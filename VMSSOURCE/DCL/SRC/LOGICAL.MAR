	.TITLE	LOGICAL - LOGICAL NAME COMMANDS
	.IDENT	'V04-000'
 
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; LOGICAL NAME DCLS COMMAND EXECUTION
;
;	ALLOCATE DEVICE
;	ASSIGN LOGICAL NAME
;	DEALLOCATE DEVICE
;	DEASSIGN LOGICAL NAME
;	DEFINE LOGICAL NAME
;	CREATE LOGICAL NAME TABLE
;	SHOW LOGICAL NAME TRANSLATION
;
; Peter George 20-April-1983
;
; MODIFIED BY:
;
;	V03-007	HWS0078		Harold Schultz		02-Jul-1984
;		Fix negation of table qualifiers in ASSIGN, DEASSIGN,
;		and DEFINE commands.
;
;	V03-006	HWS0041		Harold Schultz		12-Apr-1984
;		Add ALLOCATE /GENERIC.
;
;	V03-005	PCG0003		Peter George		20-Mar-1984
;		Add /JOB qualifier.
;
;	V03-004	HWS0005		Harold Schultz		07-Feb-1984
;		Added /PROTECTION=(SY:RWED,OW:RWED,...) qualifier for
;		when creating a logical name table.
;		Add /LOG qualifier when creating a logical name table.
;		Output informational messages after table creation.
;
;	V03-003	TMK0001		Todd M. Katz		12-Oct-1983
;		Translate logical names using LNM$DCL_LOGICAL as the table
;		name instead of LNM$DEFAULT_SEARCH.
;
;	V03-002	PCG0002		Peter George		01-Jul-1983
;		Fix bug in ALLOCATE command parsing.
;		Replace old logical name commands.
;		Stop fooling around with the CRELOG bit.
;
;	V03-001	PCG0001		Peter George		15-Jun-1983
;		Return more helpful status when ALLOCATE fails.
;		Pass equivalence name to DCL$OPEN_OUTPUT.
;---

;
; MACRO LIBRARY CALLS
;
 
	PRCDEF				;DEFINE PROCESS WORK AREA
	WRKDEF				;DEFINE COMMAND WORK AREA
	PTRDEF				;DEFINE RESULT PARSE DESCRIPTOR FORMAT
	$CLIMSGDEF			;DEFINE ERROR/STATUS VALUES
	$LNMDEF				;DEFINE LOGICAL NAME OFFSETS
	$PSLDEF				;DEFINE PROCESSOR STATUS FIELDS
	$SSDEF				;DEFINE SYSTEM STATUS VALUES
 
	.PSECT	DCL$ZCODE,BYTE,RD,NOWRT

;
; LOCAL DATA
;
OUTPUTNAM:
	.ASCIC	'SYS$OUTPUT'
LNM$PROCESS:
	.ASCIC	'LNM$PROCESS'
LNM$JOB:
	.ASCIC	'LNM$JOB'
LNM$GROUP:
	.ASCIC	'LNM$GROUP'
LNM$SYSTEM:
	.ASCIC	'LNM$SYSTEM'
LNM$DCL_LOGICAL:
	.ASCIC	'LNM$DCL_LOGICAL'
LNM$PROCESS_DIRECTORY:
	.ASCIC	'LNM$PROCESS_DIRECTORY'
LNM$FILE_DEV:
	.ASCIC	'LNM$FILE_DEV'
UNDEFINED:
	.ASCIC	'UNDEFINED'
LOGICALMSG:
	.ASCIC	'  !AS = "!AS"  (!AS)'
ACCESS:	.ASCII	/DEWR/			;ACCESS PROTECTION CODES
CLASS:	.ASCII	/WGOS/			;PROTECTION CLASSES
;
; DEFINE OFFSETS FOR COMMON PARSING DATA STRUCTURE
;
	EQUNAM = 32
	LOGNAM = 24
	TABNAM = 16
	ACMODE = 12
	QUAL = 8
	DEF_PROT = ^XFF00
	LOG_V = 0
	LOG_M = 1
	ATTR_V = 1
	ATTR_M = 2
	DEF_V = 2
	DEF_M = 4
	NAME_ATTR = 4
	TRAN_ATTR = 0


	.SBTTL	ALLOCATE DEVICE
;+
; DCL$ALLOCATE - ALLOCATE DEVICE
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO EXECUTE THE ALLOCATE
; COMMAND.
;
; INPUTS:
;
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; OUTPUTS:
;
;	THE SPECIFIED DEVICE IS ALLOCATED AND ASSIGNED THE SPECIFIED LOGICAL
;	NAME. IF THE LOGICAL NAME WAS PREVIOUSLY ASSIGNED, THEN A MESSAGE TO
;	THAT EFFECT IS WRITTEN TO THE OUTPUT STREAM.
;-
DCL$ALLOCATE::				;ALLOCATE DEVICE
;
; Allocate and init common logical name data structure.
;
	SUBL	#16,R9				;ALLOCATE PHYSICAL DEV BUFFER
	MOVL	R9,-(R9)			;INIT THE EQUIV NAME DESCR
	MOVZWL	#16,-(R9)			;
	CLRQ	-(R9)				;ALLOCATE LOG NAME DESCR
	MOVAB	LNM$FILE_DEV,R5			;SET LOGICAL NAME TABLE
	MOVZBL	(R5)+,R4			;
	MOVQ	R4,-(R9)			;SAVE THE DESCRIPTOR
	MOVL	#PSL$C_SUPER,-(R9)		;AND SUPERVISOR MODE
	MOVL	#LOG_M,-(R9)			;ASSUME /LOG DEFAULTED
	CLRQ	-(R9)				;SET DEFAULT NAME/TRAN ATTRIBUTES
	MOVL	R9,R8				;COPY THE BASE OF THE DATA STRUCTURE
	CLRL	-(R9)				;ALLOCATE /TYPE VALUE 

	CLRL	R6				;SET NO TERMINATOR YET
	MOVZWL	#SS$_NOSUCHDEV,R7		;PRESET ERROR STATUS

;
; Process /log and /type command qualifiers.
;
10$:	BSBW	DCL$GETDVAL			;GET NEXT TOKEN
	CMPB	R5,#PTR_K_PARAMETR		;PARAMETER VALUE?
	BEQL	40$				;YES, THEN NO /GENE OR /LOG
	BSBW	DCL$GETNVAL			;GET QUALIFIER TYPE
	CMPB	#CLI$K_ALLO_GENE,R1		;IS IT /GENE
	BEQL	20$				;YES, THEN BRANCH
	BISL	#LOG_M,QUAL(R8)			;ASSUME /LOG
	BLBC	R3,10$				;BRANCH IF SO
	BICL	#LOG_M,QUAL(R8)			;SET /NOLOG
	BRB	10$				;GET NEXT TOKEN
20$:	CLRL	(R9)				;ASSUME /NOGENERIC
	BLBS	R3,10$				;BRANCH IF SO
	MOVL	#1,(R9)				;IT WAS /GENERIC
	BRB	10$				;GET NEXT TOKEN	

;
; Return allocation error.
;
90$:	MOVL	R7,R0				;SET ERROR STATUS
	RSB					;EXIT

;
; Process the device names.
;
30$:	BSBW	DCL$GETDVAL			;GET NEXT TOKEN
	CMPB	R6,#PTR_K_COMMA			;ANOTHER PARAMETER VALUE IN LIST?
	BNEQ	90$				;NO, THEN ERROR
40$:	CMPB	R5,#PTR_K_PARAMETR		;PARAMETER VALUE?
	BNEQ	90$				;NO, THEN ERROR
	MOVL	R4,R6				;SAVE TOKEN TERMINATOR
	BSBW	DCL$COMPSTRING			;REMOVE ANY DOUBLE QUOTES
	MOVQ	R1,LOGNAM(R8)			;SAVE THE DESCRIPTOR
	CMPB	#^A/:/,-1(R2)[R1]		;DEVICE NAME END WITH A COLON?
	BNEQ	50$				;IF NEQ NO
	DECL	LOGNAM(R8)			;REDUCE LENGTH OF DEVICE NAME
50$:	MOVL	(R9),R0				;GET /GENERIC INDICATOR
	$ALLOC_S  LOGNAM(R8),EQUNAM(R8),-	;ALLOCATE DEVICE
		EQUNAM(R8),#0,R0		;
	MOVL	R0,R7				;SAVE FINAL STATUS
	BLBC	R0,30$				;IF ERROR, TRY NEXT DEVICE IN LIST

;
; Output the device allocated message.
;
	BBC	#LOG_V,QUAL(R8),80$		;SKIP IF /NOLOG
	PUSHAQ	EQUNAM(R8)			;PUSH DESCRIPTOR ADDRESS
	MOVL	#1,R1				;SET ARG COUNT
	MOVL	#CLI$_ALLOC,R0			;SET STATUS
	BSBW	DCL$FORMMSG			;OUTPUT INFORMATIONAL MESSAGE

;
; Get the requested logical name.
;
80$:	BSBW	DCL$GETDVAL			;GET NEXT PARAMETER VALUE
	CMPB	R5,#PTR_K_PARAMETR		;PARAMETER VALUE?
	BEQL	60$				;CONTINUE IF LOGICAL NAME FOUND
	BRB	95$				;EXIT IF NOT
60$:	CMPB	R6,#PTR_K_COMMA			;STILL IN P1 LIST?
	BNEQ	70$				;IF P2 FOUND, ASSIGN THE LOGICAL NAME
	MOVL	R4,R6				;COPY TERMINATOR TYPE CODE
	BRB	80$				;LOOP UNTIL P2 OR EOL FOUND

70$:	BSBW	DCL$COMPSTRING			;REMOVE QUOTATION MARKS
	CMPB	#^A/:/,-1(R2)[R1]		;LOGICAL NAME END WITH COLON?
	BNEQ	75$				;IF NEQ NO
	DECL	R1				;REDUCE LENGTH OF LOGICAL NAME
75$:	MOVQ	R1,LOGNAM(R8)			;SAVE THE LOGICAL NAME

;
; Create the required item list.
;
	CLRQ	-(SP)				;TERMINATE THE LIST, ZERO LEN ADDR
	MOVQ	EQUNAM(R8),-(SP)		;SET THE EQUIV NAME DESCR
	MOVW	#LNM$_STRING,2(SP)		;SET THE ITEM TYPE
	MOVL	SP,R7				;GET THE ITEM LIST ADDRESS

	$CRELNM_S  ATTR=NAME_ATTR(R8),-		;CREATE THE REQUESTED NAME
		TABNAM=TABNAM(R8),-		;
		LOGNAM=LOGNAM(R8),-		;
		ACMODE=ACMODE(R8),-		;
		ITMLST=(R7)			;

	ADDL	#4*4,SP				;POP THE ITEM LIST

;
; Output informational message if appropriate.
;
	CMPW	#SS$_SUPERSEDE,R0		;PREVIOUS ASSIGNMENT SUPERSEDED?
	BNEQ	96$				;IF NEQ NO
	BBC	#LOG_V,QUAL(R8),95$		;BRANCH IF /NOLOG
	PUSHAB	LOGNAM(R8)			;SET LOGICAL NAME ADDRESS
	MOVL	#1,R1				;SET FAO COUNT
	MOVL	#CLI$_SUPERSEDE,R0		;SET STATUS
	BSBW	DCL$FORMMSG			;OUTPUT MESSAGE

95$:	STATUS	NORMAL				;RETURN SUCCESS
96$:	RSB					;EXIT

	.SBTTL	ASSIGN LOGICAL NAME TO EQUIVALENCE STRING
;+
; DCL$ASSIGN - ASSIGN LOGICAL NAME TO EQUIVALENCE STRING
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO EXECUTE THE ASSIGN
; COMMAND.
;
; INPUTS:
;
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; OUTPUTS:
;
;	THE SPECIFIED LOGICAL NAME IS ASSIGNED TO THE SPECIFIED EQUIVALENCE
;	STRING. IF A PREVIOUS LOGICAL ASSIGNMENT IS SUPERSEDED, THEN A
;	MESSAGE TO THAT EFFECT IS WRITTEN TO THE OUTPUT STREAM.
;-
 
DCL$ASSIGN::					;ASSIGN LOGICAL NAME TO EQUIVALENCE STRING
;
; Parse the common qualifiers and the logical name string.
;
	BSBW	COMMON_QUAL			;PROCESS COMMON QUALIFIERS
	CLRQ	-(R9)				;ALLOCATE SPACE FOR EQUIV NAME
	MOVQ	LOGNAM(R8),R1			;GET EQUIV NAME DESCR
	BSBW	DCL$COMPRESS			;COMPRESS THE STRING
	MOVQ	R1,EQUNAM(R8)			;SAVE EQUIV NAME

;
; Init the item list.  Insert the default translation attributes.
;
	MOVAB	-64*6*4-4(SP),SP		;ALLOCATE ROOM FOR A 128 ITEM LIST
	MOVL	SP,R7				;SAVE THE ADDRESS OF THE LIST

	MOVL	#LNM$_ATTRIBUTES@16+4,(R7)+	;SET THE ITEM TYPE
	MOVAL	TRAN_ATTR(R8),(R7)+		;SET THE DEFAULT ATTRIBUTES ADDR
	CLRL	(R7)+				;ZERO THE RETURN LENGTH ADDR
	MOVL	#1,R6				;MARK DEFAULT ATTRIBUTES SET

;
; Loop getting equivalence strings and their attributes.  
; Build the item list.
;
25$:	BSBW	GET_TRAN_ATTR			;CHECK FOR NEW TRAN ATTRIBUTES
	BLBC	R0,30$				;BRANCH IF NO LOCAL QUALIFIER
	MOVL	#LNM$_ATTRIBUTES@16+4,(R7)+	;SET THE ITEM TYPE
	MOVL	R3,-(R9)			;SAVE THE ATTRIBUTES
	MOVL	R9,(R7)+			;SET THE ATTRIBUTES ADDR
	CLRL	(R7)+				;ZERO THE RETURN LENGTH ADDR
	CLRL	R6				;MARK NEW ATTRIBUTES SET
	BRB	40$				;PROCESS THE PARAMETER
30$:	BLBS	R6,40$				;SKIP IF DEFAULTS IN EFFECT
	MOVL	#LNM$_ATTRIBUTES@16+4,(R7)+	;SET THE ITEM TYPE
	MOVAL	TRAN_ATTR(R8),(R7)+		;SET THE DEFAULT ATTRIBUTES ADDR
	CLRL	(R7)+				;ZERO THE RETURN LENGTH ADDR
	MOVL	#1,R6				;MARK NEW ATTRIBUTES SET

40$:	MOVQ	EQUNAM(R8),(R7)+		;SAVE THE EQUIV NAME DESCR
	MOVW	#LNM$_STRING,-6(R7)		;SET THE ITEM TYPE
	CLRL	(R7)+				;ZERO THE RETURN LENGTH ADDR
	SUBL3	#PTR_K_LENGTH,-			;GET ADDRESS OF TOKEN DESCRIPTOR
		WRK_L_RSLNXT(R10),R0		;
	CMPB	PTR_B_PARMCNT(R0),#2		;HAVE WE FOUND THE LOGICAL NAME?
	BEQL	43$				;YES, THEN TERMINATE ITEM LIST
	BSBW	DCL$COMPRESS			;COMPRESS THE STRING
	MOVQ	R1,EQUNAM(R8)			;STORE THE LATEST STRING DESCR
	BRB	25$				;CHECK FOR NEW ATTRIBUTES

43$:	CLRL	(R7)+				;TERMINATE THE LIST

;
; Process logical name string.
;
	BSBW	DCL$COMPSTRING			;REMOVE QUOTATION MARKS
	CMPB	#^A/:/,-1(R2)[R1]		;LOGICAL NAME END WITH COLON?
	BNEQ	45$				;IF NEQ NO
	DECL	R1				;REDUCE LENGTH OF LOGICAL NAME
45$:	MOVQ	R1,LOGNAM(R8)			;SAVE LOGICAL NAME DESCRIPTOR
	BSBW	GET_TRAN_ATTR			;CHECK FOR NEW TRAN ATTRIBUTES
	BLBC	R0,47$				;BRANCH IF NO LOCAL QUALIFIER
	MOVL	R3,TRAN_ATTR(R8)		;SAVE THE ATTRIBUTES
47$:	BRW	COMMON_CRELNM			;CREATE THE LOGICAL NAME

	.SBTTL	DEFINE LOGICAL NAME EQUIVALENCE
;+
; DCL$DEFINE - DEFINE LOGICAL NAME EQUIVALENCE
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO EXECUTE THE DEFINE
; COMMAND.
;
; INPUTS:
;
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; OUTPUTS:
;
;	THE SPECIFIED LOGICAL NAME IS ASSIGNED TO THE SPECIFIED EQUIVALENCE
;	STRING. IF A PREVIOUS LOGICAL ASSIGNMENT IS SUPERSEDED, THEN A
;	MESSAGE TO THAT EFFECT IS WRITTEN TO THE OUTPUT STREAM.
;-
 
DCL$DEFINE::					;DEFINE LOGICAL NAME EQUIVALENCE
;
; Parse the common qualifiers and the logical name string.
;
	BSBW	COMMON_QUAL			;PROCESS COMMON QUALIFIERS
	CLRQ	-(R9)				;ALLOCATE SPACE FOR EQUIVALENCE NAME
	MOVQ	LOGNAM(R8),R1			;GET LOGICAL NAME DESCR
	BSBW	DCL$COMPSTRING			;REMOVE QUOTES FROM LOGICAL NAME
	MOVQ	R1,LOGNAM(R8)			;SAVE LOGICAL NAME

;
; Init the item list.  Insert the default translation attributes.
;
	MOVAB	-64*6*4-4(SP),SP		;ALLOCATE ROOM FOR A 128 ITEM LIST
	MOVL	SP,R7				;SAVE THE ADDRESS OF THE LIST

	MOVL	#LNM$_ATTRIBUTES@16+4,(R7)+	;SET THE ITEM TYPE
	MOVAL	TRAN_ATTR(R8),(R7)+		;SET THE DEFAULT ATTRIBUTES ADDR
	CLRL	(R7)+				;ZERO THE RETURN LENGTH ADDR

	BSBW	GET_TRAN_ATTR			;CHECK FOR NEW TRAN ATTRIBUTES
	BLBC	R0,23$				;BRANCH IF NO LOCAL QUALIFIER
	MOVL	R3,TRAN_ATTR(R8)		;SAVE THE ATTRIBUTES
23$:	BSBW	DCL$COMPRESS			;COMPRESS THE STRING
	MOVQ	R1,EQUNAM(R8)			;LOAD THE PIPELINE
	MOVL	#1,R6				;MARK DEFAULT ATTRIBUTES SET

;
; Loop getting equivalence strings and their attributes.  
; Build the item list.
;
25$:	BSBW	GET_TRAN_ATTR			;CHECK FOR NEW TRAN ATTRIBUTES
	BLBC	R0,30$				;BRANCH IF NO LOCAL QUALIFIER
	MOVL	#LNM$_ATTRIBUTES@16+4,(R7)+	;SET THE ITEM TYPE
	MOVL	R3,-(R9)			;SAVE THE ATTRIBUTES
	MOVL	R9,(R7)+			;SET THE ATTRIBUTES ADDR
	CLRL	(R7)+				;ZERO THE RETURN LENGTH ADDR
	CLRL	R6				;MARK NEW ATTRIBUTES SET
	BRB	40$				;PROCESS THE PARAMETER
30$:	BLBS	R6,40$				;SKIP IF DEFAULTS IN EFFECT
	MOVL	#LNM$_ATTRIBUTES@16+4,(R7)+	;SET THE ITEM TYPE
	MOVAL	TRAN_ATTR(R8),(R7)+		;SET THE DEFAULT ATTRIBUTES ADDR
	CLRL	(R7)+				;ZERO THE RETURN LENGTH ADDR
	MOVL	#1,R6				;MARK NEW ATTRIBUTES SET

40$:	MOVQ	EQUNAM(R8),(R7)+		;SAVE THE EQUIV NAME DESCR
	MOVW	#LNM$_STRING,-6(R7)		;SET THE ITEM TYPE
	CLRL	(R7)+				;ZERO THE RETURN LENGTH ADDR
	CMPB	#PTR_K_ENDLINE,R5		;EOL?
	BEQL	43$				;YES, THEN TERMINATE ITEM LIST
	BSBW	DCL$COMPRESS			;COMPRESS THE STRING
	MOVQ	R1,EQUNAM(R8)			;STORE THE LATEST STRING DESCR
	BRB	25$				;CHECK FOR NEW ATTRIBUTES

43$:	CLRL	(R7)+				;TERMINATE THE LIST


;
; Check for SYS$OUTPUT.  Do special processing if appropriate.
;
COMMON_CRELNM:
	SUBL	#6*4+4,R7			;WAS MORE THAN ONE VALUE SUPPLIED
	CMPL	R7,SP				;
	BNEQ	45$				;YES, THEN BRANCH
	BSBW	TESTOUT				;IS LOGICAL NAME SYS$OUTPUT?
	BEQL	80$				;YES, THEN BRANCH

;
; Create the requested logial names.
;
45$:	BBC	#ATTR_V,QUAL(R8),47$		;BRANCH IF QUALIFIER NOT SEEN
;	BICL	#LNM$M_CRELOG,NAME_ATTR(R8)	;DISABLE CRELOG ATTRIBUTE
47$:	MOVL	SP,R7				;GET THE ITEM LIST ADDRESS
	$CRELNM_S  ATTR=NAME_ATTR(R8),-		;CREATE THE REQUESTED NAME
		TABNAM=TABNAM(R8),-		;
		LOGNAM=LOGNAM(R8),-		;
		ACMODE=ACMODE(R8),-		;
		ITMLST=(R7)			;

;
; Output informational message if appropriate.
;
	CMPW	#SS$_SUPERSEDE,R0		;PREVIOUS ASSIGNMENT SUPERSEDED?
	BNEQ	60$				;IF NEQ NO
	BBC	#LOG_V,QUAL(R8),50$		;BRANCH IF /NOLOG
	PUSHAB	LOGNAM(R8)			;SET LOGICAL NAME ADDRESS
	MOVL	#1,R1				;SET FAO COUNT
	MOVL	#CLI$_SUPERSEDE,R0		;SET STATUS
	BSBW	DCL$FORMMSG			;OUTPUT MESSAGE

50$:	STATUS	NORMAL				;SET NORMAL COMPLETION
60$:	MOVAB	64*6*4+4(SP),SP			;RESTORE THE STACK
	RSB					;

;
; Update SYS$OUTPUT.
;
80$:	MOVQ	EQUNAM(R8),R1			;GET DESCRIPTOR OF EQUIVALENCE NAME
	BSBW	DCL$OPEN_OUTPUT			;OPEN SPECIFIED OUTPUT FILE
	BLBC	R0,60$				;LEAVE EVERYTHING ALONE IF ERROR
	MOVL	PRC_L_IDFLNK(R11),R8		;POINT TO THE SYS$OUTPUT INFORMATION
	BSBW	DCL$CREATE_OUTPUT		;CREATE THE SYS$OUTPUT LOGICAL NAME
	BRB	50$				;

	.SBTTL	DEALLOCATE DEVICE
;+
; DCL$DEALLOCAT - DEALLOCATE DEVICE
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO EXECUTE THE DEALLOCATE
; DCLS COMMAND.
;
; INPUTS:
;
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; OUTPUTS:
;
;	THE SPECIFIED DEVICE IS DEALLOCATED OR ALL DEVICES ARE DEALLOCATED.
;-
 
DCL$DEALLOCAT::				;DEALLOCATE DEVICE
	BSBW	DCL$GETDVAL		;GET TOKEN DESCRIPTOR
	CMPB	#PTR_K_PARAMETR,R5	;ITEM TYPE PARAMETER?
	BEQL	10$			;YES, PROCESS IT
	CLRL	R9			;NO, ASSUME /ALL
	BRB	90$			;DEALLOCATE THEM ALL
10$:	BSBW	DCL$COMPSTRING		;REMOVE EXTERNAL QUOTATION MARKS
	MOVQ	R1,-(R9)		;SAVE LOGICAL NAME
	CMPB	#^A/:/,-1(R2)[R1]	;STRING END WITH A COLON
	BNEQ	90$			;BR IF NO
	DECL	(R9)			;REMOVE COLON FROM STRING
90$:	$DALLOC_S (R9)			;DEALLOCATE DEVICE
	RSB				;

	.SBTTL	DEASSIGN LOGICAL NAME EQUIVALENCE
;+
; DCL$DEASSIGN - DEASSIGN LOGICAL NAME EQUIVALENCE
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO EXECUTE THE DEASSIGN DCLS
; COMMAND.
;
; INPUTS:
;
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; OUTPUTS:
;
;	THE SPECIFIED LOGICAL NAME EQUIVALENCE OR ALL LOGICAL NAME EQUIVALENCES
;	ARE DEASSIGNED.
;-
 
DCL$DEASSIGN::				;DEASSIGN LOGICAL NAME EQUIVALENCE
	BSBW	COMMON_QUAL		;PROCESS COMMON QUALIFIERS
	CLRL	R7			;ASSUME DOING /ALL
	BBC	#DEF_V,QUAL(R8),3$	;SKIP IF DEFAULTED
	BBS	#LOG_V,QUAL(R8),5$	;BR IF DOING /ALL
3$:	MOVQ	LOGNAM(R8),R1		;GET LOGICAL NAME
	BSBW	DCL$COMPSTRING		;REMOVE EXTERNAL QUOTATION MARKS
	MOVQ	R1,LOGNAM(R8)		;SAVE LOGICAL NAME
	MOVAQ	LOGNAM(R8),R7		;COPY THE DESCRIPTOR ADDRESS
	CMPB	#^A/:/,-1(R2)[R1]	;STRING END WITH A COLON
	BNEQ	5$			;BR IF NO
	DECL	LOGNAM(R8)		;REMOVE COLON FROM STRING
5$:	BSBB	TESTOUT			;IS LOGICAL NAME SYS$OUTPUT?
	BEQL	10$			;YES, THEN SKIP
	$DELLNM_S  TABNAM=TABNAM(R8),-	;DEASSIGN LOGICAL NAME EQUIVALENCE
		LOGNAM=(R7),-		;
		ACMODE=ACMODE(R8)	;
	TSTL	R7			;DEASSIGN/ALL?
	BEQL	20$			;YES, THEN RECREATE SYS$OUTPUT
	RSB				;

10$:	MOVAB	PRC_W_OUTIFI(R11),R2	;GET ADDRESS OF SYS$OUTPUT INFORMATION
	MOVL	PRC_L_IDFLNK(R11),R8	;GET ADDRESS OF CURRENT IDF BLOCK
	BSBW	DCL$RESTORE_OUTPUT	;RESTORE PROCESS PERMANENT SYS$OUTPUT
20$:	MOVL	PRC_L_IDFLNK(R11),R8	;GET ADDRESS OF CURRENT IDF BLOCK
	BSBW	DCL$CREATE_OUTPUT	;CREATE SYS$OUTPUT LOGICAL NAME
	RSB

	.SBTTL	TEST IF LOGICAL NAME IS SYS$OUTPUT
;
; SUBROUTINE TO TEST IF LOGICAL NAME IS SYS$OUTPUT
;
; ON OUTPUT, 'Z'= 1 IF SYS$OUTPUT IS SPECIFIED
;
; CLOBBERS R0-R3
; 
TESTOUT:
	TSTL	LOGNAM(R8)		;WAS A LOGICAL NAME SPECIFIED?
	BEQL	20$			;RETURN IF NOT
	BBS	#ATTR_V,QUAL(R8),20$	;BRANCH IF ATTRIBUTES SPECIFIED
	CMPL	#PSL$C_USER,ACMODE(R8)	;IS LOGICAL NAME USER MODE?
	BEQL	20$			;YES, THEN RETURN
	CMPB	LNM$PROCESS,TABNAM(R8)	;COMPARE LENGTH OF TABLE NAME
	BNEQ	20$			;RETURN IF NOT EQUAL
	CMPC	TABNAM(R8),@TABNAM+4(R8),-;COMPARE ACTUAL STRING
		LNM$PROCESS+1  		;
	BNEQ	20$			;RETURN IF NOT EQUAL
	CMPB	OUTPUTNAM,LOGNAM(R8)	;COMPARE LENGTH OF OUTPUT
	BNEQ	20$			;RETURN IF NOT EQUAL
	CMPC	LOGNAM(R8),@LOGNAM+4(R8),-;COMPARE ACTUAL STRING
		OUTPUTNAM+1		;
10$:	RSB				;

20$:	TSTL	#1			;SET FAILURE STATUS
	RSB				;

	.SBTTL	PROCESS COMMON COMMAND QUALIFIERS
;
; SUBROUTINE TO PROCESS COMMON COMMAND QUALIFIERS
;
; ON INPUT,  R9 = ADDRESS OF SCRATCH STACK
;
; ON OUTPUT, SCRATCH STACK LOOKS LIKE
;
;			  <-- R9 initially
;	;---------------;
;	; Logical name	; LOGNAM(R8)
;	;  descriptor	;
;	;---------------;
;	;  Table name	; TABNAM(R8)
;	;  descriptor	;
;	;---------------;
;	;  Access mode	; ACMODE(R8)
;	;---------------;
;	; Qual flags	; QUAL(R8)
;	;---------------;	
;	; Def name attr	; NAME_ATTR(R8)
;	;---------------;
;	; Def tran attr ; TRAN_ATTR(R8) <-- R8,R9 finally
;	;---------------;
;
;
COMMON_QUAL:
	CLRQ	-(R9)				;ALLOCATE SPACE FOR LOG NAME DESCR
	MOVAB	LNM$PROCESS,R5			;ASSUME PROCESS LOGICAL NAME TABLE
	MOVZBL	(R5)+,R4			;
	MOVQ	R4,-(R9)			;SAVE THE DESCRIPTOR
	MOVL	#PSL$C_SUPER,-(R9)		;AND SUPERVISOR MODE
	MOVL	#LOG_M,-(R9)			;ASSUME /LOG DEFAULTED
;	MOVL	#LNM$M_CRELOG,-(R9)		;SET DEFAULT NAME ATTRIBUTES
	CLRL	-(R9)				;SET DEFAULT NAME ATTRIBUTES
	CLRL	-(R9)				;SET DEFAULT TRAN ATTRIBUTES
	MOVL	R9,R8				;COPY THE BASE OF THE DATA STRUCTURE

10$:	BSBW	DCL$GETDVAL			;GET NEXT DESCRIPTOR VALUE
20$:	CMPB	#PTR_K_PARAMETR,R5		;ITEM TYPE PARAMETER OR EOL?
	BGTRU	30$				;NO, THEN PROCESS QUALIFIER	
	BEQL	25$				;PROCESS PARAMETER
	BRW	210$				;RETURN WITH NULL PARAMETER
25$:	BRW	200$				;PROCESS PARAMETER
30$:	BSBW	DCL$GETNVAL			;GET QUALIFIER NUMBER
	CMPL	R1,#CLI$K_DEFI_USER		;QUALIFIER MATCH?
	BEQL	100$				;YES, THEN BRANCH
	CMPL	R1,#CLI$K_DEFI_SUPE		;QUALIFIER MATCH?
	BEQL	110$				;YES, THEN BRANCH
	CMPL	R1,#CLI$K_DEFI_EXEC		;QUALIFIER MATCH?
	BEQL	120$				;YES, THEN BRANCH
	CMPL	R1,#CLI$K_DEFI_PROC		;QUALIFIER MATCH?
	BEQL	130$				;YES, THEN BRANCH
	CMPL	r1,#CLI$K_DEFI_JOB		;QUALIFIER MATCH?
	BEQL	135$				;YES, THEN BRANCH
	CMPL	R1,#CLI$K_DEFI_GROU		;QUALIFIER MATCH?
	BEQL	140$				;YES, THEN BRANCH
	CMPL	R1,#CLI$K_DEFI_SYST		;QUALIFIER MATCH?
	BEQL	150$				;YES, THEN BRANCH
	CMPL	R1,#CLI$K_DEFI_TABL		;QUALIFIER MATCH?
	BNEQ	60$				;NO, CHECK NEXT
	BRW	160$				;YES, THEN BRANCH
60$:	CMPL	R1,#CLI$K_DEFI_LOG		;QUALIFIER MATCH? (ALSO DEASSIGN/ALL)
	BNEQ	70$				;NO, CHECK NEXT
	BRW	170$				;YES, THEN BRANCH
70$:	CMPL	R1,#CLI$K_DEFI_NAME		;QUALIFIER MATCH?
	BNEQ	80$				;NO, CHECK NEXT
	BRW	180$				;YES, THEN BRANCH
80$:	CMPL	R1,#CLI$K_DEFI_TRAN		;QUALIFIER MATCH?
	BNEQ	10$				;NO, IGNORE IT
	BRW	190$				;YES, THEN BRANCH

100$:	MOVL	#PSL$C_USER,ACMODE(R8)		;SET USER MODE
	BRW	171$				;GET NEXT TOKEN
110$:	MOVL	#PSL$C_SUPER,ACMODE(R8)		;SET SUPER MODE
	BRB	171$				;GET NEXT TOKEN
120$:	MOVL	#PSL$C_EXEC,ACMODE(R8)		;SET EXEC MODE
	BRB	171$				;GET NEXT TOKEN

130$:	MOVAB	LNM$PROCESS,R5			;USE PROCESS LOGICAL NAME TABLE
	MOVZBL	(R5)+,R4			;
	MOVQ	R4,TABNAM(R8)			;SAVE THE DESCRIPTOR
	BRB	171$				;GET NEXT TOKEN

135$:	MOVAB	LNM$PROCESS,R5			;ASSUME /NOJOB
	BBS	#PTR_V_NEGATE-PTR_V_FLAGS,R3,137$  ;BR IF /NOJOB
	MOVAB	LNM$JOB,R5			;USE JOB LOGICAL NAME TABLE
137$:	MOVZBL	(R5)+,R4			;
	MOVQ	R4,TABNAM(R8)			;SAVE THE DESCRIPTOR
	BRB	171$				;GET NEXT TOKEN

140$:	MOVAB	LNM$PROCESS,R5			;ASSUME /NOGROUP
	BBS	#PTR_V_NEGATE-PTR_V_FLAGS,R3,147$  ;BR IF /NOGROUP
	MOVAB	LNM$GROUP,R5			;USE GROUP LOGICAL NAME TABLE
147$:	MOVZBL	(R5)+,R4			;
	MOVQ	R4,TABNAM(R8)			;SAVE THE DESCRIPTOR
	BRB	171$				;GET NEXT TOKEN

150$:	MOVAB	LNM$PROCESS,R5			;ASSUME /NOSYSTEM
	BBS	#PTR_V_NEGATE-PTR_V_FLAGS,R3,157$  ;BR IF /NOSYSTEM
	MOVAB	LNM$SYSTEM,R5			;USE SYSTEM LOGICAL NAME TABLE
157$:	MOVZBL	(R5)+,R4			;
	MOVQ	R4,TABNAM(R8)			;SAVE THE DESCRIPTOR
	BRB	171$				;GET NEXT TOKEN

160$:	MOVAB	LNM$PROCESS,R5			;ASSUME PROCESS LOGICAL NAME TABLE
	MOVZBL	(R5)+,R4			;
	MOVQ	R4,TABNAM(R8)			;SAVE THE DESCRIPTOR
	BLBS	R3,171$				;BRANCH IF NEGATED
	BSBW	DCL$GETDVAL			;GET THE TABLE NAME
	MOVQ	R1,TABNAM(R8)			;SAVE IT AWAY
	BRB	171$				;GET NEXT TOKEN

170$:	BISL	#LOG_M!DEF_M,QUAL(R8)		;ASSUME /LOG OR /ALL
	BLBC	R3,171$				;BRANCH IF SO
	BICL	#LOG_M,QUAL(R8)			;SET /NOLOG OR /NOALL
171$:	BRW	10$				;GET NEXT TOKEN
172$:	BRW	20$				;PROCESS THE TOKEN

180$:	BISL	#ATTR_M,QUAL(R8)		;MARK /NAME_ATTRIBUTES SEEN
	CLRL	NAME_ATTR(R8)			;ZERO INITIAL ATTRIBUTES
	BLBS	R3,171$				;BRANCH IF NEGATED
182$:	BSBW	DCL$GETDVAL			;GET ITS VALUE
	CMPB	R5,#PTR_K_QUALVALU		;SKIP IF NOT A QUALIFIER VALUE
	BNEQ	172$				;
	CMPB	(R2),#^A/C/			;CONFINE KEYWORD?
	BNEQ	184$				;NO, THEN BRANCH
	BISL	#LNM$M_CONFINE,NAME_ATTR(R8)	;SET THE ATTRIBUTE
	BRB	182$				;GET NEXT VALUE
184$:	BISL	#LNM$M_NO_ALIAS,NAME_ATTR(R8)	;SET THE ATTRIBUTE
	BRB	182$				;GET NEXT VALUE

190$:	BISL	#ATTR_M,QUAL(R8)		;MARK /TRANSLATION_ATTRIBUTES SEEN
	CLRL	TRAN_ATTR(R8)			;ZERO INITIAL ATTRIBUTES
	BLBS	R3,171$				;BRANCH IF NEGATED
192$:	BSBW	DCL$GETDVAL			;GET ITS VALUE
	CMPB	R5,#PTR_K_QUALVALU		;SKIP IF NOT A QUALIFIER VALUE
	BNEQ	172$				;
	CMPB	(R2),#^A/C/			;CONCEALED KEYWORD?
	BNEQ	194$				;NO, THEN BRANCH
	BISL	#LNM$M_CONCEALED,TRAN_ATTR(R8)	;SET THE ATTRIBUTE
	BRB	192$				;GET NEXT VALUE
194$:	BISL	#LNM$M_TERMINAL,TRAN_ATTR(R8)	;SET THE ATTRIBUTE
	BRB	192$				;GET NEXT VALUE

200$:	MOVQ	R1,LOGNAM(R8)			;GET FIRST PARAMETER DESCRIPTOR
210$:	RSB					;


	.SBTTL	GET TRANSLATION ATTRIBUTES
;
; SUBROUTINE TO PROCESS TRANSLATION ATTRIBUTES
;
;	R0 = QUALIFIER SEEN FLAG
;	R1/R2 = DESCR OF NEXT PARAMETER
;	R3 = TRANSLATION ATTRIBUTES
;	R5 = TYPE OF LAST TOKEN SEEN
;
GET_TRAN_ATTR:					;GET TRAN ATTRIBUTES
	CLRQ	-(SP)				;ASSUME QUALIFIER NOT SEEN
10$:	BSBW	DCL$GETDVAL			;GET NEXT DESCRIPTOR VALUE
20$:	CMPB	#PTR_K_PARAMETR,R5		;ITEM TYPE PARAMETER?
	BLEQ	90$				;IF LEQ END OF LINE OR PARAMETER
	MOVL	#1,4(SP)			;MARK QUALIFIER SEEN
	CLRL	(SP)				;RESET ATTRIBUTES
	BISL	#ATTR_M,QUAL(R8)		;MARK /TRANSLATION_ATTRIBUTES SEEN
	BLBS	R3,10$				;BRANCH IF NEGATED
30$:	BSBW	DCL$GETDVAL			;GET ITS VALUE
	CMPB	R5,#PTR_K_QUALVALU		;SKIP IF NOT A QUALIFIER VALUE
	BNEQ	20$				;
	CMPB	(R2),#^A/C/			;CONCEALED KEYWORD?
	BNEQ	40$				;NO, THEN BRANCH
	BISL	#LNM$M_CONCEALED,(SP)		;SET THE ATTRIBUTE
	BRB	30$				;GET NEXT VALUE
40$:	BISL	#LNM$M_TERMINAL,(SP)		;SET THE ATTRIBUTE
	BRB	30$				;GET NEXT VALUE

90$:	POPL	R3				;RETURN ATTRIBUTES AND STATUS
	POPL	R0				;
	RSB					;

	.SBTTL	CREATE LOGICAL NAME TABLE
;+
; DCL$CRETABLE - CREATE LOGICAL NAME TABLE
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO EXECUTE THE
; CREATE/NAME_TABLE COMMAND.
;
; INPUTS:
;
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; OUTPUTS:
;
;	THE SPECIFIED LOGICAL NAME TABLE IS CREATED.
;-
 
DCL$CRETABLE::					;CREATE A LOGICAL NAME TABLE
	CLRL	-(R9)				;ASSUME /LOG
	MOVZWL	#DEF_PROT,-(R9)			;SET DEFAULT TABLE PROTECTION
						;(SY:RWED,OW:RWED,GR,WO)

	MOVL	#PSL$C_SUPER,-(R9)		;ASSUME SUPERVISOR MODE ACMODE
	CLRL	-(R9)				;ASSUEM /NOQUOTA
	MOVL	#LNM$M_CREATE_IF,-(R9)		;ASSUME /NOATTR
	MOVAB	LNM$PROCESS_DIRECTORY,R1	;ASSUME /NOPARENT
	MOVZBL	(R1)+,R0			;
	MOVQ	R0,-(R9)			;SAVE THE DESCRIPTOR

10$:	BSBW	DCL$GETDVAL			;GET NEXT DESCRIPTOR VALUE
20$:	CMPB	#PTR_K_PARAMETR,R5		;ITEM TYPE PARAMETER?
	BNEQ	30$				;NO, THEN PROCESS QUALIFIER
	BRW	200$				;YES, THEN DONE

30$:	BSBW	DCL$GETNVAL			;GET QUALIFIER NUMBER
	CMPL	R1,#CLI$K_CRET_USER		;QUALIFIER MATCH?
	BEQL	100$				;YES, THEN BRANCH
	CMPL	R1,#CLI$K_CRET_SUPE		;QUALIFIER MATCH?
	BEQL	110$				;YES, THEN BRANCH
	CMPL	R1,#CLI$K_CRET_EXEC		;QUALIFIER MATCH?
	BEQL	120$				;YES, THEN BRANCH
	CMPL	R1,#CLI$K_CRET_QUOT		;QUALIFIER MATCH?
	BEQL	130$				;YES, THEN BRANCH
	CMPL	R1,#CLI$K_CRET_ATTR		;QUALIFIER MATCH?
	BEQL	140$				;YES, THEN BRANCH
	CMPL	R1,#CLI$K_CRET_PARE		;QUALIFIER MATCH?
	BEQL	150$				;YES, THEN BRANCH
	CMPL	R1,#CLI$K_CRET_PROT		;QUALIFIER MATCH?
	BNEQ	40$				;NO
	BRW	160$				;YES, THEN BRANCH
40$:	CMPL	R1,#CLI$K_CRET_LOG		;QUALIFIER MATCH
	BNEQ	10$				;NO, GET NEXT TOKEN
	BRW	175$				;YES, THEN BRANCH

100$:	MOVL	#PSL$C_USER,16(R9)		;SET USER MODE
	BRB	10$				;GET NEXT TOKEN
110$:	MOVL	#PSL$C_SUPER,16(R9)		;SET SUPER MODE
	BRB	10$				;GET NEXT TOKEN
120$:	MOVL	#PSL$C_EXEC,16(R9)		;SET EXEC MODE
	BRB	10$				;GET NEXT TOKEN

130$:	CLRL	12(R9)				;ASSUME /NOQUOTA
	BLBS	R3,131$				;BRANCH IF SO
	BSBW	DCL$GETDVAL			;GET QUOTA VALUE
	MOVQ	R1,R2				;COPY DESCRIPTOR
	MOVL	#1,R1				;SET DECIMAL RADIX
	BSBW	DCL$CNVNOEDIT			;CONVERT NUMBER TO BINARY
	MOVL	R1,12(R9)			;SAVE THE VALUE AWAY
131$:	BRW	10$				;GET NEXT TOKEN
132$:	BRW	20$				;PROCESS NEXT TOKEN

140$:	MOVL	#LNM$M_CREATE_IF,8(R9)		;ASSUME /NOATTRIBUTES
	BLBS	R3,131$				;BRANCH IF SO
142$:	BSBW	DCL$GETDVAL			;GET ATTRIBUTE KEYWORD
	CMPB	R5,#PTR_K_QUALVALU		;SKIP IF NOT A QUALIFIER VALUE
	BNEQ	132$				;
	CMPB	(R2),#^A/N/			;NO_ALIAS KEYWORD?
	BNEQ	144$				;NO, THEN BRANCH
	BISL	#LNM$M_NO_ALIAS,8(R9)		;SET THE ATTRIBUTE
	BRB	142$				;GET NEXT VALUE
144$:	CMPB	(R2),#^A/C/			;CONFINE KEYWORD?
	BNEQ	146$				;NO, THEN BRANCH
	BISL	#LNM$M_CONFINE,8(R9)		;SET THE ATTRIBUTE
	BRB	142$				;GET NEXT VALUE
146$:	BICL	#LNM$M_CREATE_IF,8(R9)		;CLEAR THE ATTRIBUTE
	BRB	142$				;GET NEXT VALUE

150$:	MOVAB	LNM$PROCESS_DIRECTORY,R1	;ASSUME /NOPARENT
	MOVZBL	(R1)+,R0			;
	MOVQ	R0,(R9)				;SAVE THE DESCRIPTOR
	BLBS	R3,131$				;BRANCH IF SO
	BSBW	DCL$GETDVAL			;GET TABLE NAME
	MOVQ	R1,(R9)				;SAVE THE DESCRIPTOR
	BRB	131$				;GET NEXT TOKEN
;
;	SET LOGICAL NAME TABLE PROTECTION CODE
;
160$:	BSBW	DCL$GETDVAL			;GET NEXT DESCRIPTOR VALUES
	CMPB	#PTR_K_QUALVALU,R5		;QUALIFIER VALUE?
	BNEQ	132$				;NO, ALL DONE WITH PROTECTION.

	LOCC	(R2),#4,CLASS			;LOCATE PROTECTION CLASS
	BEQL	180$				;IF EQL INVALID CLASS

	DECL	R0				;CALCULATE STARTING BIT NUMBER
	MULL3	#4,R0,R8
	INSV	#^XF,R8,#4,20(R9)		;ASSUME NO ACCESS
	CMPB	#PTR_K_COLON,R4			;PROTECTION VALUE SPECIFIED?
	BNEQ	160$				;NO, TRY TO GET NEXT CLASS

	BSBW	DCL$GETDVAL			;GET PROTECTION VALUE DESCRIPTOR
	MOVL	R1,R7				;SAVE LENGTH OF VALUE STRING

165$:	LOCC	(R2)+,#4,ACCESS			;LOCATE PROTECTION CODE
	BEQL	185$				;IF EQUL INVALID PROTECTION CODE
	DECL	R0				;CALCULATE RELATIVE BIT NUMBER
	ADDL	R8,R0				;CALCULATE ACTUAL BIT NUMBER
	BBCC	R0,20(R9),170$			;ALLOW SPECIFIED ACCESS
170$:	SOBGTR	R7,165$				;ANY MORE TO SCAN?
	BRB	160$				;NO, TRY TO GET NEXT CLASS
;
;	PROCESS /LOG QUALIFIER
;
175$:	CLRB	24(R9)				;ASSUME /LOG
	BLBC	R3,176$				;IT IS /LOG. FLAG OK AS IS
	INCB	24(R9)				;IT IS /NOLOG. SET FLAG
176$:	BRW	131$				;GET NEXT TOKEN

180$:	STATUS	IVKEYW				;SET INVALID KEYWORD
	RSB					;EXIT
185$:	STATUS	IVPROT				;SET INVALID PROTECTION CODE
	RSB					;EXIT

200$:	MOVQ	R1,-(R9)			;SAVE THE LOGICAL NAME DESR

	$CRELNT_S  ATTR=16(R9),-		;CREATE THE TABLE
		QUOTA=20(R9),-			;
		TABNAM=(R9),-			;
		PARTAB=8(R9),-			;
		ACMODE=24(R9),-			;
		PROMSK=28(R9)			;

;
;	OUTPUT INFORMATION MESSAGES ABOUT THE TABLE CREATION
;
	BLBS	32(R9),280$			;SKIP IF /NOLOG
	CMPW	#SS$_NORMAL,R0			;EXISTING TABLE NOT SUPER.?
	BNEQ	210$				;NO, CHECK OTHER STATUS
	MOVL	#CLI$_TABEXIST,R0		;YES, TELL USER
	BRB	270$				;

210$:	CMPW	#SS$_SUPERSEDE,R0		;EXISTING TABLE SUPERSEDED?
	BNEQ	220$				;NO, CHECK OTHER STATUS
	MOVL	#CLI$_TABSUPER,R0		;YES, TELL USER
	BRB	270$				;

220$:	CMPW	#SS$_LNMCREATED,R0		;NEW TABLE CREATED?
	BNEQ	280$				;NO, CHECK FOR CREATION ERROR
	MOVL	#CLI$_TABNOTFND,R0		;ASSUME /SUPERSEDE SPECIFIED
	BITL	#LNM$M_CREATE_IF,16(R9)		;WAS /SUPERSEDE SPECIFIED?
	BNEQ	285$				;IF NOT, SKIP MESSAGE

270$:	PUSHAB	(R9)				;GET TABLE NAME DESCIPTOR
	MOVL	#1,R1				;SET FAO COUNT
	BSBW	DCL$FORMMSG			;OUTPUT MESSAGE
	BRB	285$				;EXIT WITH STATUS NORMAL

280$:	BLBC	R0,290$				;BRANCH IF ERROR
285$:	STATUS	NORMAL				;RETURN SUCCESS
290$:	RSB					;

	.SBTTL	SHOW LOGICAL NAME EQUIVALENCES
;+
; DCL$SHOWTRAN - SHOW LOGICAL NAME TRANSLATION
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO EXECUTE THE SHOW LOGICAL
; NAME EQUIVALENCES DCLS COMMAND.
;
; INPUTS:
;
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; OUTPUTS:
;
;	THE SPECIFIED LOGICAL NAME EQUIVALENCE FROM THE PROCESS 
;	LOGICAL NAME TABLE IS WRITTEN TO THE OUTPUT STREAM.
;-
DCL$SHOWTRAN::					;SHOW THE TRANSLATION FOR A NAME

;++
; Stack layout:
;
;	;---------------;
;	;  Table name	; 
;	;  descriptor	;
;	;---------------;
;	; Logical name	; 
;	;  descriptor	;
;	;---------------;
;	; Equival name	; 
;	;  descriptor	;
;	;---------------;
;	; Item list ...	; 
;	;		;
;
;--
;
; Parse the command string.
;
	MOVAB	LNM$DCL_LOGICAL,R1		;SET DEFAULT LOGICAL NAME TABLE
	MOVZBL	(R1)+,R0			;
	MOVQ	R0,-(SP)			;

10$:	BSBW	DCL$GETDVAL			;GET FIRST TOKEN
	CMPB	#PTR_K_PARAMETR,R5		;IS IT A PARAMETER
	BNEQ	15$				;NO, THEN PROCESS /TABLE
	ASSUME	PTR_V_KEYWORD EQ 21
	BBS	#1,R3,10$			;IGNORE OPTION KEYWORD
	BRB	20$				;PROCESS THE LOGICAL NAME

15$:	MOVAB	LNM$DCL_LOGICAL,R1		;ASSUME /NOTABLE
	MOVZBL	(R1)+,R0			;
	MOVQ	R0,(SP)				;
	BLBS	R3,10$				;BRANCH IF SO
	BSBW	DCL$GETDVAL			;GET TABLE NAME
	MOVQ	R1,(SP)				;SAVE IT
	BRB	10$				;GET NEXT TOKEN

20$:	MOVQ	R1,-(SP)			;SAVE LOGICAL NAME DESCR

;
; Create item list and perform translation.
;
	CLRL	-(SP)				;BUILD ITEM LIST
	MOVAB	-12(SP),-(SP)			;SET ADDR OF RETURN LENGTH
	MOVAB	WRK_G_INPBUF(R10),-(SP)		;BUILD TABLE NAME DESCRIPTOR
	MOVL	#LNM$_TABLE@16+WRK_C_INPBUFSIZ,-(SP) ;SET ITEM TYPE AND LENGTH
	MOVAB	-12(SP),-(SP)			;SET ADDR OF RETURN LENGTH
	ADDL3	#6,R1,R0			;LENGTH OF RESULT BEFORE EQUIV
	ADDL3	R0,4(R8),-(SP)			;BUILD EQUIV NAME DESCRIPTOR
	SUBL3	R0,(R8),-(SP)			;
	MOVW	#LNM$_STRING,2(SP)		;SET ITEM TYPE
	MOVL	SP,R7				;SET ITEM LIST ADDR
	
	$TRNLNM_S  TABNAM=36(R7),-		;TRANSLATE THE LOGICAL NAME
		LOGNAM=28(R7),-			;
		ITMLST=(R7)			;

	CMPL	R0,#SS$_NORMAL			;TEST FOR SUCCESSFUL TRANSLATION
	BEQL	30$				;BRANCH IF SUCCESS
	CLRW	(R7)				;ELSE CLEAR BYTE COUNT OF RESULTANT STRING
	MOVAB	UNDEFINED,R1			;INDICATE UNDEFINED
	MOVZBL	(R1)+,R0			;
	MOVQ	R0,12(R7)			;

;
; Strip off escape sequences.
;
30$:	CLRW	2(R7)				;CLEAR ITEM TYPE
	MOVAB	(R7),R2				;GET ADDRESS OF EQUIV DESCRIPTOR
	TSTL	(R2)				;ZERO LENGTH EQUIV?
	BEQL	40$				;IF EQL YES
	CMPB	#27,@4(R2)			;FIRST CHARACTER ESCAPE?
	BNEQ	40$				;IF NEQ NO
	ADDL	#4,4(R2)			;POINT PAST EQUIV HEADER
	SUBL	#4,(R2)				;REDUCE LENGTH OF EQUIV BY HEADER
	BGEQ	40$				;IF GEQ OKAY
	CLRL	(R2)				;CLEAR EQUIV LENGTH

;
; Output the message.
;
40$:	MOVAB	LOGICALMSG,R1			;GET ADDRESS OF ASCIC FAO STRING
	MOVZBL	(R1)+,R0			;MAKE INTO DESCRIPTOR
	MOVQ	R0,-(SP)			;PUSH ONTO STACK
	MOVL	SP,R0				;GET DESCRIPTOR ADDRESSES
	MOVAQ	28(R7),R1			;
	MOVAQ	(R7),R2				;
	MOVAQ	12(R7),R3			;

	$FAO_S	(R0),(R8),(R8),R1,R2,R3		;FORMAT OUTPUT MESSAGE
		
	MOVAB	44(R7),SP			;RESTORE THE STACK
	MOVQ	(R8),R1				;GET OUTPUT MESSAGE PARAMETERS
	BSBW	DCL$MSGOUT			;OUTPUT MESSAGE
	STATUS	NORMAL				;RETURN SUCCESS
	RSB

	.END
