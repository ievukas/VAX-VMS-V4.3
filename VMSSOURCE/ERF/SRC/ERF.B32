MODULE ERF (%TITLE 'Errorlog Report Formatter'
	    MAIN = ERF,
	    IDENT = 'V04-000' ) =
! The version number above must be changed in two places.
! Search for 'IDENT ='.
BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************

!++
! FACILITY:  ERF, Errorlog Report Formatter
!
! ABSTRACT:
!	This is the main routine for ERF. All exit paths must return
!	here to exit.
!	
!
! ENVIRONMENT:
!
!	VAX/VMS operating system. unprivileged user mode,
!
! AUTHOR:  Elliott A. Drayton
!
! Modified by:
!
!	V03-026	EAD0197		Elliott A. Drayton		23-Jul-1984
!		Added code to check version numbers in VALIDATE_PACKET.
!
!	V03-025	EAD0193		Elliott A. Drayton		 6-Jul-1984
!		Made LSTLUN own and initialized it from syecom. Cleared
!		MAILBOX_CHANNEL which is now in syecom.
!
!	V03-024	EAD0180		Elliott A. Drayton		26-Jun-1984
!		Add workstation device class and have /LOG report any
!		files that were created.
!
!	V03-023	EAD0170		Elliott A. Drayton		 4-May-1984
!		Added context parameter to FILE_SCAN.
!
!	V03-022	EAD0140		Elliott	A. Drayton		12-Apr-1984
!		Removed reference to EMBETDEF.
!
!	V03-021	EAD0130		Elliott A. Drayton		 9-Apr-1984
!		Moved image_loader and its support routines in to ERFSHR.
!
!	V03-020	EAD0119		Elliott A. Drayton		22-Mar-1984
!		Add support for the UNKNOWN keyword.
!
!	V03-019	EAD0117		Elliott A. Drayton		21-Mar-1984
!		Fixed translation of loadable image name.
!
!	V03-018	SAR0209		Sharon A. Reynolds		10-Mar-1984
!		- Fixed a bug in write_msg so it checks the contents of
!		output_flag.
!		- Changed the call to write_msg so that the address of the
!		command line descriptor is passed.
!
!	V03-017	EAD0116		Elliott A. Drayton		 9-Mar-1984
!		Removed emb_buf and syecom_buf.
!
!		JMG0013		Joel M. Gringorten		 8-Mar-1984
!		Output command line at end of report if IO is directed 
!		to a file.
!
!	V03-016	EAD0107		Elliott A. Drayton		29-Feb-1984
!		Fixed problem in validate_packet which prevented unknown
!		error packets from being identified.
!
!	V03-015 EAD0104		Elliott A. Drayton		29-Feb-1984
!		Major clean up. 
!
!		SAR0189		Sharon A. Reynolds		13-Feb-1984
!		- Added the ERF_NOTFOUND message test at EOF.
!		- Added summary specific test for summary update calls.
!		- Added two parameters to the Brief_c_dispatcher calls.
!
!		JMG0012		Joel M. Gringorten		7-Feb-1984
!		Added support for /statistics qualifier.
!
!	V03-014	JMG0005		Joel M. Gringorten		29-Dec-1983
!		Added support for /summary=histogram.	
!		- Added histo output dispatch to erf_control.
!		- Added histo update dispatch to process_file.
!
!	V03-013	SAR0172		Sharon A. Reynolds		16-Nov-1983
!		- Added 'logmscp' entry support.
!		- Updated the 'max_xxx_type' values for new devices.
!		- Completed the device tables.
!		- Fixed a bug with /include=mem/summary=mem, the summary
!		  statistics were counted twice.
!
!	V03-012	SAR0165		Sharon A. Reynolds		14-Oct-1983
!		- Removed the code that counts logmessage/logstatus
!		  entries to fix a bug. (/incl=logm/excl=DU).
!		- Fixed a bug with the report type and /SID qualifier.
!		- Changed erf_norep to erf_invreptyp with fatal severity.
!
!	V03-011 SAR0150 	Sharon A. Reynolds		7-Oct-1983
!		Fixed a bug in the 'validate_packet' routine.
!
!	V03-010	SAR0138		Sharon A. Reynolds		20-Sep-1983
!		Fixed bug in code that determines whether to init commons.
!
!	V03-009	SAR0136		Sharon A. Reynolds		12-Sep-1983
!		Added code that removed the mscp info msg first part.
!
!	V03-008	SAR0128		Sharon A. Reynolds		7-Sep-1983
!		Added routine to initialize the qiocommon, opcode,
!		and modes commons. (Init_commons routine). Replaced
!		debugging error messages with permanent error messages.
!
!	V03-007	EAD0006		Elliott A. Drayton		23-Aug-1983
!		Added routines to open and parse text library records which
!		are used to build internal tables.
!
!	V03-006	SAR0062		Sharon A. Reynolds,		20-Jun-1983
!		Fixed bug with processor type in 'validate_packet'.
!
!	V03-005	SAR0031		Sharon A. Reynolds, 		2-Jun-1983
!		Put in a permanent solution to syecom buffer address problem.
!		Removed some unneccessary code.
!
!	V03-004	SAR0023		Sharon A. Reynolds,		11-May-1983
!		Modified 'process_packet' and 'full_dispatcher' so that the
!		summary information will be updated. Also modified 
!		'process_record' so that multiple part MSCP entries will 
!		be output. Fixed a problem passing record_length.
!		Put in a temporary solution to syecom problem.
!
!	V03-003 SAR0011		Sharon A. Reynolds,		11-Apr-1983
!		Added code to 'validate_packet' to set up the device
!		class and type fields to the appropriate emb fields,
!		as they are in different locations per entry type.
!
!	V03-002	SAR0010		Sharon A. Reynolds,		9-Apr-1983
!		Intialized status, status2, status3, and status4. Also
! 		added code to ensure processing a 'device entry' before 
!		examining device class and device type in 'validate packet'.
!
!--

REQUIRE 'SRC$:RECSELDEF.REQ';	! Defines emb fields
REQUIRE 'LIB$:PARSERDAT.R32';	! Defines option_flag fields
REQUIRE 'SRC$:ERFDEF.REQ';


FORWARD ROUTINE
   Build_class_tables,		! Allocates and inits device class tables
   Erf,				! Top level routine
   Erf_control,			! Main control loop
   Full_dispatcher,		! Cases to correct EXEC_IMAGE call
   Get_library_text,		! Reads library module record and calls parser
   Handler,			! Condition handler
   Init_commons,		! Initialize fortran data commons
   Open_text_lib,		! Routine to open and init the text library
   Parse_text_record,		! Routine to compress and parse text record
   Parse_max_table_size,	! 
   Parse_module_names,		! 
   Parse_device_desc_record,	! 
   Parse_max_min_table_record,	! 
   Process_file,		! Reads ERRLOG.SYS & loops till EOF
   Process_packet,		! Cases on report type to dispatcher
   Validate_packet,		! Checks packet for CPU,ENTRY,CLASS&TYPE
   Write_binary,		! Write packet as read, no text translation
   Write_err_msg;		! Write error messages to output file

EXTERNAL ROUTINE
   Exec_image,			! Call loaded image with correct params.
   Device_type_entry,		!
   Get_vm,			! Allocates requested buffers
   Image_loader,		! Determines which image to load & loads
   Lbr$close,
   Lbr$get_record,
   Lbr$ini_control,
   Lbr$lookup_key,
   Lbr$open,
   Lbr$set_locate,
   Lib$cvt_dtb,			! Convert decimal to binary
   Lib$extzv,
   Lib$file_scan,
   Log_filename,		! Signals filenames and error messages
   Map_image,
   Parse_command,		! Analyze command line
   Parse_output_files,		! Handles the opening of output files
   Record_selected,		! Determines if record should be processed
   Timrb,			! Runtime statistics package
   Timre,			! 
   Unknown_dispatcher,		! Formats and outputs reports for unknown error packets
   Write_msg;			! 

EXTERNAL
   Class_dir:			REF VECTOR[,WORD],
   EMB:				    $BBLOCK PSECT (EMB),
   Input_fab:			    $BBLOCK [],
   Input_rab:			    $BBLOCK [],
   Input_nam:			    $BBLOCK [],
   Input_xabfhc:		    $BBLOCK [],
   Lstlun_rab_address:		REF $BBLOCK [],
   Option_flag:			REF $BBLOCK [],
   Output_fab:			    $BBLOCK [],
   Output_nam:			REF $BBLOCK [],
   Output_rab:			    $BBLOCK [],
   Parser_data:			REF $BBLOCK [],
   Parser_table:		REF $BBLOCK [],
   Related_nam:			    $BBLOCK [],
   Rejected_fab:		    $BBLOCK [],
   Rejected_nam:		    $BBLOCK [],
   Rejected_rab:		    $BBLOCK [],
   Summary_flag:		REF $BBLOCK [],
   Syecom:			    $BBLOCK PSECT (SYECOM),
   Sys$output_rab_address:	REF $BBLOCK,
   Worst_error:			    $BBLOCK [LONG],
   Lnm$file_dev_desc,
   Bus_image:			REF BLOCKVECTOR[,2] FIELD (desc_fields),
   Bus_version:			REF VECTOR[,WORD],
   Bus_xfer_addr:		REF VECTOR[,LONG],	! Address of bus xfer address table
   Disk_image:			REF BLOCKVECTOR[,2] FIELD (desc_fields),
   Disk_version:		REF VECTOR[,WORD],	! Address of version number of device dependent code
   Disk_xfer_addr:		REF VECTOR[,LONG],	! Address of disk xfer address table
   Lp_image:			REF BLOCKVECTOR[,2] FIELD (desc_fields),
   Lp_version:			REF VECTOR[,WORD],
   Lp_xfer_addr:		REF VECTOR[,LONG],	! Address of lp xfer address table
   Max_misc_type:		    BYTE,
   Max_lp_type:			    BYTE,
   Packet_processor_xfer_addr:	REF VECTOR[,LONG],	! Address of realtime xfer address table
   Packet_processor_image:	REF BLOCKVECTOR[,2] FIELD (desc_fields),
   Packet_processor_version:	REF VECTOR[,WORD],
   Realtime_image:		REF BLOCKVECTOR[,2] FIELD (desc_fields),
   Realtime_version:		REF VECTOR[,WORD],
   Realtime_xfer_addr:		REF VECTOR[,LONG],	! Address of realtime xfer address table
   Scom_image:			REF BLOCKVECTOR[,2] FIELD (desc_fields),
   Scom_version:		REF VECTOR[,WORD],
   Scom_xfer_addr:		REF VECTOR[,LONG],	! Address of scom xfer address table
   Tape_image:			REF BLOCKVECTOR[,2] FIELD (desc_fields),
   Tape_version:		REF VECTOR[,WORD],
   Tape_xfer_addr:		REF VECTOR[,LONG],	! Address of tape xfer address table
   Translate_entry_table:	REF VECTOR [,WORD],
   Workstation_image:		REF BLOCKVECTOR[,2] FIELD (desc_fields),
   Workstation_version:		REF VECTOR[,WORD],
   Workstation_xfer_addr:	REF VECTOR[,LONG];


LITERAL
   Erf$_facility = 8,		! Facility code for ERF
   Word_size = 2,		! Number of bytes in a word
   Longword = 4,			! Number of bytes in a longword
   Descriptor_length = 8;	! Number of bytes in a string descriptor

Own
   Lstlun:			    LONG;

EXTERNAL LITERAL
Erf_badevtyp,
Erf_badevval,
Erf_badmodnam,
Erf_clstblerr,
Erf_cvterr,
Erf_herald,
Erf_input,
Erf_loaderr,
Erf_notfound,
Erf_invreptyp,
Erf_toomancls,
Erf_total,
Erf_unkentry,
Erf_unkclass;


SD('ERFLIB');	! Defines string descriptors

GLOBAL
   Bus_devices:			REF VECTOR[,WORD],
   Desc_table_address:		REF BLOCKVECTOR[,2] FIELD (desc_fields),
   Dev_addrs_ptr:		REF VECTOR[,LONG],	! Address device name pointers
   Dev_class_ptr:		REF VECTOR[,WORD],
   Disk_devices: 		REF VECTOR[,WORD],	! Address of disk device name table (e.g. DB)
   Function,						! Function to be done
   Herald:			    $BBLOCK [12],	! Address of message vector
   Inited_commons,
   Input_desc:			    $BBLOCK [dsc$k_d_bln],! Allocate dynmaic descriptor
   Input_file_count,
   Item_count,						! Used as index count
   Library_func:		    INITIAL (Lbr$c_read),
   Library_index,
   Library_type:		    INITIAL (lbr$c_typ_txt),
   Lp_devices:			REF VECTOR[,WORD],
   Max_bus_type:		    BYTE,
   Max_classes:			    BYTE,
   Max_cpu_types:		    WORD,
   Max_disk_type:		    BYTE,
   Max_range_table_addr:	REF VECTOR [,LONG],
   Max_realtime_type:		    BYTE,
   Max_scom_type:		    BYTE,
   Max_tape_type:		    BYTE,
   Max_Workstation_type:	    BYTE,
   Min_modules_desc:		REF BLOCKVECTOR[,2] FIELD (desc_fields),
   Max_modules_desc:		REF BLOCKVECTOR[,2] FIELD (desc_fields),
   Min_max_table_sizes:		REF VECTOR[,WORD],
   Min_range_table_addr:	REF VECTOR[,LONG],
   Module_name_desc,
   Packet_processor_devices:	REF VECTOR[,WORD],
   Processor_type_table:	REF VECTOR [,WORD],
   Realtime_devices:		REF VECTOR[,WORD],
   Record_desc:			    $BBLOCK [dsc$k_d_bln],
   Scom_devices:		REF VECTOR[,WORD],
   Selected,						! Count of records selected for processing
   Summary_dispatcher_addr,				! Transfer address of summary dispatcher
   Tape_devices: 		REF VECTOR[,WORD],
   Table_address:		REF VECTOR[,WORD],
   Table_length:			BYTE,
   Text_rfa:			VECTOR [2],
   Token_desc:			$BBLOCK [DSC$K_D_BLN],
   Total_selected,
   Total_rejected,
   Unknown_entry:		INITIAL (false),
   Workstation_devices: 	REF VECTOR[,WORD];

Builtin
	FFS ;


Routine ERF =				! Main routine for ERF
BEGIN
!++
! Functional description
!
!	This is the top level routine for the ERF facility.
!	It calls the main control loop.  Any errors encountered
!	will be passed back to this routine.
!
! Calling sequence
!
!	ERF () from the command language interpreter
!
! Input parameters
!
!	AP = Address of argument list passed from CLI
!
! Output parameters
!
!	None
!
! Routine value
!
!	Worst error is returned.
!
!----

LOCAL 
	channel, 
	status;

!
!SET UP HANDLERS ---
! Declare condition handler to record severest
! error message issued, to be returned on exit of image.
!

ENABLE handler;


!
!CALL MAIN CONTROL ---
! Invoke the main subroutine.  If any errors are encountered they
! will be returned immediately, if fatal, or saved in WORST_ERROR
! for exit processing.
!

Worst_error = Erf_control() ;


!
!RETURN TO USER ---
!	Return to the user.  Variable WORST_ERROR is maintained by
!	the error handler (see routine HANDLER).  If no messages have
!	been signaled then the initial value of WORST_ERROR, SS$_NORMAL,
!	will be returned.
!

Return .worst_error;				! Return contents of WORST_ERROR

END;

Routine ERF_CONTROL =				! Main control loop for ERF
BEGIN

!++
! Functional description
!
!	This is the control routine for the ERF facility.
!	Any errors encountered will be passed back to this routine.
!
! Calling sequence
!
!	ERF_CONTROL ()
!
! Input parameters
!
!
! Output parameters
!
!	None
!
! Routine value
!
!	Worst error is returned.
!
!----

LOCAL
	Field_size:		BYTE INITIAL (6),
	Scan_context:		     INITIAL (0),
	Start_position:		     INITIAL (0),
	Status,					! Returned status
	Summary_index,				! Index for summary type
	Text_lib_name,
	Out_file;


!
! Unconditional call to the runtime statistics package initialization routine.
!
TIMRB();


$INIT_DYNDESC (input_desc);

!
! Initialize the number of lines output.
!
Syecom[sye$b_lines] = 1 ;



!
! OPEN TEXT LIBRARY
!  Call LBR interface routines to prepare the library which
!  will provide text for output reports.

CALL_FUNCTION ( Open_text_lib () );


!
! PROCESS COMMAND LINE
!  Call CLI interface routines to parse command line and setup
!  internal tables for further processing.

CALL_FUNCTION ( Parse_command () );

!
! If /SUMMARY then load the ERFSUMM.EXE. If ERFSUMM.EXE not found clear
! summary flag and continue.
!

If .option_flag [opt$v_summary_qual] then
 Begin
 Status = Map_image( AD ('SYS$SYSTEM:ERFSUMM.EXE'), Summary_dispatcher_addr) ;
 If NOT .status then option_flag [opt$v_summary_qual] = 0;  
 End;


Syecom[sye$l_mailbox_channel] = 0;

!
! While file names exist in the command line go process the file.
!

While GET_VALUE ('FILE_SPECS', input_desc ) do
   Begin
   input_fab [fab$b_fns] = .input_desc [dsc$w_length];
   input_fab [fab$l_fna] = .input_desc [dsc$a_pointer];
   input_fab [fab$l_ctx] = msg$_searchfail;	! Setup the error message 
   LIB$FILE_SCAN (				! Call file scanner with -
		Input_fab,			! address of FAB, -
		Process_file,			! success action routine, -
		Log_filename,			! error action routine, -
		Scan_context );			! and scan context.
   End;


!
! If /SUMMARY then output summary report type requested.
!
If .option_flag[opt$v_summary_qual]
Then
    Begin

    Until .start_position GTR 6 do
	 Begin

	 FFS (start_position,field_size,
		.summary_flag,summary_index) ;

	 Case .summary_index from 0 to 5 of
 	     Set

	     [0]:
	     Function = all_summ_out;	! Initialize function to output
					! all possible summary information

	     [1]:
 	     Function = dev_summ_out;	! Initialize function to output 
					! device summary information only

	     [2]:
	     Function = entry_summ_out;	! Initialize function to output 
					! entry summary information only
 
	     [3]:
	     Function = memory_summ_out; ! Initialize function to output
					 ! memory summary information only

	     [4]:
	     Function = volume_summ_out; ! Initialize function to output 
					 ! volume summary information only

	     [5]:
	     Function = histo_summ_out;  ! Initialize function to output 
					 ! histogram summary information only

	     [OUTRANGE]:
	     EXITLOOP;
	     
	     TES;

	 Exec_image ( Summary_dispatcher_addr, Lstlun, Function) ;
	 Start_position = .summary_index + 1 ;
	 End ;
     End;


! LOG MESSAGE
!  If /LOG requested and more then one input file
!  was processed then print total number of files processed,
!  total records selected and total records rejected.
!

If .option_flag[opt$v_log_qual] and .input_file_count gtru 1 then
    signal (erf_total, 3, .total_selected, .total_rejected, .input_file_count);


!
! If /STATISTICS was specified then call the runtime statistics display routine.
!
If .option_flag[opt$v_statistics_qual] then TIMRE(lstlun) ;


!
! Write original command line, if /REJECTED was not specified.
!
If ( NOT .option_flag[opt$v_rejected_qual] ) then
   write_msg ( parser_table[erl$r_cmd_line], 1 );


!
! CLOSE OUTPUT FILES
!

If .syecom [sye$l_forms] OR
   .option_flag [opt$v_binary_qual]
then
   BEGIN
   If .option_flag[opt$v_log_qual]
   then
      BEGIN
      Local desc : VECTOR [2,long];
      Desc[0] = .output_nam [nam$b_rsl];
      Desc[1] = .output_nam [nam$l_rsa];
      Signal (msg$_created, 1, desc);
      END;
   END;   


Output_fab [fab$l_ctx] = msg$_closeout;		! Assign error messages
Rejected_fab [fab$l_ctx] = msg$_closeout;	! Assign error messages

If .option_flag [opt$v_output_qual] AND
   .option_flag [opt$v_binary_qual]
then
   CALL_FUNCTION ( $close (fab = output_fab, err = log_filename) );


If .option_flag[opt$v_rejected_qual]
then 
   BEGIN
   If .option_flag[opt$v_log_qual]
   then
      BEGIN
      Local desc : VECTOR [2,long];
      Desc[0] = .rejected_nam [nam$b_rsl];
      Desc[1] = .rejected_nam [nam$l_rsa];
      Signal (msg$_created, 1, desc);
      END;
   CALL_FUNCTION ( $close ( fab = rejected_fab, err = log_filename) );
   END;

Return .worst_error

End;


Routine PROCESS_FILE (FAB) =

!++
! Functional description
!
!	This routine processes one input file. It is
!	called as an action routine from LIB$FILE_SCAN.
!
! Calling sequence
!
!	PROCESS_FILE (FAB)
!
! Input parameters
!
!	FAB - address of input_fab.
!
! Output parameters
!
!	None
!
! Routine value
!
!	Worst error is returned.
!
!----

BEGIN

Map
	Fab:		ref $bblock;


Local
	Status:		$BBLOCK [LONG],
	Desc:		VECTOR [2,LONG];	! General purpose descriptor


Own
	Class: 		WORD,			! Class of the image to be loaded
	First_time:	INITIAL (TRUE),		! Flag to know if this is first_time
	Type:		WORD,			! Type of the image to be loaded
	Xfer_addr:	LONG ;			! Transfer address of the required image



!
! Establish the input buffer address.
!
Input_rab [rab$l_ubf] = emb ;		! Load input buffer addr. in RAB

!
! OPEN AND CONNECT ---
!  To the input error log file.  Exit immediately if any errors
!  are detected. The error handlers will have been invoked if an
!  error occured, and the user will have been notified.  The error
!  message used by the LOG_FILENAME routine is drawn from the
!  CTX field of the FAB or INPUT_RAB as needed.
!

Fab [fab$l_ctx] = msg$_openin;			! Specify the error message
CALL_FUNCTION ( $open (fab=.fab,		! OPEN the input file
		       err=log_filename) );
CALL_FUNCTION ( $connect (rab=input_rab,	! CONNECT to input file
		       err=log_filename) );




!
! INITIALIZE OUTPUT FILES --
!  The processing of the output files has been deferred until now
!  so that a fully parsed input file name would be available (as
!  a related file name) for default file name components.
!

If .input_file_count eql 0 then			! If this is the first pass
  CALL_FUNCTION ( parse_output_files(Lstlun) );	! then open the output files

Input_file_count = .input_file_count + 1;	! Count the number of files we process.

Lstlun = .syecom[sye$l_lstlun];			! Initialize the fortran logical unit number


!
! RESET THE RECORD COUNTERS--
!   Reset the file-relative record number such that records in each
!   file will be numbered in ascending order beginning with one.
!   Reset the selected count so it is also on a per-file basis.
!

Syecom[sye$l_reccnt] = 0;			! Reset the record number
Selected = 0;					! Reset file select count


!
! READ AND LOOP UNTIL EOF OR ERROR ---
!   While status is true, get a record from the input file.
!     Increment the SYECOM[SYE$L_RECCNT] which is the record count.
!     If the user command specified this type of record needs processing then 
!      Increment record selected count.
!      If /BINARY specified, then
!       write the record to the specified binary file,
!      else go process the record(error packet).
!     else write the error packet to the rejected records file if specified.
!   End while
!

While status = $GET (rab=input_rab, err=log_filename) do ! Read a record
 BEGIN
 Syecom[sye$l_reccnt] = .syecom[sye$l_reccnt] + 1;  ! Update the record number

 If record_selected () then			! Process this record?
   BEGIN					!  Yes
   Selected = .selected + 1;			!  Count how many we process
   If .option_flag[opt$v_binary_qual] then	!  If /BINARY write packet
    CALL_FUNCTION ( write_binary (emb, output_rab) )
   Else
     CALL_FUNCTION ( process_packet () );	! Analyze packet
   End
 Else
   If .option_flag[opt$v_rejected_qual]		! If /REJECTED write packet
   then CALL_FUNCTION ( write_binary (emb, rejected_rab) );

!
! Determine if the end value for a '/entry=end' was found.
! Yes, set up status and exit as if end of file.
!
 If .syecom[sye$b_end_value] then
   Begin
   Status = RMS$_EOF ;
   Exitloop ;
   End ;
 END;

Total_selected = .total_selected + .selected;	! Accumulate totals
Total_rejected = .total_rejected + (.syecom[sye$l_reccnt] - .selected);


!
!CHECK STATUS AT END OF LOOP ---
! Now check the return status to make sure it was a normal EOF.  If not,
! notify the user.
!

If not (.status eql rms$_eof)		! If any status other than
   then	return .status;			!  expected eof, return it

!
! Indicate that end of file occurred.
!
Syecom[sye$b_eof_flag] = true ;

!
! Display MSCP messages
! Determine if a full report should be generated, so that the MSCP
! messages can be de-queued and output. (This must be done after EOF
! because the number of entries for a given cmd ref number is unknown 
! due to the number of retries for the I/O, etc.).
! *********************************
!  Brief reports are handled in the root and don't seem to require this 
!  call back to de-queue any information.???????
!  Summary information is updated when the first part of an MSCP message
!  is seen. Summaries for device rollup worked before this code was put in.
!
If .parser_data[erl$b_rpt_type] EQLU FULL_REP
Then
    !
    ! Set up the class/type and attempt to load the ERFPROC1 image. If the
    ! image was already loaded the xfer address will be returned.
    !
    Begin
    Class = 0 ;
    Type = EMB$C_SP ;

    Worst_error = Image_loader ( type, class, xfer_addr );

    If .Xfer_addr NEQU 0 
    Then
	!
	! Call the device dependent module to produce a full report.
	! (Record_size is passed as a count of 1 and record_number is unknown 
	! at this time and should not matter, because when ERLLOGSTS sees that 
	! EOF was seen it will call the DUDRIVER_MSCP_DQ routine to output the 
	! remainder of the MSCP message information).
	!
	BEGIN
	Syecom[sye$l_options] = %c'S';
	Exec_image ( Xfer_addr, Lstlun, %REF(1), syecom[sye$l_reccnt],
		     AD('S') );
	End;
    End ;

!
! Determine whether any of the specified enrtries were found.
! If no entries found. Output an informational message for the user.
!

If .total_selected EQL 0 then signal (erf_notfound) ; 

!
! CLOSE ---
!	Input file processing is now complete.  Revise the stored error
!	message (which is passed to the error routine via the 'user context'
!	field [CTX] of the FAB) and $CLOSE the input file.
!

Fab [fab$l_ctx] = msg$_closein;				! Assign error message
CALL_FUNCTION ( $close (fab=.fab, err=log_filename) );	! Close the input file


If .option_flag[opt$v_log_qual] then		! If /LOG requested
   BEGIN
   Desc [0] = .input_nam [nam$b_rsl];		!  then notify the user
   Desc [1] = .input_nam [nam$l_rsa];		!  with file name and counts
   Signal (erf_input, 3, desc, .selected, .syecom[sye$l_reccnt] - .selected);
   END;



Return true;

END;

Routine PROCESS_PACKET =
BEGIN
!++
! Functional description
!
!	This routine determines which dispatcher to call for processing
!	the specified report type. Any errors encountered will be passed
!	back to the caller.
!
! Calling sequence
!
!	Process_packet ( )
!
! Input parameters
!
!
! Output parameters
!
!	None
!
! Routine value
!
!	Worst error is returned.
!
!----

Literal
	No_full = 0 ;

Local
   Status;

Global
   Brief_xfer_addr;

syecom[sye$l_record_size] = .input_rab [rab$w_rsz];

If (NOT .unknown_entry) then 		! If not an unknown entry then
   Begin
   Case .parser_data[erl$b_rpt_type] 	! Case on report type value
      From 0 to REG_DUMP_REP of
      Set

      [No_full]:
	If .option_flag[opt$v_summary_qual] then
	  CALL_FUNCTION ( full_dispatcher () ) ;


      [Brief_rep]:			! Go output a Brief report
	Begin
	If .Brief_xfer_addr EQL 0 then
	   Begin
	   Status = map_image (AD ('SYS$SYSTEM:ERFBRIEF.EXE'),brief_xfer_addr);
	   If NOT .status then return true;
	   End;

	Syecom[sye$l_options] = %c'B';
	Exec_image( Brief_xfer_addr,
		    Lstlun,
		    AD('B'),
		    syecom[sye$l_record_size],
		    %REF(.option_flag[opt$v_summary_qual]),
		    .Summary_flag) ;
	End;

      [Full_rep]:			! Go output a Full report
	Begin
	!
	! Determine whether the fortran text commons (qiocommon, opcodes, modes)
	! have been initialized, if not then call the init_commons routine to
	! initialize them. Then call the full dispatcher.
	!
	If NOT .inited_commons then CALL_FUNCTION (init_commons()) ;
	CALL_FUNCTION ( Full_dispatcher () );
	End ;


      [Reg_dump_rep]:			! Go output a Register Dump report
	Begin
	If .Brief_xfer_addr EQL 0 then
	   Begin
	   Status = map_image (AD ('SYS$SYSTEM:ERFBRIEF.EXE'),brief_xfer_addr);
	   If NOT .status then return true;
	   End;

	Syecom[sye$l_options] = %c'C';
	Exec_image( Brief_xfer_addr,
		    Lstlun,
		    AD('C'),
		    syecom[sye$l_record_size],
		    %REF(.option_flag[opt$v_summary_qual]),
		    .Summary_flag) ;

	End;

      [OUTRANGE]:
	Signal (erf_invreptyp);

      TES;
      End
Else
      If .parser_data[erl$b_rpt_type] NEQU NO_FULL then
         Unknown_dispatcher ();		! Call unknown dispatcher


!
! If /summary was specified then call summary_dispatcher.
!
If .option_flag [opt$v_summary_qual] then
 Begin 
 If (.summary_flag[sum$v_device]  OR .summary_flag[sum$v_all_summ]) then
 Exec_image ( Summary_dispatcher_addr, Lstlun, %REF(dev_summ_upd)) ;

 If (.summary_flag[sum$v_histogram] OR .summary_flag[sum$v_all_summ]) then
 Exec_image ( Summary_dispatcher_addr, Lstlun, %REF(histo_summ_upd)) ;
 End;

Return true;
End;

Routine FULL_DISPATCHER =			! Full report dispatcher
BEGIN
!++
! Functional description
!
!	This routine checks to see if the loadable module needed
!       to process the error packet is available. If it is not then
!       it tries to load the module. If successful then it call the module.
!	Any errors encountered will be passed back to this routine.
!
! Calling sequence
!
!	Full_dispatcher ()
!
! Input parameters
!
!
! Output parameters
!
!	None
!
! Routine value
!
!	Worst error is returned.
!
!----

Own
   Xfer_addr:	LONG,			! Transfer address of the required image
   Class: 	WORD,			! Class of the image to be loaded
   Type:	WORD;			! Type of the image to be loaded


!
! If the packet entry type is a device error, device timeout, or
! device attention then use the class and type specified in the packet as
! class and type of the image to be loaded. Else use class = 0 and
! type = entry type value.
!

If ( .emb[emb$w_hd_entry] EQLU EMB$C_DE ) OR
   ( .emb[emb$w_hd_entry] EQLU EMB$C_DT ) OR
   ( .emb[emb$w_hd_entry] EQLU EMB$C_DA )
Then
   Begin
   Type = .emb[emb$b_dv_type];
   Class = .emb[emb$b_dv_class];
   End
Else
   Begin
   Type = .emb[emb$w_hd_entry];
   Class = 0;
   End;

!
! Try and load the image. If no image report error and return.
!
Worst_error = Image_loader ( type, class, xfer_addr );
If .Xfer_addr EQLU 0 then return .worst_error;

!
! The error packet entry type will determine which call to EXEC_IMAGE should
! be used in order to pass the necessary parameters to the loaded image
! for translation of the error packet.
!
Case .emb[emb$w_hd_entry] from 1 to EMB$C_UBC of
SET

[ EMB$C_DE,			! Device Error 1
  EMB$C_BE,			! Bus Error 4
  EMB$C_AW, 			! Asynchronous Write Error 7
  EMB$C_CS,			! Cold start (ie: SYSTEM BOOT) 32 %x20
  34,				! NOT IN DEFINITION FILE 34 %x22
  EMB$C_NF,			! New errlod.sys file created 35 %x23
  EMB$C_WS,			! Warm start (ie: SYSTEM POWER RECOVERY) 36 %x24
  EMB$C_CR,			! Fatal bugcheck 37 %x25
  EMB$C_TS,			! Time stamp entry 38 %X26
  EMB$C_SS,			! System service message 39 %X27
  EMB$C_SBC,			! System bugcheck 40 %X28
  EMB$C_OM,			! Operator message 41 %X29
  EMB$C_NM,			! Network message 42 %X2A
  EMB$C_DT,			! Device Timeout 96 %X60
  EMB$C_UI,			! Undefined interrupt 97 %X61
  EMB$C_DA,			! Asynchronous Device Attention 98 %X62
  EMB$C_UBC ] :			! User bugcheck 112 %X70

   !
   ! Determine if a full report should be generated.
   ! Call the device dependent module to produce a full report.
   ! Else return.
   !
   Begin
   If .parser_data[erl$b_rpt_type] NEQ 0 then Exec_image ( Xfer_addr, Lstlun );
   Return true;
   End;

[ EMB$C_SP,			!  Software Parameters 99 %X63
  EMB$C_LM ,			!  Logged Message 100 %X64
  EMB$C_LOGMSCP ] :		!  MSCP message without UCB  101 %x65

   Begin
   !
   ! Determine if summary information should be updated.
   !
   If (.option_flag[opt$v_summary_qual]) AND 
	(.emb[emb$w_hd_entry] NEQU EMB$C_LOGMSCP)
   Then
	! Yes, call the deivce dependent module for summary updates.
	!
	BEGIN
	Syecom[sye$l_options] = %c'R';
	Exec_image ( Xfer_addr, Lstlun, syecom[sye$l_record_size],
		     syecom[sye$l_reccnt], AD('R') );
	END;

   !
   ! If report type is not equal to NOFULL then call the device dependent
   ! module to produce a full report.
   !
   If .parser_data[erl$b_rpt_type] NEQ 0
   then
      BEGIN
      Syecom[sye$l_options] = %c'S';
      Exec_image ( Xfer_addr, Lstlun, syecom[sye$l_record_size],
		   syecom[sye$l_reccnt], AD('S') );
      End;
   Return true;
   End;

[ EMB$C_MC,			! Machine check 2
  EMB$C_SA, 			! SBI Alert 5
  EMB$C_SE,			! Soft ECC Error 6
  EMB$C_HE,			! Hard ECC Error 8
  EMB$C_UBA,			! 11/780 Unibus Adapter error 9
  EMB$C_UE,			! 11/730 Unibus Error 11 %XB
  EMB$C_MBA,			! 11/780 Massbus Adapter Error 12 %XC
  EMB$C_VM,			! Volume mount 64 %X40
  EMB$C_VD ] :			! Volume dismount 65 %X41

   Begin
   !
   ! Determine if summary information should be updated.
   !
   If (.parser_data[erl$b_rpt_type] EQL 0) AND
       (.option_flag[opt$v_summary_qual])
   Then
	! Yes, call the deivce dependent module for summary updates
	! and return to the calling routine.
	!
	Begin
	Syecom[sye$l_options] = %c'R';
	Exec_image (Xfer_addr, Lstlun, AD ('R') );
	Return true ;
	End ;

   !
   ! Call the device dependent module to produce a full report.
   !
   Syecom[sye$l_options] = %c'S';
   Exec_image (Xfer_addr, Lstlun, AD ('S') );
   Return True;
   End;

 [EMB$C_SBIA,				! SBI Adaptor error 13 %X0D
  EMB$C_CRD,				! CRD log 14 %X0E
  EMB$C_EMM,				! Environmental Monitor 15 %X0F
  EMB$C_HLT,				! Processor Error Halt 16 %20
  EMB$C_CRBT]:				! Console Reboot 17 %X21
	Begin
	Exec_image (Xfer_addr);
	Return true;
	End;

 [ 3, 10, 18 to 31, 33, 43 to 63, 66 to 95, 102 to 111, outrange ]:
  Return true;
TES;

End;


Routine OPEN_TEXT_LIB =

!++
! Functional description
!
!	This routine set up the default library name then attempts
!	to translate ERFLIB. If there is no translation then the
!	default library name is used to open the text library.
!	If there is a translation then that string is used instead.
!	Once the library is opened, modules are read in and there
!	records parsed. These records are used to build the tables
!	which control device validation, device module secection,
!	and CPU validation. MODULE_NAME_DESC points at the name of
!	text module to be read and parsed. FUNCTION is a value which
!	specifies which record parser to use for a particular text
!	module.	
!
! Calling sequence
!
!	OPEN_TEXT_LIB ()
!
! Input parameters
!
!
! Output parameters
!
!	None
!
! Routine value
!
!	Worst error is returned.
!
!----

BEGIN

LOCAL
	Buff:		$BBLOCK [80],
	Desc:		VECTOR[2,LONG] INITIAL (80,buff),
	Function,
	Nocall_needed:	BYTE INITIAL (FALSE),
	Status,
	Text_library_name_desc,
	Trnlnmlst:	$itmlst_decl (items = 1);

Global
	Ident;

Ident = $descriptor('V03-026');
Text_library_name_desc = $descriptor ('SYS$LIBRARY:ERFLIB.TLB') ;

$Itmlst_init ( itmlst = trnlnmlst, (itmcod = lnm$_string, bufadr = .desc[1],
				    bufsiz = .desc[0], retlen = desc[0]));

If $trnlnm ( attr = %ref(lnm$m_case_blind),
		 tabnam = lnm$file_dev_desc,
		 lognam = erflib_desc,
		 itmlst = trnlnmlst)
Then
  Text_library_name_desc = desc;

!
! Initialize text library control and open the library.
!
Status = LBR$INI_CONTROL ( Library_index, Library_func, Library_type ) ;
If NOT .status then Signal_stop (.status) ;

Status = LBR$OPEN ( Library_index, .Text_library_name_desc ) ;
If NOT .status then 				! Could not open library.
   Begin
   Signal_stop (msg$_searchfail, 1, .text_library_name_desc, .status) ;
   End;


!
! Set to locate mode for reading records to parse.
!

CALL_FUNCTION ( LBR$SET_LOCATE (Library_index) );


!
! Sequence thru the reading and parsing of the text modules.
!
Incr loop_count from 1 to 11 do
  Begin
  Case .loop_count from 1 to 11 of set
    [1]: ( Function = 1; Module_name_desc = $descriptor ('MAX_CLASS_SIZE') );
    [2]: ( Function = 1; Module_name_desc = $descriptor ('CLASS_VALUES') );
    [3]: ( Function = 3; Module_name_desc = $descriptor ('TABLE_SIZES') );
    [4]:
	Begin
	Herald[msg$w_msg_flg] = 1;	! Message flages
	Herald[msg$w_arg_cnt] = 3;	! Argument count
	Herald[msg$l_msg_id] = erf_herald;
	Herald[msg$w_new_flg] = 1;	! New message flages
	Herald[msg$w_FAO_cnt] = 1;
	Herald[msg$l_FAO_arg1] = .ident;
	$Putmsg (msgvec = herald);
	Function = 4;
	Module_name_desc = $descriptor ('DEVICES') ;
	End;
    [5]:
	Begin
	Function = 2;
	Module_name_desc = $descriptor ('TRANSLATE_ENTRY_TABLE');
	Table_address = .translate_entry_table;
	Table_length = .max_misc_type;
	Item_count = 0;
	End;
    [6]:
	Begin
	Function = 2;
	Module_name_desc = $descriptor ('CPU_TYPES');
	Table_address = .processor_type_table;
	Table_length = .max_cpu_types;
	Item_count = 0;
	End;

    [7]:
	Begin
	Function = 5; 
	Module_name_desc = $descriptor ('MIN_MODULE_NAMES');
	Desc_table_address = .min_modules_desc;
	Table_length = .max_cpu_types;
	Item_count = 0;
	End;
    [8]:
	Begin
	Function = 5;
	Module_name_desc = $descriptor ('MAX_MODULE_NAMES');
	Desc_table_address = .max_modules_desc;
	Table_length = .max_cpu_types;
	Item_count = 0;
	End;


    [9]:
	!
	! THE NEXT THREE SECTIONS MUST BE DONE IN THIS SEQUENCE.
	! This section loads the MIN_MAX_TABLE_SIZES table. Each
	! table entry specifies the number of range pairs that
	! exist for a particular CPU.
	!
	Begin
	Function = 2;
	Module_name_desc = $descriptor ('MIN_MAX_SIZES');
	Table_address = .min_max_table_sizes;
	Table_length = .max_cpu_types;
	Item_count = 0;
	End;

    [10]:
	!
	! This section uses the contents of the MIN_MAX_TABLE_SIZES table
	! to determine the size of the range tables. The base address of
	! each range table is then saved.
	!
	Begin
	Incr range_loop from 1 to .max_cpu_types do
	  Begin
	  If .min_max_table_sizes[.range_loop] NEQ 0 then
	    Begin
	    Max_range_table_addr[.range_loop] =
		get_vm ( (.min_max_table_sizes[.range_loop] + 1 ) * word_size);
	    Min_range_table_addr[.range_loop] =
		get_vm ( (.min_max_table_sizes[.range_loop] + 1 ) * word_size);
	    End
	  Else
	    Begin
	    Max_range_table_addr[.range_loop] = 0;
	    Min_range_table_addr[.range_loop] = 0;
	    End;
          End;

	!
	! For each range table which has a non zero size, read a text library
	! module which will specify the min. ranges.
	! 
	Incr range_loop from 1 to .max_cpu_types do
	  If .min_max_table_sizes[.range_loop] NEQ 0 then
	    Begin
	    Function = 2;
	    Module_name_desc = min_modules_desc[.range_loop,desc_one];
	    Table_address = .min_range_table_addr[.range_loop];
	    Table_length = .min_max_table_sizes[.range_loop];
	    Item_count = 0;
	    CALL_FUNCTION ( Get_library_text ( .Function, .Module_name_desc ));
	    End;
	Nocall_needed = True;
	End;


    [11]:
	!
	! For each range table which has a non zero size, read a text library
	! module which will specify the max. ranges.
	! 
	Begin
	Incr range_loop from 1 to .max_cpu_types do
	  If .min_max_table_sizes[.range_loop] NEQ 0 then
	    Begin
	    Function = 2;
	    Module_name_desc = max_modules_desc[.range_loop,desc_one];
	    Table_address = .max_range_table_addr[.range_loop];
	    Table_length = .min_max_table_sizes[.range_loop];
	    Item_count = 0;
	    CALL_FUNCTION ( Get_library_text ( .Function, .Module_name_desc ));
	    End;
	Nocall_needed = True;
	End;
  TES;

  If NOT .nocall_needed then		! If nocall_needed is false then
    CALL_FUNCTION ( Get_library_text ( .Function, .Module_name_desc ))
  Else					! else its true and reset it to false.
    Nocall_needed = false;

  End;

Status = LBR$CLOSE ( Library_index ) ;
If NOT .status then Signal_stop (.status) ;

Return true;
End;

Routine GET_LIBRARY_TEXT ( Function, module_name ) =
BEGIN
!++
! Functional description
!
!	This routine looks up the text module name specified. It
!	reads the records from that text module. If a record
!	does not have a comment character in the first three
!	character positions and the record is not of length zero,
!	then the parsing routine specified by FUNCTION is called.
!
! Calling sequence
!
!	GET_LIBRARY_TEXT ( Function, module_name )
!
! Input parameters
!
!		Function : Value specifying;
!			1 Build class tables
!			2 Parse and convert to binary a list of values
!			3 Allocate and initialize processor and device tables
!			4 Parse device description records. See text module
!			   DEVICES for more information.
!
!	     Module_name : Address of descriptor for module name.
!
! Output parameters
!
!	None
!
! Routine value
!
!	Worst error is returned.
!
!----

LOCAL
	Offset,
	Position,
	Status;

!
! Use MODULE_NAME as the key to find the text module in library.
!

Status = LBR$LOOKUP_KEY ( Library_index, .Module_name, Text_rfa ) ;
If NOT .status then Signal (erf_badmodnam, 1, .module_name, .status) ;


!
!READ A RECORD FROM THE TEXT LIBRARY
! If the record length is not zero then case to a decode routine.
! Search the record for the comment character '!'.
! If "!" is in one of the first three positions get a new record.
!

While Status = LBR$GET_RECORD ( Library_index, Record_desc, Record_desc) do
    Begin
    If .Record_desc [dsc$w_length] NEQ 0 then
      Begin
      Position = CH$FIND_CH (.Record_desc [dsc$w_length],
			     .Record_desc [dsc$a_pointer], %c'!' );
      If .position NEQ 0 then
	Offset = CH$DIFF ( .position , .Record_desc [dsc$a_pointer])
      Else
	Offset = 4;

      If .Offset GTR 3 then	    
	 Case .function from 1 to 5 of set
	  [1]: Build_class_tables ();		! Inits device class table
	  [2]: Parse_max_min_table_record ();	! Min max table parser
	  [3]: Parse_max_table_size ();		! Parse & convert to binary
	  [4]: Parse_device_desc_record ();	! Parse & return strings
	  [5]: Parse_module_names ();
	 Tes;
      End;
    End;

Item_count = 0;					! Global used by several routines 
						!  as there array index.
Return true ;
End ;


Routine BUILD_CLASS_TABLES =
BEGIN
!++
! Functional description
!
!	This routine allocates memory for tables which will be filled
!	with the information obtained from the ERF text library in
!	SYS$LIBRARY. See the text library modules for a description
!	of the text library records.
!
! Calling sequence
!
!      Build_class_tables ()
!
! Input parameters
!
!
! Output parameters
!
!	Class_dir, class_names, dev_addrs_ptr, dev_class_ptr
!
! Routine value
!
!	Worst error is returned.
!
!----

OWN
	Context,		! Continuation flag if this flag is set then more
				!   values in comma seperated list
	Size,			! Length of the field pointed to by VALUE_ADDR
	Status,			! Status after a convert
	Index,			! The first field of a text record
	Value_addr;		! Pointer to current filed in the text record

!LOCAL
!	Class_names;		! Address of DC$_xxx strings
!Class_names = Get_vm ((.size+1) * 13);	! Class name + string size = 13

!
! Call to obtain the index and the current value address (value_addr).
!

Context = 0;
CALL_FUNCTION ( Parse_text_record ( context, index, value_addr, size ) );



!
! Convert the current value from ASCII to binary and use it to allocate
! memory for tables. Use the index value to determin which table to build.
!
Status = LIB$CVT_DTB ( .size, .Value_addr, size );
If NOT .status then Signal (erf_cvterr, 2,.size,value_addr) ;
   
If .class_dir EQL 0 then
 Begin
 Class_dir = Get_vm ((.size+1) * 6);	! Device Class(2 bytes + device name table addr (longword)= 6
 Max_classes = .size;			! Total number of dev. classes
 Dev_addrs_ptr = Class_dir[.max_classes+1];
 Dev_class_ptr = .class_dir ;
 End
Else
 Begin
 If .index GTR .max_classes then signal (erf_toomancls, 1, .index);
 Class_dir[.index] = .size; ! Set device class values
 End;

Return true ;
End ;

Routine PARSE_MAX_MIN_TABLE_RECORD =
BEGIN
!++
! Functional description
!
!	This routine calls parse_text_record to obtain a value from
!	the comma seperated list of values. The value is converted
!	to binary and place in a table.
!
! Calling sequence
!
! Input parameters
!
!
! Output parameters
!
!	Fills the table specified by TABLE_ADDRESS.
!
! Routine value
!
!	Worst error is returned.
!
!----
Local
	Context,
	Index,
	Size,
	Status,
	Value_addr;


Context = 0;	! Clear the context

Do
 Begin
 Item_count = .item_count + 1;

 If .item_count GTR .table_length then
    (signal (erf_badevtyp, 2, .item_count, .Module_name_desc); Return true);

 CALL_FUNCTION ( Parse_text_record ( context, index, value_addr, size ) );


 Status = LIB$CVT_DTB ( .size, .Value_addr, size );
 If NOT .status  then Signal (erf_cvterr, 2,.size,value_addr) ;

 Table_address [.Item_count] = .size;

 End

While .context EQL 1;

Return true ;
End ;

Routine PARSE_MAX_TABLE_SIZE =
BEGIN
!++
! Functional description
!
!	With the information that is returned from a call to 
!	'PARSE_TEXT_RECORD', this routine allocates storage.
!	The index value of the library record being parsed
!	determines which table pointers are initialized.
!	It also sets up the table of addresses pointed to
!	by 'DEV_ADDR_PTR'.
!
! Calling sequence
!
! Input parameters
!
!	None.
!
! Output parameters
!
!	All the table pointers for devices and cpu tables
!	are set up here and are global.
!
! Routine value
!
!	Worst error is returned.
!
!----

OWN
	Dc_class: word,		! Temp for device class
	Device_addr,		! Temp for device table address
	Context,		! Flag which specifies if there are more items in the text record
	Image_addr,
	Index,			! Value of the first item in the text record
	Size,			! Size of the item returned.
	Status,			! Status of the LIB$ call
	Value_addr,		! Address of the current value in the text record
	Version_addr,
	Xfer_addr;


!
! Call to obtain the index and the current value address (value_addr).
!
Context = 0;
CALL_FUNCTION ( Parse_text_record ( context, index, value_addr, size ) );

!
! Convert the current value from ASCII to binary and use it to allocate
! memory for tables. Use the index value to determin which table to build.
!
Status = LIB$CVT_DTB ( .size, .Value_addr, size );
If NOT .status then Signal (erf_cvterr, 2,.size,value_addr) ;

!
! Update the size for non-used first locations in tables.
!
Size = .size + 1 ;

!
! If INDEX is equal to one then allocate storage for the
! CPU and verfification table and save the table addresses.
!
If .index EQL 1 then
  Begin
  Local Amount;
  Amount = .size * longword;
  Max_cpu_types = .size -1;
  Min_range_table_addr = get_vm (.amount);
  Max_range_table_addr = get_vm (.amount);
  Min_modules_desc = get_vm (.amount*2);
  Max_modules_desc = get_vm (.amount*2);
  Processor_type_table = get_vm (.size * word_size);
  Min_max_table_sizes = get_vm (.size * word_size);
  Return true;
  End;

!
! Allocate the storage for the device, version number, xfer address,
! and image name tables.
!
Device_addr = get_vm (.size * word_size);
Version_addr = get_vm (.size * word_size);
Xfer_addr = get_vm (.size * longword);
Image_addr = get_vm (.size * descriptor_length);


!
! Via the index determine which entry is being processed and
! copy the addresses/size of the tables to the appropriate places.
!
Case .index from 2 to 9 of set
   [2]: Begin
	Disk_devices = .device_addr;
	Disk_version = .version_addr;
	Disk_xfer_addr = .xfer_addr;
	Disk_image = .image_addr;
	Max_disk_type = .size - 1;
	Disk_devices[0] = .size;
	Dc_class = DC$_DISK;
	End;

   [3]: Begin
	Tape_devices = .device_addr;
	Tape_version = .version_addr;
	Tape_xfer_addr = .xfer_addr;
	Tape_image = .image_addr;
	Max_tape_type = .size - 1;
	Tape_devices[0] = .size;
	Dc_class = DC$_TAPE;
	End;

   [4]: Begin
	Scom_devices = .device_addr;
	Scom_version = .version_addr;
	Scom_xfer_addr = .xfer_addr;
	Scom_image = .image_addr;
	Max_scom_type = .size - 1;
	Scom_devices[0] = .size;
	Dc_class = DC$_SCOM;
	End;

   [5]: Begin
	Lp_devices = .device_addr;
	Lp_version = .version_addr;
	Lp_xfer_addr = .xfer_addr;
	Lp_image = .image_addr;
	Max_lp_type = .size - 1;
	Lp_devices[0] = .size;
	Dc_class = DC$_LP;
	End;

   [6]: Begin
	Realtime_devices = .device_addr;
	Realtime_version = .version_addr;
	Realtime_xfer_addr = .xfer_addr;
	Realtime_image = .image_addr;
	Max_realtime_type = .size - 1;
	Realtime_devices[0] = .size;
	Dc_class = DC$_REALTIME;
	End;

   [7]: Begin
	Bus_devices = .device_addr;
	Bus_version = .version_addr;
	Bus_xfer_addr = .xfer_addr;
	Bus_image = .image_addr;
	Max_bus_type = .size - 1;
	Bus_devices[0] = .size;
	Dc_class = DC$_BUS;
	End;

   [8]: Begin
	Packet_processor_devices = .device_addr;
	Packet_processor_version = .version_addr;
	Packet_processor_xfer_addr = .xfer_addr;
	Packet_processor_image = .image_addr;
	Max_misc_type = .size - 1;
	Packet_processor_devices[0] = .size;
	Translate_entry_table = get_vm (.size * word_size);
	Dc_class = DC$_ZERO_CLASS;
	End;

   [9]: Begin
	Workstation_devices = .device_addr;
	Workstation_version = .version_addr;
	Workstation_xfer_addr = .xfer_addr;
	Workstation_image = .image_addr;
	Max_Workstation_type = .size - 1;
	Workstation_devices[0] = .size;
	Dc_class = DC$_WORKSTATION;
	End;

   [OUTRANGE]:	Begin
		Signal (erf_badevval, 1, .index, .module_name_desc) ;
		Return true ;
		End;

   TES;

!
! Fill in the device class address of the 'class_dir' table. It
! contains the pointers to the device class specific tables (devices,
! version number, xfer address, and image name).
!
Incr count from 1 to .max_classes do
 Begin
 If .dev_class_ptr[.count] EQL .dc_class then   ! Make sure its the right slot
    Begin					!  for the address.
    Dev_addrs_ptr[.count] = .device_addr;	! Save the address of the 
    Return true ;				!  device name tables.
    End;
 End;

Signal (erf_clstblerr, 1,.dc_class) ;
Return true;
End ;

Routine PARSE_DEVICE_DESC_RECORD =
BEGIN
!++
! Functional description :
!	Each call to 'PARSE_TEXT_RECORD' returns the next item in
!	the record (comma seperated list). The state of CONTEXT
!	determines if more items are available in the record. The
!	item count (I) does not consider the INDEX as a item in the
!	record. The first item in the record is the item after the
!	'='.
!	  Record format:
!		INDEX = ITEM_ONE,ITEM_TWO,..ITEM_FOUR
!	  See 'DEVICES' module in SYS$LIBRARY:ERFLIB.TLB for
!	  more information.
!
!	For the first and second items returned convert them to dec.
!
!	If this is ITEM_ONE then save it as a device class. For
!	each device class (ITEM_ONE) see if the device type (INDEX)
!	is greater the is max allowable value.
!
!	If this is ITEM_TWO the save it as the allowable version
!	number for a loadable routine.
!
!	If this is ITEM_THREE then it is a two character device
!	name. Use INDEX to obtain the address in which this string
!	should be copied to.
!
!	If this is ITEM_FOUR then it is the name of the loadable image
!	that will interpurt this deviced error packet. This string
!	is copied to a table indexed by INDEX.
!
! Calling sequence
!
! Input parameters
!
!	RECORD_DESC global descriptor pointing at the record read
!		    from the text library.
!
! Output parameters
!
!	None
!
! Routine value
!
!	Worst error is returned.
!
!----

OWN
	Context,
	Dc_class:	BYTE,
	I,
	Index,
	Item_address:	REF $BBLOCK[dsc$k_d_bln],
	Size,
	Status,
	Table_addr,
	Temp,
	Value_addr,
	Version;


Context = 0;	! Clear the context
I = 1;		! Set the item count

Do
 Begin
 CALL_FUNCTION ( Parse_text_record ( context, index, value_addr, size ) );

 If .I LEQ 2 then	! If first or second item
   Begin		! then convert to binary
   Status = LIB$CVT_DTB ( .size, .Value_addr, size );
   If NOT .status then Signal (erf_cvterr, 2,.size,value_addr) ;

   If .I EQL 1 then dc_class = .size;	! If first item save
   End;

!
! Determine which device class is being processed. 
!
 Selectoneu .dc_class of
  Set

   [DC$_ZERO_CLASS]:
    Begin
     !
     ! Make sure it's a valid device type for this class of devices.
     !
     If .index GTR .max_misc_type then
        Signal (erf_badevtyp, 2, .index, .module_name_desc);

      !
      ! Determine which portion of the record is being processed and 
      ! get the address of the location to store the data.
      !
      Case .I from 2 to 4 of
       Set 
	[2]:
	   Packet_processor_version [ .index ] = .size;
	[3]:
	   Table_addr = Packet_processor_devices[.index];
	[4]:
	   Table_addr = Packet_processor_image[.index, desc_one];
	[Outrange]:
       TES;
    End ;

   [DC$_DISK]:
    Begin
     !
     ! Make sure it's a valid device type for this class of devices.
     !
     If .index GTR .max_disk_type then
        Signal (erf_badevtyp, 2, .index, .Module_name_desc);

      !
      ! Determine which portion of the record is being processed and 
      ! get the address of the location to store the data.
      !
      Case .I from 2 to 4 of
       Set 
	[2]:
	   Disk_version [ .index ] = .size;
	[3]:
	   Table_addr = Disk_devices[.index];
	[4]:
	   Table_addr = Disk_image[.index, desc_one];
	[Outrange]:
       TES;
    End ;

   [DC$_TAPE]:
    Begin
     !
     ! Make sure it's a valid device type for this class of devices.
     !
     If .index GTR .max_tape_type then
      Signal (erf_badevtyp, 2, .index, .Module_name_desc);

      !
      ! Determine which portion of the record is being processed and 
      ! get the address of the location to store the data.
      !
      Case .I from 2 to 4 of
       Set 
	[2]:
	   Tape_version [ .index ] = .size;
	[3]:
	   Table_addr = tape_devices[.index];
	[4]:
	   Table_addr = Tape_image[.index, desc_one];
	[Outrange]:
       TES;
    End ;
    
   [DC$_SCOM]:
    Begin
    !
    ! Make sure it's a valid device type for this class of devices.
    !
    If .index GTR .max_scom_type
    Then
	Signal (erf_badevtyp, 2, .index, .Module_name_desc) ;

    !
    ! Determine which portion of the record is being processed and 
    ! get the address of the location to store the data.
    !
    Case .I from 2 to 4 of
     Set
      [2]:
	Scom_version[.index] = .size ;

      [3]:
	Table_addr = scom_devices[.index];

      [4]:
	Table_addr = scom_image[.index, desc_one];

      [Outrange]:
      TES ;
    End ;

   [DC$_LP]:
    Begin
    !
    ! Make sure it's a valid device type for this class of devices.
    !
    If .index GTR .max_lp_type
    Then
	Signal (erf_badevtyp, 2, .index, .Module_name_desc) ;

    !
    ! Determine which portion of the record is being processed and 
    ! get the address of the location to store the data.
    !
    Case .I from 2 to 4 of
     Set
      [2]:
	Lp_version[.index] = .size ;

      [3]:
	Table_addr = lp_devices[.index];

      [4]:
	Table_addr = lp_image[.index, desc_one];

      [Outrange]:
      TES ;
    End ;

   [DC$_REALTIME]:
    Begin
    !
    ! Make sure it's a valid device type for this class of devices.
    !
    If .index GTR .max_realtime_type
    Then
	Signal (erf_badevtyp, 2, .index, .Module_name_desc) ;

    !
    ! Determine which portion of the record is being processed and 
    ! get the address of the location to store the data.
    !
    Case .I from 2 to 4 of
     Set
      [2]:
	Realtime_version[.index] = .size ;

      [3]:
	Table_addr = realtime_devices[.index];

      [4]:
	Table_addr = realtime_image[.index, desc_one];

      [Outrange]:
      TES ;
    End ;

   [DC$_BUS]:
    Begin
    !
    ! Make sure it's a valid device type for this class of devices.
    !
    If .index GTR .max_bus_type
    Then
	Signal (erf_badevtyp, 2, .index, .Module_name_desc) ;

    !
    ! Determine which portion of the record is being processed and 
    ! get the address of the location to store the data.
    !
    Case .I from 2 to 4 of
     Set
      [2]:
	Bus_version[.index] = .size ;

      [3]:
	Table_addr = bus_devices[.index];

      [4]:
	Table_addr = bus_image[.index, desc_one];

      [Outrange]:
      TES ;
    End ;

   [DC$_WORKSTATION]:
    Begin
     !
     ! Make sure it's a valid device type for this class of devices.
     !
     If .index GTR .max_workstation_type then
        Signal (erf_badevtyp, 2, .index, .Module_name_desc);

      !
      ! Determine which portion of the record is being processed and 
      ! get the address of the location to store the data.
      !
      Case .I from 2 to 4 of
       Set 
	[2]:
	   Workstation_version [ .index ] = .size;
	[3]:
	   Table_addr = Workstation_devices[.index];
	[4]:
	   Table_addr = Workstation_image[.index, desc_one];
	[Outrange]:
       TES;
    End ;

 TES;    

 If .I EQL 3 then CH$MOVE (.size, .value_addr, .table_addr );

 If .I EQL 4 then
   Begin
   Item_address = .table_addr;
   Item_address[dsc$w_length] = .size ;
   Item_address[dsc$a_pointer] = get_vm(.size);
   CH$MOVE (.size, .value_addr, .item_address[dsc$a_pointer]);
   End;

 I = .I + 1;

 End

While .context EQL 1;

Return true ;
End ;

Routine PARSE_MODULE_NAMES =
Begin
!++
! Functional description
!
!	This routine builds a descriptor table, which contains the names
!	of library modules to be processed.
!
! Calling sequence
!
! Input parameters
!
!	None.
!
! Output parameters
!
!
! Routine value
!
!
!----

Local
	Desc: REF $bblock [],
	Context: initial (0),
	Index,
	Value_addr,
	Size;

Do
  Begin

  Item_count = .item_count + 1;

  If .item_count GTR .table_length then
     (signal (erf_badevtyp, 2, .item_count, .Module_name_desc); Return true);

  Call_function (Parse_text_record ( context, index, value_addr, size) );

  Desc = desc_table_address[.item_count,desc_one];

  Desc[dsc$w_length] = .size;
  Desc[dsc$b_class] = dsc$k_class_d;
  Desc[dsc$b_dtype] = dsc$k_dtype_t;
! SIZE could be zero if the lib. module had ",," or ",<EOL>"
! This is could be a problem.
  Desc[dsc$a_pointer] = get_vm(.size);

  CH$MOVE (.desc[dsc$w_length], .value_addr, .desc[dsc$a_pointer]);

  End
While .context EQL 1;

Return true;
End;


Routine PARSE_TEXT_RECORD ( context, index, value_addr, size ) =
BEGIN
!++
! Functional description
!
!	This routine parses a record that was previously read from
!	the text library. Each call to this routine returns the next
!	item in the record(comma seperated list). CONTEXT is set after
!	returning all items in the list. The value of INDEX, in binary, 
!	is constant for all items in a record. VALUE_ADDR is the starting
!	address of the next item. Its size is returned in SIZE. All records
!	processed by this routine are expected to have 4 items after there
!	index. See 'DEVICES' module in SYS$LIBRARY:ERFLIB.TLB for more
!	information.
!
!
! Calling sequence
!
! Input parameters
!
!		 Context : Should always be zero in first call to this routine
!			   on return from this routine it is set to one to
!			   specify that there more values in the list.
!
!
! Output parameters
!
!		   Index : Binary value of the number to the left of the equal
!			   sign.
!
!	      Value_addr : Starting address of the string to be returned.
!
!		    Size : The length of the field pointed to by VALUE_ADDR
!
!		 Context : Binary 1 to indicate more values in the comma
!			   separated list.
!			   Binary 0 to indicate no more in the list.
!
!
! Routine value
!
!	Worst error is returned.
!
!----

LITERAL
	Max_deliminters = 3,
	TAB = 9;

OWN
	Context_length,
	Context_pointer,
	Delim_position:		INITIAL (0),
	Length_to_move,
	Offset,
	Status,
	Temp_ptr;



!
! If context equals 1 then compress the record and get the index.
!

If ..context EQL 0 then
 Begin

  !
  ! Setup pointer to start of record and record length.
  !
  Context_pointer = CH$PTR ( .Record_desc [dsc$a_pointer] );
  Context_length = .Record_desc [dsc$w_length];

  !
  ! Search the record for a '!'.
  !
  Delim_position = CH$FIND_CH ( .context_length, .context_pointer, %c'!' );

  !
  ! If the '!' is in the first character position then this is a comment,
  ! so return to get another record. If it is not in the first position
  ! then reset the record length to the '!' position.
  !
  If .Delim_position NEQ 0 then
   Begin
   Offset = CH$DIFF ( .delim_position , .context_pointer);
   If .Offset LEQ 3 then	    ! If "!" is in the first three positions
    Return false		    !  get the next record
   else				    !  else adjust the context length
    Context_length = .Offset - 1 ;  !  (Record length )
   End;

  Offset = 0;			    ! reset to zero for counting characters.
 
  !
  ! Search the record for a ' '. If a blank then compress record.
  !
  Delim_position = 1;
  While .Delim_position NEQ 0 do
   Begin
   Delim_position = CH$FIND_CH (.context_length,.context_pointer,%C' ');
   If .Delim_position EQL 0 then
     Delim_position = CH$FIND_CH (.context_length,.context_pointer,TAB);
   If .Delim_position NEQ 0 then
     Begin
     offset = .offset + 1;	! Count number of characters removed
     Temp_ptr = CH$DIFF(.delim_position+1, .context_pointer);
     Length_to_move = .context_length - .temp_ptr ;
     Temp_ptr = CH$COPY (.length_to_move, .delim_position + 1, %C'*',
			.length_to_move + 1, .delim_position);
     End;
   End;

  Context_length = .context_length - .offset;


  !
  ! Search the record for '='. If an equal sign is found get index and value.
  !

  Delim_position = CH$FIND_CH (.context_length,.context_pointer,%C'=');
  If .delim_position NEQ 0 then
    Begin
    Status = LIB$CVT_DTB ( (.delim_position - .context_pointer),  ! Calculate index field length
			    .context_pointer,			   ! Start of index string
			    .index );
    If NOT .status then Signal (erf_cvterr, 2,
			(.delim_position - .context_pointer),context_pointer) ;
    Context_length = .context_length - (.delim_position - .context_pointer);
    End;
 End;

Temp_ptr = 0;		! Clear pointer

!
! Get the value_addr, the size of the value field and
! if no commas are found set context to 0.
!

.Value_addr = .delim_position + 1;

Temp_ptr = CH$FIND_CH (.context_length-1, .delim_position + 1, %C',');
If .temp_ptr EQL 0 then
  Begin
  If ..context EQL 1 then
    .Size = .context_length - 1
  else
    .Size = .context_length - ( CH$DIFF (.delim_position, .context_pointer) );
  .Context = 0;
  End
else
  Begin
  .Size = CH$DIFF (.temp_ptr, .delim_position);
  Context_length = .context_length - ..size;
  .Size = ..size - 1;
  Delim_position = .temp_ptr;
  .Context = 1;
  End;
 
Return true ;
End ;

Routine INIT_COMMONS  =
Begin

!++
!
! Functional Description:
!
!	This routine initializes some of the commons in
!	ERFSHR (qiocommon, opcodes, modes).
!
! Calling Sequence:
!
!	Init_commons ()
!
! Input parameters
!
!	None
!
! Output parameters
!
!	None
!
!--

LOCAL
    Array_addr,
    Array_size,
    Status,
    Xfer_addr ;


!
! Get the image name and attempt to load it.
! Determine if a loading error occurred and signal it 
! if necessary.
!
Status = Map_image ( AD ('SYS$SYSTEM:ERFINICOM.EXE'), xfer_addr) ;
If NOT .status then return false ;

!
! Execute the image. Then set the flag indicateing that the commons have been
! initialized.
!
EXEC_IMAGE (xfer_addr) ;

Inited_commons = true ;

Return true ;
End ;		! Routine


Global routine VALIDATE_PACKET =
BEGIN
!++
! Functional description
!
!		This routine checks the error log packet entry type
!		to see if the type is valid for the CPU type it was
!		logged on.
!
! Calling sequence
!
!	Validate_packet()
!
! Input parameters
!
!
! Output parameters
!
!	If valid_cpu, valid_class, valid_type or valid_entry are false
!	then return false.
!
! Routine value
!
!	Worst error is returned.
!
!----

! THERE SHOULD BE A MAX_ENTRY_TYPE.

GLOBAL
	Processor_type:		LONG,
	Device_class:		BYTE,
	Device_type:		BYTE ;

LOCAL
	Table_size:		WORD INITIAL (0),
	Max_value:		BYTE,
	Min_range:		REF VECTOR[,WORD],
	Max_range:		REF VECTOR[,WORD],
	Begin_bit_pos:		LONG INITIAL (24),
	Version:		REF VECTOR[,WORD],
	Field_size:		LONG INITIAL (8);

!
! Set default state for valid flags
!
Syecom[sye$b_Valid_CPU] = true;
Syecom[sye$b_Valid_class] = true;

!
! Obtain processor type. Determine if the processor type in the SID has 
! been set up. (Early VAX systems did not have the processor type set).
!
Processor_type = LIB$EXTZV ( Begin_bit_pos, Field_size, emb[emb$l_hd_sid] );

If .processor_type EQLU 255 then processor_type = 1;


!
! Depending on processor type, determine which set of tables to use. 
! These tables specify invalid entry type ranges for specific cpu's.
!
Incr loop_count from 1 to .max_cpu_types do
 If .processor_type_table[.loop_count] EQL .Processor_type then
   Begin
   Min_range = .Min_range_table_addr[.loop_count];
   Max_range = .Max_range_table_addr[.loop_count];
   Table_size = .Min_max_table_sizes[.loop_count];
   Exitloop;
   End;
   
If .table_size EQL 0 then syecom[sye$b_Valid_CPU] = False;

!
! Ensure processing a device type entry.
!
If DEVICE_TYPE_ENTRY () 
Then
    Begin
    !
    ! Determine the type of device entry and set up device class
    ! and type from the appropriate fields in the EMB buffer.
    !
    Selectoneu .emb[emb$w_hd_entry] of
	Set
	[EMB$C_DE, EMB$C_DT, EMB$C_DA]:
	    Begin
	    Device_class = .emb[emb$b_dv_class] ;
	    Device_type = .emb[emb$b_dv_type] ;
	    End ;

	[EMB$C_LM]:
	    Begin
	    Device_class = .emb[emb$b_lm_class] ;
	    Device_type = .emb[emb$b_lm_type] ;
	    End ;

	[EMB$C_SP]:
	    Begin
	    Device_class = .emb[emb$b_sp_class] ;
	    Device_type = .emb[emb$b_sp_type] ;
	    End ;

	[EMB$K_LOGMSCP]:
	    Begin
	    If CH$EQL (2,emb[driver_type],2,CH$PTR(uplit('DISK')))
	    Then
		Begin
		Device_class = DC$_DISK ;
		Device_type = 1 ;
		End ;

	    If CH$EQL (2,emb[driver_type],2,CH$PTR(uplit('TAPE')))
	    Then
		Begin
		Device_class = DC$_TAPE ;
		Device_type = 1 ;
		End ;
	    End ;

	Tes ;

     !
     ! Determine the device class and set up the maximum number
     ! of device types.
     ! If class is out of range then VALID_class = False
     !
     Selectoneu .device_class of
	Set			
 
	[DC$_DISK]:	! Disk
		BEGIN
		Max_value = .max_disk_type;
		Version = .disk_version;
		END;

	[DC$_TAPE]:	! Tape
		BEGIN
		Max_value = .max_tape_type;
		Version = .tape_version;
		END;

	[DC$_SCOM]:	! Scom
		BEGIN
		Max_value = .max_scom_type;
		Version = .scom_version;
		END;

	[DC$_LP]:	! Printers
		BEGIN
		Max_value = .max_lp_type;
		Version = .lp_version;
		END;

	[DC$_REALTIME]:	! Realtime
		BEGIN
		Max_value = .max_realtime_type;
		Version = .realtime_version;
		END;

	[DC$_BUS]:	! Buses
		BEGIN
		Max_value = .max_bus_type;
		Version = .bus_version;
		END;

	[DC$_WORKSTATION]:	! Workstations
		BEGIN
		Max_value = .max_workstation_type;
		Version = .workstation_version;
		END;

	[OTHERWISE]:
	  Begin
	   Max_value = 0;
	   Version = 0;
	   Syecom[sye$b_Valid_class] = false;
	  End;

	TES;

!
! If device type is less then 1 or greater then max
! value or the version number is zero, then set flags false.
!
	If ( .device_type LSSU  1 ) OR
	   ( .device_type GTRU .max_value ) OR
	   ( .version EQLU 0 )
	Then
	  Syecom[sye$b_Valid_type] = false
	Else
	  If .version[.device_type] EQLU 0
	  then
	    Syecom[sye$b_Valid_type] = false
	  else
	    Syecom[sye$b_Valid_type] = true;
    End
Else
    Syecom[sye$b_valid_type] = true ;


!
! Ensure a valid cpu type was found. Otherwise don't attempt
! to do entry type verification.
!
If .syecom[sye$b_valid_cpu]
Then
    Begin
    Incr I from 1 to .table_size do
	Begin

	If ( .emb[emb$w_hd_entry] GEQU .min_range[.I] ) AND
	    ( .emb[emb$w_hd_entry] LEQU .max_range[.I] )
	then
	    Begin
	    Syecom[sye$b_Valid_entry] = false ;
	    Exitloop;
	    End	
	else 
            Syecom[sye$b_Valid_entry] = true ;
	End;
    End ;

If NOT .syecom[sye$b_valid_cpu] OR
   NOT .syecom[sye$b_valid_class] OR
   NOT .syecom[sye$b_valid_type] OR
   NOT .syecom[sye$b_valid_entry]
Then return false;

Return true;
End;

Routine HANDLER (sig, mech ) =

!---
!
!	This condition handler gets control on any signalled
!	condition in order to save the highest severity error
!	to be returned by exit from the image.
!
! Inputs:
!
!	signal_args = Address of signal argument list
!	mechanism_args = Address of mechanism argument list
!
! Outputs:
!
!	WORST_ERROR is updated with highest severity error.
!
!---

BEGIN

External worst_error: $BBLOCK [LONG] ;	! Holds worst error encountered

MAP					! Standard VMS condition handler parameters.
    sig:	REF $BBLOCK,		! Address of signal argument list
    mech:	REF $BBLOCK;		! Address of mechanism argument list

BIND
    COND = SIG[CHF$L_SIG_NAME]: $BBLOCK ;! Condition



If .COND eql RMS$_EOF then return true;

If .cond[sts$v_fac_no] eql erf$_facility then
   return ss$_resignal;

If
   .cond[sts$v_severity] gtru .worst_error [sts$v_severity] 
then
    worst_error = .cond or sts$m_inhib_msg;

sig[chf$l_sig_args] = .sig[chf$l_sig_args] - 2; ! Dont count pc/psl
$putmsg ( msgvec = sig[chf$l_sig_args], actrtn = write_err_msg);
sig[chf$l_sig_args] = .sig[chf$l_sig_args] + 2;

ss$_resignal					! Continue signalling

END;

Routine WRITE_ERR_MSG (Error_msg_desc) =
!---
!
!	This routine writes the error message to the output file.
!
! Inputs:
!
!	error_msg_desc = Address of descriptor for message
!
! Outputs:
!
!
!---
Begin

Local
	Rmserror;

Map
	Error_msg_desc : REF BLOCK[,BYTE];

If .Lstlun_rab_address EQL 0 then return false;

Lstlun_rab_address[rab$l_rbf] = .error_msg_desc[dsc$a_pointer];
Lstlun_rab_address[rab$w_rsz] = .error_msg_desc[dsc$w_length];

If NOT (rmserror = $put(rab = .Lstlun_rab_address)) then
  ( Signal (.rmserror); Return .rmserror);

Return false;
End;

Global routine WRITE_BINARY (BUFFER, RAB) =

!----
!
! Functional description
!
!	This routine accepts a pointer to a buffer and writes
!	the buffer to an output stream in binary format.
!
! Input parameters
!
!	BUFFER = address of an input record buffer
!
!	RAB =    address of output rab
!
!----

BEGIN

MAP
   rab:		ref $bblock,		! Pointer to rab
   buffer: 	ref $bblock;		! Describe the input buffer

LOCAL
	desc:	vector [2, long];	! Temporary string descriptor


If .rab eql 0 then return true;		! Exit immediately if no output

!
!INITIALIZE THE RAB
!	Store the buffer address and length in the RAB.
!

rab [rab$l_rbf] = .buffer;			! Store buffer address in RAB
rab [rab$w_rsz] = .input_rab[rab$w_rsz];	! Store buffer size in RAB



!
!WRITE TO FILE ---
!	Output the buffer via RMS.
!

CALL_FUNCTION  ($put (			! Call RMS with
		rab = .rab,		!  -record stream identifier
		err = log_filename));	!  -error action routine

return true;
END;

END
ELUDOM

