%TITLE 'SMG$$MINIMUM_UPDATE - Minimum update calculation and output'
MODULE SMG$$MINIMUM_UPDATE (
		IDENT = '1-045'	! File: SMGMINUPD.B32 Edit: STAN1045
		) =
BEGIN
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY:	Screen Management
!
! ABSTRACT:
!
!	This module contains routines which inspect two screen 
!	representations and calculate the near-minimal sequence of 
!	terminal commands to change the current contents of the screen 
!	to the new representation of the screen.
!	Also contained herein are routines pertaining to buffering.
!
! ENVIRONMENT:	User mode, Shared library routines.
!
! AUTHOR: R. Reichert, CREATION DATE: 15-APR-1983
!
! MODIFIED BY:
!
! 1-045 - STAN 17-Apr-1984. Store unknown terminal type correctly in PBCB.
! 1-044 - STAN  7-Apr-1984. Minor change for unsolicit input.
! 1-043 - STAN 31-Mar-1984. Fix dot bug in SET_ATTRIBUTES_OFF.
! 1-042 - STAN 21-Mar-1984. Fixed bug with border vector.
! 1-041 - STAN 18-Mar-1984. Renove use of %ASCID that causes PSECTS
!	  to be read/write thus making their use impractical for
!	  shared images.
!	  Home cursor before erasing screen.
!	  Change test for unknown terminal.
! 1-040 - STAN 14-Mar-1984. Ensure final cursor position doesn't change
!	  after removing any scrolling region in the exit handler.
!	  Change END_BOLD capability to BEGIN_NORMAL_RENDITION.
!	  Handle unknown terminals.
!	  Make truncation icon work again; also other control displays.
!	  Write two new routines, SET_ATTRIBUTES_ON and SET_ATTRIBUTES_OFF.
! 1-039 - STAN 23-Feb-1984. Bug fix.
!	  Initialize characteristics from terminal characteristics
!	  not from termtable capabilities.
!	  Allow long sequences for border vector.
!	  Add temporary SET_ATTRIBUTES_ONLY.
! 1-038 - STAN 21-Feb-1984. Bug fixes.
! 1-037 - STAN 21-Feb-1984. Store BS bit in PBCB.
! 1-036 - STAN 13-Feb-1984. Install Pam's fix for VT52s.
!	  Bug fix in exit handler.
! 1-035 - STAN  7-Feb-1984. Allow positive terminal codes.
! 1-034 - STAN 15-Jan-1983. Use TERMTABLE.
!	  Fix charset bug.
! 1-033 - STAN 14-Dec-1983. Fix dot bug in edit 32.
! 1-032 - RKR   2-Dec-1983. Add SMG$$ERASE_PASTEBOARD.  This inner routine
!	  goes directly to SMG$$FLUSH_BUFFER rather than SMG$FLUSH_BUFFER.
!	  Redirect current calls to SMG$ERASE_PASTEBOARD to call 
!	  SMG$$ERASE_PASTEBOARD instead.
! 1-031 - STAN  2-Nov-1983. Restore terminal width on exit.
! 1-030 - STAN 14-Oct-1983. Invalidate screen on CTRL/O.
! 1-029 - STAN 13-Oct-1983. Bug fix for scrolling wide lines.
! 1-028 - Handle DIAMOND and control character displays. STAN 5-Oct-1983.
! 1-027 - Handle user graphics. STAN 19-sep-1983.
!	  Clear screen on exit if so requested.
! 1-026 - Add SMG$$AUTOB_OUTPUT so the autobended routines can
!	  output directly to the pb without knowing the pb addr.
!	  PLL 9-Sep-1983
! 1-025 - Add SMG$ERASE_PASTEBOARD. STAN 25-Aug-1983
! 1-024 - Changes to SMG$$CHECK_HDWR_SCROLL and SMG$$MIN_UPD to support
!	  double-wide/double high text.  RKR 17-AUG-1983.
! 1-023 - Add some preprocessing to SMG$$MIN_UPD to refine the range
!	  of lines that actually changed.  RKR 12-AUG-1983.
! 1-022 - Modify CHECK_HDWR_SCROLL to bypass situation where in fact
!	  the virtual display contains line-by-line identical contents
!	  except for the top or bottom line.
!	  For example, if you fill up (except the last line ) a 
!	  virtual display with the text
!		COMMAND:
!		COMMAND:
!		COMMAND:
!
!	  As you write the last line to COMMAND:, the current logic
!	  will downscroll the virtual display and repaint the top line.
!	  This will produce the right result but looks ugly.  Right
!	  now this will also happen when you clear a display to all
!	  spaces since it falls into the upscroll logic.
!	  This fix intercepts the cases where the virtual display
!	  has changed only in the 1st or last line, avoids scrolling,
!	  and lets the rest of minimal update repaint just the last line
! 1-021 - RKR Remove temporary fix to scrolling problem.  Compensating
!	  code in SMG$$FIND_MIN_CURSOR_POS and SMG$$SET_PHYSICAL_CURSOR 
!	  should now take care of the problem.
! 1-020 - RKR 3-AUG-1983. Consolidate lines of code pertaining to
!	  actually setting the physical scrolling region into a new
!	  subroutine SMG$$FORCE_SCROLL_REG.
! 1-019 - RKR 1-AUG-1983. Modify SMG$$CHECK_HDWR_SCROLL to provide
!	  downscrolling as well as upscrolling.
! 1-018 - STAN 28-Jul-1983. Temporary fix to remove scrolling
!			    region after use.
! 1-017 - RKR  15-JUL-1983. Fix bug found by J. Burrows.
! 1-016 - RKR  14-JUL-1983. Minor code improvements and better comments
!	  to newly-added code.

! 1-015 - RKR  12-Jul-1983. Add SMG$$CHECK_HDWR_SCROLL.
! 1-014 - STAN 21-Jun-1983. Temporary fix.
! 1-013 - STAN 18-Jun-1983. File output.
! 1-012 - RKR 20-May-1983 Remove external references to DD_ structures
!			  and counts -- no longer needed (or available).
! 1-011 - STAN 16-May-1983 Pasteboard batching
! 1-010	- STAN 11-May-1983
!	  Use shift out and shift in.
! 1-009 - STAN 10-May-1983
!	  Temporary fix for rendition attribute.
! 1-008 - STAN 8-May-1983
!	  Flush buffer only on success exit.
! 1-007 - STAN 2-May-1983
!	  Fixed bug in buffering.
!	  Handle border rendition.
!	  Don't flush buffer on CLI forced exit.
! 1-006 - STAN 1-May-1983
!	  SMG$$PUT_OUTPUT,
!	  SMG$$OUTPUT,
!	  Finished SMG$$FLUSH_BUFFER.
! 1-005 - One additional tweak. RKR 26-APR-1983.
! 1-004 - Minor optimization.  RKR 26-APR-1983.
! 1-003 - Fix video attribute production.  RKR 21-APR-1983.
! 1-002 - Minor temp speed up.  RKR 18-APR-1983
! 1-001	- Shell for further development.  RKR 15-APR-1983.
!--

%SBTTL 'Declarations'
!
! TABLE OF CONTENTS:
!

FORWARD ROUTINE

!	Public entry points

	SMG$ERASE_PASTEBOARD,		! Clears screen

	SMG$FLUSH_BUFFER,		! Flush remaining buffered
					! output to screen by display id.

	SMG$PUT_PASTEBOARD,		! Output pasteboard via user routine

	SMG$SNAPSHOT,			! Take an RMS snapshot

!	Private entry points

	SMG$$CHECK_HDWR_SCROLL,		! Check to see if harware scroll
					! will help min. update

	SMG$$ERASE_PASTEBOARD,		! Inner ERASE_PASTEBOARD routine

	SMG$$PBCB_EXIT_HANDLER,		! Exit handler to flush pasteboard

	SMG$$SETUP_TERMINAL_TYPE,	! Find out type of terminal.

	SMG$$FLUSH_BUFFER,		! Flush remaining buffered
					! output to screen by PBCB.

	SMG$$FORCE_SCROLL_REG,		! Force physical scrolling
					! region to that specified.

	SMG$$PUT_SCREEN,		! Put text to screen with rendition
					! and cursor positioning

	SMG$$AUTOB_OUTPUT,		! Autobended entry to SMG$$OUTPUT

	SMG$$SET_ATTRIBUTES_ON,
	SMG$$SET_ATTRIBUTES_OFF,
	SMG$$OUTPUT,			! Raw outputter
	SMG$$MIN_UPD,			! force compatibility *** temp
	SMG$$OUTPUT_PASTEBOARD,		! Output pasteboard (use minimal
					! update if this mode is enabled)

!	Local entry points

	ESTABLISH_BORDER_VECTOR : NOVALUE,	! Create border vector
	RMS_RTN,			! Output record with RMS
	OUTPUT;				! Low level output routine

!
! SWITCHES:
!
!	in include files

!
! LINKAGES:
!
!	in include files

!
! INCLUDE FILES
!

REQUIRE 'RTLIN:SMGPROLOG';		! defines psects, macros, 
					! structures, & terminal symbols
REQUIRE 'RTLIN:STRLNK.REQ';		! JSB linkages

!
! EXTERNAL REFERENCES
!

EXTERNAL

	PBD_L_COUNT,	! No. of pasteboards we currently have

	PBD_A_PBCB : VECTOR [PBD_K_MAX_PB, LONG],
			! Table of addresses of PBCB's

	PBD_V_PB_AVAIL : BITVECTOR [PBD_K_MAX_PB];
			! Bit vector or pasteboard id numbers in use.

EXTERNAL LITERAL

	SMG$_WILUSERMS,	! RMS will be used later to perform output
	SMG$_INVPAS_ID;	! Invalid pasteboard id

EXTERNAL ROUTINE

	LIB$GET_EF,
	LIB$GET_VM,
	SMG$$FIND_MIN_CURSOR_POS,
	SMG$BEGIN_PASTEBOARD_UPDATE,
	SMG$END_PASTEBOARD_UPDATE,
	SMG$$OUTPUT_MINIMAL_UPDATE;

OWN

	FIRST_TIME_FLAG : INITIAL (0);	!***** Kludge -- ignore ***

%SBTTL 'SMG$ERASE_PASTEBOARD- Clear Screen'
GLOBAL ROUTINE SMG$ERASE_PASTEBOARD ( PASTEBOARD_ID ) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine erases the entire pasteboard.
!	The physical cursor is left at (1,1).
!
! CALLING SEQUENCE:
!
!       ret_status.wlc.v = SMG$ERASE_PASTEBOARD ( PASTEBOARD_ID.rl.r )
!
! FORMAL PARAMETERS:
!
!	PASTEBOARD_ID.rl.r	The id of the PASTEBOARD which is to be cleared.
!
! IMPLICIT INPUTS:
!
!       None
!
! IMPLICIT OUTPUTS:
!
!       None
!
! COMPLETION STATUS:
!
!       SS$_NORMAL      Normal successful completion
!       SMG$_WRONUMARG  Wrong number of arguments.
!	SMG$_INVPAS_ID	Invalid pasteboard id.
!
! SIDE EFFECTS:
!
!       NONE
!--
    BEGIN

    LOCAL
	PBCB	: REF $PBCB_DECL;	! Address of pasteboard control block.


    $SMG$VALIDATE_ARGCOUNT(1,1);

!+
! Isolate pasteboard control block.
!-

    $SMG$GET_PBCB(.PASTEBOARD_ID,PBCB);	! Get address of PBCB

    RETURN (SMG$$ERASE_PASTEBOARD (.PBCB));

END;		! routine SMG$ERASE_PASTEBOARD

%SBTTL 'SMG$$ERASE_PASTEBOARD- Clear Screen'
GLOBAL ROUTINE SMG$$ERASE_PASTEBOARD ( PBCB : REF $PBCB_DECL ) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine erases the entire pasteboard.
!	The physical cursor is left at (1,1).
!
! CALLING SEQUENCE:
!
!       ret_status.wlc.v = SMG$$ERASE_PASTEBOARD ( PBCB.rab.r)
!
! FORMAL PARAMETERS:
!
!	PBCB.rab.r	Address of pasteboard control block
!
! IMPLICIT INPUTS:
!
!       None
!
! IMPLICIT OUTPUTS:
!
!       None
!
! COMPLETION STATUS:
!
!       SS$_NORMAL      Normal successful completion
!
! SIDE EFFECTS:
!
!       NONE
!--

BEGIN

LOCAL

	STATUS,
	WCB	: REF $WCB_DECL;	! Address of window control block.

!+
! Flush out our buffers.
!-

    STATUS=SMG$$FLUSH_BUFFER(.PBCB);
    IF NOT .STATUS THEN SIGNAL(.STATUS);

!+
! Home the cursor. (erase_whole_display doesn't necessarily do that).
!-

    $SMG$GET_TERM_DATA(HOME);
    STATUS=OUTPUT(.PBCB,.PBCB[PBCB_L_CAP_LENGTH],.PBCB[PBCB_A_CAP_BUFFER]);
    IF NOT .STATUS THEN RETURN .STATUS;

!+
! Physically clear the screen with an escape sequence.
!-

    $SMG$GET_TERM_DATA(ERASE_WHOLE_DISPLAY);

!+
! Make sure it happens immediately by calling OUTPUT rather than SMG$$OUTPUT.
! This way it won't get buffered.
!-

    STATUS=OUTPUT(.PBCB,.PBCB[PBCB_L_CAP_LENGTH],.PBCB[PBCB_A_CAP_BUFFER]);
    IF NOT .STATUS THEN RETURN .STATUS;

!+
! Set the screen buffers to all blanks.
!-

    WCB=.PBCB[PBCB_A_WCB];
    CH$FILL(%C' ',.WCB[WCB_L_BUFSIZE],.WCB[WCB_A_TEXT_BUF]);
    CH$FILL(%C' ',.WCB[WCB_L_BUFSIZE],.WCB[WCB_A_SCR_TEXT_BUF]);
    CH$FILL(0,    .WCB[WCB_L_BUFSIZE],.WCB[WCB_A_ATTR_BUF]);
    CH$FILL(0,    .WCB[WCB_L_BUFSIZE],.WCB[WCB_A_SCR_ATTR_BUF]);
    IF .WCB[WCB_A_CHAR_SET_BUF] NEQ 0
    THEN
	BEGIN
	CH$FILL(0,.WCB[WCB_L_BUFSIZE],.WCB[WCB_A_CHAR_SET_BUF]);
	END;

    IF .WCB[WCB_A_SCR_CHAR_SET_BUF] NEQ 0
    THEN
	BEGIN
	CH$FILL(0,.WCB[WCB_L_BUFSIZE],.WCB[WCB_A_SCR_CHAR_SET_BUF]);
	END;

!+
! The physical cursor moves to (1,1).
!-

    WCB[WCB_W_CURR_CUR_ROW]=1;
    WCB[WCB_W_OLD_CUR_ROW] =1;
    WCB[WCB_W_CURR_CUR_COL]=1;
    WCB[WCB_W_OLD_CUR_COL] =1;

!+
! The line characteristics get set back to 0.
!-

    CH$FILL(0,.WCB[WCB_W_NO_ROWS]+1,.WCB[WCB_A_LINE_CHAR]);
    CH$FILL(0,.WCB[WCB_W_NO_ROWS]+1,.WCB[WCB_A_SCR_LINE_CHAR]);

    RETURN	SS$_NORMAL

END;		! routine SMG$$ERASE_PASTEBOARD

%SBTTL 'SMG$FLUSH_BUFFER - Flush all buffered output to terminal'
GLOBAL ROUTINE SMG$FLUSH_BUFFER (
				  PASTEBOARD_ID
				) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine causes all output which has been buffered up but
!	not yet sent to the terminal, to be output at once.
!	It does not matter if our caller is also buffering output.
!	When a user requests a flush, we FLUSH. And NOW.
!
! CALLING SEQUENCE:
!
!       ret_status.wlc.v = SMG$FLUSH_BUFFER ( PASTEBOARD_ID.rl.r )
!
! FORMAL PARAMETERS:
!
!	PASTEBOARD_ID.rl.r	The id of the PASTEBOARD for which the
!				flushing action is to take place.
!
! IMPLICIT INPUTS:
!
!       None
!
! IMPLICIT OUTPUTS:
!
!       None
!
! COMPLETION STATUS:
!
!       SS$_NORMAL      Normal successful completion
!       SMG$_WRONUMARG  Wrong number of arguments.
!	SMG$_INVPAS_ID	Invalid pasteboard id.
!
! SIDE EFFECTS:
!
!       NONE
!--

BEGIN

LOCAL

	PBCB;		! Address of associated
			! pasteboard control block.

!+
! Isolate pasteboard control block and call inner routine to do the
! work.
!-

$SMG$GET_PBCB(.PASTEBOARD_ID,PBCB);	! Get address of PBCB

RETURN SMG$$FLUSH_BUFFER(.PBCB)

END;			! Routine SMG$FLUSH_BUFFER

%SBTTL 'SMG$$CHECK_HDWR_SCROLL - Check to see if use of hardware scroll will help'
GLOBAL ROUTINE SMG$$CHECK_HDWR_SCROLL (
				      PBCB : REF $PBCB_DECL 
				      ) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine checks to see if the WCB text buffer has changed
!	in such a way that we can optimize the output by using
!	hardware scrolling regions and letting the terminal scroll.
!
!	Screen Text		Text
!	Buffer			Buffer
!
!	+---------------+	+---------------+
!	|		|	|		|
!	|		|	|		|
! N --->|		|	|		| <--- N
!	|		|	|		|
!	|		|	|		|
! M --->|		|	|		| <--- M
!	|		|	|		|
!	|		|	|		|
!	+---------------+	+---------------+
!
!	If information in the PBCB tells us that lines N through M
!	of the text buffer have been changed, we check to see if
!
!		Line N   of Text Buffer = Line N+1 of Screen Text Buf.
!		Line N+1 of Text Buffer = Line N+2 of Screen Text Buf.
!		.
!		.
!		.
!
!		Line M-1 of Text Buffer = Line M of Screen Text Buf.
!
!	This can be done with a single compare instruction since the
!	areas are continguous.
!
!	If these areas are the same, the probability is very high that
!	the text buffer was changed by scrolling line N through M
!	upward by one line and inserting a new line (M) into the buffer.
!	If we determine that this is the case, we use the hardware to
!	accomplish the scroll for us, update the screen text buffer to
!	reflect the effects of the scroll, and then fall into the
!	normal minimal update logic to patch up minor differences, e.g.,
!	attribute information.
!
!	In an analogous fashion, we also check to see if the change
!	represents a downscroll of one line.
!
! 	This routine is called only when it has already been established
!	that we are dealing with a device that has settable scrolling
!	regions and at least 2 consecutive lines have changed.
!
! CALLING SEQUENCE:
!
!	ret_status.wlc.v = SMG$$CHECK_HDWR_SCROLL ( PBCB.rl.r)
!
! FORMAL PARAMETERS:
!
!	PBCB.rl.r	Address of a Pasteboard Control Block
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!       NONE
!
! COMPLETION STATUS:
!
!       SS$_NORMAL	Normal Successful Completion
!
! SIDE EFFECTS:
!
!	NONE
!--

BEGIN

LOCAL

	STATUS,			! Status of subroutine calls

	WCB : REF $WCB_DECL,	! Address of associated Window Control 
				! Block

	TB,			! Index of 1st byte in WCB text buffer
				! that may have been changed.

	STB,			! Index into WCB Screen Text buffer
				! of starting byte position which
				! should be the same if changes were
				! made via a single-line scroll
				! operation.

	WIDTH,			! Longword counterpart of
				! .WCB [WCB_W_NO_COLS] -- extracted to
				! yield better code.

	BTC,			! Number of bytes that need to be
				! compared.

	LCS : REF VECTOR [,BYTE],	! Address of line
					! characteristics vector assoc.
					! with WCB [WCB_A_SCR_TEXT_BUF].

	SR,	! Top or bottom line of scrolling region.
		! =.LCR if scrolling up
		! =.FCR if scrolling down

	FCR,	! First changed row = .PBCB [PBCB_W_FIRST_CHANGED_ROW]
	LCR,	! Last  changed row = .PBCB [PBCB_W_LAST_CHANGED_ROW]
		! Extracting the fields above gives better code

	DL;	! Delta number of lines (-1) that changed, = .LCR - .FCR

WCB = .PBCB [PBCB_A_WCB];

!+
! Extract following fields for better code generation.
!-

WIDTH = .WCB [WCB_W_NO_COLS];
FCR = .PBCB [PBCB_W_FIRST_CHANGED_ROW];
LCR = .PBCB [PBCB_W_LAST_CHANGED_ROW];

DL = .LCR - .FCR;	! Known to be 1 or greater

!+
! Calc. the starting byte position in the text buffer that could have
! changed.
!-

TB = (.FCR - 1) * .WIDTH;

!+
! Calc. the corresponding byte position in the screen text buffer that
! should match if change was brought about by an upward scroll of one
! line -- a common phenomena.  This will be one line further down in the
! buffer.
!-

STB = .TB + .WIDTH;

!+
! Calc. how many byte positions in the text buffer should match the
! given slot in the screen text buffer.
!-

BTC = ( .DL ) * .WIDTH;

!+
! Check to see if an upscroll or downscroll of one line accounts for
! the differences between the text and screen buffers.
!-
IF (CH$EQL ( .BTC, .WCB [WCB_A_TEXT_BUF]     + .TB,
	     .BTC, .WCB [WCB_A_SCR_TEXT_BUF] + .STB))
THEN
    SR = .LCR	! Will be upscrolling
ELSE
    BEGIN	! Check for downscrolling
    TB = .FCR * .WIDTH ; ! Line N+1
    STB = .TB - .WIDTH ; ! Line N
    IF (CH$EQL ( .BTC, .WCB [WCB_A_TEXT_BUF]     + .TB,
	         .BTC, .WCB [WCB_A_SCR_TEXT_BUF] + .STB))
    THEN
	SR = .FCR	! Will be downscrolling
    ELSE
	RETURN (SS$_NORMAL);	! Quit -- neither upscroll or downscroll
				! of 1 line will do it.
    END;	! Check for downscrolling

!+
! If we reach here, we have a candidate for scrolling.
! Check to see if physical scrolling region on the terminal matches
! the area we want to scroll.  If not, set it to the desired region
! and record where we left it.
!-

IF .FCR  NEQ .PBCB [PBCB_W_TOP_SCROLL_LINE] 	OR
   .LCR  NEQ .PBCB [PBCB_W_BOT_SCROLL_LINE]
THEN
	BEGIN	! Not where we want it, reset
	IF NOT (STATUS = SMG$$FORCE_SCROLL_REG ( .PBCB, .FCR, .LCR))
	THEN
	    RETURN .STATUS;

	END;	! Not where we want it, reset

!+
! Set physical cursor to either top or bottom line of scroll region.
!-

   SMG$$FIND_MIN_CURSOR_POS ( .PBCB,
			      .WCB [WCB_W_OLD_CUR_ROW], ! Current
			      .WCB [WCB_W_OLD_CUR_COL], ! Current
			      .SR, 			! Desired
			      1);   			! Desired

!+
! Update screen image with respect to current cursor positioning.
!-

    WCB [WCB_W_OLD_CUR_ROW] = .SR;
    WCB [WCB_W_OLD_CUR_COL] = 1;
    WCB [WCB_W_CURR_CUR_ROW] = .SR;
    WCB [WCB_W_CURR_CUR_COL] = 1;

!+
! Set up base of line characteristics vector for what is currently
! on the screen.  This vector will have to have its entries shuffled
! up or down.
!-
    LCS = .WCB [WCB_A_SCR_LINE_CHAR];

!+
! Write a line-feed into the bottom line of the scrolling region or
! perform a down_scroll in the top line of the scrolling region,
! causing current lines N through M to scroll either down or up.
!	***NOTE:  This is not the best solution.  Writing a <LF> will
!		  cause a blank line to be written with video attributes
!		  of "normal".  This line should really be line M, with
!		  all its video attributes in all their glory.
!		  That takes too long to compute.  We compromise with
!		  a line of normal blanks and let the rest of Min_Upd
!		  straigten it out later, even though the line will get
!		  written twice and will flicker at low baud rates.
!-

IF .SR EQL .LCR
THEN
    BEGIN	! Upscroll action
    !+
    ! Upscroll by outputting a <LF> in last line of scrolling region.
    !-

!    $SMG$GET_TERM_DATA(SCROLL_FORWARD);
!    IF .PBCB[PBCB_L_CAP_LENGTH] EQL 0
!    THEN
!	RETURN 1;
!
!    STATUS = SMG$$OUTPUT (.PBCB, .PBCB[PBCB_L_CAP_LENGTH],
!				 .PBCB[PBCB_A_CAP_BUFFER]);
!    IF NOT .STATUS THEN RETURN .STATUS;

    STATUS = SMG$$OUTPUT (.PBCB, 1, UPLIT BYTE(10));
    IF NOT .STATUS THEN RETURN .STATUS;

    !+
    ! Slide screen line characteristics vector up by one to correspond 
    ! to lines that got scrolled up.
    !-
    CH$MOVE ( .DL, LCS [.FCR+1], LCS [.FCR]);
    LCS[.LCR]=0;

    END		! Upscroll action

ELSE

    BEGIN	! Downscroll action

    !+
    ! Downscroll by emitting a reverse index or a down-scroll escape sequence.
    !-

    $SMG$GET_TERM_DATA(REVERSE_INDEX);
    IF .PBCB[PBCB_L_CAP_LENGTH] EQL 0
    THEN
	BEGIN
	$SMG$GET_TERM_DATA(SCROLL_REVERSE,1);
	IF .PBCB[PBCB_L_CAP_LENGTH] EQL 0
	THEN
	    RETURN 1;
	END;

    STATUS = SMG$$OUTPUT (.PBCB, .PBCB[PBCB_L_CAP_LENGTH],
				 .PBCB[PBCB_A_CAP_BUFFER]);
    IF NOT .STATUS THEN RETURN .STATUS;

    !+
    ! Slide screen line characteristics vector down by one to correspond
    ! to lines that got scrolled down.
    !-
    CH$MOVE ( .DL, LCS [.FCR], LCS [.FCR+1]);
    LCS[.FCR]=0;

    END;	! Downscroll action


!+
! Update screen buffer to reflect what scrolling operation should have
! done to the screen.
!-
    ! Text that got scrolled, move screen text buffer by 1 line
    CH$MOVE ( .BTC,
	      .WCB [WCB_A_SCR_TEXT_BUF] + .STB,
	      .WCB [WCB_A_SCR_TEXT_BUF] + .TB);

    ! Attributes that go along with text that scrolled
    CH$MOVE ( .BTC,
	      .WCB [WCB_A_SCR_ATTR_BUF] + .STB,
	      .WCB [WCB_A_SCR_ATTR_BUF] + .TB);

    ! Blank line introduced by scroll operation
    CH$FILL ( %C' ',				! Fill
	      .WIDTH,				! No. of chars
	      .WCB [WCB_A_SCR_TEXT_BUF] + (.SR -1) * .WIDTH);

    ! Attributes for blank line introduced by scroll
    !	NOTE: See note above.  This line of code is related.

    CH$FILL ( 0,					! Fill
	      .WIDTH,				! No. of chars
	      .WCB [WCB_A_SCR_ATTR_BUF] + (.SR -1) * .WIDTH);

RETURN	SS$_NORMAL

END;			! Routine SMG$$CHECK_HDWR_SCROLL

%SBTTL 'SMG$$FLUSH_BUFFER - Flush all buffered output to terminal'
GLOBAL ROUTINE SMG$$FLUSH_BUFFER ( P_PBCB ) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine causes all output which has been buffered up but
!	not yet sent to the terminal, to be output at once.
!
! CALLING SEQUENCE:
!
!       ret_status.wlc.v = SMG$$FLUSH_BUFFER ( P_PBCB.rab.r )
!
! FORMAL PARAMETERS:
!
!	P_PBCB.rab.r	The pasteboard control block address for which 
!			the flushing action is to take place.
!
! IMPLICIT INPUTS:
!
!       PBCB[PBCB_W_OUTPUT_BUFLEN]	number of characters in buffer
!       PBCB[PBCB_W_OUTPUT_BUFFER]	address of buffer
!
! IMPLICIT OUTPUTS:
!
!       PBCB[PBCB_W_OUTPUT_BUFLEN]	set to 0 (indicating buffer empty)
!
! COMPLETION STATUS:
!
!       SS$_NORMAL      Normal successful completion
!	SS$_xyz		errors from SMG$$OUTPUT.
!
! SIDE EFFECTS:
!
!       NONE
!--

BEGIN

BIND

	PBCB	= .P_PBCB	: $PBCB_DECL,	! Pasteboard control block
	OUTBUF	= .PBCB[PBCB_A_OUTPUT_BUFFER]	: VECTOR,
	OUTLEN	=  PBCB[PBCB_W_OUTPUT_BUFLEN]	: WORD;

LOCAL

	STATUS;

!+
! Do nothing if the buffer is empty.
!-

IF .OUTLEN EQL 0
  THEN	RETURN	SS$_NORMAL;

!+
! Output the buffer now.
! Save time by calling OUTPUT directly rather than SMG$$OUTPUT.
! (SMG$$OUTPUT would try to buffer the text up anyhow.)
!-

STATUS=OUTPUT(PBCB,.OUTLEN,OUTBUF);
IF NOT .STATUS THEN RETURN .STATUS;

!+
! Note that the buffer is now empty.
!-

OUTLEN=0;

RETURN	SS$_NORMAL

END;			! Routine SMG$$FLUSH_BUFFER

%SBTTL 'SMG$$FORCE_SCROLL_REG - Force physical scrolling regions'
GLOBAL ROUTINE SMG$$FORCE_SCROLL_REG (
					PBCB : REF $PBCB_DECL,
					TOP_LINE,
					BOT_LINE
				     ) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine performs three actions:
!		a). Construct escape sequence needed to set scroll
!		    region.
!		b). Output this sequence to terminal.
!		c). Update PBCB to reflect new position of scroll
!		    region.
!
!	The physical cursor is left in first row of scrolling region,
!	COLUMN 1.
!
! CALLING SEQUENCE:
!
!       ret_status.wlc.v = SMG$$FORCE_SCROLL_REG (
!						  PBCB.rab.r,
!						  TOP_LINE.rl.v,
!						  BOT_LINE.rl.v)
!
! FORMAL PARAMETERS:
!
!	PBCB.rab.r	Address of Pasteboard Control Block
!	TOP_LINE.rl.v	Top line of physical scroll region desired.
!	BOT_LINE.rl.v	Bottom line of physica scroll region desired.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!       SS$_NORMAL      Normal successful completion
!	SS$_xyz		errors from SMG$$OUTPUT.
!
! SIDE EFFECTS:
!
!	Physical scrolling region changed.
!--

BEGIN
LOCAL

    WCB		: REF $WCB_DECL,
    STATUS;			! Status of subroutine calls

WCB=.PBCB[PBCB_A_WCB];

!+
! Create escape sequence needed into capability buffer.
!-

$SMG$GET_TERM_DATA(SET_SCROLL_REGION,.TOP_LINE,.BOT_LINE);

!+
! Output BUFFER.
!-
IF NOT (STATUS = SMG$$OUTPUT ( .PBCB, .PBCB[PBCB_L_CAP_LENGTH],
				      .PBCB[PBCB_A_CAP_BUFFER])) 
THEN 
    RETURN .STATUS;

!+
! Record where scrolling region now is.
!-

PBCB [PBCB_W_TOP_SCROLL_LINE] = .TOP_LINE;
PBCB [PBCB_W_BOT_SCROLL_LINE] = .BOT_LINE;

!+
! Move the cursor to the first row of the scrolling region, column 1.
!-

$SMG$GET_TERM_DATA(SET_CURSOR_ABS,.TOP_LINE,1);

!+
! Output BUFFER.
!-

IF .PBCB[PBCB_L_CAP_LENGTH] NEQ 0
  THEN	BEGIN
	IF NOT (STATUS = SMG$$OUTPUT ( .PBCB, .PBCB[PBCB_L_CAP_LENGTH],
				      .PBCB[PBCB_A_CAP_BUFFER])) 
	THEN 
	    RETURN .STATUS;

	!+
	! Record where the cursor is now.
	!-

	WCB[WCB_W_CURR_CUR_ROW]=.TOP_LINE;
	WCB[WCB_W_CURR_CUR_COL]=1;
	WCB[WCB_W_OLD_CUR_ROW]=.TOP_LINE;
	WCB[WCB_W_OLD_CUR_COL]=1;

	END;

RETURN SS$_NORMAL

END;		! Routine SMG$$FORCE_SCROLL_REG

%SBTTL 'SMG$$PBCB_EXIT_HANDLER - Exit handler'
GLOBAL ROUTINE SMG$$PBCB_EXIT_HANDLER ( P_REASON, P_PBCB ) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine gets called on image exit once for
!	each active pasteboard.  It flushes the output
!	on that device.  No flush occurs, however, if
!	the CLI forced the exit, as in the user typed
!	CTRL/Y then EXIT.
!
!	If device is a terminal, reset the physcial scrolling region to
!	full screen. If the user doesn't request the screen to be cleared,
!	then leave the cursor alone (unless the width needs to be reset).
!
! CALLING SEQUENCE:
!
!       ret_status.wlc.v = SMG$$PBCB_EXIT_HANDLER ( P_REASON.rl.r,
!						    P_PBCB.rab.r )
!
! FORMAL PARAMETERS:
!
!	P_REASON	Address of word that contains exit reason.
!			Should be PBCB[PBCB_L_EXIT_REASON].
!
!	P_PBCB.rab.r	The pasteboard control block address for which 
!			the flushing action is to take place.
!
! IMPLICIT INPUTS:
!
!	contents of PBCB
!
! IMPLICIT OUTPUTS:
!
!       PBCB[PBCB_W_OUTPUT_BUFLEN]	set to 0 (indicating buffer empty)
!
! COMPLETION STATUS:
!
!       SS$_NORMAL      Normal successful completion
!
! SIDE EFFECTS:
!
!       NONE
!--

BEGIN

BIND

	PBCB	= .P_PBCB	: $PBCB_DECL;

LOCAL
	STATUS,
	WCB : REF $WCB_DECL;	! Address of window control block

EXTERNAL ROUTINE

	SMG$CHANGE_PBD_CHARACTERISTICS;

WCB = .PBCB [PBCB_A_WCB];

!+
! If a scrolling region is set (other than the full screen),
! then reset it now, being careful to leave the cursor alone
! even though SET SCROLLING REGION may move it.
! Note that if we never established any scrolling regions,
! the TOP_SCROLL line will be 0.
!-

IF    .PBCB[PBCB_W_TOP_SCROLL_LINE] NEQ 0
AND  (.PBCB[PBCB_W_TOP_SCROLL_LINE] NEQ 1   OR
      .PBCB[PBCB_W_BOT_SCROLL_LINE] NEQ .WCB[WCB_W_NO_ROWS])
THEN
    BEGIN	! Remove scrolling regions

    LOCAL

	FINAL_ROW,	! Final cursor row
	FINAL_COL;	! Final cursor column

    !+
    ! Construct escape sequence (possibly null if not a supporting terminal)
    ! to set the hardware scroll region to the full height of the screen.
    !-

    $SMG$GET_TERM_DATA(SET_SCROLL_REGION,
			1,
			.WCB [WCB_W_NO_ROWS]);

    !+
    ! Output BUFFER.
    !-

    IF .PBCB[PBCB_L_CAP_LENGTH] NEQ 0
    THEN
	BEGIN	! Issue the reset

	!+
	! Remember where the user left the physical cursor, since
	! changing scrolling regions might upset this.
	!-

	FINAL_ROW=.WCB[WCB_W_CURR_CUR_ROW];
	FINAL_COL=.WCB[WCB_W_CURR_CUR_COL];

	STATUS = SMG$$OUTPUT(PBCB,.PBCB[PBCB_L_CAP_LENGTH],
				  .PBCB[PBCB_A_CAP_BUFFER]);
	IF NOT .STATUS THEN RETURN .STATUS;

	!+
	! Move the cursor back to where it was.
	! (No need to do this if the screen will be cleared anyhow.)
	!-

	IF NOT .PBCB[PBCB_V_CLEAR_SCREEN]
	  THEN	BEGIN	! Restore final cursor position

		$SMG$GET_TERM_DATA(SET_CURSOR_ABS,.FINAL_ROW,.FINAL_COL);

		STATUS = SMG$$OUTPUT(PBCB,.PBCB[PBCB_L_CAP_LENGTH],
					  .PBCB[PBCB_A_CAP_BUFFER]);
		IF NOT .STATUS THEN RETURN .STATUS

		END	! Restore final cursor position

	END	! Issue the reset

    END;	! Remove scrolling regions

!+
! Flush the buffer associated with this pasteboard if the exit
! was successful.
! This prevents us from flushing the buffer on things like
! CTRL/Y (SS$_CLIFRCEXT).
! Ignore any errors.
!-

IF .PBCB[PBCB_L_EXIT_REASON]
  THEN	BEGIN
	!+
	! If output is being controlled by RMS, then
	! do a final (or only) snapshot.
	! Otherwise, merely flush the buffer.
	IF .PBCB[PBCB_V_RMS]
	  THEN	SMG$SNAPSHOT(PBCB[PBCB_L_PBID])
	  ELSE	SMG$$FLUSH_BUFFER(PBCB);
	END;

!+
! Change the terminal width back to what it used to be.
!-

IF .PBCB[PBCB_W_WIDTH] NEQ .PBCB[PBCB_W_ORIG_WIDTH]
  THEN	BEGIN	! Change physical width

	LOCAL

		DESIRED_WIDTH,
		NORMAL_WIDTH,
		WIDE_WIDTH,
		WIDTH_SEQUENCE;

	DESIRED_WIDTH=.PBCB[PBCB_W_ORIG_WIDTH];

	!+
	! First, clear the screen.
	!-

	$SMG$GET_TERM_DATA(HOME);
	STATUS=OUTPUT(.PBCB,.PBCB[PBCB_L_CAP_LENGTH],.PBCB[PBCB_A_CAP_BUFFER]);
	IF NOT .STATUS THEN RETURN .STATUS;

	$SMG$GET_TERM_DATA(ERASE_WHOLE_DISPLAY);
	IF .PBCB[PBCB_L_CAP_LENGTH] NEQ 0
	  THEN	BEGIN
		STATUS = SMG$$OUTPUT(PBCB,.PBCB[PBCB_L_CAP_LENGTH],
					  .PBCB[PBCB_A_CAP_BUFFER]);
		IF NOT .STATUS THEN RETURN .STATUS
		END;

	!+
	! Second, get the normal size.
	!-

	$SMG$GET_TERM_DATA(COLUMNS);
	IF .PBCB[PBCB_L_CAP_LENGTH] NEQ 0
	  THEN	BEGIN
		BIND RESULT=.PBCB[PBCB_A_CAP_BUFFER];
		STATUS = SMG$$OUTPUT(PBCB,.PBCB[PBCB_L_CAP_LENGTH],
					  .PBCB[PBCB_A_CAP_BUFFER]);
		IF NOT .STATUS THEN RETURN .STATUS;
		NORMAL_WIDTH=.RESULT
		END
	  ELSE	NORMAL_WIDTH=80;

	!+
	! Third, get the wide size.
	!-

	$SMG$GET_TERM_DATA(WIDTH_WIDE);
	IF .PBCB[PBCB_L_CAP_LENGTH] NEQ 0
	  THEN	BEGIN
		BIND RESULT=.PBCB[PBCB_A_CAP_BUFFER];
		STATUS = SMG$$OUTPUT(PBCB,.PBCB[PBCB_L_CAP_LENGTH],
					  .PBCB[PBCB_A_CAP_BUFFER]);
		IF NOT .STATUS THEN RETURN .STATUS;
		WIDE_WIDTH=.RESULT
		END
	  ELSE	WIDE_WIDTH=80;

	!+
	! Decide which sequence to send.
	!-

	IF .DESIRED_WIDTH GTR .NORMAL_WIDTH
	  THEN	$SMG$GET_TERM_DATA(WIDTH_NARROW)
	  ELSE	$SMG$GET_TERM_DATA(WIDTH_WIDE);
	IF .PBCB[PBCB_L_CAP_LENGTH] NEQ 0
	  THEN	BEGIN
		STATUS = SMG$$OUTPUT(PBCB,.PBCB[PBCB_L_CAP_LENGTH],
					  .PBCB[PBCB_A_CAP_BUFFER]);
		IF NOT .STATUS THEN RETURN .STATUS;
		END;

	END;	! Change physical width

!+
! Clear the screen if the user asked us to.
!-

IF .PBCB[PBCB_V_CLEAR_SCREEN]
  THEN	SMG$$ERASE_PASTEBOARD(PBCB);

SMG$$FLUSH_BUFFER(PBCB);

! ***	I don't know whether or not an exit routine is supposed
!	to return a value; so I'm returning SS$_NORMAL for now.

RETURN	SS$_NORMAL

END;			! Routine SMG$$PBCB_EXIT_HANDLER

%SBTTL 'SMG$$SETUP_TERMINAL_TYPE - Setup terminal type for SMG$$ routines'
GLOBAL ROUTINE SMG$$SETUP_TERMINAL_TYPE ( 
		FILE_NAME,
		NAME_LEN,
		P_TERM_TYPE,
		PBCB_ADR
		) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine uses the specified file name to determine device
!	characteristics and assign a terminal type code which is understood
!	by other SMG$$ routines.  SMG$$ routines use the terminal type to
!	determine the correct escape sequence for a given function (ex. set
!	cursor).
!
! CALLING SEQUENCE:
!
!	ret_status.wlc.v = SMG$$SETUP_TERM_TYPE (FILE_NAME.rt.r,
!						 NAME_LEN.rl.v,
!						 P_TERM_TYPE.wl.r
!						 [,PBCB_ADR.wl.r])
!
! FORMAL PARAMETERS:
!
!	FILE_NAME.rt.r		addr of file name text
!	NAME_LEN.rl.v		length of file name text
!	P_TERM_TYPE.wl.r	terminal type code, one of the following:
!				    unknown
!				    vt05	(unused)
!				    vt52	(unused)
!				    vt100	(unused)
!				    vtforeign 
!				    hardcopy
!
!	PBCB_ADR.wl.r		Address of longword to receive address
!				of the pasteboard control block.
!				If 0 or omitted, no PBCB gets allocated.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	PBCB fields get filled in.
!
! COMPLETION STATUS:
!
!
! SIDE EFFECTS:
!
!	NONE
!--

    BEGIN

    BIND

	TERM_TYPE	= .P_TERM_TYPE;		! Address to get terminal type

    BUILTIN

	NULLPARAMETER;

    LOCAL

	SMGFAB		: $FAB_DECL,
	SMGNAM		: $NAM_DECL,
	DEVNAM_DSC : BLOCK [8, BYTE],		! dsc for name
	DVI_ITMLST : VECTOR [6*3 + 1] INITIAL	! item list for $GETDVI
		(DVI$_DEVTYPE    ^ 16 + 4, 0, 0,!  device type  (DT$_xyz)
		 DVI$_DEVDEPEND  ^ 16 + 4, 0, 0,!  device dependent bits (1)
		 DVI$_DEVDEPEND2 ^ 16 + 4, 0, 0,!  device dependent bits (2)
		 DVI$_DEVBUFSIZ  ^ 16 + 4, 0, 0,!  terminal width
		 DVI$_DEVCLASS   ^ 16 + 4, 0, 0,!  device class (DC$_xyz)
		 DVI$_DEVNAM     ^ 16 +64, 0, 0,!  result name string
		 0),				!  terminater

	DVI_EFN,				! event flag for $GETDVI,
	DVI_IOSB	: VECTOR [4, WORD],	! I/O Status block for $GETDVI
	STATUS,					! status retd by called routines
	DEV_TYPE	: VOLATILE,		! storage for $GETDVI value
	DEV_DEPEND	: VOLATILE BLOCK [4, BYTE],	! device dependent bits (1)
	DEV_DEPEND2	: VOLATILE BLOCK [4, BYTE],	! device dependent bits (2)
	DEV_BUFSIZ	: VOLATILE,		! storage for $GETDVI value
	DEV_CLASS	: VOLATILE,		! storage fpr $GETDVI value

	DEV_PAGSIZ,				! gets the number of rows of device

	DEV_DEVNAM : VECTOR [64, BYTE],		! Buffer for result name
						! string

	DEV_NAMLEN : VOLATILE WORD,		! Length of returned
						! resultant name string
	TERMTABLE;				! Address of terminal table

    BIND
	DVI_TYPE    = DVI_ITMLST + 4,		! make it easy to reference
	DVI_DEPEND  = DVI_ITMLST + 16,		!
	DVI_DEPEND2 = DVI_ITMLST + 28,		!  items retd by $GETDVI
	DVI_BUFSIZ  = DVI_ITMLST + 40,		!
	DVI_CLASS   = DVI_ITMLST + 52,		!
	DVI_DEVNAM  = DVI_ITMLST + 64,		!
	DVI_NAMLEN  = DVI_ITMLST + 68;		!

    BIND

	FABDEV		= SMGFAB[FAB$L_DEV]	: BLOCK[,BYTE], ! Device characteristcs
	DVI_NAME_LEN	= SMGNAM[NAM$T_DVI]	: BYTE,
	DVI_NAME	= SMGNAM[NAM$T_DVI]+1	: VECTOR[,BYTE];

    OWN

	GENERIC_ANSI_CRT_BUF	: VECTOR[16,BYTE]

		INITIAL(BYTE('GENERIC_ANSI_CRT')),

	GENERIC_DEC_CRT_BUF	: VECTOR[15,BYTE]

		INITIAL(BYTE('GENERIC_DEC_CRT')),

	GENERIC_ANSI_CRT_DESC	: VECTOR[2],
	GENERIC_DEC_CRT_DESC	: VECTOR[2];

    EXTERNAL ROUTINE

	SMG$INIT_TERM_TABLE_BY_TYPE,		! Initialize terminal table by type
	SMG$INIT_TERM_TABLE,			! Initialize terminal table by name
	SMG$$CREATE_PASTEBOARD,			! Create a PBCB.
	LIB$LP_LINES;				! Get number of rows for lpt

    !+
    ! Use RMS to parse the device name.
    ! This will give us a 1-15 character physical device name
    ! in the DVI field in the NAM block.
    ! (If we just use $GETDVI, it may return a 63-character hidden
    ! device name.)
    ! The main reason we call $PARSE is so that we can allow filenames.
    ! If the user specifies "TTB5:" as his device, he gets a terminal.
    ! If the user specifies "TTB5" as his output, he gets the file
    ! TTB5.LIS on his default disk and directory.
    !-

    !+
    ! Initialize the FAB and NAM blocks.
    !-

    $FAB_INIT(	FAB	= SMGFAB,
		DNM	= 'SMGOUTPUT.LIS',
		NAM	= SMGNAM,
		FNA	= .FILE_NAME,
		FNS	= .NAME_LEN);

    $NAM_INIT(NAM=SMGNAM);

    STATUS=$PARSE(FAB=SMGFAB);
    IF NOT .STATUS THEN RETURN .STATUS;

    !+
    ! The device name is now a counted string in the NAM block
    ! beginning at offset NAM$T_DVI.
    ! There is an obscure case though that can occur.  If the output device
    ! is on another node, then RMS cannot figure out the device name
    ! so the DVI field is empty.  This can happen if an SMG job is
    ! run as a TASK with SYS$OUTPUT defined to be SYS$NET.
    ! This happens when you use the "TASK=FOO" kind of filespecification
    ! to RMS.
    ! To allow this to work, we check to see if the device characteristic
    ! of the pasteboard device is DEV$M_NET.  If so, we bypass the call
    ! to $GETDVI, and we fill in the fields the best we can.
    !-

    IF .FABDEV[DEV$V_NET]
    THEN
	BEGIN		! Network device

	!+
	! Fudge the items to reasonable values.
	!-

	DEV_TYPE	= DT$_MBX;
	DEV_DEPEND	= 0;
	DEV_DEPEND2	= 0;
	DEV_CLASS	= DC$_MAILBOX;
	DEV_BUFSIZ	= 80;
	DEV_DEVNAM	= .FILE_NAME;
	DEV_NAMLEN	= .NAME_LEN;
	END		! Network device
    ELSE
	BEGIN		! Normal device

	DVI_TYPE    = DEV_TYPE;			! fill in rest of itmlst
	DVI_DEPEND  = DEV_DEPEND;
	DVI_DEPEND2 = DEV_DEPEND2;
	DVI_CLASS   = DEV_CLASS;
	DVI_BUFSIZ  = DEV_BUFSIZ;			
	DVI_DEVNAM  = DEV_DEVNAM;
	DVI_NAMLEN  = DEV_NAMLEN;

	IF NOT (STATUS = LIB$GET_EF (DVI_EFN))
	THEN RETURN (.STATUS);		! get unique event flag number

	!+
	! Create a descriptor for use by $GETDVI.
	!-

	DEVNAM_DSC [DSC$B_DTYPE]   =  DSC$K_DTYPE_T;
	DEVNAM_DSC [DSC$B_CLASS]   =  DSC$K_CLASS_S;
	DEVNAM_DSC [DSC$W_LENGTH]  = .DVI_NAME_LEN;
	DEVNAM_DSC [DSC$A_POINTER] =  DVI_NAME;

	STATUS = $GETDVI(	EFN	= .DVI_EFN,
				IOSB	=  DVI_IOSB,
				DEVNAM	=  DEVNAM_DSC,
				ITMLST	=  DVI_ITMLST);
	IF NOT .STATUS THEN RETURN (.STATUS);

	! *** Possible bug: Should we deallocate the event flag if the
	!	  $getdvi fails?  Otherwise, enough calls to this routine
	!	  that return errors will use up all the event flags.

	STATUS=$WAITFR (EFN = .DVI_EFN);		! make $GETDVI synchronous
	IF NOT .STATUS THEN RETURN (.STATUS);

	!+
	! When the operation completes, the final status
	! is left in the first word of the I/O status block.
	!-

	IF NOT .DVI_IOSB [0] THEN RETURN (.DVI_IOSB [0]);

	END;	! Normal device

    !+
    ! Calculate the number of rows and columns for our pasteboard.
    ! If the device is a terminal, then the number of rows
    ! is the high byte in DEVDEPEND.
    ! If the device is not a terminal, then the number of rows
    ! is hereby declared to be that returned by LIB$LP_LINES.
    ! (We don't let this get bigger than 511 however, since we
    ! store the result in a byte.)
    ! The number of columns is the device buffer size, whether or not
    ! the device is a terminal.
    ! If the device is not aterminal, then we assume it will eventually
    ! be printed on a terminal or a lineprinter, so we minimize
    ! the width with 132.  We might wish to reconsider this idea
    ! in the future if we ever start producing wider terminals.
    !-

    IF .DEV_CLASS EQL DC$_TERM
    THEN
	DEV_PAGSIZ = .DEV_DEPEND[TT$V_PAGE]
    ELSE
	BEGIN
	DEV_PAGSIZ = MIN(LIB$LP_LINES(),511);
	DEV_BUFSIZ = MIN(.DEV_BUFSIZ,132)
	END;

    !+
    ! Allocate a pasteboard control block (PBCB).
    !-

    IF NOT NULLPARAMETER(PBCB_ADR)
    THEN
	BEGIN
	STATUS = SMG$$CREATE_PASTEBOARD ( DEV_PAGSIZ, DEV_BUFSIZ, .PBCB_ADR );
	IF NOT .STATUS THEN RETURN (.STATUS);
	END;

    !+
    ! If the device is a terminal, we get information about it from
    ! TERMTABLE.EXE.  We set TERM_TYPE to VTTERMTABLE.
    !-

    TERMTABLE=0;

    IF .DEV_CLASS EQL DC$_TERM
    THEN
	BEGIN	! Get info from TERMTABLE
	IF .DEV_TYPE EQL TT$_UNKNOWN
	  THEN	BEGIN	! TERMTABLE never heard of it
		LOCAL GENERIC_NAME;
		!+
		! Initialize our descriptors.
		! We couldn't do this with an INITIAL clause
		! because that would generate a .ADDRESS directive
		! which would require fixup vectors
		! which would make the PSECT read/write
		! which would prevent sharing in our shared image.
		!-

		GENERIC_ANSI_CRT_DESC[0]=%ALLOCATION(GENERIC_ANSI_CRT_BUF);
		GENERIC_ANSI_CRT_DESC[1]=GENERIC_ANSI_CRT_BUF;
		GENERIC_DEC_CRT_DESC[0]=%ALLOCATION(GENERIC_DEC_CRT_BUF);
		GENERIC_DEC_CRT_DESC[1]=GENERIC_DEC_CRT_BUF;

		!+
		! Well, if it's either an ANSI_CRT or a DEC_CRT,
		! we can handle it. DEC_CRT has priority over ANSI.
		!-
		GENERIC_NAME=0;
		IF .DEV_DEPEND2[TT2$V_ANSICRT]
		  THEN	GENERIC_NAME=GENERIC_ANSI_CRT_DESC;
		IF .DEV_DEPEND2[TT2$V_DECCRT]
		  THEN	GENERIC_NAME=GENERIC_DEC_CRT_DESC;
		IF .GENERIC_NAME EQL 0
		  THEN	TERM_TYPE=UNKNOWN
		  ELSE	BEGIN	! Use a generic terminal
			STATUS=SMG$INIT_TERM_TABLE(.GENERIC_NAME,TERMTABLE);
			IF NOT .STATUS THEN RETURN .STATUS;
			TERM_TYPE=VTTERMTABLE
			END;	! Use a generic terminal
		END	! TERMTABLE never heard of it
	  ELSE	BEGIN	! Standard TERMTABLE terminal
		STATUS=SMG$INIT_TERM_TABLE_BY_TYPE(DEV_TYPE,TERMTABLE);
		IF NOT .STATUS THEN RETURN .STATUS;
		TERM_TYPE=VTTERMTABLE
		END	! Standard TERMTABLE terminal
	END	! Get info from TERMTABLE
    ELSE
	TERM_TYPE=UNKNOWN;

    !+
    ! Store items in the PBCB if one was created.
    !-

    IF NOT NULLPARAMETER(4)
    THEN
	BEGIN	! storing into PBCB

	BIND	PBCB = ..PBCB_ADR : $PBCB_DECL ;

	!+
	! We will need an event flag for many future operations on this
	! pasteboard, so we store away the event flag in the PBCB.
	!-

	PBCB [PBCB_B_EFN] = .DVI_EFN;

	PBCB [PBCB_B_DEVTYPE]	= .TERM_TYPE;	! Internal type

	!+
	! Fill in the 12-byte device characteristics block in the PBCB.
	! Note that the DEVDEPEND field will not be valid if the device
	! is not a terminal because we replace the top byte of this
	! longword with the device page size (as it would be for a terminal).
	!-

	PBCB [PBCB_B_PHY_DEV_TYPE]= .DEV_TYPE;	! Physical type.
	PBCB [PBCB_B_CLASS]	= .DEV_CLASS;	! Device class
	PBCB [PBCB_W_WIDTH]	= .DEV_BUFSIZ;	! Number of columns.
	PBCB [PBCB_W_ORIG_WIDTH]= .DEV_BUFSIZ;	! Number of columns (original value)
	PBCB [PBCB_L_DEVDEPEND]	= .DEV_DEPEND;	! Implicitly sets overlapped
						! field PBCB_B_ROWS also.
	PBCB [PBCB_B_ROWS]	= .DEV_PAGSIZ;	! Reset it again.
	PBCB [PBCB_L_DEVDEPEND2]= .DEV_DEPEND2;	! Secondary characteristics.
	PBCB [PBCB_L_TERMTABLE] = .TERMTABLE;	! Terminal table
	PBCB [PBCB_L_LONGEST_SEQUENCE]=SMG$K_LONGEST_SEQUENCE;

	!+
	! Allocate a buffer to hold the longest possible sequence
	! that can be returned to us.
	!-

	STATUS=LIB$GET_VM(PBCB[PBCB_L_LONGEST_SEQUENCE],
			  PBCB[PBCB_A_CAP_BUFFER]);
	IF NOT .STATUS THEN RETURN .STATUS;

	!+
	! Create the border vector.
	!-

	ESTABLISH_BORDER_VECTOR(PBCB);

	!+
	!	If terminal does not support direct cursor positioning,
	!	then treat it as a hardcopy device.
	!	Otherwise, treat it as a TERMTABLE scope terminal.
	!-

	IF .TERM_TYPE EQL VTTERMTABLE
	  THEN	BEGIN
		$SMG$GET_TERM_DATA(SET_CURSOR_ABS, 1, 1);
		IF .PBCB[PBCB_L_CAP_LENGTH] EQL 0
		  THEN	BEGIN
			TERM_TYPE=HARDCOPY;
			PBCB [PBCB_B_DEVTYPE]	= .TERM_TYPE;	! Internal type
			END;
		$SMG$GET_TERM_DATA(SCOPE);
		IF .PBCB[PBCB_L_CAP_LENGTH] EQL 0
		  THEN	BEGIN
			TERM_TYPE=HARDCOPY;
			PBCB [PBCB_B_DEVTYPE]	= .TERM_TYPE;	! Internal type
			END
		  ELSE	BEGIN
			BIND BOOL = .PBCB[PBCB_A_CAP_BUFFER];
			IF NOT .BOOL
			  THEN	BEGIN
				TERM_TYPE=HARDCOPY;
				PBCB [PBCB_B_DEVTYPE]	= .TERM_TYPE;	! Internal type
				END;
			END;
		END;

	!+
	! Find out if this terminal supports high and/or wide lines,
	! and if it has physical tabs and backspaces.
	!-

	IF .TERMTABLE NEQ 0
	  THEN	BEGIN	! Get info from TERMTABLE

		$SMG$GET_TERM_DATA(DOUBLE_WIDE);
		IF .PBCB[PBCB_L_CAP_LENGTH] NEQ 0
		  THEN	PBCB[PBCB_V_WIDE] = 1;	! It handles wide lines

		$SMG$GET_TERM_DATA(DOUBLE_HIGH_TOP);
		IF .PBCB[PBCB_L_CAP_LENGTH] NEQ 0
		  THEN	PBCB[PBCB_V_HIGH] = 1;	! It handles double high lines

		IF .DEV_DEPEND[TT$V_MECHTAB]
		  THEN	BEGIN
			PBCB[PBCB_V_TABS] = 1;		! It handles physical tabs
							! We check the NOTABS bit
							! elsewhere, because the user
							! can dynamically change that
							! at runtime.
			END;

		$SMG$GET_TERM_DATA(BACKSPACE);
		IF .PBCB[PBCB_L_CAP_LENGTH] NEQ 0
		  THEN	BEGIN
			BIND ANSWER = .PBCB[PBCB_A_CAP_BUFFER];
			IF .ANSWER
			  THEN	PBCB[PBCB_V_BS] = 1;	! It handles backspace
			END;

		END;	! Get info from TERMTABLE

	!+
	! Fill in the device name.
	!-

	PBCB [PBCB_W_DEVNAM_LEN]= .DEV_NAMLEN;	! Length of device name
	CH$MOVE ( .DEV_NAMLEN, DEV_DEVNAM, PBCB[PBCB_T_DEVNAM]);

	!+
	! Initially, we don't know what color the background is.
	!-

	PBCB [PBCB_B_BACKGROUND_COLOR] = SMG$C_COLOR_UNKNOWN;

	!+
	! Output any initialization sequence now.
	!-

	$SMG$GET_TERM_DATA(INIT_STRING);

	IF .PBCB[PBCB_L_CAP_LENGTH] NEQ 0
	  THEN	BEGIN
		STATUS=SMG$$OUTPUT(PBCB,.PBCB[PBCB_L_CAP_LENGTH],
					.PBCB[PBCB_A_CAP_BUFFER]);
		IF NOT .STATUS THEN RETURN .STATUS
		END;

	END;	! storing into PBCB

    RETURN .STATUS

    END;				! End of routine SMG$$SETUP_TERMINAL_TYPE

%SBTTL 'ESTABLISH_BORDER_VECTOR'
ROUTINE ESTABLISH_BORDER_VECTOR( P_PBCB) : NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Creates a 16-longword vector used for translating border characters.
!	If the longword has a value less than 256, then it is a border
!	character.  If it is greater than 256, then it is the addresss of
!	a border character sequence.
!
! CALLING SEQUENCE:
!
!       ret_status.wlc.v = ESTABLISH_BORDER_VECTOR(P_PBCB)
!
! FORMAL PARAMETERS:
!
!	P_PBCB.rab.r		Address of PBCB
!
! IMPLICIT INPUTS:
!
!	contents of PBCB
!
! IMPLICIT OUTPUTS:
!
!	R_BORDER_VECTOR field in PBCB gets set up
!	V_COMPLEX_BORDER is set to 1 if some border element
!			 is longer than a byte
!
! COMPLETION STATUS:
!
!	NONE
!
! SIDE EFFECTS:
!
!       NONE
!--

BEGIN

BIND	PBCB	= .P_PBCB	: $PBCB_DECL;

LOCAL	STATUS;

!+
! Macro to set code longword in border_vector if
! corresponding capability is defined.
! We use the default character if the capability doesn't exisit
! or if it does exist but the terminal is a non-AVO ANSI CRT.
!-

MACRO

    $VECTOR_SET(CODE,CAP,DEFAULT) =

	BEGIN

	BIND TT2 = PBCB[PBCB_L_DEVDEPEND2]	: $BBLOCK;

	BIND VECT =  PBCB[PBCB_R_BORDER_VECTOR]	: VECTOR[16];

	$SMG$GET_TERM_DATA(CAP);

	IF .PBCB[PBCB_L_CAP_LENGTH] EQL 0
	OR (.TT2[TT2$V_ANSICRT] AND NOT .TT2[TT2$V_AVO])
	  THEN	BEGIN	! Use default character
		VECT[CODE]=DEFAULT
		END	! Use default character
	  ELSE	BEGIN	! Use specified string
		IF .PBCB[PBCB_L_CAP_LENGTH] GTR 1
		  THEN	BEGIN	! It's a long string

			LOCAL	SIZE;

			!+
			! Build a byte-counted string for this string.
			!-

			SIZE=.PBCB[PBCB_L_CAP_LENGTH]+1;

			!+
			! Allocate virtual memory for the capability.
			! Store it as a counted string.
			!-

			STATUS=LIB$GET_VM(SIZE,VECT[CODE]);
			IF NOT .STATUS THEN RETURN .STATUS;

			!+
			! Copy the capability in.
			!-

			CH$MOVE(.PBCB[PBCB_L_CAP_LENGTH],
				.PBCB[PBCB_A_CAP_BUFFER],
				.VECT[CODE]+1);

			!+
			! Set the byte count.
			!-

				BEGIN
				BIND COUNT = .VECT[CODE] : BYTE;
				COUNT=.PBCB[PBCB_L_CAP_LENGTH]
				END;

			PBCB[PBCB_V_COMPLEX_BORDER]=1

			END	! It's a long string
		  ELSE	BEGIN	! It's a single character
			BIND CHAR = .PBCB[PBCB_A_CAP_BUFFER] : BYTE;
			VECT[CODE]=.CHAR
			END	! It's a single character
		END;	! Use specified string

	END

    %;

!+
! The border vector is a 16-longword vector.
! The nth longword represents the character used to represent
! the nth border element.  It is the character itself (if <256,
! or the address of a (byte) counted string for the capability.
! These elements are described below:
!
! code	description		default
!
! 0	unused			space
! 1	right			-
! 2	up			|
! 3	lower left corner	+
! 4	left			-
! 5	horizontal		-
! 6	lower right corner	+
! 7	tup			+
! 8	down			|
! 9	upper left corner	+
! 10	vertical		|
! 11	tright			+
! 12	upper right corner	+
! 13	tdown			+
! 14	tleft			+
! 15	cross			+
!-

!+
! Note: "tright" means a T with the stem pointing to the right.
!	(This is called a left T on the VT100 manual.)
!-

!+
! Note how the codes "or" together.
!-

BIND

	HARD_SEQUENCE	= UPLIT BYTE(' -|+--++|+|+++++') : VECTOR[16,BYTE];

!+
! Now replace each element, one at a time, with the appropriate special
! character, if one was specified in the TERMTABLE file.
! Otherwise, store in the default character.
!-

$VECTOR_SET( 1,HORIZONTAL_BAR,%C'-');
$VECTOR_SET( 2,VERTICAL_BAR,%C'|');
$VECTOR_SET( 3,LOWER_LEFT_CORNER,%C'+');
$VECTOR_SET( 4,HORIZONTAL_BAR,%C'-');
$VECTOR_SET( 5,HORIZONTAL_BAR,%C'-');
$VECTOR_SET( 6,LOWER_RIGHT_CORNER,%C'+');
$VECTOR_SET( 7,BOTTOM_T_CHAR,%C'+');
$VECTOR_SET( 8,VERTICAL_BAR,%C'|');
$VECTOR_SET( 9,UPPER_LEFT_CORNER,%C'+');
$VECTOR_SET(10,VERTICAL_BAR,%C'|');
$VECTOR_SET(11,LEFT_T_CHAR,%C'+');
$VECTOR_SET(12,UPPER_RIGHT_CORNER,%C'+');
$VECTOR_SET(13,TOP_T_CHAR,%C'+');
$VECTOR_SET(14,RIGHT_T_CHAR,%C'+');
$VECTOR_SET(15,CROSS_CHAR,%C'+');

END;

%SBTTL 'SMG$PUT_PASTEBOARD - Output pasteboard via routine'
GLOBAL ROUTINE SMG$PUT_PASTEBOARD ( PASTEBOARD_ID, P_RTN, P_PRM, P_FF_FLAG ) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is used to get access to the contents of a pasteboard.
!	The caller specifies an action routine.  The action routine
!	will then get called once for each line in the pasteboard.
!	The action routine will be passed a descriptor for that line
!	followed by a user-specified parameter.
!
! CALLING SEQUENCE:
!
!       ret_status.wlc.v = SMG$PUT_PASTEBOARD ( PASTEBOARD_ID.rl.r
!						 ,P_RTN
!						[,P_PRM.rl.r]
!						[,P_FF_FLAG.rl.r])
!	ACTION ROUTINE:
!
!	ret_status.wlc.v = RTN(LINE.rt.dx,PRM.rl.v)
!
!		A false status return means stop sending lines.
!
! FORMAL PARAMETERS:
!
!	PASTEBOARD_ID.rl.r	pasteboard id
!
!	P_RTN.rzem.r		Address of routine to be called.
!
!	P_PRM.rl.r		User-specified parameter to be passed
!				along to the action routine
!				If omitted, a 0 will be passed as
!				the user parameter.
!
!	P_FF_FLAG.rl.r		A flag (0 or 1).  If 1, then the first
!				line passed to the action routine
!				will be prepended with a formfeed.
!				(If the output device is a terminal
!				and if the terminal does not have
!				the MECHFORM characteristic, then
!				a linefeed will be used instead.)
!				If not specified, then no form feed
!				will be prepended.
!
! IMPLICIT INPUTS:
!
!	contents of PBCB
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!       SS$_NORMAL      Normal successful completion
!
!	other		Error return passed back by an action routine
!
! SIDE EFFECTS:
!
!       NONE
!--

BEGIN

BIND

	PRM	= .P_PRM,
	FF_FLAG	= .P_FF_FLAG;

LOCAL

	TEMP_BUF	: VECTOR[512,BYTE],	! *** TEMP
	STATUS,
	BUF_DESC	: BLOCK[8,BYTE],	! Descriptor for buffer to be
						! passed to the user
	ACTION_PRM,				! Value of action parameter
	ACTION_FF_FLAG,
	PBCB		: REF $PBCB_DECL,
	WCB		: REF $WCB_DECL;

BUILTIN

	NULLPARAMETER;

OWN

	BORDER_TRANS	: VECTOR[16,BYTE]
			  INITIAL (BYTE(' -|+--++|+|+++++'));

$SMG$VALIDATE_ARGCOUNT(2,4);

!+
! Get the pasteboard control block from the pasteboard id.
!-

$SMG$GET_PBCB(.PASTEBOARD_ID,PBCB);

!+
! Get the value of the action routine parameter.
!-

IF NULLPARAMETER(3)
  THEN	ACTION_PRM=0
  ELSE	ACTION_PRM=.PRM;

!+
! Get the value of the formfeed flag.
!-

IF NULLPARAMETER(4)
  THEN	ACTION_FF_FLAG=0
  ELSE	ACTION_FF_FLAG=.FF_FLAG;

!+
! Set up the WCB reference.
!-

WCB=.PBCB[PBCB_A_WCB];

!+
! Temporary fix: ****
!-

IF .PBCB[PBCB_A_RBF] EQL 0
  THEN	PBCB[PBCB_A_RBF]=TEMP_BUF;

!+
! Set up the descriptor for our buffer.
!-

BUF_DESC[DSC$W_LENGTH] =.WCB[WCB_W_NO_COLS];
BUF_DESC[DSC$B_CLASS]  = DSC$K_CLASS_S;
BUF_DESC[DSC$B_DTYPE]  = DSC$K_DTYPE_T;
BUF_DESC[DSC$A_POINTER]= .PBCB[PBCB_A_RBF];

!+
! Call the action routine once for each line in the pasteboard.
!-

INCR ROW FROM 0 TO .PBCB[PBCB_B_ROWS]-1 DO
	BEGIN	! Output a row
	
	BIND

		WIDTH	= WCB[WCB_W_NO_COLS]		   : WORD,
		TEXT	= .WCB[WCB_A_TEXT_BUF]+.ROW*.WIDTH : VECTOR[,BYTE],
		ATTR	= .WCB[WCB_A_ATTR_BUF]+.ROW*.WIDTH : VECTOR[,BYTE],
		RBF	= .PBCB[PBCB_A_RBF]		   : VECTOR[,BYTE];

	BIND ROUTINE

		ACTION_ROUTINE = .P_RTN;

	!+
	! Copy the appropriate row into the record buffer.
	!-

	CH$MOVE(.WCB[WCB_W_NO_COLS],TEXT,RBF);

	!+
	! Scan the attribute buffer looking for any border elements.
	! If we find one, change its representation in the record buffer
	! to something more reasonable.
	!-

	INCR COL FROM 0 TO .WCB[WCB_W_NO_COLS]-1 DO
		BEGIN	! Scan record buffer
		BIND CHAR = RBF[.COL] : BYTE;
		LITERAL BORDER_MASK = ATTR_M_BORD_ELEM OR ATTR_M_USER_GRAPHIC;
		IF (.ATTR[.COL] AND BORDER_MASK) NEQ 0
		  THEN	BEGIN
			IF .CHAR GTRU 16
			  THEN	RBF[.COL]=%C'*'
			  ELSE	RBF[.COL]=.BORDER_TRANS[.CHAR<0,4>];
			END
		END;	! Scan record buffer

	STATUS=ACTION_ROUTINE(BUF_DESC,.ACTION_PRM);
	IF NOT .STATUS THEN RETURN .STATUS

	END;	! Output a row

RETURN	SS$_NORMAL

END;			! Routine SMG$PUT_PASTEBOARD

%SBTTL 'SMG$SNAPSHOT - Snapshot pasteboard into a file'
GLOBAL ROUTINE SMG$SNAPSHOT ( PASTEBOARD_ID ) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	If the output device is being controlled by RMS
!	(i.e. it is a file or unknown terminal)
!	then calling this routine causes a snapshot
!	of the current pasteboard to be taken and output
!	to the output file.
!	Pasteboard batching has no affect on this routine.
!
! CALLING SEQUENCE:
!
!       ret_status.wlc.v = SMG$SNAPSHOT ( PASTEBOARD_ID.rl.r)
!
! FORMAL PARAMETERS:
!
!	PASTEBOARD_ID.rl.r	pasteboard id
!
! IMPLICIT INPUTS:
!
!	contents of PBCB
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!       SS$_NORMAL      Normal successful completion
!	SMG$_NOTRMSOUT	(success) no action taken since output is
!			not being controlled by RMS
!	RMS$_xyz	Errors from RMS
!
! SIDE EFFECTS:
!
!       NONE
!--

BEGIN

EXTERNAL LITERAL

	SMG$_NOTRMSOUT;		! Not RMS output

LOCAL

	STATUS,
	PBCB		: REF $PBCB_DECL;

$SMG$VALIDATE_ARGCOUNT(1,1);

!+
! Get the pasteboard control block from the pasteboard id.
!-

$SMG$GET_PBCB(.PASTEBOARD_ID,PBCB);

!+
! Do nothing if output is not being controlled by RMS.
!-

IF NOT .PBCB[PBCB_V_RMS]
  THEN	RETURN	SMG$_NOTRMSOUT;

!+
! Output this pasteboard using our special RMS output routine.
!-

STATUS=SMG$PUT_PASTEBOARD(.PASTEBOARD_ID,RMS_RTN,PBCB);
IF NOT .STATUS THEN RETURN .STATUS;

RETURN	SS$_NORMAL

END;			! Routine SMG$SNAPSHOT

%SBTTL 'SMG$$SET_ATTRIBUTES_ON'
GLOBAL ROUTINE SMG$$SET_ATTRIBUTES_ON ( 
		    PBCB : REF $PBCB_DECL,
		    FLAGS : BITVECTOR
		) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine generates the escape sequences turning on
!	attributes such as bolding and blinking.
!
! CALLING SEQUENCE:
!
!	ret_status.wlc.v = SMG$$SET_ATTRIBUTES_ON (PBCB,
!						FLAGS.rl.v)
!
! FORMAL PARAMETERS:
!
!	PBCB
!	FLAGS.rl.v		flags specifying which attributes to turn on
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!
! SIDE EFFECTS:
!
!	NONE
!--

BEGIN

LOCAL

	STATUS;

BIND	TT2 = PBCB[PBCB_L_DEVDEPEND2]	: $BBLOCK;

!+
! Renditions requires that the AVO (ADVANCED_VIDEO) terminal
! characteristic bit be set.  Even if the TERMTABLE entries
! show that the terminal has the BEGIN_BOLD capability,
! the terminal might not have the advanced video option.
!-

IF .FLAGS[ATTR_V_REND_GRAPHIC]
AND (.TT2[TT2$V_AVO] OR NOT .TT2[TT2$V_ANSICRT])
  THEN	BEGIN
	$SMG$GET_TERM_DATA(BEGIN_LINE_DRAWING_CHAR);

	IF .PBCB[PBCB_L_CAP_LENGTH] NEQ 0
	  THEN	BEGIN
		STATUS=SMG$$OUTPUT(.PBCB,.PBCB[PBCB_L_CAP_LENGTH],
					 .PBCB[PBCB_A_CAP_BUFFER]);
		IF NOT .STATUS THEN RETURN .STATUS
		END;
	END;

!+
! Get and output the string to set the correct attributes.
!-

IF .FLAGS[ATTR_V_REND_BOLD]
AND (.TT2[TT2$V_AVO] OR NOT .TT2[TT2$V_ANSICRT])
  THEN	BEGIN
	$SMG$GET_TERM_DATA(BEGIN_BOLD);

	IF .PBCB[PBCB_L_CAP_LENGTH] NEQ 0
	  THEN	BEGIN
		STATUS=SMG$$OUTPUT(.PBCB,.PBCB[PBCB_L_CAP_LENGTH],
					 .PBCB[PBCB_A_CAP_BUFFER]);
		IF NOT .STATUS THEN RETURN .STATUS;
		END;
	END;

IF .FLAGS[ATTR_V_REND_BLINK]
AND (.TT2[TT2$V_AVO] OR NOT .TT2[TT2$V_ANSICRT])
  THEN	BEGIN
	$SMG$GET_TERM_DATA(BEGIN_BLINK);

	IF .PBCB[PBCB_L_CAP_LENGTH] NEQ 0
	  THEN	BEGIN
		STATUS=SMG$$OUTPUT(.PBCB,.PBCB[PBCB_L_CAP_LENGTH],
					 .PBCB[PBCB_A_CAP_BUFFER]);
		IF NOT .STATUS THEN RETURN .STATUS;
		END;
	END;

IF .FLAGS[ATTR_V_REND_REV]
AND (.TT2[TT2$V_AVO] OR NOT .TT2[TT2$V_ANSICRT])
  THEN	BEGIN
	$SMG$GET_TERM_DATA(BEGIN_REVERSE);

	IF .PBCB[PBCB_L_CAP_LENGTH] NEQ 0
	  THEN	BEGIN
		STATUS=SMG$$OUTPUT(.PBCB,.PBCB[PBCB_L_CAP_LENGTH],
					 .PBCB[PBCB_A_CAP_BUFFER]);
		IF NOT .STATUS THEN RETURN .STATUS;
		END;
	END;

IF .FLAGS[ATTR_V_REND_UNDER]
AND (.TT2[TT2$V_AVO] OR NOT .TT2[TT2$V_ANSICRT])
  THEN	BEGIN
	$SMG$GET_TERM_DATA(BEGIN_UNDERSCORE);

	IF .PBCB[PBCB_L_CAP_LENGTH] NEQ 0
	  THEN	BEGIN
		STATUS=SMG$$OUTPUT(.PBCB,.PBCB[PBCB_L_CAP_LENGTH],
					 .PBCB[PBCB_A_CAP_BUFFER]);
		IF NOT .STATUS THEN RETURN .STATUS;
		END;
	END;

RETURN	SS$_NORMAL
    
END;				! End of routine SMG$$SET_ATTRIBUTES_ON

%SBTTL 'SMG$$SET_ATTRIBUTES_OFF'
GLOBAL ROUTINE SMG$$SET_ATTRIBUTES_OFF ( 
		    PBCB : REF $PBCB_DECL,
		    FLAGS : BITVECTOR
		) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine generates the escape sequences turning on
!	attributes such as bolding and blinking.
!
! CALLING SEQUENCE:
!
!	ret_status.wlc.v = SMG$$SET_ATTRIBUTES_OFF (PBCB,
!						FLAGS.rl.v)
!
! FORMAL PARAMETERS:
!
!	PBCB
!	FLAGS.rl.v		flags specifying which attributes to turn on
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!
! SIDE EFFECTS:
!
!	NONE
!--

BEGIN

LOCAL

	STATUS;

BIND	TT2 = PBCB[PBCB_L_DEVDEPEND2]	: $BBLOCK;

!+
! Renditions requires that the AVO (ADVANCED_VIDEO) terminal
! characteristic bit be set.  Even if the TERMTABLE entries
! show that the terminal has the BEGIN_BOLD capability,
! the terminal might not have the advanced video option.
!-

!+
! Get and output the suffix string to reset attributes to normal.
! We used to assume that END_BOLD brings back normal attributes.
! Now we rely on BEGIN_NORMAL_RENDITION.
!-

IF .TT2[TT2$V_AVO] OR NOT .TT2[TT2$V_ANSICRT]
  THEN	BEGIN

	%IF %DECLARED( SMG$K_BEGIN_NORMAL_RENDITION )
	%THEN
		$SMG$GET_TERM_DATA(BEGIN_NORMAL_RENDITION);
	%ELSE
		$SMG$GET_TERM_DATA(END_BOLD);
	%FI

	IF .PBCB[PBCB_L_CAP_LENGTH] NEQ 0
	  THEN	BEGIN
		STATUS=SMG$$OUTPUT(.PBCB,.PBCB[PBCB_L_CAP_LENGTH],
					 .PBCB[PBCB_A_CAP_BUFFER]);
		IF NOT .STATUS THEN RETURN .STATUS;
		END;
	END;

RETURN	SS$_NORMAL
    
END;

%SBTTL 'RMS_RTN - Action routine used to output a line with RMS'
ROUTINE RMS_RTN ( P_LINE_DESC, P_PBCB ) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Outputs a line to the output file using RMS.
!
! CALLING SEQUENCE:
!
!       ret_status.wlc.v = RMS_RTN ( P_LINE_DESC.rt.ds, P_PBCB.rab.r)
!
! FORMAL PARAMETERS:
!
!	P_LINE_DESC.rt.ds	Address of fixed length string descriptor
!				for line to be output.
!
!	P_PBCB.rab.r		Address of pasteboard control block
!
! IMPLICIT INPUTS:
!
!	contents of PBCB
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!       RMS$_NORMAL     Normal successful completion
!	RMS$_xyz	Errors from RMS
!
! SIDE EFFECTS:
!
!       NONE
!--

BEGIN

BIND

	LINE_DESC	= .P_LINE_DESC		: BLOCK[8,BYTE],
	PBCB		= .P_PBCB		: $PBCB_DECL,
	SMGRAB		= .PBCB[PBCB_A_RAB]	: $RAB_DECL;

!+
! Output this line using RMS.
!-

SMGRAB[RAB$W_RSZ]	= .LINE_DESC[DSC$W_LENGTH];
SMGRAB[RAB$L_RBF]	= .LINE_DESC[DSC$A_POINTER];

RETURN $PUT(RAB=SMGRAB)

END;			! Routine RMS_RTN

%SBTTL 'SMG$$MIN_UPD - Calculate minimum update sequence and output'
GLOBAL ROUTINE SMG$$MIN_UPD (
				PBCB : REF $PBCB_DECL
			    ) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Obsolete.
!	SMG$$OUTPUT_PASTEBOARD should be called instead.
!	If this or that bombs out, you can use the old original temporary
!	routine that Rich wrote.  It's called SMG$$OLD_MIN_UPD.
!
! CALLING SEQUENCE:
!
!	ret_status.wlc.v = SMG$$MIN_UPD ( PBCB.rab.r )
!
! FORMAL PARAMETERS:
!
!	PBCB.rab.r		Address of pasteboard control block.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	SS$_NORMAL	Normal successful completion
!
! SIDE EFFECTS:
!
!	NONE
!--

BEGIN
LOCAL
    WCB : REF $WCB_DECL;	! Address of Window Control Block.

WCB = .PBCB [PBCB_A_WCB];
IF .PBCB [PBCB_W_LAST_CHANGED_ROW] NEQ 0
THEN
    BEGIN	! Normal case
    LOCAL
	LC  : REF VECTOR [,BYTE],	! Addr of line characteristics
				        ! vector for text buffer.
	LCS : REF VECTOR [,BYTE],	! Addr of line characteristics
					! vector for screen text buffer.
	B_OFFSET,	! Byte offset to begining of line of interest
	WIDTH;		! Extracted copy of .WCB [WCB_W_NO_COLS]

    WIDTH = .WCB [WCB_W_NO_COLS];
    B_OFFSET = (.PBCB [PBCB_W_FIRST_CHANGED_ROW] - 1 ) * .WIDTH;
    LC  = .WCB [WCB_A_LINE_CHAR];
    LCS = .WCB [WCB_A_SCR_LINE_CHAR];

    !+
    ! Try to narrow the range of lines that claim to have been changed.
    ! If we can collapse it to 1 or less, scrolling is not feasible.
    ! As a by-product of doing these tests, the range of lines that
    ! may have changed will possibly be narrowed, making minimum 
    ! update's work faster.
    ! First try to refine the "first changed line" downwards.
    !-
    WHILE .PBCB [PBCB_W_FIRST_CHANGED_ROW] LSS
          .PBCB [PBCB_W_LAST_CHANGED_ROW]
    DO
	BEGIN	! Collapsing loop
	!+
	! If this line is the same, with respect to the text buffer,
	! the attribute buffer, and the line characteristics vector, 
	! then it is not changed -- drag down the first changed line by 
	! 1.
	!-
	IF CH$EQL ( .WIDTH, .WCB [WCB_A_TEXT_BUF]     + .B_OFFSET,
		    .WIDTH, .WCB [WCB_A_SCR_TEXT_BUF] + .B_OFFSET)

	   AND

	   CH$EQL ( .WIDTH, .WCB [WCB_A_ATTR_BUF]     + .B_OFFSET,
		    .WIDTH, .WCB [WCB_A_SCR_ATTR_BUF] + .B_OFFSET)

	   AND

	   .LC  [.PBCB [PBCB_W_FIRST_CHANGED_ROW] ] EQL
	   .LCS [.PBCB [PBCB_W_FIRST_CHANGED_ROW] ]

	THEN
	    BEGIN	! Advance one row
	    PBCB [PBCB_W_FIRST_CHANGED_ROW] = 
				.PBCB [PBCB_W_FIRST_CHANGED_ROW] + 1;
	    B_OFFSET = .B_OFFSET + .WIDTH;
	    END	! Advance one row
	ELSE
	    EXITLOOP;	! 1st refined downward as far as possible
	END;	! Collapsing loop

    !+
    ! Now try to refine "last changed line" upward in a similar manner.
    !-
    B_OFFSET = (.PBCB [PBCB_W_LAST_CHANGED_ROW] - 1 ) * .WIDTH;

    WHILE .PBCB [PBCB_W_FIRST_CHANGED_ROW] LSS
          .PBCB [PBCB_W_LAST_CHANGED_ROW]
    DO
	BEGIN	! Collapsing loop

	!+
	! If this line is the same, with respect to the text buffer,
	! the attribute buffer, and the line characteristics vector,
	! then it is not changed -- drag up the last changed line by 1.
	!-
	IF CH$EQL ( .WIDTH, .WCB [WCB_A_TEXT_BUF]     + .B_OFFSET,
		    .WIDTH, .WCB [WCB_A_SCR_TEXT_BUF] + .B_OFFSET)

           AND

           CH$EQL ( .WIDTH, .WCB [WCB_A_ATTR_BUF]     + .B_OFFSET,
		    .WIDTH, .WCB [WCB_A_SCR_ATTR_BUF] + .B_OFFSET)

	   AND

	   .LC  [.PBCB [PBCB_W_LAST_CHANGED_ROW] ] EQL
	   .LCS [.PBCB [PBCB_W_LAST_CHANGED_ROW] ]

	THEN
	    BEGIN	! Back up one row
	    PBCB [PBCB_W_LAST_CHANGED_ROW] = 
				.PBCB [PBCB_W_LAST_CHANGED_ROW] - 1;
	    B_OFFSET = .B_OFFSET - .WIDTH;
	    END	! Back up one row
	ELSE
	    EXITLOOP;	! 1st refined downward as far as possible
	END;	! Collapsing loop
    END		! Normal case

ELSE

    BEGIN	! Range not set case
    !+
    ! It is possible, in some obscure cases, to reach here with the
    ! the 1st changed row set to #rows+1 and last changed row set to 0.
    ! In this case, set range to whole pasteboard.
    !-
    PBCB [PBCB_W_FIRST_CHANGED_ROW] = 1;
    PBCB [PBCB_W_LAST_CHANGED_ROW]  = .WCB [WCB_W_NO_ROWS];
    END;	! Range not set case

!+
! If we reach here, we have legitimate differences on the lines
! between .PBCB [PBCB_FIRST_CHANGED_ROW] and 
! .PBCB [PBCB_LAST_CHANGED_ROW]
!-

!+
! If terminal supports scrolling regions, check to see if minimal update can be helped
! by using physical scrolling regions.
! *** Actually, we could also do full screen scrolling if we wanted to.
!-

$SMG$GET_TERM_DATA(SET_SCROLL_REGION,1,2);

IF .PBCB[PBCB_L_CAP_LENGTH] NEQ 0
THEN
    BEGIN	! Terminal supports scrolling regions
    !+
    ! Changed area must be at least 2 lines high for scrolling to be
    ! useful.
    !-
    IF .PBCB [PBCB_W_LAST_CHANGED_ROW] - 
       .PBCB [PBCB_W_FIRST_CHANGED_ROW] GEQ 1
    THEN
	BEGIN	! Scrolling may be possible

	SMG$$CHECK_HDWR_SCROLL (.PBCB);

	END;	! Scrolling may be possible
    END;	! Terminal is a VT100

RETURN	SMG$$OUTPUT_PASTEBOARD(.PBCB)

END;			! End of routine SMG$$MIN_UPD

%SBTTL 'SMG$$OUTPUT_PASTEBOARD - bring pasteboard up-to-date'
GLOBAL ROUTINE SMG$$OUTPUT_PASTEBOARD ( P_PBCB ) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Brings the display associated with this pasteboard up-to-date.
!	It does this by either redrawing it in its entirety,
!	or by perfomring minimal update if that mode is enabled.
!
! CALLING SEQUENCE:
!
!	ret_status.wlc.v = SMG$$OUTPUT_PASTEBOARD ( P_PBCB.rab.r )
!
! FORMAL PARAMETERS:
!
!	P_PBCB.rab.r		Address of pasteboard control block.
!
! IMPLICIT INPUTS:
!
!	contents of PBCB and its WCB
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	SMG$_BATWAS_ON	OK, but batching was on, so nothing happened
!	SS$_NORMAL	Normal successful completion
!
! SIDE EFFECTS:
!
!	NONE
!--

BEGIN

BIND

	PBCB		= .P_PBCB		: $PBCB_DECL,
	WCB		= .PBCB[PBCB_A_WCB]	: $WCB_DECL,
	TEXT_BUF	= .WCB[WCB_A_TEXT_BUF]	: VECTOR[,BYTE],
	ATTR_BUF	= .WCB[WCB_A_ATTR_BUF]	: VECTOR[,BYTE],
	ROWS		=  WCB[WCB_W_NO_ROWS]	: WORD,
	COLS		=  WCB[WCB_W_NO_COLS]	: WORD;

LOCAL

	STATUS,
	SIZE;

EXTERNAL LITERAL

	SMG$_BATWAS_ON;

!+
! Do nothing if the output is being controlled by RMS.
!-

IF .PBCB[PBCB_V_RMS]
  THEN	RETURN	SMG$_WILUSERMS;

!+
! Do nothing if batching is in effect.
!-

IF .PBCB[PBCB_L_BATCH_LEVEL] NEQ 0
  THEN	RETURN	SMG$_BATWAS_ON;

SIZE = .ROWS * .COLS;

!+
! If minimal updating is in effect, then call
! SMG$$OUTPUT_MINIMAL_UPDATE to output a minimal update sequence.
! Then return.
!-

IF .PBCB[PBCB_V_MINUPD]
  THEN	RETURN SMG$$OUTPUT_MINIMAL_UPDATE(PBCB);

!+
! Otherwise, do nothing (for now).
!-

RETURN	SS$_NORMAL

END;			! End of routine SMG$$OUTPUT_PASTEBOARD

%SBTTL 'SMG$$PUT_SCREEN - Output to screen'
GLOBAL ROUTINE SMG$$PUT_SCREEN (
		P_PBCB,
		TEXT_LEN,
		TEXT_ADR,
		ROW_NUM,
		COL_NUM,
		FLAGS : BITVECTOR[32] ) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Logically outputs a string to the screen using calls
!	to SMG$$OUTPUT.  The text may be accomapnied by
!	renditions and cursor positioning.
!	Note that the output sequences generated may get
!	buffered up by SMG$$OUTPUT if buffering is enabled.
!
! CALLING SEQUENCE:
!
!	ret_status.wlc.v = SMG$$PUT_SCREEN(
!					P_PBCB.rab.r,
!					TEXT_LEN.rl.v,
!					TEXT_ADR.rt.r
!					ROW_NUM.rl.v,
!					COL_NUM.rl.v
!					[,FLAGS.rl.v])
!
! FORMAL PARAMETERS:
!
!	P_PBCB.rab.r		Address of pasteboard control block.
!
!	TEXT_LEN.rl.v		Number of characters in text string
!
!	TEXT_ADR.rt.r		Address of start of text string
!
!	ROW_NUM.rl.v		Row number
!
!	COL_NUM.rl.v		Column number
!
!	FLAGS.rl.v		Rendition codes. (bit encoded)
!				Optional. If omitted, normal rendition
!				occurs.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	SS$_NORMAL	Normal successful completion
!
! SIDE EFFECTS:
!
!	NONE
!--

BEGIN

BIND

	PBCB	= .P_PBCB	: $PBCB_DECL;	! Pasteboard control block

LOCAL

	STATUS;

OWN

	TRANSLATED_TEXT_DESC	: BLOCK[8,BYTE]	! reusable dynamic descriptor
						! must be OWN storage
	PRESET(	[DSC$B_DTYPE]	= DSC$K_DTYPE_T,
		[DSC$B_CLASS]	= DSC$K_CLASS_D,
		[DSC$W_LENGTH]	= 0,
		[DSC$A_POINTER]	= 0);

BUILTIN

	ACTUALCOUNT;

!+
! Do nothing if the output is being controlled by RMS.
!-

IF .PBCB[PBCB_V_RMS]
  THEN	RETURN	SMG$_WILUSERMS;

!+
! If a rendition was specified, then output it now.
!-

IF ACTUALCOUNT() GEQU 6
  THEN	BEGIN	! output text and renditions and cursor positioning

	BIND	TT2 = PBCB[PBCB_L_DEVDEPEND2]	: $BBLOCK;

	!+
	! Renditions requires that the AVO (ADVANCED_VIDEO) terminal
	! characteristic bit be set.  Even if the TERMTABLE entries
	! show that the terminal has the BEGIN_BOLD capability,
	! the terminal might not have the advanced video option.
	!-

	IF .FLAGS[ATTR_V_REND_GRAPHIC]
	AND (.TT2[TT2$V_AVO] OR NOT .TT2[TT2$V_ANSICRT])
	  THEN	BEGIN
		$SMG$GET_TERM_DATA(BEGIN_LINE_DRAWING_CHAR);

		IF .PBCB[PBCB_L_CAP_LENGTH] NEQ 0
		  THEN	BEGIN
			STATUS=SMG$$OUTPUT(PBCB,.PBCB[PBCB_L_CAP_LENGTH],
						.PBCB[PBCB_A_CAP_BUFFER]);
			IF NOT .STATUS THEN RETURN .STATUS
			END;
		END;

	!+
	! Get and output the string to set the correct attributes.
	!-

	IF .FLAGS[ATTR_V_REND_BOLD]
	AND (.TT2[TT2$V_AVO] OR NOT .TT2[TT2$V_ANSICRT])
	  THEN	BEGIN
		$SMG$GET_TERM_DATA(BEGIN_BOLD);

		IF .PBCB[PBCB_L_CAP_LENGTH] NEQ 0
		  THEN	BEGIN
			STATUS=SMG$$OUTPUT(PBCB,.PBCB[PBCB_L_CAP_LENGTH],
						.PBCB[PBCB_A_CAP_BUFFER]);
			IF NOT .STATUS THEN RETURN .STATUS;
			END;
		END;

	IF .FLAGS[ATTR_V_REND_BLINK]
	AND (.TT2[TT2$V_AVO] OR NOT .TT2[TT2$V_ANSICRT])
	  THEN	BEGIN
		$SMG$GET_TERM_DATA(BEGIN_BLINK);

		IF .PBCB[PBCB_L_CAP_LENGTH] NEQ 0
		  THEN	BEGIN
			STATUS=SMG$$OUTPUT(PBCB,.PBCB[PBCB_L_CAP_LENGTH],
						.PBCB[PBCB_A_CAP_BUFFER]);
			IF NOT .STATUS THEN RETURN .STATUS;
			END;
		END;

	IF .FLAGS[ATTR_V_REND_REV]
	AND (.TT2[TT2$V_AVO] OR NOT .TT2[TT2$V_ANSICRT])
	  THEN	BEGIN
		$SMG$GET_TERM_DATA(BEGIN_REVERSE);

		IF .PBCB[PBCB_L_CAP_LENGTH] NEQ 0
		  THEN	BEGIN
			STATUS=SMG$$OUTPUT(PBCB,.PBCB[PBCB_L_CAP_LENGTH],
						.PBCB[PBCB_A_CAP_BUFFER]);
			IF NOT .STATUS THEN RETURN .STATUS;
			END;
		END;

	IF .FLAGS[ATTR_V_REND_UNDER]
	AND (.TT2[TT2$V_AVO] OR NOT .TT2[TT2$V_ANSICRT])
	  THEN	BEGIN
		$SMG$GET_TERM_DATA(BEGIN_UNDERSCORE);

		IF .PBCB[PBCB_L_CAP_LENGTH] NEQ 0
		  THEN	BEGIN
			STATUS=SMG$$OUTPUT(PBCB,.PBCB[PBCB_L_CAP_LENGTH],
						.PBCB[PBCB_A_CAP_BUFFER]);
			IF NOT .STATUS THEN RETURN .STATUS;
			END;
		END;

	!+
	! Output the text if they are not border elements.
	! Output translated text for border elements.
	!-

	IF .FLAGS[ATTR_V_BORD_ELEM] OR .FLAGS[ATTR_V_USER_GRAPHIC]
	  THEN	BEGIN	! handing border element

		LOCAL

			TEXT_DESC	: VECTOR[2];

		EXTERNAL ROUTINE

			LIB$SCOPY_DXDX;

		!+
		! Build a fixed-length string descriptor for the
		! source text.
		!-

		TEXT_DESC[0]=.TEXT_LEN;
		TEXT_DESC[1]=.TEXT_ADR;

		!+
		! Get and output the prefix string to start borders.
		!-

		IF .TT2[TT2$V_AVO] OR NOT .TT2[TT2$V_ANSICRT]
		  THEN	BEGIN
			$SMG$GET_TERM_DATA(BEGIN_LINE_DRAWING_CHAR);

			IF .PBCB[PBCB_L_CAP_LENGTH] NEQ 0
			  THEN	BEGIN
				STATUS=SMG$$OUTPUT(PBCB,.PBCB[PBCB_L_CAP_LENGTH],
							.PBCB[PBCB_A_CAP_BUFFER]);
				IF NOT .STATUS THEN RETURN .STATUS;
				END;
			END;

		!+
		! If the COMPLEX_BORDER bit is set, then we have to output
		! the border characters one at a time.
		! Otherwise, we can do a byte for byte translation.
		!-

		IF .PBCB[PBCB_V_COMPLEX_BORDER]
		  THEN	BEGIN	! Complex border

			INCR I FROM 0 TO .TRANSLATED_TEXT_DESC[DSC$W_LENGTH]-1 DO
				BEGIN
				LOCAL CHAR;
				BIND	BUF = .TRANSLATED_TEXT_DESC[DSC$A_POINTER]
					: VECTOR[,BYTE];
				BIND	BORDER_VECTOR = PBCB[PBCB_R_BORDER_VECTOR]
					: VECTOR[16];
				CHAR=.BUF[.I];
				IF .CHAR GEQU 16
				  THEN	BEGIN
					CHAR=.CHAR/16;
					!+
					! The following code is ridiculous.
					! We should really have a control_vector in the PBCB
					! so that these characters will be gotton just once.
					! However, we had no chance to do this before final code freeze.
					!-

					SELECTONE .CHAR OF

					SET

					[6]:	$SMG$GET_TERM_DATA(TRUNCATION_ICON);
					[9]:	$SMG$GET_TERM_DATA(HT_GRAPHIC);
					[10]:	$SMG$GET_TERM_DATA(LF_GRAPHIC);
					[11]:	$SMG$GET_TERM_DATA(VT_GRAPHIC);
					[12]:	$SMG$GET_TERM_DATA(FF_GRAPHIC);
					[13]:	$SMG$GET_TERM_DATA(CR_GRAPHIC);
					[OTHERWISE]:	$SMG$GET_TERM_DATA(TRUNCATION_ICON) ! Error character

					TES;

					IF .PBCB[PBCB_L_CAP_LENGTH] NEQ 0
					  THEN	BEGIN
						STATUS=SMG$$OUTPUT(PBCB,.PBCB[PBCB_L_CAP_LENGTH],
									.PBCB[PBCB_A_CAP_BUFFER]);
						IF NOT .STATUS THEN RETURN .STATUS
						END
					  ELSE	BEGIN
						STATUS=SMG$$OUTPUT(PBCB,1,UPLIT BYTE('*'));
						IF NOT .STATUS THEN RETURN .STATUS
						END;

					END
				  ELSE	BEGIN
					BIND COUNT=.BORDER_VECTOR[.CHAR] : BYTE,
					     STRING=COUNT+1;
					STATUS=SMG$$OUTPUT(PBCB,.COUNT,STRING);
					IF NOT .STATUS THEN RETURN .STATUS
					END
				END;


			END	! Complex border
		  ELSE	BEGIN	! Simple border

			!+
			! Copy the input string to the output string.
			!-

			STATUS=LIB$SCOPY_DXDX(TEXT_DESC,TRANSLATED_TEXT_DESC);
			IF NOT .STATUS THEN RETURN .STATUS;

			!+
			! Change the characters as per the border vector.
			!-

			INCR I FROM 0 TO .TRANSLATED_TEXT_DESC[DSC$W_LENGTH]-1 DO
				BEGIN
				LOCAL CHAR;
				BIND	BUF = .TRANSLATED_TEXT_DESC[DSC$A_POINTER]
					: VECTOR[,BYTE];
				BIND	BORDER_VECTOR = PBCB[PBCB_R_BORDER_VECTOR]
					: VECTOR[16];
				!+
				! If the character is larger than 15, then
				! the high-order nibble is a special
				! user-graphic character.  We could allow
				! for up to 15 characters here, things
				! like CR_GRAPHIC, etc., but for now
				! we only allow code 6 to mean truncation-icon.
				! Other codes represent the error character.
				!-
				CHAR=.BUF[.I];
				IF .CHAR GEQU 16
				  THEN	BEGIN
					CHAR=.CHAR/16;

					!+
					! The following code is ridiculous.
					! We should really have a control_vector in the PBCB
					! so that these characters will be gotton just once.
					! However, we had no chance to do this before final code freeze.
					!-

					SELECTONE .CHAR OF

					SET

					[6]:	$SMG$GET_TERM_DATA(TRUNCATION_ICON);
					[9]:	$SMG$GET_TERM_DATA(HT_GRAPHIC);
					[10]:	$SMG$GET_TERM_DATA(LF_GRAPHIC);
					[11]:	$SMG$GET_TERM_DATA(VT_GRAPHIC);
					[12]:	$SMG$GET_TERM_DATA(FF_GRAPHIC);
					[13]:	$SMG$GET_TERM_DATA(CR_GRAPHIC);
					[OTHERWISE]:	$SMG$GET_TERM_DATA(TRUNCATION_ICON) ! Error character

					TES;

					IF .PBCB[PBCB_L_CAP_LENGTH] NEQ 0
					  THEN	BEGIN
						BIND CHAR=.PBCB[PBCB_A_CAP_BUFFER] : BYTE;
						BUF[.I]=.CHAR
						END
					  ELSE	BEGIN
						BUF[.I]=%C'*'
						END;

					END
				  ELSE	BUF[.I]=.BORDER_VECTOR[.CHAR]
				END;

			!+
			! Output the translated characters.
			! We do not free the dynamic string at this time
			! as an optimization.  We are sure to need that
			! space later.
			!-

			STATUS=SMG$$OUTPUT(PBCB,
					   .TRANSLATED_TEXT_DESC[DSC$W_LENGTH],
					   .TRANSLATED_TEXT_DESC[DSC$A_POINTER]);
			IF NOT .STATUS THEN RETURN .STATUS;

			END;	! Simple border

		!+
		! Get and output the suffix string to reset attributes to normal.
		!-

		IF .TT2[TT2$V_AVO] OR NOT .TT2[TT2$V_ANSICRT]
		  THEN	BEGIN
			$SMG$GET_TERM_DATA(END_LINE_DRAWING_CHAR);

			IF .PBCB[PBCB_L_CAP_LENGTH] NEQ 0
			  THEN	BEGIN
				STATUS=SMG$$OUTPUT(PBCB,.PBCB[PBCB_L_CAP_LENGTH],
							.PBCB[PBCB_A_CAP_BUFFER]);
				IF NOT .STATUS THEN RETURN .STATUS;
				END;
			END;

		END	! handling border element
	  ELSE	BEGIN	! handling normal text
		STATUS=SMG$$OUTPUT(PBCB,.TEXT_LEN,.TEXT_ADR);
		IF NOT .STATUS THEN RETURN .STATUS;
		END;	! handling normal text

	!+
	! Get and output the suffix string to reset attributes to normal.
	! We used to assume that END_BOLD brings back normal attributes.
	! Now we rely on BEGIN_NORMAL_RENDITION.
	!-

	IF .TT2[TT2$V_AVO] OR NOT .TT2[TT2$V_ANSICRT]
	  THEN	BEGIN

		%IF %DECLARED( SMG$K_BEGIN_NORMAL_RENDITION )
		%THEN
			$SMG$GET_TERM_DATA(BEGIN_NORMAL_RENDITION);
		%ELSE
			$SMG$GET_TERM_DATA(END_BOLD);
		%FI

		IF .PBCB[PBCB_L_CAP_LENGTH] NEQ 0
		  THEN	BEGIN
			STATUS=SMG$$OUTPUT(PBCB,.PBCB[PBCB_L_CAP_LENGTH],
						.PBCB[PBCB_A_CAP_BUFFER]);
			IF NOT .STATUS THEN RETURN .STATUS;
			END;
		END;

	IF .FLAGS[ATTR_V_REND_GRAPHIC]
	AND (.TT2[TT2$V_AVO] OR NOT .TT2[TT2$V_ANSICRT])
	  THEN	BEGIN
		$SMG$GET_TERM_DATA(END_LINE_DRAWING_CHAR);

		IF .PBCB[PBCB_L_CAP_LENGTH] NEQ 0
		  THEN	BEGIN
			STATUS=SMG$$OUTPUT(PBCB,.PBCB[PBCB_L_CAP_LENGTH],
						.PBCB[PBCB_A_CAP_BUFFER]);
			IF NOT .STATUS THEN RETURN .STATUS
			END;
		END;

	END	! output text and renditions
  ELSE	BEGIN	! output text only

	STATUS=SMG$$OUTPUT(PBCB,.TEXT_LEN,.TEXT_ADR);
	IF NOT .STATUS THEN RETURN .STATUS

	END;	! output text only

RETURN SS$_NORMAL

END;	! routine SMG$$PUT_SCREEN

%SBTTL 'SMG$$AUTOB_OUTPUT - Autobended entry for output to screen'
GLOBAL ROUTINE SMG$$AUTOB_OUTPUT (PB_ID,TEXT_LEN,TEXT_ADR) =
!++
! FUNCTIONAL DESCRIPTION:
!
!
! CALLING SEQUENCE:
!
!	ret_status.wlc.v = SMG$$AUTOB_OUTPUT(
!					PB_ID.rl.v,
!					TEXT_LEN.rl.v,
!					TEXT_ADR.rt.r)
!
! FORMAL PARAMETERS:
!
!	PB_ID.rl.v		Pasteboard id
!
!	TEXT_LEN.rl.v		Number of characters in text string
!
!	TEXT_ADR.rt.r		Address of start of text string
!				The text may contain escape sequences.
!
! IMPLICIT INPUTS:
!
!	None
!
! IMPLICIT OUTPUTS:
!
!	None
!
! COMPLETION STATUS:
!
!	SS$_NORMAL	Normal successful completion
!
! SIDE EFFECTS:
!
!	The following may occur as a result of calling SMG$$OUTPUT:
!	Output may occur.
!	If buffering is enabled, buffers may fill and/or dump.
!--

BEGIN

LOCAL

	PBCB;

$SMG$GET_PBCB(.PB_ID,PBCB);

RETURN SMG$$OUTPUT(.PBCB,.TEXT_LEN,.TEXT_ADR)

END;				! end of routine SMG$$AUTOB_OUTPUT

%SBTTL 'SMG$$OUTPUT - Output to screen'
GLOBAL ROUTINE SMG$$OUTPUT (P_PBCB,TEXT_LEN,TEXT_ADR) =
!++
! FUNCTIONAL DESCRIPTION:
!
!
! CALLING SEQUENCE:
!
!	ret_status.wlc.v = SMG$$OUTPUT(
!					P_PBCB.rab.r,
!					TEXT_LEN.rl.v,
!					TEXT_ADR.rt.r)
!
! FORMAL PARAMETERS:
!
!	P_PBCB.rab.r		Address of pasteboard control block.
!
!	TEXT_LEN.rl.v		Number of characters in text string
!
!	TEXT_ADR.rt.r		Address of start of text string
!				The text may contain escape sequences.
!
! IMPLICIT INPUTS:
!
!	Contents of PBCB.
!
! IMPLICIT OUTPUTS:
!
!	PBCB[PBCB_W_OUTPUT_BUFLEN]	may change if buffering is enabled.
!
! COMPLETION STATUS:
!
!	SS$_NORMAL	Normal successful completion
!
! SIDE EFFECTS:
!
!	Output may occur.
!	If buffering is enabled, buffers may fill and/or dump.
!--

BEGIN

BIND

	PBCB	= .P_PBCB	: $PBCB_DECL,	! pasteboard control block
	TEXT	= .TEXT_ADR	: VECTOR[,BYTE],! string to be output
	BUFLEN	=  PBCB[PBCB_W_OUTPUT_BUFLEN]	: WORD,	! number of chars in buffer
	BUFSIZ	=  PBCB[PBCB_W_OUTPUT_BUFSIZ]	: WORD,	! size of buffer
	BUFFER	= .PBCB[PBCB_A_OUTPUT_BUFFER]	: VECTOR[,BYTE];	! Output buffer

LOCAL

	STATUS;

!+
! Do nothing if the output is being controlled by RMS.
!-

IF .PBCB[PBCB_V_RMS]
  THEN	RETURN	SMG$_WILUSERMS;

!+
! If buffering is enabled, and the new string won't fit in the buffer,
! then we must output the buffer now.
! If it will fit, then just put it in the buffer.
! Do not break up the string since we do not want to output
! a partial escape sequence.
!-

IF .PBCB[PBCB_V_BUF_ENABLED]
  THEN	BEGIN	! buffering is enabled

	!+
	! See if the string will fit in the buffer.
	!-

	IF .TEXT_LEN+.BUFLEN GTRU .BUFSIZ
	  THEN	BEGIN	! No - Dump buffer
		STATUS=OUTPUT(PBCB,.BUFLEN,BUFFER);
		IF NOT .STATUS THEN RETURN .STATUS;
		BUFLEN=0
		END	! No - Dump buffer
	  ELSE	BEGIN	! Yes - append to buffer

		!+
		! Copy the text into the buffer,
		! update BUFLEN which keeps track of
		! how much data is in the buffer,
		! and then return.
		!-

		CH$MOVE(.TEXT_LEN,TEXT,BUFFER[.BUFLEN]);
		BUFLEN=.BUFLEN+.TEXT_LEN;
		RETURN	SS$_NORMAL

		END;	! Yes - append to buffer

	!+
	! We reach here if the string would not fit in the buffer.
	! The buffer has been dumped.
	! Put the new string into the buffer.
	! If it will not fit, we output it in chunks.
	! We output as many full buffer chunks as we can.
	! When we are all done, we are left with a string
	! smaller than one buffer's worth, which we then
	! put into our output buffer.
	!-

	INCR I FROM 0 BY .BUFSIZ DO
		IF .I+.BUFSIZ LEQU .TEXT_LEN
		  THEN	BEGIN	! output next part of string
			STATUS=OUTPUT(PBCB,.BUFSIZ,TEXT[.I]);
			IF NOT .STATUS THEN RETURN .STATUS
			END	! output next part of string
		  ELSE	BEGIN	! buffer final part of string
			BUFLEN=.TEXT_LEN-.I;			! could be 0
			CH$MOVE(.BUFLEN,TEXT[.I],BUFFER);
			EXITLOOP
			END	! buffer final part of string

	END	! buffering is enabled
  ELSE	BEGIN	! no buffering

	!+
	! Output the string directly.
	!-

	STATUS=OUTPUT(PBCB,.TEXT_LEN,TEXT);
	IF NOT .STATUS THEN RETURN .STATUS

	END;	! no buffering

RETURN 	SS$_NORMAL

END;

%SBTTL 'OUTPUT - Low level output'
ROUTINE OUTPUT(P_PBCB,TEXT_LEN,TEXT_ADR) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Handles low level output by issuing a QIO or calling RMS.
!	No buffering occurs here.
!	If CTRL/O was encountered, then we invalidate our knowledge
!	of the screen.
!
! CALLING SEQUENCE:
!
!	ret_status.wlc.v = OUTPUT(
!				P_PBCB.rab.r,
!				TEXT_LEN.rl.v,
!				TEXT_ADR.rt.r)
!
! FORMAL PARAMETERS:
!
!	P_PBCB.rab.r		Address of pasteboard control block.
!
!	TEXT_LEN.rl.v		Number of characters in text string
!
!	TEXT_ADR.rt.r		Address of start of text string
!				The text may contain escape sequences.
!
! IMPLICIT INPUTS:
!
!	Contents of PBCB.
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	SS$_NORMAL	Normal successful completion
!	SS$_xyz		errors from QIO
!	SS$_xyz		errors from $ASSIGN
!	RMS$_xyz	errors from RMS (STS value only)
!
! SIDE EFFECTS:
!
!	NONE
!--

BEGIN

BIND

	PBCB	= .P_PBCB	: $PBCB_DECL;	! pasteboard control block

LOCAL

	QIO_IOSB		: VECTOR[4],
	STATUS;

!+
! Do nothing if the output is being controlled by RMS.
!-

IF .PBCB[PBCB_V_RMS]
  THEN	RETURN	SMG$_WILUSERMS;

!+
! Null strings succeed no matter what.
!-

IF .TEXT_LEN EQL 0
  THEN	RETURN	SS$_NORMAL;

!+
! Normally, we use QIOs to talk to this terminal.
! See if a channel has been assigned yet.
! If not, assign a channel now.
!-

IF .PBCB[PBCB_W_CHAN] EQL 0
  THEN	BEGIN	! assigning channel

	! *** Perhaps this code should be moved to SMG$CREATE_PASTEBOARD.

	LOCAL	NAME_DESC	: VECTOR[2];	! Fixed length descriptor

	!+
	! Create a fixed length descriptor for our device name string
	! for use by $ASSIGN.
	!-

	NAME_DESC[0]=.PBCB[PBCB_W_DEVNAM_LEN];
	NAME_DESC[1]= PBCB[PBCB_T_DEVNAM];

	!+
	! Assign the channel.
	! Put the resulting channel number in PBCB[PBCB_W_CHAN].
	!-

	STATUS=$ASSIGN(	DEVNAM	= NAME_DESC,
			CHAN	= PBCB[PBCB_W_CHAN]);
	IF NOT .STATUS THEN RETURN .STATUS

	END;	! assigning channel

!+
! Issue a QIO to output the string.
!-

STATUS=$QIOW(	CHAN	= .PBCB[PBCB_W_CHAN],
		EFN	= .PBCB[PBCB_B_EFN],
		FUNC	=  IO$_WRITEVBLK OR IO$M_NOFORMAT OR
		   (IF .PBCB[PBCB_V_UNSOLICIT] THEN IO$M_ENABLMBX ELSE 0),
		IOSB	= QIO_IOSB,
		P1	= .TEXT_ADR,
		P2	= .TEXT_LEN);
IF NOT .STATUS THEN RETURN .STATUS;
IF NOT .QIO_IOSB[0] THEN RETURN .QIO_IOSB[0];

!+
! If the I/O was aborted by CTRL/O, then we have no idea how far
! the I/O got and so our knowledge of the screen is invalid.
! We therefore invalidate our screen buffer by setting the CONTROLO bit.
! (We can't just invalidate the screen buffer here because our caller
! may set that buffer.)
!-

IF .STATUS EQL SS$_CONTROLO
OR .QIO_IOSB[0] EQL SS$_CONTROLO
  THEN	PBCB[PBCB_V_CONTROLO]=1;

RETURN 	SS$_NORMAL

END;

END
ELUDOM
