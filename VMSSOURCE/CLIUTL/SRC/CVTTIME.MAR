	.TITLE	CVTTIME - CONVERT CLI TIME TO BINARY
	.IDENT	'V04-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY: GENERAL LIBRARY
;
; ABSTRACT:
;
; THESE ROUTINES ARE CALLED TO CONVERT AN ASCII STRING TO BINARY ABSO-
; LUTE OR DELTA-TIME FORMAT
;
; ENVIRONMENT: USER MODE
;
; AUTHOR: C. MONIA	, CREATION DATE: 12-SEP-1977
;
; MODIFIED BY:
;
;	V03-005	PCG0001		Peter George		23-Jun-1983
;		Do not accept keywords as delta time strings.
;		Remove leading blank from absolute time string.
;
;	V03-004	BLS0210		Benn Schreiber		 3-Mar-1983
;		Change third arg to be string descriptor, add 3 more
;		args.  Work around absolute addressing caused by reference
;		to DAY_TABLE.  Get length of return value when calling
;		$ASCTIM from LIB$CVT_TIME.
;
;	V03-003	LMP49245	L. Mark Pilant,		20-Sep-1982  16:15
;		Correct offset used to calculate "YESTERDAY".
;
;--

	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;
 
	$CLIMSGDEF		; DEFINE CLI STATUS CODES
	$SSDEF			; DEFINE SYSTEM STATUS CODES
 
;

;
; MACROS:
;
; DEFINE STATE
;
 
	.MACRO	STATE	NAME,FILL
	.SAVE
	.PSECT	_CNVCLI_STATE,NOWRT,RD
	.IF NB	NAME
NAME:
	.ENDC
	.REPT	NTOKNS
	.IF NB	FILL
	.BYTE	^A/FILL/
	.IFF
	.BYTE	0
	.ENDC
	.ENDR
	.REPT	NTOKNS
	.WORD	ILLCHR-CNV_RELOC
	.WORD	0
	.ENDR
	.RESTORE
	.ENDM
 
;
; DEFINE TOKEN LIST ENTRY
;
 
	.MACRO	TOKEN	TOKN,NXTSTATE,STRNGADR,FILL
	.SAVE
	.PSECT	_CNVCLI_STATE,NOWRT,RD
$$$1=.
	.BLKL	-NTOKNS
$$$2=.-NTOKNS
	.IF IDN	<->,<TOKN>
	.BLKL	1
$$$2=$$$2+1
	.ENDC
	.IF IDN <:>,<TOKN>
	.BLKL	2
$$$2=$$$2+2
	.ENDC
	.IF IDN	< >,<TOKN>
	.BLKL	3
$$$2=$$$2+3
	.ENDC
	.IF NB	STRNGADR
	.WORD	STRNGADR-CNV_RELOC
	.IFF
	.WORD	ENDSECS-CNV_RELOC
	.ENDC
	.IF NB	NXTSTATE
	.WORD	NXTSTATE-CNV_RELOC
	.IFF
	.WORD	0
	.ENDC
.=$$$2
	.IF NB	<FILL>
	.IF IDN	<RESCAN>,<FILL>
	.BYTE	RESC
	.IFF
	.IF IDN	<NULL>,<FILL>
	.BYTE	0
	.IFF
	.BYTE	^A/FILL/
	.ENDC
	.ENDC
	.ENDC
.=$$$1
	.RESTORE
	.ENDM

;
; DEFINE KEYWORD ENTRIES
;

	.MACRO	KEY_ENTRY KEYWORD

FIRST_FLAG$$=128
	.IRPC	CHAR$$,<KEYWORD>
	.BYTE	^A/CHAR$$/!FIRST_FLAG$$
FIRST_FLAG$$=0
	.ENDR
	.ENDM

;
; EQUATED SYMBOLS:
;
 
EOS=0					; TERMINATION SYMBOL
MAXLGH=25				; MAX STRING LENGTH
RESC=-2					; RESCAN FLAG
TS_LEN=60				; LIB$CVTTIME TEMPORARY STRING LENGTH
 
;
; DEFINE TOKEN DISPATCH TABLE OFFSETS
;
 
	.PSECT	$ABS$,ABS
 
TSTRING:.BLKW	1			; OFFSET TO TERMINAL STRING
NEXTSTATE:.BLKW	1			; OFFSET TO NEXT STATE
;
; OFFSETS FROM FP USED BY LIB$CVT_TIME 
;   (NB: This is not the only use of the stack)
;
	$OFFSET	0,NEGATIVE,<-
	<TEMPSTRING,TS_LEN>,-		; LIB$CVTTIME Temporary String
	<TEMPDESC,8>,-			; Descriptor for TEMPSTRING
	<SCRATCHSIZE,0>-		; Size of Scratch Area
	>
;
; OWN STORAGE:
;
	.PSECT	_CNVCLI_CODE	NOWRT,LONG
 
CNV_RELOC:.BLKL	0			; DEFINE RELOCATION BASE
 
;
; TOKEN LIST
;
 
$$$2=.					;
TOKENS:	.ASCII	/ :-/<EOS>		; ORDER IS FIXED
NTOKNS=.-$$$2				;
 
;
; TOKEN SUBSTITUTION STRINGS
;
; ADJACENCY REQUIRED
;
; COLON
;
 
COLDAY:	.ASCII	/-/			; DD:
COLMON:	.ASCII	/-/			; DD-MMM:
COLYR:	.ASCIZ	/ /			; DD-MMM-YYYY:
COLHR:					; [DD-MMM-YYYY]:HH:
COLMIN:	.ASCIZ	/:/			; [DD-MMM-YYYY]:HH:MM:
COLD:	.ASCIZ	/0 /			; <BLANK>!<->[HH:MM:SS.SS]
 
;
; END OF STRING
;
 
$$$3=.
ENDDAY:	.ASCII	/-/			; DD<EOS>
ENDMON:	.ASCII	/-/			; DD-MMM<EOS>
ENDD:					; DD<BLANK><EOS>
ENDYR:	.ASCII	/ 0/			; DD-MMM-YYYY<EOS>
ENDHR:	.ASCII	/:00/			; [DD-MMM-YYYY]:HH<EOS>
ENDMIN:	.ASCII	/:00.00/		; [DD-MMM-YYYY]:HH:MM<EOS>
ENDSECS:.BYTE	0			; [DD-MMM-YYYY]:HH:MM:SS.SS<EOS>
ILLCHR:	.BYTE	-1,0			; ILLEGAL CHARACTER TERMINATOR
FILCNT=.-$$$3				; FILL COUNT
TBUF=<<FILCNT+MAXLGH>+3>&-4		; SIZE OF BUFFER ON STACK
 
;
; BUFFER LENGTHS FOR ASCII TIME CONVERSION CALLS
;

SHORT_TIME_LEN=11			; LENGTH OF BUFFER FOR TIME WITHOUT HOURS
MIDNIGHT_LEN=8				; LENGTH OF MIDNIGHT ASCII TIME STRING
FULL_TIME_LEN=TBUF			; FULL TIME BUFFER LENGTH

;
; MINUS SIGN
;
 
MINDAY:					; DD-[MM-YYYY:HH:MM:SS.SS]<EOS>
MINMON:	.ASCIZ	/-/			; DD-MM-[YYYY:HH:MM:SS.SS]<EOS>
 
;
; DEFINE STATE TABLES FOR TIME CONVERSION
;
; INITIAL STATE
;
; PARSE DAY OF MONTH
;
 
	STATE	DAY			; PARSE DAY OF MONTH
	TOKEN	EOS,HOURS,COLDAY,RESCAN	 ; ASSUME TIME ON END OF STRING
	TOKEN	<:>,HOURS,COLDAY,RESCAN	 ; ASSUME TIME ON COLON
	TOKEN	-,MONTH,MINDAY		; PARSE MONTH OF YEAR
	TOKEN	< >,HOURS,COLDAY,RESCAN	 ; ASSUME TIME ON SPACE
 
;
; PARSE MONTH OF YEAR
;
 
	STATE	MONTH			;
	TOKEN	EOS,,ENDMON		; TERMINATE ON END OF STRING
	TOKEN	< >,HOURS,COLMON	; TERMINATE MONTH, CONVERT TIME
	TOKEN	<:>,HOURS,COLMON	; TERMINATE MONTH, CONVERT TIME
	TOKEN	-,YEAR,MINMON		; PARSE YEAR
 
;
; PARSE YEAR
;
 
	STATE	YEAR			;
	TOKEN	EOS,,ENDYR		; TERMINATE ON END OF STRING
	TOKEN	<:>,HOURS,COLYR		; CONVERT TIME, TERMINATE DATE
	TOKEN	< >,HOURS,COLYR		; CONVERT TIME, TERMINATE DATE
 
;
; PARSE HOURS
;
 
	STATE	HOURS,<0>		;
	TOKEN	EOS,,ENDHR		; TERMINATE ON END OF STRING
	TOKEN	<:>,MINUTES,COLHR 	; MOVE TOKEN
	TOKEN	< >,HOURS,,NULL		; IGNORE SPACES
 
;
; PARSE MINUTES
;
 
	STATE	MINUTES,<0>		;
	TOKEN	EOS,,ENDMIN		; TERMINATE ON END OF STRING
	TOKEN	<:>,SECONDS,COLMIN 	; MOVE PARSED STRING
	TOKEN	< >,MINUTES,,NULL	; IGNORE SPACES
 
;
; PARSE SECONDS
;
 
	STATE	SECONDS,<0>		;
	TOKEN	EOS,,ENDSECS		; TERMINATE ON END OF STRING
	TOKEN	< >,SECONDS,,NULL	; IGNORE SPACES
 
;
; PARSE DELTA-TIME FORMAT
;
; PARSE DELTA-DAY
;
 
	STATE	DELTA_DAY,<0>		;
	TOKEN	EOS,HOURS,COLD,RESCAN	; RESCAN ON END OF STRING
	TOKEN	<:>,HOURS,COLD,RESCAN	; RESCAN ON COLON
	TOKEN	< >,HOURS,COLD,RESCAN	; RESCAN ON SPACE
	TOKEN	<->,HOURS,COLYR		; MOVE PARSED STRING

;
; DEFINE MNEMONIC KEYWORDS THAT CAN REPRESENT TIMES
;

DAY_TABLE:
	KEY_ENTRY	YEST		; "YESTERDAY"
	KEY_ENTRY	TODA		; "TODAY"
	KEY_ENTRY	TOMO		; "TOMORROW"
DAY_TBL_LEN=.-DAY_TABLE			; LENGTH OF KEYWORD TABLE

;
; TIME FACTORS. EACH KEYWORD HAS AN ASSOCIATED TIME FACTOR, WHICH, WHEN ADDED
; TO THE CURRENT TIME VALUE, CREATES A 64-BIT TIME VALUE THAT IS EQUIVALENT TO
; THE KEYWORD STRING.
;
; YESTERDAY IS ONE NANOSECOND BEFORE ZERO TIME TODAY.
; TODAY IS ZERO TIME TODAY.
; TOMORROW IS ZERO TIME TODAY PLUS ONE DAY'S WORTH OF NANOSECONDS.
;
; NOTE THAT THE FIGURES IN THIS TABLE ARE "MAGIC" NUMBERS.
;

TIME_TABLE:
	.LONG	^XD5964000		; "YESTERDAY"
	.LONG	^XFFFFFF36
	.LONG	0			; "TODAY"
	.LONG	0
	.LONG	^X2A69C000		; "TOMORROW"
	.LONG	^XC9


	.SBTTL	LIB$CVT_TIME
;++
; FUNCTIONAL DESCRIPTION:
;
; THESE ROUTINES ARE CALLED TO CONVERT AN ASCII STRING INTO A FORM
; THAT IS ACCEPTABLE TO THE 'GET TIME' SYSTEM SERVICES.
;
; ENTRY POINT LIB$CVT_TIME IS CALLED TO CONVERT A STRING TO ABSOLUTE
; BINARY TIME.
;
; ENTRY POINT LIB$CVT_DTIME IS CALLED TO CONVERT A STRING TO DELTA
; TIME
;
; ABSOLUTE TIME SYNTAX:
;
; THE FULLY EXPANDED TIME STRING, AS SEEN BY THE SYSTEM, HAS THE FORM:
;
;	DD-MMM-YYYY<BLANK>HH:MM:SS.SS
;
; WHERE ANY FIELD MAY BE EMPTY.
;
; THE TIME CONVERSION ROUTINES CONVERT ABBREVIATED INPUT SUPPLIED BY
; THE CALLER INTO THE ABOVE FORMAT, THEN INVOKE THE SYSTEM SERVICE TO
; CONVERT THE STRING TO BINARY.
;
; THE FOLLOWING FORMS ARE ACCEPTABLE:
;
;	DD-MMM-YYYY:HH:MM:SS.SS		- FULL
;
;	DD-MMM-YYYY<BLANK>HH:MM:SS.SS	- FULL
;
;	DD-MMM:HH:MM			- TRUNCATED FIELDS
;
;	DD--YYYY:HH::SS			- NULL FIELDS
;
;	HH:[MM:SS.SS]			- TIME ONLY
;
; DELTA TIME SYNTAX
;
; THE FULLY EXPANDED DELTA TIME STRING AS SEEN BY THE SYSTEM IS:
;
;	DD<BLANK>HH:MM:SS.S
;
; WHERE ANY FIELD MAY BE EMPTY.
;
; THE FOLLOWING FORMS ARE ACCEPTABLE:
;
;	DD-HH:MM:SS.SS			- FULL
;
;	DD-HH:				- TRUNCATED FIELDS
;
;	DD-:MM				- NULL FIELDS
;
;	HH[:MM:SS.SS]			- TIME ONLY
;
;
; CALLING SEQUENCE:
;
;	CALL LIB$CVT_TIME   (DESCR,TIME,[OUTDESC],[OUTLEN],[USEDLEN],[FLAGS])
;	CALL LIB$CVT_ATIME   (DESCR,TIME,[OUTDESC],[OUTLEN],[USEDLEN],[FLAGS])
;	CALL LIB$CVT_DTIME   (DESCR,TIME,[OUTDESC],[OUTLEN],[USEDLEN],[FLAGS])
;
; INPUT PARAMETERS:
;
;	DESCR = ADDRESS OF INPUT STRING DESCRIPTOR
;
;	TIME = ADDRESS OF QUADWORD TO RECEIVE CONVERTED TIME
;
;	OUTDESC = [OPTIONAL] ADDRESS OF DESCRIPTOR FOR CONVERTED TIME
;			ASCII STRING
;
;	OUTLEN = [OPTIONAL] ADDRESS OF WORD TO RECEIVE OUTPUT STRING LENGTH
;
;	USEDLEN = [OPTIONAL] ADDRESS OF WORD TO RECEIVE LENGTH OF STRING USED
;
;	FLAGS = [OPTIONAL] NYI
;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	R0=CLI$_NORMAL
;
;
;	TIME = ABSOLUTE BINARY TIME IN 64-BIT FORMAT
;
;
;	R0=CLI$_IVVALU
;
;	INVALID TIME FORMAT DETECTED
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	R0 LBS = SUCCESS
;	R0 LBC = SYNTAX ERROR
;
; SIDE EFFECTS:
;
;	NONE
;
;--
;
; CONVERT FULL TIME STRING
;
	.ALIGN	LONG
	.ENTRY	LIB$CVT_TIME,^M<R2,R3,R4,R5,R6,R7,R8,R9>
	MOVAL	SCRATCHSIZE(SP),SP	; RESERVE SCRATCH STORAGE
	MOVC5	#0,(SP),#0,#-SCRATCHSIZE,(SP) ; ZERO THE SCRATCH STORAGE
	MOVAB	TEMPSTRING(FP),R7	; ADDR TO HOLD RETURNED STRING
	MOVL	#TS_LEN,TEMPDESC(FP)	; SETUP DESCRIPTOR
	MOVL	R7,TEMPDESC+4(FP)	;...
	MOVQ	@4(AP),R2		; GET STRING DESCRIPTOR
	MOVZWL	R2,R2			; Truncate length to a word

	TSTL	R2			; CHARACTERS LEFT TO EXAMINE?
	BEQL	10$			; NO, THEN SKIP
	CMPB	#^A/ /,(R3)		; DELETE LEADING BLANK
	BNEQ	10$			; BRANCH IF NOT BLANK
	DECL	R2			; DECREMENT LENGTH
	INCL	R3			; INCREMENT ADDRESS

10$:	LOCC	#^A/+/,R2,(R3)		; LOOK FOR PLUS SIGN
	MOVL	R0,R6			; SAVE BYTES REMAINING
	BNEQ	40$			; BR IF "+" FOUND
	LOCC	#^A/:/,R2,(R3)		; LOOK FOR COLON
	MOVL	R1,R4			; SAVE ADDR IF FOUND

	LOCC	#^A/-/,R2,(R3)		; LOOK FOR DASH
	BEQL	40$			; BR IF ABS TIME ONLY
	MOVL	R1,R5			; SAVE LOC. OF FIRST DASH
	CMPL	R1,R4			; "-" RIGHT OF ":"
	BGTRU	40$			; IF YES - THEN DELIMITER

	DECL	R0			; ADJUST COUNT BEYOND "-"
	INCL	R1			; ADJUST ADDR BEYOND "-"
	LOCC	#^A/-/,R0,(R1)		; LOOK FOR 2ND DASH
	BEQL	20$			; IF EQL - THEN NOT FOUND
	CMPL	R1,R4			; "-" RIGHT OF ":"
	BGTRU	40$			; IF YES - THEN DELIMITER

	DECL	R0			; ADJUST COUNT BEYOND 2ND "-"
	INCL	R1			; ADJUST ADDR BEYOND 2ND "-"
	LOCC	#^A/-/,R0,(R1)		; LOOK FOR THIRD DASH
	BNEQ	40$			; IF FOUND - THEN DELIMITER

20$:	INCL	R5			; INCREMENT BEYOND "-"
	CMPB	(R5),#^A/:/		; 
	BEQL	30$
	CMPB	(R5),#^A/0/		; CAN NEXT CHAR BE A DIGIT?
	BLSS	40$			; IF LESS THAN - THEN NO
	CMPB	(R5),#^A/9/		; CAN CHAR BE A DIGIT?
	BGTR	40$			; IF GT - THEN NO
30$:	SUBL3	#1,R5,R1		; BREAK STRING AT DIGIT OR DASH

40$:
	CLRQ	-(SP)			; QUAD WORD TIME BUFFER
	MOVL	R3,-(SP)		; GET ADDR. OF ABS TIME STRING
	SUBL3	R3,R1,-(SP)		; LENGTH OF ABS
	BNEQ	60$			; BR IF ABS TIME PRESENT
	$GETTIM_S	TIMADR=8(SP)	; GET CURRENT TIME
	BRB	80$			; DON'T CONVERT ABS TIME
60$:	PUSHAQ	8(SP)			; ADDR. OF BUFFER
	PUSHAQ	4(SP)			; ADDR. OF DESCRIPTOR
	CALLS	#2,w^LIB$CVT_ATIME	; CONVERT ABS TIME
	BLBC	R0,180$			; IF LBC - THEN ERROR
80$:	MOVQ	8(SP),@8(AP)		; MOVE TIME TO USER BUFFER

	INCL	(SP)			; INCLUDE DELIMITER IN COUNT
	ADDL	(SP),4(SP)		; POINT TO DELTA TIME
	SUBL3	(SP),R2,(SP)		; CALC LENGTH OF DELTA TIME
	BLEQ	140$			; EXIT IF NO DELTA TIME

	PUSHAQ	8(SP)			; ADDR OF BUFFER
	PUSHAQ	4(SP)			; ADDR OF DESCRIPTOR
	CALLS	#2,W^LIB$CVT_DTIME	; CONVERT DELTA TIME
	BLBC	R0,180$			; IF LBC - THEN ERROR CONVERTING

	MOVL	8(AP),R1		; GET ADDR OF USER BUFFER
	TSTL	R6			; DELTA TIME PLUS OR MINUS?
	BEQL	120$			; BR IF MINUS
;
; delta time is negative so arithmetic is inverted
;
	SUBL3	8(SP),(R1),(R1)+	; SUBTRACT DELTA
	SBWC	12(SP),(R1)		; FROM ABS TIME
	BRB	140$			; RETURN
120$:	ADDL3	8(SP),(R1),(R1)+	; ADD  DELTA
	ADWC	12(SP),(R1)		; TO ABS TIME
140$:	CMPB	(AP),#3			; DO WE NEED TO RETURN THE DATE/TIME?
	BLSSU	180$			; IF LSSU NO, DON'T BOTHER
	$ASCTIM_S TIMADR=@8(AP),-	; YES, CONVERT BINARY TIME
		  TIMBUF=TEMPDESC(FP),-
		  TIMLEN=TEMPDESC(FP)
	MOVQ	TEMPDESC(FP),R8		; LOAD DESCRIPTOR
	BSBB	RETURN_STRING		; RETURN STRING TO USER
180$:	RET

	.SBTTL	RETURN_STRING - RETURN DATE/TIME STRING IF REQUESTED
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE RETURNS THE DATE/TIME STRING (AND STRING) LENGTH
;	TO THE CALLER IF THE OPTIONAL ARGUMENTS ARE PRESENT
;
; INPUTS:
;
;	R8	LENGTH OF DATE/TIME STRING
;	R9	ADDRESS OF DATE/TIME STRING
;
;	12(AP)	IF PRESENT, ADDRESS OF OUTPUT STRING DESCRIPTOR
;	16(AP)	IF PRESENT, ADDRESS OF WORD TO STORE OUTPUT STRING LENGTH
;
;--
	.WEAK	DCL$SCOPY_DXDX		;DON'T COMPLAIN IF NOT FOUND

RETURN_STRING:
	MOVL	#1,R0			;PRESET SUCCESS
	CMPB	(AP),#3			;THIRD ARGUMENT PRESENT?
	BLSSU	20$			;BRANCH IF NOT
	TSTL	12(AP)			;YES, BUT WAS IT DEFAULTED?
	BEQL	20$			;BRANCH IF SO
	TSTL	R8			;NON-ZERO STRING?
	BEQL	5$			;IF EQL ZERO STRING
	CMPB	(R9),#^A/ /		;IS LEADING CHAR A SPACE?
	BNEQ	5$			;IF NEQ NO
	DECL	R8			;YES, STRIP IT OUT
	INCL	R9			; AND DON'T COPY IT
5$:	PUSHL	R9			;FORM DESCRIPTOR ON STACK
	PUSHL	R8			;...
	PUSHL	12(AP)			;STACK OUTPUT DESCRIPTOR ADDRESS
	PUSHAB	4(SP)			;STACK INPUT DESCRIPTOR ADDRESS
	MOVAB	G^DCL$SCOPY_DXDX,R0	;IS DCL STRING COPY PRESENT?
	BNEQ	10$			;IF NEQ YES--GO USE IT
	MOVAB	G^LIB$SCOPY_DXDX,R0	;NO--USE LIB$SCOPY
10$:	CALLS	#4,(R0)			;COPY STRING, CLEAR DESCRIPTOR
					; FROM STACK
	BLBC	R0,20$			;BRANCH IF SOME SORT OF COPY ERROR
	CMPB	(AP),#4			;WAS 4TH ARGUMENT PRESENT?
	BLSSU	20$			;IF LSSU NO
	TSTL	16(AP)			;YES, DEFAULTED?
	BEQL	20$			;IF EQL YES
	MOVW	R8,@16(AP)		;NO, STORE OUTPUT STRING LENGTH
20$:	RSB

	.SBTTL	LIB$CVT_ATIME - CONVERT ABSOLUTE TIME
 
;
; CONVERT ABSOLUTE TIME
;
 
	.ENABL	LSB
 
 
	.ENTRY	LIB$CVT_ATIME,^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	MOVAB	DAY,R11			; GET ADDRESS OF STATE TABLE
	MOVL	#CLI$_IVVALU,R2		; ASSUME STRING TOO LONG
	MOVQ	@4(AP),R6		; GET STRING DESCRIPTOR
	MOVZWL	R6,R6			; Truncate length to a word
	CMPW	#MAXLGH,R6		; STRING TOO LONG?
	BLSSU	20$			; IF LSSU YES
	SUBL	#TBUF,SP		; ALLOCATE BUFFER ON STACK
	CLRL	R8			; CLEAR OUTPUT STRING COUNT
	MOVL	SP,R9			; POINT TO BUFFER
	BSBW	CNV_MNEM_DAY		; SEE IF THE INPUT STRING IS A WORD
					; LIKE "YESTERDAY", "TODAY", OR
					; "TOMORROW".
	BLBC	R0,10$			; IF NOT, CHECK OUT DELTA TIMES
	RET				;
 

	.SBTTL	LIB$CVT_DTIME - CONVERT DELTA TIME
 
;
; CONVERT DELTA TIME
;
 
	.ENTRY	LIB$CVT_DTIME,^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	MOVAB	DELTA_DAY,R11		; GET ADDRESS OF STATE TABLE
	MOVL	#CLI$_IVVALU,R2		; ASSUME STRING TOO LONG
	MOVQ	@4(AP),R6		; GET STRING DESCRIPTOR
	MOVZWL	R6,R6			; Truncate length to a word
	CMPW	#MAXLGH,R6		; STRING TOO LONG?
	BLSSU	20$			; IF LSSU YES
	SUBL	#TBUF,SP		; ALLOCATE BUFFER ON STACK
	CLRL	R8			; CLEAR OUTPUT STRING COUNT
	MOVL	SP,R9			; POINT TO BUFFER
10$:					;
	BSBB	CNV_PARSTRNG		; NORMAL TIME SPECIFIED. PARSE STRING
	BSBW	RETURN_STRING		; RETURN STRING TO USER IF REQUESTED
	BLBC	R0,30$			; BRANCH IF SOME SORT OF ERROR
	MOVL	#CLI$_NORMAL,R2		; ASSUME SUCCESS
	MOVQ	R8,-(SP)		; PUSH DESCRIPTOR
	MOVL	SP,R0			; SAVE DESCRIPTOR ADDRESS
	$BINTIM_S	-		; CONVERT TIME TO BINARY
		TIMBUF=(R0),-		; ADDRESS OF TIME BUFFER
		TIMADR=@8(AP)		; ADDRESS OF QUADWORD RESULT
	BLBS	R0,20$			; IF LBS, SUCCESS
	MOVL	#CLI$_IVVALU,R2		; SET INVALID VALUE
20$:					;
	MOVL	R2,R0			; SET STATUS
30$:					;
	RET				;
 
	.DSABL	LSB

	.SBTTL	PARSE INPUT STRING
;+
; CNV_PARSTRNG - PARSE INPUT STRING
;
; THIS ROUTINE IS CALLED TO PARSE THE INPUT STRING.
;
; INPUTS:
;
;	R6,R7 = INPUT STRING DESCRIPTOR
;	R8,R9 = OUTPUT STRING DESCRIPTOR
;	R11 = ADDRESS OF STATE TABLES
;
; OUTPUTS:
;
;	R8,R9 = STRING DESCRIPTOR FOR PARSED STRING
;
; REGISTERS MODIFIED:
;
;	R0 - R11
;-
 
CNV_PARSTRNG:				;
	CLRL	R2			; CLEAR LENGTH OF PARSED STRING
	MOVL	R7,R3			; POINT TO START OF STRING
10$:					;
	MOVB	#EOS,R4			; ASSUME AT END OF STRING
	TSTW	R6			; AT END OF STRING?
	BEQL	20$			; IF EQL YES
	MOVB	(R7)+,R4		; GET CURRENT CHARACTER
	DECW	R6			; DECREMENT BYTES REMAINING
20$:					;
	LOCC	R4,#NTOKNS,TOKENS	; FIND TOKEN
	BNEQ	30$			; IF NEQ HAVE TOKEN
	INCW	R2			; INCREMENT LENGTH OF PARSED STRING
	BRB	10$			; GET NEXT CHARACTER
30$:					;
	MOVAB	-(R0),R10		; REMOVE BIAS, SAVE INDEX
	MOVAB	(R11)[R10],R1		; POINT TO FILL BYTE
	CMPB	(R1),#RESC		; RESCAN REQUIRED?
	BNEQ	35$			; IF NEQ NO
	ADDW	R2,R6			; BACK OUT STRING
	SUBL	R2,R7			; ...
	CMPB	R4,#EOS			; END OF STRING?
	BEQL	45$			; IF EQL YES
	DECL	R7			; BACK OUT TOKEN
	INCL	R6			; ...
	BRB	45$			;
35$:					;
	MOVW	R2,-(SP)		; SAVE LENGTH OF PARSED STRING
	BNEQ	40$			; IF NEQ STRING NOT NULL
	MOVL	R1,R3			; POINT TO FILL BYTE
	TSTB	(R3)			; NULL STRING?
	BEQL	40$			; IF EQL YES
	INCW	(SP)			; SET COUNT TO 1
40$:					;
	MOVZWL	(SP)+,R0		; Pick up length
	BEQL	45$			; Br if nothing
41$:	MOVZBL	(R3)+,R1		; Pick up next byte
	CMPB	R1,#^A'a'		; In lower case range?
	BLSSU	42$			; Br if not
	CMPB	R1,#^A'z'		; Test high end
	BGTRU	42$			; Br if not
	BICB2	#^X20,R1		; Convert to upper case
42$:	MOVB	R1,(R8)+[R9]		; Store in output buffer, bump count
	SOBGTR	R0,41$			; Loop for count
45$:					;
	MOVAL	NTOKNS(R11)[R10],R11	; POINT TO TOKEN LIST ENTRY
	CVTWL	TSTRING(R11),R0		; GET OFFSET TO STRING
	MOVAB	CNV_RELOC[R0],R0	; COMPUTE STRING ADDRESS
50$:					;
	MOVB	(R0)+,(R8)+[R9]		; SUBSTITUTE STRING FOR TOKEN
	BNEQ	50$			; GO AGAIN
	DECW	R8			; STRIP EOS
	CVTWL	NEXTSTATE(R11),R11	; POINT TO NEXT STATE
	BEQL	60$			; IF EQL, TERMINATE SCAN
	MOVAB	CNV_RELOC[R11],R11	; COMPUTE ADDRESS OF NEXT STATE
	BRW	CNV_PARSTRNG		; CONTINUE PARSE
60$:					;
	RSB				;

	.SBTTL	CNV_MNEM_DAY

;++
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE CONVERTS AN ASCII STRING REPRESENTING "YESTERDAY", "TODAY",
; OR "TOMORROW" INTO A FORM THAT IS ACCEPTABLE TO THE 'GET TIME' SYSTEM SERVICES.
;
; STRINGS ACCEPTED ARE THE FOLLOWING:
;
;	YESTERDAY
;	TODAY
;	TOMORROW
;
; ONLY THE FIRST FOUR CHARACTERS OF A STRING ARE READ. UNIQUE ABBREVIATIONS ARE
; ACCEPTED.
;
; INPUTS:
;
;	R6,R7	- INPUT STRING DESCRIPTOR
;	R8,R9	- OUTPUT STRING DESCRIPTOR
;	8(AP)	- ADDRESS IN WHICH TO PLACE ABSOLUTE BINARY TIME IN 64-BIT FORMAT
;
; OUTPUTS:
;
;	@8(AP)	- 64-BIT ABSOLUTE BINARY TIME
;	@12(AP)	- OUTPUT STRING DESCRIPTOR...STRING COPIED 
;
;	R0= LBS 1	- MATCH FOUND, CONVERSION SUCCEEDED.
;	R0= LBS 0	- MATCH NOT FOUND OR CONVERSION FAILED.
;
;	R0=CLI$_ABKEYW	- AMBIGUOUS KEYWORD
;
;	R0 MAY CONTAIN ERROR STATUS CODES FROM "GET TIME" SYSTEM SERVICES.
;
; REGISTERS MODIFIED
;
;	R0-R5, R10
;
;--


CNV_MNEM_DAY:
	MOVL	#4,R5			; DEFAULT LENGTH OF SUBSTRING
					; PATTERN TO MATCH.
	CMPB	R6,R5			; IS THE INPUT STRING SHORTER?
	BGTRU	10$			; IF NOT, USE DEFAULT LENGTH.
	MOVL	R6,R5			; IF SO, USE INPUT STRING LENGTH.

10$:	MOVL	(R7),-(SP)		; COPY FIRST FOUR LETTERS OF ASCII
	MOVL	SP,R10			; STRING ONTO STACK. LOAD STACK ADDRESS
					; INTO TEMPORARY REGISTER.
	BISB	#128,(R10)		; SET THE HIGH BIT IN THE BYTE
					; THAT HOLDS THE FIRST CHARACTER
					; OF THE INPUT STRING.
	BICL	#^X20202020,(R10)	; Convert lower to upper case.
	MATCHC	R5,(R10),#DAY_TBL_LEN,DAY_TABLE
					; LOOK FOR A SUBSTRING MATCH BETWEEN
					; THE INPUT STRING AND THE TABLE
					; OF KEYWORDS.
	BEQL	20$			; IF MATCH IS FOUND, CONTINUE.
	CLRL	R0			; OTHERWISE, SET ERROR STATUS CODE
	BRW	80$			; AND BRANCH TO RETURN CODE.

20$:	MOVL	R3,R4			; SAVE POSITION OF INPUT STRING
					; BYTE THAT FOLLOWS LAST MATCHING
					; CHARACTER.
	MATCHC	R5,(R10),R2,(R3)	; TEST FOR AMBIGUOUS KEYWORD.
	BNEQ	30$			; NO MATCH MEANS NO AMBIGUITY.
	MOVL	#CLI$_ABKEYW,R0		; MATCH MEANS KEYWORD IS AMBIGUOUS.
	BRW	80$			; RETURN WITH AN ERROR STATUS CODE.

30$:	DECL	R4			; DECREMENT POINTER SO THAT IT
					; POINTS TO THE LAST CHARACTER
					; IN THE SUBSTRING MATCH.
	MOVAB	DAY_TABLE,R0		; GET ADDRESS OF DAY TABLE
	SUBL2	R0,R4			; SUBTRACT THE ADDRESS OF THE
					; BEGINNING OF THE KEYWORD TABLE
					; FROM THIS CHARACTER'S ADDRESS.
	DIVL2	#4,R4			; COMPUTE INDEX OF THIS KEYWORD.
	MOVL	#SHORT_TIME_LEN,R8	; SETUP STRING DESCRIPTOR FOR A
					; BUFFER TO HOLD THE CURRENT TIME.
	MOVQ	R8,-(SP)		; ALLOCATE THE STRING DESCRIPTOR ON
					; THE STACK. SAY THAT THE LENGTH
					; OF THE BUFFER IS QUITE SHORT SO
					; THAT HOURS/MINUTES/SECONDS ARE
					; NOT RETURNED.
	MOVL	SP,R3			; LOAD ADDRESS OF THE STRING
					; DESCRIPTOR INTO A REGISTER SO
					; THAT IT CAN BE USED AS A SYSTEM
					; SERVICE CALL ARGUMENT.
	$ASCTIM_S -			; ASK SYSTEM FOR AN ASCII STRING
		TIMBUF=(R3)		; REPRESENTING THE CURRENT DAYTIME.
					; SPECIFY THE STRING DESCRIPTOR 
					; JUST MADE ON THE STACK.
	BLBC	R0,40$			; BRANCH ON ERROR RETURN.
	MOVQ	#^A/ 0:0:0.0/,SHORT_TIME_LEN(R9)
					; ADD MIDNIGHT TIME SPECIFICATION TO
					; TODAY'S DATE.
	ADDL2	#MIDNIGHT_LEN,(R3)	; NOW EXTEND THE BUFFER LENGTH
					; REPRESENTED IN THE STRING
					; DESCRIPTOR TO NEW STRING LENGTH.
	MOVL	8(AP),R2		; GET THE ADDRESS INTO WHICH THE
					; 64-BIT TIME VALUE IS TO BE RETURNED.
	$BINTIM_S -			; ASK SYSTEM FOR THE BINARY TIME
		TIMBUF=(R3),-		; EQUIVALENT OF THE ASCII TIME STRING.
		-			; SPECIFY AN INPUT BUFFER AND
		TIMADR=(R2)		; AN OUTPUT ADDRESS INTO WHICH THE
					; VALUE CAN BE WRITTEN.
	BLBC	R0,40$			; BRANCH ON ERROR.
	MULL2	#2,R4			; CONVERT THE INDEX INTO THE TIME
					; TABLE INTO A LONGWORD INDEX.
	ADDL2	TIME_TABLE[R4],(R2)+	; ADD THE TIME FACTOR FOR "YESTERDAY",
					; "TODAY", OR "TOMORROW" TO THE
	ADWC	TIME_TABLE+4[R4],(R2)	; 64-BIT BINARY TIME VALUE.
	CMPB	(AP),#3			; 3RD ARGUMENT PRESENT?
	BLSSU	60$			; BRANCH IF NOT
	MOVL	#FULL_TIME_LEN,(R3)	; ALLOW THE OUTPUT ASCII STRING TO

					; BE THE FULL SIZE OF THE OUTPUT BUFFER.
	$ASCTIM_S -			; THE ADJUSTED BINARY TIME VALUE BACK
		-			; TO AN ASCII STRING ONCE AGAIN.
		TIMBUF=(R3),-		; SPECIFY THE STRING DESCRIPTOR FOR
		-			; THE OUTPUT BUFFER
		TIMADR=@8(AP),-		; AND THE ADDRESS OF THE TIME VALUE.
		-			; OUTPUT BUFFER.
		TIMLEN=(R3)
	MOVQ	(R3),R8			; GET DESCRIPTOR OF OUTPUT STRING
	BLBS	R0,50$			; BRANCH ON SUCCESS.

					; ERROR HANDLING
40$:	CLRL	R8			; RESET LENGTH FIELD OF OUTPUT STRING
					; DESCRIPTOR BACK TO ZERO.
	BRB	70$			; BRANCH TO RETURN CODE.

50$:	BSBW	RETURN_STRING		; RETURN STRING TO CALLER
	BLBC	R0,70$			; BRANCH IF COPY ERROR

60$:	MOVL	#1,R0			; MOVE A SUCCESS INDICATOR INTO R0.

70$:	ADDL2	#8,SP			; RESTORE THE STACK TO ITS INITIAL
					; STATE.

80$:	ADDL2	#4,SP			; MORE STACK RESTORATION.
	RSB				; RETURN TO CALLER.

	.END
