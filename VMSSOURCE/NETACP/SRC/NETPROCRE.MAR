	.TITLE	NETPROCRE - Process creation
	.IDENT	'V04-000'
	.DEFAULT DISPLACEMENT,WORD
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;


;++
; FACILITY:	NETWORK ACP
;
; ABSTRACT:
;	THIS MODULE PERFORMS PROCESS CREATION FOR AN INBOUND CONNECT.
;
; ENVIRONMENT:
;	MODE = KERNEL
;
; AUTHOR:	SCOTT G. DAVIS, CREATION DATE: 10-AUG-77
;
; MODIFIED BY:
;
;	V03-024	ADE0039		Alan D. Eldridge	18-Jul-1984
;		When looking for a free XWB slot, don't allow either byte of
;		the local link number to be equal the character '"' since
;		that results in some non-intelligent NCB parsers to break.
;
;	V03-025	PRB0340		Paul Beck	18-Jul-1984  16:10
;		Test against LGI$_INVPWD for invalid access instead of magic number.
;
;	V03-024	ADE0038		Alan D. Eldridge	25-Jun-1984
;		Change SS$_NOLINKS to SS$_CONNECFAIL on problems finding
;		or creating logical-link resources.
;
;	V03-023	RNG0023		Rod Gamache		12-Jun-1984
;		Change calling conventions for calls to NODE COUNTER
;		BLOCK access routines.
;
;	V03-022	PRB0331		Paul Beck	1-May-1984  20:19
;		1.	Look for EPID instead of IPID in OBI$L_PID 
;		2.	Fix callers of NET$DELIVER_CI to set up R0 correctly.
;
;	V03-021	ADE0001		Alan D. Eldridge	11-Apr-1984
;		When comparing remote link addresses in NET$PROC_XWB, ignore
;		an address of zero.
;
;	V03-019	PRB0317		Paul Beck	8-Mar-1984  17:36
;		Force created network processes to use DCL as their default
;		CLI, independent of the default CLI for the specified account.
;		Fix bug in ADE0035.
;
;	V018	ADE0035		Alan D. Eldridge	14-Feb-1984
;		Create LLI entry when receive notification of a new XWB.
;
;	V017	RNG0017		Rod Gamache	 7-Feb-1984
;		Fix initialization of local storage in NET$DELIVER_CI routine.
;
;	V016	TMH0016		Tim Halvorsen	23-Jun-1983
;		Fix selection of waiting network processes so
;		that processes which were activated with different
;		default accounts (using default accounts on different
;		objects) are correctly selected.
;
;	V015	RNG0015		Rod Gamache	20-Apr-1983
;		Fix branch destinations out of range.
;
;	V014	TMH0014		Tim Halvorsen	03-Mar-1983
;		If requested object name starts with a "$", then use
;		a default filespec of SYS$SYSTEM (rather than SYS$LOGIN)
;		since objects with a "$" are reserved to DEC.
;		Allow STARTUP_OBJ to be called with an object name
;		as well as a number.
;		Notify new DLE module of process termination.
;
;	V013	TMH0013		Tim Halvorsen	14-Feb-1983
;		Remove node proxy access parameter.
;		Add support for EPIDs.
;		Return IPID of SPI database key in IOSB of DECLSERV QIO
;		to NETSERVER process.
;
;	V012	RNG0012		Rod Gamache	26-Jan-1983
;		Fix bug in NET$DELIVER_CI which doesn't check status
;		for success on call to memory allocation routine.
;
;	V011	TMH0011		Tim Halvorsen	28-Dec-1982
;		Add routine to break all links for a given process.
;		Do not store NCB, SFI or PNM into SPI until the link
;		is actually given to the process, and not when the
;		process is created.
;
;	V010	TMH0010		Tim Halvorsen	11-Nov-1982
;		Fix bug in NETSERVER startup, so that initial connects
;		which have been tagged for a certain process do not get
;		inadvertantly given to the another free server process
;		for which the logical link was not intended.
;
;	V009	TMH0009		Tim Halvorsen	09-Jul-1982
;		Make it possible for the network channel to be cleaned
;		up without any errors.
;		Add code to report mailbox messages of MSG$_RESET
;		to the Transport module, so that it can respond to
;		X.25 circuit resets during datalink startup.
;
;	V008	TMH0008		Tim Halvorsen	16-Jun-1982
;		Add an entry to the SPI database when creating a network
;		job, and remove it when we get the termination message.
;		Add code to transfer connect requests to waiting server
;		processes, in order to optimize server process creation.
;		Fix code in process termination to ignore the INHIB_MSG
;		bit in the final termination status, when making the
;		determination of whether the object procedure exists or not.
;		Do not cause a proxy login if the connect format type is
;		not a 2.  This prevents an 8 byte PID from being sent to
;		LOGIN for proxy logins.
;
;	V007	TMH0007		Tim Halvorsen	12-Apr-1982
;		Get address of utility buffer from cell, rather than
;		referencing a statically defined location.
;		Modify ACP mailbox dispatching to handle X.25 mailbox
;		messages, and dispatch them.
;		Fix a bug in mailbox dispatching, so that if the mailbox
;		read is canceled or aborted, then the QIO is re-issued.
;		Make default addressing word relative and remove explicit
;		addressing specifiers.
;
;	V03-06	ADE0035		A.Eldridge	11-Feb-1982
;		Move check for specific OBI proxy access state to allow objects
;		not in the database and with an object number zero to use the
;		proxy access specified for the TASK OBI.
;
;	V03-05	ADE0034		A.Eldridge	10-Feb-1982
;		Return error (instead of bug_check) if call to $CREMBX fails.
;
;	V03-04	ADE0033		A.Eldridge	18-Jan-1981
;		Fix bug in proxy login.  If the access control string received
;		in the connect message is non-null then don't allow proxy 
;		login.
;
;	V03-03	ADE0032		A.Eldridge	26-Dec-1981
;		Allow maximum task name of 12 characters in NCB.
;
;	V03-02	ADE0031		A.Eldridge	18-Dec-1981
;		Make sure that the NCB, the taskname, the process name, and
;		the access control strings passed to LOGINOUT, are properly 
;		uppercased.
;
;	V03-01	ADE0030		A.Eldridge	30-Nov-1981
;		Added proxy login (access) support.
;
;	V03-00	ADE0029		A.Eldridge	01-Nov-1981
;		General cleanup.
;
;	V02-17	TMH0017		Tim Halvorsen	04-Sep-1980
;		Accept SYS$NET parameter as input to NET$STARTUP_OBJ.
;
;	V2			A.Eldridge	01-Jan-1980
;		Rewritten for Phase III
;---

.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;
	$ACCDEF
	$AQBDEF
	$STSDEF
	$DRDEF
	$MSGDEF
	$PRVDEF
	$UCBDEF
	$IRPDEF
	$RCBDEF
	$LLIDEF
	$LTBDEF

	$CNFDEF
	$CNRDEF
	$NFBDEF
	$NMADEF
	$XWBDEF

	$WQEDEF

	$NETSYMDEF
	$NETUPDDEF
;
; MACROS:
;

;
; EQUATED SYMBOLS:
;

	CNF = CNF$C_LENGTH		; Short name for readability

STS_M_NOACNT	=   1@3			; Do not generate accounting records
STS_M_NOAUTH	=   1@6			; use caller's privs/quotas at login
STS_M_NETLOG	=   1@7			; bit no. for network login
MBX_MSG_LTH =       150			; size of a mailbox message
MAX_TASKNAM =        12			; Max size of taskname -- the name
					; following teh "=" in the NCB

	ASSUME	MBX_MSG_LTH GE ACC$K_TERMLEN

;
; OWN STORAGE:
;
	.PSECT	NET_IMPURE,WRT,NOEXE,LONG

		.ALIGN	LONG
NET_L_R0:				;
NET_L_FCT:	.LONG	0		; Function to pass to NETDRIVER
NET_L_R1:				;
NET_L_LPD:				; LPD of line which is starting
NET_L_PID:	.LONG	0		; PID to pass to NETDRIVER
NET_L_R2:				;
NET_L_REASON:	.LONG	0		; Disconnect reason
NET_L_R3:				;
NET_L_LNK:	.LONG	0		; Link number
NET_L_R4:				;
NET_A_NCB:	.BLKA	1		; For saving address of NCB buffer
NET_L_R5:				;
NET_L_UCB:	.LONG	0		; UCB address to pass to NETDRIVER

PTR_NCB_BUF:	.LONG	0		; Address of NCB buffer
PTR_CON_BUF:	.LONG	0		; Address of DELIVER_CI scratch buffer

NET_A_LLI:	.LONG	0		; Address of create LLI
NET_Q_NCB:	.QUAD	0		; NCB descriptor
NET_Q_PRC:	.QUAD	0		; Process descriptor
NET_Q_TSK:	.QUAD	0		; Name of file to run 
NET_Q_ACC:	.QUAD	0		; Descriptor for 3 account
					; strings preceded by flags word

DET_C_ACC = 5				; Buffer for access control strings
DET_AB_ACC:	.WORD	0		; for creating detached, privileged
		.BYTE	0		; processes.  It consists of a flags
		.BYTE	0		; Word followed by 3 null counted
		.BYTE	0		; strings.

OBI_B_PRX:	.BYTE	0		; OBI proxy access state
INT_B_PRX:	.BYTE	0		; Internal proxy access state.  This is
					; set to "none" if any conditions are
					; detected internally (other than the
					; values stored in the OBI or NDI) 
					; which would disallow proxy access
;
;   Fields used for termination mailbox creation, message buffering.  Be
;!  careful when modifying since some code assumes data ordering without
;!  using assumes.
;
		.ALIGN	LONG
MBX_CHAN:	.BLKW	1		; Channel number of mailbox
MBX_RDCNT:	.BLKW	1		; Number of reads posted to mailbox
MBX_IOSB:				; I/O status block
		.BLKW	1		;  -- status of i/o completion
MBX_LEN:	.BLKW	1		;  -- length of operation here
MBX_PID:	.BLKL	1		;  -- pid of process deleted
EXIT_MSG:				; Buffer for mailbox message
EXIT_ID:	.BLKW	1		;  -- message identification
		.BLKW	1		;  -- not used
NCB_DATA:				; On connect initiates
EXIT_CODE:	.BLKL	1		;  status of message
		.BLKB	MBX_MSG_LTH	; Leave room for message

NET$GQ_WQE_MBX::			; MBX read element
		.LONG	 .		; FLINK
		.LONG	 .-4		; BLINK
		.WORD	 WQE_MBX_LTH	; Length of entry
		.BYTE	 NET$C_DYN_WQE	; Structure type
		.BYTE	 WQE$C_SUB_MBX	; Sub-type is "MBX"
		.ADDRESS MBX_ACTION 	; Action routine address
		.LONG	 0		; AST parameter
		.LONG	 0		; "In-use" flag
WQE_MBX_LTH = .-NET$GQ_WQE_MBX
;
;  Buffer to get mailbox unit number for $CREPRC argument
;
BBUF:		.BLKL	3		; Device characteristics
MBX_UNIT:	.BLKW	1		; Unit number for CREPRC argument
ENDBUF:					; Truncate the rest !
ZNABUF:		.BLKB	MAX_TASKNAM+8	; Buffer for building ZNA 
					; the 8 includes 1 byte for the object
					; number and 7 bytes of slop



	.PSECT	NET_PURE,NOWRT,NOEXE,LONG


NET_Q_NETPREFIX:.ASCID	"NET"		; Prefix for unnamed tasks
NET_Q_TASKZNA:	.LONG	 5		; Length of TASK ZNA string
		.ADDRESS TASKZNA	; Its pointer
TASKZNA:	.BYTE 	 0		; Object type
		.ASCII	"TASK"		; Object name
EXIT_BUF:				; Descriptor for channel info
		.LONG	ENDBUF-BBUF	; Length of buffer
		.LONG	BBUF		; Address of buffer

NET$GQ_MBX_NAME::
		.ASCID	"NETACP$MBX"	; Logical name of mailbox
NET_Q_SYSTEM:
		.ASCID	"SYS$SYSTEM:"	; Prefix for reserved objects
NET_Q_IMAGE:
		.ASCID	"SYS$SYSTEM:DCL"  ; Login image
NET_Q_PROC:
		.ASCID	"SYS$SYSTEM:NETSERVER"	; Network server procedure
X25_DEV_NAME:
		.ASCID	"NWA"		; X.25 device name

	.PSECT	NET_CODE,NOWRT,LONG

.SBTTL	NET$PROC_XWB - Process returned XWB
;+
;
;  NETDRIVER has passed us an XWB either to be linked into the LTB and assigned
;  a local logical-link address (upon receiving an incoming connect) or to be
;  unhooked from the LTB and deallocated.
;
;  If both the XWB$W_REMLNK and XWB$W_LOCLNK fields are zero, then this request
;  comes from the NETACP code which handles the IO$_ACCESS request for Connect
;  initiates.
;
;  NETACP is responsible for the LTB maintenance and the XWB linkage in order to
;  avoid any race conditions it may have with NETDRIVER while scanning this list
;
;
;  INPUTS:	R3	XWB pointer
;
;  OUTPUTS:	All registers are clobbered
;
;-
	.SAVE_PSECT
	.PSECT	NET_LOCK_CODE,NOWRT,GBL	; Can't tolerate page faults
	.ENABL	LSB

NET$PROC_XWB::				; Process (deallocate) XWB
	MOVL	NET$GL_CNR_LLI,R11	; Pick up LLI CNR
	CLRL	R10			; No LLI CNF yet
	MOVL	XWB$L_VCB(R3),R2	; Get RCB
	MOVL	RCB$L_PTR_LTB(R2),R5	; Get LTB
	TSTW	XWB$W_LOCLNK(R3)	; Test local link number
	BNEQ	2$			; If NEQ, XWB being returned
	BRW	NEW_LINK		; If EQL, this is an incoming connect
2$:	;
	;
	;    Locate and Delete the LLI CNF.  Release hold on counter block
	;
	;
	MOVL	R3,R8			; Setup XWB address for search
	$SEARCH	eql,lli,l,xwb		; Find the corresponding LLI, if any
	BLBC	R0,10$			; If LBC, not found
					; 
	PUSHR	#^M<R2,R3,R4,R5>	; Save regs
	SUBL	#100,SP			;&Create dummy non-pageable buffer
	MOVL	SP,R6			; Point to dummy buffer
	MOVL	#1,R4			; Say "zero XWB counters"
	MOVL	R3,R5			; XWB ptr for subr call
	BSBW	NET$FLUSH_LLI_CNT	; Flush LLI and XWB counters to node
					; counter block
	ADDL	#100,SP			;&Release stack space
	POPR	#^M<R2,R3,R4,R5>	; Restore regs
					;
	CLRL	R8			; Nullify pointer
	BSBW	CNF$PUT_FIELD		; Erase the XWB pointer
	BSBW	CNF$DELETE		; Mark the entry for deletion
	BSBW	CNF$PURGE		; Purge the entry from the database
	CLRL	R10			; Forget about the LLI, its gone
	BSBW	NET$RELEASE_NDCOU	; Release hold on counter block
10$:	;
	;
	;    This is an old XWB coming back to be removed and deallocated
	;
	;
	MOVZWL	XWB$W_LOCLNK(R3),R0	; Get link number
	BICW	#^C<NET$C_MAXLNK>,R0	; Clear all but 'index' bits
	MOVAL	LTB$L_SLOTS(R5)[R0],R0	; Get link slot
	CMPL	(R0),R3			; Does address match ?
	BNEQ	200$			; If NEQ, bug
	DSBINT	#NET$C_IPL		; Synchronize with NETDRIVER
					;
	MOVW	#1,(R0)+		; Set 'available' flag
	MOVW	XWB$W_LOCLNK(R3),(R0)	; Store last used link address
	MOVAB	-XWB$L_LINK -		;
		+LTB$L_XWB(R5),R1 	; Init for scan
20$:	MOVL	R1,R0			; Save a copy
	MOVL	XWB$L_LINK(R1),R1	; Travel list
	CMPL	R1,R3			; Is this it ?
	BNEQ	20$			; If not, branch
	MOVL	XWB$L_LINK(R3),-	; Remove it from list
		XWB$L_LINK(R0)		;
					;
	ENBINT				; Restore IPL
					;
DEAL_XWB:				; Deallocate XWB
	BSBW	NET$DECR_MCOUNT		; Account for link now gone
	MOVL	R3,R0			; Get block address for call
	BSBW	NET$DEALLOCATE		; Deallocate the block
	RSB

200$:	BUG_CHECK NETNOSTATE,FATAL	; Else, bad slot address

		.DSABL	LSB


NEW_LINK:				; Insert new XWB into LTB
	;
	;
	;    Find a free slot in the link table (LTB).  Start from where we left
	;    off last time in order to avoid using the same slots over and over
	;    again.  This technique increases the interval between re-use of a
	;    logical-link number -- i.e., sequence number, slot number.
	;
	;    Don't allow either byte of the local link number to equal '"' since
	;    some non-intelligent NCB parsers mistake that for the end of the
	;    NCB.
	;
	;    The slot vector terminates with a -1 (longword) followed by a
	;    0 (longword).
	;
	;
	MOVZWL #SS$_CONNECFAIL,R0	; Assume failure
	MOVL	LTB$L_SLT_NXT(R5),R4	; Get first slot candidate ptr
5$:	BLBC	(R4)+,5$		; LBC means unavailable
	CMPL	-(R4),#-1		; Backup and test for end of
	BNEQ	10$			; NEQ means slot found
	MOVAL	LTB$L_SLOTS(R5),R4	; Start from top of vector
7$:	BLBC	(R4)+,7$		; LBC means unavailable
	CMPL	-(R4),#-1		; Backup and test for end of
	BEQL	200$			; EQL means slot not found
8$:	ADDW	#NET$C_MAXLNK+1,2(R4)	; Update local link seq #
	CMPB	2(R4),#^A'"'		; Is low byte a double quote?
	BEQL	7$			; If EQL yes, keep scanning
	CMPB	3(R4),#^A'"'		; Is high byte a double quote ?
	BEQL	8$			; If EQL, bump the seq # and try again
10$:	;
	;
	;    Find position in XWB list.  At the same time, see if this is a
	;    duplicate by matching the remote node address (the remote link 
	;    number has not been assigned yet if this is a Connect Initiate).
	;    If its a duplicate, simply deallocate the XWB.
	;
	;
	MOVAB	-XWB$L_LINK -		;
		+LTB$L_XWB(R5),R0	; Init for scan
30$:	MOVL	R0,R1			; Remember last entry
	MOVL	XWB$L_LINK(R0),R0	; Go to next entry
	BEQL	50$			; If EQL, at end of list
	CMPW	XWB$W_REMNOD(R3),-	; Are we going too far ?
		XWB$W_REMNOD(R0)	; 
	BGTRU	50$			; If GTRU yes, stop here
	CMPW	XWB$W_REMLNK(R3),-	; Is this it ?
		XWB$W_REMLNK(R0)	;
	BNEQ	30$			; If NEQ no, continue searching
	TSTW	XWB$W_REMLNK(R3)	; But, if =0 then no address has been
	BEQL	30$			; assigned; comparison was invalid
	BRB	DEAL_XWB		; ...else duplicate connect
50$:	;
	;
	;    LTB slot and place in XWB list have been found.  Link XWB into the
	;    LTB and setup local link number.
	;
	;
	DSBINT #NET$C_IPL		; Synch with NETDRIVER
					;
	BICW   #XWB$M_STS_SOL,-		;
		XWB$W_STS(R3) 		; No longer queued
	MOVW	2(R4),XWB$W_LOCLNK(R3)	; Setup local link number
	MOVL	R3,(R4)+		; Store XWB ptr in this slot
	MOVL	R4,LTB$L_SLT_NXT(R5)	; Store scan's next starting pt.
	MOVL	R0,XWB$L_LINK(R3)	; Link tail of list to current XWB
	MOVL	R3,XWB$L_LINK(R1)	; Link XWB to head of list
					;
	ENBINT				; Restore IPL
					;
	BSBW	CREATE_LLI		; Create LLI and insert it into database
					; Use status as input to NET$DELIVER_CI
	TSTW	XWB$W_REMLNK(R3)	; Connect Initiate ?
	BEQL	100$			; If EQL yes, return R0 to caller
	MOVL	R3,R6			; Else, copy XWB address
	BSBW	NET$DELIVER_CI		; Create LLI, and deliver connect
					; notification to some server
	MOVL	#1,R0			; Say "success"
100$:	RSB				; Done

200$:	BUG_CHECK  NETNOSTATE,FATAL

	.RESTORE_PSECT


CREATE_LLI:				; Create LLI and insert it into the list
	;
	;   This subroutine in required so that the  "utility buffer"  acquired 
	;   by the NET$GETUTLBUF co-routine will be released in a timely manner.
	;   
	;  NOTE - the NET$ACQUIRE_NDCOU routine needs the utility buffer, so
	;   we must not allocate the utility buffer until after we acquire the
	;   NDC counter block.
	;
	BSBW	NET$ACQUIRE_NDCOU	; Inc. reference level of counter block
	BLBC	R0,90$			; If LBC, problem encountered
	BSBW	NET$GETUTLBUF		; Get permission to use utility buffer
					; - the above is a co-routine call
	MOVL	NET$GL_CNR_LLI,R11	; Pick up CNR
	BSBW	CNF$INIT_UTL		; Init "utility buffer" as a CNF
	MOVL	R3,R8			; Get XWB
	$PUTFLD	lli,l,xwb		; ...Store it in LLI
					;
	PUSHR	#^M<R2,R3,R4,R5,R6>	; Save registers
	MOVAB	CNF+LLI$Z_NDC_RT(R10),R6; Point to 'running total' counters
	MOVC5	#0,(SP),#0,#NDC$C_LENGTH,(R6) ; Zero the counters
	MOVAB	CNF+LLI$Z_NDC_LZ(R10),R6; Point to 'last zeroed' counters
	MOVC5	#0,(SP),#0,#NDC$C_LENGTH,(R6) ; Zero the counters
	CLRL	R6			; No "old" CNF
	BSBW	CNF$INSERT		; Try to put block into list
	POPR	#^M<R2,R3,R4,R5,R6>	; Restore registers
					;
	BLBS	R0,100$			; If LBS, okay
	BSBW	NET$RELEASE_NDCOU	; Else, dec. reference to counter block
90$:	MOVZWL	#SS$_CONNECFAIL,R0	; Return general purpose error status
100$:	RSB				; Release utility buffer, return status


.SBTTL	NET$CREATE_MBX	- Create ACP mailbox
.SBTTL	NET$KILL_MBX	- Delete ACP mailbox
.SBTTL	NET$MBX_QIO	- Issue mailbox read
;++
;
;
; *** TBS ***
;
;--
NET$CREATE_MBX::
	CLRW	MBX_RDCNT		; Init oustanding mailbox read count
	$CREMBX_S -			; Create mailbox
	    CHAN   = MBX_CHAN,-
	    MAXMSG = #MBX_MSG_LTH,-
	    BUFQUO = #<MBX_MSG_LTH*16>,-
	    LOGNAM = NET$GQ_MBX_NAME,-	; mailbox's logical name
	    PROMSK = #0
	BLBC	R0,10$			; Br if error
	$GETCHN_S -			; Get mailbox unit number
	    CHAN   = MBX_CHAN,-
	    PRIBUF = EXIT_BUF
10$:	RSB				; Return status in R0



NET$KILL_MBX::				; Delete channel to mailbox
	$DASSGN_S  CHAN = MBX_CHAN	; do it
	RSB


NET$MBX_QIO::					; Post read to mailbox
;
;  
;  This routine puts a read out on the mailbox for process termination and 
;  inbound connect notifications.
;
;
	$QIO_S  CHAN	= MBX_CHAN,-
		FUNC	= S^#IO$_READVBLK,-
		EFN	= #NET$C_EFN_ASYN,-
		ASTADR	= NET$SET_MBX_AST,-
		IOSB	= MBX_IOSB,-
		P1	= EXIT_MSG,-
		P2	= #MBX_MSG_LTH
	BLBS	R0,10$				; Br unless error
	BUG_CHECK	ACPMBFAIL,FATAL		;!arrgh
10$:	RSB					; return

.SBTTL	NET$SET_MBX_AST	- Process mailbox AST
;++
;
;
;--
NET$SET_MBX_AST::
	.WORD	^M<R2,R3,R4,R5>

	MOVAB	NET$GQ_WQE_MBX,R0	; Get base of mailbox WQE
	TSTL	WQE$L_PM2(R0)		; Is it active ?
	BNEQ	10$			; If NEQ then active, there's a bug
	MOVL	4(AP),WQE$L_PM1(R0)	; Get the AST parameter
	MNEGL	#1,WQE$L_PM2(R0)	; Mark WQE busy
	BSBW	WQE$INSQUE		; Queue the WQE
	RET				; Done

10$:	BUG_CHECK  NETNOSTATE,FATAL	; Signal the bug

MBX_ACTION:				; Enter upon WQE dispatch
	CLRL	WQE$L_PM2(R5)		; Mark WQE idle
	CALLS	#0,B^NET$MBX_AST	; Call the mailbox processor
	RSB
;+
;
; NET$MBX_AST - THIS ROUTINE SERVICES PROCESS TERMINATIONS
;		AND INBOUND CONNECT NOTIFICATIONS
;
;-
NET$MBX_AST::	.WORD	0		; Entry point
	CMPW	MBX_IOSB,S^#SS$_ABORT	; Was the i/o cancelled?
	BEQL	5$			; If so, assume mailbox going away
	CMPW	MBX_IOSB,#SS$_CANCEL	; Try this code, too
	BEQL	5$			; If NEQ proceed
	BSBB	10$			; Dispatch
	BSBW	NET$MBX_QIO		; Put out another read
5$:	RET				; Done
	;
	;   Dispatch
	;
10$:	MOVL	MBX_PID,R0		; Get EPID returned by MBX driver
	JSB	G^EXE$EPID_TO_IPID	; Convert to internal PID
	MOVL	R0,MBX_PID		; Use the IPID for later processing
	MOVL	NET$GL_NET_UCB,R6	; Point to our NET channel's UCB
	MOVAB	EXIT_ID,R11		; Get address of mbx message
	MOVW	(R11)+,R6		; Get message type
	MOVW	(R11)+,R9		; Get unit number
	MOVZBL	(R11)+,R10		; Get device name count value
	CMPC5	R10,(R11),#0,-		; X.25 mailbox message?
		X25_DEV_NAME,@X25_DEV_NAME+4
	BEQL	20$			; Branch if so
	ADDL	R10,R11			; Get pointer to mbx "data"
	$DISPATCH  TYPE=W,R6,-		; Dispatch on mailbox msg type
	<-
	  <MSG$_DELPROC,  DELPROC>,-	   ; Process termination
	  <MSG$_CONNECT,  CONNECT>,-	   ; Inbound connect
	  <MSG$_PATHLOST, NET$DRV_CANCEL>,-; I/O channel cancelled
	>
	RSB				; Ignore the message

;
;   Dispatch on X.25 mailbox message
;
20$:	MOVAB	EXIT_ID+20,R11		; Point to "data"
	MOVZWL	MBX_LEN,R10		; Get length of mailbox message
	SUBL	#20,R10			; Subtract out overhead
	$DISPATCH  TYPE=W,R6,-		; Dispatch on mailbox msg type
	<-
	  <MSG$_CONNECT,  NET$DLL_X25_CALL>,-	; Incoming X.25 call
	  <MSG$_RESET,	  NET$DLL_X25_RESET>,-	; X.25 circuit reset
	>
	RSB				; Ignore the message

;
;  Connect initiate message received
;
;
;	The mailbox data consists of the address of the NETDRIVER update 
;	routine and the address of the XWB. 
;
CONNECT:
	MOVL	4(R11),R6		; Get XWB address
	MOVL	#1,R0			; "Success" flag to NET$DELIVER_CI
	BSBW	NET$DELIVER_CI		; Deliver the inbound connect to a user
	RSB

;
;  Handle network process termination
;
DELPROC:
	;
	;  Notify netdriver of process exit
	;
	MOVL	#NET$C_DR_NOBJ,R2		; Assume can't find .com file
	CLRBIT	#STS$V_INHIB_MSG,EXIT_CODE	; Ignore INHIB_MSG flag
	CMPL	#RMS$_FNF,EXIT_CODE		; file-not-found?
	BEQL	35$				; if EQL yes
	MOVL	#NET$C_DR_EXIT,R2		; assume just an exit
	CMPL	#LGI$_INVPWD,EXIT_CODE		; was it an access problem?
	BNEQ	35$				; if NEQ, no
	MOVL	#NET$C_DR_ACCESS,R2		; say so
35$:	MOVL	MBX_PID,R1			; PID of exiting process
	BSBW	NET$SERVER_FAIL			; Notify NETSERVER server gone
	;
	;   Remove the process from the SPI database
	;
	MOVL	NET$GL_CNR_SPI,R11		; Get root of SPI database
	CLRL	R10				; Start at beginning of list
	MOVL	MBX_PID,R8			; Get process PID
	$SEARCH	eql,spi,l,pid			; Find database entry
	BLBC	R0,50$				; Branch if not found
	$GETFLD	spi,l,irp			; Waiting DECLSERV IRP?
	BLBC	R0,40$				; Branch if no IRP waiting
	BUG_CHECK NETNOSTATE,FATAL		; Should never have IRP
						; waiting, if process deleted
40$:	BSBW	CNF$DELETE			; Mark the CNF entry deleted
	BSBW	CNF$PURGE			; Delete all marked CNFs
50$:	;
	;   Notify DLE module of process termination.
	;
	MOVL	MBX_PID,R8			; Setup the PID
	BSBW	DLE$PRC_EXIT			; Inform DLE of process exit
	RSB

.SBTTL	NET$CONNECT_FAIL - Notify NETDRIVER of failed link
;+
;
; An attempt to confirm a logical link has failed.  Notify NETDRIVER so that
; it can verify the user's access to the link and then notify the remote end of
; the link that the link is being broken and why.
;
;
; INPUTS:	R3	Local logical link number (0 implies connect initiate)
;		R2	Reason code to be sent in the disconnect message
;		R1	User's PID
;
; OUTPUTS:	R5-R0	Clobbered
;
;		All other registers are preserved
;
;-
NET$CONNECT_FAIL::				; A connect attempt has failed
	MOVL	NET$GL_NET_UCB,NET_L_UCB	; Use the ACP's UCB
	MOVZWL	R3,NET_L_LNK			; Specify link number
	BEQL	10$				; If EQL then connect initiate
	MOVL	R2,NET_L_REASON			; Specify disconnect reason
	MOVL	R1,NET_L_PID			; Specify user's PID
	MOVL	#NETUPD$_ABORT,NET_L_FCT	; Specify "link terminated"
	BSBW	TELL_DRV			; Notify NETDRIVER
10$:	RSB

.SBTTL	NET$SERVER_FAIL	- Notify NETDRIVER of terminated server
;+
;
; A server process (or NETSERVER session) has terminated.  Notify NETDRIVER so
; that it can break all links that might still be pending for that process.
; This handles the case where the process was unable to confirm the link due
; to some error.
;
;
; INPUTS:	R2	Reason code to be sent in the disconnect message
;		R1	User's PID
;
; OUTPUTS:	R5-R0	Clobbered
;
;		All other registers are preserved
;
;-
NET$SERVER_FAIL::				; A server has terminated
	MOVL	NET$GL_NET_UCB,NET_L_UCB	; Use the ACP's UCB
	MOVL	R2,NET_L_REASON			; Specify disconnect reason
	MOVL	R1,NET_L_PID			; Specify user's PID
	MOVL	#NETUPD$_EXIT,NET_L_FCT		; Specity "process exit"
	BSBW	TELL_DRV			; Notify NETDRIVER
	RSB

.SBTTL	NET$SCAN_FOR_ZNA - Send pending connects to declared object
;+
;
; This routine is called when a task name or object is declared by a user.
; The function is to scan the XWB list for links in the Connect Initiate
; state which are intended for the object with the specified ZNA and to build
; a NCB which is given to NETDRIVER to be put in the declared name's mailbox.
;
; INPUTS:	R7,R8 = Descriptor of object ZNA being declared
;
; OUTPUTS:	None
;
;-
NET$SCAN_FOR_ZNA::			; Find unclaimed XWBs which match ZNA
	MOVQ	R7,R9			; Make copy of ZNA descriptor
	MOVL	NET$GL_PTR_VCB,R6	; Get RCB pointer
	MOVL	RCB$L_PTR_LTB(R6),R6	; Get LTB pointer
	MOVAB	LTB$L_SLOTS+4(R6),R5	; Point to first XWB (skip slot 0)
10$:	BLBS	(R5)+,10$		; If LBS then pointer is invalid
	MOVL	-4(R5),R6		; Get the XWB address
	BEQL	30$			; If EQL then done
	CMPB	#XWB$C_STA_CIR,-	; In connect initiate state?
		    XWB$B_STA(R6)	;
	BNEQ	10$			; If NEQ then keep looking
	MOVAB	XWB$T_LPRNAM(R6),R1	; Setup for subroutine call
	PUSHR	#^M<R5,R6,R9,R10>	; Save important regs
	BSBW	GET_PR_ZNA		; Get ZNA string from LRPNAM
	BLBC	R0,20$			; If LBC then field is not valid
	CMPC5	R7,(R8),#0,R9,(R10)	; Are they the same?
	BNEQ	20$			; If NEQ keep looking
	MOVL	#1,R0			; "Success" flag to NET$DELIVER_CI
	BSBW	NET$DELIVER_CI		; Build NCB, pass to user in mailbox
20$:	POPR	#^M<R5,R6,R9,R10>	; Restore regs
	BRB	10$			; Keep looking
30$:	RSB				; Done

.SBTTL	NET$RESEND_SERVER - Re-send initial connect to server
;+
;
; This routine is called when a server process declares that it is waiting
; for an incoming connect.  The XWB list is scanned for links in the CI
; state looking to see if the initial connect which started the process
; is still pending.  If so, then re-send the NCB to the server process
; so that it will be executed.
;
; INPUTS:	R8 = PID of server process
;
; OUTPUTS:	None
;
;-
NET$RESEND_SERVER::			; Find unclaimed XWBs for server process
	MOVL	NET$GL_PTR_VCB,R6	; Get RCB pointer
	MOVL	RCB$L_PTR_LTB(R6),R6	; Get LTB pointer
	MOVAB	LTB$L_SLOTS+4(R6),R5	; Point to first XWB (skip slot 0)
10$:	BLBS	(R5)+,10$		; If LBS then pointer is invalid
	MOVL	-4(R5),R6		; Get the XWB address
	BEQL	30$			; If EQL then done
	CMPB	#XWB$C_STA_CIR,-	; In connect initiate state?
		    XWB$B_STA(R6)	;
	BNEQ	10$			; If NEQ then keep looking
	CMPL	R8,XWB$L_PID(R6)	; Intended for this process?
	BNEQ	10$			; If NEQ keep looking
	PUSHR	#^M<R5,R6,R8>		; Save registers
	MOVL	#1,R0			; "Success" flag to NET$DELIVER_CI
	BSBW	NET$DELIVER_CI		; Build NCB, satisfy DECLSERV request
	POPR	#^M<R5,R6,R8>		; Restore registers
	BRB	10$			; Keep looking
30$:	RSB				; Done

.SBTTL	NET$STARTUP_OBJ	    - Startup privileged process	
.SBTTL	NET$STARTUP_OBJ_NAM - Startup process by name
;+
;
; Startup a privileged object process if it is not already running.  This is
; used to create EVL for event logging and NML for down-line loading or 
; up-line dumping.
;
; Inputs:
;
;	R8    = Object number to start (If NET$STARTUP_OBJ)
;	R7/R8 = Object name to start (If NET$STARTUP_OBJ_NAM)
;
;	R2,R3 = Descriptor of string to be passed as SYS$NET to process
;	R4,R5 = Descriptor of string to be used as process name
;		If =0 then use the object's name as the process name
;
; Outputs:
;
;	R1   PID if process has been created
;	R0   Status
;-
	.ENABL	LSB

NET$STARTUP_OBJ_NAM::
	PUSHR	#^M<R7,R8,R9,R10,R11>	; Save registers
	MOVL	NET$GL_CNR_OBI,R11	; Point to OBI database
	CLRL	R10			; and start at beginning of list
	$SEARCH	eql,obi,l,nam		; Search for specified object
	BRB	1$			; Join common code

NET$STARTUP_OBJ::			; Startup privileged process
	PUSHR	#^M<R7,R8,R9,R10,R11>	; Save registers
	MOVL	NET$GL_CNR_OBI,R11	; Point to OBI database
	CLRL	R10			; and start at beginning of list
	$SEARCH	eql,obi,l,num		; Search for specified object
1$:	CLRL	R1			; Clear PID
	MOVQ	R2,NET_Q_NCB		; Store descriptor of SYS$NET string
	BLBC	R0,2$			; Skip if not defined as object
	;
	;  If object has already declared itself, then it is running
	;
	$GETFLD	obi,l,ucb		; If UCB NE 0, it has declared itself
	BLBS	R0,2$			; If declared, then its already running
	;
	;  If not, get the access control string and process name
	;
	$GETFLD	obi,s,sfi		; Get the process file name
	BLBS	R0,5$			; Skip if specified
2$:	BRW	80$			; Return with status in R0
5$:	MOVQ	R7,NET_Q_TSK		; Save the descriptor
	MOVQ	R4,NET_Q_PRC		; Setup process name
	BNEQ	10$			; If NEQ then name is non-null
	$GETFLD	obi,s,nam		; Else get object name
	MOVQ	R7,NET_Q_PRC		; Use as process name
10$:	MOVL	#DET_C_ACC,NET_Q_ACC	; Setup descriptor of access control
	MOVAB	DET_AB_ACC,NET_Q_ACC+4	; data used for create detached,
					; privileged processes.
	;
	;  Start the process with privileges
	;
	$CREPRC_S	-		; create a process
	    INPUT  = NET_Q_TSK,-	; Network .COM filename
	    OUTPUT = NET_Q_ACC,-	; Network access control string
	    ERROR  = NET_Q_NCB,-	; SYS$NET logical name string
	    PRCNAM = NET_Q_PRC,-	; Process name
	    IMAGE  = NET_Q_IMAGE,-	; Image (LOGINOUT) to run first
	    PIDADR = NET_L_PID,-	; Place to store process id
	    MBXUNT = MBX_UNIT,-		; MBX for termination
	    BASPRI = G^SYS$GB_DEFPRI,-	; Priority
	    UIC    = #<^O1@16+^O4>,-	; UIC is [1,4]
	    STSFLG = <#STS_M_NETLOG!-	; Network login parameters (IN,OUT,ERR)
		       STS_M_NOAUTH!-	; Use caller's privs/quotas/etc.
		       STS_M_NOACNT>	; Do not add any accounting records
	BLBC	R0,80$			; If LBC then failed
	MOVL	NET_L_PID,R0		; Get the EPID returned by CREPRC
	JSB	G^EXE$EPID_TO_IPID	; Convert to internal PID format
	MOVL	R0,NET_L_PID		; Use internal format of PID
	MOVL	NET_L_PID,R1		; Return the PID to caller
	MOVL	S^#SS$_NORMAL,R0	; Success
80$:	POPR	#^M<R7,R8,R9,R10,R11>	; Restore registers
	RSB

	.DSABL	LSB

.SBTTL	NET$DELIVER_CI	- Process and Deliver Inbound Connect
;++
;
;  A non-zero destination object number indicates that NETACP must fetch the 
;  name of the .COM file from the OBJ block - using 'SYS$SYSROOT:[SYSEXE]' as
;  the default directory.  A zero destination object number indicates that the 
;  .COM file name is the same as the destination taskname - the default login 
;  directory account is assumed to contain the taskname.COM. 
;
;	\update this to include tasks with a file i.d.\;!
;
;  If the incoming USER,PSW,ACCT strings are all null, then the default 
;  inbound access control for the specified object (or task) are used (these
;  strings may also be null).  This allows a DECnet-VAX node to serve as a 
;  convenient host particularly for RSX-11S. 
;
;  This routines determines whether the connect is to be handed to a task
;  which has declared a name or an object type.
;
;
;  INPUTS:	R11	LLI CNR address (if low bit set in R0)
;		R10	LLI CNF address (if low bit set in R0)
;		R6	XWB address 
;		R0	Low bit set    =>  deliver connect notification
;			Low bit clear  =>  tell NETDRIVER that resource error
;					   occurred
;
;  OUTPUTS:	R11,R10,R6 are preserved.
;
;		All other registers are clobbered.
;
;
; SIDE EFFECTS:	Process created if needed, image started
;
;--

;
; Define scratch storage
;

ACC =  12				; Composite access strings
PRC = 200				; Process name
TSK = 300				; Image to run
CONN_SPACE = 1000			; Size of scratch storage

NET$DELIVER_CI:
	CLRL	PTR_NCB_BUF		; No NCB buffer yet
	CLRL	PTR_CON_BUF		; No scratch buffer yet
	;
	;   Initialize parameters for call to NETDRIVER
	;
	MOVZWL	XWB$W_LOCLNK(R6),NET_L_LNK	; Setup logical link address
	MOVZBL	#NETUPD$_ABORT,  NET_L_FCT	; Assume process couldn't start
	MOVL	NET$GL_NET_UCB,  NET_L_UCB	; Default is our UCB
	MOVL	R10,	         NET_A_LLI	; Save LLI pointer
	CLRL			 NET_L_PID	; No PID yet
	CLRL			 NET_A_NCB	; No NCB yet
	;
	;
	;
	BLBC	R0,3$			; If LBC, resource error encountered
					; by caller
	MOVZWL	#CONN_SPACE,R1		; Set size of scratch buffer
	BSBW	NET$ALLOCATE		; Allocate a scratch buffer
	BLBC	R0,3$			; Br if allocation failure, notify
					;  driver
	MOVL	R2,PTR_CON_BUF		; Save address for deallocation
	;
	;    Initialize descriptors and data for process creation
	;
	MOVAB	ACC(R2),R3		; Get ACC address
	MOVL	R3,NET_Q_ACC+4		; Store it
	MNEGL	R3,NET_Q_ACC		; Bias ACC size
	MOVAB	PRC(R2),R3		; Get PRC address
	MOVL	R3,NET_Q_PRC+4		; Store it
	MNEGL	R3,NET_Q_PRC		; Bias PRC size
	MOVAB	TSK(R2),R3		; Get TSK address
	MOVL	R3,NET_Q_TSK+4		; Store it
	MNEGL	R3,NET_Q_TSK		; Bias TSK size
	;
	;    Set default values
	;
	MOVL	NET$GL_PTR_VCB,R0		; Point to RCB
	MOVB	RCB$B_ECL_DPX(R0),OBI_B_PRX	; Set default OBI proxy access
	MOVB	#NMA$C_ACES_BOTH, INT_B_PRX	; Set default internal proxy
						; access state
	;
	;    Allocate scratch buffer from nonpaged pool for NCB
	;
	MOVZWL	#NET$C_MAX_NCB+13,R1		; Length of buffer for an NCB
	BSBW	NET$ALONPAGED			; Allocate the buffer
	BLBS	R0,5$				; If LBS then block allocated
	;
	;   Tell NETDRIVER about resource error
	;
3$:	MOVZBL	#NET$C_DR_RSU,NET_L_REASON	; Reason is "resource error"
	MOVL	NET$GL_PTR_VCB,R0		; Get RCB pointer
	BUMP	W,RCB$W_CNT_XRE(R0)		; Account for resource error
	BRB	10$				; Continue
	;
	;  Build the NCB and locate the process to accept it 
	;
5$:	MOVL	R2,PTR_NCB_BUF			; Save for deallocation
	MOVAB	13(R2),R3			; Get address of string, leave
						; room for count and buf header
	MOVL	R3,NET_Q_NCB+4			; Store it
	MNEGL	R3,NET_Q_NCB			; Bias NCB size
	BSBW	BUILD_NCB			; Build the NCB
	BLBC	R0,10$				; If LBC then error
	CMPL	NET_Q_NCB,#NET$C_MAX_NCB	; Make sure we didn't write
						; past end of buffer
	ASSUME	NET$C_MAX_NCB  LE  255		; Must allow counted string fmt
	MOVL	NET_Q_NCB+4,R0			; Get ptr to NCB
	MOVB	NET_Q_NCB,-(R0)			; Enter count field and 
	MOVL	R0,NET_A_NCB			; save its address in case NCB
						; is to be passed to NETDRIVER
						; for a declared name
	BSBW	GET_PROC			; Find/create process to
						; receive the connect
10$:	BSBW	TELL_DRV			; Tell driver about connect
	MOVL	PTR_NCB_BUF,R0			; Address of buffer
	BSBW	NET$DEALLOCATE			; Deallocate the buffer
	MOVL	PTR_CON_BUF,R0			; Address of scratch buffer
	BSBW	NET$DEALLOCATE			; Deallocate scratch storage
	RSB					; Done


.SBTTL	BUILD_NCB	- Build NCB for incoming connect
;+
;
; This routine builds the NCB string for the connect, to be later
; given to the destination process (in any number of different ways).
;
; Inputs:
;
;	R6 = XWB address
;	NET_Q_NCB = Descriptor of scratch space for NCB
;
; Outputs:
;
;	R0 = status code
;	NET_Q_NCB = Descriptor of resultant NCB
;-
BUILD_NCB:				; Build the NCB
	;
	;    Enter 'nodename::'
	;
	MOVL	NET_Q_NCB+4,R3		; Get output buffer pointer
	MOVL	NET$GL_CNR_NDI,R11	; Get root for search
	CLRL	R10			; Indicate no NDI yet
	MOVZWL	XWB$W_REMNOD(R6),R8	; Get remote node address
	$SEARCH	eql,ndi,l,tad		; Find NDI with matching address
	BLBC	R0,10$			; If LBC none, use node address
	$GETFLD	ndi,s,nna		; Get the node name
	BLBC	R0,10$			; Invalid if LBC
	TSTB	R7			; Is name null ?
	BEQL	10$			; If EQL use node address
	;
	;    Enter ASCII nodename
	;
	MOVC3	R7,(R8),(R3)		; Move node name
	BRB	20$
	;
	;    Enter node address converted to ASCII
	;
10$:	MOVZWL	XWB$W_REMNOD(R6),R0	; Get node address
	BSBW	NET$BIN2ASC		; Move after conversion to ASCII
20$:	MOVW	#^A'::',(R3)+		; Move delimiter
	;
	;    Enter taskname
	;
	MOVB	#^A'"',(R3)+		; Enter delimiter
	MOVZBL	XWB$T_RPRNAM+1(R6),R0	; Get object number
	BEQL	30$			; If EQL then use taskname
	BSBW	NET$BIN2ASC		; Else convert to ASCII and move
	MOVB	#^A'=',(R3)+		; Enter delimiter
	BRB	50$			; Continue
	;
	;    Enter 0=taskname
	;
30$:	MOVW	#^A'0=',(R3)+		; Enter 0=
	MOVAB	XWB$T_RPRNAM(R6),R1	; Point to process name field
	PUSHL	R3			; Save pointer
	BSBW	GET_PR_NAM		; Move the name text
	POPL	R3			; Recover pointer
	BLBC	R0,60$			; If LBC then illegal name format
	MOVC3	R7,(R8),(R3)		; Enter taskname
	; 
	;    Enter remainder of NCB
	;
50$:	MOVB	#^A'/',(R3)+		; Enter delimiter
	MOVW	NET_L_LNK,(R3)+		; Enter local link number
	MOVAB	XWB$B_DATA(R6),R1	; Get address of counted data
	MOVZBL	(R1),R0			; Get its length
	INCW	R0			; Include its count field
	MOVC5	R0,(R1),#0,#17,(R3)	; Enter into fixed size field
	MOVAB	XWB$B_LPRNAM(R6),R1	; Address local task specifier 
	MOVZBL	(R1)+,R0		; Get its length
	MOVC3	R0,(R1),(R3)		; Move it
	MOVB	#^A'"',(R3)+		; Enter terminator
	ADDL	R3,NET_Q_NCB		; Update size in descriptor
	MOVB	#1,R0			; Indicate success
60$:	RSB

.SBTTL	GET_PROC	- Locate process to accept connect
;+
;
; Find the OBI block associated with the local object.  If the OBI is
; for a declared name or object then pass the NCB to the declaring
; process's mailbox, otherwise create a process to receive the connect.
; If there is a server process waiting for more work, then tell the
; server process that it can have the connect request.
;
; Inputs:
;
;	R6 = XWB address
;
;	Own storage
;
; Outputs:
;
;	None
;-
GET_PROC:				; Get process to accept the connect
	MOVL	NET$GL_CNR_OBI,R11	; Set up OBI CNR
	MOVAB	XWB$T_LPRNAM(R6),R1	; Address local task specifier
	BSBW	GET_PR_ZNA		; Get its ZNA field
	BLBC	R0,10$			; If LBC then format error
	;
	;
	;   Find the OBI CNF
	;
	;
	MOVZWL	#NET$C_DR_NOBJ,-	; Assume failure due to unknown object
		    NET_L_REASON	;
	CLRL	R10			; Indicate no current CNF
	$SEARCH	eql,obi,s,zna		; Find OBI block with this CNF
	BLBS	R0,20$			; If LBS then CNF was found
	TSTB	(R8)			; Is this a numbered object connect ?
	BNEQ	10$			; If NEQ then no such object
	MOVQ	NET_Q_TASKZNA,R7	; Else use default TASK  ZNA descriptor
	MOVZBL	S^#NFB$C_OP_EQL,R1	; Specify match operator
	CLRL	R10			; Start from head of list
	BSBW	CNF$KEY_SEARCH		; Look for the CNF
	BLBS	R0,25$			; If LBS then found, br to continue
10$:	BRW	100$			; Complete with error
	;
	;
	;   The OBI CNF has been found.  See if the object has been "declared"
	;   If not, build the .COM file file i.d. and setup its descriptor.
	;
	;
20$:	$GETFLD	obi,l,ucb		; Get the associated UCB
	BLBC	R0,30$			; If LBC then not declared name
	MOVL	R8,NET_L_UCB		; Save the UCB pointer
	$GETFLD	obi,l,pid		; Get the declarer's EPID
	BLBC	R0,30$			; If LBC then treat as undeclared
	MOVL	R8,R0			; Convert from EPID to IPID
	JSB	G^EXE$EPID_TO_IPID	; ...
	MOVL	R0,NET_L_PID		; Save the PID
	MOVZBL	#NETUPD$_CONNECT,-	; Setup the function code
		    NET_L_FCT		;
	BRW	100$			; Return to pass NCB to mailbox
	;
	;   The object is a named object which could not be found in the
	;   object database.  Use the requested object name to construct
	;   the name of the command procedure, rather than consulting the
	;   OBI entry (we are currently set to the "TASK" OBI).  If the
	;   object name starts with a "$", then the object is "reserved
	;   to DEC", and we get the command procedure from SYS$SYSTEM.
	;
25$:	MOVAB	XWB$T_LPRNAM(R6),R1	; Address local task specifier
	BSBW	GET_PR_NAM		; Get its name
	MOVL	NET_Q_TSK+4,R3		; Get address of output buffer
	CMPB	(R8),#^A"$"		; Does the name start with "$"?
	BNEQ	28$			; If so,
	INCL	R8			; Strip "$" off front of name
	DECL	R7
	MOVC	NET_Q_SYSTEM,-		; Prefix name with "SYS$SYSTEM:"
		@NET_Q_SYSTEM+4,(R3)
28$:	MOVC3	R7,(R8),(R3)		; Move the name
	ADDL	R3,NET_Q_TSK		; Update filename size
	BRB	40$			; Continue
	;
	;   Build filespec of object command procedure
	;
30$:	MOVZWL	#NET$C_DR_NOBJ,-	; Assume error
		    NET_L_REASON	;
	$GETFLD	obi,s,sfi		; Get parsed file id
	BLBC	R0,55$			; If LBC then file id is invalid
	MOVQ	R7,NET_Q_TSK		; Update filename descriptor
	;
	;
	;   Create a process name.
	;
	;
	$GETFLD	obi,s,nam		; Get object name for prefix
	BLBS	R0,50$			; If LBS then name was found
40$:	MOVQ	NET_Q_NETPREFIX,R7	; Setup standard prefix descriptor
50$:	MOVC3	R7,(R8),@NET_Q_PRC+4	; Move the prefix
	MOVB	#^A'_',(R3)+		; Move the delimiter
	MOVL	NET_L_LNK,R0		; Get the local link number
	BSBW	NET$BIN2ASC		; Convert to ascii and append as
					; the suffix
	ADDL	R3,NET_Q_PRC		; Done with process name
	;
	;   If the connect did not use format type 2, then don't attempt
	;   a proxy login.
	;
	CMPB	XWB$T_RPRNAM(R6),#2	; Format type 2?
	BEQL	51$			; Branch if so
	MOVB	#NMA$C_ACES_NONE,INT_B_PRX ; Disallow proxy access
51$:	;
	;
	;   If no access control was specified, use default from OBI block
	;
	;
	$GETFLD	obi,l,prx		; Get proxy login state
	BLBC	R0,52$			; If LBC then none specified
	MOVB	R8,OBI_B_PRX		; Store it
52$:	MOVAB	XWB$B_LOGIN(R6),R8	; Get address of access info
	MOVZBL	(R8)+,R7		; Get total size
	CMPB	R7,#3			; Is it 3 null (counted) strings
	BEQL	60$			; If so use access info in OBI
	MOVB	#NMA$C_ACES_NONE,-	; Disallow proxy access
		    INT_B_PRX		; Store it
	CMPB	R7,#NET$C_MAXACCFLD*3	; Too long ?
	BLEQU	70$			; If LEQU then move the strings
	MOVZWL	#NET$C_DR_IMLONG,-	; Indicate network failure type
		    NET_L_REASON	;
55$:	BRW	100$			; Continue
					;
60$:	$GETFLD	obi,s,iac		; Get inbound access control
70$:	;
	;
	;   Enter the flags word followed by the access control strings
	;
	;
	MOVL	NET_Q_ACC+4,R3		; Get pointer to access control buffer
	CLRW	(R3)+			; Clear the flags word
	$DISPATCH  TYPE=B,INT_B_PRX -	; Don't set flag if proxy disallowed
	<-
	  <NMA$C_ACES_OUTG, 80$>-
	  <NMA$C_ACES_NONE, 80$>-
	>
	$DISPATCH  TYPE=B,OBI_B_PRX -	; Don't set flag if proxy disallowed
	<-
	  <NMA$C_ACES_OUTG, 80$>-
	  <NMA$C_ACES_NONE, 80$>-
	>
	BISW	#1,-2(R3)		; Say "proxy login allowed"
80$:	MOVC3	R7,(R8),(R3)		; Move access control strings,
					; even if it's null
	ADDL	R3,NET_Q_ACC		; Complete string size calc.
	BSBW	UP_CASE			; Up-case all pertinent strings
	;
	;   Attempt to find an available server process which is waiting
	;   for a connect which matches it's context.
	;
	MOVL	NET$GL_CNR_SPI,R11	; Get root of SPI database
	CLRL	R10			; Start at beginning of list
81$:	CLRL	R8			; Search key is zero
	$SEARCH	neq,spi,l,irp		; Find an SPI with an IRP NE 0
	BLBS	R0,82$			; Br if found, check process
	BRW	89$			; Else, create process
82$:	TSTL	XWB$L_PID(R6)		; Is this connect "tagged" for a
	BEQL	83$			; specific process?
	$GETFLD	spi,l,pid		; If so, get PID of this server
	BLBC	R0,81$			; (if not present, error, skip entry)
	CMPL	R8,XWB$L_PID(R6)	; Is this server the intended process?
	BNEQ	81$			; If not, then continue searching
83$:	;
	;   Always check the access control, even for processes started
	;   with proxy requested.  This way, if different default access
	;   control is used (each object can specify a unique account,
	;   including NONE), the wrong process isn't matched.
	;
	$GETFLD	spi,s,acs		; Get ACS for server process
	BLBC	R0,81$			; (if not present, error, skip entry)
	MOVQ	NET_Q_ACC,R0		; Get access string for new connect
	CMPC5	R7,(R8),#0,R0,(R1)	; Does it match?
	BNEQ	81$			; If no match, keep searching
	;
	;   Make sure the process's "proxy request" flag matches.
	;
	$GETFLD	spi,v,prl		; Get proxy login flag
	BLBC	R0,81$			; (if not present, error, skip entry)
	CMPZV	#0,#1,@NET_Q_ACC+4,R8	; Does proxy login flag match?
	BNEQ	81$			; If not, try to find another server
	;
	;   For logical links which request proxy access, require
	;   that the requesting node and username match as well.
	;
	BLBC	R8,87$			; If proxy requested,
	$GETFLD	spi,l,rna		; Get remote node address for server
	BLBC	R0,81$			; (if not present, error, skip entry)
	CMPW	XWB$W_REMNOD(R6),R8	; Is it the same node as the connect?
	BNEQ	81$			; If not, try to find another server
	$GETFLD	spi,s,rid		; Get remote user ID for server
	BLBC	R0,88$			; (if not present, error, skip entry)
	MOVZBL	XWB$B_RID(R6),R0	; Get length of RID for new connect
	CMPC5	R7,(R8),#0,R0,XWB$T_RID(R6) ; Does it match?
	BNEQ	88$			; If no match, then skip it
87$:	BRB	SEND_TO_SERVER		; Server ok, send it the connect

88$:	BRW	81$			; (Branch helper to top of loop)
89$:	;
	;
	;   Create the user process
	;
	$CREPRC_S	-		; create a process
	    INPUT=  NET_Q_PROC,-	; Network NETSERVER.COM filename
	    OUTPUT= NET_Q_ACC,-		; Access control strings
	    ERROR=  NET_Q_NCB,-		; 1st NCB (solely for LOGIN proxy use)
	    PRCNAM= NET_Q_PRC,-		; Process name
	    IMAGE=  NET_Q_IMAGE,-	; Image (LOGINOUT) to run first
	    PIDADR= NET_L_PID,-		; Place to store process id
	    BASPRI= G^SYS$GB_DEFPRI,-	; Priority
	    UIC=    #<^O10@16+^O40>,-	; UIC is [10,40]
	    STSFLG= #<STS_M_NETLOG>,-	; This is a network process
	    MBXUNT= MBX_UNIT		; MBX for termination
					; notification
	BLBS	R0,90$			; If LBS process was created
	MOVZWL	#NET$C_DR_RSU,-		; Assume because couldn't get 
		NET_L_REASON		; the resources
	BRB	100$			; Take common exit
90$:	MOVL	NET_L_PID,R0		; Get the EPID returned by CREPRC
	MOVL	R0,R8			; Save EPID
	JSB	G^EXE$EPID_TO_IPID	; Convert to internal PID format
	MOVL	R0,NET_L_PID		; Use internal format of PID
	MOVZWL	#NETUPD$_PROCRE,-	; Say "process created"
		    NET_L_FCT		;
	;
	;    The network process is created.  Now create an SPI database entry 
	;    so we can keep track of it.
	;
	BSBW	CREATE_SPI		; Create SPI database entry
					; Ignore errors if can't be inserted
100$:	RSB				; Common exit

.SBTTL	SEND_TO_SERVER	- Send connect to waiting server
;+
;
; There is a waiting server which can handle the incoming connect.  Set
; it up so that the server can accept the logical link.
;
; Inputs:
;
;	R11 = SPI CNR address
;	R10 = CNF for server database entry
;
;-
SEND_TO_SERVER:
	MOVL	R10,R6			; Save address of old CNF
	BSBW	NET$GETUTLBUF		; Get permission to use utility buffer
	BSBW	CNF$INIT_UTL		; Initialize utility buffer
	MOVL	R6,R8			; Pass address of old CNF
	BSBW	CNF$COPY		; Copy old CNF to new CNF space
	MOVQ	NET_Q_NCB,R7		; Get descriptor of NCB
	$PUTFLD	spi,s,ncb		; Store it
	MOVQ	NET_Q_TSK,R7		; Get procedure filespec
	$PUTFLD	spi,s,sfi		; Store it
	MOVQ	NET_Q_PRC,R7		; Get process name
	$PUTFLD	spi,s,pnm		; Store it
	BSBW	CNF$INSERT		; Insert new CNF (R10 = UTILBUF)
					; and delete old CNF (R6)
					; returns: R10 = valid CNF
	$GETFLD	spi,l,pid		; Get PID of server process
	MOVL	R8,NET_L_PID		; Make it seem as if it was just created
	$GETFLD	spi,l,irp		; Get waiting DECLSERV IRP
	BSBW	CNF$CLR_FIELD		; and clear it from database
	MOVL	R8,R3			; Get IRP address
	MOVL	S^#SS$_NORMAL,IRP$L_IOST1(R3) ; Set success into IRP
	MOVL	NET_L_PID,IRP$L_IOST2(R3) ; Return IPID of SPI process as well
	MOVL	IRP$L_UCB(R3),R5	; Get UCB address
	JSB	G^COM$POST		; and complete the request
	BSBW	NET$DEC_TRANS		; Account for completed transaction
	MOVZWL	#NETUPD$_PROCRE,NET_L_FCT ; Tell NETDRIVER that process exists
	RSB

.SBTTL	CREATE_SPI	- Create SPI database entry
;+
;
; Subroutine to create an SPI database entry after having just created
; the network process.
;
; Inputs:
;
;	R6 = XWB address
;	Own storage
;
; Outputs:
;
;	R0 = Status code
;-
CREATE_SPI:
	BSBW	NET$GETUTLBUF		; Get permission to use utility buffer
	MOVL	NET$GL_CNR_SPI,R11	; Get root of SPI database
	BSBW	CNF$INIT_UTL		; Init utility buffer as a CNF block
	MOVL	NET_L_PID,R8		; Get PID of server process
	$PUTFLD	spi,l,pid		; Store parameter into entry
	EXTZV	#0,#1,@NET_Q_ACC+4,R8	; Get proxy flag sent to LOGIN
	$PUTFLD	spi,v,prl		; Store it
	MOVQ	NET_Q_ACC,R7		; Get access control sent to LOGIN
	$PUTFLD	spi,s,acs		; Store ACS string sent to LOGIN
	MOVZWL	XWB$W_REMNOD(R6),R8	; Get remote node address
	$PUTFLD	spi,l,rna		; Store it
	MOVZBL	XWB$B_RID(R6),R7	; Make descriptor of RID
	MOVAB	XWB$T_RID(R6),R8
	$PUTFLD	spi,s,rid		; Store it
	CLRL	R6			; No "old" CNF entry
	BSBW	CNF$INSERT		; Insert into database
	RSB

.SBTTL	GET_PR_NAM	- Get name of object procedure
.SBTTL	GET_PR_ZNA	- Construct ZNA string for an object
;+
;
; Inputs:
;
;	R1 = Address of local task specifier
;
; Outputs:
;
;	R7/R8 = Descriptor of resultant string
;-

		.ENABL	LSB
GET_PR_NAM:				; Get procedure name
	MOVAB	ZNABUF,R8		; Setup buffer pointer
	MOVL	R8,R3			; Make a copy
	BRB	5$			; Continue	
GET_PR_ZNA:
	MOVAB	ZNABUF,R8		; Point to ZNA buffer
	MOVL	R8,R3			; Make a copy
	MOVB	1(R1),(R3)+		; Enter object type
5$:	CVTWB	(R1)+,R0    		; Get format type, skip over object type
	BNEQ	20$			; If NEQ then not numbered object
10$:	TSTB	-1(R1)			; Is object type zero ?
	BEQL	40$			; If EQL then error
	BRB	60$			; Else we're done
20$:	TSTB	-1(R1)			; Is object type zero ?
	BNEQ	40$			; If NEQ then error
	CMPB	#1,R0			; Format type 1 is a counted string
	BEQL	30$			; If EQL then go move the string
	CMPB	#2,R0			; Format type 2 is UIC + counted string
	BNEQ	40$			; If NEQ then format type is unknown
	TSTL	(R1)+			; Skip over UIC
30$:	MOVZBL	(R1)+,R0		; Get taskname string size
	BEQL	40$			; If EQL then illegal format
	CMPB	R0,#MAX_TASKNAM		; Is it within bounds?
	BLEQU	50$			; If LEQU then legal format
40$:	CLRL	R0			; Else, indicate error
	MOVZWL	#NET$C_DR_FMT,-		; Setup network failure code
		    NET_L_REASON	;
	BRB	70$			; Take common exit
50$:	MOVC3	R0,(R1),(R3)		; Enter string
60$:	SUBL3	R8,R3,R7		; Get string size
	MOVL	#1,R0			; Indicate success
70$:	RSB

		.DSABL	LSB

.SBTTL	TELL_DRV	- Call NETDRIVER
;++
;
; Call NETDRIVER to perform a given function.
;
; Inputs:
;
;	NET_L_R0-R5 = Arguments to NETDRIVER function
;--
TELL_DRV:				; Tell driver about process
	MOVQ	NET_L_R0,R0		; Get regs for call
	MOVQ	NET_L_R2,R2		;
	MOVQ	NET_L_R4,R4		;
	BSBW	CALL_NETDRIVER		; Call driver
	RSB

.SBTTL	UP_CASE	- Upcase the LOGINOUT strings
;+
;
; The NCB (up to the "/"), the access control strings, the taskname, and the
; process name are up-cased in place.
;
; INPUTS:	none
;
; OUTPUTS:	none
;
;		All register contents are preserved.
;
;-
UP_CASE:				; Up-case strings passed to LOGINOUT
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	; Save regs
	MOVAB	NET$AB_UPASCNUM,R5	; Get translation table
	MOVB	#^A'/',R4		; Setup terminator
	MOVAB	NET_Q_NCB,R3		; Point to NCB descriptor
	BSBB	UP_IT			; Up-case it in place
	CLRL	R4			; Say "no terminator"
	MOVAB	NET_Q_TSK,R3		; Point to task-name descriptor
	BSBB	UP_IT			; Up-case it in place
	MOVAB	NET_Q_PRC,R3		; Point to process-name descriptor
	BSBB	UP_IT			; Up-case it in place
	MOVAB	NET_Q_ACC,R3		; Get access control descriptor
	MOVL	4(R3),R1		; Get pointer to strings
	ADDL	#2,R1			; Skip over flags word
	MOVZBL	(R1)+,R2		; Get count of bytes in username
	BSBB	UP_CASE_LOOP		; Start at end of loop
	MOVZBL	(R1)+,R2		; Get count of bytes in password
	BSBB	UP_CASE_LOOP		; Start at end of loop
	MOVZBL	(R1)+,R2		; Get count of bytes in account name
	BSBB	UP_CASE_LOOP		; Start at end of loop
	ADDL3	(R3),4(R3),-(SP)	; Get address of end of strings
	CMPL	R1,(SP)+		; Have we gone too far?
	BGTRU	10$			; If GTRU then yes
	POPR	#^M<R0,R1,R2,R3,R4,R5>	; Restore regs
	RSB		


10$:	BUG_CHECK  NETNOSTATE,FATAL	; Access control strings setup
					; incorrectly


		.ENABL	LSB

UP_IT:	MOVZWL	(R3),R2			; Get string length
	MOVL	4(R3),R1		; Point to string
	BRB	UP_CASE_LOOP		; Start at end of loop
20$:	MOVB	(R1)+,R0		; Get next character
	CMPB	R0,R4			; Is it the terminator?
	BEQL	60$			; If EQL yes, we're done
	MOVB	(R5)[R0],R0		; Up-case it
	BEQL	UP_CASE_LOOP		; If EQL then not alpha-numeric
	MOVB	R0,-1(R1)		; Store up-cased value

UP_CASE_LOOP:
	SOBGEQ	R2,20$			; Loop for each character
60$:	RSB				; Done

		.DSABL	LSB


.END
