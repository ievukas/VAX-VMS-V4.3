	.TITLE	SYSACPFDT - ACP FUNCTION DECISION TABLE ACTION ROUTINES
	.IDENT	'V04-001'
 
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; D. N. CUTLER 22-NOV-76
;
; MODIFIED BY:
;
;	V04-001	ACG0467		Andrew C. Goldstein,	12-Sep-1984  21:45
;		Fix protection holes in QIO device protection check
;
;	V03-029	ACG0438		Andrew C. Goldstein,	2-Aug-1984  19:38
;		Fix field mask in XQP$UNLOCK_CACHE, remove code that
;		flushes caches when block lock is released. Add dismount
;		in progress check in mount check logic. Add error checks
;		on calls to SCH$QAST in XQP routines.
;
;	V03-028	ACG0438		Andrew C. Goldstein,	25-Jul-1984  11:09
;		Add XQP$UNLOCK_CACHE subroutine for cache flusher
;
;	V03-027	ACG0422		Andrew C. Goldstein,	23-Apr-1984  15:23
;		Further corrections to erase QIO processing with non-zero
;		erase patterns.
;
;	V03-026	CDS0003		Christian D. Saether	 1-May-1984
;		Add blocking routine XQP$FCBSTALE.
;
;	V03-025	ACG0421		Andrew C. Goldstein,	20-Apr-1984  14:29
;		Fix segment byte count limiting in erase QIO's;
;		re-enable use of DSE function in MSCP disks.
;
;	V03-024 EMD0071		Ellen M. Dusseault	6-Apr-1984
;		Allocate and initialize a buffer for new parameter,
;		encryption key (P4), in common code path of ACP$WRITEBLK
;		and ACP$READBLK.		
;
;	V03-023	RKS0023		RICK SPITZ		6-APR-1984
;		Allow new attribute access mode to always be probed
;		at Callers access mode.
;
;	V03-022	RKS0022		RICK SPITZ		23-MAR-1984
;		Add functionality in BUILDACPBUF to recognize a user supplied
;		attribute specifying the access mode to probe the remaining
;		attributes in the buffer.
;
;	V03-021	ACG0400		Andrew C. Goldstein,	10-Mar-1984  1:24
;		Add routines to release quota cache locks for cluster
;		wide quota cache.
;
;	V03-020	LMP0206		L. Mark Pilant,		9-Mar-1984  8:31
;		Insure that the access check is only done once per channel
;		for physical and logical read/write requests.
;
;	V03-019	CDS0002		Christian D. Saether	 2-Mar-1984
;		Add support for WRITE_TURN.
;
;	V03-018	WMC0001		Wayne Cardoza		01-Nov-1983
;		XQP$DEQBLOCKER needs 4 arguments in call to EXE$DEQ.
;
;	V03-017	CDS0001		Christian D. Saether	13-Oct-1983
;		Add routines to allow xqp file system blocking.
;		XQP$BLOCK_ROUTINE and XQP$DEQBLOCKER.
;
;	V03-016	RPG0016		Bob Grosso		12-Sep-1983
;		Back out branch around WCB refcnt checking so that
;		deleted open known files will be closed with the 
;		WCB deallocated.
;
;	V03-015	ROW0218		Ralph O. Weber		 7-SEP-1983
;		Change maximum byte count, UCB$L_MAXBCNT, tests to be 
;		unsigned.
;
;	V03-014	ROW0212		Ralph O. Weber		20-AUG-1983
;		Change mechanism used to disable use of the MSCP erase 
;		function to one which allow its use to be restored with a 
;		simple patch.  Also change MXDESCR from 5+17 to 5+30 at Andy's 
;		request.
;
;	V03-013	ROW0198		Ralph O. Weber		29-JUL-1983
;		Temporarily disable use of the MSCP erase function for 
;		IO$M_ERASE requests because the HSC does not support MSCP 
;		erase.
;
;	V03-012	LJK0226		Lawrence J. Kenah	6-Jul-1983
;		Temporarily disable decrement of REFCNT in shared windows.
;
;	V03-011	ROW0192		Ralph O. Weber		21-JUN-1983
;		Fix ACP$WRITEBLK and ACP$READBLK to allow longword byte 
;		counts.  This should allow virtual disk transfers to exceed 
;		65K bytes.
;
;	V03-010	STJ3105		Steven T. Jeffreys,	17-Jun-1983
;		- Return SS$_ILLIOFUNC for virtual erase to tapes.
;
;	V03-009	STJ3099		Steven T. Jeffreys,	03-May-1983
;		- Enable erase I/O to tape devices.
;		- Greatly improve resource utilization for nonzero erase I/O.
;
;	V03-008	LJK0199		Lawrence J. Kenah	26-Apr-1983
;		Do not credit FILCNT quota when DEACCESS is performed
;		on a shared window. No charge was made on ACCESS path.
;
;	V03-007 MSH53232	Maryann Hinden		29-Apr-1983
;		Test count, not address, in CHKDESCR.
;
;	V03-006	STJ3086		Steven T. Jeffreys,	13-Apr-1983
;		- Performance enhancement to setup_erase made possible
;		  by change to IOCIOPOST (STJ3085).
;
;	V03-005	RLRMXBCNTa	Robert L. Rappaport	21-Mar-1983
;		Correct bug in original addition to allow segmentation
;		of Logical I/O.
;
;	V03-004	RLRMXBCNT	Robert L. Rappaport	11-Mar-1983
;		Allow for segmentation of Logical I/O (and Virtual)
;		based on the UCB$L_MAXBCNT field.
;
;	V03-003	STJ3059		Steven T. Jeffreys	02-Feb-1983
;		Temporary disable of ERASE to tapes to resolve I/O
;		function modifier collision.
;
;	V03-002	STJ3048		Steven T. Jeffreys	06-Jan-1983
;		Added support for erase qio.
;
;	V03-001	KDM0002		Kathleen D. Morse	28-Jun-1982
;		Added $SSDEF.
;
;**
;
; ACP FUNCTION DECISION TABLE ACTION ROUTINES
;
; MACRO LIBRARY CALLS
;
 
	$ACBDEF				;DEFINE ACB SYMBOLS.
	$ATRDEF				;DEFINE ACP FILE ATTRIBUTES
	$CCBDEF				;DEFINE CCB OFFSETS
	$DCDEF				;DEFINE DEVICE CLASS CODES
	$DDTDEF				;DEFINE DDT OFFSETS
	$DEVDEF				;DEFINE DEVICE CHARACTERISTICS BITS
	$DYNDEF				;DEFINE STRUCTURE TYPE CODES
	$FCBDEF				;DEFINE FCB OFFSETS
	$FIBDEF				;DEFINE FIB FIELDS AND CODES
	$IPLDEF				;DEFINE INTERRUPT PRIORITY LEVELS
	$IODEF				;DEFINE I/O FUNCTION CODES
	$IRPDEF				;DEFINE IRP OFFSETS
	$JIBDEF				;DEFINE JIB OFFSETS
	$LCKDEF				;DEFINE LOCK MANAGER SYMBOLS
	$PCBDEF				;DEFINE PCB OFFSETS
	$PRDEF				;DEFINE PROCESSOR REGISTERS
	$PRTDEF				;DEFINE PAGE PROTECTION CODES
	$PRVDEF				;DEFINE PRIVILEGE BITS
	$PTEDEF				;DEFINE PTE FORMAT
	$RVTDEF				;DEFINE ROOT VOLUME TABLE OFFSETS
	$SSDEF				;DEFINE SYSTEM STATUS CODES
	$UCBDEF				;DEFINE UCB OFFSETS
	$VADEF				;DEFINE VIRTUAL ADDRESS FIELDS
	$VCADEF				;DEFINE VOLUME CACHE OFFSETS
	$VCBDEF				;DEFINE VCB OFFSETS
	$WCBDEF				;DEFINE WCB OFFSETS
 
;
; LOCAL SYMBOLS
;
; ARGUMENT LIST OFFSET DEFINITIONS
;
 
P1=0					;FIRST FUNCTION DEPENDENT PARAMETER
P2=4					;SECOND FUNCTION DEPENDENT PARAMETER
P3=8					;THIRD FUNCTION DEPENDENT PARAMETER
P4=12					;FOURTH FUNCTION DEPENDENT PARAMETER
P5=16					;FIFTH FUNCTION DEPENDENT PARAMETER
P6=20					;SIXTH FUNCTION DEPENDENT PARAMETER
 
;
; MAXIMUM NUMBER OF ACP DESCRIPTORS
;
 
MXDESCR=5+30				;MAXIMUM NUMBER OF ACP DESCRIPTORS

	.SBTTL	ACCESS AND CREATE ACP FUNCTION PROCESSING
;+
; ACP$ACCESS - ACCESS AND CREATE ACP FUNCTION PROCESSING
; ACP$ACCESSNET - ACCESS (CONNECT) TO NETWORK FUNCTION PROCESSING
;
; ***TBS***
;
; INPUTS:
;
;	R0 = SCRATCH.
;	R1 = SCRATCH.
;	R2 = SCRATCH.
;	R3 = ADDRESS OF I/O REQUEST PACKET.
;	R4 = CURRENT PROCESS PCB ADDRESS.
;	R5 = ASSIGNED DEVICE UCB ADDRESS.
;	R6 = ADDRESS OF CCB.
;	R7 = I/O FUNCTION CODE BIT NUMBER.
;	R8 = FUNCTION DECISION TABLE DISPATCH ADDRESS.
;	R9 = SCRATCH.
;	R10 = SCRATCH.
;	R11 = SCRATCH.
;	AP = ADDRESS OF FIRST FUNCTION DEPENDENT PARAMETER.
;
; OUTPUTS:
;
; ***TBS***
;-
 
	.ENABL	LSB
BRMODIFY:				;
	BRW	ACP$MODIFY		;
ACP$ACCESS::				;ACCESS AND CREATE ACP FUNCTION PROCESSING
	BBC	#IO$V_ACCESS,IRP$W_FUNC(R3),BRMODIFY ; IF CLR, NOT ACCESS
ACP$ACCESSNET::				;ACCESS (CONNECT) TO NETWORK FUNCTION PROCESSING
	MOVZWL	#SS$_FILALRACC,R0	;ASSUME FILE ALREADY ACCESSED
	TSTL	CCB$L_WIND(R6)		;FILE ALREADY ACCESSED ON CHANNEL?
	BGTR	20$			;IF GTR PROCESS SECTION OPEN ON CHANNEL
	BNEQ	30$			;IF NEQ FILE OPEN ON CHANNEL
	MOVZWL	#SS$_EXQUOTA,R0		;ASSUME FILE QUOTA EXCEEDED
	MOVL	PCB$L_JIB(R4),R1	;GET JIB ADDRESS
	TSTW	JIB$W_FILCNT(R1)	;FILE QUOTA EXCEEDED?
	BLEQ	30$			;IF LEQ YES
	BSBW	BUILDACPBUF		;BUILD ACP BUFFER
	BSBW	CHKDISMOUNT		;CHECK VOLUME AND UPDATE TRANSACTION COUNT
	MOVL	PCB$L_JIB(R4),R1	;GET JIB ADDRESS
	DECW	JIB$W_FILCNT(R1)	;UPDATE FILE ACCESS COUNT
	INCL	CCB$L_WIND(R6)		;SET CHANNEL INTERLOCK
	BRB	70$			;

	.SBTTL	DEACCESS ACP FUNCTION PROCESSING
;+
; ACP$DEACCESS - DEACCESS ACP FUNCTION PROCESSING
;
; ***TBS***
;
; INPUTS:
;
;	R0 = SCRATCH.
;	R1 = SCRATCH.
;	R2 = SCRATCH.
;	R3 = ADDRESS OF I/O REQUEST PACKET.
;	R4 = CURRENT PROCESS PCB ADDRESS.
;	R5 = ASSIGNED DEVICE UCB ADDRESS.
;	R6 = ADDRESS OF CCB.
;	R7 = I/O FUNCTION CODE BIT NUMBER.
;	R8 = FUNCTION DECISION TABLE DISPATCH ADDRESS.
;	R9 = SCRATCH.
;	R10 = SCRATCH.
;	R11 = SCRATCH.
;	AP = ADDRESS OF FIRST FUNCTION DEPENDENT PARAMETER.
;
; OUTPUTS:
;
; ***TBS***
;-
 
ACP$DEACCESS::				;DEACCESS ACP FUNCTION PROCESSING
	MOVZWL	#SS$_FILNOTACC,R0	;ASSUME FILE NOT ACCESSED
	MOVL	CCB$L_WIND(R6),R1	;FILE ACCESSED ON CHANNEL?
	BGTR	20$			;IF GTR PROCESS SECTION OPEN ON CHANNEL
	BEQL	30$			;IF EQL NO FILE OPEN ON CHANNEL
	BITB	#WCB$M_NOTFCP!WCB$M_SHRWCB,WCB$B_ACCESS(R1) ;NORMAL WINDOW?
	BNEQ	40$			;IF NEQ NO
10$:	BSBW	BUILDACPBUF		;BUILD ACP BUFFER
	INCL	CCB$L_WIND(R6)		;SET CHANNEL INTERLOCK
	BSBW	UPTRANSCNT		;UPDATE TRANSACTION COUNT
	CMPW	#1,CCB$W_IOC(R6)	;ANY OTHER I/O ON CHANNEL?
	BEQL	70$			;IF EQL NO
	DECW	CCB$W_IOC(R6)		;ADJUST COUNT FOR DEACCESS
	MOVL	R3,CCB$L_DIRP(R6)	;SAVE ADDRESS OF DEACCESS PACKET
	BRW	EXE$QIORETURN		;
20$:	MOVZWL	#SS$_IVCHNLSEC,R0	;SET INVALID SECTION CHANNEL STATUS
30$:	BRW	EXE$ABORTIO		;
40$:	BBC	#WCB$V_SHRWCB,WCB$B_ACCESS(R1),50$ ;IF CLR, NOT SHARED WINDOW
	DECW	WCB$W_REFCNT(R1)	;ANY SHARERS REMAINING?
	BNEQ	60$			;IF NEQ YES
	BBC	#WCB$V_NOTFCP,WCB$B_ACCESS(R1),10$ ;IF CLR, NOT FCP WINDOW
	BRB	60$			;REJOIN COMMON CODE

50$:	MOVL	PCB$L_JIB(R4),R0	;GET JIB ADDRESS
	INCW	JIB$W_FILCNT(R0)	;INCREMENT FILE COUNT
60$:	CLRL	CCB$L_WIND(R6)		;CLEAR WINDOW ADDRESS
	MOVZWL	#SS$_NORMAL,R0		;SET NORMAL COMPLETION STATUS
	BRW	EXE$FINISHIOC		;

	.SBTTL	DELETE AND MODIFY ACP FUNCTION PROCESSING
;+
; ACP$MODIFY - DELETE AND MODIFY ACP FUNCTION PROCESSING
;
; ***TBS***
;
; INPUTS:
;
;	R0 = SCRATCH.
;	R1 = SCRATCH.
;	R2 = SCRATCH.
;	R3 = ADDRESS OF I/O REQUEST PACKET.
;	R4 = CURRENT PROCESS PCB ADDRESS.
;	R5 = ASSIGNED DEVICE UCB ADDRESS.
;	R6 = ADDRESS OF CCB.
;	R7 = I/O FUNCTION CODE BIT NUMBER.
;	R8 = FUNCTION DECISION TABLE DISPATCH ADDRESS.
;	R9 = SCRATCH.
;	R10 = SCRATCH.
;	R11 = SCRATCH.
;	AP = ADDRESS OF FIRST FUNCTION DEPENDENT PARAMETER.
;
; OUTPUTS:
;
; ***TBS***
;-
 
ACP$MODIFY::				;DELETE AND MODIFY ACP FUNCTION PROCESSING
	BSBW	BUILDACPBUF		;BUILD ACP BUFFER
	BSBW	CHKMOUNT		;CHECK VOLUME AND UPDATE TRANSACTION COUNT
	BRB	70$

	.SBTTL	MOUNT ACP FUNCTION PROCESSING
;+
; ACP$MOUNT - MOUNT ACP FUNCTION PROCESSING
;
; ***TBS***
;
; INPUTS:
;
;	R0 = SCRATCH.
;	R1 = SCRATCH.
;	R2 = SCRATCH.
;	R3 = ADDRESS OF I/O REQUEST PACKET.
;	R4 = CURRENT PROCESS PCB ADDRESS.
;	R5 = ASSIGNED DEVICE UCB ADDRESS.
;	R6 = ADDRESS OF CCB.
;	R7 = I/O FUNCTION CODE BIT NUMBER.
;	R8 = FUNCTION DECISION TABLE DISPATCH ADDRESS.
;	R9 = SCRATCH.
;	R10 = SCRATCH.
;	R11 = SCRATCH.
;	AP = ADDRESS OF FIRST FUNCTION DEPENDENT PARAMETER.
;
; OUTPUTS:
;
; ***TBS***
;-
 
ACP$MOUNT::				;MOUNT ACP FUNCTION PROCESSING
	BSBW	BUILDACPBUF		;BUILD ACP BUFFER
	MOVZWL	#SS$_NOPRIV,R0		;ASSUME INSUFFICIENT PROCESS PRIVILEGE
	IFNPRIV	MOUNT,90$		;PROCESS HAVE PRIVILEGE TO MOUNT VOLUME?
	BBCC	#UCB$V_MOUNTING,UCB$W_STS(R5),80$ ;IF CLR, NOT MOUNTING DEVICE
	BSBW	UPTRANSCNT		;UPDATE VOLUME TRANSACTION COUNT
70$:	BRW	EXE$QIOACPPKT		;QUEUE ACP PACKET
80$:	MOVZWL	#SS$_DEVNOTMOUNT,R0	;SET DEVICE NOT MOUNTED STATUS
90$:	BRW	EXE$ABORTIO		;ABORT I/O OPERATION
	.DSABL	LSB

	.SBTTL	READ AND WRITE BLOCK ACP FUNCTION PROCESSING
;+
; ACP$READBLK - READ BLOCK ACP FUNCTION PROCESSING
; ACP$WRITEBLK - WRITE BLOCK ACP FUNCTION PROCESSING
;
; ***TBS***
;
; INPUTS:
;
;	R0 = SCRATCH.
;	R1 = SCRATCH.
;	R2 = SCRATCH.
;	R3 = ADDRESS OF I/O REQUEST PACKET.
;	R4 = CURRENT PROCESS PCB ADDRESS.
;	R5 = ASSIGNED DEVICE UCB ADDRESS.
;	R6 = ADDRESS OF CCB.
;	R7 = I/O FUNCTION CODE BIT NUMBER.
;	R8 = FUNCTION DECISION TABLE DISPATCH ADDRESS.
;	R9 = SCRATCH.
;	R10 = SCRATCH.
;	R11 = SCRATCH.
;	AP = ADDRESS OF FIRST FUNCTION DEPENDENT PARAMETER.
;
; OUTPUTS:
;
; ***TBS***
;-
 
	.ENABL	LSB
ACP$READBLK::				;READ BLOCK ACP FUNCTION PROCESSING
	MOVL	#CCB$V_RDCHKDON,R9	;CCB BIT FOR READ PROT CHECK
	MOVAB	W^EXE$READLOCK,R10	;SET ADDRESS OF READ CHECK AND LOCK ROUTINE
	MOVAB	EXE$CHKRDACCES,R11	;SET ADDRESS OF ACCESS CHECK ROUTINE
	BBC	S^#DEV$V_RCK,UCB$L_DEVCHAR(R5),20$ ;IF CLR, NO DEVICE READ CHECK
10$:	BISW	#IO$M_DATACHECK,IRP$W_FUNC(R3) ;SET DATA CHECK ENABLE
	BRB	20$			;
;
; ZERO LENGTH TRANSFER
;
 
13$:	MOVZWL	#SS$_NORMAL,R0		;SET NORMAL COMPLETION
	BRW	EXE$FINISHIOC		;FINISH I/O OPERATION
;
; DEVICE SOFTWARE WRITE LOCKED
;

14$:	MOVZWL	#SS$_WRITLCK,R0		;SET WRITE LOCK ERROR
	BRW	70$

;
; RECORD LENGTH TOO SHORT FOR MAGTAPE TRANSFER
;
 
15$:	MOVZWL	#SS$_BADPARAM,R0	;SET BAD PARAMETER STATUS
	BRW	70$			;
 

;
; SET DEVICE LEVEL WRITE CHECK
;

16$:	BISW	#IO$M_DATACHECK,-	;SET DATA CHECK ENABLE
		IRP$W_FUNC(R3)		;
	BRB	18$			;REJOIN COMMON CODE

;
; SET UP FOR CALL TO ERASE REQUEST PROCESSING.  IT'S DONE
; THIS WAY TO MAKE THE LEAST IMPACT ON THE EXISTING CODE,
; AND TO AVOID THE LENGTH CHECKS ON THE BYTE TRANSFER COUNT.
;

17$:	MOVAB	W^SETUP_ERASE,R10	;SET ADDRESS OF SERVICE ROUTINE
	BRB	30$			;REJOIN COMMON CODE


ACP$WRITEBLK::				;WRITE BLOCK ACP FUNCTION PROCESSING
	BBS	S^#DEV$V_SWL,UCB$L_DEVCHAR(R5),14$ ;IF SET, SOFTWARE WRITE LOCKED
	BBS	S^#DEV$V_WCK,UCB$L_DEVCHAR(R5),16$ ;IF SET, DEVICE LEVEL WRITE CHECK
18$:	MOVL	#CCB$V_WRTCHKDON,R9	;CCB BIT FOR WRITE PROT CHECK
	MOVAB	EXE$CHKWRTACCES,R11	;SET ADDRESS OF ACCESS CHECK ROUTINE
	BBS	#IO$V_ERASE,-		;BRANCH IF ERASE REQUEST
		IRP$W_FUNC(R3),17$	;
	MOVAB	W^EXE$WRITELOCK,R10	;SET ADDRESS OF WRITE CHECK AND LOCK ROUTINE
20$:	MOVL	P1(AP),R0		;GET STARTING ADDRESS OF TRANSFER
	MOVL	P2(AP),R1		;GET NUMBER OF BYTES TO TRANSFER (LONGWORD)
	BEQL	13$			;IF EQL ZERO LENGTH TRANSFER
	BBC	S^#DEV$V_SQD,UCB$L_DEVCHAR(R5),30$ ;IF CLR, NOT SEQUENTIAL DEVICE
	CMPL	#14,R1			;RECORD TOO SHORT?
	BGTR	15$			;IF GTR YES
30$:	JSB	(R10)			;CHECK BUFFER AND LOCK IN MEMORY
	MOVL	P3(AP),R0		;GET STARTING MEDIA ADDRESS
	MOVL	IRP$L_BCNT(R3),R1	;RETRIEVE TRANSFER BYTE COUNT
	MOVL	R1,IRP$L_OBCNT(R3)	;SET ORIGNINAL BYTE COUNT
	CLRL	IRP$L_ABCNT(R3)		;CLEAR ACCUMULATED BYTE COUNT
    	BBS	#IO$V_ENCRYPT,IRP$W_FUNC(R3),36$    ; Set, key for encryption
33$:	CMPZV	#IRP$V_FCODE,#IRP$S_FCODE,- ;LOGICAL OR PHYSICAL I/O FUNCTION?
		IRP$W_FUNC(R3),#IO$_LOGICAL ;
	BLEQ	39$			;IF LEQ YES
	MOVL	IRP$L_WIND(R3),R2	;FILE ACCESSED ON CHANNEL?
	BEQL	50$			;IF EQL NO
	BBS	#IRP$V_FUNC,IRP$W_STS(R3),41$ ;IF SET, READ FUNCTION
 
;
; CHECK WRITE ACCESS
;
 
	BBC	#WCB$V_WRITE,WCB$B_ACCESS(R2),60$ ;IF CLR, NO WRITE ACCESS ALLOWED
	BBC	S^#DEV$V_SQD,UCB$L_DEVCHAR(R5),35$ ;IF CLR, NOT SEQUENTIAL DEVICE
	BICB	#WCB$M_READ,WCB$B_ACCESS(R2) ;DON'T ALLOW FURTHER READS
35$:	INCL	WCB$L_WRITES(R2)	;COUNT THE WRITE OPERATION
	BBS	#WCB$V_WRITE_TURN, WCB$W_ACON (R2), 40$ ; FORCE WINDOW TURN
	BBS	#WCB$V_WRITECK,WCB$W_ACON(R2),90$ ;IF SET, WRITE DATA CHECK ENABLED
	BRW	100$			;
;
; Encryption.  The key size must be less than or equal to 96 bytes.  This is
;	       a security check to ensure that the user does not gobble up
;	       pool. 
;
36$: 
    	PUSHR	#^M<R0,R1,R3,R4,R5>		; Preserve contents of registers
    	MOVL	P4(AP), R1			; r1 contains address of descriptor
    	BSBW	EXE$PROBER_DSC			; check read accessability
    	BLBC	R0,38$				; clear, error condition
    	CMPW	#96, R1				; size must be leq 96 bytes
    	BLSS	37$				; less than, size to large
    	MOVZWL	R1,R1				; zero extend the size
    	MOVQ	R1,-(SP)			; save descriptor
    	ADDL	#8, R1				; Account for header on buffer
    	JSB	G^EXE$ALLOCBUF			; Allocate nonpaged pool buffer
    	MOVQ	(SP)+,R3			; restore descriptor
    	BLBC	R0, 38$				; Clear, error condition
    	SUBL2	#4, R3				; Subtract 4 because of flags
    	SUBL2	#12, R1				; R1 size of allocated buffer-header
    	MOVL	(R4),(R2)			; Move flags field into buffer
    	PUSHL	R2				; save address of buffer
    	MOVC5	R3,4(R4),#0,R1,12(R2)		; Move key into buffer
    	POPL	R2				; restore address of buffer
    	POPR	#^M<R0,R1,R3,R4,R5>		; Restore register contents
    	MOVL	R2,IRP$L_KEYDESC(R3)		; store address of buffer in IRP
   	BISW	#IRP$M_KEY, IRP$W_STS(R3)	; Set flag in status field
    	BRW	33$

37$:	MOVL	#SS$_BADPARAM, R0			; set error status
38$:	POPR	#^M<R1,R2,R3,R4,R5>		; Restore register contents
    	BRB	70$				; Abort this io
    	
;
; EXTENDED BRANCH TO ACCESS CHECK.
;

39$:	BRB	120$

;
; EXTENDED BRANCH TO FORCED WINDOW TURN CODE.
;

40$:	BRW	220$

;
; EXTENDED BRANCH TO CHECK READ ACCESS
;
41$:	BRB 	80$

;
; FILE NOT ACCESSED ON CHANNEL
;
 
50$:	MOVZWL	#SS$_FILNOTACC,R0	;SET FILE NOT ACCESSED
	BRB	70$			;
 
;
; PRIVILEGE VIOLATION
;
 
60$:	MOVZWL	#SS$_NOPRIV,R0		;SET NO PRIVILEGE
70$:	BRW	EXE$ABORTIO		;
75$:	ADDL	#8,SP			;CLEAN TEMPS OFF STACK
	BRB	70$			;AND EXIT
 
;
; CHECK READ ACCESS
;
 
80$:	BBC	#WCB$V_READ,WCB$B_ACCESS(R2),60$ ;IF CLR, READ ACCESS NOT ALLOWED
	INCL	WCB$L_READS(R2)		;COUNT THE READ OPERATION
	BBC	#WCB$V_READCK,WCB$W_ACON(R2),100$ ;IF CLR, NO READ CHECK
90$:	BISW	#IO$M_DATACHECK,IRP$W_FUNC(R3) ;SET DATA CHECK ENABLE
100$:	BISW	#IRP$M_VIRTUAL,IRP$W_STS(R3) ;SET VIRTUAL I/O FUNCTION
	MOVL	R0,IRP$L_SEGVBN(R3)	;SAVE STARTING VIRTUAL BLOCK NUMBER
	MOVL	IRP$L_SVAPTE(R3),IRP$L_DIAGBUF(R3) ;COPY STARTING PTE ADDRESS
	SUBW	#IO$_WRITEVBLK-IO$_WRITEPBLK,- ;CONVERT TO PHYSICAL I/O FUNCTION
		IRP$W_FUNC(R3)		;
	SETIPL	UCB$B_FIPL(R5)		;RAISE TO DRIVER FORK LEVEL
	BSBW	IOC$MAPVBLK		;MAP VIRTUAL BLOCK TO LOGICAL BLOCK
	MOVL	R5,IRP$L_UCB(R3)	;STORE MODIFIED UCB IN I/O PACKET
	MOVL	R1,R0			;COPY STARTING LOGICAL BLOCK NUMBER
	SUBL3	R2,IRP$L_OBCNT(R3),R1	;CALCULATE LENGTH OF SEGMENT
	MOVL	R1,IRP$L_BCNT(R3)	;STORE IN I/O PACKET
	BEQL	160$			;IF EQL COMPLETE MAP FAILURE
	BBS	S^#DEV$V_SQD,UCB$L_DEVCHAR(R5),140$ ;IF CLR, NOT SEQUENTIAL DEVICE
	MOVQ	R0,R9			;COPY LBN AND COUNT FOR USE BELOW
	BRB	130$			;

120$:	MOVL	R0,IRP$L_MEDIA(R3)	;SAVE MEDIA ADDRESS
	MOVQ	R0,-(SP)		;SAVE TRANSFER PARAMETERS
	BBS	R9,CCB$B_STS(R6),125$	;XFER IF CHECK DONE ALREADY

; R4 - PCB ADDRESS
; R5 - UCB ADDRESS

	JSB	(R11)			;CHECK FOR PROPER ACCESS RIGHTS
	BLBC	R0,75$			;IF LBC PRIVILEGE VIOLATION
	BBSS	R9,CCB$B_STS(R6),125$	;MARK PROT CHECK DONE
125$:	MOVQ	(SP)+,R9		; GET BACK TRANSFER PARAMETERS
	CMPZV	#IRP$V_FCODE,#IRP$S_FCODE,- ;PHYSICAL I/O FUNCTION?
		IRP$W_FUNC(R3),#IO$_PHYSICAL ;
	BLEQ	150$			;IF LEQ YES
	SUBW	#IO$_WRITELBLK-IO$_WRITEPBLK,- ;CONVERT TO PHYSICAL I/O FUNCTION
		IRP$W_FUNC(R3)		;
	MOVL	R9,IRP$L_SEGVBN(R3)	; Prepare for possible segmentation of
					;  Logical I/O function by setting
	MOVL	IRP$L_SVAPTE(R3),-	;  up Starting segmented LBN and
		IRP$L_DIAGBUF(R3)	;  by copying the starting PTE address.
	BBS	S^#DEV$V_SQD,UCB$L_DEVCHAR(R5),140$ ;IF SET, SEQUENTIAL DEVICE
130$:	MOVL	UCB$L_MAXBCNT(R5),R0	; R0 = 0 or Max. permissible BCNT.
	BNEQ	133$			; NEQ implies Max. permissible BCNT in R0.
	MOVZWL	#512*127,R0		; If 0, use default Max. permissible.
133$:
	CMPL	R0,IRP$L_BCNT(R3)	; See if BCNT too large.
	BGEQU	137$			; GEQU implies we are OK.
	MOVL	R0,IRP$L_BCNT(R3)	; Else scale down to maximum allowed.
	MOVL	R0,R10			; Also update R10 copy of BCNT if changed.
137$:
	DECL	R10			;ROUND BYTE COUNT DOWN
	ASHL	#-VA$S_BYTE,R10,R10	;CONVERT TO BLOCK COUNT
	ADDL	R9,R10			;CALCULATE ENDING BLOCK NUMBER
	BCS	170$			;IF CS ILLEGAL BLOCK NUMBER
	CMPL	R10,UCB$L_MAXBLOCK(R5)	;LEGAL BLOCK NUMBER?
	BGEQU	170$			;IF GEQU NO
	MOVL	R9,R0			;RETRIEVE STARTING MEDIA ADDRESS
	BSBW	IOC$CVTLOGPHY		;CONVERT LOGICAL BLOCK TO PHYSICAL ADDRESS
140$:	BICW	#IO$M_INHERLOG!IO$M_INHSEEK,- ;CLEAR INHIBIT ERROR LOGGING
		IRP$W_FUNC(R3)		;AND EXPLICIT SEEK
150$:	BBS	#IO$V_ERASE,-		;BRANCH IF ERASE REQUEST
		IRP$W_FUNC(R3),200$	;
155$:	BRW	EXE$QIODRVPKT		;QUEUE I/O PACKET TO DRIVER
160$:	MOVL	R2,IRP$L_BCNT(R3)	;SET REQUESTED BYTE COUNT
165$:	MOVL	IRP$L_WIND(R3),R2	;GET WINDOW ADDRESS
	BBS	#WCB$V_NOTFCP,WCB$B_ACCESS(R2),180$ ;IF SET, NOT FCP WINDOW
	BRW	EXE$QIOACPPKT		;QUEUE ACP PACKET
170$:	MOVZWL	#SS$_ILLBLKNUM,R0	;SET ILLEGAL BLOCK NUMBER STATUS
	BRB	190$
180$:	MOVZWL	#SS$_ENDOFFILE,R0	;SET END OF FILE STATUS
190$:	BRW	EXE$FINISHIOC		;FINISH I/O OPERATION
	;
	;
	; SEE IF THE FUNCTION CODE SHOULD BE CHANGED TO IO$_DSE.
	; THIS IS DONE FOR ALL TAPE DEVICES, AND ALL OTHER DEVICES
	; THAT HAVE SPECIAL HARDWARE SUPPORT (INDICATED BY A SVAPTE
	; OF ZERO).  AFTER CHANGING THE CODE, CHECK THE NEW FUNCTION
	; CODE AGAINST THE DRIVER'S FDT TABLE, SINCE WE'VE BYPASSED
	; THE NORMAL CHECK BY CHANGING THE FUNCTION CODE AT THIS LATE
	; DATE.
	;
	;
200$:	CMPB	#DC$_TAPE,-		;CHECK DEVICE CLASS
		UCB$B_DEVCLASS(R5)	;
	BEQL	210$			;BRANCH IF TAPE
	TSTL	IRP$L_SVAPTE(R3)	;TEST SVAPTE ADDRESS
	BEQL	210$			;BRANCH IF ZERO
	MOVL	#127*512,R0		;GET LIMIT FOR PSEUDO PAGE TABLE
	CMPL	IRP$L_BCNT(R3),R0	;CHECK BYTE COUNT AGAINST LIMIT
	BLEQU	155$			;BRANCH IF OK
	MOVL	R0,IRP$L_BCNT(R3)	;SET COUNT TO LIMIT
	BRB	155$

210$:	INSV	#IO$_DSE,-		;CHANGE WRITE REQUEST TO ERASE
		#IRP$V_FCODE,-		;
		#IRP$S_FCODE,-		;
		IRP$W_FUNC(R3)		;
	MOVL	UCB$L_DDT(R5),R0	;GET THE DDT ADDRESS
	BBS	#IO$_DSE,-		;BRANCH IF DSE SUPPORTED
		@DDT$L_FDT(R0),155$	;
	MOVZWL	#SS$_ILLIOFUNC,R0	;SET FAILURE STATUS
	BRW	EXE$ABORTIO		;ABORT THE I/O REQUEST

;
; FORCE WINDOW TURN.  THIS IS DONE TO ALLOW THE FILE SYSTEM TO INVALIDATE
; FILE SYSTEM CACHE ENTRIES THAT CORRESPOND TO VIRTUAL WRITES ON FILE
; SYSTEM FILES (INDEXF, BITMAP, DIRECTORIES).  THE WRITE_TURN FLAG WAS
; SET BY THE FILE SYSTEM WHEN THE FILE WAS WRITE ACCESSED.
; SOME CODE IS REPEATED HERE FROM ABOVE TO AVOID MUCKING UP THE NORMAL
; (NON WRITE_TURN) PATH.
;

220$:	BBC	#WCB$V_WRITECK, WCB$W_ACON (R2), 230$ ; BR IF NO WRITE DATA CHK
	BISW	#IO$M_DATACHECK, IRP$W_FUNC (R3) ; SET DATA CHECK
230$:	BISW	#IRP$M_VIRTUAL, IRP$W_STS (R3) ; NOTE AS VIRTUAL I/O
	MOVL	R0, IRP$L_SEGVBN (R3)	; SAVE STARTING VBN
	MOVL	IRP$L_SVAPTE (R3), IRP$L_DIAGBUF (R3) ; SAVE STARTING PTE ADDR
	MOVW	#IO$_WRITEPBLK, IRP$W_FUNC (R3) ; CONVERT TO PHYSICAL I/O FUNC
	BRB	165$			; AND OFF TO QUEUE THE PACKET

	.DSABL	LSB

	.SBTTL	SET UP ERASE REQUEST
;++
; SETUP_ERASE
;
; THE ERASE I/O REQUEST IS IMPLEMENTED AS A MODIFIED IO$_WRITExBLK REQUEST.
; THIS SCHEME ALLOWS THE ERASE FUNCTION TO BE USED AS A VIRTUAL, LOGICAL,
; OR PHYSICAL I/O REQUEST, AND HAS THE ADDITIONAL ADVANTAGE OF NOT REQUIRING
; EXISTING DISK DRIVERS TO RECODE THEIR FDT TABLES TO USE THE NEW I/O FUNCTION.
;
; THERE ARE SEVERAL WAYS TO PROCESS THE ERASE REQUEST, DEPENDING ON 1) THE SIZE
; OF THE TRANSFER, 2) THE ERASE PATTERN (ZERO OR NONZERO), AND THE LEVEL OF
; HARDWARE SUPPORT.  THE VARIOUS CASES ARE PRESENTED BELOW.  NOTE THAT FOR DEVICES
; THAT HAVE HARDWARE SUPPORT, IT IS NOT NECESSARY, IN SOME CASES, TO TRANSFER DATA
; FROM THE HOST TO THE DEVICE.  WE CAN TAKE ADVANTAGE OF THIS, AND NOT HAVE TO
; SET UP AND MAP AN ERASE PATTERN BUFFER.  WHEN THE HARDWARE SUPPORT IS NOT
; AVAILABLE OR PRACTICAL, THE ERASE IS PROCESSED IN A MANNER SIMILAR TO A WRITE
; REQUEST.  HOWEVER, TO MINIMIZE OVERHEAD, THE ERASE BUFFER IS ONLY 1 PAGE LONG,
; AND A SPECIAL PSUEDO PAGE TABLE (PPT) IS CREATE TO MAP THAT BUFFER.  EACH PTE
; IN THE PPT MAPS THE ERASE BUFFER.  THIS ALLOWS NORMAL DMA TRANSFER FROM THE
; HOST TO THE DEVICE.  SINCE MOST ERASE REQUESTS USE A PATTERN OF ZERO, AND ARE
; LESS THAN OR EQUAL TO 127 PAGES LONG, THE SYSTEM PREALLOCATES A PAGE-ALIGNED
; 512 BYTE ERASE PATTERN BUFFER (EPB) AND A ONE PAGE PPT TO MAP IT.  NOTE THAT
; ONE PAGE OF PTE'S WILL ALLOW TRANSFERS OF UP TO 127 PAGES.
;
;	CASE 0: TARGET DEVICE IS A 'TAPE CLASS' DEVICE
;
;			THE ERASE QIO IS LEGAL ONLY FOR THOSE TAPE DEVICES THAT
;			HAVE SPECIAL HARDWARE SUPPORT, NAMELY A DATA SECURITY
;			ERASE (DSE) FUNCTION.  THIS FUNCTION WILL START AT THE
;			CURRENT TAPE POSITION, ERASE UNTIL TEN FEET PAST THE EOT
;			MARK, AND REWIND THE TAPE TO THE STARTING POSITION.  THE
;			HARDWARE DOES NOT ACCEPT A LENGTH OR ERASE PATTERN ARGUEMENT,
;			SO BOTH P1 AND P2 (IN R0 AND R1) ARE IGNORED.  MAP A
;			VIRTUAL WRITE TO A LOGICAL WRITE, SO THAT IMPLICIT TRANSFER
;			LENGTH CHECKS ARE AVOIDED.  THE FUNCTION CODE WILL BE
;			MAPPED TO IO$_DSE BY ACP$WRITEBLK BEFORE QUEUING THE
;			REQUEST TO THE DRIVER.
;
;	CASE 1: PATTERN IS ZERO, HARDWARE SUPPORT, TRANSFER LENGTH IRRELEVENT
;			IRP$L_SVAPTE =	0
;
;			TO SIGNAL THE DRIVER TO USE THE HARDWARE ERASE
;			FEATURE, THE FUNCTION CODE IS CHANGED TO IO$_DSE.
;			HOWEVER, SINCE THE CALLER (ACP$WRITEBLK) WOULD
;			FAIL IF THE FUNCTION CODE IS CHANGED PREMATURELY,
;			IT IS NOT CHANGED UNTIL JUST BEFORE THE REQUEST IS
;			QUEUED TO THE DRIVER.  FOR THIS TO HAPPEN, THE
;			IO$M_ERASE BIT MUST BE SET, AND IRP$L_SVAPTE MUST
;			BE ZERO.
;
;	CASE 2: PATTERN IS ZERO, NO HARDWARE SUPPORT, TRANSFER <= 127 PAGES
;			IRP$L_SVAPTE =	ADDRESS OF PREALLOCATED PPT
;
;	CASE 3: PATTERN IS ZERO, NO HARDWARE SUPPORT, TRANSFER > 127 PAGES
;			IRP$L_SVAPTE =	ADDRESS OF FIRST PTE WITHIN THE PPT
;					THAT WAS CREATED FROM POOL
;			*** NOTE ***
;			CASE 3 NOW COLLAPSES INTO CASE 2 WITH THE AUTOMATIC
;			SEGMENTATION OF LOGICAL I/O REQUESTS.  NOTE THAT
;			THE SVAPTE IS NOT ADVANCED DURING SEGMENTATION, WHICH
;			ALLOWS THE SYSTEM PPT TO HANDLE TRANSFERS OF ANY LENGTH.
;
;	CASE 4:	PATTERN IS NONZERO
;			IRP$L_SVAPTE =	ADDRESS OF FIRST PTE WITHIN THE PPT
;					THAT MAPS THE EPB.  BOTH THE PPT AND
;					EPB ARE BUILT OUT OF THE SAME PIECE
;					OF POOL, WITH THE PPT STARTING DIRECTLY
;					AFTER THE 12 BYTE HEADER, AND THE EPB
;					STARTING ON THE FIRST PAGE BOUNDARY
;					BELOW THE END OF THE PPT.
;
; THE SYSTEM RESOURCE USAGE:
;
;	IF THE ERASE PATTERN IS ZERO, THEN NO SYSTEM RESOURCES ARE USED.
;	OTHERWISE, AN EPB AND PPT TO MAP IT MUST BE CREATED FROM SYSTEM
;	NONPAGED POOL.  THE COST IN POOL IS
;
;	    COST = POOL_HEADER  + EPB  +  PPT
;	    COST = 12		+ 1024 +  (4*MIN(XFER_SIZE/512),128)
;	    COST = 1548 BYTES OF POOL, WORST CASE.
;
; NOTE THAT THE I/O POST PROCESSING ROUTINE IS RESPONSIBLE FOR CLEANING
; UP AFTER THE ERASE I/O COMPLETES, AND WILL RETURN ALL BORROWED RESOURCES
; BACK TO THE SYSTEM.  THE PREALLOCATED EPB AND PPT ARE SHARED RESOURCES.
;
; INPUTS:
;
;	R0 = SCRATCH
;	R1 = SCRATCH
;	R2 = SCRATCH
;	R3 = ADDRESS OF I/O REQUEST PACKET
;	R4 = CURRENT PROCESS PCB ADDRESS
;	R5 = ADDRESS OF DEVICE UCB
;	R6 = ADDRESS OF CCB
;	R7 = I/O FUNCTION CODE BIT NUMBER
;	R8 = FUNCTION DECISION TABLE DISPATCH ADDRESS
;	R9 = SCRATCH
;	R10= SCRATCH
;	R11= ADDRESS OF EXE$CHKWRTACCES
;	AP = ADDRESS OF FIRST FUNCTION DEPENDENT PARAMETER
;	P1(AP) = ADDRESS OF ERASE PATTERN BUFFER
;	P2(AP) = NUMBER OF BYTES TO ERASE
;
; OUTPUT:
;
;	NONE.
;
; IMPLICIT INPUT:
;
;	EXE$GL_ERASEPPT	: CONTAINS THE ADDRESS OF THE PREALLOCATED PPT
;	EXE$GL_ERASEPB	: CONTAINS THE ADDRESS OF THE PREALLOCATED EPB
;
; IMPLICIT OUTPUT:
;
;	- ALL NON-SCRATCH REGISTERS ARE PRESERVED
;	- IRP$L_SVAPTE(R3) IS ALTERED
;	- IRP$L_BCNT(R3) CONTAINS NUMBER OF BYTES TO TRANSFER
;--

SETUP_ERASE:				; PROCESS ERASE REQUEST
	MOVL	P1(AP),R0		; GET THE ERASE PATTERN ADDRESS
	MOVL	P2(AP),R1		; GET THE TRANSFER BYTE COUNT
	CLRW	IRP$W_BOFF(R3)		; ASSUME EPB IS PAGE-ALIGNED
	CLRL	IRP$L_SVAPTE(R3)	; ASSUME DEVICE HAS HARDWARE SUPPORT
;
; PEFORM A SANITY CHECK TO ENSURE THIS REQUEST IS TO A DISK OR TAPE.
; IF NOT, TRANSFER CONTROL TO THE NORMAL BUFFER CHECK ROUTINE.
;
	CMPB	#DC$_DISK,-		; IS THIS A DISK DEVICE?
		UCB$B_DEVCLASS(R5)	;
	BEQL	30$			; BRANCH IF SO
	CMPB	#DC$_TAPE,-		; IS THIS A TAPE DEVICE?
		UCB$B_DEVCLASS(R5)	;
	BNEQ	10$			; BRANCH IF NOT
	CLRL	IRP$L_BCNT(R3)		; NO DATA TO TRANSFER
	CMPZV	#IRP$V_FCODE,-		; IS THIS A VIRTUAL WRITE?
		#IRP$S_FCODE,-		;
		IRP$W_FUNC(R3),-	;
		#IO$_WRITEVBLK		;
	BNEQ	50$			; BRANCH IF NOT (RETURN)
	MOVZWL	#SS$_ILLIOFUNC,R0	; DO NOT ALLOW VIRTUAL ERASE TO TAPES
	BRB	80$			;  (ERASE FORGETS TAPE POSITION)
10$:	BRW	EXE$WRITELOCK		; OTHERWISE USE 'NORMAL' ROUTINE
20$:	MOVZWL	#SS$_NORMAL,R0		; SET SUCCESS STATUS
	BRW	EXE$FINISHIOC		; COMPLETE THE I/O REQUEST
;
; ROUND THE BYTE TRANSFER COUNT UP TO THE NEAREST MULTIPLE OF 512.
; THIS ENSURES THAT NO PART OF A DISK BLOCK WILL BE UNTOUCHED.
;
30$:	TSTL	R1			; CHECK BYTE COUNT
	BEQL	20$			; BRANCH IF NO BYTES TO TRANSFER
	MOVAB	^X1FF(R1),R1		; ROUND UP TO NEXT PAGE
	BICW	#^X1FF,R1		; TRUNCATE TRANSFER COUNT TO PAGE #
	MOVL	R1,IRP$L_BCNT(R3)	; SAVE R1
;
; DETECT AND PROCESS 'CASE 1' ERASE REQUESTS. THIS CASE IS HANDLED
; FIRST BECAUSE IT IS THE SIMPLEST TO PROCESS AND OCCURS MOST FREQUENTLY.
;
	TSTL	R0			; CHECK ERASE PATTERN ADDRESS
	BEQL	40$			; BRANCH IF ZERO - ASSUME PATTERN = 0
	IFNORD	#4,(R0),70$		; BRANCH IF NO READ ACCESS
	MOVL	(R0),R0			; GET ERASE PATTERN
40$:	BNEQ	60$			; BRANCH IF PATTERN NONZERO
	BBC	#DEV$V_RCT,-		; BRANCH IF NOT MSCP DEVICE
		UCB$L_DEVCHAR(R5),60$	;  OTHERWISE WE'RE DONE (CASE 1)
50$:	RSB				; RETURN
;
; IF WE GET THIS FAR, IT MEANS THIS IS NOT A 'CASE 1' ERASE REQUEST.
; THIS MEANS THAT THERE IS NO HARDWARE SUPPORT (VERY LIKELY), AND/OR
; THE ERASE PATTERN IS NONZERO (VERY UNLIKELY).  THE PREALLOCATED
; EPB AND PPT WILL BE USED WHENEVER POSSIBLE.
;
60$:	MOVL	G^EXE$GL_ERASEPPT,-	; USE SYSTEM PPT - PUT ADDRESS IN IRP
		IRP$L_SVAPTE(R3)	;   SVAPTE NONZERO FOR ROBUSTNESS
	TSTL	R0			; IS ERASE PATTERN ZERO?
	BNEQ	90$			; BRANCH IF NOT - DO IT THE HARD WAY
	RSB				; RETURN - 'CASE 2' DONE
70$:	MOVZWL	#SS$_ACCVIO,R0		; INDICATE ACCESS VIOLATION
80$:	BRW	EXE$ABORTIO		; ABORT THE I/O
;
; 'CASE 4' ERASE REQUESTS ARE HANDLED HERE.
; ALLOCATE A BLOCK OF POOL LARGE ENOUGH TO CONTAIN A PAGE-ALIGNED
; ERASE PATTERN BUFFER AND A PPT LARGE ENOUGH TO MAP IT.  SINCE
; THE SVAPTE IS NOT ADVANCED FOR ERASE I/O, AN ARBITRARILY LARGE
; ERASE REQUEST CAN BE MAPPED BY A ONE PAGE PPT.
; THERE IS AN ADDITIONAL 12 BYTES OF OVERHEAD FOR THE USUAL HEADER.
;
90$:	ASHL	#-7,R1,R9		; CALC BYTES OF PTE'S IN PPT
	MOVZWL	#512,R2			; LOAD VALUE INTO REGISTER
	CMPL	R9,R2			; IS THE PPT BIGGER THAN ONE PAGE?
	BLEQ	100$			; BRANCH IF NOT
	MOVL	R2,R9			; TRUNCATE PPT TO ONE PAGE
100$:	MOVAB	12+512(R2)[R9],R1	; CALC NUMBER OF BYTES IN PPT
	PUSHL	R3			; SAVE IRP ADDRESS
	MOVL	R0,R10			; SAVE ERASE PATTERN
	BSBW	EXE$ALLOCBUF		; ALLOCATE THE EPB
	POPL	R3			; RESTORE IRP ADDRESS
	BLBC	R0,80$			; EXIT IF ERROR
	MOVAB	12(R2),IRP$L_SVAPTE(R3)	; SET ADDRESS OF FIRST PTE
;
; THE CHUNK OF POOL FOR THE EPB AND PPT IS ALLOCATED.
; CALCULATE THE ADDRESS OF THE EPB WITHIN THE CHUNK AND FILL IT IN.
; THEN FETCH THE PTE OF THE EPB AND FILL IN PPT.
;
	MOVAB	12+511(R2)[R9],R2	; CALC ADDRESS OF END OF THE PPT
	BICW	#VA$M_BYTE,R2		; PAGE ALIGN THE BUFFER
	MOVZWL	#512,R1			; SET SIZE OF EPB
	MOVL	R10,R0			; RESTORE PATTERN TO R0
	BSBB	FILL_BUFFER		; FILL ERASE BUFFER
	EXTZV	#VA$V_VPN,#VA$S_VPN,-	; EXTRACT VIRTUAL PAGE NUMBER
		R2,R0			;
	MOVL	@MMG$GL_SPTBASE[R0],R0	; GET PTE THAT MAPS THE EPB
	INSV	#PRT$C_UR,#PTE$V_PROT,-	; MAKE PTE USER READABLE
		#PTE$S_PROT,R0
	MOVL	R9,R1			; SIZE OF PAGE TABLE
	MOVL	IRP$L_SVAPTE(R3),R2	; GET ADDRESS OF FIRST PTE IN PPT
	BSBB	FILL_BUFFER		; PROPAGATE PTE THROUGHOUT PPT
	RSB				; RETURN

	.SBTTL	FILL BUFFER (ERASE QIO)
;++
; FILL_BUFFER
;
;	THIS IS LOCAL SUBROUTINE USED BY THE SETUP_ERASE ROUTINE TO
;	PROPAGATE A 4 BYTE PATTERN THROUGHOUT A CONTIGUOUS RANGE OF
;	BYTES.  THE NUMBER OF BYTES IS ASSUMED TO BE AN INTEGER NUMBER
;	OF LONGWORDS.
;
; INPUT:
;
;	R0 = 4 BYTE PATTERN
;	R1 = LENGTH OF BUFFER
;	R2 = ADDRESS OF BUFFER
;
; OUTPUT:
;
;	NONE.
;
; SIDE EFFECTS:
;
;	THE BUFFER IS FILLED.
;	ALL REGISTERS ARE PRESERVED.
;	NO ROUTINE VALUE IS RETURNED.
;--

FILL_BUFFER:				; PROPAGATE A LONGWORD INTO A BUFFER
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	; SAVE REGISTERS
	TSTL	R0			; CHECK FOR A PATTERN OF 0
	BNEQ	100$			; BRANCH IF NOT ZERO
10$:	MOVC5	#0,(R2),R0,R1,(R2)	; DO IT THE FAST WAY
69$:	POPR	#^M<R0,R1,R2,R3,R4,R5>	; RESTORE REGISTERS
	RSB
;
; IF THE PATTERN IS SIGNIFICANT TO ONE BYTE, USE THE MOVC5.
;
100$:	CMPB	R0,1(SP)		; ARE THE FIRST TWO BYTES IDENTICAL?
	BNEQ	200$			; BRANCH IF NOT
	CMPW	R0,2(SP)		; ARE THE FIRST TWO WORDS IDENTICAL?
	BEQL	10$			; YES - USE THE MOVC5
;
; THE PATTERN CANNOT BE PROPAGATED VIA A MOVC INSTRUCTION.
; ATTEMPT TO MOVE 32 BYTES AT A TIME VIA A MOVQ LOOP.
; ALL REMAINING BYTES WILL BE MOVED A LONGWORD AT A TIME.
;
200$:	MOVL	R1,R3			; COPY SIZE OF BUFFER
	CLRL	R4			; CLEAR FOR EDIV
	EDIV	#32,R3,R3,R4		; R3 = # OF 32 BYTE CHUNKS, R4 = REM.
	ASHL	#-2,R4,R4		; CONVERT R4 TO # OF LONGWORDS
	MOVL	R0,R1			; SET UP FOR QUADWORD MOVE
	TSTL	R3			; MAKE SURE THE BUFFER IS BIG ENOUGH
	BEQL	220$			; BRANCH IF NOT
210$:	MOVQ	R0,(R2)+		; MOVE A QUADWORD
	MOVQ	R0,(R2)+		; MOVE A QUADWORD
	MOVQ	R0,(R2)+		; MOVE A QUADWORD
	MOVQ	R0,(R2)+		; MOVE A QUADWORD
	SOBGTR	R3,210$			; DECREMENT COUNTER AND LOOP IF MORE
220$:	TSTL	R4			; CHECK REMAINDER
230$:	BEQL	69$			; BRANCH IF NONE
	MOVL	R0,(R2)+		; MOVE A LONGWORD
	DECL	R4			; DECREMENT COUNTER
	BRB	230$			; LOOP	

	.SBTTL	BUILD ACP BUFFER
;
; SUBROUTINE TO BUILD ACP BUFFER
;
 
	.ENABL	LSB
BUILDACPBUF:				;BUILD ACP BUFFER
	MOVAB	-MXDESCR*8(SP),SP	;ALLOCATE SPACE FOR MAXIMUM DESCRIPTORS
	MOVL	SP,R11			;SET ADDRESS TO STORE DESCRIPTORS
	MOVL	#16,R10			;SET INITIAL BYTE COUNT
	MOVL	#4,(R11)+		;INSERT WINDOW ADDRESS LENGTH AND ACCESS MODE
	MOVAL	CCB$L_WIND(R6),(R11)+	;INSERT WINDOW ADDRESS
	BSBW	CHKDESCR		;INSERT FIB DESCRIPTOR
	CMPB	#IO$_DEACCESS,R7	;IS OPERATION A DEACCESS
	BNEQ	3$			;IF NEQ, NO
	CMPL	CCB$L_UCB(R6),IRP$L_UCB(R3) ;IS OPERATION FOR IMPLICIT SPOOLING
	BEQL	3$			;IF EQL, NO
	MOVL	#12+8,R0		;SIZE OF USER NAME PLUS ACCOUNT
	MOVAB	CTL$T_USERNAME,R1	;ADDRESS OF THOSE IN P1 SPACE
	BSBW	UPBYTCNT		;INSERT DESCRIPTOR FOR NAME AND ACCOUNT
	TSTL	(AP)+			;IGNORE FILE NAME ARGUMENT
	BRB	7$			;
3$:	BSBW	CHKDESCR		;INSERT NAME STRING DESCRIPTOR
7$:	MOVL	(AP)+,R0		;GET ADDRESS TO STORE RESULT STRING LENGTH
	BEQL	10$			;IF EQL NONE SPECIFIED
	MOVL	R0,R1			;SET ADDRESS OF RESULT LENGTH
	MOVL	#2,R0			;GET LENGTH OF RESULT LENGTH
	IFNOWRT	R0,(R1),ACCVIO		;CAN RESULT LENGTH BE WRITTEN?
10$:	BSBW	UPBYTCNT		;INSERT DESCRIPTOR AND UPDATE BYTE ACCUMULATION
	BSBW	CHKDESCR		;INSERT RESULT STRING DESCRIPTOR
	MOVL	#MXDESCR-5,R9		;SET MAXIMUM NUMBER OF ATTRIBUTE DESCRIPTORS
	MOVL	(AP),AP			;GET ADDRESS OF ATTRIBUTE LIST
	BEQL	30$			;IF EQL NONE SPECIFIED

	CLRL	R1			;INIT CURRENT ACCESS MODE (KERNEL)
20$:	IFNORD	#2,(AP),ACCVIO		;CAN ATTRIBUTE LENGTH BE READ?
	MOVW	(AP)+,(R11)+		;INSERT ATTRIBUTE LENGTH
	BEQL	30$			;IF EQL END OF ATTRIBUTE LIST
	IFNORD	#6,(AP),ACCVIO		;CAN REST OF ATTRIBUTE DESCRIPTOR BE READ?
	MOVW	(AP)+,(R11)+		;INSERT ATTRIBUTE NUMBER
	MOVL	(AP)+,(R11)+		;INSERT ATTRIBUTE ADDRESS

	CMPW	#ATR$C_ACCESS_MODE,-	;CHECK FOR CHANGE ACCESS MODE ATTRIBUTE
		-6(R11)
	BEQL	NEWMODE			;IT IS, SO SPECIAL CASE 

	PUSHR	#^M<R1,R3>		;SAVE IRP ADDRESS AND CURRENT ACCESS MODE
	MOVL	R1,R3			;SPECIFY MODE
	MOVZWL	-8(R11),R1		;GET LENGTH
	MOVL	-4(R11),R0		;GET ADDRESS OF BUFFER	
	JSB	EXE$PROBEW		;PROBE BUFFER
	POPR	#^M<R1,R3>		;RESTORE REGISTERS
	BLBC	R0,ACCVIO		;IF LBC, NO WRITE ACCESS

25$:	ADDW	-8(R11),R10		;UPDATE BYTE ACCUMULATION
	BCS	35$			;IF CS ACCUMULATION OVERFLOW
	SOBGTR	R9,20$			;ANY MORE ATTRIBUTES TO PROCESS?
30$:	SUBL3	R9,#MXDESCR,R9		;CALCULATE TOTAL NUMBER OF DESCRIPTORS
	MULL3	#9,R9,AP		;CALCULATE BYTES REQUIRED BY DESCRIPTORS
	ADDW	AP,R10			;UPDATE BYTE ACCUMULATION
35$:	BCS	BRXQUOTA		;IF CS ACCUMULATION OVERFLOW
	PUSHL	R3			;SAVE I/O PACKET ADDRESS
	MOVL	R10,R1			;SET NUMBER OF BYTES REQUIRED
	BSBW	EXE$BUFFRQUOTA		;CHECK BUFFER BYTE COUNT QUOTA
	BLBC	R0,40$			;IF LBC QUOTA EXCEEDED
	MOVL	R10,R1			;SET NUMBER OF BYTES REQUIRED
	BSBW	EXE$ALLOCBUF		;ALLOCATE BUFFERED I/O BUFFER
	BLBS	R0,50$			;IF LBS SUCCESSFUL ALLOCATION
 
;
; QUOTA CHECK OR BUFFER ALLOCATION FAILURE
;
 
40$:	POPR	#^M<R3>			;RETRIEVE I/O PACKET ADDRESS
42$:	BRW	EXE$ABORTIO
;
; ACCESS VIOLATION ON DESCRIPTOR OR INFORMATION STRING
;
 
ACCVIO:	MOVZWL	#SS$_ACCVIO,R0		;SET ACCESS VIOLATION
	BRB	42$

;
; CHANGE ACCESS MODE ATTRIBUTE PROCESSING
;
NEWMODE:
	PUSHL	R3			;SAVE IRP
	CLRL	R3			;SPECIFY MODE (MAXIMIZE CALLERS MODE)
	MOVZWL	-8(R11),R1		;GET LENGTH
	MOVL	-4(R11),R0		;GET ADDRESS OF BUFFER	
	JSB	EXE$PROBEW		;PROBE BUFFER
	POPL	R3
	BLBC	R0,ACCVIO		;IF LBC, NO WRITE ACCESS
	MOVL	-4(R11),R0		;GET ADDRESS OF USER BUFFER
	MOVZBL	(R0),R1			;LOAD NEW CURRENT ACCESS MODE
	BRB	25$			;AND REJOIN MAINLINE PATH
 
BRXQUOTA:BRB	XQUOTA			;
;
; ACP BUFFER ALLOCATED AND ALL DESCRIPTORS CHECKED
;
 
50$:	POPR	#^M<R3>			;RETRIEVE I/O PACKET ADDRESS
	MOVL	R2,IRP$L_SVAPTE(R3)	;INSERT ADDRESS OF ACP BUFFER
	MOVL	R9,IRP$L_BCNT(R3)	;INSERT NUMBER OF DESCRIPTORS
	MOVW	R10,IRP$W_BOFF(R3)	;SET NUMBER OF BYTES CHARGED TO QUOTA
	BISW	#IRP$M_COMPLX!-		;SET COMPLEX BUFFERED I/O AND
	IRP$M_FILACP!IRP$M_VIRTUAL,IRP$W_STS(R3) ; VIRTUAL, COMPLEX FILE ACP I/O
	DECW	PCB$W_DIOCNT(R4)	;CHARGE A DIRECT I/O
	MOVAL	12(R2),(R2)+		;SET POINTER TO FIRST DESCRIPTOR
	CLRL	(R2)+			;CLEAR SPARE LONGWORD
	MOVW	R10,(R2)+		;SET SIZE OF BUFFER
	MOVZBW	#DYN$C_BUFIO,(R2)+	;SET DATA STRUCTURE TYPE
	MOVL	PCB$L_JIB(R4),AP	;GET JIB ADDRESS
	MOVZWL	R10,R10			;CONVERT TO LONGWORD
	SUBL	R10,JIB$L_BYTCNT(AP)	;UPDATE CURRENT BUFFERED I/O USAGE
	MULL3	#8,R9,AP		;CALCULATE OFFSET TO START OF DATA AREA
	ADDL	R2,AP			;CALCULATE ADDRESS OF DATA AREA
	MOVL	R2,R10			;SET ADDRESS OF FIRST OUTPUT DESCRIPTOR
	MOVL	SP,R11			;SET ADDRESS OF FIRST INPUT DESCRIPTOR
	PUSHR	#^M<R3,R4,R5>		;SAVE REGISTERS R3, R4, AND R5
	BSBB	WRDESCR			;PROCESS WINDOW ADDRESS DESCRIPTOR
	BSBB	RDDESCR			;PROCESS FIB DESCRIPTOR
	BSBB	RDDESCR			;PROCESS NAME STRING DESCRIPTOR
	BSBB	RDDESCR			;PROCESS RESULT STRING LENGTH DESCRIPTOR
	BSBB	RDDESCR			;PROCESS RESULT STRING DESCRIPTOR
	SUBL	#5,R9			;CALCULATE NUMBER OF REMAINING DESCRIPTORS
	BEQL	70$			;IF EQL NONE
60$:	BSBB	RDDESCR			;PROCESS ATTRIBUTE DESCRIPTOR
	SOBGTR	R9,60$			;ANY MORE ATTRIBUTES TO PROCESS?
70$:	POPR	#^M<R3,R4,R5>		;RESTORE REGISTERS R3, R4, AND R5
	MOVAB	MXDESCR*8(SP),SP	;REMOVE DESCRIPTOR STORAGE FROM STACK
	MOVL	CCB$L_UCB(R6),IRP$L_MEDIA(R3) ;INSERT ORIGINAL UCB ADDRESS
	SETIPL	#IPL$_SYNCH		;SYNCHRONIZE ACCESS TO SYSTEM DATA BASE
	RSB				;
BRACCVIO1:
	POPL	R0
BRACCVIO:				;
	BRW	ACCVIO			;
 
;
; BYTE ACCUMULATION OVERFLOW
;
 
XQUOTA:	MOVZWL	#SS$_EXQUOTA,R0		;SET QUOTA EXCEEDED
	BRW	EXE$ABORTIO
	.DSABL	LSB

	.SBTTL	CHECK DESCRIPTOR AND UPDATE BYTE ACCUMULATION
;
; SUBROUTINE TO CHECK PARAMETER DESCRIPTOR AND UPDATE BYTE ACCUMULATION
;
 
CHKDESCR:				;CHECK PARARMETER DESCRIPTOR
	MOVL	(AP)+,R0		;GET ADDRESS OF DESCRIPTOR
	BEQL	UPBYTCNT		;IF EQL NONE SPECIFIED
	IFNORD	#8,(R0),BRACCVIO	;CAN DESCRIPTOR BE READ?
	MOVZWL	(R0),R1			;GET LENGTH OF INFORMATION STRING
	BEQL	UPBYTCT1		;IF EQL ZERO LENGTH
	MOVL	4(R0),R0		;GET ADDRESS OF INFORMATION STRING
	PUSHL	R1			;SAVE REGISTERS
	PUSHL	R0
	PUSHL	R3
	CLRL	R3			;SPECIFY MODE
	JSB	EXE$PROBEW		;PROBE FOR WRITE ACCESS
	POPL	R3			;RESTORE REGISTERS
	POPL	R1			; (SWAP R0 & R1)
	BLBC	R0,BRACCVIO1		;IF LBC, NO ACCESS
	POPL	R0			;RESTORE R0
UPBYTCNT:				;INSERT DESCRIPTOR AND UPDATE BYTE ACCUMULATION
	ADDW	R0,R10			;UPDATE BYTE ACCUMULATION
	BCS	XQUOTA			;IF CS ACCUMULATION OVERFLOW
	MOVW	R0,(R11)+		;INSERT LENGTH OF INFORMATION STRING
	MOVZBW	IRP$B_RMOD(R3),(R11)+	;INSERT ACCESS MODE
	MOVL	R1,(R11)+		;INSERT INFORMATION STRING ADDRESS
	RSB				;
UPBYTCT1:
	MOVL	4(R0),R1		;GET ADDRESS
	CLRL	R0			;WE KNOW IT'S A ZERO COUNT
	BRB	UPBYTCNT		;JOIN COMMON CODE

	.SBTTL	BUILD INFORMATION DESCRIPTOR AND COPY DATA
;
; SUBROUTINE TO BUILD DESCRIPTOR FOR INFORMATION THAT IS BEING READ FROM THE
; CALLING PROCESS' ADDRESS SPACE.
;
 
	.ENABL	LSB
RDDESCR:				;BUILD READ DESCRIPTOR
	PUSHL	#1			;SET READ INDICATOR
	BRB	10$			;
 
;
; SUBROUTINE TO BUILD DESCRIPTOR FOR INFORMATION THAT WILL BE WRITTEN TO THE
; CALLING PROCESS' ADDRESS SPACE.
;
 
WRDESCR:				;BUILD WRITE DESCRIPTOR
	PUSHL	#0			;SET WRITE INDICATOR
10$:	SUBL3	R10,AP,(R10)+		;CALCULATE OFFSET TO DATA AREA
	
	MOVW	(R11)+,-2(R10)		;INSERT LENGTH OF DATA AREA
	MOVB	(R11)+,(AP)+		;INSERT ACCESS MODE OR ATTRIBUTE NUMBER
	INCL	R11			;ADVANCE TO INFORMATION ADDRESS
	MOVL	(R11)+,(R10)+		;INSERT ADDRESS OF INFORMATION
	BLBC	(SP)+,20$		;IF LBC INFORMATION BEING WRITTEN
	
	MOVC	-6(R10),@-4(R10),(AP)	;MOVE INFORMATION TO BUFFER
20$:	MOVZWL	-6(R10),R0		;GET LENGTH OF DATA AREA
	ADDL	R0,AP			;POINT TO NEXT DATA AREA
	RSB				;
	.DSABL	LSB

	.SBTTL	CHECK VOLUME AND UPDATE TRANSACTION COUNT
;
; SUBROUTINE TO CHECK IF VOLUME MARKED FOR DISMOUNT, VOLUME NOT MOUNTED,
; OR VOLUME MOUNTED FOREIGN. IF ALL CHECKS SUCCEED, THEN UPDATE VOLUME
; TRANSACTION COUNT. ELSE RETURN APPROPRIATE ERROR.
;
 
	.ENABL	LSB
CHKDISMOUNT:				;CHECK IF VOLUME MARKED FOR DISMOUNT
	BBS	S^#DEV$V_DMT,UCB$L_DEVCHAR(R5),10$ ;IF SET, VOLUME MARKED FOR DISMOUNT
 
;
; SUBROUTINE TO CHECK IF VOLUME NOT MOUNTED OR MOUNTED FOREIGN. IF BOTH
; CHECKS SUCCEED, THEN UPDATE TRANSACTION COUNT. ELSE RETURN APPROPRIATE
; ERROR.
;
 
CHKMOUNT:				;CHECK IF VOLUME MOUNTED AND NOT FOREIGN
	BBC	S^#DEV$V_MNT,UCB$L_DEVCHAR(R5),10$ ;IF CLR, VOLUME NOT MOUNTED
	BBS	S^#UCB$V_DISMOUNT,UCB$L_STS(R5),10$ ;IF SET, NOT REALLY MOUNTED
	BBS	S^#DEV$V_FOR,UCB$L_DEVCHAR(R5),20$ ;IF SET, VOLUME FOREIGN
 
;
; SUBROUTINE TO UPDATE VOLUME TRANSACTION COUNT. IF THERE IS A FILE OPEN ON
; THE CHANNEL, REDIRECT THE I/O FUNCTION TO THE UCB ON WHICH THE FILE IS
; OPEN.
;
 
UPTRANSCNT:				;UPDATE VOLUME TRANSACTION COUNT
	BBC	#DEV$V_FOD,UCB$L_DEVCHAR(R5),5$ ;BRANCH IF DEVICE IS NOT FILE DEV
	BBS	#DEV$V_SQD,UCB$L_DEVCHAR(R5),5$ ;BRANCH IF DEVICE IS MAGTAPE
	MOVL	IRP$L_WIND(R3),R0	;GET WINDOW ADDRESS FROM IRP
	BEQL	5$			;BRANCH IF NO FILE OPEN
	MOVL	WCB$L_ORGUCB(R0),R5	;GET UCB ADDRESS OF FILE
	CMPL	IRP$L_UCB(R3),IRP$L_MEDIA(R3) ;SEE IF THIS IS A SPOOL OPERATION
	BNEQ	4$			;BRANCH IF YES
	MOVL	R5,IRP$L_MEDIA(R3)	;REDIRECT ALTERNATE UCB AS WELL
4$:	MOVL	R5,IRP$L_UCB(R3)	;REDIRECT UCB ADDRESS IN IRP

5$:	MOVL	UCB$L_VCB(R5),R0	;GET ADDRESS OF VCB
	INCW	VCB$W_TRANS(R0)		;UPDATE VOLUME TRANSACTION COUNT
	RSB				;
 
;
; VOLUME MARKED FOR DISMOUNT OR NOT MOUNTED
;
 
10$:	MOVZWL	#SS$_DEVNOTMOUNT,R0	;SET DEVICE NOT MOUNTED
	BRB	30$
 
;
; DEVICE MOUNTED FOREIGN
;
 
20$:	MOVZWL	#SS$_DEVFOREIGN,R0	;SET DEVICE FOREIGN
30$:	BRW	EXE$ABORTIO


	.DSABL	LSB

	.SBTTL	XQP$UNLOCK_CACHE - Release Cache Contents and Unlock
;++
;
; This subroutine is entered as a system blocking AST when another file
; system in the cluster requests a flush of all caches of a particular
; type. It passes the AST on as a real process AST to the file system's
; cache server process.
;
; INPUTS:
;	R1 = AST parameter
;	   = UCB address + cache type in low bits
;
;--

XQP$UNLOCK_CACHE::
	BICL3	#^X7,R1,R5		; get UCB address
	BICL3	#^C^X7,R1,R0		; and cache type code
	BBC	#DEV$V_MNT,UCB$L_DEVCHAR(R5),40$ ; if not mounted, don't do it
	BBS	#DEV$V_FOR,UCB$L_DEVCHAR(R5),40$ ; if mounted foreign, don't
	MOVL	UCB$L_VCB(R5),R5	; get VCB address
	MOVL	VCB$L_CACHE(R5),R4	; get cache block address
	ASSUME	FIB$C_FID_CACHE EQ 1
	ASSUME	FIB$C_EXTENT_CACHE EQ 2
	ASSUME	FIB$C_QUOTA_CACHE EQ 3
	SUBL	#2,R0			; check cache type
	BGTR	20$			; branch if quota cache
	BEQL	10$			; branch if extent cache
	ADDL3	#VCA$B_FIDCACB,VCA$L_FIDCACHE(R4),R5 ; get file ID cache ACB
	BRB	30$

10$:	ADDL3	#VCA$B_EXTCACB,VCA$L_EXTCACHE(R4),R5 ; get extent cache ACB
	BRB	30$

20$:	MOVL	VCB$L_QUOCACHE(R5),R5	; find quota cache
	BEQL	40$			; branch if none
	ADDL	#VCA$B_QUOFLUSHACB,R5	; get quota cache ACB
30$:	MOVL	R1,ACB$L_ASTPRM(R5)	; set up AST parameter
	MOVL	XQP$GL_FILESERVER,ACB$L_PID(R5) ; and PID
	BEQL	NOACP			; bad news if there isn't one
	MOVL	XQP$GL_FILESERV_ENTRY,ACB$L_AST(R5) ; and address
	CLRL	R2			; no priority boost
	JSB	SCH$QAST		; and queue the AST
	BLBC	R0,NOACP		; bug check if error
40$:	RSB

;
; To here on error returns from SCH$QAST - our server process has disappeared.
;
NOACP:	BUG_CHECK NONEXSTACP,FATAL	; server process disappeared

	.SBTTL	XQP$BLOCK_ROUTINE - Block further XQP activity.
;++
; XQP$BLOCK_ROUTINE
;
; This routine is not an fdt routine, but needs a home in the non-paged exec.
; It is invoked as a system blocking routine.  The lock itself is
; armed by the F11BXQP before the first file system request is performed
; for a given volume as part of mounting the volume.
;
; If the file system quiescent when this routine is called, a kernel
; ast will be queued to execute in the context of the swapper.  That
; routine follows this one.  Otherwise, a flag is set so that all
; further file system requests for the volume are blocked, and the last
; one underway will complete shutting this volume down.
;
; All of this is necessary so that volume rebuild can rummage around
; the volume without other activity messing it up.
;
; The ACB used by this routine is part of the per volume file system
; database in non-paged pool, and was set up by the file system when
; the lock with this blocking routine was armed.
;
; Called at IPL_SYNCH.
;
; INPUTS:
;
;	R1 - blocking routine parameter = address of VCB.
;
; Registers R0 - R5 are available as scratch registers.
;
;--
XQP$BLOCK_ROUTINE::
	TSTW	VCB$W_RVN (R1)		; is this a volume set?
	BNEQ	50$			; Neq it is.
	DECW	VCB$W_ACTIVITY (R1)	; Is volume quiescent?
	BEQL	10$			; EQL it is.
	RSB				; Not quiet.  Exit.

10$:	CLRL	VCB$L_BLOCKID (R1)	; note lock is disarmed.
	ASSUME	VCB$S_ACB EQ ACB$C_LENGTH
;
; There is an ACB block built into each VCB.  The size allocated
; in the VCB MUST match the real VCB.
;
	MOVAB	VCB$B_ACB (R1), R5	; address of ACB
20$:	CLRL	R2			; no priority increment
	BSBW	SCH$QAST		; queue ast to dequeue lock.
	BLBC	R0,NOACP		; bug check if error
30$:	RSB

50$:	MOVL	VCB$L_RVT (R1), R0	; get RVT address.
	DECW	RVT$W_ACTIVITY (R0)	; is volume set quiescent?
	BNEQ	30$			; NEQ not quiet.  Exit.
	CLRL	RVT$L_BLOCKID (R0)
	MOVAB	RVT$B_ACB (R0), R5
	ASSUME	RVT$S_ACB EQ ACB$C_LENGTH
;
; There is an ACB built into each RVT.
; The length provided in the RVT MUST match that of the real ACB.
;
	BRB	20$

	.SBTTL	XQP$DEQBLOCKER - dequeue blocking lock

;++
; XQP$DEQBLOCKER
;
; This routine dequeues the per volume (or volume set) blocking lock.
; It executes as a kernel ast in the context of the swapper.
; It is initiated by the blocking routine above.
;
; The ast parameter is address of the lock id to be dequeued.
;
;--

	.ENTRY	XQP$DEQBLOCKER, 0	; save no registers
	CLRQ	-(SP)			; null arguments
	CLRL	-(SP)
	PUSHL	4(AP)			; lock id to dequeue.
	CALLS	#4,G^SYS$DEQ-P1SYSVECTORS+^X80000000
	BLBC	R0,LOCKERR		; bug check on any error
	RET				; exit.

	.SBTTL	XQP$REL_QUOTA - Release Quota Cache Entry

;++
;
; XQP$REL_QUOTA
;
; This routine is entered by a fork-level blocking AST on a system owned
; quota cache lock. The event of the blocking AST indicates that the cache
; entry is being requested by another processor; therefore, we release
; the lock (and the cache entry contents). The actual releasing of the
; lock is done by an AST queued to the swapper, which executes the routine
; following this one.
;
; Called at IPL$_SYNCH
;
; INPUTS:
;
;	R1 = address of cache entry requested
;
;--

XQP$REL_QUOTA::
;
; There is one ACB for each volume, back in the header of the quota
; cache. We find the cache header by using the cache entry's index
; to subtract back.
;
	MOVZWL	VCA$W_QUOINDEX(R1),R0	; get entry's index
	MULL	#VCA$C_QUOLENGTH,R0	; compute offset in bytes
	ADDL	#VCA$L_QUOLIST-VCA$B_QUOACB-VCA$C_QUOLENGTH,R0
					; add in header, point to ACB
	SUBL3	R0,R1,R5		; point to ACB
	MOVL	R1,ACB$L_ASTPRM(R5)	; AST param is cache entry
	CLRL	R2			; no priority increment
	BSBW	SCH$QAST		; rest of ACB is set up - queue it
	BLBC	R0,NOACP
	RSB				; bug check if error

	.SBTTL	XQP$UNLOCK_QUOTA - Release Lock on Quota Cache Entry

;++
;
; XQP$UNLOCK_QUOTA
;
; This routine executes in the context of the swapper as a kernel AST.
; It dequeues or demotes the lock on the specified quota cache entry
; according to its current status.
;
; INPUTS:
;
;	ASTPARAM = address of quota cache entry
;
;--

ASTPARAM = 4

	.ENTRY	XQP$UNLOCK_QUOTA,^M<R2>	; save R2
	MOVL	ASTPARAM(AP),R2		; get address of cache entry
	ASSUME	VCA$W_QUOINDEX+2 EQ VCA$W_QUOLRUX
	PUSHL	VCA$W_QUOINDEX(R2)	; save cache index and LRU counter
	ASSUME	VCA$V_QUOVALID EQ 0
	BLBS	VCA$B_QUOFLAGS(R2),10$	; branch if valid - demote lock

	CLRQ	-(SP)			; null arguments
	CLRL	-(SP)			; no value block
	PUSHL	VCA$L_QUOLKID(R2)	; lock id to dequeue.
	CALLS	#4, G^SYS$DEQ-P1SYSVECTORS+^X80000000
	BLBC	R0,LOCKERR		; bug check on any error
	ASSUME	VCA$L_QUORECNUM EQ VCA$L_QUOLKID+4
	ASSUME	VCA$B_QUOFLAGS EQ VCA$L_QUORECNUM+3
	CLRQ	VCA$L_QUOLKID(R2)	; mark cache entry vacant
	BRB	20$			; exit
;
; To here if we are converting the lock down, instead of releasing it
; entirely.
;
10$:	CLRQ	-(SP)			; null acmode and extra param
	PUSHAB	XQP$REL_QUOTA		; re-arm same blocking AST
	PUSHL	R2			; cache entry is AST param
	CLRQ	-(SP)			; null astadr and parent ID
	CLRL	-(SP)			; null resource name
	PUSHL	#LCK$M_CONVERT!LCK$M_NOQUEUE!LCK$M_CVTSYS!LCK$M_VALBLK!LCK$M_SYNCSTS
	PUSHAB	VCA$R_QUOLOCK(R2)	; lock status block
	PUSHL	#LCK$K_CRMODE		; lock mode
	CLRL	-(SP)			; null EFN
	CALLS	#11,G^SYS$ENQ-P1SYSVECTORS+^X80000000
	BLBC	R0,LOCKERR		; bug check on any error
	BICB	#VCA$M_QUOVALID,VCA$B_QUOFLAGS(R2) ; mark entry not valid
20$:	MOVL	(SP)+,VCA$W_QUOINDEX(R2) ; restore index and LRU counter
	RET
;
; Bug check on any lock manager errors.
;
LOCKERR:
	BUG_CHECK XQPERR,FATAL

	.SBTTL	XQP$FCBSTALE - Blocking routine to mark FCB as stale.
;++
;
; This routine is a system blocking routine called from the lock manager
; with a jsb at ipl_synch.  It will set the STALE flag in the FCB.
; The blocking routine is associated with the access lock on the file.
;
; INPUTS:
;	R1 = fcb address.
;
;--

XQP$FCBSTALE::
	CMPB	FCB$B_TYPE (R1), #DYN$C_FCB	; Is this an FCB?
	BNEQ	LOCKERR				; Unexpected answer.
	BISW2	#1@FCB$V_STALE, FCB$W_STATUS (R1) ; Set flag.
	RSB					; That's it.	


	.END
