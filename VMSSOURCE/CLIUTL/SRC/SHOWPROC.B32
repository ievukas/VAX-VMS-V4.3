MODULE showprocess (IDENT = 'V04-000',
		  ADDRESSING_MODE (EXTERNAL = GENERAL)) =

BEGIN
!
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
!
!++
!
! FACILITY:  SHOW utility
!
! ABSTRACT:
!	This module contains the routines for the SHOW PROCESS command.
!
! ENVIRONMENT:
!	VAX native, user and kernel mode
!
! AUTHOR:  Gerry Smith		 CREATION DATE:   8-Sep-1982
!
! MODIFIED BY:
!
!	V03-022	MCN0188		Maria del C. Nasr	29-Aug-1984
!		Add routine CHECK_PRIVELEGE to turn off WORLD privelege
!		if the user issuing the SHOW PROCESS command does not
!		have it.
!
!	V03-021	MCN0182		Maria del C. Nasr	24-Jul-1984
!		Add three new quotas returned by GETJPI: MAXDETACH,
!		MAXJOBS, SHRFILLM.  Also, make the sizes in the jpi
!		list match those in $JPIDEF macro.
!
!	V03-020	MCN0181		Maria del C. Nasr	23-Jul-1984
!		Eliminate from the display of SHOW PROC/PRIV some
!		privileges that are not implemented yet (UPGRADE,
!		DOWNGRADE, PRMJNL, TMPJNL).
!
!	V03-019	MCN0178		Maria del C. Nasr	16-Jul-1984
!		Fix misspellings in messages displayed by SHOW PROC/PRIV.
!
!	V03-018	AEW0001		Anne E. Warner		17-May-1984
!		Increase the size of the variable that holds the
!		logical translation of the process default disk 
!		(SYS$DISK) to 256 bytes.  This is to avoid truncation
!		of the disk name when printed.
!
!	V03-017	HH0002		Hai Huang		27-Feb-1984
!		Add job-wide mount support.
!	
!	V03-016 MCN0149		Maria del C. Nasr	08-Feb-1984
!		If SHOW PROCESS/ALL/ID is specified and the process id
!		is not the same as the current process, do not display
!		memory, nor subprocesses.  Also, when the user specified
!		a pid value, call $GETJPI to make sure we work with the
!		extended form.
!
!	V03-015	GAS0187		Gerry Smith		20-Sep-1983
!		Fix up displays for /quota and /accounting.
!
!	V03-014	LMP0140		L. Mark Pilant,		23-Aug-1983  22:43
!		Add support for alphanumeric UICs.
!
!	V03-013	GAS0159		Gerry Smith		26-Jul-1983
!		Fix the display for SHOW PROC/PRIV so that the
!		output is columnar.
!
!	V03-012	GAS0149		Gerry Smith		27-Jun-1983
!		Obtain device names from the common system routine
!		IOC$CVT_DEVNAM.
!
!	V03-011	RSH0020		R. Scott Hanna		21-May-1983
!		Add SECURITY privilege
!
!	V03-010	GAS0131		Gerry Smith		17-May-1983
!		Add the access control rights lists for SHOW PROC/PRIV.
!
!	V03-009	GAS0129		Gerry Smith		28-Apr-1983
!		For MSCP devices, fix display problem that caused the
!		unit number to be zero always.
!
!	V03-008	GAS0124		Gerry Smith		20-Apr-1983
!		Change the name of prv$v_noacnt to ACNT.  Also add 
!		TMPJNL and PRMJNL.
!
!	V03-07	GAS0115		Gerry Smith		 4-Apr-1983
!		Add support for cluster devices.
!
!	V03-006	LMP0083		L. Mark Pilant,		28-Feb-1983  15:27
!		Add support for the new privileges: SHARE, UPGRADE, DOWNGRADE,
!		GRPPRV, and READALL.
!
!	V03-005	CWH1002		CW Hobbs		25-Feb-1983
!		Use a routine to convert the extended pid to a pcb address.
!		Also convert extended pid to ipid to check device allocation.
!		Use SCH$GL_PIXWIDTH to reference pix in epid.  Fix a couple of
!		4 byte iosb's to be 8 bytes.  Use literal SCH$C_SWPPIX to anchor
!		loop through PCBVEC.
!
!	V03-004	GAS0107		Gerry Smith		24-Jan-1983
!		If an error occurs with the /ID qualifier, signal
!		a more reasonable message.
!
!	V03-003	GAS0106		Gerry Smith		21-Jan-1983
!		Change the name SETPRI to ALTPRI, since this is the
!		preferred name.
!
!	V03-002	GAS0104		Gerry Smith		21-Jan-1983
!		Fix the privilege display so that the scan doesn't
!		go beyond the end of the privilege table.
!
!	V03-001	GAS0098		Gerry Smith		7-Jan-1983
!		Add the count of images activated.
!
!--


!
! Include files
!

LIBRARY 'SYS$LIBRARY:LIB';		! VAX/VMS system definitions
REQUIRE 'SRC$:SHOWDEF';			! SHOW common definitions

!
! Define shared messages.
!
$SHR_MSGDEF	(SHOW,120,LOCAL,
    		(INVQUAVAL,ERROR));

!
! Define the linkage for the routines to lock, unlock, and scan  the I/O
! database, as well as the routines to manipulate pids.
!
LINKAGE
    IOLOCK = JSB (REGISTER = 4),
    CVTPID = JSB (REGISTER=0) : PRESERVE (1,2,3,4,5) NOTUSED (6,7,8,9,10,11),
    IOSCAN = JSB (REGISTER = 11,		! Call with DDB,
	    	  REGISTER = 10;		! UCB,
		  REGISTER = 11,		! Return with DDB,
		  REGISTER = 10),		! UCB
    CVTDEV = JSB (REGISTER = 0,			! Length of output buffer,
		  REGISTER = 1,			! Address of output buffer
		  REGISTER = 4,			! Format of device name
		  REGISTER = 5;			! Address of UCB
		  REGISTER = 1);		! Length of final name



!
! Define bits for the flags longword
!
MACRO
    PROC$V_DEF		=	0, 0, 1, 0%,	! print default info
    PROC$V_QUOT		=	0, 1, 1, 0%,	! /QUOTAS
    PROC$V_ACC		=	0, 2, 1, 0%,	! /ACCOUNTING
    PROC$V_PRIV		=	0, 3, 1, 0%,	! /PRIVILEGES
    PROC$V_MEM		=	0, 4, 1, 0%,	! /MEMORY
    PROC$V_SUB		=	0, 5, 1, 0%,	! /SUBPROCESS
    PROC$V_ALL		=	0, 6, 1, 0%,	! /ALL
    PROC$V_ID		=	0, 7, 1, 0%,	! /IDENTIFICATION
    PROC$V_CONT		=	0, 8, 1, 0%;	! /CONTINUOUS

!
! Define the locations of the device name and unit number for allocated
! and mounted devices.
!
MACRO
    d_l_length	= 0, 0, 32, 0%,			! Length of device name
    d_a_ptr	= 4, 0, 32, 0%,			! Address of device name
    d_t_device	= 8, 0,  8, 0%;			! ASCII device name
LITERAL d_k_length = $BYTEOFFSET(d_t_device) + 21;

!
! Define the locations of the owner pix and process pix in the
! structure that contains information about subprocesses.
!
MACRO
    sub_owner = 0, 0, 16, 0%,
    sub_pix   = 2, 0, 16, 0%,
    sub_name  = 4, 0,  8, 0%;

!
! A couple of macros to build the privilege table.
!
MACRO
    text_entry [text] = UPLIT(%ASCIC %STRING(text))%,


    make_priv_table (table_name) =
	LITERAL priv_num = (%LENGTH -1)/2;
	OWN priv_table : VECTOR[%LENGTH]
    			 INITIAL ( text_entry(%REMAINING) );%;

!
! The following set of macros are used to get all the information about
! a particular process.  These macros produce:
!	1. A list of arguments for $FAOL, which are used to output 
!	   information.  The elements in this list are all prefixed 
!	   with 'FAO_'
!	2. A list of auxiliary data buffers.  The elements are all 
!	   prefixed with 'AUX_'
!	3. A GETJPI list which will store all the information requested,
!	   into the FAO_ elements (for 4-byte quantities), or else puts
!	   the data into the AUX_ buffers (for strings) and puts the final
!	   length into the FAO_ buffer.
!
COMPILETIME list_length = 0;

MACRO
    find_length [item, length] =
	%ASSIGN(list_length, list_length + %NUMBER(length))%,

    bind_names (prefix) [item, length] =
	%NAME(prefix, item) = %NAME(prefix, 'list')[%NUMBER(list_length)/4]
	%ASSIGN(list_length, list_length + %NUMBER(length))%,

    define_fao_items (list) = 
	%ASSIGN(list_length, 0)
	find_length(%EXPAND list, %REMAINING)
	OWN fao_list : VECTOR[%NUMBER(list_length)/4];
	%ASSIGN(list_length, 0)
	BIND bind_names(fao_, %EXPAND list, %REMAINING);%,

    define_auxiliary_items (list) =
	%ASSIGN(list_length, 0)
	find_length(%EXPAND list, %REMAINING)
	OWN aux_list : VECTOR[%NUMBER(list_length)/4];
	%ASSIGN(list_length, 0)
	BIND bind_names(aux_, %EXPAND list, %REMAINING);%,

    set_jpi [item, length, buffer, reslen] =
	%NAME('jpi$_',item)^16 + length,
	buffer,
	reslen%,

    define_jpi_list (list) =
	OWN jpi_list : VECTOR[3 * (%LENGTH/4) + 1]
	    INITIAL (set_jpi(%EXPAND list, %REMAINING), 0);%;


!
! Define the FAO list.  This list is ordered, so that all the data for
! a particular call to SHOW$WRITE_LINE occurs sequentially.  That way,
! an argument list is not needed; instead, the address of the first 
! piece of data is given, and the rest just naturally follow.
!
define_fao_items(

! Header information
	    systime,		4,		! Dummy (for current date)
	    terminal,		8,		! terminal name
	    username,		8,		! username
! Default information
	    pid,		4,		! process ID
	    prcnam,		8,		! process name
	    uic,		4,		! UIC
	    prib,		4,		! base priority
	    defdev,		8,		! default device string
	    defdir,		4,		! default directory
! Quota information
	    account,		8,		! account name
	    cpulim,		8,		! cpu limit
	    diolm,		4,		! direct i/o limit
	    bytcnt,		4,		! byte count limit
	    biolm,		4,		! buffered i/o limit
	    tqcnt,		4,		! timer que entry limit
	    filcnt,		4,		! open file limit
	    pagfilcnt,		4,		! paging file quota
	    prclm,		4,		! subprocess quota
	    dfpfc,		4,		! default page fault cluster
	    astcnt,		4,		! ast quota
	    enqcnt,		4,		! enque limit
	    shrfillm,		4,		! shared file limit
	    maxdetach,		4,		! maximum num of detached processes
	    maxjobs,		4,		! maximum num of active jobs
! Accounting information
	    bufio, 		4, 		! buffered i/o count
	    wspeak,		4,		! peak working set
	    dirio, 		4, 		! direct i/o count
	    virtpeak,		4,		! virtual memory peak
	    pageflts,		4,		! page fault count
	    volumes,		4,		! count of mounted volumes
	    imagecount,		4,		! Count of images executed
	    cputim, 		4,		! cpu time -- later points to quad cputim
	    logintim,		8);		! login time (quadword)

!
! Define the auxiliary buffers.  This includes any strings that are returned,
! as well as the process privileges.
!
define_auxiliary_items(
	    terminal,		16,		! terminal name
	    username,		16,		! username
	    prcnam,		16,		! process name
	    defdev,		256,		! default device string
	    account,		16,		! account name
	    cpulim,		16,		! cpu limit 
	    jobprccnt,		4,		! total process count
	    cputim,		8,		! Quad CPU time
	    logintim,		8,		! login time (quadword)
    	    procpriv,		8);		! privilege bits (quadword)

!
! Now declare the $GETJPI item list, telling where the data is to go, and 
! where the resultant string lengths should be stored.
!
define_jpi_list(
	    terminal,	8,	aux_terminal,	fao_terminal,
	    username,	12,	aux_username,	fao_username,
	    pid,	4,	fao_pid,	0,
	    prcnam,	16,	aux_prcnam,	fao_prcnam,
	    uic,	4,	fao_uic,	0,
	    prib,	1,	fao_prib,	0,
	    account,	8,	aux_account,	fao_account,
	    cpulim,	4,	fao_cpulim,	0,
	    diolm,	2,	fao_diolm,	0,
	    bytcnt,	4,	fao_bytcnt,	0,
	    biolm,	2,	fao_biolm,	0,
	    tqcnt,	2,	fao_tqcnt,	0,
	    filcnt,	2,	fao_filcnt,	0,
	    pagfilcnt,	4,	fao_pagfilcnt,	0,
	    prclm,	2,	fao_prclm,	0,
	    dfpfc,	1,	fao_dfpfc,	0,
	    astcnt,	2,	fao_astcnt,	0,
	    enqcnt,	2,	fao_enqcnt,	0,
	    shrfillm,	2,	fao_shrfillm,	0,
	    maxdetach,	2,	fao_maxdetach,	0,
	    maxjobs,	2,	fao_maxjobs,	0,
	    jobprccnt,	2,	aux_jobprccnt,	0,
	    bufio, 	4, 	fao_bufio,	0,
	    wspeak,	4,	fao_wspeak,	0,
	    dirio, 	4, 	fao_dirio,	0,
	    virtpeak,	4,	fao_virtpeak,	0,
	    pageflts,	4,	fao_pageflts,	0,
	    volumes,	4,	fao_volumes,	0,
	    imagecount,	4,	fao_imagecount,	0,
	    cputim, 	4,	fao_cputim,	0,
	    logintim,	8,	aux_logintim,	0,
	    procpriv,	8,	aux_procpriv,	0);

!
! Make a table of all known privileges, containing the privilege name and
! text describing it.
!
! ***** THE PRIVILEGES MUST BE IN BIT NUMBER ORDER *****
!
make_priv_table (priv,
	cmkrnl,	    		'may change mode to kernel',
	cmexec,	    		'may change mode to exec',
	sysnam,	    		'may insert in system logical name table',
	grpnam,	    		'may insert in group logical name table',
	allspool,	    	'may allocate spooled device',
	detach,	    		'may create detached processes',
	diagnose,	    	'may diagnose devices',
	log_io,	    		'may do logical i/o',
	group,	    		'may affect other processes in same group',
	acnt,	    		'may suppress accounting message',
	prmceb,	    		'may create permanent common event clusters',
	prmmbx,	    		'may create permanent mailbox',
	pswapm,	    		'may change process swap mode',
	altpri,	    		'may set any priority value',
	setprv,	    		'may set any privilege bit',
	tmpmbx,	    		'may create temporary mailbox',
	world,	    		'may affect other processes in the world',
	mount,	    		'may execute mount acp function',
	oper,	    		'operator privilege',
	exquota,	    	'may exceede quota',
	netmbx,	    		'may create network device',
	volpro,	    		'may override volume protection',
	phy_io,	    		'may do physical i/o',
	bugchk,	    		'may make bug check log entries',
	prmgbl,	    		'may create permanent global sections',
	sysgbl,	    		'may create system wide global sections',
	pfnmap,	    		'may map to specific physical pages',
	shmem,	    		'may create/delete objects in shared memory',
	sysprv,	    		'may access objects via system protection',
	bypass,	    		'bypasses UIC checking',
	syslck,	    		'may lock system wide resources',
	share,			'may assign channels to non-shared device',
	upgrade,		'may upgrade classification',
	downgrade,		'may downgrade classification',
	grpprv,			'group access via system protection',
	readall,		'may read anything as the owner',
	tmpjnl,			'may create temporary journals',
   	prmjnl,			'may create permanent journals',
	security,		'may perform security functions');

!
! The following GLOBAL declarations are a temporary means of incorporating
! SHOW PROCESS/CONTINUOUS (aka INFO) into this version of SHOW.  It is not
! my intention for it to continue in this way. (Famous last words)
!
GLOBAL
    proc_a_desc : $BBLOCK[dsc$c_s_bln],
    proc_z_name : VECTOR[15,BYTE],
    proc_l_pid;

!
! Table of contents
!

FORWARD ROUTINE
    show$process : NOVALUE,
    check_privilege : NOVALUE,
    display_data : NOVALUE,
    display_tree : NOVALUE,
    make_tree,
    next_process : NOVALUE,
    get_devall,
    get_devmoun,
    display_rights : NOVALUE,
    get_rights_size,
    get_rights;

EXTERNAL ROUTINE
    proc_cont_display : NOVALUE,
    cli$present,
    cli$get_value,
    exe$epid_to_ipid : CVTPID ADDRESSING_MODE (GENERAL),
    exe$epid_to_pcb : CVTPID ADDRESSING_MODE (GENERAL),
    lib$get_vm,
    lib$free_vm,
    lib$cvt_htb,
    sch$iolockr : IOLOCK,
    sch$iounlock : IOLOCK,
    ioc$scan_iodb : IOSCAN,
    ioc$cvt_devnam : CVTDEV,
    show$prcallreg,
    show$write_line : NOVALUE;

EXTERNAL
    ctl$gl_pcb,
    sch$gl_curpcb,
    ioc$gl_devlist,
    scs$ga_localsb,
    pio$gt_ddstring,
    sch$gl_maxpix,
    sch$gl_pixwidth,
    sch$gl_pcbvec : REF VECTOR;

EXTERNAL LITERAL
    sch$c_swppix : UNSIGNED (6);	! A short literal for the swapper pix

BUILTIN SUBM;

GLOBAL ROUTINE show$process : NOVALUE =
BEGIN

!---
!
! This is the main routine for the SHOW PROCESS function.  All the command
! qualifiers are gathered, and a $GETJPIW is issued to get the information.
! If the /CONT qualifier is invoked, the control is transferred to that 
! portion of SHOW.  Otherwise, call the data-display routine.
!
!---

LOCAL
    ourpid,				! This process's PID
    pid,				! PID of requested process
    scratch : REF VECTOR,		! Scratch area
    flags : $BBLOCK[4],			! Flags longword
    procname : $BBLOCK[dsc$c_s_bln];	! Process descriptor

! Check to make sure that the user has the correct privileges to run
! this image.
!
check_privilege ();

!
! Collect the qualifiers.  If no qualifiers were present, then show that only 
! the default stuff should be displayed.
!
flags[proc$v_def] = NOT(
	   (flags[proc$v_quot]	= cli$present(%ASCID 'QUOTAS'))
	OR (flags[proc$v_acc]	= cli$present(%ASCID 'ACCOUNTING'))
	OR (flags[proc$v_priv]	= cli$present(%ASCID 'PRIVILEGES'))
	OR (flags[proc$v_mem]	= cli$present(%ASCID 'MEMORY'))
	OR (flags[proc$v_sub]	= cli$present(%ASCID 'SUBPROCESSES'))
	OR (flags[proc$v_cont]	= cli$present(%ASCID 'CONTINUOUS')));

!
! Get the current process PID.
!
BEGIN
LOCAL
    status,
    iosb : VECTOR[4,WORD],
    list : $BBLOCK[16];
list[ 0, 0, 16, 0] = 4;
list[ 2, 0, 16, 0] = jpi$_pid;
list[ 4, 0, 32, 0] = ourpid;
list[ 8, 0, 32, 0] = 0;
list[12, 0, 32, 0] = 0;
IF (status = $GETJPIW(ITMLST = list,
		      IOSB = iosb))
THEN status = .iosb[0];
IF NOT .status 
THEN (SIGNAL(.status); RETURN);

!
! If a process name was specified, convert it to a PID.
!
pid = 0;				! No PID yet.
$init_dyndesc(procname);		! Set up a dynamic descriptor 
IF cli$get_value(%ASCID 'PROCESS', procname)
THEN
    BEGIN
    list[ 4, 0, 32, 0] = pid;
    IF (status = $GETJPIW(ITMLST = list,
			  PRCNAM = procname,
			  IOSB   = iosb))
    THEN status = .iosb[0];
    IF NOT .status 
    THEN (SIGNAL(.status); RETURN);
    END;
END;

!
! If no process name, then check for a PID.  If the PID was specified, 
!convert the ASCII representation to a number.
!
IF cli$get_value(%ASCID 'IDENTIFICATION', procname)
THEN
    BEGIN
    LOCAL
	iosb : VECTOR[4,WORD],
	list : $BBLOCK[16],
	status;

    IF NOT (status = lib$cvt_htb(.procname[dsc$w_length],
				 .procname[dsc$a_pointer],
				 pid))
    THEN
	BEGIN
	SIGNAL(show$_invquaval,		! Qualifier invalid
	       2,			! with 2 FAO params:
	       procname,		! the ID value given,
	       %ASCID 'IDENTIFICATION'); ! and the /ID qualifier
	RETURN;
	END;

    ! Make sure we get the extended pid, in case the user has used the
    ! short form.
    !

    list[ 0, 0, 16, 0] = 4;
    list[ 2, 0, 16, 0] = jpi$_pid;
    list[ 4, 0, 32, 0] = pid;
    list[ 8, 0, 32, 0] = 0;
    list[12, 0, 32, 0] = 0;
 
    IF (status = $GETJPIW(ITMLST = list,
			  PIDADR = pid,
		 	  IOSB = iosb))
    THEN status = .iosb[0];

    IF NOT .status 
    THEN
	BEGIN
	SIGNAL(.status);
	RETURN;
	END;
    END;

!
! If PID is still zero, then no process was specified, i.e. the
! process in question is the current process.  So, use the current
! process PID.
!
IF .pid EQL 0
THEN pid = .ourpid;

!
! If the /ALL qualifier is present, then turn on the proper bits.
! If the pid is for the current process, then allow memory
! and subprocesses too.
!
IF cli$present(%ASCID 'ALL')
THEN 
    BEGIN
    flags[proc$v_def]	= flags[proc$v_quot] 
    			= flags[proc$v_acc]
			= flags[proc$v_priv]
			= true;

    IF .pid EQL .ourpid
    THEN
    flags[proc$v_mem]	= flags[proc$v_sub]
			= true;
    END;

!
! Now for some further checks.  If /MEMORY or /SUBPROCESSES was
! specified, and the requested process is not the current process,
! then signal that it can't be done.
!
IF .ourpid NEQ .pid
AND (.flags[proc$v_mem] OR .flags[proc$v_sub])
THEN (SIGNAL(show$_confqual); RETURN);

!
! Obtain the data for the requested process.
!
BEGIN
LOCAL
    status,
    iosb : VECTOR[4,WORD];
IF (status = $GETJPIW(PIDADR = pid,
		      ITMLST = jpi_list,
		      IOSB = iosb))
THEN status = .iosb[0];
IF NOT .status
THEN (SIGNAL(.status); RETURN);
pid = .fao_pid;
END;

!
! If /CONTINUOUS was specified, then transfer control
!
IF .flags[proc$v_cont]
THEN
    BEGIN
    proc_l_pid = .fao_pid;
    proc_a_desc[dsc$w_length] = fao_prcnam;
    proc_a_desc[dsc$a_pointer] = aux_prcnam;
    CH$MOVE(.fao_prcnam, aux_prcnam, proc_z_name);
    proc_cont_display();
    RETURN;
    END;

!
! Grab a large chunk of memory in which to put data.  The present
! "algorithm" is to grab 64 pages, which should be more than enough,
! at least it has been so far.
!
BEGIN
REGISTER status;
IF NOT (status = lib$get_vm(%REF(64*512), scratch))
THEN (SIGNAL(.status); RETURN);
scratch[0] = 64*512;			! Put the size of the scratch area
    					! in the first longword
END;


!
! Now to print all the stuff.
!
display_data (.scratch, flags, .ourpid);

RETURN;
END;

ROUTINE check_privilege : NOVALUE =
!++
! 
! This routine checks that the image has the correct privilege.
!
!---
BEGIN

LOCAL
    status,
    oldpriv : $BBLOCK[8];		! Permanent privileges go here

OWN
    newpriv : $BBLOCK[8]			! Mask to disable WORLD
    	      PRESET([prv$v_world]=true);

!
! The image SHOW is installed with WORLD privilege, but we don't want the user 
! to have that much power unless s/he already has it.  So, first check to 
! see if the process has the privilege, and if not, then remove it for the
! duration of this image.
!
IF NOT (status = $SETPRV(ENBFLG = 1,		! Enable
    			 PRVADR = 0,		! No new privileges
    			 PRMFLG = 1,		! Permanent privs
    			 PRVPRV = oldpriv))	! Store current ones here
THEN SIGNAL_STOP(.status);
!
! Check to see if privilege there.  If not, then remove it from current
! privileges.
!
IF NOT .oldpriv[prv$v_world]			! If WORLD not permanent
THEN 
    BEGIN
    IF NOT (status = $SETPRV(ENBFLG = 0,	! Disable
    			     PRVADR = newpriv,	! this privilege
    			     PRMFLG = 0,	! for the duration of this image
    			     PRVPRV = 0))
    THEN SIGNAL_STOP(.status)
    END;

RETURN;
END;

ROUTINE display_data (scratch, flags, ourpid)  : NOVALUE =
BEGIN

!---
!
! Display the data, based on which qualifiers the user gave.
! 
! Inputs
!	SCRATCH -- a handy scratch area to put stuff when we need it
!	FLAGS   -- the options longword to direct what to output
!	OURPID  -- the PID of the current (this) process
!
! Outputs
!	None.  The data is displayed.
!
!---

MAP
    scratch : REF VECTOR,
    flags : REF $BBLOCK;

LOCAL
    status,
    arglst : VECTOR[3],
    entry : REF $BBLOCK;

!
! Print the header.
!
fao_systime = 0;			! Get current time
fao_terminal+4 = aux_terminal;		! Locate the terminal string
fao_username+4 = aux_username;		! Locate the username string
show$write_line (%ASCID '!/!%D   !16AF   User: !AF', fao_systime);

!
! Display the data for each option requested.
!
IF .flags[proc$v_def]			! Standard info
THEN
    BEGIN
    fao_prcnam+4 = aux_prcnam;		! Locate the process name string
!
! If the process of interest is this process, then obtain the current
! default device name and default.
!
    IF .fao_pid NEQ .ourpid
    THEN
	BEGIN
	fao_defdev = 0;
	fao_defdir = cstring('Not available');
	END
    ELSE
	BEGIN
	LOCAL
	    status;
	fao_defdev = lnm$c_namlength;		! Length of logical disk name
	fao_defdev + 4 = aux_defdev;		! Where to put logical name
	IF NOT (status = $TRNLOG(LOGNAM = %ASCID 'SYS$DISK',
				 RSLLEN = fao_defdev,
				 RSLBUF = fao_defdev))
	THEN (SIGNAL(.status); RETURN);
	IF CH$RCHAR(aux_defdev) EQL %X'1B'
	THEN
	    BEGIN
	    fao_defdev = .fao_defdev - 4;
	    fao_defdev + 4 = .(fao_defdev + 4) + 4;
	    END;
	fao_defdir = pio$gt_ddstring;
	END;

    show$write_line(%ASCID 'Pid: !XL   Proc. name: !16AF UIC: !%I',
		    fao_pid,
		    %ASCID 'Priority: !3UB   Default file spec: !AF!AC',
		    fao_prib);

!
! Get a list of devices allocated by this process
!
    arglst[0] = 2;
    arglst[1] = .scratch;
    arglst[2] = .fao_pid;
    IF NOT (status = $CMKRNL(ROUTIN = get_devall,
			     ARGLST = arglst))
    THEN SIGNAL(.status)
    ELSE
	BEGIN
	entry = scratch[1];
	IF .entry[d_l_length] NEQ 0
	THEN
	    BEGIN
	    show$write_line(%ASCID '!/Devices allocated: !AF',
			    entry[d_l_length]);
	    entry = .entry + d_k_length;
	    WHILE .entry[d_l_length] NEQ 0 DO
		BEGIN
		show$write_line(%ASCID '!19< !>!AF', entry[d_l_length]);
		entry = .entry + d_k_length;
		END;
	    END;
	END;
!
! Get a list of mounted devices for this process
!
    IF .ourpid EQL .fao_pid
    THEN
	BEGIN
	arglst[0] = 1;
	arglst[1] = .scratch;
	IF NOT (status = $CMKRNL(ROUTIN = get_devmoun,
				 ARGLST = arglst))
	THEN SIGNAL(.status)
	ELSE
	    BEGIN
	    entry = scratch[1];
	    IF .entry[d_l_length] NEQ 0
	    THEN
		BEGIN
		show$write_line(%ASCID '!/Devices mounted: !AF',
				entry[d_l_length]);
		entry = .entry + d_k_length;
		WHILE .entry[d_l_length] NEQ 0 DO
		    BEGIN
		    show$write_line(%ASCID '!17< !>!AF', entry[d_l_length]);
		    entry = .entry + d_k_length;
		    END;
		END;
	    END;
	END;
    END;

!
! Quotas
!
IF .flags[proc$v_quot]
THEN
    BEGIN
!
! If the CPU time limit is set to zero, then say that it's
! infinite.  Otherwise, mangle it and point to the mangled value.
!
    IF .fao_cpulim EQL 0
    THEN
	BEGIN
	fao_cpulim = %CHARCOUNT('        Infinite');
	fao_cpulim + 4 = UPLIT ('        Infinite');
	END
    ELSE
	BEGIN
	LOCAL
	    temp,
	    quad_time : VECTOR[2];
	IF .fao_cpulim
	THEN temp = -100000
	ELSE temp = 0;
	fao_cpulim = .fao_cpulim<1,31>;
	EMUL(%REF(-200000),
	     fao_cpulim,
	     temp,
	     quad_time);
	fao_cpulim = 16;
	fao_cpulim + 4 = aux_cpulim;
	$FAOL(CTRSTR = %ASCID '!%D',
	      OUTLEN = fao_cpulim,
	      OUTBUF = fao_cpulim,
	      PRMLST = %REF(quad_time));
	END;

!
! Get the number of subprocesses remaining, by subtracting the current
! job process count from the process limit.
!
    fao_prclm = .fao_prclm - .aux_jobprccnt;

    fao_account+4 = aux_account;			! Locate the account string

    show$write_line(%ASCID '!/Process Quotas:!/ Account name: !AF',
		    fao_account,
		    %ASCID ' CPU limit:              !AF  Direct I/O limit: !9UL',
		    fao_cpulim,
		    %ASCID ' Buffered I/O byte count quota:!10UL  Buffered I/O limit:!8UL',
		    fao_bytcnt,
		    %ASCID ' Timer queue entry quota:!16UL  Open file quota:!11UL',
		    fao_tqcnt,
		    %ASCID ' Paging file quota:!22UL  Subprocess quota:!10UL',
		    fao_pagfilcnt,
		    %ASCID ' Default page fault cluster:!13UL  AST limit:!17UL',
		    fao_dfpfc,
		    %ASCID ' Enqueue quota:!26UL  Shared file limit:!9UL',
		    fao_enqcnt,
		    %ASCID ' Max detached processes:!17UL  Max active jobs:!11UL',
		    fao_maxdetach);
    END;

!
! Accounting
!
IF .flags[proc$v_acc] 
THEN
    BEGIN

!
! Convert the CPU time to standard system format.
!
    EMUL(%REF(-100000), fao_cputim, %REF(0), aux_cputim);
    fao_cputim = aux_cputim;		! Locate the quad cputim

!
! Figure out the connect time.
!
    BEGIN
    LOCAL system_time : VECTOR[2];
    $GETTIM(TIMADR = system_time);
    SUBM (2, system_time, aux_logintim, aux_logintim);
    END;

    fao_logintim = aux_logintim;	! Locate quad login time

    show$write_line(%ASCID '!/Accounting information:', 0,
		    %ASCID ' Buffered I/O count:!10UL  Peak working set size:!11UL',
		    fao_bufio,
		    %ASCID ' Direct I/O count:!12UL  Peak virtual size:!15UL',
		    fao_dirio,
		    %ASCID ' Page faults:!17UL  Mounted volumes:!17UL',
		    fao_pageflts,
		    %ASCID ' Images activated:!12UL',
		    fao_imagecount,
		    %ASCID ' Elapsed CPU time:   !%D!/ Connect time:       !%D',
		    fao_cputim);
    END;

!
! Process privileges
!
IF .flags[proc$v_priv]
THEN
    BEGIN
    BIND privileges = aux_procpriv : BITVECTOR[64];
    show$write_line(%ASCID ' ', 0,
    		    %ASCID 'Process privileges:',0);
    INCR index FROM 0 TO priv_num - 1 DO
	BEGIN

	! We do not want to display some privileges (UPGRADE, DOWNGRADE,
	! TMPJNL, PRMJNL) that are partially implemented but that can be set.
	! This looks ugly, I know, but we could not comment the privileges
	! out of the table because then the bits got out of synchronization.
	!

	IF .privileges[.index]
	  AND ( .index neq 32				! upgrade
	     AND .index neq 33				! downgrade
	     AND .index neq 36				! tmpjnl
	     AND .index neq 37 )			! prmjnl
	THEN show$write_line(%ASCID ' !20AC !AC',
			     priv_table[.index * 2]);
	END;
    show$write_line(%ASCID ' ', 0);

!
! Display the rights for this process.
!
    IF .ourpid EQL .fao_pid
    THEN display_rights();
    END;


!
! Memory
!
IF .flags[proc$v_mem]
THEN
    BEGIN
    IF NOT (status = show$prcallreg())
    THEN SIGNAL(.status);
    END;

!
! The subprocess tree
!
IF .flags[proc$v_sub]
THEN display_tree(.scratch);

RETURN;
END;

ROUTINE display_tree (scratch) : NOVALUE =
BEGIN

!---
!
! A routine to print the subprocess tree.  This is used as the starting
! point for calling NEXT_PROCESS, which is a recursive routine.  This
! routine simply sets up the master process, the process at the top of
! the tree, and then calls NEXT_PROCESS to wind its way down the tree.
! When control is finally returned to this routine, then all the processes
! in the tree have been displayed.
!
! Inputs
!	SCRATCH -- address of the scratch area that contains all the 
!		   info on the subprocesses
!
! Outputs
!	None.  The subprocess tree is output.
!
!---

MAP 
    scratch : REF VECTOR;		! The first longword contains the
    					! size of the scratch area
LOCAL
    fao_pix,				! Index for the fao pid
    master_pix : WORD,			! Master index for this JIB set
    entry : REF $BBLOCK,		! Pointer to the entries
    arglst : VECTOR[3],			! The ever-present argument list
    status;				! sigh...

!
! Get information on all the relevant processes.
!
arglst[0] = 1;				! Set up the argument list
arglst[1] = .scratch;
IF NOT (status = $CMKRNL(ROUTIN = make_tree,
			 ARGLST = arglst))
THEN (SIGNAL(.status); RETURN);

!
! Find the master process.
!
entry = scratch[1];			! Set up a pointer to the entries

WHILE .entry[sub_owner] NEQ 0 DO	! Look for a non-owned process
    entry = entry[sub_name] + pcb$s_lname;

master_pix = .entry[sub_pix];		! Got it, now save it away.

!
! Display this master process.  If it is the originator, say so.
!
show$write_line(%ASCID '!/Processes in this tree: !/', 0);

arglst[0] = entry[sub_name];		! Point to the process name.
fao_pix = .fao_pid<0,.sch$gl_pixwidth>;	! Get index for fao process
IF .master_pix EQL .fao_pix		! If this is the originator
THEN arglst[1] = cstring(' (*)')	! then point it out
ELSE arglst[1] = UPLIT(0);		! otherwise be silent
show$write_line(%ASCID '!AC!AC', arglst);

!
! Now go get all the other subprocesses hanging off this one.
!
entry = scratch[1];			! Always start at beginning of list
next_process(.entry, .master_pix, .fao_pix, 1);

RETURN;
END;

ROUTINE next_process (entry, pid, origin, level) : NOVALUE =
BEGIN

!---
!
! A magical little routine that looks for a process in the scratch
! area that has an owner PID equal to the PID that is passed to it.
! If such a process is found, then this subroutine is called again,
! with that process's PID, to get all its children.  It's a fairly 
! nifty way to go about printing the tree.
!
! Inputs
!	ENTRY  -- beginning address of scratch area
!	PID    -- the PID to look for as a process's owner
!	ORIGIN -- the PID of the process that this SHOW PROCESS
!		  request was issued for.  
!	LEVEL  -- a handy way to tell what level of subprocess we're at.
!
! Outputs
!	The subprocess tree is displayed.
!
!---

LOCAL
    status,
    list : REF $BBLOCK;

list = .entry;					! Point to the list of entries

!
! Scan the entries, looking for an entry whose owner field is equal to PID.
! If/when such an entry is found, print it.  If that entry is the process
! of interest, indicate it.
!
DO
    BEGIN
    IF .list[sub_owner] EQL .pid<0,16>		! If this process is owned by
    THEN					! the process, print it.
	BEGIN
	LOCAL
	    temp : VECTOR[80,BYTE],		! Need a place to store spaces
	    arglst : VECTOR[3];			! And an argument list
	temp[0] = 2 * .level;			! Print this many leading
	CH$FILL(' ', 2*.level+1, temp[1]);	! spaces before the name.
	arglst[0] = temp;			! Now point to it.
	arglst[1] = list[sub_name];		! Point to the process name
	IF .list[sub_pix] EQL .origin<0,16>	! If the originator,
	THEN arglst[2] = cstring(' (*)')	! then point it out
	ELSE arglst[2] = UPLIT(0);		! otherwise be silent
	show$write_line(%ASCID '!AC!AC!AC', arglst);
!
! Zero the owner field, so that this process isn't displayed again.  Then
! call this subroutine with this process's PID, and a higher level, to display
! all of its children.
!
    	list[sub_owner] = 0;
	next_process(.entry, .list[sub_pix], .origin, .level+1);
    	END;
    list = list[sub_name] + pcb$s_lname;
    END
UNTIL .list[sub_pix] EQL 0;

RETURN;
END;

ROUTINE make_tree (scratch) =
BEGIN

!---
!
! This routine operates in KERNEL mode.  It locates the JIB, which is shared
! by all processes in this tree.  Then, it scans all the processes in the
! system, gathering information about each process with the appropriate JIB
! address.  All the data is stored in the scratch area pointed to by SCRATCH.
!
! Inputs
!	SCRATCH -- address of the scratch area.
!
! Outputs
!	SCRATCH -- will contain all relevant data about the subprocesses.
!
!---

MAP 
    scratch : REF VECTOR;

LOCAL
    entry : REF $BBLOCK,
    pcb : REF $BBLOCK,
    limit,
    jib_address;

entry = scratch[1];				! Point to the scratch area
limit = scratch[0] + .scratch[0] -256;		! Limit is half a page before 
    						! end of scratch area.
!
! Get the JIB address.  All processes of interest will have the same JIB address
!
pcb = exe$epid_to_pcb (.fao_pid);
jib_address = .pcb[pcb$l_jib];

!
! Scan all the processes and get only those whose JIB address matches
! this process's JIB address.
!
INCR index FROM sch$c_swppix+1 TO .sch$gl_maxpix DO
    BEGIN
    pcb = .sch$gl_pcbvec[.index];
    IF .pcb[pcb$l_jib] EQL .jib_address
    AND .entry LSSA .limit
    THEN
	BEGIN
	entry[sub_pix] = .pcb[pcb$l_pid];
	entry[sub_owner] = .pcb[pcb$l_owner];
	entry = CH$MOVE(pcb$s_lname, pcb[pcb$t_lname], entry[sub_name]);
	END;
    END;

entry[sub_pix] = entry[sub_owner] = 0;	! To show end of list

RETURN 1;
END;


ROUTINE get_devall (data, pid) =
BEGIN

!---
! 
! This routine operates in KERNEL mode, and gathers the names of all devices
! allocated by this process.
!
! Inputs
!	DATA -- scratch area to store the names
!	PID  -- PID of the particular process of interest
!
! Outputs
!	DATA -- will contain the device names
!
!---

MAP
    data : REF VECTOR;

LOCAL
    status,
    ipid,					! Internal pid
    limit,					! End-of-address limit
    scratch : REF $BBLOCK,			! Pointer to scratch area
    ucb : REF $BBLOCK,				! UCB pointer
    ddb : REF $BBLOCK;				! DDB pointer

!
! Set up the scratch area so that is can be addressed easily.  Also, calculate
! a limit toward the end of the scratch area, so that we don't write beyond the 
! area.  Finally, set up STATUS as 1, to show that we still have room in the
! scratch area to store more data.
!
scratch = data[1];				! Point to beginning of scratch area
limit = .data[0] + data[0] - 256;		! Set the limit to be halfway in to
    						! the last page of the scratch area.
status = 1;					! Indicate no problem yet.

! 
! Lock the I/O data base.  Upon return from the call to SCH$IOLOCKR, the 
! IPL will be 2, so that pagefaults are still allowed.
!
SCH$IOLOCKR(.ctl$gl_pcb);			! Lock the I/O database

!
! Convert the extended PID to an internal PID for checking the I/O database.
!
ipid = exe$epid_to_ipid (.pid);

!
! For each UCB in the I/O database, see if the owner PID matches the
! internal PID of interest
!
status = IOC$SCAN_IODB(0, 0; ddb, ucb);
WHILE .status DO
    BEGIN
    IF .ucb[ucb$l_pid] EQL .ipid
    THEN
	BEGIN
	IF .scratch GEQA .limit		! Check if there is still room
	THEN (status = SS$_VASFULL; EXITLOOP);

	IF ioc$cvt_devnam(21,			! Get device name, max this long
			  scratch[d_t_device],	! put it here,
			  -1,			! in standard display format
	    		  .ucb;			! UCB is here
			  scratch[d_l_length])	! final length here
	THEN
	    BEGIN
	    scratch[d_l_length] = .scratch[d_l_length] - 1;
	    scratch[d_a_ptr] = scratch[d_t_device] + 1;
	    scratch = .scratch + d_k_length;
	    END;
	END;
    status = IOC$SCAN_IODB(.ddb, .ucb; ddb, ucb);
    END;

scratch[d_l_length] = 0;			! To show end of list
IF .status EQL 0				! If just end of list
THEN status = 1;				! then readjust status

!
! Now to clean up.  Unlock the I/O database, then lower the IPL
! to zero.
!
SCH$IOUNLOCK(.ctl$gl_pcb);			! Unlock I/O database
SET_IPL(0);					! Lower IPL

RETURN .status;					! Return with status
END;						! End of GET_DATA

ROUTINE get_devmoun (data) =
BEGIN

!---
!
! This one operates in KRNL mode, and simply goes down the mounted volume
! list for this process, putting the name of the device(s) into the DATA
! area.
!
! Inputs
!	DATA -- scratch area to store the device names
!
! Outputs
!	DATA -- will contain some device names, maybe.
!
!---

MAP data : REF VECTOR;

LOCAL
    status,
    limit,
    mtl_head,
    jib	    : REF $BBLOCK,
    devlist : REF $BBLOCK,
    scratch : REF $BBLOCK;

BIND
    pcb = .ctl$gl_pcb : $BBLOCK;

!
! Set up the scratch area so that is can be addressed easily.  Also, calculate
! a limit toward the end of the scratch area, so that we don't write beyond the 
! area.  Finally, set up STATUS as 1, to show that we still have room in the
! scratch area to store more data.
!
scratch = data[1];				! Point to beginning of scratch area
limit = .data[0] + data[0] - 256;		! Set the limit to be halfway in to
    						! the last page of the scratch area.
status = 1;					! Indicate no problem yet.

!
! Starting at the mounted device list in the JIB. Simply copy
! the device name and unit number into the scratch area.
!
jib = .pcb [pcb$l_jib];				! get the JIB address
mtl_head = devlist = jib [jib$l_mtlfl];		! get the mount list head
sch$iolockr(.ctl$gl_pcb);			! lock I/O database


WHILE .status							! While no error
AND (devlist = .devlist[mtl$l_mtlfl]) NEQ .mtl_head DO	! not at end of
    BEGIN							! the list, copy
    IF .scratch GEQA .limit			! Check if there is still room
    THEN (status = SS$_VASFULL; EXITLOOP);
    IF ioc$cvt_devnam(21,			! Get device name, max this long
		      scratch[d_t_device],	! put it here,
		      -1,			! in standard display format
		      .devlist[mtl$l_ucb];	! UCB is here
		      scratch[d_l_length])	! final length here
    THEN
	BEGIN
	scratch[d_l_length] = .scratch[d_l_length] -1;
	scratch[d_a_ptr] = scratch[d_t_device] + 1;
	scratch = .scratch + d_k_length;
	END;
    END;

sch$iounlock(.ctl$gl_pcb);			! Unlock I/O database
set_ipl(0);					! and drop IPL
scratch[d_l_length] = 0;			! Zero to show end of list

RETURN .status;
END;

ROUTINE display_rights : NOVALUE =
BEGIN

!+++
!
! Display the identifiers found in the process rights lists.
!
! Inputs:
!	None.
!
! Outputs:
!	None.  The process rights are displayed.
!
!---

LOCAL
    status,
    size,
    id_block : REF VECTOR,
    name_buffer : VECTOR[30],
    name_desc : VECTOR[2];

!
! First, get the total number of ID's that are in the rights list.
!
IF NOT (status = $CMKRNL(ROUTIN = get_rights_size,
    			 ARGLST = size))
THEN (SIGNAL(.status); RETURN);

!
! Now grab a chunk of memory large enough to put the ID's.
!
IF NOT (status = lib$get_vm(%REF(8*.size), id_block))
THEN (SIGNAL(.status); RETURN);


!
! Get the ID's
!
IF NOT (status = $CMKRNL(ROUTIN = get_rights,
			 ARGLST = .id_block))
THEN (SIGNAL(.status); RETURN);

!
! If the second ID block is zero, then there is nothing to display.
!
IF .id_block[2] EQL 0
THEN RETURN;

!
! Print a header.
!
show$write_line(%ASCID 'Process rights identifiers:', 0);

name_desc[1] = name_buffer;

!
! Run thru the ID's, skipping the UIC identifier.
!
INCR i FROM 1 TO .size-1 DO
    BEGIN
    IF .id_block[2*.i] NEQ 0
    THEN
	BEGIN
	name_desc[0] = %ALLOCATION(name_buffer);
	IF NOT (status = $IDTOASC(ID     = .id_block[2*.i],
				  NAMLEN = name_desc,
				  NAMBUF = name_desc))
	THEN SIGNAL(.status)
	ELSE show$write_line(%ASCID ' !AS', %REF(name_desc));
	END;
    END;

RETURN;
END;

ROUTINE get_rights_size =
BEGIN

!++++
!
! Calculate the size of the rights list
! 
!	THIS ROUTINE OPERATES IN KERNEL MODE
!
! Inputs:
!	AP = address of size longword
!
! Outputs:
!	AP gets filled with the number of rights ID's found.
!
!----

BUILTIN
    ap;

BIND
    pcb = .ctl$gl_pcb : $BBLOCK,
    arb = .pcb[pcb$l_arb] : $BBLOCK,
    rightslist = arb[arb$l_rightslist] : VECTOR;

REGISTER
    size;

size = 0;

!
! For each rights list described in the rightslist vector, add
! the size of the rights list.
!
INCR i FROM 0 TO 3 DO
    BEGIN
    BIND
	rights_desc = .rightslist[.i] : $BBLOCK;
    IF .rightslist[.i] NEQ 0
    THEN size = .size + .rights_desc[dsc$w_length];
    END;

!
! The size is in bytes, and each rights ID is 8 bytes.  So, return
! the number of ID's, NOT the size in bytes.
!
.ap = .size/8;

RETURN 1;
END;

ROUTINE get_rights =
BEGIN

!++++
!
! This routine copies the local rights into a user-readable area.
! This routine executes in KERNEL mode.
!
! Inputs:
!	AP = address of local user area
!
! Outputs:
!	None.  The data is copied to the user area.
!
!---

BUILTIN
    ap;

BIND
    pcb = .ctl$gl_pcb : $BBLOCK,
    arb = .pcb[pcb$l_arb] : $BBLOCK,
    rightslist = arb[arb$l_rightslist] : VECTOR;

LOCAL
    ptr;

ptr = .ap;

!
! For each rights list described in the PCB rightslist vector,
! if the size is non-zero, copy the contents of the rights list
! to the user area.
!
INCR i FROM 0 TO 3 DO
    BEGIN
    BIND
	rights_desc = .rightslist[.i] : $BBLOCK;
    IF .rightslist[.i] NEQ 0
    THEN IF .rights_desc[dsc$w_length] NEQ 0
    THEN ptr = CH$MOVE(.rights_desc[dsc$w_length],
    		       .rights_desc[dsc$a_pointer],
    		       .ptr);
    END;

RETURN 1;
END;

END
ELUDOM
