MODULE RSTCNTRL (IDENT = 'V04-000') =

BEGIN

!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
! WRITTEN BY
!	Bert Beander	June, 1980.
!
! MODULE FUNCTION
!	This module contains the routines which build and remove DEBUG's
!	Run-Time Symbol Table (RST).  This includes the routines which
!	initialize the RST when DEBUG is started up as well as the routines
!	which build and remove (SET and CANCEL) a specific module's RST
!	during the debugging session.  The routines which maintain the
!	DEBUG Scope List are also here.
!
! MODIFIED BY
!	Rich Title	Nov, 1981	Fixed a bug in DBG$RST_SETSCOPE :
!					SET SCOPE MOD1 sometimes failed if
!					MOD1 is a module which is already
!					set.
!
!	Ping Sager      Mar, 1982       Break original DBG$RST_SETSCOPE
!					routine into two parts.  One builds
!					the scope list, the other sets up
!					the scope list.
!
!	Rich Title	Mar, 1982	Added to RST_BUILD_ERROR_HANDLER
!					some code that marks the module
!					as not being set, if an error occured
!					when trying to set it.
!
!	Ping Sager      Apr, 1982       Added DBG$GST_INIT.
!
!	Ping Sager      Apr, 1982       Insert TYPE RST into hash chain also
!
!	V. Holt		Jul, 1982	Modified STATIC_CHECK to accept static
!					records.  Modified DBG$RST_INIT so that
!					static records are added to the program
!					level SAT.
!
!	Bert Beander	Dec, 1982	Put in the fast initialization of the
!					RST using the Debug Module Table (DMT).
!
!	Rich Title	Feb 1983	Added DBG$ANALYZE_HASH to aid in
!					analysis of hashing algorithms.
!
!	Rich Title	Feb 1983	Added BUILD_TYPE_TABLE flag to suppress
!					unnecessary looping through RST, and
!					thus speed up SET MODULE in some cases.
!
!	Rich Title	Feb 1983	Removed the CHECK_DUPLICATE routine
!					which screened out duplicate BLISS
!					RST entries during the RST build.
!					The was costing us very heavily
!					during the SET MODULE command. Now,
!					this check is done during lookup
!					(see the CHECK_DUPLICATE routine
!					in RSTACCESS).
!	Rich Title	Apr 1983	Increased size of hash table in order
!					to speed up symbol lookup.
!	Rich Title	Apr 1983	Made changes to SET SCOPE to handle
!					SET SCOPE/MODULE.
!	Rich Title	Apr 1983	Added SET MODULE/ALLOCATE
!
!	Ping Sager      May 1983        Added shareable image support
!
!	Walter Carrell	Oct 1983	Added support for continuation DST records
!
!	Walter Carrell	Nov 1983	Added overloaded symbol support
!
!	Brad Becker	Nov 1983	Added code to hash in type spec. DSTs
!

REQUIRE 'SRC$:DBGPROLOG.REQ';

FORWARD ROUTINE
    DBG$ANALYZE_HASH:	NOVALUE,	! Dump out information about hash chains
    DBG$GET_DST_NAME,			! Find the name string in a DST record
    DBG$GST_INIT,			! Build RST entries for all global
					!	symbols in GST
    DBG$GST_TO_RST:	NOVALUE,	! Create RST entry for a global symbol
    DBG$HASH_FIND,			! Find a name in the RST Hash Table
    DBG$HASH_FIND_SETUP:NOVALUE,	! Set up calls on DBG$HASH_FIND routine
    DBG$HASH_INSERT:	NOVALUE,	! Insert an RST entry in the Hash Table
    DBG$RST_BUILD:	NOVALUE,	! Build the RST for one module
    DBG$RST_BLDSCOPE_LIST,		! Build the scope list
    DBG$RST_CANMOD,			! CANCEL a module in the RST
    DBG$RST_DST_LENGTH,			! Return the "real" DST length
    DBG$RST_DST_PTR,			! Return the "real" DST pointer
    DBG$RST_INIT:	NOVALUE,	! Initialize DST and RST
    DBG$RST_MOST_RECENT:NOVALUE,	! Mark the Most Recently Used module
    DBG$RST_NEXT_DST,			! Return the next DST given the one
    DBG$RST_REMOVE:	NOVALUE,	! Remove a module from the RST
    DBG$RST_SETMOD,			! SET a module in the RST
    DBG$RST_SETSCOPE:	NOVALUE,	! Set a list of scopes from SET SCOPE
    BLDSCOPE_ERROR_HANDLER,		! Error handler for DBG$RST_BLDSCOPE_LIST
    BUILD_LABEL_RST,			! Build RST entries for numeric labels
    COPY_COMP_LIST:	NOVALUE,	! Copy a record component list to RST
    COPY_VARIANT_LIST,			! Copy a record variant list to RST
    COMP_LIST_ADD_ENTRY:NOVALUE,	! Add entry to a record component list
    GET_MEM,				! Get memory from the free memory pool
    GET_MOD_RST,			! Find a specified module in the RST
    GET_TYPEPTR:	NOVALUE,	! Find record or enum type DST pointer
    MERGE_CONTINUATION_DST,		! Move and merge continuation records
    POSITION_GST,			! Position GST pointer
    READ_DEBUG_MODULE_TABLE,		! Read Debug Module Table to initialize
					!      the RST (for new images only)
    RST_BUILD_ERROR_HANDLER,		! Error handler for DBG$RST_BUILD
    SHARED_IMAGE_NAMES: NOVALUE,	! Make global symbols from all shared
					!      image names in this execution
    SHARED_IMAGE_NAMES_HANDLER,		! Handler for above routine 
    SHARED_IMAGE_NAMES_V3: NOVALUE,	! Make global symbols from all shared
					!      image names in this execution 
    					!      for VMS 3.0 system
    STATIC_ADDRESS:	NOVALUE,	! Make a Static Address Table entry
    STATIC_CHECK:	NOVALUE,	! Check whether a data item is static
    STATIC_CHECK_HANDLER,		! Handler for STATIC_CHECK
    TEST_DST_SIZE;			! Find DST size for Testable Debugger

EXTERNAL ROUTINE
    DBG$EXPAND_MEMORY,			! Expand the free memory pool
    DBG$FIND_SEPTYP,			! Given SEPTYP DST, find the size
    DBG$FREE_MEM_LEFT,			! Return the free memory pool size
    DBG$GET_BITSIZE_FROM_TYPESPEC,	! Get the bit size for this type spec
    DBG$GET_MEMORY,			! Get a memory block from memory pool
    DBG$GET_TEMPMEM,			! Get a memory block from the temp memory pool
    DBG$GET_BITSIZE_FROM_DESC,		! Given Descr, find the size
    DBG$LANGUAGE,			! Return ASCIC name from a language code
    DBG$NCIS_ADD,
    DBG$NEWLINE:	NOVALUE,	! DEBUG output routine
    DBG$NPATHDESC_TO_CS:NOVALUE,	! Convert pathname to counted ASCII
    DBG$PRINT:	        NOVALUE,	! DEBUG output routine
    DBG$REL_MEMORY:	NOVALUE,	! Release a block to free memory pool
    DBG$SCR_INITIALIZE: NOVALUE,	! Initialize Screen Debugging
    DBG$SET_LANG: NOVALUE,		! Set the current language setting
    DBG$SRC_INIT:	NOVALUE,	! Initialize source line display blocks
    DBG$STA_GETSYMBOL:	NOVALUE,	! Look up a symbol in the RST
    DBG$STA_LOCK_SYMID:	NOVALUE,	! Lock a SYMID in RST memory
    DBG$STA_LOOKUP_GBL,			! Look up a Global symbol in the GST
    DBG$STA_SYMNAME: NOVALUE,		! Get the name string of a given symbol
    DBG$STA_UNLOCK_SYMID: NOVALUE,	! Unlock a SYMID locked in RST memory
    DBG$TRANS_TYPE_CODE,		! Returns the FCODE for the type spec
    SYS$CRMPSC,				! Create Map Section system service
    SYS$DELTVA;				! Delete Virtual memory space

EXTERNAL
    DBG$GB_LANGUAGE: BYTE,		! The currently SET language code
    DBG$GL_MOVED_DST_LIST_HEAD,		! The head of the Moved DST list
    DBG$GL_LIB_SIGNAL_ADDR,		! Address of LIB$SIGNAL
    DBG$GL_LIB_STOP_ADDR,		! Address of LIB$STOP
    DBG$GV_CONTROL : DBG$CONTROL_FLAGS,	! DEBUG control bits
    DBG$RUNFRAME : BLOCK[,BYTE],	! The current user run frame
    DBG$GL_TRANSFER_ADDRESS,		! Transfer address

    ! Note - for FT1 we get the shareable image list from IAC$GL_IMAGE_LIST
    ! which is obtained by linking against SYS.STB. For FT2,
    ! we get it from SYS$GL_IMGLSTPTR which comes from STARLET.
    !
    SYS$GL_IMGLSTPTR,			! See SHARED_IMAGE_NAMES
    IAC$GL_IMAGE_LIST: WEAK,		! See SHARED_IMAGE_NAMES

    SYS$GL_IAFLINK: WEAK REF VECTOR[1];	! Pointer to pointer to start of Image
					!      Activator Fixup Block List

GLOBAL
    DST$BEGIN_ADDR: INITIAL(0),		! Virtual address where the DST begins
    DST$END_ADDR: INITIAL(0),		! Virtual address of last byte of DST
    DST$NEXT_ADDR,			! -
    GST$BEGIN_ADDR: INITIAL(0),		! Virtual address where the GST (Global
					!      Symbol Table) begins
    GST$NEXT_ADDR,			! -
    GST$REC_COUNT: INITIAL(0),		! Number of records in the GST
    LRUM$LISTHEAD: REF LRUM$ENTRY	! Pointer to the list head for the Least
			INITIAL(0),	!      Recently Used Module (LRUM) chain
    LRUM$MOST_RECENT: INITIAL(0),	! Pointer to the Module RST Entry of the
					!      Most Recently Used module
    RST$REF_LIST: REF VECTOR[,LONG]	! Pointer to a list of pointers to RST
			INITIAL(0),	!      entries referenced by the current
					!      command.
    RST$SET_SCOPE: INITIAL(FALSE),	! Flag set to TRUE if DBG$STA_GETSYMBOL
					!      is called from DBG$RST_SETSCOPE
    RST$START_ADDR: INITIAL(0),		! Address of the first Module RST Entry
					!      on the RST module chain.
    RST$TEMP_LIST: INITIAL(0),		! Pointer to Temporary RST Entry List
    SAT$START_ADDR: INITIAL(0),		! Address of first Static Address Table
					!      (SAT) entry on Program SAT chain
    SCOPE$LIST: REF SCOPE$ENTRY;	! Pointer to current Scope List

LITERAL
    GST_TYPE		= 1,		! Record type is GST
    GST_RECORD_TYPE     = 0,		! Type of GST record
    MIN_MODS_IN_RST	= 6,		! Minimum number of modules the RST must
					!      be able to hold--in particular,
					!      the MIN_MODS_IN_RST largest mod-
					!      ules must fit in the RST.
    RST$K_HASHTBLSIZE	= 2503;		! The size of the RST Hash Table
    					!      (A prime number should be used).

OWN
    DBG$HASH_INDEX,			! Hash index used to communicate between
					!      routines DBG$HASH_FIND_SETUP and
					!      DBG$HASH_FIND
    DBG$HASH_RSTPTR: REF RST$ENTRY	! Pointer to current RST entry on the
		INITIAL(0),		!      current hash chain--used to com-
					!      municate between DBG$HASH_FIND
					!      and DBG$HASH_FIND_SETUP
    EXEFAB: $FAB(),			! RMS File Access Block (FAB) for the
					!      executable image file
    EXERAB: $RAB(),			! RMS Record Access Block (RAB) for the
					!      executable image file
    IMAGE_MODULE_RST_SIZE,		! Keep track the module RST size of the image
    IMAGE_MODULE_END_ADDR,		! Keep track the end address of the module
    MOD_BEING_BUILT,			! Pointer to RST entry for module being
					!      built--used to communicate with
					!      error handler.
    PREV_RST_PTR: REF RST$ENTRY, 	! Pointer to the previous RST entry in
					!      the chain of Module RST entries
    RST$HASH_TABLE: 			! The RST Hash Table--a vector of list
	VECTOR[2*RST$K_HASHTBLSIZE],	!      heads for RST hash chains.
    TYPRSTLOC: REF VECTOR[,LONG],	! Pointer to next available location in
					!      the current Type RST Entry block
    TYPRSTPTR: REF RST$ENTRY;		! Pointer to the current Type RST Entry

GLOBAL ROUTINE DBG$ANALYZE_HASH: NOVALUE =
!
! FUNCTION
!	Dumps information about the length of the hash chains. This 
!	information is useful in analyzing how good our hash algorithm is.
!	This routine should probably be commented out in the version of
!	the debugger that we ship since it is only used to aid our
!	own development.
!
! INPUTS
!	The entire RST is scanned.
!
! OUTPUTS
!	The length of each hash chain is displayed at the terminal.
!
    INCR I FROM 0 TO RST$K_HASHTBLSIZE-1 DO
    	BEGIN
    	LOCAL
    	    COUNT,
	    NAME,
    	    NEW_RSTPTR: REF RST$ENTRY,
    	    RSTPTR: REF RST$ENTRY;
	DBG$PRINT(UPLIT BYTE(%ASCIC 'Hash chain !UL:'), .I );
	DBG$NEWLINE();
    	RSTPTR = .RST$HASH_TABLE[2*.I];
    	NEW_RSTPTR = .RSTPTR[RST$L_HASH_FLINK];
    	COUNT = 0;
    	WHILE .NEW_RSTPTR NEQ .RSTPTR DO
    	    BEGIN
    	    COUNT = .COUNT + 1;
	    DBG$STA_SYMNAME(.NEW_RSTPTR[RST$L_HASH_BLINK], NAME );
	    DBG$PRINT( .NAME );
	    DBG$NEWLINE();
    	    NEW_RSTPTR = .NEW_RSTPTR[RST$L_HASH_FLINK];
    	    END;
    	DBG$PRINT(UPLIT BYTE(%ASCIC '	!UL entries.'), .COUNT);
    	DBG$NEWLINE();
    	END;

GLOBAL ROUTINE DBG$GET_DST_NAME(DSTPTR) =
!
! FUNCTION
!	This routine accepts a pointer to a DST entry and returns the address of
!	the counted string that contains the name of that DST symbol.  If there
!	is no name field in the specified DST entry, an error is signalled.
!
! INPUTS
!	DSTPTR	- A pointer to the Debug Symbol Table entry whose name field is
!		  to be located.
!
! OUTPUTS
!	The address of the counted string containing the symbol name is returned
!		  as DBG$GET_DST_NAME's value.
!

    BEGIN

    MAP
	DSTPTR: REF DST$RECORD;		! Pointer to the input DST record

    LOCAL
	BPTR: REF DST$BLI_TRAILER1;	! Pointer to Bliss special cases DST
					!      record's first trailer



    ! Use the DST record type as a CASE index.  For each type of DST record,
    ! we then locate the corresponding name field.
    !
    CASE .DSTPTR[DST$B_TYPE] FROM 0 TO 255 OF
	SET


	! Handle all the DST record types of the "standard" format.
	!
	[DSC$K_DTYPE_LOWEST TO DSC$K_DTYPE_HIGHEST,
	 DST$K_SEPTYP, DST$K_BOOL, DST$K_RECBEG,
	 DST$K_VARBEG, DST$K_ENUMELT, DST$K_ENTRY,
	 DST$K_LABEL, DST$K_LBLORLIT, DST$K_BLIFLD,
	 DST$K_COB_HACK]:
	    RETURN DSTPTR[DST$B_NAME];


	! Handle the Module-Begin record.
	!
	[DST$K_MODBEG]:
	    RETURN DSTPTR[DST$B_MODBEG_NAME];


	! Handle the Routine-Begin record.
	!
	[DST$K_RTNBEG]:
	    RETURN DSTPTR[DST$B_RTNBEG_NAME];


	! Handle the Lexical Block-Begin record.
	!
	[DST$K_BLKBEG]:
	    RETURN DSTPTR[DST$B_BLKBEG_NAME];


	! Handle the PSECT record.
	!
	[DST$K_PSECT]:
	    RETURN DSTPTR[DST$B_PSECT_NAME];


	! Handle the Bliss Special Cases record.
	!
	[DST$K_BLI]:
	    BEGIN
	    BPTR = DSTPTR[DST$A_BLI_TRLR1] + .DSTPTR[DST$B_BLI_LNG];
	    RETURN BPTR[DST$B_BLI_NAME];
	    END;


	! Handle the Enumeration Type Begin record.
	!
	[DST$K_ENUMBEG]:
	    RETURN DSTPTR[DST$B_ENUMBEG_NAME];


	! Handle the Type Specification DST record.
	!
	[DST$K_TYPSPEC]:
	    RETURN DSTPTR[DST$B_TYPSPEC_NAME];


	! Handle the Overloaded Symbol DST record.
	!
	[DST$K_OVERLOAD]:
	    RETURN DSTPTR[DST$B_OL_NAME];


	! Handle all DST records which do not have symbol name fields by signal-
	! ling an internal coding error.
	[INRANGE]:
	    $DBG_ERROR('RSTCNTRL\GET_DST_NAME 10');

	TES;


    ! We should never get here--if we do, signal an internal coding error.
    !
    $DBG_ERROR('RSTCNTRL\GET_DST_NAME 20');
    RETURN 0;

    END;

GLOBAL ROUTINE DBG$GST_INIT(IMGFILCHAN, BASEADDR, MODRSTPTR): =
!
! FUNCTION
!	This routine sequentially reads in the Global Symbols and calls
!	DBG$GST_TO_RST to build RST entry for each Global Symbol at RST 
!	intialization time in DBG$RST_INIT.
!
!	Before this routine is called, the location of the GST in the image
!	file is found, and it is mapped into DEBUG's image.  The begin addrss
!	of this buffer is pointed by GST$BEGIN_ADDR.  This routine analyzes
!	the GST record, and moves through the buffer, getting the buffer
!	address of each global symbol entry as it is seen.  When the buffer 
!	is exhausted, this routine reads in the next GST record.  It halts at
!	end of file and returns a value of zero to the caller.
!
!	The format of one of these concatenated records is a single
!	leading type containing the value 1, indicating that the record is
!	indeed a GST record.  Each entry in the record has a fixed number of
!	overhead types followed by a symbol name that is a variable number
!	of bytes.  The entries we are interested in processing are the
!	global symbol definitions and entry point symbol and prodecure definitions.
!	The other defined type, PSECT definition, is noted only because it must
!	be successfully passed over.  The detailed format of the GST is defined
!	in DBGLIB.
!	
! INPUT
!	IMGFILCHAN	- The channel number that the image is opened on.
!
!	BASEADDR	- Base address of the shareable image. (it may be zero).
!
!	MODRSTPTR	- Module RST pointer which contains all global symbols.
!
! OUTPUT
!	RST entries for all Global Symbols are built.
!

    BEGIN

    MAP
	MODRSTPTR: REF RST$ENTRY;	! Pointer to anonymous module RST entry
    					!	or shareable image module RST

    LOCAL
	EXE_FILNAM_DESC: VECTOR[2,LONG],! File name descriptor for $CRMPSC
	EXE_HDRBOUNDS: VECTOR[2,LONG],	! Map section bounds descriptor for the
					!      $CRMPSC system service
	EXE_SECBOUNDS: VECTOR[2,LONG],	! Map section bounds descriptor for the
					!      $CRMPSC system service
	EXE_SECNAM_DESC: VECTOR[2,LONG],! Map section name descriptor for the
					!      $CRMPSC system service
    	GSTADDR: REF VECTOR[,WORD],	! Pointer to Gst record-used to find
    					!      first GST data record
	GSTPTR: REF BLOCK[,BYTE],	! Virtual address of current GST record
	IMG_DST_BLOCK: REF IHS$ENTRY,	! Pointer to DST/GST descriptor in the
					!      executable image header
    	IMG_HEADER: REF BLOCK[,BYTE],	! Pointer to the .EXE file image header
	NUM_ARGS: BYTE,			! maximum number of arguments.
	SATPTR: REF SAT$ENTRY,		! Pointer to Program Statci address table
	STATUS: BLOCK[1,LONG];


    ! Initialize some pointers in OWN or GLOBAL memory to zeroes.
    ! 
    ! In V4 system, we can get the module end address from shareable image descriptor block.
    ! So, we don't have to guess what is the end address for the module.
    ! Note: Global symbols do not have static address table, this info. is needed for
    ! shareable image module static address table only.
    !
    IMAGE_MODULE_END_ADDR = 0;
    IMAGE_MODULE_RST_SIZE = 0;
    GST$BEGIN_ADDR = 0;
    GST$REC_COUNT = 0;


    ! Set the pointer to image header by using $CRMPSC to map in the 1st
    ! virtual block.
    !
    EXE_HDRBOUNDS[0] = 200;
    EXE_HDRBOUNDS[1] = 1^30;
    EXE_SECNAM_DESC[0] = 6;
    EXE_SECNAM_DESC[1] = UPLIT BYTE(%ASCIC 'HEADER');
    STATUS = SYS$CRMPSC(EXE_HDRBOUNDS, EXE_HDRBOUNDS, 0, SEC$M_EXPREG,
			EXE_SECNAM_DESC, 0, 0,
			.IMGFILCHAN, 1, 0, 0, 0);
    IF NOT .STATUS
    THEN
        BEGIN
	IMG_HEADER = 0;
	STATUS[STS$V_SEVERITY] = SYS$K_INFO;
	SIGNAL(.STATUS);
    	RETURN FALSE;
	END

    ELSE
        IMG_HEADER = .EXE_HDRBOUNDS[0];


    ! Start by doing some consistency checks to ensure that the image header
    ! pointer is non-zero and that the debug symbol-table offset in the header
    ! is non-zero.  If either is wrong, signal an error and give up.
    !
    IF .IMG_HEADER EQL 0
    THEN
	BEGIN
	SIGNAL(DBG$_NORSTBLD);
	RETURN FALSE;
	END;

    IF .IMG_HEADER[IHD$W_SYMDBGOFF] EQL 0
    THEN
	BEGIN
	SIGNAL(DBG$_NORSTBLD);
	RETURN FALSE;
	END;


    ! We have a debug symbol table descriptor in the image header.  If no DST
    ! exists (because all the modules were compiled without /DEBUG or /TRACE),
    ! we indicate this by leaving the DST address zeroed.  Otherwise we set the
    ! DST address to 1 temporarily.
    !
    IMG_DST_BLOCK = .IMG_HEADER + .IMG_HEADER[IHD$W_SYMDBGOFF];


    ! First we want to map in the Global Symbol Table (GST) the same way.  First
    ! we make sure there is a GST--there must be at least four GST records (an
    ! image header, a sub-header, and an end-of-module record plus one data rec-
    ! ord).  If there is no GST, we leave the GST start address zeroed; other-
    ! wise we set it to 1 for now.
    !
    IF .IMG_DST_BLOCK[IHS$W_GSTRECS] GEQ 4 THEN GST$BEGIN_ADDR = 1;


    ! If the GST's Virtual Block Number (VBN) is invalid, we simply pretend that
    ! there is no GST, though this is actually an error in the image header.
    !
    IF .IMG_DST_BLOCK[IHS$L_GSTVBN] LEQ 2 THEN GST$BEGIN_ADDR = 0;


    ! We decided that there is a GST, so we create another map section
    ! which maps the GST into our virtual address space.  Again, if this fails,
    ! we print the status message with informational severity and set the GST
    ! address to zero.  If this succeeds, we make the GST pointer point to the
    ! first data record in the GST--we skip over the header and sub-header here.
    ! We also set the GST record count minus the header and trailer records.
    !
    IF .GST$BEGIN_ADDR NEQ 0
    THEN
	BEGIN
	EXE_SECBOUNDS[0] = 200;
	EXE_SECBOUNDS[1] = 1^30;
	EXE_SECNAM_DESC[0] = 3;
	EXE_SECNAM_DESC[1] = UPLIT BYTE(%ASCIC 'GST');
	STATUS = SYS$CRMPSC(EXE_SECBOUNDS, EXE_SECBOUNDS, 0, SEC$M_EXPREG,
			EXE_SECNAM_DESC, 0, 0,
			.IMGFILCHAN, .IMG_DST_BLOCK[IHS$W_GSTRECS], 
			.IMG_DST_BLOCK[IHS$L_GSTVBN], 0, 0);
	IF NOT .STATUS
	THEN
	    BEGIN
	    GST$BEGIN_ADDR = 0;
	    STATUS[STS$V_SEVERITY] = SYS$K_INFO;
	    SIGNAL(.STATUS);
	    END

	ELSE
	    BEGIN
	    GSTADDR = .EXE_SECBOUNDS[0];
	    GSTADDR = .GSTADDR + 2 + ((.GSTADDR[0] + 1)/2)*2;
	    GSTADDR = .GSTADDR + 2 + ((.GSTADDR[0] + 1)/2)*2;
	    GST$BEGIN_ADDR = .GSTADDR;
	    GST$NEXT_ADDR = .GST$BEGIN_ADDR;
	    GST$REC_COUNT = .IMG_DST_BLOCK[IHS$W_GSTRECS] - 3;
	    END;

	END;


    ! If we have by now decided that there is no GST in the executable image, 
    ! we return FALSE to the caller so that the caller print a message saying 
    ! that there are no global symbols.
    !
    IF .GST$BEGIN_ADDR EQL 0 THEN RETURN FALSE;


    ! Set up the number of GST records to be read in.  Pick up the address of
    ! the current record, and update the pointer to the subsequent one.
    !
    GSTPTR = POSITION_GST(FALSE);
    IF .GSTPTR EQL 0 THEN SIGNAL(DBG$_INVGSTREC);


    ! Go through GST, build RST entries.
    !
    WHILE TRUE DO
	BEGIN


	! Check to see if there are no more GST records.
	!
	IF .GSTPTR EQL 0 THEN EXITLOOP;


	! See whether the current buffer address is beyond the end of the
	! end of the last GST record we looked at.  Note that we rounded up
	! GST$NEST_ADDR when calculating where the next GST record will begin.
	! Therefore we must temporarily round it down again when comparing it
	! with GSTPTR since it may point to the last unused byte in a GST
	! record.
	!
	IF (.GSTPTR GEQA .GST$NEXT_ADDR - 1)
	THEN
	    BEGIN
	    IF ((GSTPTR = POSITION_GST(TRUE)) EQL 0)
	    THEN


		! There are no more GST records.
		!
		EXITLOOP

	    ELSE
		

		! GET succeeded.  If the new record is a GST record, then
		! initialize the valiable GSTPTR to point to the first global
		! symbol definition block in this record.
		!
		BEGIN
		LOCAL
		    BUFFER_ADDRESS: REF VECTOR[,BYTE];

		BUFFER_ADDRESS = .GSTPTR;
		IF .BUFFER_ADDRESS[GST_RECORD_TYPE] EQL GST_TYPE
		THEN
		    GSTPTR = .GSTPTR + 1
		ELSE


		    ! This record is not a GST record. Go on to the next.
		    !
		    GSTPTR = %X'FFFFFFFF';

		END;

	    END


	! This is a global symbol.  Save its address.  Then update the
	! GSTPTR to point to the next symbol.
	!
	ELSE
	    BEGIN
	    ! Do a CASE on the GST record type and handle each type separately.
	    !
	    CASE .GSTPTR[GSD$B_RECTYP] FROM GSD$C_PSC TO GSD$C_SPSC OF
	        SET


		! DEBUG does not handle PSECT, just update the address.
		!
		[GSD$C_PSC]:
		    BEGIN
		    GSTPTR = .GSTPTR + GPS$C_NAME + .GSTPTR[GPS$B_NAMLNG];
		    END;


	        ! Handle the definition of a global symbol.  If this is the symbol
	        ! we are looking for, build an RST entry for it and return a pointer
	        ! to that RST entry.  Otherwise, continue the search.
	        !
	        [GSD$C_SYM]:
		    BEGIN
		    DBG$GST_TO_RST(.MODRSTPTR, GSTPTR[SDF$B_NAMLNG],.GSTPTR[SDF$L_VALUE] + .BASEADDR ,FALSE);
		    GSTPTR = .GSTPTR + SDF$C_NAME + .GSTPTR[SDF$B_NAMLNG];
		    END;


	        ! Handle the definition of a global routine or a global entry point.
	        ! If this is the symbol we are looking for, build an RST entry for
	        ! it and return the entry's address.  Otherwise continue the search.
	        !
	        [GSD$C_EPM,
	         GSD$C_PRO]:
		    BEGIN


    		    ! Keep track of the end address.  This is not needed for V4 system.
    		    !
	            IF (.GSTPTR[PRO$L_ADDRS] + .BASEADDR) GTR .IMAGE_MODULE_END_ADDR
	            THEN
		        IMAGE_MODULE_END_ADDR = .GSTPTR[PRO$L_ADDRS] + .BASEADDR;

		    DBG$GST_TO_RST(.MODRSTPTR, GSTPTR[PRO$B_NAMLNG],.GSTPTR[PRO$L_ADDRS] + .BASEADDR,TRUE);
		    CASE .GSTPTR[GSD$B_RECTYP] FROM GSD$C_EPM TO 
						    GSD$C_PRO OF
			SET

			[GSD$C_EPM]:
			    BEGIN
			    GSTPTR = .GSTPTR + EPM$C_NAME + .GSTPTR[EPM$B_NAMLNG];
			    END;

			[GSD$C_PRO]:
			    BEGIN
			    GSTPTR = .GSTPTR + PRO$C_NAME + .GSTPTR[PRO$B_NAMLNG];
			    NUM_ARGS = .GSTPTR[FML$B_MAXARGS];
			    GSTPTR = .GSTPTR + FML$C_SIZE;
			    DECR I FROM .NUM_ARGS-1 TO 0 BY 1 DO
			        BEGIN
				GSTPTR = .GSTPTR + .GSTPTR[ARG$B_BYTECNT] +
    				    ARG$C_SIZE;
				END;

			    END;

		        TES;

		    END;

    		[GSD$C_SPSC]:
    		    BEGIN
		    DBG$GST_TO_RST(.MODRSTPTR, GSTPTR[SGPS$B_NAMLNG],.GSTPTR[SGPS$L_BASE] + .BASEADDR,TRUE);
    		    GSTPTR = .GSTPTR + SGPS$C_NAME + .GSTPTR[SGPS$B_NAMLNG];
    		    END;


	        ! We signal error for all other kinds.  There are other
    		! kinds of GST records, but we do not encounter them
    		! so far, if you do encounter them, see Linker man. 
    		! (App. A) and Starlet.req.
	        !
	        [INRANGE, OUTRANGE]:
    		    BEGIN
		    SIGNAL(DBG$_INVGSTTYP);
    		    EXITLOOP;
    		    END;

	        TES;

	    END;			! End of ELSE a global symbol.

	END;				! End of WHILE loop over the GST.


    ! Release the Virtual address space occupied by Image header.
    !
    STATUS = SYS$DELTVA(EXE_HDRBOUNDS, EXE_HDRBOUNDS, 0);
    IF NOT .STATUS
    THEN
    	BEGIN
    	STATUS[STS$V_SEVERITY] = SYS$K_INFO;
    	SIGNAL(.STATUS);
    	END;


    ! Release the Virtual address space occupied by GST.
    !
    STATUS = SYS$DELTVA(EXE_SECBOUNDS, EXE_SECBOUNDS, 0);
    IF NOT .STATUS
    THEN
    	BEGIN
    	STATUS[STS$V_SEVERITY] = SYS$K_INFO;
    	SIGNAL(.STATUS);
    	END;


    ! Record the module size in the module RST.
    !
    MODRSTPTR[RST$L_MODRSTSIZ] = .IMAGE_MODULE_RST_SIZE * 4;


    ! Fill in the module size in the program static address table.
    ! Needed only for V3 system.
    !
    IF NOT .DBG$GV_CONTROL[DBG$V_CONTROL_VERSION_4]
    THEN
    	BEGIN
        IF .MODRSTPTR NEQ .RST$START_ADDR
        THEN
    	    BEGIN
    	    SATPTR = .SAT$START_ADDR;
    	    WHILE TRUE DO
    	        BEGIN
    	        IF .SATPTR EQL 0 THEN EXITLOOP;
    	        IF .SATPTR[SAT$L_RSTPTR] EQL .MODRSTPTR
    	        THEN
    		    BEGIN
    		    SATPTR[SAT$L_END] = .IMAGE_MODULE_END_ADDR;
    		    EXITLOOP;
    		    END;

    	        SATPTR = .SATPTR[SAT$L_FLINK];    	    
    		END;

    	    END;

    	END;

    RETURN TRUE;
    END;

GLOBAL ROUTINE DBG$GST_TO_RST(MODRSTPTR, NAMEPTR, VALUE, ROUTINE_FLAG) :NOVALUE =
!
! FUNCTION
!	This routine accepts the characteristics of a global symbol as input
!	and build a Run-Time Symbol Table (RST) entry for that symbol.
!	The global symbol has normally been looked up in the Global Symbol
!	Table (GST), and its name, value, and routine flag has been extracted
!	from the GST entry.  This routine is then called to convert that infor-
!	mation to the corresponding RST pointer.  A new RST
!	entry is constructed, added to the anonymous module's symbol chain,
!	and added to the RST Hash Table.  In addition, a "dummy" DST entry is
!	created for the symbol so that other symbol table access routines do
!	not have to make a special case of global symbols--these symbols seem
!	to have perfectly normal DST entries like all others.  The DST entry is
!	created in the same memory block as the RST entry.
!
! INPUTS
!	MODRSTPTR - Module RST pointer.
!
!	NAMEPTR	- A pointer to the global symbol's name, represented as a
!		  Counted ASCII string.
!
!	VALUE	- The value (i.e., address) of the global symbol.
!
!	ROUTINE_FLAG - A flag set to TRUE if the global symbol is a routine
!		  name.  If this flag is FALSE, the symbol is assumed to be
!		  a data symbol.
!
! OUTPUTS
!	None.
!

    BEGIN

    MAP
	MODRSTPTR: REF RST$ENTRY,	! Pointer to anonymous module RST entry
    					!      or shareable image module
	NAMEPTR: REF VECTOR[,BYTE];	! Pointer to Counted ASCII name of the
					!      global symbol

    LOCAL
	DSTPTR: REF DST$RECORD,		! Pointer to the dummy DST record we
					!      build for the global symbol
    	LENGTH,				! Length of the RST entry
	RSTPTR: REF RST$ENTRY;		! Pointer to the RST entry we construct
					!      for the global symbol



    ! The global symbol is not yet in the RST.  If it is a routine name, con-
    ! struct a Routine RST Entry and a corresponding dummy DST record for it.
    !
    IF .ROUTINE_FLAG
    THEN
	BEGIN
    	LENGTH = RST$K_ROUTENTSIZ + (11 + .NAMEPTR[0])/4;
    	IMAGE_MODULE_RST_SIZE = .IMAGE_MODULE_RST_SIZE + .LENGTH;
	RSTPTR = GET_MEM(.LENGTH);
	DSTPTR = .RSTPTR + 4*RST$K_ROUTENTSIZ;
	RSTPTR[RST$B_KIND] = RST$K_ROUTINE;
	RSTPTR[RST$L_STARTADDR] = .VALUE;
	RSTPTR[RST$L_ENDADDR] = .VALUE;
	RSTPTR[RST$L_BREAKADDR] = .VALUE + 2;
	DSTPTR[DST$B_LENGTH] = 7 + .NAMEPTR[0];
	DSTPTR[DST$B_TYPE] = DST$K_RTNBEG;
	DSTPTR[DST$V_RTNBEG_UNUSED] = 0;
	DSTPTR[DST$V_RTNBEG_NO_CALL] = FALSE;
	DSTPTR[DST$L_RTNBEG_ADDRESS] = .VALUE;
	CH$MOVE(.NAMEPTR[0] + 1, NAMEPTR[0], DSTPTR[DST$B_RTNBEG_NAME]);


    	! One additional thing we do here is: If the global symbol
    	! we are adding is for the routine LIB$SIGNAL, then we
    	! save away its address. This is later used in DBGEVENT
    	! to discover whether we are stepping over a call to LIB$SIGNAL.
    	! The way we can get LIB$SIGNAL in the GST is if the user
    	! links /NOSYSSHR.
    	!
    	IF CH$EQL(11, .NAMEPTR, 11, UPLIT(%ASCIC 'LIB$SIGNAL'))
    	THEN
    	    DBG$GL_LIB_SIGNAL_ADDR = .VALUE;
    	IF CH$EQL(9, .NAMEPTR, 9, UPLIT(%ASCIC 'LIB$STOP'))
    	THEN
    	    DBG$GL_LIB_STOP_ADDR = .VALUE;
	END


    ! If the global symbol is a data symbol, build a Data Item RST Entry for
    ! it.  Also construct the corresponding dummy DST record.  The DST data
    ! type is set to be longword integer.
    !
    ELSE
	BEGIN
    	LENGTH = RST$K_DATENTSIZ + (11 + .NAMEPTR[0])/4;
    	IMAGE_MODULE_RST_SIZE = .IMAGE_MODULE_RST_SIZE + .LENGTH;
	RSTPTR = GET_MEM(.LENGTH);
	DSTPTR = .RSTPTR + 4*RST$K_DATENTSIZ;
	RSTPTR[RST$B_KIND] = RST$K_DATA;
	RSTPTR[RST$L_TYPEPTR] = 0;
	DSTPTR[DST$B_LENGTH] = 7 + .NAMEPTR[0];
	DSTPTR[DST$B_TYPE] = DSC$K_DTYPE_L;
	DSTPTR[DST$B_VFLAGS] = 1;
	DSTPTR[DST$L_VALUE] = .VALUE;
	CH$MOVE(.NAMEPTR[0] + 1, NAMEPTR[0], DSTPTR[DST$B_NAME]);
	END;


    ! Fill in the remainder of the RST entry and mark the symbol as global.
    ! Attach the symbol to the anonymous module's symbol chain.
    !
    IF .MODRSTPTR EQL .RST$START_ADDR
    THEN
    	RSTPTR[RST$V_GLOBAL] = TRUE


    ! Make a Static Address Table Entry.
    !
    ELSE
    	BEGIN
    	IMAGE_MODULE_RST_SIZE = .IMAGE_MODULE_RST_SIZE + SAT$K_ENTSIZE;
    	STATIC_ADDRESS(.VALUE, 1, .RSTPTR, MODRSTPTR[RST$L_SAT_PTR], FALSE);
    	END;

    RSTPTR[RST$L_SYMCHNPTR] = .MODRSTPTR[RST$L_SYMCHNPTR];
    MODRSTPTR[RST$L_SYMCHNPTR] = .RSTPTR;
    RSTPTR[RST$L_DSTPTR] = .DSTPTR;
    RSTPTR[RST$L_UPSCOPEPTR] = .MODRSTPTR;
    RSTPTR[RST$W_REFCOUNT] = 0;
    DBG$HASH_INSERT(.RSTPTR);


    ! We are all done.
    !
    RETURN 0;

    END;

GLOBAL ROUTINE DBG$HASH_FIND(NAMEPTR) =
!
! FUNCTION
!	This routine looks up a specified symbol name in the RST Hash Table and
!	returns a pointer to the corresponding RST entry.  This routine is al-
!	ways used in conjunction with routine DBG$HASH_FIND_SETUP.  Since there
!	can in general be many RST entries with the same symbolic name, there
!	has to be a way of finding all such entries.  DBG$HASH_FIND_SETUP is
!	thus called to compute the initial hash index and to intialize this
!	search.  DBG$HASH_FIND can then be called repeatedly to find each indi-
!	vidual occurrence of the given name in the RST.  When no more RST
!	entries with that name are found, a zero RST pointer is returned.
!
! INPUTS
!	NAMEPTR	- A pointer to the counted string that gives the name of the
!		  symbol to be looked up.  This name must be a single symbol
!		  name, not a complete pathname.
!
!	The OWN variables DBG$HASH_RSTPTR and DBG$HASH_INDEX are implicit
!		  inputs.  These variables are set by DBG$HASH_FIND_SETUP
!		  initially.  Of these, variable DBG$HASH_RSTPTR is updated
!		  by this routine.
!
! OUTPUTS
!	A pointer to the next RST entry with the specified symbol name is
!		  returned as the routine's value.  If there are no more RST
!		  entries with that name, zero is returned.
!
!	DBG$HASH_RSTPTR is an implicit output.  It is updated to contain the
!		  returned RST pointer.
!

    BEGIN

    MAP
	NAMEPTR: REF VECTOR[,BYTE];	! A pointer to a counted string contain-
					!      ing the desired symbol name

    LOCAL
	DSTNAMEPTR: REF VECTOR[,BYTE];	! Pointer to DST name counted string



    ! Loop through the current RST hash chain until the chain ends, i.e. until
    ! we get back to the chain list head.  For each RST entry, we see if it has
    ! the name we are searching for.  If it does, we return it to the caller.
    !
    IF .DBG$HASH_RSTPTR EQL 0 THEN $DBG_ERROR('RSTCNTRL\HASH_FIND');
    DBG$HASH_RSTPTR = .DBG$HASH_RSTPTR[RST$L_HASH_FLINK];
    WHILE .DBG$HASH_RSTPTR NEQ RST$HASH_TABLE[2*.DBG$HASH_INDEX] DO
	BEGIN
	IF .DBG$HASH_RSTPTR[RST$V_GLOBAL]
	THEN
	    DBG$STA_SYMNAME(.DBG$HASH_RSTPTR, DSTNAMEPTR)
	ELSE
	    DSTNAMEPTR = DBG$GET_DST_NAME(.DBG$HASH_RSTPTR[RST$L_DSTPTR]);

	IF CH$EQL(.NAMEPTR[0], NAMEPTR[1], .DSTNAMEPTR[0], DSTNAMEPTR[1], 0)
	THEN
	    RETURN .DBG$HASH_RSTPTR;

	DBG$HASH_RSTPTR = .DBG$HASH_RSTPTR[RST$L_HASH_FLINK];
	END;


    ! The hash chain ended before we found another RST symbol with the same
    ! name.  Set DBG$HASH_RSTPTR to zero and return that as the routine value.
    !
    DBG$HASH_RSTPTR = 0;
    RETURN 0;

    END;

GLOBAL ROUTINE DBG$HASH_FIND_SETUP(NAMEPTR): NOVALUE =
!
! FUNCTION
!	This routine sets up a search through the RST hash table for a specified
!	symbol name.  The routine computes the symbol's hash index and saves it
!	and a pointer to the corresponding RST hash chain's list head in OWN
!	variables where they can be accessed by routine DBG$HASH_FIND.  After
!	the initial DBG$HASH_FIND_SETUP call, DBG$HASH_FIND should be called
!	repeatedly to find all RST entries with the specified symbol name.
!
!	Note that the hashing method is encoded both here and in routine
!	DBG$HASH_INSERT.  If it is changed in one place, it must be changed
!	in the other as well.
!
! INPUTS
!	NAMEPTR	- A pointer to the counted string that gives the name of the
!		  symbol to be looked up.  This name must be a single symbol
!		  name, not a complete pathname.
!
! OUTPUTS
!	No value is returned by DBG$HASH_FIND_SETUP.
!
!	There are two implicit outputs: DBG$HASH_INDEX and DBG$HASH_RSTPTR
!		  are set so they can be used by routine DBG$HASH_FIND.
!

    BEGIN

    MAP
	NAMEPTR: REF VECTOR[,BYTE];	! Pointer to symbol name counted string

    LOCAL
    	WORD_NAMEPTR: REF VECTOR[,WORD];! Pointer to symbol name counted string,
    					! used to access the string one word at
    					! a time.


    ! Compute the hash index for the specified symbol name.  Set DBG$HASH_INDEX
    ! and DBG$HASH_RSTPTR so they can be used by the DBG$HASH_FIND routine.
    !
    ! The hash algorithm is as follows:
    ! Add up the words in the name. (If the number of bytes is odd then include
    ! the count byte in the first word so it comes out even.) Then take
    ! that sum modulo the hash table size.
    !
    IF (.NAMEPTR[0] MOD 2) EQL 0
    THEN
    	WORD_NAMEPTR = NAMEPTR[1]
    ELSE
    	WORD_NAMEPTR = NAMEPTR[0];

    DBG$HASH_INDEX = 0;
    INCR I FROM 0 TO (.NAMEPTR[0]+1)/2-1 DO
	DBG$HASH_INDEX = .DBG$HASH_INDEX + .WORD_NAMEPTR[.I];

    DBG$HASH_INDEX = .DBG$HASH_INDEX MOD RST$K_HASHTBLSIZE;
    DBG$HASH_RSTPTR = RST$HASH_TABLE[2*.DBG$HASH_INDEX];
    RETURN;

    END;

GLOBAL ROUTINE DBG$HASH_INSERT(RSTPTR): NOVALUE =
!
! FUNCTION
!	This routine inserts an RST entry in the RST Hash Table.  The symbolic
!	name associated with the RST entry is looked up the DST and is hashed.
!	The RST entry is then linked into the corresponding hash chain.
!
!	Note that the hashing method is encoded both here and in routine
!	DBG$HASH_FIND_SETUP.  If it is changed in one place, it must thus
!	be changed in the other as well.
!
! INPUTS
!	RSTPTR	- A pointer to the RST entry to be inserted in the hash table.
!
! OUTPUTS
!	NONE
!

    BEGIN

    MAP
	RSTPTR: REF RST$ENTRY;		! A pointer to the RST entry to be
					!      inserted in the RST Hash Table

    LOCAL
	HASHINDEX,			! The computed hash index.
	NAMEPTR: REF VECTOR[,BYTE],	! Pointer to symbol name (counted ASCII)
	NEXTPTR: REF RST$ENTRY,		! A pointer to the RST entry in the hash
					!      chain before which the new RST
					!      entry is inserted.
	PREVPTR: REF RST$ENTRY,		! A pointer to the RST entry in the hash
					!      chain after which the new RST
					!      entry is inserted.
    	WORD_NAMEPTR: REF VECTOR[,WORD];! Pointer to symbol name counted string,
    					! used to access the string one word at
    					! a time.




    ! Get the RST entry's symbol name from the DST and compute its hash index.
    !
    IF .RSTPTR[RST$V_GLOBAL]
    THEN
	DBG$STA_SYMNAME(.RSTPTR, NAMEPTR)
    ELSE
	NAMEPTR = DBG$GET_DST_NAME(.RSTPTR[RST$L_DSTPTR]);


    ! Compute the hash index for the specified symbol name.  Set DBG$HASH_INDEX
    ! and DBG$HASH_RSTPTR so they can be used by the DBG$HASH_FIND routine.
    !
    ! The hash algorithm is as follows:
    ! Add up the words in the name. (If the number of bytes is odd then include
    ! the count byte in the first word so it comes out even.) Then take
    ! that sum modulo the hash table size.
    !
    IF (.NAMEPTR[0] MOD 2) EQL 0
    THEN
    	WORD_NAMEPTR = NAMEPTR[1]
    ELSE
    	WORD_NAMEPTR = NAMEPTR[0];

    HASHINDEX = 0;
    INCR I FROM 0 TO (.NAMEPTR[0]+1)/2-1 DO
	HASHINDEX = .HASHINDEX + .WORD_NAMEPTR[.I];

    HASHINDEX = .HASHINDEX MOD RST$K_HASHTBLSIZE;


    ! Link the RST entry into the appropriate hash chain.
    !
    PREVPTR = RST$HASH_TABLE[2*.HASHINDEX];
    NEXTPTR = .PREVPTR[RST$L_HASH_FLINK];
    RSTPTR[RST$L_HASH_FLINK] = .NEXTPTR;
    RSTPTR[RST$L_HASH_BLINK] = .PREVPTR;
    PREVPTR[RST$L_HASH_FLINK] = .RSTPTR;
    NEXTPTR[RST$L_HASH_BLINK] = .RSTPTR;
    RETURN;

    END;

GLOBAL ROUTINE DBG$RST_BUILD(MODRSTPTR): NOVALUE =
!
! FUNCTION
!	This routine builds the RST for a specified module.  It takes as input a
!	pointer to the desired module's Module RST Entry.  From that it can get
!	to the module's DST records which are scanned until the Module-End DST
!	record is found.  For each DST record, a corresponding RST entry is cre-
!	ated if appropriate.  Each such RST entry is added to the module's sym-
!	bol chain and to the RST Hash Table.  Symbols with static addresses are
!	added to the module's Static Address Table (SAT) as well.
!
! INPUTS
!	MODRSTPTR - A pointer to the Module RST Entry of the module whose RST
!		  is to be built.
!
! OUTPUTS
!	The RST for the specified module is constructed.  No value is returned.
!

    BEGIN

    MAP
	MODRSTPTR: REF RST$ENTRY;	! Pointer to the Module RST Entry of the
					!      module whose RST is to be built

    LITERAL
	MAX_NESTING	= 50;		! Maximum lexical and record component
					!      nesting we will allow

    FIELD RS_FIELDS =			! Field definitions for RECSTACK array
	SET				!      to handle nested data records
	RS_CLPTR	= [ 0, L_ ],	! Component list pointer
	RS_CLSIZ	= [ 1, L_ ],	! Component list size
	RS_RCDST	= [ 2, L_ ],	! Record Begin DST address
	RS_VRPTR	= [ 3, L_ ],	! Variant record pointer
	RS_TRSIZ	= [ 4, L_ ]	! Type record size in longwords
	TES;

    LOCAL
	ADDRESS,			! Static address to be added to SAT
	ARRAY_FLAG,			! Flag set if item is array of records
	BLINK: REF RST$ENTRY,		! RST entry backward hash link
    	BUILD_TYPE_TABLE,		! Flag saying whether we have to build
    					!      a type reference table.
	COBOLGBL_FLAG,			! Flag set to TRUE is the COBOL "global"
					!      attribute applies to the next
					!      symbol defined in the DST
	COMP_LST_PTR: REF VECTOR[,LONG],! Pointer to current component list
	COMP_LST_SIZE,			! Size of current component list block
	CONTINUATION_DST_SEEN:		! Flag set when a Continuation DST
			INITIAL(FALSE),	!      record is seen
	DSTPTR: REF DST$RECORD,		! Pointer to the current DST record
	NEXT_DSTPTR: REF DST$RECORD,	! Pointer to the next DST record
	DSTPTR_TO_SAVE,			! The DST pointer to be saved in the
					!      current RST entry
	DST_TYPE,			! The DST type of the current DST record
	ENUM_BITSIZE,			! Bit-size of current enumeration type
	ENUMELT: REF VECTOR[,LONG],	! Pointer to enumeration element list in
					!      the Type RST Entry
	ENUM_DSTPTR,			! Pointer to Enumeration Type Begin DST
					!      record for current enum type
	ENUM_LST_PTR: REF VECTOR[,LONG],! Pointer to list block used to accumu-
					!      late enumeration type elements
	ENUM_LST_SIZE,			! Size of the ENUM_LST_PTR memory block
	FLINK: REF RST$ENTRY,		! RST entry forward hash link
	LENGTH,				! Length of static address to add to SAT
	MODNAMEPTR,			! Pointer to the module name as Counted
					!      ASCII--used for error messages
	MOD_PC_TBL: REF VECTOR[,LONG],	! Pointer to Module RST Entry vector of
					!      PC Correlation Table pointers
	MOD_SRC_TBL: REF VECTOR[,LONG],	! Pointer to Module RST Entry vector of
					!      pointers to module's Source Line
					!      Correlation DST Records
	NAMEPTR,			! Pointer to symbol name counted ASCII
	NEST_FLAG,			! Set to TRUE if the new RST entry def-
					!      ines a new level of nesting
	NESTING,			! Current DST record nesting depth
	NEST_STACK: VECTOR[MAX_NESTING],! Stack containing RST pointers for
					!      nested DST items: lexical enti-
					!      ties and record components
    	NESTING_BREAK,			! Current DST record break address 
    					!      nesting depth
    	NEST_BREAK_STACK: VECTOR[MAX_NESTING],
    					! Stack containing RST pointers for
    					!      nested DST items: Routine and
    					!      Entry begin 
	NEWENT_FLAG,			! Flag set to TRUE if a new RST entry is
					!      being built from this DST record
	NUM_PC_TBLS,			! Number of PC-Correlation Tables in the
					!      DST for the module being SET
	NUM_SRC_DSTS,			! Number of Source Line Correlation DST
					!      Records for module being SET
	PC_CORR_SIZE,			! Size of the PC_CORR_TBL memory block
	PC_CORR_TBL: REF VECTOR[,LONG],	! Pointer to table of pointers to the
					!      DST PC-Correlation Table records
					!      for the module being SET
	PCTBL_BASE,			! Base address for offsets in current
					!      module's PC-Correlation Tables
	PPTR: REF DST$PSECT_TRAILER,	! Pointer to PSECT DST record trailer
	RECBEGTRLR:			! Pointer to Record Begin DST record's
		REF DST$RECBEG_TRLR,	!      trailer fields
	REC_DSTPTR: REF DST$RECORD,	! Pointer to Record Begin DST record
	RECSTACK: BLOCKVECTOR		! Record stack to keep track of nested
		[MAX_NESTING, 5]	!      record and variant definitions
		FIELD(RS_FIELDS),	!
	RSPTR,				! Current RECSTACK index (next available
					!      location in RECSTACK)
	RSTPOINTER : REF RST$ENTRY,	! Pointer to an RST entry
	RSTPTR: REF RST$ENTRY,		! Pointer to the RST entry we are
					!      currently building
	RST_PTR: REF RST$ENTRY,		! RST Entry pointer--used when fixing up
					!      pointers to continued DST records
	SRC_CORR_SIZE,			! Size of the SRC_CORR_TBL memory block
	SRC_CORR_TBL: REF VECTOR[,LONG],! Pointer to the table of pointers to
					!      the Source Line Correlation DST
					!      records of the module being SET
	STATIC_FLAG,			! Flag set to TRUE for static data items
	SYMCHNPTR: REF RST$ENTRY,	! Pointer to the last entry on the mod-
					!      ule's symbol chain
	TSPTR: REF DST$TYPE_SPEC,	! Pointer to a type spec in a DST record
	TAGDSTPTR,			! Address of the DST record of a record
					!      variant's tag variable
	TAGRSTPTR,			! Address of the RST entry of a record
					!      variant's tag variable
	TYPCOMPLST: REF VECTOR[,LONG],	! Pointer to Type Component List
	TYPE_DST_LST: REF VECTOR[,LONG],! Pointer to DST part of DST to RST
					!      translate table for type entries
	TYPE_DST_LEN,			! Size of TYPE_RST_LST memory block
	TYPEPTR: REF RST$ENTRY,		! Pointer to Type RST Entry
	TYPE_RST_LST: REF VECTOR[,LONG],! Pointer to RST part of DST to RST
					!      translate table for type entries
	TYPE_RST_LEN,			! Size of TYPE_DST_LST memory block
	TYPREFTBL: REF VECTOR[,LONG],	! Pointer to Type RST Entry's type
					!      reference table
	TYP_RST_SIZE,			! Size in longwords needed for the Type
					!      RST memory block being built
	UNNEST_FLAG,			! Set to TRUE if this DST entry termi-
					!      nates a level of DST nesting
	VARBEG_DSTPTR:			! Pointer to the Variant-Set Begin DST
		REF DST$VARBEG_TRAILER,	!      record trailer fields
	VARIANT_ENTRY:			! Pointer to Variant RST Entry--used to
		REF RST$VAR_ENTRY,	!      fix up pointers to continued DST
					!      records
	VARIANT_VALUE_FOUND,		! Set to TRUE when a DST$K_VARVAL
					!      record has been found
	VAR_REC_PTR: REF RST$ENTRY,	! Pointer to the current Variant RST
					!      Entry being built
	VARSETTBL: REF VECTOR[,LONG];	! Pointer to Variant Set Table--used to
					!      fix up pointers to continued DST
					!      records

    ENABLE
	RST_BUILD_ERROR_HANDLER;	! Set up error handler for DBG$_NOFREE



    ! We have declared an error handler to handle the DBG$_NOFREE condition,
    ! i.e. running out of memory while building the module's RST.  The handler 
    ! removes the partially built module from the RST.  We set the address of
    ! the Module RST Entry in MOD_BEING_BUILT for the error handler to use.
    ! This handler also handles the abort-on-control-Y condition.
    !
    MOD_BEING_BUILT = .MODRSTPTR;


    ! If the module's RST has already been built, we return immediately.
    ! Otherwise, we set the Module-in-RST flag and continue processing.
    !
    IF .MODRSTPTR[RST$B_KIND] NEQ RST$K_MODULE
    THEN
	$DBG_ERROR('RSTCNTRL\RST_BUILD 10');

    IF .MODRSTPTR[RST$V_MOD_IN_RST] THEN RETURN;
    MODRSTPTR[RST$V_MOD_IN_RST] = TRUE;


    ! Mark this as the Most Recently Used module.  (The Most Recently Used mod-
    ! ule will not be removed by DBG$GET_MEMORY to get more free space.)
    !
    DBG$RST_MOST_RECENT(.MODRSTPTR);


    ! Build shareable image RST entries.
    !
    IF .MODRSTPTR[RST$V_SHARE_IMAGE]
    THEN
    	BEGIN
    	IF NOT DBG$GST_INIT(.MODRSTPTR[RST$B_IMGFILCHAN], .MODRSTPTR[RST$L_BASEVA],
    			.MODRSTPTR)
    	THEN
    	    SIGNAL(DBG$_NOUNIVERSALS);

    	RETURN;
    	END;


    ! Set the Debug Symbol Table (DST) pointer to point to the first DST record
    ! after the specified module's Module-Begin record.  Note that we pick up
    ! the language code from the Module Begin DST Record--unless the module has
    ! been SET before, it may not be right in the Module RST Entry.
    !
    DSTPTR = .MODRSTPTR[RST$L_DSTPTR];
    IF .DSTPTR[DST$B_TYPE] NEQ DST$K_MODBEG THEN SIGNAL(DBG$_INVDSTREC);
    MODRSTPTR[RST$B_LANGUAGE] = .DSTPTR[DST$L_MODBEG_LANGUAGE];
    MODNAMEPTR = DSTPTR[DST$B_MODBEG_NAME];
    DSTPTR = DBG$RST_NEXT_DST( .DSTPTR );									! M015


    ! If this is a PL/I module, we set the "old PL/I flag" to indicate that we
    ! must compensate for the incorrect data descriptors generated by old ver-
    ! sions of the PL/I compiler.  This flag is cleared if we find a Version
    ! DST Record for this module later in the DST scan.
    !
    IF .MODRSTPTR[RST$B_LANGUAGE] EQL DBG$K_PLI
    THEN
	MODRSTPTR[RST$V_OLDPLIFLAG] = TRUE;


    ! Initialize the module's Static Address Table pointer to zero.  Also set up
    ! the module's symbol chain pointer.  Clear a random flag as well.
    !
    MODRSTPTR[RST$L_SAT_PTR] = 0;
    SYMCHNPTR = .MODRSTPTR;
    COBOLGBL_FLAG = FALSE;


    ! Set up the two buffers we will use to accumulate pointers to the module's
    ! PC-Correlation Table DST Records and its Source-Line Correlation DST
    ! Records.  Initialize the number of such records to zero and set the PC-
    ! Correlation Table base address to the largest possible address.
    !
    NUM_PC_TBLS = 0;
    PC_CORR_SIZE = 100;
    PC_CORR_TBL = GET_MEM(.PC_CORR_SIZE);
    NUM_SRC_DSTS = 0;
    SRC_CORR_SIZE = 100;
    SRC_CORR_TBL = GET_MEM(.SRC_CORR_SIZE);
    PCTBL_BASE = %X'7FFFFFFF';


    ! Initialize the lexical nesting stack to have one entry pointing to the
    ! Module RST Entry.
    !
    NESTING = 0;
    NEST_STACK[0] = .MODRSTPTR;


    ! Initialize the break address nesting stack.
    !
    NESTING_BREAK = 0;
    NEST_BREAK_STACK[0] = 0;


    ! Initialize the record and variant nesting stack to be empty and initialize
    ! the variables which keep track of record and variant components.
    !
    RSPTR = 0;
    COMP_LST_PTR = 0;
    COMP_LST_SIZE = 0;
    REC_DSTPTR = 0;
    VAR_REC_PTR = 0;
    TYP_RST_SIZE = 0;
    ENUM_LST_PTR = 0;


    ! Initialize the BUILD_TYPE_TABLE flag. This flag tells us whether we have
    ! encountered any record types, for which we have to build a type
    ! reference table. Avoiding the build of this table saves us some loops
    ! over the RST at the end.
    !
    BUILD_TYPE_TABLE = FALSE;


    ! Now loop over the whole DST for this module.  For each DST record we find,
    ! we build the appropriate RST record and link all such records on the mod-
    ! ule's symbol chain.  Each such symbol is also inserted in the RST Hash
    ! Table.
    !
    WHILE TRUE DO
	BEGIN


	! If the user entered Control-Y DEBUG, we signal our way out to abort
	! the current command.  The error handler does the necessary cleanup.
	!
	$ABORT_ON_CONTROL_Y;


	! Initialize flags for this DST record and get the DST record type.
	!
	NEWENT_FLAG = FALSE;
	NEST_FLAG = FALSE;
	UNNEST_FLAG = FALSE;
	DST_TYPE = DST$K_MODBEG;
	IF .DSTPTR LSSU .DST$END_ADDR
	THEN
	    DST_TYPE = .DSTPTR[DST$B_TYPE];


	! Merge this DST record with its Continuation DST records (if any) and
	! set a flag if any continuation DST records have been seen.
	!
	IF MERGE_CONTINUATION_DST( DSTPTR, NEXT_DSTPTR )	
	THEN							
	    CONTINUATION_DST_SEEN = TRUE;			

	DSTPTR_TO_SAVE = .DSTPTR;


	! Now handle each type of DST record individually.
	!
	CASE .DST_TYPE FROM 0 TO 255 OF
	    SET


	    ! Handle the Module-Begin record.  Since the Module-End record seems
	    ! to be missing, we signal an error and terminate the DST scan.
	    !
	    [DST$K_MODBEG]:
		BEGIN
		SIGNAL(DBG$_MISMODEND, 1, .MODNAMEPTR);
		EXITLOOP;
		END;


	    ! Handle the Module-End record.  Terminate the DST scan normally
	    ! after checking that the nesting level is down to 1.
	    !
	    [DST$K_MODEND]:
		BEGIN
		IF .NESTING NEQ 0 OR .NESTING_BREAK NEQ 0
    		THEN 
    		    SIGNAL(DBG$_INCDSTNES, 1, .MODNAMEPTR);
		EXITLOOP;
		END;


	    ! Handle the Version record.  This record gives the version number
	    ! of the compiler that generated the current module.  If this is a
	    ! PL/I module and a Version DST record is present, we clear the
	    ! "old PL/I flag" in the Module RST Entry.  (This is the flag that
	    ! tells us to compensate for the incorrect symbol descriptors gene-
	    ! rated by old versions of the PL/I compiler.)
	    !
	    [DST$K_VERSION]:
		BEGIN
		IF .MODRSTPTR[RST$B_LANGUAGE] EQL DBG$K_PLI
		THEN
		    MODRSTPTR[RST$V_OLDPLIFLAG] = FALSE;

		END;


	    ! Handle the PSECT record.  Enter it in the symbol table only if
	    ! the language is MACRO.  Also make a Static Address Table entry.
	    !
	    [DST$K_PSECT]:
		BEGIN
		IF .MODRSTPTR[RST$B_LANGUAGE] EQL DBG$K_MACRO
		THEN
		    BEGIN


		    ! See if there already is a label with the same name as the
		    ! PSECT name (PSECTs are always declared last in MACRO).  If
		    ! so, do not build a Label RST Entry for the PSECT.
		    !
		    NAMEPTR = DBG$GET_DST_NAME(.DSTPTR);
		    DBG$HASH_FIND_SETUP(.NAMEPTR);
		    WHILE TRUE DO
			BEGIN
			RSTPTR = DBG$HASH_FIND(.NAMEPTR);


			! If there is no previous definition for the PSECT name,
			! make a Label RST Entry for it.  Also make a Static
			! Address Table entry.
			!
			IF .RSTPTR EQL 0
			THEN
			    BEGIN
			    RSTPTR = DBG$GET_MEMORY(RST$K_LBLENTSIZ);
			    RSTPTR[RST$B_KIND] = RST$K_LABEL;
			    RSTPTR[RST$L_STARTADDR] = .DSTPTR[DST$L_PSECT_VALUE];
			    NEWENT_FLAG = TRUE;
			    PPTR = DSTPTR[DST$A_PSECT_TRLR_BASE]
					+ .DSTPTR[DST$B_PSECT_TRLR_OFFS];
			    LENGTH = .PPTR[DST$L_PSECT_SIZE];
			    RSTPTR[RST$V_NONZLENGTH] = TRUE;
			    STATIC_ADDRESS(.RSTPTR[RST$L_STARTADDR], .LENGTH,
				.RSTPTR, MODRSTPTR[RST$L_SAT_PTR], FALSE);
			    EXITLOOP;
			    END;


			! If there already is a definition for the PSECT name in
			! the current scope (i.e., the user defined a label by
			! the same name), exit the name search loop without
			! making a Label RST Entry for the PSECT.
			!
			IF .RSTPTR[RST$L_UPSCOPEPTR] EQL .NEST_STACK[.NESTING]
			THEN
			    EXITLOOP;

			END;		! End of Hash Table search loop

		    END;		! End of language = MACRO if statement

		END;


	    ! Handle the Line Number/PC Correlation Table record.  Here we save
	    ! its address in a temporary buffer.  It will later be moved to a
	    ! special table pointed to by the Module RST Entry.  Note that we
	    ! expand the buffer which holds the DST pointers if it overflows.
	    !
	    [DST$K_LINE_NUM,
	     DST$K_LINE_NUM_REL_R11]:
		BEGIN
		IF .NUM_PC_TBLS GEQ .PC_CORR_SIZE
		THEN
		    BEGIN
		    MOD_PC_TBL = .PC_CORR_TBL;
		    PC_CORR_SIZE = .PC_CORR_SIZE + 100;
		    PC_CORR_TBL = DBG$GET_MEMORY(.PC_CORR_SIZE);
		    CH$MOVE(4*.NUM_PC_TBLS, .MOD_PC_TBL, .PC_CORR_TBL);
		    DBG$REL_MEMORY(.MOD_PC_TBL);
		    END;

		PC_CORR_TBL[.NUM_PC_TBLS] = .DSTPTR;
		NUM_PC_TBLS = .NUM_PC_TBLS + 1;
		END;


	    ! Handle the Source Line Correlation record.  Here we save its
	    ! address in a temporary buffer.  It will later be moved into a
	    ! special table pointed to by the Module RST Entry.  Note that we
	    ! expand the buffer which holds the DST pointers if it overflows.
	    !
	    [DST$K_SOURCE]:
		BEGIN
		IF .NUM_SRC_DSTS GEQ .SRC_CORR_SIZE
		THEN
		    BEGIN
		    MOD_SRC_TBL = .SRC_CORR_TBL;
		    SRC_CORR_SIZE = .SRC_CORR_SIZE + 100;
		    SRC_CORR_TBL = DBG$GET_MEMORY(.SRC_CORR_SIZE);
		    CH$MOVE(4*.NUM_SRC_DSTS, .MOD_SRC_TBL, .SRC_CORR_TBL);
		    DBG$REL_MEMORY(.MOD_SRC_TBL);
		    END;

		SRC_CORR_TBL[.NUM_SRC_DSTS] = .DSTPTR;
		NUM_SRC_DSTS = .NUM_SRC_DSTS + 1;
		END;


	    ! Handle the Routine-Begin record.  Create the Routine RST Entry and
	    ! make a NEST_STACK entry so we know when the matching Routine-End
	    ! record is found (except that MACRO has no Routine-End records).
	    !
	    [DST$K_RTNBEG]:
		BEGIN
		RSTPTR = DBG$GET_MEMORY(RST$K_ROUTENTSIZ);
		RSTPTR[RST$B_KIND] = RST$K_ROUTINE;
		RSTPTR[RST$L_STARTADDR] = .DSTPTR[DST$L_RTNBEG_ADDRESS];
		RSTPTR[RST$L_ENDADDR] = .RSTPTR[RST$L_STARTADDR];
	        IF .NESTING_BREAK GEQ MAX_NESTING
	        THEN
		    SIGNAL(DBG$_DSTNESDEP, 1, .MODNAMEPTR);

    		! Language MACRO does not have routine end dst record.
    		! 
    		IF .MODRSTPTR[RST$B_LANGUAGE] NEQ DBG$K_MACRO
    		THEN
	            NESTING_BREAK = .NESTING_BREAK + 1;

	        NEST_BREAK_STACK[.NESTING_BREAK] = .RSTPTR;
		IF .DSTPTR[DST$V_RTNBEG_NO_CALL]
		THEN
		    RSTPTR[RST$L_BREAKADDR] = .RSTPTR[RST$L_STARTADDR]

		ELSE
		    RSTPTR[RST$L_BREAKADDR] = .RSTPTR[RST$L_STARTADDR] + 2;

		NEWENT_FLAG = TRUE;
		IF .PCTBL_BASE GTR .DSTPTR[DST$L_RTNBEG_ADDRESS]
		THEN
		    PCTBL_BASE = .DSTPTR[DST$L_RTNBEG_ADDRESS];

		IF .MODRSTPTR[RST$B_LANGUAGE] EQL DBG$K_MACRO
		THEN
		    STATIC_ADDRESS(.RSTPTR[RST$L_STARTADDR], 0, .RSTPTR,
					MODRSTPTR[RST$L_SAT_PTR], FALSE)
		ELSE
		    NEST_FLAG = TRUE;

		END;


	    ! Handle the Routine-End record.  Compute the routine end address,
	    ! add it to the Routine RST Entry, make a Static Address Table
	    ! entry, and pop NEST_STACK.
	    !
	    [DST$K_RTNEND]:
		BEGIN
    		NESTING_BREAK = .NESTING_BREAK - 1;
		RSTPTR = .NEST_STACK[.NESTING];
		IF .RSTPTR[RST$B_KIND] NEQ RST$K_ROUTINE
		THEN
		    SIGNAL(DBG$_INCDSTNES, 1, .MODNAMEPTR);

		LENGTH = .DSTPTR[DST$L_RTNEND_SIZE];
		IF .LENGTH LSS 1 THEN LENGTH = 1;
		RSTPTR[RST$L_ENDADDR] = .RSTPTR[RST$L_STARTADDR] + .LENGTH - 1;
		RSTPTR[RST$V_NONZLENGTH] = TRUE;
		STATIC_ADDRESS(.RSTPTR[RST$L_STARTADDR], .LENGTH, .RSTPTR,
					MODRSTPTR[RST$L_SAT_PTR], FALSE);
		UNNEST_FLAG = TRUE;
		END;


	    ! Handle the Lexical Block-Begin record.  Create the Lexical Block
	    ! RST Entry and push the block on NEST_STACK.
	    !
	    [DST$K_BLKBEG]:
		BEGIN
		RSTPTR = DBG$GET_MEMORY(RST$K_LEXENTSIZ);
		RSTPTR[RST$B_KIND] = RST$K_BLOCK;
		RSTPTR[RST$L_STARTADDR] = .DSTPTR[DST$L_BLKBEG_ADDRESS];
		RSTPTR[RST$L_ENDADDR] = .RSTPTR[RST$L_STARTADDR];
		NEWENT_FLAG = TRUE;
		NEST_FLAG = TRUE;
		END;


	    ! Handle the Lexical Block-End record.  Compute the block's end ad-
	    ! dress, add it to the RST entry, make a Static Address Table entry,
	    ! and pop NEST_STACK.
	    !
	    [DST$K_BLKEND]:
		BEGIN
		RSTPTR = .NEST_STACK[.NESTING];
		IF .RSTPTR[RST$B_KIND] NEQ RST$K_BLOCK
		THEN
		    SIGNAL(DBG$_INCDSTNES, 1, .MODNAMEPTR);

		LENGTH = .DSTPTR[DST$L_BLKEND_SIZE];
		IF .LENGTH LSS 1 THEN LENGTH = 1;
		RSTPTR[RST$L_ENDADDR] = .RSTPTR[RST$L_STARTADDR] + .LENGTH - 1;
		RSTPTR[RST$V_NONZLENGTH] = TRUE;
		STATIC_ADDRESS(.RSTPTR[RST$L_STARTADDR], .LENGTH, .RSTPTR,
					MODRSTPTR[RST$L_SAT_PTR], FALSE);
		UNNEST_FLAG = TRUE;
		END;


	    ! Handle the Prolog record.  The Prolog DST record specifies the
	    ! address of the first instruction after the current routine's
	    ! prolog code, i.e. after the code needed to set up descriptors,
	    ! initialize the stack, and so on.  A routine breakpoint is set at
	    ! the prolog address for any routine that has a Prolog DST record.
	    !
	    [DST$K_PROLOG]:
		BEGIN
	        RSTPTR = .NEST_BREAK_STACK[.NESTING_BREAK];
    		IF .RSTPTR NEQ 0
    		THEN
		    RSTPTR[RST$L_BREAKADDR] = .DSTPTR[DST$L_PROLOG_BKPT_ADDR];
		END;


	    ! Handle the Static Link record.  Just put a pointer to this DST
	    ! record in the Routine RST Entry currently on top of the nesting
	    ! stack.  If the top of the nesting stack is not a routine, signal
	    ! an error.
	    !
	    [DST$K_STATLINK]:
		BEGIN
		RSTPTR = .NEST_STACK[.NESTING];
		IF .RSTPTR[RST$B_KIND] NEQ RST$K_ROUTINE
		THEN
		    SIGNAL(DBG$_INCDSTNES, 1, .MODNAMEPTR);

		RSTPTR[RST$L_STATIC_LINK] = .DSTPTR;
		END;


	    ! Handle the Label record.  Create a Label RST Entry for it and make
	    ! a Static Address Table entry.
	    !
	    [DST$K_LABEL]:
		BEGIN
		RSTPTR = BUILD_LABEL_RST(.DSTPTR);
		DSTPTR_TO_SAVE = .RSTPTR[RST$L_DSTPTR];
		RSTPTR[RST$B_KIND] = RST$K_LABEL;
		RSTPTR[RST$L_STARTADDR] = .DSTPTR[DST$L_VALUE];
		NEWENT_FLAG = TRUE;
		STATIC_ADDRESS(.RSTPTR[RST$L_STARTADDR], 0, .RSTPTR,
					MODRSTPTR[RST$L_SAT_PTR], FALSE);
		END;


	    ! Handle the Label-or-Literal record.  If this is an instruction
	    ! label, create a Label RST Entry and a Static Address Table entry.
	    ! If this is a literal, create a Data Item RST Entry for it.
	    !
	    [DST$K_LBLORLIT]:
		BEGIN
		IF .DSTPTR[DST$B_VFLAGS] EQL 1
		THEN
		    BEGIN
		    RSTPTR = BUILD_LABEL_RST(.DSTPTR);
		    DSTPTR_TO_SAVE = .RSTPTR[RST$L_DSTPTR];
		    RSTPTR[RST$B_KIND] = RST$K_LABEL;
		    RSTPTR[RST$L_STARTADDR] = .DSTPTR[DST$L_VALUE];
		    STATIC_ADDRESS(.RSTPTR[RST$L_STARTADDR], 0, .RSTPTR,
					MODRSTPTR[RST$L_SAT_PTR], FALSE);
		    END

		ELSE
		    BEGIN
		    RSTPTR = DBG$GET_MEMORY(RST$K_DATENTSIZ);
		    RSTPTR[RST$B_KIND] = RST$K_DATA;
		    RSTPTR[RST$L_TYPEPTR] = 0;
		    END;

		NEWENT_FLAG = TRUE;
		END;


	    ! Handle the Entry-Point record.  Create an Entry-Point RST Entry
	    ! for it and make a Static Address Table entry.
	    !
	    [DST$K_ENTRY]:
		BEGIN
		RSTPTR = DBG$GET_MEMORY(RST$K_EPTENTSIZ);
		RSTPTR[RST$B_KIND] = RST$K_ENTRY;
		RSTPTR[RST$L_STARTADDR] = .DSTPTR[DST$L_VALUE];
	        NEST_BREAK_STACK[.NESTING_BREAK] = .RSTPTR;
	        RSTPTR[RST$L_BREAKADDR] = .RSTPTR[RST$L_STARTADDR] + 2;
		NEWENT_FLAG = TRUE;
		STATIC_ADDRESS(.RSTPTR[RST$L_STARTADDR], 0, .RSTPTR,
					MODRSTPTR[RST$L_SAT_PTR], FALSE);
		END;


	    ! Handle the Record-Begin record.  Generate a Data Item RST Entry
	    ! for the record unless this is just a Type definition.  Then stack
	    ! the information which keeps track of the currently open record
	    ! definition (if any) and set up the same information for this new
	    ! record.
	    !
	    [DST$K_RECBEG]:
		BEGIN

    		! Set the flag saying we have to build the Type Reference
    		! Table. We always have to build this table in the presence
    		! of records.
    		!
    		BUILD_TYPE_TABLE = TRUE;


		! Generate a Data Item RST Entry if this is a data record defin-
		! ition (not just a Type definition).
		!
		IF .DSTPTR[DST$B_VFLAGS] NEQ DST$K_VFLAGS_NOVAL
		THEN
		    BEGIN
		    RSTPTR = DBG$GET_MEMORY(RST$K_DATENTSIZ);
		    RSTPTR[RST$B_KIND] = RST$K_DATA;
		    RSTPTR[RST$L_TYPEPTR] = .DSTPTR;
		    RSTPTR[RST$V_SET_TYPEPTR] = TRUE;
		    NEWENT_FLAG = TRUE;
		    IF .COMP_LST_PTR EQL 0
		    THEN
			BEGIN
			STATIC_CHECK(.DSTPTR, ADDRESS, LENGTH, STATIC_FLAG);
			IF .STATIC_FLAG
			THEN
			    BEGIN
			    IF .LENGTH NEQ 0 THEN RSTPTR[RST$V_NONZLENGTH] = TRUE;
			    STATIC_ADDRESS(.ADDRESS, .LENGTH, .RSTPTR,
					MODRSTPTR[RST$L_SAT_PTR], FALSE);
			    END;

			END

		    ELSE
			COMP_LIST_ADD_ENTRY(COMP_LST_PTR,COMP_LST_SIZE,.RSTPTR);

		    END;


		! Stack the variables which keep track of the current record
		! definition (if any).  Then set these variables up to keep
		! track of this new record definition.
		!
		IF .RSPTR GEQ MAX_NESTING
		THEN
		    SIGNAL(DBG$_DSTNESDEP, 1, .MODNAMEPTR);

		RECSTACK[.RSPTR, RS_CLPTR] = .COMP_LST_PTR;
		RECSTACK[.RSPTR, RS_CLSIZ] = .COMP_LST_SIZE;
		RECSTACK[.RSPTR, RS_RCDST] = .REC_DSTPTR;
		RECSTACK[.RSPTR, RS_VRPTR] = .VAR_REC_PTR;
		RECSTACK[.RSPTR, RS_TRSIZ] = .TYP_RST_SIZE;
		RSPTR = .RSPTR + 1;
		COMP_LST_PTR = DBG$GET_MEMORY(11);
		COMP_LST_SIZE = 10;
		REC_DSTPTR = .DSTPTR;
		VAR_REC_PTR = 0;
		TYP_RST_SIZE = RST$K_TYPENTSIZ;
		END;


	    ! Handle the Record-End record.  Here we create the Data Type RST
	    ! Entry for the record type.  We then pop the record stack to re-
	    ! store the context for any outer record definition.
	    !
	    [DST$K_RECEND]:
		BEGIN
		IF .VAR_REC_PTR NEQ 0
		THEN
		    SIGNAL(DBG$_INCDSTNES, 1, .MODNAMEPTR);


		! Build the Data Type RST Entry for the record type.
		!
		TYP_RST_SIZE = .TYP_RST_SIZE + .COMP_LST_PTR[0];
		RSTPTR = DBG$GET_MEMORY(.TYP_RST_SIZE);
		RSTPTR[RST$B_KIND] = RST$K_TYPE;
		RSTPTR[RST$B_FCODE] = RST$K_TYPE_RECORD;
		RECBEGTRLR = REC_DSTPTR[DST$B_NAME] + 1 + .REC_DSTPTR[DST$B_NAME];
		RSTPTR[RST$L_BITSIZE] = .RECBEGTRLR[DST$L_RECBEG_SIZE];
		DSTPTR_TO_SAVE = .REC_DSTPTR;
		NEWENT_FLAG = TRUE;


		! Now copy all component and variant set lists into the Type RST
		! Entry's memory block after the RST entry proper.  This is done
		! by a call on recursive routine COPY_COMP_LIST.
		!
		TYPRSTPTR = .RSTPTR;
		TYPRSTLOC = RSTPTR[RST$L_TYPCOMPCNT];
		COPY_COMP_LIST(.COMP_LST_PTR);


		! Pop the record stack so we continue the accumulation of record
		! components at the next outer level of record nesting (if any).
		!
		IF .RSPTR LEQ 0 THEN SIGNAL(DBG$_INCDSTNES, 1, .MODNAMEPTR);
		RSPTR = .RSPTR - 1;
		COMP_LST_PTR = .RECSTACK[.RSPTR, RS_CLPTR];
		COMP_LST_SIZE = .RECSTACK[.RSPTR, RS_CLSIZ];
		REC_DSTPTR = .RECSTACK[.RSPTR, RS_RCDST];
		VAR_REC_PTR = .RECSTACK[.RSPTR, RS_VRPTR];
		TYP_RST_SIZE = .RECSTACK[.RSPTR, RS_TRSIZ];
		END;


	    ! Handle the Variant-Set Begin record.  This signals the start of a
	    ! set of variants of the current record which all have the same tag
	    ! variable (though the tag variable need not be materialized).  Here
	    ! we find the tag variable and build a Variant RST Entry.  We then
	    ! set up a new component list to accumulate the individual variants
	    ! of this variant set.
	    !
	    [DST$K_VARBEG]:
		BEGIN
		IF .COMP_LST_PTR EQL 0
		THEN
		    SIGNAL(DBG$_INCDSTNES, 1, .MODNAMEPTR);


		! Determine the address of the RST entry of the variant set's
		! tag variable if present.  We do this by searching the already
		! existing record components for a symbol with the desired DST
		! pointer.
		!
		VARBEG_DSTPTR = DSTPTR[DST$B_NAME] + 1 + .DSTPTR[DST$B_NAME];
		TAGDSTPTR = .VARBEG_DSTPTR[ DST$L_VARBEG_TAG_PTR ];
		TAGRSTPTR = 0;
		IF .TAGDSTPTR NEQ 0
		THEN
		    BEGIN
		    TAGDSTPTR = DBG$RST_DST_PTR( .TAGDSTPTR + .DST$BEGIN_ADDR );			! M015
		    INCR I FROM 1 TO .COMP_LST_PTR[0] DO
			BEGIN
			RSTPTR = .COMP_LST_PTR[.I];
			IF (.RSTPTR[RST$L_DSTPTR] EQL .TAGDSTPTR) AND
			   (.RSTPTR[RST$B_KIND] EQL RST$K_DATA)
			THEN
			    BEGIN
			    TAGRSTPTR = .RSTPTR;
			    EXITLOOP;
			    END;

			END;

		    IF .TAGRSTPTR EQL 0
		    THEN
			SIGNAL(DBG$_INCDSTNES, 1, .MODNAMEPTR);

		    END;


		! Build a Variant RST Entry for this variant set.  This entry is
		! temporary in the sense that it will eventually be copied into
		! the Type RST Entry for the containing record data type.
		!
		RSTPTR = DBG$GET_MEMORY(RST$K_VARENTSIZ);
		RSTPTR[RST$L_DSTPTR] = .DSTPTR;
		RSTPTR[RST$L_VARTAGPTR] = .TAGRSTPTR;
		RSTPTR[RST$B_KIND] = RST$K_VARIANT;
		COMP_LIST_ADD_ENTRY(COMP_LST_PTR, COMP_LST_SIZE, .RSTPTR);


		! Push the current component list pointer and size on the
		! record stack and set up a new component list for the
		! variant set.
		!
		IF .RSPTR EQL MAX_NESTING
		THEN
		    SIGNAL(DBG$_DSTNESDEP, 1, .MODNAMEPTR);

		RECSTACK[.RSPTR, RS_CLPTR] = .COMP_LST_PTR;
		RECSTACK[.RSPTR, RS_CLSIZ] = .COMP_LST_SIZE;
		RECSTACK[.RSPTR, RS_VRPTR] = .VAR_REC_PTR;
		RSPTR = .RSPTR + 1;
		COMP_LST_PTR = DBG$GET_MEMORY(11);
		COMP_LST_SIZE = 10;
		VAR_REC_PTR = .RSTPTR;
		VARIANT_VALUE_FOUND = FALSE;
		END;


	    ! Handle the Variant-Set End record.  Close out the component list
	    ! of the last variant in the variant set, and then close out the
	    ! whole set.
	    !
	    [DST$K_VAREND]:
		BEGIN
		IF .VAR_REC_PTR EQL 0
		THEN
		    SIGNAL(DBG$_INCDSTNES, 1, .MODNAMEPTR);


		! Pop the record stack and put the address of the last variant's
		! component list on the variant set list.
		!
		IF .VARIANT_VALUE_FOUND
		THEN
		    BEGIN
		    TYP_RST_SIZE = .TYP_RST_SIZE + 1 + .COMP_LST_PTR[0];
		    RSTPTR = .COMP_LST_PTR;
		    RSPTR = .RSPTR - 1;
		    IF .RSPTR LEQ 0 THEN SIGNAL(DBG$_INCDSTNES, 1, .MODNAMEPTR);
		    COMP_LST_PTR = .RECSTACK[.RSPTR, RS_CLPTR];
		    COMP_LST_SIZE = .RECSTACK[.RSPTR, RS_CLSIZ];
		    COMP_LIST_ADD_ENTRY(COMP_LST_PTR, COMP_LST_SIZE, .RSTPTR);
		    END;


		! Then close out the current variant set by saving the address
		! of the variant set list in the temporary Variant RST Entry.
		! Then pop the record stack to continue accumulating record
		! components for the outer level record definition.
		!
		VARIANT_VALUE_FOUND = TRUE;
		TYP_RST_SIZE = .TYP_RST_SIZE + RST$K_VARENTSIZ + .COMP_LST_PTR[0];
		VAR_REC_PTR[RST$L_SYMCHNPTR] = .COMP_LST_PTR;
		IF .RSPTR LEQ 0 THEN SIGNAL(DBG$_INCDSTNES, 1, .MODNAMEPTR);
		RSPTR = .RSPTR - 1;
		COMP_LST_PTR = .RECSTACK[.RSPTR, RS_CLPTR];
		COMP_LST_SIZE = .RECSTACK[.RSPTR, RS_CLSIZ];
		VAR_REC_PTR = .RECSTACK[.RSPTR, RS_VRPTR];
		END;


	    ! Handle the Variant-Value record.  This record defines a new vari-
	    ! ant of the current record and the corresponding tag value.  Close
	    ! out the previous variant (if any) and set things up to accumulate
	    ! the components of this new variant.
	    !
	    [DST$K_VARVAL]:
		BEGIN
		IF .VAR_REC_PTR EQL 0 THEN SIGNAL(DBG$_INCDSTNES,1,.MODNAMEPTR);


		! Unless this is the first variant, pop the record stack and put
		! the address of the last variant's component list on the vari-
		! ant set list.
		!
		IF .VARIANT_VALUE_FOUND
		THEN
		    BEGIN
		    TYP_RST_SIZE = .TYP_RST_SIZE + 1 + .COMP_LST_PTR[0];
		    RSTPTR = .COMP_LST_PTR;
		    RSPTR = .RSPTR - 1;
		    IF .RSPTR LEQ 0 THEN SIGNAL(DBG$_INCDSTNES, 1, .MODNAMEPTR);
		    COMP_LST_PTR = .RECSTACK[.RSPTR, RS_CLPTR];
		    COMP_LST_SIZE = .RECSTACK[.RSPTR, RS_CLSIZ];
		    COMP_LIST_ADD_ENTRY(COMP_LST_PTR, COMP_LST_SIZE, .RSTPTR);
		    END;


		! Then set things up to accumulate the components of the new
		! variant definition.  Push the tag value DST pointer on the
		! current variant component list, push the record stack, and
		! set up a component list for the new variant.
		!
		VARIANT_VALUE_FOUND = TRUE;
		COMP_LIST_ADD_ENTRY(COMP_LST_PTR, COMP_LST_SIZE, .DSTPTR);
		IF .RSPTR EQL MAX_NESTING
		THEN
		    SIGNAL(DBG$_DSTNESDEP, 1, .MODNAMEPTR);

		RECSTACK[.RSPTR, RS_CLPTR] = .COMP_LST_PTR;
		RECSTACK[.RSPTR, RS_CLSIZ] = .COMP_LST_SIZE;
		RSPTR = .RSPTR + 1;
		COMP_LST_PTR = DBG$GET_MEMORY(11);
		COMP_LST_SIZE = 10;
		END;


	    ! Handle the Enumeration Type Begin record.  Set up the accumulation
	    ! of the enumeration type elements.
	    !
	    [DST$K_ENUMBEG]:
		BEGIN


    		! Set the flag saying that we have to build a Type Reference
    		! Table. (I'm not sure whether this absolutely has to be done
    		! for enumeration types. It does have to be done for records).
    		!
    		BUILD_TYPE_TABLE = TRUE;


		IF .ENUM_LST_PTR NEQ 0
		THEN
		    SIGNAL(DBG$_INCDSTNES, 1, .MODNAMEPTR);

		ENUM_DSTPTR = .DSTPTR;
		ENUM_BITSIZE = .DSTPTR[DST$B_ENUMBEG_LENG];
		ENUM_LST_PTR = DBG$GET_MEMORY(11);
		ENUM_LST_SIZE = 10;
		END;


	    ! Handle the Enumeration Type Element record.  Build a Data Item RST
	    ! Entry for the element (it constitutes a literal of the enumeration
	    ! type).  Also add the element to the type's element list.
	    !
	    [DST$K_ENUMELT]:
		BEGIN
		IF .ENUM_LST_PTR EQL 0
		THEN
		    SIGNAL(DBG$_INCDSTNES, 1, .MODNAMEPTR);

		RSTPTR = DBG$GET_MEMORY(RST$K_DATENTSIZ);
		RSTPTR[RST$B_KIND] = RST$K_DATA;
		RSTPTR[RST$L_TYPEPTR] = .ENUM_DSTPTR;
		RSTPTR[RST$V_SET_TYPEPTR] = TRUE;
		NEWENT_FLAG = TRUE;
		COMP_LIST_ADD_ENTRY(ENUM_LST_PTR, ENUM_LST_SIZE, .RSTPTR);
		END;


	    ! Handle the Enumeration Type End record.  Build the Data Type RST
	    ! Entry for the enumeration type and include the element list as
	    ! the type's "component" list.  Then clear ENUM_LST_PTR to indicate
	    ! that we are no longer accumulating enumeration type elements.
	    !
	    [DST$K_ENUMEND]:
		BEGIN
		IF .ENUM_LST_PTR EQL 0
		THEN
		    SIGNAL(DBG$_INCDSTNES, 1, .MODNAMEPTR);

		RSTPTR = DBG$GET_MEMORY(RST$K_TYPENTSIZ + .ENUM_LST_PTR[0]);
		RSTPTR[RST$B_KIND] = RST$K_TYPE;
		RSTPTR[RST$B_FCODE] = RST$K_TYPE_ENUM;
		RSTPTR[RST$L_BITSIZE] = .ENUM_BITSIZE;
		DSTPTR_TO_SAVE = .ENUM_DSTPTR;
		NEWENT_FLAG = TRUE;
		RSTPTR[RST$L_TYPCOMPCNT] = .ENUM_LST_PTR[0];
		ENUMELT = RSTPTR[RST$A_TYPCOMPLST];
		INCR I FROM 1 TO .ENUM_LST_PTR[0] DO
		    ENUMELT[.I - 1] = .ENUM_LST_PTR[.I];

		DBG$REL_MEMORY(.ENUM_LST_PTR);
		ENUM_LST_PTR = 0;
		END;


	    ! Handle all Data Symbol records.  This includes Boolean records and
	    ! Separate Type Spec records.  Create a Data Item RST Entry for the
	    ! data symbol and make a Static Address Table entry if the data item
	    ! is static.
	    !
	    [DSC$K_DTYPE_LOWEST TO DSC$K_DTYPE_HIGHEST,
	     DST$K_BOOL,
	     DST$K_SEPTYP]:
		BEGIN


		! Build the Data Item RST Entry.
		!
		RSTPTR = DBG$GET_MEMORY(RST$K_DATENTSIZ);
		RSTPTR[RST$B_KIND] = RST$K_DATA;
		RSTPTR[RST$L_TYPEPTR] = 0;
		NEWENT_FLAG = TRUE;


		! If this is a ZEM data DST, and the name is "TRANSFER$ADDRESS",
		! and it contains a static address in the VALUE field, then
		! this is the special DST put out by FORTRAN to tell us where
		! the transfer address is.
		!
		IF (.DSTPTR[DST$B_TYPE] EQL DSC$K_DTYPE_ZEM) AND
		   (.DSTPTR[DST$B_VFLAGS] EQL DST$K_VALKIND_ADDR) AND
		   CH$EQL(17, DSTPTR[DST$B_NAME], 
			  17, UPLIT(%ASCIC 'TRANSFER$ADDRESS'))
		THEN
		    DBG$GL_TRANSFER_ADDRESS = .DSTPTR[DST$L_VALUE];
		

		! If this is a DST$K_SEPTYP record, see if the separate Type
		! Spec record ultimately points to a record or enumeration type
		! definition.  If so, set up the RST$L_TYPEPTR field in the RST
		! entry.  We also set RST$V_MARKBIT if this is an array whose
		! cell type is a record type.
		!
		IF .DSTPTR[DST$B_TYPE] EQL DST$K_SEPTYP
		THEN
		    BEGIN
		    GET_TYPEPTR(.DSTPTR, .MODNAMEPTR, TYPEPTR, ARRAY_FLAG);
		    RSTPTR[RST$L_TYPEPTR] = .TYPEPTR;
    		    IF .TYPEPTR NEQ 0
    		    THEN
    			BEGIN
		        RSTPTR[RST$V_SET_TYPEPTR] = TRUE;
    			BUILD_TYPE_TABLE = TRUE;
    			END;
    			
		    RSTPTR[RST$V_MARKBIT] = .ARRAY_FLAG;
		    END;


		! If we are not nested in a record definition and if the data
		! item is static, make a Static Address Table entry.
		!
		IF .COMP_LST_PTR EQL 0
		THEN
		    BEGIN
		    STATIC_CHECK(.DSTPTR, ADDRESS, LENGTH, STATIC_FLAG);
		    IF .STATIC_FLAG
		    THEN
			BEGIN
			IF .LENGTH NEQ 0 THEN RSTPTR[RST$V_NONZLENGTH] = TRUE;
			STATIC_ADDRESS(.ADDRESS, .LENGTH, .RSTPTR,
					MODRSTPTR[RST$L_SAT_PTR], FALSE);
			END;

		    END


		! If this is a record component, add the data item to the cur-
		! rent record's component list.  We do not make a SAT entry for
		! a record component (though we may have for the whole record).
		!
		ELSE
		    COMP_LIST_ADD_ENTRY(COMP_LST_PTR, COMP_LST_SIZE, .RSTPTR);

		END;


	    ! Handle the BLISS special cases record.  Here we create a Data Item
	    ! RST Entry for the BLISS data item.  We also make a Static Address
	    ! Table entry if appropriate.
	    !
	    [DST$K_BLI]:
		BEGIN
		RSTPTR = DBG$GET_MEMORY(RST$K_DATENTSIZ);
		RSTPTR[RST$B_KIND] = RST$K_DATA;
		RSTPTR[RST$L_TYPEPTR] = 0;
		NEWENT_FLAG = TRUE;
		STATIC_CHECK(.DSTPTR, ADDRESS, LENGTH, STATIC_FLAG);
		IF .STATIC_FLAG
		THEN
		    BEGIN
		    IF .LENGTH NEQ 0 THEN RSTPTR[RST$V_NONZLENGTH] = TRUE;
		    STATIC_ADDRESS(.ADDRESS, .LENGTH, .RSTPTR,
					MODRSTPTR[RST$L_SAT_PTR], FALSE);
		    END;

		END;


	    ! Handle the BLISS field record.  Just build a Data Item RST Entry.
	    !
	    [DST$K_BLIFLD]:
		BEGIN
		RSTPTR = DBG$GET_MEMORY(RST$K_DATENTSIZ);
		RSTPTR[RST$B_KIND] = RST$K_DATA;
		RSTPTR[RST$L_TYPEPTR] = 0;
		NEWENT_FLAG = TRUE;
		END;


	    ! Handle the COBOL special cases.  Build a Data Item RST Entry.
	    !
	    [DST$K_COB_HACK]:
		BEGIN
		RSTPTR = DBG$GET_MEMORY(RST$K_DATENTSIZ);
		RSTPTR[RST$B_KIND] = RST$K_DATA;
		RSTPTR[RST$L_TYPEPTR] = 0;
		NEWENT_FLAG = TRUE;
		END;


	    ! Handle the COBOL Global Attribute record.  Here we just set the
	    ! COBOL "global" flag.  This flag will then be set in the RST entry
	    ! for the next symbol to be defined in the DST.  This attribute is
	    ! needed to correctly emulate COBOL's scope rules.
	    !
	    [DST$K_COBOLGBL]:
		COBOLGBL_FLAG = TRUE;


	    ! Handle the Overloaded Symbol DST record.
	    !
	    [DST$K_OVERLOAD]:
		BEGIN
		RSTPTR = DBG$GET_MEMORY(RST$K_OLENTSIZ);
		RSTPTR[RST$B_KIND] = RST$K_OVERLOAD;
		NEWENT_FLAG = TRUE;
		END;


            ! Handle type specs
            !
            [DST$K_TYPSPEC]:
                BEGIN

                ! Only create an RST entry and hash it in if this type spec
                ! has a name.
                !
                IF .DSTPTR[DST$B_TYPSPEC_NAME] NEQ 0
                THEN
                    BEGIN

                    ! Get a pointer to the type spec.
                    !
                    TSPTR = .DSTPTR[DST$B_TYPSPEC_NAME] + DSTPTR[DST$B_TYPSPEC_NAME] + 1;

                    ! Get memory and fill in the fields of the RST type entry
                    !
                    RSTPTR = DBG$GET_MEMORY(RST$K_TYPENTSIZ);
                    RSTPTR[RST$L_DSTPTR] = .DSTPTR;
                    RSTPTR[RST$L_UPSCOPEPTR] = .RST$START_ADDR;
                    RSTPTR[RST$B_KIND] = RST$K_TYPE;
                    RSTPTR[RST$B_FCODE] = DBG$TRANS_TYPE_CODE(.TSPTR[DST$B_TS_KIND]);

    		    ! Note - the code to fill in BITSIZE is commented out.
    		    ! This is because the GET_BITSIZE_FROM_TYPESPEC routine
    		    ! may, in certain cases, call DBG$STA_VALSPEC to evaluate
    		    ! a descriptor to determine the size. If the valspec refers
    		    ! to any registers, however, then VALSPEC will signal an
    		    ! error, and we cannot allow error signals in this 
    		    ! initialization code. So we leave BITSIZE zero here.
    		    ! (This may affect the "'SIZE" operator in ADA).
    		    !
                    ! RSTPTR[RST$L_BITSIZE] = DBG$GET_BITSIZE_FROM_TYPESPEC(.TSPTR);

                    NEWENT_FLAG = TRUE;
                    END;

                END;


	    ! Handle all other cases by ignoring the DST record.
	    !
	    [INRANGE]:
		0;

	    TES;			! End of CASE over the DST record type


	! If a new RST entry is being created from this DST record, fill in the
	! remaining fields, link it into the module's symbol chain, and insert
	! it in the RST Hash Table.
	!
	IF .NEWENT_FLAG
	THEN
	    BEGIN
	    RSTPTR[RST$L_DSTPTR] = .DSTPTR_TO_SAVE;
	    RSTPTR[RST$L_UPSCOPEPTR] = .NEST_STACK[.NESTING];
	    IF .COBOLGBL_FLAG THEN RSTPTR[RST$V_COBOLGBL] = TRUE;
	    COBOLGBL_FLAG = FALSE;
	    SYMCHNPTR[RST$L_SYMCHNPTR] = .RSTPTR;
	    SYMCHNPTR = .RSTPTR;
	    !IF .RSTPTR[RST$B_KIND] EQL RST$K_TYPE
	    !THEN
	    !	BEGIN
	    !	RSTPTR[RST$L_HASH_FLINK] = .RSTPTR;
	    !	RSTPTR[RST$L_HASH_BLINK] = .RSTPTR;
	    !	END
            !
	    !ELSE
	    DBG$HASH_INSERT(.RSTPTR);

	    END;


	! If this RST entry defines a new nesting level (either lexical nesting
	! or data record nesting), we push a new entry on NEST_STACK.
	!
	IF .NEST_FLAG
	THEN
	    BEGIN
	    IF .NESTING GEQ MAX_NESTING - 1
	    THEN
		SIGNAL(DBG$_DSTNESDEP, 1, .MODNAMEPTR);

	    NESTING = .NESTING + 1;
	    NEST_STACK[.NESTING] = .RSTPTR;
	    END;


	! If this DST record terminates the current nesting level, pop an entry
	! off the nesting stack.
	!
	IF .UNNEST_FLAG
	THEN
	    BEGIN
	    IF .NESTING LEQ 0 THEN SIGNAL(DBG$_INCDSTNES, 1, .MODNAMEPTR);
	    NESTING = .NESTING - 1;
	    END;


	! Advance the DST pointer to the next sequential DST record and loop.
	!
!	DSTPTR = DSTPTR[DST$A_NEXT] + .DSTPTR[DST$B_LENGTH];				! D015
	DSTPTR = .NEXT_DSTPTR;								

	END;				! End of WHILE loop over module's DST


    ! If there were any PC-Correlation Table DST records for this module, copy
    ! the table of pointers to those DST records into a separate memory block
    ! and make the RST$L_MODPCTBL field point to that block.  The first long-
    ! word of the block gives the number of DST pointers in the block.  Then
    ! release the temporary memory block we used for those pointers.
    !
    IF .NUM_PC_TBLS GTR 0
    THEN
	BEGIN
	MODRSTPTR[RST$L_PCTBL_BASE] = .PCTBL_BASE;
	MOD_PC_TBL = DBG$GET_MEMORY(.NUM_PC_TBLS + 1);
	MODRSTPTR[RST$L_MODPCTBL] = .MOD_PC_TBL;
	MOD_PC_TBL[0] = .NUM_PC_TBLS;
	INCR I FROM 1 TO .NUM_PC_TBLS DO
	    MOD_PC_TBL[.I] = .PC_CORR_TBL[.I - 1];

	END;

    DBG$REL_MEMORY(.PC_CORR_TBL);


    ! If there were any Source Line Correlation DST Records for this module,
    ! copy the table of pointers to those DST records into a separate memory
    ! block and make the RST$L_MODPCTBL field point to that block.  The first
    ! longword of the block gives the number of DST pointers in the block.
    ! Then release the temporary memory block we used for those pointers.
    !
    IF .NUM_SRC_DSTS NEQ 0
    THEN
	BEGIN
	MOD_SRC_TBL = DBG$GET_MEMORY(.NUM_SRC_DSTS + 1);
	MODRSTPTR[RST$L_MODSRCTBL] = .MOD_SRC_TBL;
	MOD_SRC_TBL[0] = .NUM_SRC_DSTS;
	INCR I FROM 1 TO .NUM_SRC_DSTS DO
	    MOD_SRC_TBL[.I] = .SRC_CORR_TBL[.I - 1];

	END;

    DBG$REL_MEMORY(.SRC_CORR_TBL);


    ! We must walk the RST to fix any pointers to continued DST records.  We do
    ! it only when there is a continued record at all in the DST.  We can't do
    ! it as we build the RST because there might be pointers in the DST to DST
    ! records that have not been moved at the time the RST entry is built.
    !
    IF .CONTINUATION_DST_SEEN
    THEN
	BEGIN


	! Loop on the RST
	!
        RSTPTR = .MODRSTPTR[RST$L_SYMCHNPTR];
        WHILE .RSTPTR NEQ 0 DO
	    BEGIN


	    ! Transform the DST pointer
	    !
	    RSTPTR[RST$L_DSTPTR] = DBG$RST_DST_PTR(.RSTPTR[RST$L_DSTPTR]);


	    ! RST$L_TYPEPTR may be a DST pointer for data
	    !
	    IF RSTPTR[RST$B_KIND] EQL RST$K_DATA
	    THEN
		RSTPTR[RST$L_TYPEPTR] = DBG$RST_DST_PTR(.RSTPTR[RST$L_TYPEPTR]);


	    ! RST$L_DST_TYPE_REC_PTR
	    !
	    IF RSTPTR[RST$B_KIND] EQL RST$K_TYPE
	    THEN
		RSTPTR[RST$L_DST_TYP_REC_PTR] =
				DBG$RST_DST_PTR(.RSTPTR[RST$L_DST_TYP_REC_PTR]);


	    ! Variant RSTs have DST pointers buried in the "Variant Entry"
	    !
	    IF .RSTPTR[RST$B_KIND] EQL RST$K_TYPE
	    THEN
		BEGIN


		! Walk the type component list
		!
		TYPCOMPLST = RSTPTR[RST$A_TYPCOMPLST];
		INCR J FROM 0 TO .RSTPTR[RST$L_TYPCOMPCNT] - 1 DO
		    BEGIN


		    ! If we find a variant
		    !
		    RST_PTR = .TYPCOMPLST[.J];
		    IF .RST_PTR[RST$B_KIND] EQL RST$K_VARIANT
		    THEN
			BEGIN


			! Walk the variant list fixing the DST pointer
			!
			VARSETTBL = RST_PTR[RST$A_VARSETTBL];
			INCR I FROM 0 TO .RST_PTR[RST$L_VARSETCNT] - 1 DO
			    BEGIN
			    VARIANT_ENTRY = .VARSETTBL[.I];
			    VARIANT_ENTRY[RST$L_VAR_DSTPTR] = DBG$RST_DST_PTR(
					.VARIANT_ENTRY[RST$L_VAR_DSTPTR]);
			    END;

			END;

		    END;

		END;


	    ! Next RST entry
	    !
	    RSTPTR = .RSTPTR[RST$L_SYMCHNPTR];

	    END;

	END;


    ! Go through the module's symbol chain to construct a DST address to RST
    ! address translate table for Data Type RST Entries which refer to records
    ! or enumeration types.
    ! Don't bother to do this unless the BUILD_TYPE_TABLE flag
    ! is set.
    !
    IF .BUILD_TYPE_TABLE
    THEN
    	BEGIN
        
    	TYPE_DST_LST = DBG$GET_MEMORY(11);
        TYPE_DST_LEN = 10;
        TYPE_RST_LST = DBG$GET_MEMORY(11);
        TYPE_RST_LEN = 10;
        RSTPTR = .MODRSTPTR[RST$L_SYMCHNPTR];
        WHILE .RSTPTR NEQ 0 DO
	    BEGIN
	    IF .RSTPTR[RST$B_KIND] EQL RST$K_TYPE
	    THEN
	        BEGIN
	        COMP_LIST_ADD_ENTRY(TYPE_DST_LST, TYPE_DST_LEN,
					.RSTPTR[RST$L_DSTPTR]);
	        COMP_LIST_ADD_ENTRY(TYPE_RST_LST, TYPE_RST_LEN, .RSTPTR);
	        END;

	    RSTPTR = .RSTPTR[RST$L_SYMCHNPTR];
	    END;


        ! Now use this translate table to fill in the RST$L_TYPEPTR field of Data
        ! Item and Type Component RST Entries which reference the Record-Begin or
        ! Enumeration-Type-Begin DST record of their type.
        !
        RSTPTR = .MODRSTPTR[RST$L_SYMCHNPTR];
        WHILE .RSTPTR NEQ 0 DO
	    BEGIN
	    IF .RSTPTR[RST$V_SET_TYPEPTR]
	    THEN
	        BEGIN
	        INCR I FROM 1 TO .TYPE_DST_LST[0] DO
	 	    BEGIN
		    IF .TYPE_DST_LST[.I] EQL .RSTPTR[RST$L_TYPEPTR]
		    THEN
		        BEGIN
		        RSTPTR[RST$L_TYPEPTR] = .TYPE_RST_LST[.I];
		        RSTPTR[RST$V_SET_TYPEPTR] = FALSE;
		        EXITLOOP;
		        END;

		    END;

	        IF .RSTPTR[RST$V_SET_TYPEPTR]
	        THEN
		    SIGNAL(DBG$_INCDSTNES, 1, .MODNAMEPTR);

	        END;

	    RSTPTR = .RSTPTR[RST$L_SYMCHNPTR];
	    END;

        ! Go through the symbol chain to find all Data RST Entries and all Type
        ! Component RST Entries which point to Type RST Entries for Record data
        ! types.  For each such RST entry, increment the RST$W_TYPREFCNT field
        ! in the corresponding Type RST Entry.  At the end of the loop, we will
        ! thus know how many RST entries reference each Record Type RST Entry.
        ! This is the information we need to allocate space for the Type Refer-
        ! ence Table for each Record Type RST Entry.
        !
        RSTPTR = .MODRSTPTR[RST$L_SYMCHNPTR];
        WHILE .RSTPTR NEQ 0 DO
	    BEGIN
	    IF (.RSTPTR[RST$B_KIND] EQL RST$K_DATA) OR
	       (.RSTPTR[RST$B_KIND] EQL RST$K_TYPCOMP)
	    THEN
	        BEGIN
	        IF .RSTPTR[RST$L_TYPEPTR] NEQ 0
	        THEN
		    BEGIN
		    TYPEPTR = .RSTPTR[RST$L_TYPEPTR];
		    IF .TYPEPTR[RST$B_KIND] NEQ RST$K_TYPE
		    THEN
		        $DBG_ERROR('RSTCNTRL\RST_BUILD 20');

		    IF .TYPEPTR[RST$B_FCODE] EQL RST$K_TYPE_RECORD
		    THEN
		        TYPEPTR[RST$W_TYPREFCNT] = .TYPEPTR[RST$W_TYPREFCNT] + 1;

		    END;

	        END;

	    RSTPTR = .RSTPTR[RST$L_SYMCHNPTR];
	    END;


        ! Now loop through all Type RST Entries, and allocate a "Type Reference
        ! Table" for each such entry with a non-zero reference count.  The type
        ! reference table for each entry will be used to store pointers to all
        ! RST entries which reference this Type RST Entry (i.e., to all symbols
        ! of this data type).
        !
        INCR I FROM 1 TO .TYPE_RST_LST[0] DO
	    BEGIN
	    TYPEPTR = .TYPE_RST_LST[.I];
	    IF .TYPEPTR[RST$W_TYPREFCNT] NEQ 0
	    THEN
	        BEGIN
	        TYPEPTR[RST$L_TYPREFTBL] = DBG$GET_MEMORY(.TYPEPTR[RST$W_TYPREFCNT]);
	        TYPEPTR[RST$W_TYPREFCNT] = 0;
	        END;

	    END;


        ! To complete the "Type Reference Tables", go through the module's symbol
        ! chain once more.  For each Data or Type Component RST Entry with a type
        ! pointer to a Record Type RST Entry, add that entry's RST pointer to the
        ! Type RST Entry's Type Reference Table.  This data structure is later
        ! used by DBG$STA_GETSYMBOL to find all records which could have a given
        ! symbol as a record component.
        !
        RSTPTR = .MODRSTPTR[RST$L_SYMCHNPTR];
        WHILE .RSTPTR NEQ 0 DO
	    BEGIN
	    IF (.RSTPTR[RST$B_KIND] EQL RST$K_DATA) OR
	       (.RSTPTR[RST$B_KIND] EQL RST$K_TYPCOMP)
	    THEN
	        BEGIN
	        IF .RSTPTR[RST$L_TYPEPTR] NEQ 0
	        THEN
		    BEGIN


		    ! This RST entry has a type pointer.  Add a pointer to the
		    ! corresponding Type RST Entry's Type Reference Table which
		    ! points back to this current RST entry.
		    !
		    TYPEPTR = .RSTPTR[RST$L_TYPEPTR];
		    IF .TYPEPTR[RST$B_FCODE] EQL RST$K_TYPE_RECORD
		    THEN
		        BEGIN
		        TYPREFTBL = .TYPEPTR[RST$L_TYPREFTBL];
		        TYPREFTBL[.TYPEPTR[RST$W_TYPREFCNT]] = .RSTPTR;
		        TYPEPTR[RST$W_TYPREFCNT] = .TYPEPTR[RST$W_TYPREFCNT] + 1;
		        END;


		    ! If RST$V_MARKBIT is set, this RST entry is for an array of
		    ! records and RST$L_TYPEPTR points to the cell type of the
		    ! array.  This pointer is no longer needed and in fact should
		    ! no longer be there.  We thus clear it and the mark bit.
		    !
		    IF .RSTPTR[RST$V_MARKBIT]
		    THEN
		        BEGIN
		        RSTPTR[RST$L_TYPEPTR] = 0;
		        RSTPTR[RST$V_MARKBIT] = FALSE;
		        END;

		    END;

	        END;

	    RSTPTR = .RSTPTR[RST$L_SYMCHNPTR];
	    END;


        ! Now release the DST and RST address tables for types to the memory pool.
        !
        DBG$REL_MEMORY(.TYPE_DST_LST);
        DBG$REL_MEMORY(.TYPE_RST_LST);
    	END;


    ! We are then all done, and can return to the caller.
    !
    MODRSTPTR[RST$V_MOD_IN_RST] = TRUE;
    RETURN;
    END;

GLOBAL ROUTINE DBG$RST_BLDSCOPE_LIST(PNVEC, ERRINDEX, 
    				     ORIGIN_FLAG, MODULE_FLAG): =
!
! FUNCTION
!	This routine makes a new set of scopes available to the symbol table
!	access routines.  It is thus called in the course of processing the 
!	set scope list.  It accepts as input a vector of pointers to 
!	Pathname Descriptors for the scopes specified on the SET SCOPE command,
!	or SET SYMBOL/qulifiers namespec IN scopespec command. 	It builds a 
!	linked list of the corresponding Scope Entries, and makes a scope 
!	pointer point to this list.
!
!	If an error in a scope pathname is detected, the index of that pathname
!	is returned to ERRINDEX.  The actual return is accomplished by signal-
!	ling an error which is intercepted by an error handler.  That handler
!	releases any partially built new scope list back to the free memory pool
!	and then unwinds to return control to the caller of DBG$RST_SETSCOPE,
!	or DBG$STA_SHOWSYMBOL.
!
! INPUTS
!	PNVEC	- A vector of pointers to Pathname Descriptors for the scopes
!		  specified on the SET SCOPE command or SHOW SYMBOL command.
!		  PNVEC[0] gives the number of such pointers and PNVEC[1] 
!		  through PNVEC[.PNVEC[0]] contain the pointers to the 
!		  Pathname Descriptors.  The CANCEL SCOPE command is handled 
!		  by making PNVEC[0] zero.
!
!	ERRINDEX - The address of a longword location to receive an "error
!		  index"; see description below.
!
!	ORIGIN_FLAG - A flag set to TRUE if this routine is called from
!		    DBG$RST_SETSCOPE. This prevents us from setting the
!		    module as a side effect of the command.
!	MODULE_FLAG - TRUE if we were called from SET SCOPE/MODULE
!
! OUTPUTS
!	ERRINDEX - If some pathname is found to be invalid, the PNVEC index of
!		  that pathname is returned to ERRINDEX.  The calling routine
!		  can then use ERRINDEX to produce an error message.  If all
!		  scope pathnames are correct, zero is returned to ERRINDEX.
!
!	NEW_SCOPE_LIST - Return value from this routine which is the pointer
!			point to the newly build scope list.
!

    BEGIN

    MAP
	PNVEC: REF VECTOR[,LONG],	! Pointer to vector of Pathname Descrip-
					!      tor pointers
	ERRINDEX: REF VECTOR[1];	! Pointer to error index longword

    LOCAL
	KIND,				! The Kind of the scope's RST entry
	MODPTR: REF RST$ENTRY,		! Pointer to Module RST Entry for module
					!      containing the present scope
	NEW_SCOPE_LIST: VOLATILE,	! Pointer to new scope list being built
	PATHNAME: REF PTH$PATHNAME,	! Pointer to current Pathname Descriptor
	PATHVEC: REF VECTOR[,LONG],	! Pointer to current pathname vector
	PATH_STRING,			! Pointer to scope name as counted ASCII
	PNAME: REF VECTOR[,BYTE],	! Pointer to first name in the Pathname
					!      Descriptor (as Counted ASCII)
	PREVSCOPE: REF SCOPE$ENTRY,	! Pointer to the scope entry before the
					!      present scope entry
	RSTPTR: REF RST$ENTRY,		! Pointer to current scope's RST entry
	SCOPE: REF SCOPE$ENTRY,		! Pointer to the present scope entry
	STATUS;				! Status code returned by other routines

    ENABLE
	BLDSCOPE_ERROR_HANDLER(NEW_SCOPE_LIST);	! Declare an error handler



    ! Make NEW_SCOPE_LIST point to the list of new scopes.
    !
    PREVSCOPE = NEW_SCOPE_LIST;
    PREVSCOPE[SCOPE$L_FLINK] = 0;


    ! If PNVEC is empty (as for CANCEL SCOPE), we build a scope list entry for
    ! numbered scope "0", i.e. for the scope containing the current PC.
    !
    IF .PNVEC[0] EQL 0
    THEN
	BEGIN
	SCOPE = DBG$GET_MEMORY(SCOPE$K_ENTSIZE);
	SCOPE[SCOPE$L_FLINK] = 0;
	SCOPE[SCOPE$L_STATE] = SCOPE$K_NUMBERED;
	SCOPE[SCOPE$L_RSTPTR] = 0;
	SCOPE[SCOPE$L_MODPTR] = 0;
	PREVSCOPE[SCOPE$L_FLINK] = .SCOPE;
	PREVSCOPE = .SCOPE;
	END;


    ! Loop through the PNVEC vector and build a new scope entry for each element
    ! in that vector.
    !
    INCR I FROM 1 TO .PNVEC[0] DO
	BEGIN
	ERRINDEX[0] = .I;


	! Set up pointers to the Pathname Descriptor, the pathname vector in
	! that descriptor, to the first name in the pathname vector, and to the
	! whole pathname string as Counted ASCII.
	!
	PATHNAME = .PNVEC[.I];
	PATHVEC = PATHNAME[PTH$A_PATHVECTOR];
	PNAME = .PATHVEC[0];
	DBG$NPATHDESC_TO_CS(.PATHNAME, PATH_STRING);


	! Make sure there is no data qualification in the pathname.
	!
	IF .PATHNAME[PTH$B_TOTCNT] NEQ .PATHNAME[PTH$B_PATHCNT]
	THEN
	    SIGNAL(DBG$_BADSCOPE, 1, .PATH_STRING);


    	! If SET SCOPE/MODULE was specified, we process it here.
    	!
    	IF .MODULE_FLAG
    	THEN
    	    BEGIN

    	    ! Make sure there is exactly one name in the scope.
    	    !
    	    IF .PATHNAME[PTH$B_PATHCNT] NEQ 1
    	    THEN
    		SIGNAL(DBG$_MODUSCOPE, 1, .PATH_STRING);
    	    IF .PNAME[0] EQL 0
    	    THEN
    		SIGNAL(DBG$_MODUSCOPE, 1, .PATH_STRING);


    	    ! Find the module RST.
    	    !
	    RSTPTR = GET_MOD_RST(PNAME[1], .PNAME[0]);

		
	    ! If the name is not a module, signal an error.
	    !
	    IF .RSTPTR EQL 0 THEN SIGNAL(DBG$_NOSUCHMODU, 1, .PATH_STRING);


	    ! If the module is not set, try to set it.  
	    !
	    IF NOT .RSTPTR[RST$V_MODSET] 
	    THEN
		IF NOT DBG$RST_SETMOD(PNAME[1], .PNAME[0], FALSE)
		THEN
		    $DBG_ERROR('RSTCNTRL\RST_BLDSCOPE_LIST');


	    ! We have now found the scope in the RST.  Create a Normal scope
	    ! entry for it.
	    !
	    MODPTR = .RSTPTR;
	    WHILE .MODPTR[RST$B_KIND] NEQ RST$K_MODULE DO
		MODPTR = .MODPTR[RST$L_UPSCOPEPTR];

	    SCOPE = DBG$GET_MEMORY(SCOPE$K_ENTSIZE);
	    SCOPE[SCOPE$L_FLINK] = 0;
	    SCOPE[SCOPE$L_STATE] = SCOPE$K_NORMAL;
	    SCOPE[SCOPE$L_RSTPTR] = .RSTPTR;
	    SCOPE[SCOPE$L_MODPTR] = .MODPTR;
    	    END


	! If the first name in the pathname is null, we either have a numbered
	! scope or the global scope.  Handle these two cases.
	!
	ELSE IF .PNAME[0] EQL 0
	THEN
	    BEGIN
	    IF .PATHNAME[PTH$B_TOTCNT] NEQ 1
	    THEN
		SIGNAL(DBG$_BADSCOPE, 1, .PATH_STRING);


	    ! If this is the Global scope (i.e., "\"), build a Global Scope
	    ! Entry for inclusion on the new scope list.
	    !
	    IF .PATHNAME[PTH$B_LOCINVOC] EQL 0
	    THEN
		BEGIN
		SCOPE = DBG$GET_MEMORY(SCOPE$K_ENTSIZE);
		SCOPE[SCOPE$L_FLINK] = 0;
		SCOPE[SCOPE$L_STATE] = SCOPE$K_GLOBAL;
		SCOPE[SCOPE$L_RSTPTR] = 0;
		SCOPE[SCOPE$L_MODPTR] = 0;
		END


	    ! If this is a Numbered scope (i.e., "0"), build a Numbered Scope
	    ! Entry for inclusion on the new scope list.
	    !
	    ELSE IF .PATHNAME[PTH$B_LOCINVOC] EQL 1
	    THEN
		BEGIN
		SCOPE = DBG$GET_MEMORY(SCOPE$K_ENTSIZE);
		SCOPE[SCOPE$L_FLINK] = 0;
		SCOPE[SCOPE$L_STATE] = SCOPE$K_NUMBERED;
		SCOPE[SCOPE$L_RSTPTR] = 0;
		SCOPE[SCOPE$L_MODPTR] = .PATHNAME[PTH$L_INVOCNUM];
		END


	    ! Anything else with a null first name is an error.
	    !
	    ELSE
		SIGNAL(DBG$_BADSCOPE, 1, .PATH_STRING);

	    END


	! This seems to be an ordinary pathname.  Look it up in the RST.  If it
	! is not there, we see if it names a new module; if so, we SET that mod-
	! ule and look up the symbol in that module.
	!
	ELSE
	    BEGIN


	    ! Look up the pathname in the currently SET scopes and modules.  We
	    ! have a loop here since we may have to repeat the process if the
	    ! new scope is in a module which is not yet SET.
	    !
	    MODPTR = 0;
	    WHILE TRUE DO
		BEGIN


		! Look up the symbol in the current scopes.  Then see what KIND
		! of symbol we got back.  We do not accept global (GST) symbols.
		!
		RST$SET_SCOPE = TRUE;
		DBG$STA_GETSYMBOL(.PATHNAME, RSTPTR, KIND, 0, 0, 0, 0);
		IF .RSTPTR NEQ 0
		THEN
		    IF .RSTPTR[RST$V_GLOBAL] THEN KIND = RST$K_INVALID;

		CASE .KIND FROM RST$K_KIND_MINIMUM TO RST$K_KIND_MAXIMUM OF
		    SET


		    ! If the symbol is not unique, return with an error.  If
		    ! this is the second time through, cancel the module we SET
		    ! the last time through; then signal not unique.
		    !
		    [RST$K_NOTUNIQUE,
		     RST$K_OVERLOAD]:
			BEGIN
			IF .MODPTR NEQ 0
			THEN
			    STATUS = DBG$RST_CANMOD(PNAME[1], .PNAME[0]);

			IF .KIND EQL RST$K_NOTUNIQUE
			THEN
 		            SIGNAL(DBG$_NOUNIQUE, 1, .PATH_STRING)

			ELSE
 		            SIGNAL(DBG$_NOTUNQOVR, 1, .PATH_STRING);

			END;


		    ! If the symbol is a lexical entity, it is a valid scope.
		    ! Clear MODPTR to indicate this.
		    !
		    [RST$K_ROUTINE, RST$K_BLOCK]:
			MODPTR = 0;


		    ! If the symbol is a Line Number, the actual scope is the
		    ! containing lexical entity.  Change RSTPTR accordingly and
		    ! set MODPTR to zero to indicate we have a good scope.
		    !
		    [RST$K_LINE]:
			BEGIN
			RSTPTR = .RSTPTR[RST$L_UPSCOPEPTR];
			KIND = .RSTPTR[RST$B_KIND];
			MODPTR = 0;
			END;


		    ! If the symbol is anything else, this is not a valid scope.
		    ! We thus try to interpret the first name in the pathname as
		    ! a module name.  If this succeeds, we SET that module and
		    ! loop to look up the scope again.
		    !
		    [INRANGE]:
			BEGIN


			! See if this is the second time around (i.e., 
    			! we tried setting the module last time around).
			!
			IF .MODPTR NEQ 0
			THEN
			    BEGIN

    			    ! If there was only one name in the pathname then 
    			    ! what has happened is that we set the module
    			    ! and looped around to see if we found a scope
    			    ! within the module that we should use. We did
    			    ! not, so we use the module as the scope.
    			    !
    			    IF .PATHNAME[PTH$B_TOTCNT] EQL 1
    			    THEN
    				BEGIN
    				RSTPTR = .MODPTR;
    				EXITLOOP;
    				END;

    			    ! Otherwise, cancel the module and return error.
    			    !
			    STATUS = DBG$RST_CANMOD(PNAME[1], .PNAME[0]);
			    SIGNAL(DBG$_BADSCOPE, 1, .PATH_STRING);
			    END;


			! First time around.  Try to SET the module given by the
			! first name in the Pathname Descriptor.  
			!
			RSTPTR = GET_MOD_RST(PNAME[1], .PNAME[0]);

		
			! If the first name is not a module, signal an error.
			!
			IF .RSTPTR EQL 0 THEN SIGNAL(DBG$_BADSCOPE, 1, .PATH_STRING);


			! If the module is already set, and the pathname is more
			! than a single name, then there is no use going on with
			! the search.  Signal an error.
			!
			IF .RSTPTR[RST$V_MODSET] AND
			   (.PATHNAME[PTH$B_TOTCNT] NEQ 1)
			THEN
			    SIGNAL(DBG$_BADSCOPE, 1, .PATH_STRING);


			! If the module is not set, try to set it.  Only if
			! we are called from DBG$RST_SETSCOPE.
			!
			IF NOT .RSTPTR[RST$V_MODSET] 
			THEN
			    BEGIN    		
			    IF NOT .ORIGIN_FLAG
			    THEN
				SIGNAL(DBG$_BADSCOPE, 1, .PATH_STRING);
			    IF NOT DBG$RST_SETMOD(PNAME[1], .PNAME[0], FALSE)
			    THEN
				$DBG_ERROR('RSTCNTRL\RST_BLDSCOPE_LIST');
			    END;


    			! Set MODPTR to point to the module we have just
    			! set and loop back to try looking up the name
    			! in this module.
    			!
    			MODPTR = .RSTPTR;
			END;

		    TES;


		! If MODPTR is non-zero, we have a new module to try the look-up
		! in, so we loop.  Otherwise, we exit this WHILE loop.
		!
		IF .MODPTR EQL 0 THEN EXITLOOP;
		END;


	    ! We have now found the scope in the RST.  Create a Normal scope
	    ! entry for it.
	    !
	    MODPTR = .RSTPTR;
	    WHILE .MODPTR[RST$B_KIND] NEQ RST$K_MODULE DO
		MODPTR = .MODPTR[RST$L_UPSCOPEPTR];

	    SCOPE = DBG$GET_MEMORY(SCOPE$K_ENTSIZE);
	    SCOPE[SCOPE$L_FLINK] = 0;
	    SCOPE[SCOPE$L_STATE] = SCOPE$K_NORMAL;
	    SCOPE[SCOPE$L_RSTPTR] = .RSTPTR;
	    SCOPE[SCOPE$L_MODPTR] = .MODPTR;

	    END;			! End of normal scope ELSE clause


	! We have now created a Scope Entry of some kind.  Attach it to the
	! end of the new scope list we are building.
	!
	PREVSCOPE[SCOPE$L_FLINK] = .SCOPE;
	PREVSCOPE = .SCOPE;

	END;				! End of INCR loop over PNVEC vector


    ! We have now built the new scope list successfully.  Note this by setting
    ! ERRINDEX to zero.
    !
    ERRINDEX[0] = 0;
    RETURN .NEW_SCOPE_LIST;

    END;

GLOBAL ROUTINE DBG$RST_CANMOD(MODNAMEPTR, LENGTH) =
!
! FUNCTION
!	This routine marks a specified module as being CANCELLED (not SET).
!	The routine accepts the desired module name and its length as input,
!	looks up that name in the RST Module Chain, and marks the module as
!	being not SET.  Alternatively, if no module name is specified, all
!	modules in the RST Module Chain are CANCELLED.
!
! INPUTS
!	MODNAMEPTR - A pointer to the first character of an ASCII string
!		  containing the module name.  If this pointer is zero, it
!		  is assumed that all modules should be marked as not SET.
!
!	LENGTH	- The length in characters of the module name.
!
! OUTPUTS
!	This routine returns the value STS$K_SUCCESS if the module was success-
!		  fully cancelled, or it returns STS$K_SEVERE if the specified
!		  module name does not exist in the RST Module Chain.  If all
!		  modules are cancelled, STS$K_SUCCESS is returned.
!

    BEGIN

    LOCAL
	RSTPTR: REF RST$ENTRY;		! Pointer to the Module RST Entry



    ! If a specific module name was specified, we look up the corresponding
    ! Module RST Entry, mark the module as being CANCELLED (not SET), and remove
    ! the module's RST symbol chain.
    !
    IF .MODNAMEPTR NEQ 0
    THEN
	BEGIN
	RSTPTR = GET_MOD_RST(.MODNAMEPTR, .LENGTH);
	IF .RSTPTR EQL 0 THEN RETURN STS$K_SEVERE;
	RSTPTR[RST$V_MODSET] = FALSE;
	DBG$RST_REMOVE(.RSTPTR);
	RETURN STS$K_SUCCESS;
	END;


    ! No module name was specified.  Go through the whole RST Module Chain (but
    ! ignore the anonymous module) and mark each module as being not SET.  Also
    ! remove each such module's RST symbol chain.  Note that we abort this loop
    ! if the user has entered Control-Y DEBUG to stop the command.
    !
    RSTPTR = .RST$START_ADDR;
    WHILE .RSTPTR NEQ 0 DO
	BEGIN
	$ABORT_ON_CONTROL_Y;
	IF NOT .RSTPTR[RST$V_ANONMOD]
	THEN
	    BEGIN
	    RSTPTR[RST$V_MODSET] = FALSE;
	    DBG$RST_REMOVE(.RSTPTR);
	    END;

	RSTPTR = .RSTPTR[RST$L_NXTMODPTR];
	END;

    RETURN STS$K_SUCCESS;

    END;

GLOBAL ROUTINE DBG$RST_DST_LENGTH(PASSED_DSTPTR) =
!
! FUNCTION
!	This routine searches the Moved DST entry list for a matching
!	"real" DST pointer.  If it finds one it returns the length of the
!	DST as stored in the MDE$ structure.  If not it returns the DST length
!	from the record.
!
! INPUTS
!	PASSED_DSTPTR - The DST pointer to look for. Passed by value.
!
! OUTPUTS
!	Returns the DST length.
!

    BEGIN

    LOCAL
	DSTPTR: REF DST$RECORD,		! ???
	MOVED_DST_ENTRY: REF MDE$RECORD;! ???



    ! Assure ourselves that it is "real".
    !
    DSTPTR = DBG$RST_DST_PTR(.PASSED_DSTPTR);
    MOVED_DST_ENTRY = .DBG$GL_MOVED_DST_LIST_HEAD;
    WHILE .MOVED_DST_ENTRY NEQA 0 DO
	BEGIN


	! Check if we've found it and return the "next" one.
	!
	IF .DSTPTR EQLA .MOVED_DST_ENTRY[MDE$L_REAL_DSTPTR]
	THEN
	    RETURN .MOVED_DST_ENTRY[MDE$L_REAL_LENGTH];


	! Next!
	!
	MOVED_DST_ENTRY = .MOVED_DST_ENTRY[MDE$L_FLINK];
	END;


    ! We didn't find anything.
    !
    RETURN .DSTPTR[DST$B_LENGTH];

    END;

GLOBAL ROUTINE DBG$RST_DST_PTR(PASSED_DSTPTR) =
!
! FUNCTION
!	This routine searches the Moved DST entry list for a matching
!	old DST pointer.  If it find one it returns the address of the
!	moved DST record.  If not it returns the passed DST pointer.
!
! INPUTS
!	PASSED_DSTPTR - The DST pointer to look for.  Passed by value.
!
! OUTPUTS
!	Returns the "real" DST pointer.
!

    BEGIN

    LOCAL
	MOVED_DST_ENTRY: REF MDE$RECORD;! ???



    ! ---
    !
    MOVED_DST_ENTRY = .DBG$GL_MOVED_DST_LIST_HEAD;
    WHILE .MOVED_DST_ENTRY NEQ 0 DO
	BEGIN


	! Check if we've found it and return the "real" one.
	!
	IF .PASSED_DSTPTR EQLA .MOVED_DST_ENTRY[MDE$L_ORIGINAL_DSTPTR]
	THEN
	    RETURN .MOVED_DST_ENTRY[MDE$L_REAL_DSTPTR];


	! Next!
	!
	MOVED_DST_ENTRY = .MOVED_DST_ENTRY[MDE$L_FLINK];

	END;


    ! We didn't find anything.
    !
    RETURN .PASSED_DSTPTR;

    END;

GLOBAL ROUTINE DBG$RST_INIT(IMGFILCHAN, FILENAME, 
			    IMG_HEADER, TRANSFER_ADDR): NOVALUE =
!
! FUNCTION
!	This routine initializes the Debug Symbol Table (DST) and the Run-Time
!	Symbol Table (RST) when the Debugger is first invoked.  It locates the
!	DST in the user's executable image file and maps it into the Debugger's
!	(and thus the user's) virtual address space.  It does the same with the
!	Global Symbol Table (GST).  Thereafter, it scans the entire DST to find
!	all modules which have DST records.  For each such module, the amount of
!	RST space required for the module is recorded, the static address bounds
!	of the module are entered in the Program Static Address Table (SAT), and
!	a Module RST Entry is constructed.  The RST Hash Table is also initial-
!	ized and all module names are entered in it.  Finally, enough free memo-
!	ry space is allocated to accommodate the RSTs of the largest several
!	modules.  Thus it should always be possible to have several modules in
!	the RST at the same time no matter how large they are.
!
! INPUTS
!	IMGFILCHAN - The channel that the image file is open on
!	FILENAME - The address of a Counted ASCII string containing the file-
!		  name of the executable image file.
!
!	IMG_HEADER - The address (in memory) of the executable image file's
!		  header block.
!
!	TRANSFER_ADDR - The program transfer address.  This is used only to
!		  select the module which is initially SET.
!
! OUTPUTS
!	The DST, GST, and RST are initialized.  No value is returned.
!

    BEGIN

    MAP
	FILENAME: REF VECTOR[,BYTE],	! The .EXE file's name in counted ASCII
	IMG_HEADER: REF BLOCK[,BYTE];	! Pointer to the .EXE file image header

    LITERAL
	MAX_ROUT_STACK	= 50;		! Maximum size of the internal routine
					!      start address stack--deeper rout-
					!      ine nesting can mess up SAT.

    LOCAL
	ADDRESS,			! Memory block address from $EXPREG
	DSTBLK_COUNT,			! Number of DST blocks to map to memory
	DSTPTR: REF DST$RECORD,		! Pointer to the current DST record
	ERROR_COUNT,			! Counts number of error messages given
					!      for Missing Module-Begin Record
	EXE_FILNAM_DESC: VECTOR[2,LONG],! File name descriptor for $CREMAPSEC
	EXE_SECBOUNDS: VECTOR[2,LONG],	! Map section bounds descriptor for the
					!      $CREMAPSEC system service
	EXE_SECNAM_DESC: VECTOR[2,LONG],! Map section name descriptor for the
					!      $CREMAPSEC system service
	IMG_DST_BLOCK: REF IHS$ENTRY,	! Pointer to DST/GST descriptor in the
					!      executable image header
	IN_MODULE_FLAG,			! Set to TRUE if we are after a Module-
					!      Begin record and before a Module-
					!      End record in the DST
	LANGUAGE,			! Language of the current module
	LENGTH,				! Byte length of a static address range
	LONGS_NEEDED,			! Number of longwords of RST space we
					!      need from $EXPREG to handle
					!      the largest several modules.
	MOD_DSTPTR: REF DST$RECORD,	! Pointer to the DST Module-Begin record
					!      for the current module
	MODNAMEPTR,			! Pointer to current module's name in
					!      counted ASCII (used for errors).
	MOD_SIZE_TBL:			! Table giving the RST symbol table
		VECTOR[MIN_MODS_IN_RST],!      sizes of the MIN_MODS_IN_RST
					!      largest modules in longwords.
	MST_INDEX,			! Index into MOD_SIZE_TBL vector
	NEXTSAT,			! Pointer to the next SAT entry on the
					!      TMP_SAT_CHAIN chain.
	NUM_BYTES,			! Number of bytes in $EXPREG call
	NUM_RST_ENTS,			! Number of RST entries needed for the
					!      current module's symbol table
	NUM_RST_LONGS,			! Number of RST longwords needed for the
					!      current module's symbol table
	NUM_SAT_ENTS,			! Number of Static Address Table entries
					!      in this module's RST
	PPTR: REF DST$PSECT_TRAILER,	! Pointer to PSECT DST record trailer
	PREV_SAT_PTR: REF SAT$ENTRY,	! Pointer to previous SAT entry in the
					!      Program SAT chain--used to insert
					!      new Static Address Table entries.
	PROG_SAT_PTR: REF SAT$ENTRY,	! Pointer to current SAT entry in the
					!      Program SAT chain--used to insert
					!      new Static Address Table entries.
	REC_NESTING,			! Depth of data record nesting in DST
	ROUT_STACK:			! Routine start address stack--used to
		VECTOR[MAX_ROUT_STACK],	!      build SAT for nested routines
	ROUT_STACK_INDEX,		! Current size of routine address stack
	RSTPTR: REF RST$ENTRY,		! Pointer to the current RST entry
	RSTSIZE,			! The RST space in longwords needed for
					!      the current module's symbol table
	SATPTR: REF SAT$ENTRY,		! Pointer to SAT entry when searching
					!      for module with transfer address
	STARTADDR,			! The start address of a static area
	STATIC_FLAG,			! Flag set to TRUE for static data items
	STATUS: BLOCK[1, LONG],		! Status returned by RMS or $CREMAPSEC
	TESTDSTSIZE,			! Size of test program DST for a
					!      Testable Debugger
	TMP_SAT_CHAIN,			! Pointer to a temporary Static Address
					!      Table chain for current module
	TMP_SAT_PTR: REF SAT$ENTRY,	! Pointer to the current entry in the
					!      temporary SAT chain when copying
					!      to the Program SAT chain.
	TYPE;				! The type of the current DST record



    !---------------------------------------------------------------------------
    !
    ! The first task is to map the Debug Symbol Table (DST) into virtual 
    ! address space.  To do this, we must locate the DST in the executable 
    ! image file (via the image header),
    ! open the file, call the Create Map Section system service for each symbol
    ! table, and then close the file.  Thereafter the DST can be refer-
    ! enced directly by the other symbol table access routines.
    ! (We'll do the same thing to GST in DBG$GST_INIT, the virtual address
    !  space is released after the GST_RST build.)
    !---------------------------------------------------------------------------
    !
    !
    ! Initialize some pointers in OWN or GLOBAL memory to zeroes.
    !
    RST$START_ADDR = 0;
    SAT$START_ADDR = 0;
    DST$BEGIN_ADDR = 0;
    DST$END_ADDR = 0;


    ! Start by doing some consistency checks to ensure that the image header
    ! pointer is non-zero and that the debug symbol-table offset in the header
    ! is non-zero.  If either is wrong, signal an error and give up.
    !
    IF .IMG_HEADER EQL 0
    THEN
	BEGIN
	SIGNAL(DBG$_NORSTBLD);
	RETURN;
	END;

    IF .IMG_HEADER[IHD$W_SYMDBGOFF] EQL 0
    THEN
	BEGIN
	SIGNAL(DBG$_NORSTBLD);
	RETURN;
	END;


    ! We have a debug symbol table descriptor in the image header.  If no DST
    ! exists (because all the modules were compiled without /DEBUG or /TRACE),
    ! we indicate this by leaving the DST address zeroed.  Otherwise we set the
    ! DST address to 1 temporarily.
    !
    IMG_DST_BLOCK = .IMG_HEADER + .IMG_HEADER[IHD$W_SYMDBGOFF];
    DSTBLK_COUNT = .IMG_DST_BLOCK[IHS$W_DSTBLKS];
    IF .DSTBLK_COUNT NEQ 0 THEN DST$BEGIN_ADDR = 1;


    ! If the DST's Virtual Block Number (VNB) is invalid, we simply pretend that
    ! there is no DST.  (This is actually an error in the image header.)
    !
    IF .IMG_DST_BLOCK[IHS$L_DSTVBN] LEQ 2 THEN DST$BEGIN_ADDR = 0;


    ! If this is a Testable Debugger, determine the length of the DST for the
    ! test program, i.e. before the Debugger's own DST records.  Set the size
    ! of the DST in file blocks accordingly so that only the test program's DST
    ! is mapped into virtual memory below.
    !
    IF (.DBG$GV_CONTROL[DBG$V_CONTROL_TDBG]) AND (.DST$BEGIN_ADDR NEQ 0)
    THEN
	BEGIN
	TESTDSTSIZE = TEST_DST_SIZE(.FILENAME, .IMG_DST_BLOCK);
	DSTBLK_COUNT = (.TESTDSTSIZE + 511)/512;
	END;


    ! If we decided above that there is no DST in the executable image, we print
    ! a message saying that there are no local symbols.
    !
    IF .DST$BEGIN_ADDR EQL 0
    THEN
	SIGNAL(DBG$_NOLOCALS)


    ! Otherwise we decided that there is a DST, so we create a map section which
    ! maps the DST into our virtual address space.  If this fails, we print the
    ! status message (with informational severity so we can continue) and set
    ! the DST start address to zero; if this succeeds, we set the DST start and
    ! end addresses to the values assigned by $CREMAPSEC.
    !
    ELSE
	BEGIN
	EXE_SECBOUNDS[0] = 200;
	EXE_SECBOUNDS[1] = 1^30;
	EXE_SECNAM_DESC[0] = 3;
	EXE_SECNAM_DESC[1] = UPLIT BYTE(%ASCIC 'DST');
	STATUS = SYS$CRMPSC(EXE_SECBOUNDS, EXE_SECBOUNDS, 0, SEC$M_EXPREG,
			EXE_SECNAM_DESC, 0, 0,
			.IMGFILCHAN, .DSTBLK_COUNT, 
			.IMG_DST_BLOCK[IHS$L_DSTVBN], 0, 0);
	IF NOT .STATUS
	THEN
	    BEGIN
	    DST$BEGIN_ADDR = 0;
	    STATUS[STS$V_SEVERITY] = SYS$K_INFO;
	    SIGNAL(.STATUS);
	    END

	ELSE
	    BEGIN
	    DST$BEGIN_ADDR = .EXE_SECBOUNDS[0];
	    DST$END_ADDR = .EXE_SECBOUNDS[1];
	    IF .DBG$GV_CONTROL[DBG$V_CONTROL_TDBG]
	    THEN
		DST$END_ADDR = .DST$BEGIN_ADDR + .TESTDSTSIZE - 1;

	    DST$NEXT_ADDR = .DST$BEGIN_ADDR;
	    END;

	END;


    !---------------------------------------------------------------------------
    !
    ! We have now mapped the DST into our (and the user's) virtual
    ! address space.  Next we want to scan the DST to find all modules in the
    ! program and to build the Run-Time Symbol Table's (the RST's) Module Chain.
    ! We will also build the Program Static Address Table (SAT) which indicates
    ! which static addresses belong to which modules, and we will build the RST
    ! hash table.  Finally, we will determine how much RST space we need for the
    ! several largest modules and allocate enough free space so that their RSTs
    ! can be in memory at the same time.
    !
    !---------------------------------------------------------------------------
    !
    !
    ! First create a Module RST Entry for the "anonymous module" to which we
    ! assign all global symbols (from the GST) which do not belong elsewhere.
    ! Global symbols are attached to this module's symbol chain only as they
    ! are referenced, not now when the RST is initially built.
    !
    RSTPTR = GET_MEM(RST$K_MODENTSIZ);
    RSTPTR[RST$B_KIND] = RST$K_MODULE;
    RSTPTR[RST$V_ANONMOD] = TRUE;
    RSTPTR[RST$B_LANGUAGE] = DBG$K_MACRO;


    ! Put the anonymous module at the start of the Module Entry RST chain.
    !
    RST$START_ADDR = .RSTPTR;
    PREV_RST_PTR = .RSTPTR;


    ! Initialize the RST Reference List so that RST$REF_LIST points to a list
    ! of zero RST entries.  This list is used by DBG$STA_GETSYMBOL to mark which
    ! RST entries are used by the current Debug command and thus cannot be re-
    ! moved from the RST until the command ends.
    !
    RST$REF_LIST = GET_MEM(22);
    RST$REF_LIST[0] = 20;
    RST$REF_LIST[1] = 0;


    ! Create the list head for the Least Recently Used Module (LRUM) table.
    ! This table is used by DBG$GET_MEMORY to determine what module to remove
    ! from the RST when more free memory space is needed.
    !
    LRUM$LISTHEAD = GET_MEM(LRUM$ENTSIZE);
    LRUM$LISTHEAD[LRUM$L_FLINK] = .LRUM$LISTHEAD;
    LRUM$LISTHEAD[LRUM$L_BLINK] = .LRUM$LISTHEAD;
    LRUM$LISTHEAD[LRUM$L_RSTPTR] = 0;


    ! Set up all Source File Control Blocks and associated RMS blocks that we
    ! need to do source line display.
    !
    DBG$SRC_INIT();


    ! Initialize the Screen Debugging feature.
    !
    DBG$SCR_INITIALIZE();


    ! Zero out all entries in the Module Size Table.  This table will give the
    ! RST space requirements of the several largest modules in the DST.  Also
    ! zero out several other counters and flags.
    !
    INCR I FROM 0 TO MIN_MODS_IN_RST - 1 DO
	MOD_SIZE_TBL[.I] = 0;

    IN_MODULE_FLAG = FALSE;
    ERROR_COUNT = 0;
    REC_NESTING = 0;
    SAT$START_ADDR = 0;


    ! If this executable image was linked by a VMS V4.0 or later linker, then
    ! we use the Debug Module Table to initialize the RST.  This is a much
    ! faster way of doing the initialization than reading through the whole
    ! Debug Symbol Table.  If this succeeds, we set up DSTPTR so that the loop
    ! below to scan the whole DST is skipped.
    !
    DSTPTR = .DST$BEGIN_ADDR;
    IF .(IMG_HEADER[IHD$L_LNKFLAGS])<V_(5)> AND
        (.DSTPTR[DST$L_MODBEG_LANGUAGE] NEQ DST$K_BASIC)
    THEN
	BEGIN
	STATUS = READ_DEBUG_MODULE_TABLE(.IMGFILCHAN,
					.IMG_DST_BLOCK, MOD_SIZE_TBL[0]);
	IF .STATUS THEN DSTPTR = .DST$END_ADDR;
	END;


    ! Scan the Debug Symbol Table to find all modules in it.  For each module,
    ! determine how much RST space that module's symbol table will require when
    ! when brought into the RST.  Also build its Static Address Table entries.
    ! Then create its Module RST Entry and put it on the RST Module Chain.
    ! Note that all this is done only if we did not initialize the RST from the
    ! the Debug Module Table, i.e. only if this is an old executable image.
    !
    WHILE .DSTPTR LSSU .DST$END_ADDR DO
	BEGIN


	! Pick up the DST record's type and use it as a CASE index so each
	! significant kind of DST record can be processed individually.
	!
    	IF .DSTPTR[DST$B_LENGTH] EQL 0
    	THEN
    	    TYPE = 257
    	ELSE
	    TYPE = .DSTPTR[DST$B_TYPE];
	IF (NOT .IN_MODULE_FLAG) AND (.TYPE NEQ DST$K_MODBEG) THEN EXITLOOP;
	CASE .TYPE FROM 0 TO 257 OF
	    SET


    	    ! Handle the error case where we have a zero length DST record
    	    ! within a module. A zero length DST record outside a module
    	    ! is OK.
    	    !
    	    [257]:
    		BEGIN
    		SIGNAL(DBG$_ZERLENDST);
    		END;


	    ! Handle the error case where we have a DST record not nested within
	    ! a Module-Begin/Module-End pair.  Give an error message, but quit
	    ! printing the message if we have done so too many times already.
	    !
	    [256]:
		BEGIN
		IF .ERROR_COUNT LSS 50 THEN SIGNAL(DBG$_MISMODBEG);
		IF .ERROR_COUNT EQL 50 THEN SIGNAL(DBG$_TOOMANERR);
		ERROR_COUNT = .ERROR_COUNT + 1;
		END;


	    ! Handle the Module Begin record.  Here we make sure we are not al-
	    ! ready in a module (i.e., we check for nesting errors), and then
	    ! we set up all pointers and counters we will need to collect infor-
	    ! mation about this module and later create a Module RST Entry.
	    !
	    [DST$K_MODBEG]:
		BEGIN
		IF .IN_MODULE_FLAG THEN SIGNAL(DBG$_MISMODEND, 1, .MODNAMEPTR);
		IN_MODULE_FLAG = TRUE;
		MOD_DSTPTR = .DSTPTR;
		MODNAMEPTR = MOD_DSTPTR[DST$B_MODBEG_NAME];
		NUM_RST_ENTS = 0;
		NUM_RST_LONGS = 0;
		NUM_SAT_ENTS = 0;
		TMP_SAT_CHAIN = 0;
		ROUT_STACK_INDEX = 0;
		LANGUAGE = .MOD_DSTPTR[DST$L_MODBEG_LANGUAGE];
		END;


	    ! Handle the Module End record.  Build the Module RST Entry for this
	    ! module and link it into the RST Module Chain.  Then see if it is
	    ! among the several largest modules in RST space requirements--if so
	    ! we remember how much RST space it needs.  Also copy the Static
	    ! Address Table entries on this module's temporary SAT chain over to
	    ! the permanent Program Static Address Table chain.
	    !
	    [DST$K_MODEND]:
		BEGIN
		IN_MODULE_FLAG = FALSE;


		! Determine how much RST space the module needs for its symbol
		! table.  Note that this includes both the space needed for RST
		! and SAT entries plus one longword for memory allocation con-
		! trol for each such entry.
		!
		RSTSIZE = .NUM_RST_ENTS + .NUM_RST_LONGS
				+ .NUM_SAT_ENTS*(1 + SAT$K_ENTSIZE);


		! Build the Module RST Entry for the current module.
		!
		RSTPTR = GET_MEM(RST$K_MODENTSIZ);
		RSTPTR[RST$L_DSTPTR] = .MOD_DSTPTR;
		RSTPTR[RST$B_KIND] = RST$K_MODULE;
		RSTPTR[RST$L_MODRSTSIZ] = 4*.RSTSIZE;
		RSTPTR[RST$B_LANGUAGE] = .LANGUAGE;


		! Link the Module RST Entry into the RST Module Chain.
		!
		PREV_RST_PTR[RST$L_NXTMODPTR] = .RSTPTR;
		PREV_RST_PTR = .RSTPTR;


		! If the amount of RST space the module needs makes it one of
		! the several largest modules, enter it in MOD_SIZE_TBL.  Note
		! that the table remains sorted on module size, largest first.
		!
		INCR I FROM 0 TO MIN_MODS_IN_RST - 1 DO
		    BEGIN
		    IF .RSTSIZE GTR .MOD_SIZE_TBL[.I]
		    THEN
			BEGIN
			DECR J FROM MIN_MODS_IN_RST - 2 TO .I DO
			    MOD_SIZE_TBL[.J+1] = .MOD_SIZE_TBL[.J];

			MOD_SIZE_TBL[.I] = .RSTSIZE;
			EXITLOOP;
			END;

		    END;


		! Copy the Static Address Table entries we have built and merged
		! on the TMP_SAT_CHAIN chain (which covers the current module
		! only) over to the permanent Program Static Address Table.
		!
		PREV_SAT_PTR = SAT$START_ADDR;
		PROG_SAT_PTR = .SAT$START_ADDR;
		TMP_SAT_PTR = .TMP_SAT_CHAIN;
		WHILE .TMP_SAT_PTR NEQ 0 DO
		    BEGIN


		    ! Find the proper place in the permanent chain to insert the
		    ! new entry so the chain remains sorted on start address.
		    !
		    WHILE .PROG_SAT_PTR NEQ 0 DO
			BEGIN
			IF .PROG_SAT_PTR[SAT$L_START] GTRU .TMP_SAT_PTR[SAT$L_START]
			THEN
			    EXITLOOP;

			PREV_SAT_PTR = .PROG_SAT_PTR;
			PROG_SAT_PTR = .PROG_SAT_PTR[SAT$L_FLINK];
			END;


		    ! Fill the module RST pointer into the new SAT entry and
		    ! link it into the permanent Program SAT.  Then step to
		    ! the next TMP_SAT_CHAIN entry.
		    !
		    NEXTSAT = .TMP_SAT_PTR[SAT$L_FLINK];
		    TMP_SAT_PTR[SAT$L_RSTPTR] = .RSTPTR;
		    TMP_SAT_PTR[SAT$L_FLINK] = .PROG_SAT_PTR;
		    PREV_SAT_PTR[SAT$L_FLINK] = .TMP_SAT_PTR;
		    PREV_SAT_PTR = .TMP_SAT_PTR;
		    TMP_SAT_PTR = .NEXTSAT;
		    END;

		END;			! End of Module-End-record code


	    ! Handle the PSECT record.  For each PSECT record we record its
	    ! address range in the temporary Static Address Table we are build-
	    ! ing for this module.  (That table will be copied to the Program
	    ! Static Address Table when the Module-End record is found.)  We
	    ! also tabulate that the PSECT will require a Label RST Entry.
	    !
	    [DST$K_PSECT]:
		BEGIN
		STARTADDR = .DSTPTR[DST$L_PSECT_VALUE];
		PPTR = DSTPTR[DST$A_PSECT_TRLR_BASE]
				+ .DSTPTR[DST$B_PSECT_TRLR_OFFS];
		LENGTH = .PPTR[DST$L_PSECT_SIZE];
		STATIC_ADDRESS(.STARTADDR, .LENGTH, 0, TMP_SAT_CHAIN, TRUE);
		NUM_SAT_ENTS = .NUM_SAT_ENTS + 1;
		NUM_RST_ENTS = .NUM_RST_ENTS + 1;
		NUM_RST_LONGS = .NUM_RST_LONGS + RST$K_LBLENTSIZ;
		END;


	    ! Handle the Routine-Begin record.  Tabulate how much RST space it
	    ! requires.  Also remember the routine start address in the routine
	    ! start address stack--we will need it when we find the Routine-End
	    ! record.
	    !
	    [DST$K_RTNBEG]:
		BEGIN
		NUM_RST_ENTS = .NUM_RST_ENTS + 1;
		NUM_RST_LONGS = .NUM_RST_LONGS + RST$K_ROUTENTSIZ;
		NUM_SAT_ENTS = .NUM_SAT_ENTS + 1;
		IF .ROUT_STACK_INDEX LSS MAX_ROUT_STACK
		THEN
		    ROUT_STACK[.ROUT_STACK_INDEX] = .DSTPTR[DST$L_RTNBEG_ADDRESS]

		ELSE IF .LANGUAGE NEQ DBG$K_MACRO
		THEN
		    SIGNAL(DBG$_DSTNESDEP, 1, .MODNAMEPTR);

		ROUT_STACK_INDEX = .ROUT_STACK_INDEX + 1;
		END;


	    ! Handle the Routine-End record.  Determine what address range the
	    ! routine body covers and enter that range in the temporary Static
	    ! Address Table we are building for the current module.  (That info
	    ! will be copied to the Program Static Address Table when we find
	    ! the Module-End record.)
	    !
	    [DST$K_RTNEND]:
		BEGIN
		ROUT_STACK_INDEX = .ROUT_STACK_INDEX - 1;
		IF .ROUT_STACK_INDEX LSS 0
		THEN
		    SIGNAL(DBG$_INCDSTNES, 1, .MODNAMEPTR)

		ELSE IF .ROUT_STACK_INDEX LSS MAX_ROUT_STACK
		THEN
		    BEGIN
		    STARTADDR = .ROUT_STACK[.ROUT_STACK_INDEX];
		    LENGTH = .DSTPTR[DST$L_RTNEND_SIZE];
		    STATIC_ADDRESS(.STARTADDR, .LENGTH, 0, TMP_SAT_CHAIN, TRUE);
		    END;

		END;


	    ! Handle the Lexical Block-Begin record.  Tabulate how much RST
	    ! space it will require.
	    !
	    [DST$K_BLKBEG]:
		BEGIN
		NUM_RST_ENTS = .NUM_RST_ENTS + 1;
		NUM_RST_LONGS = .NUM_RST_LONGS + RST$K_LEXENTSIZ;
		NUM_SAT_ENTS = .NUM_SAT_ENTS + 1;
		END;


	    ! Handle the Label record.  Again just tabulate how much RST space
	    ! is required for this record.
	    !
	    [DST$K_LABEL]:
		BEGIN
		NUM_RST_ENTS = .NUM_RST_ENTS + 1;
		NUM_RST_LONGS = .NUM_RST_LONGS + RST$K_LBLENTSIZ;
		NUM_SAT_ENTS = .NUM_SAT_ENTS + 1;
		END;


	    ! Handle the Label-or-Literal record.  If the record is for a Label,
	    ! tabulate the space needed for a Label RST Entry and a SAT entry.
	    ! If it is for a literal, tabulate the space needed for a Data Item
	    ! RST Entry.
	    !
	    [DST$K_LBLORLIT]:
		BEGIN
		NUM_RST_ENTS = .NUM_RST_ENTS + 1;
		IF .DSTPTR[DST$B_VFLAGS] EQL 1
		THEN
		    BEGIN
		    NUM_RST_LONGS = .NUM_RST_LONGS + RST$K_LBLENTSIZ;
		    NUM_SAT_ENTS = .NUM_SAT_ENTS + 1;
		    END

		ELSE
		    NUM_RST_LONGS = .NUM_RST_LONGS + RST$K_DATENTSIZ;

		END;


	    ! Handle the Entry-Point record.  Tabulate the RST space it needs.
	    !
	    [DST$K_ENTRY]:
		BEGIN
		NUM_RST_ENTS = .NUM_RST_ENTS + 1;
		NUM_RST_LONGS = .NUM_RST_LONGS + RST$K_EPTENTSIZ;
		NUM_SAT_ENTS = .NUM_SAT_ENTS + 1;
		END;


	    ! Handle the Record-Begin record.  Tabulate the space needed for the
	    ! Type RST Entry for the record and a possible Data Item RST Entry.
	    ! Also increment the current level of record nesting.
	    !
	    [DST$K_RECBEG]:
		BEGIN
		NUM_RST_ENTS = .NUM_RST_ENTS + 2;
		NUM_RST_LONGS = .NUM_RST_LONGS +
					RST$K_TYPENTSIZ + RST$K_DATENTSIZ + 1;
		IF .REC_NESTING GTR 0 THEN NUM_RST_LONGS = .NUM_RST_LONGS + 1;
		REC_NESTING = .REC_NESTING + 1;
		STATIC_CHECK(.DSTPTR, STARTADDR, LENGTH, STATIC_FLAG);
		IF .STATIC_FLAG
		THEN
		    BEGIN
		    STATIC_ADDRESS(.STARTADDR, .LENGTH, 0, TMP_SAT_CHAIN, TRUE);
		    NUM_SAT_ENTS = .NUM_SAT_ENTS + 1;
		    END;
		END;


	    ! Handle the Record End record.  Just decrement the record nesting
	    ! depth by one.
	    !
	    [DST$K_RECEND]:
		BEGIN
		IF .REC_NESTING LEQ 0 THEN SIGNAL(DBG$_INCDSTNES,1,.MODNAMEPTR);
		REC_NESTING = .REC_NESTING - 1;
		END;


	    ! Handle the Variant-Set Begin record.  Tabulate the space needed
	    ! for one Variant RST Entry plus a component list pointer to it.
	    !
	    [DST$K_VARBEG]:
		NUM_RST_LONGS = .NUM_RST_LONGS + RST$K_VARENTSIZ + 1;


	    ! Handle the Variant Value record.  Note that we need 2 longwords
	    ! per variant entry plus one more for a list pointer.
	    !
	    [DST$K_VARVAL]:
		NUM_RST_LONGS = .NUM_RST_LONGS + 3;


	    ! Handle the Enumeration Type Begin record.  Tabulate the space
	    ! needed for a Data Type RST Entry.
	    !
	    [DST$K_ENUMBEG]:
		BEGIN
		NUM_RST_ENTS = .NUM_RST_ENTS + 1;
		NUM_RST_LONGS = .NUM_RST_LONGS + RST$K_TYPENTSIZ;
		END;


	    ! Handle the Enumeration Type Element record.  Tabulate the space
	    ! needed for one Data RST Entry plus a longword pointer to it.
	    !
	    [DST$K_ENUMELT]:
		BEGIN
		NUM_RST_ENTS = .NUM_RST_ENTS + 1;
		NUM_RST_LONGS = .NUM_RST_LONGS + RST$K_DATENTSIZ + 1;
		END;


	    ! Handle all Data Symbol records.  This includes the Bliss special
	    ! cases, the Boolean record, and the Separate Type Spec record.  For
	    ! each, tabulate the amount of RST space needed for the data symbol
	    ! and make a Static Address Table entry if this is a static data
	    ! item.
	    !
	    [DSC$K_DTYPE_LOWEST TO DSC$K_DTYPE_HIGHEST,
	     DST$K_BLI,
	     DST$K_BOOL,
	     DST$K_SEPTYP]:
		BEGIN
		NUM_RST_ENTS = .NUM_RST_ENTS + 1;
		NUM_RST_LONGS = .NUM_RST_LONGS + RST$K_DATENTSIZ;
		IF .REC_NESTING GTR 0 THEN NUM_RST_LONGS = .NUM_RST_LONGS + 1;
		STATIC_CHECK(.DSTPTR, STARTADDR, LENGTH, STATIC_FLAG);
		IF .STATIC_FLAG
		THEN
		    BEGIN
		    STATIC_ADDRESS(.STARTADDR, .LENGTH, 0, TMP_SAT_CHAIN, TRUE);
		    NUM_SAT_ENTS = .NUM_SAT_ENTS + 1;
		    END;

		END;


	    ! Handle the BLISS field record.  Here we allow for one Data Item
	    ! RST Entry.
	    !
	    [DST$K_BLIFLD]:
		BEGIN
		NUM_RST_ENTS = .NUM_RST_ENTS + 1;
		NUM_RST_LONGS = .NUM_RST_LONGS + RST$K_DATENTSIZ;
		END;


	    ! Handle the COBOL special cases.  Tabulate the space needed for one
	    ! Data Item RST Entry.
	    !
	    [DST$K_COB_HACK]:
		BEGIN
		NUM_RST_ENTS = .NUM_RST_ENTS + 1;
		NUM_RST_LONGS = .NUM_RST_LONGS + RST$K_DATENTSIZ;
		END;


	    ! For all other records, we do nothing.
	    !
	    [INRANGE]:
		0;

	    TES;


	! Advance the DST pointer to point to the next record.  Then loop.
	!
	DSTPTR = DSTPTR[DST$A_NEXT] + .DSTPTR[DST$B_LENGTH];

	END;				! End of WHILE loop over whole DST


    ! If we come out of the loop but we are still in a module then
    ! then the module end record was missing. Signal an error.
    !
    IF .IN_MODULE_FLAG
    THEN
	SIGNAL(DBG$_MISMODEND, 1, .MODNAMEPTR);


    ! Now initialize the RST Hash Table and enter all module names in it.
    ! Note that we omit the anonymous module.
    !
    INCR I FROM 0 TO RST$K_HASHTBLSIZE - 1 DO
	BEGIN
	RST$HASH_TABLE[2*.I] = RST$HASH_TABLE[2*.I];
	RST$HASH_TABLE[2*.I + 1] = RST$HASH_TABLE[2*.I];
	END;

    RSTPTR = .RST$START_ADDR;
    RSTPTR = .RSTPTR[RST$L_NXTMODPTR];
    WHILE .RSTPTR NEQ 0 DO
	BEGIN
	DBG$HASH_INSERT(.RSTPTR);
	RSTPTR = .RSTPTR[RST$L_NXTMODPTR];
	END;


    ! Also create a global symbol SHARE$xxx in the RST for each shared image
    ! xxx in the current execution.  This allows the user to see the start
    ! address of each shared image (actually every image whether shared or
    ! not) in the execution.
    !
    ! Note: Shareable image format in VMS 4.0 (3B) is different from
    ! VMS 3.0.  So we call different routines depending on the system.
    !
    IF .DBG$GV_CONTROL[DBG$V_CONTROL_VERSION_4]
    THEN
        SHARED_IMAGE_NAMES(.IMGFILCHAN)
    ELSE
    	SHARED_IMAGE_NAMES_V3(.IMGFILCHAN);


    ! Build RST entries for all Global Symbols in GST.
    !
    IF NOT DBG$GST_INIT(.IMGFILCHAN, 0, .RST$START_ADDR) 
    THEN 
    	SIGNAL(DBG$_NOGLOBALS);


    ! Determine how much free memory space we need to accommodate the RST's of
    ! the largest several modules plus enough working space.  If we don't have
    ! that much, we expand the free memory pool (via DBG$EXPAND_MEMORY) so that
    ! we will have enough.  Note that if we cannot expand the pool that much
    ! (i.e, if DBG$EXPAND_MEMORY fails because the system cannot come up with
    ! the extra virtual address space), we scale down the request by one module
    ! at a time and try again--hence the WHILE loop here.
    !
    LONGS_NEEDED = 8192;			! 32K bytes of working space
    INCR I FROM 0 TO MIN_MODS_IN_RST - 1 DO
	LONGS_NEEDED = .LONGS_NEEDED + .MOD_SIZE_TBL[.I];

    LONGS_NEEDED = .LONGS_NEEDED - DBG$FREE_MEM_LEFT();
    MST_INDEX = MIN_MODS_IN_RST;
    WHILE .LONGS_NEEDED GTR 100 DO
	BEGIN
	STATUS = DBG$EXPAND_MEMORY(.LONGS_NEEDED);
	IF .STATUS OR (.MST_INDEX EQL 0) THEN EXITLOOP;
	MST_INDEX = .MST_INDEX - 1;
	LONGS_NEEDED = .LONGS_NEEDED - .MOD_SIZE_TBL[.MST_INDEX];
	END;


    ! The DST and RST are now initialized, the Program Static Address Table is
    ! built, the RST Hash Table is built, and the necessary free memory has
    ! been acquired (if it was possible).  We now set up the Scope List with
    ! the default scopes.
    !
    DBG$RST_SETSCOPE(UPLIT(0), RSTPTR);


    ! Now search the Static Address Table for the module with the transfer
    ! address so we can SET that module.
    !
    RSTPTR = 0;
    SATPTR = .SAT$START_ADDR;
    WHILE .SATPTR NEQ 0 DO
	BEGIN
	IF .TRANSFER_ADDR GEQ .SATPTR[SAT$L_START] AND
	   .TRANSFER_ADDR LEQ .SATPTR[SAT$L_END]
	THEN
	    BEGIN
	    RSTPTR = .SATPTR[SAT$L_RSTPTR];
	    EXITLOOP;
	    END;

	SATPTR = .SATPTR[SAT$L_FLINK];
	END;


    ! If we did not find the module with the transfer address, we SET the first
    ! module in the RST (and DST) instead.
    !
    IF .RSTPTR EQL 0
    THEN
	BEGIN
	RSTPTR = .RST$START_ADDR;
	RSTPTR = .RSTPTR[RST$L_NXTMODPTR];
	END;


    ! If we are in SUPERDEBUG, look up symbol BEGINHERE in the GST and set its
    ! address in the current PC.  If the lookup fails, we die right here.  Also
    ! set the language to BLISS and do not SET any initial module.
    !
    IF .DBG$GV_CONTROL[DBG$V_CONTROL_SDBG]
    THEN
	BEGIN
	BIND BEGINHERENAME = UPLIT BYTE(%ASCIC 'BEGINHERE');
	RSTPTR = DBG$STA_LOOKUP_GBL(BEGINHERENAME);
	IF .RSTPTR EQL 0 THEN SIGNAL(DBG$_NOSYMBOL, 1, BEGINHERENAME);
	DSTPTR = .RSTPTR[RST$L_DSTPTR];
	DBG$RUNFRAME[DBG$L_USER_PC] = .DSTPTR[DST$L_VALUE] + 2;
	DBG$SET_LANG(0, DBG$K_BLISS);
	RSTPTR = 0;
	END;


    ! Now actually SET the selected module and build its RST.  Also print the
    ! start-up message and set the language code accordingly.  Note that the
    ! module must be SET before we can use its language code--the language code
    ! is not set if READ_DEBUG_MODULE_TABLE did the RST initialization.
    !
    IF .RSTPTR NEQ 0
    THEN
	BEGIN
	RSTPTR[RST$V_MODSET] = TRUE;
	DBG$RST_BUILD(.RSTPTR, TRUE);
	DBG$SET_LANG(0, .RSTPTR[RST$B_LANGUAGE]);
	DSTPTR = .RSTPTR[RST$L_DSTPTR];
	SIGNAL(DBG$_INITIAL, 2,
		DBG$LANGUAGE(.RSTPTR[RST$B_LANGUAGE]),
		DSTPTR[DST$B_MODBEG_NAME]);
	END


    ! If no module could be SET, modify the initialization message accordingly.
    !
    ELSE
	BEGIN
	SIGNAL(DBG$_INITIAL, 2, DBG$LANGUAGE(.DBG$GB_LANGUAGE),
						UPLIT BYTE(%ASCIC 'no module'));
	END;


    ! If we saw a "TRANSFER$ADDRESS" DST but it specifies the same address
    ! as TRANSFER_ADDR, set the global back to zero - we do not need to
    ! do anything special.
    !
    IF .DBG$GL_TRANSFER_ADDRESS+2 EQL .TRANSFER_ADDR
    THEN
	DBG$GL_TRANSFER_ADDRESS = 0;


    ! Check for the presence of the special "TRANSFER$ADDRESS" DST
    ! which tells us that we did not come up at the true start of the
    ! main program. If it was present, signal an informational and
    ! set a break at the main program.
    !
    IF .DBG$GL_TRANSFER_ADDRESS NEQ 0
    THEN
    	BEGIN
    	LOCAL CMD_STRING: REF VECTOR[,BYTE];
    	SIGNAL(DBG$_NOTATMAIN);
    	CMD_STRING = DBG$GET_MEMORY(10);
    	CH$MOVE(36, UPLIT (%ASCII 'SET BREAK/TEMPORARY TRANSFER$ADDRESS'), .CMD_STRING);
    	CMD_STRING[36] = 0;
    	DBG$NCIS_ADD(.CMD_STRING, 36, CIS_INPBUF, 0, 0, 0);
    	END;


    ! The RST initialization is done.  Now return.
    !
    RETURN;

    END;

GLOBAL ROUTINE DBG$RST_MOST_RECENT(MODRSTPTR): NOVALUE =
!
! FUNCTION
!	This routine marks a specified module as being the Most Recently Used
!	module among the modules currently in the Run-Time Symbol Table (RST).
!	This is done by searching for the module in the LRUM (Least Recently
!	Used Module) table and moving its LRUM entry to the first position in
!	the table.  If no LRUM entry exists for the specified module, a new
!	entry is created and inserted at the beginning of the table.
!
!	The LRUM table is a doubly linked list of entries, where each entry
!	represents one module currently in the RST.  The list is ordered by
!	recency of reference, so that the first module on the list is the most
!	recently referenced and the last is the Least Recently Used.  This
!	routines moves entries to the beginning of the list--this keeps used
!	modules away from the Least Recently Used slot at the end of the list.
!
!	When more memory is needed in the free memory pool, DBG$GET_MEMORY will
!	use the LRUM table to find the Least Recently Used Module.  That module
!	is then removed from the RST so that its RST space can be reused.  The
!	Most Recently Used module will never be removed, however; this prevents
!	a module from being removed while its own RST is being built.
!
! INPUTS
!	MODRSTPTR - A pointer to the Module RST Entry for the module to be
!		  marked as being Most Recently Used.
!
! OUTPUTS
!	NONE
!

    BEGIN

    MAP
	MODRSTPTR: REF RST$ENTRY;	! Pointer to Module RST Entry of the
					!      Most Recently Used module

    LOCAL
	BACKPTR: REF LRUM$ENTRY,	! Pointer to previous entry on LRUM list
	FORWPTR: REF LRUM$ENTRY,	! Pointer to the next entry on LRUM list
	PTR: REF LRUM$ENTRY;		! Pointer to the current LRUM entry



    ! If the specified module is already marked as being the Most Recently Used
    ! module, return right away.
    !
    IF .MODRSTPTR EQL .LRUM$MOST_RECENT THEN RETURN;


    ! Search the whole Least Recently Used Module list for the MODRSTPTR module.
    ! Exit the loop with PTR pointing to the corresponding LRUM entry.
    !
    PTR = .LRUM$LISTHEAD[LRUM$L_FLINK];
    WHILE TRUE DO
	BEGIN


	! If we have come to the end of the list, the specified module is not on
	! the LRUM list.  If so, create a new LRUM entry for the MODRSTPTR mod-
	! ule and exit the search loop.
	!
	IF .PTR EQL .LRUM$LISTHEAD
	THEN
	    BEGIN
	    IF NOT .MODRSTPTR[RST$V_MOD_IN_RST]
	    THEN
		$DBG_ERROR('RSTCNTRL\RST_MOST_RECENT');

	    PTR = DBG$GET_MEMORY(LRUM$ENTSIZE);
	    PTR[LRUM$L_RSTPTR] = .MODRSTPTR;
	    EXITLOOP;
	    END;


	! If this is the desired LRUM entry, unlink it from the doubly linked
	! list and exit the loop.
	!
	IF .PTR[LRUM$L_RSTPTR] EQL .MODRSTPTR
	THEN
	    BEGIN
	    FORWPTR = .PTR[LRUM$L_FLINK];
	    BACKPTR = .PTR[LRUM$L_BLINK];
	    FORWPTR[LRUM$L_BLINK] = .BACKPTR;
	    BACKPTR[LRUM$L_FLINK] = .FORWPTR;
	    EXITLOOP;
	    END;


	! We have not found it yet--link on and loop.
	!
	PTR = .PTR[LRUM$L_FLINK];
	END;


    ! We now have the desired LRUM entry.  Link it into the doubly linked LRUM
    ! list in the Most Recently Used position.  Also set LRUM$MOST_RECENT to
    ! point to the specified Module RST Entry.  Then return.
    !
    FORWPTR = .LRUM$LISTHEAD[LRUM$L_FLINK];
    BACKPTR = .LRUM$LISTHEAD;
    PTR[LRUM$L_FLINK] = .FORWPTR;
    PTR[LRUM$L_BLINK] = .BACKPTR;
    FORWPTR[LRUM$L_BLINK] = .PTR;
    BACKPTR[LRUM$L_FLINK] = .PTR;
    LRUM$MOST_RECENT = .MODRSTPTR;
    RETURN;

    END;

GLOBAL ROUTINE DBG$RST_NEXT_DST(PASSED_DSTPTR) =
!
! FUNCTION
!	This routine searches the Moved DST entry list for a matching
!	"real" DST pointer.  If it find one it returnes the address of the
!	next DST.  If not it returns the next DST as calculated using the
!	length.
!
! INPUTS
!	PASSED_DSTPTR - The DST pointer to look for.  Passed by value.
!
! OUTPUTS
!	Returns the "next" DST pointer.
!

    BEGIN

    LOCAL
	DSTPTR: REF DST$RECORD,		! ???
	MOVED_DST_ENTRY: REF MDE$RECORD;! ???



    ! Assure ourselves that it is "real".
    !
    DSTPTR = DBG$RST_DST_PTR(.PASSED_DSTPTR);
    MOVED_DST_ENTRY = .DBG$GL_MOVED_DST_LIST_HEAD;
    WHILE .MOVED_DST_ENTRY NEQA 0 DO
	BEGIN


	! Check if we've found it and return the "next" one.  Make sure it
	! hasn't moved
	!
	IF .DSTPTR EQLA .MOVED_DST_ENTRY[MDE$L_REAL_DSTPTR]
	THEN
	    RETURN DBG$RST_DST_PTR(.MOVED_DST_ENTRY[MDE$L_NEXT_DSTPTR]);


	! Next!
	!
	MOVED_DST_ENTRY = .MOVED_DST_ENTRY[MDE$L_FLINK];

	END;


    ! We didn't find anything.  Make sure it hasn't moved.
    !
    RETURN DBG$RST_DST_PTR(DSTPTR[DST$A_NEXT] + .DSTPTR[DST$B_LENGTH]);

    END;

GLOBAL ROUTINE DBG$RST_REMOVE(MODRSTPTR): NOVALUE =
!
! FUNCTION
!	This routine removes the RST for one module from the Run-Time Symbol
!	Table (RST).  It accepts as input a pointer to the Module RST Entry of
!	the module to be removed.  The module's symbol chain is then scanned,
!	and all RST entries on it with zero reference counts are released to the
!	free memory pool.  The module's Static Address Table chain is also re-
!	leased and its Least Recently Used Module (LRUM) table entry is removed.
!
!	RST entries on the module's symbol chain which are locked (have non-zero
!	reference counts) cannot be released since there are pointers around
!	which point to them.  Such entries are therefore added to the Temporary
!	RST Entry List after being removed from the module's symbol chain and
!	from the RST Hash Table.  These RST entries are eventually released by
!	routine DBG$RST_TEMP_RELEASE after their reference counts have been re-
!	duced to zero.
!
! INPUTS
!	MODRSTPTR - A pointer to the Module RST Entry of the module which is to
!		  be removed from the RST.
!
! OUTPUTS
!	NONE
!

    BEGIN

    MAP
	MODRSTPTR: REF RST$ENTRY;	! Pointer to the Module RST Entry of the
					!      module to be removed

    LOCAL
	BACKLRUM: REF LRUM$ENTRY,	! Pointer to previous LRUM entry
	BACKPTR: REF RST$ENTRY,		! Pointer to previous RST entry on
					!      the RST hash chain
	FORWLRUM: REF LRUM$ENTRY,	! Pointer to the next LRUM entry
	FORWPTR: REF RST$ENTRY,		! Pointer to the next RST entry on
					!      the RST hash chain
	LOCKNODE: DBG$LINK_NODE,	! Node used to lock or unlock SYMIDs
	LRUMPTR: REF LRUM$ENTRY,	! Pointer to the current LRUM (Least Re-
					!      cently Used Module) table entry
	NEXTRST,			! Pointer to the next RST entry on the
					!      module's symbol chain
	NEXTSAT,			! Pointer to the next entry on the
					!      module's SAT chain
	RSTPTR: REF RST$ENTRY,		! Pointer to the current RST entry on
					!      the module's symbol chain
	SATPTR: REF SAT$ENTRY;		! Pointer to the current Static Address
					!      Table entry being removed



    ! Mark the specified module as no longer being in the RST.  Also increment
    ! the reference counts of all RST entries which are referenced by the cur-
    ! rent Debug command (the entries on the RST Reference List).
    !
    MODRSTPTR[RST$V_MOD_IN_RST] = FALSE;
    LOCKNODE[DBG$L_LINK_NODE_LINK] = 0;
    INCR I FROM 1 TO .RST$REF_LIST[1] DO
	BEGIN
	LOCKNODE[DBG$L_LINK_NODE_VALUE] = .RST$REF_LIST[.I + 1];
	DBG$STA_LOCK_SYMID(LOCKNODE);
	END;


    ! Loop over the module's symbol chain and remove all entries on it from that
    ! chain and from the RST Hash Table.  Release all RST entries with zero ref-
    ! erence counts to the memory pool, and put those with non-zero reference
    ! counts on the Temporary RST Entry List.
    !
    RSTPTR = .MODRSTPTR[RST$L_SYMCHNPTR];
    MODRSTPTR[RST$L_SYMCHNPTR] = 0;
    WHILE .RSTPTR NEQ 0 DO
	BEGIN
	NEXTRST = .RSTPTR[RST$L_SYMCHNPTR];


	! Remove the RST entry from the RST Hash Table.
	!
	FORWPTR = .RSTPTR[RST$L_HASH_FLINK];
	BACKPTR = .RSTPTR[RST$L_HASH_BLINK];
	FORWPTR[RST$L_HASH_BLINK] = .BACKPTR;
	BACKPTR[RST$L_HASH_FLINK] = .FORWPTR;


	! Since the SAT is going to be removed, the pointers into the SAT
	! should be updated (zeroed).  This is done for every routine;
	! especially those that are hanging around because their reference
	! count is not zero.  This may effect code in DBG$STA_SETCONTEXT.
	!
	IF .RSTPTR[RST$B_KIND] EQL RST$K_ROUTINE
	THEN
	    RSTPTR[RST$L_RTNSATPTR] = 0;


	! Release the RST entry to the memory pool or put it on the
	! Temporary RST Entry List.
	!
	IF .RSTPTR[RST$W_REFCOUNT] EQL 0
	THEN
	    DBG$REL_MEMORY(.RSTPTR)

	ELSE
	    BEGIN
	    RSTPTR[RST$L_HASH_FLINK] = .RST$TEMP_LIST;
	    RSTPTR[RST$L_HASH_BLINK] = 0;
	    RST$TEMP_LIST = .RSTPTR;
	    RSTPTR[RST$L_SYMCHNPTR] = 0;
	    END;

	RSTPTR = .NEXTRST;
	END;


    ! Also remove all SAT entries on the module's Static Address Table chain.
    !
    SATPTR = .MODRSTPTR[RST$L_SAT_PTR];
    MODRSTPTR[RST$L_SAT_PTR] = 0;
    WHILE .SATPTR NEQ 0 DO
	BEGIN
	NEXTSAT = .SATPTR[SAT$L_FLINK];
	DBG$REL_MEMORY(.SATPTR);
	SATPTR = .NEXTSAT;
	END;


    ! If we have PC-Correlation and Source-Correlation DST record pointer
    ! tables, we release them here.
    !
    IF .MODRSTPTR[RST$L_MODPCTBL] NEQ 0
    THEN
	DBG$REL_MEMORY(.MODRSTPTR[RST$L_MODPCTBL]);

    MODRSTPTR[RST$L_MODPCTBL] = 0;
    IF .MODRSTPTR[RST$L_MODSRCTBL] NEQ 0
    THEN
	DBG$REL_MEMORY(.MODRSTPTR[RST$L_MODSRCTBL]);

    MODRSTPTR[RST$L_MODSRCTBL] = 0;


    ! Decrement the reference counts of all RST entries referenced by the
    ! current Debug command; we have already ensured that they will stay in
    ! memory for now.
    !
    INCR I FROM 1 TO .RST$REF_LIST[1] DO
	BEGIN
	LOCKNODE[DBG$L_LINK_NODE_VALUE] = .RST$REF_LIST[.I + 1];
	DBG$STA_UNLOCK_SYMID(LOCKNODE);
	END;


    ! Finally remove the LRUM (Least Recently Used Module) table entry for the
    ! module.  Such entries may only exist for modules currently in the RST.
    !
    IF .MODRSTPTR EQL .LRUM$MOST_RECENT THEN LRUM$MOST_RECENT = 0;
    LRUMPTR = .LRUM$LISTHEAD[LRUM$L_FLINK];
    WHILE .LRUMPTR NEQ .LRUM$LISTHEAD DO
	BEGIN
	IF .LRUMPTR[LRUM$L_RSTPTR] EQL .MODRSTPTR
	THEN
	    BEGIN
	    FORWLRUM = .LRUMPTR[LRUM$L_FLINK];
	    BACKLRUM = .LRUMPTR[LRUM$L_BLINK];
	    FORWLRUM[LRUM$L_BLINK] = .BACKLRUM;
	    BACKLRUM[LRUM$L_FLINK] = .FORWLRUM;
	    DBG$REL_MEMORY(.LRUMPTR);
	    EXITLOOP;
	    END;

	LRUMPTR = .LRUMPTR[LRUM$L_FLINK];
	END;


    ! We are all done with the module--now return.
    !
    RETURN;

    END;

GLOBAL ROUTINE DBG$RST_SETMOD(MODNAMEPTR, LENGTH, ALLOCATE_FLAG) =
!
! FUNCTION
!	This routine marks a specified module as being SET.  The routine accepts
!	the desired module name and its length as input, looks that name up in
!	the RST Module Chain, and marks the module as being SET.  Alternatively,
!	if no module name is specified, all modules in the RST Module Chain are
!	marked as SET (Shareable image module must be set individually).
!
! INPUTS
!	MODNAMEPTR - A pointer to the first character of an ASCII string
!		  containing the module name.  If this pointer is zero, it is
!		  assumed that all modules should be marked as being SET.
!
!	LENGTH	- The length in characters of the module name.
!
!	ALLOCATE_FLAG - TRUE if SET MODULE/ALLOCATE was specified.
!
! OUTPUTS
!	This routine returns the value STS$K_SUCCESS if the module was success-
!		  fully SET; it returns STS$K_SEVERE if the specified module
!		  name does not exist in the RST Module Chain.  If all modules
!		  are SET, STS$K_SUCCESS is always returned.
!

    BEGIN

    LOCAL
	RSTPTR: REF RST$ENTRY;		! Pointer to the Module RST Entry



    ! Set the flag saying whether it is OK to allocate more memory in order
    ! to set this module. This is true if /ALLOCATE was specifically
    ! requested.
    !
    DBG$GV_CONTROL[DBG$V_CONTROL_ALLOCATE] = .ALLOCATE_FLAG;


    ! If a specific module name was specified, we look up the corresponding
    ! Module RST Entry, mark the module as being SET, and build the RST symbol
    ! chain for the module.
    !
    IF .MODNAMEPTR NEQ 0
    THEN
	BEGIN
	RSTPTR = GET_MOD_RST(.MODNAMEPTR, .LENGTH);
	IF .RSTPTR EQL 0 THEN RETURN STS$K_SEVERE;
	RSTPTR[RST$V_MODSET] = TRUE;
	DBG$RST_BUILD(.RSTPTR);
	RETURN STS$K_SUCCESS;
	END;


    ! No module name was specified.  Go through the whole RST Module Chain (but
    ! ignore the anonymous module) and mark each module as being SET.  Also
    ! build each such module's RST symbol chain.  Note that we abort this loop
    ! if the user entered Control-Y DEBUG to stop the SET MODULE command.
    !
    RSTPTR = .RST$START_ADDR;
    WHILE .RSTPTR NEQ 0 DO
	BEGIN
	$ABORT_ON_CONTROL_Y;
	IF NOT .RSTPTR[RST$V_ANONMOD]
	THEN
	    BEGIN
    	    IF NOT .RSTPTR[RST$V_SHARE_IMAGE]
    	    THEN
    		BEGIN
	    	RSTPTR[RST$V_MODSET] = TRUE;
	    	DBG$RST_BUILD(.RSTPTR);
    		END;
	    END;

	RSTPTR = .RSTPTR[RST$L_NXTMODPTR];
	END;

    RETURN STS$K_SUCCESS;

    END;

GLOBAL ROUTINE DBG$RST_SETSCOPE(PNVEC, ERRINDEX, SET_SCOPE_MODULE): NOVALUE =
!
! FUNCTION
!	This routine makes a new set of scopes available to the symbol table
!	access routines (DBG$STA_GETSYMBOL in particular).  It is thus called
!	in the course of processing the SET SCOPE command.  It accepts as in-
!	put a vector of pointers to Pathname Descriptors for the scopes speci-
!	fied on the SET SCOPE command.  It calls DBG$RST_BLDSCOPE_LIST to
!	build a linked list of the corresponding Scope Entries, and makes 
!	SCOPE$LIST point to this list.
!
! INPUTS
!	PNVEC	- A vector of pointers to Pathname Descriptors for the scopes
!		  specified on the SET SCOPE command.  PNVEC[0] gives the number
!		  of such pointers and PNVEC[1] through PNVEC[.PNVEC[0]] contain
!		  the pointers to the Pathname Descriptors.  The CANCEL SCOPE
!		  command is handled by making PNVEC[0] zero.
!
!	ERRINDEX - The address of a longword location to receive an "error
!		  index"; see description below.
!
!	SET_SCOPE_MODULE - An optional 3rd parameter which if present and
!			   TRUE means we were called from SET SCOPE/MODULE.
!
! OUTPUTS
!	ERRINDEX - If some pathname is found to be invalid, the PNVEC index of
!		  that pathname is returned to ERRINDEX.  The calling routine
!		  can then use ERRINDEX to produce an error message.  If all
!		  scope pathnames are correct, zero is returned to ERRINDEX.
!
!	No value is returned.
!

    BEGIN

    MAP
	PNVEC: REF VECTOR[,LONG],	! Pointer to vector of Pathname Descrip-
					!      tor pointers
	ERRINDEX: REF VECTOR[1];	! Pointer to error index longword

    LOCAL
	LOCKNODE: DBG$LINK_NODE,	! Node used to lock or unlock SYMIDs
    	MODULE_FLAG,			! TRUE if called from SET SCOPE/MODULE
	NEW_SCOPE_LIST,			! Pointer to new scope list being built
	PREVSCOPE: REF SCOPE$ENTRY,	! Pointer to the scope entry before the
					!      present scope entry
	SCOPE: REF SCOPE$ENTRY;		! Pointer to the present scope entry

    BUILTIN
    	ACTUALCOUNT;


    ! Initialize the flag that says whether we were called from
    ! SET SCOPE/MODULE. This is just passed along to the BLDSCOPE routine
    ! that actually processes the SET SCOPE command.
    !
    IF ACTUALCOUNT() LSS 3
    THEN
    	MODULE_FLAG = FALSE
    ELSE
    	MODULE_FLAG = .SET_SCOPE_MODULE;


    NEW_SCOPE_LIST = DBG$RST_BLDSCOPE_LIST(.PNVEC, ERRINDEX[0], 
    					    TRUE, .MODULE_FLAG);
    IF .ERRINDEX[0] NEQ 0 THEN RETURN;


    ! Lock the scope's RST entry in memory.
    !
    !
    SCOPE = .NEW_SCOPE_LIST;
    WHILE .SCOPE NEQ 0 DO
        BEGIN
	IF .SCOPE[SCOPE$L_STATE] EQL SCOPE$K_NORMAL
	THEN
	    BEGIN
            LOCKNODE[DBG$L_LINK_NODE_LINK] = 0;
            LOCKNODE[DBG$L_LINK_NODE_VALUE] = .SCOPE[SCOPE$L_RSTPTR];
            DBG$STA_LOCK_SYMID(LOCKNODE);
	    END;

	PREVSCOPE = .SCOPE;
	SCOPE = .PREVSCOPE[SCOPE$L_FLINK];
	END;


    ! We have now built the new scope list successfully. 
    ! Append two more scope entries to the end of the new scope list: one for
    ! all SET modules and one for the global (GST) scope.
    !
    SCOPE = DBG$GET_MEMORY(SCOPE$K_ENTSIZE);
    SCOPE[SCOPE$L_FLINK] = 0;
    SCOPE[SCOPE$L_STATE] = SCOPE$K_SETMODS;
    SCOPE[SCOPE$L_RSTPTR] = 0;
    SCOPE[SCOPE$L_MODPTR] = 0;
    PREVSCOPE[SCOPE$L_FLINK] = .SCOPE;
    PREVSCOPE = .SCOPE;
    SCOPE = DBG$GET_MEMORY(SCOPE$K_ENTSIZE);
    SCOPE[SCOPE$L_FLINK] = 0;
    SCOPE[SCOPE$L_STATE] = SCOPE$K_GLOBAL;
    SCOPE[SCOPE$L_RSTPTR] = 0;
    SCOPE[SCOPE$L_MODPTR] = 0;
    PREVSCOPE[SCOPE$L_FLINK] = .SCOPE;


    ! Then loop through the old scope list and release all the old scope entries
    ! to the free memory pool.  Note that we unlock normal scope RST entries.
    !
    WHILE .SCOPE$LIST NEQ 0 DO
	BEGIN
	IF .SCOPE$LIST[SCOPE$L_STATE] EQL SCOPE$K_NORMAL
	THEN
	    BEGIN
	    LOCKNODE[DBG$L_LINK_NODE_LINK] = 0;
	    LOCKNODE[DBG$L_LINK_NODE_VALUE] = .SCOPE$LIST[SCOPE$L_RSTPTR];
	    DBG$STA_UNLOCK_SYMID(LOCKNODE);
	    END;

	PREVSCOPE = .SCOPE$LIST;
	SCOPE$LIST = .PREVSCOPE[SCOPE$L_FLINK];
	DBG$REL_MEMORY(.PREVSCOPE);
	END;


    ! Set the start address of the new scope list in SCOPE_LIST; that makes it
    ! official.  Then return.
    !
    SCOPE$LIST = .NEW_SCOPE_LIST;
    RETURN;

    END;

ROUTINE BLDSCOPE_ERROR_HANDLER(SIGARG, MECHARG, ENBLARG) =
!
! FUNCTION
!	This routine is the error handler for the DBG$RST_BLDSCOPE_LIST routine.
!	All it does is to handle the DBG$_BADSCOPE and DBG$_NOFREE errors by
!	releasing all Scope Entries accumulated on NEW_SCOPE_LIST back to the
!	memory pool so they are not lost.  For DBG$_BADSCOPE, the handler then
!	unwinds so that control is returned to the routine that called routine
!	DBG$RST_BLDSCOPE_LIST.  Otherwise, it just resignals the error.
!
! INPUTS
!	SIGARG	- The signal argument vector.
!
!	MECHARG	- The mechanism argument vector.
!
!	ENBLARG	- The enable argument vector.  ENBLARG[1] is assumed to
!		  contains the address of NEW_SCOPE_LIST.
!
! OUTPUTS
!	For the DBG$_BADSCOPE error, this handler unwinds the call stack.
!		  For all other errors, it resignals.
!

    BEGIN

    MAP
	SIGARG: REF VECTOR[,LONG],	! Signal argument vector
	ENBLARG: REF VECTOR[,LONG];	! Enable declaration argument vector

    BIND
	NEW_SCOPE_LIST = .ENBLARG[1];	! Address of pointer to new scope list

    LOCAL
	RELSCOPE,			! Pointer to scope entry being released
	SCOPE: REF SCOPE$ENTRY;		! Pointer to the next scope list entry



    ! If the condition code is anything other than DBG$_BADSCOPE or DBG$_NOFREE,
    ! just resignal the error.
    !
    IF .SIGARG[1] NEQ DBG$_BADSCOPE AND
       .SIGARG[1] NEQ DBG$_NOUNIQUE AND
       .SIGARG[1] NEQ DBG$_NOFREE
    THEN
	RETURN SS$_RESIGNAL;


    ! It is one of the errors we handle.  Loop through the new scope list and
    ! release each Scope Entry on it back to the free memory pool.
    !
    SCOPE = .NEW_SCOPE_LIST;
    WHILE .SCOPE NEQ 0 DO
	BEGIN
	RELSCOPE = .SCOPE;
	SCOPE = .SCOPE[SCOPE$L_FLINK];
	DBG$REL_MEMORY(.RELSCOPE);
	END;


    ! For DBG$_BADSCOPE, unwind the stack to return control to the caller of
    ! DBG$RST_SETSCOPE.  For DBG$_NOFREE, we simply resignal the error.
    !
    IF .SIGARG[1] EQL DBG$_BADSCOPE THEN SETUNWIND();
    RETURN SS$_RESIGNAL;

    END;

ROUTINE BUILD_LABEL_RST(DSTPTR) =
!
! FUNCTION
!	This routine builds a skeleton Label RST Entry.  The main thing it does,
!	however, is to determine if a label is a numeric label.  If the label is
!	numeric, a memory block is allocated to hold both the Label RST Entry
!	and a dummy DST record for that label.  The dummy DST record is set up
!	so that the name field contains "%LABEL nnn" where nnn is the label num-
!	ber stripped of all leading zeroes.  This allows the Debugger to search
!	for "%LABEL nnn" as it searches for any other symbol without making any
!	special provisions for the "%LABEL" part (other than when parsing).
!
! INPUTS
!	DSTPTR	- A pointer to the original label DST record for the label.
!
! OUTPUTS
!	A pointer to a skeleton Label RST Entry is returned as the routine's
!		  value.  The RST$L_DSTPTR field is filled in correctly in this
!		  entry, but all other fields are empty.  If the label is numer-
!		  ic, this pointer points to a dummy DST record with a modified
!		  label name; otherwise it points to the original DST record.
!

    BEGIN

    MAP
	DSTPTR: REF DST$RECORD;		! Pointer to original label DST record

    LOCAL
	FIRSTLOC,			! Location of first non-zero digit
	J,				! Index into new label name string
	NAMEPTR: REF VECTOR[,BYTE],	! Pointer to original name string
	NEWDST: REF DST$RECORD,		! Pointer to new "dummy" DST record
	NEWNAME: REF VECTOR[,BYTE],	! Pointer to new label name string
	NUMLBL_FLAG,			! Set to TRUE if label is numeric
	RSTPTR: REF RST$ENTRY;		! Pointer to new Label RST Entry



    ! Determine if the input label's name is fully numeric.  Also determine the
    ! location of the first non-zero digit in the name.
    !
    NAMEPTR = DSTPTR[DST$B_NAME];
    FIRSTLOC = 0;
    NUMLBL_FLAG = TRUE;
    INCR I FROM 1 TO .NAMEPTR[0] DO
	BEGIN
	IF (.NAMEPTR[.I] LSS '0') OR (.NAMEPTR[.I] GTR '9')
	THEN
	    BEGIN
	    NUMLBL_FLAG = FALSE;
	    EXITLOOP;
	    END;

	IF (.NAMEPTR[.I] NEQ '0') AND (.FIRSTLOC EQL 0) THEN FIRSTLOC = .I;
	END;

    IF .FIRSTLOC EQL 0 THEN FIRSTLOC = .NAMEPTR[0];


    ! If the label is not numeric, get a memory block for the Label RST Entry
    ! only, put the DST pointer in the RST$L_DSTPTR field, and return.
    !
    IF (NOT .NUMLBL_FLAG) OR (.NAMEPTR[0] EQL 0)
    THEN
	BEGIN
	RSTPTR = DBG$GET_MEMORY(RST$K_LBLENTSIZ);
	RSTPTR[RST$L_DSTPTR] = .DSTPTR;
	RETURN .RSTPTR;
	END;


    ! The label is numeric.  Allocate a memory block large enough to hold both
    ! the Label RST Entry and a dummy DST record for the label.  The name in
    ! this dummy DST record is set to "%LABEL nnn" where nnn is all the digits
    ! of the label number except for leading zeroes.  We then return.
    !
    RSTPTR = DBG$GET_MEMORY(RST$K_LBLENTSIZ + (.NAMEPTR[0] - .FIRSTLOC + 19)/4);
    NEWDST = .RSTPTR + 4*RST$K_LBLENTSIZ;
    RSTPTR[RST$L_DSTPTR] = .NEWDST;
    NEWDST[DST$B_LENGTH] = .NAMEPTR[0] - .FIRSTLOC + 15;
    NEWDST[DST$B_TYPE] = DST$K_LABEL;
    NEWDST[DST$B_VFLAGS] = 0;
    NEWDST[DST$L_VALUE] = .DSTPTR[DST$L_VALUE];
    NEWNAME = NEWDST[DST$B_NAME];
    NEWNAME[1] = '%';
    NEWNAME[2] = 'L';
    NEWNAME[3] = 'A';
    NEWNAME[4] = 'B';
    NEWNAME[5] = 'E';
    NEWNAME[6] = 'L';
    NEWNAME[7] = ' ';
    J = 7;
    INCR I FROM .FIRSTLOC TO .NAMEPTR[0] DO
	BEGIN
	J = .J + 1;
	NEWNAME[.J] = .NAMEPTR[.I];
	END;

    NEWNAME[0] = .J;
    RETURN .RSTPTR;

    END;

ROUTINE COPY_COMP_LIST(OLDPTR): NOVALUE =
!
! FUNCTION
!	This routine copies a record component list from a component list
!	memory block to memory inside a Data Type RST Entry memory block.
!	This is done because component lists must be accumulated in separate
!	memory blocks which can be dynamically grown, but once accumulated,
!	they are packed into the exact amount of space they need in the Type
!	RST Entry.  Putting the component list in the same memory block as
!	the Type RST Entry also simplifies keeping reference counts and the
!	deallocation of RST entries.
!
!	This routine calls COPY_VARIANT_LIST which in turn calls this routine
!	recursively.  This recursion corresponds to the nesting of records and
!	variants in the DST.
!
! INPUTS
!	OLDPTR	- A pointer to the component list memory block to be copied.
!		  This memory block is released to the free memory pool after
!		  being copied.
!
!	TYPRSTLOC is an implicit input.  It specifies where the new copy should
!		  be placed in the Type RST Entry memory block.
!
! OUTPUTS
!	TYPRSTLOC is an implicit output.  It is updated to point to the next
!		  available location in the Type RST Entry memory block.
!
!	No value is returned.
!

    BEGIN

    MAP
	OLDPTR: REF VECTOR[,LONG];	! Pointer to the list to be copied

    LOCAL
	NEWPTR: REF VECTOR[,LONG],	! Pointer to the new copy of the list
	RPTR: REF RST$ENTRY;		! Pointer to component RST entry



    ! Allocate space for the new copy in the Data Type RST Entry.  Then copy the
    ! old list over to the new location.  Copy any Variant RST Entries into the
    ! Type RST Entry by calling COPY_VARIANT_LIST recursively.  Also change the
    ! kind of all data record components to RST$K_TYPCOMP and set their up-scope
    ! pointers to point to the Type RST Entry.
    !
    NEWPTR = .TYPRSTLOC;
    TYPRSTLOC = TYPRSTLOC[.OLDPTR[0] + 1];
    NEWPTR[0] = .OLDPTR[0];
    INCR I FROM 1 TO .OLDPTR[0] DO
	BEGIN
	RPTR = .OLDPTR[.I];
	IF .RPTR[RST$B_KIND] EQL RST$K_VARIANT
	THEN
	    RPTR = COPY_VARIANT_LIST(.RPTR)

	ELSE
	    BEGIN
	    RPTR[RST$B_KIND] = RST$K_TYPCOMP;
	    RPTR[RST$L_UPSCOPEPTR] = .TYPRSTPTR;
	    END;

	NEWPTR[.I] = .RPTR;
	END;


    ! Finally release the old component list back to the free memory pool and
    ! return to the caller.
    !
    DBG$REL_MEMORY(.OLDPTR);
    RETURN;

    END;

ROUTINE COPY_VARIANT_LIST(OLDRSTPTR) =
!
! FUNCTION
!	This routine copies a Variant RST Entry and the corresponding variant
!	set list from free-standing memory blocks into memory inside the current
!	Data Type RST Entry's memory block.  This is done so that the variant
!	set list can be grown dynamically while being accumulated, and still use
!	only just enough space in the final RST entry.
!
!	This routine is called only by COPY_COMP_LIST, which it also calls re-
!	cursively.
!
! INPUTS
!	OLDRSTPTR - A pointer to the Variant RST Entry to be copied into the
!		  Data Type RST Entry memory block.  This "old" RST entry and
!		  the associated component list are released back to the free
!		  memory pool.
!
! OUTPUTS
!	A pointer to the new copy of the Variant RST Entry is returned as the
!		  routine value.  This copy is located within the current
!		  Data Type RST Entry.
!

    BEGIN

    MAP
	OLDRSTPTR: REF RST$ENTRY;	! Pointer to Variant RST Entry to copy

    LOCAL
	NEWPTR: REF VECTOR[,LONG],	! Pointer to new variant set table
	NEWRSTPTR: REF RST$ENTRY,	! Pointer to the new Variant RST Entry
	OLDPTR: REF VECTOR[,LONG];	! Pointer to "old" variant set list



    ! Allocate space in the current Data Type RST Entry for the new Variant RST
    ! Entry and its component list.
    !
    OLDPTR = .OLDRSTPTR[RST$L_SYMCHNPTR];
    NEWRSTPTR = .TYPRSTLOC;
    TYPRSTLOC = TYPRSTLOC[RST$K_VARENTSIZ + .OLDPTR[0]/2];
    NEWPTR = NEWRSTPTR[RST$A_VARSETTBL];


    ! Fill in the fields in the Variant RST Entry.
    !
    NEWRSTPTR[RST$L_HASH_FLINK] = .NEWRSTPTR;
    NEWRSTPTR[RST$L_HASH_BLINK] = .NEWRSTPTR;
    NEWRSTPTR[RST$L_SYMCHNPTR] = 0;
    NEWRSTPTR[RST$L_DSTPTR] = .OLDRSTPTR[RST$L_DSTPTR];
    NEWRSTPTR[RST$L_VARTAGPTR] = .OLDRSTPTR[RST$L_VARTAGPTR];
    NEWRSTPTR[RST$B_KIND] = RST$K_VARIANT;
    NEWRSTPTR[RST$W_REFCOUNT] = 0;


    ! Copy the variant set component list (which points to the tag value DST
    ! record and the variant component list for each variant in the set) over
    ! to the new Variant RST Entry in the current Type RST Entry's memory
    ! block.  Note that we call COPY_COMP_LIST which may recursively call this
    ! routine again.
    !
    NEWRSTPTR[RST$L_VARSETCNT] = .OLDPTR[0]/2;
    INCR I FROM 1 TO .OLDPTR[0]/2 DO
	BEGIN
	NEWPTR[.I - 1] = .TYPRSTLOC;
	TYPRSTLOC[0] = .OLDPTR[2*.I - 1];
	TYPRSTLOC = TYPRSTLOC[1];
	COPY_COMP_LIST(.OLDPTR[2*.I]);
	END;


    ! Finally release the old variant RST entry and component list memory blocks
    ! back to the memory pool.  Return the address of the new Variant RST Entry
    ! to the caller.
    !
    DBG$REL_MEMORY(.OLDRSTPTR);
    DBG$REL_MEMORY(.OLDPTR);
    RETURN .NEWRSTPTR;

    END;

ROUTINE COMP_LIST_ADD_ENTRY(COMP_LST_PTR, COMP_LST_SIZE, VALUE): NOVALUE =
!
! FUNCTION
!	This routine adds an entry to a "component list".  Such a list consists
!	of a memory block whose first longword contains a count giving the num-
!	ber of entries on the list.  The longwords that follow contain the list
!	elements, one per longword.  This routine increments the count and ap-
!	pends the new component value to the list.  If this would cause the list
!	memory block to overflow, a new, larger block is allocated and the list
!	is copied to that block before the new value is appended.
!
! INPUTS
!	COMP_LST_PTR - The address of the pointer to the component list memory
!		  block to which the new value should be appended.
!
!	COMP_LST_SIZE - The address of the location giving the number of list
!		  components the memory block can hold.  This is one less than
!		  the size of the list memory block in longwords.
!
!	VALUE	- The value to be appended at the end of the component list.
!
! OUTPUTS
!	COMP_LST_PTR - If a new memory block had to be allocated to accommodate
!		  the new list entry, the address of that new memory block is
!		  returned to COMP_LST_PTR.  The old block is deallocated.
!
!	COMP_LST_SIZE - If a new memory block had to be allocated to accommodate
!		  the new list entry, the number of list entries the new memory
!		  block can hold is returned to COMP_LST_SIZE.
!

    BEGIN

    MAP
	COMP_LST_PTR: REF VECTOR[1],	! Pointer to pointer to component list
	COMP_LST_SIZE: REF VECTOR[1];	! Pointer to size of component list

    LOCAL
	LISTPTR: REF VECTOR[,LONG],	! Pointer to component list
	NEWPTR;				! Pointer to new memory block for list



    ! If the component list memory block is about to overflow, get a new,
    ! larger memory block and copy the contents of the old block into the
    ! new block.  Then release the old block to the free memory pool.
    !
    LISTPTR = .COMP_LST_PTR[0];
    IF .LISTPTR[0] EQL .COMP_LST_SIZE[0]
    THEN
	BEGIN
	NEWPTR = DBG$GET_MEMORY(.COMP_LST_SIZE[0] + 11);
	CH$MOVE(4*(.LISTPTR[0] + 1), .LISTPTR, .NEWPTR);
	COMP_LST_PTR[0] = .NEWPTR;
	COMP_LST_SIZE[0] = .COMP_LST_SIZE[0] + 10;
	DBG$REL_MEMORY(.LISTPTR);
	LISTPTR = .NEWPTR;
	END;


    ! Append the new value at the end of the component list vector.
    !
    LISTPTR[0] = .LISTPTR[0] + 1;
    LISTPTR[.LISTPTR[0]] = .VALUE;
    RETURN;

    END;

ROUTINE GET_MEM(LENGTH) =
!
! FUNCTION
!	This routine gets a memory block of a specified size from the free mem-
!	ory pool.  If there is no memory left in the pool, it expands the free
!	memory pool via DBG$EXPAND_MEMORY (which gets more space from the system
!	via $EXPREG).  It then gets the desired block from the expanded pool.
!	If the expansion fails for some reason, zero is returned instead of a
!	block address.
!
!	This routine is used only during Run-Time Symbol Table initialization.
!	After that, the free memory pool is not allowed to expand into the user
!	address space because that could cause DEBUG space and user space to
!	become checkerboarded.  That would make it more likely that the Debugger
!	could interfere with the behavior of the user program being debugged.
!
! INPUTS
!	LENGTH	- The length in longwords of the desired memory block.
!
! OUTPUTS
!	The start address of the returned memory block is returned as the value
!	of GET_MEM.  If no memory could be found, an error is signalled.
!

    BEGIN

    LOCAL
	ADDRESS,			! Pointer to the allocated memory block
	STATUS: BLOCK[1,LONG];		! Status code from DBG$EXPAND_MEMORY



    ! Get the desired memory block from DBG$GET_MEMORY.  If that succeeds,
    ! simply return the block's address right away.
    !
    ADDRESS = DBG$GET_MEMORY(.LENGTH, 0);
    IF .ADDRESS NEQ 0 THEN RETURN .ADDRESS;


    ! If we could not get any memory, try to expand the memory pool.  If that
    ! fails, signal an error message (no free memory).
    !
    STATUS = DBG$EXPAND_MEMORY(MAX(16384 - 3, .LENGTH + 1));
    IF NOT .STATUS THEN SIGNAL(DBG$_NOFREE);


    ! The memory pool was successfully expanded.  Now allocate the block we
    ! desire--this time it is guaranteed to work.
    !
    RETURN DBG$GET_MEMORY(.LENGTH);

    END;

ROUTINE GET_MOD_RST(MODNAMEPTR, LENGTH) =
!
! FUNCTION
!	This routine looks up a specified module name in the RST and returns a
!	pointer to the corresponding Module RST Entry.
!
! INPUTS
!	MODNAMEPTR - A pointer to the first character of the ASCII string con-
!		  taining the desired module's name.
!
!	LENGTH	- The length of the module name in characters.
!
! OUTPUTS
!	A pointer to the specified module's Module RST Entry is returned as the
!		  routine's value.  If no such routine exists in the RST, a zero
!		  is returned instead.
!

    BEGIN

    LOCAL
	DSTNAME: REF VECTOR[,BYTE],	! Pointer to the current module's name
					!      in the DST (as Counted ASCII)
	RSTPTR: REF RST$ENTRY;		! A pointer to the current Module RST
					!      Entry



    ! Search the RST Module Chain for a module with the specified name.  If we
    ! find such a module, exit the search loop with RSTPTR pointing to the
    ! desired Module RST Entry.  If we exhaust the loop, RSTPTR is zero.  In
    ! either case, return whatever value RSTPTR has.
    !
    RSTPTR = .RST$START_ADDR;
    WHILE .RSTPTR NEQ 0 DO
	BEGIN
	IF NOT .RSTPTR[RST$V_ANONMOD]
	THEN
	    BEGIN
	    DSTNAME = DBG$GET_DST_NAME(.RSTPTR[RST$L_DSTPTR]);
	    IF CH$EQL(.DSTNAME[0], DSTNAME[1], .LENGTH, .MODNAMEPTR, 0)
	    THEN
		EXITLOOP;

	    END;

	RSTPTR = .RSTPTR[RST$L_NXTMODPTR];
	END;

    RETURN .RSTPTR;

    END;

ROUTINE GET_TYPEPTR(DATA_DSTPTR, MODNAMEPTR, TYPE_DSTPTR, ARRAY_FLAG): NOVALUE =
!
! FUNCTION
!	This routine determines whether a given data item is of a record type or
!	an enumeration type, and if so, what the address is of the DST record
!	which defines that type (the Record Begin or Enumeration Type Begin DST
!	record).  The routine is called during the RST build procedure so that
!	the RST$L_TYPEPTR field can be filled in for record and enumeration type
!	data items.
!
!	If the given data item is of an array type, this routine determines if
!	the array's cell type is a record data type.  If so, the address of the
!	cell type's Record Begin DST record is returned and TRUE is returned to
!	the ARRAY_FLAG parameter.  This information allows the RST build proce-
!	dure to build the record type's Type RST Entry so that it has a refer-
!	ence pointer to the array's Data RST Entry.  This information is later
!	used by the DBG$STA_GETSYMBOL routine during symbol lookup.
!
! INPUTS
!	DATA_DSTPTR - A pointer to the data item DST record whose type is to be
!		  determined.
!
!	MODNAMEPTR - A pointer to the current module's name as Counted ASCII.
!		  This is used only for error messages.
!
!	TYPE_DSTPTR - A pointer to a longword location to receive a pointer
!		  to a Record Begin or Enumeration Type Begin DST record.
!
!	ARRAY_FLAG - A pointer to a longword location to receive the array
!		  flag returned by this routine.
!
! OUTPUTS
!	TYPE_DSTPTR - If the data item is an object of a record or enumeration
!		  data type, the address of the corresponding Record Begin or
!		  Enumeration Type Begin DST record is returned to TYPE_DSTPTR.
!		  If the data item is an array whose cell type is a record data
!		  type, the address of the cell type's Record Begin DST record
!		  is returned to TYPE_DSTPTR.  In all other cases, zero is re-
!		  turned to TYPE_DSTPTR.
!
!	ARRAY_FLAG - If the data item is an array whose cell type is a record
!		  data type, TRUE is returned to ARRAY_FLAG.  Otherwise, FALSE
!		  is returned to ARRAY_FLAG.
!
!	No value is returned.
!

    BEGIN

    MAP
	TYPE_DSTPTR: REF VECTOR[1],	! Pointer to Type DST pointer longword
	ARRAY_FLAG: REF VECTOR[1];	! Pointer to array flag longword

    LOCAL
	DSTPTR: REF DST$RECORD,		! Pointer to the current DST record
	FBPTR: REF BITVECTOR[],		! Pointer to Array Type Spec flag bits
	LOCAL_ARRAY_FLAG,		! Set to TRUE if data item is an array
	TSPTR: REF DST$TYPE_SPEC,	! Pointer to a DST Type Spec
	VSPTR: REF DST$VAL_SPEC;	! Pointer to the descriptor Value Spec
					!      in an Array Type Spec



    ! Initially we clear both output parameters.
    !
    TYPE_DSTPTR[0] = 0;
    ARRAY_FLAG[0] = FALSE;


    ! Unless the data item is a DST$K_SEPTYP DST record, it cannot point to a
    ! record or enumeration type definition, so we return immediately.
    !
    DSTPTR = .DATA_DSTPTR;
    IF .DSTPTR[DST$B_TYPE] NEQ DST$K_SEPTYP THEN RETURN;


    ! Advance DSTPTR past the DST$K_SEPTYP record.  If the next record is a
    ! Global-is-Next record, skip past that too to get to the record
    ! defining the data type.
    !
!    DSTPTR = DSTPTR[DST$A_NEXT] + .DSTPTR[DST$B_LENGTH];			! D015
    DSTPTR = DBG$RST_NEXT_DST( .DSTPTR );					
    IF .DSTPTR[DST$B_TYPE] EQL DST$K_GLOBNXT
    THEN
!	DSTPTR = DSTPTR[DST$A_NEXT] + .DSTPTR[DST$B_LENGTH];			! D015
	DSTPTR = DBG$RST_NEXT_DST( .DSTPTR );					


    ! Loop through any Type Spec indirection in the DST so we can get to the
    ! ultimate type specification for the data item.
    !
    LOCAL_ARRAY_FLAG = FALSE;
    WHILE TRUE DO
	BEGIN


	! If we have now gotten to a Record Begin or Enumeration Type Begin DST
	! record, we exit the indirection loop and return a pointer to that DST
	! record to TYPE_DSTPTR.
	!
	IF .DSTPTR[DST$B_TYPE] EQL DST$K_RECBEG THEN EXITLOOP;
	IF .DSTPTR[DST$B_TYPE] EQL DST$K_ENUMBEG
	THEN
	    BEGIN
	    IF .LOCAL_ARRAY_FLAG THEN RETURN;
	    EXITLOOP;
	    END;


	! If DSTPTR points to anything other than a Record Begin, Enumeration
	! Type Begin, or Type Spec DST record, there is an error in the DST.
	!
	IF .DSTPTR[DST$B_TYPE] NEQ DST$K_TYPSPEC
	THEN
	    SIGNAL(DBG$_INCDSTNES, 1, .MODNAMEPTR);


	! This is a Type Spec DST record.  Loop through any nested cell types
	! in Array Type Specs until we get to an Indirect Type Spec or a Novel
	! Length Type Spec (which also indirects).  If we get to an Indirect
	! or Novel Length Type Spec, we pick up the new DST pointer and con-
	! tinue the outer loop; otherwise we return a zero to TYPE_DSTPTR.
	!
	TSPTR = DSTPTR[DST$A_TYPSPEC_TS_ADDR] + .DSTPTR[DST$B_TYPSPEC_NAME];
	WHILE TRUE DO
	    BEGIN


	    ! If this is an Indirect Type Spec, get the new DST pointer and
	    ! continue the outer loop.
	    !
	    IF .TSPTR[DST$B_TS_KIND] EQL DST$K_TS_IND
	    THEN
		BEGIN
		DSTPTR = DBG$RST_DST_PTR( .TSPTR[DST$L_TS_IND_PTR] + .DST$BEGIN_ADDR );					! M015
		EXITLOOP;
		END


	    ! If this is a Novel Length Type Spec, do the same thing.
	    !
	    ELSE IF .TSPTR[DST$B_TS_KIND] EQL DST$K_TS_NOV_LENG
	    THEN
		BEGIN
		DSTPTR = DBG$RST_DST_PTR( .TSPTR[DST$L_TS_NOV_LENG_PAR_TSPEC] + .DST$BEGIN_ADDR );			! M015
		EXITLOOP;
		END


	    ! If this is an Array Type Spec, set the array flag and determine
	    ! whether the cell type can be a record type.  If not, return zero
	    ! to TYPE_DSTPTR.  Otherwise, get the pointer to the cell type Type
	    ! Spec and continue the inner loop.
	    !
	    ELSE IF .TSPTR[DST$B_TS_KIND] EQL DST$K_TS_ARRAY
	    THEN
		BEGIN
		LOCAL_ARRAY_FLAG = TRUE;
		FBPTR = TSPTR[DST$A_TS_ARRAY_FLAGS_ADDR];
		IF NOT .FBPTR[0] THEN RETURN;
		VSPTR = .FBPTR + (.TSPTR[DST$B_TS_ARRAY_DIM] + 8)/8;
		IF .VSPTR[DST$B_VS_VFLAGS] EQL DST$K_VS_FOLLOWS
		THEN
		    TSPTR = VSPTR[DST$B_VS_ALLOC] + .VSPTR[DST$W_VS_LENGTH]

		ELSE
		    TSPTR = VSPTR[DST$A_VS_TVS_BASE];

		END


	    ! For any other kind of Type Spec, it is not possible to reach a
	    ! Record Begin or Enumeration Type Begin DST record so we return
	    ! zero to TYPE_DSTPTR.
	    !
	    ELSE
		RETURN;

	    END;			! End of inner cell type loop

	END;				! End of outer indirection loop


    ! We found a Record or Enumeration Type type specification.  Return a
    ! pointer to the corresponding DST record and return the array flag value.
    !
    TYPE_DSTPTR[0] = .DSTPTR;
    IF .DSTPTR NEQ 0 THEN ARRAY_FLAG[0] = .LOCAL_ARRAY_FLAG;
    RETURN;

    END;

ROUTINE MERGE_CONTINUATION_DST(PASSED_DSTPTR, PASSED_NEXT_DSTPTR) =
!
! FUNCTION
!	Given a DST pointer, this routine scans ahead in the DST to see
!	if there are continuation records following this DST record.
!	If so, we merge all of these into a single DST record which
!	is allocated from DEBUG's memory pool.
!
!	It returns TRUE if it encountered a continuation record.
!
!	The two parameters are in-out parameters in which we return
!	the virtual address of the merged DST record and the
!	virtual address of the next DST record. If there were no
!	continuation records then the address in PASSED_DSTPTR 
!	is left unchanged.
!
!	It assumes that it has been given a DST pointer within the
!	mapped in DST, not a moved DST record.
!
! INPUTS
!	PASSED_DSTPTR - Pointer to a DST record passed by reference.
!
!	PASSED_NEXT_DSTPTR - Output parameter in which we fill in
!		the address of the next DST record, after reading
!		past any continuation records.
!
! OUTPUTS
!	If there are continuation records, a block of memory large
!	enough to hold the merged record is allocated, and the
!	appropriate bytes are copied into this block. A pointer to
!	this newly constructed DST record is returned in the in-out
!	parameter PASSED_DSTPTR.
!
!	If there are not any continuation records the passed DST pointer
!	is returned in PASSED_DSTPTR.
!
!	In any case the next DST pointer is calculated and returned in
!	PASSED_NEXT_DSTPTR.
!
!	The routine value is TRUE or FALSE, for whether any continuation
!	records were seen.
!

    BEGIN

    MAP
	PASSED_DSTPTR: REF VECTOR[1],	  ! Explained in routine header above
	PASSED_NEXT_DSTPTR: REF VECTOR[1];! Explained in routine header above

    LOCAL
	CONTINUATION_FLAG:		! Did we see a continuation
			INITIAL(FALSE),	!      record?
	DSTPTR: REF DST$RECORD,		! The current DST pointer
	MOVED_DST_ENTRY: REF MDE$RECORD,! Pointer to a Moved DST entry
	NEW_DSTPTR,			! New DST record under construction
    	NEW_LENGTH,			! Size of new DST record
        NEXT_DSTPTR: REF DST$RECORD,	! Pointer to new DST record
    	NEXT_LEN,			! Length of next DST record
	TEMP_PTR;			! Temporary pointer to new DST record



    ! Because it is easy to be off by +1 or -1 when copying bytes around,
    ! I'll explain the algorithm in detail using pictures.
    !
    ! Here is our situation at the start of the loop:
    ! X = .DSTPTR[DST$B_LENGTH]
    ! Y = .NEXT_DSTPTR[DST$B_LENGTH]
    !
    !	+---------------+	^	<--- "DSTPTR" in code below
    !	| count = X	|	|
    !	+---------------+   "NEW_LENGTH" in code below
    !	|  X bytes	|	|
    !	|    ...	|	|
    !	+---------------+	v	<-- "NEXT_DSTPTR" in code below
    !   | count = Y	|
    !	+---------------+
    !	| CONTIN code	|
    !	+---------------+	^
    !	|  Y-1 bytes	|   "NEXT_LEN" in code below
    !	|    ...	|	|
    !	+---------------+	v
    !
    ! Here is our situation after one or more times around the loop:
    !
    ! This is the DST in temporary memory that we've built so far:
    !
    !	+---------------+	^	<--- "DSTPTR" in code below
    !	| count byte	|	|
    !	+---------------+   "NEW_LENGTH" in code below
    !	|  X bytes	|	|
    !	|    ...	|	|
    !	+---------------+	v
    !
    ! This is where we are in the original DST:
    !
    !	+---------------+  <-- "NEXT_DSTPTR" in code below
    !   | count = Y	|
    !	+---------------+
    !	| CONTIN code	|
    !	+---------------+	^
    !	|  Y-1 bytes	|   "NEXT_LEN" in code below
    !	|    ...	|	|
    !	+---------------+	v
    !
    ! "NEW_LENGTH" always represents the length in bytes (including the
    ! count byte) of the DST record we have built so far out of temporary
    ! memory. This implies that NEW_LENGTH is X+1 at the start of the loop.
    ! "NEXT_LEN" always represents the amount of bytes we are going to
    ! append on to the DST record we are building. This is always Y-1 bytes.
    ! NEW_LENGTH is thus incremented by NEXT_LEN each time around the loop.
    !
    DSTPTR = .PASSED_DSTPTR[0];
    NEW_LENGTH = .DSTPTR[DST$B_LENGTH] + 1;
    NEXT_DSTPTR = DSTPTR[DST$A_NEXT] + .DSTPTR[DST$B_LENGTH];
    WHILE .NEXT_DSTPTR[DST$B_TYPE] EQL DST$K_CONTIN DO
    	BEGIN


    	! Compute the new size and allocate enough memory for a merged record.
	!
    	NEXT_LEN = .NEXT_DSTPTR[DST$B_LENGTH] - 1;
    	NEW_LENGTH = .NEW_LENGTH + .NEXT_LEN;
    	NEW_DSTPTR = DBG$GET_TEMPMEM((.NEW_LENGTH + 3)/4);


    	! Move the bytes into the merged record.
	!
    	TEMP_PTR = CH$MOVE(.NEW_LENGTH - .NEXT_LEN, .DSTPTR, .NEW_DSTPTR);
    	CH$MOVE(.NEXT_LEN, .NEXT_DSTPTR + 2, .TEMP_PTR);


	! Move the new DST pointer into place.
	!
    	DSTPTR = .NEW_DSTPTR;


	! Set the continued flag.
	!
	CONTINUATION_FLAG = TRUE;


    	! Try another.
	!
    	NEXT_DSTPTR = NEXT_DSTPTR[DST$A_NEXT] + .NEXT_DSTPTR[DST$B_LENGTH];
    	END;


    ! When there was a continuation record
    !    1	We move the record to permanent memory and
    !    	release the temporary memory
    !    2	Add an entry to the moved DST list
    !
    IF (.CONTINUATION_FLAG)
    THEN
	BEGIN
	IF ((.DSTPTR[DST$B_TYPE] EQL DST$K_VARVAL)  	OR
	    (.DSTPTR[DST$B_TYPE] EQL DST$K_BOOL)	OR
	    (.DSTPTR[DST$B_TYPE] EQL DST$K_SEPTYP)	OR
	    (.DSTPTR[DST$B_TYPE] EQL DST$K_ENUMELT)	OR
	    (.DSTPTR[DST$B_TYPE] EQL DST$K_VARBEG)	OR
	    (.DSTPTR[DST$B_TYPE] EQL DST$K_RECBEG)	OR
	    (.DSTPTR[DST$B_TYPE] EQL DST$K_TYPSPEC)	OR
	    (.DSTPTR[DST$B_TYPE] EQL DST$K_LBLORLIT)	OR
	    (.DSTPTR[DST$B_TYPE] EQL DST$K_LABEL)	OR
	    (.DSTPTR[DST$B_TYPE] EQL DST$K_OVERLOAD))
	THEN
	    BEGIN


	    ! Move the record to permanent memory and release the memory.
	    !
	    TEMP_PTR = DBG$GET_MEMORY( (.NEW_LENGTH + 3)/4 );
	    CH$MOVE(.NEW_LENGTH, .DSTPTR, .TEMP_PTR);
	    DSTPTR = .TEMP_PTR;


	    ! Get and load the new Moved DST Entry.
	    !
	    MOVED_DST_ENTRY = DBG$GET_MEMORY(MDE$K_LENGTH);
	    MOVED_DST_ENTRY[ MDE$L_ORIGINAL_DSTPTR ] = .PASSED_DSTPTR[0];
	    MOVED_DST_ENTRY[ MDE$L_REAL_DSTPTR     ] = .DSTPTR;
	    MOVED_DST_ENTRY[ MDE$L_NEXT_DSTPTR     ] = .NEXT_DSTPTR;
	    MOVED_DST_ENTRY[ MDE$L_REAL_LENGTH     ] = .NEW_LENGTH;


	    ! Link it up.
	    !
	    MOVED_DST_ENTRY[MDE$L_FLINK] = .DBG$GL_MOVED_DST_LIST_HEAD;
	    DBG$GL_MOVED_DST_LIST_HEAD = .MOVED_DST_ENTRY;
	    END

	ELSE
	    $DBG_ERROR('RSTCNTRL\MERGE_CONTINUATION_DST');

	END;


    ! Return the values.
    !
    PASSED_DSTPTR[0] = .DSTPTR;
    PASSED_NEXT_DSTPTR[0] = .NEXT_DSTPTR;
    RETURN .CONTINUATION_FLAG;

    END;

ROUTINE POSITION_GST(GST_REC_FLAG) =
!
! FUNCTION
!	This routine positions the GST at the start of the GST or at the next
!	sequential record, depending on the input parameter.  It expects the
!	OWN variable GST$BEGIN_ADDR to contain the address of the first GST
!	record and it expects GST$NEXT_ADDR to point to the "current" GST
!	record.  GST$NEXT_ADDR is updated by this routine as the "next sequen-
!	tial record" is updated.  The routine returns the address of the record
!	to which GST$NEXT_ADDR is then pointing as its value.
!
! INPUTS
!	GST_REC_FLAG - If this flag is non-zero, the GST is repositioned to its
!		  first record and the address of that record is returned as
!		  the routine value.  If this flag is zero, the address of the
!		  next sequential GST record is returned as the routine value.
!
! OUTPUTS
!	If GST_REC_FLAG is non-zero, the address of the first record in the GST
!		  is returned as the routine value.  If GST_REC_FLAG is zero,
!		  the address of the next sequential GST record is returned as
!		  the routine value.  If there is no next sequential GST record,
!		  zero is returned as the routine value.
!

    BEGIN

    OWN
	RECORDS_LEFT;				! Number of GST left

    LOCAL
	BLOCK_ADDR,				! GST address
	GST_NEXT_ADDR: REF VECTOR[,WORD];	! Virtual Address of next GST



    ! If there is no mapped GST, signal error.
    !
    IF (.GST$BEGIN_ADDR LEQA 1) THEN SIGNAL(DBG$_INVGSTREC);


    ! Flag is cleared to indicate the pointer should be re-positioned to start.
    !
    IF NOT .GST_REC_FLAG
    THEN
	BEGIN
	GST$NEXT_ADDR = .GST$BEGIN_ADDR;
	RECORDS_LEFT  = .GST$REC_COUNT;
	END;


    ! Stop the following from faulting if some caller ignores the end condition
    ! and effectively causes us to 'run off the end' of the mapped GST.
    !
    IF (.RECORDS_LEFT LSS 1) THEN RETURN (0);


    ! Pick up the address of the current record, and update the pointer to the
    ! subsequent one.
    !
    BLOCK_ADDR = .GST$NEXT_ADDR + 2;
    GST_NEXT_ADDR = .GST$NEXT_ADDR;
    GST$NEXT_ADDR = .GST$NEXT_ADDR + 2 + ((.GST_NEXT_ADDR[0] +1)/2)*2;
    RECORDS_LEFT = .RECORDS_LEFT - 1;
    RETURN (.BLOCK_ADDR);

    END;

ROUTINE READ_DEBUG_MODULE_TABLE(IMGFILCHAN, IMG_DST_BLOCK, EST_RST_SIZE) =
!
! FUNCTION
!	This routine reads in the Debug Module Table (the DMT) that the linker
!	puts in the executable image and uses this table to initialize the Run-
!	Time Symbol Table (the RST).  This table exists in images built by the
!	VMS V4.0 and later linkers, and does not exist in images built by ear-
!	lier linkers.  The advantage of this table is that it allows us to
!	initialize the RST very rapidly compared to making a complete scan of
!	the Debug Symbol Table (the DST), which must otherwise be done.
!
!	The initialization takes place as follows: First the DMT is mapped into
!	virtual memory.  Then the whole DMT is scanned, and for each DMT entry,
!	a Module RST Entry is built.  The Module's DST pointer is retrieved
!	directly from the DMT entry and the module size (i.e., the amount of
!	Run-Time Symbol Table space it would require if SET) is computed by
!	taking the size of the module's DST (as given by the DMT entry) and
!	multiplying it by a scale factor which yields a rough approximation to
!	the actual RST size.  The estimated RST sizes of the MIN_MODS_IN_RST
!	largest modules are remembered in a table as the DMT scan proceeds.
!
!	The module language code is not set in the Module RST Entry at this
!	time.  This means that no access to the DST is necessary during initia-
!	lization which prevents any DST paging.  The initialization is thus
!	speeded up.  The language code is retrieved when the module is SET.
!
!	For each module represented in the DMT (and thus in the DST), the DMT
!	lists the addresses and lengths of all its PSECTs.  This information
!	is used to build the Program Static Address Table (SAT) during the DMT
!	scan.
!
!	At the end of the scan, the estimated total RST memory requirements of
!	the several largest modules is computed and returned to the caller.
!	This number is used by DBG$RST_INIT to determine the initial size of
!	the DEBUG memory pool.
!
! INPUTS
!	IMGFILCHAN - The executable image file channel number.  The image is
!		  already open on this channel; the DMT can thus be read on it.
!
!	IMG_DST_BLOCK - The address of the Image Header Symbol Information
!		  block which gives the locations (virtual blocks numbers) and
!		  sizes of the DST, the GST, and the DMT.  Here we use this
!		  block to get the DMT location and size.
!
!	EST_RST_SIZE - The address of a longword to receive the estimated number
!		  of longwords of symbol table space needed to hold the RST of
!		  the MIN_MODS_IN_RST largest modules.
!
! OUTPUTS
!	EST_RST_SIZE - The estimated number of longwords needed to hold the RST
!		  for the MIN_MODS_IN_RST largest modules in the image is re-
!		  turned to the EST_RST_SIZE location.  This number is estimated
!		  by multiplying the DST size of each module by a scale factor
!		  which roughly estimates the corresponding RST size.
!
!	If the RST was successfully initialized using the Debug Module Table,
!		  TRUE is returned as the routine value.  If the initialization
!		  failed for any reason, FALSE is returned so that the initial-
!		  ization can be tried the slow way by reading the DST.
!

    BEGIN

    MAP
	IMG_DST_BLOCK: REF IHS$ENTRY,	! Pointer to the DST/GST/DMT descriptor
					!      in the executable image header
	EST_RST_SIZE: REF VECTOR[1];	! Estimated RST size parameter

    LITERAL
	DST_TO_RST_FACTOR = 25;		! Scale factor (times 10) for convert-
					!      ing DST size to estimated RST
					!      size for current module

    LOCAL
	DMTPTR: REF VECTOR[,LONG],	! Pointer to current Debug Module Table
					!      location
	DMT_SIZE,			! The total size of the DMT in bytes
	DMT_START_ADDR,			! The start address of the DMT
	DSTPTR,				! Pointer to Module Begin DST Record
	EXE_SECBOUNDS: VECTOR[2,LONG],	! Map-section bounds descriptor for
					!      SYS$CRMPSC system service
	EXE_SECNAM_DESC: VECTOR[2,LONG],! Map-section name descriptor for the
					!      SYS$CRMPSC system service
	MOD_SIZE_TBL:			! Table giving the estimated RST sizes
		VECTOR[MIN_MODS_IN_RST],!      of the MIN_MODS_IN_RST largest
					!      modules in longwords.
	NPSECTS,			! Number of PSECTs in current module
	RSTPTR: REF RST$ENTRY,		! Pointer to current Module RST Entry
	RSTSIZE,			! The estimated RST size in longwords
					!      of current module's symbol table
	STATUS: BLOCK[1, LONG];		! The status returned by SYS$CRMPSC



    ! Check that there is a Debug Module Table (DMT) in this image.  If the
    ! DMT virtual block number or length is zero, there is none and we return
    ! FALSE to the caller.  This will happen if the user did not LINK/DEBUG.
    !
    EST_RST_SIZE[0] = 0;
    IF (.IMG_DST_BLOCK[IHS$L_DMTVBN] EQL 0) OR
       (.IMG_DST_BLOCK[IHS$L_DMTBYTES] EQL 0)
    THEN
	RETURN FALSE;


    ! Map the Debug Module Table (the DMT) into our virtual address space.
    ! After doing so, we set DMT_START_ADDR to point to this table.  We also
    ! set DMT_SIZE to contain its size in bytes.  If we are unable to map it
    ! in, we signal the bad status and return FALSE so that DBG$RST_INIT can
    ! initialize the RST the slow way by reading through the whole DST.
    !
    DMT_SIZE = .IMG_DST_BLOCK[IHS$L_DMTBYTES];
    EXE_SECBOUNDS[0] = 200;
    EXE_SECBOUNDS[1] = 1^30;
    EXE_SECNAM_DESC[0] = 3;
    EXE_SECNAM_DESC[1] = UPLIT BYTE(%ASCIC 'DMT');
    STATUS = SYS$CRMPSC(EXE_SECBOUNDS, EXE_SECBOUNDS, 0, SEC$M_EXPREG,
			EXE_SECNAM_DESC, 0, 0, .IMGFILCHAN,
			(.DMT_SIZE + 511)/512,
			.IMG_DST_BLOCK[IHS$L_DMTVBN], 0, 0);
    IF NOT .STATUS
    THEN
	BEGIN
	STATUS[STS$V_SEVERITY] = SYS$K_INFO;
	SIGNAL(.STATUS);
	RETURN FALSE;
	END;

    DMT_START_ADDR = .EXE_SECBOUNDS[0];


    ! Set up a table to keep track of the MIN_MODS_IN_RST largest modules in
    ! the DST.  Also initialize PREV_RST_PTR.
    !
    INCR I FROM 0 TO MIN_MODS_IN_RST - 1 DO
	MOD_SIZE_TBL[.I] = 0;

    PREV_RST_PTR = .RST$START_ADDR;


    ! Now loop through the Debug Module Table (the DMT) to get each module's
    ! Module Begin DST Record address, size, and static address ranges.
    !
    DMTPTR = .DMT_START_ADDR;
    WHILE .DMTPTR LSSA .DMT_START_ADDR + .DMT_SIZE DO
	BEGIN


	! Get the DST pointer from the current DMT entry and check that it
	! actually points to a Module Begin DST Record.  Note that if we go
	! past DST$END_ADDR and this is a Testable Debugger, we have reached
	! the DEBUG part of the DST so we simply exit the loop, having already
	! initialized the RST for the test program part of the image.
	!
	DSTPTR = .DST$BEGIN_ADDR + .DMTPTR[0];
	IF .DSTPTR LSSA .DST$BEGIN_ADDR
	THEN
	    BEGIN
	    SIGNAL(DBG$_INVDMTPTR);
	    RETURN FALSE;
	    END;

	IF .DSTPTR GEQA .DST$END_ADDR
	THEN
	    BEGIN
	    IF .DBG$GV_CONTROL[DBG$V_CONTROL_TDBG] THEN EXITLOOP;
	    SIGNAL(DBG$_INVDMTPTR);
	    RETURN FALSE;
	    END;


	! Build the Module RST Entry for the current module in the DMT.  Note
	! that the language code is not set: this saves us an access to the DST
	! and so prevents any DST paging during the RST initialization.  Also
	! link that RST entry into the RST Module Chain.
	!
	RSTPTR = GET_MEM(RST$K_MODENTSIZ);
	RSTPTR[RST$L_DSTPTR] = .DSTPTR;
	RSTPTR[RST$B_KIND] = RST$K_MODULE;
	RSTPTR[RST$B_LANGUAGE] = DBG$K_UNKNOWN;
	PREV_RST_PTR[RST$L_NXTMODPTR] = .RSTPTR;
	PREV_RST_PTR = .RSTPTR;


	! Compute the estimated RST size of this module from the actual DST size
	! as given by the DMT entry.  Store this size (in bytes) in the Module
	! RST Entry.  Then, if this RST size makes this one of the several larg-
	! est modules, enter it in MOD_SIZE_TBL.  Note that this table remains
	! sorted on module size (given in longwords), largest modules first.
	!
	RSTSIZE = (DST_TO_RST_FACTOR*.DMTPTR[1])/(10*%UPVAL);
	RSTPTR[RST$L_MODRSTSIZ] = .RSTSIZE*%UPVAL;
	INCR I FROM 0 TO MIN_MODS_IN_RST - 1 DO
	    BEGIN
	    IF .RSTSIZE GTR .MOD_SIZE_TBL[.I]
	    THEN
		BEGIN
		DECR J FROM MIN_MODS_IN_RST - 2 TO .I DO
		    MOD_SIZE_TBL[.J+1] = .MOD_SIZE_TBL[.J];

		MOD_SIZE_TBL[.I] = .RSTSIZE;
		EXITLOOP;
		END;

	    END;


	! Now loop through the PSECT entries for this module to build the
	! Program Static Address Table (SAT) entries for this module.
	!
	NPSECTS = .DMTPTR[2];
	DMTPTR = DMTPTR[3];
	INCR I FROM 1 TO .NPSECTS DO
	    BEGIN
	    IF .DMTPTR[1] GTR 0
	    THEN
		STATIC_ADDRESS(.DMTPTR[0], .DMTPTR[1],
					.RSTPTR, SAT$START_ADDR, FALSE);
	    DMTPTR = DMTPTR[2];
	    END;

	END;				! End of loop over the DMT


    ! We have now read through the entire Debug Module Table and built the
    ! corresponding RST Module Chain.  Return the estimated RST size (in long-
    ! words) for the MIN_MODS_IN_RST largest modules.
    !
    RSTSIZE = 0;
    INCR I FROM 0 TO MIN_MODS_IN_RST - 1 DO
	RSTSIZE = .RSTSIZE + .MOD_SIZE_TBL[.I];

    EST_RST_SIZE[0] = .RSTSIZE;


    ! Finally return successfully to the caller.
    !
    RETURN TRUE;

    END;

ROUTINE RST_BUILD_ERROR_HANDLER(SIGARG, MECHARG, ENBLARG) =
!
! FUNCTION
!	This routine is the error handler for DBG$RST_BUILD.  The only error
!	conditions it checks for are DBG$_NOFREE, i.e. running out of memory
!	while building the RST for some module, and DBG$_ABORTED, i.e. the user
!	entered Control-Y DEBUG to abort the current command.  When either of
!	these conditions occurs, this handler calls DBG$RST_REMOVE to release
!	all the RST space which was allocated during the attempt to build the
!	module's RST.  It then resignals the error.
!
! INPUTS
!	SIGARG	- The address of the signal argument vector.
!
!	MECHARG	- The address of the mechanism argument vector.
!
!	ENBLARG	- The address of the enable argument vector.
!
! OUTPUTS
!	The error is always resignalled, meaning that SS$_RESIGNAL is returned
!		  as the routine value.
!

    BEGIN

    MAP
	SIGARG: REF VECTOR[,LONG];	! The signal argument vector

    LOCAL
	RSTPTR: REF RST$ENTRY;		! Pointer to the Module RST Entry


    ! If we ran out of memory or were aborted by Control-Y DEBUG, remove the
    ! partially built module from the RST.  Also, mark the module as being
    ! cancelled.  Then resignal the error.
    !
    IF (.SIGARG[1] EQL DBG$_NOFREE) OR (.SIGARG[1] EQL DBG$_ABORTED)
    THEN 
	BEGIN
	RSTPTR = .MOD_BEING_BUILT;
	RSTPTR[RST$V_MODSET] = FALSE;
	DBG$RST_REMOVE(.MOD_BEING_BUILT);
	END;

    RETURN SS$_RESIGNAL;

    END;

ROUTINE SHARED_IMAGE_NAMES(IMGFILCHAN): NOVALUE =
!
! FUNCTION
!
!	***** This routine is used for VMS 4.0 (3B) shareable image format *****
!
!	This routine goes through the list of image names in the current
!	execution and creates a Global Symbol for each such image name.
!	The images in the current execution include the user program, all
!	sharable images used by the user program, and even DEBUG itself.
!	For each image name xxx, this routine creates an RST entry for
!	the symbol SHARE$xxx, marks that RST entry as being a global symbol,
!	and attaches it to the global symbol chain off the anonymous module.
!	This is intended to be an aid to programmers debugging shared im-
!	ages since it provides a way of telling where a shared image starts.
!
!	The sharable image names and their addresses are gotten from the
!	Sharable Image Descriptor List Elements in the Image Descriptor Blocks
!	in P1 space.  The external symbol IAC$GL_IMAGE_LIST is used to access
!	the doubly linked list of Image Descriptor Blocks; it points to a
!	2 longword vector in which the 1st longword points to the first 
!	Descriptor Block on the list. Note - for FT2, a symbol called
!	SYS$GL_IMGLSTPTR was put in STARLET which we use instead of
!	IAC$GL_IMAGE_LIST.
!
!	The Image Descriptor Blocks do not contain duplicate entries for
!	the same sharable image.  This code assumes this is true, and no check
!	is done to validate it.
!
!	This routine also creates Module RST entry for each shareable
!	image.
!
! INPUTS
!	IMGFILCHAN - The channel that the image file is open on.
!
! OUTPUTS
!	NONE
!

    BEGIN

    LOCAL
    	DSTPTR: REF DST$RECORD,		! Pointer to Module DST pointer
	GBLNAME: VECTOR[		! Buffer in which we build the global
		IMDB$C_MAXNAMLNG+7,BYTE],!      symbol name "SHARE$xxx"
    	HEADER,
	IMDBPTR: REF BLOCK[,BYTE],	! Pointer to Image Descriptor Block
    	LENGTH,				! Length of the Module DST
	NAMEPTR: REF VECTOR[,BYTE],	! Pointer to shared image name "xxx"
	RSTPTR: REF RST$ENTRY;		! Pointer to duplicate RST entry


    ! Enable a handler that will catch any errors that might occur
    ! during this routine. This is mainly done as a defensive move
    ! in case the symbols IAC$GL_IMAGE_LIST or SYS$GL_IMGLSTPTR
    ! are incorrect or the data structures they point to are incorrect 
    ! (e.g., as a result of image activator changes). In that case, 
    ! we signal an informational to the effect that the SHARE$xxx names 
    ! were not available, but we do not want to abort the debugging session
    ! (which is what would happen without a handler).
    !
    ENABLE
    	SHARED_IMAGE_NAMES_HANDLER;


    ! Get the start address of the Image Descriptor Block list.  Then loop
    ! through this doubly linked list of Descriptor Blocks until we get to the 
    ! head of the list, and for each Descriptor Block, make global symbols for 
    ! any image entries in the block.
    !
    IF SYS$GL_IMGLSTPTR NEQ 0
    THEN
    	IMDBPTR = .SYS$GL_IMGLSTPTR
    ELSE IF IAC$GL_IMAGE_LIST NEQ 0
    THEN
        IMDBPTR = IAC$GL_IMAGE_LIST
    ELSE
    	SIGNAL(0);	! The handler will catch it.
    HEADER = .IMDBPTR;
    IMDBPTR = .IMDBPTR[IMDB$L_FLINK];
    WHILE .IMDBPTR NEQ .HEADER DO
	BEGIN


	! For each sharable image, create the corresponding global sym-
	! bol by prefixing the image name with "SHARE$".
	!
    	NAMEPTR = IMDBPTR[IMDB$T_IMAGE_NAME];
    	CH$MOVE(6, UPLIT BYTE(%ASCII 'SHARE$'), GBLNAME[1]);
	CH$MOVE(.NAMEPTR[0], NAMEPTR[1], GBLNAME[7]);
	GBLNAME[0] = .NAMEPTR[0] + 6;


    	! Create a Global symbol RST entry for the new symbol.
    	! Ignore the main user exe.
    	!
    	IF .IMDBPTR[IMDB$W_CHAN] NEQ .IMGFILCHAN
    	THEN
    	    BEGIN


    	    ! Enter this symbol into Global symbol chain.
    	    !
	    DBG$GST_TO_RST(.RST$START_ADDR, GBLNAME[0], 
    		.IMDBPTR[IMDB$L_STARTING_ADDRESS], FALSE);


    	    ! 1 byte of DST length, 1 byte of DST kind, 1 byte of
    	    ! MODBEG_UNUSED, 4 bytes of MODBEG_LANGUAGE, and a
    	    ! counted ASCIC string.
    	    !
    	    LENGTH = 1 + 1 + 1 + 4 + 1 + .GBLNAME[0];


    	    ! Create Module RST Entry in the module RST chain for this shareable
    	    ! image.
    	    !
    	    RSTPTR = GET_MEM(RST$K_SHARED_MODENTSIZ + (.LENGTH + 3) / %UPVAL);
    	    RSTPTR[RST$L_BASEVA] = .IMDBPTR[IMDB$L_STARTING_ADDRESS];
    	    RSTPTR[RST$B_IMGFILCHAN] = .IMDBPTR[IMDB$W_CHAN];
    	    RSTPTR[RST$V_SHARE_IMAGE] = 1;


    	    ! Create a dummy Module Begin DST record for the shareable image
    	    ! "module".
    	    !
    	    DSTPTR = .RSTPTR + %UPVAL * RST$K_SHARED_MODENTSIZ;
    	    DSTPTR[DST$B_LENGTH] = .LENGTH - 1;
    	    DSTPTR[DST$B_TYPE] = DST$K_MODBEG;
    	    DSTPTR[DST$L_MODBEG_LANGUAGE] = DBG$K_UNKNOWN;
    	    NAMEPTR = DSTPTR[DST$B_MODBEG_NAME];
    	    NAMEPTR[0] = .GBLNAME[0];
    	    CH$MOVE(.NAMEPTR[0], GBLNAME[1], NAMEPTR[1]);
    	    RSTPTR[RST$L_DSTPTR] = .DSTPTR;
    	    RSTPTR[RST$B_KIND] = RST$K_MODULE;
    	    RSTPTR[RST$B_LANGUAGE] = DBG$K_UNKNOWN;
    	    DBG$HASH_INSERT(.RSTPTR);


    	    ! Build the Program Static Address entry for this module.
    	    !
    	    LENGTH =
    		.IMDBPTR[IMDB$L_END_ADDRESS] - .IMDBPTR[IMDB$L_STARTING_ADDRESS] + 1;
    	    STATIC_ADDRESS(.RSTPTR[RST$L_BASEVA], .LENGTH, .RSTPTR,
    	   		SAT$START_ADDR, FALSE);


    	    ! Update the next module chain pointer.
    	    !
    	    PREV_RST_PTR[RST$L_NXTMODPTR] = .RSTPTR;
    	    PREV_RST_PTR = .RSTPTR;
    	    END;
    		    

	! Link to the next Image Descriptor Block and loop.
	!
	IMDBPTR = .IMDBPTR[IMDB$L_FLINK];
	END;


    ! We have now gone through all Descriptor Blocks.  Return to the caller.
    !
    RETURN;

    END;

ROUTINE SHARED_IMAGE_NAMES_HANDLER(SIGNAL_ARG_PTR: REF BLOCK[,BYTE]) =
!
! FUNCTION
!	
!	This routine is the error handler for the SHARED_IMAGE_NAMES
!	routine.
!
! 	An error handler is used as a defensive move
! 	in case the symbol IAC$GL_IMAGE_LIST is incorrect or the data
! 	structures it points to are incorrect (e.g., as a result of 
! 	image activator changes). In that case, we want to signal an
! 	informational to the effect that the SHARE$xxx names were not
! 	available, but we do not want to abort the debugging session
! 	(which is what would happen without a handler).
!
! INPUTS
!	SIGNAL_ARG_PTR points to the signal arguments for the exception.
!
! OUTPUTS
!	This routine unwinds the stack to the caller of SHARED_IMAGE_NAMES
!	and then returns SS$_CONTINUE.
!
    BEGIN


    ! If we get into this handler for the second time (because of
    ! the unwind), then resignal.
    !
    IF .SIGNAL_ARG_PTR[CHF$L_SIG_NAME] EQL SS$_UNWIND
    THEN
    	RETURN SS$_RESIGNAL;


    ! Put out an informational saying that the shared image names
    ! are not available. We fake the message since the final
    ! handler is not set up properly to accept a signal here.
    ! Only do this for V4.
    !
    IF .DBG$GV_CONTROL[DBG$V_CONTROL_VERSION_4]
    THEN
    	BEGIN
        DBG$PRINT(UPLIT BYTE(%ASCIC
    	    '%DEBUG-I-ERRSHRNAM, internal error during initialization, SHARE$ symbols not available'));
        DBG$NEWLINE();
    	END;


    ! Unwind the stack to the caller of SHARED_IMAGE_NAMES and then
    ! return SS$_CONTINUE. What this does is abort processing of
    ! SHARED_IMAGE_NAMES and allow the rest of DEBUG initialization
    ! to proceed.
    !
    SETUNWIND();
    RETURN SS$_CONTINUE;
    END;

ROUTINE SHARED_IMAGE_NAMES_V3(IMGFILCHAN): NOVALUE =
!
! FUNCTION
!
!	***** This routine is used for VMS 3.0 shareable image format *****
!
!	This routine goes through the list of image names in the current
!	execution and creates a Global Symbol for each such image name.
!	The images in the current execution include the user program, all
!	sharable images used by the user program, and even DEBUG itself.
!	For each image name xxx, this routine creates an RST entry for
!	the symbol SHARE$xxx, marks that RST entry as being a global symbol,
!	and attaches it to the global symbol chain off the anonymous module.
!	This is intended to be an aid to programmers debugging shared im-
!	ages since it provides a way of telling where a shared image starts.
!
!	The sharable image names and their addresses are gotten from the
!	Sharable Image List Elements in the Image Activator Fixup Blocks
!	in P1 space.  The external symbol SYS$GL_IAFLINK is used to access
!	the linked list of Image Activator Fixup Blocks; it points to a
!	pointer to the first Fixup Block on the list.
!
!	The Image Activator Fixup Blocks may contain duplicate entries for
!	the same sharable image.  This happens when two sharable images in
!	the execution reference a third image, for example--in this case
!	there are two entries for that third image.  This code assumes
!	that only the first such entry is valid and ignores all succeeding
!	duplicates.  If the image activator is ever changed to invalidate
!	this assumption, this routine could break.
!
!	This routine also creates Module RST entry for each shareable
!	image.
!
! INPUTS
!	IMGFILCHAN - The channel that the image file is open on.
!
! OUTPUTS
!	NONE
!

    BEGIN

    LOCAL
    	CHANNEL_NUMBER,			! The channel number that the image
    					!      file is open on
    	DSTPTR: REF DST$RECORD,		! Pointer to Module dst pointer
	GBLNAME: VECTOR[		! Buffer in which we build the global
		SHL$C_MAXNAMLNG+7,BYTE],!      symbol name "SHARE$xxx"
	IAFPTR: REF BLOCK[,BYTE],	! Pointer to Image Activator Fixup Block
    	LENGTH,				! Length of the Module DST
	NAMEPTR: REF VECTOR[,BYTE],	! Pointer to shared image name "xxx"
	RSTPTR: REF RST$ENTRY,		! Pointer to duplicate RST entry
	SHLPTR: REF BLOCKVECTOR[	! Pointer to Sharable Image List vector
		,SHL$K_LENGTH,BYTE];	!



    ! Enable a handler that will catch any errors that might occur
    ! during this routine. This is mainly done as a defensive move
    ! in case the symbol IAC$GL_IMAGE_LIST is incorrect or the data
    ! structures it points to are incorrect (e.g., as a result of 
    ! image activator changes). In that case, we want to signal an
    ! informational to the effect that the SHARE$xxx names were not
    ! available, but we do not want to abort the debugging session
    ! (which is what would happen without a handler).
    !
    ENABLE
    	SHARED_IMAGE_NAMES_HANDLER;


    ! Get the start address of the Image Activator Fixup Block list.  Then loop
    ! through this linked list of Fixup Blocks until we get to the end of the
    ! list, and for each Fixup Block, make global symbols for any image entries
    ! in the block.
    !
    IAFPTR = .SYS$GL_IAFLINK[0];
    WHILE .IAFPTR NEQ 0 DO
	BEGIN
	SHLPTR = .IAFPTR + .IAFPTR[IAF$L_SHLSTOFF];


	! Loop through the vector of Sharable Image List Elements in this Fixup
	! Block.  For each sharable image, create the corresponding global sym-
	! bol by prefixing the image name with "SHARE$".
	!
	INCR I FROM 0 TO .IAFPTR[IAF$L_SHRIMGCNT] - 1 DO
	    BEGIN


	    ! Create the new symbol name by prefixing SHARE$ to the image name.
	    !
	    NAMEPTR = SHLPTR[.I, SHL$T_IMGNAM];
	    CH$MOVE(6, UPLIT BYTE(%ASCII 'SHARE$'), GBLNAME[1]);
	    CH$MOVE(.NAMEPTR[0], NAMEPTR[1], GBLNAME[7]);
	    GBLNAME[0] = .NAMEPTR[0] + 6;


    	    ! Get the channel number, now the channel number is carried in
    	    ! the last byte of the shared image NAME.  This may change
    	    ! in the future.
    	    !
    	    CHANNEL_NUMBER = .NAMEPTR[30];


	    ! Determine whether we already have a Global symbol RST entry for
	    ! the SHARE$xxx symbol.  If so, this is a duplicate Fixup Block
	    ! entry and we ignore it.  Otherwise, create a Global symbol RST
	    ! entry for the new symbol.
	    !
	    DBG$HASH_FIND_SETUP(GBLNAME);
	    WHILE TRUE DO
		BEGIN
		RSTPTR = DBG$HASH_FIND(GBLNAME);
		IF .RSTPTR EQL 0
		THEN
		    BEGIN
    		    IF .CHANNEL_NUMBER NEQ .IMGFILCHAN
    		    THEN
    			BEGIN


    		    	! Enter this symbol into Global symbol chain.
    		    	!
		    	DBG$GST_TO_RST(.RST$START_ADDR, GBLNAME[0], .SHLPTR[.I,SHL$L_BASEVA], FALSE);


    		    	! Create module rst entry in the module rst chain.
    		    	!
    		        RSTPTR = GET_MEM(RST$K_SHARED_MODENTSIZ);
    			RSTPTR[RST$L_BASEVA] = .SHLPTR[.I, SHL$L_BASEVA];
    			RSTPTR[RST$B_IMGFILCHAN] = .CHANNEL_NUMBER;
    			RSTPTR[RST$V_SHARE_IMAGE] = 1;


    			! 1 byte of DST length, 1 byte of DST kind, 1 byte of
    			! MODBEG_UNUSED, 4 bytes of MODBEG_LANGUAGE, and
    			! counted ASCIC string.
    			!
    			LENGTH = 1 + 1 + 1 + 4 + 1 + .GBLNAME[0];
    			DSTPTR = DBG$GET_MEMORY((.LENGTH + 3) / 4);
    			DSTPTR[DST$B_LENGTH] = .LENGTH - 1;
    			DSTPTR[DST$B_TYPE] = DST$K_MODBEG;
    			DSTPTR[DST$L_MODBEG_LANGUAGE] = DBG$K_UNKNOWN;
    			NAMEPTR = DSTPTR[DST$B_MODBEG_NAME];
    			NAMEPTR[0] = .GBLNAME[0];
    			CH$MOVE(.NAMEPTR[0], GBLNAME[1], NAMEPTR[1]);
    			RSTPTR[RST$L_DSTPTR] = .DSTPTR;
    			RSTPTR[RST$B_KIND] = RST$K_MODULE;
    			RSTPTR[RST$B_LANGUAGE] = DBG$K_UNKNOWN;
    			DBG$HASH_INSERT(.RSTPTR);


    			! Build the Program Static Address entry for this
    			! module.
    			!
    			STATIC_ADDRESS(.RSTPTR[RST$L_BASEVA], 1, .RSTPTR,
    				SAT$START_ADDR, FALSE);


    			! Update the next module chain pointer.
    			!
    			PREV_RST_PTR[RST$L_NXTMODPTR] = .RSTPTR;
    			PREV_RST_PTR = .RSTPTR;
    			END;
    		    
		    EXITLOOP;
		    END;

		IF .RSTPTR[RST$V_GLOBAL] THEN EXITLOOP;
		END;

	    END;


	! Link to the next Image Activator Fixup Block and loop.
	!
	IAFPTR = .IAFPTR[IAF$L_IAFLINK];
	END;


    ! We have now gone through all Fixup Blocks.  Return to the caller.
    !
    RETURN;

    END;


ROUTINE STATIC_ADDRESS(STARTADDR, LENGTH, RSTPTR, SAT_CHAIN, MERGE_FLAG): NOVALUE =
!
! FUNCTION:
!	This routine constructs a Static Address Table (SAT) entry and inserts
!	it in the proper place in a specified SAT chain.  It accepts an address
!	range as input and searches the specified Static Address Table chain
!	until it finds the proper place to insert an entry for the new address
!	range.  The insertion is always done so that the SAT chain remains sort-
!	ed by start address.  If the MERGE_FLAG parameter is set, SAT entries
!	along the way whose address ranges overlap or adjoin the new address
!	range are removed from the SAT chain and their address ranges merged
!	with the new address range.
!
!	This routine is called during RST initialization, when a SAT chain is
!	built for each module in the DST.  These SAT chains are then merged (not
!	by this routine) to produce the Program Static Address Table which says
!	in which modules a given address can be found.  (An address may be found
!	in several modules--Fortran COMMON blocks cause this situation.)
!
!	This routine is also called when the RST and SAT for an individual mod-
!	ule is built.  In this case, the SAT is of course still sorted by start
!	address.  However, if two SAT entries have the same start address, they
!	are always sorted so that the larger end address comes first.  This
!	ordering is required by routine DBG$STA_SETCONTEXT which needs it to
!	determine when there are nested routines which overlap the address range
!	of an outer routine.  The ordering ensures that a nested routine always
!	follows an outer routine in the Module SAT.
!
! INPUTS:
!	STARTADDR - The start address of the address range to be inserted in the
!		  specified Static Address Table Chain.  If the Program Static
!		  Address Table is built from the Debug Module Table (DMT),
!		  STARTADDR contains the address SAT$START_ADDR, in which case
!		  GET_MEM is called to get SAT space instead of DBG$GET_MEMORY.
!
!	LENGTH	- The length in bytes of the STARTADDR address range.
!
!	RSTPTR	- The Run-Time Symbol Table (RST) pointer which specifies the
!		  symbol to which this address range belongs.  When the Program
!		  Static Address Table (which says which module covers which
!		  address range) is built, RSTPTR is zero.  Then GET_MEM is
!		  called to get SAT space instead of DBG$GET_MEMORY.
!
!	SAT_CHAIN - The address of a longword location which contains a pointer
!		  to the first entry on the Static Address Table chain being
!		  built.  If the chain is empty, this location contains a zero.
!
!	MERGE_FLAG - A flag which specifies whether SAT entries on the specified
!		  chain should be merged if their address ranges adjoin or over-
!		  lap.  The flag can have these two values:
!
!			TRUE  -- Merge SAT entries with adjoining or
!				 overlapping address ranges.
!			FALSE -- Do not merge such SAT entries.
!
! OUTPUTS:
!	SAT_CHAIN - A new SAT entry is added to the SAT_CHAIN chain.  Also, old
!		  entries whose address ranges can be merged with the new one
!		  are removed from the chain if MERGE_FLAG is set.  Either oper-
!		  ation can change the value at the SAT_CHAIN location.
!
!	No value is returned by STATIC_ADDRESS.
!

    BEGIN

    MAP
	RSTPTR: REF RST$ENTRY;		! Pointer to symbol's RST entry

    LOCAL
	ADDR1,				! The start address of the input address
					!      range, possibly as expanded by
					!      merging with existing SAT entries
	ADDR2,				! The end address of the input address
					!      range, possibly as expanded by
					!      merging with existing SAT entries
	OLDPTR: REF SAT$ENTRY,		! Pointer to the SAT entry just before
					!      the SATPTR entry in the SAT chain
	SATPTR: REF SAT$ENTRY;		! Pointer to the current SAT entry in
					!      the SAT chain.



    ! Compute the start and end addresses of the address range passed by the
    ! caller.  Also initialize the Static Address Table list pointers.
    !
    ADDR1 = .STARTADDR;
    IF .LENGTH LEQ 0
    THEN
	ADDR2 = .STARTADDR
    ELSE
	ADDR2 = .STARTADDR + .LENGTH - 1;

    OLDPTR = .SAT_CHAIN;
    SATPTR = .OLDPTR[SAT$L_FLINK];


    ! Loop through the entire Static Address Table linked list, looking to see
    ! where we should link in an entry for this static address range or merge
    ! it with existing SAT entries with overlapping address ranges.
    !
    WHILE .SATPTR NEQ 0 DO
	BEGIN


	! If this SAT entry's address range comes before the ADDR1 start address
	! we just link on to the next SAT entry.
	!
	IF .SATPTR[SAT$L_END] + 1 LSSU .ADDR1
	THEN
	    BEGIN
	    OLDPTR = .SATPTR;
	    SATPTR = .SATPTR[SAT$L_FLINK];
	    END


	! If this SAT entry's address range comes after the ADDR2 end address,
	! we have gone too far in the sorted SAT chain, so we exit the loop.
	!
	ELSE IF .ADDR2 + 1 LSSU .SATPTR[SAT$L_START]
	THEN
	    EXITLOOP


	! The current SAT entry's address range overlaps or adjoins the ADDR1 -
	! ADDR2 address range.  If merging of such address ranges is requested,
	! we compute the expanded address range (including both ranges) in ADDR1
	! and ADDR2 and delete the SAT entry from the SAT chain.  We then keep
	! searching the chain in case other SAT entries overlap the new range.
	!
	ELSE IF .MERGE_FLAG
	THEN
	    BEGIN
	    ADDR1 = MIN(.ADDR1, .SATPTR[SAT$L_START]);
	    ADDR2 = MAX(.ADDR2, .SATPTR[SAT$L_END]);
	    OLDPTR[SAT$L_FLINK] = .SATPTR[SAT$L_FLINK];
	    DBG$REL_MEMORY(.SATPTR);
	    SATPTR = .OLDPTR[SAT$L_FLINK];
	    END


	! The current SAT entry's address range overlaps the ADDR1 - ADDR2
	! address range, but merging address ranges is not allowed.  Exit the
	! loop if the ADDR1 start address is less than that in the SAT entry.
	! Also exit the loop if the ADDR1 start address equals that in the SAT
	! entry and the ADDR2 end address is greater than or equal to the SAT
	! entry's end address.  Otherwise, link to the next SAT entry.  This
	! ensures that the SAT chain will remain sorted on start address with
	! the larger end address first if two start addresses are the same.
	!
	ELSE IF (.ADDR1 LSSU .SATPTR[SAT$L_START]) OR
		(.ADDR1 EQLU .SATPTR[SAT$L_START] AND
		 .ADDR2 GEQU .SATPTR[SAT$L_END])
	THEN
	    EXITLOOP

	ELSE
	    BEGIN
	    OLDPTR = .SATPTR;
	    SATPTR = .SATPTR[SAT$L_FLINK];
	    END;

	END;				! End of WHILE loop


    ! Build a new SAT entry containing the ADDR1 - ADDR2 address range and link
    ! it into the SAT chain after the OLDPTR position.  Then return.
    !
    IF (.RSTPTR EQL 0) OR (.SAT_CHAIN EQL SAT$START_ADDR)
    THEN
	SATPTR = GET_MEM(SAT$K_ENTSIZE)

    ELSE
	SATPTR = DBG$GET_MEMORY(SAT$K_ENTSIZE);

    IF .SATPTR EQL 0 THEN RETURN;
    SATPTR[SAT$L_FLINK] = .OLDPTR[SAT$L_FLINK];
    SATPTR[SAT$L_START] = .ADDR1;
    SATPTR[SAT$L_END] = .ADDR2;
    SATPTR[SAT$L_RSTPTR] = .RSTPTR;
    OLDPTR[SAT$L_FLINK] = .SATPTR;


    ! If RSTPTR points to a Routine RST Entry, put a pointer in that RST entry
    ! to the SAT entry we just built.  This pointer is later used by routine
    ! DBG$STA_SETCONTEXT to find a routine's SAT entry.
    !
    IF .RSTPTR NEQ 0
    THEN
	BEGIN
	IF .RSTPTR[RST$B_KIND] EQL RST$K_ROUTINE
	THEN
	    RSTPTR[RST$L_RTNSATPTR] = .SATPTR;

	END;

    RETURN;

    END;

ROUTINE STATIC_CHECK(DSTPTR, ADDRESS, LENGTH, STATIC_FLAG): NOVALUE =
!
! FUNCTION
!	This routine determines whether a specified data item is static or not.
!	This is done by inspecting the data item's DST entry; the data object is
!	deemed to be static if the object's data address is specified directly
!	in the DST entry or if it is specified in a descriptor directly in the
!	DST entry.  Any use of registers or indirection in the address calcula-
!	tion disqualifies the data item from being deemed static.
!
!	If the data item is static, STATIC_FLAG is set to TRUE and the item's
!	start address and byte length is returned to the caller.  If the data
!	item is not static or if the DST entry is not even that of a data item,
!	STATIC_FLAG is set to FALSE and nothing else is returned.
!
! INPUTS
!	DSTPTR	- A pointer to the Debug Symbol Table (DST) entry of the data
!		  item in question.
!
!	ADDRESS	- The address of a longword location where the address of the
!		  static area is to be returned.
!
!	LENGTH	- The address of a longword location where the length of the
!		  static area is to be returned.
!
!	STATIC_FLAG - The address of a longword location where a flag should
!		  be returned saying whether the data item is static or not.
!
! OUTPUTS
!	ADDRESS	- If the data item is static, the start address of its static
!		  address range is returned to ADDRESS.
!
!	LENGTH	- If the data item is static, the length in bytes of its static
!		  address range is returned to LENGTH.
!
!	STATIC_FLAG - If the data item is static, STATIC_FLAG is set to TRUE;
!		  otherwise STATIC_FLAG is set to FALSE.
!

    BEGIN

    ENABLE
	STATIC_CHECK_HANDLER;

    MAP
	DSTPTR: REF DST$RECORD,		! Pointer to data item's DST record
	ADDRESS: REF VECTOR[1],		! Location where the static start
					!      address is returned
	LENGTH: REF VECTOR[1],		! Location where the length of the
					!      static area is returned
	STATIC_FLAG: REF VECTOR[1];	! Location where TRUE is returned if the
					!      data item is static--else FALSE

    BIND
	LENGTH_TBL = UPLIT BYTE(0, 1, 1,2,4,8, 1,2,4,8, 4,8,8,16,
				REP 11 OF (0), 16,16,8,16,16,32,
				12,8,8,0,0,0,0): VECTOR[,BYTE];
	%IF DSC$K_DTYPE_HIGHEST GTR 37	! If the LENGTH_TBL PLIT is too small,
	%THEN				!      generate a compile-time error
	    %ERROR('Error:  Must expand PLIT in Routine STATIC_CHECK')
	%FI;

    LOCAL
	BPTR1: REF DST$BLI_TRAILER1,	! Pointer to the Bliss special cases DST
					!      record first trailer
	BPTR2: REF DST$BLI_TRAILER2,	! Pointer to the Bliss special cases DST
					!      record second trailer
	DESCPTR: REF BLOCK[,BYTE];	! Pointer to VAX Standard Descriptor in
					!      the DST record
    

    ! Assume everything is not static to begin with.
    !
    STATIC_FLAG[0] = FALSE;


    ! If this is a BLISS special cases DST record, return its start address and
    ! length if the BLISS data item is static.
    !
    IF .DSTPTR[DST$B_TYPE] EQL DST$K_BLI
    THEN
	BEGIN
	STATIC_FLAG[0] = FALSE;
	IF .DSTPTR[DST$B_BLI_VFLAGS] NEQ DST$K_VALKIND_ADDR THEN RETURN;
	BPTR1 = DSTPTR[DST$A_BLI_TRLR1] + .DSTPTR[DST$B_BLI_LNG];
	ADDRESS[0] = .BPTR1[DST$L_BLI_VALUE];
	BPTR2 = BPTR1[DST$A_BLI_TRLR2] + .BPTR1[DST$B_BLI_NAME];
	LENGTH[0] = .BPTR2[DST$L_BLI_SIZE];
	IF .DSTPTR[DST$V_BLI_REF] THEN LENGTH[0] = 4;
	STATIC_FLAG[0] = TRUE;
	RETURN;
	END;


    ! If this is a boolean (as in PASCAL) and it is static, we mark it as static
    ! and return its address and a length of 1 byte.  We determine whether it is
    ! static by checking the Value-Flags field.
    !
    IF (.DSTPTR[DST$B_TYPE] EQL DST$K_BOOL) AND
       (.DSTPTR[DST$B_VFLAGS] EQL DST$K_VALKIND_ADDR)
    THEN
	BEGIN
	ADDRESS[0] = .DSTPTR[DST$L_VALUE];
	LENGTH[0] = 1;
	STATIC_FLAG[0] = TRUE;
	RETURN;
	END;


    ! If this is a record begin record, or if the item is specified by the
    ! DST$K_SEPTYP record, and it is static, then we mark it as static and
    ! return its address.  However, we do not know its length (at least not
    ! readily), so we return a length of zero.  In effect, we treat the 
    ! object as a label.
    !
    IF (.DSTPTR[DST$B_TYPE] EQL DST$K_SEPTYP) AND 
       (.DSTPTR[DST$B_VFLAGS] EQL DST$K_VALKIND_ADDR)
    THEN
	BEGIN
	LOCAL
	    TYPEPTR, TYPESPEC;

	ADDRESS[0] = .DSTPTR[DST$L_VALUE];
	LENGTH[0] = DBG$FIND_SEPTYP(.DSTPTR, TYPEPTR, TYPESPEC);
	LENGTH[0] = (.LENGTH[0] + 7) / 8;
	STATIC_FLAG[0] = TRUE;
	RETURN;
	END;


    IF (.DSTPTR[DST$B_TYPE] EQL DST$K_RECBEG) AND
       (.DSTPTR[DST$B_VFLAGS] EQL DST$K_VALKIND_ADDR)
    THEN
	BEGIN
	LOCAL
	    RECBEG_TRLR: REF DST$RECBEG_TRLR;

	ADDRESS[0] = .DSTPTR[DST$L_VALUE];
	RECBEG_TRLR = DSTPTR[DST$B_NAME] + 1 + .DSTPTR[DST$B_NAME];
	LENGTH[0] = (.RECBEG_TRLR[DST$L_RECBEG_SIZE] + 7) / 8;
	STATIC_FLAG[0] = TRUE;
	RETURN;
	END;

    IF (.DSTPTR[DST$B_TYPE] EQL DST$K_ENUMBEG) AND
       (.DSTPTR[DST$B_VFLAGS] EQL DST$K_VALKIND_ADDR)
    THEN
	BEGIN
	ADDRESS[0] = .DSTPTR[DST$L_VALUE];
	LENGTH[0] = (.DSTPTR[DST$B_ENUMBEG_LENG] + 7) / 8;
	STATIC_FLAG[0] = TRUE;
	END;


    ! If the DST record is anything other than a VAX Standard Data Type at this
    ! point, just return with STATIC_FLAG set to FALSE.
    !
    IF (.DSTPTR[DST$B_TYPE] LSS DSC$K_DTYPE_LOWEST) OR
       (.DSTPTR[DST$B_TYPE] GTR DSC$K_DTYPE_HIGHEST)
    THEN
	BEGIN
	STATIC_FLAG[0] = FALSE;
	RETURN;
	END;


    ! We have a VAX Standard data item.  If this is a static scalar, pick up its
    ! start address and length and return with STATIC_FLAG set to TRUE.
    !
    IF .DSTPTR[DST$B_VFLAGS] EQL DST$K_VALKIND_ADDR
    THEN
	BEGIN
	ADDRESS[0] = .DSTPTR[DST$L_VALUE];
	LENGTH[0] = .LENGTH_TBL[.DSTPTR[DST$B_TYPE]];
	STATIC_FLAG[0] = TRUE;
	RETURN;
	END;


    ! If this data item DST record contains a VAX Standard Descriptor, we can
    ! assume it to be static and we pick up its address and length from the
    ! embedded descriptor.
    !
    IF .DSTPTR[DST$B_VFLAGS] EQL DST$K_VFLAGS_DSC
    THEN
	BEGIN


	! Get the start address and data item length from the descriptor.
	!
	DESCPTR = DSTPTR[DST$A_DSC_BASE] + .DSTPTR[DST$L_DSC_OFFS];
	ADDRESS[0] = .DESCPTR[DSC$A_POINTER];
	LENGTH[0] = DBG$GET_BITSIZE_FROM_DESC(.DESCPTR);
	LENGTH[0] = (.LENGTH[0] + 7) / 8;

	! Set the static flag to TRUE and return.
	!
	STATIC_FLAG[0] = TRUE;
	RETURN;
	END;


    ! If we have come here, the data item is not static.  Return saying so.
    !
    STATIC_FLAG[0] = FALSE;
    RETURN;

    END;

ROUTINE STATIC_CHECK_HANDLER(SIGARG, MECHARG, ENBLARG) =
!
! FUNCTION
!	This routine is to catch the signals for STATIC_CHECK routine.
!	So the STATIC_CHECK will not treat the object to be static.
!
! INPUTS
!	SIGARG	- The signal argument vector.
!
!	MECHARG	- The mechanism argument vector.
!
!	ENBLARG	- The enable argument vector. (not used)
!
! OUTPUTS
!	None. 
!

    BEGIN

    MAP
	SIGARG: REF VECTOR[,LONG];

    IF .SIGARG[1] EQL DBG$_ACCADDCOM OR
       .SIGARG[1] EQL DBG$_DESCNOTSET OR
       .SIGARG[1] EQL DBG$_SYMNOTACT OR
       .SIGARG[1] EQL DBG$_NOACCESSR
    THEN
	BEGIN
        SETUNWIND();
	RETURN 0;
	END;

    RETURN SS$_RESIGNAL;
    END;


ROUTINE TEST_DST_SIZE(FILENAME, IMG_DST_BLOCK) =
!
! FUNCTION
!	This routine is used only if this is a Testable Debugger.  It scans the
!	Debug Symbol Table (DST) to find where the User Program DST ends.  This
!	is done to exclude the Debugger's own DST from the DST mapped into the
!	virtual address space.  The routine thus scans the DST (using RMS I/O so
!	that no virtual address space is used up) looking for the Module-Begin
!	record for DBGSTART.  If this record is found, that location is returned
!	as the DST end location; otherwise the actual end of the DST is returned
!	as the end location.
!
! INPUTS
!	FILENAME - The address of a Counted ASCII string containing the file-
!		  name of the executable image file.
!
!	IMG_DST_BLOCK - A pointer to the image header DST/GST descriptor.  This
!		  is assumed to already be in memory.
!
! OUTPUTS
!	The number of bytes in the DST before the end of the DST or before the
!		  Module-Begin record for DBGSTART is returned as the value.
!

    BEGIN

    MAP
	FILENAME: REF VECTOR[,BYTE],	! Pointer to the executable image file-
					!      name in Counted ASCII
	IMG_DST_BLOCK: REF IHS$ENTRY;	! Pointer to the image header symbol
					!      table descriptor

    LITERAL
	BLKCOUNT = 10,			! Number of file blocks/buffer "block"
	BUFSIZE  = (BLKCOUNT + 1)*512;	! Size of the DST record buffer

    OWN
	DSTFAB: $FAB(FAC=<BIO,GET>),	! DST File Access Block (FAB)
	DSTRAB: $RAB(ROP=BIO);		! DST Record Access Block (RAB)

    LOCAL
	BLKNUM,				! Block number within the image file--a
					!      "block" is BLKCOUNT*512 bytes
	BYTNUM,				! Byte number within current "block"
	CURBLK,				! Number of current "block" in XBUFFER
	DSTADDR,			! Current byte address in the DST rela-
					!      tive to the start of the DST
	DSTENDADDR,			! Byte address of the end of the DST
	DSTPTR: REF DST$RECORD,		! Pointer to the current DST record
	STATUS,				! Status code returned by RMS
	XBUFFER: VECTOR[BUFSIZE,BYTE];	! DST file buffer



    ! Set up the FAB and the RAB for doing Block I/O to read the executable
    ! image file.  Then open and connect the executable image file.
    !
    DSTFAB[FAB$L_FNA] = FILENAME[1];
    DSTFAB[FAB$B_FNS] = .FILENAME[0];
    DSTRAB[RAB$L_FAB] = DSTFAB;
    DSTRAB[RAB$L_UBF] = XBUFFER;
    STATUS = $OPEN(FAB=DSTFAB);
    IF NOT .STATUS THEN SIGNAL(.STATUS);
    STATUS = $CONNECT(RAB=DSTRAB);
    IF NOT .STATUS THEN SIGNAL(.STATUS);


    ! Now loop over the whole Debug Symbol Table (DST) to find where the user
    ! program DST ends.  This is either at the true end of the DST or at the
    ! start of the Module-Begin DST record for DBGSTART.
    !
    CURBLK = -1;
    DSTADDR = 0;
    DSTENDADDR = 512*.IMG_DST_BLOCK[IHS$W_DSTBLKS] - 1;
    WHILE TRUE DO
	BEGIN


	! Find the "block" number and the byte offset within the block repre-
	! sented by the current DST address.  If that "block" of the file is
	! not now in the buffer, read it into the buffer.
	!
	BLKNUM = .DSTADDR/(BLKCOUNT*512);
	BYTNUM = .DSTADDR MOD (BLKCOUNT*512);
	IF .BLKNUM NEQ .CURBLK
	THEN
	    BEGIN
	    DSTRAB[RAB$L_BKT] = .BLKNUM*BLKCOUNT + .IMG_DST_BLOCK[IHS$L_DSTVBN];
	    DSTRAB[RAB$W_USZ] = MIN(BUFSIZE,
				.DSTENDADDR + 1 - .BLKNUM*BLKCOUNT*512);
	    STATUS = $READ(RAB=DSTRAB);
	    IF NOT .STATUS THEN SIGNAL(.STATUS);
	    CURBLK = .BLKNUM;
	    END;

	DSTPTR = XBUFFER[.BYTNUM];


	! Determine whether we have reached the end of the DST.  If we have,
	! return the current DST size in bytes to the caller.
	!
	IF (.DSTADDR GEQU .DSTENDADDR)   OR
	   (.DSTPTR[DST$B_LENGTH] EQL 0) OR
	   (.DSTPTR[DST$B_TYPE] EQL DST$K_MODBEG AND
	    CH$EQL(9, UPLIT BYTE(%ASCIC 'DBGSTART'),
		.DSTPTR[DST$B_MODBEG_NAME] + 1, DSTPTR[DST$B_MODBEG_NAME], 0))
	THEN
	    RETURN .DSTADDR;


	! We are not yet at the end of the DST.  Go to the next record and loop.
	!
	DSTADDR = .DSTADDR + 1 + .DSTPTR[DST$B_LENGTH];
	END;


    ! We should never get here.
    !
    RETURN 0;

    END;

END ELUDOM
