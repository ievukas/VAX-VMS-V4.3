MODULE RDBLOK (
		LANGUAGE (BLISS32),
		IDENT = 'V04-000'
		) =
BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************

!++
!
! FACILITY:  F11ACP Structure Level 2
!
! ABSTRACT:
!
!	This module contains routines for basic block I/O, as well
!	as the buffer management mechanism.
!
! ENVIRONMENT:
!
!	STARLET operating system, including privileged system services
!	and internal exec routines.
!
!--
!
!
! AUTHOR:  Andrew C. Goldstein,	 CREATION DATE:  13-Dec-1976  22:48
!
! MODIFIED BY:
!
!	V03-032	CDS0015		Christian D. Saether	30-Aug-1984
!		Allow for multi-header directory files.
!
!	V03-031	CDS0014		Christian D. Saether	24-Aug-1984
!		Removing an entry from the directory index cache
!		free list had one too many levels of indirection,
!		occasionally messing up the queue.
!
!	V03-030	CDS0013		Christian D. Saether	 7-Aug-1984
!		Add KILL_DINDX routine.  Remove tests for dir_fcb
!		and primary_fcb in unhook_bfrd - the fcb$v_dir flag
!		handles those conditions correctly.
!
!	V03-029	CDS0012		Christian D. Saether	 6-Aug-1984
!		Fix bug in CDS0011 causing infinite loop when
!		mounting disk /nocache, or while marked for dismount.
!		Use L_NORM linkage for UNHOOK_BFRD.
!
!	V03-028	CDS0011		Christian D. Saether	15-Jul-1984
!		Add support for maintaining directory index blocks.
!		Add MAKE_DIRINDX routine.
!		Remove intermediate blocks from CDS0010.  The
!		problem was in the form of the bind_common
!		declarations and was resolved there.
!
!	V03-027	CDS0010		Christian D. Saether	 7-Jul-1984
!		Break up READ_BLOCK and FIND_BUFFER into smaller
!		blocks to stop the absurd amount of cse that the
!		compiler generates.
!
!	V03-026	CDS0009		Christian D. Saether	 2-Jul-1984
!		Remove CACHELOCK consistency check so that cell
!		can be used for STS_DISKREAD flag.
!		Raise minimum file header requirements to 3 buffers
!		from 2 buffers.
!
!	V03-025	CDS0008		Christian D. Saether	24-Jun-1984
!		Restore multi-block read capability.
!
!	V03-024	CDS0007		Christian D. Saether	20-Jun-1984
!		Raise/lower process diocnt around qio so that file
!		system i/o is not blocked for lack of quota.  Do
!		same for ASTCNT so it does not fail for lack of
!		ast quota either.
!
!	V03-023	CDS0006		Christian D. Saether	25-May-1984
!		When not cluster accessible, do not bump
!		sequence number on modifies.
!		Add routine to scan appropriate pool and kick
!		out buffers of a given type.
!
!	V03-022	Expand test for clusterness to test whether we are
!		are a cluster at all.
!
!	V03-021	CDS0004		Christian D. Saether	 8-May-1984
!		Do not leave lock on buffer if not cluster device.
!		Modify buffer validation for bitmap, index, and quota
!		type buffers.
!
!	V03-020	CDS0003		Christian D. Saether	10-Apr-1984
!		Bump appropriate pool hit/miss counters.
!		Don't set VALID, DIRTY in bfrd in CREATE_BLOCK if
!		for special lbn -1.  Set VALID, DIRTY in bfrd in
!		RESET_LBN routine.
!
!	V03-019	CDS0002		Christian D. Saether	 4-Apr-1984
!		On lockbasis mismatch, when tolerated at all (for
!		blocks in the data or headers), toss the buffer out
!		to get the lock dissociated because it's the wrong
!		one.
!
!	V03-018	CDS0001		Christian D. Saether	20-Mar-1984
!		Establish BASE as AST parameter in SERIAL_CACHE routine.
!
!	V03-017	ACG0408		Andrew C. Goldstein,	23-Mar-1984  14:47
!		Add AST parameter so that impure storage is fully based
!
!	V03-016	ACG0403		Andrew C. Goldstein,	15-Mar-1984  17:35
!		Correct test for new buffer in WRONG_LOCKBASIS;
!		fix buffer address computation in TOSS_CACHE_DATA.
!
!	V03-015	CDS	Christian D. Saether	 9-Mar-1984
!		Rewrite cache routines for shared paged pool caching.
!
!**


LIBRARY 'SYS$LIBRARY:LIB.L32';
REQUIRE 'SRC$:FCPDEF.B32';

FORWARD ROUTINE
	GET_REQD_BFR_CREDITS : L_NORM NOVALUE,
	RETURN_BFRD	: L_JSB_1ARG NOVALUE,
	FIND_BUFFER	: L_NORM,
	INVALIDATE	: L_NORM NOVALUE,
	UNHOOK_BFRD	: L_NORM NOVALUE,
	WRITE_BLOCK	: L_NORM NOVALUE,
	FREE_ONE	: L_JSB NOVALUE,
	WAKE_WAITER	: NOVALUE,
	RELEASE_CACHE	: L_JSB NOVALUE,
	SERIAL_CACHE	: L_JSB NOVALUE;

EXTERNAL ROUTINE
	WAIT_FOR_AST	: NOVALUE,	! exit thread until completion ast
	CONTINUE_THREAD	: NOVALUE;	! completion AST to resume thread

EXTERNAL
	CTL$GL_PHD	: REF BBLOCK ADDRESSING_MODE (GENERAL),
	CTL$GL_PCB	: REF BBLOCK ADDRESSING_MODE (GENERAL);

MACRO
	QFLNK = 0,0,32,0 %,
	QBLNK = 4,0,32,0 %,

	LOOKUP_LBN (LBN) =

		BEGIN
		BIND
		    HSHTBL = .CACHE_HDR [F11BC$L_LBNHSHBAS] : VECTOR [,WORD];

		HSHTBL [ABS (LBN MOD .CACHE_HDR [F11BC$W_LBNHSHCNT])]
		END %,

	LOOKUP_LOCK (LOCKBASIS, PARLKID) =

		BEGIN
		BIND
		    HSHTBL = .CACHE_HDR [F11BC$L_BLHSHBAS] : VECTOR [,WORD];

		HSHTBL [ABS ((LOCKBASIS + PARLKID) MOD .CACHE_HDR [F11BC$W_BLHSHCNT])]
		END %,

! Calculate address of given descriptor within 1-based descriptor blockvectors.
!

	BFRD_ADDR (BAS1INDX) =
		.CACHE_HDR [F11BC$L_BFRDBAS] + (BAS1INDX - 1)*BFRD$S_BFRDDEF %,

	BFRLD_ADDR (BAS1INDX) =
		.CACHE_HDR [F11BC$L_BFRLDBAS] + (BAS1INDX - 1)*BFRL$S_BFRLDEF %;

BIND
	POOL_TABLE	= UPLIT BYTE (	2,	! file headers
					0,	! storage map
					1,	! directories
					2,	! index file blocks
					1,	! random data blocks
					1,	! quota file blocks
					3	! directory index blocks
			) : VECTOR [,BYTE];

GLOBAL ROUTINE MAKE_DIRINDX (FCB) : L_NORM =

!++
!
! FUNCTIONAL DESCRIPTION:
!
! This routine validates the directory index pointed to from the
! given FCB, under the cache interlock.
!
! If the given FCB does not have a directory index, attempt to
! attach one to it.
!
! ROUTINE VALUE:
!
!	0 - if the given FCB is invalid
!	1 - if the given FCB is valid
!
!--

BEGIN

MAP
	FCB	: REF BBLOCK;

BIND_COMMON;

EXTERNAL
	PMS$GL_DIRHIT	: ADDRESSING_MODE (GENERAL),
	PMS$GL_DIRMISS	: ADDRESSING_MODE (GENERAL);
LOCAL
	DIRINDX		: REF BBLOCK FIELD (DIRC),
	DNDX_BFRD	: REF BBLOCK,
	FCBVALID	: INITIAL (0);

IF .LB_HDRSEQ [.DIR_LCKINDX] EQL 0
THEN
    LB_HDRSEQ [.DIR_LCKINDX] = .LB_HDRSEQ [.DIR_LCKINDX] + 1;

IF .LB_DATASEQ [.DIR_LCKINDX] EQL 0
THEN
    LB_DATASEQ [.DIR_LCKINDX] = .LB_DATASEQ [.DIR_LCKINDX] + 1;

SERIAL_CACHE ();

IF (DIRINDX = .FCB [FCB$L_DIRINDX]) EQL 0
THEN
    BEGIN
    LOCAL
	INDX0,
	POOL_LRU	: REF BBLOCK;

    POOL_LRU = CACHE_HDR [F11BC$Q_POOL_LRU] + 3*8;

    REMQUE (.POOL_LRU [QFLNK], DNDX_BFRD);

    INDX0 = ((.DNDX_BFRD - .CACHE_HDR [F11BC$L_BFRDBAS])/BFRD$S_BFRDDEF);

    UNHOOK_BFRD (.INDX0 + 1, .DNDX_BFRD);

    DIRINDX = (.INDX0*512) + .CACHE_HDR [F11BC$L_BUFBASE];

    DNDX_BFRD [BFRD$L_LBN] = .FCB;
    DNDX_BFRD [BFRD$B_BTYPE] = DIRINDX_TYPE;
    DNDX_BFRD [BFRD$L_LOCKBASIS] = .LB_BASIS [.DIR_LCKINDX];
    DNDX_BFRD [BFRD$L_UCB] = .CURRENT_UCB;
    FCB [FCB$L_DIRINDX] = .DIRINDX;
    DNDX_BFRD [BFRD$V_VALID] = 1;
    DIRINDX [DIRC$W_INUSE] = 0;
    PMS$GL_DIRMISS = .PMS$GL_DIRMISS + 1;
    END
ELSE
    BEGIN

    DNDX_BFRD = (((.DIRINDX - .CACHE_HDR [F11BC$L_BUFBASE])/512)*BFRD$S_BFRDDEF)
		+ .CACHE_HDR [F11BC$L_BFRDBAS];

    REMQUE (.DNDX_BFRD, DNDX_BFRD);

    IF .DNDX_BFRD [BFRD$L_SEQNUM] EQL .LB_HDRSEQ [.DIR_LCKINDX]
    THEN
	BEGIN
	FCBVALID = 1;

	IF .DIRINDX [DIRC$L_DATASEQ] NEQ .LB_DATASEQ [.DIR_LCKINDX]
	THEN
	    BEGIN
	    DIRINDX [DIRC$W_INUSE] = 0;
	    PMS$GL_DIRMISS = .PMS$GL_DIRMISS + 1;
	    END
	ELSE
	    PMS$GL_DIRHIT = .PMS$GL_DIRHIT + 1;

	END
    ELSE
	BEGIN
	DIRINDX [DIRC$W_INUSE] = 0;
	PMS$GL_DIRMISS = .PMS$GL_DIRMISS + 1;
	END;

    END;

IF .BFRS_USED [3] NEQ 0
THEN
    BUG_CHECK (XQPERR, 'should not have any in use')
ELSE
    BFRS_USED [3] = 1;

IF .DNDX_BFRD [BFRD$W_CURPID] NEQ 0
THEN
    BUG_CHECK (XQPERR, 'directory index buffer should not be in use')
ELSE
    DNDX_BFRD [BFRD$W_CURPID] = .CTL$GL_PCB [PCB$L_PID];

INSQUE (.DNDX_BFRD, .BFR_LIST [3, QBLNK]);

RELEASE_CACHE ();

.FCBVALID

END;		! of routine MAKE_DIRINDX

GLOBAL ROUTINE KILL_DINDX (FCB) : L_NORM NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Invalidate the directory index block pointed to by
!	the given fcb, if any.  This is done under the cache
!	serialization lock.
!
!--

BEGIN

MAP
	FCB	: REF BBLOCK;

BIND_COMMON;

LOCAL
	INDX0,
	BFRD	: REF BBLOCK,
	DIRINDX	: REF BBLOCK,
	PIDINDX	: WORD;

SERIAL_CACHE ();

IF (DIRINDX = .FCB [FCB$L_DIRINDX]) NEQ 0
THEN
    BEGIN
    INDX0 = (.DIRINDX - .CACHE_HDR [F11BC$L_BUFBASE])/512;
    BFRD = .CACHE_HDR [F11BC$L_BFRDBAS] + BFRD$S_BFRDDEF*(.INDX0);

    PIDINDX = .CTL$GL_PCB [PCB$L_PID];

    IF .BFRD [BFRD$W_CURPID] NEQ 0
    THEN
	BEGIN
	IF .BFRD [BFRD$W_CURPID] NEQ .PIDINDX
	THEN
	    BUG_CHECK (XQPERR, 'should not belong to anyone else')
	ELSE
	    BEGIN

! If this one is in-process, simply clear valid to cause it to
! be cleaned up when locks are run down.  Also clear the pointer
! to the fcb in the bfrd.
!

	    BFRD [BFRD$V_VALID] = 0;
	    BFRD [BFRD$L_LBN] = 0;
	    END;
	END
    ELSE
	BEGIN
	UNHOOK_BFRD (.INDX0+1, .BFRD);
	RETURN_BFRD (.BFRD);
	END;

    FCB [FCB$L_DIRINDX] = 0;

    END;

RELEASE_CACHE ();

END;		! of routine KILL_DINDX

GLOBAL ROUTINE READ_BLOCK (LBN, COUNT, TYPE) : L_NORM =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine reads the desired block(s) from the disk.
!	Blocks are categorized by type to aid buffer management.
!	Note that the caller assumes only one block is ever read; multiple
!	blocks read ahead are acquired through cache hits on subsequent calls.
! CALLING SEQUENCE:
!	READ_BLOCK (ARG1, ARG2, ARG3)
!
! INPUT PARAMETERS:
!	ARG1: LBN of block(s)
!	ARG2: number of blocks to read
!	ARG3: block type code
!
! IMPLICIT INPUTS:
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	IO_STATUS receives status of I/O transfer
!
! ROUTINE VALUE:
!	address of buffer containing block
!
! SIDE EFFECTS:
!	BLOCK READ
!
!--

BEGIN


LOCAL
	I,				! index of buffer used
	BFRD		: REF BBLOCK,	! pointer to buffer descriptor
	STATUS,				! QIO service status
	FOUND_COUNT;			! count of buffers gotten

EXTERNAL
	ACP$GB_DATACHK	: BITVECTOR ADDRESSING_MODE (ABSOLUTE);
					! ACP datacheck enable flags

BIND_COMMON;

EXTERNAL LITERAL
	ACP$V_READCHK	: UNSIGNED (6);	! read check enable flag

! Find a suitable block buffer. If it does not already contain the block,
! read it.
!

STSFLGS [STS_DISKREAD] = 0;

I = FIND_BUFFER (.LBN, .TYPE, .COUNT, FOUND_COUNT);

BFRD = .CACHE_HDR [F11BC$L_BFRDBAS] + (.I*BFRD$S_BFRDDEF);

IF .BFRD [BFRD$V_VALID]
THEN
    RETURN .CACHE_HDR [F11BC$L_BUFBASE] + (.I*512);

    BEGIN
    LOCAL
	PTR	: REF BBLOCK,
	SAVE_PRIV : VECTOR [4];

    STSFLGS [STS_DISKREAD] = 1;

    PTR = .CTL$GL_PCB;
    PTR [PCB$W_DIOCNT] = .PTR [PCB$W_DIOCNT] + 1;
    PTR [PCB$W_ASTCNT] = .PTR [PCB$W_ASTCNT] + 1;
    SAVE_PRIV [0] = .(PTR [PCB$Q_PRIV]);
    SAVE_PRIV [1] = .(PTR [PCB$Q_PRIV]+4);
    BBLOCK [PTR [PCB$Q_PRIV], PRV$V_LOG_IO] = 1;
    BBLOCK [PTR [PCB$Q_PRIV], PRV$V_BYPASS] = 1;
    PTR = .CTL$GL_PHD;
    SAVE_PRIV [2] = .(PTR [PHD$Q_PRIVMSK]);
    SAVE_PRIV [3] = .(PTR [PHD$Q_PRIVMSK]+4);
    BBLOCK [PTR [PHD$Q_PRIVMSK], PRV$V_LOG_IO] = 1;
    BBLOCK [PTR [PHD$Q_PRIVMSK], PRV$V_BYPASS] = 1;

    PMS_TOT_READ = .PMS_TOT_READ + 1;
    STATUS = $QIO (
		EFN   = EFN,
		ASTADR = CONTINUE_THREAD,
		ASTPRM = .BASE,
		CHAN  = .IO_CHANNEL,
		FUNC  = (IO$_READLBLK
			 OR .ACP$GB_DATACHK[ACP$V_READCHK]
			 ^ $BITPOSITION (IO$V_DATACHECK)),
		IOSB  = IO_STATUS,
		P1    = .CACHE_HDR [F11BC$L_BUFBASE] + (.I*512),
		P2    = .FOUND_COUNT*512,
		P3    = .LBN
		);

    (PTR [PHD$Q_PRIVMSK]) = .SAVE_PRIV [2];
    (PTR [PHD$Q_PRIVMSK]+4) = .SAVE_PRIV [3];
    PTR = .CTL$GL_PCB;
    PTR [PCB$W_DIOCNT] = .PTR [PCB$W_DIOCNT] - 1;
    PTR [PCB$W_ASTCNT] = .PTR [PCB$W_ASTCNT] - 1;
    (PTR [PCB$Q_PRIV]) = .SAVE_PRIV [0];
    (PTR [PCB$Q_PRIV]+4) = .SAVE_PRIV [1];

    IF NOT .STATUS
    THEN IO_STATUS = .STATUS
    ELSE WAIT_FOR_AST();

    IF NOT .IO_STATUS
    THEN
	BEGIN
	INCR J FROM 0 TO .FOUND_COUNT-1
	DO
	    INVALIDATE (.CACHE_HDR [F11BC$L_BUFBASE] + (.I+.J)*512);
	ERR_EXIT (.IO_STATUS[0]);
	END;

    INCR J FROM 0 TO .FOUND_COUNT - 1
    DO
	BEGIN
	BFRD [BFRD$V_VALID] = 1;
	BFRD = .BFRD + BFRD$S_BFRDDEF;
	END;

    END;

RETURN .CACHE_HDR [F11BC$L_BUFBASE] + (.I*512)

END;					! end of routine READ_BLOCK

ROUTINE SERIAL_CACHE : L_JSB NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
! Serialize cache processing by queuing the CDRP part of our
! IO packet onto the AQB queue.  Go to sleep if someone else
! is already there.
!
!--

BEGIN

BIND_COMMON;

EXTERNAL
	PMS$GL_XQPCACHEWAIT	: ADDRESSING_MODE (GENERAL);

BUILTIN
	TESTBITSS,
	INSQUE;

LOCAL
	AQB	: REF BBLOCK,
	ACB	: REF BBLOCK;

AQB = .CURRENT_VCB [VCB$L_AQB];

IF (ACB = .ACB_ADDR) EQL 0
THEN
    BEGIN
    ACB_ADDR = (ACB = .IO_PACKET + IRP$C_CDRP);
    ACB [ACB$L_PID] = .CTL$GL_PCB [PCB$L_PID];
    ACB [ACB$L_AST] = CONTINUE_THREAD;
    ACB [ACB$L_ASTPRM] = .BASE;
    ACB [ACB$B_RMOD] = PSL$C_KERNEL + ACB$M_NODELETE;
    ACB [ACB$B_TYPE] = DYN$C_ACB;
    ACB [ACB$W_SIZE] = 0;
    END;

IF INSQUE (.IO_PACKET, .AQB [AQB$L_ACPQBL])
THEN
    RETURN
ELSE
    BEGIN
    PMS$GL_XQPCACHEWAIT = .PMS$GL_XQPCACHEWAIT + 1;
    WAIT_FOR_AST ();
    END;

END;

GLOBAL ROUTINE FIND_BUFFER (LBN, TYPE, COUNT, FOUND_COUNT) : L_NORM =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!
! CALLING SEQUENCE:
!
! INPUT PARAMETERS:
!
! IMPLICIT INPUTS:
!
! OUTPUT PARAMETERS:
!
! IMPLICIT OUTPUTS:
!
! ROUTINE VALUE:
!	index of first buffer found
!
! SIDE EFFECTS:
!	LRU list relinked, buffers may be written
!
!--

BEGIN

MAP
	TYPE	: BYTE;

BIND_COMMON;

EXTERNAL
	ACP$GB_MAXREAD		: BYTE ADDRESSING_MODE (ABSOLUTE),
	PMS$GL_FILHDR_HIT	: ADDRESSING_MODE (ABSOLUTE),
	PMS$GL_FILHDR_MISS	: ADDRESSING_MODE (ABSOLUTE),
	PMS$GL_DIRDATA_HIT	: ADDRESSING_MODE (ABSOLUTE),
	PMS$GL_DIRDATA_MISS	: ADDRESSING_MODE (ABSOLUTE),
	PMS$GL_STORAGMAP_HIT	: ADDRESSING_MODE (ABSOLUTE),
	PMS$GL_STORAGMAP_MISS	: ADDRESSING_MODE (ABSOLUTE);

LOCAL
	FNDCNT,
	INDX,
	POOL,
	INDX_ADDR,
	LOCKBASIS,
	SEQNUM,
	PIDINDX		: WORD,
	BFRD		: REF BBLOCK,
	BFRL		: REF BBLOCK,
	POOL_LRU	: REF BBLOCK;

LABEL
	GOT_ONE;

.FOUND_COUNT = 1;

SERIAL_CACHE ();

! If this is for LBN = -1, we just want a buffer.  Don't look for it,
! because other processes may be doing this also, and we don't want
! to find theirs.
!

IF (.LBN+1) EQL 0
THEN
    INDX = 0
ELSE
    BEGIN

! Get initial index by hashing.  Follow links, if any, until we
! get match on both LBN and UCB, or we run out of links to follow.
!

    INDX = .LOOKUP_LBN (.LBN)<0,16>;

    WHILE .INDX NEQ 0
    DO
	BEGIN

	BFRD = BFRD_ADDR (.INDX);

! Determine if this in fact matches on both LBN and UCB.
!

	IF .BFRD [BFRD$L_LBN] EQL .LBN
	    AND .BFRD [BFRD$L_UCB] EQL .CURRENT_UCB
	THEN
	    EXITLOOP
	ELSE
	    INDX = .BFRD [BFRD$W_NXTBFRD];
	END;
    END;

POOL = .POOL_TABLE [.TYPE];

PIDINDX = .CTL$GL_PCB [PCB$L_PID];

! Validate that we have a lockbasis for the buffer type requested.
! We deliberately do not include DIRINDX_TYPE buffers here, because
! they are not hashed at all and are not handled with this routine.
!

CASE .TYPE FROM 0 TO 5 OF
    SET
    [HEADER_TYPE, DATA_TYPE]:
	BEGIN
	
	IF .CURR_LCKINDX EQL 0
	THEN
	    BUG_CHECK (XQPERR, 'no current lock index lock basis');

	LOCKBASIS = .LB_BASIS [.CURR_LCKINDX];
	END;

    [DIRECTORY_TYPE]:
	BEGIN
	IF .DIR_LCKINDX EQL 0
	THEN
	    BUG_CHECK (XQPERR, 'No dir lock basis');

	LOCKBASIS = .LB_BASIS [.DIR_LCKINDX];
	END;

    [INDEX_TYPE, BITMAP_TYPE, QUOTA_TYPE]:
	IF (LOCKBASIS = .LB_BASIS [0]) EQL 0
	THEN
	    BUG_CHECK (XQPERR, 'no allocation lock for lock basis');

    [OUTRANGE]:
	BUG_CHECK (BADBUFTYP, 'Bad buffer type code');

    TES;

! Retrieve the lock basis and current buffer sequence number.  The
! lock basis is the same as used for the synchronization lock, and
! the sequence number was retrieved from the value block of that lock
! when it was raised to synchronize this operation.
! The appropriate lock depends on the type of buffer being requested.
!

CASE .TYPE FROM 0 TO 5 OF
    SET
    [HEADER_TYPE]:
	BEGIN
	IF .LB_HDRSEQ [.CURR_LCKINDX] EQL 0
	THEN
	    LB_HDRSEQ [.CURR_LCKINDX] = 1;

	SEQNUM = .LB_HDRSEQ [.CURR_LCKINDX];
	END;

    [DIRECTORY_TYPE]:
	BEGIN
	IF .LB_DATASEQ [.DIR_LCKINDX] EQL 0
	THEN
	    LB_DATASEQ [.DIR_LCKINDX] = 1;

	SEQNUM = .LB_DATASEQ [.DIR_LCKINDX];
	END;

    [DATA_TYPE]:
	BEGIN
	IF .LB_DATASEQ [.CURR_LCKINDX] EQL 0
	THEN
	    LB_DATASEQ [.CURR_LCKINDX] = 1;

	SEQNUM = .LB_DATASEQ [.CURR_LCKINDX];
	END;

! The storage bitmap, index file bitmap, and quota file data blocks
! get their sequence numbers from the volume lock value block.
! Check with the code in allocation_lock and allocation_unlock before
! changing any of this.
!

    [BITMAP_TYPE]:
	BEGIN
	IF .(LB_DATASEQ [0])<0,16,0> EQL 0
	THEN
	    (LB_DATASEQ [0])<0,16,0> = 1;

	SEQNUM = .(LB_DATASEQ [0])<0,16,0>;
	END;

    [INDEX_TYPE]:
	BEGIN
	IF .(LB_DATASEQ [0])<16,16,0> EQL 0
	THEN
	    (LB_DATASEQ [0])<16,16,0> = 1;

	SEQNUM = .(LB_DATASEQ [0])<16,16,0>;
	END;

    [QUOTA_TYPE]:
	BEGIN
	SEQNUM = .SAVE_VC_FLAGS<1,15,0>;

	IF .SEQNUM EQL 0
	THEN
	    BEGIN
	    SEQNUM = .SEQNUM + 1;
	    SAVE_VC_FLAGS<1,15,0> = .SEQNUM;
	    END;

	END;

    TES;

IF .INDX NEQ 0
THEN

! We found a buffer that matches the LBN and UCB desired.
! It may either be on our in-process queue (curpid will be us),
! or in the general buffer cache.
!

GOT_ONE:
    BEGIN

    IF .BFRD [BFRD$W_CURPID] NEQ 0
    THEN
	IF .BFRD [BFRD$W_CURPID] EQL .PIDINDX
	THEN

! This is a buffer we've already put onto our in-process queue.
! Move to the head of the LRU list and return.
!

	    BEGIN
	    REMQUE (.BFRD, BFRD);
	    INSQUE (.BFRD, .BFR_LIST [.POOL, QBLNK]);
	    RELEASE_CACHE ();
	    RETURN .INDX - 1
	    END

	ELSE
	    bug_check (xqperr,'');
!	    RESOLVE_AMBIGUITY ();


! Verify lock basis and that things are in the right pool.
!
! Blocks in the data block pool may legitimately have the wrong
! lockbasis as a result of having been deallocated to free storage
! and reallocated to another file.
!
! File headers may legitimately have the wrong lockbasis if they
! have been deleted and are being treated as primary headers when
! they used to be extension headers or vice-versa.  This will
! force a read from disk.  Further checks will be made in read_header
! against the actual header to see if things really make sense.
!
! Blocks can also cross pools (rare in practice) if directory or quota
! file data blocks, for example, are deallocated to free storage, and
! the index file is then extended, causing them to become file headers.
!
! In all cases, unhook and return the bfrd to destroy the association
! of this buffer with the lock basis and lock that is backing it.
!

    IF .BFRD [BFRD$L_LOCKBASIS] NEQ .LOCKBASIS
	OR .BFRD [BFRD$V_POOL] NEQ .POOL
    THEN
	IF .POOL EQL 1
	    OR .TYPE EQL HEADER_TYPE
	    OR .BFRD [BFRD$V_POOL] EQL 1
	THEN
	    BEGIN

	    UNHOOK_BFRD (
		((.BFRD - .CACHE_HDR [F11BC$L_BFRDBAS])/BFRD$S_BFRDDEF) + 1,
		.BFRD);

	    RETURN_BFRD (.BFRD);

	    LEAVE GOT_ONE;
	    END
	ELSE
	    BUG_CHECK (XQPERR, 'invalid lock basis');

! This was not on our in-process queue.  We'll need to account for the
! fact that we are taking another buffer out of general circulation for
! this operation.
!

    IF .BFRS_USED [.POOL] EQL .BFR_CREDITS [.POOL]
    THEN
	BEGIN
	BIND POOLAVAIL = CACHE_HDR [F11BC$L_POOLAVAIL] + .POOL*4;

	IF .POOLAVAIL GTR 4
	THEN
	    BEGIN
	    POOLAVAIL = .POOLAVAIL - 1;
	    BFR_CREDITS [.POOL] = .BFR_CREDITS [.POOL] + 1;
	    END
	ELSE
	    FREE_ONE (.POOL);
	END;

    BFRS_USED [.POOL] = .BFRS_USED [.POOL] + 1;

    IF .BFRD [BFRD$L_SEQNUM] NEQ .SEQNUM
    THEN
	BFRD [BFRD$V_VALID] = 0;

! The sequence number will be stored in the BFRD when the buffer is
! released back to the cache, otherwise it would be stored here.
!

    BFRD [BFRD$W_CURPID] = .PIDINDX;

! Pull this buffer out of the cache list and insert into our in-process queue.
!

    REMQUE (.BFRD, BFRD);
    INSQUE (.BFRD, .BFR_LIST [.POOL, QBLNK]);

    RELEASE_CACHE ();

! Count finding a valid buffer as a hit, an invalid one as a miss.
! We are deliberately not counting hits on buffers already on our
! in-process list to get a more meaningful hit ratio.
!

    IF .BFRD [BFRD$V_VALID]
    THEN
	BEGIN
	PMS_TOT_CACHE = .PMS_TOT_CACHE + 1;
	CASE .POOL FROM 0 TO 2 OF
	SET
	[0]:	PMS$GL_STORAGMAP_HIT = .PMS$GL_STORAGMAP_HIT + 1;
	[1]:	PMS$GL_DIRDATA_HIT = .PMS$GL_DIRDATA_HIT + 1;
	[2]:	PMS$GL_FILHDR_HIT = .PMS$GL_FILHDR_HIT + 1;
	TES;
	END
    ELSE
	CASE .POOL FROM 0 TO 2 OF
	SET
	[0]:	PMS$GL_STORAGMAP_MISS = .PMS$GL_STORAGMAP_MISS + 1;
	[1]:	PMS$GL_DIRDATA_MISS = .PMS$GL_DIRDATA_MISS + 1;
	[2]:	PMS$GL_FILHDR_MISS = .PMS$GL_FILHDR_MISS + 1;
	TES;

    RETURN .INDX - 1;
    END;			! of block GOT_ONE


! Failed to find a buffer matching desired LBN and UCB in the cache.
! Account for us using another buffer from the cache.
!

FNDCNT = 1;

IF .BFRS_USED [.POOL] EQL .BFR_CREDITS [.POOL]
THEN
    BEGIN
    BIND POOLAVAIL = CACHE_HDR [F11BC$L_POOLAVAIL] + .POOL*4;

    IF .POOLAVAIL GTR 4
    THEN
	BEGIN
	POOLAVAIL = .POOLAVAIL - 1;
	BFR_CREDITS [.POOL] = .BFR_CREDITS [.POOL] + 1;
	END
    ELSE
	FREE_ONE (.POOL);
    END;

POOL_LRU = CACHE_HDR [F11BC$Q_POOL_LRU] + .POOL*8;

REMQUE (.POOL_LRU [QFLNK], BFRD);

IF .COUNT GTRU 1
    AND .POOL EQL 1
THEN
    BEGIN
    LABEL CHK_BFRDS;

    BIND POOLAVAIL = CACHE_HDR [F11BC$L_POOLAVAIL] + 4;		! Pool 1
    BIND POOLCNT = CACHE_HDR [F11BC$W_POOLCNT] : VECTOR [,WORD];

    LOCAL
	DOWN,
	TRY_COUNT,
	LO_BFRD,
	HI_BFRD,
	CUR_BFRD : REF BBLOCK;

    TRY_COUNT = .ACP$GB_MAXREAD;

    IF .COUNT LSSU .TRY_COUNT
    THEN
	TRY_COUNT = .COUNT;

    LO_BFRD = .CACHE_HDR [F11BC$L_BFRDBAS] + (.POOLCNT [0])*BFRD$S_BFRDDEF;
    HI_BFRD = .LO_BFRD + (.POOLCNT [1])*BFRD$S_BFRDDEF;

    DOWN = 0;
    CUR_BFRD = .BFRD;

    WHILE .FNDCNT LSSU .TRY_COUNT
    DO
	CHK_BFRDS:
	BEGIN

	IF NOT .DOWN
	THEN
	    BEGIN

	    CUR_BFRD = .CUR_BFRD + BFRD$S_BFRDDEF;

	    IF .CUR_BFRD GEQA .HI_BFRD
	    THEN
		BEGIN
		CUR_BFRD = .BFRD;
		DOWN = 1;
		LEAVE CHK_BFRDS;
		END;

	    END
	ELSE
	    BEGIN

	    CUR_BFRD = .CUR_BFRD - BFRD$S_BFRDDEF;

	    IF .CUR_BFRD LSSA .LO_BFRD
	    THEN
		EXITLOOP;

	    END;

	IF .CUR_BFRD [BFRD$W_CURPID] NEQ 0
	THEN
	    EXITLOOP;

! NOTE: FNDCNT has not been bumped yet.

	INDX = .LOOKUP_LBN ((.LBN + .FNDCNT))<0,16>;

	WHILE .INDX NEQ 0
	DO
	    BEGIN

	    LOCAL TMPBFRD : REF BBLOCK;

	    TMPBFRD = BFRD_ADDR (.INDX);

	    IF .TMPBFRD [BFRD$L_LBN] EQL (.LBN + .FNDCNT)
		AND .TMPBFRD [BFRD$L_UCB] EQL .CURRENT_UCB
	    THEN
		EXITLOOP
	    ELSE
		INDX = .TMPBFRD [BFRD$W_NXTBFRD];
	    END;

	IF .INDX NEQ 0
	THEN
	    EXITLOOP;

	IF .POOLAVAIL GTR 4
	THEN
	    BEGIN
	    POOLAVAIL = .POOLAVAIL - 1;
	    BFR_CREDITS [1] = .BFR_CREDITS [1] + 1;
	    END
	ELSE
	    EXITLOOP;

! This one is ok.  Yank off LRU and count it.
!

	REMQUE (.CUR_BFRD, CUR_BFRD);
	FNDCNT = .FNDCNT + 1;

	IF .CUR_BFRD LSSA .BFRD
	THEN
	    BFRD = .CUR_BFRD;

	END;		! of block CHK_BFRDS

    .FOUND_COUNT = .FNDCNT;

! Set BFRD to the highest one in the range found.
!

    BFRD = .BFRD + (.FNDCNT - 1)*BFRD$S_BFRDDEF;

    END;	! of consider multi-block read

BFRS_USED [.POOL] = .BFRS_USED [.POOL] + .FNDCNT;

DECR I FROM (.FNDCNT - 1) TO 0
DO
    BEGIN

    INDX = ((.BFRD - .CACHE_HDR [F11BC$L_BFRDBAS])/BFRD$S_BFRDDEF) + 1;

    UNHOOK_BFRD (.INDX, .BFRD);

! Insert the new buffer into the hash list using the new LBN.
!

    INDX_ADDR = LOOKUP_LBN ((.LBN + .I));
    BFRD [BFRD$W_NXTBFRD] = .(.INDX_ADDR)<0,16>;
    (.INDX_ADDR)<0,16> = .INDX;

! Fill in our new or recycled BFRD, as the case may be, and
! insert it onto the appropriate in-process queue.
!

    BFRD [BFRD$L_LBN] = .LBN + .I;
    BFRD [BFRD$L_UCB] = .CURRENT_UCB;
    BFRD [BFRD$W_CURPID] = .PIDINDX;

    BFRD [BFRD$L_LOCKBASIS] = .LOCKBASIS;
    BFRD [BFRD$L_SEQNUM] = .SEQNUM;
    BFRD [BFRD$B_BTYPE] = .TYPE;

    INSQUE (.BFRD, .BFR_LIST [.POOL, QBLNK]);

    BFRD = .BFRD - BFRD$S_BFRDDEF;

    END;

RELEASE_CACHE ();

! We didn't find the buffer in the cache so count a miss.
!

CASE .POOL FROM 0 TO 2 OF
SET
[0]:	PMS$GL_STORAGMAP_MISS = .PMS$GL_STORAGMAP_MISS + 1;
[1]:	PMS$GL_DIRDATA_MISS = .PMS$GL_DIRDATA_MISS + 1;
[2]:	PMS$GL_FILHDR_MISS = .PMS$GL_FILHDR_MISS + 1;
TES;

RETURN .INDX - 1;

END;

ROUTINE WAKE_WAITER (AQB) : NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
! Remove ourself from cache processing queue.  Wake up
! the next process if queue is not empty.
!
!--

BEGIN

MAP
	AQB	: REF BBLOCK;

LINKAGE
	L_SCH$QAST = JSB : GLOBAL (PINCL=2, ACB=5) NOPRESERVE (3,4)
			NOTUSED (6,7,8,9,10,11);

GLOBAL REGISTER
	PINCL = 2,
	ACB = 5;

EXTERNAL ROUTINE
	SCH$QAST	: L_SCH$QAST ADDRESSING_MODE (ABSOLUTE);

ACB = .AQB [AQB$L_ACPQFL] + IRP$C_CDRP;	! first waiter's ACB
PINCL = PRI$_RESAVL;
IF NOT SCH$QAST ()
THEN
    BUG_CHECK (XQPERR, 'Failed to queue ast');

END;

GLOBAL ROUTINE RELEASE_CACHE : L_JSB NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
! Remove ourself from cache processing queue.  Wake up
! the next process if queue is not empty.
!
!--

BEGIN

BUILTIN
	REMQUE;

BIND_COMMON;

LOCAL
	AQB	: REF BBLOCK,
	DUMMY;

AQB = .CURRENT_VCB [VCB$L_AQB];

IF REMQUE (.AQB [QFLNK], DUMMY) EQL 0	! queue not empty
THEN
    WAKE_WAITER (.AQB);

END;

GLOBAL ROUTINE GET_REQD_BFR_CREDITS : L_NORM NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
! Acquire minimum buffer credits so that this operation may proceed.
! Wait for their availability if necessary.
! Initialize the global cell CACHE_HDR, primarily used by the buffer
! management routines.
!
!--

BEGIN

BIND_COMMON;

LOCAL
    AQB    : REF BBLOCK,
    REQD;

AQB = .CURRENT_VCB [VCB$L_AQB];

CACHE_HDR = .AQB [AQB$L_BUFCACHE];

SERIAL_CACHE ();

BEGIN
BIND
	POOLAVAIL = CACHE_HDR [F11BC$L_POOLAVAIL] : VECTOR,
	POOL_WAITQ = CACHE_HDR [F11BC$Q_POOL_WAITQ] : BLOCKVECTOR [,8,BYTE];

DECR POOL FROM 3 TO 0
DO
    BEGIN

! The minimal buffer requirements are:
! 1 for storage bitmap blocks (pool 0)
! 2 for directory data blocks (pool 1)
! 3 for file headers (pool 2)
! 1 for directory index (pool 3)
!


    REQD = .POOL + 1;

    IF .POOL EQL 3
    THEN
	REQD = 1;

    IF (POOLAVAIL [.POOL] = .POOLAVAIL [.POOL] - .REQD) LSS 0
    THEN
	BEGIN

! Insert our ACB temporarily at the head of the queue.  Then when
! we pull our irp off of it to put on the wait queue, the cache interlock
! queue will not be left empty until we do our release_cache and
! at that point pull off our temp acb entry.
!

	INSQUE (.ACB_ADDR, AQB [AQB$L_ACPQFL]);
	REMQUE (.IO_PACKET, IO_PACKET);		! take us out of cache queue
	INSQUE (.IO_PACKET, .POOL_WAITQ [.POOL, QBLNK]); ! into pool queue
	RELEASE_CACHE ();
	WAIT_FOR_AST ();

	IF .AQB [AQB$L_ACPQFL] NEQ .IO_PACKET
	THEN
	    BUG_CHECK (XQPERR, 'messed up cache interlock queues');

	END;

    BFR_CREDITS [.POOL] = .REQD;

    END;
END;		! of BIND

RELEASE_CACHE ();

END;

GLOBAL ROUTINE RETURN_CREDITS : L_NORM NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
! This routine returns the in-process buffer credits to the
! buffer pool.  It moves the next waiter in line to the head
! of the cache processing queue, which will cause it to become
! awakened when we release the cache interlock.
!
!--

BEGIN

BIND_COMMON;

LOCAL
    POOLAVAIL	: REF VECTOR,
    AQB		: REF BBLOCK;

! This may be called multiple times.   Check if already returned credits.
!

IF .BFR_CREDITS [3] EQL 0
THEN RETURN;

AQB = .CURRENT_VCB [VCB$L_AQB];
POOLAVAIL = CACHE_HDR [F11BC$L_POOLAVAIL];

SERIAL_CACHE ();

DECR POOL FROM 3 TO 0
DO
    BEGIN

    BIND
	POOL_WAITQ = CACHE_HDR [F11BC$Q_POOL_WAITQ] + .POOL*8 : BBLOCK;

    IF .BFRS_USED [.POOL] NEQ 0
    THEN
	BUG_CHECK (XQPERR, 'buffer use not to zero yet');

    POOLAVAIL [.POOL] = .POOLAVAIL [.POOL] + .BFR_CREDITS [.POOL];
    BFR_CREDITS [.POOL] = 0;

    IF .POOL_WAITQ [QFLNK] NEQ POOL_WAITQ [QFLNK]
    THEN
	BEGIN
	LOCAL
	    WAITER;

	REMQUE (.POOL_WAITQ [QFLNK], WAITER);
	INSQUE (.WAITER, .AQB [AQB$L_ACPQFL]);	! insert AFTER us.
	END;

    END;

RELEASE_CACHE ();

END;

GLOBAL ROUTINE WRITE_BLOCK (BUFFER) : L_NORM NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine writes the indicated block back to the disk.
!
! CALLING SEQUENCE:
!	WRITE_BLOCK (ARG1)
!
! INPUT PARAMETERS:
!	ARG1: address of block buffer
!
! IMPLICIT INPUTS:
!	BUFFER DESCRIPTOR ARRAYS
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	block written
!
!--

BEGIN

LOCAL
	BFRD		: REF BBLOCK,
	STATUS,				! service status of QIO call
	INDX;				! index of buffer

EXTERNAL
	CLU$GL_CLUB	: ADDRESSING_MODE (ABSOLUTE),
	ACP$GB_DATACHK	: BITVECTOR ADDRESSING_MODE (ABSOLUTE);
					! ACP datacheck enable flags

BIND_COMMON;

EXTERNAL LITERAL
	ACP$V_WRITECHK	: UNSIGNED (6);	! write check enable flag

INDX = (.BUFFER - .CACHE_HDR [F11BC$L_BUFBASE])/512 + 1;

IF .INDX<0,16> GTRU .CACHE_HDR [F11BC$W_BFRCNT]
THEN
    BUG_CHECK (BADBUFADR, 'out of this cache, man');

BFRD = BFRD_ADDR (.INDX);

! Stuff the UCB of IO_CHANNEL to go where we want.
!

IO_CCB [CCB$L_UCB] = .BFRD [BFRD$L_UCB];

BEGIN
LOCAL
	PTR		: REF BBLOCK,
	SAVE_PRIV	: VECTOR [4];

PTR = .CTL$GL_PCB;
PTR [PCB$W_DIOCNT] = .PTR [PCB$W_DIOCNT] + 1;
PTR [PCB$W_ASTCNT] = .PTR [PCB$W_ASTCNT] + 1;
SAVE_PRIV [0] = .(PTR [PCB$Q_PRIV]);
SAVE_PRIV [1] = .(PTR [PCB$Q_PRIV]+4);
BBLOCK [PTR [PCB$Q_PRIV], PRV$V_LOG_IO] = 1;
BBLOCK [PTR [PCB$Q_PRIV], PRV$V_BYPASS] = 1;
PTR = .CTL$GL_PHD;
SAVE_PRIV [2] = .(PTR [PHD$Q_PRIVMSK]);
SAVE_PRIV [3] = .(PTR [PHD$Q_PRIVMSK]+4);
BBLOCK [PTR [PHD$Q_PRIVMSK], PRV$V_LOG_IO] = 1;
BBLOCK [PTR [PHD$Q_PRIVMSK], PRV$V_BYPASS] = 1;

PMS_TOT_WRITE = .PMS_TOT_WRITE + 1;
STATUS = $QIO (
		EFN  = EFN,
		ASTADR = CONTINUE_THREAD,
		ASTPRM = .BASE,
		CHAN = .IO_CHANNEL,
		FUNC = (IO$_WRITELBLK
			 OR .ACP$GB_DATACHK[ACP$V_WRITECHK]
			 ^ $BITPOSITION (IO$V_DATACHECK)),
		IOSB = IO_STATUS,
		P1   = .BUFFER,
		P2   = 512,
		P3   = .BFRD [BFRD$L_LBN]
		);

(PTR [PHD$Q_PRIVMSK]) = .SAVE_PRIV [2];
(PTR [PHD$Q_PRIVMSK]+4) = .SAVE_PRIV [3];
PTR = .CTL$GL_PCB;
PTR [PCB$W_DIOCNT] = .PTR [PCB$W_DIOCNT] - 1;
PTR [PCB$W_ASTCNT] = .PTR [PCB$W_ASTCNT] - 1;
(PTR [PCB$Q_PRIV]) = .SAVE_PRIV [0];
(PTR [PCB$Q_PRIV]+4) = .SAVE_PRIV [1];

END;		! of block defining PTR, SAVE_PRIV

IF NOT .STATUS
THEN IO_STATUS = .STATUS
ELSE WAIT_FOR_AST();

! Restore CURRENT_UCB to IO_CHANNEL.
!

IO_CCB [CCB$L_UCB] = .CURRENT_UCB;

IF .IO_STATUS
THEN
    BEGIN
    LOCAL
	CLUSTER,
	LCKINDX;

    BFRD [BFRD$V_DIRTY] = 0;

! Now let's find the lock that backs this buffer and bump it's
! sequence number so the rest of the world will know we've modified
! this buffer.
!

    LCKINDX = 0;

    DO
	BEGIN

	IF .BFRD [BFRD$L_LOCKBASIS] EQL .LB_BASIS [.LCKINDX]
	THEN
	    EXITLOOP;

	LCKINDX = .LCKINDX + 1;
	END
    UNTIL .LCKINDX EQL LB_NUM;

    IF .LCKINDX EQL LB_NUM
    THEN
	BUG_CHECK (XQPERR, 'no backing lock for dirty buffer');

    CLUSTER = 0;

    IF .BBLOCK [CURRENT_UCB [UCB$L_DEVCHAR2], DEV$V_CLU]
	AND .CLU$GL_CLUB NEQ 0
    THEN
	CLUSTER = 1;

    CASE .BFRD [BFRD$B_BTYPE] FROM 0 TO 5 OF
    SET
    [HEADER_TYPE]:
	IF .CLUSTER
	THEN
	    LB_HDRSEQ [.LCKINDX] = .LB_HDRSEQ [.LCKINDX] + 1;

    [DIRECTORY_TYPE, DATA_TYPE]:
	IF .CLUSTER
	THEN
	    LB_DATASEQ [.LCKINDX] = .LB_DATASEQ [.LCKINDX] + 1;

    [BITMAP_TYPE]:
	(LB_DATASEQ [0])<0,16,0> = .(LB_DATASEQ [0])<0,16,0> + 1;

    [INDEX_TYPE]:
	(LB_DATASEQ [0])<16,16,0> = .(LB_DATASEQ [0])<16,16,0> + 1;

    [QUOTA_TYPE]:
	SAVE_VC_FLAGS<1,15,0> = .SAVE_VC_FLAGS<1,15,0> + 1;

    TES;

    END
ELSE
    BEGIN

! clean up will iterate on write failures if the volume is write locked until
! the best effort clean up has been done. However, if the write error was on the
! storage bitmap, we allocation lock the volume to prevent further damage.
!

    IF .BFRD [BFRD$V_POOL] EQL 0	! this is storage bitmap pool
	AND SURFACE_ERROR (.IO_STATUS [0])
    THEN
	CURRENT_VCB [VCB$V_NOALLOC] = 1;

    INVALIDATE (.BUFFER);
    ERR_EXIT (.IO_STATUS[0]);
    END;

END;					! end of routine WRITE_BLOCK

GLOBAL ROUTINE CREATE_BLOCK (LBN, COUNT, TYPE) : L_NORM =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine fabricates block buffer(s) containing the designated
!	block(s). The type code is as for READ_BLOCK and determines the buffer
!	pool to be used.
!
! CALLING SEQUENCE:
!
! INPUT PARAMETERS:
!
! IMPLICIT INPUTS:
!
! OUTPUT PARAMETERS:
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	address of buffer
!
! SIDE EFFECTS:
!	buffer zeroed and recorded as a block read
!
!--

BEGIN

BIND_COMMON;

LOCAL
	BUFFER,
	FOUND_COUNT,
	BFRD		: REF BBLOCK,
	INDX0;

INDX0 = FIND_BUFFER (.LBN, .TYPE, 1, FOUND_COUNT);

BFRD = .CACHE_HDR [F11BC$L_BFRDBAS] + .INDX0*BFRD$S_BFRDDEF;

BUFFER = .CACHE_HDR [F11BC$L_BUFBASE] + .INDX0*512;
CH$FILL (0, 512, .BUFFER);

IF (.LBN + 1) NEQ 0
THEN
    BEGIN
    BFRD [BFRD$V_DIRTY] = 1;
    BFRD [BFRD$V_VALID] = 1;
    END;

RETURN .BUFFER;

END;					! end of routine CREATE_BLOCK

GLOBAL ROUTINE UNHOOK_BFRD (INDXARG, BFRDARG) : L_NORM NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
! This routine extricates a BFRD and its associated BFRL from
! their hash lookup lists.  It also takes care of the BFRL if
! this was the last reference to it.
! The caller of this routine is responsible for clearing or
! rewriting other relevant fields in the BFRD.
!
!--

BEGIN

BIND_COMMON;

EXTERNAL ROUTINE
	DEL_EXTFCB	: L_NORM,
	NUKE_HEAD_FCB	: L_NORM NOVALUE;

LOCAL
	BFRD		: REF BBLOCK,
	INDX		: WORD,
	INDX_ADDR,
	BFRL		: REF BBLOCK;

BFRD = .BFRDARG;
INDX = .INDXARG;

IF .BFRD [BFRD$V_DIRTY]
THEN
    BUG_CHECK (XQPERR, 'Should not find dirty buffer');

BFRD [BFRD$V_VALID] = 0;

IF .BFRD [BFRD$B_BTYPE] EQL DIRINDX_TYPE
THEN
    BEGIN
    LOCAL
	BUFR	: REF BBLOCK,
	DIRFCB	: REF BBLOCK;

! DIRINDX_TYPE blocks are not hashed by lbn, and the field is used
! to point to the directory fcb.

    IF (DIRFCB = .BFRD [BFRD$L_LBN]) NEQ 0
    THEN
	BEGIN

	IF .DIRFCB [FCB$B_TYPE] NEQ DYN$C_FCB
	    OR .DIRFCB [FCB$L_DIRINDX] EQL 0
	THEN
	    BUG_CHECK (XQPERR, 'not legit dirfcb');

! This will break the association of this directory index buffer
! from the directory fcb.
!

	DIRFCB [FCB$L_DIRINDX] = 0;

	IF .DIRFCB [FCB$W_REFCNT] EQL 0
	THEN
	    IF TESTBITSC (DIRFCB [FCB$V_DIR])

! from this point on, because the refcnt was zero, and the DIR
! flag was set and is now clear, the search_fcb routine will no
! longer find this fcb, so we are free to deallocate it.
! Furthermore, because the DIR was set, we know that no search_fcb
! had found it at the time we cleared it because search_fcb will
! unconditionally clear it.
!
	    THEN
		BEGIN

! Note that we are under the cache interlock here, and assume that
! the these routines will do nothing that could cause a stall.
!

		DEL_EXTFCB (.DIRFCB);
		NUKE_HEAD_FCB (.DIRFCB);
		END;

	BFRD [BFRD$L_LBN] = 0;

	END;		! of bfrd$l_lbn (dirfcb pointer) neq zero

    END;

IF .BFRD [BFRD$L_LBN] NEQ 0
THEN

! BFRD$L_LBN neq 0 means that this buffer is in the hash lookup list.
! We need to remove it from the list it is currently
! in as we are about to use the same buffer for some other LBN.
!

    BEGIN

    INDX_ADDR = LOOKUP_LBN (.BFRD [BFRD$L_LBN]);

    IF .(.INDX_ADDR)<0,16> EQL .INDX
    THEN
	(.INDX_ADDR)<0,16> = .BFRD [BFRD$W_NXTBFRD]
    ELSE
	BEGIN
	DO
	    INDX_ADDR = BBLOCK [ BFRD_ADDR (.(.INDX_ADDR)<0,16>), BFRD$W_NXTBFRD]
	UNTIL .(.INDX_ADDR)<0,16> EQL .INDX;

	(.INDX_ADDR)<0,16> = .BFRD [BFRD$W_NXTBFRD];
	END;
    END;

! If it had a buffer lock hooked up with it, adjust the reference count
! on the lock descriptor, and remove the lock descriptor from its hash
! lookup list if this is the last reference to it.
!

IF .BFRD [BFRD$W_BFRL] NEQ 0
THEN
    BEGIN

    BFRL = BFRLD_ADDR (.BFRD [BFRD$W_BFRL]);

    BFRL [BFRL$W_REFCNT] = .BFRL [BFRL$W_REFCNT] - 1;
    IF .BFRL [BFRL$W_REFCNT] EQL 0
    THEN
	BEGIN

	IF .BFRL [BFRL$L_LKID] NEQ 0
	THEN
	    BEGIN
	    IF NOT $DEQ (LKID = .BFRL [BFRL$L_LKID])
	    THEN
		BUG_CHECK (XQPERR, 'unexpected lock manager reaction');
	    END;

! Hash on the lockbasis,parlkid pair and scan the list to find the
! desired bfrl, if necessary.  Pull it from the list when located.
!

	INDX_ADDR = LOOKUP_LOCK (.BFRL [BFRL$L_LCKBASIS],
				.BFRL [BFRL$L_PARLKID]);

	IF .(.INDX_ADDR)<0,16> EQL .BFRD [BFRD$W_BFRL]
	THEN
	    (.INDX_ADDR)<0,16> = .BFRL [BFRL$W_NXTBFRL]
	ELSE
	    BEGIN

	    DO
		INDX_ADDR = BBLOCK [ BFRLD_ADDR (.(.INDX_ADDR)<0,16>), BFRL$W_NXTBFRL]
	    UNTIL .(.INDX_ADDR)<0,16> EQL .BFRD [BFRD$W_BFRL];

	    (.INDX_ADDR)<0,16> = .BFRL [BFRL$W_NXTBFRL];
	    END;

	BFRL [BFRL$L_LKID] = 0;
	BFRL [BFRL$L_LCKBASIS] = 0;
	BFRL [BFRL$L_PARLKID] = 0;

	BFRL [BFRL$W_NXTBFRL] = .CACHE_HDR [F11BC$W_FREEBFRL];
	CACHE_HDR [F11BC$W_FREEBFRL] = .BFRD [BFRD$W_BFRL];
	END;

! There is no longer a BFRL associated with this BFRD.
!

    BFRD [BFRD$W_BFRL] = 0;

    END;

END;

ROUTINE FREE_ONE (POOL) : L_JSB NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
! This routine tosses a buffer off the in-process list to make room
! for a new one.  This only happens when we already have used up
! the minimum number of buffers for this pool, and there are not
! enough available in the cache to steal more from it.
!
!--

BEGIN

BIND_COMMON;

LOCAL
	INDX,
	POOL_LRU	: REF BBLOCK,
	FREED		: REF BBLOCK;

BFRS_USED [.POOL] = .BFRS_USED [.POOL] - 1;

REMQUE (.BFR_LIST [.POOL, QFLNK], FREED);

INDX = (.FREED - .CACHE_HDR [F11BC$L_BFRDBAS])/BFRD$S_BFRDDEF;

IF .FREED [BFRD$V_DIRTY]
THEN
    BEGIN
    RELEASE_CACHE ();
    WRITE_BLOCK (.INDX*512 + .CACHE_HDR [F11BC$L_BUFBASE]);
    SERIAL_CACHE ();
    END;

! Insert at front for now to recycle immediately.
!

POOL_LRU = CACHE_HDR [F11BC$Q_POOL_LRU] + .POOL*8;
INSQUE (.FREED, POOL_LRU [QFLNK]);
FREED [BFRD$W_CURPID] = 0;

END;

GLOBAL ROUTINE RELEASE_LOCKBASIS (LCKINDX) : L_NORM =

!++
!
! FUNCTIONAL DESCRIPTION:
!
! This routine scans in-process buffers and prepares them for lowering
! the synchronization lock associated with LOCKBASIS.
! All dirty buffers associated with the given LOCKBASIS must have been
! written to disk previously.  This routine runs under the cache serialization
! interlock, and if a conversion is required, will exit without releasing
! the cache serialization interlock.
!
!--

BEGIN

BIND_COMMON;

EXTERNAL
	CLU$GL_CLUB	: ADDRESSING_MODE (GENERAL);

LOCAL
	LOCKBASIS,
	LKID_ADDR,
	INDX;

LABEL
	FIXBFRL,
	LBMATCH;

LKID_ADDR = 0;
INDX = 0;
LOCKBASIS = .LB_BASIS [.LCKINDX];

SERIAL_CACHE ();

INCR POOL FROM 0 TO 3
DO
    BEGIN
    LOCAL
	I,
	QHEAD	: REF BBLOCK,
	BFRL	: REF BBLOCK,
	BFRD	: REF BBLOCK;

    QHEAD = BFR_LIST [.POOL, QFLNK];
    BFRD = .QHEAD [QFLNK];

    I = .BFRS_USED [.POOL];

    UNTIL .I EQL 0
    DO
	BEGIN
	LOCAL
	    NXTBFRD;

	I = .I - 1;
	NXTBFRD = .BFRD [BFRD$L_QFL];

! Check this BFRD for LOCKBASIS match.   Note that we are scanning an
! in-process list which can only contain buffers from a given volume
! or volume set.  Because the LOCKBASIS contains the RVN, it is not
! necessary to make a separate check for a volume set match.
! When the buffer was initially brought into the in-process list, it
! matched correctly on the desired UCB.
!

	IF .BFRD [BFRD$L_LOCKBASIS] EQL .LOCKBASIS
	THEN
LBMATCH:    BEGIN

	    LOCAL
		POOL_LRU : REF BBLOCK;

	    IF NOT .BFRD [BFRD$V_VALID]
	    THEN
		BEGIN
		LOCAL
		    INDX0;

		INDX0 = (.BFRD - .CACHE_HDR [F11BC$L_BFRDBAS])/BFRD$S_BFRDDEF;

		UNHOOK_BFRD (.INDX0 + 1, .BFRD);

		RETURN_BFRD (.BFRD);

		LEAVE LBMATCH;
		END;

! This is a valid buffer to be returned to the cache.
!

FIXBFRL:	BEGIN

		LOCAL
		    LBINDX_ADDR,
		    PARLKID;

		IF .BFRD [BFRD$V_DIRTY]
		THEN
		    BUG_CHECK (XQPERR, 'should not have dirty buffers now');

		PARLKID = .(IF .CURRENT_VCB [VCB$W_RVN] EQL 0
				THEN CURRENT_VCB [VCB$L_VOLLKID]
				ELSE CURRENT_RVT [RVT$L_STRUCLKID]);

		IF .BFRD [BFRD$W_BFRL] NEQ 0
		THEN

! We're already hooked up to a BFRL.  This means we found it already
! in the cache in the first place.  Nothing needs to be done with
! the BFRL.  However, let's be paranoid and make sure that it is
! hooked up to the correct lock.
!

		    BEGIN
		    BFRL = BFRLD_ADDR (.BFRD [BFRD$W_BFRL]);

		    IF .BFRL [BFRL$L_LCKBASIS] NEQ .LOCKBASIS
			OR .BFRL [BFRL$L_PARLKID] NEQ .PARLKID
		    THEN
			BUG_CHECK (XQPERR, 'wrong lockbasis');

		    LEAVE FIXBFRL;
		    END
		ELSE IF .INDX NEQ 0
		THEN

! This BFRD is not hooked up with a BFRL yet, but we've already
! got a BFRL in hand (from an earlier hit) so just hook it up
! and bump the REFCNT in the BFRL.
!
		    BEGIN

		    BFRD [BFRD$W_BFRL] = .INDX;
		    BFRL [BFRL$W_REFCNT] = .BFRL [BFRL$W_REFCNT] + 1;

		    LEAVE FIXBFRL;
		    END;

! There is no BFRL for this BFRD yet, so let's first see if a BFRL
! for this LOCKBASIS is already in the cache.
!

		LBINDX_ADDR = LOOKUP_LOCK (.LOCKBASIS, .PARLKID);
		INDX = .(.LBINDX_ADDR)<0,16>;

		WHILE .INDX NEQ 0
		DO
		    BEGIN

		    BFRL = BFRLD_ADDR (.INDX);

		    IF .BFRL [BFRL$L_LCKBASIS] EQL .LOCKBASIS
			AND .BFRL [BFRL$L_PARLKID] EQL .PARLKID
		    THEN
			EXITLOOP;

		    INDX = .BFRL [BFRL$W_NXTBFRL];
		    END;

		IF .INDX EQL 0
		THEN

! We did not find a BFRL in the cache already, so take one off
! the free list and use it.
!
		    BEGIN

		    IF (INDX = .CACHE_HDR [F11BC$W_FREEBFRL]) EQL 0
		    THEN
			BUG_CHECK (XQPERR, 'no free lock block');

! Take our new BFRL out of the free BFRL list.
! Link it into the front of the hash chain.
! Fill in the lockbasis and parent lock ID fields.
!

		    BFRL = BFRLD_ADDR (.INDX);
		    CACHE_HDR [F11BC$W_FREEBFRL] = .BFRL [BFRL$W_NXTBFRL];
		    BFRL [BFRL$W_NXTBFRL] = .(.LBINDX_ADDR)<0,16>;
		    (.LBINDX_ADDR)<0,16> = .INDX;

		    BFRL [BFRL$L_LCKBASIS] = .LOCKBASIS;
		    BFRL [BFRL$L_PARLKID] = .PARLKID;

! Test for LOCKBASIS of -1.  -1 is used for all buffers backed by the
! volume allocation lock.  Because there is a volume allocation lock
! associated with the VCB at all times, there is no need to separately
! keep a lock on those buffers in the cache.  However, we will keep
! a BFRL around to avoid a lot of special casing, but it's LKID field
! will be zero.
!

		    IF (.LOCKBASIS + 1) NEQ 0
			AND .BBLOCK [CURRENT_UCB [UCB$L_DEVCHAR2], DEV$V_CLU]
			AND .CLU$GL_CLUB NEQ 0
		    THEN
			LKID_ADDR = BFRL [BFRL$L_LKID];

		    END;

! Fill in the BFRD field that points to the BFRL.  Bump the REFCNT
! in the BFRL.
!

		BFRD [BFRD$W_BFRL] = .INDX;
		BFRL [BFRL$W_REFCNT] = .BFRL [BFRL$W_REFCNT] + 1;

		END;			! of FIXBFRL block

! Store the current sequence number from the backing lock for this buffer.
! This must be done here because multiple buffers may be backed by a
! single lock.  If one of them has been modified, the sequence number
! for that lock will have changed, yet unmodified buffers backed by
! the same do not have the same sequence number, even though they
! are still valid.  Hence, stamp all buffers with the current sequence
! number.

	    CASE .BFRD [BFRD$B_BTYPE] FROM 0 TO 6 OF
	    SET
	    [HEADER_TYPE]:
		BFRD [BFRD$L_SEQNUM] = .LB_HDRSEQ [.LCKINDX];

	    [DIRECTORY_TYPE, DATA_TYPE]:
		BFRD [BFRD$L_SEQNUM] = .LB_DATASEQ [.LCKINDX];

	    [DIRINDX_TYPE]:
		BEGIN
		LOCAL
		    DIRINDX	: REF BBLOCK FIELD (DIRC);

		BFRD [BFRD$L_SEQNUM] = .LB_HDRSEQ [.LCKINDX];
		DIRINDX = .CACHE_HDR [F11BC$L_BUFBASE]
			+ 512*(.BFRD - .CACHE_HDR [F11BC$L_BFRDBAS])/BFRD$S_BFRDDEF;
		DIRINDX [DIRC$L_DATASEQ] = .LB_DATASEQ [.LCKINDX];
		END;

	    [BITMAP_TYPE]:
		BFRD [BFRD$L_SEQNUM] = .(LB_DATASEQ [0])<0,16,0>;

	    [INDEX_TYPE]:
		BFRD [BFRD$L_SEQNUM] = .(LB_DATASEQ [0])<16,16,0>;

	    [QUOTA_TYPE]:
		BFRD [BFRD$L_SEQNUM] = .SAVE_VC_FLAGS<1,15,0>;

	    TES;


! Take the buffer off of the in-process queue and put it back
! on the appropriate pool LRU list in the cache.
! Clear out CURPID in the BFRD to note we aren't using it anymore.
!

	    REMQUE (.BFRD, BFRD);
	    BFRS_USED [.POOL] = .BFRS_USED [.POOL] - 1;
	    BFRD [BFRD$W_CURPID] = 0;
	    POOL_LRU = CACHE_HDR [F11BC$Q_POOL_LRU] + .POOL*8;
	    INSQUE (.BFRD, .POOL_LRU [QBLNK]);
	    END;		! of LOCKBASIS match.

	BFRD = .NXTBFRD;

	END;		! of loop through pool bfrds.

    IF .QHEAD NEQA .BFRD
    THEN
	BUG_CHECK (XQPERR, 'screwed up in-process list');

    END;	! of loop through all pools

IF .LKID_ADDR EQL 0
THEN
    RELEASE_CACHE ();

RETURN .LKID_ADDR

END;

GLOBAL ROUTINE RESET_LBN (BUFFER, LBN) : L_NORM NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine changes the resident LBN of the indicated block
!	and marks it as dirty and valid.
!	It is assumed this will be followed soon by a buffer write
!	operation for the new lbn.
!
! CALLING SEQUENCE:
!	RESET_LBN (ARG1, ARG2)
!
! INPUT PARAMETERS:
!	ARG1: address of block buffer
!	ARG2: new LBN
!
! IMPLICIT INPUTS:
!	buffer descriptor arrays
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	backing LBN for buffer altered
!	buffer marked as dirty and valid.
!
!--

BEGIN

BIND_COMMON;

LOCAL
    INDX,
    BFRD	: REF BBLOCK,
    INDX_ADDR;

INDX = (.BUFFER - .CACHE_HDR [F11BC$L_BUFBASE])/512 + 1;

BFRD = BFRD_ADDR (.INDX);

SERIAL_CACHE ();

IF .BFRD [BFRD$L_LBN] NEQ 0
THEN

! BFRD$L_LBN neq 0 means that this buffer is in the hash lookup list.
! We need to remove it from the list it is currently
! in prior to resetting the LBN field.
!

    BEGIN

    INDX_ADDR = LOOKUP_LBN (.BFRD [BFRD$L_LBN]);

    IF .(.INDX_ADDR)<0,16> EQL .INDX
    THEN
	(.INDX_ADDR)<0,16> = .BFRD [BFRD$W_NXTBFRD]
    ELSE
	BEGIN
	DO
	    INDX_ADDR = BBLOCK [ BFRD_ADDR (.(.INDX_ADDR)<0,16>), BFRD$W_NXTBFRD]
	UNTIL .(.INDX_ADDR)<0,16> EQL .INDX;

	(.INDX_ADDR)<0,16> = .BFRD [BFRD$W_NXTBFRD];
	END;
    END;

! Store the desired LBN and hook it up in the LBN hash list.
!

BFRD [BFRD$L_LBN] = .LBN;

INDX_ADDR = LOOKUP_LBN (.LBN);
BFRD [BFRD$W_NXTBFRD] = .(.INDX_ADDR)<0,16>;
(.INDX_ADDR)<0,16> = .INDX;

BFRD [BFRD$V_VALID] = 1;
BFRD [BFRD$V_DIRTY] = 1;

RELEASE_CACHE ();

END;					! end of routine RESET_LBN

GLOBAL ROUTINE MARK_DIRTY (BUFFER) : L_NORM NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine marks the indicated buffer for write-back.
!
! CALLING SEQUENCE:
!	MARK_DIRTY (ARG1)
!
! INPUT PARAMETERS:
!	ARG1: address of block buffer
!
! IMPLICIT INPUTS:
!	CURRENT_VCB: VCB of volume
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	buffer marked for write-back
!
!--

BEGIN

BIND_COMMON;

LOCAL
	BFRD	: REF BBLOCK,
	INDX0;

INDX0 = (.BUFFER - .CACHE_HDR [F11BC$L_BUFBASE])/512;

IF .INDX0<0,16> GEQU .CACHE_HDR [F11BC$W_BFRCNT]
THEN
    BUG_CHECK (BADBUFADR, 'buffer addr out of range');

BFRD = .CACHE_HDR [F11BC$L_BFRDBAS] + .INDX0*BFRD$S_BFRDDEF;

IF NOT .BFRD [BFRD$V_VALID] OR .BFRD [BFRD$W_CURPID] EQL 0
THEN
    BUG_CHECK (XQPERR, 'expect it to be valid and in-process');

BFRD [BFRD$V_DIRTY] = 1;

END;					! end of routine MARK_DIRTY

ROUTINE RETURN_BFRD (BFRD) : L_JSB_1ARG NOVALUE =

!++
!
! This routine completes the return of the given BFRD to the appropriate
! pool in the cache.  It expects that it has already been unhooked from
! the hash lists and the BFRL taken care of.
!
!--

BEGIN

MAP
    BFRD : REF BBLOCK;

BIND_COMMON;

LOCAL
    POOL,
    POOL_LRU	: REF BBLOCK;


POOL = .BFRD [BFRD$V_POOL];
POOL_LRU = CACHE_HDR [F11BC$Q_POOL_LRU] + .POOL*8;

! Credit our buffers in use count if this was on our in-process list.
!

IF .BFRD [BFRD$W_CURPID] NEQ 0
THEN
    BFRS_USED [.POOL] = .BFRS_USED [.POOL] - 1;

BFRD [BFRD$L_LBN] = 0;
BFRD [BFRD$L_UCB] = 0;
BFRD [BFRD$L_LOCKBASIS] = 0;
BFRD [BFRD$L_SEQNUM] = 0;
BFRD [BFRD$W_CURPID] = 0;
BFRD [BFRD$W_NXTBFRD] = 0;

! Remove from either the in-process list or it's current position in
! the cache LRU (whether curpid was zero or not) and move to the head
! of the cache LRU list.
!

REMQUE (.BFRD, BFRD);
INSQUE (.BFRD, POOL_LRU [QFLNK]);

END;

GLOBAL ROUTINE INVALIDATE (BUFFER) : L_NORM NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine invalidates the indicated buffer.
!
! CALLING SEQUENCE:
!	INVALIDATE (ARG1)
!
! INPUT PARAMETERS:
!	ARG1: address of block buffer
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	buffer contents forgotten
!
!--

BEGIN

BIND_COMMON;

LOCAL
	POOL,
	BFRD	: REF BBLOCK;

BFRD = ((.BUFFER - .CACHE_HDR [F11BC$L_BUFBASE])/512)*BFRD$S_BFRDDEF
	+ .CACHE_HDR [F11BC$L_BFRDBAS];

BFRD [BFRD$V_DIRTY] = 0;
BFRD [BFRD$V_VALID] = 0;

IF .BFRD [BFRD$W_CURPID] NEQ .(CTL$GL_PCB [PCB$L_PID])<0,16>
THEN
    BUG_CHECK (XQPERR, 'expected this to be in-process');

! Pull this buffer out of it's current position and place it at the
! front of the list so it will be the next buffer tossed off of our
! in-process list.
!

POOL = .BFRD [BFRD$V_POOL];
REMQUE (.BFRD, BFRD);
INSQUE (.BFRD, BFR_LIST [.POOL, QFLNK]);

IF .BUFFER EQL .BITMAP_BUFFER
THEN
    BITMAP_VBN = 0;

END;					! end of routine INVALIDATE

GLOBAL ROUTINE WRITE_HEADER : L_NORM NOVALUE  =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine writes out the currently resident file header.
!
! CALLING SEQUENCE:
!	WRITE_HEADER ()
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	FILE_HEADER: address of current file header
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	IO_STATUS: status of I/O transfer
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	checksum checked, header written
!
!--

BEGIN

BIND_COMMON;

EXTERNAL ROUTINE
	CHECKSUM	: L_NORM;	! compute file header checksum


! The checksum of the header should be good, since all routines that modify
! the header bless it with a new checksum when they are finished. Check the
! checksum and write the header.
!

IF NOT CHECKSUM (.FILE_HEADER)
THEN BUG_CHECK (WRTINVHDR, FATAL, 'ACP attempted to write an invalid file header');

WRITE_BLOCK (.FILE_HEADER);

END;					! end of routine WRITE_HEADER

GLOBAL ROUTINE WRITE_DIRTY (LOCKBASIS) : L_NORM NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine writes all buffers which were modified back to the
!	disk from whence they came.
!
! INPUT PARAMETERS:
!
! SIDE EFFECTS:
!	dirty buffers written.
!
!--

BEGIN

BIND_COMMON;

INCR POOL FROM 0 TO 2
DO
    BEGIN
    LOCAL
	I,
	QHEAD	: REF BBLOCK,
	BFRD	: REF BBLOCK;

    QHEAD = BFR_LIST [.POOL, QFLNK];
    BFRD = .QHEAD [QFLNK];

    I = .BFRS_USED [.POOL];

    UNTIL .I EQL 0
    DO
	BEGIN
	I = .I - 1;

	IF (.LOCKBASIS EQL 0
	    OR .BFRD [BFRD$L_LOCKBASIS] EQL .LOCKBASIS)
	    AND .BFRD [BFRD$V_DIRTY]
	THEN
	    WRITE_BLOCK (((.BFRD-.CACHE_HDR [F11BC$L_BFRDBAS])/BFRD$S_BFRDDEF)*512
			+ .CACHE_HDR [F11BC$L_BUFBASE]);

	BFRD = .BFRD [BFRD$L_QFL];
	END;

    IF .QHEAD NEQA .BFRD
    THEN
	BUG_CHECK (XQPERR, 'in-process queue screwed up');

    END;

END;			! of routine WRITE_DIRTY

GLOBAL ROUTINE TOSS_CACHE_DATA (LCKINDX) : L_NORM NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine invalidates all data blocks associated with
!	the given lock basis, after first writing dirty blocks.
!	The data sequence number is incremented, which invalidates
!	copies of these blocks on other nodes, and blocks found in
!	our cache will be marked invalid, causing them to be tossed
!	from the cache when the serialization lock is lowered.
!	Only the data block pool is scanned.
!
! SIDE EFFECTS:
!	dirty buffers written, appropriate buffers invalidated
!
!--

BEGIN

BIND_COMMON;

LOCAL
    I,
    LOCKBASIS,
    QHEAD	: REF BBLOCK,
    BFRD	: REF BBLOCK;

LOCKBASIS = .LB_BASIS [.LCKINDX];

QHEAD = BFR_LIST [1, QFLNK];
BFRD = .QHEAD [QFLNK];

I = .BFRS_USED [1];

UNTIL .I EQL 0
DO
    BEGIN
    I = .I - 1;

    IF .BFRD [BFRD$L_LOCKBASIS] EQL .LOCKBASIS
    THEN
	BEGIN

	IF .BFRD [BFRD$V_DIRTY]
	THEN
	    WRITE_BLOCK (((.BFRD-.CACHE_HDR [F11BC$L_BFRDBAS])/BFRD$S_BFRDDEF)*512
			+ .CACHE_HDR [F11BC$L_BUFBASE]);

	BFRD [BFRD$V_VALID] = 0;
	END;

    BFRD = .BFRD [BFRD$L_QFL];
    END;		! of loop through in-process data block pool

IF .QHEAD NEQA .BFRD
THEN
    BUG_CHECK (XQPERR, 'in-process data block queue screwed up');

LB_DATASEQ [.LCKINDX] = .LB_DATASEQ [.LCKINDX] + 1;

END;			! of routine TOSS_CACHE_DATA


GLOBAL ROUTINE KILL_CACHE (UCB) : L_NORM NOVALUE =

!++
!
! This routine scans through all BFRD's in the cache tossing out
! all those that match the specified UCB.
!
!--

BEGIN

BIND_COMMON;

LOCAL
    BFRD : REF BBLOCK,
    PIDINDX : WORD;

BFRD = .CACHE_HDR [F11BC$L_BFRDBAS];
PIDINDX = .CTL$GL_PCB [PCB$L_PID];

SERIAL_CACHE ();

INCR INDX0 FROM 0 TO (.CACHE_HDR [F11BC$W_BFRCNT] - 1)
DO
    BEGIN

    IF .BFRD [BFRD$L_UCB] EQLA .UCB
    THEN
	BEGIN

	IF .BFRD [BFRD$W_CURPID] NEQ 0
	THEN
	    BEGIN
	    IF .BFRD [BFRD$W_CURPID] EQL .PIDINDX
	    THEN
		BFRD [BFRD$V_VALID] = 0;	! it will get tossed on unlock
	    END
	ELSE
	    BEGIN
	    UNHOOK_BFRD (.INDX0+1, .BFRD);
	    RETURN_BFRD (.BFRD);
	    END;
	END;

    BFRD = .BFRD + BFRD$S_BFRDDEF;

    END;

RELEASE_CACHE ();

END;

GLOBAL ROUTINE WRONG_LOCKBASIS (HEADER) : L_NORM NOVALUE =

!++
!
! This routine returns the given buffer as a result of discovering
! we had the wrong lockbasis when finding it.
! If it was read from disk, we must invalidate it, as we stored the
! wrong lockbasis in its bfrd.  If it was found in the cache,
! simply return it and credit us for returning it.
!
!--

BEGIN

BIND_COMMON;

LOCAL
    POOL,
    BFRD	: REF BBLOCK,
    POOL_LRU	: REF BBLOCK;

SERIAL_CACHE ();

BFRD = ((.HEADER - .CACHE_HDR [F11BC$L_BUFBASE])/512)*BFRD$S_BFRDDEF
	+ .CACHE_HDR [F11BC$L_BFRDBAS];

IF .BFRD [BFRD$W_BFRL] EQL 0
THEN
    BFRD [BFRD$V_VALID] = 0
ELSE
    BEGIN
    POOL = .BFRD [BFRD$V_POOL];
    REMQUE (.BFRD, BFRD);
    BFRS_USED [.POOL] = .BFRS_USED [.POOL] - 1;
    BFRD [BFRD$W_CURPID] = 0;
    POOL_LRU = CACHE_HDR [F11BC$Q_POOL_LRU] + .POOL*8;
    INSQUE (.BFRD, .POOL_LRU [QBLNK]);
    END;

RELEASE_CACHE ();
END;

GLOBAL ROUTINE KILL_BUFFERS (POOL, LOCKBASIS) : L_NORM NOVALUE =

!++
!
! This routine scans through all BFRD's in the cache tossing out
! all those in the specified POOL for the CURRENT_UCB.
! If the directory data pool is specified, LOCKBASIS must match also.
!
!--

BEGIN

BIND_COMMON;

LOCAL
    BFRD : REF BBLOCK,
    BFRD_CNT : WORD,
    START_BFRD : WORD,
    PIDINDX : WORD;

BEGIN

BIND
    POOLCNT = CACHE_HDR [F11BC$W_POOLCNT] : VECTOR [,WORD];

START_BFRD = 0;

IF .POOL NEQ 0
THEN
    BEGIN
    START_BFRD = .POOLCNT [0];
    IF .POOL EQL 2
    THEN START_BFRD = .START_BFRD + .POOLCNT [1];
    END;

BFRD_CNT = .POOLCNT [.POOL];
END;

BFRD = .CACHE_HDR [F11BC$L_BFRDBAS] + .START_BFRD*BFRD$S_BFRDDEF;
PIDINDX = .CTL$GL_PCB [PCB$L_PID];

SERIAL_CACHE ();

INCR INDX0 FROM .START_BFRD TO (.START_BFRD + .BFRD_CNT - 1)
DO
    BEGIN

    IF .CURRENT_UCB EQL .BFRD [BFRD$L_UCB]
	AND (.POOL NEQ 1 OR
	    .BFRD [BFRD$L_LOCKBASIS] EQL .LOCKBASIS)
    THEN
	BEGIN

	IF .BFRD [BFRD$W_CURPID] NEQ 0
	THEN
	    BEGIN
	    IF .BFRD [BFRD$W_CURPID] EQL .PIDINDX
	    THEN
		BFRD [BFRD$V_VALID] = 0;	! it will get tossed on unlock
	    END
	ELSE
	    BEGIN
	    UNHOOK_BFRD (.INDX0+1, .BFRD);
	    RETURN_BFRD (.BFRD);
	    END;
	END;

    BFRD = .BFRD + BFRD$S_BFRDDEF;

    END;

RELEASE_CACHE ();

END;

END
ELUDOM
