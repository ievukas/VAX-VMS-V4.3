	.TITLE	SYSCREPRC CREATE PROCESS SYSTEM SERVICE
	.IDENT	'V04-002'

;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
; FACILITY: EXECUTIVE, SYSTEM SERVICES
;
; ABSTRACT: SYSCREPRC IMPLEMENTS THE CREATE PROCESS SYSTEM SERVICE.
;
; ENVIRONMENT: KERNEL MODE
;
; AUTHOR: R. HUSTVEDT	, CREATION DATE: 29-NOV-76
;
; MODIFIED BY:
;
;	V04-002	WMC0001		Wayne Cardoza		14-Sep-1984
;		Fix LJK0290 to only increment counts for detached processes.
;
;	V04-001	LJK0290		Lawrence J. Kenah	12-Sep-1984
;		Do not count process in SYS$GW_xJOBCNT cell until all error
;		conditions have been tested. This eliminates the need to 
;		worry about the xJOBCNT cells along error paths.
;
;	V03-037	ACG0432		Andrew C. Goldstein,	9-Jul-1984  17:27
;		Add PRC$V_NOPASSWORD flag bit, remove DETACH priv
;		requirement from NOUAF, CLISPEC,  and INTER flags.
;		Add and initialize JIB$L_ORG_BYTLM.
;
;	V03-036	PRD0100		Paul R. DeStefano	27-Jun-1984
;		Correct placement of label 10001$ in routine ACTIVATE.
;
;	V03-035	LJK0284		Lawrence J. Kenah	15-May-1984
;		Make SS$_INSSWAPSPACE into a useful error return instead
;		of a system crasher.
;
;	V03-034	MHB0155		Mark Bramhall		 1-May-1984
;		Propagate PCB${V|M}_SECAUDIT to new process's PCB.
;
;	V03-033	RAS0297		Ron Schaefer		18-Apr-1984
;		Put back bogus translation of SYS$DISK for compatibility
;		with past history.  Remove KPL0110 and KPL0111.
;
;	V03-032	KPL0111		Peter Lieberwirth	17-Apr-1984
;		The use of IOC$TRNADEVNAM, in V03-029, caused the device
;		string in PQB$T_DISK not to have a trailing colon.  This
;		caused PROCSTRT to create an invalid translation for
;		SYS$DISK.  Fix here by re-appending the colon.
;
;	V03-031	MHB0136		Mark Bramhall		12-Apr-1984
;		Add support for PRC$V_CLISPEC.
;
;	V03-030	MHB0134		Mark Bramhall		10-Apr-1984
;		Creators w/o JIBs => Username = SYSTEM, Account = binary nulls.
;		Account names with a leading binary null byte are special:
;			<0><0>... => <0><0>...	All binary nulls stays as is.
;			<0><x>... => <x>...< >	Others are shifted left one.
;		Move new spawn CLI information to PQB from P1 space.
;
;	V03-029	KPL0110		Peter Lieberwirth	31-Mar-1984
;		Translate SYS$DISK by calling IOC$TRANDEVNAM, which
;		uses $TRNLNM.  This call replaces obsolete $TRNLOG use.
;
;	V03-028	SRB0119		Steve Beckhardt		26-Mar-1984
;		Another round in the broken branch grame.
;
;	V03-027	LJK0263		Lawrence J. Kenah	29-Feb-1984
;		We're playing the broken branch game again. The various calls
;		to EXE$DEANONPAGED need more than word displacement.
;
;	V03-026 HH0002		Hai Huang		1-Feb-1984
;		Add job-wide mount support, i.e. initialize mount listhead
;		in JIB.
;
;	V03-025	LJK0259		Lawrence J. Kenah	23-Jan-1984
;		Fix incorrect register usage bug in PQB deallocation.
;
;	V03-024	LJK0258		Lawrence J. Kenah	18-Jan-1984
;		Fix bug introduced by LJK0257. Make JIB creation code handle
;		the case of the swapper, a process that does not own a JIB.
;
;	V03-023	ACG0385		Andrew C. Goldstein,	11-Jan-1984  18:39
;		Make MAXDETACH and MAXJOBS JIB fields words
;
;	V03-022	LJK0257		Lawrence J. Kenah	21-Dec-1983
;		Make changes to support larger PQB. Remove support for ACCOUNT
;		and USERNAME fields in P1 space. Use $TRNLNM to pick up
;		translation of SYS$DISK. Perform general cleanup.
;
;	V03-021	TMK0001		Todd M. Katz		12-Oct-1983
;		Add JTQUOTA (job-wide logical name table creation quota)
;		to the process quota block and as a quota in the quota list 
;		for SYS$CREPRC. No special processing is required for this
;		new quota item.
;
;	V03-020	JWT0138		Jim Teague		11-Oct-1983
;		Fix broken branch to SCH$CHSE.
;
;	V03-019	RAS0181		Ron Schaefer		05-Sep-1983
;		Convert creation of SYS$INPUT, SYS$OUTPUT, SYS$ERROR,
;		and SYS$DISK logical names to use $CRELNM.
;
;	V03-018	WMC0008		Wayne Cardoza		01-Aug-1983
;		New item list codes for logical name attributes.
;
;	V03-017	ACG0347		Andrew C. Goldstein,	1-Aug-1983  13:21
;		Fix register use bug in ACG0335
;
;	V03-016	WMC0007		Wayne Cardoza		28-Jul-1983
;		Move bumping of interactive and batch counts here.
;
;	V03-015	WMC0006		Wayne Cardoza		05-JUL-1983
;		No privilege needed for interactive subprocess.
;
;	V03-014	CWH1010		CW Hobbs		20-Jun-1983
;		Add a comment which calls attention to an order dependency
;		in the call to EXE$IPID_TO_EPID.
;
;	V03-013	ACG0335		Andrew C. Goldstein,	9-May-1983  16:26
;		Propagate default file protection in PCB; copy extended
;		rights list to created process.
;
;	V03-012	WMC0005		Wayne Cardoza		27-Apr-1983
;		Change PSECT of detach code.
;		SS$_INSSWAPSPACE for no swap space.
;
;	V03-011	WMC0004		Wayne Cardoza		14-Apr-1983
;		New STSFLG flags.
;
;	V03-010	WMC0003		Wayne Cardoza		31-Mar-1983
;		Second half of the detach changes.
;
;	V03-009	WMC0002		Wayne Cardoza		10-Mar-1983
;		Liberalized rules on creation of detached processes.
;
;	V03-008	ACG0318		Andrew C. Goldstein,	8-Mar-1983  20:27
;		Initialize new ARB fields in created process
;
;	V03-007	MTR0001		Michael T. Rhodes	28-Feb-1983
;		Change the privilege requirements for setting the initial
;		process state flags to require only the creator to have
;		privilege.
;
;	V03-006	CWH1002		CW Hobbs		24-Feb-1983
;		Create new extended process ident PCB$L_EPID.  Return the
;		extended pid to the pidadr argument if specifed.  The
;		extended pid of a subprocess owner propagates to the
;		new PCB$L_EOWNER field.
;
;	V03-005	CWH1001		CW Hobbs		15-Feb-1983
;		Change from sequential to round-robin PIX allocation.
;
;	V03-004	WMC0001		Wayne Cardoza		18-Oct-1982
;		Add support for item list argument for page file control.
;
;	V03-003	LJK48272	Lawrence J. Kenah	10-Aug-1982
;		Insure that PCB$L_JIB is clear before allocating PQB
;		in case PQB allocation fails. Error code assumes that
;		contents of JIB field are always valid if nonzero.
;		Remove $PRDEF and $SSDEF calls.
;
;	V03-002	LJK0169		Lawrence J. Kenah	2-Jun-1982
;		Insure that revised CPU limit is stored in PQB along error
;		paths. Use ROTL to perform unsigned divide by two.
;
;--
	.PAGE
	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;
	$ACLDEF				; DEFINE ACL BLOCK
	$ARBDEF				; DEFINE ACCESS RIGHTS BLOCK
	$DYNDEF				; DATA STRUCTURE IDENTIFIERS
	$IPLDEF				; DEFINE INTERRUPT PRIORITY LEVELS
	$JIBDEF				; DEFINE JOB INFORMATION BLOCK
	$LNMDEF				; DEFINE LNM OFFSETS
	$LNMSTRDEF			; DEFINE LNM BLOCK OFFSETS
	$PCBDEF				; DEFINE PCB OFFSETS
	$PFNDEF				; DEFINE PFN CONSTANTS
	$PHDDEF				; DEFINE PHD OFFESTS
	$PQBDEF				; DEFINE PROCESS QUOTA BLOCK
	$PQLDEF				; DEFINE PROCESS QUOTA LIST CODES
	$PRCDEF				; DEFINE $CREPRC STATUS FLAGS
	$PRIDEF				; DEFINE PRIORITY INCREMENT CLASSES
	$PRVDEF				; DEFINE PRIVILEGE BITS

;***** Temporary definitions for ARB cells until SDL is fixed to
;***** expand $ARBDEF correctly.
;
ARB$R_RIGHTSDESC=48
ARB$R_LOCALRIGHTS=56
;
; MACROS:
;

;
; MACRO TO CREATE STSFLG MAPPING AND PRIVILEGE CHECK TABLES:
;	STSNAM		OPTIONAL STATUS BIT NAME TO SET IN PCB
;	PRVNAM		OPTIONAL REQUIRED PRIVILEGE BIT NAME
;	NOSUBPRV	OPTIONAL NO PRIVILEGE REQUIRED IF SUBPROCESS FLAG
;
	.MACRO	STSFLAG	STSNAM,PRVNAM,NOSUBPRV
	.IF	B,PRVNAM
	.BYTE	-1
	.IFF
	.IF	B,NOSUBPRV
	.BYTE	PRV$V_'PRVNAM
	.IFF
	.BYTE	PRV$V_'PRVNAM ! ^X80
	.ENDC
	.ENDC
	.IF	B,STSNAM
	.BYTE	-1
	.IFF
	.BYTE	PCB$V_'STSNAM
	.ENDC
	.ENDM	STSFLAG

;
; MACRO TO CALL STRING MOVING AND VERIFICATION ROUTINE
;
	.MACRO	MOVSTRING LIM=15,SRC,DST
	BSBW	MOVSTR			; CALL MOVE SUBROUTINE
	.BYTE	LIM			; COUNT LIMIT
	.BYTE	SRC@-2			; SOURCE OFFSET FROM AP
	.WORD	PQB$T_'DST		; DESTINATION OFFSET IN PQB
	.ENDM	MOVSTRING	

;
; EQUATED SYMBOLS:
;

PIDADR=4				; PID ADDRESS
IMAGE=8					; IMAGE NAME
INPUT=12				; INPUT LOGICAL NAME DESCRIPTOR
OUTPUT=16				; OUTPUT LOGICAL NAME DESCRIPTOR
ERROR=20				; ERROR LOGICAL NAME DESCRIPTOR
PRVADR=24				; PRIVILEGE MASK ADDRESS
QUOTA=28				; QUOTA BUFFER POINTER
PRCNAM=32				; PROCESS NAME DESCRIPTOR
BASPRI=36				; BASE PRIORITY
UIC=40					; UIC
MBXUNT=44				; MAILBOX UNIT NUMBER
STSFLG=48				; STATUS FLAG MASK
ITMLST=52				; ITEM LIST

PQL_V_DEDUCT=0				; DEDUCTIBLE QUOTA FLAG
ITMLST_ARG=13				; ARGUMENT NUMBER FOR THE ITEM LIST

CURPCB = -4				; OFFSET FROM FP TO SAVED R4

;
; OWN STORAGE:
;

	.PSECT	Y$EXEPAGED,BYTE		; PAGEABLE PSECT

	ASSUME	PRC$V_SSRWAIT  EQ  0
	ASSUME	PRC$V_SSFEXCU  EQ  1
	ASSUME	PRC$V_PSWAPM   EQ  2
	ASSUME	PRC$V_NOACNT   EQ  3
	ASSUME	PRC$V_BATCH    EQ  4
	ASSUME	PRC$V_HIBER    EQ  5
	ASSUME	PRC$V_NOUAF    EQ  6
	ASSUME	PRC$V_NETWRK   EQ  7
	ASSUME	PRC$V_DISAWS   EQ  8
	ASSUME	PRC$V_DETACH   EQ  9
	ASSUME	PRC$V_INTER    EQ  10
	ASSUME	PRC$V_IMGDMP   EQ  11
	ASSUME	PRC$V_CLISPEC  EQ  12
	ASSUME	PRC$V_NOPASSWORD EQ  13

STSFLGTBL:				; TRANSLATION TABLE FOR STATUS FLAG BITS
	STSFLAG	SSRWAIT			; BIT 0 => RESOURCE WAIT
	STSFLAG	SSFEXCU			; BIT 1 => SYSTEM SERVICE FAIL EXCEPTION
					;	   FOR USER MODE
	STSFLAG	PSWAPM,PSWAPM		; BIT 2 => PROCESS SWAP MODE
	STSFLAG	NOACNT,NOACNT		; BIT 3 => NO ACCOUNTING MESSAGE
	STSFLAG	BATCH,DETACH		; BIT 4 => BATCH
	STSFLAG	HIBER			; BIT 5 => HIBERNATE BEFORE CALLING
					;	   INITIAL IMAGE IN PROCSTRT
	STSFLAG	LOGIN			; BIT 6 => LOGIN WITHOUT READING AUTH FILE
	STSFLAG	NETWRK,DETACH		; BIT 7 => NETWORK
	STSFLAG	DISAWS			; BIT 8 => DISABLE WORKING SET ADJUST
	STSFLAG				; BIT 9 => DETACH
	STSFLAG	INTER			; BIT 10 => INTERACTIVE
	STSFLAG				; BIT 11 => IMAGE DUMP
	STSFLAG				; BIT 12 => PASS ON CLI SPECIFICATIONS
	STSFLAG				; BIT 13 => NO USERNAME DIALOGUE
STSFLGCNT=<.-STSFLGTBL>@-1		; NUMBER OF STATUS FLAGS

; THE FOLLOWING TEXT FIELDS ARE USED WHEN THE CREATING PROCESS (SUCH AS THE
; SWAPPER) DOES NOT HAVE A JIB.

DEFAULT_NAMES:
	.ASCII	'SYSTEM'		; Username is SYSTEM, blank padded
	.BYTE	^A' ' [JIB$S_USERNAME - <. - DEFAULT_NAMES>]
	.BYTE	0 [JIB$S_ACCOUNT]	; Account name is binary nulls
	ASSUME	<. - DEFAULT_NAMES> EQ <JIB$S_USERNAME + JIB$S_ACCOUNT>

; LOGICAL NAME DATA FOR USE IN TRANSLATING SYS$DISK

LNM_TBL:.ASCID	\LNM$FILE_DEV\
LNM_ATTR = ^X0103

	.PAGE
	.SBTTL	EXE$CREPRC - CREATE PROCESS SYSTEM SERVICE
;++
; FUNCTIONAL DESCRIPTION:
;	EXE$CREPRC CREATES A NEW PROCESS ACCORDING TO THE 
;	SUPPLIED PARAMETERS.  THE NEW PROCESS MAY BE EITHER A SUB-PROCESS
;	OR AN INDEPENDENT, DETACHED PROCESS.
;
; CALLING SEQUENCE:
;	CALLG	ARGLIST,EXE$CREPRC
;
; INPUT PARAMETERS:
;	PIDADR(AP) - ADDRESS AT WHICH TO RETURN PID OF CREATED PROCESS
;	IMAGE(AP)  - ADDRESS OF IMAGE NAME STRING DESCRIPTOR
;	INPUT(AP)  - ADDRESS OF INPUT NAME STRING DESCRIPTOR
;	OUTPUT(AP) - ADDRESS OF OUTPUT NAME STRING DESCRIPTOR
;	ERROR(AP)  - ADDRESS OF ERROR LOGICAL NAME STRING DESCRIPTOR
;	PRVADR(AP) - ADDRESS OF PRIVILEGE MASK FOR CREATED PROCESS
;	QUOTA(AP)  - POINTER TO QUOTA BUFFER
;	PRCNAM(AP) - ADDRESS OF PROCESS NAME STRING DESCRIPTOR
;	BASPRI(AP) - BASE PRIORITY FOR CREATED PROCESS
;	UIC(AP)    - UIC FOR CREATED PROCESS(0 => SUB-PROCESS)
;	MBXUNT(AP) - MAILBOX UNIT NUMBER FOR TERMINATION MESSAGES
;	STSFLG(AP) - STATUS FLAG SETTINGS FOR CREATED PROCESS
;	ITMLST(AP) - ITEM LIST 
;	R4 - ADDRESS OF CURRENT PROCESS CONTROL BLOCK
;
;			BIT	MEANING
;			---	-------
;			 0	RESOURCE WAIT DISABLE
;			 1	SYSTEM SERVICE FAIL EXCEPTION ENABLE
;			 2	PROCESS SWAP MODE
;			 3	ACCOUNTING MESSAGE DISABLE
;			 4	BATCH INDICATOR
;			 5	HIBERNATE BEFORE CALLING INITIAL IMAGE
;			 6	BYPASS LOGIN VERIFICATION FOR DETACHED
;				PROCESS.
;			 7	NETWORK INDICATOR
;			 8	DISABLE WORKING SET ADJUSTMENT
;			 9	DETACHED PROCESS
;			10	INTERACTIVE INDICATOR
;			11	IMAGE DUMP ON FATAL ABORT
;			12	PASS ON CLI SPECIFICATIONS
;
;
; OUTPUT PARAMETERS:
;	R0  -  COMPLETION STATUS CODE
;	@PIDADR(AP) - PROCESS ID (PID) OF CREATED PROCESS
;
; COMPLETION CODES:
;	SS$_NORMAL   -   SUCCESSFUL COMPLETION
;	SS$_ACCVIO   -   ACCESS VIOLATION
;	SS$_DUPLNAM  -   DUPLICATE PROCESS NAME
;	SS$_EXQUOTA  -   EXCEEDED QUOTA
;	SS$_INSFMEM  -   INSUFFICIENT MEMORY AVAILABLE
;	SS$_IVLOGNAM -   INVALID LOGICAL NAME
;	SS$_IVQUOTAL -   INVALID QUOTA LIST
;	SS$_IVSTSFLG -   INVALID STATUS FLAG ARGUMENT
;	SS$_NOPRIV   -   NO PRIVILEGE FOR SPECIFIED OPERATION
;
; SIDE EFFECTS:
;	IF NO ERRORS ARE DETECTED, A NEW PROCESS WILL HAVE BEEN ACTIVATED
;	AND MARKED NON-RESIDENT.  THE INITIAL INSWAP FOR THIS PROCESS
;	WILL BE FROM THE SHELL PROCESS.  EXECUTION FOR THIS PROCESS
;	BEGINS IN THE ROUTINE EXE$PROCSTRT WHICH WILL MOVE THE INFORMATION
;	FROM THE PROCESS QUOTA BLOCK TO THE APPROPRIATE LOCATIONS
;	IN THE PROCESS CONTEXT.  CONTROL WILL THEN BE GIVEN TO THE
;	SPECIFIED IMAGE.
;
;--

	.ENABL	LSB
EXE$CREPRC::				; CREATE PROCESS SYSTEM SERVICE
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>	; SAVE ALL REGISTERS
	PUSHL	R4			; SAVE CREATOR'S PCB ADDRESS
	PUSHL	PIDADR(AP)		; SAVE PID RETURN ADDRESS
	BEQL	10$			; NONE, NO PROBE
	IFNOWRT	#4,@(SP),20$		; CHECK FOR WRITABLE
10$:	MOVL	UIC(AP),R11		; FETCH UIC FOR CREATED PROCESS
	BEQL	29$			; NOT SPECIFIED
	CMPL	R11,PCB$L_UIC(R4)	; IS IT SAME UIC AS CREATOR
	BEQL	30$			; NO PRIVILEGE NEEDED
	IFPRIV	DETACH,30$		; FULL DETACH PRIVILEGE
	IFPRIV	CMKRNL,30$		; OR CHANGE MODE TO KERNEL
	MOVZWL	#SS$_NOPRIV,R0		; NO, SET ERROR CODE
15$:	RET				; RETURN

20$:	MOVZWL	#SS$_ACCVIO,R0		; SET ERROR CODE FOR ACCESS VIOLATION
	RET				; RETURN

; FAST ALLOCATION OF PQB FAILED. DO IT THE HARD WAY

26$:	BSBW	ALLOCPQB		; ALLOCATE ANOTHER PQB
	MOVL	R2,R9			; ASSUME THAT IT SUCCEEDED
	BLBS	R0,50$			; RESUME CREATION IF SUCCESSFUL
	BRW	ABRT2			; ERROR PATH FOR PQB ALLOCATION FAILURE

29$:	BBC	#PRC$V_DETACH,STSFLG(AP),30$
	MOVL	PCB$L_UIC(R4),R11	; DETACHED PROCESS (SAME UIC) REQUESTED
30$:	JSB	EXE$ALLOCPCB		; ALLOCATE PCB, WAIT IF NECESSARY
	BLBC	R0,15$			; RETURN ERROR IF FAILURE
	MOVL	R2,R10			; SAVE ADDRESS OF NEW PCB
	MOVC5	#0,(SP),#0,#<PCB$C_LENGTH-12>,12(R10)	; CLEAR PCB
	MOVL	CURPCB(FP),R4		; RESTORE CREATOR PCB ADDRESS
	BICL3	#^C<PCB$M_SECAUDIT>,-	; PROPAGATE (ONLY) MANDATORY AUDITING
		PCB$L_STS(R4),PCB$L_STS(R10) ;  FROM PARENT TO NEW PCB
	REMQUE	@EXE$GL_PQBFL,R9	; ATTEMPT FAST PQB ALLOCATION
	BVS	26$			; OUT IF LINE IF FAILURE
;
;	INITIALIZE NEW PCB		
;
50$:	TSTL	R11			; IS THIS A DETACHED CREATE?
	BNEQ	51$			; YES, GO ALLOCATE A NEW JIB
	MOVL	PCB$L_JIB(R4),R2	; GET JIB ADDRESS OF PARENT
	MOVL	R2,PCB$L_JIB(R10)	; SAVE POINTER TO JIB IN OFFSPRING
	INCW	JIB$W_PRCCNT(R2)	; ADD ANOTHER SUBPROCESS
	SUBL	#SWP$C_SHELLPFIL,JIB$L_PGFLCNT(R2); CHARGE FOR SHELL PAGES
	BLSS	23$			; BR IF OUT OF PAGE FILE QUOTA
	CMPW	JIB$W_PRCCNT(R2),JIB$W_PRCLIM(R2) ; OVER LIMIT?
	BLEQU	56$			; IF LEQU NO, CONTINUE
23$:	MOVZWL	#SS$_EXQUOTA,R0		; SET ERROR STATUS
24$:	BRW	ABORT			; YES ABORT

51$:	JSB	EXE$ALLOCJIB		; ALLOCATE JIB FOR MASTER PROCESS
	BLBC	R0,24$			; BR IF NO SPACE AVAILABLE
	MOVAL	JIB$L_MTLFL(R2),JIB$L_MTLFL(R2) ; INITIALIZE MOUNT LISTHEAD
	MOVAL	JIB$L_MTLFL(R2),JIB$L_MTLBL(R2) ; 
	MOVL	R2,PCB$L_JIB(R10)	; SAVE POINTER TO JIB

; THE USERNAME AND ACCOUNT FIELDS OF THE CREATOR'S JIB ARE MOVED INTO THE
; NEW JIB. THE REST OF THE JIB IS CLEARED. THE TWO ASSUME STATEMENTS INSURE
; THAT THE JIB LAYOUT ALLOWS ALL OF THESE SHENANIGANS TO BE ACCOMPLISHED
; WITH A SINGLE MOVC5 INSTRUCTION.

	ASSUME JIB$T_USERNAME EQ 12
	ASSUME JIB$T_ACCOUNT EQ <12 + JIB$S_USERNAME>

	MOVL	PCB$L_JIB(R4),R3	; GET JIB ADDRESS OF CREATOR
	BNEQ	53$			; JIB EXISTS, GO USE IT

; THE SWAPPER PROCESS DOES NOT HAVE A JIB. LOAD R3 WITH THE ADDRESS OF SOME
; TEXT FIELDS THAT LOAD THE NEW JIB WITH A DEFAULT USERNAME AND ACCOUNT.

	MOVAB	DEFAULT_NAMES-JIB$T_USERNAME,R3 ; GET STRING ADDRESS
53$:	MOVC5	#<JIB$S_USERNAME + JIB$S_ACCOUNT>,-
		JIB$T_USERNAME(R3),-	; CREATOR'S JIB IS SOURCE
		#0,-			; FILL THE REST WITH ZEROS
		#<JIB$C_LENGTH-12>,-
		JIB$T_USERNAME(R2)	; NEW JIB IS DESTINATION

; Check the account name for a leading binary null.  Account names with
; a leading binary null are special, reserved to DIGITAL, account names.
; The following account name combinations are possible:
;	<x>...		Normal account name; left as is.
;	<0><0>...	Initial startup account name; left as is.
;	<0><x>...	Special account name; shifted left one place.

	MOVL	PCB$L_JIB(R10),R2	; Re-address offspring's JIB
	TSTB	JIB$T_ACCOUNT(R2)	; A leading binary null byte?
	BNEQ	56$			; Nope, leave account name as is
	TSTB	JIB$T_ACCOUNT+1(R2)	; Anything after the null to shift?
	BEQL	56$			; Nope, leave account name alone
	MOVC5	#JIB$S_ACCOUNT-1,-	; Move all but the first byte
		JIB$T_ACCOUNT+1(R2),-	;  of the account name,
		#^A' ',-		;   padding with a blank,
		#JIB$S_ACCOUNT,-	;    into the full
		JIB$T_ACCOUNT(R2)	;     account name

56$:	MOVAL	PCB$L_ASTQFL(R10),PCB$L_ASTQFL(R10)	; SET UP AST Q HEADER
	MOVAL	PCB$L_ASTQFL(R10),PCB$L_ASTQBL(R10)	;
	MOVB	#^X0F,PCB$B_ASTEN(R10)			; SET ALL AST ENABLES
	MOVAL	PCB$L_LOCKQFL(R10),PCB$L_LOCKQFL(R10)	; SET UP LOCK Q HEADER
	MOVAL	PCB$L_LOCKQFL(R10),PCB$L_LOCKQBL(R10)
	MOVL	CURPCB(FP),R4				; RESTORE CREATOR PCB ADDRESS
	MOVL	PCB$Q_PRIV+ARB$L_RIGHTSLIST+8(R4),R6	; GET EXTENDED RIGHTS LIST, IF ANY
	MOVL	PCB$L_DEFPROT(R4),PCB$L_DEFPROT(R10)	; COPY DEFAULT FILE PROTECTION
	BBC	#31,SP,57$				; BRANCH IF NOT INITIAL CREATE
	MOVZWL	SYS$GW_FILEPROT,PCB$L_DEFPROT(R10)	; SET SYSTEM FILE PROTECTION
57$:	MOVC3	#ARB$C_LENGTH,PCB$Q_PRIV(R4),PCB$Q_PRIV(R10) ; COPY ENTIRE ARB
	MOVAB	PCB$Q_PRIV(R10),PCB$L_ARB(R10)		; SET ADDRESS OF ARB
	MOVAB	PCB$Q_PRIV+ARB$R_RIGHTSDESC(R10),-
		PCB$Q_PRIV+ARB$L_RIGHTSLIST(R10)	; ADDR OF LOCAL RIGHTS DESC
	MOVAB	PCB$Q_PRIV+ARB$R_LOCALRIGHTS(R10),-
		PCB$Q_PRIV+ARB$R_RIGHTSDESC+4(R10)	; ADDR OF LOCAL RIGHTS LIST
	TSTL	R6					; SEE IF EXTENDED RIGHTS LIST PRESENT
	BEQL	59$					; BRANCH IF NONE
	CLRL	PCB$Q_PRIV+ARB$L_RIGHTSLIST+8(R10)	; MARK NONE ALLOCATED YET
	MOVZWL	ACL$W_SIZE(R6),R1			; GET SIZE
	JSB	EXE$ALLOCBUF				; AND ALLOCATE A NEW ONE
	BLBS	R0,58$					; KEEP GOING IF SUCCESS
	BRW	ABORT					; ABORT CREATION

58$:	MOVL	R2,R7					; SAVE ADDRESS
	MOVL	R2,PCB$Q_PRIV+ARB$L_RIGHTSLIST+8(R10)	; STORE IN PCB
	MOVC3	R1,(R6),(R7)				; COPY RIGHTS LIST CONTENTS
	MOVAB	12(R7),4(R7)				; SET DESCRIPTOR POINTER
59$:	MOVW	MBXUNT(AP),PCB$W_TMBU(R10)		; TERMINATION MAILBOX UNIT
	MOVW	SWP$GL_SHELLSIZ,PCB$W_PPGCNT(R10)	; AND PROCESS PAGE COUNT
;
;	INITIALIZE QUOTA BUFFER
;
	MOVC5	#0,(SP),#0,#<PQB$C_LENGTH-12>,12(R9)	; CLEAR QUOTA BUFFER
	MOVSTRING	LIM=15,-	; MOVE PROCESS NAME TO PQB TO VALIDATE
		SRC=PRCNAM,-		; FROM PROCESS NAME DESCRIPTOR
		DST=IMAGE		; TO IMAGE SLOT IN PQB
	MOVZBL	PQB$T_IMAGE(R9),R6	; FETCH STRING LENGTH FROM BUFFER
	BEQL	60$			; NO PROCESS NAME, NULL STRING
	INCL	R6			; INCLUDE COUNT BYTE
	MOVC3	R6,PQB$T_IMAGE(R9),PCB$T_LNAME(R10)	; SET INTO NEW PCB
	CLRQ	PQB$T_IMAGE(R9)		; CLEAR IMAGE NAME LENGTH
60$:	MOVL	CURPCB(FP),R4		; RESTORE PCB ADDRESS
	MOVQ	@PCB$L_PHD(R4),R0	; GET PRIVILEGE MASK
	MOVQ	R0,R2			; ASSUME SAME PRIVILEGES
	MOVL	PRVADR(AP),R7		; FETCH ADDRESS OF PRIVILEGE MASK
	BEQL	70$			; NONE SPECIFIED
	IFNORD	#8,(R7),125$		; ERROR IF NOT READABLE
	MOVQ	(R7),R2			; FETCH NEW PRIVILEGE MASK
	IFPRIV	SETPRV,70$		; SKIP MINIMIZATION IF SETPRV
	MCOML	R0,R0			; INVERT FOR BIT CLR
	MCOML	R1,R1			;
	BICL	R0,R2			; MINIMIZE PRIVILEGES
	BICL	R1,R3			; IF CALLER IS NOT PRIVILEGED ENOUGH
70$:	MOVQ	R2,PQB$Q_PRVMSK(R9)	; SET PRIVILEGES IN BUFFER
	EXTZV	#0,#5,BASPRI(AP),R0	; FETCH DESIRED BASE PRIORITY
	SUBL3	R0,#31,R0		; CONVERT TO INTERNAL PRIORITY
	IFPRIV	SETPRI,100$		; SKIP MINIMIZATION IF PRIVILEGE
	CMPB	R0,PCB$B_PRIB(R4)	; OTHERWISE MINIMIZE WITH CALLERS BASE
	BGEQU	100$			; GOOD VALUE, USE IT
	MOVB	PCB$B_PRIB(R4),R0	; NO, USE CALLERS BASE PRIORITY
100$:	MOVB	R0,PCB$B_PRIB(R10)	; SET IN NEW PCB
	MOVB	R0,PCB$B_PRI(R10)	; AS BOTH CURRENT AND BASE PRIORITY
	MOVL	R11,PCB$L_UIC(R10)	; STORE UIC FOR NEW PROCESS
	BNEQ	110$			; BR IF IT WAS SPECIFIED
	MOVL	PCB$L_UIC(R4),PCB$L_UIC(R10)	; OTHERWISE USE UIC OF CREATOR
	MOVL	PCB$L_PID(R4),PCB$L_OWNER(R10)	; AND INDICATE SUBPROCESS
	MOVL	PCB$L_EPID(R4),PCB$L_EOWNER(R10); AND ALSO COPY THE EXTENDED PID
110$:	MOVZWL	SCH$GL_MAXPIX,R7	; INITIALIZE INDEX FOR NAME CHECK
	TSTL	R6			; ANY LOGICAL NAME FOR NEW PROCESS?
	BEQL	140$			; NO, SKIP SEARCH
120$:	MOVL	@SCH$GL_PCBVEC[R7],R8	; FETCH A PCB ADDRESS
	CMPW	PCB$W_GRP(R8),PCB$W_GRP(R10)	; SAME GROUP?
	BNEQ	130$			; NO, TRY ANOTHER
	CMPC3	R6,PCB$T_LNAME(R10),PCB$T_LNAME(R8)	; COMPARE NAMES
	BNEQ	130$			; NO MATCH, CONTINUE
	MOVZWL	#SS$_DUPLNAM,R0		; SET DUPLICATE NAME CODE
	BRW	ABORT			; AND ABORT CREATION

125$:	BRW	ACCVIO			; GIVE ACCESS VIOLATION AND ABORT
126$:	BUG_CHECK KRPEMPTY,FATAL	; OUT-OF-LINE KRP ALLOCATION BUGCHECK
130$:	SOBGTR	R7,120$			; CONTINUE SEARCH
140$:	MOVSTRING	LIM=255,-	; MOV IMAGE NAME TO BUFFER
			SRC=IMAGE,-	; FROM IMAGE STRING DESCRIPTOR
			DST=IMAGE	; TO PQB$T_IMAGE
	MOVSTRING	LIM=255,-	; MOVE INPUT LOGICAL NAME TO BUFFER
			SRC=INPUT,-	; FROM INPUT STRING DESCRIPTOR
			DST=INPUT	; TO PQB$T_INPUT
	MOVSTRING	LIM=255,-	; MOVE OUTPUT LOGICAL NAME TO BUFFER
			SRC=OUTPUT,-	; FROM OUTPUT STRING DESCRIPTOR
			DST=OUTPUT	; TO PQB$T_OUTPUT
	MOVSTRING	LIM=255,-	; MOVE ERROR LOGICAL NAME TO BUFFER
			SRC=ERROR,-	; FROM ERROR STRING DESCRIPTOR
			DST=ERROR	; TO PQB$T_ERROR

	MOVB	#^B1111,PQB$B_MSGMASK(R9) ; DEFAULT MESSAGE FLAGS = ALL OF THEM
	BBC	#31,SP,1401$		; IF SYSTEM SPACE STACK
	BRW	145$			; THEN NO P1 SPACE DATA BASE AVAILABLE
1401$:	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	; SAVE MOVC REGISTERS

;
; TRANSLATE SYS$DISK USING LNM$SEARCH_ONE.  
; THIS TRANSLATES EXACTLY ONCE AND PASSES THE EQUIVALENCE STRING TO
; THE CREATED PROCESS.  COMPLETELY BOGUS RESULTS WILL OCCUR IF THIS
; TRANSLATION IS NOT EITHER A SYSTEM-WIDE LOGICAL NAME OR A PHYSICAL
; DEVICE NAME.  THIS TOTALLY BOGUS IMPLEMENTATION MUST REMAIN THIS WAY
; FOR COMPATIBILITY WITH PREVIOUS RELEASES.
;
; ALLOCATE A KERNEL REQUEST PACKET TO CONTAIN THE EQUIVALENCE STRING
; (AND LOGICAL NAME WORK AREA) FOR LNM$SEARCH_ONE.

	MOVAB	G^CTL$GL_KRPFL,R7	; GET KRP LISTHEAD
	REMQUE	@4(R7),R6		; GET A KRP
	BVS	126$			; BUG_CHECK IF ALL ARE IN USE
	PUSHL	R6			; SAVE POINTER TO KRP
	MOVZWL	EXE$GQ_SYSDISK,R0	; GET DESCRIPTION OF "SYS$DISK" FOR CALL
	MOVL	EXE$GQ_SYSDISK+4,R1
	MOVZWL	LNM_TBL,R2		; GET DESCRIPTION OF TABLE NAME
	MOVL	LNM_TBL+4,R3
	MOVZWL	#LNM_ATTR,R5		; CASE_BLIND AND USER MODE
	JSB	LNM$SEARCH_ONE		; TRANSLATE "SYS$DISK" (R4 HAS PCB)
	BLBS	R0,1405$		; SUCCESS!
	CMPW	R0,#SS$_NOLOGNAM	; NO TRANSLATION IS OKAY
	BNEQ	141$			; ELSE ABORT
	BRB	1406$			; GO RETURN KRP 
1405$:	MOVZBL	LNMX$T_XLATION(R6),R0	; GET SIZE OF TRANSLATION
	MOVB	R0,PQB$T_DISK(R9)	; STORE COUNT IN PQB
	MOVC3	R0,<LNMX$T_XLATION+1>(R6),-
		<PQB$T_DISK+1>(R9)	; COPY DEVICE NAME TO PQB
1406$:	MOVL	#1,R0			; INDICATE SUCCESS
141$:	MOVL	(SP)+,R6		; RESTORE KRP POINTER
	INSQUE	(R6),@4(R7)		; RETURN KRP
	BLBC	R0,146$			; ABORT IF ERROR

; MOVE MINIMUM AND MAXIMUM AUTHORIZED SECURITY CLEARANCE RECORDS FROM
; CREATOR'S PHD INTO THE PQB. THE FOLLOWING ASSUME STATEMENTS GUARANTEE THAT
; WE CAN SAFELY PERFORM THIS WITH A SINGLE MOVC3 INSTRUCTION. 

	ASSUME PQB$S_MIN_CLASS EQ PHD$S_MIN_CLASS 
	ASSUME PQB$S_MAX_CLASS EQ PHD$S_MAX_CLASS 
	ASSUME PQB$R_MAX_CLASS EQ <PQB$R_MIN_CLASS + PQB$S_MIN_CLASS>
	ASSUME PHD$R_MAX_CLASS EQ <PHD$R_MIN_CLASS + PHD$S_MIN_CLASS>

	MOVL	G^CTL$GL_PHD,R5		; GET CREATOR'S PHD ADDRESS
	MOVC3	#<PHD$S_MIN_CLASS+PHD$S_MAX_CLASS>,-
		PHD$R_MIN_CLASS(R5),-
		PQB$R_MIN_CLASS(R9)

	MOVC3	#PQB$S_DDSTRING,-
		@#PIO$GT_DDSTRING,PQB$T_DDSTRING(R9) ; DEFAULT DIRECTORY

; Move CLI and CLI table information from P1 space in one fell swoop:
;	CTL$GT_CLINAME    -> PQB$T_CLI_NAME
;	CTL$GT_TABLENAME  -> PQB$T_CLI_TABLE
;	CTL$GT_SPAWNCLI   -> PQB$T_SPAWN_CLI		Optional
;	CTL$GT_SPAWNTABLE -> PQB$T_SPAWN_TABLE		Optional

	ASSUME PQB$T_CLI_TABLE   EQ <PQB$T_CLI_NAME  + PQB$S_CLI_NAME>
	ASSUME PQB$T_SPAWN_CLI   EQ <PQB$T_CLI_TABLE + PQB$S_CLI_TABLE>
	ASSUME PQB$T_SPAWN_TABLE EQ <PQB$T_SPAWN_CLI + PQB$S_SPAWN_CLI>

	MOVZWL	#<PQB$S_CLI_NAME+-	; ASSUME WE'LL MOVE ALL FIELDS
		  PQB$S_CLI_TABLE+-
		  PQB$S_SPAWN_CLI+-
		  PQB$S_SPAWN_TABLE>,-
		R0
	BBS	#PRC$V_CLISPEC,STSFLG(AP),143$ ; PASSING ON CLI SPECIFICATION?
	MOVZWL	#<PQB$S_CLI_NAME+-	; NO, ONLY MOVE FIRST TWO FIELDS
		  PQB$S_CLI_TABLE>,-
		R0
143$:	MOVC5	R0,-			; MOVE AS MANY FIELDS AS SPECIFIED
		@#CTL$GT_CLINAME,-	;  FROM P1 SPACE
		#0,-			;   ZEROING OPTIONAL FIELDS AS NEEDED
		#<PQB$S_CLI_NAME+-	;    TO
		  PQB$S_CLI_TABLE+-	;     THE
		  PQB$S_SPAWN_CLI+-	;      FULL
		  PQB$S_SPAWN_TABLE>,-	;       ALLOCATION
		PQB$T_CLI_NAME(R9)	;        IN THE PQB

	POPR	#^M<R0,R1,R2,R3,R4,R5>	; RESTORE MOVC REGISTERS
	MOVB	@#CTL$GB_MSGMASK,PQB$B_MSGMASK(R9) ; USE CREATOR'S MESSAGE FLAGS
	MOVL	@#CTL$GL_UAF_FLAGS,PQB$L_UAF_FLAGS(R9) ; AND FLAGS FROM UAF RECORD
;
;	ESTABLISH STATUS FLAG SETTINGS FOR PROCESS
;
145$:	MOVL	STSFLG(AP),R8		; GET STATUS FLAG ARGUMENT
	EXTZV	#STSFLGCNT,#<32-STSFLGCNT>,R8,R0	; TEST MBZ FIELD
	BEQL	150$			; CORRECT IF ZERO
	MOVZWL	#SS$_IVSTSFLG,R0	; ERROR, INVALID STATUS FLAG ARG
146$:	BRW	ABORT			; ABORT CREATION

150$:	MOVL	R8,PQB$L_CREPRC_FLAGS(R9) ; STORE FLAGS IN PQB
	CLRL	R7			; INITIALIZE INDEX FOR SCAN
160$:	FFS	R7,#STSFLGCNT,R8,R7	; FIND AN ACTIVE STATUS FLAG
	BEQL	190$			; NONE, FINISHED WITH SCAN
	MOVAW	STSFLGTBL[R7],R1	; POINT TO TRANSLATION ENTRY
	CVTBL	(R1)+,R0		; GET PRIVILEGE BIT NUMBER  TO CHECK
	BGEQ	165$			; NEGATIVE MEANS POSSIBLY NOT PRIVILEGED
	CMPB	#-1,R0
	BEQL	170$			; NO PRIVILEGE REQUIRED
	TSTL	R11
	BEQL	170$			; NO PRIVILEGE REQUIRED FOR SUBPROCESS
	EXTZV	#0,#7,R0,R0		; GET THE PRIVILEGE BIT NUMBER ONLY
165$:	BBS	R0,@PCB$L_PHD(R4),170$	; THE CREATOR PROCESS MUST HAVE PRIVILEGE
	MOVZWL	#SS$_NOPRIV,R0		; INDICATE NO PRIVILEGE ERROR
	BRW	ABORT			; AND ABORT PROCESS CREATION

170$:	CVTBL	(R1),R0			; GET BIT NUMBER IN STS
	BLSS	180$			; NOT NEEDED IN PCB
	BBSS	R0,PCB$L_STS(R10),180$	; SET STSFLG IN NEW PCB
180$:	INCL	R7			; NEXT BIT
	BRB	160$			; CONTINUE SCAN
190$:					; DONE WITH STSFLG
;
; MISC PQB FLAGS
;
	CLRW	PQB$W_FLAGS(R9)		; INITIALIZE THE FLAGS
	BBC	#PRC$V_IMGDMP,STSFLG(AP),195$
	BISW	#PQB$M_IMGDMP,PQB$W_FLAGS(R9) ; REQUEST IMAGE DUMP
195$:
;
; CHECK FOR MAXIMUM ALLOWED DETACHED PROCESSES
;
	TSTL	R11
	BEQL	200$			; NOT DETACHED
	PCB_IBN = <1@PCB$V_INTER>+<1@PCB$V_BATCH>+<1@PCB$V_NETWRK>
	BITL	#PCB_IBN,PCB$L_STS(R10)
	BNEQ	200$			; NO CHECK ON NETWORK, BATCH, OR INTERACTIVE
	MOVL	PCB$L_JIB(R10),R5	; GET THE JIB OF NEW PROCESS
	MOVL	PCB$L_JIB(R4),R7	; GET THE JIB OF PARENT PROCESS
	BNEQ	205$			; IF NO JIB - WE ARE BOOTING
200$:	BRW	240$			; BRANCH AID

205$:	MOVW	JIB$W_MAXDETACH(R7),-	; DETACHED PROCESS LIMIT
		JIB$W_MAXDETACH(R5)	; PROPAGATE THE LIMITS
	MOVW	JIB$W_MAXJOBS(R7),-	; MAX PROCESS LIMIT
		JIB$W_MAXJOBS(R5)
	BISW3	JIB$W_MAXDETACH(R7),JIB$W_MAXJOBS(R7),R5
	BEQL	240$			; NO LIMIT	
	CLRL	R6
	CLRL	R8
	PUSHR	#^M<R0,R1,R2,R3,R4,R9,R10,R11>
	MOVL	#2,R9			; PROCESS INDEX - AFTER NULL AND SWAPPER
	SETIPL	IPL_SYNCH
210$:	MOVL	@SCH$GL_PCBVEC[R9],R10	; GET A PCB
	CMPL	R10,@SCH$GL_PCBVEC	; IS IT NULL PROCESS PCB
	BEQL	220$			; YES
	TSTL	PCB$L_OWNER(R10)	; IS IT SUBPROCESS
	BNEQ	220$
	BBS	#PCB$V_NETWRK,PCB$L_STS(R10),220$ ; DON'T COUNT NETWORK JOBS
	MOVL	PCB$L_JIB(R10),R11	; JIB OF PROCESS BEING CHECKED
	CMPC3	#JIB$S_USERNAME,JIB$T_USERNAME(R7),JIB$T_USERNAME(R11)
	BNEQ	220$			; NOT THE SAME USER
	INCL	R8			; ONE MORE TOTAL JOB
	PCB_IB = <1@PCB$V_INTER>+<1@PCB$V_BATCH>
	BITL	#PCB_IB,PCB$L_STS(R10)
	BNEQ	220$			; INTERACTIVE OR BATCH
	INCL	R6			; ONE MORE TO COUNT AGAINST DETACHED
220$:	AOBLEQ	SCH$GL_MAXPIX,R9,210$
	POPR	#^M<R0,R1,R2,R3,R4,R9,R10,R11>
	SETIPL	#0
	MOVZWL	JIB$W_MAXJOBS(R7),R5
	BEQL	225$			; NO LIMIT
	SUBL	R5,R8
	BGEQU	230$			; OVER LIMIT (INCLUDING THIS PROCESS)
225$:	MOVZWL	JIB$W_MAXDETACH(R7),R5
	BEQL	240$			; NO LIMIT
	SUBL	R5,R6
	BLSSU	240$			; OVER LIMIT (INCLUDING THIS PROCESS)
230$:	MOVL	#SS$_EXPRCLM,R0
	BRW	ABORT
IPL_SYNCH: 
	.LONG	IPL$_SYNCH
;
240$:
;
	.DSABL	LSB
	.PAGE
	.SBTTL	ESTABLISH QUOTAS FOR NEW PROCESS
;-------------------------------------------------------------------
;
;	PROCESS QUOTA BLOCK
;
;-------------------------------------------------------------------

;
;	THE PROCESS QUOTA LIST, IF SUPPLIED, HAS THE FOLLOWING STRUCTURE
;	EACH QUOTA IS INTRODUCED AND IDENTIFIED BY A CODE BYTE, PQL$_?????,
;	WHICH IS FOLLOWED BY A LONGWORD CONTAINING THE QUOTA VALUE.
;
;	THE QUOTA VALUES SUPPLIED ARE MAXIMIZED WITH THE REQUIRED MINIMUM
;	VALUES AND REPLACE THE DEFAULT VALUE FOR EACH SPECIFIED QUOTA.
;	ONLY IF THE PROCESS CREATION IS SUCCESSFUL ARE THE DEDUCTIBLE
;	QUOTAS SUBTRACTED FROM THOSE OF A PROCESS CREATING A DETACHED PROCESS.
;
;	IF DUPLICATE QUOTA ENTRIES ARE FOUND, THE LAST ONE ENCOUNTERED IS
;	THE ONE THAT IS USED.
;

QUOTALIST:				; 
	PUSHR	#^M<R0,R1,R2,R3,R4>	; SAVE REGISTERS FOR MOVC
	MOVC3	#<<PQL$_LENGTH-1>*4>,-	; COPY DEFAULTS TO PQB
		PQL$AL_DEFAULT+4,-	; AS ASSUMED VALUES FOR 
		PQB$L_ASTLM(R9)		; QUOTAS
	POPR	#^M<R0,R1,R2,R3,R4>	; RESTORE REGISTERS
	MOVL	PCB$L_PHD(R4),R5	; FOR SWAPPER POINT TO REAL PHD SINCE NO
	CMPL	PCB$L_PID(R4),SCH$GL_SWPPID	; IS IT THE SWAPPER
	BEQL	5$			; YES, USE PCB POINTER TO PHD
	MOVL	@#CTL$GL_PHD,R5		; GET POINTER TO PHD WINDOW IN 
					; CONTROL REGION FOR WINDOW
5$:	MOVL	QUOTA(AP),R7		; GET POINTER TO QUOTA LIST
	BEQL	NOQLIST			; NONE SPECIFIED
10$:	IFNORD	#1,(R7),30$		; CHECK FOR ACCESSIBILITY
	MOVZBL	(R7)+,R6		; GET CODE
	ASSUME	PQL$_LISTEND EQ 0	;
	BEQL	NOQLIST			; DONE IF PQL$_ENDLIST
	IFNORD	#4,(R7),30$		; CHECK QUOTA FOR ACCESSIBILITY
	CMPW	R6,#PQL$_LENGTH		; CHECK FOR LEGAL QUOTA NUMBER
	BGEQ	20$			; INVALID IF GEQ
	MOVL	(R7)+,PQB$L_ASTLM-4(R9)[R6] ; MERGE INTO PQB QUOTA LIST
	BRB	10$			; GO GET NEXT QUOTA SPECIFIED
20$:	MOVZWL	#SS$_IVQUOTAL,R0	; INVALID QUOTA LIST
	BRW	ABORT			; SIGNAL ERROR CONDITION AND ABORT CREATE

30$:	BRW	ACCVIO			; ABORT WITH ACCESS VIOLATION

NOQLIST:				; DONE MERGING QUOTAS SPECIFIED
	MOVAL	PQL$AL_MIN+<4*PQL$_LENGTH>,R6	; SET POINTER TO BASE OF MIN VALUES
	MOVAL	<PQB$L_ASTLM+<4*<PQL$_LENGTH-1>>>(R9),R3 ; SET BASE OF QUOTA VALUES
	MOVZWL	#<PQL$_LENGTH-1>,R8	; SET COUNT FOR SCAN
	MOVL	PCB$L_JIB(R10),R7	; GET ADDRESS OF JOB INFORMATION BLOCK
	CLRL	R2			; INDICATE UNRESTRICTED QUOTAS ALLOWED
	TSTL	R11			; IS IT A SUBPROCESS
	BEQL	5$			; YES
	IFPRIV	DETACH,10$		; UNRESTRICTED IS OK
	IFPRIV	CMKRNL,10$
5$:	MOVL	PCB$L_JIB(R4),R2	; INDICATE RESTRICTED QUOTAS (JIB ADDRESS)
10$:	CMPL	-(R3),-(R6)		; CHECK AGAINST MINIMUM ALLOWABLE VALUE
	BGEQ	20$			; BR IF ABOVE MINIMUM
	MOVL	(R6),(R3)		; FORCE TO MINIMUM
20$:	
	MOVL	(R3),R0			; GET QUOTA REQUEST VALUE
	BSBB	40$			; PROCESS QUOTA
	SOBGTR	R8,10$			; LOOP FOR ALL QUOTAS
	BRW	ITEMLIST		; GO PROCESS THE ITEM LIST

40$:	CASE	R8,LIMIT=#1,<-		; SWITCH ON TYPE OF QUOTA
		QASTLM,-		; 1 => AST LIMIT
		QBIOLM,-		; 2 => BUFFERED I/O LIMIT
		QBYTLM,-		; 3 => BUFIO BYTE COUNT LIMIT
		QCPULM,-		; 4 => CPU TIME LIMIT
		QDIOLM,-		; 5 => DIRECT I/O LIMIT
		QFILLM,-		; 6 => OPEN FILE LIMIT
		QPGFLQUOTA,-		; 7 => PAGING FILE QUOTA
		QPRCLM,-		; 8 => SUB-PROCESS LIMIT
		QTQELM,-		; 9 => TIMER QUEUE ENTRY LIMIT
		QWSQUOTA,-		;10 => WORKING SET QUOTA
		QWSDEFAULT,-		;11 => WORKING SET DEFAULT
		QENQLM,-		;12 => ENQUEUE LIMIT
		QWSEXTENT,-		;13 => WORKING SET EXTENT
		QJTQUOTA-		;14 => JOB-WIDE LOGICAL NAME TABLE QUOTA
		>; 

QJTQUOTA:				; NO SPECIAL PROCESSING FOR JTQUOTA
	RSB				; 

QASTLM:					; AST LIMIT
	CMPW	R0,PHD$W_ASTLM(R5)	; CHECK FOR IN LIMIT
	BLEQU	10$			; YES, CONTINUE
	TSTL	R2			; UNRESTRICTED DETACHED CREATE?
	BEQL	10$			; YES, ALLOW ANYTHING
	MOVW	PHD$W_ASTLM(R5),R0	; NO, LIMIT TO MAXIMUM
10$:	MOVW	R0,PCB$W_ASTCNT(R10)	; SET AS WORKING AST COUNT
	RSB				; NEXT QUOTA

QBIOLM:					; BUFFERED I/O LIMIT
	CMPW	R0,PCB$W_BIOLM(R4)	; CHECK FOR IN LIMIT
	BLEQU	10$			; YES, CONTINUE
	TSTL	R2			; UNRESTRICTED DETACHED CREATE?
	BEQL	10$			; YES ALLOW ANYTHING
	MOVW	PCB$W_BIOLM(R4),R0	; NO, LIMIT TO CURRENT VALUE
10$:	MOVW	R0,PCB$W_BIOLM(R10)	; SET LIMIT
	MOVW	R0,PCB$W_BIOCNT(R10)	; AND WORKING COUNT
	RSB				; NEXT QUOTA

QBYTLM:					; BUFFERED I/O BYTE LIMIT
	TSTL	R11			; DETACHED CREATE?
	BEQL	10$			; BR IF NOT
	TSTL	R2			; UNRESTRICTED QUOTAS?
	BEQL	5$			; YES
	CMPL	R0,JIB$L_BYTLM(R2)	; IS IT WITHIN LIMITS
	BLEQU	5$			; YES
	MOVL	JIB$L_BYTLM(R2),R0	; LIMIT TO CURRENT VALUE
5$:	MOVL	R0,JIB$L_BYTLM(R7)	; SET IN JIB OF MASTER PROCESS
	MOVL	R0,JIB$L_BYTCNT(R7)	; BOTH LIMIT AND COUNT VALUES
	MOVL	R0,JIB$L_ORG_BYTLM(R7)	; AND ORIGINAL VALUE FIELD
10$:	RSB				; NEXT QUOTA

QCPULM:					; CPU TIME LIMIT
	TSTL	R2			; UNRESTRICTED DETACHED CREATE?
	BEQL	20$			; YES, ALLOW ANYTHING
	TSTL	R11			; IS IT A DETACHED PROCESS
	BEQL	3$			; NO
	CMPL	R0,PHD$L_CPULIM(R5)	; IS IT WITHIN LIMITS
	BLEQU	20$			; YES
	MOVL	PHD$L_CPULIM(R5),R0	; LIMIT IT TO CURRENT VALUE
	BRB	20$
3$:	MOVL	PHD$L_CPULIM(R5),R1	; GET CURRENT PROCESS LIMIT
	BEQL	20$			; NO LIMIT ON CURRENT PROCESS
	SUBL	PHD$L_CPUTIM(R5),R1	; DETERMINE REMAINING LIMIT
	BLEQU	10$			; BRANCH IF WILL EXCEED LIMIT
	TSTL	R0			; IS REQUESTED VALUE INFINITY?
	BNEQ	5$			; NO, GO SEE IF REQUEST CAN BE FILLED
	INCL	R1			; IF REQUESTING INFINITY, GIVE
	BICL2	#1,R1			;  HALF OF CALLER'S LIMIT BY CLEARING
	ROTL	#31,R1,R0		;  LOW BIT AND ROTATING THAT TO SIGN BIT
	MOVL	R0,(R3)			; STORE NEW LIMIT IN PQB
5$:	CMPL	R0,R1			; CHECK FOR IN LIMIT
	BLSSU	20$			; YES, CONTINUE
10$:	BSBW	OVERCHECK		; CHECK FOR LEGAL TO EXCEED
20$:	RSB				; NEXT QUOTA

QDIOLM:					; DIRECT I/O LIMIT
	CMPW	R0,PCB$W_DIOLM(R4)	; CHECK FOR IN LIMIT
	BLEQU	10$			; YES, CONTINUE
	TSTL	R2			; UNRESTRICTED DETACHED CREATE?
	BEQL	10$			; YES, ALLOW ANYTHING
	MOVW	PCB$W_DIOLM(R4),R0	; ELSE LIMIT TO CURRENT VALUE
10$:	MOVW	R0,PCB$W_DIOLM(R10)	; SET LIMIT
	MOVW	R0,PCB$W_DIOCNT(R10)	; AND SET WORKING COUNT
	RSB				;

QFILLM:					; OPEN FILE LIMIT
	TSTL	R11			; IS THIS A DETACHED CREATE?
	BEQL	10$			; BR IF NOT
	TSTL	R2			; UNRESTRICTED QUOTAS?
	BEQL	5$			; YES
	CMPW	R0,JIB$W_FILLM(R2)	; IS IT WITHIN LIMITS
	BLEQU	5$			; YES
	MOVW	JIB$W_FILLM(R2),R0	; LIMIT TO CURRENT VALUE
5$:	MOVW	R0,JIB$W_FILCNT(R7)	; SET FILE COUNT FOR MASTER PROCESS
	MOVW	R0,JIB$W_FILLM(R7)	; AND LIMIT VALUE
10$:	RSB				; NEXT QUOTA

QPGFLQUOTA:				; PAGE FILE QUOTA
	TSTL	R11			; DETACHED CREATE?
	BEQL	10$			; BR IF NOT
	TSTL	R2			; UNRESTRICTED QUOTAS?
	BEQL	5$			; YES
	CMPL	R0,JIB$L_PGFLQUOTA(R2)	; IS IT WITHIN LIMITS
	BLEQU	5$			; YES
	MOVL	JIB$L_PGFLQUOTA(R2),R0	; LIMIT TO CURRENT VALUE
5$:	MOVL	R0,JIB$L_PGFLQUOTA(R7)	; SET PAGE FILE QUOTA
	MOVL	R0,JIB$L_PGFLCNT(R7)	; AND COUNT
10$:	RSB				; NEXT QUOTA

QPRCLM:					; SUBPROCESS QUOTA
	TSTL	R11			; IS THIS A DETACHED CREATE?
	BEQL	10$			; BR IF NOT
	TSTL	R2			; UNRESTRICTED QUOTAS?
	BEQL	5$			; YES
	CMPW	R0,JIB$W_PRCLIM(R2)	; IS IT WITHIN LIMITS
	BLEQU	5$			; YES
	MOVW	JIB$W_PRCLIM(R2),R0	; LIMIT TO CURRENT VALUE
5$:	MOVW	R0,JIB$W_PRCLIM(R7)	; AND LIMIT
10$:	RSB				; NEXT QUOTA

QTQELM:					; TIMER QUEUE ENTRY QUOTA
	TSTL	R11			; IS THIS A DETACHED CREATE?
	BEQL	10$			; BR IF NOT
	TSTL	R2			; UNRESTRICTED QUOTAS?
	BEQL	5$			; YES
	CMPW	R0,JIB$W_TQCNT(R2)	; IS IT WITHIN LIMITS
	BLEQU	5$			; YES
	MOVW	JIB$W_TQCNT(R2),R0	; LIMIT TO CURRENT VALUE
5$:	MOVW	R0,JIB$W_TQCNT(R7)	; SET TIMER QUEUE QUOTA FOR JOB
	MOVW	R0,JIB$W_TQLM(R7)	; AND LIMIT VALUE
10$:	RSB				; NEXT QUOTA

QWSQUOTA:				; WORKING SET QUOTA
	BSBB	MAXWSCNT		; LIMIT TO MAX WORKING SET COUNT
	ADDW	PHD$W_WSLIST(R5),R0	; ADD BASE OF WORKING SET LIST
	CMPW	R0,PHD$W_WSQUOTA(R5)	; CHECK FOR IN LIMIT
	BLSSU	10$			; YES,CONTINUE
	TSTL	R2			; UNRESTRICTED DETACHED PROCESS?
	BEQL	10$			; YES, USE AS IS
	ADDW3	#1,PHD$W_WSQUOTA(R5),R0	; ELSE FORCE TO CORRECT MAXIMUM
10$:	SUBW3	PHD$W_WSLIST(R5),R0,(R3); REMOVE BIAS
	RSB				; NEXT QUOTA

QWSEXTENT:				; WORKING SET EXTENT
	BSBB	MAXWSCNT		; LIMIT TO MAX WORKING SET COUNT
	CMPL	R0,PQB$L_WSQUOTA(R9)	; CHECK AGAINST QUOTA
	BGEQU	5$			; MORE, USE AS IS
	MOVL	PQB$L_WSQUOTA(R9),R0	; MAXIMIZE WITH WSQUOTA
5$:	ADDW	PHD$W_WSLIST(R5),R0	; ADD BASE OF WORKING SET LIST
	CMPW	R0,PHD$W_WSEXTENT(R5)	; CHECK FOR IN LIMIT
	BLSSU	10$			; YES,CONTINUE
	TSTL	R2			; UNRESTRICTED DETACHED PROCESS?
	BEQL	10$			; YES, USE AS IS
	ADDW3	#1,PHD$W_WSEXTENT(R5),R0; ELSE FORCE TO CORRECT MAXIMUM
10$:	SUBW3	PHD$W_WSLIST(R5),R0,(R3); REMOVE BIAS
	RSB				; NEXT QUOTA

QWSDEFAULT:				; WORKING SET LIST DEFAULT
	BSBB	MAXWSCNT		; LIMIT TO MAXIMUM WORKING SET COUNT
	CMPL	R0,PQB$L_WSQUOTA(R9)	; CHECK AGAINST QUOTA
	BLEQU	10$			; LESS, USE AS IS
	MOVL	PQB$L_WSQUOTA(R9),(R3)	; MINIMIZE WITH WSQUOTA
10$:	RSB				; NEXT QUOTA


MAXWSCNT:				; LIMIT WSQUOTA OR DEFAULT TO MAXIMUL SIZE
	CMPW	R0,SGN$GL_MAXWSCNT	; COMPARE WITH MAXIMUM WS LIST LENGTH
	BLEQU	10$			; BR IF WITHIN LEGAL RANGE
	MOVW	SGN$GL_MAXWSCNT,R0	; FORCE TO LEGAL VALUE
10$:	RSB				;

QENQLM:					; ENQUEUE QUOTA
	TSTL	R11			; IS THIS A DETACHED CREATE?
	BEQL	10$			; BR IF NOT
	TSTL	R2			; UNRESTRICTED QUOTAS?
	BEQL	5$			; YES
	CMPW	R0,JIB$W_ENQCNT(R2)	; IS IT WITHIN LIMITS
	BLEQU	5$			; YES
	MOVW	JIB$W_ENQCNT(R2),R0	; LIMIT TO CURRENT VALUE
5$:	MOVW	R0,JIB$W_ENQCNT(R7)	; SET ENQUEUE QUOTA FOR JOB
	MOVW	R0,JIB$W_ENQLM(R7)	; AND LIMIT VALUE
10$:	RSB				; NEXT QUOTA

	.PAGE
	.SBTTL	OVERCHECK - CHECK FOR LEGAL TO EXCEED QUOTA
;++
; FUNCTIONAL DESCRIPTION:
;	OVERCHECK CHECKS TO SEE IF THE PROCESS BEING CREATED IS A DETATCHED
;	PROCESS.   IF A DETATCHED PROCESS IS BEING CREATED, CONTROL RETURNS 
;	INLINE.  OTHERWISE THE CREATE IS ABORTED BY BRANCHING TO ABORT 
;	WITH THE STATUS CODE SS$_NOQUOTA.
;
; INPUT PARAMETERS:
;	R4 - PCB ADDRESS OF CURRENT PROCESS
;	R5 - ADDRESS OF PHD FOR CURRENT PROCESS (WINDOW IN P1 SPACE)
;	R9 - ADDRESS OF PROCESS QUOTA BLOCK
;	R10- ADDRESS OF PCB FOR NEW PROCESS
;	R11- UIC FOR CREATED PROCESS (0 => SUBPROCESS)
;
;--

OVERCHECK:				;
	TSTL	R11			; CHECK FOR SUBPROCESS CREATE
	BNEQ	10$			; YES, IGNORE OVER LIMIT
	MOVZWL	#SS$_EXQUOTA,R0		; SET ERROR STATUS CODE
	BRW	ABORT			; NO, ABORT CREATE

10$:	RSB				; RETURN
	.PAGE
	.PAGE
	.SBTTL	PROCESS THE ITEM LIST
;-------------------------------------------------------------------
;
;	PROCESS ITEM LIST
;
;-------------------------------------------------------------------

;
;	THE PROCESS ITEM LIST, IF SUPPLIED, HAS THE FOLLOWING STRUCTURE
;	EACH ITEM HAS A 2 LONGWORD FIELD.  THE FIRST LONGWORD HAS TWO
;	SUBFIELDS, A WORD OF ITEM LENGTH, FOLLOWED BY A CODE WORD PRC$_?????,
;	WHICH IS FOLLOWED BY A LONGWORD CONTAINING THE ITEM VALUE.
;
;
;	IF DUPLICATE ITEM LIST ENTRIES ARE FOUND, THE LAST ONE ENCOUNTERED IS
;	THE ONE THAT IS USED.
;
;	NOTE THAT THE PAGE FILE INDEX AND CHARACTERISTICS WILL BE TREATED AS
;	ADVICE ONLY.  IF THEY ARE INVALID OR CANNOT BE MET (NO FILE AVAILABLE),
;	THE NORMAL ALGORITHM FOR ASSIGNING PAGE FILES WILL BE USED IN SHELL.
;
	ASSUME PRC$_PGFLCHAR EQ 1
	ASSUME PRC$_PGFLINDEX EQ 2
	ASSUME PRC$_INPUT_ATT EQ 3
	ASSUME PRC$_OUTPUT_ATT EQ 4
	ASSUME PRC$_ERROR_ATT EQ 5
;
ITEMLIST:
	CMPL	(AP),#ITMLST_ARG	; WAS THE ITEM LIST ARGUMENT SUPPLIED?
	BLSSU	NO_ITMLST		; NO
	IFNORD	#4,ITMLST(AP),40$	; CAN WE READ THE ITEMLIST POINTER
	MOVL	ITMLST(AP),R7		; GET THE POINTER
	BEQL	NO_ITMLST		; NONE SPECIFIED
10$:	IFNORD	#4,(R7),40$		; CAN WE READ THE CODE AND LENGTH
	MOVZWL	(R7)+,R0		; GET LENGTH WORD
	MOVZWL	(R7)+,R6		; GET THE CODE
	BEQL	NO_ITMLST		; END OF THE LIST
	IFNORD	#4,(R7),40$		; CAN WE READ THE ITEM VALUE
	BSBB	20$			; PROCESS THE ITEM
	ADDL	#4,R7
	BRB	10$			; NEXT

20$:	CASE	R6,LIMIT=#1,<-
		ITM_PGFLCHAR,-
		ITM_PGFLINDEX,-
		ITM_INPUT_ATT,-
		ITM_OUTPUT_ATT,-
		ITM_ERROR_ATT,-
		>
	MOVL	#SS$_BADPARAM,R0
	BRW	ABORT

40$:	BRW	ACCVIO

ITM_PGFLCHAR:				; PAGE FILE CHARACTERISTICS
	MOVW	(R7),PCB$W_PGFLCHAR(R10)
	RSB

ITM_PGFLINDEX:				; PAGE FILE INDEX
	MOVB	(R7),PCB$B_PGFLINDEX(R10)
	RSB

ITM_INPUT_ATT:				; SYS$INPUT ATTRIBUTES
	MOVL	(R7),PQB$L_INPUT_ATT(R9)
	RSB

ITM_OUTPUT_ATT:				; SYS$INPUT ATTRIBUTES
	MOVL	(R7),PQB$L_OUTPUT_ATT(R9)
	RSB

ITM_ERROR_ATT:				; SYS$INPUT ATTRIBUTES
	MOVL	(R7),PQB$L_ERROR_ATT(R9)
	RSB

NO_ITMLST:
	.PAGE
	.SBTTL	ACTIVATE NEW PROCESS
;
;	ACTIVATE NEW PROCESS
;

ACTIVATE:				;
	MOVL	R9,PCB$L_PQB(R10)	; POINT NEW PCB TO PROCESS QUOTA BLOCK
	MOVL	R10,R4			; PCB ADDRESS OF NEW PROCESS
	MOVL	R4,(R10)		; BUILD QUEUE HEADER
	MOVL	R4,4(R10)		; FOR PCB
10$:	DSBINT	W^10001$		; BLOCK SYSTEM EVENT REPORTING
	JSB	G^MMG$CALCSWAPSIZE	; GET THE SIZE IN R2 OF MINIMUM SWAP AREA
	CLRQ	R0			; INDICATE NO CURRENT SPACE
	JSB	G^MMG$ALLOCSWPAREA	; ALLOCATE INITIAL SWAP SPACE
	BGEQ	15$			; IS SWAP SPACE AVAILABLE
	MOVZWL	#SS$_INSSWAPSPACE,R0	; NO
	BRW	65$
15$:	MNEGL	R0,PCB$L_WSSWP(R4)	; INSERT SWAP FILE TYPE VBN/INDEX
	MOVL	R2,PCB$L_SWAPSIZE(R4)	; SAVE MAXIMUM ALLOWABLE SWAP SIZE
	MOVL	CURPCB(FP),R6		; GET PCB ADDRESS OF CREATOR
	MOVL	PCB$L_PHD(R6),R5	; AND EXTRACT HEADER ADDRESS
;
; Look for a free PCB slot (i.e. one pointing to nullpcb).  Start at the slot after the
; last PIX allocated and perform a round-robin scan.
;
	MOVZWL	SCH$GL_MAXPIX,R3	; SAVE MAX PIX TO TEST WHEN TO WRAP AROUND
	SUBL3	S^#<SCH$C_SWPPIX+1>,R3,R1 ; LOOP COUNTER IS MAX LESS SWAPPER AND NULL
	MOVL	SCH$GL_PIXLAST,R7	; SET INDEX FOR PIX SEARCH TO LAST ALLOCATED PIX
	MOVAL	SCH$GL_NULLPCB,R8	; REFERENCE PCB ADDRESS (NULL PROCESS)
20$:	INCL	R7			; MOVE TO THE NEXT PIX IN THE SEARCH
	CMPL	R7, R3			; IS THE PIX LARGER THAN THE MAXIMUM
	BLEQ	21$			; BRANCH IF R7 IS OK
	MOVL	S^#<SCH$C_SWPPIX+1>,R7	; SET TO FIRST SLOT AFTER SWAPPER
21$:	CMPL	R8,@SCH$GL_PCBVEC[R7]	; FIND NON-ZERO PIX POINTING TO NULLPCB
	BEQL	30$			; GOT ONE, FREE SLOT
	SOBGTR	R1,20$			; OCCUPIED, TRY ANOTHER
;
; Error, deallocate the paging file space
;
22$:	EXTZV	#24,#8,R0,R3		; GET PAGE FILE ALLOCATION IN
	EXTZV	#0,#24,R0,R0		; GET VBN OF ALLOCATION
	MOVL	R2,R1			; PASS SIZE OF SWAP SLOT TO DEALLOCATE
	MOVL	@L^MMG$GL_PAGSWPVC[R3],R3 ; GET ADDR OF PAGE FILE CONTROL BLOCK
	JSB	G^MMG$DEALLOCPAGFIL	; FREE UP THE SPACE
	BRW	60$			; NO FREE SLOTS AVAILABLE
;
30$:	CMPW	SCH$GW_PROCLIM,SCH$GW_PROCCNT ; CHECK FOR MAX PROCESSES
	BLEQ	22$			; BR IF YES AND ABORT CREATE
;
; Update global data and create the internal and external process identifiers.
;
	MOVL	R7,SCH$GL_PIXLAST	; SAVE NEW PIX AS LAST ALLOCATED PIX
	INCW	SCH$GW_PROCCNT		; COUNT THIS PROCESS

; Note that the following code assumes that caller's of Create Process
; know what they are doing in the sense that there will never be more than
; one of the bits INTER, BATCH, and NETWRK set at the same time.

	TSTL	R11
	BEQL	33$			; IT IS A SUBPROCESS - DON'T COUNT IT
	BBC	#PCB$V_INTER,PCB$L_STS(R10),31$
	INCW	SYS$GW_IJOBCNT		; ONE MORE INTERACTIVE JOB
31$:	BBC	#PCB$V_BATCH,PCB$L_STS(R10),33$
	INCW	SYS$GW_BJOBCNT		; ONE MORE BATCH JOB
33$:
;
; NOTE: The call to EXE$IPID_TO_EPID checks to make sure the IPID is valid,
;	therefore we must set the IPID in the new PCB and store the address
;	of the new PCB in the PCBVEC before we call EXE$IPID_TO_EPID.
;
	MOVL	R10,@SCH$GL_PCBVEC[R7]	; SET POINTER TO PCB IN VECTOR OF PCBS
	MOVAW	@SCH$GL_SEQVEC[R7],R0	; GET ADDRESS OF SEQUENCE NUMBER FOR SLOT
	INCW	(R0)			; NEXT SEQUENCE NUMBER FOR THIS PROCESS
	BGEQ	35$			; BR IF IN RANGE (POSITIVE PID)
	CLRW	(R0)			; ELSE, RESET SEQUENCE NUMBER
35$:	MOVW	(R0),PCB$L_PID+2(R10)	; SET SEQUENCE NUMBER
	MOVW	R7,PCB$L_PID(R10)	; AND PIX TO FORM COMPLETE INTERNAL PID
	MOVL	PCB$L_PID(R10),R0	; LOAD THE INTERNAL PID TO PASS TO ROUTINE
	JSB	EXE$IPID_TO_EPID	; CONVERT IPID TO EPID, RETURN EPID IN R0
	MOVL	R0,PCB$L_EPID(R10)	; STORE THE EXTENDED PID

	TSTL	R11			; DETACHED CREATE?
	BEQL	38$			; BR IF NOT
	MOVL	PCB$L_JIB(R10),R0	; GET JIB ADDRESS
	MOVL	PCB$L_PID(R10),JIB$L_MPID(R0)	; AND SET ROOT PID FOR PROCESS TREE
38$:	MOVZBL	#PRI$_TICOM,R2		; SET PRIORITY INCREMENT CLASS
	JSB	SCH$CHSE		; MAKE PROCESS EXECUTABLE, NON-RESIDENT
	TSTL	R11			; TEST FOR DETACHED CREATE
	BNEQ	40$			; BR IF CREATING DETACHED PROCESS
	INCW	PCB$W_PRCCNT(R6)	; OTHERWISE ACCOUNT FOR SUB-PROCESS
	TSTL	PHD$L_CPULIM(R5)	; CHECK FOR NO CPU LIMIT
	BEQL	40$			; NO LIMIT, DONT DEDUCT
	SUBL	PQB$L_CPULM(R9),PHD$L_CPULIM(R5); DEDUCT CPU TIME LIMIT
40$:					;
	MOVL	4(SP),R0		; GET EPID RETURN VALUE ADDRESS
	BEQL	55$			; NONE
	BLSS	70$			; SYSTEM SPACE ADDRESS
42$:	ENBINT				; RESTORE IPL
45$:	MOVL	PCB$L_EPID(R10),(R0)	; RETURN EXTENDED PID FOR CREATED PROCESS
50$:	MOVZWL	#SS$_NORMAL,R0		; SET NORMAL COMPLETION STATUS
	RET				; AND RETURN TO CALLER

55$:	ENBINT				; RESTORE IPL
	BRB	50$			; AND EXIT

60$:	MOVZWL	#SS$_NOSLOT,R0		; SET ERROR CODE FOR NO SLOT AVAILABLE
65$:	ENBINT				; ENABLE SYSTEM EVENT REPORTING
	BRB	ABORT			; ABORT CREATION, EXCEEDED QUOTA

70$:	CMPL	R0,MMG$GL_NPAGEDYN	; CHECK FOR IN NONPAGED POOL
	BLSSU	42$			; NO, DROP IPL TO STORE EPID
	CMPL	R0,EXE$GL_INTSTK	; HIGH LIMIT
	BGEQU	42$			; OUT OF POOL OR INTERRUPT STACK
	MOVL	PCB$L_EPID(R10),(R0)	; STORE EXTENDED PID FOR CREATED PROCESS
	ENBINT				; RESTORE IPL
	BRB	50$			; AND RETURN SUCCESS
10001$:					; MARKER FOR END OF NONPAGABLE AREA
	.LONG	IPL$_SYNCH		; IPL TO BLOCK EVENT REPORTING
10002$:
	ASSUME	<10002$-10$> LE 512	; MAKE SURE IT IS LESS THAN A PAGE
	.PAGE
	.SBTTL	ABORT PROCESS CREATION
;
;	ABORT PROCESS CREATION AFTER DETECTING ANY ERROR
;


ABRT2:					; ABORT WITH PCB ONLY
	CLRL	R9			; INDICATE NO PQB ALLOCATED
ABORT:					; ABORT WITH BOTH PCB AND PQB ALLOCATED
	MOVL	R0,R7			; SAVE STATUS CODE
	TSTL	R11			; IS THIS A DETACHED PROCESS CREATE?
	BEQL	10$			; BR IF NOT
	MOVL	PCB$L_JIB(R10),R0	; GET JIB ADDRESS FOR RELEASE
	BEQL	10$			; BR IF NONE
	BSBB	EXE_DEANONPAGED		; DEALLOCATE JIB
	BRB	20$			; 
10$:	MOVL	CURPCB(FP),R4		; GET PCB ADDRESS FOR SURE
	MOVL	PCB$L_JIB(R4),R2	; FETCH JIB ADDRESS
	ADDL	#SWP$C_SHELLPFIL,JIB$L_PGFLCNT(R2); RETURN PAGE FILE QUOTA
					; FOR SHELL PAGES
	DECW	JIB$W_PRCCNT(R2)	; CORRECT SUBPROCESS COUNT

20$:	MOVL	PCB$Q_PRIV+ARB$L_RIGHTSLIST+8(R10),R0	; GET EXTENDED RIGHTS LIST, IF ANY
	BEQL	22$			; BRANCH IF NONE
	BSBB	EXE_DEANONPAGED		; DEALLOCATE RIGHTS LIST
22$:	MOVL	R10,R0			; ADDRESS OF NEW PCB
	BSBB	EXE_DEANONPAGED		; DEALLOCATE QUOTA BUFFER
	TSTL	R9			; ADDRESS OF PQB IF ANY
	BEQL	30$			; BR IF NONE ALLOCATED
	INSQUE	(R9),@EXE$GL_PQBBL	; DEALLOCATE PQB TO LOOKASIDE LIST
30$:	MOVL	R7,R0			; RESTORE STATUS CODE
	RET				; AND RETURN TO CALLER

EXE_DEANONPAGED:
	JMP	G^EXE$DEANONPAGED	; BRANCH AID TO REACH THIS ROUTINE
	.PAGE
	.SBTTL	MOVSTR - STRING COPY SUBROUTINE
;+
; FUNCTIONAL DESCRIPTION: 
;	MOVSTR VALIDATES AND COPIES A STRING FROM THE ARGUMENT LIST
;	TO THE PROCESS QUOTA BUFFER.  IF ANY ERROR IS DETECTED, THE
;	SERVICE CALL IS EXITED VIA A RET INSTRUCTION WITH R0 CONTAINING
;	THE ERROR STATUS CODE.
;
; CALLING SEQUENCE:
;	BSB	MOVSTR
;	.BYTE	<MAXIMUM_STRING_LENGTH>
;	.BYTE	<AP_OFFSET_TO_SOURCE_DESCRIPTOR>
;	.BYTE	<PQB_OFFSET_OF_DESTINATION>
;
; INPUT PARAMETERS:
;	R9 - PQB BASE ADDRESS
;	@(SP) - MAXIMUM STRING LENGTH
;	@(SP)+1 - AP OFFSET TO SOURCE STRING DESCRIPTOR
;	@(SP)+2 - PQB OFFSET FOR DESTINATION COUNTED STRING
;
; OUTPUT PARAMETERS:
;	SPECIFIED AREA IN PQB RECEIVES SOURCE STRING
;
; COMPLETION CODES:
;	SS$_ACCVIO  -  ACCESS VIOLATION FETCHING DESCRIPTOR OR STRING
;	SS$_IVLOGNAM - INVALID LOGICAL NAME (COUNT OUT OF RANGE)
;
;-

MOVSTR:					; MOVE STRING TO PQB
	MOVL	(SP),R5			; GET BASE OF PARAMETERS
	ADDL	#4,(SP)			; INCREMENT RETURN ADDRESS
	PUSHR	#^M<R4,R5,R6,R7,R8>	; SAVE REGISTERS
	MOVZBL	(R5)+,R8		; GET STRING LIMIT
	MOVZBL	(R5)+,R3		; GET ARGLIST OFFSET
	MOVL	(AP)[R3],R2		; FETCH DESCRIPTOR ADDRESS
	BEQL	MOVEXIT			; NONE, EXIT
	IFNORD	#8,(R2),ACCVIO		; MUST BE ABLE TO READ DESCRIPTOR
	MOVQ	(R2),R6			; FETCH DESCRIPTOR
	TSTW	R6			; CHECK FOR NULL COUNT
	BEQL	MOVEXIT			; YES, NULL STRING
	CMPW	R6,R8			; CHECK UPPER LIMIT ON STRING 
	BLEQU	10$			; BR IF WITHIN LIMIT
	MOVZWL	#SS$_IVLOGNAM,R0	; SET ERROR CODE
	BRW	ABORT			; AND ABORT CREATE

10$:	IFNORD	R6,(R7),ACCVIO		; CHECK ACCESSIBILITY
	MOVZWL	(R5),R3			; GET PQB OFFSET
	MOVAB	(R9)[R3],R3		; COMPUTE ADDRESS IN PQB
	MOVB	R6,(R3)+		; SET COUNT FOR STRING
	MOVC3	R6,(R7),(R3)		; COPY STRING TO BUFFER
MOVEXIT:				;
	POPR	#^M<R4,R5,R6,R7,R8>	; RESTORE REGISTERS
	RSB				; AND RETURN

ACCVIO:	MOVZWL	#SS$_ACCVIO,R0		; SET ERROR CODE
	BRW	ABORT			;
	.PAGE
	.SUBTITLE	ALLOCPQB - Allocate PQB from paged pool
;+
; Functional Description:
;
;	This subroutine merely allocates a PQB from paged pool. If the
;	allocation fails, the process may be put into a resource wait state
;	but only after the already allocated PCB is deallocated and IPL is
;	lowered to zero. 
;
; Input Parameters:
;
;	R4  - Address of PCB of creating process
;	R10 - Address of chunk of nonpaged pool that will become PCB
;		of new process.
;
; Implicit Input:
;
;	Running at IPL$_ASTDEL as a result of successful PCB allocation
;
; Ouptut Parameters:
;
;	If allocation is successful
;
;		R2 - Address of PQB
;
;	If the allocation fails and the creator waits for resources,
;
;		the PCB pointed to by R10 is deallocated and the process
;		is put into a resource wait state. When paged pool becomes
;		available, the process resumes execution at the beginning
;		of the service.
;
;	If the allocation fails and resource wait is disabled,
;
;		a simple failure status (SS$_INSFMEM) is returned.
;
; Side Effects:
;
;	R0 through R3 are modified
;-

ALLOCPQB:				; Allocate process quota block
	MOVZWL	#PQB$C_LENGTH,R1 	; Set structure size
	PUSHL	R1			; Save request size
	MOVAB	B^DEALLOCATE_PCB,R0	; Store address of error action routine
	JSB	G^EXE$ALOPAGWAIT	; Attempt to allocate packet
	POPL	R1			; Restore request size 
	BLBC	R0,10$			; If low bit clear, no packet allocated
	MOVW	R1,PQB$W_SIZE(R2)	; Insert size of allocated block
	MOVZBW	#DYN$C_PQB,-		; Insert data structure type
		PQB$B_TYPE(R2)		;  and clear adjacent byte
10$:	RSB				;  and return

DEALLOCATE_PCB:
	MOVL	R10,R0			; Get new PCB address
	BSBW	EXE_DEANONPAGED		; Give it back
	RSB				; Return to error code in ALOPAGWAIT

	.END
