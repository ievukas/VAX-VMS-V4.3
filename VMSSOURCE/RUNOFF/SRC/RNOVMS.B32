%TITLE 'RNOVMS - DSR VMS Command Line Interface'
MODULE RNOVMS (	IDENT = 'V04-000',
		ADDRESSING_MODE( EXTERNAL=LONG_RELATIVE,
				 NONEXTERNAL=LONG_RELATIVE )
		) =
BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
!
! FACILITY:	 DSR (Digital Standard RUNOFF) / DSRPLUS
!
! ABSTRACT:
!
!	This module is the DSR VMS Command Line interface module.
!
! ENVIRONMENT:  VAX/VMS User Mode
!
! AUTHOR:  Ray Marshall,	CREATION DATE:  23 August 1981
!

%SBTTL 'Revision History'
!
! MODIFIED BY:
!
!	026	REM00026	Ray Marshall	31-May-1984
!		Added a dot to a reference to dbg2 where it gets bit 15 set on
!		  the user saying /DEC_INTERNAL=OUTPUT_LINE_NUMBER.  Dbg2 was
!		  being loaded with its own address!
!
!	025	REM00025	Ray Marshall	17-May-1984
!		Added parameter OUTPUT_LINE_NUMBER to /DEC_INTERNAL.  This
!		  parameter sets bit 15 of debug flag word number 2.  The
!		  meaning of this bit is to force output line numbers to be put
!		  into the left margin of each line of text in the output file.
!		  Not controlled by any special parameter is but 14 which will
!		  prefix the line number with the internal output page number
!		  followed by a period.  This second bit will have to be set by
!		  the /DEC_INTERNAL=DBG2=%X4000 qualifier.
!
!	024	REM00024	Ray Marshall	11-April-1984
!		Make /DEVICE return an error for invalid entries.
!		Conditionalized the DIABLO, FLIP, & VT100 parameters of the
!		  /DEVICE qualifier for DSRPLUS only.  This way, with the
!		  change mentioned in the above entry, they will now yeald
!		  errors when given to DSR.
!		Made some changes towards making the /FORM work better when
!		  /SIMULATE isn't specified.  These are incomplete and mostly
!		  commented out for now.  The variable to look for to get to
!		  this new work is FORM_QUALIFIER.
!
!	023	REM00023	Ray Marshall	24-March-1984
!		Fixed definition of LIB$FIND_FILE_END.
!
!	022	REM00022	Ray Marshall	15-March-1984
!		Added logic to initialize and cleanup for LIB$FIND_FILE.  This
!		  routine is now called from RUNOFF.BLI to support search-lists
!		  as implemented in VMS V4.
!
!	021	REM00021	Ray Marshall	5-December-1983
!		Add [NO]LOAD parameter to the /DEVICE qualifier and make it
!		  related to the LN01[E] parameter.
!
!	020	REM00020	Ray Marshall	13-September-1983
!		Increase the logical name buffer size from 64 to 256 to
!		  accommodate the larger file specifications for VMS V4.0.
!		Add [NO]HEADER parameter to the /DEVICE qualifier and make it
!		  related to the LN01[E] parameter.
!
!	019	KAD00019	Keith Dawson	2-Jun-1983
!		Set bits RNO$V_S_RIGHT and RNO$V_S_DOWN if the qualifiers 
!		  were explicitly given.
!
!	018	REM00018	Ray Marshall	24-May-1983
!		Modify exit logic so that if one of several calls to RUNOFF
!		  returns a failure, we will also return to VMS with a failure
!		  status code.
!
!	017	REM00017	Ray Marshall	11-May-1983
!		Removed the check for error returns from the call to RUNOFF.
!		  This will allow a list of input files to continue being
!		  processed if one in the middle has errors.
!
!	016	REM00016	Ray Marshall	10-May-1983
!		Added call to SYS$PURGWS to purge the user's working set.
!		Removed the .L32 extensions from all LIBRARY commands.
!		Deconditionalized the /DEBUG=SAVE_RESTORE parameter logic to
!		  allow it to be compiled into DSR as well as DSRPLUS.
!		Many small changes to the TPARSE tables to catch unprocessed
!		  parameter text and report it as an error.
!		Single character parameter processing for all "character"
!		  expecting qualifiers has been moved out of the TPARSE tables.
!		  Now, if the parameter string is just one (1) character long,
!		  that character will be put directly into it's proper resultant
!		  field and TPARSE will not be called.
!		Removed %O, %D, & %X logic from /DEVICE TPARSE tables because
!		  it was never used.
!
!	015	KAD00015	Keith Dawson	14-Apr-1983
!		Support /DEVICE=FLIP.
!
!	014	KAD00014	Keith Dawson	20-Mar-1983
!		Removed LN01 conditionals and all references to .BIX
!		  and .BTC files.
!		Removed /OVERPRINT.
!		Changed GCA_FLIP bit to (.gca_op_dev EQL op_dev_flip).
!
!	013	KAD00013	Keith Dawson	07-Mar-1983
!		Global edit of all modules. Updated module names, idents,
!		copyright dates. Changed require files to BLISS library.
!
!--

%SBTTL 'Module Level Declarations'

!  This literal prevents the new RNODAT from being compiled in. It also
!  prevents any reference to it.

LITERAL
    NEW_RNODAT_MODULE = 1;	! Allow the new RNODAT.

!
! TABLE OF CONTENTS:
!

FORWARD ROUTINE

    rnocli,			! DSR VMS command interface routine
    call_tparse,		! Causes TPARSE to put data into command table
    save_value,			! Used by TPARSE to store a DBG1 or DBG2 value
    set_output_device_code	!

%IF NEW_RNODAT_MODULE %THEN ,
    rnodat : NOVALUE
%FI			;

!
! INCLUDE FILES:
!

LIBRARY	'SYS$LIBRARY:STARLET';	! System macros
LIBRARY	'SYS$LIBRARY:TPAMAC';	! TPARSE macros

LIBRARY 'NXPORT:XPORT';			! XPORT Library
REQUIRE 'REQ:RNODEF';			! RUNOFF variant definitions

undeclare %quote $descriptor;

%IF DSRPLUS %THEN
LIBRARY 'REQ:DPLLIB';			! DSRPLUS BLISS Library
%ELSE
LIBRARY 'REQ:DSRLIB';			! DSR BLISS Library
%FI

STRUCTURE
    BBLOCK [O, P, S, E; N] =
		[N]
		(BBLOCK + O) <P, S, E>;
!
! MACROS:
!
!
!	Define internal descripters
!
MACRO		! (n,'text')
    CSTRING[] =  %STRING( %CHAR(%CHARCOUNT(%REMAINING)),%REMAINING)%,

    string_descr [] = (uplit (%charcount (%remaining),
				ch$ptr (uplit (%string (%remaining)))))%,
    swch_automatic =  string_descr('AUTOMATIC') %,
    swch_backspace =  string_descr('BACKSPACE') %,
    swch_bold =  string_descr('BOLD') %,
    swch_change =  string_descr('CHANGE_BARS') %,
    swch_contents =  string_descr('CONTENTS') %,
    swch_cross_reference =  string_descr('CROSS_REFERENCE') %,
    swch_dec_internal =  string_descr('DEC_INTERNAL') %,
    swch_debug =  string_descr('DEBUG') %,
    swch_device =  string_descr('DEVICE') %,
    swch_down =  string_descr('DOWN') %,
    swch_form_size =  string_descr('FORM_SIZE') %,
    swch_index =  string_descr('INDEX') %,
    swch_input =  string_descr('P1') %,
    swch_intermediate =  string_descr('INTERMEDIATE') %,
    swch_log =  string_descr('LOG') %,
    swch_messages =  string_descr('MESSAGES') %,
    swch_output =  string_descr('OUTPUT') %,
    swch_pages =  string_descr('PAGES') %,
    swch_pause =  string_descr('PAUSE') %,
    swch_right =  string_descr('RIGHT') %,
    swch_separate =  string_descr('SEPARATE_UNDERLINE') %,
    swch_sequence =  string_descr('SEQUENCE') %,
    swch_simulate =  string_descr('SIMULATE') %,
    swch_spacing =  string_descr('NONSPACING_UNDERLINE') %,
    swch_underline =  string_descr('UNDERLINE_CHARACTER') %,
    swch_variant =  string_descr('VARIANT') %;

!
! EQUATED SYMBOLS:
!

LITERAL
    yes = 1,			! Used to turn indicators on
    no = 0,			! Used to turn indicators off
    logical_name_buffer_length = 256;

$LITERAL	! Literals used to dispatch within the SAVE_VALUE routine
    sv_byte_value	= $DISTINCT,
    sv_dev_header	= $DISTINCT,
    sv_dev_noheader	= $DISTINCT,
    sv_dev_italic	= $DISTINCT,
    sv_dev_landscape	= $DISTINCT,
    sv_dev_load		= $DISTINCT,
    sv_dev_noload	= $DISTINCT,
    sv_dev_portrait	= $DISTINCT,
    sv_dev_underline	= $DISTINCT,
    sv_di_dbg1		= $DISTINCT,
    sv_di_dbg2		= $DISTINCT,
    sv_output_line_numbers = $DISTINCT;

$LITERAL
    swch_id_automatic	= $DISTINCT,
    swch_id_backspace	= $DISTINCT,
    swch_id_bold	= $DISTINCT,
    swch_id_change	= $DISTINCT,
    swch_id_contents	= $DISTINCT,
    swch_id_cross_reference = $DISTINCT,
    swch_id_dec_internal= $DISTINCT,
    swch_id_debug	= $DISTINCT,
    swch_id_device	= $DISTINCT,
    swch_id_down	= $DISTINCT,
    swch_id_form_size	= $DISTINCT,
    swch_id_index	= $DISTINCT,
    swch_id_input	= $DISTINCT,
    swch_id_intermediate = $DISTINCT,
    swch_id_log		= $DISTINCT,
    swch_id_messages	= $DISTINCT,
    swch_id_output	= $DISTINCT,
    swch_id_pages	= $DISTINCT,
    swch_id_pause	= $DISTINCT,
    swch_id_right	= $DISTINCT,
    swch_id_separate	= $DISTINCT,
    swch_id_sequence	= $DISTINCT,
    swch_id_simulate	= $DISTINCT,
    swch_id_spacing	= $DISTINCT,
    swch_id_underline	= $DISTINCT,
    swch_id_variant	= $DISTINCT;

!
! OWN STORAGE:
!
OWN

    runoff_command :  $RNO_CMD,	! DSR command information block
    swch_id,			! Will contain value assigned to the swch_xxx
				!   names assigned previously.  This is used
				!   within common routines to know which
				!   qualifier is being processed.
    ln01_option_used,		! True if an LN01 option is specified
    ws_limits : VECTOR[2] INITIAL (0,%X'7FFFFFFF');

!
! EXTERNAL REFERENCES:
!
EXTERNAL ROUTINE
    RUNOFF,					! Transportable DSR entry point

    SYS$PURGWS : ADDRESSING_MODE(GENERAL),	! Purge working set
%IF NEW_RNODAT_MODULE %THEN
    SYS$NUMTIM,
%FI
    CLI$GET_VALUE : ADDRESSING_MODE(GENERAL),	! Gets switch value
    CLI$PRESENT : ADDRESSING_MODE(GENERAL),	! Checks for switch
    LIB$CVT_DTB : ADDRESSING_MODE(GENERAL),	! Converts decimal ASCII string to integer
    LIB$TPARSE : ADDRESSING_MODE(GENERAL),	! Table driven parser
    LIB$LP_LINES : ADDRESSING_MODE(GENERAL),	! Get default printer paper length
    LIB$FIND_FILE_END : 	! NEEDED to free memory used by LIB$FIND_FILE.
	WEAK  ADDRESSING_MODE(GENERAL);

EXTERNAL LITERAL
%IF DSRPLUS %THEN
    dsrplus$_facility;		! Our facility number
%ELSE
    runoff$_facility;		! Our facility number
%FI

! The following system literals are also used, but defined in STARLET:
!
!    ss$_badparam,		! "bad parameter value"
!    sts$k_severe;		! code for SEVERE (or fatal) error status

EXTERNAL LITERAL		! Value returned by CLI$PRESENT
    CLI$_ABSENT,		! Qualifier totally absent
    CLI$_PRESENT,		! 	Present and asserted (on verb)
    CLI$_DEFAULTED,		! 	absent, but defaulted in CLD
    CLI$_NEGATED,		! 	present and negated (on verb)

		! Additional values for VMS V3.1 or later

    CLI$_LOCPRES : WEAK ,	! 	present and asserted on parameter
    CLI$_LOCNEG : WEAK ;	!	present and negated on parameter

EXTERNAL
    lffctx;			! LIB$FIND_FILE context cell


%SBTTL 'TPARSE state tables'
!
!	Build a (MASK,ADDR) pair for TPARSE bit-mask table entries
!
MACRO
    xmask_[i,p,s,e]	 =	(1^((p)+(s))) - (1^(p)) %,
    mask_[]		 =	(0 OR xmask_(%REMAINING)) %,
    tpmsk_(o,p,s,e,base) =	mask_(o,p,s,e) , (base) + %UPVAL*(o) %,
    tpmskf_(fld,base)	 =	tpmsk_(%FIELDEXPAND(fld), base) %;

!
!	Tables to parse /DEBUG
!
$init_state(debug_states,debug_keys);
$state(,
    ('ALL',		tpa$_exit,,tpmsk_(%FIELDEXPAND(rno$v_deb_cond,0),
					  %FIELDEXPAND(rno$v_deb_cond,1),
					  6,0,		     runoff_command)),
    ('CONDITIONALS',	tpa$_exit,,tpmskf_(rno$v_deb_cond,   runoff_command)),
    ('CONTENTS',	tpa$_exit,,tpmskf_(rno$v_deb_cont,   runoff_command)),
%IF DSRPLUS %THEN
    ('CROSS_REFERENCES',tpa$_exit,,tpmskf_(rno$v_deb_cros,   runoff_command)),
%FI
    ('FILES',		tpa$_exit,,tpmskf_(rno$v_deb_files,  runoff_command)),
    ('INDEX',		tpa$_exit,,tpmskf_(rno$v_deb_index,  runoff_command)),
    ('SAVE_RESTORE',	tpa$_exit,,tpmskf_(rno$v_deb_save,   runoff_command))
    );
!
!	Tables to parse /MESSAGES
!
$init_state(messages_states,messages_keys);
$state(,
    ('OUTPUT',		tpa$_exit,,tpmskf_(rno$v_msg_out,    runoff_command)),
    ('USER',		tpa$_exit,,tpmskf_(rno$v_msg_user,   runoff_command)),
    (tpa$_lambda,tpa$_exit,)
    );
!
!	Tables to parse /DEVICE
!
$init_state(device_states,device_keys);
$state(dev_options,
%IF dsrplus %THEN
    ('DIABLO',		tpa$_exit,set_output_device_code,,,op_dev_diablo),
%FI
    ('LINEPRINTER',	tpa$_exit,set_output_device_code,,,op_dev_line_printer),
%IF dsrplus %THEN
    ('VT100',		tpa$_exit,set_output_device_code,,,op_dev_vt100),
    ('FLIP',		tpa$_exit,set_output_device_code,,,op_dev_flip),
%FI
    ('LN01',		tpa$_exit,set_output_device_code,,,op_dev_ln01),
    ('LN01E',		tpa$_exit,set_output_device_code,,,op_dev_ln01e),
    ('UNDERLINE',	tpa$_exit,save_value,,,sv_dev_underline),
    ('ITALIC',		tpa$_exit,save_value,,,sv_dev_italic),
    ('PORTRAIT',	tpa$_exit,save_value,,,sv_dev_portrait),
    ('LANDSCAPE',	tpa$_exit,save_value,,,sv_dev_landscape),
    ('HEADER',		tpa$_exit,save_value,,,sv_dev_header),
    ('NOHEADER',	tpa$_exit,save_value,,,sv_dev_noheader),
    ('LOAD',		tpa$_exit,save_value,,,sv_dev_load),
    ('NOLOAD',		tpa$_exit,save_value,,,sv_dev_noload),
    (tpa$_lambda,	tpa$_fail,)
    );
!
!	Tables to parse /DEC_INTERNAL
!
$init_state(dec_internal_states,dec_internal_keys);
$state(options,
    (',',		options),
    ('DBG1',		dbg1,,,,sv_di_dbg1),
    ('DBG2',		dbg1,,,,sv_di_dbg2),
    ('FLIP',		options,set_output_device_code,,,op_dev_flip),
    ('VT100',		options,set_output_device_code,,,op_dev_vt100),
    ('OUTPUT_LINE_NUMBER',	options,save_value,,,sv_output_line_numbers),
    (tpa$_lambda,tpa$_exit,)
    );

$state(,
    ('%',	which_base),
    (tpa$_lambda,tpa$_exit,)
    );

$state(dbg1,
    ('='),
    (':'),
    (',',	options)
    );
$state(,
    ('%',	which_base),
    (tpa$_hex,		options,save_value),
    (tpa$_lambda,options)
    );
$state(which_base,
    ('X',		hex_num),
    ('O',		oct_num),
    ('D',		dec_num),
    (tpa$_hex,		options,save_value),
    (tpa$_lambda,options)
    );
$state(hex_num,
    (tpa$_hex,options,save_value));
$state(oct_num,
    (tpa$_octal,options,save_value));
$state(dec_num,
    (tpa$_decimal,options,save_value));

!
!	Tables to parse /CHANGE_BARS, /UNDERLINE_CHARACTER,
!			/NONSPACING_UNDERLINE, & /SEPARATE_UNDERLINE.
!
!	For that matter, with the appropriate changes made to routine
!	SAVE_VALUE, these tables will handle any qualifier that expects to
!	be given a single character or the numeric value representing that
!	character.
!
$init_state(chars_states,chars_keys);
$state(,
    ('%',		chars_which_base,,,,sv_byte_value),
    (tpa$_eos,		tpa$_exit,),
    (tpa$_lambda,	tpa$_fail,)
    );
$state(chars_which_base,
    ('X',		chars_hex_num),
    ('O',		chars_oct_num),
    ('D',		chars_dec_num),
    (tpa$_decimal,	chars_done,save_value),
    (tpa$_hex,		chars_done,save_value),
    (tpa$_lambda,	tpa$_fail,)
    );
$state(chars_hex_num,
    (tpa$_hex,		chars_done,save_value));
$state(chars_oct_num,
    (tpa$_octal,	chars_done,save_value));
$state(chars_dec_num,
    (tpa$_decimal,	chars_done,save_value));
$state(chars_done,
    (tpa$_eos,		tpa$_exit,),
    (tpa$_lambda,	tpa$_fail,)
    );

%SBTTL 'RNOCLI -- Header and local storage'
GLOBAL ROUTINE RNOCLI =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine uses the VMS DCL CLE routines to obtain command
!	line information which is in turn passed to the DSR application
!	in a transportable manner.
!
! FORMAL PARAMETERS:	None
!
! IMPLICIT INPUTS:	None
!
! IMPLICIT OUTPUTS:	None
!
! COMPLETION CODES:
!
!	completion code from DSR
!
! SIDE EFFECTS:		None
!--

    BEGIN

    LOCAL
	desc : 			! Descriptor work area for translating #'s
		$STR_DESCRIPTOR(CLASS=DYNAMIC),
	flag_state,		! Presence/absence implicit/explicit of /FLAG
	status,			! Temporary routine completion code
	exit_status,		! Final status for return to VMS
	form_qualifier,		! Used to save the status of /FORM
	temp;			! Real temporary storage!

%SBTTL 'RNOCLI -- Initialization'
!
! Misc. internal initalization
!
! Initialize the DSR command block.
!
    $STR_DESC_INIT( DESCRIPTOR = desc,  CLASS = DYNAMIC);

    exit_status = %X'10000001';		! Initialize to normal return status.
					! Bit # 28 is also set to prevent VMS
					! from outputting any exit message on
					! our behalf.

    lffctx = 0;		! Initialize the LIB$FIND_FILE context cell

    WHILE	CLI$GET_VALUE(swch_input,desc)
    DO
	BEGIN

	    BEGIN
	    MAP runoff_command :  VECTOR;

	    INCR index FROM 0 TO RNO$K_CMD_LEN / %UPVAL - 1 DO
		runoff_command[.index] = false;
	    END;

	runoff_command[RNO$C_UNDERLINE] = %X'FF';

!
! Complete the DSR command block (RNOCMD) from the information returned by
! the DCL CLI.
!
!	NOTE :  Some RNOCMD fields are set by qualifier action routines.
!

	$STR_DESC_INIT( DESCRIPTOR = runoff_command[RNO$T_INPUT],
		CLASS = DYNAMIC);

	$STR_COPY(STRING = desc, TARGET = runoff_command[RNO$T_INPUT] );

	$STR_DESC_INIT( DESCRIPTOR = runoff_command[RNO$T_OUTPUT],
		CLASS = DYNAMIC);

	$STR_DESC_INIT( DESCRIPTOR = runoff_command[RNO$T_INTERMEDIATE],
		CLASS = DYNAMIC);

	$STR_DESC_INIT( DESCRIPTOR = runoff_command[RNO$T_PAGES],
		CLASS = DYNAMIC);

	$STR_DESC_INIT( DESCRIPTOR = runoff_command[RNO$T_VARIANT],
		CLASS = DYNAMIC);

	$STR_DESC_INIT( DESCRIPTOR = runoff_command[rno$t_drop_rec],
		CLASS = DYNAMIC);

	$STR_DESC_INIT( DESCRIPTOR = runoff_command[rno$t_program_name],
		CLASS = DYNAMIC);

	$STR_DESC_INIT( DESCRIPTOR = runoff_command[rno$t_program_filename],
		CLASS = DYNAMIC);


%SBTTL 'RNOCLI -- /AUTO /CROSS /BACK /PAUSE /SEQ /SEQ /SIM /LOG'
!
!	Pickup switch settings and setup command table accordingly
!
!	Process switches without values:  /CROSSREF /AUTOMATIC
!					  /BACKSPACE /PAUSE /SEQUENCE
!					  /SIMULATE /LOG

%IF DSRPLUS %THEN

	temp = cli$present(swch_cross_reference);

	SELECT .temp OF
	    SET

	    [CLI$_NEGATED, CLI$_PRESENT, CLI$_LOCPRES, CLI$_LOCNEG] :
		runoff_command[rno$v_s_cross_reference] = true;

	    [CLI$_ABSENT, CLI$_NEGATED, CLI$_LOCNEG] :
		runoff_command[rno$v_cross_reference] = false;

	    [CLI$_DEFAULTED, CLI$_PRESENT, CLI$_LOCPRES] :
		runoff_command[rno$v_cross_reference] = true;

	    TES;

	temp = cli$present(swch_automatic);

	SELECT .temp OF
	    SET

	    [CLI$_NEGATED, CLI$_PRESENT, CLI$_LOCPRES, CLI$_LOCNEG] :
		runoff_command[rno$v_s_automatic] = true;

	    [CLI$_ABSENT, CLI$_NEGATED, CLI$_LOCNEG] :
		runoff_command[rno$v_automatic] = false;

	    [CLI$_DEFAULTED, CLI$_PRESENT, CLI$_LOCPRES] :
		runoff_command[rno$v_automatic] = true;

	    TES;
%FI
	temp = cli$present(swch_backspace);

	SELECT .temp OF
	    SET

	    [CLI$_ABSENT, CLI$_DEFAULTED] :
		runoff_command[rno$v_s_backspace] = false;

	    [CLI$_NEGATED, CLI$_PRESENT, CLI$_LOCPRES, CLI$_LOCNEG] :
		runoff_command[rno$v_s_backspace] = true;

	    [CLI$_ABSENT, CLI$_NEGATED, CLI$_LOCNEG] :
		runoff_command[rno$v_backspace] = false;

	    [CLI$_DEFAULTED, CLI$_PRESENT, CLI$_LOCPRES] :
		runoff_command[rno$v_backspace] = true;

	    TES;

	temp = cli$present(swch_log);

	SELECT .temp OF
	    SET

	    [CLI$_ABSENT, CLI$_DEFAULTED] :
		runoff_command[rno$v_s_log] = false;

	    [CLI$_NEGATED, CLI$_PRESENT, CLI$_LOCPRES, CLI$_LOCNEG] :
		runoff_command[rno$v_s_log] = true;

	    [CLI$_ABSENT, CLI$_NEGATED, CLI$_LOCNEG] :
		runoff_command[rno$v_log] = false;

	    [CLI$_DEFAULTED, CLI$_PRESENT, CLI$_LOCPRES] :
		runoff_command[rno$v_log] = true;

	    TES;

	temp = cli$present(swch_pause);

	SELECT .temp OF
	    SET

	    [CLI$_ABSENT, CLI$_DEFAULTED] :
		runoff_command[rno$v_s_pause] = false;

	    [CLI$_NEGATED, CLI$_PRESENT, CLI$_LOCPRES, CLI$_LOCNEG] :
		runoff_command[rno$v_s_pause] = true;

	    [CLI$_ABSENT, CLI$_NEGATED, CLI$_LOCNEG] :
		runoff_command[rno$v_pause] = false;

	    [CLI$_DEFAULTED, CLI$_PRESENT, CLI$_LOCPRES] :
		runoff_command[rno$v_pause] = true;

	    TES;
!
	temp = cli$present(swch_sequence);

	SELECT .temp OF
	    SET

	    [CLI$_ABSENT, CLI$_DEFAULTED] :
		runoff_command[rno$v_s_sequence] = false;

	    [CLI$_NEGATED, CLI$_PRESENT, CLI$_LOCPRES, CLI$_LOCNEG] :
		runoff_command[rno$v_s_sequence] = true;

	    [CLI$_ABSENT, CLI$_NEGATED, CLI$_LOCNEG] :
		runoff_command[rno$v_sequence] = false;

	    [CLI$_DEFAULTED, CLI$_PRESENT, CLI$_LOCPRES] :
		runoff_command[rno$v_sequence] = true;

	    TES;

	temp = cli$present(swch_simulate);

	SELECT .temp OF
	    SET

	    [CLI$_ABSENT, CLI$_DEFAULTED] :
		runoff_command[rno$v_s_simulate] = false;

	    [CLI$_NEGATED, CLI$_PRESENT, CLI$_LOCPRES, CLI$_LOCNEG] :
		runoff_command[rno$v_s_simulate] = true;

	    [CLI$_ABSENT, CLI$_NEGATED, CLI$_LOCNEG] :
		runoff_command[rno$v_simulate] = false;

	    [CLI$_DEFAULTED, CLI$_PRESENT, CLI$_LOCPRES] :
		runoff_command[rno$v_simulate] = true;

	    TES;

%SBTTL 'RNOCLI -- /OUTPUT /INTERMEDIATE'
!
!	Process switchs specifying files: /OUTPUT /INTERMEDIATE
!	The input file(s) [currently identified as INFIL] will be processed
!	last.
!
	temp = cli$present(swch_output);

!	First, initialize all flags affected by this switch:

	runoff_command[rno$v_s_output] = false;
	runoff_command[rno$v_output] = false;
	runoff_command[rno$v_quick] = false;

	SELECT .temp OF
	    SET

	    [CLI$_NEGATED, CLI$_PRESENT, CLI$_LOCPRES, CLI$_LOCNEG] :
		runoff_command[rno$v_s_output] = true;

	    [CLI$_NEGATED, CLI$_LOCNEG] :
		    runoff_command[rno$v_quick] = true;

	    [CLI$_PRESENT, CLI$_LOCPRES
%IF NOT DSRPLUS %THEN			, CLI$_DEFAULTED %FI	] :
		    runoff_command[rno$v_output] = true;

	    [CLI$_DEFAULTED, CLI$_PRESENT, CLI$_LOCPRES] :
		cli$get_value(swch_output,runoff_command[rno$t_output]);

	    TES;

	temp = cli$present(swch_intermediate);

	SELECT .temp OF
	    SET

	    [CLI$_NEGATED, CLI$_PRESENT, CLI$_LOCPRES, CLI$_LOCNEG] :
		runoff_command[rno$v_s_intermediate] = true;

	    [CLI$_DEFAULTED, CLI$_PRESENT, CLI$_LOCPRES] :
		runoff_command[rno$v_intermediate] = true;

	    [CLI$_DEFAULTED, CLI$_NEGATED, CLI$_PRESENT, CLI$_LOCPRES, CLI$_LOCNEG] :
		cli$get_value(swch_intermediate,runoff_command[rno$t_intermediate]);

	    TES;

%SBTTL 'RNOCLI -- /CHANGE /UNDER /SEPARATE /NONSPACING'
!
!	Process switches passing ASCII characters: /CHANGE_BARS
!		/UNDERLINE_CHARACTER /SEPARATE_UNDERLINE /NONSPACING_UNDERLINE
!

	temp = cli$present(swch_change);

	SELECT .temp OF
	    SET

	    [CLI$_ABSENT, CLI$_DEFAULTED] :
		runoff_command[rno$v_s_change] = false;

	    [CLI$_NEGATED, CLI$_PRESENT, CLI$_LOCPRES, CLI$_LOCNEG] :
		runoff_command[rno$v_s_change] = true;

	    [CLI$_ABSENT] :
		runoff_command[rno$c_change] = %X'FF';

	    [CLI$_NEGATED, CLI$_LOCNEG] :
		BEGIN
		runoff_command[rno$c_change] = 0;
		runoff_command[rno$v_change] = false;
		END;

	    [CLI$_DEFAULTED, CLI$_PRESENT, CLI$_LOCPRES] :
		BEGIN
		runoff_command[rno$v_change] = true;
		swch_id = swch_id_change;
		IF cli$get_value(swch_change,desc) THEN
		    IF .desc[str$h_length] EQL 1 THEN
			runoff_command[rno$c_change] = CH$RCHAR(.desc[str$a_pointer])
		    ELSE

			( IF NOT (status = call_tparse( desc
						       ,chars_states
						       ,chars_keys) )
			    THEN RETURN (%IF DSRPLUS %THEN dsrplus$_facility
					 %ELSE	       runoff$_facility %FI ^16
					    OR ss$_badparam
					    OR sts$k_severe)  )

		ELSE
		    runoff_command[rno$c_change] = %C'|';
		END;

	    [CLI$_DEFAULTED, CLI$_NEGATED, CLI$_PRESENT, CLI$_LOCPRES, CLI$_LOCNEG] :
		BEGIN
		runoff_command[rno$v_chng_char] = true;
		IF .runoff_command[rno$c_change] EQL 0 THEN
		    runoff_command[rno$v_change] = false;
		END;

	    TES;

	temp = cli$present(swch_underline);

!	First, initialize all flags affected by this switch:

	runoff_command[rno$v_s_underline] = false;
	runoff_command[rno$v_underline] = false;
	runoff_command[rno$v_und_char] = false;

	SELECT .temp OF
	    SET

	    [CLI$_NEGATED, CLI$_PRESENT, CLI$_LOCPRES, CLI$_LOCNEG] :
		runoff_command[rno$v_s_underline] = true;

	    [CLI$_DEFAULTED, CLI$_PRESENT, CLI$_LOCPRES] :
		BEGIN
		runoff_command[rno$v_underline] = true;
		runoff_command[rno$v_und_char] = true;
		IF cli$get_value(swch_underline,desc) THEN
		    IF .desc[str$h_length] EQL 1 THEN
			runoff_command[rno$c_underline] = CH$RCHAR(.desc[str$a_pointer])
		    ELSE
			BEGIN
			swch_id = swch_id_underline;
			IF NOT (status = call_tparse( desc
						     ,chars_states
						     ,chars_keys) )
			    THEN RETURN (%IF DSRPLUS %THEN dsrplus$_facility
					 %ELSE	       runoff$_facility %FI ^16
					    OR ss$_badparam
					    OR sts$k_severe)
			END
		ELSE
		    runoff_command[rno$c_underline] = %C'_';

		END;

	    TES;

	temp = cli$present(swch_separate);

!	First, initialize all flags affected by this switch except for the
!		underline character flag:

	runoff_command[rno$v_s_und_separ] = false;
	runoff_command[rno$v_und_separ] = false;

	SELECT .temp OF
	    SET

	    [CLI$_NEGATED, CLI$_PRESENT, CLI$_LOCPRES, CLI$_LOCNEG] :
		runoff_command[rno$v_s_und_separ] = true;

	    [CLI$_DEFAULTED, CLI$_PRESENT, CLI$_LOCPRES] :
		BEGIN
		runoff_command[rno$v_und_separ] = true;
		runoff_command[rno$v_underline] = true;
		runoff_command[rno$v_und_char] = true;
		IF cli$get_value(swch_separate,desc) THEN
		    IF .desc[str$h_length] EQL 1 THEN
			runoff_command[rno$c_underline] = CH$RCHAR(.desc[str$a_pointer])
		    ELSE
			BEGIN
			swch_id = swch_id_separate;
			IF NOT (status = call_tparse( desc
						     ,chars_states
						     ,chars_keys) )
			    THEN RETURN (%IF DSRPLUS %THEN dsrplus$_facility
					 %ELSE	       runoff$_facility %FI ^16
					    OR ss$_badparam
					    OR sts$k_severe)
			END
		ELSE
		    runoff_command[rno$c_underline] = %C'-';
		END;

	    TES;

	temp = cli$present(swch_spacing);

!	First, initialize all flags affected by this switch except for the
!		underline character flag:

	runoff_command[rno$v_s_und_nonsp] = false;
	runoff_command[rno$v_und_nonsp] = false;

	SELECT .temp OF
	    SET

	    [CLI$_NEGATED, CLI$_PRESENT, CLI$_LOCPRES, CLI$_LOCNEG] :
		runoff_command[rno$v_s_und_nonsp] = true;

	    [CLI$_DEFAULTED, CLI$_PRESENT, CLI$_LOCPRES] :
		BEGIN
		runoff_command[rno$v_und_nonsp] = true;
		runoff_command[rno$v_underline] = true;
		runoff_command[rno$v_und_char] = true;
		IF cli$get_value(swch_spacing,desc) THEN
		    IF .desc[str$h_length] EQL 1 THEN
			runoff_command[rno$c_underline] = CH$RCHAR(.desc[str$a_pointer])
		    ELSE
			BEGIN
			swch_id = swch_id_underline;
			IF NOT (status = call_tparse( desc
						     ,chars_states
						     ,chars_keys) )
			    THEN RETURN (%IF DSRPLUS %THEN dsrplus$_facility
					 %ELSE	       runoff$_facility %FI ^16
					    OR ss$_badparam
					    OR sts$k_severe)
			END
		ELSE
		    runoff_command[rno$c_underline] = 7;
		END;

	    TES;

	IF .runoff_command[RNO$C_UNDERLINE] EQLU %X'FF'
	THEN
	    runoff_command[RNO$C_UNDERLINE] = no
	ELSE
	    runoff_command[RNO$V_UND_CHAR] = yes;

%SBTTL 'RNOCLI -- /PAGES /VARIANT'
!
!	Process switches passing ASCII strings parsed by DSR:
!
!				/PAGES 	/VARIANT
!
	temp = cli$present(swch_pages);

	SELECT .temp OF
	    SET

	    [CLI$_ABSENT, CLI$_NEGATED, CLI$_LOCNEG] : false;
	    [CLI$_DEFAULTED, CLI$_PRESENT, CLI$_LOCPRES] :
		cli$get_value(swch_pages,runoff_command[rno$t_pages]);

	    TES;

	temp = cli$present(swch_variant);

	SELECT .temp OF
	    SET

	    [CLI$_ABSENT, CLI$_NEGATED, CLI$_LOCNEG] : false;
	    [CLI$_DEFAULTED, CLI$_PRESENT, CLI$_LOCPRES] :
		cli$get_value(swch_variant,runoff_command[rno$t_variant]);

	    TES;

%SBTTL 'RNOCLI -- /BOLD /DOWN /RIGHT'
!
!	Process switches passing numeric arguments:  /BOLD /DOWN /RIGHT

	temp = cli$present(swch_bold);

	SELECT .temp OF
	    SET

	    [CLI$_ABSENT] :
		    runoff_command[rno$h_bold] = 1;

	    [CLI$_NEGATED, CLI$_LOCNEG] :
		    runoff_command[rno$h_bold] = 0;

	    [CLI$_DEFAULTED, CLI$_PRESENT, CLI$_LOCPRES] :
		IF cli$get_value(swch_bold,desc) THEN
		    BEGIN
		    status = lib$cvt_dtb(.desc[str$h_length],
					 .desc[str$a_pointer],
					 temp);
		    runoff_command[rno$h_bold] = .temp
		    END
		ELSE
		    runoff_command[rno$h_bold] = 1;

	    TES;

	temp = cli$present(swch_down);

	SELECT .temp OF
	    SET

	    [CLI$_ABSENT, CLI$_NEGATED, CLI$_LOCNEG] :
		    runoff_command[rno$h_down] = 0;

	    [CLI$_DEFAULTED, CLI$_PRESENT, CLI$_LOCPRES] :
		IF cli$get_value(swch_down,desc) THEN
		    BEGIN
		    status = lib$cvt_dtb(.desc[str$h_length],
					 .desc[str$a_pointer],
					 temp);
		    runoff_command[rno$h_down] = .temp
		    END
		ELSE
		    runoff_command[rno$h_down] = 5;

	    [CLI$_NEGATED, CLI$_LOCNEG, CLI$_PRESENT, CLI$_LOCPRES] :
		runoff_command[rno$v_s_down] = true;

	    TES;

	form_qualifier = cli$present(swch_form_size);

	SELECT .form_qualifier OF
	    SET

	    [CLI$_ABSENT] :
		    runoff_command[rno$h_form_size] = lib$lp_lines();

	    [CLI$_NEGATED, CLI$_LOCNEG] :
		runoff_command[rno$h_form_size] = 0;

	    [CLI$_DEFAULTED, CLI$_PRESENT, CLI$_LOCPRES] :
		IF cli$get_value(swch_form_size,desc) THEN
		    BEGIN
		    status = lib$cvt_dtb(.desc[str$h_length],
					 .desc[str$a_pointer],
					 temp);
		    runoff_command[rno$h_form_size] = .temp
		    END
		ELSE
		    BEGIN
		    runoff_command[rno$h_form_size] = lib$lp_lines();
		    form_qualifier = CLI$_ABSENT	! so /DEV works right.
		    END;
	    TES;

	temp = cli$present(swch_right);

	SELECT .temp OF
	    SET

	    [CLI$_ABSENT, CLI$_NEGATED, CLI$_LOCNEG] :
		runoff_command[rno$h_right] = 0;

	    [CLI$_DEFAULTED, CLI$_PRESENT, CLI$_LOCPRES] :
		IF cli$get_value(swch_right,desc) THEN
		    BEGIN
		    status = lib$cvt_dtb(.desc[str$h_length],
					 .desc[str$a_pointer],
					 temp);
		    runoff_command[rno$h_right] = .temp
		    END
		ELSE
		    runoff_command[rno$h_right] = 5;

	    [CLI$_NEGATED, CLI$_LOCNEG, CLI$_PRESENT, CLI$_LOCPRES] :
		runoff_command[rno$v_s_right] = true;

	    TES;


%SBTTL 'RNOCLI -- /DEBUG /DEVICE /MESSAGES /DEC_INTERNAL'
!
!	Process switches passing lists of arguments: /DEBUG /DEVICE /MESSAGES
!						     and /DEC_INTERNAL
!
	temp = cli$present(swch_debug);

!	First initialize all bits that can be set by this qualifier:

	runoff_command[rno$v_deb_cond] = false;
	runoff_command[rno$v_deb_cont] = false;
	runoff_command[rno$v_deb_files] = false;
	runoff_command[rno$v_deb_index] = false;
	runoff_command[rno$v_deb_cros] = false;
	runoff_command[rno$v_deb_save] = false;

	SELECT .temp OF
	    SET

	    [CLI$_DEFAULTED, CLI$_PRESENT, CLI$_LOCPRES] :
		WHILE cli$get_value(swch_debug,desc)
		DO call_tparse(desc,debug_states,debug_keys);

	    TES;

	temp = cli$present(swch_device);

!	First, initialize all items that can be set by this qualifier:

	runoff_command[rno$v_4_out_format] = op_dev_line_printer;
	runoff_command[rno$v_ln01_port_land] = true;	! 1 ==> portrait
	runoff_command[rno$v_ln01_ital_under] = true;	! 1 ==> italics
	runoff_command[rno$v_ln01_header] = true;	! 1 ==> O/P header info.
	runoff_command[rno$v_ln01_load] = true;		! 1 ==> O/P font load OCS

	SELECT .temp OF
	    SET

	    [CLI$_DEFAULTED, CLI$_PRESENT, CLI$_LOCPRES] :
		WHILE cli$get_value(swch_device,desc)
		DO
		    IF NOT (status = call_tparse( desc
						 ,device_states
						 ,device_keys) )
			THEN RETURN (%IF DSRPLUS %THEN dsrplus$_facility
				     %ELSE	       runoff$_facility %FI ^16
					OR ss$_badparam
					OR sts$k_severe);
	    TES;
%(
	IF .form_qualifier EQL CLI$_ABSENT  THEN    ! If we used LIB$LP_LINES
	    IF  .runoff_command[rno$v_4_out_format] EQL op_dev_ln01
					OR
		.runoff_command[rno$v_4_out_format] EQL op_dev_ln01e
	    THEN
		runoff_command[rno$h_form_size] = 255
	    ELSE
		runoff_command[rno$h_form_size] = .runoff_command[rno$h_form_size] - 6;
)%
	temp = cli$present(swch_messages);

!	First initialize all bits that can be set by this qualifier:

	runoff_command[rno$v_msg_out] = false;
	runoff_command[rno$v_msg_user] = false;

	SELECT .temp OF
	    SET

	    [CLI$_DEFAULTED, CLI$_PRESENT, CLI$_LOCPRES] :
		WHILE cli$get_value(swch_messages,desc)
		DO  IF NOT (status = call_tparse( desc
						 ,messages_states
						 ,messages_keys) )
			THEN RETURN (%IF DSRPLUS %THEN dsrplus$_facility
				     %ELSE	       runoff$_facility %FI ^16
					OR ss$_badparam
					OR sts$k_severe)

	    TES;

	temp = cli$present(swch_dec_internal);

!	First, initialize all items that can be set by this qualifier:
!
!	RNO$V_4_OUT_FORMAT has already been initialized by the processing
!	of the /DEVICE qualifier.

	runoff_command[rno$h_dbg1] = 0;
	runoff_command[rno$h_dbg2] = 0;

	SELECT .temp OF
	    SET

	    [CLI$_DEFAULTED, CLI$_PRESENT, CLI$_LOCPRES] :
		WHILE cli$get_value(swch_dec_internal,desc)
		DO call_tparse(desc,dec_internal_states,dec_internal_keys);

	    TES;

%SBTTL 'RNOCLI -- final error checking'

	!  If an LN01 option was used without specifying an LN01,
	!	report the error and exit with a fatal status.

	IF .ln01_option_used
		AND NOT
	   (.runoff_command[rno$v_4_out_format] EQL op_dev_ln01
	 OR .runoff_command[rno$v_4_out_format] EQL op_dev_ln01e)

	THEN
	    RETURN (			!  Our facility name
		%IF DSRPLUS %THEN	dsrplus$_facility
		%ELSE		runoff$_facility   %FI	^ 16)
		OR shr$_confqual	!  shared message from VMS-land
		OR sts$k_severe;	!  force FATAL status

%SBTTL 'RNOCLI -- Point to dropped record file if present'
!
! This logic is to support dropped statistical records from DSR and DSRPLUS.
! It looks for the existance of the logical "DSR$STATISTICAL_RECORDS" and, if
! present, sets up the descriptor RNO$T_DROP_REC to be pointing to the fully
! translated name.
!
! If the logical does not exist, then the descriptor RNO$T_DROP_REC will be
! left in its initialized state.
!
    BEGIN
    LOCAL
	assign_status,
	trnlog_status,
	tt_buf_desc : BLOCK [8, BYTE],
	tt_name_string : VECTOR [logical_name_buffer_length, BYTE],
	tt_name_desc : BLOCK [8, BYTE],
	logtab;

    ! Put "canned" logical name into buffer

    CH$MOVE (23, UPLIT ('DSR$STATISTICAL_RECORDS'), tt_name_string);

    ! Initialize descriptor to be pointing to the "canned" logical

    tt_name_desc [dsc$w_length] = 23;
    tt_name_desc [dsc$b_dtype] = dsc$k_dtype_t;
    tt_name_desc [dsc$b_class] = dsc$k_class_s;
    tt_name_desc [dsc$a_pointer] = tt_name_string [0];

    ! The same buffer will be receiving the system's translation of the logical
    ! names. Initialize the destination descriptor to point to the same buffer,
    ! but to indicate that buffer's full length.

    tt_buf_desc [dsc$w_length] = logical_name_buffer_length;
    tt_buf_desc [dsc$b_dtype] = dsc$k_dtype_t;
    tt_buf_desc [dsc$b_class] = dsc$k_class_s;
    tt_buf_desc [dsc$a_pointer] = tt_name_string [0];

    ! Before we attempt to translate, we first determine just which logical
    ! name table(s) we will look at (or which one(s) we will ignore).

    BEGIN
    LOCAL
	foo;

	foo = .runoff_command[rno$h_dbg1];

	IF .foo<13,1> THEN
	    logtab = 0		!  This says we look at all tables
	ELSE
	    logtab = 6		!  This says we only look at the system table.
    END;

    ! To see if the "canned" logical name is defined, perform one initial
    ! translation and look at the returned status.

    trnlog_status = $trnlog (    lognam = tt_name_desc
				,rsllen = tt_name_desc [dsc$w_length]
				,rslbuf = tt_buf_desc
				,dsbmsk = .logtab);! Don't look at process or
						! group logical name tables

    IF .trnlog_status EQL ss$_normal  THEN  ! If we are not told that no
	BEGIN				    ! translation took place, then we
					    ! must assume (at least initially)
					    ! that a logical was defined, and
					    ! we must process it.

	! However, if the return status wasn't "normal", then something went
	! wrong and we must abort processing of the logical.


	! Do the logical name translation up to 9 more times to be sure we have
	! the real destination.

	INCR i FROM 1 TO 9 DO

	    IF (trnlog_status =
		$trnlog ( lognam = tt_name_desc
			 ,rsllen = tt_name_desc [dsc$w_length]
			 ,rslbuf = tt_buf_desc
			 ,dsbmsk = 6 )		! Don't look at process or
						! group logical name tables

						  ) EQL ss$_notran
	    THEN
		EXITLOOP;

	$STR_COPY(  STRING = tt_name_desc
		   ,TARGET = runoff_command[rno$t_drop_rec] )

	END
    END;

%SBTTL 'RNOCLI -- DSR invocation and exit'
!
! Call the DSR application to process a single command line.
!

%IF NEW_RNODAT_MODULE %THEN
	rnodat ( runoff_command );		! Pickup current date & time
%FI

	status =  RUNOFF( runoff_command );	! Pass the DSR application the address
						! of the complete command information block.

	IF NOT .status				! If DSR returns a failure
	THEN					! completion code, save it for
	    exit_status = .status;		! final exit later.

	END;		! end of WHILE --- DO against input filename list
!
! Tell the RTL to dump any LIB$FIND_FILE context that it may still have
! lying around.
!
    IF LIB$FIND_FILE_END NEQA 0 THEN
	LIB$FIND_FILE_END(lffctx);
!
! Purge the working set to free up space for other users.
!
    SYS$PURGWS(ws_limits);
!
! Return to the system.
!
    RETURN .exit_status				! Return the final DSR completion code to the caller.

    END;			! End of routine RNOCLI

%SBTTL 'CALL_TPARSE -- Routine to call LIB$TPARSE'
ROUTINE call_tparse(string,states,keys) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine calls tparse given the string, states, and keys
!
! FORMAL PARAMETERS:
!
!	string		Address of string descriptor for string to parse
!	states		Address of tparse states table
!	keys		Address of tparse keys table
!
! IMPLICIT INPUTS:	none
!
! IMPLICIT OUTPUTS:	none
!
! ROUTINE VALUE:
! COMPLETION CODES:	return code of LIB$TPARSE
!
! SIDE EFFECTS:		none known
!
!--
    BEGIN

    MAP	string : REF BBLOCK;
    LOCAL
    	status,
    	tpablock : BBLOCK[tpa$k_length0];
!
!    Initialize the TPARSE block:
!
    CH$FILL(0,tpa$k_length0,tpablock);
    tpablock[tpa$l_count] = tpa$k_count0;
    tpablock[tpa$l_options] = tpa$m_abbrev;
    tpablock[tpa$l_stringcnt] = .string[dsc$w_length];
    tpablock[tpa$l_stringptr] = .string[dsc$a_pointer];
!
!    Envoke TPARSE and return with its return code:
!
    RETURN LIB$TPARSE(tpablock,.states,.keys)
    END;


%SBTTL 'SAVE_VALUE -- store values decided by $TPARSE'
ROUTINE save_value =
    BEGIN
    BUILTIN AP;
    MAP AP : REF BBLOCK;

	SELECTONE .ap[tpa$l_param] OF
	SET

	    [sv_di_dbg1] : runoff_command[rno$h_dbg1] = .AP[TPA$L_NUMBER];

	    [sv_di_dbg2] : runoff_command[rno$h_dbg2] = .AP[TPA$L_NUMBER];

	    [sv_byte_value] : BEGIN

		  SELECTONE .swch_id OF
		  SET

		    [swch_id_change] :
			runoff_command[rno$c_change] = .AP[TPA$L_NUMBER];

		    [swch_id_underline,swch_id_spacing,swch_id_separate] :
			runoff_command[rno$c_underline] = .AP[TPA$L_NUMBER];

		    [OTHERWISE] : RETURN 0;

		  TES
		  END;

	    [sv_dev_landscape] :
		    BEGIN
		    runoff_command[rno$v_ln01_port_land] = 0;
		    ln01_option_used = true
		    END;

	    [sv_dev_portrait] :
		    BEGIN
		    runoff_command[rno$v_ln01_port_land] = 1;
		    ln01_option_used = true
		    END;

	    [sv_dev_underline] :
		    BEGIN
		    runoff_command[rno$v_ln01_ital_under] = 0;
		    ln01_option_used = true
		    END;

	    [sv_dev_italic] :
		    BEGIN
		    runoff_command[rno$v_ln01_ital_under] = 1;
		    ln01_option_used = true
		    END;

	    [sv_dev_header] :
		    BEGIN
		    runoff_command[rno$v_ln01_header] = true;
		    ln01_option_used = true
		    END;

	    [sv_dev_noheader] :
		    BEGIN
		    runoff_command[rno$v_ln01_header] = false;
		    ln01_option_used = true
		    END;

	    [sv_dev_load] :
		    BEGIN
		    runoff_command[rno$v_ln01_load] = true;
		    ln01_option_used = true
		    END;

	    [sv_dev_noload] :
		    BEGIN
		    runoff_command[rno$v_ln01_load] = false;
		    ln01_option_used = true
		    END;

	    [sv_output_line_numbers] :	! generate output line numbers in the
					! output file.
		    runoff_command[rno$h_dbg2] = 
			    .runoff_command[rno$h_dbg2] + 1^15 ;

	    [OTHERWISE] : RETURN 0;

	TES;

    1			! If we get back to here, return "SUCCESS"

    END;		! End of routine SAVE_VALUE

%SBTTL 'SET_OUTPUT_DEVICE_CODE -- store O/P device type codes determined by $TPARSE'
ROUTINE set_output_device_code =
    BEGIN
    BUILTIN AP;
    MAP AP : REF BBLOCK;

	runoff_command[rno$v_4_out_format] = .ap[tpa$l_param];

    1			! Make it return "success"

    END;		! End of routine SET_OUTPUT_DEVICE_CODE

%SBTTL 'RNODAT - Get current system date and time'
%IF NEW_RNODAT_MODULE %THEN
ROUTINE rnodat (runoff_command) : NOVALUE =

!++
!
! ABSTRACT:	Obtains the system date and time in a standard format.
!
!	This routine has been made a part of RNOVMS.B32 to move all system
!	related logic into one place. It was extracted from RNODAT.BLI which
!	was at IDENT 007 at the time. This work was done by Ray Marshall on
!	August 6, 1982.
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine obtains the system date and time, breaks it
!	up into its constituents, and returns the results.
!
! FORMAL PARAMETERS:
!
!	RUNOFF_COMMAND -- the command tables into which the current system
!			  date and time will be stuffed.
!
! IMPLICIT INPUTS:	None
!
! IMPLICIT OUTPUTS:	None
!
! ROUTINE VALUE:
! COMPLETION CODES:	None
!
! SIDE EFFECTS:		None
!
!--
    BEGIN

    MAP
	runoff_command : REF $RNO_CMD;	! Define control block data structure

    LOCAL
	TIME_32 : VECTOR [7,2];

    SYS$NUMTIM (TIME_32, 0);		!Get binary date as a short-word vector.

!		Convert the system's date and time to the structure setup
!		within our command tables:

    runoff_command[RNO$H_YEAR]		= .TIME_32[0];
    runoff_command[RNO$H_MONTH]		= .TIME_32[1];
    runoff_command[RNO$H_MONTHDAY]	= .TIME_32[2];
    runoff_command[RNO$H_HOURS]		= .TIME_32[3];
    runoff_command[RNO$H_MINUTES]	= .TIME_32[4];
    runoff_command[RNO$H_SECONDS]	= .TIME_32[5];

    END;				! End of RNODAT
%FI

END					! End of module
ELUDOM
