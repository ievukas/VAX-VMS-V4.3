	.TITLE	INIT PROCESSOR INITIALIZATION
	.IDENT	'V04-000'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; SYSTEM INITIALIZATION
;
; D. HUSTVEDT 17-SEP-76
;
; MODIFIED BY:
;
;	V03-054	WMC0054		Wayne Cardoza		06-Aug-1984
;		Tie IRPMIN to SRPSIZE.
;
;	V03-053	WMC0053		Wayne Cardoza		30-Jul-1984
;		New minimum size for IRP list.
;
;	V03-052	TCM0017		Trudy C. Matthews	24-Jul-1984
;		Use the RPB$B_CTRLLTR field when determining the boot
;		device's controller letter.
;
;	V03-051	MSH0068		Michael S. Harvey	23-Jul-1984
;		Correctly initialize the HWTYPE field of the local SB.
;
;	V03-050	WHM0001		Bill Matthews		09-Jul-1984
;		Load SYSLOAxxx before during any I/O to the console terminal.
;		The console terminal I/O routines are now in SYSLOAxxx.
;
;	V03-049	LMP0275		L. Mark Pilant,		12-Jul-1984  19:57
;		Initialize the ACL info in the ORB to be a null descriptor
;		list rather than an empty queue.  This avoids the overhead
;		of locking and unlocking the ACL mutex, only to find out
;		that the ACL was empty.
;
;	V03-048	WMC0048		Wayne Cardoza		05-Jul-1984
;		Pay attention to the SRPMIN parameter.
;		Eliminate the check of LRPMIN against 480 - this used to be so 
;		that PQBs fit.
;		Add consistency checking of size against MIN for SRP, LRP.
;
;	V03-047	ROW0367		Ralph O. Weber		21-MAY-1984
;		Cause IDB$W_UNITS to be 1 in IDB created for system disk 
;		class driver.
;
;	V03-046	ROW0363		Ralph O. Weber		11-MAY-1984
;		Force DEV$M_NNM to be set before IOC$CVT_DEVNAM is called to 
;		build the translation for SYS$SYSDEVICE.  This is required to 
;		cause IOC$CVT_DEVNAM to prepend the node name or allocation
;		class name field.
;
;	V03-045	ROW0358		Ralph O. Weber		 3-MAY-1984
;		Return to using -1 in the call to IOC$CVT_DEVNAM when building 
;		SYS$SYSDEVICE.  The allocation class is not correctly known 
;		during INIT.  An allocation class device name translation for 
;		SYS$SYSDEVICE will have to be formed later in the booting 
;		process.
;
;	V03-044	ROW0352		Ralph O. Weber		27-APR-1984
;		Change name conversion flag argument from -1 (a displayable 
;		device name) to zero (an allocation class device name) in call 
;		to IOC$CVT_DEVNAM used to build SYS$SYSDEVICE logical name 
;		translation.  This causes the translation for SYS$SYSDEVICE to 
;		be useable over time and various cluster failures.  For class 
;		drivers, cause a real IDB to be allocated an initialized. This 
;		corrects a misformed I/O database problem which causes the 
;		SYSGEN command SHOW /DEVICE to crash systems and generally 
;		eliminates maintenance headaches in this area.  Also remove 
;		reference to the obsolete $LOGDEF.
;
;	V03-043	LMP0240		L. Mark Pilant,		26-Apr-1984  8:45
;		Make sure an ORB is created for the UCB when booting from an
;		HSC device.
;
;	V03-042 EMD0079		Ellen M. Dusseault	11-Apr-1984
;		Store base address of SYSLOA image in MMG$GL_SYSLOA_BASE.
;
;	V03-041	KTA3113		Kerbey T. Altmann	15-Mar-1984
;		Fill in UCB$W_MSCPUNIT for HSC/UDA/Emulated disks.
;
;	V03-040	KTA3109		Kerbey T. Altmann	11-Mar-1984
;		Fill in more fields in permanent local SB.
;
;	V03-039	MMD0251		Meg Dumont,	27-Feb-1984  17:50
;		Add support for $MTACCESS installation specific accessibility 
;		routine
;
;	V03-038	ROW0311		Ralph O. Weber		26-FEB-1984
;		Make the page setup for use by mount verification a different 
;		page from the black hole page.  Because mount verification 
;		will soon be performing read-modify-write operations on the 
;		storage control block, it must have a private page of working 
;		storage.
;
;	V03-037	ROW0274		Ralph O. Weber		 5-JAN-1984
;		Fix setup of UCB address in IDB$L_UCBLST for system disk IDB.  
;		The system disk IDB is built assuming a unit number no greater 
;		than 7.  This is not true for MSCP supported system disks.  
;		Since the MSCP disk class driver does not used IDB$L_UCBLST, 
;		simply do not setup the field when the unit number exceeds 7.
;
;	V03-036	SRB0105		Steve Beckhardt		11-Nov-1983
;		Added initialization of LCK$GB_HTBLSHFT.
;
;	V03-035	ACG0372		Andrew C. Goldstein,	11-Nov-1983  10:32
;		Change page protection of paged pool to ERKW
;
;	V03-034	TCM0016		Trudy C. Matthews	22-Sep-1983
;		Store CLU$GL_ALLOCLS in system disk's DDB.
;
;	V03-033	ROW0207		Ralph O. Weber		13-AUG-1983
;		Establish page protection of UR on all PTEs in the erase 
;		psuedo page-table.  This corrects a bug which was causing the 
;		CI port to crash because the PTEs contained a page protection 
;		of KW.
;
;	V03-032	WMC0032		Wayne Cardoza		06-Aug-1983
;		Remove setting of cluster-wide bit for system disk.
;		Fix register destroyed by misplaced MOVC5.
;
;	V03-031	RAS0175		Ron Schaefer		28-Jul-1983
;		Change definitions of SYS$SYSDEVICE and SYS$DISK
;		to be TERMINAL/CONCEALED rather than use "_"s.
;
;	V03-030	KDM0062		Kathleen D. Morse	18-Jul-1983
;		Move initialization of time-wait data cells to a
;		loadable, cpu-dependent routine, EXE$INI_TIMWAIT.
;
;	V03-029	TCM0015		Trudy C. Matthews	28-Jul-1983
;		Change "BBS" to "BBSS" in KTA3068.
;
;	V03-028	KTA3068		Kerbey T. Altmann	06-Jul-1983
;		Stuff EXE$GQ_TODCBASE into localsb as incarnation number.
;		Remove CPU-specific code in console/boot device init.
;		Add support for booting off MSCP emulated disks.
;		Make system disk always potentially cluster-wide.
;
;	V03-027	KTA3060		Kerbey T. Altmann	22-Jun-1983
;		Add support for boot device name passed in from
;		SYSBOOT.  Also make HSC disk always on 'A' controller.
;
;	V03-026	DMW4053		DMWalp			21-Jun-1983
;		Convert boot device logical name from CRELOG to CRELNM 
;
;	V03-025	TCM0014		Trudy C. Matthews	10-Jun-1983
;		Fix comment in TCM0013.
;
;	V03-024	TCM0013		Trudy C. Matthews	21-Apr-1983
;		Add new input register (R4) to call to IOC$CVT_DEVNAM.
;
;	V03-024	KDM0044		Kathleen D. Morse	03-May-1983
;		Hook instruction emulation code into SCB, if required.
;
;	V03-023	DWT0093		David W. Thiel		11-Apr-1983
;		Initialize local system block before initializing
;		CLSLOA.
;
;	V03-022	CWH1002		CW Hobbs		24-Feb-1983
;		Compute SCH$GL_PIXWIDTH cell from max process count, init
;		extended pid cells of null and swapper processes.
;
;	V03-021	TCM0012		Trudy C. Matthews	15-Feb-1983
;		Update CPUDISP cases to include 790-specific path.
;
;	V03-020	DWT0072		David W. Thiel		28-Jan-1983
;		Initialize loadable cluster code after SCS loadable code.
;
;	V03-019	STJ3057		Steven T. Jeffreys	21-Jan-1983
;		- Added code to link $ERAPAT loadable code to vectors in system.
;		- Added code to create system Erase Pattern Buffer (EPB) and
;		  the Psuedo Page Table (PPT) to map it.
;
;	V03-018	SRB0059		Steve Beckhardt		6-Jan-1983
;		Added code to link cluster loadable code to vectors
;		in system.
;
;	V03-017	KTA3022		Kerbey T. Altmann	29-Dec-1982
;		Initialize perm local system block.  Add setting
;		of scs nodename into boot device name, if applicable.
;
;	V03-015	SRB0057		Steve Beckhardt		16-Dec-1982
;		Changed initialization of lockid table to store
;		a sequence number of 1 in the 2nd word of each entry.
;
;	V03-014	TCM0011		Trudy C. Matthews	16-Dec-1982
;		Initialize R2 before calling CON$SENDCONSCMD.
;
;	V03-013	DMW4018		DMWalp			15-Dec-1982
;		Combined CRELOG logical name blocks, and pass it via
;		LNM pointer
;
;	V03-012	TCM0010		Trudy C. Matthews	10-Nov-1982
;		Use new input values in call to CON$SENDCONSCMD.
;
;	V03-011	DMW4005		DMWalp			10-Nov-1982
;		Recode logical name blocks for SYS$DISK and SYS$SYSDEVICE
;		to use external interface ( not internal ) of $CRELOG
;
;	V03-010	KTA3018		Kerbey T. Altmann	05-Nov-1982
;		Delete loading of INILOA.
;
;	V03-009	BLS0190		Benn Schreiber		19-Oct-1982
;		Ensure console terminal is not autobaud and scope
;
;	V03-008	TCM0009		Trudy C. Matthews	12-Oct-1982
;		Added a delay loop (to avoid saturating the Unibus) to the
;		calibration of the TIMEWAIT macro loop.
;
;	V03-007	WMC0001		Wayne Cardoza		28-Sep-1982
;		Give RPB a PFN data base.
;
;	V03-006	STJ3022		Steven Jeffreys		22-Sep-1982
;		Renamed routine LINK_VEC to EXE$LINK_VEC and moved it
;		to its own module, LINKVEC.  Note that EXE$LINK_VEC
;		is in a psect that is removed from the system's
;		address space by INIT, and is therefore unavailable
;		for use, in the EXEC, after INIT finishes.
;
;	V03-005	BLS0183		Benn Schreiber		16-Aug-1982
;		Changes for loadable console support
;
;	V03-004	SRB0051		Steve Beckhardt		1-Jun-1982
;		Fixed bug that occurred if the DEADLOCK_WAIT system
;		parameter was zero at boot time and then later set non-zero.
;
;

; SYSTEM INITIALIZATION
;
; MACRO LIBRARY CALLS
;
 
	$ADPDEF				; DEFINE ADP OFFSETS
	$ARCDEF				; DEFINE ARCHITECTURE BITS
	$BOODEF				; DEFINE BOOT CONTROL BLOCK OFFSETS
	$BTDDEF				; DEFINE BOOT DEVICE TYPES
	$CONDEF				; DEFINE CONSOLE FUNCTION CODES
	$CRBDEF				; DEFINE CRB OFFSETS
	$DCDEF				; DEFINE DEVICE CHARACTERISTICS
	$DDBDEF				; DEFINE DDB OFFSETS
	$DDTDEF				; DEFINE DDT OFFSETS
	$DEVDEF				; DEFINE DEVICE BITS
	$DPTDEF				; DEFINE DRIVER PROLOGUE
	$DYNDEF				; DEFINE DATA STRUCTURE TYPE CODES
	$IDBDEF				; DEFINE IDB OFFSETS
	$IPLDEF				; IPL DEFINITIONS
	$IRPDEF				; DEFINE IRP OFFSETS
	$LNMDEF				; DEFINE LNM OFFSETS
	$MPMDEF				; DEFINE MULTI-PORT MEMORY
	$MSCPDEF			; DEFINE MSCP OFFSETS
	$NDTDEF				; DEFINE NEXUS-DEVICE TYPE CODES
	$ORBDEF				; OBJECT'S RIGHTS BLOCK OFFSETS
	$PCBDEF				; DEFINE PCB OFFSETS
	$PFLDEF				; PAGE FILE OFFSET DEFINITIONS
	$PFNDEF				; PFN DATA BASE OFFSET DEFINITIONS
	$PHDDEF				; DEFINE PROCESS HEADER OFFSETS
	$PRDEF				; DEFINE IPR NUMBERS
	$PRTDEF				; DEFINE PAGE PROTECTION CODES
	$PTEDEF				; PAGE TABLE ENTRY DEFINITIONS
	$PTRDEF				; POINTER CONTROL BLOCK OFFSETS
	$RBMDEF				; Define realtime SPT bit map
	$RPBDEF				; DEFINE RESTART PARAMETER BLOCK
	$SBDEF				; Define system block offsets
	$SECDEF				; SECTION TABLE OFFSET DEFINITIONS
	$UBADEF				; DEFINE UBA REGISTER OFFSETS
	$UBIDEF				; DEFINE UNIBUS INTERCONNECT
					;  REGISTER OFFSETS
	$UCBDEF				; DEFINE UCB OFFSETS
	$TTYDEFS			; DEFINE TERMINAL DRIVER OFFSETS
	$TTDEF				; TERMINAL ATTRIBUTES
	$TT2DEF				; MORE TERMINAL-SPECIFIC ATTRIBUTES
	$VADEF				; DEFINE VIRTUAL ADDRESS FIELDS
	$VECDEF				; DEFINE VEC OFFSETS
	$WCBDEF				; DEFINE WINDOW CONTROL BLOCK OFFSETS
;
; LOCAL MACROS
;
;
; DEFINE RANGE OF PURE CODE/DATA MACRO:
;
	.MACRO	PURE,START,STOP		;
	.IF	NB	START
	.LONG	<START-<1@31>>@-7	;
	.IFF
	.LONG	0
	.ENDC
	.IF	NB	STOP
	.LONG	<STOP-^X80000200>@-7	;
	.IFF
	.LONG	0
	.ENDC
	.ENDM	PURE			;

;
; LOCAL SYMBOLS
;
; CHARACTER DEFINITIONS
;
 
CR=13					; CARRIAGE RETURN
LF=10					; LINE FEED
DYN$C_HEADLEN=12			; LENGTH OF A SELF-IDENT HEADER
;
; LOCAL DATA
;
 
	.PSECT	Z$DEBUGA,PAGE		; PSECT TO MARK BASE OF XDELTA
XDELTABASE:				;
	.PSECT	Z$INIT000,LONG		; Psect to mark base of bootstrap
EXE$A_BOOPARAM::			; parameter block.
	.PSECT	Z$INIT,PAGE
INI_BASE:				;

;
; The following Logical Name Structures must be contiguous
;
; Boot Device Logical name equivalence
;
BDL$GL_DISK_LOG::			; item list for SYS$DISK $CRELNM
					;     in SWAPPER init
	.WORD	4,LNM$_ATTRIBUTES	; size of attributes and item code
BDL_L_DISK_AT_PTR = . - BDL$GL_DISK_LOG	; attribute pointer offset
	.LONG	110$  - BDL$GL_DISK_LOG	; pointer to SYS$DISK attributes
	.LONG	0			
BDL_W_DISK_EQ_SZ  = . - BDL$GL_DISK_LOG ; equiv name size offset
	.WORD	0,LNM$_STRING		; size of string and item code
BDL_L_DISK_EQ_PTR = . - BDL$GL_DISK_LOG	; equiv name string pointer offset
	.LONG	100$  - BDL$GL_DISK_LOG	; pointer to SYS$DISK equiv name string
	.QUAD	0			; end of item list
	.BYTE	^A\_\			; space for the leading "_"
BDL_L_DISK_EQV  =  .  - BDL$GL_DISK_LOG	; equiv name string offset
100$:	.ASCII	/NNNNNN$DUC000:/	; equiv name string nnnnnn$ducu[uu]:
	.LONG	0			; safty area
	.BLKB	<<<.-BDL$GL_DISK_LOG>+15>&^C<15>>-<.-BDL$GL_DISK_LOG> ; quad
110$:	.LONG	LNM$M_TERMINAL		; terminal attr

BDL$L_SYSDLOG  == .   - BDL$GL_DISK_LOG	; item list for SYS$SYSDEVICE $CRELNM
	       	      			;     in SWAPPER init
	.WORD	4,LNM$_ATTRIBUTES	; size of attributes and item code
BDL_L_SYSD_AT_PTR = . - BDL$GL_DISK_LOG	; attribute pointer offset
	.LONG	210$  - BDL$GL_DISK_LOG	; pointer to SYS$SYSDEVICE attributes
	.LONG	0			
BDL_W_SYSD_EQ_SZ =  . - BDL$GL_DISK_LOG	; equiv name  size offset
	.WORD	0,LNM$_STRING		; size of string and item code
BDL_L_SYSD_EQ_PTR = . - BDL$GL_DISK_LOG	; equiv name string pointer offset
	.LONG	200$  - BDL$GL_DISK_LOG	; ptr to SYS$SYSDEVICE equiv name str
	.QUAD	0			; end of item list
	.BYTE	^A\_\			; space for the leading "_"
BDL_L_SYSD_EQV  =  .  - BDL$GL_DISK_LOG	; equiv name string offset
200$:	.ASCII	/NNNNNN$DUC000:/	; equiv name string nnnnnn$ducu[uu]:
	.LONG	0			; safty area
	.BLKB	<<<.-BDL$GL_DISK_LOG>+15>&^C<15>>-<.-BDL$GL_DISK_LOG>; quad
210$:	.LONG	LNM$M_TERMINAL		; terminal attr

BDL$S_CRELNM_ITMLST == . - BDL$GL_DISK_LOG

;
; MEMORY MANAGEMENT DATA		;
;
PGDCOD:
;	.LONG	<MMG$AL_PGDCOD-<1@31>>@-9 ; 1ST VPN OF PAGED CODE
	.LONG	0			; CELL IS LOADED BY INIT
	.LONG	<MMG$AL_PGDCODEN-<1@31>>@-9 ; LAST + 1 VPN OF PAGED CODE
	.LONG	<PTE$C_UR ! PTE$C_KOWN ! PTE$M_TYP1 ! PTE$M_TYP0>
					; SECTION 0 PAGE TABLE ENTRY
	PGDCODBEG=PGDCOD		; BEGINNING OF PAGED CODE
	PGDCODEND=PGDCOD+4		; LAST + 1 PAGE OF PAGED CODE
					; SECTION 0 PAGE TABLE ENTRY
PAGEDYN:
	.LONG	0			; 1ST VPN OF PAGED DYNAMIC POOL
					; STORED BY INIT CODE
	.LONG	0			; LAST + 1 VPN OF PAGED DYNAMIC POOL
					; STORED BY INIT CODE
	.LONG	<PTE$C_ERKW ! PTE$C_KOWN> ; DEMAND ZERO PTE
;
; SYSTEM WINDOW CONTROL BLOCK TEMPLATE FOR MAPPING THE SYSTEM IMAGE
;
SYSWCB:
	ASSUME	WCB$C_LENGTH EQ WCB$C_MAP
10$:	.BLKB	WCB$C_LENGTH		; ALLOCATE THE FRONT OF A WINDOW
20$:
	.=10$+WCB$W_SIZE		; FILL IN THE SIZE FIELD
	.WORD	WCB$C_LENGTH		; NOT COUNTING RETRIEVAL POINTERS
	.=10$+WCB$B_TYPE		; TYPE FIELD
	.BYTE	DYN$C_WCB
	.=10$+WCB$B_ACCESS		; ACCESS FIELD
	.BYTE	WCB$M_READ ! -		; ACCESSED FOR READ
		WCB$M_NOTFCP ! -	; NOT AN FCP WINDOW
		WCB$M_CATHEDRAL ! -	; CATHEDRAL WINDOW
		WCB$M_COMPLETE		; MAPS THE ENTIRE FILE
	.=10$+WCB$L_STVBN		; STARTING VIRTUAL BLOCK NUMBER
	.LONG	1
	.=20$				; BACK TO END OF WCB
;
; HWTYPE TABLE
;
	.ASCII	/V785/			; SPECIAL VARIANT OF 780
HWTYPE:	.ASCII	/V780/			;
	.ASCII	/V750/			;
	.ASCII	/V730/			;
	.ASCII	/V790/			;
	.ASCII	/V8SS/			;
	.ASCII	/V8NN/			;
	.ASCII	/VUV1/			; MICRO-VAX 1
	.ASCII	/VUV2/			;
;
; MESSAGES
;
NOSPACE:				; INSUFFICIENT NON-PAGED POOL
	.ASCII	<CR><LF>/%EXECINIT-F-Insufficient non-paged pool/
	.ASCIZ	<CR><LF>		;
NOPHYSMEM:				;
	.ASCII	<CR><LF>/%EXECINIT-F-Insufficient physical memory for /
	.ASCIZ	/minimum working set/<CR><LF>
NOSPT:	.ASCIZ	<CR><LF>/%EXECINIT-F-Insufficient SPT entries/<CR><LF>
BADCONUCB:				;
	.ASCIZ	<CR><LF>/%EXECINIT-F-Illegal OPA0: UCB size/<CR><LF>
BADDSKUCB:				;
	.ASCIZ	<CR><LF>/%EXECINIT-F-Illegal SYSDISK UCB size/<CR><LF>
BADTTYDRV:				;
	.ASCIZ	<CR><LF>/%EXECINIT-F-Illegally formatted terminal service/<CR><LF>
BAD_ADDRESS:
	.ASCII	<CR><LF>/%EXECINIT-F-Address is not within the/
	.ASCIZ	/ nonpaged system image, SYS.EXE/<CR><LF>
BAD_OPCODE:
	.ASCII	<CR><LF>/%EXECINIT-F-Instruction mismatch between/
	.ASCIZ	/ old opcode table and instruction stream/<CR><LF>

;+
; SYSTEM BOOT ENTRY POINTS TO START UP SYSTEM
;
; INPUTS:
;
;	R0 = PHYSICAL ADDRESS OF EXE$INIT
;	R11 = PHYSICAL ADDRESS OF RESTART PARAMETER BLOCK (RPB)
;	PR$_SBR/PR$_SLR - SET TO DESCRIBE SPT
;	PR$_P0BR/PR$_P0LR - SET TO MAP EXE$INIT VIRTUAL = REAL
;-
 
	.ALIGN	LONG
EXE$INIT::				; INIT START
	MOVL	RPB$L_BOOTR5(R11),FP	; GET DEBUG FLAGS
	MTPR	#1,S^#PR$_MAPEN		; ENABLE MAPPING
	JMP	@#10$			; AND SET PC IN SYSTEM SPACE
10$:	MOVL	EXE$GL_INTSTK,SP		; SET TO USE INTERRUPT STACK
	MOVL	EXE$GL_DEFFLAGS,EXE$GL_FLAGS	; ESTABLISH CORRECT DEFAULTS
	MOVL	EXE$GL_SCB,R1		; GET ADDRESS OF SCB
	MOVAL	@#EXE$TBIT,^X28(R1)	; CONNECT SYS.EXE TRACE,
	MOVAL	@#EXE$BREAK,^X2C(R1)	;  BREAKPOINT,
	MOVAL	@#EXE$ROPRAND,^X18(R1)	;  RESERVED OPERAND,
	MOVAL	@#EXE$ACVIOLAT,^X20(R1)	;  ACCESS VIOLATION,
	MOVAL	@#MMG$PAGEFAULT,^X24(R1) ;  AND PAGE FAULT HANDLERS TO SCB
	BITL	#<ARC$M_CHAR_EMUL!ARC$M_DCML_EMUL!ARC$M_EDPC_EMUL! - 
		ARC$M_CRC_EMUL>,G^EXE$GL_ARCHFLAG ; ARE STRING/DECIMAL/EDITPC/
					; CRC INSTRUCTIONS BEING EMULATED?
	BEQL	11$			; BR IF DONE IN HARDWARE/FIRMWARE
	MOVL	W^BOO$GL_VAXEMUL,R4	; ADR WHERE EMULATION CODE IS LOADED
	ADDL2	4(R4),R4		; GET ADR OF INITIALIZATION ROUTINE
	JSB	(R4)			; CONNECT CHAR EMUL TO SCB
11$:
	BITL	#<ARC$M_DFLT_EMUL!ARC$M_FFLT_EMUL!ARC$M_HFLT_EMUL! - ; ARE
		ARC$M_GFLT_EMUL>,G^EXE$GL_ARCHFLAG ; FLT PT INS BEING EMULATED?
	BEQL	12$			; BR IF DONE IN HARDWARE/FIRMWARE
	MOVL	W^BOO$GL_FPEMUL,R4	; ADR WHERE EMULATION CODE IS LOADED
	ADDL2	4(R4),R4		; GET ADR OF INITIALIZATION ROUTINE
	JSB	(R4)			; CONNECT FLT PT EMUL TO OPCDEC IN SCB
12$:
	BBC	S^#EXE$V_SSINHIBIT,-
		G^EXE$GL_FLAGS,14$	; IF WE ARE INHIBITING SYSTEM
	MOVAL	G^EXE$CMODKRNLX,^X40(R1) ; SERVICES, REVECTOR THE ENTRY
	MOVAL	G^EXE$CMODEXECX,^X44(R1) ; POINTS FOR THE CHMK/CHME SERVICES
14$:
	EXTZV	#VA$V_VPN,#VA$S_VPN,R1,R2 ; GET THE VPN OF THE SCB
	MOVL	@MMG$GL_SPTBASE[R2],R2	; GET PTE
	EXTZV	#PTE$V_PFN,#PTE$S_PFN,R2,R2	; EXTRACT PFN
	ASHL	#9,R2,R2		; AND CONVERT TO BYTE ADDRESS
	MTPR	R2,S^#PR$_SCBB		; SET SYSTEM CONTROL BLOCK BASE
	BBS	#RPB$V_DEBUG,FP,20$	; KEEP DEBUGGER IF REQUESTED
15$:	NOP				; SOURCE OF NOP OPCODE
	MOVB	15$,INI$BRK		; PREVENT INITIAL BREAKPOINT
	MOVL	#<<XDELTABASE-^X80000000>@-9>,-	;
		W^FREE			; SET FREE DESCRIPTOR TO RELEASE DEBUGGER
	BRB	30$			; CONTINUE WITHOUT DEBUGGER
20$:	MOVAB	@#XDELBPT,^X2C(R1)	; SET VECTOR TO BPT
	MOVAB	@#XDELTBIT,^X28(R1)	; SET TBIT VECTOR
; FOR LARGER THAN 32 MBYTES, USE LONGWORD FORMAT ...
	PFN_DISP_IF_BIGPFN_THEN		END_BIGPFN_CODE=23$
		MOVAL	G^XDS$GT_LONG_PFN,G^XDS$GL_XESTRING ; SAVED XE STRING
		MOVAL	G^XDS$GT_LONG_PFN,G^XDS$GL_XFSTRING ; SAVED XF STRING
; OTHERWISE, USE WORD FORMAT
	PFN_DISP_ELSE		ELSE_CODE=23$,COMMON_CODE=26$
		MOVAL	G^XDS$GT_WORD_PFN,G^XDS$GL_XESTRING ; SAVED XE STRING
		MOVAL	G^XDS$GT_WORD_PFN,G^XDS$GL_XFSTRING ; SAVED XF STRING
	PFN_DISP_ENDIF		COMMON_CODE=26$
30$:
;
; Load SYSLOAxxx and connect up the vectors so the console terminal I/O
; routines can be used. The initialization routine for SYSLOA is called
; later when the rest of the loadable code is initialized.
;
	INVALID				; Clear temporary boot device mapping
					; from translation buffer.
	MOVL	W^BOO$GL_SYSLOA,R2	; Address of SYSLOAxxx image in pool
	MOVL	R2,XDEL_LOADBASE	; Save base of loadable code in
					;   XDELTA X3 register
    	MOVL	R2,G^MMG$GL_SYSLOA_BASE ; store address of sysloa image in
    					; in mmg field so that sda can find it.
	MOVAL	G^EXE$AL_LOAVEC,R3	; Address of resident vectors.
	JSB	G^EXE$LINK_VEC		; Connect SYSLOA vectors
	JSB	G^CON$INIT_CTY		; Initialize the console terminal

	CLRL	R11			; INIDICATE CONSOLE TERMINAL
	MOVAL	SYS$GT_ANNOUNCE,R1	; GET ADDRESS OF ANNOUNCEMENT MESSAGE
	JSB	EXE$OUTZSTRING		; ANNOUNCE SYSTEM
;
; LOAD ARRAYS WITH VPN OF BOUNDARY BETWEEN NONPAGED AND PAGEABLE EXEC
;
	EXTZV	#VA$V_VPN,#VA$S_VPN,G^MMG$GL_PGDCOD,R0	; MAKE ADDRESS INTO VPN
	MOVL	R0,PGDCOD		; STORE IN PGDCOD ARRAY
	ASHL	#2,R0,R0		; MAKE R0 INTO BYTE INDEX INTO SPT
	MOVL	R0,PGDCOD_LIM		; LOAD THIS VALUE INTO ARRAY USED
					;  BY INI$RDONLY/INI$WRITABLE
	DECL	R0			; (UPPER LIMIT IS ONE SMALLER
	MOVL	R0,INI_RDONLY_LIST+4	;  THAN LOWER LIMIT)
;
; SET UP NONPAGED POOL LISTHEAD AND INITIAL CONTENTS
;
	MOVL	MMG$GL_NPAGEDYN,R0	; GET ADDRESS OF NON-PAGED POOL
	CLRL	(R0)			; ZAP FORWARD LINK
	MOVL	W^BOO$GL_NPAGEDYN,4(R0)	; SET SIZE OF FREE BLOCK
	MOVL	R0,EXE$GL_NONPAGED+4	; SET ADDRESS OF POOL
 
	MOVAL	@MMG$GL_SYSPHD,R5	; GET ADDRESS OF SYSTEM HEADER
	MOVB	SGN$GB_SYSPFC,PHD$B_DFPFC(R5)	; SET SYS PAGE FAULT CLUSTER
	MOVAL	EXE$GL_FLAGS,R0		; PUT FLAGS ADDRESS IN CONVENIENT PLACE
	BBC	#RPB$V_INIBPT,FP,NODEBUG ; BR IF NORMAL STARTUP(NO BREAKPOINT)
;
;	R0 = ADDRESS OF EXE$GL_FLAGS 
;	R5 = ADDRESS OF SYSTEM PROCESS HEADER.
;
	JSB	INI$BRK			; OTHERWISE BREAKPOINT
NODEBUG:				;
	MOVW	SGN$GW_MAXPRCCT,SCH$GW_PROCLIM	; SET TENATIVE LIMIT FOR PROCS
;
; SET MODIFIED PAGE WRITER PARAMETERS
;
	MOVZWL	MPW$GW_HILIM,SCH$GL_MFYLIMSV ; LIST HIGH THRESHOLD
	MOVZWL	MPW$GW_HILIM,SCH$GL_MFYLIM ; CURRENT AND SAVE VALUES
	MOVZWL	MPW$GW_LOLIM,SCH$GL_MFYLOSV ; SAVE VALUE FOR LOW THRESHOLD
	MOVZWL	MPW$GW_LOLIM,SCH$GL_MFYLOLIM ; LOW LIST THRESHOLD
	JSB	INI$WRITABLE		; SYSTEM WRITABLE UNTIL INIT COMPLETES
 

	.SUBTITLE	Alter PFN references if large PFN configuration
;+
;  If there is less than 32 Mbytes of memory described in the PFN data base
;  (MMG$GW_BIGPFN contains zero), this next block of code does nothing. 
;  Otherwise, an address table is scanned.
;
;	1.  Each address must be in the nonpaged system image.
;
;	2.  The current contents are verified as a consistency check.
;
;	3.  A new (longword context) opcode is stored at that location.
;
;  Failure of either test prevents the system from being bootstrapped with
;  more than 32 Mbytes of physical memory. (That is, the PHYSICALPAGES
;  parameter must be used to allow the system to come up using less that
;  its total amount of physical memory.)
;-

	PFN_DISP_IF_BIGPFN_THEN		END_BIGPFN_CODE=100$

	MOVAL	MMG$AL_FIXUPTBL,R1	; Address of opcode/address table
	MOVAL	MMG$AL_ENDDRIVE,R2	; SYS.EXE bounds check lower limit
	MOVL	MMG$GL_PGDCOD,R3	; SYS.EXE bounds check upper limit
10$:	MOVL	(R1)+,R0		; Get address of next fixup 
					;  (R1 now points to old opcode byte)
	BEQL	50$			; Zero indicates end of list
	CMPL	R0,R2			; Is address too small?
	BLSSU	20$			; Quit with error if too small
	CMPL	R0,R3			; Is address too large?
	BGEQU	20$			; Error exit in this case, too
	CMPB	(R1)+,(R0)		; Perform sanity check 
					;  (R1 now points to new opcode byte)
	BNEQU	30$			; Quit with error if different
	MOVB	(R1)+,(R0)		; Finally, alter the opcode 
					;  (R1 points to next address in table)
	BRB	10$			;  and go back for the next one

20$:	MOVAB	BAD_ADDRESS,R1		; Select address-out-of-range message
	BRB	40$			;  and join common termination code

30$:	MOVAB	BAD_OPCODE,R1		; Select opcode-mismatch message
40$:	CLRL	R11			; Specify console terminal
	JSB	EXE$OUTZSTRING		; Type out error message
	HALT				;  and finally halt the processor
;
;  This is the successful exit path after all opcodes have been altered. It
;  is necessary to execute an REI instruction in order that any instruction
;  lookahead be invalidated and the new opcodes used.
;
50$:	MOVPSL	-(SP)			; Store PSL for REI
	PUSHAB	B^100$			; Push PC also
	REI				; Drop through to next instruction 

	PFN_DISP_ENDIF		COMMON_CODE=100$

	.SUBTITLE	Initialize pageable system code
INI_PAGING:
	MOVL	W^BOO$GL_BOOTCB,R6	; ADDRESS OF BOOT CONTROL BLOCK
	MOVL	R6,EXE$GL_BOOTCB	; SET ADDRESS IN SYSCOMMON
	BBC	S^#EXE$V_SYSPAGING,EXE$GL_FLAGS,20$ ; BR IF NOT PAGING SYSTEM SPACE
	CLRQ	PGDCOD_LIM		; PREVENT PROTECTION SETTING
	MOVAL	@MMG$GL_SYSPHD,R5	; ADDRESS OF SYSTEM HEADER
	CVTWL	PHD$W_PSTLAST(R5),R2	; INDEX TO LAST SECTION TABLE ENTRY
	SUBL	#SEC$C_LENGTH@-2,R2	; ALLOCATED NEW SECTION TABLE ENTRY
	MOVW	R2,PHD$W_PSTLAST(R5)	; UPDATE LAST ALLOCATED ENTRY
	MOVW	R2,PGDCOD+8		; SET PAGED CODE SECTION INDEX
	ADDL	PHD$L_PSTBASOFF(R5),R5	; BASE ADDRESS OF SECTION TABLE
	MOVAL	(R5)[R2],R2		; ADDRESS OF FIRST SECTION TABLE ENTRY
	MOVL	BOO$L_SYS_VBN(R6),SEC$L_VBN(R2) ; MAP THE ENTIRE SYSTEM IMAGE
	CLRL	SEC$L_VPXPFC(R2)	; STARTS AT SYS VIRTUAL PAGE 0
	MOVL	BOO$L_SYS_MAP(R6),SEC$L_WINDOW(R2) ; SYSTEM WINDOW
	MOVL	#1,SEC$L_REFCNT(R2)	; MAKE REFERENCE COUNT NON-ZERO
	MOVAL	W^PGDCOD,R5		; SET SPT FOR PAGED CODE
	BSBW	FILLSPT			; AND RELEASE THE PAGES OCCUPIED
20$:					;
;
;	PLACE ALL PAGES CURRENTLY REMAINING IN PFNMAP ON THE FREE LIST
;
INI_FREEMEM:				;
	MOVL	EXE$GL_RPB,R6		; GET ADDRESS OF RPB	
	MOVL	#<<EXE$RESTART-^X80000000>@-9>,R0 ; VPN OF RESTART ROUTINE
	MOVL	@MMG$GL_SPTBASE[R0],R0	; GET PTE FOR RESTART ROUTINE
	EXTZV	#PTE$V_PFN,#PTE$S_PFN,R0,R0	; EXTRACT PFN
	ASHL	#9,R0,RPB$L_RESTART(R6)	; SAVE PHYSICAL ADDRESS OF RESTART ROUTINE
	CLRL	RPB$L_CHKSUM(R6)	; INIT CHECKSUM ACCUMULATOR
	CLRL	RPB$L_RSTRTFLG(R6)	; ENABLE RESTART
	MOVAB	EXE$RESTART,R0		; ADDRESS OF RESTART ROUTINE
	MOVL	#^X1F,R1		; COUNT OF LONGWORDS IN CHECKSUM
5$:	ADDL	(R0)+,RPB$L_CHKSUM(R6)	; ACCUMULATE CHECKSUM OF RESTART ROUTINE
	SOBGTR	R1,5$			; FOR ALL 31 LONGWORDS
	MFPR	#PR$_SBR,RPB$L_SBR(R6)	; SAVE SBR VALUE FOR RESTART
	MFPR	#PR$_SLR,RPB$L_SLR(R6)	; SAVE SLR VALUE FOR RESTART
	MFPR	#PR$_SCBB,RPB$L_SCBB(R6); AND SCB BASE ADDRESS
	CLRL	RPB$L_ISP(R6)		; CLEAR "SUCCESSFUL POWERFAIL" FLAG
	ROTL	#<32-9>,RPB$Q_PFNMAP+4(R6),R4 ; STARTING PFN OF BITMAP
	MOVL	MMG$GL_MAXPFN,R0	; START WITH HIGHEST PFN INCLUSIVE
	ASHL	#-12,R0,R1		; GET BITMAP PAGE NUMBER
	ADDL	R1,R4			; FIRST BITMAP PAGE TO MAP
	MOVL	SWP$GL_BALBASE,R7	; VA TO REFERENCE BITMAP PAGES
10$:	BISL3	#<PTE$C_ERKW!PTE$M_VALID!PTE$C_KOWN>,R4,-
	@SWP$GL_BALSPT			; MAP A PAGE OF THE PFN BITMAP
	INVALID	R7			; AND INVALIDATE THAT VA
	EXTZV	#0,#12,R0,R5		; BITMAP PAGE RELATIVE PFN
20$:	BBC	R5,(R7),30$		; BRANCH IF THIS PFN IS NOT USABLE
	JSB	MMG$DALLOCPFN		; MAKE USABLE PFN AVAILABLE
30$:	DECL	R0			; NEXT PFN TO CHECK
	BEQL	50$			; PFN ZERO MAY NOT BE USED
	CMPL	R0,MMG$GL_MINPFN	; DONE THEM ALL?
	BLSS	50$			; BRANCH IF YES
	SOBGEQ	R5,20$			; DO THE NEXT PAGE IN THIS BITMAP PAGE
	SOBGEQ	R4,10$			; DO THE NEXT BITMAP PAGE
					; THIS DOES NOT FALL THROUGH
50$:	CLRL	@SWP$GL_BALSPT		; CLEAN UP THE MAP ENTRY
	INVALID	R7			; AND THE TRANSLATION BUFFER
 
;
; INITIALIZE SPT FOR PAGED DYNAMIC POOL
;
INI_PAGDYN:				;
	EXTZV	#VA$V_VPN,#VA$S_VPN,MMG$GL_PAGEDYN,R4 ; VPN OF PAGED POOL
	ASHL	#-9,SGN$GL_PAGEDYN,R0	; OTHERWISE INIT IT AS NON-PAGED
	ADDL3	R0,R4,R5		; IF NOT PAGING POOL
	MOVL	MMG$GL_PAGEDYN,EXE$GL_PAGED	; SET ADDRESS OF PAGED POOL
	BBS	S^#EXE$V_POOLPGING,EXE$GL_FLAGS,30$ ; BRANCH IF PAGING PAGED POOL
10$:	MOVL	@MMG$GL_SPTBASE[R4],R0	; SPT ENTRY
	JSB	MMG$ALLOCPFN		; OTHEWISE GET A PFN
	BBC	#31,R0,20$		; BRANCH IF GOT ONE
	HALT				; NO PAGES FOR POOL, DISASTER!!
20$:	BICL	#^C<PTE$M_PFN>,R0	; LEAVE ONLY PFN BITS
	BISL3	#<PTE$M_VALID ! PTE$C_ERKW ! PTE$C_KOWN>,-
		R0,@MMG$GL_SPTBASE[R4]	; SET NEW PAGE TABLE ENTRY
	BSBW	SETRESIDENT		; SET THE PFN RESIDENT
	AOBLSS	R5,R4,10$		; FOR EACH PAGE IN THE POOL
	BRB	40$			; 
 
;
; SET UP ADDRESS OF PAGED POOL AND INIT IT FOR PAGING IF ENABLED
;
30$:	MOVAL	W^PAGEDYN,R5		; ADDRESS OF PAGED POOL DESCRIPTORS
	MOVL	R4,(R5)			; 1ST VPN OF PAGED POOL
	ASHL	#-9,SGN$GL_PAGEDYN,-(SP); GET SIZE OF PAGED POOL IN PAGES
	ADDL3	(SP)+,R4,4(R5) 		; LAST + 1 OF PAGED POOL
	BSBW	FILLSPT			; SET SPT FOR PAGED POOL
40$:					;
;
; INITIALIZE LOOKASIDE I/O PACKET POOL
;
INI_IRP:				;
	MOVQ	W^BOO$GL_SPLITADR,R0	; R0 = BASE ADDRESS OF IRP LIST
					; R1 = NO. OF IRP'S TO INITIALIZE
	MOVL	R0,EXE$GL_SPLITADR	; SET LOOKASIDE LIST SPLIT ADDRESS
	MOVL	R1,IOC$GL_IRPCNT	; SET CURRENT COUNT OF IRPS
	BEQL	INI_LRP			; SKIP IF NONE
	BRB	140$			; 0 OR MORE TRIPS THROUGH THE LOOP
130$:	INSQUE	(R0),@IOC$GL_IRPBL	; INSERT I/O PACKET IN LOOKASIDE LIST
	MOVW	#<IRP$C_LENGTH+^XF>&<^C<^XF>>,IRP$W_SIZE(R0) ; SET SIZE
	ADDL	#<IRP$C_LENGTH+^XF>&<^C<^XF>>,R0 ; ADVANCE TO NEXT I/O PACKET
140$:	SOBGEQ	R1,130$			;
	EXTZV	#0,#9,R0,R2		; GET OFFSET IN PAGE
	BEQL	INI_LRP			; IF ZERO, NO PARTIAL PACKET
	SUBL3	R2,#512,(R0)		; SAVE SIZE OF PARTIAL PACKET IN
					;  FIRST LONGWORD OF FRAGMENT
	MOVL	R0,IOC$GL_IRPREM	; SAVE ADDRESS OF PARTIAL PACKET
;
; INITIALIZE LARGE REQUEST PACKET LOOK ASIDE LIST
;
INI_LRP:
	MOVL	W^BOO$GL_LRPSIZE,R2	; LRP SIZE FROM SYSBOOT
	MOVL	R2,IOC$GL_LRPSIZE	; STORE LRP SIZE
	MOVL	W^BOO$GL_LRPMIN,IOC$GL_LRPMIN ; STORE LRP MINIMUM SIZE 
	CMPL	R2,IOC$GL_LRPMIN	; MAKE SURE MIN < SIZE
	BGEQU	10$
	MOVL	R2,IOC$GL_LRPMIN	; USE MIN = SIZE
10$:	MOVQ	W^BOO$GL_LRPSPLIT,R0	; R0 = LRP LOOKASIDE LIST SPLIT ADR
					; R1 = NO. OF LRP'S TO INITIALIZE
	MOVL	R0,IOC$GL_LRPSPLIT	; SET LOOKASIDE LIST SPLIT ADDRESS
	MOVL	R1,IOC$GL_LRPCNT	; SAVE CURRENT LRP COUNT
	BEQL	50$			; SKIP IF NONE
	BRB	40$			; 0 OR MORE TRIPS THROUGH LOOP
30$:	INSQUE	(R0),@IOC$GL_LRPBL	; INSERT I/O PACKET IN LOOKASIDE LIST
	MOVW	R2,IRP$W_SIZE(R0)	; SET SIZE
	ADDL	R2,R0			; ADVANCE TO NEXT I/O PACKET
40$:	SOBGEQ	R1,30$			;
	EXTZV	#0,#9,R0,R1		; GET OFFSET IN PAGE
	BEQL	50$			; IF ZERO, NO PARTIAL PACKET
	SUBL3	R1,#512,(R0)		; SAVE SIZE OF PARTIAL PACKET IN
					;  FIRST LONGWORD.
	MOVL	R0,IOC$GL_LRPREM	; SAVE ADDRESS OF PARTIAL PACKET
50$:					;
;
; INITIALIZE SMALL REQUEST PACKET LOOK ASIDE LIST
;
INI_SRP:
	MOVL	SGN$GL_SRPSIZE,R2	; SRP SIZE FROM SYSBOOT
	ADDL	#15,R2			; ROUND UP TO 16 BYTE BOUNDARY
	BICL	#15,R2
	MOVL	R2,IOC$GL_SRPSIZE	; STORE SRP SIZE
	MOVL	SGN$GL_SRPMIN,IOC$GL_SRPMIN ; ** NOTE MEMORYALC MAY IGNORE THIS
	CMPL	R2,IOC$GL_SRPMIN	; MAKE SURE MIN < SIZE
	BGEQU	10$
	MOVL	R2,IOC$GL_SRPMIN	; USE MIN = SIZE
10$:	MOVL	W^BOO$GL_SRPSPLIT,R0	; R0 = SRP LOOKASIDE LIST SPLIT ADR
	MOVL	SGN$GL_SRPCNT,R1	; R1 = NO. OF SRP'S TO INITIALIZE
	MOVL	R0,IOC$GL_SRPSPLIT	; SET LOOKASIDE LIST SPLIT ADDRESS
	MOVL	R1,IOC$GL_SRPCNT	; SAVE CURRENT SRP COUNT
	BEQL	50$			; SKIP IF NONE
	BRB	40$			; 0 OR MORE TRIPS THROUGH LOOP
30$:	INSQUE	(R0),@IOC$GL_SRPBL	; INSERT I/O PACKET IN LOOKASIDE LIST
	MOVW	R2,IRP$W_SIZE(R0)	; SET SIZE
	ADDL	R2,R0			; ADVANCE TO NEXT I/O PACKET
40$:	SOBGEQ	R1,30$			;
	EXTZV	#0,#9,R0,R1		; GET OFFSET IN PAGE
	BEQL	50$			; IF ZERO, NO PARTIAL PACKET
	SUBL3	R1,#512,(R0)		; SAVE SIZE OF PARTIAL PACKET IN
					;  FIRST LONGWORD.
	MOVL	R0,IOC$GL_SRPREM	; SAVE ADDRESS OF PARTIAL PACKET
50$:					;
	
	MOVL	IOC$GL_SRPSIZE,IOC$GL_IRPMIN ; SET MIN SIZE
	INCL	IOC$GL_IRPMIN		; DON'T LEAVE A HOLE AFTER SRP SIZE
	MOVL	EXE$GL_NONPAGED,R11	; Save IPL for pool allocation.
	MFPR	S^#PR$_IPL,-		; Set it to 31 for allocations
		EXE$GL_NONPAGED		; during INIT execution.
;
; SET UP FILEREAD GLOBAL PARAMETERS PASSED FROM SYSBOOT
;
	MOVQ	W^BOO$GQ_FILCACHE,FIL$GQ_CACHE ; SET UP CACHE
	MOVC3	#10,W^BOO$GT_TOPSYS,FIL$GT_TOPSYS ; SET TOP LEVEL SYSTEM DIR
;
; NO ALLOCATION OF NON-PAGED POOL BEFORE THIS POINT !!!!
;

	.SBTTL	Miscellaneous Initialization
;
; Initialize the permanent local system block.
;
	MOVAL	@#SCS$GA_LOCALSB,R5		; Cover the system block
	MOVQ	@#SCS$GB_SYSTEMID, -
		 SB$B_SYSTEMID(R5)		; Set in the systemid
	CLRW	SB$B_SYSTEMID+6(R5)		; Just in case
	MOVL	#^A/VMS /,SB$T_SWTYPE(R5)	; Set operating system name
	MOVL	#SYS$K_VERSION,SB$T_SWVERS(R5)	; Set operating system version
;
; Set NODE_HWTYPE value based upon the CPUTYPE value. This code is modeled
; on the CPUDISP macro.
;
	MOVZBL	G^EXE$GB_CPUTYPE,R0		; Get CPU type and use as index
	SOBGTR	R0,60$				; If GTR, then type <> 780
	BBC	#23,G^EXE$GB_CPUDATA,60$	; If bit clear, then not a 785
	DECL	R0				; Set up as 785
60$:	MOVL	HWTYPE[R0],SB$T_HWTYPE(R5)	; Store CPU type string in SB

	MOVQ	G^EXE$GB_CPUDATA,SB$B_HWVERS(R5); Copy CPU data (hardware/ ucode
	LOCC	#^A/ /,#8,@#SCS$GB_NODENAME	; Find the end of the name
	SUBL3	R0,#8,R0			; Calculate name size
	MOVB	R0,SB$T_NODENAME(R5)		; Insert size
	MOVQ	@#EXE$GQ_TODCBASE,-		; Copy the last boot time
		 SB$Q_SWINCARN(R5)		;  as the incarnation number
	MOVC5	R0,@#SCS$GB_NODENAME,#0,#15, -
		 SB$T_NODENAME+1(R5)		; Insert the name

	.SBTTL	Connect up loadable CPU-dependent code (SYSLOAxxx.EXE)
;
; The loadable CPU-dependent image (SYSLOAxxx.EXE) is now allocated 
; non-paged pool space and read into it by SYSBOOT.  The address of this
; code is passed in BOO$GL_SYSLOA.  Link the resident system vectors at
; EXE$AL_LOAVEC.  The loadable file now has self-describing vector and
; offset information within it.
;
; The SYSLOAxxx.EXE image starts with a longword containing the load image
; size, a longword of zero, a longword of standard pool header, followed
; by a list of self describing entries.  Each entry consists of a type byte
; and a longword self-relative offset to the loaded subroutine.
;
INI_LOADCODE:
	INVALID				; Clear temporary boot device mapping
					; from translation buffer.
	MOVL	W^BOO$GL_SYSLOA,R4	; Address of SYSLOAxxx image in pool
	BSBB	LINK_INIT_RTN		; Call initialization routine
					; SYSLOAxxx has already been connected


;
; Connect up loadable $ERAPAT code.  The loadable $ERAPAT code image
; (ERAPATLOA.EXE) has been loaded into pool (if necessary) by SYSBOOT.
; The address of the code is passed in BOO$GL_ERAPATLOA.  Link the system
; vectors (at EXE$ERAPAT_VEC) to the loaded code if the code was loaded.
;

ERAPAT_LOADCODE:
	MOVL	W^BOO$GL_ERAPATLOA,R2	; Get address in pool of loaded code
	BEQL	10$			; It wasn't loaded
	MOVAL	G^EXE$ERAPAT_VEC,R3	; Get address of vectors in SYS.EXE
	BSBB	LINK_INIT		; Connect vectors to loaded routines
10$:

; Connect up loadable $MTACCESS code.  The loadable $MTACCESS code image
; (MTACCESS.EXE) has been loaded into pool (if necessary) by SYSBOOT.
; The address of the code is passed in BOO$GL_MTACCESSLOA.  Link the system
; vectors (at EXE$MTACCESS_VEC) to the loaded code if the code was loaded.

MTACCESS_LOADCODE:
	MOVL	W^BOO$GL_MTACCESSLOA,R2	; Get address in pool of loaded code
	BEQL	10$			; It wasn't loaded
	MOVAL	G^EXE$MTACCESS_VEC,R3	; Get address of vectors in SYS.EXE
	BSBB	LINK_INIT		; Connect vectors to loaded routines
10$:

	.SBTTL	Connect up loadable SCS code (SCSLOA.EXE)
;
; The loadable SCS code image (SCSLOA.EXE) is now allocated non-paged 
; pool space and read into it by SYSBOOT.  The address of this code
; is passed in BOO$GL_SCSLOA.  Link the resident system vectors at
; SCS$AL_LOAVEC.  The loadable file has self-describing vector and
; offset information within it.
;
SCS_LOADCODE:
	MOVL	W^BOO$GL_UCODE,-	; Transfer the address of any
		G^SCS$GL_MCADR		;  loaded microcode
	MOVL	W^BOO$GL_SCSLOA,R2	; Address of SCSLOA image in pool
	BEQL	10$			; Not loaded
	MOVAL	G^SCS$AL_LOAVEC,R3	; Address of resident vectors.
	BSBB	LINK_INIT		; Connect vectors to loaded routines
10$:


;
; Connect up loadable cluster code.  The loadable cluster code image
; (CLUSTRLOA.EXE) has been loaded into pool (if necessary) by SYSBOOT.
; The address of the code is passed in BOO$GL_CLSLOA.  Link the system
; vectors (at CLU$AL_LOAVEC) to the loaded code if the code was loaded.
;
; This must be initialized AFTER the SCS loadable code.
; This must be initialized after and after the local sytstem block.
;
CLU_LOADCODE:
	MOVL	W^BOO$GL_CLSLOA,R2	; Get address in pool of loaded code
	BEQL	10$			; It wasn't loaded
	MOVAL	G^CLU$AL_LOAVEC,R3	; Get address of vectors in SYS.EXE
	BSBB	LINK_INIT		; Connect vectors to loaded routines
10$:
	BRB	END_LOA

LINK_INIT:
	MOVL	R2,R4			; Save
	JSB	G^EXE$LINK_VEC		; Connect vectors to loaded routines.
LINK_INIT_RTN:
	MOVL	4(R4),R0		; Possible initialization routine
	BEQL	9$			; None, leave
	JSB	(R0)[R4]		; Call it
	BLBS	R0,9$			; No errors
	BSBW	NOPOOLERR		; Trouble! Not enough memory
	HALT				; **** FATAL ERROR ****

9$:	RSB

END_LOA:

	.SBTTL	Initialize real time SPT bit map
;
; Allocate and initialize a bit map that describes the SPTs reserved
; via a SYSBOOT parameter for use by real time processes that issue
; connect to interrupt requests.
;
INI_SPT:
;
; See if the number of real time SPTs requested by the system
; parameter is available in the SPT free list.
;
	MOVL	G^EXE$GL_RTIMESPT,R5	; Get number requested.
	BNEQ	5$			; If any, branch and proceed.
	BRW	END_INISPT		; in system initialization.

5$:	ADDL3	G^BOO$GL_SPTFREL,R5,R6	; Add to base of free SPTs.
	CMPL	R6,G^BOO$GL_SPTFREH	; Are there enough left?
	BLEQ	10$			; Yes. Branch forward.
	MOVAB	NOSPT,R1		; No. Report error.
	CLRL	R11			; Specify console terminal
	JSB	EXE$OUTZSTRING		; Output error report.
	HALT				; And halt processor.
;
; Calculate size of bit map control block needed and allocate it.
;
10$:	ASHL	#-5,R5,R1		; Calculate number of longwords
					; needed for bit map.
	BITL	#^X1F,R5		; Need to round up?
	BEQL	20$			; No. Branch forward.
	INCL	R1			; Yes. Add one more longword.
20$:	ASHL	#2,R1,R1		; Convert to byte count.
	ADDL	#RBM$K_LENGTH,R1	; R1 = realtime bitmap block size.
	BSBW	ALONONPAGED		; Allocate from nonpaged pool.
					; ALONONPAGED halts on error.
	MOVL	R2,G^EXE$GL_RTBITMAP	; Save block address.
	MOVL	R2,R7			; Get another copy of block address.
;
; Translate starting offset of starting SPT to the system virtual
; address of the page table entry. Then initialize the control block.
;
	ASSUME	RBM$L_STARTVPN EQ 0
	MOVL	G^BOO$GL_SPTFREL,(R7)+	; Store starting virtual page
					; number in control block.
	MOVL	R6,G^BOO$GL_SPTFREL	; Save new first free SPT.
	ASSUME	RBM$L_FREECOUNT EQ RBM$L_STARTVPN+4
	MOVL	R5,(R7)+		; Store number of SPTs.
	ASSUME	RBM$W_SIZE EQ RBM$L_FREECOUNT+4
	MOVW	R1,(R7)+		; Set block size.
	ASSUME	RBM$B_TYPE EQ RBM$W_SIZE+2
	MOVW	#DYN$C_RBM,(R7)+	; Store block type.
	ASSUME	RBM$L_BITMAP EQ RBM$B_TYPE+2
;
; In the bit map section of the control block, set each bit that
; corresponds to a reserved SPT.
;
	CLRL	R6			; Starting bit number is zero.
30$:	CMPL	#32,R5			; More than a longword of bits to set?
	BGEQ	40$			; No. Do last longword.
	INSV	#-1,R6,#32,-		; Set a longword worth of bits.
		RBM$L_BITMAP(R2)
	ADDL	#32,R6			; Move to next longword.
	SUBL	#32,R5			; Decrement count by bits set.
	BRB	30$			; Go alter more bits.

40$:	INSV	#-1,R6,R5,-		; Set remaining bits.
		RBM$L_BITMAP(R2)
END_INISPT:

	.SBTTL	Initialize Lock Manager Data Structures
;
; ALLOCATE AND INITIALIZE THE LOCK ID TABLE, THE RESOURCE HASH TABLE AND
; THE PROCESS BITMAP.  THE LOCK ID TABLE IS INITIALIZED WITH EACH LONGWORD 
; CONTAINING THE INDEX OF THE NEXT LONGWORD.  THE RESOURCE HASH TABLE 
; IS INITIALIZED TO ZERO.  THE PROCESS BITMAP DOES NOT HAVE TO BE
; INITIALIZED.
;
INI_LCKIDTBL:
	MULL3	#4,LCK$GL_IDTBLSIZ,R1	; MULTIPLY NUMBER OF ENTRIES BY 4
	ADDL	#12,R1			; AND ALLOCATE THAT SIZE + 12
	BSBW	ALONONPAGED		; BYTES OF PREFIX
	MOVL	R1,0(R2)		; STORE SIZE ALLOCATED
	TSTW	2(R2)			; IS IT BIGGER THAN 65K?
	BNEQ	5$			; YES
	MOVW	R1,8(R2)		; NO, STORE SIZE IN SIZE FIELD
5$:	MOVB	#DYN$C_LKID,10(R2)	; STORE STRUCTURE TYPE
	MOVAB	12(R2),LCK$GL_IDTBL	; STORE ADDRESS OF START OF TABLE
	ADDL	#16,R2			; POINT TO SECOND ENTRY IN TABLE
	SUBL	#16,R1			; COMPUTE NUMBER OF ENTRIES
	DIVL	#4,R1			; LESS ONE
	MOVL	R1,LCK$GL_MAXID		; STORE MAX LOCK ID
	MOVL	#1,LCK$GL_NXTID		; INITIALIZE NEXT ID TO 1
	MOVL	#2,R3			; SETUP TO INITIALIZE REST OF TABLE
10$:	MOVW	R3,(R2)+		; STORE INDEX OF NEXT ENTRY IN THIS ENTRY
	MOVW	#1,(R2)+		; STORE SEQUENCE NUMBER
	AOBLEQ	R1,R3,10$		; REPEAT FOR ALL ENTRIES EXCEPT THE LAST
	MOVL	#^X10000,(R2)+		; STORE LAST ENTRY
;
; ALLOCATE RESOURCE HASH TABLE.  THE NUMBER OF ENTRIES IN THE HASH TABLE
; MUST BE A POWER OF TWO.  SO THE ALLOCATED SIZE IS THE SMALLEST POWER OF
; TWO LARGER THAN THE SYSGEN PARAMETER.
;
INI_RESHTBL:
	MOVL	#1,R1			; SMALLEST POSSIBLE HASH TABLE IS 1 ENTRY
	CLRL	R4			; R4 WILL BE POWER OF TWO ENTRIES
10$:	CMPL	R1,LCK$GL_HTBLSIZ	; IS R1 >= SPECIFIED SIZE?
	BGEQU	20$			; YES
	MULL	#2,R1			; NO - MULTIPLY SIZE BY TWO
	INCL	R4			; INCREMENT POWER OF TWO
	BRB	10$			; REPEAT

20$:	MULL	#4,R1			; MULTIPLY # OF ENTRIES BY 4
	ADDL	#12,R1			; ADD IN OVERHEAD
	BSBW	ALONONPAGED		; ALLOCATE MEMORY
	MOVW	R1,8(R2)		; STORE SIZE OF STRUCTURE
	MOVB	#DYN$C_RSHT,10(R2)	; STORE STRUCTURE TYPE
	MOVAB	12(R2),LCK$GL_HASHTBL	; STORE POINTER TO HASH TABLE
	MOVL	R4,LCK$GL_HTBLCNT	; STORE POWER OF TWO COUNT OF ENTRIES
	SUBB3	#16,R4,LCK$GB_HTBLSHFT	; STORE IT AS A RIGHT SHIFT COUNT
					; NOTE: HASH TABLE INITIALIZED TO ZERO
;
; ALLOCATE PROCESS BITMAP.  THIS BITMAP HAS ONE BIT FOR EVERY POSSIBLE
; PROCESS IN THE SYSTEM.
;
INI_PRCBITMAP:
	MOVZWL	SGN$GW_MAXPRCCT,R1	; GET MAX. # OF PROCESSES IN SYSTEM
	DIVL	#8,R1			; COMPUTE # OF BYTES NEEDED
	ADDL	#13,R1			; ADD IN OVERHEAD PLUS EXTRA BYTE
					; TO HANDLE TRUNCATION ERROR
	BSBW	ALONONPAGED		; ALLOCATE MEMORY
	MOVW	R1,8(R2)		; STORE SIZE OF STRUCTURE
	MOVW	#<DYN$C_PRCMAP@8>+DYN$C_INIT,10(R2) ; STORE STRUCTURE TYPE
	SUBL3	#12,R1,4(R2)		; STORE SIZE OF BITMAP PORTION ONLY
	MOVAB	12(R2),LCK$GL_PRCMAP	; STORE POINTER TO BITMAP

	.SBTTL	Initialize Process State
;
; INIT PROCESS STATE
;
 
INI_PSTATE:				;
	MOVZWL	SGN$GW_MAXPRCCT,R1	; GET TOTAL COUNT OF PROCESSES
	INCL	R1			; ADD ONE FOR SYSTEM HEADER
	MULL	#6,R1			; 2 BYTES FOR SEQ + 4 BYTES FOR PCB ADDR
	ADDL	#DYN$C_HEADLEN,R1	; ADD IN HEADER LENGTH
	BSBW	ALONONPAGED		; ALLOCATE SPACE FOR SEQUENCE VECTOR
					; AND PCB VECTOR
	CLRQ	(R2)+			; CLEAR OUT TRASH
	MOVW	R1,(R2)+		; SET IN SIZE
	MOVW	#<DYN$C_PCBVEC@8!DYN$C_INIT>,(R2)+ ; SET TYPE AND SUBTYPE
	MOVL	R2,SCH$GL_PCBVEC	; SAVE POINTER TO PCB VECTOR
	MOVZWL	SGN$GW_MAXPRCCT,R1	; GET COUNT OF PROCESSES
	MOVAL	4(R2)[R1],SCH$GL_SEQVEC	; SET BASE OF SEQUENCE VECTOR
	MOVAL	MMG$AL_SYSPCB,(R2)[R1]	; SET POINTER TO SYSTEM PCB
	MOVL	(R2)[R1],R0		; GET POINTER TO SYSTEM PCB
	MOVW	R1,PCB$L_PID(R0)	; SET PROPER PIX FOR SYSTEM PCB
	DECL	R1			; COMPUTE MAXIMUM PIX VALUE
	MOVL	R1,SCH$GL_MAXPIX	; AND SET
	MOVL	#31,R0			; START AT HIGH BIT
10$:	BBS	R0,R1,11$		; FIND THE HIGHEST SET BIT
	SOBGTR	R0,10$			; WE KNOW WE WILL FIND ONE
11$:	ADDL3	#1,R0,SCH$GL_PIXWIDTH	; BIT "N" SET MEANS THAT PIX WIDTH FOR
					;  EXTENDED PID IS "N+1" BITS
20$:	MOVAL	SCH$GL_NULLPCB,(R2)[R1]	; INIT VECTOR TO POINT TO NULL PROCESS
	CLRW	@SCH$GL_SEQVEC[R1]	; INITIALIZE SEQUENCE COUNTER
	SOBGEQ	R1,20$			; INIT THEM ALL
	MOVL	MMG$GL_GPTE,EXE$GL_GPT	; ESTABLISH POINTER TO GLOBAL FREE LIST
	CLRL	R2			; SET NULL PRIO INCR CLASS
	MOVAL	SCH$GL_NULLPCB,R4	; GET ADDRESS OF NULL PCB
	BSBB	30$			; SETUP PROCESS PHYPCB AND STATE
	MOVAL	SCH$GL_SWPPCB,R4	; GET ADDRESS OF SWAPPER PCB
	BSBB	30$			; SETUP PROCESS PHYPCB AND STATE
	BRB	INI_PHV			; CONTINUE WITH INITIALIZATION
30$:	EXTZV	#VA$V_VPN,#VA$S_VPN,PCB$L_PHYPCB(R4),R0	; GET VPN FOR HW PCB
	MOVL	@MMG$GL_SPTBASE[R0],R0	; TRANSLATE TO ACTUAL PHYSICAL
	INSV	R0,#VA$V_VPN,#PTE$S_PFN,PCB$L_PHYPCB(R4); SET PHYSICAL ADDRESS
	MOVL	PCB$L_PID(R4),R0	; GET INTERNAL PROCESS IDENTIFIER
	MOVL	R0,R1			; AND SAVE A COPY
	JSB	EXE$IPID_TO_EPID	; CONVERT INTERNAL TO EXTENDED PROCESS ID
	MOVL	R0,PCB$L_EPID(R4)	; STORE THE EXTENDED PROCESS ID
	MOVZWL	R1,R0			; GET PROCESS INDEX FROM INTERNAL PID
	MOVL	R4,@SCH$GL_PCBVEC[R0]	; AND SET ADDRESS IN PCB VECTOR
	JMP	SCH$CHSE		; AND CHANGE STATE TO EXECUTABLE
 
;
;	INITIALIZE PROCESS HEADER VECTOR
;
INI_PHV:				;
	ADDL3	#1,SGN$GL_BALSETCT,R4	; GET COUNT OF SLOTS
	ASHL	#2,R4,R1		; SIZE OF BLOCK TO ALLOCATE
	ADDL	#DYN$C_HEADLEN,R1	; ADD IN SIZE OF HEADER
	BSBW	ALONONPAGED		; ALLOCATE BLOCK FOR PHV
	CLRQ	(R2)+			; CLEAR OUT TRASH
	MOVW	R1,(R2)+		; SET IN SIZE
	MOVW	#<DYN$C_PHVEC@8!DYN$C_INIT>,(R2)+ ; SET TYPE AND SUBTYPE
	MOVL	R2,PHV$GL_PIXBAS	; SET PROCESS INDEX VECTOR
	MOVAW	(R2)[R4],PHV$GL_REFCBAS	; AND REFERENCE COUNT BASE
	MOVW	SGN$GW_MAXPRCCT,-2(R2)[R4]; SET SYSTEM PIX
	DECL	R4			; 
	MOVW	#1024,@PHV$GL_REFCBAS[R4]	; SET SYSTEM REFERENCE COUNT 
20$:	DECL	R4			; 
	BLSS	30$			; CHECK FOR DONE
	MNEGW	#1,@PHV$GL_REFCBAS[R4]	; INIT REFC
	CLRW	(R2)[R4]		; AND PIX
	BRB	20$			; AND AGAIN
30$:					;
;
;	SETUP SWAPPER MAP
;
INI_SWAP:				;
	ASHL	#2,SGN$GL_MAXWSCNT,R1	; GET SIZE TO ALLOCATE
	ADDL	#4+DYN$C_HEADLEN,R1	; ADD SPACE FOR STOPPER LONGWORD + HEAD
	BSBW	ALONONPAGED		; ALLOCATE A BLOCK FOR SWAPPER MAP
	CLRQ	(R2)+			; CLEAR OUT TRASH
	MOVW	R1,(R2)+		; SET IN SIZE
	MOVW	#<DYN$C_SWPMAP@8!DYN$C_INIT>,(R2)+ ; SET TYPE AND SUBTYPE
	MOVL	R2,SWP$GL_MAP		; SET ADDRESS OF SWAPPER MAP
	MOVAL	SCH$GL_SWPPCB,R4	; GET ADDRESS OF SWAPPER PCB
	MOVL	PCB$L_PHD(R4),R5	; AND GET HEADER ADDRESS
	MOVL	R2,PHD$L_P0BR(R5)	; SET BASE REGISTER
	INSV	SGN$GL_MAXWSCNT,#0,#24,PHD$L_P0LRASTL(R5) ; AND LENGTH REGISTER
;
; ALLOCATE MODIFIED PAGE WRITER PAGE TABLE ENTRY ARRAY
; AND PROCESS HEADER VECTOR INDEX ARRAY.
;
INI_MPW:
	MOVZWL	MPW$GW_MPWPFC,R1	; MODIFIED PAGE WRITER PAGE FAULT CLUSTER
	BICL	#7,R1			; TRUNCATE TO MULTIPLE OF 8
	BNEQ	10$			; CANNOT ALLOW ZERO
	MOVL	#16,R1			; USE MINIMUM INSTEAD
10$:	MOVW	R1,MPW$GW_MPWPFC	; RESET PARAMETER
	movw	r1,swp$gw_swpinc	; ********** temp ********** 
	ADDL2	#7,R1			; ALLOW BIT-LEVEL PAGE FILE ALLOCATION
	ROTL	#2,R1,R4		; SIZE OF PTE ARRAY
	MOVAW	DYN$C_HEADLEN(R4)[R1],R1; 6 BYTES PER PAGE TO ALLOCATE + HEADER
	BSBW	ALONONPAGED		; ALLOCATE THE STORAGE
	CLRQ	(R2)+			; CLEAR OUT TRASH
	MOVW	R1,(R2)+		; SET IN SIZE
	MOVW	#<DYN$C_MPWMAP@8!DYN$C_INIT>,(R2)+ ; SET TYPE AND SUBTYPE
	MOVL	R2,MPW$AL_PTE		; ADR OF PAGE TABLE ENTRY ARRAY
	ADDL3	R2,R4,MPW$AW_PHVINDEX	; ADR OF PROCESS HEADER VECTOR INDEX ARRAY

	.SUBTITLE	MISCELLANEOUS INITIALIZATION
;
; DO SHORT PIECES OF MISCELLANEOUS SYSTEM INITIALIZATION
;
INI_MISC:
;
; INITIALIZE THE GLOBAL PAGE FILE LIMIT
;
	MOVL	SGN$GL_GBLPAGFIL,MMG$GL_GBLPAGFIL
;
; INITIALIZE PAGEFILE CONTROL BLOCK 0 FOR READ OF SHELL INTO SYSTEM WORKING SET
;
	MOVL	#<<SWP$GL_SHELLBAS&^X7FFFFFFF>@-9>+1+1,- ;SET STARTING VBN
		MMG$GL_NULLPFL+PFL$L_VBN	; FOR SHELL PROCESS
	MOVL	W^BOO$GL_BOOTCB,R0		; GET BOOT CONTROL BLOCK ADDR
	MOVL	BOO$L_SYS_MAP(R0),-		; STORE ADDRESS OF SYSTEM WCB
		MMG$GL_NULLPFL+PFL$L_WINDOW	; FOR SHELL READS INTO SYSTEM
	ADDW3	#1,SGN$GW_SWPFILES,SGN$GW_SWPFILCT ; SET ACTUAL NUMBER OF SWAP
						; FILE SLOTS
;
; GIVE RPB A PFN DATA BSE
;
	EXTZV	#9,#22,EXE$GL_RPB,R1		; GET VIRTUAL PAGE NUMBER
	BICL3	#^C<PTE$M_PFN>,@MMG$GL_SPTBASE[R1],R0 ; GET PFN
	MOVAL	@MMG$GL_SPTBASE[R1],@PFN$AL_PTE[R0] ; PTE BACK POINTER
	INCW	@PFN$AW_REFCNT[R0]		; REF COUNT
	MOVB	#PFN$C_ACTIVE,@PFN$AB_STATE[R0] ; STATE IS ACTIVE
	MOVB	#1,@PFN$AB_TYPE[R0]		; SYSTEM PAGE


	.SUBTITLE	PAGE AND SWAP FILE VECTOR INITIALIZATION
;--
;
;  Functional Description:
;
;	The page file control block vector is initialized. This vector
;	contains a longword pointer for each page file or swap file recognized
;	by the system. Each vector element is initialized to point to a
;	dummy PFL allocated in SYS.EXE. As a new page file or swap file is
;	added to the system, a vector slot is loaded with its PFL address.
;
;  Input Parameters:
;
;	SGN$GW_PAGFILCT		Maximum number of paging files
;	SGN$GW_SWPFILCT		Maximum number of swapping files
;
;  Implicit Input:
;
;	none
;
;  Output Parameters:
;
;	None
;
;  Implicit Output:
;
;	An array of longwords is allocated from nonpaged pool to contain
;	the page file control block vector. 
;
;  Completion Status:
;
;	If allocation of the vector of longwords fails, the bootstrap
;	operation is aborted.
;
;--
 
INI_PFLVEC:
	MOVZWL	G^SGN$GW_PAGFILCT,R0	; Zero extend page file count
	MOVZWL	G^SGN$GW_SWPFILCT,R1	;  ... and swap file count
	ADDL3	R0,R1,R2		; Form their sum
	PUSHL	R2			;  ... and save this result
	MULL3	#4,R2,R1		; Make R1 a byte count
	ADDL2	#PTR$K_LENGTH,R1	; Add header overhead
	PUSHL	R1			; Save requested size
	BSBW	ALONONPAGED		; Allocate the pointer block
	MOVL	(SP)+,PTR$W_SIZE(R2)	; Size is the requested size
	MOVB	#DYN$C_PTR,PTR$B_TYPE(R2) ; Set structure type as PTR
	MOVB	#DYN$C_PFL,PTR$B_PTRTYPE(R2) ; ... which locates PFLs
	MOVL	(SP),PTR$L_PTRCNT(R2)	; Store size of PFL array
	MOVAL	G^MMG$GL_NULLPFL,R3	; Set up contents of uninitialized slot
	MOVAL	PTR$L_PTR0(R2),R1	; Get address of first slot
	MOVL	R1,G^MMG$GL_PAGSWPVC 	; Store this for exec routines
	POPL	R0			; R0 is loop counter
10$:	MOVL	R3,(R1)+		; Initialize next slot
	SOBGTR	R0,10$			; If not done, load next slot

;
;	INITIALIZE POINTER TO TOP OF INTERRUPT STACK AND COMPUTE MAXIMUM
;	ALLOWED DEPTH FOR LOCK MANAGER RESOURCE NAMES
;
INI_INTSTKLM:
	MOVZWL	SGN$GW_ISPPGCT,R0	; GET # OF PAGES OF INTERRUPT STACK
	ASHL	#9,R0,R0		; CONVERT TO BYTES
	SUBL3	R0,EXE$GL_INTSTK,-	; SUBTRACT FROM BASE OF STACK AND STORE
		EXE$GL_INTSTKLM
	SUBL	LCK$GL_EXTRASTK,R0	; SUBTRACT EXTRA STACK AMOUNT FROM
					; SIZE OF INTERRUPT STACK
	DIVL	#16,R0			; ALLOW 16 BYTES FOR EACH LEVEL
	CMPL	R0,#4			; MAKE SURE IT'S AT LEAST 4
	BGEQ	10$			; IT IS
	MOVL	#4,R0			; SET IT TO 4
10$:	CMPL	R0,#255			; MAKE SURE IT'S NO MORE THAN 255
	BLEQ	20$			; IT IS
	MOVL	#255,R0			; SET IT TO 255
20$:	MOVB	R0,LCK$GB_MAXDEPTH	; STORE IT
;
; POINT SYSTEM PCB AT SYSTEM PHD AND SET PROPER PIX
;
INI_SYSPCB:				;
	MOVAL	MMG$AL_SYSPCB,R4	; GET ADDRESS OF SYSTEM PCB
	MOVL	MMG$GL_SYSPHD,PCB$L_PHD(R4)	; AND SET IN SYSTEM PCB
	MOVW	SGN$GW_MAXPRCCT,PCB$L_PID(R4)	; SET SYSTEM PIX
;
; SYSBOOT PRODUCED A MAP FOR SYS.EXE AND LEFT IT IN THE BOOT CONTROL
; BLOCK.  ITS RETRIEVAL POINTERS ARE IN THE NORMALIZED FORM OF 32 BITS
; OF BLOCK COUNT, 32 BITS OF LBN.  SYSBOOT LEFT ENOUGH SPACE AT THE END
; OF THE MAP TO MAKE A REAL WCB AND PUT IT RIGHT ON TOP OF THIS MAP.
;
	MOVL	W^BOO$GL_BOOTCB,R8	; ADDRESS OF BOOT CONTROL BLOCK
	MOVL	BOO$L_SYS_MAP(R8),R6	; ADDRESS OF MAP LEFT BY SYSBOOT
	ASHL	#-3,(R6),R7		; RETRIEVAL POINTER COUNT IN MAP
	MOVW	R7,W^SYSWCB+WCB$W_NMAP	; SET COUNT IN TEMPLATE WCB
	MOVAL	4(R6),R0		; ADR OF 1ST 8 BYTE RTRV PTR
	MOVL	R6,R1			; ADR TO STORE 1ST 6 BYTE RTRV PTR
	MOVL	R7,R2			; NUMBER OF RETRIEVAL POINTERS
;
; COLLAPSE THE 8 BYTE FORMAT INTO A 6 BYTE FORMAT.  SINCE SYS.EXE ITSELF
; IS NOT 65K BLOCKS BIG, NONE OF THESE RETRIEVAL POINTERS CAN HAVE A
; NON-ZERO HIGH ORDER WORD.
;
20$:	CVTLW	(R0)+,(R1)+		; MOVE THE BLOCK COUNT
	MOVL	(R0)+,(R1)+		; AND THE STARTING LBN
	SOBGTR	R2,20$			; LOOP THROUGH ALL RTRV PTRS
	MULL	#6,R7			; NUMBER OF BYTES IN NEW RTRV PTRS
	ADDW	R7,W^SYSWCB+WCB$W_SIZE	; FIX UP TEMPLATE WCB SIZE FIELD
	MOVC3	R7,(R6),WCB$C_LENGTH(R6) ; MOVE 6 BYTE RTRV PTRS DOWN
	MOVC3	#WCB$C_LENGTH,W^SYSWCB,(R6) ; AND INSERT THE TEMPLATE WCB
;
; Compute the data that calibrates the time-wait loop, used by drivers
; to wait, instead of reading the processor clock.
;

	JSB	EXE$INI_TIMWAIT		; INITIALIZE DATA FOR TIMEWAIT LOOP
;
; INSERT ALL DRIVERS LINKED AS PART OF THE SYSTEM IMAGE IN THE DRIVER 
; PROLOGUE TABLE LIST SO THAT SUBSEQUENT DEVICE CONNECTIONS WILL BE ABLE
; TO FIND THEM.
;
	INSQUE	MB$DPT,IOC$GL_DPTLIST	; INSERT MAILBOX DRIVER ON DRIVER LIST
	INSQUE	NL$DPT,IOC$GL_DPTLIST	; INSERT NULL DRIVER ON DRIVER LIST
	INSQUE	OP$DPT,IOC$GL_DPTLIST	; INSERT CONSOLE DRIVER ON DRIVER LIST
;
; move logical name for SYS$DISK and SYS$SYSDEVICE into non-paged pool
;
INI_LOG:				;
	MOVZWL	#BDL$S_CRELNM_ITMLST,R1	; get size to allocate
	BSBW	ALONONPAGED		; allocate it
	MOVL	R2,@LNM$AL_HASHTBL	; store addr temporarily (see swapinit)
	MOVAB	BDL$GL_DISK_LOG,R4	; get addr of block
	MOVL	R2,R6			; save pointer
	MOVC3	#BDL$S_CRELNM_ITMLST,(R4),(R2)
					; copy block to pool
	;
	; make self relative pointer absolute
	;
	ADDL	R6,BDL_L_DISK_EQ_PTR(R6)
	ADDL	R6,BDL_L_DISK_AT_PTR(R6)
	ADDL	R6,BDL_L_SYSD_EQ_PTR(R6)
	ADDL	R6,BDL_L_SYSD_AT_PTR(R6)
;
; THE TERMINAL SERVICE IS NOW ALLOCATED NON-PAGED POOL AND READ INTO IT
; BY SYSBOOT.  THE ADDRESS IN POOL IS PASSED IN BOO$GL_TRMDRV.
; INITIALIZE THE TERMINAL DRIVER.
;
INI_TTYDRV:				;
	.ENABLE	LSB
;
; INITIALIZE PARTS OF OPA0 UCB THAT CAN ONLY BE DONE AFTER SYSBOOT HAS
; POSSIBLY CHANGED SYSGEN PARAMS
;
	MOVAB	G^OP$DPT,R4		; R4 POINTS TO CONSOLE DPT
	MOVAB	G^OPA$UCB0,R5		; R5 POINTS TO CONSOLE UCB
	JSB	G^IOC$INITDRV		; INITIALIZE FIELDS THAT CAN'T BE DONE
					;  STATICALLY.
	BBCC	#TT$V_SCOPE,W^UCB$L_TT_DECHAR(R5),10$ ; ENSURE NOT SCOPE
10$:	BICL2	#TT2$M_AUTOBAUD,W^UCB$L_TT_DECHA1(R5) ; ENSURE NOT AUTOBAUD
	MOVL	W^BOO$GL_TRMDRV,R2	; ADDRESS OF TERMINAL SERVICE CODE
	MOVL	R2,G^TTY$GL_DPT		; STORE LOADED TERMINAL SERVICE DPT
	INSQUE	(R2),G^IOC$GL_DPTLIST 	; INSERT TERMINAL DRIVER ON LIST
	CMPB	#DYN$C_DPT,DPT$B_TYPE(R2) ; REALLY A DPT?
	BNEQ	50$			; NOPE, GO SAY SO
	CMPW	UCB$W_SIZE(R5),-	; CORRECT UCB SIZE IN CONSOLE UCB?
		DPT$W_UCBSIZE(R2)
	BGEQU	70$			; IF GEQU YES
	MOVAB	BADCONUCB,R1		; SET ILLEGAL OPA0: ERROR
	BRB	OUTZ			; AND GO DIE

50$:	MOVAB	BADTTYDRV,R1		; SET ILLEGAL FORMAT ERROR
OUTZ:	CLRL	R11			; ADDRESS CONSOLE
	JSB	EXE$OUTZSTRING		; OUTPUT IT
	HALT				;
;
; RELOCATE TTDRIVER CLASS VECTOR, SET ADDRESS OF OPA0 DDT
;
70$:	MOVZWL	DPT$W_VECTOR(R2),R1	; OFFSET TO CLASS VECTOR DISPATCH TABLE
	ADDL2	R2,R1			; CALCULATE ADDRESS
	MOVL	R1,R3			; SAVE
	
80$:	ADDL2	R2,(R1)+		; ADD IN DPT OFFSET
	TSTL	(R1)			; END OF LIST ?
	BNEQ	80$			; BRANCH IF NO
	
	MOVL	CLASS_DDT(R3),-
		OPA$GL_DDB+DDB$L_DDT	; STORE DDT IN CONSOLE DDB
	MOVL	CLASS_DDT(R3),-
		UCB$L_DDT(R5)		; STORE DDT IN CONSOLE UCB
	MOVL	R3,-
		UCB$L_TT_CLASS(R5)	; STORE CLASS VECTOR ADDRESS
	MOVL	CLASS_GETNXT(R3),-
		UCB$L_TT_GETNXT(R5)	; STORE GET NEXT IN CONSOLE UCB
	MOVL	CLASS_PUTNXT(R3),-
		UCB$L_TT_PUTNXT(R5)	; STORE PUT NEXT IN CONSOLE UCB
	MOVZWL	DPT$W_VECTOR(R4),R1	; OFFSET TO CONSOLE PORT VECTOR DISPATCH TABLE
	ADDL3	R1,R4,-
		UCB$L_TT_PORT(R5)	; SET ADDRESS IN CONSOLE UCB
	.DISABLE LSB

	.SBTTL	INIT THE BOOT DEVICE
;
; THE BOOTSTRAP DEVICE DRIVER'S ADDRESS IN POOL IS PASSED IN BOO$GL_DSKDRV.
; FINISH ALLOCATING AND INITIALIZING THE DATA BASE TO DESCRIBE THE BOOT DEVICE,
; AND ANY CLASS/PORT DRIVERS ASSOCIATED WITH IT.
;
INI_BOOTDEVIC:				;
;
; FIGURE OUT THE DEVICE NAME FROM THE ADAPTER.
;
	MOVL	G^EXE$GL_RPB,R6		; ADDRESS OF RPB
	MNEGL	#1,-(SP)		; INIT ADAPTER COUNTS
	PUSHL	(SP)			; ALLOW FOR 8 ADAPTERS
	MOVQ	(SP),-(SP)		; ALLOW FOR 16 ADAPTERS
	MOVAL	IOC$GL_ADPLIST-ADP$L_LINK,R4	; START OF ADAPTER LIST
10$:	MOVL	ADP$L_LINK(R4),R4	; MOVE TO NEXT ADAPTER
	BEQL	20$			; BRANCH IF NONE
	MOVZWL	ADP$W_ADPTYPE(R4),R1	; GET ADAPTER TYPE CODE
	INCB	(SP)[R1]		; BUMP APPROPRIATE COUNT
	MOVB	(SP)[R1],ADP$B_NUMBER(R4); SET ADAPTER NUMBER 
	CMPW	ADP$W_TR(R4),RPB$L_BOOTR1(R6)	; IS THIS THE BOOT ADAPTER?
	BNEQ	10$			; NO, KEEP LOOKING
	MOVZBL	(SP)[R1],R5		; YES, SAVE THE COUNT
	MOVL	R4,R7			; AND ADP ADDRESS
	BRB	10$			; AND CONTINUE THROUGH ALL ADPS
20$:	ADDL	#16,SP			; CLEAN STACK
;
; IF A BOOT DEVICE CONTROLLER LETTER WAS PASSED TO US IN AN INPUT REGISTER
; TO VMB, USE THAT AS THE CONTROLLER LETTER.
;
	TSTB	RPB$B_CTRLLTR(R6)	; WAS A CONTROLLER LETTER SPECIFIED?
	BEQL	22$			; BRANCH IF NOT
	MOVZBL	RPB$B_CTRLLTR(R6),R5	; GET THE CONTROLLER LETTER
	DECL	R5			; BECAUSE A=1 (0 = UNSPECIFIED)
22$:	MOVZWL	RPB$W_UNIT(R6),R8	; PICK UP UNIT NUMBER FROM BOOT
;
; FIRST CHECK FOR ANY PORT DRIVER.  IF THERE IS ONE, THEN THE DDB AND UCB
; FOR IT MUST BE ALLOCATED, SINCE THEY ARE NOT BUILT IN.
;
	MOVL	W^BOO$GL_PRTDRV,R4	; ADR IN POOL OF BOOT PORT DRIVER
	MOVL	R4,R9			; SAVE AWAY
	BNEQ	25$			; THERE IS
	BRW	50$			; THERE IS NO PORT DRIVER

25$:	INSQUE	DPT$L_FLINK(R4),-
		G^IOC$GL_DPTLIST 	; INSERT DRIVER IN LIST
	MOVZBL	#DDB$K_LENGTH,R1	; GET SIZE OF DDB
	BSBW	ALONONPAGED		; GRAB SOME POOL
	MOVL	R2,R3			; TRANSFER
	MOVW	R1,DDB$W_SIZE(R3)	; SET THE SIZE
	MOVZBW	#DYN$C_DDB,DDB$B_TYPE(R3) ; AND TYPE
	MOVAL	G^IOC$GL_DEVLIST,R1	; PICK UP SYSTEM DDB LIST POINTER
30$:	MOVL	DDB$L_LINK(R1),R2	; CHASE DOWN THE LIST
	BEQL	40$			; UNITL THE END
	MOVL	R2,R1			; TRANSFER POINTERS
	BRB	30$			; AND CONTINUE

40$:	MOVL	R3,DDB$L_LINK(R1)	; LINK US IN
;	CLRL	DDB$L_LINK(R3)		; AND SET AS END
	BSBW	FIX_DRV_NAME		; FIX UP THE NAMES
	MOVAL	@#SCS$GA_LOCALSB,-	; SET IN THE SYSTEM BLOCK BACK LINK
		DDB$L_SB(R3)
	PUSHL	R3			; SAVE POINTER TO DDB
	MOVZWL	DPT$W_UCBSIZE(R4),R1	; PICK UP SIZE OF UCB
	ADDL2	#ORB$C_LENGTH,R1	; ALLOCATE ORB ADJACENT TO THE UCB
	BSBW	ALONONPAGED		; GET IT
	POPL	R3			; RESTORE DDB
	PUSHR	#^M<R1,R2,R3,R4,R5>	; SAVE MOVC REGISTERS
	MOVC5	#0,(SP),#0,R1,(R2)	; CLEAR OUT BLOCK JUST ALLOCATED
	POPR	#^M<R1,R2,R3,R4,R5>	; RESTORE MOVC REGISTERS
	MOVZWL	DPT$W_UCBSIZE(R4),R1	; RESTORE ORIGINAL UCB SIZE
	MOVL	R2,DDB$L_UCB(R3)	; SET POINTER
	MOVL	R3,UCB$L_DDB(R2)	; AND ANOTHER
	ADDL3	R1,R2,UCB$L_ORB(R2)	; SET ORB ADDRESS
	MOVL	R2,R10			; COPY ADDRESS
	CLRQ	(R2)+			; STEP TO SIZE
	MOVW	R1,(R2)+		; SET SIZE
	MOVZBW	#DYN$C_UCB,(R2)+	; SET TYPE
	MOVL	R2,(R2)+		; SET ASTQFL
	MOVL	UCB$L_ASTQFL(R10),(R2)	; SET ASTQBL
	MOVAL	UCB$L_IOQFL(R10),-
		UCB$L_IOQFL(R10)	; SET IOQFL
	MOVAL	UCB$L_IOQFL(R10),-
		UCB$L_IOQBL(R10)	; AND IOQBL
	MOVL	UCB$L_ORB(R10),R0	; GET THE ORB ADDRESS
	MOVB	#DYN$C_ORB,ORB$B_TYPE(R0)	; SET BLOCK TYPE
	MOVW	#ORB$C_LENGTH,ORB$W_SIZE(R0)	; SET BLOCK SIZE
	MOVB	#ORB$M_PROT_16,ORB$B_FLAGS(R0)	; SOGW PROTECTION WORD

	ASSUME	ORB$L_ACL_DESC EQ ORB$L_ACL_COUNT+4

	CLRQ	ORB$L_ACL_COUNT(R0)	; NO ACL AS YET
;
; NOTE: The following code depends on several assumptions:
;	1) We will get here only if there are both a port and class driver
;	2) All UNIBUS port drivers have the same bootdriver (BTD$K_UDA)
;	3) "REAL" physical unit numbers on HSC's are less than 12 bits.
;
;	The boot device name is built up of three parts:
;	1) The device mnemonic (e.g. DU,DM) is extracted from the driver
;	name for most devices, otherwise it is copied up from the boot
;	driver thru SYSBOOT.
;	2) The controller letter is the same as the port controller for
;	all UNIBUS ports.  For the HSC, it is always "A".  For the
;	emulated disks, it is derived from the unit number.
;	3) The unit number is extracted from the RPB.
;
	MOVW	R8,@#SYS$GL_BOOTUCB+ -	; STUFF THE MSCP UNIT NUMBER
		 UCB$W_MSCPUNIT		;  WHERE IT BELONGS
	CMPB	#BTD$K_UDA,-
		RPB$B_DEVTYP(R6)	; IF BOOTING FROM CI/HSC/EMULA
	BEQL	48$			;  (NO)
	EXTZV	#MSCP$V_EU_DESIG,-	; EXTRACT CONTROLLER DESIGNATOR
		#MSCP$S_EU_DESIG,R8,R5	;  FROM UNIT NUMBER
	BEQL	48$			; NONE, SO LEAVE AT "DxA"
	DECL	R5			; BECAUSE 1=A
	EXTZV	#MSCP$V_EU_SUBU,-	; PICK UP 3-BIT UNIT NUMBER
		#MSCP$S_EU_SUBU,R8,R1
	CMPZV	#MSCP$V_EU_CTYPE,-	; IF CONTROLLER TYPE IS NOT OLD
		#MSCP$S_EU_CTYPE,R8,-
		#MSCP$K_EMD_OLD
	BEQL	45$			;  THEN
	EXTZV	#MSCP$V_EU_NO,-		; PICK UP 8-BIT UNIT NUMBER
		#MSCP$S_EU_NO,R8,R1
45$:	MOVL	R1,R8			; SET UNIT NUMBER
48$:	TSTW	@#SYS$GL_BOOTUCB+ -	; CHECK FOR SHADOWING
		 UCB$W_MSCPUNIT
	BGEQ	50$			; NOT SHADOWING
	MOVL	#^X12,R5		; SHADOWING: MAKE CONTROLLER "DxS"
;
; NOW FIX UP BOOT DISK DEVICE
;
50$:	MOVL	W^BOO$GL_DSKDRV,R4	; ADR IN POOL OF BOOT DISK DRIVER
	INSQUE	DPT$L_FLINK(R4),-
		G^IOC$GL_DPTLIST	; INSERT DRIVER IN LIST
	MOVAL	G^SYS$GL_BOOTDDB,R3	; GET DDB ADDRESS FOR BOOT DEVICE
	BSBW	FIX_DRV_NAME		; FIX UP THE NAMES
	MOVW	W^BOO$GL_DEVNAME,R1	; PICK UP POSSIBLE BOOT DEVICE NAME
	BEQL	55$			; THERE IS NONE
	MOVW	R1,DDB$T_NAME+1(R3)	; STUFF IT IN DDB
55$:	MOVL	CLU$GL_ALLOCLS,-	; STORE DEVICE ALLOCATION CLASS
		DDB$L_ALLOCLS(R3)	; IN DDB
	MOVL	DDB$L_UCB(R3),R5	; PICK UP UCB ADDRESS
	CMPW	DPT$W_UCBSIZE(R4),-	; CHECK THAT PREBUILT IS LARGE
		UCB$W_SIZE(R5)		;  ENOUGH
	BLSS	60$			; YES
	MOVAB	BADDSKUCB,R1		; NO, SET ERROR MESSAGE
	BRW	OUTZ

60$:	MOVW	R8,UCB$W_UNIT(R5)	; SET PROPER UNIT NUMBER
	MOVL	R5,G^EXE$GL_SYSUCB	; SET ADDRESS OF SYSTEM DEVICE UCB
	PUSHR	#^M<R1,R3>		; SAVE REGISTERS
	MOVL	W^BOO$GL_BOOTCB,R1	; GET BOOT CONTROL BLOCK ADDRESS
	MOVL	BOO$L_SYS_MAP(R1),R0	; GET WCB ADDRESS FOR SYS.EXE
	MOVL	R5,WCB$L_ORGUCB(R0)	; SET UCB IN WINDOW CONTROL BLOCK
	MOVL	BOO$L_CHECKSUM(R1),EXE$GQ_BOOTCB_D ; BYTE COUNT TO CHECKSUM
					; LEFT HERE BY SYSBOOT
	JSB	EXE$BOOTCB_CHK		; CALCULATE BOOTCB CHECKSUM IN R3
	MOVL	R3,BOO$L_CHECKSUM(R1)	; AND STORE IT
	POPR	#^M<R1,R3>		; RESTORE REGISTERS
	BBC	#DPT$V_SVP,DPT$B_FLAGS(R4),70$	; IF DRIVER REQUESTS ...
	BSBW	ALOSPT			; ALLOCATE SPT SLOT FOR UCB WINDOW
	MOVL	R0,UCB$L_SVPN(R5)	; SAVE SYSTEM VPN IN UCB
;
; NOW THE BOOT DISK DRIVER (AND ANY ASSOCIATED PORT DRIVER) HAVE BEEN HOOKED
; INTO THE DATA BASE. DDB'S AND UCB'S ARE PRESENT.
;
;	R3 -->	DISK [CLASS] DRIVER DDB
;	R4 -->	DISK [CLASS] DRIVER DPT
;	R5 -->	DISK [CLASS] DRIVER UCB
;	R6 -->	RPB
;	R7 -->	ADP FOR EITHER A REAL DISK OR A PORT
;	R9 -->	PORT DRIVER DPT (IF PRESENT)
;	R10-->	PORT DIRVER UCB (IF PRESENT)
;
; SPECIAL CODE FOR THE CONSOLE DEVICE
;
70$:	JSB	@#INI$CONSOLE		; Off to SYSLOA code for routine
;
; Check to see if we have been booted from a remote system (BOO$GQ_NODENAME
; will be non-blank).  If so set up a system block for it, so that the
; correct names can be generated.
;
	PUSHR	#^M<R4,R5,R7,R8>	; Save  registers
	MOVAL	@#BOO$GB_NODENAME,R6	; Address of remote node name
	LOCC	#^A/ /,#8,(R6)		; Find the end of the name
	SUBL3	R0,#8,R8		; Calculate name size
	BEQL	80$			; None, leave
	MOVZWL	#SB$C_LENGTH,R1		; Get size of system block
	BSBW	ALONONPAGED		; Allocate it
	MOVL	R2,R7			; Copy to nonvolitle
	MOVW	R1,SB$W_SIZE(R7)	; Set in size field
	MOVW	#DYN$C_SCS!<DYN$C_SCS_SB@8>,-
		 SB$B_TYPE(R7)		; And type
	MOVAB	SB$L_PBFL(R7),-		; Init the path block listhead
		 SB$L_PBFL(R7)
	MOVAB	SB$L_PBFL(R7),-
		 SB$L_PBBL(R7)
	MOVQ	W^BOO$GB_SYSTEMID,-
		 SB$B_SYSTEMID(R7)	; Set in systemid
	CLRW	SB$B_SYSTEMID+6(R7)	; Just in case
	MOVAB	@#SCS$GQ_CONFIG,R3	; Address of list head
	INSQUE	(R7),@4(R3)		; Insert at tail
	MOVB	R8,SB$T_NODENAME(R7)	; Insert size
	MOVC5	R8,(R6),#0,#15,-	; Insert the name
		 SB$T_NODENAME+1(R7)
	MOVAB	@#SCS$GA_LOCALSB+ -
		 SB$L_DDB-DDB$L_LINK,R3	; Cover the DDB list head
	MOVL	DDB$L_LINK(R3),R0	; R0 --> Boot DDB
	MOVL	R0,SB$L_DDB(R7)		; Insert it in the remote system block
	MOVL	DDB$L_LINK(R0),-
		 DDB$L_LINK(R3)		; R1 --> Next DDB after boot DDB
	CLRL	DDB$L_LINK(R0)		; Show Boot DDB end of its list
	MOVL	R7,DDB$L_SB(R0)		; Set back pointer to system block
;
; Now fill in correct equivalence string for SYS$DISK
;
80$:	MOVL	@LNM$AL_HASHTBL,R6	; Stuff address of data block
	ADDL3	R6,#BDL_L_DISK_EQV-1,R1	; Point to equivalence name (at "_")
	ADDL3	#1,R1,R7		; Copy at real name
	MOVL	#15,R0			; Output length
	MOVL	4(SP),R5		; Recover R5
	BISL	#DEV$M_NNM, -		; Signal that system device uses the
		UCB$L_DEVCHAR2(R5)	; node$ddcn device name format.
	MNEGL	#1, R4			; Get NODE$ device name
	JSB	@#IOC$CVT_DEVNAM	; Construct the name
	SUBW3	#1,R1,BDL_W_DISK_EQ_SZ(R6) ; Update size
;
; Fill in correct equivalence string for SYS$SYSDEVICE
;
	MOVAB	BDL_L_SYSD_EQV(R6),R3	; Point to equiv name string (past "_")
	MOVW	BDL_W_DISK_EQ_SZ(R6),-  ; Move size ( same as for SYS$DISK )
		BDL_W_SYSD_EQ_SZ(R6)
	BBC	S^#EXE$V_CONCEALED,- 	; Branch if not concealing dev name
		G^EXE$GL_FLAGS,90$
	BISL2	#LNM$M_CONCEALED,-
		@BDL_L_SYSD_AT_PTR(R6)	; Mark concealed attribute
90$:	MOVC3	R1,(R7),(R3)		; Copy device spec
	POPR	#^M<R4,R5,R7,R8>	; Restore registers
;
; CONNECT UP CRB/IDB
;
	.ENABLE LSB
	TSTL	R9			; PORT DRIVER?
	BEQL	10$			; NO
	MOVQ	R4,-(SP)		; YES, SAVE DSK DPT/UCB ADDRESS
	MOVQ	R9,R4			; TRANSFER PORT DPT/UCB ADDRESS
10$:	MOVL	R8,UCB$L_CRB(R5)	; CONNECT UCB TO CRB
	INCW	CRB$W_REFC(R8)		; STEP COUNT OF CONNECTED UCB'S
	MOVL	CRB$L_INTD+VEC$L_IDB(R8),R2  ; GET ADDRESS OF IDB
	BEQL	20$			; NONE
	MOVW	#8,IDB$W_UNITS(R2)	; This IDB good for upto 8 units.
	MOVZWL	UCB$W_UNIT(R5),R0	; Get devie unit number.
	CMPL	#8,R0			; Will this unit fit in the IDB?
	BLEQU	20$			; Branch if unit will not fit.
					; Its a class driver disk and the
					; class driver doesn't use the IDB.
	MOVL	R5,IDB$L_UCBLST(R2)[R0]	; Else, plant UCB address in IDB.
;
; CONNECT DRIVER TO DEVICE DATA BASE AND PERFORM ANY NECESSARY RELOCATION.
;
20$:	JSB	G^IOC$INITDRV		; CONNECT DRIVER TO DATA BASE
	MOVL	UCB$L_DDB(R5),R6	; GET DDB
	MOVL	DDB$L_DDT(R6),UCB$L_DDT(R5) ; SET DDT IN UCB
	BISW	#UCB$M_VALID,UCB$W_STS(R5) ; MUST FORCE ON SOFTWARE VOLUME VALID
;
; DITTO FOR CLASS DRIVER
;
	TSTL	R9			; ANY CLASS DRIVER?
	BEQL	40$			; NO, LEAVE
	MOVQ	(SP)+,R4		; YES, TRANSFER TO CORRECT REGISTER
	BSBW	ALLOC_CRB		; GET A CRB
	MOVL	R2,UCB$L_CRB(R5)	; CONNECT UCB TO CRB
	INCW	CRB$W_REFC(R2)		; STEP COUNT OF CONNECTED UCB'S
	MOVL	R7, -			; FOR CLASS DRIVER, SAVE ADP POINTER IN
		CRB$L_INTD+VEC$L_ADP(R2);  VEC SO THAT UNIBUS MAPPING ROUTINES
					;  CAN WORK.
	PUSHL	R2			; Save CRB address.
	MOVZWL	#IDB$K_LENGTH, R1	; Set size to allocate.
	BSBW	ALONONPAGED		; Allocate space for an IDB.
	MOVW	R1, IDB$W_SIZE(R2)	; Set size of IDB.
	MOVB	#DYN$C_IDB, -		; Set type of IDB.
		IDB$B_TYPE(R2)
	MOVW	#1, IDB$W_UNITS(R2)	; Set max units to one.
	MOVAB	W^BOO$GB_SYSTEMID, -	; Setup systemid address as CSR 
		IDB$L_CSR(R2)		; for the class driver.
	POPL	R0			; Restore CRB address.
	MOVL	R2, -			; Store IDB address in CRB.
		CRB$L_INTD+VEC$L_IDB(R0)
	CLRL	R9			; CLEAR A FLAG
	BRB	20$			; CONNECT THIS DRIVER
;
; ALLOC_CRB - ALLOCATE AND PARTIALLY FILL A CRB BLOCK
;
INI$ALLOC_CRB::
ALLOC_CRB:
	MOVZWL	#CRB$C_LENGTH,R1	; SET SIZE TO ALLOCATE
	BSBW	ALONONPAGED		; ATTEMPT TO ALLOCATE IT
	MOVW	R1,CRB$W_SIZE(R2)	; SET STRUCTURE SIZE
	MOVB	#DYN$C_CRB,CRB$B_TYPE(R2); AND TYPE CODE
	MOVAL	CRB$L_WQFL(R2),-
		CRB$L_WQFL(R2)		; BUILD WAIT QUEUE HEADER
	MOVAL	CRB$L_WQFL(R2),-
		CRB$L_WQBL(R2)		; FLINK AND BLINK
	RSB
;
; FIX_DRV_NAME - FIX UP THE DRIVER/DEVICE NAMES IN DDB/DDT
;
FIX_DRV_NAME:
	MOVZBL	DPT$T_NAME(R4),R0	; GET SIZE OF DRIVER NAME
	INCL	R0			; BUMP TO INCLUDE COUNT
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	; SAVE MOVC REGISTERS
	MOVC3	R0,DPT$T_NAME(R4),-
		 DDB$T_DRVNAME(R3)	; SET DRIVER NAME IN DDB
	POPR	#^M<R0,R1,R2,R3,R4,R5>	; RESTORE MOVC REGISTERS
	MOVAB	DDB$T_NAME(R3),R2	; GET ADDRESS OF DEVICE NAME
	MOVB	#3,(R2)+		; SET COUNT FOR DDB NAME
	MOVW	DDB$T_DRVNAME+1(R3),(R2)+ ; ASSUME SAME AS START OF DRIVER
	ADDB3	#^A/A/,R5,(R2)		; SET CONTROLLER BASED ON ADAPTER COUNT
	RSB
;
; RESTORE PROPER IPL FOR POOL ALLOCATION
;
40$:	MOVL	R11,G^EXE$GL_NONPAGED	; END OF INIT POOL ALLOCATION
	.DISABLE LSB
;
; INIT DEVICE CONTROLLERS FOR DEVICES WITH RESIDENT DATABASES:
;
INI_DEVICE:				;
	MNEGL	#1,AP			; Set flag for INIT ALL
	JSB	G^EXE$INIT_DEVICE

	.SBTTL	MISCELLANEOUS CLEAN UP
;
FINISH_UP:
	JSB	G^INI$RDONLY		; MAKE THE SYSTEM CODE READ ONLY
	JSB	G^EXE$INIPROCREG	; INIT PROCESSOR REGISTERS
	JSB	G^MMG$ALLOCPFN		; GET A MEMORY PAGE
	MOVL	R0,G^EXE$GL_BLAKHOLE	; SAVE PFN - THIS IS THE RABBIT HOLE PAGE
	DECL	G^PFN$GL_PHYPGCNT	; DECREASE NUMBER OF PAGES AVAILABLE

; Allocate a PFN and a SPT entry for mount verification.  Build a PTE to map 
; the allocated PFN into system space.  Save the system virtual address of
; the PTE in the global longword EXE$GL_SVAPTE.

	JSB	G^MMG$ALLOCPFN		; Get a memory page.
	DECL	G^PFN$GL_PHYPGCNT	; Decrease number of pages available.
	PUSHL	R0			; Save allocated PFN value.
	BSBW	ALOSPT			; Get an SPTE.
	MOVAL	@MMG$GL_SPTBASE[R0], R0	; Calculate the SVA of the SPTE.
	MOVL	R0, G^EXE$GL_SVAPTE	; Save the SVA of the SPTE.
	INSV	(SP)+, #0, -		; Set PFN in allocated SPTE.
		#PTE$S_PFN, (R0)
;
; ALLOCATE THE SYSTEM ERASE PATTERN BUFFER (EPB) AND THE PSUEDO
; PAGE TABLE (PPT) TO MAP IT.  THE EPB MUST BE PAGE ALIGNED.  BOTH
; PAGES ARE USED BY THE ERASE QIO FDT ROUTINE TO SPEED UP THE (FREQUENT)
; PROCESSING OF AN ERASE PATTERN OF 0 WRITTEN ON UP TO 127 BLOCKS.
;
	BSBB	1000$			; GET A PAGE OF MEMORY FOR SYSTEM EPB
	MOVL	R0,G^EXE$GL_ERASEPB	; SAVE ADDRESS OF SYSTEM EPB
	PUSHL	R1			; SAVE SVAPTE
	CLRL	R1			; SET PATTERN
	BSBB	2000$			; PROPAGATE PATTERN TROUGH PAGE
	BSBB	1000$			; GET A PAGE OF MEMORY FOR SYSTEM PPT
	MOVL	R0,G^EXE$GL_ERASEPPT	; SAVE ADDRESS OF SYSTEM PPT
	MOVL	@(SP)+,R1		; GET PTE THAT MAPS SYSTEM EPB
	INSV	#PRT$C_UR, #PTE$V_PROT, -
		#PTE$S_PROT, R1		; SET PPT PAGE PROTECTION TO UR
	BSBB	2000$			; PROPAGATE PTE THROUGH PPT
	BRB	50$			; REJOIN NORMAL CODE PATH

;
; LOCAL SUBROUTINE TO GET A PAGE (ALIGNED) OF MEMORY AND AN SPT
; AND TO MAP IT.  NO INPUT.  ON OUTPUT:
;	R0 = SYSTEM VIRTUAL ADDRESS (SVA) OF THE PAGE
;	R1 = SYSTEM VIRTUAL ADDRESS OF THE PTE (SVAPTE) THAT MAPS THE PAGE
;
1000$:	JSB	G^MMG$ALLOCPFN		; GET AND MAP A PAGE OF MEMORY
	PUSHL	R0			; SAVE THE PFN
	DECL	G^PFN$GL_PHYPGCNT	; DECREMENT # OF FLUID PAGES
	BSBW	ALOSPT			; GET AN SPT TO MAP THE PFN TO A VA
	MOVAL	@MMG$GL_SPTBASE[R0],R1	; CALCULATE THE SVA OF THE SPTE
	INSV	(SP)+,#0,#PTE$S_PFN,(R1); STORE THE PFN IN THE PTE
	ASHL	#VA$V_VPN,R0,R0		; CREATE THE SVA OF THE PAGE
	BBSS	#VA$V_SYSTEM,R0,1010$	; SET HIGH BIT TO INDICATE S0 ADDRESS
1010$:	RSB

;
; LOCAL SUBROUTINE TO PROPAGATE A LONGWORD THROUGH A PAGE.
; 	R0 = ADDRESS OF PAGE
;	R1 = LONGWORD PATTERN
;
2000$:	PUSHL	R2			; SAVE R2
	MOVL	#128,R2			; SET LOOP COUNTER
2010$:	MOVL	R1,(R0)+		; PUT PATTERN IN NEXT LONGWORD
	SOBGTR	R2,2010$		; BRANCH IF MORE
	MOVL	(SP)+,R2		; RESTORE R2
	RSB

50$:	MOVZWL	SGN$GW_SYSDWSCT,R0	; SYSTEM WORKING SET COUNT
	SUBL3	R0,SCH$GL_FREECNT,R0	; SET AVAILABLE PAGE COUNT
	ADDL3	#<<MMG$A_SYS_END-MMG$AL_PGDCODEN>@-9>,R0,-
		PFN$GL_PHYPGCNT		; ADD INIT PAGES ALSO
	MOVL	G^SGN$GL_FREELIM,-
		G^SCH$GL_FREELIM	; SET WORKING VALUE OF FREE LIMIT
	SUBL3	G^SCH$GL_FREELIM,-
		G^PFN$GL_PHYPGCNT,R0	; COMPUTE MAX WS SIZE
	MOVZWL	MPW$GW_LOLIM,R1		; SUBTRACT OUT FROM TOTAL
	SUBL	R1,R0
	SUBL	SCH$GL_FREELIM,R0	; MINUS 2*FREELIM
	CMPL	R0,SGN$GL_MAXWSCNT	; CHECK MAX WS COUNT FOR PHYS MEM
	BGEQU	60$			; BR IF OK
	MOVL	R0,SGN$GL_MAXWSCNT	; OTHERWISE LIMIT WS SIZE TO AVAILABLE MEM
60$:					;
	MOVZBL	SWP$GB_SHLP1PT,-(SP)	; GET MANDATORY PAGE TABLES FOR SHELL
	MOVZWL	SGN$GW_MINWSCNT,R1	; GET MINIMUM FLUID WORKING SET
	ADDL	SGN$GL_PHDPAGCT,R1	; ADD FIXED PROCESS HEADER
	ADDL	(SP)+,R1		; ADD NECESSARY PAGE TABLES
	ADDL	S^#SWP$C_KSTACK+1,R1	; ADD SPACE FOR KERNEL STACK AND POINTERS
	CMPL	R0,R1			; MIN WORKING SET MUST BE LESS THAN
	BGEQ	70$			; AVAILABLE PHYSICAL MEMORY
	MOVAB	W^NOPHYSMEM,R1		; SET ADDRESS OF MESSAGE
	CLRL	R11			; USE CONSOLE TERMINAL
	JSB	EXE$OUTZSTRING		; GIVE ERROR
	HALT				; ***** FATAL ERROR *****
70$:					;
	CLRL	R2			; SIGNAL NO RETURN DATA EXPECTED
	MOVL	#CON$C_CLRWARM,R0	; SIGNAL CLEAR WARMSTART INHIBIT FLAG
	JSB	G^CON$SENDCONSCMD	; CLEAR FLAG IN CONSOLE
	CLRL	R2			; SIGNAL NO RETURN DATA EXPECTED
	MOVL	#CON$C_CLRCOLD,R0	; SIGNAL CLEAR COLD START INHIBIT FLAG
	JSB	G^CON$SENDCONSCMD	; CLEAR FLAG IN CONSOLE
;
;	MOVE A PIECE OF INIT INTO THE UNUSED POOL AND JUMP TO IT.
;	THIS SEGMENT OF CODE WILL RELEASE THE INIT PAGES TO THE FREELIST.
;
	MOVL	EXE$GL_NONPAGED+4,R6	; GET ADDRESS OF FREE BLOCK
	ADDL	#8,R6			; SKIP HEADER
	MOVC3	#INI_EXITSIZ,W^INI_EXITCODE,(R6)	; COPY CODE TO POOL
	MOVPSL	-(SP)			; BUILD PC PCL PAIR
	PUSHL	R6			; SET NEW PC
	REI				; TRANSFER TO CODE IN POOL
;
INI_EXITCODE:				; START OF EXIT CODE TO DESTROY INIT
	MOVAL	FREE,R5			; SET ADDRESS OF FREE MEMORY DESCRIPTOR
	PUSHAB	@#SCH$SCHED		; SET EXIT TO SCHEDULER
					; FALL THROUGH TO FILLSPT TO FREE
					;  INIT PAGES;  FILLSPT RSB
					;  EXITS TO SCH$SCHED

;
; FILL THE SPT AND RELEASE PREVIOUSLY MAPPED PAGES IF ANY
;
; INPUT:
;
;	R5 = DESCRIPTOR OF RANGE OF PAGES AND NEW PTE
;		0(R5) = 1ST VIRTUAL PAGE NUMBER
;		4(R5) = LAST + 1 VIRTUAL PAGE NUMBER
;		8(R5) = NEW PAGE TABLE ENTRY TO STORE
;
; OUTPUT:
;
;	R4 ALTERED
;
 
FILLSPT:
	MOVL	(R5),R4
	PUSHL	@#MMG$GL_SPTBASE	; GET BASE ADDRESS OF SPT
20$:	BICL3	#^C<PTE$M_PFN>,@(SP)[R4],R0 ; PFN FROM SPT ENTRY IF ANY
	BEQL	40$			; BRANCH IF NONE THERE
	JSB	@#MMG$DALLOCPFN		; OTHERWISE DEALLOCATE IT
40$:	MOVL	8(R5),@(SP)[R4] 	; SET NEW SPT ENTRY
	AOBLSS	4(R5),R4,20$		; REPEAT FOR EACH PAGE IN THE RANGE
	INVALID				; INVALIDATE THE TRANSLATION BUFFER
	TSTL	(SP)+			; CLEAN STACK
	RSB				; AND RETURN
 
FREE:	.LONG	<INI_BASE-^X80000000>@-9	; START OF INIT
	.LONG	<MMG$A_SYS_END-^X80000000>@-9	; END OF INIT
	.LONG	0				; NO ACCESS PTE
INI_EXITSIZ=.-INI_EXITCODE		; SIZE OF EXIT CODE
;
; SET THE PFN IN R0 RESIDENT
;
; INPUT:
;
;	R0 = PFN
;
; OUTPUT:
;
;	NONE
;
 
SETRESIDENT:
	INCW	@PFN$AW_REFCNT[R0]	; COUNT ONE REFERENCE
	MOVAL	@MMG$GL_SPTBASE[R0],@PFN$AL_PTE[R0] ; BACK PTE POINTER
	MOVB	#PFN$C_ACTIVE,@PFN$AB_STATE[R0] ; PAGE IS ACTIVE
	MOVB	#PFN$C_SYSTEM,@PFN$AB_TYPE[R0] ; SYSTEM PAGE
	RSB

	.SBTTL	NONPAGED POOL ALLOCATION SUBROUTINES
;+
; ALONONPAGED CALLS EXE$ALONONPAGED TO ALLOCATE NON-PAGED POOL.  IF POOL
; SPACE IS NOT SUFFICIENT TO CONTAIN THE REQUEST, A FATAL ERROR MESSAGE IS
; GIVEN AND EXECUTION HALTS. THE PC ON THE TOP OF STACK WILL GIVE FURTHER
; CONTEXT ABOUT THE ERROR.  THE ALLOCATED BLOCK WILL BE ZEROED.
;
; INPUT:
;	R1 - SIZE OF REQUESTED BLOCK IN BYTES
;
; OUTPUTS:
;	R0 - SUCCESS/FAILURE INDICATION
;	R1 - ALLOCATED SIZE OF BLOCK
;	R2 - ADDRESS OF BLOCK
;-
INI$ALONONPAGED::			;
ALONONPAGED:				;
	PUSHL	R1			; SAVE DESIRED ALLOCATION QUANTITY
	JSB	EXE$ALONONPAGED		; ATTEMPT TO ALLOCATE
	BLBS	R0,10$			; CONTINUE IF ALLOCATED
	MOVQ	FIL$GQ_CACHE,R1		; DEALLOCATE FIL$OPENFILE CACHE 
	BEQL	5$			; BRANCH IF ALREADY GONE, FATAL
	CLRQ	FIL$GQ_CACHE		; SAY IT IS GONE
	MOVL	R2,R0			; ADDRESS TO R0, SIZE IN R1
	PUSHL	R3			; SAVE THIS FROM DEALLOCATE
	MOVL	EXE$GL_NONPAGED+4,R3	; ADDRESS OF FREE NON-PAGED POOL
	JSB	EXE$DEALLOCATE		; DEALLOCATE THE PIECE
	POPR	#^M<R3>			; RECOVER SAVED R3
	POPR	#^M<R1>			; GET ALLOCATION QUANTITY
	BRB	ALONONPAGED		; AND TRY ALL OVER AGAIN
5$:	BSBB	NOPOOLERR		; GIVE ERROR MESSAGE
	HALT				; ***** FATAL ERROR *****
10$:	ADDL	#4,SP			; CLEAN OFF SAVED ALLOC SIZE
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	; SAVE MOVC REGISTERS
	MOVC5	#0,(R2),#0,R1,(R2)	; ZERO FILL BLOCK
	POPR	#^M<R0,R1,R2,R3,R4,R5>	; RESTORE MOVC REGISTERS
	RSB				; RETURN
;
; NOPOOLERR - SEND ERROR MESSAGE FOR INSUFFICIENT NON-PAGED POOL
;
NOPOOLERR:				;
	CLRL	R11			; INDICATE CONSOLE TERMINAL
	MOVAB	NOSPACE,R1		; SET ADDRESS OF ERROR MESSAGE
	JMP	EXE$OUTZSTRING		; AND OUTPUT IT

	.SBTTL	ALOSPT - ALLOCATE AND FILL SPT ENTRY FOR BUFFER WINDOW
;+
; ALOSPT ALLOCATES AN SPT SLOT TO BE USED FOR BUFFER OVERMAPPING WHEN
; PERFORMING ECC CORRECTION OR OTHER SIMILAR EXCEPTIONAL I/O OPERATIONS.
; THE SYSTEM PAGE TABLE ENTRY FOR THE ALLOCATED SYSTEM VIRTUAL PAGE NUMBER
; WILL BE SET VALID, KERNEL WRITABLE BUT MAPPED TO A NON-EXISTENT PHYSICAL PAGE.
; A FATAL ERROR MESSAGE WILL BE GIVEN IF UNABLE TO ALLOCATE SPT.
;
; INPUT:
; 	BOO$GL_SPTFREL - LOWEST FREE SYSTEM VPN
;	BOO$GL_SPTFREH - HIGHEST FREE SYSTEM VPN
;
; OUTPUT:
;	R0 - SYSTEM VPN ALLOCATED
;	@MMG$GL_SPTBASE[R0] - PTE$M_VALID!PTE$M_PFN!PTE$C_KW
;-
ALOSPT:					;
	MOVL	BOO$GL_SPTFREL,R0	; GET NEXT AVAILABLE SYSTEM VPN
	CMPL	R0,BOO$GL_SPTFREH	; CHECK FOR REALLY AVAILABLE
	BLEQ	10$			; BRANCH IF YES
	MOVAB	NOSPT,R1		; SET ADDRESS OF ERROR MESSAGE
	CLRL	R11			; INDICATE CONSOLE TERMINAL	
	JSB	EXE$OUTZSTRING		; OUTPUT ERROR MESSAGE
	HALT				; **** FATAL ERROR ****
10$:	INCL	BOO$GL_SPTFREL		; MARK VPN ALLOCATED
	MOVL	#<PTE$C_KW!PTE$M_VALID!PTE$M_PFN!PTE$C_KOWN>,-	;
		@MMG$GL_SPTBASE[R0]	; SET SPTE VALID, WRITABLE, NONEXISTENT PFN
	RSB				;

	.SBTTL	RESIDENT PSECT CODE
	.PSECT	XDELTA,BYTE
;
;	INITIAL BREAKPOINT
;
; INPUT:
;	NONE
;
; OUTPUT:
;	CAUSES ENTRY TO DEBUGGER VIA BREAK POINT
;
; ***** WARNING DO NOT ALTER THIS ROUTINE, JUST A BPT AND RETURN.
;
 
INI$BRK::
	BPT				; STARTS AS BPT, CHANGED TO NOP
	RSB				; RETURN
 
;
;	MASTER WAKE INTERRUPT, CAUSED BY SOFTWARE LEVEL 5 INTERRUPT:
;
	.PSECT	$AEXENONPAGED,LONG

	.ALIGN	LONG
INI$MASTERWAKE::			; SOFTWARE LEVEL 5 INTERRUPT
	JSB	G^INI$BRK		; CALL BREAKPOINT SUBROUTINE
	REI				; RETURN FROM INTERRUPT

;
; MAKE SYSTEM CODE READ ONLY, MAKE SYSTEM CODE READ/WRITE
; USED BY XDELTA AND INIT.
;
; INPUTS:	NONE
;
; OUTPUTS:	ALL REGISTERS PRESERVED
;
	.PSECT	XDELTA,BYTE
 
	.ENABL	LSB
INI$WRITABLE::
	PUSHR	#^M<R0,R1,R2,R3>	; PRESERVE REGISTERS USED
	MOVZBL	#PRT$C_URKW,R0		; PROTECTION TO USE
	BRB	20$
INI$RDONLY::
	PUSHR	#^M<R0,R1,R2,R3>	; PRESERVE REGISTERS USED
	MOVZBL	#PRT$C_UR,R0		; PROTECTION TO USE
20$:
	MOVAL	W^INI_RDONLY_LIST,R3	; GET START OF READ ONLY LIST
	BBS	S^#EXE$V_SYSWRTABL,EXE$GL_FLAGS,60$ ; BRANCH IF LEAVING SYSTEM WRITABLE
	MOVQ	(R3)+,R1		; GET A SET OF ADDRESS LIMITS
	BEQL	60$			; DONE IF NULL
40$:
	INSV	R0,#PTE$V_PROT,#PTE$S_PROT,@MMG$GL_SPTBASE[R1] ; SET PROTECTION
	ACBL	R2,#4,R1,40$		; FOR EACH PAGE
	INVALID				; INVALIDATE THE TRANSLATION BUFFER
60$:
	POPR	#^M<R0,R1,R2,R3>	; RESTORE SAVED REGISTERS
	RSB				; AND RETURN TO THE CALLER
	.DSABL	LSB			;
;
;	LIST OF READ ONLY SECTIONS IN THE RESIDENT EXEC
;
INI_RDONLY_LIST:			;
	.LIST	MEB
	PURE	MMG$FRSTRONLY,<>	; SECOND LONGWORD LOADED BY INIT
	PURE	MMG$AL_BEGDRIVE,MMG$AL_ENDDRIVE	;
;
;	THE LIST MUST TERMINATE WITH THE FOLLOWING TWO DESCRIPTORS
;
PGDCOD_LIM:				;
	PURE	<>,MMG$AL_PGDCODEN	; FIRST LONGWORD LOADED BY INIT
	.LONG	0,0			; NULL DESCRIPTOR TO TERMINATE
	.NLIST	MEB			;
	.END	EXE$INIT
