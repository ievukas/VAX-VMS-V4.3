%TITLE 'SMG$DISPLAY_CHANGE - Virtual Display -- Changes to Displays'
MODULE SMG$DISPLAY_CHANGE (
		IDENT = '1-048'	! File: SMGDISCHA.B32 Edit: PLL1048
		) =
BEGIN
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY:	Screen Management
!
! ABSTRACT:
!	The procedures in this module update and maintain the contents
! of the in-memory representations of the virtual displays.  The data
! areas themselves are allocated/deallocated, pasted/upasted, etc.
! by the procedures in module SMG$DISPLAY_LINKS.  Output from these
! virtual displays is handled by procedures in SMG$DISPLAY_OUTPUT.
! The module SMG$DISPLAY_INPUT contains the routines that support
! input operations on displays.
!
!
!
! ENVIRONMENT:	User mode, Shared library routines.
!
! AUTHOR: R. Reichert, CREATION DATE: 26-Jan-1983
!
! MODIFIED BY:
!
! 1-048 - Change error messages by SMG$SET_CURSOR_REL. STAN 3-Jun-1984.
! 1-047 - Turn off the scrolling bit whenever sequential output ends, ie.
!	  whenever the cursor may be randomly positioned.  PLL 3-May-1984
! 1-001	- Original.  Skeleton for future code.  RKR 26-Jan-1983
!--

%SBTTL 'Declarations'
!
! SWITCHES:
!

!
! LINKAGES:
!
!	NONE
!
! TABLE OF CONTENTS:
!

FORWARD ROUTINE

! Public entry points:

    SMG$CHANGE_RENDITION,		! Change video attributes of
					! something already in a virtual
					! display

    SMG$CURSOR_COLUMN,			! Function to return current
					! cursor col. within virt. disp.

    SMG$CURSOR_ROW,			! Function to return current
					! cursor row within virt. disp.

    SMG$DELETE_CHARS,			! Delete characters from within
					! a line in a virtual display.

    SMG$DELETE_LINE,			! Delete line in a display &
					! scroll remaining lines

    SMG$ERASE_CHARS,			! Erase characters in a display
					! w/out moving remaining text

    SMG$ERASE_DISPLAY,			! Erase virtual display

    SMG$ERASE_LINE,			! Erase from position to end
					! of line

    SMG$HOME_CURSOR,			! Move cursor to one of the 4
					! corners of the virtual display

    SMG$INSERT_CHARS,			! Insert characters in a line
					! of a virtual display.

    SMG$INSERT_LINE,			! Insert line in a virtual
					! display

    SMG$PUT_CHARS,			! Put text to display without
					! additonal cursor motion.

    SMG$PUT_LINE,			! Put text line to display with
					! optional additonal cursor
					! motion.

    SMG$READ_FROM_DISPLAY,		! Read text back from virtual
					! display

    SMG$PUT_WITH_SCROLL,		! Scroll a virtual display and
					! place callers text into opened
					! area.

    SMG$RETURN_CURSOR_POS,		! Returns current cursor
					! position (row/column).

    SMG$SCROLL_DISPLAY_AREA,		! Scroll a rectangular area

    SMG$SET_CURSOR_ABS,			! Move cursor to absolute
					! position specified.

    SMG$SET_CURSOR_REL;			! Move cursor relative to its
					! current position.


! INCLUDE FILES
!

REQUIRE 'RTLIN:SMGPROLOG';		! defines psects, macros, tcb,
					!  wcb, & terminal symbols
REQUIRE 'RTLIN:STRLNK';			! JSB linkage

!
! EXTERNAL REFERENCES
!
EXTERNAL ROUTINE
    LIB$ANALYZE_SDESC_R2 : LIB$ANALYZE_SDESC_JSB_LINK,

    LIB$SCOPY_R_DX6 : STRING_JSB,	! String copier

    SMG$$CHECK_FOR_OUTPUT_DCB,	! Force output if now is the time

    SMG$$PUT_TEXT_TO_BUFFER,	! Move callers text to virtual
				! display text buffer checking
				! for characters that affect
				! where characters land in
				! buffer.

    SMG$$SCROLL_AREA;		! Scroll a rectangular area

EXTERNAL
    SMG$_FATERRLIB,	! Fatal error in SMG$ -- internal consistancy
			! check failed.
    SMG$_INVARG,	! Invalid argument
    SMG$_INVCOL,	! Invalid column number
    SMG$_INVDIS_ID,	! Invalid virtual display id
    SMG$_INVPAS_ID,	! Invalid pasteboard id
    SMG$_INVROW,	! Invalid row number
    SMG$_NO_CHADIS,	! No change to virtual display
    SMG$_WRONUMARG;	! Wrong number of arguments

!+
! The following macro determines whether scrolling up, down, or neither
! should occur.
!-
MACRO $SMG$SET_SCROLLING (SWITCH) =
    BEGIN
    SWITCH = 0;		! init scroll to off
    IF .DCB [DCB_V_FULL] NEQ 0
    THEN		! display is full, check other conditions
	BEGIN
	IF .DCB [DCB_W_CURSOR_ROW] EQL .DCB [DCB_W_BOTTOM_OF_SCRREG]
	THEN
	    SWITCH = 1	! scroll up
	ELSE
	    IF .DCB [DCB_W_CURSOR_ROW] EQL .DCB [DCB_W_TOP_OF_SCRREG]
	    THEN
		SWITCH = 2;  ! scroll down
	END;
    END;%;

!<BLF/PAGE>

%SBTTL 'SMG$CHANGE_RENDITION - Change Rendition'
GLOBAL ROUTINE SMG$CHANGE_RENDITION (
                        DISPLAY_ID,
                        START_ROW,
                        START_COL,
                        NO_ROW,
                        NO_COL,
			RENDITION_SET,
			RENDITION_COMPLEMENT
                                    ) =
!++
! FUNCTIONAL DESCRIPTION:
!
!       This routine changes the video rendition of a rectangular block of
!	text already in the specified virtual display.
!       Use of this routine makes it easy, for example, to redisplay a
!       particular column in reverse video.
!
! CALLING SEQUENCE:
!
!       ret_status.wlc.v = SMG$CHANGE_RENDITION (
!                               DISPLAY_ID.rl.r,
!                               START_ROW.rl.r,
!                               START_COL.rl.r,
!                               NO_ROW.rl.r,
!                               NO_COL.rl.r,
!                               [,RENDITION_SET.rl.r]
!				[,RENDITION_COMPLEMENT.rl.r])
!
! FORMAL PARAMETERS:
!
!       DISPLAY_ID.rl.r         Display id of desired virtual display.
!
!       START_ROW.rl.r          Starting row position to receive new 
!                               rendition
!
!       START_COL.rl.r          Starting column position to receive 
!                               new rendition.
!
!       NO_ROW.rl.r             No. of rows to receive new rendition
!
!       NO_COL.rl.r             No. of columns to receive new
!                               rendition
!
!	RENDITION_SET.rl.r	Each 1 bit attribute in this parameter
!				causes the corresponding attribute to
!				be set in the display.  (See below for
!				list of settable attributes.)
!
!	RENDITION_COMPLEMENT.rl.r
!				Each 1 bit attribute in this parameter
!				causes the corresponding attribute to
!				be complemented in the display.  (See
!				below for list of complementable
!				attributes.)
!
!	If the same bit is specified in both the RENDITION_SET parameter
!	and in the RENDITION_COMPLEMENT parameter, the application is
!	RENDITION_SET followed by RENDITION complement.  Using these two
!	parameters together the caller can exercise arbitrary and
!	independent control over each attribute on a single call.  On an
!	attribute by attribute basis he can cause the following
!	transformations:
!
!		SET	COMPLEMENT	Action
!		---	__________	______
!		0	0		Attribute unchanged.
!		1	0		Attribute set to "on"
!		0	1		Attribute set to complement of
!					current setting.
!		1	1		Attribute set to "off".
!
!
!	Attributes which can be manipulated in this manner are:
!
!	SMG$M_BLINK  displays characters blinking.
!	SMG$M_BOLD  displays characters in higher-than-normal 
!		      intensity.
!	SMG$M_REVERSE  displays characters in reverse video -- that is, 
!		      using the opposite default rendition of the 
!		      virtual display.
!	SMG$M_UNDERLINE  displays characters underlined.
!
! IMPLICIT INPUTS:
!
!       NONE
!
! IMPLICIT OUTPUTS:
!
!       NONE
!
! COMPLETION STATUS:
!
!       SS$_NORMAL      Normal successful completion
!       SMG$_INVROW     Invalid start row -- outside virtual display.
!       SMG$_INVCOL     Invalid start column -- outside virtual display.
!       SMG$_INVDIS_ID   Invalid display id.
!       SMG$_INVARG     Invalid no. of rows -- outside virtual display
!                    or Invalid no. of columns -- outside virtual display.
!                    or Unrecognized action code.
!                    or Unrecognized rendition code.
!       SMG$_WRONUMARG  Wrong number of arguments.
!
! SIDE EFFECTS:
!
!       NONE
!--
    BEGIN
    
    LOCAL
	START_INDEX,		! Byte offset into attribute buffer

	DCB : REF $DCB_DECL,	! Addr of display control block

	REND_CODE,		! Video rendition -- set up by
				! $SMG$SET_REND_CODE

	ATTR_BUF : REF VECTOR [,BYTE];	! Addr of attribute buffer for
					! this virtual display.

    LITERAL
	K_SET_ARG = 6,
	K_COMP_ARG = 7;

    $SMG$VALIDATE_ARGCOUNT (5,7);

    $SMG$GET_DCB ( .DISPLAY_ID, DCB);	! Get addr of display control
					! block

!+
! Validate arguments, make sure row & column are within the display.
!-

    $SMG$VALIDATE_ROW_COL (..START_ROW, ..START_COL);

    IF ..NO_COL LEQ 0 OR
       ..NO_ROW LEQ 0
    THEN
	RETURN (SMG$_NO_CHADIS);

    $SMG$VALIDATE_ROW_COL (..START_ROW + ..NO_ROW - 1,
			   ..START_COL + ..NO_COL - 1);

    ATTR_BUF = .DCB [DCB_A_ATTR_BUF];	
				! addr of attribute buffer

    $SMG$SET_REND_CODE (K_SET_ARG, K_COMP_ARG);
				! set rend_code w/default or caller's args

    !+
    ! Set the rendition bytes in the attribute buffer on a line by line
    ! basis, in case the change does not include the entire line.
    ! Be careful to preserve the other bits in the rendition byte that have
    ! nothing to do with rendition.
    !-

    START_INDEX = $SMG$LINEAR (..START_ROW, ..START_COL);
    INCR LINE_COUNT FROM 1 TO ..NO_ROW
    DO
    	BEGIN	! For each row
	INCR COL_COUNT FROM 0 TO (..NO_COL - 1)
	DO
	    BEGIN	! For each column

	    ATTR_BUF [.START_INDEX + .COL_COUNT ] =
	      (.ATTR_BUF [.START_INDEX + .COL_COUNT]
			 AND
	      ( NOT (SMG$M_BLINK+SMG$M_BOLD+SMG$M_REVERSE+SMG$M_UNDERLINE)) )
			 OR
		 .REND_CODE ;

	    END;	! For each column

	START_INDEX = .START_INDEX + .DCB [DCB_W_NO_COLS]; ! To next row start
	END;	! For each row
			
    !+
    ! See if this change should be reflected on the screen right away.
    !-

    RETURN (SMG$$CHECK_FOR_OUTPUT_DCB (.DCB, 
				       SMG$C_CHANGE_RENDITION));
    END;			! End of routine SMG$CHANGE_RENDITION
!<BLF/PAGE>

%SBTTL 'SMG$CURSOR_COLUMN - Return current cursor column position'
GLOBAL ROUTINE SMG$CURSOR_COLUMN ( DISPLAY_ID ) =
!++
! FUNCTIONAL DESCRIPTION:
!
!       This functions returns the current cursor column position in the
!	specified virtual display.
!
!	If the specified virtual display id is invalid, SMG$_INVDIS_ID
!	is signaled.
!
! CALLING SEQUENCE:
!
!       CURSOR_COLUMN.wl.r = SMG$CURSOR_COLUMN ( DISPLAY_ID.rl.r )
!
! FORMAL PARAMETERS:
!
!       DISPLAY_ID.rl.r Display id of desired display.
!
! IMPLICIT INPUTS:
!
!       NONE
!
! IMPLICIT OUTPUTS:
!
!       NONE
!
! ROUTINE VALUE:
!
!       CURSOR_COLUMN.wl.v	The current cursor column number in the
!				display.
!
! SIDE EFFECTS:
!
!	SMG$_INVDIS_ID	will be signaled if DISPLAY_ID in invalid.
!	SMG$_WRONUMARG	will be signaled if DISPLAY_ID is omitted.
!--
    BEGIN
    BUILTIN
	NULLPARAMETER;

    LOCAL
	DCB : REF $DCB_DECL;	! Addr. of display control block

    IF NULLPARAMETER(DISPLAY_ID)
    THEN
	SIGNAL_STOP ( SMG$_WRONUMARG);	! Display id has to be there

!+
! The next few lines of code validate the supplied device id.  It
! does precisely what $SMG$GET_DCB  does except it signals where that
! macro would return a status.
!-
    DCB = ..DISPLAY_ID;			! assume it is correct

    IF .DCB [DCB_L_DID] NEQ ..DISPLAY_ID
    THEN
	SIGNAL_STOP (SMG$_INVDIS_ID);	! Not pointing to one of our
					! control blocks

    IF .DCB [DCB_B_STRUCT_TYPE] NEQ DCB_K_STRUCT_TYPE
    THEN
	SIGNAL_STOP (SMG$_INVDIS_ID);	! Not pointing to a DCB
					! block

    RETURN (.DCB [DCB_W_CURSOR_COL]);	! Give them what they asked for

    END;			! End of routine SMG$CURSOR_COLUMN
!<BLF/PAGE>

%SBTTL 'SMG$CURSOR_ROW - Return current cursor row position'
GLOBAL ROUTINE SMG$CURSOR_ROW ( DISPLAY_ID ) =
!++
! FUNCTIONAL DESCRIPTION:
!
!       This functions returns the current cursor row position in the
!	specified virtual display.
!
!	If the specified virtual display id is invalid, SMG$_INVDIS_ID
!	is signaled.
!
! CALLING SEQUENCE:
!
!       CURSOR_ROW.wl.r = SMG$CURSOR_ROW ( DISPLAY_ID.rl.r )
!
! FORMAL PARAMETERS:
!
!       DISPLAY_ID.rl.r Display id of desired display.
!
! IMPLICIT INPUTS:
!
!       NONE
!
! IMPLICIT OUTPUTS:
!
!       NONE
!
! ROUTINE VALUE:
!
!       CURSOR_ROW.wl.v	The current cursor row number in the display.
!
! SIDE EFFECTS:
!
!	SMG$_INVDIS_ID	will be signaled if DISPLAY_ID in invalid.
!	SMG$_WRONUMARG	will be signaled if DISPLAY_ID is omitted.
!--
    BEGIN
    BUILTIN
	NULLPARAMETER;

    LOCAL
	DCB : REF $DCB_DECL;	! Addr. of display control block

    IF NULLPARAMETER(DISPLAY_ID)
    THEN
	SIGNAL_STOP ( SMG$_WRONUMARG);	! Display id has to be there

!+
! The next few lines of code validate the supplied device id.  It
! does precisely what $SMG$GET_DCB  does except it signals where that
! macro would return a status.
!-
    DCB = ..DISPLAY_ID;			! assume it is correct

    IF .DCB [DCB_L_DID] NEQ ..DISPLAY_ID
    THEN
	SIGNAL_STOP (SMG$_INVDIS_ID);	! Not pointing to one of our
					! control blocks

    IF .DCB [DCB_B_STRUCT_TYPE] NEQ DCB_K_STRUCT_TYPE
    THEN
	SIGNAL_STOP (SMG$_INVDIS_ID);	! Not pointing to a DCB
					! block

    RETURN (.DCB [DCB_W_CURSOR_ROW]);	! Give them what they asked for

    END;			! End of routine SMG$CURSOR_ROW
!<BLF/PAGE>

%SBTTL 'SMG$DELETE_CHARS - Delete Characters'
GLOBAL ROUTINE SMG$DELETE_CHARS (
                                 DISPLAY_ID,
                                 NUM_CHAR,
                                 ROW,
                                 COL
                                ) =
!++
! FUNCTIONAL DESCRIPTION:
!
!       This routine deletes the number of characters specified starting
!       at the row/column specified.
!
!       Remaining characters on the line to the right of the deleted 
!       characters are shifted to the left to occupy the vacated 
!       space(s).  
!
!	The internal display cursor position is left at the specified
!	start position after the operation.
!
! CALLING SEQUENCE:
!
!
!       ret_status.wlc.v = SMG$DELETE_CHARS ( 
!                                       DISPLAY_ID.rl.r,
!                                       NUM_CHAR.rl.r,
!                                       ROW.rl.r,
!                                       COL.rl.r)
!
! FORMAL PARAMETERS:
!
!       DISPLAY_ID.rl.r         Display id of desired virtual display.
!
!       NUM_CHAR.rl.r           Number of characters to be deleted
!
!       ROW.rl.r                Row position at which to start deletion.
!
!       COL.rl.r                Column position at which to start 
!                               deletion.
!
! IMPLICIT INPUTS:
!
!       NONE
!
! IMPLICIT OUTPUTS:
!
!       NONE
!
! COMPLETION STATUS:
!
!       SS$_NORMAL      Normal successful completion
!       SMG$_INVROW     Invalid row specification-- outside virtual
!                                                   display.
!       SMG$_INVCOL     Invalid column specification -- outside virtual
!                                                       display.
!       SMG$_INVDIS_ID  Invalid display id.
!       SMG$_WRONUMARG  Wrong number of arguments.
!       SMG$_INVARG     Number of characters specified starting at
!                       specified row and column extends outside of
!                       virtual display.
!
! SIDE EFFECTS:
!
!       NONE
!--
    BEGIN
    LOCAL
	NUM_TO_MOVE,		! No. of char positions to move left

	DCB : REF $DCB_DECL;	! Addr of display control block


    $SMG$VALIDATE_ARGCOUNT (4,4);

    $SMG$GET_DCB ( .DISPLAY_ID, DCB);	! Get addr of display control

!+
! Validity check row and column specified
!-

    $SMG$VALIDATE_ROW_COL ( ..ROW, ..COL);

!+
! Call SMG$$SCROLL_AREA to do the work.  It will shift the text left and
! blank fill the vacated space.
!-

    NUM_TO_MOVE = ..NUM_CHAR; 		! Assume number is ok
    IF ..COL + ..NUM_CHAR -1 GTR .DCB[DCB_W_NO_COLS]
    THEN				! Truncate to what's left on line
	NUM_TO_MOVE = .DCB [DCB_W_NO_COLS] - ..COL + 1;

    SMG$$SCROLL_AREA (.DCB, ..ROW, ..COL,
		      1, .DCB [DCB_W_NO_COLS],
		      SMG$M_LEFT, .NUM_TO_MOVE);

!+
! Make sure cursor points to first requested delete position.
!-

    DCB [DCB_W_CURSOR_ROW] = ..ROW;
    DCB [DCB_W_CURSOR_COL] = ..COL;
    DCB [DCB_V_FULL] = 0;		! turn off scrolling

!+
! See if this change should be reflected on the screen.
!-

    RETURN (SMG$$CHECK_FOR_OUTPUT_DCB (.DCB,
					SMG$C_DELETE_CHARS,
					..ROW));
    END;			! End of routine SMG$DELETE_CHARS
!<BLF/PAGE>

%SBTTL 'SMG$DELETE_LINE - Delete Line in Display'
GLOBAL ROUTINE SMG$DELETE_LINE (
				DISPLAY_ID,
				START_LINE_NO,
				NUM_LINES
			      ) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine deletes one or more lines in a virtual display
!	and scrolls up remaining lines into the created space.
!
!	The internal display cursor position is left at the first column
!	of the start line.
!
! CALLING SEQUENCE:
!
!	ret_status.wlc.v = SMG$DELETE_LINE (DISPLAY_ID.rl.r, 
!					    START_LINE_NO.rl.r
!					    [,NUM_LINES.rl.r])
!
! FORMAL PARAMETERS:
!
!	DISPLAY_ID	Display id of desired virtual display.
!
!	START_LINE_NO.rl.r	
!			Address of line number where deleting/scrolling
!			starts.
!
!	NUM_LINES.rl.r  Optional.  Number of lines to delete/scroll.
!			If not specified, defaults to 1.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	SS$_NORMAL	Normal successful completion
!
! SIDE EFFECTS:
!
!	NONE
!--
    BEGIN
    BUILTIN
	NULLPARAMETER;

    LOCAL
	DCB : REF $DCB_DECL,    ! addr of display control block
	WORK_NUM_LINES;		! working number of lines

    $SMG$VALIDATE_ARGCOUNT (2,3);

    $SMG$GET_DCB (.DISPLAY_ID, DCB);
				! get address of display control block

!+
! Validate arguments and set up working temporaries.
!-

    IF ..START_LINE_NO LSS .DCB [DCB_W_ROW_START] OR
       ..START_LINE_NO GTR .DCB [DCB_W_NO_ROWS]
    THEN
	RETURN (SMG$_INVROW);

    IF NOT NULLPARAMETER (NUM_LINES)
    THEN
	BEGIN
	WORK_NUM_LINES = ..NUM_LINES;
	IF ..START_LINE_NO + .WORK_NUM_LINES -1 GTR .DCB [DCB_W_NO_ROWS]
   	THEN
	    RETURN (SMG$_INVARG);
	END
    ELSE
	WORK_NUM_LINES = 1;

!+
! Reset the line characteristics in case the line was previously
! double high or wide.
!-

    BEGIN
    BIND 
	LINE_CHAR = .DCB [DCB_A_LINE_CHAR];
    MAP
	LINE_CHAR : VECTOR [,BYTE];

    INCR ROW_NUM FROM 1 TO .WORK_NUM_LINES DO
    	LINE_CHAR [.ROW_NUM] = 0;
    END;

!+
! Call SMG$$SCROLL_AREA to do the work.  It will move lines up or down,
! overwriting the lines that are to be deleted.
!-

    SMG$$SCROLL_AREA (.DCB,
		      ..START_LINE_NO,
	              .DCB [DCB_W_COL_START],
		      (.DCB [DCB_W_NO_ROWS] - ..START_LINE_NO + 1),
		      .DCB [DCB_W_NO_COLS],
		      SMG$M_UP,
		      .WORK_NUM_LINES);

!+
! Set cursor position to start of first line that was 'deleted'.
!-

    DCB [DCB_W_CURSOR_ROW] = ..START_LINE_NO;
    DCB [DCB_W_CURSOR_COL] = 1;
    DCB [DCB_V_FULL] = 0;	! mark that display is not full -
				! there is at least 1 line available
!+
! See if this change should be reflected on the screen right away.
!-

    RETURN (SMG$$CHECK_FOR_OUTPUT_DCB (.DCB,
				       SMG$C_DELETE_LINE,
				       ..START_LINE_NO));

    END;			! end of routine SMG$DELETE_LINE
!<BLF/PAGE>

%SBTTL 'SMG$ERASE_CHARS - Erase Characters in Display'
GLOBAL ROUTINE SMG$ERASE_CHARS (
				DISPLAY_ID,
				NUM_CHARS,
				LINE_NO,
				COL_NO
			      ) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine erases characters in a display by replacing them
!	with blanks.  Remaining text is not moved over.
!
!	Erasing is limited to the specified line.  If NUM_CHARS would
!	cause characters past the end of line to be erased, it is ignored
!	and only to the end of the line is blanked.
!
!	The internal display cursor position is set to the first free
!	position following the erase.
!
! CALLING SEQUENCE:
!
!	ret_status.wlc.v = SMG$ERASE_CHARS (DISPLAY_ID.rl.r, 
!					    NUM_CHARS.rl.r
!					    LINE_NO.rl.r, 
!					    COL_NO.rl.r)
!
! FORMAL PARAMETERS:
!
!	DISPLAY_ID.rl.r	Display id of desired virtual display.
!
!	NUM_CHARS.rl.r  Number of characters to erase.
!
!	LINE_NO.rl.r	Address of line number where erasing starts.
!
!	COL_NO.rl.r	Address of column number where erasing starts. 
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	SS$_NORMAL	Normal successful completion
!
! SIDE EFFECTS:
!
!	NONE
!--

    BEGIN

    LOCAL
	DCB : REF $DCB_DECL,    ! Addr of virtual display
				! control block.
	DEST_COL,		! destination column number
	START_INDEX,		! starting linear index into buffers
	WORK_NUM_CHARS;		! working number of characters

    $SMG$VALIDATE_ARGCOUNT (4, 4);

    $SMG$GET_DCB ( .DISPLAY_ID, DCB);	! Get address of virtual
					! display control block.
!+
! Validity check the parameters.  Don't try to erase more characters
! than are on the line.
!-

    $SMG$VALIDATE_ROW_COL ( ..LINE_NO, ..COL_NO);

    WORK_NUM_CHARS = ..NUM_CHARS;
    DEST_COL = ..COL_NO + ..NUM_CHARS - 1;
    IF .DEST_COL GTR .DCB [DCB_W_NO_COLS]
    THEN
	WORK_NUM_CHARS = .DCB [DCB_W_NO_COLS] - ..COL_NO + 1;

!+
! Put blanks in the text buffer, the default attribute byte into the
! attribute buffer, and the default character set byte into the character
! buffer.
!-

    START_INDEX = $SMG$LINEAR (..LINE_NO, ..COL_NO);

    $SMG$BLANK_FILL_DCB (.WORK_NUM_CHARS, .START_INDEX);

!+
! Virtual display buffers have been erased.  Init cursor to first 
! free position.
!-

    DCB [DCB_W_CURSOR_ROW] = ..LINE_NO;
    DCB [DCB_W_CURSOR_COL] = ..COL_NO;
    DCB [DCB_V_FULL] = 0;		! turn off scrolling

!+
! Call the output routine to see if this change in the virtual display
! should be reflected on the screen immediately.
!-

    RETURN (SMG$$CHECK_FOR_OUTPUT_DCB (.DCB, 
					SMG$C_ERASE_CHARS,
					..LINE_NO));
    END;				! End of routine SMG$ERASE_CHARS
!<BLF/PAGE>

%SBTTL 'SMG$ERASE_DISPLAY - Erase Display'
GLOBAL ROUTINE SMG$ERASE_DISPLAY (
				DISPLAY_ID,
				START_LINE_NO,
				START_COL_NO,
				END_LINE_NO,
				END_COL_NO
				 ) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine causes the specified display to be erased from the
!	specified start position to the specified end position.  If omitted,
!	the start position defaults to (1,1).  If the end position is omitted,
!	it defaults to the last character position in the display.  Thus the
!	entire display is erased if only the display_id is passed.
!
!	The internal display cursor position is set to the first free
!	position (1,1) following the erase.
!
! CALLING SEQUENCE:
!
!	ret_status.wlc.v = SMG$ERASE_DISPLAY (DISPLAY_ID.rl.r 
!					      [,START_LINE_NO.rl.r, 
!					      START_COL_NO.rl.r]
!					      [,END_LINE_NO.rl.r,
!					      END_COL_NO.rl.r])
!
! FORMAL PARAMETERS:
!
!	DISPLAY_ID.rl.r		Display id of the desired virtual display.
!
!	START_LINE_NO.rl.r	Optional.  Address of line number at which to 
!				start erasing.  If omitted, START_COL_NO will be 
!				ignored as well and whole display will be
!				erased.
!
!	START_COL_NO.rl.r	Optional.  Address of Column number at which 
!				to start erasing.  If omitted, START_LINE_NO  
!				will be ignored as well and entire display will
!				be erased.
!
!	END_LINE_NO.rl.r	Optional.  Address of line number at which to
!				end erasing.  If omitted, END_COL_NO is also
!				ignored and to the end of the display is erased.
!
!	END_COL_NO.rl.r		Optional.  Address of column number at which to
!				end erasing.  If omitted, END_LINE_NO is also
!				ignored and to the end of the display is erased.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	SS$_NORMAL	Normal successful completion
!
! SIDE EFFECTS:
!
!	NONE
!--

    BEGIN

    LOCAL
	DCB : REF $DCB_DECL,    ! Addr of virtual display
				! control block.
	LINE,			! temp row
	COL,			! temp column
	END_ROW,		! temp end row
	END_COLUMN,		! temp end col
	START_INDEX,		! starting linear index into buffers
	END_INDEX,		! ending linear index into buffers
	NUM_CHARS;		! number of characters to put into buffers

    BUILTIN
	ACTUALCOUNT,
	NULLPARAMETER;

    LITERAL
	K_START_LINE_ARG = 2,	! argument number of start_line_no
	K_END_LINE_ARG   = 4,	! argument number of end_line_no
	K_END_COL_ARG    = 5;	! argument number of end_col_no

!+
! Validity check the number of parameters.
!-

    $SMG$VALIDATE_ARGCOUNT (1, 5);

    $SMG$GET_DCB ( .DISPLAY_ID, DCB);	! Get address of virtual
					! display control block.
!+
! Calculate the linear start index, based on whether a cursor position
! was specified.
!-

    IF ACTUALCOUNT () LSS K_START_LINE_ARG  OR		! Quick check
       NULLPARAMETER (START_LINE_NO)        OR		! More elaborate checks
       NULLPARAMETER (START_COL_NO)
    THEN			! default start position
	BEGIN
	START_INDEX = 0;
	LINE = 1;
	COL = 1;
	END
    ELSE			! use specified position
	BEGIN
    	$SMG$VALIDATE_ROW_COL ( ..START_LINE_NO, ..START_COL_NO);
	START_INDEX = $SMG$LINEAR (..START_LINE_NO, ..START_COL_NO);
	LINE = ..START_LINE_NO;
	COL = ..START_COL_NO;
	END;

    IF ACTUALCOUNT() GEQ K_END_LINE_ARG    AND  ! Last 2 exist and are not null
    NOT NULLPARAMETER (END_LINE_NO)        AND
    NOT NULLPARAMETER (END_COL_NO)
    THEN
	BEGIN			! use specified end position
	$SMG$VALIDATE_ROW_COL (..END_LINE_NO, ..END_COL_NO);
	END_ROW = ..END_LINE_NO;
	END_COLUMN = ..END_COL_NO;
	END
    ELSE			! use default end position
	BEGIN
	END_ROW = .DCB [DCB_W_NO_ROWS];
	END_COLUMN = .DCB [DCB_W_NO_COLS];
	END;

    END_INDEX = $SMG$LINEAR (.END_ROW, .END_COLUMN);


!+
! Reset the line characteristics in case the line was previously
! double high or wide.
!-

    BEGIN
    BIND 
	LINE_CHAR = .DCB [DCB_A_LINE_CHAR];
    MAP
	LINE_CHAR : VECTOR [,BYTE];
    INCR ROW_NUM FROM .LINE TO (.END_ROW - .LINE) DO
    	LINE_CHAR [.ROW_NUM] = 0;
    END;

!+
! Put blanks in the text buffer, the default attribute byte into the
! attribute buffer, and the default character set byte into the character
! buffer.
!-

    NUM_CHARS = .END_INDEX - .START_INDEX + 1;

    $SMG$BLANK_FILL_DCB (.NUM_CHARS, .START_INDEX);

!+
! Virtual display buffers have been erased.  Init the cursor to the first
! free position.
!-

    DCB [DCB_W_CURSOR_ROW] = .LINE;
    DCB [DCB_W_CURSOR_COL] = .COL;

    DCB [DCB_V_FULL] = 0;	! flag that some lines are free

!+
! Call the output routine to see if this change in the virtual display
! should be reflected on the screen immediately.
!-

    RETURN (SMG$$CHECK_FOR_OUTPUT_DCB (.DCB, 
					SMG$C_ERASE_DISPLAY));
    END;			! End of routine SMG$ERASE_DISPLAY 
!<BLF/PAGE>

%SBTTL 'SMG$ERASE_LINE - Erase Line from Display'
GLOBAL ROUTINE SMG$ERASE_LINE (
				DISPLAY_ID,
				LINE_NO,
				COL_NO
			      ) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine causes the display to be erased from the specified
!	position to the end of the line.  If the position is not
!	specified, the current cursor position on the screen is assumed.
!
!	The internal display cursor position is set to the first free
!	position following the erase.
!
! CALLING SEQUENCE:
!
!	ret_status.wlc.v = SMG$ERASE_LINE (DISPLAY_ID.rl.r, 
!					   [LINE_NO.rl.r, 
!					   COL_NO.rl.r])
!
! FORMAL PARAMETERS:
!
!	DISPLAY_ID.rl.r	Display id of desired virtual display.
!
!	LINE_NO.rl.r	Optional.  Address of line number where erasing
!			starts.  If this argument is omitted, COL_NO is
!			ignored as well, and current position will be 
!			used.
!
!	COL_NO.rl.r	Optional.  Address of column number where 
!			erasing starts.  If this argument is omitted, 
!			LINE_NO is ignored as well, and current position
!			will be used.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	SS$_NORMAL	Normal successful completion
!
! SIDE EFFECTS:
!
!	NONE
!--

    BEGIN

    LOCAL
	DCB : REF $DCB_DECL,    ! Addr of virtual display
				! control block.
	LINE,			! temp line
	COL,			! temp column
	START_INDEX,		! starting linear index into buffers
	END_INDEX,		! ending linear index into buffers
	NUM_CHARS;		! number of characters to put into buffers

    BUILTIN
	ACTUALCOUNT,
	NULLPARAMETER;

!+
! Validity check the number of parameters.
!-

    $SMG$VALIDATE_ARGCOUNT (1, 3);

    $SMG$GET_DCB ( .DISPLAY_ID, DCB);	! Get address of virtual
					! display control block.


!+
! Calculate the linear start index, based on whether a cursor position
! was specified.
!-

    IF NULLPARAMETER (LINE_NO) OR
       NULLPARAMETER (COL_NO)
    THEN			! default start position
	BEGIN
	LINE = .DCB [DCB_W_CURSOR_ROW];
	COL = .DCB [DCB_W_CURSOR_COL];
	END
    ELSE			! use specified position
	BEGIN
    	$SMG$VALIDATE_ROW_COL ( ..LINE_NO, ..COL_NO);
	LINE = ..LINE_NO;
	COL = ..COL_NO;
	END;
!+
! Put blanks in the text buffer, the default attribute byte into the
! attribute buffer, and the default character set byte into the character
! buffer.
!-

    START_INDEX = $SMG$LINEAR (.LINE, .COL);
    END_INDEX = $SMG$LINEAR (.LINE, .DCB [DCB_W_NO_COLS]);
    NUM_CHARS = .END_INDEX - .START_INDEX + 1;

    $SMG$BLANK_FILL_DCB (.NUM_CHARS, .START_INDEX);

!+
! Reset the line characteristics in case the line was previously
! double high or wide.
!-

    BEGIN
    BIND 
	LINE_CHAR = .DCB [DCB_A_LINE_CHAR];
    MAP
	LINE_CHAR : VECTOR [,BYTE];
    IF .NUM_CHARS EQL .DCB [DCB_W_NO_COLS]
    THEN
    	LINE_CHAR [.LINE] = 0;
    END;

!+
! Virtual display buffers have been erased.  Init cursor to first 
! free position.
!-

    DCB [DCB_W_CURSOR_ROW] = .LINE;
    DCB [DCB_W_CURSOR_COL] = .COL;
    DCB [DCB_V_FULL] = 0;		! turn off scrolling

!+
! Call the output routine to see if this change in the virtual display
! should be reflected on the screen immediately.
!-

    RETURN (SMG$$CHECK_FOR_OUTPUT_DCB (.DCB, 
					SMG$C_ERASE_LINE,
					.LINE));
    END;				! End of routine SMG$ERASE_LINE
!<BLF/PAGE>

%SBTTL 'SMG$HOME_CURSOR - Home cursor to a corner position'
GLOBAL ROUTINE SMG$HOME_CURSOR (
                                DISPLAY_ID,
                                POSITION
                               ) =
!++
! FUNCTIONAL DESCRIPTION:
!
!       This routine moves the cursor to the corner row and column
!       of the specified virtual display according to position specified
!       by the POSITION parameter.
!       The caller does not need to know the dimensions of the
!       virtual display.
!
! CALLING SEQUENCE:
!
!       ret_status.wlc.v = SMG$HOME_CURSOR (
!                                           DISPLAY_ID.rl.r
!                                           [,POSITION.rl.r])
!
! FORMAL PARAMETERS:
!
!       DISPLAY_ID.rl.r The display id of the desired virtual display.
!
!       POSITION.rl.r   Optional.  Position to move cursor to according
!                       to following code:
!
!        0 = SMG$C_UPPER_LEFT   Row 1 Column 1 (upper left-hand corner).
!                               This is the default if argument is
!                               omitted.
!
!        1 = SMG$C_LOWER_LEFT   Row n Column 1 (Lower left-hand corner).
!                               This is a useful position for inputting
!                               into an upward scrolling virtual display
!
!        2 = SMG$C_UPPER_RIGHT  Row 1 Column m (Upper right-hand corner)
!
!        3 = SMG$C_LOWER_RIGHT  Row n Column m (Lower right-hand corner)
!
!                       +------------------+
!                       |0                2|
!                       |                  |
!                       |                  |
!                       |1                3|
!                       +------------------+
! IMPLICIT INPUTS:
!
!       NONE
!
! IMPLICIT OUTPUTS:
!
!       NONE
!
! COMPLETION STATUS:
!
!       SS$_NORMAL      Normal successful completion
!       SMG$_INVDIS_ID  Invalid virtual display id.
!       SMG$WRONUMARG   Wrong number of arguments.
!
! SIDE EFFECTS:
!
!       NONE
!--
    BEGIN
    BUILTIN
	NULLPARAMETER;

    LOCAL
	ROW,				! Working row number
	COL,				! Working col number
	DCB : REF $DCB_DECL;    	! Addr of display control block

    $SMG$VALIDATE_ARGCOUNT (1, 2);

    $SMG$GET_DCB ( .DISPLAY_ID, DCB);	! Get addr of display control
					! block

    ROW = 1;	! Assume defaults
    COL = 1;

    IF NOT NULLPARAMETER (POSITION)
    THEN
	BEGIN	! User-specified
	IF ..POSITION LSS SMG$C_UPPER_LEFT OR
	   ..POSITION GTR SMG$C_LOWER_RIGHT
	THEN
	    RETURN (SMG$_INVARG);

	CASE ..POSITION FROM SMG$C_UPPER_LEFT TO SMG$C_LOWER_RIGHT OF
	SET
	    [SMG$C_UPPER_LEFT]: 
		; 

	    [SMG$C_LOWER_LEFT]: 
		ROW = .DCB [DCB_W_NO_ROWS]; 

	    [SMG$C_UPPER_RIGHT]: 
		COL = .DCB [DCB_W_NO_COLS];

	    [SMG$C_LOWER_RIGHT]: 
		BEGIN 
		ROW = .DCB [DCB_W_NO_ROWS];
		COL = .DCB [DCB_W_NO_COLS]; 
		END;

	    [INRANGE, OUTRANGE]:
		RETURN SMG$_INVARG;

	TES;

	END;	! User-specified

    DCB [DCB_W_CURSOR_ROW] = .ROW;
    DCB [DCB_W_CURSOR_COL] = .COL;
    DCB [DCB_V_FULL] = 0;		! turn off scrolling

    RETURN (SMG$$CHECK_FOR_OUTPUT_DCB (.DCB,
					SMG$C_HOME_CURSOR));
    END;			! End of routine SMG$HOME_CURSOR
!<BLF/PAGE>

%SBTTL 'SMG$INSERT_CHARS - Insert Characters'
GLOBAL ROUTINE SMG$INSERT_CHARS (
                                 DISPLAY_ID,
                                 CHAR_STRING,
                                 ROW,
                                 COL,
				 RENDITION_SET,
				 RENDITION_COMPLEMENT,
				 CHAR_SET
                                ) =
!++
! FUNCTIONAL DESCRIPTION:
!
!       This routine inserts the specified character string at the
!       row and column position specified.
!
!       Characters supplied from CHAR_STRING are inserted into the
!       specified display at the specified ROW and COL, shifting
!       subsequent characters on the line to the right.
!
!	SMG$INSERT_CHARS is a character-oriented operation - any
!	characters which do not fit on the current line are thrown
!	away.  Wrapping is not allowed.
!
!	The internal display cursor position is left at the character
!	position following the last character written.
!
! CALLING SEQUENCE:
!
!       ret_status.wlc.v = SMG$INSERT_CHARS (
!                               DISPLAY_ID.rl.r,
!                               CHAR_STRING.rt.dx,
!                               ROW.rl.r,
!                               COL.rl.r,
!                               [,RENDITION_SET.rl.r]
!				[,RENDITION_COMPLEMENT.rl.r]
!				[,CHAR_SET.rl.r])
!
! FORMAL PARAMETERS:
!
!       DISPLAY_ID.rl.r         Display id of desired virtual display.
!
!       CHAR_STRING.rt.dx       Character string to be inserted
!
!       ROW.rl.r                Row position at which to start 
!                               insertion.
!
!       COL.rl.r                Column position at which to start 
!                               insertion.
!
!	RENDITION_SET.rl.r	Each 1 bit attribute in this parameter
!				causes the corresponding attribute to
!				be set in the display.  (See below for
!				list of settable attributes.)
!
!	RENDITION_COMPLEMENT.rl.r
!				Each 1 bit attribute in this parameter
!				causes the corresponding attribute to
!				be complemented in the display.  (See
!				below for list of complementable
!				attributes.)
!
!	If the same bit is specified in both the RENDITION_SET parameter
!	and in the RENDITION_COMPLEMENT parameter, the application is
!	RENDITION_SET followed by RENDITION complement.  Using these two
!	parameters together the caller can exercise arbitrary and
!	independent control over each attribute on a single call.  On an
!	attribute by attribute basis he can cause the following
!	transformations:
!
!		SET	COMPLEMENT	Action
!		---	__________	______
!		0	0		Attribute unchanged.
!		1	0		Attribute set to "on"
!		0	1		Attribute set to complement of
!	 				current setting.
!		1	1		Attribute set to "off".
!
!
!	Attributes which can be manipulated in this manner are:
!
!	SMG$M_BLINK  displays characters blinking.
!	SMG$M_BOLD  displays characters in higher-than-normal 
!		      intensity.
!	SMG$M_REVERSE  displays characters in reverse video -- that is, 
!		      using the opposite default rendition of the 
!		      virtual display.
!	SMG$M_UNDERLINE  displays characters underlined.
!
!	CHAR_SET.rl.r   	Optional.  Character set to use.
!				Choices are:
!					SMG$C_UNITED_KINGDOM
!					SMG$C_ASCII (default)
!					SMG$C_SPEC_GRAPHICS
!					SMG$C_ALT_CHAR
!					SMG$C_ALT_GRAPHICS
!
! IMPLICIT INPUTS:
!
!       NONE
!
! IMPLICIT OUTPUTS:
!
!       NONE
!
! COMPLETION STATUS:
!
!       SS$_NORMAL      Normal successful completion
!       LIB$_INVSTRDES  Invalid string descriptor
!       SMG$_INVROW     Invalid row specification-- outside virtual
!                       display.
!       SMG$_INVCOL     Invalid column specification -- outside virtual
!                       display.
!       SMG$_INVDIS_ID  Invalid virtual display id.
!       SMG$_WRONUMARG  Wrong number or arguments.
!       SMG$_INVARG     Unrecognized rendition code.
!
! SIDE EFFECTS:
!
!       NONE
!--
    BEGIN

    BUILTIN
	NULLPARAMETER;

    LITERAL
	K_SET_ARG = 5,
	K_COMP_ARG = 6;

    LOCAL
	DCB : REF $DCB_DECL,    	! Addr of display control block
	STR_ADDR,			! Addr of text
 	STR_LEN : INITIAL(0),		! Length of text
	PRINT_LEN,			! Length of text w/tabs, backspaces, etc
	REND_CODE,			! Rendition code 
	STATUS;				! Retd by called routine

    $SMG$VALIDATE_ARGCOUNT (4, 7);

    $SMG$GET_DCB ( .DISPLAY_ID, DCB);	! Get addr of display control

!+
! Validity check row and column specified.
!-

    $SMG$VALIDATE_ROW_COL ( ..ROW, ..COL);

    IF NOT NULLPARAMETER( CHAR_SET )
    THEN
	BEGIN
	CASE ..CHAR_SET FROM SMG$C_UNITED_KINGDOM TO SMG$C_ALT_GRAPHICS OF
	SET

	[SMG$C_UNITED_KINGDOM, SMG$C_ASCII, SMG$C_SPEC_GRAPHICS,
	 SMG$C_ALT_CHAR, SMG$C_ALT_GRAPHICS]:
		;
	[INRANGE, OUTRANGE]:
	  	RETURN (SMG$_INVARG);
	TES;
	END;

    IF NOT (STATUS = LIB$ANALYZE_SDESC_R2 (.CHAR_STRING;
					   STR_LEN,
					   STR_ADDR))
    THEN 
	RETURN (.STATUS);

!+
! Reset the line characteristics in case the line was previously
! double high or wide.
!-

    BEGIN
    BIND 
	LINE_CHAR = .DCB [DCB_A_LINE_CHAR];
    MAP
	LINE_CHAR : VECTOR [,BYTE];
    IF .LINE_CHAR [..ROW] NEQ 0		! prev. wide or high chars
    THEN
	BEGIN				! blank line
	LOCAL
	    START_INDEX;
	START_INDEX = $SMG$LINEAR (..ROW, 1);
	$SMG$BLANK_FILL_DCB (.DCB [DCB_W_NO_COLS], .START_INDEX);
        LINE_CHAR [..ROW] = 0;
	END;
    END;

!+
! Shift existing characters over to make room for new text.  If the
! space is already blank, just write into it.  Don't write over a
! blank if there are characters to the right of it - an embedded blank
! should be treated as a regular character and shifted.
!
! Macro $SMG$FIND_PRINT_LENGTH scans the string for funny characters
! and determines how many printing characters there are.  Extra space
! is allowed for tabs.  If a LF or CR is found, it terminates the string
! since the effect of this routine is limited to a single line.  STR_LEN
! is modified to reflect the number of characters that comprise PRINT_LEN.
!-

    BEGIN
    LOCAL
	INDEX,
	PTR,
	LINE_LEN,
	TEXT_BUF : REF VECTOR [,BYTE];

    $SMG$FIND_PRINT_LENGTH (STR_LEN, .STR_ADDR, PRINT_LEN);

    INDEX = $SMG$LINEAR (..ROW, ..COL);
    TEXT_BUF = .DCB [DCB_A_TEXT_BUF];

    LINE_LEN = .DCB [DCB_W_NO_COLS] - ..COL + 1;

    PTR = CH$FIND_NOT_CH (.LINE_LEN, TEXT_BUF [.INDEX], %C' ');
				! get ptr to 1st non-blank
    IF .PTR NEQ 0		
    THEN
    	SMG$$SCROLL_AREA (.DCB, ..ROW, ..COL,
		          1, .DCB [DCB_W_NO_COLS], 
			  SMG$M_RIGHT, .PRINT_LEN);

    END;

!+
! Write text into created space.  SMG$$PUT_TEXT_TO_BUFFER checks for
! funny characters (tabs, etc) and also updates the cursor position.
!-

    $SMG$SET_REND_CODE (K_SET_ARG, K_COMP_ARG);


    DCB [DCB_W_CURSOR_ROW] = ..ROW;
    DCB [DCB_W_CURSOR_COL] = ..COL;
				! set current position for PUT_TEXT

    SMG$$PUT_TEXT_TO_BUFFER (.DCB, .REND_CODE,
			     .STR_LEN, .STR_ADDR,
			     (IF NOT NULLPARAMETER (CHAR_SET)
			          THEN ..CHAR_SET
				  ELSE SMG$C_ASCII)   );

!+
! Turn off scrolling.  Sequential output has been interupted by
! moving the cursor for insert_chars.
!-

    DCB [DCB_V_FULL] = 0;

!+    
! See if this change needs to be reflected on the screen.
!-

    RETURN (SMG$$CHECK_FOR_OUTPUT_DCB (.DCB,
					SMG$C_INSERT_CHARS,
					..ROW));
    END;			! End of routine SMG$INSERT_CHARS
!<BLF/PAGE>

%SBTTL 'SMG$INSERT_LINE - Insert a line into a virtual display'
GLOBAL ROUTINE SMG$INSERT_LINE	 ( DISPLAY_ID,
				   LINE_NO,
				   STRING,
				   DIRECTION,
				   RENDITION_SET,
				   RENDITION_COMPLEMENT,
				   WRAP_FLAG,
				   CHAR_SET ) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine allows a line to be inserted into a virtual display
!	at a location other than the first or last line.  Existing lines
!	are scrolled in the specified direction to create an open space.
!	If a string is passed, it will be written in the space created;
!	otherwise, the new line will remain blank.  The entire line is
!	rewritten; if the string does not span the width of the display,
!	it is blank padded.
!
!	If WRAP_FLAG is set, characters which would exceed the rightmost
!	boundary of the display cause another line scroll and the overflow
!	characters are written in the created space.  If WRAP_FLAG is off,
!	any overflow characters are lost.
!
!	The internal display cursor position is left at the character
!	position following the text written.
!
!	See SMG$PUT_WITH_SCROLL to add lines at the first or last
!	line of a virtual display with scrolling.
!
! CALLING SEQUENCE:
!
!       ret_status.wlc.v = SMG$INSERT_LINE ( DISPLAY_ID.rl.r,
!					     LINE_NO.rlu.r,
!					     [,STRING.rt.dx]
!					     [,DIRECTION.rl.r]
!					     [,RENDITION_SET.rl.r]
!					     [,RENDITION_COMPLEMENT.rl.r]
!					     [,WRAP_FLAG.rl.r]
!					     [,CHAR.SET.rl.r])
!
! FORMAL PARAMETERS:
!
!       DISPLAY_ID.rl.r         Display id of desired virtual display.
!
!	LINE_NO.rlu.r		Line number at which to start scroll.
!
!	STRING.rt.dx		Optional.  Text to insert into line
!				created.  If not specified, all blanks
!				are used.
!
!	DIRECTION.rlu.r		Optional.  Direction to scroll text.
!					SMG$M_UP (Default)
!					SMG$M_DOWN
!
!	RENDITION_SET.rl.r	Each 1 bit attribute in this parameter
!				causes the corresponding attribute to
!				be set in the display.  (See below for
!				list of settable attributes.)
!
!	RENDITION_COMPLEMENT.rl.r
!				Each 1 bit attribute in this parameter
!				causes the corresponding attribute to
!				be complemented in the display.  (See
!				below for list of complementable
!				attributes.)
!
!	If the same bit is specified in both the RENDITION_SET parameter
!	and in the RENDITION_COMPLEMENT parameter, the application is
!	RENDITION_SET followed by RENDITION complement.  Using these two
!	parameters together the caller can exercise arbitrary and
!	independent control over each attribute on a single call.  On an
!	attribute by attribute basis he can cause the following
!	transformations:
!
!		SET	COMPLEMENT	Action
!		---	__________	______
!		0	0		Attribute unchanged.
!		1	0		Attribute set to "on"
!		0	1		Attribute set to complement of
!					current setting.
!		1	1		Attribute set to "off".
!
!	WRAP_FLAG.rl.r		Optional.  Action to take if text does
!				not fit on the line.
!				0 = nowrap (Default)
!				1 = wrap
!				
!	CHAR_SET.rl.r   	Optional.  Character set to use.
!				Choices are:
!					SMG$C_UNITED_KINGDOM
!					SMG$C_ASCII (default)
!					SMG$C_SPEC_GRAPHICS
!					SMG$C_ALT_CHAR
!					SMG$C_ALT_GRAPHICS
!
! IMPLICIT INPUTS:
!
!       NONE
!
! IMPLICIT OUTPUTS:
!
!       NONE
!
! COMPLETION STATUS:
!
!       SS$_NORMAL      Normal successful completion
!       SMG$_INVDIS_ID  Invalid display id.
!       SMG$_WRONUMARG  Wrong number of arguments.
!
! SIDE EFFECTS:
!
!       NONE
!--
    BEGIN

    BUILTIN
	NULLPARAMETER;

    LITERAL
	K_SET_ARG = 5,
	K_COMP_ARG = 6;

    LOCAL
	DONE,
	STATUS,				! Status of subroutine calls
	DCB : REF $DCB_DECL,		! Addr of display control block
	STR_LEN : INITIAL (0),		! Length of text string
	STR_ADDR,			! Addr of text string
	DIR,				! Working direction
	C_SET,				! Working character set
	WRAP_CHARS : INITIAL (0),	! No. of overflow characters
					! Reset by call to
					! SMG$$PUT_TEXT_TO_BUFFER
	REND_CODE;			! Rendition code from params
					! Set by $SMG$SET_REND_CODE
    $SMG$VALIDATE_ARGCOUNT (2, 8);

    $SMG$GET_DCB ( .DISPLAY_ID, DCB);	! Get address of display control
					! block

!+
! Validity check the arguments.
!-

    IF ..LINE_NO LSS .DCB [DCB_W_TOP_OF_SCRREG] OR
       ..LINE_NO GTR .DCB [DCB_W_BOTTOM_OF_SCRREG]
    THEN
	RETURN (SMG$_INVROW);

    DIR = SMG$M_UP;			! init to default

    IF NOT NULLPARAMETER( DIRECTION )
    THEN
	BEGIN
      	IF (..DIRECTION NEQ SMG$M_UP AND 
            ..DIRECTION NEQ SMG$M_DOWN)
    	THEN
	    RETURN (SMG$_INVARG)
    	ELSE
	    DIR = ..DIRECTION;
	END;

    C_SET = SMG$C_ASCII;		! init to default

    IF NOT NULLPARAMETER( CHAR_SET )
    THEN
	BEGIN
	CASE ..CHAR_SET FROM SMG$C_UNITED_KINGDOM TO SMG$C_ALT_GRAPHICS OF
	SET

	[SMG$C_UNITED_KINGDOM, SMG$C_ASCII, SMG$C_SPEC_GRAPHICS,
	 SMG$C_ALT_CHAR, SMG$C_ALT_GRAPHICS]:
		C_SET = ..CHAR_SET;
	[INRANGE, OUTRANGE]:
	  	RETURN (SMG$_INVARG);
	TES;
	END;

!+
! Set up string to output, either the caller's text or a blank line.
!-

    IF NOT NULLPARAMETER (STRING)
    THEN
	BEGIN				! use caller's text
	IF NOT (STATUS = LIB$ANALYZE_SDESC_R2 (.STRING; STR_LEN, STR_ADDR))
	THEN 
	    RETURN (.STATUS);
	END;				! user caller's text

!+
! Move existing lines up or down to create an empty space.  This space
! will remain empty if the user did not specify a text string.
!-

    IF .DIR EQL SMG$M_UP
    THEN
	SMG$$SCROLL_AREA (.DCB, .DCB [DCB_W_TOP_OF_SCRREG], 
			  .DCB [DCB_W_COL_START],
		      	  (..LINE_NO - .DCB [DCB_W_TOP_OF_SCRREG] + 1),
			  .DCB [DCB_W_NO_COLS],
		      	  SMG$M_UP, 1)
    ELSE
	SMG$$SCROLL_AREA (.DCB, ..LINE_NO, .DCB [DCB_W_COL_START],
			  (.DCB [DCB_W_BOTTOM_OF_SCRREG] - ..LINE_NO + 1),
			  .DCB [DCB_W_NO_COLS],
			  SMG$M_DOWN, 1);

!+
! Reset the line characteristics in case the line was previously
! double high or wide.
!-

    BEGIN
    BIND 
	LINE_CHAR = .DCB [DCB_A_LINE_CHAR];
    MAP
	LINE_CHAR : VECTOR [,BYTE];
    LINE_CHAR [..LINE_NO] = 0;
    END;

!+
! Write text into the space just created.  SMG$$PUT_TEXT_TO_BUFFER
! checks for funny characters (tabs, etc) and also updates the cursor
! position.  
!-

    IF .STR_LEN NEQ 0
    THEN
	BEGIN				! parse & move caller's text
    	$SMG$SET_REND_CODE (K_SET_ARG, K_COMP_ARG);

    	DCB [DCB_W_CURSOR_ROW] = ..LINE_NO;
    	DCB [DCB_W_CURSOR_COL] = 1;
					! set current position for PUT_TEXT
	DCB [DCB_V_FULL] = 0;
	
    	SMG$$PUT_TEXT_TO_BUFFER (.DCB, 
				.REND_CODE,
			        .STR_LEN, 
				.STR_ADDR,
			        C_SET,
				WRAP_CHARS);
	END

    ELSE
	BEGIN			
	!+
	! Used the short cut to put out a blank line (we let SMG$$SCROLL_AREA
	! do it), so we must update the cursor position ourselves (normally
	! SMG$$PUT_TEXT_TO_BUFFER would do it).
	!-
	DCB [DCB_W_CURSOR_ROW] = ..LINE_NO + 1;
	IF .DCB [DCB_W_CURSOR_ROW] LEQ .DCB [DCB_W_BOTTOM_OF_SCRREG]
 	THEN
	    BEGIN
	    DCB [DCB_V_FULL] = 0;
	    DCB [DCB_W_CURSOR_COL] = .DCB [DCB_W_COL_START]
	    END
	ELSE
	    BEGIN			! just wrote last line
	    DCB [DCB_W_CURSOR_ROW] = .DCB [DCB_W_BOTTOM_OF_SCRREG];
	    DCB [DCB_W_CURSOR_COL] = .DCB [DCB_W_NO_COLS];
	    DCB [DCB_V_FULL] = 1;	! remember used all lines
	    DCB [DCB_V_COL_80] = 1;	! remember at last col position
	    END;
	END;

!+
! Check for overflow characters which should cause us to scroll 2 lines
! in order to output everything (if wrap requested).  Need to pass the
! number of characters (not the printing length) in the descriptor.
!-

    IF .WRAP_CHARS NEQ 0
    THEN
	BEGIN
    	IF NOT NULLPARAMETER( WRAP_FLAG ) AND
           ..WRAP_FLAG NEQ 0 		! wrap requested
    	THEN
	    BEGIN			! recurse until whole string output
	    LOCAL
	    	TEMP_DESC : BLOCK [8, BYTE];

	    TEMP_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
	    TEMP_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	    TEMP_DESC [DSC$W_LENGTH] = .STR_LEN - .DCB [DCB_W_NO_COLS];
	    TEMP_DESC [DSC$A_POINTER] = .STR_ADDR +
				    .DCB [DCB_W_NO_COLS];

	    !+
	    ! Kludge for downscrolling so that pieces of the line appear
	    ! in the correct order.
	    !-
	    IF .DIR EQL SMG$M_DOWN
	    THEN
	    	BEGIN
	    	LOCAL
		    OVERFLOW_LINE;
	    	OVERFLOW_LINE = ..LINE_NO + 1;
	    	SMG$INSERT_LINE (.DISPLAY_ID, OVERFLOW_LINE,
			         TEMP_DESC, %REF (SMG$M_DOWN),
			         (IF NOT NULLPARAMETER (RENDITION_SET)
				      THEN .RENDITION_SET
				      ELSE 0),
				 (IF NOT NULLPARAMETER (RENDITION_COMPLEMENT)
				      THEN .RENDITION_COMPLEMENT
				      ELSE 0),
			         .WRAP_FLAG, C_SET);
	    	END
	    ELSE
	    	SMG$INSERT_LINE (.DISPLAY_ID, .LINE_NO,
			         TEMP_DESC, %REF (SMG$M_UP),
			         (IF NOT NULLPARAMETER (RENDITION_SET)
				      THEN .RENDITION_SET
				      ELSE 0),
				 (IF NOT NULLPARAMETER (RENDITION_COMPLEMENT)
				      THEN .RENDITION_COMPLEMENT
				      ELSE 0),
			         .WRAP_FLAG,
			         C_SET);
	    DONE = 0;
	    RETURN 1;			! to keep Bliss happy
	    END
	ELSE
	    BEGIN
	    !+
	    ! Wrap was not requested but there were overflow characters.
	    ! Put out diamond in last position to show truncation.
	    !-
	    IF .DCB [DCB_V_TRUNC_ICON]
	    THEN
		BEGIN
	    	DCB [DCB_W_CURSOR_COL] = .DCB [DCB_W_NO_COLS];
	    	SMG$$PUT_TEXT_TO_BUFFER (.DCB, 
				         .REND_CODE + ATTR_M_USER_GRAPHIC,
				         1, UPLIT (BYTE (DIAMOND)),
				         SMG$C_ASCII);
		END;
	    DONE = 1;
	    END;
	END
    ELSE
	DONE = 1;			! no wrap chars

!+
! See if this change should be reflected on the screen.  Even if
! we call SMG$INSERT_LINE again, SMG$$CHECK_FOR_OUTPUT_DCB should
! be executed only once.
!-

    IF .DONE
    THEN
    	RETURN (SMG$$CHECK_FOR_OUTPUT_DCB (.DCB,
				   	   SMG$C_INSERT_LINE,
					   ..LINE_NO))
    ELSE
	RETURN 1;

    END;				! End of SMG$INSERT_LINE
!<BLF/PAGE>

%SBTTL 'SMG$PUT_CHARS - Put Text to Display'
GLOBAL ROUTINE SMG$PUT_CHARS (
				DISPLAY_ID,
				TEXT    : REF BLOCK [,BYTE],
				LINE_NO,
				COL_NO,
				ERASE_LINE_FLAG,
				RENDITION_SET,
				RENDITION_COMPLEMENT,
				CHAR_SET
			      ) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is used to write messages to the virtual display.
!	No additional cursor motion is added.  Existing text is NOT
!	shifted over - SMG$PUT_CHARS will overwrite anything already
!	in the specified positions.  (See SMG$INSERT_CHARS to write new
!	text while preserving existing text.)
!
!	By default, SMG$PUT_CHARS will write out only the text passed to
!	it - other character positions in the line are not modified.  
!	Optionally, the caller can request that the line be erased before 
!	the new characters are output by setting ERASE_LINE_FLAG.  This
!	option is provided for callers who do not want to preserve the
!	previous contents of the line.
!
!	The internal display cursor position is left at the character position
!	following the text written.
!
! CALLING SEQUENCE:
!
!	ret_status.wlc.v = SMG$PUT_CHARS (DISPLAY_ID.rl.r,
!					  TEXT.rt.dx
!					  [,LINE_NO.rl.r, COL_NO.rl.r] 
!					  [,ERASE_LINE_FLAG.rl.r]
!					  [,RENDITION_SET.rl.r]
!					  [,RENDITION_COMPLEMENT.rl.r]
!					  [,CHAR_SET.rl.r])
!
! FORMAL PARAMETERS:
!
!	DISPLAY_ID.rl.r	Display id of virtual display
!
!	TEXT.rt.dx	Address of descriptor of output string.
!
!	LINE_NO.rl.r	Optional.  Address of line number at which to 
!			start output.  If omitted (=0), the current 
!			line number is used.
!
!	COL_NO.rl.r	Optional.  Address of column number at which 
!			to start output.  If omitted (=0), the current 
!			line number is used.
!
!	ERASE_LINE_FLAG.rl.r
!			Optional.  Address of flag which specifies
!			whether to erase the line before outputting
!			the specified text.
!			1==> Erase
!			0==> Don't erase
!
!	RENDITION_SET.rl.r	Each 1 bit attribute in this parameter
!				causes the corresponding attribute to
!				be set in the display.  (See below for
!				list of settable attributes.)
!
!	RENDITION_COMPLEMENT.rl.r
!				Each 1 bit attribute in this parameter
!				causes the corresponding attribute to
!				be complemented in the display.  (See
!				below for list of complementable
!				attributes.)
!
!	If the same bit is specified in both the RENDITION_SET parameter
!	and in the RENDITION_COMPLEMENT parameter, the application is
!	RENDITION_SET followed by RENDITION complement.  Using these two
!	parameters together the caller can exercise arbitrary and
!	independent control over each attribute on a single call.  On an
!	attribute by attribute basis he can cause the following
!	transformations:
!
!		SET	COMPLEMENT	Action
!		---	__________	______
!		0	0		Attribute unchanged.
!		1	0		Attribute set to "on"
!		0	1		Attribute set to complement of
!					current setting.
!		1	1		Attribute set to "off".
!
!
!	Attributes which can be manipulated in this manner are:
!
!	SMG$M_BLINK  displays characters blinking.
!	SMG$M_BOLD  displays characters in higher-than-normal 
!		      intensity.
!	SMG$M_REVERSE  displays characters in reverse video -- that is, 
!		      using the opposite default rendition of the 
!		      virtual display.
!	SMG$M_UNDERLINE  displays characters underlined.
!
!	CHAR_SET.rl.r  	Optional.  Character set to use.
!			Choices are:
!				SMG$C_UNITED_KINGDOM
!				SMG$C_ASCII (default)
!				SMG$C_SPEC_GRAPHICS
!				SMG$C_ALT_CHAR
!				SMG$C_ALT_GRAPHICS
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	SS$_NORMAL	Normal successful completion
!	SMG$_INVCOL	Invalid column specification
!	SMG$_INVROW	Invalid row specification
!	LIB$_INVSTRDES	Invalid string descriptor
!	SMG$_WRONUMARG	Wrong number (or combination of) arguments
!
! SIDE EFFECTS:
!
!	NONE
!--

    BEGIN

    BUILTIN
	NULLPARAMETER;

    LOCAL
	ROW,				! Row where text goes
	COL,				! Column where text goes
	REND_CODE,			! RENDITION_CODE code to use.
	STR_LEN : INITIAL (0),		! Length of text string
	STR_ADDR,			! Addr. of text string
	DCB : REF $DCB_DECL,    	! Address of virtual display
					! control block
	STATUS;				! Status of subroutine calls

    LITERAL
	K_SET_ARG = 6,
	K_COMP_ARG = 7;

    $SMG$VALIDATE_ARGCOUNT (2, 8);

    $SMG$GET_DCB ( .DISPLAY_ID, DCB);	! Get address of virtual display
					! control block.

!+
! Get the length and address of the text string.
!-

    IF NOT (STATUS = LIB$ANALYZE_SDESC_R2 ( .TEXT;
 					    STR_LEN,
					    STR_ADDR))
    THEN
	RETURN (.STATUS);

!+
! Check for all optional arguments.  Set local variables to caller's
! values, when available, and defaults when arguments omitted.
!-

    IF NOT NULLPARAMETER (LINE_NO) AND
       ..LINE_NO NEQ 0
    THEN
	ROW = ..LINE_NO
    ELSE
	ROW = .DCB [DCB_W_CURSOR_ROW];

    IF NOT NULLPARAMETER (COL_NO) AND
       ..COL_NO NEQ 0
    THEN
	COL = ..COL_NO
    ELSE
	COL = .DCB [DCB_W_CURSOR_COL];

    $SMG$VALIDATE_ROW_COL (.ROW, .COL);
				! verify row & col within display

    $SMG$SET_REND_CODE (K_SET_ARG, K_COMP_ARG);
				! macro to use caller's args if present

    IF NOT NULLPARAMETER( CHAR_SET )
    THEN
	BEGIN
	CASE ..CHAR_SET FROM SMG$C_UNITED_KINGDOM TO SMG$C_ALT_GRAPHICS OF
	SET

	[SMG$C_UNITED_KINGDOM, SMG$C_ASCII, SMG$C_SPEC_GRAPHICS,
	 SMG$C_ALT_CHAR, SMG$C_ALT_GRAPHICS]:
		;
	[INRANGE, OUTRANGE]:
	  	RETURN (SMG$_INVARG);
	TES;
	END;


!+
! Reset the line characteristics in case the line was previously
! double high or wide.
!-

    BEGIN
    BIND 
	LINE_CHAR = .DCB [DCB_A_LINE_CHAR];
    MAP
	LINE_CHAR : VECTOR [,BYTE];
    IF .LINE_CHAR [.ROW] NEQ 0		! prev wide or high chars
    THEN
	BEGIN				! blank line
	LOCAL
	    START_INDEX;
	START_INDEX = $SMG$LINEAR (.ROW, 1);
	$SMG$BLANK_FILL_DCB (.DCB [DCB_W_NO_COLS], .START_INDEX);
        LINE_CHAR [.ROW] = 0;
	END;
    END;

!+
! If erase_line_flag is set, blank out the line before outputting the text.
!-

    IF NOT NULLPARAMETER (ERASE_LINE_FLAG) AND
       ..ERASE_LINE_FLAG NEQ 0
    THEN
	BEGIN
	LOCAL
	    START_INDEX;
	START_INDEX = $SMG$LINEAR (.ROW, 1);
   	$SMG$BLANK_FILL_DCB (.DCB [DCB_W_NO_COLS], .START_INDEX);
	END;

!+
! All local variables are set up.  Call routine to put text into the
! display buffer.
!-

    DCB [DCB_W_CURSOR_ROW] = .ROW;
    DCB [DCB_W_CURSOR_COL] = .COL;
				! set current position for PUT_TEXT

    IF NOT (STATUS = SMG$$PUT_TEXT_TO_BUFFER ( .DCB,
					       .REND_CODE,
					       .STR_LEN,
					       .STR_ADDR,
					       IF NOT NULLPARAMETER (CHAR_SET)
					       THEN ..CHAR_SET
					       ELSE SMG$C_ASCII ))
    THEN
	RETURN (.STATUS);


!+
! Check for non-printable characters, such as LF, that may cause this
! call to affect several lines.  Normally we try to tell the output
! routines exactly what line changed (so it can optimize), but if we
! encountered funny characters which may have changed more than 1 line,
! just pass a 0 (which will turn off optimization).
!-
    BEGIN
    LOCAL
	SAVED_STRING_LEN,
	PRINT_LEN;

	SAVED_STRING_LEN = .STR_LEN;
				! side effect of macro is to change STR_LEN
	$SMG$FIND_PRINT_LENGTH (STR_LEN, .STR_ADDR, PRINT_LEN);
				! macro to do SCANC
	IF .PRINT_LEN NEQ .SAVED_STRING_LEN
	THEN
	    ROW = 0;
    END;

!+
! Turn off scrolling.  This change just moved the cursor to some
! random position.
!-
    DCB [DCB_V_FULL] = 0;

!+
! See if this change should be reflected on the screen.
!-

    RETURN (SMG$$CHECK_FOR_OUTPUT_DCB (.DCB,
					SMG$C_PUT_CHARS,
					.ROW));
    END;				! End of routine SMG$PUT_CHARS
!<BLF/PAGE>

%SBTTL 'SMG$PUT_LINE - Put Text to Display in Line Mode'
GLOBAL ROUTINE SMG$PUT_LINE (
				DISPLAY_ID,
				TEXT     : REF BLOCK [,BYTE],
				LINE_ADV,
				RENDITION_SET,
				RENDITION_COMPLEMENT,
				WRAP_FLAG,
				CHAR_SET
			    ) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is used to write lines to the virtual display
!	optionally followed by cursor movement sequences.  SMG$PUT_LINE
!	writes from the current cursor position to the end of the line. 
!	If the caller's text does not span to the end of the line, blank  
!	fill is added.
!
!	Treatment of text which exceeds the rightmost bounds of the
!	display depends on WRAP_FLAG.  If WRAP_FLAG is set, lines are
!	scrolled LINE_ADV times to make room for the overflow characters
!	in the 'next' line.  If wrap is off, overflow characters are lost.
!
!	Following a call to SMG$PUT_LINE, the internal display cursor
!	position is set to column 1 of the next line where output should
!	occur.  The next line where output should occur is determined by
!	LINE_ADV;  LINE_ADV defaults to 1 so that subsequent calls to
!	SMG$PUT_LINE will not cause overprinting.
!
! CALLING SEQUENCE:
!
!	ret_status.wlc.v = SMG$PUT_LINE (DISPLAY_ID.rl.r,
!					 TEXT.rt.dx
!					 [,LINE_ADV.rl.r] 
!					 [,RENDITION_SET.rl.r]
!					 [,RENDITION_COMPLEMENT.rl.r]
!					 [,WRAP_FLAG.rl.r]
!					 [,CHAR_SET.rl.r])
!
! FORMAL PARAMETERS:
!
!	DISPLAY_ID.rl.r	Display id of virtual display
!
!	TEXT.rt.dx	Address of descriptor of output string.
!
!	LINE_ADV.rl.r	Optional.  Address of signed number of lines 
!			to advance after output.
!
!	RENDITION_SET.rl.r	Each 1 bit attribute in this parameter
!				causes the corresponding attribute to
!				be set in the display.  (See below for
!				list of settable attributes.)
!
!	RENDITION_COMPLEMENT.rl.r
!				Each 1 bit attribute in this parameter
!				causes the corresponding attribute to
!				be complemented in the display.  (See
!				below for list of complementable
!				attributes.)
!
!	If the same bit is specified in both the RENDITION_SET parameter
!	and in the RENDITION_COMPLEMENT parameter, the application is
!	RENDITION_SET followed by RENDITION complement.  Using these two
!	parameters together the caller can exercise arbitrary and
!	independent control over each attribute on a single call.  On an
!	attribute by attribute basis he can cause the following
!	transformations:
!
!		SET	COMPLEMENT	Action
!		---	__________	______
!		0	0		Attribute unchanged.
!		1	0		Attribute set to "on"
!		0	1		Attribute set to complement of
!					current setting.
!		1	1		Attribute set to "off".
!
!
!	Attributes which can be manipulated in this manner are:
!
!	SMG$M_BLINK  displays characters blinking.
!	SMG$M_BOLD  displays characters in higher-than-normal 
!		      intensity.
!	SMG$M_REVERSE  displays characters in reverse video -- that is, 
!		      using the opposite default rendition of the 
!		      virtual display.
!	SMG$M_UNDERLINE  displays characters underlined.
!
!	WRAP_FLAG.rl.r	= 0 means no wrap
!			= 1 means wrap
!			If omitted, no wrap is the default.
!
!	CHAR_SET.rl.r  	Optional.  Character set to use.
!			Choices are:
!				SMG$C_UNITED_KINGDOM
!				SMG$C_ASCII (default)
!				SMG$C_SPEC_GRAPHICS
!				SMG$C_ALT_CHAR
!				SMG$C_ALT_GRAPHICS
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	SS$_NORMAL	Normal successful completion
!	SMG$_WRONUMARG	Wrong number (of combination of) arguments
!	SMG$_INVARG	Negative LINE_ADV specified
!	LIB$_INVSTRDES	Invalid string descriptor
!
! SIDE EFFECTS:
!
!	NONE
!--

    BEGIN

    BUILTIN
	NULLPARAMETER;

    LOCAL
	DONE,
	DCB : REF $DCB_DECL,		! Address of virtual display
					! control block.
	STR_LEN : INITIAL (0),		! Length of text string
	STR_ADDR,			! Address of text string
	REND_CODE,			! Rendition code to use
	WRAPPED_CHARS :INITIAL (0),	! Number of chars that don't fit on
					! the current line
					! Set by call to SMG$$PUT_TEXT_TO_BUFFER
	SCROLL_FLAG : INITIAL (0),	! Flag to scroll up, down, or neither
					! Set by $SMG$SET_SCROLLING
	STATUS;				! Status of subroutine calls

    LITERAL
	K_SET_ARG = 4,
	K_COMP_ARG = 5;

    MACRO $SCROLL_UP (COUNT) =
	    SMG$$SCROLL_AREA (.DCB,
			      .DCB [DCB_W_TOP_OF_SCRREG],
			      .DCB [DCB_W_COL_START],
			      (.DCB [DCB_W_BOTTOM_OF_SCRREG] -
			       .DCB [DCB_W_TOP_OF_SCRREG] + 1),
			      .DCB [DCB_W_NO_COLS],
 			      SMG$M_UP, COUNT) %;

    $SMG$VALIDATE_ARGCOUNT (2,7);

    $SMG$GET_DCB (.DISPLAY_ID, DCB);	! Get address of virtual display
					! control block.

    IF NOT NULLPARAMETER (LINE_ADV) AND
       ..LINE_ADV LSS 0
    THEN
	RETURN (SMG$_INVARG);		! positive advancing only

!+
! Select rendition code to use, based on whether one was provided by 
! caller.
!-

    $SMG$SET_REND_CODE (K_SET_ARG, K_COMP_ARG);

!+
! Get the length and address of the text string.
!-
    IF NOT (STATUS = LIB$ANALYZE_SDESC_R2 ( .TEXT;
					    STR_LEN,
					    STR_ADDR))
    THEN
	RETURN (.STATUS);

!+
! If the previous line written was the last line in the display, we
! did not scroll at the end of the operation.  (This would've always
! left {he last line blank - effectively the display would have one
! less useable line.)  If we're at the bottom, scroll up one before writing.  
!
!-

    $SMG$SET_SCROLLING (SCROLL_FLAG);

    IF .SCROLL_FLAG EQL 1
    THEN			! we're at the last line in the display
	BEGIN			! and display is full
        IF NOT NULLPARAMETER (LINE_ADV)
	THEN
	    BEGIN	! Arg present
	    IF ..LINE_ADV GTR 0 
            THEN			! positive line advancing		

	        $SCROLL_UP (..LINE_ADV)

	    ELSE
		BEGIN	! Negative line advance specified

		IF ..LINE_ADV LSS 0
		THEN
		    RETURN (SMG$_INVARG);	
					
		END	! Negative line advance specified
	    END		! Arg present

	ELSE	! Arg not present, default to 1 line

	    $SCROLL_UP (1)

	END;			! we're at the last line in the display

!+
! Blank out the line before writing new text.
!-

    BEGIN
    LOCAL
	START_INDEX;

    START_INDEX = $SMG$LINEAR (.DCB [DCB_W_CURSOR_ROW], .DCB [DCB_W_CURSOR_COL]);
    $SMG$BLANK_FILL_DCB ((.DCB [DCB_W_NO_COLS] - .DCB [DCB_W_CURSOR_COL] + 1),
			  .START_INDEX);

    END;

!+
! Reset the line characteristics in case the line was previously
! double high or wide.
!-

    BEGIN
    BIND 
	LINE_CHAR = .DCB [DCB_A_LINE_CHAR];
    MAP
	LINE_CHAR : VECTOR [,BYTE];
    LINE_CHAR [.DCB [DCB_W_CURSOR_ROW]] = 0;
    END;

!+
! Move the text string into our virtual display buffer.
! Note the cursor position is already correct for the call.
!-

    IF NOT ( STATUS = SMG$$PUT_TEXT_TO_BUFFER ( .DCB,
					       .REND_CODE,
				       	       .STR_LEN, 
					       .STR_ADDR,
					       IF NOT NULLPARAMETER (CHAR_SET)
					           THEN ..CHAR_SET 
					           ELSE SMG$C_ASCII,
					       WRAPPED_CHARS))
    THEN
	RETURN (.STATUS);


!+
! If all went well so far, we need to enter the <CR>,<LF> to form the 
! end of line.
!-

    DCB [DCB_W_CURSOR_COL] = 1;		! Effect of <CR>

!+
! Default to advancing one line if LINE_ADV is omitted.
!-

    IF NULLPARAMETER (LINE_ADV)
    THEN
	BEGIN			! line adv omitted
	IF .DCB [DCB_W_CURSOR_ROW] + 1 LEQ .DCB [DCB_W_BOTTOM_OF_SCRREG]
    	THEN
	    ! Just advance cursor row to next line
	    DCB [DCB_W_CURSOR_ROW] = .DCB [DCB_W_CURSOR_ROW] + 1
    	ELSE
	    BEGIN
	    $SMG$SET_SCROLLING (SCROLL_FLAG);
	    IF .SCROLL_FLAG EQL 1
	    THEN
		IF .DCB [DCB_W_CURSOR_ROW] NEQ .DCB [DCB_W_BOTTOM_OF_SCRREG]
		THEN
		    $SCROLL_UP (1);	! scroll if within scrolling region
	    IF .DCB [DCB_W_CURSOR_ROW] LEQ .DCB [DCB_W_BOTTOM_OF_SCRREG]
	    THEN
	        DCB [DCB_W_CURSOR_ROW] = .DCB [DCB_W_BOTTOM_OF_SCRREG];
	    DCB [DCB_V_FULL] = 1; ! remember that we used last line
	    END;

	END			! line_adv omitted

!+
! Take care of the requested line advancing.
!-

    ELSE
	BEGIN			!  line_adv specified
	IF ..LINE_ADV GTR 0
  	THEN
	    BEGIN		! upspacing requested
	    IF .DCB [DCB_W_CURSOR_ROW] + ..LINE_ADV LEQ
	       .DCB [DCB_W_BOTTOM_OF_SCRREG]
	    THEN
	    	! Just advance cursor row number
	    	DCB [DCB_W_CURSOR_ROW] = .DCB [DCB_W_CURSOR_ROW] 
				     + ..LINE_ADV
	    ELSE
		BEGIN		! scrolling up
	    	$SMG$SET_SCROLLING (SCROLL_FLAG);
	    	IF .SCROLL_FLAG EQL 1
	    	THEN
		    IF .DCB [DCB_W_CURSOR_ROW] NEQ .DCB [DCB_W_BOTTOM_OF_SCRREG]
		    THEN
		    	$SCROLL_UP (..LINE_ADV); ! scroll if w/in scroll region
		IF .DCB [DCB_W_CURSOR_ROW] LEQ .DCB [DCB_W_BOTTOM_OF_SCRREG]
	 	THEN
		    DCB [DCB_W_CURSOR_ROW] = .DCB [DCB_W_BOTTOM_OF_SCRREG];
	    	DCB [DCB_V_FULL] = 1; ! remember that we used last line
		END		! scrolling up
	    END;		! upspace action

    	END;			! line_adv specified

    !+
    ! If wrapping was requested and some characters overflowed the line,
    ! call ourself again with the remainder of the characters.
    !-

    IF .WRAPPED_CHARS NEQ 0 AND
       ((NOT NULLPARAMETER (LINE_ADV) AND ..LINE_ADV GTR 0) OR
       NULLPARAMETER (LINE_ADV))
    THEN
	BEGIN				! overflow chars
	IF (NOT NULLPARAMETER (WRAP_FLAG) AND
          ..WRAP_FLAG NEQ 0)
        THEN
	    BEGIN			! wrap set - recurse w/overflow
	    LOCAL
	    	STR_DESC : BLOCK [8, BYTE],
	    	C_SET;

    	    STR_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
	    STR_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	    STR_DESC [DSC$W_LENGTH] = .STR_LEN - .DCB [DCB_W_NO_COLS];
	    STR_DESC [DSC$A_POINTER] = .STR_ADDR + .DCB [DCB_W_NO_COLS];

            C_SET = SMG$C_ASCII;
	    IF NOT NULLPARAMETER( CHAR_SET )
	    THEN
	    	C_SET = ..CHAR_SET;

	    SMG$PUT_LINE (.DISPLAY_ID,
		       	  STR_DESC,
		          .LINE_ADV,
		          .RENDITION_SET,
		          .RENDITION_COMPLEMENT,
		          .WRAP_FLAG,
		          C_SET);
	    DONE = 0;
	    RETURN 1;		! to keep Bliss happy
	    END			! wrap set - recurse w/overflow
	ELSE
	    BEGIN		! wrap not set - truncation
	    !+
	    ! Wrap was not requested but there were overflow characters.
	    ! Put out diamond in last position to show truncation.
	    !-
	    IF .DCB [DCB_V_TRUNC_ICON]
	    THEN
		BEGIN
	    	IF NOT .DCB [DCB_V_FULL]
	    	THEN
	    	    DCB [DCB_W_CURSOR_ROW] = .DCB [DCB_W_CURSOR_ROW] - 1;
	    	DCB [DCB_W_CURSOR_COL] = .DCB [DCB_W_NO_COLS];

	    	SMG$$PUT_TEXT_TO_BUFFER (.DCB, 
				         .REND_CODE + ATTR_M_USER_GRAPHIC,
				         1, UPLIT (BYTE (DIAMOND)),
				         SMG$C_ASCII);

	    	IF NOT .DCB [DCB_V_FULL]
	    	THEN
	    	    DCB [DCB_W_CURSOR_ROW] = .DCB [DCB_W_CURSOR_ROW] + 1;
					! restore for next call
	    	DCB [DCB_W_CURSOR_COL] = 1;
		END;

	    DONE = 1;
	    END;			! wrap not set - truncation
	END
    ELSE
	DONE = 1;			! no wrap chars

    !+
    ! See if this change should be reflected on the screen.
    ! Even if we call SMG$PUT_LINE again, SMG$$CHECK_FOR_OUTPUT_DCB
    ! should be called only once.
    !-

    IF .DONE
    THEN
	BEGIN
	LOCAL
	    LINE_CHANGED;
	LINE_CHANGED = .DCB [DCB_W_CURSOR_ROW] -(IF NOT NULLPARAMETER (LINE_ADV)
			    			 THEN ABS (..LINE_ADV)
			    			 ELSE 0);
    	RETURN (SMG$$CHECK_FOR_OUTPUT_DCB (.DCB,
					   SMG$C_PUT_LINE,
					   .LINE_CHANGED));
	END
    ELSE
	RETURN 1;

    END;				! End of routine SMG$PUT_LINE
!<BLF/PAGE>

%SBTTL 'SMG$PUT_WITH_SCROLL - Scroll virtual display and output'
GLOBAL ROUTINE SMG$PUT_WITH_SCROLL ( 
                        DISPLAY_ID,
                        STRING,
                        DIRECTION,
			RENDITION_SET,
			RENDITION_COMPLEMENT,
			WRAP_FLAG,
			CHAR_SET
                                 ) =
!++
! FUNCTIONAL DESCRIPTION:
!
!       This routine scrolls a virtual display, if necessary,  and deposits 
!	the string in the opened area.  If no string is specified, the opened 
!	line is left blank.  This routine imitates a physical scrolling region
!	in a virtual display;  scrolling occurs when all the lines in the 
!	virtual display have been filled.  A new line is opened at the bottom 
!	of the virtual display for upscrolling, and at the top of the virtual 
!	display for downscrolling.
!
!	Treatment of text which exceeds the rightmost boundary of the display
!	depends on the setting of WRAP_FLAG.  If WRAP_FLAG is on, another line
!	scroll occurs and overflow characters are written in the new space.
!	If WRAP_FLAG is off, overflow characters are lost.
!
!	The internal display cursor position is left at the character
!	position following the last character written.
!
!	See SMG$INSERT_LINE for inserting lines at locations other than the
!	first or last line of a virtual display.
!
! CALLING SEQUENCE:
!
!       ret_status.wlc.v = SMG$PUT_WITH_SCROLL (
!                               DISPLAY_ID.rl.r
!                               [,STRING.rt.dx]
!				[,DIRECTION.rlu.r]
!				[,RENDITION_SET.rl.r]
!				[,RENDITION_COMPLEMENT.rl.r]
!				[,WRAP_FLAG.rl.r]
!				[,CHAR_SET.rl.r])
!
! FORMAL PARAMETERS:
!
!       DISPLAY_ID.rl.r         Display id of desired virtual display.
!
!       STRING.rt.dx            Optional.  String to be deposited in the opened
!                               line.  If omitted, a blank line is the default.
!
!       DIRECTION.rlu.r         Optional.  Direction to scroll.  Values:
!                                       SMG$M_UP   (up)   Default
!                                       SMG$M_DOWN (down)
!
!	RENDITION_SET.rl.r	Optional.  Each 1 bit attribute in this 
!				parameter causes the corresponding attribute
!				to be set in the display.  (See below for
!				list of settable attributes.)
!
!	RENDITION_COMPLEMENT.rl.r
!				Optional.  Each 1 bit attribute in this
!				parameter causes the corresponding attribute
!				to be complemented in the display.  (See
!				below for list of complementable
!				attributes.)
!
!	If the same bit is specified in both the RENDITION_SET parameter
!	and in the RENDITION_COMPLEMENT parameter, the application is
!	RENDITION_SET followed by RENDITION complement.  Using these two
!	parameters together the caller can exercise arbitrary and
!	independent control over each attribute on a single call.  On an
!	attribute by attribute basis he can cause the following
!	transformations:
!
!		SET	COMPLEMENT	Action
!		---	__________	______
!		0	0		Attribute unchanged.
!		1	0		Attribute set to "on"
!		0	1		Attribute set to complement of
!					current setting.
!		1	1		Attribute set to "off".
!
!
!	Attributes which can be manipulated in this manner are:
!
!	SMG$M_BLINK  displays characters blinking.
!	SMG$M_BOLD  displays characters in higher-than-normal 
!		      intensity.
!	SMG$M_REVERSE  displays characters in reverse video -- that is, 
!		      using the opposite default rendition of the 
!		      virtual display.
!	SMG$M_UNDERLINE  displays characters underlined.
!
!
!	WRAP_FLAG.rl.r	Optional.
!			= 0 means no wrap
!			= 1 means wrap
!			If omitted, no wrap is the default.
!
!	CHAR_SET.rl.r  	Optional.  Character set to use.
!			Choices are:
!				SMG$C_UNITED_KINGDOM
!				SMG$C_ASCII (default)
!				SMG$C_SPEC_GRAPHICS
!				SMG$C_ALT_CHAR
!				SMG$C_ALT_GRAPHICS
!
! IMPLICIT INPUTS:
!
!       NONE
!
! IMPLICIT OUTPUTS:
!
!       NONE
!
! COMPLETION STATUS:
!
!       SS$_NORMAL      Normal successful completion
!       LIB$_INVSTRDES  Invalid string descriptor
!       SMG$_INVDIS_ID  Invalid display id.
!       SMG$_WRONUMARG  Wrong number of arguments.
!                    or ACTION is given but RENDITION is not.
!       SMG$_INVARG     Unrecognized action code
!                    or Unrecognized rendition code
!
! SIDE EFFECTS:
!
!       NONE
!--
    BEGIN

    MACRO $SCROLL_UP (COUNT) =
	    SMG$$SCROLL_AREA (.DCB,
			      .DCB [DCB_W_TOP_OF_SCRREG],
			      .DCB [DCB_W_COL_START],
			      (.DCB [DCB_W_BOTTOM_OF_SCRREG] -
			       .DCB [DCB_W_TOP_OF_SCRREG] + 1),
			      .DCB [DCB_W_NO_COLS],
 			      SMG$M_UP, COUNT) %;

    MACRO $SCROLL_DOWN (COUNT) =
	    SMG$$SCROLL_AREA (.DCB,
			      .DCB [DCB_W_TOP_OF_SCRREG],
			      .DCB [DCB_W_COL_START],
			      (.DCB [DCB_W_BOTTOM_OF_SCRREG] -
			       .DCB [DCB_W_TOP_OF_SCRREG] + 1),
			      .DCB [DCB_W_NO_COLS],
 			      SMG$M_DOWN, COUNT) %;

    BUILTIN
	NULLPARAMETER;

    LITERAL
	K_STRING_ARG = 2,
	K_SET_ARG = 4,
	K_COMP_ARG = 5;

    LOCAL
	DONE,				! Done flag
	STATUS,				! Status of subroutine calls
	DCB : REF $DCB_DECL,		! Addr of display control block
	STR_LEN : INITIAL (0),		! Length of string
	STR_ADDR,			! Addr of string
	WORK_DIR,			! Working direction
	WRAP_CHARS : INITIAL (0),	! No. of overflow characters
	SCROLL_FLAG,			! Flag to scroll up, down, or neither
	REND_CODE;			! Rendition code from params

    $SMG$VALIDATE_ARGCOUNT (1, 7);

    $SMG$GET_DCB ( .DISPLAY_ID, DCB);	! Get address of display control
					! block

!+
! Validity check the arguments.
!-

    IF NOT NULLPARAMETER( DIRECTION )
    THEN
	BEGIN				! use caller's direction
	IF (..DIRECTION NEQ SMG$M_UP AND 
            ..DIRECTION NEQ SMG$M_DOWN)
    	THEN
	    RETURN (SMG$_INVARG)
	ELSE
	    WORK_DIR = ..DIRECTION;
	END
    ELSE
	WORK_DIR = SMG$M_UP;		! use default direction

    IF NOT NULLPARAMETER( CHAR_SET )
    THEN
	BEGIN
	CASE ..CHAR_SET FROM SMG$C_UNITED_KINGDOM TO SMG$C_ALT_GRAPHICS OF
	SET

	[SMG$C_UNITED_KINGDOM, SMG$C_ASCII, SMG$C_SPEC_GRAPHICS,
	 SMG$C_ALT_CHAR, SMG$C_ALT_GRAPHICS]:
		;
	[INRANGE, OUTRANGE]:
	  	RETURN (SMG$_INVARG);
	TES;
	END;

!+
! Check user's text, if any.
!-

    IF NOT NULLPARAMETER (STRING)
    THEN
	BEGIN				! use caller's text
	IF NOT (STATUS = LIB$ANALYZE_SDESC_R2 (.STRING; STR_LEN, STR_ADDR))
	THEN 
	    RETURN (.STATUS);
	END;				! end use caller's text

!+
! If the display is full and we're at the top or bottom line (depending on
! scrolling direction), then scroll to make a space.
!-

    $SMG$SET_SCROLLING (SCROLL_FLAG);

    IF .SCROLL_FLAG EQL 1 AND
       .WORK_DIR EQL SMG$M_UP
    THEN
	$SCROLL_UP (1)		! on bottom line
    ELSE
	IF .SCROLL_FLAG EQL 2 AND
	   .WORK_DIR EQL SMG$M_DOWN
	THEN
	    $SCROLL_DOWN (1);	! on top line

!+
! Reset the line characteristics in case the line was previously
! double high or wide.
!-

    BEGIN
    BIND 
	LINE_CHAR = .DCB [DCB_A_LINE_CHAR];
    MAP
	LINE_CHAR : VECTOR [,BYTE];
    LINE_CHAR [.DCB [DCB_W_CURSOR_ROW]] = 0;
    END;

!+
! Write text into the space.  SMG$$PUT_TEXT_TO_BUFFER checks for
! funny characters (tabs, etc) and also updates the cursor position.
!-

    IF .STR_LEN NEQ 0
    THEN
	BEGIN
    	$SMG$SET_REND_CODE (K_SET_ARG, K_COMP_ARG);

    	DCB [DCB_W_CURSOR_COL] = .DCB [DCB_W_COL_START];
				 	! set cursor for PUT_TEXT
    	SMG$$PUT_TEXT_TO_BUFFER (.DCB, .REND_CODE,
			         .STR_LEN,  
				 .STR_ADDR,
			         (IF NULLPARAMETER( CHAR_SET )
			              THEN SMG$C_ASCII
				      ELSE ..CHAR_SET),
				 WRAP_CHARS);
	END;

!+
! Update the cursor position.  Set bits in the DCB which may affect 
! future scrolling.
!-

    DCB [DCB_W_CURSOR_COL] = 1;

    CASE .WORK_DIR FROM SMG$M_UP TO SMG$M_DOWN OF
    SET
	[SMG$M_UP]:
	    BEGIN
	    IF .DCB [DCB_W_CURSOR_ROW] + 1 LEQ .DCB [DCB_W_BOTTOM_OF_SCRREG]
	    THEN
	        DCB [DCB_W_CURSOR_ROW] = .DCB [DCB_W_CURSOR_ROW] + 1
	    ELSE
		DCB [DCB_V_FULL] = 1;
	    END;
	
	[SMG$M_DOWN]:
	    BEGIN
	    IF .DCB [DCB_W_CURSOR_ROW] - 1 GEQ .DCB [DCB_W_TOP_OF_SCRREG]
	    THEN
	        DCB [DCB_W_CURSOR_ROW] = .DCB [DCB_W_CURSOR_ROW] - 1
	    ELSE
	  	DCB [DCB_V_FULL] = 1;
	    END;
    TES;

!+
! Check for overflow characters which should cause us to scroll 2 lines
! in order to output everything (if wrap requested).  
!-

    IF .WRAP_CHARS NEQ 0
    THEN
	BEGIN
    	IF NOT NULLPARAMETER( WRAP_FLAG ) AND
           ..WRAP_FLAG NEQ 0 		! wrap requested
    	THEN
	    BEGIN			! recurse until whole string output
	    LOCAL
	    	TEMP_DESC : BLOCK [8, BYTE],
	    	C_SET;

	    TEMP_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
	    TEMP_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	    TEMP_DESC [DSC$W_LENGTH] = .STR_LEN - .DCB [DCB_W_NO_COLS];
	    TEMP_DESC [DSC$A_POINTER] = .STR_ADDR +
				        .DCB [DCB_W_NO_COLS];

  	    C_SET = SMG$C_ASCII;
	    IF NOT NULLPARAMETER( CHAR_SET )
	    THEN
	    	C_SET = ..CHAR_SET;

	    !+
	    ! Notice that we always upscroll for wrapped text.  This is
	    ! because downscrolling would cause the last part of the line
	    ! to be displayed before the first part.  This approach may not
	    ! be perfect but it at least lines appear in a readable manner.
	    !-
	    IF .WORK_DIR EQL SMG$M_DOWN
	    THEN
	    	BEGIN
	    	LOCAL
		    OVERFLOW_LINE;
	    	OVERFLOW_LINE = .DCB [DCB_W_CURSOR_ROW] + 1;
	    	SMG$INSERT_LINE (.DISPLAY_ID,
			         OVERFLOW_LINE,
			         TEMP_DESC, %REF (SMG$M_DOWN),	
			         (IF NOT NULLPARAMETER (RENDITION_SET)
				      THEN .RENDITION_SET
				      ELSE 0),
				 (IF NOT NULLPARAMETER (RENDITION_COMPLEMENT)
				      THEN .RENDITION_COMPLEMENT
				      ELSE 0),
			         .WRAP_FLAG, C_SET);
	    	DCB [DCB_W_CURSOR_ROW] = .DCB [DCB_W_ROW_START];
	    	END
	    ELSE
	    	SMG$PUT_WITH_SCROLL (.DISPLAY_ID,
	    		 	     TEMP_DESC, %REF (SMG$M_UP),
			             (IF NOT NULLPARAMETER (RENDITION_SET)
				         THEN .RENDITION_SET
				         ELSE 0),
				     (IF NOT NULLPARAMETER (RENDITION_COMPLEMENT)
				         THEN .RENDITION_COMPLEMENT
				         ELSE 0),
			 	     .WRAP_FLAG,
			 	     C_SET);
	    DONE = 0;
	    RETURN 1;			! to keep Bliss happy
	    END
	ELSE
	    BEGIN
	    !+
	    ! Wrap was not requested but there were overflow characters.
	    ! Put out diamond in last position to show truncation.
	    !-
	    IF .DCB [DCB_V_TRUNC_ICON]
	    THEN
		BEGIN
	    	IF NOT .DCB [DCB_V_FULL]
	    	THEN
	    	    DCB [DCB_W_CURSOR_ROW] = .DCB [DCB_W_CURSOR_ROW] - 1;
	    	DCB [DCB_W_CURSOR_COL] = .DCB [DCB_W_NO_COLS];

	    	SMG$$PUT_TEXT_TO_BUFFER (.DCB, 
				         .REND_CODE + ATTR_M_USER_GRAPHIC,
				         1, UPLIT (BYTE (DIAMOND)),
				         SMG$C_ASCII);

	    	IF NOT .DCB [DCB_V_FULL]
	    	THEN
	    	    DCB [DCB_W_CURSOR_ROW] = .DCB [DCB_W_CURSOR_ROW] + 1;
					! restore for next call
		END;

	    DONE = 1;
	    END;
        END
    ELSE
	DONE = 1;			! no wrap chars

!+
! See if this change should be reflected on the screen.
! Even if SMG$PUT_WITH_SCROLL is called multiple times, call
! SMG$$CHECK_FOR_OUTPUT_DCB only once.
!-

    IF .DONE
    THEN
    	RETURN (SMG$$CHECK_FOR_OUTPUT_DCB (.DCB,
					   SMG$C_PUT_WITH_SCROLL))
    ELSE
	RETURN 1;

    END;		! End of routine SMG$PUT_WITH_SCROLL
!<BLF/PAGE>

%SBTTL 'SMG$READ_FROM_DISPLAY - Read text from virtual display'
GLOBAL ROUTINE SMG$READ_FROM_DISPLAY (
				      DISPLAY_ID,
				      RET_STRING,
				      SEARCH_STRING
				     ) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This procedure returns back to the caller a text string which
!	represents the current contents of a portion of a virtual
!	display line.  The current cursor position row determines which
!	line is to act as the source of the text.
!	If the SEARCH_STRING parameter is omitted, the contents of
!	the current line, from the current cursor column to the
!	right-most column, is returned in RET_STRING.
!
!	If SEARCH_STRING is provided, it is a list of character codes
!	that are to act as terminators in "back searching" -- the
!	process of determining the first character position to be
!	returned.  Each character in this string serves as a potential 
!	terminator.  If no terminator is encountered during "back
!	searching", the search is terminated by column 1 of the
!	virtual display.
!
!	Some examples:
!		Assume the line of text which contains the current
!	cursor contains the text:
!
!	"$ COPY/LOG FOO1 FOO2     "
!                 ^
!
!	Assume the cursor is positioned at the "G".
!
!	SMG$READ_FROM_DISPLAY (Display_id, OUTSTRING )
!	will return "G FOO1 FOO2     " since no terminator was supplied,
!	and hence no "back-searching" is performed.
!
!	SMG$READ_FROM_DISPLAY (Display_id, OUTSTRING, '/' )
!	will return "/LOG FOO1 FOO2     " since the specified terminator
!	was found prior to encountering column 1.
!
!	SMG$READ_FROM_DISPLAY (Display_id, OUTSTRING, '' )
!	will return "$ COPY/LOG FOO1 FOO2     " since the specified
!	terminator was not found prior to encountering column 1.
!
!	SMG$READ_FROM_DISPLAY (Display_id, OUTSTRING, '#' )
!	will return "$ COPY/LOG FOO1 FOO2     " since the specified
!	terminator was not seen before column 1 was encountered.
!
!	SMG$READ_FROM_DISPLAY (Display_id, OUTSTRING, "Y/" )
!	will return "/LOG FOO1 FOO2     " since, of the specified
!	terminators, the "/" was encountered before column 1 or any of
!	the other terminators.
!
!	NOTE: The "back-searching" begins at the current cursor column.
!	Hence,	if the text string is:
!	"$COPY/LOG FOO1 FOO2     " and cursor is positioned
!		       ^
!
!	SMG$READ_FROM_DISPLAY (Display_id, OUTSTRING, ' ' ) will
!	return " FOO2     ".
!
! CALLING SEQUENCE:
!
!	ret_status.wlc.v = SMG$READ_FROM_DISPLAY (
!				      DISPLAY_ID.rl.r,
!				      RET_STRING.wt.dx
!				      [,SEARCH_STRING.rt.dx])
!
! FORMAL PARAMETERS:
!
!	DISPLAY_ID.rl.r		Address of a display id.
!
!	RET_STRING.wt.dx	Address of a string descriptor,
!				describing the output string to be
!				produced.
!
!	SEARCH_STRING.rt.dx	[Optional].  If specified, the address
!				of a string descriptor, describing a
!				list of terminators which is to stop the
!				backward search in determining the
!				starting position of the string to be
!				returned.
!				If omitted, the returned string starts
!				at the current cursor column position --
!				no back searching is performed.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	SS$_NORMAL	Normal successful completion
!	LIB$_INVSTRDES	Invalid string descriptor
!	LIB$_INSVIRMEM	Insufficient virtual memory
!
! SIDE EFFECTS:
!
!	NONE
!--

    BEGIN
    BUILTIN
	NULLPARAMETER;

    LOCAL
	STATUS,			! Status of subroutine calls

	START_COL,		! Computed column number where source-
				! to-be-returned starts.

	START_LOC : REF VECTOR [1, BYTE], ! Address of text byte 
					  ! currently being inspected

	DCB : REF $DCB_DECL;	! Address of Display Control Block

!+
! Validate number of arguments and extract corresponding DCB address
!-
    $SMG$VALIDATE_ARGCOUNT (1, 3);
    $SMG$GET_DCB (.DISPLAY_ID, DCB)

    IF NOT NULLPARAMETER (SEARCH_STRING)
    THEN
	BEGIN	! Terminator string supplied
	LOCAL
	    T_LEN,		! Length of terminator string

	    T_ADDR : REF VECTOR [,BYTE];	! Address of 1st byte 
						! of terminator string

	!+
	! Extract length and address of 1st byte of terminator string.
	!-
	IF NOT (STATUS = LIB$ANALYZE_SDESC_R2 ( .SEARCH_STRING ;
						T_LEN, T_ADDR))
	THEN
	    RETURN (.STATUS);	! Can't access terminator string

	!+
	! Initialize pointer for searching.
	!-
	START_LOC = 
		(.DCB [DCB_W_CURSOR_ROW] - 1) * .DCB [DCB_W_NO_COLS] +
		 .DCB [DCB_W_CURSOR_COL] - 1 + .DCB [DCB_A_TEXT_BUF];

	START_COL = .DCB [DCB_W_CURSOR_COL];
	WHILE .START_COL NEQ 1
	DO
	    BEGIN	! Back search
	    !+
	    ! If text byte currently under inspection is one of the
	    ! the terminator bytes, exit from loop.
	    !-
	    INCR I FROM 0 TO .T_LEN -1
	    DO
		BEGIN	! Try to match terminator loop
		IF .START_LOC [0] EQL .T_ADDR [.I]
		THEN
		    BEGIN	! Terminator found exit path
		    RETURN (LIB$SCOPY_R_DX6 (
			.DCB [DCB_W_NO_COLS] - .START_COL + 1, ! # bytes
			.START_LOC,			       ! from
			.RET_STRING));			       ! To desc
		    END;	! Terminator found exit path
		END;	! Try to match terminator loop
	    !+
	    ! This character doesn't match any of the terminator.
	    ! Back up where we are searching by one column.
	    !-
	    START_COL = .START_COL -1;
	    START_LOC = .START_LOC -1;
	    END;	! Back search
	!+
	! If we fall out of loop above, none of the terminators were
	! found.  We need to return the whole line.
	!-
	RETURN (LIB$SCOPY_R_DX6 (
			.DCB [DCB_W_NO_COLS],	! # bytes
			.START_LOC,		! from
			.RET_STRING));		! To desc
	END	! Terminator string supplied

    ELSE

	BEGIN	! No terminator string supplied
	!+
	! Return string starting at current cursor column.
	!-
	START_COL = .DCB [DCB_W_CURSOR_COL];
	END;	! No terminator string supplied

!+
! Recalculate starting byte offset within text buffer for selected
! starting postion.
!-
    START_LOC  = (.DCB [DCB_W_CURSOR_ROW] - 1) * .DCB [DCB_W_NO_COLS]
		   + .START_COL - 1 + .DCB [DCB_A_TEXT_BUF];
!+
! Deliver selected text string to callers string.
!-
    RETURN (LIB$SCOPY_R_DX6 (
		.DCB [DCB_W_NO_COLS] - .START_COL + 1,	! # bytes
		.START_LOC,				! start address
		.RET_STRING));				! Dest. descr.
    END;		! End of routine SMG$READ_FROM_DISPLAY
!<BLF/PAGE>

%SBTTL 'SMG$RETURN_CURSOR_POS - Return current cursor position'
GLOBAL ROUTINE SMG$RETURN_CURSOR_POS (
                                   DISPLAY_ID,
                                   ROW_NUM,
                                   COL_NUM
                                  ) =
!++
! FUNCTIONAL DESCRIPTION:
!
!       Returns the current cursor row and column position in the
!	specified virtual display.
!
! CALLING SEQUENCE:
!
!       ret_status.wlc.v = SMG$RETURN_CURSOR_POS (
!                                       DISPLAY_ID.rl.r,
!                                       ROW_NUM.wl.r,
!                                       COL_NUM.wl.r)
!
! FORMAL PARAMETERS:
!
!       DISPLAY_ID.rl.r Display id of desired display.
!
!       ROW_NUM.wl.r  	Returned row position.
!
!       COL_NUM.w.r     Returned column position.
!
! IMPLICIT INPUTS:
!
!       NONE
!
! IMPLICIT OUTPUTS:
!
!       NONE
!
! COMPLETION STATUS:
!
!       SS$_NORMAL      Normal successful completion
!       SMG$_WRONUMARG  Wrong number arguments.
!	SMG$_INVDIS_ID	Invalid display Id.
!
! SIDE EFFECTS:
!
!       NONE
!--
    BEGIN
    LOCAL
	DCB : REF $DCB_DECL;		! Addr. of display control block

    $SMG$VALIDATE_ARGCOUNT (3,3);	! Check for right no. of args

    $SMG$GET_DCB ( .DISPLAY_ID, DCB);	! Get address of display control
					! block

    .ROW_NUM = .DCB [DCB_W_CURSOR_ROW];
    .COL_NUM = .DCB [DCB_W_CURSOR_COL];

    RETURN (SS$_NORMAL);
    END;			! End of routine SMG$RETURN_CURSOR_POS

%SBTTL 'SMG$SCROLL_DISPLAY_AREA - Scroll rectangular area in a virtual display'
GLOBAL ROUTINE SMG$SCROLL_DISPLAY_AREA (
                                   DISPLAY_ID,
                                   START_ROW,
                                   START_COL,
				   HEIGHT,
				   WIDTH,
				   DIRECTION,
				   COUNT
                                  ) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine scrolls the contents of a rectangular area in a virtual
!       display in the specified direction for the specified count.  By default
!	the scrolling rectangle is the 'scrolling region' in the virtual
!	display.
!	
!	The default direction is 'up' and the default number of units is 1.
!
!	The scrolling rectangle must lie entirely
!	within the virtual display, else SMG$_INVARG is returned.
!	
!	If the number of units to be scrolled exceeds the size of the rectangle
!	in that direction the text within the rectangle simply "disappears"
!	at the rectangle boundary.  Locations emptied by this operation are
!	set to spaces.
!
!	The cursor position is left at START_ROW, START_COL.
!
! CALLING SEQUENCE:
!
!       ret_status.wlc.v = SMG$SCROLL_DISPLAY_AREA (
!                                       	DISPLAY_ID.rl.r
!                                       	[,START_ROW.rl.r, START_COL_NUM.rl.r]
!						[,HEIGHT.rl.r]
!						[,WIDTH.rl.r]
!						[,DIRECTION.rl.r]
!						[,COUNT.rl.r]
!
! FORMAL PARAMETERS:
!
!       DISPLAY_ID.rl.r Display id of desired display.
!
!	START_ROW.rl.r	Optional.  Row in which scrolling region starts.
!			Defaults to row 1.
!
!	START_COL.rl.r	Optional.  Column in which scrolling region starts.
!			Defaults to column 1.
!
!	HEIGHT.rl.r	Optional.  Height of scrolling region.  Defaults to
!			the height of the scrolling region in the virtual 
!			display.
!
!	WIDTH.rl.r	Optional.  Width of scrolling region.  Defaults to
!			the width of the scrolling region in the virtual 
!			display.
!
!	DIRECTION.rl.r	Optional.  Direction in which to scroll.  Defaults
!			to SMG$M_UP.  Choices are:	SMG$M_UP
!							SMG$M_DOWN
!							SMG$M_RIGHT
!							SMG$M_LEFT
!
!	COUNT.rl.r	Optional.  Number of positions to scroll.  Defaults
!			to 1 line.
!
! IMPLICIT INPUTS:
!
!       NONE
!
! IMPLICIT OUTPUTS:
!
!       NONE
!
! COMPLETION STATUS:
!
!       SS$_NORMAL      Normal successful completion
!       SMG$_WRONUMARG  Wrong number arguments.
!	SMG$_INVDIS_ID	Invalid display Id.
!
! SIDE EFFECTS:
!
!       NONE
!--
    BEGIN
    LOCAL
	DCB : REF $DCB_DECL,		! Addr. of display control block
	LOCAL_ROW,			! working start row
	LOCAL_COL,			! working start column
	LOCAL_HEIGHT,			! working height
	LOCAL_WIDTH,			! working width
	LOCAL_DIR,			! working direction
	LOCAL_COUNT,			! working count
	STATUS;				! status of called routine

    BUILTIN
	NULLPARAMETER;

    $SMG$VALIDATE_ARGCOUNT (1,7);

    $SMG$GET_DCB ( .DISPLAY_ID, DCB);	! Get address of display control
					! block

!+
! Validate arguments and fill in local variables.
!-

    IF NOT NULLPARAMETER (START_ROW) AND
       NOT NULLPARAMETER (START_COL)
    THEN
	BEGIN			! use caller's row, col
	$SMG$VALIDATE_ROW_COL (..START_ROW, ..START_COL);
	LOCAL_ROW = ..START_ROW;
	LOCAL_COL = ..START_COL;
	END
    ELSE
	BEGIN			! use default row, col
	LOCAL_ROW = .DCB [DCB_W_TOP_OF_SCRREG];
	LOCAL_COL = 1;
	END;

    LOCAL_HEIGHT = .DCB [DCB_W_BOTTOM_OF_SCRREG] -
		   .LOCAL_ROW + 1; ! init to default

    IF NOT NULLPARAMETER (HEIGHT)
    THEN
	BEGIN			! check caller's heigth
	IF ..HEIGHT + .LOCAL_ROW - 1 LSS .DCB [DCB_W_ROW_START] OR
	   ..HEIGHT + .LOCAL_ROW - 1 GTR .DCB [DCB_W_NO_ROWS]
	THEN 
	    RETURN (SMG$_INVARG)
	ELSE
	    LOCAL_HEIGHT = ..HEIGHT;
	END;

    LOCAL_WIDTH = .DCB [DCB_W_NO_COLS]; ! init to default

    IF NOT NULLPARAMETER (WIDTH)
    THEN
	BEGIN			! check caller's width
	IF ..WIDTH + .LOCAL_COL -1 LSS .DCB [DCB_W_COL_START] OR
	   ..WIDTH + .LOCAL_COL -1 GTR .DCB [DCB_W_NO_COLS]
	THEN
	    RETURN (SMG$_INVARG)
	ELSE
	    LOCAL_WIDTH = ..WIDTH;
	END;

    LOCAL_DIR = SMG$M_UP;

    IF NOT NULLPARAMETER (DIRECTION)
    THEN
	BEGIN			! check caller's direction
	CASE ..DIRECTION FROM SMG$M_UP TO SMG$M_LEFT OF
	SET
	    [SMG$M_UP, SMG$M_DOWN, SMG$M_RIGHT, SMG$M_LEFT]:
		LOCAL_DIR = ..DIRECTION;

	    [INRANGE,OUTRANGE]:
		RETURN (SMG$_INVARG);
	TES;
        END;

    LOCAL_COUNT = 1;		! init to default

    IF NOT NULLPARAMETER (COUNT)
    THEN
	BEGIN			! check caller's count
	IF ..COUNT GTR 0 
	THEN
	    LOCAL_COUNT = ..COUNT
	ELSE
	    RETURN (SMG$_INVARG);
	END;

!+
! Now all the arguments are set up.  Call an internal routine to do
! the real work.
!-

    STATUS = SMG$$SCROLL_AREA (.DCB, 
			       .LOCAL_ROW, .LOCAL_COL,
			       .LOCAL_HEIGHT, .LOCAL_WIDTH,
			       .LOCAL_DIR, .LOCAL_COUNT);
    IF NOT (.STATUS) THEN RETURN (.STATUS);

!+
! The internal routine did not reset the cursor position.  Do that here.
!-

    DCB [DCB_W_CURSOR_ROW] = .LOCAL_ROW;
    DCB [DCB_W_CURSOR_COL] = .LOCAL_COL;

!+
! Turn off scrolling since we have moved the cursor.
!-

    DCB [DCB_V_FULL] = 0;

!+
! See if this change should be reflected on the screen immediately.
!-

    RETURN (SMG$$CHECK_FOR_OUTPUT_DCB (.DCB,
					SMG$C_SCROLL_DISPLAY_AREA));
    END;			! End of routine SMG$SCROLL_DISPLAY_AREA
!<BLF/PAGE>

%SBTTL 'SMG$SET_CURSOR_ABS - Set absolute cursor position'
GLOBAL ROUTINE SMG$SET_CURSOR_ABS (
                                   DISPLAY_ID,
                                   ROW_NUM,
                                   COL_NUM
                                  ) =
!++
! FUNCTIONAL DESCRIPTION:
!
!       Position cursor to absolute row and column specified.
!	Return SMG$_INVROW or SMG$_INVCOL if either position is outside
!	of the virtual display area.
!
! CALLING SEQUENCE:
!
!       ret_status.wlc.v = SMG$SET_CURSOR_ABS (
!                                       DISPLAY_ID.rl.r
!                                       [,ROW_NUM.rl.r]
!                                       [,COL_NUM.rl.r])
!
! FORMAL PARAMETERS:
!
!       DISPLAY_ID.rl.r Display id of desired display.
!
!       ROW_NUM.rl.r  	Row position.  If not supplied, row number is 
!			not altered from current position.
!
!       COL_NUM.rl.r    Column position.  If not supplied, column number
!		        is not altered from current position.
!
! IMPLICIT INPUTS:
!
!       NONE
!
! IMPLICIT OUTPUTS:
!
!       NONE
!
! COMPLETION STATUS:
!
!       SS$_NORMAL      Normal successful completion
!	SMG$_INVROW	Invalid row number
!	SMG$_INVCOL	Invalid column number
!       SMG$_WRONUMARG  Wrong number arguments.
!	SMG$_INVDIS_ID	Invalid display Id.
!
! SIDE EFFECTS:
!
!       NONE
!--
    BEGIN
    BUILTIN
	NULLPARAMETER;

    LOCAL
	STATUS,				! Status of subroutine calls
	ROW,				! Working row number
	COL,				! Working column number
	DCB : REF $DCB_DECL;		! Addr. of display control block

    $SMG$VALIDATE_ARGCOUNT (1,3);

    $SMG$GET_DCB ( .DISPLAY_ID, DCB);	! Get address of display control
					! block


    ROW = (IF NOT NULLPARAMETER (ROW_NUM) THEN ..ROW_NUM
				          ELSE .DCB [DCB_W_CURSOR_ROW]);

    COL = (IF NOT NULLPARAMETER (COL_NUM) THEN ..COL_NUM
				          ELSE .DCB [DCB_W_CURSOR_COL]);

!+
! Make sure resulting position is still within the virtual display.
!-
!+
! Validity check row and column specified
!-
    $SMG$VALIDATE_ROW_COL ( .ROW, .COL);

!+
! Ok, set them.
!-
    DCB [DCB_W_CURSOR_ROW] = .ROW;
    DCB [DCB_W_CURSOR_COL] = .COL;

!+
! We have altered the cursor position so obviously sequential output
! has been interupted.  Turn off the scrolling bit.
!-

    DCB [DCB_V_FULL] = 0;

    RETURN (SMG$$CHECK_FOR_OUTPUT_DCB (.DCB,
					SMG$C_SET_CURSOR_ABS));
    END;			! End of routine SMG$SET_CURSOR_ABS
!<BLF/PAGE>

%SBTTL 'SMG$SET_CURSOR_REL - Set relative cursor position'
GLOBAL ROUTINE SMG$SET_CURSOR_REL (
                                   DISPLAY_ID,
                                   DELTA_ROW,
                                   DELTA_COLUMN
                                  ) =
!++
! FUNCTIONAL DESCRIPTION:
!
!       Position cursor to relative row and column specified --
!       relative to current position.
!	If adding DELTA_ROW or DELTA_COLUMN takes us outside of the
!	virtual display, return SMG$_INVROW or SMG$_INVCOL respectively.
!
!
! CALLING SEQUENCE:
!
!       ret_status.wlc.v = SMG$SET_CURSOR_REL (
!                                       DISPLAY_ID.rl.r
!                                       [,DELTA_ROW.rl.r]
!                                       [,DELTA_COLUMN.rl.r])
!
! FORMAL PARAMETERS:
!
!       DISPLAY_ID.rl.r         Display id of desired display.
!
!       DELTA_ROW.rl.r  	Delta row position (-delta, +delta)
!                               If not supplied, row number is not
!                               altered from current position.
!
!       DELTA_COLUMN.rl.r       Delta_column position (-delta, +delta)
!                               If not supplied, column number is not
!                               altered from current position.
!
!
! IMPLICIT INPUTS:
!
!       NONE
!
! IMPLICIT OUTPUTS:
!
!       NONE
!
! COMPLETION STATUS:
!
!       SS$_NORMAL      Normal successful completion
!       SMG$_INVROW     When delta_column is added to current column 
!       SMG$_INVCOL     and/or delta_row is added to current row, 
!                       resulting row or column is outside virtual 
!                       display.
!       SMG$_WRONUMARG  Wrong number arguments.
!
! SIDE EFFECTS:
!
!       NONE
!--
    BEGIN
    BUILTIN
	NULLPARAMETER;

    LOCAL
	STATUS,		! Status of subroutine calls
	D_ROW,		! Working delta row
	D_COL,		! Working delta column
	DCB : REF $DCB_DECL;	! Addr. of display control block

    $SMG$VALIDATE_ARGCOUNT (1,3);

    $SMG$GET_DCB ( .DISPLAY_ID, DCB);	! Get address of display control
					! block


    D_ROW = (IF NOT NULLPARAMETER (DELTA_ROW) THEN ..DELTA_ROW
				              ELSE 0);

    D_COL = (IF NOT NULLPARAMETER (DELTA_COLUMN) THEN ..DELTA_COLUMN
				                 ELSE 0);

!+
! Make sure resulting position is still within the virtual display.
!-
    IF .DCB [DCB_W_CURSOR_ROW] + .D_ROW LSS 1  OR
       .DCB [DCB_W_CURSOR_ROW] + .D_ROW GTR .DCB [DCB_W_NO_ROWS]
    THEN
	RETURN (SMG$_INVROW);

    IF .DCB [DCB_W_CURSOR_COL] + .D_COL LSS 1  OR
       .DCB [DCB_W_CURSOR_COL] + .D_COL GTR .DCB [DCB_W_NO_COLS]
    THEN
	RETURN (SMG$_INVCOL);

!+
! Ok, set them.
!-
    DCB [DCB_W_CURSOR_ROW] = .DCB [DCB_W_CURSOR_ROW] + .D_ROW;
    DCB [DCB_W_CURSOR_COL] = .DCB [DCB_W_CURSOR_COL] + .D_COL;

!+
! Turn off scrolling.
!-
    
    DCB [DCB_V_FULL] = 0;

    RETURN (SMG$$CHECK_FOR_OUTPUT_DCB (.DCB,
					SMG$C_SET_CURSOR_REL));
    END;			! End of routine SMG$SET_CURSOR_REL
!<BLF/PAGE>

END			! End of module SMG$DISPLAY_CHANGE

ELUDOM
