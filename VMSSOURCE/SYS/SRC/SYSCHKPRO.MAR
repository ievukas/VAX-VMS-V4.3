	.TITLE	SYSCHKPRO - CENTRAL PROTECTION CHECK ALGORITHM
	.IDENT	'V04-000'
	.ENABL	DBG

;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
; FACILITY:	VAX/VMS Exec
;
; ABSTRACT:
;
;	This module contains the routines that implement the protection
;	check algorithms used within VMS (UIC protection, Access Control
;	Lists, Classification mask check, etc.)
;
; ENVIRONMENT:
;
;	VAX/VMS Exec.
;
;--
;
; AUTHOR:  L. Mark Pilant,		CREATION DATE:	18-Feb-1983
;
;	(With thanks to A. Goldstein)
;
; MODIFIED BY:
;
;	V03-023	LMP0293		L. Mark Pilant,		2-Aug-1984  12:16
;		Clear the local ACL_PRESENT flag if SS$_IVACL is returned
;		from EXE$CHECKACL, so that EXE$GET_AUDIT is not called.
;
;	V03-022	LMP0286		L. Mark Pilant,		26-Jul-1984  12:49
;		Fix a broken intermediate branch.
;
;	V03-021	ACG0440		Andrew C. Goldstein,	23-Jul-1984  13:42
;		Add classification valid flag to ORB; use GRPPRV only with
;		UIC format owner ID
;
;	V03-020	LMP0264		L. Mark Pilant,		26-Jun-1984  13:49
;		Check for SS$_IVACL returning from EXE$CHECKACL.
;
;	V03-019	LMP0249		L. Mark Pilant,		7-May-1984  8:51
;		Modify EXE$GET_AUDIT to handle an ACL queue correctly.
;
;	V03-018	LMP0245		L. Mark Pilant,		1-May-1984  16:57
;		Remove the reference to R10 within the ACL segment scanning
;		loop.  This bug caused the segment count to be used as the
;		CHPCTL block address.
;
;	V03-017	LMP0242		L. Mark Pilant,		27-Apr-1984  14:19
;		Allow the BYPASS privilege to override SS$_IVACL.
;
;	V03-016	LMP0239		L. Mark Pilant,		23-Apr-1984  9:15
;		Add a common return point so that the block allocated from
;		the P1 lookaside list may be returned.
;
;	V03-015	TMH0015		Tim Halvorsen		14-Apr-1984
;		Fix V03-014 to define entry point as EXE$CHKPRO, not SYS$CHKPRO.
;
;	V03-014	LMP0221		L. Mark Pilant,		7-Apr-1984  14:55
;		Add support for the new internal interface.
;
;	V03-013	LMP0215		L. Mark Pilant,		21-Mar-1984  14:01
;		Make sure that the SYSTEM and OWNER protection fields have
;		control access when going from a word to the vector.
;
;	V03-012	LMP0214		L. Mark Pilant,		21-Mar-1984  11:51
;		Change EXE$CHECKPROT_16 to use the address of the protection
;		word, rather that the protection word itself.
;
;	V03-011	LMP0199		L. Mark Pilant,		28-Feb-1984  12:40
;		Correctly handle an ACL segment padded with zero.
;
;	V03-010	ACG0392		Andrew C. Goldstein,	19-Jan-1984  21:21
;		Add match-all identifier
;
;	V03-009	ACG0394		Andrew C. Goldstein,	24-Jan-1984  19:55
;		Fix loop exit in ACL check (bug in ACG0384)
;
;	V03-008	ACG0384		Andrew C. Goldstein,	19-Dec-1983  16:22
;		Allow SYSTEM and OWNER access to override ACL
;
;	V03-007	LMP0177		L. Mark Pilant,		7-Dec-1983  12:42
;		Enable the conditional non-discretionary classification
;		check by uncommenting the line.  Also change the location
;		of the flag from EXE$GL_FLAGS to EXE$GL_DYNAMIC_FLAGS.
;
;	V03-006	ACG0354		Andrew C. Goldstein,	29-Aug-1983  14:33
;		General code cleanup and tightening, add CONTROL access
;		via READALL privilege. Remove CHP$_ACCESSRIGHTS item.
;
;	V03-005	LMP0145		L. Mark Pilant,		25-Aug-1983  11:34
;		Ignore default ACEs during an ACL protection check.
;
;	V03-004	LMPBUILD	L. Mark Pilant,		28-Jun-1983  11:32
;		Fix a broken branch.
;
;	V03-003	LMP0115		L. Mark Pilant,		19-May-1983  10:38
;		Miscellaneous fixes.
;
;	V03-002	LMP0109		L. Mark Pilant,		30-Apr-1983  1:58
;		Add logic to enable the access allowed to be returned.
;		Also, several miscellaneous minor bugs were fixed.
;
;	V03-001	LMP0106		L. Mark Pilant,		26-Apr-1983  16:39
;		Change register usage in EXE$SEARCH_RIGHT.
;
;**

	.SBTTL	LIBRARY STRUCTURE DEFINITIONS AND MACROS

	$ACEDEF			; access control list entry
	$ACLDEF			; ACL segment structure offsets
	$ARBDEF			; Agent's rights block
	$ARMDEF			; access bitmask definitions
	$CHPDEF			; service item codes
	$CHPCTLDEF		; CHKPRO control block offsets
	$CHPRETDEF		; $CHKPRO return arg block offsets
	$CLSDEF			; non-discretionary classification mask
	$DSCDEF			; string descriptor
	$IPLDEF			; Priority levels
	$ORBDEF			; Object's rights block
	$PCBDEF			; process control block
	$PRDEF			; Processor registers
	$PRBDEF			; internal structure protection block
	$PRVDEF			; privilege bits
	$PSLDEF			; PSL fields
	$SSDEF			; system statue codes
	$UICDEF			; UIC and identifier format

; Macro to generate the necessary table entries based upon the item code.

	.MACRO	TABLE_ENTRY	CODE, SIZE, INDEX, OFFSET
	TMP_PC=	.
	.=	MIN_SIZE_TABLE+CODE
	.BYTE	SIZE
	.=	INDEX_TABLE+CODE
	.BYTE	INDEX
	.=	OFFSET_TABLE+<CODE*4>
	.LONG	0
	.=	OFFSET_TABLE+<CODE*4>+INDEX
	.BYTE	OFFSET
	.=	TMP_PC
	.ENDM	TABLE_ENTRY;	CODE, SIZE, INDEX, OFFSET

	.SBTTL	LOCAL CONSTANTS AND FLAGS

	MAX_ACL_DESC=	20		; maximum number of acl segment descrs
	MAX_RIGHT_DESC=	11		; maximum number of rights segment descrs
					; (actually one less, since the list
					; must be zero terminated)
	MAX_CHP_CODE=	CHP$_MAX_CODE-1

; Define the index values used to determine the address of the local
; protection structure and the offset into that structure.

	ARB_INDEX=	0
	ORB_INDEX=	1
	CHPCTL_INDEX=	2
	CHPRET_INDEX=	3

; Define the local block used when processing the user's item list.

	STRUCT_ADDR=	0		; Protection structure address table
	LOCAL_ARB=	16		; Agent's rights block
	ASSUME	ARB$C_HEADER EQ ARB$L_RIGHTSLIST+ARB$S_RIGHTSLIST
	RIGHTS_LIST=	LOCAL_ARB+ARB$L_RIGHTSLIST	; Agent's rights list
	LOCAL_ORB=	RIGHTS_LIST+<MAX_RIGHT_DESC*4>	; Object's rights block
	LOCAL_CHPCTL=	LOCAL_ORB+ORB$C_LENGTH	; Control block
	LOCAL_CHPRET=	LOCAL_CHPCTL+CHPCTL$C_LENGTH	; Return arg block
	PRIVS_USED=	LOCAL_CHPRET+CHPRET$C_LENGTH	; Privs used storage
	ACL_LIST=	PRIVS_USED+4	; ACL segment descr list
	RIGHTS_DESC=	ACL_LIST+<MAX_ACL_DESC*DSC$C_S_BLN>	; Rights list descriptors

	LOCAL_LENGTH=	RIGHTS_DESC+<MAX_RIGHT_DESC*DSC$C_S_BLN>
					; Length of the local storage block
	ASSUME	LOCAL_LENGTH LE 512	; Must be less than a page

; Local flags used in EXE$CHKPRO_INT.

	CHKPRO_V_ACL_PRESENT=	0		; ACL is present
	CHKPRO_V_INTERNAL=	1		; internal vs system service entry
	CHKPRO_V_NO_CHPRET=	2		; CHPRET block not supplied

	CHKPRO_M_ACL_PRESENT=	1@CHKPRO_V_ACL_PRESENT	; ACL is present
	CHKPRO_M_INTERNAL=	1@CHKPRO_V_INTERNAL	; internal vs system service entry
	CHKPRO_M_NO_CHPRET=	1@CHKPRO_V_NO_CHPRET	; CHPRET block not supplied

	.SBTTL	ITEM CODE TABLES

	.PSECT	Y$EXEPAGED

; The following table defines the minimum sizes for the various item codes.

MIN_SIZE_TABLE:
	.BLKB	CHP$_MAX_CODE

; The following table define the index associated with the local protection
; structure, based upon the item code.

INDEX_TABLE:
	.BLKB	CHP$_MAX_CODE

; The following table defines the offsets into the various protection
; structures.  The table is organized such that there are four offset bytes.
; These are for the ARB, ORB, CHKCTL, and CHPRET blocks in that order.

OFFSET_TABLE:
	.BLKB	CHP$_MAX_CODE*4

; Now fill the tables defined above.

	TABLE_ENTRY	CHP$_END,	0,	0,		0
	TABLE_ENTRY	CHP$_ACCESS,	4,	CHPCTL_INDEX,	CHPCTL$L_ACCESS
	TABLE_ENTRY	CHP$_FLAGS,	4,	CHPCTL_INDEX,	CHPCTL$L_FLAGS
	TABLE_ENTRY	CHP$_PRIV,	8,	ARB_INDEX,	ARB$Q_PRIV
	TABLE_ENTRY	CHP$_ACMODE,	1,	CHPCTL_INDEX,	CHPCTL$B_MODE
	TABLE_ENTRY	CHP$_ACCLASS,	20,	ARB_INDEX,	ARB$R_CLASS
	TABLE_ENTRY	CHP$_RIGHTS,	8,	ARB_INDEX,	ARB$L_RIGHTSLIST
	TABLE_ENTRY	CHP$_ADDRIGHTS,	8,	ARB_INDEX,	ARB$L_RIGHTSLIST
	TABLE_ENTRY	CHP$_MODE,	1,	ORB_INDEX,	ORB$B_MODE
	TABLE_ENTRY	CHP$_MODES,	8,	ORB_INDEX,	ORB$Q_MODE_PROT
	TABLE_ENTRY	CHP$_MINCLASS,	20,	ORB_INDEX,	ORB$R_MIN_CLASS
	TABLE_ENTRY	CHP$_MAXCLASS,	20,	ORB_INDEX,	ORB$R_MAX_CLASS
	TABLE_ENTRY	CHP$_OWNER,	4,	ORB_INDEX,	ORB$L_OWNER
	TABLE_ENTRY	CHP$_PROT,	2,	ORB_INDEX,	ORB$W_PROT
	TABLE_ENTRY	CHP$_ACL,	4,	ORB_INDEX,	ORB$L_ACL_DESC
	TABLE_ENTRY	CHP$_AUDITNAME,	1,	CHPRET_INDEX,	CHPRET$W_AUDITLEN
	TABLE_ENTRY	CHP$_ALARMNAME,	1,	CHPRET_INDEX,	CHPRET$W_ALARMLEN
	TABLE_ENTRY	CHP$_MATCHEDACE,4,	CHPRET_INDEX,	CHPRET$W_MATCHED_ACELEN
	TABLE_ENTRY	CHP$_PRIVUSED,	4,	CHPRET_INDEX,	CHPRET$L_PRIVS_USED

	.SBTTL	EXE$CHKPRO - GENERAL PROTECTION ALGORITHM

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine implements the $CHKPRO system service, which
;	serves as a centralized protection check. Depending on the
;	items supplied, the following forms of protection check
;	are available:
;		access mode
;		non-discretionary classification
;		access control list
;		simple SOGW mask
;		audit log and alarm
;
; CALLING SEQUENCE:
;	EXE$CHKPRO (ITEM_LIST)
;
; INPUT PARAMETERS:
;	ITEM_LIST: address of item descriptor list
;
; IMPLICIT INPUTS:
;	SCH$GL_CURPCB: PCB address of process
;	previous access mode (access mode of caller)
;
; OUTPUT PARAMETERS:
;	ITEM_LIST: address of item descriptor list
;
; IMPLICIT OUTPUTS:
;	NONE
;
; ROUTINE VALUE:
;	SS$_NORMAL: access granted
;	SS$_NOPRIV: access denied
;	SS$_ACCVIO: item list or item buffers inaccessible
;
; SIDE EFFECTS:
;	NONE
;
;--

; Define the offsets into the routine argument list

	CHKPRO_ARGCOUNT=	0
	CHKPRO_ITMLST=		4

	.SBTTL	$CHKPRO SYSTEM SERVICE INITIAL SETUP

; Within the main body of the protection checking routine (i.e., the item
; descriptor scanner), the following register conventions are used:
;
;	R11 -	address of the local storage block
;	R10 -	address of the current item list descriptor
;	R9 -	return length storage address
;	R8 -	input/output buffer address
;	R7 -	size of the input/output buffer
;	R6 -	index into rights descriptor list
;	R5 -	address for item in local protection structure

	.ENABLE LSB

	.ENTRY	EXE$CHKPRO,^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>

; Local storage block from P1 lookaside list.

	REMQUE	@CTL$GL_KRPFL,R11	; Else allocate from P1 lookaside list
	BVC	5$			; Xfer if able to get one
	BUG_CHECK	KRPEMPTY	; Else come to a screeching halt
;
; Set up the initial defaults in the local protection structures.
;
5$:	MOVC5	#0,(SP),#0,#LOCAL_LENGTH,(R11)	; Initially clear out the block

; Set up ARB defaults.

	MOVL	@#SCH$GL_CURPCB,R0	; get current PCB address
	MOVC3	#ARB$C_HEADER,@PCB$L_ARB(R0),LOCAL_ARB(R11)	; Copy minimal ARB
	MOVAB	LOCAL_ARB(R11),R0	; Set address of protection structure
	MOVL	R0,STRUCT_ADDR(R11)	; Save ARB address for later
	CLRL	R6			; Reset rights list segment index
10$:	TSTL	ARB$L_RIGHTSLIST(R0)[R6]	; End of the list?
	BEQL	15$			; Xfer if so, index now set
	INCL	R6			; Else up the index
	BRB	10$			; And try the next one

; Set up ORB defaults.

15$:	MOVAB	LOCAL_ORB(R11),R0	; Set address of protection structure
	MOVL	R0,STRUCT_ADDR+4(R11)	; Save ORB address for later
	MOVL	#4,ORB$B_MODE(R0)	; Default access mode of object

; Set up CHPCTL block defaults.

	MOVAB	LOCAL_CHPCTL(R11),R0	; Set address of protection structure
	MOVL	R0,STRUCT_ADDR+8(R11)	; Save CHPCTL address for later
	MOVL	#CHPCTL$M_READ!CHPCTL$M_WRITE,CHPCTL$L_FLAGS(R0)
					; allowing for read and write access
	MOVPSL	R1			; Get the current PSL
	EXTZV	#PSL$V_PRVMOD,#PSL$S_PRVMOD,R1,CHPCTL$B_MODE(R0)
					; get accessor mode

; Set up the CHPRET block defaults.

	MOVAB	LOCAL_CHPRET(R11),R0	; Set address of protection structure
	MOVL	R0,STRUCT_ADDR+12(R11)	; Save CHPRET address for later
	MOVAB	PRIVS_USED(R11),CHPRET$L_PRIVS_USED(R0)	; Where to return privs used

; Start the item list processing.

	MOVL	CHKPRO_ITMLST(AP),R10	; set the address of the item list
	IFRD	#4,(R10),GET_ITEM	; probe first longword of item list

; Error returns.

RETURN_ACCVIO:
	MOVL	#SS$_ACCVIO,R0		; set error status
	BRW	RETURN_P1_BLOCK		;   and return

BADPARAM:
	MOVL	#SS$_BADPARAM,R0	; set status
	BRW	RETURN_P1_BLOCK		; and return
;
; To here when all of the item descriptors have been processed.  Now begin
; the actual protection checking.  This consists of calling a series of
; routines to do the various checks.
;
FINISH_ITEMS:
	PUSHL	R11			; Save address of the local storage block
	CLRL	R7			; Reset all flags & indicate service entry
	MOVQ	STRUCT_ADDR(R11),R0	; Get ARB and ORB addresses
	MOVQ	STRUCT_ADDR+8(R11),R2	; Now for CHPCTL and CHPRET addresses
	BRW	EXE$CHKPRO_CMN		; join common code

	.SBTTL	$CHKPRO SYSTEM SERVICE ITEM SCANNING
;
; Scan through the item list, acquiring the input information as encountered.
;
GET_ITEM:
	MOVZWL	(R10)+,R7		; get next item length
	BEQL	FINISH_ITEMS		; if zero, end of list
	MOVZWL	(R10)+,R4		; get item code
	CMPL	R4,#MAX_CHP_CODE	; range check item code
	BGTRU	BADPARAM
	MOVZBL	MIN_SIZE_TABLE[R4],R1	; get minimum size allowed
	CMPL	R7,R1			; less than the min required?
	BLSSU	BADPARAM		; xfer if so
	IFNORD	#12,(R10),RETURN_ACCVIO1	; probe rest of item + start of next
	MOVL	(R10)+,R8		; get buffer address
	MOVL	R7,R1			; copy buffer descriptor
	MOVL	R8,R0
	CLRL	R3			; use prev mode only
	JSB	EXE$PROBER		; and probe buffer for readability
	BLBC	R0,RETURN_ACCVIO1	; branch on failure
	MOVL	(R10)+,R9		; get the address to return length
	BEQL	30$			; xfer if no return length required
	IFNOWRT	#2,(R9),RETURN_ACCVIO1	; else check for write access
	CLRW	(R9)			; preset to zero

; Use the index obtained from the index table to get the local protection
; structure base address and the offset into that same structure.

30$:	MOVZBL	INDEX_TABLE[R4],R0	; Get appropriate index table entry
	MOVL	STRUCT_ADDR(R11)[R0],R3	; Get structure base address
	MOVAL	OFFSET_TABLE[R4],R1	; Get offset table entry
	MOVZBL	(R1)[R0],R5		; Get the offset
	ADDL	R3,R5			; compute protection structure field address
;
; All of the basic checks about the item descriptor have succeeded.  Now
; dispatch based upon the item code to take the appropriate action.
;
	CASEL	R4,#1,#MAX_CHP_CODE-1
40$:	.WORD	ITEM_ACCESS-40$		; CHP$_ACCESS
	.WORD	ITEM_FLAGS-40$		; CHP$_FLAGS
	.WORD	ITEM_PRIV-40$		; CHP$_PRIV
	.WORD	ITEM_ACMODE-40$		; CHP$_ACMODE
	.WORD	ITEM_ACCLASS-40$	; CHP$_ACCLASS
	.WORD	ITEM_RIGHTS-40$		; CHP$_RIGHTS
	.WORD	ITEM_ADDRIGHTS-40$	; CHP$_ADDRIGHTS
	.WORD	ITEM_MODE-40$		; CHP$_MODE
	.WORD	ITEM_MODES-40$		; CHP$_MODES
	.WORD	ITEM_MINCLASS-40$	; CHP$_MINCLASS
	.WORD	ITEM_MAXCLASS-40$	; CHP$_MAXCLASS
	.WORD	ITEM_OWNER-40$		; CHP$_OWNER
	.WORD	ITEM_PROT-40$		; CHP$_PROT
	.WORD	ITEM_ACL-40$		; CHP$_ACL
	.WORD	ITEM_AUDITNAME-40$	; CHP$_AUDITNAME
	.WORD	ITEM_ALARMNAME-40$	; CHP$_ALARMNAME
	.WORD	ITEM_MATCHEDACE-40$	; CHP$_MATCHEDACE
	.WORD	ITEM_PRIVUSED-40$	; CHP$_PRIVUSED
;
; Falling through indicates a bad parameter.
;
BADPARAM1:
	MOVL	#SS$_BADPARAM,R0	; set status
	BRW	RETURN_P1_BLOCK		; and return
;
; What to do when some portion of the item descriptor cannot be read or
; written as necessary.
;
RETURN_ACCVIO1:
	MOVL	#SS$_ACCVIO,R0		; set error status
	BRW	RETURN_P1_BLOCK		;   and return
;
; Common routines to copy item text into the local storage block.  For all
; of the ITEM_xxx routines below, the following register usage is utilized:
;
;	R0-R2	Scratch
;	R3	Address of the local protection structure
;	R4	Item code
;	R5	Address of the local protection structure field

;
; Classification mask item. For the first of MIN or MAX class, copy
; the item into its partner to default the contents.
;
ITEM_MINCLASS:
	MOVAB	ORB$R_MAX_CLASS(R3),R0	; Point to other mask
	BRB	43$
ITEM_MAXCLASS:
	MOVAB	ORB$R_MIN_CLASS(R3),R0	; Point to other mask
43$:	BBCS	#ORB$V_CLASS_PROT,ORB$B_FLAGS(R3),44$ ; Mark classification present
ITEM_ACCLASS:
	ASSUME	ARB$S_CLASS EQ 20
	ASSUME	ORB$S_MIN_CLASS EQ 20
	ASSUME	ORB$S_MAX_CLASS EQ 20
	MOVL	R5,R0			; Copy mask address
44$:	MOVQ	(R8),(R0)+		; First 8 bytes
	MOVQ	(R8)+,(R5)+		; First 8 bytes
	MOVQ	(R8),(R0)+		; Second 8 bytes
	MOVQ	(R8)+,(R5)+		; Second 8 bytes
	MOVL	(R8),(R0)+		; Final 4 bytes
	MOVL	(R8)+,(R5)+		; Final 4 bytes
NEXT_ITEM:
	BRW	GET_ITEM		; Go get next item
;
; Quadword item.
;
ITEM_PRIV:
ITEM_MODES:
	MOVQ	(R8),(R5)		; store in local protection structure
	CMPL	R4,#CHP$_MODES		; Mode protection vector?
	BNEQ	45$			; Xfer if not
	BISB2	#ORB$M_MODE_VECTOR,ORB$B_FLAGS(R3)	; Else note use of vector
45$:	BRB	NEXT_ITEM		; Go get the next item in the list
;
; Longword item.
;
ITEM_ACCESS:
ITEM_FLAGS:
ITEM_OWNER:
	MOVL	(R8),(R5)		; store in local protection structure
	BRB	NEXT_ITEM		; go get next item_descriptor
;
; Byte item.
;
ITEM_ACMODE:
	MOVZBL	(R8),(R5)		; store in local protection structure
	BRB	NEXT_ITEM		; go get next item_descriptor
;
; Common path for returning a longword value of some sort.  Check for write
; accessibility, and then save the return address.
;
ITEM_PRIVUSED:
	IFNOWRT	#4,(R8),RETURN_ACCVIO1	; xfer if cannot be written
	MOVL	R8,(R5)			; where to return information
	TSTL	R9			; return length needed?
	BEQL	NEXT_ITEM		; xfer if not
	MOVW	#4,(R9)			; else set return length
	BRB	NEXT_ITEM		; go get next item descriptor
;
; Common path for returning a descriptor of some sort.  Check for write
; accessibility, and then save the needed arguments.
;
	ASSUME	CHPRET$W_AUDITLEN EQ CHPRET$L_AUDIT-4
	ASSUME	CHPRET$L_AUDITRET EQ CHPRET$L_AUDIT+4
	ASSUME	CHPRET$W_ALARMLEN EQ CHPRET$L_ALARM-4
	ASSUME	CHPRET$L_ALARMRET EQ CHPRET$L_ALARM+4
	ASSUME	CHPRET$W_MATCHED_ACELEN EQ CHPRET$L_MATCHED_ACE-4
	ASSUME	CHPRET$L_MATCHED_ACERET EQ CHPRET$L_MATCHED_ACE+4

ITEM_AUDITNAME:
ITEM_ALARMNAME:
ITEM_MATCHEDACE:
	MOVL	R7,R1			; copy buffer descriptor
	MOVL	R8,R0
	CLRL	R3			; use prev mode only
	JSB	EXE$PROBEW		; check item descr for writing
	BLBC	R0,RETURN_ACCVIO1	; xfer if cannot be written
	MOVQ	R7,(R5)+		; save descriptor
	MOVL	R9,(R5)+		; save return address specified
	BRB	NEXT_ITEM		; go get the next descriptor
;
; Special case item handling code follows.
;
; Extract simple access mode.
;
ITEM_MODE:
	EXTZV	#0,#2,(R8),(R5)		; get access mode protection
	BRB	NEXT_ITEM		; go get next item descriptor
;
; Process ACL segment descriptor.
;
ITEM_ACL:
	MOVL	ORB$L_ACL_COUNT(R3),R0 ; get current number of descrs
	BNEQ	50$			; xfer if not the first one
	MOVAB	ACL_LIST(R11),ORB$L_ACL_DESC(R3)	; Else note address
50$:	CMPL	R0,#MAX_ACL_DESC	; table full?
	BGEQU	60$			; xfer if so
	MOVQ	R7,@ORB$L_ACL_DESC(R3)[R0]	; else save another
	INCL	ORB$L_ACL_COUNT(R3)	; up count of ACL segments
	BRB	NEXT_ITEM		; go get next item descriptor

60$:	MOVZWL	#SS$_ACLFULL,R0		; set error code
	BRW	RETURN_P1_BLOCK		; and return
;
; Build specified rights list.
;
ITEM_RIGHTS:
ITEM_ADDRIGHTS:
;
; If a new rights list is specified, forget any existing entries.
;
90$:	CMPL	R4,#CHP$_RIGHTS		; see if new rights list specified
	BNEQ	100$			; branch if not - add to existing
	CLRL	R6			; initialize counter
;
; Add a new rights list descriptor to any that already exist.
;
100$:	CMPL	R6,#MAX_RIGHT_DESC	; is there room for this descriptor?
	BGEQU	110$			; xfer if not, note error
	MOVAQ	RIGHTS_DESC(R11)[R6],R0	; set address of descriptor
	MOVL	R0,RIGHTS_LIST(R11)[R6]	; save address for later
	MOVQ	R7,(R0)			; save descriptor for later
	INCL	R6			; next available
	CLRL	RIGHTS_LIST(R11)[R6]	; mark current end
NEXT_ITEM1:
	BRW	GET_ITEM		; go get next item descriptor

110$:	MOVZWL	#SS$_RIGHTSFULL,R0	; else set error code
	BRW	RETURN_P1_BLOCK		; and exit stage left

;
; The following section of code converts the standard protection mask into
; a series of longwords, each representing a specific class of users (system,
; group, etc.)  It further assumes that any extensions to the protection mask
; will be in 4 bit chunks;  thus adding an additional word.  Following is
; a diagram of the mapping that takes place:
;
;		+---------+---------+---------+---------+
;		|  WORLD  |  GROUP  |  OWNER  |  SYSTEM |
;		+---------+---------+---------+---------+
;		| D|E|W|R | D|E|W|R | D|E|W|R | D|E|W|R |
;		+---------+---------+---------+---------+
;	       15                                       0
;
;		+---------+---------+---------+---------+
;		|  WORLD  |  GROUP  |  OWNER  |  SYSTEM |
;		+---------+---------+---------+---------+
;		|   ...|C |   ...|C |   ...|C |   ...|C |
;		+---------+---------+---------+---------+
;	       15                                       0
;                               |      |
;                               |      |
;                             \ |      | /
;                              \|      |/
;                               \      /
;                                \    /
;                                 \  /
;                                  \/
;
;	       31					0
;		+---------------------------------------+
;		|                          ...|C|D|E|W|R|	SYSTEM
;		+---------------------------------------+
;		|                          ...|C|D|E|W|R|	OWNER
;		+---------------------------------------+
;		|                          ...|C|D|E|W|R|	GROUP
;		+---------------------------------------+
;		|                          ...|C|D|E|W|R|	WORLD
;		+---------------------------------------+
;	       31					0


ITEM_PROT:
	ASHL	#-1,R7,R0		; get mask size in words
	CMPL	R0,#8			; too much supplied?
	BLEQU	140$			; xfer if not - start loop
	BRW	BADPARAM1		; return error status

120$:	CLRL	R1			; else reset index
	MOVZWL	(R8)[R0],R2		; get next protection word
	ASHL	#2,R0,R3		; calc position in output mask
130$:	CLRL	R4			; preload R4
	BICB3	#^XF0,R2,R4		; get protection bits
	ROTL	R3,R4,R4		; shift into position
	BISL2	R4,(R5)[R1]		; save in output mask
	ROTL	#-4,R2,R2		; get next set of bits
	AOBLSS	#4,R1,130$		; continue till done
140$:	SOBGEQ	R0,120$			; go get next protection word
	BRB	NEXT_ITEM1		; done

	.DISABLE LSB

	.SBTTL	EXE$CHKPRO_INT - $CHKPRO INTERNAL ENTRY POINT

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This is the internal entry point to the $CHKPRO system service.  This
;	entry point may be used to avoid the overhead associated with insuring
;	that the item list is valid.  This is done by assuming that the caller
;	has filled in the necessary arg blocks in the same manner as the item
;	list processing code above.
;
; CALLING SEQUENCE:
;	JSB	EXE$CHKPRO_INT
;
; INPUT PARAMETERS:
;	ARB	(R0): address of the agents rights block
;	ORB	(R1): address of the objects rights block
;	CHPCTL	(R2): address of the protection check control block
;	CHPRET	(R3): address of the return argument block
;
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;	SAME AS EXE$CHKPRO
;
; IMPLICIT OUTPUTS:
;	NONE
;
; ROUTINE VALUE:
;	SAME AS EXE$CHKPRO
;
; SIDE EFFECTS:
;	NONE
;
;--

; Internal entry point to the protection check system service.

EXE$CHKPRO_INT::
	PUSHR	#^M<R1,R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>	; save work regs
	MOVL	#CHKPRO_M_INTERNAL,R7		; Reset flags & indicate internal entry
EXE$CHKPRO_CMN:
	MOVQ	R0,R8				; put structure addresses
	MOVQ	R2,R10				;   in a more useful place
	TSTL	R11				; was a return arg block given?
	BNEQ	5$				; xfer if so, skip following
	BISL2	#CHKPRO_M_NO_CHPRET,R7		; note fabricated CHPRET block
	ASSUME	<CHPRET$C_LENGTH & 3> EQ 0
	SUBL2	#CHPRET$C_LENGTH+4,SP		; else make room for one
	MOVL	SP,R11				; save address
	MOVC5	#0,(SP),#0,#CHPRET$C_LENGTH+4,(R11)
	ADDL3	#CHPRET$C_LENGTH,R11,CHPRET$L_PRIVS_USED(R11)	; privs used return address

; If an ACL is supplied as a queue, lock it now.

5$:	BBC	#ORB$V_ACL_QUEUE,ORB$B_FLAGS(R9),10$	; Skip if not a queue
	DSBINT	#IPL$_ASTDEL			; Raise IPL to prevent deletion
	MOVL	@#SCH$GL_CURPCB,R4		; Get current PCB address
	MOVAB	ORB$L_ACL_MUTEX(R9),R0		; Set mutex address
	JSB	@#SCH$LOCKR			; Lock mutex for reading

; Set up an alternate SOGW protection vector/mask.  This is used when checking
; to see if system or owner are allowed access if the ACL actually denies access.

	ASSUME	ORB$L_SYS_PROT EQ ORB$W_PROT
	ASSUME	ORB$L_OWN_PROT EQ ORB$L_SYS_PROT+4
	ASSUME	ORB$L_WOR_PROT EQ ORB$L_GRP_PROT+4

10$:	MNEGL	#1,-(SP)			; deny access to group
	MNEGL	#1,-(SP)			;   and world
	MOVQ	ORB$L_SYS_PROT(R9),-(SP)	; Original system & owner protection
	BBC	#ORB$V_PROT_16,ORB$B_FLAGS(R9),15$	; Xfer if full vector
	MNEGB	#1,1(SP)			; Else deny group & world access

; Perform the access mode protection check.

15$:	MOVL	CHPCTL$L_ACCESS(R10),R3		; set up input parameters
	MOVZBL	CHPCTL$B_MODE(R10),R4
	MOVZBL	ORB$B_MODE(R9),R5		; assume simple mode protection
	BBC	#ORB$V_MODE_VECTOR,ORB$B_FLAGS(R9),20$	; xfer if correct
	MOVAB	ORB$Q_MODE_PROT(R9),R5		; else set address of vector
20$:	BSBW	EXE$CHECKACMODE			; do the actual check
	BLBC	R0,45$				; xfer if access was denied

; Next comes the non-discretionary protection check, if enabled (via a
; SYSGEN flag), and if it is called for.

	BBC	S^#EXE$V_CLASS_PROT,@#EXE$GL_DYNAMIC_FLAGS,30$	; xfer if not enabled
	BBC	#ORB$V_CLASS_PROT,ORB$B_FLAGS(R9),30$ ; xfer if not present
	MOVAB	ARB$Q_PRIV(R8),R2		; else set up input parameters
	MOVL	CHPCTL$L_FLAGS(R10),R3
	MOVAB	ARB$R_CLASS(R8),R4
	MOVAB	ORB$R_MIN_CLASS(R9),R5
	MOVAB	ORB$R_MAX_CLASS(R9),R6
	BSBW	EXE$CHECKCLASS			; do the check
	BISL2	R1,@CHPRET$L_PRIVS_USED(R11)	; note any privileges used
25$:	BLBC	R0,45$				; xfer if access denied

; If there is any ACL, check it now.  This may be in one of two forms:
; 1) an ACL queue segment listhead or 2) a ACL segment descriptor vector
; and an associated count (of the number of descriptors).

30$:	MOVQ	R10,-(SP)			; save CHPCTL and CHPRET
	MOVL	CHPCTL$L_ACCESS(R10),R3		; set up CHECKACL input parameters
	MOVAB	ARB$L_RIGHTSLIST(R8),R4
	BBC	#ORB$V_ACL_QUEUE,ORB$B_FLAGS(R9),50$	; xfer if not a queue

; Handle the ACL segment queue here.

	MOVAB	ORB$L_ACLFL(R9),R10		; set address of queue head
	TSTL	(R10)				; Is queue head valid?
	BEQL	70$				; Xfer if not, nothing to check
	MOVL	R10,R11				; Else copy address for later
40$:	MOVL	(R10),R10			; get address of next segment
	CMPL	R10,R11				; end of the line?
	BEQL	70$				; xfer if so
	CLRL	R5				; else preset segment size
	SUBW3	#ACL$C_LENGTH,ACL$W_SIZE(R10),R5	; set segment size
	MOVAB	ACL$L_LIST(R10),R6		; set address of ACEs
	BRB	65$				; go do the ACL check

; If an invalid ACL has been seen, clear the local ACL_PRESENT flag so that
; it is not checked for an AUDIT or ALARM ACE.

44$:	BICL2	#CHKPRO_M_ACL_PRESENT,R7	; Forget any ACL present

; Intermediate branch for BYPASS checking.

45$:	BRW	BYPASS_CHECK			; Go check for BYPASS priv

; Handle the descriptor vector here.

50$:	MOVL	ORB$L_ACL_COUNT(R9),R10		; get the number of descriptors
	BEQL	70$				; xfer if no ACL supplied
	MOVL	ORB$L_ACL_DESC(R9),R11		; get address of descriptor list
60$:	MOVQ	(R11)+,R5			; get a descriptor

; Now check the ACL segment described by R5 & R6.

65$:	BISL2	#CHKPRO_M_ACL_PRESENT,R7	; note an ACL present
	BSBW	EXE$CHECKACL			; search this segment
	CMPW	R0,#SS$_NOENTRY			; was anything found?
	BNEQ	80$				; xfer if so...go deal with it
	BBS	#ORB$V_ACL_QUEUE,ORB$B_FLAGS(R9),40$	; if a queue, go get next
	SOBGTR	R10,60$				; else continue with next segment
70$:	MOVQ	(SP)+,R10			; restore saved registers
	BRB	110$				; go try next check

; If the ACL segment is invalid, go check for BYPASS.

80$:	CMPW	R0,#SS$_IVACL			; Valid ACL?
	BEQL	44$				; Xfer if not

; An entry was found in the ACL.  It may grant or deny access.

	MOVQ	(SP)+,R10			; restore saved registers
	MOVL	R0,R6				; Save current status
	ASSUME	CHPRET$W_MATCHED_ACELEN EQ CHPRET$L_MATCHED_ACE-4
	MOVQ	CHPRET$W_MATCHED_ACELEN(R11),R2	; get the return descriptor
	BEQL	100$				; xfer if no need to return
	MOVZBL	ACE$B_SIZE(R1),R4		; else get size of the ACE
	MOVL	CHPRET$L_MATCHED_ACERET(R11),R5	; note where length is returned
	BEQL	90$				; xfer if not returning length
	MOVL	R4,(R5)				; else save ACE length
90$:	MOVC5	R4,(R1),#0,R2,(R3)		; copy matching ACE
100$:	MOVL	R6,R0				; Restore saved status
	BLBS	R0,BYPASS_CHECK			; done if access granted

; Processing of the protection mask depends upon what happened with the ACL
; processing.  Matching an ACE overrides group and world access.  If no
; protection mask was supplied (coded as an ORB$L_OWNER equal to zero),
; access is granted if there was no ACL, and denied if there was one.

	MOVL	SP,R5				; Set modified prot mask addr
	MOVZWL	#SS$_NOPRIV,R0			; Failure if no prot mask
	BRB	120$				; go do SOGW check

	ASSUME	ORB$L_SYS_PROT EQ ORB$W_PROT
110$:	MOVAB	ORB$L_SYS_PROT(R9),R5		; Set protection mask address
	MOVZWL	#SS$_NOPRIV,R0			; Failure if no prot mask & ACL present
	BBS	#CHKPRO_V_ACL_PRESENT,R7,120$	; Xfer if no ACL present
	MOVZWL	#SS$_NORMAL,R0			; Else success if no prot mask & no ACL

; R5 set up above.

120$:	MOVAB	ARB$Q_PRIV(R8),R2		; Set up input parameters
	MOVL	CHPCTL$L_ACCESS(R10),R3		; Get the desired access
	MOVAB	ARB$L_RIGHTSLIST(R8),R4		; Set rights list descr addr
	MOVL	ORB$L_OWNER(R9),R6		; was there an owner?
	BEQL	BYPASS_CHECK			; xfer if not, no SOGW check
	BBS	#ORB$V_PROT_16,ORB$B_FLAGS(R9),130$	; else check for full vector
	BSBW	EXE$CHECKPROT			; do check with full vector
	BRB	140$				; go finish this check
130$:	BSBW	EXE$CHECKPROT_16		; do check with word value
140$:	BISL2	R1,@CHPRET$L_PRIVS_USED(R11)	; note any privileges used

; At this point, the status will be set according to the protection checks
; applied.  Now check for any overriding privileges.

BYPASS_CHECK:
	ADDL2	#16,SP				; Clean off protection vector
	BLBS	R0,10$				; xfer is successful
	MOVAB	ARB$Q_PRIV(R8),R2		; Else set up input parameters
	MOVL	CHPCTL$L_FLAGS(R10),R3
	BSBW	EXE$CHECK_BYPASS		; check for BYPASS or READALL
	BISL2	R1,@CHPRET$L_PRIVS_USED(R11)	; note any privileges used

; Return any security audit or alarm names from the ACL segments supplied.

	ASSUME	CHPRET$W_AUDITLEN EQ CHPRET$L_AUDIT-4
	ASSUME	CHPRET$L_AUDITRET EQ CHPRET$L_AUDIT+4
	ASSUME	CHPRET$W_ALARMLEN EQ CHPRET$L_ALARM-4
	ASSUME	CHPRET$L_ALARMRET EQ CHPRET$L_ALARM+4

10$:	MOVL	R0,R6				; save the final status
	BBC	#CHKPRO_V_ACL_PRESENT,R7,RETURN_STATUS	; if no ACL, go finish up
	MOVAB	CHPRET$W_AUDITLEN(R11),R4	; set descriptor address
	TSTW	(R4)				; want audit journal name?
	BEQL	20$				; xfer if not, try alarm journal
	MOVL	#ACE$C_AUDIT,R3			; else set the ACE type to get
	BSBB	EXE$GET_AUDIT			; go get the journal name, if one
	BLBC	R0,30$				; xfer if any errors
20$:	MOVAB	CHPRET$W_ALARMLEN(R11),R4	; set descriptor address
	TSTW	(R4)				; want alarm journal name?
	BEQL	30$				; xfer if not, we're done
	MOVL	#ACE$C_ALARM,R3			; else set the ACE type to get
	BSBB	EXE$GET_AUDIT			; go get the journal name, if one
	BLBS	R0,RETURN_STATUS		; xfer if no errors
30$:	MOVL	R0,R6				; Else change saved status

; Done at last!!  Release ACL mutex, if necessary, and do the final cleanup.

RETURN_STATUS:
	BBC	#ORB$V_ACL_QUEUE,ORB$B_FLAGS(R9),10$	; Xfer if not a queue
	MOVL	@#SCH$GL_CURPCB,R4		; Else get current PCB address
	MOVAB	ORB$L_ACL_MUTEX(R9),R0		; Set mutex address
	JSB	@#SCH$UNLOCK			; Unlock mutex
	ENBINT					; Restore IPL
10$:	MOVL	R6,R0				; Restore the final status
	BBC	#CHKPRO_V_INTERNAL,R7,30$	; xfer if system service return
	BBC	#CHKPRO_V_NO_CHPRET,R7,20$	; xfer if no cleanup of CHPRET block
	ADDL2	#CHPRET$C_LENGTH+4,SP		; else remove the local CHPRET
20$:	POPR	#^M<R1,R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>	; restore work regs
	RSB					; return to caller

30$:	MOVL	(SP)+,R11			; Restore local storage block address
RETURN_P1_BLOCK:
	INSQUE	(R11),CTL$GL_KRPFL		; Return block to lookaside list
	RET					; return for system service entry

	.SBTTL	EXE$GET_AUDIT - SEARCH FOR SECURITY AUDIT ACE IN THE ACL

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine searches the access control lists in the item
;	list for security audit or alarm entries of the specified
;	type.
;
; CALLING SEQUENCE:
;	JSB EXE$GETAUDIT
;
; INPUT PARAMETERS:
;	TYPE	(R3): ACE type code of audit or alarm to find
;	STATUS	(R6): status of the protection check
;	ORB	(R9): address of the object's rights block
;	CHPCTL	(R10): address of the protection check control block
;
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;	ITEM  (R4): address of item descriptor to which to write
;
; IMPLICIT OUTPUTS:
;	none
;
; ROUTINE VALUE:
;	SS$_NORMAL if ACL ok - audit found or not
;	SS$_IVACL if invalid
;
; SIDE EFFECTS:
;	NONE
;
;--


EXE$GET_AUDIT:
	PUSHR	#^M<R2,R3,R4,R5,R6,R7,R8>	; save work registers
	CLRL	R1				; start with the first ACE
	BBC	#ORB$V_ACL_QUEUE,ORB$B_FLAGS(R9),20$	; xfer if not a queue

; Handle the ACL segment queue here.

	MOVAB	ORB$L_ACLFL(R9),R7		; else set address of queue head
	MOVL	R7,R8				; copy address for later
10$:	MOVL	(R7),R7				; get address of next segment
	CMPL	R7,R8				; end of the line?
	BEQL	50$				; xfer if so
	CLRL	R5				; else preset segment size
	SUBW3	#ACL$C_LENGTH,ACL$W_SIZE(R7),R5	; set segment size
	MOVAB	ACL$L_LIST(R7),R6		; set address of ACEs
	BRB	40$				; go do the ACL check

; Handle the descriptor vector here.

20$:	MOVL	ORB$L_ACL_COUNT(R9),R7		; get the number of descriptors
	BEQL	50$				; xfer if no ACL supplied
	MOVL	ORB$L_ACL_DESC(R9),R8		; get address of descriptor list
30$:	MOVL	(R8)+,R5			; get a descriptor
40$:	BSBW	EXE$FINDACL			; locate the specified type
	BLBS	R0,60$				; xfer if in this one
	CMPW	R0,#SS$_NOENTRY			; check for normal termination
	BNEQ	110$				; exit if error
	BBS	#ORB$V_ACL_QUEUE,ORB$B_FLAGS(R9),10$	; if a queue, go get next
	SOBGTR	R7,30$				; else continue with next segment
50$:	BRB	95$				; Go finish up

; An ACE has been found of the desired type.  Check to see if the success/failure
; status matches, and also that the access matches.

60$:	MOVZBL	ACE$B_SIZE(R1),R0		; get ACE size
	SUBL	#ACE$T_AUDITNAME,R0		; compute audit name length
	CMPL	R0,#1				; check for minimum size
	BLSS	100$				; must have at least 1 byte of name

; The following instruction depends on the (number and order of) registers
; saved upon entering EXE$GET_AUDIT.

	BLBC	16(SP),70$			; xfer if final status is failure

; Verify that the success/failure status of the protection check matches the
; flags in the ACE.

	BBS	#ACE$V_SUCCESS,ACE$W_FLAGS(R1),80$	; Xfer if success matches
	BRB	75$				; Else go check next segment
70$:	BBS	#ACE$V_FAILURE,ACE$W_FLAGS(R1),80$	; Xfer if failure matches
75$:	BBS	#ORB$V_ACL_QUEUE,ORB$B_FLAGS(R9),10$	; Else xfer if a queue
	BRB	20$				; Else must be descr list

; Now verify that the requested access is in fact enabled in the ACE.

80$:	BITL	CHPCTL$L_ACCESS(R10),ACE$L_ACCESS(R1)	; for desired access?
	BEQL	40$				; xfer if not, try another ACE
	MOVQ	(R4)+,R2			; get descriptor
	MOVL	(R4)+,R5			; get return length address
	BEQL	90$				; xfer if return length not needed
	MOVW	R0,(R5)				; else save it
90$:	MOVC5	R0,ACE$T_AUDITNAME(R1),#0,R2,(R3) ; copy the journal name
95$:	MOVL	#SS$_NORMAL,R0			; set success return
	BRB	110$				; go finish up

100$:	MOVZWL	#SS$_IVACL,R0			; invalid ACL - set error
110$:	POPR	#^M<R2,R3,R4,R5,R6,R7,R8>	; save work registers
	RSB

	.SBTTL	EXE$CHECKACL - CHECK FOR AN ACE IN AN ACL

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine searches the specified access control list for an entry
;	that matches the specified rights list. If an entry is found, it
;	checks whether the entry grants the requested rights.
;
; CALLING SEQUENCE:
;	JSB EXE$CHECKACL
;
; INPUT PARAMETERS:
;	ACCESS		(R3): bitmask of access requested
;	RIGHTSDESC	(R4): address of rights list descriptors
;	ACL_LENGTH	(R5): length of ACL segment
;	ACL		(R6): address of ACL segment
;
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;	ACE		(R1): address of ACL entry matched
;
; IMPLICIT OUTPUTS:
;	NONE
;
; ROUTINE VALUE:
;	SS$_NORMAL if matching ACE found and access is granted
;	SS$_NOPRIV if matching ACE found and access is denied
;	SS$_NOENTRY if no matching ACE is found
;	SS$_IVACL if the ACL structure is invalid
;
; SIDE EFFECTS:
;	NONE
;
;--

	.ENABLE LSB

EXE$CHECKACL::
	PUSHR	#^M<R2,R5,R6,R7,R8,R9>	; save work regs
	MOVL	R6,R9			; set address of the first ACE
	ADDL2	R5,R6			; calc end of the ACL segment
10$:	MOVL	R9,R7			; position to next ACE
	CMPL	R7,R6			; more to go in this segment?
	BGEQU	50$			; xfer if not
	MOVZBL	ACE$B_SIZE(R7),R0	; get the size of the current ACE
	BEQL	50$			; xfer if at the end of the segment
	CMPL	R0,#4			; check minimum ACE size
	BLSSU	40$			; too small - error
	ADDL3	R0,R7,R9		; calc the end of the current ACE
	CMPL	R9,R6			; beyond the end of the ACL segment?
	BGTRU	40$			; xfer if so, note error
	BBS	#ACE$V_DEFAULT,ACE$W_FLAGS(R7),10$	; ignore default ACEs
	CMPB	ACE$B_TYPE(R7),#ACE$C_KEYID	; else right type of ACE?
	BNEQ	10$			; xfer if not, go try the next ACE

	ASSUME	ACE$V_RESERVED EQ 0

	CLRL	R0			; pre-clear high order part
	BICB3	#-<1@ACE$S_RESERVED>,ACE$W_FLAGS(R7),R0	; get size of reserved area
	MOVAL	ACE$L_KEY(R7)[R0],R8	; calc start of actual keys
	CMPL	R8,R9			; check for non-null identifier list
	BGEQU	40$			; branch if null - bad ACE
20$:	MOVL	(R8)+,R2		; get an identifier from the ACE
	BSBB	EXE$SEARCH_RIGHT	; see if the identifier is present
	BLBC	R0,10$			; xfer if it is not
	CMPL	R8,R9			; at the end of the ACE?
	BLSSU	20$			; loop if not
;
; At this point an ACE has been found whose identifiers are contained in the
; rights lists.  Check for the desired access.
;
30$:	MOVL	#SS$_NOPRIV,R0		; preset status
	BICL3	ACE$L_ACCESS(R7),R3,R2	; check for access
	BNEQ	CHKACL_RETURN		; xfer if denied
	MOVL	#SS$_NORMAL,R0		; else note successful
CHKACL_RETURN:
	MOVL	R7,R1			; return matched ACE
	POPR	#^M<R2,R5,R6,R7,R8,R9>	; restore work regs
	RSB
;
; The ACL or an ACE within the ACL has been found to be invalid.  Note the
; error for the caller.
;
40$:	MOVZWL	#SS$_IVACL,R0		; else set error
	BRB	CHKACL_RETURN		; go finish up
;
; The ACL does not contain the specified ACE.  Note this condition.
;
50$:	MOVZWL	#SS$_NOENTRY,R0		; set error status
	BRB	CHKACL_RETURN		; go finish up

	.DISABLE LSB

	.SBTTL	EXE$SEARCH_RIGHT - SEARCH RIGHTS DESCRIPTOR FOR AN IDENTIFIER

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine searches the specified rights segment for the given
;	identifier.
;
; CALLING SEQUENCE:
;	JSB	EXE$SEARCH_RIGHT
;
; INPUT PARAMETERS:
;	IDENTIFIER	(R2): identifier being sought
;	RIGHTSDESC	(R4): address of the rights segment descriptors
;
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;	ID_ADDRESS	(R1): address of the ID quadword if found
;	DESC_ADDRESS	(R5): address of the rights segment containing the ID
;
; IMPLICIT OUTPUTS:
;	NONE
;
; ROUTINE VALUE:
;	SS$_NORMAL if ID was found
;	SS$_NOSUCHID if the ID was not found
;
; SIDE EFFECTS:
;	NONE
;
;--

	ASSUME	UIC$K_UIC_FORMAT EQ 0
	ASSUME	UIC$K_ID_FORMAT EQ 2
	ASSUME	UIC$V_FORMAT EQ 30
	ASSUME	UIC$K_MATCH_ALL EQ -1

EXE$SEARCH_RIGHT::
	PUSHL	R10			; save work registers
	PUSHL	R4
	PUSHL	R3
	MCOML	R2,R10			; see if match-all specified
	BNEQ	5$			; branch if not
	MOVL	R2,R10			; set test mask to all ones
	CLRL	R2			; search pattern is zero
	BRB	30$			; and execute match code

5$:	BBS	#30,R2,50$		; xfer if invalid identifier format
	CLRL	R10			; preset UIC mask
	TSTL	R2			; check for a UIC type identifier
	BLSS	30$			; xfer if not a UIC
;
; Form a wildcard mask based upon the UIC entry in the ACE.
;
	CMPZV	#UIC$V_GROUP,#UIC$S_GROUP,R2,#UIC$K_WILD_GROUP
					; wildcard group?
	BNEQ	10$			; xfer if not
	MOVL	R2,R10			; get the UIC with wild group
	CLRW	R10			; zap the member for now
10$:	CMPW	R2,#UIC$K_WILD_MEMBER	; wildcard member?
	BNEQ	20$			; xfer if not
	MNEGW	#1,R10			; else note it
20$:	BICL	R10,R2			; mask out unneeded portions
;
; At this point an identifier exists in R2.  Now scan the rights list segments
; to see if it exists within the rights lists.
;
30$:	MOVL	(R4)+,R5		; else get address of a descriptor
	BEQL	50$			; xfer if at the end...ID not found
	MOVZWL	(R5),R3			; else get size of descriptor
	ASHL	#-3,R3,R3		; get number of entries
	BEQL	30$			; xfer if none to check
	MOVL	4(R5),R1		; get starting address
40$:	MOVL	(R1),R0			; get the identifier
	BEQL	30$			; xfer if no more
	BICL	R10,R0			; mask out any unneeded portions
	CMPL	R2,R0			; ACE & rights list identifier match?
	BEQL	60$			; xfer if so, next identifier please
	ADDL	#ARB$S_RIGHTSDESC,R1	; point to next identifier
	SOBGTR	R3,40$			; go try it
	BRB	30$			; if exhausted, try next rights list

50$:	MOVZWL	#SS$_NOSUCHID,R0	; set status
	BRB	70$			; go finish up

60$:	MOVL	#SS$_NORMAL,R0		; set status
70$:	MOVL	(SP)+,R3		; restore work registers
	MOVL	(SP)+,R4
	MOVL	(SP)+,R10
	RSB				; return to caller

	.SBTTL	EXE$FINDACL - SEARCH FOR A PARTICULAR ACE IN THE ACL

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine searches the specified ACL segment for an entry
;	of the specified type.
;
; CALLING SEQUENCE:
;	JSB EXE$FINDACL
;
; INPUT PARAMETERS:
;	TYPE		(R3): type code of ACE to find
;	ACL_LENGTH	(R5): length of ACL segment
;	ACL		(R6): address of ACL segment
;	PREV_ACE	(R1): address of previously found ACE
;
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;	ACE		(R1): address of found entry
;
; IMPLICIT OUTPUTS:
;	NONE
;
; ROUTINE VALUE:
;	SS$_NORMAL if entry found
;	SS$_NOENTRY if entry not found
;	SS$_IVACL if ACL format is invalid
;
; SIDE EFFECTS:
;	NONE
;
;--

EXE$FINDACL::
	PUSHL	R8			; save work regs
	PUSHL	R7
	ADDL3	R5,R6,R7		; calc the end of the ACL segment
	TSTL	R1			; any previous entry?
	BEQL	10$			; branch if not
	MOVZBL	ACE$B_SIZE(R1),R0	; else get size of ACE
	BEQL	40$			; xfer if at the end of the segment
	ADDL	R0,R1			;   else point to the next one
	BRB	20$

10$:	MOVL	R6,R1			; set up for the first ACE
20$:	CMPL	R1,R7			; at the end of the ACL?
	BGEQU	40$			; xfer if so, done for the moment
	MOVZBL	ACE$B_SIZE(R1),R0	; else get size of ACE
	BEQL	40$			; Xfer if at the end of the segment
	CMPL	R0,#4			; check minimum ACE size
	BLSSU	30$			; too small - error
	ADDL3	R0,R1,R8		;   and point to the next one
	CMPL	R8,R7			; check end of ACE against ACL
	BGTRU	30$			; xfer if out of range
	CMPB	ACE$B_TYPE(R1),R3	; found desired type?
	BEQL	50$			; xfer if so, time to go
	MOVL	R8,R1			; advance to next ACE
	BRB	20$			; go test for the end

30$:	MOVZWL	#SS$_IVACL,R0		; else set error status
	BRB	60$			; go finish up

40$:	MOVZWL	#SS$_NOENTRY,R0		; no entry found
	BRB	60$			; go finish up

50$:	MOVL	#SS$_NORMAL,R0		; entry found
60$:	MOVL	(SP)+,R7		; restore work regs
	MOVL	(SP)+,R8
	RSB

	.SBTTL	EXE$CHECKPROT_16 - DO STANDARD SOGW CHECK WITH WORD INPUT

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine performs the standard "system - owner - group -
;	world" protection check using the information supplied.  This
;	routine differs from EXE$CHKPROT in that it expects a pointer
;	to a word protection mask input instead of a pointer to a
;	longword array.
;
; CALLING SEQUENCE:
;	JSB EXE$CHECKPROT
;
; INPUT PARAMETERS:
;	PRIV_MASK	(R2): address of accessor privilege mask
;	ACCESS		(R3): bitmask of access requested
;	RIGHTSDESC	(R4): address of rights list descriptors
;	PROTECTION	(R5): address of the protection word to use
;	OWNER		(R6): owner UIC of object
;
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;	PRIVS_USED	(R1): bitmask of privileges used to gain access
;
; IMPLICIT OUTPUTS:
;	NONE
;
; ROUTINE VALUE:
;	SS$_NORMAL: access is granted
;	SS$_NOPRIV: access if denied
;
; SIDE EFFECTS:
;	NONE
;
;--

EXE$CHECKPROT_16::
	PUSHL	R10			; save work regs
	PUSHL	R8
	PUSHL	R7
	PUSHL	R3
	PUSHL	R5
	EXTZV	#12,#4,(R5),-(SP)	; save the world protection bits
	BISL2	#ARM$M_CONTROL,(SP)	; control access denied
	EXTZV	#8,#4,(R5),-(SP)	; save the group protection bits
	BISL2	#ARM$M_CONTROL,(SP)	; control access denied
	EXTZV	#4,#4,(R5),-(SP)	; save the owner protection bits
	EXTZV	#0,#4,(R5),-(SP)	; save the system protection bits
	MOVL	SP,R5			; save address of protection array
	MNEGL	#1,-(SP)		; indicate entry type
	BRB	EXE$CHECKPROT_CMN	; go join common code

	.SBTTL	EXE$CHECKPROT - DO STANDARD SOGW PROTECTION CHECK

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine performs the standard "system - owner - group -
;	world" protection check using the information supplied.
;
; CALLING SEQUENCE:
;	JSB EXE$CHECKPROT
;
; INPUT PARAMETERS:
;	PRIV_MASK	(R2): address of accessor privilege mask
;	ACCESS		(R3): bitmask of access requested
;	RIGHTSDESC	(R4): address of rights list descriptors
;	PROTECTION	(R5): address of protection mask
;	OWNER		(R6): owner UIC of object
;
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;	PRIVS_USED	(R1): bitmask of privileges used to gain access
;
; IMPLICIT OUTPUTS:
;	NONE
;
; ROUTINE VALUE:
;	SS$_NORMAL: access is granted
;	SS$_NOPRIV: access if denied
;
; SIDE EFFECTS:
;	NONE
;
;--

EXE$CHECKPROT::
	PUSHL	R10			; save work regs
	PUSHL	R8
	PUSHL	R7
	PUSHL	R3
	CLRL	-(SP)			; indicate entry type

EXE$CHECKPROT_CMN:
	MOVL	#SS$_NORMAL,R0		; assume success
	CLRL	R1			; no privs used yet
	MOVL	(R4),R10		; get address of first descriptor
	MOVL	@4(R10),R10		; get the UIC from first descriptor
;
; Check for owner access first since it will be the most common
;
	CMPL	R10,R6			; UICs match?
	BNEQ	10$			; xfer if not, on to the next test
	MCOML	4(R5),R7		; get access bits
	BICL	R7,R3			; see if access allowed
	BEQL	50$			; xfer if it is
;
; Try world access next.
;
10$:	MCOML	12(R5),R7		; get access bits
	BICL	R7,R3			; see if access allowed
	BEQL	50$			; xfer if so
;
; Since world access failed, try group access next
;
	ROTL	#-16,R10,R10		; get accessor group in low word
	ROTL	#-16,R6,R8		; get owner group in low word
	CMPW	R10,R8			; check for group number match
	BNEQ	20$			; xfer if not a match
	BITW	#^XC000,R10		; check if UIC format accessor
	BNEQ	20$			; branch if not - no group
	MCOML	8(R5),R7		; get access bits
	BICL	R7,R3			; see if access allowed
	BEQL	50$			; xfer if allowed
;
; Try for group access via the system protection field and GRPPRV
;
	BBC	#PRV$V_GRPPRV,(R2),20$	; branch if no GRPPRV
	MCOML	(R5),R7			; get access bits
	BICL	R7,R3			; see if access allowed
	BNEQ	40$			; xfer if not allowed
	BISL	#CHP$M_GRPPRV,R1	; else note GRPPRV used
	BRB	50$			; go finish up
;
; Finally check the system protection field
;
20$:	BBS	#PRV$V_SYSPRV,(R2),30$	; branch if no SYSPRV
	CMPW	R10,@#EXE$GL_SYSUIC	; system group?
	BGTRU	40$			; xfer if not
30$:	MCOML	(R5),R7			; get access bits
	BICL	R7,R3			; see if access allowed
	BNEQ	40$			; xfer if not allowed
	BISL	#CHP$M_SYSPRV,R1	; else note SYSPRV used
	BRB	50$			; go finish up
;
; Note that no access was allowed
;
40$:	MOVL	#SS$_NOPRIV,R0
;
; Finally, clean up the stack.
;
50$:	BLBC	(SP)+,60$		; branch if normal entry
	ADDL2	#16,SP			; else clean up protection array
	MOVL	(SP)+,R5		; restore one reg
60$:	MOVL	(SP)+,R3		; restore remaining work regs
	MOVL	(SP)+,R7
	MOVL	(SP)+,R8
	MOVL	(SP)+,R10
	RSB				;   and return

	.SBTTL	EXE$CHECKACMODE - DO ACCESS MODE PROTECTION CHECK

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine performs the access mode protection check.  The
;	accessor access mode must be less than or equal to the access
;	mode.  For the per-access mode protection check, this must be
;	true for each field in the access mode vector for which access
;	is intended.
;
; CALLING SEQUENCE:
;	JSB	EXE$CHECKACMODE
;
; INPUT PARAMETERS:
;	ACCESS		(R3): bitmask of intended access
;	ACCESS_MODE	(R4): access mode of accessor
;	MODE_PROT	(R5): access mode protection vector
;
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	NONE
;
; ROUTINE VALUE:
;	SS$_NORMAL: access granted
;	SS$_NOPRIV: access denied
;
; SIDE EFFECTS:
;	NONE
;
;--

EXE$CHECKACMODE::
	PUSHL	R9			; save work regs
	PUSHL	R8
	MOVL	#SS$_NOPRIV,R0		; assume failure
	CMPL	R5,#4			; value or vector?
	BGTRU	10$			; xfer if a vector
;
; Perform a simple access mode check.
;
	CMPL	R4,R5			; else check for inner mode
	BLEQU	30$			; xfer if so
	BRB	40$			; else note failure
;
; Perform the per-access mode check.
;
10$:	CLRL	R9			; reset index
20$:	SUBL3	R9,#32,R8		; compute bits left to test
	FFS	R9,R8,R3,R9		; find next access bit set
	BEQL	30$			; no more bits found - done
	ADDL3	R9,R9,R8		; two bits at a time
	CMPZV	R8,#2,(R5),R4		; accessor mode more privileged?
	BLSSU	40$			; xfer if not
	AOBLSS	#32,R9,20$		; move to next bit and loop

30$:	MOVL	#SS$_NORMAL,R0		; else set access allowed
40$:	MOVL	(SP)+,R8		; restore work regs
	MOVL	(SP)+,R9
	RSB				;   and return

	.SBTTL	EXE$CHECKCLASS - DO NON-DISCRETIONARY SECURITY CHECK

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine performs the non-discretionary security check, using
;	the specified security and integrity levels and category masks.
;
; CALLING SEQUENCE:
;	JSB EXE$CHECKCLASS
;
; INPUT PARAMETERS:
;	PRIV_MASK	(R2): address of accessor privilege mask
;	ACCESS		(R3): bitmask of access requested
;			      bit 0 => read
;			      bit 1 => write
;	ACC_CLASS	(R4): address of accessor's classification
;	MIN_CLASS	(R5): address of minimum classification of object
;	MAX_CLASS	(R6): address of maximum classification of object
;
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;	PRIVS_USED	(R1): bitmask of privileges used to gain access
;
; IMPLICIT OUTPUTS:
;	NONE
;
; ROUTINE VALUE:
;	SS$_NORMAL if access granted
;	SS$_NOPRIV if access denied
;
; SIDE EFFECTS:
;	NONE
;
;--

EXE$CHECKCLASS::
	CLRL	R1			; no privileges used yet
;
; Check for read access requested.
;
	ASSUME	CHP$M_READ EQ 1
	BLBC	R3,10$
;
; Check the security level using the simple securrity property.
;
	CMPB	CLS$B_SECUR_LEV(R4),CLS$B_SECUR_LEV(R5)		; access > min?
	BLSSU	60$						; no, fail it
	BICL3	CLS$Q_SECUR_CAT(R4),CLS$Q_SECUR_CAT(R5),R0	; low part OK?
	BNEQ	60$						; xfer if not
	BICL3	CLS$Q_SECUR_CAT+4(R4),CLS$Q_SECUR_CAT+4(R5),R0	; high part OK?
	BNEQ	60$				; xfer if high part checks out
;
; Check the integrity level using the simple integrity property.
;
	CMPB	CLS$B_INTEG_LEV(R6),CLS$B_INTEG_LEV(R4)		; access < max?
	BLSSU	60$						; no, fail it
	BICL3	CLS$Q_INTEG_CAT(R6),CLS$Q_INTEG_CAT(R4),R0	; low part OK?
	BNEQ	60$						; xfer if not
	BICL3	CLS$Q_INTEG_CAT+4(R6),CLS$Q_INTEG_CAT+4(R4),R0	; high part OK?
	BNEQ	60$				; xfer if high part does not check out
;
; Check for write access requested.
;
	BBC	#CHP$V_WRITE,R3,50$		; see if write access requested
;
; Check the security level using the star property.
;
10$:	CMPB	CLS$B_SECUR_LEV(R6),CLS$B_SECUR_LEV(R4)		; access < max?
	BLSSU	20$						; no, fail it
	BICL3	CLS$Q_SECUR_CAT(R6),CLS$Q_SECUR_CAT(R4),R0	; low part OK?
	BNEQ	20$						; xfer if not
	BICL3	CLS$Q_SECUR_CAT+4(R6),CLS$Q_SECUR_CAT+4(R4),R0	; high part OK?
	BEQL	30$				; xfer if high part checks out

20$:	BBC	#PRV$V_DOWNGRADE,(R2),60$ ; branch if no DOWNGRADE
	BISL	#CHP$M_DOWNGRADE,R1	; else note the use
;
; Check the integrity level using the star property.
;
30$:	CMPB	CLS$B_INTEG_LEV(R4),CLS$B_INTEG_LEV(R5)		; access > min?
	BLSSU	40$						; no, fail it
	BICL3	CLS$Q_INTEG_CAT(R4),CLS$Q_INTEG_CAT(R5),R0	; low part OK?
	BNEQ	40$						; xfer if not
	BICL3	CLS$Q_INTEG_CAT+4(R4),CLS$Q_INTEG_CAT+4(R5),R0	; high part OK?
	BEQL	50$						; branch if OK

40$:	BBC	#PRV$V_UPGRADE,(R2),60$ ; branch if no UPGRADE
	BISL	#CHP$M_UPGRADE,R1	; else note the use

50$:	MOVL	#SS$_NORMAL,R0		; note access granted
	RSB
60$:	MOVL	#SS$_NOPRIV,R0		; note denial of access
	RSB

	.SBTTL	EXE$CHECK_BYPASS - CHECK FOR BYPASS OR READALL PRIVILEGES

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine checks for either the BYPASS privilege (regardless of the
;	access desired) or the READALL privilege and read access.  In which
;	case, success is returned.  Otherwise access is denied.
;
; CALLING SEQUENCE:
;	JSB	EXE$CHECK_BYPASS
;
; INPUT PARAMETERS:
;	STATUS		(R0): protection check status so far
;	PRIV_MASK	(R2): address of the accessor privilege mask
;	ACCESS		(R3): bitmask of access requested
;
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;	STATUS		(R0): success or failure, depending on privs
;	PRIVS_USED	(R1): bitmask if privileges used to gain access
;
; IMPLICIT OUTPUTS:
;	NONE
;
; ROUTINE VALUE:
;	SS$_NORMAL: access is granted
;	SS$_NOPRIV: access is denied
;
; SIDE EFFECTS:
;	NONE
;
;--

EXE$CHECK_BYPASS::
	CLRL	R1			; no privs used so far
	CMPL	R0,#SS$_NOPRIV		; see if we are in fact checking NOPRIV
	BEQL	10$			; Xfer if so, see if privilege override
	CMPL	R0,#SS$_IVACL		; Else check for an invalid ACL
	BNEQ	40$			; Xfer if error cannot be overridden
10$:	BBC	#CHP$V_USEREADALL,R3,20$ ; xfer if READALL not applicable
	BBC	#PRV$V_READALL,(R2),20$	; branch if no READALL
	BISL2	#CHP$M_READALL,R1	; else note READALL used
	BRB	30$			; successful

20$:	BBC	#PRV$V_BYPASS,(R2),40$	; branch if no BYPASS
	BISL2	#CHP$M_BYPASS,R1	; else note BYPASS used

30$:	MOVL	#SS$_NORMAL,R0		; set success
40$:	RSB				; and return to caller

	.END
