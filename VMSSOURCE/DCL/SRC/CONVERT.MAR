	.TITLE CONVERT - DCL VALUE CONVERSION AND EDITING SUBROUTINES
	.IDENT	'V04-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:	DCL
;
; ABSTRACT:	Value conversion and editing subroutines
;
; AUTHOR:	Peter George
;
; DATE:		01-MAR-1983
;
; MODIFIED BY:
;
;	V03-006	HWS0096		Harold Schutlz		27-Jul-1984
;		Fix HWS0082 to correctly handle null strings.
;
;	V03-005	HWS0082		Harold Schultz		19-Jul-1984
;		Fix DCL$CNVASCBIN to not return success if processing
;		a string of all uniary operators without any numbers.
;
;	V03-004	PCG0004		Peter George		11-Jan-1984
;		Add lowercase to edit.
;
;	V03-003	PCG0003		Peter George		15-Jul-1983
;		Use multi-national upcase algorithm.
;
;	V03-002	PCG0002		Peter George		15-Jun-1983
;		Fix bug in DCL$CBTA_HEXSTR.
;
;	V03-001	PCG0001		Peter George		09-May-1983
;		Add DCL$CBTA_HEXSTR.
;--

	.SBTTL	DECLARATIONS
;
; MACRO LIBRARY CALLS
;
	WRKDEF				; DEFINE COMMAND WORK AREA
	EDITDEF				; DEFINE EDIT FLAGS
	$CLIMSGDEF			; CLI MESSAGE DEFINITIONS

	.PSECT	DCL$ZCODE	BYTE,RD,NOWRT
 
;
; OWN STORAGE:
;
CNVRDX:	.ASCII	\ODX\			; CONVERSION RADIX CONTROLS
RADIX:	.BYTE	16,10,8			; CORRESPONDING RADIX VALUES
DIGIT_TABLE:				; HEX DIGITS
	.ASCII	'0123456789ABCDEF'

	.SBTTL	ASCII NUMERIC VALUE CONVERSION ROUTINE
;++
;
; DCL$CNVASCBIN - CONVERT ASCII STRING TO BINARY VALUE
;
; THIS ROUTINE IS CALLED TO CONVERT AN ASCII STRING TO A BINARY VALUE.
;
; INPUTS:
;
;	R1 = DEFAULT RADIX INDICATOR, 0=HEX,1=DECIMAL,2=OCTAL
;	R2/R3 = QUADWORD DESCRIPTOR OF VALUE
;
; OUTPUTS:
;
;	R0 = 0 IF SUCCESSFUL, NONZERO IF FAILURE
;	R1 = CONVERTED BINARY VALUE
;
;--
DCL$CNVASCBIN::				; CONVERT IN SPECIFIED RADIX
	PUSHL	R1			; SAVE R1
	MOVQ	R2,R1			; SET UP THE ARGUMENT REGISTERS
	BSBW	DCL$TRIM		; TRIM AND UPCASE THE STRING
	MOVQ	R1,R2			; RETURN STRING TO R2/R3
	POPL	R1			; RESTORE R1

DCL$CNVNOEDIT::				; CONVERT NUMERIC DECIMAL RADIX
	CLRL	-(SP)			; SAVE ROOM FOR  "NUMBER SEEN" FLAG
	PUSHAB	(R2)[R3]		; SAVE ADDRESS OF END OF STRING
	PUSHL	#0			; SET NO NEGATE FLAG
	MOVL	R2,R0			; TEST FOR ZERO LENGTH STRING
	BEQL	70$			; IF IT IS THE NULL STRING-RETURN ZERO
	MOVL	#1,8(SP)		; INIT. "NUMBER SEEN" FLAG
5$:	CMPB	#^A/%/,(R3)		; RADIX CHANGE OPERATOR?
	BNEQ	10$			; BR IF NO
	INCL	R3			; SKIP OVER OPERATOR
	LOCC	(R3)+,#3,CNVRDX		; FIND RADIX SPECIFIER
	BEQL	70$			; BR IF NONE RECOGNIZED
	MOVAB	-(R0),R1		; SET RADIX INDICATOR
	BRB	5$			; LOOK FOR AN OTHER SET
10$:	CMPB	#^A/+/,(R3)		; CHECK FOR UNIARY OPERATOR OF PLUS
	BEQL	20$			; BR IF YES
	CMPB	#^A/-/,(R3)		; HOW ABOUT MINUS
	BNEQ	30$			; BR IF NO
	INCL	(SP)			; NEGATE THE NEGATIVE FLAG
20$:	INCL	R3			; SKIP THE UNIARY OPERATOR
	BRB	5$			; LOOK FOR ANOTHER
30$:	MOVZBL	RADIX[R1],R2		; SET ACTUAL RADIX OF CONVERSION
	CLRQ	R0			; START WITH RESULT AND WORK VALUE OF 0
40$:	SUBB3	#^A/0/,(R3),R1		; GET NEXT NUMBER MINUS ASCII BIAS
	BLSS	70$			; BR IF NOT A NUMERIC CHARACTER
	CMPB	R1,#9			; WAS IT A NUMERIC DIGIT?
	BLEQ	60$			; BR IF YES
	CMPB	R1,#<^A/A/-^A/0/>	; HEX RADIX CHARACTER?
	BLSS	70$			; BR IF NO - TERMINATE THE CONVERT
	SUBB	#<<^A/A/-^A/0/>-10>,R1	; CONVERT TO BINARY VALUE
60$:	CMPB	R1,R2			; WITH IN THE RADIX?
	BGEQ	70$			; BR IF OUT OF THE RANGE
	EMUL	R2,R0,R1,R0		; FIND CURRENT TOTAL
	CLRL	8(SP)			; INDICATE AT LEAST ONE NUMBER PROCESSED
	INCL	R3			; POINT AT NEXT CHARACTER
	CMPL	R3,4(SP)		; TIME TO QUIT?
	BNEQ	40$			; BR IF NO
70$:	MOVL	R0,R1			; SET RESULT
	BLBC	(SP)+,80$		; TEST NEGATE FLAG
	MNEGL	R1,R1			; NEGATE THE SOURCE
80$:	SUBL3	R3,(SP)+,R0		; SET NUMBER OF UN-PROCESSED BYTES
	BLBC	(SP)+,90$		; IF A NUMBER SEEN, FLAG OK AS IS
	MOVL	#1,R0			; IF NO NUMBER SEEN, UNCONDITIONALLY
					;	SET TO FAILURE
90$:	RSB				; BACK TO THE CALLER


	.SBTTL	CONVERT BINARY TO 8-DIGIT HEX
;+ 
; DCL$CBTA_HEX - CONVERT BINARY TO HEX STRING
;
; CONVERT A BINARY NUMBER TO A HEX STRING OF EXACTLY 8 DIGITS.
;
; INPUTS:
;
;	R0 = NUMBER TO BE CONVERTED.
;
; OUTPUTS:
;
;	R1 = LENGTH OF CONVERTED VALUE.
;	R2 = ADDRESS OF CONVERTED VALUE.
;-

DCL$CBTA_HEX::
	MOVL	#4,R1			;CREATE DESCRIPTOR OF HEX STRING
	PUSHL	R0			;
	MOVL	SP,R2			;
	BSBB	DCL$CBTA_HEXSTR		;GET CONVERTED VALUE
	TSTL	(SP)+			;RESTORE THE STACK
	RSB				;RETURN

DCL$CBTA_HEXSTR::
	SUBL	R1,SP			;ALLOCATE SCRATCH BUFFER ON THE STACK
	PUSHL	R1			;SAVE INPUT LENGTH
	MOVC	R1,(R2),4(SP)		;COPY INPUT BUFFER
	POPL	R5			;RESTORE INPUT LENGTH
	MOVL	WRK_L_EXPANDPTR(R10),R2	;MARK POSITION IN OUTPUT BUFFER
	ASHL	#1,R5,R3		;DOUBLE THE NUMBER OF INPUT BYTES

	DECL	R5			;START WITH LAST BYTE OF DATA
10$:	EXTZV	#4,#4,(SP)[R5],R0	;GET SECOND NIBBLE OF BYTE
	MOVZBL	DIGIT_TABLE[R0],R0	;CONVERT DIGIT TO ASCII
	BSBW	DCL$PUTCHAR		;PUT THE CHAR IN THE OUTPUT BUFFER
	EXTZV	#0,#4,(SP)[R5],R0	;GET FIRST NIBBLE OF BYTE
	MOVZBL	DIGIT_TABLE[R0],R0	;CONVERT DIGIT TO ASCII
	BSBW	DCL$PUTCHAR		;PUT THE CHAR IN THE OUTPUT BUFFER
	SOBGEQ	R5,10$			;BRANCH WHILE MORE DIGITS

20$:	SUBL3	R2,WRK_L_EXPANDPTR(R10),R1 ;GET DESCRIPTOR OF RESULTANT STRING
	MOVL	R2,WRK_L_EXPANDPTR(R10)	;RESET EXPANSION BUFFER POINTER
	ASHL	#-1,R1,R0		;GET THE NUMBER OF INPUT BYTES
	ADDL	R0,SP			;POP SCRATCH BUFFER OFF THE STACK
	RSB				;

	.SBTTL	CONVERT BINARY TO ZERO SUPRESSED ASCII
;+ 
; CBTA_DEC - CONVERT BINARY TO ASCII BASE TEN
; CBTA_OCT - CONVERT BINARY TO ASCII BASE EIGHT
;
; THESE ROUTINES ARE CALLED TO CONVERT A BINARY NUMBER TO A LEFT JUSTIFIED, ZERO
; SUPRESSED, ASCII STRING.  THE RESULTANT STRING IS PLACED IN THE EXPANSION
; BUFFER AND THE EXPANSION POINTER IS UPDATED.
;
; INPUTS:
;
;	R0 = NUMBER TO BE CONVERTED.
;
; OUTPUTS:
;
;	R1 = LENGTH OF CONVERTED VALUE.
;	R2 = ADDRESS OF CONVERTED VALUE.
;-
	.ENABL	LSB

DCL$CBTA_OCT::				;CONVERT BINARY TO ASCII BASE EIGHT
	MOVZBL	#8,R3			;SET CONVERSION RADIX
	BRB	10$			;
DCL$CBTA_DEC::				;CONVERT BINARY TO ASCII BASE TEN
	MOVZBL	#10,R3			;SET CONVERSION RADIX
10$:	MOVL	WRK_L_EXPANDPTR(R10),R2	;MARK POSITION IN BUFFER
	TSTL	R0			;IS NUMBER NEGATIVE?
	BGEQ	15$			;NO, THEN SKIP
	MNEGL	R0,R4			;YES, THEN CHANGE SIGN AND SAVE VALUE
	MOVZBL	#^A"-",R0		;GET NEGATIVE SIGN
	BSBW	DCL$PUTCHAR		;PUT IT IN THE EXPANSION BUFFER
	MOVL	R4,R0			;RECOVER VALUE
15$:	BSBB	20$			;PUT ASCII CHARACTERS INTO BUFFER
	SUBL3	R2,WRK_L_EXPANDPTR(R10),R1 ;GET DESCRIPTOR OF RESULTANT STRING
	MOVL	R2,WRK_L_EXPANDPTR(R10)	;RESET EXPANSION BUFFER POINTER
	RSB
;
; RECURSIVE ROUTINE TO OUTPUT THE ASCII NUMBER, HIGH ORDER DIGITS FIRST
; WITHOUT ANY LEADING SPACES OR ZEROS.
;
20$:	CLRL	R1			;CLEAR HIGH PART OF DIVIDEND
	EDIV	R3,R0,R0,R1		;ISOLATE NEXT DIGIT
	ADDL3	#^A'0',R1,-(SP)		;CONVERT DIGIT TO ASCII AND SAVE
	TSTL	R0			;ANY MORE DIGITS TO CONVERT?
	BEQL	30$			;IF EQL NO
	BSBB	20$			;CONVERT NEXT DIGIT
30$:	POPL	R0			;RETRIEVE NEXT CHARACTER
	BSBW	DCL$PUTCHAR		;PUT CHARACTER IN EXPANSION BUFFER
	RSB

	.DSABL	LSB
 

	.SBTTL	EDIT THE STRING
;+ 
; DCL$EDIT  - EDIT THE STRING
;
; THIS ROUTINE IS CALLED TO EDIT THE INPUT STRING.  THE RESULTANT STRING 
; IS RETURNED VIA THE INPUT DESCRIPTOR.
; 
; INPUTS:
;
;	R0 = EDIT FLAGS
;	R1 = LENGTH OF INPUT STRING
;	R2 = ADDRESS OF INPUT STRING
;
; OUTPUTS:
;
;	R1 = LENGTH OF EDITED STRING
;	R2 = ADDRESS OF EDITED STRING
;-

DCL$TRIM::
	MOVL	#EDIT_M_UPCASE!EDIT_M_TRIM,R0	; SET UPCASE AND TRIM FLAGS
	BRB	DCL$EDIT

DCL$SQUEEZE::
	MOVL	#EDIT_M_UPCASE!EDIT_M_COLLAPSE,R0 ; SET UPCASE AND COLLAPSE FLAGS
	BRB	DCL$EDIT

DCL$UPCASE::
	MOVL	#EDIT_M_UPCASE,R0		; SET UPCASE FLAG

DCL$EDIT::
	TSTL	R1				; IS LENGTH ZERO
	BEQL	6$				; YES, THEN DONE
	TSTL	R0				; ARE NO FLAGS SET
	BEQL	6$				; YES, THEN DONE
	MOVQ	R3,-(SP)			; SAVE R3,R4
	MOVL	R2,R3				; COPY ADDRESS OF STRING
	MOVL	R2,R4				; COPY ADDRESS OF STRING
	MOVL	R2,-(SP)			; COPY ADDRESS OF STRING
	CLRL	-(SP)				; CLEAR FLAGS

;
; IF CHARACTER IS A QUOTE THEN TOGGLE THE FLAG, AND COPY THE CHARACTER
;
5$:	CMPB	#^A/"/,(R3)			; IS CHARACTER A QUOTE
	BNEQ	7$				; NO, THEN BRANCH
	XORL	#1,(SP)				; YES, TOGGLE QUOTE FLAG
	BRB	30$				; COPY THE CHARACTER

6$:	BRW	50$				; ALL DONE

;
; IF INSIDE QUOTES, THEN COPY THE CHARACTER
;
7$:	BLBS	(SP),30$			; IF IN QUOTES, COPY THE CHAR

;
; IF REMOVING COMMENTS, AND COMMENT CHARACTER WAS FOUND, THEN WE'RE ALL DONE.
;
	BBC	#EDIT_V_UNCOMMENT,R0,10$	; BRANCH IF NOT IGNORING COMMENTS
	CMPB	#^A/!/,(R3)			; IS CHARACTER A COMMENT DELIMITER
	BEQL	42$				; YES, THEN DONE

;
; IF WE ARE COMPRESSING BLANKS, THEN EITHER SET THE BLANK FLAG, OR
; REMOVE THE CHARACTER.  ALSO, SAVE THE ADDRESS OF THE FIRST BLANK
; IN CASE WE ARE TRIMMING BLANKS.
;
10$:	CMPB	#^X20,(R3)			; IS CHARACTER A BLANK
	BEQL	15$				; YES, PROCESS IT
	CMPB	#^X09,(R3)			; IS CHARACTER A TAB
	BNEQ	20$				; NO, THEN BRANCH
15$:	BBS	#EDIT_V_COLLAPSE,R0,18$		; BRANCH IF COLLAPSING
	BBC	#EDIT_V_TRIM,R0,16$		; BRANCH IF NOT TRIMMING
	BBC	#2,(SP),18$			; REMOVE LEADING BLANKS
16$:	BBC	#EDIT_V_COMPRESS,R0,17$		; BRANCH IF NOT COMPRESSING
	MOVB	#^X20,(R3)			; CONVERT SPACE OR TAB TO SPACE
	BBSS	#1,(SP),18$			; IF NOT FIRST BLANK, THEN SKIP IT
17$:	MOVB	(R3),(R4)+			; COPY THE CHARACTER
18$:	INCL	R3				; POINT PAST THE BLANK
	BRB	40$				; LOOP

;
; IF WE ARE UPCASING THE STRING, THEN NOW DO SO.
;
20$:	BBC	#EDIT_V_UPCASE,R0,26$		; BRANCH IF NOT UPCASING
	CMPB	(R3),#^A/a/			; CHECK LOW LIMIT OF LOW RANGE
	BLSSU	30$				; BR IF FAILED
	CMPB	(R3),#^A/z/			; CHECK HIGH LIMIT OF LOW RANGE
	BLEQU	25$				; BR IF VALID CHARACTER
	CMPB	(R3),#^XE0			; CHECK LOW LIMIT OF HIGH RANGE
	BLSSU	30$				; BR IF FAILED
	CMPB	(R3),#^XFE			; CHECK HIGH LIMIT OF HIGH RANGE
	BGTRU	30$				; BR IF FAILED
25$:	BICB	#^X20,(R3)			; UPCASE THE CHARACTER
	BRB	30$				;

29$:	BRB	5$

;
; IF WE ARE LOWERCASING THE STRING, THEN NOW DO SO.
;
26$:	BBC	#EDIT_V_LOWERCASE,R0,30$	; BRANCH IF NOT LOWERCASING
	CMPB	(R3),#^A/A/			; CHECK LOW LIMIT OF LOW RANGE
	BLSSU	30$				; BR IF FAILED
	CMPB	(R3),#^A/Z/			; CHECK HIGH LIMIT OF LOW RANGE
	BLEQU	27$				; BR IF VALID CHARACTER
	CMPB	(R3),#^XC0			; CHECK LOW LIMIT OF HIGH RANGE
	BLSSU	30$				; BR IF FAILED
	CMPB	(R3),#^XDE			; CHECK HIGH LIMIT OF HIGH RANGE
	BGTRU	30$				; BR IF FAILED
27$:	BISB	#^X20,(R3)			; LOWERCASE THE CHARACTER

;
; COPY THE CHARACTER TO THE RESULT STRING.  SUBTRACT ONE FROM THE INPUT LENGTH
; AND CONTINUE.
;
30$:	MOVB	(R3)+,(R4)+			; MOVE CHARACTER
	BICL	#2,(SP)				; CLEAR BLANK FLAG
	BISL	#4,(SP)				; SET FIRST NON-BLANK SEEN
	MOVL	R4,4(SP)			; SAVE ADDR OF LAST NON-BLANK
40$:	SOBGTR	R1,29$				; LOOP TILL DONE

;
; GET THE RESULT STRING.  DO ANY TRIMMING THAT IS NECESSARY
;
42$:	SUBL3	R2,R4,R1			; CALCULATE NEW LENGTH
	MOVQ	(SP)+,R3			; RESTORE STACK
	BBC	#EDIT_V_TRIM,R0,45$		; BRANCH IF NOT TRIMMING
	SUBL3	R2,R4,R1			; CALCULATE SIZE AFTER TRIM
45$:	MOVQ	(SP)+,R3			; RESTORE REGISTERS
50$:	RSB

	.END
