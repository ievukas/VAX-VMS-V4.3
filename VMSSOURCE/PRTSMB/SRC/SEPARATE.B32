MODULE SEPARATE ( %TITLE 'Print Symbiont -- separation routines'
	IDENT = 'V04-001',
	ADDRESSING_MODE (EXTERNAL = GENERAL)
	) =
BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY:
!	Print Symbiont.
!
! ABSTRACT:
!	File and module input routines.
!
! ENVIRONMENT:
!	VAX/VMS user mode.
!--
!
! AUTHOR: Rowland R. Bradley
!
! CREATION DATE: April 1, 1984
!
! MODIFIED BY:
!
!	40-001	RRB0006		Rowland R. Bradley	14-Aug-1984
!		Add a <CR> to  the page header.  This fixes QAR 0682
!		QAR 1737, loss  of first line of data of every page.
!
!	3B-005  RRB0005		Rowland R. Bradley	02-Aug-1984
!		Remove the phrase "in this file" in (file) record description.
!		Remove extra spaces in job description after start date
!		and after queued to date.  Slightly alter filename algorithm to
!		avoid placing long filename on a single line and NOT displaying
!		the type and version (or vice versa).  Add a call to
!		PSM$READ_ITEM_DX in GET_QUALIFIERS to test correctness(this 
!		is my call and will remain as a test).  Modify the file trailer
!		page to avoid an ugly truncation of the input file.  Add the
!		acronym "UIC" to the job description sentence.  Add /FEED and
!		/NOFEED to the list of qualifiers in GET_QUALIFIERS.
!		
!
!	3B-004	RRB0004		Rowland R. Bradley	04-May-1984
!		Avoid truncation of the Job Flag Page when burst pages
!		are not specified.
!
!	3B-003	GRR0003		Gregory R. Robert	29-Apr-1984
!		Removed reference to JBC$_JOBREQUEUE until job controller
!		message definitions appear in LIB.L32.  Changed ABORTED
!		and REQUEUED words in job sentence to uppercase for emphasis.
!		Considered left and right margins in computing page header
!		size.  Create page header only once per task.  Fix page header
!		to have file revision date instead of revision number.
!
!	3B-002	RRB0002		Rowland R. Bradley	27-Apr-1984
!		Add dynamic Page_Header routine, display all queue qualifiers
!		in a single phrase, fix form feed and line one problems, print
!		/setup_file & /setup_form,  insert job number in burst chars,
!		FIX: footer bar, devicename, receipt box, file desc sentence,
!		     trailer header bar, digital_logo dynamics, /width,
!		     psm$announce display size, fab valid bit, page setup quals.
!
!	3B-001  RRB0001		Rowland R. Bradley	01-Apr-1984
!		Original version
!
!**

LIBRARY 'SYS$LIBRARY:LIB';
REQUIRE 'LIB$:SMBDEF';
REQUIRE 'SRC$:SMBREQ';

EXTERNAL ROUTINE
	PSM$BANNER,
	PSM$READ_ITEM_DX			! strictly to test behavior
	;

LITERAL
	UPCASE_MASK= %B '0100000',		! lowercase to uppercase
	LEAD_MASK  = %B '001000',		! delete leading blanks
	SIZE	= 0,
	ADDR	= 1
	;

OWN
	BURST
	;

FORWARD ROUTINE
	PSM$FILE_BURST		,
	PSM$FILE_FLAG		,
	PSM$FILE_TRAILER	,
	PSM$JOB_BURST		,
	PSM$JOB_FLAG		,
	PSM$JOB_TRAILER		,
	PSM$PAGE_HEADER		,

	PARSE_FILE_NAME		,
	ALLOCATE_PAGE		,
	DEALLOCATE_PAGE		,
	CREATE_PAGE_HEADER	,
	RETURN_FRAME_LENGTH	,
	RETURN_FRAME_WIDTH	,
	FILL_JOB_FLAG		: NOVALUE,
	FILL_FILE_FLAG		: NOVALUE,
	FILL_JOB_TRAILER	: NOVALUE,
	FILL_FILE_TRAILER	: NOVALUE,
	GET_FORM_SIZE		: NOVALUE,
	GET_REVISION_DATE	: NOVALUE,
	GET_SYSTEM_ANNOUNCEMENT	: NOVALUE,
	GET_JOB_DESCRIPTION	: NOVALUE,
	GET_FILE_DESCRIPTION	: NOVALUE,
	GET_FILE_NAME		: NOVALUE,
	GET_JOB_NAME		: NOVALUE,
	GET_EOJ			: NOVALUE,
	GET_EOF			: NOVALUE,
	GET_ACCOUNTING_INFO	: NOVALUE,
	GET_QUALIFIERS		: NOVALUE,
	GET_QUEUE_QUALIFIERS	: NOVALUE,
	GET_USER_NOTE		: NOVALUE,
	GET_RECEIPT_BOX		: NOVALUE,
	GET_VMS_LOGO		: NOVALUE,
	GET_DIGITAL_LOGO	: NOVALUE,
	GET_RULER_FINE		: NOVALUE,
	GET_RULER_COARSE	: NOVALUE,
	SCROLL_FRAME		: NOVALUE,	! scrolls/fills frame w/ string
	FILL_FRAME		: NOVALUE,	! fills a frame with chars
	MOVE_FRAME		: NOVALUE,	! inserts undelimited strings
	INSERT_FRAME		: NOVALUE,	! inserts delimited strings
	CENTER_FRAME		: NOVALUE,	! centers undelimited strings
	MERGE_FRAME		: NOVALUE,	! merges "pure" frames
	INSERT_NAME_BANNER	,		! inserts banners into frames
	INSERT_FILENAME_BANNER	,		! inserts banners into frames
	INSERT_JOBNUMBER_BANNER	,		! inserts banners into frames
	DELIMIT_STRING		,		! delimits strings
	DELIMIT_STRING_NOT	,		! delimits strings
	FIND_DEST_PTR		: NOVALUE,	! identifies "pure" frames
	FIND_SOURCE_PTR		: NOVALUE,	! identifies "impure" frames
	DISCARD			: NOVALUE,	! discards chars in strings
	FILE_OPEN				! determines file accessibility
	;


%sbttl 'PSM$FILE_BURST - Print a File Burst Page'
! Functional Description:
!	This routine controls the creation of the file burst page.  The 
!	FUNCTION code dictates the action taken in creation.
!	FUNCTION:
!		OPEN  - Allocate and create the File Burst Page
!		READ  - Return the current line of the File Burst Page
!		CLOSE - Return the buffer allocated on OPEN
!
! Formal Parameters:
!		SMB_CONTEXT   - Pointer to the SMB
!		USER_CONTEXT  - User defined pointer (not used here)
!		FUNCTION      - OPEN, READ, CLOSE
!		FUNC_DESC     - Pointer to functionally dependent descriptor
!		FUNC_ARG      - Pointer to functionally dependent argument
!
! Implicit Inputs:
!		none
!
! Implicit Outputs:
!		none
!
! Returned Value:
!		none
!
! Side Effects:
!		none
!--
GLOBAL ROUTINE PSM$FILE_BURST ( %SBTTL 'FILE_BURST'
	SMB_CONTEXT	: REF VECTOR,
	USER_CONTEXT	: REF VECTOR,
	FUNCTION	: REF VECTOR,
	FUNC_DESC	: REF VECTOR,
	FUNC_ARG	: REF VECTOR
	)	=
BEGIN

LOCAL
	SCB		: REF $BBLOCK,
	STATUS,
	FORM_WIDTH,
	FORM_LENGTH,
	FORM_SIZE,
	PAGE_REF	: REF PAGE_ARRAY,	! Declare the pointer to page
	BUFFER		: VECTOR [512,byte],	! Assume max size 512 bytes
	STRING_DESC	: VECTOR [2];		! Descriptor to current string


SCB = .SMB_CONTEXT[0];

! Check the FUNCTION requested

SELECTONEU .FUNCTION[0] OF
SET
    [PSM$K_READ]:
	BEGIN
	PAGE_REF = .SCB[PSM$A_PAGE_POINTER];
						!   Output one line at a time
	IF .SCB[PSM$L_RECORD_NUMBER] GTR (.SCB[PSM$L_PAGE_LENGTH]-6) THEN
	    RETURN PSM$_EOF;

	FUNC_DESC[SIZE] = .SCB[PSM$L_PAGE_WIDTH];
	FUNC_DESC[ADDR] = PAGE_REF[0,.SCB[PSM$L_RECORD_NUMBER],
				   .SCB[PSM$L_PAGE_WIDTH]];

				 ! adjust pointer
	FUNC_DESC[SIZE] = DELIMIT_STRING_NOT (.FUNC_DESC[ADDR], 
					      %CHAR(32), .FUNC_DESC[SIZE]);

	END;

    [PSM$K_OPEN]:
	BEGIN

	GET_FORM_SIZE (.SCB);			! Returns the WidthxLength


	FORM_WIDTH	= .SCB[PSM$L_PAGE_WIDTH];
	FORM_LENGTH	= .SCB[PSM$L_PAGE_LENGTH];

	RETURN_IF_ERROR_(ALLOCATE_PAGE( .SCB));	! Get the page of memory

	PAGE_REF = .SCB[PSM$A_PAGE_POINTER];	! My local page pointer

	! Allocate the buffer for "GET_xxx" Routines
	!
	STRING_DESC[SIZE] = %ALLOCATION(BUFFER);	! allocate for routines
	STRING_DESC[ADDR] = BUFFER;			! init address 
    
	! No Form_feed for the burst page

	! Format the page identically to File Flag
	!  Standard Burst Page 132x66:  text covers rows 2 through 60,  
	!    translated to frames... ref starts at 2 and length is 58.
	FILL_FILE_FLAG(
		    .SCB,
		    PAGE_REF[0,2,.FORM_WIDTH],
		    .FORM_WIDTH,
		    .FORM_LENGTH - 6 - 2 );		! bottom margin is 6
							! 2 spaces at the top
	END;
    [PSM$K_CLOSE]: 			! Return the Page of Memory
	RETURN_IF_ERROR_(DEALLOCATE_PAGE(.SCB));

    [OTHERWISE]:
	RETURN PSM$_FUNNOTSUP;

    TES; ! case .function

SS$_NORMAL

END;

%sbttl 'PSM$FILE_FLAG - Print a File Flag Page'
! Functional Description:
!	This routine controls the creation of the file flag page.  The 
!	FUNCTION code dictates the action taken in creation.
!	FUNCTION:
!		OPEN  - Allocate and create the file Flag Page
!		READ  - Return the current line of the file Flag Page
!		CLOSE - Return the buffer allocated on OPEN
!
! Formal Parameters:
!		SMB_CONTEXT   - Pointer to the SMB
!		USER_CONTEXT  - User defined pointer (not used here)
!		FUNCTION      - OPEN, READ, CLOSE
!		FUNC_DESC     - Pointer to functionally dependent descriptor
!		FUNC_ARG      - Pointer to functionally dependent argument
!
! Implicit Inputs:
!		none
!
! Implicit Outputs:
!		none
!
! Returned Value:
!		none
!
! Side Effects:
!		none
!--

GLOBAL ROUTINE PSM$FILE_FLAG ( %SBTTL 'FILE_FLAG'
	SMB_CONTEXT	: REF VECTOR,
	USER_CONTEXT	: REF VECTOR,
	FUNCTION	: REF VECTOR,
	FUNC_DESC	: REF VECTOR,
	FUNC_ARG	: REF VECTOR
	)	=
BEGIN

LOCAL
	SCB		: REF $BBLOCK,
	STATUS,
	FORM_WIDTH,
	FORM_LENGTH,
	FORM_SIZE,
	BUFFER		: VECTOR [512,byte],	! Assume max size 512 bytes
	STRING_DESC	: VECTOR [2],		! Descriptor to current string
	PAGE_REF	: REF PAGE_ARRAY;	! Declare the pointer 
     						!  to page

SCB = .SMB_CONTEXT[0];

! Check the FUNCTION requested

SELECTONEU .FUNCTION[0] OF
SET
    [PSM$K_READ]:
	BEGIN
	PAGE_REF = .SCB[PSM$A_PAGE_POINTER];
						!   Output one line at a time
	IF (  .SCB[PSM$L_RECORD_NUMBER] GTR .SCB[PSM$L_PAGE_LENGTH])
			OR
	  ( NOT .SEPARATE_FLAG_(FILE_BURST) AND
	.SCB[PSM$L_RECORD_NUMBER] GTR (.SCB[PSM$L_PAGE_LENGTH] - 6) )
		THEN
	    RETURN PSM$_EOF;

	FUNC_DESC[SIZE] = .SCB[PSM$L_PAGE_WIDTH];
	FUNC_DESC[ADDR] = PAGE_REF[0,.SCB[PSM$L_RECORD_NUMBER],
				   .SCB[PSM$L_PAGE_WIDTH]];

				 ! adjust pointer
	FUNC_DESC[SIZE] = DELIMIT_STRING_NOT (.FUNC_DESC[ADDR], 
					      %CHAR(32), .FUNC_DESC[SIZE]);

	END;

    [PSM$K_OPEN]:
	BEGIN

	GET_FORM_SIZE (.SCB);				! Returns the WidthxLength


	FORM_WIDTH	= .SCB[PSM$L_PAGE_WIDTH];
	FORM_LENGTH	= .SCB[PSM$L_PAGE_LENGTH];

	RETURN_IF_ERROR_(ALLOCATE_PAGE( .SCB));		! Get the page of memory

	PAGE_REF = .SCB[PSM$A_PAGE_POINTER];		! My local page pointer

	! Always start at top of page
	!
	PAGE_REF[0,0,.FORM_WIDTH] = PSM$K_CHAR_FF;	! form feed in 0 pos.

	!  Standard Flag Page 132x66:  text covers rows 1 through 58,  
	!    translated to frames... ref starts at 1 and length is 57.
	FILL_FILE_FLAG(  .SCB,
			PAGE_REF[0,1,.FORM_WIDTH],
			.FORM_WIDTH,
			.FORM_LENGTH - 6 - 2 - 1);		! total form length...
							!   6 burst, 2 spaces
							!   top margin of 1
	! Burst always appears on the Flag page, starting at page length - 5
	!  and contiuing to page length.  This leaves a two blank lines
	!  between File flag footer bar and file burst header bar.
	!  This IS the right way to perform a BURST over the crease !
	!
	IF (.SEPARATE_FLAG_(FILE_BURST)) THEN
	    BEGIN
	    STRING_DESC[SIZE] = %ALLOCATION(BUFFER);
	    STRING_DESC[ADDR] = BUFFER;

	    ! determine the correct size of the string to insert
	    !
	    GET_VMS_LOGO
		(.SCB,
	     	STRING_DESC[0],			! Buffer descriptor
		STRING_DESC[SIZE]);		! Returned length

	    INSERT_FRAME 
			(.SCB,
			STRING_DESC[0],
		    	PAGE_REF[10,.FORM_LENGTH-5,.FORM_WIDTH],
			.FORM_WIDTH-20, 1);
	    INSERT_FRAME 
			(.SCB,
			STRING_DESC[0],
		    	PAGE_REF[14,.FORM_LENGTH-4,.FORM_WIDTH],
			.FORM_WIDTH-16, 1);
	    INSERT_FRAME 
			(.SCB,
			STRING_DESC[0],
		    	PAGE_REF[10,.FORM_LENGTH-3,.FORM_WIDTH],
			.FORM_WIDTH-20, 1);
	    INSERT_FRAME 
			(.SCB,
			STRING_DESC[0],
		    	PAGE_REF[14,.FORM_LENGTH-2,.FORM_WIDTH],
			.FORM_WIDTH-16, 1);
	    INSERT_FRAME 
			(.SCB,
			STRING_DESC[0],
		    	PAGE_REF[10,.FORM_LENGTH-1,.FORM_WIDTH],
			.FORM_WIDTH-20, 1);
	    INSERT_FRAME 
			(.SCB,
			STRING_DESC[0],
		    	PAGE_REF[14,.FORM_LENGTH,.FORM_WIDTH],
			.FORM_WIDTH-16, 1);
	    END;
	END;

    [PSM$K_CLOSE]: 			! Return the Page of Memory
	RETURN_IF_ERROR_(DEALLOCATE_PAGE(.SCB));

    [OTHERWISE]:
	RETURN PSM$_FUNNOTSUP;

    TES; ! case .function

SS$_NORMAL

END;

%sbttl 'PSM$FILE_TRAILER - Print a File Trailer Page'
! Functional Description:
!	This routine controls the creation of the file flag page.  The 
!	FUNCTION code dictates the action taken in creation.
!	FUNCTION:
!		OPEN  - Allocate and create the file Flag Page
!		READ  - Return the current line of the file Flag Page
!		CLOSE - Return the buffer allocated on OPEN
!
! Formal Parameters:
!		SMB_CONTEXT   - Pointer to the SMB
!		USER_CONTEXT  - User defined pointer (not used here)
!		FUNCTION      - OPEN, READ, CLOSE
!		FUNC_DESC     - Pointer to functionally dependent descriptor
!		FUNC_ARG      - Pointer to functionally dependent argument
!
! Implicit Inputs:
!		none
!
! Implicit Outputs:
!		none
!
! Returned Value:
!		none
!
! Side Effects:
!		none
!--

GLOBAL ROUTINE PSM$FILE_TRAILER ( %SBTTL 'FILE_TRAILER'
	SMB_CONTEXT	: REF VECTOR,
	USER_CONTEXT	: REF VECTOR,
	FUNCTION	: REF VECTOR,
	FUNC_DESC	: REF VECTOR,
	FUNC_ARG	: REF VECTOR
	) =
BEGIN

LITERAL
	TRAILING = 1;
LOCAL
	SCB		: REF $BBLOCK,
	STATUS,
	FORM_WIDTH,
	FORM_LENGTH,
	FORM_SIZE,
	PAGE_REF	: REF PAGE_ARRAY;	! Declare the pointer 
     						!  to page

SCB = .SMB_CONTEXT[0];

! Check the FUNCTION requested

SELECTONEU .FUNCTION[0] OF
SET
    [PSM$K_READ]:
	BEGIN
	LOCAL  TEMP_PTR;

	PAGE_REF = .SCB[PSM$A_PAGE_POINTER];
						!   Output one line at a time
	IF .SCB[PSM$L_RECORD_NUMBER] GTR (.SCB[PSM$L_PAGE_LENGTH] - 6 - 2) THEN
	    RETURN PSM$_EOF;

	FUNC_DESC[SIZE] = .SCB[PSM$L_PAGE_WIDTH];
	FUNC_DESC[ADDR] = PAGE_REF[0,.SCB[PSM$L_RECORD_NUMBER],
				   .SCB[PSM$L_PAGE_WIDTH]];

				 ! adjust pointer
	FUNC_DESC[SIZE] = DELIMIT_STRING_NOT (.FUNC_DESC[ADDR], 
					      %CHAR(32), .FUNC_DESC[SIZE]);

	END;

    [PSM$K_OPEN]:
	BEGIN

	GET_FORM_SIZE (.SCB);				! Returns the WidthxLength


	FORM_WIDTH	= .SCB[PSM$L_PAGE_WIDTH];
	FORM_LENGTH	= .SCB[PSM$L_PAGE_LENGTH];

	RETURN_IF_ERROR_(ALLOCATE_PAGE( .SCB));		! Get the page of memory

	PAGE_REF = .SCB[PSM$A_PAGE_POINTER];		! My local page pointer

	! Always start at top of page
	!
	PAGE_REF[0,0,.FORM_WIDTH] = PSM$K_CHAR_FF;	! form feed in 0 pos.

	!  Standard Trailer Page 132x66:  text covers rows 1 through 58,  
	!    translated to frames... ref starts at 1 and length is 57.
	FILL_FILE_TRAILER( .SCB,
			  PAGE_REF[0,1,.FORM_WIDTH],
			  .FORM_WIDTH,
			  .FORM_LENGTH - 6 - 2 - 1);	! total form length...
	END;						! ..6 burst, 2 spaces
							! ...top margin of 1

    [PSM$K_CLOSE]: 			! Return the Page of Memory
	RETURN_IF_ERROR_(DEALLOCATE_PAGE(.SCB));

    [OTHERWISE]:
	RETURN PSM$_FUNNOTSUP;

    TES; ! case .function

SS$_NORMAL

END;

%sbttl 'PSM$JOB_BURST - Print a Job Burst Page'
! Functional Description:
!	This routine controls the creation of the job burst page.  The 
!	FUNCTION code dictates the action taken in creation.
!	FUNCTION:
!		OPEN  - Allocate and create the Job Burst Page
!		READ  - Return the current line of the Job Burst Page
!		CLOSE - Return the buffer allocated on OPEN
!
! Formal Parameters:
!		SMB_CONTEXT   - Pointer to the SMB
!		USER_CONTEXT  - User defined pointer (not used here)
!		FUNCTION      - OPEN, READ, CLOSE
!		FUNC_DESC     - Pointer to functionally dependent descriptor
!		FUNC_ARG      - Pointer to functionally dependent argument
!
! Implicit Inputs:
!		none
!
! Implicit Outputs:
!		none
!
! Returned Value:
!		none
!
! Side Effects:
!		none
!--
GLOBAL ROUTINE PSM$JOB_BURST ( %SBTTL 'JOB_BURST'
	SMB_CONTEXT	: REF VECTOR,
	USER_CONTEXT	: REF VECTOR,
	FUNCTION	: REF VECTOR,
	FUNC_DESC	: REF VECTOR,
	FUNC_ARG	: REF VECTOR
	)	=
BEGIN

LOCAL
	SCB		: REF $BBLOCK,
	STATUS,
	FORM_WIDTH,
	FORM_LENGTH,
	FORM_SIZE,
	PAGE_REF	: REF PAGE_ARRAY;	! Declare the pointer 
     						!  to page

SCB = .SMB_CONTEXT[0];

! Check the FUNCTION requested

SELECTONEU .FUNCTION[0] OF
SET
    [PSM$K_READ]:
	BEGIN
	PAGE_REF = .SCB[PSM$A_PAGE_POINTER];
						!   Output one line at a time
	IF .SCB[PSM$L_RECORD_NUMBER] GTR (.SCB[PSM$L_PAGE_LENGTH] - 6)
	THEN
	    RETURN PSM$_EOF;

	FUNC_DESC[SIZE] = .SCB[PSM$L_PAGE_WIDTH];
	FUNC_DESC[ADDR] = PAGE_REF[0,.SCB[PSM$L_RECORD_NUMBER],
				   .SCB[PSM$L_PAGE_WIDTH]];

				 ! adjust pointer
	FUNC_DESC[SIZE] = DELIMIT_STRING_NOT (.FUNC_DESC[ADDR], 
					      %CHAR(32), .FUNC_DESC[SIZE]);

	END;

    [PSM$K_OPEN]:
	BEGIN

	GET_FORM_SIZE (.SCB);				! Returns the WidthxLength


	FORM_WIDTH	= .SCB[PSM$L_PAGE_WIDTH];
	FORM_LENGTH	= .SCB[PSM$L_PAGE_LENGTH];

	RETURN_IF_ERROR_(ALLOCATE_PAGE( .SCB));	! Get the page of memory

	PAGE_REF = .SCB[PSM$A_PAGE_POINTER];	! My local page pointer

	! No form_feed on a burst page

	!  Standard Burst Page 132x66:  text covers rows 2 through 60,  
	!    translated to frames... ref starts at 2 and length is 58.
	FILL_JOB_FLAG(  .SCB,
			PAGE_REF[0,2,.FORM_WIDTH],
			.FORM_WIDTH,
			.FORM_LENGTH - 6 - 2 );		! 6 blank lines
	END;						! top margin is 2

    [PSM$K_CLOSE]: 			! Return the Page of Memory
	RETURN_IF_ERROR_(DEALLOCATE_PAGE(.SCB));

    [OTHERWISE]:
	RETURN PSM$_FUNNOTSUP;

    TES; ! case .function

SS$_NORMAL

END;

%sbttl 'PSM$JOB_FLAG - Print a Job Flag Page'
! Functional Description:
!	This routine controls the creation of the job flag page.  The 
!	FUNCTION code dictates the action taken in creation.
!	FUNCTION:
!		OPEN  - Allocate and create the Job Flag Page
!		READ  - Return the current line of the Job Flag Page
!		CLOSE - Return the buffer allocated on OPEN
!
! Formal Parameters:
!		SMB_CONTEXT   - Pointer to the SMB
!		USER_CONTEXT  - User defined pointer (not used here)
!		FUNCTION      - OPEN, READ, CLOSE
!		FUNC_DESC     - Pointer to functionally dependent descriptor
!		FUNC_ARG      - Pointer to functionally dependent argument
!
! Implicit Inputs:
!		none
!
! Implicit Outputs:
!		none
!
! Returned Value:
!		none
!
! Side Effects:
!		none
!--
GLOBAL ROUTINE PSM$JOB_FLAG ( %SBTTL 'JOB_FLAG'
	SMB_CONTEXT	: REF VECTOR,
	USER_CONTEXT	: REF VECTOR,
	FUNCTION	: REF VECTOR,
	FUNC_DESC	: REF VECTOR,
	FUNC_ARG	: REF VECTOR
	)	=
BEGIN
LITERAL
	TRAILING = 1;

LOCAL
	SCB		: REF $BBLOCK,
	STATUS,
	FORM_WIDTH,
	FORM_LENGTH,
	FORM_SIZE,
	BUFFER		: VECTOR [512,byte],	! Assume max size 512 bytes
	STRING_DESC	: VECTOR [2],		! Descriptor to current string
	PAGE_REF	: REF PAGE_ARRAY;	! Declare the pointer 
     						!  to page

SCB = .SMB_CONTEXT[0];

! Check the FUNCTION requested

SELECTONEU .FUNCTION[0] OF
SET
    [PSM$K_READ]:
	BEGIN
	PAGE_REF = .SCB[PSM$A_PAGE_POINTER];
						!   Output one line at a time
	IF (  .SCB[PSM$L_RECORD_NUMBER] GTR .SCB[PSM$L_PAGE_LENGTH])
			OR
	  ( NOT .SEPARATE_FLAG_(JOB_BURST) AND .SCB[PSM$L_RECORD_NUMBER] 
			GEQ (.SCB[PSM$L_PAGE_LENGTH] - 6 ) )
		THEN
	    RETURN PSM$_EOF;

	FUNC_DESC[SIZE] = .SCB[PSM$L_PAGE_WIDTH];
	FUNC_DESC[ADDR] = PAGE_REF[0,.SCB[PSM$L_RECORD_NUMBER],
				   .SCB[PSM$L_PAGE_WIDTH]];

				 ! adjust pointer
	FUNC_DESC[SIZE] = DELIMIT_STRING_NOT (.FUNC_DESC[ADDR], 
					      %CHAR(32), .FUNC_DESC[SIZE]);

	END;

    [PSM$K_OPEN]:
	BEGIN

	GET_FORM_SIZE (.SCB);				! Returns the WidthxLength


	FORM_WIDTH	= .SCB[PSM$L_PAGE_WIDTH];
	FORM_LENGTH	= .SCB[PSM$L_PAGE_LENGTH];

	RETURN_IF_ERROR_(ALLOCATE_PAGE( .SCB));		! Get the page of memory

	PAGE_REF = .SCB[PSM$A_PAGE_POINTER];		! My local page pointer

	! Always start at top of page
	!
	PAGE_REF[0,0,.FORM_WIDTH] = PSM$K_CHAR_FF;	! form feed in 0 pos.

	!  Standard Flag Page 132x66:  text covers rows 1 through 58,  
	!    translated to frames... ref starts at 1 and length is 57.
	FILL_JOB_FLAG(  .SCB,
			PAGE_REF[0,1,.FORM_WIDTH],
			.FORM_WIDTH,
			.FORM_LENGTH - 6 - 2 - 1);	! 6 burst,
							! 2 spaces before burst,
							! top margin is 1
	IF (.SEPARATE_FLAG_(JOB_BURST))
	THEN
	    BEGIN
	    STRING_DESC[SIZE] = %ALLOCATION(BUFFER);
	    STRING_DESC[ADDR] = BUFFER;

	    GET_VMS_LOGO
		(.SCB,
	     	STRING_DESC[0],			! Buffer descriptor
		STRING_DESC[SIZE]);		! Returned length

	    INSERT_FRAME 
			(.SCB,
			STRING_DESC[0],
		    	PAGE_REF[10,.FORM_LENGTH-5,.FORM_WIDTH],
			.FORM_WIDTH-20, 1);
	    INSERT_FRAME 
			(.SCB,
			STRING_DESC[0],
		    	PAGE_REF[14,.FORM_LENGTH-4,.FORM_WIDTH],
			.FORM_WIDTH-16, 1);
	    INSERT_FRAME 
			(.SCB,
			STRING_DESC[0],
		    	PAGE_REF[10,.FORM_LENGTH-3,.FORM_WIDTH],
			.FORM_WIDTH-20, 1);
	    INSERT_FRAME 
			(.SCB,
			STRING_DESC[0],
		    	PAGE_REF[14,.FORM_LENGTH-2,.FORM_WIDTH],
			.FORM_WIDTH-16, 1);
	    INSERT_FRAME 
			(.SCB,
			STRING_DESC[0],
		    	PAGE_REF[10,.FORM_LENGTH-1,.FORM_WIDTH],
			.FORM_WIDTH-20, 1);
	    INSERT_FRAME 
			(.SCB,
			STRING_DESC[0],
		    	PAGE_REF[14,.FORM_LENGTH,.FORM_WIDTH],
			.FORM_WIDTH-16, 1);
	    END;
	END;

    [PSM$K_CLOSE]: 			! Return the Page of Memory
	RETURN_IF_ERROR_(DEALLOCATE_PAGE(.SCB));

    [OTHERWISE]:
	RETURN PSM$_FUNNOTSUP;

    TES; ! case .function

SS$_NORMAL

END;

%sbttl 'PSM$JOB_TRAILER - Print a Job Flag Page'
! Functional Description:
!	This routine controls the creation of the job trailer page.  The 
!	FUNCTION code dictates the action taken in creation.
!	FUNCTION:
!		OPEN  - Allocate and create the Job Trailer Page
!		READ  - Return the current line of the Job Trailer Page
!		CLOSE - Return the buffer allocated on OPEN
!
! Formal Parameters:
!		SMB_CONTEXT   - Pointer to the SMB
!		USER_CONTEXT  - User defined pointer (not used here)
!		FUNCTION      - OPEN, READ, CLOSE
!		FUNC_DESC     - Pointer to functionally dependent descriptor
!		FUNC_ARG      - Pointer to functionally dependent argument
!
! Implicit Inputs:
!		none
!
! Implicit Outputs:
!		none
!
! Returned Value:
!		none
!
! Side Effects:
!		none
!--
GLOBAL ROUTINE PSM$JOB_TRAILER ( %SBTTL 'JOB_TRAILER'
	SMB_CONTEXT	: REF VECTOR,
	USER_CONTEXT	: REF VECTOR,
	FUNCTION	: REF VECTOR,
	FUNC_DESC	: REF VECTOR,
	FUNC_ARG	: REF VECTOR
	) =
BEGIN

LITERAL
	TRAILING = 1;
LOCAL
	SCB		: REF $BBLOCK,
	STATUS,
	FORM_WIDTH,
	FORM_LENGTH,
	FORM_SIZE,
	PAGE_REF	: REF PAGE_ARRAY;	! Declare the pointer 
     						!  to page

SCB = .SMB_CONTEXT[0];

! Check the FUNCTION requested

SELECTONEU .FUNCTION[0] OF
SET
    [PSM$K_READ]:
	BEGIN
	LOCAL  TEMP_PTR;

	PAGE_REF = .SCB[PSM$A_PAGE_POINTER];

	IF .SCB[PSM$L_RECORD_NUMBER] GTR (.SCB[PSM$L_PAGE_LENGTH] - 2 - 6)
	THEN
	    RETURN PSM$_EOF;

	FUNC_DESC[SIZE] = .SCB[PSM$L_PAGE_WIDTH];
	FUNC_DESC[ADDR] = PAGE_REF[0,.SCB[PSM$L_RECORD_NUMBER],
				   .SCB[PSM$L_PAGE_WIDTH]];

				 ! adjust pointer
	FUNC_DESC[SIZE] = DELIMIT_STRING_NOT (.FUNC_DESC[ADDR], 
					      %CHAR(32), .FUNC_DESC[SIZE]);

	END;

    [PSM$K_OPEN]:
	BEGIN

	GET_FORM_SIZE (.SCB);				! Returns the WidthxLength


	FORM_WIDTH	= .SCB[PSM$L_PAGE_WIDTH];
	FORM_LENGTH	= .SCB[PSM$L_PAGE_LENGTH]; 

	RETURN_IF_ERROR_(ALLOCATE_PAGE( .SCB));		! Get the page of memory

	PAGE_REF = .SCB[PSM$A_PAGE_POINTER];		! My local page pointer

	! Always start at top of page
	!
	PAGE_REF[0,0,.FORM_WIDTH] = PSM$K_CHAR_FF;	! form feed in 0 pos.

	!  Standard Trailer Page 132x66:  text covers rows 1 through 58,
	!    translated to frames... ref starts at 1 and length is 57.
	FILL_JOB_TRAILER( .SCB,
			  PAGE_REF[0,1,.FORM_WIDTH],
			  .FORM_WIDTH,
			  .FORM_LENGTH - 6 - 2 - 1 );	! ...6 burst, 2 sp,
	END;						!    top margin is 1

    [PSM$K_CLOSE]: 			! Return the Page of Memory
	RETURN_IF_ERROR_(DEALLOCATE_PAGE(.SCB));

    [OTHERWISE]:
	RETURN PSM$_FUNNOTSUP;

    TES; ! case .function

SS$_NORMAL

END;

%sbttl 'PSM$PAGE_HEADER - Print a Header at the Top of each Page'
! Functional Description:
!	Creates a page header for the current file and prints it at the
!	top of each page.
!	FUNCTION:
!		OPEN  - Allocate and create the Page Header
!		READ  - Return the current header with the new page number
!		CLOSE - Deallocate the header
!
! Formal Parameters:
!		SMB_CONTEXT   - Pointer to the SMB
!		USER_CONTEXT  - User defined pointer (not used here)
!		FUNCTION      - OPEN, READ, CLOSE
!		FUNC_DESC     - Pointer to functionally dependent descriptor
!		FUNC_ARG      - Pointer to functionally dependent argument
!
! Implicit Inputs:
!		none
!
! Implicit Outputs:
!		none
!
! Returned Value:
!		none
!
! Side Effects:
!		none
!--
GLOBAL ROUTINE PSM$PAGE_HEADER ( %SBTTL 'PAGE_HEADER'
	SMB_CONTEXT	: REF VECTOR,
	USER_CONTEXT	: REF VECTOR,
	FUNCTION	: REF VECTOR,
	FUNC_DESC	: REF VECTOR,
	FUNC_ARG	: REF VECTOR
	) =
BEGIN
LOCAL
	SCB		: REF $BBLOCK;

SCB = .SMB_CONTEXT[0];

! Check the FUNCTION requested

SELECTONEU .FUNCTION[0] OF
SET
    [PSM$K_READ]:
	BEGIN

	IF .SCB[PSM$L_RECORD_NUMBER] GTRU 0
	THEN
	    RETURN PSM$_EOF;

	! Use the supplied string descriptor as a temp for the page number
	!
	FUNC_DESC[SIZE] = 5;
	FUNC_DESC[ADDR] = .SCB_ADDR_(PAGE_HEADER) + .SCB_SIZE_(PAGE_HEADER) - 8;
	!
	! Write the page number into the end of the page header buffer
	! (note -- since the page number can decrease we always fill out
	! the page number area with blanks to overwrite any prior data)
	!
	$FAO (
	    $DESCRIPTOR ('!5<!UL!>' ),		! pad with trailing spaces
	    FUNC_DESC[SIZE],			! ignore return length
	    FUNC_DESC[0],			! temp output buffer desc
	    .SCB[PSM$L_PAGE]			! current page number
	    );

	! copy the page header descriptor size and address to
	! the function descriptor
	!
	FUNC_DESC[SIZE] = .SCB_SIZE_ (PAGE_HEADER);
	FUNC_DESC[ADDR] = .SCB_ADDR_ (PAGE_HEADER);

	END;

    [PSM$K_OPEN]:
	BEGIN
	!  set carriage control to imbedded
	!
	FUNC_ARG[0] = PSM$K_CC_INTERNAL;

	! Format everything but the page number, but only do it once per task
	!
	IF TESTBITCS (SCB[PSM$V_PAGE_HEADER_BUILT])
	THEN
	    CREATE_PAGE_HEADER (.SCB);

	END;

    [PSM$K_START_TASK]:
	! Set the size of the page header equal to the page width adjusted
	! for margins.
	!
	BEGIN
	GET_FORM_SIZE (.SCB);			! Returns the WidthxLength

	! Adjust for margins and imbedded carriage control
	!
	SCB[PSM$L_PAGE_WIDTH] = .SCB[PSM$L_PAGE_WIDTH]
			- .SCB[PSM$L_LEFT_MARGIN]	! less leading spaces
			- .SCB[PSM$L_RIGHT_MARGIN]	! less early truncation
			+ 3;				! plus trailing carr
							! cntrl <CR><LF><LF>

	RETURN_IF_ERROR_ (STR$GET1_DX (%REF (.SCB[PSM$L_PAGE_WIDTH]),
			  SCB[PSM$Q_PAGE_HEADER]));
	END;

    [OTHERWISE]:
	RETURN PSM$_FUNNOTSUP;

    TES; ! case .function

SS$_NORMAL

END;

ROUTINE PARSE_FILE_NAME ( %SBTTL 'PARSE_FILE_NAME'
	FILENAME	: REF $BBLOCK,
	ITEM_CODE	,
	RESULT		: REF VECTOR
	)	=
BEGIN

LOCAL
	LIST	: $ITMBLK [1,8]
	;

CH$FILL (0, %ALLOCATION (LIST), LIST);

LIST [0, ITM$W_ITMCOD] = .ITEM_CODE;

RETURN_IF_ERROR_ ($FILESCAN (SRCSTR=.FILENAME, VALUELST=LIST));

RESULT[SIZE] = .LIST[0, ITM$W_BUFSIZ];
RESULT[ADDR] = .LIST[0, ITM$L_BUFADR];

SS$_NORMAL

END;

%sbttl 'ALLOCATE_PAGE - Allocate the Page of Memory'
!++
! Functional Description:
!	This routine allocates memory in an amount of 
!	memory equal to the largest Form Size supported.
!
! Formal Parameters:
!		SCB	- Address of the SCB
!
! Implicit Inputs:
!		none
!
! Implicit Outputs:
!		none
!
! Returned Value:
!		none
!
! Side Effects:
!		none
!--
ROUTINE ALLOCATE_PAGE(
		SCB  : REF $BBLOCK
		     ) =
BEGIN
   LOCAL
	PAGE_SIZE;

    PAGE_SIZE = .SCB[PSM$L_PAGE_WIDTH] * (.SCB[PSM$L_PAGE_LENGTH]+1);

    RETURN_IF_ERROR_( LIB$GET_VM ( %REF(.PAGE_SIZE),
		      SCB[PSM$A_PAGE_POINTER]));
							! Fill it with Blanks
    CH$FILL (%CHAR(32), .PAGE_SIZE,
	     .SCB[PSM$A_PAGE_POINTER]);

    RETURN SS$_NORMAL;
END;

%sbttl 'DEALLOCATE_PAGE - Deallocate the Page of Memory'
!++
! Functional Description:
!	This routine deallocates memory in an amount of 
!	memory equal to the largest Form Size supported.
!
! Formal Parameters:
!		SCB	- Address of the SCB
!
! Implicit Inputs:
!		none
!
! Implicit Outputs:
!		none
!
! Returned Value:
!		none
!
! Side Effects:
!		none
!--
ROUTINE DEALLOCATE_PAGE (
		    SCB	: REF $BBLOCK
		   ) =
BEGIN
    LOCAL
	PAGE_SIZE;

PAGE_SIZE = .SCB[PSM$L_PAGE_WIDTH] * (.SCB[PSM$L_PAGE_LENGTH]+1);

RETURN_IF_ERROR_( LIB$FREE_VM ( %REF(.PAGE_SIZE),
		      SCB[PSM$A_PAGE_POINTER]));

RETURN SS$_NORMAL;
END;

%sbttl 'CREATE_PAGE_HEADER - Allocate and Format the Page Header'
!++
! Functional Description:
!	This routine allocates memory and formats the information
!	for the page header.  Returns success if allocation of memory
!	was successful.
!
! Formal Parameters:
!		SCB	- Address of the SCB
!
! Implicit Inputs:
!		none
!
! Implicit Outputs:
!		none
!
! Returned Value:
!		none
!
! Side Effects:
!		none
!--
ROUTINE CREATE_PAGE_HEADER (
		    SCB	: REF $BBLOCK
		   ) =
BEGIN

LOCAL
    REMAINING,					! Remaining header space
    NAME_LENGTH	,				! Trimmed file name length
    BUFFER	: VECTOR [512,byte],		! Assume max size 512 bytes0
    STR_DESC	: VECTOR [2],
    HEADER_REF	: REF PAGE_ARRAY,
    HEADER_SIZE	;

!*! SMALL WIDTHS -- THE PAGE NUMBER SHOULD BE THE ONLY THING PRINTED
!*! WHEN THE WIDTH IS TOO SMALL.  DATE vs. FILENAME IS DEVO'S CHOICE

HEADER_SIZE = .SCB_SIZE_ (PAGE_HEADER) - 3;	! don't include the carriage
						!   control area of 3 bytes
HEADER_REF  = .SCB_ADDR_ (PAGE_HEADER);

CH$FILL (%CHAR(32), .HEADER_SIZE, .HEADER_REF);

! Insert imbedded carriage control <LF><LF><CR>
!
CH$FILL (PSM$K_CHAR_LF, 2,(.HEADER_REF + .HEADER_SIZE));
CH$FILL (PSM$K_CHAR_CR, 1,(.HEADER_REF + .HEADER_SIZE) + 2);
						! address is offset by two

! If the header is too small even for "Page 99999" then disable page
! headers.  (Maybe this code should be in "MESSAGE").
!
IF .HEADER_SIZE LSSU 10
THEN
    RETURN SS$_NORMAL;

! Set up the buffer descriptor for "GET_xxx" Routines
!
STR_DESC[SIZE] = %ALLOCATION(BUFFER);		! allocate for routines
STR_DESC[ADDR] = BUFFER;			! init address

! Insert the word "Page "
!
MOVE_FRAME
	(.SCB,
	$DESCRIPTOR ('Page '),
	HEADER_REF[.HEADER_SIZE-10,0,.SCB[PSM$L_FORM_WIDTH]],
	5,
	1);

! Get the filename - include the expected length
!
STR_DESC[SIZE] = %ALLOCATION(BUFFER);		! reset buffer length
GET_FILE_NAME
	(.SCB,					! SCB addr.
	.HEADER_SIZE - 11,			! expected length (less page #)
     	STR_DESC[0],				! Buffer descriptor
	STR_DESC[SIZE]);			! Returned length

NAME_LENGTH = .STR_DESC[SIZE] + 1;		! Save the trimmed length

INSERT_FRAME					! Left Justified
	(.SCB,
	STR_DESC[0],
	HEADER_REF[0,0,.SCB[PSM$L_FORM_WIDTH]],
	.NAME_LENGTH - 1,			! Always less than frame_width
	1);


! The area remaining for the date is the original header
! width less the size of the file name, less the size for the page
! number field ("Page 99999") less one blank for each.
!
REMAINING = .HEADER_SIZE - .NAME_LENGTH - 10 - 1;
IF .REMAINING LSSU 18
THEN
    RETURN SS$_NORMAL;

! Get the file revision date and center it between file name and page number
!
STR_DESC[SIZE] = %ALLOCATION(BUFFER);		! reset buffer length
GET_REVISION_DATE
    	(.SCB,					! SCB addr.
     	STR_DESC[0],				! Buffer descriptor
	STR_DESC[SIZE]);			! Returned length

CENTER_FRAME
	(.SCB,
	STR_DESC[0],
	HEADER_REF[.NAME_LENGTH,0,.SCB[PSM$L_FORM_WIDTH]],
	.REMAINING,
	1);

RETURN SS$_NORMAL;

END;

%sbttl 'FILL_FILE_FLAG - Insert Information into the FILE Page'
!++
! Functional Description:
!	This procedure controls all inserts required for the FILE Page.
!
! Formal Parameters:
!	SCB		- Address of the SCB
!	PAGE_REF	- Pointer to the Page (first byte)
!	PAGE_LENGTH	- Length of Frame
!	PAGE_WIDTH	- Width of Frame
!
! Implicit Inputs:
!		none
!
! Implicit Outputs:
!		none
!
! Returned Value:
!		none
!
! Side Effects:
!		none
!--
ROUTINE FILL_FILE_FLAG (
	SCB		: REF $BBLOCK,
	PAGE_REF	: REF PAGE_ARRAY,
	PAGE_WIDTH,
	PAGE_LENGTH
	):	NOVALUE	=
BEGIN

LITERAL	K_MAX_BUFFER_SIZE = 512;

LOCAL
    RET_LEN	: VECTOR[1],
    TOP_OFFSET	,
    BOTTOM_OFFSET,
    BUFFER	: VECTOR [512,byte],		! Assume max size 512 bytes
    STRING_DESC	: VECTOR [2];			! Descriptor to current string

! Allocate the buffer for "GET_xxx" Routines
!
STRING_DESC[SIZE] = %ALLOCATION(BUFFER);	! allocate for routines
STRING_DESC[ADDR] = BUFFER;			! init address 

TOP_OFFSET = 0;					! start insert at zero
BOTTOM_OFFSET = .PAGE_LENGTH - 2;		! Note: offset includes next
						!   "insert" frame length

! Burst characters
!
    FILL_FRAME (.SCB,
	    	.SCB[PSM$B_FILE_BURST_CHAR],
	    	PAGE_REF[0,.TOP_OFFSET,.PAGE_WIDTH], .PAGE_WIDTH, 3);

    FILL_FRAME (.SCB,
	    	.SCB[PSM$B_FILE_BURST_CHAR], 
	    	PAGE_REF[0,.BOTTOM_OFFSET,.PAGE_WIDTH], .PAGE_WIDTH, 3);

    FILL_FRAME (.SCB,
	    	%C' ',
	    	PAGE_REF[10,.TOP_OFFSET,.PAGE_WIDTH], .PAGE_WIDTH-20, 3);

    FILL_FRAME (.SCB,
	    	%C' ',
	    	PAGE_REF[10,.BOTTOM_OFFSET,.PAGE_WIDTH], .PAGE_WIDTH-20, 3);

    FILL_FRAME (.SCB,
	    	.SCB[PSM$B_JOB_BURST_CHAR],
	    	PAGE_REF[14,.TOP_OFFSET,.PAGE_WIDTH], .PAGE_WIDTH-28, 3);

    FILL_FRAME (.SCB,
	    	.SCB[PSM$B_JOB_BURST_CHAR], 
	    	PAGE_REF[14,.BOTTOM_OFFSET,.PAGE_WIDTH], .PAGE_WIDTH-28, 3);

!  Get the sys$announce note and output to page
!	note:	system announcement will fit or will be truncated so there is
!		no updating of "offsets"
!
    ! re-init
    STRING_DESC[SIZE] = K_MAX_BUFFER_SIZE; ! reset buffer size

    GET_SYSTEM_ANNOUNCEMENT
	    	(.SCB,			! SCB addr.
	     	STRING_DESC[0],		! Buffer descriptor
		STRING_DESC[SIZE]);	! Returned length

    CENTER_FRAME (.SCB,
		   STRING_DESC[0],
		   PAGE_REF[0,.TOP_OFFSET + 1,.PAGE_WIDTH], .PAGE_WIDTH, 1);

    ! re-init
    STRING_DESC[SIZE] = K_MAX_BUFFER_SIZE; ! reset buffer size

    GET_DIGITAL_LOGO
	    	(.SCB,			! SCB addr.
	     	STRING_DESC[0],		! Buffer descriptor
		STRING_DESC[SIZE]);	! Returned length

    CENTER_FRAME (.SCB,
		   STRING_DESC[0],
		   PAGE_REF[0,.BOTTOM_OFFSET + 1,.PAGE_WIDTH], .PAGE_WIDTH, 1);


!  Create a sentence describing the current job.
!
    ! re-init
    STRING_DESC[SIZE] = K_MAX_BUFFER_SIZE;	! reset buffer size
    TOP_OFFSET = .TOP_OFFSET + 4;		! adjust & allow for spacing

    GET_JOB_DESCRIPTION
	    	(.SCB,			! SCB addr.
		 1,			! Use present tense
	     	 STRING_DESC[0],	! Buffer descriptor
		 STRING_DESC[SIZE]);	! Returned length

    RET_LEN[0] = RETURN_FRAME_LENGTH
		 (.SCB,
		  STRING_DESC[0],	  	! string ref.
		  PAGE_REF[0,0,.PAGE_WIDTH],	! ref to frame
		  .PAGE_WIDTH,			! cols to fill
		  .BOTTOM_OFFSET - .TOP_OFFSET);! rows to fill

    IF .RET_LEN[0] GTR 0
    THEN
	BOTTOM_OFFSET = .BOTTOM_OFFSET - (.RET_LEN[0] + 1);
						! offset before inserting
						!   includes the space
    ! Insert the string delimited.  Bottom of page.
    INSERT_FRAME (.SCB,
		  STRING_DESC[0],		! string ref.
		  PAGE_REF[0,.BOTTOM_OFFSET,.PAGE_WIDTH],
						! ref to frame
		  .PAGE_WIDTH, 			! cols to fill
		  .RET_LEN[0]);			! rows to fill

!  Create a sentence describing the current file.  Bottom of page.
!
    ! re-init
    STRING_DESC[SIZE] = K_MAX_BUFFER_SIZE; 	! reset buffer size

    GET_FILE_DESCRIPTION
	    	(.SCB,				! SCB addr.
	     	 STRING_DESC[0],		! Buffer descriptor
		 STRING_DESC[SIZE]);		! Returned length

    RET_LEN[0] = RETURN_FRAME_LENGTH
		 (.SCB,
		  STRING_DESC[0],	  	! string ref.
		  PAGE_REF[0,0,.PAGE_WIDTH],	! ref to frame
		  .PAGE_WIDTH,			! cols to fill
		  .BOTTOM_OFFSET - .TOP_OFFSET);! rows to fill

    IF .RET_LEN[0] GTR 0
    THEN
	BOTTOM_OFFSET = .BOTTOM_OFFSET - (.RET_LEN[0] + 1);
						! offset before inserting

    ! insert the string delimited						
    INSERT_FRAME (.SCB,
		  STRING_DESC[0],		! string ref.
		  PAGE_REF[0,.BOTTOM_OFFSET,.PAGE_WIDTH],
						! ref to frame
		  .PAGE_WIDTH, 			! cols to fill
		  .RET_LEN[0]);			! rows to fill

! User note
!
    ! re-init
    STRING_DESC[SIZE] = K_MAX_BUFFER_SIZE; 	! reset buffer size

    !  Get the user note
    GET_USER_NOTE
	    	(.SCB,				! SCB addr.
	     	STRING_DESC[0],			! Buffer descriptor
		STRING_DESC[SIZE]);		! Returned length

    RET_LEN[0] = RETURN_FRAME_LENGTH
		 (.SCB,
		  STRING_DESC[0],	  	! string ref.
		  PAGE_REF[0,0,.PAGE_WIDTH],	! ref to frame
		  .PAGE_WIDTH,			! cols to fill
		  .BOTTOM_OFFSET - .TOP_OFFSET);! rows to fill

    ! insert the string delimited						
    INSERT_FRAME (.SCB,
		  STRING_DESC[0],	  	! string ref.
		  PAGE_REF[0,.TOP_OFFSET,.PAGE_WIDTH],
						! ref to frame
		  .PAGE_WIDTH,			! cols to fill
		  .RET_LEN[0]);			! rows to fill

! User name
!
    ! re-init
    STRING_DESC[SIZE] = K_MAX_BUFFER_SIZE;	! reset buffer size
    IF .RET_LEN[0] GTR 0
    THEN
	TOP_OFFSET	= .TOP_OFFSET + .RET_LEN[0] + 1
    ELSE
	TOP_OFFSET	= .TOP_OFFSET + 1;
						! adjust & allow for spacing

    RET_LEN[0] = INSERT_NAME_BANNER (.SCB,
		 	SCB_SIZE_(USER_NAME),	! user name desc
		    	PAGE_REF[0,.TOP_OFFSET,.PAGE_WIDTH],
						! ref to frame
		    	.PAGE_WIDTH,		! max width Bann 
			.BOTTOM_OFFSET - .TOP_OFFSET,
						! frame length
		    	7);			! max hght Bann str desired

    IF .RET_LEN[0] GTR 0
    THEN
	TOP_OFFSET	= .TOP_OFFSET + .RET_LEN[0] + 2;
						! adjust & allow for spacing

!  Get and insert the filename banner
!
    ! re-init
    STRING_DESC[SIZE] = K_MAX_BUFFER_SIZE;	! reset buffer size
    RET_LEN[0] = INSERT_FILENAME_BANNER 
			(.SCB,
			 STRING_DESC[0],	! Buffer desc.
			 PAGE_REF[0,.TOP_OFFSET,.PAGE_WIDTH],
						! ref to frame
			 .PAGE_WIDTH,		! max width Bann 
			  .BOTTOM_OFFSET - .TOP_OFFSET);
						! rows to fill
    IF .RET_LEN[0] GTR 0
    THEN
	TOP_OFFSET	= .TOP_OFFSET + .RET_LEN[0] + 2;
						! adjust & allow for spacing

END;

%sbttl 'FILL_JOB_FLAG - Insert Information into the JOB Page'
!++
! Functional Description:
!	This procedure controls all inserts required for the JOB Page.
!
! Formal Parameters:
!	SCB		- Address of the SCB
!	PAGE_REF	- Pointer to the Page (first byte)
!	PAGE_LENGTH	- Length of Frame
!	PAGE_WIDTH	- Width of Frame
!
! Implicit Inputs:
!		none
!
! Implicit Outputs:
!		none
!
! Returned Value:
!		none
!
! Side Effects:
!		none
!--
ROUTINE FILL_JOB_FLAG (
	SCB		: REF $BBLOCK,
	PAGE_REF	: REF PAGE_ARRAY,
	PAGE_WIDTH,
	PAGE_LENGTH
	):	NOVALUE	=
BEGIN

LITERAL	K_MAX_BUFFER_SIZE = 512;

LOCAL
    RET_LEN	: VECTOR[1],
    TOP_OFFSET	,
    BOTTOM_OFFSET,
    BUFFER	: VECTOR [512,byte],		! Assume max size 512 bytes
    STRING_DESC	: VECTOR [2];			! Descriptor to current string

! Allocate the buffer for "GET_xxx" Routines
!
STRING_DESC[SIZE] = %ALLOCATION(BUFFER);	! allocate for routines
STRING_DESC[ADDR] = BUFFER;			! init address 

TOP_OFFSET = 0;
BOTTOM_OFFSET = .PAGE_LENGTH - 2;		! offset includes burst offset

! Burst Character
!
    FILL_FRAME (.SCB,
	    	.SCB[PSM$B_JOB_BURST_CHAR],
	    	PAGE_REF[0,.TOP_OFFSET,.PAGE_WIDTH], .PAGE_WIDTH, 3);

    FILL_FRAME (.SCB,
	    	.SCB[PSM$B_JOB_BURST_CHAR], 
	    	PAGE_REF[0,.BOTTOM_OFFSET,.PAGE_WIDTH], .PAGE_WIDTH, 3);

!  System announcement
!
    ! re-init
    STRING_DESC[SIZE] = K_MAX_BUFFER_SIZE;	! reset buffer size
    GET_SYSTEM_ANNOUNCEMENT
	    	(.SCB,				! SCB addr.
	     	STRING_DESC[0],			! Buffer descriptor
		STRING_DESC[SIZE]);		! Returned length

    CENTER_FRAME (.SCB,
		   STRING_DESC[0],
		   PAGE_REF[0,.TOP_OFFSET + 1,.PAGE_WIDTH], .PAGE_WIDTH, 1);

    ! re-init
    STRING_DESC[SIZE] = K_MAX_BUFFER_SIZE;	! reset buffer size
    GET_DIGITAL_LOGO
	    	(.SCB,				! SCB addr.
	     	STRING_DESC[0],			! Buffer descriptor
		STRING_DESC[SIZE]);		! Returned length

    CENTER_FRAME (.SCB,
		   STRING_DESC[0],
		   PAGE_REF[0,.BOTTOM_OFFSET + 1,.PAGE_WIDTH], .PAGE_WIDTH, 1);

    TOP_OFFSET = .TOP_OFFSET + 4;		! adjust & allow for spacing

!  Job description - create a sentence describing the current job.
!
    ! re-init
    STRING_DESC[SIZE] = K_MAX_BUFFER_SIZE;	! reset buffer size
    GET_JOB_DESCRIPTION
	    	(.SCB,				! SCB addr.
		 1,				! Use present tense
	     	 STRING_DESC[0],		! Buffer descriptor
		 STRING_DESC[SIZE]);		! Returned length

    RET_LEN[0] = RETURN_FRAME_LENGTH
		 (.SCB,
		  STRING_DESC[0],	  	! string ref.
		  PAGE_REF[0,0,.PAGE_WIDTH],	! ref to frame
		  .PAGE_WIDTH,			! cols to fill
		  .BOTTOM_OFFSET - .TOP_OFFSET);! rows to fill

    IF .RET_LEN[0] GTR 0
    THEN
	BOTTOM_OFFSET = .BOTTOM_OFFSET - (.RET_LEN[0] + 1);
						! offset before inserting
    ! insert the string delimited						
    INSERT_FRAME (.SCB,
		  STRING_DESC[0],		! string ref.
		  PAGE_REF[0,.BOTTOM_OFFSET,.PAGE_WIDTH],
						! ref to frame
		  .PAGE_WIDTH, 			! cols to fill
		  .RET_LEN[0]);			! rows to fill

! User note
!
    ! re-init
    STRING_DESC[SIZE] = K_MAX_BUFFER_SIZE;	! reset buffer size

    !  Get the user note
    GET_USER_NOTE
	    	(.SCB,				! SCB addr.
	     	STRING_DESC[0],			! Buffer descriptor
		STRING_DESC[SIZE]);		! Returned length

    RET_LEN[0] = RETURN_FRAME_LENGTH
		 (.SCB,
		  STRING_DESC[0],	  	! string ref.
		  PAGE_REF[0,0,.PAGE_WIDTH],	! ref to frame
		  .PAGE_WIDTH,			! cols to fill
		  .BOTTOM_OFFSET - .TOP_OFFSET);! rows to fill

    ! insert the string delimited						
    INSERT_FRAME (.SCB,
		  STRING_DESC[0],	  	! string ref.
		  PAGE_REF[0,.TOP_OFFSET,.PAGE_WIDTH],
						! ref to frame
		  .PAGE_WIDTH,			! cols to fill
		  .RET_LEN[0]);			! rows to fill

    IF .RET_LEN[0] GTR 0
    THEN
	TOP_OFFSET	= .TOP_OFFSET + .RET_LEN[0] + 1
    ELSE
	TOP_OFFSET	= .TOP_OFFSET + 1;
						! adjust & allow for spacing
! User Name
!
    ! re-init
    STRING_DESC[SIZE] = K_MAX_BUFFER_SIZE;	! reset buffer size

    RET_LEN[0] = INSERT_NAME_BANNER (
			.SCB,
		 	SCB_SIZE_(USER_NAME),	! user name descriptor
		    	PAGE_REF[0,.TOP_OFFSET,.PAGE_WIDTH],
						! ref to frame
		    	.PAGE_WIDTH,		! max width Bann 
			.BOTTOM_OFFSET-.TOP_OFFSET,
						! space left
			14);			! max hght Bann string desired

    TOP_OFFSET	= .TOP_OFFSET + .RET_LEN[0] + 2;! adjust for banner & spacing

!  Job Name
!
    ! re-init
    STRING_DESC[SIZE] = K_MAX_BUFFER_SIZE;	! reset buffer size

    GET_JOB_NAME
	    	(.SCB,				! SCB addr.
	     	STRING_DESC[0],			! Buffer descriptor
		STRING_DESC[SIZE]);		! Returned length

    RET_LEN[0] = INSERT_NAME_BANNER (
			.SCB,
		   	STRING_DESC[SIZE],	! job name desc
		    	PAGE_REF[0,.TOP_OFFSET,.PAGE_WIDTH],
						! ref to frame
		    	.PAGE_WIDTH,		! max width Bann 
			.BOTTOM_OFFSET-.TOP_OFFSET,
						! space left
			7);			! max hght Bann str desired

    IF .RET_LEN[0] GTR 0
    THEN
	TOP_OFFSET	= .TOP_OFFSET + .RET_LEN[0] + 2;
						! adjust & allow for spacing
    !  Get and insert the filename banner
    !

    ! re-init
    STRING_DESC[SIZE] = K_MAX_BUFFER_SIZE;	! reset buffer size

    IF (.BOTTOM_OFFSET - 9) GTR .TOP_OFFSET 	! test for enough room
    THEN
	BEGIN
	BOTTOM_OFFSET = .BOTTOM_OFFSET - 9;
						! offset before inserting
	INSERT_JOBNUMBER_BANNER 
		(.SCB,
		 STRING_DESC[0],		! Buffer desc.
		 PAGE_REF[0, .BOTTOM_OFFSET,.PAGE_WIDTH],
						! ref to frame
		 .PAGE_WIDTH,			! max width Bann 
	 	 7);				! rows to fill
	END;
END;

%sbttl 'FILL_JOB_TRAILER - Insert Information into the JOB Page'
!++
! Functional Description:
!	This procedure controls all inserts required for the JOB Page.
!
! Formal Parameters:
!	SCB		- Address of the SCB
!	PAGE_REF	- Pointer to the Page (first byte)
!	PAGE_LENGTH	- Length of Frame
!	PAGE_WIDTH	- Width of Frame
!
! Implicit Inputs:
!		none
!
! Implicit Outputs:
!		none
!
! Returned Value:
!		none
!
! Side Effects:
!		none
!--
ROUTINE FILL_JOB_TRAILER (
	SCB		: REF $BBLOCK,
	PAGE_REF	: REF PAGE_ARRAY,
	PAGE_WIDTH,
	PAGE_LENGTH
	):	NOVALUE	=
BEGIN

LITERAL	K_MAX_BUFFER_SIZE = 512;

LOCAL
    RET_LEN	: VECTOR[1],
    RET_WIDE	: VECTOR[1],
    RIGHT_OFFSET,
    LEFT_OFFSET	,
    TOP_OFFSET	,
    BOTTOM_OFFSET,
    BUFFER	: VECTOR [512,byte],		! Assume max size 512 bytes
    STRING_DESC	: VECTOR [2];			! Descriptor to current string

! Allocate the buffer for "GET_xxx" Routines
!
STRING_DESC[SIZE] = %ALLOCATION(BUFFER);	! allocate for routines
STRING_DESC[ADDR] = BUFFER;			! init address 

! Top of page
!
TOP_OFFSET = 0;
BOTTOM_OFFSET = .PAGE_LENGTH;

    !  insert the burst characters
    FILL_FRAME (.SCB,
	    	.SCB[PSM$B_JOB_BURST_CHAR], 
	    	PAGE_REF[0,.TOP_OFFSET+2,.PAGE_WIDTH], .PAGE_WIDTH, 3);

    ! re-init
    STRING_DESC[SIZE] = K_MAX_BUFFER_SIZE;	! reset buffer size

    GET_EOJ	
		(.SCB,
	     	STRING_DESC[0],			! Buffer descriptor
		STRING_DESC[SIZE]);		! Returned length

    RET_LEN[0] = INSERT_NAME_BANNER (
			.SCB,
		   	STRING_DESC[SIZE],	! eoj name desc
		    	PAGE_REF[0,.TOP_OFFSET,.PAGE_WIDTH],
						! ref to frame
		    	.PAGE_WIDTH,		! max width Bann 
			.BOTTOM_OFFSET - .TOP_OFFSET,
						! frame size
		    	7);			! max hght Bann str

    IF .RET_LEN[0] GTR 0
    THEN
	TOP_OFFSET	= .TOP_OFFSET + .RET_LEN[0] + 2;
						! adjust & allow for spacing
						!  includes the burst also...
						!  two spaces...
! Bottom of page
!
BOTTOM_OFFSET = .PAGE_LENGTH - 5;		! offset includes burst offset

    FILL_FRAME (.SCB,
	    	.SCB[PSM$B_JOB_BURST_CHAR], 
	    	PAGE_REF[0,.BOTTOM_OFFSET,.PAGE_WIDTH], .PAGE_WIDTH,3);

    ! re-init
    STRING_DESC[SIZE] = K_MAX_BUFFER_SIZE;	! reset buffer size

    !  Get the digital logo and output to page ... assume not greater than
    !  amount allocated.... truncation otherwise occurs

    GET_DIGITAL_LOGO
	    	(.SCB,				! SCB addr.
	     	STRING_DESC[0],			! Buffer descriptor
		STRING_DESC[SIZE]);		! Returned length

    CENTER_FRAME (.SCB,
		   STRING_DESC[0],
		   PAGE_REF[0,.BOTTOM_OFFSET+1,.PAGE_WIDTH], .PAGE_WIDTH, 1);


    ! re-init
    STRING_DESC[SIZE] = K_MAX_BUFFER_SIZE;	! reset buffer size

    GET_RULER_COARSE
	    	(.SCB,				! SCB addr.
	     	STRING_DESC[0],			! Buffer descriptor
		STRING_DESC[SIZE]);		! Returned length

    SCROLL_FRAME (.SCB,
		   STRING_DESC[0],
		   PAGE_REF[0,.BOTTOM_OFFSET+4,.PAGE_WIDTH], .PAGE_WIDTH, 1);

    SCROLL_FRAME (.SCB,
		  $DESCRIPTOR ('1234567890'),
		   PAGE_REF[0,.BOTTOM_OFFSET+5,.PAGE_WIDTH], .PAGE_WIDTH, 1);

!  Create a sentence describing the current job.
!
    ! re-init
    STRING_DESC[SIZE] = K_MAX_BUFFER_SIZE;	! reset buffer size

    GET_JOB_DESCRIPTION
	    	(.SCB,				! SCB addr.
		 0,				! Use past tense
	     	 STRING_DESC[0],		! Buffer descriptor
		 STRING_DESC[SIZE]);		! Returned length

    RET_LEN[0] = RETURN_FRAME_LENGTH
		 (.SCB,
		  STRING_DESC[0],	  	! string ref.
		  PAGE_REF[0,0,.PAGE_WIDTH],	! ref to frame
		  .PAGE_WIDTH,			! cols to fill
		  .BOTTOM_OFFSET - .TOP_OFFSET);! rows to fill

    IF .RET_LEN[0] GTR 0
    THEN
	BOTTOM_OFFSET = .BOTTOM_OFFSET - (.RET_LEN[0] + 1);
						! adjust & allow for spacing
						!   before inserting
    ! insert the string delimited						
    INSERT_FRAME (.SCB,
		  STRING_DESC[0],	  	! string ref.
		  PAGE_REF[0,.BOTTOM_OFFSET,.PAGE_WIDTH],
						! ref to frame
		  .PAGE_WIDTH,			! cols to fill
		  .RET_LEN[0]);		 	! rows to fill


! User name
!
    RET_LEN[0] = INSERT_NAME_BANNER
			(.SCB,
		 	SCB_SIZE_(USER_NAME),	! user name desc
		    	PAGE_REF[0,.TOP_OFFSET,.PAGE_WIDTH],
						! ref to frame
		    	.PAGE_WIDTH,		! max width Bann 
			.BOTTOM_OFFSET - .TOP_OFFSET,
						! frame size
			7);			! max hght Bann str desired

    ! re-init
    IF .RET_LEN[0] GTR 0
    THEN
	TOP_OFFSET	= .TOP_OFFSET + .RET_LEN[0] + 2;
						! adjust & allow for spacing
! Job name
!
    ! re-init
    STRING_DESC[SIZE] = K_MAX_BUFFER_SIZE;	! reset buffer size

    GET_JOB_NAME	
		(.SCB,
	     	STRING_DESC[0],			! Buffer descriptor
		STRING_DESC[SIZE]);		! Returned length

    RET_LEN[0] = INSERT_NAME_BANNER (
			.SCB,
		   	STRING_DESC[SIZE],	! job name size
		    	PAGE_REF[0,.TOP_OFFSET,.PAGE_WIDTH],
						! ref to frame
		    	.PAGE_WIDTH,		! max width Bann 
			.BOTTOM_OFFSET - .TOP_OFFSET,
						! frame size
			7);			! max hght Bann str

    ! re-init
    IF .RET_LEN[0] GTR 0
    THEN
	TOP_OFFSET	= .TOP_OFFSET + .RET_LEN[0] + 2;
						! adjust & allow for spacing
!  Receipt box
!
RIGHT_OFFSET = .PAGE_WIDTH;			! right_offset and left_offset
LEFT_OFFSET = 0;				! are positional offsets for
						! a specific frame_length and
						! range.
    ! re-init
    STRING_DESC[SIZE] = K_MAX_BUFFER_SIZE;	! reset buffer size

    GET_RECEIPT_BOX
	    	(.SCB,				! SCB addr.
	     	STRING_DESC[0],			! Buffer descriptor
		STRING_DESC[SIZE]);		! Returned length

    ! Get the width needed for insert (assume length of seven)
    RET_WIDE[0] = RETURN_FRAME_WIDTH
		 (.SCB,
		  STRING_DESC[0],		! string ref.
		  PAGE_REF[0,.TOP_OFFSET,.PAGE_WIDTH],
						! ref to frame
		  .RIGHT_OFFSET -.LEFT_OFFSET,	! special width
		  8);				! rows to fill

    RET_LEN[0] = RETURN_FRAME_LENGTH
		 (.SCB,
		  STRING_DESC[0],	  	! string ref.
		  PAGE_REF[0,0,.PAGE_WIDTH],	! ref to frame
		  .RET_WIDE[0],			! cols to fill
		  .BOTTOM_OFFSET - .TOP_OFFSET);! rows to fill

    IF .RET_LEN[0] GTR 0
    THEN
	BOTTOM_OFFSET = .BOTTOM_OFFSET - (.RET_LEN[0] + 1);
						! adjust & allow for spacing
						!   before inserting
    RIGHT_OFFSET = .RIGHT_OFFSET - .RET_WIDE[0];! offset before inserting

    MOVE_FRAME (.SCB,
		  STRING_DESC[0], 		! string frame reference
		  PAGE_REF[.RIGHT_OFFSET,.BOTTOM_OFFSET,.PAGE_WIDTH],
						! ref to frame
		  .RET_WIDE[0],			! width
		  .RET_LEN[0]);			! rows to fill

    !  Get and insert the filename banner
    !

    ! re-init
    STRING_DESC[SIZE] = K_MAX_BUFFER_SIZE;	! reset buffer size

    INSERT_JOBNUMBER_BANNER 
		(.SCB,
		 STRING_DESC[0],		! Buffer desc.
		 PAGE_REF[.LEFT_OFFSET,.BOTTOM_OFFSET,.PAGE_WIDTH],
						! ref to frame
		 .RIGHT_OFFSET-.LEFT_OFFSET,	! max width Bann 
	 	 .BOTTOM_OFFSET - .TOP_OFFSET);	! rows to fill

! re-init
STRING_DESC[SIZE] = K_MAX_BUFFER_SIZE;	! reset buffer size
RIGHT_OFFSET = .PAGE_WIDTH;			! right_offset and left_offset
LEFT_OFFSET = 0;				! are positional offsets for
						! a specific frame_length and
						! range.

!    GET_ACCOUNTING_INFO	
!		(.SCB,
!	     	STRING_DESC[0],		! Buffer descriptor
!		STRING_DESC[SIZE]);	! Returned length
!
! insert the string delimited						
!    INSERT_FRAME (.SCB,
!		  STRING_DESC[0],	  		   ! string ref.
!		  PAGE_REF[0, 45, .PAGE_WIDTH],		   ! ref to frame
!		  .PAGE_WIDTH,				   ! cols to fill
!		  2);			 		   ! rows to fill
END;

%sbttl 'FILL_FILE_TRAILER - Insert Information into the FILE Page'
!++
! Functional Description:
!	This procedure controls all inserts required for the FILE Page.
!
! Formal Parameters:
!	SCB		- Address of the SCB
!	PAGE_REF	- Pointer to the Page (first byte)
!	PAGE_LENGTH	- Length of Frame
!	PAGE_WIDTH	- Width of Frame
!
! Implicit Inputs:
!		none
!
! Implicit Outputs:
!		none
!
! Returned Value:
!		none
!
! Side Effects:
!		none
!--
ROUTINE FILL_FILE_TRAILER (
	SCB		: REF $BBLOCK,
	PAGE_REF	: REF PAGE_ARRAY,
	PAGE_WIDTH,
	PAGE_LENGTH
	):	NOVALUE	=
BEGIN

LITERAL	K_MAX_BUFFER_SIZE = 512;

LOCAL
    FORCE_LEN	,
    RET_LEN	: VECTOR[1],
    TOP_OFFSET	,
    BOTTOM_OFFSET,
    BUFFER	: VECTOR [512,byte],	! Assume max size 512 bytes
    STRING_DESC	: VECTOR [2];		! Descriptor to current string

! Allocate the buffer for "GET_xxx" Routines
!
STRING_DESC[SIZE] = %ALLOCATION(BUFFER);	! allocate for routines
STRING_DESC[ADDR] = BUFFER;			! init address 


! Top of page
!
TOP_OFFSET = 0;
BOTTOM_OFFSET = .PAGE_LENGTH;

    FILL_FRAME (.SCB,
	    	.SCB[PSM$B_FILE_BURST_CHAR], 
	    	PAGE_REF[0,.TOP_OFFSET+2,.PAGE_WIDTH], .PAGE_WIDTH, 3);

    FILL_FRAME (.SCB,
	    	%C' ',
	    	PAGE_REF[10,.TOP_OFFSET+2,.PAGE_WIDTH], .PAGE_WIDTH-20, 3);

    FILL_FRAME (.SCB,
	    	.SCB[PSM$B_JOB_BURST_CHAR], 
		PAGE_REF[13, .TOP_OFFSET+2,.PAGE_WIDTH], .PAGE_WIDTH-26, 3);

    ! re-init
    STRING_DESC[SIZE] = K_MAX_BUFFER_SIZE;	! reset buffer size

    GET_EOF	(.SCB,
	     	STRING_DESC[0],			! Buffer descriptor
		STRING_DESC[SIZE]);		! Returned length

    RET_LEN[0] = INSERT_NAME_BANNER (
			.SCB,
			STRING_DESC[SIZE],	! file name desc
		    	PAGE_REF[0,.TOP_OFFSET,.PAGE_WIDTH],
						! ref to frame
		    	.PAGE_WIDTH,		! max width Bann 
			.BOTTOM_OFFSET - .TOP_OFFSET,
						! frame size
		    	7);			! max hght Bann str

    ! Adust for the burst characters too
    IF .RET_LEN[0] GTR 0
    THEN
	TOP_OFFSET	= .TOP_OFFSET + .RET_LEN[0] + 2;
						! adjust & allow for spacing
						!   allow for two spaces...

! Bottom of page - Bottom_offset already adjusted
!
BOTTOM_OFFSET = .PAGE_LENGTH - 5;		! offset includes burst offset

    FILL_FRAME (.SCB,
	    	.SCB[PSM$B_FILE_BURST_CHAR], 
	    	PAGE_REF[0,.BOTTOM_OFFSET,.PAGE_WIDTH], .PAGE_WIDTH, 3);

    FILL_FRAME (.SCB,
	    	%C' ',
	    	PAGE_REF[10,.BOTTOM_OFFSET,.PAGE_WIDTH], .PAGE_WIDTH-20, 3);

    FILL_FRAME (.SCB,				! Offset set... Add the diff
	    	.SCB[PSM$B_JOB_BURST_CHAR], 
	    	PAGE_REF[14,.BOTTOM_OFFSET,.PAGE_WIDTH], .PAGE_WIDTH-28, 3);

    ! re-init
    STRING_DESC[SIZE] = K_MAX_BUFFER_SIZE;	! reset buffer size

    !  Get the sys$announce note and output to page
    GET_DIGITAL_LOGO
	    	(.SCB,				! SCB addr.
	     	STRING_DESC[0],			! Buffer descriptor
		STRING_DESC[SIZE]);		! Returned length

    ! assume string will not over run the area... fail_safe is truncation 
    CENTER_FRAME (.SCB,
		   STRING_DESC[0],
		   PAGE_REF[0,.BOTTOM_OFFSET+1,.PAGE_WIDTH],
		   .PAGE_WIDTH, 1);


    ! re-init
    STRING_DESC[SIZE] = K_MAX_BUFFER_SIZE;	! reset buffer size

    GET_RULER_COARSE
	    	(.SCB,				! SCB addr.
	     	STRING_DESC[0],			! Buffer descriptor
		STRING_DESC[SIZE]);		! Returned length

    SCROLL_FRAME (.SCB,
		   STRING_DESC[0],
		   PAGE_REF[0,.BOTTOM_OFFSET + 4,.PAGE_WIDTH], .PAGE_WIDTH, 1);

    SCROLL_FRAME (.SCB,
		  $DESCRIPTOR ('1234567890'),
		   PAGE_REF[0,.BOTTOM_OFFSET + 5,.PAGE_WIDTH], .PAGE_WIDTH, 1);

!  Create a sentence describing the current job.
!
    ! re-init
    STRING_DESC[SIZE] = K_MAX_BUFFER_SIZE;	! reset buffer size

    GET_JOB_DESCRIPTION
	    	(.SCB,				! SCB addr.
		 0,				! Use past tense
	     	 STRING_DESC[0],		! Buffer descriptor
		 STRING_DESC[SIZE]);		! Returned length

    RET_LEN[0] = RETURN_FRAME_LENGTH
		 (.SCB,
		  STRING_DESC[0],	  	! string ref.
		  PAGE_REF[0,0,.PAGE_WIDTH],	! ref to frame
		  .PAGE_WIDTH,			! cols to fill
		  .BOTTOM_OFFSET - .TOP_OFFSET);! rows to fill

    IF .RET_LEN[0] GTR 0
    THEN
	BOTTOM_OFFSET = .BOTTOM_OFFSET - (.RET_LEN[0] + 1);
						! adjust & allow for spacing
						!   before inserting
    ! insert the string delimited						
    INSERT_FRAME (.SCB,
		  STRING_DESC[0],	  	! string ref.
		  PAGE_REF[0,.BOTTOM_OFFSET,.PAGE_WIDTH],
						! ref to frame
		  .PAGE_WIDTH,			! cols to fill
		  .RET_LEN[0]);		 	! rows to fill


!  Create a sentence describing the current file.
!
    ! re-init
    STRING_DESC[SIZE] = K_MAX_BUFFER_SIZE;	! reset buffer size

    GET_FILE_DESCRIPTION
	    	(.SCB,				! SCB addr.
	     	 STRING_DESC[0],		! Buffer descriptor
		 STRING_DESC[SIZE]);		! Returned length

    RET_LEN[0] = RETURN_FRAME_LENGTH
		 (.SCB,
		  STRING_DESC[0],	  	! string ref.
		  PAGE_REF[0,0,.PAGE_WIDTH],	! ref to frame
		  .PAGE_WIDTH,			! cols to fill
		  .BOTTOM_OFFSET - .TOP_OFFSET);! rows to fill

    IF .RET_LEN[0] GTR 0
    THEN
	BOTTOM_OFFSET = .BOTTOM_OFFSET - (.RET_LEN[0] + 1);
						! adjust & allow for spacing
						!   before inserting
    ! insert the string delimited						
    INSERT_FRAME (.SCB,
		  STRING_DESC[0],	  	! string ref.
		  PAGE_REF[0,.BOTTOM_OFFSET,.PAGE_WIDTH],
						! ref to frame
		  .PAGE_WIDTH,			! cols to fill
		  .RET_LEN[0]);		 	! rows to fill

! User name banner
!
    RET_LEN[0] = INSERT_NAME_BANNER (
			.SCB,
		 	SCB_SIZE_(USER_NAME),	! user name desc
		    	PAGE_REF[0,.TOP_OFFSET,.PAGE_WIDTH],
						! ref to frame
		    	.PAGE_WIDTH,		! max width Bann 
			.BOTTOM_OFFSET - .TOP_OFFSET,
						! frame size
		    	7);			! max hght Bann str

    IF .RET_LEN[0] GTR 0
    THEN
	TOP_OFFSET	= .TOP_OFFSET + .RET_LEN[0] + 2;
						! adjust & allow for spacing

!  Get and insert the filename banner ... force the banner to be small (always)
!
    ! re-init
    STRING_DESC[SIZE] = K_MAX_BUFFER_SIZE;	! reset buffer size

    FORCE_LEN = 7;
    IF .BOTTOM_OFFSET - .TOP_OFFSET LSS .FORCE_LEN
    THEN
	FORCE_LEN = .BOTTOM_OFFSET - .TOP_OFFSET;

    RET_LEN[0] = INSERT_FILENAME_BANNER 
			(.SCB,
		   	STRING_DESC[0],		! file name size
		    	PAGE_REF[0,.TOP_OFFSET,.PAGE_WIDTH],
						! ref to frame
		    	.PAGE_WIDTH,		! max width Bann 
		    	.FORCE_LEN);
						! max hght Bann str
    IF .RET_LEN[0] GTR 0
    THEN
	TOP_OFFSET	= .TOP_OFFSET + .RET_LEN[0] + 2;
						! adjust & allow for spacing

!  Create a phrase which includes all the appropriate qualifiers
!  describing the current print and insert from the bottom without spacing.
!
! re-init
    STRING_DESC[SIZE] = K_MAX_BUFFER_SIZE;	! reset buffer size

    GET_QUALIFIERS
	    	(.SCB,				! SCB addr.
	     	 STRING_DESC[0],		! Buffer descriptor
		 STRING_DESC[SIZE]);		! Returned length

    RET_LEN[0] = RETURN_FRAME_LENGTH
		 (.SCB,
		  STRING_DESC[0],	  	! string ref.
		  PAGE_REF[0,0,.PAGE_WIDTH],	! ref to frame
		  .PAGE_WIDTH-12,		! less twelve chars.
		  .BOTTOM_OFFSET - .TOP_OFFSET);! rows to fill

    IF .RET_LEN[0] GTR 0
    THEN
	BEGIN
	BOTTOM_OFFSET = .BOTTOM_OFFSET - (.RET_LEN[0] + 1);
						! adjust & allow for spacing
						!   before inserting

	! move the string undelimited						
	MOVE_FRAME (.SCB,
		  $DESCRIPTOR ('Qualifiers: '),
		  PAGE_REF[0,.BOTTOM_OFFSET,.PAGE_WIDTH],
						! ref to frame
		  .PAGE_WIDTH,			! cols to fill
		  .RET_LEN[0]);			! rows to fill
	END;

    ! insert the string delimited						
    INSERT_FRAME (.SCB,
		  STRING_DESC[0],		! string ref.
		  PAGE_REF[12,.BOTTOM_OFFSET,.PAGE_WIDTH],
						! ref to frame
		  .PAGE_WIDTH-12,		! cols to fill
		  .RET_LEN[0]);			! rows to fill

END;

%sbttl 'RETURN_FRAME_LENGTH - Returns the Frame Length for String Insertion'
!++
! Functional Description:
!	Returns the frame length needed to insert the string into the page.
!	This routine checks the top_of_frame/bottom_of_frame offsets and
!	decides if the string will fit-
!	1) yes - return number of frame rows required for string to fit.
!	2) no  - return zero
!
!
! Formal Parameters:
!	SCB		- Address of the SCB
!	STR_DESC	- Descriptor of String to Insert
!	FRAME_PTR	- Address of first byte of Frame
!	FRAME_LENGTH	- Length of Frame
!	FRAME_WIDTH	- Width of Frame
!
!
! Implicit Inputs:
!		none
!
! Implicit Outputs:
!		none
!
! Returned Value:
!		none
!
! Side Effects:
!		none
!--
ROUTINE RETURN_FRAME_LENGTH (
	SCB		: REF $BBLOCK,
	STR_DESC	: REF VECTOR[2],
	FRAME_PTR	: REF PAGE_ARRAY,
	FRAME_WIDTH	,		! Number of Columns
	FRAME_LENGTH			! Number of Rows
		     ) =
BEGIN

LOCAL MAX_CHARS;

! don't even try if there is no frame left
IF (.FRAME_LENGTH LEQ 0) OR
    (.FRAME_WIDTH LEQ 0) OR
    (.STR_DESC[SIZE] EQL 0)
THEN
    RETURN 0;

MAX_CHARS = .FRAME_WIDTH * .FRAME_LENGTH;

! The boundary condition of string size of some multiple of frame width
!   can occur - add one less than the frame width to overcome this condition
!
IF .STR_DESC[SIZE] LEQ .MAX_CHARS
THEN
    RETURN ((.STR_DESC[SIZE]+(.FRAME_WIDTH-1)) / .FRAME_WIDTH);

! otherwise it just won't fit 
RETURN 0;

END;

%sbttl 'RETURN_FRAME_WIDTH - Returns the Frame Length for String Insertion'
!++
! Functional Description:
!	Returns the frame width needed to insert the required lengths into
!	the page.  This routine returns only a prescribed value and 
!	decides if the string will fit -
!	Return value - frame_width
!	Return zero - only if no length or width of frame.
!	Assumes the FRAME_LENGTH is constant. (How many lengths are needed
!	to fit this string)
!
! Formal Parameters:
!	SCB		- Address of the SCB
!	STR_DESC	- Descriptor of String to Insert
!	FRAME_PTR	- Address of first byte of Frame
!	FRAME_LENGTH	- Length of Frame
!	FRAME_WIDTH	- Width of Frame
!
!
! Implicit Inputs:
!		none
!
! Implicit Outputs:
!		none
!
! Returned Value:
!		none
!
! Side Effects:
!		none
!--
ROUTINE RETURN_FRAME_WIDTH (
	SCB		: REF $BBLOCK,
	STR_DESC	: REF VECTOR[2],
	FRAME_PTR	: REF PAGE_ARRAY,
	FRAME_WIDTH	,		! Number of Columns
	FRAME_LENGTH			! Number of Rows
		     ) =
BEGIN

LOCAL 
    MAX_CHARS,
    TEMP_WIDE;

! don't even try if there is no frame left
IF (.FRAME_LENGTH LEQ 0) OR
    (.FRAME_WIDTH LEQ 0) OR
    (.STR_DESC[SIZE] EQL 0)
THEN
    RETURN 0;

MAX_CHARS = .FRAME_WIDTH * .FRAME_LENGTH;
IF .MAX_CHARS LSS .STR_DESC[SIZE]
THEN
    RETURN 0;					! string wont fit

! The boundary condition of string size of some multiple of frame width
!   can occur - add one less than the frame width to overcome this condition
!
TEMP_WIDE = .STR_DESC[SIZE]/.FRAME_LENGTH;

IF .TEMP_WIDE LEQ .FRAME_WIDTH
THEN
    RETURN (.TEMP_WIDE);			! return the value

! otherwise it just won't fit 
RETURN 0;

END;

%sbttl 'GET_REVISION_DATE - Get the revision date of current file'
!++
! Functional Description:
!	This routine creates a phrase with DD-MMM-YYYY HH:MM describing
!	the revision date of the current file.  Returns zero if file
!	not open.
!
! Formal Parameters:
!	SCB		- Address of the SCB
!	STR_DESC	- Desc of String to Return
!	RET_LEN		- Return length of Desc.
!
! Implicit Inputs:
!		none
!
! Implicit Outputs:
!		none
!
! Returned Value:
!		none
!
! Side Effects:
!		none
!--
ROUTINE	GET_REVISION_DATE	(
		SCB		: REF $BBLOCK,		! SCB
		STR_DESC	: REF VECTOR[2],	! Output buffer desc
		RET_LEN		: REF VECTOR [,WORD]	! Return length (word)
			    )	: NOVALUE =
BEGIN
BIND
    XABDAT = .SCB[PSM$A_XABDAT]: $BBLOCK,	! - RMS date block
    FORMAT = $DESCRIPTOR (  
	'!17%D' ),				! - revision date

    NAM = .SCB[PSM$A_NAM]: REF $BBLOCK;

LOCAL
    CURRENT_LEN	: INITIAL (0);

IF FILE_OPEN(.SCB) 
THEN
    $FAO (
	FORMAT,
	CURRENT_LEN,
	STR_DESC[0],
	XABDAT[XAB$Q_RDT],	
	);

RET_LEN[0] = .CURRENT_LEN;

END;

%sbttl 'GET_SYSTEM_ANNOUNCEMENT- Create a Sentence Describing the Current Job'
!++
! Functional Description:
!	This routine get the system annoucement. All allocation of buffers
!	handled by caller
!
! Formal Parameters:
!	SCB		- Address of the SCB
!	STR_DESC	- Desc of String to Return
!	RET_LEN		- Return length of Desc.
!
! Implicit Inputs:
!		none
!
! Implicit Outputs:
!		none
!
! Returned Value:
!		none
!
! Side Effects:
!		none
!--
ROUTINE GET_SYSTEM_ANNOUNCEMENT (
		SCB		: REF $BBLOCK,		! SCB
		STR_DESC	: REF VECTOR[2],	! Output buffer desc
		RSL_LEN		: REF VECTOR [,WORD]	! Return length (word)
			    )	: NOVALUE =
BEGIN
BIND
    DEFINED_ANNOUNCE = $DESCRIPTOR (
		'!AF'	),		! - Defined announcement

    ANNOUNCE = $DESCRIPTOR ( 
		'PSM$ANNOUNCE' );	! - system annoucement

LOCAL
    FAO_DESC	: VECTOR[2],
    BUFFER	: VECTOR[256,byte],
    TEMP_LEN 	: INITIAL (0),
    STATUS	;

FAO_DESC[SIZE] = %ALLOCATION(BUFFER);
FAO_DESC[ADDR] = BUFFER;

!STATUS = $TRNLNM(attr  =LNM$M_CASE_BLIND,
!		 tabnam=%ASCID 'LNM$SYSTEM_TABLE', 
!		 lognam= ANNOUNCE,
!		 rsllen= FAO_DESC[SIZE],
!		 rslbuf= FAO_DESC[ADDR]);

STATUS = $TRNLOG(lognam= ANNOUNCE,
		 rslbuf= FAO_DESC,
		 rsllen= TEMP_LEN);

IF .STATUS 
THEN				! Success - Normal, Buffer_overflow
    !
    ! check for command file pointer "@" sign or no-translation code
    !
    BEGIN
    IF (.STATUS EQL SS$_NOTRAN)
    THEN
	TEMP_LEN = 0;
    END
ELSE					! Bad status - Badparam, Badlength,
    TEMP_LEN = 0;			!  Badtable, Notfound(badname), Baddepth

IF .TEMP_LEN EQL 0			! Get the default sys version #
THEN
    ! Put in the Digital Logo
    GET_DIGITAL_LOGO(.SCB,STR_DESC[0],RSL_LEN[0])
ELSE
    $FAO (
	DEFINED_ANNOUNCE, 
	RSL_LEN[0], 
	STR_DESC[0],
	.TEMP_LEN,
	.FAO_DESC[ADDR]);

END;

%sbttl 'GET_VMS_LOGO - Create a Phrase of VMS logo'
!++
! Functional Description:
!	VAX/VMS Version Vx.x
!
! Formal Parameters:
!	SCB		- Address of the SCB
!	STR_DESC	- Desc of String to Return
!	RET_LEN		- Return length of Desc.
!
! Implicit Inputs:
!		none
!
! Implicit Outputs:
!		none
!
! Returned Value:
!		none
!
! Side Effects:
!		none
!--
ROUTINE GET_VMS_LOGO (
		SCB		: REF $BBLOCK,		! SCB
		STR_DESC	: REF VECTOR[2],	! Output buffer desc
		RSL_LEN		: REF VECTOR [,WORD]	! Return length (word)
			    )	: NOVALUE =
BEGIN
BIND
    TRAILING = 1,

    DEFAULT = $DESCRIPTOR (
		'VAX/VMS  ',
		'VAX/VMS  ',
		'VAX/VMS  ',
		'VAX/VMS  ',
		'VAX/VMS  ',
		'VAX/VMS  ',
		'VAX/VMS  ',
		'VAX/VMS  ',
		'VAX/VMS  ',
		'VAX/VMS  ',
		'VAX/VMS  ',
		'VAX/VMS  ',
		'VAX/VMS  ',
		'VAX/VMS  ',
		'VAX/VMS  ',
		'VAX/VMS  ',
		'VAX/VMS  ',
		'VAX/VMS  ',
		'VAX/VMS  ',
		'VAX/VMS  ',
		'VAX/VMS  ',
		'VAX/VMS  ',
		'VAX/VMS  ',
		'VAX/VMS  ',
		'VAX/VMS' );

LOCAL
    STR_PTR	,
    STR_LEN	;

IF .SCB[PSM$L_PAGE_WIDTH] LSS 20
THEN					! no room for burst bar
    BEGIN
    RSL_LEN[0] = 0;
    RETURN;
    END;

$FAO (
     DEFAULT, 
    RSL_LEN[0], 
    STR_DESC[0]);

RSL_LEN[0] = .SCB[PSM$L_PAGE_WIDTH] - 20;	! set the page length
						!  largest less than 180
STR_PTR = CH$PTR(.STR_DESC[ADDR]+.RSL_LEN[0]);

WHILE CH$NEQ( 1, .STR_PTR, 1, CH$PTR(UPLIT(' ')))
DO						! trim off chars until blanks
    BEGIN
    RSL_LEN[0] = .RSL_LEN[0] - 1;
    STR_PTR = CH$PTR(.STR_DESC[ADDR]+.RSL_LEN[0]);
    END;

END;

%sbttl 'GET_DIGITAL_LOGO - Create a Phrase of Digital logo'
!++
! Functional Description:
!	VAX/VMS Version Vx.x
!
! Formal Parameters:
!	SCB		- Address of the SCB
!	STR_DESC	- Desc of String to Return
!	RET_LEN		- Return length of Desc.
!
! Implicit Inputs:
!		none
!
! Implicit Outputs:
!		none
!
! Returned Value:
!		none
!
! Side Effects:
!		none
!--
ROUTINE GET_DIGITAL_LOGO (
		SCB		: REF $BBLOCK,		! SCB
		STR_DESC	: REF VECTOR[2],	! Output buffer desc
		RSL_LEN		: REF VECTOR [,WORD]	! Return length (word)
			    )	: NOVALUE =
BEGIN
BIND
    DEFAULT = $DESCRIPTOR (
		'!AC - VAX/VMS Version ',
		'!AS');

LOCAL
    LOGO	,
    FAO_DESC	: VECTOR[2],
    BUFFER	: VECTOR[20,byte],
    ITEM_LIST	: $ITMLST_DECL (ITEMS=1);

FAO_DESC[SIZE] = %ALLOCATION(BUFFER);
FAO_DESC[ADDR] = BUFFER;

IF .SCB[PSM$L_PAGE_WIDTH] LSS 52		! 52 chars in complete logo
THEN
    LOGO = UPLIT BYTE (%ASCIC 'DEC')
ELSE
    LOGO = UPLIT BYTE (%ASCIC 'Digital Equipment Corporation');

$ITMLST_INIT (ITMLST=ITEM_LIST,
    (
    ITMCOD=SYI$_VERSION,
    BUFADR=.FAO_DESC[ADDR],
    BUFSIZ=8,
    RETLEN=FAO_DESC[SIZE]
    ));

$GETSYIW(ITMLST=ITEM_LIST);

FAO_DESC[SIZE] = DELIMIT_STRING_NOT (.FAO_DESC[ADDR], 
				      %CHAR(32), .FAO_DESC[SIZE]);
$FAO (
    DEFAULT, 
    RSL_LEN[0], 
    STR_DESC[0],
    .LOGO,
    FAO_DESC[0])			! version

END;

%sbttl 'GET_JOB_DESCRIPTION - Create a Sentence Describing the Current Job'
!++
! Functional Description:
!	This routine creates a sentence describing the current job.
!
! Formal Parameters:
!	SCB		- Address of the SCB
!	STR_DESC	- Desc of String to Return
!	RET_LEN		- Return length of Desc.
!
! Implicit Inputs:
!		none
!
! Implicit Outputs:
!		none
!
! Returned Value:
!		none
!
! Side Effects:
!		none
!--
ROUTINE GET_JOB_DESCRIPTION (
		SCB		: REF $BBLOCK,		! SCB
		TIME_FLAG	,
		STR_DESC	: REF VECTOR[2],	! Output buffer desc
		RET_LEN		: REF VECTOR [,WORD]	! Return length (word)
			    )	: NOVALUE =
BEGIN
BIND
    TRAILING	= 1,
    LEADING	= 0,

    NODE = $DESCRIPTOR ( 
	'SYS$NODE'),! - system annoucement

    DATE_FORMAT = $DESCRIPTOR (
	'!17%D'),

    SENT_FORMAT1 = $DESCRIPTOR (  
	'Job !AS ',			! - job name
	'(!UL) ',			! - job number
	'queued to !AS ',		! - batch file name(pres tense)
	'on !AS ',			! - time queued
	'by user !AS, ',		! - user name
	'UIC !%I, ',			! - user uic
	'under account !AS ',		! - user account
	'at priority !UL, ',		! - que priority
	'!AC ',				! - 'started'/'completed'/
					!   'restarted'/'aborted'
	'on printer !AS ',		! - device name
	'on !AS ',			! - time printed
	'from queue !AS',		! - executor queue
	'.'	);			! - period

LOCAL
    RET_LENGTH		,
    STATUS		,
    DOUBLE_COLONS	,
    CHOICE		,
    DATE_QUEUED		: VECTOR[2],
    DATE_QUEUED_BUFF	: VECTOR [17,byte],
    DATE_PRINTED	: VECTOR[2],
    DATE_PRINTED_BUFF	: VECTOR [17,byte],
    ACCOUNT_DESC	: VECTOR [2],
    USERNAME_DESC	: VECTOR [2];	  ! desc of string

! get the user name delimited
!
USERNAME_DESC[SIZE] = .SCB_SIZE_ (USER_NAME);
USERNAME_DESC[ADDR] = .SCB_ADDR_ (USER_NAME);
! Insert only the string ... No trailing blanks
!
DISCARD (TRAILING, %C' ', .USERNAME_DESC[ADDR], .USERNAME_DESC[SIZE], 
	 USERNAME_DESC[SIZE],USERNAME_DESC[ADDR]); !Return length and pointer

! get the account name delimited
!
ACCOUNT_DESC[SIZE] = .SCB_SIZE_ (ACCOUNT_NAME);
ACCOUNT_DESC[ADDR] = .SCB_ADDR_ (ACCOUNT_NAME);
! Insert only the string ... No trailing blanks
!
DISCARD (TRAILING, %C' ', .ACCOUNT_DESC[ADDR], .ACCOUNT_DESC[SIZE], 
	 ACCOUNT_DESC[SIZE],ACCOUNT_DESC[ADDR]); ! Return length and pointer

! start, restart and complete
IF .TIME_FLAG
THEN
    BEGIN
    CHOICE = UPLIT BYTE (%ASCIC 'started');
    IF .REQUEST_FLAG_ (RESTARTING)
    THEN
	CHOICE = UPLIT BYTE (%ASCIC 'restarted');
    END 
ELSE
    BEGIN
    BIND CONDITION = SCB[PSM$T_CONDITION_AREA] : VECTOR; ! Task completion status

    ! Assume job completed normally
    !
    CHOICE = UPLIT BYTE (%ASCIC 'completed');

    ! Check completion status for an error
    !
    IF .CONDITION[0] NEQU 0
    THEN
	BEGIN
	! Assume job controller or symbiont initiated abort
	!
	CHOICE = UPLIT BYTE (%ASCIC 'ABORTED');

	! Check for special case of job controller inititated requeue
	!

!*! FEATURE DISABLED UNTIL JOB CONTROLLER MESSAGE AVAILABILTY STRAIGHTENED OUT
!*!	IF .CONDITION[0] EQLU JBC$_JOBREQUEUE
!*!	THEN
!*!	    CHOICE = UPLIT BYTE (%ASCIC 'REQUEUED');

	END;
    END;

! Get and delimit the date/times
!   time queued
DATE_QUEUED[SIZE] = %ALLOCATION(DATE_QUEUED_BUFF);
DATE_QUEUED[ADDR] = DATE_QUEUED_BUFF;

$FAO (	DATE_FORMAT,
	RET_LENGTH,
	DATE_QUEUED[0],
	SCB[PSM$Q_TIME_QUEUED]);
!
DISCARD (LEADING, %C' ', .DATE_QUEUED[ADDR], .RET_LENGTH, 
	 DATE_QUEUED[SIZE],DATE_QUEUED[ADDR]);	! Return length and pointer
DISCARD (TRAILING, %C' ', .DATE_QUEUED[ADDR], .RET_LENGTH, 
	 DATE_QUEUED[SIZE],DATE_QUEUED[ADDR]);	! Return length and pointer

!   time printed
DATE_PRINTED[SIZE] = %ALLOCATION(DATE_PRINTED_BUFF);
DATE_PRINTED[ADDR] = DATE_PRINTED_BUFF;

$FAO (	DATE_FORMAT,
	RET_LENGTH,
	DATE_PRINTED[0],
	SCB[PSM$Q_TIME_PRINTED]);
!
DISCARD (LEADING, %C' ', .DATE_PRINTED[ADDR], .RET_LENGTH, 
	 DATE_PRINTED[SIZE],DATE_PRINTED[ADDR]);! Return length and pointer
DISCARD (TRAILING, %C' ', .DATE_PRINTED[ADDR], .RET_LENGTH, 
	 DATE_PRINTED[SIZE],DATE_PRINTED[ADDR]);! Return length and pointer

$FAO (	SENT_FORMAT1, 
	RET_LEN[0], 
	STR_DESC[0],
	SCB[PSM$Q_JOB_NAME],			! job name
	.SCB[PSM$L_ENTRY_NUMBER],		! entry number
	SCB[PSM$Q_QUEUE],			! batch que present tense
	DATE_QUEUED[0],				! time queued
	USERNAME_DESC[0],			! user name
	.SCB[PSM$L_UIC],			! user uic
	ACCOUNT_DESC[0],			! user account
	.SCB[PSM$L_PRIORITY],			! queue priority
	.CHOICE,				! started/completed/restarted
	SCB[PSM$Q_DEVICE_NAME],			! device name
	DATE_PRINTED[0],			! time printed
	SCB[PSM$Q_EXECUTOR_QUEUE]		! executor queue
    );

RETURN SS$_NORMAL;
END;

%sbttl 'GET_FILE_DESCRIPTION - Create a Sentence Describing the Current File'
!++
! Functional Description:
!	This routine creates a sentence describing the current File.
!
! Formal Parameters:
!	SCB		- Address of the SCB
!	STR_DESC	- Desc of String to Return
!	RET_LEN		- Return length of Desc.
!
! Implicit Inputs:
!		none
!
! Implicit Outputs:
!		none
!
! Returned Value:
!		none
!
! Side Effects:
!		none
!--
ROUTINE	GET_FILE_DESCRIPTION	(
		SCB		: REF $BBLOCK,		! SCB
		STR_DESC	: REF VECTOR[2],	! Output buffer desc
		RET_LEN		: REF VECTOR [,WORD]	! Return length (word)
			    )	: NOVALUE =
BEGIN
BIND
    FAB = .SCB[PSM$A_FAB]: $BBLOCK,
    NAM = .SCB[PSM$A_NAM]: $BBLOCK,
    XABDAT = .SCB[PSM$A_XABDAT]: $BBLOCK,
    XABFHC = .SCB[PSM$A_XABFHC]: $BBLOCK,
    XABPRO = .SCB[PSM$A_XABPRO]: $BBLOCK,

    FORMAT_POS = $DESCRIPTOR (  
	'File !AS ',				! - file name
	'(!UL,!UL,!UL), ',			! - file Id number
	'last revised on !17%D, ',		! - revision date
	'is a !UL block ',			! - file size
	'!AC file ',				! - file organization
	'owned by UIC !%I.  '),			! - owner user uic

    RECORD_FORMAT = $DESCRIPTOR (
	'The records are ',	! - 
	'!AC with '),				! - record format

    RECORD_VFC_FORMAT = $DESCRIPTOR (
	'The records are ',	! - 
	'variable length with a ',
	'fixed control size of !UL byte!%S and '),
						! - fixed control area size

    REC_SIZE = $DESCRIPTOR (  
	'  The longest record is !UL byte!%S.'),
						! - max record size

    CARRIAGE_FORMAT = $DESCRIPTOR (  
	'!AC.'),				! - record attributes

    FORMAT_NEG = $DESCRIPTOR (
	'File (!AS) description is unavailable to the symbiont.');

LITERAL
    K_MAX_BUFFER_SIZE = 512;

LOCAL
    RECORD_SIZE		,
    FILE_SIZE		,
    ORGANIZATION	,
    ATTRIBUTES		,
    FORMAT		,
    CURRENT_LEN		: INITIAL (0),
    DATE_REVISED	: VECTOR[2],
    STRING_PTR		: VECTOR [2];		! Pointer to current string

! Allocate the buffer for "GET_xxx" Routines
!
STRING_PTR[SIZE] = K_MAX_BUFFER_SIZE;
STRING_PTR[ADDR] = .STR_DESC[ADDR];	! init address 

RET_LEN[0] = 0;

IF FILE_OPEN(.SCB) 
THEN
    BEGIN
    ! get the file size
    !
    FILE_SIZE = .XABFHC[XAB$L_EBK];
    IF (.XABFHC[XAB$W_FFB] EQL 0) AND
       ( .FILE_SIZE NEQ 0)
    THEN
	FILE_SIZE = .FILE_SIZE - 1;

    ! insert file organization
    !
    IF .FAB[FAB$B_ORG] EQL FAB$C_IDX
    THEN
	ORGANIZATION = UPLIT BYTE (%ASCIC 'indexed')
    ELSE IF .FAB[FAB$B_ORG] EQL FAB$C_SEQ
    THEN
	ORGANIZATION = UPLIT BYTE (%ASCIC 'sequential')
    ELSE IF .FAB[FAB$B_ORG] EQL FAB$C_REL
    THEN
	ORGANIZATION = UPLIT BYTE (%ASCIC 'relative')
    ELSE
	ORGANIZATION = UPLIT BYTE (%ASCIC 'undefined organization');


    $FAO (  FORMAT_POS,
	    CURRENT_LEN,
	    STRING_PTR[0],
	    SCB[PSM$Q_FILE_SPECIFICATION],
	    .NAM[NAM$W_FID_NUM],
	    .NAM[NAM$W_FID_SEQ],
	    .NAM[NAM$W_FID_RVN],
	    XABDAT[XAB$Q_RDT],	
	    .FILE_SIZE,
	    .ORGANIZATION,
	    .XABPRO[XAB$L_UIC]
	);

    RET_LEN[0] = .RET_LEN[0] + .CURRENT_LEN;
    STRING_PTR[ADDR] = .STRING_PTR[ADDR] + .CURRENT_LEN;
    STRING_PTR[SIZE] = K_MAX_BUFFER_SIZE - .RET_LEN[0];

    ! get record format
    !

    RECORD_SIZE = .XABFHC[XAB$W_LRL];		! record size

    IF .FAB[FAB$B_RFM] NEQ FAB$C_VFC
    THEN
	BEGIN
	! get record type
	!
	SELECTONE .FAB[FAB$B_RFM] OF
	    SET
	    [FAB$C_FIX]:	FORMAT = UPLIT BYTE 
					(%ASCIC 'fixed-length');
	    [FAB$C_STM]:	FORMAT = UPLIT BYTE 
					(%ASCIC 'stream');
	    [FAB$C_STMCR]:	FORMAT = UPLIT BYTE 
					(%ASCIC 'stream-CR');
	    [FAB$C_STMLF]:	FORMAT = UPLIT BYTE 
					(%ASCIC 'stream-LF');
	    [FAB$C_UDF]:	FORMAT = UPLIT BYTE
					(%ASCIC 'an undefined format');
	    [FAB$C_VAR]:	FORMAT = UPLIT BYTE 
					(%ASCIC 'variable length');
	    TES;

	$FAO (  RECORD_FORMAT,
		CURRENT_LEN,
		STRING_PTR[0],
		.FORMAT
	    );

	END
    ELSE
	$FAO (  RECORD_VFC_FORMAT,
		CURRENT_LEN,
		STRING_PTR[0],
		.FAB[FAB$B_FSZ]
	    );

    RET_LEN[0] = .RET_LEN[0] + .CURRENT_LEN;
    STRING_PTR[ADDR] = .STRING_PTR[ADDR] + .CURRENT_LEN;
    STRING_PTR[SIZE] = K_MAX_BUFFER_SIZE - .RET_LEN[0];

    ! get carriage control
    !
    IF .FAB[FAB$V_CR]
    THEN
	ATTRIBUTES = UPLIT BYTE (%ASCIC 'implied (CR) carriage control')
    ELSE
	BEGIN
	IF .FAB[FAB$V_FTN]
	THEN
	    ATTRIBUTES = UPLIT BYTE (%ASCIC 'FORTRAN (FTN) carriage control')
	ELSE
	    BEGIN
	    IF .FAB[FAB$V_PRN]
	    THEN
		ATTRIBUTES = 
			UPLIT BYTE (%ASCIC 'print file (PRN) carriage control')
	    ELSE
		ATTRIBUTES = UPLIT BYTE 
			(%ASCIC 'imbedded (<none>) carriage control');
	    END;
	END;

    $FAO (
	CARRIAGE_FORMAT,
	CURRENT_LEN,
	STRING_PTR[0],
	.ATTRIBUTES );

    RET_LEN[0] = .RET_LEN[0] + .CURRENT_LEN;
    STRING_PTR[ADDR] = .STRING_PTR[ADDR] + .CURRENT_LEN;
    STRING_PTR[SIZE] = K_MAX_BUFFER_SIZE - .RET_LEN[0];

    IF .FAB[FAB$B_RFM] NEQ FAB$C_FIX
    THEN
	BEGIN
	$FAO (
	    REC_SIZE,
	    CURRENT_LEN,
	    STRING_PTR[0],
	    .RECORD_SIZE );

	RET_LEN[0] = .RET_LEN[0] + .CURRENT_LEN;
	STRING_PTR[ADDR] = .STRING_PTR[ADDR] + .CURRENT_LEN;
	STRING_PTR[SIZE] = K_MAX_BUFFER_SIZE - .RET_LEN[0];
	END;

    END
ELSE
    BEGIN
    $FAO (
	FORMAT_NEG,
	CURRENT_LEN,
	STRING_PTR[0],
	SCB[PSM$Q_FILE_SPECIFICATION]
	);

    RET_LEN[0] = .CURRENT_LEN;
    END;

! final check for overflow
IF .RET_LEN[0] GTR K_MAX_BUFFER_SIZE
THEN
    BEGIN
	RET_LEN[0] = 512;
	RETURN;
    END;

RETURN SS$_NORMAL;
END;

%sbttl 'GET_FILE_NAME - Get Name of the Current File'
!++
! Functional Description:
!	This routine creates a phrase with the name of the current file.
!
! Formal Parameters:
!	SCB		- Address of the SCB
!	STR_DESC	- Desc of String to Return
!	RET_LEN		- Return length of Desc.
!
! Implicit Inputs:
!		none
!
! Implicit Outputs:
!		none
!
! Returned Value:
!		none
!
! Side Effects:
!		none
!--
ROUTINE GET_FILE_NAME (
		SCB		: REF $BBLOCK,		! SCB
		EXPECTED_LEN	,			! Maximum length allowed
		STR_DESC	: REF VECTOR[2],	! Output buffer desc
		RET_LEN		: REF VECTOR [,WORD]	! Return length (word)
			    )	: NOVALUE =
BEGIN
BIND
    SENT_FORMAT = $DESCRIPTOR (
	'!AS');

LOCAL
    BUFFER	: VECTOR [512,byte],
    LENG	: VECTOR [1],
    NAME	:  VECTOR[2];

NAME[SIZE] = %ALLOCATION(BUFFER);	! allocate for routines
NAME[ADDR] = BUFFER;			! init address 

$FAO (  SENT_FORMAT, 
	NAME[SIZE],			! return length
	NAME,				! address of string
	SCB[PSM$Q_FILE_SPECIFICATION],	! file name
     );

LENG[0] = .EXPECTED_LEN;	!  must be reference to word for call

IF .RET_LEN[0] GTR .EXPECTED_LEN THEN
    !  Trim the file spec to fit.
    !
    LIB$TRIM_FILESPEC ( NAME, STR_DESC[0], LENG[0], 
			STR_DESC[SIZE])
ELSE
    BEGIN
    STR_DESC[SIZE] = .NAME[SIZE];
    STR_DESC[ADDR] = .NAME[ADDR];
    END;

RET_LEN[0] = .STR_DESC[SIZE];

RETURN SS$_NORMAL;
END;

%sbttl 'INSERT_FILENAME_BANNER - Get Name of the Current File'
!++
! Functional Description:
!	This routine creates a banner phrase with the name of the current file.
!	Algorithm:
!		If the Filename, Type, and Version (FTV) fits on one line 
!		If only one banner line exists....
!						insert FTV on only ONE line
!
!		If there are Three banner lines available...
!						insert Filename on one, Type on
!						another, and Version on third
!
!		Otherwise...			insert Filename on one, Type and
!						Version on the second
!
! Formal Parameters:
!	SCB		- Address of the SCB
!	STR_DESC	- Desc of String to Return
!	RET_LEN		- Return length of Desc.
!
! Implicit Inputs:
!		none
!
! Implicit Outputs:
!		none
!
! Returned Value:
!		none
!
! Side Effects:
!		none
!--
ROUTINE INSERT_FILENAME_BANNER (
	SCB		: REF $BBLOCK,
	STR_DESC	: REF VECTOR[2],
	FRAME_PTR	: REF PAGE_ARRAY,
	FRAME_WIDTH	,		! Number of Columns
	FRAME_LENGTH			! Number of Rows
	)  =
BEGIN
LITERAL
    BIG_BANNER = 14,
    LITTLE_BANNER = 7,
    SMALL = 2,
    LARGE = 1;

LOCAL
    RET_LEN	: VECTOR[1],
    PAGE_PTR	: REF PAGE_ARRAY,
    SPACING	,
    CURRENT_PTR	,
    FTV_LEN	: VECTOR[1],
    BANNER_TYPE	,
    BANNER_SIZE	,
    MAX_BAN_CHARS,
    MAX_ROWS	,
    MAX_COLS	,
    NAME	: VECTOR[2],
    TYPE	: VECTOR[2],
    VERS	: VECTOR[2];

! dont even try if there is no frame left
!
IF (.FRAME_LENGTH LSS 7)
THEN
    RETURN 0;

PARSE_FILE_NAME (SCB[PSM$Q_FILE_SPECIFICATION], FSCN$_NAME, NAME);
PARSE_FILE_NAME (SCB[PSM$Q_FILE_SPECIFICATION], FSCN$_TYPE, TYPE);
PARSE_FILE_NAME (SCB[PSM$Q_FILE_SPECIFICATION], FSCN$_VERSION, VERS);

FTV_LEN[0] = .NAME[SIZE] + .TYPE[SIZE] + .VERS[SIZE];

BANNER_TYPE = BIG_BANNER;
BANNER_SIZE = LARGE;
SPACING = SMALL;				! two spaces between banner rows

MAX_BAN_CHARS = (.FRAME_LENGTH/16) * (.FRAME_WIDTH/12);
MAX_ROWS = .BANNER_SIZE * (.FRAME_LENGTH / 16);
MAX_COLS = .BANNER_SIZE * (.FRAME_WIDTH / 12);

IF .MAX_BAN_CHARS LSS .FTV_LEN[0]
THEN
    BEGIN
    BANNER_SIZE = SMALL;
    BANNER_TYPE = LITTLE_BANNER;
    SPACING = LARGE;				! single space banner rows
    MAX_ROWS = .BANNER_SIZE * (.FRAME_LENGTH / 18);
    MAX_COLS = .BANNER_SIZE * (.FRAME_WIDTH / 14);
    END;


! Do somemore calculations to ensure consistent letter sizing
!	!X! Just to gte this out the door...  needs to be optimized later.rb
!
IF (	(.NAME[SIZE] GTR .MAX_COLS)
			OR
	(.TYPE[SIZE] GTR .MAX_COLS)
			OR
	(.VERS[SIZE] GTR .MAX_COLS)
			OR
	(	(.MAX_ROWS LSS 3) AND
	((.TYPE[SIZE] + .VERS[SIZE]) GTR .MAX_COLS)
			OR
	(.FTV_LEN[0] GTR (.MAX_COLS * .MAX_ROWS))  )
	)
THEN
    BEGIN
    BANNER_SIZE = SMALL;
    BANNER_TYPE = LITTLE_BANNER;
    SPACING = LARGE;				! single space banner rows
    MAX_ROWS = .BANNER_SIZE * (.FRAME_LENGTH / 18);
    MAX_COLS = .BANNER_SIZE * (.FRAME_WIDTH / 14);
    END;

! Attempt to fit the filename, type, and version on one line
!
IF (.FTV_LEN[0] LEQ .MAX_COLS)			! insert on one line
	AND					! only if little banner
   (.BANNER_TYPE EQL LITTLE_BANNER)
THEN
    BEGIN
    CURRENT_PTR = .STR_DESC[ADDR];
    CURRENT_PTR = CH$MOVE(.NAME[SIZE], .NAME[ADDR], .CURRENT_PTR);
    CURRENT_PTR = CH$MOVE(.TYPE[SIZE], .TYPE[ADDR], .CURRENT_PTR);
    CURRENT_PTR = CH$MOVE(.VERS[SIZE], .VERS[ADDR], .CURRENT_PTR);
    STR_DESC[SIZE] = .FTV_LEN[0];

    INSERT_NAME_BANNER (.SCB,
		 	STR_DESC[SIZE],		! job name desc
		    	FRAME_PTR[0,0,.SCB[PSM$L_PAGE_WIDTH]],
						! ref to frame
		    	.FRAME_WIDTH,		! max width Bann 
			.BANNER_TYPE,		! frame length
		    	.BANNER_TYPE);		! max hght Bann str

    RETURN  .BANNER_TYPE;			! return how much space used
    END
ELSE
    BEGIN
    !  Move filename with truncated banners when not enough space
    !  
    IF ( 	(.MAX_ROWS LEQ 1) )
!
! !X! Comment this out .... causes too many filenames to be printed on
! !X! a single line when two lines would be more appropriate.
!
!			OR
!	(.NAME[SIZE] GTR .MAX_COLS)
!			OR
!	(.TYPE[SIZE] GTR .MAX_COLS)
!			OR
!	(.VERS[SIZE] GTR .MAX_COLS)
!			OR
!	(	(.MAX_ROWS LSS 3) AND
!	((.TYPE[SIZE] + .VERS[SIZE]) GTR .MAX_COLS)
!			OR
!	(.FTV_LEN[0] GTR (.MAX_COLS * .MAX_ROWS))  )
!	)
    THEN
	BEGIN
	CURRENT_PTR = .STR_DESC[ADDR];
	CURRENT_PTR = CH$MOVE(.NAME[SIZE], .NAME[ADDR], .CURRENT_PTR);
	CURRENT_PTR = CH$MOVE(.TYPE[SIZE], .TYPE[ADDR], .CURRENT_PTR);
	CURRENT_PTR = CH$MOVE(.VERS[SIZE], .VERS[ADDR], .CURRENT_PTR);

!X! This is a cludge to get this out the door.  I will declare a valid
!   descriptor in the future and use LIB$TRIM_FILESPEC.
!
	STR_DESC[SIZE] = .FTV_LEN[0];

	IF .NAME[0] GEQ .MAX_COLS
	THEN
	    (STR_DESC[SIZE] = .MAX_COLS)
	ELSE 
	    (IF .NAME[0]+.TYPE[0] GTR .MAX_COLS
	    THEN
		STR_DESC[SIZE] = .NAME[0]
		ELSE
		    IF ((.NAME[0]+TYPE[0]+VERS[0]) GTR .MAX_COLS)
		    THEN
			STR_DESC[SIZE] = .NAME[0]+.TYPE[0]);

!	IF .FTV_LEN[0] GTR (.MAX_ROWS * .MAX_COLS)
!	THEN
!	    !  Trim the file spec to fit.
!	    !
!	    LIB$TRIM_FILESPEC ( STR_DESC, STR_DESC[0], 
!			    .MAX_COLS, 
!			    STR_DESC[SIZE]);


	    RET_LEN[0] = INSERT_NAME_BANNER (
				.SCB,
		 		STR_DESC[SIZE],	! job name desc
				FRAME_PTR[0,0,.SCB[PSM$L_PAGE_WIDTH]],
						! ref to frame
		    		.FRAME_WIDTH,	! max width Bann 
				.BANNER_TYPE,	! frame length
		    		.BANNER_TYPE);	! max hght Bann str

	RETURN  .RET_LEN[0];	! return how much space used
	END
    ELSE	! Should be able to insert it... Make it pretty
	BEGIN
	IF .MAX_ROWS GEQ 3
	THEN    
	    BEGIN

	    PAGE_PTR = FRAME_PTR[0,0,.SCB[PSM$L_PAGE_WIDTH]];
	    INSERT_NAME_BANNER (
			.SCB,
		 	NAME[SIZE],			! file name
			PAGE_PTR[0,0,.SCB[PSM$L_PAGE_WIDTH]],
							! ref to frame
		    	.FRAME_WIDTH,			! max width Bann 
			.BANNER_TYPE,			! frame length
		    	.BANNER_TYPE);			! max hght Bann str
	    
	    PAGE_PTR = 	PAGE_PTR[0,(.BANNER_TYPE+.SPACING),
				 .SCB[PSM$L_PAGE_WIDTH]];
	    INSERT_NAME_BANNER (
			.SCB,
			TYPE[SIZE],			! file type
			PAGE_PTR[0,0,.SCB[PSM$L_PAGE_WIDTH]],
							! ref to frame
		    	.FRAME_WIDTH,			! max width Bann 
			.BANNER_TYPE,			! frame length
		    	.BANNER_TYPE);			! max hght Bann str

	    PAGE_PTR = 	PAGE_PTR[0,(.BANNER_TYPE+.SPACING),
				 .SCB[PSM$L_PAGE_WIDTH]];
	    INSERT_NAME_BANNER (
			.SCB,
			VERS[SIZE],			! file version number
			PAGE_PTR[0,0,.SCB[PSM$L_PAGE_WIDTH]],
							! ref to frame
		    	.FRAME_WIDTH,			! max width Bann 
			.BANNER_TYPE,			! frame length
		    	.BANNER_TYPE);			! max hght Bann str

	    RETURN  (3 * (.BANNER_TYPE + .SPACING));	! return count of used
							!  space
	    END
	ELSE
	    BEGIN
	    CURRENT_PTR = .STR_DESC[ADDR];
	    CURRENT_PTR = CH$MOVE(.TYPE[SIZE], .TYPE[ADDR], .CURRENT_PTR);
	    CURRENT_PTR = CH$MOVE(.VERS[SIZE], .VERS[ADDR], .CURRENT_PTR);
	    STR_DESC[SIZE] = .TYPE[SIZE] + .VERS[SIZE];

	    PAGE_PTR = FRAME_PTR[0,0,.SCB[PSM$L_PAGE_WIDTH]];
	    INSERT_NAME_BANNER (
			.SCB,
			NAME[SIZE],			! file name
			PAGE_PTR[0,0,.SCB[PSM$L_PAGE_WIDTH]],
							! ref to frame
		    	.FRAME_WIDTH,			! max width Bann 
			.BANNER_TYPE,			! frame length
		    	.BANNER_TYPE);			! max hght Bann str

	    PAGE_PTR = 	PAGE_PTR[0,(.BANNER_TYPE+.SPACING),
				 .SCB[PSM$L_PAGE_WIDTH]];
	    INSERT_NAME_BANNER (
			.SCB,
			STR_DESC[SIZE],			! file and version type
			PAGE_PTR[0,0,.SCB[PSM$L_PAGE_WIDTH]],
							! ref to frame
		    	.FRAME_WIDTH,			! max width Bann 
			.BANNER_TYPE,			! frame length
		    	.BANNER_TYPE);			! max hght Bann str

	    RETURN (2 * (.BANNER_TYPE + .SPACING));	! return count of used
							!  space
	    END;
	END;
    END;
END;

%sbttl 'INSERT_JOBNUMBER_BANNER - Get Job Number of the current Job'
!++
! Functional Description:
!	This routine creates a banner phrase with the Job Number
!
! Formal Parameters:
!	SCB		- Address of the SCB
!	STR_DESC	- Desc of String to Return
!	RET_LEN		- Return length of Desc.
!
! Implicit Inputs:
!		none
!
! Implicit Outputs:
!		none
!
! Returned Value:
!		none
!
! Side Effects:
!		none
!--
ROUTINE INSERT_JOBNUMBER_BANNER (
	SCB		: REF $BBLOCK,
	STR_DESC	: REF VECTOR[2],
	FRAME_PTR	: REF PAGE_ARRAY,
	FRAME_WIDTH	,		! Number of Columns
	FRAME_LENGTH			! Number of Rows
	)  =
BEGIN
BIND
    SENT_FORMAT = $DESCRIPTOR (
	'JOB ',
	'!UL'),

    NUM_FORMAT = $DESCRIPTOR (
	'!UL');

LITERAL
    LITTLE_BANNER = 7,
    SMALL = 2,
    LARGE = 1;

LOCAL
    RET_LEN	: VECTOR[1],
    PAGE_PTR	: REF PAGE_ARRAY,
    CURRENT_PTR	,
    JOB_LEN	: INITIAL (0),
    BANNER_TYPE	,
    SPACING	,
    BANNER_SIZE	,
    MAX_BAN_CHARS,
    BUFFER	: VECTOR[10,byte],
    MAX_COLS	,
    NUMBER	: VECTOR[2];

NUMBER[SIZE] = %ALLOCATION(BUFFER);
NUMBER[ADDR] = BUFFER;

! dont even try if there is no frame left
!
IF (.FRAME_LENGTH LSS 7)
THEN
    RETURN 0;

MAX_BAN_CHARS = (.FRAME_LENGTH/16) * (.FRAME_WIDTH/12);

BANNER_SIZE = SMALL;
BANNER_TYPE = LITTLE_BANNER;
SPACING = LARGE;				! single space banner rows

MAX_COLS = .BANNER_SIZE * (.FRAME_WIDTH / 12);


$FAO (  NUM_FORMAT, 
	JOB_LEN,				! str[size] > fetched namelen 
	NUMBER[0],
	.SCB[PSM$L_ENTRY_NUMBER]		! job number
     );

IF (.JOB_LEN+4) LEQ .MAX_COLS		! insert job&num on one line
THEN
    BEGIN
    $FAO (  SENT_FORMAT, 
	    JOB_LEN,	
	    STR_DESC[0],
	    .SCB[PSM$L_ENTRY_NUMBER]		! job number
	 );
    STR_DESC[SIZE] = .JOB_LEN;			! update the size
    END
ELSE						! copy the string.. num only
    BEGIN
    IF .JOB_LEN LEQ .MAX_COLS
    THEN
	BEGIN
	CURRENT_PTR = .STR_DESC[ADDR];
	CURRENT_PTR = CH$MOVE(.JOB_LEN, .NUMBER[ADDR], .CURRENT_PTR);
	STR_DESC[SIZE] = .JOB_LEN;
	END
    ELSE
	RETURN 0;				! exit ... No Room
    END;
    
INSERT_NAME_BANNER (
			.SCB,
			STR_DESC[SIZE],		! job name desc
		    	FRAME_PTR[0,0,.SCB[PSM$L_PAGE_WIDTH]],
						! ref to frame
		    	.FRAME_WIDTH,		! max width Bann 
			.BANNER_TYPE,		! frame length
		    	.BANNER_TYPE);		! max hght Bann str

RETURN  .BANNER_TYPE;				! return how much space in
						!  length used
END;

%sbttl 'GET_JOB_NAME - Get Name of the Current Job'
!++
! Functional Description:
!	This routine creates a phrase with the name of the current job.
!
! Formal Parameters:
!	SCB		- Address of the SCB
!	STR_DESC	- Desc of String to Return
!	RET_LEN		- Return length of Desc.
!
! Implicit Inputs:
!		none
!
! Implicit Outputs:
!		none
!
! Returned Value:
!		none
!
! Side Effects:
!		none
!--
ROUTINE GET_JOB_NAME (
		SCB		: REF $BBLOCK,		! SCB
		STR_DESC	: REF VECTOR[2],	! Output buffer desc
		RET_LEN		: REF VECTOR [,WORD]	! Return length (word)
			    )	: NOVALUE =
BEGIN
BIND
    SENT80_FORMAT = $DESCRIPTOR (
	'!AS');

    $FAO (  SENT80_FORMAT, 
	    RET_LEN[0],				! str[size] > fetched namelen 
	    STR_DESC[0],
	    SCB[PSM$Q_JOB_NAME],		! job name
	 );

RETURN SS$_NORMAL;
END;

%sbttl 'GET_EOJ - Get the Phrase End of Job'
!++
! Functional Description:
!	This routine creates a phrase with "EOJ" or "END OF JOB".
!
! Formal Parameters:
!	SCB		- Address of the SCB
!	STR_DESC	- Desc of String to Return
!	RET_LEN		- Return length of Desc.
!
! Implicit Inputs:
!		none
!
! Implicit Outputs:
!		none
!
! Returned Value:
!		none
!
! Side Effects:
!		none
!--
ROUTINE GET_EOJ (
		SCB		: REF $BBLOCK,		! SCB
		STR_DESC	: REF VECTOR[2],	! Output buffer desc
		RET_LEN		: REF VECTOR [,WORD]	! Return length (word)
			    )	: NOVALUE =
BEGIN
BIND
    SENT132_FORMAT = $DESCRIPTOR (  
	'END OF JOB'),			! - 

    SENT80_FORMAT = $DESCRIPTOR (
	'EOJ');

$FAO (  SENT132_FORMAT, 
	RET_LEN[0],			! return length
	STR_DESC[0],			! address of string
     );

! Is it short enough to allow the words "End of Job" to be printed ?
!
IF ((12 * .RET_LEN[0]) GTR .SCB[PSM$L_PAGE_WIDTH])
THEN
    $FAO (  SENT80_FORMAT, 
	    RET_LEN[0],				! str[size] > fetched namelen 
	    STR_DESC[0],
	 );

RETURN SS$_NORMAL;
END;

%sbttl 'GET_EOF - Get the Phrase End of File'
!++
! Functional Description:
!	This routine creates a phrase with "EOF" or "END OF FILE".
!
! Formal Parameters:
!	SCB		- Address of the SCB
!	STR_DESC	- Desc of String to Return
!	RET_LEN		- Return length of Desc.
!
! Implicit Inputs:
!		none
!
! Implicit Outputs:
!		none
!
! Returned Value:
!		none
!
! Side Effects:
!		none
!--
ROUTINE GET_EOF (
		SCB		: REF $BBLOCK,		! SCB
		STR_DESC	: REF VECTOR[2],	! Output buffer desc
		RET_LEN		: REF VECTOR [,WORD]	! Return length (word)
			    )	: NOVALUE =
BEGIN
BIND
    SENT132_FORMAT = $DESCRIPTOR (  
	'END OF FILE'),			! - 

    SENT80_FORMAT = $DESCRIPTOR (
	'EOF');

$FAO (  SENT132_FORMAT, 
	RET_LEN[0],			! return length
	STR_DESC[0],			! address of string
     );

! Is it short enough to allow the words "End of Job" to be printed ?
!
IF ((12 * .RET_LEN[0]) GTR .SCB[PSM$L_PAGE_WIDTH])
THEN
    $FAO (  SENT80_FORMAT, 
	    RET_LEN[0],				! str[size] > fetched namelen 
	    STR_DESC[0],
	 );

RETURN SS$_NORMAL;
END;

%sbttl 'GET_ACCOUNTING_INFO - Get the Accounting Information'
!++
! Functional Description:
!	This routine returns a string containing the accounting information.
!
! Formal Parameters:
!	SCB		- Address of the SCB
!	STR_DESC	- Desc of String to Return
!	RET_LEN		- Return length of Desc.
!
! Implicit Inputs:
!		none
!
! Implicit Outputs:
!		none
!
! Returned Value:
!		none
!
! Side Effects:
!		none
!--
ROUTINE GET_ACCOUNTING_INFO (
		SCB		: REF $BBLOCK,		! SCB
		STR_DESC	: REF VECTOR[2],	! Output buffer desc
		RET_LEN		: REF VECTOR [,WORD]	! Return length (word)
			    )	: NOVALUE =
BEGIN
BIND
    SENT132_FORMAT = $DESCRIPTOR (  
	'!#(AC)',
	'!#(AS)'
				 );
LOCAL
    IF_PRES;

IF_PRES = .SCB_SIZE_ (ACCOUNTING_DATA);
IF .IF_PRES GEQ 1
THEN
    IF_PRES = 1;

$FAO (  SENT132_FORMAT, 
	RET_LEN[0],			! return length
	STR_DESC[0],			! address of string
	.IF_PRES,
	UPLIT BYTE (%ASCIC 'ACCOUNTING INFO:'),
	.IF_PRES,
	SCB[PSM$Q_ACCOUNTING_DATA]	! accounting data
     );
END;

%sbttl 'GET_QUALIFIERS - Get Switches/Qualifiers associated with PRINTING'
!++
! Functional Description:
!	This routine returns a string containing the all relevant print
!	qualifier information.
!
! Formal Parameters:
!	SCB		- Address of the SCB
!	STR_DESC	- Desc of String to Return
!	RET_LEN		- Return length of Desc.
!
! Implicit Inputs:
!		none
!
! Implicit Outputs:
!		none
!
! Returned Value:
!		none
!
! Side Effects:
!		none
!--
ROUTINE GET_QUALIFIERS (
		SCB		: REF $BBLOCK,		! SCB
		STR_DESC	: REF VECTOR[2],	! Output buffer desc
		RET_LEN		: REF VECTOR [,WORD]	! Return length (word)
			    )	: NOVALUE =
BEGIN
BIND
! all the formats start here
!
    DATE_FORMAT = $DESCRIPTOR (
	'!17%D'),

    AFTER_TIME_FORMAT = $DESCRIPTOR (
	' /AFTER=!17%D'),			! - after_time print

    BURST_FORMAT = $DESCRIPTOR (
	' /BURST'	 ),			! - burst

    CHARACTERISTICS_FORMAT = $DESCRIPTOR (
	' /CHARACTERISTICS=!AS'	 ),		! - characteristics

    FILE_COPIES_FORMAT = $DESCRIPTOR (
	' /COPIES=!UL(!UL of !UL)'),		! - copies/iteration

    FEED_FORMAT = $DESCRIPTOR (
	' /FEED'		),		! - feed

    FLAG_FORMAT = $DESCRIPTOR (
	' /FLAG'		),		! - flag

    FORM_FORMAT = $DESCRIPTOR (
	' /FORM=!AS'		),		! - form

    HEADER_FORMAT = $DESCRIPTOR (
	' /HEADER'		),		! - header

    JOB_COUNT_FORMAT = $DESCRIPTOR (
	' /JOB_COUNT=!UL(!UL of !UL)'),		! - job count /iteration

    LENGTH_FORMAT = $DESCRIPTOR(
	' /LENGTH=!UL'),

    LIBRARY_FORMAT = $DESCRIPTOR (
	' /LIBRARY=!AS'	 ),			! - library

    MARGIN_FORMAT = $DESCRIPTOR(
	' /MARGIN=('),

    TOP_FORMAT = $DESCRIPTOR(
	'TOP=!UL'),

    BOTTOM_FORMAT = $DESCRIPTOR(
	'BOTTOM=!UL'),

    LEFT_FORMAT = $DESCRIPTOR(
	'LEFT=!UL'),

    RIGHT_FORMAT = $DESCRIPTOR(
	'RIGHT=!UL'),

    NOFEED_FORMAT = $DESCRIPTOR (
	' /NOFEED'		),		! - nofeed

    SETUP_PAGE_FORMAT = $DESCRIPTOR(
	' /PAGE_SETUP=(!AS)'	),		! - setup page

    PAGES_FORMAT = $DESCRIPTOR (
	' /PAGES=(!UL,!UL)'	),		! - page count

    PARAMETER_FORMAT = $DESCRIPTOR (
	' /PARAMETERS=(',
	'"!AS", "!AS", "!AS", "!AS", "!AS", ',
	'"!AS", "!AS", "!AS")'),		! - parameter lists

    PASSALL_FORMAT = $DESCRIPTOR (
	' /PASSALL'		),		! - passall

    PUNCTUATION_FORMAT = $DESCRIPTOR(
	'!AC'),					! comma or close paren

    SETUP_FILE_FORMAT = $DESCRIPTOR (
	' /SETUP_FILE=(!AS)'	 ),		! - setup file

    SETUP_FORM_FORMAT = $DESCRIPTOR(
	' /SETUP_FORM=(!AS)'	),		! - setup form

    SHEET_FORMAT = $DESCRIPTOR(
	' /SHEET_FEED'	),

    SPACE_FORMAT = $DESCRIPTOR (
	' /SPACE'		),		! - space

    TRAILER_FORMAT = $DESCRIPTOR (
	' /TRAILER'		),		! - trailer

    TRUNCATE_FORMAT = $DESCRIPTOR(
	' /TRUNCATE'	),

    WIDTH_FORMAT = $DESCRIPTOR(
	' /WIDTH=!UL'),

    WRAP_FORMAT = $DESCRIPTOR(
	' /WRAP'	);

LITERAL
    K_MAX_BUFFER_SIZE = 512;

LOCAL
    PUNC_FLAG	: INITIAL (0),
    TEMP_LEN	,
    AFT_DATE_PTR: VECTOR[2],
    TEMP_PTR	: VECTOR[2],
    AFT_BUFF	: VECTOR[17,byte],
    TEMP_BUFF	: VECTOR[17,byte],
    IF_PRES	,
    CURRENT_LEN	: INITIAL (0),
    STRING_PTR	: VECTOR [2];		! Pointer to current string

! Allocate the buffer for "GET_xxx" Routines
!
STRING_PTR[SIZE] = K_MAX_BUFFER_SIZE;
STRING_PTR[ADDR] = .STR_DESC[ADDR];	! init address 

RET_LEN[0] = 0;

!$FAO (  BEGIN_FORMAT, 
!	CURRENT_LEN,			! return length
!	STRING_PTR[0],			! address of string
 !    );
!
!RET_LEN[0] = .RET_LEN[0] + .CURRENT_LEN;
!STRING_PTR[ADDR] = .STRING_PTR[ADDR] + .CURRENT_LEN;
!STRING_PTR[SIZE] = K_MAX_BUFFER_SIZE - .RET_LEN[0];


! Increment pointer only if not equal to time queued
!
AFT_DATE_PTR[SIZE] = %ALLOCATION(AFT_BUFF);
AFT_DATE_PTR[ADDR] = AFT_BUFF;

$FAO (	DATE_FORMAT,
	TEMP_LEN,
	AFT_DATE_PTR[0],
	SCB[PSM$Q_AFTER_TIME]);

TEMP_PTR[SIZE] = %ALLOCATION(TEMP_BUFF);
TEMP_PTR[ADDR] = TEMP_BUFF;

$FAO (	DATE_FORMAT,
	TEMP_LEN,
	TEMP_PTR[0],
	SCB[PSM$Q_TIME_QUEUED]);

IF CH$NEQ( .TEMP_LEN, .TEMP_PTR[ADDR], .TEMP_LEN, .AFT_DATE_PTR[ADDR])
THEN
    BEGIN

    $FAO (
	AFTER_TIME_FORMAT, 
	CURRENT_LEN,			! return length
	STRING_PTR[0],			! address of string
	SCB[PSM$Q_AFTER_TIME]);		! after_time
    
    RET_LEN[0] = .RET_LEN[0] + .CURRENT_LEN;
    STRING_PTR[ADDR] = .STRING_PTR[ADDR] + .CURRENT_LEN;
    STRING_PTR[SIZE] = K_MAX_BUFFER_SIZE - .RET_LEN[0];
    END;

IF .SEPARATE_FLAG_ (FILE_BURST) 
THEN
    BEGIN
    $FAO (  BURST_FORMAT, 
	    CURRENT_LEN,			! return length
	    STRING_PTR[0]			! address of string
	);

    RET_LEN[0] = .RET_LEN[0] + .CURRENT_LEN;
    STRING_PTR[ADDR] = .STRING_PTR[ADDR] + .CURRENT_LEN;
    STRING_PTR[SIZE] = K_MAX_BUFFER_SIZE - .RET_LEN[0];
    END;

IF (.SCB_SIZE_ (CHARACTERISTICS) EQL 0)
THEN
    BEGIN
    $FAO (  CHARACTERISTICS_FORMAT, 
	    CURRENT_LEN,			! return length
	    STRING_PTR[0],			! address of string
	    SCB[PSM$Q_CHARACTERISTICS]		! /CHARACTERISTICS
	);

    RET_LEN[0] = .RET_LEN[0] + .CURRENT_LEN;
    STRING_PTR[ADDR] = .STRING_PTR[ADDR] + .CURRENT_LEN;
    STRING_PTR[SIZE] = K_MAX_BUFFER_SIZE - .RET_LEN[0];
    END;

! Always print something about form feed... /FEED or /NOFEED
!
IF .$BBLOCK[SCB[PSM$L_PRINT_CONTROL], SMBMSG$V_PAGINATE]
THEN
    BEGIN
    $FAO (  FEED_FORMAT, 
	    CURRENT_LEN,			! return length
	    STRING_PTR[0]			! address of string
	);

    RET_LEN[0] = .RET_LEN[0] + .CURRENT_LEN;
    STRING_PTR[ADDR] = .STRING_PTR[ADDR] + .CURRENT_LEN;
    STRING_PTR[SIZE] = K_MAX_BUFFER_SIZE - .RET_LEN[0];
    END;

IF .SCB[PSM$L_FILE_COPIES] GTR 1
THEN
    BEGIN
    $FAO (  FILE_COPIES_FORMAT, 
	    CURRENT_LEN,			! return length
	    STRING_PTR[0],			! address of string
	    .SCB[PSM$L_FILE_COPIES],		! /FILE_COPIES
	    .SCB[PSM$L_FILE_COUNT],		! iteration
	    .SCB[PSM$L_FILE_COPIES]
	);

    RET_LEN[0] = .RET_LEN[0] + .CURRENT_LEN; 
    STRING_PTR[ADDR] = .STRING_PTR[ADDR] + .CURRENT_LEN;
    STRING_PTR[SIZE] = K_MAX_BUFFER_SIZE - .RET_LEN[0];
    END;

IF .SEPARATE_FLAG_ (FILE_FLAG)
THEN
    BEGIN
    $FAO (  FLAG_FORMAT, 
	    CURRENT_LEN,			! return length
	    STRING_PTR[0]			! address of string
	);

    RET_LEN[0] = .RET_LEN[0] + .CURRENT_LEN;
    STRING_PTR[ADDR] = .STRING_PTR[ADDR] + .CURRENT_LEN;
    STRING_PTR[SIZE] = K_MAX_BUFFER_SIZE - .RET_LEN[0];
    END;

$FAO (  FORM_FORMAT, 
	CURRENT_LEN,			! return length
	STRING_PTR[0],			! address of string
	SCB[PSM$Q_FORM_NAME]);

RET_LEN[0] = .RET_LEN[0] + .CURRENT_LEN;
STRING_PTR[ADDR] = .STRING_PTR[ADDR] + .CURRENT_LEN;
STRING_PTR[SIZE] = K_MAX_BUFFER_SIZE - .RET_LEN[0];

IF .RET_LEN[0] GTR K_MAX_BUFFER_SIZE
THEN
    BEGIN
	RET_LEN[0] = 512;
	RETURN;
    END;

IF .$BBLOCK[SCB[PSM$L_PRINT_CONTROL], SMBMSG$V_PAGE_HEADER]
THEN
    BEGIN
    $FAO (  HEADER_FORMAT, 
	    CURRENT_LEN,			! return length
	    STRING_PTR[0]			! address of string
	);

    RET_LEN[0] = .RET_LEN[0] + .CURRENT_LEN;
    STRING_PTR[ADDR] = .STRING_PTR[ADDR] + .CURRENT_LEN;
    STRING_PTR[SIZE] = K_MAX_BUFFER_SIZE - .RET_LEN[0];
    END;

IF .RET_LEN[0] GTR K_MAX_BUFFER_SIZE
THEN
    BEGIN
	RET_LEN[0] = 512;
	RETURN;
    END;

IF .SCB[PSM$L_JOB_COPIES] GTR 1
THEN
    BEGIN
    $FAO (  JOB_COUNT_FORMAT, 
	    CURRENT_LEN,			! return length
	    STRING_PTR[0],			! address of string
	    .SCB[PSM$L_JOB_COPIES],		! /JOB_COUNT
	    .SCB[PSM$L_JOB_COUNT],		! iteration
	    .SCB[PSM$L_JOB_COPIES]		!
	);

    RET_LEN[0] = .RET_LEN[0] + .CURRENT_LEN;
    STRING_PTR[ADDR] = .STRING_PTR[ADDR] + .CURRENT_LEN;
    STRING_PTR[SIZE] = K_MAX_BUFFER_SIZE - .RET_LEN[0];
    END;

! Here is my internal call to PSM$READ_ITEM_DX to insure that the user
! can copy information successfully using this routine
!
BEGIN
LOCAL LEN: VECTOR[2];

INIT_DYN_DESC_ (LEN);
PSM$READ_ITEM_DX (.SCB , %ref(SMBMSG$K_FORM_LENGTH),
			 LEN[0]);

    $FAO (  LENGTH_FORMAT, 
	    CURRENT_LEN,			! return length
	    STRING_PTR[0],			! address of string
	    ..LEN[ADDR]				! length pointed to by len[addr]
	);

RET_LEN[0] = .RET_LEN[0] + .CURRENT_LEN;
STRING_PTR[ADDR] = .STRING_PTR[ADDR] + .CURRENT_LEN;
STRING_PTR[SIZE] = K_MAX_BUFFER_SIZE - .RET_LEN[0];
END;

!***  ALWAYS PRINT THE LIBRARY !**!
!
$FAO (  LIBRARY_FORMAT, 
	CURRENT_LEN,			! return length
	STRING_PTR[0],			! address of string
	SCB[PSM$Q_LIBRARY_SPECIFICATION]! /LIBRARY
     );

RET_LEN[0] = .RET_LEN[0] + .CURRENT_LEN;
STRING_PTR[ADDR] = .STRING_PTR[ADDR] + .CURRENT_LEN;
STRING_PTR[SIZE] = K_MAX_BUFFER_SIZE - .RET_LEN[0];

IF .RET_LEN[0] GTR K_MAX_BUFFER_SIZE
THEN
    BEGIN
	RET_LEN[0] = 512;
	RETURN;
    END;

IF (.SCB[PSM$L_TOP_MARGIN] NEQ 0) OR
    (.SCB[PSM$L_BOTTOM_MARGIN] NEQ 0) OR
    (.SCB[PSM$L_LEFT_MARGIN] NEQ 0) OR
    (.SCB[PSM$L_RIGHT_MARGIN] NEQ 0)
THEN
    BEGIN

    $FAO (  MARGIN_FORMAT, 
	    CURRENT_LEN,			! return length
	    STRING_PTR[0]			! address of string
	);

    RET_LEN[0] = .RET_LEN[0] + .CURRENT_LEN;
    STRING_PTR[ADDR] = .STRING_PTR[ADDR] + .CURRENT_LEN;
    STRING_PTR[SIZE] = K_MAX_BUFFER_SIZE - .RET_LEN[0];

    IF (.SCB[PSM$L_TOP_MARGIN] NEQ 0)
    THEN
	BEGIN
	$FAO (  TOP_FORMAT, 
		CURRENT_LEN,			! return length
		STRING_PTR[0],			! address of string
		.SCB[PSM$L_TOP_MARGIN]		! top
	     );

	PUNC_FLAG = 1;
	RET_LEN[0] = .RET_LEN[0] + .CURRENT_LEN;
	STRING_PTR[ADDR] = .STRING_PTR[ADDR] + .CURRENT_LEN;
	STRING_PTR[SIZE] = K_MAX_BUFFER_SIZE - .RET_LEN[0];
        END;

	IF  (.SCB[PSM$L_BOTTOM_MARGIN] NEQ 0) AND
	    .PUNC_FLAG
	THEN
	    BEGIN
 	    $FAO(
		PUNCTUATION_FORMAT,
		CURRENT_LEN,			! return length
		STRING_PTR[0],			! address of string
		UPLIT BYTE (%ASCIC ',')
     		);

	    RET_LEN[0] = .RET_LEN[0] + .CURRENT_LEN;
	    STRING_PTR[ADDR] = .STRING_PTR[ADDR] + .CURRENT_LEN;
	    STRING_PTR[SIZE] = K_MAX_BUFFER_SIZE - .RET_LEN[0];
	    END;

	IF  (.SCB[PSM$L_BOTTOM_MARGIN] NEQ 0)
	THEN
	    BEGIN
	    $FAO (  
		BOTTOM_FORMAT, 
		CURRENT_LEN,			! return length
		STRING_PTR[0],			! address of string
		.SCB[PSM$L_BOTTOM_MARGIN]	! bottom
		);

	    PUNC_FLAG = 1;
	    RET_LEN[0] = .RET_LEN[0] + .CURRENT_LEN;
	    STRING_PTR[ADDR] = .STRING_PTR[ADDR] + .CURRENT_LEN;
	    STRING_PTR[SIZE] = K_MAX_BUFFER_SIZE - .RET_LEN[0];
	    END;

	IF  (.SCB[PSM$L_LEFT_MARGIN] NEQ 0) AND
	    .PUNC_FLAG
	THEN
	    BEGIN
 	    $FAO(
		PUNCTUATION_FORMAT,
		CURRENT_LEN,			! return length
		STRING_PTR[0],			! address of string
		UPLIT BYTE (%ASCIC ',')
     		);
	    RET_LEN[0] = .RET_LEN[0] + .CURRENT_LEN;
	    STRING_PTR[ADDR] = .STRING_PTR[ADDR] + .CURRENT_LEN;
	    STRING_PTR[SIZE] = K_MAX_BUFFER_SIZE - .RET_LEN[0];
	END;

	IF  (.SCB[PSM$L_LEFT_MARGIN] NEQ 0)
	THEN
	    BEGIN
	    $FAO (  LEFT_FORMAT, 
		CURRENT_LEN,			! return length
		STRING_PTR[0],			! address of string
		.SCB[PSM$L_LEFT_MARGIN]		! left
		);

	    PUNC_FLAG = 1;
	    RET_LEN[0] = .RET_LEN[0] + .CURRENT_LEN;
	    STRING_PTR[ADDR] = .STRING_PTR[ADDR] + .CURRENT_LEN;
	    STRING_PTR[SIZE] = K_MAX_BUFFER_SIZE - .RET_LEN[0];
	    END;

	IF  (.SCB[PSM$L_RIGHT_MARGIN] NEQ 0) AND
	    .PUNC_FLAG
	THEN
	    BEGIN
 	    $FAO(
		PUNCTUATION_FORMAT,
		CURRENT_LEN,			! return length
		STRING_PTR[0],			! address of string
		UPLIT BYTE (%ASCIC ',')
     		);

	    RET_LEN[0] = .RET_LEN[0] + .CURRENT_LEN;
	    STRING_PTR[ADDR] = .STRING_PTR[ADDR] + .CURRENT_LEN;
	    STRING_PTR[SIZE] = K_MAX_BUFFER_SIZE - .RET_LEN[0];
	    END;

	IF  (.SCB[PSM$L_RIGHT_MARGIN] NEQ 0)
	THEN
	BEGIN
	    $FAO (  RIGHT_FORMAT,
		    CURRENT_LEN,		! return length
		    STRING_PTR[0],		! address of string
		    .SCB[PSM$L_RIGHT_MARGIN],	! right
		);

	    RET_LEN[0] = .RET_LEN[0] + .CURRENT_LEN;
	    STRING_PTR[ADDR] = .STRING_PTR[ADDR] + .CURRENT_LEN;
	    STRING_PTR[SIZE] = K_MAX_BUFFER_SIZE - .RET_LEN[0];
	END;

	$FAO(
	    PUNCTUATION_FORMAT,
	    CURRENT_LEN,			! return length
	    STRING_PTR[0],			! address of string
	    UPLIT BYTE (%ASCIC ')')
     	    );

	RET_LEN[0] = .RET_LEN[0] + .CURRENT_LEN;
	STRING_PTR[ADDR] = .STRING_PTR[ADDR] + .CURRENT_LEN;
	STRING_PTR[SIZE] = K_MAX_BUFFER_SIZE - .RET_LEN[0];
    END;

IF .RET_LEN[0] GTR K_MAX_BUFFER_SIZE
THEN
    BEGIN
	RET_LEN[0] = 512;
	RETURN;
    END;

IF NOT (.$BBLOCK[SCB[PSM$L_PRINT_CONTROL], SMBMSG$V_PAGINATE])
THEN
    BEGIN
    $FAO (  NOFEED_FORMAT, 
	    CURRENT_LEN,			! return length
	    STRING_PTR[0]			! address of string
	);

    RET_LEN[0] = .RET_LEN[0] + .CURRENT_LEN;
    STRING_PTR[ADDR] = .STRING_PTR[ADDR] + .CURRENT_LEN;
    STRING_PTR[SIZE] = K_MAX_BUFFER_SIZE - .RET_LEN[0];
    END;

IF .RET_LEN[0] GTR K_MAX_BUFFER_SIZE
THEN
    BEGIN
	RET_LEN[0] = 512;
	RETURN;
    END;

IF (.SCB[PSM$L_FIRST_PAGE] NEQ 0) OR		! default last page is zero
    (.SCB[PSM$L_LAST_PAGE] NEQ 0)
THEN
    BEGIN
    $FAO (  PAGES_FORMAT, 
	    CURRENT_LEN,			! return length
	    STRING_PTR[0],			! address of string
	    .SCB[PSM$L_FIRST_PAGE],
	    .SCB[PSM$L_LAST_PAGE]
	);

    RET_LEN[0] = .RET_LEN[0] + .CURRENT_LEN;
    STRING_PTR[ADDR] = .STRING_PTR[ADDR] + .CURRENT_LEN;
    STRING_PTR[SIZE] = K_MAX_BUFFER_SIZE - .RET_LEN[0];
    END;

IF .RET_LEN[0] GTR K_MAX_BUFFER_SIZE
THEN
    BEGIN
	RET_LEN[0] = 512;
	RETURN;
    END;

IF (.SCB_SIZE_ (PARAMETER_1) NEQ 0 OR
    .SCB_SIZE_ (PARAMETER_2) NEQ 0 OR
    .SCB_SIZE_ (PARAMETER_3) NEQ 0 OR
    .SCB_SIZE_ (PARAMETER_4) NEQ 0 OR
    .SCB_SIZE_ (PARAMETER_5) NEQ 0 OR
    .SCB_SIZE_ (PARAMETER_6) NEQ 0 OR
    .SCB_SIZE_ (PARAMETER_7) NEQ 0 OR
    .SCB_SIZE_ (PARAMETER_8) NEQ 0  )
THEN
    BEGIN
    $FAO (
	PARAMETER_FORMAT, 
	CURRENT_LEN,			! return length
	STRING_PTR[0],			! address of string
	SCB[PSM$Q_PARAMETER_1],		! P1
	SCB[PSM$Q_PARAMETER_2],		! P2
	SCB[PSM$Q_PARAMETER_3],		! P3
	SCB[PSM$Q_PARAMETER_4],		! P4
	SCB[PSM$Q_PARAMETER_5],		! P5
	SCB[PSM$Q_PARAMETER_6],		! P6
	SCB[PSM$Q_PARAMETER_7],		! P7
	SCB[PSM$Q_PARAMETER_8]		! P8
     );

    RET_LEN[0] = .RET_LEN[0] + .CURRENT_LEN;
    STRING_PTR[ADDR] = .STRING_PTR[ADDR] + .CURRENT_LEN;
    STRING_PTR[SIZE] = K_MAX_BUFFER_SIZE - .RET_LEN[0];
    END;

IF .RET_LEN[0] GTR K_MAX_BUFFER_SIZE
THEN
    BEGIN
	RET_LEN[0] = 512;
	RETURN;
    END;

IF .$BBLOCK[SCB[PSM$L_PRINT_CONTROL], SMBMSG$V_PASSALL]
THEN
    BEGIN
    $FAO (  PASSALL_FORMAT, 
	    CURRENT_LEN,			! return length
	    STRING_PTR[0]			! address of string
	);

    RET_LEN[0] = .RET_LEN[0] + .CURRENT_LEN;
    STRING_PTR[ADDR] = .STRING_PTR[ADDR] + .CURRENT_LEN;
    STRING_PTR[SIZE] = K_MAX_BUFFER_SIZE - .RET_LEN[0];
    END;

IF .RET_LEN[0] GTR K_MAX_BUFFER_SIZE
THEN
    BEGIN
	RET_LEN[0] = 512;
	RETURN;
    END;

IF .SCB_SIZE_ (FILE_SETUP_MODULES) GTR 0
THEN
    BEGIN
    $FAO (  SETUP_FILE_FORMAT, 
	    CURRENT_LEN,			! return length
	    STRING_PTR[0],			! address of string
	    SCB[PSM$Q_FILE_SETUP_MODULES]
	);

    RET_LEN[0] = .RET_LEN[0] + .CURRENT_LEN;
    STRING_PTR[ADDR] = .STRING_PTR[ADDR] + .CURRENT_LEN;
    STRING_PTR[SIZE] = K_MAX_BUFFER_SIZE - .RET_LEN[0];
    END;

IF .RET_LEN[0] GTR K_MAX_BUFFER_SIZE
THEN
    BEGIN
	RET_LEN[0] = 512;
	RETURN;
    END;

IF .SCB_SIZE_ (FORM_SETUP_MODULES) GTR 0
THEN
    BEGIN
    $FAO (  SETUP_FORM_FORMAT, 
	    CURRENT_LEN,			! return length
	    STRING_PTR[0],			! address of string
	    SCB[PSM$Q_FORM_SETUP_MODULES]	! form setup
	);

    RET_LEN[0] = .RET_LEN[0] + .CURRENT_LEN; 
    STRING_PTR[ADDR] = .STRING_PTR[ADDR] + .CURRENT_LEN;
    STRING_PTR[SIZE] = K_MAX_BUFFER_SIZE - .RET_LEN[0];
    END;

IF .SCB_SIZE_ (PAGE_SETUP_MODULES) GTR 0
THEN
    BEGIN
    $FAO (  SETUP_PAGE_FORMAT, 
	    CURRENT_LEN,			! return length
	    STRING_PTR[0],			! address of string
	    SCB[PSM$Q_PAGE_SETUP_MODULES]	! form setup
	);

    RET_LEN[0] = .RET_LEN[0] + .CURRENT_LEN; 
    STRING_PTR[ADDR] = .STRING_PTR[ADDR] + .CURRENT_LEN;
    STRING_PTR[SIZE] = K_MAX_BUFFER_SIZE - .RET_LEN[0];
    END;

IF .RET_LEN[0] GTR K_MAX_BUFFER_SIZE
THEN
    BEGIN
	RET_LEN[0] = 512;
	RETURN;
    END;

IF .$BBLOCK[SCB[PSM$L_PRINT_CONTROL], SMBMSG$V_SHEET_FEED]
THEN
    BEGIN
    $FAO (  SHEET_FORMAT, 
	    CURRENT_LEN,			! return length
	    STRING_PTR[0]			! address of string
	);

    RET_LEN[0] = .RET_LEN[0] + .CURRENT_LEN;
    STRING_PTR[ADDR] = .STRING_PTR[ADDR] + .CURRENT_LEN;
    STRING_PTR[SIZE] = K_MAX_BUFFER_SIZE - .RET_LEN[0];
    END;

IF .RET_LEN[0] GTR K_MAX_BUFFER_SIZE
THEN
    BEGIN
	RET_LEN[0] = 512;
	RETURN;
    END;

IF .$BBLOCK[SCB[PSM$L_PRINT_CONTROL], SMBMSG$V_DOUBLE_SPACE]
THEN
    BEGIN
    $FAO (  SPACE_FORMAT, 
	    CURRENT_LEN,			! return length
	    STRING_PTR[0]			! address of string
	);

    RET_LEN[0] = .RET_LEN[0] + .CURRENT_LEN;
    STRING_PTR[ADDR] = .STRING_PTR[ADDR] + .CURRENT_LEN;
    STRING_PTR[SIZE] = K_MAX_BUFFER_SIZE - .RET_LEN[0];
    END;

IF .RET_LEN[0] GTR K_MAX_BUFFER_SIZE
THEN
    BEGIN
	RET_LEN[0] = 512;
	RETURN;
    END;

IF .SEPARATE_FLAG_ (FILE_TRAILER)
THEN
    BEGIN
    $FAO (  TRAILER_FORMAT, 
	    CURRENT_LEN,			! return length
	    STRING_PTR[0]			! address of string
	);

    RET_LEN[0] = .RET_LEN[0] + .CURRENT_LEN;
    STRING_PTR[ADDR] = .STRING_PTR[ADDR] + .CURRENT_LEN;
    STRING_PTR[SIZE] = K_MAX_BUFFER_SIZE - .RET_LEN[0];
    END;

IF .RET_LEN[0] GTR K_MAX_BUFFER_SIZE
THEN
    BEGIN
	RET_LEN[0] = 512;
	RETURN;
    END;

IF .$BBLOCK[SCB[PSM$L_PRINT_CONTROL], SMBMSG$V_TRUNCATE]
THEN
    BEGIN
    $FAO (  TRUNCATE_FORMAT, 
	    CURRENT_LEN,			! return length
	    STRING_PTR[0]			! address of string
	);

    RET_LEN[0] = .RET_LEN[0] + .CURRENT_LEN;
    STRING_PTR[ADDR] = .STRING_PTR[ADDR] + .CURRENT_LEN;
    STRING_PTR[SIZE] = K_MAX_BUFFER_SIZE - .RET_LEN[0];
    END;

IF .RET_LEN[0] GTR K_MAX_BUFFER_SIZE
THEN
    BEGIN
	RET_LEN[0] = 512;
	RETURN;
    END;

$FAO (  WIDTH_FORMAT, 
	CURRENT_LEN,			! return length
	STRING_PTR[0],			! address of string
	.SCB[PSM$L_FORM_WIDTH]		! form width
    );

RET_LEN[0] = .RET_LEN[0] + .CURRENT_LEN;
STRING_PTR[ADDR] = .STRING_PTR[ADDR] + .CURRENT_LEN;
STRING_PTR[SIZE] = K_MAX_BUFFER_SIZE - .RET_LEN[0];

IF .RET_LEN[0] GTR K_MAX_BUFFER_SIZE
THEN
    BEGIN
	RET_LEN[0] = 512;
	RETURN;
    END;

IF .$BBLOCK[SCB[PSM$L_PRINT_CONTROL], SMBMSG$V_WRAP]
THEN
    BEGIN
    $FAO (  WRAP_FORMAT, 
	    CURRENT_LEN,			! return length
	    STRING_PTR[0]			! address of string
	);

    RET_LEN[0] = .RET_LEN[0] + .CURRENT_LEN;
    END;

! Don't print anything if no flags were set
!
IF .RET_LEN[0] LEQ 18
THEN
    RET_LEN[0] = 0;

! Length returned must be less than max string size
!
IF .RET_LEN[0] GTR K_MAX_BUFFER_SIZE
THEN
    BEGIN
	RET_LEN[0] = 512;
	RETURN;
    END;

END;

%sbttl 'GET_QUEUE_QUALIFIERS - Gets the qualifiers pertaining to queues'
!++
! Functional Description:
!	This routine returns a string containing the all relevant file qualifier
!	information.
!
! Formal Parameters:
!	SCB		- Address of the SCB
!	STR_DESC	- Desc of String to Return
!	RET_LEN		- Return length of Desc.
!
! Implicit Inputs:
!		none
!
! Implicit Outputs:
!		none
!
! Returned Value:
!		none
!
! Side Effects:
!		none
!--
ROUTINE GET_QUEUE_QUALIFIERS (
		SCB		: REF $BBLOCK,		! SCB
		STR_DESC	: REF VECTOR[2],	! Output buffer desc
		RET_LEN		: REF VECTOR [,WORD]	! Return length (word)
			    )	: NOVALUE =
BEGIN
BIND
    BEGIN_FORMAT = $DESCRIPTOR (
	'Queue Qualifiers:'),

    RESET_FORMAT = $DESCRIPTOR (
	'RESET="',
	'!AS',					! - Reset Module
	'"'),

    JOB_RESET_MODULE_FORMAT = $DESCRIPTOR (
	' /SEPARATE=('),			! - separation

    INSERTION_FORMAT = $DESCRIPTOR (
	'!AC');					! - separation flags


LITERAL 
    K_MAX_BUFFER_SIZE = 512;

LOCAL
    INSERT_FLAG	: INITIAL (0),
    CURRENT_LEN	: INITIAL (0),
    STRING_PTR	: VECTOR [2];		! Pointer to current string

STRING_PTR[SIZE] = K_MAX_BUFFER_SIZE;
STRING_PTR[ADDR] = .STR_DESC[ADDR];	! init address 

RET_LEN[0] = 0;

$FAO (  BEGIN_FORMAT, 
	CURRENT_LEN,			! return length
	STRING_PTR[0],			! address of string
     );

RET_LEN[0] = .RET_LEN[0] + .CURRENT_LEN;
STRING_PTR[ADDR] = .STRING_PTR[ADDR] + .CURRENT_LEN;
STRING_PTR[SIZE] = K_MAX_BUFFER_SIZE - .RET_LEN[0];


IF .SEPARATE_FLAG_ (JOB_BURST) OR
    .SEPARATE_FLAG_ (JOB_FLAG) OR
    .SEPARATE_FLAG_ (JOB_TRAILER) OR
    .SCB_SIZE_ (JOB_RESET_MODULES)
THEN
    BEGIN
    $FAO (  JOB_RESET_MODULE_FORMAT, 		! /SEPARATE
	    CURRENT_LEN,			! return length
	    STRING_PTR[0]			! address of string
	);

    RET_LEN[0] = .RET_LEN[0] + .CURRENT_LEN;
    STRING_PTR[ADDR] = .STRING_PTR[ADDR] + .CURRENT_LEN;
    STRING_PTR[SIZE] = K_MAX_BUFFER_SIZE - .RET_LEN[0];

    IF .SEPARATE_FLAG_ (JOB_BURST)
    THEN
	BEGIN
	$FAO (
	    INSERTION_FORMAT,
	    CURRENT_LEN,			! return length
	    STRING_PTR[0],			! address of string
	    UPLIT BYTE (%ASCIC'BURST')
	);

	INSERT_FLAG = 1;
	RET_LEN[0] = .RET_LEN[0] + .CURRENT_LEN;
	STRING_PTR[ADDR] = .STRING_PTR[ADDR] + .CURRENT_LEN;
	STRING_PTR[SIZE] = K_MAX_BUFFER_SIZE - .RET_LEN[0];
	END;

    IF .SEPARATE_FLAG_ (JOB_FLAG) AND
	.INSERT_FLAG
    THEN
	BEGIN
	$FAO (
	    INSERTION_FORMAT,
	    CURRENT_LEN,			! return length
	    STRING_PTR[0],			! address of string
	    UPLIT BYTE (%ASCIC',')
	);

	RET_LEN[0] = .RET_LEN[0] + .CURRENT_LEN;
	STRING_PTR[ADDR] = .STRING_PTR[ADDR] + .CURRENT_LEN;
	STRING_PTR[SIZE] = K_MAX_BUFFER_SIZE - .RET_LEN[0];
	END;

    IF .SEPARATE_FLAG_ (JOB_FLAG)
    THEN
	BEGIN
	$FAO (
	    INSERTION_FORMAT,
	    CURRENT_LEN,			! return length
	    STRING_PTR[0],			! address of string
	    UPLIT BYTE (%ASCIC'FLAG')
	);

	INSERT_FLAG = 1;
	RET_LEN[0] = .RET_LEN[0] + .CURRENT_LEN;
	STRING_PTR[ADDR] = .STRING_PTR[ADDR] + .CURRENT_LEN;
	STRING_PTR[SIZE] = K_MAX_BUFFER_SIZE - .RET_LEN[0];
	END;

    IF .SCB_SIZE_ (JOB_RESET_MODULES) AND
	.INSERT_FLAG
    THEN
	BEGIN
	$FAO (
	    INSERTION_FORMAT,
	    CURRENT_LEN,			! return length
	    STRING_PTR[0],			! address of string
	    UPLIT BYTE (%ASCIC',')
	);

	RET_LEN[0] = .RET_LEN[0] + .CURRENT_LEN;
	STRING_PTR[ADDR] = .STRING_PTR[ADDR] + .CURRENT_LEN;
	STRING_PTR[SIZE] = K_MAX_BUFFER_SIZE - .RET_LEN[0];
	END;

    IF .SCB_SIZE_(JOB_RESET_MODULES)
    THEN
	BEGIN
	$FAO (
	    RESET_FORMAT,
	    CURRENT_LEN,			! return length
	    STRING_PTR[0],			! address of string
	    SCB[PSM$Q_JOB_RESET_MODULES]
	);

	RET_LEN[0] = .RET_LEN[0] + .CURRENT_LEN;
	STRING_PTR[ADDR] = .STRING_PTR[ADDR] + .CURRENT_LEN;
	STRING_PTR[SIZE] = K_MAX_BUFFER_SIZE - .RET_LEN[0];
	END;

    IF .SEPARATE_FLAG_ (JOB_TRAILER) AND
	.INSERT_FLAG
    THEN
	BEGIN
	$FAO (
	    INSERTION_FORMAT,
	    CURRENT_LEN,			! return length
	    STRING_PTR[0],			! address of string
	    UPLIT BYTE (%ASCIC',')
	);

	RET_LEN[0] = .RET_LEN[0] + .CURRENT_LEN;
	STRING_PTR[ADDR] = .STRING_PTR[ADDR] + .CURRENT_LEN;
	STRING_PTR[SIZE] = K_MAX_BUFFER_SIZE - .RET_LEN[0];
	END;

    IF .SEPARATE_FLAG_ (JOB_TRAILER)
    THEN
	BEGIN
	$FAO (
	    INSERTION_FORMAT,
	    CURRENT_LEN,			! return length
	    STRING_PTR[0],			! address of string
	    UPLIT BYTE (%ASCIC'TRAILER')
	);

	RET_LEN[0] = .RET_LEN[0] + .CURRENT_LEN;
	STRING_PTR[ADDR] = .STRING_PTR[ADDR] + .CURRENT_LEN;
	STRING_PTR[SIZE] = K_MAX_BUFFER_SIZE - .RET_LEN[0];
	END;

    $FAO (
	INSERTION_FORMAT,
	CURRENT_LEN,			! return length
	STRING_PTR[0],			! address of string
	UPLIT BYTE (%ASCIC')')
	);

    RET_LEN[0] = .RET_LEN[0] + .CURRENT_LEN;
    STRING_PTR[ADDR] = .STRING_PTR[ADDR] + .CURRENT_LEN;
    STRING_PTR[SIZE] = K_MAX_BUFFER_SIZE - .RET_LEN[0];
    END;

! Don't print anything if no flags were set
!
IF .RET_LEN[0] LEQ 18
THEN
    RET_LEN[0] = 0;

! Length returned must be less than max string size
IF .RET_LEN[0] GTR K_MAX_BUFFER_SIZE
THEN
    BEGIN
	RET_LEN[0] = 512;
	RETURN;
    END;

END;

%sbttl 'GET_FORM_QUALIFIERS - Get the qualifiers which pertain to forms'
!++
! Functional Description:
!	This routine returns a string containing the all relevant file qualifier
!	information.
!
! Formal Parameters:
!	SCB		- Address of the SCB
!	STR_DESC	- Desc of String to Return
!	RET_LEN		- Return length of Desc.
!
! Implicit Inputs:
!		none
!
! Implicit Outputs:
!		none
!
! Returned Value:
!		none
!
! Side Effects:
!		none
!--
ROUTINE GET_FORM_QUALIFIERS (
		SCB		: REF $BBLOCK,		! SCB
		STR_DESC	: REF VECTOR[2],	! Output buffer desc
		RET_LEN		: REF VECTOR [,WORD]	! Return length (word)
			    )	: NOVALUE =
BEGIN
BIND
    BEGIN_FORMAT = $DESCRIPTOR(
	'Form Qualifiers:');

LITERAL
    K_MAX_BUFFER_SIZE = 512;

LOCAL
    CURRENT_LEN	: INITIAL (0),
    STRING_PTR	: VECTOR [2];		! Pointer to current string


STRING_PTR[SIZE] = K_MAX_BUFFER_SIZE;
STRING_PTR[ADDR] = .STR_DESC[ADDR];	! init address 

RET_LEN[0] = 0;

$FAO (  BEGIN_FORMAT, 
	CURRENT_LEN,			! return length
	STRING_PTR[0],			! address of string
     );

RET_LEN[0] = .RET_LEN[0] + .CURRENT_LEN;
STRING_PTR[ADDR] = .STRING_PTR[ADDR] + .CURRENT_LEN;
STRING_PTR[SIZE] = K_MAX_BUFFER_SIZE - .RET_LEN[0];



! Don't print anything if no flags were set
!
IF .RET_LEN[0] LEQ 18
THEN
    RET_LEN[0] = 0;

! Length returned must be less than max string size
IF .RET_LEN[0] GTR K_MAX_BUFFER_SIZE
THEN
    BEGIN
	RET_LEN[0] = 512;
	RETURN;
    END;

END;

%sbttl 'GET_USER_NOTE- Insert a Note into the Page'
!++
! Functional Description:
!	This routine gets a note as specified by the user for the frame.
!
! Formal Parameters:
!	SCB		- Address of the SCB
!	STR_DESC	- Desc of String to Return
!	RET_LEN		- Return length of Desc.
!
! Implicit Inputs:
!		none
!
! Implicit Outputs:
!		none
!
! Returned Value:
!		none
!
! Side Effects:
!		none
!--
ROUTINE GET_USER_NOTE (
		SCB		: REF $BBLOCK,		! SCB
		STR_DESC	: REF VECTOR[2],	! Output buffer desc
		RET_LEN		: REF VECTOR [,WORD]	! Return length (word)
			    )	: NOVALUE =
BEGIN
BIND
    NOTE_FULL_FORMAT = $DESCRIPTOR (  
	'NOTE: !AF'		 );		! - user note
LITERAL
    K_MIN_NOTE_LEN = 6;
LOCAL
    STATUS;

STATUS = $FAO ( NOTE_FULL_FORMAT, 
		RET_LEN[0], 
		STR_DESC[0],
		.SCB_SIZE_ (NOTE),
		.SCB_ADDR_ (NOTE));	! user note

IF .RET_LEN[0] LEQ K_MIN_NOTE_LEN		! print nothing... no note
    THEN RET_LEN[0] = 0;
    

RETURN SS$_NORMAL;
END;

%sbttl 'GET_RECEIPT_BOX - Insert a "Received Box" into the Page'
!++
! Functional Description:
!	This routine gets a note as specified by the user for the frame.
!
! Formal Parameters:
!	SCB		- Address of the SCB
!	STR_DESC	- Desc of String to Return
!	RET_LEN		- Return length of Desc.
!
! Implicit Inputs:
!		none
!
! Implicit Outputs:
!		none
!
! Returned Value:
!		none
!
! Side Effects:
!		none
!--
ROUTINE GET_RECEIPT_BOX (
		SCB		: REF $BBLOCK,		! SCB
		STR_DESC	: REF VECTOR[2],	! Output buffer desc
		RET_LEN		: REF VECTOR [,WORD]	! Return length (word)
			    )	: NOVALUE =
BEGIN
BIND
    NOTE132_FORMAT = $DESCRIPTOR (  
	'+--------------------------------------+',
	'!                                      !',
	'! Received: .......................... !',
	'!                                      !',
	'! Date    : .......................... !',
	'!                                      !',
	'! Operator: .......................... !',
	'+--------------------------------------+'
		 ) : VECTOR;	! - receipt box

CH$MOVE (.NOTE132_FORMAT[0], .NOTE132_FORMAT[1], .STR_DESC[ADDR]);
RET_LEN[0] = .NOTE132_FORMAT[0];

RETURN SS$_NORMAL;
END;

%sbttl 'GET_RULER_FINE - Insert a fine "RULER" into the Page'
!++
! Functional Description:
!	This routine gets a fine ruler '1234567890'
!
! Formal Parameters:
!	SCB		- Address of the SCB
!	STR_DESC	- Desc of String to Return
!	RET_LEN		- Return length of Desc.
!
! Implicit Inputs:
!		none
!
! Implicit Outputs:
!		none
!
! Returned Value:
!		none
!
! Side Effects:
!		none
!--
ROUTINE GET_RULER_FINE (
		SCB		: REF $BBLOCK,		! SCB
		STR_DESC	: REF VECTOR[2],	! Output buffer desc
		RET_LEN		: REF VECTOR [,WORD]	! Return length (word)
			    )	: NOVALUE =
BEGIN
BIND
    VMS_FORMAT = $DESCRIPTOR (  
		'1234567890'
		 );

$FAO (  VMS_FORMAT, 
	RET_LEN[0], 
	STR_DESC[0]
	);

RETURN SS$_NORMAL;
END;

%sbttl 'GET_RULER_COARSE - Insert a coarse "RULER" into the Page'
!++
! Functional Description:
!	This routine gets a coarse ruler '1...2...3...' for the frame.
!
! Formal Parameters:
!	SCB		- Address of the SCB
!	STR_DESC	- Desc of String to Return
!	RET_LEN		- Return length of Desc.
!
! Implicit Inputs:
!		none
!
! Implicit Outputs:
!		none
!
! Returned Value:
!		none
!
! Side Effects:
!		none
!--
ROUTINE GET_RULER_COARSE (
		SCB		: REF $BBLOCK,		! SCB
		STR_DESC	: REF VECTOR[2],	! Output buffer desc
		RET_LEN		: REF VECTOR [,WORD]	! Return length (word)
			    )	: NOVALUE =
BEGIN
BIND
    VMS_FORMAT = $DESCRIPTOR (  
		'         1',
		'         2',
		'         3',
		'         4',
		'         5',
		'         6',
		'         7',
		'         8',
		'         9',
		'         0'
		 );

$FAO (  VMS_FORMAT, 
	RET_LEN[0], 
	STR_DESC[0]
	);

RETURN SS$_NORMAL;
END;

%sbttl 'GET_FORM_SIZE - Determine the Size of Form Specified'
!++
! Functional Description:
!	This routine determines the which standard form is
!	specified by interrogating the SCB for length and width
! 	Standard forms sizes include: 132x66, 132x51, 80x66, 80x51 or
!	40xany_length.  Otherwise form size is "non_std".
!
! Formal Parameters:
!		SCB	- Address of the SCB
!
! Implicit Inputs:
!		none
!
! Implicit Outputs:
!		none
!
! Returned Value:
!		none
!
! Side Effects:
!		none
!--
ROUTINE GET_FORM_SIZE (
			SCB	: REF $BBLOCK
	):	NOVALUE	=
BEGIN

    SCB[PSM$L_PAGE_WIDTH] = .SCB[PSM$L_FORM_WIDTH];
    IF .SCB[PSM$L_PAGE_WIDTH] GTRU 200
    THEN
	SCB[PSM$L_PAGE_WIDTH]  = 200;

    SCB[PSM$L_PAGE_LENGTH] = .SCB[PSM$L_FORM_LENGTH];
    IF .SCB[PSM$L_PAGE_LENGTH] GTRU 100
    THEN
	SCB[PSM$L_PAGE_LENGTH]  = 100;

    WHILE .SCB[PSM$L_PAGE_LENGTH] LSSU 40
    DO
	SCB[PSM$L_PAGE_LENGTH]  =
	    .SCB[PSM$L_PAGE_LENGTH] + .SCB[PSM$L_FORM_LENGTH];

END;

%sbttl 'FILL_FRAME - Insert Information into this Frame of the Page'
!++
! Functional Description:
!	This procedure inserts a character into an array(frame)
!	until no room left in the frame.
!
! Formal Parameters:
!	SCB		- Address of the SCB
!	CHAR		- Descriptor of String to Insert
!	FRAME_PTR	- Address of first byte of Frame
!	FRAME_LENGTH	- Length of Frame
!	FRAME_WIDTH	- Width of Frame
!
! Implicit Inputs:
!		none
!
! Implicit Outputs:
!		none
!
! Returned Value:
!		none
!
! Side Effects:
!		none
!--
ROUTINE FILL_FRAME (
	SCB		: REF $BBLOCK,
	CHAR,
	FRAME_PTR	: REF PAGE_ARRAY,
	FRAME_WIDTH,
	FRAME_LENGTH
	):	NOVALUE	=
BEGIN

LOCAL	PTR 		: REF PAGE_ARRAY,
	LOC_FRAME_LENGTH,
	LOC_FRAME_WIDTH	;

! Check for dumb calls
!
IF (.FRAME_LENGTH LEQ 0) OR (.FRAME_WIDTH LEQ 0)
THEN
    RETURN;
IF  (.FRAME_LENGTH GTR .SCB[PSM$L_PAGE_LENGTH]) OR 
    (.FRAME_WIDTH GTR .SCB[PSM$L_PAGE_WIDTH])
THEN
    RETURN;

! Check page boundary conditions
!
LOC_FRAME_LENGTH = .FRAME_LENGTH;
IF .LOC_FRAME_LENGTH GTR .SCB[PSM$L_PAGE_LENGTH]
THEN
    LOC_FRAME_LENGTH = .SCB[PSM$L_PAGE_LENGTH];		! stay in page bounds

LOC_FRAME_WIDTH  = .FRAME_WIDTH;
IF .LOC_FRAME_WIDTH GTR .SCB[PSM$L_PAGE_WIDTH]
THEN
    LOC_FRAME_WIDTH = .SCB[PSM$L_PAGE_WIDTH];		! stay in page bounds


PTR = FRAME_PTR[0,0,.SCB[PSM$L_PAGE_WIDTH]];


DECR L FROM .LOC_FRAME_LENGTH TO 1 DO 
    BEGIN
    CH$FILL( .CHAR, .LOC_FRAME_WIDTH,.PTR);

    PTR = .PTR + .SCB[PSM$L_PAGE_WIDTH];		! Address calc. is based
							!  on Form Width 
    END;
END;

%sbttl 'SCROLL_FRAME - Insert Information into this Frame of the Page'
!++
! Functional Description:
!	This procedure inserts a string into an array(frame) repeatedly
!	until no room is left in the frame.
!
! Formal Parameters:
!	SCB		- Address of the SCB
!	CHAR_STRING	- Descriptor of String to Insert
!	FRAME_PTR	- Address of first byte of Frame
!	FRAME_LENGTH	- Length of Frame
!	FRAME_WIDTH	- Width of Frame
!
! Implicit Inputs:
!		none
!
! Implicit Outputs:
!		none
!
! Returned Value:
!		none
!
! Side Effects:
!		none
!--
ROUTINE SCROLL_FRAME (
	SCB		: REF $BBLOCK,
	CHAR_STRING	: REF VECTOR[2],
	FRAME_PTR	: REF PAGE_ARRAY,
	FRAME_WIDTH	,
	FRAME_LENGTH
	)  :	NOVALUE	=
BEGIN

LOCAL	PTR 		: REF PAGE_ARRAY,
	LOC_FRAME_LENGTH,
	LOC_FRAME_WIDTH	,
	TEMP_PTR	,
	START_CNT	: INITIAL (0),
	CHARS		,
	NUM_CHARS	: INITIAL (0);

! Check for dumb calls
!
IF (.FRAME_LENGTH LEQ 0) OR (.FRAME_WIDTH LEQ 0) OR
   (.FRAME_LENGTH GTR .SCB[PSM$L_PAGE_LENGTH]) OR 
    (.FRAME_WIDTH GTR .SCB[PSM$L_PAGE_WIDTH])
THEN
    RETURN;

LOC_FRAME_LENGTH = .FRAME_LENGTH;

LOC_FRAME_WIDTH  = .FRAME_WIDTH;

PTR = FRAME_PTR[0,0,.SCB[PSM$L_PAGE_WIDTH]];
TEMP_PTR = .CHAR_STRING[ADDR];
CHARS = CH$PTR(.TEMP_PTR);

    INCR L FROM 0 TO (.LOC_FRAME_LENGTH-1)  DO 
	BEGIN
	PTR = FRAME_PTR[0,0,.SCB[PSM$L_PAGE_WIDTH]]	! Address calc. is based
	      + (.L * .SCB[PSM$L_PAGE_WIDTH]);		!  on Form Width
	!
	!  Move the rest of the string into the beginning of the next frame
	!
	IF (.NUM_CHARS LEQ .CHAR_STRING[SIZE])
	    AND ((.CHAR_STRING[SIZE]-.NUM_CHARS) LSS .LOC_FRAME_WIDTH)
	THEN						! Scroll it
	    BEGIN
	    TEMP_PTR = .CHAR_STRING[ADDR] + .NUM_CHARS;	! move remainder of str.
	    CH$MOVE(.CHAR_STRING[SIZE]- .NUM_CHARS, .TEMP_PTR, .PTR);
	    PTR = .PTR + (.CHAR_STRING[SIZE] - .NUM_CHARS);
							! incr by no. inserted
	    START_CNT = .CHAR_STRING[SIZE] - .NUM_CHARS;
	    TEMP_PTR = .CHAR_STRING[ADDR];
	    END;

	INCR I FROM .START_CNT TO .LOC_FRAME_WIDTH BY .CHAR_STRING[SIZE] DO 
	    BEGIN
	    IF .CHAR_STRING[SIZE] GEQ (.LOC_FRAME_WIDTH - .I)
	    THEN
		NUM_CHARS = (.LOC_FRAME_WIDTH - .I)
	    ELSE
	        NUM_CHARS = .CHAR_STRING[SIZE];

	    CH$MOVE(.NUM_CHARS, .TEMP_PTR, .PTR);

	    PTR = .PTR + .NUM_CHARS;
	    END;
	END;
END;

%sbttl 'MOVE_FRAME - Move Information into this Frame of the Page'
!++
! Functional Description:
!	This procedure inserts a string(frame) into an array(frame).
!	Insertion continues until either no more string or no more room.
!
! Formal Parameters:
!	SCB		- Address of the SCB
!	CHAR_STRING	- Descriptor of String to Insert
!	FRAME_PTR	- Address of first byte of Frame
!	FRAME_LENGTH	- Length of Frame
!	FRAME_WIDTH	- Width of Frame
!
! Implicit Inputs:
!		none
!
! Implicit Outputs:
!		none
!
! Returned Value:
!		none
!
! Side Effects:
!		Truncation is possible.
!
!--
ROUTINE MOVE_FRAME (
	SCB		: REF $BBLOCK,
	CHAR_STRING	: REF VECTOR[2],
	FRAME_PTR	: REF PAGE_ARRAY,
	FRAME_WIDTH	,		! Number of Columns
	FRAME_LENGTH			! Number of Rows
	)  :	NOVALUE	=
BEGIN

LOCAL	PTR 		: REF PAGE_ARRAY,
	LOC_FRAME_LENGTH,
	LOC_FRAME_WIDTH	,
	STR_PTR		,
	CURR_SIZE	,
	NUM_CHARS;

! Check for dumb calls
!
IF (.FRAME_LENGTH LEQ 0) OR (.FRAME_WIDTH LEQ 0)
THEN
    RETURN;
IF  (.FRAME_LENGTH GTR .SCB[PSM$L_PAGE_LENGTH]) OR 
    (.FRAME_WIDTH GTR .SCB[PSM$L_PAGE_WIDTH])
THEN
    RETURN;


! Check page boundary conditions
!
LOC_FRAME_LENGTH = .FRAME_LENGTH;
IF .LOC_FRAME_LENGTH GTR .SCB[PSM$L_PAGE_LENGTH]
THEN
    LOC_FRAME_LENGTH = .SCB[PSM$L_PAGE_LENGTH];		! stay in page bounds

LOC_FRAME_WIDTH  = .FRAME_WIDTH;
IF .LOC_FRAME_WIDTH GTR .SCB[PSM$L_PAGE_WIDTH]
THEN
    LOC_FRAME_WIDTH = .SCB[PSM$L_PAGE_WIDTH];		! stay in page bounds

!  Get string info
CURR_SIZE 	= .CHAR_STRING[SIZE];
PTR		= FRAME_PTR[0,0,.SCB[PSM$L_PAGE_WIDTH]];
STR_PTR		= .CHAR_STRING[ADDR];

!  Do a quick fill of the frame
 FILL_FRAME (.SCB,
	     %CHAR(32),		! fill with blanks
	     FRAME_PTR[0,0,.SCB[PSM$L_PAGE_WIDTH]],
	     .LOC_FRAME_WIDTH,
	     .LOC_FRAME_LENGTH);

DECRU L FROM .LOC_FRAME_LENGTH TO 1 DO 
    BEGIN
    IF .CURR_SIZE GEQ .LOC_FRAME_WIDTH THEN
	NUM_CHARS = .LOC_FRAME_WIDTH
    ELSE
	NUM_CHARS = .CURR_SIZE;

    CH$MOVE(.NUM_CHARS, .STR_PTR, .PTR);

    PTR = .PTR + .SCB[PSM$L_PAGE_WIDTH];		! Address calc. is based
							!  on Form Width
    STR_PTR = .STR_PTR + .LOC_FRAME_WIDTH;

    IF .LOC_FRAME_WIDTH GTRU .CURR_SIZE THEN
	EXITLOOP;

    CURR_SIZE = .CURR_SIZE - .NUM_CHARS;		! Decrease string size
    END;
END;

%sbttl 'INSERT_FRAME - Insert Information into this Frame of the Page'
!++
! Functional Description:
!	This procedure inserts a string into an array(frame).
!	Insertion continues until either no more string or no more room
!	Delimiting characters are used to correctly parse the string 
!	prior to insertion.
!
! Formal Parameters:
!	SCB		- Address of the SCB
!	CHAR_STRING	- Descriptor of String to Insert
!	FRAME_PTR	- Address of first byte of Frame
!	FRAME_LENGTH	- Length of Frame
!	FRAME_WIDTH	- Width of Frame
!
! Implicit Inputs:
!		none
!
! Implicit Outputs:
!		none
!
! Returned Value:
!		none
!
! Side Effects:
!		Truncation is possible.
!
!--
ROUTINE INSERT_FRAME (
	SCB		: REF $BBLOCK,
	CHAR_STRING	: REF VECTOR[2],
	FRAME_PTR	: REF PAGE_ARRAY,
	FRAME_WIDTH	,		! Number of Columns
	FRAME_LENGTH			! Number of Rows
	)  :	NOVALUE	=
BEGIN
BUILTIN AP;		! just in case trucation occurred ... don't delimit

LITERAL
	LEADING		= 0,
	TRAILING	= 1;

LOCAL	PTR 		: REF PAGE_ARRAY,
	LOC_FRAME_LENGTH,
	LOC_FRAME_WIDTH	,
	STR_PTR		,
	CURR_SIZE	,
	DUM_LEN		,
	NUM_CHARS;

! Check for dumb calls
!
IF (.FRAME_LENGTH LEQ 0) OR (.FRAME_WIDTH LEQ 0)
THEN
    RETURN;
IF  (.FRAME_LENGTH GTR .SCB[PSM$L_PAGE_LENGTH]) OR 
    (.FRAME_WIDTH GTR .SCB[PSM$L_PAGE_WIDTH])
THEN
    RETURN;

! Check page boundary conditions
!
LOC_FRAME_LENGTH = .FRAME_LENGTH;
IF .LOC_FRAME_LENGTH GTR .SCB[PSM$L_PAGE_LENGTH]
THEN
    LOC_FRAME_LENGTH = .SCB[PSM$L_PAGE_LENGTH];		! stay in page bounds

LOC_FRAME_WIDTH  = .FRAME_WIDTH;
IF .LOC_FRAME_WIDTH GTR .SCB[PSM$L_PAGE_WIDTH]
THEN
    LOC_FRAME_WIDTH = .SCB[PSM$L_PAGE_WIDTH];		! stay in page bounds

!  Get string info
CURR_SIZE 	= .CHAR_STRING[SIZE];
PTR		= FRAME_PTR[0,0,.SCB[PSM$L_PAGE_WIDTH]];
STR_PTR		= .CHAR_STRING[ADDR];

!  Do a quick fill of the frame
 FILL_FRAME (.SCB,
	     %CHAR(32),		! fill with blanks
	     FRAME_PTR[0,0,.SCB[PSM$L_PAGE_WIDTH]],
	     .LOC_FRAME_WIDTH,
	     .LOC_FRAME_LENGTH);

DECR L FROM .LOC_FRAME_LENGTH TO 1 DO 
    BEGIN
    IF .CURR_SIZE GEQ .LOC_FRAME_WIDTH THEN
	NUM_CHARS = DELIMIT_STRING(.STR_PTR,%CHAR(32),.LOC_FRAME_WIDTH)
    ELSE
	NUM_CHARS = .CURR_SIZE;
				 ! adjust pointer
    DISCARD (LEADING, %C' ', .STR_PTR, .NUM_CHARS, NUM_CHARS, STR_PTR);
    CH$MOVE(.NUM_CHARS, .STR_PTR, .PTR);

    PTR = .PTR + .SCB[PSM$L_PAGE_WIDTH];		! Address calc. is based
							!  on Form Width
    STR_PTR = .STR_PTR + .NUM_CHARS;

    IF .LOC_FRAME_WIDTH GEQ .CURR_SIZE THEN
	EXITLOOP;

    CURR_SIZE = .CURR_SIZE - .NUM_CHARS;		! Decrease string size
    END;

IF .STR_PTR LSS (.CHAR_STRING[ADDR] + .CHAR_STRING[SIZE])
THEN		! truncation occurred
    CALLG (.AP, MOVE_FRAME);			! dont delimit..just move str.
END;

%sbttl 'CENTER_FRAME - Insert String Information into the Center of this Frame'
!++
! Functional Description:
!	This procedure inserts a string into the cneter of an array(frame).
!	Insertion continues until either no more string or no more room
!	The idea is to center the string within the frame. 
!	1) If the string is shorter than the entire frame then
!	   center the string in the frame.
!	2) If the string is longer than the entire frame then
!	   insert as much of the string as possible.
!	3) Use an assumed pad of blanks for beginning and end of string.
!
!
! Formal Parameters:
!	SCB		- Address of the SCB
!	CHAR_STRING	- Descriptor of String to Insert
!	FRAME_PTR	- Address of first byte of Frame
!	FRAME_LENGTH	- Length of Frame
!	FRAME_WIDTH	- Width of Frame
!
! Implicit Inputs:
!		none
!
! Implicit Outputs:
!		none
!
! Returned Value:
!		none
!
! Side Effects:
!		Truncation is possible.
!
!--
ROUTINE CENTER_FRAME (
	SCB		: REF $BBLOCK,
	CHAR_STRING	: REF VECTOR[2],
	FRAME_PTR	: REF PAGE_ARRAY,
	FRAME_WIDTH	,		! Number of Columns
	FRAME_LENGTH			! Number of Rows
	)  :	NOVALUE	=
BEGIN
LITERAL K_MAX_BUFFER_SIZE = 512, ! maximum possible buffer size
	K_PAD_LEN	  =   2; ! length to pad the string

LOCAL	PTR 		: REF PAGE_ARRAY, ! points to col 0, variable row
	LOC_FRAME_LENGTH,		  ! local count of frame_length
	LOC_FRAME_WIDTH	,		  ! local count of frame_width
	PAD_CHAR	,		  ! pad character is assumed a space
	PTR_OFFSET	: SIGNED,	  ! pos/neg offset to origin
	STR_PTR		,		  ! points to str position in frame 
	STR_SIZE	,		  ! num char left in string
	BUFFER		: VECTOR [512,byte],  ! variable buff for pad and string
	STR_DESC	: VECTOR [2];	  ! desc of string

! Check for dumb calls. Frame dimensions must be writable
!
IF (.FRAME_LENGTH LEQ 0) OR (.FRAME_WIDTH LEQ 0)
THEN
    RETURN;
IF  (.FRAME_LENGTH GTR .SCB[PSM$L_PAGE_LENGTH]) OR 
    (.FRAME_WIDTH GTR .SCB[PSM$L_PAGE_WIDTH])
THEN
    RETURN;
! String must not be zero !!
!
IF .CHAR_STRING[SIZE] EQL 0 THEN RETURN SS$_NORMAL;

! Check page boundary conditions
!
LOC_FRAME_LENGTH = .FRAME_LENGTH;
IF .LOC_FRAME_LENGTH GTR .SCB[PSM$L_PAGE_LENGTH]
THEN
    LOC_FRAME_LENGTH = .SCB[PSM$L_PAGE_LENGTH];		! stay in page bounds

LOC_FRAME_WIDTH  = .FRAME_WIDTH;
IF .LOC_FRAME_WIDTH GTR .SCB[PSM$L_PAGE_WIDTH]
THEN
    LOC_FRAME_WIDTH = .SCB[PSM$L_PAGE_WIDTH];		! stay in page bounds

!  Get string into padding buffer if enough room
!
STR_DESC[SIZE] = %ALLOCATION (BUFFER);	! length of string and pad chars
STR_DESC[ADDR] = BUFFER;		! ptr into pad&string buffer
PAD_CHAR  = %CHAR(32,32);
PTR = FRAME_PTR[0,0,.SCB[PSM$L_PAGE_WIDTH]];	! init

! Pad the string if there is enough room
IF (.CHAR_STRING[SIZE] + (2 * K_PAD_LEN)) 
		LEQ 
	(.LOC_FRAME_WIDTH * .LOC_FRAME_LENGTH)
THEN
    BEGIN
    !  Set the size to correct value
    !
    IF .CHAR_STRING[SIZE] LEQ (K_MAX_BUFFER_SIZE-2*(K_PAD_LEN)) THEN
	STR_DESC[SIZE] = .CHAR_STRING[SIZE] + ( 2 * (K_PAD_LEN))
    ELSE
	STR_DESC[SIZE] = K_MAX_BUFFER_SIZE;

    !  Pad the string using the local buffer
    CH$COPY (K_PAD_LEN, PAD_CHAR, .CHAR_STRING[SIZE], .CHAR_STRING[ADDR],
	     K_PAD_LEN, PAD_CHAR, .PAD_CHAR, .STR_DESC[SIZE],
	     .STR_DESC[ADDR]);
    END
ELSE		! copy into local buffer
    BEGIN
    CH$MOVE(.CHAR_STRING[SIZE], .CHAR_STRING[ADDR], .STR_DESC[ADDR]);
    STR_DESC[SIZE] = .CHAR_STRING[SIZE];
    END;

!  Calc offset to pointer using new padded length
IF ( .LOC_FRAME_WIDTH * .LOC_FRAME_LENGTH) GTR (.STR_DESC[SIZE]) 
THEN
    PTR_OFFSET	= (( .LOC_FRAME_WIDTH * .LOC_FRAME_LENGTH)
			     - (.STR_DESC[SIZE]))/2
ELSE
    PTR_OFFSET	= 0;

!  Check for negative offset
IF .PTR_OFFSET LSS 0 
THEN 
    PTR_OFFSET = 0;

!  Set pointer to buffer
STR_PTR = .PTR + .PTR_OFFSET;
STR_SIZE = .STR_DESC[SIZE];

DECRU L FROM .LOC_FRAME_LENGTH TO 1 DO 
    BEGIN

    LOCAL NUM_CHARS; ! number of chars to move to the frame

    IF .PTR_OFFSET GEQ .LOC_FRAME_WIDTH THEN
	BEGIN
	PTR = .PTR + .SCB[PSM$L_PAGE_WIDTH];     ! go to next row of frame
	PTR_OFFSET = .PTR_OFFSET - .LOC_FRAME_WIDTH; ! adjust offset to column
	END
    ELSE BEGIN	
									
	IF .STR_SIZE GEQ (.LOC_FRAME_WIDTH - .PTR_OFFSET) THEN
	    NUM_CHARS = .LOC_FRAME_WIDTH - .PTR_OFFSET
	ELSE 				! check for overflow of frame width 
	    NUM_CHARS = .STR_SIZE;		! - insert which ever is less

	CH$MOVE(.NUM_CHARS, .STR_DESC[ADDR], .STR_PTR);
	STR_PTR = .PTR + .SCB[PSM$L_PAGE_WIDTH];! Address calc. is base on
        PTR = .STR_PTR;				!   Frame ptr[0,0] & Form Width

        STR_DESC[ADDR] = .STR_DESC[ADDR] + .NUM_CHARS;

        IF .LOC_FRAME_WIDTH GTRU .STR_SIZE	! Already inserted it all
	THEN
	    EXITLOOP;

        STR_SIZE = .STR_SIZE - .NUM_CHARS;		! Decrease string size

    ! reset the offset to start column one
        PTR_OFFSET = 0;

       END;
    END;
END;

%sbttl 'MERGE_FRAME - Merge Information in this Frame of the Page'
!++
! Functional Description:
!	This procedure merges rows of non-blank strings into an array(frame).
!	Merging continues until either no more strings or no more frame.  The
!	contents of the frame are merged to the base of the frame.  Any row 
!	with data present is considered impure and is merged.
!
! Formal Parameters:
!	SCB		- Address of the SCB
!	CHAR_STRING	- Descriptor of String to Insert
!	FRAME_PTR	- Address of first byte of Frame
!	FRAME_LENGTH	- Length of Frame
!	FRAME_WIDTH	- Width of Frame
!
! Implicit Inputs:
!		none
!
! Implicit Outputs:
!		none
!
! Returned Value:
!		none
!
! Side Effects:
!		Truncation is possible.
!
!--
ROUTINE MERGE_FRAME (
	SCB		: REF $BBLOCK,
	CHAR_STRING	: REF VECTOR[2],
	FRAME_PTR	: REF PAGE_ARRAY,
	FRAME_WIDTH	,		! Number of Columns
	FRAME_LENGTH	,		! Number of Rows
	RET_LEN		: REF VECTOR[,word]
	)  :	NOVALUE	=
BEGIN

LITERAL	K_MAX_SIZE	= 256;

LOCAL
	CLR_STR		: VECTOR[2],
	SRCE_STR	: VECTOR[2],
	BUFFER		: VECTOR[256,byte],
	CURRENT_PTR	: REF PAGE_ARRAY,
	CURRENT_LEN	,
	DEST_OFFSET	,
	SOURCE_OFFSET	;

! setup clr_str
!
CLR_STR[ADDR] = .CHAR_STRING[ADDR];
CLR_STR[SIZE] = .FRAME_WIDTH;
CH$FILL ( %C' ', .FRAME_WIDTH, .CLR_STR[ADDR]);
! setup source_str
!
SRCE_STR[SIZE] = %ALLOCATION(BUFFER);
SRCE_STR[ADDR] = BUFFER;

! setup current point and offsets into frame
!
CURRENT_PTR = FRAME_PTR[0,0, .SCB[PSM$L_PAGE_WIDTH]];

SOURCE_OFFSET = .FRAME_LENGTH-1;		! start at frame boundaries
DEST_OFFSET = .FRAME_LENGTH-1;

DECRU I FROM (.FRAME_LENGTH-1) TO 0
DO
    BEGIN
    FIND_DEST_PTR (	.SCB, 
			CLR_STR[0], 
			CURRENT_PTR[0,0,.SCB[PSM$L_PAGE_WIDTH]], 
			.FRAME_WIDTH, 
			.FRAME_LENGTH,
			DEST_OFFSET);

    FIND_SOURCE_PTR (	.SCB,
			SRCE_STR[0],
			CURRENT_PTR[0,0,.SCB[PSM$L_PAGE_WIDTH]],
			.FRAME_WIDTH,
			.DEST_OFFSET,
			SOURCE_OFFSET);

! Exit loop when no source string
!
    IF .SRCE_STR[SIZE] EQL 0
    THEN
	BEGIN
	RET_LEN[0] = .FRAME_LENGTH - .I;
	RETURN;
	END;

    ! Move the source to the destination
    ! 
    MOVE_FRAME (
		.SCB,
		SRCE_STR[0], 			! string frame reference
		CURRENT_PTR[0,.DEST_OFFSET,.SCB[PSM$L_PAGE_WIDTH]],
						! ref to frame
		.FRAME_WIDTH,			! cols to fill
		1);				! rows to fill

    ! Clear the source position
    !
    MOVE_FRAME (
		.SCB,
		CLR_STR[0], 			! string frame reference
		CURRENT_PTR[0,.SOURCE_OFFSET,.SCB[PSM$L_PAGE_WIDTH]],
						! ref to frame
		.FRAME_WIDTH,			! cols to fill
		1);				! rows to fill

    SRCE_STR[SIZE] = K_MAX_SIZE;

    END;
END;

%sbttl 'INSERT_NAME_BANNER - Insert User Name as Banner into this Frame'
!++
! Functional Description:
!	This procedure inserts a string into the cneter of an array(frame).
!	The workhorse of this routine is the BANNER routine which creates the
!	large letters.  Insertion is attempted in the center of the frame.
!	Otherwise, insertion starts at the left margin until no more characters
!	will fit.
!	NOTE:	Returns the amount of space used in the frame
!
! Formal Parameters:
!	SCB			- Address of the SCB
!	CHAR_DESC		- Desc String to Insert
!	FRAME_PTR		- Address of first byte of Frame
!	FRAME_LENGTH		- Length of Frame and Largest Banner
!	FRAME_WIDTH		- Width of Frame and Height of Characters
!	DESIRED_BAN_TYPE	- Requested banner type
!
! Implicit Inputs:
!		none
!
! Implicit Outputs:
!		none
!
! Returned Value:
!		none
!
! Side Effects:
!		Truncation is possible.
!
!--
ROUTINE INSERT_NAME_BANNER (
	SCB		: REF $BBLOCK,
	CHAR_DESC	: REF VECTOR[2],
	FRAME_PTR	: REF PAGE_ARRAY,
	FRAME_WIDTH	,			! Number of Columns
	FRAME_LENGTH	,			! Number of Rows
	DESIRED_BAN_TYPE			! Banner size desired
	)  =
BEGIN
!  Define literals to use in "Banner" Call
!  (incl... char_repeat, line_repeat, spacing)
!
LITERAL	K_LARGE_LETTERS =  14,			! Double size chars
	K_MAX_STRING_SIZE = 42,			! max expanded chars(512 buffer)
	K_ALT_CHAR	=   0,			! alternate construction char
	K_SPACING	=   2,			! between character spacing
	K_LEAD_SPACES 	=   0,			! number of leading spaces
	K_MAX_BUF	= 512,			! max for this frame buffer
	LEAD_MASK	= %B'00100000',		! convert lower to upper case
	TRAILING	=   1;  		! flag for discard
						!   (anything but 0 is trailing)
!
!  By defining local buffer and descriptor. I can call the banner routine
!  and get the length of the string ... then use an algorithm to center the
!  string into the frame.
!
LOCAL	
    NUM_LINES	,
    CHAR_REPEAT	,				! character repeat
    LINE_REPEAT	,				! line repeat
    BUFFER	: VECTOR [512,byte],		! assume max size 512 bytes
    STRING_DESC	: VECTOR [2],			! descriptor to current string
    STR_PTR	,				! temp addr of input string
    STR_LEN	,				! temp length of input string
    RET_LEN	: VECTOR[1];			! Return Length Used

! Dont even try if no frame
!
IF (.FRAME_LENGTH LSS 7)			! won't ever fit !!
	OR
   (.FRAME_WIDTH LEQ 0)				! nadda...
THEN
    RETURN 0;					! dont even try... no room...

STR_LEN = .CHAR_DESC[SIZE];			! move them into registers
STR_PTR = .CHAR_DESC[ADDR];

BAS$EDIT (CHAR_DESC[0], CHAR_DESC[0], UPCASE_MASK);
						! lower to upper case character
! Insert only the string ... No trailing blanks
!
DISCARD (TRAILING, %C' ', .STR_PTR, .STR_LEN, 
	 STR_LEN, STR_PTR);			! Return length and pointer

!
!  init the character spacing ...depends on frame_length passed in !
!	assume small chars.
CHAR_REPEAT =   1;				! times to repeat a char
LINE_REPEAT =   1;				! times to repeat a line
NUM_LINES = 	7;				! lines equal height of banner

! Attempt to give the caller what he wants
!   Only use large banners if they fit in the Frame
!
IF (
    (.DESIRED_BAN_TYPE EQL K_LARGE_LETTERS)	! if he wants it
		AND
    ((.FRAME_LENGTH GEQ K_LARGE_LETTERS)	! and...
		AND				! if there is room !!!
    ((.FRAME_WIDTH/12) GEQ .STR_LEN))
				    )
THEN
    BEGIN
    CHAR_REPEAT =   2;				! times to repeat a char
    LINE_REPEAT =   2;				! times to repeat a line
    NUM_LINES 	=   14;				! height of banner
    END;

! truncate long character names to fit in buffer
!
IF .STR_LEN GTR K_MAX_STRING_SIZE
THEN
    STR_LEN = K_MAX_STRING_SIZE;		! maximum 42 chars in
						!   buffer of 512
! get the buffer
!
STRING_DESC[SIZE] = %ALLOCATION(BUFFER);
STRING_DESC[ADDR] = BUFFER;

INCR LINE_NO FROM 0 TO (.NUM_LINES - 1)
DO
    BEGIN
    PSM$BANNER (.SCB,
		.STR_LEN,
		.STR_PTR,
		K_LEAD_SPACES,
		.CHAR_REPEAT,
		.LINE_REPEAT,
		K_SPACING,
		K_ALT_CHAR,
		.STRING_DESC[ADDR],
		.LINE_NO,
		STRING_DESC[SIZE]);

    CENTER_FRAME ( .SCB,
		    STRING_DESC[0],
		    FRAME_PTR[0,.LINE_NO,.SCB[PSM$L_PAGE_WIDTH]], 
		    .FRAME_WIDTH, 1);
    ! re-init
    STRING_DESC[SIZE] = K_MAX_BUF; 		! reset buffer size
    END;

RETURN .NUM_LINES
END;

%sbttl 'FIND_DEST_PTR - Finds an empty Position in the Frame'
!++
! Functional Description:
!	This routine finds the first empty frame position from the bottom
!	of the frame.  The returned parameters include the dest_ptr (position
!	found) and the length left in the frame.  If unable to find an empty
!	position then RET_OFFSET = .FRAME_LENGTH
!
! Formal Parameters:
!	SCB			- Address of the SCB
!	CLR_STR			- Descriptor of blank string
!	FRAME_PTR		- Address of first byte of Frame
!	FRAME_LENGTH		- Length of Frame and Largest Banner
!	FRAME_WIDTH		- Width of Frame and Height of Characters
!	RETURN_PTR		- Pointer to position in frame
!	RET_LEN			- Resultant length of frame
!
! Implicit Inputs:
!		none
!
! Implicit Outputs:
!		none
!
! Returned Value:
!		none
!
! Side Effects:
!		Truncation is possible.
!
!--
ROUTINE FIND_DEST_PTR (
	SCB		: REF $BBLOCK,
	CLR_STR		: REF VECTOR[2],
	FRAME_PTR	: REF PAGE_ARRAY,
	FRAME_WIDTH	,		! Number of Columns
	FRAME_LENGTH	,		! Number of Rows
	RET_OFFSET	: REF VECTOR
	)  :	NOVALUE	=
BEGIN
LOCAL
    CURR_PTR	;

! exit if frame length is zero
!
IF .FRAME_LENGTH EQL 0
THEN
    RETURN;

DECR I FROM (.FRAME_LENGTH-1) TO 0
DO
    BEGIN
    CURR_PTR = FRAME_PTR[0, .I, .SCB[PSM$L_PAGE_WIDTH]];

    IF CH$EQL( .FRAME_WIDTH, .CURR_PTR,
	       1, CH$PTR( UPLIT (' ')), %C' ' )
    THEN
	BEGIN
	RET_OFFSET[0] = .I;
	RETURN;				! exit this routine
	END;
    END;

RET_OFFSET[0] = 0;			! exit with 0 if destination not found

END;

%sbttl 'FIND_SOURCE_PTR - Finds an empty Position in the Frame'
!++
! Functional Description:
!	This routine finds the first nonempty frame position from the bottom
!	of the frame.  The returned parameters include the ret_str descriptor
!	return_ptr (position found) and the length left in the frame.  If 
!	unable to find a string position then RET_STR[SIZE]=0, RET_LEN = 0 and 
!	RETURN_PTR = FRAME_PTR.
!
! Formal Parameters:
!	SCB			- Address of the SCB
!	RET_STR			- Descriptor of buffer for return string
!	FRAME_PTR		- Address of first byte of Frame
!	FRAME_LENGTH		- Length of Frame and Largest Banner
!	FRAME_WIDTH		- Width of Frame and Height of Characters
!	RET_OFFSET		- Pointer to position in frame
!
! Implicit Inputs:
!		none
!
! Implicit Outputs:
!		none
!
! Returned Value:
!		none
!
! Side Effects:
!		Truncation is possible.
!
!--
ROUTINE FIND_SOURCE_PTR (
	SCB		: REF $BBLOCK,
	RET_STR		: REF VECTOR[2],
	FRAME_PTR	: REF PAGE_ARRAY,
	FRAME_WIDTH	,		! Number of Columns
	FRAME_LENGTH	,		! Number of Rows
	RET_OFFSET	: REF VECTOR
	)  :	NOVALUE	=
BEGIN

LOCAL
    CURR_PTR;


! exit if frame length is zero
!
IF .FRAME_LENGTH EQL 0
THEN
    BEGIN
    RET_STR[SIZE] = 0;
    RETURN;
    END;

DECR I FROM (.FRAME_LENGTH-1) TO 0
DO
    BEGIN
    CURR_PTR = FRAME_PTR[0,.I,.SCB[PSM$L_PAGE_WIDTH]];

    IF CH$NEQ( .FRAME_WIDTH, .CURR_PTR,
	       1, CH$PTR( UPLIT (' ')), %C' ' )
    THEN
	BEGIN
	CH$MOVE(.FRAME_WIDTH, .CURR_PTR,
		.RET_STR[ADDR]);
	RET_STR[SIZE] = .FRAME_WIDTH;
	RET_OFFSET[0] = .I;
	RETURN;				! exit this routine
	END;
    END;

RET_STR[SIZE] = 0;
RET_OFFSET = 0;

END;

%sbttl 'DELIMIT_STRING - Return the last position of this delimiter'  
!++
! Functional Description:
!	This procedure returns the position of the delimiter nearest the
!	string_end
!
! Formal Parameters:
!	STR_PTR		- Pointer of String to delimit
!	CHAR		- Character delimiter
!	STR_END		- End position of string
!
! Implicit Inputs:
!		none
!
! Implicit Outputs:
!		none
!
! Returned Value:
!		none
!
! Side Effects:
!		none
!--
ROUTINE DELIMIT_STRING	(
	STR_PTR	,
	CHAR	,
	STR_END		)	=
BEGIN
LOCAL
    POS,
    BASE,
    TEMP_PTR,
    CHAR_PTR;

TEMP_PTR = .STR_PTR;
BASE = .STR_PTR + .STR_END - 1;
CHAR_PTR = CH$PTR(CHAR);

DECR CURR_PTR FROM (.BASE) TO .STR_PTR DO
BEGIN
    TEMP_PTR = CH$PTR(.CURR_PTR);

    POS = CH$EQL(1, .TEMP_PTR, 1, .CHAR_PTR);

    IF  (.POS EQL 1) AND 
	(.CURR_PTR EQL .STR_PTR)
    THEN
	RETURN .STR_END;	! ...return the original length

    IF  (.POS EQL 1) AND
	(.CURR_PTR GTR .STR_PTR) 
    THEN 					! char in string
	RETURN (.CURR_PTR - .STR_PTR + 1);		!  ...return position plus one

    IF (.POS EQL 0) AND (.CURR_PTR EQL .STR_PTR) THEN
	RETURN .STR_END;				! handle extra decrem
    END;

RETURN .STR_END;	! ...return the original length

END;

%sbttl 'DELIMIT_STRING_NOT - Return the last position of not this delimiter'  
!++
! Functional Description:
!	This procedure returns the length of the string without the delimited
!	characters on the string end.  Return the original length if
!	non_delimiters cannot be found.
!
! Formal Parameters:
!	STR_PTR		- Pointer of String to delimit
!	CHAR		- Character delimiter
!	STR_END		- End position of string
!
! Implicit Inputs:
!		none
!
! Implicit Outputs:
!		none
!
! Returned Value:
!		none
!
! Side Effects:
!		none
!--
ROUTINE DELIMIT_STRING_NOT(
	STR_PTR	,
	CHAR	,
	STR_END		)	=
BEGIN


LOCAL
    PTR	: REF VECTOR[,byte];

IF .STR_END EQL 0
THEN
    RETURN 0;

PTR = .STR_PTR + .STR_END - 1;

WHILE .PTR GTRU .STR_PTR
DO
    IF .PTR[0] NEQU .CHAR
    THEN
	EXITLOOP
    ELSE
	PTR = .PTR - 1;

RETURN .PTR - .STR_PTR + 1;

END;

%sbttl 'DISCARD - Returns a Pointer to First Char NOT Discarded'  
!++
! Functional Description:
!	This routine discards the character in the string from the beginning
!	(LEADING) or end(TRAILING) of the string(STR_PTR) and returns a pointer
!	to the first position that is found not to contain the discard 
!	character(CHAR).  The boundaries of the string are the beginning pointer
!	and the string length(LEN).
!
! Formal Parameters:
!	WHICH_WAY	- Leading/Trailing
!	CHAR		- Character to discard
!	STR_PTR		- Pointer of String to delimit
!	LEN		- Length of string
!	RET_PTR		- Return pointer to first undiscarded position
!
! Implicit Inputs:
!		none
!
! Implicit Outputs:
!		none
!
! Returned Value:
!		none
!
! Side Effects:
!		none
!--
ROUTINE DISCARD	(
	WHICH_WAY,
	CHAR,
	STR_PTR	,
	LEN	: WORD,			! force word size
	RET_LEN : REF VECTOR,
	RET_PTR	: REF VECTOR) : NOVALUE =
BEGIN

LITERAL
	LEADING    = 0;

LOCAL
    DSTR_DESC	: VECTOR[2];

! a descriptor is needed for BAS$EDIT routine
DSTR_DESC[SIZE] = .LEN;
DSTR_DESC[ADDR] = .STR_PTR;

IF .WHICH_WAY EQL LEADING THEN
    BEGIN
    BAS$EDIT ( DSTR_DESC[0], DSTR_DESC[0], LEAD_MASK);	! trim leading blanks
    RET_PTR[0] = .DSTR_DESC[ADDR];
    RET_LEN[0] = .DSTR_DESC[SIZE];
    END
ELSE							! trim trailing blanks
    BEGIN
    RET_LEN[0] = DELIMIT_STRING_NOT ( .STR_PTR, .CHAR, .LEN);
    RET_PTR[0] = .STR_PTR;
   END;
END;

%sbttl 'FILE_OPEN - Boolean Valued routine indicating file open status'
!++
! Functional Description:
!	This routine interrogates the FAB and determines if the current file
!	is open and/or if information can be extracted from the file.
!	TRUE = 1, FALSE = 0;
!
! Formal Parameters:
!		none
!
! Implicit Inputs:
!		none
!
! Implicit Outputs:
!		none
!
! Returned Value:
!		none
!
! Side Effects:
!		none
!--
ROUTINE FILE_OPEN (
		SCB		: REF $BBLOCK	! SCB
		 )	=
BEGIN

RETURN .SCB[PSM$V_FAB_VALID]

END;

END
ELUDOM
