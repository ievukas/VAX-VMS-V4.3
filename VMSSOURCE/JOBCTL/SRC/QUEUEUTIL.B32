MODULE QUEUEUTIL(%TITLE	'Queue manipulation utilities'
		IDENT = 'V04-000'
		) =
BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY:
!	Job controller.
!
! ABSTRACT:
!	This module contains utility routines to manipulate the job queue.
!
! ENVIRONMENT:
!	VAX/VMS user and kernel mode.
!--
!
! AUTHOR: M. Jack, CREATION DATE: 16-Feb-1982
!
! MODIFIED BY:
!
!	V03-007	KPL0002		P Lieberwirth,	23-Jul-1984
!		Protect routine DEQUEUE_OPEN_JOB as in V03-006.
!
!	V03-006	KPL0001		P Lieberwirth,	 9-Jul-1984
!		Protect routine COMPLETE_JOB against common form of queue file
!		corruption - specifically an invalid SJH.
!
!	V03-005	MLJ0115		Martin L. Jack,	30-Jul-1983  14:55
!		Changes for job controller baselevel.
!
!	V03-004	MLJ0114		Martin L. Jack,	23-Jun-1983  5:02
!		Changes for job controller baselevel and divide with RECORDUTL.
!
!	V03-003	MLJ0113		Martin L. Jack,	26-May-1983  21:08
!		Changes for job controller baselevel.
!
!	V03-002	MLJ0112		Martin L. Jack,	29-Apr-1983  3:04
!		Changes for job controller baselevel.
!
!	V03-001	MLJ0109		Martin L. Jack,	14-Apr-1983  12:47
!		Changes for job controller baselevel.
!
!**

REQUIRE 'SRC$:JOBCTLDEF';


FORWARD ROUTINE
	ENTER_PROCESS_DATA:		NOVALUE,
	FIND_PROCESS_DATA:		L_OUTPUT_3,
	SEARCH_QUEUES:			L_OUTPUT_4,
	DEQUEUE_OPEN_JOB:		L_OUTPUT_1,
	ALLOCATE_ENTRY_NUMBER,
	DEALLOCATE_ENTRY_NUMBER:	NOVALUE,
	JOB_STATUS_MESSAGE,
	NOTIFY_USER:			NOVALUE,
	COMPLETE_JOB:			NOVALUE,
	VALIDATE_OBJECT_NAME,
	FIND_CHARACTERISTIC:		L_OUTPUT_1,
	FIND_FORM_NAME:			L_OUTPUT_2,
	FIND_FORM_NUMBER:		L_OUTPUT_2,
	FIND_QUEUE:			L_OUTPUT_4,
	FIND_FORM_REFERENCES_J,
	FIND_FORM_REFERENCES,
	FIND_QUEUE_REFERENCES_J,
	FIND_QUEUE_REFERENCES,
	DEALLOCATE_VARIABLE_DATA:	NOVALUE,
	FETCH_VARIABLE_ITEM,
	FETCH_VARIABLE_ITEM_LIST,
	FETCH_VARIABLE_DATA:		NOVALUE,
	STORE_VARIABLE_DATA,
	STORE_VARIABLE_DATA_LIST;


EXTERNAL ROUTINE
	AFTER_AST:			NOVALUE,
	ALLOCATE_MEMORY,
	ALLOCATE_RECORD:		L_OUTPUT_2,
	BROADCAST_MESSAGE:		NOVALUE,
	DEALLOCATE_RECORD_LIST:		NOVALUE,
	DELETE_SJH_RECORD:		NOVALUE,
	ENQUEUE_JOB:			L_OUTPUT_2 NOVALUE,
	READ_RECORD,
	RELEASE_RECORD:			NOVALUE,
	REWRITE_RECORD:			NOVALUE,
	SCAN_INCOMPLETE_SERVICES:	NOVALUE,
	UPDATE_GETQUI_DATA:		NOVALUE,
	WRITE_ACCOUNTING_RECORD:	NOVALUE;


BUILTIN
	EDIV,
	MOVC3,
	TESTBITCS;

GLOBAL ROUTINE ENTER_PROCESS_DATA(TYPE,PID,P1,P2): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine adds an entry to the process data structure.
!
! INPUT PARAMETERS:
!	TYPE		- Process type.
!	PID		- Process ID.
!	P1		- (Optional) First parameter.
!	P2		- (Optional) Second parameter.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	PDB:		REF BBLOCK,	! Pointer to PDB
	PDE:		REF BBLOCK;	! Pointer to PDB entry
BUILTIN
	ACTUALCOUNT;


! Search for an unused entry within the existing PDB list.
!
PDB = .PROCESS_DATA_LIST;
WHILE .PDB NEQ 0 DO
    BEGIN
    IF .PDB[PDB_COUNT] LSSU PDB_K_MAX
    THEN
	BEGIN
	PDE = PDB[PDB_ENTRIES] + .PDB[PDB_COUNT] * PDE_S_ENTRY;
	EXITLOOP;
	END;
    PDB = .PDB[PDB_LINK];
    END;


! If no free entry found, allocate and initialize a new page.
!
IF .PDB EQL 0
THEN
    BEGIN
    PDB = ALLOCATE_MEMORY();
    PDB[PDB_LINK] = .PROCESS_DATA_LIST;
    PROCESS_DATA_LIST = .PDB;
    PDE = PDB[PDB_ENTRIES];
    END;


! Initialize the PDB entry.
!
PDB[PDB_COUNT] = .PDB[PDB_COUNT] + 1;
PDE[PDE_TYPE] = .TYPE;
PDE[PDE_PID] = .PID;
IF ACTUALCOUNT() GEQU 3 THEN PDE[PDE_P1] = .P1;
IF ACTUALCOUNT() GEQU 4 THEN PDE[PDE_P2] = .P2;
END;

GLOBAL ROUTINE FIND_PROCESS_DATA(TYPE,PID,REMOVE; TY,P1,P2): L_OUTPUT_3=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine looks up an entry in the process data structure.
!
! INPUT PARAMETERS:
!	TYPE		- Type of process.
!	PID		- Process ID.
!	REMOVE		- True if entry to be removed.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	TY		- Type of process found.
!	P1		- First parameter.
!	P2		- Second parameter.
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	True if the entry was found, false otherwise.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	PDB:		REF BBLOCK;	! Pointer to PDB


PDB = .PROCESS_DATA_LIST;
WHILE .PDB NEQ 0 DO
    BEGIN
    LOCAL
	PDE:		REF BBLOCK;	! Pointer to PDB entry

    PDE = PDB[PDB_ENTRIES];
    INCR CBN FROM 0 TO .PDB[PDB_COUNT]-1 DO
	BEGIN
	IF .PDE[PDE_PID] EQL .PID
	AND (.TYPE EQL PDE_K_ANY OR .TYPE EQL .PDE[PDE_TYPE])
	THEN
	    BEGIN
	    TY = .PDE[PDE_TYPE];
	    P1 = .PDE[PDE_P1];
	    P2 = .PDE[PDE_P2];
	    IF .REMOVE
	    THEN
		BEGIN
		PDB[PDB_COUNT] = .PDB[PDB_COUNT] - 1;
		CH$COPY(
		    (.PDB[PDB_COUNT] - .CBN) * PDE_S_ENTRY,
		    .PDE + PDE_S_ENTRY,
		    0,
		    (.PDB[PDB_COUNT] - .CBN) * PDE_S_ENTRY + PDE_S_ENTRY,
		    .PDE);
		END;
	    RETURN TRUE;
	    END;
	PDE = .PDE + PDE_S_ENTRY;
	END;
    PDB = .PDB[PDB_LINK];
    END;


FALSE
END;

GLOBAL ROUTINE SEARCH_QUEUES(
	QSM,
	SMQ_NF, SMQ_F,
	ENTRY, JOBNAME,
	ACCESS_CHECK,
	REMOVE,
	CTX;
	SJH_N, SJH, SMQ_N, SMQ): L_OUTPUT_4=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine provides a general facility to search the job queues.
!
! INPUT PARAMETERS:
!
!	QSM		- Bit mask that identifies queues to be searched.
!
!	SMQ_NF		- Record number of SMQ to search.
!	SMQ_F		- Pointer to SMQ to search.
!
!	ENTRY		- Address of job entry number, or 0 to denote wild.
!
!	JOBNAME		- Short descriptor for job name, or 0 to denote wild.
!			  This parameter is significant only if ENTRY is 0.
!			  Job name is implicitly qualified by username.
!
!	ACCESS_CHECK	- Address of access check routine, or 0 to denote none.
!
!	REMOVE		- Specifies if job to be removed from queue.
!				QSM_K_NO_REMOVE		Never remove
!				QSM_K_REMOVE		Always remove
!				QSM_K_REMOVE_INACTIVE	Remove unless executing
!
!	CTX		- Pointer to context area of size QSM_K_CTXSIZE bytes
!			  for wildcard operations (optional).  Initialize to
!			  binary zeros prior to first call.
!
! IMPLICIT INPUTS:
!	MBX		- Pointer to buffered mailbox message.
!
! OUTPUT PARAMETERS:
!	SJH_N		- Record number of SJH.
!	SJH		- Pointer to SJH.
!	SMQ_N		- Record number of SQH or SMQ.
!	SMQ		- Pointer to SQH or SMQ.
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	SS$_NORMAL	- Job found.
!	JBC$_NOSUCHJOB	- Job not found.
!	JBC$_NOPRIV	- No privilege to operate on job.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	QSM:		BBLOCK,			! Queue search bitmask
	SMQ_F:		REF BBLOCK,		! Pointer to SMQ
	ENTRY:		REF VECTOR[,WORD],	! Pointer to job ID or 0
	JOBNAME:	REF BBLOCK,		! Descriptor for name or 0
	CTX:		REF VECTOR,		! Pointer to context block
	SJH:		REF BBLOCK,		! Pointer to SJH
	SMQ:		REF BBLOCK;		! Pointer to SQH or SMQ
LOCAL
	LIST_OFFSET,			! Offset to list head in SQH or SMQ
	QID,				! Queue type context
	SQX_N,				! Record number of SQX
	SQX:		REF BBLOCK,	! Pointer to SQX
	SQE_N,				! Offset to SQX entry
	SJH_NP,				! Record number of predecessor of SJH
	SJH_P:		REF BBLOCK;	! Pointer to predecessor of SJH
BUILTIN
	NULLPARAMETER;


! Set up context for the search.  If the context block is supplied, initialize
! context from the block; otherwise, initialize as for first call.
!
LIST_OFFSET = 0;
QID = 0;
SQX_N = 0;
SQX = 0;
SQE_N = 0;
SMQ_N = 0;
SMQ = 0;
SJH_NP = 0;
SJH_P = 0;
IF NOT NULLPARAMETER(8)
THEN
    BEGIN
    LIST_OFFSET =	.CTX[0];
    QID =		.CTX[1];
    SQX_N =		.CTX[2];
    SQX =		.CTX[3];
    SQE_N =		.CTX[4];
    SMQ_N =		.CTX[5];
    SMQ =		.CTX[6];
    SJH_NP =		.CTX[7];
    SJH_P =		.CTX[8];
    END;

    
! Loop until a job is found, or until all queues have been searched.
!
WHILE TRUE DO
    BEGIN

    ! If a new queue needs to be started, find the next queue that must be
    ! searched.  If no more queues, return failure.
    !
    IF .LIST_OFFSET EQL 0
    THEN
	BEGIN

	! Loop that advances over queues until one that is selected by the
	! queue selection criteria (QSM and SMQ) is found.
	!
	WHILE TRUE DO
	    BEGIN

	    ! Advance to next queue type.
	    !
	    QID = .QID + 1;


	    ! Case on the QID context to select the next queue type.
	    !
	    CASE .QID FROM 1 TO 3 OF
		SET


		[1]:	! open queue
		    BEGIN
		    IF .QSM[QSM_V_OPEN]
		    AND .SMQ_F[SMQ$W_OPEN_JOB_COUNT] NEQ 0
		    THEN 
			BEGIN
			LIST_OFFSET = $BYTEOFFSET(SQH$L_OPEN_LIST);
			EXITLOOP;
			END;
		    END;


		[2]:	! timer queue
		    BEGIN
		    IF .QSM[QSM_V_TIMER]
		    AND .SMQ_F[SMQ$W_TIMER_JOB_COUNT] NEQ 0
		    THEN
			BEGIN
			LIST_OFFSET = $BYTEOFFSET(SQH$L_TIMER_LIST);
			EXITLOOP;
			END;
		    END;


		[3]:	! pending queue
		    BEGIN
		    IF .QSM[QSM_V_PENDING]
		    AND .SMQ_F[SMQ$W_PENDING_JOB_COUNT] NEQ 0
		    THEN
			BEGIN
			IF .SMQ_F[SMQ$V_BATCH]
			    THEN LIST_OFFSET = $BYTEOFFSET(SQH$L_PENDING_BATCH_LIST)
			    ELSE LIST_OFFSET = $BYTEOFFSET(SQH$L_PENDING_PRINT_LIST);
			EXITLOOP;
			END;
		    END;


		[OUTRANGE]:
		    BEGIN
		    IF NOT .QID
		    THEN
			BEGIN
			LOCAL
			    SMQ_NP;	! Predecessor of new SMQ_N
			LABEL
			    FIND_SELECTED;


			! Even value greater than 3; establish a new queue
			! header.
			!
			IF .QSM[QSM_V_CURRENT]
			THEN
FIND_SELECTED:		    BEGIN

			    ! Read the queue header if not yet done.
			    !
			    IF .SMQ_N EQL 0
			    THEN
				SMQ = READ_RECORD(SMQ_N = SQH$K_RECNO);


			    ! Including current queues; the requested queue and
			    ! all execution queues of the same type must be
			    ! examined.  Execute a scan of the queue index to
			    ! locate these queues.
			    !
			    SMQ_NP = .SMQ_N;
			    SMQ_N = 0;


			    ! Initialize to the first queue index block.
			    !
			    IF .SQX_N EQL 0
			    THEN
				BEGIN
				SQX_N = .SMQ[SQH$L_QUEUE_INDEX_LIST];
				SQE_N = $BYTEOFFSET(SYM$T_DATA) - SQX$S_SQX;
				END;


			    ! Loop over queue index blocks.
			    !
			    WHILE .SQX_N NEQ 0 DO
				BEGIN
				LOCAL
				    SQX_NS;


				! Read the record if this has not been done.
				!
				IF .SQX EQL 0 THEN SQX = READ_RECORD(.SQX_N);


				! Loop over queue index entries.
				!
				WHILE TRUE DO
				    BEGIN
				    LOCAL
					SQE:		REF BBLOCK;


				    ! Advance to next entry, and ensure that it
				    ! is valid.
				    !
				    SQE_N = .SQE_N + SQX$S_SQX;
				    IF .SQE_N GEQU $BYTEOFFSET(SYM$T_DATA) + SQX$S_SQX * SQX$K_ENTRIES
					THEN EXITLOOP;
				    SQE = .SQX + .SQE_N;
				    IF CH$RCHAR(SQE[SQX$T_NAME]) EQL 0 THEN EXITLOOP;


				    ! Determine if this queue is interesting.
				    !
				    IF .SQE[SQX$L_QUEUE_LINK] EQL .SMQ_NF
				    OR (.SQE[SQX$V_BATCH] EQL .SMQ_F[SMQ$V_BATCH]
					AND .SQE[SQX$V_EXECUTOR])
				    THEN
				  	BEGIN
					SMQ_N = .SQE[SQX$L_QUEUE_LINK];
					LEAVE FIND_SELECTED;
					END;
				    END;


				! Advance to next index record.
				!
				SQX_NS = .SQX[SYM$L_LINK];
				RELEASE_RECORD(.SQX_N);
				SQX = 0;
				SQX_N = .SQX_NS;
				SQE_N = $BYTEOFFSET(SYM$T_DATA) - SQX$S_SQX;
				end;
			    END
			ELSE
			    BEGIN

			    ! Excluding current queues; only the requested queue
			    ! must be examined.
			    !
			    SMQ_NP = .SMQ_N;
			    IF .SMQ_N LEQU SQH$K_RECNO
				THEN SMQ_N = .SMQ_NF
				ELSE SMQ_N = 0;
			    END;


			! Release the previous queue header, and read the next.
			! If no more queues, return with failure.
			!
			IF .SMQ_NP NEQ 0 THEN RELEASE_RECORD(.SMQ_NP);
			IF .SMQ_N EQL 0 THEN RETURN JBC$_NOSUCHJOB;
			SMQ = READ_RECORD(.SMQ_N);


			! Now process hold job queue of the queue header just
			! established.
			!
			IF .QSM[QSM_V_HOLD]
			AND .SMQ_NF EQL .SMQ_N
			AND .SMQ[SMQ$L_HOLD_LIST] NEQ 0
			THEN
			    BEGIN
			    LIST_OFFSET = $BYTEOFFSET(SMQ$L_HOLD_LIST);
			    EXITLOOP;
			    END;
			END
		    ELSE
			BEGIN

			! Odd value greater than 3; current job queue of the
			! queue header established by the previous value.
			!
			IF .QSM[QSM_V_CURRENT]
			AND .SMQ_F[SMQ$V_BATCH] EQL .SMQ[SMQ$V_BATCH]
			AND .SMQ[SMQ$L_CURRENT_LIST] NEQ 0
			THEN
			    BEGIN
			    LIST_OFFSET = $BYTEOFFSET(SMQ$L_CURRENT_LIST);
			    EXITLOOP;
			    END;
			END;
		    END;


		TES;
	    END;


	IF .SMQ_N EQL 0 THEN SMQ = READ_RECORD(SMQ_N = SQH$K_RECNO);
	SJH_NP = .SMQ_N;
	SJH_P = 0;
	SJH_N = .SMQ[.LIST_OFFSET,0,32,0];
	END
    ELSE
	IF .SJH_P EQL 0
	    THEN SJH_N = .SMQ[.LIST_OFFSET,0,32,0]
	    ELSE SJH_N = .SJH_P[SYM$L_LINK];


    ! Now search the queue.
    !
    WHILE .SJH_N NEQ 0 DO
	BEGIN
	SJH = READ_RECORD(.SJH_N);
	IF
	    BEGIN
	    .SMQ_NF EQL .SJH[SJH$L_QUEUE_LINK] OR
	    (.QID GTRU 3 AND .QID AND .SMQ_NF EQL .SMQ_N)
	    END
	AND
	    BEGIN
	    IF .ENTRY NEQ 0
	    THEN
		.ENTRY[0] EQL .SJH[SYM$L_ENTRY_NUMBER]
	    ELSE
		IF .JOBNAME EQL 0
		THEN
		    TRUE
		ELSE
		    IF .JOBNAME[SDSC_W_LENGTH] EQL CH$RCHAR(SJH[SJH$T_NAME])
		    THEN
			CH$EQL(
			    .JOBNAME[SDSC_W_LENGTH], .JOBNAME[SDSC_A_POINTER],
			    .JOBNAME[SDSC_W_LENGTH], SJH[SJH$T_NAME]+1) AND
			CH$EQL(
			    ACM$S_USERNAME, MBX[ACM$T_USERNAME],
			    SJH$S_USERNAME, SJH[SJH$T_USERNAME])
		    ELSE
			FALSE
	    END
	THEN
	    BEGIN
	    LOCAL
		REMOVING;		! True if removing this entry


	    ! If an access check was requested, execute it.
	    !
	    IF .ACCESS_CHECK NEQ 0
	    THEN
		IF NOT (.ACCESS_CHECK)(.SMQ_F, .SJH)
		THEN
		    BEGIN
		    IF .SQX_N NEQ 0
			THEN RELEASE_RECORD(.SQX_N);
		    IF .SMQ_N NEQ 0 AND .SMQ_N NEQ .SJH_NP
			THEN RELEASE_RECORD(.SMQ_N);
		    IF .SJH_NP NEQ 0
			THEN RELEASE_RECORD(.SJH_NP);
		    RELEASE_RECORD(.SJH_N);
		    RETURN JBC$_NOPRIV;
		    END;


	    ! Determine if we must remove the job, based on the input parameter
	    ! and whether the job is executing.
	    !
	    REMOVING = TRUE;
	    CASE .REMOVE FROM QSM_K_NO_REMOVE TO QSM_K_REMOVE_INACTIVE OF
		SET
		[QSM_K_NO_REMOVE]:
		    REMOVING = FALSE;
		[QSM_K_REMOVE]:
		    0;
		[QSM_K_REMOVE_INACTIVE]:
		    IF .SJH[SJH$V_EXECUTING] THEN REMOVING = FALSE;
		TES;


	    IF .REMOVING
	    THEN
		BEGIN

		! Adjust the job reference counts for queues linked from the
		! queue header.
		!
		IF .QID LEQU 3
		THEN
		    BEGIN
		    CASE .QID FROM 1 TO 3 OF
			SET

			[OUTRANGE]:
			    0;

			[1]:
			    SMQ_F[SMQ$W_OPEN_JOB_COUNT] =
				.SMQ_F[SMQ$W_OPEN_JOB_COUNT] - 1;

			[2]:
			    SMQ_F[SMQ$W_TIMER_JOB_COUNT] =
				.SMQ_F[SMQ$W_TIMER_JOB_COUNT] - 1;

			[3]:
			    SMQ_F[SMQ$W_PENDING_JOB_COUNT] =
				.SMQ_F[SMQ$W_PENDING_JOB_COUNT] - 1;

			TES;
		    READ_RECORD(.SMQ_NF);
		    REWRITE_RECORD(.SMQ_NF);
		    END;


		! Unlink the job.
		!
		UPDATE_GETQUI_DATA(.SJH_N, .SJH);
		IF .SJH_P EQL 0
		THEN
		    BEGIN
		    SMQ[.LIST_OFFSET,0,32,0] = .SJH[SYM$L_LINK];
		    IF .SJH[SYM$L_LINK] EQL 0
			THEN SMQ[.LIST_OFFSET+4,0,32,0] = 0;
		    READ_RECORD(.SMQ_N);
		    REWRITE_RECORD(.SMQ_N);
		    IF .QID EQL 2
		    THEN
			BEGIN
			LOCAL
			    SJH_N2,			! Record number of next 
			    SJH_2:	REF BBLOCK,	! Pointer to next
			    STATUS;			! Status return

		 	$CANTIM(REQIDT=JBC$K_AFTER_IDT);
			IF .SJH[SYM$L_LINK] NEQ 0
			THEN
			    BEGIN
			    SJH_2 = READ_RECORD(SJH_N2 = .SJH[SYM$L_LINK]);
			    STATUS = $SETIMR(
				DAYTIM=SJH_2[SJH$Q_AFTER_TIME],
				ASTADR=AFTER_AST,
				REQIDT=JBC$K_AFTER_IDT);
			    IF NOT .STATUS
			    THEN
				SIGNAL(JBC$_SETIMR OR STS$K_ERROR, 0, .STATUS);
			    RELEASE_RECORD(.SJH_N2);
			    END;
			END;
		    END
		ELSE
		    BEGIN
		    SJH_P[SYM$L_LINK] = .SJH[SYM$L_LINK];
		    IF .SJH[SYM$L_LINK] EQL 0
		    THEN
			BEGIN
			SMQ[.LIST_OFFSET+4,0,32,0] = .SJH_NP;
			READ_RECORD(.SMQ_N);
			REWRITE_RECORD(.SMQ_N);
			END;
		    READ_RECORD(.SJH_NP);
		    REWRITE_RECORD(.SJH_NP);
		    END;
		END
	    ELSE
		BEGIN
		IF .SJH_NP NEQ .SMQ_N THEN RELEASE_RECORD(.SJH_NP);
		END;


	    IF NOT NULLPARAMETER(8)
	    THEN
		BEGIN
		CTX[0] = .LIST_OFFSET;
		CTX[1] = .QID;
		CTX[2] = .SQX_N;
		CTX[3] = .SQX;
		CTX[4] = .SQE_N;
		CTX[5] = .SMQ_N;
		CTX[6] = .SMQ;
		IF .REMOVING
		THEN
		    BEGIN
		    CTX[7] = .SJH_NP;
		    CTX[8] = .SJH_P;
		    END
		ELSE
		    BEGIN
		    CTX[7] = .SJH_N;
		    CTX[8] = .SJH;
		    END;
		END;


	    RETURN SS$_NORMAL;
	    END;


	IF .SJH_NP NEQ .SMQ_N THEN RELEASE_RECORD(.SJH_NP);
	SJH_NP = .SJH_N;
	SJH_P = .SJH;
	SJH_N = .SJH[SYM$L_LINK];
	END;


    ! Indicate no current queue.
    !
    IF .SJH_NP NEQ .SMQ_N THEN RELEASE_RECORD(.SJH_NP);
    LIST_OFFSET = 0;
    END;
0
END;

GLOBAL ROUTINE DEQUEUE_OPEN_JOB(SJH_N;SJH): L_OUTPUT_1=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine searches the open job queue for a specified job, and
!	dequeues the job.
!
! INPUT PARAMETERS:
!	SJH_N		- Record number of SJH record.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	SJH		- Pointer to SJH record.
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	TRUE		- Job found.
!	FALSE		- Job not found.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	SJH:		REF BBLOCK;	! Pointer to SJH
LOCAL
	SQH:		REF BBLOCK,	! Pointer to SQH
	SMQ_N,				! Record number of SMQ
	SMQ:		REF BBLOCK,	! Pointer to SMQ
	SJH_NP,				! Record number of predecessor of SJH
	SJH_P:		REF BBLOCK,	! Pointer to predecessor of SJH
	SJH_NT;				! Record number of SJH


SQH = READ_RECORD(SJH_NP = SQH$K_RECNO);
SJH_NT = .SQH[SQH$L_OPEN_LIST];
WHILE .SJH_NT NEQ 0 DO
    BEGIN
    SJH = READ_RECORD(.SJH_NT);
    IF .SJH_N EQL .SJH_NT
    THEN
	BEGIN
	IF .SJH_NP EQL SQH$K_RECNO
	THEN
	    BEGIN
	    SQH[SQH$L_OPEN_LIST] = .SJH[SYM$L_LINK];
	    IF .SJH[SYM$L_LINK] EQL 0 THEN SQH[SQH$L_OPEN_LIST_END] = 0;
	    REWRITE_RECORD(SQH$K_RECNO);
	    END
	ELSE
	    BEGIN
	    SJH_P[SYM$L_LINK] = .SJH[SYM$L_LINK];
	    IF .SJH[SYM$L_LINK] EQL 0 THEN SQH[SQH$L_OPEN_LIST_END] = .SJH_NP;
	    REWRITE_RECORD(.SJH_NP);
	    REWRITE_RECORD(SQH$K_RECNO);
	    END;
	SMQ_N = .SJH[SJH$L_QUEUE_LINK];
	IF .SMQ_N NEQ 0
	THEN
	    BEGIN
	    ! Queue pointer is OK, update queue record.
	    !
	    SMQ = READ_RECORD(.SMQ_N);
	    SMQ[SMQ$W_OPEN_JOB_COUNT] = .SMQ[SMQ$W_OPEN_JOB_COUNT] - 1;
	    REWRITE_RECORD(.SMQ_N);
	    END;
	RETURN TRUE;
	END;
    IF .SJH_NP NEQ SQH$K_RECNO THEN RELEASE_RECORD(.SJH_NP);
    SJH_NP = .SJH_NT;
    SJH_P = .SJH;
    SJH_NT = .SJH[SYM$L_LINK];
    END;
IF .SJH_NP NEQ SQH$K_RECNO THEN RELEASE_RECORD(.SJH_NP);
RELEASE_RECORD(SQH$K_RECNO);
FALSE
END;

GLOBAL ROUTINE ALLOCATE_ENTRY_NUMBER(P_ENTRY_NUMBER)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine allocates a new job entry number.
!
! INPUT PARAMETERS:
!	P_ENTRY_NUMBER	- Address of a longword to receive the entry number.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Completion status.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	SQH:		REF BBLOCK,	! Pointer to SQH
	SEB_N,				! Record number of bitmap extension
	SEB:		REF BBLOCK,	! Pointer to bitmap extension
	ENTRY_NUMBER,			! Trial entry number
	ENTRY_NUMBER_LIMIT,		! Limit for entry number loop
	BIT_NUMBER,			! Bit number within bitmap block
	BLOCK_NUMBER,			! Offset to bitmap extension block
	Q:		VECTOR[2],	! Temporary for EDIV
	STATUS;				! Status return


! Read the queue header.
!
SQH = READ_RECORD(SQH$K_RECNO);
SEB_N = 0;


! Search the portion of the bitmap from NEXT_ENTRY_NUMBER to the end and
! then the portion of the bitmap from the beginning to NEXT_ENTRY_NUMBER.
!
ENTRY_NUMBER = .SQH[SQH$L_NEXT_ENTRY_NUMBER];
ENTRY_NUMBER_LIMIT = .SQH[SQH$L_HIGHEST_ENTRY_NUMBER];
DECR I FROM 1 TO 0 DO
    BEGIN

    ! Search the specified portion of the bitmap.
    !
    WHILE .ENTRY_NUMBER LEQU .ENTRY_NUMBER_LIMIT DO
	BEGIN

	! Normalize the entry number to the bit number.
	!
	BIT_NUMBER = .ENTRY_NUMBER - 1;
	IF .BIT_NUMBER LSSU SQH$S_ENTRY_BITMAP * 8
	THEN
	    BEGIN

	    ! The bit is not in an extension record.  Try to allocate the
	    ! specified bit in the queue header.  If this succeeds, update
	    ! data structures and return success.
	    !
	    IF TESTBITCS(BITVECTOR[SQH[SQH$B_ENTRY_BITMAP], .BIT_NUMBER])
	    THEN
		BEGIN
		SQH[SQH$L_NEXT_ENTRY_NUMBER] = .ENTRY_NUMBER + 1;
		.P_ENTRY_NUMBER = .ENTRY_NUMBER;
		IF .SEB_N NEQ 0 THEN RELEASE_RECORD(.SEB_N);
		REWRITE_RECORD(SQH$K_RECNO);
		RETURN SS$_NORMAL;
		END;
	    END
	ELSE
	    BEGIN

	    ! The bit is in an extension record.  Determine the index within
	    ! the extension record vector, and the bit number within the
	    ! selected extension record.
	    !
	    Q[0] = .BIT_NUMBER - SQH$S_ENTRY_BITMAP * 8;
	    Q[1] = 0;
	    EDIV(%REF(SYM$S_DATA * 8), Q, BLOCK_NUMBER, BIT_NUMBER);


	    ! If the wrong extension record (or no extension record) is in
	    ! memory, read the required record.
	    !
	    IF .SEB_N NEQ .VECTOR[SQH[SQH$L_ENTRY_BITMAP_VECTOR], .BLOCK_NUMBER]
	    THEN
		BEGIN
		IF .SEB_N NEQ 0 THEN RELEASE_RECORD(.SEB_N);
		SEB_N = .VECTOR[SQH[SQH$L_ENTRY_BITMAP_VECTOR], .BLOCK_NUMBER];
		SEB = READ_RECORD(.SEB_N);
		END;


	    ! Try to allocate the specified bit in the extension record.  If
	    ! this succeeds, update data structures and return success.
	    !
	    IF TESTBITCS(BITVECTOR[SEB[SYM$T_DATA], .BIT_NUMBER])
	    THEN
		BEGIN
		SQH[SQH$L_NEXT_ENTRY_NUMBER] = .ENTRY_NUMBER + 1;
		.P_ENTRY_NUMBER = .ENTRY_NUMBER;
		REWRITE_RECORD(.SEB_N);
		REWRITE_RECORD(SQH$K_RECNO);
		RETURN SS$_NORMAL;
		END;
	    END;


	! Advance to the next entry number.
	!
	ENTRY_NUMBER = .ENTRY_NUMBER + 1;
	END;


    ! Set up to search the beginning of the bitmap.
    !
    ENTRY_NUMBER = 1;
    ENTRY_NUMBER_LIMIT = .SQH[SQH$L_NEXT_ENTRY_NUMBER] - 1;
    END;


! All bits were set in the existing blocks (extremely unlikely).  Determine the
! offset within the vector of a new block.
!
IF .SEB_N NEQ 0 THEN RELEASE_RECORD(.SEB_N);
BLOCK_NUMBER =
    (.SQH[SQH$L_HIGHEST_ENTRY_NUMBER] - SQH$S_ENTRY_BITMAP * 8) /
    (SYM$S_DATA * 8);


! If the computed offset is not within the allocated vector, the architectural
! maximum number of jobs has been reached; return "no space".
!
IF .BLOCK_NUMBER GEQU SQH$S_ENTRY_BITMAP_VECTOR/4
THEN
    BEGIN
    RELEASE_RECORD(SQH$K_RECNO);
    RETURN JBC$_NOQUESPACE;
    END;


! Allocate and initialize the new record.
!
STATUS = ALLOCATE_RECORD( ; SEB_N, SEB);
IF NOT .STATUS
THEN
    BEGIN
    RELEASE_RECORD(SQH$K_RECNO);
    RETURN JBC$_NOQUESPACE;
    END;
VECTOR[SQH[SQH$L_ENTRY_BITMAP_VECTOR], .BLOCK_NUMBER] = .SEB_N;
SEB[SYM$B_TYPE] = SYM$K_ENTRY_BITMAP;
BITVECTOR[SEB[SYM$T_DATA], 0] = TRUE;
REWRITE_RECORD(.SEB_N);


! Update data structures in the queue header to reflect the new block.
!
.P_ENTRY_NUMBER = .SQH[SQH$L_HIGHEST_ENTRY_NUMBER] + 1;
SQH[SQH$L_NEXT_ENTRY_NUMBER] = .SQH[SQH$L_HIGHEST_ENTRY_NUMBER] + 2;
SQH[SQH$L_HIGHEST_ENTRY_NUMBER] =
    .SQH[SQH$L_HIGHEST_ENTRY_NUMBER] + (SYM$S_DATA * 8);
REWRITE_RECORD(SQH$K_RECNO);
SS$_NORMAL
END;

GLOBAL ROUTINE DEALLOCATE_ENTRY_NUMBER(ENTRY_NUMBER): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine deallocates a job entry number.
!
! INPUT PARAMETERS:
!	ENTRY_NUMBER	- Entry number to be deallocated.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	SQH:		REF BBLOCK,	! Pointer to SQH
	BIT_NUMBER;			! Bit number within record


! Read the queue header.
!
SQH = READ_RECORD(SQH$K_RECNO);


! Ensure that the entry number is in range.
!
IF .ENTRY_NUMBER EQLU 0
OR .ENTRY_NUMBER GTRU .SQH[SQH$L_HIGHEST_ENTRY_NUMBER]
THEN
    RETURN;


! Determine if the bit is in the queue header or in an extension record,
! and process accordingly.
!
BIT_NUMBER = .ENTRY_NUMBER - 1;
IF .BIT_NUMBER LSSU SQH$S_ENTRY_BITMAP * 8
THEN
    BEGIN
    BITVECTOR[SQH[SQH$B_ENTRY_BITMAP], .BIT_NUMBER] = FALSE;
    REWRITE_RECORD(SQH$K_RECNO);
    END
ELSE
    BEGIN
    LOCAL
	BLOCK_NUMBER,			! Index to extension block
	Q:		VECTOR[2],	! Temporary for EDIV
	SEB_N,				! Record number of extension bitmap
	SEB:		REF BBLOCK;	! Pointer to extension bitmap


    Q[0] = .BIT_NUMBER - SQH$S_ENTRY_BITMAP * 8;
    Q[1] = 0;
    EDIV(%REF(SYM$S_DATA * 8), Q, BLOCK_NUMBER, BIT_NUMBER);
    IF .BLOCK_NUMBER LSSU SQH$S_ENTRY_BITMAP_VECTOR/4
    THEN
	BEGIN
	SEB_N = .VECTOR[SQH[SQH$L_ENTRY_BITMAP_VECTOR], .BLOCK_NUMBER];
	IF .SEB_N NEQ 0
	THEN
	    BEGIN
	    SEB = READ_RECORD(.SEB_N);
	    BITVECTOR[SEB[SYM$T_DATA], .BIT_NUMBER] = FALSE;
	    REWRITE_RECORD(.SEB_N);
	    END;
	END;
    RELEASE_RECORD(SQH$K_RECNO);
    END;
END;

GLOBAL ROUTINE JOB_STATUS_MESSAGE(RESULT,MSG_BUFFER,SMQ,SJH,ESMQ)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine formats a job status message.
!
! INPUT PARAMETERS:
!	RESULT		- Result of the enqueue.
!	MSG_BUFFER	- Pointer to message buffer.
!	SMQ		- Pointer to SMQ.
!	SJH		- Pointer to SJH.
!	ESMQ		- Pointer to executor SMQ, if job is executing.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Message length.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	MSG_BUFFER:	REF VECTOR[,BYTE],	! Pointer to message buffer
	SJH:		REF BBLOCK,		! Pointer to SJH
	SMQ:		REF BBLOCK,		! Pointer to SMQ
	ESMQ:		REF BBLOCK;		! Pointer to SMQ
LOCAL
	GET_DESC:	VECTOR[2],		! Descriptor for $GETMSG buffer
	MSG_DESC:	VECTOR[2],		! Descriptor for message buffer
	LENGTH:		WORD,			! Length of message
	PRMLST:		VECTOR[4],		! $FAOL parameters
	GET_BUFFER:	VECTOR[80,BYTE];	! $GETMSG buffer
OWN
	MESSAGES:	VECTOR[5] PSECT(CODE) PRESET(
	    [ENQ_K_CURRENT] =	JBC$_NFY_CURRENT,
	    [ENQ_K_HOLD] =	JBC$_NFY_HOLD,
	    [ENQ_K_PENDING] =	JBC$_NFY_PENDING,
	    [ENQ_K_TIMER] =	JBC$_NFY_TIMER,
	    [ENQ_K_COMPLETE] =	JBC$_NFY_COMPLETE);
LITERAL
	MSG_LENGTH=	160;


! Get the message to be formatted.
!
GET_DESC[0] = %ALLOCATION(GET_BUFFER);
GET_DESC[1] = GET_BUFFER;
IF NOT $GETMSG(
    MSGID=.MESSAGES[.RESULT],
    MSGLEN=GET_DESC,
    BUFADR=GET_DESC,
    FLAGS=%B'0001')
THEN
    RETURN 0;


! Set up the proper FAO parameters.
!
PRMLST[0] = SJH[SJH$T_NAME];
PRMLST[1] = SMQ[SMQ$T_NAME];
PRMLST[2] = .SJH[SYM$L_ENTRY_NUMBER];
IF .RESULT EQL ENQ_K_CURRENT THEN PRMLST[3] = ESMQ[SMQ$T_NAME];
IF .RESULT EQL ENQ_K_TIMER THEN PRMLST[3]= SJH[SJH$Q_AFTER_TIME];


! Format the message.
!
MSG_DESC[0] = MSG_LENGTH;
MSG_DESC[1] = .MSG_BUFFER;
$FAOL(
    CTRSTR=GET_DESC,
    OUTLEN=MSG_DESC,
    OUTBUF=MSG_DESC,
    PRMLST=PRMLST);


IF .RESULT EQL ENQ_K_COMPLETE
AND .SJH[SJH$L_CONDITION_1] NEQ 0 AND NOT .SJH[SJH$L_CONDITION_1]
THEN
    BEGIN

    ! Append CR-LF to the buffer, and update the descriptor to describe the
    ! remaining portion of the buffer.
    !
    MSG_DESC[1] = .MSG_DESC[1] + .MSG_DESC[0];
    (.MSG_DESC[1])<0,16> = %CHAR(%O'015', %O'012');
    MSG_DESC[1] = .MSG_DESC[1] + 2;
    MSG_DESC[0] = MSG_LENGTH - .MSG_DESC[0] - 2;


    ! Get the message corresponding to the completion status.
    !
    $GETMSG(
	MSGID=.SJH[SJH$L_CONDITION_1],
	MSGLEN=LENGTH,
	BUFADR=MSG_DESC,
	FLAGS=%B'1111');


    ! Update the descriptor to describe the entire message.
    !
    MSG_DESC[0] = MSG_LENGTH - .MSG_DESC[0] + .LENGTH;
    END;


.MSG_DESC[0]
END;

ROUTINE NOTIFY_USER(RESULT,SMQ,SJH,ESMQ): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine notifies a user via broadcast of the status of a job.
!
! INPUT PARAMETERS:
!	RESULT		- Result of the enqueue.
!	SMQ		- Pointer to SMQ.
!	SJH		- Pointer to SJH.
!	ESMQ		- Pointer to executor SMQ, if job is executing.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	Messages broadcast to terminals.
!
!--

BEGIN
MAP
	SJH:		REF BBLOCK,		! Pointer to SJH
	SMQ:		REF BBLOCK,		! Pointer to SMQ
	ESMQ:		REF BBLOCK;		! Pointer to SMQ
LOCAL
	LENGTH,					! Length of message
	MSG_BUFFER:	VECTOR[SRQ$S_BRDCST_TEXT,BYTE]; ! Message buffer


! Fill in a CR-LF and two bells ahead of the message, and get the formatted
! message.
!
MSG_BUFFER = %CHAR(%O'015', %O'012', %O'007', %O'007');
LENGTH = 4 + JOB_STATUS_MESSAGE(.RESULT, MSG_BUFFER + 4, .SMQ, .SJH, .ESMQ);


! Issue the broadcast message.
!
BROADCAST_MESSAGE(
    SJH[SJH$T_SYSID],
    SJH[SJH$T_USERNAME],
    .LENGTH, MSG_BUFFER);
END;

GLOBAL ROUTINE COMPLETE_JOB(SJH_N,SJH,SMQ,ACM,STS): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine completes a job.
!
! INPUT PARAMETERS:
!	SJH_N		- Record number of SJH.
!	SJH		- Pointer to SJH.
!	SMQ		- Pointer to SMQ.
!	ACM		- Pointer to ACM or 0.
!	STS		- (Optional) Forced completion status.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	SJH:		REF BBLOCK,	! Pointer to SJH
	SMQ:		REF BBLOCK,	! Pointer to SMQ
	ACM:		REF BBLOCK;	! Pointer to ACM
BUILTIN
	ACTUALCOUNT;


! First, check to see that the SJH is valid by verifying the QUEUE_LINK is
! non-zero.  Invalid SJHs can only occur in a corrupted file.  An invalid
! SJH is generally a record that has been deallocated to the free list but
! still may appear in the SMQ's current list.
!
IF .SJH[SJH$L_QUEUE_LINK] EQL 0 THEN RETURN;

! Propagate the process termination status to the SJH record.
!
IF .SJH[SJH$L_CONDITION_1] EQL 0 AND .ACM NEQ 0
THEN
    BEGIN
    SJH[SJH$L_CONDITION_1] = .ACM[ACM$L_FINALSTS];
    SJH[SJH$L_CONDITION_2] = 0;
    SJH[SJH$L_CONDITION_3] = 0;
    END;


! Propagate the forced abort, requeue, or delete status, if specified.
!
IF .SJH[SJH$V_DELETED]
THEN
    BEGIN
    SJH[SJH$L_CONDITION_1] = JBC$_JOBDELETE OR STS$K_ERROR;
    SJH[SJH$L_CONDITION_2] = 0;
    SJH[SJH$L_CONDITION_3] = 0;
    END

ELSE IF .SJH[SJH$V_ABORTED]
THEN
    BEGIN
    IF .SJH[SJH$V_REQUEUE]
	THEN SJH[SJH$L_CONDITION_1] = JBC$_JOBREQUEUE OR STS$K_ERROR
	ELSE SJH[SJH$L_CONDITION_1] = JBC$_JOBABORT OR STS$K_ERROR;
    SJH[SJH$L_CONDITION_2] = 0;
    SJH[SJH$L_CONDITION_3] = 0;
    END;


! Propagate the forced completion status, if specified.
!
IF ACTUALCOUNT() GEQU 5
THEN
    BEGIN
    SJH[SJH$L_CONDITION_1] = .STS;
    SJH[SJH$L_CONDITION_2] = 0;
    SJH[SJH$L_CONDITION_3] = 0;
    END;


! Write an accounting record for the job except if it was not executing
! at the time of a system failure, or it has been retained.
!
IF (NOT .SJH[SJH$V_SYSTEM_FAILURE] OR .SJH[SJH$V_EXECUTING])
AND NOT .SJH[SJH$V_RETAINED]
THEN
    WRITE_ACCOUNTING_RECORD(.SJH, .SMQ, .ACM);


! Delete jobs from the completed queue without going through NOTIFY and
! SYNCHRONIZE processing.
!
IF .SJH[SJH$V_DELETED]
AND .SJH[SJH$V_RETAINED]
THEN
    DELETE_SJH_RECORD(.SJH_N, .SJH)


! Requeue the job if required.
!
ELSE IF .SJH[SJH$V_SYSTEM_FAILURE]
    AND (NOT .SJH[SJH$V_EXECUTING] OR .SJH[SJH$V_RESTART])
OR .SJH[SJH$V_REQUEUE]
OR .SJH[SJH$V_RETAINED]
THEN
    BEGIN
    SJH[SJH$L_CURRENT_FILE_LINK] = 0;
    ENQUEUE_JOB(.SJH_N, .SJH);
    REWRITE_RECORD(.SJH_N);
    END


! Complete the job with NOTIFY and SYNCHRONIZE processing, and then delete or
! retain the job according to the /RETAIN specification.
!
ELSE
    BEGIN
    LOCAL
	QSMQ_N,				! Record number of job's SMQ
	QSMQ:		REF BBLOCK;	! Pointer to job's SMQ


    ! If the /NOTIFY qualifier was given, send the completion notification to
    ! the user.
    !
    IF .SJH[SJH$V_NOTIFY]
    THEN
	NOTIFY_USER(ENQ_K_COMPLETE, .SMQ, .SJH, 0);


    ! If there are SYNCHRONIZE commands pending for this job, send the response
    ! messages.
    !
    IF .SJH[SJH$V_SYNCHRONIZE]
    THEN
	SCAN_INCOMPLETE_SERVICES(
	    ISRV_K_SYNCHRONIZE,
	    .SJH_N,
	    .SJH[SJH$L_CONDITION_1]);


    ! Read the job's queue record.
    !
    QSMQ = READ_RECORD(QSMQ_N = .SJH[SJH$L_QUEUE_LINK]);


    ! If the job is to be retained, do so; otherwise delete it.
    !
    IF NOT .SJH[SJH$V_DELETED]
    AND (.QSMQ[SMQ$V_RETAIN_ALL_JOBS]
	OR (.QSMQ[SMQ$V_RETAIN_ERROR_JOBS] AND NOT .SJH[SJH$L_CONDITION_1]))
    THEN
	BEGIN
	SJH[SJH$L_COMPLETED_BLOCKS] = 0;
	SJH[SJH$L_CURRENT_FILE_CHKPT] = 0;
	SJH[SJH$B_JOB_COPIES_CHKPT] = 0;
	SJH[SJH$B_FILE_COPIES_CHKPT] = 0;
	DEALLOCATE_VARIABLE_DATA(
	    SJH$S_CHECKPOINT,
	    SJH[SJH$T_CHECKPOINT]);
	SJH[SJH$L_CURRENT_FILE_LINK] = 0;
	SJH[SJH$V_RETAINED] = TRUE;
	ENQUEUE_JOB(.SJH_N, .SJH);
	REWRITE_RECORD(.SJH_N);
	END
    ELSE
	DELETE_SJH_RECORD(.SJH_N, .SJH);


    RELEASE_RECORD(.QSMQ_N);
    END;
END;

GLOBAL ROUTINE VALIDATE_OBJECT_NAME(LENGTH,ADDRESS,DESC)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine validates a characteristic, form, or queue name.
!
! INPUT PARAMETERS:
!	LENGTH		- Descriptor for ASCII name.
!	ADDRESS		-
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	DESC		- Short descriptor for converted name.
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	True if the parameter is a valid name, false otherwise.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	ADDRESS:	REF VECTOR[,BYTE],	! Pointer to ASCIC queue name
	DESC:		REF BBLOCK;		! Pointer to short descriptor


! Ensure that the length is valid.
!
IF .LENGTH EQL 0 OR .LENGTH GTRU 31
THEN
    RETURN FALSE;


! Initialize the descriptor.
!
DESC[SDSC_W_LENGTH] = .LENGTH;
DESC[SDSC_A_POINTER] = .ADDRESS;


! Loop through all characters of the name checking for validity.  Convert
! lowercase to uppercase in place, and remove a trailing colon if one exists.
!
INCR I FROM 0 TO .LENGTH-1 DO
    BEGIN
    LOCAL
	C:	BYTE;

    C = .ADDRESS[.I];
    SELECTONE .C OF
	SET
	[%C'A' TO %C'Z', %C'0' TO %C'9', %C'$', %C'_']:
	    0;
	[%C'a' TO %C'z']:
	    ADDRESS[.I] = .ADDRESS[.I] - %C'a' + %C'A';	    
	[%C':']:
	    IF .I EQL .LENGTH-1
		THEN DESC[SDSC_W_LENGTH] = .DESC[SDSC_W_LENGTH] - 1
		ELSE RETURN FALSE;
	[OTHERWISE]:
	    RETURN FALSE;
	TES;
    END;


TRUE
END;

GLOBAL ROUTINE FIND_CHARACTERISTIC(DESC;NUMBER): L_OUTPUT_1=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine looks up a characteristic name.
!
! INPUT PARAMETERS:
!	DESC		- Short descriptor for characteristic name.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NUMBER		- Numeric equivalent of the characteristic name.
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	True if the characteristic is defined, false otherwise.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	DESC:		REF BBLOCK;	! Short descriptor for name
LOCAL
	SCX:		REF BBLOCK,	! Pointer to SCX
	SCX_N,				! Record number of SCX
	SCX_NS,				! Record number of successor of SCX
	SCE:		REF BBLOCK;	! Pointer to SCX entry


! Search the characteristic index for the desired name.
!
SCX = READ_RECORD(SQH$K_RECNO);
SCX_N = .SCX[SQH$L_CHARACTERISTIC_LIST];
RELEASE_RECORD(SQH$K_RECNO);
WHILE .SCX_N NEQ 0 DO
    BEGIN

    ! Read the characteristic index record.
    !
    SCX = READ_RECORD(.SCX_N);


    ! Search the characteristic index for the desired name.
    !
    SCE = SCX[SYM$T_DATA];
    INCR SCE_N FROM 0 TO SCX$K_ENTRIES-1 DO
	BEGIN
	IF CH$RCHAR(SCE[SCX$T_NAME]) EQL 0
	THEN
	    EXITLOOP
	ELSE
	    BEGIN
	    CASE CH$COMPARE(
		CH$RCHAR(SCE[SCX$T_NAME]), SCE[SCX$T_NAME]+1,
		.DESC[SDSC_W_LENGTH], .DESC[SDSC_A_POINTER],
		%C' ')
	    FROM -1 TO 1 OF
		SET

		[-1]:
		    SCE = .SCE + SCX$S_SCX;

		[0]:
		    BEGIN
		    NUMBER = .SCE[SCX$B_NUMBER];
		    RELEASE_RECORD(.SCX_N);
		    RETURN TRUE;
		    END;

		[+1]:
		    BEGIN
		    RELEASE_RECORD(.SCX_N);
		    RETURN FALSE;
		    END;

		TES;
	    END;
	END;


    ! Advance to the next index block.
    !
    SCX_NS = .SCX[SYM$L_LINK];
    RELEASE_RECORD(.SCX_N);
    SCX_N = .SCX_NS;
    END;


FALSE
END;

GLOBAL ROUTINE FIND_FORM_NAME(DESC;SFM_N,SFM): L_OUTPUT_2=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine finds a form definition by name.
!
! INPUT PARAMETERS:
!	DESC		- Short descriptor for form name.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	SFM_N		- Record number of SFM.
!	SFM		- Pointer to SFM.
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	True if the form is defined, false otherwise.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	DESC:		REF BBLOCK,	! Short descriptor for form name
	SFM:		REF BBLOCK;	! Pointer to SFM
LOCAL
	SFX:		REF BBLOCK,	! Pointer to SFX
	SFX_N,				! Record number of SFX
	SFX_NS,				! Record number of successor of SFX
	SFE:		REF BBLOCK;	! Pointer to SFX entry


! Search the form index for the desired name.
!
SFX = READ_RECORD(SQH$K_RECNO);
SFX_N = .SFX[SQH$L_FORM_INDEX_LIST];
RELEASE_RECORD(SQH$K_RECNO);
WHILE .SFX_N NEQ 0 DO
    BEGIN

    ! Read the form index record.
    !
    SFX = READ_RECORD(.SFX_N);


    ! Search the form index for the desired name.
    !
    SFE = SFX[SYM$T_DATA];
    INCR SFE_N FROM 0 TO SFX$K_ENTRIES-1 DO
	BEGIN
	IF CH$RCHAR(SFE[SFX$T_NAME]) EQL 0
	THEN
	    EXITLOOP
	ELSE
	    BEGIN
	    CASE CH$COMPARE(
		CH$RCHAR(SFE[SFX$T_NAME]), SFE[SFX$T_NAME]+1,
		.DESC[SDSC_W_LENGTH], .DESC[SDSC_A_POINTER],
		%C' ')
	    FROM -1 TO 1 OF
		SET

		[-1]:
		    SFE = .SFE + SFX$S_SFX;

		[0]:
		    BEGIN
		    SFM = READ_RECORD(SFM_N = .SFE[SFX$L_FORM_LINK]);
		    RELEASE_RECORD(.SFX_N);
		    RETURN TRUE;
		    END;

		[+1]:
		    BEGIN
		    RELEASE_RECORD(.SFX_N);
		    RETURN FALSE;
		    END;

		TES;
	    END;
	END;


    ! Advance to the next index block.
    !
    SFX_NS = .SFX[SYM$L_LINK];
    RELEASE_RECORD(.SFX_N);
    SFX_N = .SFX_NS;
    END;


FALSE
END;

GLOBAL ROUTINE FIND_FORM_NUMBER(NUMBER;SFM_N,SFM): L_OUTPUT_2=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine finds a form definition by number.
!
! INPUT PARAMETERS:
!	NUMBER		- Form number.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	SFM_N		- Record number of SFM.
!	SFM		- Pointer to SFM.
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	True if the form is defined, false otherwise.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	SFM:		REF BBLOCK;	! Pointer to SFM
LOCAL
	SFX:		REF BBLOCK,	! Pointer to SFX
	SFX_N,				! Record number of SFX
	SFX_NS,				! Record number of successor of SFX
	SFE:		REF BBLOCK;	! Pointer to SFX entry


! Search the form index for the desired number.
!
SFX = READ_RECORD(SQH$K_RECNO);
SFX_N = .SFX[SQH$L_FORM_INDEX_LIST];
RELEASE_RECORD(SQH$K_RECNO);
WHILE .SFX_N NEQ 0 DO
    BEGIN

    ! Read the form index record.
    !
    SFX = READ_RECORD(.SFX_N);


    ! Search the form index for the desired number.
    !
    SFE = SFX[SYM$T_DATA];
    INCR SFE_N FROM 0 TO SFX$K_ENTRIES-1 DO
	BEGIN
	IF CH$RCHAR(SFE[SFX$T_NAME]) EQL 0
	THEN
	    EXITLOOP
	ELSE
	    IF .NUMBER EQL .SFE[SFX$L_NUMBER]
	    THEN
		BEGIN
		SFM = READ_RECORD(SFM_N = .SFE[SFX$L_FORM_LINK]);
		RELEASE_RECORD(.SFX_N);
		RETURN TRUE;
		END
	    ELSE
		SFE = .SFE + SFX$S_SFX;
	END;


    ! Advance to the next index block.
    !
    SFX_NS = .SFX[SYM$L_LINK];
    RELEASE_RECORD(.SFX_N);
    SFX_N = .SFX_NS;
    END;


FALSE
END;

ROUTINE FIND_FORM_REFERENCES_J(SFM_NF,SJH_N0)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine finds references to a specified form in a list of jobs.
!
! INPUT PARAMETERS:
!	SFM_NF		- Record number of SFM.
!	SJH_N0		- Record number of SJH.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	True if any references were found, false otherwise.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	SJH_NS,				! Record number of successor of SJH
	SJH_N,				! Record number of SJH
	SJH:		REF BBLOCK;	! Pointer to SJH


SJH_N = .SJH_N0;
WHILE .SJH_N NEQ 0 DO
    BEGIN
    SJH = READ_RECORD(.SJH_N);


    IF .SJH[SJH$L_FORM_LINK] EQL .SFM_NF
    THEN
	BEGIN
	RELEASE_RECORD(.SJH_N);
	RETURN TRUE;
	END;


    SJH_NS = .SJH[SYM$L_LINK];
    RELEASE_RECORD(.SJH_N);
    SJH_N = .SJH_NS;
    END;


FALSE
END;

GLOBAL ROUTINE FIND_FORM_REFERENCES(SFM_NF)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine finds references to a specified form anywhere in the queue.
!
! INPUT PARAMETERS:
!	SFM_NF		- Record number of SFM.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	SQH:		REF BBLOCK,	! Pointer to SQH
	SQX:		REF BBLOCK,	! Pointer to SQX
	SQX_N,				! Record number of SQX
	SQX_NS,				! Record number of successor of SQX
	SQE:		REF BBLOCK,	! Pointer to SQX entry
	SMQ_N,				! Record number of SMQ
	SMQ:		REF BBLOCK;	! Pointer to SMQ


! Read the queue header.
!
SQH = READ_RECORD(SQH$K_RECNO);


! Search for form references in each job list linked from the queue header.
!
IF FIND_FORM_REFERENCES_J(.SFM_NF, .SQH[SQH$L_OPEN_LIST])
OR FIND_FORM_REFERENCES_J(.SFM_NF, .SQH[SQH$L_PENDING_BATCH_LIST])
OR FIND_FORM_REFERENCES_J(.SFM_NF, .SQH[SQH$L_PENDING_PRINT_LIST])
OR FIND_FORM_REFERENCES_J(.SFM_NF, .SQH[SQH$L_TIMER_LIST])
THEN
    BEGIN
    RELEASE_RECORD(SQH$K_RECNO);
    RETURN TRUE;
    END;


! Loop over all queue headers.
!
SQX_N = .SQH[SQH$L_QUEUE_INDEX_LIST];
RELEASE_RECORD(SQH$K_RECNO);
WHILE .SQX_N NEQ 0 DO
    BEGIN

    ! Read the queue index record.
    !
    SQX = READ_RECORD(.SQX_N);


    ! Search the queue index.
    !
    SQE = SQX[SYM$T_DATA];
    INCR SQE_N FROM 0 TO SQX$K_ENTRIES-1 DO
	BEGIN
	IF CH$RCHAR(SQE[SQX$T_NAME]) EQL 0
	THEN
	    EXITLOOP
	ELSE
	    BEGIN

	    ! Read the queue header.
	    !
	    SMQ = READ_RECORD(SMQ_N = .SQE[SQX$L_QUEUE_LINK]);


	    ! Search for form references in the queue header and in each job
	    ! list linked from the queue header.
	    !
	    IF .SMQ[SMQ$L_FORM_LINK] EQL .SFM_NF
	    OR FIND_FORM_REFERENCES_J(.SFM_NF, .SMQ[SMQ$L_CURRENT_LIST])
	    OR FIND_FORM_REFERENCES_J(.SFM_NF, .SMQ[SMQ$L_HOLD_LIST])
	    THEN
		BEGIN
		RELEASE_RECORD(.SMQ_N);
		RELEASE_RECORD(.SQX_N);
		RETURN TRUE;
		END;


	    ! Release the queue header.
	    !
	    RELEASE_RECORD(.SMQ_N);
	    END;


	SQE = .SQE + SQX$S_SQX;
	END;


    ! Advance to the next index block.
    !
    SQX_NS = .SQX[SYM$L_LINK];
    RELEASE_RECORD(.SQX_N);
    SQX_N = .SQX_NS;
    END;


FALSE
END;

ROUTINE FIND_QUEUE_REFERENCES_J(SMQ_NF,SJH_N0)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine finds references to a specified queue in a list of jobs.
!
! INPUT PARAMETERS:
!	SMQ_NF		- Record number of SMQ.
!	SJH_N0		- Record number of SJH.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	True if any references were found, false otherwise.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	SJH_NS,				! Record number of successor of SJH
	SJH_N,				! Record number of SJH
	SJH:		REF BBLOCK;	! Pointer to SJH


SJH_N = .SJH_N0;
WHILE .SJH_N NEQ 0 DO
    BEGIN
    SJH = READ_RECORD(.SJH_N);


    IF .SJH[SJH$L_LOG_QUEUE_LINK] EQL .SMQ_NF
    OR .SJH[SJH$L_QUEUE_LINK] EQL .SMQ_NF
    OR .SJH[SJH$L_REQUEUE_QUEUE_LINK] EQL .SMQ_NF
    THEN
	BEGIN
	RELEASE_RECORD(.SJH_N);
	RETURN TRUE;
	END;


    SJH_NS = .SJH[SYM$L_LINK];
    RELEASE_RECORD(.SJH_N);
    SJH_N = .SJH_NS;
    END;


FALSE
END;

GLOBAL ROUTINE FIND_QUEUE_REFERENCES(SMQ_NF)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine finds references to a specified queue anywhere in the
!	queue.
!
! INPUT PARAMETERS:
!	SMQ_NF		- Record number of SMQ.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	SQH:		REF BBLOCK,	! Pointer to SQH
	SQX:		REF BBLOCK,	! Pointer to SQX
	SQX_N,				! Record number of SQX
	SQX_NS,				! Record number of successor of SQX
	SQE:		REF BBLOCK,	! Pointer to SQX entry
	SMQ_N,				! Record number of SMQ
	SMQ:		REF BBLOCK;	! Pointer to SMQ


! Read the queue header.
!
SQH = READ_RECORD(SQH$K_RECNO);


! Search for queue references in each job list linked from the queue header.
!
IF FIND_QUEUE_REFERENCES_J(.SMQ_NF, .SQH[SQH$L_OPEN_LIST])
OR FIND_QUEUE_REFERENCES_J(.SMQ_NF, .SQH[SQH$L_PENDING_BATCH_LIST])
OR FIND_QUEUE_REFERENCES_J(.SMQ_NF, .SQH[SQH$L_PENDING_PRINT_LIST])
OR FIND_QUEUE_REFERENCES_J(.SMQ_NF, .SQH[SQH$L_TIMER_LIST])
THEN
    BEGIN
    RELEASE_RECORD(SQH$K_RECNO);
    RETURN TRUE;
    END;


! Loop over all queue headers.
!
SQX_N = .SQH[SQH$L_QUEUE_INDEX_LIST];
RELEASE_RECORD(SQH$K_RECNO);
WHILE .SQX_N NEQ 0 DO
    BEGIN

    ! Read the queue index record.
    !
    SQX = READ_RECORD(.SQX_N);


    ! Search the queue index.
    !
    SQE = SQX[SYM$T_DATA];
    INCR SQE_N FROM 0 TO SQX$K_ENTRIES-1 DO
	BEGIN
	IF CH$RCHAR(SQE[SQX$T_NAME]) EQL 0
	THEN
	    EXITLOOP
	ELSE
	    BEGIN

	    ! Read the queue header.
	    !
	    SMQ = READ_RECORD(SMQ_N = .SQE[SQX$L_QUEUE_LINK]);


	    ! Search for queue references in the queue header and in each job
	    ! list linked from the queue header.
	    !
	    IF .SMQ[SMQ$L_ASSIGNED_QUEUE_LINK] EQL .SMQ_NF
	    OR FIND_QUEUE_REFERENCES_J(.SMQ_NF, .SMQ[SMQ$L_CURRENT_LIST])
	    OR FIND_QUEUE_REFERENCES_J(.SMQ_NF, .SMQ[SMQ$L_HOLD_LIST])
	    THEN
		BEGIN
		RELEASE_RECORD(.SMQ_N);
		RELEASE_RECORD(.SQX_N);
		RETURN TRUE;
		END;


	    ! Search for generic target references to the queue.
	    !
	    IF .SMQ[SMQ$L_GENERIC_TARGET] NEQ 0
	    THEN
		BEGIN
		LOCAL
		    AUX_N,			! Number of auxiliary record
		    AUX:	REF BBLOCK;	! Pointer to auxiliary record

		AUX = READ_RECORD(AUX_N = .SMQ[SMQ$L_GENERIC_TARGET]);
		DECR N FROM .VECTOR[AUX[SYM$T_DATA], 0] TO 1 DO
		    BEGIN
		    IF .VECTOR[AUX[SYM$T_DATA], .N] EQL .SMQ_NF
		    THEN
			BEGIN
			RELEASE_RECORD(.AUX_N);
			RELEASE_RECORD(.SMQ_N);
			RELEASE_RECORD(.SQX_N);
			RETURN TRUE;
			END;
		    END;
		RELEASE_RECORD(.AUX_N);
		END;


	    ! Release the queue header.
	    !
	    RELEASE_RECORD(.SMQ_N);
	    END;


	SQE = .SQE + SQX$S_SQX;
	END;


    ! Advance to the next index block.
    !
    SQX_NS = .SQX[SYM$L_LINK];
    RELEASE_RECORD(.SQX_N);
    SQX_N = .SQX_NS;
    END;


FALSE
END;

GLOBAL ROUTINE FIND_QUEUE(DESC;SQX_N,SQE,SMQ_N,SMQ): L_OUTPUT_4=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine finds a queue header.
!
! INPUT PARAMETERS:
!	DESC		- Short descriptor for queue name.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	SQX_N		- Record number of SQX.
!	SQE		- Pointer to SQX entry.
!	SMQ_N		- Record number of SMQ.
!	SMQ		- Pointer to SMQ.
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	True if the queue exists, false otherwise.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	DESC:		REF BBLOCK,	! Short descriptor for queue name
	SQE:		REF BBLOCK,	! Pointer to SQX entry
	SMQ:		REF BBLOCK;	! Pointer to SMQ
LOCAL
	SQX:		REF BBLOCK,	! Pointer to SQX
	SQX_NS;				! Record number of successor of SQX


! Search the queue index for the desired name.
!
SQX = READ_RECORD(SQH$K_RECNO);
SQX_N = .SQX[SQH$L_QUEUE_INDEX_LIST];
RELEASE_RECORD(SQH$K_RECNO);
WHILE .SQX_N NEQ 0 DO
    BEGIN

    ! Read the queue index record.
    !
    SQX = READ_RECORD(.SQX_N);


    ! Search the queue index for the desired name.
    !
    SQE = SQX[SYM$T_DATA];
    INCR SQE_N FROM 0 TO SQX$K_ENTRIES-1 DO
	BEGIN
	IF CH$RCHAR(SQE[SQX$T_NAME]) EQL 0
	THEN
	    EXITLOOP
	ELSE
	    BEGIN
	    CASE CH$COMPARE(
		CH$RCHAR(SQE[SQX$T_NAME]), SQE[SQX$T_NAME]+1,
		.DESC[SDSC_W_LENGTH], .DESC[SDSC_A_POINTER],
		%C' ')
	    FROM -1 TO 1 OF
		SET

		[-1]:
		    SQE = .SQE + SQX$S_SQX;

		[0]:
		    BEGIN
		    SMQ = READ_RECORD(SMQ_N = .SQE[SQX$L_QUEUE_LINK]);
		    RETURN TRUE;
		    END;

		[+1]:
		    BEGIN
		    RELEASE_RECORD(.SQX_N);
		    RETURN FALSE;
		    END;

		TES;
	    END;
	END;


    ! Advance to the next index block.
    !
    SQX_NS = .SQX[SYM$L_LINK];
    RELEASE_RECORD(.SQX_N);
    SQX_N = .SQX_NS;
    END;


FALSE
END;

GLOBAL ROUTINE DEALLOCATE_VARIABLE_DATA(FIELD_SIZE,FIELD_ADDRESS): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine deallocates extension records linked to a fixed/variable
!	data field, if they exist.
!
! INPUT PARAMETERS:
!	FIELD_SIZE	- Size of the fixed data field.
!	FIELD_ADDRESS	- Address within the record of the fixed data field.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	FIELD_ADDRESS:	REF BBLOCK;	! Pointer to fixed/variable buffer


IF .FIELD_ADDRESS[FVDF_LENGTH] GTRU .FIELD_SIZE - 2
THEN
    DEALLOCATE_RECORD_LIST(.FIELD_ADDRESS[FVDF_LINK]);


CH$FILL(0, .FIELD_SIZE, .FIELD_ADDRESS);
END;

GLOBAL ROUTINE FETCH_VARIABLE_ITEM(FIELD_SIZE,FIELD_ADDRESS,ITEM_CODE,ITEM_BUFFER)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine fetches an item from a fixed/variable data field.
!
! INPUT PARAMETERS:
!	FIELD_SIZE	- Size of the fixed data field.
!	FIELD_ADDRESS	- Address within the record of the fixed data field.
!	ITEM_CODE	- Type code for the item.
!	ITEM_BUFFER	- Pointer to the item buffer.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Updated pointer to the item buffer.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	FIELD_ADDRESS:	REF BBLOCK;	! Pointer to fixed/variable buffer
LOCAL
	ITEM:		REF BBLOCK;	! Cursor for item buffer


ITEM = .ITEM_BUFFER;
IF .FIELD_ADDRESS[FVDF_LENGTH] NEQ 0
THEN
    BEGIN
    ITEM[0,0,16,0] = .FIELD_ADDRESS[FVDF_LENGTH];
    ITEM[2,0,16,0] = .ITEM_CODE;
    ITEM = .ITEM + 4;
    IF .FIELD_ADDRESS[FVDF_LENGTH] LEQU .FIELD_SIZE - 2
    THEN
	BEGIN
	MOVC3(
	    FIELD_ADDRESS[FVDF_LENGTH],
	    FIELD_ADDRESS[FVDF_DATA],
	    .ITEM; ,,, ITEM);
	END
    ELSE
	BEGIN
	LOCAL
	    AUX_N,			! Record number of auxiliary record
	    INPUT_LENGTH;		! Remaining input data


	! Initialize.
	!
	INPUT_LENGTH = .FIELD_ADDRESS[FVDF_LENGTH];
	AUX_N = .FIELD_ADDRESS[FVDF_LINK];


	! Loop over all auxiliary information records.
	!
	WHILE .AUX_N NEQ 0 DO
	    BEGIN
	    LOCAL
		AUX_NS,			! Record number of successor of AUX
		AUX:	REF BBLOCK,	! Pointer to auxiliary record
		THIS_LENGTH;		! Length of current transfer


	    AUX = READ_RECORD(.AUX_N);
	    THIS_LENGTH = MINU(.INPUT_LENGTH, SYM$S_DATA);
	    MOVC3(INPUT_LENGTH, AUX[SYM$T_DATA], .ITEM; ,,, ITEM);
	    INPUT_LENGTH = .INPUT_LENGTH - .THIS_LENGTH;
	    AUX_NS = .AUX[SYM$L_LINK];
	    RELEASE_RECORD(.AUX_N);
	    AUX_N = .AUX_NS;
	    END;
	END;
    END;
.ITEM
END;

GLOBAL ROUTINE FETCH_VARIABLE_ITEM_LIST(FIELD_SIZE,FIELD_ADDRESS,ITEM_CODE,ITEM_BUFFER)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine fetches a sequence of items from a fixed/variable data
!	field.
!
! INPUT PARAMETERS:
!	FIELD_SIZE	- Size of the fixed data field.
!	FIELD_ADDRESS	- Address within the record of the fixed data field.
!	ITEM_CODE	- Type code for the first item, incrementing by 1.
!	ITEM_BUFFER	- Pointer to the item buffer.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Updated pointer to the item buffer.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	FIELD_ADDRESS:	REF BBLOCK;
LOCAL
	ITEM:		REF BBLOCK,
	A:		REF BBLOCK,
	E,
	I,
	BUFFER:		BBLOCK[1024];


ITEM = .ITEM_BUFFER;
FETCH_VARIABLE_DATA(.FIELD_SIZE, .FIELD_ADDRESS, 1024, BUFFER);
A = BUFFER;
E = .A + .FIELD_ADDRESS[FVDF_LENGTH];
I = .ITEM_CODE;
WHILE .A LSSA .E DO
    BEGIN
    LOCAL
	L;

    L = .A[0,0,16,0];
    A = .A + 2;
    IF .L NEQ 0
    THEN
	BEGIN
	ITEM[0,0,16,0] = .L;
	ITEM[2,0,16,0] = .I;
	ITEM = .ITEM + 4;
	MOVC3(L, .A, .ITEM; , A, , ITEM);
	END;
    I = .I + 1;
    END;
.ITEM
END;

GLOBAL ROUTINE FETCH_VARIABLE_DATA(FIELD_SIZE,FIELD_ADDRESS,BUFFER_LENGTH,BUFFER_ADDRESS): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine fetches data from a fixed/variable data field.
!
! INPUT PARAMETERS:
!	FIELD_SIZE	- Size of the fixed data field.
!	FIELD_ADDRESS	- Address within the record of the fixed data field.
!	BUFFER_LENGTH	- Descriptor for output buffer.
!	BUFFER_ADDRESS	-
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	FIELD_ADDRESS:	REF BBLOCK;	! Pointer to fixed/variable buffer
LOCAL
	AUX_N,				! Record number of auxiliary record
	AUX_NS,				! Record number of successor of AUX
	AUX:		REF BBLOCK;	! Pointer to auxiliary record


IF .FIELD_ADDRESS[FVDF_LENGTH] LEQU .FIELD_SIZE - 2
THEN
    BEGIN
    CH$COPY(
	.FIELD_ADDRESS[FVDF_LENGTH], FIELD_ADDRESS[FVDF_DATA],
	0,
	.BUFFER_LENGTH, .BUFFER_ADDRESS);
    END
ELSE
    BEGIN
    LOCAL
	INPUT_LENGTH,			! Remaining input data
	CURRENT_LENGTH,			! Remaining buffer length
	CURRENT_ADDRESS;		! Current buffer address


    ! Initialize.
    !
    INPUT_LENGTH = .FIELD_ADDRESS[FVDF_LENGTH];
    CURRENT_LENGTH = .BUFFER_LENGTH;
    CURRENT_ADDRESS = .BUFFER_ADDRESS;
    AUX_N = .FIELD_ADDRESS[FVDF_LINK];


    ! Loop over all auxiliary information records.
    !
    WHILE TRUE DO
	BEGIN
	AUX = READ_RECORD(.AUX_N);
	IF .AUX[SYM$L_LINK] EQL 0
	THEN
	    BEGIN
	    CH$COPY(
		MINU(.INPUT_LENGTH, SYM$S_DATA), AUX[SYM$T_DATA],
		0,
		.CURRENT_LENGTH, .CURRENT_ADDRESS);	    
	    RELEASE_RECORD(.AUX_N);
	    EXITLOOP;
	    END
	ELSE
	    BEGIN
	    LOCAL
		THIS_LENGTH;		! Length of current transfer


	    THIS_LENGTH = MINU(.CURRENT_LENGTH, SYM$S_DATA);
	    CURRENT_ADDRESS = CH$MOVE(
		.THIS_LENGTH, AUX[SYM$T_DATA], .CURRENT_ADDRESS);
	    CURRENT_LENGTH = .CURRENT_LENGTH - .THIS_LENGTH;
	    IF .CURRENT_LENGTH EQL 0 THEN EXITLOOP;
	    AUX_NS = .AUX[SYM$L_LINK];
	    RELEASE_RECORD(.AUX_N);
	    AUX_N = .AUX_NS;
	    END;
	END;
    END;
END;

GLOBAL ROUTINE STORE_VARIABLE_DATA(RECORD_ADDRESS,FIELD_SIZE,FIELD_ADDRESS,TYPE_CODE,DATA_LENGTH,DATA_ADDRESS)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine stores data in a fixed/variable data field.  These fields
!	allow a string up to 65535 bytes to be stored and retrieved by use of
!	extension queue records; however, a string that does not exceed the
!	fixed field size is stored without use of auxiliary records.
!
! INPUT PARAMETERS:
!	RECORD_ADDRESS	- Pointer to record containing the fixed/variable data
!			  field.
!	FIELD_SIZE	- Size of the fixed data field.
!	FIELD_ADDRESS	- Address within the record of the fixed data field.
!	TYPE_CODE	- Value of SYM$B_TYPE for extension records.
!	DATA_LENGTH	- Descriptor for data to be stored.
!	DATA_ADDRESS	-
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Completion status.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	RECORD_ADDRESS:	REF BBLOCK,	! Pointer to record
	FIELD_ADDRESS:	REF BBLOCK;	! Pointer to fixed/variable buffer


IF .FIELD_ADDRESS[FVDF_LENGTH] NEQ 0
THEN
    DEALLOCATE_VARIABLE_DATA(.FIELD_SIZE, .FIELD_ADDRESS);


FIELD_ADDRESS[FVDF_LENGTH] = .DATA_LENGTH;
IF .DATA_LENGTH LEQU .FIELD_SIZE - 2
THEN
    BEGIN
    CH$COPY(
	.DATA_LENGTH, .DATA_ADDRESS,
	0,
	.FIELD_SIZE-2, FIELD_ADDRESS[FVDF_DATA]);
    END
ELSE
    BEGIN
    LOCAL
	SEQUENCE,			! Sequence counter
	AUX_NP,				! Record number of predecessor of AUX
	AUX_P:		REF BBLOCK,	! Pointer to predecessor of AUX
	AUX_N,				! Record number of auxiliary record
	AUX:		REF BBLOCK,	! Pointer to auxiliary record
	CURRENT_LENGTH,			! Remaining source length
	CURRENT_ADDRESS;		! Current source address


    ! Initialize.
    !
    SEQUENCE = 0;
    AUX_NP = 0;
    CURRENT_LENGTH = .DATA_LENGTH;
    CURRENT_ADDRESS = .DATA_ADDRESS;


    ! Loop until all source data is stored.
    !
    WHILE TRUE DO
	BEGIN
	LOCAL
	    THIS_LENGTH,		! Current transfer length
	    STATUS;			! Status return


	! Obtain the minimum of the remaining input length and the space
	! available in one record.
	!
	THIS_LENGTH = .CURRENT_LENGTH;
	IF .THIS_LENGTH GTRU SYM$S_DATA THEN THIS_LENGTH = SYM$S_DATA;


	! Allocate the record and set up the forward link.
	!
	STATUS = ALLOCATE_RECORD( ; AUX_N, AUX);
	IF NOT .STATUS
	THEN
	    BEGIN
	    DEALLOCATE_RECORD_LIST(.FIELD_ADDRESS[FVDF_LINK]);
	    CH$FILL(0, .FIELD_SIZE, .FIELD_ADDRESS);
	    RETURN .STATUS;
	    END;
	IF .AUX_NP EQL 0
	THEN
	    FIELD_ADDRESS[FVDF_LINK] = .AUX_N
	ELSE
	    BEGIN
	    AUX_P[SYM$L_LINK] = .AUX_N;
	    REWRITE_RECORD(.AUX_NP);
	    END;
	

	! Initialize the record header.
	!
	SEQUENCE = .SEQUENCE + 1;
	AUX[SYM$B_TYPE] = .TYPE_CODE;
	AUX[SYM$B_AUX_SEQUENCE] = .SEQUENCE;
	AUX[SYM$W_SEQUENCE] = .RECORD_ADDRESS[SYM$W_SEQUENCE];
	AUX[SYM$L_ENTRY_NUMBER] = .RECORD_ADDRESS[SYM$L_ENTRY_NUMBER];


	! Move the information.
	!
	CH$MOVE(.THIS_LENGTH, .CURRENT_ADDRESS, AUX[SYM$T_DATA]);


	! Update current length and address for the next record and quit if
	! all data has been transferred.
	!
	CURRENT_LENGTH = .CURRENT_LENGTH - .THIS_LENGTH;
	IF .CURRENT_LENGTH EQL 0 THEN EXITLOOP;
	CURRENT_ADDRESS = .CURRENT_ADDRESS + .THIS_LENGTH;
	END;


    REWRITE_RECORD(.AUX_N);
    END;


SS$_NORMAL
END;

GLOBAL ROUTINE STORE_VARIABLE_DATA_LIST(RECORD_ADDRESS,FIELD_SIZE,FIELD_ADDRESS,TYPE_CODE)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine stores data in a fixed/variable data field.  These fields
!	allow a string up to 65535 bytes to be stored and retrieved by use of
!	extension queue records; however, a string that does not exceed the
!	fixed field size is stored without use of auxiliary records.
!
! INPUT PARAMETERS:
!	RECORD_ADDRESS	- Pointer to record containing the fixed/variable data
!			  field.
!	FIELD_SIZE	- Size of the fixed data field.
!	FIELD_ADDRESS	- Address within the record of the fixed data field.
!	TYPE_CODE	- Value of SYM$B_TYPE for extension records.
!	(Length, address) pairs for each string to be stored.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Completion status.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	RECORD_ADDRESS:	REF BBLOCK,	! Pointer to record
	FIELD_ADDRESS:	REF BBLOCK;	! Pointer to fixed/variable buffer
LOCAL
	LN,				! Index of last non-null parameter
	DATA_LENGTH,			! Total length of stored data
	BUFFER:		BBLOCK[1024],	! Buffer for stored data
	CURRENT_LENGTH,			! Length of current string
	CURRENT_ADDRESS;		! Cursor for data storage area
BUILTIN
	ACTUALCOUNT,
	ACTUALPARAMETER;


! Deallocate an existing variable data area, if it exists.
!
IF .FIELD_ADDRESS[FVDF_LENGTH] NEQ 0
THEN
    DEALLOCATE_VARIABLE_DATA(.FIELD_SIZE, .FIELD_ADDRESS);


! Strip trailing null strings from the list of string descriptors.
!
LN = 0;
DECR N FROM ACTUALCOUNT()-1 TO 5 BY 2 DO
    BEGIN
    IF ACTUALPARAMETER(.N) NEQ 0
    THEN
	BEGIN
	LN = .N;
	EXITLOOP;
	END;
    END;


! Compute the total length of the data to be stored including the length word
! for each string.
!
DATA_LENGTH = 0;
INCR N FROM 5 TO .LN BY 2 DO
    BEGIN
    DATA_LENGTH = .DATA_LENGTH + 2 + ACTUALPARAMETER(.N);
    END;


! Build a buffer containing the data to be stored.
!
CURRENT_ADDRESS = BUFFER;
INCR N FROM 5 TO .LN BY 2 DO
    BEGIN
    CURRENT_LENGTH = ACTUALPARAMETER(.N);		! Fetch length
    (.CURRENT_ADDRESS)<0,16> = .CURRENT_LENGTH;		! Store length word
    CURRENT_ADDRESS = .CURRENT_ADDRESS + 2;		! Point past length
    MOVC3(						! Store data
	CURRENT_LENGTH,
	ACTUALPARAMETER(.N+1),
	.CURRENT_ADDRESS; ,,, CURRENT_ADDRESS);
    END;


! Store the data.
!
STORE_VARIABLE_DATA(
    .RECORD_ADDRESS, .FIELD_SIZE, .FIELD_ADDRESS, .TYPE_CODE,
    .DATA_LENGTH, BUFFER)
END;

END
ELUDOM
