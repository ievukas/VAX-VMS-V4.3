%TITLE 'SMG$MISC - Miscellaneous routines for screen mgmt'
MODULE SMG$MISC (
		IDENT = '1-012'	! EDIT: STAN1013
		) =
BEGIN
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY:	Screen Management
!
! ABSTRACT:
!
!	This module contains miscellaneous routines
!	having to do with asynchronous terminal operation.
!
! ENVIRONMENT:	User mode, Shared library routines.
!
! AUTHOR: Stanley Rabinowitz, CREATION DATE: 3-May-1983
!
! MODIFIED BY:
!
! 1-013 Stan	24-Jul-1984	Remove informational errors.
! 1-012 Stan	 4-Apr-1984	Add error message for non-ANSI terminal.
!				Tighten up error checking in unsolicted input.
! 1-011 Stan	18-Mar-1984	Allow asking terminal for physical cursor location
!				Rename some routines.
! 1-010 Stan	17-Mar-1984	More fixes to documentation
!				Fix bug in initializing mailbox.
! 1-009 Stan	21-Feb-1984	Fix documentation
! 1-008 Stan	27-Nov-1983	Unsolicited input.
! 1-007 Stan	27-Sep-1983	Get background color.
! 1-006 Stan	17-Aug-1983	Add items to GET_PASTEBOARD_ATTRIBUTES.
! 1-005 Stan	 7-Jul-1983	Call user's AST routine.
! 1-004	Stan	13-Jun-1983	Finish mailbox stuff.
! 1-003	Stan	 2-Jun-1983	Add SMG$GET_PASTEBOARD_ATTRIBUTES.
! 1-002	Stan	 1-Jun-1983	Set characteristics
! 1-001	Stan	 3-May-1983	Original version.
!--

%SBTTL 'Declarations'
!
! TABLE OF CONTENTS:
!

FORWARD ROUTINE

	SMG$SET_OUT_OF_BAND_ASTS,	! Enable out-of-band ASTs
	SMG$SET_BROADCAST_TRAPPING,	! Enable trapping of broadcast messages
	SMG$ENABLE_UNSOLICITED_INPUT,	! Enable unsolicited input
	SMG$GET_BROADCAST_MESSAGE,	! Gets a broadcast message
	SMG$GET_PASTEBOARD_ATTRIBUTES,	! Get information about pasteboard
	SMG$GET_PHYSICAL_CURSOR,	! Get physical cursor position

	SMG$$OUT_OF_BAND_HANDLER,	! Generic out-of-band AST handler
	SMG$$SET_TERM_CHARACTERISTICS,	! Set characteristics
					! in a modular fashion

	MAILBOX_AST_ROUTINE,		! Handles messages to our mailbox
	INITIALIZE_MAILBOX,		! Sets up mailbox and queues
	CHAR_EXIT_HANDLER;		! Handler to reset terminal
					! characteristics

!
! SWITCHES:
!
!	In the include files.
!

!
! LINKAGES:
!
!	In the include files.
!

!
! INCLUDE FILES:
!

REQUIRE 'SRC$:SMGPROLOG';		! defines psects, macros,
					! structures and terminal defs
REQUIRE 'RTLIN:STRLNK';			! linkages

!
! MACROS:
!

!
! EQUATED SYMBOLS:
!

LITERAL

	SMG$S_CHAR_EXIT_BLOCK	= 9*4;	! Size of exit block used by
					! SMG$$SET_TERMINAL_CHARACTERISTICS
					! (in bytes).

!
! FIELDS:
!

FIELD

	SMGMBX_FIELDS =

SET

SMGMBX_L_FLINK	= [ 0,0,32,0],	! Forward  link in queue of mailbox blocks
SMGMBX_L_BLINK	= [ 4,0,32,0],	! Backward link in queue of mailbox blocks
SMGMBX_A_BUFFER	= [ 8,0,32,0],	! Addres of buffer containing received message
SMGMBX_Q_IOSB	= [12,0, 0,0],	! Copy of 4-word I/O status block
SMGMBX_W_STATUS	= [12,0,16,0],	! Status of mailbox read (from I/O status block)
SMGMBX_W_MSGLEN	= [14,0,16,0],	! Size of message received
SMGMBX_L_SENDER	= [16,0,32,0],	! PID of process that sent message
SMGMBX_W_BUFSIZ	= [20,0,16,0],	! Allocated size of buffer
SMGMBX_W_UNUSED	= [22,0,16,0]	! Reserved for future use

TES;

LITERAL

	SMGMBX_S_SIZE	= 24;	! Size of structure in bytes

MACRO

	$SMGMBX_DECL	= BLOCK[SMGMBX_S_SIZE,BYTE] FIELD(SMGMBX_FIELDS) %;

!
! PSECTS:
!

! OWN STORAGE:
!
!	NONE	(and shouldn't have any)

LITERAL

	MAX_MSG	= 300,	! *****
	BUFQUO	= 300;	! *****

!
! EXTERNAL REFERENCES:
!

!EXTERNAL ROUTINE
!
!	NONE

%SBTTL 'SMG$GET_PASTEBOARD_ATTRIBUTES'
GLOBAL ROUTINE SMG$GET_PASTEBOARD_ATTRIBUTES (
    PASTEBOARD_ID,P_PIT,P_PIT_SIZE) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine gets information about a pasteboard and
!	leaves it in a user-supplied area (the PIT), the pasteboard
!	information table.
!
! CALLING SEQUENCE:
!
!       RET_STATUS.wlc.v = SMG$GET_PASTEBOARD_ATTRIBUTES (
!				PASTEBOARD_ID.rl.r,
!				P_PIT.wab.r,
!				P_PIT_SIZE.rl.r)
!
! FORMAL PARAMETERS:
!
!	PASTEBOARD_ID.rl.r	Address of pasteboard id
!
!	P_PIT.wab.r		Address of a pasteboard information table.
!				This is a byte block whose size and field
!				references are described in SMGDEF.SDL.
!				It is the caller's responsibility to allocate
!				the correct size block and pass it's address
!				to this routine.
!
!	P_PIT_SIZE.rl.r		Address of a longword containing the size of
!				the PIT (in bytes).  For now, this size must
!				be exactly correct.  This will allow the
!				structure to grow in future releases.
!
! IMPLICIT INPUTS:
!
!       contents of PBCB
!
! IMPLICIT OUTPUTS:
!
!	PIT gets filled in.
!
! COMPLETION STATUS:
!
!	SMG$_INVARG	PIT is the wrong size
!       SS$_NORMAL      Normal successful completion
!
! SIDE EFFECTS:
!
!	NONE
!
!--

BEGIN

LOCAL

	STATUS,
	WCB		: REF BLOCK[,BYTE],	! Window control block
	PBCB		: REF BLOCK[,BYTE];	! Pasteboard control block

BIND

	PIT		= .P_PIT	: BLOCK[,BYTE],	! pasteboard info block
	PIT_SIZE	= .P_PIT_SIZE;			! size of user's PIT

EXTERNAL LITERAL

	SMG$_INVARG;		! PIT is the wrong size

EXTERNAL ROUTINE

	SMG$FIND_CURSOR_DISPLAY;

$SMG$VALIDATE_ARGCOUNT(3,3);

$SMG$GET_PBCB(.PASTEBOARD_ID,PBCB);

!+
! Make sure that the PIT is the correct size.
!-

IF .PIT_SIZE NEQ SMG$S_PASTEBOARD_INFO_BLOCK
  THEN	RETURN	SMG$_INVARG;

WCB=.PBCB[PBCB_A_WCB];

!+
! Move arguments from the PBCB to the PIT.
!-

PIT[SMG$L_DEVCHAR]	= .PBCB[PBCB_L_DEVCHAR];
PIT[SMG$L_DEVDEPEND]	= .PBCB[PBCB_L_DEVDEPEND];
PIT[SMG$L_DEVDEPEND2]	= .PBCB[PBCB_L_DEVDEPEND2];
PIT[SMG$B_DEVCLASS]	= .PBCB[PBCB_B_CLASS];
PIT[SMG$B_SMG_DEVTYPE]	= .PBCB[PBCB_B_DEVTYPE];
PIT[SMG$B_PHY_DEVTYPE]	= .PBCB[PBCB_B_PHY_DEV_TYPE];
PIT[SMG$B_ROWS]		= .PBCB[PBCB_B_ROWS];
PIT[SMG$W_WIDTH]	= .PBCB[PBCB_W_WIDTH];
PIT[SMG$B_PARITY]	= .PBCB[PBCB_B_PARITY];
PIT[SMG$W_SPEED]	= .PBCB[PBCB_W_SPEED];
PIT[SMG$W_FILL]		= .PBCB[PBCB_W_FILL];
PIT[SMG$B_COLOR]	= .PBCB[PBCB_B_BACKGROUND_COLOR];

!+
! Move arguments from the WCB into the PIT.
!-

PIT[SMG$W_CURSOR_ROW]	= .WCB[WCB_W_CURR_CUR_ROW];
PIT[SMG$W_CURSOR_COL]	= .WCB[WCB_W_CURR_CUR_COL];

!+
! Find out which virtual display the cursor is in and
! leave that in the PIT.
!-

STATUS=SMG$FIND_CURSOR_DISPLAY(.PASTEBOARD_ID,PIT[SMG$L_CURSOR_DID]);
IF NOT .STATUS THEN RETURN .STATUS;

RETURN	SS$_NORMAL

END;

%SBTTL 'SMG$GET_PHYSICAL_CURSOR'
GLOBAL ROUTINE SMG$GET_PHYSICAL_CURSOR (
    PASTEBOARD_ID,P_ROW,P_COL,P_PHYS_ROW,P_PHYS_COL) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine returns information about where
!	the physical cursor is on the pasteboard.
!	In case SMG is unsure of the cursor location (for example
!	if the pasteboard is created without clearing the screen),
!	there is also an option to inquire of the terminal
!	finding out where it thinks the cursor is.
!
! CALLING SEQUENCE:
!
!       RET_STATUS.wlc.v = SMG$GET_PHYSICAL_CURSOR (
!				PASTEBOARD_ID.rl.r,
!				[,P_ROW.wl.r]
!				[,P_COL.wl.r]
!				[,P_PHYS_ROW.wl.r]
!				[,P_PHYS_COL.wl.r])
!
! FORMAL PARAMETERS:
!
!	PASTEBOARD_ID.rl.r	Address of pasteboard id
!
!	P_ROW.wl.r		Gets SMG's idea of what row cursor is in
!				0 means it does not know.
!
!	P_COL.wl.r		Gets SMG's idea of what col cursor is in
!				0 means it does not know.
!
!	P_PHYS_ROW.wl.r		Gets terminal's idea of what row cursor is in
!
!	P_PHYS_COL.wl.r		Gets terminal's idea of what col cursor is in
!				If this and the previous arguments are omitted,
!				then no inquiry to the terminal is made
!				and no typeahead is purged.
!
! IMPLICIT INPUTS:
!
!       contents of PBCB
!
! IMPLICIT OUTPUTS:
!
!	SMG's idea of physical cursor location may get updated
!
! COMPLETION STATUS:
!
!	SMG$_TRMNOTANS	Terminal is not ansi
!       SS$_NORMAL      Normal successful completion
!			(includes case where position is not known)
!
! SIDE EFFECTS:
!
!	Type ahead may be cancelled.
!
!--

BEGIN

LOCAL

	STATUS,
	WCB		: REF BLOCK[,BYTE],	! Window control block
	PBCB		: REF BLOCK[,BYTE];	! Pasteboard control block

BUILTIN

	NULLPARAMETER;

BIND

	ROW		= .P_ROW,
	COL		= .P_COL,
	PHYS_ROW	= .P_PHYS_ROW,
	PHYS_COL	= .P_PHYS_COL;

EXTERNAL LITERAL

	SMG$_TRMNOTANS,	! Terminal is not ANSI
	SMG$_INVARG;

OWN

	INQUIRY		: VECTOR[4,BYTE] INITIAL( BYTE(27,'[6n') );

			! ANSI Cursor position report

$SMG$VALIDATE_ARGCOUNT(1,5);

$SMG$GET_PBCB(.PASTEBOARD_ID,PBCB);

WCB=.PBCB[PBCB_A_WCB];

!+
! Move physical cursor row and column from the WCB to the user, if requested.
!-

IF NOT NULLPARAMETER(P_ROW)
  THEN	ROW = .WCB[WCB_W_CURR_CUR_ROW];
IF NOT NULLPARAMETER(P_COL)
  THEN	COL = .WCB[WCB_W_CURR_CUR_COL];

!+
! If the user requested that we interrogate the terminal, then go do that now.
!-

IF NOT NULLPARAMETER(P_PHYS_ROW)
OR NOT NULLPARAMETER(P_PHYS_COL)
  THEN	BEGIN	! Interrogate terminal

	LOCAL

		PTR,
		SEQ		: REF VECTOR[,BYTE],
		ROW_START,
		ROW_LEN,
		COL_START,
		COL_LEN,
		RESP_BUFFER	: VECTOR[SMG$K_LONGEST_SEQUENCE,BYTE],
		IOSB		: VECTOR[4,WORD],
		TERM_ROW : VOLATILE,	! physical row as reported by terminal
		TERM_COL : VOLATILE;	! physical col as reported by terminal

	!+
	! Check that the terminal is really ANSI and that it supports
	! the cursor position report.
	!-

	BEGIN
	BIND TT2=PBCB[PBCB_L_DEVDEPEND2] : $BBLOCK;
	IF NOT .TT2[TT2$V_ANSICRT] THEN RETURN SMG$_TRMNOTANS
	END;

	!+
	! Issue a QIO to the terminal, sending it the standard
	! ANSI sequence asking for the row and column of the cursor,
	! and getting back a respnse in RESP_BUFFER.
	! Purge type-ahead first, and allow the read to time out.
	!-

	STATUS=$QIOW(	FUNC	= IO$_READPROMPT OR IO$M_TIMED OR
				  IO$M_PURGE	 OR IO$M_ESCAPE,
			CHAN	= .PBCB[PBCB_W_CHAN],
			EFN	= .PBCB[PBCB_B_EFN],
			IOSB	= IOSB,
			P1	= RESP_BUFFER,			! gets reply
			P2	= %ALLOCATION(RESP_BUFFER),
			P3	= 4,				! wait 4 seconds
			P5	= INQUIRY,			! inquire sequence
			P6	= %ALLOCATION(INQUIRY) );

	IF .STATUS THEN	STATUS=.IOSB[0];
	IF NOT .STATUS THEN RETURN .STATUS;

	!+
	! If the read succeeds, then IOSB[3] has the number of
	! characters in the escape sequence read, and
	! IOSB[1] points to the beginning of this escape sequence.
	! The format of the answer is "$ [ r ; c R" where r and c
	! are the row and column in decimal-coded ASCII.
	! Start by pointing past the escape and the "[" and then parse a number.
	!-

	ROW_START=RESP_BUFFER[.IOSB[1]+2];

	PTR=CH$FIND_CH(.IOSB[3]-1,.ROW_START,';');
	IF CH$FAIL(.PTR)
	  THEN	RETURN	0;
	ROW_LEN=.PTR-.ROW_START;

	COL_START=.PTR+1;
	PTR=CH$FIND_CH(.IOSB[3]-1,.COL_START,'R');
	IF CH$FAIL(.PTR)
	  THEN	RETURN	0;
	COL_LEN=.PTR-.COL_START;

	!+
	! Convert the decimal-coded ASCII to a number.
	!-

	SEQ=.ROW_START;
	PHYS_ROW=0;
	INCR I FROM 0 TO .ROW_LEN-1 DO
		PHYS_ROW=.PHYS_ROW*10+.SEQ[.I]-%C'0';

	SEQ=.COL_START;
	PHYS_COL=0;
	INCR I FROM 0 TO .COL_LEN-1 DO
		PHYS_COL=.PHYS_COL*10+.SEQ[.I]-%C'0';

	!+
	! Pass the row and column back to the user, if requested.
	!-

	IF NOT NULLPARAMETER(PHYS_ROW)
	  THEN	PHYS_ROW = .TERM_ROW;
	IF NOT NULLPARAMETER(PHYS_COL)
	  THEN	PHYS_COL = .TERM_COL;

	END;	! Interrogate terminal

RETURN	SS$_NORMAL

END;

%SBTTL 'SMG$SET_BROADCAST_TRAPPING'
GLOBAL ROUTINE SMG$SET_BROADCAST_TRAPPING(
    PASTEBOARD_ID,AST_RTN,AST_ARG) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine enables trapping of messages broadcast
!	to the specified terminal.  If an AST routine is specified
!	the AST routine will be called whenever a broadcast
!	message comes in.  The AST routine will be called
!	with the first argument being the user's AST argument
!	(passed by value).  This can be the address of a structure
!	if the user needs to pass more than 32 bits of information.
!	If more than one terminal is involved, the user may wish
!	to pass along the pasteboard id as his AST argument.
!	The AST routine can get at the message by calling
!	SMG$GET_BROADCAST_MESSAGE.
!	If no AST routine is specified, operation is synchronous and
!	the user can get at broadcast messages by calling
!	SMG$GET_BROADCAST_MESSAGE whenever he wants to check for
!	receipt of a broadcast message.
!
! CALLING SEQUENCE:
!
!       RET_STATUS.wlc.v = SMG$ENABLE_BROADCAST_TRAPPING (
!				PASTEBOARD_ID.rl.r
!				[, AST_RTN.szem.r]
!				[, AST_ARG.rz.v])
!
! FORMAL PARAMETERS:
!
!	PASTEBAORD_ID.rl.r	Address of pasteboard id
!
!	AST_RTN.szem.r		Address of AST routine to be called
!				if a broadcast message comes in
!				(optional)
!				If omitted, and if the next argument is
!				omitted, then no AST routine will
!				get called.
!
!	AST_ARG.rz.v		optional value to be passed along to
!				the AST routine
!				If this is specified, but no AST_RTN
!				argument is specified, then only the AST
!				argument changes, but the routine remains
!				the same.
!
! IMPLICIT INPUTS:
!
!       channel of associated mailbox
!
! IMPLICIT OUTPUTS:
!
!       associated mailbox channel may be assigned if not
!	previous;y created.
!
! COMPLETION STATUS:
!
!       SS$_NORMAL      Normal successful completion
!       SMG$_WRONUMARG  Wrong number of arguments
!	SMG$_NOT_A_TRM	Success, but device is not a terminal
!	LIB$_xyz	Errors from LIB$ASN_WTH_MBX
!       SS$_xyz         Any error possible from SMG$$SET_TERM_CHARACTERISTICS
!
! SIDE EFFECTS:
!
!	A mailbox may be created.
!	The terminal characteristics get changed to BRDCSTMBOX
!	and NOBROADCAST. (The old values of these characteristics
!	are saved away so that they can be restored later.)
!
!--

BEGIN

LOCAL

	STATUS,
	PBCB		: REF BLOCK[,BYTE];	! Pasteboard control block

BUILTIN

	NULLPARAMETER;

EXTERNAL LITERAL

	SMG$_NOT_A_TRM;		! pasteboard device is not a terminal

$SMG$VALIDATE_ARGCOUNT(1,3);

$SMG$GET_PBCB(.PASTEBOARD_ID,PBCB);

!+
! Make sure that the device is a terminal.
! If not, return the qualified success, SMG$_NOT_A_TRM.
!-

IF .PBCB[PBCB_B_CLASS] NEQ DC$_TERM
  THEN	RETURN	SMG$_NOT_A_TRM;

!+
! If we don't already have a mailbox established,
! then create a new channel to the terminal with an
! associated mailbox.
!-

IF .PBCB[PBCB_W_ASYNC_CHAN] EQL 0
  THEN	BEGIN
	STATUS=INITIALIZE_MAILBOX(.PBCB);
	IF NOT .STATUS THEN RETURN .STATUS
	END;

!+
! Note that broadcasts are enabled.
!-

PBCB[PBCB_V_BROADCAST]=1;

!+
! Store the (possibly new) AST routine and argument in our PBCB.
!-

IF NULLPARAMETER(2)
  THEN	BEGIN	! no AST routine specified
	IF NULLPARAMETER(3)
	  THEN	BEGIN	! cancel ASTs
		PBCB[PBCB_A_BROADCAST_RTN]=0;
		PBCB[PBCB_L_BROADCAST_ARG]=0
		END	! cancel ASTs
	  ELSE	BEGIN	! change AST argument
		PBCB[PBCB_L_BROADCAST_ARG]=.AST_ARG
		END;	! change AST argument
	END	! no AST routine specified
  ELSE	BEGIN	! New AST routine
	PBCB[PBCB_A_BROADCAST_RTN]=.AST_RTN;
	IF NULLPARAMETER(3)
	  THEN	PBCB[PBCB_L_BROADCAST_ARG]=0
	  ELSE	PBCB[PBCB_L_BROADCAST_ARG]=.AST_ARG
	END;	! New AST routine

RETURN	SS$_NORMAL

END;

%SBTTL 'INITIALIZE_MAILBOX';
ROUTINE INITIALIZE_MAILBOX(P_PBCB) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Creates a mailbox and assigns a channel to it.
!	Initializes a queue of mailbox blocks.
!
! CALLING SEQUENCE:
!
!       RET_STATUS.wlc.v = INITIALIZE_MAILBOX(P_PBCB.rl.v)
!
! FORMAL PARAMETERS:
!
!	P_PBCB.rl.v		Address of pasteboard control block.
!
! IMPLICIT INPUTS:
!
!	MAX_MSG
!	BUFQUO
!
! IMPLICIT OUTPUTS:
!
!       NONE
!
! COMPLETION STATUS:
!
!       SS$_NORMAL      Normal successful completion
!       SS$_xyz         Any error possible from $DASSGN or $CANCEL
!
! SIDE EFFECTS:
!
!	NONE
!--

BEGIN

BIND

	PBCB	= .P_PBCB	: BLOCK[,BYTE];

LOCAL

	STATUS,
	NAME_DESC	: VECTOR[2];

EXTERNAL ROUTINE

	LIB$GET_VM,
	LIB$ASN_WTH_MBX;

!+
! LIB$ASN_WTH_MBX wants the name as a descriptor,
! so we build one temporarily.
!-

NAME_DESC[0]=.PBCB[PBCB_W_DEVNAM_LEN];
NAME_DESC[1]= PBCB[PBCB_T_DEVNAM];

STATUS=LIB$ASN_WTH_MBX(NAME_DESC,%REF(MAX_MSG),%REF(BUFQUO),
	PBCB[PBCB_W_ASYNC_CHAN],PBCB[PBCB_W_MBX_CHAN]);
IF NOT .STATUS THEN RETURN .STATUS;

!+
! Change the terminal characteristics to
! NOBROADCAST and BRDCSTMBX.
! Establish an exit handler to restore the old
! characteristics upon exit.
!-

STATUS=SMG$$SET_TERM_CHARACTERISTICS(PBCB[PBCB_L_PBID],
	TT$M_NOBRDCST,TT2$M_BRDCSTMBX);
IF NOT .STATUS THEN RETURN .STATUS;

!+
! Allocate a buffer to handle reads.
!-

PBCB[PBCB_W_SMGMBX_BUFSIZ]=MAX_MSG;
STATUS=LIB$GET_VM(%REF(.PBCB[PBCB_W_SMGMBX_BUFSIZ]),
		  PBCB[PBCB_A_SMGMBX_BUFFER]);
IF NOT .STATUS THEN RETURN .STATUS;

!+
! Initialize our queue of received mailbox buffers to empty.
!-

PBCB[PBCB_L_SMGMBX_FLINK]=PBCB[PBCB_L_SMGMBX_FLINK];
PBCB[PBCB_L_SMGMBX_BLINK]=PBCB[PBCB_L_SMGMBX_FLINK];

!+
! Invoke the AST routine with our special INIT flag on,
! so that it knows that no buffer was read
! and a read gets initiated.
!-

PBCB[PBCB_V_SMGMBX_INIT]=1;
STATUS=$DCLAST(	ASTADR	= MAILBOX_AST_ROUTINE,
		ASTPRM	= PBCB);
IF NOT .STATUS THEN RETURN .STATUS;

RETURN	SS$_NORMAL

END;

%SBTTL 'MAILOX_AST_ROUTINE';
ROUTINE MAILBOX_AST_ROUTINE(P_PBCB) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine processes messages that appear in our mailbox.
!	All it does is link the message into a message chain.
!	A user's AST routine may get called at this time.
!	A new block and buffer get created and a read for another
!	message is initiated.
!
! CALLING SEQUENCE:
!
!       RET_STATUS.wlc.v = MAILBOX_AST_ROUTINE(P_PBCB.rl.v)
!
! FORMAL PARAMETERS:
!
!	P_PBCB.rl.v		Address of pasteboard control block.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!       NONE
!
! COMPLETION STATUS:
!
!       SS$_NORMAL      Normal successful completion
!       SMG$_WRONUMARG  Wrong number of arguments
!       SS$_xyz         Any error possible from $DASSGN or $CANCEL
!
! SIDE EFFECTS:
!
!	NONE
!--

BEGIN

LOCAL

	SMGMBX		: REF $SMGMBX_DECL,
	STATUS;

BUILTIN

	INSQUE;

BIND

	PBCB	= .P_PBCB	: BLOCK[,BYTE];

EXTERNAL ROUTINE

	LIB$GET_VM;

!+
! A read has just completed (except during initialization).
! The buffer and I/O status block for this read are
! in the PBCB.
! We look at the kind of message it is and deal with it accordingly.
!-

!+
! Create a new SMGMBX structure and link it in at the end.
!-

IF .PBCB[PBCB_V_SMGMBX_INIT]
  THEN	PBCB[PBCB_V_SMGMBX_INIT]=0
  ELSE	BEGIN	! Copy message to our queue
	BIND BFR = .PBCB[PBCB_A_SMGMBX_BUFFER] : VECTOR[2,WORD];

	!+
	! Do different things depending upon whether this is a
	! broadcast message or an unsolicited input message.
	!-

	IF .BFR[0] EQL MSG$_TRMUNSOLIC
	  THEN	BEGIN	! Unsolicited input

		!+
		! Call the user's AST routine, if one was specified.
		!-

		IF .PBCB[PBCB_A_UNSOLICIT_RTN] NEQ 0
		  THEN	BEGIN
			BIND ROUTINE

				BRTN	= .PBCB[PBCB_A_UNSOLICIT_RTN];

			! Ignore status from user's AST routine

			BRTN(	.PBCB[PBCB_L_PBID],
				.PBCB[PBCB_L_UNSOLICIT_ARG]);

			END;

		END	! Unsolicited input
	  ELSE	BEGIN	! broadcast message

		STATUS=LIB$GET_VM(%REF(SMGMBX_S_SIZE),SMGMBX);
		IF NOT .STATUS THEN SIGNAL(.STATUS);

		CH$FILL(0,SMGMBX_S_SIZE,.SMGMBX);
		INSQUE(.SMGMBX,.PBCB[PBCB_L_SMGMBX_BLINK]);

		!+
		! Allocate a new buffer to receive mailbox messages.
		!-

		STATUS=LIB$GET_VM(%REF(.PBCB[PBCB_W_SMGMBX_BUFSIZ]),SMGMBX[SMGMBX_A_BUFFER]);
		IF NOT .STATUS THEN SIGNAL(.STATUS);

		!+
		! Remember it's size (in case the default size in the PBCB changes.
		!-

		SMGMBX[SMGMBX_W_BUFSIZ]=.PBCB[PBCB_W_SMGMBX_BUFSIZ];

		!+
		! Copy the returned message and it's I/O status block into
		! this structure.
		!-

		CH$MOVE(8,PBCB[PBCB_Q_SMGMBX_IOSB],SMGMBX[SMGMBX_Q_IOSB]);
		CH$MOVE(.SMGMBX[SMGMBX_W_MSGLEN],
			.PBCB[PBCB_A_SMGMBX_BUFFER],
			.SMGMBX[SMGMBX_A_BUFFER]);

		!+
		! Call the user's AST routine, if one was specified.
		!-

		IF .PBCB[PBCB_A_BROADCAST_RTN] NEQ 0
		  THEN	BEGIN
			BIND ROUTINE

				BRTN	= .PBCB[PBCB_A_BROADCAST_RTN];

			! Ignore status from user's AST routine

			BRTN(.PBCB[PBCB_L_BROADCAST_ARG]);

			END;

		END	! Broadcast message

	END;	! Copy message to our queue

!+
! Issue a read to the mailbox again so that our AST routine
! will wake up again the next time something comes in.
!-

STATUS=$QIO(	CHAN	= .PBCB[PBCB_W_MBX_CHAN],
		EFN	= .PBCB[PBCB_B_ASYNC_EFN],
		FUNC	=  IO$_READVBLK,
		IOSB	=  PBCB[PBCB_Q_SMGMBX_IOSB],
		P1	= .PBCB[PBCB_A_SMGMBX_BUFFER],
		P2	= .PBCB[PBCB_W_SMGMBX_BUFSIZ],
		ASTADR	=  MAILBOX_AST_ROUTINE,
		ASTPRM	=  PBCB);
IF NOT .STATUS THEN SIGNAL(.STATUS);

RETURN	SS$_NORMAL

END;

%SBTTL 'SMG$GET_BROADCAST_MESSAGE'
GLOBAL ROUTINE SMG$GET_BROADCAST_MESSAGE (
    PASTEBOARD_ID,P_MSG_DESC,P_MSG_LEN,P_SENDER_PID) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine asks if any broadcast messages have been
!	received.  If none have been received, it returns with
!	the sucess status SMG$_NO_MORMSG.  Normally, when a program
!	desires to process trapped messages, it would call this routine
!	repeatedly, handling each message it provided until
!	there were no more.
!
!	This routine may be called from either AST level or NON-AST level.
!
! CALLING SEQUENCE:
!
!       RET_STATUS.wlc.v = SMG$GET_BROADCAST_MESSAGE (
!				PASTEBOARD_ID.rl.r
!				[, P_MSG_DESC.wt.dx,
!                               [, [P_MSG_LEN.ww.r] ]
!				[, [P_SENDER_PID])
!
! FORMAL PARAMETERS:
!
!	PASTEBOARD_ID		address of pastebaord associated
!				with terminal in question
!
!	P_MSG_DESC		address of a descriptor for a
!				buffer to receive the broadcast
!				message.  If omitted, the broadcast
!				message is discarded.
!
!	P_MSG_LEN		address of a word to receive the
!				actual length of the received message.
!				This is set to 0 if no messages were
!				available.
!				The value of this word is unpredictable
!				if other errors occur.
!
!	P_SENDER_PID		address of a longword to receive the PID
!				(process id) of the process that sent
!				this broadcast message.  This may
!				be 0 for certain system processes.
!				This longword is not set if an
!				error occurs.
!
! IMPLICIT INPUTS:
!
!       internal data storage holding previously received broadcast
!	messages.
!
! IMPLICIT OUTPUTS:
!
!       NONE
!
! COMPLETION STATUS:
!
!       SS$_NORMAL      Normal successful completion
!       SMG$_WRONUMARG  Wrong number of arguments
!	SMG$_NO_MORMSG	No more broadcast messages are available
!       LIB$_xyz        Any error possible from LIB$SCOPY_DX
!	SS$_xyz		Errors from mailbox driver (these errors
!			may have occurred when we tried to read
!			a message).
!
! SIDE EFFECTS:
!
!	NONE
!
!--

BEGIN

BIND

	MSG_DESC	= .P_MSG_DESC	: BLOCK[,BYTE],
	MSG_LEN		= .P_MSG_LEN	: WORD,
	SENDER_PID	= .P_SENDER_PID	: LONG;

EXTERNAL LITERAL

	SMG$_NO_MORMSG;

EXTERNAL ROUTINE

	LIB$SCOPY_R_DX,
	LIB$GET_VM,
	LIB$FREE_VM;

LOCAL

	FOUND_FLAG,
	FINAL_STATUS,
	SMGMBX		: REF $SMGMBX_DECL,
	PBCB		: REF BLOCK[,BYTE],
!	AST_STATUS,
	STATUS;

BUILTIN

	REMQUE,
	NULLPARAMETER;

$SMG$VALIDATE_ARGCOUNT(1,4);

$SMG$GET_PBCB(.PASTEBOARD_ID,PBCB);

!+
! Note that we have not yet found a broadcast message.
!-

FOUND_FLAG=0;

!+
! Go look in our PBCB to see if any mailbox messages are present.
! If so, extract them off, one at a time, looking for a
! broadcast message.  Return it to the user if he supplied a buffer.
!-

!+
! Note that the SMGMBX message queue must always contain at least
! one block.  This is the block that the current read is attached to.
! We must never touch this block.  Note also that we need not
! disable ASTs at critical times to prevent our queue from
! getting messed up because INSQUE and REMQUE instructions
! are non-interruptable.
!-

WHILE 1 DO
	BEGIN	! Look for message in queue

!	!+
!	! Disable delivery of ASTs.
!	!-
!
!	AST_STATUS=$SETAST(ENBFLG=0);

!	IF .PBCB[PBCB_L_SMGMBX_FLINK] EQL .PBCB[PBCB_L_SMGMBX_BLINK]
!	  THEN	EXITLOOP;

	!+
	! Attempt to remove the first mailbox block from the queue.
	!-

	STATUS=REMQUE(.PBCB[PBCB_L_SMGMBX_FLINK],SMGMBX);

	!+
	! If the queue was empty, then we merely exit the loop.
	! This means that there are no broadcast messages available.
	!-

	IF .STATUS THEN	EXITLOOP;

!	!+
!	! Re-enable delivery of ASTs if they had previously been enabled.
!	!-
!
!	IF .AST_STATUS EQL SS$_WASSET
!	  THEN	$SETAST(ENBFLG=1);

	!+
	! Examine the removed block to see if it is a broadcast mailbox
	! message.
	!-

	!+
	! If the I/O status block shows that there was some error
	! reading this message, then return that error now.
	! Who knows? It may have been a broadcast message and we
	! somehow lost it.
	!-

	IF NOT .SMGMBX[SMGMBX_W_STATUS]
	  THEN	BEGIN	! I/O error reading message
		IF NOT NULLPARAMETER(3)
		  THEN	MSG_LEN=0;

		FOUND_FLAG=1;

		FINAL_STATUS=.SMGMBX[SMGMBX_W_STATUS]
		END	! I/O error reading message
	  ELSE	BEGIN	! Valid message

		BIND

			TYPE 	= .SMGMBX[SMGMBX_A_BUFFER]	: WORD,
			BRDMSG	= TYPE			: VECTOR[,BYTE];

		!+
		! Look at the type of the message.
		! This type is in the first word of the message.
		! If it is not a broadcast message, then we throw it away.
		!-

		IF .TYPE EQL MSG$_TRMBRDCST
		  THEN	BEGIN	! Handle broadcast message

			!+
			! I can't find any symbolic offsets for this message.
			! It is described in the I/O user's guide
			! under the section about terminals.
			! The broadcast message starts at offset 22
			! in this block.
			! Its length is stored in a word at offset 20.
			!-

			BIND

				BRDLEN	= BRDMSG[20]	: WORD,
				MESSAGE	= BRDMSG[22]	: VECTOR[,BYTE];

			!+
			! Note that we have found a broadcast message.
			!-

			FOUND_FLAG=1;
			FINAL_STATUS=.SMGMBX[SMGMBX_W_STATUS];

			!+
			! Return to the user the length of
			! the message (if he asked for it).
			!-


			IF NOT NULLPARAMETER(3)
			  THEN	MSG_LEN=.BRDLEN;

			!+
			! Return to the user, the PID of the process
			! that broadcast this message,
			! if he asked for it.
			!-

			IF NOT NULLPARAMETER(4)
			  THEN	SENDER_PID=.SMGMBX[SMGMBX_L_SENDER];

			!+
			! Return the message to the user
			! (using the semantics of his descriptor)
			! if he asked for it.
			!-

			IF NOT NULLPARAMETER(2)
			  THEN	BEGIN	! Return message

				!+
				! Copy it to the user's buffer.
				!-

				STATUS=LIB$SCOPY_R_DX(
					BRDLEN,
					MESSAGE,
					MSG_DESC);
				IF NOT .STATUS THEN RETURN .STATUS

				END;	! Return message

			END;	! Handle broadcast message

		END;	! Valid message

	!+
	! Return the buffer to virtual memory.
	!-

	STATUS=LIB$FREE_VM(%REF(.SMGMBX[SMGMBX_W_BUFSIZ]),
			   SMGMBX[SMGMBX_A_BUFFER]);
	IF NOT .STATUS THEN RETURN .STATUS;

	!+
	! Return the mailbox block to virtual memory.
	!-

	STATUS=LIB$FREE_VM(%REF(SMGMBX_S_SIZE),SMGMBX);
	IF NOT .STATUS THEN RETURN .STATUS;

	!+
	! If we had found a message, then we can return now.
	!-

	IF .FOUND_FLAG
	  THEN	RETURN	.FINAL_STATUS

	END;	! Look for message in queue

!+
! No messages are left in the queue.
! Return a status to the user telling him that no
! broadcast messages are available.
!-

IF NOT NULLPARAMETER(3)
  THEN	MSG_LEN=0;

RETURN	SMG$_NO_MORMSG

END;

%SBTTL 'SMG$$OUT_OF_BAND_HANDLER - Generic out-of-band handler'
GLOBAL ROUTINE SMG$$OUT_OF_BAND_HANDLER (
	ARG, R0, R1, PC, PSL ) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine processes an out-of-band AST.
!	It runs at AST level.  It logically gets called when the
!	user types an out-of-band character.
!	Actually, another routine actually gets called first
!	and then calls this one with the same argument list.
!
! CALLING SEQUENCE:
!
!       RET_STATUS.wlc.v = SMG$$OUT_OF_BAND_HANDLER (
!				ARG.rz.v,
!				R0.rl.v
!				R1.rl.v,
!				PC.ra.v,
!				PSL.rl.v)
!
! FORMAL PARAMETERS:
!
!	ARG		character that was typed
!	R0		register 0 at time of AST
!	R1		register 1 at time of AST
!	PC		PC when AST occurred
!	PSL		contents of PSL at time of AST
!
! IMPLICIT INPUTS:
!
!       Return PC on the stack.
!	We use this to determine who called us.
!	The address of the calling procedure is used to
!	enable us to locate the PBCB associated with the
!	terminal that the out-of-band character was typed on.
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!       SS$_NORMAL      Normal successful completion
!
! SIDE EFFECTS:
!
!--

BEGIN

LOCAL

	NEXT_PC,			! return PC address
					! should point into PBCB
	PBCB : REF BLOCK[,BYTE],	! Gets the address of our PBCB
	PBID,				! Gets our pasteboard id.
	BAND_INFO_BLOCK	: BLOCK[SMG$S_BAND_INFORMATION_TABLE,BYTE],
					! Band information table
	STATUS;				! Local status

EXTERNAL

	PBD_A_PBCB	: VOLATILE VECTOR;	! pasteboard directory

BUILTIN

	FP;			! frame pointer

EXTERNAL LITERAL

	SMG$_FATERRLIB;

BIND	FRAME	= .FP	: BLOCK[,BYTE];		! Stack frame

!+
! Macro $GET_FIELD_OFFSET takes a field reference and replaces
! it in the text stream by the offset represented by that reference.
! (the first of the 4 items in the block structure reference).
! This macro works whether the actual argument is a true
! BLISS field name or if it is an SDL macro name.
! The way it tells the two apart is this: A field name will
! be a single lexeme, while a macro as an actual argument will
! be expanded before invocation and will appear as 4 arguments.
!-

MACRO

    $GET_FIELD_OFFSET(FIELD_REFERENCE) =

	%IF %LENGTH EQL 1

	  %THEN	%FIELDEXPAND(FIELD_REFERENCE,1)

	  %ELSE	FIELD_REFERENCE

	%FI

    %;

!+
! Find out where this routine is going to return to.
! That should be the RET at offset PBCB_B_RET in the AST
! routine that we built in our PBCB.
!-

NEXT_PC=.FRAME[SF$L_SAVE_PC];

!+
! By subtracting the offset of "PBCB_B_RET" we get the
! address of the start of the PBCB for the terminal that
! the out-of-band character was typed on.  We have to go through
! these machinations because there is no other was to tell
! which terminal caused the AST to trigger.
!-

PBCB=.NEXT_PC - $GET_FIELD_OFFSET(PBCB_B_RET);

!+
! Perform some validity checks to make sure that this is
! really the address of a PBCB.  If not, we just return
! without ever calling the user's AST routine.
!-

IF .PBCB[PBCB_B_RET] NEQ %X'04' THEN	RETURN	SMG$_FATERRLIB;
IF .PBCB[PBCB_B_ABS] NEQ %X'9F' THEN	RETURN	SMG$_FATERRLIB;

PBID=.PBCB[PBCB_L_PBID];
IF .PBID GTRU PBD_K_MAX_PB	THEN	RETURN	SMG$_FATERRLIB;
IF .PBD_A_PBCB[.PBID] NEQ .PBCB	THEN	RETURN	SMG$_FATERRLIB;

!+
! Call the user's AST routine as if the system were calling it
! directly.  The difference is, though, that the first
! argument will be the address of an SMG BAND INFORMATION BLOCK,
! instead of just the character that was typed.
! If somehow no user routine was specified, we just return also.
!-

IF .PBCB[PBCB_A_BAND_ROUTINE] EQL 0
  THEN	RETURN	SMG$_FATERRLIB
  ELSE	BEGIN
	BIND ROUTINE

		USER_RTN = .PBCB[PBCB_A_BAND_ROUTINE];

	!+
	! Set up the band information block.
	!-

	BAND_INFO_BLOCK[SMG$L_PASTEBOARD_ID] = .PBID;
	BAND_INFO_BLOCK[SMG$L_ARG]	     = .PBCB[PBCB_L_BAND_AST_ARG];
	BAND_INFO_BLOCK[SMG$L_CHARACTER]     = '    ';
	BAND_INFO_BLOCK[SMG$B_CHARACTER]     = .ARG;

	STATUS=USER_RTN( BAND_INFO_BLOCK,.R0,.R1,.PC,.PSL );
	IF NOT .STATUS THEN RETURN .STATUS
	END;

RETURN	SS$_NORMAL

END;

%SBTTL 'SMG$SET_OUT_OF_BAND_ASTS'
GLOBAL ROUTINE SMG$SET_OUT_OF_BAND_ASTS (
	PASTEBOARD_ID,P_CHAR_MASK,AST_RTN,AST_ARG ) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine enables new out-of-band characters to
!	be accepted from the specified terminal.  If one of these
!	characters is typed, the specified AST routine gets called.
!	See the RTL manual for conventions on how AST routines get called.
!	The first argument to the AST routine is the address of a
!	band information table.  This table contains things like
!	the pasteboard id and the character that was typed.
!	The format and structure of this table is described in SMGDEF.SDL.
!
! CALLING SEQUENCE:
!
!       RET_STATUS.wlc.v = SMG$ENABLE_OUT_OF_BAND_ASTS (
!				PASTEBOARD_ID.rl.r,
!				P_CHAR_MASK.rl.r,
!				AST_RTN.szem.r
!                               [, AST_ARG.rz.v])
!
! FORMAL PARAMETERS:
!
!       PASTEBOARD_ID   Pasteboard ID for terminal to be affected.
!
!	P_CHAR_MASK	Longword mask of which control characters
!			to be the new out-of-band control characters.
!
!	AST_RTN		Address of AST routine to be called
!
!	AST_ARG		Optional value to be passed along to the AST routine.
!			It will appear as the second longword in the
!			band information table.
!
! IMPLICIT INPUTS:
!
!       NONE
!
! IMPLICIT OUTPUTS:
!
!       Structure holding information about out-of-band AST routines
!	gets updated.
!
! COMPLETION STATUS:
!
!       SS$_NORMAL      Normal successful completion
!       SMG$_WRONUMARG  Wrong number of arguments
!       SS$_xyz         Any error possible from $QIOW
!
! SIDE EFFECTS:
!
!--

BEGIN

BIND

	CHAR_MASK	= .P_CHAR_MASK;

LOCAL

	PBCB		: REF BLOCK[,BYTE],	! Pasteboard control block
	MASK_BLOCK	: VECTOR[2],		! Character mask block
						! See figure 9-4 in I/O manual.
	STATUS;

BUILTIN

	ACTUALCOUNT;

$SMG$VALIDATE_ARGCOUNT(3,4);

!+
!	Get the PBCB associated with this id and store it in PBCB.
!_

$SMG$GET_PBCB(.PASTEBOARD_ID,PBCB);

!+
!	Store the address of the user's AST routine in the PBCB.
!-

PBCB[PBCB_A_BAND_ROUTINE] = .AST_RTN;

!+
!	Store his argument, if one was specified, or 0 if not.
!-

IF ACTUALCOUNT() EQL 4
  THEN	PBCB[PBCB_L_BAND_AST_ARG]=.AST_ARG
  ELSE	PBCB[PBCB_L_BAND_AST_ARG]= 0;

!+
!	Store away the mask for goodness sake in the PBCB
!	and in our terminator mask block.
!	The first longword of the terminator mask block must be 0
!	indicating that it is a short-form mask.
!-

PBCB[PBCB_M_BAND_MASK]=.CHAR_MASK;
MASK_BLOCK[0]=0;
MASK_BLOCK[1]=.CHAR_MASK;

!+
! Issue the appropriate QIO.
! The AST routine to service the out-of-band character has
! previously been built in the PBCB at offset PBCB_Z_OUT_OF_BAND_RTN.
! This handler actually resides within the PBCB.
! It is of the form:
!
!	0000	entry mask
!	  FA	CALLG
!	  6C	(AP)
!	  9F	absolute addressing
!    address	longword address of SMG$$OUT_OF_BAND_HANDLER
!         04	RET
!_

STATUS=$QIOW(	CHAN	=  .PBCB[PBCB_W_CHAN],
		EFN	=  .PBCB[PBCB_B_ASYNC_EFN],
		FUNC	= IO$_SETMODE OR IO$M_OUTBAND,
		P1	= PBCB[PBCB_Z_OUT_OF_BAND_RTN],
		P2	= MASK_BLOCK);

RETURN .STATUS

END;

%SBTTL 'SMG$ENABLE_UNSOLICITED_INPUT'
GLOBAL ROUTINE SMG$ENABLE_UNSOLICITED_INPUT(
	PASTEBOARD_ID,AST_RTN,AST_ARG) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine enables calling of an AST routine upon
!	receipt of unsolicited input on the specified terminal.
!	The AST routine gets called with 2 arguments:
!	PASTEBOARD_ID.rl.r and AST_ARG.rz.v.  Note that no input
!	characters are read. It is up to the user to read the
!	unsolicited input using normal SMG input routines
!	(or cancel the type-ahead).
!
! CALLING SEQUENCE:
!
!       RET_STATUS.wlc.v = SMG$ENABLE_UNSOLICITED_INPUT(
!				PASTEBOARD_ID.rl.r,
!				AST_RTN.szem.r
!                               [, AST_ARG.rz.v])
!
! FORMAL PARAMETERS:
!
!	PASTEBOARD_ID	Address of pasteboard id for terminal to
!			be affected.
!
!	AST_RTN		Address of AST routine to be called
!
!	AST_ARG		Optional value to be passed to AST routine.
!
! IMPLICIT INPUTS:
!
!       NONE
!
! IMPLICIT OUTPUTS:
!
!       Internal tables get updated.
!
! COMPLETION STATUS:
!
!       SS$_NORMAL      Normal successful completion
!       SMG$_WRONUMARG  Wrong number of arguments
!       SS$_xyz         Any error possible from $QIOW
!
! SIDE EFFECTS:
!
!--

BEGIN

BUILTIN

	NULLPARAMETER;

LOCAL

	PBCB		: REF $PBCB_DECL,
	STATUS;

EXTERNAL LITERAL

	SMG$_NOT_A_TRM;

$SMG$VALIDATE_ARGCOUNT(2,3);

$SMG$GET_PBCB(.PASTEBOARD_ID,PBCB);

!+
! Make sure that the device is a terminal.
! If not, return the qualified success, SMG$_NOT_A_TRM.
!-

IF .PBCB[PBCB_B_CLASS] NEQ DC$_TERM
  THEN	RETURN	SMG$_NOT_A_TRM;

!+
! If we don't already have a mailbox established,
! then create a new channel to the terminal with an
! associated mailbox.
!-

IF .PBCB[PBCB_W_ASYNC_CHAN] EQL 0
  THEN	BEGIN
	STATUS=INITIALIZE_MAILBOX(.PBCB);
	IF NOT .STATUS THEN RETURN .STATUS
	END;

!+
! Note that unsolicted input is enabled.
!-

PBCB[PBCB_V_UNSOLICIT]=1;

!+
! Store the (possibly new) AST routine and argument in our PBCB.
!-

PBCB[PBCB_A_UNSOLICIT_RTN]=.AST_RTN;
IF NULLPARAMETER(AST_ARG)
  THEN	PBCB[PBCB_L_UNSOLICIT_ARG]=0
  ELSE	PBCB[PBCB_L_UNSOLICIT_ARG]=.AST_ARG;

RETURN	SS$_NORMAL

END;

%SBTTL 'SMG$DISABLE_UNSOLICITED_INPUT'
GLOBAL ROUTINE SMG$DISABLE_UNSOLICITED_INPUT(
	PASTEBOARD_ID) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine disables unsolicited input ASTs for the
!	specified terminal.
!
! CALLING SEQUENCE:
!
!       RET_STATUS.wlc.v = SMG$DISABLE_UNSOLICITED_INPUT(
!				PASTEBOARD_ID.rl.r) 
!
! FORMAL PARAMETERS:
!
!	PASTEBOARD_ID	Pasteboard id for terminal to
!			be affected.
!
! IMPLICIT INPUTS:
!
!       Internal tables.
!
! IMPLICIT OUTPUTS:
!
!       Internal tables get updated.
!
! COMPLETION STATUS:
!
!       SS$_NORMAL      Normal successful completion
!       SMG$_WRONUMARG  Wrong number of arguments
!       SS$_xyz         Any error possible from $QIOW
!
! SIDE EFFECTS:
!
!--

BEGIN

LOCAL

	PBCB		: REF $PBCB_DECL,
	STATUS;

EXTERNAL LITERAL

	SMG$_NOT_A_TRM;

$SMG$VALIDATE_ARGCOUNT(1,1);

$SMG$GET_PBCB(.PASTEBOARD_ID,PBCB);

!+
! Make sure that the device is a terminal.
! If not, return the qualified success, SMG$_NOT_A_TRM.
!-

IF .PBCB[PBCB_B_CLASS] NEQ DC$_TERM
  THEN	RETURN	SMG$_NOT_A_TRM;

!+
! Note that unsolicted input is disabled.
!-

PBCB[PBCB_V_UNSOLICIT]=0;
PBCB[PBCB_A_UNSOLICIT_RTN]=0;
PBCB[PBCB_L_UNSOLICIT_ARG]=0;

RETURN	SS$_NORMAL

END;

%SBTTL 'SMG$$SET_TERM_CHARACTERISTICS'
GLOBAL ROUTINE SMG$$SET_TERM_CHARACTERISTICS (
	PBID, ON_CHARACTERISTICS1, ON_CHARACTERISTICS2,
	OFF_CHARACTERISTICS1, OFF_CHARACTERISTICS2,
	P_HANDLE,
	P_OLD_CHARACTERISTICS1, P_OLD_CHARACTERISTICS2 ) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine changes the terminal characteristics
!	for a given pasteboard.
!	It also establishes an exit handler that will restore
!	the characteristics back to what they were on image exit.
!
! CALLING SEQUENCE:
!
!       RET_STATUS.wlc.v = SMG$$SET_TERM_CHARACTERISTICS (
!				PBID.rl.r
!				[,ON_CHARACTERISTICS1.rl.v]
!				[,ON_CHARACTERISTICS2.rl.v]
!				[,OFF_CHARACTERISTICS1.rl.v]
!				[,OFF_CHARACTERISTICS2.rl.v]
!				[,P_HANDLE.wl.r]
!				[,P_OLD_CHARACTERISTICS1.wl.r]
!				[,P_OLD_CHARACTERISTICS2.wl.r])
!
! FORMAL PARAMETERS:
!
!	PBID.rl.r			pasteboard id
!	ON_CHARACTERITSICS1.rl.v	bits to turn on in 1st characteristics
!	ON_CHARACTERITSICS2.rl.v	bits to turn on in 2nd characteristics
!	OFF_CHARACTERITSICS1.rl.v	bits to turn off in 1st characteristics
!	OFF_CHARACTERITSICS2.rl.v	bits to turn off in 2nd characteristics
!	P_HANDLE.wl.r			longword to receive "handle" for
!					this request.  This handle value may
!					be used to refer back to this
!					request in a subsequent call to
!					SMG$$REVERT_CHARACTERISTICS.
!	P_OLD_CHARACTERISTICS1.wl.r	gets old characteristics (part 1)
!	P_OLD_CHARACTERISTICS2.wl.r	gets old characteristics (part 2)
!
! IMPLICIT INPUTS:
!
!	Terminal characteristics
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!       SS$_NORMAL      Normal successful completion
!	SMG$_NOT_A_TRM	Success - but device is not a terminal
!	LIB$_xyz	Errors from LIB$GET_VM
!	SS$_xyz		Errors from $DCLEXH or $QIOW
!
! SIDE EFFECTS:
!
!--

BEGIN

BIND

	HANDLE		= .P_HANDLE,
	OLD_CHAR1	= .P_OLD_CHARACTERISTICS1,
	OLD_CHAR2	= .P_OLD_CHARACTERISTICS2;

EXTERNAL LITERAL

	SMG$_NOT_A_TRM;		! Device is not a terminal (success)

LOCAL

	PBCB	: REF BLOCK[,BYTE],	! Pasteboard control block
	TTIOSB	: VECTOR[4,WORD],	! I/O status block
	EXIT_BLOCK			! Address of exit block
		: REF VECTOR[SMG$S_CHAR_EXIT_BLOCK/4],
	OLD_CHARBUF	: BLOCK[12,BYTE],	! Old characteristics buffer
	CHAR1,				! Old characteristics (part 1)
	CHAR2,				! Old characteristics (part 2)
	STATUS;

BUILTIN

	NULLPARAMETER;

EXTERNAL ROUTINE

	LIB$GET_VM;

!+
! Get the pasteboard control block from the pasteboard id.
!-

$SMG$GET_PBCB(.PBID,PBCB);

!+
! Check that the output device is really a terminal.
! If it isn't then, return qualified success.
!-

IF .PBCB[PBCB_B_CLASS] NEQ DC$_TERM
  THEN	BEGIN
	IF NOT NULLPARAMETER(7)
	  THEN	OLD_CHAR1=0;

	IF NOT NULLPARAMETER(8)
	  THEN	OLD_CHAR2=0;

	RETURN	SMG$_NOT_A_TRM

	END;

!+
! Save the old characteristics buffer.
!-

CH$MOVE(12,PBCB[PBCB_R_CHARBUF],OLD_CHARBUF);

!+
! Get the old characteristics and return them to the user
! if he asked for them.
!-

CHAR1=.PBCB[PBCB_L_DEVDEPEND];
CHAR2=.PBCB[PBCB_L_DEVDEPEND2];

IF NOT NULLPARAMETER(7)
  THEN	OLD_CHAR1=.CHAR1;

IF NOT NULLPARAMETER(8)
  THEN	OLD_CHAR2=.CHAR2;

!+
! OR in the new characteristic bits requested on.
!-

IF NOT NULLPARAMETER(2)
  THEN	PBCB[PBCB_L_DEVDEPEND]=
		.PBCB[PBCB_L_DEVDEPEND] OR .ON_CHARACTERISTICS1;

IF NOT NULLPARAMETER(3)
  THEN	PBCB[PBCB_L_DEVDEPEND2]=
		.PBCB[PBCB_L_DEVDEPEND2] OR .ON_CHARACTERISTICS2;

!+
! AND out the characteristics bits requested off.
!-

IF NOT NULLPARAMETER(4)
  THEN	PBCB[PBCB_L_DEVDEPEND]=
		.PBCB[PBCB_L_DEVDEPEND] AND (NOT .OFF_CHARACTERISTICS1);

IF NOT NULLPARAMETER(5)
  THEN	PBCB[PBCB_L_DEVDEPEND2]=
		.PBCB[PBCB_L_DEVDEPEND2] AND (NOT .OFF_CHARACTERISTICS2);

!+
! Set the terminal to have the desired new characteristics.
!-

STATUS=$QIOW(	CHAN	= .PBCB[PBCB_W_CHAN],
		FUNC	= IO$_SETMODE,
		IOSB	= TTIOSB,
		P1	= PBCB[PBCB_R_CHARBUF],
		P2	= 12);
IF NOT .STATUS THEN RETURN .STATUS;
IF NOT .TTIOSB[0] THEN RETURN .TTIOSB[0];

!+
! Create an exit block to be used to set the characteristics back.
!-

STATUS=LIB$GET_VM(%REF(SMG$S_CHAR_EXIT_BLOCK),EXIT_BLOCK);
IF NOT .STATUS THEN RETURN .STATUS;

!+
! Give the user back the address of this exit block as the "handle".
!-

IF NOT NULLPARAMETER(6)
  THEN	HANDLE=.EXIT_BLOCK;

!+
! Set up the exit block.
!-

EXIT_BLOCK[0]=0;		! reserved for use by VMS as forward link
EXIT_BLOCK[1]=CHAR_EXIT_HANDLER;! specify our exit handler
EXIT_BLOCK[2]=6;		! six arguments
EXIT_BLOCK[3]=EXIT_BLOCK[4];	! Store reason in next entry in exit block
EXIT_BLOCK[4]=0;		! Gets reason for exit
EXIT_BLOCK[5]=.PBCB[PBCB_W_CHAN]; ! Terminal channel
!+
! Longwords 6,7,8 form a 12-byte characteristics buffer.
!-
CH$MOVE(12,OLD_CHARBUF,EXIT_BLOCK[6]);

!+
! Declare an exit handler using this exit block.
!-

STATUS=$DCLEXH(	DESBLK=.EXIT_BLOCK);
IF NOT .STATUS THEN RETURN .STATUS;

RETURN SS$_NORMAL

END;

%SBTTL 'CHAR_EXIT_HANDLER - exit handler to reset terminal characteristics'
ROUTINE CHAR_EXIT_HANDLER(RSN_ADR,RSN,CHAN,CHARBUF : VECTOR[3,LONG]) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is established as an exit handler.
!	It restores the terminal to it's previous characteristics.
!
! CALLING SEQUENCE:
!
!       RET_STATUS.wlc.v = CHAR_EXIT_HANDLER( P_EXIT_BLOCK.rab.r)
!
! FORMAL PARAMETERS:
!
!	P_EXIT_BLOCK.rab.r	Exit block as set up by
!				SMG$$SET_TERMINAL_CHARACTERISTICS
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!       SS$_NORMAL      Normal successful completion
!
!		Errors are ignored.
!
! SIDE EFFECTS:
!
!	Previous terminal characteristics are restored
!
!--

BEGIN

BIND

	CLASS		= CHARBUF	: BYTE;

LOCAL

	STATUS;

!+
! Verify that the device class to be restored is DC$_TERM.
! If not, just go away.
! Give no error, since this is an exit handler.
! If it is a terminal, then restore the old characteristics.
!-

IF .CLASS EQL DC$_TERM
  THEN	$QIOW(	CHAN	= .CHAN,
		FUNC	= IO$_SETMODE,
		P1	= CHARBUF,
		P2	= 12);

RETURN	SS$_NORMAL

END;

END
ELUDOM
