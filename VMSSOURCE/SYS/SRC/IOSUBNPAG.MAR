	.TITLE	IOSUBNPAG - NONPAGED I/O RELATED SUBROUTINES
	.IDENT	'V04-000'
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; D. N. CUTLER 13-JUN-76
;
;
; NONPAGED I/O RELATED SUBROUTINES
;
; MODIFIED BY:
;
;	V03-038	WMC0004		Wayne Cardoza		23-Aug-1984
;		Add routine for emergency message to console.
;
;	V03-037	WMC0003		Wayne Cardoza		14-Aug-1984
;		Fix ROW0409 to restore the correct register.
;
;	V03-036	ACG0442		Andrew C. Goldstein,	7-Aug-1984  17:52
;		Save R8 in IOC$LAST_CHAN; fix order of tests in IOC$TESTUNIT
;		for correct allocation and mount checks. Fix handling of
;		lock value block on device lock in IOC$TESTUNIT.
;
;	V03-035	ROW0409		Ralph O. Weber		 6-AUG-1984
;		Fix release map registers processing of requests waiting for 
;		map registers.  Restore saved fork registers -- including the 
;		PDT address -- before the calling IOC$ALOMAPUDA at 
;		REALLOC_CD_MAPREGS.
;
;	V03-034	TCM0006		Trudy C. Matthews	20-Jul-1984
;		Add routine IOC$THREADCRB.
;
;	V03-033	WMC0002		Wayne Cardoza		03-May-1984
;		Add support for MNTVERPND bit.
;
;	V03-032	RAS0300		Ron Schaefer		 2-May-1984
;		Change IOC$CVT_DEVNAM to only prefix cluster node names if
;		the DEV$V_NNM device characteristic is set in UCB$L_DEVCHAR2.
;		Add additional itemcode (4) to IOC$CVT_DEVNAM to provide
;		the device name string sans unit number.
;
;	V03-031	TMK0001		Todd M. Katz		23-Apr-1984
;		Remove the $LOGDEF data definitions.
;
;	V03-030	RLRPDTADP	Robert L. Rappaport	9-Apr-1984
;		Modify entrypoints used for allocating and deallocating
;		Buffered Data Paths and UNIBUS Map Registers for UQPORTS (UDA),
;		to pickup pointer for ADP from PDT$L_ADP(R4).
;
;	V03-029	ACG0414		Andrew C. Goldstein,	30-Mar-1984  15:49
;		Minor parse and searching fixes in IOC$SEARCH...
;		add IOC$V_ALLOC to force allocation
;
;	V03-028	ACG0406		Andrew C. Goldstein,	16-Mar-1984  15:42
;		Fix bugs in searching for allocation class
;
;	V03-027	ACG0399		Andrew C. Goldstein,	24-Feb-1984  22:28
;		Add IOC$LAST_CHAN subroutine, and move in internal I/O
;		database parse and search routines, so they can be called
;		by IPC.
;
;	V03-026	RLRMAPSP	Robert L. Rappaport	15-Feb-1984
;		Correct bug in BEQL destination in IOC$ALOUBAMAPSP that is
;		only triggered if the range specified, coincides with the
;		exact end of an extent of map registers.
;
;	V03-025	ROW0292		Ralph O. Weber		 4-FEB-1984
;		Fix branch displacements broken by movement of EXE$MOUNTVER to 
;		SYSLOAxxx.
;
;	V03-024	KPL0001		Peter Lieberwirth	 7-Nov-1983
;		Add paths for new processors to CPUDISP invocation.
;
;	V03-023	ROW0244		Ralph O. Weber		17-OCT-1983
;		Change the IOC$CVT_DEVNAM name string formation rules to 
;		eliminate _$1$TTA0: and other allocation class based names 
;		for devices which can never be dual pathed.  See routine 
;		comments for details of current operation mode.
;
;	V03-022	ROW0239		Ralph O. Weber		11-OCT-1983
;		Fix IOC$CVT_DEVNAM to not insert node name or trailing dollar 
;		sign when node name is null.  Also correct comments describing 
;		the R4 argument to IOC$CVT_DEVNAM.
;
;	V03-021	ROW0234		Ralph O. Weber		 5-OCT-1983
;		Change IOC$CVT_DEVNAM to produce $allocation-class$device 
;		strings completely in ASCII, when allocation class output is 
;		requested.  In the process rip up the whole thing because that 
;		was the only way to get something that worked and didn't 
;		occupy all non-page memory
;
;	V03-020	TCM0005		Trudy C. Matthews	 5-OCT-1983
;		Add IOC$SCAN_IODB_2P which is functionally the same as 
;		IOC$SCAN_IOCB except that both primary and secondary paths to 
;		a device are scanned.
;
;	V03-019	KDM0084		Kathleen D. Morse	26-Sep-1983
;		Added MicroVAX I support to CPUDISP macros.
;
;	V03-018	ROW0221		Ralph O. Weber		 8-SEP-1983
;		Change IOC$UNITINIT to look for a unit initialization routine 
;		in the DDT before looking in the CRB.  See the note in the 
;		routine's header for details.
;
;	V03-017	ROW0203		Ralph O. Weber		 5-AUG-1983
;		Add two new routines IOC$CTRLINIT and IOC$UNITINIT.  These are 
;		the proscribed mechanism for calling device driver controller 
;		and unit initialization routines.  These routines correctly 
;		setup for, locate, and call the appropriate driver routines.
;
;	V03-016	TCM0004		Trudy C. Matthews	26-Jul-1983
;		Change IOC$CVT_DEVNAM to return the <allocation_class>+
;		<devnam> form of device name if R4 > 0.
;
;	V03-015	RLRBYTEOFF	Robert L. Rappaport	27-Jun-1983
;		Correct error in IOC$REQDATAPUDA.  Error is that this
;		routine has operated in a NOWAIT mode, that is, if no
;		Buffered Datapath was available, we just used the
;		Direct Datapath.  Unfortunately, this doesn't work on
;		780's and 790's if the user buffer is located at an
;		odd byte address since Byte Offset doesn't work on the
;		Direct Datapath for the UNIBUS Adapters on these
;		processors.
;
;	V03-014	LMPBUILD	L. Mark Pilant,		26-Jun-1983  23:11
;		Change references from TTY$K_WB_HDRLEN to TTY$K_WB_LENGTH.
;
;	V03-013	TCM0003		Trudy C. Matthews	17-Jun-1983
;		Change the way cluster-style device names are conditionally
;		returned, such that cluster-style names are returned for
;		local disk devices if the system is participating in a
;		cluster (routine IOC$CVT_DEVNAM).
;
;	V03-012	TCM0002		Trudy C. Matthews	09-Jun-1983
;		Fix bug in TCM0001.
;
;	V03-011	TCM0001		Trudy C. Matthews	21-Apr-1983
;		Add new parameter to IOC$CVT_DEVNAM that allows caller
;		to specify whether he wants the node name returned for
;		local devices or not.
;
;	V03-010	ROW0188		Ralph O. Weber		30-APR-1983
;		Fix broken branches to PMS$ routines.
;
;	V03-009	KTA3022		Kerbey T. Altmann	29-Dec-1982
;		Enhance KTA3018. Add new routine to scan the IO
;		data base and return the blocks.
;
;	V03-008	ROW0140		Ralph O. Weber		18-NOV-1982
;		Cause IOC$DALOCUBAMAP to give non-fatal INCONSTATE, 
;		"Inconsistant UBA data base" bugcheck if number of map 
;		registers to deallocate is zero.
;
;	V03-007	MLJ0101		Martin L. Jack		11-Nov-1982
;		Add $SBDEF.
;
;	V03-006	KTA3018		Kerbey T. Altmann	01-Nov-1982
;		Modify CVT_DEVNAME for new IO database.
;
;	V03-005	ROW0130		Ralph O. Weber		 5-OCT-1982
;		Remove IOC$DELMBX whose functionality is replaced by new 
;		routines in module UCBCREDEL.
;
;	V03-004	KDM0002		Kathleen D. Morse	28-Jun-1982
;		Added $DCDEF.
;
;	V03-003	RLR0003		Robert L. Rappaport	1-June-1982
;		Correct errors in UNIBUS map register allocation and
;		deallocation that occur when the number of active
;		descriptors is zero.  Errors were in IOC$ALOUBAMAPSP
;		(allocation error), IOC$ALOUBAPRM (allocation error),
;		and IOC$DALOCUBAMAP (deallocation error).  The error
;		in IOC$DALOCUBAMAP is corrected in a patch to V3.1.
;
;	V03-002	RLR0002		Robert L. Rappaport	22-May-1982
;		Remove IOC$REQMAPREGN and all comments that reference it.
;
;	V03-001	RLR0001	Robert L. Rappaport	22-May-1982
;		Correct error in UNIBUS map register allocation that
;		doubly allocated registers when the number of active
;		descriptors was zero.
;		This bug corrected in patch to V3.1.
;

;
;
; MACRO LIBRARY CALLS
;
 
	$ADPDEF				;DEFINE ADP OFFSETS
	$CADEF				;DEFINE CONDITIONAL ASSEMBLY PARAMETERS
	$CANDEF				;DEFINE CANCEL I/O REASON CODES
	$CDRPDEF			;DEFINE CLASS DRIVER I/O REQUEST PACKET
	$CRBDEF				;DEFINE CRB OFFSETS
	$DCDEF				;DEFINE DEVICE CLASSES
	$DDBDEF				;DEFINE DDB OFFSETS
	$DDTDEF				;DEFINE DDT OFFSETS
	$DEVDEF				;DEFINE DEVICE CHARACTERISTICS FLAGS
	$DYNDEF				;DEFINE DYNAMIC POOL BLOCK TYPES
	$EMBDEF				;DEFINE EMB OFFSETS
	$IDBDEF				;DEFINE IDB OFFSETS
	$IOCDEF				;DEFINE IOC$SEARCHxxx FLAGS
	$IPLDEF				;DEFINE INTERRUPT PRIORITY LEVELS
	$IRPDEF				;DEFINE IRP OFFSETS
	$JIBDEF				;DEFINE JIB OFFSETS
	$LCKDEF				;DEFINE LOCK MANAGER SYMBOLS
	$MSCPDEF			;DEFINE MSCP STRUCTURES
	$PCBDEF				;DEFINE PCB OFFSETS
	$PDTDEF				;Define PDT offsets
	$PRDEF				;DEFINE PROCESSOR REGISTERS
	$PRVDEF				;DEFINE PRIVILEGE BITS
	$SBDEF				; Define system block offsets
	$SSDEF				;DEFINE SYSTEM STATUS CODES
	$TTYDEF				;DEFINE TERMINAL WRITE PACKET OFFSETS
	$UBMDDEF			;Define UNIBUS Map Descriptor structure
	$UCBDEF				;DEFINE UCB OFFSETS
	$VECDEF				;DEFINE CRB VECTOR OFFSETS

	.SBTTL	CANCEL I/O ON CHANNEL
;+
; IOC$CANCELIO - CANCEL I/O ON CHANNEL
;
; THIS ROUTINE IS A DEVICE INDEPENDENT CANCEL I/O ROUTINE THAT CONDITIONALLY
; MARKS THE UCB SUCH THAT THE CURRENT I/O REQUEST WILL BE CANCELED IF CONDITIONS
; WARRANT SUCH A ACTION.
;
; INPUTS:
;
;	R2 = NEGATIVE OF THE CHANNEL NUMBER.
;	R3 = CURRENT IO PACKET.
;	R4 = PCB ADDRESS.
;	R5 = UCB ADDRESS.
;
; OUTPUTS:
;
;	IF THE DEVICE IS BUSY, THE REQUEST IS FOR THE CURRENT PROCESS, AND
;	THE I/O WAS ISSUED FROM THE DESIGNATED CHANNEL, THEN THE CANCEL I/O
;	BIT IS SET IN THE CORRESPONDING UCB.
;
;	R2, R3, R4, AND R5 ARE PRESERVED ACROSS CALL.
;-
 
	.PSECT	WIONONPAGED
IOC$CANCELIO::				;CANCEL I/O ON CHANNEL
	BBC	#UCB$V_BSY,UCB$W_STS(R5),10$ ;IF CLR, DEVICE NOT BUSY
	CMPL	IRP$L_PID(R3),PCB$L_PID(R4) ;PROCESS ID MATCH?
	BNEQ	10$			;IF NEQ NO
	CMPW	R2,IRP$W_CHAN(R3)	;CHANNEL NUMBER MATCH
	BNEQ	10$			;IF NEQ NO
	BISW	#UCB$M_CANCEL,UCB$W_STS(R5) ;SET CANCEL PENDING
10$:	RSB				;

	.SBTTL	Handle Last Channel Deassign

;+
; IOC$LAST_CHAN - Last Channel Deassign Specific
; IOC$LAST_CHAN_AMBX - Last Assoc. MBX Channel Deassign Specific
;
; Functional Description:
;
;	Common functions done on last channel deassignment are handled.  The 
;	driver's cancel I/O routine is called with an appropriate reason code 
;	(CAN$C_DASSGN for regular deassign, or CAN$C_AMBXDGN for associated 
;	mailboxes).  If after the cancel routine finished UCB$V_DELETEUCB is 
;	set, the UCB is credited and deleted.
;
; Inputs:
;
;	R5	UCB address
;	R2	Channel index (LAST_CHAN only)
;
; Outputs:
;
;	R0 thru R3 destroyed.
;	If appropriate, UCB is deallocated.
;
;-

	.ENABLE	LSB

IOC$LAST_CHAN_AMBX::
	PUSHL	R8			; Save R8
	CLRQ	R2			; Clear unused cancel inputs.
	MOVZBL	#CAN$C_AMBXDGN, R8	; Set cancel reason code.
	BRB	10$

IOC$LAST_CHAN::
	PUSHL	R8			; Save R8
	MOVL	UCB$L_IRP(R5), R3	; Get active packet address.
	MOVZBL	#CAN$C_DASSGN, R8	; Set cancel reason code.

10$:	MOVL	UCB$L_DDT(R5), R0	; Get DDT address.
	SETIPL	UCB$B_FIPL(R5)		; Raise to fork IPL.
	JSB	@DDT$L_CANCEL(R0)	; Call driver's cancel I/O routine.
	SETIPL	#IPL$_ASTDEL		; Lower IPL.
	BBS	#DEV$V_ALL, -		; Branch if still allocated
		UCB$L_DEVCHAR(R5),30$
	BITL	#DEV$M_TRM!DEV$M_MBX, -	; Is this a terminal, remote terminal 
		UCB$L_DEVCHAR(R5)	; or mailbox?
	BEQL	20$			; Branch if not.
	BBSC	#DEV$V_OPR, -		; Else, clear OPR bit.
		UCB$L_DEVCHAR(R5), 20$	; This is an implicit operator disable.
20$:	BBC	#UCB$V_DELETEUCB,-	; Branch if UCB not to be deleted.
		UCB$L_STS(R5), 30$
	BSBW	IOC$CREDIT_UCB		; Else credit UCB quotas,
	BSBW	IOC$DELETE_UCB		; and delete the UCB.
30$:	POPL	R8			; Restore R8
	RSB

	.DISABLE LSB

	.SBTTL	FILL DIAGNOSTIC BUFFER
;+
; IOC$DIAGBUFILL - FILL DIAGNOSTIC BUFFER
;
; THIS ROUTINE IS CALLED AT THE END OF AN I/O OPERATION, BUT BEFORE RELEASING
; THE I/O CHANNEL, TO FILL THE FINAL DEVICE PARAMETERS INTO AN INTERNAL DIAG-
; NOSTIC BUFFER IF ONE IS SPECIFIED.
;
; INPUTS:
;
;	R4 = ADDRESS OF DEVICE CSR REGISTER.
;	R5 = DEVICE UNIT UCB ADDRESS.
;
; OUTPUTS:
;
;	IF A DIAGNOSTIC BUFFER WAS SPECIFIED IN THE ORIGINAL REQUEST, THEN
;	THE COMPLETION TIME, FINAL ERROR COUNTERS, AND DEVICE REGISTERS ARE
;	FILLED INTO THE DIAGNOSTIC BUFFER.
;-
 
IOC$DIAGBUFILL::			;FILL DIAGNOSTIC BUFFER
	MOVL	UCB$L_IRP(R5),R3	;GET ADDRESS OF I/O PACKET
	BBC	#IRP$V_DIAGBUF,IRP$W_STS(R3),10$ ;IF CLR, NO DIAGNOSTIC BUFFER
	MOVL	@IRP$L_DIAGBUF(R3),R0	;GET ADDRESS OF INTERNAL BUFFER DATA AREA
	ADDL	#8,R0			;POINT PAST START TIME
	MOVQ	EXE$GQ_SYSTIME,(R0)+	;INSERT COMPLETION TIME
	MOVZWL	UCB$B_ERTCNT(R5),(R0)+	;INSERT FINAL ERROR COUNTERS
	MOVL	UCB$L_DDT(R5),R2	;GET ADDRESS OF DDT
	JSB	@DDT$L_REGDUMP(R2)	;CALL DEVICE SPECIFIC REGISTER DUMP ROUTINE
10$:	RSB				;

	.SBTTL	RELEASE I/O CHANNEL
;+
; IOC$RELCHAN - RELEASE ALL I/O CHANNELS
; IOC$RELSCHAN - RELEASE SECONDARY I/O CHANNEL
;
; THIS ROUTINE IS CALLED AT THE END OF AN I/O OPERATION TO RELEASE ALL
; CHANNELS THE I/O WAS BEING PERFORMED ON.
;
; INPUTS:
;
;	R5 = UCB ADDRESS OF DEVICE UNIT.
;
; OUTPUTS:
;
;	THE CHANNELS ARE RELEASED AND AN ATTEMPT IS MADE TO REMOVE THE NEXT
;	WAITING DRIVER PROCESS FROM EACH CHANNEL QUEUE. IF A DRIVER PROCESS
;	IS WAITING, THEN THE CHANNEL IS ASSIGNED TO THAT DRIVER PROCESS AND
;	IT IS CALLED VIA A JSB TO ITS CHANNEL WAIT RETURN ADDRESS. WHEN THE
;	CALLED DRIVER PROCESS RETURNS, A RETURN IS MADE TO THE DRIVER PROCESS
;	THAT RELEASED THE CHANNEL. IF THERE IS NO DRIVER PROCESS WAITING FOR
;	THE CHANNEL, THEN THE CHANNEL STATUS IS SET TO IDLE.
;
;	R3 AND R4 ARE PRESERVED ACROSS CALL.
;-
 
	.ENABL	LSB
IOC$RELSCHAN::				;RELEASE SECONDARY I/O CHANNEL
	MOVL	UCB$L_CRB(R5),R0	;GET ADDRESS OF PRIMARY CRB
	MOVL	CRB$L_LINK(R0),R0	;GET ADDRESS OF SECONARY CRB
	BRB	20$			;
IOC$RELCHAN::				;RELEASE I/O CHANNEL
	MOVL	UCB$L_CRB(R5),R0	;GET ADDRESS OF PRIMARY CRB
	MOVL	CRB$L_LINK(R0),R0	;GET ADDRESS OF SECONDARY CRB
	BEQL	10$			;IF EQL NONE
	BSBB	20$			;RELEASE SECONDARY CHANNEL
10$:	MOVL	UCB$L_CRB(R5),R0	;GET ADDRESS OF PRIMARY CRB
20$:	BBC	#CRB$V_BSY,CRB$B_MASK(R0),30$ ;IF CLR, THEN CHANNEL NOT BUSY
	MOVL	CRB$L_INTD+VEC$L_IDB(R0),R1 ;GET ADDRESS OF IDB
	CMPL	R5,IDB$L_OWNER(R1)	;DRIVER PROCESS OWN CHANNEL?
	BNEQ	30$			;IF NEQ NO
	REMQUE	@CRB$L_WQFL(R0),R2	;GET ADDRESS OF NEXT DRIVER FORK BLOCK
	BVS	40$			;IF VS NO DRIVER PROCESS WAITING
	PUSHR	#^M<R3,R4,R5>		;SAVE CONTEXT OF CURRENT DRIVER PROCESS
	MOVL	R2,R5			;COPY ADDRESS OF DRIVER PROCESS FORK BLOCK
	MOVL	UCB$L_FR3(R5),R3	;LOAD WAITING DRIVER PROCESS CONTEXT
	MOVL	IDB$L_CSR(R1),R4	;SET ASSIGNED CHANNEL CSR ADDRESS
	MOVL	R5,IDB$L_OWNER(R1)	;SET ADDRESS OF OWNER PROCESS UCB
	JSB	@UCB$L_FPC(R5)		;CALL DRIVER AT CHANNEL WAIT RETURN ADDRESS
	POPR	#^M<R3,R4,R5>		;RESTORE PREVIOUS DRIVER PROCESS CONTEXT
30$:	RSB				;
40$:	CLRL	IDB$L_OWNER(R1)		;CLEAR OWNER UNIT UCB ADDRESS
	BICB	#CRB$M_BSY,CRB$B_MASK(R0) ;CLEAR CHANNEL BUSY
	RSB				;
	.DSABL	LSB

	.SBTTL	REQUEST I/O CHANNEL
;+
; IOC$REQPCHANH - REQUEST PRIMARY I/O CHANNEL HIGH PRIORITY
; IOC$REQSCHANH - REQUEST SECONDARY I/O CHANNEL HIGH PRIORITY
; IOC$REQPCHANL - REQUEST PRIMARY I/O CHANNEL LOW PRIORITY
; IOC$REQSCHANL - REQUEST SECONDARY I/O CHANNEL LOW PRIORITY
;
; THESE ROUTINES ARE CALLED TO REQUEST AN I/O CHANNEL TO PERFORM AN I/O
; OPERATION ON.
;
; INPUTS:
;
;	R5 = UCB ADDRESS OF DEVICE UNIT.
;	04(SP) = RETURN ADDRESS OF CALLER'S CALLER.
;
; OUTPUTS:
;
;	IF THE SPECIFIED I/O CHANNEL IS IDLE, THEN IT IS IMMEDIATELY
;	ASSIGNED TO THE CURRENT DRIVER PROCESS. ELSE THE DRIVER PROCESS
;	CONTEXT IS SAVED IN ITS FORK BLOCK, THE FORK BLOCK IS INSERTED
;	IN THE CHANNEL WAIT QUEUE, AND A RETURN TO THE DRIVER PROCESS'
;	CALLER IS EXECUTED.
;
;	WHEN THE CHANNEL IS ASSIGNED, THE CSR ADDRESS OF THE ASSIGNED
;	CONTROLLER IS RETURNED TO THE CALLER IN REGISTER R4.
;
;	R3 IS PRESERVED ACROSS CALL.
;-
 
	.ENABL	LSB
IOC$REQSCHANH::				;REQUEST SECONDARY I/O CHANNEL HIGH PRIORITY
	MOVL	UCB$L_CRB(R5),R0	;GET ADDRESS OF PRIMARY CRB
	MOVL	CRB$L_LINK(R0),R0	;GET ADDRESS OF SECONDARY CRB
	BRB	10$			;
IOC$REQSCHANL::				;REQUEST SECONDARY I/O CHANNEL LOW PRIORITY
	MOVL	UCB$L_CRB(R5),R0	;GET ADDRESS OF PRIMARY CRB
	MOVL	CRB$L_LINK(R0),R0	;GET ADDRESS OF SECONDARY CRB
	BRB	20$			;
IOC$REQPCHANH::				;REQUEST PRIMARY I/O CHANNEL HIGH PRIORITY
	MOVL	UCB$L_CRB(R5),R0	;GET ADDRESS OF PRIMARY CRB
10$:	MOVL	R0,R2			;SET ADDDRESS OF WAIT QUEUE LISTHEAD
	BRB	30$			;
IOC$REQPCHANL::				;REQUEST PRIMARY I/O CHANNEL LOW PRIORITY
	MOVL	UCB$L_CRB(R5),R0	;GET ADDRESS OF PRIMARY CRB
20$:	MOVL	CRB$L_WQBL(R0),R2	;GET ADDRESS OF LAST ENTRY IN QUEUE
30$:	MOVL	CRB$L_INTD+VEC$L_IDB(R0),R1 ;GET ADDRESS OF IDB
	BBSS	#CRB$V_BSY,CRB$B_MASK(R0),40$ ;IF SET, THEN CHANNEL BUSY
	MOVL	IDB$L_CSR(R1),R4	;SET ASSIGNED CHANNEL CSR ADDRESS
	MOVL	R5,IDB$L_OWNER(R1)	;SET OWNER UCB ADDRESS
	RSB				;
40$:	MOVL	R3,UCB$L_FR3(R5)	;SAVE R3 IN FORK BLOCK
	POPL	UCB$L_FPC(R5)		;SAVE CHANNEL WAIT RETURN ADDRESS
	INSQUE	UCB$L_FQFL(R5),CRB$L_WQFL(R2) ;INSERT DRIVER PROCESS IN CHANNEL WAIT QUEUE
	CMPL	R5,IDB$L_OWNER(R1)	;CURRENT DRIVER PROCESS OWNER?
	BNEQ	50$			;IF NEQ, BRANCH TO RETURN
	BRW	IOC$RELCHAN		;IF EQL BRW TO RELEASE CHANNELS
50$:
	RSB				;
	.DSABL	LSB

	.SBTTL	I/O Request Completion Processing for Class Drivers

;+
; IOC$ALTREQCOM - I/O Request Complete Alternate Entry.
;
; This routine is entered when an I/O operation is completed on one
;	one of the devices using the disk or tape class drivers.
;	The packet is inserted in the I/O finish queue for I/O post
;	processing.
;
; INPUTS:
;
;	R0 = First  longword of I/O status
;	R1 = Second longword of I/O status
;	R5 = CDRP address
;
; OUTPUTS:
;
;	The I/O packet is inserted in the I/O Post Processing Queue,
;	a Software interrupt is requested to initiate I/O Post
;	Processing.
;-

IOC$ALTREQCOM::
	MOVAB	CDRP$L_IOQFL(R5),R3	; R3 => IRP section of CDRP. This is
					;  for compatibility with rest of QIO
					;  logic.
	MOVL	IRP$L_UCB(R3),R5	; R5 => UCB.
	INCL	UCB$L_OPCNT(R5)		; Increment operations completed
 
	BLBC	R0,20$			; LBC implies I/O error, so goto call
					;  MOUNT VERIFICATION just in case.
10$:
	MOVQ	R0,IRP$L_MEDIA(R3)	; Save final I/O status in IRP.

	.IF DF	CA$_MEASURE_IOT
 
	JSB	G^PMS$END_IO		; Insert end of I/O transaction message
 
	.ENDC
 
	INSQUE	(R3),@L^IOC$GL_PSBL	; Insert packet in POST process queue
	SOFTINT	#IPL$_IOPOST		; Initiate SOFTWARE INTERRUPT
	RSB
20$:
	JSB	G^EXE$MOUNTVER		; If LBC, call MOUNT VERIFICATION.
	BRB	10$			; Go back to normal flow.

	.SBTTL	I/O REQUEST COMPLETION PROCESSING
;+
; IOC$REQCOM - I/O REQUEST COMPLETE
;
; THIS ROUTINE IS ENTERED WHEN AN I/O OPERATION IS COMPLETED ON A
; DEVICE UNIT. THE FINAL I/O STATUS IS STORED IN THE ASSOCIATED I/O
; PACKET AND THE PACKET IS INSERTED IN THE I/O FINISH QUEUE FOR
; I/O POST PROCESSING. DEVICE UNIT BUSY IS CLEARED AND AN ATTEMPT
; IS MADE TO START ANOTHER I/O REQUEST ON THE DEVICE UNIT.
;
; IF THE I/O REQUEST COMPLETED WITH AN ERROR, AND THE DEVICE IS
; A DISK, THEN BRANCH TO THE MOUNT VERIFICATION CODE, WHICH WILL
; DETERMINE IF THE SITUATION REQUIRES MOUNT VERIFICATION.
;
; IF MOUNT VERIFICATION IS IN PROGRESS, NO FURTHER I/O REQUESTS WILL
; BE INITIATED.  THIS HAS A SIDE EFFECT OF KEEPING THE 'BSY' BIT IN
; WHATEVER STATE IT IS CURRENTLY IN.  FOR CONVENTIONAL DISK DRIVERS,
; THE BSY BIT WILL BE LEFT ON, WHICH WILL BLOCK $QIO FROM INITIATING
; ANY NEW I/O ON THE DEVICE.  FOR THE DISK CLASS DRIVER, THE BUSY 
; BIT WILL BE OFF, WHICH WILL ALLOW $QIO TO INITIATE NEW I/O.
;
; INPUTS:
;
;	R0 = FIRST LONGWORD OF I/O STATUS.
;	R1 = SECOND LONGWORD OF I/O STATUS.
;	R5 = UCB ADDRESS OF DEVICE UNIT.
;
; OUTPUTS:
;
;	THE I/O PACKET IS INSERTED IN THE I/O POST PROCESSING QUEUE
;	AND DEVICE UNIT BUSY IS CLEARED. A SOFTWARE INTERRUPT IS
;	REQUESTED TO INITIATE I/O POST PROCESSING.
;-
 
	.ENABL	LSB
IOC$REQCOM::				;I/O DONE PROCESSING
	BBCC	#UCB$V_ERLOGIP,UCB$W_STS(R5),10$ ;IF CLR, ERROR LOG NOT IN PROGRESS
	MOVL	UCB$L_EMB(R5),R2	;GET ADDRESS OF ERROR MESSAGE BUFFER
	MOVW	UCB$W_STS(R5),EMB$W_DV_STS(R2) ;INSERT FINAL DEVICE STATUS
	MOVW	UCB$B_ERTCNT(R5),EMB$B_DV_ERTCNT(R2) ;INSERT FINAL ERROR COUNTERS
	MOVQ	R0,EMB$Q_DV_IOSB(R2)	;INSERT FINAL I/O STATUS
	PUSHL	R0			;SAVE R0
	BSBW	ERL$RELEASEMB		;RELEASE ERROR MESSAGE BUFFER
	POPL	R0			;RESTORE R0
10$:	MOVL	UCB$L_IRP(R5),R3	;GET ADDRESS OF I/O PACKET
	INCL	UCB$L_OPCNT(R5)		;INCREMENT OPERATIONS COMPLETED
	BLBC	R0,DISKCHK		;IF I/O ERROR, CHECK FOR DISK DEVICE
;
; DO NOT SAVE THE I/O STATUS IN THE IRP UNTIL IT HAS BEEN DECIDED THAT
; MOUNT VERIFICATION IS NOT NECESSARY.  THIS IS TO AVOID OVERWRITING THE
; PHYSICAL DISK ADDRESS STORED IN THE IRP AT OFFSET IRP$L_MEDIA.
;
20$:	MOVQ	R0,IRP$L_MEDIA(R3)	;STORE FINAL I/O STATUS
 
	.IF DF	CA$_MEASURE_IOT
 
	TSTL	L^PMS$GL_IOPFMPDB	;DATA COLLECTION ENABLED?
	BNEQ	DO_PMS			;BRANCH IF YES
 
	.ENDC

PMSEND:	INSQUE	(R3),@L^IOC$GL_PSBL	;INSERT PACKET IN POST PROCESS QUEUE
	SOFTINT	#IPL$_IOPOST		;INITIATE SOFTWARE INTERRUPT
	BBS	#UCB$V_MNTVERIP,-	;BRANCH IF MOUNT VERIFICATION IN PROGRESS
		UCB$W_STS(R5),MNTVERPNDCHK ;(NOTE THIS LEAVES 'BSY' AS IS)
NXTIRP:	REMQUE	@UCB$L_IOQFL(R5),R3	;REMOVE I/O PACKET FROM DEVICE UNIT QUEUE
	BVC	IOC$INITIATE		;IF VC INITIATE NEXT FUNCTION
	BICW	#UCB$M_BSY,UCB$W_STS(R5) ;CLEAR UNIT BUSY
RELEASE:				;RELEASE ALL CHANNELS
	BRW	IOC$RELCHAN		;
;
; IF THIS IS A DISK DEVICE, CALL THE MOUNT VERIFICATION ROUTINE
; TO DETERMINE IF MOUNT VERIFICATION IS NECESSARY.  IF NOT, CONTROL
; WILL RETURN, AND THE REQUEST WILL BE COMPLETED IN THE NORMAL MANNER.
;
DISKCHK:
	CMPB	#DC$_DISK,-		;IS THIS DEVICE A DISK?
		UCB$B_DEVCLASS(R5)	;
	BNEQ	20$			;BRANCH IF NOT
	BBCC	#UCB$V_MNTVERPND,-	;CHECK FOR MOUNT VERIFICATION PENDING
		UCB$L_STS(R5),30$	;IF NOT, JUST ENTER MOUNT VERIFICATION
	BBCC	#UCB$V_MNTVERIP,-	;CLEAR IN-PROGRESS BIT BEFORE CALL
		UCB$L_STS(R5),30$	; SO IT WILL REALLY START
30$:	JSB	G^EXE$MOUNTVER		;START MOUNT VERIFICATION
	BRB	20$			;COMPLETE I/O REQUEST

	.IF DF	CA$_MEASURE_IOT

DO_PMS:	JSB	G^PMS$END_IO		;INSERT END OF I/O TRANSACTION MESSAGE
	BRB	PMSEND			;REJOIN COMMON CODE

	.ENDC
;
; THE MOUNT-VERIFICATION-PENDING BIT IS USED TO INDICATE THAT A DISK SHOULD GO
; INTO MOUNT VERIFICATION AS SOON AS THE CURRENT I/O IS DONE.  THIS IS INTENDED
; FOR USE IN A CLUSTER TO STALL I/O WHEN QUORUM IS LOST.
;
MNTVERPNDCHK:
	BBCC	#UCB$V_MNTVERPND,-	;CHECK FOR MOUNT VERIFICATION PENDING
		UCB$L_STS(R5),RELEASE	;IF NOT, JUST CLEAN UP
	CMPB	#DC$_DISK,-		;IS THIS DEVICE A DISK?
		UCB$B_DEVCLASS(R5)	;
	BNEQ	RELEASE			;BRANCH IF NOT
	BBCC	#UCB$V_MNTVERIP,-	;CLEAR IN-PROGRESS BIT BEFORE CALL
		UCB$L_STS(R5),40$
40$:	CLRL	R3			;NO IRP PASSED TO MOUNT VERIFICATION
	JSB	G^EXE$MOUNTVER		;TRY TO START MOUNT VERIFICATION
	BRB	NXTIRP			;WASN'T NECESSARY

	.DSABL	LSB

	.SBTTL	MOUNT VERIFICATION HELPER
;++
; IOC$MNTVER	- Assist driver with mount verification.
;
; This routine is called by EXE$MOUNTVER to perform some driver-specific
; actions necessary for mount verification.  This routine is used by non-
; CLASS drivers, and is called by default if EXE$MOUNTVER finds the address
; of IOC$RETURN in DDT$L_MNTVER.
;
; Inputs:
;
;	R3	= IRP address or 0
;	R5	= UCB address
;
; Outputs:
;
;	None.
;
; Side effects:
;
;	If R3 contains an IRP address, the IRP will be queued to the
;	head of the UCB's IRP work queue.  If R3 contains is zero, then
;	remove the IRP from the head of the UCB's work queue and attempt
;	to initiate the I/O.
;--

IOC$MNTVER::				;Driver-specific mount verification code
	TSTL	R3			;Check IRP address
	BEQL	NXTIRP			;Branch if none
	INSQUE	IRP$L_IOQFL(R3),-	;Requeue the IRP
		UCB$L_IOQFL(R5)		;
	RSB				;Return

	.SBTTL	INITIATE I/O FUNCTION ON DEVICE
;+
; IOC$INITIATE - INITIATE NEXT FUNCTION ON DEVICE
;
; THIS ROUTINE IS CALLED TO INITIATE THE NEXT FUNCTION ON A DEVICE BY CLEARING
; STATUS BITS, SETTING THE OPERATION START TIME IF A DIAGNOSTIC BUFFER IS
; SPECIFIED, AND CALLING THE DRIVER AT ITS START I/O ENTRY POINT.
;
; INPUTS:
;
;	R3 = ADDRESS OF I/O REQUEST PACKET.
;	R5 = DEVICE UNIT UCB ADDRESS.
;
; OUTPUTS:
;
;	CANCEL I/O, POWERFAIL, AND TIME OUT STATUS BITS ARE CLEARED, THE
;	CURRENT SYSTEM TIME IS FILLED INTO THE INTERNAL DIAGNOSTIC BUFFER
;	IF ONE IS SPECIFIED, AND THE DRIVER IS CALLED AT ITS START I/O ENTRY
;	POINT.
;-
 
IOC$INITIATE::				;INITIATE I/O FUNCTION
	MOVL	R3,UCB$L_IRP(R5)	;SAVE I/O PACKET ADDRESS
 
	.IF DF	CA$_MEASURE_IOT
 
	JSB	G^PMS$START_IO		;INSERT START OF I/O TRANSACTION MESSAGE
 
	.ENDC
 
	MOVQ	IRP$L_SVAPTE(R3),UCB$L_SVAPTE(R5) ;COPY TRANSFER PARAMETERS
	BICW	#UCB$M_CANCEL!UCB$M_TIMOUT,UCB$W_STS(R5) ;CLEAR CANCEL AND TIME OUT
	BBC	#IRP$V_DIAGBUF,IRP$W_STS(R3),10$ ;IF CLR, NO DIAGNOSTIC BUFFER
	MOVL	@IRP$L_DIAGBUF(R3),R0	;GET ADDRESS OF DIAGNOSTIC BUFFER DATA AREA
	MOVQ	EXE$GQ_SYSTIME,(R0)	;INSERT I/O OPERATION START TIME
10$:	MOVL	UCB$L_DDT(R5),R0	;GET ADDRESS OF DRIVER DISPATCH TABLE
	JMP	@DDT$L_START(R0)	;START I/O OPERATION

	.SBTTL	Allocate Buffered Data Path
;+
; ALLOCATE BUFFERED DATA PATH CODE -
;
; IOC$REQDATAP - Entrypoint (called from traditional drivers) where caller
;	wishes to be queued (using UCB fork block) if no buffered data path
;	is available at the time of the call.
; INPUT:
;		R5 => UCB.
;
; IOC$REQDATAPNW - Entrypoint to call when caller does not want to wait for
;	unavailable data path.
; INPUT:
;		R5 => UCB
;
; IOC$REQDATAPUDA - Entrypoint (called from UDA port driver) where CDRP
;	is used as the source of information about the request and where
;	the caller does not want to wait for unavailable datapath.
;
; INPUT:
;		R4 => PDT
;		R5 => CDRP
;-

IOC$REQDATAP::
	BSBB	IOC$REQDATAPNW		; Try to alloc. and get control after.
	BLBS	R0,10$			; LBS implies allocation success.

	MOVQ	R3,UCB$L_FR3(R5)	; Save driver context in UCB fork block.
	POPL	UCB$L_FPC(R5)		; Save caller's return point.
	INSQUE	UCB$L_FQFL(R5),-	; Queue fork block to resource wait queue.
		@ADP$L_DPQBL(R1)	;  Assumes IOC$ALODATAP saves R1=>ADP.
10$:	RSB				; Return to caller or caller's caller.

IOC$REQDATAPNW::
	MOVL	UCB$L_CRB(R5),R0		; R0=>CRB.
	MOVL	CRB$L_INTD+VEC$L_ADP(R0),R1	; R1=>ADP (pass to IOC$ALODATAP)
	MOVAB	CRB$L_INTD+VEC$W_MAPREG(R0),R2	; R2=>UBMD   "   "      "

	BRB	IOC$ALODATAP		; NOWAIT, RSB from IOC$ALODATAP
					;  returns to our caller.
IOC$REQDATAPUDA::
	MOVL	PDT$L_ADP(R4),R1	; R1=>ADP (pass to IOC$ALODATAP)
	MOVAB	CDRP$L_UBARSRCE(R5),R2	; R2=>UBMD   "   "      "

	BSBB	IOC$ALODATAP		; Call to allocate a data path.
	BLBS	R0,20$			; LBS means we got one.
	BLBC	CDRP$W_BOFF(R5),20$	; LBC means, user buffer is on an
					;  even byte address so we can use
					;  the Direct Data Path.

; Here we have a transfer to a user buffer located at an odd byte address.
; On those processors which support Byte Offset on the Direct Datapath, we
; can continue processing.  On other processors, we must wait for a buffered
; datapath.

	CPUDISP	<<780,10$>,-		; On 11-780 we wait.
		 <750,20$>,-		; On 11-750 we continue.
		 <730,20$>,-		; On 11-730 we continue.
		 <790,10$>,-		; On 11-790 we wait.
		 <8SS,10$>,-		; On SCORPIO we wait.
		 <8NN,10$>,-		; On NAUTILUS we wait.
		 <UV1,30$>>		; On MicroVAX we bugcheck.

10$:	MOVQ	R3,CDRP$L_FR3(R5)	; Save driver context in CDRP fork block.
	POPL	CDRP$L_FPC(R5)		; Save caller's return point.
	INCW	@CDRP$L_RWCPTR(R5)	; Increment RWAITCNT.
	INSQUE	CDRP$L_FQFL(R5),-	; Queue fork block to resource wait queue.
		@ADP$L_DPQBL(R1)	;  Assumes IOC$ALODATAP saves R1=>ADP.
20$:
	RSB				; Return to caller or caller's caller.

30$:	BUG_CHECK	IVBYTEALGN,FATAL

; IOC$ALODATAP - Common subroutine called by above routines to allocate
;	a UNIBUS buffered datapath.
;
; INPUTS:
;	R1 => ADP wherein the datapath allocation bit map is stored.
;	R2 => UBA mapping descriptor in user's data structure.
;
; OUTPUTS:
;	R0 LBS - implies allocation success
;		datapath field in R2 => UBA mapping descriptor is set to the
;			number of the datapath allocated.
;		appropriate bit in datapath allocation bit map is cleared.
;	R0 LBC - implies allocation failure.
;

IOC$ALODATAP:
	BBS	#VEC$V_PATHLOCK,-	; If this user has a permanently allocated
		UBMD$B_DATAPATH(R2),10$	;  datapath, branch around to success.

	ASSUME	ADP$C_NUMDATAP  EQ  16
	FFS	#0,-			; Find first available datapath,
		#ADP$C_NUMDATAP,-	;  according to bit map.  Note failure
		ADP$W_DPBITMAP(R1),-	;  leaves R0 with the value "16", an
		R0			;  even number with the low bit clear.
	BEQL	20$			; EQL implies failure.

	INSV	R0,-			; Upon success, R0 has number of the
		#VEC$V_DATAPATH,-	;  available datapath to allocate.
		#VEC$S_DATAPATH,-	;  So we update the user's datapath
		UBMD$B_DATAPATH(R2)	;  descriptor pointed at by R2.

	BBSC	R0,ADP$W_DPBITMAP(R1),10$; And we update the bit map.
	BUG_CHECK INCONSTATE		 ; We shouldn't be here obviously.

10$:	MOVL	S^#SS$_NORMAL,R0	; Indicate allocation success.
20$:	RSB				; And we return to our caller.

	.SBTTL	Release Buffered Data Path
;+
; RELEASE BUFFERED DATA PATH CODE -
;
; IOC$RELDATAPUDA - Entry point called from UDA port driver in response
;	to an UNMAP call.  Here the data as to the buffered data path
;	is in the CDRP.
;
; INPUTS:
;	R4 => PDT
;	R5 => CDRP
;
; IOC$RELDATAP - Entry point called from traditional drivers to release
;	the buffered datapath described in CRB$L_INTD+VEC$B_DATAPATH.
;
; INPUTS:
;	R5 => UCB
;
; OUTPUTS:
;	Datapath re-allocated (if any waiters). R0, R1, and R2 modified.
; NOTE: Since calls to IOC$REQDATAPUDA are NOWAIT, fork blocks dequeued
;	here from ADP$L_DPQFL are guaranteed to be UCB's.
;

IOC$RELDATAPUDA::
	MOVL	PDT$L_ADP(R4),R1	; R1 => ADP.
	MOVAB	CDRP$L_UBARSRCE(R5),R2	; R2 => UBMD.
	BRB	RELDATAP_COMMON
IOC$RELDATAP::
	MOVL	UCB$L_CRB(R5),R0		; R0 => CRB.
	MOVAB	CRB$L_INTD+VEC$W_MAPREG(R0),R2	; R2 => UBMD.
	MOVL	CRB$L_INTD+VEC$L_ADP(R0),R1	; R1 => ADP.
RELDATAP_COMMON:
	CVTBL	UBMD$B_DATAPATH(R2),R0		; Get datapath designator.
	BLEQ	10$				; If LSS permanent assignment.
						; If EQL we had NO datapath to
						;  release.
	INSV	#0,-				; Zero datapath number.
		#VEC$V_DATAPATH,#VEC$S_DATAPATH,-
		UBMD$B_DATAPATH(R2)
	EXTZV	#VEC$V_DATAPATH,-	; Extract datapath number.
		#VEC$S_DATAPATH,R0,R2	;
	REMQUE	@ADP$L_DPQFL(R1),R0	; R0 => next driver fork block
	BVS	20$			; If VS no driver process waiting

	MOVQ	R3,-(SP)		; Save R3, R4, R5
	PUSHL	R5
	MOVL	R0,R5			; R5 => driver fork block.
	CMPB	#DYN$C_UCB,-		; See if we dequeued a UCB or a CDRP.
		UCB$B_TYPE(R5)
	BNEQ	30$			; NEQ implies a CDRP.

; Here we have R5 => UCB.

	MOVL	UCB$L_CRB(R5),R1	; R1 => CRB.

	INSV	R2,-			; Store assigned datapath #
		#VEC$V_DATAPATH,-	;  in CRB.
		#VEC$S_DATAPATH,-
		CRB$L_INTD+VEC$B_DATAPATH(R1)

	MOVQ	UCB$L_FR3(R5),R3	; Restore driver context.
	JSB	@UCB$L_FPC(R5)		; Call back waiting driver.
5$:
	POPL	R5			; Restore deallocator's R5,R4,R3
	MOVQ	(SP)+,R3		;
10$:	RSB				; Return to deallocator.
20$:	BBCS	R2,-
		ADP$W_DPBITMAP(R1),10$	; Set datapath bit and exit
	BUG_CHECK INCONSTATE		; Inconsistent state.
	RSB				;

; Here we have R5 => CDRP.

30$:
	INSV	R2,-			; Store assigned datapath #
		#VEC$V_DATAPATH,-	;  in CDRP field.
		#VEC$S_DATAPATH,-
		CDRP$L_UBARSRCE+UBMD$B_DATAPATH(R5)

	JSB	SCS$RESUMEWAITR		; Resume waiting thread and any backed
					;  up IRP's.
	BRB	5$			; Branch back to resume deallocator's
					;  thread.

	.SBTTL	REQUEST AND ALLOCATE UNIBUS MAP REGISTERS FOR CLASS DRIVER
;+
; IOC$REQMAPUDA - REQUEST AND ALLOCATE UNIBUS MAP REGISTERS FOR CLASS DRIVER
;
; THIS ROUTINE IS CALLED TO ALLOCATE UBA MAP REGISTERS AND TO MARK THE ALLOCATION
; IN THE UBA MAP REGISTER ALLOCATION DATA STRUCTURES.
;
; INPUTS:
;
;	R4 = ADDRESS OF PORT DESCRIPTOR TABLE.
;	R5 = ADDRESS OF CLASS DRIVER REQUEST PACKET (CDRP).
;
; OUTPUTS:
;
;	IF MAP REGISTERS ARE ALLOCATED FOR THE CDRP, THE APPROPRIATE FIELDS
;	IN THE CDRP ARE MODIFIED TO INDICATE WHICH REGISTERS, AND THE NUMBER
;	OF REGISTERS THAT HAVE BEEN ALLOCATED.  ALSO THE ALLOCATION DATA
;	STRUCTURE IN THE ADP IS MODIFIED.
;
;	IF MAP REGISTERS CANNOT BE ALLOCATED AT THIS TIME, THE CDRP IS
;	QUEUED ONTO THE RESOURCE WAIT LIST AND THE UCB$W_RWAITCNT IS
;	INCREMENTED.
;
;-
 
IOC$REQMAPUDA::				; Allocate UBA map registers for class driver.
	BSBB	IOC$ALOMAPUDA		; Call to allocate map registers if available.
					;  Returns R2 => ADP.

; If here, low bit of R0 tells us whether we were successful in the allocation
;	attempt.

	BLBS	R0,10$			; Branch around if successful.
	MOVQ	R3,CDRP$L_FR3(R5)	; Save driver process context
	INCW	@CDRP$L_RWCPTR(R5)	; One more CDRP, on this UCB, awaiting
					;  resources.
	POPL	CDRP$L_FPC(R5)		; Save map register wait return address
	INSQUE	CDRP$L_FQFL(R5),-
		@ADP$L_MRQBL(R2)	; Insert process in map register wait queue
10$:	RSB				;

	.SBTTL	REQUEST UNIBUS MAP REGISTERS
;+
; IOC$REQMAPREG - REQUEST UNIBUS MAP REGISTERS
;
; THIS ROUTINE IS CALLED TO REQUEST UNIBUS MAP REGISTERS TO PERFORM AN
; I/O TRANSFER.
;
; INPUTS:
;
;	R5 = UCB ADDRESS OF DEVICE UNIT.
;	04(SP) = RETURN ADDRESS OF CALLER'S CALLER.
;
;	IT IS ASSUMED THAT THE CALLER OWNS THE I/O CHANNEL ON WHICH THE
;	TRANSFER IS TO OCCUR ON.
;
; OUTPUTS:
;
;	IF MAP REGISTERS HAVE BEEN PERMANENTLY ASSIGNED TO THE ASSOCIATED
;	I/O CHANNEL, THEN CONTROL IS IMMEDIATELY RETURNED TO THE CALLER.
;	ELSE AN ATTEMPT IS MADE TO ALLOCATE THE REQUESTED NUMBER OF MAP REG-
;	ISTERS. IF SUFFICIENT CONTIGUOUS MAP REGISTERS ARE FOUND, THEN THEY
;	ARE ASSIGNED TO THE ASSOCIATED I/O CHANNEL AND CONTROL IS RETURNED
;	TO THE CALLER. ELSE THE DRIVER PROCESS CONTEXT IS SAVED IN ITS FORK
;	BLOCK, THE FORK BLOCK IS INSERTED IN THE MAP REGISTER WAIT QUEUE,
;	AND A RETURN TO THE DRIVER PROCESS' CALLER IS EXECUTED.
;-
 
IOC$REQMAPREG::				;REQUEST UNIBUS MAP REGISTERS
	BSBB	IOC$ALOUBAMAP		; ALLOCATE UBA MAP REGISTER
	BLBS	R0,10$			;IF LBS SUCCESSFUL ALLOCATION
	MOVQ	R3,UCB$L_FR3(R5)	;SAVE DRIVER PROCESS CONTEXT
	POPL	UCB$L_FPC(R5)		;SAVE MAP REGISTER WAIT RETURN ADDRESS
	INSQUE	UCB$L_FQFL(R5),@ADP$L_MRQBL(R2) ;INSERT PROCESS IN MAP REGISTER WAIT QUEUE
10$:	RSB				;

	.SBTTL	ALLOCATE UNIBUS MAP REGISTERS
;+
; IOC$ALOUBAMAP - ALLOCATE UBA MAP REGISTERS (CRB DATABASE SPECIFIED)
; IOC$ALOUBAMAPN - ALLOCATE UBA MAP REGISTERS (ARGUMENT SPECIFIED)
; IOC$ALOMAPUDA - ALLOCATE UBA MAP REGISTERS (FOR CLASS DRIVER(S))
;
; This routine is called to allocate uba map registers and to mark the allocation
;	in the map register allocation structure located in the ADP.  The state
;	of the UNIBUS map registers is maintained in a set of descriptors
;	that describe contiguous extents of allocatable (i.e. free) map
;	registers.  A map register descriptor consists of the
;	corresponding elements of two distinct arrays (of one word items)
;	located in the ADP.  These arrays, ADP$W_MRNREGARY and ADP$W_MRFREGARY,
;	contain the number of map registers and the first map register in each
;	contiguous extent of free map registers.  These arrays are each
;	preceeded by a one word field containing all 1's (-1) so that compares
;	made against the "previous" descriptor fail when the current desciptor
;	is the one whose index is zero.
;
;	ADP$L_MRACTMDRS maintains the number of active descriptors, i.e. the
;	number of elements of each array which contain valid data.
;
; INPUTS: (FOR IOC$ALOUBAMAP AND ALOUBAMAPN)
;	R3 = NUMBER OF MAP REGISTERS TO ALLOCATE (IOC$ALOUBAMAPN only).
;	R5 = DEVICE UNIT UCB ADDRESS.
;
; INPUT:  (FOR IOC$ALOMAPUDA)
;	R4 => PDT
;	R5 => CDRP
;
; OUTPUTS:
;	R0 = SUCCESS INDICATION.
;	R2 => ADP
;-
	.enabl	lsb
IOC$ALOMAPUDA:
	MOVQ	R3,-(SP)		; Save R3,R4,R5
	PUSHL	R5			;

	MOVL	PDT$L_ADP(R4),R2	; R2 => ADP before we modify R4.

	MOVL	CDRP$L_BCNT(R5),R3	; Get transfer byte count
	MOVZWL	CDRP$W_BOFF(R5),R4	; Get byte offset in page
	MOVAB	^X3FF(R3)[R4],R3	; Calculate highest relative byte and round
	ASHL	#-9,R3,R3		; Calculate number of map registers required

	MOVAB	CDRP$L_UBARSRCE(R5),R1	; R1 => UBMD.
	BRB	COMMON_ALOUBAMAP	; Branch to common code.

IOC$ALOUBAMAPN::			;ALLOCATE UBA MAP REGISTERS ARGUMENT SPECIFIED
	MOVQ	R3,-(SP)		; Save R3,R4,R5
	PUSHL	R5			;
	BRB	5$			;

IOC$ALOUBAMAP::				;ALLOCATE UBA MAP REGISTERS CRB SPECIFIED
	MOVQ	R3,-(SP)		; Save R3,R4,R5
	PUSHL	R5			;

	MOVZWL	UCB$W_BCNT(R5),R3	;GET TRANSFER BYTE COUNT
	MOVZWL	UCB$W_BOFF(R5),R4	;GET BYTE OFFSET IN PAGE
	MOVAB	^X3FF(R3)[R4],R3	;CALCULATE HIGHEST RELATIVE BYTE AND ROUND
	ASHL	#-9,R3,R3		;CALCULATE NUMBER OF MAP REGISTERS REQUIRED
5$:
	MOVL	UCB$L_CRB(R5),R1		; R1 => CRB.
	MOVL	CRB$L_INTD+VEC$L_ADP(R1),R2	; R2 => ADP.
	MOVAB	CRB$L_INTD+VEC$W_MAPREG(R1),R1	; R1 => UBMD.
	BBS	#VEC$V_MAPLOCK,-		; If SET, already permanently
		UBMD$W_MAPREG(R1),40$		;  allocated, so branch around.

; Here:
;	R1 => UBMD - caller's structure where we record registers allocated
;	R2 => ADP
;	R3 =  number of map registers to allocate
;

COMMON_ALOUBAMAP:
	TSTL	ADP$L_MRACTMDRS(R2)	; Test for zero active descriptors.
	BEQL	15$			; EQL implies no registers available.
	INCL	R3			; Round up request to next multiple
	BICB	#1,R3			;  of 2.
	CLRL	R5			; Establish loop variable.
10$:
	CMPW	R3,ADP$W_MRNREGARY(R2)[R5]	; See if enough regs described here.
	BLEQ	20$				; LEQ implies YES.

	AOBLSS	ADP$L_MRACTMDRS(R2),R5,10$	; Else branch back and continue
15$:
	CLRL	R0				; If here, allocation failure.
	BRB	50$				; Branch around to return.
20$:
	MOVW	ADP$W_MRFREGARY(R2)[R5],-	; Allocate from low end of extent
		UBMD$W_MAPREG(R1)		;  by copying 1st map reg. #.
	MOVB	R3,UBMD$B_NUMREG(R1)		; Set # of map regs allocated.
	SUBW	R3,ADP$W_MRNREGARY(R2)[R5]	; Subtract out # regs allocated.
	BNEQ	30$				; NEQ implies extent not empty,
						;   branch around deallocate.
	BSBW	DEALLOC_DESCRIP			; Call to deallocate descriptor.
	BRB	40$				;  And branch back to return.
30$:
	ADDW	R3,ADP$W_MRFREGARY(R2)[R5]	; Bump descriptor past
						;  allocated registers.
40$:	MOVL	S^#SS$_NORMAL,R0	; Indicate success.
50$:	POPL	R5			; Restore R5,R4,R3
	MOVQ	(SP)+,R3		;
	RSB
	.dsabl	lsb

	.SBTTL	Allocate a specific set of UNIBUS Map Registers
;+
; IOC$ALOUBAMAPSP
;
; This routine is called to allocate a specific set of UNIBUS Map Registers.
;
; INPUTS:
;	R3 =  # of map registers to allocate
;	R4 =  # of first map register to allocate
;	R5 => UCB
;
; OUTPUTS:
;	R0 =  Success or failure indication
;		Note R0, R1 and R2 modified.
;-

IOC$ALOUBAMAPSP::
	MOVQ	R3,-(SP)		; Save R3,R4,R5
	PUSHL	R5			;

	MOVL	UCB$L_CRB(R5),R0		; R0 => CRB.
	MOVL	CRB$L_INTD+VEC$L_ADP(R0),R2	; R2 => ADP.
	MOVAB	CRB$L_INTD+VEC$W_MAPREG(R0),R1	; R1 => UBA mapping descriptor.

	TSTL	ADP$L_MRACTMDRS(R2)	; Test for zero active descriptors.
	BEQL	30$			; EQL implies no registers available.
	BLBC	R4,10$			; Prepare to round DOWN to even boundary.
	BICB	#1,R4			; Clear low bit if set and
	INCL	R3			;  then increment # of registers to allocate.
10$:
	INCL	R3			; Prepare to round UP to even # of registers.
	BICB	#1,R3			;

	CLRL	R5			; R5 will be index register.
20$:
	CMPW	R4,ADP$W_MRFREGARY(R2)[R5]	; Are registers we want in
						;  current extent?
	BLSS	30$			; LSS means current extent is beyond the
					;  desired registers. Therefore they are
					;  not availiable and we have failed.
	BEQL	50$			; EQL means they are at the beginning
					;  of the current extent.

; Here the registers we want are either within the middle of the current
;	extent or else beyond the current extent.

	ADDW3	ADP$W_MRFREGARY(R2)[R5],-	; R0 = 1st register beyond
		ADP$W_MRNREGARY(R2)[R5],R0	;  current extent.
	CMPW	R4,R0				; Are we in current extent?
	BLSS	40$				; LSS means YES, in current.
	AOBLSS	ADP$L_MRACTMDRS(R2),R5,20$	; Loop thru all extents.
30$:						; Failure if we fall thru.
	CLRL	R0				; Set failure code.
	BRB	80$				; And branch to return.
40$:

; Here the first register we want is greater than the first register of
;	current extent (defined by R5 = index) and is less than or equal to
;	the last register of the extent. R0 contains the # of the register just
;	beyond the current extent.  In other words,
;
;	ADP$W_MRFREGARY(R2)[R5] < R4 < R0

	SUBW	R4,R0			; R0 = length of subextent based at R4.
	CMPW	R0,R3			; Compare to # of registers needed.
	BLSS	30$			; LSS means failure.

	MOVW	R4,UBMD$W_MAPREG(R1)	; Success. Fill in user's descriptor
	MOVB	R3,UBMD$B_NUMREG(R1)	;  with base register and # of registers.

;	SUBW3	ADP$W_MRFREGARY(R2)[R5],R4,-	; Distance from beginning of
;		ADP$W_MRNREGARY(R2)[R5]		;  extent to R4 is new length.
	SUBW	R0,ADP$W_MRNREGARY(R2)[R5]	; Equivalent result.

	SUBW	R3,R0			; R0 = # regs. left in sub-extent.
	BEQL	70$			; EQL means we do not have to allocate
					;  and fill a new extent descriptor.
	INCL	R5			; R5 = index of new extent descriptor.
	MOVW	R0,-(SP)		; Save length of new extent.
	BSBW	ALLOC_DESCRIP		; Call to allocate a new descriptor.

	ADDW3	R4,R3,ADP$W_MRFREGARY(R2)[R5]	; Fill in new descriptor with
	MOVW	(SP)+,ADP$W_MRNREGARY(R2)[R5]	;  1st register and # registers.
	BRB	70$				; Branch around to success.
50$:

; Here the first register we want is equal to the first register of the current
;	extent (defined by index register R5).  In other words,
;
;	R4 = ADP$W_MRFREGARY(R2)[R5]

	CMPW	R3,ADP$W_MRNREGARY(R2)[R5]	; See if we have enough registers.
	BGTR	30$				; GTR implies failure.

	MOVW	R4,UBMD$W_MAPREG(R1)	; Success.  Fill in user's descriptor
	MOVW	R3,UBMD$B_NUMREG(R1)	;  with 1st register and # allocated.

	SUBW	R3,ADP$W_MRNREGARY(R2)[R5]	; Update current descriptor.
	BEQL	60$				; EQL means current extent now
						;  empty. Go to deallocate.
	ADDW	R3,ADP$W_MRFREGARY(R2)[R5]	; If not empty, update 1st register.
	BRB	70$				; Branch around deallocate.
60$:
	BSBW	DEALLOC_DESCRIP			; Deallocate system descriptor.
70$:	MOVL	S^#SS$_NORMAL,R0	; Set success indicator.
80$:	POPL	R5			; Restore R5,R4,R3
	MOVQ	(SP)+,R3		;
	RSB				; And return to caller.

	.SBTTL	Permanently Allocate UNIBUS Map Registers
;+
; IOC$ALOUBAMAPRM  - Permanently Allocate UBA Map Registers (CRB Database Specified)
; IOC$ALOUBAMAPRMN - Permanently Allocate UBA Map Registers (Argument Specified)
;
; This routine is called to permanently allocate UNIBUS map registers.
;	Here we allocate the map registers from the highest numbered
;	available registers.
;
; INPUTS:
;	R3 =  # Registers to allocate (IOC$ALOUBAMAPRMN only)
;	R5 => UCB
;
; OUTPUTS:
;	R0 = Success indication
;
;-

	.enabl	LSB
IOC$ALOUBMAPRMN::			;ALLOCATE UBA MAP REGISTERS ARGUMENT SPECIFIED
	MOVQ	R3,-(SP)		; Save R3,R4,R5
	PUSHL	R5			;

	BRB	5$			;
IOC$ALOUBMAPRM::			;ALLOCATE UBA MAP REGISTERS CRB SPECIFIED
	MOVQ	R3,-(SP)		; Save R3,R4,R5
	PUSHL	R5			;

	MOVZWL	UCB$W_BCNT(R5),R3	;GET TRANSFER BYTE COUNT
	MOVZWL	UCB$W_BOFF(R5),R4	;GET BYTE OFFSET IN PAGE
	MOVAB	^X3FF(R3)[R4],R3	;CALCULATE HIGHEST RELATIVE BYTE AND ROUND
	ASHL	#-9,R3,R3		;CALCULATE NUMBER OF MAP REGISTERS REQUIRED
5$:
	MOVL	UCB$L_CRB(R5),R1		; R1 => CRB
	MOVL	CRB$L_INTD+VEC$L_ADP(R1),R2	; R2 => ADP
	MOVAB	CRB$L_INTD+VEC$W_MAPREG(R1),R1	; R1 => UBMD.
	BBS	#VEC$V_MAPLOCK,-		; If SET, already permanently
		UBMD$W_MAPREG(R1),30$		;  allocated, so branch around.

	INCL	R3			; Round up request to next multiple
	BICB	#1,R3			;  of 2.
	MOVL	ADP$L_MRACTMDRS(R2),R5	; R5 = index beyond last MRD.
	BEQL	15$			; EQL implies no registers available.
10$:
	CMPW	R3,ADP$W_MRNREGARY-2(R2)[R5]	; See if enough regs described here.
	BLEQ	20$				; LEQ implies YES.

	SOBGTR	R5,10$				; Else branch back and continue
15$:
	CLRL	R0				; If here, allocation failure.
	BRB	40$				; Branch around to return.
20$:
	ADDW3	ADP$W_MRFREGARY-2(R2)[R5],-	; Calculate register # beyond
		ADP$W_MRNREGARY-2(R2)[R5],R0	;  last extent.
	SUBW	R3,R0				; We allocate from high end. R0
						;  contains 1st reg. to alloc.
	MOVW	R0,UBMD$W_MAPREG(R1)		; Record 1st register allocated.
	BISW	#VEC$M_MAPLOCK,UBMD$W_MAPREG(R1);  and mark it permanent.
	MOVB	R3,UBMD$B_NUMREG(R1)		; Set # of map regs allocated.
	SUBW	R3,ADP$W_MRNREGARY-2(R2)[R5]	; Subtract out # regs allocated.
	BEQL	50$				; EQL implies descriptor not
						;  valid; branch to deallocate.
30$:
	MOVL	S^#SS$_NORMAL,R0	; Indicate success.
40$:
	POPL	R5			; Restore R5,R4,R3
	MOVQ	(SP)+,R3		;
	RSB
50$:
	DECL	R5			; R5 = index of descriptor to dealloc.
	BSBW	DEALLOC_DESCRIP		; Call to deallocate descriptor.
	BRB	30$			;  And branch back to return.
	.dsabl	lsb

;+
; DEALLOC_DESCRIP - Common internal subroutine called to deallocate
;	a UBA Map Register descriptor.
;
; INPUTS:
;	R2 => ADP
;	R5 =  index of descriptor to deallocate.
; OUTPUTS:
;	The UBA Map Allocation structures are updated by contracting
;		descriptors over the deallocated one.
;	Register R5 is modified.
;-

DEALLOC_DESCRIP:
	DECL	ADP$L_MRACTMDRS(R2)	; Decrement # active descriptors.
10$:
	MOVW	ADP$W_MRNREGARY+2(R2)[R5],-	; Move data towards lower index
		ADP$W_MRNREGARY(R2)[R5]		;  to fill up hole.
	MOVW	ADP$W_MRFREGARY+2(R2)[R5],-	;
		ADP$W_MRFREGARY(R2)[R5]		;
	AOBLSS	ADP$L_MRACTMDRS(R2),R5,10$	; Loop thru rest of active MDRS.
	RSB

;+
; ALLOC_DESCRIP - Common internal subroutine to allocate a UBA map register
;	descriptor in the middle of the range of descriptors.
;
; INPUTS:
;	R2 => ADP
;	R5 =  index of where we must allocate descriptor
; OUTPUTS:
;	Allocation is accomplished by creating a hole in each of the arrays
;		by moving descriptor items to the next higher element.
;	Note R0 is modified.
;-

ALLOC_DESCRIP:
	MOVL	ADP$L_MRACTMDRS(R2),R0		; R0 = # active descriptors.
10$:
	CMPL	R0,R5				; Have we finished?
	BLEQ	20$				; LEQ implies YES.
	MOVW	ADP$W_MRNREGARY-2(R2)[R0],-	; Starting from ends of arrays,
		ADP$W_MRNREGARY(R2)[R0]		;  copy # register items.

	MOVW	ADP$W_MRFREGARY-2(R2)[R0],-	;
		ADP$W_MRFREGARY(R2)[R0]		;
	SOBGTR	R0,10$				; And loop back until we reach
						;  the hole we have created.
20$:	INCL	ADP$L_MRACTMDRS(R2)		; Increment # active descriptors.
	RSB					; Return to caller

	.SBTTL	Release UNIBUS Map Registers
;+
; IOC$RELMAPUDA - RELEASE UNIBUS MAP REGISTERS (CALLED FROM UDA PORT DRIVER)
; IOC$RELMAPREG - RELEASE UNIBUS MAP REGISTERS
;
; This routine is called to release UNIBUS map registers that were previously
; assigned for an I/O transfer.
;
; INPUTS:
;   (For IOC$RELMAPUDA only)
;
;	R4 => PDT
;	R5 => CDRP
;
;   (For IOC$RELMAPREG call only)
;
;	R5 = UCB ADDRESS OF DEVICE UNIT.
;
;	It is assumed that the caller still owns the I/O channel on which
;	the transfer took place.
;
; OUTPUTS:
;
;	If the mapping registers have been permanently assigned to the asso-
;	ciated I/O channel (only possible for IOC$RELMAPREG), then control
;	is immediately returned to the caller.  Else the mapping registers are
;	released (via a call to IOC$DALOCUBAMAP) and we then go into a loop
;	removing waiting driver processes from the Map Register Wait Queue
;	until either the Queue is completely drained or we run out of map
;	registers to satisfy the needs of a given waiting driver process.
;	Driver processes waiting here have their context stored in either
;	a UCB fork block or a CDRP fork block and the processing required to
;	resume each of these types of driver process is slightly different.
;	What is done for each is to allocate the required map registers
;	(via a call to IOC$ALOUBAMPA for UCB threads and via a call to
;	IOC$ALOUBAMAP for CDRP threads) and to resume the waiting driver
;	process.  Resuming a UCB thread is done by restoring register
;	context and JSB'ing to the saved PC.  Resuming a CDRP thread is
;	accomplished by calling SCS$RESUMEWAITR.
;-
	.enabl	lsb
IOC$RELMAPUDA::
	MOVQ	R3,-(SP)		; Save R3-R6
	MOVQ	R5,-(SP)		;

	MOVL	PDT$L_ADP(R4),R2	; R2 => ADP.
	MOVL	R2,R6			; R6 => ADP also.

	MOVAB	CDRP$L_UBARSRCE(R5),R3	; R3 => UBMD.
	MOVZWL	UBMD$W_MAPREG(R3),R4	; R4 has 1st mapreg #.
	MOVZBL	UBMD$B_NUMREG(R3),R3	; R3 has # of mapregs.
	BRB	10$			; Branch to common code.

IOC$RELMAPREG::				; Release unibus map registers
	MOVL	UCB$L_CRB(R5),R1	; R1 => CRB.
	BBS	#VEC$V_MAPLOCK,-	; If SET, permanent allocation so branch.
		CRB$L_INTD+VEC$W_MAPREG(R1),50$
	MOVQ	R3,-(SP)		; Save R3-R6
	MOVQ	R5,-(SP)		;

	MOVL	CRB$L_INTD+VEC$L_ADP(R1),R2 ;GET ADDRESS OF ADP
	MOVL	R2,R6			;SAVE ADDRESS OF ADP
	MOVZWL	CRB$L_INTD+VEC$W_MAPREG(R1),R4 ;GET STARTING MAP REGISTER NUMBER
	MOVZBL	CRB$L_INTD+VEC$B_NUMREG(R1),R3 ;GET NUMBER OF REGISTERS TO DEALLOC
10$:
	BSBW	IOC$DALOCUBAMAP		; Free up UBA map resources.
20$:
	REMQUE	@ADP$L_MRQFL(R6),R5	;GET ADDRESS OF NEXT DRIVER FORK BLOCK
	BVS	40$			;IF VS NO DRIVER PROCESS WAITING

	CMPB	#DYN$C_UCB,-		; See if we dequeued a UCB or a CDRP.
		UCB$B_TYPE(R5)
	BNEQ	REALLOC_CD_MAPREGS	; NEQ implies a CDRP.

	BSBW	IOC$ALOUBAMAP		;SEARCH MAP REGISTER BITMAP AND ALLOCATE
	BLBC	R0,30$			;IF LBC ALLOCATION FAILURE
	MOVQ	UCB$L_FR3(R5),R3	;RESTORE DRIVE PROCESS CONTEXT
	JSB	@UCB$L_FPC(R5)		;CALL DRIVER AT MAP REGISTER WAIT RETURN ADDRESS
	BRB	20$			;
30$:	INSQUE	UCB$L_FQFL(R5),ADP$L_MRQFL(R6) ;REINSERT DRIVER PROCESS AT FRONT OF QUEUE
40$:	MOVQ	(SP)+,R5		; Restore R3-R6
	MOVQ	(SP)+,R3		;
50$:	RSB				;

REALLOC_CD_MAPREGS:			; Reallocate mapregs to a class driver
					;  process.
	MOVL	CDRP$L_FR4(R5),R4	; Restore saved fork register.
	BSBW	IOC$ALOMAPUDA		; Allocate map registers if we can.
	BLBC	R0,30$			; LBC implies allocation failure, branch

	JSB	SCS$RESUMEWAITR		; Resume waiting thread and any backed
					;  up IRP's.
	BRB	20$			; Branch back to try and allocate more
					;  UNIBUS map registers.
	.dsabl	lsb

;+
; IOC$DALOCUBAMAP - Common internal subroutine to update the UBA Map allocation
;	structures to include the map registers specified here among the
;	available map registers.
;
; INPUTS:
;	R2 => ADP
;	R3 =  # map registers to free.
;	R4 =  first map register to free.
;
; OUTPUTS:
;	The UBA Map Allocation structures are updated.
;
;	Registers R0, R1 and R5 are modified.
;
;-

IOC$DALOCUBAMAP:
	CLRL	R5			; Initialize loop variable.
	ADDL3	R4,R3,R1		; R1 = map register beyond extent.
	TSTL	R3			; Is the # of regs. to deallocate zero?
	BEQL	90$			; Branch to bugcheck if zero.
	TSTL	ADP$L_MRACTMDRS(R2)	; Test for zero active descriptors.
	BEQL	50$			; EQL implies no registers available.
10$:
	CMPW	R1,ADP$W_MRFREGARY(R2)[R5]	; See if map registers to free
						;  are before those described
						;  by current descriptor.
	BLEQ	20$				; LEQ implies yes.

	AOBLSS	ADP$L_MRACTMDRS(R2),R5,10$	; Else branch back and try next.
	BRB	40$				; If here, registers to free
						;  beyond those described by
						;  last descriptor. So branch
						;  to try and absorb at end of
						;  last descriptor.
20$:
	BNEQ	40$			; NEQ implies that although we alloca-
					;  registers before the current des-
					;  criptor, we are not contiguous with
					;  it.  So we branch to try and absorb
					;  these registers in the previous one.

; Here we can absorb the registers in the current descriptor.

	ADDW3	ADP$W_MRNREGARY-2(R2)[R5],-	; Calculate end of previous
		ADP$W_MRFREGARY-2(R2)[R5],R0	;  extent and move to R0.
	CMPW	R0,R4				; Does it coincide with start
						;  of this extent?
	BEQL	30$				; EQL implies yes.

; Here we have the most likely case. The map registers that we are freeing can
;	be absorbed into the top of the current descriptor but not also in the
;	previous descriptor.

	MOVW	R4,ADP$W_MRFREGARY(R2)[R5]	; First register freed becomes
						;  first register of current
						;  descriptor.
	ADDW	R3,ADP$W_MRNREGARY(R2)[R5]	; Number of registers is sum of
						;  registers freed and registers
						;  previously described here.
	RSB

; Here we have the case where the map registers being freed fall between two
;	discontiguous blocks and exactly span the difference.  We then can
;	describe the entire group with one descriptor, and so we also
;	deallocate the current descriptor.  Note new combined descriptor
;	will still begin at same map register number so we do NOT alter
;	this item.

30$:
	ADDW	R3,ADP$W_MRNREGARY-2(R2)[R5]	; Partial sum of registers
						;  being freed and previous ones.
	ADDW	ADP$W_MRNREGARY(R2)[R5],-	; Now add in registers described
		ADP$W_MRNREGARY-2(R2)[R5]	;  in current descriptor.

	BRW	DEALLOC_DESCRIP			; BRW to subroutine and let it
						;  return to our caller.

; Here we cannot absorb the freed map registers in the current descriptor.
;	We test to see if we can absorb them in the previous descriptor.

40$:
	ADDW3	ADP$W_MRNREGARY-2(R2)[R5],-	; Calculate end of previous
		ADP$W_MRFREGARY-2(R2)[R5],R0	;  extent and move to R0.
	CMPW	R0,R4				; See if contigous with previous.
	BNEQ	50$				; NEQ implies NO.

	ADDW	R3,ADP$W_MRNREGARY-2(R2)[R5]	; Sum # of registers in extent.
	RSB

; Here we must allocate a new descriptor to describe the map registers we
;	are freeing.  Conditions at this time are as follows:
;
;		R2 => ADP
;		R3 =  # registers to free
;		R4 =  first register to free
;		R5 =  index of where we must allocate descriptor
;
;	Allocation is accomplished by calling subroutine ALLOC_DESCRIP
;

50$:
	BSBW	ALLOC_DESCRIP			; Alloc R5 = index of descriptor.
	MOVW	R3,ADP$W_MRNREGARY(R2)[R5]	; Fill in allocated descriptor.
	MOVW	R4,ADP$W_MRFREGARY(R2)[R5]	;
	RSB

90$:	BUG_CHECK INCONSTATE		; Non-fatal bugcheck on zero map
					; registers deallocation attempts.
	RSB				; Then ignore deallocate request.

	.SBTTL	RETURN TO CALLER
;+
; IOC$RETURN - RETURN TO CALLER
;
; THIS ROUTINE IS CALLED AS A RESULT OF A DDT DISPATCH TO A NULL ENTRY. ITS
; FUNCTION IS MERELY TO RETURN TO ITS CALLER.
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	NONE.
;-
 
IOC$RETURN::				;RETURN TO CALLER
	RSB				;

	.SBTTL	WAITFOR INTERRUPT OR TIMEOUT AND KEEP CHANNEL
;+
; IOC$WFIKPCH - WAITFOR INTERRUPT OR TIMEOUT AND KEEP CHANNEL
;
; THIS ROUTINE IS CALLED TO SOFTWARE ENABLE INTERRUPTS AND TIMEOUT ON
; A DEVICE UNIT AND TO KEEP THE CHANNEL. THIS ROUTINE CAN BE CALLED AT 
; EITHER FORK OR DEVICE INTERRUPT LEVEL.
;
; INPUTS:
;
;	00(SP) = RETURN ADDRESS OF CALLER.
;	04(SP) = TIMEOUT VALUE IN SECONDS.
;	08(SP) = IPL TO LOWER TO AFTER SETTING WAIT.
;	12(SP) = RETURN ADDRESS OF CALLER'S CALLER.
;
;	R5 = UCB ADDRESS OF DEVICE UNIT.
;
; OUTPUTS:
;
;	THE TIMEOUT VALUE IS COMPUTED AND STORED IN DUE TIME, REGISTERS R3 AND
;	R4 ALONG WITH THE RETURN PC ARE SAVED IN THE FORK BLOCK, INTERRUPTS AND
;	TIMEOUT ARE ENABLED, AND A RETURN TO THE CALLER'S CALLER IS EXECUTED.
;-
 
IOC$WFIKPCH::				;WAITFOR INTERRUPT/TIMEOUT AND KEEP CHANNEL
	ADDL	#2,(SP)			;CALCULATE OFFSET TO NORMAL RETURN
	MOVQ	R3,UCB$L_FR3(R5)	;SAVE REGISTERS R3 AND R4
	POPL	UCB$L_FPC(R5)		;SAVE INTERRUPT RETURN ADDRESS
	BISW	#UCB$M_INT!UCB$M_TIM,UCB$W_STS(R5) ;ENABLE INTERRUPT AND TIMEOUT
	ADDL3	(SP)+,L^EXE$GL_ABSTIM,UCB$L_DUETIM(R5) ;SET TIMEOUT TIME
	BICW	#UCB$M_TIMOUT,UCB$W_STS(R5) ;CLEAR UNIT TIMED OUT
	ENBINT				;ENABLE INTERRUPTS
	RSB				;

	.SBTTL	WAITFOR INTERRUPT OR TIMEOUT AND RELEASE CHANNEL
;+
; IOC$WFIRLCH - WAITFOR INTERRUPT OR TIMEOUT AND RELEASE CHANNEL
;
; THIS ROUTINE IS CALLED TO SOFTWARE ENABLE INTERRUPTS AND TIMEOUT ON A DEVICE
; UNIT AND TO RELEASE THE CHANNEL. THIS ROUTINE CAN ONLY BE CALLED AT FORK LEVEL.
;
; INPUTS:
;
;	00(SP) = RETURN ADDRESS OF CALLER.
;	04(SP) = TIMEOUT VALUE IN SECONDS.
;	08(SP) = IPL TO LOWER TO AFTER SETTING WAIT.
;	12(SP) = RETURN ADDRESS OF CALLER'S CALLER.
;
;	R5 = UCB ADDRESS OF DEVICE UNIT.
;
; OUTPUTS:
;
;	THE TIMEOUT VALUE IS COMPUTED AND STORED IN DUE TIME, REGISTERS R3 AND
;	R4 ALONG WITH THE RETURN PC ARE SAVED IN THE FORK BLOCK, INTERRUPTS AND
;	TIMEOUT ARE ENABLED, THE CHANNEL IS RELEASED, AND A RETURN TO THE CALLER'S
;	CALLER IS EXECUTED.
;-
 
IOC$WFIRLCH::				;WAITFOR INTERRUPT/TIMEOUT AND RELEASE CHANNEL
	ADDL	#2,(SP)			;CALCULATE OFFSET TO NORMAL RETURN
	MOVQ	R3,UCB$L_FR3(R5)	;SAVE REGISTERS R3 AND R4
	POPL	UCB$L_FPC(R5)		;SAVE INTERRUPT RETURN ADDRESS
	BISW	#UCB$M_INT!UCB$M_TIM,UCB$W_STS(R5) ;ENABLE INTERRUPT AND TIMEOUT
	ADDL3	(SP)+,L^EXE$GL_ABSTIM,UCB$L_DUETIM(R5) ;SET TIMEOUT TIME
	BICW	#UCB$M_TIMOUT,UCB$W_STS(R5) ;CLEAR UNIT TIMED OUT
	ENBINT				;ENABLE INTERRUPTS
	BRW	IOC$RELCHAN		;RELEASE ALL CHANNELS AND RETURN TO CALLER
 


	.SBTTL	ALLOCATE SYSTEM PAGE TABLE
;+
; IOC$ALLOSPT - ALLOCATE SYSTEM PAGE TABLE
;
; THIS ROUTINE ALLOCATES SYSTEM PAGE TABLE (SPT) ENTRIES.
; 
; INPUTS:
;
;	R1 = NUMBER OF SPT ENTRIES TO BE ALLOCATED
;
;	BOO$GL_SPTFREL = LOWEST FREE VPN
;	BOO$GL_SPTFREH = HIGHEST FREE VPN
;
;	IT IS ASSUMED THAT THE CALLER IS RUNNING AT IPL$_SYNCH.
;
; OUTPUTS:
;
;	R0 = SUCCESS INDICATION.
;	R2 = STARTING PAGE NUMBER ALLOCATED (SVPN).
;	R3 = ADDRESS OF BASE OF SYSTEM PAGE TABLE (MMG$GL_SPTBASE).
;
;	R1 IS PRESERVED ACROSS CALL.
;-
IOC$ALLOSPT::				;ALLOCATE SYSTEM PAGE TABLE
	CLRL	R0			;ASSUME FAILURE
	MOVL	L^BOO$GL_SPTFREL,R2	;GET NEXT AVAILABLE SYSTEM VPN
	ADDL3	R1,R2,R3		;COMPUTE NEXT WITH THIS ALLOCATION
	CMPL	R3,L^BOO$GL_SPTFREH	;ARE THERE ENOUGH AVAILABLE?
	BGEQU	10$			;BR IF NO
	MOVL	R3,L^BOO$GL_SPTFREL	;MARK THE ENTRIES ALLOCATED
	MOVL	L^MMG$GL_SPTBASE,R3	;GET ADDR OF BASE OF SPT
	INCL	R0			;SET SUCCESS
10$:
	RSB				;

	.SBTTL	CONVERT DEVICE NAME AND UNIT
;+
; IOC$CVT_DEVNAM - Convert device name and unit
;
; This routine is called to convert a device name and unit number to a physical
; device name string.
;
; Inputs:
;
;	The caller is assumed to have PROBEd the output buffer for write access.
;	The I/O data base is locked for read access.  This means that the caller
;	owns the I/O data base mutex and/or is at IPL SYNCH or higher.
;
;	R0 = length of output buffer.
;	R1 = address of output buffer.
;	R4 = name string formation mode, one of:
;	    -1 (DVI$_DEVNAM) -- a name suitable for displays
;		for non-local devices, return node$ddcn 
;		for local devices:
;		    if in cluster and file oriented device, return node$ddcn
;		    otherwise, return ddcn
;	     0 (DVI$_FULLDEVNAM) -- a name with appropriate node information
;		if allocation class not zero and file oriented device, return 
;			$alloclass$ddcn
;		otherwise, return node$ddcn
;	     1 (DVI$_ALLDEVNAM) -- a name with allocation class information
;		if allocation class not zero, return $alloclass$ddcn
;		otherwise, return node$ddcn
;	     2 (no GETDVI item code) -- an old fashioned name
;		return ddcn
;	     3 (no GETDVI item code) -- a secondary path name for displays
;		same as -1 except secondary path name returned
;	     4 (no GETDVI item code) -- path controller name for displays
;		same as -1 except no unit number is appended
;	     Note: if the node name string is null, node$ is not returned.
;	R5 = address of device UCB.
;
; Outputs:
;
;	The device name and unit number are converted and stored in the specified
;	output buffer. The following register values are returned:
;
;		R0 = Final conversion status.
;			SS$_NORMAL or
;			SS$_BUFFEROVF (an alternate success status which 
;				indicates that the supplied buffer could not
;				hold the device name string)
;		R1 = Length of conversion string.  R1 = 0 if the alternate
;		     path name was requested but none exists.
;-
 
;
; Working storage (offsets from R7)
;
	$OFFSET	0,POSITIVE,< -
		<BINNUM,8>, -		;Binary value to convert to ASCII
		-	; add new working storage cells before this line
		<RESR0>, -		;Result R0
		<RESR1>, -		;Result R1
		<SCRLEN,0> -		;amount of working storage
		<RESR2>, -		;saved R2
		<RESR3>, -		;saved R3
		<RESR4>, -		;saved R4
		>
 
IOC$CVT_DEVNAM::			;Convert device name and unit

	PUSHR	#^M<R2,R3,R4,R5,R6,R7>	;Save registers
;
; Push a quadword onto the stack.  The quadword will land
; on the stack so that when the POPR at the end of the routine
; is executed, R0 will contain the routine value, and R1 will
; contain the length of the formatted device name.
;
	MOVQ	#SS$_NORMAL,-(SP)	;Put a 1 and a 0 on the stack
	CLRQ	-(SP)			;Init binary number working area.
	ASSUME	SCRLEN EQ 16
	MOVL	SP, R7			;Setup result R0 and R1 pointer in R7.
;
; Precede the device name with a "_" (underscore character) to
; indicate that this is a physical device name.
;
	MOVZBL	#^A/_/,R3		;Put underscore character in R3
	BSBW	PUTCHAR			;Put it in the output buffer
;
; Check for a possible nodename. If it exists, determine which format
; of name was requested by the caller.
;
	MOVL	UCB$L_DDB(R5),R6	;Get DDB address
	MOVL	DDB$L_SB(R6),R2		;Get System Block address
	BEQL	LOCAL_NAME		;None, leave
	BBC	#DEV$V_NNM,-		;Branch if nodename not wanted
		UCB$L_DEVCHAR2(R5),LOCAL_NAME
	CASE	R4, -			;Dispatch on type of output requested:
		limit=#-1, displist=< -
		DISPLAY_NAME, -		; -1 ==> node$dev: for disks, else dev:
		FULL_NAME, -		;  0 ==> $allocls$dev: or node$dev:
		ALLOC_NAME, -		;  1 ==> $allocls$dev: or node$dev:
		LOCAL_NAME, -		;  2 ==> just dev:
		SECONDARY_NAME, -	;  3 ==> secondary path
		DISPLAY_NAME -		;  4 ==> same as -1 sans unit number
		>
	BRB	EXDVNM			; All others are NOPs.

FULL_NAME:
	BBC	#DEV$V_FOD, -		;A file oriented device?
		UCB$L_DEVCHAR(R5), -
		ADD_NODE		;Branch if not file oriented device.

ALLOC_NAME:

	MOVZBL	DDB$L_ALLOCLS(R6), -	;Setup allocation class value
		BINNUM(R7)		; for conversion.
	BEQL	ADD_NODE		;If none return node+device name.
	BSBW	PUTDOLLAR		;Prepend allocation class with a '$'
	BSBB	PUTNUM			;Convert allocation class number to
					;ASCII and put it in the buffer
	BRB	ADD_DOLLAR		;Append dollar sign to alloc. class
					; and add device name to buffer.

SECONDARY_NAME:
	BBC	#DEV$V_2P,-		;Branch if device not dual-pathed.
		UCB$L_DEVCHAR2(R5),-	; (I.E. there is no secondary path to 
		NO_SECONDARY		; return.)
	MOVL	UCB$L_DP_DDB(R5),R6	;Get secondary DDB.
	BEQL	NO_SECONDARY		;Branch to no sec. path if none.
	MOVL	DDB$L_SB(R6),R2		;Get alternate SB.

DISPLAY_NAME:
	CMPL	R2,#SCS$GA_LOCALSB	;Is it the perm local system block?
	BNEQ	ADD_NODE		;Return node+devnam for non-local devs.
	IFNOCLSTR LOCAL_NAME		;Return devnam if not part of a cluster.
	BBC	#DEV$V_FOD, -		;A file oriented device?
		UCB$L_DEVCHAR(R5), -
		LOCAL_NAME		;Branch if not a file oriented device.
					;Its a local disk in a cluster: return
					;node+device name format.
;
; Return node name plus device name.  Copy node name to buffer and
; suffix with a "$" before moving in rest of device name.
;
ADD_NODE:
	MOVAB	SB$T_NODENAME(R2),R2	;Point to name field
	TSTB	(R2)			;Is the node name null?
	BEQL	LOCAL_NAME		;Skip inserting node name, if its null.
	BSBB	PUTASCIC		;Copy counted ASCII str. to output buf.
ADD_DOLLAR:
	BSBB	PUTDOLLAR		;Append dollar sign to node name
;
; Copy device name to buffer.
;
LOCAL_NAME:
	MOVAB	DDB$T_NAME(R6),R2	;Get address of ASCIC device name.
	BSBB	PUTASCIC		;Copy counted ASCII str. to output buf.
	CMPW	RESR4(R7),#4		;Do we want the unit number?
	BEQL	EXDVNM			;Nope
	MOVZWL	UCB$W_UNIT(R5), -	;Setup device unit number for
		BINNUM(R7)		; converstion to ASCII.
	BSBB	PUTNUM			;Convert unit number to ASCII.
;
; Terminate the device name with a ":" (colon).
;
	MOVZBL	#^A/:/,R3		;Put a ":" in R3
	BSBB	PUTCHAR			;Put the ":" in output buffer
;
; Clean up the stack and exit.  The stack has been set up so that
; the proper values will be stored in R0 and R1 by the POPR.
;
EXDVNM:	ADDL	#RESR0,SP		;Remove everything upto result R0
					;from the stack
	POPR	#^M<R0,R1,R2,R3,R4,R5,R6,R7> ;Restore registers
	RSB				;Return

;
; Come here when the secondary device name was requested but none exists.
;
NO_SECONDARY:
	CLRL	RESR1(R7)		;Clear count of characters
	BRB	EXDVNM			;and return.


;++
; The following code is a local subroutine to convert binary to ASCII and
; put the ASCII equivalent in the output name buffer.
;
; Inputs:
;
;	BINNUM(R7)	binary number to be converted (a quadword with high 
;			longword zeroed
;
; Outputs:
;	The number at BINNUM(R7) is converted to ASCII and stored in the
;	device name buffer.
;--
PUTNUM:
	MNEGB	#1, R3			;Get end-of-number marker.
10$:	MOVB	R3, -(SP)		;Move digit/marker to scratch.
	EDIV	#10, BINNUM(R7), -	;Divide number by 10, overwrite number
		BINNUM(R7), R3		;with quotient, put remainder in R3.
	BNEQ	10$			;If quotient not zero, go save this 
					; digit and get the next one.
;
; Get digits -- most significant first (then saved ones), convert them to
; ASCII, and put them in the output buffer
;
50$:	ADDB	#^A/0/, R3		;Convert binary digit to ASCII
	BSBB	PUTCHAR			;Copy digit to output buffer
	MOVB	(SP)+, R3		;Get another digit
	BGEQ	50$			;Branch if the end
	RSB

;++
; The following code is a local subroutine to copy a counted ASCII string 
; to the output name buffer.
;
; Inputs:
;
;	R2	Beginning address of a counted ASCII string
;
; Outputs:
;	The counted ASCII string pointed to by R2 is copied to the device
;	name buffer.
;--
PUTASCIC:
	MOVZBL	(R2)+, R4		;Get counted string length.
	BEQL	90$			;If no characters, leave.
5$:	MOVB	(R2)+, R3		;Move one byte to output buffer.
	BSBB	PUTCHAR			;Put the character in the output buffer.
	SOBGTR	R4, 5$			;Branch if more to copy.
90$:	RSB				;All done, return.

;++
;
; The following code is a local subroutine to place a given
; byte in the output buffer.  A count is kept of all characters
; placed in the output buffer.  If the output buffer is full,
; the byte is not copied, the count is not increased, and the
; return status for IOC$CVT_DEVNAM is changed to SS$_BUFFEROVF 
; (an alternate success status).
;
; Inputs:
;	R0	Count of unstored character slots remaining in output buffer
;	R1	Address of next unused character slot in output buffer
;	R3	Character to be placed in the buffer
;
; Implicit inputs:
;	RESR0(R7)	longword holding final IOC$CVT_DEVNAM status
;	RESR1(R7)	longword holding final IOC$CVT_DEVNAM count of
;				characters stored in the buffer (to be
;				returned in R1
;
; Outputs:
;	None.
;
; Implicit outputs:
;	If R0 >= zero:
;		R0		<== R0 - 1
;		(R1)		<== R3
;		R1		<== R1 + 1
;		RESR1(R7)	<== RESR1(R7) + 1
;	otherwise:
;		RESR0(R7)	<== SS$_BUFFEROVF
;++
; PUTDOLLAR is an internal routine which is the equivalent of:
;
;	MOVB	#^A/$/, R3
;	BSBB	PUTCHAR
;--
PUTDOLLAR:
	MOVB	#^A/$/, R3		;Setup to put "$" in output buffer.
PUTCHAR:
	DECL	R0			;Decrease characters remaining count.
	BLSS	90$			;Branch if no more characters remaining.
	MOVB	R3, (R1)+		;Copy character to output buffer
	INCL	RESR1(R7)		;Count characters stored
	RSB				;Return

90$:	MOVZWL	#SS$_BUFFEROVF, -	;Set buffer overflow status
		RESR0(R7)
	RSB

	.SBTTL	BROADCAST TO A TERMINAL
;++
; IOC$BROADCAST
;
;	This routine will allow driver fork processes to broadcast a
;	given message to given terminal.  The broadcast request is
;	dispatched to the proper terminal and control returns immediately
;	to the caller.  Some time later the broadcast will complete, and
;	at that time all the necessary post-processing will be done.
;
;	This routine does not implement all the features of the $BRDCST system
;	service, but only the bare minimum necessary to send a message to a 
;	single terminal.  For more information about the terminal broadcast
;	mechanism, see the module SYSBRDCST.
;
; Input:
;
;	R1 = Message length
;	R2 = Message address
;	R5 = Address of target terminal's UCB
;
; Implicit input:
;
;	IPL$_ASTDEL  <=  CURRENT_IPL  <=  UCB$B_FIPL(R5)
;
; Output:
;
;	None.  The contents of R1 .. R5 are preserved across the call.
;
; Routine value:
;
;	SS$_NORMAL	- The broadcast completed successfully.
;	SS$_INSFMEM	- Insufficient dynamic nonpaged pool for the request.
;	SS$_DEVOFFLINE	- The target terminal has rejected the request.
;	SS$_ILLIOFUNC	- The specified UCB does not belong to a terminal.
;			  (Therefore a BROADCAST is an illegal I/O function.)
;--

SAVED_R0 = 0				;.
SAVED_R1 = 4				; .
SAVED_R2 = 8				; .
SAVED_R3 = 12				; . Symbolic offsets to saved registers
SAVED_R4 = 16				; .
SAVED_R5 = 20				;.

IOC$BROADCAST::				; Broadcast to a terminal
	MOVZWL	#SS$_ILLIOFUNC,R0	; Assume device not a terminal
	BBC	#DEV$V_TRM,-		; Branch if not a terminal
		UCB$L_DEVCHAR(R5),14$	; 
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	; Save R0 .. R5
	ADDL2	#TTY$K_WB_LENGTH,R1	; Calculate the total pool required
	MOVZWL	#SS$_INSFMEM,SAVED_R0(SP); Assume allocation failure
	BSBW	EXE$ALONONPAGED		; Allocate the pool
	BLBC	R0,13$			; Exit if error
	;
	; Fill in the Terminal Write Packet (TWP).
	; Note that EXE$ALONONPAGED the pool size
	; in R1 and the pool address in R2.
	;
	MOVW	R1,TTY$W_WB_SIZE(R2)	; Set TWP size
	MOVB	#DYN$C_TWP,-		; Set TWP structure type
		TTY$B_WB_TYPE(R2)	;
	MOVB	#IPL$_QUEUEAST,-	; Set the TWP fork IPL (for later use)
		TTY$B_WB_FIPL(R2)	;
	MOVL	#1,TTY$L_WB_FR3(R2)	; Request refresh of read prompt
	MOVAB	TTY$L_WB_DATA(R2),-	; Set address of message start
		TTY$L_WB_NEXT(R2)	;
	ADDL3	SAVED_R1(SP),-		; Set address of message end
		TTY$L_WB_NEXT(R2),-	;
		TTY$L_WB_END(R2)	;
	MOVAB	B^END_BROADCAST,-	; Set callback address
		TTY$L_WB_RETADDR(R2)	;
	CLRL	TTY$L_WB_IRP(R2)	; Clear pointer to associated IRP
	PUSHL	R2			; Save TWP address
	MOVC3	4+SAVED_R1(SP),-	; Copy the message text to the TWP
		@4+SAVED_R2(SP),-	; (note the stack depth changed)
		TTY$L_WB_DATA(R2)	;
	;
	; Queue the broadcast request to the terminal.
	; The disposition of the broadcast request will be determined
	; by the contents of TTY$L_WB_END.  Note that if the request is
	; accepted by a remote terminal, or is rejected outright, the
	; TWP is no longer needed, and may be deallocated.  The TTY$L_WB_END
	; field of the TWP will contain one of the following values:
	;
	;	System address:	request accepted by TTDRIVER
	;	1:		request accepted by RTTDRIVER
	;	2:		request rejected
	;
	MOVL	(SP),R3			; Put TWP address in R3
	MOVL	4+SAVED_R5(SP),R5	; Restore UCB address
	BSBW	EXE$ALTQUEPKT		; Queue the request to the terminal
	POPL	R0			; Remove TWP address from the stack
	MOVZWL	#SS$_NORMAL,SAVED_R0(SP); Assume success 
	TSTL	TTY$L_WB_END(R0)	; Check for rejection
	BEQL	69$			; Branch if request rejected
	BGTR	80$			; Branch if remote terminal accepted
13$:	POPR	#^M<R0,R1,R2,R3,R4,R5>	; Restore the registers
14$:	RSB				; Return
69$:	MOVZWL	#SS$_DEVOFFLINE,-	; Set broadcast rejection status
		SAVED_R0(SP)		;
80$:	BSBW	COM$DRVDEALMEM		; Deallocate the TWP
	BRB	13$			; Take common exit path

;
; The following code performs all of the necessary broadcast post-processing.
; This entry point is FORKed to at IPL IPL$_QUEUEAST from the terminal driver.
; The fork block is the TWP.
;
END_BROADCAST:				; Post-processor for broadcast requests
	MOVL	R5,R0			; Copy TWP address
	BRW	EXE$DEANONPAGED		; Deallocate the TWP and return

	.SBTTL	BROADCAST EMERGENCY MESSAGE TO CONSOLE
;++
; IOC$CONBRDCST
;
;	This routine will allow emergency messages to be put on the console
;	terminal.  Some time later the broadcast will complete, and
;	at that time all the necessary post-processing will be done.
;
; Input:
;
;	R1 = Message length
;	R2 = Message address
;
; Implicit input:
;
;	IPL$_ASTDEL  <=  CURRENT_IPL  <=  UCB$B_FIPL(R5)
;
;	A dedicated TWP block must immediately preced the message.
;	The low bit of the first byte of the TWP is assumed to remain clear
;	while it is in use.
;
; Output:
;
;	None.  The contents of R1 .. R5 are preserved across the call.
;
; Routine value:
;
;	SS$_NORMAL	- The broadcast completed successfully.
;--

SAVED_R0 = 0				;.
SAVED_R1 = 4				; .
SAVED_R2 = 8				; .
SAVED_R3 = 12				; . Symbolic offsets to saved registers
SAVED_R4 = 16				; .
SAVED_R5 = 20				;.

IOC$CONBRDCST::				; Broadcast to a terminal
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	; Save R0 .. R5
	MOVAB	OPA$UCB0,R5		; Get the console terminal UCB
	SUBL2	#TTY$K_WB_LENGTH,R2	; Retreat to the start of the TWP
	;
	; Fill in the Terminal Write Packet (TWP).
	;
	MOVW	R1,TTY$W_WB_SIZE(R2)	; Set TWP size
	MOVB	#DYN$C_TWP,-		; Set TWP structure type
		TTY$B_WB_TYPE(R2)	;
	MOVB	#IPL$_QUEUEAST,-	; Set the TWP fork IPL (for later use)
		TTY$B_WB_FIPL(R2)	;
	MOVL	#1,TTY$L_WB_FR3(R2)	; Request refresh of read prompt
	MOVAB	TTY$L_WB_DATA(R2),-	; Set address of message start
		TTY$L_WB_NEXT(R2)	;
	ADDL3	SAVED_R1(SP),-		; Set address of message end
		TTY$L_WB_NEXT(R2),-	;
		TTY$L_WB_END(R2)	;
	MOVAB	B^END_CONBRDCST,-	; Set callback address
		TTY$L_WB_RETADDR(R2)	;
	CLRL	TTY$L_WB_IRP(R2)	; Clear pointer to associated IRP
	PUSHL	R2			; Save TWP address
	;
	; Queue the broadcast request to the terminal.
	;
	MOVL	R2,R3			; Put TWP address in R3
	BSBW	EXE$ALTQUEPKT		; Queue the request to the terminal
	POPL	R0			; Remove TWP address from the stack
	MOVZWL	#SS$_NORMAL,SAVED_R0(SP); Assume success 
	TSTL	TTY$L_WB_END(R0)	; Check for rejection
	BEQL	69$			; Branch if request rejected
13$:	POPR	#^M<R0,R1,R2,R3,R4,R5>	; Restore the registers
14$:	RSB				; Return
69$:	MOVZWL	#SS$_DEVOFFLINE,-	; Set broadcast rejection status
		SAVED_R0(SP)		;
80$:	MNEGL	#1,(R0)			; Mark the TWP free
	BRB	13$			; Take common exit path

;
; The following code performs all of the necessary broadcast post-processing.
; This entry point is FORKed to at IPL IPL$_QUEUEAST from the terminal driver.
; The fork block is the TWP.
;
END_CONBRDCST:				; Post-processor for broadcast requests
	MNEGL	#1,(R5)			; Mark the TWP free
	RSB

	.SBTTL	SCAN THE I/O DATA BASE
;+
; IOC$SCAN_IODB - Scan the I/O data base and return next block.
;
; This routine is called to scan the device lists in the IO data base and
; return a pointer to the next block in the list.  Context is kept in R11
; and by using back pointers.
;
; Inputs:
;
;	The I/O data base is locked for read access.  This means that the caller
;	owns the I/O data base mutex and/or is at IPL SYNCH or higher.
;
;		R11 =  0 implies first call
;		R11 <> 0 indicates that R11 is pointer to current DDB
;		R10 =  0 implies end of UCB chain
;		R10 <> 0 indicates that R10 is pointer to current UCB
;
; Outputs:
;
;		R0  = Success status.
;		R10 = Pointer to UCB
;		R11 = Pointer to DDB
;
;	All other registers preserved.
;
;-
 
IOC$SCAN_IODB::

	MOVL	#1,R0			; Success
	TSTL	R11			; Initial condition?
	BEQL	50$			; Yes
	TSTL	R10			; End of chain?
	BEQL	10$			; Yes
	MOVL	UCB$L_LINK(R10),R10	; Get next UCB
	BEQL	10$			; None
	RSB

10$:	TSTL	DDB$L_LINK(R11)		; At end of DDB chain?
	BEQL	30$			; Yes
	MOVL	DDB$L_LINK(R11),R11	; No, get next one
20$:	MOVL	DDB$L_UCB(R11),R10	; Pick up first UCB
	BEQL	10$			; None, get next DDB
	RSB

30$:	MOVL	DDB$L_SB(R11),R11	; Get back to parent system block
40$:	MOVL	SB$L_FLINK(R11),R11	; Get next system block
	CMPL	R11,#SCS$GQ_CONFIG	; End of chain?
	BNEQ	60$			; No
	DECL	R0
	RSB

50$:	MOVL	@#SCS$GQ_CONFIG,R11	; Pick up first system block
60$:	TSTL	SB$L_DDB(R11)		; Is there a DDB chain?
	BEQL	40$			; No, go try next SB
	MOVL	SB$L_DDB(R11),R11	; Yes, get the first DDB
	BRB	20$


	.SBTTL	SCAN THE I/O DATA BASE BOTH PRIMARY & SECONDARY PATHS
;++
; IOC$SCAN_IODB_2P
;
; This routine is called to scan the device lists in the IO data base and
; return a pointer to the next block in the list.  Context is kept in R10
; and R11 and by using back pointers.
;
; SCAN_IODB_2P differs from SCAN_IODB in that it will scan both the primary
; and secondary UCB chain for each DDB.  This means that if a device is
; dual-pathed, SCAN_IODB_2P will return the address of its UCB twice, once in
; the context of the primary controller and once in the context of the
; secondary.
;
; Inputs and Outputs are identical to IOC$SCAN_IODB.
;--
 
IOC$SCAN_IODB_2P::

	MOVL	#1,R0			; Success
	TSTL	R11			; Initial condition?
	BEQL	60$			; Yes
	TSTL	R10			; Caller signalled end of chain?
	BEQL	30$			; Yes, done with this DDB
;
; At this point we must decide if we're following the primary or secondary
; chain of UCBs on this DDB.
;
	CMPL	UCB$L_DDB(R10),R11	; Are we traversing the primary chain?
	BNEQ	10$			; Branch if we're following secondary
	MOVL	UCB$L_LINK(R10),R10	; Get next UCB on primary chain
	BEQL	20$			; Branch if none to try secondary chain
	RSB				; Else return UCB address to caller
;
; Get next UCB on secondary chain.
;
10$:	MOVL	UCB$L_DP_LINK(R10),R10	; Get next UCB on secondary chain
	BEQL	30$			; Branch if none left
	RSB				; Else return UCB address to caller
;
; No UCBs left on primary chain; traverse secondary chain if present.
;
20$:	MOVL	DDB$L_DP_UCB(R11),R10	; Get first UCB on secondary chain
	BEQL	30$			; Branch if none to try next DDB
	RSB				; Else return UCB address to caller
;
; Step to next DDB.
;
30$:	TSTL	DDB$L_LINK(R11)		; At end of DDB chain?
	BEQL	40$			; Yes, try next system block
	MOVL	DDB$L_LINK(R11),R11	; No, get next one
35$:	MOVL	DDB$L_UCB(R11),R10	; Pick up first UCB on primary chain
	BEQL	20$			; None, try for UCB on secondary chain
	RSB				; Else return UCB address to caller

;
; Step to next system block.
;
40$:	MOVL	DDB$L_SB(R11),R11	; Get back to parent system block
50$:	MOVL	SB$L_FLINK(R11),R11	; Get next system block
	CMPL	R11,#SCS$GQ_CONFIG	; End of chain?
	BNEQ	70$			; No
	DECL	R0			; Signal end of IO scan
	RSB

60$:	MOVL	@#SCS$GQ_CONFIG,R11	; Pick up first system block
70$:	TSTL	SB$L_DDB(R11)		; Is there a DDB chain?
	BEQL	50$			; No, go try next SB
	MOVL	SB$L_DDB(R11),R11	; Yes, get the first DDB
	BRB	35$			; Try for UCB on primary chain

	.SBTTL	IOC$CTRLINIT - Call driver controller init. routine
;++
;  FUNCTIONAL DESCRIPTION:
;
;	For UNIBUS devices, the device CSR is tested for existance.  If this 
;	test fails, a no routine call occurs and failure status is returned in 
;	R0.  Input values for a device driver's controller initialization 
;	routine are loaded into the proper registers, the routine starting 
;	address is located, and if a routine exists, it is called.
;
;  INPUTS:
;	R1	CSR address to use if IDB contains zero
;	R8	CRB address (primary)
;	R11	DDB address
;
;  OUTPUTS:
;	R0	Status (success, or failure ==> UNIBUS CSR non-existant)
;	R1-R6	Destroyed
;--

;++
;  Controller initialization routine parameters:
;
;  INPUTS:
;	R4	CSR address (for UNIBUS and MASSBUS devices)
;		SCSSYSTEMID address (for class drivers during SYSGEN driver
;			loading)
;		zero for all others, including class drivers during power 
;			failure recovery
;	R5	IDB address (or zero if none exists)
;	R6	DDB address
;	R8	CRB address
;
;  OUTPUTS: 
;	Must preserve all registers except R0 through R4.
;
;--


IOC$CTRLINIT::

	MOVL	CRB$L_INTD+VEC$L_IDB(R8), R5	; Get IDB address.
	BGEQ	10$				; Branch if none.
	MOVL	IDB$L_CSR(R5), R4		; Get CSR address.
	BLSS	20$				; Branch if really a CSR.
10$:	MOVL	R1, R4				; Else, use supplied value,
	BRB	40$				; and skip CSR testing.

20$:	MOVL	IDB$L_ADP(R5), R6		; Get ADP address.
	BGEQ	40$				; If none, skip CSR test.
	CMPW	#AT$_UBA, ADP$W_ADPTYPE(R6)	; Is this a UBA?
	BNEQ	40$				; If not a UBA, skip CSR test.
	MOVL	ADP$L_CSR(R6), R6		; Get adapter config reg addr.
	MOVL	R4, R0				; Setup CSR for test.
	JSB	G^EXE$TEST_CSR			; Test UNIBUS CSR.
	BLBC	R0, 90$				; Branch if no CSR present.

40$:	MOVL	CRB$L_INTD+VEC$L_INITIAL(R8), R0 ; Get ctrl init rout addr.
	BGEQ	80$				; Branch if none.
	MOVL	R11, R6				; Get DDB address.
	JSB	(R0)				; Call ctrl init routine.

80$:	MOVL	#1, R0				; Set success status.
90$:	RSB					; Return w/ status.

	.SBTTL	IOC$UNITINIT - Call driver unit init. routine
;++
;  FUNCTIONAL DESCRIPTION:
;
;	Input values for a device driver's unit initialization routine are 
;	loaded into the proper registers, the routine starting address is 
;	located, and if a routine exists, it is called.
;
;  INPUTS:
;	R5	UCB address
;	R8	CRB address (primary)
;
;  OUTPUTS:
;	R0-R4	Destroyed
;
;  NOTES:
;
;	There are two unit initialization routine addresses in the I/O data 
;	base; CRB$L_INTD_VEC$L_UNITINIT and DDT$L_UNITINIT.  Normally, only 
;	one of these two places should contain a unit initialization routine 
;	address.  However, for the console block storage device, the both 
;	locations contain an address, and the DDT contains the address which 
;	must be used.
;
;	In this case, the CRB is shared by the console terminal and console 
;	block storage devices.  The CRB contains the address of the unit 
;	initialization routine for the console terminal, and the console 
;	terminal DDT contains no unit initialization routine address.  Thus 
;	the console terminal device "fits" the "normal" case.  However, the 
;	console block storage device DDT contains a unit initialization 
;	routine which differs from the console terminal unit initialization 
;	routine and whose address is stored in the DDT.
;
;	Since the CRB is shared and contains the wrong unit initialization 
;	routine address for the console block storage device, the DDT must be 
;	inspected first.  Initialization for the console terminal will be 
;	accomplished correctly regardless of which address is checked first.
;
;--

;++
;  Unit initialization routine parameters:
;
;  INPUTS:
;	R3	CSR address (primary)
;	R4	CSR address (secondary, same as primary if no secondary exists)
;	R5	UCB address
;
;  OUTPUTS:
;	Must preserve all registers except R0 through R4.
;
;--


IOC$UNITINIT::

	MOVL	UCB$L_DDT(R5), R0		; Get DDT address.
	MOVL	DDT$L_UNITINIT(R0), R0		; Get DDT unit init rout addr.
	CMPL	R0, #IOC$RETURN			; Null unit init routine?
	BNEQ	10$				; Branch if real unit init rout.
	MOVL	CRB$L_INTD+VEC$L_UNITINIT(R8), R0 ; Get CRB unit init rout addr.
	BGEQ	90$				; Branch if no unit init rout.

10$:	CLRL	R4				; Assume no IDB exists.
	MOVL	CRB$L_INTD+VEC$L_IDB(R8), R3	; Get IDB address.
	BGEQ	50$				; Branch if none.
	MOVL	IDB$L_CSR(R3), R3		; Get primary CSR.
	MOVL	R3, R4				; Assume no sec. CRB exists.
	MOVL	CRB$L_LINK(R8), R1		; Get secondary CRB addr.
	BGEQ	50$				; Branch if none.
	ASSUME	IDB$L_CSR EQ 0
	MOVL	@CRB$L_INTD+VEC$L_IDB(R1), R4	; Get secondary CSR addr.

50$:	JMP	(R0)				; Call unit init routine, and
						; return to caller.

90$:	RSB					; No unit init routine to call:
						; return to caller.

	.SBTTL	Parse Device Name String

;+
;
; IOC$PARSDEVNAM - parse device name string
;
; This routine parses a device name string, checking syntax and
; extracting node name, allocation class number, and unit number.
; If device type format is specified, it is converted into the internal
; compressed format.
;
; INPUTS:
;
;	R8 = size of name string
;	R9 = address of name string
;	R10 = flags
;
; OUTPUTS:
;
;	R0 = SS$_NORMAL - valid name string
;	   = SS$_IVDEVNAM - invalid device name string
;	R2 = unit number
;	R3 = length of SCS node name at head of name string
;	     or allocation class number
;	     or device type code
;	R8 = size of name string
;	R9 = address of name string
;	R10 = flags
;	R4 - R7, R11 preserved
;
;-

	.ENABLE	LSB

IOC$PARSDEVNAM::
	PUSHR	#^M<R4,R5,R6>		; save working registers
	TSTL	R8			; check name string length
	BEQL	30$			; branch if null - error
	MOVQ	R8,R4			; copy name string descriptor
	SUBL3	#1,R9,R6		; default is no node no allocation 
					; class, set pointer before beginning 
					; of the string
	LOCC	#^A'$',R8,(R9)		; scan name for a "$"
	BEQL	10$			; failed to find one - no nodename
	MOVL	R1,R6			; found it, save pointer
10$:	CLRQ	R2			; init unit number and node name
20$:	MOVZBL	(R5),R0			; get next character
	BBC	#6,R0,40$		; br if code 0-^X3F - numeric or $
	BICB	#^X20,R0		; collapse lower case to upper case
	CMPB	R0,#^A'Z'		; possible alphabetic?
	BGTRU	150$			; br if not
	CMPB	R0,#^A'A'		; possible alphabetic?
	BGEQU	70$			; branch if OK - store it
30$:	BRB	150$			; no - error
;
; Non alphabetic - may be numeric or "$"
;
40$:	CMPL	R5,R6			; hit the "$" yet?
	BEQL	50$			; yes, deal with it
	BGTRU	80$			; past it, digits are unit number
	CMPB	R0,#^A'9'		; legal?
	BGTRU	150$			; no, error
	CMPB	R0,#^A'0'		; legal?
	BGEQU	70$			; yes, accept it as alpha
	BRB	150$			; no, error
;
; $ in device name - either node name or allocation class.
;
50$:	SUBL3	R9,R5,R3		; compute length of node name
	BNEQ	70$			; branch if non-null - process the $
;
; Process allocation class number.
;
60$:	INCL	R5			; move over "$" to allocation
	DECL	R4			; class digits.
	BSBB	GETNUMBER		; convert allocation class.
	MOVL	R2,R3			; store requested allocation class.
	BLEQ	150$			; leq zero is not legal.
	BISB	#IOC$M_CLASS,R10	; set allocation class flag
	CMPB	#^A'$',R0		; was terminator a "$"?
	BNEQ	150$			; if not, invalid device name.
	MOVQ	R4,R8			; reset device name - unit size.
	TSTL	R4			; check remaining string count
	BGTR	20$			; if characters remain, process them.
	BRB	150$			; else, invalid device name.

70$:	MOVB	R0,(R5)+		; store potentially upcased character
	SOBGTR	R4,20$			; any more characters to scan?
;
; End of alpha scan. Make sure we actually got a non-null device name.
;
80$:	SUBL	R4,R8			; subtract unit number from string
	BEQL	150$			; if eql no device name specified
	INCL	R6			; point past $ in node name
	CMPL	R6,R5			; see if we've processed any more chars
	BLSSU	90$			; branch if yes
	BLBS	R10,150$		; branch if physical - not valid
	BBC	#IOC$V_ANY,R10,150$	; or if not generic search for any
	BRB	100$			; node name only - verify end of string
;
; Process unit number and make sure there's no trailing junk.
;
90$:	CLRL	R2			; init unit number to 0
	TSTL	R4			; see if there's anything left
	BLEQ	110$			; branch if not
	BISB	#IOC$M_PHY,R10		; set physical flag
	BSBB	GETNUMBER		; convert unit number
	INCL	R4			; return terminator to string count
100$:	TSTL	R4			; reached end of string?
	BGTR	150$			; branch if not - error
110$:	BBS	#IOC$V_TYPE,R10,190$	; branch if name is a device type
120$:	MOVL	#SS$_NORMAL,R0		; successful parse
130$:	POPR	#^M<R4,R5,R6>		; restore registers
	RSB				; and return
;
; Invalid device name
;
140$:	TSTL	(SP)+			; pop GETNUMBER return address from stack
150$:	MOVZWL	#SS$_IVDEVNAM,R0	; set invalid device name
	BRB	130$

;+
; Routine to convert ASCII to integer
;
; Inputs:
;
;	R2	assumed zero
;	R4	size of string
;	R5	starting address of string
;
; Outputs:
;
;	R0	terminator character
;	R2	converted number
;	R4	size of string with number and terminator character removed
;	R5	address of first character after number terminator character
;-

160$:	MOVZBL	(R5)+,R0		; get next character.
	SUBB	#^A'0',R0		; base it at decimal digits.
	BLSSU	170$			; branch if not a decimal digit.
	CMPB	R0,#9			; is it a digit?
	BGTRU	170$			; branch if not a decimal digit.
	MULL	#10,R2			; scale current unit number by 10
	ADDL	R0,R2			; add new digit to accumulation.
GETNUMBER:
	SOBGEQ	R4,160$			; count off a character
	BRB	180$			; branch if no more characters

170$:	MOVZBL	-1(R5),R0		; restore terminator character.
180$:	CMPL	R2,#32768		; check number value
	BGEQU	140$			; branch if not valid
	RSB				; return to caller.

;
; Parse device type name. We do this last because all the regular device
; name validation is necessary anyway. Now we just have to do the
; additional checks and pack the characters.
;
190$:	TSTL	R3			; check if we saw node or alloc class
	BNEQ	150$			; branch if so - not valid
	SUBL3	R9,R5,R0		; compute total length of string
	SUBL	R8,R0			; compute length of unit number string
	CMPL	R0,#2			; must be two digits
	BNEQ	150$			; branch if not - not valid
	MOVL	R9,R5			; copy name address again
	CMPL	R8,#2			; check minimum name length
	BLSSU	150$			; too short - out
	SUBB3	#^A'A'-1,(R5)+,R0	; get char and convert to compressed
	INSV	R0,#17,#5,R3		; store compressed code
	SUBB3	#^A'A'-1,(R5)+,R0	; get char and convert to compressed
	INSV	R0,#12,#5,R3		; store compressed code
	CMPL	R8,#3			; check how many chars left
	BGTRU	150$			; string was longer than 5 - error
	BLSSU	200$			; short - don't take 3rd alpha
	SUBB3	#^A'A'-1,(R5)+,R0	; get char and convert to compressed
	INSV	R0,#7,#5,R3		; store compressed code
200$:	ADDL	R2,R3			; add in unit number
	BICB	#IOC$M_PHY,R10		; clear physical flag
	BRW	120$			; done

	.SBTTL	Search I/O Database for Device

;+
;
; IOC$SEARCHINT - internal I/O database search
;
; This routine searches the I/O database for the specified device, using
; the specified search rules. Depending on the search, a lock may or may
; not be taken out on the device when it is found.
;
; Note! While this routine is non-paged and therefore may be called at
; elevated IPL, the device locking code it calls is not. Therefore, only
; searches with IOC$V_ANY may be called from elevated IPL.
;
; INPUTS:
;
;	R2 = unit number
;	R3 = length of SCS node name at head of name string
;	     or allocation class number
;	     or device type code
;	R8 = size of name string
;	R9 = address of name string
;	R10 = flags
;	R11 = address to store lock value block
;	I/O database mutex held, IPL 2
;
; OUTPUTS:
;
;	R0 = SS$_NORMAL - device found
;	   = SS$_NOSUCHDEV - device not found
;	   = SS$_NODEVAVL - device exists but not available according to rules
;	   = SS$_DEVALLOC - device allocated to other user
;	   = SS$_NOPRIV - failed device protection
;	   = SS$_TEMPLATEDEV - can't allocate template device
;	   = SS$_DEVMOUNT - device already mounted
;	   = SS$_DEVOFFLINE - device marked offline
;	R5 = UCB
;	R6 = DDB
;	R7 = system block
;	R10 - R4, R8 - R11 preserved
;
;	Note: If failure, R5 - R7 point to the last structures looked at.
;
;-
 
;
; Stack use:
;
SAVR2	= 0
SAVR3	= 4
SAVR4	= 8
SAVR8	= 12
SAVR9	= 16


	.ENABLE	LSB

IOC$SEARCHINT::
	PUSHR	#^M<R2,R3,R4,R8,R9>	; save registers
;
; Search the system blocks for a suitable node. If we are doing a search
; by allocation class, generic device type, or no node name is given,
; all system blocks qualify.
;
	MOVAL	SCS$GQ_CONFIG,R7	; get head of SCS SB list
10$:	MOVL	SB$L_FLINK(R7),R0	; get next system block
	CMPL	R0,#SCS$GQ_CONFIG	; are we back at list head?
	BEQL	50$			; branch if yes - all done

	MOVL	R0,R7
	MOVAL	SB$L_DDB-DDB$L_LINK(R7),R6 ; pick up DDB listhead
	MOVL	R6,R5			; make sure UCB is non-zero
					; if allocation class or generic dev,
	BITB	#IOC$M_CLASS!IOC$M_TYPE,R10
	BNEQ	30$			; check every system block
	MOVQ	SAVR8(SP),R8		; get orig dev name descriptor
	MOVL	SAVR3(SP),R3		; get node name length
	BEQL	30$			; branch if none - go ahead
	CMPB	R3,SB$T_NODENAME(R7)	; check node name length
	BNEQ	10$			; branch if not
	CMPC3	R3,SB$T_NODENAME+1(R7),(R9) ; node names match?
	BNEQ	10$			; branch if not
;
; Found a suitable system block. Search its DDB list.
;
20$:	MOVZWL	#SS$_NORMAL,R0
	ADDL3	#1,SAVR3(SP),R3		; include the "$"
	ADDL	R3,R9			; skip over the nodename
	SUBL	R3,R8			; adjust the length
	BLEQ	60$			; if no device name, just return SB

30$:	MOVL	DDB$L_LINK(R6),R0	; get address of next DDB
	BEQL	80$			; if eql end of list
	MOVL	R0,R6
	MOVAL	<DDB$L_UCB-UCB$L_LINK>(R6),R5 ; initialize primary UCB address
	BICB	#IOC$M_2P,R10		; new DDB - clear secondary flag
	BBS	#IOC$V_TYPE,R10,100$	; branch if generic type search
	BBC	#IOC$V_CLASS,R10,40$	; branch if no class to check
	CMPL	SAVR3(SP),DDB$L_ALLOCLS(R6) ; else, is allo. class right?
	BNEQ	30$			; branch if not, try next DDB
40$:	CMPC3	R8,(R9),DDB$T_NAME+1(R6) ; check device name
	BNEQ	30$			; if no match, try next DDB
	MOVZBL	DDB$T_NAME(R6),R0	; get length of name in DDB
	CMPL	R8,R0			; check name lengths
	BEQL	100$			; if they match - OK
	DECL	R0			; try subtracting out controller letter
	CMPL	R8,R0			; and see if this matches
	BNEQ	30$			; if not, keep trying
	BLBC	R10,100$			; branch if not physical search - OK
	CMPB	DDB$T_NAME+1(R6)[R0],#^A'A' ; is this controller A?
	BEQL	100$			; if so, search it
	BRB	30$			; if not, keep looking
;
; End of search - no suitable device has been found
;
50$:	MOVZWL	#SS$_NOSUCHDEV,R0	; no device found
	BBC	#IOC$V_EXISTS,R10,140$	; branch if not seen
	MOVZWL	#SS$_NODEVAVL,R0	; otherwise status is not available
	BRB	140$
;
; To here if we're just returning a system block, with no device specified.
;
60$:	MOVL	(R6),R6			; get first DDB
	MOVL	DDB$L_UCB(R6),R5	; and first UCB
	BRB	140$			; and return
;
; To here when all UCB's on a DDB have been searched.
;
70$:	BBS	#IOC$V_TYPE,R10,30$	; if generic type search, try next DDB
;
; To here when all DDB's on a system block have been searched.
;
80$:	BITB	#IOC$M_CLASS!IOC$M_TYPE,R10 ; if generic type or alloc class
	BNEQ	90$			; keep searching system blocks
	BITB	#IOC$M_PHY!IOC$M_LOCAL,R10 ; if physical or local only
	BNEQ	50$			; we're done
	TSTL	SAVR3(SP)		; if there was an explicit node
	BNEQ	50$			; we're done
90$:	BRW	10$			; else go try next system block
;
; Found a suitable DDB. Search both its UCB lists for the right UCB.
;
100$:	MOVQ	SAVR2(SP),R2		; get unit number and device type
	MOVL	SCH$GL_CURPCB,R4	; get PCB address
NEXTUCB:				; re-entry for next UCB
110$:	BBC	#IOC$V_2P,R10,120$	; branch if on primary path
	MOVL	UCB$L_2P_LINK(R5),R5	; link to next secondary unit.
	BRB	130$
120$:	MOVL	UCB$L_LINK(R5),R5	; link to next primary unit.
130$:	BEQL	150$			; branch if no more units.
	BSBB	IOC$TESTUNIT		; is this unit ok?
	BLBS	R0,140$			; branch if successful
	BBC	#IOC$V_EXISTS,R10,110$	; keep going if we haven't seen it yet
	BLBC	R10,110$		; or if not physical search
140$:	POPR	#^M<R2,R3,R4,R8,R9>	; restore registers
	RSB				; and return

150$:	BBSS	#IOC$V_2P,R10,70$	; branch if secondary path already searched
	MOVAL	<DDB$L_2P_UCB -		; initialize secondary UCB address.
		-UCB$L_2P_LINK>(R6),R5
	BRB	110$			; go search secondary path

	.DISABLE LSB

	.SBTTL	Continue I/O Database Search

;+
;
; IOC$SEARCHCONT - internal I/O database search
;
; This routine continues a search started with a call to IOC$SEARCHINT.
; It uses IOC$SEARCHINT's outputs as the starting point at which to
; resume.
;
; INPUTS:
;
;	R2 = unit number
;	R3 = length of SCS node name at head of name string
;	     or allocation class number
;	     or device type code
;	R5 = last UCB
;	R6 = last DDB
;	R7 = last system block
;	R8 = size of name string
;	R9 = address of name string
;	R10 = flags
;	R11 = address to store lock value block
;	I/O database mutex held, IPL 2
;
; OUTPUTS:
;
;	R0 = SS$_NORMAL - device found
;	   = SS$_NOSUCHDEV - device not found
;	   = SS$_NODEVAVL - device exists but not available according to rules
;	   = SS$_DEVALLOC - device allocated to other user
;	   = SS$_NOPRIV - failed device protection
;	   = SS$_TEMPLATEDEV - can't allocate template device
;	   = SS$_DEVMOUNT - device already mounted
;	   = SS$_DEVOFFLINE - device marked offline
;	R5 = UCB
;	R6 = DDB
;	R7 = system block
;	R10 - R4, R8 - R11 preserved
;
;	Note: If failure, R5 - R7 point to the last structures looked at.
;
;-

IOC$SEARCHCONT::
	PUSHR	#^M<R2,R3,R4,R8,R9>	; save registers
	BBCC	#IOC$V_ALT,R10,10$	; check if alternate UCB in use
	MOVL	UCB$L_DP_ALTUCB(R5),R5	; link back to other to continue
10$:	BRB	NEXTUCB			; continue search

	.SBTTL	Check UCB Against Search Rules

;+
;
; IOC$TESTUNIT - Check UCB Against Search Rules
;
; INPUTS:
;
;	R2 = unit number
;	R3 = device type code
;	R4 = PCB address
;	R5 = UCB address
;	R10 = flags
;	R11= address of lock value block
;
; OUTPUTS:
;
;	R0 = SS$_NORMAL - eligible for use according to flags
;	   = SS$_NOSUCHDEV - wrong unit number
;	   = SS$_DEVALLOC - device allocated to other user
;	   = SS$_NOPRIV - failed device protection
;	   = SS$_TEMPLATEDEV - can't allocate template device
;	   = SS$_DEVMOUNT - device already mounted
;	   = SS$_DEVOFFLINE - device marked offline
;
;-

IOC$TESTUNIT::
	MOVZWL	#SS$_NOSUCHDEV,R0	; assume wrong device
	BLBC	R10,10$			; branch if not physical search
	CMPW	R2,UCB$W_UNIT(R5)	; is the unit number exactly right?
	BNEQ	70$			; branch to error if not right.

10$:	BBC	#IOC$V_TYPE,R10,20$	; branch if not searching for dev type
	CMPZV	#MSCP$V_MTYP_N,-
		#MSCP$V_MTYP_D1,-
		UCB$L_MEDIA_ID(R5),R3	; is this the requested type?
	BNEQ	70$			; branch if not
20$:	BISB	#IOC$M_EXISTS,R10	; note eligible device seen
	BBC	#DEV$V_CDP,UCB$L_DEVCHAR2(R5),30$ ; is this served path to a local device?
	MOVL	UCB$L_DP_ALTUCB(R5),R5	; yes, get local path UCB address.
	BISW	#IOC$M_ALT,R10		; note alternate UCB in use
30$:	BBC	#IOC$V_ANY,R10,40$	; if SEARCHALL, finish with success.
	BRW	150$
;
; Check the device reference count and allocation status.
;
40$:	MOVZWL	#SS$_DEVMOUNT,R0	; check if device is already mounted
	BBS	#DEV$V_MNT,UCB$L_DEVCHAR(R5),100$
	MOVZWL	#SS$_DEVALLOC,R0
	BBS	#UCB$V_MOUNTING,UCB$W_STS(R5),100$ ; branch if mount in progress
	TSTW	UCB$W_REFC(R5)		; is reference count zero?
	BEQL	80$			; branch if reference count is zero.
	BBC	#IOC$V_MOUNT,R10,50$	; if mounting...
	BBS	#IOC$V_ALLOC,R10,60$	; if shared mount
	BBC	#DEV$V_ALL,UCB$L_DEVCHAR(R5),80$ ; OK if not allocated
	BRB	60$			; otherwise check allocation

50$:	BLBC	R10,100$		; allocate: error if not phy
60$:	CMPL	UCB$L_PID(R5),PCB$L_PID(R4) ; does this process own the device?
70$:	BNEQ	100$			; branch to error if not our device.
;
; Check all the other miscellaneous junk that can make a device not
; available.
;
80$:	MOVZWL	#SS$_NOPRIV,R0		; check if device is spooled
	BBC	#DEV$V_SPL,UCB$L_DEVCHAR(R5),90$ ; branch if not
	IFNPRIV	ALLSPOOL,100$,R4	; else, process must have ALLSPOOL priv.
90$:	MOVZWL	#SS$_DEVOFFLINE,R0	; check if device is available
	BBC	#DEV$V_AVL,UCB$L_DEVCHAR(R5),100$
	BBC	#UCB$V_ONLINE,UCB$W_STS(R5),100$
	MOVZWL	#SS$_TEMPLATEDEV,R0	; check if device is a template
	BBS	#UCB$V_TEMPLATE,UCB$W_STS(R5),100$
	BSBW	EXE$CHKRDACCES		; check device protection
	BLBS	R0,120$			; continue if accessible
;
; To here on any error.
;
100$:	BBCC	#IOC$V_ALT,R10,110$	; check if alternate UCB in use
	MOVL	UCB$L_DP_ALTUCB(R5),R5	; link back to other to continue
110$:	RSB				; return
;
; We've passed all the local tests. Now try to take out the appropriate
; lock on the device.
;
120$:	MOVL	R11,R1			; value block address
	BEQL	130$			; branch if none
	CLRQ	(R1)			; initialize value block
	CLRQ	8(R1)
130$:	BBC	#DEV$V_CLU,UCB$L_DEVCHAR2(R5),150$ ; br. if not cluster visible
	MOVL	#LCK$K_EXMODE,R0	; assume exclusive lock
	BBS	#IOC$V_ALLOC,R10,140$	; branch if allocation requested
	BBC	#IOC$V_MOUNT,R10,140$	; branch if not mount mode
	BBS	#DEV$V_ALL,UCB$L_DEVCHAR(R5),140$ ; br. if allocated
	MOVL	#LCK$K_PWMODE,R0	; mount, no allocation - use PW
140$:	BSBW	IOC$LOCK_DEV		; and try to take device lock
	BLBC	R0,100$
150$:	MOVL	#SS$_NORMAL,R0		; indicate success
	RSB

	.SBTTL	IOC$THREADCRB

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine will thread a CRB onto the duetime chain headed by
;	IOC$CRBTMOUT.
;
; CALLING SEQUENCE:
;
;	JSB	IOC$THREADCRB
;
; INPUTS:
;
;	R3 -->	CRB
;
; OUTPUTS:
;
;	NONE
;
;--

IOC$THREADCRB::
	PUSHL	R0			; Save a register
	MOVAL	G^IOC$GL_CRBTMOUT, R0	; Pointer to list head
10$:	TSTL	(R0)			; End of the line?
	BEQL	20$			; Yes, go add new one
	MOVL	(R0), R0		; No, get next block
	BRB	10$			; Try, try again

20$:	MOVAL	CRB$L_TIMELINK(R3),(R0)	; Link the new block in
	POPL	R0			; Restore register
	RSB				; Leave


	.END
