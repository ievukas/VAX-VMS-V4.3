%TITLE	'VAX-11 CONVERT'
MODULE	CONV$FSTLD	( IDENT='V04-000',
			OPTLEVEL=3
			) =

BEGIN

!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************

!++
!
! Facility:	VAX-11 CONVERT
!
! Abstract:	This module contains the high level calls for the fast load
!		process along with the declaratons for the data specifically
!		used by fast load
!
! Contents:
!		FAST_LOAD
!		INIT_FAST_LOAD
!		LOAD_PRIMARY
!		LOAD_SECONDARY
!		LOAD_DATA_BUCKET
!		LOAD_INDEX_BUCKET
!		FINISH_INDEX
!		BACKUP_INDEX
!
! Environment:
!
!		VAX/VMS Operating System
!
!--

!
! Author:	Keith B Thompson	Creation date:	August-1980
!
!
! Modified by:
!
!	V03-013	RAS0305		Ron Schaefer		 7-May-1984
!		Fix check for maximum index level so that we report
!		an error rather than get an access violation if the
!		index level exceeds 31.
!
!	V03-012	JWT0177		Jim Teague		17-Apr-1984
!		CONVERT always tried to load a sidr bucket, even if 
!		all records in the file had null keys for the 
!		index, thereby corrupting the file.  Correct this 
!		error by making sure at least one non-null key is 
!		encountered for an index before allocating and
!		loading a SIDR bucket.
!		
!	V03-011 JWT0143		Jim Teague		25-Nov-1983
!		CONVERT used to blindly add records until the fill
!		factor was exceeded.  Now, check to see if adding
!		a record will bring us closer to the fill factor.
!		If we're closer before the addition (even though
!		we may be short of the fill factor), then don't 
!		add the record.
!
!	V03-010	KBT0476		Keith B. Thompson	29-Jan-1983
!		Add support for the ADD_KEY function
!
!	V03-009	KBT0459		Keith B. Thompson	10-Jan-1983
!		Fix a bug when loading p3 sidrs with no dups
!
!	V03-008	KBT0404		Keith B. Thompson	19-Nov-1982
!		Fix some of the sidr code
!
!	V03-007	KBT0382		Keith B. Thompson	26-Oct-1982
!		Add prologue 3 sidr support
!
!	V03-006	KBT0375		Keith B. Thompson	20-Oct-1982
!		Check for keys out of order from split_data
!
!	V03-005	KBT0349		Keith B. Thompson	4-Oct-1982
!		Use new linkage definitions
!
!	V03-004	KBT0050		Keith Thompson		10-May-1982
!		Check for empty file before calling finish index
!
!	V03-003	KBT0047		Keith Thompson		14-Apr-1982
!		Fix end condition problem with the index buckets
!
!	V03-002	KBT0022		Keith Thompson		24-Mar-1982
!		Fix problem with last data bucket being continuation bucket
!		and more duplicate problems.  Change some linkages.
!
!	V03-001	KBT0012		Keith Thompson		16-Mar-1982
!		Fix some prologue 3 duplicate bugs in load_data_bucket
!		and remove prologue 3 secondary key code
!****


PSECT
	OWN	= _CONV$FAST_D	(PIC),
	GLOBAL	= _CONV$FAST_D	(PIC),
	PLIT	= _CONV$PLIT	(SHARE,PIC),
	CODE	= _CONV$FAST_S	(SHARE,PIC);

LIBRARY	'SYS$LIBRARY:LIB.L32';
LIBRARY	'SRC$:CONVERT';

DEFINE_ERROR_CODES;

EXTERNAL ROUTINE
	CONV$$GET_VM		: CL$GET_VM,
	CONV$$GET_TEMP_VM	: CL$GET_TEMP_VM,
	CONV$$FREE_TEMP_VM	: CL$FREE_TEMP_VM	NOVALUE,
	CONV$$EXCEPTION,
	CONV$$END_OF_FILE	: NOVALUE,
	CONV$$SORT_SECONDARY	: CL$SORT_SECONDARY,
	CONV$$GET_RECORD	: CL$GET_RECORD,
	CONV$$CHECK_S_DUP	: CL$JSB_REG_9,
	CONV$$CHECK_NULL	: CL$JSB_REG_9,
	CONV$$SPLIT_DATA	: CL$JSB_REG_9,
	CONV$$COMPRESS_KEY	: CL$JSB_REG_9	NOVALUE,
	CONV$$COMPRESS_INDEX	: CL$JSB_REG_9	NOVALUE,
	CONV$$MAKE_INDEX	: CL$JSB_REG_9	NOVALUE,
	CONV$$WRITE_VBN		: CL$JSB_REG_9	NOVALUE,
	CONV$$COPY_KEY		: CL$COPY_KEY	NOVALUE,
	CONV$$WRITE_BUCKET	: CL$JSB_REG_9	NOVALUE,
	CONV$$GET_BUCKET	: CL$JSB_REG_9	NOVALUE,
	CONV$$INIT_BUCKET	: CL$JSB_REG_9	NOVALUE,
	CONV$$CREATE_HIGH_KEY	: CL$JSB_REG_9	NOVALUE,
	CONV$$WRITE_PROLOGUE	: NOVALUE,
	CONV$$CONVERT_VBN_ID	: CL$CONVERT_VBN_ID	NOVALUE,
	CONV$$SET_KEY_DESC	: CL$SET_KEY_DESC,
	CONV$$GET_NEXT_KEY	: CL$GET_NEXT_KEY,
	CONV$$WRITE_KEY_DESC	: CL$WRITE_KEY_DESC	NOVALUE;

FORWARD ROUTINE
	CONV$$INIT_FAST_LOAD	: CL$INIT_FAST_LOAD	NOVALUE,
	LOAD_PRIMARY		: CL$JSB_REG_9,
	CONV$$LOAD_SECONDARY	: CL$LOAD_SECONDARY	NOVALUE,
	LOAD_DATA_BUCKET	: CL$JSB_REG_8	NOVALUE,
	LOAD_INDEX_BUCKET	: CL$JSB_REG_9	NOVALUE,
	FINISH_INDEX		: CL$JSB_REG_9	NOVALUE,
	BACKUP_INDEX		: CL$JSB_REG_9	NOVALUE;

EXTERNAL
	CONV$GL_FILL		: LONG,

	CONV$GW_OUT_REC_SIZ	: SIGNED WORD,		! Output Rec. Size

	CONV$GL_RECORD_COUNT,
	CONV$GL_EXCEPT_COUNT,
	CONV$GL_VALID_COUNT,

	CONV$GW_MAX_REC_SIZ	: WORD,			! Aprox. size of record buffer
	CONV$GL_RFA_BUFFER,

	CONV$AB_IN_RAB		: $RAB_DECL,
	CONV$AB_OUT_XABSUM	: $XABSUM_DECL,
	CONV$AB_OUT_FAB		: $FAB_DECL,
	CONV$AB_OUT_RAB		: $RAB_DECL,
	CONV$AB_RFA_RAB		: $RAB_DECL,

	CONV$GL_EOF_VBN		: LONG,
	CONV$GB_PROL_V1		: BYTE,
	CONV$GB_PROL_V2		: BYTE,
	CONV$GB_PROL_V3		: BYTE,
	CONV$AR_PROLOGUE	: REF BLOCK [ ,BYTE ],
	CONV$AR_AREA_BLOCK	: REF BLOCKVECTOR [ ,AREA$C_BLN,BYTE ];

LITERAL
	FALSE = 0,
	TRUE  = 1;

MACRO
!	Some needed macros to define the data record for a bucket
!
	IRC$L_RRV_VBN	= 3,0,32,0%,	! RRV VBN Pointer
	IRC$L_RRV_VBN3	= 5,0,32,0%,	! RRV VBN Pointer (Prologue 3)
	IRC$W_VAR_SIZ	= 7,0,16,0%,	! Var. Rec. Format Size field
	IRC$L_DUPCOUNT	= 2,0,32,0%,	! Duplicate count field
	IRC$W_DUPSZ	= 6,0,16,0%,	! Size field when dup. are allowed
	IRC$W_NODUPSZ	= 2,0,16,0%,	! Size field when dup. are not allowed
	IRC$W_P3SZ	= 0,0,16,0%,	! Size field for prologue 3 files

!	These macros make the code look a little better
!
	BKT$W_VBNFS	= .CONV$GW_VBN_FS_PTR,0,16,0%,	! VBN Freespace Pointer in index level
	BKT$W_VBNFS0	= .CONV$GW_VBN_FS_PTR0,0,16,0%,	! VBN Freespace Pointer at the data level
	BKT$L_LCBPTR	= .CONV$GW_LCB_PTR,0,32,0%;	! Last Contuation Bucket Pointer

!	Data Decl. for Fast Load routines
!
GLOBAL
	CONV$GL_RECORD_PTR	: LONG,		! Pointer to record bffer

	CONV$GW_VBN_FS_PTR	: WORD,
	CONV$GW_VBN_FS_PTR0	: WORD,
	CONV$GW_LCB_PTR		: WORD,
	
	CONV$GL_CTX_BLOCK	: LONG,		! Pointer to the contex block
	CONV$GL_DUP_BUF		: LONG;		! Pointer to the Duplicate buffer

OWN
	CONTINUATION	: BYTE,		! Continuation bucket
	DUPLICATE	: BYTE SIGNED,	! Duplicate record

	SAVE_FREESPACE	: WORD,		! Save pointer for backing up index
	SAVE_KEYFRESPC	: WORD,		!   "
	SAVE_VBNFS	: WORD;		!   "


%SBTTL	'FAST_LOAD'
GLOBAL ROUTINE	CONV$$FAST_LOAD : CL$JSB_REG_11 =
!++
!
! Functional Description:
!
!	FAST_LOAD is the driving routine for the fast loading process.  It
!	will load the primary key then sort and load all secondary keys if
!	any.
!
! Calling Sequence:
!
!	CONV$$FAST_LOAD()
!
! Input Parameters:
!	none
!
! Implicit Inputs:
!	none
!
! Output Parameters:
!	none
!
! Implicit Outputs:
!	none
!
! Routine Value:
!
!	RMS$_EOF or error code
!
! Routines called:
!
!	CONV$$INIT_FAST_LOAD
!	LOAD_PRIMARY
!	CONV$$END_OF_FILE
!	CONV$$WRITE_PROLOGUE
!	CONV$$SET_KEY_DESC
!	CONV$$SORT_SECONDARY
!	CONV$$LOAD_SECONDARY
!	CONV$$WRITE_KEY_DESC
!
! Side Effects:
!	none
!
!--

    BEGIN

    DEFINE_KEY_DESC;
    DEFINE_CTX_GLOBAL;
    DEFINE_BUCKET_GLOBAL;

    ! Init the fast load process for all keys
    !
    CONV$$INIT_FAST_LOAD( 0 );

    ! Load the primary data and index
    !
    RET_ON_ERROR( LOAD_PRIMARY() );

    ! Write prologue
    !
    CONV$$WRITE_PROLOGUE();

    ! Also write the key desc.
    !
    CONV$$WRITE_KEY_DESC();

    ! Finish off the input file
    !
    CONV$$END_OF_FILE();

    ! Free the space taken up by the loading
    !
    CONV$$FREE_TEMP_VM();

    ! Process the secondary keys if there we records put into the
    ! output file.
    !
    ! NOTE: This could cause secondary key indexes to be uninitialized.
    ! At the moment RMS doesn't mind, if they ever do, something must be fixed.
    !
    IF .CONV$GL_VALID_COUNT GTRU 0
    THEN

	! Loop for each key
	!
	WHILE CONV$$GET_NEXT_KEY()
	DO
	    BEGIN

	    ! Set up the sort for the secondary key.  The sort is a INDEX sort.
	    ! This type of sort will produce a file of RFA's and keys of the
	    ! primary data level we just made.
	    !
	    RET_ON_ERROR( CONV$$SORT_SECONDARY() );

	    ! Now that the file is sorted get the data and load it in.
	    !
	    CONV$$LOAD_SECONDARY();

	    ! Write the prologue
	    !
	    CONV$$WRITE_PROLOGUE();

	    ! And the key descriptor
	    !
	    CONV$$WRITE_KEY_DESC();

	    ! Free the space taken up by the last key load
	    !
	    CONV$$FREE_TEMP_VM()

	    END;

    RETURN RMS$_EOF

    END;

%SBTTL	'INIT_FAST_LOAD'
GLOBAL ROUTINE	CONV$$INIT_FAST_LOAD ( MAX_KEY ) : CL$INIT_FAST_LOAD NOVALUE =
!++
!
! Functional Description:
!
!	Initialize the fast load process.  Get memory for buffers and set up
!	pointers.  There are up to 3 pointers to record buffers at each level
!	RCP, RDP and LKB for level 0 and prologue 3 files.  The RCP, LKP and
!	RDP for all but level 0 pointers are set here.  The proper sizes are:
!
!				-----------------------------------------
!	LEVEL 0		RCP --->|	max_key + 13			|
!				-----------------------------------------
!
!				-----------------------------------------
!	LEVEL 1+	RCP --->|	5				|
!				-----------------------------------------
!
!				-----------------------------------------
!			RDP --->|	max_key + 2			|
!				-----------------------------------------
!
!				-----------------------------------------
!	ALL LEVELS	LKP --->|	max_key				|
!				-----------------------------------------
!
!	The RDP for level 0 is set in load_primary and load_secondary.
!
! Calling Sequence:
!
!	INIT_FAST_LOAD();
!
! Input Parameters:
!	none
!
! Implicit Inputs:
!	none
!
! Output Parameters:
!	none
!
! Implicit Outputs:
!	none
!
! Routine Value:
!	none
!
! Routines Called:
!
!	CONV$$SET_KEY_DESC
!	CONV$$GET_NEXT_KEY
!	CONV$GET_VM
!
! Side Effects:
!
!	Sets the end of file VBN pointer.  Allocates memory for record buffers.
!	Sets up the record data pointers, record control pointers and last key
!	pointers.
!
!--

    BEGIN

    DEFINE_CTX;
    DEFINE_BUCKET;
    DEFINE_KEY_DESC;

    ! Since we are doing block IO we dont need the XABs anymore
    ! If they are keep around area xabs (if any) will override the fab during
    ! an extend a screw everything up.
    !
    CONV$AB_OUT_FAB [ FAB$L_XAB ] = 0;

    ! Find the end of file VBN. In a new file it the one block past the last
    ! allocated area (the last area may not be allocated therefore look at
    ! one)
    !
    BEGIN		! HIGH_VBN local

    LOCAL	HIGH_VBN;

    HIGH_VBN = 0;

    INCR AREA FROM 0 TO ( .CONV$AB_OUT_XABSUM [ XAB$B_NOA ] - 1 ) BY 1
    DO

	! If the current extent starts at a higher VBN then the last one
	! us this one to find the end of file
	!
	IF .CONV$AR_AREA_BLOCK [ .AREA,AREA$L_CVBN ] GTR .HIGH_VBN
	THEN

	    ! The end of file is this the start of this extent plus the number
	    ! of blocks in the extent
	    !
	    CONV$GL_EOF_VBN = .CONV$AR_AREA_BLOCK [ .AREA,AREA$L_CVBN ] +
				.CONV$AR_AREA_BLOCK [ .AREA,AREA$L_CNBLK ];

    END;		! HIGH_VBN local

    ! Calculate the max space needed for index key buffers and init. the contex
    ! block.  If it was not given.
    !
    IF .MAX_KEY EQLU 0
    THEN
	BEGIN

	! The max. size is the size of the logest key.
	! So we check each key desc.
	!
	CONV$$SET_KEY_DESC( 0 );

	DO

	    IF .KEY_DESC [ KEY$B_KEYSZ ] GTR .MAX_KEY
	    THEN
		MAX_KEY = .KEY_DESC [ KEY$B_KEYSZ ]

	UNTIL NOT CONV$$GET_NEXT_KEY()
	END;

    BEGIN

    LOCAL	BYTES;

    ! Figure the total number of bytes. (SEE ABOVE)
    !
    BYTES = ( .MAX_KEY * ( MAX_IDX_LVL + 1 ) ) + ( MAX_IDX_LVL * 7 ) + 13;

    ! For Prologue 3 files we may need the last key buffers
    !
    IF .CONV$GB_PROL_V3
    THEN
	BYTES = .BYTES + ( .MAX_KEY * ( MAX_IDX_LVL - 1 ) );

    ! Add the space for the contex block
    !
    BYTES = .BYTES + ( MAX_IDX_LVL * CTX$K_BLN );

    ! Get the zero filled space
    !
    CONV$GL_CTX_BLOCK = CONV$$GET_VM ( .BYTES )

    END;

    ! Set all of the record control pointers and record data pointers for
    ! level one (1) and above.
    !
    CTX = .CONV$GL_CTX_BLOCK;

    CTX [ CTX$L_RCP ] = .CTX + ( MAX_IDX_LVL * CTX$K_BLN );

    BEGIN	! BUFFER_OFFSET local

    LOCAL	BUFFER_OFFSET;

    BUFFER_OFFSET = .CTX [ CTX$L_RCP ] + .MAX_KEY + 13;

    INCR I FROM 1 TO ( MAX_IDX_LVL - 1 ) BY 1
    DO
	BEGIN
	CTX = .CTX + CTX$K_BLN;
	CTX [ CTX$B_LEVEL ] = .I;
	CTX [ CTX$L_RCP ] = .BUFFER_OFFSET;
	CTX [ CTX$L_RDP ] = .BUFFER_OFFSET + 5;
	BUFFER_OFFSET = .BUFFER_OFFSET + .MAX_KEY + 7
	END;

    ! Set up the last key buffer for level 0
    !
    CTX = .CONV$GL_CTX_BLOCK;
    CTX [ CTX$L_LKP ] = .BUFFER_OFFSET;

    ! Set up the last key buffer if necessary for levels 1 and above
    !
    IF .CONV$GB_PROL_V3
    THEN
	INCR I FROM 1 TO ( MAX_IDX_LVL - 1 ) BY 1
	DO
	    BEGIN
	    CTX = .CTX + CTX$K_BLN;
	    BUFFER_OFFSET = .BUFFER_OFFSET + .MAX_KEY;
	    CTX [ CTX$L_LKP ] = .BUFFER_OFFSET
	    END

    END;	! BUFFER_OFFSET local

    RETURN

    END;

%SBTTL	'LOAD_PRIMARY'
ROUTINE	LOAD_PRIMARY : CL$JSB_REG_9 =
!++
!
! Functional Description:
!
!	Loads the primary key of a index sequential file.
!
! Calling Sequence:
!
!	LOAD_PRIMARY()
!
! Input Parameters:
!	none
!
! Implicit Inputs:
!	none
!
! Output Parameters:
!	none
!
! Implicit Outputs:
!	none
!
! Routine Value:
!
!	RMS$_EOF or error codes
!
! Routine Called:
!
!	CONV$$SET_KEY_DESC
!	CONV$$GET_TEMP_VM
!	CONV$$GET_BUCKET
!	CONV$$GET_RECORD
!	CONV$$EXCEPTION
!	CONV$$SPLIT_DATA
!	LOAD_DATA_BUCKET
!	FINISH_INDEX
!
! Side Effects:
!
!	Loads primary key
!
!--

    BEGIN

    LABEL
	DUP_BLK;

    DEFINE_CTX;
    DEFINE_BUCKET;
    DEFINE_KEY_DESC;

    CTX = .CONV$GL_CTX_BLOCK;

    ! Set key to the primary index
    !
    CONV$$SET_KEY_DESC( 0 );

    ! Errors on the rab from now on are WRITEERRs
    !
    CONV$AB_OUT_RAB [ RAB$L_CTX ] = CONV$_WRITEERR;

    ! For prologue 3 files we need an extra buffer for the data record
    ! Else we let the REC_DATA_PTR point to the user buffer of the output rab
    !
    IF .CONV$GB_PROL_V3
    THEN
	BEGIN

	LOCAL	BYTES;

	! The worst case is fully non compressed record with compression info
	!
	BYTES = .CONV$GW_MAX_REC_SIZ + 3;

	! Get the space for the data buffer
	!
	! Record data pointer at level 0 will point to the new buffer
	!
	CTX [ CTX$L_RDP ] = CONV$$GET_TEMP_VM ( .BYTES )

	END
    ELSE

	! Record data pointer at level 0 points to Record Ptr
	!
	CTX [ CTX$L_RDP ] = .CONV$GL_RECORD_PTR;

    ! Get the Buckets for the data area and at least the first level of the index
    !
    ! Get the bucket for level 0
    !
    CONV$$GET_BUCKET( .KEY_DESC [ KEY$B_DANUM ] );

    KEY_DESC [ KEY$L_LDVBN ] = .CTX [ CTX$L_CURRENT_VBN ];

    ! Get the bucket for level 1
    !
    CTX = .CTX + CTX$K_BLN;
    CONV$$GET_BUCKET( .KEY_DESC [ KEY$B_LANUM ] );

    CTX = .CONV$GL_CTX_BLOCK;

    ! For the primary key the Data comes from GET_RECORD. NOTE: Don't use the
    ! UBF of the input RAB since some record conversion may be done. Also note
    ! the RBF pointer of the output RAB is destroyed after the first call to
    ! WRITE_BUCKET but it is ok to use it now.
    !
    BEGIN

    DEFINE_RECORD_CTRL_GLOBAL;

    LOCAL
	STATUS;

    RECORD_CTRL = .CTX [ CTX$L_RCP ];

    ! Main record processing loop.  The call to GET_RECORD does any record format
    ! processing and exception handling before it returns.  The size of the record
    ! is passed back by OUT_REC_SIZ.
    !
    WHILE ( STATUS = CONV$$GET_RECORD() )
    DO
	BEGIN		! Main Loop

DUP_BLK:
	BEGIN		! DUP_BLK Primary duplicate block

	! If the record is shorter the minium record length of the primary key
	! cause an exception
	!
	IF .CONV$GW_OUT_REC_SIZ LSS .KEY_DESC [ KEY$W_MINRECSZ ]
	THEN
	    BEGIN

	    LOCAL STATUS;

	    ! If it was not fatal continue else exit
	    !
	    IF STATUS = CONV$$EXCEPTION( CONV$_RSK )
	    THEN
		LEAVE DUP_BLK
	    ELSE
		RETURN .STATUS
	    END;

	! Seperate the key from the data record if necessary and do
	! data compression if necessary also check if this is a duplicate
	! or the key is out of order
	!
	DUPLICATE = CONV$$SPLIT_DATA();

	! If out of order, i.e. duplicate = -1, signal exception and continue
	!
	IF .DUPLICATE LSS 0
	THEN
	    BEGIN

	    LOCAL	STATUS;

	    ! If not fatal exception then continue else bomb
	    !
	    IF STATUS = CONV$$EXCEPTION ( CONV$_SEQ )
	    THEN
		LEAVE DUP_BLK
	    ELSE
		RETURN .STATUS

	    END;

	! If we got a dup and we dont allow dups then cause an exception
	!
	IF .DUPLICATE AND ( NOT .KEY_DESC [ KEY$V_DUPKEYS ] )
	THEN
	    BEGIN

	    LOCAL	STATUS;

	    ! If not fatal exception then continue else bomb
	    !
	    IF STATUS = CONV$$EXCEPTION ( CONV$_DUP )
	    THEN
		LEAVE DUP_BLK
	    ELSE
		RETURN .STATUS

	    END;

	! Set up the control byte for the record
	!
	RECORD_CTRL [ IRC$B_CONTROL ] = 2;

	! Set the size field int the record
	!
	IF .CONV$GB_PROL_V3
	THEN
	    BEGIN

	    ! A small non compressed fixed length record has no size field
	    !
	    IF .KEY_DESC [ KEY$V_REC_COMPR ] OR
		.KEY_DESC [ KEY$V_KEY_COMPR ] OR
		( .CONV$AB_OUT_FAB [ FAB$B_RFM ] EQLU FAB$C_VAR )
	    THEN
		RECORD_CTRL [ 9,0,16,0 ] = .CTX [ CTX$W_RCS ] +
							.CTX [ CTX$W_RDS ] - 11
	    END
	ELSE

	    ! Set up the record size for var. length records 
	    ! for prologue 1 and 2 files
	    !
	    IF .CONV$AB_OUT_FAB [ FAB$B_RFM ] EQLU FAB$C_VAR
	    THEN
		RECORD_CTRL [ IRC$W_VAR_SIZ ] = .CONV$GW_OUT_REC_SIZ;

	! If we are in a continuation bucket and the current record is NOT a
	! duplicate then write the current bucket out and start a new one
	!
	! For optimumization do the continuation check first
	!
	IF .CONTINUATION THEN IF NOT .DUPLICATE
	THEN
	    BEGIN

	    CONV$$WRITE_BUCKET();

	    CONV$$INIT_BUCKET();

	    ! Continuation no longer need be set.  (the next record will always
	    ! fix into the new bucket
	    !
	    CONTINUATION = _CLEAR

	    END;

	! Load the record
	!
	LOAD_DATA_BUCKET()

	END		! DUP_BLK Primary duplicate block
	END;		! Main loop

    ! If we exited because of end of file and there are records in the file
    ! then finish off the index
    !
    IF ( .STATUS EQLU RMS$_EOF ) AND
			( .CONV$GL_RECORD_COUNT NEQU .CONV$GL_EXCEPT_COUNT )
    THEN
	FINISH_INDEX();

    RETURN CONV$_SUCCESS

    END
    END;


%SBTTL	'LOAD_SECONDARY'
GLOBAL ROUTINE	CONV$$LOAD_SECONDARY : CL$LOAD_SECONDARY NOVALUE =
!++
!
! Functional Description:
!
!	Loads a secondary key of an index sequential file.  Which secondary
!	index depends on KEY_REF.  The secondary
!	data records are read from the RFA file created and opened by
!	SORT_SECONDARY.  NOTE:  The overall operation of LOAD_SECONDARY is
!	fundementally different then LOAD_PRIMARY.
!
! Calling Sequence:
!
!	CONV$$LOAD_SECONDARY();
!
! Input Parameters:
!	none
!
! Implicit Inputs:
!	none
!
! Output Parameters:
!	none
!
! Implicit Outputs:
!	none
!
! Routine Value:
!
!	RMS$_EOF or error codes
!
! Routines Called:
!
!	CONV$$GET_BUCKET
!	CONV$$GET_TEMP_VM
!	$GET
!	CONV$$CHECK_NULL
!	CONV$$CHECK_S_DUP
!	LOAD_DATA_BUCKET
!	CONV$$COPY_KEY
!	CONV$$WRITE_BUCKET
!	CONV$$INIT_BUCKET
!	CONV$$CONVERT_VBN_ID
!	FINISH_INDEX
!
! Side Effects:
!
!	Loads secondary index defined by KEY_REF
!
!--

    BEGIN

    DEFINE_CTX;
    DEFINE_BUCKET;
    DEFINE_KEY_DESC;

    LABEL
	NULL_BLK;

    LOCAL
	DUP_COUNT,
	MAX_NUM_DUP;

    ! Init some values
    !
    CONTINUATION = _CLEAR;
    DUPLICATE = _CLEAR;

    ! Errors on the rab from now on are WRITEERRs
    !
    CONV$AB_OUT_RAB [ RAB$L_CTX ] = CONV$_WRITEERR;

    ! Point to the first block
    !
    CTX = .CONV$GL_CTX_BLOCK;

    ! Get the Buckets for the secondary data area and at least the
    ! first level of the index
    !
    ! Get the bucket for level 0
    !
    CONV$$GET_BUCKET( .KEY_DESC [ KEY$B_DANUM ] );

    KEY_DESC [ KEY$L_LDVBN ] = .CTX [ CTX$L_CURRENT_VBN ];

    ! Get the bucket for level 1
    !
    CTX = .CTX + CTX$K_BLN;
    CONV$$GET_BUCKET( .KEY_DESC [ KEY$B_LANUM ] );

    CTX = .CONV$GL_CTX_BLOCK;

    ! Before we start we need to calcluate the size of the level 0 index record
    ! buffer.  This calculation is VERY important it must be very accurate!
    !
    ! If we allow dup. keys the it becomes complicated
    !
    ! Find out the max. number of duplicates that can fit in this bucket
    !
    IF .KEY_DESC [ KEY$V_DUPKEYS ]
    THEN

	! Sizes are different for prologue 3
	!
	IF .CONV$GB_PROL_V3
	THEN

	    ! For compression it is also different
	    !
	    IF .KEY_DESC [ KEY$V_IDX_COMPR ]
	    THEN

		! The space in the bucket minus the key size and the record 
		!	overhead (2+2) divided by the size of the SIDR record
		!	pointer (7)
		!
		MAX_NUM_DUP = ( .CTX [ CTX$W_SPC ] -
				    ( .KEY_DESC [ KEY$B_KEYSZ ] + 4 ) ) / 7
	    ELSE

		! The space in the bucket minus the key size and the record 
		!	overhead (2) divided by the size of the SIDR record
		!	pointer (7)
		!
		MAX_NUM_DUP = ( .CTX [ CTX$W_SPC ] -
				    ( .KEY_DESC [ KEY$B_KEYSZ ] + 2 ) ) / 7

	ELSE

	    ! The space in the bucket minus the key size and the record 
	    !		overhead (8) divided by the size of the SIDR record
	    !		pointer (6)
	    !
	    MAX_NUM_DUP = ( .CTX [ CTX$W_SPC ] -
				    ( .KEY_DESC [ KEY$B_KEYSZ ] + 8 ) ) / 6
    ELSE
	MAX_NUM_DUP = 1;

    BEGIN

    LOCAL	BYTES;

    ! The size of the level 0 buffer consist of:
    !
    !	Space for all RRVs (one for each dup) : Largest rrv - prologue 3, 7 bytes
    !	Overhead : Maximun overhead - prologue 1, 8 bytes
    !
    ! We also need a duplicate buffer for things which is the size of the key
    !
    BYTES = ( .MAX_NUM_DUP * 7 ) + 8 + .KEY_DESC [ KEY$B_KEYSZ ];

    ! Allocate the memory for the buffer
    ! The level 0 data record pointers points to this buffer
    !
    CTX [ CTX$L_RDP ] = CONV$$GET_TEMP_VM ( .BYTES );

    ! The duplicate buffer is just past that
    !
    CONV$GL_DUP_BUF = .CTX [ CTX$L_RDP ] + ( .MAX_NUM_DUP * 7 ) + 8

    END;

    ! For the secondary key the Data comes from $GET on the RFA RAB
    !
    BEGIN		! RECORD_CTRL local

    DEFINE_RECORD_CTRL_GLOBAL;

    LOCAL
	ALL_NULL,
	SKIP,
	STATUS;

    SKIP = _CLEAR;

    RECORD_CTRL = .CTX [ CTX$L_RCP ];

    ALL_NULL = _SET;	! Could be nothing but null keys, you know...

    ! Main record processing loop. The size of the record is returned in
    ! RFA_RAB [ RAB$W_RSZ ]
    !
    WHILE ( STATUS = $GET( RAB=CONV$AB_RFA_RAB ) )
    DO
	BEGIN		! Main Loop

NULL_BLK:
	BEGIN		! NULL_BLK null key value block

	LOCAL	DUP;

	! If the record is too short (does not contain the complete key)
	! then treat it as a null key
	!
	IF ( .CONV$AB_RFA_RAB [ RAB$W_RSZ ] - 6 ) LSSU .KEY_DESC [ KEY$B_KEYSZ ]
	THEN
	    LEAVE NULL_BLK;

	! If the file allows null keys check to see if this is one
	!
	IF .KEY_DESC [ KEY$V_NULKEYS ]
	THEN

	    ! If this is a null key then just ignore this record
	    !
	    IF CONV$$CHECK_NULL()
	    THEN
		LEAVE NULL_BLK;

	!
	! If we got a non-null key, then all_null can no longer be true
	!
	IF .ALL_NULL THEN ALL_NULL = _CLEAR;

	! Check to see if this is a duplicate.
	!
	DUP = CONV$$CHECK_S_DUP();

	! Process the key
	!
	IF .KEY_DESC [ KEY$V_DUPKEYS ]
	THEN
	    BEGIN

	    ! If this was a dup 
	    !
	    IF .DUP
	    THEN
		BEGIN

		DUP_COUNT = .DUP_COUNT + 1;

		! If we have exceeded the max number of dups per bucket then
		! get rid of this bucket and start a new one
		!
		IF .DUP_COUNT GEQ .MAX_NUM_DUP
		THEN
		    BEGIN

		    LOAD_DATA_BUCKET();

		    ! The record to go into the next bucket will be a duplicate
		    !
		    DUPLICATE = _SET;

		    ! We are now in a continuation bucket
		    !
		    SKIP = _SET;

		    ! Copy the key into the record (in a continuation bucket
		    ! there is no dup count ie. the 4)
		    !
		    CONV$$COPY_KEY( 4 );

		    ! Start counting dups again
		    !
		    DUP_COUNT = 0;

		    ! Set the sidr array record size
		    !
		    CTX [ CTX$W_RDS ] = 0;

		    ! Set some control fields. NOTE: COPY_KEY sets prologue 3
		    ! record size field.
		    !
		    IF NOT .CONV$GB_PROL_V3
		    THEN
			BEGIN

			! A continuation record has no duplicate pointer
			!
		    	RECORD_CTRL [ IRC$B_CONTROL ] = IRC$M_NOPTRSZ;

			! Prologue 1,2 size field includes a key
			!
		    	RECORD_CTRL [ IRC$W_NODUPSZ ] = .KEY_DESC [ KEY$B_KEYSZ ]

			END
		    END
		END
	    ELSE
		BEGIN

		! If this is the first non-dup then don't load anything else
		! load the last record processed
		!
		IF NOT .CTX [ CTX$V_FST ]
		THEN
		    BEGIN

		    LOAD_DATA_BUCKET();

		    ! The next record will not be a duplicate record
		    !
		    DUPLICATE = _CLEAR;

		    ! If we were in a continuatio bucket then dont make an index
		    ! for it. Also write the bucket because we don't put anything
		    ! in a bucket after a dup.
		    !
		    IF .SKIP
		    THEN
			BEGIN
			SKIP = _CLEAR;

			CONV$$WRITE_BUCKET();
			CONV$$INIT_BUCKET();

			! The next record will always fit into the new bucket
			! so clearing the continuation flag is ok
			!
			CONTINUATION = _CLEAR

			END
		    END;

		! Copy the key into the record past the dup count field (ie the 8)
		!
		CONV$$COPY_KEY( 8 );

		! Start counting the dups
		!
		DUP_COUNT = 0;

		! Set the sidr array record size
		!
		CTX [ CTX$W_RDS ] = 0;

		! Set some control fields. NOTE: COPY_KEY sets prologue 3
		! record size field.
		!
		IF NOT .CONV$GB_PROL_V3
		THEN
		    BEGIN

		    ! The size of the dup pointer (1=4bytes)
		    !
		    RECORD_CTRL [ IRC$B_CONTROL ] = 1;

		    ! Zero the field (not implemented)
		    !
		    RECORD_CTRL [ IRC$L_DUPCOUNT ] = 0;

		    ! Prologue 1,2 size field includes a key
		    !
		    RECORD_CTRL [ IRC$W_DUPSZ ] = .KEY_DESC [ KEY$B_KEYSZ ]

		    END

		END;

	    ! Add to the size of the dup for this record.
	    !
	    ( IF .CONV$GB_PROL_V3
	    THEN

		! A prologue 3 RRV is 7 bytes (1 control,2 ID,4 VBN)
		!
		RECORD_CTRL [ IRC$W_P3SZ ] = .RECORD_CTRL [ IRC$W_P3SZ ] + 7

	    ELSE
		BEGIN

		! A prologue 1,2 RRV is 6 bytes (1 control,1 ID,4 VBN )
		!
		IF .RECORD_CTRL [ IRC$V_NOPTRSZ ]
		THEN
		    RECORD_CTRL [ IRC$W_NODUPSZ ] =
					    .RECORD_CTRL [ IRC$W_NODUPSZ ] + 6
		ELSE
		    RECORD_CTRL [ IRC$W_DUPSZ ] =
					    .RECORD_CTRL [ IRC$W_DUPSZ ] + 6
		END )

	    END
	ELSE
	    BEGIN

	    ! If the keys are duplicate and we are not allowing dup. then error
	    !
	    IF .DUP
	    THEN
		SIGNAL_STOP( CONV$_LOADIDX,
				1,
				.KEY_DESC [ KEY$B_KEYREF ],
				RMS$_DUP );

	    ! If this is the first record don't load anything else load the
	    ! last record
	    !
	    IF NOT .CTX [ CTX$V_FST ]
	    THEN
		LOAD_DATA_BUCKET();

	    ! Move the key value
	    !
	    CONV$$COPY_KEY( 4 );

	    ! Set the sidr array record size
	    !
	    CTX [ CTX$W_RDS ] = 0;

	    ! Set some control fields. NOTE: COPY_KEY sets prologue 3 record
	    ! size field NOT counting the pointer so we must add it here
	    !
	    IF .CONV$GB_PROL_V3
	    THEN
		RECORD_CTRL [ IRC$W_P3SZ ] = .RECORD_CTRL [ IRC$W_P3SZ ] + 7
	    ELSE
		BEGIN

		! Non dup records don't have a dup count
		!
		RECORD_CTRL [ IRC$B_CONTROL ] = IRC$M_NOPTRSZ;

		RECORD_CTRL [ IRC$W_NODUPSZ ] = .KEY_DESC [ KEY$B_KEYSZ ] + 6

		END

	    END;

	! Load the SIDR array pointer
	!
	BEGIN	! SIDR local

	DEFINE_VBN_ID_GLOBAL;

	LOCAL	SIDR	: REF BLOCK [ ,BYTE ];

	! Convert the VBN and the ID that SORT returns in the file
	!
	CONV$$CONVERT_VBN_ID();

	! Move the record pointer right after the last one, if any
	!
	SIDR = .CTX [ CTX$L_RDP ] + .CTX [ CTX$W_RDS ];

	! If prologue 3 the ID is bigger
	!
	IF .CONV$GB_PROL_V3
	THEN
	    BEGIN

	    ! Set the first_key flag if necessary
	    !
	    IF .DUP
	    THEN
		SIDR [ 0,0,8,0 ] = 2			! Can't be first if dup
	    ELSE
		SIDR [ 0,0,8,0 ] = 2 + IRC$M_FIRST_KEY;	! Set flag and size

	    SIDR [ 1,0,16,0 ] = .SORT_ID;
	    SIDR [ 3,0,32,0 ] = .SORT_VBN;
	    CTX [ CTX$W_RDS ] = .CTX [ CTX$W_RDS ] + 7
	    END
	ELSE
	    BEGIN
	    SIDR [ 0,0,8,0 ] = 2;
	    SIDR [ 1,0,8,0 ] = .SORT_ID;
	    SIDR [ 2,0,32,0 ] = .SORT_VBN;
	    CTX [ CTX$W_RDS ] = .CTX [ CTX$W_RDS ] + 6
	    END

	END;		! SIDR local

	! If we are here then we have processed at least one non null record
	!
	CTX [ CTX$V_FST ] = _CLEAR;

	! If this is a non dup key then copy the current record into
	! dup buffer
	!
	IF NOT .DUP
	THEN
	    CH$MOVE( .KEY_DESC [ KEY$B_KEYSZ ],
		     .CONV$GL_RFA_BUFFER + 6,
		     .CONV$GL_DUP_BUF )

	END		! NULL_BLK null key value block

	END;		! Main loop

    ! If we exited because of end of file AND we got at least 1
    !  non-null key value, then finish off the index
    !
    IF .STATUS EQL RMS$_EOF AND NOT .ALL_NULL
    THEN
	BEGIN

	! There is a SIDR record left over at this point
	! We must load it in before we finish off the index
	!
	LOAD_DATA_BUCKET();

	FINISH_INDEX()

	END;

    RETURN

    END		! RECORD_CTRL local

    END;

%SBTTL	'LOAD_DATA_BUCKET'
ROUTINE	LOAD_DATA_BUCKET : CL$JSB_REG_8 NOVALUE =
!++
!
! Functional Description:
!
!	Loads a data bucket independent of key of reference in the
!	index.  On a call to LOAD_DATA_BUCKET a record is loaded into a bucket
!	and return.  If the record for some reason does not fit into the current
!	bucket an index is made for the bucket and the bucket is written to the
!	output file.  The written bucket is initialized and then loaded with
!	the original record.  The index for a bucket is made by calling
!	LOAD_INDEX_BUCKET.
!
! Calling Sequence:
!
!	LOAD_DATA_BUCKET();
!
! Input Parameters:
!	none
!
! Implicit Inputs:
!
! Output Parameters:
!	none
!
! Implicit Outputs:
!	none
!
! Routine Value:
!
!	SS$NORMAL or error codes
!
! Routines Called:
!
!	CONV$$GET_BUCKET
!	LOAD_INDEX_BUCKET
!	CONV$$SAVE_BUCKET
!	CONV$$WRITE_BUCKET
!	CONV$$INIT_BUCKET
!	CONV$$RESTORE_BUCKET
!	CONV$$COMPRESS_KEY
!	CONV$$MAKE_INDEX
!	CONV$$WRITE_VBN
!
! Side Effects:
!
!	Loads a record into a bucket.  Writes buckets and creates indexs
!	for lower level buckets
!
!--

    BEGIN

    DEFINE_CTX;
    DEFINE_BUCKET;
    DEFINE_KEY_DESC;
    DEFINE_RECORD_CTRL;

    ! Set the bucket pointer to the bucket at this level
    !
    BUCKET = .CTX [ CTX$L_CURRENT_BUFFER ];

    ! Will the record fit into the bucket, if not then call this thing
    ! with an index to the record.
    !
    ! A record will not fit into a bucket if:
    !
    !	For all files:
    !
    ! a) the combined record data size and record control size is greater then
    !	 the space availaible in the bucket.
    !
    ! b) the FILL switch is OFF and the space left in the bucket is less then
    !	 that allowed by bucket fill quanities
    !
    !	For prologue 1 & 2 files:
    !
    ! c) the record ID of the new record is 0 indicating that the bucket is
    !	 filled (as far as id are concerned)
    !
    IF ( ( ( .CTX [ CTX$W_RDS ] + .CTX [ CTX$W_RCS ] ) GTRU
							.CTX [ CTX$W_SPC ] ) 
	OR

	( IF .CONV$GB_PROL_V3
	  THEN	0
	  ELSE	.BUCKET [ BKT$B_NXTRECID ] EQLU 0 ) 

	OR

	( ( NOT .CONV$GL_FILL ) AND
	  ( LOCAL
		SPACE_USED_IF_RECORD_ADDED;
	    SPACE_USED_IF_RECORD_ADDED = .CTX[CTX$W_USE] + .CTX[CTX$W_RCS]
						+ .CTX[CTX$W_RDS];
	    IF .KEY_DESC[KEY$W_DATFILL] - .CTX[CTX$W_USE]		! If the difference now
			LEQ						!	(must be signed)
	       .SPACE_USED_IF_RECORD_ADDED - .KEY_DESC[KEY$W_DATFILL]	! is less than it would
	    THEN							! be if the record were added,
		TRUE							! then don't add it
	    ELSE							! else 
		FALSE							!	go ahead and add it
	   ) ) )

    THEN
	BEGIN	! Load index block

	! If for some reason we dont want to make an index entry for this
	! record then skip it.
	!
	IF NOT .CONTINUATION
	THEN
	    BEGIN

	    ! Increse the level number for the next index level
	    !
	    CTX = .CTX + CTX$K_BLN;

	    ! Call to LOAD_INDEX_BUCKET to load the next level of the index
	    !
	    LOAD_INDEX_BUCKET();

	    ! Return the level
	    !
	    CTX = .CTX - CTX$K_BLN;

	    ! Restore the bucket pointer to the current level bucket since
	    ! we should be looking at some other one.
	    !
	    BUCKET = .CTX [ CTX$L_CURRENT_BUFFER ]

	    END;

	! Write the bucket we filled
	!
	CONV$$WRITE_BUCKET();

	! If this is a dup then the next bucket is a continuation bucket
	!
	IF .DUPLICATE
	THEN
	    CONTINUATION = _SET
	ELSE
	    CONTINUATION = _CLEAR;

	! Initialize the bucket to use it again
	!
	CONV$$INIT_BUCKET()

	END;	! Load index block

    BEGIN	! BKT_*_PTR local

    ! Load the record into the bucket...
    ! First we must set up pointers to where the record will go in the bucket
    ! These are:
    !
    LOCAL
	BKT_CTRL_PTR,	! Control information
	BKT_DATA_PTR;	! Actual data record

    ! For Prologue 3 files...
    !
    IF .CONV$GB_PROL_V3
    THEN
	BEGIN

	! If key compression is on do it
	!
	IF .KEY_DESC [ KEY$V_KEY_COMPR ]
	THEN
	    CONV$$COMPRESS_KEY();

	! Key of ref. specific things
	!
	IF .KEY_DESC [ KEY$B_KEYREF ] EQL 0
	THEN

	    ! The Primary key...
	    !
	    BEGIN

	    ! The record ID
	    !
	    RECORD_CTRL [ IRC$W_ID ] = .BUCKET [ BKT$W_NXTRECID ];

	    ! The RRV points to it's self ie. it's own ID and VBN
	    !
	    RECORD_CTRL [ IRC$W_RRV_ID ] = .BUCKET [ BKT$W_NXTRECID ];
	    RECORD_CTRL [ IRC$L_RRV_VBN3 ] = .CTX [ CTX$L_CURRENT_VBN ];

	    ! Update the record next record id in the bucket
	    !
	    BUCKET [ BKT$W_NXTRECID ] = .BUCKET [ BKT$W_NXTRECID ] + 1

	    END
	END
    ELSE

	! For prologue 1 and 2 files...
	!
	BEGIN

	! The record ID
	!
	RECORD_CTRL [ IRC$B_ID ] = .BUCKET [ BKT$B_NXTRECID ];

	! If this is the primary data level the set up the RRV
	!
	IF .KEY_DESC [ KEY$B_KEYREF ] EQL 0
	THEN
	    BEGIN

	    ! The RRV points to itself ie. it's own ID and VBN
	    !
	    RECORD_CTRL [ IRC$B_RRV_ID ] = .BUCKET [ BKT$B_NXTRECID ];
	    RECORD_CTRL [ IRC$L_RRV_VBN ] = .CTX [ CTX$L_CURRENT_VBN ]

	    END;

	! Update the next record id in the bucket
	!
	BUCKET [ BKT$B_NXTRECID ] = .BUCKET [ BKT$B_NXTRECID ] + 1

	END;

    ! For all data levels the control bytes are put at the bucket
    ! freespace.  The data bytes are put directly after the control.
    !
    BKT_CTRL_PTR = .BUCKET [ BKT$W_FREESPACE ] + .BUCKET;
    BKT_DATA_PTR = .BKT_CTRL_PTR + .CTX [ CTX$W_RCS ];

    ! Update the bucket pointer (NOTE: Same update for all cases)
    !
    BUCKET [ BKT$W_FREESPACE ] = .BUCKET [ BKT$W_FREESPACE ] +
						.CTX [ CTX$W_RCS ] +
						.CTX [ CTX$W_RDS ];

    ! Load the record into the bucket...
    ! Move the control bytes into the bucket
    !
    CH$MOVE( .CTX [ CTX$W_RCS ],.CTX [ CTX$L_RCP ],.BKT_CTRL_PTR );

    ! Move the data bytes (or sidr array) into the bucket
    !
    CH$MOVE( .CTX [ CTX$W_RDS ],.CTX [ CTX$L_RDP ],.BKT_DATA_PTR );

    END;	! BKT_*_PTR local

    ! Update the amount of space left in the bucket and the amount used
    !
    BEGIN

    LOCAL
	SPACE_USED;

    SPACE_USED = .CTX [ CTX$W_RCS ] + .CTX [ CTX$W_RDS ];

    CTX [ CTX$W_SPC ] = .CTX [ CTX$W_SPC ] - .SPACE_USED;

    CTX [ CTX$W_USE ] = .CTX [ CTX$W_USE ] + .SPACE_USED;

    END;

    ! Make an index for the next level
    !
    CONV$$MAKE_INDEX();

    ! Set the index record control bytes and bucket pointer
    !
    CONV$$WRITE_VBN();

    RETURN

    END;

%SBTTL	'LOAD_INDEX_BUCKET'
ROUTINE	LOAD_INDEX_BUCKET : CL$JSB_REG_9 NOVALUE =
!++
!
! Functional Description:
!
!	Loads an index bucket independent level in the index.  On a
!	call to LOAD_INDEX_BUCKET a record is loaded into a bucket and
!	return.  If the record for some reason does not fit into the current
!	bucket an index is made for the bucket and the bucket is written to the
!	output file.  The written bucket is initialized and then loaded with
!	the original record.  The index for a bucket is made by calling
!	LOAD_INDEX_BUCKET recursivly. Each recursive call to LOAD_INDEX_BUCKET
!	is to moving up the index tree.  CTX keeps track to where you are in
!	the tree.  Most all variables are dependent on CTX so that the
!	context of each level is saved.
!
! Calling Sequence:
!
!	LOAD_INDEX_BUCKET()
!
! Input Parameters:
!	none
!
! Implicit Inputs:
!	none
!
! Output Parameters:
!	none
!
! Implicit Outputs:
!	none
!
! Routine Value:
!
!	SS$NORMAL or error codes
!
! Routines Called:
!
!	CONV$$GET_BUCKET
!	LOAD_INDEX_BUCKET	- Recursive call
!	CONV$$WRITE_BUCKET
!	CONV$$INIT_BUCKET
!	CONV$$COMPRESS_INDEX
!	CONV$$WRITE_VBN
!
! Side Effects:
!
!	Loads a record into a bucket.  Writes buckets and creates indexs
!	for lower level buckets
!
!--

    BEGIN

    DEFINE_CTX;
    DEFINE_BUCKET;
    DEFINE_KEY_DESC;

    ! Set the bucket pointer to the bucket at this level
    !
    BUCKET = .CTX [ CTX$L_CURRENT_BUFFER ];

    ! See if we have reached the maximun level. (If we have this is the
    ! biggest file in the world!)
    !
    IF .CTX [ CTX$B_LEVEL ] GEQU MAX_IDX_LVL - 1
    THEN
	SIGNAL_STOP( CONV$_IDX_LIM );
    
    ! Will the record fit into the bucket, if not then call this thing
    ! with an index to the record.
    !
    ! A record will not fit into a bucket if:
    !
    !	For all files:
    !
    ! a) the combined record data size and record control size is greater then
    !	 the space availaible in the bucket.
    !
    ! b) the FILL switch is OFF and the space left in the bucket is less then
    !	 that allowed by bucket fill quanities
    !
    !	For prologue 3 files:
    !
    ! c) the bucket below has a different size vbn then this bucket (this
    !	 is to keep the same size vbn index buckets)
    !
    IF ( ( ( .CTX [ CTX$W_RDS ] + .CTX [ CTX$W_RCS ] ) GTRU
							.CTX [ CTX$W_SPC ] ) 
	OR

	( ( NOT .CONV$GL_FILL ) AND
	  ( LOCAL
		SPACE_USED_IF_RECORD_ADDED;
	    SPACE_USED_IF_RECORD_ADDED = .CTX[CTX$W_USE] + .CTX[CTX$W_RCS]
						+ .CTX[CTX$W_RDS];
	    IF .KEY_DESC[KEY$W_IDXFILL] - .CTX[CTX$W_USE]		! If the difference now
			LEQ						!	(must be signed)
	       .SPACE_USED_IF_RECORD_ADDED - .KEY_DESC[KEY$W_IDXFILL]	! is less than it would
	    THEN							! be if the record were added,
		TRUE							! then don't add it
	    ELSE							! else 
		FALSE							!	go ahead and add it
	   ) ) 

	OR

	( IF .CONV$GB_PROL_V3
	  THEN
	      ( LOCAL CTX_M1 : REF BLOCK [ ,BYTE ];
		CTX_M1 = .CTX - CTX$K_BLN;
		IF .BUCKET [ BKT$V_PTR_SZ ] NEQU .CTX_M1 [ CTX$V_VBN ]
		THEN 1
		ELSE 0
		)
	  ELSE 0 ) )
    THEN
	BEGIN	! Load index block

	! Switch for the next index level
	!
	CTX = .CTX + CTX$K_BLN;

	! See if the bucket in at the next level is ready if not get it ready
	!
	IF NOT .CTX [ CTX$V_RDY ]
	THEN

	    ! Get the space for the bucket
	    !
	    CONV$$GET_BUCKET( .KEY_DESC [ KEY$B_IANUM ] );

	! Recursive call to LOAD_INDEX_BUCKET to load the next level of the index
	!
	LOAD_INDEX_BUCKET();

	! Return the level
	!
	CTX = .CTX - CTX$K_BLN;

	! Restore the bucket pointer to the current level bucket since
	! we should be looking at some other one.
	!
	BUCKET = .CTX [ CTX$L_CURRENT_BUFFER ];
	
	! Write the bucket we filled
	!
	CONV$$WRITE_BUCKET();

	! Initialize the bucket to use it again
	!
	CONV$$INIT_BUCKET()

	END;	! Load index block

    BEGIN	! CTX_P1 local

    LOCAL	CTX_P1	: REF BLOCK [ ,BYTE ];

    CTX_P1 = .CTX + CTX$K_BLN;

    ! An index record is made for levels 2 and above ( level 0 and 1 are
    ! made by LOAD_PRIMARY and LOAD_SECONDARY depending on KEY_REF )
    ! NOTE: Do this now because latter the key could get compressed
    !
    CH$MOVE( .CTX [ CTX$W_RDS ],.CTX [ CTX$L_RDP ],.CTX_P1 [ CTX$L_RDP ] );

    ! Set the size of the data record
    !
    CTX_P1 [ CTX$W_RDS ] = .CTX [ CTX$W_RDS ];

    ! Set the size of the control record
    !
    IF .CONV$GB_PROL_V3
    THEN
	CTX_P1 [ CTX$W_RCS ] = .CTX [ CTX$V_VBN ] + 2
    ELSE
	CTX_P1 [ CTX$W_RCS ] = .CTX [ CTX$V_VBN ] + 3

    END;	! CTX_P1 local

    BEGIN	! BKT_*_PTR local

    ! Load the record into the bucket...
    ! First we must set up pointers to where the record will go in the bucket
    ! These are:
    !
    LOCAL
	BKT_CTRL_PTR,	! Control information
	BKT_DATA_PTR;	! Actual data record

    ! The reason we split them up is because prologue 3 files put the two pieces
    ! in two different places depending on bucket type (ie. INDEX, PRIMARY data
    ! and SECONDARY data bucket.
    !
    ! For Prologue 3 files...
    !
    IF .CONV$GB_PROL_V3
    THEN
	BEGIN

	! Prologue 3 files...
	!
	IF .KEY_DESC [ KEY$V_IDX_COMPR ]
	THEN
	    CONV$$COMPRESS_INDEX();

	! If level 1 save the pointers so we can backup latter
	!
	IF .BUCKET [ BKT$B_LEVEL ] EQLU 1
	THEN
	    BEGIN
	    SAVE_VBNFS = .BUCKET [ BKT$W_VBNFS ];
	    SAVE_KEYFRESPC = .BUCKET [ BKT$W_KEYFRESPC ]
	    END;

	! Update this pointer first since we go backwards with it
	!
	BUCKET [ BKT$W_VBNFS ] = .BUCKET [ BKT$W_VBNFS ] - .CTX [ CTX$W_RCS ];

	! For the index levels the control bytes are put at the bucket
	! vbn freespace.  The data bytes are put at the key free space.
	!
	BKT_CTRL_PTR = .BUCKET [ BKT$W_VBNFS ] + .BUCKET + 1;
	BKT_DATA_PTR = .BUCKET [ BKT$W_KEYFRESPC ] + .BUCKET;

	! Update the rest of the bucket pointers
	!
	BUCKET [ BKT$W_KEYFRESPC ] = .BUCKET [ BKT$W_KEYFRESPC ] +
							.CTX [ CTX$W_RDS ]

	END
    ELSE

	! For prologue 1 and 2 files...
	!
	BEGIN

	! If level 1 save the pointers so we can backup latter
	!
	IF .BUCKET [ BKT$B_LEVEL ] EQLU 1
	THEN
	    SAVE_FREESPACE = .BUCKET [ BKT$W_FREESPACE ];

	! Set some pointers...
	!
	! For prologue 1 and 2 files the control bytes are put at the bucket
	! freespace.  The data bytes are put directly after the control.
	!
	BKT_CTRL_PTR = .BUCKET [ BKT$W_FREESPACE ] + .BUCKET;
	BKT_DATA_PTR = .BKT_CTRL_PTR + .CTX [ CTX$W_RCS ];

	! Update the bucket pointer (NOTE: Same update for all cases)
	!
	BUCKET [ BKT$W_FREESPACE ] = .BUCKET [ BKT$W_FREESPACE ] +
						.CTX [ CTX$W_RCS ] +
						.CTX [ CTX$W_RDS ];

	END;

    ! Load the record into the bucket...
    ! Move the control bytes into the bucket
    !
    CH$MOVE( .CTX [ CTX$W_RCS ],.CTX [ CTX$L_RCP ],.BKT_CTRL_PTR );

    ! Move the data bytes into the bucket
    !
    CH$MOVE( .CTX [ CTX$W_RDS ],.CTX [ CTX$L_RDP ],.BKT_DATA_PTR );

    END;	! BKT_*_PTR local

    ! Update the amount of space left in the bucket and the amount used
    !
    BEGIN

    LOCAL
	SPACE_USED;

    SPACE_USED = .CTX [ CTX$W_RCS ] + .CTX [ CTX$W_RDS ];

    CTX [ CTX$W_SPC ] = .CTX [ CTX$W_SPC ] - .SPACE_USED;

    CTX [ CTX$W_USE ] = .CTX [ CTX$W_USE ] + .SPACE_USED;

    END;

    ! Set the index record control bytes and bucket pointer
    !
    CONV$$WRITE_VBN();

    RETURN

    END;

%SBTTL	'FINISH_INDEX'
ROUTINE	FINISH_INDEX : CL$JSB_REG_9 NOVALUE =
!++
!
! Functional Description:
!
!	Loads and writes the last buckets in an index.
!
! Calling Sequence:
!
!	FINISH_INDEX()
!
! Input Parameters:
!	none
!
! Implicit Inputs:
!	none
!
! Output Parameters:
!	none
!
! Implicit Outputs:
!	none
!
! Routine Value:
!
!	CONV$_SUCCESS or error codes
!
! Routines Called:
!
!	CONV$$WRITE_BUCKET
!	BACKUP_INDEX
!	CONV$$CREATE_HIGH_KEY
!	LOAD_INDEX_BUCKET
!
! Side Effects:
!
!	Loads and writes the last buckets in an index.  Deallocates memory used
!	for bucket buffers.
!
!--

    BEGIN

    DEFINE_CTX;
    DEFINE_BUCKET;
    DEFINE_KEY_DESC;


    ! Finish off the data level bucket.  The reason why we do ths seperatly
    ! is that there are no more records to go in this bucket.  In the index
    ! levels there are.
    !
    CTX = .CONV$GL_CTX_BLOCK;
    BUCKET = .CTX [ CTX$L_CURRENT_BUFFER ];
    BUCKET [ BKT$V_LASTBKT ] = _SET;

    ! Write the data level bucket
    !
    CONV$$WRITE_BUCKET();

    ! If the last data bucket was a continuation bucket then backup one
    ! index record an put the high key there
    !
    IF .CONTINUATION
    THEN
	BACKUP_INDEX();

    ! Create the high key index record to finish things off
    !
    CONV$$CREATE_HIGH_KEY();

    ! Write the last index records into the buckets and then write the
    ! buckets out
    !
    ! Move up to level 1
    !
    CTX = .CTX + CTX$K_BLN;

    ! Loop until each level is processed
    !
    WHILE .CTX [ CTX$V_RDY ]
    DO
	BEGIN

	LOCAL	CTX_P1 : REF BLOCK [ ,BYTE ];

	! This call to load bucket will finish off this level bucket and create
	! the index to the next.
	!
	LOAD_INDEX_BUCKET();

	! Before we write out the last bucket set some control info. in it
	!
	BUCKET = .CTX [ CTX$L_CURRENT_BUFFER ];
	BUCKET [ BKT$V_LASTBKT ] = _SET;

	CTX_P1 = .CTX + CTX$K_BLN;

	! If there is no bucket above this one then this is the root
	!
	IF ( NOT .CTX_P1 [ CTX$V_RDY ] )
	THEN
	    BEGIN
	    BUCKET [ BKT$V_ROOTBKT ] = _SET;
	    KEY_DESC [ KEY$B_ROOTLEV ] = .CTX [ CTX$B_LEVEL ];
	    KEY_DESC [ KEY$L_ROOTVBN ] = .CTX [ CTX$L_CURRENT_VBN ];
	    KEY_DESC [ KEY$V_INITIDX ] = _CLEAR
	    END;

	! Write the last bucket at this level
	!
	CONV$$WRITE_BUCKET();

	! Clear the bucket ready flag at this level
	!
	CTX [ CTX$V_RDY ] = _CLEAR;

	! Prepare to work on the bucket one level up
	!
	CTX = .CTX_P1

	END;

    ! Make sure the last IO has completed
    !
    $WAIT( RAB=CONV$AB_OUT_RAB );

    ! Any more IO will be Syncronous
    !
    CONV$AB_OUT_RAB [ RAB$V_ASY ] = _CLEAR;

    RETURN

    END;

%SBTTL	'BACKUP_INDEX'
ROUTINE	BACKUP_INDEX : CL$JSB_REG_9 NOVALUE =
!++
!
! Functional Description:
!
! Calling Sequence:
!
!	BACKUP_INDEX()
!
! Input Parameters:
!	none
!
! Implicit Inputs:
!	none
!
! Output Parameters:
!	none
!
! Implicit Outputs:
!	none
!
! Routine Value:
!	none
!
! Routines Called:
!	none
!
! Side Effects:
!
!	Loads and writes the last buckets in an index.  Deallocates memory used
!	for bucket buffers.
!
!--

    BEGIN

    DEFINE_CTX;
    DEFINE_BUCKET;
    DEFINE_KEY_DESC;

    LOCAL
	VBN_SIZE,
	CTX_P1		: REF BLOCK [ ,BYTE ],
	RECORD_CTRL	: REF BLOCK [ ,BYTE ];

    CTX_P1 = .CTX + CTX$K_BLN;

    BUCKET = .CTX_P1 [ CTX$L_CURRENT_BUFFER ];

    ! If the last data bucket was a continuation bucket then we will be backing
    ! up index record which requires using the vbn in the last record.  We
    ! can fake out conv$$write_vbn (called in conv$$create_high_key) by stuffing
    ! the vbn in the ctx field.  This is ok since it it never referenced again.
    !
    ! Get the size of the vbn in the old record (in bits)
    !
    VBN_SIZE = ( .CTX_P1 [ CTX$V_VBN ] + 2 ) * 8;

    ! Backup the pointers in the bucket above and get the vbn in the record
    !
    IF .CONV$GB_PROL_V3
    THEN
	BEGIN

	! For prologue 3 the vbn is at where we are (they go backwards)
	!
	RECORD_CTRL = .BUCKET [ BKT$W_VBNFS ] + .BUCKET + 1;

	CTX [ CTX$L_CURRENT_VBN ] = .RECORD_CTRL [ 0,0,.VBN_SIZE,0 ];

	BUCKET [ BKT$W_VBNFS ] = .SAVE_VBNFS;
	BUCKET [ BKT$W_KEYFRESPC ] = .SAVE_KEYFRESPC

	END
    ELSE
	BEGIN

	BUCKET [ BKT$W_FREESPACE ] = .SAVE_FREESPACE;

	RECORD_CTRL = .BUCKET [ BKT$W_FREESPACE ] + .BUCKET;

	CTX [ CTX$L_CURRENT_VBN ] = .RECORD_CTRL [ 1,0,.VBN_SIZE,0 ]

	END;

    RETURN

    END;

END	ELUDOM
