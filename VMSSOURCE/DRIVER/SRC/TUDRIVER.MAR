	.TITLE	TUDRIVER - TAPE CLASS DRIVER
	.IDENT	'V04-000'
 
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; Robert Rappaport  16-June-1982
;
;  TAPE CLASS DRIVER
;
; MODIFIED BY:
;
;	V03-161	ROW0398		Ralph O. Weber		21-JUL-1984
;		Setup use of class driver write-lock bit in UCB$W_DEVSTS.
;
;	V03-160	ROW0396		Ralph O. Weber		21-JUL-1984
;		Setup automatic detection of density after an operation which 
;		moves the tape position off of the BOT.
;
;	V03-159	ROW0395		Ralph O. Weber		21-JUL-1984
;		Make changes which setup "normal" MSCP command timeout 
;		algorithm before calls to DUTU$POLL_FOR_UNITS and 
;		BRING_UNIT_ONLINE.  Also setup use of DAP CDRP by both 
;		DUTU$POLL_FOR_UNITS and BRING_UNIT_ONLINE.
;
;	V03-158	ROW0394		Ralph O. Weber		20-JUL-1984
;		Remove DPT_STORE setting of ACL queue present bit in the ORB.
;		This should improve performance on devices which do not really 
;		have an ACL queue in their device protection ORB.
;
;	V03-157	ROW0393		Ralph O. Weber		20-JUL-1984
;		Add media-id to device type translation table entries for the 
;		TA78, TK50, and TA81.
;
;	V03-156	ROW0387		Ralph O. Weber		 8-JUL-1984
;		Setup use of DUTU$RECONN_LOOKUP and DUTU$DRAIN_CDDB_CDRPQ.
;
;	V03-155	ROW0369		Ralph O. Weber		 6-JUL-1984
;		Change DU$RE_SYNCH to not do MRESET/MSTART to MSCP servers and 
;		then wait for something to happen.  Quite possibly, nothing 
;		ever will happen in such cases.  Proceeding directly to the 
;		DISCONNECT is the correct action.  This is being done now so 
;		that it will not be forgotten when as and if we make a tape 
;		MSCP server.
;
;	V03-154	ROW0382		Ralph O. Weber		22-JUN-1984
;		Change START_PACKACK so the an exclusive access online command 
;		is sent only the multihost controllers.  For other controllers,
;		just sent an online.
;
;	V03-153	ROW0361		Ralph O. Weber		 5-MAY-1984
;		Setup use of new class driver common DAP processing in 
;		DUTU$DODAP.  The new routine is designed to eliminate multiple 
;		concurrent DAP threads which are known to crash systems.
;
;	V03-152	ROW0354		Ralph O. Weber		30-APR-1984
;		Add setting for DEV$M_NNM in DEVCHAR2 to indicate that tape 
;		class driver devices use NODENAME$DDCN device names.
;
;	V03-151	ROW0353		Ralph O. Weber		30-APR-1984
;		Correct message type constant input to ERL$LOGMESSAGE from 
;		EMB$C_DM (for disks) to EMB$C_TM (for tapes).
;
;	V03-150	ROW0350		Ralph O. Weber		23-APR-1984
;		Correct more problems causing multiple trips through 
;		END_SINGLE_STREAM, with the attendent bugchecks.  First, clear 
;		CDDB$V_SNGLSTRM upon entry to DU$CONNECT_ERR.  Second, protect 
;		the SCS$UNSTALLUCB loop in END_SINGLE_STREAM from possible 
;		connection failures during execution of the loop.
;
;	V03-149	LMP0237		L. Mark Pilant,		19-Apr-1984  11:25
;		Initialize the template ORB.
;
;	V03-148	ROW0347		Ralph O. Weber		11-APR-1984
;		Cause MT$V_HWL to be cleared when tape is not write locked and 
;		whenever an AVAILABLE command is sent to the server.
;
;	V03-147	ROW0339		Ralph O. Weber		 9-APR-1984
;		Setup use of common invalid command processing routines 
;		(macros).  This replaces the old "form the original MSCP 
;		command packet by hand" algorithm with a "repeat the code 
;		which formed the original MSCP command" algorithm.  The cost 
;		is a single, hardly ever taken BLBS in the mainline read/write 
;		code path.  The savings are elimination of having to duplicate 
;		command packet setup changes in the invalid command case, 
;		hundreds of bytes of code, and a not inconsequential amount of 
;		static storage.
;
;	V03-146	ROW0338		Ralph O. Weber		 7-APR-1984
;		Setup use of DO_ACTION macro to replace INTERPRET_ACTION_TABLE.
;		Start using IF_MSCP where only success or failure of an MSCP 
;		command is being tested.  Setup use of ACTION_ENTRY END to end 
;		action tables.  Remove action table interpretation routines; 
;		they are now in DUTUSUBS.
;
;	V03-145	ROW0335		Ralph O. Weber		 4-APR-1984
;		> Correct positioning of DPT_STORE REINIT and add note that 
;		  reinit is not significant because driver is not reloadable.
;		> Add use of DUTU$UNITINIT.  Basicly, this permits future use 
;		  of TMSCP devices for booting.
;		> Remove usage of allocation class value in the SCS connect 
;		  accept message.  All MSCP servers now supply that 
;		  information in the Set Controller Characteristics command 
;		  end packet.
;		> Eliminate bug check for IO$_READLBLK and IO$_WRITELBLK.  
;		  Make these functions produce SS$_ILLIOFUNC status instead.  
;		  Also change function dispatcher to use DISPATCH macro.
;		> Add processing for IO$M_INHRETRY.
;		> Add the multi-host progress counter handling proposed by the 
;		  HSC implementors to TU$TMR.  This algorithm simplifies 
;		  handling of the case where the MSCP server is busy on an 
;		  older command from another host.
;
;	V03-144	ROW0331		Ralph O. Weber		31-MAR-1984
;		Setup use of common cancel support in DUTUSUBS.  Also make 
;		functions which use multiple MSCP commands check for cancel 
;		after each MSCP command and perform cancel if necessary.
;
;	V03-143	ROW0328		Ralph O. Weber		21-MAR-1984
;		Correct bugs in ROW0319 which caused it to incorrectly miss 
;		the end of the CDDB UCB chain.
;
;	V03-142	ROW0324		Ralph O. Weber		12-MAR-1984
;		> Correct set mode and set characteristics so that 
;		  MSCP$W_FORMAT is zero except when the UCB$L_RECORD is zero.  
;		  This brings the driver into conformance with TMSCP 
;		  version 1.6.
;		> Provide for proper setup of the following UCB$L_DEVDEPEND 
;		  bits in all cases that I can think of:  MT$V_BOT, MT$V_EOF, 
;		  MT$V_EOT, MT$V_HWL, MT$V_LOST, MT$V_SUP_NRZI, MT$V_SUP_PE, 
;		  and MT$V_SUP_GCR.
;		> Fix "detect LEOT" modifier setup so that the modifier is 
;		  NEVER set for physical I/O requests.
;		> Change IOSB status returned when a backwards skip file 
;		  encounters the BOT to SS$_NORMAL.
;
;	V03-141	ROW0320		Ralph O. Weber		29-FEB-1984
;		Provide for automatic PACKACK on foreign tapes (DEV$V_FOR set) 
;		whenever a request is received and the UCB$V_VALID bit is 
;		clear.  Build the sequential NOP function into macros so that 
;		its use can be easily duplicated where necessary.
;
;	V03-140	ROW0319		Ralph O. Weber		28-FEB-1984
;		Attempt to eliminate failover to non-operational path by 
;		making clearing of CDDB$V_RECONNECT the last thing done in 
;		END_SINGLE_STREAM.  Also add sanity check that CDDB$V_RECONNECT 
;		is set before it is cleared.
;
;	V03-139	ROW0310		Ralph O. Weber		23-FEB-1984
;		Make IO$_REWINDOFF equivalent to IO$_UNLOAD.
;
;	V03-138	ROW0307		Ralph O. Weber		15-FEB-1984
;		Fix trace support to work in the common modules environment.
;		Make RECORD_GETUNIT_CHAR preserve R0.
;
;	V03-137	ROW0305		Ralph O. Weber		13-FEB-1984
;		Fix R0 (final IOSB status) corruption problems in successful 
;		IO$_PACKACK processing.
;
;	V03-136	ROW0301		Ralph O. Weber		10-FEB-1984
;		Move clearing of CDDB$V_NOCONN from MAKE_CONNECTION to after 
;		the new connection information has been propogated to all UCBs 
;		in the re-connect code.  While this is not absolutely 
;		necessary here and now, it will provide a useful reminder that 
;		CDDB$V_NOCONN set blocks mount verification attempts and thus 
;		the bit cannot be cleared until connection dependent fields in 
;		all UCBs have been altered to reflect the new connection.
;
;	V03-135	ROWO299K(ludge)	Ralph O. Weber		 9-FEB-1984
;		This kludge detects a HSC tape server in RECORD_STCON and 
;		forces it to act like a multihost server for allocation class 
;		determination, inspite of the fact that the HSC tape server 
;		does not set the multihost controller flag.  This kludge can 
;		be removed when the HSC tape server sets the multihost 
;		controller flag (as it should).
;
;	V03-134	ROW0298		Ralph O. Weber		 9-FEB-1984
;		Setup use of CDRP$W_ENDMSGSIZ to hold the size of an incomming 
;		sequenced message.  This replaces use of CDRP$L_IOST2+2 whose 
;		use causes valuable input information to be overwritten.
;
;	V03-133	ROW0297		Ralph O. Weber		 7-FEB-1984
;		Correct confusion between wait count bumped due to a broken 
;		connection and wait count bumped due to a sequential NOP by 
;		introducing a UCB$V_TU_SETNOP bit in device dependent status.
;
;	V03-132	ROW0294		Ralph O. Weber		 5-FEB-1984
;		Correct RECORD_STCON setup of allocation class information in 
;		the DDBs to use DDB$L_CONLINK so that only those DDBs on this 
;		connection are effected.
;
;	V03-131	ROW0293		Ralph O. Weber		 5-FEB-1984
;		Generally bring tape class driver to same revision level as 
;		disk class driver.  The only exception is that there is no 
;		mount verification and thus thing which depend upon it for 
;		updated operation techniques have been left unchanged.
;		Replace CDRP$V_ERLOGIP in CDRP$W_STS with CDRP$V_ERLIP in 
;		CDRP$L_DUTUFLAGS.  Setup use of CDDB$V_NOCONN status bit. 
;		Setup use of several routines which have been moved to 
;		DUTUSUBS.
;
;	V03-130	ROW0272		Ralph O. Weber		 1-JAN-1984
;		Change START_DAP_THREAD to only send Determin Access Paths 
;		commands for those UCBs which are UCB$V_VALID.  MSCP servers 
;		will ignore DAP commands for units which are not MSCP online, 
;		so why should we send them.  Add block which prevents logging 
;		errors for DAP attention messages to ACCESS_PATH_ATTN.  This 
;		allows the code which logs DAP attention messages to remain 
;		and to be patched back into existance should it be needed.
;
;	V03-129	ROW0270		Ralph O. Weber		 1-JAN-1984
;		Eliminate DRIVER_SEND_MSG_BUF by replacing all calls to it 
;		with SEND_MSCP_MSG DRIVER.  Change MAKE_CONNECTION to use the 
;		larger of HSTIMEOUT_ARRAY[controller_model] and the controller 
;		timeout value as the final host timeout value for the MSCP Set 
;		Controller Characteristics command.  Setup use of VMS SCS 
;		RECYCL_RSPID and FIND_RSPID_RDTE.  Fix START_SENSECHAR and 
;		START_SENSEMODE to clear the MSCP$M_MD_CLSEX (clear serious 
;		exception modifier) bit, as this modifier is illegal on Get 
;		Unit Status commands.  Make all permanent/DAP CDRP to CDDB 
;		conversions use PERMCDRP_TO_CDDB.
;
;	V03-128	ROW0269		Ralph O. Weber		 1-JAN-1984
;		Change DU_CONTROLLER_INIT to use DUTU$CREATE_CDDB.
;
;	V03-127	ROW0262		Ralph O. Weber		27-DEC-1983
;		Move all UCB lookup and creation to DUTUSUBS.  Cleanup 
;		ATTN_MSG processing in TU$IDR.  Implement usage of $DUTUDEF, 
;		all device independent UCB fields, and the IOC$GL_TU_CDDB 
;		listhead.  Replace all DPT_STORE macros which init UCB fields 
;		with INIT_UCB macros.  INIT_UCB initializes both the DPT and 
;		the template UCB.  Its use eliminates possible mismatch of the 
;		two UCB sources as well as some setup code in the controller 
;		initialization routine.  Make driver not reloadable.  Change 
;		POLL_FOR_UNITS to DUTU$POLL_FOR_UNITS.
;
;	V03-126	ROW0261		Ralph O. Weber		22-NOV-1983
;		Move DUMP_COMMAND and DUMP_ENDMESSAGE to DUTUSUBS.  Change 
;		TU$END to DUTU$END so that linking with multiple modules does 
;		not involve a hack.  Do some common path cleanup to speed 
;		passage through the common code paths.  Change subroutine
;		CALL_SEND_MSG_BUF to SEND_MSCP_MSG macro.  Move INIT_TPLATE_UCB
;		to DUTULIB (macro library).
;
;	V03-125	RLRQBUS		Robert L. Rappaport	16-NOV-1983
;		Change building of transfer commands MSCP packet so that 
;		PQDRIVER can alter the mapping information during a map 
;		request and have the altered information appear in the MSCP 
;		packet.
;
;	V03-124	ROW0258		Ralph O. Weber		17-NOV-1983
;			The Paul Painter Memorial Enhancement
;		Named for one of the unfortunate customers who suffered much 
;		to determine the great UCB$L_MT_RECORD secret while trying to 
;		create a user-written magtape driver, this change eliminates 
;		use of the device dependent field, UCB$L_TU_RECORD in favor of 
;		the device independent field, UCB$L_RECORD.
;
;	V03-123	ROW0253		Ralph O. Weber		12-NOV-1983
;		Change device dependent UCB definitions to work with globally 
;		defined MSCP extension to the UCB.  This change does not make 
;		use of all the UCB fields in the new extension.  It simply 
;		eliminates interactions which will prevent this module from 
;		building in the presence of the new UCB definitions.  The 
;		UCB$L_TU_MEDIATYP field, which was changed to UCB$L_MEDIA_ID 
;		ages ago, has also been eliminated.  NB: a gross hack has been 
;		employed to keep this driver compatible with the other magtape 
;		drivers and the magtape ACP.  This will be corrected when all 
;		the involved parties start using the newly defined 
;		UCB$L_RECORD.
;
;	V03-122	ROW0245		Ralph O. Weber		19-OCT-1983
;		Correct couple of outstanding bugs:
;		 - Change TU$IDR to store incomming message size in 
;		   CDRP$L_IOST2+2.  This provides the message size to any code 
;		   requiring it.  In particular, the INVALID_STS fixes 
;		   mentioned below use this feature.
;		 - Fix INVALID_STS to properly place the size of the incomming 
;		   MSCP message in R1 before calling ERL$LOG_DMSCP.
;
;	V03-121	ROW0243		Ralph O. Weber		17-OCT-1983
;		Enhance SEQ_ENDCHECK to allow canceled (MSCP aborted) end 
;		packets to be received out of sequence.  This produces 
;		conformance to a revised version of the TMSCP specification.
;
;	V03-120	ROW0242		Ralph O. Weber		17-OCT-1983
;		Change unit attention processing in DU$IDR to skip altering 
;		UCB$M_DU_WAITBMP and UCB$W_RWAITCNT when the CDDB$M_INITING or 
;		CDDB$M_RECONNECT is set in CDDB$W_STATUS.  This prevents 
;		altering the wait count is such a way that the wait count 
;		tests in controller init and reconnection processing fail.  
;		Therefore, a spurous disk class driver bugcheck is eliminated.
;
;	V03-119	BLS0234		Benn Schreiber		 9-Aug-1983
;		Add missing G^s to calls in exec.
;
;	V03-118	RLRDLATE	Robert L. Rappaport	25-Jul-1983
;		Check for Data Late subcode in Controller Errors on
;		data transfer commands, and return SS$_DATALATE.
;
;	V03-117	RLRDLEOT	Robert L. Rappaport	19-Jul-1983
;		Implement suport for new MSCP$M_MD_DLEOT modifier.
;		Modifier means "Detect Logical End Of Tape" and is
;		used on QIO Skip files and Skip records (forward
;		direction only).
;
;	V03-116	RLRIMMED	Robert L. Rappaport	19-Jul-1983
;		Implement support for new MSCP$M_MD_IMMED modifier
;		that allows us to express that certain commands,
;		namely REWIND and DSE, are to return their End Messages
;		when the command BEGINS to execute rather than when it
;		completes.  A discussion of this is found in the TMSCP
;		spec under "Synchronous versus Asynchronous" operation
;		of lengthy commands.
;
;		The effort here consists of simplifying greatly the
;		previous method of implementing support for IO$M_NOWAIT.
;		This simplification eliminates the need for a REWIND
;		CDRP, as well as the need for special handling of
;		Rewind and Available (UNLOAD) requests.
;
;		This update almost completely obviates those changes
;		implemented as a result of update RLRRWATN.
;
;		Also in this update fix bug in START_SETCHAR wherein we
;		neglected to call SCS$UNSTALLUCB after decrementing
;		UCB$W_RWAITCNT.
;
;	V03-115	RLRUPTODATE	Robert L. Rappaport	26-Jul-1983
;		Adapt and incorporate relevant changes from Disk
;		Class Driver.  From ;RLRDDB audit of DUDRIVER
;		thru ;RLRODDBCNT.
;
;	V03-114	RLRGROWTH	Robert L. Rappaport	23-Jun-1983
;		Due to growth in the CDDB, the length of the CDDB plus
;		the length of the CDRP is NOT < 256.  We must change
;		a MOVZBL to a MOVZWL.
;
;	V03-113	RLRDPATH2	Robert L. Rappaport	31-May-1983
;		As a result of the previous change (RLRDPATH1),
;		UCB$L_TU_RECORD has moved with respect to UCB$L_DPC
;		breaking an assume statement that must now be fixed.
;
;	V03-112	RLRDPATH1	Robert L. Rappaport	25-May-1983
;		Allow UCB to include new DUAL PORT extension by
;		changing base of where we begin the private TUDRIVER
;		extension from UCB$L_DPC+4 to UCB$L_DP_LINK+4.
;
;	V03-111	RLRRWCPTRa	Robert L. Rappaport	11-Apr-1983
;		Correct bug in RLRRWCPTR fix.
;
;	V03-110	RLRCANCELf	Robert L. Rappaport	11-Apr-1983
;		Initialize CDRP fields before deciding whether to start
;		this I/O request or whether to Q to UCB I/O Queue.  This
;		prevents misinterpreting uninitialized fields.
;
;	V03-109	RLRRWCPTR	Robert L. Rappaport	4-Mar-1983
;		Test for zero UCB$L_RWCPTR in RDTWAIT_DIS_ACT and
;		in RDT_DIS_ACTION.  Such a situation could occur if
;		no RSPID's were available during a re-Connection and
;		if the re-Connection failed and we had to do a
;		re-re-Connection.  Also use Controller timeout for
;		host timeout value for those controllers for which
;		we care to set a host timeout.  Also only use INIT_IMMED_DELTA
;		for timing out the first SET_CONTROLLER_CHAR command. After-
;		words always use CDDB$W_CNTRLTMO.  Also increase
;		INIT_IMMED_DELTA to 30.
;
;	V03-108	RLRTMUCB	Robert L. Rappaport	25-Feb-1983
;		Revamp Template UCB so as to be automatically compliant
;		with new UCB additions.  Also remove initial Breakpoint.
;
;	V03-107	RLRWTMPOS	Robert L. Rappaport	22-Feb-1983
;		Update UCB$L_TU_POSITION after error on WRITE TAPE MARK
;		command.
;
;	V03-106	RLRSEQNOP	Robert L. Rappaport	15-Feb-1983
;		Use REPOSITION command with zeroes as a sequential NOP
;		in SET CHAR and SET MODE processing.
;
;	V03-105	RLRWRTM		Robert L. Rappaport	14-Feb-1983
;		Accept MSCP$K_ST_DATA as possible status of Write Tape Mark.
;
;	V03-104	RLRRWATN	Robert L. Rappaport	11-Feb-1983
;		Implement REWIND ATTENTION and NOWAIT.  Also add
;		support for REWIND Attention messages received as a
;		AVAILABLE and UNLOAD commands.  Also support ignoring
;		of spurious REWIND Attention messages.
;
;	V03-103	RLRTRACE	Robert L. Rappaport	4-Feb-1983
;		Make IRP trace a per unit rather than a per system
;		structure by moving it to the UCB.
;
; MACRO LIBRARY CALLS
;

	$CDDBDEF			;Define CDDB offsets
	$CDRPDEF			;Define CDRP offsets
	$CDTDEF				;Define CDT offsets
	$CRBDEF				;Define CRB offsets
	$DCDEF				;Define Device Classes and Types
	$DDBDEF				;Define DDB offsets
	$DEVDEF				;Define DEVICE CHARACTERISTICS bits
	$DPTDEF				;Define DPT offsets
	$DYNDEF				;Define DYN symbols
	$EMBLTDEF			;Define EMB Log Message Types
	$FKBDEF				;Define FKB offsets
	$IDBDEF				;Define IDB offsets
	$IODEF				;Define I/O FUNCTION codes
	$IPLDEF				;Define symbolic IPL's
	$IRPDEF				;Define IRP offsets
	$MSCPDEF			;Define MSCP packet offsets
	$MSLGDEF			;Define MSCP Error Log offsets
	$MTDEF				;Define MAGTAPE STATUS bits
	$ORBDEF				;Define ORB offsets
	$PBDEF				;Define Path Block offsets
	$PCBDEF				;Define PCB offsets
	$PDTDEF				;Define PDT offsets
	$PRDEF				;Define Processor Registers
	$SBDEF				;Define System Block Offsets
	$SCSCMGDEF			;Define SCS Connect Message offsets
	$RCTDEF				;Define RCT offsets
	$RDDEF				;Define RDTE offsets
	$RDTDEF				;Define RDT offsets
	$SSDEF				;Define System Status values
	$UCBDEF				;Define UCB offsets
	$VADEF				;Define Virtual Address offsets
	$VECDEF				;Define INTERRUPT DISPATCH VECTOR offsets
	$WCBDEF				;Define WCB offsets


	$DUTUDEF			;Define common class driver CDDB
					; extensions and other common symbols


; Constants

ALLOC_DELTA=1			; Number of seconds to wait to retry pool
				;  allocation that failed.
INIT_IMMED_DELTA=30		; During Controller Initialization, the
				;  timeout DELTA for immediate MSCP commands.
CONNECT_DELTA=10		; During Controller Initialization, the
				;  time interval for retrying failed
				;  CONNECT attempts.
HOST_TIMEOUT=30			; Host timeout value.

DISCONNECT_REASON=1
INITIAL_CREDIT=10
INITIAL_DG_COUNT=2
MAX_RETRY=2
MIN_SEND_CREDIT=2
	.PAGE
	.SBTTL	MACRO DEFINITIONS

;
; Expanded opcode macros - Branch word conditional psuedo opcodes.
;

;
; BWNEQ - Branch (word offset) not equal
;

	.MACRO	BWNEQ	DEST,?L1
	BEQL	L1		; Branch around if NOT NEQ.
	BRW	DEST		; Branch to destination if NEQ.
L1:				; Around.
	.ENDM	BWNEQ


;
; BWEQL - Branch (word offset) equal
;

	.MACRO	BWEQL	DEST,?L1
	.SHOW
	BNEQ	L1		; Branch around if NOT EQL.
	BRW	DEST		; Branch to destination if EQL.
L1:				; Around.
	.NOSHOW
	.ENDM	BWEQL

;
; BWBS - Branch (word offset) bit set.
;

	.MACRO	BWBS	BIT,FIELD,DEST,?L1
	.SHOW
	BBC	BIT,FIELD,L1		; Branch around if bit NOT set.
	BRW	DEST			; Branch to destination if bit set.
L1:					; Around.
	.NOSHOW
	.ENDM	BWBS

;
; BWBC - Branch (word offset) bit clear.
;

	.MACRO	BWBC	BIT,FIELD,DEST,?L1
	.SHOW
	BBS	BIT,FIELD,L1		; Branch around if bit NOT clear.
	BRW	DEST			; Branch to destination if bit clear.
L1:					; Around.
	.NOSHOW
	.ENDM	BWBC

	.IF	DF	TU_SEQCHK
;
; SEQFUNC - Macro included in conditional code to check sequentiality
;		of function terminations.
;

	.MACRO	SEQFUNC CODES
MASKL	= 0
MASKH	= 0
	.IRP	X,<CODES>
	.IF	GT	<IO$_'X&IO$_VIRTUAL>-31
MASKH	= MASKH!<1@<<IO$_'X&IO$_VIRTUAL>-32>>
	.IFF
MASKL	= MASKL!<1@<IO$_'X&IO$_VIRTUAL>>
	.ENDC
	.ENDM
	.LONG	MASKL,MASKH
	.ENDM	SEQFUNC
	.ENDC

;
; START_SEQNOP - macro to start a sequential NOP sequence
;
;	This macro starts a sequential NOP sequence.  A sequential NOP 
;	sequence encapsulates a series of TMSCP operations which must occur 
;	sequentially with respect to the stream of TMSCP operations flowing 
;	through the driver.
;
;	First UCB$W_RWAITCNT is increased by one to prevent future I/O 
;	requests from starting.  Then a TMSCP sequential command which does 
;	not alter the tape position is sent to the server.  When the 
;	sequential command completes, the driver and the server are 
;	synchronized.
;
;	Upon exit from this macro, the currently executing thread is the only 
;	thread conversing with the server.  When the operations which must be 
;	done in this sychronized state are completed, the sequential NOP state 
;	should be terminated using the END_SEQNOP macro.
;
; Inputs:
;
;	R3	UCB address
;	R4	PDT address
;	R5	CDRP address (RSPID & message buffer already allocated and 
;				initialized)
;	(SP)	address of caller's caller
;
; Outputs:
;
;	R3 through R5 unchanged
;	All other registers altered

	.MACRO	START_SEQNOP ?L1
	BBSS	#UCB$V_TU_SEQNOP, -	; Set sequential NOP in progress and 
		UCB$W_DEVSTS(R3), L1	; branch if its already set.
	INCW	UCB$W_RWAITCNT(R3)	; Else, increment wait count to 
					; disallow I/O.
L1:	MOVB	#MSCP$K_OP_REPOS,-	; Transfer REPOSITION opcode
		MSCP$B_OPCODE(R2)	;  to packet.
	ASSUME	MSCP$V_MD_CLSEX GE 8
	BICB	#<MSCP$M_MD_CLSEX@-8>,-	; Specifically never clear SEX on the
		MSCP$W_MODIFIER+1(R2)	;  Seq. NOP command of a SETMODE.
	SEND_MSCP_MSG			; Send message to remote MSCP server.
	RESET_MSCP_MSG			; Setup message buf. etc. for reuse.
					;  refresh RSPID, MSG_BUF, etc.
	.ENDM	START_SEQNOP

;
; END_SEQNOP - terminate sequential NOP sequence
;
;	This macro terminates the class driver - server synchronization 
;	established by START_SEQNOP and returns the communications to a full 
;	stream ahead mode.
;
; Inputs:
;
;	R3	UCB address
;
; Outputs:
;
;	R0 and R3 through R5 unchanged
;	All other registers altered

	.MACRO	END_SEQNOP ?END
	BICW	#UCB$M_TU_SEQNOP, -	; Indicate sequential NOP is no longer
		UCB$W_DEVSTS(R3)	; in progress.
	DECW	UCB$W_RWAITCNT(R3)	; Decrement wait count to allow I/O.
	BNEQ	END			; Branch if wait count not zero.
	PUSHR	#^M<R0,R3,R4,R5>	; Save valuable registers.
	MOVL	R3, R5			; R5 => UCB for SCS$UNSTALLUCB.
	JSB	G^SCS$UNSTALLUCB	; Start up any waiting IRPs on this UCB.
	POPR	#^M<R0,R3,R4,R5>	; Restore valuable registers.
END:
	.ENDM	END_SEQNOP
	.PAGE
	.SBTTL	ASSUMES

; The following set of ASSUME statements will all be true as long as
;	the IRP and CDRP definitions remain consistent.

	ASSUME	CDRP$L_IOQFL-CDRP$L_IOQFL	EQ	IRP$L_IOQFL
	ASSUME	CDRP$L_IOQBL-CDRP$L_IOQFL	EQ	IRP$L_IOQBL
	ASSUME	CDRP$W_IRP_SIZE-CDRP$L_IOQFL	EQ	IRP$W_SIZE
	ASSUME	CDRP$B_IRP_TYPE-CDRP$L_IOQFL	EQ	IRP$B_TYPE
	ASSUME	CDRP$B_RMOD-CDRP$L_IOQFL	EQ	IRP$B_RMOD
	ASSUME	CDRP$L_PID-CDRP$L_IOQFL		EQ	IRP$L_PID
	ASSUME	CDRP$L_AST-CDRP$L_IOQFL		EQ	IRP$L_AST
	ASSUME	CDRP$L_ASTPRM-CDRP$L_IOQFL	EQ	IRP$L_ASTPRM
	ASSUME	CDRP$L_WIND-CDRP$L_IOQFL	EQ	IRP$L_WIND
	ASSUME	CDRP$L_UCB-CDRP$L_IOQFL		EQ	IRP$L_UCB
	ASSUME	CDRP$W_FUNC-CDRP$L_IOQFL	EQ	IRP$W_FUNC
	ASSUME	CDRP$B_EFN-CDRP$L_IOQFL		EQ	IRP$B_EFN
	ASSUME	CDRP$B_PRI-CDRP$L_IOQFL		EQ	IRP$B_PRI
	ASSUME	CDRP$L_IOSB-CDRP$L_IOQFL	EQ	IRP$L_IOSB
	ASSUME	CDRP$W_CHAN-CDRP$L_IOQFL	EQ	IRP$W_CHAN
	ASSUME	CDRP$W_STS-CDRP$L_IOQFL		EQ	IRP$W_STS
	ASSUME	CDRP$L_SVAPTE-CDRP$L_IOQFL	EQ	IRP$L_SVAPTE
	ASSUME	CDRP$W_BOFF-CDRP$L_IOQFL	EQ	IRP$W_BOFF
	ASSUME	CDRP$L_BCNT-CDRP$L_IOQFL	EQ	IRP$L_BCNT
	ASSUME	CDRP$W_BCNT-CDRP$L_IOQFL	EQ	IRP$W_BCNT
	ASSUME	CDRP$L_IOST1-CDRP$L_IOQFL	EQ	IRP$L_IOST1
	ASSUME	CDRP$L_MEDIA-CDRP$L_IOQFL	EQ	IRP$L_MEDIA
	ASSUME	CDRP$L_IOST2-CDRP$L_IOQFL	EQ	IRP$L_IOST2
	ASSUME	CDRP$L_TT_TERM-CDRP$L_IOQFL	EQ	IRP$L_TT_TERM
	ASSUME	CDRP$B_CARCON-CDRP$L_IOQFL	EQ	IRP$B_CARCON
	ASSUME	CDRP$Q_NT_PRVMSK-CDRP$L_IOQFL	EQ	IRP$Q_NT_PRVMSK
	ASSUME	CDRP$L_ABCNT-CDRP$L_IOQFL	EQ	IRP$L_ABCNT
	ASSUME	CDRP$W_ABCNT-CDRP$L_IOQFL	EQ	IRP$W_ABCNT
	ASSUME	CDRP$L_OBCNT-CDRP$L_IOQFL	EQ	IRP$L_OBCNT
	ASSUME	CDRP$W_OBCNT-CDRP$L_IOQFL	EQ	IRP$W_OBCNT
	ASSUME	CDRP$L_SEGVBN-CDRP$L_IOQFL	EQ	IRP$L_SEGVBN
	ASSUME	CDRP$L_JNL_SEQNO-CDRP$L_IOQFL	EQ	IRP$L_JNL_SEQNO
	ASSUME	CDRP$L_DIAGBUF-CDRP$L_IOQFL	EQ	IRP$L_DIAGBUF
	ASSUME	CDRP$L_SEQNUM-CDRP$L_IOQFL	EQ	IRP$L_SEQNUM
	ASSUME	CDRP$L_EXTEND-CDRP$L_IOQFL	EQ	IRP$L_EXTEND
	ASSUME	CDRP$L_ARB-CDRP$L_IOQFL		EQ	IRP$L_ARB
	.PAGE
	.SBTTL	TAPE CLASS DRIVER DEVICE DEPENDENT UNIT CONTROL BLOCK OFFSETS

	$DEFINI	UCB


.=UCB$K_MSCP_TAPE_LENGTH

$DEF	UCB$L_TU_MAXWRCNT		; Largest size record likely to have
			.BLKL	1	;  reliability statistics.
$DEF	UCB$W_TU_FORMAT	.BLKW	1	; Format (density).
$DEF	UCB$W_TU_SPEED	.BLKW	1	; Current speed.
$DEF	UCB$W_TU_NOISE	.BLKW	1	; Size of noise records ignored by
					;  controller.
	.IF	DF	TU_SEQCHK
$DEF	UCB$B_TU_OLDINX	.BLKB	1	; Index of oldest Sequence number.
$DEF	UCB$B_TU_NEWINX	.BLKB	1	; Index of nexat available Seq. # slot.
$DEF	UCB$L_TU_SEQARY	.BLKL	64	; Array of 64 longwords wherein we
					;  we save IRP sequence numbers.
	.IFF
			.BLKW	1	; Reserved.
	.ENDC

	.IF	DF	TU_TRACE
$DEF	UCB$L_TRACEBEG	.BLKL	1	; Pointer to beginning of trace ring.
$DEF	UCB$L_TRACEPTR	.BLKL	1	; Pointer to next available slot.
$DEF	UCB$L_TRACEND	.BLKL	1	; Pointer to beyond trace ring.

	.ENDC

UCB$K_TU_LENGTH=.

	$DEFEND	UCB


	.SBTTL	Allocate Space for Template UCB

; Allocate zeroed space for template UCB.

	INIT_UCB size=UCB$K_TU_LENGTH
	INIT_ORB size=ORB$C_LENGTH
	.PAGE
	.SBTTL	DRIVER PROLOGUE AND DISPATCH TABLES (and UCB Initialization)
;
; LOCAL DATA
;
; DRIVER PROLOGUE TABLE
;
 
	DPTAB	-			;DEFINE DRIVER PROLOGUE TABLE
		END=DUTU$END,-		; End of driver
		ADAPTER=NULL,-		; No Adapter
		FLAGS=<DPT$M_SCS -	; Driver requires that SCS be loaded
		      !DPT$M_NOUNLOAD>,-; Driver cannot be reloaded
		UCBSIZE=UCB$K_TU_LENGTH,-;Sysgen insists on making a UCB
		MAXUNITS=1,-		 ;Sysgen insists on making a UCB
		NAME=TUDRIVER			; Driver name
	DPT_STORE INIT				; Control block init values
	DPT_STORE DDB,DDB$L_ACPD,L,<^A\MTA\>	; Default ACP name


	; The following UCB initialization requests alter the template UCB
	; as well as producing equivalent DPT_STORE entries.  Thus both 
	; structures reflect the required initial UCB state and the UCBs 
	; initially processed by this driver are identical whether they are
	; produced by SYSGEN or by IOC$COPY_UCB.

	INIT_UCB	W_SIZE,WORD,UCB$K_TU_LENGTH
	INIT_UCB	B_TYPE,BYTE,DYN$C_UCB
	INIT_UCB	B_FIPL,BYTE,IPL$_SCS
	INIT_UCB	L_DEVCHAR,LONG,<<DEV$M_FOD!-
					 DEV$M_DIR!-
					 DEV$M_AVL!-
					 DEV$M_ELG!-
					 DEV$M_IDV!-
					 DEV$M_ODV!-
					 DEV$M_SDI!-
					 DEV$M_SQD>>
	INIT_UCB	L_DEVCHAR2,LONG,<<DEV$M_CLU!-
					  DEV$M_MSCP!-
					  DEV$M_NNM>>
	INIT_UCB	B_DEVCLASS,BYTE,DC$_TAPE
	INIT_UCB	W_DEVBUFSIZ,WORD,2048
	INIT_UCB	L_DEVDEPEND,LONG,<<<MT$K_NORMAL11 @ MT$V_FORMAT>!-
					   <MT$K_PE_1600 @ MT$V_DENSITY>>>
	INIT_UCB	W_RWAITCNT,WORD,1
	INIT_UCB	B_DIPL,BYTE,IPL$_SCS
	INIT_UCB	W_DEVSTS,WORD, <<UCB$M_MSCP_INITING -
					!UCB$M_MSCP_WAITBMP>>

	; The following ORB initialization requests alter the template ORB
	; as well as producing equivalent DPT_STORE entries.  Thus both 
	; structures reflect the required initial ORB state and the ORBs 
	; initially processed by this driver are identical whether they are
	; produced by SYSGEN or by IOC$COPY_UCB.

	INIT_ORB	W_SIZE,WORD,ORB$C_LENGTH
	INIT_ORB	B_TYPE,BYTE,DYN$C_ORB
	INIT_ORB	B_FLAGS,BYTE,<< -
			    ORB$M_PROT_16>>	; SOGW protection word
	INIT_ORB	W_PROT,WORD,0		; default protection
	INIT_ORB	L_OWNER,LONG,0		; no owner as yet
	DPT_STORE REINIT		; Control block re-initialization values

	; N.B. Causing the following values to be setup during re-initializa-
	; tion is not significant because this driver cannot be reloaded.  
	; However, were the driver to be reloadable the following values would 
	; need to be re-initialized upon each driver reload.

	DPT_STORE CRB, -			; Controller init routine.
		CRB$L_INTD+VEC$L_INITIAL,D,TU_CONTROLLER_INIT
	DPT_STORE DDB,DDB$L_DDT,D,TU$DDT	; DDT address.

	DPT_STORE END
 
;
; DRIVER DISPATCH TABLE
;
 
	DDTAB	DEVNAM=TU,-		;DRIVER DISPATCH TABLE
		START=TU_STARTIO,-	;START I/O OPERATION
		UNSOLIC=TU_UNSOLNT,-	;UNSOLICITED INTERRUPT
		FUNCTB=TU_FUNCTABLE,-	;FUNCTION DECISION TABLE
		CANCEL=DUTU$CANCEL, -	;CANCEL I/O ENTRY POINT
		REGDMP=0,-		;REGISTER DUMP ROUTINE
		DIAGBF=MSCP$K_MXCMDLEN+MSCP$K_LEN+20+12,-; DIAG BUFF SIZE
		ERLGBF=0,-		; ERLG BUFF SIZE
		UNITINIT=DUTU$UNITINIT,-; Unit initialization routine.
		ALTSTART=0		; Alternate Start I/O entry.
	.PAGE
	.SBTTL	DISK CLASS DRIVER FUNCTION DECISION TABLE
;+
; TAPE CLASS DRIVER FUNCTION DECISION TABLE
;-
 
TU_FUNCTABLE:				;Function Decision Table
	FUNCTAB	,-			; LEGAL FUNCTIONS
		<NOP,-			;  No operation
		 UNLOAD,-		;  Unload (make available + spindown)
		 AVAILABLE,-		;  Available (no spindown)
		 SPACERECORD,-		;  Space Records
		 RECAL,-		;  Recalibrate (REWIND)
		 PACKACK,-		;  Pack Acknowledge
		 ERASETAPE,-		;  Erase Tape (Erase Gap)
		 SENSECHAR,-		;  Sense Characteristics
		 SETCHAR,-		;  Set Characteristics
		 SENSEMODE,-		;  Sense Mode
		 SETMODE,-		;  Set Mode
		 SPACEFILE,-		;  Space File
		 WRITECHECK,-		;  Write Check
		 READPBLK,-		;  Read  PHYSICAL Block
		 WRITEPBLK,-		;  Write PHYSICAL Block
		 READLBLK,-		;  Read  LOGICAL  Block
		 WRITELBLK,-		;  Write LOGICAL  Block
		 READVBLK,-		;  Read  VIRTUAL  Block
		 WRITEVBLK,-		;  Write VIRTUAL  Block
		 WRITEMARK,-		;  Write Tape Mark
		 DSE,-			;  Data Security Erase
		 REWIND,-		;  Rewind
		 REWINDOFF,-		;  Rewind AND Set Offline (UNLOAD)
		 SKIPRECORD,-		;  Skip Records
		 SKIPFILE,-		;  Skip Files
		 WRITEOF,-		;  Write End Of File
		 ACCESS,-		;  Access file and/or find directory entry
		 ACPCONTROL,-		;  ACP Control Function
		 CREATE,-		;  Create file and/or create directory entry
		 DEACCESS,-		;  Deaccess file
		 DELETE,-		;  Delete file and/or directory entry
		 MODIFY,-		;  Modify file attributes
		 MOUNT>			;  Mount volume
	FUNCTAB	,-			; BUFFERED I/O FUNCTIONS
		<NOP,-			;  No Operation
		 UNLOAD,-		;  Unload (make available + spindown)
		 AVAILABLE,-		;  Available (no spindown)
		 SPACERECORD,-		;  Space Records
		 RECAL,-		;  Recalibrate (REWIND)
		 PACKACK,-		;  Pack Acknowledge
		 ERASETAPE,-		;  Erase Tape (Erase Gap)
		 SENSECHAR,-		;  Sense Characteristics
		 SETCHAR,-		;  Set   Characteristics
		 SENSEMODE,-		;  Sense Mode
		 SETMODE,-		;  Set   Mode
		 SPACEFILE,-		;  Space File
		 WRITEMARK,-		;  Write Tape Mark
		 DSE,-			;  Data Security Erase
		 REWIND,-		;  Rewind
		 REWINDOFF,-		;  Rewind AND Set Offline (UNLOAD)
		 SKIPRECORD,-		;  Skip Records
		 SKIPFILE,-		;  Skip Files
		 WRITEOF,-		;  Write End Of File
		 ACCESS,-		;  Access file and/or find directory entry
		 ACPCONTROL,-		;  ACP Control Function
		 CREATE,-		;  Create file and/or create directory entry
		 DEACCESS,-		;  Deaccess file
		 DELETE,-		;  Delete file and/or directory entry
		 MODIFY,-		;  Modify file attributes
		 MOUNT>			;  Mount volume
	FUNCTAB	+ACP$READBLK,-		; READ FUNCTIONS
		<READLBLK,-		;  Read LOGICAL Block
		 READPBLK,-		;  Read  PHYSICAL Block
		 READVBLK>		;  Read VIRTUAL Block
	FUNCTAB	+ACP$WRITEBLK,-		; WRITE FUNCTIONS
		<WRITECHECK,-		;  Write Check
		 WRITEPBLK,-		;  Write PHYSICAL Block
		 WRITELBLK,-		;  Write LOGICAL Block
		 WRITEVBLK>		;  Write VIRTUAL Block
	FUNCTAB	+ACP$ACCESS,-		;
		<ACCESS,CREATE>		; ACCESS AND CREATE FILE OR DIRECTORY
	FUNCTAB	+ACP$DEACCESS,<DEACCESS>; DEACCESS FILE
	FUNCTAB	+ACP$MODIFY,-		;
		<ACPCONTROL,-		;  ACP Control Function
		 DELETE,-		;  Delete file or directory entry
		 MODIFY>		;  Modify File Attributes
	FUNCTAB	+ACP$MOUNT,<MOUNT>	; Mount Volume
	FUNCTAB	+MT$CHECK_ACCESS,-	;MAGTAPE CHECK ACCESS FUNCTIONS
		<ERASETAPE,-		;  Erase Tape (Erase Gap)
		 WRITEMARK,-		;  Write Tape Mark
		 DSE,-			;  Data Security Erase
		 WRITEOF>		;  Write End Of File
	FUNCTAB	+EXE$ZEROPARM,-		; ZERO PARAMETER FUNCTIONS
		<NOP,-			;  No Operation
		 UNLOAD,-		;  Unload (make available + spindown)
		 RECAL,-		;  Recalibrate (REWIND)
		 REWIND,-		;  Rewind
		 REWINDOFF,-		;  Rewind AND Set Offline (UNLOAD)
		 ERASETAPE,-		;  Erase Tape (Erase Gap)
		 SENSECHAR,-		;  Sense Characteristics
		 SENSEMODE,-		;  Sense Mode
		 WRITEMARK,-		;  Write Tape Mark
		 DSE,-			;  Data Security Erase
		 WRITEOF,-		;  Write End Of File
		 AVAILABLE,-		;  Available (no spindown)
		 PACKACK>		;  Pack Acknowledge
	FUNCTAB	+EXE$ONEPARM,-		;ONE PARAMETER FUNCTIONS
		<SPACERECORD,-		;  Space Records
		 SPACEFILE,-		;  Space Files
		 SKIPRECORD,-		;  Skip Records
		 SKIPFILE>		;  Skip Files
	FUNCTAB	+EXE$SETMODE,-		;SET TAPE CHARACTERISTICS
		<SETCHAR,-		;
		 SETMODE>		;
	.PAGE
	.SBTTL	Static Storage
	.SBTTL	-	Data Area Shared With Common Subroutines Module
;++
;
; Data Area Shared With Common Subroutines Module
;
; Functional Description:
;
;	This PSECT contains those constant (link-time) values which would 
;	otherwise be passed as arguments to the disk and tape class driver 
;	common routines in module DUTUSUBS.
;
;--

	.SAVE

	.PSECT	$$$220_DUTU_DATA_01 RD,WRT,EXE,LONG

	ASSUME	DUTU$L_CDDB_LISTHEAD EQ 0

;base + DUTU$L_CDDB_LISTHEAD			; Location containing the
						; address of the CDDB listhead
	.ADDRESS IOC$GL_TU_CDDB			; for CDDBs belonging to the 
						; tape device type

	.RESTORE
	.PAGE
	.SBTTL	-	Media-id to Device Type Conversion Table
;++
;
; Media-id to Device Type Conversion Table
;
; Functional Description:
;
;	This table is used by DUTU$GET_DEVTYPE to convert a MSCP media 
;	identifier to a VMS device type.
;
;	Entries are made here in order of expected frequency of use.  This
;	speeds lookup for the more common cases.
;
;--

	MEDIA	<MU>, <TU81>
	MEDIA	<MU>, <TA78>
	MEDIA	<MU>, <TA81>
	MEDIA	<MU>, <TK50>
	MEDIA	<MF>, <TU78>
	.PAGE
	.SBTTL	Controller Initialization Routine

;+
; MSCP speaking intelligent controller initialization routine.
;
; INPUTS:
;	R4 => System ID of intelligent controller.
;	R5 => IDB
;	R6 => DDB
;	R8 => CRB for intelligent controller.
;

TU_CONTROLLER_INIT:
	BRB	0$			; Branch around breakpoint.
	JSB	G^INI$BRK		; Breakpoint for debugging.
0$:

; Check for CDDB already present.  If a CDDB is present, this call results
; from a power failure.  This driver performs power failure recovery as a
; result of virtual circuit closure notification.  No action need be taken
; here.

	TSTL	CRB$L_AUXSTRUC(R8)	; Is there a CDDB present?
	BEQL	5$			; Branch if CDDB is not present.
	RSB				; Else, just exit.

; Check that only one UCB is chained onto the input DDB.  This UCB could be
; the boot device UCB.  Therefore, make the UCB online so that I/O may be 
; performed on it.  All other initialization of the UCB is performed as the 
; result of DPT_STORE entries place in the INIT section of the DPT by the 
; INIT_UCB macro.

5$:
	MOVL	DDB$L_UCB(R6),R5	; R5 => first UCB if any.
	BISL	#UCB$M_ONLINE, -	; Set the possibily boot UCB online.
		UCB$L_STS(R5)
	TSTL	UCB$L_LINK(R5)		; Is there another UCB?
	BEQL	10$			; EQL implies no more UCB's.
	BUG_CHECK	TAPECLASS,FATAL	; For now.
10$:

; Setup those values which must be correct before IPL is lowered from 31.  
; Then FORK to create an IPL$_SCS fork thread which will complete controller 
; initialization.  Initialization of an MSCP server requires several message 
; exchanges and consumes several seconds.  Therefore, this work is conducted 
; in a fork thread with other system initialization proceeding concurrently.

	MOVL	R5, CRB$L_AUXSTRUC(R8)	; The UCB will act as a CDDB until the 
					; real one is built.
	MOVQ	(R4), -			; Setup remote system ID for call to
		UCB$Q_UNIT_ID(R5)	; DUTU$CREATE_CDDB.

	FORK				; Create initialization fork thread.

; Create and initialize the CDDB.

	BSBW	DUTU$CREATE_CDDB
;
; Here we call an internal subroutine which:
;
;	1. Makes a connection to the MSCP server in the intelligent
;		controller.
;
;	2. Sends an MSCP command to SET CONTROLLER CHARACTERISTICS.
;
;	3. Allocates an MSCP buffer and RSPID for our future use in
;		connection management.
;
; Upon return R4 => PDT and R5 => CDRP.
;

	MOVAL	CDDB$A_PRMCDRP(R5), R5	; Get permanent CDRP address.
	BSBW	MAKE_CONNECTION		; Call internal subroutine to make
					;  a connection to the MSCP server in
					;  the intelligent controller. Input
					;  and output are R5 => CDRP.

	PERMCDRP_TO_CDDB -		; Get CDDB address in R3.
		cdrp=R5, cddb=R3
	MOVL	CDDB$L_CRB(R3),R0	; Get CRB address.
	MOVAB	W^TU$TMR, -		; Establish permanent timeout routine.
		CRB$L_TOUTROUT(R0)
	MOVZWL	CDDB$W_CNTRLTMO(R3), R1	; Get controller timeout interval.
	ADDL3	R1, G^EXE$GL_ABSTIM, -	; Use that to set next timeout 
		CRB$L_DUETIME(R0)	; wakeup time.

	; The normal MSCP timeout mechanism is now in effect.  Henceforth,
	; no fork thread may use the CDDB permanent CDRP as a fork block.

	ASSUME	CDDB$V_DAPBSY GE 8
	BISB	#<CDDB$M_DAPBSY @ -8>, -; Set DAP CDRP in use flag.
		CDDB$W_STATUS+1(R3)
	MOVL	CDDB$L_DAPCDRP(R3), R5	; Get DAP CDRP address.
	BSBW	DUTU$POLL_FOR_UNITS	; Poll controller for units.

	BICW	#CDDB$M_NOCONN, -	; Now that connection is good, clear 
		CDDB$W_STATUS(R3)	; the no connection active bit.

	SUBL3	#<UCB$L_CDDB_LINK -	; Get "previous" UCB address in R0.
		 -CDDB$L_UCBCHAIN>, R3, R5

100$:	MOVL	UCB$L_CDDB_LINK(R5), R5	; Link to next UCB (if any).
	BEQL	120$			; EQL implies no more UCB's.
	.IF	DEFINED TU_TRACE
	BSBW	TRACE_INIT		; Init IRP trace table.
	.ENDC
	BICW	#UCB$M_MSCP_WAITBMP, -	; Indicate RWAITCNT no longer bumped.
		UCB$W_DEVSTS(R5)
	DECW	UCB$W_RWAITCNT(R5)	; Decrement wait count to allow I/O.
	BEQL	110$			; Branch if wait count is zero.
	BSBW	DUTU$CHECK_RWAITCNT	; Else, check wait count validity.
110$:	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	; Save registers before call.
	JSB	G^SCS$UNSTALLUCB	; Startup any queued up I/O requests.
	POPR	#^M<R0,R1,R2,R3,R4,R5>	; Restore registers after call.
	BRB	100$			; Loop back to test more UCB's (if any).
120$:	BICW	#<CDDB$M_INITING -	; Clear "initing" and DAP CDRP busy
		 !CDDB$M_DAPBSY>, -	; flags.
		CDDB$W_STATUS(R3)
	RSB				; Terminate this thread of execution.

INIT_TIMEOUT:				; Controller Init Timeout handler.
	BRW	TU$RE_SYNCH		; If we timeout, try to restart.
	.PAGE
	.PAGE
	.SBTTL	MAKE_CONNECTION

; MAKE_CONNECTION - Internal subroutine, called from TU_CONTROLLER_INIT and
;	TU$CONNECT_ERR, that establishes a connection to the MSCP server
;	in the intelligent controller.
;
; INPUTS:
;	R5 => permanent CDRP
;
; OUTPUTS:
;	Connection established and initial SET CONTROLLER CHARACTERISTICS
;	command is sent to controller.  Also an MSCP buffer and an RSPID
;	are allocated for the connection.
;
;	Side effects include the fact that all registers, except R5, are
;	modified.
;

CLASS_DRVR_NAME:	.ASCII	/VMS$TAPE_CL_DRVR/
MSCP_SRVR_NAME:		.ASCII	/MSCP$TAPE       /

HSTIMEOUT_ARRAY:			; Host timeouts for various controllers.
	ASSUME	MSCP$K_CM_HSC50	EQ	1
	ASSUME	MSCP$K_CM_UDA50	EQ	2
	ASSUME	MSCP$K_CM_RC25	EQ	3
	ASSUME	MSCP$K_CM_EMULA	EQ	4
	ASSUME	MSCP$K_CM_TU81	EQ	5
	ASSUME	MSCP$K_CM_UDA52	EQ	6
	.BYTE	HOST_TIMEOUT		; Use default constant for HSC50.
	.BYTE	0			; Use zero for dedicated controller.(UDA50)
	.BYTE	0			; Use zero for dedicated controller.(AZTEC)
	.BYTE	HOST_TIMEOUT		; Use default constant for Emulator.
	.BYTE	0			; Use zero for dedicated controller.(TU81)
	.BYTE	0			; Use zero for dedicated controller.(UDA52)

MAKE_CONNECTION:

	PERMCDRP_TO_CDDB -		; Get CDDB address from CDRP.
		cdrp=R5, cddb=R2
	POPL	CDDB$L_SAVED_PC(R2)	; Save caller's return in CDDB field.
5$:
	MOVL	G^EXE$GL_ABSTIM,-	; Copy absolute time that we entered
		CDDB$L_OLDCMDSTS(R2)	;  this routine, or the last time that
					;  terminated all pending I/O.
10$:
	MOVL	G^SGN$GL_VMSD3,R0	; Pickup interval of seconds that we
					;  should try to CONNECT until we
					;  decide to terminate pending I/O.
	BEQL	15$			; EQL implies infinite timeout.
	ADDL	CDDB$L_OLDCMDSTS(R2),R0	; Sum is end of timeout interval.
	CMPL	R0,G^EXE$GL_ABSTIM	; See if we have timed out.
	BGTR	15$			; GTR means no, time remains.
	BSBW	TERMINATE_PENDING	; Else call to terminate all pending I/O
	BRB	5$			; Loop back to establish a new timeout
					;  period.
15$:
	CONNECT	TU$IDR,-		; Entry point of Input Dispatcher Routine.
		TU$DGDR,-		; Entry point of Datagram Dispatcher.
		TU$CONNECT_ERR,-	; Error entry point.
		CDDB$B_SYSTEMID(R2),-	; Destination SYSTEM ID.
		,-			; Remote station address.
		MSCP_SRVR_NAME,-	; MSCP server name.
		CLASS_DRVR_NAME,-	; Ascii of class driver name.
		#INITIAL_CREDIT,-	;  Needs definition
		#MIN_SEND_CREDIT,-	; Minimum send credit
		#INITIAL_DG_COUNT,-	; Initial DataGram count
		,-			; Block transfer priority
		,-			; Connect data
		(R2),-			; Also pass CDDB address to CDT$L_AUXSTRUC
		,			; Bad Response packet address

	BLBS	R0,30$			; LBS implies success, so branch around.

	CVTWL	CDRP$W_CDRPSIZE(R5),R2	; R2 has negative offset, from base of
					;  CDRP, of base of CDDB.
	ADDL	R5,R2			; R2 => CDDB.
	MOVL	CDDB$L_CRB(R2),R3	; R3 => CRB.

	MOVAB	B^20$,CRB$L_TOUTROUT(R3); Establish LABEL as place to call, for
					;  now, for periodic wakeups.
	ADDL3	#CONNECT_DELTA,-	; Establish Due time as a little in
		G^EXE$GL_ABSTIM,-	;  the future.
		CRB$L_DUETIME(R3)
	RSB				; Return to caller's caller and kill
					;  this thread.
20$:
	MOVL	CRB$L_AUXSTRUC(R3),R2	; R2 => CDDB.
	MOVAB	CDDB$A_PRMCDRP(R2),R5	; Get permanent CDRP address.
	SETIPL	#IPL$_SCS		; Lower IPL after wakeup.
	BRB	10$			; Loop back and try CONNECT again.
30$:	; A connection has been established
	PERMCDRP_TO_CDDB -		; Get CDDB address from CDRP.
		cdrp=R5, cddb=R1
	MOVL	R3, CDDB$L_CDT(R1)	; Save CDT address (in perm CDRP).
	MOVL	R4, CDDB$L_PDT(R1)	; Save PDT address.
	MOVL	R3, CDDB$L_DAPCDT(R1)	; Save CDT address in DAP CDRP too.
	MOVL	R1, R3			; Now that CDT is saved, move CDDB addr.

	MOVL	CDDB$L_CRB(R3), R1	; Get CRB address.
	MNEGL	#1, CRB$L_DUETIME(R1)	; Infinite time till next timeout, now.
	MOVAB	INIT_TIMEOUT, -		; Establish timeout routine that will
		CRB$L_TOUTROUT(R1)	; serve for rest of controller init.

;
; Here we prepare to send a SET CONTROLLER CHARACTERISTICS MSCP Packet to
;	the intelligent controller over the connection that we have just
;	established.
;

	ALLOC_RSPID			; ALLOCate a ReSPonse ID.
	ALLOC_MSG_BUF			; Allocate an MSCP buffer (and also
					;  allocate a unit of flow control).
	BLBS	R0,50$			; If success, branch around.
	MOVL	CDDB$L_CRB(R3),R3	; TU$RE_SYNCH expects R3 => CDDB.
	BRW	TU$RE_SYNCH		; Failure here means we must re-CONNECT.
50$:					; Here R2 => MSCP buffer allocated.
	CLRL	R1			; First set Controller Characteristics
					;  with zero (i.e. infinite) host timeout.
	BSBB	PRP_STCON_MSG		; Call to prepare MSCP command.
	SEND_MSCP_MSG DRIVER		; Returns with end-message addr. in R2.
	BSBW	RECORD_STCON		; Record Controller Characteristics.

	RECYCH_MSG_BUF			; We recycle the END PACKET and
					;  thereby allocate a new send credit.
	RECYCL_RSPID			; We also recycle the RSPID.

; Determine the correct host timeout interval.  This is the larger of 
; HSTIMEOUT_ARRAY[controller_model] and the controller timeout interval 
; returned by the just completed Set Controller Characteristics.  There is, 
; however, one wrinkle.  Zero represents an infinite timeout and therefore is 
; larger than any other number.  Also, the controller already believes the 
; host timeout interval to be infinite, as the result of the previous Set 
; Controller Characteristics command.  Therefore, no further action need be 
; taken when the timeout interval is infinite.

	MOVZBL	CDDB$B_CNTRLMDL(R3),R1	; Get controller model type.
	MOVZBL	HSTIMEOUT_ARRAY-1[R1],R1; Get corresponding host timeout value.
	BEQL	60$			; If zero, branch around.
	MOVZWL	CDDB$W_CNTRLTMO(R3), R0	; Get controller timeout interval.
	BEQL	60$			; If controller timeout is infinite,
					; use already set infinite host timeout.
	CMPL	R0, R1			; Compare with HSTIMEOUT_ARRAY value.
	BLSSU	55$			; Branch if HSTIMEOUT_ARRAY is larger.
	MOVL	R0, R1			; Else, use controller timeout as
					; host timeout interval.
55$:
	BSBB	PRP_STCON_MSG		; Else reset controller characteristics.
	SEND_MSCP_MSG DRIVER		; Returns with end-message addr. in R2.
	BSBB	RECORD_STCON		; Record Controller Characteristics.
	RECYCH_MSG_BUF			; Again we recycle the END PACKET and
					;  thereby allocate a new send credit.
	RECYCL_RSPID			; We also recycle the RSPID.
60$:

	JMP	@CDDB$L_SAVED_PC(R3)	; Return to caller.
	.PAGE
; PRP_STCON_MSG - Prepare a Set Controller Characteristics Command Message.
;
; Inputs:
;	R1 =  Host Timeout Value
;	R2 => MSCP buffer to fill
;	R3 => CDDB
;	R5 => CDRP
;

PRP_STCON_MSG:

	PUSHL	R1			; Save important register.
	INIT_MSCP_MSG			; Initialize buffer for MSCP message.
	POPL	R1			; Restore important register.

	MOVB	#MSCP$K_OP_STCON,-	; Insert SET CONTROLLER CHARACTERISTICS
		MSCP$B_OPCODE(R2)	;  opcode with NO modifiers.

	MOVW	CDDB$W_CNTRLFLGS(R3),-	; Set host settable characteristics
		MSCP$W_CNT_FLGS(R2)	;  bits into MSCP command message.

	MOVW	R1,MSCP$W_HST_TMO(R2)	; Set host timeout into MSCP packet.

	MOVQ	G^EXE$GQ_SYSTIME,-	; Transmit time of century in clunks.
		MSCP$Q_TIME(R2)

	MOVL	CDDB$L_CRB(R3),R0	; R0 => CRB.
	MOVZWL	CDDB$W_CNTRLTMO(R3),-(SP); Pickup controller delta.
	BNEQ	70$			 ; NEQ implies this controller has been
					 ;  init'ed at least once before.
	MOVL	#INIT_IMMED_DELTA,(SP)	 ; Else use compiled in timeout.
70$:
	ADDL3	(SP)+,-			 ; Establish delta time for time out
		G^EXE$GL_ABSTIM,-	;  to prevent against controller never
		CRB$L_DUETIME(R0)	;  responding.

	RSB				; Return to caller.
	.PAGE
; RECORD_STCON - Record data from a Set Controller Characteristics end message
;		in the CDDB.
;
; Inputs:
;	R2 => MSCP End Message
;	R3 => CDDB


RECORD_STCON:
	MOVW	MSCP$W_CNT_FLGS(R2),-	; Pickup NON-host settable characteristics
		CDDB$W_CNTRLFLGS(R3)	;  from END PACKET and save in CDDB.

	MOVW	MSCP$W_CNT_TMO(R2),-	; Likewise with controller timeout.
		CDDB$W_CNTRLTMO(R3)

	MOVQ	MSCP$Q_CNT_ID(R2),-	; Also save controller unique ID.
		CDDB$Q_CNTRLID(R3)

	BBSS	#CDDB$V_ALCLS_SET, -	; Branch if allocation class already
		CDDB$W_STATUS(R3), 90$	; set, and indicate it is now set.
	; The allocation class is about to be set for this device.  The object
	; is to give every reasonable chance for the value to be non-zero.
	MOVL	G^CLU$GL_ALLOCLS, -	; Assume a local, single host 
		CDDB$L_ALLOCLS(R3)	; controller.
	CMPB	#MSCP$K_CM_HSC50, -	; Is this an HSC?
		CDDB$B_CNTRLMDL(R3)
	BEQL	1099$			; Branch to multihost leg, if HSC.
	BBC	#MSCP$V_CF_MLTHS, -	; Branch if a single host controller.
		CDDB$W_CNTRLFLGS(R3), -
		80$
1099$:
	MOVZBL	MSCP$B_CNT_ALCS(R2), -	; Get set controller characteristics
		CDDB$L_ALLOCLS(R3)	; allocation class.
80$:	MOVAB	<CDDB$L_DDB -		; Init loop through all DDBs.
		-DDB$L_CONLINK>(R3), R0
82$:	MOVL	DDB$L_CONLINK(R0), R0	; Link to next DDB.
	BEQL	90$			; Branch if no more DDBs.
	MOVL	CDDB$L_ALLOCLS(R3), -	; Copy allocation class to this
		DDB$L_ALLOCLS(R0)	; DDB.
	BRB	82$			; Loop till no more DDBs.

90$:	RSB
	.PAGE
	.SBTTL	TERMINATE_PENDING

; TERMINATE_PENDING - internal routine called from MAKE_CONNECTION.
;	The purpose of this routine is to terminate all pending I/O on
;	this connection because the amount of time specified in a SYSGEN
;	parameter has passed without being able to CONNECT.
;
; Inputs:
;	R2 => CDDB
;	R5 => CDRP
;
; Outputs:
;	Registers R0, R1, R3 are modified.
;

TERMINATE_PENDING:
	BBS	#CDDB$V_INITING,-	; Do not time out during initialization.
		CDDB$W_STATUS(R2),50$
10$:
	REMQUE	@CDDB$L_RSTRTQFL(R2),R0	; REMQUE a pending CDRP. R0 => CDRP.
	BVS	20$			; VS implies queue empty.
	POST_CDRP status=SS$_CTRLERR	; Terminate this CDRP.
	BRB	10$			; Loop thru all CDRP's on CDDB Q.
20$:
	SUBL3	#<UCB$L_CDDB_LINK -	; Get "previous" UCB in R3.
		 -CDDB$L_UCBCHAIN>, -
		R2, R3

30$:	MOVL	UCB$L_CDDB_LINK(R3), R3	; Chain to next UCB (if any).
	BEQL	50$			; EQL implies no more UCB's here.
40$:
	REMQUE	@UCB$L_IOQFL(R3),R0	; R0 => IRP on Q.
	BVS	30$			; VS implies I/O queue empty.
	MOVAB	-CDRP$L_IOQFL(R0),R0	; R0 => CDRP portion of IRP.
	POST_CDRP status=SS$_CTRLERR	; Terminate this CDRP.
	BRB	40$			; Loop thru all IRP's on UCB.
50$:
	RSB				; Return to caller.
	.PAGE
	.SBTTL	BRING_UNIT_ONLINE

; BRING_UNIT_ONLINE - Internal subroutine to bring an available unit online.
;	This subroutine is called from TU$CONNECT_ERR.
;
; INPUTS:
;	R3 => CDDB
;	R4 => PDT
;	R5 => UCB
;
; Implicit Inputs:
;
;	CDDB$W_STATUS(R3)	CDDB$V_DAPBSY set
;
;	The normal class driver MSCP operation timeout mechanism must be
;	enabled. 
;

BRING_UNIT_ONLINE:

	POPL	CDDB$L_SAVED_PC(R3)	; Save caller's return address.
	MOVL	CDDB$L_DAPCDRP(R3), R0	; Get DAP CDRP address.
	MOVL	R5, R3			; Copy UCB address.
	MOVL	R0, R5			; Copy CDRP address.

	MOVL	R3, CDRP$L_UCB(R5)	; Setup UCB address in CDRP.

	ALLOC_MSG_BUF			; Allocate a message buffer.
	BLBS	R0, 3$			; Branch if connection is not broken.
	RSB				; Else, just kill this fork thread.
3$:	ALLOC_RSPID			; Allocate a response-id.
	INIT_MSCP_MSG ucb=(R3)		; Initialize buffer for MSCP message.

	MOVB	#MSCP$K_OP_ONLIN,-	; ONLINE command, zero modifiers.
		MSCP$B_OPCODE(R2)

	BISW	#MSCP$M_MD_CLSEX-	; Do exclusive ONLINE and clear serious
		!MSCP$M_MD_EXCLU,-	;  exception.
		MSCP$W_MODIFIER(R2)

	MOVW	UCB$W_UNIT_FLAGS(R3),-	; Copy UNIT flags to MSCP packet.
		MSCP$W_UNT_FLGS(R2)

	MOVL	UCB$L_MSCPDEVPARAM(R3),-; Copy Device dependent parameters to
		MSCP$L_DEV_PARM(R2)	;  MSCP packet.

	EXTZV	#MT$V_DENSITY,-		; Determine density that the user has
		#MT$S_DENSITY,-		;  last established for this unit
		UCB$L_DEVDEPEND(R3),R0	;  and put into R0.

	BSBW	VMSTOMSCP_DENS		; Convert VMS density to MSCP format.
	MOVW	R1,MSCP$W_FORMAT(R2)	; Move MSCP density in R1 into packet.

	BBC	#MSCP$V_UF_VSMSU,-	; Test if we are suppressing variable
		MSCP$W_UNT_FLGS(R2),10$	;  speed mode, and branch if NOT.
	EXTZV	#MT$V_SPEED,-		; Extract user's speed specification
		#MT$S_SPEED,-		;  from UCB.
		UCB$L_DEVDEPEND(R3),R0	;  and put into R0.
	BSBW	SPEEDTOMSCP			
	MOVW	R0,MSCP$W_SPEED(R2)	; Move MSCP speed in R0 into packet.

10$:	SEND_MSCP_MSG DRIVER		; ONLIN - returns end pkt. addr. in R2.
	IF_MSCP	FAILURE, then=30$	; Branch if ONLIN failed.

; If here then various fields in the END PACKET are valid.
;	Here we have just brought ONLINE a unit that was online before 
;	as a result of a failed previous CONNECTION.  We assume
;	that the volume is identical to the one that was ONLINE here before.
;	And then setup the UCB accordingly.
;

	BSBW	RECORD_ONLINE		; Move data from end message to UCB.

	RESET_MSCP_MSG			; Setup message buf. etc. for reuse.

	MOVB	#MSCP$K_OP_GTUNT,-	; GET UNIT STATUS command, zero modifiers.
		MSCP$B_OPCODE(R2)

	SEND_MSCP_MSG DRIVER		; GTUNT - returns end pkt. addr. in R2.
	IF_MSCP	FAILURE, then=30$	; Branch if GTUNT failed.

	BSBW	RECORD_GETUNIT_CHAR	; Record UNIT status data in UCB.

; Here reposition out to where we were before.

	RESET_MSCP_MSG			; Setup message buf. etc. for reuse.

	MOVB	#MSCP$K_OP_REPOS,-	; Reposition command.
		MSCP$B_OPCODE(R2)
	BISW	#MSCP$M_MD_REWND-	; Rewind and then space out an absolute
		!MSCP$M_MD_OBJCT,-	;  number of objects.
		MSCP$W_MODIFIER(R2)
	MOVL	UCB$L_RECORD(R3),-	; Copy number of objects (gaps) to skip
		MSCP$L_REC_CNT(R2)	;  into MSCP command packet.

	SEND_MSCP_MSG DRIVER		; REPOS - returns end pkt. addr. in R2.
	IF_MSCP	FAILURE, then=30$	; Branch if REPOS failed.

20$:	BSBW	DUTU$DEALLOC_ALL	; Deallocate all CDRP resources.

	PERMCDRP_TO_CDDB -		; Get CDDB address in R3.
		cdrp=R5, cddb=R3
	MOVL	CDRP$L_UCB(R5), R5	; Restore input UCB address.
	JMP	@CDDB$L_SAVED_PC(R3)	; Return to caller.

30$:					; HERE if volume has changed.
	ASSUME	UCB$V_VALID GE 8
	BICB	#<UCB$M_VALID @ -8>, -	; If could not put the drive ONLINE,
		UCB$W_STS+1(R3)		; clear the volume valid bit.
	BBC	#MSCP$V_SC_DUPUN,-	; Branch around if NOT duplicate
		MSCP$W_STATUS(R2),40$	;  unit substatus.
	BSBW	DUTU$SEND_DUPLICATE_UNIT; Notify operator of duplicate unit.
40$:
	RESET_MSCP_MSG			; Setup message buf. etc. for reuse.
	MOVB	#MSCP$K_OP_AVAIL,-	; Available command
		MSCP$B_OPCODE(R2)
	SEND_MSCP_MSG DRIVER		; AVAIL - returns end pkt. addr. in R2.
	BRB	20$			; Join common exit code.
	.PAGE
	.PAGE
	.IF	DF	TU_SEQCHK
	.SBTTL	-	OVERRIDE_SEQCHK and REMOVE_SEQARY 

;+
; OVERRIDE_SEQCHK - Set UCB$M_TU_OVRSQCHK bit in UCB$W_DEVSTS and then fall
;			thru to
; REMOVE_SEQARY - Remove this IRP$L_SEQNUM from the UCB$L_TU_SEQARY and
;			collapse the array.
;
; Inputs:
;	R5 => CDRP
;

OVERRIDE_SEQCHK:

	PUSHL	R0			; Save R0.
	MOVL	CDRP$L_UCB(R5),R0	; R0 => UCB.
	BISW	#UCB$M_TU_OVRSQCHK,-	; Set bit to override sequence
		UCB$W_DEVSTS(R0)	;  checking on this operation.
	POPL	R0			; Restore R0.

REMOVE_SEQARY:

	MOVQ	R0,-(SP)		; Save registers.
	PUSHL	R3			;
	MOVL	CDRP$L_UCB(R5),R3	; R3 => UCB.
	EXTZV	#0,#6,-			; Extract index of oldest array slot.
		UCB$B_TU_OLDINX(R3),R0
	EXTZV	#0,#6,-			; Extract index of next  array slot.
		UCB$B_TU_NEWINX(R3),R1
10$:
	EXTZV	#0,#6,R0,R0		; Reduce R0 to 6-bit index.
	CMPL	R0,R1			; Have we run thru entire array?
	BEQL	50$			; EQL implies yes.
	CMPL	CDRP$L_SEQNUM(R5),-	; If not, is this array slot ours?
		UCB$L_TU_SEQARY(R3)[R0]
	BEQL	20$			; EQL implies YES.
	INCL	R0			; Bump index.
	BRB	10$			; And continue loop.
20$:					; Here R0 has array slot index.
	EXTZV	#0,#6,-			; Extract index of oldest array slot.
		UCB$B_TU_OLDINX(R3),-(SP)
30$:					; Here we collapse the array by moving
					;  each slot preceeding the slot to
					;  remove, one position forward.  We
					;  begin with the slot immediately
					;  preceeding the found one.
	EXTZV	#0,#6,R0,R0		; Reduce R0 to 6-bit index.
	CMPL	R0,(SP)			; Are we done?
	BEQL	40$			; EQL implies we are done.
	SUBL3	#1,R0,R1		; R1 has index of preceeding slot.
	EXTZV	#0,#6,R1,R1		; Reduce R1 to 6-bit index.
	MOVL	UCB$L_TU_SEQARY(R3)[R1],-	; Move slot contents forward one
		UCB$L_TU_SEQARY(R3)[R0]		;  position.
	DECL	R0			; Decrement index.
	BRB	30$			; And continue in loop.
40$:
	INCB	UCB$B_TU_OLDINX(R3)	; Increment index to reflect collapse.
	TSTL	(SP)+			; Remove junk from stack.
50$:
	POPL	R3			; Restore registers.
	MOVQ	(SP)+,R0
	RSB				; Return to caller.
	.ENDC
	.PAGE
	.SBTTL	Density and Speed Conversion Routines

;+
; VMSTOMSCP_DENS - Internal subroutine to convert from a VMS density
;	code to a MSCP density code.
;
; Inputs:
;	R0 = VMS density code
;
; Outputs:
;	R1 = MSCP density code
;		R0 = 0 which implies that the VMS code was such that we chose
;			the default MSCP code
;		R0 = 1 which implies that the VMS code was a perfect match for
;			one of the codes.

TU_VMSDENS:
		.BYTE	MT$K_NRZI_800
		.BYTE	MT$K_PE_1600
		.BYTE	MT$K_GCR_6250
		.BYTE	MT$K_PE_1600	; Redundant for NOT FOUND case default.

TU_MSCPDENS:
		.BYTE	MSCP$M_TF_800
		.BYTE	MSCP$M_TF_PE
		.BYTE	MSCP$M_TF_GCR

TU_ABSDENS:
		.WORD	800
		.WORD	1600
		.WORD	6250
		.WORD	1600		; Redundant for NOT FOUND case.

TU_ABSPEED:
		.BYTE	25
		.BYTE	75
		.BYTE	125
		.BYTE	255

VMSTOMSCP_DENS:

	ASSUME	MT$K_NRZI_800	EQ	3
	ASSUME	MT$K_PE_1600	EQ	4
	ASSUME	MT$K_GCR_6250	EQ	5

	SUBL3	#3,R0,R1		; Subtract out NRZI bias from VMS code.
	BLSS	10$			; LSS implies input NOT valid VMS code.
	MOVL	#1,R0			; Setup for possible success return.
	CMPL	R1,#3			; See if input in range.
	BLSS	20$			; LSS implies yes.
10$:
	CLRL	R0			; Indicate we picked up default.
	MOVL	#1,R1			; Default is MSCP 1600 bpi.
20$:
	MOVZBW	TU_MSCPDENS[R1],R1	; Extract MSCP code from array.
	RSB				; Return to caller.

;+
; MSCPTOVMS_DENS - Internal routine to convert from MSCP density code to
;	VMS density code.
;
; Inputs:
;	R0 = MSCP density code
;
; Outputs:
;	R0 = VMS density code
;-

MSCPTOVMS_DENS:

	ASSUME	MSCP$V_TF_800	EQ	0
	ASSUME	MSCP$V_TF_PE	EQ	1
	ASSUME	MSCP$V_TF_GCR	EQ	2
	FFS	#0,#3,R0,R0		; R0 contains 0, 1 or 2 (or 3 if not
					;  found).
	MOVZBL	TU_VMSDENS[R0],R0	; R0 contains system density code.
	RSB				; Return to caller.

;+
; SPPEDTOMSCP - internal routine to calculate MSCP speed value.
;
; Inputs:
;	R0 = Speed in IPS
;	R1 = MSCP density value
;
; OUTPUTS:
;	R0 = MSCP speed value
;	R1 modified
;-

SPEEDTOMSCP:

	ASSUME	MSCP$V_TF_800	EQ	0
	ASSUME	MSCP$V_TF_PE	EQ	1
	ASSUME	MSCP$V_TF_GCR	EQ	2
	FFS	#0,#3,R1,R1		; R1 contains 0, 1 or 2 (or 3 if not
					;  found).
	MOVZWL	TU_ABSDENS[R1],R1	; R1 contains system density code.
	MULL	R1,R0			; R0 contains absolute data rate.
	DIVL	#1000,R0		; MSCP value is rate/1000.
	RSB				; Return to caller.

;+
; MSCPTOSPEED - internal routine to convert MSCP data rate to speed in IPS.
;
; Inputs:
;	R0 = MSCP Data Rate
;	R1 = MSCP density value
;
; OUTPUTS:
;	R0 = MSCP speed value
;	R1 modified
;-

MSCPTOSPEED:

	ASSUME	MSCP$V_TF_800	EQ	0
	ASSUME	MSCP$V_TF_PE	EQ	1
	ASSUME	MSCP$V_TF_GCR	EQ	2
	FFS	#0,#3,R1,R1		; R1 contains 0, 1 or 2 (or 3 if not
					;  found).
	MOVZWL	TU_ABSDENS[R1],R1	; R1 contains system density code.
	MULL	#1000,R0		; Multiply MSCP data rate by 1000.
	DIVL	R1,R0			; Divide by density.
	ADDL	#5,R0			; Round up.

;	ASSUME	MT$S_SPEED	EQ	8
	MOVAB	TU_ABSPEED,R1		; R1 => Start of table.
10$:
	CMPB	R0,(R1)+		; Find first entry > R0.
	BGTRU	10$			; If R0 >, loop back.
	MOVZBL	-1(R1),R0		; Pickup previous value.
	RSB				; Return to caller.
	.PAGE
	.SBTTL	SET_CLEAR_SEX

;+
; SET_CLEAR_SEX - internal subroutine to set (or not to set) the
;	CLEAR_Serious_EXception modifier in an MSCP command.
;	If the tape is NOT in Serious Exception mode, then this modifier
;	is routinely set on each and every command.  If the tape IS in
;	serious exception mode, then the modifier bit is only set if the
;	QIO function code modifier IO$M_CLSEREXCP is specified on this
;	QIO request.
;
;	Whether or not we are in Serious Exception mode is a function
;	of how the tape was mounted and the state of a MT$M_ENSEREXCP bit
;	in UCB$L_DEVDEPEND.
;
;	If the tape is MOUNTED ANSI, this implies that Serious Exception
;	mode is enabled.  In other words, we are in Serious Exception mode
;	if the volume is Mounted ANSI or if the MT$M_ENSEREXCP bit is on in
;	UCB$L_DEVDEPEND.  If a tape is NOT mounted ANSI (i.e. either not
;	mounted or mounted foreign) and MT$M_ENSEREXECP is not set then
;	we implicitly insert a Clear Serious Exception modifier on each
;	and every command.
;
; Inputs:
;	R2 => MSCP command buffer
;	R3 => UCB
;	R5 => CDRP

SET_CLEAR_SEX:

	BBS	#IO$V_CLSEREXCP,-	; Branch to clear if clearing serious
		CDRP$W_FUNC(R5),10$	;  exception specified.

	BBS	#MT$V_ENSEREXCP,-	; Branch if Serious Exception explicitly
		UCB$L_DEVDEPEND(R3),20$	;  enabled.
	BBC	#DEV$V_MNT,-		; If Tape NOT mounted, go clear serious
		UCB$L_DEVCHAR(R3),10$	;  exception.
	BBC	#DEV$V_FOR,-		; Branch around Serious Exception
		UCB$L_DEVCHAR(R3),20$	;  clearing if tape MOUNTED ANSI.

10$:	ASSUME	MSCP$V_MD_CLSEX GE 8
	BISB	#<MSCP$M_MD_CLSEX@-8>,-	; Request clearing of possible Serious
		MSCP$W_MODIFIER+1(R2)	; Exception condition.
	BICB	#MT$M_SEREXCP,-		; Also explicitly clear software bit.
		UCB$L_DEVDEPEND(R3)

20$:	RSB				; Return.
	.PAGE
	.IF	DF	TU_SEQCHK
	.ALIGN	LONG,0
SEQ_MASK:
	SEQFUNC	<-			; SEQUENTIALFUNCTIONS
		 UNLOAD,-		;  Unload (make available + spindown)
		 AVAILABLE,-		;  Available (no spindown)
		 SPACERECORD,-		;  Space Records
		 RECAL,-		;  Recalibrate (REWIND)
		 PACKACK,-		;  Pack Acknowledge
		 ERASETAPE,-		;  Erase Tape (Erase Gap)
		 SETCHAR,-		;  Set Characteristics
		 SETMODE,-		;  Set Mode
		 SPACEFILE,-		;  Space File
		 WRITECHECK,-		;  Write Check
		 READPBLK,-		;  Read  PHYSICAL Block
		 WRITEPBLK,-		;  Write PHYSICAL Block
		 READLBLK,-		;  Read  LOGICAL  Block
		 WRITELBLK,-		;  Write LOGICAL  Block
		 READVBLK,-		;  Read  VIRTUAL  Block
		 WRITEVBLK,-		;  Write VIRTUAL  Block
		 WRITEMARK,-		;  Write Tape Mark
		 DSE,-			;  Data Security Erase
		 REWIND,-		;  Rewind
		 REWINDOFF,-		;  Rewind AND Set Offline (UNLOAD)
		 SKIPRECORD,-		;  Skip Records
		 SKIPFILE,-		;  Skip Files
		 WRITEOF>		;  Write End Of File
	.ENDC
	.PAGE
	.SBTTL	AUTO_PACKACK - Perform automatic PACKACK for foreign tapes
;++
;
;	This code thread performs a gratuitous PACKACK for foreign mounted 
;	tapes.  It executes whenever an I/O request finds the volume valid bit 
;	clear, the tape at BOT, and the foreign mounted bit set.
;
;	The input CDRP is given a RSPID and a message buffer.  The message is 
;	inititalized.  This thread is then synchronized with the server so 
;	that this is the only thread communicating with the server.  Note: 
;	there is an implicit synchronization with other SEQNOP threads in that 
;	control cannot arrive here while other threads are synchronized by 
;	SEQNOP.  
;
;	Once synchronization is established, ONLINE and GET UNIT STATUS 
;	commands are sent to the server.  This simulates an IO$_PACKACK.
;	If either command fails, the I/O request is completed with a volume 
;	invalid error.  If both commands succeed, the device is marked volume 
;	valid and BOT.  The original request is requeued at the head of the 
;	pending I/O request queue and the SEQNOP condition is ended.  This 
;	restarts the original I/O request before any which may have 
;	accumulated while the automatic PACKACK was in progress.
;
;	All failures result in the unit being set MSCP AVAILABLE and the UCB 
;	being marked volume invalid.  Before completing the original I/O 
;	request, the error path also ends the SEQNOP condition.
;--

	.ENABLE LSB

850$:	BRW	MSG_BUF_FAILURE		; Branch assist.

AUTO_PACKACK:

	.IIF	DF TU_SEQCHK, BSBW OVERRIDE_SEQCHK	; Undo seq. checking.
	ALLOC_RSPID			; Allocate RSPID.
	ALLOC_MSG_BUF			; Allocate a message buffer.
	BLBC	R0, 850$		; Branch if connection broken.
	INIT_MSCP_MSG ucb=(R3)		; Initialize message buffer.
	START_SEQNOP			; Synchronize with server.

	MOVB	#MSCP$K_OP_ONLIN, -	; ONLINE command.
		MSCP$B_OPCODE(R2)
	BISW	#<MSCP$M_MD_CLSEX -	; Do exclusive ONLINE and clear serious
		 !MSCP$M_MD_EXCLU>, -	; exception.
		MSCP$W_MODIFIER(R2)
	MOVW	UCB$W_UNIT_FLAGS(R3), -	; Copy UNIT flags to MSCP packet.
		MSCP$W_UNT_FLGS(R2)
	MOVL	UCB$L_MSCPDEVPARAM(R3),-; Copy Device dependent parameters to
		MSCP$L_DEV_PARM(R2)	; MSCP packet.
	EXTZV	#MT$V_DENSITY, -	; Determine density that the user has
		#MT$S_DENSITY, -	; last established for this unit
		UCB$L_DEVDEPEND(R3), R0	; and put into R0.
	BSBW	VMSTOMSCP_DENS		; Convert VMS density to MSCP format.
	MOVW	R1, MSCP$W_FORMAT(R2)	; Move MSCP density in R1 into packet.
	BBC	#MSCP$V_UF_VSMSU, -	; Test if we are suppressing variable
		MSCP$W_UNT_FLGS(R2), 10$; speed mode, and branch if NOT.
	EXTZV	#MT$V_SPEED,-		; Extract user's speed specification
		#MT$S_SPEED,-		; from UCB.
		UCB$L_DEVDEPEND(R3), R0
	BSBW	SPEEDTOMSCP			
	MOVW	R0, MSCP$W_SPEED(R2)	; Move MSCP speed in R0 into packet.
10$:	SEND_MSCP_MSG 			; ONLIN - returns end pkt. addr. in R2.
	ASSUME	CDRP$V_CAND EQ 0
	BLBS	CDRP$L_DUTUFLAGS(R5), -	; Has operation been canceled?
		900$			; Branch if operation canceled.
	IF_MSCP	FAILURE, then=900$	; Branch if ONLIN failed.

	; The various fields in the END PACKET are valid and the tape is 
	; ONLINE.

	BSBW	RECORD_ONLINE		; Move data from end message to UCB.

	RESET_MSCP_MSG			; Setup message buf. etc. for reuse.
	MOVB	#MSCP$K_OP_GTUNT, -	; GET UNIT STATUS command.
		MSCP$B_OPCODE(R2)
	SEND_MSCP_MSG 			; GTUNT - returns end pkt. addr. in R2.
	ASSUME	CDRP$V_CAND EQ 0
	BLBS	CDRP$L_DUTUFLAGS(R5), -	; Has operation been canceled?
		900$			; Branch if operation canceled.
	IF_MSCP	FAILURE, then=900$	; Branch if GTUNT failed.

	BSBW	RECORD_GETUNIT_CHAR	; Record UNIT status data in UCB.

	ASSUME	UCB$V_VALID GE 8
	BISB	#<UCB$M_VALID @ -8>, -	; Make unit volume valid.
		UCB$W_STS+1(R3)
	ASSUME	MT$V_BOT GE 16
	BISB	#<MT$M_BOT @ -16>, -	; Set beginning of tape.
		UCB$L_DEVDEPEND+2(R3)
	BSBW	DUTU$DEALLOC_ALL	; Release all SCS resources.
	INSQUE	CDRP$L_IOQFL(R5), -	; Put this request at the head of 
		UCB$L_IOQFL(R3)		; the pending I/O queue.
	END_SEQNOP			; End the sequential NOP state.
	RSB				; Kill this thread.

	; Something went wrong during auto PACKACK.  Fail the I/O request.

900$:	ASSUME	UCB$V_VALID GE 8
	BICW	#<UCB$M_VALID @ -8>, -	; Clear unit volume valid.
		UCB$W_STS+1(R3)
	BBC	#MSCP$V_SC_DUPUN, -	; Branch around if NOT duplicate
		MSCP$W_STATUS(R2), 940$	; unit substatus.
	BSBW	DUTU$SEND_DUPLICATE_UNIT; Notify operator of duplicate unit.
940$:	RESET_MSCP_MSG			; Setup message buf. etc. for reuse.
	MOVB	#MSCP$K_OP_AVAIL, -	; Setup available command.
		MSCP$B_OPCODE(R2)
	SEND_MSCP_MSG			; AVAIL - returns end pkt. addr. in R2.
	END_SEQNOP			; End the sequential NOP state.
	MOVZWL	#SS$_VOLINV, R0		; Set volume invalid status.
	ASSUME	CDRP$V_CAND EQ 0
	BLBC	CDRP$L_DUTUFLAGS(R5), -	; But, if operation was canceled,
		950$			; use "aborted" status instead.
	MOVZWL	#SS$_ABORT, R0
950$:	BRW	FUNCTION_EXIT		; Terminate origianl I/O request.

	.DISABLE LSB
	.PAGE
	.SBTTL	START I/O
;
;+
;
;  Beginning of out of line code to deal with problems that
;	may occur in the common STARTIO code on the next page.

LOCAL_DEVICE:
	MOVL	UCB$L_2P_ALTUCB(R5),R5	; R5 => local UCB.
	JMP	G^EXE$INSIOQ		; Go hand this IRP to local driver.

;
; Out of line code to handle Volume Invalid.
;

VOL_INVALID:

	BBC	#DEV$V_FOR, -		; Branch if device is not foreign
		UCB$L_DEVCHAR(R3), 10$	; mounted.
	TSTL	UCB$L_RECORD(R3)	; Is device at beginning of tape?
	BNEQ	10$			; Branch if device not at BOT.
	BRW	AUTO_PACKACK		; Else, go issue gratuitous PACKACK.
10$:	BBS	#IRP$V_PHYSIO,-		; See if PHYSICAL I/O requested.
		CDRP$W_STS(R5),-	;  If physical, then branch back to
		PHYIO_VOLINV		;  continue even tho VOLINV.
	.IF	DF	TU_SEQCHK
	BSBW	OVERRIDE_SEQCHK		; Override sequence checking and
					;  remove sequence # from array.
	.ENDC

	MOVZWL	#SS$_VOLINV,R0		; Indicate error status.
	CLRL	R1			; Clear second word of I/O status.
	BRW	FUNCTION_EXIT		; GOTO common exit.

;

MSG_BUF_FAILURE:

; We are here only if we had an allocation failure on the Message Buffer.
;  This implies that our CONNECTION to the MSCP server is broken.  The action
;  to be taken is to kill this thread of execution since we are guaranteed
;  that a thread exists that is currently executing that is gathering all
;  CDRP's associated with this CONNECTION.  So we branch to KILL_THIS_THREAD.

	BRW	DUTU$KILL_THIS_THREAD	; Branch to where we collect all active
					;  CDRP's prior to re-CONNECTION.
;
;  End of out of line code
;-
	.PAGE
TU_STARTIO:
	ASSUME	UCB$V_BSY GE 8
	BICB	#<UCB$M_BSY @ -8>, -	; Undo bit setting so that multiple
		UCB$W_STS+1(R5)		; IRP's can be started.

; If this UCB indicates that the device is a local (non-MSCP) device that
; has also been made available to us via 1) dual porting and 2) an MSCP
; Server on the node to which it is dual ported, then shunt this IRP to
; the local driver.

	BBS	#DEV$V_CDP,-		; This bit, if clear indicates that
		UCB$L_DEVCHAR2(R5),-	;  the above condition is NOT true,
		LOCAL_DEVICE		;  so branch out of line if set.
	MOVAB	-CDRP$L_IOQFL(R3),R0	; Get address of CDRP portion of IRP.

	ASSUME	CDRP$B_CD_TYPE EQ CDRP$W_CDRPSIZE+2
	ASSUME	CDRP$B_FIPL    EQ CDRP$W_CDRPSIZE+3
	MOVL	#< <IPL$_SCS@24> -	; Initialize CDRP size, type and fork
		 ! <DYN$C_CDRP@16> -	; IPL fields.
		 ! <CDRP$L_IOQFL&^xFFFF> >, -
		CDRP$W_CDRPSIZE(R0)

	ASSUME	CDRP$L_RSPID	EQ	CDRP$L_MSG_BUF+4
	CLRQ	CDRP$L_MSG_BUF(R0)	; Prevent spurious DEALLOC_MSG_BUF and
					;  also spurious DEALLOC_RSPID.
	CLRL	CDRP$L_LBUFH_AD(R0)	; Prevent spurious UNMAP.
	MOVAB	UCB$W_RWAITCNT(R5),-	; Point CDRP field to UCB field.
		CDRP$L_RWCPTR(R0)
	CLRL	CDRP$L_DUTUFLAGS(R0)	; Initialize class driver flags.
	TSTW	UCB$W_RWAITCNT(R5)	; See if any IRP's currently waiting
					;  for resources.
	BEQL	TU_REAL_STARTIO		; EQL implies NO, so GOTO real STARTIO.
	INSQUE	IRP$L_IOQFL(R3),-	; To force sequential submission of commands
		@UCB$L_IOQBL(R5)	;  to intelligent controller, we force
					;  IRP's to be queued up here if any
					;  previous request is possibly hungup
					;  waiting for resources between the
					;  beginning of STARTIO and the SEND_MSG_BUF.
	RSB				; Return to caller (QIO system service)

TU_REAL_STARTIO:

	.IF	DF	TU_TRACE
	BSBW	TRACE_IRP		; Trace IRP.
	MOVAB	-CDRP$L_IOQFL(R3),R0	; Refresh R0=CDRP if tracing.
	.ENDC

	MOVL	R5,R3			; Let R3 => UCB.
	MOVL	R0,R5			; R5 => CDRP.

	.IF	DF	TU_SEQCHK
	EXTZV	#IRP$V_FCODE,-		; Extract I/O function code.
		#IRP$S_FCODE,-
		CDRP$W_FUNC(R5),R1
	BBC	R1,SEQ_MASK,TU_RESTARTIO; If non-Sequential I/O branch around.
	EXTZV	#0,-			; Extract six bit index into array of
		#6,-			;  IRP sequence number slots.  R1 =
		UCB$B_TU_NEWINX(R3),R1	;  index of next available slot.
	INCB	UCB$B_TU_NEWINX(R3)	; Increment index.
	MOVL	CDRP$L_SEQNUM(R5),-	; Copy sequnce number of this IRP to
		UCB$L_TU_SEQARY(R3)[R1]	;  circular ring slot.
	.ENDC

TU_RESTARTIO:				; Label where we RESTART CDRP's after
					;  virtual circuit re-CONNECTION.

	MOVL	UCB$L_CDT(R3),-		; Place CDT pointer into CDRP for handy
		CDRP$L_CDT(R5)		;  reference by SCS routines. Note we
					;  do this after label TU_RESTARTIO so
					;  that it is refreshed upon restart.
	MOVL	UCB$L_PDT(R3),R4	; R4 => port's PDT.

	BBS	#UCB$V_VALID, -		; Branch if unit is volume valid.
		UCB$W_STS(R3), PHYIO_VOLINV
	BRW	VOL_INVALID		; Else, branch to out of line
					; volume invalid processing.

PHYIO_VOLINV:
	ALLOC_RSPID			; ALLOCate a ReSPonse ID.
	ALLOC_MSG_BUF			; Allocate an MSCP buffer (and also
					;  allocate a unit of flow control).
	BLBC	R0,MSG_BUF_FAILURE	; If failure, branch out of line.

; Here a little common MSCP packet initialization.

	MOVL	R2, R0			; Copy message buffer address.
	.REPEAT	MSCP$K_MXCMDLEN / 8
	CLRQ	(R0)+			; Zero entire message buffer.
	.ENDR
	.IIF	NE MSCP$K_MXCMDLEN & 4, CLRL (R0)+
	.IIF	NE MSCP$K_MXCMDLEN & 2, CLRW (R0)+
	.IIF	NE MSCP$K_MXCMDLEN & 1, CLRB (R0)+

	MOVL	CDRP$L_RSPID(R5),-	; Use RSPID as command reference
		MSCP$L_CMD_REF(R2)	;  number for all commands.

	MOVW	UCB$W_MSCPUNIT(R3),-	; Indicate UNIT number in MSCP
		MSCP$W_UNIT(R2)		;  packet.

TU_BEGIN_IVCMD:
TU_REDO_IO:

	BSBW	SET_CLEAR_SEX		; Go set state of Clear Serious EXception.
	BBC	#IO$V_INHRETRY,-	; Branch around if NOT inhibiting RETRY.
		CDRP$W_FUNC(R5),30$
	ASSUME	MSCP$V_MD_SEREC GE 8	; Else, set the suppress error
	BISB	#<MSCP$M_MD_SEREC@-8>, -; modifier.
		MSCP$W_MODIFIER+1(R2)
30$:
	EXTZV	#IRP$V_FCODE,-		; Extract I/O function code.
		#IRP$S_FCODE,-
		CDRP$W_FUNC(R5),R1

	DISPATCH R1, type=B, prefix=IO$_, < -		; Dispatch to correct 
		<NOP,		START_NOP>, -		; function processing.
		<PACKACK,	START_PACKACK>, -
		<UNLOAD,	START_UNLOAD>, -
		<AVAILABLE,	START_AVAILABLE>, -
		<REWIND,	START_REWIND>, -
		<REWINDOFF,	START_REWINDOFF>, -
		<READPBLK,	START_READPBLK>, -
		<WRITECHECK,	START_WRITECHECK>, -
		<WRITEPBLK,	START_WRITEPBLK>, -
		<WRITEMARK,	START_WRITEMARK>, -
		<WRITEOF,	START_WRITEOF>, -
		<SPACEFILE,	START_SPACEFILE>, -
		<SKIPFILE,	START_SKIPFILE>, -
		<SPACERECORD,	START_SPACERECORD>, -
		<SKIPRECORD,	START_SKIPRECORD>, -
		<RECAL,		START_RECAL>, -
		<ERASETAPE,	START_ERASETAPE>, -
		<DSE,		START_DSE>, -
		<SENSECHAR,	START_SENSECHAR>, -
		<SENSEMODE,	START_SENSEMODE>, -
		<SETCHAR,	START_SETCHAR>, -
		<SETMODE,	START_SETMODE> -
		>

	; Function code is not legal.

	BSBW	DUTU$RESTORE_CREDIT	; Restore allocated send credit.
	MOVZWL	#SS$_ILLIOFUNC,R0
	CLRL	R1
	BRW	FUNCTION_EXIT		; Branch to exit I/O function.
	.PAGE
	.SBTTL	START_NOP
; START_NOP - Prepare an MSCP packet to do a GET UNIT STATUS command.
;
; INPUTS:
;	R2 => MSCP buffer
;	R3 => UCB
;	R4 => PDT
;	R5 => CDRP
;
;	MSCP packet is zero except for MSCP$L_CMD_REF and MSCP$W_UNIT fields.
;

START_NOP:
	MOVB	#MSCP$K_OP_GTUNT,-	; Transfer GET UNIT STATUS opcode
		MSCP$B_OPCODE(R2)	;  to packet.
	ASSUME	MSCP$V_MD_CLSEX GE 8
	BICB	#<MSCP$M_MD_CLSEX@-8>,-	; The clear serious execption modifier
		MSCP$W_MODIFIER+1(R2)	; is illegal on get unit status cmds.

	IF_IVCMD then=NOP_IVCMD_END	; Branch if invalid command processing.

	SEND_MSCP_MSG			; Send message to remote MSCP server.

	DO_ACTION	NONTRANSFER	; Decode MSCP end status.
	ACTION_ENTRY	SUCC,  SS$_NORMAL,	NOP_SUCC
	ACTION_ENTRY	OFFLN, SS$_DEVOFFLINE,	NOP_OFFLINE
	ACTION_ENTRY	AVLBL, SS$_MEDOFL,	NOP_AVAIL
	ACTION_ENTRY	DRIVE, SS$_DRVERR,	NOP_DRVERR
	ACTION_ENTRY	CNTLR, SS$_CTRLERR,	NOP_CTRLERR
	ACTION_ENTRY	ICMD,  SS$_CTRLERR,	NOP_IVCMD
	ACTION_ENTRY	END_TABLE

	BRW	INVALID_STS		; Unexpected MSCP end status.

NOP_IVCMD:
	IVCMD_BEGIN			; Begin invalid command processing.
	BRW	TU_BEGIN_IVCMD		; Replicate building MSCP command.
NOP_IVCMD_END:
	IVCMD_END			; Complete invalid command processing.
; -----	BRB	NOP_SUCC		; Fall through to complete command.


NOP_SUCC:
NOP_OFFLINE:
NOP_AVAIL:
NOP_CTRLERR:
NOP_DRVERR:
;NOP_END:
	CLRL	R1			; Clear for I/O status block.
	BRW	FUNCTION_EXIT		; Branch to common exit.
	.PAGE
	.PAGE
	.SBTTL	START_PACKACK

; START_PACKACK - Prepare an MSCP packet to do an ONLINE command.
;
; INPUTS:
;	R2 => MSCP buffer
;	R3 => UCB
;	R4 => PDT
;	R5 => CDRP
;
;	MSCP packet is zero except for MSCP$L_CMD_REF and MSCP$W_UNIT fields.
;

START_PACKACK:

	MOVB	#MSCP$K_OP_ONLIN,-	; Transfer ONLINE opcode
		MSCP$B_OPCODE(R2)	;  to packet.

	MOVL	UCB$L_CDDB(R3), R0	; Get CDDB address.
	BBC	#MSCP$V_CF_MLTHS, -	; Branch if not a multi-host server.
		CDDB$W_CNTRLFLGS(R0), 20$
	BISW	#MSCP$M_MD_EXCLU,-	; Do exclusive ONLINE.
		MSCP$W_MODIFIER(R2)

20$:	MOVW	UCB$W_UNIT_FLAGS(R3), - ; Copy unit flags to MSCP packet.
		MSCP$W_UNT_FLGS(R2)

	MOVL	UCB$L_MSCPDEVPARAM(R3),-; Copy Device dependent parameters to
		MSCP$L_DEV_PARM(R2)	;  MSCP packet.

	EXTZV	#MT$V_DENSITY,-		; Determine density that the user has
		#MT$S_DENSITY,-		;  last established for this unit
		UCB$L_DEVDEPEND(R3),R0	;  and put into R0.
	BSBW	VMSTOMSCP_DENS		; Convert VMS density to MSCP format.
	MOVW	R1,MSCP$W_FORMAT(R2)	; Move MSCP density in R1 into packet.

	IF_IVCMD then=PACKACK_IVCMD_END	; Branch if invalid command processing.

	SEND_MSCP_MSG			; Send message to remote MSCP server.

	ASSUME	UCB$V_VALID GE 8
	BICB	#<UCB$M_VALID @ -8>, -	; Initialize software volume invalid.
		UCB$W_STS+1(R3)

	DO_ACTION	NONTRANSFER	; Decode MSCP end status.
	ACTION_ENTRY	SUCC,  SS$_NORMAL,	PACKACK_SUCC
	ACTION_ENTRY	OFFLN, SS$_MEDOFL,	PACKACK_OFFLINE
	ACTION_ENTRY	ABRTD, SS$_ABORT,	END_PACKACK
	ACTION_ENTRY	DRIVE, SS$_DRVERR,	END_PACKACK
	ACTION_ENTRY	FMTER, SS$_CTRLERR,	END_PACKACK
	ACTION_ENTRY	CNTLR, SS$_CTRLERR,	END_PACKACK
	ACTION_ENTRY	ICMD,  SS$_CTRLERR,	PACKACK_IVCMD
	ACTION_ENTRY	END_TABLE

	BRW	INVALID_STS		; Unexpected MSCP end status.


PACKACK_SUCC:				; Action routine for MSCP$K_ST_SUCC.

	ASSUME	CDRP$V_CAND EQ 0
	BLBS	CDRP$L_DUTUFLAGS(R5), -	; Was I/O request canceled?
		890$			; Branch if request was canceled.
	BBS	#MSCP$V_SC_ALONL,-	; Branch around clearing of TU_RECORD
		MSCP$W_STATUS(R2),10$	;  if REDUNDANT ONLINE.
	CLRL	UCB$L_RECORD(R3)	; Successful exclusive ONLINE rewinds
	ASSUME	MT$V_BOT  GE 16
	ASSUME	MT$V_EOF  GE 16
	ASSUME	MT$V_EOT  GE 16
	ASSUME	MT$V_LOST GE 16
	BICB	#<<MT$M_EOF ! MT$M_EOT -; Clear position sensitive DEVDEPEND
		 ! MT$M_LOST> @ -16>, - ; bits.
		UCB$L_DEVDEPEND+2(R3)
	BISB	#<MT$M_BOT @ -16>, -	; Set BOT DEVDEPEND position bit.
		UCB$L_DEVDEPEND+2(R3)
10$:
	BSBW	RECORD_ONLINE		; Record ONLINE data in UCB.

; Here having done an ONLINE we proceed to do a GET UNIT STATUS.

	RESET_MSCP_MSG			; Setup message buf. etc. for reuse.
	MOVB	#MSCP$K_OP_GTUNT,-	; Opcode is for GET UNIT STATUS.
		MSCP$B_OPCODE(R2)
	SEND_MSCP_MSG			; Send message to remote MSCP server.

	IF_MSCP	SUCCESS, then=PACKACK_GTUNT_SUCC  ; Branch if GTUNT successful.
	ASSUME	CDRP$V_CAND EQ 0
890$:	BLBS	CDRP$L_DUTUFLAGS(R5), -	; Was I/O request canceled?
		PACKACK_CANCEL		; Branch if request was canceled.
	RESET_MSCP_MSG			; Setup message buf. etc. for reuse.
	BRW	TU_REDO_IO		; Go try again.

PACKACK_GTUNT_SUCC:

	BSBB	RECORD_GETUNIT_CHAR	; Record unit status data in UCB.

	MOVZWL	#SS$_NORMAL, R0		; Set success IOSB status.
	BRB	VALID_PACKACK		; And branch around to success.

PACKACK_IVCMD:
	IVCMD_BEGIN			; Begin invalid command processing.
	BRW	TU_BEGIN_IVCMD		; Repeat commands that formed MSCP cmd.
PACKACK_IVCMD_END:
	IVCMD_END			; Complete invalid command processing.
	BRB	END_PACKACK		; Branch around to end.

PACKACK_OFFLINE:

	BBC	#MSCP$V_SC_DUPUN,-	; Branch around if NOT duplicate
		MSCP$W_STATUS(R2),20$	;  unit substatus.
	PUSHL	R5			; Save R5.
	MOVL	R3,R5			; R5 => UCB for subroutine.
	BSBW	DUTU$SEND_DUPLICATE_UNIT; Send a message to the operator.
	POPL	R5			; Restore R5.
	MOVZWL	#SS$_DUPUNIT,R0		; Return final status.
	BRB	END_PACKACK		; Branch around.
20$:
	BBC	#MSCP$V_SC_INOPR,-	; Branch around if NOT unit inoperative
		MSCP$W_STATUS(R2),-	;  substatus.
		END_PACKACK
	MOVZWL	#SS$_DRVERR,R0		; Return final status.
	BRB	END_PACKACK		; Branch around.

PACKACK_CANCEL:

	RESET_MSCP_MSG			; Ready message for a new MSCP command.
	MOVB	#MSCP$K_OP_AVAIL, -	; Undo online with available command.
		MSCP$B_OPCODE(R2)
	SEND_MSCP_MSG			; Sent AVAILABLE to the server.
	MOVZWL	#SS$_ABORT, R0		; Signal request was canceled.
	BRB	END_PACKACK		; Exit function.

VALID_PACKACK:

	ASSUME	UCB$V_VALID GE 8
	BISB	#<UCB$M_VALID @ -8>, -	; Set software volume valid.
		UCB$W_STS+1(R3)
END_PACKACK:
	BRW	FUNCTION_EXIT
	.PAGE
	.SBTTL	PACKACK Support Routines

;+
; RECORD_ONLINE - copy data from ONLINE END MESSAGE to UCB.
; RECORD_SETUNIT_CHAR - copy data from SET UNIT CHAR End Message to UCB.
; RECORD_GETUNIT_CHAR - copy data from GET UNIT CHAR End Message to UCB.
;
; Inputs:
;	R2 => End Message
;	R3 => UCB
;
; Outputs:
;	R1 corrupted.
;	All other registers preserved.
;
;	UCB fields set
;-

RECORD_ONLINE:
RECORD_SETUNIT_CHAR:

	MOVL	MSCP$L_MAXWTREC(R2),-	; Copy maximum recommended write
		UCB$L_TU_MAXWRCNT(R3)	;  record size to UCB.
	MOVW	MSCP$W_NOISEREC(R2),-	; Copy size of noise records to UCB.
		UCB$W_TU_NOISE(R3)
	BRB	RECORD_COMMON		; Join common "record" processing.

RECORD_GETUNIT_CHAR:

	ASSUME	MT$V_SUP_NRZI EQ 21
	ASSUME	MSCP$V_TF_800 EQ  0
	ASSUME	MT$V_SUP_PE   EQ 22
	ASSUME	MSCP$V_TF_PE  EQ  1
	ASSUME	MT$V_SUP_GCR  EQ 23
	ASSUME	MSCP$V_TF_GCR EQ  2
	INSV	MSCP$W_FORMENU(R2), -	; Copy supported tape densities to
		#MT$V_SUP_NRZI, #3, -	; DEVDEPEND.
		UCB$L_DEVDEPEND(R3)

RECORD_COMMON:

	PUSHL	R0			; Save R0.
	MOVQ	MSCP$Q_UNIT_ID(R2),-	; In the event of success, copy unit
		UCB$Q_UNIT_ID(R3)	;  characteristics data to UCB.
	MOVL	MSCP$L_MEDIA_ID(R2),-	; Starting with the UNIT ID, followed
		UCB$L_MEDIA_ID(R3)	;  by the media identifier and
	BSBW	DUTU$GET_DEVTYPE	;  device type.

	BICW	#MT$M_DENSITY,-		; Clear density field in DEVDEPEND.
		UCB$L_DEVDEPEND(R3)

	MOVZWL	MSCP$W_FORMAT(R2),R0	; Pickup MSCP density code.
	BSBW	MSCPTOVMS_DENS		; Convert to VMS format.
	INSV	R0,-			; Insert system density code into
		#MT$V_DENSITY,-		;  DEVDEPEND.
		#MT$S_DENSITY,-
		UCB$L_DEVDEPEND(R3)

	MOVW	MSCP$W_UNT_FLGS(R2),-	; Copy new unit flags from end packet.
		UCB$W_UNIT_FLAGS(R3)
	MOVW	MSCP$W_SPEED(R2),-	; Copy speed to UCB.
		UCB$W_TU_SPEED(R3)
	MOVW	MSCP$W_FORMAT(R2),-	; Copy format to UCB.
		UCB$W_TU_FORMAT(R3)
	BBS	#MSCP$V_UF_VSMSU,-	; Branch if suppressing Variable speed
		MSCP$W_UNT_FLGS(R2),10$	;  mode.
;	ASSUME	MT$K_SPEED_DEF	EQ	0
	CLRL	R0			; R0 = default speed.
	BRB	20$			; Branch around.
10$:
	MOVZWL	MSCP$W_SPEED(R2),R0	; Get speed of unit.
	MOVZWL	MSCP$W_FORMAT(R2),R1	; And density.
	BSBW	MSCPTOSPEED		; Convert Speed to VMS value.
20$:
	INSV	R0,-			; Insert VMS speed value into UCB.
		#MT$V_SPEED,-
		#MT$S_SPEED,-
		UCB$L_DEVDEPEND(R3)
	ASSUME	MSCP$V_UF_WRTPH GE 8
	ASSUME	MSCP$V_UF_WRTPS GE 8
	ASSUME	MT$V_HWL GE 16
	ASSUME	UCB$V_MSCP_WRTP GE 8
	BICB	#<MT$M_HWL @ -16>, -	; Assume device is not hardware write
		UCB$L_DEVDEPEND+2(R3)	; locked.
	BICB	#<UCB$M_MSCP_WRTP@-8>,-	; Ditto for class driver write
		UCB$W_DEVSTS+1(R3)	; protect flag.
	BITB	#<<MSCP$M_UF_WRTPH -	; Is the unit hardware or 
		 !MSCP$M_UF_WRTPS>@-8>,-; software write protected?
		MSCP$W_UNT_FLGS+1(R2)
	BEQL	50$			; Branch if not write protected.
	BISB	#<MT$M_HWL @ -16>, -	; Else, set the hardware write
		UCB$L_DEVDEPEND+2(R3)	; locked bit in DEVDEPEND.
	BISB	#<UCB$M_MSCP_WRTP@-8>,-	; Set class driver write
		UCB$W_DEVSTS+1(R3)	; protect flag too.

50$:	POPL	R0			; Restore R0.
	RSB				; Return to caller.
	.PAGE
	.SBTTL	START_UNLOAD and START_AVAILABLE

; START_AVAILABLE - Prepare an MSCP packet to do an AVAILABLE command without
;	the spindown modifier.
;
; START_UNLOAD - Prepare an MSCP packet to do an AVAILABLE command with
;	spindown specified.
;
; INPUTS:
;	R2 => MSCP buffer
;	R3 => UCB
;	R4 => PDT
;	R5 => CDRP
;
;	MSCP packet is zero except for MSCP$L_CMD_REF and MSCP$W_UNIT fields.
;

START_REWINDOFF:
START_UNLOAD:

	BISW	#MSCP$M_MD_UNLOD,-	; Specify the UNLOAD bit in the
		MSCP$W_MODIFIER(R2)	;  modifier word.

START_AVAILABLE:

	MOVB	#MSCP$K_OP_AVAIL,-	; Transfer AVAILABLE opcode
		MSCP$B_OPCODE(R2)	;  to packet.

	IF_IVCMD then=AVAIL_IVCMD_END	; Branch if invalid command processing.

	SEND_MSCP_MSG			; Send message to remote MSCP server.

	ASSUME	UCB$V_VALID GE 8
	BICB	#<UCB$M_VALID @ -8>, -	; Initialize software volume invalid.
		UCB$W_STS+1(R3)

	DO_ACTION	NONTRANSFER	; Decode MSCP end status.
	ACTION_ENTRY	SUCC,  SS$_NORMAL,	AVAILABLE_SUCC
	ACTION_ENTRY	AVLBL, SS$_NORMAL,	AVAILABLE_SUCC
	ACTION_ENTRY	PRESE, SS$_SERIOUSEXCP,	AVAILABLE_SEREX
	ACTION_ENTRY	OFFLN, SS$_MEDOFL,	AVAILABLE_MEDOFL
	ACTION_ENTRY	ABRTD, SS$_ABORT,	AVAILABLE_ABORT
	ACTION_ENTRY	DRIVE, SS$_DRVERR,	AVAILABLE_DRVERR
	ACTION_ENTRY	CNTLR, SS$_CTRLERR,	AVAILABLE_CTRLERR
	ACTION_ENTRY	ICMD,  SS$_CTRLERR,	AVAIL_IVCMD
	ACTION_ENTRY	END_TABLE

	BRW	INVALID_STS		; Unexpected MSCP end status.

AVAIL_IVCMD:
	IVCMD_BEGIN			; Begin invalid command processing.
	BRW	TU_BEGIN_IVCMD		; Repeat building the MSCP command.
AVAIL_IVCMD_END:
	IVCMD_END			; Complete invalid command processing.
; -----	BRB	AVAILABLE_SUCC		; Fall through to complete operation.


AVAILABLE_SUCC:				; Action routine for MSCP$K_ST_SUCC.
AVAILABLE_MEDOFL:			; Action routine for MSCP$K_ST_MEDOFL.
AVAILABLE_ABORT:			; Action routine for MSCP$K_ST_ABORT.
AVAILABLE_DRVERR:			; Action routine for MSCP$K_ST_DRVERR.
AVAILABLE_CTRLERR:			; Action routine for MSCP$K_ST_CNTLR.
	BICL	#MT$M_ENSEREXCP,-	; Clear Serious Exception mode on
		UCB$L_DEVDEPEND(R3)	;  becoming available.
	INSV	#MT$K_SPEED_DEF,-	; Reset Speed to default.
		#MT$V_SPEED,-
		#MT$S_SPEED,-
		UCB$L_DEVDEPEND(R3)
	BICW	#MSCP$M_UF_VSMSU,-	; Also reset bit.
		UCB$W_UNIT_FLAGS(R3)
	CLRL	UCB$L_RECORD(R3)	; Clear tape position counter.
	ASSUME	MT$V_BOT  GE 16
	ASSUME	MT$V_EOF  GE 16
	ASSUME	MT$V_EOT  GE 16
	ASSUME	MT$V_HWL  GE 16
	ASSUME	MT$V_LOST GE 16
	BICB	#<<MT$M_EOF ! MT$M_EOT -   ; Clear position sensitive writelock
		 ! MT$M_HWL ! MT$M_LOST> - ; DEVDEPEND bits.
		 @ -16>, UCB$L_DEVDEPEND+2(R3)
	BISB	#<MT$M_BOT @ -16>, -	; Set BOT DEVDEPEND position bit.
		UCB$L_DEVDEPEND+2(R3)
	ASSUME	UCB$V_MSCP_WRTP GE 8
	BICB	#<UCB$M_MSCP_WRTP@-8>,-	; Clear class driver write
		UCB$W_DEVSTS+1(R3)	; protect flag.
AVAILABLE_SEREX:
	BRW	FUNCTION_EXIT
	.PAGE
	.SBTTL	Start WRITEOF, WRITEMARK, ERASETAPE, and DSE.

; START_WRITEMARK - Prepare an MSCP packet to do a WRITE TAPE MARK command.
; START_ERASETAPE - Prepare an MSCP packet to do an ERASE GAP command.
; START_DSE - Prepare an MSCP packet to do an ERASE command.
;
; INPUTS:
;	R2 => MSCP buffer
;	R3 => UCB
;	R4 => PDT
;	R5 => CDRP
;
;	MSCP packet is zero except for MSCP$L_CMD_REF and MSCP$W_UNIT fields.
;

START_ERASETAPE:
	MOVB	#MSCP$K_OP_ERGAP,-	; Transfer ERASEGAP opcode
		MSCP$B_OPCODE(R2)	;  to packet.
	BRB	WTM_ERASE_COM		; Branch around to common.

START_DSE:
	MOVB	#MSCP$K_OP_ERASE,-	; Transfer ERASE opcode
		MSCP$B_OPCODE(R2)	;  to packet.
	BBC	#IO$V_NOWAIT,-		; If NOT nowait, branch around.
		CDRP$W_FUNC(R5),-
		WTM_ERASE_COM
	ASSUME	MSCP$V_MD_IMMED LE 7
	BISB	#MSCP$M_MD_IMMED, -	; If NOWAIT, then set proper TMSCP
		MSCP$W_MODIFIER(R2)	; modifier in command message.
	BRB	WTM_ERASE_COM		; Branch around to common.

START_WRITEMARK:
START_WRITEOF:
	MOVB	#MSCP$K_OP_WRITM,-	; Transfer WRITE TAPE MARK opcode
		MSCP$B_OPCODE(R2)	;  to packet.

WTM_ERASE_COM:

	IF_IVCMD then=WRITM_IVCMD_END	; Branch if invalid command processing.

	SEND_MSCP_MSG			; Send message to remote MSCP server.

	ASSUME	MT$V_BOT  GE 16
	ASSUME	MT$V_EOF  GE 16
	ASSUME	MT$V_EOT  GE 16
	ASSUME	MT$V_LOST GE 16
	BICB	#<<MT$M_BOT ! MT$M_EOF -; Clear position sensitive DEVDEPEND
		 ! MT$M_EOT -		; bits
		 ! MT$M_LOST> @ -16>, -
		UCB$L_DEVDEPEND+2(R3)

	DO_ACTION	NONTRANSFER	; Decode MSCP end status.
	ACTION_ENTRY	SUCC,  SS$_NORMAL,	WRITM_SUCC
	ACTION_ENTRY	ABRTD, SS$_ABORT,	WRITM_ABORT
	ACTION_ENTRY	OFFLN, SS$_DEVOFFLINE,	WRITM_OFFLINE
	ACTION_ENTRY	AVLBL, SS$_MEDOFL,	WRITM_AVAIL
	ACTION_ENTRY	WRTPR, SS$_WRITLCK,	WRITM_WRITLCK
	ACTION_ENTRY	PRESE, SS$_SERIOUSEXCP,	WRITM_PRESE
	ACTION_ENTRY	CNTLR, SS$_CTRLERR,	WRITM_CTRLERR
	ACTION_ENTRY	FMTER, SS$_CTRLERR,	WRITM_FMTER
	ACTION_ENTRY	DATA,  SS$_PARITY,	WRITM_DATA_ERROR
	ACTION_ENTRY	DRIVE, SS$_DRVERR,	WRITM_DRVERR
	ACTION_ENTRY	PLOST, SS$_CTRLERR,	ERASEGAP_PLOST
	ACTION_ENTRY	ICMD,  SS$_CTRLERR,	WRITM_IVCMD
	ACTION_ENTRY	END_TABLE

	BRW	INVALID_STS		; Unexpected MSCP end status.

WRITM_IVCMD:
	IVCMD_BEGIN			; Begin invalid command processing.
	BRW	TU_BEGIN_IVCMD		; Rebuild fatal MSCP command.
WRITM_IVCMD_END:
	IVCMD_END			; Complete invalid command processing.
	BRB	WRITM_END		; Branch around to end.

ERASEGAP_PLOST:
	ASSUME	MT$V_LOST GE 16
	BISB	#<MT$M_LOST @ -16>, -	; Set position LOST DEVDEPEND bit.
		UCB$L_DEVDEPEND+2(R3)
WRITM_ABORT:
WRITM_OFFLINE:
WRITM_AVAIL:
WRITM_WRITLCK:
WRITM_CTRLERR:
WRITM_FMTER:
WRITM_DRVERR:
WRITM_DATA_ERROR:
WRITM_SUCC:
	TSTL	UCB$L_RECORD(R3)	; Previously at BOT?
	BNEQ	10$			; Branch if not previously at BOT.
	BISB	#CDRP$M_DENSCK, -	; Else, set density check required flag.
		CDRP$L_DUTUFLAGS(R5)
10$:	MOVL	MSCP$L_POSITION(R2), -	; Update tape position information.
		UCB$L_RECORD(R3)
WRITM_END:
	BBC	#MSCP$V_EF_EOT,-	; See if we passed into End Of Tape
		MSCP$B_FLAGS(R2),40$	;  region, and branch around if NOT.
	ASSUME	MT$V_EOT  GE 16
	BISB	#<MT$M_EOT @ -16>, -	; Set EOT DEVDEPEND position bit.
		UCB$L_DEVDEPEND+2(R3)
	BLBC	R0,40$			; If already an error, branch around.
	MOVW	#SS$_ENDOFTAPE,R0	; Return EOT.
40$:
WRITM_PRESE:
	BRW	FUNCTION_EXIT		; Branch to common exit.
	.PAGE
	.SBTTL	Start REWIND.

; START_REWIND - Prepare an MSCP packet to do a REWIND command.
;
; A Rewind QIO request causes us to send an MSCP Reposition Command with
; the MSCP$M_MD_REWIND modifier set and both the MSCP$L_REC_CNT and
; MSCP$L_TMGP_CNT fields zero.  If the user specifies IO$M_NOWAIT, then
; the MSCPP$M_MD_IMMED modifier is set in the command that is sent.
;
; INPUTS:
;	R2 => MSCP buffer
;	R3 => UCB
;	R4 => PDT
;	R5 => CDRP
;
;	MSCP packet is zero except for MSCP$L_CMD_REF and MSCP$W_UNIT fields.
;

START_RECAL:
START_REWIND:

	MOVB	#MSCP$K_OP_REPOS,-	; Transfer REPOSITION opcode
		MSCP$B_OPCODE(R2)	;  to packet.
	BISW	#MSCP$M_MD_REWND,-	; Specify rewind.
		MSCP$W_MODIFIER(R2)

	BBC	#IO$V_NOWAIT,-		; If NOT nowait, branch around.
		CDRP$W_FUNC(R5),10$
	ASSUME	MSCP$V_MD_IMMED LE 7
	BISB	#MSCP$M_MD_IMMED, -	; If NOWAIT, then set proper TMSCP
		MSCP$W_MODIFIER(R2)	; modifier in command message.

10$:	IF_IVCMD then=REWIND_IVCMD_END	; Branch if invalid command processing.

	SEND_MSCP_MSG			; Send message to remote MSCP server.

	DO_ACTION	NONTRANSFER	; Decode MSCP end status.
	ACTION_ENTRY	SUCC,  SS$_NORMAL,	REWIND_SUCC
	ACTION_ENTRY	ABRTD, SS$_ABORT,	REWIND_ABORT
	ACTION_ENTRY	PRESE, SS$_SERIOUSEXCP,	REWIND_PRESE
	ACTION_ENTRY	OFFLN, SS$_DEVOFFLINE,	REWIND_OFFLINE
	ACTION_ENTRY	AVLBL, SS$_MEDOFL,	REWIND_AVAIL
	ACTION_ENTRY	CNTLR, SS$_CTRLERR,	REWIND_CTRLERR
	ACTION_ENTRY	FMTER, SS$_CTRLERR,	REWIND_FMTER
	ACTION_ENTRY	DRIVE, SS$_DRVERR,	REWIND_DRVERR
	ACTION_ENTRY	ICMD,  SS$_CTRLERR,	REWIND_IVCMD
	ACTION_ENTRY	END_TABLE

	BRW	INVALID_STS		; Unexpected MSCP end status.

REWIND_IVCMD:
	IVCMD_BEGIN			; Begin invalid command processing.
	BRW	TU_BEGIN_IVCMD		; Rebuild fatal MSCP command.
REWIND_IVCMD_END:
	IVCMD_END			; Complete invalid command processing.
	BRB	REWIND_END		; Branch around to end.

REWIND_SUCC:
	MOVL	MSCP$L_POSITION(R2),-	; Update positon on tape.
		UCB$L_RECORD(R3)
	BNEQ	30$			; This should be a NOP.
	ASSUME	MT$V_BOT  GE 16
	ASSUME	MT$V_EOF  GE 16
	ASSUME	MT$V_EOT  GE 16
	ASSUME	MT$V_LOST GE 16
	BICB	#<<MT$M_EOF ! MT$M_EOT -; Clear position sensitive DEVDEPEND
		 ! MT$M_LOST> @ -16>, - ; bits.
		UCB$L_DEVDEPEND+2(R3)
	BISB	#<MT$M_BOT @ -16>, -	; Set BOT DEVDEPEND position bit.
		UCB$L_DEVDEPEND+2(R3)
30$:
REWIND_ABORT:
REWIND_OFFLINE:
REWIND_AVAIL:
REWIND_FMTER:
REWIND_CTRLERR:
REWIND_DRVERR:
REWIND_PRESE:
REWIND_END:
	BRW	FUNCTION_EXIT		; Branch to common exit.
	.PAGE
	.SBTTL	Start Space Records and Space Files.

;+
; START_SPACEFILE   -
; START_SKIPFILE    - Prepare an MSCP packet to do a REPOSITION command
;			so as to Skip files.
; START_SPACERECORD - 
; START_SKIPRECORD  - Prepare an MSCP packet to do a REPOSITION command
;			 so as to Skip records.
;
; INPUTS:
;	R2 => MSCP buffer
;	R3 => UCB
;	R4 => PDT
;	R5 => CDRP
;	CDRP$L_MEDIA = # of records or files to
;			 skip (word count in longword field).
;
;	MSCP packet is zero except for MSCP$L_CMD_REF and MSCP$W_UNIT fields.
;

START_SKIPFILE:
START_SPACEFILE:

	MOVAB	MSCP$L_TMGP_CNT(R2),R1	; R1 => field to fill in for skip files.
	BRB	SKIP_COMMON		; Branch around to common code.

START_SKIPRECORD:
START_SPACERECORD:

	MOVAB	MSCP$L_REC_CNT(R2),R1	; R1 => field to fill in for skip records.

SKIP_COMMON:
	MOVB	#MSCP$K_OP_REPOS,-	; Transfer REPOSITION opcode
		MSCP$B_OPCODE(R2)	;  to packet.
	CVTWL	CDRP$L_MEDIA(R5),R0	; Pickup # records to skip.
	BGEQ	10$			; GEQ implies positive (forward) movement.
	MNEGL	R0,R0			; Get absolute value of # to skip.
	BISW	#MSCP$M_MD_REVRS,-	; Set modifier to indicate reverse
		MSCP$W_MODIFIER(R2)	;  motion.
	BRB	17$			; If reverse, then do NOT try to detect
					;  LEOT, so branch around.

10$:	; Detect LEOT is performed on all tapes NOT mounted ANSI.  That is, 
	; all tapes either NOT mounted or mounted Foreign.  The only exception 
	; is for physical I/O requests.

	BBS	#IRP$V_PHYSIO, -	; If physical I/O function, branch
		CDRP$W_STS(R5), 17$	;  around setting to Detect LEOT.
	BBC	#DEV$V_MNT, -		; If Tape NOT mounted, go try to Detect
		UCB$L_DEVCHAR(R3), 14$	; LEOT.
	BBC	#DEV$V_FOR, -		; If NOT foreign, than ANSI, so branch
		UCB$L_DEVCHAR(R3), 17$	; around setting to Detect LEOT.
14$:	ASSUME	MSCP$V_MD_DLEOT LE 7
	BISB	#MSCP$M_MD_DLEOT, -	; Set modifier to ask to Detect LEOT.
		MSCP$W_MODIFIER(R2)

17$:	MOVL	R0, (R1)		; Put #records(files) to skip in packet.

	IF_IVCMD then=SKIP_IVCMD_END	; Branch if invalid command processing.

	SEND_MSCP_MSG			; Send message to remote MSCP server.

	ASSUME	MT$V_BOT  GE 16
	ASSUME	MT$V_EOF  GE 16
	ASSUME	MT$V_EOT  GE 16
	ASSUME	MT$V_LOST GE 16
	BICB	#<<MT$M_BOT ! MT$M_EOF -; Clear position sensitive DEVDEPEND
		 ! MT$M_EOT -		; bits
		 ! MT$M_LOST> @ -16>, -
		UCB$L_DEVDEPEND+2(R3)

	DO_ACTION	TRANSFER	; Decode MSCP end status.
	ACTION_ENTRY	SUCC,  SS$_NORMAL,	SKIP_SUCC
	ACTION_ENTRY	LED,   SS$_ENDOFVOLUME,	SKIP_LEOT
	ACTION_ENTRY	ABRTD, SS$_ABORT,	SKIP_ABORT
	ACTION_ENTRY	PRESE, SS$_SERIOUSEXCP,	SKIP_PRESE
	ACTION_ENTRY	OFFLN, SS$_DEVOFFLINE,	SKIP_OFFLINE
	ACTION_ENTRY	AVLBL, SS$_MEDOFL,	SKIP_AVAIL
	ACTION_ENTRY	CNTLR, SS$_CTRLERR,	SKIP_CTRLERR
	ACTION_ENTRY	FMTER, SS$_CTRLERR,	SKIP_FMTER
	ACTION_ENTRY	DRIVE, SS$_DRVERR,	SKIP_DRVERR
	ACTION_ENTRY	BOT,   SS$_NORMAL,	SKIP_BOT
	ACTION_ENTRY	TAPEM, SS$_ENDOFFILE,	SKIP_EOF
	ACTION_ENTRY	PLOST, SS$_CTRLERR,	SKIP_PLOST
	ACTION_ENTRY	ICMD,  SS$_CTRLERR,	SKIP_IVCMD
	ACTION_ENTRY	END_TABLE

	BRW	INVALID_STS		; Unexpected MSCP end status.

SKIP_IVCMD:
	IVCMD_BEGIN			; Begin invalid command processing.
	BRW	TU_BEGIN_IVCMD		; Rebuild fatal MSCP command.
SKIP_IVCMD_END:
	IVCMD_END			; Complete invalid command processing.
; -----	BRB	SKIP_ABORT		; Fall through to finish skip operation.
SKIP_PRESE:
SKIP_ABORT:
SKIP_OFFLINE:
SKIP_AVAIL:
	ROTL	#16,R0,R0		; Move SS$_ code into low order.
	BRB	SKIP_END		; Branch around to end.

SKIP_PLOST:
	ASSUME	MT$V_LOST GE 16
	BISB	#<MT$M_LOST @ -16>, -	; Set position LOST DEVDEPEND bit.
		UCB$L_DEVDEPEND+2(R3)
	BRB	SKIP_SUCC		; Rejoin common code.
SKIP_EOF:
	ASSUME	MT$V_EOF  GE 16
	BISB	#<MT$M_EOF @ -16>, -	; Set EOF DEVDEPEND position bit.
		UCB$L_DEVDEPEND+2(R3)
	BRB	SKIP_SUCC		; Rejoin common code.
SKIP_BOT:
	ASSUME	MT$V_BOT  GE 16
	BISB	#<MT$M_BOT @ -16>, -	; Set BOT DEVDEPEND position bit.
		UCB$L_DEVDEPEND+2(R3)
; -----	BRB	SKIP_SUCC		; Rejoin common code.
SKIP_FMTER:
SKIP_CTRLERR:
SKIP_DRVERR:
SKIP_SUCC:
SKIP_LEOT:
	BBC	#MSCP$V_EF_EOT, -	; Is tape in the EOT region?
		MSCP$B_FLAGS(R2), 10$	; Branch if tape not in EOT.
	ASSUME	MT$V_EOT  GE 16
	BISB	#<MT$M_EOT @ -16>, -	; Else, set EOT DEVDEPEND position bit.
		UCB$L_DEVDEPEND+2(R3)

10$:	TSTL	UCB$L_RECORD(R3)	; Previously at BOT?
	BNEQ	15$			; Branch if not previously at BOT.
	BISB	#CDRP$M_DENSCK, -	; Else, set density check required flag.
		CDRP$L_DUTUFLAGS(R5)
15$:	MOVL	MSCP$L_POSITION(R2), -	; Update tape position information.
		UCB$L_RECORD(R3)
	ADDL3	MSCP$L_RCSKIPED(R2),-	; Add records and tapemarks skipped
		MSCP$L_TMSKIPED(R2),R1	;  so as to return to user.
	ASHQ	#-16,R0,R0		; Shift count and SS$_ code into position.
SKIP_END:
	BRW	FUNCTION_EXIT		; Branch to common exit.
	.PAGE
	.SBTTL	Start a SETCHAR or a SETMODE function

; START_SETCHAR and START_SETMODE
;	The quad-word of data for the operation is contained in IRP$L_MEDIA.
;	This "PHYSICAL" I/O function and the "LOGICAL" I/O function
;	SET MODE are almost identical.  The only difference is that while
;	both allow for the setting of:
;
;		1. Default buffer size
;		2. Tape density (1600 BPI or 6250 BPI).
;		3. Tape format
;		4. Serious Exception mode
;
;	the former function (i.e. SET CHARACTERISTICS) also allows for
;	the resetting of the DEVICE CLASS and the DEVICE TYPE fields in
;	the UCB.
;
;	The first two bytes of the QUADWORD of data at IRP$L_MEDIA contain
;	the DEVICE CLASS and DEVICE TYPE respectively for a SETCHAR.
;	The next word of the QUADWORD contains the new buffer size.  The
;	third word contains new density and format information.  The fourth
;	word of the QUADWORD is reserved.
;
; INPUTS:
;	R2 => MSCP buffer
;	R3 => UCB
;	R4 => PDT
;	R5 => CDRP
;

START_SETCHAR:
	ASSUME	UCB$B_DEVTYPE EQ UCB$B_DEVCLASS+1
	MOVW	CDRP$L_MEDIA(R5),UCB$B_DEVCLASS(R3)	; Reset CLASS and TYPE.

START_SETMODE:
	MOVW	CDRP$L_MEDIA+2(R5),UCB$W_DEVBUFSIZ(R3)	; Copy new buffer size.

	START_SEQNOP			; Synchronize class driver - server 
					; communications so that only this
					; thread is sending commands to the
					; server.
	ASSUME	CDRP$V_CAND EQ 0
	BLBS	CDRP$L_DUTUFLAGS(R5), -	; Was I/O request canceled?
		SETMODE_CANCEL		; Branch if request was canceled.
	MOVB	#MSCP$K_OP_GTUNT,-	; Opcode is for GET UNIT STATUS.
		MSCP$B_OPCODE(R2)
	ASSUME	MSCP$V_MD_CLSEX GE 8
	BICB	#<MSCP$M_MD_CLSEX@-8>,-	; The clear serious execption modifier
		MSCP$W_MODIFIER+1(R2)	; is illegal on get unit status cmds.
	SEND_MSCP_MSG			; Send message to remote MSCP server.

	IF_MSCP	SUCCESS, then=SETMODE_ONLINE  ; Branch if GTUNT successful.
	.IF	DF	TU_SEQCHK	; Override sequence checking and
	BSBW	OVERRIDE_SEQCHK		; remove sequence number from array.
	.ENDC
	MOVZWL	#SS$_MEDOFL, R0		; Setup final I/O status.

SETMODE_ABORT:
SETMODE_OFFLINE:
SETMODE_CTRLERR:
SETMODE_DRVERR:
	EXTZV	#MT$V_DENSITY,-
		#MT$S_DENSITY,-
		CDRP$L_MEDIA+4(R5),R1	; Extract user designated DENSITY parameter.
	INSV	R1,-			; And insure that UCB$L_DEVDEPEND winds
		#MT$V_DENSITY,-		;  up with the correct value for DENSITY
		#MT$S_DENSITY,-
		UCB$L_DEVDEPEND(R3)

SETMODE_CANCEL:
	BRW	SETMODE_RETURN		; And branch around.

SETMODE_ONLINE:

	ASSUME	CDRP$V_CAND EQ 0
	BLBS	CDRP$L_DUTUFLAGS(R5), -	; Was I/O request canceled?
		SETMODE_ABORT		; Branch if request was canceled.
	BBS	#MT$V_ENSEREXCP,-	; Branch if Serious Exception explicitly
		CDRP$L_MEDIA+4(R5),10$	;  enabled.
	BICL	#MT$M_ENSEREXCP,-	; Else clear Serious Exception mode.
		UCB$L_DEVDEPEND(R3)
	BRB	20$			; And branch around.
10$:
	BISL	#MT$M_ENSEREXCP,-	; Enable Serious Exception mode.
		UCB$L_DEVDEPEND(R3)
20$:
	MOVW	MSCP$W_FORMAT(R2),-	; Copy format to UCB before recycling
		UCB$W_TU_FORMAT(R3)	;  end message.

	RESET_MSCP_MSG			; Setup message buf. etc. for reuse.

SETMODE_BEGIN_IVCMD:

	MOVB	#MSCP$K_OP_STUNT,-	; Transfer Set Unit Characteristics
		MSCP$B_OPCODE(R2)	;  opcode to packet.

	MOVW	UCB$W_UNIT_FLAGS(R3),-	; Copy unit flags to MSCP packet.
		MSCP$W_UNT_FLGS(R2)

	MOVL	UCB$L_MSCPDEVPARAM(R3),-; Copy Device dependent parameters to
		MSCP$L_DEV_PARM(R2)	;  MSCP packet.

	TSTL	UCB$L_RECORD(R3)	; Is tape at BOT?
	BNEQ	35$			; Skip density setup if not at BOT.
	EXTZV	#MT$V_DENSITY,-		; Determine density that the user has
		#MT$S_DENSITY,-		;  specified for this unit
		CDRP$L_MEDIA+4(R5),R0	;  and put into R0.

	BSBW	VMSTOMSCP_DENS		; Convert VMS density to MSCP format.
	BLBS	R0,30$			; LBS means successful conversion.
	EXTZV	#MT$V_DENSITY,-		; Determine density that the user has
		#MT$S_DENSITY,-		;  last established for this unit
		UCB$L_DEVDEPEND(R3),R0	;  and put into R0.
	BSBW	VMSTOMSCP_DENS		; Convert VMS density to MSCP format.
30$:
	MOVW	R1,MSCP$W_FORMAT(R2)	; Copy MSCP density to packet.

35$:	ASSUME	MT$K_SPEED_DEF EQ 0
	EXTZV	#MT$V_SPEED,-		; Extract user specified speed.
		#MT$S_SPEED,-
		CDRP$L_MEDIA+4(R5),R0
	BEQL	40$			; EQL implies default.
	BSBW	SPEEDTOMSCP		; Convert speed to MSCP format.
	BISW	#MSCP$M_UF_VSMSU,-	; Enable variable speed mode suppression.
		MSCP$W_UNT_FLGS(R2)
	BRB	50$			; And branch around.
40$:
	BICW	#MSCP$M_UF_VSMSU,-	; Disable variable speed mode suppression.
		MSCP$W_UNT_FLGS(R2)
50$:
	MOVW	R0,MSCP$W_SPEED(R2)	; Place speed value into packet.

	BSBW	SET_CLEAR_SEX		; Set SEX if called for.

	IF_IVCMD then=SETMODE_IVCMD_END	; Branch if invalid command processing.

	SEND_MSCP_MSG			; Send message to remote MSCP server.

	DO_ACTION	NONTRANSFER	; Decode MSCP end status.
	ACTION_ENTRY	SUCC,  SS$_NORMAL,	SETMODE_SUCC
	ACTION_ENTRY	PRESE, SS$_SERIOUSEXCP,	SETMODE_RETURN
	ACTION_ENTRY	ABRTD, SS$_ABORT,	SETMODE_ABORT
	ACTION_ENTRY	ICMD,  SS$_BUGCHECK,	SETMODE_IVCMD
	ACTION_ENTRY	OFFLN, SS$_MEDOFL,	SETMODE_OFFLINE
	ACTION_ENTRY	AVLBL, SS$_MEDOFL,	SETMODE_OFFLINE
	ACTION_ENTRY	CNTLR, SS$_CTRLERR,	SETMODE_CTRLERR
	ACTION_ENTRY	FMTER, SS$_CTRLERR,	SETMODE_CTRLERR
	ACTION_ENTRY	DRIVE, SS$_DRVERR,	SETMODE_DRVERR
	ACTION_ENTRY	END_TABLE

	BRW	INVALID_STS		; Unexpected MSCP end status.

SETMODE_IVCMD:
	IVCMD_BEGIN			; Begin invalid command processing.
	BRW	SETMODE_BEGIN_IVCMD	; Rebuild fatal MSCP command.
SETMODE_IVCMD_END:
	IVCMD_END			; Complete invalid command processing.
	BRB	SETMODE_RETURN		; Complete setmode operation.

SETMODE_SUCC:

	BSBW	RECORD_SETUNIT_CHAR	; Record data from End Message in UCB.

SETMODE_RETURN:
	END_SEQNOP			; End synchronized class driver - 
					; server communications.
	BRW	FUNCTION_EXIT		; Terminate I/O request.
	.PAGE
	.SBTTL	Start SENSECHAR and SENSEMODE functions.

; START_SENSECHAR and START_SENSEMODE.
;
; INPUTS:
;	R2 => MSCP buffer
;	R3 => UCB
;	R4 => PDT
;	R5 => CDRP
;

START_SENSECHAR:
START_SENSEMODE:

	MOVB	#MSCP$K_OP_GTUNT,-	; Opcode is for GET UNIT STATUS.
		MSCP$B_OPCODE(R2)
	ASSUME	MSCP$V_MD_CLSEX GE 8
	BICB	#<MSCP$M_MD_CLSEX@-8>,-	; The clear serious execption modifier
		MSCP$W_MODIFIER+1(R2)	; is illegal on get unit status cmds.
	SEND_MSCP_MSG			; Send message to remote MSCP server.

	IF_MSCP	SUCCESS, then=SENSEMODE_ONLINE  ; Branch if GTUNT successful.
	MOVZWL	#SS$_MEDOFL,R0		; Mark final I/O status.
	BRB	SENSEMODE_RETURN	; And branch around.

SENSEMODE_ONLINE:

	BSBW	RECORD_GETUNIT_CHAR	; Copy data from End Message to UCB.
	MOVZWL	#SS$_NORMAL, R0		; Setup successful completion status.

SENSEMODE_RETURN:
	BRW	FUNCTION_EXIT
	.PAGE
	.SBTTL	START_READPBLK and START_WRITEPBLK and START_WRITECHECK

; START_READPBLK - Prepare an MSCP packet to do a READ command.
;
; START_WRITEPBLK - Prepare an MSCP packet to do a WRITE command.
;
; START_WRITECHECK - Prepare an MSCP packet to do a COMPARE HOST DATA command.
;
; INPUTS:
;	R2 => MSCP buffer
;	R3 => UCB
;	R4 => PDT
;	R5 => CDRP
;
;	MSCP packet is zero except for MSCP$L_CMD_REF and MSCP$W_UNIT fields.
;

	.enable	lsb
START_WRITECHECK:

	MOVB	#MSCP$K_OP_COMP,-	; Compare host data opcode
		MSCP$B_OPCODE(R2)	;  to packet.
	BBC	#IO$V_REVERSE,-		; Branch around if NOT reverse.
		CDRP$W_FUNC(R5),20$
	BISW	#MSCP$M_MD_REVRS,-	; Else set reverse modifier.
		MSCP$W_MODIFIER(R2)
	BRB	20$			; And branch around to join common code

START_WRITEPBLK:

	MOVB	#MSCP$K_OP_WRITE,-	; Transfer WRITE opcode
		MSCP$B_OPCODE(R2)	;  to packet.
	BRB	10$

START_READPBLK:

	MOVB	#MSCP$K_OP_READ,-	; Transfer READ opcode
		MSCP$B_OPCODE(R2)	;  to packet.

	BBC	#IO$V_REVERSE,-		; Branch around if NOT reverse.
		CDRP$W_FUNC(R5),10$
	BISW	#MSCP$M_MD_REVRS,-	; Else set reverse modifier.
		MSCP$W_MODIFIER(R2)
10$:

	BBC	#IO$V_DATACHECK,-	; See if user specified compare in
		CDRP$W_FUNC(R5),20$	;  addition to data transfer. If not, branch.
	ASSUME	MSCP$V_MD_COMP GE 8	; Else, set the read/write with
	BISB	#<MSCP$M_MD_COMP@-8>, -	; data compare modifier.
		MSCP$W_MODIFIER+1(R2)
20$:
	IF_IVCMD then=70$		; Branch if invalid command processing.

	MOVAB	CDRP$T_LBUFHNDL(R5),-	; Put address of Local BUFfer HaNDLe
		CDRP$L_LBUFH_AD(R5)	;  field into field that points to it.
	MAP_IRP				; Allocate mapping resources and load
					;  them with data from SVAPTE, BOFF,
					;  and BCNT derived from IRP within
					;  CDRP.

	MOVL	CDRP$L_MSG_BUF(R5),R2	; Refresh R2 => MSCP packet.
70$:	MOVQ	CDRP$T_LBUFHNDL(R5),-	; Copy contents of buffer handle to
		MSCP$B_BUFFER(R2)	;  MSCP buffer descriptor field.
	MOVL	CDRP$T_LBUFHNDL+8(R5),-	; Buffer handle is 96 bits (12 bytes)
		MSCP$B_BUFFER+8(R2)	;  in length.
	MOVL	CDRP$L_BCNT(R5),-
		MSCP$L_BYTE_CNT(R2)	; Copy byte count of transfer.

	IF_IVCMD then=XFER_IVCMD_END	; Branch if invalid command processing.

	.enable lsb			; Start a new local symbol block.

	SEND_MSCP_MSG			; Send message to remote MSCP server.

	ASSUME	MT$V_BOT  GE 16
	ASSUME	MT$V_EOF  GE 16
	ASSUME	MT$V_EOT  GE 16
	ASSUME	MT$V_LOST GE 16
	BICB	#<<MT$M_BOT ! MT$M_EOF -; Clear position sensitive DEVDEPEND
		 ! MT$M_EOT -		; bits.
		 ! MT$M_LOST> @ -16>, -
		UCB$L_DEVDEPEND+2(R3)

	DO_ACTION	TRANSFER	; Decode MSCP end status.
	ACTION_ENTRY	SUCC,  SS$_NORMAL,	TRANSFER_RTN_RECLEN
	ACTION_ENTRY	PRESE, SS$_SERIOUSEXCP,	TRANSFER_PRESE
	ACTION_ENTRY	ABRTD, SS$_ABORT,	TRANSFER_RTN_BCNT
	ACTION_ENTRY	ICMD,  SS$_CTRLERR,	TRANSFER_INVALID_COMMAND
	ACTION_ENTRY	COMP,  SS$_DATACHECK,	TRANSFER_COMPERR
	ACTION_ENTRY	OFFLN, SS$_MEDOFL,	TRANSFER_MEDOFL
	ACTION_ENTRY	AVLBL, SS$_MEDOFL,	TRANSFER_MEDOFL
	ACTION_ENTRY	TAPEM, SS$_ENDOFFILE,	TRANSFER_EOF
	ACTION_ENTRY	BOT,   SS$_ENDOFFILE,	TRANSFER_BOT
	ACTION_ENTRY	PLOST, SS$_CTRLERR,	TRANSFER_PLOST
	ACTION_ENTRY	RDTRN, SS$_DATAOVERUN,	TRANSFER_RTN_RECLEN
	ACTION_ENTRY	DATA,  SS$_PARITY,	TRANSFER_DATA_ERROR
	ACTION_ENTRY	HSTBF, SS$_IVBUFLEN,	TRANSFER_HOST_BUFFER_ERROR
	ACTION_ENTRY	CNTLR, SS$_CTRLERR,	TRANSFER_CTRLERR
	ACTION_ENTRY	FMTER, SS$_CTRLERR,	TRANSFER_RTN_BCNT
	ACTION_ENTRY	DRIVE, SS$_DRVERR,	TRANSFER_RTN_BCNT
	ACTION_ENTRY	WRTPR, SS$_WRITLCK,	TRANSFER_RTN_BCNT
	ACTION_ENTRY	END_TABLE

	BRW	INVALID_STS		; Unexpected MSCP end status.

XFER_IVCMD_END:
	BRB	TRANSFER_IVCMD_END	; Branch assist.


TRANSFER_PLOST:
	ASSUME	MT$V_LOST GE 16
	BISB	#<MT$M_LOST @ -16>, -	; Set position LOST DEVDEPEND bit.
		UCB$L_DEVDEPEND+2(R3)
	BRB	300$			; Join common code.
TRANSFER_EOF:
	ASSUME	MT$V_EOF  GE 16
	BISB	#<MT$M_EOF @ -16>, -	; Set EOF DEVDEPEND position bit.
		UCB$L_DEVDEPEND+2(R3)
	BRB	300$			; Join common code.
TRANSFER_BOT:
	ASSUME	MT$V_BOT  GE 16
	BISB	#<MT$M_BOT @ -16>, -	; Set BOT DEVDEPEND position bit.
		UCB$L_DEVDEPEND+2(R3)
; -----	BRB	300$			; Join common code.

300$:	CLRL	R1			; Set zero bytes transfered.
	BRW	TRANSFER_SHIFT		; Branch around.

TRANSFER_PRESE:

	CLRL	R1			; R1 = number of bytes transferred.
	ASHQ	#-16,R0,R0		; Shift into proper position for IOSB.
	BRW	FUNCTION_EXIT		; Complete function immedately.

TRANSFER_CTRLERR:
	EXTZV	#MSCP$S_ST_MASK,-	; Extract the sub-code only.
		#16-MSCP$S_ST_MASK,-
		MSCP$W_STATUS(R2),R1
	CMPW	#MSCP$K_SC_DLATE,R1	; Compare to Data Late error.
	BNEQ	25$			; Branch around if not Data Late.
	MOVL	#SS$_DATALATE@16,R0	; Set SS$_DATALATE into high word.
25$:	BRW	TRANSFER_SHIFT		; Branch to common code.

TRANSFER_INVALID_COMMAND:

	IVCMD_BEGIN			; Begin invalid command processing.
	BRW	TU_BEGIN_IVCMD		; Rebuild fatal MSCP command.
TRANSFER_IVCMD_END:
	IVCMD_END			; Complete invalid command processing.
	BRB	300$			; Complete the function.

TRANSFER_MEDOFL:

	BBC	#MSCP$V_SC_INOPR,-	; Branch around if NOT unit inoperative
		MSCP$W_STATUS(R2),-	;  substatus.
		TRANSFER_RTN_BCNT
	MOVL	#SS$_DRVERR@16,R0	; Else set up R0 with proper SS$_ code
					;  in high order word and
	BRB	TRANSFER_RTN_BCNT	; Branch around.
TRANSFER_HOST_BUFFER_ERROR:

	EXTZV	#MSCP$S_ST_MASK,-	; Extract the sub-code only.
		#16-MSCP$S_ST_MASK,-
		MSCP$W_STATUS(R2),R1
	CMPW	#MSCP$K_SC_ODDBC,R1	; Compare to Odd Byte Count error.
	BEQL	TRANSFER_RTN_BCNT	; Branch around if Odd BCNT.
	BRW	INVALID_STS		; Here we got an invalid MSCP status.

TRANSFER_DATA_ERROR:			; TRANSFER action routine for MSCP$K_ST_DATA.

TRANSFER_COMPERR:
TRANSFER_RTN_BCNT:
TRANSFER_RTN_RECLEN:			; Common TRANSFER action routine.
					; Here R0 contains SS$_ code in hi order..
	MOVL	MSCP$L_BYTE_CNT(R2),R1	; Get # bytes actually transferred.

TRANSFER_SHIFT:

	ASHQ	#-16,R0,R0		; Shift into proper position for IOSB.

NORMAL_TRANSFEREND:

	BBC	#MSCP$V_EF_EOT, -	; Is tape in the EOT region?
		MSCP$B_FLAGS(R2), 65$	; Branch if tape not in EOT.
	ASSUME	MT$V_EOT  GE 16
	BISB	#<MT$M_EOT @ -16>, -	; Else, set EOT DEVDEPEND position bit.
		UCB$L_DEVDEPEND+2(R3)
65$:	BLBC	R0, 70$			; Branch if already returning an error.
	CMPW	#<MSCP$M_SC_EOT -	; Was a EOT subcode returned on a
		 +MSCP$K_ST_SUCC>, -	; success command status?
		MSCP$W_STATUS(R2)
	BNEQ	70$			; Branch if not EOT.
	MOVW	#SS$_ENDOFTAPE, R0	; Else, return EOT status.

70$:	TSTL	UCB$L_RECORD(R3)	; Previously at BOT?
	BNEQ	75$			; Branch if not previously at BOT.
	BISB	#CDRP$M_DENSCK, -	; Else, set density check required flag.
		CDRP$L_DUTUFLAGS(R5)
75$:	MOVL	MSCP$L_POSITION(R2), -	; Update tape position information.
		UCB$L_RECORD(R3)

; -----	BRB	FUNCTION_EXIT		; Go to common exit code.

	.disable	lsb
	.PAGE
	.SBTTL	FUNCTION_EXIT

; FUNCTION_EXIT - 
;
; INPUTS:
;	R0 => Final I/O status
;	R3 => UCB
;	R4 => PDT
;	R5 => CDRP
;


FUNCTION_EXIT:

	.IF	DF	TU_TRACE
	BSBW	TRACE_STATUS		; Trace status.
	.ENDC

	MOVL	CDRP$L_MSG_BUF(R5),R2	; R2 => end message.
	BEQL	20$			; EQL implies no buffer.
	BBS	#MSCP$V_EF_ERLOG,-	; Branch around if error log
		MSCP$B_FLAGS(R2),10$	;  message generated.
	BBC	#CDRP$V_ERLIP, -	; If no ERLOG flag in End Message and
		CDRP$L_DUTUFLAGS(R5), - ;  no remembered ERLIP, branch around.
		20$
10$:	BICW	#CDRP$M_ERLIP, -	; Clear error log in progress bit.
		CDRP$L_DUTUFLAGS(R5)
	JSB	G^ERL$LOGSTATUS		; Go log software status for errorlog.

20$:	MOVL	R0, CDRP$L_IOST1(R5)	; Save final I/O status in CDRP.
	.IF	DF	TU_SEQCHK
	BSBB	SEQ_ENDCHECK		; Check sequence on end.
	.ENDC
	BBCC	#CDRP$V_DENSCK, -	; Branch if density check not required
		CDRP$L_DUTUFLAGS(R5), -	; and clear required flag.
		30$
	; Use a Set Unit Characteristics command to get the current density of 
	; the tape.  SUC is used instead of Get Unit Status because SUC is a 
	; sequential command.  This affords a better chance of coordinating 
	; with controller attempts to determine the density.  (Specificially, 
	; the HSC50 needs a sequential command here.)
	RESET_MSCP_MSG			; Else, setup to send another MSCP cmd.
	MOVB	#MSCP$K_OP_STUNT, -	; Make that command a set unit 
		MSCP$B_OPCODE(R2)	; characteristics command.
	MOVW	UCB$W_UNIT_FLAGS(R3), -	; Must provide current unit flags
		MSCP$W_UNT_FLGS(R2)	; for SUC.
	MOVL	UCB$L_MSCPDEVPARAM(R3),-; Must also provide device dependent
		MSCP$L_DEV_PARM(R2)	; parameters for SUC.
	SEND_MSCP_MSG			; Send the command.
	IF_MSCP	FAILURE, then=30$	; Skip is get unit status failed.
	BBS	#MSCP$V_EF_PLS, -	; Skip if correct tape position is
		MSCP$B_FLAGS(R2), 30$	; not known.
	ASSUME	MT$V_DENSITY GE 8	; Otherwise, clear out previous 
	BICB	#<MT$M_DENSITY @ -8>, - ; density information.
		UCB$L_DEVDEPEND(R3)
	MOVZWL	MSCP$W_FORMAT(R2), R0	; Get MSCP density value.
	BSBW	MSCPTOVMS_DENS		; Convert density to VMS format.
	INSV	R0, #MT$V_DENSITY, -	; Store VMS density in UCB.
		#MT$S_DENSITY, -
		UCB$L_DEVDEPEND(R3)

30$:	BSBW	DUTU$DEALLOC_ALL	; Free resources owned by this CDRP.

	MOVL	CDRP$L_IOST1(R5), R0	; Restore final I/O status.
	MOVL	UCB$L_DEVDEPEND(R3),R1	; Return to user I/O status block.
	MOVL	UCB$L_CDDB(R3),R2	; R2 => CDDB.
	BBC	#CDDB$V_SNGLSTRM,-	; See if in one at a time CDRP mode.
		CDDB$W_STATUS(R2),100$	;  If NOT branch around PUSHAB which
					;  allows us to regain control after
					;  ALT_REQCOM.
	PUSHL	R2			; Save R2 => CDDB for after ALT_REQCOM.
	PUSHL	R4			; Likewise save R4 => PDT.
	PUSHAB	110$			; Push address to which to return after
					;  ALT_REQCOM.
100$:
	ALT_REQCOM
110$:
	POPL	R4			; Restore R4 => PDT.
	POPL	R3			;  And R3 => CDDB.
	BRW	RESTART_NEXT_CDRP	; Branch to code to restart next CDRP.

	.IF	DF	TU_SEQCHK
;+
; SEQ_ENDCHECK - routine to check that commands end in sequence.
;
; Inputs:
; R0 => Final I/O status
; R3 => UCB
; R5 => CDRP
;
; Outputs:
;	All registers preserved.

SEQ_ENDCHECK:
	PUSHL	R0			; Save R0 for later restore.
	BBSC	#UCB$V_TU_OVRSQCHK,-	; Branch around and clear bit if
		UCB$W_DEVSTS(R3),10$	;  override specified.
	EXTZV	#IRP$V_FCODE,-		; Extract I/O function code.
		#IRP$S_FCODE,-
		CDRP$W_FUNC(R5),R0
	BBC	R0,SEQ_MASK,10$		; If non-Sequential I/O branch around.
	CMPW	(SP),#SS$_ABORT		; Is this an aborted command?
	BEQL	50$			; Branch if aborted command.
	EXTZV	#0,-			; Extract six bit index into array of
		#6,-			;  IRP sequence number slots.  R0 =
		UCB$B_TU_OLDINX(R3),R0	;  index of oldest slot.
	INCB	UCB$B_TU_OLDINX(R3)	; Increment index.
	CMPL	CDRP$L_SEQNUM(R5),-	; Compare sequence number of this IRP to
		UCB$L_TU_SEQARY(R3)[R0]	;  oldest outstanding sequence number.
	BNEQ	99$			; Branch if terminating out of sequence.
10$:	POPL	R0			; Restore R0.
	RSB				; Return to caller.

	; Process canceled, aborted command.
50$:	BSBW	REMOVE_SEQARY		; Remove aborted command from list of 
					;  commands.
	BRB	10$			; Then exit this routine.

99$:	BUG_CHECK	TAPECLASS,FATAL	; Sequential command has been lost.
	.ENDC
	.PAGE
	.SBTTL	re-CONNECTION after VC error or failure

; TU$CONNECT_ERR - Block of code invoked during the time that we
;	re-CONNECT to the intelligent controller following some disturbance
;	that caused dismanteling of the logical CONNECTION between the
;	class driver and the controller.  The ultimate purpose of the code
;	here is to locate all CDRP's relevant to this controller and place
;	them in the proper order into CDDB$L_RSTRTQFL.  Once
;	all the CDRP's are on this list we "execute" each of these CDRP's, one
;	by one, until they are all done.  When the last such CDRP is completed
;	we resume normal QIO processing.  This code works in cooperation with
;	code in FUNCTION_EXIT.
;
;	We are invoked here either by the Port Driver calling us at our error
;	entry point or by the Disk Class Driver branching here as a result of
;	deciding that the intelligent controller has gone "insane".
;
;	The actions herein taken are the following:
;
;	1.  We disable the Timeout Mechanism Routine wakeups by placing a
;		longword of all 1's in CRB$L_DUETIME.
;
;	2.  In order to prevent new CDRP's from starting up, we increment
;		UCB$W_RWAITCNT for each UCB associated with this controller.
;		This count is used to count the number of CDRP's associated
;		with a UCB that have run into resource wait situations.
;		Whenever this count is non-zero, new CDRP's are automatically
;		backed up onto the UCB$L_IRPQFL queue.  Incrementing this
;		count here, insures that it will not be run to zero and will
;		cause all new CDRP's to backup.
;
;	3.  We deallocate resources owned by the permanent CDRP used by the
;		Timeout Mechanism Routine.
;
;	4.  At the time that we are called here, our active CDRP's can be
;		found in one of the following places:
;
;		a) On the HIRT wait Q.  If here note that the associated UCB
;		   RWAITCNT has been bumped due to being on this list in
;		   addition to the bump given in step 2 above.
;
;		b) On the RDT resource wait Q.  Here also RWAITCNT has been
;		   bumped once to many times.
;
;		c) On the CDDB$L_CDRPQFL.  Here RWAITCNT is normal except for
;		   the bump given in step 1.
;
;		d) On some other resource wait Q (Flow control, message buffer,
;		   mapping resources, etc.). Here again RWAITCNT has been bumped
;		   once to much.
;
;		e) On the CDDB$L_RSTRTQ.  If here, the CONNECTION has failed
;		   while we were in the middle of cleaning up a previous
;		   CONNECTION failure.  The CDRP's here need no further
;		   gathering.
;
;		Our aim here is to gather all the active CDRP's onto the
;		CDDB$L_RSTRTQ.  To do this we search for them in the above
;		mentioned places in the order in which they were mentioned.
;		This order is important as will be explained below.
;
;	5.  Note here that at the time of the call to TU$CONNECT_ERR, we
;		may have been on the middle of MOUNT VERIFICATION.  In such
;		a case the particular volume would have been marked as
;		invalid and during re-CONNECTION we would not try to bring
;		the unit online.  Also we would have a set of inactive
;		(i.e. no resources allocated for them) CDRP'a (IRP's) on
;		the MOUNT VERIFICATION QUEUE of the UCB and possibly one
;		MOUNT VERIFICATION specific CDRP active.  This all meshes
;		perfectly with our re-CONNECTION design.  The contents of
;		the MOUNT VERIFICATION QUEUE can be ignored.  The active
;		MOUNT VERIFICATION CDRP will be treated normally.  Its
;		I/O will be retried and will probably fail and MOUNT
;		VERIFICATION will re-submit it and it will wind up on the
;		normal UCB I/O QUEUE awaiting the RWAITCNT's going to zero.
;		After re-CONNECTION, it will start up normally and everything
;		should resume transparently.
;
;	6.  First we scan the HIRT wait Q and remove any CDRP's associated
;		with the current CDDB.  We do this first so that if perchance,
;		some of our CDRP's are here, they will not be selected
;		inadvertantly when the current HIRT owner is possibly killed.
;
;		This scan is done by going down the entire HIRT wait Q and
;		removing the 1st entry of ours that we find.  If in a pass
;		we DO remove an entry , then we go bask and scan from the
;		start of the Q.  When we make an entire pass without any hits,
;		we finish.  Note that when we remove an entry, we decrement
;		the RWAITCNT prior to calling INSERT_RSTRTQ to undo the bump
;		we gave in calling LOCK_HIRT.
;
;	7.  We scan the RDT resource wait Q.  Again we scan until we find our
;		first entry and after a removal we begin to scan from the
;		beginning.  Only a clean scan wnds the process.  Also we
;		must decrement RWAITCNT for each removal.
;
;	8.  We REMQUE each entry on CDDB$L_CDRPQFL and call INSERT_RSTRTQ
;		for each one.
;
;	9.  Here we should note that INSERT_RSTRTQ deallocates all resources
;		owned by a CDRP prior to inserting it in CDDB$L_RSTRTQ.
;		Because of this, the only CDRP's belonging to us that still
;		own RSPID's are the CDRP's which are on other resource wait
;		queues.  So here we scan the RDT looking for entries that
;		belong to us.  When we find one we REMQUE it, decrement its
;		RWAITCNT and call INSERT_RSTRTQ for it.  Note that this
;		deallocates its resources and as a result of this could cause
;		another of our CDRP's to receive these resources and proceed
;		up to the CDDB$L_CDRPQFL.  Therefore after a removal here,
;		we branch back to step 7 to safeguard against this possibility.
;		A complete scan of the RDT with no hits implies that we now
;		have gathered all our CDRP's and that we can continue.
;
;*********************************************************************
;	9.  If the two counts above are equal, then we have all CDRP's on
;		CDDB$L_RSTRTQFL.  No more CDRP's will trickle in so we clear
;		CDDB$M_CDRPTRCKL in CDDB$W_STATUS.
;
;	10. We DISCONNECT the now dead connection and then re-CONNECT to
;		establish a new channel to the MSCP server in the controller.
;
;	11. We are now ready to begin single stream execution of CDRPs, until
;		exhaust the contents of the CDRP$L_RSTRTQFL.  However we
;		want to guard against the possibility that a particular
;		request (i.e. CDRP) may repeatedly hang a controller (i.e.
;		cause a re-CONNECTION) and thereby prevent anything from
;		getting through.  To deal with this we only retry a given
;		request a fixed maximum number of times (MAX_RETRY).  The
;		algorithm which resolves this retry logic dilemma relies
;		on several data items in the CDDB:
;
;			a) CDDB$L_RSTRTCDRP - the address of the CDRP that is
;			    currently being processed in single stream mode if
;			    we are in single stream mode.
;
;			b) CDDB$B_RETRYCNT - the number of remaining retries
;			    for the current CDRP being processes in single
;			    stream mode if we are in single stream mode.
;
;			c) CDDB$V_SNGLSTRM - bit in CDDB$W_STATUS which tells
;			    us if we are in single stream mode.
;
;		The algorithm is as follows: If upon selecting the first CDRP
;		on CDDB$L_RSTRTQFL, we find CDDB$V_SNGLSTRM clear, we merely
;		set it and we can be assurred that this is the first time
;		that we are attempting to retry this request in single stream
;		mode.  This is so because the bit being clear implies either
;		that this is the first re-CONNECTION since the system came up
;		or that the last re-CONNECTION ran to completion thereby leaving
;		the bit clear.  In this case we select this first CDRP, set
;		CDDB$B_RETRYCNT to the maximum and establish this CDRP as the
;		current one by storing its address in CDDB$L_RSTRTCDRP.
;
;		If however CDDB$V_SNGLSTRM is set upon selecting a CDRP, we
;		must compare the CDRP address to the current value of
;		CDDB$L_RSTRTCDRP.  If they are NOT equal, then again this is
;		the first retry attempt for this CDRP and we merely set the
;		CDDB$B_RETRYCNT to the maximum and store the CDRP in
;		CDDB$L_RSTRTCDRP.  If the CDRP has the same address however,
;		we must decrement one from the retry count and if it is not
;		exhausted attempt to process the CDRP again.
;
;		Note this all works even though the address of a CDRP is not
;		necessarily unique. That is, many I/O requests in the life of
;		the system may occupy the same CDRP in virtual space.  However,
;		once re-CONNECTION logic begins, it deals only with the CDRPs
;		on the CDDB$L_RSTRTQFL.  This list never grows until re-
;		CONNECTION is run to completion since all new IRPs are
;		being backed up.  Therefore even though we may run repeated
;		re-CONNECTIONs that do not run to completion but rather each
;		causes the connection to go down, through all this the
;		CDDB$L_RSTRTQFL is always monotonically decreasing and no
;		new CDRPs are entered onto it that were not there at the time
;		that we began to process the first re-CONNECTION.  In a fixed
;		list of CDRPs which all exist at the same time, the address
;		is a unique descriptor.
;
;	12. Note that CDDB$M_SNGLSTRM in CDDB$W_STATUS acts as a flag to
;		FUNCTION_EXIT so that it can aid in the one at a time re-
;		execution of the CDRP's.
;
;	13. For debugging sake, we loop thru all UCB's and check that their
;		UCB$W_RWAITCNT values are all equal to 1.
;		Also for debugging sake we check that CDDB$L_CDRPQFL is
;		empty.
;
;	14. We REMQUE the 1st CDRP on CDDB$L_RSTRTQFL and branch to
;		TU_RESTARTIO to begin its execution.
;
; Inputs: (for TU$RE_SYNCH)
;	R3 => CRB


TU$RE_SYNCH:

	MOVL	CRB$L_AUXSTRUC(R3),R3	; R3 => CDDB.
	MOVL	CDDB$L_PDT(R3),R4	; R4 => PDT.
	CMPB	#MSCP$K_CM_EMULA, -	; If this is the MSCP server, the right
		CDDB$B_CNTRLMDL(R3)	; resynch technique is DISCONNECT.
	BEQL	RECONN_COMMON		; So, skip the MRESET setup.
	BISW	#CDDB$M_RESYNCH,-	; Signal that we should reset
		CDDB$W_STATUS(R3)	;  intelligent controller.
	BRB	RECONN_COMMON		; Branch around to common code.

; Inputs: (for TU$CONNECT_ERR)
;	R3 => CDT
;	R4 => PDT
;

TU$CONNECT_ERR:

	MOVL	CDT$L_AUXSTRUC(R3),R3	; R3 => CDDB.
RECONN_COMMON:
	INCW	CDDB$W_RSTRTCNT(R3)	; Count number of times reconnected.
	BICW	#<CDDB$M_IMPEND -	; Signal: no immediate command pending
		 !CDDB$M_INITING -	; 	  out of initialization
		 !CDDB$M_SNGLSTRM -	; 	  no single stream in progress
		 !CDDB$M_RSTRTWAIT>,-	;	  not waiting to restart CDRPs
		CDDB$W_STATUS(R3)

	MOVL	CDDB$L_CRB(R3),R0	; R0 => CRB.
	MNEGL	#1,CRB$L_DUETIME(R0)	; Prevent Timeout Mechanism wakeups.

	BISW	#CDDB$M_RECONNECT,-	; Set bit meaning that we are in
		CDDB$W_STATUS(R3)	;  the re-CONNECTING state.

	SUBL3	#<UCB$L_CDDB_LINK -	; Get "previous" UCB address in R1.
		 -CDDB$L_UCBCHAIN>, -
		R3, R1

10$:	MOVL	UCB$L_CDDB_LINK(R1), R1	; Chain to next UCB (if any).
	BEQL	20$			; EQL implies no more UCB's here.
	BBSS	#UCB$V_MSCP_WAITBMP, -	; Only bump RWAITCNT once.  If already
		UCB$W_DEVSTS(R1), 10$	;  bumped, branch back.
	INCW	UCB$W_RWAITCNT(R1)	; Prevent new CDRP's from starting up.
	BRB	10$			; Go look for more UCB's.
20$:

;
; Now we are sure that no new CDRP's will start.
;

	BSBW	DUTU$DISCONNECT_CANCEL	; Perform disconnect cancel cleanup.

; Deallocate RSPID & message buffer on each of the CDDB perm. IRP/CDRP pairs.

	MOVAB	CDDB$A_DAPCDRP(R3), R5	; Get DAP permanent CDRP address.
	BSBW	DUTU$DEALLOC_RSPID_MSG	; Deallocate its RSPID & msg. buf.
	MOVAB	CDDB$A_PRMCDRP(R3), R5	; Get permanent CDRP address.
	BSBW	DUTU$DEALLOC_RSPID_MSG	; Deallocate its RSPID & msg. buf.

;
;	Registers here are:
;		R3 => CDDB
;		R4 => PDT.
;

; Locate and prepare for restarting all CDRPs currently waiting for a RSPID.
; Since the class driver allocates a RSPID as the first step in any function,  
; CDRPs found now will not be holding any resources and will not be active.  
; Since these CDRPs hold no resources, their cleanup will not cause any other 
; waiting requests to become active.  (This fact is not currently used, but it 
; might be useful.)

	MOVL	CDDB$L_CDT(R3), R3		; Get CDT address.

	CLRL	R1				; Set SCAN_RSPID_WAIT flag.
	SCAN_RSPID_WAIT -			; Use SCS service to scan RSPID
		action = DUTU$RECONN_LOOKUP	; wait queue.
						; DUTU$RECONN_LOOKUP is in
						; DUTUSUBS.

; Remove all CDRPs on the active requests queue.  These CDRPs:
;   a. have outstanding requests in the intelligent controller, 
;   b. suffered allocation failures due to a broken connection,
;   c. represent the request during which an "insane" controller was detected.
; In any case, these CDRPs are not on any resource wait queue and do not have 
; their associated resource wait count bumped due to need for a resource.

	BSBW	DUTU$DRAIN_CDDB_CDRPQ		; Cleanup active requests.

; Now scan the entire Response-id Descriptor Table for any remaining CDRPs 
; belonging to this connection.  Presumably these CDRPs are on a resource wait 
; queue somewhere.  In addtion, releasing whatever resources such CDRPs hold 
; may cause other waiting CDRPs to become active.  Therefore, after every CDRP 
; is located and processed, the active CDRP queue must be scanned again.

	INCL	R1				; Set SCAN_RDT flag.
	SCAN_RDT -				; Use SCS service to scan RDT.
		action = DUTU$RECONN_LOOKUP	; DUTU$RECONN_LOOKUP is in
						; DUTUSUBS.

	MOVL	CDT$L_AUXSTRUC(R3), R3		; Restore the CDDB address.

RESTART_FIRST_CDRP:

;
; We come here either by falling thru from above code or by branching here
;	from CALL_SEND_MSG_BUF when the last CDRP has trickled in.
;
;
; If here all CDRP's are in CDDB$L_RSTRTQFL.  So no more will trickle.
;	Clear bit that prevents CALL_SEND_MSG_BUF from doing its job.
;
; INPUTS:
;	R3 => CDDB
;	R4 => PDT
;


;
; Here we DISCONNECT the old connection.
;

	MOVAB	CDDB$A_PRMCDRP(R3),R5	; Put R5 => CDRP for coming BSBWs.
	MOVL	R3,R0			; R0 => CDDB.
	MOVL	CDRP$L_CDT(R5),R3	; Set R3 => CDT.
	BISW	#CDDB$M_NOCONN, -	; Set no connection active flag.
		CDDB$W_STATUS(R0)
	BBCC	#CDDB$V_RESYNCH,-	; Do NOT branch around if we were called
		CDDB$W_STATUS(R0),2$	;  in order to re-synchronize.
	MOVL	CDT$L_PB(R3),R3		; R3 => Path Block for MRESET, etc.
	MRESET	PB$B_RSTATION(R3),#1	; Force controller to reset itself.
	MSTART	PB$B_RSTATION(R3)	; And force controller to restart itself.
	RSB				; Kill this thread. Rely on Port
					;  Driver calling error routine as
					;  a result of MRESET to accomplish
					;  DISCONNECT and subsequent logic.
2$:
	DISCONNECT	#DISCONNECT_REASON

	PERMCDRP_TO_CDDB -		; Get CDDB address in R3.
		cdrp=R5, cddb=R3

;
; Deallocate mapping resources 
; and queue mount verification requests for post processing
; <<< The mount verification references have been commented out in the	>>>
; <<< following lines.  This driver does not do mount verification.	>>>
; <<< When it is taught to do mount verification, however, the comment-	>>>
; <<< ed lines MUST be restored.					>>>
;

	; Any mapping resources still owned by CDRPs on the restart queue are 
	; deallocated here.  This deallocation is delayed until after the 
	; DISCONNECT (and possible MRESET) to prevent an "insane" controller 
	; from continuing to transfer via possibly re-allocated mapping 
	; resources.  The mount verification queueing is delayed because the 
	; mount verification operation may be holding mapping resources.

	PUSHAB	CDDB$L_RSTRTQFL(R3)	; Setup listhead address.
	PUSHL	CDDB$L_RSTRTQFL(R3)	; Setup first CDRP address.

4$:	POPL	R5			; Get next CDRP address.
	CMPL	R5, (SP)		; Is it the listhead?
	BEQL	6$			; If yes, all deallocations are done.
	BSBW	DUTU$DEALLOC_ALL	; Free MAP resources owned by this CDRP.
	PUSHL	(R5)			; Push next CDRP address.
;<<<	BBC	#IRP$V_MVIRP, -		; Is this a mount verification IRP?
;<<<		CDRP$W_STS(R5), 4$	; Branch if not an MV IRP.
;<<<	REMQUE	(R5), R0		; Else, remove IRP/CDRP from restart
;<<<	POST_CDRP status=SS$_MEDOFL	; queue and send it to post processing.
	BRB	4$			; Loop till all restart CDRPs are done.

6$:	TSTL	(SP)+			; Clear listhead pointer from stack.

	; Deallocate mapping resources whose description is stored in the 
	; CDDB permanent CDRP.  This information was placed there by 
	; DUTU$INSERT_RESTARTQ when it discovered that the HIRT permanent CDRP 
	; owned mapping resources.  In this way, another thread is allowed to 
	; use the HIRT permanent CDRP while this connection is broken.

	MOVAB	CDDB$A_PRMCDRP(R3), R5	; Get CDRP in R5.
	BSBW	DUTU$DEALLOC_ALL	; Free old HIRT MAP resources.
					;  the HIRT CDRP and whose ownership
					;  has been transferred here.


;
; re-CONNECT - Here we call an internal subroutine which:
;
;	1. Makes a connection to the MSCP server in the intelligent
;		controller.
;
;	2. Sends an MSCP command to SET CONTROLLER CHARACTERISTICS.
;
;	3. Allocates an MSCP buffer and RSPID for our future use in
;		connection management.
;
; Upon return R4 => PDT and R5 => CDRP.
;

	BSBW	MAKE_CONNECTION		; Call subroutine to connect.

	PERMCDRP_TO_CDDB -		; Get CDDB address in R3.
		cdrp=R5, cddb=R3
	MOVL	CDDB$L_CRB(R3),R0	; Get CRB address.
	MOVAB	W^TU$TMR, -		; Establish permanent timeout routine.
		CRB$L_TOUTROUT(R0)
	MOVZWL	CDDB$W_CNTRLTMO(R3), R1	; Get controller timeout interval.
	ADDL3	R1, G^EXE$GL_ABSTIM, -	; Use that to set next timeout 
		CRB$L_DUETIME(R0)	; wakeup time.

	; The normal MSCP timeout mechanism is now in effect.  Henceforth,
	; no fork thread may use the CDDB permanent CDRP as a fork block.

	ASSUME	CDDB$V_DAPBSY GE 8
	BISB	#<CDDB$M_DAPBSY @ -8>, -; Set DAP CDRP in use flag.
		CDDB$W_STATUS+1(R3)
	MOVL	CDDB$L_DAPCDRP(R3), R5	; Get DAP CDRP address.
	BSBW	DUTU$POLL_FOR_UNITS	; Interrogate controller, poll for units.
					;   Returns R3 => CDDB, R5 => CDRP.

	; Now it is necessary to propogate all the connection dependent 
	; information regarding the newly formed connection to the MSCP server 
	; to all the UCB's in the primary chain for this CDDB.  At the same 
	; time, every RWAITCNT value is tested to insure that it is consistant 
	; with what would be expected based upon the various possible reasons 
	; which cause it to be bumped.  This is merely a debugging exercise.  
	; In END_SINGLE_STREAM, RWAITCNT will be reduced by one and the wait 
	; count bumped flag will be cleared.

	; This loop also brings previously valid units online, an activity 
	; which would be performed by mount verification if it existed.

	; This loop also initializes previously uninitialized trace tables.  
	; This must be performed after the call to DUTU$POLL_FOR_UNITS.

	MOVAB	<CDDB$L_UCBCHAIN -	; Setup "previous" UCB address.
		-UCB$L_CDDB_LINK>(R3), -
		R5
15$:	MOVL	UCB$L_CDDB_LINK(R5), R5	; Link to next UCB.
	BEQL	30$			; Branch if no more UCBs to test.
	BSBW	DUTU$INIT_CONN_UCB	; Setup connection dep. UCB fields.
	.IF	DEFINED TU_TRACE
	BSBW	TRACE_INIT		; Init IRP trace table.
	.ENDC
	BSBW	DUTU$CHECK_RWAITCNT	; Validate the wait count value.
	BBC	#UCB$V_VALID, -		; If unit is not valid, all done
		UCB$L_STS(R5), 15$	; for now.
	BSBW	BRING_UNIT_ONLINE	; Else, bring the unit back online.
	BRB	15$			; Loop through all UCBs.

30$:	; If this driver performed mount verification, it would now be 
	; possible to execute requests on behalf of any pending mount 
	; verification threads.  Therefore, the CDDB$V_NOCONN bit is 
	; cleared here.
	;
	; Since all threads which use the DAP CDRP as a fork block are now 
	; completed, that block may now be used for DAP operations.  
	; Therefore, the DAP CDRP busy flags is cleared too.

	BICW	#<CDDB$M_NOCONN -	; Clear no-connection and 
		 !CDDB$M_DAPBSY>, -	; DAP-CDRP-busy flags.
		CDDB$W_STATUS(R3)

	; Processing of the first CDRP in the restart queue is about to begin. 
	; The queue of active requests should be empty:  check it.  N.B. if 
	; volume revalidation were being performed by mount verification, the 
	; active request queue might not be empty and it would be necessary to 
	; synchronize with mount verification activities as is done in the 
	; disk class driver.

	ASSUME	CDDB$L_CDRPQFL EQ 0
	CMPL	(R3), R3		; Empty listheads point to themselves.
	BEQL	RESTART_NEXT_CDRP	; EQL implies that all is correct.
	BUG_CHECK	TAPECLASS,FATAL


RESTART_NEXT_CDRP:

;
; Here we attempt to initiate the first (i.e. next) CDRP on the restart queue.
;	In order to prevent getting caught in an infinite loop trying to
;	initiate an operation that the controller cannot complete for
;	one reason or another, we maintain a retry count and the address
;	of the CDRP that we are currently single streaming.
;
;	In the normal case this is an isolated re-CONNECTION and the
;	first CDRP on the restart queue is a random CDRP.  We notice this
;	by seeing that the address of our first CDRP is not equal to the
;	current contents of CDDB$L_RSTRTCDRP.
;
;	In the other case the connection failed while we were in single
;	stream mode and the CDRP which we happened to be processing is the
;	same CDRP that now heads our restart queue.  In this case, before
;	initiating the processing of this CDRP, we decrement 1 from the
;	retry count and if it remains non-zero, we restart the CDRP
;	processing.  If the decrementing results in a zero retry count,
;	then we log the event and effectively abort the CDRP by branching to
;	FUNCTION_EXIT with an appropriate error status.  FUNCTION_EXIT, due
;	to the setting of the CDDB$M_SNGLSTRM bit will then start the
;	processing of the next CDRP on the restart queue.
;
; We can arrive here either by falling through from the above code or via
;	a branch from FUNCTION_EXIT.  In either case we have:
;
; INPUT:
;	R3 => CDDB
;

	REMQUE	@CDDB$L_RSTRTQFL(R3),R5	; R5 => 1st CDRP on restart queue.
	BVS	END_SINGLE_STREAM	; VS implies restart was empty.
	BBCS	#CDDB$V_SNGLSTRM,-	; Set bit and if clear, this is 1st
		CDDB$W_STATUS(R3),20$	;  time here for this CDRP, so branch.
	CMPL	R5,CDDB$L_RSTRTCDRP(R3)	; See if same CDRP as last time.
	BNEQ	20$			; NEQ implies not the same.
	DECB	CDDB$B_RETRYCNT(R3)	; If same, decrement 1 from retries.
	BNEQ	30$			; NEQ implies retries remaining.

;
; *******************************Log this error.******************************
;

	MOVL	#SS$_CTRLERR,R0		; Indicate appropriate error status.
	CLRL	R1			;  And set second part of I/O status.
	MOVL	CDRP$L_UCB(R5),R3	; R3 => UCB.
	BRW	FUNCTION_EXIT
20$:
	MOVL	R5,CDDB$L_RSTRTCDRP(R3)	; Establish new single stream CDRP.
	MOVB	#MAX_RETRY,-		; Establish fresh retry count.
		CDDB$B_RETRYCNT(R3)
30$:
	MOVL	CDRP$L_UCB(R5),R3	; R3 => UCB.
	BRW	TU_RESTARTIO		; Restart the CDRP.


END_SINGLE_STREAM:

;
; Here we want to resume normal operation and get each unit going.
;	To do this we pickup each UCB in turn and call SCS$UNSTALLUCB
;	for it.  This has the effect of starting up as many (perhaps all)
;	of the IRP's (that's right IRP's) as possible that may have
;	backed up on the UCB input queue while we were in single stream mode.
;	We then go on to the next UCB until we exhaust all UCB's connected
;	to this CDDB.
;

	BICW	#CDDB$M_SNGLSTRM, -	; Clear single streaming CDRPs flag.
		CDDB$W_STATUS(R3)
	MOVZWL	CDDB$W_RSTRTCNT(R3), R0	; Get current restart count.
	MOVAB	<CDDB$L_UCBCHAIN -	; Setup "previous" UCB address.
		-UCB$L_CDDB_LINK>(R3), -
		R5

10$:	MOVL	UCB$L_CDDB_LINK(R5), R5	; Point to next UCB.
	BEQL	30$			; Branch if no more UCBs to process.
	BICW	#UCB$M_MSCP_WAITBMP, -	; Indicate RWAITCNT no longer bumped.
		UCB$W_DEVSTS(R5)
	DECW	UCB$W_RWAITCNT(R5)	; Unbump wait count.
	BSBW	DUTU$CHECK_RWAITCNT	; Else, check wait count and
	PUSHR	#^M<R0,R3>		; Save restart cnt. and CDDB address.
	JSB	G^SCS$UNSTALLUCB	; Start up IRPs on UCB.
	POPR	#^M<R0,R3>		; Restore restart cnt. and CDDB address.
	CMPW	R0, CDDB$W_RSTRTCNT(R3)	; Did the unstall cause a restart?
	BEQL	10$			; Branch if no restart was caused.
	RSB				; Else, discontinue this thread.

30$:	BICW	#CDDB$M_RECONNECT, -	; Clear reconnect in progress bit.
		CDDB$W_STATUS(R3)
	RSB				; Ta De, Ta De, that's all folks.
	.PAGE
	.SBTTL	TU$TMR - Class Driver Timeout Mechanism Routine

;+
; TU$TMR - Time out Mechanism Routine.  This routine is called
;  periodically whenever CRB$L_DUETIME becomes due.  At the time of a
;  periodic call to TU$TMR the Class Driver is in one of three states
;  with respect to the intelligent mass storage controller associated
;  with the CRB pointed at by R3.
;
;	1. State #1, the "normal" state for which this routine is optimized,
;	    is characterized by the following two conditions:
;
;		a) One or more MSCP commands are outstanding to the controller.
;		    This is determined by having a NON-empty queue of CDRP's
;		    hanging off the CDDB.
;
;		b) The oldest outstanding command was initiated since the
;		    previous invocation of TU$TMR and is therefore not very
;		    old.  This is determined by comparing the RSPID of the
;		    currently oldest command to the RSPID of the oldest request
;		    at the time of the previous invocation.  If they are not
;		    equal then we are in State #1.
;
;	2. State #2 is characterized by having NO outstanding MSCP commands in
;	    the controller.  This is determined by finding an empty CDRP queue
;	    in the CDDB.
;
;	3. State #3 is the state where MSCP commands are outstanding and the
;	    oldest one has been outstanding for at least one previous TU$TMR
;	    invocation.
;
;  If we determine that we are in state #1, we simply record the RSPID of the
;   currently oldest outstanding MSCP command in CDDB$L_OLDRSPID and we initial-
;   ize CDDB$L_OLDCMDSTS to all 1's.  We then calculate a new due time,
;   place it in CRB$L_DUETIME and return to our caller, which results
;   in scheduling ourselves for the next invocation of TU$TMR.
;
;  States #2 and #3 share some common code.  In both cases we will issue an
;   IMMEDIATE command to the controller but for diverse reasons.  In the case
;   of state #2 it will be an effective NOP command that is only issued to
;   insure against the controller timing out the host (i.e. us) due to lack of
;   activity on our part.  In the case of state #3, the IMMEDIATE command will
;   be a "GET COMMAND STATUS" for the oldest outstanding MSCP command.
;
;  The common code they share consists of code to appropriate the pre-allocated
;   MSCP buffer pointed at by CDRP$L_MSG_BUF and to pick up the pre-allocated
;   RSPID identified by CDRP$L_RSPID.  BOth these items are located in
;   the permanent CDRP which is appended to the CDDB of this intelligent
;   controller.  Also at this time a new due time is calculated prior to
;   doing the DRIVER_SEND_MSG so that we will be able to time out the
;   Immediate command.  Then the code for these two states diverges for
;   a while to prepare distinct MSCP packets, do the SEND_MSG_BUF,
;   and in the case of state #3, to do some specific processing upon
;   receipt of the END PACKET for the IMMEDIATE command.  This processing
;   consists of insuring that the command status returned in the END PACKET
;   indicates progress being made on the oldest outstanding command; and also
;   of saving this received command status in the CDDB$L_OLDCMDSTS so as to
;   have it available at the next invocation, if this oldest command is still
;   outstanding.  Following this the two code paths converge to recycle the
;   received END PACKET for use as the next IMMEDIATE MSCP buffer and to also
;   recycle the RSPID by bumping its sequence number.
;
; INPUTS:
;	R3 => CRB of the intelligent disk controller
;
; OUTPUTS:
;	Registers R0 through R5 are all possibly modified.
;

TU$TMR:
	SETIPL	#IPL$_SCS		; After wakeup lower IPL.
	MOVL	CRB$L_AUXSTRUC(R3),R1	; R1 => CDDB.

	ASSUME	CDDB$L_CDRPQFL   EQ   0
	CMPL	(R1),R1			; If =, then list of CDRP's is empty
	BEQL	20$			; EQL means empty list of CDRP's,
					;  which implies we are in State #2.
	MOVL	(R1),R0			; R0 => CDRP associated with "oldest"
					;  outstanding MSCP command.

	CMPL	CDRP$L_RSPID(R0),-	; Compare RSPID of oldest request to
		CDDB$L_OLDRSPID(R1)	;  that of request current at time of
					;  previous invocation of TU$TMR.
	BEQL	30$			; EQL implies State #3, i.e. current
					;  oldest has been around for awhile.

	MOVL	CDRP$L_RSPID(R0),-	; State #1, we have a NEW oldest request
		CDDB$L_OLDRSPID(R1)	;  so record its RSPID in CDDB field.
	MNEGL	#1,CDDB$L_OLDCMDSTS(R1)	; And initialize its associated status.
10$:
	MOVZWL	CDDB$W_CNTRLTMO(R1),-(SP); Pickup controller delta.
	ADDL3	(SP)+,-			 ; Calculate delta time for next
		G^EXE$GL_ABSTIM,-	;  periodic invocation of TU$TMR.
		CRB$L_DUETIME(R3)
	RSB				; And return to caller.

20$:					; If we are here, there are NO outstand-
					;  ing requests in the controller since
					;  CDRP list is empty.
	CLRL	R0			; R0 flagged to indicate State #2.
	CLRL	CDDB$L_OLDRSPID(R1)	; Set to impossible value to prevent
					;  inadvertent comparison error.

30$:					; Common State #2, State #3 code path.
					; If here, for sure we will be issuing
					;  an immediate command to the controller.
					;  If we are in State #2, it will be a
					;  "GET UNIT STATUS" (NOP) command but
					;  if we are in State #3, it will be
					;  a "GET COMMAND STATUS" command.  For
					;  either case we begin the common setup.


	MOVL	CDDB$L_PDT(R1),R4	; Setup for SEND_MSG_BUF, R4=>PDT.
	MOVAB	CDDB$A_PRMCDRP(R1),R5	; R5 => CDRP appended to CDDB.
	BBCS	#CDDB$V_IMPEND,-	; Branch if an immediate command is NOT
		CDDB$W_STATUS(R1),40$	;  pending. Also set bit to show that
					;  one WILL be pending momentarily.
	BRW	TU$RE_SYNCH		; Bit set implies that an immediate
					;  "GET STATUS" type command has not
					;  completed in the timeout interval.
					;  So we goto resynchronization logic.

40$:
	MOVQ	R0, -(SP)		; Save valuable registers.
	INIT_MSCP_MSG			; Initalize buffer for MSCP message.
	MOVQ	(SP)+, R0		; Restore valuable registers.

	BSBB	10$			; Establish due time so as to be able
					;  to timeout Immediate command.
	TSTL	R0			; Test for State #2 or State #3.
	BNEQ	50$			; NEQ implies State #3. Branch to handle it.

; State #2 specific code.
; Here we prepare the MSCP packet for the "GET UNIT STATUS" command for
;	unit #0, which is an effective NOP command.  This is done to
;	maintain minimum activity so that the controller will not time
;	out the host (i.e. us). NOTE that since the MSCP buffer has been
;	cleared above, there is no need to specify unit #0 in the command
;	buffer.
;

	MOVB	#MSCP$K_OP_GTUNT,-	; Move in "GET UNIT STATUS" opcode.
		MSCP$B_OPCODE(R2)

	SEND_MSCP_MSG DRIVER		; Here we call to send the MSCP packet
					;  to the intelligent disk controller.

					; Return is experienced here after
					;  receipt of the END PACKET correspond-
					;  ing to the MSCP NOP sent above.  We
					;  regain control due to a callback
					;  from our own INPUT DISPATCHER
					;  ROUTINE.  Passed to us at this call-
					;  back are R2 => END PACKET, R3 => CRB,
					;  R4 => PDT and R5 => CDRP.
					; All we want to do is recycle the
					;  END PACKET for use as our next MSCP
					;  packet and recycle the RSPID.
					;  To do this we branch to common code.
	BRB	70$

50$:

; State #3 specific code.
; Here we prepare the MSCP packet for a "GET COMMAND STATUS" command.

	MOVL	CDRP$L_UCB(R0),R0	; R0 => UCB for oldest outstanding request.

	MOVW	UCB$W_MSCPUNIT(R0),-	; Setup UNIT field.
		MSCP$W_UNIT(R2)
	MOVB	#MSCP$K_OP_GTCMD,-	; Setup OPCODE field.
		MSCP$B_OPCODE(R2)

	MOVL	CDDB$L_OLDRSPID(R1),-	; Setup OUTSTANDING COMMAND REFERENCE
		MSCP$L_OUT_REF(R2)	;  field.

	SEND_MSCP_MSG DRIVER		; Here we call to send the MSCP packet
					;  to the intelligent disk controller.

					; We experience return here upon receipt
					;  of the END PACKET for the above "GET
					;  COMMAND STATUS" command. We must make
					;  sure that progress has indeed been
					;  made on the outstanding command.  We
					;  therefore compare the outstanding
					;  command status returned in the END
					;  PACKET to the previous value in CDDB
					;  field CDDB$L_OLDCMDSTS.
					; Here R2=>END PACKET, R3=>CRB, R4=>PDT
					;  and R5=>CDRP.

	MOVL	CRB$L_AUXSTRUC(R3),R1	; R1 => CDDB.
	CMPL	MSCP$L_CMD_STS(R2),-	; Compare received outstanding command
		CDDB$L_OLDCMDSTS(R1)	;  status to previous value.
	BLSSU	60$			; LSSU implies progress made so branch.
	BNEQ	55$			; If not equal, progress went the 
					;  wrong direction; a sure sign of 
					;  an insane controller.
	CMPL	#-1, MSCP$L_CMD_STS(R2)	; If equal to last time, is this the
					;  multi-host busy somewhere else value?
	BEQL	60$			; Branch if it is busy somewhere else.
55$:	BRW	TU$RE_SYNCH		; Anything else, implies no progress
					;  has been made.  So we goto
					;  re-synchronize with the intelligent
					;  disk controller and re-issue all
					;  outstanding commands.

60$:
	MOVL	MSCP$L_CMD_STS(R2),-	; Remember this received outstanding
		CDDB$L_OLDCMDSTS(R1)	;  command status for next time.

70$:					; States #2 and #3 code paths merge here.
	RECYCH_MSG_BUF		; Recycle END PACKET.
	RECYCL_RSPID			; Likewise the RSPID.

	MOVL	CRB$L_AUXSTRUC(R3),R1	; R1 => CDDB.
	BICW	#CDDB$M_IMPEND,-	; Indicate that immediate command is
		CDDB$W_STATUS(R1)	;  no longer pending.
	BRW	DUTU$DODAP		; Continue by doing DAP processing.
	.PAGE
	.SBTTL	TU$IDR - Class Driver Input Dispatch Routine

;+
; TU$IDR - Class Driver Input Dispatching Routine.  This routine is to
;	the class driver what the Interrupt Service Routine is to a
;	conventional driver.  We are called here by the Port Driver
;	and we are passed the address of an END PACKET or an ATTENTION
;	MESSAGE buffer.  By testing a bit in the ENDCODE field of the
;	received buffer we determine which of the two has been received.
;	For ATTENTION MESSAGES we immediately branch to ATTN_MSG.
;
;	For END PACKETs we first determine if the END PACKET is still of
;	interest.  This is done by testing whether the COMMAND REFERENCE
;	NUMBER returned in the END PACKET, interpreted as a RSPID, is
;	still valid.  If not, we merely deallocate the END PACKET and
;	return to our caller in the Port Driver.
;
;	If the END PACKET is still of interest then before dispatching
;	to the code that originally issued the MSCP command for which we
;	have just received the END PACKET, we first remove the
;	CDRP associated with the command from the list of active CDRP's
;	defined by the listhead located at CDDB$L_CDRPQFL.
;
; INPUTS:
;	R1 =  Message Length
;	R2 => END PACKET or ATTENTION MESSAGE BUFFER
;	R3 => Connection Data Block
;-

TU$IDR:
	BBC	#MSCP$V_OP_END,-	; Is this an ATTENTION MESSAGE
		MSCP$B_OPCODE(R2),-	;  or an END PACKET;
		ATTN_MSG		;  bit clear implies ATTENTION.


;
; Process command END MESSAGES
;

	PUSHL	R1			; Save message size.
	MOVL	MSCP$L_CMD_REF(R2), R5	; Get RSPID from end message.
	FIND_RSPID_RDTE			; Lookup RDTE for RSPID.
	POPL	R1			; Restore message size.
	BLBC	R0, FINISHED_WITH_MESSAGE ; Branch if error in RSPID.
	MOVL	RD$L_CDRP(R5),R5	; R5 => CDRP.
	MOVL	CDRP$L_CDT(R5),R0	; R0 => CDT.
	MOVL	CDT$L_AUXSTRUC(R0),R0	; R0 => CDDB.
	CMPL	CDDB$L_OLDRSPID(R0),-	; See if oldest outstanding command has
		MSCP$L_CMD_REF(R2)	;  this Command Reference Number.
	BNEQ	20$			; If not, branch around.
	CLRL	CDDB$L_OLDRSPID(R0)	; Prevent inadvertent timeouts due to
					;  reuse of RSPID in error situations.
20$:	ASSUME	MSCP$K_LEN LT 32767
	MOVW	R1, CDRP$W_ENDMSGSIZ(R5); Save length of incomming packet.
	MOVL	R2, CDRP$L_MSG_BUF(R5)	; Save address of incomming packet.

	REMQUE	(R5),R5			; Remove R5=>CDRP from list.
	ASSUME	CDRP$V_CAND EQ 0
	BLBS	CDRP$L_DUTUFLAGS(R5), -	; Has request been canceled?
		30$			; If so, do cancel completion work.
23$:	BBS	#IRP$V_DIAGBUF, -	; Branch out of line if a diagnostic
		CDRP$W_STS(R5), 50$	; buffer was supplied.

25$:	MOVQ	CDRP$L_FR3(R5), R3	; Restore fork registers, R3 & R4.
	JMP	@CDRP$L_FPC(R5)		; Dispatch to issuer of MSCP command
					;  who will return to our caller.

30$:	BSBW	DUTU$TEST_CANCEL_DONE	; If this request completes a cancel
					; operation, cleanup that operation.
	BRB	23$			; Branch back to normal flow.

50$:	BSBW	DUTU$DUMP_ENDMESSAGE	; If diagnostic buffer, record MSCP
					; end message sent in the buffer.
	BRB	25$			; Branch back to normal flow.



;
; Process ATTENTION MESSAGES
;

ATTN_MSG:
	PUSHR	#^M<R1,R2,R3,R4>	; Save vital registers.
	MOVL	CDT$L_AUXSTRUC(R3), R3	; Get CDDB address.
	PUSHAB	B^EXIT_ATTN_MSG		; Make DISPATCH look like a BSBx.
	DISPATCH -			; Dispatch to attention message 
		MSCP$B_OPCODE(R2), -	;  specific processing:
		type=B, prefix=MSCP$K_OP_, < -
		<AVATN, UNIT_AVAILABLE_ATTN>, -
		<DUPUN, DUPLICATE_UNIT_ATTN>, -
		<ACPTH, ACCESS_PATH_ATTN>, -
		>
INV_ATTN_MSG:				; Process invalid ATTENTION MESSAGE.
	TSTL	(SP)+			; Pop "return" address.
	MOVZWL	#EMB$C_INVATT, R0	; Invalid attention message type.
	JSB	G^ERL$LOG_TMSCP		; Log incorrect TAPE MSCP message.
	POPR	#^M<R1,R2,R3,R4>	; Restore vital registers.
	DEALLOC_MSG_BUF_REG		; Deallocate ATTN MSG buffer.
	MOVL	CDT$L_AUXSTRUC(R3), R3	; Get CDDB again.
	MOVL	CDDB$L_CRB(R3), R3	; From that get the CRB address.
	BRW	TU$RE_SYNCH		; Re-synchronize with controller.

EXIT_ATTN_MSG:
	POPR	#^M<R1,R2,R3,R4>	; Restore vital registers.
FINISHED_WITH_MESSAGE:
	DEALLOC_MSG_BUF_REG		; Deallocate ATTN MSG buffer.
	RSB				; Return to SCS caller.
	.PAGE
	.SBTTL Attention Message Processing
	.SBTTL   - Process Unit Available Attention Message

;++
;
; Functional Description:
;
;	This routine processes unit available attention messages.  If the
;	available unit is already known in the I/O database, no action is 
;	taken.  If the available unit represents a second path to an already 
;	known unit, the I/O database is altered to show the alternate path 
;	availability.  If the available unit represents a totally new device, 
;	it is added to the I/O database.
;
; Inputs:
;
;	R1	attention message size
;	R2	attention message address
;	R3	CDDB address
;
; Outputs:
;
;	R0 - R5 destroyed
;	All other registers preserved
;--

UNIT_AVAILABLE_ATTN:

	BBS	#CDDB$V_POLLING, -	; Is a poll for units in progress?
		CDDB$W_STATUS(R3), 90$	; Branch if poll for units active.
	BSBW	DUTU$NEW_UNIT		; Process possible new unit.
	.IF	DEFINED TU_TRACE
	MOVL	R2, R5			; Copy UCB address.
	BSBW	TRACE_INIT		; Initialize IRP trace table.
	.ENDC
90$:	RSB
	.PAGE
	.SBTTL   - Process Duplicate Unit Attention Message

;++
;
; Functional Description:
;
;	This routine processes duplicate unit attention messages.
;	Notification of the condition is sent to the operator's console and 
;	an entry is made in the error log.  If the unit described in the 
;	message cannot be found, an invalid MSCP message error log entry is 
;	generated.
;
; Inputs:
;
;	R1	attention message size
;	R2	attention message address
;	R3	CDDB address
;
; Outputs:
;
;	R0 - R5 destroyed
;	All other registers preserved
;--

	.ENABLE LSB

DUPLICATE_UNIT_ATTN:

	BSBW	DUTU$LOOKUP_UCB		; Locate UCB for this message.
	MOVL	R0, R3			; Setup UCB address.
	BEQL	90$			; If no UCB found, ignore the message.
	BSBW	DUTU$SEND_DUPLICATE_UNIT; Send message to operator.
	MOVZWL	#EMB$C_DUPUN, R0	; Setup duplicate unit error log code.

LOG_ATTENTION_MESSAGE:
	JSB	ERL$LOGMESSAGE		; Error log attention message.
90$:	RSB

	.DISABLE LSB
	.PAGE
	.SBTTL   - Process Access Path Attention Message

;++
;
; Functional Description:
;
;	This routine processes access path attention messages.  If the access 
;	path represents a second path to an already known unit, the I/O 
;	database is altered to show the alternate path availability, and an 
;	entry is made in the error log indicating receipt of the message.
;	If the unit described in the message cannot be found, an invalid MSCP 
;	message error log entry is generated.
;
; Inputs:
;
;	R1	attention message size
;	R2	attention message address
;	R3	CDDB address
;
; Outputs:
;
;	R0 - R5 destroyed
;	All other registers preserved
;--

ACCESS_PATH_ATTN:

	BSBW	DUTU$SETUP_DUAL_PATH	; Process possible dual path unit.
	MOVL	R0, R3			; Get UCB address.
	BEQL	90$			; If no UCB found, ignore the message.
	RSB				; Return w/o logging message, but
					; leave message logging code in place
					; just in case its needed.
	MOVZBL	#EMB$C_ACPTH, R0	; Setup ERL$LOGMESSAGE code.
	BRB	LOG_ATTENTION_MESSAGE	; Join common log message path.
90$:	RSB				; If no UCB, exit.
	.PAGE
	.SBTTL	TU$DGDR	- Data Gram Dispatch Routine
;
; Inputs:
;
;	R1 =  length of datagram
;	R2 => datagram
;	R3 => CDT
;	R4 => PDT

TU$DGDR:

	MOVL	CDT$L_AUXSTRUC(R3),R0	; R0 => CDDB
	MOVL	R3,R5			; Save pointer to CDT.
	SUBL3	#<UCB$L_CDDB_LINK -	; Get "previous" UCB address in R3.
		 -CDDB$L_UCBCHAIN>, -
		R0, R3

10$:	MOVL	UCB$L_CDDB_LINK(R3), R3	; Chain to next UCB (if any).
	BEQL	20$			; No more UCBs.
	CMPW	UCB$W_MSCPUNIT(R3),-	; See if datagram (error log packet)
		MSCP$W_UNIT(R2)		;  for this unit.
	BNEQ	10$			; If not, branch abck to try next unit.
	MOVZWL	#EMB$C_TM,R0		; Put type of message into R0.
	JSB	G^ERL$LOGMESSAGE	; And call to log message.
20$:
	MOVL	R5,R3			; Restore R3 => CDT.
	SUBL	PDT$L_DGOVRHD(R4),R2	; R2 => SCS header of datagram.
	QUEUE_DG_BUF			; Requeue datagram buffer.
	RSB				; Return to port.
	.PAGE
	.SBTTL	INVALID_STS

;+
; We come here if we get an invalid MSCP status.  We log the MSCP message
; and then RE-SYNCH the controller.
;
; Inputs:
;	R2 => MSCP packet
;	R3 => UCB
;	R4 => PDT
;	R5 => CDRP
;	CDRP$W_ENDMSGSIZ(R5) => length of MSCP packet with invalid status
;

INVALID_STS:

	MOVZWL	#EMB$C_INVSTS,R0	; Indicate type of record to log.
	MOVZWL	CDRP$W_ENDMSGSIZ(R5), R1; Pickup length of faulty packet.
	MOVL	UCB$L_CDDB(R3),R3	; R3 => CDDB for logging error.
	JSB	G^ERL$LOG_TMSCP		; Log tape MSCP error.
	BSBW	DUTU$INSERT_RESTARTQ	; Queue CDRP for retry.
	MOVL	CDDB$L_CRB(R3),R3	; R3 => CRB for re-SYNCH.
	BRW	TU$RE_SYNCH		; Zap controller.
	.PAGE
	.SBTTL	TU_UNSOLNT

TU_UNSOLNT:
	BUG_CHECK	TAPECLASS,FATAL


	.IIF	DEFINED TU_TRACE, .PAGE
	.IF	DEFINED	TU_TRACE
	.SBTTL	IRP Tracing Routines
	.SBTTL	- TRACE_INIT - Initialize trace table
;++
;
; TRACE_INIT - Initialize trace table
;
; Functional Description:
;
;	If the trace table is not initialized, initialize it.
;
; Inputs:
;
;	R5	UCB address.
;
; Implicit Inputs:
;
;	UCB$W_DEVSTS(R5)	UCB$V_TU_TRACEACT set if the trace table is 
;				initialized
;
; Outputs:
;
;	All registers preserved.
;
; Implicit Outputs:
;
;	UCB$W_DEVSTS(R5)	UCB$V_TU_TRACEACT is set if the trace table is 
;				successfully initialized
;	UCB$L_TRACEBEG(R5)	address of first IRP trace slot
;	UCB$L_TRACEPTR(R5)	address of first free IRP trace slot
;	UCB$L_TRACEND(R5)	address of first byte after IRP trace slots
;--

TRACE_SLOTS = 50			; Number of trace slots
TRACE_SIZE = 96				; Size of a trace slot
TRACE_TBLSIZ = TRACE_SLOTS * TRACE_SIZE	; Size of the trace table

	ASSUME	IRP$L_ARB+8 LE TRACE_SIZE
	ASSUME	<TRACE_SIZE & ^X1F> EQ 0

IRP$L_TU_TRCPTR = IRP$K_CD_LEN		; Define a place to hold pointer to 
CDRP$L_TU_TRCPTR = CDRP$K_CD_LEN	; trace slot

	ASSUME	IRP$L_TU_TRCPTR+4 LE IRP$K_LENGTH
	ASSUME	CDRP$L_TU_TRCPTR-CDRP$L_IOQFL EQ IRP$L_TU_TRCPTR

TRACE_INIT:

	BBS	#UCB$V_TU_TRACEACT, -	; Branch if tracing is already
		UCB$W_DEVSTS(R5), 90$	; initialized.
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	; Save registers.
	MOVZWL	#<TRACE_TBLSIZ+16>, R1	; Get size of the trace table w/ header.
	JSB	G^EXE$ALONONPAGED	; Attempt to allocate pool.
	BLBC	R0, 80$			; Branch if allocation failed.
	CLRQ	(R2)+			; Initialize trace table header for SDA.
	MOVW	R1, (R2)+		; Save size.
	MOVW	#DYN$C_CLASSDRV, (R2)+	; Type.
	CLRL	(R2)+			; Round header upto 16 byte boundary.
	MOVL	R2, UCB$L_TRACEBEG(R5)	; Save pointer to base of trace table.
	MOVL	R2, UCB$L_TRACEPTR(R5)	; Pointer to next area to use.
	ADDL3	#TRACE_TBLSIZ, R2, -	; Pointer to beyond end of trace table.
		UCB$L_TRACEND(R5)
	BISW	#UCB$M_TU_TRACEACT, -	; Indicate Trace table inited.
		UCB$W_DEVSTS(R5)
	MOVC5	#0, (SP), #0, -		; Zero trace table.
		#TRACE_TBLSIZ, (R2)

80$:	POPR	#^M<R0,R1,R2,R3,R4,R5>	; Restore registers.
90$:	RSB				; Return
	.PAGE
	.SBTTL	- TRACE_IRP - Trace incomming IRP
;++
;
; TRACE_IRP - Trace incomming IRP
;
; Functional Description:
;
;	Called as a part of start I/O processing, this routine allocates a new 
;	IRP trace slot and copies starting IRP contents into that slot.
;
;	IRP trace slots are 96 bytes long so that they line up nicely in
;	a dump.
;
; Inputs:
;
;	R3	IRP address
;	R5	UCB address
;
; Implicit Inputs:
;
;	UCB$W_DEVSTS(R5)	UCB$V_TU_TRACEACT set if IRP trace slots have 
;				been allocated
;	UCB$L_TRACEPTR(R5)	address of first free IRP trace slot
;	UCB$L_TRACEND(R5)	address of first byte after IRP trace slots
;	UCB$L_TRACEBEG(R5)	address of first IRP trace slot
;
; Outputs:
;
;	All registers preserved.
;
; Implicit Outputs:
;
;	UCB$L_TRACEPTR(R5)	updated
;	IRP$L_TU_TRCPTR(R3)	Address of IRP trace slot (for TRACE_STATUS)
;--

TRACE_IRP:

	BBC	#UCB$V_TU_TRACEACT, -	; If trace table not intialized,
		UCB$W_DEVSTS(R5), 20$	; exit immediately.
	MOVQ	R0, -(SP)		; Save R0 and R1.
	MOVL	R3, R0			; Get IRP to trace in R0.
	MOVL	UCB$L_TRACEPTR(R5), R1	; Get address of next free trace slot.
	CMPL	UCB$L_TRACEND(R5), R1	; Check for end of trace table.
	BGTR	10$			; Branch if not overflowed trace tbl.
	MOVL	UCB$L_TRACEBEG(R5), R1	; Else, reset to base of trace table.
10$:	ADDL3	#TRACE_SIZE, R1, -	; Setup next entry pointer.
		UCB$L_TRACEPTR(R5)

	MOVL	R1, IRP$L_TU_TRCPTR(R3)	; Save trace slot addr at end of CDRP.
	ASSUME	<TRACE_SIZE & 7> EQ 0
	.REPEAT	TRACE_SIZE / 8
	MOVQ	(R0)+, (R1)+		; Copy input IRP.
	.ENDR
	MOVL	IRP$L_TU_TRCPTR(R3), R1	; Refresh R1 to trace slot beginning.
	MOVL	R3, (R1)		; Put IRP address in trace slot.
	CLRL	4(R1)			; Clear field that will contain RSPID.
	MNEGL	#1, IRP$L_ARB(R1)	; Init field for I/O Status #1.
	MNEGL	#1, IRP$L_ARB+4(R1)	; Init field for I/O Status #2.

	MOVQ	(SP)+,R0		; Restore R0 and R1.
20$:	RSB
	.PAGE
	.SBTTL	- TRACE_STATUS - Trace final I/O request status
;++
;
; TRACE_STATUS - Trace final I/O request status
;
; Functional Description:
;
;	Copy final I/O status and RSPID into trace slot.
;
; Inputs:
;
;	R0 	I/O status first longword
;	R3 	UCB address
;	R5	CDRP address
;
; Implicit Inputs:
;
;	UCB$W_DEVSTS(R3)	UCB$V_TU_TRACEACT set if IRP trace slots have 
;				been allocated
;	CDRP$L_TU_TRCPTR(R5)	Address of IRP trace slot
;	UCB$L_DEVDEPEND(R3)	I/O status second longword
;
; Outputs:
;
;	All registers preserved.
;
; Implicit Outputs:
;
;	RSPID and final I/O status copies to IRP trace slot.
;--

TRACE_STATUS:

	BBC	#UCB$V_TU_TRACEACT, -	; If trace table not initialized
		UCB$W_DEVSTS(R3), 30$	; exit immediately.
	PUSHL	R2			; Save register.
	MOVL	CDRP$L_TU_TRCPTR(R5), R2; Get IRP trace slot address.
	MOVL	CDRP$L_RSPID(R5), 4(R2)	; Save RSPID in trace.
	MOVL	R0, IRP$L_ARB(R2)	; Save I/O status.
	MOVL	UCB$L_DEVDEPEND(R3), -	;	"
		IRP$L_ARB+4(R2)
	POPL	R2			; Restore register.
30$:	RSB				; Return to caller.

	.ENDC

	.END
