	.TITLE	INDIRECT - INDIRECT FILE MANIPULATION ROUTINES
	.IDENT	'V04-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; D. N. CUTLER 2-MAY-77
;
; INDIRECT FILE MANIPULATION ROUTINES
;
; MODIFIED BY:
;
;	V03-016	HWS0100		Harold Schultz	06-AUG-1984
;		Open any new indirect frame with Carriagecontrol
;		attributes.
;
;	V03-015	HWS0081		Harold Schultz	15-Jul-1984
;		When closing the current indirect frame and unstacking
;		the previous frame, set NAM block to not use the RSA and
;		ESA fields left by the indirect frame just closed. Using
;		these values cause the free dynamic memory list to become
;		corrupted. Add support for execute-only command procedures.
;
;	V03-014	HWS0080		Harold Schultz	12-Jul-1984
;		When allocating room in symbol table for resultant
;		name string, don't use constant of 256; use the value
;		of NAM$C_MAXRSS+1 rounded up to a long word boundry
;		instead. Remove the ASSUME of NAM$C_MAXRSS. Bypass
;		deallocation of unused buffer if none to deallocate.
;
;	V03-013	HWS0066		Harold Schultz	21-May-1984
;		Correct the error handling when a SYMOVF error is encountered
;		while setting up the new indirect level. Reenable password
;		masking after opening an indirect input file.
;
;	V03-012	HWS0015		Harold Schultz	21-Feb-1984
;		Check status after $FIND.
;		Initialize file spec. size fields in NAM block before reusing.
;		Deassign SYS$INPUT prior to reopening a file at a prior indirect
;		level.
;
;	V03-011	PCG0013		Peter George	12-Jan-1984
;		Fix broken branch.
;
;	V03-010	PCG0012		Peter George	17-Aug-1983
;		Correctly clear RMS F$SEARCH context.
;		Manage concealed logical name attribute using the new services.
;
;	V03-009	PCG0011		Peter George	27-May-1983
;		Fix bug in unstacking when restored command procedure
;		is already positioned to EOF.
;
;	V03-009	PCG0011		Peter George	27-May-1983
;		Fix bug in file name saving logic.
;		Fix bugs in SYS$OUTPUT processing.
;
;	V03-008	KRM0099		Karl Malik	29-Apr-1983
;		Disable password masking for network.
;
;	V03-007	PCG0010		Peter George	10-Apr-1983
;		Finish making remote open work.
;
;	V03-006	PCG0009		Peter George	22-Feb-1983
;		Add DCL$DEFINE_P1_TO_P8.
;		Clear FAB$M_SQO bit.
;		Clear FAB$V_NAM and FAB$W_IFI when performing
;		remote reopen.
;
;	V03-005	PCG0008		Peter George	28-Jan-1983
;		Remove reference to ONEXIT bit.
;
;	V03-004	PCG0007		Peter George	13-Jan-1983
;		Call SYS$OUTPUT routines.
;		Save name of command procedure.
;		Use saved file name spec to reopen command procedures
;		on remote nodes.
;
;	V03-003	PCG0006		Peter George	30-Dec-1982
;		Clear PRC_V_ONEXIT when unstacking.
;
;	V03-002	PCG0005		Peter George	28-Oct-1982
;		Fix CLRBIT typo.
;
;	V03-001	PCG0004		Peter George	15-Jul-1982
;		Allow execute-only command procedures.
;---

;
; MACRO LIBRARY CALLS
;
 
	PRCDEF				;DEFINE PROCESS WORK AREA
	WRKDEF				;DEFINE COMMAND WORK AREA
	PTRDEF				;DEFINE RESULT PARSE DESCRIPTOR FORMAT
	IDFDEF				;DEFINE INDIRECT FRAME OFFSETS
	PRDDEF				;PROCESS RMS DATA
	SYMDEF				;DEFINE TYPES OF SYMBOLS
	$CLIMSGDEF			;DEFINE ERROR/STATUS VALUES
	$DEVDEF				;DEFINE DEVICE CHARACTERISTIC BITS
	$FABDEF				;DEFINE FAB OFFSETS
	$RABDEF				;DEFINE RAB OFFSETS
	$LOGDEF				;DEFINE LOG OFFSETS
	$NAMDEF				;DEFINE NAM OFFSETS
	$PSLDEF				;DEFINE PROCESSOR STATUS FIELDS

;
; LOCAL SYMBOLS
;
 
SYMBOLS=8				;MAXIMUM NUMBER OF INDIRECT FILE SYMBOLS
 
;
; LOCAL DATA
;
 
	.PSECT	DCL$ZCODE,BYTE,RD,NOWRT
INPFILE:				; INPUT FILE DEFAULT NAME STRING
	.ASCII	/.COM/			;
OUTQUAL:.ASCII	/OUTPUT/		; REST OF NAME AND THE QUALIFIER
SYS_INPUT_NAME:
	.ASCIC	/SYS$INPUT/		; LOGICAL NAME FOR SYS$INPUT
LNM$PROCESS:
	.ASCIC	/LNM$PROCESS/		; PROCESS LOGICAL NAME TABLE
NLA0:	.ASCIC	/_NLA0:/		; NULL DEVICE

	.SBTTL	STACK INDIRECT FILE
;+
; DCL$STACKIND - STACK INDIRECT FILE
;
; THIS ROUTINE IS CALLED TO STACK THE CURRENT INDIRECT FILE LEVEL AND TO PARSE
; AND OPEN THE NEXT INDIRECT FILE.
;
; INPUTS:
;
;	IT IS ASSUMED THAT THE INDIRECT FILE PROCESSING FLAG IS SET.
;
; OUTPUTS:
;
;	THE CURRENT INDIRECT FILE SPECIFICATION IS SAVED ON THE INDIRECT FILE
;	STACK AND THE NEXT INDIRECT FILE IS PROCESSED.
;
;	R0 LOW BIT CLEAR INDICATES INDIRECT FILE PROCESSING FAILURE.
;
;		R0 = DCL$_ATLAST - INDIRECT FILE SPECIFICATION NOT LAST ITEM ON
;			COMMAND LINE.
;		R0 = DCL$_DEFOVF - ATTEMPT TO DEFINE MORE THAN EIGHT PARAMETERS.
;		R0 = DCL$_STKOVF - INDIRECT FILE INTERNAL STACK OVERFLOW.
;
;	R0 LOW BIT SET INDICATES SUCCESSFUL COMPLETION.
;
;		R0 = DCL$_NORMAL - NORMAL COMPLETION.
;-
 
DCL$STACKIND::					;STACK INDIRECT FILE
	BSBW	SETIND				;SET INDIRECT PROCESSING UP
	MOVAB	-<SYMBOLS*8>(SP),SP 		;ALLOCATE SPACE FOR SYMBOL DESCRIPTORS
	CLRL	-(SP)				;CLEAR COUNT OF GENERATED SYMBOLS
	DECL	WRK_L_CHARPTR(R10)		;BACK UP TO AT SIGN
10$:	BSBW	DCL$MARK			;MARK CURRENT PARSE POSITION
	MOVZBL	#PTR_K_PARAMETR,R3		;SET TOKEN CONTEXT FOR FILESPEC
	BSBW	DCL$PROCFILE			;PROCESS FILE SPECIFICATION
	BLBC	R0,15$				;IF LBC PARSE FAILURE
	BSBW	DCL$SETCHAR			;PEEK AT NEXT CHARACTER IN INPUT BUFFER
	CMPB	#^A\/\,R0			;SLASH?
	BNEQ	20$				;IF NEQ NO
	BSBW	DCL$MOVTOKN			;MOVE TERMINATOR AND GET NEXT TOKEN
	CMPL	R1,#4				;MORE THAN MAX MATCH NAME
	BLSS	13$				;BR IF NO
	MOVL	#4,R1				;ONLY CHECK FOR 4 CHARS
13$:	PUSHL	R0				;SAVE TERMINATION CHARACTER
	CMPC	R1,(R2),OUTQUAL			;CHECK FOR VALID QUAL
	BEQL	14$				;BR IF OK
	POPL	R0				;RESTORE TERMINATION CHARACTER
	STATUS	IVQUAL				;SET ILLEGAL QUALIFIER CODE
	BRB	15$				;
14$:	POPL	R0				;RESTORE TERMINATION CHARACTER
	CMPB	#^A/=/,R0			;EQUAL SIGN TERMINATOR?
	BEQL	10$				;IF EQL YES
	CMPB	#^A/:/,R0			;COLON TERMINATOR?
	BEQL	10$				;IF EQL YES
	STATUS	IVVALU				;SET INVALID VALUE SYNTAX
15$:	BRW	80$				;
 
;
; FILE SPECIFICATIONS PARSED - PARSE SYMBOL DEFINITIONS
;
; IF THE FILESPEC WAS FOLLOWED BY A SPACE, THAT SPACE MAY HAVE BEEN THROWN
; AWAY IF THE FIRST CHARACTER IN P1 MAKES IT INSIGNIFICANT.
;
20$:	MOVAB	4(SP),R8			;GET ADDRESS OF SYMBOL DESCRIPTOR STORAGE
	BSBW	DCL$SETNBLK			;IGNORE BLANKS AFTER FILESPEC
30$:	BSBW	DCL$MARK			;MARK POSITION OF FIRST NON-BLANK
40$:	BSBW	DCL$MOVCHAR			;COPY A CHARACTER FROM INPUT BUUFER
	BBS	#WRK_V_QUOTE,-			;LOOP IF IN A QUOTED STRING
		WRK_W_FLAGS(R10),40$ 		;
	BEQL	45$				;BR IF END OF LINE
	CMPB	#^A' ',R0			;IS THIS A TERMINATOR
	BNEQ	40$				;BR IF NO - KEEP LOOKING FOR TERMINATOR
45$:	BSBW	DCL$MARKEDTOKEN			;GET DESCRIPTOR OF PARAMETER
	DECL	R1				;REMOVE COUNT FOR TERMINATOR
	BEQL	60$				;IF NULL STRING - NO MORE SYMBOLS
	CMPB	#^A/"/,(R2)			;SYMBOL START WITH A QUOTE
	BNEQ	50$				;IF NO - LEAVE THE SYMBOL ALONE
	BSBW	DCL$COMPRESS			;ELSE REMOVE THE QUOTE PAIRS
50$:	MOVQ	R1,(R8)+			;STORE SYMBOL DESCRIPTOR
	AOBLEQ	#SYMBOLS,(SP),30$		;ANY MORE SYMBOL DEFINITIONS ALLOWED?
	STATUS	DEFOVF				;SET SYMBOL DEFINITION OVERFLOW
	BRB	80$				;
 
;
; RUN DOWN ANY IMAGE CURRENTLY RUNNING
;
60$:	PUSHL	WRK_L_RSLNXT(R10)		;SAVE POINTER INTO WRK AREA
	BSBW	DCL$RUNDOWN			;RUN DOWN IMAGE AND INDIRECT LEVELS
	SUBL3	(SP)+,WRK_L_RSLNXT(R10),R0 	;CALCULATE LENGTH OF STACK SHIFT
	ADDL	R0,<<SYMBOLS*8>+4+<9*4>>(SP)  	;RELOCATE SAVED WRK_L_RSLNXT
	ADDL	R0,<<SYMBOLS*8>+4+<10*4>>(SP) 	;RELOCATE SAVED WRK_L_RSLEND
	ADDL	R0,<<SYMBOLS*8>+4+<11*4>>(SP) 	;RELOCATE SAVED WRK_L_EXPANDPTR
	ADDL	R0,<<SYMBOLS*8>+4+<12*4>>(SP) 	;RELOCATE SAVED WRK_L_MARKPTR

;
; STACK COMMAND PROCEDURE
;
	MOVL	<<SYMBOLS*8>+4+<9*4>>(SP),-	;RETRIEVE ADDRESS OF DESCRIPTORS
		WRK_L_RSLNXT(R10) 		;
	BSBW	DCL$GETDVAL			;GET INPUT FILE DESCRIPTOR VALUES
	MOVQ	R1,-(SP)			;SAVE INPUT FILESPEC
	CLRL	R4				;ASSUME NO OUTPUT FILESPEC
	BSBW	DCL$GETDVAL			;GET OUTPUT FILESPEC
	BLBC	R0,65$				;IF NONE, PASS IN NULL FILESPEC
	MOVQ	R1,R4				;SET OUTPUT FILESPEC ARGUMENT
65$:	MOVQ	(SP)+,R2			;SET INPUT FILESPEC ARGUMENT
	CLRL	R1				;SIGNAL ALL RMS ERRORS
	BSBW	DCL$PUSHPROC			;PUSH PROCEDURE ONTO INDIRECT STACK
	BLBC	R0,80$				;BRANCH IF ERROR DETECTED

;
; CREATE SYMBOLS P1-P8
;
	MOVL	(SP),R6				;GET NUMBER OF SYMBOL DEFINITIONS
	MOVAB	4(SP),R8			;GET ADDRESS OF VALUE DESCRIPTORS
	BSBB	DCL$DEFINE_P1_TO_P8		;DEFINE P1 THROUGH P8

;
; RESTORE THE STACK AND PREPARE TO EXIT
;
80$:	MOVAB	<SYMBOLS*8+4>(SP),SP 		;DEALLOCATE SYMBOL DESCRIPTOR STORAGE
	PUSHL	R0				;SAVE FINAL STATUS
	BRW	STKXIT				;

	.SBTTL	DEFINE SYMBOLS P1-P8
;+
; DCL$DEFINE_P1_TO_P8 - DEFINE SYMBOLS P1-P8
;
; THIS ROUTINE IS CALLED TO DEFINE THE LOCAL SYMBOLS P1-P8.
;
; INPUTS:
;
;	R6 = NUMBER OF SYMBOLS THAT HAVE ASSIGNED VALUES
;	R8 = ADDRESS OF LIST OF Pn VALUE DESCRIPTORS
;
; OUTPUTS:
;
;	R1-R8 TRASHED
;
;-

DCL$DEFINE_P1_TO_P8::
	MOVZWL	#^A/P0/,-(SP)			;CREATE PROTOTYPE OF GENERATED SYMBOL
	MOVL	#SYMBOLS,R7			;SET NUMBER OF SYMBOLS TO GENERATE
10$:	CLRL	R1				;ASSUME NO MORE SYMBOLS DEFINED
	DECL	R6				;ARE THERE ANY MORE TO DEFINE
	BLSS	20$				;BR IF NO - DEFINE AS NULL STRING
	MOVQ	(R8)+,R1			;GET VALUE DESCRIPTOR
20$:	INCB	1(SP)				;INCREMENT SYMBOL NUMBER
	MOVL	#2,R3				;SET LENGTH OF SYMBOL NAME
	MOVAB	(SP),R4				;SET ADDRESS OF SYMBOL NAME
	MOVAB	PRC_Q_LOCAL(R11),R5		;GET ADDRESS OF LOCAL SYMBOL TABLE LISTHEAD
	MOVL	#SYM_K_STRING,R0		;SET SYMBOL TYPE IS STRING
	BSBW	DCL$ALLOCSYM			;ALLOCATE AND INSERT SYMBOL TABLE ENTRY
	BLBC	R0,90$				;IF LBC ALLOCATION FAILURE
	SOBGTR	R7,10$				;ANY MORE SYMBOL TO PROCESS?
	STATUS	NORMAL				;SET NORMAL COMPLETION STATUS
90$:	TSTL	(SP)+				;RESTORE THE STACK
	RSB					;RETURN

	.SBTTL	PUSH PROCEDURE ONTO INDIRECT STACK
;+
; DCL$PUSHPROC - PUSH PROCEDURE ONTO INDIRECT STACK
;
; THIS ROUTINE IS CALLED TO INITIALIZE A NEW INDIRECT FRAME
; ON THE INDIRECT PROCEDURE STACK.
;
; INPUTS:
;
;	R1 = 1 IF RMS ERRORS SHOULD NOT BE SIGNALED, ELSE 0
;	R2/R3 = DESCRIPTOR OF INPUT FILESPEC
;	R4/R5 = DESCRIPTOR OF OUTPUT FILESPEC
;	R11 = ADDRESS OF PROCESS WORK AREA
;
; OUTPUTS:
;
;	R0 = STATUS (NOT SIGNALED)
;
;-

DCL$PUSHPROC::
	PUSHR	#^M<R1,R2,R3,R4,R5,R6,R7,R8,R9,AP>
	MOVL	PRC_L_STACKPT(R11),R6	;GET CURRENT INDIRECT STACK POINTER
	MOVAB	-IDF_K_LENGTH(R6),R8	;CALCULATE NEW INDIRECT STACK POINTER
	CMPL	R8,PRC_L_STACKLM(R11)	;INDIRECT STACK OVERFLOW?
	BGEQU	2$			;BRANCH IF OK
	STATUS	STKOVF			;SET INDIRECT STACK OVERFLOW
80$:	POPR	#^M<R1,R2,R3,R4,R5,R6,R7,R8,R9,AP>
	RSB
 
;
; ALLOCATE ROOM IN SYMBOL TABLE FOR RESULTANT NAME STRING PRIOR TO CLOSING
; CURRENT INDIRECT FRAME.
;

2$:	MOVL	#<<<NAM$C_MAXRSS+1>+7>&^C<7>>,R1 ;SET MAXIMUM SIZE OF
						 ;RESULTANT NAME STRING
	BSBW	DCL$ALLDYNMEM		;ALLOCATE ROOM IN THE SYMBOL TABLE	
	BLBS	R0,3$			;BR IF NO ALLOCATION ERROR
	STATUS	SYMOVF			;INDICATE NO MORE ROOM IN SYM TAB
	BRB	80$			;JUST EXIT
3$:	MOVL	R2,R9			;SAVE ADDRESS OF ALLOCATED BLOCK

;
; THE NEW INDIRECT FILE FRAME IS FORMED ON THE STACK AND LINKED TO ANY
; PREVIOUS FRAMES.  THE STACK OVERFLOW CHECK HAS BEENY PERFORMED AT THIS POINT
;

	INCL	PRC_L_INDEPTH(R11)	; SET NEW INSTACK STACK DEPTH
	INCL	PRC_L_INDCLOCK(R11)	; INCREMENT TOTAL STACKS OR UNSTACKS
	MOVL	R8,PRC_L_STACKPT(R11)	; ALLOCATE NEW STACK FRAME
	MOVL	PRC_L_IDFLNK(R11),R6	; GET ADDRESS OF CURRENT INDIRECT FRAME
	MOVL	R6,IDF_L_LNK(R8)	; LINK NEW FRAME INTO TOP OF
	MOVAL	IDF_L_LNK(R8), -	; INDIRECT FILE FRAME LIST
		PRC_L_IDFLNK(R11)
;
; R6 = Pointer to current stack frame
; R8 = Pointer to new stack frame
;
	MOVL	PRC_L_INDFAB(R11),AP	;GET ADDRESS OF INDIRECT FAB
	MOVQ	PRC_Q_LOCAL(R11),IDF_Q_LOCAL(R6) ;SAVE LOCAL SYMBOL TABLE LISTHEAD
	MOVQ	PRC_Q_LABEL(R11),IDF_Q_LABEL(R6) ;SAVE LABEL SYMBOL TABLE LISTHEAD
	MOVW	PRC_W_ONLEVEL(R11),IDF_W_ONLEVEL(R6) ;SAVE ON ERROR LEVEL NUMBER
	MOVL	PRC_L_ONERROR(R11),IDF_L_ONERROR(R6) ;SAVE ON ERROR COMMAND TEXT
	MOVAB	PRC_Q_LOCAL(R11),R0	;GET ADDRESS OF LOCAL TABLE LISTHEAD
	MOVL	R0,(R0)			;SET ADDRESS OF LISTHEAD AS FORWARD LINK
	MOVL	(R0)+,(R0)+		;SET ADDRESS OF LISTHEAD AS BACKWARD LINK
	MOVAB	PRC_Q_LABEL(R11),R0	;GET ADDRESS OF LABEL TABLE LISTHEAD
	MOVL	R0,(R0)			;SET ADDRESS OF LISTHEAD AS FORWARD LINK
	MOVL	(R0)+,(R0)+		;SET ADDRESS OF LISTHEAD AS BACKWARD LINK
	CLRL	PRC_L_ONERROR(R11)	;CLEAR ADDRESS OF ON ERROR COMMAND TEXT
	MOVW	#2@8!2,PRC_W_ONLEVEL(R11) ;RESET ON ERROR LEVEL TO ERROR
	MOVL	PRC_L_ONCTLY(R11),IDF_L_ONCTLY(R6) ;SAVE ON CONTROL Y COMMAND
	BEQL	5$			;BR IF THERE WAS NONE
	MOVAB	W^DCL$T_DEFONTXT,PRC_L_ONCTLY(R11) ;SET DEFUALT FOR NEXT LEVEL
5$:	MOVW	#1@IDF_V_INPOPN,IDF_W_FLAG(R8) ;SET INPUT FILE OPEN FLAG
					;ASSUME FILE IS OPENED LOCALLY
	CLRL	IDF_L_SEARCHCTX(R8)	;INITIALIZE F$SEARCH CONTEXT LIST

;
; CLOSE INPUT FILE FROM PREVIOUS INDIRECT LEVEL AND REMEMBER THE CURRENT
; POSITION IN THE FILE, SO THAT ON RETURN, WE CAN RESET THE POSITION.
;
	MOVL	PRC_L_INDINPRAB(R11),R2	;SET CURRENT INDIRECT RAB POINTER
	CMPL	R2,PRC_L_INPRAB(R11)	;IS THIS THE PRIMARY INPUT STREAM?
	BEQL	7$			;BR IF YES-THAT NEVER GETS CLOSED
	BBC	#DEV$V_RND,RAB$L_CTX(R2),6$ ;SKIP IF NOT A DISK FILE
	MNEGW	#1,IDF_W_INPRFA(R6)	;ASSUME END OF FILE
	$FIND	RAB=(R2)		;GET THE CURRENT RECORD POSITION (IT
	CMPW	R0,#RMS$_EOF&^XFFFF	;MAY HAVE BEEN ADVANCED BY AN INDIRECT
	BEQL	6$			;ACCESSOR SINCE OUR LAST $GET).
	MOVL	RAB$W_RFA(R2),IDF_W_INPRFA(R6) ;SAVE RECORD POSITION IN FILE
	MOVW	RAB$W_RFA+4(R2),IDF_W_INPRFA+4(R6)
6$:	MOVW	IDF_W_INPIFI(R6),FAB$W_IFI(AP) ;SET INTERNAL FILE IDENTIFICATION
	$CLOSE	FAB=(AP)		;

;
; OPEN INPUT PROCEDURE FILE
;
7$:	CLRW	IDF_W_INPIFI(R8)	;CLEAR INPUT FILE INTERNAL INDEX
	CLRW	FAB$W_IFI(AP)		;CLEAR INTERNAL FILE INDEX

	MOVQ	4(SP),R1		;GET INPUT FILESPEC (R2/R3 ON ENTRY)
	MOVB	R1,FAB$B_FNS(AP)	;SET SIZE OF FILE NAME STRING
	MOVL	R2,FAB$L_FNA(AP)	;SET ADDRESS OF FILE NAME STRING
	MOVB	#4,FAB$B_DNS(AP)	;SET SIZE OF DEFAULT NAME STRING
	MOVAB	INPFILE,FAB$L_DNA(AP)	;SET ADDRESS OF DEFAULT NAME STRING

	MOVL	FAB$L_NAM(AP),R7	;GET ADDRESS OF INDIRECT NAME BLOCK

	MOVB	#255,(R9)		;STORE LENGTH OF BUFFER (IN SYM TAB)
	MOVL	R9,IDF_L_FILENAME(R8)	;STORE ADDRESS OF BUFFER (IN SYM TAB)
	ASSUME	NAM$B_RSL EQ NAM$B_RSS+1
	MOVZBW	#NAM$C_MAXRSS,-		;SAVE THE SIZE OF THE BUFFER
		NAM$B_RSS(R7)		;(NOTE, NOT THE ALLOCATED SIZE)
	MOVAB	1(R9),NAM$L_RSA(R7)	;SAVE THE ADDRESS OF THE BUFFER
	ASSUME	NAM$B_RSL EQ NAM$B_RSS+1
	MOVZBW	#NAM$C_MAXRSS,-		;SET UP EXPANDED STRING TOO
		NAM$B_ESS(R7)		;
	MOVL	NAM$L_RSA(R7),-		;
		NAM$L_ESA(R7)		;

	MOVB	#NAM$M_PWD,NAM$B_NOP(R7);DISABLE PASSWORD MASKING
	MOVB	#FAB$M_EXE,FAB$B_FAC(AP);SET FILE ACCESS TYPE
	MOVL	#FAB$M_INP!FAB$M_PPF,-	;SET FILE OPEN OPTIONS
		FAB$L_FOP(AP)		;
	MOVB	#FAB$M_PRN,FAB$B_RAT(AP);SET CARRIAGE CONTROL
	MOVB	#FAB$C_VFC,FAB$B_RFM(AP);SET VERT. FORMS CONTROL
	CLRB	FAB$B_SHR(AP)		;CLEAR FILE SHARING OPTIONS
	MOVL	AP,R0			;ADDRESS OF FAB

	MOVL	#4,R1			;ASSUME OPEN WITH ERROR REPORTING
	BLBC	(SP),8$			;IF ERROR REPORTING DISABLED,
	BISL	#2,R1			;DO OPEN WITHOUT ERROR REPORTING
8$:	BSBW	DCL$OPEN_CREATE		;OPEN INDIRECT INPUT FILE
	CLRBIT	NAM$V_PWD,NAM$B_NOP(R7)	;UNCONDITIONALLY REENABLE PASSWORD MASKINNG
	BLBC	R0,9$			;IF LBC OPEN FAILURE

	MOVW	FAB$W_IFI(AP),IDF_W_INPIFI(R8) ;SAVE INPUT FILE INTERNAL INDEX
	MOVAB	PRD_G_ALTINPRAB(AP),R6	;GET ALTERNATE INPUT RAB
	MOVL	FAB$L_DEV(AP),RAB$L_CTX(R6) ;SAVE DEVICE CHARACTERISTICS
	MOVL	RAB$L_CTX(R6),IDF_L_INPRABCTX(R8) ;AND A COPY IN THE STACK FRAME
	BBC	#NAM$V_NODE,-		;BRANCH IF NOT A REMOTE OPEN
		NAM$L_FNB(R7),10$	;
	SETBIT	IDF_V_REMOTE,-		;SET REMOTE OPEN FLAG
		IDF_W_FLAG(R8) 		;

;
; GET THE DEVICE NAME.  PROPAGATE CONCEALED ATTRIBUTES.
;
10$:	CLRBIT	IDF_V_INPCCL,IDF_B_OUTFLAGS(R8)	;CLEAR CONCEALED BIT IN IDF
	BBC	#NAM$V_CNCL_DEV,-		;IS DEVICE CONCEALED?
		NAM$L_FNB(R7),11$		;
	SETBIT	IDF_V_INPCCL,IDF_B_OUTFLAGS(R8)	;SET CONCEALED BIT IN IDF
	ASSUME	IDF_W_INPFID EQ IDF_T_INPDVI+16
	ASSUME	IDF_W_INPDID EQ IDF_W_INPFID+6
11$:	MOVC	#28,NAM$T_DVI(R7),-		;COPY FILE INFORMATION
		IDF_T_INPDVI(R8)		;INTO INDIRECT STACK FRAME
	MOVL	AP,RAB$L_FAB(R6)		;LINK FAB TO RAB
	$CONNECT RAB=(R6)			;CONNECT TO NEW INPUT
9$:	BLBC	R0,50$				;IF LBC CONNECT FAILURE
	CLRBIT	RAB$V_PPF_IND,RAB$W_ISI(R6) 	;MAKE SURE INDIRECT FLAG IS CLEAR
	MOVL	R6,PRC_L_INDINPRAB(R11)		;SET INDIRECT INPUT RAB
	BSBW	SAV_EXE_ONLY		;SAVE VER. FLAGS IF EXE-ONLY PROCEDURE.

;
; CREATE OUTPUT FILE, IF SPECIFIED
;
	MOVQ	12(SP),R1		;GET OUTPUT FILESPEC (R4/R5 ON ENTRY)
	MOVZBL	NAM$B_RSL(R7),-(SP)	;SAVE LENGTH OF INPUT FILE NAME
	MOVL	IDF_L_LNK(R8),R6	;SET ADDRESS OF DEFAULT SYS$OUTPUT INFO
	BSBW	DCL$OPEN_OUTPUT		;CONDITIONALLY OPEN SYS$OUTPUT
	POPL	R1			;RESTORE LENGTH OF INPUT FILE NAME
	BLBC	R0,50$			;RETURN ANY ERRORS

;
; DEALLOCATE UNUSED BUFFER.
;
	MOVL	IDF_L_FILENAME(R8),R0	;GET ADDRESS OF BUFFER
	MOVB	R1,(R0)			;SAVE FILE NAME LENGTH IN FIRST BYTE OF BUFFER
	ADDL	#8,R1			;ROUND UP SIZE TO QUADWORD BOUNDARY(INCLUDE ASCIC COUNT)
	BICL	#7,R1			;TRUNCATE DOWN SIZE TO QUADWORD BOUNDARY
	ADDL	R1,R0			;CALCULATE ADDRESS OF UNUSED BUFFER
	SUBL3	R1,#<<<NAM$C_MAXRSS+1>+7>&^C<7>>,R1 ;CALCULATE SIZE OF UNUSED BUFFER
	BEQL	40$			;DON'T DEALLOCATE IF NO UNUSED BUFFER
	BSBW	DCL$DEADYNMEM		;DEALLOCATE UNUSED BUFFER

;
; CREATE LOGICAL NAMES FOR 'INPUT' AND 'OUTPUT' AND EXIT WITH SUCCESS.
;
40$:	BSBW	DCL$CREATE_IO		;CREATE LOGICAL NAMES FOR 'INPUT' AND 'OUTPUT'
	STATUS	NORMAL			;
	BRW	80$			;EXIT WITH SUCCESS
 
;
; OPEN, CONNECT, OR SYMBOL ALLOCATION FAILURE
;
50$:	CLRW	NAM$B_RSS(R7)		;INVALIDATE RESULTANT STRINGS
	CLRW	NAM$B_ESS(R7)		;INVALIDATE EXPANDED STRINGS
	PUSHL	R0			;SAVE ERROR/STATUS VALUE
	BSBW	UNSTACK			;UNSTACK PREVIOUS INDIRECT FILE
	POPL	R0			;RETRIEVE ERROR/STATUS VALUE
	BRW	80$			;EXIT WITH STATUS

	.SBTTL	UNSTACK INDIRECT FILE SPECIFICATION
;+
; DCL$UNSTACK - UNSTACK INDIRECT FILE SPECIFICATION
;
; THIS ROUTINE IS CALLED TO CLOSE THE CURRENT INDIRECT FILE AND TO UNSTACK THE
; PREVIOUS SPECIFICATION.
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	THE CURRENT INDIRECT FILE IS CLOSED AND ALL LOCAL SYMBOLS FOR THE LEVEL
;	ARE DEALLOCATED. THE PREVIOUS INDIRECT FILE IS THEN UNSTACKED AND REOPENED.
;
;	R0 LOW BIT CLEAR INDICATES UNSUCCESSFUL COMPLETION.
;
;	R0 LOW BIT SET INDICATES SUCCESSFUL COMPLETION.
;
;	ALL ERRORS ARE SIGNALED BEFORE RETURNING TO CALLER.
;-
 
DCL$UNSTACK::				;UNSTACK INDIRECT FILE SPECIFICATION
	$DELLOG_S	TBLFLG=#LOG$C_PROCESS,- ;DELETE ANY USER DEFINED
			ACMODE=#PSL$C_USER	;LOGICAL NAMES.
	BSBB	SETIND			;SETUP INDIRECT PROCESSING
	PUSHL	S^#SS$_NORMAL		;ASSUME NORMAL COMPLETION
	BBCC	#PRC_V_GOTO,PRC_W_FLAGS(R11),10$ ;IF CLR, NO GOTO IN PROGRESS
	BSBW	DCL$DEALGOTO		;DEALLOCATE GOTO SYMBOL
	STATUS	USGOTO			;SET UNSATISFIED GOTO STATUS
	MOVL	R0,(SP)			;SET COMPLETION STATUS
	ERRMSG				;OUTPUT ERROR MESSAGE
	BSBW	DCL$SET_STATUS		;GIVE ERROR HANDLER'S A CHANCE
10$:	BSBB	UNSTACK			;UNSTACK TO PREVIOUS LEVEL
	MOVAB	WRK_G_INPBUF-1(R10),-	;SET STARTING ADDRESS OF INPUT
		WRK_L_CHARPTR(R10)	;BUFFER AS LAST BYTE FETCHED
	CLRB	WRK_G_INPBUF(R10)	;SET EOL AS NEXT BYTE TO FETCH
STKXIT:	POPR	#^M<R0,R1,R2,R3,R4,R5,R6,R7,R8,AP> ;RESTORE REGISTERS
					; R0=STATUS, R1=ORIGINAL FLAGS
	POPL	WRK_L_RSLNXT(R10)	;RESTORE TOKEN DESCRIPTORS BACK TO
	POPL	WRK_L_RSLEND(R10)	;WHERE THEY WERE WHEN WE STARTED
	POPL	WRK_L_EXPANDPTR(R10)	;RESTORE EXPANSION BUFFER POINTER
	POPL	WRK_L_MARKPTR(R10)	;RESTORE MARKER POINTER
	ENABLE				;ENABLE CONTROL Y/C AST'S
	BBS	#WRK_V_COMMAND,R1,10$	;BR IF COMMAND WAS SET
	BICW	#WRK_M_COMMAND,WRK_W_FLAGS(R10) ;CLEAR COMMAND IN PROGRESS
10$:	RSB				;
 
;
; SETIND - SETUP INDIRECT
;
; SAVE THE NON-VOLATILE REGISTERS AND THE COMMAND WORK FLAGS, THEN SET COMMAND
;
 
SETIND:	POPR	#^M<R0>			;GET RETURN PC
	DISABLE				;DISABLE CONTROL Y/C AST'S
	PUSHL	WRK_L_MARKPTR(R10)	;SAVE CURRENT MARKER POINTER
	PUSHL	WRK_L_EXPANDPTR(R10)	;SAVE CURRENT EXPANSION BUFFER POINTER
	PUSHL	WRK_L_RSLEND(R10)	;SAVE CURRENT ENDING TOKEN ADDRESS
	PUSHL	WRK_L_RSLNXT(R10)	;SAVE CURRENT POSITION IN TOKEN ARRAY
	PUSHR	#^M<R2,R3,R4,R5,R6,R7,R8,AP> ;SAVE REGISTERS
	PUSHL	WRK_W_FLAGS(R10)	;SAVE PREVIOUS COMMAND FLAGS
	SETBIT	WRK_V_COMMAND,WRK_W_FLAGS(R10) ;SET COMMAND IN PROGRESS
	JMP	(R0)			;RETURN TO CALLER

	.SBTTL	UNSTACK NEXT INDIRECT FILE
;---
;
; UNSTACK - UNSTACK NEXT INDIRECT FILE
;
; THIS ROUTINE IS CALLED TO CLOSE THE CURRENT INDIRECT FILE AND UNSTACK THE
; CONTEXT INFORMATION FOR THE PREVIOUS LEVEL INDIRECT FILE.
;
; INPUTS:
;
;	R11 = ADDRESS OF PROCESS WORK AREA
;
; OUTPUTS:
;
;	NONE
;
;	R0-R8,AP ARE DESTROYED.
;---
 
UNSTACK:				;UNSTACK INDIRECT FILE
	MOVL	PRC_L_INDFAB(R11),AP	;GET ADDRESS OF SCRATCH FAB
	MOVL	PRC_L_IDFLNK(R11),R8	;GET ADDRESS OF CURRENT INDIRECT FRAME
	PUSHL	R8			;SAVE THAT ADDRESS

;
; CLOSE CURRENT INPUT PROCEDURE FILE
;
	MOVW	IDF_W_INPIFI(R8),FAB$W_IFI(AP) ;RESTORE INTERNAL FILE INDEX
	$CLOSE	FAB=(AP)		;CLOSE INDIRECT INPUT FILE

;
; DEALLOCATE LOCAL SYMBOLS AND LABELS FOR CURRENT LEVEL
;
10$:	REMQUE	@PRC_Q_LOCAL(R11),R3	;REMOVE NEXT ENTRY FROM LOCAL SYMBOL TABLE
	BVC	20$			;IF VC ENTRY REMOVED
	REMQUE	@PRC_Q_LABEL(R11),R3	;REMOVE NEXT ENTRY FROM LOCAL LABEL TABLE
	BVS	30$			;IF VS TABLE EMPTY
20$:	BSBW	DCL$DEALLOCSYM		;DEALLOCATE SYMBOL ENTRY
	BRB	10$			;
;
; DEALLOCATE F$SEARCH CONTEXT BLOCKS FOR CURRENT LEVEL
;
30$:	MOVL	IDF_L_SEARCHCTX(R8),R3	;GET FIRST ENTRY OFF F$SEARCH LIST
	BEQL	32$			;BRANCH IF NONE LEFT
	MOVL	(R3),IDF_L_SEARCHCTX(R8) ;REMOVE FROM LINKED LIST
	MOVB	NLA0,FAB$B_FNS+8(R3)	;SET NULL DEVICE NAME
	MOVAB	NLA0+1,FAB$L_FNA+8(R3)	;
	$PARSE	FAB=8(R3)		;TERMINATE SEARCH SEQUENCE
	MOVL	R3,R0			;SET ADDRESS OF BLOCK TO DEALLOCATE
	MOVL	4(R0),R1		;GET SIZE OF ENTRY IN BYTES
	BSBW	DCL$DEADYNMEM		;DEALLOCATE CONTEXT BLOCK
	BRB	30$			;LOOP UNTIL LIST CLEANED OUT

;
; DEALLOCATE FILE NAME STRING
;
32$:	MOVL	IDF_L_FILENAME(R8),R0	;GET ADDRESS OF ASCIC FILENAME
	MOVZBL	(R0),R1			;GET SIZE OF FILENAME
	ADDL	#8,R1			;ROUND UP SIZE TO QUAD BOUNDARY
	BICL	#7,R1			;TRUNCATE SIZE TO QUAD BOUNDARY
	BSBW	DCL$DEADYNMEM		;DEALLOCATE BUFFER

;
; RESET ON CONDITIONS BACK TO DEFAULTS
;
	BSBW	DCL$ONRESET		;RESET ON ERROR PARAMETERS
	BSBW	DCL$ONCTLYRST		;AND THE ON CONTROL Y HANDLER
;
; CHECK IF THE FRAME JUST CLOSED WAS THE FIRST EXE-ONLY FRAME ENCOUNTERED.
; IF SO, RESTORE VERIFICATION STATE FROM SAVED FLAGS.
;
	BSBW	RES_EXE_ONLY		;CHECK EXE-ONLY PARAMETERS.
;
; POINT BACK TO THE PREVIOUS INDIRECT FRAME
;
	MOVL	IDF_L_LNK(R8), -	; UNLINK FRAME FROM INDIRECT LIST
		PRC_L_IDFLNK(R11)	; AND RESET FRAME POINTER
	MOVAB	IDF_K_LENGTH(R8), -	; REMOVE CURRENT INDIRECT FRAME FROM
		PRC_L_STACKPT(R11)	; STACK AND RESET STACK POINTER
	DECL	PRC_L_INDEPTH(R11)	; SET NEW INDIRECT STACK DEPTH
	INCL	PRC_L_INDCLOCK(R11)	; COUNT TOTAL STACKS OR UNSTACKS
	MOVL	PRC_L_IDFLNK(R11),R8	; POINT TO PREVIOUS INDIRECT FRAME

;
; RESTORE THE SAVED CONTEXT FROM THE PREVIOUS INDIRECT FRAME
;
	MOVQ	IDF_Q_LOCAL(R8),PRC_Q_LOCAL(R11) ;RESTORE LOCAL SYMBOL TABLE LISTHEAD
	MOVQ	IDF_Q_LABEL(R8),PRC_Q_LABEL(R11) ;RESTORE LOCAL LABEL TABLE LISTHEAD
	MOVW	IDF_W_ONLEVEL(R8),PRC_W_ONLEVEL(R11) ;RESTORE ON ERROR LEVEL NUMBER
	MOVL	IDF_L_ONERROR(R8),PRC_L_ONERROR(R11) ;RESTORE ADDRESS OF COMMAND TEXT
	MOVL	IDF_L_ONCTLY(R8),PRC_L_ONCTLY(R11) ;AND THE ON CONTROL T HANDLER

;
; RE-OPEN THE INPUT PROCEDURE FILE ASSOCIATED WITH THE PREVIOUS
; INDIRECT FRAME.
;
	CMPW	IDF_W_INPRFA(R8),#^XFFFF;IS THE INPUT FILE ALREADY AT EOF?
	BNEQ	35$			;NO, THEN BRANCH
	BRW	50$			;YES, THEN DO NOT REOPEN
35$:	MOVL	PRC_L_INPRAB(R11),-	;ASSUME RETURNING TO LEVEL ZERO AND-
		PRC_L_INDINPRAB(R11)	;SET INPUT AS INDIRECT INPUT ALSO
	BBS	#IDF_V_INPOPN,IDF_W_FLAG(R8),351$ ;CONTINUE IF NOT GOING TO LEVEL 0
	BRW	371$			;SKIP IF GOING TO LEVEL 0

351$:	PUSHL	#PSL$C_SUPER		;PUSH ACCESS MODE
	MOVAB	SYS_INPUT_NAME+1,-(SP)	;BUILD LOGICAL NAME DESCRIPTOR
	MOVZBL	SYS_INPUT_NAME,-(SP)	;
	MOVAB	LNM$PROCESS+1,-(SP)	;BUILD TABLE NAME DESCRIPTOR
	MOVZBL	LNM$PROCESS,-(SP)	;
	MOVL	SP,R1			;SAVE ADDR. OF DESCRIPTORS
	$DELLNM_S	TABNAM=(R1),-	;DELETE SYS$INPUT
		LOGNAM=8(R1),-
		ACMODE=16(R1)
	ADDL	#4*5,SP			;CLEAN STACK

	MOVAB	PRD_G_ALTINPRAB(AP),R6	;GET THE ALTERNATE INPUT RAB
	MOVL	R6,PRC_L_INDINPRAB(R11)	;SET THAT IS INDIRECT INPUT RAB
	MOVL	IDF_L_INPRABCTX(R8),-	;RESTORE STACKED DEVICE CHARACTERISTICS-
		RAB$L_CTX(R6)		;VALUE FROM STACK FRAME
	MOVL	FAB$L_NAM(AP),R7	;ADDRESS OF NAME BLOCK
	ASSUME	IDF_W_INPFID EQ IDF_T_INPDVI+16
	ASSUME	IDF_W_INPDID EQ IDF_W_INPFID+6
	MOVC	#28,IDF_T_INPDVI(R8),-	;COPY PREVIOUS INPUT DEVICE,FILE AND-
		NAM$T_DVI(R7)		;DIRECTORY ID'S INTO NAME BLOCK
	ASSUME  NAM$B_DEV EQ NAM$B_NODE+1
	ASSUME  NAM$B_DIR EQ NAM$B_DEV+1
	ASSUME  NAM$B_NAME EQ NAM$B_DIR+1
	ASSUME  NAM$B_TYPE EQ NAM$B_NAME+1
	ASSUME  NAM$B_VER EQ NAM$B_TYPE+1
	CLRL	NAM$B_NODE(R7)		;INIT. FILE SPEC. SIZE FIELDS BEFORE
					;REUSING NAM BLOCK.
	CLRW	NAM$B_TYPE(R7)		;

	ASSUME	NAM$B_RSL EQ NAM$B_RSS+1
	ASSUME	NAM$B_ESL EQ NAM$B_ESS+1
	CLRW	NAM$B_RSS(R7)		;SET RESULT RESULTANT AND EXPANDED
	CLRW	NAM$B_ESS(R7)		;STRING SIZES TO NULL SO THAT THE
					;RSA AND ESA WON'T BE USED.

	MOVB	#FAB$M_EXE!FAB$M_GET,FAB$B_FAC(AP) ;SET FILE ACCESS TYPE
	MOVL	#FAB$M_INP!FAB$M_PPF!FAB$M_NAM,- ;SET FILE OPEN OPTIONS
		FAB$L_FOP(AP)
	CLRB	FAB$B_FNS(AP)		;REMOVE RESIDUAL FILE NAME SIZE
	CLRB	FAB$B_SHR(AP)		;CLEAR FILE SHARING OPTIONS
	CLRW	FAB$W_IFI(AP)		;CLEAR INPUT IFI
	BBC	#IDF_V_REMOTE,-		;SKIP IF NOT REMOTE ACCESS
		IDF_W_FLAG(R8),36$	;
	CLRBIT	FAB$V_NAM,FAB$L_FOP(AP)	;CLEAR OPEN BY NAM BLOCK FLAG
	MOVL	IDF_L_FILENAME(R8),R0	;GET ADDRESS OF ASCIC FILENAME
	MOVB	(R0)+,FAB$B_FNS(AP)	;GET LENGTH OF FILE NAME
	MOVL	R0,FAB$L_FNA(AP)	;GET ADDRESS OF FILE NAME
36$:	$OPEN	FAB=(AP)		;OPEN PREVIOUS INPUT
	BLBS	R0,38$			;BRANCH IF SUCCESSFUL
37$:	BSBW	DCL$ERRORMSG		;REPORT ERROR MESSAGE
371$:	BRB	40$
38$:	CLRBIT	FAB$V_NAM,FAB$L_FOP(AP)	;REMOVE OPEN BY NAME BLOCK FLAG
	MOVW	FAB$W_IFI(AP),IDF_W_INPIFI(R8) ;SET NEW INPUT IFI
	CLRW	RAB$W_ISI(R6)		;ZERO PREVIOUS INTERNAL SEQUENCE NUMBER
	$CONNECT RAB=(R6)		;CONNECT TO PREVIOUS INPUT
	BLBC	R0,37$			;BRANCH IF UNSUCCESSFUL
	BBC	#DEV$V_RND,RAB$L_CTX(R6),40$ ;SKIP IF NOT A DISK FILE
	MOVW	IDF_W_INPRFA+4(R8),RAB$W_RFA4(R6) ;COPY RECORD FILE ADDRESS FROM
	MOVL	IDF_W_INPRFA(R8),RAB$W_RFA(R6) ;FROM INDIRECT STACK TO RAB
	BEQL	40$			;BR IF PREVIOUS FILE AT TOP_OF_FILE
	MOVB	#RAB$C_RFA,RAB$B_RAC(R6) ;SET ACCESS MODE TO RECORD FILE ADR
	$FIND	RAB=(R6)		;SET TO NEXT RECORD POSITION
	BLBC	R0,37$			;BRANCH IF UNSUCCESSFUL
	ASSUME	RAB$C_SEQ EQ 0
	CLRB	RAB$B_RAC(R6)		;SET ACCESS TO SEQUENTIAL

;
; CLOSE CURRENT OUTPUT FILE IF THE CURRENT OUTPUT FILE IS DIFFERENT
; FROM THE PREVIOUS LEVEL.  CREATE SYS$INPUT AND SYS$OUTPUT LOGICAL NAMES.
;
40$:	POPL	R8			;GET ADDR OF JUST CLOSED IDF FRAME
	MOVAB	IDF_W_OUTIFI+IDF_K_LENGTH(R8),R2 ;GET ADDR OF OUTPUT FILE INFO
	BSBW	DCL$RESTORE_OUTPUT	;RESET OLD SYS$OUTPUT
	MOVL	PRC_L_IDFLNK(R11),R8	;GET ADDR OF CURRENT IDF FRAME
	BSBW	DCL$CREATE_IO		;CREATE 'INPUT' AND 'OUTPUT' LOGICAL NAMES
	RSB

;
; DO NOT OPEN THIS INPUT FILE.  REOPEN THE NEXT ONE.
;
50$:	POPL	R8			;GET ADDR OF JUST CLOSED IDF FRAME
	MOVAB	IDF_W_OUTIFI+IDF_K_LENGTH(R8),R2 ;GET ADDR OF OUTPUT FILE INFO
	BSBW	DCL$RESTORE_OUTPUT	;RESET OLD SYS$OUTPUT
	MOVL	PRC_L_IDFLNK(R11),R8	;GET ADDR OF CURRENT IDF FRAME
	PUSHL	R8			;SAVE THAT ADDRESS
	BRW	10$			;REOPEN NEXT INPUT FILE

	.SBTTL	SAVE VERIFICATION STATE
;+
; SAV_EXE_ONLY - SAVE EXECUTE ONLY VERIFICATION STATE
;
; THIS ROUTINE CHECKS IF PROCEDURE THAT IS ABOUT TO BE EXECUTED IS THE FIRST
; EXECUTE-ONLY PROCEDURE ENCOUTERED SO FAR. IF SO, IT SAVES THE VERIFICATION
; STATES AND THE LEVEL NUMBER.
;
; INPUTS:
;
;	R11 - ADDRESS OF PROCESS WORK AREA
;
; OUTPUTS:
;
;	NONE
;-

SAV_EXE_ONLY:
	MOVL	R6,-(SP)		;SAVE WORK REGISTER
	BBS	#FAB$V_GET,FAB$B_FAC(AP),30$	;SKIP IF READ ACCESS
	TSTB	PRC_B_EXONLYL(R11)	;FIRST ONE ENCOUNTERED?
	BNEQ	30$			;NO, JUST SKIP IT

	BICB	#PRC_V_SAVCMDV!PRC_V_SAVIMGV,-		;PRESET SAVED VERIF. FLAGS
		PRC_B_OUTFLAGS(R11)
	CLRL	R6					;TURN OFF IMG. VERIF.
	BBC	#PRC_V_VERIFY,PRC_W_FLAGS(R11),10$	;SKIP IF NO VERIFY
	SETBIT	PRC_V_SAVCMDV,PRC_B_OUTFLAGS(R11)	;SET CMD. VERIFY
10$:	BBC	#PRC_V_VERIMAGE,PRC_B_FLAGS2(R11),20$	;SKIP IF NO VERIFY
	SETBIT	PRC_V_SAVIMGV,PRC_B_OUTFLAGS(R11)	;SET IMG. VERIFY
20$:	BSBW	DCL$SETVERIFY_IMAGE
	MOVB	PRC_L_INDEPTH(R11),PRC_B_EXONLYL(R11)	;SAVE LEVEL NUMBER
30$:	MOVL	(SP)+,R6		;RESTORE WORK REGISTERS
	STATUS	NORMAL			;ALWAYS EXIT WITH SUCCESS
	RSB				;EXIT

	.SBTTL	RESTORE VERIFICATION STATE
;+
;
; RES_EXE_ONLY - RESTORE EXECUTE ONLY VERIFICATION STATE
;
; THIS ROUTINE CHECKS IF THE FRAME CURRENTLY BEING UNSTACKED IS THE FIRST
; EXE-ONLY PROCEDURE ENCOUNTERED. IF SO, IT RESTORES THE VERIFICATION STATES
; TO WHAT THEY WERE PRIOR TO THE EXECUTE ONLY PROCEDURE.
;
; INPUTS:
;
;	R11 = ADDRESS OF PROCESS WORK AREA
;
; OUTPUTS:
;
;	NONE
;+

RES_EXE_ONLY:
	MOVL	R6,-(SP)		;SAVE WORK REGISTER
	CMPB	PRC_L_INDEPTH(R11),-	;IS THIS 1ST EX-ONLY LEVEL?
		PRC_B_EXONLYL(R11)
	BNEQ	30$			;NO, SKIP THIS ONE

	CLRB	PRC_B_EXONLYL(R11)	;CLEAR EXE-ONLY FLAG
	CLRBIT	PRC_V_VERIFY,PRC_W_FLAGS(R11)	;INIT. CMD. VERIF. FLAG
	BBC	#PRC_V_SAVCMDV,PRC_B_OUTFLAGS(R11),10$	;SKIP IF NO VERIFY
	SETBIT	PRC_V_VERIFY,PRC_W_FLAGS(R11)	;SET CMD. VERIFICATION

10$:	CLRL	R6			;ASSUME NO IMAGE VERIFICATION
	BBC	#PRC_V_SAVIMGV,PRC_B_OUTFLAGS(R11),20$ 	;SKIP IF NO VERIFY
	INCL	R6			;SET FLAG TO SET IMG. VERIFICATION
20$:	CLRBIT	PRC_V_VERIMAGE,PRC_B_FLAGS2(R11) ;SYNC FLAG WITH LAST SET STATE
	BSBW	DCL$SETVERIFY_IMAGE	;SET/RESET IMAGE VERIFICATION
30$:	MOVL	(SP)+,R6		;RESTORE WORK REGISTER
	STATUS	NORMAL			;ALWAYS SIGNAL SUCCESS
	RSB				;EXIT

	.END
