MODULE INSCREATE (			! Create KFE entry
			IDENT = 'V04-000',
			ADDRESSING_MODE(EXTERNAL = GENERAL)
		 ) =
BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************

!++
! FACILITY:  Install
!
! ABSTRACT:
!
!	This module executes the CREATE, REPLACE and DELETE options on INSTALL
!
! ENVIRONMENT:
!
!	VAX/VMS operating system.
!
! AUTHOR:  Bob Grosso, April 1983
!
! Modified by:
!
!
!	V03-023	MSH0065		Michael S. Harvey	16-Jul-1984
!		Don't allow privileged or execute_only images to have
!		transfer arrays pointing to SYS$IMGSTA.
!
!	V03-022	MSH0061		Michael S. Harvey	5-Jul-1984
!		Add EXEONLY support.
!
!	V03-021	MSH0057		Michael S. Harvey	26-Jun-1984
!		Store WRITEABLE attribute in KFE so that it can be
!		propagated across a REPLACE command along with all
!		the other attributes.
!
!	V03-020	MSH0047		Michael S. Harvey	11-May-1984
!		Add some image header validation checks for images being
!		installed with resident headers since such checks will
!		not be done in the image activator for these cases.
!
!	V03-019	MSH0046		Michael S. Harvey	11-May-1984
!		Calculate an effective IDENT for shareable compatibility
!		mode global sections, that is, an IDENT that can be
!		used by the AME. Also, don't attempt to determine the
!		state of being "shareable" for C-mode images by applying
!		the native mode test for that state.
!
!	V03-018	MSH0038		Michael S. Harvey	30-Apr-1984
!		Correct parameter definition in call to IMG$DECODE_IHD
!		so that compatibility mode images are correctly recognised.
!		Also, update ALIAS check to conform to the image activator's
!		check. Also, correctly set SHM when attempting to install
!		images with shared memory global sections.
!
!	V03-017	MSH0033		Michael S. Harvey	16-Apr-1984
!		Back out part of MSH0030 below. Turns out that we only
!		want to change the page write access mode, while leaving
!		the page ownership as USER instead of EXEC.
!
!	V03-016	MSH0028		Michael S. Harvey	11-Apr-1984
!		Maximum shared count now has meaning even for non-shareable
!		images. Initialize the count in a more general way.
!
!	V03-015	MSH0030		Michael S. Harvey	9-Apr-1984
!		Set up page ownership for protected images correctly.
!
!	V03-014	MSH0028		Michael S. Harvey	9-Apr-1984
!		Correctly set initial maximum shared count for shareable
!		known file images.
!
!	V03-013	MSH0024		Michael S. Harvey	31-Mar-1984
!		Don't attempt to create global sections for compatibility
!		mode tasks which are not built shareable (TKB /MU).
!		Also, don't set SHARED or HDRRES bits if they shouldn't
!		be set. This prevents later screwups in case the known
!		file image is deleted. Also, clean up warning to c-mode
!		users that resident headers are not allowed for such images.
!
!	V03-012	MSH0022		Michael S. Harvey	15-Mar-1984
!		Eliminate middle brackets from root directory spec.
!		Also, correct logic which flags the shared memory state.
!		Also, clarify NOGBLSEC message so it's more useful.
!
!	V03-011	MSH0018		Michael S. Harvey	7-Mar-1984
!		Remove obsolete check for maximum file name length. It's
!		obsolete now that global sections support 39 character
!		file names.
!
!	V03-010	MSH0017		Michael S. Harvey	7-Mar-1984
!		Prevent pool loss when trying to install an image for
!		which another version of the image is already installed.
!
!	V03-009	MSH0015		Michael S. Harvey	6-Mar-1984
!		Warn user when installing a shareable image and no global
!		sections can be created.
!
!	V03-008	MSH0004		Michael S. Harvey	13-Feb-1984
!		Don't reject long image names. Also, add support of long
!		global section names.
!
!	V03-007	MSH0003		Michael S. Harvey	27-Jan-1984
!		Prevent crash caused by eventual system service execution
!		while IPL is incorrectly left at ASTDEL.
!
!	V03-006	BLS0256		Benn Schreiber		 3-Jan-1984
!		Correct calls to allocate paged pool to check for errors
!		so that system doesn't crash.  Convert square brackets
!		to angle brackets in KFD list.  Don't allocate new KFD
!		until we are ready to enter the KFE.
!
!	V03-005	RPG0005		Bob Grosso		01-Aug-1983
!		Change Global section ident to be something other
!		than zero for non shareable images.
!		Set IPL to ASTDEL to ensure process is not deleted 
!		with pool allocated but not yet connected to list.
!		Also comment code.
!
!	V03-004	RPG0004		Bob Grosso		July 25, 1983
!		Count entries to assist listing.
!
!	V03-003	RPG0003		Bob Grosso		July 20, 1983
!		Correct call to MMG$RET_BYT_QUOTA.
!
!	V03-002	RPG0002		Bob Grosso		July 19, 1983
!		Create protected global sections in user mode instead
!		of exec mode.
!		Set the SHRWCB bit in the WCB and call MMG$RET_BYT_QUOTA.
! 		To return byte quota since file is being opened for everyone.
!
!	V03-001	RPG0001		Bob Grosso		July 7,1983
!		Reduce items on kernel stack
!--

!
! Include files
!

LIBRARY 'SYS$LIBRARY:LIB';			! VAX/VMS system definitions

REQUIRE	'SRC$:INSPREFIX.REQ';
REQUIRE 'SHRLIB$:IMGMSGDEF.R32';		! Message codes for the image header decode routines
REQUIRE	'LIB$:INSDEF.R32';			! Contains definition of INSTALL flags longword
REQUIRE 'LIB$:RSXLBLDF.R32';			! Contains field offsets for compatability mode image headers

%SBTTL  'Declarations';

LINKAGE
    JSB_0 = JSB (REGISTER = 0),			! for MMG$RET_BYTE_QUOTA

    JSB_0_G1 = JSB (REGISTER = 0) :		! for IOC$VERIFYCHAN
	GLOBAL (ccb = 1) NOPRESERVE (2,3), 

    JSB_G1_G2 = JSB :				! Allocate pool
	GLOBAL (length = 1, entry_block = 2) 
	NOPRESERVE (3),

    JSB_G1_G2_3 = JSB (REGISTER = 3) :		! Allocate memory in P1 space
	GLOBAL (length = 1, entry_block = 2),

    JSB_9_G10_G11 = JSB (REGISTER = 9) :	! MMG$GSDTRNLOG
	GLOBAL (SHRMEMNAM = 10, GSDNAM = 11);

!
! Table of contents
!
FORWARD ROUTINE
    INS_CREATE,					! 
    CREATE,					! 
    ALLOC_PAGED,				! Allocate from paged pool
    FIND_KFD,					! 
    BUILD_KFD : NOVALUE,			! Build a Known file Device, directory block
    ENTER_KFE,					! Insert the Known File Entry into the Hash list and KFD list
    VERIFY_CHANNEL,				! 
    CHECK_SHMIDENT,				! Check if global sections should be in shared memory
    INS$BLD_GBLSECNAM;				! Build the global section name with the _nnn suffix

EXTERNAL ROUTINE
    INS$EXECUTE_IN_KRNL_WITH_W_LOCK,
    INS$CNVRT_KF_LOCK,
    INS$FIND_KFE,
    INS$CVT_DIR,
    INS$HASH;

EXTERNAL ROUTINE
    EXE$ALLOCATE : JSB_G1_G2_3,			! Allocate in process space
    EXE$ALOPAGED : JSB_G1_G2,			! Allocate from paged pool
    IOC$VERIFYCHAN : JSB_0_G1,			! verify device channel
    IMG$DECODE_IHD,				! Get and decode Image Header
    IMG$GET_NEXT_ISD,				! Get and decode Image Section Descriptors
    LIB$GET_VM,					! Allocate virtual memory
    LIB$FREE_VM,				! Return virtual memory
    MMG$GSDTRNLOG : JSB_9_G10_G11,		! See if global section is in shared memory
    MMG$RET_BYT_QUOTA : JSB_0,			! Return byte quota when sharing
    SYS$FAO;					! format ASCII data

EXTERNAL
    ctl$gq_allocreg,				! Memory allocation listhead
    ctl$gl_knownfil,				! Process known file listhead queues
    EXE$GL_KNOWN_FILES : REF BBLOCK,		! Pointer to knownfil list queues
    EXE$GL_SYSUCB,				! Address of system disk unit control block
    INS$GL_CTLMSK : BLOCK [1],			! Control flags
    INS$GL_KFECHAN,				! Channel known image file is open on.
    INS$GQ_KFERNS : $BBLOCK [DSC$C_S_BLN],	! Result name string
    INS$GQ_KFEPRIVS : BBLOCK [8],		! quadword privilege mask
    INS$G_KFENAM : $BBLOCK,			! NAM block for the filename of the known image
    INS$GL_KFEADR,				! Return the KFE address when it has been created or replaced
    INS$L_INTRNLERR,				! Return internal error descriptor
    SGN$GB_KFHSHSIZ : BYTE;			! Number of kf list queues to put in header block

EXTERNAL LITERAL
    INS$_EXISTS,				! Different version already exists
    INS$_IMGHDR,				! Error reading image header
    INS$_IMGTRACED,				! Image linked with traceback
    INS$_INTRNLERR,				! INSTALL internal error
    INS$_HDRNOTRES,				! unable to make image header resident
    INS$_NOGBLSEC,				! No global sections created for shareable image
    INS$_NOHDRRES,				! Compatibility mode image can not be header resident
    INS$_NOSHRD,				! File not shareable
    INS$_NOKFEFND,				! no known file entry found
    INS$_NOPAGEDYN,				! Not enough pagedyn
    INS$_SYSVERDIF,				! System version mismatch
    P1SYSVECTORS,				! Base of system service vectors
!   SYS$IMGSTA,					! Image startup system service
    SYS$K_VERSION;				! Current system version value

OWN
    BLDKFDBUF : REF $BBLOCK,
    HDRBLK_BUF : REF $BBLOCK,
    IHDBUF : REF $BBLOCK,
    ISDBUF : REF $BBLOCK;

BIND
    SGN_B_KFHSHSIZ  = SGN$GB_KFHSHSIZ : BYTE;

BIND
    PROCESS_ERR_DSC = $DESCRIPTOR (' Create with /PROCESS'),
    DUPINKFD_ERR_DSC = $DESCRIPTOR (' Duplicate in KFD');

! ==========================================================================
!
!	NOTE !!
!
! The following constant is defined as a workaround for a bug in the linker.
! Because any reference to the symbol SYS$IMGSTA causes the linker to
! automatically link with /TRACEBACK and we don't want /TRACEBACK for INSTALL,
! a constant is being defined here to provide an indirect reference to
! SYS$IMGSTA instead.
!
! This constant definition is a hack and should be removed once the linker
! is fixed to allow /NOTRACEBACK for images that refer to SYS$IMGSTA. It's
! OK to have a constant because the symbol's value will never change.
!

LITERAL		SYS_IMGSTA_OFF = %X'168';	! HARD-CODED VECTOR OFFSET

!
! ==========================================================================

%SBTTL 'INS$CREATE';

GLOBAL ROUTINE  INS$CREATE =
BEGIN
!+++
!
!  FUNCTIONAL DESCRIPTION:
!
!	Create a Known File entry.
!	If there is no listhead for the entry being created, then create one.
!
!  EXPLICIT INPUT:
!
!	none
!
!  IMPLICIT INPUT:
!
!	ins$gl_ctlmsk	=	INSTALL's control flags dictating which operation to perform
!	INS$GL_KFECHAN	=	Channel on which the known file image is open
!	INS$GQ_KFEPRIVS	=	Address of quadword containing privilege mask for KFE
!	INS$G_KFENAM	=	Name Block to get the dir, nam and typ strings for the KFE
!	INS$GQ_KFERNS	=	Result Name String for error messages
!
!  IMPLICIT OUTPUT:
!
!	INS$GL_KFEADR	=	Address of KFE, may also have low bit set
!
!  ROUTINE VALUE:
!
!    R0 = return status, low bit set for success, else error status
!
!---

LOCAL
    ONE_BLOCK,
    STATUS;

!
! Allocate buffers if needed
!
ONE_BLOCK = 512;
IF .HDRBLK_BUF EQL 0
    THEN EXECUTE(LIB$GET_VM(ONE_BLOCK,HDRBLK_BUF));
IF .IHDBUF EQL 0
    THEN EXECUTE(LIB$GET_VM(ONE_BLOCK,IHDBUF));
IF .ISDBUF EQL 0
    THEN EXECUTE(LIB$GET_VM(ONE_BLOCK,ISDBUF));
IF .BLDKFDBUF EQL 0
    THEN EXECUTE(LIB$GET_VM(%REF(KFD$C_LENGTH+NAM$C_MAXRSS),BLDKFDBUF));

STATUS = INS$EXECUTE_IN_KRNL_WITH_W_LOCK (INS_CREATE, 0);

IF .INS$GL_CTLMSK [INS$V_NOGBLSEC]
THEN
    SIGNAL (INS$_NOGBLSEC,1,INS$GQ_KFERNS);

IF .INS$GL_CTLMSK [INS$V_NOHDRRES]
THEN
    SIGNAL (INS$_NOHDRRES,1,INS$GQ_KFERNS);

RETURN .STATUS;
END;		! Global routine INS$CREATE


%SBTTL 'INS_CREATE';

GLOBAL ROUTINE  INS_CREATE =
BEGIN
!+++
!
!  FUNCTIONAL DESCRIPTION:
!
!	Create a Known File entry.
!	If there is no listhead for the entry being created, then create one.
!
!  EXPLICIT INPUT:
!
!	none
!
!  IMPLICIT INPUT:
!
!	ins$gl_ctlmsk	=	INSTALL's control flags dictating which operation to perform
!	INS$GL_KFECHAN	=	Channel on which the known file image is open
!	INS$GQ_KFEPRIVS	=	Address of quadword containing privilege mask for KFE
!	INS$G_KFENAM	=	Name Block to get the dir, nam and typ strings for the KFE
!
!  IMPLICIT OUTPUT:
!
!	INS$GL_KFEADR	=	Address of KFE, may also have low bit set
!
!  ROUTINE VALUE:
!
!    R0 = return status, low bit set for success, else error status
!
!---

LOCAL
    KFD : REF BBLOCK,
    KFD_INSERT_ADR,
    HASH_INDEX,
    KFE : REF BBLOCK,
    LENGTH,
    STATUS;
!
!   Set up initial global-section-created flag for shareable image installation.
!
INS$GL_CTLMSK [INS$V_NOGBLSEC] = FALSE;		! Assume that /share will result in global section creation

!
!   Set up initial resident header created flag.
!
INS$GL_CTLMSK [INS$V_NOHDRRES] = FALSE;		! Assume that /header is OK

!
!   Compute which hash table bucket Known File Entry should go into.
!
HASH_INDEX = INS$HASH (.INS$G_KFENAM [NAM$B_NAME], .INS$G_KFENAM [NAM$L_NAME], 
			.SGN_B_KFHSHSIZ );
!
!   Check for another version of this image already installed, that is, a file name
!   that is equal and from the same device, directory and with the same file type
!   as the one we are currently trying to install.
!
STATUS = INS$FIND_KFE (.HASH_INDEX, INS$G_KFENAM);
IF .STATUS NEQ 0
THEN
    RETURN INS$_EXISTS;

!
!   Check if the Known File Device, Directory, Type (KFD) block exists.
!   If it doesn't, record where it should be inserted when it is created.
!
KFD = FIND_KFD (INS$G_KFENAM, KFD_INSERT_ADR);

STATUS = CREATE (.HASH_INDEX, .KFD, .KFD_INSERT_ADR);

RETURN .STATUS;
END;		! Global routine INS_CREATE


%SBTTL 'create';

ROUTINE CREATE (HASH_INDEX, KFD, KFD_INSERT_ADR ) =
BEGIN
!+++
!
!  FUNCTIONAL DESCRIPTION:
!
!	Create a Known File entry.
!	If there is no listhead for the entry being created, then create one.
!	Execute in Kernel mode
!
!  EXPLICIT INPUT:
!
!	HASH_INDEX	Index of Hash bucket the new KFE should be inserted in
!	KFD		Device, Directory, Type block if it exists.
!	KFD_INSERT_ADR	Address to insert a KFD if one does not exist and 
!			much be built
!
!  IMPLICIT INPUT:
!
!	ins$gl_ctlmsk	=	INSTALL's control flags dictating which operation to perform
!	INS$GL_KFECHAN	=	Channel on which the known file image is open
!	INS$GQ_KFEPRIVS	=	Address of quadword containing privilege mask for KFE
!	INS$G_KFENAM	=	Name Block to get the dir, nam and typ strings for the KFE
!
!  IMPLICIT OUTPUT:
!
!	INS$GL_KFEADR	=	Address of KFE, may also have low bit set
!
!  ROUTINE VALUE:
!
!    R0 = return status, low bit set for success, else error status
!
!---
LOCAL
    CCB : REF BBLOCK,
    WCB : REF BBLOCK,
    KFE : REF BBLOCK,
    BLD_KFE_BUF : $BBLOCK [KFE$C_LENGTH + 39],	! Size of entry plus max size of NAM block file name field
    LENGTH,
    HDR_VERSION,
    ALIAS : WORD,
    OFFSET,
    VBN,
    STATUS;
MAP
    KFD : REF BBLOCK;


IF .INS$GL_CTLMSK [INS$V_PROCESS]
THEN
    BEGIN
    INS$L_INTRNLERR = PROCESS_ERR_DSC;
    RETURN INS$_INTRNLERR;			! replace with call to ins$p1permanent ();
    END;

!
!   Build a Known File Entry (KFE) for later insertion into hash bucket list
!
LENGTH = KFE$C_LENGTH + .INS$G_KFENAM [NAM$B_NAME];
KFE = BLD_KFE_BUF;			! Point to buffer on stack, copy to paged pool when its time to enqueue it.
CH$FILL (0, .LENGTH, .KFE);		! zero the KFE

KFE [KFE$W_SIZE] = .LENGTH;
KFE [KFE$B_TYPE] = DYN$C_KFE;
KFE [KFE$B_HSHIDX] = .HASH_INDEX;

!
!   Store the file name in the KFE.  There will be a pointer to the 
!   device, directory and type which will be stored in a KFD block.
!
KFE [KFE$B_FILNAMLEN] = .INS$G_KFENAM [NAM$B_NAME];
CH$MOVE (.INS$G_KFENAM [NAM$B_NAME], .INS$G_KFENAM [NAM$L_NAME], 
		KFE [KFE$T_FILNAM]);

KFE [KFE$V_HDRRES] = .INS$GL_CTLMSK [INS$V_HDRRES];
KFE [KFE$V_SHARED] = .INS$GL_CTLMSK [INS$V_SHARED];
KFE [KFE$V_PROTECT] = .INS$GL_CTLMSK [INS$V_PROTECT];
KFE [KFE$V_OPEN] = .INS$GL_CTLMSK [INS$V_OPEN];
KFE [KFE$V_NOPURGE] = .INS$GL_CTLMSK [INS$V_NOPURGE];
KFE [KFE$V_ACCOUNT] = .INS$GL_CTLMSK [INS$V_ACCOUNT];
KFE [KFE$V_EXEONLY] = .INS$GL_CTLMSK [INS$V_EXEONLY];

IF .INS$GL_CTLMSK [INS$V_SHARED]
THEN
    KFE [KFE$V_WRITEABLE] = .INS$GL_CTLMSK [INS$V_WRITABLE];

IF .INS$GL_CTLMSK [INS$V_SHARED] OR		! /SHARE or /HEAD implies /OPEN
   .INS$GL_CTLMSK [INS$V_HDRRES]
THEN
    KFE [KFE$V_OPEN] = TRUE;

STATUS = VERIFY_CHANNEL (.INS$GL_KFECHAN, CCB);	! Obtain the CCB
IF NOT .STATUS THEN RETURN .STATUS;
IF NOT .CCB [CCB$L_UCB] EQL .EXE$GL_SYSUCB	! If this is not the system device
THEN
    IF .INS$GL_CTLMSK [INS$V_PRIV]		! Then a privileged image must remain open
    THEN					! to keep a transaction against the volume
	KFE [KFE$V_OPEN] = TRUE;

IF .INS$GL_CTLMSK [INS$V_PRIV]
THEN
    BEGIN
    KFE [KFE$V_PROCPRIV] = TRUE;		! If installed /PRIV 
    CH$MOVE (8, INS$GQ_KFEPRIVS, KFE [KFE$Q_PROCPRIV]);	! copy in the privilege mask
    END;

!
!   Check if the Known File Device Directory, Type (KFD) block exists.
!   If it doesn't create it for later insertion in KFD list
!
IF .KFD EQL 0
THEN
    BUILD_KFD (INS$G_KFENAM,.BLDKFDBUF)
ELSE
    KFE [KFE$L_KFD] = .KFD;			! KFD exists and is in place
    
!
!	The image header is opened for a number of reasons.
!
IF	(.KFE [KFE$V_PROCPRIV]
      OR .KFE [KFE$V_EXEONLY]
      OR .KFE [KFE$V_OPEN])
THEN
    BEGIN
    !
    !	Read the image header.
    !
    CH$FILL (0, 512, .HDRBLK_BUF);
    CH$FILL (0, 512, .IHDBUF);
    STATUS = IMG$DECODE_IHD (.INS$GL_KFECHAN, .HDRBLK_BUF, .IHDBUF, 
			 VBN, OFFSET, HDR_VERSION, ALIAS);
    IF NOT .STATUS THEN RETURN .STATUS;
    END;

!
!	Verify that the image transfer array doesn't contain SYS$IMGSTA for
!	images installed with privilege or as execute_only images.
!
IF .KFE [KFE$V_PROCPRIV] OR .KFE [KFE$V_EXEONLY]
THEN
    BEGIN
    LOCAL
	ACTIVOFF : BBLOCK [IHA$C_LENGTH],
	TFR1;

    ACTIVOFF = .IHDBUF + .IHDBUF [IHD$W_ACTIVOFF];
    TFR1 = .(.ACTIVOFF [IHA$L_TFRADR1]);	! Get first image transfer address
    IF (.TFR1 EQL (P1SYSVECTORS + SYS_IMGSTA_OFF))
	OR
	((.TFR1 - %X'80000000') EQL SYS_IMGSTA_OFF)
    THEN
	RETURN INS$_IMGTRACED;
    END;

IF NOT .KFE [KFE$V_OPEN]
THEN
    CH$MOVE (8, INS$G_KFENAM [NAM$W_FID], KFE [KFE$W_FID])
!
!	Explicit or implicit /OPEN. If /HEAD then store the image header.
!	If /SHARE, then process the ISDs and build global sections.
!
ELSE
    BEGIN
    LOCAL
	BLDHDR_LEN,
	CRESECFLG,				! Mask of create section options
	GBLSECNAM_DSC : BBLOCK [DSC$C_S_BLN],	! Address of descriptor of global section name
	GBLSECNAM : BBLOCK [INS$C_GBLNAMLEN],
	BLDHDR : REF BBLOCK,
	BLDHDR_SIZ;

    !
    !   Do some image type specific processing.
    !
    IF
	(.ALIAS EQL IHD$C_RSX)
	OR
	(.ALIAS EQL IHD$C_BPA)
	OR
	(.ALIAS EQL IHD$C_ALIAS)
    THEN

	!
	!   If it's not a native mode image, then set the COMPAT flag,
	!   disallow a resident header, and store the AME type code.
	!
	BEGIN
	KFE [KFE$V_COMPATMOD] = TRUE;
	IF .INS$GL_CTLMSK [INS$V_HDRRES]
	THEN
	    BEGIN
	    INS$GL_CTLMSK [INS$V_HDRRES] = FALSE;
	    KFE [KFE$V_HDRRES] = FALSE;
	    INS$GL_CTLMSK [INS$V_NOHDRRES] = TRUE;
	    END;
	KFE [KFE$W_AMECOD] = .ALIAS;		! Store which type of AME
	END
    ELSE

	!   If it's a native mode image, determine if it's shareable. Also,
	!   perform special checks on the header if it's going to be resident.
	!
	BEGIN
	BIND
	    MINORID_DIGIT = IHDBUF [IHD$W_MINORID] : VECTOR [2,BYTE];

	LITERAL
	    MINOR_ID_TENS = IHD$K_MINORID AND %X'FF',
	    MINOR_ID_ONES = IHD$K_MINORID ^ -8;

	!
	!   Determine if this image is shareable.
	!
	KFE [KFE$V_LIM] = (.IHDBUF [IHD$B_IMGTYPE] EQL IHD$K_LIM); 

	IF .KFE [KFE$V_HDRRES]
	THEN
	    !
	    !	The major ID in the image header must be identically equal to
	    !	the constant IHD$K_MAJORID. The minor ID in the image header
	    !	must be LEQU the constant IHD$K_MINORID. Both IDs are stored
	    !	as ASCII strings.
	    !
	    BEGIN
	    IF (.IHDBUF [IHD$W_MAJORID] NEQU IHD$K_MAJORID)
	    THEN RETURN SS$_BADIMGHDR;

	    IF (
		(.MINORID_DIGIT [0] GTRU MINOR_ID_TENS)
		OR
		(
		 (.MINORID_DIGIT [0] EQLU MINOR_ID_TENS)
		 AND
		 (.MINORID_DIGIT [1] GTRU MINOR_ID_ONES)
		)
	       )
	    THEN RETURN SS$_BADIMGHDR;

	    !
	    !   If the image was linked against a SYS.STB for other than
	    !	the current system, then don't install it.
	    !
	    IF (.IHDBUF [IHD$L_SYSVER] NEQU 0)
	    THEN
		IF (.IHDBUF [IHD$L_SYSVER] NEQU SYS$K_VERSION)
		THEN RETURN INS$_SYSVERDIF;
	    END;
	END;

    !
    !   Perform some initialization of the Create and Map Section parameters
    !
    IF .INS$GL_CTLMSK [INS$V_SHARED]	! /SHARE 
    THEN
	BEGIN
	LOCAL
	    IS_SHRMEM;

	!
	!   Init global section name
	!
	CH$FILL (0, INS$C_GBLNAMLEN, GBLSECNAM);
	GBLSECNAM_DSC = 0;
	GBLSECNAM_DSC [DSC$A_POINTER] = GBLSECNAM;
	INS$BLD_GBLSECNAM (GBLSECNAM_DSC);	! Build the global section name, FILENAM_nnn


	IF .KFE [KFE$V_COMPATMOD]
	THEN
	    BEGIN
	    IF .ALIAS NEQ IHD$C_RSX
	    THEN
		BEGIN
		IF .INS$GL_CTLMSK [INS$V_SHARED]
		THEN
		    BEGIN
		    INS$GL_CTLMSK [INS$V_SHARED] = FALSE;
		    KFE [KFE$V_SHARED] = FALSE;
		    !! Perhaps it is now implicitly OPEN
		    RETURN INS$_NOSHRD;
		    END;
		END
	    ELSE		! RSX AME
		BEGIN
		LOCAL
		    N_DSC,	! number of descriptors in RSX image header
		    PAGCNT,
		    VBN;

		!
		!   Would a global section that might exist for this image
		!   be in shared memory?
		!
		STATUS = CHECK_SHMIDENT (GBLSECNAM_DSC, IS_SHRMEM);
		IF NOT .STATUS THEN RETURN .STATUS;
		KFE [KFE$V_SHMIDENT] = .IS_SHRMEM;	! Record SHM state

		!
		!   Set up the match control and IDENT for global sections.
		!   Extract the flags word from the Compatibility mode
		!   image header and see if the TS$NHD bit is set.
		!   If the No_header bit is not set, there is a header, 
		!   so use the date in the header, else use 0.
		!
		KFE [KFE$B_MATCHCTL] = ISD$K_MATEQU;

		IF (.(.IHDBUF + $BYTEOFFSET(L$BFLG) ) <0,16> AND TS$NHD) EQL 0
		THEN
		    KFE [KFE$L_IDENT] = .(.IHDBUF + $BYTEOFFSET (L$BDAT) + 2)
		ELSE
		    KFE [KFE$L_IDENT] = 0;

		!
		!   Obtain VBN and Page count
		!
		IF .(.IHDBUF + $BYTEOFFSET (L$BSYS) ) <0,8> NEQ 4
		THEN			! RSX-11M Task, there are 7 descriptors
		    N_DSC = 0
		ELSE			! Not an RSX-11M task so allow for 8 more descriptors
		    N_DSC = (8 * ($BYTEOFFSET (L$BLIB) - $BYTEOFFSET (L$BPAR)));

		IF (.(.IHDBUF + $BYTEOFFSET(L$BFLG) ) <0,16> AND TS$NHD) EQL 0
		THEN
		    !
		    !   There is a header, so figure out which type so we can 
		    !   skip past the correct number of descriptors to get the
		    !   VBN and PAGE COUNT.
		    !
		    BEGIN
		    VBN = .(.IHDBUF + $BYTEOFFSET (L$BROB) + .N_DSC ) <0,16>;
		    PAGCNT = .(.IHDBUF + $BYTEOFFSET (L$BROL) + .N_DSC ) <0,16>;	! Number of 64 byte units
		    END
		ELSE
		    BEGIN	! There is no header, treat as a Library Common
		    VBN = .(.IHDBUF + $BYTEOFFSET (L$BHRB) + .N_DSC ) <0,16> + 1;
		    PAGCNT = .(.IHDBUF + $BYTEOFFSET (L$BLDZ) ) <0,16>;			! Number of 64 byte units
		    END;

		!
		! Check PAGCNT for zero. If zero, then this task was not built with a shareable
		! section. Don't continue here. Just report the fact that no global sections
		! were created.
		!
		IF .PAGCNT EQL 0
		THEN
		    BEGIN
		    INS$GL_CTLMSK [INS$V_NOGBLSEC] = TRUE;
		    INS$GL_CTLMSK [INS$V_SHARED] = FALSE;
		    KFE [KFE$V_SHARED] = FALSE;
		    KFE [KFE$V_SHMIDENT] = FALSE;
		    END
		ELSE
		    BEGIN
		    PAGCNT = .PAGCNT + 7;		! Round up to next 512 bytes
		    PAGCNT = .PAGCNT / 8;		! Divide to get page count
		    CRESECFLG = SEC$M_GBL OR SEC$M_SYSGBL OR
			        SEC$M_PERM;		! Create a permanent system global section

		    IF .INS$GL_CTLMSK [INS$V_WRITABLE]
		    THEN
		        CRESECFLG = .CRESECFLG OR SEC$M_WRT;

		    !
		    !   Create Global section
		    !
		
		    STATUS = $CRMPSC (
		        INADR = 0,			! Create but don't map
		        ACMODE = PSL$C_USER,		! Access mode
		        FLAGS = .CRESECFLG,		! Mask of create options
		        GSDNAM = GBLSECNAM_DSC,		! Address of descriptor of global section name
		        IDENT = KFE [KFE$B_MATCHCTL],	! Address of quadword containing ident
		        CHAN = .INS$GL_KFECHAN,		! Channel file is open on
		        PAGCNT = .PAGCNT,		! Number of pages in section
		        VBN = .VBN			! Virtual block number
					);
		    IF .STATUS
		    THEN
		        KFE [KFE$W_GBLSECCNT] = 1
		    ELSE
		        RETURN .STATUS;			! Report global section creation failure
		    END;		! Compat with RSX AME
		END;
	    END			! Shared COMPAT


	ELSE
	    !
	    !   Shared Native mode image
	    !
	    BEGIN
	    CRESECFLG = 0;			! Mask of create options

	    !
	    !   Determine the Ident and Match control to use if global sections
	    !   are to be created.  Store in quadword GBLSEC_MATCH_IDENT with
	    !   Ident in second longword.
	    !
	    KFE [KFE$B_MATCHCTL] = ISD$K_MATEQU;			! Default, assuming not shareable image
	    KFE [KFE$L_IDENT] = .IHDBUF [IHD$L_IDENT];			! Use Header ident as default ident
	    IF .KFE [KFE$V_LIM]						! Is it a shareable image?
	    THEN
		BEGIN
		IF .IHDBUF [IHD$V_MATCHCTL] EQL 0
		THEN
		    KFE [KFE$L_IDENT] = 0;				! Match always
		KFE [KFE$B_MATCHCTL] = .IHDBUF [IHD$V_MATCHCTL];
		END;

	    !
	    !   Check if image is in shared memory
	    !   This will affect the ident and match control
	    !
	    STATUS = CHECK_SHMIDENT (GBLSECNAM_DSC, IS_SHRMEM);
	    IF NOT .STATUS THEN RETURN .STATUS;
	    KFE [KFE$V_SHMIDENT] = .IS_SHRMEM;
	    IF .IS_SHRMEM AND NOT .KFE [KFE$V_LIM]
	    THEN
		BEGIN
		!
		!   If its been patched, use patch date as ident,
		!   else use date in Image Header Ident 
		!
		KFE [KFE$L_IDENT] = 
		   (IF .IHDBUF [IHD$W_PATCHOFF] EQL 0
		    THEN
			BEGIN
			BIND
			    IHI = .IHDBUF + .IHDBUF [IHD$W_IMGIDOFF] : BBLOCK;
			.(IHI [IHI$Q_LINKTIME] + 2)
			END
		    ELSE
			BEGIN
			BIND
			    IHP = .IHDBUF + .IHDBUF [IHD$W_PATCHOFF] : BBLOCK;
			.(IHP [IHP$Q_PATDATE] + 2)
			END
		   );
		KFE [KFE$B_MATCHCTL] = ISD$K_MATEQU;
		END;

	    END;	! Initialize for SHARED not COMPAT
	END;	! Initialize for /SHARE


    !+++
    !
    !   Save header if its to be made resident
    !
    !+++

    IF .KFE [KFE$V_HDRRES] 
    THEN
	BEGIN
	BLDHDR_LEN = 512;
	EXECUTE(LIB$GET_VM (BLDHDR_LEN, BLDHDR));
	
	CH$FILL (0, .BLDHDR_LEN, .BLDHDR);	! zero the buffer

	CH$MOVE (.IHDBUF [IHD$W_SIZE], .IHDBUF, .BLDHDR);
	BLDHDR_SIZ = .IHDBUF [IHD$W_SIZE];
	END;


    IF NOT .KFE [KFE$V_COMPATMOD]
    THEN
	BEGIN
    
	!+++
	!
	!   ISD processing loop 
	!
	!+++

	CH$FILL (0, 512, .ISDBUF);
	WHILE (STATUS = IMG$GET_NEXT_ISD (.INS$GL_KFECHAN, .HDRBLK_BUF, .IHDBUF, 
		VBN, OFFSET, .ISDBUF, .HDR_VERSION) ) DO
	    BEGIN

	    IF .KFE [KFE$V_HDRRES] 
	    THEN
		!
		!   Concatenate this ISD onto stored header
		!
		BEGIN
		IF .BLDHDR_SIZ + .ISDBUF [ISD$W_SIZE] GTR .BLDHDR_LEN
		THEN
		    BEGIN
		    LOCAL
			NEW_BLDHDR,
			NEW_BLDHDR_LEN;

		    NEW_BLDHDR_LEN = 2 * .BLDHDR_LEN;
		    EXECUTE(LIB$GET_VM (NEW_BLDHDR_LEN, NEW_BLDHDR));
		    CH$FILL (0, .NEW_BLDHDR_LEN, .NEW_BLDHDR);
		    CH$MOVE (.BLDHDR_SIZ, .BLDHDR, .NEW_BLDHDR);
		    EXECUTE(LIB$FREE_VM (BLDHDR_LEN, BLDHDR));
		    BLDHDR = .NEW_BLDHDR;
		    BLDHDR_LEN = .NEW_BLDHDR_LEN;
		    END;

		CH$MOVE (.ISDBUF [ISD$W_SIZE], .ISDBUF, (.BLDHDR + .BLDHDR_SIZ) );
		BLDHDR_SIZ = .BLDHDR_SIZ + .ISDBUF [ISD$W_SIZE];
		END;	! If /HEAD then save this ISD


	    !
	    !   If /SHARE then create global sections for the images private sections
	    !
	    IF .INS$GL_CTLMSK [INS$V_SHARED]	! /SHARE 
	    THEN
		BEGIN
		BIND
		    ISD = .ISDBUF : BBLOCK;

		IF NOT (.ISD [ISD$V_GBL] OR .ISD [ISD$V_DZRO] 
		    OR .ISD [ISD$V_CRF])
		THEN
		    BEGIN
		    LOCAL
			RETADR : BBLOCK [8];

		    CRESECFLG = .ISDBUF [ISD$L_FLAGS] AND ISD$M_WRT;
		    CRESECFLG = .CRESECFLG OR SEC$M_GBL 
				OR SEC$M_SYSGBL OR SEC$M_PERM;	! Create a permanent system global section

		    IF .ISDBUF [ISD$V_PROTECT] OR
			(.KFE [KFE$V_PROTECT] AND NOT .ISDBUF [ISD$V_WRT])
		    THEN
			BEGIN
			CRESECFLG = .CRESECFLG OR SEC$M_PROTECT;
			CRESECFLG = .CRESECFLG OR PSL$C_EXEC ^ ($BITPOSITION(SEC$V_WRTMOD));
			END;

		    STATUS = $CRMPSC (
			INADR = 0,			! Create but don't map
			RETADR = RETADR,		! Create but don't map
			ACMODE = PSL$C_USER,		! Access mode
			FLAGS = .CRESECFLG,		! Mask of create options
			GSDNAM = GBLSECNAM_DSC,		! Address of descriptor of global section name
			IDENT = KFE [KFE$B_MATCHCTL],	! Address of quadword containing ident
			RELPAG = 0,			! Create, don't map
			CHAN = .INS$GL_KFECHAN,		! Channel file is open on
			PAGCNT = .ISDBUF [ISD$W_PAGCNT],! Number of pages in section
			VBN = .ISDBUF [ISD$L_VBN],	! Virtual block number
			PROT = 0,			! Default protection mask
							!! want to ignore PFC if cross linker format
			PFC = .ISDBUF [ISD$B_PFC]	! Page fault cluster size
				    );
		    IF .STATUS
		    THEN
			BEGIN
			INS$BLD_GBLSECNAM (GBLSECNAM_DSC);	! Increment for the next global section name, FILENAM_nnn
			KFE [KFE$W_GBLSECCNT] = .KFE [KFE$W_GBLSECCNT] + 1;
			END
		    ELSE
			RETURN .STATUS;
		    END;
		END;			! End of processing this ISD for /SHARE

	    CH$FILL (0, 512, .ISDBUF);
	    END;				! While getting ISD's 

	IF NOT .STATUS AND (.STATUS NEQ IMG$_ENDOFHDR)
	THEN
	    BEGIN
	    RETURN .STATUS;
	    END;

	IF .INS$GL_CTLMSK [INS$V_SHARED] AND (.KFE [KFE$W_GBLSECCNT] EQLU 0)
	THEN
	    BEGIN
	    INS$GL_CTLMSK [INS$V_NOGBLSEC] = TRUE;
            INS$GL_CTLMSK [INS$V_SHARED] = FALSE;
            KFE [KFE$V_SHARED] = FALSE;
            KFE [KFE$V_SHMIDENT] = FALSE;
            END;

	IF .KFE [KFE$V_HDRRES] 
	THEN
	    !
	    !   Make the header resident
	    !
	    BEGIN
	    LOCAL
		KFRH : REF BBLOCK;

	    LENGTH = KFRH$C_LENGTH + .BLDHDR_SIZ + 4;	! Leave longword of zeros to mark end
	    EXECUTE(ALLOC_PAGED ( .LENGTH, KFRH ));
	    CH$FILL (0, .LENGTH, .KFRH);		! zero the KFRH

	    KFRH [KFRH$W_ALIAS] = .ALIAS;
	    KFRH [KFRH$W_SIZE] = .LENGTH;
	    KFRH [KFRH$B_TYPE] = DYN$C_KFRH;
	    KFRH [KFRH$B_HDRVER] = .HDR_VERSION;
	    KFE [KFE$L_IMGHDR] = KFRH [KFRH$T_IHD];
	    CH$MOVE (.BLDHDR_SIZ, .BLDHDR, KFRH [KFRH$T_IHD]);
	    KFRH [KFRH$L_BUFEND] = KFRH [KFRH$T_IHD] + .BLDHDR_SIZ;
	    EXECUTE(LIB$FREE_VM(BLDHDR_SIZ,BLDHDR));	!Deallocate the header
	    END;
	END;					! /OPEN but not COMPAT

    KFE [KFE$W_SHRCNT] = 1;			! Initialize shared counter (normalized on display)
    WCB = .CCB [CCB$L_WIND];			! window address
    KFE [KFE$L_WCB] = .WCB;			! Save window address
    !
    ! This call is effectively a no-op if any global sections had been created
    !
    MMG$RET_BYT_QUOTA (.WCB);			! Return byte quota since file was being opened for everyone
    WCB [WCB$W_REFCNT] = .WCB [WCB$W_REFCNT] +1;! jimmy window so the shared
						!  file remains open.
    END;

STATUS = ENTER_KFE (.KFE, .HASH_INDEX, .BLDKFDBUF, .KFD_INSERT_ADR);

RETURN .STATUS;
END;		! routine CREATE


%SBTTL 'alloc_paged  Allocate memory from paged pool';

ROUTINE  ALLOC_PAGED (LEN, ADR) =
BEGIN
!+++
!
!  FUNCTIONAL DESCRIPTION:
!
!	Jacket routine for calling paged pool allocation routine.
!	Specify the length of block required and get the address of
!	allocated block returned in ADR.
!
!---

GLOBAL REGISTER
    LENGTH = 1,		! Length to allocate
    ENTRY_BLOCK = 2;	! Address of allocated block

LOCAL
    STATUS;

LENGTH = .LEN;		! Place length into R1

STATUS = EXE$ALOPAGED ();	! Allocate from paged pool

.ADR = .ENTRY_BLOCK;	! Return address of block

IF NOT .STATUS
    THEN STATUS = INS$_NOPAGEDYN;

RETURN .STATUS;
END;			! Routine ALLO_PAGED


%SBTTL 'find_kfd  Locate Device, Directory, Type block for KFE';

ROUTINE  FIND_KFD (NAMBLK, INSERT_KFD_ADR) =
BEGIN
!+++
!
!  FUNCTIONAL DESCRIPTION:
!
!	Given a name block for a file, figure out which KFD list it
!	would be in.  If it is in a KFD list, return the address
!	of the KFD in R0.  If the KFD doesn't exist, then return 0
!	and place the address of where the KFD should go when it's
!	created into INSERT_KFD_ADR.
!
!---
MAP
    NAMBLK : REF BBLOCK;

BIND
    INSERT_KFD = .INSERT_KFD_ADR,
    KFPB = EXE$GL_KNOWN_FILES : REF BBLOCK;

LOCAL
    KFD : REF BBLOCK,
    DDTSTR : BBLOCK [NAM$C_MAXRSS],
    DDT_DSC : $BBLOCK [DSC$C_S_BLN],
    PRV_KFD;			! Previous KFD

IF .KFPB EQL 0			! There is no pointer block yet
THEN 
    BEGIN
    INSERT_KFD = 0;
    RETURN 0;
    END;

IF .KFPB [KFPB$L_KFDLST] EQL 0	! If there are no KFDs in list
THEN
    BEGIN			! Make it the first
    INSERT_KFD = KFPB [KFPB$L_KFDLST];
    RETURN 0;			! There are no KFDs
    END;

!
!   Build an ASCII string of the concatenated Device, Directory
!   Type strings.
!
DDT_DSC [DSC$W_LENGTH] = .NAMBLK [NAM$B_DEV] + .NAMBLK [NAM$B_DIR] +
			.NAMBLK [NAM$B_TYPE];	! Length of DDT string

DDT_DSC [DSC$A_POINTER] = DDTSTR;
DDT_DSC [DSC$A_POINTER] = CH$MOVE (.NAMBLK [NAM$B_DEV], .NAMBLK [NAM$L_DEV],
				.DDT_DSC [DSC$A_POINTER]);
DDT_DSC [DSC$A_POINTER] = CH$MOVE (.NAMBLK [NAM$B_DIR], .NAMBLK [NAM$L_DIR],
				.DDT_DSC [DSC$A_POINTER]);
DDT_DSC [DSC$A_POINTER] = CH$MOVE (.NAMBLK [NAM$B_TYPE], .NAMBLK [NAM$L_TYPE],
				.DDT_DSC [DSC$A_POINTER]);

DDT_DSC [DSC$A_POINTER] = DDTSTR;
INS$CVT_DIR (DDT_DSC);		! Convert and compress directory brackets
!
!   Traverse the KFD list to find a KFD block with a matching DDT string.
!   If no match is found, record address of block after which a new KFD
!   block containing the new DDT string should be inserted.
!
PRV_KFD = KFPB [KFPB$L_KFDLST];
KFD = .KFPB [KFPB$L_KFDLST];
WHILE .KFD NEQ 0 DO		! Single linked list ending in zero
    BEGIN
    CASE CH$COMPARE (.DDT_DSC [DSC$W_LENGTH], DDTSTR,
		.KFD [KFD$B_DDTSTRLEN], KFD [KFD$T_DDTSTR], %C' ')
    FROM -1 TO 1 OF		! Either less than, equal to, or greater than
	SET

	[-1]:	! Less than, therefore its not in the list
	    BEGIN
	    INSERT_KFD = .PRV_KFD;	! Return Previous KFD to caller
	    RETURN 0;			! Return KFD not found
	    END;
	    
	[0] :
	    BEGIN
	    INSERT_KFD = 0;		! Return a ZERO to caller
	    RETURN .KFD;		! Return KFD found
	    END;

	[1] :	! Greater than, 
	    BEGIN
	    PRV_KFD = .KFD;		! Current KFD now becomes previous
	    KFD = .KFD [KFD$L_LINK];	! Follow link for next current KFD
	    END;
	TES;
    END;			! WHILE traversing KFD list

!
!   Traversed whole list without finding match or finding where it
!   should fit in list, so put it at the end
!
INSERT_KFD = .PRV_KFD;
RETURN 0;
END;				! Routine find_kfd


%SBTTL 'build_kfd  Build a Device, Directory, Type block for the KFE';

ROUTINE  BUILD_KFD (NAMBLK,KFDBUF) : NOVALUE =
BEGIN
!+++
!
!  FUNCTIONAL DESCRIPTION:
!
!	Given the file info in the NAM block, construct a KFD entry.
!	A KFD entry is a list head for all known file entries which 
!	share the same Device, directory and file type.
!
! INPUTS:
!
!	NAMBLK = Address of the NAM block
!	KFDBUF = Address of the buffer to build the kfd in
!			(must be KFD$C_LENGTH+NAM$C_MAXRSS in length)
!---
MAP
    NAMBLK : REF BBLOCK,
    KFDBUF : REF $BBLOCK;

LOCAL
    DDT_DSC : $BBLOCK [DSC$C_S_BLN],
    PTR,
    PTR2,
    LENGTH;

DDT_DSC [DSC$W_LENGTH] = .NAMBLK [NAM$B_DEV] + .NAMBLK [NAM$B_DIR] +
			.NAMBLK [NAM$B_TYPE];	! Length of DDT string
LENGTH = KFD$C_LENGTH + .DDT_DSC [DSC$W_LENGTH];

CH$FILL (0, .LENGTH, .KFDBUF);			! zero the KFD
KFDBUF [KFD$W_SIZE] = .LENGTH;
KFDBUF [KFD$B_TYPE] = DYN$C_KFD;
KFDBUF [KFD$B_DDTSTRLEN] = .DDT_DSC [DSC$W_LENGTH];

!
!   Build a counted ASCII string of the concatenated Device, Directory
!   Type strings.
!
DDT_DSC [DSC$A_POINTER] = KFDBUF [KFD$T_DDTSTR];
KFDBUF [KFD$B_DEVLEN] = .NAMBLK [NAM$B_DEV];
DDT_DSC [DSC$A_POINTER] = CH$MOVE (.NAMBLK [NAM$B_DEV], .NAMBLK [NAM$L_DEV],
				.DDT_DSC [DSC$A_POINTER]);
KFDBUF [KFD$B_DIRLEN] = .NAMBLK [NAM$B_DIR];
DDT_DSC [DSC$A_POINTER] = CH$MOVE (.NAMBLK [NAM$B_DIR], .NAMBLK [NAM$L_DIR],
				.DDT_DSC [DSC$A_POINTER]);
DDT_DSC [DSC$A_POINTER] = CH$MOVE (.NAMBLK [NAM$B_TYPE], .NAMBLK [NAM$L_TYPE],
				.DDT_DSC [DSC$A_POINTER]);

LENGTH = .DDT_DSC [DSC$W_LENGTH];	! Save current DDT length
DDT_DSC [DSC$A_POINTER] = KFDBUF [KFD$T_DDTSTR];
INS$CVT_DIR (DDT_DSC);			! Convert and compress directory brackets
!
! Calculate amount of string compression that occurred and
! correct the fields in the KFD where appropriate.
!
LENGTH = .LENGTH - .DDT_DSC [DSC$W_LENGTH];
KFDBUF [KFD$B_DIRLEN] = .KFDBUF [KFD$B_DIRLEN] - .LENGTH;
KFDBUF [KFD$W_SIZE] = .KFDBUF [KFD$W_SIZE] - .LENGTH;
KFDBUF [KFD$B_DDTSTRLEN] = .KFDBUF [KFD$B_DDTSTRLEN] - .LENGTH;
RETURN;
END;			! Routine build_kfd


%SBTTL 'Enter_kfe  Enter the KFE into the hash table and KFE list';

ROUTINE  ENTER_KFE (KFE_TMP, HSHIDX, NEWKFD, NEWKFD_INSERT_ADR) =
BEGIN
!+++
!
!  FUNCTIONAL DESCRIPTION:
!
!	Place the KFE into the KFD list and the Hash table list.
!	The Hash list is the one used by RMS open to determine if
!	the file is installed.  The KFD list is the ordered list
!	which is traversed when the known file data base is LISTed.
!
!	KFE_TMP		Address of temporary block containing copy of KFE
!	HSHIDX		Index into hash table where entry should be inserted
!	NEWKFD		Address of KFD entry if this KFE was first in a new
!			 KFD list
!	NEW_KFD_INSERT_ADR
!			Address in KFD list in which to place the new KFD if
!			one was required.
!
!---
MAP
    KFE_TMP : REF BBLOCK,
    NEWKFD : REF $BBLOCK,
    NEWKFD_INSERT_ADR : REF BBLOCK;

LOCAL
    HSHTAB : REF VECTOR [,LONG],
    KFD : REF BBLOCK,
    KFE : REF $BBLOCK;

BIND
    KFPB = EXE$GL_KNOWN_FILES : REF BBLOCK;

INS$CNVRT_KF_LOCK (LCK$K_EXMODE);	! Convert protected read to exclusive
					!  to lock out any image activations

SET_IPL (IPL$_ASTDEL);
EXECUTE(ALLOC_PAGED ( .KFE_TMP [KFE$W_SIZE], KFE));
CH$MOVE ( .KFE_TMP [KFE$W_SIZE], .KFE_TMP, .KFE);	! Copy temp to paged pool

IF .KFPB EQL 0 
THEN
    BEGIN
    !
    !   Allocate Known file pointer block
    !
    EXECUTE(ALLOC_PAGED (KFPB$C_LENGTH, KFPB));
    CH$FILL (0, KFPB$C_LENGTH, .KFPB);
    KFPB [KFPB$W_SIZE] = KFPB$C_LENGTH;
    KFPB [KFPB$B_TYPE] = DYN$C_KFPB;

    !
    !   NEWKFD_INSERT_ADR must have been zero since there was no header
    !   block before now.  So the KFD for the KFE being inserted will be
    !   the first in the list.
    !
    NEWKFD_INSERT_ADR = KFPB [KFPB$L_KFDLST];

    !
    !   Allocate Hash table
    !
    EXECUTE(ALLOC_PAGED (4 * .SGN_B_KFHSHSIZ, KFPB [KFPB$L_KFEHSHTAB]));
    KFPB [KFPB$W_HSHTABLEN] = .SGN_B_KFHSHSIZ;
    CH$FILL (0, 4 * .SGN_B_KFHSHSIZ, .KFPB [KFPB$L_KFEHSHTAB]);
    END;

HSHTAB = .KFPB [KFPB$L_KFEHSHTAB];

    !
    !   Search the hash bucket linked list for insertion point
    !
    BEGIN
    LOCAL
	CMPKFE : REF BBLOCK,
	PRVKFE : REF BBLOCK;

    PRVKFE = HSHTAB [.HSHIDX];		! Previous KFE
    CMPKFE = .HSHTAB [.HSHIDX];		! Comparison KFE
    WHILE .CMPKFE NEQ 0 DO		! Single linked list ending in zero
	BEGIN
	CASE CH$COMPARE (.KFE [KFE$B_FILNAMLEN], KFE [KFE$T_FILNAM], 
		.CMPKFE [KFE$B_FILNAMLEN], CMPKFE [KFE$T_FILNAM], %C' ')
	FROM -1 TO 1 OF			! Either less than, equal to, or greater than
	    SET

	    [-1]:	! Less than, therefore its not in the list, insert here
		BEGIN
		KFE [KFE$L_HSHLNK] = .PRVKFE [KFE$L_HSHLNK];
		PRVKFE [KFE$L_HSHLNK] =  KFE [KFE$L_HSHLNK];
		PRVKFE = 0;	! Mark as inserted
		CMPKFE = 0;	! Terminate traversal
		END;
	    
	    [0] :	! Same file name, place newest in front
		BEGIN
		KFE [KFE$L_HSHLNK] = .PRVKFE [KFE$L_HSHLNK];
		PRVKFE [KFE$L_HSHLNK] =  KFE [KFE$L_HSHLNK];
		PRVKFE = 0;	! Mark as inserted
		CMPKFE = 0;	! Terminate traversal
		END;

	    [1] :	! Greater than, 
		BEGIN
		PRVKFE = .CMPKFE;
		CMPKFE = .CMPKFE [KFE$L_HSHLNK];
		END;
	    TES;
	END;			! WHILE traversing hash bucket list

    !
    !   Have traversed whole list.  If PRVKFE has been set to 0, then
    !   it was inserted, else it goes at the end.
    !
    IF .PRVKFE NEQ 0
    THEN
	PRVKFE [KFE$L_HSHLNK] = .KFE;
    END;			! Block for inserting KFE into Hash bucket list

KFPB [KFPB$W_KFDLSTCNT] = .KFPB [KFPB$W_KFDLSTCNT] + 1;

KFD = .KFE [KFE$L_KFD];
IF .KFD EQL 0
THEN
    BEGIN
    EXECUTE(ALLOC_PAGED(.NEWKFD[KFD$W_SIZE],KFD));
    CH$MOVE(.NEWKFD[KFD$W_SIZE],.NEWKFD,.KFD);		!Copy the KFD
    KFE [KFE$L_KFD] = .KFD;
    !
    !   New KFD must be inserted into list
    !
    KFD [KFD$L_LINK] = .NEWKFD_INSERT_ADR [KFD$L_LINK];
    .NEWKFD_INSERT_ADR = .KFD;

    KFPB [KFPB$W_KFDLSTCNT] = .KFPB [KFPB$W_KFDLSTCNT] + 1;
    END;

KFD [KFD$W_REFCNT] = .KFD [KFD$W_REFCNT] + 1;

!
!   Now thread the filename ordered list from the KFD
!
IF .KFD [KFD$L_KFELIST] EQL 0
THEN
    !
    !   The list is empty, so make this the first entry
    !
    KFD [KFD$L_KFELIST] = .KFE
ELSE
    !
    !   Must be inserted somewhere in the ordered list of KFEs
    !
    BEGIN
    LOCAL
	CMPKFE : REF BBLOCK,
	PRVKFE : REF BBLOCK;


    PRVKFE = .KFD;			! Initialize Previous KFE
					! *** CAUTION *** 
					! This assumes kfd$l_kfelist = kfe$l_kfelist

    CMPKFE = .KFD [KFD$L_KFELIST];	! Comparison KFE
    WHILE .CMPKFE NEQ 0 DO		! Single linked list ending in zero
	BEGIN
	CASE CH$COMPARE (.KFE [KFE$B_FILNAMLEN], KFE [KFE$T_FILNAM], 
		.CMPKFE [KFE$B_FILNAMLEN], CMPKFE [KFE$T_FILNAM], %C' ')
	FROM -1 TO 1 OF			! Either less than, equal to, or greater than
	    SET

	    [-1]:	! Less than, therefore its not in the list, insert here
		BEGIN
		KFE [KFE$L_KFELINK] = .CMPKFE;
		PRVKFE [KFE$L_KFELINK] =  .KFE;
		PRVKFE = 0;	! Mark as inserted
		CMPKFE = 0;	! Terminate traversal
		END;
	    
	    [0] :	! Same file name in same KFD, is a serious bug
		BEGIN
		INS$L_INTRNLERR = DUPINKFD_ERR_DSC;
		INS$CNVRT_KF_LOCK (LCK$K_PRMODE);	! Convert exclusive to protected read
		SET_IPL (0);				! Drop IPL before returning error status
		RETURN INS$_INTRNLERR;
		END;

	    [1] :	! Greater than, 
		BEGIN
		PRVKFE = .CMPKFE;
		CMPKFE = .CMPKFE [KFE$L_KFELINK];
		END;
	    TES;
	END;			! WHILE traversing KFD's ordered KFE list

    !
    !   Have traversed whole list.  If PRVKFE has been set to 0, then
    !   it was inserted, else it goes at the end.
    !
    IF .PRVKFE NEQ 0
    THEN
	PRVKFE [KFE$L_KFELINK] = .KFE;
    END;		! Insert KFE in ordered KFE list

SET_IPL (0);

INS$GL_KFEADR = .KFE;			! Return new KFE address in case of /LOG

INS$CNVRT_KF_LOCK (LCK$K_PRMODE);	! Convert exclusive to protected read
					!  to allow image activations

RETURN TRUE;
END;			! Routine Enter_kfe


%SBTTL 'Verify_channel  Is the file on the system device';

ROUTINE  VERIFY_CHANNEL (CHAN, RET_CCB_ADR) =
BEGIN
!+++
!
!  FUNCTIONAL DESCRIPTION:
!
!	Given the channel number, return the address of the
!	Channel Control Block.
!
!	CHAN		Channel number
!	RET_CCB_ADR	Longword in which to return CCB address 
!---
LOCAL
    STATUS;
GLOBAL REGISTER
    CCB = 1;
MAP
    CCB : REF BBLOCK;
BIND
    RET_CCB = .RET_CCB_ADR;

!
!   Obtain the Channel Control Block
!
STATUS = IOC$VERIFYCHAN (.CHAN);
RET_CCB = .CCB;
RETURN .STATUS;
END;			! Routine Verify_channel


%SBTTL 'Check_shmident  Is the section in shared memory';

ROUTINE  CHECK_SHMIDENT (GBLNAMDSC, RET_IN_SHRMEM) =
BEGIN
!+++
!
!  FUNCTIONAL DESCRIPTION:
!
!	Check to see if the global section name translates to a name
!	which would place it in shared memory.
!
!---
LOCAL
    NAM_DSC : BBLOCK [DSC$C_S_BLN],
    SHRMEMNAM_DSC : BBLOCK [DSC$C_S_BLN],
    SHRMEMNAM_BUF : BBLOCK [15],
    GSDNAM_DSC : BBLOCK [DSC$C_S_BLN],
    GSDNAM_BUF : BBLOCK [43],
    STATUS;

GLOBAL REGISTER
    SHRMEMNAM = 10,
    GSDNAM = 11;
BIND
    IN_SHARED_MEM = RET_IN_SHRMEM;

CH$MOVE (DSC$C_S_BLN, .GBLNAMDSC, NAM_DSC);		! Copy the descriptor
NAM_DSC [DSC$W_LENGTH] = .NAM_DSC [DSC$W_LENGTH] - 4;	! Drop the _000
SHRMEMNAM_DSC = 0;					! Zero length
SHRMEMNAM_DSC [DSC$W_LENGTH] = 15;			! Zero length
SHRMEMNAM_DSC [DSC$A_POINTER] = SHRMEMNAM_BUF;		! Set pointer to buffer on stack
SHRMEMNAM = SHRMEMNAM_DSC;				! Place address of descriptor in R10
GSDNAM_DSC = 0;						! Zero the length
GSDNAM_DSC [DSC$W_LENGTH] = 43;				! Zero the length
GSDNAM_DSC [DSC$A_POINTER] = GSDNAM_BUF;		! Set pointer to buffer on stack
GSDNAM = GSDNAM_DSC;					! Place address of descriptor in R11

STATUS = MMG$GSDTRNLOG ( NAM_DSC );			! Translate logical name to see if section name has a shared memory ident
.IN_SHARED_MEM = (IF .SHRMEMNAM_DSC [DSC$W_LENGTH] NEQ 0
		THEN TRUE				! Return true if there was a shared memory name translation
		ELSE FALSE);
RETURN .STATUS;
END;			! Routine Check_shmident


%SBTTL 'INS$BLD_GBLSECNAM  Build the global section name string';

GLOBAL ROUTINE  INS$BLD_GBLSECNAM (GBLNAMDSC) =
BEGIN
!+++
!
!  FUNCTIONAL DESCRIPTION:
!
!	Build the global section name.  If the name does not exist,
!	get the root from the NAM block and append _001.  If it does
!	exist, increment the suffix.
!
!---
LOCAL
    NAMSTR : REF BBLOCK,
    PTR;
BIND
    GBLNAM_SUFFIX = UPLIT (%ASCII '_001') : VECTOR [,BYTE];	! First suffix
MAP
    GBLNAMDSC : REF BBLOCK;

NAMSTR = .GBLNAMDSC [DSC$A_POINTER];				! Pointer to last global section name, or zeroed storage
IF .GBLNAMDSC [DSC$W_LENGTH] EQL 0				! If the name is zeroed then this is the first
THEN
    BEGIN
    GBLNAMDSC [DSC$W_LENGTH] = .INS$G_KFENAM [NAM$B_NAME] + 4;	! Size is filename length plus 4 for _001
    PTR = .NAMSTR;						! Point past count byte
    PTR = CH$MOVE (.INS$G_KFENAM [NAM$B_NAME], .INS$G_KFENAM [NAM$L_NAME], .PTR);	! Move filename in
    CH$MOVE (4, GBLNAM_SUFFIX, .PTR);				! Move _001 suffix in
    END
ELSE
    BEGIN							! Name has already been built, increment the suffix number
    PTR = .NAMSTR + .GBLNAMDSC [DSC$W_LENGTH] - 1;		! Locate last digit of suffix number
    WHILE ( .(.PTR) <0,8> NEQ %C'_' ) DO			! Don't want carry to clobber the '_' separater
	BEGIN
	(.PTR) <0,8> = .(.PTR) <0,8> + 1;			! Add one to suffix number

	IF ( .(.PTR) <0,8> GTR %C'9' )				! If that raises it over '9' than make it a zero and carry 1
	THEN
	    BEGIN
	    (.PTR) <0,8> = %C'0';				! Make '9' into a '0'
	    PTR = .PTR - 1;					! Move to next highest decimal place
	    END
	ELSE
	    RETURN TRUE;
	END;
    END;

RETURN TRUE;
END;			! Routine INS$BLD_GBLSECNAM


END		! Module inscreate
ELUDOM
