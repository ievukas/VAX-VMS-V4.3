MODULE SMG$INPUT ( %TITLE 'Screen Management Facility Input Procedures'
		IDENT = '2-017'		! File: SMGINPUT.B32 Edit: STAN2017
		) =
BEGIN
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY:	Screen Management Facility
!
! ABSTRACT:
!
!	This module contains the portions of the VAX-11 Run-Time Library
!	Screen Management Facility which deal with input.
!
! ENVIRONMENT:	User mode - AST reentrant
!
! AUTHOR: Steven B. Lionel, CREATION DATE: 10-Feb-1983
!
! MODIFIED BY:
!
! 1-001	- Original.  SBL 10-Feb-1983
! 1-002 - Add variant code to allow READ_STRING to work on a V3.n system.
!	  Fix READ_COMPOSED_LINE so that the equivalence string of the final
!	  key is remembered by the terminal-driver for line-recall.  Use
!	  a <CR> as a prompt if none is specified.
!	  SBL 18-May-1983
! 1-003 - Remember /LOCK'ed states across multiple reads.  Do "right" thing
!	  with ^Z, undefined keys in the middle of lines.  SBL 23-Jun-1983
! 1-004 - Prevent last echo in READ_COMPOSED_LINE unless there is
!	  something to echo.  SBL 28-Jul-1983
! p-003 - Modify SMG$CREATE_VIRTUAL_KEYBOARD and SMG$READ_STRING to 
!	  interface with screen management output.  PLL 16-Jun-1983
! p-004 - More modifications for integration.  PLL 21-Jun-1983
! p-005 - SMG$$SET_PHYSICAL_CURSOR now takes a longword buffer length,
!	  instead of word.  PLL 28-Jun-1983
! p-006 - Fix a couple bugs in SMG$READ_STRING.  PLL 29-Jun-1983
!	   1.  Use default rendition for virtual display for prompt/input.
!	   2.  If at the boundary of the virtual display, then there is no
!	       room for input - issue an error.
! 2-001 - Combined Steves edits 1-003 and 1-004 with Pam's edits
!	  1-003 through 1-006 and added some stuff of my own.
!	  STAN 2-Aug-1983.
! 2-002 - FINISHED INPUT/OUTPUT INTEGRATION. STAN 3-Aug-1983.
! 2-003 - Bug fixes to SMG$READ_STRING for terminators and modifier
!	  masks.  PLL 9-Aug-1983
! 2-004 - Another attempt to get 3a modifiers recognized.  Also, pass the
!	  terminator to the smg$ output routines - the terminator may affect
!	  the cursor position.  PLL 16-Aug-1983
! 2-005 - In SMG$READ_STRING, don't report the change if NOECHO was requested.
!	  PLL 18-Aug-1983
! 2-006 - Fix last edit.  PLL 22-Aug-1983
! 2-007 - In SMG$READ_STRING, don't report the terminator if TRMNOECHO was
!	  requested.  PLL 9-Sep-1983
! 2-008 - Another fix to SMG$READ_STRING:  if a partial escape sequence 
!	  terminated the read, do single character QIOs till we find the end
!	  of the terminator.  (This prevents keypad keys from echoing on the
!	  screen.)  PLL 13-Sep-1983
! 2-009 - Cleanup SMG$READ_COMPOSED_LINE.  PLL 5-Oct-1983
! 2-010 - GIVE ERROR if try to input to a batched display. STAN 14-Mar-1984.
!	  Fix length of buffers for renditions.
!	  Make renditions work.
!	  Change echo of CTRL/Z to track terminal driver change.
! 2-011 - Return terminator code of SMG$K_TRM_TIMEOUT on timeout. STAN
! 2-012 - Turn off renditions only if DCB was passed. STAN 28-MAR-1984.
! 2-013 - Add the codes for F1-F20 function keys, and editing keys to the code
!	  that checks for partial escapes.  PLL 2-Apr-1984
! 2-014 - Validate number of arguments. STAN 3-Jun-1984.
!	  Add F1-F20 code for READ COMPOSE LINE.
! 2-015 - Take CTRL/Z echo from system logical TTY$EXIT_STRING. STAN 7-Jul-1984.
! 2-016 - Fix to partial escape handling - after we find the end of the 
!	  terminator, fix the return status to be success.  PLL 9-Jul-1984
! 2-017 - Remove call to TRNLNM on V3 systems. STAN 24-Jul-1984.
!	  Remove informational errors.
!--

%SBTTL 'Declarations'
!
! PROLOGUE FILE:
!

REQUIRE 'RTLIN:SMGPROLOG';			! Screen management definitions

!
! TABLE OF CONTENTS:
!

FORWARD ROUTINE
    SMG$CREATE_VIRTUAL_KEYBOARD,		! Create a virtual keyboard
    SMG$DELETE_VIRTUAL_KEYBOARD,		! Delete a virtual keyboard
    SMG$READ_STRING,				! Read a string
    SMG$READ_COMPOSED_LINE,			! Read a composed line
    SMG$SET_KEYPAD_MODE,			! Set mode of numeric keypad
    SMG$CANCEL_INPUT,				! Cancel outstanding input
    SMG$$SET_PROMPT_STRING,			! Create a prompt string
    SMG$$DELETE_PROMPT_STRING: NOVALUE,		! Delete a prompt string
    SMG$$INIT_QUEUES,				! Initialize queues
    SMG$$CLEANUP: SMG$$CLEANUP$LNK,		! Cleanup from error or close
    SMG$$INPUT_EXIT_HANDLER: NOVALUE;		! Exit handler for input

!
! MACROS:
!
!	NONE
!
! EQUATED SYMBOLS:
!

LITERAL
    K_QPS_SIZE = 90;	! Size of prompt strings on QPS_QUEUE.
			! 80 character bytes + possibly a 10 byte
			! set cursor sequence.

!
! FIELDS:
!
!	NONE
!
! OWN STORAGE:
!

!+
! Queues of control blocks and prompt strings.
!-

OWN
    KQB_QUEUE: VOLATILE VECTOR [2, LONG], 	! Keyboard Queue Block
    QPS_QUEUE: VOLATILE VECTOR [2, LONG], 	! Queued Prompt Strings
    V_QUEUE_INIT: VOLATILE INITIAL (0);	! 1 if queues have been initialized

!+
! Declare strings which set the keypad into and out of applications mode.
!-

OWN
    T_KPDAPP_DECCRT:	! Sets DECCRT (and VT5x) into applications mode
	VECTOR [2, BYTE] PSECT (_SMG$CODE) INITIAL (BYTE (27,'=')),
    T_KPDNUM_DECCRT:	! Sets DECCRT and (VT5x) into numeric mode
	VECTOR [2, BYTE] PSECT (_SMG$CODE) INITIAL (BYTE (27,'>'));
	
!    
!
! EXTERNAL DECLARATIONS:
!

EXTERNAL ROUTINE
    LIB$GET_EF,			! Allocate local event flag number
    LIB$FREE_EF,		! Free local event flag number
    LIB$GET_VM,			! Allocate virtual memory
    LIB$FREE_VM,		! Deallocate virtual memory
    LIB$ANALYZE_SDESC_R2: LIB$ANALYZE_SDESC_R2$LINKAGE,	! Analyze string desc
    LIB$SCOPY_R_DX,		! Copy string
    LIB$SCOPY_R_DX6: LIB$SCOPY_R_DX6$LINKAGE,	! Copy string
    SMG$$TERM_TO_KEYCODE,	! Translate terminator to keycode
    SMG$$LOOKUP_KEY: SMG$$LOOKUP_KEY$LNK,	! Lookup item in tree
    SMG$$GET_PASTEBOARD_ID,	! SMG$ I/O interface routine
    SMG$$SET_PHYSICAL_CURSOR,   !  "
    SMG$$REPORT_CHANGE_REPLACE, !  "
    SMG$$OUTPUT,		! Output directly to terminal
    SMG$$SET_ATTRIBUTES_ON,	! Set attributes on
    SMG$$SET_ATTRIBUTES_OFF,	! Set attributes off
    SYS$QIOW;			! $QIOW system service

EXTERNAL LITERAL
    SMG$_STRTERESC,	! String terminated by escape
    SMG$_EOF,		! End-of-file
    SMG$_FILTOOLON,	! File-specification is too long (over 255 characters)
    SMG$_ILLBATFNC,	! Operation not permitted while display is batched
    SMG$_INVMAXLEN,	! Invalid maximum length (greater than 512 characters)
    SMG$_INVSTANAM,	! Invalid state name
    SMG$_PROTOOLON,	! Prompt string is too long
    SMG$_INVCOL,	! Invalid column
    SMG$_INVDIS_ID;	! Invalid display id

EXTERNAL
    LIB$AB_UPCASE;	! Upcase translate table

%SBTTL 'SMG$CREATE_VIRTUAL_KEYBOARD'
GLOBAL ROUTINE SMG$CREATE_VIRTUAL_KEYBOARD (
    KEYBOARD_ID: REF VECTOR [, LONG],
    FILESPEC: REF BLOCK [, BYTE],
    DEFAULT_FILESPEC: REF BLOCK [, BYTE],
    RESULTANT_FILESPEC: REF BLOCK [, BYTE]
    ) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This procedure creates the association between a filespec (terminal
!	name or RMS file) and a virtual-keyboard-identifier.  The keyboard-id
!	is passed to other screen management procedures to uniquely identify
!	the input stream being acted upon.
!
!	If "filespec" does not refer to a terminal, the file is opened using
!	RMS and all further access to that file is performed through RMS.  If
!	"filespec" is a terminal, a channel is assigned to the terminal, its
!	keypad is set to "application mode" (if supported), and line editing
!	is enabled.  These attributes are restored to their previous values
!	when the virtual-keyboard is deleted, either by a call to
!	SMG$DELETE_VIRTUAL_KEYBOARD or automatically when the image exits.
!
! CALLING SEQUENCE:
!
!	RET_STATUS.wlc.v = SMG$CREATE_VIRTUAL_KEYBOARD (
!				KEYBOARD-ID.wl.r
!				[, [FILESPEC.rt.dx]
!				[, [DEFAULT_FILESPEC.rt.dx]
!				[, [RESULTANT_FILESPEC.wt.dx] ]]])
!
! FORMAL PARAMETERS:
!
!	KEYBOARD-ID	A longword into which will be written the
!			virtual-keyboard-id of the created virtual-keyboard.
!
!	FILESPEC	A string containing the file specification of the
!			file or terminal to be used for this virtual-keyboard.
!			If omitted, 'SYS$INPUT:' is used.
!
!	DEFAULT_FILESPEC A string containing the default file specification.
!			If omitted, the null string is used.
!
!	RESULTANT_FILESPEC A string into which is written the expanded or
!			resultant file specification of the file used.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	SS$_NORMAL	Normal successful completion
!	SMG$_FILTOOLON	File-specification is too long (over 255 characters)
!	SMG$_WRONUMARG	Wrong number of arguments
!	LIB$_INSEF	Insufficient event flags
!	LIB$_INSVIRMEM	Insufficient virtual memory
!	LIB$_INVSTRDES	Invalid string descriptor
!	RMS$_xyz	Any error possible from $OPEN or $CONNECT
!	SS$_xyz		Any error possible from $GETDVIW, $ASSIGN or $DCLEXH
!
! SIDE EFFECTS:
!
!	Opens file using RMS or assigns a channel to it.
!	Declares an exit handler
!	Sets terminal to keypad application mode.
!
!--

    BEGIN

    LOCAL
	KCB: REF KCB_R_KCB_STRUCT,		! Keyboard Control Block
	FAB: $FAB_DECL,				! RMS File Attributes Block
	NAM: $NAM_DECL,				! RMS NAM block
	XAB_FHC: $XABFHC_DECL,			! File Header Char. XAB
	RESULTANT_STRING: VECTOR [NAM$C_MAXRSS, BYTE]; ! Resultant name string

    BUILTIN
	CALLG,
	NULLPARAMETER;

    !+
    ! Literals for argument positions.
    !-

    LITERAL
	K_KEYBOARD_ID = 1,
	K_FILESPEC = 2,
	K_DEFAULT_FILESPEC = 3,
	K_RESULTANT_FILESPEC = 4;

    $SMG$VALIDATE_ARGCOUNT(1,4);

    !+
    ! Verify assumption that a RAB is not longer than the positive-offset
    ! portion of a Keyboard Control Block.
    !-

    $ASSUME (RAB$C_BLN, LEQU, KCB_S_KCB_STRUCT - KCB_K_ORIGIN_OFFSET);

    !+
    ! Initialize FAB, NAM  and XAB.
    !-

    $FAB_INIT (FAB=FAB, NAM=NAM, XAB=XAB_FHC);
    $NAM_INIT (NAM=NAM, ESA=RESULTANT_STRING, ESS=NAM$C_MAXRSS,
	RSA=RESULTANT_STRING, RSS=NAM$C_MAXRSS);
    $XABFHC_INIT (XAB=XAB_FHC);

    !+
    ! Get the file specification.
    !-

    IF NOT NULLPARAMETER (K_FILESPEC)	! FILESPEC present?
    THEN
	BEGIN
	LOCAL
	    STRING_PTR,		! Pointer to string
	    STRING_LEN: WORD,	! Length of string
	    ANL_STATUS;		! Status from LIB$ANALYZE_SDESC_R2

	ANL_STATUS = LIB$ANALYZE_SDESC_R2 (FILESPEC [0,0,0,0];
	    STRING_LEN, STRING_PTR);
	IF NOT .ANL_STATUS
	THEN
	    RETURN .ANL_STATUS;

	IF .STRING_LEN GTRU 255
	THEN
	    RETURN SMG$_FILTOOLON;
	FAB [FAB$L_FNA] = .STRING_PTR;
	FAB [FAB$B_FNS] = .STRING_LEN;
	END
    ELSE
	BEGIN
	!+
	! Use 'SYS$INPUT:'
	!-
	FAB [FAB$B_FNS] = %CHARCOUNT ('SYS$INPUT:');
	FAB [FAB$L_FNA] = UPLIT BYTE ('SYS$INPUT:');
	END;

    !+
    ! Get default filespec, if any.
    !-

    IF NOT NULLPARAMETER (K_DEFAULT_FILESPEC)
    THEN
	BEGIN
	LOCAL
	    STRING_PTR,		! Pointer to string
	    STRING_LEN: WORD,	! Length of string
	    ANL_STATUS;		! Status from LIB$ANALYZE_SDESC_R2

	ANL_STATUS = LIB$ANALYZE_SDESC_R2 (DEFAULT_FILESPEC [0,0,0,0];
	    STRING_LEN, STRING_PTR);
	IF NOT .ANL_STATUS
	THEN
	    RETURN .ANL_STATUS;

	IF .STRING_LEN GTRU 255
	THEN
	    RETURN SMG$_FILTOOLON;
	FAB [FAB$L_DNA] = .STRING_PTR;
	FAB [FAB$B_DNS] = .STRING_LEN;
	END;

    !+
    ! Parse the file specification to see whether or not it is
    ! a terminal.
    !-

    	BEGIN
	LOCAL
	    PARSE_STATUS;
	PARSE_STATUS = $PARSE (FAB = FAB);
	IF NOT .PARSE_STATUS
	THEN
	    RETURN .PARSE_STATUS;
	END;

    !+
    ! If KQB_QUEUE and QPS_QUEUE have not yet been initialized, initialize them.
    ! SMG$$INIT_QUEUES also declares an exit handler.
    !-

    IF NOT .V_QUEUE_INIT
    THEN
	BEGIN
	LOCAL
	    INIT_STATUS;
	INIT_STATUS = SMG$$INIT_QUEUES ();
	IF NOT .INIT_STATUS
	THEN
	    RETURN .INIT_STATUS;
	END;

    !+
    ! Allocate a Keyboard Control Block
    !-

	BEGIN
	LOCAL
	    VM_POINTER,		! Pointer to allocated memory
	    VM_STATUS;		! Status from LIB$GET_VM
	VM_STATUS = LIB$GET_VM (%REF(KCB_S_KCB_STRUCT), VM_POINTER);
	IF NOT .VM_STATUS
	THEN
	    RETURN .VM_STATUS;
	CH$FILL (0, KCB_S_KCB_STRUCT, .VM_POINTER);
	KCB = .VM_POINTER + KCB_K_ORIGIN_OFFSET;
	END;

    !+
    ! Allocate a Keyboard Queue Block and put this KCB on the queue.
    ! Note that KQBs are never removed from the queue; they are inactivated
    ! by having the KQB_A_KCB field set to zero.
    !-

	BEGIN
	LOCAL
	    KQB: REF KQB_R_KQB_STRUCT,	! Keyboard Queue Block
	    KQB_PTR,	! Pointer to allocated block
	    VM_STATUS;
	BUILTIN
	    INSQUE;

	VM_STATUS = LIB$GET_VM (%REF(KQB_S_KQB_STRUCT), KQB_PTR);
	IF NOT .VM_STATUS
	THEN
	    RETURN SMG$$CLEANUP (KCB [KCB_R_KCB], .VM_STATUS);
	KQB = .KQB_PTR;
	KQB [KQB_A_KCB] = .KCB;
	KCB [KCB_A_KQB] = .KQB;
	INSQUE (KQB [KQB_Q_QUEUE_LINK], KQB_QUEUE);
	END;

    !+
    ! See if this file is a terminal.
    !-

	BEGIN
	BIND
	    FAB_DEV = FAB [FAB$L_DEV]: BLOCK [4, BYTE];
	IF NOT .FAB_DEV [DEV$V_TRM]
	THEN
	    KCB [KCB_V_RMS] = 1;	! Not a terminal
	END;

    !+
    ! Now split dpending on whether the file is a terminal or not.
    !-

    IF NOT .KCB [KCB_V_RMS]
    THEN
	BEGIN
	!+
	! The file is a terminal.  Assign a channel and use $QIOs.
	!-

	LOCAL
	    DEVNAME_DESCR: BLOCK [8, BYTE], ! Descriptor for device name
	    ASSIGN_STATUS, QIO_STATUS1, QIO_STATUS2, QIO_STATUS3;

	BIND
	    KCB_DEVDEPEND1 = KCB [KCB_L_DEVDEPEND1]: BLOCK [4, BYTE],
	    KCB_DEVDEPEND2 = KCB [KCB_L_DEVDEPEND2]: BLOCK [4, BYTE];

	!+
	! Fill in device name descriptor and assign a channel.
	!-

	DEVNAME_DESCR [DSC$W_LENGTH] = .NAM [NAM$B_ESL];
	DEVNAME_DESCR [DSC$B_CLASS] = DSC$K_CLASS_S;
	DEVNAME_DESCR [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	DEVNAME_DESCR [DSC$A_POINTER] = RESULTANT_STRING;
	ASSIGN_STATUS = $ASSIGN (
	    DEVNAM = DEVNAME_DESCR,	! Device name descriptor
	    CHAN = KCB [KCB_W_CHANNEL]);
	IF NOT .ASSIGN_STATUS
	THEN
	    RETURN SMG$$CLEANUP (KCB [KCB_R_KCB], .ASSIGN_STATUS);

	!+
	! Allocate an event flag number.
	!-
    
	    BEGIN
	    LOCAL
		EF_STATUS;
	    EF_STATUS = LIB$GET_EF (KCB [KCB_L_EFN]);
	    IF NOT .EF_STATUS
	    THEN
		RETURN SMG$$CLEANUP (KCB [KCB_R_KCB], .EF_STATUS);
	    END;

	!+
	! Fill in the QIO argument lists.
	!-

	KCB [KCB_L_QIO1_ARGCNT] = KCB_K_QIO1_ARGCNT;
	KCB [KCB_L_QIO1_EFN] = .KCB [KCB_L_EFN];
	KCB [KCB_L_QIO1_CHAN] = .KCB [KCB_W_CHANNEL];
	KCB [KCB_L_QIO1_FUNC] = IO$_READVBLK + IO$M_ESCAPE;
	KCB [KCB_A_QIO1_IOSB] = KCB [KCB_R_IOSB];
	KCB [KCB_L_QIO2_ARGCNT] = KCB_K_QIO2_ARGCNT;
	KCB [KCB_L_QIO2_EFN] = .KCB [KCB_L_EFN];
	KCB [KCB_L_QIO2_CHAN] = .KCB [KCB_W_CHANNEL];
	KCB [KCB_A_QIO2_IOSB] = KCB [KCB_R_IOSB];


	!+
	! Get the terminal's current characteristics.
	!-

	KCB [KCB_L_QIO2_FUNC] = IO$_SENSEMODE;
	KCB [KCB_L_QIO2_P1] = KCB [KCB_R_TERMCHAR];
	KCB [KCB_L_QIO2_P2] = KCB_S_TERMCHAR;
	
	QIO_STATUS1 = CALLG (KCB [KCB_R_QIO2], SYS$QIOW);
	IF .QIO_STATUS1
	THEN
	    QIO_STATUS1 = .KCB [KCB_W_IOSB_STATUS];
	IF NOT .QIO_STATUS1
	THEN
	    RETURN SMG$$CLEANUP (KCB [KCB_R_KCB], .QIO_STATUS1);

	!+
	! Save the device-dependent characteristics.
	!-

	KCB [KCB_L_OLD_DEVDEPEND1] = .KCB [KCB_L_DEVDEPEND1];
	KCB [KCB_L_OLD_DEVDEPEND2] = .KCB [KCB_L_DEVDEPEND2];

	!+
	! Indicate if the enter/exit keypad mode sequence is compatible
	! with that for DECCRTs.
	!-

	IF .KCB_DEVDEPEND2 [TT2$V_DECCRT] OR
	    (.KCB [KCB_B_DEVTYPE] EQL DT$_VT5X) OR
	    (.KCB [KCB_B_DEVTYPE] EQL DT$_VT55) OR
	    ((.KCB [KCB_B_DEVTYPE] GEQU DT$_LA36) AND	! Covers LA36,120,34,38,
	     (.KCB [KCB_B_DEVTYPE] LEQU DT$_LA100)) OR	! 12,24,100
	    (.KCB [KCB_B_DEVTYPE] EQL DT$_VK100) OR
	    (.KCB [KCB_B_DEVTYPE] EQL DT$_VT173)
	THEN
	    KCB [KCB_V_KPDSEQ_DECCRT] = 1;

	END
    ELSE
	BEGIN
	!+
	! Device is not a terminal.  Use RMS.
	!-

	LOCAL
	    OPEN_STATUS, CONNECT_STATUS, VM_STATUS;

	!+
	! Open file.
	!-

	    OPEN_STATUS;
	OPEN_STATUS = $OPEN (FAB=FAB);
	IF NOT .OPEN_STATUS
	THEN
	    RETURN SMG$$CLEANUP (KCB [KCB_R_KCB], .OPEN_STATUS);

	KCB [RAB$B_BID] = RAB$C_BID;
	KCB [RAB$B_BLN] = RAB$C_BLN;
	KCB [RAB$L_FAB] = FAB;

	!+
	! Connect to the file.
	!-

	CONNECT_STATUS = $CONNECT (RAB=KCB [KCB_R_RAB]);
	IF NOT .CONNECT_STATUS
	THEN
	    RETURN SMG$$CLEANUP (KCB [KCB_R_KCB], .CONNECT_STATUS);

	!+
	! Store the IFI for a future close.
	!-

	KCB [KCB_W_IFI] = .FAB [FAB$W_IFI];

	!+
	! Allocate a buffer that is large enough for the file.
	!-

	KCB [RAB$W_USZ] = .FAB [FAB$W_MRS];
	IF .KCB [RAB$W_USZ] EQL 0
	THEN
	    BEGIN
	    KCB [RAB$W_USZ] = .FAB [FAB$W_BLS];
	    IF .XAB_FHC [XAB$W_LRL] GTRU .KCB [RAB$W_USZ]
	    THEN
		KCB [RAB$W_USZ] = .XAB_FHC [XAB$W_LRL];
	    END;
	VM_STATUS = LIB$GET_VM (%REF(.KCB [RAB$W_USZ]), KCB [RAB$L_UBF]);
	IF NOT .VM_STATUS
	THEN
	    RETURN SMG$$CLEANUP (KCB [KCB_R_KCB], .VM_STATUS);

	!+
	! Set additional values needed in the RAB.
	!-

	KCB [RAB$B_RAC] = RAB$C_SEQ;
	KCB [RAB$V_LOC] = 1;
	KCB [RAB$V_RAH] = 1;

	END;

    !+
    ! Store RESULTANT_NAME in KCB and caller's filespec, if desired.
    !-

    BEGIN
    LOCAL
	COPY_STATUS,
	STRPTR,		! Pointer to string
	STRLEN: WORD;	! Length of string

    !+
    ! Try resultant name string first.
    !-
    STRPTR = RESULTANT_STRING;
    STRLEN = .NAM [NAM$B_RSL];
    IF .STRLEN EQL 0
    THEN
	BEGIN
	!+
	! Try expanded name string.
	!-
	STRLEN = .NAM [NAM$B_ESL];
	IF .STRLEN EQL 0
	THEN
	    BEGIN
	    !+
	    ! Use filename.
	    !-
	    STRPTR = .FAB [FAB$L_FNA];
	    STRLEN = .FAB [FAB$B_FNS];
	    END;
	END;

    IF NOT NULLPARAMETER (K_RESULTANT_FILESPEC)
    THEN
	BEGIN
	COPY_STATUS = LIB$SCOPY_R_DX6 (.STRLEN, .STRPTR, 
	    RESULTANT_FILESPEC [0,0,0,0]);
	IF NOT .COPY_STATUS
	THEN
	    RETURN SMG$$CLEANUP (KCB [KCB_R_KCB], .COPY_STATUS);
	END;

    !+
    ! Store the resultant name string in the KCB.  It may be used
    ! later with output.
    !-
    BEGIN
    LOCAL
	DEVNAM_DSC : BLOCK [8, BYTE],		! dsc for name
	DVI_ITMLST : VECTOR [1*3 + 1] INITIAL	! item list for $GETDVI
		(DVI$_DEVNAM     ^ 16 +64, 0, 0,!  result name string
		 0),				!  terminater

	DVI_IOSB	: VECTOR [4, WORD],	! I/O Status block for $GETDVI
	STATUS,					! status retd by called routines
	DEV_DEVNAM : VECTOR [64, BYTE],		! Buffer for result name
						! string
	DEV_NAMLEN : VOLATILE WORD;		! Length of returned
						! resultant name string

    BIND
	DVI_DEVNAM  = DVI_ITMLST + 4,		! make it easy to ref items
	DVI_NAMLEN  = DVI_ITMLST + 8;		!

    DVI_DEVNAM  = DEV_DEVNAM;
    DVI_NAMLEN  = DEV_NAMLEN;

    DEVNAM_DSC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
    DEVNAM_DSC [DSC$B_CLASS] = DSC$K_CLASS_S;
    DEVNAM_DSC [DSC$W_LENGTH] = .STRLEN;
    DEVNAM_DSC [DSC$A_POINTER] = .STRPTR; ! dsc needed for $GETDVI

    STATUS = $GETDVI(	EFN	= .KCB [KCB_L_EFN],
			IOSB	=  DVI_IOSB,
			DEVNAM	=  DEVNAM_DSC,
			ITMLST	=  DVI_ITMLST);
    IF NOT .STATUS THEN RETURN (.STATUS);

    $WAITFR (EFN = .KCB [KCB_L_EFN]);		! make $GETDVI synchronous

    !+
    ! When the operation completes, the final status
    ! is left in the first word of the I/O status block.
    !-

    IF NOT .DVI_IOSB [0] THEN RETURN (.DVI_IOSB [0]);


    KCB [KCB_W_DEVNAM_LENGTH]= .DEV_NAMLEN;	! Length of device name
    CH$MOVE ( .DEV_NAMLEN, DEV_DEVNAM, KCB [KCB_T_DEVNAM_STRING]);

    END;
    
    END;

    !+
    ! Store the check value in the KCB so we can recognize a valid KCB
    ! the next time we see one.
    !-

    KCB [KCB_L_CHECK] = .KCB;

    !+
    ! Init to no pasteboard.
    !-

    KCB [KCB_L_PASTEBOARD_ID] = -1;

    !+
    ! Set the terminal's keypad to application mode (if not a file).
    !-

    IF NOT .KCB [KCB_V_RMS]
    THEN
	SMG$SET_KEYPAD_MODE (%REF(KCB [KCB_R_KCB]), %REF(1));

    !+
    ! Store the KCB address in the user's argument.
    !-

    KEYBOARD_ID [0] = KCB [KCB_R_KCB];

    RETURN SS$_NORMAL;

    END;					! End of routine SMG$CREATE_VIRTUAL_KEYBOARD

%SBTTL 'SMG$READ_STRING'
GLOBAL ROUTINE SMG$READ_STRING (
    KEYBOARD_ID: REF VECTOR [, LONG],
    OUT_STRING: REF BLOCK [, BYTE],
    PROMPT_STRING: REF BLOCK [, BYTE],
    MAX_LENGTH: REF VECTOR [, LONG],
    MODIFIERS: REF VECTOR [, LONG],
    TIMEOUT: REF VECTOR [, LONG],
    TERMINATOR_SET: REF BLOCK [,BYTE],
    OUT_LENGTH: REF VECTOR [, WORD],
    TERMINATOR_CODE: REF VECTOR [, WORD],
    DISPLAY_ID: REF VECTOR [, LONG]
    ) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine reads a sequence of characters from the virtual-keyboard
!	specified and returns to the caller the characters read.  The caller
!	may also specify that a code indicating the terminator be returned.
!
! CALLING SEQUENCE:
!
!	RET_STATUS.wlc.v = SMG$READ_STRING (
!				KEYBOARD_ID.rl.r,
!				OUT_STRING.wt.dx
!				[, [PROMPT_STRING.rt.dx]
!				[, [MAX_LENGTH.rl.r]
!				[, [MODIFIERS.rl.r]
!				[, [TIMEOUT.rl.r]
!				[, [TERMINATOR_SET.rt.ds]
!				[, [OUT_LENGTH.wwu.r]
!				[, [TERMINATOR_CODE.wwu.r]
!				[, [DISPLAY_ID.rl.r] ]]]]]]]])
!				
!
! FORMAL PARAMETERS:
!
!	KEYBOARD_ID	A longword containing the identification of the
!			virtual-keyboard from which to read.  A virtual-
!			keyboard is created by calling 
!			SMG$CREATE_VIRTUAL_KEYBOARD.
!
!	PROMPT_STRING	An optional string to be used as the prompt for
!			the read operation.
!
!	OUT_STRING	A string into which is written the characters read.
!
!	MAX_LENGTH	A longword containing the maximum number of characters
!			to read.  The maximum value of MAX_LENGTH is 512.  If
!			omitted, 512 is used.
!
!	MODIFIERS	A longword bitmask that specifies optional behavior.
!			The bits defined are the same as for the $QIO
!			item-list entry TRM$_MODIFIERS. 
!
!			See the terminal driver section of the I/O User's
!			Guide for more information on MODIFIERS.  The
!			TRM$ symbols are defined by the $TRMDEF macro/module
!			in Digital-supplies system symbol libraries.
!
!	TIMEOUT		Optional timeout count.  If specified, all characters
!			typed in before the timeout are returned in the buffer.
!			If omitted, characters are returned in the buffer until
!			a terminator is seen.
!		
!	TERMINATOR_SET  Descriptor of terminator mask, 0 - 8 bytes
!			(class, dtype ignored).  If omitted, the VAX-11
!			RMS standard terminator set is used.  See the terminal
!			driver section of the VAX/VMS I/O User's Guide for
!			more information on specifying terminators.
!
!	OUT_LENGTH	An unsigned word into which is written the number
!			of characters read or the maximum length of
!			OUT_STRING, whichever is less.
!
!	TERMINATOR_CODE	An unsigned word into which is written a code
!			indicating what character or key terminated the
!			read.  For more information on the values for
!			TERMINATOR_CODE, see the description of terminator
!			codes in the Screen Management functional specification.
!	
!	DISPLAY_ID	A longword containing the identification of the
!			virtual display in which the read is to be performed.
!			If specified, the read begins at the current cursor
!			position in that virtual-display.  If omitted, the
!			read begins in the current cursor position.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	SS$_NORMAL	Normal successful completion
!	SS$_CANCEL	I/O operation cancelled (by SMG$CANCEL_INPUT)
!	SMG$_EOF	End-of-file
!	SMG$_INVDIS_ID	Invalid display-id
!	SMG$_INVKBD_ID	Invalid keyboard-id
!	SMG$_WRONUMARG	Wrong number of arguments
!	LIB$_xxx	Any error from LIB$SCOPY_R_DX
!	RMS$_xxx	Any error from $GET (except RMS$_EOF)
!	SS$_xxx		Any error from $QIOW
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LOCAL
	KCB: REF KCB_R_KCB_STRUCT,
	BUFFER: VECTOR [512, BYTE],
	BUFFER_PTR,
	BUFFER_LEN: WORD,
	KEY_CODE: WORD,
	ITEM_LIST: $ITMLST_DECL (ITEMS=4),	! QIO item list
	QIO_STATUS,
	COPY_STATUS,
	RET_STATUS,
	DISPLAY_ID_FLAG : INITIAL (0);

    BUILTIN
	ACTUALCOUNT,
	CALLG,
	NULLPARAMETER,
	TESTBITSC;

    !+
    ! Define literals for the argument positions.
    !-

    LITERAL
	K_KEYBOARD_ID = 1,
	K_OUT_STRING = 2,
	K_PROMPT_STRING = 3,
	K_MAX_LENGTH = 4,
	K_MODIFIERS = 5,
	K_TIMEOUT = 6,
	K_TERMINATOR_SET = 7,
	K_OUT_LENGTH = 8,
	K_TERMINATOR_CODE = 9,
	K_DISPLAY_ID = 10;

    !+
    ! Define literals for the item list positions.
    !-

    LITERAL
	K_MODIFIER_MASK = 0,
	K_PROMPT = 1,
	K_NEXT = 2,	! The next available position
	K_ALLOWED_MODIFIERS = IO$M_CVTLOW +  ! 3A modifiers
			      IO$M_DSABLMBX +	     ! 5f40
			      IO$M_ESCAPE +
			      IO$M_NOECHO +
			      IO$M_NOFILTR +
			      IO$M_PURGE +
			      IO$M_TRMNOECHO;

    $SMG$VALIDATE_ARGCOUNT(2,10);

    !+		
    ! Fetch and validate KCB.  
    !-

    $SMG$VALIDATE_KCB (KEYBOARD_ID, KCB);

    !+
    ! Assume success.
    !-

    RET_STATUS = SS$_NORMAL;

    !+
    ! Split depending on whether or not we are using RMS.
    !-

    IF .KCB [KCB_V_RMS]
    THEN

	!+
	! Read a line using $GET.
	!-

	BEGIN
	LOCAL
	    GET_STATUS;

	GET_STATUS = $GET (RAB = KCB [KCB_R_RAB]);
	IF NOT .GET_STATUS
	THEN
	    BEGIN
	    IF .GET_STATUS EQLU RMS$_EOF
	    THEN
		RET_STATUS = SMG$_EOF
	    ELSE
		RET_STATUS = .GET_STATUS;
	    END;

	!+
	! If user asked for TERMINATOR_CODE, return <CR>.
	!-

	IF NOT NULLPARAMETER (K_TERMINATOR_CODE)
	THEN
	    TERMINATOR_CODE [0] = SMG$K_TRM_CR;

	!+
	! Set BUFFER_PTR and BUFFER_LEN.
	!-

	BUFFER_PTR = .KCB [RAB$L_RBF];
	BUFFER_LEN = .KCB [RAB$W_RSZ];
	END

    ELSE

	!+
	! Use $QIO.
	!-

	BEGIN
	LOCAL
	    CURSOR_BUF : VECTOR [15, BYTE],	! buffer for set cursor sequence
	    CURSOR_BUF_LEN : INITIAL (0),	! used number of bytes in cursor_buf
	    FREE_COLS;			! calc. needed if display_id used

	!+
	! If the last read ended in ^Z, return SMG$_EOF.
	!-
    
	IF TESTBITSC (KCB [KCB_V_CTRLZ])
	THEN
	    RETURN SMG$_EOF;	! End of file
    
	!+
	! Build the item list for the QIO.
	!-
    
	$ITMLST_INIT (ITMLST=ITEM_LIST,
	    (ITMCOD=TRM$_MODIFIERS, BUFADR=TRM$M_TM_ESCAPE, BUFSIZ=0),
	    (ITMCOD=TRM$_PROMPT, BUFADR=0, BUFSIZ=0));
    
	!+
	! Set up the $QIOW argument list.
	!-
    
	KCB [KCB_L_QIO1_FUNC] = IO$_READVBLK+IO$M_EXTEND;
	KCB [KCB_L_QIO1_P1] = BUFFER;
	KCB [KCB_L_QIO1_P2] = %ALLOCATION(BUFFER);
	KCB [KCB_L_QIO1_P3] = 0;
	KCB [KCB_L_QIO1_P4] = 0;
	KCB [KCB_L_QIO1_P5] = ITEM_LIST;
	KCB [KCB_L_QIO1_P6] = %ALLOCATION(ITEM_LIST) - 28; ! Don't count timeout
	    						   ! or term. set yet,
	    						   ! and $ITMLST_DECL
	    						   ! adds extra 4.

	!+
	! Check for optional input parameters.  This is done as a nested if
	! rather than as a series of NULLPARAMETER tests for speed.
	!-

	IF ACTUALCOUNT () GEQU K_MAX_LENGTH
	THEN
	    BEGIN
	    LOCAL
		CUR_ITEM;	! Pointer into ITEM_LIST
	    CUR_ITEM = ITEM_LIST [K_NEXT,0,0,0,0];

	    IF MAX_LENGTH [0] NEQA 0
	    THEN
		BEGIN
		KCB [KCB_L_QIO1_P2] = .MAX_LENGTH [0];
		IF .KCB [KCB_L_QIO1_P2] GTRU %ALLOCATION(BUFFER)
		THEN
		    RETURN SMG$_INVMAXLEN;
		END;
	    IF ACTUALCOUNT () GEQU K_MODIFIERS
	    THEN
		BEGIN
		IF MODIFIERS [0] NEQA 0
		THEN
		    ITEM_LIST [K_MODIFIER_MASK,ITM$L_BUFADR] = 
			.ITEM_LIST [K_MODIFIER_MASK,ITM$L_BUFADR] OR
			.MODIFIERS [0];
		IF ACTUALCOUNT () GEQU K_TIMEOUT
		THEN
		    BEGIN
		    IF TIMEOUT [0] NEQA 0
		    THEN
			BEGIN
			$LIB$WWORD_A (CUR_ITEM) = 0;
			$LIB$WWORD_A (CUR_ITEM) = TRM$_TIMEOUT;
			$LIB$WLONG_A (CUR_ITEM) = .TIMEOUT [0];
			$LIB$WLONG_A (CUR_ITEM) = 0;
			END;
		    IF ACTUALCOUNT () GEQU K_TERMINATOR_SET
		    THEN
			BEGIN
			IF TERMINATOR_SET [0,0,0,0] NEQA 0
			THEN
			    BEGIN
			    $LIB$WWORD_A (CUR_ITEM) = .TERMINATOR_SET [DSC$W_LENGTH];
			    $LIB$WWORD_A (CUR_ITEM) = TRM$_TERM;
			    $LIB$WLONG_A (CUR_ITEM) = .TERMINATOR_SET [DSC$A_POINTER];
			    $LIB$WLONG_A (CUR_ITEM) = 0;
			    END;
			IF NOT NULLPARAMETER (K_DISPLAY_ID)
			THEN
			    BEGIN			! display_id present
			    !+
			    ! Interfacing with output's virtual displays.  Make sure user can
			    ! not type beyond the display's boundaries by limiting the input
			    ! size to the number of free columns (allowing room for prompt, if
			    ! any).
			    ! Notice that we need some info from SMG$$SET_PROMPT_STRING (prompt
			    ! string length), and we need to provide it with some info (set cursor
			    ! sequence, if any).  So get the info here and save it.
			    !+
			    LOCAL
				OUT_STATUS;
			    DISPLAY_ID_FLAG = 1;	! for quick checks later
			    IF .KCB [KCB_L_PASTEBOARD_ID] LSS 0	! pb not established yet
			    THEN
			 	BEGIN
			    	OUT_STATUS = SMG$$GET_PASTEBOARD_ID (%REF (.KCB [KCB_W_DEVNAM_LENGTH]),
								     KCB [KCB_T_DEVNAM_STRING],
								     KCB [KCB_L_PASTEBOARD_ID]);
				IF NOT .OUT_STATUS THEN RETURN (.OUT_STATUS);
				END;
			    OUT_STATUS = SMG$$SET_PHYSICAL_CURSOR (.DISPLAY_ID,
								   KCB [KCB_L_PASTEBOARD_ID],
								   CURSOR_BUF,
								   CURSOR_BUF_LEN,
								   FREE_COLS);
			    IF NOT .OUT_STATUS THEN RETURN .OUT_STATUS;
			    END;			! display_id present
			END;
		    END;
		END;

	    !+
	    ! Change item-list length to reflect modifications.
	    !-

	    KCB [KCB_L_QIO1_P6] = .CUR_ITEM - .KCB [KCB_L_QIO1_P5];
	    END;

	!+
	! Set up the prompt string.
	!-

	    BEGIN
	    LOCAL
		STATUS,
		NULL_STRING : BLOCK [8,BYTE];
	    NULL_STRING [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	    NULL_STRING [DSC$B_CLASS] = DSC$K_CLASS_S;
	    NULL_STRING [DSC$W_LENGTH] = 0;
	    NULL_STRING [DSC$A_POINTER] = UPLIT (' ');

	    IF .DISPLAY_ID_FLAG OR
	       NOT NULLPARAMETER (K_PROMPT_STRING)
	    THEN
		BEGIN				! setup prompt
	    	STATUS = SMG$$SET_PROMPT_STRING (
		   		(IF NULLPARAMETER (K_PROMPT_STRING)
		    		THEN
				    NULL_STRING
		    		ELSE
				    PROMPT_STRING [0,0,0,0]),
		    		ITEM_LIST [K_PROMPT, 0,0,0,0],
		    		.CURSOR_BUF_LEN,
		    		CURSOR_BUF);
	    	IF NOT .STATUS
	    	THEN
		    RETURN .STATUS;
		END;				! setup prompt
	    IF .DISPLAY_ID_FLAG
	    THEN
		BEGIN
		IF PROMPT_STRING [0,0,0,0] NEQA 0
		THEN
		    FREE_COLS = .FREE_COLS - .PROMPT_STRING [DSC$W_LENGTH];
		IF .FREE_COLS LEQ 0
		THEN
		    !+
		    ! No room to accept input.  Exit.
		    !-
		    RETURN (SMG$_INVCOL);	! improve this message later

		IF .KCB [KCB_L_QIO1_P2] GTR .FREE_COLS
		THEN
		    KCB [KCB_L_QIO1_P2] = .FREE_COLS;
		END;
	    END;

	!**
	! If this routine is supposed to execute on a V3.n system, map back
	! the item-list entries into the old-style of $QIO.
	!**

	%IF %VARIANT
	%THEN
	    BEGIN
	    KCB [KCB_L_QIO1_FUNC] = IO$_READVBLK;
	    KCB [KCB_L_QIO1_P5] = 0;
	    KCB [KCB_L_QIO1_P6] = 0;
	    IF .ITEM_LIST [K_PROMPT, ITM$W_BUFSIZ] NEQ 0
	    THEN
		BEGIN
		KCB [KCB_L_QIO1_P5] = .ITEM_LIST [K_PROMPT, ITM$L_BUFADR];
		KCB [KCB_L_QIO1_P6] = .ITEM_LIST [K_PROMPT, ITM$W_BUFSIZ];
		KCB [KCB_L_QIO1_FUNC] = IO$_READPROMPT;
		END;
	    IF NOT NULLPARAMETER(K_TIMEOUT)
	    THEN
		BEGIN
		KCB [KCB_L_QIO1_P3] = .TIMEOUT [0];
		KCB [KCB_L_QIO1_FUNC] = .KCB [KCB_L_QIO1_FUNC] OR IO$M_TIMED;
		END;
	    IF NOT NULLPARAMETER(K_TERMINATOR_SET)
	    THEN
		BEGIN
		LOCAL
		    CUR_ITEM: REF $ITMLST_DECL (ITEMS=1);
		CUR_ITEM = ITEM_LIST [K_NEXT, 0,0,0,0];
		IF .CUR_ITEM [0, ITM$W_ITMCOD] NEQ TRM$_TERM
		THEN
		    CUR_ITEM = CUR_ITEM [1, 0,0,0,0];
		KCB [KCB_L_QIO1_P4] = .CUR_ITEM;
		END;

	    IF NOT NULLPARAMETER (K_MODIFIERS)
	    THEN
	    	KCB [KCB_L_QIO1_FUNC] = .KCB [KCB_L_QIO1_FUNC] OR 
					(.MODIFIERS [0] AND K_ALLOWED_MODIFIERS);

	    END;
	%FI	!** End of variant code

	BEGIN				! QIO w/rendition
	LOCAL
	    PBCB : REF BLOCK [,BYTE],
	    DCB : REF BLOCK [,BYTE];

	IF .DISPLAY_ID_FLAG
	THEN
	    BEGIN			! display_id/check rendition

	    !+
	    ! Make sure the prompt and input appear in the correct video
	    ! rendition.
	    !-

	    $SMG$GET_DCB (.DISPLAY_ID, DCB);
	    $SMG$GET_PBCB (KCB [KCB_L_PASTEBOARD_ID], PBCB);

	    !+
	    ! Don't allow input if display is batched.
	    !-

	    IF .DCB[DCB_L_BATCH_LEVEL] NEQ 0
	    THEN
		RETURN	SMG$_ILLBATFNC;

	    !+
	    ! Handle renditions if necessary.
	    !-

	    SMG$$SET_ATTRIBUTES_ON (.PBCB,.DCB [DCB_B_DEF_VIDEO_ATTR]);

	    END;			! display_id/check rendition

    	!+			
    	! Read the string.
    	!-

    	QIO_STATUS = CALLG (KCB [KCB_R_QIO1], SYS$QIOW);
    	IF .QIO_STATUS
    	THEN
    	    QIO_STATUS = .KCB [KCB_W_IOSB_STATUS];

    	!+
    	! If we set the video rendition, turn it off now.
    	!-

    	IF .DISPLAY_ID_FLAG
	THEN
	    SMG$$SET_ATTRIBUTES_OFF (.PBCB,.DCB [DCB_B_DEF_VIDEO_ATTR]);

    	IF NOT .QIO_STATUS
    	THEN
    	    RET_STATUS = .QIO_STATUS;
	END;			! QIO w/rendition
    
	!+
	! Check for partial escape sequence in the buffer.  This can
	! happen if the QIO was limited to 2 characters and the input
	! string was terminated by a keypad key (which are 3 chars).
	!-

  	IF .KCB [KCB_W_IOSB_STATUS] EQL SS$_PARTESCAPE
	THEN
	    BEGIN
	    LOCAL
		QIO_RESULT,
		CHAR_BUF : BYTE,
		END_ESC_FLAG : INITIAL (0);

	    BUFFER_LEN = .KCB [KCB_W_IOSB_COUNT] + .KCB [KCB_B_IOSB_TERMLEN];
					! point past data & partial terminator

	    WHILE .END_ESC_FLAG EQL 0 DO
		BEGIN
		QIO_RESULT = $QIOW (EFN = .KCB [KCB_L_EFN],
				    CHAN = .KCB [KCB_W_CHANNEL],
				    FUNC = (IO$_READVBLK + IO$M_ESCAPE +
					    IO$M_NOECHO + IO$M_NOFILTR +
					    IO$M_TRMNOECHO),
				    P1 = CHAR_BUF,
				    P2 = 1,
				    P4 = .KCB [KCB_L_QIO1_P4]);
					! P4 = defined terminator set
		IF NOT .QIO_RESULT THEN RET_STATUS = .QIO_RESULT;

		!+
		! Move terminator characters to buffer.
		!-

		BUFFER [.BUFFER_LEN] = .CHAR_BUF;
		BUFFER_LEN = .BUFFER_LEN + 1;
		KCB [KCB_B_IOSB_TERMLEN] = .KCB [KCB_B_IOSB_TERMLEN] + 1;

		CASE .CHAR_BUF FROM %C'A' TO %C'~' OF
		SET
		    [%C'A' TO %C'D',	! arrow keys
		     %C'M',		! Enter
		     %C'P' to %C'S',	! PFn keys
		     %C'l' to %C'n',	! keypad - , .
		     %C'p' to %C'y',	! keypad 0-9
		     %C'~']:		! function keys F6-F20 (no codes for
					! F1-F5), editing keys (E1-E6)
		    	BEGIN
			END_ESC_FLAG = 1;
			RET_STATUS = SS$_NORMAL;
					! get rid of ss$_partescape error
			END;

		    [INRANGE, OUTRANGE]:
			;		! didn't find end of esc terminator
					! keep searching
		TES;

		END;			! end of WHILE loop
	    END;			! end of partial ESC terminator

	!+
	! Get the terminator code.
	!-
	
	IF .QIO_STATUS EQL SS$_TIMEOUT
	THEN
	    KEY_CODE = SMG$K_TRM_TIMEOUT
	ELSE
	    KEY_CODE  = SMG$$TERM_TO_KEYCODE (BUFFER [.KCB [KCB_W_IOSB_COUNT]], 
		.KCB [KCB_B_IOSB_TERMLEN]);

	!+
	! If DISPLAY_ID was passed, call back output side to tell it
	! what changed on the screen as a result of this prompt & input.
	!-

    	IF .DISPLAY_ID_FLAG
	THEN
	    BEGIN
	    LOCAL
		OUT_STATUS;
	    IF PROMPT_STRING [0,0,0,0] NEQA 0
	    THEN
		BEGIN			! report prompt string change
	        OUT_STATUS = SMG$$REPORT_CHANGE_REPLACE (.DISPLAY_ID,
						     KCB [KCB_L_PASTEBOARD_ID],
						     %REF (.PROMPT_STRING [DSC$W_LENGTH]),
						     .PROMPT_STRING [DSC$A_POINTER]);
		IF NOT .OUT_STATUS AND
		   .OUT_STATUS NEQ SMG$_STRTERESC
		THEN 
		    RET_STATUS = .OUT_STATUS;
		END;			! report prompt string change
	    
	    BEGIN
	    MAP
		MODIFIERS : REF BLOCK [,BYTE];
	    IF NULLPARAMETER (K_MODIFIERS) OR
	       (NOT NULLPARAMETER (K_MODIFIERS) AND		
		NOT (.MODIFIERS [TRM$V_TM_NOECHO]))
	    THEN
		BEGIN			! skip if noecho requested
	    	OUT_STATUS = SMG$$REPORT_CHANGE_REPLACE (.DISPLAY_ID,
						     KCB [KCB_L_PASTEBOARD_ID],
						     %REF (.KCB [KCB_W_IOSB_COUNT] +
							   (IF (NOT NULLPARAMETER (K_MODIFIERS) AND
							       NOT (.MODIFIERS [TRM$V_TM_TRMNOECHO]))
							   THEN .KCB [KCB_B_IOSB_TERMLEN]
							   ELSE 0)),
						     BUFFER);
					! report user's input string,
					! possibly with terminator
		IF NOT .OUT_STATUS AND
		   .OUT_STATUS NEQ SMG$_STRTERESC
		THEN 
		    RET_STATUS = .OUT_STATUS;
		END;
	    END;

	    END;

	!+
	! Check for a terminator of ^Z.
	!-

	IF .KEY_CODE EQL SMG$K_TRM_CTRLZ
	THEN
	    BEGIN
	    !+
	    ! If count is zero, return SMG$_EOF now, else set
	    ! the flag so that it will be returned the next time.
	    !-

	    IF .KCB [KCB_W_IOSB_COUNT] EQL 0
	    THEN
		RET_STATUS = SMG$_EOF
	    ELSE
		KCB [KCB_V_CTRLZ] = 1;
	    END;

	!+
	! If the caller asked for TERMINATOR_CODE, store it.
	!-

	IF NOT NULLPARAMETER (K_TERMINATOR_CODE)
	THEN
	    TERMINATOR_CODE [0] = .KEY_CODE;

	!+
	! Set BUFFER_PTR and BUFFER_LEN.
	!-

	BUFFER_PTR = BUFFER;
	BUFFER_LEN = .KCB [KCB_W_IOSB_COUNT];

	!+
	! Delete the prompt string, if any.
	!-

	IF NOT NULLPARAMETER (K_PROMPT_STRING) OR
	   .DISPLAY_ID_FLAG
	THEN
	    SMG$$DELETE_PROMPT_STRING (ITEM_LIST [K_PROMPT,0,0,0,0]);
	END;

    !+
    ! We now have the complete line in BUFFER, with length BUFFER_LEN.
    ! Copy it to the user's string.
    !-

    COPY_STATUS = LIB$SCOPY_R_DX6 (.BUFFER_LEN,
	.BUFFER_PTR, OUT_STRING [0,0,0,0]);
    IF NOT .COPY_STATUS
    THEN
	RETURN .COPY_STATUS;

    !+
    ! Fill in OUT_LENGTH if requested.
    !-

    IF NOT NULLPARAMETER (K_OUT_LENGTH)
    THEN
	BEGIN
	LOCAL
	    LINE_LENGTH: WORD;
	LIB$ANALYZE_SDESC_R2 (OUT_STRING [0,0,0,0]; LINE_LENGTH);
	IF .LINE_LENGTH LSSU .BUFFER_LEN
	THEN
	    BUFFER_LEN = .LINE_LENGTH;
	OUT_LENGTH [0] = .BUFFER_LEN;
	END;

    RETURN .RET_STATUS;

    END;					! End of routine SMG$READ_STRING

%SBTTL 'SMG$READ_COMPOSED_LINE'
GLOBAL ROUTINE SMG$READ_COMPOSED_LINE (
    KEYBOARD_ID: REF VECTOR [, LONG],
    KEY_TABLE_ID: REF VECTOR [, LONG],
    OUT_LINE: REF BLOCK [, BYTE],
    PROMPT_STRING: REF BLOCK [, BYTE],
    OUT_LENGTH: REF VECTOR [, WORD],
    DISPLAY_ID: REF VECTOR [, LONG]
    ) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	SMG$READ_COMPOSED_LINE reads a line composed of normal keystrokes
!	and key equivalence strings.  As keys are pressed which are
!	defined in the key-table, the equivalence string, if any, is 
!	substituted in the input line for the key.  Attributes of
!	the key definition control whether the equivalence string
!	is echoed and whether the read terminates.
!
!	The manner of the read operation is not affected by previous calls
!	to other Screen Management procedures, unlike SMG$READ_STRING.
!	Characters typed are always echoed (in normal rendition).
!	<CR> always terminates the read operation.
!	If <CTRL/Z> is pressed and there is no definition
!	in the key-table for CTRLZ, an appropriate string is echoed, the read terminates.
!	If the <CTRL/Z> was the first character in the line, then the
!	status SMG$_EOF is returned, else SMG$_EOF is returned on the next
!	input operation.  SMG$_EOF is also returned if RMS is used for input
!	and it returns RMS$_EOF. No other terminators are recognized except
!	as specified by attributes in the key definitions.
!
! CALLING SEQUENCE:
!
!	RET_STATUS.wlc.v = SMG$READ_COMPOSED_LINE (
!				KEYBOARD_ID.rl.r,
!				KEY_TABLE_ID.rl.r,
!    				OUT_LINE.wt.dx
!				[, [PROMPT_STRING.rt.dx]
!    				[, [OUT_LENGTH.wwu.r]
!    				[, [DISPLAY_ID.rl.r] ]]])
!
! FORMAL PARAMETERS:
!
!	KEYBOARD_ID	A longword containing the identification of the
!			virtual-keyboard from which to read.  The virtual-
!			keyboard is created by SMG$CREATE_VIRTUAL_KEYBOARD.
!
!	KEY_TABLE_ID	A longword containing the identification of the
!			key-definition-table to be used for translating
!			keystrokes.  The key-definition table-table is
!			created by SMG$CREATE_KEY_TABLE.
!
!	OUT_LINE	A string into which is written the complete composed
!			line.
!
!	PROMPT_STRING	An optional string to be used as the prompt for the
!			read operation.
!
!	OUT_LENGTH	An unsigned word into which is written the number of
!			characters read or the maximum length of OUT_LINE,
!			whichever is less.
!
!	DISPLAY_ID	A longword containing the identification of the
!			virtual-display in which the read is to be performed.
!			If specified, the read begins at the beginning of the
!			next line after the current cursor position in that
!			virtual-display.  If omitted, the read begins at the
!			beginning of the next line after the current cursor
!			position.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	SS$_NORMAL	Normal successful completion
!	SS$_CANCEL	I/O operation cancelled (by SMG$CANCEL_INPUT)
!	SMG$_EOF	End-of-file
!	SMG$_INVDIS_ID	Invalid display-id
!	SMG$_INVKBD_ID	Invalid keyboard-id
!	SMG$_INVKTB_ID	Invalid key-table-id
!	SMG$_WRONUMARG	Wrong number of arguments
!	LIB$_xxx	Any error from LIB$SCOPY_R_DX
!	RMS$_xxx	Any error from $GET (except RMS$_EOF)
!	SS$_xxx		Any error from $QIOW
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    FIELD
	FLAGS_FIELDS =
	    SET
	    V_RESET_STATE = [0,0,1,0],
	    V_SKIP_NEWLINE = [0,1,1,0],
	    V_SKIP_LAST_ECHO = [0,2,1,0],
	    V_SETPROMPT = [0,3,1,0],
	    V_ECHO_CTRLZ = [0,4,1,0]
	    TES;

    LOCAL
	KCB: REF KCB_R_KCB_STRUCT,
	KDE: REF KDE_R_KDE_STRUCT,
	KTH: REF KTH_R_KTH_STRUCT,
	BUFFER: VECTOR [516, BYTE], ! Allow 4 chars for terminator echo
	BUFFER_PTR,
	BUFFER_LEN: WORD,
	NEXT_POS,
	TKEY: VECTOR [34, BYTE],
	TKEY_POS: REF VECTOR [, WORD],
	TKEY_DSC: BLOCK [8, BYTE],
	TKEY_DSC_PTR: REF BLOCK [8, BYTE],
	KEY_CODE: WORD,
	ITEM_LIST: $ITMLST_DECL (ITEMS=5),
	FLAGS: BLOCK [1, BYTE] FIELD (FLAGS_FIELDS),
	TERM_NAME_PTR: REF VECTOR [, BYTE],
	DISPLAY_ID_FLAG	: INITIAL(0),
	QIO_STATUS,
	COPY_STATUS,
	RET_STATUS;

    LITERAL
	K_CR = 13,	! <CR>
	K_LF = 10,	! <LF>
	K_CTRLZ = 26,	! ^Z
	K_ESC = 27;	! <ESC>

    BIND
	T_CR = UPLIT BYTE (K_CR);

    BUILTIN
	ACTUALCOUNT,
	CALLG,
	NULLPARAMETER,
	TESTBITSC,
	TESTBITSS;

    !+
    ! Define literals for the argument positions.
    !-

    LITERAL
	K_KEYBOARD_ID = 1,
	K_KEY_TABLE_ID = 2,
	K_OUT_LINE = 3,
	K_PROMPT_STRING = 4,
	K_OUT_LENGTH = 5,
	K_DISPLAY_ID = 6;

    !+
    ! Define literals for the item list positions.
    !-

    LITERAL
	K_MODIFIERS = 0,
	K_PROMPT = 1,
	K_INISTRNG = 2,
	K_INIOFFSET = 3,
	K_TERM = 4;

    !+
    ! Define the default strings which echo for control-Z.
    !-

    OWN
	T_CTRLZ_DECCRT: VECTOR [17, BYTE] PSECT (_SMG$CODE) INITIAL (
	    BYTE (
		K_ESC,'7',		! DECSC - Save Cursor
		K_ESC,'[7m',		! SGR - Negative image
		' Exit ',		! " Exit "
		K_ESC,'[m',		! Normal rendition (in case resore fails)
		K_ESC,'8')),		! DECRC - Restore Cursor
	T_CTRLZ_OTHER: VECTOR [6, BYTE] PSECT (_SMG$CODE) INITIAL (
	    BYTE (
		'*EXIT*'));		! "*EXIT*"

    $SMG$VALIDATE_ARGCOUNT(3,6);

    !+
    ! Fetch and validate KCB.  
    !-

    $SMG$VALIDATE_KCB (KEYBOARD_ID, KCB);

    !+
    ! Fetch and validate KTH.
    !-

    $SMG$VALIDATE_KTH (KEY_TABLE_ID, KTH);

    !+
    ! Assume success.
    !-

    RET_STATUS = SS$_NORMAL;

    !+
    ! Split depending on whether or not we are using RMS.
    !-

    IF .KCB [KCB_V_RMS]
    THEN

	!+
	! Read a line using $GET.
	!-

	BEGIN
	LOCAL
	    GET_STATUS;

	GET_STATUS = $GET (RAB = KCB [KCB_R_RAB]);
	IF NOT .GET_STATUS
	THEN
	    BEGIN
	    IF .GET_STATUS EQLU RMS$_EOF
	    THEN
		RET_STATUS = SMG$_EOF
	    ELSE
		RET_STATUS = .GET_STATUS;
	    END;

	!+
	! Set BUFFER_PTR and BUFFER_LEN.
	!-

	BUFFER_PTR = .KCB [RAB$L_RBF];
	BUFFER_LEN = .KCB [RAB$W_RSZ];
	END

    ELSE

	!+
	! Use $QIO and do all the keypad substitution stuff.
	!-

	BEGIN

	LOCAL
	    CURSOR_BUF : VECTOR [15, BYTE],	! buffer for set cursor sequence
	    CURSOR_BUF_LEN : INITIAL (0),	! used number of bytes in cursor_buf
	    FREE_COLS;			! calc. needed if display_id used

	!+
	! If the last read ended in ^Z, return SMG$_EOF.
	!-
    
	IF TESTBITSC (KCB [KCB_V_CTRLZ])
	THEN
	    RETURN SMG$_EOF;	! End of file
    
	!+
	! Initialize flags.
	!-

	FLAGS = 0;
	FLAGS [V_RESET_STATE] = 1;

	!+
	! Build the item list for the QIO.
	!-
    
	$ITMLST_INIT (ITMLST=ITEM_LIST,
	    (ITMCOD=TRM$_MODIFIERS, 
		BUFADR=(TRM$M_TM_ESCAPE+TRM$M_TM_TRMNOECHO) OR
		    .KTH [KTH_L_MODIFIERS], BUFSIZ=0),
	    (ITMCOD=TRM$_PROMPT, BUFADR=T_CR, BUFSIZ=1),
	    (ITMCOD=TRM$_INISTRNG, BUFADR=BUFFER, BUFSIZ=0),
	    (ITMCOD=TRM$_INIOFFSET, BUFADR=0, BUFSIZ=0),
	    (ITMCOD=TRM$_TERM, BUFSIZ=0,
		BUFADR=.KTH [KTH_L_TERM_MASK]));
    
	IF NOT NULLPARAMETER (K_DISPLAY_ID)
	THEN
	    BEGIN			! display_id present
	    !+
	    ! Interfacing with output's virtual displays.  Make sure user can
	    ! not type beyond the display's boundaries by limiting the input
	    ! size to the number of free columns (allowing room for prompt, if
	    ! any).
	    ! Notice that we need some info from SMG$$SET_PROMPT_STRING (prompt
	    ! string length), and we need to provide it with some info (set cursor
	    ! sequence, if any).  So get the info here and save it.
	    !+
	    LOCAL
		OUT_STATUS;
	    DISPLAY_ID_FLAG = 1;	! for quick checks later
	    IF .KCB [KCB_L_PASTEBOARD_ID] LSS 0	! pb not established yet
	    THEN
	 	BEGIN
	    	OUT_STATUS = SMG$$GET_PASTEBOARD_ID (%REF (.KCB [KCB_W_DEVNAM_LENGTH]),
						     KCB [KCB_T_DEVNAM_STRING],
						     KCB [KCB_L_PASTEBOARD_ID]);
		IF NOT .OUT_STATUS THEN RETURN (.OUT_STATUS);
		END;
	    OUT_STATUS = SMG$$SET_PHYSICAL_CURSOR (.DISPLAY_ID,
						   KCB [KCB_L_PASTEBOARD_ID],
						   CURSOR_BUF,
						   CURSOR_BUF_LEN,
						   FREE_COLS);
	    IF NOT .OUT_STATUS THEN RETURN .OUT_STATUS;
	    END;			! display_id present

	IF .DISPLAY_ID_FLAG
	THEN
	    BEGIN	! Batching check

	    LOCAL
		DCB : REF BLOCK [,BYTE];

	    $SMG$GET_DCB (.DISPLAY_ID, DCB);

	    !+
	    ! Don't allow input if display is batched.
	    !-

	    IF .DCB[DCB_L_BATCH_LEVEL] NEQ 0
	    THEN
		RETURN	SMG$_ILLBATFNC;

	    END;	! Batching check

	!+
	! Get prompt string, if any.
	!-

	    IF .DISPLAY_ID_FLAG OR
	       NOT NULLPARAMETER (K_PROMPT_STRING)
	    THEN
		BEGIN
		LOCAL
		    STATUS,
		    NULL_STRING : BLOCK [8,BYTE];

		NULL_STRING [DSC$B_CLASS] = DSC$K_CLASS_S;
		NULL_STRING [DSC$B_DTYPE] = DSC$K_DTYPE_T;
		NULL_STRING [DSC$W_LENGTH] = 0;
		NULL_STRING [DSC$A_POINTER] = UPLIT (' ');

	    	STATUS = SMG$$SET_PROMPT_STRING (
		     		(IF NULLPARAMETER (K_PROMPT_STRING)
		 		 THEN
				     NULL_STRING	
				 ELSE
				     PROMPT_STRING [0,0,0,0]),
				ITEM_LIST [K_PROMPT,0,0,0,0],
				.CURSOR_BUF_LEN,
				CURSOR_BUF);
	    	IF NOT .STATUS
	    	THEN
		    RETURN .STATUS;
	    	FLAGS [V_SETPROMPT] = 1;
	    	END;
	
	!+
	! Set up the $QIOW argument list.
	!-
    
	KCB [KCB_L_QIO1_FUNC] = IO$_READVBLK+IO$M_EXTEND;
	KCB [KCB_L_QIO1_P1] = BUFFER;
	KCB [KCB_L_QIO1_P2] = %ALLOCATION(BUFFER) - 4; ! Reserve 4 for term. echo
	KCB [KCB_L_QIO1_P3] = 0;
	KCB [KCB_L_QIO1_P4] = 0;
	KCB [KCB_L_QIO1_P5] = ITEM_LIST;
	KCB [KCB_L_QIO1_P6] = %ALLOCATION(ITEM_LIST) - 4; ! Extra longword added
							  ! by $ITMLST_DECL.
    
	IF .DISPLAY_ID_FLAG
	THEN
		BEGIN
		IF PROMPT_STRING [0,0,0,0] NEQA 0
		THEN
		    FREE_COLS = .FREE_COLS - .PROMPT_STRING [DSC$W_LENGTH];
		IF .FREE_COLS LEQ 0
		THEN
		    !+
		    ! No room to accept input.  Exit.
		    !-
		    RETURN (SMG$_INVCOL);	! improve this message later

		IF .KCB [KCB_L_QIO1_P2] GTR .FREE_COLS
		THEN
		    KCB [KCB_L_QIO1_P2] = .FREE_COLS;
		END;

	!+
	! Start with a default state, indicate that the state lock is off and
	! get the pointer to the next open position in the buffer.
	!-
    
	TKEY_DSC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	TKEY_DSC [DSC$B_CLASS] = DSC$K_CLASS_S;
	TKEY_DSC [DSC$A_POINTER] = TKEY;
	NEXT_POS = BUFFER;
    
	!+
	! Loop until a terminator is seen, composing the line.
	!-
    
	WHILE 1 DO
	    BEGIN
    
	    !+
	    ! Prevent last portion of line from echoing unless later
	    ! shown to be necessary.
	    !-

	    FLAGS [V_SKIP_LAST_ECHO] = 1;

	    !+
	    ! Read the next part of the line.
	    !-
    
		BEGIN
		LOCAL
		    QIO_STATUS;
		QIO_STATUS = CALLG (KCB [KCB_R_QIO1], SYS$QIOW);
		IF .QIO_STATUS
		THEN
		    QIO_STATUS = .KCB [KCB_W_IOSB_STATUS];
		IF .KCB [KCB_W_IOSB_STATUS] EQLU SS$_PARTESCAPE
		    THEN
			BEGIN
			!+
			! Check for partial escape sequence in the buffer.  This can
			! happen if the QIO was limited to 2 characters and the input
			! string was terminated by a keypad key (which are 3 chars).
			!-

	    		LOCAL
			    QIO_RESULT,
			    CHAR_BUF : BYTE,
			    END_ESC_FLAG : INITIAL (0);

	    		BUFFER_LEN = .KCB [KCB_W_IOSB_COUNT] + .KCB [KCB_B_IOSB_TERMLEN];
					! point past data & partial terminator

	    		WHILE .END_ESC_FLAG EQL 0 DO
			BEGIN
			    QIO_RESULT = $QIOW (EFN = .KCB [KCB_L_EFN],
				    CHAN = .KCB [KCB_W_CHANNEL],
				    FUNC = (IO$_READVBLK + IO$M_ESCAPE +
					    IO$M_NOECHO + IO$M_NOFILTR +
					    IO$M_TRMNOECHO),
				    P1 = CHAR_BUF,
				    P2 = 1,
				    P4 = .KCB [KCB_L_QIO1_P4]);
					! P4 = defined terminator set
			    IF NOT .QIO_RESULT THEN RET_STATUS = .QIO_RESULT;

			    !+
			    ! Move terminator characters to buffer.
			    !-

			    BUFFER [.BUFFER_LEN] = .CHAR_BUF;
			    BUFFER_LEN = .BUFFER_LEN + 1;
			    KCB [KCB_B_IOSB_TERMLEN] = .KCB [KCB_B_IOSB_TERMLEN] + 1;

			    CASE .CHAR_BUF FROM %C'A' TO %C'~' OF
			    SET
		    		[%C'A' TO %C'D',	! arrow keys
		     		%C'M',		! Enter
		     		%C'P' to %C'S',	! PFn keys
		     		%C'l' to %C'n',	! keypad - , .
		     		%C'p' to %C'y',	! keypad 0-9
				%C'~']:		! function keys F6-F20 (no codes for
		 	
				    END_ESC_FLAG = 1;

		    		[INRANGE, OUTRANGE]:
				    ;		! didn't find end of esc terminator
					        ! keep searching
			    TES;

			END;			! end of WHILE loop

			QIO_STATUS = .QIO_RESULT;
						! get rid of partescape error

	    	    	END;			! end of partial ESC terminator

		IF .QIO_STATUS NEQU SS$_NORMAL
		THEN
		    BEGIN
		    IF NOT .QIO_STATUS
		    THEN
			BEGIN
			IF .QIO_STATUS EQLU SS$_BADESCAPE
			THEN
			    KCB [KCB_B_IOSB_TERMLEN] = 0
			ELSE
			    BEGIN
			    RET_STATUS = .QIO_STATUS;
			    EXITLOOP;
			    END;
			END
		    ELSE IF (.QIO_STATUS EQLU SS$_CONTROLY) OR
			    (.QIO_STATUS EQLU SS$_CONTROLC)
		    THEN
			BEGIN
			ITEM_LIST [K_INIOFFSET, ITM$L_BUFADR] = 1;
			ITEM_LIST [K_INISTRNG, ITM$W_BUFSIZ] = 0;
			FLAGS [V_SKIP_NEWLINE] = 1;	! Indicate that NEWLINE should not echo
			EXITLOOP;
			END

		    END;
		END;
    
	    !+
	    ! Set the initial offset to indicate the position (1-origin)
	    ! where the next read should start.  Set NEXT_POS to that
	    ! location in the buffer.  Note that NEXT_POS will then point
	    ! to the start of the terminator.  Set the initial string to
	    ! what has been typed so far.
	    !-
    
		BEGIN
		LOCAL
		    NEXT_INDEX;	! Index to next available position
		NEXT_INDEX = .KCB [KCB_W_IOSB_COUNT];
		ITEM_LIST [K_INIOFFSET, ITM$L_BUFADR] = .NEXT_INDEX + 1;
		ITEM_LIST [K_INISTRNG, ITM$W_BUFSIZ] = .NEXT_INDEX;
		NEXT_POS = BUFFER [.NEXT_INDEX];

		!+
		! If the buffer is now full, exit immediately.
		!-

		IF .NEXT_INDEX GEQU .KCB [KCB_L_QIO1_P2] ! Buffer size
		THEN
		    EXITLOOP;
		END;
    
	    !+
	    ! If the terminator was <CR>, exit immediately.
	    !-
    
	    IF CH$RCHAR(.NEXT_POS) EQLU K_CR
	    THEN
		BEGIN
		FLAGS [V_SKIP_LAST_ECHO] = 1;
		EXITLOOP;
		END;
    
	    !+
	    ! Get the terminator name, if any.
	    !-
	    
	    KEY_CODE = SMG$$TERM_TO_KEYCODE (.NEXT_POS, .KCB [KCB_B_IOSB_TERMLEN]);
    
	    !+
	    ! Reset state to default if needed.  Cause state to be reset
	    ! next time unless disabled later.
	    !-

	    IF TESTBITSS (FLAGS [V_RESET_STATE])
	    THEN
		BEGIN
		TKEY_DSC_PTR = KTH [KTH_R_DEF_STATE_DESCR];
		TKEY_POS = .KTH [KTH_A_DEF_KEYCODE];
		END;

	    !+
	    ! Construct TKEY.
	    !-
    
	    TKEY_POS [0] = .KEY_CODE;
    
	    !+
	    ! Look up key to see if it is defined as anything.
	    !-
    
	    IF (SMG$$LOOKUP_KEY (.KTH, .TKEY_DSC_PTR; KDE))
	    THEN
		BEGIN
		LOCAL
		    NEW_LENGTH: WORD;
		NEW_LENGTH = .ITEM_LIST [K_INISTRNG, ITM$W_BUFSIZ] +
		    .KDE [KDE_W_EQUIV_LENGTH];
		IF .NEW_LENGTH LEQU 512
		THEN
		    BEGIN
		    LOCAL
			CURSOR_POS;	! Position of cursor

		    !+
		    ! Append equivalence string to initial string.
		    ! Current cursor position may not be at end of string.
		    !-
    
		    ITEM_LIST [K_INISTRNG, ITM$W_BUFSIZ] = .NEW_LENGTH;

		    !+
		    ! If NOECHO, add the equivalence string size
		    ! to the initial string offset so that we don't
		    ! write it out.
		    !+
    
		    IF .KDE [KDE_V_NOECHO]
		    THEN
			ITEM_LIST [K_INIOFFSET, ITM$L_BUFADR] = 
			    .ITEM_LIST [K_INIOFFSET, ITM$L_BUFADR] +
			    .KDE [KDE_W_EQUIV_LENGTH]
		    ELSE
			FLAGS [V_SKIP_LAST_ECHO] = 0;

		    CURSOR_POS = .NEXT_POS - .KCB [KCB_B_IOSB_POS];
		    IF .CURSOR_POS EQLA .NEXT_POS
		    THEN
			BEGIN
			!+
			! Cursor is at end of line.
			!-
			NEXT_POS = CH$MOVE (.KDE [KDE_W_EQUIV_LENGTH],
			    .KDE [KDE_A_EQUIV_POINTER], .NEXT_POS);

			END
		    ELSE
			BEGIN
			!+
			! Cursor is not at end of line.  Move remainder of
			! line over and reset offset to cursor position.
			!-

			NEXT_POS = CH$MOVE ((.NEXT_POS-.CURSOR_POS), .CURSOR_POS,
			    (.CURSOR_POS+.KDE [KDE_W_EQUIV_LENGTH]));
			CH$MOVE (.KDE [KDE_W_EQUIV_LENGTH],
			    .KDE [KDE_A_EQUIV_POINTER], .CURSOR_POS);

			!+
			! If not NOECHO, move the initial offset back to where
			! we need to display characters.
			!-

			IF NOT .KDE [KDE_V_NOECHO]
			THEN
			    ITEM_LIST [K_INIOFFSET, ITM$L_BUFADR] =
				(.CURSOR_POS-BUFFER)+1;
			END;
		    END;
		
		!+
		! If this key sets a new state, store it.
		!-
    
		IF .KDE [KDE_V_SETSTATE]
		THEN
		    BEGIN
		    IF .KDE [KDE_V_LOCK]	! Locks new state?
		    THEN
			!+
			! Select the default state string as the
			! the basis for TKEY.
			!-
			TKEY_DSC_PTR = KTH [KTH_R_DEF_STATE_DESCR]
		    ELSE
			BEGIN
			!+
			! Use local TKEY descriptor.  Cause state to not
			! get reset to default on next iteration.
			!-
			TKEY_DSC_PTR = TKEY_DSC;
			FLAGS [V_RESET_STATE] = 0;
			END;

		    TKEY_POS = CH$MOVE (.KDE [KDE_W_STATE_LENGTH],
			.KDE [KDE_A_STATE_POINTER],
			.TKEY_DSC_PTR [DSC$A_POINTER]);
		    CH$WCHAR_A (0, TKEY_POS);
		    IF .KDE [KDE_V_LOCK]
		    THEN
			KTH [KTH_A_DEF_KEYCODE] = .TKEY_POS;
		    TKEY_DSC_PTR [DSC$W_LENGTH] = .KDE [KDE_W_STATE_LENGTH] + 3;
		    END;

		!+
		! If this terminates the read, exit the loop.
		!-
    
		IF .KDE [KDE_V_TERMINATE]
		THEN
		    EXITLOOP;
    
		END
	    ELSE
		BEGIN

		!+
		! Key is not defined.
		!-

		LOCAL
		    CURSOR_POS;

		!+
		! Cursor position must be moved to the end of the line.
		!-

		CURSOR_POS = .NEXT_POS - .KCB [KCB_B_IOSB_POS];
		ITEM_LIST [K_INIOFFSET, ITM$L_BUFADR] =
		    (.CURSOR_POS-BUFFER)+1;

		!+
		! If it is ^Z, then terminate anyway.
		!-

		IF CH$RCHAR (.NEXT_POS) EQLU K_CTRLZ
		THEN
		    BEGIN

		    !+
		    ! If ^Z was the first character in the line,
		    ! return SMG$_EOF now.  Otherwise, record the
		    ! fact that ^Z was typed for use on the next read.
		    !-
		    IF .KCB [KCB_W_IOSB_COUNT] EQL 0
		    THEN
			RET_STATUS = SMG$_EOF	! End-of-file
		    ELSE
			KCB [KCB_V_CTRLZ] = 1;

		    FLAGS [V_ECHO_CTRLZ] = 1;

		    EXITLOOP;
		    END
    
		!+
		! Else if the terminator was ENTER or DO and wasn't defined,
		! treat it as <CR>.
		!-
    
		ELSE IF (.KEY_CODE EQL SMG$K_TRM_ENTER) OR
			(.KEY_CODE EQL SMG$K_TRM_DO)
		THEN
		    BEGIN
		    FLAGS [V_SKIP_LAST_ECHO] = 1;
		    EXITLOOP;
		    END;

		END;
    
	    END;
	
	!+
	! Do a final read so that the last equivalence characters
	! (if any) will echo.  Do the read with a zero-timeout so
	! that we don't get any more characters.
	!-

	IF NOT .FLAGS [V_SKIP_LAST_ECHO]
	THEN
	    BEGIN
	    KCB [KCB_L_QIO1_P2] = .ITEM_LIST [K_INISTRNG, ITM$W_BUFSIZ];
	    ITEM_LIST [K_TERM, ITM$W_ITMCOD] = TRM$_TIMEOUT;
	    ITEM_LIST [K_TERM, ITM$W_BUFSIZ] = 0;
	    ITEM_LIST [K_TERM, ITM$L_BUFADR] = 0;
	    CALLG (KCB [KCB_R_QIO1], SYS$QIOW);
	    END;
    
	!+
	! If DISPLAY_ID was passed, call back output side to tell it
	! what changed on the screen as a result of this prompt & input.
	!-

    	IF .DISPLAY_ID_FLAG
	THEN
	    BEGIN
	    LOCAL
		OUT_STATUS;
	    IF PROMPT_STRING [0,0,0,0] NEQA 0
	    THEN
		BEGIN			! report prompt string change
	        OUT_STATUS = SMG$$REPORT_CHANGE_REPLACE (.DISPLAY_ID,
						     KCB [KCB_L_PASTEBOARD_ID],
						     %REF (.PROMPT_STRING [DSC$W_LENGTH]),
						     .PROMPT_STRING [DSC$A_POINTER]);
		IF NOT .OUT_STATUS AND .OUT_STATUS NEQ SMG$_STRTERESC
		THEN 
		    RETURN .OUT_STATUS;
		END;			! report prompt string change
	    
	    OUT_STATUS = SMG$$REPORT_CHANGE_REPLACE (.DISPLAY_ID,
						     KCB [KCB_L_PASTEBOARD_ID],
						     %REF (.KCB [KCB_W_IOSB_COUNT]),
						     BUFFER);
					! report user's input string
	    IF NOT .OUT_STATUS THEN RETURN .OUT_STATUS;
	    END;

	!+
	! If we need to echo for ^Z, do it.
	!-

	IF .FLAGS [V_ECHO_CTRLZ]
	THEN
	    BEGIN
	    !+
	    ! Echo the appropriate sequence depending on whether this
	    ! is a DECCRT or not.
	    ! The 2 sequences can be found as translations of the
	    ! system logical name TTY$EXIT_STRING (set up by SYSGEN).
	    ! It has two equivalence strings. The first one is for
	    ! DECCRT's, the second one is for other terminals.
	    ! If this logical is not defined, we use internal echoes.
	    !-
	    BIND
		KCB_DEVDEPEND2 = KCB [KCB_L_DEVDEPEND2]: BLOCK [4, BYTE];

	    LOCAL
		STATUS,
		ITEMLIST	: VECTOR[4*3+1],
		DECCRT_LEN	: WORD,
		OTHER_LEN	: WORD,
		DECCRT_PTR,
		OTHER_PTR,
		SYSTEM_TABLE	: VECTOR[2],
		LOGICAL		: VECTOR[2],
		DECCRT_ECHO	: VECTOR[LNM$C_NAMLENGTH,BYTE],
		OTHER_ECHO	: VECTOR[LNM$C_NAMLENGTH,BYTE];

	    ITEMLIST[0]=LNM$_INDEX^16+4;
	    ITEMLIST[1]=UPLIT(0);
	    ITEMLIST[2]=0;

	    ITEMLIST[3]=LNM$_STRING^16+LNM$C_NAMLENGTH;
	    ITEMLIST[4]=DECCRT_ECHO;
	    ITEMLIST[5]=DECCRT_LEN;

	    ITEMLIST[6]=LNM$_INDEX^16+4;
	    ITEMLIST[7]=UPLIT(1);
	    ITEMLIST[8]=0;

	    ITEMLIST[9]=LNM$_STRING^16+LNM$C_NAMLENGTH;
	    ITEMLIST[10]=OTHER_ECHO;
	    ITEMLIST[11]=OTHER_LEN;

	    ITEMLIST[12]=0;

	    SYSTEM_TABLE[0]=%CHARCOUNT('LNM$SYSTEM_TABLE');
	    SYSTEM_TABLE[1]=UPLIT BYTE('LNM$SYSTEM_TABLE');
	    LOGICAL[0]=%CHARCOUNT('TTY$EXIT_STRING');
	    LOGICAL[1]=UPLIT BYTE('TTY$EXIT_STRING');

	    DECCRT_PTR=T_CTRLZ_DECCRT;
	    DECCRT_LEN=%ALLOCATION(T_CTRLZ_DECCRT);
	    OTHER_PTR=T_CTRLZ_OTHER;
	    OTHER_LEN=%ALLOCATION(T_CTRLZ_OTHER);

	    ! No change if logical name isn't there or
	    ! any other problem translating this name.

	%IF NOT %VARIANT
	%THEN

	    STATUS=$TRNLNM(TABNAM=SYSTEM_TABLE,
			   LOGNAM=LOGICAL,
			   ITMLST=ITEMLIST);
	    IF .STATUS
	    THEN
		BEGIN
		DECCRT_PTR=DECCRT_ECHO;
		OTHER_PTR=OTHER_ECHO;
		END;

	%FI

	    KCB [KCB_L_QIO1_FUNC] = IO$_WRITEVBLK;
	    IF .KCB_DEVDEPEND2 [TT2$V_DECCRT]
	    THEN
		BEGIN
		KCB [KCB_L_QIO1_P1] = .DECCRT_PTR;
		KCB [KCB_L_QIO1_P2] = .DECCRT_LEN;
		END
	    ELSE
		BEGIN
		KCB [KCB_L_QIO1_P1] = .OTHER_PTR;
		KCB [KCB_L_QIO1_P2] = .OTHER_LEN;
		END;
	    
	    CALLG (KCB [KCB_R_QIO1], SYS$QIOW);
	    END;

	!+
	! Echo NEWLINE, if needed.
	!-

	IF NOT .FLAGS [V_SKIP_NEWLINE]
	THEN
	    BEGIN
	    KCB [KCB_L_QIO1_FUNC] = IO$_WRITEVBLK+IO$M_NEWLINE;
	    KCB [KCB_L_QIO1_P1] = T_CR;
	    KCB [KCB_L_QIO1_P2] = 1;
	    CALLG (KCB [KCB_R_QIO1], SYS$QIOW);
	    END;

	!+
	! Set BUFFER_PTR and BUFFER_LEN.
	!-

	BUFFER_PTR = BUFFER;
	BUFFER_LEN = .ITEM_LIST [K_INISTRNG, ITM$W_BUFSIZ];

	!+
	! Delete the prompt string, if any.
	!-

	IF .FLAGS [V_SETPROMPT]
	THEN
	    SMG$$DELETE_PROMPT_STRING (ITEM_LIST [K_PROMPT,0,0,0,0]);
	END;

    !+
    ! We now have the complete line in BUFFER, with length BUFFER_LEN.
    ! Copy it to the user's string.
    !-

    COPY_STATUS = LIB$SCOPY_R_DX6 (.BUFFER_LEN,
	.BUFFER_PTR, OUT_LINE [0,0,0,0]);
    IF NOT .COPY_STATUS
    THEN
	RETURN .COPY_STATUS;

    !+
    ! Fill in OUT_LENGTH if requested.
    !-

    IF NOT NULLPARAMETER (K_OUT_LENGTH)
    THEN
	BEGIN
	LOCAL
	    LINE_LENGTH: WORD;
	LIB$ANALYZE_SDESC_R2 (OUT_LINE [0,0,0,0]; LINE_LENGTH);
	IF .LINE_LENGTH LSSU .BUFFER_LEN
	THEN
	    BUFFER_LEN = .LINE_LENGTH;
	OUT_LENGTH [0] = .BUFFER_LEN;
	END;

    RETURN .RET_STATUS;

    END;				! End of routine SMG$READ_COMPOSED_LINE

%SBTTL 'SMG$DELETE_VIRTUAL_KEYBOARD'
GLOBAL ROUTINE SMG$DELETE_VIRTUAL_KEYBOARD (
    KEYBOARD_ID: REF VECTOR [, LONG]
    ) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine deletes a virtual-keyboard which was created by a call
!	to SMG$CREATE_VIRTUAL_KEYBOARD.  Any terminal attributes changed
!	when the virtual-keyboard was created are reset to their previous
!	values.
!
! CALLING SEQUENCE:
!
!	RET_STATUS.wlc.v = SMG$DELETE_VIRTUAL_KEYBOARD (
!				KEYBOARD_ID.rl.r)
!
! FORMAL PARAMETERS:
!
!	KEYBOARD_ID	A longword containing the identification of the
!			virtual-keyboard which is to be deleted.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	SS$_NORMAL	Normal successful completion
!	SMG$_INVKBD_ID	Invalid keyboard-id
!	SMG$_WRONUMARG	Wrong number of arguments
!
! SIDE EFFECTS:
!
!	The keypad mode (numeric or application) is reset to its original state
!	The terminal characteristics are reset to their original state
!	The file is closed or the channel is deassigned.
!
!--

    BEGIN

    LOCAL
	KCB: REF KCB_R_KCB_STRUCT;

    $SMG$VALIDATE_ARGCOUNT(1,1);

    !+
    ! Fetch and validate KCB.
    !-

    $SMG$VALIDATE_KCB (KEYBOARD_ID, KCB);

    !+
    ! Invalidate the user's KEYBOARD_ID.
    !-

    KEYBOARD_ID [0] = 0;

    !+
    ! Call SMG$$CLEANUP to do the actual close, etc.
    ! Return with success.
    !-

    RETURN (SMG$$CLEANUP (KCB [KCB_R_KCB], SS$_NORMAL));

    END;			! End of routine SMG$DELETE_VIRTUAL_KEYBOARD

%SBTTL 'SMG$SET_KEYPAD_MODE'
GLOBAL ROUTINE SMG$SET_KEYPAD_MODE (
    KEYBOARD_ID: REF VECTOR [, LONG],
    KEYPAD_MODE: REF VECTOR [, LONG]
    ) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This procedure sets the state of the terminal's numeric keypad to either
!	applications mode or numeric mode.  In applications mode, numeric
!	keypad keys (which may also include punctuation keys) are considered
!	function keys and are useable as terminators.  In numeric mode, these
!	keys are equivalent to the keys with similar legends on the main
!	key array and are not generally useable as terminators.
!
!	For VT5x, VT1xx (and compatible LAxx), and LK201 keyboards, the
!	following table lists the legends on the keypad keys, their key name
!	in applications mode, and their key value in numeric mode:
!
!		Legend		Applications	   Numeric
!		On Key	  	    Mode	     Mode
!		------		------------	   -------
!		  0		     KP0	      0
!		  1		     KP1	      1
!		  2		     KP2	      2
!		  3		     KP3	      3
!		  4		     KP4	      4
!		  5		     KP5	      5
!		  6		     KP6	      6
!		  7		     KP7	      7
!		  8		     KP8	      8
!		  9		     KP9	      9
!		  -		    MINUS	      -
!		  ,		    COMMA	      ,
!		  .		   PERIOD	      .
!		ENTER		    ENTER	     <CR>
!
!	Note that VT5x keyboards do not have all of these keys.
!
!	When a virtual-keyboard is created, the terminal is set by default
!	to applications mode.  When the virtual-keyboard is deleted the
!	state of the keypad is restored to its previous mode, as determined
!	by the terminal characteristic TT2$V_APP_KEYPAD.
!
! CALLING SEQUENCE:
!
!	RET_STATUS.wlc.v = SMG$SET_KEYPAD_MODE (
!				KEYBOARD_ID.rl.r,
!				NEW_MODE.rl.r)
!
! FORMAL PARAMETERS:
!
!	KEYBOARD_ID	A longword containing the identification of the
!			virtual-keyboard for which the keypad mode is being
!			set or returned.
!
!	KEYPAD_MODE	A longword whose low bit is used to set the new
!			state of the keypad mode.  If the low bit is set, the
!			keypad is set into numeric mode.  If clear, the
!			keypad is set into applications mode.  The default
!			mode when a virtual-keyboard is created is
!			applications mode.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	SS$_NORMAL	Normal successful completion
!	SMG$_INVKBD_ID	Invalid keyboard-id
!	SMG$_WRONUMARG	Wrong number of arguments
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LOCAL
	KCB: REF KCB_R_KCB_STRUCT;

    BUILTIN
	CALLG;

    $SMG$VALIDATE_ARGCOUNT(2,2);

    !+
    ! Validate Keyboard Control Block
    !-

    $SMG$VALIDATE_KCB (KEYBOARD_ID, KCB);

    !+
    ! Only change the keypad mode if we're at a terminal.
    !-

    IF NOT .KCB [KCB_V_RMS]
    THEN
	BEGIN

	BIND
	    KCB_DEVDEPEND2 = KCB [KCB_L_DEVDEPEND2]: BLOCK [4, BYTE];

	!+
	! Select whether we want to set or clear applications mode.
	!-

	IF .KEYPAD_MODE [0]
	THEN
	    BEGIN
	    !+
	    ! Set applications mode.
	    !-

	    !+
	    ! Mark the keypad as in applications mode.
	    !-
    
	    KCB_DEVDEPEND2 [TT2$V_APP_KEYPAD] = 1;

	    !+
	    ! Choose the proper control sequence to send.
	    !-

	    IF .KCB [KCB_V_KPDSEQ_DECCRT]
	    THEN
		BEGIN
		!+
		! Use sequence for DECCRT and VT5x.
		!-

		KCB [KCB_L_QIO2_P1] = T_KPDAPP_DECCRT;
		KCB [KCB_L_QIO2_P2] = %ALLOCATION(T_KPDAPP_DECCRT);
		END
	    ELSE SELECTONEU .KCB [KCB_B_DEVTYPE] OF
		SET
		[OTHERWISE]:
		    BEGIN
		    !+
		    ! Unknown type.
		    !-
		    KCB [KCB_L_QIO2_P1] = 0;
		    KCB [KCB_L_QIO2_P2] = 0;
		    END;
		TES;
	    END
	ELSE
	    BEGIN
	    !+
	    ! Set numeric (non-application) mode.
	    !-

	    !+
	    ! Mark the keypad as in numeric mode.
	    !-
    
	    KCB_DEVDEPEND2 [TT2$V_APP_KEYPAD] = 0;

	    !+
	    ! Choose the proper control sequence to send.
	    !-

	    IF .KCB [KCB_V_KPDSEQ_DECCRT]
	    THEN
		BEGIN
		!+
		! Use sequence for DECCRT and VT5x.
		!-

		KCB [KCB_L_QIO2_P1] = T_KPDNUM_DECCRT;
		KCB [KCB_L_QIO2_P2] = %ALLOCATION(T_KPDNUM_DECCRT);
		END
	    ELSE SELECTONEU .KCB [KCB_B_DEVTYPE] OF
		SET
		[OTHERWISE]:
		    BEGIN
		    !+
		    ! Unknown type.
		    !-
		    KCB [KCB_L_QIO2_P1] = 0;
		    KCB [KCB_L_QIO2_P2] = 0;
		    END;
		TES;
	    END;
	    
	!+
	! Write the sequence to the terminal.
	!-

	KCB [KCB_L_QIO2_FUNC] = IO$_WRITEVBLK+IO$M_NOFORMAT;
	KCB [KCB_L_QIO2_P3] = 0;
	KCB [KCB_L_QIO2_P4] = 0;
	KCB [KCB_L_QIO2_P5] = 0;
	KCB [KCB_L_QIO2_P6] = 0;
	CALLG (KCB [KCB_R_QIO2], SYS$QIOW);

	!+
	! Set the new characteristics.
	!-

	KCB [KCB_L_QIO2_FUNC] = IO$_SETMODE;
	KCB [KCB_L_QIO2_P1] = KCB [KCB_R_TERMCHAR];
	KCB [KCB_L_QIO2_P2] = KCB_S_TERMCHAR;
	CALLG (KCB [KCB_R_QIO2], SYS$QIOW);

	!+
	! Mark that the terminal characteristics have been changed.
	!-

	KCB [KCB_V_CHARS_CHANGED] = 1;

	END;

    RETURN SS$_NORMAL;

    END;				! End of routine SMG$SET_KEYPAD_MODE

%SBTTL 'SMG$CANCEL_INPUT'
GLOBAL ROUTINE SMG$CANCEL_INPUT (
    KEYBOARD_ID: REF VECTOR [, LONG]
    ) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This procedure causes immediate termination 
!	of a terminal read-in-progress which was issued by
!	SMG$READ_STRING or SMG$READ_COMPOSED_LINE.  If the
!	virtual-keyboard is associated with an RMS file, this procedure
!	has no effect, since it is not possible to cancel an outstanding
!	RMS input operation.
!
! CALLING SEQUENCE:
!
!	RET_STATUS.wlc.v = SMG$CANCEL_INPUT (
!				KEYBOARD_ID.rl.r)
!
! FORMAL PARAMETERS:
!
!	KEYBOARD_ID	A longword containing the identification of the
!			virtual keyboard for which the input is to be
!			cancelled.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	SS$_NORMAL	Normal successful completion
!	SS$_RMSNOTCAN	Success - RMS operation cannot be cancelled
!	SMG$_INVKBD_ID	Invalid keyboard-id
!	SMG$_WRONUMARG	Wrong number of arguments
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LOCAL
	KCB: REF KCB_R_KCB_STRUCT,
	CANCEL_STATUS;

    $SMG$VALIDATE_ARGCOUNT(1,1);

    !+
    ! Validate Keyboard Control Block
    !-

    $SMG$VALIDATE_KCB (KEYBOARD_ID, KCB);

    !+
    ! Only cancel input if we're at a terminal.
    !-

    IF NOT .KCB [KCB_V_RMS]
    THEN
	BEGIN

	CANCEL_STATUS = $CANCEL (CHAN=.KCB [KCB_W_CHANNEL]);
	IF NOT .CANCEL_STATUS
	THEN
	    RETURN .CANCEL_STATUS;
	END;

    RETURN SS$_NORMAL;

    END;				! End of routine SMG$CANCEL_INPUT

%SBTTL 'SMG$$SET_PROMPT_STRING'
ROUTINE SMG$$SET_PROMPT_STRING (
    PROMPT_STRING: REF BLOCK [, BYTE],		! Prompt string descriptor
    ITEM_LIST: REF $ITMLST_DECL (ITEMS=1),	! Prompt string list item
    PRE_BUF_LEN,				! Pre-prompt buffer length
    PRE_BUFFER					! Pre-prompt buffer
    ) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This procedure adds the necessary carriagecontrol to the user-specified
!	prompt string and stores it in an item-list descriptor.
!
! CALLING SEQUENCE:
!
!	ret_status.wlc.v = SMG$$SET_PROMPT_STRING (prompt_string.rt.dx,
!						item_list.ww.r,
!						pre_buf_len.rl.v,
!						pre_buffer.ra.r)
!
! FORMAL PARAMETERS:
!
!	PROMPT_STRING	The descriptor of the prompt string.
!
!	ITEM_LIST	The QIO item-list entry for the prompt-string.
!
!	PRE_BUF_LEN	Length of buffer to insert before the prompt
!			string.  (Used when interfacing to virtual display.)
!
!	PRE_BUFFER	Address of string to insert before the prompt
!			string.  (Used when interfacing to virtual display.)
!
! IMPLICIT INPUTS:
!
!	QPS_QUEUE	Queue of prompt strings
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	SS$_NORMAL	Normal successful completion
!	Errors from LIB$GET_VM 
!
! SIDE EFFECTS:
!
!	None
!
!--

    BEGIN

    LOCAL
	STRING_LEN: WORD,		! Length of PROMPT_STRING
	STRING_PTR,			! Pointer to PROMPT_STRING
	ALLOC_LEN,			! Allocated string length
	ALLOC_PTR,			! Pointer to allocated string
	ANL_STATUS, VM_STATUS;		! Status from called procedures

    LITERAL
	K_CR = 13;			! <CR>

    BUILTIN
	REMQUE;

    !+
    ! Analyze PROMPT_STRING to get the length and address.
    !-

    ANL_STATUS = LIB$ANALYZE_SDESC_R2 (PROMPT_STRING [0,0,0,0];
	STRING_LEN, STRING_PTR);
    IF NOT .ANL_STATUS
    THEN
	RETURN .ANL_STATUS;

    ALLOC_LEN = .STRING_LEN + 1;
    IF .ALLOC_LEN GTRU 65535
    THEN
	RETURN SMG$_PROTOOLON;	! Prompt string is too long
    ITEM_LIST [0,ITM$W_BUFSIZ] = .ALLOC_LEN;
    ALLOC_PTR = 0;

    !+
    ! If ALLOC_LEN is small enough so that we can get the string from
    ! our queue, do so.
    !-

    IF .ALLOC_LEN LEQU (K_QPS_SIZE - 10)
    THEN
	BEGIN
	IF REMQUE (.QPS_QUEUE [0], ALLOC_PTR)
	THEN
	    BEGIN
	    ALLOC_PTR = 0;	! Failure
	    ALLOC_LEN = K_QPS_SIZE;	! Allocate a full QPS entry.
	    END;
	END;

    !+
    ! If pointer is still zero, we have to allocate the string with LIB$GET_VM.
    !-

    IF .ALLOC_PTR EQL 0
    THEN
	BEGIN
	VM_STATUS = LIB$GET_VM (ALLOC_LEN, ITEM_LIST [0,ITM$L_BUFADR]);
	IF NOT .VM_STATUS
	THEN
	    RETURN .VM_STATUS;
	ALLOC_PTR = .ITEM_LIST [0,ITM$L_BUFADR];
	END;

    !+
    ! Store the prompt string with a leading CR for carriagecontrol.
    !
    ! If input is interfacing with output SMG$ routines (ie. a virtual
    ! display present), use the caller's buffer instead of CR.  This
    ! buffer should contain the set cursor sequence to establish the
    ! desired cursor position.
    !-

    ITEM_LIST [0,ITM$L_BUFADR] = .ALLOC_PTR;
    IF .PRE_BUF_LEN EQL 0
    THEN
        CH$WCHAR_A (K_CR, ALLOC_PTR)
    ELSE
	BEGIN
	ITEM_LIST [0,ITM$W_BUFSIZ] = .STRING_LEN + .PRE_BUF_LEN;
	ALLOC_PTR = CH$MOVE (.PRE_BUF_LEN, .PRE_BUFFER, .ALLOC_PTR);
	END;
    CH$MOVE (.STRING_LEN, .STRING_PTR, .ALLOC_PTR);
    RETURN SS$_NORMAL;

    END;				! End of routine SMG$$SET_PROMPT_STRING

%SBTTL 'SMG$$DELETE_PROMPT_STRING'
ROUTINE SMG$$DELETE_PROMPT_STRING (
    ITEM_LIST: REF $ITMLST_DECL (ITEMS=1)	! Prompt string item list
    ): NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This procedure deletes a prompt string, if any.
!
! CALLING SEQUENCE:
!
!	SMG$$DELETE_PROMPT_STRING (item_list.rr.r)
!
! FORMAL PARAMETERS:
!
!	ITEM_LIST	The QIO item-list entry for the prompt string.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	QPS_QUEUE 
!
! COMPLETION STATUS:
!
!	NONE
!
! SIDE EFFECTS:
!
!	Either inserts string on queue of prompt-strings or deallocates
!	the string.
!
!--

    BEGIN

    LOCAL
	ALLOC_LEN;

    BUILTIN
	INSQUE;

    !+
    ! If the string length is LEQ K_QPS_SIZE, insert it on the queue,
    ! as the allocated length is guaranteed to be at least K_QPS_SIZE.
    !-

    ALLOC_LEN = .ITEM_LIST [0,ITM$W_BUFSIZ];
    IF .ALLOC_LEN LEQU K_QPS_SIZE
    THEN
	INSQUE (.ITEM_LIST [0,ITM$L_BUFADR], QPS_QUEUE)
    ELSE
	LIB$FREE_VM (ALLOC_LEN, ITEM_LIST [0,ITM$L_BUFADR]);

    RETURN;

    END;				! End of routine SMG$$DELETE_PROMPT_STRING

%SBTTL 'SMG$$INIT_QUEUES'
ROUTINE SMG$$INIT_QUEUES
    =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This procedure initializes KCB_QUEUE and QPS_QUEUE, and declares
!	an exit handler.
!
! CALLING SEQUENCE:
!
!	ret_status.wlc.v = SMG$$INIT_QUEUES ()
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	V_QUEUE_INIT
!	KQB_QUEUE
!	QPS_QUEUE
!
! IMPLICIT OUTPUTS:
!
!	V_QUEUE_INIT set to 1
!	KQB_QUEUE initialized as an empty queue
!	QPS_QUEUE initialized as an empty queue
!
! COMPLETION STATUS:
!
!	SS$_NORMAL	Normal successful completion
!	Errors from LIB$GET_VM or $DCLEXH
!
! SIDE EFFECTS:
!
!	Declares SMG$$INPUT_EXIT_HANDLER as an exit handler
!
!--

    BEGIN

    LOCAL
	AST_STATUS,
	VM_STATUS,
	V_ENABLE_EXITH,	! Set to 1 if exit handler should be enabled
	EXIT_BLOCK: REF VECTOR [4, LONG],	! Exit handler block
	EB_PTR;		! Pointer to allocated memory

    BUILTIN
	TESTBITCS;

    !+
    ! Assume that we don't have to enable the exit handler.
    !-

    V_ENABLE_EXITH = 0;

    !+
    ! Disable ASTs
    !-

    AST_STATUS = $SETAST (ENBFLG=0);

    !+
    ! If V_QUEUE_INIT still clear, initialize the queue.
    !-

    IF TESTBITCS (V_QUEUE_INIT)
    THEN
	BEGIN

	!+
	! Initialize KQB_QUEUE to be an empty queue.
	!-

	KQB_QUEUE [0] = KQB_QUEUE;	! Set forward link
	KQB_QUEUE [1] = KQB_QUEUE;	! Set backwards link

	!+
	! Initialize QPS_QUEUE to be an empty queue.
	!-

	QPS_QUEUE [0] = QPS_QUEUE;	! Set forward link
	QPS_QUEUE [1] = QPS_QUEUE;	! Set backwards link

	!+
	! Remember that we want to declare the exit handler.
	!-

	V_ENABLE_EXITH = 1;

	END;

    !+
    ! Reenable ASTs if previously enabled.
    !-

    IF .AST_STATUS EQLU SS$_WASSET
    THEN
	$SETAST (ENBFLG=1);

    !+
    ! If we need to enable the exit handler, do it now.  It is not
    ! harmful if other AST-level operations go on while we are doing this.
    !-

    IF .V_ENABLE_EXITH
    THEN
	BEGIN

	VM_STATUS = LIB$GET_VM (%REF(20), EB_PTR);
	IF NOT .VM_STATUS
	THEN
	    RETURN .VM_STATUS;
	EXIT_BLOCK = .EB_PTR;
	EXIT_BLOCK [1] = SMG$$INPUT_EXIT_HANDLER;	! Handler address
	EXIT_BLOCK [2] = 1;	! 1 argument
	EXIT_BLOCK [3] = EXIT_BLOCK [4];	! Address to store reason
	$DCLEXH (DESBLK = EXIT_BLOCK [0]);
	END;

    RETURN SS$_NORMAL;

    END;				! End of routine SMG$$INIT_KQB_QUEUE

%SBTTL 'SMG$$CLEANUP'
ROUTINE SMG$$CLEANUP (
    KCB: REF KCB_R_KCB_STRUCT,		! Keyboard control block
    RET_STATUS				! Return status
    ): SMG$$CLEANUP$LNK =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This procedure performs all the necessary actions to delete
!	a virtual keyboard.
!
! CALLING SEQUENCE:
!
!	ret_status.wlc.v = SMG$$CLEANUP (KCB.mr.r, RET_STATUS.rlc.v)
!
! FORMAL PARAMETERS:
!
!	KCB (R8)	- The address of the Keyboard Control Block being
!			  deleted.
!
!	RET_STATUS (R0) - A status which is to be returned by
!			  SMG$$CLEANUP.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	The value of the RET_STATUS parameter is returned in R0.
!
! SIDE EFFECTS:
!
!	Deletes the virtual keyboard.
!
!--

    BEGIN

    LOCAL	
	KQB: REF KQB_R_KQB_STRUCT;	! Keyboard Queue Block

    BUILTIN
	CALLG;

    !+
    ! Remove this KCB from the list of KCBs.
    !-

    KQB = .KCB [KCB_A_KQB];	! Get Keyboard Queue Block pointer
    IF .KQB NEQA 0
    THEN
	KQB [KQB_A_KCB] = 0;

    !+
    ! Split for RMS vs. $QIO
    !-

    IF .KCB [KCB_V_RMS]
    THEN
	BEGIN
	LOCAL
	    FAB: $FAB_DECL;

	!+
	! Set up new FAB from saved IFI.
	!-

	$FAB_INIT (FAB=FAB);
	FAB [FAB$W_IFI] = KCB [KCB_W_IFI];

	!+
	! Close file if opened.
	!-

	IF .FAB [FAB$W_IFI] NEQ 0
	THEN
	    $CLOSE (FAB=FAB);

	!+
	! Deallocate record buffer if allocated.
	!-

	IF .KCB [RAB$L_UBF] NEQA 0
	THEN
	    LIB$FREE_VM (%REF(.KCB [RAB$W_USZ]), KCB [RAB$L_UBF]);

	END
    ELSE
	BEGIN

	BIND
	    DEVDEPEND2 = KCB [KCB_L_DEVDEPEND2]: BLOCK [4, BYTE];

	!+
	! If we have changed the terminal characteristics and keypad,
	! restore them.
	!-

	IF .KCB [KCB_V_CHARS_CHANGED]
	THEN
	    BEGIN

	    !+
	    ! Restore old DEVDEPEND2 information.
	    !-
    
	    KCB [KCB_L_DEVDEPEND2] = .KCB [KCB_L_OLD_DEVDEPEND2];
    
	    !+
	    ! Reset keypad mode.
	    !-
    
	    SMG$SET_KEYPAD_MODE (%REF(KCB [KCB_R_KCB]),
		%REF(.DEVDEPEND2 [TT2$V_APP_KEYPAD]));
	    END;

	!+
	! Deassign channel if assigned.
	!-
    
	IF .KCB [KCB_W_CHANNEL] NEQ 0
	THEN
	    $DASSGN (CHAN = .KCB [KCB_W_CHANNEL]);
	END;

    !+
    ! Free event flag if allocated.
    !-

    IF .KCB [KCB_L_EFN] NEQ 0
    THEN
	LIB$FREE_EF (KCB [KCB_L_EFN]);

    !+
    ! Deallocate KCB.
    !-

    LIB$FREE_VM (%REF(KCB_S_KCB_STRUCT), %REF (.KCB - KCB_K_ORIGIN_OFFSET));

    RETURN .RET_STATUS;

    END;					! End of routine SMG$$CLEANUP

%SBTTL 'SMG$$INPUT_EXIT_HANDLER'
ROUTINE SMG$$INPUT_EXIT_HANDLER
    : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This procedure is the exit handler for the Screen Management
!	input procedures.  It scans the list of Keyboard Queue Blocks
!	looking for those which refer to existing KCBs.  Those KCBs
!	are then deleted.
!
! CALLING SEQUENCE:
!
!	Called by VMS upon image exit
!
! FORMAL PARAMETERS:
!
!	None used
!
! IMPLICIT INPUTS:
!
!	KQB_QUEUE
!
! IMPLICIT OUTPUTS:
!
!	V_KQB_QUEUE_INIT set to zero
!
! COMPLETION STATUS:
!
!	NONE
!
! SIDE EFFECTS:
!
!	Deletes all existant virtual keyboards.
!
!--

    BEGIN

    LOCAL
	KQB: REF KQB_R_KQB_STRUCT,	! Keyboard Queue Block
	KCB: REF KCB_R_KCB_STRUCT,	! Keyboard Control Block
	QUEUE_HEAD_ADR: REF VECTOR [, LONG];	! Address of queue head

    !+
    ! Get the first KQB from the head of the queue.  Note that the
    ! queue must have already been initialized.
    !-

    QUEUE_HEAD_ADR = KQB_QUEUE [0];
    KQB = .QUEUE_HEAD_ADR [0];

    !+
    ! While we haven't returned to the head of the queue, if this KQB
    ! has an active KCB, delete it.
    !-

    WHILE (.KQB NEQA .QUEUE_HEAD_ADR) DO
	BEGIN
	KCB = .KQB [KQB_A_KCB];
	IF .KCB NEQA 0
	THEN
	    SMG$$CLEANUP (KCB [KCB_R_KCB], 0);
	KQB = .KQB [KQB_A_FLINK];
	END;

    RETURN;

    END;				! End of routine SMG$$INPUT_EXIT_HANDLER

END					! End of module SMG$INPUT

ELUDOM
