Module REBUILD (addressing_mode(external=GENERAL,
				nonexternal=LONG_RELATIVE),
		language(Bliss32),
		ident = 'V04-000') =
begin

!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************

!++
!
! FACILITY:  VMS Mount Utility
!
! ABSTRACT:
!
!	This module implements the rebuilding of the index file bitmap,
!	allocation bitmap and the quota file when a volume is mounted.
!
! ENVIRONMENT:
!
!	VAX/VMS Operating System
!
!--
!
!
! AUTHOR:  Richard I. Hustvedt,	 CREATION DATE:  28-Dec-1979
!	   Andrew C. Goldstein			
!
! MODIFIED BY:
!
!	V03-016	CDS0006		Christian D. Saether	 4-Sep-1984
!		Don't try to use the same FIB that everyone else uses
!		when reading the SCB.
!
!	V03-015	CDS0005		Christian D. Saether	28-Aug-1984
!		Define additional bit in BUILD_FLAGS argument to
!		REBUILD to allow REBUILD to determine whether rebuild
!		is really necessary or not.
!		Always unlock volume set when exiting for any reason.
!
!	V03-014	LMP0305		L. Mark Pilant,		23-Aug-1984  12:42
!		Fix a bug that caused COUNT_QUOTA to ACCVIO if the "UIC" was
!		an identifier (i.e., negative).
!
!	V03-013	JRL0031		John R. Lawson, Jr.	24-Jul-1984 10:46
!		Improve performance of QUOTA rebuild using chained hash table
!
!	V03-012	CDS0004		Christian D. Saether	10-July-1984
!		Add STAND_ALONE_REBUILD routine to jacket the
!		REBUILD routine when not called from MOUNT.
!
!	V03-011	CDS0003		Christian D. Saether	 8-Dec-1983
!		Use MOUDEF.B32 instead of FCPDEF.B32.
!
!	V03-010	CDS0002		Christian D. Saether	18-Oct-1983
!		Stop clearing SCB$W_WRITECNT.  This is done in MOUNT.
!
!	V03-009	STJ3112		Steven T. Jeffreys,	21-Jul-1983
!		Stop-gap fix to UPDATE_ALLOCMAP to prevent ACCVIO
!		when called from USER mode.
!
!	V03-008	STJ3110		Steven T. Jeffreys,	17-Jul-1983
!		Fix bug introduced in STJ3084.
!
!	V03-007	TCM0001		Trudy C.Matthews	10-Jun-1983
!		Add new input parameter (passed in R4) to call to
!		IOC$CVT_DEVNAM.
!
!	V03-006	STJ3084		Steven T. Jeffreys,	31-Mar-1983
!		Erase blocks returned to the storage bitmap.
!
!	V03-005	ACG0325		Andrew C. Goldstein,	4-Apr-1983  14:00
!		Change use of file header area length symbol
!
!	V03-004	CDS0001		Christian D. Saether	12-Jan-1983
!		Clear SCB$W_WRITECNT when allocation flags are cleared.
!
!	V03-003	STJ262		Steven T. Jeffreys,	23-Apr-1982
!		Do cleanup before signaling secondary error condition.
!		Change status of condition from ERROR to WARNING.
!
!	V03-002	STJ0254		Steven T. Jeffreys,	04-Apr-1982
!		Use common I/O routines where possible.  Duplicate
!		the necessary macros from MOUDEF.B32.
!
!	V03-001	ACG0273		Andrew C. Goldstein,	26-Mar-1982  15:59
!		Use random file sequence number in bad file headers
!
!	V02-022	STJ0219		Steven T. Jeffreys,	16-Feb-1982
!		Cancel exit handler before declaring it, to ensure that
!		a duplicate entry is not declared.
!
!	V02-021	BLS0147		Benn Schreiber		12-Feb-1982
!		Reference locals with LONG_RELATIVE
!
!	V02-020	STJ0197		Steven T. Jeffreys,	02-Feb-1982
!		Made all external references use general addressing mode.
!
!	V02-019	ACG0255		Andrew C. Goldstein,	19-Jan-1982  18:28
!		Use dynamic storage for volume descriptor tables
!
!	V02-018	STJ0184		Steven T. Jeffreys,	13-Jan-1982
!		Made all references to the exit handler internal,
!		so that the caller need have no knowledge of it.
!
!	V02-017	STJ0178		Steven T. Jeffreys,	04-Jan-1982
!		Made EXIT_HNDLR_DESC a global symbol.
!
!	V02-016	ACG0234		Andrew C. Goldstein,	4-Dec-1981  17:11
!		Fix EOF handling on index file bitmap
!
!	V02-015	MLJ0060		Martin L. Jack,	10-Nov-1981  21:23
!		Correct V02-014 to include all rewrites of SCB.
!
!	V02-014	MLJ0027		Martin L. Jack,	2-Jul-1981  10:01
!		Checksum storage control block before rewriting it.
!
!	V02-013	STJ0056		Steven T. Jeffreys,	29-Jun-1981
!		Change external references to use general addressing mode.
!
!	V02-012	ACG0198		Andrew C. Goldstein,	5-Mar-1981  23:21
!		Bounds check the LBN in storage map rebuild
!
!	V02-010	ACG0181		Andrew C. Goldstein,	9-Oct-1980  15:47
!		Fix cross facility source reference
!
!	V02-009	ACG0167		Andrew C. Goldstein,	18-Apr-1980  13:39
!		Previous revision history moved to MOUNT.REV
!**


library

   'SYS$LIBRARY:LIB.L32';

require

   'SRC$:MOUDEF.B32';

LINKAGE
   L_ONE_ARG_OUT	= CALL ( ; REGISTER = 1);

forward routine

   REBUILD,			! REBUILD main routine
   CHECK_SCB_STATUS : L_ONE_ARG_OUT NOVALUE, ! Check dirty flags in SCB.
   GET_EOF,			! Get end of file on index file
   ALLOCATE_TABLE: novalue,	! Allocate the usage table
   COUNT_QUOTA: novalue,	! Count blocks in quota list
   DELETE_TABLE: novalue,	! Delete the quota list
   MARK_ALLOC: novalue,		! Mark blocks in use in bitmap
   VERIFY_HEADER,		! Validate file header
   READ_HOMEBLOCK: novalue,	! Read home block on volume
   CHECK_HOMEBLOCK,		! Validate home block
   RBLD_HANDLER,		! Facility condition handler
   RBLD_EXIT_HNDL: novalue,	! Facility exit handler
   FILE_SIZE,			! Compute filesize
   UPDATE_ALLOCMAP,		! Write new BITMAP.SYS
   SET_FREE: novalue;		! Set number of free blocks in VCB

structure

   EXIT_CTRL_BLK [I; N] =			! Exit handler descriptor
      [(4+N)*4]					! N = # of arguments ( N <= 1)
         (EXIT_CTRL_BLK+I*4)<0,32,0>;		! The block is a longword array

!
!	Macro to signal error exit.
!

macro

   RBLD_EXIT[] = signal_stop(%REMAINING) %;

!
!	Macro to signal error message.
!

macro

   RBLD_MESSAGE[] = signal(%REMAINING) %;

!+
!
! Error messages
!
! Macro to generate each error message.
!
!-

macro

   ERR_TEXT(CODE, COUNT, SEVERITY, STRING) =
      literal
         %name('RBLD$_', CODE) = MSG_CODE + FAC_CODE^16;
      switches
         UNAMES;
      psect
         own = $MSG_TEXT;
      own
         MSG_TEXT: vector[%charcount(CODE)+11+%charcount(STRING)+2, byte]
                   initial(byte(COUNT, %charcount(CODE)+11+%charcount(STRING),
				       '%RBLD-', %string(SEVERITY), '-',
				       %string(CODE), ', ', STRING));
      psect
         own = $MSG_INDEX;
      own
         MSG_INDEX: initial(MSG_TEXT);
      undeclare
         MSG_TEXT,
         MSG_INDEX;
      switches
         NOUNAMES;
      %assign(MSG_CODE, MSG_CODE+8)
      psect
         own = $OWN$; %;

!
!	Initialize and label the message sections.
!

psect

   OWN = $MSG_TEXT(nowrite, align(0));

own

   MESSAGE_TEXT: vector[0, byte];

psect

   OWN = $MSG_INDEX(nowrite, align(2));

own

   MESSAGE_TABLE: vector[0];

compiletime

   MSG_CODE = 0;

!
!	Generate the error messages
!

literal

   FAC_CODE = 69;			! Or whatever

   ERR_TEXT(NODEVICE,	0, E, 'no device currently selected');
   ERR_TEXT(ADDERR,	0, E, 'error adding entry');
   ERR_TEXT(MODIFYERR,	0, E, 'error modifying quota file');
   ERR_TEXT(CLOSERR,	0, E, 'error closing quota file');
   ERR_TEXT(LOCKERR,	0, E, 'failed to lock volume');
   ERR_TEXT(UNLOCKERR,	0, E, 'failed to unlock volume');
   ERR_TEXT(MAXVOLS,	0, E, 'volume set has too many volumes to handle');
   ERR_TEXT(DUALLOC,	1, W, 'dual allocation on volume !UW');
   ERR_TEXT(ACCINDEXF,	1, E, 'failed to access index file on relative volume !UW');
   ERR_TEXT(ACCBITMAP,	1, E, 'failed to access bitmap file on relative volume !UW');
   ERR_TEXT(ACCQFILE,	0, E, 'failed to access quota file');
   ERR_TEXT(QUOTARERR,	0, E, 'I/O error reading quota file');
   ERR_TEXT(BITMAPERR,	1, E, 'I/O error reading index file bitmap on relative volume !UW');
   ERR_TEXT(READSCB,	1, E, 'I/O error reading storage control block on relative volume !UW');
   ERR_TEXT(WRITESCB,	1, E, 'I/O error writing storage control block on relative volume !UW');
   ERR_TEXT(WRTIBMAP,	1, E, 'I/O error writing index file bitmap on relative volume !UW');
   ERR_TEXT(WRTBITMAP,	1, E, 'I/O error writing storage bitmap on relative volume !UW');
   ERR_TEXT(HEADERERR,	2, W, 'I/O error reading file header !UL on relative volume !UW');
   ERR_TEXT(WRITEHDR,	2, W, 'I/O error writing file header !UL on relative volume !UW');
   ERR_TEXT(MEMALLOC,	0, E, 'cannot allocate sufficient memory');
   ERR_TEXT(HOMEBLOCK,	1, E, 'failed to read home block on relative volume !UW');
   ERR_TEXT(SYSHEADER,	0, E, 'failed to read system file header - rebuild aborted');
   ERR_TEXT(ERRORS,	0, E, 'too many file header errors - rebuild aborted');
   ERR_TEXT(ERASEBLKS,	1, W, 'blocks reclaimed on relative volume !UW not completely erased');

!
!	Module own storage.
!

literal

   MAX_VOLUMES = 255,			! Largest volume set handled
   COMMAND_LENGTH = 132,
   OUTPUT_LENGTH = 132,
   BLOCK_FACTOR = 64,			! Blocking factor to read index file

!
!	The following are indexes into the Exit Handler Control Block
!

   XHNDLR_ADDRESS = 1,			! Exit handler address
   XHNDLR_ARGCNT = 2,			! Exit handler argument count
   XHNDLR_STSADDR = 3;			! System exit status address

own

   OWN_START: vector[0],		! Start of own storage
   BUFFER: ref BBLOCK,			! I/O buffer to read everything
   IFILEMAP: ref bitvector,		! Pointer to index file bitmap
   IFILEMAP_SIZE,			! Size of index file bitmap
   ALLOCMAP: ref bitvector,		! Pointer to allocation bitmap
   ALLOCMAP_SIZE,			! Size of allocation bitmap in bytes
   ALLOC_CLUSTER,			! Blocks per cluster
   BLOCKS_AVAIL,			! Available blocks on volume
   OLD_ALLOCMAP: ref bitvector,		! One block window into old BITMAP.SYS
   ERASE_CHANNEL: word,			! Channel for erase I/O activity
   CHANNEL: word,			! Channel for disk I/O
   DUALLOC,				! Dual allocation flag
   IO_STATUS: vector[4, word],		! I/O status block
   OUTPUT_LINE: vector[OUTPUT_LENGTH, byte], ! Output line buffer

					! Command line descriptor
   OUTPUT_DESC: vector[2],		! Output line descriptor
   CLEANUP_FLAGS: bitvector[32],
   EXIT_HNDLR_DESC: EXIT_CTRL_BLK[1];	! Exit handler descriptor

literal

!   CLF_UNLOCK = 0,			! Unlock volume set
    CLF_EXIT = 1,			! Exit command entered

    QF_ACTIVE = 0,			! Quota file active
    COND_REBLD = 1,			! Conditional rebuild

    BITMAPS = 0,			! used with the NEED_REBLD flags
    QUOTAS = 1;				! same here


!
!	Quota file record buffers
!

own

   SRC_REC: BBLOCK[DQF$C_LENGTH],

!
!	FIB for quota file operations
!

   QUOTA_FIB: BBLOCK[FIB$C_LENGTH],

   DYN_SIZE,				! Size of dynamic memory for below
   VOLUME_PRESENT: ref bitvector,	! Volume present flags
   CLUSTER_FACTOR: ref vector[, word],	! Cluster factor of volumes
   HEADER_OFFSET: ref vector[, word],	! VBN offset of file headers
   BITMAP_OFFSET: ref vector[, word],	! VBN offset of index file bitmap
   EOF: ref vector,			! End of index file
   OWN_END: vector[0];			! End of own storage to zero

!
! Usage table:
!
!	This table consists of a single chained hash table which is 
!	allocated and initialized by a call to ALLOCATE_TABLE
!

own

   TABLE_SIZE: initial(0),
   ENTRIES_IN_TABLE,
   USAGE_TABLE: ref blockvector[, 4];

macro

   UTB_L_UIC = 0, 0, 32, 0 %,		! Hash key into table
   UTB_L_USAGE = 1, 0, 32, 0 %,		! Block usage for UIC
   UTB_A_NEXT = 2, 0, 32, 0 %,		! Link to next in chain
   UTB_V_PRESCAN = 3, 0, 1, 0 %,	! Flags entry as pre-entered in QUOTA
   UTB_V_INUSE = 3, 1, 1, 0 %;		! Flags entry as in use

!
!	Quota record descriptors
!

own

   SRCREC_DESC: vector[2] initial(DQF$C_LENGTH, SRC_REC),
   QFIB_DESC: vector[2] initial(FIB$C_LENGTH, QUOTA_FIB);

psect

   plit = $OWN$;

bind

   QFILE_NAME = DESCRIPTOR('QUOTA.SYS;1');	! Quota file name

psect

   plit = $PLIT$;

own

   REC_ATTR: BBLOCK[ATR$S_RECATTR],		! Record attributes buffer
   RECATTR_DESC: vector[3]			! Record attributes descriptor
                 initial(word(ATR$S_RECATTR, ATR$C_RECATTR), REC_ATTR, 0);

bind

   QUOTA_EOF = REC_ATTR[FAT$L_EFBLK];


GLOBAL ROUTINE STAND_ALONE_REBUILD (CHANNEL) =

!++
!
! Functional Description:
!
!	This routine is a jacket routine for the main REBUILD routine.
!	It checks to see if quotas are enabled and sets the BUILD_FLAGS
!	argument for the REBUILD routine appropriately.
!	This routine is used to do a rebuild any time after the disk
!	is mounted.
!
! Calling sequence:
!	standard
!
! Inputs:
!	CHANNEL - a channel assigned to the disk to be rebuilt
!
! Outputs, side effects, etc:
!	See REBUILD.
!
!--

BEGIN

LOCAL
	RBLD_FLAGS	: BITVECTOR [2],
	STATUS;

RBLD_FLAGS [QF_ACTIVE] = 0;

! All we want to find out is if the quota checking is enabled or not.
! The slimy test that follows is using the carnal knowledge that
! the check for whether quota checking is turned on will be made
! by the file system before it gets around to noticing that most
! of the required arguments are missing.
!

QUOTA_FIB [FIB$W_CNTRLFUNC] = FIB$C_EXA_QUOTA;

STATUS = DO_IO (CHAN = .CHANNEL,
		FUNC = IO$_ACPCONTROL,
		IOSB = IO_STATUS,
		P1   = QFIB_DESC);

IF .STATUS AND .IO_STATUS [0] NEQ SS$_QFNOTACT
THEN
    RBLD_FLAGS [QF_ACTIVE] = 1;

! This flag tells REBUILD to only do it if the status flags
! in the storage control block indicate it is still necessary.
!

RBLD_FLAGS [COND_REBLD] = 1;

REBUILD (.CHANNEL, .RBLD_FLAGS)

END;

GLOBAL ROUTINE REBUILD (CHANNEL_ARG, BUILD_FLAGS) =

!++
!
! Functional Description:
!
!	This routine implements the REBUILD function on volume mount.  It scans
!	the index file of each volume in the volume set and constructs a table
!	of UIC's and blocks used. It then updates the usage data in the quota
!	file, creating entries as needed so that all UIC's using blocks are
!	listed.  As the index file is scanned, the index file bitmap and
!	allocation bitmaps are also rebuilt and will be rewritten.
!
! Calling Sequence:
!	standard
!
! Input Parameters:
!	CHANNEL_ARG: channel number assigned to the volume (set)
!	BUILD_FLAGS:
!		BIT 0 [QF_ACTIVE] : 1 to rebuild quota file, 0 to not
!		BIT 1 [COND_REBLD] : 0 for unconditional rebuild, test SCB flags otherwise
!
! Implicit Inputs:
!	none
!
! Output Parameters:
!	none
!
! Implicit Outputs:
!	none
!
! Routines Called:
!	none
!
! Routine Value:
!	none
!
! Signals:
!	none
!
! Side Effects:
!	none
!
!--

BEGIN

MAP
	BUILD_FLAGS	: BITVECTOR;

BUILTIN
	ROT;

LOCAL
	STATUS,				! general status value
	READ_STATUS,			! status of file header read I/O
	READ_LENGTH,			! number of blocks to read
	BLOCKS_READ,			! number of blocks actually read
	ERR_COUNT,			! count of errors encountered
	RETRY_COUNT,			! number of blocks to retry in single block mode
	J,				! loop index
	VOLUME_COUNT,			! number of volumes in set
	DEFAULT_QUOTA: initial(1000),	! default quota for new entries
	DEFAULT_OVER: initial(100),	! default overdraft limit for new entries

	BITNUMBER,			! general bit pointer
	VBN,				! current VBN in file
	BUFPTR,				! current buffer pointer for file
	ENTRY		: REF BBLOCK,	! pointer to quota file entry
	HEADER		: REF BBLOCK,	! pointer to file header
	FILE_ID		: BBLOCK [FID$C_LENGTH], ! file ID block
	TIME_BUFFER	: VECTOR [2],	! buffer for time of day
	NEED_REBLD	: BITVECTOR [2], ! Flag to indicate quota file rebuild
	BLOCK_COUNT,			! blocks used by header
	FILE_NUMBER;			! file number of file in question

EXTERNAL ROUTINE
	CHECKSUM,					! compute block checksum
	LIB$FREE_VM	: ADDRESSING_MODE (GENERAL),	! deallocate working storage
	LIB$GET_VM	: ADDRESSING_MODE (GENERAL);	! allocate working storage

ENABLE RBLD_HANDLER;
CH$FILL (0, OWN_END-OWN_START, OWN_START);
!
! Set up the exit handler descriptor and declare the handler.
!

EXIT_HNDLR_DESC[XHNDLR_ADDRESS] = RBLD_EXIT_HNDL;
EXIT_HNDLR_DESC[XHNDLR_ARGCNT]  = 1;
EXIT_HNDLR_DESC[XHNDLR_STSADDR] = EXIT_HNDLR_DESC[XHNDLR_STSADDR+1];

$CANEXH (DESBLK=EXIT_HNDLR_DESC);
$DCLEXH (DESBLK=EXIT_HNDLR_DESC);

! Initialize the actual blocking factor for reads. If the working set
! turns out to be too small, decrease the blocking factor until reads succeed.
!

READ_LENGTH = BLOCK_FACTOR;

!
! Verify that a channel is open.
!

CHANNEL = .CHANNEL_ARG;

IF .CHANNEL EQL 0
THEN RBLD_EXIT (RBLD$_NODEVICE);

! Lock the volume set against modification.
!

QUOTA_FIB[FIB$W_CNTRLFUNC] = FIB$C_LOCK_VOL;
STATUS = DO_IO (CHAN = .CHANNEL,
		FUNC = IO$_ACPCONTROL,
		IOSB = IO_STATUS,
		P1   = QFIB_DESC
		);
IF .STATUS THEN STATUS = .IO_STATUS[0];
IF NOT .STATUS
THEN RBLD_EXIT (RBLD$_LOCKERR, .STATUS);

!CLEANUP_FLAGS[CLF_UNLOCK] = 1;

! Allocate the I/O buffer.
!

STATUS = LIB$GET_VM (UPLIT (BLOCK_FACTOR*512), BUFFER);
IF NOT .STATUS
THEN
    BEGIN
    BUFFER = 0;
    RBLD_EXIT (RBLD$_MEMALLOC, 0, .STATUS);
    END;

! Now open the index file on RVN 1 and read the home block.
!

CH$FILL (0, FIB$C_LENGTH, QUOTA_FIB);
QUOTA_FIB[FIB$L_ACCTL] = FIB$M_NOWRITE;
QUOTA_FIB[FIB$W_FID_NUM] = FID$C_INDEXF;
QUOTA_FIB[FIB$W_FID_SEQ] = FID$C_INDEXF;
QUOTA_FIB[FIB$W_FID_RVN] = 1;

STATUS = DO_IO (CHAN = .CHANNEL,
		FUNC = IO$_ACCESS OR IO$M_ACCESS,
		IOSB = IO_STATUS,
		P1   = QFIB_DESC
		);
IF .STATUS THEN STATUS = .IO_STATUS[0];
IF NOT .STATUS
THEN RBLD_EXIT (RBLD$_ACCINDEXF, 1, .STATUS);

READ_HOMEBLOCK (.BUFFER, 1);

VOLUME_COUNT = .BUFFER[HM2$W_SETCOUNT];
IF .VOLUME_COUNT EQL 0 THEN VOLUME_COUNT = 1;
IF .VOLUME_COUNT GTRU MAX_VOLUMES
THEN RBLD_EXIT (RBLD$_MAXVOLS);

! Allocate the volume descriptors.
!

DYN_SIZE = ((.VOLUME_COUNT+7)/8) * 81;
STATUS = LIB$GET_VM (DYN_SIZE, EOF);
IF NOT .STATUS
THEN
    BEGIN
    EOF = 0;
    RBLD_EXIT (RBLD$_MEMALLOC, 0, .STATUS);
    END;

CH$FILL (0, .DYN_SIZE, .EOF);
CLUSTER_FACTOR = .EOF + .VOLUME_COUNT*4;
HEADER_OFFSET = .CLUSTER_FACTOR + .VOLUME_COUNT*2;
BITMAP_OFFSET = .HEADER_OFFSET + .VOLUME_COUNT*2;
VOLUME_PRESENT = .BITMAP_OFFSET + .VOLUME_COUNT*2;

VOLUME_PRESENT[0] = 1;
CLUSTER_FACTOR[0] = .BUFFER[HM2$W_CLUSTER];
BITMAP_OFFSET[0] = .BUFFER[HM2$W_CLUSTER]*4 + 1;
HEADER_OFFSET[0] = .BUFFER[HM2$W_CLUSTER]*4 + .BUFFER[HM2$W_IBMAPSIZE];
EOF[0] = GET_EOF (.BUFFER, 1);

DO_IO  (CHAN = .CHANNEL,
	FUNC = IO$_DEACCESS
	);

! If this is a conditional rebuild, access the storage bitmap file to
! read the storage control block and determine whether the various flags
! in the status2 field indicate a rebuild is still necessary.  The status2
! flags are set when the volume is mounted if the corresponding flag was
! set in the status flags of the SCB, and the current count of writers
! mismatched with the current number of locks outstanding, indicating
! that the volume had caching enabled and was improperly dismounted.
!
! If not a conditional rebuild, simply set the flags.
!

IF .BUILD_FLAGS [COND_REBLD]
THEN
    CHECK_SCB_STATUS (1, 0 ;NEED_REBLD)
ELSE
    BEGIN
    NEED_REBLD [BITMAPS] = 1;
    NEED_REBLD [QUOTAS] = .BUILD_FLAGS [QF_ACTIVE];
    END;

! If this is a volume set, access the index file of each volume in the set
! and get cluster factor and EOF. We do this beforehand to verify accessibility
! of all volumes in the set.
!

INCR J FROM 2 TO .VOLUME_COUNT
DO
    BEGIN

    QUOTA_FIB[FIB$W_FID_RVN] = .J;
    STATUS = DO_IO (CHAN = .CHANNEL,
		    FUNC = IO$_ACCESS OR IO$M_ACCESS,
		    IOSB = IO_STATUS,
		    P1   = QFIB_DESC
		    );
    IF .STATUS THEN STATUS = .IO_STATUS[0];
    IF NOT .STATUS
    THEN
	BEGIN
	RBLD_MESSAGE (RBLD$_ACCINDEXF, .J, .STATUS);
	NEED_REBLD [QUOTAS] = 0;
	END
    ELSE
	BEGIN
	VOLUME_PRESENT[.J-1] = 1;

	READ_HOMEBLOCK (.BUFFER, .J);

	CLUSTER_FACTOR[.J-1] = .BUFFER[HM2$W_CLUSTER];
	BITMAP_OFFSET[.J-1] = .BUFFER[HM2$W_CLUSTER]*4 + 1;
	HEADER_OFFSET[.J-1] = .BUFFER[HM2$W_CLUSTER]*4 + .BUFFER[HM2$W_IBMAPSIZE];
	EOF[.J-1] = GET_EOF (.BUFFER, .J);

	DO_IO  (CHAN = .CHANNEL,
		FUNC = IO$_DEACCESS
		);

! If conditional rebuild, check whether it is necessary for this volume.
!

	IF .BUILD_FLAGS [COND_REBLD]
	THEN
	    CHECK_SCB_STATUS (.J, .NEED_REBLD ;NEED_REBLD);

	END;
    END;

! If this is a conditional rebuild, see if anything needs rebuilding.
! Don't rebuild quotas unless the quota file is active.
! If the quota file needs rebuilding, the bitmaps get rebuilt regardless.
! If nothing needs rebuilding, clean up and exit.
!

IF .BUILD_FLAGS [COND_REBLD]
THEN
    BEGIN

    IF NOT .BUILD_FLAGS [QF_ACTIVE]
    THEN
	NEED_REBLD [QUOTAS] = 0;

    IF .NEED_REBLD [QUOTAS]
    THEN
	NEED_REBLD [BITMAPS] = 1;

    IF NOT .NEED_REBLD [BITMAPS]
    THEN
	BEGIN

	QUOTA_FIB[FIB$W_CNTRLFUNC] = FIB$C_UNLK_VOL;
	QUOTA_FIB[FIB$L_CNTRLVAL] = 0;
	STATUS = DO_IO (CHAN = .CHANNEL,
		FUNC = IO$_ACPCONTROL,
		IOSB = IO_STATUS,
		P1   = QFIB_DESC
		);

	IF .STATUS THEN STATUS = .IO_STATUS[0];

	IF NOT .STATUS
	THEN RBLD_EXIT (RBLD$_UNLOCKERR, .STATUS);

	LIB$FREE_VM (UPLIT (BLOCK_FACTOR*512), BUFFER);
	BUFFER = 0;
	LIB$FREE_VM (DYN_SIZE, EOF);
	EOF = 0;

	$CANEXH (DESBLK=EXIT_HNDLR_DESC);

	RETURN SS$_NORMAL
	END;

    END;

! Scan the existing quota file to prebuild the usage table. This is essential
! to get table entries for quota file entries that have zero usage.
!

QUOTA_FIB[FIB$L_ACCTL] = 0;
QUOTA_FIB[FIB$W_DID_NUM] = FID$C_MFD;
QUOTA_FIB[FIB$W_DID_SEQ] = FID$C_MFD;
QUOTA_FIB[FIB$W_DID_RVN] = 1;
QUOTA_FIB[FIB$W_CNTRLFUNC] = FIB$C_ENA_QUOTA;
IF .NEED_REBLD [QUOTAS]
THEN
    BEGIN
    STATUS = DO_IO (CHAN = .CHANNEL,
		    FUNC = IO$_ACCESS OR IO$M_ACCESS,
		    IOSB = IO_STATUS,
		    P1   = QFIB_DESC,
		    P2   = QFILE_NAME,
		    P5   = RECATTR_DESC
		    );
    IF .STATUS THEN STATUS = .IO_STATUS[0];
    IF NOT .STATUS
    THEN RBLD_EXIT (RBLD$_ACCQFILE, .STATUS);

    QUOTA_EOF = ROT (.QUOTA_EOF, 16) - 1;

    ALLOCATE_TABLE();

    VBN = 1;
    UNTIL .VBN GTRU .QUOTA_EOF
    DO
	BEGIN
	STATUS = DO_IO (CHAN = .CHANNEL,
			FUNC = IO$_READVBLK,
			IOSB = IO_STATUS,
			P1   = .BUFFER,
			P2   = 512 * MINU (.READ_LENGTH, .QUOTA_EOF - .VBN + 1),
			P3   = .VBN
			);
	IF .STATUS THEN STATUS = .IO_STATUS[0];
	IF NOT .STATUS
	THEN
	    BEGIN
	    IF .STATUS EQL SS$_INSFWSL
	    THEN
		BEGIN
		READ_LENGTH = .READ_LENGTH - 1;
		IF .READ_LENGTH EQL 0
		THEN RBLD_EXIT (RBLD$_QUOTARERR, .STATUS);
		IO_STATUS[1] = 0;
		END
	    ELSE
		RBLD_EXIT (RBLD$_QUOTARERR, .STATUS);
	    END;

	ENTRY = .BUFFER;
	UNTIL .ENTRY GEQA .BUFFER + .IO_STATUS[1]
	DO
	    BEGIN

	    IF .ENTRY[DQF$V_ACTIVE]
	    THEN
		BEGIN
		IF .ENTRY[DQF$L_UIC] EQL 0
		THEN
		    BEGIN
		    DEFAULT_QUOTA = .ENTRY[DQF$L_PERMQUOTA];
		    DEFAULT_OVER = .ENTRY[DQF$L_OVERDRAFT];
		    END
		ELSE
		    BEGIN
		    COUNT_QUOTA (.ENTRY[DQF$L_UIC], 0, 1);
		    END;
		END;
	    ENTRY = .ENTRY + DQF$C_LENGTH;
	    END;				! end of buffer processing loop
	VBN = .VBN + .IO_STATUS[1] / 512;
	END;				! end of quota file reading loop

    DO_IO  (CHAN = .CHANNEL,
	    FUNC = IO$_DEACCESS
	    );

    END;

! Now we loop for all the volumes in the set. Open the index file and start
! reading file headers.
!

CH$FILL (0, FIB$C_LENGTH, QUOTA_FIB);

INCR J FROM 1 TO .VOLUME_COUNT
DO IF .VOLUME_PRESENT[.J-1]
THEN
    BEGIN
    DUALLOC = 0;
    ERR_COUNT = 0;
    QUOTA_FIB[FIB$L_ACCTL] = FIB$M_NOWRITE;
    QUOTA_FIB[FIB$W_FID_RVN] = .J;
    QUOTA_FIB[FIB$W_FID_NUM] = FID$C_BITMAP;
    QUOTA_FIB[FIB$W_FID_SEQ] = FID$C_BITMAP;	
    STATUS = DO_IO (CHAN = .CHANNEL,
		    FUNC = IO$_ACCESS OR IO$M_ACCESS,
		    IOSB = IO_STATUS,
		    P1   = QFIB_DESC
		    );
    IF .STATUS THEN STATUS = .IO_STATUS[0];
    IF NOT .STATUS
    THEN RBLD_EXIT (RBLD$_ACCBITMAP, .J, .STATUS);

    STATUS = DO_IO (CHAN = .CHANNEL,
		    FUNC = IO$_READVBLK,
		    IOSB = IO_STATUS,
		    P1	 = .BUFFER,
		    P2	 = 512,
		    P3   = 1
		    );
    IF .STATUS THEN STATUS = .IO_STATUS[0];
    IF NOT .STATUS
    THEN
	BEGIN
!	CLEANUP_FLAGS[CLF_UNLOCK] = 0;
	RBLD_EXIT (RBLD$_READSCB, .J, .STATUS);
	END;

    ALLOC_CLUSTER = .CLUSTER_FACTOR[.J-1];
    ALLOCMAP_SIZE = 4095 + ((.BUFFER[SCB$L_VOLSIZE] + .BUFFER[SCB$W_CLUSTER] - 1)
			/ .BUFFER[SCB$W_CLUSTER]);
    ALLOCMAP_SIZE = 512 * (.ALLOCMAP_SIZE / 4096);  ! convert to page byte count   
    STATUS = LIB$GET_VM (ALLOCMAP_SIZE, ALLOCMAP);
    IF NOT .STATUS
    THEN
	BEGIN
	ALLOCMAP = 0;
	RBLD_EXIT (RBLD$_MEMALLOC, .STATUS);
	END;
!
!   Initialize allocation bitmap to show all space available
!
    CH$FILL (0, .ALLOCMAP_SIZE, .ALLOCMAP);
    BLOCKS_AVAIL = ((.BUFFER[SCB$L_VOLSIZE] + .BUFFER[SCB$W_CLUSTER] -1)
		   / .BUFFER[SCB$W_CLUSTER])
		   * .BUFFER[SCB$W_CLUSTER];
    INCR BITNUMBER FROM 0
		   TO ((.BUFFER[SCB$L_VOLSIZE] + .BUFFER[SCB$W_CLUSTER] - 1)
				/ .BUFFER[SCB$W_CLUSTER]) - 1
    DO
	BEGIN
	ALLOCMAP[.BITNUMBER] = 1;
	END;

    STATUS = DO_IO (CHAN = .CHANNEL,
		    FUNC = IO$_DEACCESS
		    );

    QUOTA_FIB[FIB$L_ACCTL] = FIB$M_NOWRITE OR FIB$M_WRITE;
    QUOTA_FIB[FIB$W_FID_NUM] = FID$C_INDEXF;
    QUOTA_FIB[FIB$W_FID_SEQ] = FID$C_INDEXF;

    STATUS = DO_IO (CHAN = .CHANNEL,
		    FUNC = IO$_ACCESS OR IO$M_ACCESS,
		    IOSB = IO_STATUS,
		    P1   = QFIB_DESC
		    );
    IF .STATUS THEN STATUS = .IO_STATUS[0];
    IF NOT .STATUS
    THEN RBLD_EXIT (RBLD$_ACCINDEXF, .J, .STATUS);
!
!   Allocate space for working copy of index file bit map
!
    IFILEMAP_SIZE = (.HEADER_OFFSET[.J-1] - .BITMAP_OFFSET[.J-1] + 1) * 512;
    STATUS = LIB$GET_VM (IFILEMAP_SIZE, IFILEMAP);
    IF NOT .STATUS
    THEN
	BEGIN
	IFILEMAP = 0;
	RBLD_EXIT (RBLD$_MEMALLOC, .STATUS);
	END;
!
! Read old index file bitmap into buffer.
!
    STATUS = DO_IO (CHAN = .CHANNEL,
		    FUNC = IO$_READVBLK,
	    	    IOSB = IO_STATUS,
		    P1 = .IFILEMAP,
		    P2 = .IFILEMAP_SIZE,
		    P3 = .BITMAP_OFFSET[.J-1]
		    );
    IF .STATUS THEN STATUS = .IO_STATUS[0];
    IF NOT .STATUS THEN RBLD_EXIT (RBLD$_BITMAPERR, .J, .STATUS);


! Loop for all blocks in the index file. Read headers, starting with the MFD.
! We read multiple blocks into a data buffer and process them one at a
! time.
!

    VBN = .HEADER_OFFSET[.J-1] + 1;
    UNTIL .VBN GTRU .EOF[.J-1]
    DO
	BEGIN

	READ_STATUS = DO_IO (CHAN = .CHANNEL,
			FUNC = IO$_READVBLK,
			IOSB = IO_STATUS,
			P1   = .BUFFER,
			P2   = 512 * MINU (.READ_LENGTH, .EOF[.J-1] - .VBN + 1),
			P3   = .VBN
			);
	IF .READ_STATUS THEN READ_STATUS = .IO_STATUS[0] ELSE IO_STATUS = 0;

! If an I/O error occurred, go into single block mode for the scope of the
! read. We must do this since the byte count returned with an I/O error is
! not reliable. If we are already in single block mode, then see if the header
! read was marked active; only report the error if it was.
!

	IF NOT .READ_STATUS
	THEN
	    BEGIN
	    IO_STATUS = 0;
	    IF .READ_STATUS EQL SS$_INSFWSL
	    THEN
		BEGIN
		READ_LENGTH = .READ_LENGTH - 1;
		IF .READ_LENGTH EQL 0
		THEN RBLD_EXIT (RBLD$_HEADERERR, .FILE_NUMBER, .J, .READ_STATUS);
		END

	    ELSE
		BEGIN
		IF .READ_LENGTH GTRU 1
		THEN
		    BEGIN
		    RETRY_COUNT = .READ_LENGTH;
		    READ_LENGTH = 1;
		    END

		ELSE
		    BEGIN
		    FILE_NUMBER = .VBN - .HEADER_OFFSET[.J-1];
		    IF .IFILEMAP[.FILE_NUMBER-1]
		    THEN RBLD_MESSAGE (RBLD$_HEADERERR, .FILE_NUMBER, .J, .READ_STATUS);
		    IFILEMAP[.FILE_NUMBER-1] = 0;
		    VBN = .VBN + 1;

		    IF .FILE_NUMBER LEQU FID$C_MFD
		    THEN RBLD_EXIT (RBLD$_SYSHEADER);
		    ERR_COUNT = .ERR_COUNT + 1;
		    IF .ERR_COUNT GTRU 10
		    THEN RBLD_EXIT (RBLD$_ERRORS);
		    END;
		END;
	    END;

! For each header block that we read, verify that it is a valid file header.
! If it is, compute the number of blocks it maps and charge them to the
! owner UIC. If the header is not valid, check if it is marked busy in
! the index file bitmap. If so, bump the sequence number and write it; then
! mark it free. If the write fails, leave it busy.
!

	BLOCKS_READ = .IO_STATUS[1] / 512;
	HEADER = .BUFFER;
	UNTIL .HEADER GEQA .BUFFER + .BLOCKS_READ * 512
	DO
	    BEGIN

	    FILE_NUMBER = .VBN + (.HEADER - .BUFFER) / 512 - .HEADER_OFFSET[.J-1];
	    FILE_ID[FID$W_NUM] = .FILE_NUMBER<0,16>;
	    FILE_ID[FID$B_NMX] = .FILE_NUMBER<16,8>;
	    FILE_ID[FID$W_SEQ] = .HEADER[FH2$W_FID_SEQ];
	    STATUS = VERIFY_HEADER (.HEADER, FILE_ID);
	    IF .STATUS
	    THEN
		BEGIN
		IFILEMAP[.FILE_NUMBER-1] = 1;
		BLOCK_COUNT = FILE_SIZE (.HEADER) + 1;
		IF .NEED_REBLD [QUOTAS]
		AND .FILE_NUMBER GEQ FID$C_MFD
		THEN COUNT_QUOTA (.HEADER[FH2$L_FILEOWNER], .BLOCK_COUNT, 0);
		END

	    ELSE
		BEGIN
		IF .IFILEMAP[.FILE_NUMBER-1]
		THEN
		    BEGIN
		    IF .STATUS NEQ 2
		    THEN
			BEGIN
			CH$FILL (0, 512, .HEADER);
			$GETTIM (TIMADR = TIME_BUFFER);
			HEADER[FH2$W_FID_SEQ] = .TIME_BUFFER<16,16>;
			HEADER[FH2$B_STRUCVER] = 1;
			HEADER[FH2$B_STRUCLEV] = 2;
			END;
		    HEADER[FH2$B_IDOFFSET] = FH2$C_LENGTH / 2;
		    HEADER[FH2$B_MPOFFSET] = (FH2$C_LENGTH + FI2$C_LENGTH) / 2;
		    HEADER[FH2$B_ACOFFSET] = $BYTEOFFSET (FH2$W_CHECKSUM) / 2;
		    HEADER[FH2$B_RSOFFSET] = $BYTEOFFSET (FH2$W_CHECKSUM) / 2;
		    HEADER[FH2$W_FID_SEQ] = .HEADER[FH2$W_FID_SEQ] + 1;
		    HEADER[FH2$W_FID_NUM] = 0;
		    HEADER[FH2$W_FID_RVN] = 0;
		    HEADER[FH2$W_CHECKSUM] = 0;
		    STATUS = DO_IO (CHAN = .CHANNEL,
				    FUNC = IO$_WRITEVBLK,
				    IOSB = IO_STATUS,
				    P1   = .HEADER,
				    P2   = 512,
				    P3   = .FILE_NUMBER + .HEADER_OFFSET[.J-1]
				    );
		    IF .STATUS THEN STATUS = .IO_STATUS[0];
		    IF NOT .STATUS
		    THEN RBLD_MESSAGE (RBLD$_WRITEHDR, .FILE_NUMBER, .J, .STATUS)
		    ELSE IFILEMAP[.FILE_NUMBER-1] = 0;
		    END;
		END;

	    HEADER = .HEADER + 512;
	    END;

	VBN = .VBN + .BLOCKS_READ;

	IF .READ_LENGTH EQL 1		! handle single block mode
	THEN
	    BEGIN
	    RETRY_COUNT = .RETRY_COUNT - 1;
	    IF .RETRY_COUNT EQL 0
	    THEN READ_LENGTH = BLOCK_FACTOR;
	    END;

	END;				! end of processing one volume
!
! Clear unreferenced bits past the index file EOF. Then
! write back new index file bitmap after pass through index file.
!
    INCR I FROM .FILE_NUMBER+1 TO .IFILEMAP_SIZE*8
    DO
	IFILEMAP[.I-1] = 0;

    STATUS = DO_IO (CHAN = .CHANNEL,
		    FUNC = IO$_WRITEVBLK,
	    	    IOSB = IO_STATUS,
		    P1 = .IFILEMAP,
		    P2 = .IFILEMAP_SIZE,
		    P3 = .BITMAP_OFFSET[.J-1]
		    );
    IF .STATUS THEN STATUS = .IO_STATUS[0];
    IF NOT .STATUS
    THEN
	BEGIN
!	CLEANUP_FLAGS[CLF_UNLOCK] = 0;
	RBLD_EXIT (RBLD$_WRTIBMAP, .J, .STATUS);
	END;

!
! Release memory for working copy of indexfile bitmap.
!
    STATUS = LIB$FREE_VM (IFILEMAP_SIZE, IFILEMAP);
    IFILEMAP = 0;
    STATUS = DO_IO (CHAN = .CHANNEL,
		    FUNC = IO$_DEACCESS
		    );

!
! Write out the new storage bitmap then release bitmap buffer.
!
    UPDATE_ALLOCMAP (.J, 1);			! 1 specifies "erase the data"
    STATUS = LIB$FREE_VM (ALLOCMAP_SIZE, ALLOCMAP);	! release working memory
    ALLOCMAP = 0;

!
! Clear the cleanup flag bits in the storage control block.
!
    STATUS = DO_IO (CHAN = .CHANNEL,
		    FUNC = IO$_READVBLK,
		    IOSB = IO_STATUS,
		    P1	 = .BUFFER,
		    P2	 = 512,
		    P3   = 1
		    );
    IF .STATUS THEN STATUS = .IO_STATUS[0];
    IF NOT .STATUS
    THEN
	BEGIN
!	CLEANUP_FLAGS[CLF_UNLOCK] = 0;
	RBLD_EXIT (RBLD$_READSCB, .J, .STATUS);
	END;

    BUFFER[SCB$V_MAPDIRTY2] = 0;
    BUFFER[SCB$V_MAPALLOC2] = 0;
    BUFFER[SCB$V_FILALLOC2] = 0;
    CHECKSUM (.BUFFER);

    STATUS = DO_IO (CHAN = .CHANNEL,
		    FUNC = IO$_WRITEVBLK,
		    IOSB = IO_STATUS,
		    P1	 = .BUFFER,
		    P2	 = 512,
		    P3   = 1
		    );
    IF .STATUS THEN STATUS = .IO_STATUS[0];
    IF NOT .STATUS
    THEN
	BEGIN
!	CLEANUP_FLAGS[CLF_UNLOCK] = 0;
	RBLD_EXIT (RBLD$_WRITESCB, .J, .STATUS);
	END;

    DO_IO  (CHAN = .CHANNEL,
	    FUNC = IO$_DEACCESS
	    );


    IF .DUALLOC THEN RBLD_MESSAGE (RBLD$_DUALLOC, .J , 0);
!
!  Update volume size in VCB now.
!
    STATUS = KERNEL_CALL (SET_FREE, .J);

    END;				! end of processing all volumes

! We have now scanned the entire volume set and have a table of the total
! disk usage. Take each table entry and use it to update the corresponding
! quota file entry. This is done in two passes. The first updates all
! existing entries (these come first because of the quota file prescan).
! The second pass creates new quota file entries for UIC's that have space
! in use but have no quota file entries.
!

CH$FILL (0, FIB$C_LENGTH, QUOTA_FIB);
QUOTA_FIB[FIB$W_CNTRLFUNC] = FIB$C_MOD_QUOTA;
QUOTA_FIB[FIB$L_CNTRLVAL] = FIB$M_MOD_USE;

!
!	Update existing UIC entries in QUOTA.SYS
!

if .NEED_REBLD [QUOTAS]
    THEN
    BEGIN

      local

         P: ref block[4],
         Q;

!
!	Scan entire usage table
!

      Q = .USAGE_TABLE;

      until .Q geqa .USAGE_TABLE+.TABLE_SIZE do
         begin

            P = .Q;

            while .P neq 0 do
               begin

                  if .P[UTB_V_PRESCAN] then
                     begin

                        SRC_REC[DQF$L_UIC] = .P[UTB_L_UIC];
                        SRC_REC[DQF$L_USAGE] = .P[UTB_L_USAGE];

                        STATUS = DO_IO(chan = .CHANNEL,
                                       func = IO$_ACPCONTROL,
                                       iosb = IO_STATUS,
                                       p1 = QFIB_DESC,
                                       p2 = SRCREC_DESC);

                        if .STATUS then
                           STATUS = .IO_STATUS[0];
                        if not .STATUS then
                           RBLD_EXIT(RBLD$_MODIFYERR, .STATUS);

                     end;

                  P = .P[UTB_A_NEXT];

               end;

            Q = .Q + 16;

         end;

   end;

!
! Now we create new quota records for UIC's that are not on the quota file.
! Since the quota file may have to be extended, we must unlock the volume
! at this time. This causes a small timing window in which the UIC's to
! be added could be out of phase, if they resume file activity immediately.
! If you can't tolerate this, just do the rebuild twice.
!

QUOTA_FIB[FIB$W_CNTRLFUNC] = FIB$C_UNLK_VOL;
QUOTA_FIB[FIB$L_CNTRLVAL] = 0;
STATUS = DO_IO (CHAN = .CHANNEL,
		FUNC = IO$_ACPCONTROL,
		IOSB = IO_STATUS,
		P1   = QFIB_DESC
		);
IF .STATUS THEN STATUS = .IO_STATUS[0];
IF NOT .STATUS
THEN RBLD_EXIT (RBLD$_UNLOCKERR, .STATUS);

!CLEANUP_FLAGS[CLF_UNLOCK] = 0;

QUOTA_FIB[FIB$W_CNTRLFUNC] = FIB$C_ADD_QUOTA;

!
!	Enter the new UIC's
!

if .NEED_REBLD [QUOTAS]
THEN
    BEGIN
      local

         P: ref block[4],
         Q;

!
!	Scan entire usage table
!

      Q = .USAGE_TABLE;

      until .Q geqa .USAGE_TABLE+.TABLE_SIZE do
         begin

            P = .Q;

            while .P neq 0 do
               begin

                  if .P[UTB_V_INUSE] and not .P[UTB_V_PRESCAN] then
                     begin

                        SRC_REC[DQF$L_UIC] = .P[UTB_L_UIC];
                        SRC_REC[DQF$L_USAGE] = .P[UTB_L_USAGE];
                        SRC_REC[DQF$L_PERMQUOTA] = .DEFAULT_QUOTA;
                        SRC_REC[DQF$L_OVERDRAFT] = .DEFAULT_OVER;

                        STATUS = DO_IO(chan = .CHANNEL,
                                       func = IO$_ACPCONTROL,
                                       iosb = IO_STATUS,
                                       p1 = QFIB_DESC,
                                       p2 = SRCREC_DESC);

                        if .STATUS then
                           STATUS = .IO_STATUS[0];
                        if not .STATUS then
                           RBLD_EXIT(RBLD$_MODIFYERR, .STATUS);

                     end;

                  P = .P[UTB_A_NEXT];

               end;

            Q = .Q + 16;

         end;

!
!	Release the quota table storage.
!

      DELETE_TABLE();

!
!	Clear the cleanup flag bits in the storage control block.
!	We must open the bitmap file on volume 1, read and write the SCB, and
!	close the file.
!

      QUOTA_FIB[FIB$L_ACCTL] = FIB$M_WRITE or FIB$M_NOWRITE;
      QUOTA_FIB[FIB$W_FID_RVN] = 1;
      QUOTA_FIB[FIB$W_FID_NUM] = FID$C_BITMAP;
      QUOTA_FIB[FIB$W_FID_SEQ] = FID$C_BITMAP;	

      STATUS = DO_IO(chan = .CHANNEL,
                     func = IO$_ACCESS or IO$M_ACCESS,
                     iosb = IO_STATUS,
                     p1 = QFIB_DESC);

      if .STATUS then
         STATUS = .IO_STATUS[0];
      if not .STATUS then
         RBLD_EXIT(RBLD$_ACCBITMAP, 1, .STATUS);
   
      STATUS = DO_IO(chan = .CHANNEL,
                     func = IO$_READVBLK,
                     iosb = IO_STATUS,
                     p1 = .BUFFER,
                     p2 = 512,
                     p3 = 1);

      if .STATUS then
         STATUS = .IO_STATUS[0];
      if not .STATUS
	THEN
            RBLD_EXIT(RBLD$_READSCB, 1, .STATUS);

      BUFFER[SCB$V_QUODIRTY2] = 0;
      CHECKSUM(.BUFFER);

      STATUS = DO_IO(chan = .CHANNEL,
                     func = IO$_WRITEVBLK,
                     iosb = IO_STATUS,
                     p1 = .BUFFER,
                     p2 = 512,
                     p3 = 1);

      if .STATUS then
         STATUS = .IO_STATUS[0];
      if not .STATUS
	THEN
            RBLD_EXIT(RBLD$_WRITESCB, 1, .STATUS);

      STATUS = DO_IO(chan = .CHANNEL,
                     func = IO$_DEACCESS);

   end;

!
! Free remaining storage and cancel the exit handler.
!

LIB$FREE_VM (UPLIT (BLOCK_FACTOR*512), BUFFER);
BUFFER = 0;
LIB$FREE_VM (DYN_SIZE, EOF);
EOF = 0;

$CANEXH (DESBLK=EXIT_HNDLR_DESC);

1
END;					! end of routine REBUILD

ROUTINE CHECK_SCB_STATUS (RVN, FLAGS_IN ;FLAGS) : NOVALUE L_ONE_ARG_OUT =

!++
!
! Functional Description:
!
!	This routine opens the storage bitmap, reads the storage
!	control block, and then OR's appropriate rebuild flags.
!
! Makes use of/alters:
!
!	QUOTA_FIB
!	CHANNEL
!	BUFFER
!	IO_STATUS
!
!--

BEGIN

MAP
	FLAGS		: BITVECTOR [2];

LOCAL
	SBM_FIB		: BBLOCK [FIB$C_LENGTH],
	SBM_FIB_D	: VECTOR [2] INITIAL (FIB$C_LENGTH, SBM_FIB),
	STATUS;

FLAGS = .FLAGS_IN<0,2,0>;

CH$FILL (0, FIB$C_LENGTH, SBM_FIB);

SBM_FIB[FIB$L_ACCTL] = FIB$M_NOWRITE;
SBM_FIB[FIB$W_FID_RVN] = .RVN;
SBM_FIB[FIB$W_FID_NUM] = FID$C_BITMAP;
SBM_FIB[FIB$W_FID_SEQ] = FID$C_BITMAP;	
STATUS = DO_IO (CHAN = .CHANNEL,
		FUNC = IO$_ACCESS OR IO$M_ACCESS,
		IOSB = IO_STATUS,
		P1   = SBM_FIB_D
		);

IF .STATUS THEN STATUS = .IO_STATUS[0];

IF NOT .STATUS
THEN RBLD_EXIT (RBLD$_ACCBITMAP, .RVN, .STATUS);

STATUS = DO_IO (CHAN = .CHANNEL,
		FUNC = IO$_READVBLK,
		IOSB = IO_STATUS,
		P1   = .BUFFER,
		P2   = 512,
		P3   = 1
		);

IF .STATUS THEN STATUS = .IO_STATUS[0];

IF NOT .STATUS
THEN
    RBLD_EXIT (RBLD$_READSCB, .RVN, .STATUS);

! If either extent or file number caching was in effect, the
! bitmaps need rebuilding.
!

IF .BUFFER [SCB$V_MAPALLOC2]
    OR .BUFFER [SCB$V_FILALLOC2]
THEN
    FLAGS [BITMAPS] = 1;

! The QUODIRTY flag is only relevant for volume 1.
!

IF .BUFFER [SCB$V_QUODIRTY2]
    AND .RVN EQL 1
THEN
    FLAGS [QUOTAS] = 1;

DO_IO  (CHAN = .CHANNEL,
	    FUNC = IO$_DEACCESS);

END;			! of routine CHECK_SCB_STATUS


ROUTINE GET_EOF (BUFFER, RVN) =

!++
!
! Functional Description:
!
!	This routine finds out the actual EOF of the currently open index
!	file by (1) reading the index file record attributes and (2) looking
!	for the highest active file header as per the index file bitmap
!	and taking the maximum. This is minimized against the actual file
!	size.
!
! Calling Sequence:
!	standard
!
! Input Parameters:
!	none
!
! Implicit Inputs:
!	none
!
! Output Parameters:
!	none
!
! Implicit Outputs:
!	none
!
! Routines Called:
!	none
!
! Routine Value:
!	none
!
! Signals:
!	none
!
! Side Effects:
!	none
!
!--

BEGIN

BUILTIN
	ROT;

MAP
	BUFFER		: REF BBLOCK;	! block buffer arg

LOCAL
	STATUS,				! general status value
	BITMAP_SIZE,			! number of blocks in index file bitmap
	HIBLK,				! saved copy of index file HIBLK
	EOF;				! computed index EOF

EXTERNAL ROUTINE
	LEFT_ONE;			! find leftmost one bit in a word


! Read the index file header and the the EOF stored therein.
!

BITMAP_SIZE = .BUFFER[HM2$W_IBMAPSIZE];
STATUS = DO_IO (CHAN = .CHANNEL,
		FUNC = IO$_READVBLK,
		IOSB = IO_STATUS,
		P1   = .BUFFER,
		P2   = 512,
		P3   = .HEADER_OFFSET[.RVN-1] + 1
		);
IF .STATUS THEN STATUS = .IO_STATUS[0];
IF NOT .STATUS
THEN RBLD_EXIT (RBLD$_BITMAPERR, .RVN, .STATUS);

EOF = ROT (.BBLOCK [BUFFER[FH2$W_RECATTR], FAT$L_EFBLK], 16) - 1;
HIBLK = ROT (.BBLOCK [BUFFER[FH2$W_RECATTR], FAT$L_HIBLK], 16);

! Now scan the volume's index file bitmap backwards, looking for the highest
! bit set.
!

DECR J FROM .BITMAP_SIZE -1 TO 0
DO
    BEGIN
    MAP BUFFER : REF VECTOR;
    STATUS = DO_IO (CHAN = .CHANNEL,
		    FUNC = IO$_READVBLK,
		    IOSB = IO_STATUS,
		    P1   = .BUFFER,
		    P2   = 512,
		    P3   = .BITMAP_OFFSET[.RVN-1] + .J
		    );
    IF .STATUS THEN STATUS = .IO_STATUS[0];
    IF NOT .STATUS
    THEN RBLD_EXIT (RBLD$_BITMAPERR, .RVN, .STATUS);

    DECR I FROM 127 TO 0
    DO
	BEGIN
	IF .BUFFER[.I] NEQ 0
	THEN
	    BEGIN
	    EOF = MAXU (.J*4096 + .I*32 + LEFT_ONE (.BUFFER[.I])
			+ .HEADER_OFFSET[.RVN-1],
			.EOF);
	    RETURN MINU (.EOF, .HIBLK);
	    END;
	END;
    END;

0
END;					! end of routine GET_EOF


routine ALLOCATE_TABLE: novalue =
begin

!++
!
! Functional Description:
!
!	Initially allocate the usage table
!
! Calling Sequence:
!
!	Normal
!
! Input Parameters:
!
!	None
!
! Implicit Inputs:
!
!	None
!
! Output Parameters:
!
!	None
!
! Implicit Outputs:
!
!	TABLE_SIZE		The size, in bytes, of the usage table
!	ENTRIES_IN_TABLE	The number of buckets in that table
!	USAGE_TABLE		Hash table into which entries are made
!
!--

   external routine

      LIB$GET_VM: addressing_mode(general);	! allocate virtual memory

   local

      STATUS;

!
!	Compute the size of the hash table
!

   TABLE_SIZE = max(16*((512/DQF$C_LENGTH)*.QUOTA_EOF - 1), 16*511);
   ENTRIES_IN_TABLE = .TABLE_SIZE/16;

!
!	Allocate the table
!

   STATUS = LIB$GET_VM(TABLE_SIZE, USAGE_TABLE);

   if not .STATUS then
      begin
         USAGE_TABLE = 0;
         RBLD_EXIT(RBLD$_MEMALLOC, .STATUS);
      end;

   ch$fill(0, .TABLE_SIZE, .USAGE_TABLE);

end;



routine COUNT_QUOTA(UIC, USAGE, PRESCAN): novalue =
begin

!++
!
! Functional Description:
!
!	Add an entry to the usage table.  The usage table is a hash table
!	whose key is the UIC which is to be stored there.  Overflow is handled
!	by chaining each bucket.
!
! Calling Sequence:
!
!	COUNT_QUOTA(.UIC, .USAGE, .PRESCAN);
!
! Input Parameters:
!
!	UIC		The UIC of the file in question
!	USAGE		The number of blocks used by that file
!	PRESCAN		1, if this entry exists in the old QUOTA.SYS
!
! Implicit Inputs:
!
!	USAGE_TABLE	The hash table itself
!
! Output Parameters:
!
!	None
!
! Implicit Outputs:
!
!	USAGE_TABLE	The hash table itself
!
!--

   external routine

      LIB$GET_VM: addressing_mode(general);

   local

      Q: ref block[4];

!
!	The hash function
!

   macro

      h(UIC) = UIC mod .ENTRIES_IN_TABLE %;

!
!	Hash on the UIC into the usage table
!

   Q = USAGE_TABLE[ h(.UIC<0,$bitposition(UIC$V_FORMAT)>), 0,0,32,0 ];

!
!	Search the chain for the entry which matches our UIC
!

   while SS$_NORMAL do
      begin

!
!	Compare the UIC field of each chain member against our UIC
!

         if not .Q[UTB_V_INUSE] then
            begin

               Q[UTB_L_UIC] = .UIC;
               Q[UTB_L_USAGE] = .USAGE;
               Q[UTB_V_PRESCAN] = .PRESCAN;
               Q[UTB_V_INUSE] = 1;
               exitloop;

            end
         else if .Q[UTB_L_UIC] eql .UIC then
            begin

               Q[UTB_L_USAGE] = .Q[UTB_L_USAGE] + .USAGE;
               Q[UTB_V_PRESCAN] = .Q[UTB_V_PRESCAN] or .PRESCAN;
               exitloop;

            end
         else if .Q[UTB_A_NEXT] eql 0 then
            begin

               LIB$GET_VM(uplit(16), Q[UTB_A_NEXT]);
               ch$fill(0, 16, .Q[UTB_A_NEXT]);

            end;

!
!	Try the next entry in the chain
!

         Q = .Q[UTB_A_NEXT];

      end;

end;					! end of routine COUNT_QUOTA



routine DELETE_TABLE: novalue =
begin

!++
!
! Functional Description:
!
!	This routine deletes the usage table and returns the space to
!	the free storage pool.
!
! Calling Sequence:
!
!	Standard
!
! Input Parameters:
!
!	None
!
! Implicit Inputs:
!
!	USAGE_TABLE	The table to be disposed of
!
! Output Parameters:
!
!	None
!
! Implicit Outputs:
!
!	None
!
! Routine Value:
!
!	None
!
!--

   external routine

      LIB$FREE_VM: addressing_mode(general);

   local

      P: ref block[4],
      Q,
      R;

!
!	Check all the link pointers in the table
!

   Q = USAGE_TABLE[0, UTB_A_NEXT];

!
!	Deallocate all the chained entries first
!

   until .Q geqa .USAGE_TABLE+.TABLE_SIZE do
      begin

         P = ..Q;

         until .P eql 0 do
            begin

               R = .P;
               P = .P[UTB_A_NEXT];

               LIB$FREE_VM(uplit(16), R);

            end;

         Q = .Q + 16;

      end;

!
!	Deallocate the table itself
!

   LIB$FREE_VM(TABLE_SIZE, USAGE_TABLE);

end;					! end of routine DELETE_TABLE


ROUTINE MARK_ALLOC (COUNT, LBN) : NOVALUE =

!++
!
! Functional Description:
!
!	This routine marks the specified blocks as allocated in the allocation
!	bitmap.
!
! Calling Sequence:
!	standard
!
! Input Parameters:
!	none
!
! Implicit Inputs:
!	none
!
! Output Parameters:
!	none
!
! Implicit Outputs:
!	none
!
! Routines Called:
!	none
!
! Routine Value:
!	none
!
! Signals:
!	none
!
! Side Effects:
!	none
!
!--

BEGIN

LOCAL
	CLUSTER_NUMBER,		! Cluster bit number
	CLUSTER_COUNT,		! Count of clusters to mark allocated
	J;			! Bitmap index

CLUSTER_COUNT = .COUNT<0,31> / .ALLOC_CLUSTER;
CLUSTER_NUMBER = .LBN<0,31> / .ALLOC_CLUSTER;
INCR J FROM .CLUSTER_NUMBER
TO MINU (.CLUSTER_NUMBER + .CLUSTER_COUNT, .ALLOCMAP_SIZE * 8) - 1
DO
    BEGIN
    IF NOT .ALLOCMAP[.J]
    THEN DUALLOC = 1
    ELSE BLOCKS_AVAIL = .BLOCKS_AVAIL - .ALLOC_CLUSTER;
    ALLOCMAP[.J] = 0;
    END;
END;					! end of routine MARK_ALLOC

ROUTINE VERIFY_HEADER (HEADER, FILE_ID) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine verifies that the block given it is in fact a
!	file header. If file number and/or file seqence number are also
!	supplied, they are checked as well.
!
! Calling Sequence:
!	standard
!
! Input Parameters:
!	none
!
! Implicit Inputs:
!	none
!
! Output Parameters:
!	none
!
! Implicit Outputs:
!	none
!
! Routines Called:
!	none
!
! Routine Value:
!	none
!
! Signals:
!	none
!
! Side Effects:
!	none
!
!--

BEGIN

MAP
	HEADER		: REF BBLOCK,	! file header arg
	FILE_ID		: REF BBLOCK;	! file ID arg

LOCAL
	MAP_AREA	: REF BBLOCK;	! pointer to header map area

EXTERNAL ROUTINE
	CHECKSUM;			! compute file header checksum


! First check the structure level.
!

IF .HEADER[FH2$B_STRUCLEV] NEQ 2
THEN RETURN 0;

! Check the area offsets and the retrieval pointer use counts for
! consistency.
!

IF .HEADER[FH2$B_IDOFFSET] LSSU $BYTEOFFSET (FH2$L_HIGHWATER)/2
OR .HEADER[FH2$B_MPOFFSET] LSSU .HEADER[FH2$B_IDOFFSET]
OR .HEADER[FH2$B_ACOFFSET] LSSU .HEADER[FH2$B_MPOFFSET]
OR .HEADER[FH2$B_RSOFFSET] LSSU .HEADER[FH2$B_ACOFFSET]
OR .HEADER[FH2$B_MAP_INUSE] GTRU .HEADER[FH2$B_ACOFFSET] - .HEADER[FH2$B_MPOFFSET]
THEN RETURN 0;

! At this point, we have verified that the block at least once was a
! valid file header.
!
! Look at the file number in the header. If zero, this is a 
! deleted header.
!

IF .HEADER[FH2$W_FID_NUM] EQL 0
AND .HEADER[FH2$B_FID_NMX] EQL 0
THEN RETURN 2;

! Now compute the header checksum.
!

IF NOT CHECKSUM (.HEADER)
THEN RETURN 2;

! Check file number and file sequence number.
!

IF .HEADER[FH2$W_FID_NUM] NEQ .FILE_ID[FID$W_NUM]
OR .HEADER[FH2$B_FID_NMX] NEQ .FILE_ID[FID$B_NMX]
THEN RETURN 2;

IF .HEADER[FH2$W_FID_SEQ] NEQ .FILE_ID[FID$W_SEQ]
THEN RETURN 2;

! Header is ok.
!

RETURN 1;

END;					! end of routine VERIFY_HEADER

ROUTINE READ_HOMEBLOCK (BUFFER, RVN) : NOVALUE =

!++
!
! Functional Description:
!
!	This routine reads the first good home block of the currently open
!	index file into the buffer supplied.
!
! Calling Sequence:
!	standard
!
! Input Parameters:
!	none
!
! Implicit Inputs:
!	none
!
! Output Parameters:
!	none
!
! Implicit Outputs:
!	none
!
! Routines Called:
!	none
!
! Routine Value:
!	none
!
! Signals:
!	none
!
! Side Effects:
!	none
!
!--

BEGIN

MAP
	BUFFER		: REF BBLOCK;	! block buffer arg

LOCAL
	STATUS,				! general status value
	OLD_STATUS;			! save status for error message


! We keep reading until we get a block that reads without errors and looks
! like a home block. Track any error status for the eventual error message.
!

OLD_STATUS = SS$_ABORT;
INCR VBN FROM 2 TO 100
DO
    BEGIN
    STATUS = DO_IO (CHAN = .CHANNEL,
		    FUNC = IO$_READVBLK,
		    IOSB = IO_STATUS,
		    P1   = .BUFFER,
		    P2   = 512,
		    P3   = .VBN
		    );
    IF .STATUS THEN STATUS = .IO_STATUS[0];

    IF NOT .STATUS
    THEN
	OLD_STATUS = .STATUS
    ELSE
	IF CHECK_HOMEBLOCK (.BUFFER, .VBN)
	THEN RETURN;
    END;				! end of loop

RBLD_EXIT (RBLD$_HOMEBLOCK, .RVN, .OLD_STATUS);

END;					! end of routine READ_HOMEBLOCK

ROUTINE CHECK_HOMEBLOCK (HOME_BLOCK, VBN) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine verifies whether the given block is a Files-11 Structure
!	Level 2 home block.
!
! Calling Sequence:
!	standard
!
! Input Parameters:
!	none
!
! Implicit Inputs:
!	none
!
! Output Parameters:
!	none
!
! Implicit Outputs:
!	none
!
! Routines Called:
!	none
!
! Routine Value:
!	none
!
! Signals:
!	none
!
! Side Effects:
!	none
!
!--

BEGIN

MAP
	HOME_BLOCK	: REF BBLOCK;	! home block buffer

EXTERNAL ROUTINE
	CHECKSUM2;			! compute home block checksums


! Check the required non-zero fields and compute the checksums.
!

IF NOT (
	.HOME_BLOCK[HM2$W_HOMEVBN] EQL .VBN
    AND .HOME_BLOCK[HM2$L_ALTIDXLBN] NEQ 0
    AND .HOME_BLOCK[HM2$W_CLUSTER] NEQ 0
    AND .HOME_BLOCK[HM2$W_HOMEVBN] NEQ 0
    AND .HOME_BLOCK[HM2$W_ALHOMEVBN] NEQ 0
    AND .HOME_BLOCK[HM2$W_ALTIDXVBN] NEQ 0
    AND .HOME_BLOCK[HM2$W_IBMAPVBN] NEQ 0
    AND .HOME_BLOCK[HM2$L_IBMAPLBN] NEQ 0
    AND .HOME_BLOCK[HM2$L_MAXFILES] NEQ 0
    AND .HOME_BLOCK[HM2$W_IBMAPSIZE] NEQ 0
    AND .HOME_BLOCK[HM2$W_RESFILES] NEQ 0
    AND CHECKSUM2 (.HOME_BLOCK, $BYTEOFFSET (HM2$W_CHECKSUM1))
    AND CHECKSUM2 (.HOME_BLOCK, $BYTEOFFSET (HM2$W_CHECKSUM2))
	)
THEN RETURN 0;

RETURN 1;

END;					! end of routine CHECK_HOMEBLOCK

ROUTINE RBLD_HANDLER (SIGNAL_VEC, MECHANISM) =

!++
!
! Functional Description:
!
!	This routine is the main condition handler for the DISKQUOTA utility.
!	It receives a signal which is either an internal error code or a
!	standard system status. If the former, the appropriate message is
!	formatted and printed. For the latter, the condition is simply
!	resignalled.
!
! Calling Sequence:
!	standard
!
! Input Parameters:
!	none
!
! Implicit Inputs:
!	none
!
! Output Parameters:
!	none
!
! Implicit Outputs:
!	none
!
! Routines Called:
!	none
!
! Routine Value:
!	none
!
! Signals:
!	none
!
! Side Effects:
!	none
!
!--

BEGIN

MAP
	SIGNAL_VEC		: REF BBLOCK,	! signal vector arg
	MECHANISM	: REF BBLOCK;	! mechanism vector arg

LOCAL
	FORMAT_DESC	: VECTOR [2],	! string descriptor for message format
	P		: REF VECTOR [,BYTE], ! string pointer
	ERR_CODE	: BBLOCK [4];	! error status code

EXTERNAL ROUTINE
	LIB$PUT_OUTPUT	: ADDRESSING_MODE (GENERAL),
	LIB$FREE_VM	: ADDRESSING_MODE (GENERAL);


! Get the signal code. If it is one of ours, get the message string and
! do formatting as necessary.
!

ERR_CODE = .SIGNAL_VEC[CHF$L_SIG_NAME];
IF .ERR_CODE[STS$V_FAC_NO] EQL FAC_CODE
THEN
    BEGIN
    ERR_CODE = .ERR_CODE[STS$V_MSG_NO];
    P = .MESSAGE_TABLE[.ERR_CODE];
    FORMAT_DESC[0] = .P[1];
    FORMAT_DESC[1] = .P + 2;
    OUTPUT_DESC[0] = OUTPUT_LENGTH;
    OUTPUT_DESC[1] = OUTPUT_LINE;

    $FAOL (CTRSTR = FORMAT_DESC[0],
	   OUTLEN = OUTPUT_DESC[0],
	   OUTBUF = OUTPUT_DESC[0],
	   PRMLST = SIGNAL_VEC[CHF$L_SIG_ARG1]
	   );
    LIB$PUT_OUTPUT (OUTPUT_DESC);

! If there is a signal argument remaining, it is a system error status.
! Convert its severity to warning and signal it.
!

    ERR_CODE = 0;
    IF .SIGNAL_VEC[CHF$L_SIG_ARGS] GTRU .P[0] + 3
    THEN
	BEGIN
	ERR_CODE = .VECTOR [SIGNAL_VEC[CHF$L_SIG_ARG1], .P[0]];
	END;
    END;

IF .ERR_CODE NEQ 0
AND .ERR_CODE NEQ SS$_UNWIND
THEN
    BEGIN
    ERR_CODE[STS$V_SEVERITY] = STS$K_WARNING;
    SIGNAL (.ERR_CODE);
    END;

MECHANISM[CHF$L_MCH_SAVR0] = 1;
IF .BBLOCK [SIGNAL_VEC[CHF$L_SIG_NAME], STS$V_SEVERITY] EQL STS$K_SEVERE
THEN
    BEGIN
!    IF .CLEANUP_FLAGS[CLF_UNLOCK]
!    THEN
	BEGIN
	CH$FILL (0, FIB$C_LENGTH, QUOTA_FIB);
	QUOTA_FIB[FIB$W_CNTRLFUNC] = FIB$C_UNLK_VOL;
	DO_IO (CHAN = .CHANNEL,
	       FUNC = IO$_ACPCONTROL,
	       P1   = QFIB_DESC
	       );
!	CLEANUP_FLAGS[CLF_UNLOCK] = 0;
	END;

    IF .USAGE_TABLE NEQ 0
    THEN DELETE_TABLE ();

    IF .BUFFER NEQ 0
    THEN
	BEGIN
	LIB$FREE_VM (UPLIT (BLOCK_FACTOR*512), BUFFER);
	BUFFER = 0;
	END;

    IF .EOF NEQ 0
    THEN
	BEGIN
	LIB$FREE_VM (DYN_SIZE, EOF);
	EOF = 0;
	END;

    IF .IFILEMAP NEQ 0
    THEN
	BEGIN
	LIB$FREE_VM (IFILEMAP_SIZE, IFILEMAP);
	IFILEMAP = 0;
	END;

    IF .ALLOCMAP NEQ 0
    THEN
	BEGIN
	LIB$FREE_VM (ALLOCMAP_SIZE, ALLOCMAP);
	ALLOCMAP = 0;
	END;

    IF .OLD_ALLOCMAP NEQ 0
    THEN
	BEGIN
	LIB$FREE_VM (UPLIT (512), OLD_ALLOCMAP);
	OLD_ALLOCMAP = 0;
	END;

   
    IF .ERASE_CHANNEL NEQ 0
    THEN
	BEGIN
	$DASSGN (CHAN=.ERASE_CHANNEL);
	ERASE_CHANNEL = 0;
	END;

    DO_IO (CHAN = .CHANNEL,
	   FUNC = IO$_DEACCESS);


    ! Cancel the exit handler.
    !
    $CANEXH (DESBLK=EXIT_HNDLR_DESC);

    $UNWIND ();
    END;

RETURN SS$_CONTINUE;

END;					! end of routine RBLD_HANDLER

ROUTINE RBLD_EXIT_HNDL : NOVALUE =

!++
!
! Fucntional Description:
!
!	This routine is called by the OS on exit (for whatever reason) from
!	the DISKQUOTA utility.  This routine must ensure that DISKQUOTA did
!	not leave things in an awkward state.
!
! Calling Sequence:
!	standard
!
! Input Parameters:
!	none
!
! Implicit Inputs:
!	none
!
! Output Parameters:
!	none
!
! Implicit Outputs:
!	none
!
! Routines Called:
!	none
!
! Routine Value:
!	none
!
! Signals:
!	none
!
! Side Effects:
!	none
!
!--

BEGIN

!
! Make sure that DISKQUOTA did not leave a volume LOCKED.
!

!IF .CLEANUP_FLAGS[CLF_UNLOCK]
!THEN
    BEGIN
    CH$FILL (0, FIB$C_LENGTH, QUOTA_FIB);
    QUOTA_FIB[FIB$W_CNTRLFUNC] = FIB$C_UNLK_VOL;
    DO_IO (CHAN = .CHANNEL,
       FUNC = IO$_ACPCONTROL,
       P1   = QFIB_DESC
       );
    END;

END;					! end of routine RBLD_EXIT_HNDL

ROUTINE FILE_SIZE (HEADER) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine computes the number of blocks mapped by the specified
!	file header.
!
! CALLING SEQUENCE:
!	FILE_SIZE (ARG1)
!
! INPUT PARAMETERS:
!	ARG1: header address
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	number of blocks in header
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN

MAP
	HEADER		: REF BBLOCK;	! file header arg

LINKAGE
	L_MAP_POINTER	= JSB :
			  GLOBAL (COUNT = 6, LBN = 7, MAP_POINTER = 8);

GLOBAL REGISTER
	COUNT		= 6,		! retrieval pointer count
	LBN		= 7,		! retrieval pointer LBN
	MAP_POINTER	= 8;		! pointer to scan map area

LOCAL
	FILESIZE;			! size of file

EXTERNAL ROUTINE
	GET_MAP_POINTER	: L_MAP_POINTER; ! get value of file map pointer

! Scan the map area. Count up the file size from the retrieval pointers.
!

FILESIZE = 0;
MAP_POINTER = .HEADER + .HEADER[FH2$B_MPOFFSET]*2;
UNTIL .MAP_POINTER GEQA .HEADER + (.HEADER[FH2$B_MPOFFSET] + .HEADER[FH2$B_MAP_INUSE]) * 2
DO
    BEGIN
    GET_MAP_POINTER ();
    FILESIZE = .FILESIZE + .COUNT;
    MARK_ALLOC (.COUNT, .LBN);
    END;

RETURN .FILESIZE;

END;					! end of routine FILE_SIZE

ROUTINE SET_FREE (RVN) : NOVALUE =

!++
!
! Functional Description:
!
!	This routine sets the number of free blocks in the volume control block.
!	This routine must be called in kernel mode.
!
! Calling Sequence:
!	standard
!
! Input Parameters:
!	none
!
! Implicit Inputs:
!	none
!
! Output Parameters:
!	none
!
! Implicit Outputs:
!	none
!
! Routines Called:
!	none
!
! Routine Value:
!	none
!
! Signals:
!	none
!
! Side Effects:
!	none
!
!--

BEGIN

LOCAL
	RVT	: REF BBLOCK,	! pointer to relative volume table
	UCB	: REF BBLOCK,	! pointer to volume UCB
	VCB	: REF BBLOCK;	! pointer to volume VCB

EXTERNAL ROUTINE
	GET_CHANNELUCB;		! get UCB assigned to channel

    UCB = GET_CHANNELUCB (.CHANNEL);
    VCB = .UCB[UCB$L_VCB];
    RVT = .VCB[VCB$L_RVT];
    IF .RVT NEQ .UCB THEN UCB = .VECTOR[RVT[RVT$L_UCBLST], .RVN - 1];
    VCB = .UCB[UCB$L_VCB];
    VCB[VCB$L_FREE] = .BLOCKS_AVAIL;
END;					! end of routine SET_FREE

ROUTINE UPDATE_ALLOCMAP (RVN, ERASE_REQUESTED) =

!++
!
! Functional Description:
!
!	This routine writes a new storage bitmap (BITMAP.SYS) to the
!	specified volume.  Before writing each block, the existing
!	storage map is read and compared against the new map.  If blocks
!	are being returned to the storage bitmap, they may be erased before
!	the bitmap is updated.
!
! Calling Sequence:
!	standard
!
! Input Parameters:
!	ARG1	: relative volume number (RVN) of this volume
!	ARG2	: boolean.  Determines whether or not to erase blocks that
!		  are returned to the available pool of blocks.
!
! Implicit Inputs:
!	OWN storage defined at the beginning of this module.
!
! Output Parameters:
!	none
!
! Implicit Outputs:
!	CHANNEL	: I/O channel to current volume
!
! Routine Value:
!	1
!
! Signals:
!	RBLD$_ACCBITMAP	: BITMAP.SYS could not be opened or read.
!	RBLD$_WRTBITMAP	: A write operation to BITMAP.SYS failed.
!	RBLD$_ERASEBLKS	: Error erasing blocks returned to bitmap.
!
! Side Effects:
!	Areas of the disk may be erased.
!
!--

BEGIN						! Start of UPDATE_ALLOCMAP

LINKAGE
	IOC_CONVERT	= JSB (REGISTER=0, REGISTER=1, REGISTER=4, REGISTER=5;
			  REGISTER=1) :
				PRESERVE (2,3,4,5)
				NOTUSED (6,7,8,9,10,11);

BUILTIN
	MOVPSL;					! VAX-11 instruction to fetch PSL

EXTERNAL ROUTINE
	ERASE_BLOCKS	: ADDRESSING_MODE (GENERAL),
	GET_CHANNELUCB,
	IOC$CVT_DEVNAM	: IOC_CONVERT ADDRESSING_MODE (GENERAL),
	LIB$FREE_VM	: ADDRESSING_MODE (GENERAL),
	LIB$GET_VM	: ADDRESSING_MODE (GENERAL);

LITERAL
	DEVNAM_SIZE	= 15,			! max length of a device name
	MAP_VBN		= 2;			! first VBN of storage map

LOCAL
	CURRENT_PSL	: BBLOCK [4],		! current PSL
	BIT_COUNT,				! # of adjacent reclaimed clusters
	BUFPTR		: REF BITVECTOR,	! current buffer pointer for file
	CURRENT_DEV	: BBLOCK [DSC$K_S_BLN],	! device name descriptor
	DEVNAM_BUF	: BBLOCK [DEVNAM_SIZE],	! device name buffer
	ERASE_STATUS,				! holds erase operation status
	RVT		: REF BBLOCK,		! pointer to Relative Volume Table
	STATUS,					! saves local status values
	UCB		: REF BBLOCK,		! pointer to Unit Control Block
	VBN,					! current Virtual Block Number in file
	VCB		: REF BBLOCK;		! pointer to Volume Control Block

!
! If this routine is being called from USER mode, then disable the
! erase to prevent an ACCVIO when trying to examine the device data
! base.
!
MOVPSL (CURRENT_PSL);				! Fetch the current PSL
IF .CURRENT_PSL[PSL$V_CURMOD] EQL PSL$C_USER
THEN
    ERASE_REQUESTED = 0;

!
! Open the storage allocation bitmap file (BITMAP.SYS) on the volume.
!
QUOTA_FIB[FIB$L_ACCTL] = FIB$M_WRITE OR FIB$M_NOWRITE;
QUOTA_FIB[FIB$W_FID_NUM] = FID$C_BITMAP;
QUOTA_FIB[FIB$W_FID_SEQ] = FID$C_BITMAP;
QUOTA_FIB[FIB$W_FID_RVN] = .RVN;

STATUS = DO_IO	(CHAN = .CHANNEL,
		 FUNC = IO$_ACCESS OR IO$M_ACCESS,
		 IOSB = IO_STATUS,
		 P1   = QFIB_DESC
		);
IF .STATUS THEN STATUS = .IO_STATUS[0];
IF NOT .STATUS
THEN
    RBLD_EXIT (RBLD$_ACCBITMAP, .RVN, .STATUS);
!
!
! For each block in the bitmap, read the old map block and compare
! it to the map we have laboriously constructed.  If any blocks are
! being reclaimed (that is, they are marked free on the new map and
! marked 'in use' on the old map) then erase them before writing the
! new map block.
!
! We do not read the old storage map if the caller did not request
! that reclaimed blocks be erased.  If the map read-buffer cannot
! be created, the erase is not attempted.
!
! Note: The SCB is VBN 1 of BITMAP.SYS.  The actual storage allocation
!	bitmap begins at VBN 2.
!
!
ERASE_STATUS = 1;
OLD_ALLOCMAP = 0;

IF .ERASE_REQUESTED				! ... then allocate read-buffer
THEN
    IF .OLD_ALLOCMAP EQL 0
    THEN
	IF NOT (ERASE_STATUS = LIB$GET_VM (UPLIT (512), OLD_ALLOCMAP))
	THEN
	   ERASE_REQUESTED = 0;			! Disable the erase
    
IF .ERASE_REQUESTED				! ... then assign a channel
THEN
    BEGIN
    !
    ! Assign a channel to current volume so the erase I/O will work properly.
    ! This is done by getting the UCB address of the root volume of the volume
    ! set, following the pointers to the RVT, and from there picking up the UCB
    ! address of this volume.  Given the proper UCB address, format the device
    ! name and assign a channel to the device.
    !
    ! Note that CHANNEL is assigned to the root volume of the volume set.
    !
    IF .ERASE_CHANNEL NEQ 0
    THEN
	$DASSGN (CHAN=.ERASE_CHANNEL);
    UCB = KERNEL_CALL (GET_CHANNELUCB, .CHANNEL);
    VCB = .UCB[UCB$L_VCB];
    RVT = .VCB[VCB$L_RVT];
    IF .RVT NEQ .UCB
    THEN
	UCB = .VECTOR[RVT[RVT$L_UCBLST], .RVN-1];
    CURRENT_DEV[DSC$A_POINTER]= DEVNAM_BUF;
    IOC$CVT_DEVNAM (DEVNAM_SIZE, DEVNAM_BUF, -1, .UCB; CURRENT_DEV[DSC$W_LENGTH]);
    CURRENT_DEV[DSC$B_DTYPE] = DSC$K_DTYPE_T;
    CURRENT_DEV[DSC$B_CLASS] = DSC$K_CLASS_S;
    IF NOT (ERASE_STATUS = $ASSIGN (DEVNAM=CURRENT_DEV, CHAN=ERASE_CHANNEL))
    THEN
	ERASE_REQUESTED = 0;
    END;

VBN = MAP_VBN;					! Skip the SCB
BUFPTR = .ALLOCMAP;    
UNTIL .BUFPTR GEQA .ALLOCMAP + .ALLOCMAP_SIZE DO
    BEGIN					! Start of DO-UNTIL loop
    IF .ERASE_REQUESTED
    THEN
	BEGIN					! Start of scan/erase code
	!
	! Read the next block of the old bitmap.  Read errors will abort the
	! rebuild and leave the volume software writelocked.
	!
	STATUS = DO_IO (CHAN = .CHANNEL,
			FUNC = IO$_READVBLK,
			IOSB = IO_STATUS,
			P1   = .OLD_ALLOCMAP,
			P2   = 512,
			P3   = .VBN
			);
	IF .STATUS
	THEN
	    IF NOT (STATUS = .IO_STATUS[0])
	    THEN
		BEGIN
!		CLEANUP_FLAGS[CLF_UNLOCK] = 0;
		RBLD_EXIT (RBLD$_ACCBITMAP, .RVN, .STATUS);
		END;
	!
	! Compare the old bitmap block against the new bitmap block.
	! Reclaimed blocks are those marked 'free' on the new map
	! and 'in use' on the old.
	!
	BIT_COUNT = 0;
	INCR I FROM 0 TO 4095 DO
	    BEGIN				! Start of scan loop
	    IF .BUFPTR[.I] AND NOT .OLD_ALLOCMAP[.I]
	    THEN
		!
		! This cluster is being reclaimed.  Count it.
		!
		BIT_COUNT = .BIT_COUNT + 1
	    ELSE
		IF (.BIT_COUNT NEQ 0)
		THEN
		    BEGIN
		    !
		    ! The last BIT_COUNT clusters are being reclaimed.
		    ! Calculate the starting LBN and number of blocks
		    ! being reclaimed and erase them.
		    !
		    STATUS = ERASE_BLOCKS ((((.VBN-MAP_VBN)*4096)+(.I-.BIT_COUNT)) * .CLUSTER_FACTOR[.RVN-1],
					   .BIT_COUNT * .CLUSTER_FACTOR[.RVN-1],
					   .ERASE_CHANNEL
					  );
		    IF NOT .STATUS AND .ERASE_STATUS
		    THEN
			ERASE_STATUS = .STATUS;
		    BIT_COUNT = 0;
		    END;
	    END;				! End of scan loop
	END;					! End of scan/erase code

    !
    ! Write the new storage allocation bitmap block to the disk. Write errors
    ! will abort the rebuild and leave the volume softare writlocked.
    !
    STATUS = DO_IO (CHAN = .CHANNEL,
		    FUNC = IO$_WRITEVBLK,
		    IOSB = IO_STATUS,
		    P1   = .BUFPTR,
		    P2   = 512,
		    P3   = .VBN
		    );
    IF .STATUS
    THEN
	IF NOT (STATUS = .IO_STATUS[0])
	THEN
	    BEGIN
!	    CLEANUP_FLAGS[CLF_UNLOCK] = 0;
	    RBLD_EXIT (RBLD$_WRTBITMAP, .RVN, .STATUS);
	    END;

    VBN = .VBN + 1;				! Advance to next VBN in file
    BUFPTR = .BUFPTR + 512;			! Advance to next block in new bitmap
    END;					! End of DO-UNTIL loop

!
! If we get this far, the storage bitmap has been updated.
! Report errors encountered while erasing reclaimed blocks, if any.
!
IF NOT .ERASE_STATUS
THEN
    RBLD_MESSAGE (RBLD$_ERASEBLKS, .RVN, .ERASE_STATUS);

!
! Return resources to system.
!
IF .OLD_ALLOCMAP NEQ 0				! Return buffer
THEN
    BEGIN
    LIB$FREE_VM (UPLIT (512), OLD_ALLOCMAP);
    OLD_ALLOCMAP = 0;
    END;

IF .ERASE_CHANNEL NEQ 0				! Dassign channel
THEN
    BEGIN
    $DASSGN (CHAN=.ERASE_CHANNEL);
    ERASE_CHANNEL = 0;
    END;

RETURN 1

END;					! End of UPDATE_ALLOCMAP

end

eludom
