%TITLE 'LIB$SCREEN - Screen Management'
MODULE LIB$SCREEN (
		IDENT = 'V04-000'	! File: SCREEN.B32 Edit: PLL1011
		) =
BEGIN
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY:	General Utility Library
!
! ABSTRACT:
!
!	This module contains routines to perform terminal graphics
!	functions on the logical device SYS$OUTPUT.  The terminal type
! 	is interrogated and saved on the first routine call and
!	determines the escape sequences to be sent to the terminal.
!	For unknown terminals and terminals without any graphic
!	functions (LA36), an appropriate sequence is sent when
!	necessary (carriage return instead of SET_CURSOR.
!
! ENVIRONMENT:	User mode, Shared library routines.
!
! AUTHOR: R. Reichert, CREATION DATE: 25-AUG-1982
!
! MODIFIED BY:
!
! 1-001	- Original.  
!	  This module is based on SCRPKG.MAR, version V03-001,
!	  dated 13-April-1982.
!	  RKR 25-AUG-1982
! 1-002 - Use VMS logicals to point to require files.  PLL 24-Jan-1983
! 1-003 - Don't check the return status from FILL_MAP, to remain
!	  compatible with the original macro code.  PLL 31-Jan-1983
! 1-004 - In FILL_MAP, accept end_index equal to scr$l_area.  PLL 3-Feb-1983
! 1-005 - LIB$ERASE_LINE, LIB$ERASE_PAGE, and LIB$SET_SCROLL should treat
!	  a single null argument as no arguments passed.  PLL 22-Feb-1983
! 1-006 - Screwed up the last edit - try again.  PLL 24-Feb-1983
! 1-007 - Correct INVCHA error - it should be IVCHAN.  PLL 19-May-1983
! 1-008 - IVCHAN doesn't exits.  Change back to INVCHA to allow system to build
!		ADE 29-May-1983
! 1-009 - In SCR$PUT_BUFFER, change call to SCR$PUT_SCREEN to OUTPUT.  Try
!	  again to eliminate INVCHA error message.  PLL 19-Jul-1983
! 1-010 - To prevent an access violation, make sure that macro $SCR_APPEND
!	  doesn't try to move a negative number of bytes.  PLL 9-Jul-1984
! 1-011 - When buffering is turned off, make sure the bufsiz in the TCB is
!	  returned to the non-buffered length so subsequent non-buffered
!	  output isn't truncated.  PLL 10-Jul-1984
!--


%SBTTL 'Declarations'
!
! SWITCHES:
!

!
! LINKAGES:
!
!	NONE
!
! INCLUDE FILES:
!

REQUIRE 'SRC$:SCRPROLOG';		! defines psects, macros, &
					!  terminal defs
REQUIRE 'LIB$:STRLNK';			! JSB linkages for STR$ routines
!
! TABLE OF CONTENTS:
!

FORWARD ROUTINE

!	The LIB$ entry points

    LIB$ERASE_LINE,	! Erase Line from Screen
    LIB$ERASE_PAGE,	! Erase Page from Screen
    LIB$PUT_BUFFER,	! Put Current Buffer to Screen or to Prev. Buffer
    LIB$PUT_LINE,	! Put Text to Screen in Line Mode
    LIB$PUT_SCREEN,	! Put Text to Screen
    LIB$SET_CURSOR,	! Set Cursor to Character Position on Screen
    LIB$SET_SCROLL,	! Set Scrolling Region

!	The SCR$ entry points

    SCR$DOWN_SCROLL,	! Down Scroll, Move Cursor up One Line
    SCR$ERASE_LINE,	! Erase Line
    SCR$ERASE_PAGE,	! Erase Page
    SCR$PUT_BUFFER,	! Put Current Buffer to Screen or Previous Buffer
    SCR$PUT_LINE,	! Put Text to Screen in Line Mode
    SCR$PUT_SCREEN,	! Put Text to Screen
    SCR$SET_BUFFER,	! Set/Clear Buffer Mode
    SCR$SET_CURSOR,	! Set Cursor to Character Position on Screen
    SCR$SET_SCROLL,	! Establish Scrolling Region
    SCR$UP_SCROLL,	! Up Scroll, Move Cursor Down One Line

!	The following routine was completely commented out in the
!	original Macro version, SCRPKG.  Included here only for
!	historical reasons.
!   SCR$MOVE_CURSOR,	! Move Cursor to Relative Location

!	Internally used routines

    SCR$$GET_TYPE_R3 : GET_TYPE_LINK,  ! Get device type
    SCR$$FOREIGN,	! Foreign Terminal Handler

!	Local subroutines and functions

    DO_ATTR,		! Output simulated bolding and underlining.
    FILL_MAP,		! Fill map with specified character
    OUTPUT,		! Write string to terminal
    PUT_MAP,		! Output virtual screen map
    RMS_OUTPUT,		! Write a string via RMS
    SET_CURSOR,		! Create set cursor sequence
    TRIMMED_LENGTH; 	! Calc. length of string without trailing blanks

!+
! The following routine entry point names are defined as alias for
! routines defined above.  They are defined via 
! GLOBAL BIND ROUTINE LIB$xxx = SCR$xxx declarations.
!-
!
! LIB$DOWN_SCROLL = SCR$DOWN_SCROLL ! Down scroll, move cursor up 1 line
! LIB$SET_BUFFER  = SCR$SET_BUFFER  !	Set or Clear Screen Buffer Mode
! LIB$UP_SCROLL	  = SCR$UP_SCROLL   ! Up scroll, move cursor down 1 line

!+
! The following entry point is obsolete, but is still present in 
! SCRVECTOR.  So it's defined here to keep the linker happy.
!-
! SCR$ERASE	= SCR$ERASE_PAGE

!
! MACROS:
!

!
! EQUATED SYMBOLS:
!

!
! FIELDS:
!
!	NONE
!
! PSECTS:
!

! OWN STORAGE:
!
!+
!	W R I T A B L E  D A T A  D E F I N I T I O N S
!	-----------------------------------------------
!-
GLOBAL
    SCR$L_FLINKHEAD : INITIAL (0),	! Initial state is empty
    SCR$L_CUROUTPUT : INITIAL (0);	! Pointer to current output unit

OWN
    SCR$L_WORKMASK  : INITIAL (0);	! Used to reset attribute mask





!
! EXTERNAL REFERENCES:
!

EXTERNAL ROUTINE
    LIB$ANALYZE_SDESC_R2 : LIB$ANALYZE_SDESC_JSB_LINK,
				! Get length and address from descriptor
    LIB$ASSIGN,			! Assign channel
    LIB$CALL_IMAGE,		! Call image
    LIB$FREE_EF,		! Deallocate event flag number
    LIB$FREE_VM,		! Deallocate heap storage
    LIB$GET_EF,			! Get local event flag
    LIB$GET_INPUT,		! Get input from SYS$INPUT
    LIB$GET_VM,			! Allocate heap storage
    LIB$LP_LINES,		! Get default lines per page
    LIB$PUT_OUTPUT,		! Output to SYS$OUTPUT
    LIB$SFREE1_DD,		! Release space for a dynamic string
    LIB$SIG_TO_RET,		! Convert signals to return status
    SCR$SET_OUTPUT,		! Establish terminal for output
    SCR$STOP_OUTPUT,		! Stop output to terminal or screen buffer
    STR$CONCAT,			! Concatenate several strings into one
    STR$DUPL_CHAR;		! Fill a string with some character

EXTERNAL LITERAL		! Condition value symbols
    LIB$_FATERRLIB,		! Fatal internal error
    LIB$_INVARG,		! Invalid argument
    LIB$_NO_STRACT,		! No stream active
    LIB$_INVSCRPOS,		! Invalid screen coordinate position
    LIB$_SCRBUFOVF,		! Screen buffer overflow
    LIB$_WRONUMARG ;		! Wrong number of arguments

EXTERNAL
    SCR$AL_DEVDEPND2 : BLOCK [, BYTE];


%SBTTL 'LIB$DOWN_SCROLL - Down Scroll, Move Cursor up One Line'
! GLOBAL ROUTINE LIB$DOWN_SCROLL =
!
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine causes the cursor to be moved up 1 line to the
!	same column of the previous line.  If the cursor was on the
!	top line to begin with, it stays where it was, but all the
!	information on the screen appears to move down one line.  The
!	information that was on the bottom line is lost and a blank line
!	appears at the top.
!
!	If a scrolling region is active ( on a VT100 or in mapping)
!	then the logic above applies to the top and bottom lines of
!	the scrolling region rather than the top and bottom line of
!	the screen.  If an UP_SCROLL is performed on the bottom line of
!	the screen, or a DOWN_SCROLL is performed on the top line of the
!	screen, while a scrolling region is active then no screen
!	movement takes place unless the top or bottom line of the screen
!	corresponds to the top or bottom line of the scrolling region.
!
! CALLING SEQUENCE:
!
!	ret_status.wlc.v = LIB$DOWN_SCROLL ()
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	SS$_NORMAL	Normal successful completion
!
! SIDE EFFECTS:
!
!	NONE
!--

!+
! Equate to SCR$ entry point.
!-

GLOBAL BIND ROUTINE LIB$DOWN_SCROLL = SCR$DOWN_SCROLL ;
!<BLF/PAGE>

%SBTTL 'LIB$ERASE_LINE - Erase Line from Screen'
GLOBAL ROUTINE LIB$ERASE_LINE (
				LINE_NO : REF VECTOR [,WORD],
				COL_NO	: REF VECTOR [,WORD]
			      ) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine causes the screen to be erased from the specified
!	position to the end of the line.  If the position is not
!	specified, the current screen position is assumed.
!
! CALLING SEQUENCE:
!
!	ret_status.wlc.v = LIB$ERASE_LINE ([LINE_NO.rw.r, COL_NO.rw.r])
!
! FORMAL PARAMETERS:
!
!	LINE_NO.rw.r	Optional.  Address of line number where erasing
!			starts.  If this argument is omitted, COL_NO is
!			ignored as well, and current position will be 
!			used.
!
!	COL_NO.rw.r	Optional.  Address of column number where 
!			erasing starts.  If this argument is omitted, 
!			LINE_NO is ignored as well, and current position
!			will be used.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	SS$_NORMAL	Normal successful completion
!
! SIDE EFFECTS:
!
!	NONE
!--

    BEGIN

    BUILTIN
	ACTUALCOUNT,
	ACTUALPARAMETER,
	AP,
	CALLG;

!+
! If no arguments, just call SCR$ERASE_LINE with original call list.
!-
    IF ACTUALCOUNT() EQL 0
    THEN
	RETURN ( CALLG ( .AP, SCR$ERASE_LINE)) ;

!+
! Just 1 argument is a no-no.  If LINE_NO is supplied, COL_NO must be
! supplied as well.  Complain.
!-
    IF ACTUALCOUNT() EQL 1 
    THEN
        IF ACTUALPARAMETER (1) EQL 0
        THEN			! 1 null arg - treat as no args
	    RETURN ( SCR$ERASE_LINE ()) 
    	ELSE			! 1 nonzero arg - error
	    RETURN ( LIB$_WRONUMARG ) ;	

!+
! Check supplied arguments.  If they are not specified (arglist entry
! =0) then pass on a zero.  If they are specified, check for a value
! of zero and complain.  Call SCR$ERASE_LINE with appropriate
! combination of arguments promoted to by-value.
!-
    IF ACTUALCOUNT() EQL 2
    THEN
	RETURN ( SCR$ERASE_LINE (
			IF ACTUALPARAMETER(1) NEQ 0
			THEN
			    IF .LINE_NO[0] EQL 0
			    THEN
				RETURN (LIB$_INVSCRPOS)
			    ELSE 
				.LINE_NO[0]
			ELSE 0,

			IF ACTUALPARAMETER(2) NEQ 0
			THEN
			    IF .COL_NO[0] EQL 0
			    THEN
				RETURN (LIB$_INVSCRPOS)
			    ELSE .COL_NO[0]
			ELSE 0 ))

    ELSE
	RETURN ( LIB$_WRONUMARG ) ;	
    END;				! End of routine LIB$ERASE_LINE
!<BLF/PAGE>

%SBTTL 'LIB$ERASE_PAGE - Erase Page from Screen'
GLOBAL ROUTINE LIB$ERASE_PAGE (
				LINE_NO : REF VECTOR [,WORD],
				COL_NO	: REF VECTOR [,WORD]
			      ) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine causes the screen to be erased from the specified
!	position to the end of the screen.  If the position is not
!	specified, the current screen position is assumed.
!
! CALLING SEQUENCE:
!
!	ret_status.wlc.v = LIB$ERASE_PAGE ([LINE_NO.rw.r, COL_NO.rw.r])
!
! FORMAL PARAMETERS:
!
!	LINE_NO.rw.r	Optional.  Address of line number at which to 
!			start erasing.  If omitted, COL_NO will be 
!			ignored as well and current cursor position 
!			will be used.
!
!	COL_NO.rw.r	Optional.  Address of Column number at which 
!			to start erasing.  If omitted, LINE_NO will be 
!			ignored as well and current cursor position 
!			will be used.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	SS$_NORMAL	Normal successful completion
!
! SIDE EFFECTS:
!
!	NONE
!--

    BEGIN

    BUILTIN
	ACTUALCOUNT,
	ACTUALPARAMETER,
	AP,
	CALLG;

!+
! If no arguments, just call SCR$ERASE_PAGE with original call list.
!-
    IF ACTUALCOUNT() EQL 0
    THEN
	RETURN ( CALLG ( .AP, SCR$ERASE_PAGE)) ;

!+
! Just 1 argument is a no-no.  If LINE_NO is supplied, COL_NO must be
! supplied as well.  Complain.
!-
    IF ACTUALCOUNT() EQL 1 
    THEN
        IF ACTUALPARAMETER (1) EQL 0
 	THEN			! 1 null arg - treat as no args
	    RETURN ( SCR$ERASE_PAGE ()) 
    	ELSE			! 1 nonzero arg - error
	    RETURN ( LIB$_WRONUMARG ) ;	

!+
! Check supplied arguments.  If they are not specified (arglist entry
! =0) then pass on a zero.  If they are specified, check for a value
! of zero and complain.  Call SCR$ERASE_PAGE with appropriate
! combination of arguments promoted to by-value.
!-
    IF ACTUALCOUNT() EQL 2
    THEN
	RETURN ( SCR$ERASE_PAGE (
			IF ACTUALPARAMETER(1) NEQ 0
			THEN
			    IF .LINE_NO[0] EQL 0
			    THEN
				RETURN (LIB$_INVSCRPOS)
			    ELSE 
				.LINE_NO[0]
			ELSE 0,

			IF ACTUALPARAMETER(2) NEQ 0
			THEN
			    IF .COL_NO[0] EQL 0
			    THEN
				RETURN (LIB$_INVSCRPOS)
			    ELSE .COL_NO[0]
			ELSE 0 ))

    ELSE
	RETURN ( LIB$_WRONUMARG ) ;	
    END;				! End of routine LIB$ERASE_PAGE
!<BLF/PAGE>

%SBTTL 'LIB$PUT_BUFFER - Put Current Buffer to Screen or to Prev. Buffer'
GLOBAL ROUTINE LIB$PUT_BUFFER (
				OLD_BUFFER : REF VECTOR [,LONG]
			      ) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is the converse of LIB$SET_BUFFER.  It puts the
!	contents of the current buffer to another buffer or the screen
!	if no buffer is given.
!
! CALLING SEQUENCE:
!
!	ret_status.wlc.v = LIB$PUT_BUFFER ([OLD_BUFFER.rl.r])
!
! FORMAL PARAMETERS:
!
!	OLD_BUFFER.rl.r		Optional.  Address of the previous
!				buffer to put the current buffer into.
!				If not specified or zero, put current
!				buffer to the screen.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	SS$_NORMAL	Normal successful completion
!
! SIDE EFFECTS:
!
!	The current buffer is output and reintialized to empty.  If
!	OLD_BUFFER is nonzero, it is established to become the new 
!	current buffer.
!--

    BEGIN

    BUILTIN
	ACTUALCOUNT,
	ACTUALPARAMETER;

!+
! If no arguments supplied to us, just call SCR$PUT_BUFFER with no
! arguments.
!-
    IF ACTUALCOUNT() EQL 0
    THEN
	RETURN ( SCR$PUT_BUFFER()) ;

!+
! If parameter supplied, and it isn't zero, pass it on to SCR$PUT_BUFFER
! with the by-value address.  If parameter is zero, call SCR$PUT_BUFFER
! with no arguments.
!-
    IF ACTUALCOUNT() EQL 1
    THEN
	IF ACTUALPARAMETER(1) NEQ 0
	THEN
	    RETURN ( SCR$PUT_BUFFER ( OLD_BUFFER[0]))
	ELSE
	    RETURN ( SCR$PUT_BUFFER() )
    ELSE
	RETURN ( LIB$_WRONUMARG ) ;	

    END;				! End of routine LIB$PUT_BUFFER
!<BLF/PAGE>

%SBTTL 'LIB$PUT_LINE - Put Text to Screen in Line Mode'
GLOBAL ROUTINE LIB$PUT_LINE (
				TEXT     : REF BLOCK [,BYTE],
				LINE_ADV,
				FLAGS
			    ) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is used to write messages to the terminal
!	followed by cursor movement sequences.
!
! CALLING SEQUENCE:
!
!	ret_status.wlc.v = LIB$PUT_LINE (TEXT.rt.dx
!					 [,LINE_ADV.rl.r] 
!					 [,FLAGS.rl.r])
!
! FORMAL PARAMETERS:
!
!	TEXT.rt.dx	Address of descriptor of output string.
!
!	LINE_ADV.rl.r	Optional.  Address of signed number of lines 
!			to advance after output.
!
!	FLAGS.rl.r	Optional.  Rendition codes.
!			If omitted, SCR$M_NORMAL will be used.
!			Values:
!			    SCR$M_BLINK  	display characters blinking.
!			    SCR$M_BOLD  	display characters in
!					  	higher-than-normal intensity.
!			    SCR$M_NORMAL  	display characters using
!					  	rendition associated with
!					  	window.
!			    SCR$M_REVERSE  	display characters in reverse
!					  	video -- i.e., using opposite
!					  	rendition from window default.
!			    SCR$M_UNDERLINE  	display characters underlined.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	SS$_NORMAL	Normal successful completion
!
! SIDE EFFECTS:
!
!	NONE
!--

    BEGIN

    BUILTIN
	ACTUALCOUNT,
	ACTUALPARAMETER ;

    LITERAL
	K_ADV_ARG = 2,
	K_FLAG_ARG = 3;

    LOCAL
	STATUS;

    IF ACTUALCOUNT () NEQ 0
    THEN
	BEGIN
	RETURN (STATUS = SCR$PUT_LINE (.TEXT,
				       (IF ACTUALCOUNT () GEQ K_ADV_ARG AND
					   ACTUALPARAMETER (K_ADV_ARG) NEQ 0
					THEN ..LINE_ADV
					ELSE 1),
				       (IF ACTUALCOUNT () GEQ K_FLAG_ARG AND
					   ACTUALPARAMETER (K_FLAG_ARG) NEQ 0
					THEN ..FLAGS
					ELSE SCR$M_NORMAL)
				       ));
	END
    ELSE
	RETURN (LIB$_WRONUMARG);	! error if no arguments
						

    END;				! End of routine LIB$PUT_LINE
!<BLF/PAGE>

%SBTTL 'LIB$PUT_SCREEN - Put Text to Screen'
GLOBAL ROUTINE LIB$PUT_SCREEN (
				TEXT    : REF BLOCK [,BYTE],
				LINE_NO : REF VECTOR [,WORD],
				COL_NO  : REF VECTOR [,WORD],
				FLAGS   : REF VECTOR [,LONG]
			      ) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is used to write messages to the terminal.
!
! CALLING SEQUENCE:
!
!	ret_status.wlc.v = LIB$PUT_SCREEN (TEXT.rt.dx
!					   [,LINE_NO.rl.r, COL_NO.rl.r] 
!					   [,FLAGS.rl.r])
!
! FORMAL PARAMETERS:
!
!	TEXT.rt.dx	Address of descriptor of output string.
!
!	LINE_NO.rl.r	Optional.  Address of line number at which to 
!			start output.  If omitted (=0), the current 
!			line number is used.
!
!	COL_NO.rl.r	Optional.  Address of column number at which 
!			to start output.  If omitted (=0), the current 
!			line number is used.
!
!	FLAGS.rl.r	Optional.  Rendition codes.
!			If omitted, SCR$M_NORMAL will be used.
!			Values:
!			    SCR$M_BLINK  	display characters blinking.
!			    SCR$M_BOLD  	display characters in
!					  	higher-than-normal intensity.
!			    SCR$M_NORMAL  	display characters using
!					  	rendition associated with
!					  	window.
!			    SCR$M_REVERSE  	display characters in reverse
!					  	video -- i.e., using opposite
!					  	rendition from window default.
!			    SCR$M_UNDERLINE  	display characters underlined.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	SS$_NORMAL	Normal successful completion
!	LIB$_INVARG
!	LIB$_INVSCRPOS
!
! SIDE EFFECTS:
!
!	NONE
!--

    BEGIN

    BUILTIN
	ACTUALCOUNT,
	ACTUALPARAMETER,
	AP,
	CALLG ;

    CASE ACTUALCOUNT() FROM 1 TO 4 OF
    SET
	!+
	! Only 1 argument (TEXT), call SCR$PUT_SCREEN with existing
	! call list.
	!-
	[1]:
	    RETURN ( CALLG ( .AP, SCR$PUT_SCREEN )) ;

	!+
	! Two arguments.  This is a no-no.  If LINE_NO is specified,
	! COL_NO must be specified as well.
	!-
	[2]:
	    RETURN (LIB$_WRONUMARG) ;	

	!+
	! Three arguments provided.  Must determine which (if any)
	! were not specified (call list entry is zero).  For specified
	! LINE_NO and COL_NO, check for values of zero.  Call
	! SCR$PUT_SCREEN with appropriate combination of arguments
	! promoted to by-value.
	!-
	[3]:
	    RETURN 
		( SCR$PUT_SCREEN ( .TEXT,
				   IF ACTUALPARAMETER(2) NEQ 0
				   THEN
					IF .LINE_NO[0] EQL 0
					THEN
					      RETURN (LIB$_INVSCRPOS)
					ELSE 
					      .LINE_NO[0]
				   ELSE 0,

				   IF ACTUALPARAMETER(3) NEQ 0
				   THEN
					IF .COL_NO[0] EQL 0
					THEN
					    RETURN (LIB$_INVSCRPOS)
					ELSE .COL_NO[0]
				   ELSE 0 ));

	!+
	! Four arguments provided.  Must determine which (if any)
	! were not specified (call list entry is zero).  For specified
	! LINE_NO and COL_NO, check for values of zero.  Call
	! SCR$PUT_SCREEN with appropriate combination of arguments
	! promoted to by-value.
	!-
	[4]:
	    RETURN 
		( SCR$PUT_SCREEN ( .TEXT,
				   IF ACTUALPARAMETER(2) NEQ 0
				   THEN
					IF .LINE_NO[0] EQL 0
					THEN
					      RETURN (LIB$_INVSCRPOS)
					ELSE 
					      .LINE_NO[0]
				   ELSE 0,

				   IF ACTUALPARAMETER(3) NEQ 0
				   THEN
					IF .COL_NO[0] EQL 0
					THEN
					    RETURN (LIB$_INVSCRPOS)
					ELSE .COL_NO[0]
				   ELSE 0,

				   IF ACTUALPARAMETER(4) NEQ 0
				   THEN
					.FLAGS[0]
				   ELSE
					0 )) ;

	!+
	! Too many ( or no) arguments provided.  Complain.
	!-
	[OUTRANGE]:
	    RETURN ( LIB$_WRONUMARG ) ;	
    TES ;

    END;				! End of routine LIB$PUT_SCREEN
!<BLF/PAGE>

%SBTTL 'LIB$SET_BUFFER - Set or Clear Screen Buffer Mode'
! GLOBAL ROUTINE LIB$SET_BUFFER (
!				 BUFFER     : REF BLOCK [,BYTE],
!				 OLD_BUFFER : REF VECTOR [,LONG]
!			        ) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is called to establish a buffer to be used to hold
!	terminal output rather than immediately writing the output to
!	SYS$OUTPUT.  It is also called to turn off the buffering mode.
!	The buffer address is established such that all screen output
!	is appended to the end of the buffer.
!
! CALLING SEQUENCE:
!
!	ret_status.wlc.v = LIB$SET_BUFFER (BUFFER.mt.ds
!					   [,OLD_BUFFER.wl.r])
!
! FORMAL PARAMETERS:
!
!	BUFFER.mt.ds	Address of descriptor of buffer.  If 0,
!			buffering mode is turned off.
!
!	OLD_BUFFER.wl.r Optional. Address of the location containing
!			address of the current buffer descriptor.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	SS$_NORMAL	Normal successful completion
!
! SIDE EFFECTS:
!
!	NONE
!--

!+
! Equate to SCR$ entry point.
!-
GLOBAL BIND ROUTINE LIB$SET_BUFFER = SCR$SET_BUFFER ;
!<BLF/PAGE>

%SBTTL 'LIB$SET_CURSOR - Set Cursor to Character Position on Screen'
GLOBAL ROUTINE LIB$SET_CURSOR (
				LINE_NO : REF VECTOR [,WORD],
				COL_NO  : REF VECTOR [,WORD]
			      ) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine causes the cursor to be moved to the specified
!	position.
!
! CALLING SEQUENCE:
!
!	ret_status.wlc.v = LIB$SET_CURSOR (LINE_NO.rw.r,
!					   COL_NO.rw.r)
!
! FORMAL PARAMETERS:
!
!	LINE_NO.rw.r	Address of line number.
!
!	COL_NO.rw.r	Address of column number.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	SS$_NORMAL	Normal successful completion
!
! SIDE EFFECTS:
!
!	NONE
!--

    BEGIN

    BUILTIN
	ACTUALCOUNT,
	ACTUALPARAMETER ;

    IF ACTUALCOUNT() EQL 2
    THEN
	RETURN ( SCR$SET_CURSOR (
			IF ACTUALPARAMETER(1) NEQ 0
			THEN
			    IF .LINE_NO[0] EQL 0
			    THEN
				RETURN (LIB$_INVSCRPOS)
			    ELSE 
				.LINE_NO[0]
			ELSE 
			    RETURN ( LIB$_WRONUMARG),	

			IF ACTUALPARAMETER(2) NEQ 0
			THEN
			    IF .COL_NO[0] EQL 0
			    THEN
				RETURN (LIB$_INVSCRPOS)
			    ELSE 
				.COL_NO[0]
			ELSE 
			    RETURN ( LIB$_WRONUMARG ) )) 	
							

    ELSE
	RETURN (LIB$_WRONUMARG ) ;	

    END;				! End of routine LIB$SET_CURSOR
!<BLF/PAGE>

%SBTTL 'LIB$SET_SCROLL - Set Scrolling Region'
GLOBAL ROUTINE LIB$SET_SCROLL (
				START_LINE : REF VECTOR [,WORD],
				END_LINE   : REF VECTOR [,WORD]
			      ) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine establishes a scrolling by setting the internal
!	scrolling region parameters.  Issues the escape sequence that
!	establishes the region and preserves the cursor position.
!
! CALLING SEQUENCE:
!
!	ret_status.wlc.v = LIB$SET_SCROLL (START_LINE.rw.r, 
!					   END_LINE.rw.r)
!
! FORMAL PARAMETERS:
!
!	START_LINE.rw.r		Address of first line of scrolling 
!				region.  Optional.
!
!	END_LINE.rw.r		Address of last line of scrolling 
!				region.  Optional.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	SS$_NORMAL	Normal successful completion
!
! SIDE EFFECTS:
!
!	NONE
!--

    BEGIN

    BUILTIN
	ACTUALCOUNT,
	ACTUALPARAMETER,
	AP,
	CALLG;

!+
! If no arguments, just call SCR$SET_SCROLL with original call list.
!+
    IF ACTUALCOUNT() EQL 0
    THEN			
	RETURN ( CALLG (.AP, SCR$SET_SCROLL)); 

!+
! Just 1 argument is a no-no.  If LINE_NO is supplied, COL_NO must be
! supplied as well.  Complain.
!-
    IF ACTUALCOUNT() EQL 1
    THEN
        IF ACTUALPARAMETER (1) EQL 0
    	THEN			! 1 null arg - treat as no args
	    RETURN ( SCR$SET_SCROLL ()) 
    	ELSE			! 1 nonzero arg - error
	    RETURN ( LIB$_WRONUMARG ) ;	

!+
! Check supplied arguments.  If they are not specified (arglist entry = 0)
! then pass on a zero.  If they are specified, check for a value of zero
! and complain.  Call SCR$SET_SCROLL with appropriate combination of
! arguments promoted to by-value.
!-
    IF ACTUALCOUNT() EQL 2
    THEN
	RETURN (SCR$SET_SCROLL (
			IF ACTUALPARAMETER(1) NEQ 0
			THEN
			    IF .START_LINE[0] EQL 0
			    THEN
				RETURN (LIB$_INVSCRPOS)
			    ELSE
				.START_LINE[0]
			ELSE 0,

			IF ACTUALPARAMETER(2) NEQ 0
			THEN
			    IF .END_LINE[0] EQL 0
			    THEN
				RETURN (LIB$_INVSCRPOS)
			    ELSE .END_LINE[0]
			ELSE 0))
    ELSE
	RETURN (LIB$_WRONUMARG);		

    END;				! End of routine LIB$SET_SCROLL
!<BLF/PAGE>

%SBTTL 'LIB$UP_SCROLL - Up Scroll, Move Cursor Down One Line'
! GLOBAL ROUTINE LIB$UP_SCROLL =
!
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine causes the cursor to be moved down 1 line to the
!	same column of the following line.  If the cursor was on the
!	bottom line to begin with, it stays where it was, but all the
!	information on the screen appears to move up one line.  The
!	information that was on the top line is lost and a blank line
!	appears at the bottom.
!
!	If a scrolling region is active ( on a VT100 or in mapping)
!	then the logic above applies to the top and bottom lines of
!	the scrolling region rather than the top and bottom line of
!	the screen.  If an UP_SCROLL is performed on the bottom line of
!	the screen, or a DOWN_SCROLL is performed on the top line of the
!	screen, while a scrolling region is active then no screen
!	movement takes place unless the top or bottom line of the screen
!	corresponds to the top or bottom line of the scrolling region.
!
! CALLING SEQUENCE:
!
!	ret_status.wlc.v = LIB$UP_SCROLL ()
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	SS$_NORMAL	Normal successful completion
!
! SIDE EFFECTS:
!
!	NONE
!--

!+
! Equate to SCR$ entry point.
!-

GLOBAL BIND ROUTINE LIB$UP_SCROLL = SCR$UP_SCROLL ;
!<BLF/PAGE>

%SBTTL 'SCR$DOWN_SCROLL - Down Scroll, Move Cursor up One Line'
GLOBAL ROUTINE SCR$DOWN_SCROLL =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine causes the cursor to be moved up 1 line to the
!	same column of the previous line.  If the cursor was on the
!	top line to begin with, it stays where it was, but all the
!	information on the screen appears to move down one line.  The
!	information that was on the bottom line is lost and a blank line
!	appears at the top.
!
!	If a scrolling region is active ( on a VT100 or in mapping)
!	then the logic above applies to the top and bottom lines of
!	the scrolling region rather than the top and bottom line of
!	the screen.  If an UP_SCROLL is performed on the bottom line of
!	the screen, or a DOWN_SCROLL is performed on the top line of the
!	screen, while a scrolling region is active then no screen
!	movement takes place unless the top or bottom line of the screen
!	corresponds to the top or bottom line of the scrolling region.
!
! CALLING SEQUENCE:
!
!	ret_status.wlc.v = SCR$DOWN_SCROLL ()
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	SS$_NORMAL	Normal successful completion
!
! SIDE EFFECTS:
!
!	NONE
!--

    BEGIN
    
MACRO
	VT05_DOWN = %STRING (%CHAR(VT05_CUP), %CHAR(NULL), %CHAR(NULL), %CHAR(NULL), %CHAR(NULL))%,
	VT52_DOWN = %STRING (%CHAR(ESC), %CHAR(VT52_DWN))%,
	VT100_DOWN = %STRING (%CHAR(ESC), %CHAR(VT100_DWN))%;

    LOCAL
	STATUS,				! used for calls
	TCB,				! terminal control block
	DOWN_BUF : BLOCK [8,BYTE],	! buffer dsc for OUTPUT
	TERM_TYPE;			! terminal type

    MAP
	TCB : REF BLOCK [,BYTE];

    STATUS = SCR$$GET_TYPE_R3 (SCR$C_DOWN_SCROLL; TCB, TERM_TYPE);	
					! get current control block,
    IF NOT .STATUS OR .TCB [SCR$B_TYPE] EQL VTFOREIGN
    THEN RETURN .STATUS;

    TCB [SCR$L_LINE] = .TCB [SCR$L_LINE] - 1;
    IF .TCB [SCR$L_LINE] LEQ 0
    THEN
	TCB [SCR$L_LINE] = 1;		! limit cursor to line 1

    IF .TCB [SCR$L_CHARMAP] NEQ 0 AND
       .TCB [SCR$L_BUFFER] NEQ 0
    THEN
	RETURN (SS$_NORMAL);		! do nothing if mapping active and
					!  buffering enabled

    DOWN_BUF [DSC$B_DTYPE] = DSC$K_DTYPE_T;
    DOWN_BUF [DSC$B_CLASS] = DSC$K_CLASS_S;

    CASE .TERM_TYPE FROM UNKNOWN TO VT100 OF 
	SET
	[UNKNOWN] : 
	    BEGIN
	    DOWN_BUF [DSC$W_LENGTH] = 0;
	    DOWN_BUF [DSC$A_POINTER] = 0;
	    END;

	[VT05] :
	    BEGIN
	    DOWN_BUF [DSC$W_LENGTH] = %CHARCOUNT (VT05_DOWN);
	    DOWN_BUF [DSC$A_POINTER] = UPLIT (BYTE (VT05_DOWN));
	    END;

	[VT52] :
	    BEGIN
	    DOWN_BUF [DSC$W_LENGTH] = %CHARCOUNT (VT52_DOWN);
	    DOWN_BUF [DSC$A_POINTER] = UPLIT (BYTE (VT52_DOWN));
	    END;

	[VT100] :
	    BEGIN
	    DOWN_BUF [DSC$W_LENGTH] = %CHARCOUNT (VT100_DOWN);
	    DOWN_BUF [DSC$A_POINTER] = UPLIT (BYTE (VT100_DOWN));
	    END;

	TES;

    RETURN (STATUS = OUTPUT (.TCB, DOWN_BUF)); 	
					! output sequence for this terminal type

    END;				! End of routine SCR$DOWN_SCROLL
!<BLF/PAGE>

%SBTTL 'SCR$ERASE - Obsolete version of SCR$ERASE_PAGE'
! GLOBAL ROUTINE SCR$ERASE =
!
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is obsolete and should not be called.  It is still
!	defined because its entry cannot be removed from SCRVECTOR.
!
! CALLING SEQUENCE:
!
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	SS$_NORMAL	Normal successful completion
!
! SIDE EFFECTS:
!
!	NONE
!--

!+
! Equate to current entry point.
!-

GLOBAL BIND ROUTINE SCR$ERASE = SCR$ERASE_PAGE ;
!<BLF/PAGE>

%SBTTL 'SCR$ERASE_LINE - Erase Line'
GLOBAL ROUTINE SCR$ERASE_LINE (
				LINE_NO : WORD,
				COL_NO : WORD
			      ) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine causes the screen to be erased from the specified
!	position to the end of the line.  If the position is not
!	specified, the current screen position is assumed.
!
! CALLING SEQUENCE:
!
!	ret_status.wlc.v = SCR$ERASE_LINE ([LINE_NO.rw.v,
!					   COL_NO.rw.v])
!
! FORMAL PARAMETERS:
!
!	LINE_NO.rw.v	Optional.  Line number where erasing starts.
!			If this argument is omitted, COL_NO is ignored
!			as well, and current position will be used.
!
!	COL_NO.rw.v	Optional.  Column number where erasing starts.
!			If this argument is omitted, LINE_NO is ignored
!			as well, and current position will be used.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	SS$_NORMAL	Normal successful completion
!
! SIDE EFFECTS:
!
!	NONE
!--

    BEGIN

    BUILTIN
	ACTUALCOUNT,
	ACTUALPARAMETER ;

MACRO
    VT05_LINE =  %STRING (%CHAR(VT05_EOL), %CHAR(NULL), %CHAR(NULL))%,	! VT05 (w/fill)
    VT52_LINE =  %STRING (%CHAR(ESC), %CHAR(VT52_EOL))%,	! VT52
    VT100_LINE =  %STRING (%CHAR(ESC), %CHAR(LB), %CHAR(VT100_EOL))%; ! VT100

    LITERAL
	K_CURSOR_ARGS = 2,		! 2 args if line_no & col_no present
	K_LINE_SIZ = 25;		! size for erase line seq buffer
					!  ***** known sequences will not
					!  ***** exceed this size.  in the
					!  ***** future it may be necessary
					!  ***** to increase this.

    LOCAL
	TERM_TYPE,			! terminal type
	TCB,				! ptr to terminal control block
	STATUS;				! status retd by called routines
    MAP
	TCB : REF BLOCK [,BYTE];

    STATUS = SCR$$GET_TYPE_R3 (SCR$C_ERASE_LINE; TCB, TERM_TYPE);	
					! get current TCB
    IF NOT .STATUS OR .TCB [SCR$B_TYPE] EQL VTFOREIGN 
    THEN RETURN (.STATUS);

    !+
    ! If mapping is active, just clear the character and attribute maps.
    ! If mapping is inactive, set the cursor (if line_no and col_no
    ! were specified) and output the erase line sequence.
    !-

    IF .TCB [SCR$L_CHARMAP] NEQ 0	! mapping active
    THEN
	BEGIN
	IF ACTUALCOUNT () EQL K_CURSOR_ARGS
	THEN
	    BEGIN			! reset cursor pos if line, col spec
	    TCB [SCR$L_LINE] = .LINE_NO;
	    TCB [SCR$L_COLUMN] = .COL_NO;
	    END;
	FILL_MAP (.TCB,
		   .TCB [SCR$L_LINE],
		   .TCB [SCR$L_COLUMN],
		   .TCB [SCR$L_LINE],
		   .TCB [SCR$W_DEVWIDTH],
		   %C' ');	! fill maps with spaces
	TCB [SCR$L_ATTRMASK] = 0;	! clear OR'd attr mask
	RETURN (SS$_NORMAL);
	END
    ELSE				! mapping inactive
	BEGIN
	LOCAL
	    BUFFER : BLOCK [8, BYTE],	! dsc for buffer
	    CUR_BUF_SIZ : INITIAL (0),	! size of buffer
	    OUT_STATUS,			! status retd by OUTPUT
	    ERASE_LEN,			! length of erase sequence
	    ERASE_PTR,			! ptr to erase sequence
	    TEMP_BUF : VECTOR [K_LINE_SIZ, BYTE];! buffer to hold set cursor and
					!  erase page sequences  

	BUFFER [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	BUFFER [DSC$B_CLASS] = DSC$K_CLASS_S;
	BUFFER [DSC$A_POINTER] = TEMP_BUF;
	!+
	! Set cursor only if line_no and col_no were specified.
	! Otherwise just default to current cursor position.
	!-
	IF ACTUALCOUNT () EQL K_CURSOR_ARGS
	THEN
	    BEGIN
	    STATUS = SET_CURSOR (.TCB, .LINE_NO, .COL_NO,
				.BUFFER [DSC$A_POINTER], CUR_BUF_SIZ);
	    IF NOT .STATUS THEN RETURN (.STATUS);
	    END;

	CASE .TERM_TYPE FROM UNKNOWN TO VT100 OF
	    SET

	    [UNKNOWN]:
		BEGIN	
		ERASE_LEN = 0;
		ERASE_PTR = 0;
		END;

	    [VT05]:
		BEGIN
		ERASE_LEN = %CHARCOUNT (VT05_LINE);
		ERASE_PTR = UPLIT ( BYTE (VT05_LINE));
		END;

	    [VT52]:
		BEGIN
		ERASE_LEN = %CHARCOUNT (VT52_LINE);
		ERASE_PTR = UPLIT (BYTE (VT52_LINE));
		END;

	    [VT100]:
		BEGIN
		ERASE_LEN = %CHARCOUNT (VT100_LINE);
		ERASE_PTR = UPLIT (BYTE (VT100_LINE));
		END;

	    TES;

	CH$MOVE (.ERASE_LEN, 
		 .ERASE_PTR, .BUFFER [DSC$A_POINTER] + .CUR_BUF_SIZ);
					! append erase seq to set cursor seq
	BUFFER [DSC$W_LENGTH] = .ERASE_LEN + .CUR_BUF_SIZ;
					! update length of buffer
	OUT_STATUS = OUTPUT (.TCB, BUFFER);
	
	IF NOT .OUT_STATUS THEN RETURN (.OUT_STATUS);

	RETURN (SS$_NORMAL);

	END;

    END;				! End of routine SCR$ERASE_LINE
!<BLF/PAGE>

%SBTTL 'SCR$ERASE_PAGE - Erase Page'
GLOBAL ROUTINE SCR$ERASE_PAGE (
				LINE_NO : WORD,
				COL_NO  : WORD
			      ) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine causes the screen to be erased from the specified
!	position to the end of the screen.  If the position is not
!	specified, the current screen position is assumed.
!
! CALLING SEQUENCE:
!
!	ret_status.wlc.v = SCR$ERASE_PAGE ([LINE_NO.rw.v,
!					   COL_NO.rw.v])
!
! FORMAL PARAMETERS:
!
!	LINE_NO.rw.v	Optional.  Line number at which to start
!			erasing.  If omitted, COL_NO will be ignored
!			as well and current cursor position will
!			be used.
!
!	COL_NO.rw.v	Optional.  Column number at which to start
!			erasing.  If omitted, LINE_NO will be ignored
!			as well and current cursor position will
!			be used.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	SS$_NORMAL	Normal successful completion
!
! SIDE EFFECTS:
!
!	NONE
!--

    BEGIN

    BUILTIN
	ACTUALCOUNT,
	ACTUALPARAMETER ;

MACRO
    VT05_ERASE =  %STRING ( %CHAR(VT05_EOS), %CHAR(NULL), %CHAR(NULL), %CHAR(NULL), %CHAR(NULL) )%, ! VT05 (w/fill)
    VT52_ERASE =  %STRING (%CHAR(ESC), %CHAR(VT52_EOS))%, ! VT52
    VT100_ERASE =  %STRING (%CHAR(ESC), %CHAR(LB), %CHAR(VT100_EOS))%; ! VT100

    LITERAL
	K_CURSOR_ARGS = 2,		! 2 args if line_no & col_no present
	K_ERASE_SIZ = 25;		! size for erase_page seq buffer
					!  **** this buffer is large enough
					!  **** to hold currently known 
					!  **** sequences.  in the future, it
					!  **** may have to be expanded.

    LOCAL
	TERM_TYPE,			! terminal type
	TCB,				! ptr to terminal control block
	STATUS;				! status retd by called routines
    MAP
	TCB : REF BLOCK [,BYTE];

    STATUS = SCR$$GET_TYPE_R3 (SCR$C_ERASE_PAGE; TCB, TERM_TYPE);	
					! get current TCB
    IF NOT .STATUS OR .TCB [SCR$B_TYPE] EQL VTFOREIGN 
    THEN RETURN (.STATUS);

    !+
    ! If mapping is active, just clear the character and attribute maps.
    ! If mapping is inactive, set the cursor (if line_no and col_no
    ! were specified) and output the erase page sequence.
    !-

    IF .TCB [SCR$L_CHARMAP] NEQ 0	! mapping active
    THEN
	BEGIN
	IF ACTUALCOUNT () EQL K_CURSOR_ARGS
	THEN
	   BEGIN			! store new cursor pos if line, col spec
	   TCB [SCR$L_LINE] = .LINE_NO;
	   TCB [SCR$L_COLUMN] = .COL_NO;
	   END;
	FILL_MAP (.TCB,
		   .TCB [SCR$L_LINE],
		   .TCB [SCR$L_COLUMN],
		   .TCB [SCR$W_DEVPAGSIZ],
		   .TCB [SCR$W_DEVWIDTH],
		   %C' ');	! fill maps with spaces
	TCB [SCR$L_ATTRMASK] = 0;	! clear OR'd attr mask
	RETURN (SS$_NORMAL);
	END
    ELSE				! mapping inactive
	BEGIN
	LOCAL
	    BUFFER : BLOCK [8, BYTE],	! dsc for buffer
	    CUR_BUF_SIZ : INITIAL (0),	! size of buffer
	    OUT_STATUS,			! status retd by OUTPUT
	    ERASE_LEN,			! length of erase sequence
	    ERASE_PTR,			! ptr to erase sequence
	    TEMP_BUF : VECTOR [K_ERASE_SIZ, BYTE];! buffer to hold erase_page sequence

	BUFFER [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	BUFFER [DSC$B_CLASS] = DSC$K_CLASS_S;
	BUFFER [DSC$A_POINTER] = TEMP_BUF;

	!+
	! Set cursor only if line_no and col_no were specified.
	! Otherwise just default to current cursor position.
	!-
	IF ACTUALCOUNT () EQL K_CURSOR_ARGS
	THEN
	    BEGIN
	    STATUS = SET_CURSOR (.TCB, .LINE_NO, .COL_NO,
				.BUFFER [DSC$A_POINTER], CUR_BUF_SIZ);
	    IF NOT .STATUS THEN RETURN (.STATUS);
	    END;
	CASE .TERM_TYPE FROM UNKNOWN TO VT100 OF
	    SET

	    [UNKNOWN]:
		BEGIN	
		ERASE_LEN = 0;
		ERASE_PTR = 0;
		END;

	    [VT05]:
		BEGIN
		ERASE_LEN = %CHARCOUNT (VT05_ERASE);
		ERASE_PTR = UPLIT (BYTE (VT05_ERASE));
		END;

	    [VT52]:
		BEGIN
		ERASE_LEN = %CHARCOUNT (VT52_ERASE);
		ERASE_PTR = UPLIT (BYTE (VT52_ERASE));
		END;

	    [VT100]:
		BEGIN
		ERASE_LEN = %CHARCOUNT (VT100_ERASE);
		ERASE_PTR = UPLIT ( BYTE (VT100_ERASE));
		END;

	    TES;

	CH$MOVE (.ERASE_LEN, 
		 .ERASE_PTR, .BUFFER [DSC$A_POINTER] + .CUR_BUF_SIZ);
					! append erase seq to set cursor seq
	BUFFER [DSC$W_LENGTH] = .ERASE_LEN + .CUR_BUF_SIZ;
					! update length of buffer
	OUT_STATUS = OUTPUT (.TCB, BUFFER);
	
	IF NOT .OUT_STATUS THEN RETURN (.OUT_STATUS);

	RETURN (SS$_NORMAL);
	END;

    END;				! End of routine SCR$ERASE_PAGE
!<BLF/PAGE>

%SBTTL 'SCR$PUT_BUFFER - Put Current Buffer to Screen or Prev. Buffer'
GLOBAL ROUTINE SCR$PUT_BUFFER (
				OLD_BUFFER 
			      ) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is the converse of SCR$SET_BUFFER.  It puts the
!	contents of the current buffer to another buffer or the screen
!	if no buffer is given.
!
! CALLING SEQUENCE:
!
!	ret_status.wlc.v = SCR$PUT_BUFFER ([OLD_BUFFER.rv.r])
!
! FORMAL PARAMETERS:
!
!	OLD_BUFFER.rv.r		Optional.  Address of the previous
!				buffer to put the current buffer into.
!				If not specified or zero, put current
!				buffer to the screen.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	SS$_NORMAL	Normal successful completion
!
! SIDE EFFECTS:
!
!	The current buffer is output and reintialized to empty.  If
!	OLD_BUFFER is nonzero, it is established to become the new 
!	current buffer.
!--

    BEGIN

    BUILTIN
	NULLPARAMETER;

    LOCAL
	STATUS,			! Status to be returned to caller

	CURR_BUFF : REF BLOCK [, BYTE], ! Current contents of 
					! TCB [SCR$L_BUFFER]

	ADDR,			! Address of newly-specified buffer or
				! zero (indicating no further buffering)

	TERM_TYPE,		! dummy parameter - not used

	TCB : REF BLOCK [, BYTE] ;	! Pointer to current terminal
					! control block

    STATUS = SCR$$GET_TYPE_R3 (-1; TCB, TERM_TYPE) ;		
				! Set up TCB address
    IF NOT .STATUS 		! -1 request - foreign terminal handler
				! doesn't do this one
    THEN RETURN (.STATUS);

!+
! Determine future buffer address.  It will be either the user-specified
! buffer address or zero.
!-
    ADDR = (IF NOT NULLPARAMETER (1)
		THEN ..OLD_BUFFER
		ELSE 0 ) ;

!+
! Save the buffer address currently active.
!-
    CURR_BUFF = .TCB [SCR$L_BUFFER] ;

!+
! Save the future buffer address in the terminal control block
!-
    TCB [SCR$L_BUFFER] = .ADDR ;

!+
! If buffering was turned off, don't limit future output to buffered size.
!-
    IF .ADDR EQL 0
    THEN
	TCB [SCR$L_BUFSIZ] = BUFSIZE;

!+
! If there was no prior buffer, there is nothing to flush to the screen
!-
    IF .CURR_BUFF EQL 0
    THEN
	RETURN (SS$_NORMAL) ;

!+
! There previously was some buffering in effect, decide whether to
! flush it to the screen or move it into the newly-specified buffer.
!-
    IF .TCB [SCR$L_CHARMAP] NEQ 0
    THEN
	BEGIN	! Mapping in effect
	STATUS = SS$_NORMAL ;	! Assume success to follow
	IF .ADDR EQL 0
	THEN
	    BEGIN	! Buffering no longer in effect
	    STATUS = PUT_MAP ( .TCB) ;	! Flush out what we've got
	    END;	! Buffering no longer in effect
	END	! Mapping in effect
    ELSE
	BEGIN	! No mapping in effect
	LOCAL
	    LOC_DESC : BLOCK [8, BYTE];
	!+
	! Build a descriptor describing current contents of buffer
	!-
	LOC_DESC [DSC$W_LENGTH] = .CURR_BUFF [DSC$W_LENGTH] ;
	LOC_DESC [DSC$B_CLASS] = DSC$K_CLASS_S ;
	LOC_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T ;
	LOC_DESC [DSC$A_POINTER] = .CURR_BUFF [DSC$A_POINTER] ;

	!+
	! Reset buffer control block to make it look empty.
	!-
	CURR_BUFF [DSC$W_LENGTH] = 0 ;

	!+
	! Output to previous buffer (or screen if TCB now contains 0)
	!-
	STATUS = OUTPUT ( .TCB, LOC_DESC ) ;
	END;	! No mapping in effect

    RETURN (.STATUS);
    END;				! End of routine SCR$PUT_BUFFER
!<BLF/PAGE>

%SBTTL 'SCR$PUT_LINE - Put Text to Screen in Line Mode'
GLOBAL ROUTINE SCR$PUT_LINE (
			     TEXT     : REF BLOCK [,BYTE],
			     LINE_ADV,
			     FLAGS
			    ) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is used to write messages to the terminal
!	followed by cursor movement sequences.
!
! CALLING SEQUENCE:
!
!	ret_status.wlc.v = SCR$PUT_LINE (TEXT.rt.dx
!					 [,LINE_ADV.rl.v,
!					 [,FLAGS.rl.v])
!
! FORMAL PARAMETERS:
!
!	TEXT.rt.dx	Address of descriptor of output string.
!
!	LINE_ADV.rl.v	Optional.  Signed number of lines to advance
!			after output.
!
!	FLAGS.rl.v	Optional.  Rendition codes.
!			If omitted, SCR$M_NORMAL will be used.
!			Values:
!			    SCR$M_BLINK      display characters blinking.
!			    SCR$M_BOLD       display characters in
!					     higher-than-normal intensity.
!			    SCR$M_NORMAL     display characters using
!					     rendition associated with
!					     window.
!			    SCR$M_REVERSE    display characters in reverse
!					     video -- i.e., using opposite
!					     rendition from window default.
!			    SCR$M_UNDERLINE  display characters underlined.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	SS$_NORMAL	Normal successful completion
!
! SIDE EFFECTS:
!
!	NONE
!--

    BEGIN

    BUILTIN
	ACTUALCOUNT;

    MACRO
	VT05_CR = %STRING (%CHAR (CR))%,
	VT52_CR = %STRING (%CHAR (CR))%,
	VT100_CR = %STRING (%CHAR (CR))%;

    LITERAL
	K_LINE_ARG = 2,			! line_adv is arg 2 if present
	K_MAX_ARGS = 3;			! 3 args if all present

    LOCAL
	TERM_TYPE,			! either type or devtyp from TCB
	STATUS,				! status retd from called routine
	TCB,				! ptr to terminal control block
	TMP_LINE_ADV,			! temp loc for line advance
 	TMP_FLAGS;			! temp loc for rendition flags

    MAP
	TCB : REF BLOCK [,BYTE];

    !+
    ! Save the terminal type from the Terminal Control Block based on
    ! whether this is a DEC terminal or foreign terminal.
    !-

    STATUS = SCR$$GET_TYPE_R3 (SCR$C_PUT_LINE; TCB, TERM_TYPE);	
					! get current TCB
    IF NOT .STATUS OR .TCB [SCR$B_TYPE] EQL VTFOREIGN
    THEN RETURN (.STATUS);

    !+
    ! Validate the number of arguments passed.
    !-

    IF ACTUALCOUNT () EQL 0 OR
       ACTUALCOUNT () GTRU K_MAX_ARGS
    THEN
	RETURN (LIB$_WRONUMARG);		

    IF ACTUALCOUNT () LSS K_MAX_ARGS
    THEN
	TMP_FLAGS = SCR$M_NORMAL	! 3rd arg omitted - use default
    ELSE
	TMP_FLAGS = .FLAGS;		! use caller's rendition codes

    IF ACTUALCOUNT () LSS K_LINE_ARG
    THEN
	TMP_LINE_ADV = 1		! 2nd arg omitted - use default
    ELSE
	TMP_LINE_ADV = .LINE_ADV;	! use caller's lines to advance

    !+
    ! Call SCR$PUT_SCREEN to output the text and then call SCR$UP_SCROLL
    ! or SCR$DOWN_SCROLL to position it.
    !-

    STATUS = SCR$PUT_SCREEN (.TEXT, 0, 0, .TMP_FLAGS);
    IF NOT .STATUS THEN RETURN (.STATUS);

    IF .TMP_LINE_ADV LSS 0
    THEN
	BEGIN
	INCR COUNTER FROM 1 TO (-.TMP_LINE_ADV) DO
	    BEGIN
	    STATUS = SCR$DOWN_SCROLL ();
   	    IF NOT .STATUS THEN RETURN (.STATUS);
	    END;
	END				! negative line adv - down scroll
    ELSE
	BEGIN
	INCR COUNTER FROM 1 TO .TMP_LINE_ADV DO
	    BEGIN
	    STATUS = SCR$UP_SCROLL ();
	    IF NOT .STATUS THEN RETURN (.STATUS);
	    END;
	END;				! positive line adv - scroll up    

    TCB [SCR$L_COLUMN] = 1;		! reset cursor to col 1

    !+
    ! Determine if a <CR> should be output.
    !-

    IF .TERM_TYPE NEQ 0 OR 		! known terminal
       .TCB [SCR$L_BUFFER] EQL 0	! buffering not enabled
    THEN
	BEGIN				! <CR> needed
	LOCAL
	    BUFFER : BLOCK [8, BYTE];	! buffer dsc for OUTPUT

    	BUFFER [DSC$B_DTYPE] = DSC$K_DTYPE_T;
    	BUFFER [DSC$B_CLASS] = DSC$K_CLASS_S;
    	BUFFER [DSC$W_LENGTH] = 1;
 
    	CASE .TERM_TYPE FROM UNKNOWN TO VT100 OF
	    SET

	    [UNKNOWN]:
	    	BEGIN
	    	BUFFER [DSC$W_LENGTH] = 0;
	    	BUFFER [DSC$A_POINTER] = 0;
	    	END;

	    [VT05]:
	     	BUFFER [DSC$A_POINTER] = UPLIT (BYTE (VT05_CR));

	    [VT52]:
	    	BUFFER [DSC$A_POINTER] = UPLIT (BYTE (VT52_CR));

	    [VT100]:
	    	BUFFER [DSC$A_POINTER] = UPLIT (BYTE (VT100_CR));

	    [INRANGE,OUTRANGE]:
	    	RETURN 0;		! should never get here

	    TES;

    	STATUS = OUTPUT (.TCB, BUFFER);	! output a <CR>
    	IF NOT .STATUS THEN RETURN (.STATUS);
	END;

    RETURN (SS$_NORMAL);
    END;				! End of routine SCR$PUT_LINE
!<BLF/PAGE>

%SBTTL 'SCR$PUT_SCREEN - Put Text to Screen'
GLOBAL ROUTINE SCR$PUT_SCREEN (
				TEXT    : REF BLOCK [,BYTE],
				LINE_NO,
				COL_NO,
				FLAGS  
			      ) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is used to write messages to the terminal.
!
! CALLING SEQUENCE:
!
!	ret_status.wlc.v = SCR$PUT_SCREEN (TEXT.rt.dx
!					   [,LINE_NO.rl.v, 
!					   COL_NO.rl.v] 
!					   [,FLAGS.rl.v])
!
! FORMAL PARAMETERS:
!
!	TEXT.rt.dx	Address of descriptor of output string.
!
!	LINE_NO.rl.v	Optional.  Line number at which to start output.
!			If omitted (=0), the current line number is
!			used.
!
!	COL_NO.rl.v	Optional.  Column number at which to start
!			output.  If omitted (=0), the current line
!			number is used.
!
!	FLAGS.rl.v	Optional.  Rendition codes.
!			If omitted, SCR$M_NORMAL will be used.
!			Values:
!			    SCR$M_BLINK  	display characters blinking.
!			    SCR$M_BOLD  	display characters in
!					  	higher-than-normal intensity.
!			    SCR$M_NORMAL  	display characters using
!					  	rendition associated with
!					  	window.
!			    SCR$M_REVERSE  	display characters in reverse
!					  	video -- i.e., using opposite
!					  	rendition from window default.
!			    SCR$M_UNDERLINE  	display characters underlined.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	SS$_NORMAL	Normal successful completion
!
! SIDE EFFECTS:
!
!	NONE
!--

    BEGIN

    BUILTIN
	ACTUALCOUNT,
	ACTUALPARAMETER,
	NULLPARAMETER;

!+
! $SCR_APPEND
! Macro $SCR_APPEND appends the specified source string into the specified
! output buffer.  It assumes that IN_POINTER points into a buffer 
! BUFFER whose overall length is .TCB [SCR$L_BUFSIZ]
! It appends as much of the input string as will fit, and updates
! the buffer pointer by the number of bytes moved.
!-
MACRO
    $SCR_APPEND ( IN_LENGTH, IN_POINTER, OUT_POINTER) =
    BEGIN
    LOCAL
	AMT_TO_MOVE;	! No. bytes that will fit

    AMT_TO_MOVE = IN_LENGTH ;	! Assume all will fit

    !+
    ! If space remaining is less than space needed, limit move to 
    ! amount that left.
    !-
    IF .TCB [SCR$L_BUFSIZ] - (.OUT_POINTER - .BUFFER)  ! space remaining
	LSS IN_LENGTH				   ! space needed
    THEN
	AMT_TO_MOVE = MAX (0, .TCB [SCR$L_BUFSIZ] - (.OUT_POINTER - .BUFFER));
				! don't allow a negative length

    CH$MOVE ( .AMT_TO_MOVE,	! length
	      IN_POINTER,	! source addr
	      .OUT_POINTER);	! dest. addr

    OUT_POINTER = .OUT_POINTER + .AMT_TO_MOVE ; ! Advance pointer
    END;
% ;	! End of macro $SCR_APPEND

    LOCAL
	TCB : REF BLOCK [, BYTE],	! Pointer to current terminal
					! control block
	TYPE,				! device type
	STATUS,				! Status to return to caller
	LOC_DESC : BLOCK [8, BYTE];	! Local descriptor

!+
! Set up pointer to current terminal control block
!-
    STATUS = SCR$$GET_TYPE_R3 (SCR$C_PUT_SCREEN; TCB, TYPE) ;
    IF NOT .STATUS OR .TCB [SCR$B_TYPE] EQL VTFOREIGN
    THEN RETURN (.STATUS);

!+
! See if mapping or buffering is in effect
!-
    IF .TCB [SCR$L_CHARMAP] EQL 0  OR	! If no mapping
       .TCB [SCR$L_BUFFER]  EQL 0	! or no buffering
    THEN
	BEGIN	! No buffering or no mapping or neither

	IF ACTUALCOUNT() EQL 1
	THEN
	    BEGIN	! Only 1 arg
	    LOCAL
		LOC_DESC : BLOCK [8, BYTE];	! Local descriptor
	    !+
	    ! Extract length and address of callers text.  If descriptor
	    ! has unrecognized class code, quit.  Otherwise, build
	    ! local fixed-length descriptor to describe text string
	    ! to OUTPUT for outputing.
	    !-
	    IF NOT ( STATUS = LIB$ANALYZE_SDESC_R2 (!Get len. and addr
					.TEXT;
					LOC_DESC [DSC$W_LENGTH],
					LOC_DESC [DSC$A_POINTER]))
	    THEN
		RETURN (.STATUS );

	    !+
	    ! Complete descriptor and do output
	    !-
	    LOC_DESC [DSC$B_CLASS] = DSC$K_CLASS_S ;
	    LOC_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T ;

	    STATUS = OUTPUT ( .TCB, LOC_DESC ) ;
	    END		! Only 1 arg
	ELSE
	    BEGIN	! More than one arg 
	    LOCAL
		LENGTH,			! Length of callers text string
		ADDR,			! Address of callers text string
		BUFFER   : REF BLOCK [, BYTE],	! Pointer to allocated
						! buffer
		BUF_PTR,			! Pointer into BUFFER
						! as it is filled
		ATTR_GIVEN;			! Flag to record
						! whether an attribute
						! setting was placed in
						! the buffer and a "turn
						! off graphic" rendition
						! needs to be inserted
						! at the end of buffer.
	    IF NOT (STATUS = LIB$GET_VM ( TCB [SCR$L_BUFSIZ], ! length
					  BUFFER))	! returned addr
	    THEN
		RETURN (.STATUS ) ;

	    BUF_PTR = .BUFFER ; ! Initialize to front of buffer

	    ATTR_GIVEN = 0;	! Assume we won't be outputing
				! attribute sequence.
	    IF NOT NULLPARAMETER (4)	! FLAGS present
	    THEN
		BEGIN	! Flags present

		CASE .TYPE FROM UNKNOWN TO VTFOREIGN OF
		SET
		    [UNKNOWN,
		     VT05,
		     VT52,
		     VTFOREIGN]: 
			0 ;	! Do nothing

		    [INRANGE, OUTRANGE]:
			RETURN ( LIB$_FATERRLIB ) ;

		    [VT100]:
			BEGIN	! VT100 processing
			!+
			! Make sure MBZ bits in high end of longword
			! are in fact zero.
			!-
			IF .FLAGS<16,16> NEQ 0
			THEN
			    RETURN ( LIB$_INVARG); ! Undefined bits set

			IF .FLAGS<0,4> NEQ 0
			THEN
			    BEGIN	! Attributes set
			    ATTR_GIVEN = 1 ; ! Record that we will be
					     ! outputing attribute
					     ! escape sequence
			    CH$WCHAR_A ( ESC, BUF_PTR) ;
			    CH$WCHAR_A ( LB,  BUF_PTR) ;
			    !+
			    ! For each attribute bit set in the flags
			    ! parameter, copy the appropriate ASCII 
			    ! graphic rendition byte followed by a ";"
			    ! into our temporary buffer BUFFER.
			    ! Note use of autoincrementing.
			    !-
			    INCR I FROM 0 TO 3
			    DO
				BEGIN	! Build attribute string
				BIND ATTRTABL = UPLIT ( BYTE ( '1754'))
						: VECTOR [4, BYTE];
				IF .FLAGS<.I, 1> 
				THEN
				    BEGIN
				    CH$WCHAR_A ( .ATTRTABL [.I], 
						 BUF_PTR);
				    CH$WCHAR_A ( %C';', BUF_PTR);
				    END;
				END;	! Build attribute string
			    !+
			    ! When we fall out of loop above we have
			    ! deposited an extra ";" at the end of the
			    ! buffer.  Back up BUF_PTR so that deposit
			    ! of VT100_SGR lands on top of it.
			    !-
			    BUF_PTR = .BUF_PTR - 1 ;
			    CH$WCHAR_A ( VT100_SGR, BUF_PTR) ;

			    END;	! Attributes set
			END;	! VT100 processing
		TES;
		END;	! Flags present

	    !+
	    ! If cursor position was specified on call,
	    ! invoke SET_CURSOR to get us there.
	    !-
	    IF NOT NULLPARAMETER (2)
	    THEN
		BEGIN
		LOCAL
		    RET_LEN : INITIAL (0);
		SET_CURSOR ( .TCB, .LINE_NO, .COL_NO, .BUF_PTR, RET_LEN );
		BUF_PTR = .BUF_PTR + .RET_LEN;
		END;

	    IF NOT ( STATUS = LIB$ANALYZE_SDESC_R2 ( .TEXT;
						     LENGTH,
						     ADDR))
	    THEN
		RETURN ( .STATUS ) ;

	    !+
	    ! Insert callers text
	    !-
	    $SCR_APPEND ( .LENGTH, .ADDR, BUF_PTR) ;

	    IF .ATTR_GIVEN
	    THEN
		BEGIN	! Insert VT100_OFF
		MACRO
		    VT100_OFF = %STRING ( %CHAR(ESC), %CHAR(LB), '0m')%;
		$SCR_APPEND ( %CHARCOUNT   ( VT100_OFF ),
			  UPLIT ( BYTE ( VT100_OFF )),
			  BUF_PTR) ;

		END;	! Insert VT100_OFF

	    !+
	    ! Build local descriptor referencing the intermediate buffer
	    ! we've been contructing and output it.
	    !-
	    LOC_DESC [DSC$W_LENGTH] = .BUF_PTR - .BUFFER;
	    LOC_DESC [DSC$B_CLASS]  = DSC$K_CLASS_S ;
	    LOC_DESC [DSC$B_DTYPE]  = DSC$K_DTYPE_T ;
	    LOC_DESC [DSC$A_POINTER] = .BUFFER;
	    STATUS = OUTPUT ( .TCB,  LOC_DESC ) ;

	    !+
	    ! Give back buffer space we've been using
	    !-
	    LIB$FREE_VM ( TCB [SCR$L_BUFSIZ], BUFFER );
					
	    END;	! More than one arg 
		
	END	! No buffering or no mapping or neither

    ELSE

	BEGIN	! Buffering and mapping active
	LOCAL
	    LENGTH,	! Length of callers string
	    ADDR,	! Address of callers string
	    INDEX,	! Linear index into character buffer
	    CURR_LINE,	! Line at which to set cursor
	    CURR_COL;   ! Column at which to set cursor
	!+
	! Set up cursor arguments.  Assume the ones from the TCB but
	! overwrite if user has specified.
	!-
	CURR_LINE = .TCB [SCR$L_LINE] ;
	CURR_COL  = .TCB [SCR$L_COLUMN] ;
	IF NOT NULLPARAMETER (2) AND	! If line_no supplied
	   NOT NULLPARAMETER (3)	! and col_no supplied
	THEN
	    BEGIN	! User-supplied cursor position
	    CURR_LINE = .LINE_NO ;
	    CURR_COL = .COL_NO ;
	    !+
	    ! Reset cursor position in TCB to new values.
	    !-
	    TCB [SCR$L_LINE] = .LINE_NO ;
	    TCB [SCR$L_COLUMN] = .COL_NO ;
	    END;	! User-supplied cursor position

	!+
	! If specified starting line is beyond the bottom of the
	! screen, quit immediately, but call it a success.
	!-

	IF .CURR_LINE GTR .TCB [SCR$W_DEVPAGSIZ]
	THEN
	    RETURN ( SS$_NORMAL ) ;

	!+
	! Calculate zero-based linear index into buffer
	!-
	INDEX = (.CURR_LINE - 1) * .TCB [SCR$W_DEVWIDTH] +
		(.CURR_COL  - 1) ;

	!+
	! Extract length and address of callers text string.  If
	! unrecognized class of descriptor, quit.
	!-
	IF NOT (STATUS = LIB$ANALYZE_SDESC_R2 ( .TEXT; LENGTH, ADDR))
	THEN
	    RETURN ( .STATUS) ;

	!+
	! If length of users text reaches beyond end of buffer, quit
	!-
	IF .LENGTH + .INDEX GTR .TCB [SCR$L_AREA]
	THEN
	    RETURN ( LIB$_SCRBUFOVF );


	TCB [SCR$L_COLUMN] = .TCB [SCR$L_COLUMN] + .LENGTH ; !***???***

	!+
	! Move users text into mapping buffer
	!-
	CH$MOVE ( .LENGTH, .ADDR, .TCB [SCR$L_CHARMAP] + .INDEX ) ;

	!+
	! Check for attributes for this text and set up our attribute
	! mask.
	!-

	TCB [SCR$L_ATTRMASK] = .TCB [SCR$L_ATTRMASK] OR
				(IF ACTUALCOUNT () EQL 4 ! flag arg passed
				 THEN 
				    (NOT (.TCB [SCR$L_DEVCHAR])) AND .FLAGS
				 ELSE
				     SCR$M_NORMAL);

	!+
	! If any attributes turned on, fill them into the attribute map
	!-
	IF .TCB [SCR$L_ATTRMASK] NEQ 0
	THEN
	    CH$FILL ( (IF ACTUALCOUNT () EQL 4
		       THEN .FLAGS
		       ELSE SCR$M_NORMAL),		! Fill char
		      .LENGTH,				! No. of bytes
		      .TCB [SCR$L_ATTRMAP] + .INDEX) ;	! Dest. address

  	STATUS = SS$_NORMAL ;
	END;	! Buffering and mapping active

    RETURN (SS$_NORMAL);
    END;				! End of routine SCR$PUT_SCREEN
!<BLF/PAGE>

%SBTTL 'SCR$SET_BUFFER - Set/Clear Buffer Mode'
GLOBAL ROUTINE SCR$SET_BUFFER (
				BUFFER     : REF BLOCK [,BYTE],
				OLD_BUFFER : REF VECTOR [,LONG]
			      ) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is called to establish a buffer to be used to hold
!	terminal output rather than immediately writing the output to
!	SYS$OUTPUT.  It is also called to turn off the buffering mode.
!	The buffer address is established such that all screen output
!	is appended to the end of the buffer.
!
! CALLING SEQUENCE:
!
!	ret_status.wlc.v = SCR$SET_BUFFER (BUFFER.mt.dx
!					   [,OLD_BUFFER.wl.r])
!
! FORMAL PARAMETERS:
!
!	BUFFER.mt.dx	Address of descriptor of buffer.  If 0,
!			buffering mode is turned off.
!
!	OLD_BUFFER.wl.r Optional. Address of the location which will
!			contain the address of the previous buffer. 
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	SS$_NORMAL	Normal successful completion
!
! SIDE EFFECTS:
!
!	NONE
!--

    BEGIN

    BUILTIN
	ACTUALCOUNT,
	ACTUALPARAMETER,
	NULLPARAMETER;

    LOCAL
	TCB : REF BLOCK [, BYTE], 	! Pointer to current terminal
					! control block.
	TERM_TYPE,			! dummy parameter - device type
	STATUS;

    LITERAL
	K_MAX_ARGS = 2;			! # of args if all present

!+
! Get current device type and set up our pointer to the terminal
! control block.
!-
    STATUS = SCR$$GET_TYPE_R3 (-1; TCB, TERM_TYPE) ;
				! -1 request - foreign terminal handler
				! doesn't do the action
    IF NOT .STATUS THEN RETURN (.STATUS);

!+
! If no arguments provided, error.
!-
    IF ACTUALCOUNT () LEQ 0 OR
       ACTUALCOUNT () GTR K_MAX_ARGS
    THEN
	RETURN ( LIB$_INVARG ) ;	! *** Should be LIB$_WRONUMARG

!+
! If 2nd parameter supplied, return current buffer address from TCB
! before changing it.
!-
    IF NOT NULLPARAMETER (2)
    THEN
	OLD_BUFFER [0] = .TCB [SCR$L_BUFFER] ;

!+
! See if a new buffer address is being provided, or whether caller is
! just cancelling buffering.
!-
    IF NOT NULLPARAMETER (1)
    THEN
	BEGIN		! New buffer descriptor address provided
	LOCAL
	    STATUS,	! Error status to return to caller if need be
	    LENGTH : WORD, ! Length of buffer provided by caller
	    ADDR : REF VECTOR [,LONG];	
			! Address of buffer provided by caller.  We 
			! declare it as a vector of longwords since
			! we need to write control information into the
			! 1st 3 longwords.  The rest of the screen 
			! routines think of it as a block of bytes.

	IF NOT (STATUS = LIB$ANALYZE_SDESC_R2 ( .BUFFER; LENGTH, ADDR ))
	THEN
	    RETURN (.STATUS) ;	! Bad descriptor class

	!+
	! Length of buffer provided must be greater than 12 bytes or
	! we can't really use it since we use the 1st 12 bytes to
	! store control information.
	!-
	IF .LENGTH LEQ 12
	THEN
	    RETURN ( LIB$_SCRBUFOVF ) ;	

	!+
	! Initialize control information at top of buffer provided.
	!-
	ADDR [0] = 0 ;		! Used length set to zero
	ADDR [1] = ADDR [3] ;	! Address of start of usable buffer area
				! beyond control information
	ADDR [2] = .LENGTH - 12 ;	! Adjust length of remaining
					! buffer
	TCB [SCR$L_BUFFER] = ADDR [0] ; ! Address of new buffer
	TCB [SCR$L_BUFSIZ] = .ADDR [2]; ! Save size of buffer used
	END		! New buffer descriptor address provided
    ELSE
	BEGIN		! Cancel buffering
	TCB [SCR$L_BUFFER] = 0 ;
	TCB [SCR$L_BUFSIZ] = BUFSIZE;
	END;		! Cancel buffering

    RETURN (SS$_NORMAL);
    END;				! End of routine SCR$SET_BUFFER
!<BLF/PAGE>

%SBTTL 'SCR$SET_CURSOR - Set Cursor to Character Position on Screen'
GLOBAL ROUTINE SCR$SET_CURSOR (
				LINE_NO : WORD,
				COL_NO  : WORD
			      ) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine causes the cursor to be moved to the specified
!	position.
!
! CALLING SEQUENCE:
!
!	ret_status.wlc.v = SCR$SET_CURSOR (LINE_NO.rw.v, COL_NO.rw.v)
!
! FORMAL PARAMETERS:
!
!	LINE_NO.rw.v	Line number.
!
!	COL_NO.rw.v	Column number.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	SS$_NORMAL	Normal successful completion
!
! SIDE EFFECTS:
!
!	NONE
!--

    BEGIN

    LITERAL
	K_CURSOR_SIZ = 20;		! size for cursor seq buffer
					!  **** more than large enough
					!  **** for currently known 
					!  **** sequences - may need
					!  **** to be bigger some day
    LOCAL
	STATUS,				! status retd by called routines
	BUFFER : BLOCK [8, BYTE],	! buffer dsc for OUTPUT
	TCB : REF BLOCK [,BYTE],	! ptr to Terminal Control Block
	TERM_TYPE,			! dummy parameter - device type
	CURSOR_BUF : VECTOR [K_CURSOR_SIZ, BYTE];! buffer for cursor sequence

    STATUS = SCR$$GET_TYPE_R3 (SCR$C_SET_CURSOR; TCB, TERM_TYPE);	
					! get current TCB
    IF NOT .STATUS OR .TCB [SCR$B_TYPE] EQL VTFOREIGN
    THEN RETURN (.STATUS);

    !+
    ! Just store new cursor position if mapping active.
    !-

    TCB [SCR$L_LINE] = .LINE_NO;
    TCB [SCR$L_COLUMN] = .COL_NO;

    IF .TCB [SCR$L_CHARMAP] NEQ 0
    THEN
	RETURN (SS$_NORMAL);		! ret if mapping active

    !+
    ! Put the appropriate set cursor sequence into the buffer
    !-

    BUFFER = 0 ; ! Preset 1st long word to zero, its used as a current
		 ! length in the call below.  Fill in class and dtype
		 ! later
    BUFFER [DSC$A_POINTER] = CURSOR_BUF [0];

    IF NOT (STATUS = SET_CURSOR (.TCB, .LINE_NO, .COL_NO, 
				 .BUFFER [DSC$A_POINTER], 
				 BUFFER [DSC$W_LENGTH]))

    THEN RETURN (.STATUS);

    !+
    ! Output the sequence.
    !-

    BUFFER [DSC$B_DTYPE] = DSC$K_DTYPE_T;
    BUFFER [DSC$B_CLASS] = DSC$K_CLASS_S;

    IF NOT (STATUS = OUTPUT (.TCB, BUFFER))
    THEN RETURN (.STATUS);

    RETURN (SS$_NORMAL);
    END;				! End of routine SCR$SET_CURSOR
!<BLF/PAGE>

%SBTTL 'SCR$SET_SCROLL - Establish Scrolling Region'
GLOBAL ROUTINE SCR$SET_SCROLL (
				START_LINE : WORD,
				END_LINE   : WORD
			      ) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine establishes a scrolling by setting the internal
!	scrolling region parameters.  Issues the escape sequence that
!	establishes the region and preserves the cursor position.
!
!	If this routine is called with no arguments, scrolling is turned
!	off by setting the scrolling region parameters to zeroes.
!
! CALLING SEQUENCE:
!
!	ret_status.wlc.v = SCR$SET_SCROLL ([START_LINE.rw.v, 
!					   END_LINE.rw.v])
!
! FORMAL PARAMETERS:
!
!	[START_LINE.rw.v]	Optional - First line of scrolling region.
!
!	[END_LINE.rw.v]		Optional - Last line of scrolling region.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	SS$_NORMAL	Normal successful completion
!
! SIDE EFFECTS:
!
!	NONE
!--

    BEGIN

    LITERAL
	K_ALL_ARGS = 2,			! # args if all present
	K_SCROLL_BUFSIZ = 25;		! size of buffer to hold
					!  set scroll sequence
					!  **** more than large enough for
					!  **** currently known sequences -
					!  **** may need to be increased
					!  **** later

    LOCAL
        SET_MARGINS : VECTOR [1, 8] INITIAL (
	    DSC$K_DTYPE_T ^24 + DSC$K_CLASS_S ^16 + 14,
	    UPLIT ( BYTE (ESC, '7', ESC, LB, '!UL;!UL', 
		    VT100_SM, ESC, '8' ))) ,
					! Dsc for VT100 seq to <save cursor>
					!   <establish scrolling region>
					!   <restore cursor>
	STATUS,				! status returned by a called routine
	BUFFER : BLOCK [8, BYTE],	! dsc for intermediate buffer
	TEMP_BUF : VECTOR [K_SCROLL_BUFSIZ, BYTE],! buffer for set scroll seq
	CVT_ARGS : VECTOR [2],		! holds FAO args to convert
	FAO_LEN : WORD,			! length output from FAO
	TERM_TYPE,			! dummy parameter - device type
	TCB;				! Terminal Control Block ptr

    MAP
	TCB : REF BLOCK [,BYTE];

    BUILTIN
 	ACTUALCOUNT;

    STATUS = SCR$$GET_TYPE_R3 (SCR$C_SET_SCROLL; TCB, TERM_TYPE);	
					! get current Terminal Control Block
    IF NOT .STATUS OR .TCB [SCR$B_TYPE] EQL VTFOREIGN
    THEN RETURN (.STATUS);

    !+
    ! Determine if scrolling region should be established.
    !-

    IF ACTUALCOUNT () GEQU K_ALL_ARGS
    THEN
	TCB [SCR$V_SCROLL] = 1		! set scrolling active if args passed
    ELSE
	TCB [SCR$V_SCROLL] = 0;		! scrolling inactive if no args passed

    IF .TCB [SCR$L_CHARMAP] NEQ 0 OR	! mapping active
       .TCB [SCR$B_TYPE] NEQU VT100 OR	! allow only VT100 terminals
       .SCR$AL_DEVDEPND2 [TT2$V_DECCRT] EQL 0
					! must a a dec_crt not just VT100 style
    THEN
	RETURN 1;

    !+
    ! Point a descriptor to the buffer which will hold the set scroll
    ! sequence.
    !-

    BUFFER [DSC$B_DTYPE] = DSC$K_DTYPE_T;
    BUFFER [DSC$B_CLASS] = DSC$K_CLASS_S;
    BUFFER [DSC$W_LENGTH] = K_SCROLL_BUFSIZ;
    BUFFER [DSC$A_POINTER] = TEMP_BUF;

    !+
    ! Call $FAO to convert START_LINE and END_LINE to ASCII.  Notice
    ! that the buffer we just allocated is empty, so the current length
    ! is 0 and the first free byte is the start address of the buffer.
    !-

    IF ACTUALCOUNT () GEQU K_ALL_ARGS
    THEN
	BEGIN
    	CVT_ARGS [0] = .START_LINE;
    	CVT_ARGS [1] = .END_LINE;
	END
    ELSE
	BEGIN				! default scrolling region if
	CVT_ARGS [0] = 0;		! no args passed
	CVT_ARGS [1] = 0;
	END;

    STATUS = $FAOL (CTRSTR = SET_MARGINS, OUTLEN = FAO_LEN,
			OUTBUF = BUFFER, PRMLST = CVT_ARGS);
    IF NOT .STATUS THEN RETURN (.STATUS);
    BUFFER [DSC$W_LENGTH] = .FAO_LEN;

    !+
    ! Output the scrolling sequence.
    !-

    IF .TCB [SCR$L_RTNADDR] EQL 0	! no user supplied routine
    THEN
	BEGIN				! cancel ctrl O
    	STATUS = $QIOW (EFN = .TCB [SCR$L_EFN], 
			CHAN = .TCB [SCR$W_CHAN],
			FUNC = (IO$_WRITEVBLK OR IO$M_CANCTRLO), 
			P1 = .BUFFER [DSC$A_POINTER],
			P2 = 0);	! buffer not really used
        IF NOT .STATUS THEN RETURN (.STATUS);
	END;

    STATUS = OUTPUT (.TCB, BUFFER); ! output buffer

    IF NOT .STATUS
    THEN
	RETURN (.STATUS)
    ELSE
	RETURN (SS$_NORMAL);

    END;				! End of routine SCR$SET_SCROLL
!<BLF/PAGE>

%SBTTL 'SCR$UP_SCROLL - Up Scroll, Move Cursor Down One Line'
GLOBAL ROUTINE SCR$UP_SCROLL =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine causes the cursor to be moved down 1 line to the
!	same column of the following line.  If the cursor was on the
!	bottom line to begin with, it stays where it was, but all the
!	information on the screen appears to move up one line.  The
!	information that was on the top line is lost and a blank line
!	appears at the bottom.
!
!	If a scrolling region is active ( on a VT100 or in mapping)
!	then the logic above applies to the top and bottom lines of
!	the scrolling region rather than the top and bottom line of
!	the screen.  If an UP_SCROLL is performed on the bottom line of
!	the screen, or a DOWN_SCROLL is performed on the top line of the
!	screen, while a scrolling region is active then no screen
!	movement takes place unless the top or bottom line of the screen
!	corresponds to the top or bottom line of the scrolling region.
!
! CALLING SEQUENCE:
!
!	ret_status.wlc.v = SCR$UP_SCROLL ()
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	SS$_NORMAL	Normal successful completion
!
! SIDE EFFECTS:
!
!	NONE
!--

    BEGIN

MACRO
	VT05_UPSCROLL = %STRING (%CHAR(LF), %CHAR(NULL), %CHAR(NULL), %CHAR(NULL))%, ! VT05 (w/fill)
	VT52_UPSCROLL = %STRING (%CHAR(LF))%,		! VT52
	VT100_UPSCROLL = %STRING (%CHAR(LF))%;		! VT100

    LOCAL
	STATUS,				! used for calls
	TCB,				! terminal control block
	UP_BUFF : BLOCK [8,BYTE],	! buffer dsc for OUTPUT
	TERM_TYPE;			! terminal type

    MAP
	TCB : REF BLOCK [,BYTE];

    STATUS = SCR$$GET_TYPE_R3 (SCR$C_UP_SCROLL; TCB, TERM_TYPE);	
					! get current control block,
    IF NOT .STATUS OR .TCB [SCR$B_TYPE] EQL VTFOREIGN
    THEN RETURN (.STATUS);

    !+
    ! Update cursor position with down movement.  Limit cursor to page.
    !-

    TCB [SCR$L_LINE] = MIN (.TCB [SCR$L_LINE] + 1,
			    .TCB [SCR$W_DEVPAGSIZ]);

    !+
    ! Do nothing if mapping active and buffering enabled.
    !-

    IF .TCB [SCR$L_CHARMAP] NEQ 0 AND
       .TCB [SCR$L_BUFFER] NEQ 0
    THEN
	RETURN (SS$_NORMAL);

    !+
    ! Output scrolling sequence according to terminal type.
    !-

    UP_BUFF [DSC$B_DTYPE] = DSC$K_DTYPE_T;
    UP_BUFF [DSC$B_CLASS] = DSC$K_CLASS_S;

    CASE .TERM_TYPE FROM UNKNOWN TO VT100 OF 
	SET
	[UNKNOWN] : 
	    BEGIN
	    UP_BUFF [DSC$W_LENGTH] = 0;
	    UP_BUFF [DSC$A_POINTER] = 0;
	    END;

	[VT05] :
	    BEGIN
	    UP_BUFF [DSC$W_LENGTH] = %CHARCOUNT (VT05_UPSCROLL);
	    UP_BUFF [DSC$A_POINTER] = UPLIT (BYTE (VT05_UPSCROLL));
	    END;

	[VT52] :
	    BEGIN
	    UP_BUFF [DSC$W_LENGTH] = %CHARCOUNT (VT52_UPSCROLL);
	    UP_BUFF [DSC$A_POINTER] = UPLIT ( BYTE(VT52_UPSCROLL));
	    END;

	[VT100] :
	    BEGIN
	    UP_BUFF [DSC$W_LENGTH] = %CHARCOUNT (VT100_UPSCROLL);
	    UP_BUFF [DSC$A_POINTER] = UPLIT (BYTE (VT100_UPSCROLL));
	    END;

	TES;

    RETURN (STATUS = OUTPUT (.TCB, UP_BUFF)); 	

    END;				! End of routine SCR$UP_SCROLL
!<BLF/PAGE>

%SBTTL 'TRIMMED_LENGTH - Calc. trimmed length of string'
ROUTINE TRIMMED_LENGTH ( 
			LENGTH : REF VECTOR [, WORD], 
			ADDR
		       ) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Calculates length of specified string ignoring trailing
!	blanks.
!
! CALLING SEQUENCE:
!
!	NEW_LENGTH.wlc.v = TRIMMED_LENGTH ( LENGTH.rw.r, ADDR.ra.r )
!
! FORMAL PARAMETERS:
!
!	LENGTH.rw.r	Address of original length of string.
!
!	ADDR.ra.r	Address of start of string.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NEW_LENGTH.wl.v	  Length of string ignoring trailing blanks.
!
! SIDE EFFECTS:
!
!	NONE
!--

    BEGIN

    LOCAL
	LEN_TO_SEARCH,		! Current length to search
	ADDR_TO_SEARCH ;	! Current starting position to search

!+
! Initialize local length-to-search variable and quit immediately
! if we're looking at a zero-length string.
!-
    IF (LEN_TO_SEARCH = .LENGTH[0]) LEQU 0 THEN RETURN 0 ;

    ADDR_TO_SEARCH = .ADDR ;

    WHILE 1 DO
    BEGIN
	LOCAL
	    FIRST_BLANK_POS,	! Addr. of 1st blank
	    NON_BLANK_POS,	! Addr. of 1st non-blank
	    NEW_LEN;		! New length to search

    !+
    ! Find the 1st blank in the remainder of the string.  If we can't
    ! string has non-blanks in all character positions between here and
    ! last character position, hence its trimmed length is its original
    ! length.
    !-
    IF ( FIRST_BLANK_POS = CH$FIND_CH ( .LEN_TO_SEARCH,  ! length
					.ADDR_TO_SEARCH, ! start addr.
					%C' ')		 ! saught
       ) EQL 0 THEN RETURN (.LENGTH[0] );

    !+
    ! Calc. number of characters remaining in string including the
    ! blank we just found.
    !-
    NEW_LEN = .LEN_TO_SEARCH - (.FIRST_BLANK_POS - .ADDR_TO_SEARCH ) ;

    !+
    ! Try to find a non-blank between where we are and the end of the
    ! string.  If we can't, trimmed length is original length minus
    ! trailing blanks.  If we can, calculate a new length remaining
    ! and a new starting position and repeat.
    !-
    IF ( NON_BLANK_POS = CH$FIND_NOT_CH ( .NEW_LEN,	    ! length
					  .FIRST_BLANK_POS, ! addr
					  %C' '      )	    ! saught
	   ) EQL 0 
	THEN 
	    RETURN ( .LENGTH[0] - .NEW_LEN )	! blanks to end
	ELSE
	    BEGIN
	    LEN_TO_SEARCH = 		     ! New length
			.NEW_LEN - ( .NON_BLANK_POS - .FIRST_BLANK_POS);

	    ADDR_TO_SEARCH = .NON_BLANK_POS ; ! New start
	    END ;
    END ;

    RETURN ( 0 ) ; ! Never gets here -- just keeps compiler happy.

    END;				! End of routine TRIMMED_LENGTH
!<BLF/PAGE>

%SBTTL 'SCR$$GET_TYPE - Get device type'
GLOBAL ROUTINE SCR$$GET_TYPE_R3 ( 
		  REQUEST_TYPE;		    ! Request type
		  TCB_ADDR : REF VECTOR [,LONG], ! Addr of terminal control block
		  DEV_TYPE : REF VECTOR [,LONG]	    ! Device type
		) : GET_TYPE_LINK =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is called by other screen package routines to 
! 	find the terminal type using the GETDVI system service.  This
!	is done only once per terminal for the life of the process --
!	all later calls simply return the saved terminal type.
!
! CALLING SEQUENCE:
!
!	ret_status.wlc.v = SCR$$GET_TYPE_R3 ( REQ_TYPE.rl.v; TCB.wa.r, DEV_TYPE.wl.r )
!
! FORMAL PARAMETERS:
!
!	REQ_TYPE.rl.v	Request type.
!
!	TCB.wa.r	Address of terminal control block
!
!	DEV_TYPE.wl.r	Device type.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	LIB$_NO_STRACT
!       statuses from SCR$SET_OUTPUT or SCR$$FOREIGN
!
! SIDE EFFECTS:
!
!	NONE
!--

    BEGIN
    LOCAL
	STATUS,
	TCB;

    BUILTIN
	AP;

    MAP
	TCB: REF BLOCK [,BYTE];

    IF .SCR$L_CUROUTPUT EQL 0			 
    THEN
	BEGIN				! no output device active
	IF .SCR$L_FLINKHEAD NEQ 0	
	THEN
	    RETURN (LIB$_NO_STRACT);	! error if not 1st call to scrpkg
	STATUS = SCR$SET_OUTPUT (0);	! set up stream 0 for output
	IF NOT .STATUS
	THEN
	    RETURN (.STATUS);	
	END;

    TCB = .SCR$L_CUROUTPUT;		! should now be a current ctrl block
    TCB_ADDR = .TCB;			! ret addr of TCB to user

    IF (DEV_TYPE = .TCB [SCR$B_TYPE]) EQL VTFOREIGN
    THEN
	BEGIN	! Foreign processing
	DEV_TYPE = .TCB [SCR$B_DEVTYP];
	IF .REQUEST_TYPE GEQ 0 ! special processing if foreign device
	THEN
	    BEGIN
	    IF NOT (STATUS = SCR$$FOREIGN (.TCB, .REQUEST_TYPE, 
					   .TCB [SCR$B_DEVTYP], .AP))
				! note that AP still points to the argument
				! list from the calling SCR$ routine
	    THEN 
		RETURN (.STATUS);
	    END;
	END;	! Foreign processing

    RETURN (SS$_NORMAL);

    END;				! end of SCR$$GET_TYPE

%SBTTL 'SCR$$FOREIGN - Call foreign terminal handler'
GLOBAL ROUTINE SCR$$FOREIGN ( 
		  TCB : REF BLOCK [, BYTE], ! Addr of terminal control block
		  REQ_TYPE,	 	    ! Request type
		  DEV_TYPE, 		    ! Device type
		  SCR_ARGS		    ! Addr of SCR$ arguments
		) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine attempts to map the foreign terminal handler into
!	P0 region and call it.
!
! CALLING SEQUENCE:
!
!	ret_status.wlc.v = SCR$$FOREIGN ( TCB.ra.v, REQ_TYPE.rl.v, 
!				DEV_TYPE.rl.v, SCR_ARGS.ra.v )
!
! FORMAL PARAMETERS:
!
!	TCB.ra.v	Address of terminal control block
!
!	REQ_TYPE.rl.v	Request type.
!
!	DEV_TYPE.rl.v	Device type.
!
!	SCR_ARGS.ra.v	Address of arguments from SCR$ routine
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	Statuses returned by LIB$CALL_IMAGE and OUTPUT.
!
! SIDE EFFECTS:
!
!	NONE
!--

    BEGIN

    BUILTIN
	CALLG ;

    LOCAL

    	DEFSTR : VECTOR [1, 8] INITIAL (			! Default name
	    DSC$K_DTYPE_T ^24 + DSC$K_CLASS_S ^16 + 16,		! string
	    UPLIT ('SYS$LIBRARY:.EXE')),

        SCRFT : VECTOR [1, 8] INITIAL (			! File name
	    DSC$K_DTYPE_T ^24 + DSC$K_CLASS_S ^16 + 5,	! string
	    UPLIT ('SCRFT'))  ,

	RET_STATUS,				! Status of subroutine
						! calls.

	LOC_BUF_DESCR : BLOCK [8, BYTE],	! Fixed string descr.
						! of local buffer

	OUT_LENGTH,				! Length of output
						! returned in 
						! LOCAL_BUFFER

	PARM_LIST    : VECTOR [15, LONG],	! Paramater list for
						! call to LIB$CALL_IMAGE

	STATUS;

    MAP SCRFT : BLOCK [8, BYTE] ; ! To allow accessing as a descriptor

    MAP DEFSTR : BLOCK [8, BYTE] ; ! To allow accessing as a descriptor

!+
! Initialize LOC_BUF_DESCR 
!-
    LOC_BUF_DESCR [DSC$W_LENGTH]    = .TCB [SCR$L_BUFSIZ] ;
    LOC_BUF_DESCR [DSC$B_CLASS]     = DSC$K_CLASS_S ;
    LOC_BUF_DESCR [DSC$B_DTYPE]     = DSC$K_DTYPE_T ;

    STATUS = LIB$GET_VM (TCB [SCR$L_BUFSIZ], LOC_BUF_DESCR [DSC$A_POINTER]);
    IF NOT .STATUS THEN RETURN (.STATUS);

!+
! Set up elements of PARM_LIST in preparation for call to LIB$CALL_IMAGE
!-
    PARM_LIST [0]   = 14 ; ! Number of arguments

    PARM_LIST [1]   = PARM_LIST [4] ; ! Address of SCRFT descr in
				      ! call list

    PARM_LIST [2]   = PARM_LIST [6] ; ! Address of DEFSTR descr in
				      ! callist

    PARM_LIST [3]   = PARM_LIST [8] ; ! Address of sub-callist

    PARM_LIST [4]   = .SCRFT [DSC$W_LENGTH] ;  ! Length field of SCRFT

    PARM_LIST [5]   = .SCRFT [DSC$A_POINTER] ; ! Address field of SCRFT

    PARM_LIST [6]   = .DEFSTR [DSC$W_LENGTH] ; ! Length field of DEFSTR

    PARM_LIST [7]   = .DEFSTR [DSC$A_POINTER] ;! Address field of DEFSTR

    PARM_LIST [8]   = 5 ; 		! Number of arguments

    PARM_LIST [9]   = .SCR_ARGS ;  ! Address of args from SCR$ routine

    PARM_LIST [10]   = .REQ_TYPE ;	! Request type

    PARM_LIST [11]   = .DEV_TYPE - (DT$_FT1 - 1) ; ! Foreign terminal
						   ! number

    PARM_LIST [12]   = LOC_BUF_DESCR ; ! Address of LOC_BUF_DESC

    PARM_LIST [13]   = OUT_LENGTH ;	! Address of OUT_LENGTH

    PARM_LIST [14]   = .TCB [SCR$L_FTDATA];

!+
! Call LIB$CALL_IMAGE.  If we get don't get a success return, quit
! immediately.
!-
    IF NOT ( RET_STATUS = CALLG ( PARM_LIST, LIB$CALL_IMAGE))
    THEN
	RETURN ( .RET_STATUS ) ;

!+
! Call OUTPUT with the buffer returned.
!-
    LOC_BUF_DESCR [DSC$W_LENGTH] = .OUT_LENGTH ; ! Adjust length

    RET_STATUS = OUTPUT ( .TCB, LOC_BUF_DESCR ) ;

!+
! Free buffer space before exiting
!-

    STATUS = LIB$FREE_VM (TCB [SCR$L_BUFSIZ], LOC_BUF_DESCR [DSC$A_POINTER]);
    IF NOT .STATUS THEN RETURN (.STATUS);

    RETURN (.RET_STATUS);
    END;				! End of routine SCR$$FOREIGN
!<BLF/PAGE>

%SBTTL 'OUTPUT - Write string to terminal without carriage control'
ROUTINE OUTPUT ( TCB    : REF BLOCK [,BYTE],
		 STRING : REF BLOCK [,BYTE] ) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine writes the specified string to the terminal
!	without carriage control.
!
! CALLING SEQUENCE:
!
!	ret_status.wlc.v = OUTPUT ( TCB.rab.r, string.rt.ds )
!
! FORMAL PARAMETERS:
!
!	TCB.rab.r	Address of current terminal control block.
!
!	STRING.rt.ds	Address of fixed string descriptor of output
!			string.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE STATUS:
!
!
! SIDE EFFECTS:
!
!	String will be output.
!--

    BEGIN

    LOCAL
	STATUS : INITIAL (SS$_NORMAL) ;	! Status to return to caller

!+
! If input string length is 0, return an immediate success.
!-
    IF .STRING [DSC$W_LENGTH] EQL 0 THEN RETURN .STATUS ;

!+
! Major decision is whether output is being buffered or not.
!-
    IF .TCB [SCR$L_BUFFER] EQL 0	! If output being buffered
    THEN
	BEGIN	! Not buffered
	IF .TCB [SCR$L_RTNADDR] EQL 0	! If user has supplied call-back
	THEN				! routine
	    BEGIN	! No call-back routine
	    LOCAL
		CHANNEL ;	! Channel as a longword

	    CHANNEL = .TCB [SCR$W_CHAN] ;

	    IF .TCB [SCR$B_TYPE] EQL 0	! If unknown type
	    THEN
		BEGIN	! Use RMS_OUTPUT
		STATUS = RMS_OUTPUT ( .TCB, .STRING ) ;
		END	! Use RMS_OUTPUT
	    ELSE
		BEGIN	! Use QIO
		STATUS = $QIOW ( CHAN = .CHANNEL,
				 EFN  = .TCB [SCR$L_EFN],
				 FUNC = (IO$_WRITEVBLK OR IO$M_NOFORMAT),
				 P1   = .STRING [DSC$A_POINTER],
				 P2   = .STRING [DSC$W_LENGTH] ) ;
		END ;	! Use QIO
	    END		! No call-back routine

	ELSE

	    BEGIN	! Call-back routine provided
	    STATUS = RMS_OUTPUT ( .TCB, .STRING ) ;
	    END ;	! Call-back routine provided
	END	! Not buffered

    ELSE

	BEGIN	! Buffered output
	!+
	! Description of what the buffer header (BH) looks like:
	!-
	MACRO
	    BH$W_CURR_LENGTH = 0, 0, 16, 0 %,	! Current no. of bytes
	    BH$A_POINTER     = 4, 0, 32, 0 %,	! Addr of 1st byte
	    BH$W_MAX_LENGTH  = 8, 0, 16, 0 % ;	! Max. no. of bytes

	BIND BH = .TCB [SCR$L_BUFFER] ;
	MAP BH : BLOCK [,BYTE] ;

	LOCAL
	    BYTES_REMAINING,
	    SAVED_BUFFER_ADDR;

	SAVED_BUFFER_ADDR = .TCB [SCR$L_BUFFER];
	BYTES_REMAINING = .BH [BH$W_MAX_LENGTH] - 
			  .BH [BH$W_CURR_LENGTH] ;

	IF .STRING [DSC$W_LENGTH] GTRU .BYTES_REMAINING
	THEN
	    BEGIN	! Won't fit in current buffer
	    !+
	    ! Check to see if length of current string is larger than
	    ! the entire size of the buffer.
	    !-
	    IF .STRING [DSC$W_LENGTH] GTRU .BH [BH$W_MAX_LENGTH]
	    THEN
		BEGIN	! Will never fit
		STATUS = LIB$_SCRBUFOVF ;
		END	! Will never fit
	    ELSE
		BEGIN	! Flush buffer, then add to buffer
		SCR$PUT_BUFFER (0) ;
		TCB [SCR$L_BUFFER] = .SAVED_BUFFER_ADDR; 
					! this was re-inited by SCR$PUT_BUFFER
		CH$MOVE ( .STRING [DSC$W_LENGTH], 
			  .STRING [DSC$A_POINTER],
			  .BH [BH$A_POINTER] + .BH [BH$W_CURR_LENGTH]) ;

		BH [BH$W_CURR_LENGTH] = .BH [BH$W_CURR_LENGTH] +
					.STRING [DSC$W_LENGTH] ;
		END ;	! Flush buffer, then add to buffer
	    END		! Won't fit in current buffer
	ELSE
	    BEGIN	! Will fit in buffer
	    CH$MOVE ( .STRING [DSC$W_LENGTH], 
		      .STRING [DSC$A_POINTER],
		      .BH [BH$A_POINTER] + .BH [BH$W_CURR_LENGTH] ) ;

	    BH [BH$W_CURR_LENGTH] = .BH [BH$W_CURR_LENGTH] +
				    .STRING [DSC$W_LENGTH] ;
	    END ;	! Will fit in buffer
	END ;	! Buffered output

    RETURN (.STATUS ) ;

    END;				! End of routine OUTPUT
!<BLF/PAGE>

%SBTTL 'FILL_MAP - Fill map with specified character'
ROUTINE FILL_MAP ( 
		    TCB : REF BLOCK [,BYTE],
		    START_LINE,
		    START_COL,
		    END_LINE,
		    END_COL,
		    FILL_CHAR
		) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine fills the character map with a specified character,
!	zeroes the attribute map, and sets the modified map to ON.
!
! CALLING SEQUENCE:
!
!	ret_status.wlc.v = FILL_MAP (TCB.rz.r, START_LINE.ml.v, START_COL.ml.v,
!				     END_LINE.ml.v, END_COL.ml.v, FILL_CHAR.rt.r)
!
! FORMAL PARAMETERS:
!
!	TCB.rz.r		Terminal Control Block
!	START_LINE.ml.v		starting line number
!	START_COL.ml.v		starting column number
!	END_LINE.ml.v		ending line number
!	END_COL.ml.v		ending column number
!	FILL_CHAR.rt.r		fill character
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!
! SIDE EFFECTS:
!
!	NONE
!--

    BEGIN

    LOCAL
	START_INDEX,
	END_INDEX,
	LENGTH;

    !+
    ! Convert line and column numbers to zero based.
    !-

    START_LINE = .START_LINE - 1;
    START_COL = .START_COL - 1;
    END_LINE = .END_LINE - 1;

    !+
    ! Compute the start index.
    !-

    START_INDEX = (.TCB [SCR$W_DEVWIDTH] * .START_LINE) + .START_COL;
    IF .START_INDEX GEQU .TCB [SCR$L_AREA] 
    THEN
	RETURN 0;			! error if index outside area

    !+
    ! Compute the ending index + 1.
    !-

    END_INDEX = (.TCB [SCR$W_DEVWIDTH] * .END_LINE) + .END_COL;
    IF .END_INDEX GTRU .TCB [SCR$L_AREA]
    THEN
	RETURN 0;			! error if index outside area

    !+
    ! Fill the character and attribute maps.
    !-

    LENGTH = .END_INDEX - .START_INDEX;
    IF .LENGTH LEQU 0
    THEN
	RETURN 0;			! do nothing if zero or negative length

    CH$FILL (.FILL_CHAR, .LENGTH, (.TCB [SCR$L_CHARMAP] + .START_INDEX));
    CH$FILL (%C' ', .LENGTH, (.TCB [SCR$L_ATTRMAP] + .START_INDEX));

    RETURN 1;

    END;				! End of routine FILL_MAP
!<BLF/PAGE>

%SBTTL 'PUT_MAP - Output current map'
ROUTINE PUT_MAP (
		  TCB : REF BLOCK [,BYTE]
		) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine processes the internal screen, attribute and
!	modified maps and calls other screen package routines to
!	output the result.
!
! CALLING SEQUENCE:
!
!	ret_status.wlc.v = PUT_MAP (TCB.rab.r)
!
! FORMAL PARAMETERS:
!
!	TCB.rab.r		Current terminal control block
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	SS$_NORMAL	Normal successful completion
!	Errors returned by:	RMS_OUTPUT
!
! SIDE EFFECTS:
!
!	NONE
!--

    BEGIN
!+
! $OUTPUT_NEXT_LINE
!	This macro causes the next line of text from the data buffer to
! be output.  If no attribute information pertains to this line, it is
! output directly.  If attribute information does pertain to this line,
! DO_ATTR is called to output the line with the appropriate attributes.
!-
MACRO
    $OUTPUT_NEXT_LINE =
    SKPC (%REF(NULL), DW2, .CURR_PTR + .TCB [SCR$L_AREA]; REM_ATTR, FND);
    IF .REM_ATTR EQL 0
    THEN
	BEGIN	! No attributes set for this line's worth of text
	!+
	! Simply output line's worth of text as it sits in data buffer
	!-
	LOC_DESC [DSC$W_LENGTH] = .DW ;
	LOC_DESC [DSC$A_POINTER] = .CURR_PTR ;
	STATUS = RMS_OUTPUT ( .TCB, LOC_DESC ) ;
	END	! No attributes set for this line's worth of text
    ELSE
	BEGIN	! Attributes are present
	!+
	! Call DO_ATTR to output a line's worth of text with the
	! appropriate attributes simulated (e.g., underlining and
	! bolding)
	!-
	DO_ATTR ( REM_ATTR, FND, .TCB, DW, .CURR_PTR ) ;
	END;	! Attributes are present
% ; ! End of macro $OUTPUT_NEXT_LINE

!+
! $OUTPUT_N_BLANK_LINES
!	This macro outputs .LINES_TO_SKIP blanks lines, advancing the
! current pointer (CURR_POINTER) as it goes along.
!-
MACRO
    $OUTPUT_N_BLANK_LINES =
    INCR I FROM 1 TO .LINES_TO_SKIP
    DO
	BEGIN
	STATUS = RMS_OUTPUT ( .TCB, LOC_DESC ) ;
	CURR_PTR = .CURR_PTR + .DW2 ;	! Advance to next line
	END ;
% ;	! End of macro $OUTPUT_N_BLANK_LINES

!+
! $OUTPUT_FF
!	This macro output a <FF> to clear an entire page.
!-
MACRO
    $OUTPUT_FF =
    LOC_DESC [DSC$W_LENGTH] = 1 ;
    LOC_DESC [DSC$A_POINTER] = UPLIT (BYTE ( FF ));
    STATUS = RMS_OUTPUT ( .TCB, LOC_DESC ) ;
% ;	! End of macro $OUTPUT_FF

			! R1 = R3 = FND = 1st non-space character
			! R2 = LINES_TO_SKIP
			! R4 = BYTES_REMAINING
			! R7 = DW
			! R8 = CURR_PTR
			! R9 = SIZE
			! R10= END_DATA_ADDR = start of attributes
			! R11 = DW2

    BUILTIN
	SKPC;

    LOCAL
	STATUS,		! Status to return to caller
	DW,		! Device width
	DW2,		! Copy of device width
	CURR_PTR,	! Pointer to start of remaining characters in
			! map
	END_DATA_ADDR,	! End of character data buffer, start of
			! attribute buffer
	BYTES_REMAINING,! No. of bytes remaining to be output
	LINES_TO_SKIP,	! No. of blank lines to skip
	REM_ATTR,	! No. of attr bytes remaining
	LOC_DESC : BLOCK [8, BYTE];	! Local fixed string descriptor
					! for output

    SCR$L_WORKMASK = 0 ;	! Init working attibute mask
    DW = .TCB [SCR$W_DEVWIDTH] ;! Device width
    DW2 = .DW ;			! Copy of device width
    CURR_PTR = .TCB [SCR$L_CHARMAP] ; ! Address of start fo character
				      ! buffer
    END_DATA_ADDR = .TCB[SCR$L_CHARMAP] + .TCB [SCR$L_AREA] ;

    LOC_DESC [DSC$B_CLASS] = DSC$K_CLASS_S ;
    LOC_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T ;

    WHILE (BYTES_REMAINING = .END_DATA_ADDR - .CURR_PTR) GEQ 0
    DO
	BEGIN	! Overall loop
	LOCAL
	    TEMP,	! throwaway value
	    FND ;	! Next byte index found by a CH$FIND_NOT_CH
	!+
	! Find next displayable character
	!-
	SKPC (%REF(BLANK), BYTES_REMAINING, .CURR_PTR; TEMP, FND);
	LINES_TO_SKIP = (.FND - .CURR_PTR) / .DW2 ;
	IF .LINES_TO_SKIP EQL 0
	THEN
	    BEGIN	! No lines to skip
	    DW = TRIMMED_LENGTH (DW, .CURR_PTR);
	    IF .TCB [SCR$L_ATTRMASK] EQL 0
	    THEN
		BEGIN	! No scan for attributes
		LOC_DESC [DSC$W_LENGTH] = .DW ;
		LOC_DESC [DSC$A_POINTER] = .CURR_PTR ;
		STATUS = RMS_OUTPUT ( .TCB, LOC_DESC ) ;
		END	! No scan for attributes
	    ELSE
		BEGIN	! Scan for attributes
		$OUTPUT_NEXT_LINE ;
		END;	! Scan for attributes
	    END		! No lines to skip

	ELSE

	    BEGIN	! Some lines to skip
	    IF .FND GEQ .END_DATA_ADDR	AND	! If remaining page not
	       .LINES_TO_SKIP NEQ 1		! blank and if more than
	    THEN				! one blank line
		BEGIN	! A
		IF .TCB [SCR$L_ATTRMASK] NEQ 0
		THEN
		    BEGIN
		    DW = 0 ;
		    IF (FND = CH$FIND_NOT_CH (
				.BYTES_REMAINING, 
				.CURR_PTR + .TCB [SCR$L_AREA], 0))
		    NEQ 0
		    THEN
			BEGIN	
			LOC_DESC [DSC$W_LENGTH] = 0;
			LOC_DESC [DSC$A_POINTER] = 0;
			IF .TCB [SCR$L_ATTRMASK] EQL 0
			THEN
			    BEGIN	
			    $OUTPUT_N_BLANK_LINES ;
			    END		
			ELSE
			    BEGIN
			    SKPC (%REF(NULL), DW2, .CURR_PTR + .TCB [SCR$L_AREA];
				  REM_ATTR, FND);
			    IF .REM_ATTR NEQ 0
			    THEN
				BEGIN	
				DO_ATTR (REM_ATTR, FND, .TCB, 
					 DW, .CURR_PTR) ;
				END	
			    ELSE
				BEGIN	
				$OUTPUT_N_BLANK_LINES ;
				END;	
			    END;
			END	
		    ELSE
			BEGIN	
			$OUTPUT_FF ;
			EXITLOOP ;
			END;	
		    END
		ELSE
		    BEGIN	
		    $OUTPUT_FF ;
		    EXITLOOP ;
		    END;	
		END	! A
	    ELSE
		BEGIN	
		!+
		! Remainder of page is blank or next line is blank
		!-
		LOC_DESC [DSC$W_LENGTH] = 0;
		LOC_DESC [DSC$A_POINTER] = 0;
		IF .TCB [SCR$L_ATTRMASK] EQL 0	! If no attributes
		THEN
		    BEGIN	
		    $OUTPUT_N_BLANK_LINES ;
		    END		
		ELSE
		    BEGIN
		    !+
		    ! Locate next attibute byte
		    !-
		    SKPC (%REF(NULL), DW2, .CURR_PTR + .TCB [SCR$L_AREA];
			  REM_ATTR, FND);
		    IF .REM_ATTR NEQ 0
		    THEN
			BEGIN	
			!+
			! Output with attributes
			!-
			DO_ATTR (REM_ATTR, FND, .TCB, DW, 
				 .CURR_PTR) ;
			END	
		    ELSE
			BEGIN	
			!+
			! Output without attributes
			!-
			$OUTPUT_N_BLANK_LINES ;
			END;	
		    END;
		DW = TRIMMED_LENGTH ( DW, .CURR_PTR); 
		IF .TCB [SCR$L_ATTRMASK] EQL 0
		THEN
		    BEGIN	! No scan for attributes
		    LOC_DESC [DSC$W_LENGTH] = .DW ;
		    LOC_DESC [DSC$A_POINTER] = .CURR_PTR ;
		    STATUS = RMS_OUTPUT ( .TCB, LOC_DESC ) ;
		    END		! No scan for attributes
		ELSE
		    BEGIN	! Scan for attributes
		    $OUTPUT_NEXT_LINE ;
		    END;	! Scan for attributes
		END;	
	    END;	! Some lines to skip

	CURR_PTR = .CURR_PTR + .DW2 ;	! Advance to next line
	DW = .DW2 ;			! Reset width to width of page
	END;	! Overall loop

    TCB [SCR$L_ATTRMASK] = .SCR$L_WORKMASK ;	! Reset attibute mask
    RETURN ( .STATUS ) ;
    END;				! End of routine PUT_MAP
!<BLF/PAGE>

%SBTTL 'DO_ATTR - Handle bold and underlining'
ROUTINE DO_ATTR (
		 BYTES_REMAINING,
		 FNZ,
		 TCB : REF BLOCK [, BYTE],
		 LINE_LENGTH,
		 LINE_ADDR
		) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine handles lines containing underlining or bolding.
!	A larger line is built containing concatenated copies of the
!	original line with embedded <CR>'s.  Bold characters are
!	overprinted, underlined characters are converted to "_" and
!	then overprinted.
!
! CALLING SEQUENCE:
!
!	ret_status.wlc.v = DO_ATTR (BYTES_REMAINING.rl.r,
!				    FNZ.rl.r,
!				    TCB.rab.r,
!				    LINE_LENGTH.rl.r
!				    LINE_ADDR.ra.r)
!
! FORMAL PARAMETERS:
!
!	BYTES_REMAINING.rl.r	Count of number of bytes remaining in
!				current line.  It is assumed to be less
!				than or equal to DEV_WIDTH.
!
!	FNZ.rl.r		Address of first non_zero attribute byte
!				in a table of attribute bytes.
!
!	TCB.rab.r		The current terminal control block.
!				Used to calculate the size of the
!				mapped data area and hence the start of
!				the attribute area.
!
!	LINE_LENGTH.rl.r	Length of current line
!
!	LINE_ADDR.ra.r		Address of current line
!
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	SS$_NORMAL	Normal successful completion
!	Errors returned by:	RMS_OUTPUT
!				STR$DUPL_CHAR
!
! SIDE EFFECTS:
!
!	NONE
!--

    BEGIN
    BUILTIN
	SKPC;
    LOCAL
	BR,				! Local copy of BYTES_REMAINING
	LOC_FNZ : REF BLOCK [, BYTE],	! Local copy of FNZ
	STATUS,				! Status of subroutine calls
	UNDER_INDEX,			! Records right-most position of
					! an underline character within
					! the underline buffer.
	BOLD_INDEX,			! Records right-most position of
					! a character in the bold buffer
	UNDER_DESC : BLOCK [8, BYTE],	! Dynamic string descriptor for
					! underlining string.
	BOLD_DESC  : BLOCK [8, BYTE],	! Dynamic string descriptor for
					! bolding string.
	FIX_UNDER_DESC : BLOCK [8, BYTE],! Fixed descriptor pointing to
					 ! trimmed portion of underline
					 ! buffer
	FIX_BOLD_DESC  : BLOCK [8, BYTE],! Fixed descriptor pointing to
					 ! trimmed portion of bold
					 ! buffer
	CR_DESC : BLOCK [8, BYTE],	! Fixed string descriptor of
					! character <CR>.
	RESULT_DESC : BLOCK [8, BYTE];	! Descriptor for resulting
					! string to be output.
!+
! Construct descriptor for and allocate space for the underline buffer.
! Initialize buffer to all blanks.  Initialize fixed underline buffer
! descriptor except for length which we compute as we procede.
!-
    UNDER_DESC [DSC$B_CLASS] = DSC$K_CLASS_D ;	! Dynamic
    UNDER_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T ;	! Text
    UNDER_DESC [DSC$W_LENGTH] = 0 ;		! Length
    UNDER_DESC [DSC$A_POINTER] = 0 ;		! Unallocated address

    STATUS = STR$DUPL_CHAR ( UNDER_DESC,	  ! Resulting descriptor
			     .LINE_LENGTH, 	  ! Length needed
			     UPLIT (BYTE (' '))); ! Fill character

    FIX_UNDER_DESC [DSC$B_CLASS] = DSC$K_CLASS_S ;	! Fixed
    FIX_UNDER_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T ;	! Text
    FIX_UNDER_DESC [DSC$A_POINTER] = .UNDER_DESC [DSC$A_POINTER] ;


!+
! Construct descriptor for and allocate space for the bolding buffer.
! Initialize buffer to all blanks.  Initialize fixed bolding buffer
! descriptor except for length which we compute as we procede.
!-
    BOLD_DESC [DSC$B_CLASS] = DSC$K_CLASS_D ;	! Dynamic
    BOLD_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T ;	! Text
    BOLD_DESC [DSC$W_LENGTH] = 0 ;		! Length
    BOLD_DESC [DSC$A_POINTER] = 0 ;		! Unallocated address

    STATUS = STR$DUPL_CHAR ( BOLD_DESC,	  	  ! Resulting descriptor
			     .LINE_LENGTH, 	  ! Length needed
			     UPLIT (BYTE (' '))); ! Fill character

    FIX_BOLD_DESC [DSC$B_CLASS] = DSC$K_CLASS_S ;	! Fixed
    FIX_BOLD_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T ;	! Text
    FIX_BOLD_DESC [DSC$A_POINTER] = .BOLD_DESC [DSC$A_POINTER] ;

!+
! Initialize indices into BUFFER.  These are the relative positions of
! the right-most underline char, and right-most "char-for-bolding".
! They may get reset as we proceed with loop below.
!-
    BOLD_INDEX = -1;
    UNDER_INDEX = -1;

!+
! Loop through all the attributes bytes remaining, building carriage
! returns and properly positioned copies of the original text that
! needs to be bolded.  For underlining, we build a copy of the original
! text that contains blanks in all positions except those to be
! underlined.  These cells will contain an underscore.
! We manually break out of the loop when there are no more non-zero
! attribute bytes to process.
!-
    LOC_FNZ = ..FNZ ;
    BR = ..BYTES_REMAINING ;	! Initialize local copy
    WHILE -1 
    DO
	BEGIN	! Overall loop
	LOCAL
	    INDEX;		! Local index into underline buffer and
				! bold buffer
	INDEX = .TCB [SCR$W_DEVWIDTH] - .BR ;
	IF .LOC_FNZ [SCR$V_UNDERLINE] EQL 1
	THEN
	    BEGIN	! Underlining needed
	    UNDER_INDEX = .INDEX ; ! Right-most underline
	    .UNDER_DESC [DSC$A_POINTER] + .INDEX = %C'_' ;
	    END;	! Underlining needed

	IF .LOC_FNZ [SCR$V_BOLD] EQL 1
	THEN
	    BEGIN	! Bolding needed
	    .BOLD_DESC [DSC$A_POINTER] + .INDEX = 
				.(.LINE_ADDR + .INDEX) ;
	    BOLD_INDEX = .INDEX ;	! Right-most bold
	    END;	! Bolding needed

	BR = .BR - 1 ;
	LOC_FNZ = .LOC_FNZ + 1 ;	! to next attribute byte
	SKPC (%REF(NULL), BR, .LOC_FNZ; BR, LOC_FNZ);
	IF .BR EQL 0
	THEN
	    EXITLOOP ;
	END;	! Overall loop

!+
! Calculate true lengths of underline and bold buffers.
!-
    FIX_UNDER_DESC [DSC$W_LENGTH] = .UNDER_INDEX + 1 ;
    FIX_BOLD_DESC [DSC$W_LENGTH] = .BOLD_INDEX + 1 ;

!+
! Build composite string by concatenating the pieces.
!-
    RESULT_DESC [DSC$B_CLASS] = DSC$K_CLASS_D ;	! Dynamic
    RESULT_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T ;	! Text
    RESULT_DESC [DSC$W_LENGTH] = 0 ;		! Length
    RESULT_DESC [DSC$A_POINTER] = 0 ;		! Unallocated address

    CR_DESC [DSC$B_CLASS] = DSC$K_CLASS_S ;	! Fixed
    CR_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T ;	! Text
    CR_DESC [DSC$W_LENGTH] = 1 ;		! Length = 1
    CR_DESC [DSC$A_POINTER] = UPLIT (BYTE (CR)); ! A <CR>

    BEGIN
    LOCAL
	DESC : BLOCK [8,BYTE];
    DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
    DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
    DESC [DSC$W_LENGTH] = ..LINE_LENGTH;
    DESC [DSC$A_POINTER] = .LINE_ADDR;

    STATUS = STR$CONCAT ( RESULT_DESC,		! Resulting string
			  DESC,			! Original string
			  CR_DESC,		! A <CR>
			  FIX_UNDER_DESC,	! Underlining string
			  CR_DESC,		! A <CR>
			  FIX_BOLD_DESC,	! Bolding string copy 1
			  CR_DESC,		! A <CR>
			  FIX_BOLD_DESC,	! Bolding string copy 2
			  CR_DESC,		! A <CR>
			  FIX_BOLD_DESC ) ;	! Bolding string copy 3
    END;

!+
! Output composite string we've built
!-
    STATUS = RMS_OUTPUT ( .TCB, RESULT_DESC );

!+
! Give back strings used
!-

    LIB$SFREE1_DD ( UNDER_DESC ) ;
    LIB$SFREE1_DD ( BOLD_DESC ) ;
    LIB$SFREE1_DD ( RESULT_DESC ) ;
    RETURN (.STATUS) ;
    END;				! End of routine DO_ATTR
!<BLF/PAGE>

%SBTTL 'RMS_OUTPUT - Write string via RMS'
ROUTINE RMS_OUTPUT ( TCB : REF BLOCK [,BYTE],
		     STRING : REF BLOCK [,BYTE] ) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine writes the specified string to the terminal using
!	RMS.  If an RMS file is open for the stream it will be used,
!	else LIB$PUT_OUTPUT will be called.
!
! CALLING SEQUENCE:
!
!	ret_status.wlc.v = RMS_OUTPUT ( TCB.rab.r, string.rt.ds )
!
! FORMAL PARAMETERS:
!
!	TCB.rab.r	Address of current terminal control block.
!
!	STRING.rt.ds	Address of fixed string descriptor of output
!			string.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE STATUS:
!
!	Status returned by RMS PUT, LIB$PUT_OUTPUT, or users output
!	routine.
!
! SIDE EFFECTS:
!
!	String will be output.
!--

    BEGIN

    BUILTIN
	CALLG;

    LOCAL
	STATUS; 			! Status to return to caller

    IF .TCB [SCR$L_RTNADDR] EQL 0	! If no user-specified call-back
    THEN
	BEGIN	! We do ouptut
	LOCAL
	    RAB : REF $RAB_DECL;

	IF .TCB [SCR$L_RAB] EQL 0	! If file not open on channel
	THEN
	    BEGIN	! Use LIB$PUT_OUTPUT instead
	    STATUS = LIB$PUT_OUTPUT ( .STRING ) ;
	    END		! Use LIB$PUT_OUTPUT instead
	ELSE
	    BEGIN	! Do via RMS
	    RAB = .TCB [SCR$L_RAB];
	    RAB [RAB$W_RSZ] = .STRING [DSC$W_LENGTH] ;! length of string
	    RAB [RAB$L_RBF] = .STRING [DSC$A_POINTER] ; ! Addr of string

	    WHILE $PUT (RAB = .RAB) EQL RMS$_RSA DO $WAIT (RAB = .RAB ) ;
	    STATUS = .RAB [RAB$L_STS] ;
	    END ;	! Do via RMS
	END	! We do output

    ELSE

	BEGIN	! User does output
	LOCAL
	    CHANNEL,			! Channel as a longword
	    PARM_LIST : VECTOR [5];	! Parameter list for call-back routine

	CHANNEL = .TCB [SCR$W_CHAN] ;	! Extract channel as longword

	!+
	! Bliss must be forced to generate the proper CALL with R0 (not
	! the contents of R0) being moved to STATUS.
	!-
	PARM_LIST [0] = 4;			! number of args
	PARM_LIST [1] = .TCB [SCR$L_RTNARG];	! user-supplied arg
	PARM_LIST [2] = CHANNEL;		! addr of channel
	PARM_LIST [3] = .STRING;		! addr of output string
	PARM_LIST [4] = TCB [SCR$L_STREAM];	! addr of stream
	STATUS = CALLG (PARM_LIST, .TCB [SCR$L_RTNADDR]);
						! call user routine
	END;	! User does output

    RETURN (.STATUS ) ;

    END;				! End of routine RMS_OUTPUT
!<BLF/PAGE>

%SBTTL 'SET_CURSOR - Create set cursor sequence'
ROUTINE SET_CURSOR ( 
		    TCB : REF BLOCK [,BYTE],
		    LINE_NO,
		    COL_NO,
		    BUFFER,
		    CUR_SIZE
		) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine generates the escape sequence for a set cursor
!	position and appends the string to a given output buffer.  No
!	buffer overflow checking is done as it is assumed that the cursor
!	will be the first thing in the buffer.
!
! CALLING SEQUENCE:
!
!	ret_status.wlc.v = SET_CURSOR (TCB.rz.r, LINE_NO.rl.v, COL_NO.rl.v,
!				       BUFFER.mt.r, CUR_SIZE.ml.r)
!
! FORMAL PARAMETERS:
!
!	TCB.rz.r		addr of Terminal Control Block
!	LINE_NO.rl.v		line number
!	COL_NO.rl.v		column number
!	BUFFER.mt.r		addr of buffer
!	CUR_SIZE.ml.r		# bytes currently in buffer
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!
! SIDE EFFECTS:
!
!	NONE
!--

    BEGIN

    LOCAL
    	VT100CTL : VECTOR [1, 8] INITIAL (
	    DSC$K_DTYPE_T ^24 + DSC$K_CLASS_S ^16 + 10,
	    UPLIT ( BYTE (ESC, LB, '!UL;!UL', VT100_SC ))),
					! dsc for cvt to vt100 sequence
					! FAO control string
	FREE_ADDR : REF VECTOR [,BYTE],	! addr of 1st free byte
	TERM_TYPE;			! terminal type


    FREE_ADDR = .BUFFER + ..CUR_SIZE;	! addr of next free byte

    IF .TCB [SCR$B_TYPE] EQL VTFOREIGN
    THEN
	TERM_TYPE = .TCB [SCR$B_DEVTYP]
    ELSE 
	TERM_TYPE = .TCB [SCR$B_TYPE];

    CASE .TERM_TYPE FROM UNKNOWN TO VT100 OF
	SET
	
	[UNKNOWN]:
	    RETURN 1;			! do nothing

	[VT05]:
	    BEGIN
	    .CUR_SIZE = ..CUR_SIZE + 7;	! update current size of buffer
	    FREE_ADDR [0] = VT05_SC;	! put set cursor sequence into buffer
	    FREE_ADDR [1] = CB + .LINE_NO;
	    FREE_ADDR [2] = 0;
	    FREE_ADDR [3] = 0;
	    FREE_ADDR [4] = 0;
	    FREE_ADDR [5] = 0;
	    FREE_ADDR [6] = CB + .COL_NO;
	    END;

	[VT52]:
	    BEGIN
	    .CUR_SIZE = ..CUR_SIZE + 4;	! update current size of buffer
	    FREE_ADDR [0] = ESC;	! put set cursor sequence into buffer
	    FREE_ADDR [1] = VT52_SC;
	    FREE_ADDR [2] = CB + .LINE_NO;
	    FREE_ADDR [3] = CB + .COL_NO;
	    END;

	[VT100]:
	    BEGIN
	    LOCAL
		STATUS,
		CVT_ARGS : VECTOR [2],
		FAO_BUFFER : BLOCK [8, BYTE],
		FAO_LEN : WORD;

	    CVT_ARGS [0] = .LINE_NO;
	    CVT_ARGS [1] = .COL_NO;
	    FAO_BUFFER [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	    FAO_BUFFER [DSC$B_CLASS] = DSC$K_CLASS_S;
	    FAO_BUFFER [DSC$W_LENGTH] = (.TCB [SCR$L_BUFSIZ] - ..CUR_SIZE);
	    FAO_BUFFER [DSC$A_POINTER] = .FREE_ADDR;

	    !+
	    ! Convert to ASCII characters and move to buffer.
	    !-
	    STATUS = $FAOL (CTRSTR = VT100CTL, OUTLEN = FAO_LEN,
		OUTBUF = FAO_BUFFER, PRMLST = CVT_ARGS);
	    IF NOT .STATUS THEN RETURN (.STATUS);
	    .CUR_SIZE = ..CUR_SIZE + .FAO_LEN;	! add length of appended string
	
	    END;

	[INRANGE,OUTRANGE]:
	    RETURN 0;			! should never get here

	TES;

    RETURN 1;

    END;				! End of routine SET_CURSOR
!<BLF/PAGE>

END					! End of module LIB$SCREEN

ELUDOM
