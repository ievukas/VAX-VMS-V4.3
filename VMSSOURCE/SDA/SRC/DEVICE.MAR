	.title	device	Display device data structures
	.sbttl	copyright notice
	.ident	'V04-000'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
	.page
	.sbttl	Program description
;++
;   Facility
;
;	System Dump Analyzer
;
;   Abstract
;
;	This module contains routines to print device data
;	structures for the i/o subsystem.
;
;   Environment
;
;	Native mode, User mode
;
;   Author
;
;	Tim Halvorsen, July 1978
;
;   Modified by
;
;	V03-011 EMB0110		Ellen M. Batbouta	24-Jul-1984
;		Fix a typo in the SHOW DEVICE display and update the
;		list of devices and device characteristics.
;
;	V03-010 EMB0105 	Ellen M. Batbouta	07-Jun-1984
;		Add routines to display the contents of the class
;		driver data blocks (CDDB) when displaying an mscp
;		served device. Also for mscp served devices check
;		2 additional queues before drawing the conclusion
;		that the io request queue is empty.  Fix a minor
;		bug and include the node name in the display in 
;		the routine, SHOW_SYSTEM_BLOCK.
;
;	V03-009 EMD0082		Ellen M. Dusseault	12-Apr-1984
;		Print the address of the cddb and the alternate cddb
;		(if the device is mscp served) when displaying the ucb tables
;		and action routines .  Also display the reasons to wait
;		count for mscp served devices.
;
;	V03-008	LMP0221		L. Mark Pilant,		30-Mar-1984  11:53
;		Change UCB$L_OWNUIC to ORB$L_OWNER and UCB$W_VPROT to
;		ORB$W_PROT.
;
;	V03-007 EMD0059		Ellen M. Dusseault 	07-Mar-1984
;		Fill in local ucb with zeroes in routine, GET_UCB,
;		just in case next ucb fetched is shorter than the 
;    		previous one.
;
;	V03-006	WHM0002		Bill Matthews		16_Feb-1984
;		Change IDB$B_COMBO_VECTOR back to IDB$B_VECTOR.
;
;	V03-005	TMK0002		Todd M. Katz		29-Jan-1984
;		Add DT$_NI to the table BUS_TYPE.
;
;	V03-004	WHM0001		Bill Matthews		16-Jan-1984
;		Change IDB$B_VECTOR to IDB$B_COMBO_VECTOR.
;
;	V03-003	TMK0001		Todd M. Katz		19-Nov-1983
;		Change DT$_UNA11 to DT$_DEUNA in the table SCOM_TYPE and
;		add DT$_DELUA to the same table.
;
;	V03-002	ROW0237		Ralph O. Weber		10-OCT-1983
;		Enhance all displays for latest and greatest I/O database 
;		information.  Add support for SHOW DEVICE/ADDR <expr>, where
;		expression is a UCB address.
;
;	V03-001	KTA3041		Kerbey T. Altmann	26-Apr-1983
;		Fix for cluster names.
;--

	.sbttl	declarations
;
;	symbol defintions
;
	$adpdef			; Adapter Control Block (ADP)
	$aqbdef			; ACP queue header block (AQB)
    	$cddbdef		; Class Driver Data Block (CDDB)
    	$cdrpdef		; Class Driver Request Packet (CDRP)
	$crbdef			; channel request block (CRB)
	$dcdef			; device class/type definitions
	$ddbdef			; device data block (DDB)
	$ddtdef			; Driver dispatch table (DDT)
	$devdef			; Device characteristics definitions
	$dptdef			; Driver prologue table (DPT)
	$dyndef			; Dynamic storage type definitions
	$idbdef			; interrupt dispatch block (IDB)
	$iodef			; I/O function codes
	$irpdef			; I/O request package (IRP)
    	$mscpdef		; Mass Storage Control Protocol (MSCP)
	$orbdef			; Object's Rights Block (ORB)
	$pbdef			; path block (PB)
	$pcbdef			; Process control block (PCB)
	$sbdef			; System block (SB)
	$tpadef			; TPARSE definitions
	$ttyucbdef		; terminal UCB definitions
	$ucbdef			; unit control block (UCB)
	$vcbdef			; Volume control block (VCB)
	$vecdef			; interrupt transfer vector (in IDB)

;
; definition of requested device name storage fields
;  (using storage based at parsed_devnam)
;
	$defini	pdvnm
$def	pdvnm_t_node	.blkb 16	; node name
$def	pdvnm_t_ddc	.blkb 16	; device & controller
$def	pdvnm_w_unit	.blkw 1		; unit number
$def	pdvnm_b_nodesz	.blkb 1		; size of real node name
					;  (use by get_ddb)
	.blkb 1
pdvnm_k_length = .			; size of this structure
	$defend pdvnm

;
; definition of flags bits stored in r8 by display_device
;
	_vield	flag,0,< -
		<one_unit,,m>, - ; a specific unit was specified
		<alt_path,,m>, - ; traversing the alternate DDB chain
		<fnd_unit,,m>, - ; found at least one unit
		>

	.sbttl	storage definitions
;
;	storage definitions
;

	.psect	sdadata,noexe,wrt

ucb_size = ucb$k_lcl_disk_length
.iif gt <ucb$l_2p_cddb+4-ucb_size>, ucb_size = ucb$l_2p_cddb+4

sb:	.blkb	sb$k_length	; System block (SB)
nodnam_2p:
	.blkb	sb$s_nodename+1

ddb:	.blkb	ddb$k_length	; device data block (DDB)
ddb_2p:	.blkb	ddb$k_length	; secondary device data block (DDB)

ucb:	.blkb	ucb_size	; unit control block (UCB) 
				;  all the interesting stuff

irp:	.blkb	irp$c_length	; I/O request package (IRP)

cdrp:	.blkb	cdrp$c_cd_len-cdrp$l_ioqfl	; Class Driver Request Package (CDRP)
cdrp_length=cdrp$c_cd_len-cdrp$l_ioqfl  ; Total length of cdrp including negative offsets

vcb:	.blkb	vcb$c_length	; Volume control block (VCB)

aqb:	.blkb	aqb$c_length	; ACP queue header block (AQB)

dpt:	.blkb	dpt$c_length	; Driver prologue table (DPT)

cddb:	.blkb	cddb$k_length	; Class driver data block (CDDB)

cddb_2p:   .blkb  cddb$k_length	; Secondary CDDB

parsed_devnam:
	.blkb	pdvnm_k_length

flag_2nd_cddb:
    	.word 0		; flag to tell us if the address coming in is the
    			; primary or secondary cddb in routine, show_cddb
queue_notempty:
    	.byte 0		; if 1 means item in an io queue to be displayed
    			; if 0 the queue is empty

	.psect	device,exe,nowrt,long

	.default displacement,long

	.sbttl	read-only data definitions

;
;	read-only data definitions
;

pb_status:
	table	pb$v_,<tim>

pb_state:
	table	pb$c_,<CLOSED,ST_SENT,ST_REC,OPEN>

pb_rstate:
	table	pb$c_,<UNINIT,DISAB,ENAB>

pb_rport_type:
	table	pb$c_,<CI780,HSC,KL10,CINT,NI,PS>

ddb_acpclass:
	table	ddb$k_,<PACK,CART,SLOW,TAPE>

unit_status:
	table	ucb$v_,<tim,int,erlogip,cancel,online,power,timout,-
		inttype,bsy,mounting,deadmo,valid,unload,template,-
		mntverip,wrongvol,deleteucb,lcl_valid,supmvmsg,-
    		mntverpnd>

device_char:
	table	dev$v_,<rec,ccl,trm,dir,sdi,sqd,spl,opr,rct,net,fod,-
		dua,shr,gen,avl,mnt,mbx,dmt,elg,all,for,swl,idv,odv,-
		rnd,rtm,rck,wck>

device_char_2:
	table	dev$v_,<clu,det,rtt,cdp,2p,mscp,ssm,srv,red,nnm>

device_class:
	addr_table dc$_,<-
		<disk,disk_type>,-
		<tape,tape_type>,-
		<scom,scom_type>,-
		<card,card_type>,-
		<term,term_type>,-
		<lp,lp_type>,-
		<workstation,workstation_type>,-
		<realtime,realtime_type>,-
		<bus,bus_type>,-
		<mailbox,mailbox_type>,-
		<journal,journal_type>,-
		<misc,misc_type>-
		>

disk_type:
	table	dt$_,<RK06,RK07,RP04,RP05,RP06,RM03,RP07,RP07HT,RL01,RL02,-
		RX02,RX04,RM80,TU58,RM05,RX01,ML11,RB02,RB80,RA80,RA81,RA60,-
		RZ01,RC25,RZF01,RCF25,RD51,RX50,RD52,RD53,RD26,RA82,RC26,-
    		RCF26,CRX50>

tape_type:
	table	dt$_,<TE16,TU45,TU77,TS11,TU78,TA78,TU80,TU81,TA81,TK50>

scom_type:
	table	dt$_,<DMC11,DMR11,XK_3271,XJ_2780,NW_X25,NV_X29,SB_ISB11,-
		MX_MUX200,DMP11,DMF32,XV_3271,CI,NI,DEUNA,YN_X25,YO_X25,-
		YP_ADCCP,YQ_3271,YR_DDCMP,YS_SDLC,UK_KTC32,DEQNA,DMV11,DELUA>

card_type:
	table	dt$_,<CR11>

term_type:
	table	dt$_,<TTYUNKN,VT05,FT1,FT2,FT3,FT4,FT5,FT6,FT7,FT8,LAX,-
		LA36,LA120,VT5X,VT52,VT55,TQ_BTS,TEK401X,VT100,VK100,-
		VT173,LA34,LA38,LA12,LA24,LQP02,VT101,VT102,VT105,VT125,-
		VT131,VT132,DZ11,DZ32,DZ730,DMZ32,DHV,DHU>

lp_type:
	table	dt$_,<LP11,LA11,LA180>

workstation_type:
	table	dt$_,<VS100,VS125,VS300>

realtime_type:
	table	dt$_,<LPA11,DR780,DR750,DR11W,PCL11R,PCL11T,DR11C,XI_DR11C,-
		XP_PCL11B,IX_IEX11>

bus_type:
	table	dt$_,<CI780,CI750,UQPORT,UDA50,UDA50A,LESI,TU81P,RDRX,NI>

mailbox_type:
	table	dt$_,<MBX,SHRMBX,NULL>

journal_type:
	table	dt$_,<RUJNL,BIJNL,AIJNL,ATJNL,CLJNL>

misc_type:
	table	dt$_,<DN11>

vcb_disk_status:
	table	vcb$v_,<write_if,write_sm,homblkbad,idxhdrbad,noalloc,-
		extfid,group,system>

vcb_disk_status2:
	table	vcb$v_,<writethru,nocache,mountver,erase,nohighwater>

vcb_tape_status:
	table	vcb$v_,<partfile,logiceovs,waimouvol,wairewind,waiusrlbl,-
		cancelio,mustclose,nowrite>

vcb_tape_mode:
	table	vcb$v_,<ovrexp,ovracc,ovrlbl,ovrsetid,intchg,ebcdic,novol2,-
		starfile,enusereot,blank,init,noauto,ovrvolo>

vcb_journal_char:
	table	vcb$v_,<jnl_disk,jnl_tape,jnl_tmpfi>

cddb_status:
    	table	cddb$v_,<snglstrm,impend,initing,reconnect,resynch,polling,-
    		alcls_set,noconn,rstrtwait,quorlost,dapbsy,2pbsy>

cddb_flags:
    	table	mscp$v_,<cf_576,cf_shadw,cf_mlths,cf_this,cf_other,cf_misc,-
    		cf_attn,cf_replc>

cdrp_dutuflags:
    	table	cdrp$v_,<cand,canio,erlip,perm,hirt,ivcmd>

request_status:
	table	irp$v_,<bufio,func,pagio,complx,virtual,chained,swapio,-
		diagbuf,physio,termio,mbxio,extend,filacp,mvirp>

io_function:
	table	io$_,<nop,unload,seek,recal,erasetape,packack,spacerecord,-
		writecheck,writepblk,readpblk,available,dse,setchar,sensechar,-
		writemark,wrttmkr,writelblk,readlblk,rewindoff,setmode,rewind,-
		skipfile,skiprecord,sensemode,writeof,writevblk,readvblk,-
		access,create,deaccess,delete,modify,acpcontrol>
		
acp_status:
	table	aqb$v_,<unique,defclass,defsys,creating>

aqb_acptype:
	table	aqb$k_,<undefined,f11v1,f11v2,mta,net,rem,jnl>



	.sbttl	display_devbyaddr -- display UCB, etc. given its address
;---
;
;	display_devbyaddr
;
;	This routine takes the address value in TPA$L_NUMBER(AP), 
;	attempt to use it as a UCB address, and do a SHOW DEVICE 
;	for that UCB.  This is the primary support routine for
;	the SHOW DEVICE/ADDR command.
;
;   Inputs:
;
;	AP = pointer to TPARSE block
;
;   Outputs:
;
;	The i/o data structures for that device are shown.
;
;---

	.enable lsb

	.entry	display_devbyaddr, -
		^m<r2,r3,r4,r5,r6,r7,r8,r8,r10,r11>

	subhd	<I/O data structures>
	movab	ucb, r7				; get local UCB home
	movl	tpa$l_number(ap), r2		; get supposed UCB address
	bsbw	get_ucb				; pull UCB to local memory
	blbc	r0, 900$			; if error, exit
	cmpb	#dyn$c_ucb, ucb$b_type(r7)	; is it really a UCB?
	beql	10$				; branch if really a UCB
900$:	pushl	tpa$l_number(ap)		; else, output a error
	type	1,<!XL is not the address of a UCB>
	brw	999$				; then exit

10$:	movab	ddb, r6				; get local DDB home
	trymem	@ucb$l_ddb(r7), (r6), #ddb$k_length ; copy the DDB
910$:	blbc	r0, 900$			; quit now, if error
	cmpb	#dyn$c_ddb, ddb$b_type(r6)	; is this a DDB?
911$:	bneq	900$				; branch if not a DDB
	movab	sb, r11				; get local SB home
	trymem	@ddb$l_sb(r6), (r11), #sb$k_length ; copy the SB
	blbc	r0, 910$			; if error, exit
	cmpw	#<dyn$c_scs_sb@8+dyn$c_scs>, -	; is this really a SB?
		sb$b_type(r11)
	bneq	911$				; branch if no really a SB

	bbc	#dev$v_fod, ucb$l_devchar(r7), - ; branch if this device not 
		27$				;   file oriented?
	movzbl	sb$t_nodename(r11), r0		; else, get node name size
	beql	30$				; branch if no node name
	movb	#^a/$/, -			; add "$" to node  name
		sb$t_nodename+1(r11)[r0]
	incb	sb$t_nodename(r11)		; increase size of node name
	brb	30$
27$:	clrb	sb$t_nodename(r11)		; non-fod devices have no node

30$:	pushl	#0				; setup no flags flags longword
	pushab	sb$t_nodename(r11)		; setup node name
	pushl	r2				; setup UCB VA
	movq	r6, -(sp)			; setup local DDB and UCB
	calls	#5, w^show_ucb			; display this UCB
	
999$:	ret

	.disable lsb

	.sbttl	display_device -- display i/o data structures
;---
;
;	display_device
;
;	This routine displays all i/o data structures related
;	to a specified generic device name.
;
;   Inputs:
;
;	AP = pointer to TPARSE block
;
;   Outputs:
;
;	The i/o data structures for that device are shown.
;
;---
	.enabl	lsb

display_device::
	.word	^m<r2,r3,r4,r5,r6,r7,r8,r9,r10,r11>

	clrl	r8			; init internal flags
	bsbw	parse_device		; parse the device into name and unit

	subhd	<I/O data structures>

	assume	flag_v_one_unit eq 0
	blbs	r8, 10$			; if explicit unit, skip ddb info
	callg	(ap),w^show_ddbs	; show DDB summary

	; init iodb scan
10$:	clrl	r11			; make get_ddb initialize

	; loop over all DDBs and both paths
20$:	bsbw	get_ddb			; get the next DDB
	blbc	r0,45$			; leave when done
	movab	ucb, r7			; address UCB in local storage
	bicl	#flag_m_alt_path, r8	; assume not alternate path, yet
	movl	ddb$l_ucb(r6), r2	; Address of first UCB
	beql	30$			; Branch if none
	bsbw	get_ucb			; Read first UCB
	blbs	r0, 40$			; If got something, go process it
30$:	movl	ddb$l_dp_ucb(r6), r2	; try looking at the alternate path
	beql	20$			; branch if nothing there
	bsbw	get_ucb			; read first alternate pathed UCB
	blbc	r0, 30$			; if nothing there, skip this DDB
	bisl	#flag_m_alt_path, r8	; now doing the alternate path
	tstl	ddb$l_ucb(r6)		; was anything found on primary path?
	bneq	60$			; if so, skip the controller info

	; display controller information if appropriate
	assume	flag_v_one_unit eq 0
40$:	blbs	r8, 60$			; if explicit unit, skip controler info
	pushl	r9			; SVA of DDB
	pushab	sb$t_nodename(r11)	; address of nodename
	movq	r6,-(sp)		; address of DDB,UCB blocks
	calls	#3,w^show_controller	; Display controller info
	brb	70$			; ...enter loop

; Intermediate branch to final cleanup/error processing.

45$:	brb	100$

	; loop over all UCBs on a either DDB chain
50$:	bbc	#flag_v_alt_path, r8, -	; branch if using primary chain
		53$
	movl	ucb$l_dp_link(r7), r2	; else, addr. of next UCB on sec. chain
	beql	20$			; branch if no more
	brb	55$			; else, continue processing
53$:	movl	ucb$l_link(r7), r2	; address of next UCB in primary chain
	beql	30$			; branch if no more
55$:	bsbw	get_ucb			; Get local copy of the UCB
	blbc	r0, 30$			; skip rest if chain broken
	assume	flag_v_one_unit eq 0
	blbc	r8, 70$			; branch if displaying all units

60$:	cmpw	ucb$w_unit(r7), -	; check if request unit
		parsed_devnam+pdvnm_w_unit
	bneq	50$			; skip if not

70$:	pushl	r8			; flags longword
	pushab	sb$t_nodename(r11)	; address of node name
	pushl	r2			; actual address of UCB
	movq	r6,-(sp)		; address of DDB,UCB blocks
	calls	#5,w^show_ucb		; display current UCB
	bisl	#flag_m_fnd_unit, r8	; mark at least 1 UCB was displayed
	brb	50$			; loop thru all UCB's

100$:	bbs	#flag_v_fnd_unit, -	; branch if at least 1 ucb displayed
		r8, 110$
	movzwl	#ss$_nosuchdev,r0	; signal "no such device"
	signal	0
110$:	status	success			; exit to tparse w/success
	ret

	.dsabl	lsb

	.sbttl	parse_device -- parse device name into name and unit number
;---
;	parse the device name into name and unit number
;
; Inputs:
;
;	r8 = longword of show command status flags
;	tpa$l_tokencnt(ap) = Descriptor of device name
;	parsed_devnam = address of a work area into which parsed fragments
;			of the device name are stored
;
; Outputs:
;
;	if x equals parsed_devnam then:
;	    pdvnm_t_node(x) = ASCIC string for parsed node name
;	    pdvnm_t_ddc(x)  = ASCIC string for parsed device and controller
;	    pdvnm_s_unit(x) = converted unit number
;	    (null strings imply item missing from input)
;	flag_m_one_unit in r8, set if unit number specified
;	r2-r7 and r9-r11 are destroyed.
;---

parse_device:
	movab	parsed_devnam, r11	; get working area base address
	clrl	pdvnm_t_node(r11)	; null the two string values
	clrl	pdvnm_t_ddc(r11)
	clrw	pdvnm_w_unit(r11)	; zero unit number
	movq	tpa$l_tokencnt(ap), r6	; get descriptor of input string
	locc	#^a/$/, r6, (r7)	; scan name for a "$"
	beql	10$			; branch if none
	subl3	r7, r1, r9		; compute size of node name
	movc3	r9, (r7), -		; copy node name string to work area
		pdvnm_t_node+1(r11)
	movb	r9, pdvnm_t_node(r11)	; store node name size
	incl	r9			; get size of node name incl. "$"
	subl	r9, r6			; adjust input string descriptor to
	addl	r9, r7			;  remove node name section
10$:	tstl	r6			; anything left to work with?
	beql	90$			; branch if no characters left
20$:	subb3	#^a/0/, (r7), r0	; convert next character to a
	blss	50$			;  a numeric value and branch to
	cmpb	r0, #9			;  50$ if not a numeric digit
	bgtru	50$
	mulw	#10, pdvnm_w_unit(r11)	; scale unit number by ten
	addw	r0, pdvnm_w_unit(r11)	;  and add new digit
	bisl	#flag_m_one_unit, r8	; set the unit number found flag
	brb	66$			; go do next digit
50$:	assume	flag_v_one_unit eq 0
	blbs	r8, 90$			; branch if unit number already found
	movzbl	pdvnm_t_ddc(r11), r0	; get number of characters in dev/ctrl
	movb	(r7), -			; move new character into place
		pdvnm_t_ddc+1(r11)[r0]
	addb3	#1, r0, pdvnm_t_ddc(r11) ; store new character count
66$:	incl	r7			; move string pointer
	sobgtr	r6, 20$			; reduce character count and branch
					;  if characters still left to process
90$:	rsb

	.sbttl	show_ddbs -- display device data blocks (DDBs)
;---
;
;	show_ddbs
;
;	This routine displays all active DDB's associated
;	with a specified generic device name.
;
;   Inputs:
;
;	AP = pointer to TPARSE block
;
;---
	.save
	.psect literals

found_dpt:
	.address 8, 10$
10$:	string	<!_!XL    !10<!AC!AC!>    !6AD!+!+    !10AC !XL  !XW>

no_dpt:
	.address 6, 10$
10$:	string	<!_!XL    !10<!AC!AC!>    !6AD!+!+    !10AC>

	.restore

show_ddbs:
	.word	^m<r2,r3,r4,r5,r6,r7,r8,r9,r10,r11>

	skip	page
	print	0,<!_!_!_!_DDB list>
	print	0,<!_!_!_!_-------->
	skip	1
	print	0,<!_ Address    Controller     ACP       Driver      DPT   DPT size>
	print	0,<!_ -------    ----------     ---       ------      ---   -------->
	skip	1
	clrl	r11			; make get_ddb initialize

10$:	bsbw	get_ddb			; find next DDB
	blbc	r0, 90$			; end of DDB list
	movq	no_dpt, r4		; assume no DPT will be found
	bsbb	find_dpt		; locate dpt; r7 = local dpt; r8 = address
	blbc	r0, 17$			; branch if not found
	movq	found_dpt, r4		; show that DPT was found
	movzwl	dpt$w_size(r7), -(sp)	; length of DPT
	pushl	r8			; address of DPT
17$:	pushal	ddb$t_drvname(r6)	; address of driver name
	clrq	-(sp)			; allocate 2 longwords for ACP name
	pushal	(sp)
	clrl	-(sp)			; assume no ACP name for this DDB
	bicl3	#^xff000000, -		; obtain ACP name for this DDB
		ddb$l_acpd(r6), r0
	beql	30$			; branch if no ACP name in this DDB
	movl	r0, 8(sp)		; put name in the working string
	movl	#6, (sp)		; set length of ACP name
	movl	#^a'XQP', 11(sp)	; assume ACP is really an XQP
	cmpl	#^a'F11', r0		; is it an XQP?
	beql	30$			; branch if its an XQP
	movl	#^a'ACP', 11(sp)	; else, change it to an ACP
30$:	pushal	ddb$t_name(r6)		; generic device name for controller
	pushab	sb$t_nodename(r11)	; node name
	pushl	r9			; actual address of DDB
	printd	r4, (r5)		; print a line
	brb	10$			; loop till out of DDBs
90$:	ret				; then return
	.page
;
;	Subroutine to locate the DPT corresponding to the current
;	DDB.
;
find_dpt:
	pushr	#^m<r2,r3,r4,r5>
	movab	dpt,r7
	trymem	@ioc$gl_dptlist,dpt$l_flink(r7)	; set address of first DPT
	blbc	r0,90$			; branch if error
10$:	movl	dpt$l_flink(r7),r8	; skip to next DPT
	cmpl	r8,ioc$gl_dptlist	; check if back to listhead
	beql	80$			; branch if end of list
	trymem	(r8),(r7),#dpt$c_length	; read the entire dpt
	blbc	r0,90$			; branch if error
	movzbl	dpt$t_name(r7),r0	; get length of dpt driver name
	cmpc	r0,dpt$t_name+1(r7),ddb$t_drvname+1(r6)
	bneq	10$			; branch if no match yet
50$:	movl	#1,r0			; success
	brb	90$
80$:	clrl	r0			; not found
90$:	popr	#^m<r2,r3,r4,r5>
	rsb

	.sbttl	get_ddb -- locate the next DDB in the I/O database
;---
;
;	get_ddb
;
;	This routine locates the next DDB in the I/O database.  All
;	available system blocks are searched.  However, if a node name
;	is specified, only the system block whose node name matches 
;	actually has DDBs returned.
;
; Inputs:
;
;	r6 -	addr of DDB, local storage
;	r11 -	addr of SB, local storage
;		(zero means initialize scan)
;
; Outputs:
;
;	r0 -	status
;	r6 -	addr of DDB, local storage
;	r9 -	SYS VA of DDB
;	r11-	addr of SB, local storage
;
;---

get_ddb:
	tstl	r11			; must we initialize?
	beql	1500$			; branch if must initialize

10$:	movl	ddb$l_link(r6),r9	; skip to next DDB
	beql	100$			; if end of list, go try next SB
	getmem	(r9), (r6), -		; read entire DDB
		#ddb$c_length
	blbc	r0, 90$			; skip if cannot read
	movab	parsed_devnam, r7	; get parsed device name data base addr.
	movzbl	pdvnm_t_ddc(r7), r1	; was generic device specified?
	beql	50$			; branch if not
	cmpb	r1, ddb$t_name(r6)	; Is device name big enough?
	bgtru	10$			; branch if not
	cmpc3	r1, pdvnm_t_ddc+1(r7), -
		ddb$t_name+1(r6)
	bneq	10$			; loop until end of list
50$:	movb	pdvnm_b_nodesz(r7), -	; assume that the node name is
		sb$t_nodename(r11)	;  required for this DDB
	cmpl	ddb$l_sb(r6), -		; is this the local node?
		scs$ga_localsb
	bneq	70$			; no, node name is required
	movl	ddb$l_ucb(r6), r1	; for the local node, we want to
	bneq	53$			;  show a node name if and only if
	movl	ddb$l_dp_ucb(r6), r1	;  this is a file oriented device
	beql	70$			; if we cannot tell, show the node name
53$:	getmem	ucb$l_devchar(r1)	; else test for a file oriented device
	bbs	#dev$v_fod, r1, 70$	;  using device characteristics flag
	clrb	sb$t_nodename(r11)	; if not fod, vanish node name
70$:	movl	#1,r0			; set success
90$:	rsb
1500$:	brb	500$			; branch assist

;
; move to next SB
;

100$:	clrl	r0			; Set for failure
	movl	sb$l_flink(r11), r10	; Get next block
	cmpl	r10, scs$gq_config	; Reached end of queue?
	beql	90$			; yes
	getmem	(r10), (r11), -		; Pick up system block
		#sb$c_length
	blbc	r0,90$			; exit if broken
	movl	sb$l_ddb(r11),-
		 ddb$l_link(r6)		; set address of first DDB
	movab	parsed_devnam, r10	; get parsed device name data base addr.
	movzbl	sb$t_nodename(r11), r0	; get size of node name
	beql	120$			; branch if no node name
	movb	#^a/$/, -		; append "$" to the node name
		sb$t_nodename+1(r11)[r0]
	addb3	#1, r0, pdvnm_b_nodesz(r10) ; store new node name size
120$:	movzbl	pdvnm_t_node(r10), r5	; pick up requested node name lenght
	beql	130$			; there is none, go scan DDB chain
	cmpb	r5, r0			; do length match?
	bneq	100$			; no, this cannot be it
	cmpc3	r5, -			; do names match?
		pdvnm_t_node+1(r10), -
		sb$t_nodename+1(r11)
	bneq	100$			; no, this cannot be it
130$:	brw	10$			; go scan the DDB chain

;
; initialize I/O database scan
;

500$:	movab	sb, r11			; pickup local SB storage address
	movab	ddb, r6			; pickup local DDB storage address
	getmem	@scs$gq_config, -	; initialize next SB pointer
		sb$l_flink(r11)
	brb	100$			; link to next SB

	.sbttl	show_controller, Display controller information
;---
;
;	show_controller
;
;	Display all information related to the controller
;	device associated with each generic device name.
;
;   Inputs:
;
;	4(ap) = Address of DDB in local storage
;	8(ap) = Address of UCB in local storage
;	12(ap)= Address of node name in local storage
;	16(ap)= SVA of DDB
;
;---

show_controller:
	.word	^m<r2,r3,r4,r5,r6,r7>
	movq	4(ap),r2		; get address of DDB,UCB
	movab	buffer,r4

; begin with controller heading

	skip	page
	pushal	ddb$t_name(r2)		; generic controller name
	pushl	12(ap)
	print	2,<Controller: !AC!AC>
	pushl	#12
	addb	ddb$t_name(r2), (sp)
	addb	@12(ap), (sp)
	print	1,<!#*->
	skip	1

	cmpb	ddb$l_sb(r2), scs$ga_localsb		; skip this stuff if 
	beql	skip_sb					;  this is the local SB
	pushl	ddb$l_sb(r2)				; else, display SB and
	calls	#1, w^show_system_block			;  related information

skip_sb:
	getmem	@16(ap), (r4), #ddb$k_length		; copy DDB to local mem.
	retiferr
	ensure	6
	pushl	16(ap)
	print	1,<!_!_--- Device Data Block (DDB) !XL --->
	skip	1
	print_columns -
		buffer, 16(ap), -
		ddb_column_1, ddb_column_2, ddb_column_3
	skip	1

	getmem	@ucb$l_crb(r3), (r4), #crb$k_length	; get primary CRB
	retiferr
	ensure	8
	pushl	ucb$l_crb(r3)
	print	1,<!_    ---  Primary Channel Request Block (CRB) !XL --->
	skip	1
	movb	ucb$b_devclass(r3), crb_devclass	; setup device info.
	print_columns -
		buffer, ucb$l_crb(r3), -		; output CRB columns
		crb_column_1, crb_column_2, crb_column_3
	addl3	#crb$l_intd, ucb$l_crb(r3), r0
	print_columns -
		buffer+crb$l_intd, r0, -		; output VEC columns
		vec_column_1, vec_column_2, vec_column_3
	skip	1

	movl	crb$l_link(r4), r7			; link to second. CRB
	bneq	10$
	brw	skip_second_crb				; branch if none
10$:	getmem	(r7), (r4), #crb$k_length		; get secondary CRB
	retiferr
	ensure	8
	pushl	r7
	print	1,<!_  ---  Secondary Channel Request Block (CRB) !XL --->
	skip	1
	print_columns -
		buffer, r7, -				; output CRB columns
		crb_column_1, crb_column_2, crb_column_3
	addl2	#crb$l_intd, r7
	print_columns -
		buffer+crb$l_intd, r7, -		; output VEC columns
		vec_column_1, vec_column_2, vec_column_3
	skip	1

skip_second_crb:
	cmpl	ddb$l_sb(r2), scs$ga_localsb		; is this a local dev.?
	beql	10$
	brw	display_ddt				; if so, skip IDB etc.
10$:	addl3	#<crb$l_intd+vec$l_idb>, -		; locate address of
		ucb$l_crb(r3), r7			;  primary IDB
	getmem	(r7)					; get that address
	retiferr
	movl	r1, r7					; save IDB address
	getmem	(r7), (r4), #idb$k_length		; copy IDB to local mem.
	retiferr
	ensure	4
	pushl	r7
	print	1,<!_!_--- Interrupt Data Block (IDB) !XL --->
	skip	1
	print_columns -
		buffer, r7, -
		idb_column_1, idb_column_2, idb_column_3
	skip	1

display_ddt:
	getmem	@ucb$l_ddt(r3), (r4), #ddt$k_length	; copy DDT to local mem.
	retiferr
	ensure	6
	pushl	ucb$l_ddt(r3)
	print	1,<!_!_--- Driver Dispatch Table (DDT) !XL --->
	skip	1
	print_columns -
		buffer, ucb$l_ddt(r3), -
		ddt_column_1, ddt_column_2, ddt_column_3

	ret
	.page
	.sbttl show_controller tables & action routines

;  The following are all PRINT_COLUMNS action routines for the show 
;  controller displays.
;
;    Action Routine Inputs:
;
;	R2		value from the COLUMN_LIST entry
;	R5		size of value section for this item
;	R7		address of a descriptor for a scratch string in 
;			which the FAO converted value is to be returned
;	R11		base address of the local UCB copy
;
;    Action Routine Outputs:
;
;	R0		status
;			   lbs ==> use this entry
;			   lbc ==> skip this entry
;	R1 - R5		scratch
;			all other registers must be preserved

;
; FAO control strings, etc. used by the action routines
;

	.save
	.psect	literals

vec_fao_datapath:
	string	<!UB!AC!AC>

vec_fao_mapreg:
	string	<!UB(!UB)!AC>

vec_lwae:
	.ascic	/ LWAE/

vec_locked:
	.ascic	/ Locked/

ddt_return:
	.ascic	/return/

	.restore

;
; PRINT_COLUMNS tables for DDB display
;

ddb_column_1:
	column_list -
		ddb$, 20, 8, 3, <-
		<<Driver name>,t_drvname,ac,13,15>, -
		<<ACP ident>,ddb_acpd,0,25,3>, -
		<<ACP class>,ddb_acpcls,0>, -
		>

ddb_column_2:
	column_list -
		ddb$, 15, 8, 3, <-
		<<Alloc. class>,l_allocls,ub>, -
		<<SB address>,l_sb,xl>, -
		<<UCB address>,l_ucb,xl>, -
		>

ddb_column_3:
	column_list -
		ddb$, 15, 8, 0, <-
		<<DDT address>,l_ddt,xl>, -
		<<CONLINK addr.>,l_conlink,xl_neq>, -
		<<2p UCB addr.>,l_dp_ucb,xl_neq>, -
		>

;********
ddb_acpd:
	bicl3	#^xff000000, ddb$l_acpd(r11), -	; get ACP descriptor
		r2
	beql	ddb_no_acp			; branch if no ACP info
	rotl	#8, r2, r2			; make ACP descriptor into
	addl	#3, r2				;  an ASCIC string and
	pushl	r2				;  push it onto the stack
	movl	sp, r2				; save ASCIC pointer
	do_column_entry ac			; display ACP type id
	tstl	(sp)+				; cleanup stack
	rsb
ddb_no_acp:
	clrl	r0
	rsb

;**********
ddb_acpcls:
	movzbl	ddb$b_acpclass(r11), r2		; get ACP class
	beql	ddb_no_acp			; branch if none
	movab	ddb_acpclass, r3		; get translate table
	jsb	g^translate_address		; translate ACP class
	beql	90$				; branch if translate failed
	movl	r0, r2				; setup translated string
	do_column_entry ac, jmp			; display translation

90$:	movab	ddb$b_acpclass(r11), r2		; else, get class address
	do_column_entry ub, jmp			;  just display the value

;
; PRINT_COLUMNS tables for CRB display
;

crb_column_1:
	column_list -
		crb$, 16, 8, 4, <-
		<<Reference count>,w_refc,uw>, -
		<<Due time>,crb_timeout,crb$l_duetime>, -
		>

crb_column_2:
	column_list -
		crb$, 16, 8, 4, <-
		<<Wait queue>,l_wqfl,q2>, -
		<<Timeout rout.>,crb_timeout,crb$l_toutrout>, -
		>

crb_column_3:
	column_list -
		crb$, 16, 8, 0, <-
		<<Aux. struct.>,l_auxstruc,xl_neq>, -
		<<Timeout link>,crb_timeout,crb$l_timelink>, -
		>

;***********
crb_timeout:
	cmpb	#dc$_term, -			; terminals have a different
		crb_devclass			;  timeout scheme
	beql	90$				;  so don't do them
	tstl	crb$l_toutrout(r11)		; also don't bother unless
	beql	90$				;  a time out routine specified
	addl	r11, r2				; get datum address
	do_column_entry xl, jmp			;  and display it
90$:	clrl	r0				; or don't show anything
	rsb

	.save
	.psect	sdadata,noexe,wrt
crb_devclass:
	.long	0
	.restore

;
; PRINT_COLUMNS tables for VEC display
;

vec_column_1:
	column_list -
		vec$, 16, 8, 4, <-
		<<IDB address>,l_idb,xl>, -
		<<ADP address>,l_adp,xl_neq>, -
		<<Unit start rout.>,l_start,xl_neq>, -
		>

vec_column_2:
	column_list -
		vec$, 16, 8, 4, <-
		<<Datapath>,vec_datapath,0,10,14>, -
		<<Unit init.>,l_unitinit,xl_neq>, -
		<<Disc. rout.>,l_unitdisc,xl_neq>, -
		>

vec$l_intser = vec$q_dispatch+4
vec_column_3:
	column_list -
		vec$, 16, 8, 0, <-
		<<Map reg.>,vec_mapreg,0,11,13>, -
		<<Int. service>,l_intser,xl_neq>, -
		<<Ctrl. init.>,l_initial,xl_neq>, -
		>

;************
vec_datapath:
	bsbb	vec_test_uba			; is this a UNIBUS?
	subl	#<8+16>, sp			; make scratch space on stack
	movl	sp, r2				; point to string descriptor
	movl	#16, (r2)			; build string descriptor
	movab	8(r2), 4(r2)
	movab	null_ascic, r3			; assume no LWAE
	bbc	#vec$v_lwae, -			; branch if LWAE not on
		vec$b_datapath(r11), 10$
	movab	vec_lwae, r3			; else, change assumption
10$:	movab	null_ascic, r4			; assume no pathlock
	bbc	#vec$v_pathlock, -		; branch if path not locked
		vec$b_datapath(r11), 20$
	movab	vec_locked, r4			; else, change assumption
20$:	extzv	#vec$v_datapath, -		; extract data path number
		#vec$s_datapath, -
		vec$b_datapath(r11), r1
	$fao_s	-
		ctrstr = vec_fao_datapath, -	; convert everything to 
		outbuf = (r2), -		;  to a string
		outlen = (r2), -
		p1 = r1, -
		p2 = r3, -
		p3 = r4
	do_column_entry as			; put string in column
	addl	#<8+16>, sp			; cleanup stack
	rsb


;************
vec_test_uba:
	movl	vec$l_adp(r11), r0		; get ADP address
	beql	90$				; if none, its not a UBA
	getmem	adp$w_adptype(r0)		; get adapter type
	blbc	r0, 90$				; if error, its not a UBA
	cmpw	#at$_uba, r1			; is it a UBA?
	bneq	90$				; branch if not a UBA
	rsb					; else, return to caller
90$:	tstl	(sp)+				; if not a UBA, return a skip
	clrl	r0				;  this entry status to the
	rsb					;  action routines caller

;**********
vec_mapreg:
	bsbb	vec_test_uba			; is this a UBA?
	subl	#<8+16>, sp			; make scratch space on stack
	movl	sp, r2				; point to string descriptor
	movl	#16, (r2)			; build string descriptor
	movab	8(r2), 4(r2)
	movab	null_ascic, r4			; assume no map lock
	bbc	#vec$v_maplock, -		; branch if no map lock
		vec$w_mapreg(r11), 10$
	movab	vec_locked, r4			; else, change assumption
10$:	extzv	#vec$v_mapreg, #vec$s_mapreg, -	; extract starting map
		vec$w_mapreg(r11), r3		;  number
	$fao_s	-
		ctrstr = vec_fao_mapreg, -	; convert whole mess to a
		outbuf = (r2), -		;  string
		outlen = (r2), -
		p1 = r3, -
		p2 = vec$b_numreg(r11), -
		p3 = r4
	do_column_entry as			; put string in column
	addl	#<8+16>, sp			; cleanup stack
	rsb

;
; PRINT_COLUMNS tables for IDB display
;

idb_column_1:
	column_list -
		idb$, 16, 8, 4, <-
		<<CSR address>,l_csr,xl>, -
		<<Number of units>,w_units,uw>, -
		>

idb_column_2:
	column_list -
		idb$, 16, 8, 4, <-
		<<Owner UCB addr.>,l_owner,xl>, -
		<<Interrupt vector>,idb_vector,0,18,6>, -
		>

idb_column_3:
	column_list -
		idb$, 16, 8, 0, <-
		<<ADP address>,l_adp,xl>, -
		>

;**********
idb_vector:
	movzbl	idb$b_vector(r11), r0		; Obtain vector information
	beql	90$				; Branch if none present
	ashl	#2, r0, -(sp)			; Convert vector information
	movl	sp, r2				; Get converted info. addr.
	do_column_entry ow			; Display information
	tstl	(sp)+				; Cleanup stack
90$:	rsb					; Return to caller

;
; PRINT_COLUMNS tables for DDT display
;

ddt_column_1:
	column_list -
		ddt$, 16, 8, 4, <-
		<<Errlog buf sz>,w_errorbuf,uw>,-
		<<Start I/O>,ddt_address,ddt$l_start>, -
		<<Alt start I/O>,ddt_address,ddt$l_altstart>, -
		<<Cancel I/O>,ddt_address,ddt$l_cancel>, -
		>

ddt_column_2:
	column_list -
		ddt$, 16, 8, 4, <-
		<<Diag buf sz>,w_diagbuf,uw>, -
		<<Register dump>,ddt_address,ddt$l_regdump>, -
		<<Unit init>,ddt_address,ddt$l_unitinit>, -
		<<Unsol int>,ddt_address,ddt$l_unsolint>, -
		>

ddt_column_3:
	column_list -
		ddt$, 16, 8, 0, <-
		<<FDT size>,w_fdtsize,uw>, -
		<<FDT address>,l_fdt,xl>, -
		<<Mnt verify>,ddt_address,ddt$l_mntver>, -
		<<Cloned UCB>,ddt_address,ddt$l_cloneducb>, -
		>

;***********
ddt_address:
	addl	r11, r2				; get datum address
	cmpl	(r2), ioc$return		; is this the RSB routine?
	beql	90$				; branch if RSB routine
	do_column_entry xl, jmp			; else, output value
90$:	movab	ddt_return, r2			; for RSB routine, display
	do_column_entry ac, jmp			;  "return"

	.sbttl	show_system_block, show system/path blocks (SB/PB)
;---
;
;	show_system_block
;
;	This routine displays the system and path blocks given
;	the address of the system block.
;
;	4(ap) = SVA of the system block of interest
;---

show_system_block::
	.word	^m<r2,r3,r4,r5,r6,r7,r8>
	movab	buffer, r4				; get working buffer

; display system block

    	ensure	12
	getmem	@4(ap), (r4), #sb$k_length		; copy SB to local mem.
	retiferr
	pushl	4(ap)
    	pushab	sb$t_nodename(r4)			; node name
	print	1,<!_!_    --- !AC System Block (SB) !XL --->
	skip	1
	print_columns -
		buffer, 4(ap), -
		sb_column_1, sb_column_2
	skip	1


; display each path block

	assume	pb$k_length lt 512
	movl	sb$l_pbfl(r4), pb$l_flink(r4)		; init PB scan

pb_loop:
	addl3	#sb$l_pbfl, 4(ap), r0			; is there another PB?
	cmpl	pb$l_flink(r4), r0
	bneq	10$
	brw	end_pb					; branch if no PBs left
10$:	movl	pb$l_flink(r4), r8			; save new PB addr.
	getmem	(r8), (r4), #pb$k_length		; copy PB to local mem.
	retiferr
	ensure	12
	pushl	r8
	print	1,<!_!_    --- Path Block (PB) !XL --->
	skip	1
	movl	sp, r7					; save stack pointer
	alloc	80, r6					; allocate scratch
	movzwl	pb$w_sts(r4), -(sp)			; push PB STS
	pushab	pb_status				; push bit conv. data
	calls	#2, g^translate_bits			; translate PB STS
	pushl	r6					; push result
	movzwl	pb$w_sts(r4), -(sp)			; push PB STS
	print	2,<!_!_Status:  !XW  !AS>		; output PB STS
	movl	r7, sp					; restore stack
	skip	1
	print_columns -
		buffer, r8, -
		pb_column_1, pb_column_2
	skip	1
	brw	pb_loop

end_pb:
	ret
	.page
	.sbttl show_system_block tables & action routines

;  The following are all PRINT_COLUMNS action routines for the show 
;  system/path block displays.
;
;    Action Routine Inputs:
;
;	R2		value from the COLUMN_LIST entry
;	R5		size of value section for this item
;	R7		address of a descriptor for a scratch string in 
;			which the FAO converted value is to be returned
;	R11		base address of the local UCB copy
;
;    Action Routine Outputs:
;
;	R0		status
;			   lbs ==> use this entry
;			   lbc ==> skip this entry
;	R1 - R5		scratch
;			all other registers must be preserved

;
; FAO control strings, etc. used by the action routines
;

	.save		
	.psect	literals,exe,nowrt

sb_fao_6bytes:
	string	<!#* !XW!XL>

sb_fao_ascic:
	string	<!#* !#(AC)>

cddb_fao:
    	string  <!#* !XL>

null_ascic:
	.long	0

maint_ascic:
	.ascic	/MAINT_/

cbl_a_ascic:
	.ascic	/A-/

cbl_b_ascic:
	.ascic	/ B-/

ok_ascic:
	.ascic	/OK/

bad_ascic:
	.ascic	/BAD/

crossed_ascic:
	.ascic	/ Xed/

	.restore

;
; PRINT_COLUMNS tables for SB display
;

sb_column_1:
	column_list -
		sb$, 21, 12, 4, < -
		<<System ID>,sb_6bytes,sb$b_systemid>, -
		<<Max message size>,w_maxmsg,uw>, -
		<<Max datagram size>,w_maxdg,uw>, -
		<<Local hardware type>,sb_lwchar,sb$t_hwtype,29,4>, -
		<<Local hardware vers.>,sb_6bytes,sb$b_hwvers>, -
		<< >,sb_6bytes,sb$b_hwvers+6>, -
		>

sb$q_swincarn2 = sb$q_swincarn+4
sb_column_2:
	column_list -
		sb$, 21, 12, 0, < -
		<<Local software type>,sb_lwchar,sb$t_swtype,29,4>, -
		<<Local software vers.>,sb_lwchar,sb$t_swvers,29,4>, -
		<<Local software incarn.>,q_swincarn,xl,25,8>, -
		<< >,q_swincarn2,xl,25,8>, -
		<<SCS poller timeout>,w_timeout,xw>, -
		<<SCS poller enable mask>,b_enbmsk,xb,31,2>, -
		>

;**********
sb_6bytes:
	addl3	r2, r11, r3			; locate storage of interest
	subl	#12, r5				; get size of filler field
	$fao_s	-
		ctrstr = sb_fao_6bytes, -
		outbuf = (r7), -
		outlen = (r7), -
		p1 = r5, -
		p2 = 4(r3), -
		p3 = (r3)
	rsb

;**********
sb_lwchar:
	addl3	r2, r11, r3			; locate storage of interest
	clrl	-(sp)				; make scratch ASCIC space
    	tstb 	(r3)				; check for null string
    	beql	5$				; equal, null string
	pushl	#4				;  of the right size
10$:	movl	sp, r2				; save ASCIC pointer
	movl	(r3), 1(r2)			; put text in ASCIC string
	do_column_entry ac			; convert the ASCIC
	addl	#<2*4>, sp			; cleanup stack
	rsb

5$:	pushl	#0
    	brb	10$

;
; PRINT_COLUMNS tables for PB display
;

pb_column_1:
	column_list -
		pb$, 21, 12, 4, < -
		<<Remote sta. addr.>,sb_6bytes,pb$b_rstation>, -
		<<Remote state>,pb_rmtstate,0>, -
		<<Remote hardware rev.>,l_rport_rev,xl>, -
		<<Remote func. mask>,l_rport_fcn,xl>, -
		<<Reseting port>,b_rst_port,xb>, -
		<<Handshake retry cnt.>,w_retry,uw>, -
		<<Msg. buf. wait queue>,l_waitqfl,q2>, -
		>

pb_column_2:
	column_list -
		pb$, 21, 12, 4, < -
		<<Remote port type>,pb_rport_typ,0>, -
		<<Number of data paths>,pb_dualpath,0>, -
		<<Cables state>,pb_cables,0,18,15>,-
		<<Local state>,pb_lclstate,0>, -
		<<Port dev. name>,sb_lwchar,pb$t_lport_name,29,4>, -
		<<SCS MSGBUF address>,l_scsmsg,xl>, -
		<<PDT address>,l_pdt,xl>, -
		>

;***********
pb_rmtstate:
	movab	null_ascic, r4			; assume rport not in maint.
	assume	pb$v_maint eq 0			;  state
	blbc	pb$b_rstate(r11), 20$		; branch if rport not in maint.
	movab	maint_ascic, r4			; else, set maintenance flag
	subw	(r4), r5			;  and reduce the fill count
20$:	movab	pb_rstate, r3			; get remote state tbl. addr.
	extzv	#pb$v_state, #pb$s_state, -	; extract remote port state
		pb$b_rstate(r11), r2		;  information
	jsb	g^translate_address		; convert it to ASCIC pointer
	beql	90$				; branch if translation failed
	subb	(r0), r5			; reduce the fill count
	$fao_s	-
		ctrstr = sb_fao_ascic, -
		outbuf = (r7), -
		outlen = (r7), -
		p1 = r5, -
		p2 = #2, -
		p3 = r4, -
		p4 = r0
	rsb
90$:	movab	pb$b_rstate(r11), r2		; if cannot convert remote
	do_column_entry xb, jmp			;  status then display value

;************
pb_rport_typ:
	movab	pb_rport_type, r3		; get port type conversion
	assume	pb$v_port_typ eq 0
	assume	pb$s_port_typ eq 31
	bicl3	#^x80000000, -			; get remote port type value
		pb$l_rport_typ(r11), r2
	jsb	g^translate_address		; translate port type
	beql	90$				; branch if translation failed
	movl	r0, r2				; setup string for display
	do_column_entry ac, jmp			; display translated string

90$:	pushl	r2				; else, display just the port
	movl	sp, r2				;  type value
	do_column_entry xl
	tstl	(sp)+				; cleanup stack
	rsb

;***********
pb_dualpath:
	assume	pb$m_dualpath eq <^x80000000>
	extzv	#pb$v_dualpath, #1, -		; get paths flag for remote port
		pb$l_rport_typ(r11), r2
	addl3	#1, r2, -(sp)			; add one (there's at least one)
	movl	sp, r2				; get value pointer
	do_column_entry ul			; display value
	tstl	(sp)+				; cleanup stack
	rsb

;*********
pb_cables:
	assume	pb$v_cur_ps eq 0
	movl	#3, r4				; assume single path port
10$:	pushab	null_ascic
	sobgtr	r4, 10$

	subl	#4, r5				; adjust fill for path A
	pushab	ok_ascic			; assume path A is ok
	blbs	pb$b_p0_sts(r11), 25$		; branch if path A is ok
	movab	bad_ascic, (sp)			; else, change path A to bad
	decl	r5				; adjust fill for bad path
25$:	pushab	cbl_a_ascic			; insert "A-"

	assume	pb$m_dualpath eq <^x80000000>
	tstl	pb$l_rport_typ(r11)		; is this a dual pathed port?
	bgeq	40$				; branch if not dual pathed
	subl	#5, r5				; adjust fill for path B
	movab	ok_ascic, 12(sp)		; assume path B is ok
	blbs	pb$b_p1_sts(r11), 33$		; branch if path B is ok
	movab	bad_ascic, 12(sp)		; else, change path B to bad
	decl	r5				; adjust fill for bad path
33$:	movab	cbl_b_ascic, 8(sp)		; add " B-"
	assume	pb$v_cur_cbl eq 0
	blbs	pb$b_cbl_sts(r11), 40$		; branch if cables not crossed
	movab	crossed_ascic, 16(sp)		; else, add crossed cables flag
	subl	#4, r5				;  and adjust fill count

40$:	pushl	#5				; set number of ASCICs
	pushl	r5				; set fill count
	movl	sp, r4				; get parameter list pointer
	$faol_s	-
		ctrstr = sb_fao_ascic, -
		outbuf = (r7), -
		outlen = (r7), -
		prmlst = (r4)
	addl	#<7*4>, sp			; cleanup stack
	rsb

;***********
pb_lclstate:
	movab	pb_state, r3			; get port state conversion
	assume	pb$v_port_typ eq 0
	movzwl	pb$w_state(r11), r2		; get local port state
	jsb	g^translate_address		; translate port state
	beql	90$				; branch if translation failed
	movl	r0, r2				; setup string for display
	do_column_entry ac, jmp			; display trans. string

90$:	movab	pb$w_state(r11), r2		; else, display just the port
	do_column_entry xw, jmp			;  state value

	.sbttl	show_ucb, show unit control block (UCB)
;---
;
;	show_ucb
;
;	This routine shows the unit control block associated
;	with a device.
;
;
;	4(ap) = address of DDB in local storage
;	8(ap) = address of UCB in local storage
;	12(ap)= actual address of UCB
;	16(ap)= address of nodename in local storage
;	20(ap)= flags longword
;
;---

show_ucb:
	.word	^m<r2,r3,r4,r5,r6,r7,r8,r9,r10,r11>

	ensure	24
	pushl	12(ap)			; push virtual address of UCB

	movl	8(ap), r4		; get local address of UCB
	pushab	unknown			; assume the device will be unknown
	movzbl	ucb$b_devclass(r4), r2	; get device class value
	movab	device_class, r3	; get conversion table
	jsb	g^translate_address	; get address of device type table
	beql	90$			; branch if no class match
	movzbl	ucb$b_devtype(r4), r2	; get device type value
	movl	r0, r3			; get table address picked above
	jsb	g^translate_address	; get device type ASCIC address
	beql	90$			; branch if no device type matches
	movl	r0, (sp)		; else replace unknown with devtype
90$:	movq	4(ap), r2		; get DDB and UCB addresses

	movq	one_path, r10		; assume a single path device which
					; is not a virtual terminal

	cmpb	#dc$_term, -		; is this a terminal?
		ucb$b_devclass(r3)
	bneq	200$			; branch if not a terminal
	movl	ucb$l_tl_phyucb(r3), r4	; is this a virtual terminal?
	beql	7777$			; branch if not a virtual terminal
	cmpl	r4, 12(ap)		; does virt. term. equal phy. term.?
	beql	7777$			; if yes, then this not a virtual term.
	movq	virtual_terminal, r10	; it is a virtual terminal
	getmem	ucb$w_unit(r4)		; get physical terminal's unit number
	movzwl	r1, -(sp)		; push than unit number
	movab	ddb_2p, r5		; get work space for phy. DDB copy
	getmem	ucb$l_ddb(r4)		; get address of DDB for phy. UCB
	getmem	(r1), (r5), -		; get local copy of physical DDB
		#ddb$k_length
	pushab	ddb$t_name(r5)		; push address of phy. device name
7777$:	brw	setup_primary		; go setup virtual terminal name
					; (this is also a branch assist)

200$:	bitl	#dev$m_2p, -		; dual path device?
		ucb$l_devchar2(r3)
	beql	7777$			; branch if not dual path

	movq	this_primary, r10	; assume this path is primary
	movab	nodnam_2p, r9		; get node name workarea address
	movl	ucb$l_dp_altucb(r3), r4	; is there a local path?
	bneq	local_2p_device		; branch if local path

					; both paths through the class driver
	movzwl	ucb$w_unit(r3), -(sp)	; push secondary unit number
	movl	ucb$l_dp_ddb(r3), r5	; get secondary DDB address
	bbc	#flag_v_alt_path, -	; if scanning primary DDB chain,
		20(ap), process_2p_ddb	;  go join common code
	movl	ucb$l_ddb(r3), r5	; else, other DDB is primary DDB
	movq	this_secondary, r10	;  and this is the secondary path
	brb	process_2p_ddb		; go to common other path code

local_2p_device:			; only one path through the class driver
	getmem	ucb$w_unit(r4)		; get other path unit number
	movzwl	r1, -(sp)		; push other path unit number
	getmem	ucb$l_ddb(r4)		; get other path ddb address
	movl	r1, r5			; save ddb address in right place
	bbc	#dev$v_cdp, -		; branch if the path whose UCB is in
		ucb$l_devchar2(r3), -	; r3 is the primary path
		process_2p_ddb		; else indicate that first name is
	movq	this_secondary, r10	; the secondary path

process_2p_ddb:
	movab	ddb_2p, r4		; get workarea address for 2p DDB
	getmem	(r5), (r4), -		; pickup secondary DDB
		#ddb$k_length
	pushab	ddb$t_name(r4)		; push address of secondary device name
	movab	nodnam_2p, r9		; get workarea address fo 2p node name
	addl3	#sb$t_nodename, -	; locate secondary node name
		ddb$l_sb(r4), r0
	getmem	(r0), (r9), -		; pickup secondary node name
		#sb$s_nodename
	movzbl	r1, r1			; convert byte count to long word
	beql	setup_primary		; don't add "$" to null node name
	incl	r1			; add one for "$"
	movb	r1, (r9)		; store count in ASCIC string
	movb	#^a/$/, (r9)[r1]	; store "$" in string
	pushl	r9			; push node name pointer

setup_primary:
	pushl	ucb$w_unit(r3)		; unit number
	pushal	ddb$t_name(r2)		; generic controller name
	pushl	16(ap)			; address of nodename
	printd	r10, (r11)		; print device name and UCB
	skip	1
	movl	sp, r11			; save pre-allocation stack pointer
	alloc	80, r4			; allocate an output buffer
	pushl	ucb$l_sts(r3)		; push device status value
	pushab	unit_status		; bit definition table
	calls	#2,translate_bits	; translate bits into string
	pushl	r4			; result string
	pushl	ucb$l_sts(r3)		; push device status value
	print	2,<Device status:   !XL !AS>
	movzbl	#80, (r4)		; refresh output buffer descriptor
	pushl	ucb$l_devchar(r3)	; push device characteristics one
	pushab	device_char		; setup bit definition table
	calls	#2, translate_bits	; translate bits into string
	pushl	r4			; push result string
	pushl	ucb$l_devchar(r3)	; push device characteristics one
	print	2,<Characteristics: !XL !AS>
	movzbl	#80, (r4)		; refresh output buffer descriptor
	pushl	ucb$l_devchar2(r3)	; push device characteristics two
	pushab	device_char_2		; setup bit definition table
	calls	#2, translate_bits	; translate bits into string
	pushl	r4			; push result string
	pushl	ucb$l_devchar2(r3)	; push device characteristics two
	print	2,<                 !XL !AS>
	movl	r11, sp			; restore stack pointer
	skip	1

define_ucb_symbols:
	.enable lsb
	make_symbol UCB, 12(ap)
	make_symbol SB, ddb$l_sb(r2)
	make_symbol ORB, ucb$l_orb(r3)
	make_symbol DDB, ucb$l_ddb(r3)
	make_symbol DDT, ucb$l_ddt(r3)
	make_symbol CRB, ucb$l_crb(r3)
	tstl	ucb$l_amb(r3)
	beql	10$
	make_symbol AMB, ucb$l_amb(r3)
10$:	bbc	#ucb$v_bsy, ucb$l_sts(r3), 20$
	make_symbol IRP, ucb$l_irp(r3)
20$:
	.disable lsb

do_ucb_columns:
	movl	4(ap), ucb_ddb		; setup local DDB copy address
	print_columns -
		@8(ap), 12(ap), -
		ucb_column_1, ucb_column_2, ucb_column_3
	movq	8(ap),-(sp)		; push local,real address of UCB
    	bbc	#dev$v_mscp, ucb$l_devchar2(r3), 30$	  ; check to see if mscp served device
    	movw	#0,flag_2nd_cddb	; initialize flag to zero for primary
    	movl	ucb$l_cddb(r3),r6	; pass the address of the cddb by reg. 6
    	callg	(r3),show_cddb		; Display class driver data block
    	incw	flag_2nd_cddb		; set to 1 to indicate secondary
    	movl	ucb$l_2p_cddb(r3),r6	; pass the address of the secondary cddb
    	callg	(r3),show_cddb		; Display class driver data block
30$:	calls	#2,show_ioq		; Display I/O request queue
	callg	(r3),show_vcb		; Display volume control block
	ret
	.page
	.sbttl get_ucb, copy UCB to local storage

; This routine knows how to load enough of the UCB into local memory for
; the operations performed above, but how to avoid trying to load more
; UCB than there really is.
;
; Inputs:
;
;	r2	real UCB address
;	r7	address of the place to copy it to
;
; Outputs:
;
;	r0	status of the copy operation
;	r1	first longword of copied UCB


get_ucb:
    	pushr	#^m<r2,r3,r4,r5>	; save registers
    	movc5	#0,(sp),#0,#ucb_size,(r7)  ; zero out the local ucb
    	popr	#^m<r2,r3,r4,r5>	; restore registers
	trymem	ucb$w_size(r2)		; get size of this UCB
	blbc	r0, 90$			; exit now, if error occured
	movzwl	r1, r1			; extend size to a longword
	cmpl	r1, #ucb_size		; is UCB bigger than the local space?
	bleq	10$			; branch if not bigger
	movzwl	#ucb_size, r1		; else minimize the size
10$:	trymem	(r2), (r7), r1		; copy UCB to local storage
90$:	rsb				; return to caller
	.page
	.sbttl show_ucb tables & action routines

	.save		
	.psect	literals,exe,nowrt

;
; FAO control strings for locally generated UCB displays
;

one_path:
	.address 5, 10$
10$:	string	^\!40<!AC!AC!UW!>!17AC UCB address:  !XL\

this_primary:
	.address 8, 10$
10$:	string	^\!40<!AC!AC!UW (!AC!AC!UW)!>!17AC UCB address:  !XL\

this_secondary:
	.address 8, 10$
10$:	string	^\!40<(!AC!AC!UW) !AC!AC!UW!>!17AC UCB address:  !XL\

virtual_terminal:
	.address 7, 10$
10$:	string	^\!40<!AC!AC!UW ==> !AC!UW!>!17AC UCB address:  !XL\

unknown:
	.ascic	/Unknown/

;
; FAO control strings used by the action routines
;

ucb_uic_cstr1:
	string	<[!6OW,!6OW]>

ucb_two_bytes:
	string	<!5XB/!2XB>

ucb_retry_fao:
	string	<!#UB/!UB>

ucb_test_retry_fao:
	string	<!UB>

	.restore

;
;  PRINT_COLUMNS tables for UCB display
;

ucb_column_1:
	column_list -				; column 1 -- allocation 
		ucb$, 17, 8, 3, < -		;    and other device status
		<<Owner UIC>,orb_owner,0,10,15>, -	; Owner UIC
		<<      PID>,l_pid,xl>, -		; Owner PID
		<<Alloc. lock ID>,ucb_lockid,0>, -	; Allocation lock ID
		-					; Allocation class
		<<Alloc. class>,ucb_alloclass,ucb_ddb>, -
		<<Class/Type>,ucb_clstyp,0>, -		; Device class/type
		<<Def. buf. size>,w_devbufsiz,uw>, - 	; default buffer size
		<<DEVDEPEND>,l_devdepend,xl>, -		; Device dependent first
		<<DEVDEPND2>,l_devdepnd2,xl>, -		;   "        "     sec.
		<<FIPL/DIPL>,ucb_ipls,0>, -		; Fork / Device IPL
		<<Charge PID>,ucb_cpid,0>, -		; UCB size charge PID
		>				; *** end column 1

	.save
	.psect	sdadata,noexe,wrt
ucb_ddb:
	.long	0
	.restore

ucb_column_2:					
	column_list -				; column 2 -- device activity
		ucb$, 18, 8, 3, < -		;    data
		<<Operation count>,l_opcnt,ul>, - ; operations completed
		<<Error count>,w_errcnt,uw>, -	; errors recorded count
		<<Reference count>,w_refc,uw>, -; reference count
		<<Online count>,ucb_onlcnt,0>, -; online count
		<<Retry cnt/max>,ucb_retry,0>, -; error retry count/maximum
		<<BOFF>,w_boff,xw>, -		; byte offset
		<<Byte count>,w_bcnt,xw>, -	; byte count
		<<SVAPTE>,l_svapte,xl>, -	; system virtual addr. PTE
		<<SVPN>,ucb_svpn,0> -		; system virtual page number
		<<DEVSTS>,w_devsts,xw>, -	; Device dependent status
		<<Master CSID>,ucb_mcsid,0>, -	; Master node's CSID
		<<Int. due time>,ucb_duetim,0>, - ; Interrupt due time
		<<RWAITCNT>,ucb_rwaitcnt,0> -	; Reasons to wait count
		>				; *** end column 2

ucb_column_3:
	column_list -				; column 3 -- pointer addresses
		ucb$, 15, 8, 0, < -
		<<ORB address>,l_orb,xl>, -	; Object's rights block
		<<DDB address>,l_ddb,xl>, -	; Device data block
		<<DDT address>,l_ddt,xl>, -	; Driver dispatch table
		<<VCB address>,ucb_vcb,0>, -	; Volume control block
		<<CRB address>,l_crb,xl>, -	; Channel request block
		<<LNM address>,ucb_lnm,0>, -	; MBX LNM pointer
		<<AMB address>,l_amb,xl_neq>, -	; Associated mailbox
		<<PDT address>,ucb_pdt,0>, -	; Port descriptor table
    		<<CDDB address>,ucb_cddb,0>,-	; Class driver data block
    		<<2P_CDDB addr.>,ucb_2pcddb,0>,-; Alternate CDDB
		<<2P_DDB address>,ucb_2pddb,0>, -; Secondary path DDB
		<<2P_UCB address>,ucb_altucb,0>,-; Alternate UCB
		-				; All of the following appear
		-				;  only when the UCB is busy
		<<IRP address>,ucb_bsy,ucb$l_irp>, -	; I/O request packet
		<<Fork PC>,ucb_bsy,ucb$l_fpc>, -	; Fork PC
		<<Fork R3>,ucb_bsy,ucb$l_fr3>, -	; Fork R3
		<<Fork R4>,ucb_bsy,ucb$l_fr4>, -	; Fork R4
		<<I/O wait queue>,l_ioqfl,q2>, -	; Pending I/O queue
		>				; *** end column 3

;  The following are all PRINT_COLUMNS action routines for the UCB
;  display.
;
;    Action Routine Inputs:
;
;	R2		value from the COLUMN_LIST entry
;	R5		size of value section for this item
;	R7		address of a descriptor for a scratch string in 
;			which the FAO converted value is to be returned
;	R11		base address of the local UCB copy
;
;    Action Routine Outputs:
;
;	R0		status
;			   lbs ==> use this entry
;			   lbc ==> skip this entry
;	R1 - R5		scratch
;			all other registers must be preserved

;*************
ucb_alloclass:	; if appropriate, return allocation class
	bbc	#dev$v_fod, -			; branch if not a file oriented
		ucb$l_devchar(r11), ucb_act_nop	;  device
	addl3	#ddb$l_allocls, (r2), r2	; get allocation class address
ucb_act_ub:					; display allocation class
	do_column_entry ub, jmp

;**********
ucb_altucb:
	bbc	#dev$v_2p, ucb$l_devchar2(r11), - ; branch if device is not
		ucb_act_nop			  ;  dual pathed
	moval	ucb$l_dp_altucb(r11), r2	; alternate UCB address
	tstl	(r2)				; is there something there?
	beql	ucb_act_nop			; branch if nothing there
	make_symbol -				; else,
		2P_UCB, (r2)			;  make a symbol and
	brw	ucb_act_xl			;  display it

;%%%%%%%
ucb_bsy:
	bbc	#ucb$v_bsy, ucb$l_sts(r11), -	; exit doing nothing if the
		ucb_act_nop			;  UCB is not busy
	addl	r11, r2				; else locate cell to return
ucb_act_xl_neq:
	do_column_entry xl_neq, jmp		; display that entry

;**********
ucb_clstyp:	; return device class / type
	movzbl	ucb$b_devclass(r11), r2		; return device class
	movzbl	ucb$b_devtype(r11), r3		;  and device type
	brb	ucb_ret_2xbytes			; go join common code

;********
ucb_cpid:	; if appropriate, return PID charged for UCB creation
	bitl	#<dev$m_mbx ! dev$m_net>, -	; is this a mailbox or a
		ucb$l_devchar(r11)		;  network device
	beql	ucb_act_nop			; if not, assume no PID charged
	moval	ucb$l_cpid(r11), r2		; else, return charged PID
	brb	ucb_act_xl			; using common code

ucb_act_nop:
	clrl	r0				; make this call a nop
	rsb					; return

;**********
ucb_duetim:	; if appropriate, return interrupt due time
	bbc	#ucb$v_tim, -			; branch if time-out not
		ucb$l_sts(r11), ucb_act_nop	;  expected
	moval	ucb$l_duetim(r11), r2		; else return due time
	brb	ucb_act_xl			; join common code

;********
ucb_ipls:	; return fork / device IPL
	movzbl	ucb$b_fipl(r11), r2		; return fork IPL
	movzbl	ucb$b_dipl(r11), r3		;  and device IPL
ucb_ret_2xbytes:
	$fao_s	-				; two values as requested
		ctrstr = ucb_two_bytes,  -
		outbuf = (r7), -
		outlen = (r7), -
		p1 = r2, -
		p2 = r3
	rsb					; return

;*******
ucb_lnm:
	cmpb	#dc$_mailbox, -			; is this a mailbox?
		ucb$b_devclass(r11)
	bneq	ucb_act_nop			; branch if not a mailbox
	moval	ucb$l_logadr(r11), r2		; get logical name pointer
	tstl	(r2)				; is something there?
	beql	ucb_act_nop			; branch if nothing there
	make_symbol -				; else,
		LNM, (r2)			;  make a symbol and
	brb	ucb_act_xl			;  display it

;**********
ucb_lockid:	; if sensible, return allocation lock id
	bbc	#dev$v_clu, -			; branch if not a cluster
		ucb$l_devchar2(r11), ucb_act_nop ;  accessible device
	moval	ucb$l_lockid(r11), r2		; else return lock id
ucb_act_xl:
	do_column_entry xl, jmp

;*********
ucb_mcsid:
	cmpb	#dc$_journal, -			; is this a journal device?
		ucb$b_devclass(r11)
	bneq	ucb_act_nop			; branch if not a journal dev.
	moval	ucb$l_jnl_mcsid(r11), r2	; else, return master CSID
	brb	ucb_act_xl			;  using common code

;**********
ucb_onlcnt:
	cmpb	#dc$_disk, ucb$b_devclass(r11)	; is this a disk device?
	bneq	ucb_act_nop_a			; branch if not a disk
	movab	ucb$b_onlcnt(r11), r2		; else get online count addr.
	brw	ucb_act_ub			;  and display it

;**********
orb_owner:	; attempt to format owner UIC
	clrl	-(sp)				; storage for the UIC from ORB
	movl	sp,r2				; save address for later
	movl	ucb$l_orb(r11),r1		; get real ORB address
	beql	10$				; display [0,0] if no ORB
	getmem	orb$l_owner(r1)			; get the owner UIC
	blbc	r0,10$				; display [0,0] if unaccessable
	movl	r1,(r2)				; save for $FAO below
	ASSUME	ORB$L_OWNER EQ 0
10$:	$fao_s	-				; convert UIC to octal
		ctrstr = ucb_uic_cstr1, -
		outbuf = (r7), -
		outlen = (r7), -
		p1 = orb$w_uicgroup(r2), -
		p2 = orb$w_uicmember(r2)
	tstl	(sp)+				; clean the stack
	rsb					; return

;*******
ucb_pdt:
	movl	ucb$l_pdt(r11), r3		; get possible PDT address
	beql	ucb_act_nop_a			; branch if none
	getmem	ucb$b_type(r3)			; get type and sub-type of PDT
	cmpw	#<dyn$c_scs_pdt@8 -		; is thing pointed to really
		 + dyn$c_scs>, r1		;  a PDT?
	bneq	ucb_act_nop_a			; branch if not really a PDT
	moval	ucb$l_pdt(r11), r2		; get address of PDT pointer
	make_symbol -
		PDT, (r2)			;  make a symbol and
	brw	ucb_act_xl			;  display it


ucb_act_nop_a:
	clrl	r0
	rsb

;*********
ucb_cddb:
    	bbc	#dev$v_mscp,ucb$l_devchar2(r11),-
    		ucb_act_nop_a			; branch if device is not mscp served
    	moval	ucb$l_cddb(r11),r2		; get address of CDDB pointer
    	make_symbol -
    		CDDB, (r2)			; make a symbol and
    	brw	ucb_act_xl			; display it

;*********
ucb_2pcddb:
    	bbc	#dev$v_mscp,ucb$l_devchar2(r11),-
    		ucb_act_nop_a			; branch if device is not mscp served
    	moval	ucb$l_2p_cddb(r11),r2		; alternate CDDB address
    	tstl	(r2)				; is there a secondary cddb
    	beql	ucb_act_nop_a			; branch if not
    	make_symbol -
    		2P_CDDB, (r2)			; make a symbol and
    	brw	ucb_act_xl			; display it
    	
;*********
ucb_retry:
	tstb	ucb$b_ertmax(r11)		; is there a retry max?
	beql	ucb_act_nop_a			; quit now, if no retry max
	clrl	-(sp)				; make a little room on stack
	movl	sp, r2				; save its address
	$fao_s	-
		ctrstr = ucb_test_retry_fao, -	; determine size of 
		outbuf = (r7), -		;  retry max
		outlen = (r2), -
		p1 = ucb$b_ertmax(r11)
	incl	(sp)				; add one to retry max size
	subl	(sp)+, r5			; reduce retry cnt. size by that
	$fao_s	-
		ctrstr = ucb_retry_fao, -	; now produce the whole value
		outbuf = (r7), -
		outlen = (r7), -
		p1 = r5, -
		p2 = ucb$b_ertcnt(r11), -
		p3 = ucb$b_ertmax(r11)
	rsb					; then return

;************
ucb_rwaitcnt:
    	bbc	#dev$v_mscp,ucb$l_devchar2(r11),-
    		ucb_act_nop_b			; branch if device is not mscp served
    	moval	ucb$w_rwaitcnt(r11),r2		; get address of wait count
    	make_symbol -
    		RWAITCNT,(r2)			; make a symbol and
ucb_act_xw:
    	do_column_entry xw,jmp

;********
ucb_svpn:
	cmpb	#dc$_mailbox, -			; is this a mailbox? (they
		ucb$b_devclass(r11)		;  don't have SVPN's)
	beql	ucb_act_nop_b			; branch if mailbox
	moval	ucb$l_svpn(r11), r2		; get SVPN address
	brw	ucb_act_xl_neq			;  display it if non-zero

;*******
ucb_vcb:
	bitl	#<dev$m_mnt ! dev$m_dmt>, -	; is the device mounted?
		ucb$l_devchar(r11)
	beql	ucb_act_nop_b			; branch if not mounted
	moval	ucb$l_vcb(r11), r2
	make_symbol -				; else,
		VCB, (r2)			;  make a symbol and
	brw	ucb_act_xl			;  and display it

;*********
ucb_2pddb:
	bbc	#dev$v_2p, ucb$l_devchar2(r11), - ; branch if device is not
		ucb_act_nop_b			  ;  dual pathed
	moval	ucb$l_dp_ddb(r11), r2		; secondary DDB address
	make_symbol -
		2P_DDB, (r2)			; make a symbol and
	brw	ucb_act_xl_neq			;  display it

ucb_act_nop_b:
	clrl	r0
	rsb


	.sbttl	show_ioq, Display I/O queue for device
;---
;
;	show_ioq
;
;	Display the IRPs and/or CDRP's (if mscp served) in the I/O queues
;       associated with	a specified device.
;
; Inputs:
;
;	4(ap) = Address of UCB in local storage
;	8(ap) = Actual address of UCB
;
;---
	.enabl	lsb

show_ioq:
	.word	^m<r2,r3,r4,r5,r6,r7,r8>

	movl	4(ap),r2		; address of UCB
	bbc	#dev$v_mscp,ucb$l_devchar2(r2),5$
					; only 1 queue if not mscp served
	movab	cddb,r7			; address of Class Driver Data Block
    	getmem  @ucb$l_cddb(r2),(r7),#cddb$c_length   ; read CDDB
    	blbc	r0,8$			; branch if cannot read entire CDDB
	addl3	#cddb$l_cdrpqfl,ucb$l_cddb(r2),r4	; Get real address of cdrp queue header
	cmpl	cddb$l_cdrpqfl(r7),r4	; Empty CDRP queue?
	bneq	10$			; branch if not empty
4$:    	addl3	#cddb$l_rstrtqfl,ucb$l_cddb(r2),r4  ; Get real address of restart queue
    	cmpl 	cddb$l_rstrtqfl(r7),r4	; Empty restart queue
    	bneq	30$			; branch if not empty
5$:	addl3	#ucb$l_ioqfl,8(ap),r4	; Get real address of queue header
	cmpl	ucb$l_ioqfl(r2),r4	; Empty i/o queue?
	bneq	7$			; Branch if not
	bbs	#ucb$v_bsy,ucb$w_sts(r2),7$  ; Branch if have IRP
    	tstb	queue_notempty		; if 0 all queues are empty
    	bneq	8$			; if 1 then at least 1 queue was not empty
	skip	1
	print	0,<!_*** I/O request queue is empty ***>
	ret

7$:	brw	50$			; process io request queue
8$:	brw	90$			; clear queue flag and return

;	Queue - Class Driver Request Packet Queue (CDRP)
;
10$:	movl	cddb$l_cdrpqfl(r7),r3	; Get address of first entry in queue
    	movl	#1,r6			; Set state to current
    	movl	8(ap),r8		; pass actual address of ucb in r8
20$:	bsbw	print_cdrp		; display the contents of the cdrp
	movl	cdrp$l_fqfl(r5),r3	; advance to next entry in queue
    	cmpl	r3,r4			; check to see if another entry exists
    	beql	4$			; if points back to beginning no more
    	brb	20$			; process this entry in queue
;
;	Queue - Restarted Class Driver Request Packet Queue (RSTRTQ)
;
30$:	movl	cddb$l_rstrtqfl(r7),r3	; Get first entry in queue
    	movl	#2,r6			; State is restart
    	movl	8(ap),r8		; pass actual address of ucb in r8
40$:   	bsbw	print_cdrp		; Call routine to display this cdrp
   	movl	cdrp$l_fqfl(r5),r3	; Advance to next entry in queue
    	cmpl	r3,r4			; Check to see if no more entries in queue
    	bneq	40$			; if eql branch to check next queue
    	brw	5$			; otherwise still more entries here to process
;
;	Queue - Standard IO Request Packet Queue (IRP)
;
50$:	tstb	queue_notempty		; Check to see if anyone set this flag
    	bneq	55$			; if 1 then yes so don't bother with it
    	bsbw	queue_title		; print header for page (IO Request Queue)
    	movb	#1,queue_notempty	; set flag to indicate queue was not empty
55$:	bbc	#ucb$v_bsy,ucb$w_sts(r2),60$	; Branch if not busy
	movl	ucb$l_irp(r2),r3	; Address of current IRP
	movl	#1,r6			; Indicate current IRP
	bsbw	print_irp		; Print line for current IRP

60$:	movl	ucb$l_ioqfl(r2),r3	; Get address of first IRP in queue
	clrl	r6			; Indicate not current IRP

70$:	cmpl	r3,r4			; end of queue?
	beql	90$			; Branch if so
	bsbw	print_irp		; print IRP line
	movl	irp$l_ioqfl(r5),r3	; Skip to next IRP in queue
	brb	70$

90$:	clrb	queue_notempty		; clear flag before we are called again
	status	success
	ret
	.dsabl	lsb

	.sbttl	show_acpq, display acp queue
;---
;
;	show_acpq
;
;	Display the IRP queue associated with the ACP
;	on the current volume.
;
; Inputs:
;
;	ap = address of VCB in local storage
;
;---
	.enabl	lsb

show_acpq:
	.word	^m<r2,r3,r4,r5,r6>

	tstl	vcb$l_aqb(ap)		; Is there any AQB?
	bneq	10$			; Branch if so
90$:	brw	95$			; Exit

10$:	movab	aqb,r2
	getmem	@vcb$l_aqb(ap),(r2),#aqb$c_length  ; Read entire AQB
	blbc	r0,90$
	ensure	11
	pushl	vcb$l_aqb(ap)
	skip	1
	print	1,<!_!_    --- ACP Queue Block (AQB) !XL --->
	skip	1
	tstl	aqb$l_acppid(r2)	; Is the XQP servicing this queue?
	beql	20$			; Branch if XQP
	getmem	@sch$gl_pcbvec,r3	; Get address of PCB vector
	blbc	r0,30$
	cvtwl	aqb$l_acppid(r2),r1	; Extract process index
	moval	(r3)[r1],r1		; Point to PCB address entry
	getmem	(r1)			; Read PCB address
	blbc	r0,30$
	movab	buffer,r3
	getmem	pcb$t_lname(r1),(r3),#16  ; Read 16-byte process name
	blbc	r0,30$
	pushl	aqb$l_acppid(r2)	; Process PID
	pushl	r3			; Address of ASCIC string
	print	1,<ACP requests are serviced by process !AC whose PID is !XL>
	brb	30$

20$:	print	0,<ACP requests are serviced by the eXtended Qio Processor (XQP)>

30$:	skip	1
	alloc	80			; 80 byte string buffer
	movzbl	aqb$b_status(r2),-(sp)	; ACP status
	pushab	acp_status		; Bit definition table
	calls	#2,translate_bits	; Translate bits into names
	pushl	sp			; Address of string descriptor
	pushl	aqb$b_status(r2)	; ACP status
	print	2,<Status: !XB !AS>
	skip	1
	print_columns -
		(r2), vcb$l_aqb(ap), -
		aqb_column_1, aqb_column_2, aqb_column_3

	skip	1
	movl	aqb$l_acpqfl(r2),r3	; Get address of first IRP
	addl3	#aqb$l_acpqfl,vcb$l_aqb(ap),r4	; Get real address of queuehead
	cmpl	r3,r4			; Empty ACP queue?
	bneq	70$			; Branch if not
	print	0,<!_*** ACP request queue is empty ***>
	ret

70$:	ensure	8
	print	0,<!_!_!_!_ACP request queue>
	print	0,<!_!_!_!_----------------->
	skip	1
	bsbw	irp_heading		; Print heading line
	clrl	r6			; Indicate not current IRP

80$:	cmpl	r3,r4			; End of queue?
	beql	95$			; Branch if so
	bsbw	print_irp		; Print IRP line
	movl	irp$l_ioqfl(r5),r3	; skip to next IRP
	brb	80$

95$:	status	success
	ret
	.dsabl	lsb
	.sbttl volume control block tables & action routines

;  The following are all PRINT_COLUMNS action routines for the show_vcb
;  block displays.
;
;    Action Routine Inputs:
;
;	R2		value from the COLUMN_LIST entry
;	R5		size of value section for this item
;	R7		address of a descriptor for a scratch string in 
;			which the FAO converted value is to be returned
;	R11		base address of the local UCB copy
;
;    Action Routine Outputs:
;
;	R0		status
;			   lbs ==> use this entry
;			   lbc ==> skip this entry
;	R1 - R5		scratch
;			all other registers must be preserved


;
; PRINT_COLUMNS tables for AQB display
;

aqb_column_1:
	column_list -
		aqb$, 16, 8, 4, < -
		<<Mount count>,b_mntcnt,ub>, -
		>

aqb_column_2:
	column_list -
		aqb$, 16, 8, 4, < -
		<<ACP type>,aqb_type,0,14,10>, -
		<<ACP class>,aqb_class,0>, -
		>

aqb_column_3:
	column_list -
		aqb$, 16, 8, 0, < -
		<<Linkage>,l_link,xl_neq>, -
		<<Request queue>,l_acpqfl,q2>, -
		>

;**********
aqb_type:
	movzbl	aqb$b_acptype(r11), r2		; get ACP type
	movab	aqb_acptype, r3			; get translate table
	jsb	g^translate_address		; translate ACP class
	beql	90$				; branch if translate failed
	movl	r0, r2				; setup translated string
	do_column_entry ac, jmp			; display translation

90$:	movab	aqb$b_acptype(r11), r2		; else, get type address
	do_column_entry ub, jmp			;  just display the value

;**********
aqb_class:
	movzbl	aqb$b_class(r11), r2		; get ACP class
	beql	90$				; branch if none
	movab	ddb_acpclass, r3		; get translate table
	jsb	g^translate_address		; translate ACP class
	beql	90$				; branch if translate failed
	movl	r0, r2				; setup translated string
	do_column_entry ac, jmp			; display translation

90$:	movab	ddb$b_acpclass(r11), r2		; else, get class address
	do_column_entry ub, jmp			;  just display the value

	.sbttl	print_cdrp, print a single CDRP block
;---

	.enabl	lsb
;
;	Subroutine to print information for a single CDRP block
;
; Inputs:
;
;	r3 = Dump address of CDRP block
;	r6 = 2, if restarted CDRP, 1 if current CDRP 
;	r8 = Actual address of UCB
;
; Outputs:
;
;	r5 = Address of CDRP in local storage
;
;---

print_cdrp:
	ensure	3
    	pushl	r6			; save r6 
    	addl3	#cdrp$l_ioqfl,r3,r6	; get start of cdrp at most negative offset
	movab	cdrp,r5			; get address of local cdrp
	getmem	(r6),(r5),#cdrp_length	; read entire CDRP 
    	popl	r6			; restore r6
	blbs	r0,5$			; check status
    	brw	90$			; return
5$:    	subl2	#cdrp$l_ioqfl,r5	; actual start of CDRP
	cmpl	r8,cdrp$l_ucb(r5)	; check to see if this request is from this device
    	beql	10$			; if equal yes so process it
    	brw	90$			; return
10$:	tstb	queue_notempty		; Check to see if anyone set this flag
    	bneq	15$			; If 1 then yes so don't bother with it
    	bsbw    queue_title		; Otherwise display the header for page
    	movb	#1,queue_notempty	; set flag to say this queue was not empty
15$:	pushl	cdrp$w_sts(r5)		; request status
	pushl	cdrp$l_iosb(r5)		; address of IOSB
	pushl	cdrp$l_ast(r5)		; address of AST routine
	pushl	cdrp$b_efn(r5)		; Event flag number
	pushl	cdrp$l_wind(r5)		; Address of WCB
	pushl	cdrp$w_func(r5)		; Function code
	pushl	cdrp$w_chan(r5)		; Channel number
	extzv	#irp$v_mode,#irp$s_mode,cdrp$b_rmod(r5),r0
	pushl	#^a'KESU'		; Possible user modes
	pushab	(sp)[r0]		; Address of string
	pushl	#1			; Length of string
	pushl	cdrp$l_pid(r5)		; Process identification
	pushl	r3			; Address of CDRP
	pushl	#^a'C'			; String containing space
	pushl	sp			; Address of string
	pushl	#1			; Length of string
	cmpl	#1,r6			; check if current CDRP
	beql	20$			; branch if not
	movl	#^a'R',8(sp)		; Flag current CDRP being done
20$:	print	15,< !AD!+    !XL  !XL  !AD!+  !XW  !XW  !XL  !2UB  !XL  !XL  !XW>

; save a few registers now.  Then we will allocate stack space for two output
; buffers.  Translate the class driver's flags field, the status field of the
; cdrp, and the function code for the request.  Then display.
;
	movq	r2, -(sp)		; save some registers
	alloc	80,r2			; 80 byte output buffer for request status
    	alloc	80,r3			; another buffer of 80 bytes
    	movl	cdrp$l_dutuflags(r5),-(sp)  ; cdrp flags
    	pushab	cdrp_dutuflags		; bit definition table
    	calls	#2,translate_bits	; translate bits to names
    	pushl	sp			; push the address of descriptor
    	pushl	4(r2)			; push descriptor for request status
    	pushl	(r2)			; push size of this buffer
	movzwl	cdrp$w_sts(r5),-(sp)	; request status
	pushab	request_status		; bit definition table
	calls	#2,translate_bits	; translate bits to names
	pushl	sp			; address of string descriptor
	pushab	null_ascic		; assume function will not translate
	extzv	#io$v_fcode, #io$s_fcode, -
		cdrp$w_func(r5), r2	; get function code
	movab	io_function, r3		; get translation table
	jsb	g^translate_address	; translate function to text
	beql	33$			; branch if translate failed
	movl	r0, (sp)		; setup translated function
33$:	print	3,<!_!AC !AS!+!+ !AS>	; print translated information
	skip	1			; advance
	addl	#184,sp			; deallocate translate buffers
	movq	(sp)+, r2		; restore saved registers

90$:	rsb

	.sbttl	print_irp, print a single IRP block
;---

	.enabl	lsb
;
;	Subroutine to print information for a single IRP block
;
; Inputs:
;
;	r3 = Dump address of IRP block
;	r6 = 1 if current IRP, else 0 if pending
;
; Outputs:
;
;	r5 = Address of IRP in local storage
;
;---

queue_title:
	ensure	10
	print	0,<!_!_!_!_I/O request queue>
	print	0,<!_!_!_!_----------------->
	skip	1
    	bbs	#dev$v_mscp,ucb$l_devchar2(r2),cdrp_heading
irp_heading:
	print	0,<STATE    IRP      PID   MODE CHAN  FUNC    WCB     EFN    AST     IOSB    STATUS>
	skip	1
999$:	rsb

cdrp_heading:
	print	0,<STATE CDRP/IRP    PID   MODE CHAN  FUNC    WCB     EFN    AST     IOSB    STATUS>
    	skip 	1
    	rsb

print_irp:
	ensure	3
	movab	irp,r5
	getmem	(r3),(r5),#irp$c_length	; read entire IRP
	blbc	r0,999$
	pushl	irp$w_sts(r5)		; request status
	pushl	irp$l_iosb(r5)		; address of IOSB
	pushl	irp$l_ast(r5)		; address of AST routine
	pushl	irp$b_efn(r5)		; Event flag number
	pushl	irp$l_wind(r5)		; Address of WCB
	pushl	irp$w_func(r5)		; Function code
	pushl	irp$w_chan(r5)		; Channel number
	extzv	#irp$v_mode,#irp$s_mode,irp$b_rmod(r5),r0
	pushl	#^a'KESU'		; Possible user modes
	pushab	(sp)[r0]		; Address of string
	pushl	#1			; Length of string
	pushl	irp$l_pid(r5)		; Process identification
	pushl	r3			; Address of IRP
	pushl	#^a'P'			; String containing space
	pushl	sp			; Address of string
	pushl	#1			; Length of string
	tstl	r6			; check if current IRP
	beql	20$			; branch if not
	movl	#^a'C',8(sp)		; Flag current IRP being done
20$:	print	15,< !AD!+   !XL  !XL  !AD!+   !XW  !XW  !XL  !2UB  !XL  !XL  !XW>

	movq	r2, -(sp)		; save some registers
	alloc	80			; 80 byte output buffer
	movzwl	irp$w_sts(r5),-(sp)	; request status
	pushab	request_status		; bit definition table
	calls	#2,translate_bits	; translate bits to names
	pushl	sp			; address of string descriptor
	pushab	null_ascic		; assume function will not translate
	extzv	#io$v_fcode, #io$s_fcode, -
		irp$w_func(r5), r2	; get function code
	movab	io_function, r3		; get translation table
	jsb	g^translate_address	; translate function to text
	beql	33$			; branch if translate failed
	movl	r0, (sp)		; setup translated function
33$:	print	2,<!_!AC !AS>		; print translated information
	skip	1
	addl	#88,sp			; deallocate translate buffer
	movq	(sp)+, r2		; restore saved registers

90$:	rsb

	.dsabl	lsb

	.sbttl	show_vcb, Display Volume Control Block (VCB)
;---
;
;	show_vcb
;
;	Display the Volume Control Block (VCB)
;
; Inputs:
;
;	ap = Address of UCB in local storage
;
;---

show_vcb:
	.word	^m<r2,r3,r4,r5,r11>

	tstl	ucb$l_vcb(ap)		; any VCB for this unit?
	bneq	10$			; Branch if so

90$:	status	success
	ret

10$:	bbs	#dev$v_spl,ucb$l_devchar(ap),90$  ; ignore VCB for
					; spooled devices (wrong usage)
	movab	vcb,r2
	getmem	@ucb$l_vcb(ap),(r2),#vcb$c_length ; read entire VCB
	blbc	r0,90$
	cmpb	vcb$b_type(r2),#dyn$c_vcb	; Check if block valid
	bneq	90$			; Exit if not valid type

	ensure	12
	skip	1
	pushl	ucb$l_vcb(ap)
	print	1,<!_!_--- Volume Control Block (VCB) !XL --->
	skip	1
	alloc	80			; 80 byte output buffer
	movl	sp, r11			; save descriptor address

	; use different display stratagies for different VCB types
	bbc	#dev$v_net, ucb$l_devchar(ap), 20$
	brw	vcb_net
20$:	dispatch ucb$b_devclass(ap), type=B, prefix=dc$_, <-
		<disk,vcb_disk>, -
		<tape,vcb_tape>, -
		<journal,vcb_journal> -
		>
	status	success
	ret

vcb_disk:
	bbc	#dev$v_for, -		; Is this a foreign mounted disk?
		ucb$l_devchar(ap), 20$
	brw	vcb_foreign		; Branch if foreign.
20$:	pushal	vcb$t_volcknam(r2)	; Address of volume lock name
	pushl	#12			; Length of volume lock name
	pushal	vcb$t_volname(r2)	; Address of volume name
	pushl	#12			; Length of volume name
	print	2,<Volume: !AD     Lock name: !AF>
	movl	r11, sp			; Setup scratch area
	movzbl	vcb$b_status(r2), -(sp)	; Volume status
	pushab	vcb_disk_status		; Bit definition table
	calls	#2, translate_bits	; Translate bits to names
	pushl	sp			; Address of output descriptor
	pushl	vcb$b_status(r2)
	print	2,<Status:  !XB !AS>
	movl	r11, sp			; Setup scratch area
	movzbl	vcb$b_status2(r2), -(sp); Volume status, second byte
	pushab	vcb_disk_status2	; Bit definition table
	calls	#2, translate_bits	; Translate bits to names
	pushl	sp			; Address of output descriptor
	pushl	vcb$b_status2(r2)
	print	2,<Status2: !XB !AS>
	skip	1
	print_columns -
		(r2), ucb$l_vcb(ap), -
		vcb_disk_col_1, vcb_disk_col_2, vcb_disk_col_3
	brw	vcb_show_acpq

	.enable lsb
vcb_tape:
vcb_foreign:
	pushal	vcb$t_volname(r2)	; Address of volume name
	pushl	#12			; Length of volume name
	print	1,<Volume: !AD>
	bbc	#dev$v_for, -		; Is this a foreign mounted volume?
		ucb$l_devchar(ap), 20$	; Branch if not foreign.
	skip	1
	print	0,<!_!_!_Volume is foreign mounted>
	skip	1
	brw	vcb_show_acpq		; Go try to do AQB, ha ha.
20$:	movl	r11, sp			; Setup scratch area
	movzbl	vcb$b_status(r2), -(sp)	; Volume status
	pushab	vcb_tape_status		; Bit definition table
	calls	#2, translate_bits	; Translate bits to names
	pushl	sp			; Address of output descriptor
	pushl	vcb$b_status(r2)
	print	2,<Status: !4XB !AS>
	movl	r11, sp			; Setup scratch area
	movzwl	vcb$w_mode(r2), -(sp)	; Volume operating mode
	pushab	vcb_tape_mode		; Bit definition table
	calls	#2, translate_bits	; Translate bits to names
	pushl	sp			; Address of output descriptor
	pushl	vcb$w_mode(r2)
	print	2,<Mode:   !4XW !AS>
	skip	1
	print_columns -
		(r2), ucb$l_vcb(ap), -
		vcb_tape_col_1, vcb_tape_col_2, vcb_tape_col_3
	brw	vcb_show_acpq

	.disable lsb

vcb_net:
	print_columns -
		(r2), ucb$l_vcb(ap), -
		vcb_net_col_1, vcb_net_col_2, vcb_net_col_3
	brw	vcb_show_acpq

vcb_journal:
	pushal	vcb$t_volname(r2)	; Address of journalname
	pushl	#12			; Length of journal name
	print	1,<Journal name: !AD>
	movl	r11, sp			; Setup scratch area
	movl	vcb$l_jnl_char(r2),-(sp); Journal characteristics
	pushab	vcb_journal_char	; Bit definition table
	calls	#2, translate_bits	; Translate bits to names
	pushl	sp			; Address of output descriptor
	pushl	vcb$l_jnl_char(r2)
	print	2,<Characteristics: !XL !AS>
	skip	1
	print_columns -
		(r2), ucb$l_vcb(ap), -
		vcb_jnl_col_1, vcb_jnl_col_2, vcb_jnl_col_3

vcb_show_acpq:
	callg	(r2),show_acpq		; Display ACP queue (if any)
	ret
	.page
	.sbttl volume control block tables & action routines

;  The following are all PRINT_COLUMNS action routines for the show_vcb
;  block displays.
;
;    Action Routine Inputs:
;
;	R2		value from the COLUMN_LIST entry
;	R5		size of value section for this item
;	R7		address of a descriptor for a scratch string in 
;			which the FAO converted value is to be returned
;	R11		base address of the local UCB copy
;
;    Action Routine Outputs:
;
;	R0		status
;			   lbs ==> use this entry
;			   lbc ==> skip this entry
;	R1 - R5		scratch
;			all other registers must be preserved


;
; PRINT_COLUMNS tables for disk VCB displays
;

vcb_disk_col_1:
	column_list -
		vcb$, 16, 8, 4, < -
		<<Mount count>,w_mcount,uw>, -
		<<Transactions>,w_trans,uw>, -
		<<Free blocks>,l_free,ul>, -
		<<Window size>,b_window,ub>, -
		<<Vol. lock ID>,l_vollkid,xl_neq>, -
		<<Block. lock ID>,l_blockid,xl_neq>, -
		>

vcb_disk_col_2:
	column_list -
		vcb$, 16, 8, 4, < -
		<<Rel. volume>,w_rvn,uw>, -
		<<Max. files>,l_maxfiles,ul>, -
		<<Rsvd. files>,b_resfiles,ub>, -
		<<Cluster size>,w_cluster,uw>, -
		<<Def. extend sz.>,w_extend,uw>, -
		<<Record size>,w_recordsz,uw>, -
		>

vcb_disk_col_3:
	column_list -
		vcb$, 16, 8, 0, < -
		<<AQB address>,l_aqb,xl>, -
		<<RVT address>,l_rvt,xl>, -
		<<FCB queue>,l_fcbfl,q2>, -
		<<Quota FCB>,l_quotafcb,xl_neq>, -
		<<Quota cache>,l_quocache,xl_neq>, -
		<<Cache blk.>,l_cache,xl_neq>, -
		>

;
; PRINT_COLUMNS tables for tape VCB displays
;

vcb_tape_col_1:
	column_list -
		vcb$, 16, 8, 4, < -
		<<Transactions>,w_trans,uw>, -
		<<Start record>,l_st_record,ul>, -
		<<Tapemark count>,b_tm,ub>, -
		>

vcb_tape_col_2:
	column_list -
		vcb$, 16, 8, 4, < -
		<<Rel. volume>,b_cur_rvn,ub>, -
		<<Tape vol. list>,l_mvl,xl_neq>, -
		>

vcb_tape_col_3:
	column_list -
		vcb$, 16, 8, 0, < -
		<<AQB address>,l_aqb,xl>, -
		<<Virt. pg. queue>,l_vpfl,q2>, -
		<<Blocked queue>,l_blockfl,q2>, -
		>

;
; PRINT_COLUMNS tables for network VCB displays
;

vcb_net_col_1:
	column_list -
		vcb$, 16, 8, 4, < -
		<<Transactions>,w_trans,uw>, -
		>

vcb_net_col_2:
	column_list -
		vcb$, 16, 8, 4, < -
		<<Mount count>,w_mcount,uw>, -
		>

vcb_net_col_3:
	column_list -
		vcb$, 16, 8, 0, < -
		<<AQB address>,l_aqb,xl>, -
		>

;
; PRINT_COLUMNS tables for journal VCB displays
;

vcb_jnl_col_1:
	column_list -
		vcb$, 16, 8, 4, < -
		<<Copies>,w_jnl_cop,uw>, -
		<<Mask>,l_jnl_mask,xl>, -
		>

vcb_jnl_col_2:
	column_list -
		vcb$, 16, 8, 4, < -
		<<Access mode>,b_jnl_mode,xb>, -
		<<JFT address>,l_jnl_jfta,xl>, -
		>

vcb_jnl_col_3:
	column_list -
		vcb$, 16, 8, 0, < -
		<<AQB address>,l_aqb,xl>, -
		<<JMT address>,l_jnl_jmt,xl>, -
		>

	.sbttl	show_cddb, Display Class Driver Data Block (CDDB)
;---
;
;	show_cddb
;
;	Display the Class Driver Data Block (CDDB)
;
; Inputs:
;
;	ap = Address of UCB in local storage
;	r6 = actual address of cddb
;
;---

show_cddb:
	.word	^m<r2,r3,r4,r5,r11>

    	tstl	r6			; is there a cddb
    	beql	5$			; no, so exit
    	movab	cddb, r2		; store address of local cddb 
    	getmem	(r6),(r2),#cddb$c_length	; read entire cddb
    	blbc	r0,5$			; return if not able to read it

    	cmpw	#<dyn$c_cd_cddb@8+dyn$c_classdrv>,cddb$b_type(r2)
    					; check for valid block type
    	beql	10$			; exit if not valid type
5$:
    	status  success			;
    	ret

10$:   	ensure 	20			; need 15 lines for this display
    	skip	1    			; advance 1 line
    	pushl	r6			; pass address of cddb to print routine
    	tstw	flag_2nd_cddb		; 0 - primary, 1 - secondary
    	bneq	second			; secondary if branch
    	print	1,<!_!_--- Primary Class Driver Data Block (CDDB) !XL --->
    	brb	display
second:
    	print   1,<!_!_--- Secondary Class Driver Data Block (CDDB) !XL --->
display:
	skip	1			; advance 1 line
    	movl	sp,r11			; save pre-allocation stack pointer
    	alloc	80,r4			; 80 byte output buffer
    	movzwl	cddb$w_status(r2),-(sp)	; cddb status field
    	pushab	cddb_status		; bit definition table
    	calls	#2,translate_bits	; translate bits to names
    	pushl	r4			; address of output descriptor
    	movzwl	cddb$w_status(r2),-(sp)	; pass value of status field to print
    	print	2,<Status:              !XW !AS>	; display status
    	movzbl	#80,(r4)		; 
    	movzwl	cddb$w_cntrlflgs(r2),-(sp)  ; cddb controller flags
    	pushab	cddb_flags		; bit definition table
    	calls	#2,translate_bits	; translate bits to names
    	pushl	r4			; address of output descriptor
    	movzwl  cddb$w_cntrlflgs(r2),-(sp)	; pass value of status field to print
    	print	2,<Controller Flags:    !XW !AS>  ; display status
    	movl	r11,sp			; restore stack pointer
    	skip 	1			; advance 1 line
    	print_columns	-
    		(r2), r6,-
    		cddb_col_1,cddb_col_2,cddb_col_3	;display!!!!
	status	success
    	ret



	.sbttl class driver data block tables & action routines

;  The following are all PRINT_COLUMNS action routines for the show_cddb
;  block displays.
;
;    Action Routine Inputs:
;
;	R2		value from the COLUMN_LIST entry
;	R5		size of value section for this item
;	R7		address of a descriptor for a scratch string in 
;			which the FAO converted value is to be returned
;	R11		base address of the local UCB copy
;
;    Action Routine Outputs:
;
;	R0		status
;			   lbs ==> use this entry
;			   lbc ==> skip this entry
;	R1 - R5		scratch
;			all other registers must be preserved


;
; PRINT_COLUMNS tables for CDDB displays
;

cddb_col_1:
	column_list -
		cddb$, 16, 8, 4, < -
		<<Allocation class>,l_allocls,ul>, -
		<<System ID>,cddb_4bytes,cddb$b_systemid>, -
    		<<>,cddb_2bytes,cddb$b_systemid+4>,-
		<<Contrl. ID>,cddb_4bytes,cddb$q_cntrlid>, -
    		<<>,cddb_4bytes,cddb$q_cntrlid+4>,-
		<<Response ID>,l_oldrspid,xl>, -
    		<<MSCP Cmd status>,l_oldcmdsts,xl>,-
		>

cddb_col_2:
	column_list -
		cddb$, 16, 8, 4, < -
		<<CDRP Queue>,l_cdrpqfl,q2>, -
		<<Restart Queue>,l_rstrtqfl,q2>, -
		<<Restarted CDRP>,rstrt_cdrp,cddb$l_rstrtcdrp>, -
		<<CDRP retry cnt.>,retry_cnt,cddb$b_retrycnt>, -
    		<<DAP Count>,b_dapcount,ub>, -
		<<Contr. timeout>,w_cntrltmo,uw>, -
		<<Reinit Count>,w_rstrtcnt,uw>, -
    		<<Wait UCB Count>,w_wtucbctr,uw>, -
		>


cddb_col_3:
	column_list -
		cddb$, 16, 8, 0, < -
		<<DDB address>,l_ddb,xl>, -
		<<CRB address>,l_crb,xl>, -
		<<CDDB link>,l_cddblink,xl>, -
		<<PDT address>,l_pdt,xl>, -
    		<<Original UCB>,l_origucb,xl>,-
		<<UCB chain>,l_ucbchain,xl>, -
		>

;**********
cddb_4bytes:
    	addl3	r2,r11,r3			; locate storage of interest
    	subl	#8,r5				; get size of filler field
    	$fao_s	 -
    		ctrstr=cddb_fao,-
    		outbuf = (r7),-
    		outlen = (r7),-
    		p1 = r5,-
    		p2 = (r3)
    	rsb

;**********
cddb_2bytes:
	addl3	r2, r11, r3			; locate storage of interest
	subl	#4, r5				; get size of filler field
	$fao_s	-
		ctrstr = sb_fao_6bytes, -
		outbuf = (r7), -
		outlen = (r7), -
		p1 = r5, -
		p2 = (r3)
	rsb

;**********
rstrt_cdrp:
    	bbc	#cddb$v_snglstrm,cddb$w_status(r11),cddb_act_nop
    					; cdrp only exists if single stream
    	addl	r11,r2			; locate cell to return
    	do_column_entry xl,jmp		; display this entry    	

cddb_act_nop:
    	clrl	r0
    	rsb

;**********
retry_cnt:
    	bbc	#cddb$v_snglstrm,cddb$w_status(r11),cddb_act_nop
    					; count is valid if single stream
    	addl	r11,r2			; locate cell to return
    	do_column_entry ub,jmp		; display this entry


	.end
