	.TITLE	PARSENT - PARSE PARAMETERS AND QUALIFIERS
	.IDENT	'V04-000'
 
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; D. N. CUTLER 24-MAR-77
;
; PROCESS QUALIFIER SPECIFICATION
;
; MODIFICATIONS:
;
;	V03-018	HWS0027		Harold Schultz		09-Mar-1984
;		Check for error when expanding an expression.
;
;	V03-017	HWS0021		Harold Schultz		06-Mar-1984
;		Don't issue warning message about ignored qualifiers due
;		to a syntax change when the only previous qualifiers
;		were the one responsible for the syntax change.
;		Fix typo's.
;
;	V03-016	PCG0019		Peter George		18-Nov-1983
;		Allow hyphens in filenames.
;
;	V03-015	PCG0018		Peter George		17-Aug-1983
;		Disable indirection when looking ahead for keyword values.
;
;	V03-014	PCG0017		Peter George		17-Jul-1983
;		Signal ignored qualifier message.
;		Support null node names.
;
;	V03-013	PCG0016		Peter George		27-Jun-1983
;		Fix bug in $REST_OF_LINE.
;
;	V03-012	PCG0015		Peter George		15-Jun-1983
;		Add support for $FILE, $EXPRESSION, $QUOTED_STRING, and
;		$PARENTHESIZED_VALUE.  Rename old $PARENTHESIZED_VALUE 
;		$ACL.  Improve error reporting.
;
;	V03-011	PCG0014		Peter George		27-May-1983
;		Add support for $DELTATIME.
;		Remove DCL$SORT_TOKENS.
;
;	V03-010	PCG0013		Peter George		06-May-1983
;		Add DCL$SORT_TOKENS.
;
;	V03-009	PCG0012		Peter George		30-Apr-1983
;		Move disallow logic into DISALLOW.
;		Add WRK_B_PARMSUM.
;
;	V03-008	PCG0011		Peter George		20-Apr-1983
;		Undo the part of the last fix dealing with negated
;		entities and syntax checks.  
;
;	V03-007	PCG0010		Peter George		07-Apr-1983
;		Add more parameter limit checks.
;		Modify ambiguous verb check.
;		Do not change syntax on negated qualifiers or keywords.
;
;	V03-006	PCG0009		Peter George		15-Feb-1983
;		Convert to new structure level.
;		Pass entity block address to DCL$GENDESCR.
;		Do not allow values on negated qualifiers.
;		Add support for $NUMBER, $PARENTHESIZED_VALUE,
;		and $DATETIME.
;
;	V03-005	PCG0008		Peter George		15-Jan-1983
;		Make NOQUALIFIERS work.
;
;	V03-004	PCG0007		Peter George		22-Nov-1982
;		Use prompt descriptor instead of WRK_L_PROMPT.
;
;	V03-003	PCG0006		Peter George		29-Oct-1982
;		Insert CRLF into DCL prompts.
;
;	V03-002	PCG0005		Peter George		19-Oct-1982
;		Call user input routine with address of string descriptor
;		instead of address of ascic string.
;		Use constant for maximum prompt string length.
;		Do the right thing when a CTRL/Z is entered.
;		Do not zero out parameters before a syntax change.
;		Check full spelling of negated keywords.
;		Zero R6 after parsing $REST_OF_LINE value.
;
;	V03-001	PCG0004		Peter George		30-Sep-1982
;		Add keyword parsing.  Create more common parsing
;		routines.  Add prompting for CLI$DCL_PARSE.
;
;---


;
; MACRO LIBRARY CALLS
;
	PRCDEF				; DEFINE PROCESS WORK AREA
	WRKDEF				; DEFINE COMMAND WORK AREA
	PTRDEF				; DEFINE RESULT PARSE DESCRIPTOR
	$CLIMSGDEF			; CLI MESSAGES
	$FSCNDEF			; DEFINE FILE SCAN SYMBOLS
	$$CLITABDEF			; DEFINE TABLE STRUCTURES

	.PSECT	DCL$ZCODE,BYTE,RD,NOWRT

CTRLZ	= 26				; CONTROL/Z CHARACTER

;
; DEFINE LOCAL FLAGS
;
V_NEGAT	= 0
M_NEGAT = 1
V_KEYWD	= 1
M_KEYWD	= 2
V_SYNTAX = 2
M_SYNTAX = 4
V_AMBIG	= 3
M_AMBIG = 8


	.SBTTL	PARSE COMMAND QUALIFIERS AND PARAMETERS
;---
; DCL$PARSE_COMMAND - PARSE COMMAND QUALIFIERS AND PARAMETERS
;
; THIS ROUTINE IS CALLED AFTER THE COMMAND VERB HAS BEEN PARSED, TO PARSE
; WHATEVER QUALIFIERS AND PARAMETERS MAY APPEAR ON THE COMMAND LINE.
;
; INPUTS:
;
;	R10 =	ADDRESS OF COMMAND WORK AREA
;	R11 =	ADDRESS OF PROCESS WORK AREA (FOR SUPERVISOR MODE PARSING)
;
; OUTPUTS:
;
;	R0 =	STATUS
;	NO REGISTERS ARE SAVED
;
;+++

DCL$PARSE_COMMAND::
	BISW	#WRK_M_VERB,-		;SET VERB PROCESSING FLAG
		WRK_W_FLAGS(R10) 

;
; PROCESS ALL LEADING COMMAND QUALIFIERS
;
PARSE_QUAL:
	BSBW	DCL$SETCHAR		;PEEK AT NEXT CHARACTER IN INPUT BUFFER
	CMPB	#^A'/',R0		;QUALIFIER?
	BNEQ	PARSE_PARMS		;IF NEQ NO
	BSBW	DCL$MARK		;MARK CURRENT PARSE POSITION
	BSBW	DCL$PROCQUAL		;PROCESS QUALIFIER
	BLBS	R0,PARSE_QUAL		;IF LBS SUCCESSFUL COMPLETION
	BRW	EXIT			;UNSUCCESSFUL, EXIT WITH STATUS

;
; PROCESS EACH COMMAND PARAMETER AND ITS ASSOCIATED QUALIFIERS
;
PARSE_PARMS:
10$:	BICW	#WRK_M_VERB,-		;CLEAR VERB PROCESSING
		WRK_W_FLAGS(R10) 	;
	MOVL	WRK_L_PROPTR(R10),R8	;GET ADDRESS OF P1 ENTITY BLOCK
	BEQL	30$			;BRANCH IF NONE
	MOVZBL	WRK_B_PARMCNT(R10),R0	;GET PARAMETER # BEING PARSED
	BEQL	30$			;BRANCH IF NO LOOP NEEDED
20$:	ADDL3	ENT_L_NEXT(R8),-	;GET ADDRESS OF NEXT ENTITY BLOCK
		WRK_L_TAB_VEC(R10),R8	;
	SOBGTR	R0,20$			;LOOP UNTIL PARAMETER FOUND

30$:	BSBW	DCL$MARK		;MARK CURRENT PARSE POSITION
	BSBW	DCL$SETCHAR		;PEEK AT NEXT CHARACTER IN INPUT BUFFER
	BEQL	END_OF_LINE		;IF EQL END OF LINE
	CMPB	#^A' ',R0		;BLANK?
	BNEQ	130$			;IF NEQ NO
	INCB	WRK_B_PARMCNT(R10)	;INCREMENT COUNT OF PARAMETER
	CMPB	WRK_B_PARMCNT(R10),-	;MAXIMUM PARAMETERS EXCEEDED?
		WRK_B_MAXPARM(R10) 	;
	BGTR	100$			;BR IF SO

40$:	BSBW	DCL$MARK		;MARK CURRENT PARSE POSITION
	MOVZBL	#PTR_K_PARAMETR,R3	;SET CLASSIFICATION OF VALUE STRING
	INCB	WRK_B_PARMSUM(R10)	;INCREMENT COUNT OF PARAMETER VALUES
	CLRL	R5			;CLEAR PARENTHESIS FLAG
	BSBW	DCL$PARSE_VALUE		;PROCESS PARAMETER VALUE
50$:	BLBC	R0,190$			;IF LBC, THEN PARSE ERROR

	BSBW	DCL$SETCHAR		;PEEK AT NEXT CHARACTER IN INPUT BUFFER
	CMPB	#^A'/',R0		;QUALIFIER?
	BNEQ	60$			;IF NEQ NO
	BSBW	DCL$PROCQUAL		;PROCESS QUALIFIER
	BRB	50$			;CHECK FOR ANOTHER QUALIFIER

60$:	CMPB	#^A',',R0		;MULTIPLE PARAMETERS?
	BEQL	110$			;IF EQL YES
	CMPB	#^A'+',R0		;CONCATENATED PARAMETERS?
	BEQL	120$			;IF EQL YES
	BRB	10$			;PROCESS NEXT PARAMETER
 
;
; MAXIMUM PARAMETER COUNT EXCEEDED
;
100$:	BSBW	DCL$GETOKEN		;GET NEXT TOKEN
	STATUS	MAXPARM			;SET MAXIMUM PARAMETER COUNT EXCEEDED
190$:	BRW	EXIT			;EXIT WITH STATUS
 
;
; PARAMETER LIST SPECIFIED
;
110$:	BBS	#ENT_V_LIST,-		;IF SET, LISTS ALLOWED
		ENT_W_FLAGS(R8),40$ 	;
	BSBW	DCL$MOVTOKN		;GET "," AND TOKEN
	STATUS	NOLIST			;SET NO LISTS ALLOWED STATUS
	BRB	190$			;EXIT WITH STATUS
 
;
; PARAMETER CONCATENATION SPECIFIED
;
120$:	BBS	#ENT_V_CONCAT,-		;IF SET, CONCATENATION ALLOWED
		ENT_W_FLAGS(R8),40$ 	;
	BSBW	DCL$MOVTOKN		;GET "+" AND TOKEN
	STATUS	NOCCAT			;SET NO CONCATENATION ALLOWED STATUS
	BRB	190$			;EXIT WITH STATUS
 
;
; INVALID PARAMETER DELIMITER
;
130$:	BSBW	DCL$MOVTOKN		;GET DELIMITER AND TOKEN
	STATUS	PARMDEL			;SET INVALID PARAMETER DELIMITER STATUS
	BRB	190$			;EXIT WITH STATUS
 
;
; ALL COMMAND INPUT PROCESSED - CHECK FOR SUFFICIENT PARAMETERS
;
END_OF_LINE:
	STATUS	MAXPARM			;ASSUME MAXIMUM PARAMETER COUNT EXCEEDED
	CMPB	WRK_B_PARMCNT(R10),-	;MAXIMUM PARAMETERS EXCEEDED?
		WRK_B_MAXPARM(R10) 	;
	BGTR	210$			;BR IF SO
	BBSS	#WRK_V_PROMPT,-		;IF SET ALREADY PROMPTING
		WRK_W_FLAGS(R10),PROMPT ;
	CMPB	WRK_B_PARMCNT(R10),-	;SUFFICIENT PARAMETERS?
		WRK_B_MINPARM(R10) 	;
	BGEQ	NORMAL_EXIT		;IF GEQ YES

;
; DO NOT PROMPT IF WE ARE PARSING A DCL COMMAND WITHIN A COMMAND PROCEDURE OR
; A BATCH JOB.  IF WE ARE PARSING A USER COMMAND, THEN DO NOT PROMPT IF THE 
; USER HAS NOT SUPPLIED A PROMPT ROUTINE.
;
	TSTL	WRK_L_PROMPTRTN(R10)	;DO WE HAVE A PROMPT ROUTINE?
	BEQL	200$			;SIGNAL ERROR IF NOT
	BBS	#WRK_V_USRMODE,-	;IF SET THEN USER PROMPT ROUTINE
		WRK_W_FLAGS(R10),PROMPT ;
	BBS	#PRC_V_YLEVEL,-		;IF SET, AT CONTROL Y/C LEVEL
		PRC_W_FLAGS(R11),PROMPT ;
	TSTL	PRC_L_INDEPTH(R11)	;INDIRECT LEVEL ZERO?
	BNEQ	200$			;IF NEQ NO
	BBC	#PRC_V_MODE,-		;IF CLR, INTERACTIVE MODE
		PRC_W_FLAGS(R11),PROMPT ;
200$:	STATUS	INSFPRM			;SET INSUFFICIENT PARAMETERS
210$:	BRW	EXIT			;EXIT WITH ERROR STATUS
 
;
; PROMPT FOR MISSING PARAMETERS
;
PROMPT:	CMPB	WRK_B_PARMCNT(R10),-	;ALL PARAMETERS PROCESSED?
		WRK_B_MAXPARM(R10) 	;
	BGEQ	NORMAL_EXIT		;IF GEQ YES
	BSBW	ISSUE_PROMPT		;PROMPT FOR INPUT
	BLBS	R1,220$			;CONTINUE IF NO ERROR
	MOVL	R1,R0			;MOVE STATUS BACK TO R0
	BRB	EXIT			;EXIT WITH ERROR
220$:	TSTB	R0			;CHECK FIRST CHARACTER
	BNEQ	222$			;IF EQL NULL LINE
	BBS	#ENT_V_VALREQ,-		;IF SET, PARAMETER REQUIRED
		ENT_W_FLAGS(R8),PROMPT	;
	BRB	NORMAL_EXIT		;NOT REQUIRED, THEN EXIT
222$:	CMPB	R0,#CTRLZ		;CONTROL/Z?
	BEQL	NO_COMMAND		;CONTROL/Z TYPED - EXIT 
	CMPB	R0,#^A'/'		;LEADING QUALIFIER?
	BNEQ	230$			;BRANCH IF NOT
	TSTB	WRK_B_PARMCNT(R10)	;FIRST PARAMETER?
	BNEQ	225$			;NO, THEN PARSE PARAMETER QUALIFIERS
	BRW	DCL$PARSE_COMMAND	;YES, THEN PARSE COMMAND QUALIFIERS
225$:	BRW	PARSE_QUAL		;PROCESS PARAMETER QUALIFIER(S)
230$:	MOVB	#^A' ',-		;INSERT BLANK AT FRONT OF BUFFER
		@WRK_L_CHARPTR(R10) 	;
	DECL	WRK_L_CHARPTR(R10)	;BACK UP CHARACTER POINTER
	BRW	PARSE_PARMS		;PROCESS PARAMETER

NO_COMMAND:
	STATUS	NOCOMD			;SET NO COMMAND FOUND
EXIT:	BSBB	DCL$GENEOL		;GENERATE AN EOL TOKEN
	RSB				;RETURN

NORMAL_EXIT:
	BSBB	DCL$GENEOL		;GENERATE AN EOL TOKEN
	BSBW	DCL$EVAL_DISALLOW	;EVALUATE ANY DISALLOW EXPRESSIONS
	RSB				;RETURN

	.SBTTL	GENERATE AN EOL DESCRIPTOR
;+
; DCL$GENEOL - GENERATE AN EOL DESCRIPTOR
;
; THIS ROUTINE IS CALLED TO GENERATE AN END-OF-LINE TOKEN DESCRIPTOR.
;
; INPUTS:
;
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;
; OUTPUTS:
;
;	R0 = RETURN STATUS
;
;-
 
DCL$GENEOL::
	PUSHL	R0			;SAVE RETURN STATUS
	CLRL	R4			;CLEAR ITEM NUMBER
	MOVZBL	#PTR_K_ENDLINE,R5	;SET ITEM TYPE TO END OF LINE
	CLRL	R6			;CLEAR FLAGS
	MOVZBL	#1,R7			;SET LENGTH OF ITEM
	MOVL	WRK_L_EXPANDPTR(R10),R8	;SET STARTING ADDRESS OF ITEM
	CLRL 	R9			;CLEAR ENTITY BLOCK ADDRESS
	BSBW	DCL$GENDESCR		;GENERATE END-OF-LINE TOKEN
	POPL	R0			;RESTORE RETURN STATUS
	RSB				;RETURN FROM SUBROUTINE


	.SBTTL	PROCESS QUALIFIER SPECIFICATION
;+
; DCL$PROCQUAL - PROCESS QUALIFIER SPECIFICATION
;
; THIS ROUTINE IS CALLED TO PARSE A QUALIFIER SPECIFICATION AND EMIT A
; DESCRIPTOR TO THE RESULT PARSE TABLE.
;
; INPUTS:
;
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;
; OUTPUTS:
;
;	R0 LOW BIT CLEAR INDICATES FAILURE TO PARSE QUALIFIER SPECIFICATION.
;
;		R0 = DCL$_ABKEYW - AMBIGUOUS KEYWORD IN QUALIFIER.
;		R0 = DCL$_IMCHNG - MULTIPLE ATTEMPT TO CHANGE IMAGE NAME.
;		R0 = DCL$_IVKEYW - INVALID KEYWORD IN QUALIFIER.
;		R0 = DCL$_IVQLOC - INVALID QUALIFIER LOCATION.
;		R0 = DCL$_IVVALU - INVALID QUALIFIER VALUE SYNTAX.
;		R0 = DCL$_NOKEYW - NO KEYWORD IN QUALIFIER.
;		R0 = DCL$_NOQUAL - NO QUALIFIERS ALLOWED ON COMMAND.
;		R0 = DCL$_NOVALU - NO VALUE ALLOWED ON QUALIFIER.
;
;	R0 LOW BIT SET INDICATES SUCCESSFUL PARSE WITH THE QUALIFIER
;		DESCRIPTOR EMITTED AND THE QUALIFIER SPECIFICATION COPIED
;		TO THE COMMAND BUFFER.
;
;		R0 = DCL$_NORMAL - NORMAL COMPLETION.
;-
 
DCL$PROCQUAL::				;PROCESS QUALIFIER SPECIFICATION
	PUSHR	#^M<R6,R7,R8>		;SAVE REGISTERS
	CLRL	R6			;CLEAR KEYWORD NEGATION FLAG
	INCB	WRK_B_VALLEV(R10)	;INCREASE THE VALUE LEVEL

;
; GET QUALIFIER KEYWORD
;
	BSBW	DCL$MOVCHAR		;MOVE SLASH TERMINATOR
	BSBW	DCL$MARK		;MARK CURRENT POSITION IN BUFFER
	BSBW	DCL$GETOKEN		;GET QUALIFIER NAME
	BEQL	90$			;IF NONE, THEN ERROR

;
; CHECK THAT IT MATCHES AN ALLOWED QUALIFIER KEYWORD
;
	STATUS	NOQUAL			;ASSUME NO QUALIFIERS ALLOWED ON COMMAND
	MOVL	WRK_L_QUABLK(R10),R8	;GET ADDRESS OF QUALIFIER DESCRIPTORS
	BEQL	100$			;IF EQL NONE
	BSBW	DCL$FIND_KEYWORD	;LOOKUP QUALIFIER
	BLBS	R0,110$			;IF SUCCESSFUL, THEN CONTINUE
	BRW	390$			;OTHERWISE, EXIT WITH ERROR STATUS
90$:	STATUS	NOKEYW			;SET NO KEYWORD STATUS
100$:	BRW	390$			;EXIT WITH ERROR STATUS

;
; VALID KEYWORD MATCH FOUND - CHECK THAT IT IS POSITIONED CORRECTLY
;
110$:	STATUS	IVQLOC			;ASSUME INVALID QUALIFIER LOCATION
	BBS	#WRK_V_VERB,-		;IF SET, PROCESSING VERB
		WRK_W_FLAGS(R10),120$	;
	BBS	#ENT_V_PARM,-		;IF SET, ALLOWED ON PARAMETERS
		ENT_W_FLAGS(R8),125$ 	;
120$:	BBC	#ENT_V_VERB,-		;IF CLR, NOT ALLOWED ON VERBS
		ENT_W_FLAGS(R8),100$ 	;

;
; CHECK NEGATION 
;
	ASSUME	V_NEGAT EQ 0		;
125$:	BLBC	R6,150$			;BRANCH IF QUALIFIER WAS NOT NEGATED
	STATUS	NOTNEG			;ASSUME QUALIFIER NOT NEGATABLE
	BBC	#ENT_V_NEG,-		;IF CLR, NOT NEGATABLE
		ENT_W_FLAGS(R8),100$ 	;

;
; PROCESS CHANGE LIST - IF ANY
;
150$:	TSTL	ENT_L_SYNTAX(R8)	;NEW COMMAND SYNTAX?
	BEQL	160$			;BRANCH IF NOT
	BSBW	DCL$CHANGE_SYNTAX	;PROCESS CHANGE LIST
	ASSUME	PTR_V_SYNTAX EQ 22	;
	BISL	#M_SYNTAX,R6		;SET SYNTAX CHANGE BIT
	BLBC	R0,160$			;BRANCH IF NO QUALIFIER CHANGE LIST
	CLRL	R7			;INVALIDATE THIS QUALIFIER

;
; GENERATE QUALIFIER DESCRIPTOR
;
160$:	MOVZBL	#PTR_K_COMDQUAL,R5	;ASSUME COMMAND QUALIFIER
	BBS	#WRK_V_VERB,-		;IF SET, PROCESSING VERB
		WRK_W_FLAGS(R10),170$ 	;
	BBC	#ENT_V_PARM,-		;IF CLR, COMMAND QUALIFIER
		ENT_W_FLAGS(R8),170$ 	;
	MOVZBL	#PTR_K_PARMQUAL,R5	;SET TYPE TO PARAMETER QUALIFIER
170$:	MOVQ	R7,-(SP)		;SAVE REGISTERS
	MOVL	R7,R4			;GET QUALIFIER NUMBER
	MOVL	R8,R9			;GET ENTITY BLOCK ADDRESS
	BSBW	DCL$MARKEDTOKEN		;GET QUALIFIER DESCRIPTOR
	MOVQ	R1,R7			;
	BSBW	DCL$GENDESCR		;GENERATE RESULT PARSE DESCRIPTOR
	MOVQ	(SP)+,R7		;RESTORE REGISTERS

;
; CHECK FOR QUALIFIER VALUE(S)
;
	STATUS	NOVALU			;ASSUME VALUE NOT ALLOWED
	MOVZBL	#PTR_K_QUALVALU,R3	;SET VALUE TYPE
	BSBW	DCL$CHECK_VALUES	;CHECK FOR VALUES
	BLBC	R0,390$			;EXIT IF ERROR

;
; CLEAN UP AND EXIT
;
	STATUS	NORMAL			;SET SUCCESSFUL COMPLETION
390$:	DECB	WRK_B_VALLEV(R10)	;DECREASE THE VALUE LEVEL
	POPR	#^M<R6,R7,R8>		;RESTORE REGISTERS
	RSB				;RETURN FROM SUBROUTINE

	.SBTTL	FIND KEYWORD
;+
; DCL$FIND_KEYWORD - LOOK UP SPECIFIED KEYWORD IN SPECIFIED LIST
;
; THIS ROUTINE IS CALLED TO LOOK UP A SPECIFIED QUALIFIER OR KEYWORD
; IN THE APPROPRIATE LIST.  IF THE SEARCH IS SUCCESSFUL, THE QUALIFIER 
; OR KEYWORD NUMBER IS RETURNED ALONG WITH THE ADDRESS OF THE ENTITY
; DESCRIPTOR BLOCK.  OTHERWISE, AN ERROR STATUS IS RETURNED.
;
; INPUTS:
;
;	R1/R2 = DESCRIPTOR OF KEYWORD TO LOOK UP
;	R6 = 0 IF QUALIFIER KEYWORD, M_KEYWD IF REGULAR KEYWORD
;	R8 = ADDRESS OF LIST OF DESCRIPTOR BLOCKS
;	R10 = ADDRESS OF COMMAND WORK AREA
;
; OUTPUTS:
;
;	R1/R2 = DESCRIPTOR OF KEYWORD (NEEDED BY DCL$PARSE_VALUE)
;	R6 = NEGATION FLAG - LBS, IF KEYWORD NEGATED; LBC, IF NOT
;	R7 = QUALIFIER OR KEYWORD NUMBER (IF SUCCESSFUL)
;	R8 = ADDRESS OF ENTITY DESCRIPTOR BLOCK
;
;-

DCL$FIND_KEYWORD:
	ASSUME	PTR_V_NEGATE EQ 20		;
	PUSHR	#^M<R1,R2,R3,R4,R5,R9>		;SAVE REGISTERS

;
; IF KEYWORD LIST, THEN SKIP PAST TYPE BLOCK.
;
	CMPB	ENT_B_TYPE(R8),#BLOCK_K_TYPE	;TYPE BLOCK?
	BNEQ	5$				;NO, THEN SKIP
	ADDL3	WRK_L_TAB_VEC(R10),-		;GET ADDR OF FIRST ENT BLOCK
		TYPE_L_KEYWORDS(R8),R8		;

;
; SAVE ADDRESS OF LIST OF DESCRIPTOR BLOCKS.
;
5$:	MOVL	R8,R9				;SAVE LIST ADDRESS

;
; INITIALIZE SEARCH PARAMETERS.
;
10$:	CLRL	R7				;CLEAR QUALIFIER NUMBER
	CLRQ	-(SP)				;SET NULL AS QUALIFIER FOUND

;
; IF QUALIFIER THEN ONLY CHECK FIRST FOUR CHARACTERS OF KEYWORD,
; ELSE CHECK THE WHOLE THING.
;
	MOVL	R1,AP			;SAVE ORIGINAL TOKEN SIZE
	BBS	#V_KEYWD,R6,30$		;ARE WE LOOKING FOR A KEYWORD?
	CMPL	#4,R1			;KEYWORD LESS THAN 5 CHARACTERS?
	BGEQ	30$			;IF GEQ YES
	MOVL	#4,R1			;SET TO ONLY COMPARE 4 CHARACTERS

;
; GET NEXT QUALIFIER IN LIST
;
30$:	CVTWL	ENT_W_NAME(R8),R0	;GET OFFSET TO ASCIC QUALIFIER NAME
	MOVAB	(R8)[R0],R5		;FIND ADDRESS OF QUALIFIER KEY LENGTH
	MOVAB	1(R8)[R0],R0		;FIND ADDRESS OF QUALIFIER KEY TEXT
	MOVQ	R1,R3			;COPY QUALIFIER STRING DESCRIPTOR

;
; COMPARE THE QUALIFIER WITH THE INPUT
;
60$:	CMPB	#^A/ /,(R0)		;END OF QUALIFIER TEXT?
	BEQL	65$			;BR IF YES
	CMPB	(R0)+,(R4)+		;IS THIS THE QUALIFIER WERE LOOKIN FOR?
	BNEQ	70$			;BR IF DEFINITELY NOT!
	SOBGTR	R3,60$			;BR IF MORE TO CHECK

;
; WHAT KIND OF MATCH DO WE HAVE?
;
	CMPB	AP,(R5)			;IS TABLE QUALIFIER SAME LENGTH
	BNEQ	65$			;NO, THEN SKIP
	ADDL	#8,SP			;YES, THEN WE HAVE A UNIQUE MATCH
	BRB	83$			;RESTORE STACK, BRANCH TO EXIT

;
; CHECK FOR AMBIGUITY AND SAVE MATCH.
;
65$:	TSTL	4(SP)			;FIND MATCH BEFORE?
	BEQL	67$			;BR IF NOT AMBIGUOUS
	BISL	#M_AMBIG,R6		;SET AMBIGUOUS BIT
67$:	MOVQ	R7,(SP)			;SAVE MATCHED QUALIFIER VALUES

;
; CHECK NEXT QUALIFIER IN LIST.
;
70$:	INCL	R7			;INCREMENT QUALIFIER NUMBER
	MOVL	ENT_L_NEXT(R8),R8	;GET OFFSET TO NEXT QUALIFIER DESCRIPTOR
	BEQL	75$			;IF EQL THEN DONE
	ADDL	WRK_L_TAB_VEC(R10),R8	;CALCULATE ADDRESS
	BRB	30$			;CHECK NEXT QUALIFIER
 
;
; ALL QUALIFERS HAVE BEEN CHECK WITHOUT AMBIGUITY, NOW SEE IF ANY MATCHED.
;
75$:	STATUS	ABKEYW			;ASSUME AMBIGUOUS
	BBSC	#V_AMBIG,R6,85$		;BR IF TRUE
	MOVQ	(SP)+,R7		;RESTORE MATCHED QUALIFER PARAMETERS
	BNEQ	83$			;BR IF ONE WAS FOUND
 
;
; QUALIFIER DESCRIPTOR TABLE EXHAUSTED - TRY NEGATION
;
	XORL	#M_NEGAT,R6		;COMPLEMENT NEGATION FLAG
	SUBL3	#2,AP,R1		;REDUCE CHARACTER COUNT
	BLEQ	80$			;IF LEQ NO MATCH POSSIBLE
	MOVL	R9,R8			;RESTORE ADDRESS OF DESCRIPTOR LIST
	CMPW	#^A/NO/,(R2)+		;KEYWORD START WITH 'NO'?
	BEQL	10$			;IF EQL YES
 
;
; SET STATUS, CLEAN UP, AND RETURN
;
80$:	STATUS	IVQUAL			;ASSUME INVALID QUALIFIER
	BBC	#V_KEYWD,R6,90$		;BRANCH IF QUALIFIER PROCESSING
	STATUS	IVKEYW			;SET INVALID KEYWORD STATUS
	BRB	90$			;EXIT WITH ERROR STATUS

83$:	STATUS	NORMAL			;SET SUCCESS STATUS
	BRB	90$			;EXIT WITH ERROR STATUS

85$:	MOVQ	(SP)+,R7		;RESTORE MATCHED QUALIFIER PARAMETERS
90$:	INCL	R7			;ADJUST TO ACTUAL KEYWORD NUMBER
	POPR	#^M<R1,R2,R3,R4,R5,R9>	;RESTORE REGISTERS
	RSB				;RETURN FROM SUBROUTINE

	.SBTTL	CHECK FOR VALUES
;+
; DCL$CHECK_VALUES - CHECK FOR VALUES AND THEN PROCESS THEM
;
; THIS ROUTINE IS CALLED TO DETERMINE IF A VALUE OR LIST OF VALUES IS
; ASSOCIATED WITH THE LAST QUALIFIER OR PARAMETER PARSED, TO DETERMINE
; THE SYNTACTIC LEGALITY OF THE EXISTENCE OF VALUES, AND TO CALL 
; DCL$PARSE_VALUE TO PARSE EACH VALUE FOUND.
;
; INPUTS:
;
;	R3 = CLASSIFICATION OF VALUE (PTR_K_QUALVALU OR PTR_K_PARAMETR)
;	R6 = NEGATION FLAG - LBS, IF KEYWORD NEGATED; LBC, IF NOT
;	R8 = ADDRESS OF ENTITY DESCRIPTOR BLOCK
;	R10 = ADDRESS OF COMMAND WORK AREA
;
; IMPLICIT INPUTS:
;
;	WRK_L_EXPANDPTR IS POSITIONED AT THE TERMINATOR OF THE PREVIOUS
;	QUALIFIER OR PARAMETER.
;
; OUTPUTS:
;
;	R0 INDICATES THE SYNTACTIC CORRECTNESS OR INCORRECTNESS OF
;	WHAT WAS FOUND.
;
;-

DCL$CHECK_VALUES:
	PUSHL	R3			;SAVE VALUE TYPE

;
; CHECK IF VALUE HAS BEEN SPECIFIED
;
	CLRL	-(SP)			;ASSUME NO BLANKS
	SETBIT	PRC_V_IND,PRC_W_FLAGS(R11) ;DISABLE @ INDIRECTION
	BSBW	DCL$SETCHAR		;PEEK AT NEXT CHAR IN INPUT BUFFER
	CMPB	R0,#^A' '		;BLANK?
	BNEQ	5$			;IF NEQ NO
	INCL	(SP)			;MARK BLANK SEEN
	BSBW	DCL$SETNBLK		;PEEK AT NEXT NON-BLANK
5$:	CLRBIT	PRC_V_IND,PRC_W_FLAGS(R11) ;ENABLE @ INDIRECTION
	CMPB	R0,#^A'='		;VALUE SPECIFIED?
	BEQL	10$			;IF EQL YES
	CMPB	R0,#^A':'		;VALUE SPECIFIED?
	BEQL	10$			;IF EQL YES
	TSTL	(SP)+			;WAS A BLANK SEEN?
	BEQL	7$			;BRANCH IF NO BLANK SEEN
	MOVB	#^A' ',R0		;RESTORE THE BLANK
	BSBW	DCL$BACKUPCHAR		;

;
; IS VALUE REQUIRED?
;
	ASSUME	V_NEGAT EQ 0		;
7$:	BLBS	R6,9$			;NO VALUE IS OK IF ENTITY WAS NEGATED
	STATUS	VALREQ			;ASSUME VALUE REQUIRED ERROR
	BBS	#ENT_V_VALREQ,-		;IF SET, REPORT VALUE IS REQUIRED
		ENT_W_FLAGS(R8),95$ 	;
9$:	BRW	90$			;OTHERWISE, ITS OK

;
; IS VALUE ALLOWED?
;
10$:	TSTL	(SP)+			;RESTORE THE STACK
	BSBW	DCL$MOVCHAR		;MOVE EQUAL SIGN
	BSBW	DCL$GENTERM		;SET TOKEN TERMINATOR
	STATUS	NOVALU			;ASSUME NO VALUE ALLOWED
	BBC	#ENT_V_VAL,-		;IF CLR, VALUE NOT ALLOWED
		ENT_W_FLAGS(R8),95$	;
	CMPB	#ENT_K_QUALIFIER,-	;ARE WE PARSING A QUALIFIER VALUE?
		ENT_B_TYPE(R8)		;
	BNEQ	15$			;NO, THEN SKIP
	ASSUME	V_NEGAT EQ 0		;
	BLBS	R6,95$			;YES, THEN ERROR IF QUALIFIER WAS NEGATED

;
; CHECK FOR VALUE LIST AND PROCESS VALUE(S)
;
15$:	MNEGL	#2,R5			;SET VALUE STATE VARIABLE
	BSBW	DCL$SETNBLK		;PEEK AT FIRST NON-BLANK AFTER (=)
	CMPB	R0,#^A'('		;START OF VALUE LIST?
	BEQL	20$			;BR IF YES
	BSBW	DCL$BACKUPMOVE		;RESTORE EQUAL SIGN DELIMITER
	BRB	30$			;AND PARSE THE SINGLE VALUE
20$:	INCL	R5			;MARK LIST IS PRESENT
30$:	MOVL	(SP),R3			;SET TOKEN TYPE
	BSBW	DCL$PARSE_VALUE		;PARSE VALUE STRING
	BLBC	R0,95$			;BRANCH IF ERROR DETECTED
	INCL	R5			;COUNT UP THE VALUES SEEN
	BLSS	90$			;BR IF SINGLE VALUE QUALIFIER
	CMPL	R0,#3			;SHOULD PAREN CHECK BE IGNORED?
	BEQL	90$			;YES, THEN BRANCH
	BSBW	DCL$SETCHAR		;PEEK AT NEXT CHARACTER
	CMPB	R0,#^A','		;TERMINATER SAY MORE VALUES COMING?
	BEQL	30$			;IF MORE COMING, PROCESS THEM
	CMPB	R0,#^A')'		;END OF VALUE LIST?
	BNEQ	80$			;IF NO-ITS AN ERROR
	BSBW	DCL$MOVCHAR		;COPY RIGHT PARENTHESIS DELIMITER
	BSBW	DCL$TESTBLANK		;THROW AWAY INSIGNIFICANT TRAILING BLANKSK
	BSBW	DCL$GENTERM		;SET ACTUAL TERMINATOR INSTEAD OF RPAREN
					;SINCE END OF LIST CAN BE DEDUCED BY
					;NON-QUALVALU TOKEN; AND SINCE BLANK
					;TERMINATOR MARKS A PARAMETER NEXT.

;
; DID WE GET MORE THAN ONE VALUE?  ARE VALUE LISTS ALLOWED?
;
	TSTL	R5			;DID WE GET MORE THAN ONE VALUE?
	BEQL	90$			;BR IF NO (PARENS WERE NOP)
	STATUS	ONEVAL			;ASSUME ONLY ONE VALUE ALLOWED
	BBC	#ENT_V_LIST,-		;ERROR IF NO LISTS ALLOWED
		ENT_W_FLAGS(R8),95$ 	;
	BRB	90$			;CONTINUE
 
;
; NO CLOSING PAREN SYNTAX ERROR
;
80$:	BSBW	DCL$MOVTOKN		;GET DELIMITER AND FOLLOWING TOKEN
	STATUS	NOPAREN			;SET INVALID SYNTAX
	BRB	95$			;EXIT WITH STATUS
 
;
; SINGLE VALUE QUALIFIER
;
90$:	STATUS	NORMAL			;SET SUCCESSFUL COMPLETION
95$:	POPL	R3			;RESTORE TOKEN TYPE
	RSB				;RETURN FROM SUBROUTINE

	.SBTTL	PARSE VALUE STRING
;+
; DCL$PARSE_VALUE - PARSE A SINGLE VALUE IN A VALUE LIST
;
; THIS ROUTINE IS CALLED TO SCAN A SINGLE VALUE AND STORE
; THE TOKEN DESCRIPTOR WHICH DESCRIBES IT.
;
; INPUTS:
;
;	R3 = CLASSIFICATION OF VALUE (PTR_K_QUALVALU OR PTR_K_PARAMETR)
;	R5 = -1 IF FIRST VALUE IN A PARENTHESIZED LIST
;	R8 = ADDRESS OF ENTITY DESCRIPTOR BLOCK
;	R10 = ADDRESS OF COMMAND WORK AREA
;
;	CHARACTER POINTER POINTS TO DELIMITER JUST BEFORE THE VALUE STRING
;
; OUTPUTS:
;
;	R0 = STATUS
;
;	INSIGNIFICANT BLANKS ARE THROWN AWAY FOLLOWING THE VALUE.
;	CHARACTER POINTER POINTS TO DELIMITER JUST AFTER THE VALUE STRING.
;
;	ONE (OR TWO) TOKEN DESCRIPTORS ARE OUTPUT DEPENDING ON WHETHER
;	THE SYNTAX WAS 'VALUE' OR 'KEYWORD=VALUE'.
;-

;
; VALID TERMINATOR LIST FOR VALUE STRINGS
;
TRMB:	.ASCII	\ +,/()\<0>		; SPACE,PLUS,COMMA,SLASH,PARENS AND EOL
TRME:

DCL$PARSE_VALUE:
	PUSHR	#^M<R3,R4,R5,R6,R7,R8>	;SAVE REGISTERS
	INCB	WRK_B_VALLEV(R10)	;INCREASE THE VALUE LEVEL
	MOVZBL	ENT_B_VALTYPE(R8),R0	;GET VALUE TYPE
	CMPB	R0,#ENT_K_FILE		;FILESPEC?
	BEQL	5$			;IF SO, PROCESS FILESPEC
	CMPB	R0,#ENT_K_INFILE	;INPUT FILESPEC?
	BEQL	5$			;IF SO, PROCESS FILESPEC
	CMPB	R0,#ENT_K_OUTFILE	;OUTPUT FILESPEC?
	BEQL	5$			;IF SO, PROCESS FILESPEC
	CMPB	R0,#ENT_K_NODE		;NODE NAME?
	BEQL	5$			;IF SO, PROCESS AS FILESPEC
	CMPB	R0,#ENT_K_DEVICE	;DEVICE NAME?
	BEQL	5$			;IF SO, PROCESS AS FILESPEC
	CMPB	R0,#ENT_K_DIR		;DIRECTORY SPEC?
	BEQL	5$			;IF SO, PROCESS AS FILESPEC
	CMPB	R0,#ENT_K_UIC		;UIC SPEC?
	BEQL	5$			;IF SO, PROCESS AS FILESPEC
	CMPB	R0,#ENT_K_RESTOFLINE	;REST OF LINE AS VALUE STRING?
	BEQL	10$			;IF SO, PROCESS IT
	CMPB	R0,#ENT_K_EXPRESSION	;$EXPRESSION?
	BEQL	12$			;IF SO, PROCESS IT
	CMPB	R0,#ENT_K_ACL		;$ACL?
	BEQL	13$			;IF SO, PROCESS IT
	CMPB	R0,#ENT_K_PARENVALUE	;$PAREN_VALUE?
	BEQL	15$			;IF SO, PROCESS IT
	BRB	17$			;IF NOT, BRANCH

5$:	BSBW	DCL$PROCFILE		;PARSE THE FILE SPEC
	BRW	90$			;SKIP TO END
10$:	BSBW	DCL$REST_OF_LINE	;PARSE $REST_OF_LINE VALUE
	BRW	90$			;EMIT A DESCRIPTOR
12$:	BSBW	DCL$EXPRESSION		;PARSE $EXPRESSION VALUE
	BRW	60$			;EMIT A DESCRIPTOR
13$:	BSBW	DCL$ACL			;PARSE $ACL VALUE
	BRW	90$			;SKIP TO END
15$:	BSBW	DCL$PAREN_VALUE		;PARSE VALUE
	BRW	90$			;SKIP TO END

;
; GET UNTYPED VALUE TOKEN (STOP AT "=" OR ":" IF KEYWORDS ARE ALLOWED)
;
17$:	BSBW	DCL$MOVCHAR		;COPY TERMINATOR INTO EXPANSION BUFFER
	BSBW	DCL$SETNBLK		;SKIP LEADING BLANKS
	BSBW	DCL$MARK		;MARK START OF VALUE STRING
20$:	BSBW	DCL$GTBTOKEN		;COPY TOKEN INTO EXPANSION BUFFER
	TSTL	ENT_L_USER_TYPE(R8)	;DOES VALUE TAKE KEYWORDS?
	BEQL	30$			;IF NOT, IGNORE EMBEDDED '=:'
	CMPB	R0,#^A'='		;VALUE SEPARATOR?
	BEQL	50$			;BR IF YES
	CMPB	R0,#^A':'		;CHECK IF END OF KEY AND START OF VALUE
	BEQL	50$			;BR IF YES
30$:	LOCC	R0,S^#TRME-TRMB,TRMB	;CHECK FOR VALUE STRING TERMINATOR
	BNEQ	50$			;BR IF TERMINATOR FOUND
	BSBW	DCL$MOVCHAR		;COPY CHARACTER WHICH STOPPED GETOKEN
	BRB	20$			;KEEP GETTING TOKENS UNTIL END OF VALUE
50$:	BSBW	DCL$MARKEDTOKEN		;GET DESCRIPTOR OF VALUE STRING
	BEQL	80$			;ERROR IF NO VALUE
	CMPB	ENT_B_VALTYPE(R8),-	;$QUOTED_STRING?
		#ENT_K_QUOTEDSTRING	;
	BEQL	51$			;IF SO, THEN SKIP COMPRESSION
	BSBW	DCL$COMPRESS		;COMPRESS QUOTED STRING

;
; PEFORM APPROPRIATE SYNTAX CHECKING OR CONVERSION ON THE VALUE JUST FETCHED.
;
51$:	MOVL	ENT_L_USER_TYPE(R8),R0	;ARE KEYWORDS ALLOWED?
	BNEQ	53$			;BRANCH IF SO
	MOVZBL	ENT_B_VALTYPE(R8),R0	;GET VALUE TYPE
	CMPB	R0,#ENT_K_NUMBER	;NUMBER?
	BEQL	56$			;BRANCH IF SO
	CMPB	R0,#ENT_K_DATETIME	;DATETIME?
	BEQL	59$			;BRANCH IF SO
	CMPB	R0,#ENT_K_DELTATIME	;DELTATIME?
	BEQL	59$			;BRANCH IF SO
	BRB	65$

80$:	STATUS	VALREQ			;SET MISSING VALUE STATUS
	BRB	90$			;EXIT WITH ERROR STATUS

53$:	MOVL	(SP),R3			;GET CLASSIFICATION OF VALUE TOKEN
	BSBW	DCL$PROCESS_KEYWORD	;PROCESS KEYWORD
	BLBC	R0,90$			;BRANCH IF ERROR
	BRB	70$			;CLEAN UP AND RETURN
56$:	BSBW	DCL$NUMBER		;PROCESS $NUMBER
	BLBC	R0,90$			;BRANCH IF ERROR
	BRB	65$			;GENERATE DESCRIPTOR
59$:	BSBW	DCL$DATETIME		;PROCESS $DATETIME
60$:	BLBC	R0,90$			;BRANCH IF ERROR

;
; GENERATE VALUE DESCRIPTOR
;
65$:	CLRL	R4			;CLEAR ENTITY NUMBER
	MOVL	(SP),R5			;GET CLASSIFICATION OF VALUE TOKEN (R3)
	CLRL	R6			;CLEAR THE FLAGS
	MOVL	R8,R9			;SET ADDRESS OF ENTITY BLOCK
	MOVQ	R1,R7			;SET LENGTH AND OFFSET OF VALUE 
	BSBW	DCL$GENDESCR		;GENERATE RESULT PARSE DESCRIPTOR

;
; CLEAN UP AND RETURN
;
70$:	BSBW	DCL$TESTBLANK		;THROW AWAY INSIGNIFICANT BLANKS
	BSBW	DCL$GENTERM		;AND SET TERMINATOR IN LAST TOKEN
	MOVL	#1,R0			;SET SUCCESSFUL
90$:	DECB	WRK_B_VALLEV(R10)	;DECREASE THE VALUE LEVEL
	POPR	#^M<R3,R4,R5,R6,R7,R8>	;RESTORE REGISTERS
	RSB

	.SBTTL	PROCESS KEYWORD
;+
; DCL$PROCESS_KEYWORD - PROCESS KEYWORD
;
; THIS ROUTINE IS CALLED TO PROCESS A KEYWORD AND TO EMIT A DESCRIPTOR 
; TO THE RESULT PARSE TABLE.
;
; INPUTS:
;
;	R0 = ADDRESS OF KEYWORD LIST HEADER
;	R1/R2 = KEYWORD DESCRIPTOR
;	R3 = ENTITY TYPE
;	R8 = ADDRESS OF ENTITY BLOCK
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;
; OUTPUTS:
;
;	R0 = STATUS
;-
 
DCL$PROCESS_KEYWORD:				;PROCESS KEYWORD

;
; VALIDATE THE KEYWORD
;
	ADDL3	R0,WRK_L_TAB_VEC(R10),R8	;GET ADDRESS OF KEYWORD LIST
	ASSUME	PTR_V_KEYWORD EQ 21		;
	ASSUME	V_KEYWD EQ 1			;
	MOVL	#M_KEYWD,R6			;SPECIFY THAT FULL LENGTH BE VALIDATED
	BSBW	DCL$FIND_KEYWORD		;VALIDATE THE KEYWORD
	BLBC	R0,90$				;EXIT IF INVALID
;
; CHECK NEGATION
;
	ASSUME	V_NEGAT EQ 0			;
	BLBC	R6,10$				;IF KEYWORD NOT NEGATED, THEN SKIP
	STATUS	NOTNEG				;ASSUME KEYWORD NOT NEGATABLE
	BBC	#ENT_V_NEG,-			;EXIT IF NEGATED
		ENT_W_FLAGS(R8),90$		;

;
; PROCESS CHANGE LIST - IF ANY
;
10$:	TSTL	ENT_L_SYNTAX(R8)		;ALTERNATE COMMAND SYNTAX SPECIFIED?
	BEQL	20$				;BRANCH IF NOT
	PUSHL	R1				;SAVE R1
	BSBW	DCL$CHANGE_SYNTAX		;CHANGE COMMAND SYNTAX
	POPL	R1				;RESTORE R1
	ASSUME	PTR_V_SYNTAX EQ 22		;
	ASSUME	V_SYNTAX EQ 2			;
	BISL	#M_SYNTAX,R6			;SET SYNTAX CHANGE BIT

;
; GENERATE VALUE (KEYWORD) DESCRIPTOR
;
20$:	MOVL	R7,R4				;GET KEYWORD NUMBER
	MOVL	R3,R5				;GET CLASSIFICATION OF VALUE TOKEN
	MOVQ	R7,-(SP)			;SAVE KEYWORD NUM AND ADDR OF ENTITY BLOCK
	MOVL	R8,R9				;SET ADDRESS OF ENTITY BLOCK
	MOVQ	R1,R7				;SET LENGTH AND OFFSET OF VALUE 
	BSBW	DCL$GENDESCR			;GENERATE RESULT PARSE DESCRIPTOR
	MOVQ	(SP)+,R7			;RESTORE SAVED REGISTERS

;
; DO WE HAVE A KEYWORD VALUE LEFT TO PROCESS?
;
	BSBW	DCL$CHECK_VALUES		;MAKE INDIRECTLY RECURSIVE CALL
90$:	RSB					;RETURN WITH STATUS

	.SBTTL	PROCESS FILE SPECIFICATION
;+
; DCL$PROCFILE - PROCESS FILE SPECIFICATION.
;
; THIS ROUTINE IS CALLED TO SCAN A FILE SPECIFICATION FOR SYNTACTIC CORRECT-
; NESS AND TO EMIT A FILE DESCRIPTOR TO THE RESULT PARSE TABLE.
;
; INPUTS:
;
;	R3 = VALUE CONTEXT (PTR_K_QUALVALU OR PTR_K_PARAMETR) FOR DESCRIPTOR
;	R8 = ADDRESS OF ENTITY BLOCK
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;
; OUTPUTS:
;
;	R0 = STATUS
;	R1/R2 = DESCRIPTOR OF FILE SPECIFICATION STRING, IF SUCCESSFUL
;-
 
DCL$PROCFILE::					;PROCESS FILE SPECIFICATION
;
; SET STATE TO START OF FILE SPECIFICATION.
;
	PUSHR	#^M<R3,R4,R5,R6,R7,R8>		;SAVE REGISTERS
	BSBW	DCL$MOVCHAR			;MOVE TERMINATOR CHARACTER
	BSBW	DCL$MARK			;MARK CURRENT POSITION IN BUFFER
DCL$PROCFILE1:
	BSBW	DCL$GETOKEN			;GET NEXT TOKEN
	BNEQ	5$				;IF NEQ THEN FOUND

;
; NO TOKEN OBTAINED - CHECK FOR NULL NODE.
;
;	'::DEVICE...' 
;
	CMPB	#^A/:/,R0		;FIRST COLON PRESENT?
	BNEQ	20$			;IF NEQ NO
	BSBW	DCL$MOVCHAR		;MOVE TERMINATOR TO COMMAND BUFFER
	BSBW	DCL$SETCHAR		;PEEK AT NEXT CHARACTER IN INPUT BUFFER
	CMPB	#^A/:/,R0		;SECOND COLON PRESENT?
	BEQL	7$			;IF YES THEN LOOK FOR MORE NODES,DEVICES
	BRW	950$			;IF NO THEN ERROR

;
; TOKEN OBTAINED - FORM MUST BE:
;
;	'NODE::' OR,
;	'DEVICE:' OR,
;	'FILENAME.' OR,
;	'FILENAME;' OR,
;	'FILENAME-' OR,
;	'FILENAME '.
;
5$:	CMPB	#^A/:/,R0		;NODE OR DEVICE NAME?
	BNEQ	60$			;IF NEQ NO
 
;
; NODE OR DEVICE NAME
;
	BSBW	DCL$MOVCHAR		;MOVE TERMINATOR TO COMMAND BUFFER
	BSBW	DCL$SETCHAR		;PEEK AT NEXT CHARACTER IN INPUT BUFFER
	CMPB	#^A/:/,R0		;NODE NAME?
	BNEQ	10$			;IF NEQ NO
7$:	BSBW	DCL$MOVBTOKN		;MOVE TERMINATOR AND GET BLANK TOKEN
	BEQL	20$			;IF EQL NONE
	BRB	5$			;LOOP TO ALLOW ANOTHER NODE NAME

10$:	BSBW	DCL$GTBTOKEN		;GET NEXT BLANK TOKEN
	BNEQ	60$			;IF NEQ TOKEN OBTAINED
 
;
; NO TOKEN OBTAINED - FORM MUST BE:
;
;	'[DIRECTORY]' OR,
;	'<DIRECTORY>' OR,
;	'.TYPE' OR,
;	';VERSION'.
;
20$:	CMPB	#^A/[/,R0		;DIRECTORY?
	BEQL	30$			;IF EQL YES
	CMPB	#^A/</,R0		;DIRECTORY?
	BNEQ	60$			;IF NEQ NO
30$:	MOVAB	2(R0),AP		;SAVE DIRECTORY TERMINATOR CHARACTER
	BSBW	DCL$MOVBTOKN		;MOVE TERMINATOR AND GET BLANK TOKEN
	CMPB	#^A/,/,R0		;OLD STYLE DIRECTORY?
	BNEQ	40$			;IF NEQ NO
 
;
; OLD STYLE DIRECTORY - FORM IS:
;
;	'[GROUP,MEMBER]'.
;
 
	BSBW	DCL$MOVBTOKN		;MOVE TERMINATOR AND GET BLANK TOKEN
	CMPB	R0,AP			;EXPECTED TERMINATOR?
	BEQL	50$			;BRANCH IF YES
120$:	STATUS	DIRECT			;RETURN INVALID DIRECTORY SYNTAX
	BRB	900$			;AND EXIT WITH ERROR
 
;
; NEW STYLE DIRECTORY - FORM IS:
;
;	'<SUB.SUB...SUB>'.
;
 
40$:	CMPB	R0,AP			;EXPECTED TERMINATOR?
	BEQL	50$			;IF EQL YES
	CMPB	#^A/./,R0		;SUBDIRECTORY?
	BEQL	45$			;IF EQL, TERMINATOR OK
	CMPB	#^A/-/,R0		;BACKUP SYMBOL?
	BNEQ	120$			;IF NEQ, INVALID SYNTAX
45$:	BSBW	DCL$MOVBTOKN		;MOVE TERMINATOR AND GET BLANK TOKEN
	BRB	40$			;
50$:	BSBW	DCL$MOVBTOKN		;MOVE TERMINATOR AND GET BLANK TOKEN
	BRB	20$			;CHECK FOR MORE DIRECTORIES
 
;
; FILENAME, TYPE, OR VERSION - FORM MUST BE:
;
;	'FILENAME.' OR,
;	'FILENAME;' OR,
;	'FILENAME-FILENAME' OR,
;	'FILENAME ' OR,
;	'.TYPE' OR,
;	';VERSION'.
;
 
60$:	CMPB	#^A/-/,R0		;CONTINUED FILENAME?
	BNEQ	65$			;IF NEQ NO
	BSBW	DCL$MOVBTOKN		;MOVE TERMINATOR AND GET BLANK TOKEN
	BRB	60$			;LOOK FOR MORE OF FILENAME
65$:	CMPB	#^A/./,R0		;FILE TYPE?
	BNEQ	70$			;IF NEQ NO
67$:	BSBW	DCL$MOVBTOKN		;MOVE TERMINATOR AND GET BLANK TOKEN
	CMPB	#^A/-/,R0		;CONTINUED FILE TYPE?
	BEQL	67$			;IF EQL YES
	CMPB	#^A/./,R0		;NEW VERSION FORMAT?
	BEQL	80$			;IF EQL YES
 
;
; FILE VERSION - FORM MUST BE:
;
;	';VERSION'.
;
 
70$:	CMPB	#^A/;/,R0		;FILE VERSION?
	BNEQ	100$			;IF NEQ NO
80$:	BSBW	DCL$MOVBTOKN		;MOVE TERMINATOR AND GET BLANK TOKEN
	BNEQ	100$			;IF NON-NULL, GOT VERSION STRING
	CMPB	#^A/-/,R0		;NEGATIVE VERSION?
	BNEQ	100$			;IF NEQ NO
	BSBW	DCL$MOVBTOKN		;MOVE TERMINATOR AND GET BLANK TOKEN

;
; FILE SPECIFICATION SCANNED - CHECK RESULT
;
100$:	BSBW	DCL$MARKEDTOKEN			;GET DESCRIPTOR OF PARAMETER STRING
	BEQL	950$				;IF NONE, EXIT WITH ERROR

	MOVQ	R1,-(SP)			;COPY DESCRIPTOR
;	CLRQ	-(SP)				;CREATE ITEM LIST
;	MOVL	#FSCN$_FILESPEC@16,-(SP)	;SET ITEM CODE
;	MOVL	SP,R0				;GET ADDRESS OF ITEM LIST
;	$FILESCAN_S  SRCSTR=12(R0),-		;SCAN THE FILE SPEC
;		VALUELST=(R0)			;
;	ADDL	#3*4,SP				;POP THE ITEM LIST
	MOVQ	(SP)+,R7			;POP THE FILESPEC DESCR
;	BLBC	R0,950$				;RETURN ERROR IF LBC

	CLRL	R4				;CLEAR ENTITY BLOCK ADDRESS
	CLRL	R6				;CLEAR FLAGS
	MOVL	(SP),R5				;GET VALUE CONTEXT (R3 ON ENTRY)
	BSBW	DCL$GENDESCR			;GENERATE RESULT PARSE DESCRIPTOR
	MOVQ	R7,R1				;RETURN FILESPEC DESCRIPTOR TO CALLER
	STATUS	NORMAL				;SET SUCCESSFUL COMPLETION
900$:	POPR	#^M<R3,R4,R5,R6,R7,R8>		;RESTORE REGISTERS
	RSB					;RETURN FROM SUBROUTINE

950$:	STATUS	NULFIL				;SET INVALID FILE SPEC STATUS
	POPR	#^M<R3,R4,R5,R6,R7,R8>		;RESTORE REGISTERS
	RSB					;RETURN FROM SUBROUTINE

	.SBTTL	PROCESS REST OF LINE VALUE
;+
; DCL$REST_OF_LINE  - PROCESS REST OF LINE VALUE
;
; THIS ROUTINE IS PROCESS A $REST_OF_LINE VALUE AND PREPARE TO EMIT A 
; DESCRIPTOR TO THE RESULT PARSE TABLE.
;
; INPUTS:
;
;	R3 = CLASSIFICATION OF VALUE (PTR_K_QUALVALU OR PTR_K_PARAMETR)
;	R8 = ADDRESS OF ENTITY BLOCK
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;
; OUTPUTS:
;
;	R1/R2 = DESCRIPTOR OF $REST_OF_LINE VALUE
;-
 
DCL$REST_OF_LINE:				;PROCESS REST OF LINE
;
; GET REST OF LINE.
;
	PUSHL	R3				;SAVE TOKEN TYPE
	BBS	#WRK_V_USRMODE,-		;IF SET THEN USER MODE PARSE
		WRK_W_FLAGS(R10),10$ 		;
	SETBIT	PRC_V_IND,-			;DISABLE @ INDIRECTION, SO THAT @
		PRC_W_FLAGS(R11)		;CAN BE PASSED IN THE VALUE
10$:	BSBW	DCL$MOVCHAR			;COPY TERMINATOR INTO EXPANSION BUFFER
	BSBW	DCL$SETNBLK			;SKIP LEADING BLANKS
	BSBW	DCL$MARK			;MARK START OF VALUE STRING
20$:	BSBW	DCL$MOVCHAR			;COPY NEXT CHARACTER
	BNEQ	20$				;LOOP UNTIL END OF LINE
	BBS	#WRK_V_USRMODE,-		;IF SET THEN USER MODE PARSE
		WRK_W_FLAGS(R10),30$ 		;
	CLRBIT	PRC_V_IND,-			;RE-ENABLE @ INDIRECTION AGAIN
		PRC_W_FLAGS(R11) 		;
30$:	BSBW	DCL$MARKEDTOKEN			;GET DESCRIPTOR OF MARKED TOKEN
	DECL	R1				;SUBTRACT OUT EOL CHARACTER

;
; GENERATE VALUE DESCRIPTOR
;
	CLRL	R4				;CLEAR ENTITY NUMBER
	MOVL	(SP)+,R5			;GET CLASSIFICATION OF VALUE TOKEN (R3)
	CLRL	R6				;CLEAR THE FLAGS
	MOVL	R8,R9				;SET ADDRESS OF ENTITY BLOCK
	MOVQ	R1,R7				;SET LENGTH AND OFFSET OF VALUE 
	BSBW	DCL$GENDESCR			;GENERATE RESULT PARSE DESCRIPTOR

;
; CLEAN UP AND RETURN
;
	BSBW	DCL$TESTBLANK			;THROW AWAY INSIGNIFICANT BLANKS
	BSBW	DCL$GENTERM			;AND SET TERMINATOR IN LAST TOKEN
	MOVL	#3,R0				;SET SUCCESSFUL
	RSB					;RETURN

	.SBTTL	PROCESS $NUMBER VALUE
;+
; DCL$NUMBER - PROCESS $NUMBER VALUE
;
; THIS ROUTINE IS CALLED TO SCAN A $NUMBER VALUE FOR SYNTACTIC CORRECTNESS,
; CONVERT THAT NUMBER TO A DECIMAL STRING, AND PREPARE TO EMIT A DESCRIPTOR 
; FOR THAT DECIMAL STRING TO THE RESULT PARSE TABLE.
;
; INPUTS:
;
;	R1/R2 = DESCRIPTOR OF VALUE STRING
;	R8 = ADDRESS OF ENTITY BLOCK
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;
; OUTPUTS:
;
;	R0 = STATUS
;	R1/R2 = DESCRIPTOR OF DECIMAL STRING, IF SUCCESSFUL
;-
 
DCL$NUMBER:				;PROCESS $NUMBER
	PUSHL	R1			;SAVE STRING LENGTH
	MOVQ	R1,R2			;COPY DESCRIPTOR OF STRING
	MOVL	#1,R1			;SET DECIMAL RADIX
	BSBW	DCL$CNVNOEDIT		;CHECK THE NUMBER
	TSTL	R0			;WAS STRING COMPLETELY PARSED?
	BNEQ	80$			;BRANCH IF ERROR
	POPL	R0			;GET THE STRING LENGTH
	SUBL	R0,WRK_L_EXPANDPTR(R10)	;REMOVE IT FROM THE EXPANSION BUFFER
	MOVL	R1,R0			;GET THE VALUE TO CONVERT
	BSBW	DCL$CBTA_DEC		;CONVERT THE BINARY VALUE TO DECIMAL
	ADDL	R1,WRK_L_EXPANDPTR(R10)	;UPDATE THE EXPANSION BUFFER PTR
	STATUS	NORMAL			;SET NORMAL STATUS
	RSB				;RETURN

80$:	POPL	R1			;POP STRING LENGTH
	STATUS	NUMBER			;SET STATUS
	RSB				;RETURN

	.SBTTL	PROCESS $DATETIME VALUE
;+
; DCL$DATETIME - PROCESS $DATETIME VALUE
;
; THIS ROUTINE IS CALLED TO SCAN A $DATETIME VALUE FOR SYNTACTIC CORRECTNESS,
; CONVERT THAT TIME TO AN ABSOLUT TIME, AND PREPARE TO EMIT A DESCRIPTOR FOR
; THAT ABSOLUTE TIME STRING TO THE RESULT PARSE TABLE.
;
; INPUTS:
;
;	R0 = ENT_K_DATETIME OR ENT_K_DELTATIME
;	R1/R2 = DESCRIPTOR OF VALUE STRING
;	R8 = ADDRESS OF ENTITY BLOCK
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;
; OUTPUTS:
;
;	R0 = STATUS
;	R1/R2 = DESCRIPTOR OF ABSOLUTE TIME STRING, IF SUCCESSFUL
;-
 
DCL$DATETIME:					;PROCESS $DATETIME OR $DELTATIME

;
; ALLOCATE INPUT DESCRIPTOR, TIME QUADWORD, AND OUTPUT DESCRIPTOR.
;
	PUSHL	R0				;SAVE TYPE CODE
	MOVQ	R1,-(SP)			;SAVE STRING DESCRIPTOR
	MOVL	SP,R3				;GET ADDRESS OF THE DESCRIPTOR
	CLRQ	-(SP)				;ALLOCATE A QUADWORD TIME BUFFER
	MOVL	SP,R4				;SAVE ITS ADDRESS
	MOVAB	WRK_G_BUFFER+WRK_C_CMDBUFSIZ(R10),R0  ;FIND END OF BUFFER
	ADDL	R0,R1				;ADD LENGTH OF STRING TO BE REMOVED
	SUBL	WRK_L_EXPANDPTR(R10),R1		;CALCULATE AMOUNT LEFT
	MOVQ	R1,-(SP)			;PUSH OUTPUT DESCRIPTOR

;
; CALL LIB$CVT_TIME.
;
	MOVL	24(SP),R0			;GET TYPE CODE
	PUSHL	SP				;PUSH ADDRESS OF DESCRIPTOR TWICE
	PUSHAB	4(SP)				;
	MOVQ	R3,-(SP)			;PUSH INPUT DESCRIPTOR AND BUFFER
	CMPL	R0,#ENT_K_DATETIME		;IS IT $DATETIME
	BNEQ	50$				;NO, THEN $DELTATIME
	CALLS	#4,LIB$CVT_TIME			;PARSE THE TIME SPECIFICATION
	BRB	60$				;BRANCH
50$:	CALLS	#4,LIB$CVT_DTIME		;PARSE THE TIME SPECIFICATION

;
; RESTORE STACK AND BRANCH IF ERROR.
;
60$:	MOVQ	(SP)+,R1			;GET OUTPUT DESCRIPTOR
	ADDL	#8,SP				;POP TIME BUFFER
	MOVQ	(SP)+,R3			;GET INPUT DESCRIPTOR
	POPL	R5				;POP THE TYPE CODE
	BLBC	R0,90$				;BRANCH IF ERROR

;
; RESET EXPANSION BUFFER POINTER.
;
	SUBL	R3,WRK_L_EXPANDPTR(R10)		;REMOVE INPUT FROM THE EXPANSION BUFFER
	ADDL	R1,WRK_L_EXPANDPTR(R10)		;INSERT OUTPUT IN THE EXPANSION BUFFER
	RSB					;RETURN

90$:	CMPL	R0,#CLI$_BUFOVF			;WAS IT BUFFER OVERFLOW
	BEQL	95$				;YES, THEN RETURN THAT STATUS
	CMPL	R5,#ENT_K_DATETIME		;IS IT $DATETIME
	BNEQ	97$				;NO, THEN $DELTATIME
	STATUS	IVATIME				;SET INVALID ABSOLUTE TIME
95$:	RSB					;RETURN
97$:	STATUS	IVDTIME				;SET INVALID DELTA TIME
	RSB					;RETURN

;
; DEFINE A STUB DCL$SCOPY_DXDX ROUTINE FOR USE BY LIB$CVTTIME.
;
; INPUTS:  INPUT DESCRIPTOR, OUTPUT DESCRIPTOR
;
	.ENTRY	DCL$SCOPY_DXDX,^M<R2,R3,R4,R5>
	MOVL	4(AP),R1			;GET INPUT DESCRIPTOR
	MOVL	8(AP),R2			;GET OUTPUT DESCRIPTOR
	CMPW	(R1),(R2)			;WILL STRING FIT
	BGTRU	90$				;NO, THEN RETURN ERROR
	MOVZWL	(R1),(R2)			;COPY STRING LENGTH
	MOVC3	(R2),@4(R1),@4(R2)		;COPY DESCRIPTOR	
	MOVL	#1,R0				;SET NORMAL STATUS
	RET					;RETURN

90$:	STATUS	BUFOVF				;SET BUFFER OVERFLOW
	RET					;RETURN	

	.SBTTL	PROCESS $PARENTHESIZED_VALUE VALUE
;+
; DCL$PAREN_VALUE - PROCESS $PARENTHESIZED_VALUE VALUE
;
; THIS ROUTINE IS CALLED TO PROCESS A $PARENTHESIZED_VALUE VALUE AND TO EMIT A 
; DESCRIPTOR TO THE RESULT PARSE TABLE.
;
; INPUTS:
;
;	R3 = CLASSIFICATION OF VALUE (PTR_K_QUALVALU OR PTR_K_PARAMETR)
;	R5 = -1 IF FIRST VALUE IN A PARENTHESIZED LIST
;	R8 = ADDRESS OF ENTITY BLOCK
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;
; OUTPUTS:
;
;	R0 = STATUS
;	R1/R2 = DESCRIPTOR OF VALUE
;-
 
DCL$PAREN_VALUE:			;PROCESS LIST
	PUSHR	#^M<R3,R4,R5,R6,R7,R8>	;SAVE REGISTERS
	MOVL	#1,R4			;SET PAREN COUNT

;
; CHECK FOR AND SAVE LEADING PAREN.  IF NONE, PROCESS AS A FILE SPEC.
;
	BSBW	DCL$MOVCHAR		;COPY TERMINATOR INTO EXPANSION BUFFER
	BSBW	DCL$MARK		;MARK START OF VALUE STRING
	CMPL	#-1,R5			;WAS PAREN ALREADY SEEN?
	BEQL	10$			;YES, THEN BRANCH
	BSBW	DCL$SETNBLK		;SKIP LEADING BLANKS
	CMPB	R0,#^A'('		;IS FIRST CHAR AN OPEN PAREN?
	BEQL	20$			;YES, THEN BRANCH
	BRW	DCL$PROCFILE1		;NO, PROCESS AS A FILE SPEC

10$:	BSBW	DCL$BACKUPMOVE		;RESTORE FIRST PAREN
	BSBW	DCL$MARK		;MARK START OF VALUE STRING
20$:	BSBW	DCL$MOVCHAR		;COPY PAREN INTO EXPANSION BUFFER

;
; GET REST OF $PARENTHESIZED_VALUE
;
25$:	BSBW	DCL$GTBTOKEN		;COPY TOKEN INTO EXPANSION BUFFER
	BSBW	DCL$MOVCHAR		;COPY CHARACTER WHICH STOPPED GETOKEN
	BEQL	90$			;ERROR IF END OF LINE
	CMPB	R0,#^A')'		;CLOSE PAREN?
	BNEQ	30$			;NO, THEN SKIP
	DECL	R4			;DECREMENT PAREN COUNT
	BEQL	40$			;BRANCH IF DONE
	BRB	25$			;KEEP GETTING TOKENS
30$:	CMPB	R0,#^A'('		;OPEN PAREN?
	BNEQ	25$			;NO, THEN SKIP
	INCL	R4			;INCREMENT PAREN COUNT
	BRB	25$			;KEEP GETTING TOKENS

;
; GENERATE VALUE DESCRIPTOR
;
40$:	BSBW	DCL$MARKEDTOKEN		;GET DESCRIPTOR OF VALUE STRING
	CLRL	R4			;CLEAR ENTITY NUMBER
	MOVL	(SP),R5			;GET CLASSIFICATION OF VALUE TOKEN (R3)
	CLRL	R6			;CLEAR THE FLAGS
	MOVL	R8,R9			;SET ADDRESS OF ENTITY BLOCK
	MOVQ	R1,R7			;SET LENGTH AND OFFSET OF VALUE 
	BSBW	DCL$GENDESCR		;GENERATE RESULT PARSE DESCRIPTOR

;
; CLEAN UP AND RETURN
;
	BSBW	DCL$TESTBLANK		;THROW AWAY INSIGNIFICANT BLANKS
	BSBW	DCL$GENTERM		;AND SET TERMINATOR IN LAST TOKEN
	POPR	#^M<R3,R4,R5,R6,R7,R8>	;RESTORE REGISTERS
	MOVL	#3,R0			;SET STATUS
	RSB				;

90$:	POPR	#^M<R3,R4,R5,R6,R7,R8>	;RESTORE REGISTERS
	STATUS	NOPAREN			;SET INVALID SYNTAX
	RSB				;

	.SBTTL	PROCESS $ACL VALUE
;+
; DCL$ACL - PROCESS $ACL VALUE
;
; THIS ROUTINE IS CALLED TO PROCESS A $ACL VALUE AND TO EMIT A 
; DESCRIPTOR TO THE RESULT PARSE TABLE.
;
; INPUTS:
;
;	R3 = CLASSIFICATION OF VALUE (PTR_K_QUALVALU OR PTR_K_PARAMETR)
;	R5 = -1 IF FIRST VALUE IN A PARENTHESIZED LIST
;	R8 = ADDRESS OF ENTITY BLOCK
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;
; OUTPUTS:
;
;	R0 = STATUS
;	R1/R2 = DESCRIPTOR OF VALUE
;-
 
DCL$ACL:				;PROCESS LIST
	MOVL	#1,-(SP)		;CLEAR SIGNIFICANT PAREN FLAG
	PUSHL	R3			;SAVE R3

;
; DETERMINE IF PROCESSING FIRST LIST AFTER AN EQUAL SIGN AND HANDLE
; SPECIAL CASE OF POSSIBLY ONE OR TWO OPEN PARENTHESES.
;
	BSBW	DCL$MOVCHAR		;COPY TERMINATOR INTO EXPANSION BUFFER
	BSBW	DCL$SETNBLK		;SKIP LEADING BLANKS
	BSBW	DCL$MARK		;MARK START OF VALUE STRING
	CMPB	R0,#^A'('		;IS NEXT CHAR OPEN PAREN?
	BEQL	10$			;YES, THEN SKIP
	CMPL	#-1,R5			;FIRST VALUE IN LIST?
	BNEQ	85$			;NO, THEN ERROR
	BSBW	DCL$BACKUPMOVE		;YES, RESTORE FIRST PAREN
	MOVL	#3,4(SP)		;MARK FIRST PAREN WAS SIGNIFICANT
10$:	MOVL	#1,R4			;SET PAREN COUNT
	BSBW	DCL$MARK		;MARK START OF VALUE STRING
	BSBW	DCL$MOVCHAR		;COPY PAREN INTO EXPANSION BUFFER

;
; GET REST OF $ACL
;
20$:	BSBW	DCL$GTBTOKEN		;COPY TOKEN INTO EXPANSION BUFFER
	BSBW	DCL$MOVCHAR		;COPY CHARACTER WHICH STOPPED GETOKEN
	BEQL	90$			;ERROR IF END OF LINE
	CMPB	R0,#^A')'		;CLOSE PAREN?
	BNEQ	30$			;NO, THEN SKIP
	DECL	R4			;DECREMENT PAREN COUNT
	BEQL	40$			;BRANCH IF DONE
	BRB	20$			;KEEP GETTING TOKENS
30$:	CMPB	R0,#^A'('		;OPEN PAREN?
	BNEQ	20$			;NO, THEN SKIP
	INCL	R4			;INCREMENT PAREN COUNT
	BRB	20$			;KEEP GETTING TOKENS

;
; GENERATE VALUE DESCRIPTOR
;
40$:	BSBW	DCL$MARKEDTOKEN		;GET DESCRIPTOR OF VALUE STRING
	CLRL	R4			;CLEAR ENTITY NUMBER
	MOVL	(SP)+,R5		;GET CLASSIFICATION OF VALUE TOKEN (R3)
	CLRL	R6			;CLEAR THE FLAGS
	MOVL	R8,R9			;SET ADDRESS OF ENTITY BLOCK
	MOVQ	R1,R7			;SET LENGTH AND OFFSET OF VALUE 
	BSBW	DCL$GENDESCR		;GENERATE RESULT PARSE DESCRIPTOR

;
; CLEAN UP AND RETURN
;
	BSBW	DCL$TESTBLANK		;THROW AWAY INSIGNIFICANT BLANKS
	BSBW	DCL$GENTERM		;AND SET TERMINATOR IN LAST TOKEN
	POPL	R0			;SET STATUS
	RSB				;

85$:	BSBW	DCL$GTBTOKEN		;COPY TOKEN INTO EXPANSION BUFFER
90$:	ADDL	#8,SP			;POP STATUS AND R3
	STATUS	NOPAREN			;SET INVALID SYNTAX
	RSB				;

	.SBTTL	PROCESS $EXPRESSION VALUE
;+
; DCL$EXPRESSION - PROCESS $EXPRESSION VALUE
;
; THIS ROUTINE IS CALLED TO PROCESS A $EXPRESSION VALUE AND EMIT A 
; DESCRIPTOR TO THE RESULT PARSE TABLE.
;
; ***** NOT SUPPORTED FOR CLI$DCL_PARSE CALLS *****
;
; INPUTS:
;
;	R3 = CLASSIFICATION OF VALUE (PTR_K_QUALVALU OR PTR_K_PARAMETR)
;	R5 = -1 IF FIRST VALUE IN A PARENTHESIZED LIST
;	R8 = ADDRESS OF ENTITY BLOCK
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;
; OUTPUTS:
;
;	R0 = STATUS
;	R1/R2 = DESCRIPTOR OF VALUE
;-
 
DCL$EXPRESSION:					;PROCESS VALUE
;
; EVALUATE THE EXPRESSION.
;
	BSBW	DCL$MOVCHAR			;COPY TERMINATOR INTO EXPANSION BUFFER
	BSBW	DCL$SETNBLK			;SKIP LEADING BLANKS
	PUSHL	WRK_L_EXPANDPTR(R10)		;SAVE PRE-EVALUATION EXPANSION PTR
	BSBW	DCL$EXPRESS			;EVALUATE THE EXPRESSION
	BLBC	R0,95$				;BRANCH IF ERROR
	MOVL	(SP)+,WRK_L_EXPANDPTR(R10)	;RESET EXPANSION PTR

;
; CONVERT BINARY RESULTS TO ASCII.
;
	TSTL	R2				;BINARY RESULT?
	BNEQ	50$				;NO, THEN SKIP CONVERSION
	MOVL	R1,R0				;GET THE VALUE TO CONVERT
	BSBW	DCL$CBTA_DEC			;CONVERT THE BINARY VALUE TO DECIMAL
	BRB	80$				;DONE

;
; COPY THE ASCII EXPRESSION RESULT OVER THE ORIGINAL EXPRESSION
;
50$:	PUSHL	R1				;SAVE STRING LENGTH
	MOVC	R1,(R2),@WRK_L_EXPANDPTR(R10)	;COPY THE STRING
	POPL	R1				;RESTORE STRING LENGTH
	MOVL	WRK_L_EXPANDPTR(R10),R2		;GET THE BUFFER ADDRESS
	
;
; CLEANUP AND RETURN.
;
80$:	ADDL	R1,WRK_L_EXPANDPTR(R10)		;UPDATE THE EXPANSION BUFFER PTR
	STATUS	NORMAL				;SET SUCCESS
90$:	RSB					;
;
; EXPRESSION EVALUATION ERROR
;
95$:	TSTL	(SP)+				;FIX STACK
	RSB

	.SBTTL	ISSUE PROMPT AND GET RESPONSE
;---
; ISSUE_PROMPT - ISSUE PROMPT AND GET RESPONSE
;
; THIS ROUTINE IS CALLED WHEN A REQUIRED PARAMETER IS MISSING
; FROM A COMMAND.  THE USER IS PROMPTED FOR MORE INPUT.
;
; INPUTS:
;
;	R8 =	ADDRESS OF ENTITY BLOCK
;	R10 =	ADDRESS OF COMMAND WORK AREA
;	R11 =	ADDRESS OF PROCESS WORK AREA (FOR SUPERVISOR MODE PROMPTING)
;
;	WRK_B_PARMCNT = # PARAMETERS OBTAINED SO FAR
;
; OUTPUTS:
;
;	R0 = NEXT CHARACTER IN INPUT BUFFER
;	R1 = RETURN STATUS
;---

ISSUE_PROMPT:
;
; ALLOCATE SPACE FOR THE PARAMETER PROMPT ON THE STACK.
;
	MOVQ	WRK_W_PMPTLEN(R10),-(SP);SAVE PREVIOUS PROMPT STRING DESCRIPTOR
	SUBL	#ENT_K_MAX_PROMPT+8,SP	;GET SIZE OF THE BIGGEST PROMPT STRING
					;PLUS EXTRA FOR COUNT,COLON,SPACE,ETC.
	MOVL	SP,R3			;GET ADDRESS OF STORAGE TO BUILD PROMPT STRING

;
; INITIALIZE THE PROMPT.
;
	CLRB	(R3)+			;ZERO LENGTH OF PROMPT STRING
	BBS	#WRK_V_USRMODE,-	;IF SET THEN USER PROMPT ROUTINE
		WRK_W_FLAGS(R10),10$	;
	MOVW	PRC_W_PMPTCTRL(R11),(R3)+ ;INSERT CR/LF PAIR
10$:	MOVB	#^A/_/,(R3)+		;SET CONTINUATION CHARACTER

;
; GET THE PROMPT STRING FROM THE TABLES
;
	CVTWL	ENT_W_PROMPT(R8),R0	;GET PROMPT STRING OFFSET
	ADDL	R8,R0			;GET PROMPT STRING ADDRESS

;
; INSERT THE PARAMETER PROMPT ON THE STACK
;
	MOVZBL	(R0)+,R1		;LENGTH IN R1, ADDRESS IN R0
40$:	MOVB	(R0)+,(R3)+		;MOVE CHARACTER TO PROMPT STRING
	SOBGTR	R1,40$			;ANY MORE TO MOVE?
	MOVW	#^A/: /,(R3)+		;INSERT SUFFIX CHARACTERS
	SUBL3	SP,R3,R1		;GET NUMBER OF CHARACTERS IN PROMPT
	SUBB3	#1,R1,(SP)		;SET NEW LENGTH

;
; DO EITHER SUPERVISOR MODE OR USER MODE PROMPT
;
	BBS	#WRK_V_USRMODE,-	;IF SET THEN USER PROMPT ROUTINE
		WRK_W_FLAGS(R10),60$	;

;
; PROMPT FOR THE PARAMETER USING DCL'S PROMPT ROUTINE
;
	MOVZBW	(SP),WRK_W_PMPTLEN(R10)	;SET PROMPT STRING LENGTH
	MOVAB	1(SP),WRK_L_PMPTADDR(R10);SET PROMPT STRING ADDRESS
	SETBIT	WRK_V_INQUIRE,-		;MAKE IT LOOK LIKE INQUIRE
		WRK_W_FLAGS(R10) 	; SO WE GET BACK CONTROL/Z'S (EOF)
	SETBIT	WRK_V_CONTIN,-		;MAKE IT LOOK LIKE A CONTINUATION
		WRK_W_FLAGS(R10)	; SO THE RECALL BUFFER IS UPDATED
	BSBW	DCL$FORNBLK		;FORCE NONBLANK CHARACTER
	BNEQ	50$			;BRANCH IF NON-NULL
	MOVL	PRC_L_INPRAB(R11),R1	;GET ADDRESS OF INPUT RAB
	CMPW	RAB$L_STS(R1),-		;END OF FILE?
		#RMS$_EOF&^XFFFF 	;
	BNEQ	50$			;BRANCH IF NOT
	MOVZBL	#CTRLZ,R0		;YES, THEN SKIP THIS COMMAND
50$:	CLRBIT	WRK_V_INQUIRE,-		;CLEAR INQUIRE FLAG
		WRK_W_FLAGS(R10) 	;
	CLRBIT	WRK_V_CONTIN,-		;CLEAR CONTINUATION FLAG
		WRK_W_FLAGS(R10) 	;
	MOVL	#1,R1			;SET NORMAL STATUS
	BRB	90$			;GO CLEAN-UP

;
; PROMPT FOR THE PARAMETER USING THE USER'S PROMPT ROUTINE
;
60$:	MOVL	SP,R1			;GET ADDRESS OF ASCIC PROMPT STRING
	MOVAB	1(R1),-(SP)		;PUSH PROMPT STRING ADDRESS
	MOVZBL	(R1),-(SP)		;PUSH PROMPT STRING LENGTH
	MOVL	SP,R1			;GET ADDR OF PROMPT DESCRIPTOR
	MOVL	WRK_L_PROMPTRTN(R10),R0	;GET ADDRESS OF PROMPT ROUTINE
	BSBW	DCL$USER_INPUT		;CALL USER INPUT ROUTINE
	ADDL	#8,SP			;POP THE PROMPT DESCRIPTOR
	CMPL	#RMS$_EOF,R0		;END OF FILE?
	BNEQ	70$			;NO, THEN CONTINUE
	MOVL	#1,R1			;SET SUCCESSFUL STATUS
	MOVL	#CTRLZ,R0		;RETURN CTRL/Z AS FIRST CHARACTER
	BRB	90$			;
70$:	PUSHL	R0			;SAVE RETURN STATUS
	BSBW	DCL$SETNBLK		;GET FIRST CHARACTER
	POPL	R1			;RETURN STATUS IN R1

;
; CLEAN UP AND RETURN
;
90$:	ADDL	#ENT_K_MAX_PROMPT+8,SP	;DEALLOCATE PROMPT BUFFER STORAGE
	MOVQ	(SP)+,WRK_W_PMPTLEN(R10);RESTORE PREVIOUS PROMPT ADDRESS
	RSB				;AND RETURN WITH FIRST CHARACTER IN R0


	.SBTTL	CHANGE COMMAND SYNTAX
;+
; DCL$CHANGE_SYNTAX - PROCESS A CHANGE LIST AND CHANGE THE COMMAND SYNTAX
;
; THIS ROUTINE IS CALLED TO REDEFINE THE SYTNAX OF THE COMMAND BEING PARSED
; ACCORDING TO THE DESCRIPTION IN THE CHANGE LIST.
;
; INPUTS:
;
;	R7 = QUALIFIER NUMBER
;	R8 = ADDRESS OF ENTITY DESCRIPTOR BLOCK
;	R10 = ADDRESS OF COMMAND WORK AREA
;
; OUTPUTS:
;
;	R0 = 0 IF NO NEW QUALIFIER LIST
;	     1 IF NEW QUALIFIER LIST
;
;	APPROPRIATE WRK BLOCK FIELDS ARE MODIFIED TO REFLECT THE
;	NEW COMMAND SYNTAX.
;
;		WRK_L_IMAGE -	NEW IMAGE ADDRESS
;		WRK_B_MINPARM -	MINIMUM PARAMETER COUNT
;		WRK_B_MAXPARM -	MAXIMUM PARAMETER COUNT
;		WRK_L_PROPTR -	PARAMETER LIST
;		WRK_L_QUABLK -	QUALIFIER LIST
;		WRK_G_RESULT -	TOKEN ARRAY
;
;-

DCL$CHANGE_SYNTAX:
	PUSHL	R6				;SAVE REGISTERS
	CLRL	-(SP)				;INIT PARAM/QUAL LIST STATUS
	BISW	#WRK_M_VERB,-			;SET VERB PROCESSING FLAG ONCE AGAIN
		WRK_W_FLAGS(R10) 		;
	ADDL3	ENT_L_SYNTAX(R8),-		;GET ADDRESS OF CHANGE LIST
		WRK_L_TAB_VEC(R10),R6		;
	TSTB	WRK_B_CMDOPT(R10)		;FIRST SYNTAX CHANGE SO FAR?
	BNEQ	10$				;ONLY RECORD THE FIRST CHANGE MADE
	MOVB	R7,WRK_B_CMDOPT(R10)		;SAVE QUAL # INDUCING THE FIRST CHANGE
						; FOR GETOPT CALLBACK (SET/SHOW)

;
; CHANGE IMAGE TO BE EXECUTED
; 	IF USER ROUTINE - GET ROUTINE ADDRESS.
; 	IF CLI ROUTINE OR IMAGE - GET ADDRESS OF ASCIC ROUTINE NAME OR FILE SPEC.
;
10$:	CMPB	#CMD_K_SAME,CMD_B_HANDLER(R6)	;IMAGE CHANGE REQUESTED?
	BEQL	40$				;BRANCH IF NOT
	BICW	#WRK_M_CLIRTN!WRK_M_USERRTN,-	;CLEAR PREVIOUS IMAGE STATE
		WRK_W_FLAGS2(R10)		;
	CVTWL	CMD_W_IMAGE(R6),R0		;GET BRO TO IMAGE/ROUTINE INFO
	ADDL	R6,R0				;COMPUTE REAL ADDRESS
	CMPB	#CMD_K_CLI,CMD_B_HANDLER(R6)	;ARE WE DEALING WITH A CLI ROUTINE?
	BNEQ	15$				;NO, THEN SKIP
	SETBIT	WRK_V_CLIRTN,WRK_W_FLAGS2(R10)	;SET CLI ROUTINE FLAG
15$:	CMPB	#CMD_K_USER,CMD_B_HANDLER(R6)	;ARE WE DEALING WITH A USER ROUTINE?
	BNEQ	20$				;NO, THEN SKIP
	SETBIT	WRK_V_USERRTN,WRK_W_FLAGS2(R10)	;SET USER ROUTINE FLAG
	MOVL	(R0),R0				;GET ROUTINE ADDRESS
20$:	MOVL	R0,WRK_L_IMAGE(R10)		;SAVE IMAGE/ROUTINE INFO

;
; CLEAR/SET NOSTATUS BIT.
;
40$:	CLRBIT	WRK_V_NOSTAT,WRK_W_FLAGS(R10)	;CLEAR STATUS FLAG
	BBC	#CMD_V_NOSTAT,-			;BRANCH IF STATUS SHOULD BE SET
		CMD_W_FLAGS(R6),50$		;
	SETBIT	WRK_V_NOSTAT,WRK_W_FLAGS(R10)	;SET STATUS FLAG

;
; CHANGE PARAMETER DEFINITIONS
;
50$:	BBC	#CMD_V_PARMS,-		;BRANCH IF NO PARAMETER CHANGE
		CMD_W_FLAGS(R6),60$ 	;
	EXTZV	#CMD_V_MINPARM,-	;EXTRACT MINIMUM PARAMETERS
		#CMD_S_MINPARM,-	;
		CMD_B_PARMCNT(R6),R0	;
	MOVB	R0,WRK_B_MINPARM(R10)	;
	EXTZV	#CMD_V_MAXPARM,-	;EXTRACT MAXIMUM PARAMETERS
		#CMD_S_MAXPARM,- 	;
		CMD_B_PARMCNT(R6),R0	;
	MOVB	R0,WRK_B_MAXPARM(R10)	;
	MOVL	CMD_L_PARMS(R6),R0	;GET OFFSET TO NEW PARAMETER LIST
	BEQL	55$			;IF NONE, THEN NO MORE PARAMS ALLOWED
	ADDL	WRK_L_TAB_VEC(R10),R0	;GET ADDRESS OF PARAMETER LIST
55$:	MOVL	R0,WRK_L_PROPTR(R10)	;RESET ADDRESS OF PARAMETER LIST

;
; CHANGE QUALIFIER DEFINITIONS
;
60$:	BBC	#CMD_V_QUALS,-		;BRANCH IF NO QUAL CHANGE
		CMD_W_FLAGS(R6),80$ 	;
	MOVL	CMD_L_QUALS(R6),R0	;GET OFFSET TO NEW QUALIFIER LIST
	BEQL	65$			;IF NONE, THEN NO MORE QUALS ALLOWED
	ADDL	WRK_L_TAB_VEC(R10),R0	;GET ADDRESS OF QUALIFIER LIST
65$:	MOVL	R0,WRK_L_QUABLK(R10)	;RESET ADDRESS OF QUALIFIER LIST

;
; INVALIDATE ALL QUALIFIERS IN THE TOKEN ARRAY, INCLUDING THE QUALIFIER WE
; MAY BE CURRENTLY PROCESSING, SO THAT ALL QUALIFIERS IN THE PREVIOUS SYNTAX
; ARE NO LONGER ACCESSIBLE.  THIS IS DONE TO PREVENT PREVIOUS QUALIFIERS
; FROM BEING CONFUSED WITH THE CURRENT QUALIFIER NUMBERING SCHEME.  THE
; INVALIDATION IS DONE BY ZEROING THE QUALIFIER NUMBER IN THE TOKEN ARRAY,
; ESSENTIALLY TO RECORD THAT A QUALIFIER WAS DETECTED IN THAT POSITION, BUT
; THAT IT DOESN'T REPRESENT ANY QUALIFIER IN THE CURRENT QUALIFIFER LIST.
;
	MOVAB	WRK_G_RESULT-PTR_C_LENGTH(R10),R0 ;GET ADDRESS OF TOKEN ARRAY
70$:	ADDL	#PTR_C_LENGTH,R0	;SKIP TO NEXT ENTRY
	CMPL	R0,WRK_L_RSLNXT(R10)	;REACHED LAST ENTRY STORED?
	BGEQU	75$			;BRANCH IF SO
	ASSUME	PTR_K_COMDQUAL EQ 0	;
	ASSUME	PTR_K_PARMQUAL EQ 1	;
	ASSUME	PTR_K_QUALVALU EQ 2
	CMPZV	#PTR_V_TYPE,-		;QUALIFIER?
		#PTR_S_TYPE,(R0),-	;
		#PTR_K_QUALVALU 	;
	BGTRU	70$			;SKIP IF NOT
	BBS	#PTR_V_SYNTAX,-		;SKIP IF QUALI. CHANGED SYNTAX
		(R0),72$
	MOVL	#1,(SP)			;SET BIT TO INVALIDATE THIS QUALIFIER
72$:	CLRL	PTR_L_ENTITY(R0)	;ZERO ENTITY BLOCK ADDRESS (INVALIDATE IT)
	INSV	#PTR_K_IGNORE,#PTR_V_TYPE,-	;SET IGNORE FLAG IN TYPE FIELD
		#PTR_S_TYPE,(R0) 	;
	BRB	70$			;LOOP UNTIL ALL QUALIFIERS INVALIDATED
75$:	BBCS	#0,(SP),80$		;BRANCH IF NO QUALIFIERS SEEN
	STATUS	IGNQUAL			;SET THE IGNORED QUALIFIER STATUS
	JSB	@WRK_L_SIGNALRTN(R10)	;SIGNAL THE INFORMATIONAL MESSAGE

;
; GET NEW DISALLOW EXPRESSION TREE.
;
80$:	BBC	#CMD_V_DISALLOWS,-	;BRANCH IF NO DISALLOW CHANGE
		CMD_W_FLAGS(R6),90$ 	;
	MOVL	CMD_L_DISALLOW(R6),R0	;GET OFFSET TO DISALLOW EXPRESSION TREE
	BEQL	85$			;IF EQL NONE
	ADDL	WRK_L_TAB_VEC(R10),R0	;CALCULATE ACTUAL ADDRESS
85$:	MOVL	R0,WRK_L_DISALLOW(R10)	;SAVE ADDRESS OF DISALLOW EXPRESSION TREE

;
; RESTORE REGISTERS AND RETURN
;
90$:	POPL	R0			;SET QUAL/PARAM LIST STATUS
	POPL	R6			;RESTORE REGISTERS
	RSB 				;RETURN FROM SUBROUTINE

	.SBTTL	SEARCH VERB TABLE
;---
; DCL$SEARCH_VERB - SEARCH VERB TABLE AND OBTAIN VERB INFORMATION
;
; THIS ROUTINE SEARCHES THE VERB TABLE FOR A SPECIFIED STRING.
; IF FOUND, THE VERB ATTRIBUTES ARE STORED IN THE COMMAND WORK AREA.
;
; INPUTS:
;
;	R8 = ADDRESS OF COMMAND TABLES
;	R1 = LENGTH OF VERB TOKEN
;	R2 = ADDRESS OF VERB TOKEN
;
; OUTPUTS:
;
;	R0 = STATUS CODE
;	R8 = ADDRESS OF CMD BLOCK
;	THE COMMAND WORK AREA IS INITIALIZED IF VERB FOUND
;---

DCL$SEARCH_VERB::
	PUSHR	#^M<R6,R7,R9>			;SAVE REGISTERS

;
; TRIM VERB TO FOUR CHARACTERS.
;
	MOVQ	R1,R4				;SAVE COMMAND VERB DESCRIPTOR
	CMPL	#4,R4				;COMMAND VERB LESS THAN 5 CHARACTERS?
	BGEQ	20$				;IF GEQ, USE ORIGINAL LENGTH
	MOVL	#4,R4				;SET TO SCAN ONLY 4 CHARACTERS

;
; FIND BASE AND SIZE OF VERB AND POINTER TABLES.
;
20$:	ADDL3	VEC_L_COMDPTR(R8),R8,R7		;GET BASE OF POINTER TABLE
	ADDL	#VEC_K_HEADER_LENGTH,R7		;SKIP PAST POINTER TABLE HEADER

	ADDL3	VEC_L_VERBTBL(R8),R8,R3		;GET BASE OF VERB TABLE
	CVTWL	VEC_W_SIZE(R3),R2		;GET SIZE OF TABLE + HEADER
	SUBL	#VEC_K_HEADER_LENGTH,R2		;REMOVE HEADER
	DIVL3	#4,R2,R6			;GET SIZE IN VERBS (4 BYTES PER VERB)
	ADDL	#VEC_K_HEADER_LENGTH,R3		;SKIP PAST VERB TABLE HEADER

;
; SEARCH VERB TABLE FOR SPECIFIED VERB.
;
22$:	MATCHC	R4,(R5),R2,(R3)			;SCAN FOR VERB MATCH
	BEQL	25$				;BR IF VERB MATCH
	STATUS	IVVERB				;INVALID VERB
	BRW	90$				;

;
; IF MATCH WAS NOT ON LONGWORD BOUNDARY, THEN KEEP LOOKING.
;
25$:	SUBL3	R4,R3,R0			;GET ADDRESS OF MATCHED VERB
	BICL3	#3,R0,R1			;ROUND ADDR TO LONGWORD ADDR
	CMPL	R0,R1				;IS IT SAME AS ORIGINAL?
	BEQL	27$				;YES, THEN DONE
	SUBL3	#1,R4,R0			;START SEARCH ONE CHAR AFTER
	SUBL	R0,R3				; FIRST CHAR OF MATCH	
	ADDL	R0,R2				;  
	BRB	22$				;KEEP LOOKING

;
; VERB MATCH FOUND - GET ADDRESS OF CMD BLOCK.
;
27$:	MOVL	R8,WRK_L_TAB_VEC(R10)		;SAVE ADDRESS OF TABLES VECTOR
	DIVL3	#4,R2,R9			;CALCULATE INVERSE COMMAND INDEX
	SUBW3	R9,R6,R9			;CALCULATE VERB INDEX
	SUBW	#1,R9				;ZERO BASE THE RESULT
	ADDL3	WRK_L_TAB_VEC(R10),(R7)[R9],R9	;GET ADDRESS OF COMMAND BLOCK

;
; CHECK FOR AMBIGUOUS VERBS.
;
	BBS	#CMD_V_ABBREV,-			;IF SET, NON UNIQUE ACCEPTABLE
		CMD_W_FLAGS(R9),30$ 		;
	SUBL	R4,R3				;BACKUP TO START OF VERB ENTRY FOUND
	CMPC5	R4,(R5),#0,#4,(R3)		;EXACT MATCH?
	BEQL	30$				;IF EXACT MATCH, IGNORE AMBIGUITY
	MATCHC	R4,(R5),#4,(R3)			;SCAN FOR DUPLICATE MATCH
	BNEQ	30$				;IF NEQ UNIQUE MATCH
	STATUS	ABVERB				;AMBIGUOUS COMMAND VERB
	BRW	90$				;

;
; VERB MATCH FOUND - EXTRACT ATTRIBUTES FROM COMMAND BLOCK
;
30$:	MOVB	CMD_B_VERBTYP(R9),-		;SET VERB TYPE FOR OLD INTERFACE
		WRK_B_VERBTYP(R10)		;

	CVTWL	CMD_W_NAME(R9),R0		;SAVE VERB NAME
	ADDL	R9,R0				;
	MOVAB	1(R0),WRK_L_VERB(R10)		;SKIP PAST FIRST ASCIC COUNT

	EXTZV	#CMD_V_MINPARM,-		;EXTRACT MINIMUM NUMBER OF PARAMETERS
		#CMD_S_MINPARM,-		;
		CMD_B_PARMCNT(R9),R0		;
	MOVB	R0,WRK_B_MINPARM(R10)		;
	EXTZV	#CMD_V_MAXPARM,-		;EXTRACT MAXIMUM NUMBER OF PARAMETERS
		#CMD_S_MAXPARM,-		;
		CMD_B_PARMCNT(R9),R0		;
	MOVB	R0,WRK_B_MAXPARM(R10)		;

	MOVL	CMD_L_QUALS(R9),R0		;GET OFFSET TO FIRST QUALIFIER DESC
	BEQL	40$				;IF EQL NONE
	ADDL	R8,R0				;CALCULATE ACTUAL ADDRESS
40$:	MOVL	R0,WRK_L_QUABLK(R10)		;SET ADDRESS OF QUALIFIER DESCRIPTORS

	MOVL	CMD_L_PARMS(R9),R0		;GET OFFSET TO FIRST POSITIONAL ENTITY
	BEQL	50$				;IF EQL NONE
	ADDL	R8,R0				;CALCULATE ACTUAL ADDRESS
50$:	MOVL	R0,WRK_L_PROPTR(R10)		;SAVE ADDRESS OF PARAMETER DESCRIPTORS

	MOVL	CMD_L_DISALLOW(R9),R0		;GET OFFSET TO DISALLOW EXPRESSION TREE
	BEQL	55$				;IF EQL NONE
	ADDL	R8,R0				;CALCULATE ACTUAL ADDRESS
55$:	MOVL	R0,WRK_L_DISALLOW(R10)		;SAVE ADDRESS OF DISALLOW EXPRESSION TREE

	CVTWL	CMD_W_OUTPUTS(R9),R0		;GET OFFSET TO OUTPUT LIST
	BEQL	60$				;IF EQL NONE
	ADDL	R9,R0				;CALCULATE ACTUAL ADDRESS
60$:	MOVL	R0,WRK_L_PAROUT(R10)		;SAVE ADDRESS OF OUTPUT LIST

	CLRB	WRK_B_PARMCNT(R10)		;CLEAR COUNTS OF PARAMETERS
	CLRB	WRK_B_PARMSUM(R10)		;
	CLRB	WRK_B_CMDOPT(R10)		;CLEAR ENTITY # CAUSING SYNTAX CHANGE
	CLRBIT	WRK_V_NOSTAT,WRK_W_FLAGS(R10)	;CLEAR STATUS FLAG
	BBC	#CMD_V_NOSTAT,-			;BRANCH IF STATUS SHOULD BE SET
		CMD_W_FLAGS(R9),62$		;
	SETBIT	WRK_V_NOSTAT,WRK_W_FLAGS(R10)	;SET STATUS FLAG

;
; IF USER ROUTINE - GET ROUTINE ADDRESS.
; IF CLI ROUTINE OR IMAGE - GET ADDRESS OF ASCIC ROUTINE NAME OR FILE SPEC.
;
62$:	BICW	#WRK_M_CLIRTN!WRK_M_USERRTN,-	;CLEAR PREVIOUS IMAGE STATE
		WRK_W_FLAGS2(R10)		;
	CVTWL	CMD_W_IMAGE(R9),R0		;GET BRO TO IMAGE/ROUTINE INFO
	ADDL	R9,R0				;COMPUTE REAL ADDRESS
	CMPB	#CMD_K_CLI,CMD_B_HANDLER(R9)	;ARE WE DEALING WITH A CLI ROUTINE?
	BNEQ	65$				;NO, THEN SKIP
	SETBIT	WRK_V_CLIRTN,WRK_W_FLAGS2(R10)	;SET CLI ROUTINE FLAG
65$:	CMPB	#CMD_K_USER,CMD_B_HANDLER(R9)	;ARE WE DEALING WITH A USER ROUTINE?
	BNEQ	70$				;NO, THEN SKIP
	SETBIT	WRK_V_USERRTN,WRK_W_FLAGS2(R10)	;SET USER ROUTINE FLAG
	MOVL	(R0),R0				;GET ROUTINE ADDRESS
70$:	MOVL	R0,WRK_L_IMAGE(R10)		;SAVE IMAGE/ROUTINE INFO

;
; RESTORE STATE AND RETURN SUCCESS.
;
	STATUS	NORMAL				;SET SUCCESSFUL STATUS
	MOVL	R9,R8				;RETURN CMD BLOCK ADDRESS
90$:	POPR	#^M<R6,R7,R9>			;RESTORE REGISTERS
	RSB

	.END
