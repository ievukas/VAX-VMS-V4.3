MODULE RM3CREATE (LANGUAGE (BLISS32) ,
		IDENT = 'V04-000'
		) =
BEGIN
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************

!++
!
! FACILITY:	RMS32 INDEX SEQUENTIAL FILE ORGANIZATION
!
! ABSTRACT:
!		This module performs the $CREATE function for indexed
!		sequential files.
!
! ENVIRONMENT:
!
!		VAX/VMS OPERATING SYSTEM
!
!--

!
! AUTHOR:        Maria del C. Nasr 	CREATION DATE:		21-Sep-1982
!
!
! MODIFIED BY:
!
!	V03-031	RAS0284		Ron Schaefer		30-Mar-1984
!		Fix STV value on error paths for area allocation and
!		RMS$_RPL and RMS$_WPL errors.
!
!	V03-030	SHZ0002		Stephen H. Zalewski,	27-Feb-1984
!		If you allocate a BDB, you MUST increment the available
!		local buffer count (IFB$W_AVLCL).
!
!	V03-029	SHZ0001		Stephen H. Zalewski	15-Dec-1983
!		Correct error handling when doing XAB processing.
!
!	V03-028	KPL0001		Peter Lieberwirth	18-May-1983
!		Initial pass at implementing the journaling of $CREATE.
!
!	V03-027	RAS0152		Ron Schaefer		29-Apr-1983
!		Update MCN0012 to remove the warning message.
!		Turn the XAB reference from a GLOBAL REGISTER to a
!		REGISTER parameter.
!
!	V03-026 MCN0012		Maria del C. Nasr	07-Apr-1983
!		Modify calling sequence to RM$EXTEND0 to match new linkage.
!
!	V03-025 MCN0011		Maria del C. Nasr	24-Mar-1983
!		Change linkages for the GETSPC and RETSPC routines among
!		others.  Also get rid of prologue and journaling check
!		introduced by MCN0007 since it is not useful.
!
!	V03-024 MCN0010		Maria del C. Nasr	21-Mar-1983
!		Fix some local linkages that were incorrectly defined
!		by MCN0009.
!
!	V03-023 MCN0009		Maria del C. Nasr	07-Mar-1983
!		Reorganize linkages.
!
!	V03-022 MCN0009		Maria del C. Nasr	07-Mar-1983
!		When MRS and bucket size are not specified, RMS should
!		use minimum record size to calculate bucket size of data
!		level.  Also, change maximum bucket size to 65 and use
!		symbolic name for it.
!		
!	V03-021	DAS0001		David Solomon		01-Feb-1983
!		Add support for 64-bit binary keys (IN8 and BN8); namely,
!		add a case-value in routine CHECK_KEY_PARMS to validate
!		the key size.
!
!	V03-020	MCN0008		Maria del C. Nasr	31-Jan-1983
!		Under certain error conditions RM$CREATECOM exits RMS
!		without returning status to RM$CREATE3B.  RMS then bugchecks
!		because the space allocated for the key and area tables is
!		not returned.  Fix code so that this condition is eliminated.
!		Allocate table, but copy information back to XAB so that it
!		can be returned before calling RM$CREATECOM.  Unfortunately,
!		this change requires extra passes through the XAB chain.
!
!	V03-019	MCN0007		Maria del C. Nasr	25-Jan-1983
!		Do not create the file if the prologue is 1 or 2 and
!		any of the journal flags in the IFAB are set.
!
!	V03-018	KBT0461		Keith B. Thompson	13-Jan-1983
!		Allocate a BDB and buffer for reading in the prologue
!
!	V03-017	MCN0006		Maria del C. Nasr	02-Dec-1982
!		In main module, check the device type if file created
!		with block I/O set.  If device is random access, continue
!		to write prologue; otherwise, return.  This will correct the
!		creation of a file with invalid prologue when all XABs were
!		correctly defined.  If no XABs were given, an invalid file
!		will still be created to support the COPY program.
!
!	V03-016 MCN0005		Maria del C. Nasr	01-Dec-1982
!		Routine EXTEND:  Set the TOTAL_ALLOC field in the area
!		descriptor for each area as it is extended.
!
!	V03-015 MCN0004		Maria del C. Nasr	18-Nov-1982
!		Fix more bucket size problems caused by COPY since it does
!		not define any keys, but it sets up area XABs.
!
!	V03-014	MCN0003		Maria del C. Nasr	15-Nov-1982
!		- Do not change the FAB_BKS value if there are no area XABs.
!		- If a given area is not related to a key or data bucket, and
!		the bucket size is zero, return bucket size error.
!		- If no area XABs, make sure that at least two keys fit in the
!		bucket size specified in the FAB, if any.
!		- Set the FAB and IFAB bucket size values to the largest bucket
!		size in the file, not the primary data level size.
!		- Call CHECK_MRS for the FAB only when we know that there are
!		no area XABs.
!		- Place the FWA address in R10 again, if RM$CREATCOM fails.
!
!	V03-013 MCN0002		Maria del C. Nasr	11-Nov-1982
!		Delay the optimization of the bucket size for the data bucket
!		(forcing it to be at least 2), after we have determined if the
!		user gave a bucket size in an allocation XAB.  In that way, we
!		will not return a BKZ error if he specified a value of 1.
!
!	V03-012	MCN0001		Maria del C. Nasr	11-Nov-1982
!		If there are no key XABs and the file is being created with
!		block I/O set, do not return error.  This is done so that
!		COPYing of indexed files works, since no key XABs are defined
!		for the output file.
!
!
!*****

LIBRARY 'RMSLIB:RMS';

REQUIRE 'RMSSRC:RMSIDXDEF';

! define default psects for code
!
PSECT
    CODE = RM$RMSMISC(PSECT_ATTR),
    PLIT = RM$RMSMISC(PSECT_ATTR);

! External Linkages
!
LINKAGE
    L_ALDBUF,
    L_CACHE,
    L_EXTEND0,
    L_FABREG,
    L_GETSPC,
    L_LINK_7_10_11,
    L_CHKSUM,
    L_RELEASE_FAB,
    L_RETSPC;

! Local linkage definitions
!
LINKAGE
    RL$AL_KEY 		= JSB () : GLOBAL (COMMON_FABREG),
    RL$CHECK_DENSE	= JSB (),
    RL$CHECK_INPUT	= JSB (;REGISTER = 7) :
			GLOBAL (COMMON_FABREG, XAB = 6),
    RL$CHECK_KEY_PARMS	= JSB (REGISTER = 1, REGISTER = 2, REGISTER = 3) :
			GLOBAL (XAB = 6, R_IFAB)
			NOTUSED (9, 11),
    RL$CHECK_OVERLAP	= JSB (REGISTER = 3) : GLOBAL (XAB = 6),
    RL$CHECK_PROLOG	= JSB (REGISTER = 0, REGISTER = 3; REGISTER = 7) :
			GLOBAL (XAB = 6, R_FAB, R_IFAB),
    RL$CHK_AND_REPROBE	= JSB () : GLOBAL (R_FAB, R_IFAB, XAB = 6),
    RL$CLEAR 		= JSB (),
    RL$EXTEND 		= JSB (REGISTER = 7, REGISTER=6) :
			GLOBAL (COMMON_FABREG)	NOPRESERVE (2),
    RL$FIND_PROLOGUE	= JSB (REGISTER = 3; REGISTER = 7) :
			GLOBAL (XAB = 6, R_FAB, R_IFAB),
    RL$GET_BKS		= JSB (;REGISTER = 1) :
			GLOBAL (R_FAB, R_IFAB, XAB = 6),
    RL$GET_KEY_PARMS	= JSB (;REGISTER = 1, REGISTER = 2, REGISTER = 3) :
			GLOBAL (XAB = 6)
			NOTUSED (9, 10, 11),
    RL$RW_PROLOG 	= JSB () : GLOBAL (COMMON_FABREG, R_BDB),
    RL$WRITE_KEY_DESC	= JSB () : GLOBAL (R_IFAB, R_FAB, XAB = 6, BUF = 7);

! Forward Routines
!

FORWARD ROUTINE
    RM$CREATE3B 	: RL$FABREG,
    AL_KEY_DESC		: RL$AL_KEY,
    CHECK_AREAS		: RL$CHK_AND_REPROBE,
    CHECK_DENSE 	: RL$CHECK_DENSE,
    CHECK_INPUT 	: RL$CHECK_INPUT,
    CHECK_KEY_PARMS 	: RL$CHECK_KEY_PARMS,
    CHECK_MRS		: RL$CHK_AND_REPROBE,
    CHECK_OVERLAP	: RL$CHECK_OVERLAP,
    CHECK_PROLOG	: RL$CHECK_PROLOG,
    CLEAR		: RL$CLEAR NOVALUE,
    EXTEND 		: RL$EXTEND,
    FIND_PROLOGUE	: RL$FIND_PROLOGUE,
    GET_BKS		: RL$GET_BKS,
    GET_KEY_PARMS 	: RL$GET_KEY_PARMS NOVALUE,
    MOVE		: RL$WRITE_KEY_DESC,
    READ_PROLOGUE	: RL$RW_PROLOG,
    REPROBE		: RL$CHK_AND_REPROBE,
    WRITE_KEY_DESC	: RL$WRITE_KEY_DESC,
    WRITE_PROLOGUE	: RL$RW_PROLOG;

! External Routines
!
EXTERNAL ROUTINE
    RM$AL_KEY_DESC	: RL$LINK_7_10_11 ADDRESSING_MODE(GENERAL),
    RM$ALBLB		: RL$LINK_7_10_11 ADDRESSING_MODE(GENERAL),
    RM$ALDBUF		: RL$ALDBUF	ADDRESSING_MODE( GENERAL ),
    RM$CACHE		: RL$CACHE ADDRESSING_MODE(GENERAL),
    RM$CREATECOM	: RL$FABREG ADDRESSING_MODE(GENERAL),
    RM$EXTEND0		: RL$EXTEND0 ADDRESSING_MODE(GENERAL),
    RM$GETSPC		: RL$GETSPC ADDRESSING_MODE(GENERAL),
    RM$MAKSUM		: RL$CHKSUM ADDRESSING_MODE(GENERAL),
    RM$RELEASE		: RL$RELEASE_FAB ADDRESSING_MODE(GENERAL),
    RM$RETSPC		: RL$RETSPC ADDRESSING_MODE(GENERAL) NOVALUE,
    RM$RND_DEV		: RL$LINK_7_10_11 ADDRESSING_MODE(GENERAL);

EXTERNAL
    PIO$GB_RMSPROLOG: ADDRESSING_MODE (GENERAL), 	! These symbols are defined in the SHELL
    SYS$GB_RMSPROLOG: ADDRESSING_MODE (GENERAL); 	! These symbols are defined in SYSPARAM


%SBTTL	'RM$CREATE3B'
GLOBAL ROUTINE RM$CREATE3B : RL$FABREG =

!++
!
! RM$CREATE3B
!
!	This routine checks the input (XABs), creates the file,
!	fills in key descriptor, allocates index descriptor, and writes
!	the prologue.
!
! CALLING SEQUENCE:
!
!	RM$CREATE3B()
!
! INPUT PARAMETERS:
!
!	FAB 	- address of user's file access block
!	IFAB_FILE - address of internal RMS file access block
!
! IMPLICIT INPUTS:
!	None
!
! IMPLICIT OUTPUTS:
!	None
!
! ROUTINE VALUE:
!
!	RFM,BKS,IMX,REF,FLG,DTP,SIZ,POS,NPK,XAB,IAN,LAN,DAN,IFL,DFL,
!	BKZ,PLV,MRS,SEG,KNM,AID,IBK,KSI,and SUC
!
! SIDE EFFECTS:
!	File is created
!
!--

    BEGIN

    ! These macros are defined to make code more readable.  They are
    ! executed when an error occurs, and buffers must be released.
    !
    MACRO
	RETURN_VBN1 =
	    BEGIN
	    IF .BDB_VBN1 EQL 0
	      THEN BDB = .BLB_VBN1
	      ELSE BDB = .BDB_VBN1;
	    RM$RELEASE (0);
	    END; %,

	RETURN_ALL_BUFS =
	    BEGIN
	    IF .BDB EQL .BDB_VBN1
	    THEN
	        RM$RELEASE (0)
	    ELSE
		BEGIN
	    	RM$RELEASE (0);
		RETURN_VBN1;
		END;
	    END; %;

    LOCAL
	CRE_STATUS;

    EXTERNAL REGISTER
	COMMON_FAB_STR;

    GLOBAL REGISTER
	BUF = 7	: REF BBLOCK,
	XAB = 6	: REF BBLOCK;

    ! Set up IFAB in R10, but have to save the FWA address for RM$CREATECOM
    !
    BEGIN

    LOCAL
	SPACE_ADDR,
	FWA;

    LITERAL
	TABLE_SIZE = 64;

    FWA = .IFAB;
    IFAB = .IFAB_FILE;

    ! Get space for key and area bit masks
    !

    RETURN_ON_ERROR ( RM$GETSPC (.IFAB, TABLE_SIZE; SPACE_ADDR) );

    ! Call CHECK_INPUT to verify that the XABs are correct.
    !
    BEGIN

    LOCAL
	PROLOGUE,
	STATUS;

    STATUS = CHECK_INPUT ( .SPACE_ADDR; PROLOGUE );

    ! Before checking STATUS, return space used for bits masks
    !

    RM$RETSPC ( TABLE_SIZE, .IFAB, .SPACE_ADDR );

    ! If CHECK_INPUT failed, return error.  Otherwise, save
    ! prologue version, and continue processing.
    !

    IF NOT .STATUS
    THEN
	RETURN .STATUS;

    IFAB [IFB$B_PLG_VER] = .PROLOGUE;

    END;			! end of STATUS and PROLOGUE definition

    ! Get space for key and area tables
    !

    BEGIN

    LOCAL
	SIZE,
	STATUS;

    SIZE = ( 8 * .IFAB [IFB$B_NUM_KEYS] ) + .IFAB [IFB$B_AMAX];

    IF .SIZE LSS 12
    THEN
	SIZE = 12;
    RETURN_ON_ERROR ( RM$GETSPC (.IFAB, .SIZE; SPACE_ADDR) );

    ! Call routine to check area information against key XABs, and
    ! return space used by tables.
    !

    STATUS = CHECK_AREAS ( .SPACE_ADDR );

    RM$RETSPC ( .SIZE, .IFAB, .SPACE_ADDR );

    ! If CHECK_AREAS failed, return error.
    !

    IF NOT .STATUS
    THEN
	RETURN .STATUS;
    END;				! end of SIZE, STATUS def

    ! Actually create the file on the disk
    !
    IFAB = .FWA;			! restore FWA adddress for call
    CRE_STATUS = RM$CREATECOM();

    IF  NOT .CRE_STATUS
      OR ( .FAB [FAB$V_CIF]
	AND  .CRE_STATUS EQL RMSSUC() )
    THEN
	RETURN .CRE_STATUS;

    END;				! end of FWA and SPACE_ADDR definition

    ! From now on, we need the IFAB address in R10
    !
    IFAB = .IFAB_FILE;

    ! If block I/O, and device not random, then just return.  Otherwise,
    ! continue to write prologue.
    !

    BEGIN

    GLOBAL REGISTER
	R_IDX_DFN;

    IF .FAB [FAB$V_BIO]
      AND NOT RM$RND_DEV ()
    THEN
	RETURN .CRE_STATUS;

    END;

    BEGIN

    GLOBAL REGISTER
	R_BDB_STR;

    BEGIN

    ! Allocate a BDB and a 1 block buffer for reading in the prologue
    ! More if either AI or BI journaling, see discussion in RM3CONN.
    !
    LOCAL
	BKS,				! max bucket size
	BUFSIZ,				! size of buffer to allocate
	JBDB:	REF BLOCK[,BYTE],	! pointer to jnlbdb
	DBDB:	REF BLOCK[,BYTE];	! pointer to data bdb

    BUFSIZ = BKS = 512;

    IF .IFAB[IFB$V_AI]
    THEN
	BUFSIZ = .BUFSIZ + RJR$C_BKTLEN + BDB$C_BLN;

    IF .IFAB[IFB$V_BI]
    THEN
	BUFSIZ = .BUFSIZ + .BKS + RJR$C_BKTLEN + BDB$C_BLN;

    RETURN_ON_ERROR( RM$ALDBUF( .BUFSIZ ) );	! Allocate a BDB.
    IFAB[IFB$W_AVLCL] = .IFAB[IFB$W_AVLCL] + 1;	! Increment the local buffer count.

    ! The new BDB is allocated onto the end of the BDB chain.  Now fill in the
    ! BDB to describe the journaling fields and buffers.
    !
    DBDB = .IFAB[IFB$L_BDB_BLNK];

    DBDB[BDB$W_SIZE] = .BKS;

    IF .IFAB[IFB$V_AI]
    THEN
	BEGIN
	JBDB = .DBDB[BDB$L_ADDR];
	DBDB[BDB$L_AI_BDB] = .JBDB;

	JBDB[BDB$B_BID] = BDB$C_BID;
	JBDB[BDB$B_BLN] = BDB$C_BLN/4;
	JBDB[BDB$L_FLINK] = .JBDB;
	JBDB[BDB$L_BLINK] = .JBDB;
	JBDB[BDB$W_SIZE] = .BKS + RJR$C_BKTLEN;
	JBDB[BDB$L_ADDR] = .JBDB + BDB$C_BLN;
	DBDB[BDB$L_ADDR] = .JBDB + BDB$C_BLN + RJR$C_BKTLEN;
	END;

    IF .IFAB[IFB$V_BI]
    THEN
	BEGIN
	JBDB = .DBDB[BDB$L_ADDR] + .BKS;
	DBDB[BDB$L_BI_BDB] = .JBDB;

	JBDB[BDB$B_BID] = BDB$C_BID;
	JBDB[BDB$B_BLN] = BDB$C_BLN/4;
	JBDB[BDB$L_FLINK] = .JBDB;
	JBDB[BDB$L_BLINK] = .JBDB;
	JBDB[BDB$W_SIZE] = .BKS + RJR$C_BKTLEN;
	JBDB[BDB$L_ADDR] = .JBDB + BDB$C_BLN;
	END;

    END;

    ! One BLB is allocated as part of a shared open if necessary.  If
    ! locking is required, a lock BLB must be allocated now.
    !
    IF NOT .IFAB [IFB$V_NORECLK]
    THEN
	BEGIN

	GLOBAL REGISTER
	    R_IDX_DFN;

        RETURN_ON_ERROR( RM$ALBLB() );
	END;

    ! Define and initialize some local variables.
    !
    BEGIN

    LOCAL
	VBN,				! VBN number
	DISP,				! offset into VBN
	LAST_KEY_VBN,			! will be used to calculate where
					! first area descriptor goes in plg
	COMPR : BYTE,			! compression flag
	ALLOC : BYTE,			! alloc XAB found flag
	XAB_TYP : BYTE,			! XAB type
	BDB_VBN1,			! stores BDB address of VBN 1
	BLB_VBN1,			! stores BLB address of VBN 1
	AREA0_SIZE;			! total size allocated to area 0

    COMPR = 0;
    ALLOC = 0;
    BDB_VBN1 = 0;
    BLB_VBN1 = 0;
    LAST_KEY_VBN = ( .IFAB [IFB$B_NUM_KEYS] + 3 ) / 5 + 1;
    AREA0_SIZE = .IFAB [IFB$L_HBK];

    ! If we are sharing this file, then get a lock on VBN 1 to keep everyone
    ! else out while we write the prologue.  It will remain locked for the
    ! rest of the file creation.  The BLB address is saved in BLB_VBN1 so we
    ! can return the lock if errors occur later.

    IF NOT .IFAB [IFB$V_NORECLK]
    THEN
 	BEGIN

    	GLOBAL REGISTER
	    R_BKT_ADDR_STR;

    	RETURN_ON_ERROR (RM$CACHE(1,512,CSH$M_NOREAD OR CSH$M_LOCK OR CSH$M_NOBUFFER),
			 STATUS = RMSERR (ENQ) );
    	BLB_VBN1 = .BDB;			! BLB returned instead of BDB.
	END;

    ! Get start of XAB chain, and start scanning
    !
    XAB = .FAB [FAB$L_XAB];

    WHILE 1
    DO

	BEGIN

	! If no more XABs, check if we found an allocation XAB.  If we did,
	! exit loop.  Else, set the XAB type to ALL, so that we force at least
	! one alloc XAB definition.
	!

	IF .XAB EQL 0
	THEN
	    BEGIN

	    IF .ALLOC
	    THEN
		EXITLOOP
	    ELSE
		XAB_TYP = XAB$C_ALL;
	    END
	ELSE

	    ! If this is a valid XAB, reprobe it and save the type.
	    !
	    BEGIN
	    RETURN_ON_ERROR ( REPROBE () );
	    XAB_TYP = .XAB [XAB$B_COD];
	    END;

	CASE .XAB_TYP FROM XAB$C_DAT TO XAB$C_TRM OF
	    SET
 
	    [XAB$C_KEY] :

		BEGIN

		! Calculate the VBN and offset where this key descriptor
		! will go in the prologue based on the key of reference.
		!

		IF .XAB [XAB$B_REF] EQL 0
		THEN
		    BEGIN
		    VBN = 1;
		    DISP = 0;
		    END
		ELSE
		    BEGIN
		    VBN = ( .XAB [XAB$B_REF] + 4 ) / 5 + 1;
		    DISP = ( ( .XAB [XAB$B_REF] - 1 ) MOD 5 )
					* ( KEY$C_BLN + KEY$C_SPARE );
		    END;

		RETURN_ON_ERROR ( READ_PROLOGUE (.VBN),
				RETURN_VBN1 );

		! If VBN 1 is read, save its BDB address in BDB_VBN1 so that
		! if we fail reading or writing the prologue, this locked VBN
		! can be released.
		!
		IF .VBN EQL 1
		THEN
		    BDB_VBN1 = .BDB;

		! Set the starting address of the key descriptor and call the
		! routine which fills in the fields.  If in error, must release
		! all buffers that have been locked.
		!
		BUF = .BDB [BDB$L_ADDR] + .DISP;

		RETURN_ON_ERROR ( WRITE_KEY_DESC (),
				  RETURN_ALL_BUFS );

		! Allocate in_core index descriptor
		!
		RETURN_ON_ERROR ( AL_KEY_DESC ( .BUF, .VBN, .DISP ),
				RETURN_ALL_BUFS );

		! Write the VBN we just filled.  If sharing and we are writing
		! VBN 1 then clear bdb as it will be released when we write 
		! the buffer.  Clearing bdb before the write is okay, because
		! if an error occurs, all we can do is release the lock.
		!
    		IF NOT .IFAB [IFB$V_NORECLK]
       		   AND .BDB [BDB$L_VBN] EQL 1
    		THEN
  		    BDB_VBN1 = 0;

		RETURN_ON_ERROR ( WRITE_PROLOGUE (),
				RETURN_VBN1 );

		! If the key or index is to be compressed, then set the
		! compression flag for future reference.
		!

		IF NOT .XAB [XAB$V_IDX_NCMPR] OR NOT .XAB [XAB$V_KEY_NCMPR]
		THEN
		    COMPR = 1;
		END;

	    [XAB$C_ALL]:

		BEGIN

		! The area descriptors go in the prologue depending on the
		! position of the last key descriptor and the area id number.
		!

		IF .XAB EQL 0
		THEN
		    BEGIN
		    VBN = .LAST_KEY_VBN + 1;
		    DISP = 0;
		    END
		ELSE
		    BEGIN
		    VBN = ( .XAB [XAB$B_AID] + 8 ) / 8 + .LAST_KEY_VBN;
		    DISP = ( .XAB [XAB$B_AID] MOD 8 ) * AREA$C_BLN;
		    END;

		RETURN_ON_ERROR ( READ_PROLOGUE (.VBN),
				RETURN_VBN1 );

		! If VBN 1 is read, save its BDB address in BDB_VBN1 so that
		! if we fail reading or writing the prologue, this locked VBN
		! can be released.
		!
		IF .VBN EQL 1
		THEN
		    BDB_VBN1 = .BDB;

		! Set the starting address of the area descriptor,
		! and clear the buffer.
		!
		BUF = .BDB [BDB$L_ADDR] + .DISP;
		CLEAR (.BUF, AREA$C_BLN);

		! If no allocation XAB, then default values
		!

		IF .XAB EQL 0
		THEN
		    BEGIN
		    BUF [AREA$L_CVBN] = 1;
		    BUF [AREA$B_ARBKTSZ] = .IFAB [IFB$B_BKS];
		    BUF [AREA$L_NXTVBN] = .VBN + 1;
		    BUF [AREA$L_CNBLK] = .AREA0_SIZE;
		    BUF [AREA$L_USED] = .VBN;
		    BUF [AREA$W_DEQ] = .IFAB [IFB$W_DEQ];
		    BUF [AREA$L_TOTAL_ALLOC] = .AREA0_SIZE;
		    IFAB [IFB$B_AVBN] = .VBN;
		    END
		ELSE
		    BEGIN
		    BUF [AREA$B_AREAID]	= .XAB [XAB$B_AID];
		    BUF [AREA$W_DEQ] = .XAB [XAB$W_DEQ];
		    BUF [AREA$B_ARBKTSZ] = .XAB [XAB$B_BKZ];
		    BUF [AREA$V_CBT] = .XAB [XAB$V_CBT];
		    BUF [AREA$V_CTG] = .XAB [XAB$V_CTG];
		    BUF [AREA$V_ONC] = .XAB [XAB$V_ONC];
		    BUF [AREA$B_ALN] = .XAB [XAB$B_ALN];

		    ! The alignment data are stored in the area descriptor
		    ! depending on the alignment option the user specified.
		    !
		    CASE .XAB [XAB$B_ALN] FROM XAB$C_ANY TO XAB$C_RFI OF
			SET

			[XAB$C_ANY] : 0;

			[XAB$C_CYL, XAB$C_LBN]:
			    BEGIN
			    BUF [AREA$W_VOLUME] = .XAB [XAB$W_VOL];
			    BUF [AREA$L_LOC] = .XAB [XAB$L_LOC];
			    BUF [AREA$V_HARD] = .XAB [XAB$V_HRD];
			    END;

			[XAB$C_VBN]:
			    BUF [AREA$L_LOC] = .XAB [XAB$L_LOC];

			[XAB$C_RFI]:
			    BEGIN

			    LOCAL
				RFI : REF VECTOR [,WORD];

			    RFI = BUF [AREA$W_RFI];
			    RFI [0] = .XAB [XAB$W_RFI0];
			    RFI [1] = .XAB [XAB$W_RFI2];
			    RFI [2] = .XAB [XAB$W_RFI4];
			    BUF [AREA$L_LOC] = .XAB [XAB$L_LOC];
			    END;

			[OUTRANGE] :
			    BEGIN
			    FAB [FAB$L_STV] = .XAB [XAB$B_AID];
			    RETURN_ON_ERROR ( RMSERR (ALN),
						RETURN_ALL_BUFS );
			    END;
			TES;

		    IF .XAB [XAB$B_AID] NEQ 0
		    THEN
			BEGIN

			IF .XAB [XAB$L_ALQ] NEQ 0
			THEN

			    RETURN_ON_ERROR ( EXTEND ( .BUF, .XAB),
						RETURN_ALL_BUFS );
			END

		    ELSE

			! Area number 0
			!
			BEGIN
			BUF [AREA$L_USED] = .IFAB [IFB$B_AVBN];
			BUF [AREA$L_NXTVBN] = .IFAB [IFB$B_AVBN] + 1;
			IFAB [IFB$B_AVBN] = .VBN;
			BUF [AREA$L_CVBN] = 1;
			BUF [AREA$L_CNBLK] = .AREA0_SIZE;
			BUF [AREA$L_TOTAL_ALLOC] = .AREA0_SIZE;
			END;
		    END;

		! Write the VBN we just filled.  If sharing and we are writing
		! VBN 1 then clear bdb as it will be released when we write 
		! the buffer.  Clearing bdb before the write is okay, because
		! if an error occurs, all we can do is release the lock.
		!
    		IF NOT .IFAB [IFB$V_NORECLK]
       		   AND .BDB [BDB$L_VBN] EQL 1
    		THEN
  		    BDB_VBN1 = 0;

		RETURN_ON_ERROR ( WRITE_PROLOGUE (),
				RETURN_VBN1 );

		ALLOC = 1;		! an area descriptor was found
		END;

	    [INRANGE] : 0;
	    [OUTRANGE] : 0;

	    TES;

	IF .XAB NEQ 0
	THEN
	    XAB = .XAB [XAB$L_NXT];		! get next XAB
	END;					! end of WHILE loop

         
    ! If the index of any of the keys, or the key itself is compressed,
    ! then add two bytes for compression overhead to the key buffer.
    !

    IF .COMPR
    THEN
	IFAB [IFB$W_KBUFSZ] = .IFAB [IFB$W_KBUFSZ] + 2;

    END;				!  end of def of VBN, DISP and others

    ! Reread VBN 1 and fill in summary area information and prologue
    ! version number
    !
    BEGIN

    GLOBAL REGISTER
	R_BKT_ADDR_STR;

    RETURN_ON_ERROR ( RM$CACHE ( 1, 512, CSH$M_LOCK ),
			BEGIN
			IF .FAB [FAB$L_STV] EQL 0
			THEN
			    FAB [FAB$L_STV] = .STATUS OR 1^16;
			STATUS = RMSERR (RPL)
			END );

    BKT_ADDR [PLG$B_AVBN] = .IFAB [IFB$B_AVBN];
    BKT_ADDR [PLG$B_AMAX] = .IFAB [IFB$B_AMAX];
    BKT_ADDR [PLG$W_VER_NO] = .IFAB [IFB$B_PLG_VER];
    RM$MAKSUM ( .BKT_ADDR );
    END;

    BDB [BDB$V_VAL] = 1;
    BDB [BDB$V_DRT] = 1;

    RETURN_ON_ERROR ( RM$RELEASE ( RLS$M_WRT_THRU ),
			BEGIN
			IF .FAB [FAB$L_STV] EQL 0
			THEN
			    FAB [FAB$L_STV] = .STATUS OR 1^16;
			STATUS = RMSERR (WPL)
			END);

    END;			! end of BDB register declaration

    RETURN .CRE_STATUS;

    END;


%SBTTL	'AL_KEY_DESC'
ROUTINE AL_KEY_DESC ( BUF,VBN,OFFSET ) : RL$AL_KEY =

!++
!
! AL_KEY_DESC
!	This routine allocates a key descriptor.  This is in a separate module
!	so as not to clobber R7.
!
!
! CALLING SEQUENCE:
!	AL_KEY_DESC (BUF, VBN, OFFSET)
!
! INPUT PARAMETERS:
!	BUF - address of buffer where data are stored
!	VBN - virtual block number corresponding to buffer
!	OFFSET - displacement into buffer
!
! IMPLICIT INPUTS:
!	None
!
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	Error code or success
!
! SIDE EFFECTS:
!	none
!
!--

    BEGIN

    EXTERNAL REGISTER
	COMMON_FABREG;

    GLOBAL REGISTER
	R_IDX_DFN;

    RETURN_ON_ERROR ( RM$AL_KEY_DESC ( .BUF, .VBN, .OFFSET ) );

    RETURN RMSSUC();

    END;

%SBTTL	'CHECK_AREAS'
ROUTINE CHECK_AREAS ( TABLES ) : RL$CHK_AND_REPROBE =

!++
!
! CHECK_AREAS
!
!	This routine loops thru the XAB chain again to validate key
!	information against area allocation information, and also obtain
!	a valid bucket size value for each of the index levels.  It stores
!	all the needed information in a table in memory for future reference
!	to avoid future	passes thru the XAB chain.
!
! CALLING SEQUENCE:
!	CHECK_AREAS (TABLES)
!
! INPUT PARAMETERS:
!	TABLES - Address for tables in memory
!
! IMPLICIT INPUTS:
!	FAB, IFAB, XAB
!
! OUTPUT PARAMETERS:
!	None
!
! IMPLICIT OUTPUTS:
!	None
!
! ROUTINE VALUE:
!	Success or error code.
!
! SIDE EFFECTS:
!	None
!---

    BEGIN

    EXTERNAL REGISTER
	R_FAB_STR,
	R_IFAB_STR,
	XAB = 6 : REF BBLOCK;

    LITERAL
	VBN_SIZE = 4;

    ! Fields for the key table
    !
    FIELD
	KEY_TBL_FLD =
	    SET
	    KSZ = [0,0,8,0],			! key size
	    DAN = [1,0,8,0],			! data area number
	    IAN = [2,0,8,0],			! index area number
	    LAN = [3,0,8,0],			! lowest level index area number
	    IFL = [4,0,16,0],			! index bucket fill size
	    DFL = [6,0,16,0]			! data bucket fill size
	    TES;
	
    ! Define the tables and others.
    !
    LOCAL
	BIG_BKS,				! stores biggest bucket size
	AREA_FOUND,				! indicates if areas were defined
	MAX_MINREC,
	KEY_TBL  : REF BLOCKVECTOR [1,8,BYTE] FIELD(KEY_TBL_FLD),
	AREA_BKS : REF VECTOR [1,BYTE];		! the only field in the area
						!  table is the bucket size

    ! Get the address for each table
    !
    KEY_TBL = .TABLES;
    AREA_BKS = .TABLES + ( 8 * .IFAB [IFB$B_NUM_KEYS] );
    BIG_BKS = 0;
    AREA_FOUND = 0;
    MAX_MINREC = 0;

    XAB = .FAB [FAB$L_XAB];

    WHILE .XAB NEQ 0
    DO

	BEGIN
	RETURN_ON_ERROR ( REPROBE () );

	! First verify that the area numbers in the key XABs point to a valid
	! allocation XAB.  Then fill the table with the information that must
	! be verified later.
	!
	CASE .XAB [XAB$B_COD] FROM XAB$C_DAT TO XAB$C_TRM OF
	    SET

	    [XAB$C_KEY]:

		BEGIN
		FAB [FAB$L_STV] = .XAB [XAB$B_REF];

		IF .XAB [XAB$B_IAN] GEQU .IFAB [IFB$B_AMAX]
		THEN
		    RETURN RMSERR (IAN);

		IF .XAB [XAB$B_LAN] GEQU .IFAB [IFB$B_AMAX]
		THEN
		    RETURN RMSERR (LAN);

		IF .XAB [XAB$B_DAN] GEQU .IFAB [IFB$B_AMAX]
		THEN
		    RETURN RMSERR (DAN);

		! If LAN is defined as area 0, set it equal to IAN.
		!

		IF .XAB [XAB$B_LAN] EQL 0
		THEN
		    XAB [XAB$B_LAN] = .XAB [XAB$B_IAN];

		BEGIN

		LOCAL
		    KEYSIZE,
		    MINREC,
		    SEGS;

		! Get key size, and minimum record size.  Store key size
		! in table, and save biggest minrec so far.
		!

		GET_KEY_PARMS (;KEYSIZE, MINREC, SEGS);
		KEY_TBL [.XAB [XAB$B_REF], KSZ] = .KEYSIZE;

		IF .MAX_MINREC LSS .MINREC
		THEN
		    MAX_MINREC = .MINREC;
		END;

		! Store area numbers and fill values
		!
		KEY_TBL [.XAB [XAB$B_REF], IAN] = .XAB [XAB$B_IAN];
		KEY_TBL [.XAB [XAB$B_REF], LAN] = .XAB [XAB$B_LAN];
		KEY_TBL [.XAB [XAB$B_REF], DAN] = .XAB [XAB$B_DAN];
		KEY_TBL [.XAB [XAB$B_REF], IFL] = .XAB [XAB$W_IFL];
		KEY_TBL [.XAB [XAB$B_REF], DFL] = .XAB [XAB$W_DFL];
		END;

	    [XAB$C_ALL]:

		! For the allocation XAB, just save the bucket size
		! specified for the given area.
		!
		BEGIN
		AREA_FOUND = 1;
		AREA_BKS [.XAB [XAB$B_AID]] = .XAB [XAB$B_BKZ];

		IF .XAB [XAB$B_BKZ] GTR .BIG_BKS
		THEN
		    BIG_BKS = .XAB [XAB$B_BKZ];
		END;

	    [OUTRANGE] : 0;
	    [INRANGE]  : 0;

	    TES;

	XAB = .XAB [XAB$L_NXT];

	END;				! end of WHILE loop

    ! Now that all required data have been stored in the tables,
    ! find the best bucket size for each area based on the key sizes,
    ! if the user did not give a value.  If he specified a size, then
    ! make sure that it is big enough to hold the keys and data record
    ! which correspond to the given area number.
    !
    BEGIN

    LOCAL
	LAST_BKS,			! last bucket size found
	MIN_BKS;			! minimum bucket size

    ! Get the bucket size for a given area number.
    !
    INCR AREANO FROM 0 TO ( .IFAB [IFB$B_AMAX] - 1 )
    DO
	BEGIN

	LAST_BKS = 0;

	! Loop thru all keys
	!
	INCR KEYNO FROM 0 TO ( .IFAB [IFB$B_NUM_KEYS] - 1 )
	DO
	    BEGIN

	    ! If the area number is equal to the index or lowest area
	    ! number for the given key, calculate the minimum bucket size.
	    ! It is equal to the bucket overhead plus two keys and their
	    ! overhead, depending on the prologue version.
	    !
	    
	    IF .AREANO EQL .KEY_TBL [.KEYNO, IAN]
	      OR .AREANO EQL .KEY_TBL [.KEYNO, LAN]
	    THEN
		BEGIN

		IF .IFAB [IFB$B_PLG_VER] LSS PLG$C_VER_3
		THEN
		    MIN_BKS = 2 * ( .KEY_TBL [.KEYNO, KSZ] + VBN_SIZE
			+ IRC$C_IDXOVHDSZ ) + BKT$C_OVERHDSZ
		ELSE
		    MIN_BKS = 2 * ( .KEY_TBL [.KEYNO, KSZ] + VBN_SIZE
			+ IRC$C_KEYCMPOVH ) + BKT$C_OVERHDSZ + BKT$C_ENDOVHD;

		! The bucket size should be in number of blocks, not bytes.
		!
		MIN_BKS = ( .MIN_BKS / 512 ) + 1;

		! If the user gave a bucket size value for the given area,
		! make sure it is big enough to hold two keys.  If no area XAB
		! found, use the FAB value if not zero.
		!

		IF ( .AREA_BKS [.AREANO] NEQ 0
		  AND .MIN_BKS GTR .AREA_BKS [.AREANO] )
		    OR ( NOT .AREA_FOUND
		      AND .FAB [FAB$B_BKS] NEQ 0
			AND .MIN_BKS GTR .FAB [FAB$B_BKS] )
		THEN
		    BEGIN
		    FAB [FAB$L_STV] = .KEYNO;
		    RETURN RMSERR (KSI);
		    END;

		! Then get the largest bucket size found so far.
		!

		IF .LAST_BKS LSS .MIN_BKS
		THEN
		    LAST_BKS = .MIN_BKS;
		END;

	    ! If the area number is equal to the one specified for the
	    ! data level, find the minimum bucket size depending on the key
	    ! of reference.
	    !

	    IF .AREANO EQL .KEY_TBL [.KEYNO, DAN]
	    THEN
		BEGIN

		! For the SIDR level, just make it equal to the key size since
		! we know that at least one key will always fit in the bucket.
		!

		IF .KEYNO NEQ 0
		THEN
		    MIN_BKS = ( .KEY_TBL [.KEYNO, KSZ] / 512 ) + 1

		! For the primary key, it depends on the bucket size value
		! specified in the allocation XAB.
		!

		ELSE
		    BEGIN

		    ! If an area XAB was given, use the allocation XAB bucket
		    ! size, else use the FAB value.
		    ! Call CHECK_MRS to make sure the record fits in the bucket.
		    !

		    IF .AREA_FOUND
		    THEN
			IFAB [IFB$B_BKS] = .AREA_BKS [.AREANO]
		    ELSE
			IFAB [IFB$B_BKS ] = .FAB [FAB$B_BKS];

		    IF .IFAB [IFB$W_MRS] NEQU 0
		    THEN
			RETURN_ON_ERROR ( CHECK_MRS (.IFAB [IFB$B_PLG_VER], .IFAB [IFB$W_MRS]) )
		    ELSE
			RETURN_ON_ERROR ( CHECK_MRS (.IFAB [IFB$B_PLG_VER], .MAX_MINREC) );

		    ! The best value is in the IFAB now.
		    !
		    MIN_BKS = .IFAB [IFB$B_BKS];
		    END;				! primary key case

		! Get largest one so far
		!

		IF .LAST_BKS LSS .MIN_BKS
		THEN
		    LAST_BKS = .MIN_BKS;
		END;
	    END;			! end of INCR KEYNO loop

	! Now that we searched all keys for one area number, store the bucket
	! size calculated if the user did not give one.
	!

	IF .AREA_BKS [.AREANO] EQL 0
	THEN
	    AREA_BKS [.AREANO] = .LAST_BKS
	ELSE

	    ! If he gave one, make sure it is big enough.
	    !

	    IF .LAST_BKS GTR .AREA_BKS [.AREANO]
	    THEN
		BEGIN
		FAB [FAB$L_STV] = .AREANO;
		RETURN RMSERR (BKZ);
		END;

	! If no reference was made to this area, and the bucket size
	! given is zero, return "bucket size" error.
	!

	IF .AREA_BKS [.AREANO] EQL 0
	  AND .AREA_FOUND
	THEN
	    BEGIN
	    FAB [FAB$L_STV] = .AREANO;
	    RETURN RMSERR (BKZ);
	    END;

	! Store the biggest bucket size value so far.
	!
	IF .BIG_BKS LSS .LAST_BKS
	THEN
	    BIG_BKS = .LAST_BKS;

	END;				! end of INCR AREANO loop

    ! Store the biggest bucket size value in the FAB and IFAB.  But before, do
    ! some validation to check the cases in which there are no key nor area
    ! XABs defined, for example when the file is being created with block I/O set.
    !

    IF .BIG_BKS EQL 0
    THEN
	BEGIN
	IFAB [IFB$B_BKS] = .FAB [FAB$B_BKS];

	IF .IFAB [IFB$W_MRS] NEQU 0
	THEN
	    RETURN_ON_ERROR ( CHECK_MRS (.IFAB [IFB$B_PLG_VER], .IFAB [IFB$W_MRS]) )
	ELSE
	    RETURN_ON_ERROR ( CHECK_MRS (.IFAB [IFB$B_PLG_VER], .MAX_MINREC) );
	BIG_BKS = .IFAB [IFB$B_BKS];
	END
    ELSE
	BEGIN
	FAB [FAB$B_BKS] = .BIG_BKS;
	IFAB [IFB$B_BKS] = .BIG_BKS;
	END;

    IF .BIG_BKS EQL 0
    THEN
	BEGIN
	FAB [FAB$L_STV] = 0;		! no valid area id to give
	RETURN RMSERR (BKS);
	END;
    END;				! end of LAST_BKS, and MIN_BKS def

    ! Loop thru the key table again to validate some fields.
    !

    INCR KEYNO FROM 0 TO ( .IFAB [IFB$B_NUM_KEYS] - 1 )
    DO
	BEGIN
	FAB [FAB$L_STV] = .KEYNO;

	! Make sure the bucket size of the index level is equal to the bucket
	! size of the lowest index level for all keys.
	!

	IF .AREA_BKS [.KEY_TBL [.KEYNO, IAN]] NEQ .AREA_BKS [.KEY_TBL [.KEYNO, LAN]]
	THEN
	    RETURN RMSERR (IBK);

	! Check the IFL and DFL values.  They cannot be greater than the bucket
	! size given in number of bytes.
	!

	IF .KEY_TBL [.KEYNO, IFL] GTR (.AREA_BKS [.KEY_TBL [.KEYNO, IAN]] * 512)
	THEN
	    RETURN RMSERR (IFL);

	IF .KEY_TBL [.KEYNO, DFL] GTR (.AREA_BKS [.KEY_TBL [.KEYNO, DAN]] * 512)
	THEN
	    RETURN RMSERR (DFL);
	END;

    FAB [FAB$L_STV] = 0;

    ! Loop thru the XAB's again to fill in the correct bucket size value in the
    ! area XABs.
    !

    XAB = .FAB [FAB$L_XAB];

    WHILE .XAB NEQ 0
    DO
	BEGIN
	RETURN_ON_ERROR ( REPROBE () );

	IF .XAB [XAB$B_COD] EQL XAB$C_ALL
	THEN
	    XAB [XAB$B_BKZ] = .AREA_BKS [.XAB [XAB$B_AID]];
	XAB = .XAB [XAB$L_NXT];
	END;

    RETURN RMSSUC ();
    END;

%SBTTL	'CHECK_DENSE'
ROUTINE CHECK_DENSE (BITS_MASK) : RL$CHECK_DENSE =

!++
!
! CHECK_DENSE
!	This routine determines if the key and area XABs are dense
!	or not.
!
! CALLING SEQUENCE:
!	CHECK_DENSE (BITS_MASK)
!
! INPUT PARAMETERS:
!	BITS_MASK - Bit mask address for XABs
!
! IMPLICIT INPUTS:
!	None
!
! OUTPUT PARAMETERS:
!	None
!
! IMPLICIT OUTPUTS:
!	None
!
! ROUTINE VALUE:
!	IMX error - XABs are not dense
!	SUCCESS - XABs are dense
!
! SIDE EFFECTS:
!	None
!---

    BEGIN

    LOCAL
	TOTAL_BITS,
	FLD_SIZE,
	BIT_NUM;

    TOTAL_BITS = 255;
    FLD_SIZE = 32;
    BIT_NUM = 0;

    ! Loop until we find the first bit clear in the given field.
    !

    WHILE FFC ( BIT_NUM, FLD_SIZE, .BITS_MASK, BIT_NUM )
    DO
	BEGIN

	! None found, compute number of bits left to search
	!
	FLD_SIZE = .TOTAL_BITS - .BIT_NUM;

	IF .FLD_SIZE EQL 0
	THEN
	    RETURN RMSSUC ();

	IF .FLD_SIZE GTR 32
	THEN
	    FLD_SIZE = 32;
	END;				! end of WHILE loop

    ! There was a clear bit found.  Calculate number of bits left to search.
    ! Add one to BIT_NUM since we do not want to search that one again.
    !
    BIT_NUM = .BIT_NUM + 1;
    FLD_SIZE = .TOTAL_BITS - .BIT_NUM;

    ! If the clear bit was the last one, then we know the xabs are dense.
    !

    IF .FLD_SIZE EQL 0
    THEN
	RETURN RMSSUC ();

    IF .FLD_SIZE GTR 32
    THEN
	FLD_SIZE = 32;

    ! Loop until we find the first bit set in the given field.
    !

    WHILE FFS ( BIT_NUM, FLD_SIZE, .BITS_MASK, BIT_NUM )
    DO
	BEGIN

	! None found, compute number of bits left to search
	!
	FLD_SIZE = .TOTAL_BITS - .BIT_NUM;

	! If there are not bits left, then the xabs are dense.
	!

	IF .FLD_SIZE EQL 0
	THEN
	    RETURN RMSSUC ();

	IF .FLD_SIZE GTR 32
	THEN
	    FLD_SIZE = 32;
	END;				! end of WHILE loop

    ! If we are here, then the key or area xabs are not dense.
    !
    RETURN RMSERR (IMX);

    END;


%SBTTL	'CHECK_INPUT'
ROUTINE CHECK_INPUT ( BITS_MASK; PROLOGUE ) : RL$CHECK_INPUT =

!++
!
! CHECK_INPUT
!
!	This routine performs input checks specific to indexed sequential
!	files.  Among these are:
!	- record formats allowed:  VAR and FIX (UDF only if BIO access)
!	- legal bucket size (0<=BKS<=BKT$C_MAXBKTSIZ)
!	- key XAB checks
!	    - correct XAB length
!	    - valid key of reference
!	    - valid key size
!	    - last key character cannot be larger than minimum record size
!	    - data type is within range
!	    - check flags on primary key:  CHG and NUL not allowed
!	- area XAB checks
!	    - correct XAB length and readable
!	    - valid area identification number
!	    - legal bucket size
!	- both key and area XABs must be dense
!	- there must be a primary key
!
! CALLING SEQUENCE:
!	CHECK_INPUT ( BITS_MASK; PROLOGUE )
!
! INPUT PARAMETERS:
!	Bits mask address
!
! IMPLICIT INPUTS:
!	FAB 	- address of user's file access block
!	IFAB	- address of internal RMS file access block
!
! OUTPUT PARAMETERS:
!	PROLOGUE - prologue version number
!
! IMPLICIT OUTPUTS:
!	IFAB [IFB$W_KBUFSZ]
!	IFAB [IFB$B_BKS]
!	IFAB [IFB$W_DEQ]
!	IFAB [IFB$B_NUM_KEYS]
!	IFAB [IFB$W_RTDEQ]
!	IFAB [IFB$B_AMAX]
!	IFAB [IFB$B_AVBN] - # of prologue VBN
!	FAB [FAB$L_ALQ] - if area XAB
!	FAB [FAB$W_DEQ] - if area XAB
!
! ROUTINE VALUE:
!	RFM,BKS,IMX,REF,FLG,DTP,SIZ,POS,NPK,XAB,IAN,LAN,DAN,IFL,DFL
!	SEG,AID,IBK,KSI,BKZ,PLV,MRS, and SUC
!
! SIDE EFFECTS:
!	none
!
!--

    BEGIN

    EXTERNAL REGISTER
	COMMON_FAB_STR,
	XAB = 6	: REF BBLOCK;

    ! Must be a valid record format for indexed seq files.  If undefined
    ! record format, the BIO access bit must be on.
    !

    IF .IFAB [IFB$B_RFMORG] GTRU FAB$C_VAR
    THEN
	RETURN RMSERR (RFM);

    IF  .IFAB [IFB$B_RFMORG] EQL FAB$C_UDF
      AND
	NOT .FAB [FAB$V_BIO]
    THEN
	RETURN RMSERR (RFM);

    ! Bucket size cannot be larger than BKT$C_MAXBKTSIZ blocks
    !

    IF .FAB [FAB$B_BKS] GTRU BKT$C_MAXBKTSIZ
    THEN
	RETURN RMSERR (BKS);

    IFAB [IFB$B_BKS] = .FAB [FAB$B_BKS];

    ! Now do checks on KEY and AREA XABs.
    !

    BEGIN

    LOCAL
	KEY_BITS  : REF BITVECTOR [256],
	AREA_BITS : REF BITVECTOR [256],
	AREAS,					! # of area XAB's
	KEYS;					! # of key XAB's

    KEYS = 0;					! initialize them
    AREAS = 0;

    CLEAR ( .BITS_MASK, 64 );			! clear bit mask
    KEY_BITS = .BITS_MASK;
    AREA_BITS = .BITS_MASK + 32;
    XAB = .FAB [FAB$L_XAB];			! get start of chain

    WHILE .XAB NEQ 0
    DO

	BEGIN

	! Make sure we can read and write user's XAB.  Save XAB address
	! in status value field (STV) to be returned in case of error.
	!
	RETURN_ON_ERROR ( REPROBE() );
	FAB [FAB$L_STV] = .XAB;

	CASE .XAB [XAB$B_COD] FROM XAB$C_DAT TO XAB$C_TRM OF
	    SET

	    [XAB$C_KEY] :			! key XAB
		BEGIN

		! Check that XAB length is at least equal to minimum
		!

		IF .XAB [XAB$B_BLN] LSS XAB$C_KEYLEN_V2
		THEN
		    RETURN RMSERR (XAB);

		FAB [FAB$L_STV] = .XAB [XAB$B_REF];

		! If more than 255 keys, return error
		!

		IF .XAB [XAB$B_REF] EQL 255
		THEN
		    RETURN RMSERR (REF);

		BEGIN

		LOCAL
		    KEYSIZE,
		    MINREC,
		    SEGS;

		GET_KEY_PARMS (;KEYSIZE, MINREC, SEGS);
		RETURN_ON_ERROR ( CHECK_KEY_PARMS ( .KEYSIZE, .MINREC, .SEGS ) );

		! Set key buffer size, using the size of the longest key
		!

		IF .KEYSIZE<0, 8> GTRU .IFAB [IFB$W_KBUFSZ]
		THEN
		    IFAB [IFB$W_KBUFSZ] = .KEYSIZE;

		! Get the prologue number from the primary key XAB.
		!

		IF .XAB [XAB$B_REF] EQL 0
		THEN
		    BEGIN

		    IF .XAB [XAB$V_CHG]  OR  .XAB [XAB$V_NUL]
		    THEN
			RETURN RMSERR (FLG);
		    RETURN_ON_ERROR ( FIND_PROLOGUE ( .SEGS; PROLOGUE ) );
		    END;

		END;			! end of def of KEYSIZE, MINREC, SEGS

		! If prolog 1 defined, decide if prolog 2 is required.
		!
		
		IF .XAB [XAB$B_DTP] NEQ XAB$C_STG
		   AND .PROLOGUE EQL PLG$C_VER_NO
		THEN
		    PROLOGUE = PLG$C_VER_IDX;

		! One more key has been defined.  Set corresponding bit
		! in mask.
		!
		KEYS = .KEYS + 1;
		KEY_BITS [ .XAB [XAB$B_REF] ] = 1;

		END;				! of key XAB processing

	    [XAB$C_ALL] :			! area XAB
		BEGIN

		IF .XAB [XAB$B_BLN] LSS XAB$C_ALLLEN
		THEN
		    RETURN RMSERR (XAB);

		FAB [FAB$L_STV] = .XAB [XAB$B_AID];

		IF .XAB [XAB$B_AID] EQL 255
		THEN
		    RETURN RMSERR (AID);

		IF .XAB [XAB$B_BKZ] GTRU BKT$C_MAXBKTSIZ
		THEN
		    RETURN RMSERR (BKZ);

		! first area XAB overrides FAB values
		!

		IF .XAB [XAB$B_AID] EQL 0
		THEN
		    BEGIN
		    FAB [FAB$L_ALQ] = .XAB [XAB$L_ALQ];
		    FAB [FAB$W_DEQ] = .XAB [XAB$W_DEQ];
		    END;

		AREAS = .AREAS + 1;
		AREA_BITS [ .XAB [XAB$B_AID] ] = 1;

		END;			! of area XAB processing

	    [INRANGE] :	0;
	    [OUTRANGE] :0;

	    TES;

	XAB = .XAB [XAB$L_NXT];

	END;			! end of WHILE XAB check loop

    ! If we are creating with block I/O and no record I/O at all, make sure
    ! there is at least a primary key defined.
    !

    IF NOT ( .FAB [FAB$V_BIO] AND NOT .FAB [FAB$V_BRO] )
      AND .KEYS EQL 0
    THEN
	RETURN RMSERR (NPK);

    ! Get key XABs density.
    !

    BEGIN

    LOCAL
	STATUS;

    ! Set the STV to the XAB address for "non-dense" XAB error.
    !
    FAB [FAB$L_STV] = .FAB [FAB$L_XAB];
    STATUS = CHECK_DENSE (.KEY_BITS);

    ! If the keys are not dense, find out if there is a primary key.
    ! If not there, return "no primary key" error.
    !

    IF NOT .STATUS
    THEN
	BEGIN

	IF .KEY_BITS[0] EQL 0
	THEN
	    STATUS = RMSERR (NPK);
	RETURN .STATUS;
	END;
    END;				! end of STATUS definition


    ! If no areas defined, default to one.  Else, make sure the area
    ! XABs defined are dense.  Set maximum number of areas, and total
    ! number of keys.
    !

    IF .AREAS EQL 0
    THEN
	AREAS = 1
    ELSE
	RETURN_ON_ERROR ( CHECK_DENSE (.AREA_BITS) );

    IFAB [IFB$B_AMAX] = .AREAS;
    IFAB [IFB$B_NUM_KEYS] = .KEYS;
    FAB [FAB$L_STV] = 0;

    ! Determine minimum number of VBN's to allocate for prologue and force it
    !
    BEGIN

    LOCAL
	MIN_ALLOC;

    MIN_ALLOC = ( (.AREAS + 7) / 8 ) + 1 + ( (.KEYS + 3) / 5 );

    ! Save this value in area VBN because it is the number of VBNs
    ! used by the prologue.
    !
    IFAB [IFB$B_AVBN] = .MIN_ALLOC;

    IF .MIN_ALLOC GTRU .FAB [FAB$L_ALQ]
    THEN
	FAB [FAB$L_ALQ] = .MIN_ALLOC;

    END;		! end local definition of MIN_ALLOC

    ! Now that FAB [DEQ] has been defaulted from first area XAB if one,
    ! default IFAB [DEQ] and IFAB [RTDEQ].
    !
    IFAB [IFB$W_DEQ] = .FAB [FAB$W_DEQ];
    IFAB [IFB$W_RTDEQ] = .FAB [FAB$W_DEQ];

    END;		! end local definitions of AREAS, KEYS, and others

    RETURN RMSSUC();    ! everything checked out correctly

    END;



%SBTTL 'CHECK_KEY_PARMS'
ROUTINE CHECK_KEY_PARMS ( KEYSIZE, MINREC, SEGS ) : RL$CHECK_KEY_PARMS =

!++
!
! CHECK_KEY_PARMS
!	This routine validates key size, and sets the value in the XAB if
!	it was not defined for binary and integer types.
!
! CALLING SEQUENCE:
!	CHECK_KEY_PARMS ( KEYSIZE, MINREC, SEGS )
!
! INPUT PARAMETERS:
!	KEYSIZE - number of characters in key
!	MINREC - minimum record size
!	SEGS - number of segments
!
! IMPLICIT INPUTS:
!	XAB      - address of XAB to process
!	IFAB address
!
! OUTPUT PARAMETERS:
!	None
!
! IMPLICIT OUTPUTS:
!	None
!
! ROUTINE VALUE:
!	R0 :  Success or ( SEG, SIZ, DTP, POS ) error code
!
! SIDE EFFECTS:
!	XAB [XAB$B_SIZ0] filled in if it was 0.
!
!--

    BEGIN

    EXTERNAL REGISTER
	R_IFAB_STR,
	XAB = 6	: REF BBLOCK;

    ! If more than one segment, and key data type is not string, then
    ! return error.
    !

    IF .SEGS GTRU 1
      AND
	.XAB [XAB$B_DTP] NEQ XAB$C_STG
    THEN
	RETURN RMSERR (SEG);

    ! Validate key size depending on data type
    !

    CASE .XAB [XAB$B_DTP] FROM XAB$C_STG TO XAB$C_MAXDTP OF
	SET

	[XAB$C_STG]:				! string data type
	    IF .KEYSIZE EQL 0
		OR  .KEYSIZE GTRU 255
	    THEN
		RETURN RMSERR (SIZ);

	[XAB$C_IN2, XAB$C_BN2] :		! 2-byte integer or binary
	    BEGIN
	    IF .KEYSIZE EQL 0
	    THEN
		BEGIN
		KEYSIZE = 2;
		XAB [XAB$B_SIZ0] = .KEYSIZE;
		END;

	    IF .KEYSIZE NEQ 2
	    THEN
		RETURN RMSERR (SIZ);
	    END;

	[XAB$C_IN4, XAB$C_BN4] :		! 4-byte integer or binary
	    BEGIN
	    IF .KEYSIZE EQL 0
	    THEN
		BEGIN
		KEYSIZE = 4;
		XAB [XAB$B_SIZ0] = .KEYSIZE;
		END;

	    IF .KEYSIZE NEQ 4
	    THEN
	        RETURN RMSERR (SIZ);
	    END;

	[XAB$C_PAC] :				! packed decimal string
	    IF .KEYSIZE GTRU 16			! max size is 31 nibbles + sign
	      OR .KEYSIZE EQL 0
	    THEN
		RETURN RMSERR (SIZ);

	[XAB$C_IN8, XAB$C_BN8] :		! 8-byte integer or binary
	    BEGIN
	    IF .KEYSIZE EQL 0
	    THEN
		BEGIN
		KEYSIZE = 8;
		XAB [XAB$B_SIZ0] = .KEYSIZE;
		END;

	    IF .KEYSIZE NEQ 8
	    THEN
	        RETURN RMSERR (SIZ);
	    END;

	[OUTRANGE] :				! illegal data type
	    RETURN RMSERR (DTP);

	TES;

    ! If the minimum record value calculated by GET_KEY_PARMS equals 0,
    ! then the key must have been a binary or integer with 0 length.
    ! Set MINREC correctly now that the keysize is known.
    !

    IF .MINREC EQL 0
    THEN
	MINREC = .KEYSIZE + .XAB [XAB$W_POS0];

    ! Make sure that the maximum record size defined by user is enough to
    ! hold the key.
    !

    IF .IFAB [IFB$W_MRS] NEQ 0
      AND .MINREC GTRU .IFAB [IFB$W_MRS]
    THEN
	RETURN RMSERR (POS);

    RETURN RMSSUC();

    END;					! end of CHECK_KEY_PARMS

%SBTTL	'CHECK_MRS'
ROUTINE CHECK_MRS ( PROLOGUE, REC_SIZE ) : RL$CHK_AND_REPROBE =

!++
!
! CHECK_MRS
!
!	This routine checks that the record size given fits in a bucket,
!	and calculates the minimum bucket size if not specified by
!	the user.
!
! CALLING SEQUENCE:
!	CHECK_MRS (PROLOGUE, REC_SIZE)
!
! INPUT PARAMETERS:
!	PROLOGUE :  prologue version
!	REC_SIZE :  Maximum Record Size given by user or
!		    Minimum record size calculated using key size/position
!
! IMPLICIT INPUTS:
!	XAB      - address of XAB to process
!	FAB	 - address of file access block
!	IFAB	 - address of internal FAB
!
! OUTPUT PARAMETERS:
!	None
!
! IMPLICIT OUTPUTS:
!	IFAB [IFB$B_BKS]
!
! ROUTINE VALUE:
!	R0 :  MRS error if record does not fit in bucket
!
! SIDE EFFECTS:
!	none
!
!--

    BEGIN

    EXTERNAL REGISTER
	R_FAB_STR,
	R_IFAB_STR,
	XAB = 6	: REF BBLOCK;

    ! If the user did not specify a bucket size, define a maximum size
    ! to make sure MRS will fit.
    !
    BEGIN

    LOCAL
	BUCKET_SIZE;

    IF .IFAB [IFB$B_BKS] EQL 0
    THEN
	BUCKET_SIZE = BKT$C_MAXBKTSIZ
    ELSE
	BUCKET_SIZE = .IFAB [IFB$B_BKS];
    
    ! Decide if record size will fit in bucket.
    ! For prologue 3 files, we have to consider all possible overhead due to
    ! compression.  Only do these calculations if record size does not equal 0.
    !

    IF .REC_SIZE NEQU 0
    THEN
	BEGIN

	LOCAL
	    BYTES_IN_BKS;

	IF .PROLOGUE LSSU PLG$C_VER_3
	THEN
	    BEGIN

	    BYTES_IN_BKS = ( .BUCKET_SIZE * 512 ) - BKT$C_OVERHDSZ - 1 -
	    	    	IRC$C_FIXOVHDSZ;	    	    	    ! -1 for check byte at end

	    IF .IFAB [IFB$B_RFMORG] EQL FAB$C_VAR
	    THEN
	        BYTES_IN_BKS = .BYTES_IN_BKS - (IRC$C_VAROVHDSZ - IRC$C_FIXOVHDSZ);
	    END
	ELSE
	    BYTES_IN_BKS = ( .BUCKET_SIZE * 512 ) - BKT$C_OVERHDSZ
		    - BKT$C_DATBKTOVH - IRC$C_VAROVHSZ3
		    - IRC$C_KEYCMPOVH - IRC$C_DATCMPOVH;

	IF .REC_SIZE GTRU WORDMASK(.BYTES_IN_BKS)
	THEN
	    RETURN RMSERR (MRS);
	END;					! end of MRS check
    END;					! end of BUCKET_SIZE definition

    ! If the user did not specify a bucket size, find the minimum size,
    ! based on the record size, which was given.
    !

    IF .IFAB [IFB$B_BKS] EQL 0
    THEN
	BEGIN

	LOCAL
	    BYTES;				! # of bytes to hold one record

	IF .PROLOGUE LSSU PLG$C_VER_3
	THEN
	    BEGIN
	    BYTES = .REC_SIZE + BKT$C_OVERHDSZ + IRC$C_FIXOVHDSZ;

	    IF .IFAB [IFB$B_RFMORG] EQL FAB$C_VAR
	    THEN
		BYTES = .BYTES + (IRC$C_VAROVHDSZ - IRC$C_FIXOVHDSZ);

	    END
	ELSE

	    ! Assume all kinds of compressions on for prologue 3 files...
	    !
	    BYTES = .REC_SIZE + BKT$C_OVERHDSZ + BKT$C_DATBKTOVH
			+ IRC$C_VAROVHSZ3 + IRC$C_KEYCMPOVH + IRC$C_DATCMPOVH;

	IFAB [IFB$B_BKS] = ( .BYTES / 512 ) + 1;

	! If the bucket size we found is only equal to 1, optimize space
	! and performance by setting it to 2.
	!

	IF .IFAB [IFB$B_BKS] EQL 1
	THEN
	    IFAB [IFB$B_BKS] = 2;
	END;					! end of bucket size defaulting

    RETURN RMSSUC();
    END;	


%SBTTL	'CHECK_OVERLAP'
ROUTINE CHECK_OVERLAP ( NO_SEGS ) : RL$CHECK_OVERLAP =

!++
!
! CHECK_OVERLAP
!
!	This routine checks if the segments of the primary key for
!	prologue 3 files overlap, or not.
!
! CALLING SEQUENCE:
!	CHECK_OVERLAP(NO_SEGS)
!
! INPUT PARAMETERS:
!	NO_SEGS :  number of segments in primary key
!
! IMPLICIT INPUTS:
!	XAB      - address of XAB to process
!
! OUTPUT PARAMETERS:
!	None
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	R0 :  SUC - segments do not overlap (success)
!	      SEG error code - segments overlap
!
! SIDE EFFECTS:
!	none
!
!--

    BEGIN

    EXTERNAL REGISTER
	XAB = 6	: REF BBLOCK;

    LOCAL
	START1,
	END1,
	START2,
	END2,
	LEN	: REF VECTOR [, BYTE],
	POS	: REF VECTOR [, WORD];

    POS = XAB [XAB$W_POS];
    LEN = XAB [XAB$B_SIZ];

    ! To find out if any segments in the primary key overlap, we must
    ! find the starting and ending position of a given segment, and
    ! compare these values with the starting and ending position of all
    ! other segments in the key.
    !

    INCR I FROM 0 TO (.NO_SEGS - 2)
    DO
	BEGIN
	START1 = .POS[.I];
	END1 = .POS[.I] + .LEN[.I] - 1;

	INCR J FROM .I+1 TO (.NO_SEGS - 1)
	DO
	    BEGIN
	    START2 = .POS[.J];
	    END2 = .POS[.J] + .LEN[.J] - 1;

	    IF ((.START1 GEQ .START2) AND (.START1 LEQ .END2))
	      OR ((.END1 GEQ .START2) AND (.END1 LEQ .END2))
		OR ((.START1 LEQ .START2) AND (.END1 GEQ .END2))
	    THEN
		RETURN RMSERR (SEG);
	    END;			! end of INCR J loop
	END;				! end of INCR I loop

    RETURN RMSSUC();			! return success

    END;	

%SBTTL	'CHECK_PROLOG'
ROUTINE CHECK_PROLOG (PROLOG, NO_SEGS; PROLOGUE) : RL$CHECK_PROLOG =

!++
!
! CHECK_PROLOG
!
!	This routine finds the highest prologue that can
!	handle this key XAB, starting with the value in PROLOG.
!
! CALLING SEQUENCE:
!	CHECK_PROLOG (PROLOG, NO_SEGS; PROLOGUE)
!
! INPUT PARAMETERS:
!	PROLOG - prologue number to start with
!	NO_SEGS - number of segments in key
!
! IMPLICIT INPUTS:
!	XAB - address of XAB to process
!
! OUTPUT PARAMETERS:
!	PROLOGUE
!
! IMPLICIT OUTPUTS:
!	None
!
! ROUTINE VALUE:
!	Error status or success
!
! SIDE EFFECTS:
!	None
!---

BEGIN

EXTERNAL REGISTER
    R_IFAB_STR,
    R_FAB,
    XAB = 6;

LOCAL
    STATUS;

STATUS = RMSERR (PLV);

DECR I FROM .PROLOG TO 1 DO

    BEGIN
    CASE .I FROM 1 TO 3 OF

	SET

	[1,2] : ! Set to prologue 1 and return success
		!
		BEGIN
		PROLOGUE = PLG$C_VER_NO;
		RETURN RMSSUC();
		END;

	[3] :	! Prologue 3:  if all checks succeed, the prologue version
		! becomes 3, otherwise, we try a lower version.
		!
		BEGIN
		PROLOGUE = PLG$C_VER_3;
		STATUS = CHECK_OVERLAP (.NO_SEGS);

		! If the keys do not overlap, we must check for maximum record
		! size here too, since we do not want to break old programs
		! that do not specify a prologue number, but have big MRS set.
		!

		IF .STATUS
		THEN
		    BEGIN
		    STATUS = CHECK_MRS (PLG$C_VER_3, .IFAB [IFB$W_MRS]);

		    IF .STATUS
		    THEN
			RETURN .STATUS;
		    END;

		END;

	[OUTRANGE] : ! Invalid prologue number
		RETURN RMSERR (PLV);

	TES;
    END;

! If we got here, no prologue worked
!
RETURN .STATUS;
END;


%SBTTL	'CLEAR'
ROUTINE CLEAR ( BUFFER, SIZE ) : RL$CLEAR NOVALUE =

!++
!
! CLEAR
!	This routine fills the buffer with zeros.  It is a separate routine
!	so as not to clobber R4 and R5.
!
! CALLING SEQUENCE:
!	CLEAR (BUFFER, SIZE)
!
! INPUT PARAMETERS:
!	buffer to clear
!	number of bytes to clear
!
! IMPLICIT INPUTS:
!	BKT_ADDR - address of buffer to initialize
!
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	none
!
! SIDE EFFECTS:
!	none
!
!--

    BEGIN
    CH$FILL ( 0, .SIZE, .BUFFER );
    END;


%SBTTL	'EXTEND'
ROUTINE EXTEND (BUF,XAB) : RL$EXTEND =

!++
!
! EXTEND
!	This routine is an interface to RM$EXTEND0.  It is called to
!	extend a file area based on the allocation specified in the
!	allocation XAB.
!
! CALLING SEQUENCE:
!	EXTEND (BUF,XAB)
!
! INPUT PARAMETERS:
!	BUF	- address of area buffer
!	XAB address
!
! IMPLICIT INPUTS:
!	FAB address
!	IFAB address
!
! OUTPUT PARAMETERS:
!	BUF [AREA$L_CVNB] 	- start VBN
!	BUF [AREA$L_NXTVBN]	- start VBN
!	BUF [AREA$L_CNBLK]	- number of VBNs in extent
!	BUF [AREA$L_TOTAL_ALLOC]- total number of VBNs in area
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	Success or error code (ALN or AOP)
!
! SIDE EFFECTS:
!	none
!
!--

    BEGIN

    MAP
	BUF	: REF BBLOCK,
	XAB	: REF BBLOCK;

    EXTERNAL REGISTER
	COMMON_FAB_STR;

    LOCAL
	EXTEND_QT;

    EXTEND_QT = .XAB [XAB$L_ALQ];

    BEGIN

    LOCAL
	STARTVBN,
	ENDVBNP1;

    RETURN_ON_ERROR ( RM$EXTEND0 ( .EXTEND_QT, .ENDVBNP1; STARTVBN, ENDVBNP1 ));

    ! Set up IFAB EBK and HBK data
    !
    IFAB [IFB$L_EBK] = .ENDVBNP1;
    IFAB [IFB$L_HBK] = .ENDVBNP1 - 1;

    BUF [AREA$L_CVBN]   = .STARTVBN;
    BUF [AREA$L_NXTVBN] = .STARTVBN;
    BUF [AREA$L_CNBLK]  = .ENDVBNP1 - .STARTVBN

    END;

    BUF [AREA$L_TOTAL_ALLOC] = .BUF [AREA$L_CNBLK];
    XAB [XAB$L_ALQ] = .BUF [AREA$L_CNBLK];
    FAB [FAB$L_ALQ] = .FAB [FAB$L_ALQ] + .XAB [XAB$L_ALQ];

    RETURN RMSSUC ();

    END;

%SBTTL	'FIND_PROLOGUE'
ROUTINE FIND_PROLOGUE ( NO_SEGS; PROLOGUE ) : RL$FIND_PROLOGUE =

!++
!
! FIND_PROLOGUE
!	This routine examines the key XAB and determines the prologue
!	version depending on a series of parameters.
!
! CALLING SEQUENCE:
!	FIND_PROLOGUE ( NO_SEGS; PROLOGUE )
!
! INPUT PARAMETERS:
!	NO_SEGS - number of segments in key
!
! IMPLICIT INPUTS:
!	XAB      - address of XAB to process
!
! OUTPUT PARAMETERS:
!	PROLOGUE version number
!
! IMPLICIT OUTPUTS:
!	None
!
! ROUTINE VALUE:
!	R0 :  Success or PLV error code
!
! SIDE EFFECTS:
!	none
!
!--

    BEGIN

    EXTERNAL REGISTER
	R_IFAB,
	R_FAB,
	XAB = 6 :  REF BBLOCK;

    LOCAL
	PROLOG;

    ! First check if the user actually specified a prologue number
    !

    IF .XAB [XAB$B_BLN] GEQU XAB$C_KEYLEN
    THEN

	! The user has a long key XAB
	!
	BEGIN

	IF .XAB [XAB$B_PROLOG] GTRU 0
	THEN

	    ! We have an explicit prologue number.
	    ! Check that there is a valid key XAB for that
	    ! prologue.
	    !
	    BEGIN

	    CASE .XAB [XAB$B_PROLOG] FROM 1 TO 3 OF
		SET

		[1,2] :	BEGIN
			PROLOGUE = PLG$C_VER_NO;
			RETURN RMSSUC ();
			END;

		[3]   :	BEGIN
			PROLOGUE = PLG$C_VER_3;
			RETURN CHECK_OVERLAP (.NO_SEGS);
			END;

		[OUTRANGE] : RETURN RMSERR (PLV);

		TES;
	    END;

	END;

    ! Either the user has a short XAB or he didn't specify
    ! prologue number.  Look for process and system defaults.
    !

    IF .PIO$GB_RMSPROLOG<0,8> NEQU 0
    THEN
	! There is a default process prologue level
	!
	PROLOG = .PIO$GB_RMSPROLOG<0,8>
    ELSE

    IF .SYS$GB_RMSPROLOG<0,8> NEQU 0
    THEN
	! There is a default system prologue level
	!
	PROLOG = .SYS$GB_RMSPROLOG<0,8>
    ELSE
	! Try for the best there is
	!
	PROLOG = PLG$C_VER_3;

    RETURN CHECK_PROLOG (.PROLOG, .NO_SEGS; PROLOGUE);

END;

%SBTTL	'GET_BKS'
ROUTINE GET_BKS ( AREA_NO ; BKT_SIZE) : RL$GET_BKS =

!++
!
! GET_BKS
!	This routine returns the bucket size corresponding to the index
!	or data level area number of the given key of reference.
!
! CALLING SEQUENCE:
!	GET_BKS ( AREA_NO ; BKT_SIZE )
!
! INPUT PARAMETERS:
!	AREA_NO - Area number we are looking for
!
! IMPLICIT INPUTS:
!	IFAB address
!	FAB address
!	XAB address
!
! OUTPUT PARAMETERS:
!	BKT_SIZE = bucket size value for the given area
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	1 - success
!	XAB error on REPROBE
!
! SIDE EFFECTS:
!	none
!
!--

    BEGIN

    EXTERNAL REGISTER
	R_IFAB_STR,
	R_FAB_STR,
	XAB = 6 :	REF BBLOCK;

    LOCAL
	SAVE_XAB;			! stores address of current XAB

    SAVE_XAB = .XAB;
    XAB = .FAB [FAB$L_XAB];

    ! Loop thru the XAB chain
    !
    WHILE .XAB NEQ 0
    DO
	BEGIN
	RETURN_ON_ERROR ( REPROBE () );

	! If it is an area allocation XAB, and the area id is the one we
	! area looking for, get the bucket size and return.
	!

	IF .XAB [XAB$B_COD] EQL XAB$C_ALL
	  AND .XAB [XAB$B_AID] EQL .AREA_NO <0,8>
	THEN
	    EXITLOOP;
	XAB = .XAB [XAB$L_NXT];
	END;

    ! If no area was found, return IFAB bucket size value, else
    ! use value from XAB.
    !

    IF .XAB EQL 0
    THEN
	BKT_SIZE = .IFAB [IFB$B_BKS]
    ELSE
	BKT_SIZE = .XAB [XAB$B_BKZ];
    XAB = .SAVE_XAB;			! restore XAB addresss
    RETURN RMSSUC ();

    END;

%SBTTL 'GET_KEY_PARMS'
ROUTINE GET_KEY_PARMS ( ;KEYSIZE, MINREC, SEGS ) : RL$GET_KEY_PARMS NOVALUE =

!++
!
! GET_KEY_PARMS
!	This routine determines the number of segments in a key,
!	the size of the key, and the minimum record size containing key.
!
! CALLING SEQUENCE:
!	GET_KEY_PARMS ( ;KEYSIZE, MINREC, SEGS )
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	XAB      - address of XAB to process
!
! OUTPUT PARAMETERS:
!	KEYSIZE - total number of characters in key
!	MINREC  - minimum size of record necessary to contain key
!	SEGS - number of segments in key
!
! IMPLICIT OUTPUTS:
!	None
!
! ROUTINE VALUE:
!	none
!
! SIDE EFFECTS:
!	none
!
!--

    BEGIN

    EXTERNAL REGISTER
	XAB = 6	: REF BBLOCK;

    LOCAL
	LEN	: REF VECTOR [, BYTE],
	POS	: REF VECTOR [, WORD],
	TYP	: REF VECTOR [, BYTE];

    POS = XAB [XAB$W_POS];
    LEN = XAB [XAB$B_SIZ];
    SEGS = 0;
    MINREC = 0;
    KEYSIZE = 0;

    ! Loop thru all key segments adding values to find keysize, number of
    ! segments, and minimum record size to include key.  Stop the loop when
    ! a segment of zero length is found.
    !

    INCR I FROM 0 TO 7 DO
	BEGIN

	IF .LEN[.I] NEQ 0
	THEN
	    BEGIN
	    SEGS = .SEGS + 1;
	    KEYSIZE = .KEYSIZE + .LEN[.I];

	    IF .POS[.I] + .LEN[.I] GTRU .MINREC
	    THEN
		MINREC = .POS[.I] + .LEN[.I];
	    END
	ELSE
	    EXITLOOP;
	END;

    ! If the first segment had zero length, assume there is at least one
    ! segment, until we can verify if the key definition is correct.
    !

    IF .SEGS EQL 0
    THEN
	SEGS = 1;

    END;


%SBTTL	'MOVE'
ROUTINE MOVE ( SEGMENTS ) : RL$WRITE_KEY_DESC =

!++
!
! MOVE
!
!	This routine moves key position/length information
!	from XAB's to key descriptors on disk.
!	If also moves the key name if non_zero.
!	It is done as a routine so as not to clobber R4 - R5.
!
! CALLING SEQUENCE:
!	MOVE ( SEGMENTS )
!
! INPUT PARAMETERS:
!	SEGMENTS - number of segments in the key
!
! IMPLICIT INPUTS:
!	BUF	- address of key descriptor buffer
!	XAB	- address of XAB containing data to be moved
!
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	data moved to BUF, an image of the disk key descriptor
!
! ROUTINE VALUE:
!	KNM error if keyname reprobe fails
!	SUC - success
!
! SIDE EFFECTS:
!	none
!
!--

    BEGIN

    EXTERNAL REGISTER
	R_FAB_STR,
	R_IFAB_STR,
	BUF = 7	: REF BBLOCK,
	XAB = 6	: REF BBLOCK;

    ASSUME( %QUOTE KEY$W_POSITION,  %QUOTE KEY$W_POSITION1);
    ASSUME( %QUOTE KEY$W_POSITION1, %QUOTE KEY$W_POSITION2);
    ASSUME( %QUOTE KEY$W_POSITION2, %QUOTE KEY$W_POSITION3);
    ASSUME( %QUOTE KEY$W_POSITION3, %QUOTE KEY$W_POSITION4);
    ASSUME( %QUOTE KEY$W_POSITION4, %QUOTE KEY$W_POSITION5);
    ASSUME( %QUOTE KEY$W_POSITION5, %QUOTE KEY$W_POSITION6);
    ASSUME( %QUOTE KEY$W_POSITION6, %QUOTE KEY$W_POSITION7);
    ASSUME( %QUOTE KEY$W_POSITION7, %QUOTE KEY$B_SIZE);
    ASSUME( %QUOTE KEY$B_SIZE,  %QUOTE KEY$B_SIZE1);
    ASSUME( %QUOTE KEY$B_SIZE1, %QUOTE KEY$B_SIZE2);
    ASSUME( %QUOTE KEY$B_SIZE2, %QUOTE KEY$B_SIZE3);
    ASSUME( %QUOTE KEY$B_SIZE3, %QUOTE KEY$B_SIZE4);
    ASSUME( %QUOTE KEY$B_SIZE4, %QUOTE KEY$B_SIZE5);
    ASSUME( %QUOTE KEY$B_SIZE5, %QUOTE KEY$B_SIZE6);
    ASSUME( %QUOTE KEY$B_SIZE6, %QUOTE KEY$B_SIZE7);
    ASSUME( %QUOTE KEY$B_SIZE7, %QUOTE KEY$T_KEYNAM);

%IF $BYTEOFFSET(KEY$T_KEYNAM) + KEY$S_KEYNAM NEQ $BYTEOFFSET(KEY$L_LDVBN)
%THEN
    %WARN('WARNING CONSTANT HAS CHANGES')
%FI;

    ! Pick up the keyname buffer address into a local.  Reprobe for read,
    ! and if valid, move to key descriptor buffer.
    !

    IF .XAB [XAB$L_KNM] NEQ 0
    THEN
	BEGIN

	LOCAL
	    KEYNAM;

	KEYNAM = .XAB [XAB$L_KNM];

	IFNORD ( %REF (KEY$S_KEYNAM), .KEYNAM, IFAB [IFB$B_MODE],
		BEGIN
		FAB [FAB$L_STV] = .XAB [XAB$B_REF]; 
		RETURN RMSERR (KNM);
		END );
	CH$MOVE(KEY$S_KEYNAM, .KEYNAM, BUF[KEY$T_KEYNAM]);
	END;

    ! Move the segments position and size.  Use the number of
    ! segments to do the move as a unit.
    !
    CH$MOVE ( .SEGMENTS * 2, XAB [XAB$W_POS], BUF [KEY$W_POSITION] );
    CH$MOVE ( .SEGMENTS, XAB [XAB$B_SIZ], BUF [KEY$B_SIZE] );

    ! Set data types values.  Propagate XAB$B_DTP to TYP0, and
    ! TYP1-TYP7 to null (STG).
    !
    BUF[KEY$B_TYPE] = .XAB [XAB$B_DTP];
    CH$FILL( 0, 7, BUF[KEY$B_TYPE1] );

    RETURN RMSSUC();
    END;					! end of routine MOVE

%SBTTL	'READ_PROLOGUE'
ROUTINE READ_PROLOGUE ( VBN ) : RL$RW_PROLOG =

!++
!
! READ_PROLOGUE
!
!	This routine locks the VBN.
!
! CALLING SEQUENCE:
!	READ_PROLOGUE ( VBN )
!
! INPUT PARAMETERS:
!	VBN	- VBN to lock
!
! IMPLICIT INPUTS:
!	none
!
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	RPL error
!	SUC - success
!
! SIDE EFFECTS:
!	none
!
!--

    BEGIN

    EXTERNAL REGISTER
	COMMON_FAB_STR,
	R_BDB_STR;

    GLOBAL REGISTER
	R_BKT_ADDR;

    RETURN_ON_ERROR ( RM$CACHE (.VBN, 512, CSH$M_NOREAD  OR  CSH$M_LOCK),
		BEGIN
		IF .FAB [FAB$L_STV] EQL 0
		THEN
		    FAB [FAB$L_STV] = .STATUS OR 1^16;
		STATUS = RMSERR (RPL) 
		END );

    RETURN RMSSUC();

    END;

%SBTTL	'REPROBE'
ROUTINE REPROBE : RL$CHK_AND_REPROBE =

!++
!
! REPROBE
!	This routine reprobes current XAB for read and write.
!
! CALLING SEQUENCE:
!	REPROBE()
!
! INPUT PARAMETERS:
!	none
!
! IMPLICIT INPUTS:
!	XAB - address of user XAB
!	IFAB address
!	FAB address
!
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	Success or XAB error code
!
! SIDE EFFECTS:
!	none
!
!--

    BEGIN

    EXTERNAL REGISTER
	R_IFAB_STR,
	R_FAB_STR,
	XAB = 6 :	REF BBLOCK;

    ! Probe current XAB for read and write.
    !

    IFNORD ( %REF($BYTEOFFSET(XAB$L_NXT) + $FIELDWIDTH(XAB$L_NXT)/8),
		 .XAB,
		 IFAB [IFB$B_MODE],
		(FAB [FAB$L_STV] = .XAB;
		RETURN RMSERR (XAB)) );

    IF .XAB [XAB$B_COD] EQL XAB$C_ALL
    THEN
	IFNOWRT ( %REF(XAB$C_ALLLEN), .XAB, IFAB [IFB$B_MODE],
		    (FAB [FAB$L_STV] = .XAB;
		    RETURN RMSERR (XAB)) );

    IF .XAB [XAB$B_COD] EQL XAB$C_KEY
    THEN
	BEGIN

	IF .XAB [XAB$B_BLN] GEQ XAB$C_KEYLEN
	THEN
	    IFNOWRT ( %REF(XAB$C_KEYLEN), .XAB, IFAB [IFB$B_MODE],
			(FAB [FAB$L_STV] = .XAB;
			RETURN RMSERR (XAB)) )
	ELSE
	    IFNOWRT ( %REF(XAB$C_KEYLEN_V2), .XAB, IFAB [IFB$B_MODE],
			(FAB [FAB$L_STV] = .XAB;
			RETURN RMSERR (XAB)) );

	END;

    RETURN RMSSUC();

    END;


%SBTTL	'WRITE_KEY_DESC'
ROUTINE WRITE_KEY_DESC : RL$WRITE_KEY_DESC =

!++
!
! WRITE_KEY_DESC
!	This routine fills in the data of the prologue key descriptor.
!
! CALLING SEQUENCE:
!	WRITE_KEY_DESC
!
! INPUT PARAMETERS:
!	None
!
! IMPLICIT INPUTS:
!	IFAB address
!	FAB address
!	XAB to process
!	BUF - address of key descriptor
!
! IMPLICIT OUTPUTS:
!	None
!
! ROUTINE VALUE:
!	SUC - success
!	KNM - error from routine MOVE when keyname probing fails
!
! SIDE EFFECTS:
!	Some fields in user's XAB are written.
!
!--

    BEGIN

    EXTERNAL REGISTER
	R_FAB_STR,
	R_IFAB_STR,
	BUF = 7 :	REF BBLOCK,
	XAB = 6 :	REF BBLOCK;

    CLEAR ( .BUF, KEY$C_BLN + KEY$C_SPARE );

    ! Fill in key descriptor in prologue VBN
    ! key descriptor.
    !
    BUF [KEY$B_IANUM] = .XAB [XAB$B_IAN];
    BUF [KEY$B_LANUM] = .XAB [XAB$B_LAN];
    BUF [KEY$B_DANUM] = .XAB [XAB$B_DAN];

    ! This is needed to conform with RMS_11 clug.
    !
    (BUF [KEY$L_ROOTVBN])<0, 8> = .XAB [XAB$B_DAN];
    (BUF [KEY$L_ROOTVBN])<8, 8> = .XAB [XAB$B_IAN];
    (BUF [KEY$L_ROOTVBN])<16, 8> = .XAB [XAB$B_LAN];
    BUF [KEY$B_DATATYPE] = .XAB [XAB$B_DTP];

    ! Get the bucket size calculated for the given area number
    !

    BEGIN

    LOCAL
	BKT_SIZE;

    RETURN_ON_ERROR ( GET_BKS ( .XAB [XAB$B_IAN]; BKT_SIZE ) );
    BUF [KEY$B_IDXBKTSZ] = .BKT_SIZE;
    RETURN_ON_ERROR ( GET_BKS ( .XAB [XAB$B_DAN]; BKT_SIZE ) );
    BUF [KEY$B_DATBKTSZ] = .BKT_SIZE;
    END;				! end of BKT_SIZE definition

    BEGIN

    LOCAL
	KEYSIZE,
	MINREC,
	SEGS;

    GET_KEY_PARMS ( ;KEYSIZE, MINREC, SEGS );

    BUF [KEY$B_SEGMENTS] = .SEGS;
    BUF [KEY$B_NULLCHAR] = .XAB [XAB$B_NUL];
    BUF [KEY$B_KEYSZ] = .KEYSIZE;
    BUF [KEY$B_KEYREF] = .XAB [XAB$B_REF];
    BUF [KEY$W_MINRECSZ] = .MINREC;

    ! Now we must make intelligent decisions about the compression
    ! bits for the keys.  If it is not a plg 3 file, then we want
    ! to turn off all compression, since default is zero.
    !

    IF .IFAB [IFB$B_PLG_VER] LSSU PLG$C_VER_3
    THEN
	BEGIN
	XAB [XAB$V_KEY_NCMPR] = 1;
	XAB [XAB$V_IDX_NCMPR] = 1;

	IF .XAB [XAB$B_REF] EQL 0
	THEN
	    XAB [XAB$V_DAT_NCMPR] = 1;
	END

    ! In a prologue 3 file, we decide if the compression should
    ! be turned off depending on the key size and type.
    !
    ELSE
        BEGIN

	! If the key is less than 6 bytes, or it is not a string key,
	! do not allow compression.
	!

	IF .KEYSIZE LSS 6
	  OR .XAB [XAB$B_DTP] NEQ XAB$C_STG
	THEN
	    BEGIN
	    XAB [XAB$V_KEY_NCMPR] = 1;
	    XAB [XAB$V_IDX_NCMPR] = 1;
	    END;

	! If the data record left after the primary key is
	! extracted is less than 11 bytes, do not allow data compression.
	!

	IF .XAB [XAB$B_REF] EQL 0
	THEN

	    IF .IFAB [IFB$W_MRS] NEQ 0
	      AND (.IFAB [IFB$W_MRS] - .KEYSIZE<0,16>) LSS 11
	    THEN
	        XAB [XAB$V_DAT_NCMPR] = 1;
	END;

    ! Store flag values.  First those that are valid for all keys, and
    ! then depending on the key of reference.
    !
    BUF [KEY$V_DUPKEYS] = .XAB [XAB$V_DUP];
    BUF [KEY$V_INITIDX] = 1;
    BUF [KEY$V_IDX_COMPR] = NOT .XAB [XAB$V_IDX_NCMPR];
    BUF [KEY$V_KEY_COMPR] = NOT .XAB [XAB$V_KEY_NCMPR];

    IF .XAB [XAB$B_REF] EQL 0
    THEN
	BUF [KEY$V_REC_COMPR] = NOT .XAB [XAB$V_DAT_NCMPR]
    ELSE
	BEGIN
	BUF [KEY$V_NULKEYS] = .XAB [XAB$V_NUL];
	BUF [KEY$V_CHGKEYS] = .XAB [XAB$V_CHG];
	END;

    ! Move key position / length information
    !
    RETURN_ON_ERROR ( MOVE ( .SEGS ) );

    END;			! end of KEYSIZE,MINREC,SEGS def

    BUF [KEY$W_IDXFILL] = .XAB [XAB$W_IFL];

    IF .BUF [KEY$W_IDXFILL] EQL 0
    THEN
	BUF [KEY$W_IDXFILL] = .BUF [KEY$B_IDXBKTSZ] * 512;

    IF .BUF [KEY$W_IDXFILL] LSSU
			WORDMASK( .BUF [KEY$B_IDXBKTSZ] * ( 512/2 ) )
    THEN
	BUF [KEY$W_IDXFILL] = .BUF [KEY$B_IDXBKTSZ] * ( 512/2 );

    BUF [KEY$W_DATFILL] = .XAB [XAB$W_DFL];

    IF .BUF [KEY$W_DATFILL] EQL 0
    THEN
	BUF [KEY$W_DATFILL] = .BUF [KEY$B_DATBKTSZ] * 512;

    IF .BUF [KEY$W_DATFILL] LSSU
		WORDMASK( .BUF [KEY$B_DATBKTSZ] * ( 512/2 ) )
    THEN
	BUF [KEY$W_DATFILL] = .BUF [KEY$B_DATBKTSZ] * ( 512/2 );

    ! Set pointers to next key descriptor:  if this is the last key,
    ! then pointers should be zero.  Otherwise, use key of reference
    ! value to find next position.
    !

    IF .XAB [XAB$B_REF] EQL (.IFAB [IFB$B_NUM_KEYS] - 1)
    THEN
	BEGIN
	BUF [KEY$L_IDXFL] = 0;
	BUF [KEY$W_NOFF] = 0;
	END
    ELSE
	BEGIN
	BUF [KEY$L_IDXFL] = (.XAB [XAB$B_REF] + 5) / 5 + 1;
	BUF [KEY$W_NOFF] = ( ( .XAB [XAB$B_REF] ) MOD 5 )
					* ( KEY$C_BLN + KEY$C_SPARE );
	END;

    RETURN RMSSUC();			! return success

    END;

%SBTTL	'WRITE_PROLOGUE'
ROUTINE WRITE_PROLOGUE : RL$RW_PROLOG =

!++
!
! WRITE_PROLOGUE
!
!	This routine recalculates the check sum, sets the buffer dirty, and
!	writes it out.
!
!
! CALLING SEQUENCE:
!	WRITE_PROLOGUE()
!
! INPUT PARAMETERS:
!	none
!
! IMPLICIT INPUTS:
!	BDB	- address of BDB describing buffer containing prologue VBN
!
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	WPL error
!	Success code
!
! SIDE EFFECTS:
!
!--

    BEGIN

    EXTERNAL REGISTER
	COMMON_FAB_STR,
	R_BDB_STR;

    RM$MAKSUM(.BDB [BDB$L_ADDR]);
    BDB [BDB$V_VAL] = 1;
    BDB [BDB$V_DRT] = 1;

    BEGIN

    LOCAL
	FLAGS;

    FLAGS = RLS$M_WRT_THRU;

    IF .BDB [BDB$L_VBN] EQL 1
    THEN
	FLAGS = .FLAGS	OR  RLS$M_KEEP_LOCK;

    RETURN_ON_ERROR (RM$RELEASE(.FLAGS),
	BEGIN
	IF .FAB [FAB$L_STV] EQL 0
	THEN
	    FAB [FAB$L_STV] = .STATUS OR 1^16;
	STATUS = RMSERR (WPL)
	END);
    END;				! end of FLAGS declaration

    RETURN RMSSUC();

    END;

END

ELUDOM
