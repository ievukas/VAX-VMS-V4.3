	.TITLE	IMAGECTRL - IMAGE CONTROL
	.IDENT	'V04-000'
 
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; IMAGE CONTROL DCLS COMMAND EXECUTION
;
;	CONTINUE IMAGE EXECUTION
;	DEBUG IMAGE EXECUTION
;	STOP IMAGE EXECUTION
;
; D. N. CUTLER 4-APR-77
;
; MODIFIED BY:
;
;	V03-006	HWS0071		Harold Schultz		04-Jun-1984
;		When finished with skipping data records in the input
;		stream of an image being run down, set EOL in the input
;		buffer following the last record read.
;
;	V03-005	HWS0036		Harold Schultz		21-Mar-1984
;		Use PRC_V_IRUNDWN to indicate whether or not an image
;		has been run down by DCL
;
;	V03-004	HWS0026		Harold Schultz		09-Mar-1984
;		When shutting down an image, check if device is a
;		record-oriented device rather than a terminal.
;
;	V03-003	PCG0005		Peter George		15-Jun-1983
;		Create DCL$RMSRUNDWN.
;
;	V03-002	PCG0004		Peter George		24-Feb-1983
;		Remove SETBIT WRK_V_NOSTAT from CONTINUE and STOP.
;
;	V03-001	PCG0003		Peter George		21-Jan-1983
;		Remove code that is duplicated in DCL$LOGOUT
;		from DCL$STOP.
;---

;
; MACRO LIBRARY CALLS
;
 
	$PPDDEF				;PROCESS PERMANENT DATA AREA
	PRCDEF				;DEFINE PROCESS WORK AREA
	WRKDEF				;DEFINE COMMAND WORK AREA
	PTRDEF				;DEFINE RESULT PARSE DESCRIPTOR FORMAT
	$DEVDEF				;DEFINE DEVICE CHARACTERISTIC BITS
	$PSLDEF				;DEFINE PROCESSOR STATUS FIELDS
	$RABDEF				;DEFINE RAB OFFSETS
	$SSDEF				;DEFINE SYSTEM STATUS VALUES
	$CLIMSGDEF			;DEFINE ERROR/STATUS VALUES
 
;
; LOCAL DATA
;
; HEX CONVERSION TABLE
;
 
	.PSECT	DCL$ZCODE,BYTE,RD,NOWRT
HEXTAB:	.ASCII	/FEDCBA9876543210/	;

	.SBTTL	CONTINUE IMAGE EXECUTION
;+
; DCL$CONTINUE - CONTINUE IMAGE EXECUTION
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO EXECUTE THE CONTINUE DCLS
; COMMAND.
;
; INPUTS:
;
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; OUTPUTS:
;
;	IF A PREVIOUS IMAGE WAS INTERRUPTED VIA A CONTROL Y AST, THEN THE
;	CURRENT COMMAND CONTEXT IS REMOVED FROM THE STACK AND CONTROL IS
;	RETURNED TO THE IMAGE. OTHERWISE THIS COMMAND IS A NOPERATION.
;-
 
	.ENABL	LSB
DCL$CONTINUE::				;CONTINUE IMAGE EXECUTION
	BSBW	TESTMODE		;TEST PREVIOUS MODE
	BBC	#PRC_V_PRIV,PRC_B_FLAGS2(R11),10$  ;BR IF UNPRIVILEGED IMAGE
	BSBW	RESTORE_PRIVS		;RESTORE IMAGE PRIVILEGE
10$:	RET				;

	.SBTTL	DEBUG IMAGE EXECUTION
;+
; DCL$DEBUG - DEBUG IMAGE EXECUTION
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO EXECUTE THE DEBUG DCLS
; COMMAND.
;
; INPUTS:
;
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; OUTPUTS:
;
;	IF A PREVIOUS IMAGE WAS INTERRUPTED VIA A CONTROL Y AST, THEN A
;	DEBUG EXCEPTION IS GENERATED FOR THE IMAGE. OTHERWISE THIS COMMAND
;	IS A NOPERATION.
;-
 
DCL$DEBUG::				;DEBUG IMAGE EXECUTION
	BSBW	TESTMODE		;TEST PREVIOUS MODE
	MOVAB	B^20$,16(FP)		;RESET AST RETURN ADDRESS
	ASHL	#PSL$V_PRVMOD,#<PSL$C_SUPER@2>! - ;CONSTRUCT PROPER PSL
		PSL$C_USER,-(SP)	;
	PUSHAB	10$			;SET PC
	REI				;
 
;
; CONTROL IS REGAINED AT THIS POINT WITH:
;
;	00(SP) = NUMBER OF AST ARGUMENTS (ALWAYS 5).
;	04(SP) = AST PARAMETER.
;	08(SP) = SAVED R0.
;	12(SP) = SAVED R1.
;	16(SP) = IMAGE PC.
;	20(SP) = IMAGE PSL.
;
 
20$:	ADDL	#8,SP			;REMOVE NUMBER OF ARGUMENTS AND PARAMETER
	POPR	#^M<R0,R1>		;RESTORE SAVED REGISTERS
	MOVZWL	#SS$_DEBUG,-(SP)	;SET EXCEPTION NAME
	PUSHL	#3			;SET NUMBER OF EXCEPTION ARGUMENTS
	JMP	@#EXE$REFLECT		;REFLECT EXCEPTION
	.DSABL	LSB

	.SBTTL	STOP IMAGE EXECUTION
;+
; DCL$STOP - STOP IMAGE EXECUTION
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO EXECUTE THE STOP DCLS
; COMMAND.
;
; INPUTS:
;
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; OUTPUTS:
;
;	IF A PROCESS NAME OR IDENTIFICATION IS SPECIFIED, THEN THAT PROCESS IS
;	DELETED.
;
;	IF THE JOB IS A NONINTERACTIVE JOB, THEN THE JOB IS LOGGED OFF THE SYSTEM
;	WITH A STATUS OF NORMAL COMPLETION. OTHERWISE ALL INDIRECT FILE LEVELS ARE
;	UNSTACKED AND A TEST IS MADE TO DETERMINE IF AN IMAGE WAS INTERRUPTED VIA
;	A CONTROL C/Y. IF A PREVIOUS IMAGE WAS INTERRUPTED, THEN THE CONTEXT OF THE
;	RUN COMMAND THAT INITIATED IMAGE EXECUTION IS REMOVED FROM THE STACK AND
;	RMS-32 IS CALLED TO CLOSE ALL OPEN IMAGE FILES. OTHERWISE NO OPERATION IS
;	PERFORMED.
;-
 
DCL$STOP::				;STOP IMAGE EXECUTION
	BSBW	DCL$GETDVAL		;GET DESCRIPTOR VALUES
	CMPL	#PTR_K_ENDLINE,R5	;END OF LINE?
	BNEQ	40$			;IF NEQ NO
10$:	TSTL	PRC_L_INDEPTH(R11)	;INDIRECT LEVEL ZERO?
	BEQL	20$			;IF EQL YES
	BSBW	DCL$UNSTACK		;UNSTACK INDIRECT LEVEL
	BRB	10$			;
20$:	BBC	#PRC_V_MODE,-		;IF SET, NONINTERACTIVE JOB
		PRC_W_FLAGS(R11),25$ 	;
	BRW	DCL$ABORT		;LOG PROCESS OUT
25$:	BSBW	TESTMODE		;TEST PREVIOUS MODE
	MOVL	WRK_L_SAVFP(R10),R10	;RESTORE SAVED WRK ADDRESS
	BSBW	DCL$SHUTDOWN		;CLOSE FILES OF PREVIOUS IMAGE
	CLRL	G^CTL$GL_CLINTOWN	;ZERO CLINT OWN STORAGE POINTER
	CLRL	G^CTL$GL_DCLPRSOWN	;ZERO DCL PARSE OWN STORAGE
	$RUNDWN_S #PSL$C_USER		;RUN DOWN PREVIOUS IMAGE
	BICB	#<PRC_M_EXEONLY ! PRC_M_PRIV>,- ;SINCE IMAGE IS NOW GONE
		PRC_B_FLAGS2(R11)	;NO NEED TO PROTECT IT
	CLRBIT	PRC_V_IRUNDWN,PRC_B_IMGFLAG(R11)  ;INDICATE THAT IMAGE IS RUNDOWN
	MOVL	R10,FP			;RESET FP SO YLEVEL WRK IS DEALLOCATED
					;ON RETURN TO DCL$RESTART.
	RSB				;

;
; DELETE PROCESS
;
 
40$:	CLRL	-(R9)			;CLEAR PROCESS IDENTIFICATION
	MOVL	R8,R7			;COPY ADDRESS OF SCRATCH DESCRIPTOR
	CMPL	#PTR_K_COMDQUAL,R5	;COMMAND QUALIFIER SPECIFIED?
	BNEQ	70$			;IF NEQ NO
	BSBW	DCL$GETDVAL		;GET VALUE PARAMETERS
	MOVQ	R1,R2			;SAVE VALUE PARAMETERS
50$:	DECL	R2			;ANY MORE CHARACTERS TO CONVERT?
	BLSS	60$			;IF LSS NO
	LOCC	(R3)+,#16,HEXTAB	;SEARCH FOR HEX CHARACTER MATCH
	BEQL	80$			;IF EQL VALUE SYNTAX ERROR
	MULL	#16,(R9)		;SCALE ACCUMULATED RESULT
	ADDL	R0,(R9)			;ADD IN NEXT DIGIT
	DECL	(R9)			;SUBTRACT OUT CHARACTER COUNT
	BRB	50$			;
60$:	BSBW	DCL$GETDVAL		;GET DESCRIPTOR VALUES
	CMPL	#PTR_K_ENDLINE,R5	;END OF LINE?
	BNEQ	70$			;IF NEQ NO
	CLRL	R7			;CLEAR DESCRIPTOR ADDRESS
70$:	MOVQ	R1,(R8)			;SAVE PROCESS NAME PARAMETERS
	$DELPRC_S (R9),(R7)		;DELETE PROCESS
	RSB				;
80$:	STATUS	IVVALU			;SET INVALID VALUE SYNTAX STATUS
	RSB				;

	.SBTTL	TEST PREVIOUS MODE
;
; SUBROUTINE TO TEST PREVIOUS MODE AND DISABLE CONTROL Y AST
;
 
TESTMODE:				;TEST PREVIOUS MODE
	SETBIT	PRC_V_DISABL,PRC_W_FLAGS(R11) ;DISABLE CONTROL Y AST
	BBCC	#PRC_V_YLEVEL,PRC_W_FLAGS(R11),10$ ;IF CLR, NOT AT CONTROL Y/C LEVEL
	BBC	#PSL$V_CURMOD,@PRC_L_SAVAP(R11),10$ ;IF CLR, PREVIOUS MODE SUPERVISOR
	MOVQ	WRK_L_SAVAP(R10),PRC_L_SAVAP(R11) ;RESTORE ARGUMENT AND FRAME POINTERS
	RSB				;
 
;
; PREVIOUS MODE SUPERVISOR
;
 
10$:	TSTL	(SP)+			;REMOVE RETURN FROM STACK
	STATUS	NORMAL			;SET COMPLETION STATUS
	RSB				;

	.SBTTL	SAVE/RESTORE IMAGE PRIVILEGES
;+
; DCL$SAVE_PRIVS - SAVE PRIVILEGED IMAGE PRIVILEGES
;		   SET IMAGE PRIVILEGES TO PROCESS PRIVILEGES
; RESTORE_PRIVS  - RESTORE PRIVILEGED IMAGE PRIVILEGES FROM
;		   SAVED COPY
;
; INPUTS:
;
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;	PRC_Q_SAVEPRIV(R11) - SAVED IMAGE PRIVILEGE TO BE USED BY
;		RESTORE_PRIVS
;
; OUTPUTS:
;
;	R0,R1,R2 DESTROYED OTHERS PRESERVED
;	PRC_Q_SAVEPRIV(R11) - PREVIOUS VALUE OF IMAGE PRIVILEGES
;-
DCL$SAVE_PRIVS::
	$SETPRV_S PRMFLG=#1,-	;READ PROCESS PERMANENT PRIVILEGES
		  PRVPRV=PRC_Q_SAVEPRIV(R11)
RESTORE_PRIVS:
	MNEGL	#1,-(SP)	;FORM MASK OF ALL PRIVS FOR DISABLE
	MNEGL	#1,-(SP)
	MOVAQ	-(SP),R2	;RESERVE 2ND MASK, R2 = ADR
	$SETPRV_S ENBFLG=#0,-	;DISABLE ALL PROCESS PRIVILEGES
		  PRVADR=8(R2),-
		  PRVPRV=(R2)	;SAVING OLD COPY
	$SETPRV_S ENBFLG=#1,-	;ENABLE THE SAVED PRIVILEGES
		  PRVADR=PRC_Q_SAVEPRIV(R11)
	MOVQ	(R2),PRC_Q_SAVEPRIV(R11) ;SAVE PREVIOUS PRIVILEGES
	ADDL	#16,SP		;CLEAN OFF 2 PRIV MASKS
	RSB

	.SBTTL	RUN DOWN IMAGE AND INDIRECT LEVELS
;+
; DCL$RUNDOWN - RUN DOWN IMAGE AND INDIRECT LEVELS
;
; THIS SUBROUTINE IS CALLED TO CHECK WHETHER INDIRECT LEVELS SHOULD BE RUN DOWN
; AND TO CLOSE RMS-32 FILES AND RUN DOWN THE PREVIOUS IMAGE.
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	IF THE CURRENT LEVEL IS CONTROL Y/C, THEN ALL INDIRECT FILES ARE UNSTACKED.
;	IF THE PREVIOUS MODE WAS USER, THEN THE USER IMAGE EXIT HANDLERS ARE
;	EXECUTED. THE PREVIOUS IMAGE IS ALWAYS RUNDOWN.
;-
	.ENABL	LSB
 
DCL$RUNDWNI::				;RUN DOWN BUT PRESERVE INDIRECT LEVEL
	MOVAB	B^20$,R0		;SET EXIT HANDLER RETURN ADDRESS
	BRB	5$			;
 
DCL$RUNDOWN::				;RUN DOWN IMAGE AND INDIRECT LEVELS
	MOVAB	B^10$,R0		;SET EXIT HANDLER RETURN ADDRESS
5$:	SETBIT	PRC_V_DISABL,PRC_W_FLAGS(R11) ;DISABLE CONTROL Y/C AST'S
	BBCC	#PRC_V_YLEVEL,PRC_W_FLAGS(R11),20$ ;IF CLR, NOT AT CONTROL Y/C LEVEL
	PUSHL	R0			;PUSH PROPER RETURN ADDRESS
	MOVL	PRC_L_SAVAP(R11),R0	;GET ADDRESS OF PREVIOUS PSL
	BBC	#PSL$V_CURMOD,(R0),10$	;IF CLR, PREVIOUS MODE SUPERVISOR
	BICB	#<PSL$M_FPD!PSL$M_TP!PSL$M_CM>@-24,3(R0) ; RESET BITS IN PSL
	MOVAB	@#EXE$EXIT_IMAGE,-(R0)	;RESET USER RETURN ADDRESS
	MOVZWL	#SS$_CLIFRCEXT,-8(R0)	;SET EXIT CAUSE INTO SAVED R0
	SUBL3	R10,SP,WRK_L_SAVSP(R10)	;SAVE RELATIVE ADDRESS OF TOP OF STACK
	MOVQ	WRK_L_SAVAP(R10),R8	;RETRIEVE PREVIOUS ARGUMENT AND FRAME POINTERS
	MOVQ	R8,PRC_L_SAVAP(R11)	;SAVE IN PROCESS WORK AREA
	SUBL	R10,WRK_L_RSLNXT(R10)	;CONVERT PARSE POINTER TO RELATIVE ADDRESS
	SUBL	R10,WRK_L_RSLEND(R10)	;CONVERT END POINTER TO RELATIVE ADDRESS
	MOVAB	8(R0),R7		;GET ADDRESS OF END OF ARGUMENT LIST + 4
	SUBL	FP,R7			;CALCULATE LENGTH OF CALL FRAME AND ARGLIST
	SUBL	R7,SP			;CALCULATE NEW TOP OF STACK ADDRESS
	MOVC	R7,(FP),(SP)		;MOVE CALL FRAME AND ARGUMENT LIST
	SUBL3	SP,FP,R7		;CALCULATE LENGTH OF COMMAND BUFFER AND ARGLISTS
	SUBL3	R7,R9,FP		;CALCULATE NEW TOP OF STACK ADDRESS
	MOVC	R7,(SP),(FP)		;COLLAPSE STACK REMOVING FIRST COMMAND CONTEXT
	ADDL	R9,WRK_L_SAVSP(R9)	;CALCULATE NEW COMMAND STACK POINTER
	ADDL	R9,WRK_L_RSLNXT(R9)	;CONVERT PARSE POINTER TO REAL ADDRESS
	ADDL	R9,WRK_L_RSLEND(R9)	;CONVERT END POINTER TO REAL ADDRESS
	RET				;RETURN TO EXE$EXIT_IMAGE
					;  THEN TO 10$ OR 20$
10$:	TSTL	PRC_L_INDEPTH(R11)	;INDIRECT LEVEL ZERO?
	BEQL	20$			;IF EQL YES
	BSBW	DCL$UNSTACK		;UNSTACK INDIRECT LEVEL
	BRB	10$			;
20$:	BBCC	#PRC_V_IRUNDWN,PRC_B_IMGFLAG(R11),30$ ;SKIP IF IMAGE ALREADY RUNDOWN
	$RUNDWN_S #PSL$C_USER		;RUN DOWN IMAGE (THE HARD WAY)
	BICB	#<PRC_M_EXEONLY ! PRC_M_PRIV>,- ;SINCE IMAGE IS NOW GONE
		PRC_B_FLAGS2(R11)	;NO NEED TO PROTECT IT
30$:	RSB				;
	.DSABL	LSB

	.SBTTL	SHUT DOWN IMAGE
;+
; DCL$SHUTDOWN - SHUT DOWM IMAGE
;
; THIS ROUTINE IS CALLED TO CLOSE ALL FILES OPENED BY THE JUST EXECUTED IMAGE
; AND TO CLOSE THE IMAGE ACTIVATION FILE.
;
; INPUTS:
;
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; OUTPUTS:
;
;	ALL FILES OPENED BY THE JUST EXECUTED IMAGE ARE CLOSED BY CALLING RMS-32,
;	DATA RECORDS ARE SKIPPED IN THE INPUT STREAM, AND THE IMAGE FILE IS CLOSED.
;	IF ANY DATA RECORDS ARE SKIPPED, THE INPUT BUFFER POINTER IS ADJUSTED
;	AND EOL SET FOR THE LAST RECORD READ (FOR POSSIBLE FUTURE DCL$FLUSH
;	OPERATION).
;
;		R4 DESTROYED
;		R2 = NUMBER OF DATA RECORDS SKIPPED IN THE INPUT STREAM.
;-
 
DCL$SHUTDOWN::					;SHUT DOWN IMAGE
	BSBB	DCL$RMSRUNDWN			;RUNDOWN RMS-32 FILES
	MOVL	PRC_L_INDINPRAB(R11),R3		;GET ADDRESS OF INDIRECT RAB
	MOVQ	RAB$W_RFA(R3),-(SP)		;SAVE RFA OF LAST COMMAND
	BBS	#DEV$V_REC,RAB$L_CTX(R3),30$ 	;IF SET, RECORD ORIENTED DEVICE
	BITB	#PRC_M_CHAIN!PRC_M_CMD,-	;CHAIN A/O COMMAND?
		PRC_B_FLAGS2(R11) 		;
	BNEQ	30$				;NO SKIP IF EITHER IS PENDING
	SETBIT	RAB$V_PPF_IND,RAB$W_ISI(R3) 	;CONVERT TO NONPRIVILEGED ISI
20$:	INCL	R2				;INCREMENT NUMBER OF RECORDS SKIPPED
	$GET	RAB=(R3)			;GET NEXT RECORD FROM INDIRECT FILE
	BLBC	R0,25$				;IF LBC FINISHED
	MOVZWL	RAB$W_RSZ(R3),R4		;SAVE LENGTH OF RECORD 
	BRB	20$

25$:	CLRBIT	RAB$V_PPF_IND,RAB$W_ISI(R3) 	;CONVERT BACK TO PRIVILEGED ISI
	DECL	R2				;ADJUST FOR LAST RECORD
	BEQL	30$				;SKIP IF NO RECORDS READ IN
	MOVAB	@RAB$L_RBF(R3)[R4],R4		;GET ADDR. OF END OF LAST RECORD
	CLRB	(R4)				;SET EOL IN BUFFER
	MOVAB	-1(R4),WRK_L_CHARPTR(R10)	;ADJUST 'GET CHARACTER' POINTER

30$:	MOVQ	(SP)+,RAB$W_RFA(R3)		;RESTORE RFA OF LAST COMMAND
	RSB					;
 

	.SBTTL	RMS RUNDOWN AN IMAGE
;+
; DCL$RMSRUNDWN - RMS RUNDOWN AN IMAGE
;
; THIS ROUTINE IS CALLED TO CLOSE ALL FILES OPENED BY THE JUST EXECUTED IMAGE
; AND TO CLOSE THE IMAGE ACTIVATION FILE.
;
; INPUTS:
;
;	NONE
;
; OUTPUTS:
;
;	ALL FILES OPENED BY THE JUST EXECUTED IMAGE ARE CLOSED BY CALLING RMS-32,
;	DATA RECORDS ARE SKIPPED IN THE INPUT STREAM, AND THE IMAGE FILE IS CLOSED.
;
;-
 
DCL$RMSRUNDWN::					;RMS RUNDOWN THE IMAGE
	BSBW	DCL$ALLOCBUF			;ALLOCATE BUFFER AND DESCRIPTOR
10$:	MOVZBL	#WRK_C_MSGBUFSIZ,(R2)		;RESET SIZE OF MESSAGE BUFFER
	PUSHL	#0				;RUN DOWN ONLY IMAGE FILES
	PUSHAB	(R2)				;SET ADDRESS OF MESSAGE BUFFER DESCRIPTOR
	CALLS	#2,@#SYS$RMSRUNDWN		;RUNDOWN RMS-32 FILES
	BLBC	R0,10$				;IF RUNDOWN FAILURE CONTINUE WITH NEXT FILE
	MOVAB	WRK_C_MSGBUFSIZ+8(SP),SP 	;DEALLOCATE MESSAGE BUFFER AND DESCRIPTOR
	CLRL	R2				;CLEAR COUNT OF RECORDS SKIPPED
	RSB					;RETURN

	.END
