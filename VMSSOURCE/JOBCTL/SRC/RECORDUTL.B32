MODULE RECORDUTL(%TITLE	'Queue record manipulation utilities'
		IDENT = 'V04-000'
		) =
BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY:
!	Job controller.
!
! ABSTRACT:
!	This module contains utility routines to manipulate queue records.
!
! ENVIRONMENT:
!	VAX/VMS user and kernel mode.
!--
!
! AUTHOR: M. Jack, CREATION DATE: 16-Feb-1982
!
! MODIFIED BY:
!
!	V03-010	JAK0228		J A Krycka	20-Aug-1984
!		Restrict total length of all parameter strings for a batch job.
!
!	V03-009	JAK0220		J A Krycka	18-Jul-1984
!		Support SJC$_PAGINATE at the queue level in addition to the
!		job and file levels.
!
!	V03-008	GRR0003		Gregory R. Robert	16-Sep-1983
!		Remove delete access check.
!
!	V03-007	GRR0002		Gregory R. Robert	09-Sep-1983
!		Make FIB non-local to repair asynchronous stack corruption.
!
!	V03-006	MLJ0118		Martin L. Jack,	23-Aug-1983
!		Change field name, implement page setup, fix file deletion bug.
!
!	V03-005	MLJ0115		Martin L. Jack,	30-Jul-1983
!		Changes for job controller baselevel.
!
!	V03-004	MLJ0114		Martin L. Jack,	23-Jun-1983
!		Split from QUEUEUTIL.
!
!	V03-003	MLJ0113		Martin L. Jack,	26-May-1983
!		Changes for job controller baselevel.
!
!	V03-002	MLJ0112		Martin L. Jack,	29-Apr-1983
!		Changes for job controller baselevel.
!
!	V03-001	MLJ0109		Martin L. Jack,	14-Apr-1983
!		Changes for job controller baselevel.
!
!**

REQUIRE 'SRC$:JOBCTLDEF';


FORWARD ROUTINE
	UPDATE_SFX_ENTRY:		NOVALUE,
	UPDATE_SQX_ENTRY:		NOVALUE,
	CREATE_SFM_RECORD:		L_OUTPUT_2,
	APPLY_SFM_OPTIONS,
	DELETE_SFM_RECORD:		NOVALUE,
	CREATE_SMQ_RECORD:		L_OUTPUT_2,
	APPLY_SMQ_OPTIONS,
	DELETE_SMQ_RECORD:		NOVALUE,
	CREATE_SJH_RECORD:		L_OUTPUT_2,
	APPLY_SJH_OPTIONS,
	DELETE_SJH_RECORD:		NOVALUE,
	CREATE_SQR_RECORD:		L_OUTPUT_2,
	APPLY_SQR_OPTIONS,
	DELETE_SQR_RECORD:		NOVALUE,
	DELETE_FILES:			NOVALUE,
	DELETE_ONE_FILE:		NOVALUE,
	DELETE_ONE_FILE_AST:		NOVALUE;


EXTERNAL ROUTINE
	ALLOCATE_ENTRY_NUMBER,
	ALLOCATE_MEMORY,
	ALLOCATE_RECORD:		L_OUTPUT_2,
	CREATE_SRQ_RECORD,
	DEALLOCATE_ENTRY_NUMBER:	NOVALUE,
	DEALLOCATE_MEMORY:		NOVALUE,
	DEALLOCATE_RECORD:		NOVALUE,
	DEALLOCATE_VARIABLE_DATA:	NOVALUE,
	LOCK_QUEUE_FILE:		NOVALUE,
	READ_RECORD,
	REWRITE_RECORD:			NOVALUE,
	SCAN_INCOMPLETE_SERVICES:	NOVALUE,
	SCHEDULE_NONAST:		NOVALUE,
	STORE_VARIABLE_DATA,
	STORE_VARIABLE_DATA_LIST,
	UNLOCK_QUEUE_FILE:		NOVALUE;


EXTERNAL
	SYS$GB_DEFPRI:		BYTE ADDRESSING_MODE(GENERAL),
	SYS$GB_DEFQUEPRI:	BYTE ADDRESSING_MODE(GENERAL);


BUILTIN
	LOCC,
	TESTBITSS;

GLOBAL ROUTINE UPDATE_SFX_ENTRY(SFE,SFM_N,SFM): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine updates an SFX entry from the corresponding SFM record.
!
! INPUT PARAMETERS:
!	SFE		- Pointer to SFX entry.
!	SFM_N		- Record number of SFM.
!	SFM		- Pointer to SFM.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	SFE:		REF BBLOCK,	! Pointer to SFX entry
	SFM:		REF BBLOCK;	! Pointer to SFM


CH$MOVE(SFM$S_NAME, SFM[SFM$T_NAME], SFE[SFX$T_NAME]);
SFE[SFX$L_FORM_LINK] = .SFM_N;
SFE[SFX$L_NUMBER] = .SFM[SFM$L_NUMBER];
END;

GLOBAL ROUTINE UPDATE_SQX_ENTRY(SQE,SMQ_N,SMQ): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine updates an SQX entry from the corresponding SMQ record.
!
! INPUT PARAMETERS:
!	SQE		- Pointer to SQX entry.
!	SMQ_N		- Record number of SMQ.
!	SMQ		- Pointer to SMQ.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	SQE:		REF BBLOCK,	! Pointer to SQX entry
	SMQ:		REF BBLOCK;	! Pointer to SMQ


CH$MOVE(SMQ$S_NAME, SMQ[SMQ$T_NAME], SQE[SQX$T_NAME]);
SQE[SQX$L_QUEUE_LINK] = .SMQ_N;
SQE[SQX$L_FLAGS] = 0;
IF .SMQ[SMQ$V_BATCH]
    THEN SQE[SQX$V_BATCH] = TRUE;
IF NOT .SMQ[SMQ$V_GENERIC_QUEUE] AND .SMQ[SMQ$L_ASSIGNED_QUEUE_LINK] EQL 0
    THEN SQE[SQX$V_EXECUTOR] = TRUE;
IF .SMQ[SMQ$V_GENERIC_SELECTION]
    THEN SQE[SQX$V_GENERIC_SELECTION] = TRUE;
END;

GLOBAL ROUTINE CREATE_SFM_RECORD(;SFM_N,SFM): L_OUTPUT_2=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine allocates and initializes a form definition record.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	SFM_N		- Record number of SFM.
!	SFM		- Pointer to SFM.
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Completion status.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	SFM:		REF BBLOCK;	! Pointer to SFM
LOCAL
	STATUS;				! Status return


! Allocate the queue record, and return if no more.
!
STATUS = ALLOCATE_RECORD( ; SFM_N, SFM);
IF NOT .STATUS THEN RETURN .STATUS;


! Initialize the form definition record.
!
SFM[SYM$B_TYPE] = SYM$K_SFM;
CH$WCHAR(
    .VALUE_FORM_NAME[SDSC_W_LENGTH],
    SFM[SFM$T_NAME]);
CH$COPY(
    .VALUE_FORM_NAME[SDSC_W_LENGTH],
    .VALUE_FORM_NAME[SDSC_A_POINTER],
    0,
    SFM$S_NAME-1,
    SFM[SFM$T_NAME]+1);
CH$COPY(
    SFM$S_NAME, SFM[SFM$T_NAME],
    0,
    SFM$S_DESCRIPTION, SFM[SFM$T_DESCRIPTION]);
CH$MOVE(SFM$S_NAME, SFM[SFM$T_NAME], SFM[SFM$T_STOCK]);
SFM[SFM$L_NUMBER] = .VALUE_FORM_NUMBER;
SFM[SFM$B_LENGTH] = 66;
SFM[SFM$W_WIDTH] = 132;
SFM[SFM$B_MARGIN_BOTTOM] = 6;
SFM[SFM$V_TRUNCATE] = TRUE;


SS$_NORMAL
END;

GLOBAL ROUTINE APPLY_SFM_OPTIONS(SFM)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine applies options to a form definition record.
!
! INPUT PARAMETERS:
!	SFM		- Pointer to SFM.
!
! IMPLICIT INPUTS:
!	Existing values in SFM.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	New values in SFM.
!
! ROUTINE VALUE:
!	Completion status.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	SFM:		REF BBLOCK;	! Pointer to SFM
LOCAL
	LSFM:		BBLOCK[SYM$S_SYM],	! Saved copy of original SFM
	FINAL_STATUS;				! Final routine status
LABEL
	PROTECTED_UPDATE;


! Set up for backing out the transaction in case of an error.
!
CH$MOVE(SYM$S_SYM, .SFM, LSFM);
CH$FILL(0, SFM$S_FORM_SETUP_MODULES, SFM[SFM$T_FORM_SETUP_MODULES]);
CH$FILL(0, SFM$S_PAGE_SETUP_MODULES, SFM[SFM$T_PAGE_SETUP_MODULES]);
FINAL_STATUS = SS$_NORMAL;
PROTECTED_UPDATE:  BEGIN


IF .ITEM_PRESENT[SJC$_FORM_DESCRIPTION]
THEN
    BEGIN
    CH$WCHAR(
	.VALUE_FORM_DESCRIPTION[SDSC_W_LENGTH],
	SFM[SFM$T_DESCRIPTION]);
    CH$COPY(
	.VALUE_FORM_DESCRIPTION[SDSC_W_LENGTH],
	.VALUE_FORM_DESCRIPTION[SDSC_A_POINTER],
	0,
	SFM$S_DESCRIPTION-1,
	SFM[SFM$T_DESCRIPTION]+1);
    END;


IF .ITEM_PRESENT[SJC$_FORM_LENGTH]
THEN
    SFM[SFM$B_LENGTH] = .VALUE_FORM_LENGTH;


IF .ITEM_PRESENT[SJC$_FORM_MARGIN_BOTTOM]
THEN
    SFM[SFM$B_MARGIN_BOTTOM] = .VALUE_FORM_MARGIN_BOTTOM;


IF .ITEM_PRESENT[SJC$_FORM_MARGIN_LEFT]
THEN
    SFM[SFM$W_MARGIN_LEFT] = .VALUE_FORM_MARGIN_LEFT;


IF .ITEM_PRESENT[SJC$_FORM_MARGIN_RIGHT]
THEN
    SFM[SFM$W_MARGIN_RIGHT] = .VALUE_FORM_MARGIN_RIGHT;


IF .ITEM_PRESENT[SJC$_FORM_MARGIN_TOP]
THEN
    SFM[SFM$B_MARGIN_TOP] = .VALUE_FORM_MARGIN_TOP;


IF .ITEM_PRESENT[SJC$_FORM_NUMBER]
THEN
    SFM[SFM$L_NUMBER] = .VALUE_FORM_NUMBER;


IF .ITEM_PRESENT[SJC$_FORM_SETUP_MODULES]
THEN
    BEGIN
    FINAL_STATUS = STORE_VARIABLE_DATA(
	.SFM,
	SFM$S_FORM_SETUP_MODULES,
	SFM[SFM$T_FORM_SETUP_MODULES],
	SYM$K_FORM_SETUP_MODULES,
	.VALUE_FORM_SETUP_MODULES[SDSC_W_LENGTH],
	.VALUE_FORM_SETUP_MODULES[SDSC_A_POINTER]);
    IF NOT .FINAL_STATUS THEN LEAVE PROTECTED_UPDATE;
    END;


IF .ITEM_PRESENT[SJC$_FORM_SHEET_FEED]
THEN
    SFM[SFM$V_SHEET_FEED] = TRUE;


IF .ITEM_PRESENT[SJC$_NO_FORM_SHEET_FEED]
THEN
    SFM[SFM$V_SHEET_FEED] = FALSE;


IF .ITEM_PRESENT[SJC$_FORM_STOCK]
THEN
    BEGIN
    CH$WCHAR(
	.VALUE_FORM_STOCK[SDSC_W_LENGTH],
	SFM[SFM$T_STOCK]);
    CH$COPY(
	.VALUE_FORM_STOCK[SDSC_W_LENGTH],
	.VALUE_FORM_STOCK[SDSC_A_POINTER],
	0,
	SFM$S_STOCK-1,
	SFM[SFM$T_STOCK]+1);
    END;


IF .ITEM_PRESENT[SJC$_FORM_TRUNCATE]
THEN
    BEGIN
    SFM[SFM$V_TRUNCATE] = TRUE;
    SFM[SFM$V_WRAP] = FALSE;
    END;


IF .ITEM_PRESENT[SJC$_NO_FORM_TRUNCATE]
THEN
    SFM[SFM$V_TRUNCATE] = FALSE;


IF .ITEM_PRESENT[SJC$_FORM_WIDTH]
THEN
    SFM[SFM$W_WIDTH] = .VALUE_FORM_WIDTH;


IF .ITEM_PRESENT[SJC$_FORM_WRAP]
THEN
    BEGIN
    SFM[SFM$V_TRUNCATE] = FALSE;
    SFM[SFM$V_WRAP] = TRUE;
    END;


IF .ITEM_PRESENT[SJC$_NO_FORM_WRAP]
THEN
    SFM[SFM$V_WRAP] = FALSE;


IF .ITEM_PRESENT[SJC$_PAGE_SETUP_MODULES]
THEN
    BEGIN
    FINAL_STATUS = STORE_VARIABLE_DATA(
	.SFM,
	SFM$S_PAGE_SETUP_MODULES,
	SFM[SFM$T_PAGE_SETUP_MODULES],
	SYM$K_PAGE_SETUP_MODULES,
	.VALUE_PAGE_SETUP_MODULES[SDSC_W_LENGTH],
	.VALUE_PAGE_SETUP_MODULES[SDSC_A_POINTER]);
    IF NOT .FINAL_STATUS THEN LEAVE PROTECTED_UPDATE;
    END;


IF .SFM[SFM$W_MARGIN_LEFT] + .SFM[SFM$W_MARGIN_RIGHT] GEQU .SFM[SFM$W_WIDTH]
OR .SFM[SFM$B_MARGIN_TOP] + .SFM[SFM$B_MARGIN_BOTTOM] GEQU .SFM[SFM$B_LENGTH]
THEN
    BEGIN
    FINAL_STATUS = JBC$_INCFORMPAR;
    LEAVE PROTECTED_UPDATE;
    END;

    
END;	! block PROTECTED_UPDATE


IF .FINAL_STATUS
THEN
    BEGIN
    IF .ITEM_PRESENT[SJC$_FORM_SETUP_MODULES]
    OR .ITEM_PRESENT[SJC$_NO_FORM_SETUP_MODULES]
    THEN
	DEALLOCATE_VARIABLE_DATA(
	    SFM$S_FORM_SETUP_MODULES,
	    LSFM[SFM$T_FORM_SETUP_MODULES])
    ELSE
	CH$MOVE(
	    SFM$S_FORM_SETUP_MODULES,
	    LSFM[SFM$T_FORM_SETUP_MODULES],
	    SFM[SFM$T_FORM_SETUP_MODULES]);


    IF .ITEM_PRESENT[SJC$_PAGE_SETUP_MODULES]
    OR .ITEM_PRESENT[SJC$_NO_PAGE_SETUP_MODULES]
    THEN
	DEALLOCATE_VARIABLE_DATA(
	    SFM$S_PAGE_SETUP_MODULES,
	    LSFM[SFM$T_PAGE_SETUP_MODULES])
    ELSE
	CH$MOVE(
	    SFM$S_PAGE_SETUP_MODULES,
	    LSFM[SFM$T_PAGE_SETUP_MODULES],
	    SFM[SFM$T_PAGE_SETUP_MODULES]);
    END
ELSE
    BEGIN
    DEALLOCATE_VARIABLE_DATA(
	SFM$S_FORM_SETUP_MODULES,
	SFM[SFM$T_FORM_SETUP_MODULES]);
    DEALLOCATE_VARIABLE_DATA(
	SFM$S_PAGE_SETUP_MODULES,
	SFM[SFM$T_PAGE_SETUP_MODULES]);
    CH$MOVE(SYM$S_SYM, LSFM, .SFM);
    END;


.FINAL_STATUS
END;

GLOBAL ROUTINE DELETE_SFM_RECORD(SFM_N,SFM): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine deallocates a form definition record and its substructures.
!
! INPUT PARAMETERS:
!	SFM_N		- Record number of SFM.
!	SFM		- Pointer to SFM.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	SFM:		REF BBLOCK;	! Pointer to SFM


! Deallocate the fixed/variable data areas, if they exist.
!
DEALLOCATE_VARIABLE_DATA(
    SFM$S_FORM_SETUP_MODULES,
    SFM[SFM$T_FORM_SETUP_MODULES]);
DEALLOCATE_VARIABLE_DATA(
    SFM$S_PAGE_SETUP_MODULES,
    SFM[SFM$T_PAGE_SETUP_MODULES]);


! Deallocate the form definition record.
!
DEALLOCATE_RECORD(.SFM_N);
END;

GLOBAL ROUTINE CREATE_SMQ_RECORD(;SMQ_N,SMQ): L_OUTPUT_2=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine allocates and initializes a queue header record.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	SMQ_N		- Record number of SMQ.
!	SMQ		- Pointer to SMQ.
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Completion status.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	SMQ:		REF BBLOCK;
LOCAL
	STATUS;


! Allocate the queue record, and return if no more.
!
STATUS = ALLOCATE_RECORD( ; SMQ_N, SMQ);
IF NOT .STATUS THEN RETURN .STATUS;


! Initialize the queue header record.
!
SMQ[SYM$B_TYPE] = SYM$K_SMQ;
SMQ[SMQ$V_GENERIC_SELECTION] = TRUE;
SMQ[SMQ$V_JOB_SIZE_SCHEDULING] = TRUE;
SMQ[SMQ$V_PAGINATE] = TRUE;
SMQ[SMQ$V_STOPPED] = TRUE;
SMQ[SMQ$V_SWAP] = TRUE;
CH$WCHAR(
    .VALUE_QUEUE[SDSC_W_LENGTH],
    SMQ[SMQ$T_NAME]);
CH$COPY(
    .VALUE_QUEUE[SDSC_W_LENGTH],
    .VALUE_QUEUE[SDSC_A_POINTER],
    0,
    SMQ$S_NAME-1, SMQ[SMQ$T_NAME]+1);
SMQ[SMQ$L_OWNER_UIC] = .JBC_UIC;
SMQ[SMQ$W_PROTECTION] = %B'1101111001111011'; ! S:E, O:D, G:R, W:W
SMQ[SMQ$B_JOB_LIMIT] = 1;
SMQ[SMQ$B_BASE_PRIORITY] = .SYS$GB_DEFPRI;


SS$_NORMAL
END;

GLOBAL ROUTINE APPLY_SMQ_OPTIONS(SMQ)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine applies options to a queue header record.
!
! INPUT PARAMETERS:
!	SMQ		- Pointer to SMQ.
!
! IMPLICIT INPUTS:
!	Existing values in SMQ.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	New values in SMQ.
!
! ROUTINE VALUE:
!	Completion status.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	SMQ:		REF BBLOCK;		! Pointer to SMQ
LOCAL
	LSMQ:		BBLOCK[SYM$S_SYM],	! Saved copy of original SMQ
	FINAL_STATUS;				! Final routine status
LABEL
	PROTECTED_UPDATE;


! Set up for backing out the transaction in case of an error.
!
CH$MOVE(SYM$S_SYM, .SMQ, LSMQ);
CH$FILL(0, SMQ$S_JOB_RESET_MODULES, SMQ[SMQ$T_JOB_RESET_MODULES]);
SMQ[SMQ$L_GENERIC_TARGET] = 0;
FINAL_STATUS = SS$_NORMAL;
PROTECTED_UPDATE:  BEGIN


IF TESTBITSS(SMQ[SMQ$V_BATCH_EXPLICIT])
THEN
    IF (.ITEM_PRESENT[SJC$_BATCH] AND NOT .SMQ[SMQ$V_BATCH])
    OR (.ITEM_PRESENT[SJC$_NO_BATCH] AND .SMQ[SMQ$V_BATCH])
    THEN
	RETURN JBC$_INCQUETYP;


IF .ITEM_PRESENT[SJC$_BASE_PRIORITY]
THEN
    SMQ[SMQ$B_BASE_PRIORITY] = .VALUE_BASE_PRIORITY;


IF .ITEM_PRESENT[SJC$_BATCH]
THEN
    SMQ[SMQ$V_BATCH] = TRUE;


IF .ITEM_PRESENT[SJC$_CHARACTERISTIC_NAME]
OR .ITEM_PRESENT[SJC$_CHARACTERISTIC_NUMBER]
THEN
    CH$MOVE(
	SMQ$S_CHARACTERISTICS,
	VALUE_CHARACTERISTICS,
	SMQ[SMQ$T_CHARACTERISTICS]);


IF .ITEM_PRESENT[SJC$_NO_CHARACTERISTICS]
THEN
    CH$FILL(
	0,
	SMQ$S_CHARACTERISTICS,
	SMQ[SMQ$T_CHARACTERISTICS]);


IF .ITEM_PRESENT[SJC$_GENERIC_SELECTION]
THEN
    SMQ[SMQ$V_GENERIC_SELECTION] = TRUE;


IF .ITEM_PRESENT[SJC$_NO_GENERIC_SELECTION]
THEN
    SMQ[SMQ$V_GENERIC_SELECTION] = FALSE;


IF .ITEM_PRESENT[SJC$_GENERIC_QUEUE]
THEN
    SMQ[SMQ$V_GENERIC_QUEUE] = TRUE;


IF .ITEM_PRESENT[SJC$_NO_GENERIC_QUEUE]
THEN
    SMQ[SMQ$V_GENERIC_QUEUE] = FALSE;


IF .ITEM_PRESENT[SJC$_GENERIC_TARGET]
THEN
    BEGIN
    LOCAL
	P:		REF VECTOR,	! Pointer to generic target value
	AUX_N,				! Record number of auxiliary record
	AUX:		REF BBLOCK;	! Pointer to auxiliary record


    FINAL_STATUS = ALLOCATE_RECORD( ; AUX_N, AUX);
    IF NOT .FINAL_STATUS THEN LEAVE PROTECTED_UPDATE;
    SMQ[SMQ$L_GENERIC_TARGET] = .AUX_N;


    AUX[SYM$B_TYPE] = SYM$K_GENERIC_TARGET;
    VECTOR[AUX[SYM$T_DATA], 0] = .VALUE_GENERIC_TARGET[0];
    P = VALUE_GENERIC_TARGET[1] + 8 * (.VALUE_GENERIC_TARGET[0] - 1);
    INCR I FROM 1 TO .VALUE_GENERIC_TARGET[0] DO
	BEGIN
	LOCAL
	    TSMQ:	REF BBLOCK;	! Pointer to generic target SMQ

	TSMQ = .P[1];
	IF .SMQ[SMQ$V_BATCH] NEQ .TSMQ[SMQ$V_BATCH]
	OR .TSMQ[SMQ$V_GENERIC_QUEUE]
	OR .TSMQ[SMQ$L_ASSIGNED_QUEUE_LINK] NEQ 0
	THEN
	    BEGIN
	    FINAL_STATUS = JBC$_INCDSTQUE;
	    LEAVE PROTECTED_UPDATE;
	    END;
	VECTOR[AUX[SYM$T_DATA], .I] = .P[0];
	P = .P - 8;
	END;
    REWRITE_RECORD(.AUX_N);
    END;


IF .ITEM_PRESENT[SJC$_OWNER_UIC]
THEN
    SMQ[SMQ$L_OWNER_UIC] = .VALUE_OWNER_UIC;


IF .ITEM_PRESENT[SJC$_PROTECTION]
THEN
    SMQ[SMQ$W_PROTECTION] =
	(.SMQ[SMQ$W_PROTECTION] AND NOT .VALUE_PROTECTION<16,16>) OR
	(.VALUE_PROTECTION<0,16> AND .VALUE_PROTECTION<16,16>);


IF .ITEM_PRESENT[SJC$_RETAIN_ALL_JOBS]
THEN
    BEGIN
    SMQ[SMQ$V_RETAIN_ALL_JOBS] = TRUE;
    SMQ[SMQ$V_RETAIN_ERROR_JOBS] = FALSE;
    END;


IF .ITEM_PRESENT[SJC$_RETAIN_ERROR_JOBS]
THEN
    BEGIN
    SMQ[SMQ$V_RETAIN_ALL_JOBS] = FALSE;
    SMQ[SMQ$V_RETAIN_ERROR_JOBS] = TRUE;
    END;


IF .ITEM_PRESENT[SJC$_NO_RETAIN_JOBS]
THEN
    BEGIN
    SMQ[SMQ$V_RETAIN_ALL_JOBS] = FALSE;
    SMQ[SMQ$V_RETAIN_ERROR_JOBS] = FALSE;
    END;


IF .ITEM_PRESENT[SJC$_SCSNODE_NAME]
THEN
    COPY_SYSID(VALUE_SCSNODE_NAME, SMQ[SMQ$T_SYSID]);


IF .SMQ[SMQ$V_BATCH]
THEN
    BEGIN
    IF .ITEM_PRESENT[SJC$_CPU_DEFAULT]
    THEN
	BEGIN
	SMQ[SMQ$V_CPU_DEFAULT] = TRUE;
	SMQ[SMQ$L_CPU_DEFAULT] = .VALUE_CPU_DEFAULT;
	END;


    IF .ITEM_PRESENT[SJC$_NO_CPU_DEFAULT]
    THEN
	BEGIN
	SMQ[SMQ$V_CPU_DEFAULT] = FALSE;
	SMQ[SMQ$L_CPU_DEFAULT] = 0;
	END;


    IF .ITEM_PRESENT[SJC$_CPU_LIMIT]
    THEN
	BEGIN
	SMQ[SMQ$V_CPU_MAXIMUM] = TRUE;
	SMQ[SMQ$L_CPU_MAXIMUM] = .VALUE_CPU_LIMIT;
	END;


    IF .ITEM_PRESENT[SJC$_NO_CPU_LIMIT]
    THEN
	BEGIN
	SMQ[SMQ$V_CPU_MAXIMUM] = FALSE;
	SMQ[SMQ$L_CPU_MAXIMUM] = 0;
	END;


    IF .ITEM_PRESENT[SJC$_JOB_LIMIT]
    THEN
	SMQ[SMQ$B_JOB_LIMIT] = .VALUE_JOB_LIMIT;


    IF .ITEM_PRESENT[SJC$_SWAP]
    THEN
	SMQ[SMQ$V_SWAP] = TRUE;


    IF .ITEM_PRESENT[SJC$_NO_SWAP]
    THEN
	SMQ[SMQ$V_SWAP] = FALSE;


    IF .ITEM_PRESENT[SJC$_WSDEFAULT]
    THEN
	BEGIN
	SMQ[SMQ$V_WSDEFAULT] = TRUE;
	SMQ[SMQ$W_WSDEFAULT] = .VALUE_WSDEFAULT;
	END;


    IF .ITEM_PRESENT[SJC$_NO_WSDEFAULT]
    THEN
	BEGIN
	SMQ[SMQ$V_WSDEFAULT] = FALSE;
	SMQ[SMQ$W_WSDEFAULT] = 0;
	END;


    IF .ITEM_PRESENT[SJC$_WSEXTENT]
    THEN
	BEGIN
	SMQ[SMQ$V_WSEXTENT] = TRUE;
	SMQ[SMQ$W_WSEXTENT] = .VALUE_WSEXTENT;
	END;


    IF .ITEM_PRESENT[SJC$_NO_WSEXTENT]
    THEN
	BEGIN
	SMQ[SMQ$V_WSEXTENT] = FALSE;
	SMQ[SMQ$W_WSEXTENT] = 0;
	END;


    IF .ITEM_PRESENT[SJC$_WSQUOTA]
    THEN
	BEGIN
	SMQ[SMQ$V_WSQUOTA] = TRUE;
	SMQ[SMQ$W_WSQUOTA] = .VALUE_WSQUOTA;
	END;


    IF .ITEM_PRESENT[SJC$_NO_WSQUOTA]
    THEN
	BEGIN
	SMQ[SMQ$V_WSQUOTA] = FALSE;
	SMQ[SMQ$W_WSQUOTA] = 0;
	END;


    IF .SMQ[SMQ$V_CPU_MAXIMUM] AND .SMQ[SMQ$V_CPU_DEFAULT]
    AND .SMQ[SMQ$L_CPU_MAXIMUM] - 1 LSSU .SMQ[SMQ$L_CPU_DEFAULT] - 1
    THEN
	SMQ[SMQ$L_CPU_DEFAULT] = .SMQ[SMQ$L_CPU_MAXIMUM];


    IF .SMQ[SMQ$V_WSEXTENT] AND .SMQ[SMQ$V_WSQUOTA]
    AND .SMQ[SMQ$W_WSEXTENT] LSSU .SMQ[SMQ$W_WSQUOTA]
    THEN
	SMQ[SMQ$W_WSQUOTA] = .SMQ[SMQ$W_WSEXTENT];


    IF .SMQ[SMQ$V_WSQUOTA] AND .SMQ[SMQ$V_WSDEFAULT]
    AND .SMQ[SMQ$W_WSQUOTA] LSSU .SMQ[SMQ$W_WSDEFAULT]
    THEN
	SMQ[SMQ$W_WSDEFAULT] = .SMQ[SMQ$W_WSQUOTA];


    IF .SMQ[SMQ$V_WSEXTENT] AND .SMQ[SMQ$V_WSDEFAULT]
    AND .SMQ[SMQ$W_WSEXTENT] LSSU .SMQ[SMQ$W_WSDEFAULT]
    THEN
	SMQ[SMQ$W_WSDEFAULT] = .SMQ[SMQ$W_WSEXTENT];
    END
ELSE
    BEGIN
    IF .ITEM_PRESENT[SJC$_DEVICE_NAME]
    THEN
	BEGIN
	CH$WCHAR(
	    .VALUE_DEVICE_NAME[SDSC_W_LENGTH],
	    SMQ[SMQ$T_DEVICE_NAME]);
	CH$COPY(
	    .VALUE_DEVICE_NAME[SDSC_W_LENGTH],
	    .VALUE_DEVICE_NAME[SDSC_A_POINTER],
	    0,
	    SMQ$S_DEVICE_NAME-1,
	    SMQ[SMQ$T_DEVICE_NAME]+1);
	END;


    IF .ITEM_PRESENT[SJC$_FILE_BURST]
    THEN
	BEGIN
	SMQ[SMQ$V_FILE_BURST] = TRUE;
	SMQ[SMQ$V_FILE_BURST_ONE] = FALSE;
	END;


    IF .ITEM_PRESENT[SJC$_FILE_BURST_ONE]
    THEN
	BEGIN
	SMQ[SMQ$V_FILE_BURST] = FALSE;
	SMQ[SMQ$V_FILE_BURST_ONE] = TRUE;
	END;


    IF .ITEM_PRESENT[SJC$_NO_FILE_BURST]
    THEN
	BEGIN
	SMQ[SMQ$V_FILE_BURST] = FALSE;
	SMQ[SMQ$V_FILE_BURST_ONE] = FALSE;
	END;


    IF .ITEM_PRESENT[SJC$_FILE_FLAG]
    THEN
	BEGIN
	SMQ[SMQ$V_FILE_FLAG] = TRUE;
	SMQ[SMQ$V_FILE_FLAG_ONE] = FALSE;
	END;


    IF .ITEM_PRESENT[SJC$_FILE_FLAG_ONE]
    THEN
	BEGIN
	SMQ[SMQ$V_FILE_FLAG] = FALSE;
	SMQ[SMQ$V_FILE_FLAG_ONE] = TRUE;
	END;


    IF .ITEM_PRESENT[SJC$_NO_FILE_FLAG]
    THEN
	BEGIN
	SMQ[SMQ$V_FILE_FLAG] = FALSE;
	SMQ[SMQ$V_FILE_FLAG_ONE] = FALSE;
	END;


    IF .ITEM_PRESENT[SJC$_FILE_TRAILER]
    THEN
	BEGIN
	SMQ[SMQ$V_FILE_TRAILER] = TRUE;
	SMQ[SMQ$V_FILE_TRAILER_ONE] = FALSE;
	END;


    IF .ITEM_PRESENT[SJC$_FILE_TRAILER_ONE]
    THEN
	BEGIN
	SMQ[SMQ$V_FILE_TRAILER] = FALSE;
	SMQ[SMQ$V_FILE_TRAILER_ONE] = TRUE;
	END;


    IF .ITEM_PRESENT[SJC$_NO_FILE_TRAILER]
    THEN
	BEGIN
	SMQ[SMQ$V_FILE_TRAILER] = FALSE;
	SMQ[SMQ$V_FILE_TRAILER_ONE] = FALSE;
	END;


    IF .ITEM_PRESENT[SJC$_FORM_NAME]
    OR .ITEM_PRESENT[SJC$_FORM_NUMBER]
    THEN
	SMQ[SMQ$L_FORM_LINK] = .VALUE_FORM[0];


    IF .ITEM_PRESENT[SJC$_JOB_BURST]
    THEN
	SMQ[SMQ$V_JOB_BURST] = TRUE;


    IF .ITEM_PRESENT[SJC$_NO_JOB_BURST]
    THEN
	SMQ[SMQ$V_JOB_BURST] = FALSE;


    IF .ITEM_PRESENT[SJC$_JOB_FLAG]
    THEN
	SMQ[SMQ$V_JOB_FLAG] = TRUE;


    IF .ITEM_PRESENT[SJC$_NO_JOB_FLAG]
    THEN
	SMQ[SMQ$V_JOB_FLAG] = FALSE;


    IF .ITEM_PRESENT[SJC$_JOB_RESET_MODULES]
    THEN
	BEGIN
	FINAL_STATUS = STORE_VARIABLE_DATA(
	    .SMQ,
	    SMQ$S_JOB_RESET_MODULES,
	    SMQ[SMQ$T_JOB_RESET_MODULES],
	    SYM$K_JOB_RESET_MODULES,
	    .VALUE_JOB_RESET_MODULES[SDSC_W_LENGTH],
	    .VALUE_JOB_RESET_MODULES[SDSC_A_POINTER]);
	IF NOT .FINAL_STATUS THEN LEAVE PROTECTED_UPDATE;
	END;


    IF .ITEM_PRESENT[SJC$_JOB_SIZE_MAXIMUM]
    THEN
	SMQ[SMQ$L_JOB_SIZE_MAXIMUM] = .VALUE_JOB_SIZE_MAXIMUM;


    IF .ITEM_PRESENT[SJC$_NO_JOB_SIZE_MAXIMUM]
    THEN
	SMQ[SMQ$L_JOB_SIZE_MAXIMUM] = 0;


    IF .ITEM_PRESENT[SJC$_JOB_SIZE_MINIMUM]
    THEN
	SMQ[SMQ$L_JOB_SIZE_MINIMUM] = .VALUE_JOB_SIZE_MINIMUM;


    IF .ITEM_PRESENT[SJC$_NO_JOB_SIZE_MINIMUM]
    THEN
	SMQ[SMQ$L_JOB_SIZE_MINIMUM] = 0;


    IF .ITEM_PRESENT[SJC$_JOB_SIZE_SCHEDULING]
    THEN
	SMQ[SMQ$V_JOB_SIZE_SCHEDULING] = TRUE;


    IF .ITEM_PRESENT[SJC$_NO_JOB_SIZE_SCHEDULING]
    THEN
	SMQ[SMQ$V_JOB_SIZE_SCHEDULING] = FALSE;


    IF .ITEM_PRESENT[SJC$_JOB_TRAILER]
    THEN
	SMQ[SMQ$V_JOB_TRAILER] = TRUE;


    IF .ITEM_PRESENT[SJC$_NO_JOB_TRAILER]
    THEN
	SMQ[SMQ$V_JOB_TRAILER] = FALSE;


    IF .ITEM_PRESENT[SJC$_LIBRARY_SPECIFICATION]
    THEN
	BEGIN
	CH$WCHAR(
	    .VALUE_LIBRARY_SPECIFICATION[SDSC_W_LENGTH],
	    SMQ[SMQ$T_LIBRARY]);
	CH$COPY(
	    .VALUE_LIBRARY_SPECIFICATION[SDSC_W_LENGTH],
	    .VALUE_LIBRARY_SPECIFICATION[SDSC_A_POINTER],
	    0,
	    SMQ$S_LIBRARY-1,
	    SMQ[SMQ$T_LIBRARY]+1);
	END;


    IF .ITEM_PRESENT[SJC$_NO_LIBRARY_SPECIFICATION]
    THEN
	CH$FILL(
	    0,
	    SMQ$S_LIBRARY,
	    SMQ[SMQ$T_LIBRARY]);


    IF .ITEM_PRESENT[SJC$_PAGINATE]
    THEN
	SMQ[SMQ$V_PAGINATE] = TRUE;


    IF .ITEM_PRESENT[SJC$_NO_PAGINATE]
    THEN
	SMQ[SMQ$V_PAGINATE] = FALSE;


    IF .ITEM_PRESENT[SJC$_PROCESSOR]
    THEN
	BEGIN
	CH$WCHAR(
	    .VALUE_PROCESSOR[SDSC_W_LENGTH],
	    SMQ[SMQ$T_PROCESSOR]);
	CH$COPY(
	    .VALUE_PROCESSOR[SDSC_W_LENGTH],
	    .VALUE_PROCESSOR[SDSC_A_POINTER],
	    0,
	    SMQ$S_PROCESSOR-1,
	    SMQ[SMQ$T_PROCESSOR]+1);
	END;


    IF .ITEM_PRESENT[SJC$_NO_PROCESSOR]
    THEN
	CH$FILL(
	    0,
	    SMQ$S_PROCESSOR,
	    SMQ[SMQ$T_PROCESSOR]);


    IF .ITEM_PRESENT[SJC$_TERMINAL]
    THEN
	SMQ[SMQ$V_TERMINAL] = TRUE;


    IF .ITEM_PRESENT[SJC$_NO_TERMINAL]
    THEN
	SMQ[SMQ$V_TERMINAL] = FALSE;
    END;


END;	! block PROTECTED_UPDATE


IF .FINAL_STATUS
THEN
    BEGIN
    IF .ITEM_PRESENT[SJC$_GENERIC_QUEUE]
    OR .ITEM_PRESENT[SJC$_NO_GENERIC_QUEUE]
    OR .ITEM_PRESENT[SJC$_GENERIC_TARGET]
    THEN
	BEGIN
	IF .LSMQ[SMQ$L_GENERIC_TARGET] NEQ 0
	THEN
	    DEALLOCATE_RECORD(.LSMQ[SMQ$L_GENERIC_TARGET]);
	END
    ELSE
	SMQ[SMQ$L_GENERIC_TARGET] = .LSMQ[SMQ$L_GENERIC_TARGET];


    IF .ITEM_PRESENT[SJC$_JOB_RESET_MODULES]
    OR .ITEM_PRESENT[SJC$_NO_JOB_RESET_MODULES]
    THEN
	DEALLOCATE_VARIABLE_DATA(
	    SMQ$S_JOB_RESET_MODULES,
	    LSMQ[SMQ$T_JOB_RESET_MODULES])
    ELSE
	CH$MOVE(
	    SMQ$S_JOB_RESET_MODULES,
	    LSMQ[SMQ$T_JOB_RESET_MODULES],
	    SMQ[SMQ$T_JOB_RESET_MODULES]);
    END
ELSE
    BEGIN
    IF .SMQ[SMQ$L_GENERIC_TARGET] NEQ 0
	THEN DEALLOCATE_RECORD(.SMQ[SMQ$L_GENERIC_TARGET]);
    DEALLOCATE_VARIABLE_DATA(
	SMQ$S_JOB_RESET_MODULES,
	SMQ[SMQ$T_JOB_RESET_MODULES]);
    CH$MOVE(SYM$S_SYM, LSMQ, .SMQ);
    END;


.FINAL_STATUS
END;

GLOBAL ROUTINE DELETE_SMQ_RECORD(SMQ_N,SMQ): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine deallocates a queue header and its substructures.
!
! INPUT PARAMETERS:
!	SMQ_N		- Record number of SMQ.
!	SMQ		- Pointer to SMQ.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	SMQ:		REF BBLOCK;	! Pointer to SMQ


! If there are services outstanding for this queue, cancel them.
!
IF .SMQ[SMQ$V_PAUSING]
OR .SMQ[SMQ$V_RESETTING]
OR .SMQ[SMQ$V_RESUMING]
OR .SMQ[SMQ$V_STARTING]
OR .SMQ[SMQ$V_STOPPING]
THEN
    SCAN_INCOMPLETE_SERVICES(ISRV_K_PURGE_SMQ, .SMQ_N);


! Deallocate the generic target record, if it exists.
!
IF .SMQ[SMQ$L_GENERIC_TARGET] NEQ 0
THEN
    DEALLOCATE_RECORD(.SMQ[SMQ$L_GENERIC_TARGET]);


! Deallocate the fixed/variable data areas, if they exist.
!
DEALLOCATE_VARIABLE_DATA(
    SMQ$S_JOB_RESET_MODULES,
    SMQ[SMQ$T_JOB_RESET_MODULES]);


! Finally, deallocate the queue header record.
!
DEALLOCATE_RECORD(.SMQ_N);
END;

GLOBAL ROUTINE CREATE_SJH_RECORD(SMQ_N,SMQ;SJH_N,SJH): L_OUTPUT_2=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine allocates and initializes a job header record.
!
! INPUT PARAMETERS:
!	SMQ_N		- Record number of SMQ.
!	SMQ		- Pointer to SMQ.
!
! IMPLICIT INPUTS:
!	MBX		- Pointer to buffered mailbox message.
!
! OUTPUT PARAMETERS:
!	SJH_N		- Record number of SJH.
!	SJH		- Pointer to SJH.
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Completion status.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	SMQ:		REF BBLOCK,
	SJH:		REF BBLOCK;
LOCAL
	STATUS;


! Allocate the queue record, and return if no more.
!
STATUS = ALLOCATE_RECORD( ; SJH_N, SJH);
IF NOT .STATUS THEN RETURN .STATUS;


! Initialize the queue record.
!
SJH[SYM$B_TYPE] = SYM$K_SJH;
STATUS = ALLOCATE_ENTRY_NUMBER(SJH[SYM$L_ENTRY_NUMBER]);
IF NOT .STATUS
THEN
    BEGIN
    DEALLOCATE_RECORD(.SJH_N);
    RETURN .STATUS;
    END;


IF .SMQ[SMQ$V_BATCH]
THEN
    BEGIN
    SJH[SJH$V_LOG_DELETE] = TRUE;
    SJH[SJH$V_LOG_SPOOL] = TRUE;
    END
ELSE
    BEGIN
    SJH[SJH$V_RESTART] = TRUE;
    SJH[SJH$B_JOB_COPIES] = 1;
    END;


SJH[SJH$V_OPEN] = TRUE;
SJH[SJH$L_QUEUE_LINK] = .SMQ_N;
SJH[SJH$B_PRIORITY] = .SYS$GB_DEFQUEPRI;
IF .SJH[SJH$B_PRIORITY] EQL 0 THEN SJH[SJH$B_PRIORITY] = .MBX[ACM$B_PROCPRI];
SJH[SJH$L_PID] = .MBX[ACM$L_PID];
COPY_SYSID(THIS_SYSID, SJH[SJH$T_SYSID]);
SJH[SJH$L_UIC] = .MBX[ACM$L_UIC];
CH$MOVE(SJH$S_USERNAME, MBX[ACM$T_USERNAME], SJH[SJH$T_USERNAME]);
CH$MOVE(SJH$S_ACCOUNT, MBX[ACM$T_ACCOUNT], SJH[SJH$T_ACCOUNT]);
COPY_TIME(CUR_TIME, SJH[SJH$Q_TIME]);
COPY_TIME(CUR_TIME, SJH[SJH$Q_AFTER_TIME]);
SS$_NORMAL
END;

GLOBAL ROUTINE APPLY_SJH_OPTIONS(SJH)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine applies options to a job header record.
!
! INPUT PARAMETERS:
!	SJH		- Pointer to SJH.
!
! IMPLICIT INPUTS:
!	Existing values in SJH.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	New values in SJH.
!
! ROUTINE VALUE:
!	Completion status.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	SJH:		REF BBLOCK;
LOCAL
	LSJH:		BBLOCK[SYM$S_SYM],	! Saved copy of original SJH
	FINAL_STATUS;				! Final routine status
LABEL
	PROTECTED_UPDATE;


! Set up for backing out the transaction in case of an error.
!
CH$MOVE(SYM$S_SYM, .SJH, LSJH);
CH$FILL(0, SJH$S_CHECKPOINT, SJH[SJH$T_CHECKPOINT]);
CH$FILL(0, SJH$S_LOG_SPECIFICATION, SJH[SJH$T_LOG_SPECIFICATION]);
CH$FILL(0, SJH$S_NOTE, SJH[SJH$T_NOTE]);
CH$FILL(0, SJH$S_PARAMETERS, SJH[SJH$T_PARAMETERS]);
CH$FILL(0, SJH$S_OPERATOR_REQUEST, SJH[SJH$T_OPERATOR_REQUEST]);
FINAL_STATUS = SS$_NORMAL;
PROTECTED_UPDATE:  BEGIN


IF .ITEM_PRESENT[SJC$_AFTER_TIME]
THEN
    BEGIN
    COPY_TIME(VALUE_AFTER_TIME, SJH[SJH$Q_AFTER_TIME]);
    IF TIME_GEQU(CUR_TIME, SJH[SJH$Q_AFTER_TIME])
    THEN
	COPY_TIME(CUR_TIME, SJH[SJH$Q_AFTER_TIME]);
    END;

    
IF .ITEM_PRESENT[SJC$_NO_AFTER_TIME]
THEN
    COPY_TIME(CUR_TIME, SJH[SJH$Q_AFTER_TIME]);


IF .ITEM_PRESENT[SJC$_CHARACTERISTIC_NAME]
OR .ITEM_PRESENT[SJC$_CHARACTERISTIC_NUMBER]
THEN
    CH$MOVE(
	SJH$S_CHARACTERISTICS,
	VALUE_CHARACTERISTICS,
	SJH[SJH$T_CHARACTERISTICS]);


IF .ITEM_PRESENT[SJC$_NO_CHARACTERISTICS]
THEN
    CH$FILL(
	0,
	SJH$S_CHARACTERISTICS,
	SJH[SJH$T_CHARACTERISTICS]);


IF .ITEM_PRESENT[SJC$_CHECKPOINT_DATA]
THEN
    BEGIN
    FINAL_STATUS = STORE_VARIABLE_DATA(
	.SJH,
	SJH$S_CHECKPOINT,
	SJH[SJH$T_CHECKPOINT],
	SYM$K_CHECKPOINT,
	.VALUE_CHECKPOINT_DATA[SDSC_W_LENGTH],
	.VALUE_CHECKPOINT_DATA[SDSC_A_POINTER]);
    IF NOT .FINAL_STATUS THEN LEAVE PROTECTED_UPDATE;
    END;


IF .ITEM_PRESENT[SJC$_NO_CHECKPOINT_DATA]
THEN
    BEGIN
    SJH[SJH$L_COMPLETED_BLOCKS] = 0;
    SJH[SJH$L_CURRENT_FILE_CHKPT] = 0;
    SJH[SJH$B_JOB_COPIES_CHKPT] = 0;
    SJH[SJH$B_FILE_COPIES_CHKPT] = 0;
    END;


IF .ITEM_PRESENT[SJC$_CLI]
THEN
    BEGIN
    CH$WCHAR(
	.VALUE_CLI[SDSC_W_LENGTH],
	SJH[SJH$T_CLI]);
    CH$COPY(
	.VALUE_CLI[SDSC_W_LENGTH],
	.VALUE_CLI[SDSC_A_POINTER],
	0,
	SJH$S_CLI-1,
	SJH[SJH$T_CLI]+1);
    END;


IF .ITEM_PRESENT[SJC$_NO_CLI]
THEN
    CH$FILL(
	0,
	SJH$S_CLI,
	SJH[SJH$T_CLI]);


IF .ITEM_PRESENT[SJC$_CPU_LIMIT]
THEN
    BEGIN
    SJH[SJH$V_CPU_MAXIMUM] = TRUE;
    SJH[SJH$L_CPU_MAXIMUM] = .VALUE_CPU_LIMIT;
    END;


IF .ITEM_PRESENT[SJC$_NO_CPU_LIMIT]
THEN
    BEGIN
    SJH[SJH$V_CPU_MAXIMUM] = FALSE;
    SJH[SJH$L_CPU_MAXIMUM] = 0;
    END;


IF .ITEM_PRESENT[SJC$_DESTINATION_QUEUE]
THEN
    SJH[SJH$L_QUEUE_LINK] = .VALUE_DESTINATION_QUEUE[0];


IF .ITEM_PRESENT[SJC$_FILE_BURST]
THEN
    BEGIN
    SJH[SJH$V_FILE_BURST_ONE] = FALSE;
    SJH[SJH$V_FILE_BURST] = TRUE;
    SJH[SJH$V_FILE_BURST_EXPLICIT] = TRUE;
    END;


IF .ITEM_PRESENT[SJC$_FILE_BURST_ONE]
THEN
    BEGIN
    SJH[SJH$V_FILE_BURST] = FALSE;
    SJH[SJH$V_FILE_BURST_ONE] = TRUE;
    SJH[SJH$V_FILE_BURST_EXPLICIT] = TRUE;
    END;


IF .ITEM_PRESENT[SJC$_NO_FILE_BURST]
THEN
    BEGIN
    SJH[SJH$V_FILE_BURST] = FALSE;
    SJH[SJH$V_FILE_BURST_ONE] = FALSE;
    SJH[SJH$V_FILE_BURST_EXPLICIT] = TRUE;
    END;


IF .ITEM_PRESENT[SJC$_FILE_FLAG]
THEN
    BEGIN
    SJH[SJH$V_FILE_FLAG_ONE] = FALSE;
    SJH[SJH$V_FILE_FLAG] = TRUE;
    SJH[SJH$V_FILE_FLAG_EXPLICIT] = TRUE;
    END;


IF .ITEM_PRESENT[SJC$_FILE_FLAG_ONE]
THEN
    BEGIN
    SJH[SJH$V_FILE_FLAG] = FALSE;
    SJH[SJH$V_FILE_FLAG_ONE] = TRUE;
    SJH[SJH$V_FILE_FLAG_EXPLICIT] = TRUE;
    END;


IF .ITEM_PRESENT[SJC$_NO_FILE_FLAG]
THEN
    BEGIN
    SJH[SJH$V_FILE_FLAG] = FALSE;
    SJH[SJH$V_FILE_FLAG_ONE] = FALSE;
    SJH[SJH$V_FILE_FLAG_EXPLICIT] = TRUE;
    END;


IF .ITEM_PRESENT[SJC$_FILE_TRAILER]
THEN
    BEGIN
    SJH[SJH$V_FILE_TRAILER_ONE] = FALSE;
    SJH[SJH$V_FILE_TRAILER] = TRUE;
    SJH[SJH$V_FILE_TRAILER_EXPLICIT] = TRUE;
    END;


IF .ITEM_PRESENT[SJC$_FILE_TRAILER_ONE]
THEN
    BEGIN
    SJH[SJH$V_FILE_TRAILER] = FALSE;
    SJH[SJH$V_FILE_TRAILER_ONE] = TRUE;
    SJH[SJH$V_FILE_TRAILER_EXPLICIT] = TRUE;
    END;


IF .ITEM_PRESENT[SJC$_NO_FILE_TRAILER]
THEN
    BEGIN
    SJH[SJH$V_FILE_TRAILER] = FALSE;
    SJH[SJH$V_FILE_TRAILER_ONE] = FALSE;
    SJH[SJH$V_FILE_TRAILER_EXPLICIT] = TRUE;
    END;


IF .ITEM_PRESENT[SJC$_FORM_NAME]
OR .ITEM_PRESENT[SJC$_FORM_NUMBER]
THEN
    SJH[SJH$L_FORM_LINK] = .VALUE_FORM[0];


IF .ITEM_PRESENT[SJC$_HOLD]
THEN
    SJH[SJH$V_HOLDING] = TRUE;


IF .ITEM_PRESENT[SJC$_NO_HOLD]
THEN
    BEGIN
    COPY_TIME(CUR_TIME, SJH[SJH$Q_AFTER_TIME]);
    SJH[SJH$V_HOLDING] = FALSE;
    SJH[SJH$V_REFUSED] = FALSE;
    SJH[SJH$V_RETAINED] = FALSE;
    END;


IF .ITEM_PRESENT[SJC$_JOB_COPIES]
THEN
    SJH[SJH$B_JOB_COPIES] = .VALUE_JOB_COPIES;


IF .ITEM_PRESENT[SJC$_JOB_NAME]
THEN
    BEGIN
    CH$WCHAR(
	.VALUE_JOB_NAME[SDSC_W_LENGTH],
	SJH[SJH$T_NAME]);
    CH$COPY(
	.VALUE_JOB_NAME[SDSC_W_LENGTH],
	.VALUE_JOB_NAME[SDSC_A_POINTER],
	0,
	SJH$S_NAME-1,
	SJH[SJH$T_NAME]+1);
    END;


IF .ITEM_PRESENT[SJC$_LOG_DELETE]
THEN
    SJH[SJH$V_LOG_DELETE] = TRUE;


IF .ITEM_PRESENT[SJC$_NO_LOG_DELETE]
THEN
    SJH[SJH$V_LOG_DELETE] = FALSE;


IF .ITEM_PRESENT[SJC$_LOG_SPECIFICATION]
THEN
    BEGIN
    FINAL_STATUS = STORE_VARIABLE_DATA(
	.SJH,
	SJH$S_LOG_SPECIFICATION,
	SJH[SJH$T_LOG_SPECIFICATION],
	SYM$K_LOG_SPECIFICATION,
	.VALUE_LOG_SPECIFICATION[SDSC_W_LENGTH],
	.VALUE_LOG_SPECIFICATION[SDSC_A_POINTER]);
    IF NOT .FINAL_STATUS THEN LEAVE PROTECTED_UPDATE;
    SJH[SJH$V_LOG_NULL] = FALSE;
    END;

    
IF .ITEM_PRESENT[SJC$_NO_LOG_SPECIFICATION]
THEN
    SJH[SJH$V_LOG_NULL] = TRUE;


IF .ITEM_PRESENT[SJC$_LOG_SPOOL]
THEN
    SJH[SJH$V_LOG_SPOOL] = TRUE;


IF .ITEM_PRESENT[SJC$_NO_LOG_SPOOL]
THEN
    BEGIN
    SJH[SJH$L_LOG_QUEUE_LINK] = 0;
    SJH[SJH$V_LOG_SPOOL] = FALSE;
    IF NOT .ITEM_PRESENT[SJC$_LOG_DELETE] THEN SJH[SJH$V_LOG_DELETE] = FALSE;
    END;


IF .ITEM_PRESENT[SJC$_LOG_QUEUE]
THEN
    BEGIN
    IF .BBLOCK[.VALUE_LOG_QUEUE[1], SMQ$V_BATCH]
    THEN
	BEGIN
	FINAL_STATUS = JBC$_INCDSTQUE;
	LEAVE PROTECTED_UPDATE;
	END;
    SJH[SJH$L_LOG_QUEUE_LINK] = .VALUE_LOG_QUEUE[0];
    SJH[SJH$V_LOG_SPOOL] = TRUE;
    END;


IF .ITEM_PRESENT[SJC$_LOWERCASE]
THEN
    SJH[SJH$V_LOWERCASE] = TRUE;


IF .ITEM_PRESENT[SJC$_NO_LOWERCASE]
THEN
    SJH[SJH$V_LOWERCASE] = FALSE;


IF .ITEM_PRESENT[SJC$_NOTE]
THEN
    BEGIN
    FINAL_STATUS = STORE_VARIABLE_DATA(
	.SJH,
	SJH$S_NOTE,
	SJH[SJH$T_NOTE],
	SYM$K_NOTE,
	.VALUE_NOTE[SDSC_W_LENGTH],
	.VALUE_NOTE[SDSC_A_POINTER]);
    IF NOT .FINAL_STATUS THEN LEAVE PROTECTED_UPDATE;
    END;


IF .ITEM_PRESENT[SJC$_NOTIFY]
THEN
    SJH[SJH$V_NOTIFY] = TRUE;


IF .ITEM_PRESENT[SJC$_NO_NOTIFY]
THEN
    SJH[SJH$V_NOTIFY] = FALSE;


IF .ITEM_PRESENT[SJC$_PAGINATE]
THEN
    BEGIN
    SJH[SJH$V_PAGINATE] = TRUE;
    SJH[SJH$V_PAGINATE_EXPLICIT] = TRUE;
    END;


IF .ITEM_PRESENT[SJC$_NO_PAGINATE]
THEN
    BEGIN
    SJH[SJH$V_PAGINATE] = FALSE;
    SJH[SJH$V_PAGINATE_EXPLICIT] = TRUE;
    END;


IF .BBLOCK[ITEM_PRESENT, 0, SJC$_PARAMETER_1, 8, 0] NEQ 0
THEN
    BEGIN
    IF (.VALUE_PARAMETER_1[SDSC_W_LENGTH] +
	.VALUE_PARAMETER_2[SDSC_W_LENGTH] +
	.VALUE_PARAMETER_3[SDSC_W_LENGTH] +
	.VALUE_PARAMETER_4[SDSC_W_LENGTH] +
	.VALUE_PARAMETER_5[SDSC_W_LENGTH] +
	.VALUE_PARAMETER_6[SDSC_W_LENGTH] +
	.VALUE_PARAMETER_7[SDSC_W_LENGTH] +
	.VALUE_PARAMETER_8[SDSC_W_LENGTH]) GTRU JBC$K_MAXPARSIZ_ALL
    THEN FINAL_STATUS = JBC$_INVPARLEN
    ELSE FINAL_STATUS = STORE_VARIABLE_DATA_LIST(
	.SJH,
	SJH$S_PARAMETERS,
	SJH[SJH$T_PARAMETERS],
	SYM$K_PARAMETERS,
	.VALUE_PARAMETER_1[SDSC_W_LENGTH], .VALUE_PARAMETER_1[SDSC_A_POINTER],
	.VALUE_PARAMETER_2[SDSC_W_LENGTH], .VALUE_PARAMETER_2[SDSC_A_POINTER],
	.VALUE_PARAMETER_3[SDSC_W_LENGTH], .VALUE_PARAMETER_3[SDSC_A_POINTER],
	.VALUE_PARAMETER_4[SDSC_W_LENGTH], .VALUE_PARAMETER_4[SDSC_A_POINTER],
	.VALUE_PARAMETER_5[SDSC_W_LENGTH], .VALUE_PARAMETER_5[SDSC_A_POINTER],
	.VALUE_PARAMETER_6[SDSC_W_LENGTH], .VALUE_PARAMETER_6[SDSC_A_POINTER],
	.VALUE_PARAMETER_7[SDSC_W_LENGTH], .VALUE_PARAMETER_7[SDSC_A_POINTER],
	.VALUE_PARAMETER_8[SDSC_W_LENGTH], .VALUE_PARAMETER_8[SDSC_A_POINTER]);
    IF NOT .FINAL_STATUS THEN LEAVE PROTECTED_UPDATE;
    END;


IF .ITEM_PRESENT[SJC$_PRIORITY]
THEN
    SJH[SJH$B_PRIORITY] = .VALUE_PRIORITY;


IF .ITEM_PRESENT[SJC$_OPERATOR_REQUEST]
THEN
    BEGIN
    FINAL_STATUS = STORE_VARIABLE_DATA(
	.SJH,
	SJH$S_OPERATOR_REQUEST,
	SJH[SJH$T_OPERATOR_REQUEST],
	SYM$K_OPERATOR_REQUEST,
	.VALUE_OPERATOR_REQUEST[SDSC_W_LENGTH],
	.VALUE_OPERATOR_REQUEST[SDSC_A_POINTER]);
    IF NOT .FINAL_STATUS THEN LEAVE PROTECTED_UPDATE;
    END;


IF .ITEM_PRESENT[SJC$_RESTART]
THEN
    SJH[SJH$V_RESTART] = TRUE;


IF .ITEM_PRESENT[SJC$_NO_RESTART]
THEN
    SJH[SJH$V_RESTART] = FALSE;


IF .ITEM_PRESENT[SJC$_WSDEFAULT]
THEN
    BEGIN
    SJH[SJH$V_WSDEFAULT] = TRUE;
    SJH[SJH$W_WSDEFAULT] = .VALUE_WSDEFAULT;
    END;


IF .ITEM_PRESENT[SJC$_NO_WSDEFAULT]
THEN
    BEGIN
    SJH[SJH$V_WSDEFAULT] = FALSE;
    SJH[SJH$W_WSDEFAULT] = 0;
    END;


IF .ITEM_PRESENT[SJC$_WSEXTENT]
THEN
    BEGIN
    SJH[SJH$V_WSEXTENT] = TRUE;
    SJH[SJH$W_WSEXTENT] = .VALUE_WSEXTENT;
    END;


IF .ITEM_PRESENT[SJC$_NO_WSEXTENT]
THEN
    BEGIN
    SJH[SJH$V_WSEXTENT] = FALSE;
    SJH[SJH$W_WSEXTENT] = 0;
    END;


IF .ITEM_PRESENT[SJC$_WSQUOTA]
THEN
    BEGIN
    SJH[SJH$V_WSQUOTA] = TRUE;
    SJH[SJH$W_WSQUOTA] = .VALUE_WSQUOTA;
    END;


IF .ITEM_PRESENT[SJC$_NO_WSQUOTA]
THEN
    BEGIN
    SJH[SJH$V_WSQUOTA] = FALSE;
    SJH[SJH$W_WSQUOTA] = 0;
    END;


END;	! block PROTECTED_UPDATE


IF .FINAL_STATUS
THEN
    BEGIN
    IF .ITEM_PRESENT[SJC$_CHECKPOINT_DATA]
    OR .ITEM_PRESENT[SJC$_NO_CHECKPOINT_DATA]
    THEN
	DEALLOCATE_VARIABLE_DATA(
	    SJH$S_CHECKPOINT,
	    LSJH[SJH$T_CHECKPOINT])
    ELSE
	CH$MOVE(
	    SJH$S_CHECKPOINT,
	    LSJH[SJH$T_CHECKPOINT],
	    SJH[SJH$T_CHECKPOINT]);


    IF .ITEM_PRESENT[SJC$_LOG_SPECIFICATION]
    OR .ITEM_PRESENT[SJC$_NO_LOG_SPECIFICATION]
    THEN
	DEALLOCATE_VARIABLE_DATA(
	    SJH$S_LOG_SPECIFICATION,
	    LSJH[SJH$T_LOG_SPECIFICATION])
    ELSE
	CH$MOVE(
	    SJH$S_LOG_SPECIFICATION,
	    LSJH[SJH$T_LOG_SPECIFICATION],
	    SJH[SJH$T_LOG_SPECIFICATION]);


    IF .ITEM_PRESENT[SJC$_NOTE]
    OR .ITEM_PRESENT[SJC$_NO_NOTE]
    THEN
	DEALLOCATE_VARIABLE_DATA(
	    SJH$S_NOTE,
	    LSJH[SJH$T_NOTE])
    ELSE
	CH$MOVE(
	    SJH$S_NOTE,
	    LSJH[SJH$T_NOTE],
	    SJH[SJH$T_NOTE]);


    IF .BBLOCK[ITEM_PRESENT, 0, SJC$_PARAMETER_1, 8, 0] NEQ 0
    OR .ITEM_PRESENT[SJC$_NO_PARAMETERS]
    THEN
	DEALLOCATE_VARIABLE_DATA(
	    SJH$S_PARAMETERS,
	    LSJH[SJH$T_PARAMETERS])
    ELSE
	CH$MOVE(
	    SJH$S_PARAMETERS,
	    LSJH[SJH$T_PARAMETERS],
	    SJH[SJH$T_PARAMETERS]);


    IF .ITEM_PRESENT[SJC$_OPERATOR_REQUEST]
    OR .ITEM_PRESENT[SJC$_NO_OPERATOR_REQUEST]
    THEN
	DEALLOCATE_VARIABLE_DATA(
	    SJH$S_OPERATOR_REQUEST,
	    LSJH[SJH$T_OPERATOR_REQUEST])
    ELSE
	CH$MOVE(
	    SJH$S_OPERATOR_REQUEST,
	    LSJH[SJH$T_OPERATOR_REQUEST],
	    SJH[SJH$T_OPERATOR_REQUEST]);
    END
ELSE
    BEGIN
    DEALLOCATE_VARIABLE_DATA(
	SJH$S_CHECKPOINT,
	SJH[SJH$T_CHECKPOINT]);
    DEALLOCATE_VARIABLE_DATA(
	SJH$S_LOG_SPECIFICATION,
	SJH[SJH$T_LOG_SPECIFICATION]);
    DEALLOCATE_VARIABLE_DATA(
	SJH$S_NOTE,
	SJH[SJH$T_NOTE]);
    DEALLOCATE_VARIABLE_DATA(
	SJH$S_PARAMETERS,
	LSJH[SJH$T_PARAMETERS]);
    DEALLOCATE_VARIABLE_DATA(
	SJH$S_OPERATOR_REQUEST,
	SJH[SJH$T_OPERATOR_REQUEST]);
    CH$MOVE(SYM$S_SYM, LSJH, .SJH);
    END;


.FINAL_STATUS
END;

GLOBAL ROUTINE DELETE_SJH_RECORD(SJH_N,SJH): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine deallocates a job header and its substructures.
!
! INPUT PARAMETERS:
!	SJH_N		- Record number of SJH.
!	SJH		- Pointer to SJH.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	SJH:		REF BBLOCK;	! Pointer to SJH
LOCAL
	SQR_N,				! Record number of SQR
	SQR_NS,				! Record number of successor of SQR
	SQR:		REF BBLOCK,	! Pointer to SQR
	DELETIONS;			! List of deletions to process


! If there are services outstanding for this job, cancel them.
!
IF .SJH[SJH$V_ABORTING]
OR .SJH[SJH$V_STARTING]
THEN
    SCAN_INCOMPLETE_SERVICES(ISRV_K_PURGE_SJH, .SJH_N);


! Deallocate the fixed/variable data areas, if they exist.
!
DEALLOCATE_VARIABLE_DATA(
    SJH$S_CHECKPOINT,
    SJH[SJH$T_CHECKPOINT]);
DEALLOCATE_VARIABLE_DATA(
    SJH$S_LOG_SPECIFICATION,
    SJH[SJH$T_LOG_SPECIFICATION]);
DEALLOCATE_VARIABLE_DATA(
    SJH$S_NOTE,
    SJH[SJH$T_NOTE]);
DEALLOCATE_VARIABLE_DATA(
    SJH$S_PARAMETERS,
    SJH[SJH$T_PARAMETERS]);
DEALLOCATE_VARIABLE_DATA(
    SJH$S_REFUSAL_REASON,
    SJH[SJH$T_REFUSAL_REASON]);
DEALLOCATE_VARIABLE_DATA(
    SJH$S_OPERATOR_REQUEST,
    SJH[SJH$T_OPERATOR_REQUEST]);


! Deallocate the file record list.
!
DELETIONS = 0;
SQR_N = .SJH[SJH$L_FILE_LIST];
WHILE .SQR_N NEQ 0 DO
    BEGIN
    SQR = READ_RECORD(.SQR_N);
    SQR_NS = .SQR[SYM$L_LINK];


    ! Cancel the delete option for an open job, or for a job that is deleted
    ! before execution, unless the file is not in a directory.
    !
    IF
	(.SJH[SJH$V_DELETED]
	AND NOT .SJH[SJH$V_RETAINED]
	AND .SQR[SQR$W_FILE_ID_DID_NUM] NEQ 0)
    OR
	.SJH[SJH$V_OPEN]
    THEN
	SQR[SQR$V_DELETE_FILE] = FALSE;


    DELETE_SQR_RECORD(.SQR_N, .SQR, DELETIONS);
    SQR_N = .SQR_NS;
    END;


! Execute file deletions, if any.
!
IF .DELETIONS NEQ 0
THEN
    IF SYSID_NEQ(THIS_SYSID, SJH[SJH$T_SYSID])
    THEN
	CREATE_SRQ_RECORD(SRQ$K_DELETE_FILES, .SJH, .DELETIONS)
    ELSE
	DELETE_FILES(.DELETIONS);


! Deallocate the job entry number.
!
DEALLOCATE_ENTRY_NUMBER(.SJH[SYM$L_ENTRY_NUMBER]);


! Finally, deallocate the job header record.
!
DEALLOCATE_RECORD(.SJH_N);
END;

GLOBAL ROUTINE CREATE_SQR_RECORD(SJH;SQR_N,SQR): L_OUTPUT_2=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine allocates and initializes a job file record.
!
! INPUT PARAMETERS:
!	SJH		- Pointer to SJH.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	SQR_N		- Record number of SQR.
!	SQR		- Pointer to SQR.
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Completion status.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	SJH:		REF BBLOCK,	! Pointer to SJH
	SQR:		REF BBLOCK;	! Pointer to SQR
LOCAL
	STATUS;


! Allocate the queue record, and return if no more.
!
STATUS = ALLOCATE_RECORD( ; SQR_N, SQR);
IF NOT .STATUS THEN RETURN .STATUS;


! Initialize the queue record.
!
SQR[SYM$B_TYPE] = SYM$K_SQR;
SQR[SYM$L_ENTRY_NUMBER] = .SJH[SYM$L_ENTRY_NUMBER];
SQR[SQR$V_PAGINATE] = TRUE;
CH$MOVE(
    SQR$S_FILE_IDENTIFICATION,
    VALUE_FILE_IDENTIFICATION,
    SQR[SQR$T_FILE_IDENTIFICATION]);
SQR[SQR$L_FILE_SIZE] = .VALUE_FILE_IDENTIFICATION[28,0,32,0];
SQR[SQR$B_FILE_COPIES] = 1;
CH$WCHAR(
    .VALUE_FILE_SPECIFICATION[SDSC_W_LENGTH],
    SQR[SQR$T_FILE_SPECIFICATION]);
CH$COPY(
    .VALUE_FILE_SPECIFICATION[SDSC_W_LENGTH],
    .VALUE_FILE_SPECIFICATION[SDSC_A_POINTER],
    0,
    SQR$S_FILE_SPECIFICATION-1,
    SQR[SQR$T_FILE_SPECIFICATION]+1);


IF .ITEM_PRESENT[SJC$_BATCH_INPUT]
THEN
    BEGIN
    LOCAL
	P:		REF BBLOCK,	! Cursor for item list
	P_END;				! Pointer past end of item list


    ! Pick up a pointer to the item list and one to the last item.
    !
    P = .VALUE_BATCH_INPUT[SDSC_A_POINTER];
    P_END = .P + .VALUE_BATCH_INPUT[SDSC_W_LENGTH] - 4;


    ! Loop over the items.
    !
    WHILE .P LSSA .P_END DO
	BEGIN
	LOCAL
	    TYPE,			! Item type
	    SIZE;			! Item size


	! Get and advance over the item type and size.
	!
	TYPE = .P[DJI$W_ITEM_CODE];
	SIZE = .P[DJI$W_ITEM_SIZE];
	P = .P + DJI$S_ITEM_HEADER;


	! Process the item.
	!
	CASE .TYPE FROM DJI$K_CONDITION_VECTOR TO DJI$K_FILE_SPECIFICATION OF
	    SET


	    [OUTRANGE]:
		EXITLOOP;


	    [DJI$K_CONDITION_VECTOR]:
		BEGIN
		CH$COPY(
		    .SIZE, .P,
		    0,
		    SQR$S_CONDITION_VECTOR, SQR[SQR$L_CONDITION_1]);
		END;


	    [DJI$K_FILE_SPECIFICATION]:
		BEGIN
		CH$WCHAR(
		    .SIZE,
		    SQR[SQR$T_FILE_SPECIFICATION]);
		CH$COPY(
		    .SIZE, .P,
		    0,
		    SQR$S_FILE_SPECIFICATION-1,
		    SQR[SQR$T_FILE_SPECIFICATION]+1);
		END;


	    TES;


	! Advance to the next item.
	!
	P = .P + .SIZE;
	END;
    END;


! Default the job name from the file name of the first file.
!
IF .SJH[SJH$L_FILE_LIST] EQL 0 AND CH$RCHAR(SJH[SJH$T_NAME]) EQL 0
THEN
    BEGIN
    LOCAL
	DESC:		VECTOR[2],	! Descriptor for file specification
	ITMLST:		BBLOCK[12];	! $FILESCAN item list


    DESC[0] = CH$RCHAR(SQR[SQR$T_FILE_SPECIFICATION]);
    DESC[1] = SQR[SQR$T_FILE_SPECIFICATION] + 1;
    ITMLST[0,0,16,0] = 0;
    ITMLST[2,0,16,0] = FSCN$_NAME;
    ITMLST[4,0,32,0] = 0;
    ITMLST[8,0,32,0] = 0;
    $FILESCAN(SRCSTR=DESC, VALUELST=ITMLST);
    IF .ITMLST[0,0,16,0] GTRU SJH$S_NAME-1 THEN ITMLST[0,0,16,0] = SJH$S_NAME-1;
    CH$WCHAR(
	.ITMLST[0,0,16,0],
	SJH[SJH$T_NAME]);
    CH$COPY(
	.ITMLST[0,0,16,0], .ITMLST[4,0,32,0],
	0,
	SJH$S_NAME-1, SJH[SJH$T_NAME]+1);
    END;


SS$_NORMAL
END;

GLOBAL ROUTINE APPLY_SQR_OPTIONS(SJH,SQR)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine applies options to a job file record.
!
! INPUT PARAMETERS:
!	SJH		- Pointer to SJH.
!	SQR		- Pointer to SQR.
!
! IMPLICIT INPUTS:
!	Existing values in SQR.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	New values in SQR.
!
! ROUTINE VALUE:
!	Completion status.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	SJH:		REF BBLOCK,	! Pointer to SJH
	SQR:		REF BBLOCK;	! Pointer to SQR
LOCAL
	LSQR:		BBLOCK[SYM$S_SYM],	! Saved copy of original SQR
	FINAL_STATUS;				! Final routine status
LABEL
	PROTECTED_UPDATE;


! Set up for backing out the transaction in case of an error.
!
CH$MOVE(SYM$S_SYM, .SQR, LSQR);
CH$FILL(0, SQR$S_FILE_SETUP_MODULES, SQR[SQR$T_FILE_SETUP_MODULES]);
FINAL_STATUS = SS$_NORMAL;
PROTECTED_UPDATE:  BEGIN


IF .ITEM_PRESENT[SJC$_DELETE_FILE]
THEN
    SQR[SQR$V_DELETE_FILE] = TRUE;


IF .ITEM_PRESENT[SJC$_NO_DELETE_FILE]
THEN
    SQR[SQR$V_DELETE_FILE] = FALSE;


IF .ITEM_PRESENT[SJC$_DOUBLE_SPACE]
THEN
    SQR[SQR$V_DOUBLE_SPACE] = TRUE;


IF .ITEM_PRESENT[SJC$_NO_DOUBLE_SPACE]
THEN
    SQR[SQR$V_DOUBLE_SPACE] = FALSE;


IF .ITEM_PRESENT[SJC$_FILE_BURST]
THEN
    BEGIN
    SQR[SQR$V_FILE_BURST] = TRUE;
    SQR[SQR$V_FILE_BURST_EXPLICIT] = TRUE;
    END;


IF .ITEM_PRESENT[SJC$_NO_FILE_BURST]
THEN
    BEGIN
    SQR[SQR$V_FILE_BURST] = FALSE;
    SQR[SQR$V_FILE_BURST_EXPLICIT] = TRUE;
    END;


IF .ITEM_PRESENT[SJC$_FILE_COPIES]
THEN
    SQR[SQR$B_FILE_COPIES] = .VALUE_FILE_COPIES;


IF .ITEM_PRESENT[SJC$_FILE_FLAG]
THEN
    BEGIN
    SQR[SQR$V_FILE_FLAG] = TRUE;
    SQR[SQR$V_FILE_FLAG_EXPLICIT] = TRUE;
    END;


IF .ITEM_PRESENT[SJC$_NO_FILE_FLAG]
THEN
    BEGIN
    SQR[SQR$V_FILE_FLAG] = FALSE;
    SQR[SQR$V_FILE_FLAG_EXPLICIT] = TRUE;
    END;


IF .ITEM_PRESENT[SJC$_FILE_SETUP_MODULES]
THEN
    BEGIN
    FINAL_STATUS = STORE_VARIABLE_DATA(
	.SQR,
	SQR$S_FILE_SETUP_MODULES,
	SQR[SQR$T_FILE_SETUP_MODULES],
	SYM$K_FILE_SETUP_MODULES,
	.VALUE_FILE_SETUP_MODULES[SDSC_W_LENGTH],
	.VALUE_FILE_SETUP_MODULES[SDSC_A_POINTER]);
    IF NOT .FINAL_STATUS THEN LEAVE PROTECTED_UPDATE;
    END;


IF .ITEM_PRESENT[SJC$_FILE_TRAILER]
THEN
    BEGIN
    SQR[SQR$V_FILE_TRAILER] = TRUE;
    SQR[SQR$V_FILE_TRAILER_EXPLICIT] = TRUE;
    END;


IF .ITEM_PRESENT[SJC$_NO_FILE_TRAILER]
THEN
    BEGIN
    SQR[SQR$V_FILE_TRAILER] = FALSE;
    SQR[SQR$V_FILE_TRAILER_EXPLICIT] = TRUE;
    END;


IF .ITEM_PRESENT[SJC$_FIRST_PAGE]
THEN
    SQR[SQR$L_FIRST_PAGE] = .VALUE_FIRST_PAGE;


IF .ITEM_PRESENT[SJC$_NO_FIRST_PAGE]
THEN
    SQR[SQR$L_FIRST_PAGE] = 0;


IF .ITEM_PRESENT[SJC$_LAST_PAGE]
THEN
    SQR[SQR$L_LAST_PAGE] = .VALUE_LAST_PAGE;


IF .ITEM_PRESENT[SJC$_NO_LAST_PAGE]
THEN
    SQR[SQR$L_LAST_PAGE] = 0;


IF .ITEM_PRESENT[SJC$_PAGE_HEADER]
THEN
    SQR[SQR$V_PAGE_HEADER] = TRUE;


IF .ITEM_PRESENT[SJC$_NO_PAGE_HEADER]
THEN
    SQR[SQR$V_PAGE_HEADER] = FALSE;


IF .ITEM_PRESENT[SJC$_PAGINATE]
THEN
    BEGIN
    SQR[SQR$V_PAGINATE] = TRUE;
    SQR[SQR$V_PAGINATE_EXPLICIT] = TRUE;
    END;


IF .ITEM_PRESENT[SJC$_NO_PAGINATE]
THEN
    BEGIN
    SQR[SQR$V_PAGINATE] = FALSE;
    SQR[SQR$V_PAGINATE_EXPLICIT] = TRUE;
    END;


IF .ITEM_PRESENT[SJC$_PASSALL]
THEN
    SQR[SQR$V_PASSALL] = TRUE;


IF .ITEM_PRESENT[SJC$_NO_PASSALL]
THEN
    SQR[SQR$V_PASSALL] = FALSE;


END;	! block PROTECTED_UPDATE


IF .FINAL_STATUS
THEN
    BEGIN
    IF .ITEM_PRESENT[SJC$_FILE_SETUP_MODULES]
    OR .ITEM_PRESENT[SJC$_NO_FILE_SETUP_MODULES]
    THEN
	DEALLOCATE_VARIABLE_DATA(
	    SQR$S_FILE_SETUP_MODULES,
	    LSQR[SQR$T_FILE_SETUP_MODULES])
    ELSE
	CH$MOVE(
	    SQR$S_FILE_SETUP_MODULES,
	    LSQR[SQR$T_FILE_SETUP_MODULES],
	    SQR[SQR$T_FILE_SETUP_MODULES]);
    END
ELSE
    BEGIN
    DEALLOCATE_VARIABLE_DATA(
	SQR$S_FILE_SETUP_MODULES,
	SQR[SQR$T_FILE_SETUP_MODULES]);
    CH$MOVE(SYM$S_SYM, LSQR, .SQR);
    END;


SJH[SJH$L_JOB_SIZE] = .SJH[SJH$L_JOB_SIZE] +
    .SQR[SQR$L_FILE_SIZE] * .SQR[SQR$B_FILE_COPIES] * .SJH[SJH$B_JOB_COPIES];


.FINAL_STATUS
END;

GLOBAL ROUTINE DELETE_SQR_RECORD(SQR_N,SQR,DELETIONS): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine deallocates a job file record and its substructures.
!
! INPUT PARAMETERS:
!	SQR_N		- Record number of SQR.
!	SQR		- Pointer to SQR.
!	DELETIONS	- (Optional) Pointer to list head for deletions.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	SQR:		REF BBLOCK;	! Pointer to SQR
BUILTIN
	ACTUALCOUNT;


! Deallocate the fixed/variable data areas, if they exist.
!
DEALLOCATE_VARIABLE_DATA(
    SQR$S_FILE_SETUP_MODULES,
    SQR[SQR$T_FILE_SETUP_MODULES]);


! Delete files as requested.
!
IF .SQR[SQR$V_DELETE_FILE]
AND CH$RCHAR(SQR[SQR$T_FILE_ID_DVI]) NEQ 0
AND ACTUALCOUNT() GEQU 3
THEN
    BEGIN
    SQR[SYM$L_LINK] = ..DELETIONS;
    .DELETIONS = .SQR_N;
    REWRITE_RECORD(.SQR_N);
    END
ELSE
    DEALLOCATE_RECORD(.SQR_N);
END;

GLOBAL ROUTINE DELETE_FILES(SQR_N): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine schedules the deletion of files in a completed job.
!
! INPUT PARAMETERS:
!	SQR_N		- Record number of first SQR in list.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	P:		REF VECTOR;	! Pointer to file deletion context


! Allocate the file deletion context area, initialize it with the list head,
! and schedule execution of the file deletion routine.
!
P = ALLOCATE_MEMORY();
P[0] = .SQR_N;
SCHEDULE_NONAST(DELETE_ONE_FILE, 4, P);
END;

ROUTINE DELETE_ONE_FILE(REF_P): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine deletes one file in a completed job.
!
! INPUT PARAMETERS:
!	P		- Pointer to pointer to file deletion context area.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	P:		REF VECTOR;	! Pointer to file deletion context.


IF .QUEUE_FAB[FAB$W_IFI] NEQ 0
THEN
    BEGIN

    ! Point to file deletion context.
    !
    P = ..REF_P;


    ! Lock the queue file.
    !
    LOCK_QUEUE_FILE();


    ! Loop until a deletion is successfully submitted or no files remain.
    !
    WHILE TRUE DO
	BEGIN
	BIND
	    FIB = P[2] : BBLOCK[FIB$C_LENGTH];	! FIB

	LOCAL
	    SQR_N,				! Record number of SQR
	    SQR:		REF BBLOCK,	! Pointer to SQR
	    DEVICE_DESC:	VECTOR[2],	! Descriptor for device name
	    FIB_DESC:		VECTOR[2],	! Descriptor for FIB
	    FNA_DESC:		VECTOR[2],	! Descriptor for filename
	    ITMLST:		BBLOCK[28];	! $FILESCAN item list


	! If no more files, exit the loop.
	!
	IF .P[0] EQL 0
	THEN
	    BEGIN
	    DEALLOCATE_MEMORY(.P);
	    EXITLOOP;
	    END;


	! Read the SQR record and link to next.
	!
	SQR = READ_RECORD(SQR_N = .P[0]);
	P[0] = .SQR[SYM$L_LINK];


	! Extract the name, type, and version from the file specification.
	!
	FNA_DESC[0] = CH$RCHAR(SQR[SQR$T_FILE_SPECIFICATION]);
	FNA_DESC[1] = SQR[SQR$T_FILE_SPECIFICATION] + 1;
	ITMLST[0,0,16,0] = 0;
	ITMLST[2,0,16,0] = FSCN$_NAME;
	ITMLST[4,0,32,0] = 0;
	ITMLST[8,0,16,0] = 0;
	ITMLST[10,0,16,0] = FSCN$_TYPE;
	ITMLST[12,0,32,0] = 0;
	ITMLST[16,0,16,0] = 0;
	ITMLST[18,0,16,0] = FSCN$_VERSION;
	ITMLST[20,0,32,0] = 0;
	ITMLST[24,0,32,0] = 0;
	$FILESCAN(SRCSTR=FNA_DESC, VALUELST=ITMLST);


	! Initialize for the delete.
	!
	DEVICE_DESC[0] = CH$RCHAR(SQR[SQR$T_FILE_ID_DVI]);
	DEVICE_DESC[1] = SQR[SQR$T_FILE_ID_DVI] + 1;
	CH$FILL(0, FIB$C_LENGTH, FIB);
	FIB[FIB$W_FID_NUM] = .SQR[SQR$W_FILE_ID_FID_NUM];
	FIB[FIB$W_FID_SEQ] = .SQR[SQR$W_FILE_ID_FID_SEQ];
	FIB[FIB$W_FID_RVN] = .SQR[SQR$W_FILE_ID_FID_RVN];
	FIB[FIB$W_DID_NUM] = .SQR[SQR$W_FILE_ID_DID_NUM];
	FIB[FIB$W_DID_SEQ] = .SQR[SQR$W_FILE_ID_DID_SEQ];
	FIB[FIB$W_DID_RVN] = .SQR[SQR$W_FILE_ID_DID_RVN];
	FIB_DESC[0] = FIB$C_LENGTH;
	FIB_DESC[1] = FIB;
	FNA_DESC[0] = .ITMLST[0,0,16,0] + .ITMLST[8,0,16,0] + .ITMLST[16,0,16,0];
	FNA_DESC[1] = .ITMLST[4,0,32,0];


	! Assign a channel to the device, and issue the delete QIO.  Te
	! cleanly if anything fails.
	!
	IF $ASSIGN(DEVNAM=DEVICE_DESC, CHAN=P[1])
	THEN
	    IF $QIO(
		FUNC=IO$_DELETE OR IO$M_DELETE,
		CHAN=.P[1],
		ASTADR=DELETE_ONE_FILE_AST,
		ASTPRM=.P,
		P1=FIB_DESC,
		P2=FNA_DESC)
	    THEN
		BEGIN
		DEALLOCATE_RECORD(.SQR_N);
		EXITLOOP;
		END
	    ELSE
		BEGIN
		DEALLOCATE_RECORD(.SQR_N);
		$DASSGN(CHAN=.P[1]);
		END
	ELSE
	    DEALLOCATE_RECORD(.SQR_N);
	END;


    ! Unlock the queue file.
    !
    UNLOCK_QUEUE_FILE();
    END;
END;

ROUTINE DELETE_ONE_FILE_AST(P): NOVALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine is the completion AST for deletion of one file in a
!	completed job.  It reschedules execution of the file deletion routine,
!	or terminates the operation if it is complete.
!
! INPUT PARAMETERS:
!	P		- Pointer to file deletion context area.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	P:		REF VECTOR;	! Pointer to file deletion context.


! Deassign the channel, and reschedule the file deletion routine.  If the
! operation is complete, release the file context area.
!
$DASSGN(CHAN=.P[1]);
IF .P[0] EQL 0
    THEN DEALLOCATE_MEMORY(.P)
    ELSE SCHEDULE_NONAST(DELETE_ONE_FILE, 4, P);
END;

END
ELUDOM
