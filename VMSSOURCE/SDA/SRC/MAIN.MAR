	.TITLE	MAIN	SYSTEM DUMP ANALYZER MAIN PROGRAM
	.SBTTL	COPYRIGHT NOTICE
	.IDENT	'V04-000'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
	.PAGE
	.SBTTL	PROGRAM DESCRIPTION
;++
;   FACILITY
;
;	SYSTEM DUMP ANALYZER
;
;   ABSTRACT
;
;	THIS PROGRAM ACCEPTS A DUMP FILE FROM A SYSTEM
;	CRASH AND THE SYSTEM SYMBOL TABLE CORRESPONDING
;	TO THE SYSTEM BEING ANALYZED, AND OUTPUTS A
;	LISTING CONTAINING THE FORMATTED SYSTEM DATA
;	STRUCTURES AND MEMORY AT THE TIME OF THE CRASH.
;	THE PROGRAM CAN ALSO BE USED INTERACTIVELY TO
;	INTERROGATE THE SYSTEM DUMP INFORMATION.
;
;   ENVIRONMENT
;
;	NATIVE MODE, USER MODE
;
;   AUTHOR
;
;	TIM HALVORSEN, JULY 1978
;
;   MODIFIED BY
;
;	V03-012 EMB0104		Ellen M. Batbouta	07-Jun-1984
;		Increase the size of the LIST_BUFFER from 132 (for a
;		single line) to 300 since the line of output may overflow
;		onto the next lines.  Change the version number from v3.0
;		to v4.0 (which is displayed as part of the heading when
;		the output is sent to a file).
;
;	V03-011 EMD0094		Ellen M. Dusseault	02-May-1984
;		Save registers to preserve contents at the entrance of
;	        the routine PAGE_WAIT.  The instructions which destroy
;	        the registers are two movc3 instructions.
;
;	V03-010	TMK0002		Todd M. Katz		24-Ap-1984
;		Modify the routine PAGE_WAIT to save the contents of the input 
;		buffer before prompting for a command. If the user simply hits 
;		"RETURN" to the prompt, then the command which was in progress 
;		when end-of-page was encountered is returned to the input buffer
;		before the command is allowed to continue. This change will 
;		allow any descriptors of the information in the input buffer to 
;		describe the same information both before and after the 
;		end-of-page was encountered. 
;
;		This fixes the SHOW POOL/TYPE= problem. This command sets up a 
;		descriptor of the block type requested with the buffer address
;		pointing into the input buffer. When the first end-of-page is
;		encountered during the display of block of the specified type, 
;		the retrieval of the users "RETURN", indicating that the current
;		SHOW POOL command should be continued, wipes out the block type 
;		within the input buffer, that the descriptor was refering to. 
;		This results in an inability to display more than a screen's 
;		worth of pool whenever a block type is explicitly specified.
;
;	V03-009	JLV0329		Jake VanNoy		27-FEB-1984
;		Fix bug in ^C handling that resulted in RMS-F-BUSY errors.
;
;	V03-008	ROW0237		Ralph O. Weber		22-OCT-1983
;		Correct sub-heading output to only take character count from 
;		first word of descriptor, not first longword.  Add 
;		PRINT_COLUMNS a table-driven, generalized "produce displays in 
;		columns" routine.
;
;	V03-007	JLV0303		Jake VanNoy		22-AUG-1983
;		Remove one argument from call to SMG$READ_COMPOSED_LINE
;		to track change to this RTL routine.
;
;	V03-006	JLV0281		Jake VanNoy		27-JUL-1983
;		Change name of init file.
;
;	V03-005	JLV0260		Jake VanNoy		23-MAY-1983
;		Add key input. Remove use of RMS for SYS$INPUT. Replace
;		use of SCR$SCREEN_INFO with a call to $GETDVI.
;
;	V03-004	TMK0001		Todd M. Katz		21-Mar-1983
;		Add the descriptor LOG_FILE, the RMS control blocks
;		LOGFAB LOGRAB and LOGNAM, and the action routines OPEN_LOG
;		and CLOSE_LOG so that interactive sessions maybe logged.
;		Also modify PUT_LINE so that all lines written to the terminal
;		are also logged to the log file when logging is enabled.
;
;	V03-003	CWH1002		CW Hobbs		13-Mar-1983
;		Reduce the prompt region at the bottom of a screen to
;		three lines so that an extra line in SHOW PROCESS can
;		be displayed without a page wrap.  Also changed a couple
;		of references to the prompt region to use the symbol
;		PROMPT_LINES rather than a constant.
;
;	V03-002	JLV0223		Jake VanNoy		21-JAN-1983
;		Add assigning a channel to terminal and establish
;		a ^C handler to exit current command.
;
;	V03-001	KTA0093		Kerbey T. Altmann	05-Apr-1982
;		Modifications to allow PAGEFILE.SYS to be a dumpfile.
;		Also use SYS$LP_LINES to calculate page size.
;
;**++**									**++**
;		If ANALYZE was invoked via DCL;
;		Then
;			If /SYMBOLS is present and nonblank;
;			Then
;				Use the value of /SYMBOLS (e.g. directory spec);
;			Else
;				Use a default of SYS$SYSTEM: ;
;			Endif;
;		Else
;			Use the directory that the dump file came from;
;		End;
;**--**									**--**
;
;		Change all CMPW's referencing an MSG$_ symbol to CMPL's.
;
;		Change default addressing to longword.
;
;		Remove references to $SDAMSGDEF macro.
;
;		Remove old Help file FAB and RAB.
;
;	V006	TMH0006		Tim Halvorsen	22-May-1981
;		Do not show "Dump taken on ..." message if
;		analyzing the running system.
;
;	V005	TMH0005		Tim Halvorsen	20-May-1981
;		Add indirect FABs and RABs.  Do not request upcasing
;		from terminal driver, as upcasing will be done by
;		command parser now.  Change version number to 3.0.
;
;	V004	TMH0004		Tim Halvorsen	03-Feb-1981
;		Allow program to be invoked via new ANALZYE/SYSTEM
;		or ANALYZE/CRASH_DUMP DCL commands.
;
;	V003	TMH0003		Tim Halvorsen	23-Sep-1980
;		Change reference to SCR$INFO to SCR$SCREEN_INFO.
;--

	.SBTTL	DECLARATIONS
;
;	SYMBOL DEFINTIONS
;
	$STSDEF			; COMPLETION CODE FIELDS
	$DSCDEF			; DESCRIPTOR DEFINITIONS
	$DVIDEF			; GETDVI DEFINITIONS
	$COLMDEF		; COLUMN_LIST definitions
	$EMBDEF <CR>		; ERROR LOG DEFINITIONS
	$DMPDEF			; DUMP FILE DEFINITIONS
	$DIBDEF			; DEVICE INFORMATION BUFFER
	$DCDEF			; DEVICE TYPE DEFINITIONS
	$DEVDEF			; DEVICE CHARACTERISTICS
	$JPIDEF			; GETJPI REQUEST DEFINITIONS
	$SHRDEF			; SHARED MESSAGE DEFINITIONS
	$SCRDEF			; SCREEN PACKAGE DEFINITIONS
	$CHFDEF			; CONDITION HANDLING FACILITY DEFINITIONS
	$CLIDEF			; OLD CLI INTERFACE DEFINITIONS

	.DEFAULT DISPLACEMENT,LONG

	.SBTTL	STORAGE DEFINITIONS

;
;	READ/WRITE STORAGE DEFINITIONS
;

	.PSECT	SDADATA,NOEXE,WRT,LONG

VERSION_FLAGS::
	.BLKL	1			; DESCRIBES SYSTEM VERSION

LOG_FILE::
	.BLKQ	1			; LOG FILE NAME DESCRIPTOR

OUTPUT_FILE::
	.BLKQ	1			; OUTPUT FILE NAME DESCRIPTOR

CURRENT_SYSTEM::
	.BLKL	1			; TRUE IF EXAMINING CURRENT SYSTEM

PAGE_NUMBER::
	.BLKL	1			; CURRENT PAGE NUMBER

LINE_COUNT::
	.LONG	0			; LINES FOR CURRENT PAGE

HEADING_LINES:
	.BLKL	1			; LINES USED FOR PAGE HEADING

PROMPT_LINES = 3			; NO. LINES USED FOR PAGE_WAIT

PAGE_SIZE::
	.BLKL	1			; MAX. LINES/PAGE

CLR_PAGE:
	.BLKL	1			; zeroed to prevent clearing page

CURRENT_TIME:				; CURRENT DATE AND TIME
	.LONG	24
	.LONG	TIME_BUFFER
TIME_BUFFER:
	.BLKB	24			; ONLY GET FIRST 24 CHARS

CTRLC_PENDING:
	.BLKB	1			; ^C pending flag

PUT_BUSY:
	.BLKB	1			; $PUT busy flag

	.PSECT	BUFFERS,NOEXE,WRT

BUFFER::
	.BLKB	512			; BUFFER FOR GENERAL USE

INPUT_BUF_LEN == 80
INPUT_BUFFER::
	.BLKB	INPUT_BUF_LEN
SAVE_INPUT_BUFFER:
	.BLKB	INPUT_BUF_LEN
SAVE_INPUT_LEN:
	.LONG	0
INPUT_LEN::
	.LONG	0
INPUT_BUF::
	.LONG		INPUT_BUF_LEN	; Descriptor for input buffer
	.ADDRESS	INPUT_BUFFER

DUMP_HEADER::
DUMP_HEADER_LEN	== 3*512		; 3 BLOCKS
	.BLKB	DUMP_HEADER_LEN

LINE_DESCR::
	.LONG	LIST_BUFFER_LEN
	.LONG	LIST_BUFFER
LIST_BUFFER:
LIST_BUFFER_LEN	= 300
	.BLKB	LIST_BUFFER_LEN

CMND_DESCR::				; OUTPUT BUFFER DESCRIPTOR
	.LONG	CMND_BUFFER_LEN
	.LONG	CMND_BUFFER
CMND_BUFFER::
CMND_BUFFER_LEN == 80
	.BLKB	CMND_BUFFER_LEN

STB_BUFFER==BUFFER			; OVERLAP MISC. BUFFER
STB_BUFFER_LEN = 512

HELP_BUFFER:
HELP_BUFFER_LEN = 80
	.BLKB	HELP_BUFFER_LEN

REPEAT_KEY::
	.ASCID	/KP0/			; Default 'repeat' key
KEYBOARD::	
	.LONG	0			; Screen input routine storage
KEYTABLE::
	.LONG	0
TT_CHAN::
	.LONG	0			; TERMINAL CHANNEL IF SYS$INPUT IS TRM
SMG_PROMPT:
	.LONG	0			; address of prompt loaded here

DVI_ITMLST:
	.WORD	4,DVI$_DEVDEPEND
	.LONG	DVI_DEVDEPEND,0		; GETDVI FOR DEVDEPEND

	.WORD	4,DVI$_DEVDEPEND2
	.LONG	DVI_DEVDEPND2,0		; GETDVI FOR DEVDEPEND 2

	.WORD	4,DVI$_DEVBUFSIZ
	.LONG	DVI_DEVBUFSIZ,0	

	.WORD	4,DVI$_DEVCHAR
	.LONG	DVI_DEVCHAR,0

	.LONG	0			; End of list

DVI_DEVDEPEND::
	.BLKB	3
DVI_PAGESIZE:
	.BYTE	0			; High byte of DEVDEPEND is page size
DVI_DEVDEPND2::
	.LONG	0
DVI_DEVBUFSIZ:
	.LONG	0
DVI_DEVCHAR::
	.LONG	0

	.PSECT	RMSBLOCKS,NOEXE,WRT,LONG

DUMPF::	$FAB	DNM=<SYSDUMP.DMP>,-
		NAM=DUMPN,-		; ADDRESS OF NAM BLOCK
		FAC=<BIO,GET>		; BLOCK I/O

DUMPN:	$NAM	ESA=DUMP_EXPNAME,-	; EXPANDED NAME STRING BUFFER
		ESS=NAM$C_MAXRSS	; LENGTH OF BUFFER

DUMP_EXPNAME:
	.BLKB	NAM$C_MAXRSS		; EXPANDED NAME STRING

DUMPR::	$RAB	FAB=DUMPF, -
		ROP=BIO, -		; BLOCK I/O ACCESS
		BKT=1, -		; BOZO'S BUCKET #1
		UBF=DUMP_HEADER, -	; BUFFER ADDRESS
		USZ=DUMP_HEADER_LEN	; BUFFER LENGTH

SAVDMPF: $FAB	DNM=<.DMP>,-		; DEFAULT NAME STRING
		FOP=SUP,-		; SUPERSEDE OLD VERSION ON CREATE
		FAC=<BIO,PUT>,-		; BLOCK I/O
		RFM=FIX,-		; RECORD FORMAT IS FIXED
		MRS=512			; 512 BYTE RECORDS

SAVDMP:: $RAB	FAB=SAVDMPF,-		; ADDRESS OF FAB BLOCK
		ROP=BIO			; BLOCK I/O ACCESS

LISTF:	$FAB	FAC=<PUT,UPD>, -	; PUT/UPDATE
		DNM=<SYSDUMP.LIS>,-	; DEFAULT NAME STRING
		MRS=133, -		; MAXIMUM RECORD SIZE
		ORG=SEQ, -		; SEQUENTIAL ORGANIZATION
		RAT=CR, -		; CR CARRIAGE CONTROL
		RFM=VAR,-		; FIXED LENGTH RECORDS
		NAM=LISTN		; ADDRESS OF NAM BLOCK

LIST::	$RAB	FAB=LISTF, -
		MBF=2, -		; DOUBLE BUFFERED
		MBC=16, -		; 16 BLOCKS AT A TIME
		RAC=SEQ, -		; SEQUENTIAL ACCESS
		RBF=LIST_BUFFER, -	; BUFFER ADDRESS
		RSZ=0, -		; EMPTY BUFFER
		UBF=LIST_BUFFER, -	; DUMMY READ BUFFER
		USZ=LIST_BUFFER_LEN, -	; BUFFER LENGTH
		ROP=WBH			; WRITE BEHIND (DOUBLE BUFFER)

LISTN:	$NAM	ESS=NAM$C_MAXRSS	; MAXIMUM EXPANDED SIZE

LOGFAB::$FAB	FAC=PUT, -		; PUT OPERATIONS
		DNM=<SYSDUMP.LOG>,-	; DEFAULT NAME STRING
		MRS=133, -		; MAXIMUM RECORD SIZE
		ORG=SEQ, -		; SEQUENTIAL ORGANIZATION
		RAT=CR, -		; CR CARRIAGE CONTROL
		RFM=VAR,-		; FIXED LENGTH RECORDS
		NAM=LOGNAM		; ADDRESS OF NAM BLOCK

LOGRAB::$RAB	FAB=LOGFAB, -
		MBF=2, -		; DOUBLE BUFFERED
		MBC=16, -		; 16 BLOCKS AT A TIME
		RAC=SEQ, -		; SEQUENTIAL ACCESS
		ROP=WBH			; WRITE BEHIND (DOUBLE BUFFER)

LOGNAM:	$NAM	ESS=NAM$C_MAXRSS	; MAXIMUM EXPANDED SIZE

INDFAB:	$FAB	FAC=GET,-		; READ OPERATIONS
		DNM=<.COM>		; DEFAULT NAME STRING

INDRAB:: $RAB	FAB=INDFAB,-		; ADDRESS OF FAB
		UBF=INPUT_BUFFER,-	; ADDRESS OF INPUT BUFFER
		USZ=INPUT_BUF_LEN	; BUFFER LENGTH

KEYFAB:	$FAB	FAC=GET,-		; READ OPERATIONS
		FNM=<SYS$LOGIN:SDA.INIT>,-; FILE NAME
		DNM=<SDA$INIT> 		; DEFAULT NAME STRING

KEYRAB:: $RAB	FAB=KEYFAB,-		; ADDRESS OF FAB
		UBF=INPUT_BUFFER,-	; ADDRESS OF INPUT BUFFER
		USZ=INPUT_BUF_LEN	; BUFFER LENGTH

OUTPUTF: $FAB	FNM=<SYS$OUTPUT>, -
		RAT=CR, -		; EACH LINE NEEDS LF/CR
		FAC=PUT			; PUT OPERATIONS ONLY

OUTPUT:: $RAB	FAB=OUTPUTF, -
		UBF=CMND_BUFFER, -	; OUTPUT BUFFER
		USZ=CMND_BUFFER_LEN	; OUTPUT BUFFER LENGTH

STBF::	$FAB	FNM=<SYS.STB;0>, -
		FAC=GET			; GET OPERATIONS ONLY

STB::	$RAB	FAB=STBF, -
		UBF=STB_BUFFER, -	; BUFFER ADDRESS
		USZ=STB_BUFFER_LEN	; BUFFER LENGTH

	.PSECT	MAIN,EXE,NOWRT,LONG

	.SBTTL	READ-ONLY DATA DEFINITIONS

;
;	READ-ONLY DATA DEFINITIONS
;

SYSTEM_ENTITY:
	.ASCID	'SYSTEM'
CRASH_ENTITY:
	.ASCID	'CRASH_DUMP'
DUMPFILE_ENTITY:
	.ASCID	'DUMP_FILE'
SYMBOLS_ENTITY:
	.ASCID	'SYMBOLS'

DEV_PROMPT:
	.ASCID	<10>'Enter name of dump file > '

SDA_PROMPT:
	.ASCID	<10>'SDA> '

SYS$SYSTEM:
	.ASCID	'SYS$SYSTEM:'

STARTUP:
	.ASCII	'STARTUP'		; NAME OF STARTUP PROCESS
STARTUP_LEN = . - STARTUP

SYSINPUT:
	.ASCID	/SYS$INPUT/		; 

	.SBTTL	MAIN PROGRAM
;---
; 	START - MAIN PROGRAM ENTRY POINT
;
;	CALL INITIALIZATION ROUTINES AND FORMAT THE SYSTEM DUMP
;	BY CALLING THE INDIVIDUAL FORMATTING ROUTINES ONE AT A
;	TIME.
;---

	.ENABL	LSB

	.ENTRY	START,^M<R2,R9>

	MOVAB	HANDLER,(FP)		; INITIALIZE CONDITION HANDLER
	CALLS	#0,W^OPEN_FILES		; OPEN INPUT/OUTPUT FILES
	CALLS	#0,MAP_DUMP		; MAP DUMP INTO VIRTUAL MEMORY
	CALLS	#0,READ_SYMBOLS		; READ SYSTEM SYMBOL TABLE
	CALLS	#0,GET_DUMP_INFO	; GET DUMP FILE INFORMATION
	CALLS	#0,W^EXIT_IF_OLD	; IF OLD DUMP AT STARTUP TIME

	SKIP	PAGE			; ERASE SCREEN
	BLBC	CURRENT_SYSTEM,3$	; BRANCH IF ANALYZING A DUMP
	PRINT	0,<VAX/VMS System analyzer>
;	PUSHL	#0
;	PRINT	1,<!17%D>
	BRB	8$

3$:	PRINT	0,<VAX/VMS System dump analyzer>
	PRINT	0,< >
	MOVL	ERLPTR,R9		; ADDRESS OF ERROR LOG ENTRY
	$ASCTIM_S TIMADR=EMB$Q_CR_TIME(R9),TIMBUF=CURRENT_TIME
	PUSHAQ	CURRENT_TIME
	PRINT	1,<Dump taken on !AS>
	ASHL	#-3,EMB$L_CR_CODE(R9),R0	; MESSAGE NUMBER
	BEQL	8$			; BRANCH IF NO MESSAGE
	MOVAB	BUG$T_MESSAGES,R1	; ADDRESS OF MESSAGES
5$:
	MOVZBL	(R1)+,R2		; LENGTH OF MESSAGE
	ADDL2	R2,R1			; SKIP TO NEXT MESSAGE
	SOBGTR	R0,5$			; LOOP UNTIL FOUND
	PUSHL	R1			; ADDRESS OF BUGCHECK MESSAGE
	PRINT	1,<!AC>
8$:
	PRINT	0,<>			; BLANK LINE
;
;	SET CURRENT PROCESS = PROCESS THAT CRASHED
;
	CALLS	#0,CURPROC		; SET TO CURRENT PROCESS
;
; 	PROCESS SDAINI FILE
;
	TSTL	INPUT_RAB		; SEE IF SDAINI FOUND
	BEQL	20$			; NOT IF ZERO
10$:
	CLRL	LINE_COUNT		; AVOID END OF PAGE PROMPTS
	CALLS	#0,GET_COMMANDS		; ACCEPT AND EXECUTE COMMANDS
	BLBS	R0,10$			; CONTINUE UNTIL ERROR
	CLRL	INPUT_RAB		; CLEAR SDAINI RAB
;
;	ACCEPT COMMANDS UNTIL END OF FILE
;
20$:
	MOVL	#1,CLR_PAGE		; CLEAR PAGE ON MSG$_EXITCMD
	CLRL	LINE_COUNT		; AVOID END OF PAGE PROMPTS
	CALLS	#0,GET_COMMANDS		; ACCEPT AND EXECUTE COMMANDS
	CMPL	R0,#MSG$_EOF		; CHECK IF END OF FILE
	BEQL	50$			; BRANCH IF SO
	CMPL	R0,#MSG$_EXITCMD	; DID WE JUST EXIT A LEVEL?
	BNEQ	20$			; BRANCH IF NOT
	CLRQ	SUB_HEADING		; CLEAR CURRENT HEADING
	CLRL	HEADING_ROUTINE		; CLEAR HEADING ROUTINE ADDRESS
	TSTL	CLR_PAGE		; IF ZERO, DON'T CLEAR PAGE
	BEQL	20$			; 
	SKIP	PAGE			; ERASE PREVIOUS JUNK
	BRB	20$
50$:
	TSTL	OUTPUT_FILE		; OUTPUT FILE SPECIFIED?
	BEQL	90$			; BRANCH IF NOT
	CALLS	#0,PRINT_INDEX		; PRINT TABLE OF CONTENTS
90$:
	CALLS	#0,MARK_DUMP		; MARK DUMP ANALYZED
	STATUS	SUCCESS
	RET

	.DSABL	LSB

	.SBTTL	OPEN_FILES - OPEN INPUT/OUTPUT FILES
;---
;	OPEN_FILES
;
;	THE FOLLOWING FILES WILL BE OPENED:
;
;	 - SYSTEM DUMP FILE (SYSDUMP.DMP)
;	 - SYSTEM SYMBOL TABLE (SYS.STB)
;	 - COMMAND FILE FOR RUN-TIME OPTIONS
;
;---

	.ENTRY	OPEN_FILES,^M<R2,R3,R4,R5,R6>
	;
	; Use screen management routines for input.
	; RMS will be used by the RTL in SYS$INPUT is a file.
	;	
	pushab	SYSINPUT		; SYS$INPUT
	pushab	keyboard		; keyboard id
	calls	#2,G^SMG$CREATE_VIRTUAL_KEYBOARD ; create (open) keyboard
	SIGNAL
	
	pushab	keytable		; keypad table
	calls	#1,G^SMG$CREATE_KEY_TABLE ; create keypad table
	SIGNAL
	;
	; Try to open a file defined by the logical name ??? SDA$KEYPAD ???
	;
	$OPEN	KEYFAB			; try open
	BLBC	R0,10$			; continue if error
	$CONNECT KEYRAB			; try connect
	BLBC	R0,10$			; continue if error
	MOVAB	KEYRAB,INPUT_RAB	; make it look like this
					; was an "@filespec"
10$:
	$CREATE	OUTPUTF			; OPEN OUTPUT FILE
	SIGNAL	RMS,OUTPUTF
	$CONNECT OUTPUT
	SIGNAL	RMS,OUTPUT

	$GETDVI_S DEVNAM = SYSINPUT,-	
		ITMLST = DVI_ITMLST	; GET DEVICE DEPENDENT INFO
	SIGNAL

	MOVZBL	DVI_PAGESIZE,R0		; GET PAGE SIZE
	SUBL3	#PROMPT_LINES,R0,PAGE_SIZE	; SET PAGE SIZE

	BBS	#DEV$V_TRM,DVI_DEVCHAR,40$
	CLRL	DVI_DEVDEPEND		; Clear if not terminal
40$:	
;
;	If the command line entities SYSTEM or CRASH_DUMP are defined
;	and "present", initialize as "current system" or dump file
;	respectively.
;
	clrl	r6			;set DCL flag = .FALSE.
	subl	#cli$c_reqdesc,sp	; Allocate old CLINT request block
	movc5	#0,(sp),#0,#cli$c_reqdesc,(sp) ; Zero request block
	movab	dumpf,r3		; Set address of DUMP FAB 
	movb	#cli$k_getcmd,cli$b_rqtype(sp) ; Set "get command" request
	pushl	sp			; Push address of request descriptor
	calls	#1,g^sys$cli		; Call old CLI interface for verb type
	blbc	r0,80$			; Branch if not a DCL command
	cmpb	cli$b_rqstat(sp),#cli$k_verb_fore ; Foreign command?
	beql	80$			; Branch if so
	cmpb	cli$b_rqstat(sp),#cli$k_verb_mcr  ; or MCR command?
	beql	80$			; Branch if so

	pushab	system_entity		; address of entity descriptor
	calls	#1,g^cli$present	; Check if /SYSTEM specified
	blbs	r0,60$			; branch if present
	pushab	crash_entity		; address of entity descriptor
	calls	#1,g^cli$present	; Check if /CRASH_DUMP specified
	blbc	r0,80$			; branch if absent
	pushab	dumpfile_entity		; address of entity descriptor
	calls	#1,g^cli$present	; Check if dump filespec present
	blbc	r0,80$			; Branch if absent
	clrq	-(sp)			; Recieve buffer descriptor
	movb	#dsc$k_class_d,dsc$b_class(sp) ; Set to dynamic desc.
	pushl	sp			; address of return buffer
	pushab	dumpfile_entity		; address of entity descriptor
	calls	#2,g^cli$get_value	; Get dump filespec from command line
	blbc	r0,80$			; Branch if absent
	movb	(sp),fab$b_fns(r3)	; set length of filespec
	movl	4(sp),fab$l_fna(r3)	; set address of filespec
	clrq	-(sp)			; Recieve buffer descriptor
	movb	#dsc$k_class_d,dsc$b_class(sp) ; Set to dynamic desc.
	pushl	sp			; address of return buffer
	pushab	symbols_entity		;address of symbols descriptor
	calls	#2,g^cli$get_value	;Check if /SYMBOLS specified and 
					;   get its value if it was.
	bisb2	#1,r6			;set DCL flag = .TRUE.
	brw	200$			; and open dump/stb files

60$:	brb	140$			; analyze current running system
;
;	Attempt to get file name from foreign command line
;
80$:
	movab	dev_prompt,smg_prompt	; Prompt descriptor

	clrq	-(sp)			; Recieve buffer descriptor
	movb	#dsc$k_class_d,dsc$b_class(sp) ; Set to dynamic desc.
	pushab	dev_prompt		; Address of prompt desc.
	pushab	4(sp)			; Address of buffer desc.
	calls	#2,G^lib$get_foreign	; Get the command line
	blbc	r0,160$			; branch if any error
	movb	(sp),fab$b_fns(r3)	; set length of filespec
	movl	4(sp),fab$l_fna(r3)	; set address of filespec
	brb	120$			; Process command line
100$:
	;
	; Loop to here to try another dump file prompt
	;
	bsbw	get_input		; Get one line of input
	movb	input_len,fab$b_fns(r3)	; set length of filespec
	movab	input_buffer,fab$l_fna(r3); set address of filespec
120$:
	CLRL	CURRENT_SYSTEM		; PRESET TO NON-CURRENT SYS.
	CMPB	fab$b_fns(R3),#1	; MUST BE EXACTLY 1 CHAR.
	BNEQ	160$			; BRANCH IF NOT
	CMPB	@fab$l_fna(R3),#^A'*'	; SEE CURRENT RUNNING SYSTEM?
	BNEQ	160$			; BRANCH IF NOT
140$:	MOVL	#1,CURRENT_SYSTEM	; EXAMINE CURRENT SYSTEM
	MOVAB	STBF,R4			; SETUP R4 FOR STB CODE
	BRW	340$			; OPEN STB FILE
160$:
	CMPL	R0,#RMS$_EOF		; CHECK IF END OF FILE
	BNEQ	180$			; BRANCH IF NOT
	INSV	#STS$K_SEVERE, -	; MUST EXIT IMAGE IF EOF
		#STS$V_SEVERITY,#STS$S_SEVERITY,R0
180$:
	SIGNAL
200$:
	MOVAB	DUMPF,R3		; ADDRESS OF FAB
	MOVL	FAB$L_NAM(R3),R5	; ADDRESS OF NAM BLOCK
	TSTB	FAB$B_FNS(R3)		; TEST SIZE
	BNEQ	220$			; BRANCH IF NON-EMPTY STRING
	MOVL	SYS$SYSTEM+4,FAB$L_FNA(R3)	; GET FROM SYS$SYSTEM
	MOVB	SYS$SYSTEM,FAB$B_FNS(R3)
220$:
	$OPEN	(R3)			; ATTEMPT TO OPEN THE FILE
	BLBS	R0,240$
	MOVL	FAB$L_STV(R3),R1	; SECONDARY ERROR CODE
	BRB	260$			; AND OUTPUT ERROR MESSAGE
240$:
	$CONNECT DUMPR
	BLBS	R0,300$			; BRANCH IF SUCCESSFUL
	MOVL	DUMPR+RAB$L_STV,R1
260$:
	PUSHL	NAM$L_ESA(R5)		; DESCRIPTOR OF FILE NAME
	MOVZBL	NAM$B_ESL(R5),-(SP)
	MOVQ	R0,-(SP)		; PUSH RMS ERROR CODES
	PUSHAB	8(SP)			; ADDRESS OF DESCRIPTOR
	PUSHL	#1			; NUMBER OF FAO ARGUMENTS
	PUSHL	#MSG$_OPENIN		; ERROR OPENING INPUT FILE
;***	TSTB	RAB$B_PSZ(R2)		; ARE WE PROMPTING FOR FILESPEC?
;***	BEQL	280$			; IF NOT, EXIT PROGRAM ON ANY ERROR
;***	INSV	#STS$K_WARNING, -	; CHANGE SEVERITY TO WARNING
;***		#STS$V_SEVERITY,#STS$S_SEVERITY,(SP)

280$:	CALLS	#5,G^LIB$SIGNAL		; OUTPUT ERROR MESSAGE
	ADDL	#8,SP			; REMOVE DESCRIPTOR FROM STACK
	BRW	100$			; ALLOW USER TO TRY AGAIN

300$:
	MOVAB	STBF,R4
	BLBC	R6,320$			;INVOKED VIA DCL?
	TSTW	(SP)			;WAS /SYMBOLS NONBLANK?
	BEQL	340$			;NO, SO USE SYS$SYSTEM:
	MOVB	FAB$B_FNS(R4),FAB$B_DNS(R4) ;MAKE "SYS.STB;0" THE DEFAULT FILE
	MOVL	FAB$L_FNA(R4),FAB$L_DNA(R4)
	MOVL	4(SP),FAB$L_FNA(R4)	;USER SUPPLIED DIRECTORY SPEC
	MOVB	(SP),FAB$B_FNS(R4)	;  TAKEN FROM THE /SYMBOLS QUAL.
	BRW	360$			;ATTEMPT TO OPEN THE FILE
320$:
	MOVL	NAM$L_ESA(R5),FAB$L_DNA(R4)  ; SET DEFAULT FROM DUMP
	MOVB	NAM$B_ESL(R5),FAB$B_DNS(R4)
	$OPEN	(R4)			; OPEN THE STB FILE
	CMPL	R0,#RMS$_FNF		; CHECK IF STB FILE THERE
	BNEQ	380$			; BRANCH IF OK
340$:	MOVL	SYS$SYSTEM+4,FAB$L_DNA(R4)	; SET TO TRY SYS$SYSTEM
	MOVB	SYS$SYSTEM,FAB$B_DNS(R4)

360$:	$OPEN	(R4)			; OPEN THE STB FILE
380$:	BLBS	R0,400$			; BRANCH IF SUCCESSFUL
	PUSHL	FAB$L_FNA(R4)		; DESCRIPTOR OF FILE NAME
	MOVZBL	FAB$B_FNS(R4),-(SP)
	PUSHL	FAB$L_STV(R4)		; PUSH RMS SECONDARY STATUS
	PUSHL	R0			; PUSH RMS PRIMARY STATUS
	PUSHAB	8(SP)			; ADDRESS OF DESCRIPTOR
	PUSHL	#1			; NUMBER OF FAO ARGUMENTS
	PUSHL	#MSG$_OPENIN		; ERROR OPENING INPUT FILE
	CALLS	#5,G^LIB$SIGNAL		; OUTPUT ERROR MESSAGE
	ADDL	#8,SP			; REMOVE DESCRIPTOR FROM STACK

400$:	$CONNECT STB
	SIGNAL	RMS,STB
;
; SET UP TERMINAL HANDLING IF SYS$INPUT IS A TERMINAL
;
	BBC	#DEV$V_TRM,DVI_DEVCHAR,420$ ; EXIT IF NOT TERMINAL

	$ASSIGN_S CHAN = TT_CHAN -
		DEVNAM = SYSINPUT	; SYS$INPUT
	BLBC	R0,420$			; BRANCH ON ERROR
	$QIOW_S CHAN = TT_CHAN -
		FUNC = #IO$_SETMODE!IO$M_CTRLCAST -
		P1 = CTRL_C_AST 	; AST ROUTINE
420$:
	movab	sda_prompt,smg_prompt	; Prompt descriptor

	RET


	.SBTTL	GET_INPUT - Get one line of input using RTL
;---
;
; This routine calls SMG$READ_COMPOSED_LINE and is provided for
; any read to SYS$INPUT.
;
;
; INPUTS:
;
;	SMG_PROMPT - loaded with address of prompt to be used.
;
; OUTPUTS:
;
;	INPUT_BUF - descriptor of input
;	INPUT_LEN - length of input
;
;+++

GET_INPUT::

	clrl	-(SP)			; display ID
	pushab	input_len		; input length
	pushl	smg_prompt		; pre-loaded address of prompt
	pushab	input_buf		; input buffer descriptor
	pushab	keytable		; key definition table
	pushab	keyboard		; keyboard ID
	calls	#6,G^SMG$READ_COMPOSED_LINE ; read file spec
	RSB


	.SBTTL	CTRL_C_AST - Handle Control C AST routine

;+++
;
;	This routine is called as an ast routine whenever ^C (cancel)
;	is typed. The routine signals MSG$_EXITCMD and exits.
;
;
;	0(AP) is zero if called to fake ^C.
;
;---

CTRL_C_AST:
	.WORD	0
	
	TSTL	(AP)			; test for fake ^C
	BEQL	10$			; no need to re-enable ^C 
;
; It would be nice for this to be an out of band, rather than a 
; simple ^C enable. This prevents the ^Y window. For right now however,
; an out of band cannot cancel I/O, so until that work is done...
;
	$QIOW_S CHAN = TT_CHAN -
		FUNC = #IO$_SETMODE!IO$M_CTRLCAST -
		P1 = CTRL_C_AST 	; AST ROUTINE
;
; If a $PUT is active, just flag ^C pending
;
	BLBC	PUT_BUSY,10$		; branch if ok to signal
	MOVB	#1,CTRLC_PENDING	; set flag
	RET				; and exit

10$:	CLRB	CTRLC_PENDING		; CLEAR PENDING FLAG
	CLRL	LINE_COUNT		; CLEAR SO NO CONTINUE PROMPT
	CLRL	CLR_PAGE		; CLEAR TO AVOID PAGE ERASE
	SIGNAL	0,EXITCMD		; EXIT MESSAGE
	RET				; RET


	.SBTTL	EXIT_IF_OLD - EXIT IF OLD DUMP AT STARTUP TIME
;---
;
;	THIS ROUTINE WILL EXIT THE PROGRAM IF WE ARE CALLED
;	FROM STARTUP.COM AT BOOT TIME AND IF THE DUMP HAS
;	ALREADY BEEN ANALYZED.  OPERATOR SHUTDOWN CRASHES
;	ARE ALSO IGNORED AS THEY DO NOT CONSTITUTE A REAL
;	CRASH.
;
;   INPUTS:
;
;	DUMP_HEADER CONTAINS THE DUMP HEADER BLOCKS
;	ERLPTR CONTAINS A POINTER TO THE ERROR LOG ENTRY
;
;   OUTPUTS:
;
;	NONE
;
;---

	.ENTRY	EXIT_IF_OLD,^M<R2>

;
;	CHECK IF WE ARE IN SYSTEM STARTUP PROCEDURE
;

	ALLOC	15,R2			; ALLOCATE 15 BYTE BUFFER
	CLRL	-(SP)			; CREATE GETJPI REQUEST LIST
	PUSHL	R2			; ADDRESS TO RECEIVE LENGTH
	PUSHL	4(R2)			; ADDRESS OF OUTPUT BUFFER
	PUSHL	#<JPI$_PRCNAM@16>!15	; REQUEST CODE AND BUFLTH
	MOVL	SP,R1
	$GETJPI_S ITMLST=(R1)		; GET NAME OF THIS PROCESS
	SIGNAL
	CMPC5	(R2),@4(R2),#^A' ',#STARTUP_LEN,STARTUP
	BNEQ	90$			; BRANCH IF NOT STARTUP TIME

;
;	EXIT IF DUMP HAS ALREADY BEEN ANALYZED OR IS EMPTY
;
	BITW	#<<1@DMP$V_OLDDUMP> ! <1@DMP$V_EMPTY>>,-
		 DUMP_HEADER+DMP$L_FLAGS
	BNEQ	20$

;
;	... OR IF OPERATOR SHUTDOWN
;
	MOVL	ERLPTR,R1		; ADDRESS OF ERROR LOG ENTRY
	BICL3	#7,EMB$L_CR_CODE(R1),R1	; GET BUGCHECK CODE OF CRASH
	CMPL	R1,#BUG$_OPERATOR	; CHECK IF OPERATOR SHUTDOWN
	BNEQ	90$			; BRANCH IF NOT
;
;	EXIT THE IMAGE - FLUSH THE REMAINING INPUT COMMANDS
;
20$:
	BBS	#DEV$V_TRM,DVI_DEVCHAR,40$ ; SKIP IF TERMINAL
30$:
	BSBW	GET_INPUT		; Get input line
	BLBS	R0,30$			; CONTINUE UNTIL ALL DATA READ
40$:
	$EXIT_S				; EXIT THE IMAGE
90$:
	STATUS	SUCCESS
	RET

	.SBTTL	PAGE_WAIT - GIVE END-OF-PAGE PROMPT ON SCREEN
;---
;
;	PAGE_WAIT
;
;	THIS ROUTINE CAUSES AN END-OF-PAGE PROMPT TO BE GIVEN
;	ON THE BOTTOM OF THE SCREEN.  IF THE USER SIMPLY HITS
;	RETURN, HE WILL CONTINUE OUT OF THIS ROUTINE TO PRINT
;	THE NEXT PAGE.  IF HE ENTERS SOME OTHER COMMAND, THE
;	CURRENT COMMAND WILL BE ABORTED.
;
; INPUTS:
;
;	IF LINE_COUNT = 0, NO PROMPT WILL BE ISSUED.
;
;---

	.ENABL	LSB

	.ENTRY	PAGE_WAIT,^M<R2,R3,R4,R5>

	TSTL	OUTPUT_FILE		; CHECK IF ANY OUTPUT FILE
	BNEQ	5$			; SKIP IF LISTING FILE
	BBC	#TT$V_SCOPE,DVI_DEVDEPEND,5$ ; SKIP SCROLLING
	TSTL	LINE_COUNT		; 0 FORCES NO PROMPT
	BNEQ	10$			; BRANCH IF PROMPT WANTED
5$:	RET
10$:
	CLRL	LINE_COUNT		; CLEAR BEFORE ANYTHING ELSE
	SKIP	<PROMPT_LINES-1>	; MOVE UP IF SCROLLING
	PUSHL	#1			; COLUMN 1
	MOVZBL	DVI_PAGESIZE,R0		; GET PAGE SIZE
	SUBL3	#<PROMPT_LINES-1>,R0,-(SP)	; 2ND FROM BOTTOM LINE
	CALLS	#2,G^SCR$SET_CURSOR	; SET CURSOR POSITION
	PRINT	0,<    Press RETURN for more.>

	MOVL	INPUT_LEN,SAVE_INPUT_LEN; SAVE CURRENT COMMAND LINE LENGTH
	MOVC3	INPUT_LEN,INPUT_BUFFER,-; SAVE THE CURRENT COMMAND LINE
		SAVE_INPUT_BUFFER	; BEFORE PROMPTING FOR COMMAND
	CALLS	#0,GET_COMMANDS		; PROMPT FOR COMMAND
	BLBC	R0,14$			; BRANCH IF EMPTY LINE
13$:
	SIGNAL	0,BACKUP		; SILENTLY ABORT COMMAND
14$:
	CMPL	R0,#MSG$_BACKUP		; ARE WE BACKING UP?
	BEQL	13$			; CONTINUE BACK TO MAIN LEVEL
	CMPL	R0,#MSG$_EOF		; CHECK IF END OF FILE (EXIT)
	BEQL	15$			; BRANCH IF SO
	CMPL	R0,#MSG$_EXITCMD	; ARE WE EXITING COMMAND?
	BEQL	15$			; BRANCH IF SO
	MOVL	SAVE_INPUT_LEN,INPUT_LEN; RESTORE CURRENT COMMAND LINE LENGTH
	MOVC3	INPUT_LEN,-		; WE ARE CONTINUING WITH THE CURRENT
		SAVE_INPUT_BUFFER,-	; COMMAND SO RESTORE THE CONTENTS OF
		INPUT_BUFFER		; THE INPUT BUFFER TO ITS PRIOR STATE
    	
	RET
15$:
	SIGNAL	0,EXITCMD		; EXIT AND ERASE SCREEN

	.SBTTL	NEW_PAGE - BEGIN A NEW PAGE ON THE LISTING
;---
;
;	NEW_PAGE
;
;	THIS ROUTINE WILL CAUSE A NEW PAGE TO BE WRITTEN AND
;	WILL OUTPUT THE PAGE HEADING AND CURRENT SUB-HEADING.
;
;   INPUTS:
;
;	PAGE_NUMBER = CURRENT PAGE NUMBER
;
;   OUTPUTS:
;
;	PAGE_NUMBER IS UPDATED
;	LINE_COUNT IS INITIALIZED
;
;---

	.ENABL	LSB

	.ENTRY	NEW_PAGE,^M<>

	TSTL	SUB_HEADING		; ANY SUB-HEADING?
	BEQL	10$			; SKIP CHECK IF NOT
	CMPL	LINE_COUNT,HEADING_LINES ; ANY NEW LINES BESIDES TITLE?
	BEQL	90$			; IF NOT, SKIP PAGE EJECT
10$:
	CALLS	#0,PAGE_WAIT		; GIVE BOTTOM OF PAGE PROMPT
	CLRL	LINE_COUNT		; CLEAR BEFORE ANYTHING ELSE
	INCL	PAGE_NUMBER		; INCREMENT PAGE NUMBER
	TSTL	OUTPUT_FILE		; CHECK IF LISTING FILE
	BEQL	50$			; NO HEADINGS IF NOT
	PRINT	0,<!^>			; PRINT FORM FEED
	PUSHL	PAGE_NUMBER
	PUSHAQ	CURRENT_TIME
	PRINT	2,<VAX/VMS 4.0 -- System Dump Analysis!_!_!_!_!_!AS!_!_!_Page !UL>
	PUSHAQ	SUB_HEADING		; SECTION HEADING
	PRINT	1,<!AS>
	SKIP	3			; 3 BLANK LINES
60$:
	TSTL	HEADING_ROUTINE		; ANY HEADING ROUTINE?
	BEQL	90$			; BRANCH IF NOT
	CALLS	#0,@HEADING_ROUTINE	; CALL THE ROUTINE
90$:
	MOVL	LINE_COUNT,HEADING_LINES ; REMEMBER # HEADING LINES
	RET
50$:
;	SKIP SUB-HEADING IF NOT SCREEN ORIENTED DEVICE
	BBC	#TT$V_SCOPE,DVI_DEVDEPEND,90$ ; 
	PUSHL	#1			; FROM COLUMN 1
	PUSHL	#1			; LINE 1
	CALLS	#2,G^SCR$ERASE_PAGE	; ERASE ENTIRE SCREEN
	PUSHAQ	SUB_HEADING		; SECTION HEADING
	PRINT	1,<!AS>
	MOVZWL	SUB_HEADING,-(SP)	; CHARACTERS IN HEADING
	PRINT	1,<!#*->
	BRB	60$

	.DSABL	LSB

	.PAGE
	.SBTTL	PRINT -- FORMAT AND PRINT A SINGLE LINE
;---
;
;	PRINT
;
;	THIS ROUTINE IS INVOKED FROM THE PRINT MACRO TO FORMAT
;	AND PRINT A SINGLE LINE.
;
;   INPUTS:
;
;	 4(AP) = ADDRESS OF CONTROL STRING
;	 8(AP) = FAO PARAMETERS (AS MANY AS NEEDED)
;
;   OUTPUTS:
;
;	NONE
;
;---

	.ENTRY	PRINT,^M<>

	PUSHAL	8(AP)			; ADDRESS OF PARAMETER LIST
	PUSHAQ	LINE_DESCR		; BUFFER DESCRIPTOR
	PUSHAL	LIST+RAB$W_RSZ		; TO RECEIVE LENGTH OF LINE
	PUSHL	4(AP)			; ADDRESS OF CONTROL STRING
	CALLS	#4,G^SYS$FAOL		; FORMAT LINE
	CALLS	#0,B^PUT_LINE		; OUTPUT LINE
	RET

	.PAGE
	.SBTTL	PUT_LINE - OUTPUT A LINE TO THE LISTING FILE
;---
;
;	PUT_LINE
;
;	THIS ROUTINE OUTPUTS A SINGLE PRINT LINE TO THE LISTING
;	FILE.  THE NUMBER OF LINES ON THE PAGE IS ACCOUNTED FOR
;	AND A NEW PAGE WILL BE ISSUED WHEN THE PAGE IS FULL.
;
;   INPUTS:
;
;	LINE_COUNT	= NUMBER OF LINES ON CURRENT PAGE
;
;   OUTPUTS:
;
;	LINE_COUNT IS UPDATED
;
;---

	.ENABL	LSB

	.ENTRY	PUT_LINE,^M<R2,R3,R4,R5,R6,R7,R8>

	MOVB	#1,PUT_BUSY		; flag "Put Busy"
	MOVAL	LINE_COUNT,R6		; ADDRESS OF LINE COUNT
	MOVAL	LIST,R8			; ADDRESS OF LIST RAB
	CLRL	R7			; R7=0 IF TERMINAL OUTPUT
	TSTL	OUTPUT_FILE		; OUTPUT FILE SPECIFIED?
	BEQL	10$			; BRANCH IF NOT
	MOVL	#1,R7			; R7=1 IF LISTING OUTPUT
10$:
	INCL	(R6)			; ASSUME 1 LINE PRINTED
	BLBS	R7,5$			; BRANCH IF LISTING FILE
	CMPW	RAB$W_RSZ(R8),DVI_DEVBUFSIZ
					; CHECK IF OVER SIZE OF SCREEN
	BLEQU	5$			; BRANCH IF OK
	INCL	(R6)			; ACCOUNT FOR 2 LINES
5$:
	CMPL	(R6),PAGE_SIZE
	BLEQ	20$			; BRANCH IF STILL ROOM
	TSTL	PAGE_SIZE		; CHECK IF VALID PAGE SIZE
	BLEQ	20$			; BRANCH IF NO PAGE SIZE (FILE)
	MOVW	RAB$W_RSZ(R8),-(SP)	; SAVE LINE LENGTH
	SUBL2	#LIST_BUFFER_LEN,SP	; ALLOCATE SPACE FOR LINE
	MOVC3	#LIST_BUFFER_LEN,LIST_BUFFER,(SP)  ; SAVE LINE
	SKIP	PAGE
	MOVC3	#LIST_BUFFER_LEN,(SP),LIST_BUFFER  ; RESTORE LINE
	ADDL2	#LIST_BUFFER_LEN,SP	; DEALLOCATE SPACE
	MOVW	(SP)+,RAB$W_RSZ(R8)	; RESTORE LINE LENGTH
	BRW	10$			; TRY AGAIN
20$:
	BLBS	R7,50$			; BRANCH IF LISTING FILE
	MOVAB	OUTPUT,R2
	MOVW	RAB$W_RSZ(R8),RAB$W_RSZ(R2)
	MOVL	LINE_DESCR+4,RAB$L_RBF(R2)
	$PUT	(R2)			; OUTPUT TO TERMINAL
	SIGNAL	RMS,(R2)

	BLBC	RAB$L_STS(R2),100$	; OUTPUT TO LOGFILE IF LOGGING ENABLED
	TSTB	LOG_FILE		; AND OUTPUT TO TERMINAL SUCCEEDED
	BEQL	100$
	MOVAB	LOGRAB,R2
	MOVW	RAB$W_RSZ(R8),RAB$W_RSZ(R2)
	MOVL	LINE_DESCR+4,RAB$L_RBF(R2)
	$PUT	(R2)
	SIGNAL	RMS,(R2)
	BRB	100$
50$:
	$PUT	(R8)			; OUTPUT RECORD TO THE FILE
	SIGNAL	RMS,(R8)
	MOVC5	#0,(SP),#^A' ',#LIST_BUFFER_LEN,LIST_BUFFER
	CLRW	RAB$W_RSZ(R8)		; RESET TO EMPTY LINE
	STATUS	SUCCESS
100$:
	;
	; clear "Put Busy" and check for ^C pending flag
	;
	CLRB	PUT_BUSY
	BLBS	CTRLC_PENDING,110$
	RET
110$:	
	CALLS	#0,CTRL_C_AST		; fake ^C operation
	RET

	.DSABL	LSB

	.PAGE
	.SBTTL	SKIP_LINES - SKIP ANY NUMBER OF BLANK LINES
;---
;
;	SKIP_LINES
;
;	THIS ROUTINE WILL OUTPUT A SPECIFIED NUMBER OF BLANK
;	LINES TO THE LISTING FILE.
;
;   INPUTS:
;
;	4(AP)	= THE NUMBER OF LINES TO SKIP
;
;   OUTPUTS:
;
;	THE BLANK LINES ARE OUTPUT
;
;---

	.ENTRY	SKIP_LINES,^M<>

	TSTL	4(AP)			; CHECK IF ALREADY DONE
	BEQL	90$
10$:
	CLRW	LIST+RAB$W_RSZ		; EMPTY LINE
	CALLS	#0,PUT_LINE		; OUTPUT A BLANK LINE
	SOBGTR	4(AP),10$
90$:
	RET

	.SBTTL	PRINT_COLUMNS -- PRODUCE COLUMNAR OUTPUT
;---
;
;	PRINT_COLUMNS
;
;	Based upon input parameters, tables, and action routine outputs, this 
;	routine produces multi-column displays.  This routine has the 
;	following major features:
;
;	  o it is entirely input driven
;
;	  o an action routine my signal that the entry it is preparing is not
;	    to be included in this display.  This will result in the 
;	    successive column entries in that column being moved up one row.
;
;	  o ragged bottoms of columns are properly handled.
;
;	It is assumed that each column is to contain three sections, a text 
;	description of a value followed by the value followed by a spacer to 
;	the next column.
;
;   INPUTS:
;
;	      (AP)	number of arguments [ (AP)-((COLLS1/4)-1) gives the 
;			number of columns]
;	DATBAS(AP)	base address for data structure against which offsets apply
;	DATSVA(AP)	system virtual address of data structure
;			(used only on queue header processing)
;	COLLS1(AP)	base address of the COLUMN_LIST for column 1
;	COLLS1+4(AP)	base address of the COLUMN_LIST for column 2
;	COLLS1+8(AP)	base address of the COLUMN_LIST for column 3
;	  .		  .
;	  .		  .
;	  .		  .
;
;   OUTPUTS:
;
;	NONE
;
;   Description of the COLUMN_LIST macro:
;
;   Format:
;
; BASE:	COLUMN_LIST -
;		prefix, df-desc-size, df-val-size, df-sep-size, < -
;		-				; row 1 description this column
;		<<string>,offset,type,desc-size,val-size,sep-size>, -
;		-				; row 2 description this column
;		<<string>,action,value,desc-size,val-size,sep-size>, -
;		-				; row 3 description this column
;		<<string>,offset,type,desc-size,val-size,sep-size>, -
;			.					.
;			.					.
;			.					.
;		>
;
;    Where:
;
;	prefix		is the data structure prefix
;	df-desc-size	is the default description string size for this column
;	df-val-size	is the default value string size for this column
;	df-sep-size	is the default seperator size for this column
;	string		is the description string for an entry
;	offset		is the data structure offset name for the value 
;			    (w/o the prefix)
;	type		is one of the following FAO directives w/o the "!"
;			    AC, AS, OB, OW, OL, XB, XW, XL, ZB, ZW, ZL, 
;			    UB, UW, UL, SB, SW, or SL
;			the following types cause conversion only if the
;			    value is not zero:
;			    OB_NEQ, OW_NEQ, OL_NEQ, XB_NEQ, XW_NEQ, XL_NEQ, 
;			    ZB_NEQ, ZW_NEQ, ZL_NEQ, UB_NEQ, UW_NEQ, UL_NEQ, 
;			    SB_NEQ, SW_NEQ, and SL_NEQ
;			the following special codes are also available:
;			    Q2  - doubly-linked queue header (does not work 
;				with DO_COLUMN_ENTRY macro)
;	action		is an action routine name
;	value		is a longword value to be passed to the action routine
;	desc-size	over-rides df-desc-size on this entry
;	val-size	over-rides df-val-size on this entry
;	sep-size	over-rides df-sep-size on this entry
;
;    Action Routine Inputs:
;
;	R2		value from the COLUMN_LIST entry
;	R5		size of the value field for this entry
;	R7		address of a descriptor for the scratch string in
;			which the FAO converted value is to be returned
;	R11		base address of the data structure from DATBAS(AP)
;
;    Action Routine Outputs:
;
;	R0		status
;			  lbs ==> use this entry
;			  lbc ==> skip this entry
;	R1 - R5		scratch
;			all other registers must be preserved
;
;    Action routines may also use the DO_COLUMN_ENTRY macro to access any
;    of the conversion services available through the COLUMN_LIST type
;    parameter.
;
;    Invocation:
;
;	DO_COLUMN_ENTRY	type [,jump]
;
; Parameters:
;
;	type	FAO type (anything valid in the COLUMN_LIST macro, except Q2, 
;		is valid here)
;	jump	JMP or JSB controlling transfer to subroutine
;		(JSB is the default: if JMP is used control does not return
;		to the action routine)
;
; Inputs:
;
;	R2	address of the datum or its descriptor
;	R5	field size (as input to the action routine)
;---

	$OFFSET	4,POSITIVE,< -			; Argument list offsets:
		DATBAS, -
		DATSVA, -
		COLLS1 -
		>

	.SAVE
	.PSECT	LITERALS,EXE,NOWRT

ONE_COL:
	STRING	<!#AC!#AS!#* >

NULL_ASCID:				; A null .ASCID string
NULL_ASCIC:				; A null .ASCIC string
	.LONG	0, 0

	.RESTORE

	$OFFSET	-4,NEGATIVE,< -			; FP offsets for stack scratch:
		<LINE_CTRSTR, 8>, -		;  1 line FAO CTRSTR descriptor
		NUMCOL, -			;  number of columns
		SCRATCH_SIZE, -			;  size of one scratch string
		COLLST_BASE, -			;  base of COLUMN_LIST pointers
		COLSCRATCH_BASE, -		;  base of per-column scratch 
		-				;	pointers
		FLAGS, -			;  flags
		<STACK_LEN, 0> -		; end of stack storage
		>

	_VIELD	FLAGS,0,< -			; fields in FLAGS above:
		<NO_ENTRIES,,M> -		;  no entries on this line
		>

;
; Out-of-line code used during PRINT_COLUMNS setup
;

PC_XIT:	RET					; Zero columns - so exit.

;
; PRINT_COLUMNS entry point
;

PRINT_COLUMNS::
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>

	SUBW3	#<<COLLS1/4>-1>, (AP), R11	; Compute number of columns.
	BLEQ	PC_XIT				; Branch if no columns.

	MOVAB	STACK_LEN(SP), SP		; Allocate space on the stack.
	MOVZWL	R11, R11			; Zero extend columns count.
	MOVL	R11, NUMCOL(FP)			; Save column count.

	MULW3	ONE_COL, R11, R2		; Compute size needed for the
	ADDW3	#3, R2, R1			;  line FAO control string
	BICL	#^XFFFF0003, R1			;  (rounded to a longword).
	SUBL	R1, SP				; Allocate space on the stack.
	MOVZWL	R2, LINE_CTRSTR(FP)		; Setup size in descriptor.
	MOVL	SP, LINE_CTRSTR+4(FP)		; Setup starting address too.

	MOVQ	ONE_COL, R9			; Get 1 column FAO descriptor.
	MOVL	SP, R3				; Initialize output str. addr.
10$:	MOVC3	R9, (R10), (R3)			; Make one copy of the single
	SOBGTR	R11, 10$			;  col. string for every col.

SETUP_COL_SCRATCH:

	MOVL	NUMCOL(FP), R11			; Get number of columns.
	MOVL	COLLS1(AP), R10			; Get a COLUMN_LIST entry.
	ADDB3	COLM$B_DESC_SIZE(R10), -	; Assume that value field can
		COLM$B_VAL_SIZE(R10), R9	;  never be bigger than total
	ADDB	COLM$B_SEP_SIZE(R10), R9	;  column size.
	ADDB	#3, R9				; Round that to a longword.
	BICL	#^XFFFFFF03, R9			; That times number of columns 
	MULL3	R11, R9, R8			;  is the size of scratch.
	MOVL	R9, SCRATCH_SIZE(FP)		; Save per-col. scratch size.
	SUBL	R8, SP				; Allocate scratch on stack.
	MOVL	SP, R10				; Save starting scr. address.
10$:	MOVQ	R9, -(SP)			; Make a descriptor.
	ADDL	R9, R10				; Move to next slot.
	SOBGTR	R11, 10$			; Loop through all columns.

	MOVL	SP, COLSCRATCH_BASE(FP)		; Save scratch descriptors 
						;  pointer.

SETUP_COL_INFO:

	MOVAB	COLLS1-4(AP), R0		; Get indexable base for
						; COLUMN_LIST addresses in
						; argument list.
	MOVL	NUMCOL(FP), R1			; Get columns count.
10$:	PUSHL	(R0)[R1]			; Init column list pointers on 
	SOBGTR	R1, 10$				; the stack.
	MOVL	SP, COLLST_BASE(FP)		; Save base addr. for pointers.

	MOVL	DATBAS(AP), R11			; Get data structure base addr.

LINES_LOOP:
	SUBL3	#1, NUMCOL(FP), R10		; Initial columns counter.
	BISL	#FLAGS_M_NO_ENTRIES, FLAGS(FP)	; Initially, no entries made.

COLUMN_LOOP:
	MOVL	@COLLST_BASE(FP)[R10], R9	; Get current COLUMN_LIST ptr.
	MOVZBL	COLM$B_SEP_SIZE(R9), -(SP)	; Assume a null entry 
	PUSHAB	NULL_ASCID			;  for this column.
	MOVZBL	COLM$B_VAL_SIZE(R9), R5		; Also, setup val. size for 
	PUSHL	R5				;  action routine.
	PUSHAB	NULL_ASCIC
	MOVZBL	COLM$B_DESC_SIZE(R9), -(SP)

DO_COLLST_ENTRY:
	TSTL	COLM$L_STRING(R9)		; Is this list exhausted?
	BEQL	NEXT_COLUMN			; Branch if list exhausted.
	MOVAQ	@COLSCRATCH_BASE(FP)[R10], R7	; Get scratch descriptor for
						;  this column.

	MOVL	COLM$L_SOURCE(R9), R8		; Get data source descriptor.
	BGTR	200$				; Branch if its an action rout.

	BSBW	DO_ONE_COLUMN			; Convert data to ASCID.
	BLBS	R0, 400$			; Branch if value returned.
	BRB	300$				; Else, skip this entry.

200$:	MOVL	COLM$L_ACTION_VALUE(R9), R2	; Get supplied value.
	JSB	(R8)				; Call action routine.
	BLBS	R0, 400$			; Branch if value returned

300$:	ADDL	#COLM$K_LENGTH, R9		; Else, move to the next entry.
	MOVZBL	COLM$B_SEP_SIZE(R9), 16(SP)	; Setup new separation, value,
	MOVZBL	COLM$B_VAL_SIZE(R9), R5		;  and descriptor sizes.
	MOVL	R5, 8(SP)
	MOVZBL	COLM$B_DESC_SIZE(R9), (SP)
	BRB	DO_COLLST_ENTRY			; Try processing this entry.

400$:	MOVL	R7, 12(SP)			; Replace null ASCID for value.
	MOVL	COLM$L_STRING(R9), 4(SP)	; Replace descriptive text too.
	BICL	#FLAGS_M_NO_ENTRIES, FLAGS(FP)	; Indicate an entry was made.
	ADDL3	#COLM$K_LENGTH, R9, -		; Setup next COLUMN_LIST entry
		@COLLST_BASE(FP)[R10]		;  in pointer table.

NEXT_COLUMN:
	SOBGEQ	R10, COLUMN_LOOP		; Loop till all columns done.

PRINT_A_LINE:
	ASSUME	FLAGS_V_NO_ENTRIES EQ 0
	BLBS	FLAGS(FP), ALL_DONE		; If no entries made, all done.
	MULL3	#5, NUMCOL(FP), R2		; Compute number of FAO args.
	PRINTD	R2, LINE_CTRSTR(FP)		; Print the line.

RESTORE_SCRATCH_DESCRIPTORS:
	MOVL	NUMCOL(FP), R1			; Get number of columns.
	MOVL	COLSCRATCH_BASE(FP), R0		; Get base of scratch desc.
10$:	MOVL	SCRATCH_SIZE(FP), (R0)+		; Restore a size value.
	TSTL	(R0)+				; Skip the address.
	SOBGTR	R1, 10$				; Do all scratch descriptors.

	BRW	LINES_LOOP			; Try for another line.

ALL_DONE:
	RET					; All done, so return.
	.PAGE
;	Internal routine for PRINT_COLUMNS
;
;---
;
;	DO_ONE_COLUMN -- process a single -- non-action-routine -- column entry
;
;	This routine is the single column entry action routine used by 
;	PRINT_COLUMNS when a data structure offset is specified in place of an 
;	action routine.  The specified data is located, converted to ASCII, 
;	and the resulting string descriptor is returned.
;
;	PRINT_COLUMN_VALUE -- action routine callback which processes one value
;
;	This is the target of the DO_COLUMN_ENTRY macro.
;
;   INPUTS:
;
;	R2		address of datum or its descriptor 
;			(PRINT_COLUMN_VALUE only)
;	R4		byte COLM$K_FAO_xxx value
;			(PRINT_COLUMN_VALUE only)
;
;	R5		size of the value section for this item
;	R7		address of descriptor for a scratch string
;
;	R8		minus offset in data structure which locates data
;			(DO_ONE_COLUMN only)
;	R9		address of the current COLUMN_LIST entry
;			(DO_ONE_COLUMN only)
;	R11		data structure base
;			(DO_ONE_COLUMN only)
;
;   OUTPUTS:
;
;	R0 - R4		scratch
;			all other registers preserved
;
;---

	ASSUME COLM$K_FAO_AC EQ 0	; Besure type dispatching and 
	ASSUME COLM$K_FAO_AS EQ 1	; the FAO string table will work
	ASSUME COLM$K_FAO_OB EQ 2
	ASSUME COLM$K_FAO_XB EQ 3
	ASSUME COLM$K_FAO_ZB EQ 4
	ASSUME COLM$K_FAO_UB EQ 5
	ASSUME COLM$K_FAO_SB EQ 6
	ASSUME COLM$K_FAO_OW EQ 7
	ASSUME COLM$K_FAO_XW EQ 8
	ASSUME COLM$K_FAO_ZW EQ 9
	ASSUME COLM$K_FAO_UW EQ 10
	ASSUME COLM$K_FAO_SW EQ 11
	ASSUME COLM$K_FAO_OL EQ 12
	ASSUME COLM$K_FAO_XL EQ 13
	ASSUME COLM$K_FAO_ZL EQ 14
	ASSUME COLM$K_FAO_UL EQ 15
	ASSUME COLM$K_FAO_SL EQ 16
	ASSUME COLM$K_FAO_OB_NEQ EQ <COLM$K_FAO_OB + ^X80>
	ASSUME COLM$K_FAO_XB_NEQ EQ <COLM$K_FAO_XB + ^X80>
	ASSUME COLM$K_FAO_ZB_NEQ EQ <COLM$K_FAO_ZB + ^X80>
	ASSUME COLM$K_FAO_UB_NEQ EQ <COLM$K_FAO_UB + ^X80>
	ASSUME COLM$K_FAO_SB_NEQ EQ <COLM$K_FAO_SB + ^X80>
	ASSUME COLM$K_FAO_OW_NEQ EQ <COLM$K_FAO_OW + ^X80>
	ASSUME COLM$K_FAO_XW_NEQ EQ <COLM$K_FAO_XW + ^X80>
	ASSUME COLM$K_FAO_ZW_NEQ EQ <COLM$K_FAO_ZW + ^X80>
	ASSUME COLM$K_FAO_UW_NEQ EQ <COLM$K_FAO_UW + ^X80>
	ASSUME COLM$K_FAO_SW_NEQ EQ <COLM$K_FAO_SW + ^X80>
	ASSUME COLM$K_FAO_OL_NEQ EQ <COLM$K_FAO_OL + ^X80>
	ASSUME COLM$K_FAO_XL_NEQ EQ <COLM$K_FAO_XL + ^X80>
	ASSUME COLM$K_FAO_ZL_NEQ EQ <COLM$K_FAO_ZL + ^X80>
	ASSUME COLM$K_FAO_UL_NEQ EQ <COLM$K_FAO_UL + ^X80>
	ASSUME COLM$K_FAO_SL_NEQ EQ <COLM$K_FAO_SL + ^X80>

	.SAVE
	.PSECT	LITERALS,EXE,NOWRT

FAO_AC:	.ASCII	/!#* !AC/
FAO_AS:	.ASCII	/!#* !AS/
FAO_OB:	.ASCII	/!#OB/
FAO_XB:	.ASCII	/!#XB/
FAO_ZB:	.ASCII	/!#ZB/
FAO_UB:	.ASCII	/!#UB/
FAO_SB:	.ASCII	/!#SB/
FAO_OW:	.ASCII	/!#OW/
FAO_XW:	.ASCII	/!#XW/
FAO_ZW:	.ASCII	/!#ZW/
FAO_UW:	.ASCII	/!#UW/
FAO_SW:	.ASCII	/!#SW/
FAO_OL:	.ASCII	/!#OL/
FAO_XL:	.ASCII	/!#XL/
FAO_ZL:	.ASCII	/!#ZL/
FAO_UL:	.ASCII	/!#UL/
FAO_SL:	.ASCII	/!#SL/

FAO_TABLE:
	.ADDRESS 7,FAO_AC
	.ADDRESS 7,FAO_AS
	.ADDRESS 4,FAO_OB
	.ADDRESS 4,FAO_XB
	.ADDRESS 4,FAO_ZB
	.ADDRESS 4,FAO_UB
	.ADDRESS 4,FAO_SB
	.ADDRESS 4,FAO_OW
	.ADDRESS 4,FAO_XW
	.ADDRESS 4,FAO_ZW
	.ADDRESS 4,FAO_UW
	.ADDRESS 4,FAO_SW
	.ADDRESS 4,FAO_OL
	.ADDRESS 4,FAO_XL
	.ADDRESS 4,FAO_ZL
	.ADDRESS 4,FAO_UL
	.ADDRESS 4,FAO_SL

	.RESTORE

QHDR:	BRW	DO_QUEUE_HEADER			; Branch assist

DO_ONE_COLUMN:

	SUBL3	R8, R11, R2			; Compute data value address.
	MOVB	COLM$B_SRC_FAO(R9), R4		; Get FAO type for data.

PRINT_COLUMN_VALUE::
	BICL3	#^XFFFFFF80, R4, R3		; Strip _NEQ from FAO type.
	CMPB	R3, #COLM$K_FAO_Q2		; Is this a queue header?
	BEQL	QHDR				; Branch if queue header.
	CMPB	R3, #COLM$K_FAO_AS		; Is data a value?
	BGTR	40$				; Branch if data is value.
	BLSS	20$				; Branch if data is ASCIC.
	MOVZWL	(R2), R1			; Must be ASCID, get its size.
	BRB	30$				; Go adjust fill size.
20$:	MOVZBL	(R2), R1			; Get ASCIC size.
30$:	SUBL	R1, R5				; Adjust string filler size.
	BRW	70$				; Go convert the data.
40$:	DISPATCH R4, type=B, prefix=COLM$K_FAO_, <-
		<OB_NEQ,41$>, -			; Dispatch byte values for
		<XB_NEQ,41$>, -			;  zero test
		<ZB_NEQ,41$>, -
		<UB_NEQ,41$>, -
		<SB_NEQ,41$>, -
		<OW_NEQ,43$>, -			; Dispatch word values for
		<XW_NEQ,43$>, -			;  zero test
		<ZW_NEQ,43$>, -
		<UW_NEQ,43$>, -
		<SW_NEQ,43$>, -
		<OL_NEQ,45$>, -			; Dispatch longword values for
		<XL_NEQ,45$>, -			;  zero test
		<ZL_NEQ,45$>, -
		<UL_NEQ,45$>, -
		<SL_NEQ,45$> -
		>
	MOVL	(R2), R2			; Everything else doesn't get
	BRB	70$				;  tested.
41$:	MOVZBL	(R2), R2			; Perform byte sized zero
	BNEQ	70$				;  test.
	BRB	49$				; Branch if zero.
43$:	MOVZWL	(R2), R2			; Perform word sized zero
	BNEQ	70$				;  test.
	BRB	49$				; Branch if zero.
45$:	MOVL	(R2), R2			; Perform longword zero
	BNEQ	70$				;  test.
49$:	CLRL	R0				; For zero, indicate that
	RSB					;  entry is to be skipped.
70$:	$FAO_S	ctrstr = FAO_TABLE[R3], -	; Convert the data.
		outbuf = (R7), -
		outlen = (R7), -
		p1 = R5, -
		p2 = R2
	SIGNAL
	RSB					; Return


;---
;   DO_QUEUE_HEADER - Action routine for queue headers
;
;   This routine tests a doubly linked queue header to see if the queue
;   is empty.  If the queue is not empty, the address of the first entry
;   in the queue is displayed (PRINT_COLUMNS style).  If the queue is
;   empty, the word "empty" is displayed.
;
;   Inputs:
;	R2		address of queue header in local storage
;	R5		size of the value section for this item
;	R7		address of descriptor for a scratch string
;	R8		minus offset in data structure which locates data
;	DATSVA(AP)	SVA of real data structure base
;
;   Outputs:
;	see PRINT_COLUMN_VALUE
;
;   Implicit outputs:
;	column entry made in PRINT_COLUMNS table
;---

QUEUE_EMPTY:
	STRING	<empty>

DO_QUEUE_HEADER:
	MOVB	#COLM$K_FAO_XL, R4		; Assume queue is not empty.
	SUBL3	R8, DATSVA(AP), R3		; Get SVA of queue header
	CMPL	(R2), R3			; Is the queue empty?
	BNEQ	90$				; Branch if not empty.
	MOVAB	QUEUE_EMPTY, R2			; Else, flag queue as empty
	MOVB	#COLM$K_FAO_AS, R4		;  and change output type.
90$:	BRW	PRINT_COLUMN_VALUE		; Go output information.

	.PAGE
	.SBTTL	OPEN_OUTPUT -- OPEN THE OUTPUT LISTING FILE
;---
;
;	OPEN_OUTPUT
;
;	OPEN THE OUTPUT LISTING FILE AND SETUP TO
;	BEGIN LISTING OUTPUT.
;
;   INPUTS:
;
;	OUTPUT_FILE = DESCRIPTOR OF FILE NAME
;
;   OUTPUTS:
;
;	NONE
;
;---

	.ENTRY	OPEN_OUTPUT,^M<R2,R3,R4,R5,R6>

	MOVAB	LIST,R3			; ADDRESS THE RAB
	MOVL	RAB$L_FAB(R3),R2	; ADDRESS THE FAB
	MOVL	FAB$L_NAM(R2),R4	; ADDRESS THE NAM BLOCK
;
;	CLOSE THE PREVIOUS LISTING FILE, IF ANY
;
	TSTB	FAB$B_FNS(R2)		; WAS FILE ALREADY OPEN?
	BEQL	20$			; BRANCH IF NOT
	CALLS	#0,PRINT_INDEX		; PRINT TABLE OF CONTENTS
	$CLOSE	(R2)			; CLOSE LISTING FILE
	SIGNAL	RMS,(R2)
;
;	DETERMINE IF PARAMETER GIVEN IS A TERMINAL OR LISTING DEVICE
;
20$:	MOVB	OUTPUT_FILE,FAB$B_FNS(R2)	; SET FILE NAME
	MOVL	OUTPUT_FILE+4,FAB$L_FNA(R2)
	ALLOC	NAM$C_MAXRSS,R5		; ALLOCATE STRING BUFFER
	MOVL	4(R5),NAM$L_ESA(R4)	; SET ADDRESS OF BUFFER
	$PARSE	(R2)			; GET EXPANDED FILE NAME
	SIGNAL	RMS,(R2)
	MOVZBL	NAM$B_ESL(R4),(R5)	; SET LENGTH OF STRING
	ALLOC	DIB$C_LENGTH,R6		; ALLOCATE GETDEV BUFFER
	$GETDEV_S DEVNAM=(R5),PRIBUF=(R6)
	SIGNAL
	MOVL	4(R6),R1		; ADDRESS THE BUFFER
	CMPB	DIB$B_DEVCLASS(R1),#DC$_TERM	; TERMINAL?
	BEQL	50$			; BRANCH IF SO
;
;	OPEN LISTING FILE AND SET PAGE SIZES
;
	$CREATE	(R2)			; OPEN LISTING FILE
	SIGNAL	RMS,(R2)
	$CONNECT (R3)			; CONNECT TO OUTPUT STREAM
	SIGNAL	RMS,(R3)
	CALLS	#0,G^LIB$LP_LINES	; FIND THE CURRENT PAGE SIZE
	SUBL3	#6,R0,PAGE_SIZE		; INITIALIZE PAGE SIZE
	CLRL	PAGE_NUMBER		; START AT PAGE 1
	CLRL	LINE_COUNT		; NEW PAGE
	$ASCTIM_S TIMBUF=CURRENT_TIME	; GET CURRENT DATE/TIME
	CALLS	#0,DUMMY_INDEX		; PRINT DUMMY TABLE OF CONTENTS
	RET
;
;	OPEN TERMINAL FOR OUTPUT AND SET PAGE SIZES
;
50$:	CLRL	OUTPUT_FILE		; SIGNAL TO USE TERMINAL
	CLRB	FAB$B_FNS(R2)		; MARK NO LISTING FILE OPEN
	MOVZBL	DIB$L_DEVDEPEND+3(R1),R0	; GET PAGE SIZE
	SUBL3	#PROMPT_LINES,R0,PAGE_SIZE	; SET PAGE SIZE
	CLRL	LINE_COUNT		; NEW PAGE
	MOVL	#1,R0			; SUCCESS
	RET


	.SBTTL	OPEN_LOG -- OPEN THE LOGGING FILE
;---
;
;	OPEN_LOG
;
;	OPEN THE LOGGING FILE AND SETUP TO BEGIN LOGGING.
;
;   INPUTS:
;
;	LOG_FILE = DESCRIPTOR OF FILE NAME
;
;   OUTPUTS:
;
;	NONE
;
;---

	.ENTRY	OPEN_LOG,^M<R2,R3,R4,R5,R6>

	MOVAB	LOGRAB,R3		; ADDRESS THE RAB
	MOVL	RAB$L_FAB(R3),R2	; ADDRESS THE FAB
	MOVL	FAB$L_NAM(R2),R4	; ADDRESS THE NAM BLOCK
;
;	CLOSE THE PREVIOUS LOGGING FILE, IF ANY
;
	TSTB	FAB$B_FNS(R2)		; WAS FILE ALREADY OPEN?
	BEQL	20$			; BRANCH IF NOT
	$CLOSE	(R2)			; CLOSE LOGGING FILE
	SIGNAL	RMS,(R2)
;
;	DETERMINE IF PARAMETER GIVEN IS A TERMINAL OR LOGGING DEVICE
;
20$:	MOVB	LOG_FILE,FAB$B_FNS(R2)	; SET FILE NAME
	MOVL	LOG_FILE+4,FAB$L_FNA(R2)
	ALLOC	NAM$C_MAXRSS,R5		; ALLOCATE STRING BUFFER
	MOVL	4(R5),NAM$L_ESA(R4)	; SET ADDRESS OF BUFFER
	$PARSE	(R2)			; GET EXPANDED FILE NAME
	SIGNAL	RMS,(R2)
	MOVZBL	NAM$B_ESL(R4),(R5)	; SET LENGTH OF STRING
	ALLOC	DIB$C_LENGTH,R6		; ALLOCATE GETDEV BUFFER
	$GETDEV_S DEVNAM=(R5),PRIBUF=(R6)
	SIGNAL
	MOVL	4(R6),R1		; ADDRESS THE BUFFER
	CMPB	DIB$B_DEVCLASS(R1),#DC$_TERM	; TERMINAL?
	BEQL	50$			; BRANCH IF SO
;
;	OPEN LOGGING FILE 
;
30$:	$CREATE	(R2)			; OPEN LOGGING FILE
	SIGNAL	RMS,(R2)
	$CONNECT (R3)			; CONNECT TO STREAM
	SIGNAL	RMS,(R3)
	RET
;
;	LOGGING AT THE TERMINAL IS NOT ALLOWED SINCE THIS IS BEING DONE ANYWAY
;
50$:	CLRB	FAB$B_FNS(R2)		; MARK NO LOGGING FILE OPEN
	CLRL	LOG_FILE		; MARKING NO LOGGING ENABLED
	MOVL	#1,R0			; SUCCESS
	RET

	.PAGE
	.SBTTL	CLOSE_LOG -- CLOSE THE LOGGING FILE
;---
;
;	CLOSE_LOG
;
;	CLOSE THE LOGGING FILE IF ONE IS OPEN.
;
;   INPUTS:
;
;	LOGFAB = LOGGING FAB
;
;   OUTPUTS:
;
;	NONE
;
;---

	.ENTRY	CLOSE_LOG,^M<R2>

	MOVAB	LOGFAB,R2		; ADDRESS THE FAB
	MOVL	#1,R0

	TSTB	FAB$B_FNS(R2)		; WAS FILE OPEN?
	BEQL	20$			; BRANCH IF NOT
	$CLOSE	(R2)			; CLOSE LOGGING FILE
	SIGNAL	RMS,(R2)
	CLRB	FAB$B_FNS(R2)		; CLEAR INDICATERS THAT THERE
	CLRL	LOG_FILE		; IS A LOGGING FILE AND THAT LOGGING IS
20$:	RET				; ENABLED


	.END	START
