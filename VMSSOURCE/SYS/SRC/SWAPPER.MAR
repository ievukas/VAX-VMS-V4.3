	.TITLE	SWAPPER  WORKING SET SWAPPER 
	.IDENT	'V04-000'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
; FACILITY: EXECUTIVE, SWAPPER
;
; ABSTRACT: THE SWAPPER SCHEDULES AND EXECUTES SWAPPING OF PROCESS
;	    WORKING SETS BETWEEN SWAP STORAGE AND MAIN MEMORY.
;
; ENVIRONMENT:
;	MODE = KERNEL ,  RESIDENT
;
; AUTHOR:  R. HUSTVEDT	 CREATION DATE: 30-NOV-76
;
; MODIFIED BY:
;
;	V03-029	ACG0440		Andrew C. Goldstein,	24-Jul-1984  10:50
;		Add ref count field to ORB
;
;	V03-028	LMP0275		L. Mark Pilant,		12-Jul-1984  20:31
;		Initialize the ACL info in the ORB to be a null descriptor
;		list rather than an empty queue.  This avoids the overhead
;		of locking and unlocking the ACL mutex, only to find out
;		that the ACL was empty.
;
;	V03-027	TMK0011		Todd M. Katz		11-Apr-1984
;		The ACL mutexes within the Object Rights Blocks of the system
;		and system directory logical name tables are currently 
;		incorrectly initialized to ^X00001111. Initialize them to
;		^X0000FFFF.
;
;	V03-026	MSH0029		Michael S. Harvey	9-Apr-1984
;		The translation of LNM$TEMPORARY_MAILBOX will now be LNM$JOB
;		instead of LNM$GROUP. This is a part of an effort to close
;		some privilege related security holes involving logical names
;		and temporary mailbox creation.
;
;	V03-025	TMK0010		Todd M. Katz		26-Mar-1984
;		Modify the logical name system services to make use of the 
;		updated internal protection checking mechanisms. What this
;		involves is replacing the system directory and system logical
;		name tables' CHIP protection templates with quad-word aligned
;		Object Rights Blocks.
;
;	V03-024	TMK0009		Todd M. Katz		07-Mar-1984
;		Add a hash code field, LNMX$W_HASH, to every translation block
;		of every logical name table template defined. This hash code 
;		field will be used in an optimization of logical name table name
;		PROCESSing.
;
;	V03-023	LY00b7		Larry Yetto		16-FEB-1984 14:33
;		Fix alignment of logical name tables
;
;	V03-022	ROW62094	Ralph O. Weber		25-JAN-1984
;		Add PROCESSing for inswapped global page when there currently 
;		exists a equivalent global page having a page read error.  
;		This makes the list of ossible conditions to be handled for an 
;		inswap of a global page: 1) no equivalent global page exsts, 
;		2) an equivalent global page exists, 3) the equivalent page is 
;		still being read (from a page fault read), 4) the equivalent 
;		page was read but encountered a page read error.
;
;	V03-021	TMK0008		Todd M. Katz		06-Jan-1984
;		Never allow the system directory logical name table to be
;		deleted. This is done as follows:
;
;		1. Set the LNMB$V_NODELETE bit within the LNMB$B_FLAGS field
;		   of the system directory logical name table.
;		2. Check for this bit within the logical name system services 
;		   whenever a LNMB is to be deleted.
;		3. If this bit is set, do not allow the LNMB to be deleted;
;		   otherwise, proceed with the deletion. 
;
;		This mechanism will prevent the directories from ever being 
;		explicitely or implicitely deleted which can cause all sorts
;		of problems.
;
;	V03-020	TMK0007		Todd M. Katz		25-Dec-1983
;		Make a small change to TMK0006. Setup the remaining quota
;		byte field of the system directory logical name table with a
;		value of positive infinity (i.e. - ^X7FFFFFFF) instead of a
;		value of positive infinity minus the size of the system table. 
;		This is necessary because the routine which is used to 
;		appropriately insert the system table performs the necessary
;		quota subtractions; thus, in TMK0006 quota for the system
;		table was being subtracted twice from the system directory 
;		logical name table.
;
;	V03-019	TMK0006		Todd M. Katz		18-Dec-1983
;		Handcraft the system logical name table, LNM$SYSTEM_TABLE,
;		instead of using the system service ($CRELNT) to CREATE it.
;
;	V03-018	WMC0018		Wayne Cardoza		02-Dec-1983
;		PHD$W_WSLX, PHD$W_BAK have become longwords.
;
;	V03-017	TMK0005		Todd M. Katz		19-Oct-1983
;		Add the following kernel mode logical names which will be 
;		used in order to optimize $TRNLOGs:
;
;		TRNLOG$_PROCESS_GROUP
;		TRNLOG$_PROCESS_SYSTEM
;		TRNLOG$_GROUP_SYSTEM
;		TRNLOG$_PROCESS_GROUP_SYSTEM
;
;		Also, CREATE LNM$TEMPORARY_MAILBOX with a translation of
;		LNM$GROUP instead of LNM$JOB.
;
;	V03-016	TMK0004		Todd M. Katz		11-Oct-1983
;		Make the following changes to the logical names and tables
;		that are CREATEd at system initialization time:
;
;		1. CREATE LNM$FILE_DEV with the translations 
;		   LNM$PROCESS,LNM$JOB,LNM$GROUP,LNM$SYSTEM (the change is the 
;		   addition of the LNM$JOB translation).
;		2. CREATE LNM$TEMPORARY_MAILBOX with the translation LNM$JOB.
;		3. Remove LNM$TRNLOG_PG, LNM$TRNLOG_PS, LNM$TRNLOG_GS, 
;		   LNM$TRNLOG_PGS, and LNM$DEFAULT_SEARCH.
;		4. Add the following kernel mode logical names which will be 
;		   used in order to provide compatibility between V3 and V4 
;		   for all of the old logical name system services ($TRNLOG, 
;		   $CRELOG, $DELLOG):
;
;		   LOG$PROCESS
;		   LOG$GROUP
;		   LOG$SYSTEM
;
;		5. Add to the PQB$AB_SYSPQL quota list a PQL$_JTQUOTA item.
;
;	V03-015	TMK0003		Todd M. Katz		09-Apr-1983
;		Statically define the CHIP protection structure of
;		LNM$SYSTEM_DIRECTORY, set the (internal) attribute bit
;		LNM$V_SYSTEM when creating LNM$SYSTEM_TABLE, and change the
;		CHIP protection of LNM$SYSTEM_DIRECTORY and LNM$SYSTEM_TABLE to 
;		S:RWE O:RWE G:R W:R. Also, CREATE the supervisor mode logical
;		name LNM$FILE_DEV with the translations LNM$PROCESS,LNM$GROUP,
;		LNM$SYSTEM instead of LNM$DEFAULT_SEARCH, mark both 
;		translations of LNM$DIRECTORIES with the TERMINAL attribute,
;		and CREATE the non-aliasable kernal mode logical names
;		LNM$TRNLOG_PG,LNM$TRNLOG_PS,LNM$TRNLOG_GS,LNM$TRNLOG_PGS.
;
;	V03-014	KDM0052		Kathleen D. Morse	11-Jul-1983
;		Replace references of PR$_TODR with EXE$GQ_SYSTIME+2.
;
;	V03-013	DMW4060		DMWalp			23-Jun-1983
;		Change $xxLNM value parameters to be by reference
;
;	V03-012	DMW4054		DMWalp			21-Jun-1983
;		Convert SYS$DISK and SYS$SYSDEVICE creation from $CRELOG
;		to $CRELNM
;
;	V03-011	RAS0158		Ron Schaefer		23-May-1983
;		Add CHIP protection structure to the logical name structures.
;		Protection stuff only supports SOGW checking for now.
;		Fix quota for LNM$SYSTEM_TABLE.
;
;	V03-010	TMK0002		Todd M. Katz		26-Apr-1983
;		CREATE the following logical name structures at system
;		initialization time:
;
;		1. LNM$SYSTEM_TABLE.
;		2. LNM$SYSTEM.
;		3. LNM$FILE_DEV (Executive Mode).
;		4. LNM$FILE_DEV (Supervisor Mode).
;		5. LNM$DEFAULT_SEARCH.
;		6. LNM$TEMPORARY_MAILBOX.
;		7. LNM$PERMANENT_MAILBOX.
;		8. LNM$DIRECTORIES.
;
;		Change the name of LNT$SYSTEM_DIRECTORY to LNM$SYSTEM_DIRECTORY.
;
;	V03-009	TMK0001		Todd M. Katz		14-Apr-1983
;		Make the following changes to the system directory logical
;		name table:
;
;		1. Make the table a kernel access mode table.
;		2. Make LNMB$L_TABLE point to the system directory table's
;		   table header.
;		3. Set the bits LNMTH$V_SHAREABLE and LNMTH$V_DIRECTORY within
;		   LNMTH$B_FLAGS.
;		4. Delete the field LNMTH$L_LOGNAM.
;
;	V03-008	HRJ0200		Herb Jacobs		05-Feb-1983
;		Add check to BALANCE to remove confusion as to why
;		swapper has woken up.  If there are FREELIM pages on
;		Freelist, then don't acquire FREEGOAL pages, but rather
;		perform requested function woken up for.
;
;	V03-007	DMW4020		DMWalp			30-Dec-1982
;		Added creation system logical directory.
;
;	V03-006	DMW4019		DMWalp			15-Dec-1982
;		Calculate LNM hash table parameters and CREATE hash table.
;
;	V03-005	DMW4006		DMWalp			10-NOV-1982
;		Recode creation SYS$DISK and SYS$SYSDEVICE to use
;		external interface ( not internal ) of $CRELOG
;
;	V03-004	HRJ0101		Herb Jacobs		30-Jun-1982
;		Add perturbation to balance set slot scanner to try to
;		alleviate deadlocks caused there if seemingly the
;		best swapper action is to try to free PROCESS waited
;		for service from an outswapped PROCESS.
;
;
;--

	.PAGE
	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;

	$ACBDEF				; DEFINE AST CONTROL BLOCK OFFSETS
	$DYNDEF				; DEFINE STRUCTURE TYPE CODES
	$IPLDEF				; DEFINE INTERRUPT PRIORITY LEVELS
	$IRPDEF				; DEFINE I/O REQUEST PACKET OFFSETS
	$LNMDEF				; DEFINE LOGICAL NAME OFFSETS
	$LNMSTRDEF			; DEFINE lOGICAL NAME STRUCTURE OFFSETS
	$OPDEF				; DEFINE OPCODE EQUIVALENT VALUES
	$ORBDEF				; DEFINE OBJECT RIGHTS BLOCK OFFSETS
	$PCBDEF				; DEFINE PCB OFFSETS
	$PFLDEF				; DEFINE SWAP FILE TABLE OFFSETS
	$PFNDEF				; DEFINE PFN VALUES
	$PHDDEF				; DEFINE PHD OFFSETS
	$PQLDEF				; DEFINE QUOTA SYMBOLS
	$PRDEF				; DEFINE PROCESSOR REGISTERS
	$PRCDEF				; CREATE PROCESS FLAGS
	$PSLDEF				; DEFINE PSL VALUES
	$PTEDEF				; DEFINE PAGE TABLE ENTRY
	$VADEF				; DEFINE VIRTUAL ADDRESS FIELDS
	$WSLDEF				; DEFINE WORKING SET LIST BITS

;
; ASSUMPTIONS ABOUT THE STRUCTURE OF LOGICAL NAME AND OBJECT RIGHTS BLOCKS:
;

	ASSUME	LNMB$L_FLINK,      EQ,	0
	ASSUME	LNMB$L_FLINK+4,    EQ,	LNMB$L_BLINK
	ASSUME	LNMB$L_BLINK+4,    EQ,	LNMB$W_SIZE
	ASSUME 	LNMB$W_SIZE+2,     EQ,	LNMB$B_TYPE
	ASSUME	LNMB$B_TYPE+1,     EQ,	LNMB$B_ACMODE
	ASSUME	LNMB$B_ACMODE+1,   EQ,	LNMB$L_TABLE
	ASSUME	LNMB$L_TABLE+4,    EQ,	LNMB$B_FLAGS
	ASSUME	LNMB$B_FLAGS+1,    EQ, 	LNMB$T_NAME

	ASSUME	LNMX$B_FLAGS,      EQ,	0
	ASSUME	LNMX$B_FLAGS+1,    EQ,	LNMX$B_INDEX
	ASSUME	LNMX$B_INDEX+1,    EQ,	LNMX$W_HASH
	ASSUME	LNMX$W_HASH+2,     EQ,	LNMX$T_XLATION

	ASSUME	LNMTH$B_FLAGS,	   EQ,	0
	ASSUME	LNMTH$B_FLAGS+1,   EQ,	LNMTH$L_HASH
	ASSUME	LNMTH$L_HASH+4,    EQ,	LNMTH$L_ORB
	ASSUME	LNMTH$L_ORB+4,     EQ,	LNMTH$L_NAME
	ASSUME	LNMTH$L_NAME+4,    EQ,	LNMTH$L_PARENT
	ASSUME	LNMTH$L_PARENT+4,  EQ,	LNMTH$L_CHILD
	ASSUME	LNMTH$L_CHILD+4,   EQ,	LNMTH$L_SIBLING
	ASSUME	LNMTH$L_SIBLING+4, EQ,	LNMTH$L_QTABLE
	ASSUME	LNMTH$L_QTABLE+4,  EQ,	LNMTH$L_BYTESLM
	ASSUME	LNMTH$L_BYTESLM+4, EQ,	LNMTH$L_BYTES

	ASSUME	ORB$L_OWNER,	   EQ,	0
	ASSUME	ORB$L_OWNER+4,	   EQ,	ORB$L_ACL_MUTEX
	ASSUME	ORB$L_ACL_MUTEX+4, EQ,	ORB$W_SIZE
	ASSUME	ORB$W_SIZE+2,	   EQ,	ORB$B_TYPE
	ASSUME	ORB$B_TYPE+1,	   EQ,	ORB$B_FLAGS
	ASSUME	ORB$B_FLAGS+3,	   EQ,	ORB$W_REFCOUNT
	ASSUME	ORB$W_REFCOUNT+2,  EQ,	ORB$Q_MODE_PROT
	ASSUME	ORB$Q_MODE_PROT+8, EQ,	ORB$L_SYS_PROT
	ASSUME	ORB$L_SYS_PROT+4,  EQ,	ORB$L_OWN_PROT
	ASSUME	ORB$L_OWN_PROT+4,  EQ,	ORB$L_GRP_PROT
	ASSUME	ORB$L_GRP_PROT+4,  EQ,	ORB$L_WOR_PROT
	ASSUME	ORB$L_WOR_PROT+4,  EQ,	ORB$L_ACL_COUNT
	ASSUME	ORB$L_ACL_COUNT+4, EQ,	ORB$L_ACL_DESC
	ASSUME	ORB$L_ACL_DESC+4,  EQ,	ORB$R_MIN_CLASS
	ASSUME	ORB$R_MIN_CLASS+ORB$S_MIN_CLASS,-
				   EQ,	ORB$R_MAX_CLASS
	ASSUME	ORB$R_MAX_CLASS+ORB$S_MAX_CLASS,-
				   EQ,	ORB$K_LENGTH


;
; OWN STORAGE:
;

	.PSECT	$$$220,LONG		; SWAPPER/SCHEDULER WRITABLE DATA
IOROUTINE:				; ADDRESS OF PROPER BUILD PACKET ROUTINE
	.LONG	0			;
IOEA:	.LONG	0			; I/O END ACTION RETURN
RWSSWP:	.LONG	0			; REMAINING WS SWP ADDRESS
RSVAPTE:.LONG	0			; REMAINING SVA OF PTE
RPGCNT:	.WORD	0			; REMAINING PAGE COUNT
OSWPPGS:.WORD	0			; OUTSWAP PAGE COUNT
OSWPPCB:.LONG	0			; PCB ADDRESS OF OUTSWAP PROCESS
SWP$GW_BALCNT::				; COUNT OF PROCESSES IN BALANCE SET
	.WORD	-1			; EXCLUDING NULL PROCESS AND SWAPPER
SCH$GW_SWPFCNT::			; COUNT OF SUCCESSIVE SWAP
	.WORD	0			; SCHEDULE FAILURES.

	.PSECT  $$$260,5		; WRITABLE, HIGH USE PSECT

;
; LNM$SYSTEM_DIRECTORY - THE SYSTEM DIRECTORY LOGICAL NAME TABLE.
;

LNM$SYSTEM_DIRECTORY::
	.LONG   0			; FORWARD LINK
	.LONG   0			; BACK LINK
	.WORD   LNM_SYS_DIR_SIZ		; SIZE OF STRUCTURE
	.BYTE   DYN$C_LNM		; TYPE OF STRUCTURE
	.BYTE   PSL$C_KERNEL		; KERNEL ACCESS MODE
	.ADDRESS LNM_SYSTEM_DIR_LNMTH	; DIRECTORY TABLE HEADER ADDRESS
	.BYTE   LNMB$M_NO_ALIAS!-	; DIRECTORY TABLES CAN NOT BE ALIASED
		LNMB$M_TABLE!-		; DIRECTORIES ARE TABLES
		LNMB$M_NODELETE		; DIRECTORIES CAN NOT BE DELETED
	.ASCIC  "LNM$SYSTEM_DIRECTORY"	; NAME OF DIRECTORY TABLE

	.BYTE   LNMX$M_TERMINAL		; FLAGS BYTE. NO MORE TRANSLATIONS
	.BYTE   LNMX$C_TABLE		; TRANSLATION INDEX ( SPECIAL TABLE )
	.WORD   0			; TRANSLATION HASH CODE
	.BYTE   LNMTH$K_LENGTH		; SIZE OF TABLE HEADER BLOCK

LNM_SYSTEM_DIR_LNMTH::
	.BYTE   LNMTH$M_SHAREABLE!-	; DIRECTORY IS A SHAREABLE TABLE
		LNMTH$M_DIRECTORY	; TABLE IS A DIRECTORY TABLE
	.LONG   0			; ADDRESS OF HASH TABLE 
	.ADDRESS LNM_SYSTEM_DIR_ORB	; ADDRESS OF OBJECT RIGHTS BLOCK
	.ADDRESS LNM$SYSTEM_DIRECTORY	; ADDRESS OF CONTAINING LNMB BLOCK
	.LONG   0			; ADDRESS OF PARENT TABLE
	.LONG   0			; ADDRESS OF CHILD TABLE
	.LONG   0			; ADDRESS OF SIBLING TABLE
	.ADDRESS LNM_SYSTEM_DIR_LNMTH	; ADDRESS OF TABLE HOLDING QUOTA
	.LONG   ^X7FFFFFFF		; INITIAL QUOTA   ( POSITIVE INFINITY )
	.LONG   ^X7FFFFFFF		; REMAINING QUOTA ( POSITIVE INFINITY )

	.BYTE   LNMX$M_XEND		; FLAGS BYTE. NO MORE TRANSLATIONS

	.ALIGN	QUAD
LNM_SYSTEM_DIR_ORB:
	.LONG	^X00010004		; SYSTEM DIRECTORY OWNER IS [1,4]
	.WORD	-1,0			; INITIALIZE ACL MUTEX
	.WORD	LNM_SYS_DIR_ORB_SIZ	; SIZE OF OBJECT RIGHTS BLOCK
	.BYTE	DYN$C_ORB		; BLOCK TYPE
	.BYTE	0			; NO ACL AS YET
	.LONG	0			; ZERO RESERVED WORD & REF COUNT
	.QUAD	0			; OBJECT DOES NOT HAVE AN ACCESS MODE
	.LONG	^X00000008		; SYSTEM PROTECTION IS RWE
	.LONG	^X00000008		; OWNER PROTECTION IS RWE
	.LONG	^X0000000E		; GROUP PROTECTION IS R
	.LONG	^X0000000E		; WORLD PROTECTION IS R
	.LONG	0,0			; NULL INITIAL ACL
	.BYTE   0[ORB$S_MIN_CLASS]	; MINIMUM CLASSIFICATION MASK
	.BYTE   0[ORB$S_MAX_CLASS]	; MAXIMUM CLASSIFICATION MASK

	.ALIGN  5
LNM_SYS_DIR_ORB_SIZ = . - LNM_SYSTEM_DIR_ORB
LNM_SYS_DIR_SIZ = . - LNM$SYSTEM_DIRECTORY

;
; LNM$SYSTEM_TABLE - THE SYSTEM LOGICAL NAME TABLE.
;
					
SYSTEM_TABLE:
	.LONG   0			; FORWARD LINK
	.LONG   0			; BACK LINK
	.WORD   SYSTEM_TABLE_SIZE	; SIZE OF STRUCTURE
	.BYTE   DYN$C_LNM		; TYPE OF STRUCTURE
	.BYTE   PSL$C_KERNEL		; KERNEL ACCESS MODE
	.ADDRESS LNM_SYSTEM_DIR_LNMTH	; DIRECTORY TABLE HEADER ADDRESS
	.BYTE   LNMB$M_NO_ALIAS!-	; TABLE CAN NOT BE ALIASED
		LNMB$M_TABLE		; TABLE
	.ASCIC  "LNM$SYSTEM_TABLE"	; TABLE NAME

	.BYTE   LNMX$M_TERMINAL		; FLAGS BYTE. NO MORE TRANSLATIONS
	.BYTE   LNMX$C_TABLE		; TRANSLATION INDEX ( SPECIAL TABLE )
	.WORD   0			; TRANSLATION HASH CODE
	.BYTE   LNMTH$K_LENGTH		; SIZE OF TABLE HEADER BLOCK

SYSTEM_TABLE_LNMTH:
	.BYTE   LNMTH$M_SHAREABLE!-	; TABLE IS SHAREABLE
		LNMTH$M_SYSTEM 		; THIS IS THE SYSTEM LOGICAL NAME TABLE
	.LONG   0			; ADDRESS OF HASH TABLE
	.ADDRESS SYSTEM_TABLE_ORB	; ADDRESS OF OBJECT RIGHTS BLOCK
	.ADDRESS SYSTEM_TABLE		; ADDRESS OF CONTAINING LNMB BLOCK
	.ADDRESS LNM_SYSTEM_DIR_LNMTH	; ADDRESS OF PARENT TABLE
	.LONG   0			; ADDRESS OF CHILD TABLE
	.LONG   0			; ADDRESS OF SIBLING TABLE
	.ADDRESS LNM_SYSTEM_DIR_LNMTH	; ADDRESS OF TABLE HOLDING QUOTA
	.LONG   0			; INITIAL QUOTA   ( POOLED )
	.LONG   0			; REMAINING QUOTA ( POOLED )

	.BYTE   LNMX$M_XEND		; FLAGS BYTE. NO MORE TRANSLATIONS

	.ALIGN	QUAD
SYSTEM_TABLE_ORB:
	.LONG	^X00010004		; SYSTEM TABLE OWNER IS [1,4]
	.WORD	-1,0			; INITIALIZE ACL MUTEX
	.WORD	SYSTEM_TABLE_ORB_SIZ	; SIZE OF OBJECT RIGHTS BLOCK
	.BYTE	DYN$C_ORB		; BLOCK TYPE
	.BYTE	0			; NO ACL AS YET
	.LONG	0			; ZERO RESERVED WORD & REF COUNT
	.QUAD	0			; OBJECT DOES NOT HAVE AN ACCESS MODE
	.LONG	^X00000008		; SYSTEM PROTECTION IS RWE
	.LONG	^X00000008		; OWNER PROTECTION IS RWE
	.LONG	^X0000000E		; GROUP PROTECTION IS R
	.LONG	^X0000000E		; WORLD PROTECTION IS R
	.LONG	0,0			; NULL INITIAL ACL
	.BYTE   0[ORB$S_MIN_CLASS]	; MINIMUM CLASSIFICATION MASK
	.BYTE   0[ORB$S_MAX_CLASS]	; MAXIMUM CLASSIFICATION MASK

	.ALIGN  5
SYSTEM_TABLE_ORB_SIZ = . - SYSTEM_TABLE_ORB
SYSTEM_TABLE_SIZE = . - SYSTEM_TABLE


	.PSECT	YF$LOWUSE		; PAGED PSECT AT END OF SYS.EXE

IMGDESC:.ASCID	/SYSINIT.EXE/		; SYSTEM INITIALIZATION PROCESS
TT0DESC:.ASCID	/OPA0:/

;
; DESCRIPTORS AND CHARACTER STRING BUFFERS FOR THE LOGICAL NAME TABLE NAMES, 
; LOGICAL NAMES, AND LOGICAL NAME EQUIVALENCE STRINGS THAT ARE CREATED AT 
; SYSTEM INITIALIZATION TIME.
;

LNM_DIRECTORIES_DESC:
	.ASCID	/LNM$DIRECTORIES/

LNM_FILE_DEV_DESC:
	.ASCID	/LNM$FILE_DEV/

LNM_PERMANENT_MAILBOX_DESC:
	.ASCID	/LNM$PERMANENT_MAILBOX/

LNM_SYSTEM_DESC:
	.LONG	LNM_SYSTEM_LENGTH
	.ADDRESS LNM_SYSTEM

LNM_SYSTEM_DIRECTORY_DESC:
	.LONG	LNM_SYSTEM_DIRECTORY_LENGTH
	.ADDRESS LNM_SYSTEM_DIRECTORY
 
LNM_TEMPORARY_MAILBOX_DESC:
	.ASCID	/LNM$TEMPORARY_MAILBOX/

LOG_G_DESC:
	.LONG	LOG_GROUP_LENGTH
	.ADDRESS LOG_GROUP

LOG_P_DESC:
	.LONG	LOG_PROCESS_LENGTH
	.ADDRESS LOG_PROCESS

LOG_S_DESC:
	.LONG	LOG_SYSTEM_LENGTH
	.ADDRESS LOG_SYSTEM

SYS_DISK_DESC:
	.ASCID	/SYS$DISK/

SYS_SYSDEVICE_DESC:
	.ASCID	/SYS$SYSDEVICE/

TRNLOG_GS_DESC:
	.ASCID	/TRNLOG$_GROUP_SYSTEM/

TRNLOG_PG_DESC:
	.ASCID	/TRNLOG$_PROCESS_GROUP/

TRNLOG_PS_DESC:
	.ASCID	/TRNLOG$_PROCESS_SYSTEM/

TRNLOG_PGS_DESC:
	.ASCID	/TRNLOG$_PROCESS_GROUP_SYSTEM/

LNM_GROUP:
	.ASCII	/LNM$GROUP/
LNM_GROUP_LENGTH = . - LNM_GROUP

LNM_JOB:
	.ASCII	/LNM$JOB/
LNM_JOB_LENGTH	= . - LNM_JOB

LNM_PROCESS:
	.ASCII	/LNM$PROCESS/
LNM_PROCESS_LENGTH = . - LNM_PROCESS

LNM_PROCESS_DIRECTORY:
	.ASCII	/LNM$PROCESS_DIRECTORY/
LNM_PROCESS_DIRECTORY_LENGTH = . - LNM_PROCESS_DIRECTORY

LNM_SYSTEM:
	.ASCII	/LNM$SYSTEM/
LNM_SYSTEM_LENGTH = . - LNM_SYSTEM

LNM_SYSTEM_DIRECTORY:
	.ASCII	/LNM$SYSTEM_DIRECTORY/
LNM_SYSTEM_DIRECTORY_LENGTH = . - LNM_SYSTEM_DIRECTORY

LNM_SYSTEM_TABLE:
	.ASCII	/LNM$SYSTEM_TABLE/
LNM_SYSTEM_TABLE_LENGTH = . - LNM_SYSTEM_TABLE

LOG_GROUP:
	.ASCII	/LOG$GROUP/
LOG_GROUP_LENGTH = . - LOG_GROUP

LOG_PROCESS:
	.ASCII	/LOG$PROCESS/
LOG_PROCESS_LENGTH = . - LOG_PROCESS

LOG_SYSTEM:
	.ASCII	/LOG$SYSTEM/
LOG_SYSTEM_LENGTH = . - LOG_SYSTEM

;
; ATTRIBUTE, ACCESS MODE AND ITEM BUFFERS WHICH ARE PASSED BY REFERENCE.
;

EXEC_MODE:				; EXECUTIVE ACCESS MODE BUFFER
	.LONG	PSL$C_EXEC

KERNEL_MODE:				; KERNEL ACCESS MODE BUFFER
	.LONG	PSL$C_KERNEL

SUPER_MODE:				; SUPERVISOR ACCESS MODE BUFFER
	.LONG	PSL$C_SUPER

LNM_NO_ALIAS:				; NO_ALIAS ATTRIBUTE BUFFER
	.LONG	LNM$M_NO_ALIAS

TERMINAL_BUFFER:			; TERMINAL ATTRIBUTES ITEM BUFFER
	.LONG	LNM$M_TERMINAL

;
; ITEM LISTS FOR THE CREATION OF THE LOGICAL NAMES SETUP AT SYSTEM 
; INITIALIZATION TIME.
;

DIRECTORIES_LIST:			; ITEM LIST FOR LNM$DIRECTORIES
	.WORD	4			; TERMINAL ATTRIBUTES ITEM
	.WORD	LNM$_ATTRIBUTES	
	.ADDRESS TERMINAL_BUFFER
	.LONG	0

	.WORD	LNM_PROCESS_DIRECTORY_LENGTH ; LNM$PROCESS_DIRECTORY STRING ITEM
	.WORD	LNM$_STRING
	.ADDRESS LNM_PROCESS_DIRECTORY
	.LONG	0

	.WORD	LNM_SYSTEM_DIRECTORY_LENGTH ; LNM$SYSTEM_DIRECTORY STRING ITEM
	.WORD	LNM$_STRING
	.ADDRESS LNM_SYSTEM_DIRECTORY
	.LONG	0

	.LONG	0			; END OF ITEM LIST

FILE_DEV_SUPER_LIST:			; ITEM LIST FOR SUPERVISOR LNM$FILE_DEV 
	.WORD	LNM_PROCESS_LENGTH	; LNM$PROCESS STRING ITEM
	.WORD	LNM$_STRING
	.ADDRESS LNM_PROCESS
	.LONG	0

	.WORD	LNM_JOB_LENGTH		; LNM$JOB STRING ITEM
	.WORD	LNM$_STRING
	.ADDRESS LNM_JOB
	.LONG	0

	.WORD	LNM_GROUP_LENGTH	; LNM$GROUP STRING ITEM
	.WORD	LNM$_STRING
	.ADDRESS LNM_GROUP
	.LONG	0

	.WORD	LNM_SYSTEM_LENGTH	; LNM$SYSTEM STRING ITEM
	.WORD	LNM$_STRING
	.ADDRESS LNM_SYSTEM
	.LONG	0

	.LONG	0			; END OF ITEM LIST

FILE_DEV_EXEC_LIST:			; ITEM LIST FOR EXECUTIVE LNM$FILE_DEV
PERMANENT_MAILBOX_LIST:			; ITEM LIST FOR LNM$PERMANENT_MAILBOX
	.WORD	LNM_SYSTEM_LENGTH	; LNM$SYSTEM STRING ITEM
	.WORD	LNM$_STRING
	.ADDRESS LNM_SYSTEM
	.LONG	0

	.LONG	0			; END OF ITEM LIST

LOG_G_LIST:				; ITEM LIST FOR LOG$GROUP
	.WORD	LNM_GROUP_LENGTH	; LNM$GROUP STRING ITEM
	.WORD	LNM$_STRING
	.ADDRESS LNM_GROUP
	.LONG	0

	.LONG	0			; END OF ITEM LIST

LOG_P_LIST:				; ITEM LIST FOR LOG$PROCESS
	.WORD	LNM_PROCESS_LENGTH	; LNM$PROCESS STRING ITEM
	.WORD	LNM$_STRING
	.ADDRESS LNM_PROCESS
	.LONG	0

	.WORD	LNM_JOB_LENGTH		; LNM$JOB STRING ITEM
	.WORD	LNM$_STRING
	.ADDRESS LNM_JOB
	.LONG	0

	.LONG	0			; END OF ITEM LIST

LOG_S_LIST:				; ITEM LIST FOR LOG$SYSTEM
	.WORD	LNM_SYSTEM_LENGTH	; LNM$SYSTEM STRING ITEM
	.WORD	LNM$_STRING
	.ADDRESS LNM_SYSTEM
	.LONG	0

	.LONG	0			; END OF ITEM LIST

SYSTEM_LIST:				; ITEM LIST FOR LNM$SYSTEM 
	.WORD	4			; TERMINAL ATTRIBUTES ITEM
	.WORD	LNM$_ATTRIBUTES
	.ADDRESS TERMINAL_BUFFER
	.LONG	0

	.WORD	LNM_SYSTEM_TABLE_LENGTH	; LNM$SYSTEM_TABLE STRING ITEM
	.WORD	LNM$_STRING
	.ADDRESS LNM_SYSTEM_TABLE
	.LONG	0

	.LONG	0			; END OF ITEM LIST

TEMPORARY_MAILBOX_LIST:			; ITEM LIST FOR LNM$TEMPORARY_MAILBOX
	.WORD	LNM_JOB_LENGTH		; LNM$JOB STRING ITEM
	.WORD	LNM$_STRING
	.ADDRESS LNM_JOB
	.LONG	0

	.LONG	0			; END OF ITEM LIST

TRNLOG_GS_LIST:				; ITEM LIST FOR TRNLOG$_GROUP_SYSTEM
	.WORD	LOG_GROUP_LENGTH	; LOG$GROUP STRING ITEM
	.WORD	LNM$_STRING
	.ADDRESS LOG_GROUP
	.LONG	0

	.WORD	LOG_SYSTEM_LENGTH	; LOG$SYSTEM STRING ITEM
	.WORD	LNM$_STRING
	.ADDRESS LOG_SYSTEM
	.LONG	0

	.LONG	0			; END OF ITEM LIST

TRNLOG_PG_LIST:				; ITEM LIST FOR TRNLOG$_PROCESS_GROUP
	.WORD	LOG_PROCESS_LENGTH	; LOG$PROCESS STRING ITEM
	.WORD	LNM$_STRING
	.ADDRESS LOG_PROCESS
	.LONG	0

	.WORD	LOG_GROUP_LENGTH	; LOG$GROUP STRING ITEM
	.WORD	LNM$_STRING
	.ADDRESS LOG_GROUP
	.LONG	0

	.LONG	0			; END OF ITEM LIST

TRNLOG_PS_LIST:				; ITEM LIST FOR TRNLOG$_PROCESS_SYSTEM
	.WORD	LOG_PROCESS_LENGTH	; LOG$PROCESS STRING ITEM
	.WORD	LNM$_STRING
	.ADDRESS LOG_PROCESS
	.LONG	0

	.WORD	LOG_SYSTEM_LENGTH	; LOG$SYSTEM STRING ITEM
	.WORD	LNM$_STRING
	.ADDRESS LOG_SYSTEM
	.LONG	0

	.LONG	0			; END OF ITEM LIST

TRNLOG_PGS_LIST:			; ITEM LIST FOR TRNLOG$_PROCESS_GROUP_SYSTEM
	.WORD	LOG_PROCESS_LENGTH	; LOG$PROCESS STRING ITEM
	.WORD	LNM$_STRING
	.ADDRESS LOG_PROCESS
	.LONG	0

	.WORD	LOG_GROUP_LENGTH	; LOG$GROUP STRING ITEM
	.WORD	LNM$_STRING
	.ADDRESS LOG_GROUP
	.LONG	0

	.WORD	LOG_SYSTEM_LENGTH	; LOG$SYSTEM STRING ITEM
	.WORD	LNM$_STRING
	.ADDRESS LOG_SYSTEM
	.LONG	0

	.LONG	0			; END OF ITEM LIST

;
; ARGUMENT LISTS FOR THE $CRELNMS. THIS SYSTEM SERVICES CAN NOT BE DIRECTLY 
; ISSUED AT SYSTEM INITIALIZATION BECAUSE THE SWAPPER DOES NOT HAVE A P1 SPACE 
; WITH SYSTEM SERVICE VECTORS; HOWEVER, IT MAYBE CALLED DIRECTLY. SETUP AN 
; ARGUMENT LIST FOR EACH AND EVERY DIRECT CALL.
;

DIRECTORIES_ARG:			; ARGUMENT LIST FOR LNM$DIRECTORIES
	$CRELNM	-
		ACMODE	= KERNEL_MODE, -
		ATTR	= LNM_NO_ALIAS, -
		ITMLST	= DIRECTORIES_LIST, -
		LOGNAM	= LNM_DIRECTORIES_DESC, -
		TABNAM  = LNM_SYSTEM_DIRECTORY_DESC

FILE_DEV_EXEC_ARG:			; ARGUMENT LIST FOR EXECUTIVE LNM$FILE_DEV 
	$CRELNM	-
		ACMODE	= EXEC_MODE, -
		ITMLST	= FILE_DEV_EXEC_LIST, -
		LOGNAM	= LNM_FILE_DEV_DESC, -
		TABNAM  = LNM_SYSTEM_DIRECTORY_DESC

FILE_DEV_SUPER_ARG:			; ARGUMENT LIST FOR SUPERVISOR LNM$FILE_DEV 
	$CRELNM	-
		ACMODE	= SUPER_MODE, -
		ITMLST	= FILE_DEV_SUPER_LIST, -
		LOGNAM	= LNM_FILE_DEV_DESC, -
		TABNAM  = LNM_SYSTEM_DIRECTORY_DESC

LOG_G_ARG:				; ARGUMENT LIST FOR LOG$GROUP
	$CRELNM	-	
		ACMODE	= KERNEL_MODE, -
		ITMLST	= LOG_G_LIST, -
		LOGNAM	= LOG_G_DESC, -
		TABNAM  = LNM_SYSTEM_DIRECTORY_DESC

LOG_P_ARG:				; ARGUMENT LIST FOR LOG$PROCESS
	$CRELNM	-	
		ACMODE	= KERNEL_MODE, -
		ITMLST	= LOG_P_LIST, -
		LOGNAM	= LOG_P_DESC, -
		TABNAM  = LNM_SYSTEM_DIRECTORY_DESC

LOG_S_ARG:				; ARGUMENT LIST FOR LOG$SYSTEM
	$CRELNM	-	
		ACMODE	= KERNEL_MODE, -
		ITMLST	= LOG_S_LIST, -
		LOGNAM	= LOG_S_DESC, -
		TABNAM  = LNM_SYSTEM_DIRECTORY_DESC

PERMANENT_MAILBOX_ARG:			; ARGUMENT LIST FOR LNM$PERMANENT_MAILBOX
	$CRELNM	-	
		ACMODE	= KERNEL_MODE, -
		ITMLST	= PERMANENT_MAILBOX_LIST, -
		LOGNAM	= LNM_PERMANENT_MAILBOX_DESC, -
		TABNAM  = LNM_SYSTEM_DIRECTORY_DESC

SYSTEM_ARG:				; ARGUMENT LIST FOR LNM$SYSTEM
	$CRELNM	-
		ACMODE	= KERNEL_MODE, -
		ATTR	= LNM_NO_ALIAS, -
		ITMLST	= SYSTEM_LIST, -
		LOGNAM	= LNM_SYSTEM_DESC, -
		TABNAM  = LNM_SYSTEM_DIRECTORY_DESC

TEMPORARY_MAILBOX_ARG:			; ARGUMENT LIST FOR LNM$TEMPORARY_MAILBOX
	$CRELNM	-	
		ACMODE	= KERNEL_MODE, -
		ITMLST	= TEMPORARY_MAILBOX_LIST, -
		LOGNAM	= LNM_TEMPORARY_MAILBOX_DESC, -
		TABNAM  = LNM_SYSTEM_DIRECTORY_DESC

TRNLOG_GS_ARG:				; ARGUMENT LIST FOR TRNLOG$_GROUP_SYSTEM
	$CRELNM	-	
		ACMODE	= KERNEL_MODE, -
		ITMLST	= TRNLOG_GS_LIST, -
		LOGNAM	= TRNLOG_GS_DESC, -
		TABNAM  = LNM_SYSTEM_DIRECTORY_DESC

TRNLOG_PG_ARG:				; ARGUMENT LIST FOR TRNLOG$_PROCESS_GROUP
	$CRELNM	-	
		ACMODE	= KERNEL_MODE, -
		ITMLST	= TRNLOG_PG_LIST, -
		LOGNAM	= TRNLOG_PG_DESC, -
		TABNAM  = LNM_SYSTEM_DIRECTORY_DESC

TRNLOG_PS_ARG:				; ARGUMENT LIST FOR TRNLOG$_PROCESS_SYSTEM
	$CRELNM	-	
		ACMODE	= KERNEL_MODE, -
		ITMLST	= TRNLOG_PS_LIST, -
		LOGNAM	= TRNLOG_PS_DESC, -
		TABNAM  = LNM_SYSTEM_DIRECTORY_DESC

TRNLOG_PGS_ARG:				; ARGUMENT LIST FOR TRNLOG$_PROCESS_GROUP_SYSTEM
	$CRELNM	-	
		ACMODE	= KERNEL_MODE, -
		ITMLST	= TRNLOG_PGS_LIST, -
		LOGNAM	= TRNLOG_PGS_DESC, -
		TABNAM  = LNM_SYSTEM_DIRECTORY_DESC

	.PSECT  $$$260			; WRITABLE PSECT
					; ITMLST MUST BE FOLLOWING TWO CRELNM

SYS_DISK_ARG:				; ARGUMENT LIST FOR SYS$DISK
	$CRELNM	-
		ACMODE 	= EXEC_MODE, -
		LOGNAM	= SYS_DISK_DESC, -
		TABNAM  = LNM_SYSTEM_DESC

SYS_SYSDEVICE_ARG:			; ARGUMENT LIST FOR SYS$SYSDEVICE
	$CRELNM	-
		ACMODE 	= EXEC_MODE, -
		LOGNAM	= SYS_SYSDEVICE_DESC, -
		TABNAM  = LNM_SYSTEM_DESC


	.PSECT	YF$LOWUSE		; PAGED PSECT AT END OF SYS.EXE

;
; DEFINE A QUOTA LIST TO BE USED BY VARIOUS PIECES OF THE SYSTEM WHEN
; CREATING A SPECIAL SYSTEM PROCESS, LIKE A FILES-11 ACP.  EVERY QUOTA
; IS MENTIONED EXPLICITLY.  NOTE THAT THIS LIST CAN BE TAILORED BY
; COPYING IT TO SOME TEMPORARY LOCATION AND APPENDING NEW QUOTA ITEMS
; TO THE END OF THE LIST.  THE $CREPRC SYSTEM SERVICE USES THE LAST
; VALUE OF A SPECIFIED QUOTA IN THE LIST WHEN IT CREATES A PROCESS.
; NOTE THAT THE END OF THE LIST MUST BE TERMINATED BY A ZERO BYTE,
; AND THAT THE LENGTH OF THE LIST, AS GIVEN BY PQL$C_SYSPQLLEN, DOES NOT
; INCLUDE THE LIST TERMINATOR.
;

PQL$AB_SYSPQL::				; SYSTEM PROCESS QUOTA LIST
	.BYTE	PQL$_ASTLM		; PROCESS AST LIMIT
	.LONG	10
	.BYTE	PQL$_BIOLM		; PROCESS BUFFERED I/O LIMIT
	.LONG	10
	.BYTE	PQL$_BYTLM		; PROCESS BUFFERED I/O BYTE LIMIT
	.LONG	32768
	.BYTE	PQL$_CPULM		; PROCESS CPU TIME LIMIT
	.LONG	0			; ZERO IMPLIES NO LIMIT
	.BYTE	PQL$_DIOLM		; PROCESS DIRECT I/O LIMIT
	.LONG	10
	.BYTE	PQL$_FILLM		; PROCESS OPEN FILE LIMIT
	.LONG	60
	.BYTE	PQL$_PGFLQUOTA		; PROCESS PAGE FILE QUOTA
	.LONG	20000
	.BYTE	PQL$_PRCLM		; PROCESS SUBPROCESS CREATION LIMIT
	.LONG	8
	.BYTE	PQL$_TQELM		; PROCESS TIMER QUEUE ENTRY LIMIT
	.LONG	8
	.BYTE	PQL$_WSDEFAULT		; PROCESS DEFAULT WORKING SET SIZE
	.LONG	100
	.BYTE	PQL$_WSQUOTA		; PROCESS WORKING SET QUOTA
	.LONG	200
	.BYTE	PQL$_WSEXTENT		; PROCESS WORKING SET EXTENT LIMIT
	.LONG	1000
	.BYTE	PQL$_ENQLM		; PROCESS LOCK LIMIT
	.LONG	100
	.BYTE	PQL$_JTQUOTA		; JOB-WIDE LOGICAL NAME TABLE QUOTA
	.LONG	1024
10$:	.BYTE	PQL$_LISTEND		; END OF PROCESS QUOTA LIST

PQL$C_SYSPQLLEN == 10$ - PQL$AB_SYSPQL	; LENGTH OF LIST (MINUS TERMINATOR)
	.PAGE

	.SBTTL	EXE$SWAPINIT - INITIALIZATION AND STARTUP FOR SWAPPER

;++
; FUNCTIONAL DESCRIPTION:
;	EXE$SWAPINIT IS ENTERED WHEN THE SWAPPER PROCESS IS FIRST
;	SCHEDULED AFTER A SYSTEM BOOT/STARTUP.  THIS TRANSFER OCCURS
;	VIA THE INITIAL PC VALUE BUILT INTO THE HARDWARE PCB FOR THE
;	SWAPPER PROCESS.  R4 CONTAINS THE ADDRESS OF THE SWAPPER PCB.
;
;--

EXE$SWAPINIT::				; SWAPPER INITIALIZATION
;
; INITIALIZE PAGED POOL.
;
	MOVL	G^EXE$GL_PAGED,R11	; POINT TO START OF PAGED POOL
	CLRL	(R11)+			; ZAP FORWARD LINK
	MOVL	G^SGN$GL_PAGEDYN,(R11)	; AND SET SIZE

;
; ALLOCATE LOGICAL NAME HASH TABLE.  THE NUMBER OF ENTRIES IN THE HASH TABLE
; MUST BE A POWER OF TWO.  SO THE ALLOCATED SIZE IS THE SMALLEST POWER OF
; TWO LARGER THAN THE SYSGEN PARAMETER.
;
	PUSHL	@LNM$AL_HASHTBL 	; SAVE ADDR OF CRELNM ITMLST BLOCKS FOR
					; "SYS$DISK" AND "SYS$SYSDEVICE"
	MOVL	#1, R8			; DO THIS TWICE
40$:	SUBL3	#1,G^LNM$GL_HTBLSIZS[R8],R7 ; PICK UP ONE LESS THAN SYSGEN PARM
	CVTLF	R7,R7			; CONVERT TO FLOATING
	EXTZV	#7,#7,R7,R7		; PICK UP EXPONENT-NOW THE POWER OF 2
	CLRL	R1			; CLEAR A REGISTER
	BBSS	R7,R1,50$		; THE SIZE OF THE TABLE ROUNDED UP
50$:	MOVL	R1,G^LNM$GL_HTBLSIZS[R8]; WRITE BACK THE CORRECT VALUE
	SOBGEQ	R8,40$			; LOOP TWO TIMES
;
; INITIALIZE THE SYSTEM SPACE HASH TABLE.
;
	MOVL	G^LNM$GL_HTBLSIZS,R1	; SIZE OF TABLE IN ENTRIES
	MOVAL	@#LNMHSH$K_BUCKET[R1],R1; MULT BY 4 AND ADD OVERHEAD
	JSB	G^EXE$ALOPAGED		; ALLOCATE MEMORY
	PUSHR	#^M<R1,R2>		; SAVE REGISTERS DESTORYED BY MOVC5
	MOVC5	#0,#0,#0,R1,(R2)	; ZERO HASH TABLE
	POPR	#^M<R1,R4>		; RESTORE REGISTERS DESTORYED BY MOVC5
					;  NOTE: tHAT R2 COMES BACK AS R4
	SUBL3	#1,G^LNM$GL_HTBLSIZS,R0 ; CALC UPPER BOUND OF HASH INDEX
	MCOML	R0,LNMHSH$L_MASK(R4)	; STORE HASH INDEX MASK
	MOVW	R1,LNMHSH$W_SIZE(R4)	; STORE SIZE IN STRUCTURE HEADER
	MOVB	#DYN$C_RSHT,LNMHSH$B_TYPE(R4)
					; STORE STRUCTURE TYPE
	MOVAB	(R4),@LNM$AL_HASHTBL	; STUFF WAY POINTER TO TABLE
					; NOTE: THAT THE HASH TABLE HAS BEEN
					; INITIALIZED TO ZERO

;
; FIX UP THE SYSTEM LOGICAL NAME DIRECTORY, AND INSERT IT IN INTO THE 
; APPROPRIATE HASH BUCKET OF THE SHAREABLE LOGICAL NAME HASH TABLE.
;

	MOVAB	LNM$SYSTEM_DIRECTORY,R3
	MOVAL	(R4),LNM_SYSTEM_DIR_LNMTH+LNMTH$L_HASH
					; HASH TABLE ADDRESS IN LNMTH
	MOVZBL	LNMB$T_NAME(R3),R0	; GET SIZE OF DIRECTORY NAME
	MOVAB	LNMB$T_NAME+1(R3),R1	; GET ADDRESS OF DIRECTORY NAME
	JSB	LNM$HASH		; HASH THE DIRECTORY NAME
	BICL2	LNMHSH$L_MASK(R4),R0	; MODIFY THE INDEX TO BE IN RANGE
	MOVAL	(R3),LNMHSH$C_BUCKET(R4)[R0]
				        ; INSERT DIRECTORY LNMB IN HASH TABLE
	MOVAL	LNMHSH$C_BUCKET(R4)[R0],LNMB$L_BLINK(R3)
					; INSERT HASH TBL ENTRY IN DIRECT LNMB

;
; FIXUP THE SYSTEM LOGICAL NAME TABLE, LNM$SYSTEM_TABLE, AND INSERT IT INTO THE 
; APPROPRIATE HASH BUCKET OF THE SYSTEM LOGICAL NAME HASH TABLE.
;

	MOVAB	SYSTEM_TABLE,R1		; RETRIEVE SYSTEM TABLE LNMB ADDRESS
	MOVL	@LNM$AL_HASHTBL,-	; MOVE THE ADDRESS OF THE SHAREABLE 
		SYSTEM_TABLE_LNMTH+-	; LOGICAL NAME HASH TABLE INTO THE 
		LNMTH$L_HASH		; SYSTEM TABLE'S TABLE HEADER
	CLRL	R2			; NO SPECIAL INSERTION ATTRIBUTES
	JSB	G^LNM$INSLOGTAB		; APPROPRIATELY INSERT LNM$SYSTEM_TABLE

;
; CREATE THE SYSTEM LOGICAL NAMES, CONTAINED WITHIN THE SYSTEM DIRECTORY TABLE,
; - ALL OF WHICH MUST BE CREATED AT SYSTEM INITIALIZATION TIME.
;

	CALLG -				; CREATE LNM$DIRECTORIES
		DIRECTORIES_ARG, -
		@#SYS$CRELNM-P1SYSVECTORS+^X80000000

	CALLG -				; CREATE EXECUTIVE LNM$FILE_DEV
		FILE_DEV_EXEC_ARG, -
		@#SYS$CRELNM-P1SYSVECTORS+^X80000000

	CALLG -				; CREATE SUPERVSIOR LNM$FILE_DEV
		FILE_DEV_SUPER_ARG, -
		@#SYS$CRELNM-P1SYSVECTORS+^X80000000

	CALLG -				; CREATE LOG$GROUP
		LOG_G_ARG, -
		@#SYS$CRELNM-P1SYSVECTORS+^X80000000

	CALLG -				; CREATE LOG$PROCESS
		LOG_P_ARG, -
		@#SYS$CRELNM-P1SYSVECTORS+^X80000000

	CALLG -				; CREATE LOG$SYSTEM
		LOG_S_ARG, -
		@#SYS$CRELNM-P1SYSVECTORS+^X80000000

	CALLG -				; CREATE LNM$PERMANENT_MAILBOX
		PERMANENT_MAILBOX_ARG, -
		@#SYS$CRELNM-P1SYSVECTORS+^X80000000

	CALLG -				; CREATE LNM$SYSTEM
		SYSTEM_ARG, -
		@#SYS$CRELNM-P1SYSVECTORS+^X80000000

	CALLG -				; CREATE LNM$TEMPORARY_MAILBOX
		TEMPORARY_MAILBOX_ARG, -
		@#SYS$CRELNM-P1SYSVECTORS+^X80000000

	CALLG -				; CREATE TRNLOG$_GROUP_SYSTEM
		TRNLOG_GS_ARG, -
		@#SYS$CRELNM-P1SYSVECTORS+^X80000000

	CALLG -				; CREATE TRNLOG$_PROCESS_GROUP
		TRNLOG_PG_ARG, -
		@#SYS$CRELNM-P1SYSVECTORS+^X80000000

	CALLG -				; CREATE TRNLOG$_PROCESS_SYSTEM
		TRNLOG_PS_ARG, -
		@#SYS$CRELNM-P1SYSVECTORS+^X80000000

	CALLG -				; CREATE TRNLOG$_PROCESS_GROUP_SYSTEM
		TRNLOG_PGS_ARG, -
		@#SYS$CRELNM-P1SYSVECTORS+^X80000000

;
; CREATE TWO STARTUP LOGICAL NAMES.
;

	POPL	R4			; RECOVER ADDR OF CRELOG BLOCK
	MOVAL	(R4),SYS_DISK_ARG+CRELNM$_ITMLST
					; STUFF THE ADDRESS OF THE ITEM LIST
	MOVAL	BDL$L_SYSDLOG(R4),SYS_SYSDEVICE_ARG+CRELNM$_ITMLST
					; STUFF THE ADDRESS OF THE ITEM LIST

	CALLG -				; CREATE SYS$DISK
		SYS_DISK_ARG, -
		@#SYS$CRELNM-P1SYSVECTORS+^X80000000

	CALLG -				; CREATE SYS$SYSDEVICE
		SYS_SYSDEVICE_ARG, -
		@#SYS$CRELNM-P1SYSVECTORS+^X80000000

	MOVZBL	#BDL$S_CRELNM_ITMLST,R1	; GET THE SIZE OF THE STRUCTURE
	MOVL	R4,R0			; MOVE STRUCTURE ADDR INTO CORRECT REG
	JSB	EXE$DEANONPGDSIZ	; RETURN THE MEMORY

;
; CREATE INITIAL PROCESSES
;

; THE $CREPRC_S MACRO CANNOT BE USED BECAUSE THAT MACRO GENERATES A
; CALL THROUGH THE P1 SYSTEM SERVICE VECTOR PAGES AND THE SWAPPER DOES 
; NOT HAVE A P1 SPACE. tHE SENSE OF THE CREATE PROCESS CALL IS THE
; FOLLOWING.
;
;	$CREPRC_S	INPUT=TT0DESC,-	;
;			OUTPUT=TT0DESC,-;
;			ERROR=TT0DESC,-	;
;			IMAGE=IMGDESC,-	;
;			UIC=#^X80020,-	;
;			STSFLG=#<PRC$M_NOACNT!PRC$M_SSRWAIT>,-
;			BASPRI=#2	;

	PUSHL	#<PRC$M_NOACNT!PRC$M_SSRWAIT>
	CLRL	-(SP)
	PUSHL	#^X80020
	PUSHL	#2
	CLRQ	-(SP)
	PUSHL	#0
	PUSHAQ	TT0DESC
	PUSHL	(SP)
	PUSHL	(SP)
	PUSHAQ	IMGDESC
	PUSHL	#0
	CALLS	#12,@#SYS$CREPRC-P1SYSVECTORS+^X80000000
	JMP	G^LOOP			; JUMP OFF TO THE MAIN LOOP
	.PAGE

	.SBTTL	SWAPPER - MAIN LOOP

;++
; FUNCTIONAL DESCRIPTION:
;	THE MAIN LOOP OF THE SWAPPER IS EXECUTED WHENEVER THE SWAPPER IS AWAKENED
;	FOR ANY REASON.  EACH OF THE FUNCTIONAL ROUTINES WILL CHECK TO SEE IF
;	THEY HAVE ANY ACTION TO PERFORM.
;--

        .PSECT	$AEXENONPAGED		; NON-PAGED PSECT
LOOP:	BSBB	BALANCE			; BALANCE FREE PAGE COUNT
	BSBW	MMG$WRTMFYPAG		; WRITE MODIFIED PAGES
	BSBW	SWAPSCHED		; SCHEDULE SWAP
	TSTL	W^EXE$GL_PFATIM		; CHECK FOR POWER FAIL TIME
	BEQL	15$			; BRANCH IF NO POWERFAIL
	JSB	EXE$POWERAST		; GIVE ANY REQUIRED POWER FAIL ASTS
15$:	MOVL	W^SCH$GL_CURPCB,R4	; GET PROPER PCB ADDRESS
	MOVAQ	W^SCH$GQ_HIBWQ,R2	; AND ADDRESS OF WAIT QUEUE HEADER
	SETIPL	#IPL$_SYNCH		; BLOCK SYSTEM EVENTS WHILE CHECKING
	BBSC	#PCB$V_WAKEPEN,PCB$L_STS(R4),20$ ; TEST AND CLEAR WAKE PENDING
	PUSHL	#0			; NULL PSL
	BSBW	SCH$WAITK		; WAIT WITH STACK CLEAN
20$:	SETIPL	#0			; DROP IPL
	BRB	LOOP			; CHECK FOR WORK TO DO
	.DISABLE LSB
	.PAGE

	.SBTTL	BALANCE FREE PAGE COUNT

;++
; FUNCTIONAL DESCRIPTION:
;	BALANCE WILL ENSURE THAT THE FREE PAGE LIST HAS AT LEAST THE NUMBER OF
;	PAGES SPECIFIED BY THE PARAMETER FREELIM.  IF NOT, PAGES WILL BE MADE 
;	AVAILABLE BY EITHER WRITING MODIFIED PAGES OR OUTSWAPPING PROCESSES.
;	IF SUFFICIENT FREE PAGES ARE AVAILABLE, THEN A CHECK IS MADE FOR 
;	DELETED PROCESS HEADERS IN NEED OF CLEANUP.
;--

BALANCE:				; BALANCE FREE PAGE COUNT
	CMPL	W^SGN$GL_FREELIM,W^SCH$GL_FREECNT ; ARE WE HERE DUE TO FREELIM?
	BLEQ	5$			; BRANCH IF NOT
	SUBL3	W^SGN$GL_FREEGOAL,W^SCH$GL_FREECNT,R3 ; SUFFICIENT FREE PAGES?
	BLSS	20$			; NO, MUST ACQUIRE SOME
5$:	TSTW	W^SCH$GW_DELPHDCT	; CHECK FOR DELETED PROCESS HEADERS
	BEQL	10$			; NONE, EXIT
	CLRL	R3			; INDICATE NO FREE PAGES NEEDED
	BRB	25$			;
10$:	RSB				; IN BALANCE, RETURN
20$:					;
	BBS	S^#SCH$V_MPW,W^SCH$GB_SIP,25$	; MODIFIED PAGE WRITING ACTIVE
	SUBL3	W^SCH$GL_MFYLOLIM,W^SCH$GL_MFYCNT,R0 ; HOW MUCH WILL WRITING PAGES
	BLEQ	25$			; NONE, MUST OUTSWAP
	ADDL	R3,R0			; YIELD RELATIVE TO WHAT WE NEED?
	BLSS	25$			; NOT ENOUGH, MUST OUTSWAP
	MOVL	W^SCH$GL_MFYLOLIM,W^SCH$GL_MFYLIM ; TRIGGER MODIFIED PAGE WRITING
	RSB				; AND EXIT TO LET IT HAPPEN
;
;	MUST OUTSWAP, FIRST CHECK FOR SWAP IN PROGRESS SINCE SWAPPER IS
;	NOT RE-ENTRANT.  IF PURGING DELETED HEADERS, THEN THE NUMBER OF
;	REQUIRED PAGES (IN R3) WILL BE SET TO ZERO.  AN INFINITE INSWAP PRIORITY
;	WILL BE ASSUMED WHILE BALANCING THE NUMBER FO FREE PAGES.
;
25$:	BBSS	S^#SCH$V_SIP,W^SCH$GB_SIP,10$	; EXIT IF SWAPPER ALREADY BUSY
	SETIPL	#IPL$_SYNCH		; BLOCK SYSTEM EVENTS
	PUSHR	#^M<R6,R7,R8,R9,R10,R11,AP,FP>	; SAVE NON-STANDARD REGISTERS
	CLRB	W^SWP$GB_ISWPRI		; SET PRIORITY FOR SWAP SCHEDULE
	MOVL	R3,FP			; GET AND TEST FREE PAGE DEFICIT
	BGEQ	30$			; NONE, PURGING DELETED HEADERS
	TSTW	W^SWP$GW_BALCNT		; CHECK FOR SINGULAR BALANCE SET
	BNEQ	30$			; NO, CAN OUTSWAP
	CLRL	FP			; PREVENT OUTSWAP SCHEDULE
30$:	BRW	OUTSWAP			; TRY TO FORCE AN OUTSWAP
	.PAGE

	.SBTTL	SCHEDULE SWAP

;++
; FUNCTIONAL DESCRIPTION:
;	SWAPSCHED IS CALLED BY THE MAIN LOOP OF THE SWAPPER PROCESS TO CHECK
;	ELIGIBLE INSWAP CANDIDATES AND TO PROVIDE MEMORY NEEDED FOR THEIR
;	INSWAP.  A QUICK EXIT WILL BE TAKEN IF THE SWAPPER IS ALREADY BUSY.
;	NO OUTSWAP WILL BE NEEDED IF THE NUMBER OF REQUIRED PAGES CAN BE
;	TAKEN FROM THE FREE PAGE LIST LEAVING AT LEAST FREELIM STILL FREE.
;	OTHERWISE OUTSWAP WILL BE ENTERED TO MAKE PAGES AVAILABLE BY ANY
;	MEANS NECESSARY.
;--

QEMPTY:	BUG_CHECK QUEUEMPTY,FATAL	; EMPTY QUEUE OR NOT A PCB

SWAPSCHED:				;
	SETIPL	#IPL$_SYNCH		; BLOCK SYSTEM EVENTS
	BBSS	S^#SCH$V_SIP,W^SCH$GB_SIP,5$	; EXIT IF SWAP IN PROGRESS
	FFS	#0,#32,W^SCH$GL_COMOQS,R2; FIND HIGHEST PRIORITY QUEUE
	BNEQ	10$			; FOUND ONE
	BBCC	S^#SCH$V_SIP,W^SCH$GB_SIP,5$	; CLEAR SWAP IN PROGRESS
5$:	SETIPL	#0			; DROP IPL
	RSB				; AND RETURN

10$:					;
	PUSHR	#^M<R6,R7,R8,R9,R10,R11,AP,FP>	; SAVE REGS OTHER THAN R0-R5
	MOVAQ	W^SCH$AQ_COMOH[R2],R3	; COMPUTE ADDRESS OF QUEUE HEADER
	MOVL	(R3),R4			; GET PCB ADDRESS
;
; THE FOLLOWING CHECK IS NEEDED DUE TO THE ODIOUS MISLEADING SYMPTOMS THAT
; MIGHT OTHERWISE RESULT.
;
	CMPB	#DYN$C_PCB,PCB$B_TYPE(R4); IS THIS A GOOD PCB?
	BNEQ	QEMPTY			;  BUGCHECK IF NOT
;
; DETERMINE THE SIZE OF THE INSWAP CANDIDATE, TAKING INTO ACCOUNT THE FACT
; THAT THE PROCESS HEADER MIGHT ALREADY BE RESIDENT.
;
	MOVZWL	PCB$W_PPGCNT(R4),R0	; COUNT OF PROCESS PAGES
	MOVZWL	PCB$W_GPGCNT(R4),R10	; COUNT OF GLOBAL PAGES
	ADDL	R0,R10			; SUM PAGE COUNTS
	BBC	#PCB$V_PHDRES,PCB$L_STS(R4),15$	; CONTINUE IF HEADER NON-RESIDENT
	MOVZWL	PCB$W_APTCNT(R4),R0	; GET ACTIVE PAGE TABLE COUNT
	SUBL	R0,R10			; SUBTRACT RESIDENT HEADER PAGES FROM REQUIRED
15$:					;
	SUBL3	W^SCH$GL_FREELIM,W^SCH$GL_FREECNT,R0	; COMPUTE PAGES AVAILABLE
	MOVB	PCB$B_PRI(R4),W^SWP$GB_ISWPRI	; SAVE PRIORITY OF INSWAP
	SUBL3	R10,R0,FP			; WILL PROCESS FIT?
	BLSS	20$			; NO, MUST OUTSWAP
	MOVW	W^SCH$GW_SWPFAIL,W^SCH$GW_SWPFCNT	; RESET FAILURE COUNTER
	BRW	INSWAP			; YES PERFORM SWAP
;
; IF INSWAPPING A NON-REAL TIME PROCESS, THEN CHECK TO SEE IF ITS CURRENT
; PRIORITY IS THE DEFAULT BACKGROUND PRIORITY.  IF SO, THEN DELAY AT LEAST
; SWAPRATE INTERVAL SINCE THE LAST INSWAP.  THE EFFECT WILL BE TO AVOID FILLING
; THE BALANCE SET WITH CRUNCHING PROCESSES IMMEDIATELY.
;
20$:					; SCHEDULE OUTSWAP
	CMPB	#16,PCB$B_PRI(R4)	; IS THIS A REAL TIME PROCESS?
	BGTR	40$			; BR IF SO
	SUBB3	W^SYS$GB_DEFPRI,#31,R1	; CONVERT PRIORITY TO INTERNAL FORM
	CMPB	R2,R1			; IS THIS A CRUNCHER OR LOW PRIORITY JOB?
	BLSS	40$			; BR IF NOT
	MOVL	EXE$GQ_SYSTIME,R1	; GET CURRENT TIME IN APPROX. 10MS UNITS
	CMPL	R1,W^SWP$GL_SWTIME	; HAS INTERVAL ELAPSED?
	BGTRU	40$			; BR IF YES
	BRW	SWAPEXIT		; CAN'T DO SWAP NOW
40$:					;
	.PAGE

	.SBTTL	OUTSWAP

;--------------------------------------------------------------------
;
;	SCHEDULE AND PERFORM OUTSWAPS IF POSSIBLE
;
;--------------------------------------------------------------------
; FUNCTIONAL DESCRIPTION:
;	THE OUTSWAP STRATEGY IS TO FREE PROCESS HEADERS FOR OUTSWAP PROCESSES,
;	USE AVAILABLE MODIFIED PAGES (AFTER WRITING THEM) AND FINALLY AS A LAST
;	RESORT OUTSWAP ANOTHER PROCESS.  ONLY ONE OF THESE ACTIONS WILL BE TAKEN
;	AT A TIME THEN THE SCHEDULING SITUATION WILL BE RE-EVALUATED.  THE VALUE
;	IN FP INDICATES THE SIZE OF THE PAGE DEFICIT AND WILL BE SET POSITIVE IF
;	ENTERED FROM BALANCE TO FREE DELETED PROCESS HEADERS.
;
; INPUT:	FP - NEGATIVE VALUE WILL PERMIT PROCESS OUTSWAP
;		     ZERO OR POSITIVE WILL PURGE HEADERS ONLY.
;

OUTSWAP:				; TRY TO OUTSWAP
	SUBL3	#1,SGN$GL_BALSETCT,R8	; INIT INDEX FOR BALANCE SLOT SCAN
	MCOML	#0,R9			; INDICATE NO FREE LIST PURGE CANDIDATE
10$:	TSTW	@W^PHV$GL_REFCBAS[R8]	; IS SLOT IN NEED OF CLEANUP?
	BNEQ	12$			; CONTINUE IF NOT RELEASABLE
	BRW	60$			; GO RELEASE PAGE TABLES AND HEADER
12$:	CVTWL	@W^PHV$GL_PIXBAS[R8],R4	; GET PROCESS INDEX
	BLEQ	15$			; DELETED PROCESS OR VACANT SLOT
	MOVL	@W^SCH$GL_PCBVEC[R4],R4	; GET PCB ADDRESS FOR PIX
	BLBS	PCB$L_STS(R4),20$	; SKIP IF PROCESS IS RESIDENT
15$:	BEQL	20$			; VACANT SLOT
	TSTB	W^EXE$GQ_SYSTIME	; ADD 1 IN 8 RANDOMNESS TO DECISION
	BEQL	17$			; BRANCH ON LOW PROBABILITY
	TSTL	R9			; CHECK FOR REMEMBERED INDEX
	BGEQ	20$			; YES DONT OVERWRITE
17$:	MOVL	R8,R9			; SAVE BALANCE SLOT NUMBER OF CANDIDATE
20$:	SOBGEQ	R8,10$			; TRY ALL SLOTS
	TSTB	W^EXE$GQ_SYSTIME+1	; ADD 1 IN 256 RANDOMNESS TO DECISION
	BEQL	21$			; BRANCH ON VERY LOW PROBABILITY
	MOVL	R9,R8			; GET AND TEST SLOT INDEX FOR SECONDARY CANDIDATE
	BGEQ	24$			; BR IF SLOT FOR CLEANUP
21$:	TSTL	FP			; CHECK FOR HEADER PURGE
	BGEQ	22$			; EXIT IF SO
;
; SINCE THERE WAS NO HEADER TO FREE, WE MUST NOW WRITE MODIFIED PAGES OR OUTSWAP
; SOME PROCESS.  ONLY IF MODIFIED PAGES (MFYCNT-LOLIM) WILL TOTALLY SATISFY OUR
; NEEDS WILL THEY BE WRITTEN.  OTHERWISE THE LEAST USEFUL (BY SOME OPINION) PROCESS
; WILL BE OUTSWAPPED AND THE SITUATION RECONSIDERED.
;
	BSBW	SCH$OSWPSCHED		; SCHEDULE OUTSWAP
	TSTL	R4			; ANY CANDIDATE?
	BNEQ	23$			; YES
22$:	BRW	SWAPEXIT		; ELSE EXIT AND TRY LATER
23$:	BRW	70$			; GO DO OUTSWAP
;
; A HEADER SLOT IN NEED OF CLEANUP WAS FOUND, NOW SCAN THE FREELIST FOR ALL
; PAGES WHOSE PTE BACK POINTERS PLACE THEM WITHIN THIS HEADER.  DELETE THE
; CONTENT OF THOSE PAGES VIA MMG$DELCONPFN TO FINALLY REDUCE THE REFERENCE
; COUNT BINDING THE HEADER.
;
24$:	ROTL	#2,W^SWP$GL_BSLOTSZ,R7	; GET SIZE OF BALANCE SLOT IN BYTES
	MULL3	R7,R8,R6		; COMPUTE OFFSET TO BASE OF SLOT
	PUSHAB	@W^SWP$GL_BALSPT[R6]	; ADD BASE TO GET ADDRESS
	ROTL	#7,R6,R2		; FORM OFFSET TO PHD BASE
	PUSHAB	@W^SWP$GL_BALBASE[R2]	; BASE ADDRESS FOR PHD
	ROTL	#7,R7,R1		; MUL SPT SLOT SIZE BY 128
	PUSHAB	@4(SP)[R7]		; FORM HIGH LIMIT FOR PAGTBLPPTE
	PUSHAB	@4(SP)[R1]		; ANS SAVE PTE HIGH LIMIT

;
;	AT THIS POINT:
;
;	00(SP) - HIGH LIMIT ADDRESS FOR PROCESS HEADER
;	04(SP) - HIGH LIMIT FOR PROCESS PAGE TABLE PTE
;	08(SP) - LOW LIMIT FOR PROCESS HEADER
;	12(SP) - LOW LIMIT  FOR PROCESS PAGE TABLE PTE
;
	ASSUME	PFN$C_FREPAGLST EQ 0	;
	ASSUME	PFN$C_MFYPAGLST	EQ 1	;
	ASSUME	PFN$C_BADPAGLST	EQ 2	;
	CLRL	R7			; ASSUME ONLY FREELIST SCAN
	TSTW	@W^PHV$GL_PIXBAS[R8]	; IS THIS A DELETED PROCESS HEADER?
	BGEQ	25$			; BR IF NOT.  ONLY SCAN FREELIST
	MOVL	#PFN$C_BADPAGLST,R7	; INITIALIZE LOOP SCAN TO BADPAGLST
25$:	MOVL	W^PFN$AL_HEAD[R7],R0	; GET HEAD OF LIST TO START SCAN
	BEQL	45$			; NO PAGES, DONE
30$:		PFN_REFERENCE	-
	MOVZWL	<@W^PFN$Ax_FLINK[R0],R9>,-	; GET FORWARD LINK
		LONG_OPCODE=MOVL,-
		IMAGE=SYS_NONPAGED
	MOVL	@W^PFN$AL_PTE[R0],R3	; GET SVA OF PTE FOR PAGE
	ASSUME	PFN$C_PPGTBL EQ 4	
	ASSUME	PFN$C_GPGTBL EQ 5
	EXTZV	#2,#1,@W^PFN$AB_TYPE[R0],R1	; GET PAGE TABLE BIT
	CMPL	R3,8(SP)[R1]		; COMPARE WITH LOW LIMIT
	BLSSU	40$			; OUT OF RANGE
	CMPL	R3,(SP)[R1]		; COMPARE WITH HIGH LIMIT
	BGEQU	40$			; OUT OF RANGE
	BLBC	R7,35$			; BR IF FREE OR BAD LIST
	MOVL	@PFN$AL_BAK[R0],R2	; GET BACKING STORE ADDRESS
	BBS	#PTE$V_TYP0,R2,40$	; LEAVE MODIFIED SECTION PAGES
35$:	MOVL	R7,R2			; SET LIST NUMBER FOR DELETE
	BSBW	MMG$REMPFN		; REMOVE PAGE FROM FREE LIST
	BSBW	RELDELPAGE		; RELEASE PAGE DELETING CONTENT
40$:	MOVL	R9,R0			; FLINK TO NEXT PAGE
	BNEQ	30$			; ANOTHER PAGE TO TRY
45$:	SOBGEQ	R7,25$			; NEXT LIST
	ADDL	#16,SP			; CLEAN STACK OF LIMITS
	TSTW	@W^PHV$GL_REFCBAS[R8]	; DID WE FREE PROCESS HEADER
	BEQL	60$			; YES, RELEASE IT
;
; THERE ARE TWO REASONS THAT MIGHT PREVENT THE HEADER FROM BEING RELEASED BY
; THE FREELIST SCAN:
; 			1. SOME OF THE TRANSITION PAGES ARE ON THE MODIFED LIST.
;			2. THERE IS I/O IN PROGRESS ON THE TRANSITION PAGES.
; TO COVER THE FORMER CASE (SINCE WE CANT REALLY TELL), THE MODIFIED LIST MUST
; BE TOTALLY FLUSHED.  HOWEVER THIS IS ACTUALLY QUITE RARE.
;
	CLRL	W^SCH$GL_MFYLOLIM	; FORCE ENTIRE MODIFY LIST TO BE WRITTEN
	CLRW	W^SCH$GL_MFYLIM		; CLEAR PART OF HI LIMIT, NOT PART THAT
					; INDICATES MODIFIED WRITING IN PROGRESS
	MCOML	#0,R9			; NO, TRY FOR ANOTHER
	BRW	20$			; NOW ATTEMPT CLEANUP
60$:	BRW	RELPHD			; GO RELEASE PROCESS HEADER
70$:					;
;
;	R4 - PCB OF OUTSWAP CANDIDATE, ALREADY MARKED NON-RESIDENT
;

	MOVL	PCB$L_PHD(R4),R5	; GET PROCESS HEADER ADDRESS

	DECW	W^SWP$GW_BALCNT		; DECREASE NUMBER IN BALANCE SET
	BSBW	OSINIT			; INIT REGISTERS FOR SCAN
	CLRW	PCB$W_APTCNT(R4)	; INITIALIZE ACTIVE PAGE TABLE COUNT
	MOVZWL	PHD$W_WSLIST(R5),R7	; WS INDEX FOR PERM PAGES
	MOVZWL	PHD$W_WSLAST(R5),R6	; END OF WORKING SET LIST
;
;	REGISTER CONVENTIONS FOR OWSLOOP ARE:
;
;	R0 - PFN
;	R1 - SCRATCH, WSLX
;	R2 - WORKING SET LIST ENTRY (VIRTUAL ADDRESS+FLAGS)
;	R3 - SVA OF PTE FOR WORKING SET LIST ENTRY
;	R4 - PCB ADDRESS
;	R5 - PHD ADDRESS
;	R6 - END INDEX TO WORKING SET LIST
;	R7 - WSLX (WORKING SET LIST INDEX)
;	R8 - PTE CONTENT
;	R9 - WORKING POINTER TO SWP$AL_MAP
;	R10 - PTE$M_VALID!PTE$C_ERKW
;	R11 - BASE ADDRESS OF SWP$AL_MAP
;
OWSLOOP:				; OUTSWAP WS LOOP
	MOVL	(R5)[R7],R2		; GET WORKING SET LIST ENTRY
	BLBC	R2,NOTVALID		; SKIP IF NOT VALID
	BSBW	MMG$SVAPTECHK		; CONVERT VA TO SVA OF PTE
;
;	R3 <- SVA OF PTE FOR VA IN R2
;
	MOVL	(R3),R8			; GET CONTENT OF PTE
	BLSS	10$			; CONTINUE IF VALID PAGE
	DECL	R2			; CLEAR VALID FLAG
10$:	BICB	#^C<WSL$M_VALID!WSL$M_PAGTYP!WSL$M_PFNLOCK>,R2; ISOLATE INTERESTING FLAGS FOR PAGE
	EXTZV	#PTE$V_PFN,#PTE$S_PFN,R8,R0	; GET PFN FROM PTE
	BSBB	OSDISPATCH		; DISPATCH ON PAGE TYPE
NOTVALID:				;
	AOBLEQ	R6,R7,OWSLOOP		; PROCESS ENTIRE WORKING SET LIST
	BRB	PROCWRT			; DONE WITH WORKING SET LIST, RESET HEADER
OSDISPATCH:				; 
	ASSUME	WSL$V_VALID   EQ  0
	ASSUME	WSL$V_PAGTYP  EQ  1
	ASSUME	WSL$V_PFNLOCK EQ  4
	ASSUME	PFN$C_PROCESS EQ  0
	ASSUME	PFN$C_SYSTEM  EQ  1
	ASSUME	PFN$C_GLOBAL  EQ  2
	ASSUME	PFN$C_GBLWRT  EQ  3
	ASSUME	PFN$C_PPGTBL  EQ  4
	ASSUME	PFN$C_GPGTBL  EQ  5
	MOVAL	(R5)[R7],FP		; COMPUTE ADDRESS OF WSL ENTRY
	CASE	R2,<-			; SWITCH ON WSL PAGE TYPE + PTE VALID BIT
		PROCTRANS,-		; 0 => PROCESS TRANSITION PAGE
		PROCVALID,-		; 1 => PROCESS VALID PAGE
		WSLERR,-		; 2 => ????  BUGCHECK
		WSLERR,-		; 3 => ????  BUGCHECK
		GBLTRANS,-		; 4 => GLOBAL TRANSITION
		GBLVALID,-		; 5 => GLOBAL VALID
		GBLWRTTRANS,-		; 6 => GLOBAL WRITABLE TRANSITION
		GBLWRTVALID-		; 7 => GLOBAL WRITABLE VALID
		PPGTBLTRANS,-		; 8 => PROCESS PAGE TABLE TRANSITION
		PPGTBLVALID,-		; 9 => PROCESS PAGE TABLE VALID
		>,TYPE=B		;
	RSB				; SKIP PFN LOCK PAGES

SPACEFAIL:
	BUG_CHECK INSSWPFIL,FATAL	; INSUFFICIENT SWAP FILE SPACE

PROCWRT:				; RESET PROCESS HEADER BASE REGISTERS
	MOVL	PCB$L_WSSWP(R4),R2	; GET SWAP ADDRESS
	BLEQ	SPACEFAIL		; BRANCH IF NO VBN AVAILABLE TO USE
	MOVZWL	PCB$W_APTCNT(R4),R0	; GET COUNT OF ACTIVE PAGE TABLES
	MOVL	R4,W^OSWPPCB		; SAVE ADDRESS OF OUTSWAP PROCESS
	SUBL	R11,R9			; COMPUTE NUMBER OF PAGES * 4
	ROTL	#<32-2>,R9,R4		; DIVIDE COUNT BY 4
	CMPW	R4,PHD$W_SWAPSIZE(R5)	; DO WE HAVE ENOUGH SPACE FOR SWAP
	BGTRU	SPACEFAIL		; BRANCH IF NOT, THIS IS FATAL
	MOVW	R4,W^OSWPPGS		; SAVE COUNT OF OUTSWAP PAGES
	MOVL	R11,R3			; SVAPTE FOR OUTSWAP I/O
	ADDL	R0,R2			; SKIP HEADER AND ACTIVE PAGE TABLES
	.PAGE


;----------------------------------------------------------------------------
;
;	DO OUTSWAP I/O FOR PROCESS HEADER AND BODY
;
;----------------------------------------------------------------------------

	INCL	W^SWP$GL_OSWPCNT	; ACCOUNT FOR OUTSWAP
	BSBW	SWPWRITE		; WRITE HEADER AND BODY
	BLBS	R0,20$			; CONTINUE IF NO I/O ERROR
	BUG_CHECK OUTSWPERR,FATAL	; **** OUT SWAP I/O ERROR
20$:					;

	BSBW	RELINIT			; INIT REGISTERS FOR RELEASE LOOP
	MOVL	PCB$L_PHD(R4),R5	; GET POINTER TO PHD
	MOVZWL	PHD$W_PHVINDEX(R5),R8	; GET PROCESS HEADER SLOT INDEX
30$:	BICL3	R10,(R9)+,R0 		; GET PAGE NUMBER TO RELEASE
	CMPZV	#PFN$V_PAGTYP,#PFN$S_PAGTYP,@W^PFN$AB_TYPE[R0],#PFN$C_GLOBAL	;
	BEQL	80$			; PAGE IS GLOBAL, COMPLEX CLEANUP
	MOVL	@W^PFN$AL_PTE[R0],R6	; GET POINTER TO PAGE TABLE FOR  PAGE
	BICL	#<PTE$M_VALID!PTE$M_MODIFY>,(R6); CLEAR VALID AND MODIFY
	TSTW	@W^PFN$AW_SWPVBN[R0]	; WAS I/O IN PROGRESS?
	BEQL	40$			; NO, DONT MARK PAGE MODIFIED
	BISB	#PFN$M_MODIFY,@W^PFN$AB_STATE[R0] ; MARK PAGE MODIFIED
	CMPZV	#PFN$V_LOC,#PFN$S_LOC,-	; IF THIS WAS READ IN PROGRESS
		@W^PFN$AB_STATE[R0],#PFN$C_RDERR ; AND IS NOW PAGE READ ERROR
	BNEQ	40$			;
	DECREF				; AND IF THIS IS THE LAST REFERENCE
	BNEQ	60$			;
	MOVZBL	#PFN$C_BADPAGLST,R2	; THEN DIVERT THE PAGE TO
	BSBW	MMG$INSPFNT		; THE BAD PAGE LIST
	BRB	60$			;
40$:	DECREF				; DECREMENT REFERENCE COUNT FOR PAGE
	BNEQ	55$			; NOT RELEASABLE YET
50$:	BSBW	MMG$RELPFN		; RELEASE PFN AS APPROPRIATE
	BRB	60$			; GO FOR NEXT PAGE
55$:	CMPZV	#PFN$V_LOC,#PFN$S_LOC,@W^PFN$AB_STATE[R0],- ;
		#PFN$C_ACTIVE		; IS STATE ACTIVE?
	BNEQ	60$			; NO, THEN LEAVE UNCHANGED
	INSV	#PFN$C_RELPEND,-	; MAKE STATE BE RELEASE PENDING
		#PFN$V_LOC,#PFN$S_LOC,@W^PFN$AB_STATE[R0]; IF SOME I/O OUTSTANDING
60$:	SOBGTR	R7,30$			; NEXT PAGE IN LIST
	BRW	RELPHD			; RELEASE PROCESS HEADER IF POSSIBLE
80$:	DECSHR	GTR=60$,-		; DECREASE SHARE COUNT FOR PAGE
		IMAGE_FLAG=SYS_NONPAGED
	BRB	40$			; RELEASE PAGE TO FREE LIST IF REFCNT=0
	.PAGE

	.SBTTL	RELPHD - RELEASE PROCESS HEADER

;++
; FUNCTIONAL DESCRIPTION:
;	RELPHD CHECKS THE REFERENCE  COUNT ON THE PROCESS HEADER
;	AND RELEASES THE PAGE TABLES FROM THE PROCESS HEADER WHEN ALL
;	OF THEIR PAGES HAVE BEEN RELEASED.  THE PAGE TABLES ARE FIRST WRITTEN
;	TO THE SWAP IMAGE IF THEY ARE MARKED AS UPDATED.
;
; CALLING SEQUENCE:
;	BRW/JMP	RELPHD
;
; INPUT PARAMETERS:
;	R8 - BALANCE SLOT INDEX FOR HEADER TO BE RELEASED
;
; OUTPUT PARAMTERS:
;	R0-R7,R9,R10 VOLATILE
;
; SIDE EFFECTS:
;	THE PAGE TABLES FROM THE PROCESS HEADER MAY BE WRITTEN TO THE
;	SWAP IMAGE FOR THE PROCESS IF THEY HAVE BEEN UPDATED.
;
;--


RELPHD:					;
	TSTW	@W^PHV$GL_REFCBAS[R8]	; SEE IF PROCESS HEADER IS RELEASABLE
	BEQL	5$			; YES, FREE ACTIVE PAGE TABLES
	BRW	OSWPEXIT		; NO, TRY LATER
5$:	MOVL	W^SWP$GL_BSLOTSZ,R7	; SET ITERATION COUNT TO WHOLE BALANCE SLOT
	MULL3	R7,R8,R1		; GET LONG WORD OFFSET TO SLOT
	MOVAL	@W^SWP$GL_BALSPT[R1],R6	; POINT TO BASE OF THIS SLOT
	BSBW	OSINIT			; INIT REGISTERS FOR SCAN
	CVTWL	@W^PHV$GL_PIXBAS[R8],R4	; GET INDEX TO PROCESS IN SLOT
	BLSS	12$			; BR IF DELETED PROCESS
	MOVL	@W^SCH$GL_PCBVEC[R4],R4	; AND TRANSLATE TO PCB ADDRESS
	MOVL	PCB$L_PHD(R4),R5	; GET PROCESS HEADER ADDRESS
	MOVL	R8,PCB$L_PHD(R4)	; INDICATE NO PHD FOR PROCESS
	SUBL	R5,PHD$L_P0BR(R5)	; UNBIAS MEMORY MANAGEMENT BASE REGISTERS
	SUBL	R5,PHD$L_P1BR(R5)	; FOR BOTH P0 AND P1 SPACE
	BBCC	#PCB$V_PHDRES,PCB$L_STS(R4),7$	; MARK PHD NON-RESIDENT
7$:	MOVL	PHD$L_WSLX(R5),AP	; GET POINTER TO WSLX SAVE AREA
	MOVAL	(R5)[AP],AP		; AND CONVERT TO BYTE ADDRESS
	MOVL	PHD$L_BAK(R5),FP	; GET POINTER TO BACKING STORE VECTOR
	MOVAL	(R5)[FP],FP		; AND CONVERT TO BYTE ADDRESS
	CLRW	PHD$W_EMPTPG(R5)	; CLEAR COUNT OF EMPTY WSL PAGES
10$:	MOVL	(R6)+,(FP)+		; COPY ENTRY FROM SPT
	BLSS	15$			; BR IF VALID
	BNEQ	11$			; BR IF NOT EMPTY WSL PAGE
	INCW	PHD$W_EMPTPG(R5)	; COUNT EMPTY WSL PAGES
11$:	CLRL	-4(R6)			; ZAP INVALID ENTRY TO NO-ACCESS
	CLRW	(AP)+			; AND CLEAR WSLX VALUE FOR PAGE
	BRB	20$			; 
12$:	BRW	DELPHD			; FINISH DELETE FOR PROCESS
15$:	EXTZV	#PTE$V_PFN,#PTE$S_PFN,-4(FP),R0	; GET PFN FOR VALID ENTRY
	BEQL	11$			; DEMAND ZERO OR NULL PTE
	INSV	@W^PFN$AL_BAK[R0],#PTE$V_PGFLVB,#PTE$S_PGFLVB,-4(FP)	; SAVE BACKUP ADDR
		PFN_REFERENCE	-
	MOVW	<@W^PFN$Ax_WSLX[R0],(AP)+>,-	; AND WORKING SET LIST INDEX
		LONG_OPCODE=CVTLW,-
		IMAGE=SYS_NONPAGED
	BISL3	R0,R10,(R9)+		; SET INTO SWAPPER MAP
	BBSS	#PTE$V_VALID,-4(FP),20$	; MARK PAGE VALID FOR INSWAP PURPOSES
20$:	SOBGTR	R7,10$			; SCAN ENTIRE BALANCE SLOT
	SUBL	R11,R9			; COMPUTE NUMBER OF PAGES * 4
	MOVL	PCB$L_WSSWP(R4),R2	; WORKING SET SWAP SLOT
	MOVL	R4,W^OSWPPCB		; SAVE PCB ADDRESS FOR SLOT OWNER
	ROTL	#<32-2>,R9,R4		; DIVIDE COUNT BY 4
	MOVW	R4,W^OSWPPGS		; SAVE COUNT OF OUTSWAP PAGES
	MOVL	R11,R3			; SET SVA OF MAP FOR I/O
	INCL	W^SWP$GL_HOSWPCNT	; ACCOUNT FOR HEADER OUTSWAP
	BSBW	SWPWRITE		; WRITE ACTIVE PAGE TABLES
	BLBS	R0,30$			; CONTINUE IF NO ERROR
	BUG_CHECK APTWRTERR,FATAL	; **** ACTIVE PAGE TABLE SWAP I/O ERROR
30$:	BSBW	RELINIT			; INIT REGISTERS FOR RELEASE LOOP
	MOVL	PCB$L_PHD(R4),R8	; RESTORE BALANCE SLOT INDEX
40$:	BICL3	R10,(R9)+,R0		; ISOLATE PAGE FRAME NUMBER
	MOVL	@W^PFN$AL_PTE[R0],R6	; GET PTE ADDRESS
	MOVL	R0,(R6)			; MAKE PTE CORRECT BUT INVALID
	DECW	@W^PFN$AW_REFCNT[R0]	; DROP REFERENCE COUNT 
	BEQL	50$			; MUST BE ZERO
	BUG_CHECK APTREFHIGH,FATAL	; INCONSISTENT PAGE TABLE REFERENCE COUNT
50$:	MOVL	R6,R3			; SVAPTE FOR DELCON
	BSBW	RELDELPAGE		; RELEASE PAGE THROUGH DELCONPFN
	CLRL	(R6)			; SET NO ACCESS ON PFN
	SOBGTR	R7,40$			; CONTINUE FOR ALL ACTIVE PAGE TABLES
	MNEGW	#1,@W^PHV$GL_REFCBAS[R8]	; MARK BALANCE SLOT AVAIL
	CLRW	@W^PHV$GL_PIXBAS[R8]	; AND SET PIX TO NULL
	CLRL	PCB$L_PHD(R4)		; AND SEVER CONNECTION WITH PROCESS

OSWPEXIT:				; OUTSWAP COMPLETE
	BRW	SWAPRETRY		; RETRY SWAP SCHEDULE AFTER OUTSWAP
	.PAGE

	.SBTTL	DELPHD - DELETE PROCESS HEADER FOR DELETED PROCESS

;
; FUNCTIONAL DESCRIPTION:
;	DELPHD IS ENTERED BY RELPHD IF THE PROCESS INDEX ASSOCIATED WITH
;	THE BALANCE SLOT IS NEGATIVE INDICATING THE PROCESS HAS BEEN DELETED.
;	NOW THAT THE REFERENCE COUNT FOR THE HEADER IS ZERO, ALL PAGES AND
;	BACKING STORE PAGES CAN BE RELEASED PERMITTING RELEASE OF THE BALANCE
;	SLOT.  AT THIS POINT THE SPT ENTRIES ARE VALID WITH A PFN, DEMAND ZERO,
;	OR BACKING STORE ADDRESS FORM.  THERE ARE NO REMAINING TRANSITION PAGES.
;
; INPUT PARAMETERS:
;	R1 - PRODUCT OF SGN$C_BSLOTSZ * BALANCE_SLOT_INDEX
;	R6 - ADDRESS OF FIRST SPT ENTRY FOR THIS BALANCE SLOT
;	R7 - SGN$C_BSLOTSZ
;	R8 - BALANCE_SLOT_INDEX
;	R10- MASK OF PTE$M_VALID!PTE$M_MODIFY!PTE$C_ERKW
;

DELPHD:					;
	ROTL	#9,R1,R5		; COMPUTE OFFSET TO PHD FROM BASE
	ADDL	W^SWP$GL_BALBASE,R5	; FORM PHD ADDRESS
	MOVZBL	PHD$B_PAGFIL(R5),R11	; GET PAGING FILE NUMBER
10$:	MOVL	(R6)+,R0		; GET PTE FROM SPT
	BEQL	40$			; BR IF EMPTY
	BLSS	20$			; BR IF VALID
	BBS	#PTE$V_TYP1,R0,25$	; BR IF TYPE 1 (BACKING STORE)
20$:	BICL	R10,R0			; ISOLATE PFN
	BEQL	30$			; SKIP DEMAND ZERO PTE
	MOVL	@W^PFN$AL_BAK[R0],R9	; GET BACKUP ADDRESS
	BICB	#<<PTE$M_VALID!PTE$M_MODIFY>@-24>,-1(R6) ; CLEAR VALID AND MODIFY
	BSBW	RELDELPAGE		; RELEASE PAGE
	MOVL	R9,R0			; GET BACKUP ADDRESS
25$:	EXTZV	#PTE$V_PGFLVB,#PTE$S_PGFLVB,R0,R0	; GET PAG FIL VB
	BEQL	30$			; BR IF NONE
	MOVL	R11,R3			; SET PAGING FILE NUMBER FOR RELEASE
	BSBW	MMG$DALCPAGFIL		; DEALLOCATE PAGING FILE PAGE
30$:	CLRL	-4(R6)			; ZAP SPT ENTRY
40$:	SOBGTR	R7,10$			; RELEASE ENTIRE HEADER
	INVALID				; INVALIDATE HEADER
	MNEGW	#1,@W^PHV$GL_REFCBAS[R8]	; MARK SLOT EMPTY
	CLRW	@W^PHV$GL_PIXBAS[R8]	; POINT OWNER PIX AT NULL PROCESS
	DECW	W^SCH$GW_DELPHDCT	; ACCOUNT FOR DELETED HEADER
	BRW	SWAPRETRY		; AND RETRY SWAP ATTEMPT
	.PAGE

	.SBTTL	GBLTRANS/GBLVALID/GBLWRTVALID - HANDLE GLOBAL PAGES

;
;	GBLTRANS HANDLES THE CASE OF A GLOBAL PAGE IN TRANSITION,
;	WHICH IMPLIES THAT THE PAGE HAS BEEN FAULTED BUT IS NOT YET
;	RESIDENT.  THE WORKING SET LIST ENTRY FOR THIS PAGE WILL BE
;	DELETED AND THE PAGE WILL HAVE TO BE FAULTED AGAIN.
;

GBLTRANS:				; TRANSITION GLOBAL PAGE
GBLWRTTRANS:				; TRANSITION WRITABLE GLOBAL PAGE
	INSV	@W^MMG$GL_GPTBASE[R0],#PTE$V_PFN,#PTE$S_PFN,R0	; GET GLOBAL PFN FROM MASTER

	.ENABL	LSB
GBLDROP:				; DROP GLOBAL PAGE FROM WORKING SET
	MOVL	R7,R1			; GET WSL INDEX FOR RELEASE
	PUSHL	R3			; SAVE SVAPTE FOR FOLLOWING DECPTREF
	BSBW	MMG$DELWSLEX		; DELETE WSL GIVEN INDEX
	POPR	#^M<R3>			; RESTORE SVAPTE
	BSBW	MMG$DECPTREF		; AND DROP PAGE TABLE REFERENCE
	DECSHR	GTR=10$,-		; DECREASE SHARE COUNT
		IMAGE_FLAG=SYS_NONPAGED		
PROCDROP:
	DECREF	GTR=20$			; AND REF COUNT IF LAST SHARER
	BSBW	MMG$RELPFN		; RELEASE PAGE IF LAST REFERENCE
10$:					;
	RSB				; RETURN FOR NEXT PAGE
20$:	CMPZV	#PFN$V_LOC,#PFN$S_LOC,@W^PFN$AB_STATE[R0],- ;
		#PFN$C_ACTIVE		; CHECK FOR ACTIVE STATE
	BNEQ	30$			; NO, THEN LEAVE STATE UNCHANGED
	INSV	#PFN$C_RELPEND,-	; SET STATE TO RELEASE PENDING IF
		#PFN$V_LOC,#PFN$S_LOC,@W^PFN$AB_STATE[R0] ; I/O OUTSTANDING
30$:	RSB				;
	.DSABL	LSB

;
;	GBLVALID HANDLES A VALID, NON-WRITABLE, PAGE.
;
GBLVALID:				; VALID GLOBAL PAGE
;
;	IF THE GLOBAL PAGE IS BEING ACTIVELY SHARED THEN IT WILL BE DROPPED
;	FROM THE WORKING SET AND REFAULTED LATER (PRESUMABLY WITHOUT I/O).
;
	BBS	#WSL$V_WSLOCK,(FP),10$	; DON'T DROP PAGES LOCKED IN WORKING SET
		PFN_REFERENCE	-
	CMPW	<#1,@W^PFN$Ax_SHRCNT[R0]>,-	; IS THERE ACTIVE SHARING OF THIS PAGE?
		LONG_OPCODE=CMPL,-
		IMAGE=SYS_NONPAGED
	BNEQ	GBLWRTVALID		; YES, DROP IT AND REFAULT LATER
;
;	OTHERWISE THE PAGE WILL BE WRITTEN TO THE SWAP IMAGE SINCE IT IS
;	UNLIKELY TO BE RESIDENT UPON INSWAP.
;
10$:	BISL3	R0,R10,(R9)+		; SET IN SWAPPER MAP FOR OUT SWAP
	BSBW	MMG$DECPTREF		; DROP PAGE TABLE REFERENCE FOR PAGE
GBLRESET:				; RESET SLAVE PTE TO GPTX FORMAT
	SUBL3	W^MMG$GL_GPTBASE,@W^PFN$AL_PTE[R0],R1	; GET GPTX FOR PAGE
	ROTL	#<32-2>,R1,R1		; AND CONVERT TO CORRECT SCALE
	ASSUME	PTE$V_TYP0 EQ PTE$S_GPTX
	BBSS	#PTE$V_TYP0,R1,10$	; MARK AS GLOBAL
10$:	BICL3	#<PTE$M_VALID ! -	; OBTAIN PERMANENT BITS FOR PTE
		  PTE$M_TYP0  ! -	; BY CLEARING ALL OTHERS
		  PTE$M_TYP1  ! -	;
		  PTE$M_PFN>,(R3),R2	; TO FORM TRANSITION GLOBAL PTE
	BISL3	R1,R2,(R3)		; MUST SET ENTIRE PTE AT ONE TIME
					; SO THAT I/O CAN SEE CONSISTENT PTE
	RSB				; RETURN FOR NEXT PAGE

;
;	GBLWRTVALID HANDLES THE CASE OF A WRITABLE GLOBAL PAGE.
;	SUCH PAGES ARE DROPPED FROM THE WORKING SET BEFORE OUTSWAPPING
;	AND MUST BE SUBSEQUENTLY RE-FAULTED.
;
GBLWRTVALID:				; VALID WRITABLE GLOBAL PAGE
	BBCC	#PTE$V_MODIFY,(R3),10$	; TEST AND CLEAR MODIFY BIT IN SLAVE PTE
	BISB	#PFN$M_MODIFY,@W^PFN$AB_STATE[R0] ; AND SAVE MODIFY STATE
10$:	BSBB	GBLRESET		; RESET PTE
	BRB	GBLDROP			; DELETE WORKING SET LIST ENTRY
	.PAGE

	.SBTTL	PROCTRANS - PROCESS PAGE IN TRANSITION

;
;	THIS PAGE IS IN TRANSITION DUE TO THE FACT THAT THE PAGE FAULT
;	READ OPERATION HAS NOT YET COMPLETED.  IT IS TREATED AS AN
;	I/O IN PROGRESS PAGE.
;

PROCTRANS:				; PROCESS PAGE IN TRANSITION
	CMPZV	#PFN$V_LOC,#PFN$S_LOC,-	; IF THIS PAGE COULD NOT
		@W^PFN$AB_STATE[R0],#PFN$C_RDERR ; BE SUCCESSFULLY READ
	BNEQ	PROCVALID		;
	MOVL	R7,R1			; DROP IT FROM THE WORKING SET
	BSBW	MMG$DELWSLEX		; DELETE THE WSL ENTRY GIVEN WSL INDEX
	BRB	PROCDROP		; AND RELEASE THE PFN IF LAST REF

;
;	PROCVALID HANDLES THE CASE OF A VALID PROCESS PAGE WHICH INCURS
;	SOME SPECIAL PROCESSING IF THERE IS I/O IN PROGRESS.  AN I/O IN 
;	PROGRESS PAGE IS SWAPPED WITH THE BODY OF THE PROCESS TO RESERVE
;	SPACE FOR IT IN THE SWAP IMAGE AND IS LATER WRITTEN WITH CORRECT 
;	CONTENT BY THE MODIFIED PAGE WRITER TO THIS RESERVED SPACE IN THE
;	SWAP IMAGE.
;
PROCVALID:				; PROCESS VALID PAGE
	.ENABL	LSB
10$:					;
	BBSC	#PFN$V_MODIFY,@W^PFN$AB_STATE[R0],20$	; BR IF PAGE MODIFIED
	BBC	#PTE$V_MODIFY,(R3),30$	; BR IF PAGE NOT MODIFIED
20$:	BBSS	#WSL$V_MODIFY,(FP),30$	; SET WORKING SET MODIFIED BIT
30$:					;
	CMPW	#1,@W^PFN$AW_REFCNT[R0]	; CHECK FOR I/O OUTSTANDING
	BEQL	40$			; NO, NONE
	BLBC	R2,SETWRTBAK		; BRANCH IF TRANSITION PAGE
	BBC	#WSL$V_MODIFY,(FP),40$	; DONT WRITE UNMODIFIED PAGES
SETWRTBAK:				; SET PAGE FOR WRITE BACK TO SWAP FILE
	SUBL3	R11,R9,R1		; GET OFFSET TO PAGE IN SWAP MAP
	DIVL	#4,R1			; SCALE BACK TO PAGE NUMBER
	MOVW	R1,@W^PFN$AW_SWPVBN[R0]	; SET OFFSET INTO SWAP IMAGE LESS APTCNT
40$:					;
	BISL3	R0,R10,(R9)+		; PUT PAGE IN SWAPPER MAP
;
;	SET DELETE CONTENT FLAG TO CAUSE PAGE TO BE PLACED AT HEAD
;	OF FREE PAGE LIST AND CONTENT FORGOTTEN.
;
DELCON:	BISB	#PFN$M_DELCON,@W^PFN$AB_STATE[R0] ; SET TO DELETE CONTENT
	RSB				; RETURN FOR NEXT PAGE
	.DSABL	LSB			;

WSLERR:	BUG_CHECK IVWSETLIST,FATAL	; INVALID WORKING SET LIST ENTRY
	.PAGE

	.SBTTL	PAGE TABLE WORKING SET LIST ENTRIES

;
;	PAGE TABLE AND PROCESS HEADER ENTRIES IN THE WORKING SET LIST
;	ARE IGNORED DURING THE PROCESS BODY OUTSWAP SCAN OF THE WORKING
;	SET LIST.
;

PPGTBLTRANS:				; TRANSITION PAGE TABLE
PPGTBLVALID:				; VALID PAGE TABLE
	INCW	PCB$W_APTCNT(R4)	; ACCUMULATE ACTIVE PAGE TABLE COUNT
	SUBL	R5,(FP)			; UNBIAS WSL VA FOR PAGE TABLE
	BBSS	#VA$V_SYSTEM,(FP),10$	; BUT FORCE SYSTEM BIT ON IN VA
10$:	RSB				; RETURN
	.PAGE

	.SBTTL	INSWAP

;------------------------------------------------------------------------------
;	PERFORM REQUESTED INSWAP
;
;	INPUTS:
;		R4 - PCB ADDRESS OF INSWAP CANDIDATE
;------------------------------------------------------------------------------

INSWAP:					; PERFORM INSWAP
	MOVL	PCB$L_PHD(R4),R5	; GET CURRENT PROCESS HEADER SLOT
	BEQL	10$			; NONE, MUST ALLOCATE ONE
	MOVZWL	PHD$W_PHVINDEX(R5),R8	; GET BALANCE SLOT INDEX
	BRB	40$			; AND CONTINUE
10$:	CLRL	R8			; INIT INDEX FOR BALANCE SLOT SEARCH
20$:	TSTW	@W^PHV$GL_REFCBAS[R8]	; CHECK FOR EMPTY
	BLSS	30$			; YES, GOT ONE
	AOBLSS	SGN$GL_BALSETCT,R8,20$	; TRY ALL BALANCE SET SLOTS
	ROTL	#31,#1,FP		; SET FLAG TO PERMIT OUTSWAPPING
					; OF PROCESSES
	BRW	OUTSWAP			; OUTSWAP IF NECESSARY TO GET SLOT
30$:	MOVW	PCB$L_PID(R4),@W^PHV$GL_PIXBAS[R8]	; SET PIX FOR BALANCE SET SLOT
	CLRW	@W^PHV$GL_REFCBAS[R8]	; AND BUMP REFERENCE COUNT
	MULL3	W^SWP$GL_BSLOTSZ,R8,R0	; COMPUTE BALANCE SLOT OFFSET
	ROTL	#9,R0,PCB$L_PHD(R4)	; MAKE BYTE OFFSET 
					; POSITIVE UNTIL I/O COMPLETE
40$:	CLRL	R9			; INITIALIZE SWAPPER MAP INDEX
50$:	BSBW	MMG$ALLOCPFN		; ALLOCATE A PAGE
	TSTL	R0			; MAKE SURE IT WAS ALLOCATED
	BGEQ	60$			; YES, CONTINUE
	BUG_CHECK INSNFREPAG,FATAL	; INSUFFICIENT FREE PAGES
60$:	INCW	@W^PFN$AW_REFCNT[R0]	; REFERENCE PAGE
	MOVB	#PFN$C_ACTIVE,@W^PFN$AB_STATE[R0]	; AND MARK IT ACTIVE
	BISL3	#<PTE$C_ERKW!PTE$M_VALID>,R0,@W^SWP$GL_MAP[R9] ; MARK VALID, WRITABLE
	AOBLSS	R10,R9,50$		; REPEAT FOR ALL REQUIRED PAGES
	CLRL	@W^SWP$GL_MAP[R9]	; PUT STOPPER IN LIST
;
;	ALL PAGES HAVE NOW BEEN ACQUIRED AND A BALANCE SET SLOT
;	ALLOCATED.  THE INSWAP I/O OPERATION CAN NOW BE PERFORMED.
;
	INCW	W^SWP$GW_BALCNT		; ADD ONE PROCESS TO BALANCE SET
	MOVL	R4,W^SWP$GL_INPCB	; SAVE POINTER TO IN SWAP PCB
	MOVL	R10,W^SWP$GL_ISPAGCNT	; SAVE COUNT OF ALLOCATED PAGES
	MOVW	R8,W^SWP$GW_IBALSETX	; AND BALANCE SET SLOT NUMBER
;--------------------------------------------------------------------
;
;	PERFORM INSWAP I/O OPERATION
;
;--------------------------------------------------------------------

	MOVL	PCB$L_WSSWP(R4),R2	; GET SWAP IMAGE DISK ADDRESS
	BLEQ	COPYSHELL		; BRANCH IF SHELL IN SWAP
	BBC	#PCB$V_PHDRES,PCB$L_STS(R4),70$	; SWAP EVERYTHING IF HEADER NON-RES
	MOVZWL	PCB$W_APTCNT(R4),R0	; GET ACTIVE PAGE TABLE COUNT
	ADDL	R0,R2			; ADD PAGE TABLE COUNT
70$:	MOVAL	@W^SWP$GL_MAP,R3	; SVA OF PAGE TABLE FOR I/O
	MOVL	R10,R4			; NUMBER OF PAGES TO READ
	ADDL2	R10,W^SWP$GL_ISWPPAGES	; UPDATE TOTAL PAGES INSWAPPED
	INCL	W^SWP$GL_ISWPCNT	; BUMP INSWAP COUNTER
	BSBW	SWPREAD			; PERFORM READ
	BLBS	R0,80$			; BRANCH IF NO ERROR IN READ
	BUG_CHECK	INSWAPERR,FATAL	; **** BUGCHECK ON I/O ERROR
80$:	BRW	SETUP			; SET UP PROCESS IN BALANCE SLOT

COPYSHELL:
	MOVAL	W^MMG$AL_SYSPCB,R4	; ADDRESS OF SYSTEM PCB
	MOVL	PCB$L_PHD(R4),R5	; ADDRESS OF SYSTEM PROCESS HEADER
	MOVL	W^SWP$GL_SHELIO,R6	; GET I/O PAGE COUNT FOR SHELL
	MOVAB	L^SWP$GL_SHELLBAS,R2	; GET ADDRESS OF SHELL
	BSBW	MMG$SVAPTECHK		; GET ADDRESS OF PAGE TABLE ENTRY
	PUSHR	#^M<R3,R6>		; SAVE SVAPTE AND PAGE COUNT FOR LATER
	CLRL	R8			; SET FLAG INDICATING NO I/O NEEDED
	MOVZWL	#256+3,R7		; SET FLAGS TO LOCK ONLY VALID OR
					; TRANSITION PAGES AND CREATE OTHERS
					; WITHOUT ZEROING THE PHYSICAL PAGE
	MOVB	#WSL$C_SYSTEM,R2	; SET PAGE TYPE IN LOW BITS
	BISB	S^#MMG$M_NOWAIT,W^MMG$GB_FREWFLGS ; PREVENT FREWLSE MWAIT
10$:	BSBW	MMG$IOLOCKPAG		; LOCK THE PAGE INTO SYSTEM WORKING SET
	BLBS	R0,20$			; BRANCH IF SUCCEEDED
	BUG_CHECK INSNFREPAG,FATAL	; INSUFFICIENT FREE PAGES
20$:	BISB	R0,R8			; SET FLAG (BIT 1) IF WE HAVE TO I/O IT
	MOVAB	512(R2),R2		; BUMP VA TO NEXT PAGE
	ADDL	#4,R3			; BUMP PTE TO NEXT ENTRY
	SOBGTR	R6,10$			; LOOP THROUGH THE PAGES
	POPR	#^M<R3,R4>		; RECOVER SVAPTE AND PAGE COUNT
	BBC	#1,R8,40$		; BRANCH IF ALL SHELL PAGES IN MEMORY
	BICB	S^#MMG$M_NOWAIT,W^MMG$GB_FREWFLGS ; ALLOW FREWLSE MWAIT
	CLRL	R2			; SHELL IS PAGE FILE 0 AND VBN 0
	BSBW	SWPREAD			; PERFORM SHELL READ
	BLBS	R0,30$			; BRANCH IF NO ERROR IN READ
	BUG_CHECK INSWAPERR,FATAL	; **** BUGCHECK ON I/O ERROR
30$:	BISB	S^#MMG$M_NOWAIT,W^MMG$GB_FREWFLGS ; PREVENT FREWLSE MWAIT
40$:	SETIPL	#IPL$_ASTDEL		; ALLOW RESCHEDULE AND PAGEFAULTS WHILE
					; COPYING SHELL BUT NOT COMPLETION ASTS
	MOVL	W^SWP$GL_SHELIO,R6	; GET I/O PAGE COUNT FOR SHELL
	MOVAB	L^SWP$GL_SHELLBAS,R7	; GET ADDRESS OF SHELL
	ASHL	#9,R6,R0		; GET BYTE COUNT
	CLRL	R1			; FORM DESTINATION VA
	MOVC3	R0,(R7),(R1)		; COPY THE SHELL TO LOCATION 0
	SETIPL	#IPL$_SYNCH		; BACK TO BLOCKING IPL
	BICB	S^#MMG$M_NOWAIT,W^MMG$GB_FREWFLGS ; ALLOW FREWLSE MWAIT
	MOVQ	R6,R1			; SET UP COUNT AND VA OF SHELL AGAIN
	BSBW	MMG$SVAPTECHK		; GET ADDRESS OF PAGE TABLE ENTRY
	BSBW	MMG$UNLOCK		; DROP THE REFERENCE COUNTS
					; CONTINUE PROCESS CREATION
	.PAGE


;--------------------------------------------------------------------
;
;	SET UP PROCESS IN BALANCE SET SLOT
;
;--------------------------------------------------------------------

SETUP:					; SETUP INSWAP PROCESS
	BSBW	OSINIT			; INIT REGISTERS
	MOVL	W^SWP$GL_INPCB,R4	; GET PCB ADDRESS OF INSWAP PROCESS
	TSTL	PCB$L_PHD(R4)		; CHECK FOR NEWLY ALLOCATED PHD
	BLSS	10$			; BR IF NOT
	ADDL	W^SWP$GL_BALBASE,PCB$L_PHD(R4)	; AND SET ADDRESS IN PCB
10$:	TSTL	PCB$L_WSSWP(R4)		; CHECK FOR SHELL INSWAP
	BGTR	NOTSHELL		; BR IF NOT
	INVALID				; CLEAR TRANSLATION BUFFER
	JSB	@#SWP$SHELINIT		; CALL SHELL INITIALIZATION
					; WHICH RETURNS WITH A FULLY INITED PHD
NOTSHELL:				;
	MOVZWL	W^SWP$GW_IBALSETX,R8	; AND BALANCE SET INDEX
	MULL3	W^SWP$GL_BSLOTSZ,R8,R7	; COMPUTE OFFSET TO THIS SLOT
	MOVAL	@W^SWP$GL_BALSPT[R7],R7	; FORM BASE ADDRESS OF MAP FOR SLOT
	MOVL	R7,R3			; NOW POINT TO PROCESS HEADER
	BBSS	#PCB$V_PHDRES,PCB$L_STS(R4),5$	; SKIP IF PROCESS HEADER STILL RESIDENT
	INCL	W^SWP$GL_HISWPCNT	; COUNT SWAPS INCLUDING HEADER
	BSBW	FILLPHD			; SET INTO SPT ENTRIES
;
;	FILLPHD RETURNS WITH R5 POINTING TO THE PROCESS HEADER POSITION
;	WITHIN ITS P0 SPACE.
;
	MOVW	R8,PHD$W_PHVINDEX(R5)	; SET BALANCE SLOT INDEX
	ADDL	PCB$L_PHD(R4),PHD$L_P0BR(R5)	; RELOCATE P0 BASE REGISTER
	ADDL	PCB$L_PHD(R4),PHD$L_P1BR(R5)	; RELOCATE P1 BASE REGISTER
	BBSS	#PHD$V_NOACCVIO,PHD$W_FLAGS(R5),5$ ; INDICATE PHD INSWAP TO PAGER
5$:	EXTZV	#0,#PTE$S_PFN,(R7),R0	; GET PHYSICAL ADDRESS OF PCB
	ROTL	#9,R0,R0		; AND SET IN SOFTWARE PCB
	MOVAB	PHD$L_PCB(R0),PCB$L_PHYPCB(R4)	; ADD OFFSET TO HW PCB
;
;	NOW SET PAGES FROM WORKING SET LIST INTO PAGE TABLE ENTRIES
;
	MOVL	PCB$L_PHD(R4),R5	; GET PROCESS HEADER ADDRESS
	INVALID				; CLEAR TRANSLATION BUFFER TO SEE IT
;
;	A WINDOW IN P1 SPACE IS DOUBLE MAPPED TO ALL OF THE PROCESS
;	HEADER EXCEPT FOR THE PAGE TABLES. THIS PERMITS REFERENCE TO 
;	MOST OF THE PROCESS HEADER WHILE RUNNING AT IPL LESS THAN THE
;	SCHEDULER.  TO REFERENCE THE PROCESS HEADER IN SYSTEM SPACE
;	A PROCESS(OTHER THAN THE SWAPPER) MUST RAISE TO IPL$_SYNCH.
;

	MOVL	SWP$GL_PHDBASVA,R2	; VIRTUAL ADDRESS OF PHD WINDOW
	BSBW	MMG$SVAPTECHK		; GET POINTER TO WINDOW PTE
	MOVL	W^SGN$GL_PHDPAGCT,R2	; SET COUNT OF PAGES FOR WINDOW
	MOVL	#<PTE$C_URKW!PTE$M_VALID>,R1	; SKELETON PTE
10$:	MOVL	(R7)+,R0		; GET SWAPPER PTE FOR PHD
	BLSS	20$			; BR IF VALID PAGE
	CLRL	(R3)+			; NO, SET NO ACCESS
	BRB	30$			;
20$:	INSV	R0,#PTE$V_PFN,#PTE$S_PFN,R1	; AND INSERT PFN INTO WINDOW PTE
	MOVL	R1,(R3)+		; STORE IN WINDOW AND ADVANCE TO NEX PTE
30$:	SOBGTR	R2,10$			; MAP ENTIRE PHD WINDOW
;
;	THE REMAINING LIST OF PAGES READ BY THE SWAPPER ARE NOW PROCESSED
;	ACCORDING TO THE CONTENT OF THE WORKING SET LIST IN THE HEADER OF
;	THE INSWAP PROCESS.  THE DISPOSITION OF EACH INSWAP PAGE DEPENDS
;	ON ITS TYPE AND WHETHER THE PAGE IS ALREADY PRESENT IN WHICH CASE
;	THE NEW, REDUNDANT COPY IS DISCARDED.  SHARED PAGES READ FROM THE
;	SWAP IMAGE WHICH ARE NOT ALREADY RESIDENT BECOME THE MASTER COPY
;	AS WELL AS SATISFYING THE REQUIREMENT OF THE INSWAP PROCESS.
;
	ROTL	#PTE$V_VALID,#1,R11	; FORM VALID MASK
	MOVZWL	PHD$W_WSLIST(R5),R6	; INDEX TO START OF PERM ENTRIES
	MOVZWL	PHD$W_WSLAST(R5),R7	; POINTER TO LAST WS ENTRY
	.ENABL	LSB			;
WSLOOP:	MOVL	(R5)[R6],R2		; GET A WORKING SET ENTRY
	BSBB	10$			; AND PROCESS IT
	AOBLEQ	R7,R6,WSLOOP		; SCAN ENTIRE WORKING SET LIST
5$:	BICL3	R10,(R9)+,R0		; GET AND RELEASE EXCESS PAGES
	BEQL	7$			; BR IF NO MORE
	BSBW	RELPAGE			; RELEASE AN EXCESS PAGE
	BRB	5$			; AND TRY FOR ANOTHER
7$:	BRW	SETASTLVL		; END OF WORKING SET LIST
	ASSUME	WSL$V_VALID EQ 0	; FOR USE OF BLBS
10$:	BLBS	R2,20$			; CHECK FOR VALIDITY, BR IF VALID
15$:	RSB				; GET NEXT WSL ENTRY IF NOT VALID
17$:	ADDL	R5,R2			; REBIAS VA FOR WSL ENTRY
	BISL3	R11,R2,(R5)[R6]		; AND SET SYSTEM BIT IN VA
18$:	RSB				; NEXT WORKING SET LIST ENTRY
20$:					;
	BLSS	17$			; SKIP PAGE TABLE ENTRIES
	BSBW	MMG$SVAPTECHK		; GET SVA OF PTE FOR PAGE
;
;	R0 - ALL BITS EXCEPT PFN FIELD ARE CLEAR
;	R2 - WS LIST ENTRY
;	R3 - SVA OF PTE
;	R4 - INSWAP PROCESS PCB
;	R5 - PHD ADDRESS FOR INSWAP PROCESS
;	R6 - WORKING SET INDEX
;	R7 - END INDEX TO WORKING SET
;	R8 - BALANCE SET SLOT INDEX
;	R9 - ADDRESS OF PHYSICAL PAGE POINTER IN SWP$AL_MAP
;	R10 - PTE$C_ERKW!PTE$M_VALID!PTE$M_MODIFY
;	R11 - CONSTANT PFN$M_VALID
;
	BICL3	R10,(R9)+,R0		; GET PFN FROM MAP
	BNEQ	30$			; GOT A GOOD PFN
	BUG_CHECK ZEROPAGE,FATAL	; ZERO PAGE TABLE ENTRY FROM SWAP MAP
30$:	MOVL	(R3),AP			; GET CONTENT OF PTE
	BGEQ	35$			; PTE VALID => PFN LOCK, NOT SWAPPED
;
; IF THE PAGE IS VALID, IT MUST HAVE BEEN LOCKED IN MEMORY AND WAS IGNORED AT
; OUTSWAP.  THE REDUNDANT PAGE ALLOCATED FOR THIS WORKING SET LIST ENTRY MUST
; BE RELEASED AFTER ALL WORKING SET LIST ENTRIES ARE PROCESSED.  NO OTHER 
; ACTION IS NEEDED SINCE THE PTE FOR THE LOCKED PAGE IS ALREADY CORRECT.
; THE PFN THAT WOULD HAVE MATCHED THIS ENTRY REALLY BELONGS TO THE NEXT
; WSL WITHOUT PFNLOCK SET, SO THE MAP POINTER IN R9 MUST BE BACKED UP FOR
; ANOTHER TRY.
;
	BBC	#WSL$V_PFNLOCK,R2,32$	; ERROR IF PAGE NOT LOCKED IN MEMORY
	TSTL	-(R9)			; BACK UP IN SWAPPER MAP
	RSB				; AND CONTINUE WITH NEXT WSL
32$:	BUG_CHECK	ICPAGELOC,FATAL	; INCONSISTENT PTE/WSL
35$:	BBC	#PTE$V_TYP1,AP,NTYP1	; BR IF NOT TYPE 1
	MOVL	R3,@W^PFN$AL_PTE[R0]	; NOTE LOCATION OF PTE
		PFN_REFERENCE	-
	MOVW	<R6,@W^PFN$Ax_WSLX[R0]>,-	; AND POSITION IN WORKING SET
		LONG_OPCODE=MOVZWL,-
		IMAGE=SYS_NONPAGED
	EXTZV	#PFN$V_BAK,#PFN$S_BAK,(R3),R1 ; GET BACKING ADR FROM PTE
	BBS	#PTE$V_TYP0,R1,40$	; BR IF SECTION ADDRESS
	INSV	PHD$B_PAGFIL(R5),#PFN$V_PGFLX,#PFN$S_PGFLX,R1
					; SET PAGING FILE NUMBER
40$:	MOVL	R1,@W^PFN$AL_BAK[R0]	; STORE BACKING ADDRESS
	MOVB	#PFN$C_ACTIVE,@W^PFN$AB_STATE[R0]; SET PAGE ACTIVE
RECONNECT:				; RECONNECT TO PAGE
	BICL3	#^C<PTE$M_PROT!PTE$M_OWN>,(R3),R1	; RETAIN PERMANENT BITS
	MOVAL	(R5)[R6],R2		; GET ADDRESS OF WORKING SET LIST ENTRY
	BBCC	#WSL$V_MODIFY,(R2),50$	; CHECK FOR MODIFIED AND CLEAR
	BISB	#PFN$M_MODIFY,@W^PFN$AB_STATE[R0] ; RECORD MODIFY STATE
50$:	BISL	R11,R1			; SET VALID BIT FOR PTE
	BISL3	R0,R1,(R3)		; MERGE BITS WITH PFN  AND STORE IN PGTBL
	EXTZV	#VA$V_VPN,#VA$S_VPN,R3,R1	; GET VPN OF PAGE TABLE
	INSV	@W^MMG$GL_SPTBASE[R1],#0,#PTE$S_PFN,R0	; GET PT PFN
					; ASSUMES HIGH ORDER BITS OF R0 ARE CLEAR
		PFN_REFERENCE	-
	TSTW	<@W^PFN$Ax_SHRCNT[R0]>,-	; CHECK FOR FIRST ACTIVE PAGE
		LONG_OPCODE=TSTL,-
		IMAGE=SYS_NONPAGED
	BNEQ	60$			; NO, JUST RAISE SHARE COUNT FOR PT
		PFN_REFERENCE	-
	MOVZWL	<@W^PFN$Ax_WSLX[R0],R1>,-	; GET INDEX TO WSL ENTRY FOR PAGE TABLE
		LONG_OPCODE=MOVL,-
		IMAGE=SYS_NONPAGED
	BISL	#WSL$M_WSLOCK,(R5)[R1]	; AND MARK IT LOCKED IN WORKING SET
	INCW	PHD$W_PTCNTACT(R5)	; COUNT ANOTHER ACTIVE PAGE TABLE
	INCW	@W^PHV$GL_REFCBAS[R8]	; RAISE REFERENCE COUNT OF BALANCE SLOT
60$:					;
		PFN_REFERENCE	-
	INCW	<@W^PFN$Ax_SHRCNT[R0]>,-	; INDICATE ANOTHER ACTIVE PAGE FOR PT
		LONG_OPCODE=INCL,-
		IMAGE=SYS_NONPAGED
	RSB				; RETURN TO GET NEXT WSL ENTRY
	.DSABL	LSB			;
NTYP1:					; GLOBAL OR TRANSITION
	BBS	#PTE$V_TYP0,AP,11$	; BR IF GLOBAL PAGE
	EXTZV	#PTE$V_PFN,#PTE$S_PFN,AP,FP	; GET OLD PFN IF ANY
	BEQL	12$			; BR IF ZERO PAGE (BUG CHECK)
;
;	RELEASE PFN FOR PAGE ALREADY PRESENT
;
	BSBW	RELPAGE			; RELEASE DUPLICATE PAGE
	MOVL	FP,R0			; GET SAVED PFN
	EXTZV	#PFN$V_LOC,#PFN$S_LOC,@W^PFN$AB_STATE[R0],R2
	ASSUME	PFN$C_FREPAGLST EQ 0	;
	ASSUME	PFN$C_MFYPAGLST EQ 1	;
	ASSUME	PFN$C_BADPAGLST EQ 2	;
	ASSUME	PFN$C_RELPEND	EQ 3	;
	ASSUME	PFN$C_RDERR	EQ 4	;
	ASSUME	PFN$C_WRTINPROG	EQ 5	;
	ASSUME	PFN$C_RDINPROG	EQ 6	;
	ASSUME	PFN$C_ACTIVE	EQ 7	;
	CASE	R2,<-			; DISPATCH ON PAGE LOCATION
		20$,-			; 0 => FREE PAGE LIST
		20$,-			; 1 => MODIFIED PAGE LIST
		60$,-			; 2 => BAD PAGE LIST, PAGE READ/WRITE ERR
		30$,-			; 3 => RELEASE PENDING
		10$,-			; 4 => PAGE READ ERROR
		30$,-			; 5 => WRITE IN PROGRESS
		40$,-			; 6 => READ IN PROGRESS
		30$>			; 7 => ACTIVE ( I/O NOT YET COMPLETE

10$:	BUG_CHECK ICPAGELOC,FATAL	; INCONSISTENT PAGE LOCATION

11$:	BRW	GLOBAL			; GLOBAL PAGE
12$:	BUG_CHECK ZEROPAGE,FATAL	; ZERO PFN IN PTE

20$:	PUSHL	R3			; SAVE SVAPTE
	BSBW	MMG$REMPFN		; UNLINK PFN FROM FREE OR MODIFY LIST
	POPR	#^M<R3>			; RESTORE SVAPTE
	MOVAL	(R5)[R6],R2		; COMPUTE ADDRESS OF WSL ENTRY
30$:	BISL	R11,(R3)		; SET VALID BIT FOR PTE
	ASSUME	PFN$V_LOC EQ 0		; TO USE BISB INSTEAD OF INSV
	BISB	#PFN$C_ACTIVE,@W^PFN$AB_STATE[R0]	;
40$:	BICB	#<PFN$M_DELCON!-	; CLEAR DELETE AND
		PFN$M_MODIFY>,-		; MODIFY
		@W^PFN$AB_STATE[R0]	; FLAGS
45$:	INCW	@W^PFN$AW_REFCNT[R0]	; RAISE REFERENCE COUNT
	CLRW	@W^PFN$AW_SWPVBN[R0]	; INDICATE NO ALTERNATE LOCATION
	MOVAL	(R5)[R6],R2		; COMPUTE ADDRESS OF WSL ENTRY
	BBCC	#WSL$V_MODIFY,(R2),50$	; CLEAR MODIFY BIT FOR WSL
	BISB	#PFN$M_MODIFY,@W^PFN$AB_STATE[R0] ; RECORD PAGE AS MODIFIED
50$:		PFN_REFERENCE	-
	MOVW	<R6,@W^PFN$Ax_WSLX[R0]>,-	; SET WORKING SET LIST INDEX FOR PAGE
		LONG_OPCODE=MOVZWL,-
		IMAGE=SYS_NONPAGED
	RSB				; AND RETURN FOR NEXT PAGE
;
; PAGE IS ON THE BAD PAGE LIST.  IT HAS THE FOLLOWING POSSIBLE STATES
;	1) BADPAG BIT SET IN PFN$AB_TYPE => BUG_CHECK
;	2) SWPVBN CLEAR => PAGE WRITE ERROR, CORRECT COPY OF MODIFY BIT
;	   IS THE LOGICAL OR OF THE WSLE BIT AND THE PFN BIT
;	3) SWPVBN SET => PAGE READ ERROR, SET RDERR STATE.
;
60$:	BBS	#PFN$V_BADPAG,@W^PFN$AB_TYPE[R0],10$ ; ERROR IF BADPAG
	PUSHL	R3			; SAVE PTE ADDRESS
	BSBW	MMG$REMPFN		; UNLINK PFN FROM THE BAD PAGE LIST
	POPR	#^M<R3>			; RESTORE PTE ADDRESS
	MOVAL	(R5)[R6],R2		; COMPUTE ADDRESS OF WSL ENTRY
	TSTW	@W^PFN$AW_SWPVBN[R0]	; IF SWPVBN SET, THEN PAGE READ ERROR
	BNEQ	80$			; BRANCH IF PAGE READ ERROR
;
; PAGE WRITE ERROR
;
	ASSUME	PFN$V_MODIFY EQ 7
	TSTB	@W^PFN$AB_STATE[R0]	; IF PFN MODIFY BIT IS SET
	BGEQ	30$			;
	BBSS	#WSL$V_MODIFY,(R2),30$	; THEN JAM THE WSL ENTRY MODIFY BIT
	BRB	30$			; AND CONNECT TO THE PAGE
;
; PAGE READ ERROR
;
80$:	MOVB	#<PFN$M_DELCON ! PFN$C_RDERR>,- ; SET DELCON
		@W^PFN$AB_STATE[R0]	; AND PAGE READ ERROR STATE
	BICW	#<WSL$M_MODIFY>,(R2)	; CLEAN UP WSLE
	BRB	45$			; AND LEAVE PTE IN TRANSITION STATE
;
;	INSWAP GLOBAL PAGE
;
GLOBAL:					; GLOBAL PAGE INSWAP
	EXTZV	#PTE$V_GPTX,#PTE$S_GPTX,AP,R1	; GET GLOBAL PAGE TABLE INDEX
	MOVAL	@W^MMG$GL_GPTBASE[R1],R1	; AND CONVERT TO ADDRESS OF GPTE
	MOVL	(R1),R2			; PICK UP GLOBAL MASTER PTE
	BLSS	10$			; BR IF VALID
	BBS	#PTE$V_TYP0,R2,5$	; BR IF GLOBAL SECTION TYPE
	EXTZV	#PTE$V_PFN,#PTE$S_PFN,R2,R0	; GET PFN OF TRANSITION PAGE
	ASSUME	PFN$C_FREPAGLST EQ 0
	EXTZV	#PFN$V_LOC,#PFN$S_LOC,@W^PFN$AB_STATE[R0],R2	; TEST FOR FREE PAGE LIST
	BEQL	20$			; YES, REFAULT IT
	ASSUME PFN$C_RDINPROG EQ <PFN$C_RDERR + 2>
	CASE	R2, < -			; DISPATCH ON READ CASES:
		55$, -			;  READ ERROR
		4$,  -			;  WRONG STATE
		60$ >, -		;  READ IN PROGRESS
		LIMIT=#PFN$C_RDERR
4$:	BUG_CHECK	ICPAGELOC, FATAL	; WRONG STATE - CRASH SYSTEM
5$:	BRW	50$			; A BRANCH ASSIST

10$:					; INSWAP WITH VALID GLOBAL PAGE
	BSBW	RELPAGE			; RELEASE REDUNDANT PAGE
	EXTZV	#PTE$V_PFN,#PTE$S_PFN,R2,R0	; GET PFN FROM MASTER
	BRB	40$			; AND GO SETUP SLAVE PTE
20$:					; GLOBAL ON FREE LIST
	PUSHL	R0			; SAVE MASTER PFN
	BICL3	R10,-4(R9),R0		; GET REDUNDANT PFN
	BSBW	RELPAGE			; AND RELEASE IT (PRESERVING R1-R3)
	POPR	#^M<R0>			; RESTORE MASTER PFN
	BISL	R11,(R1)		; SET PAGE VALID
	PUSHR	#^M<R1,R3>		; SAVE SVAGPTE, SVAPTE
	BSBW	MMG$REMPFN		; REMOVE PFN FROM FREELIST
	POPR	#^M<R1,R3>		; RESTORE SVAGPTE, SVAPTE
	INSV	#PFN$C_ACTIVE,#PFN$V_LOC,#PFN$S_LOC,@W^PFN$AB_STATE[R0]	;
	INCW	@W^PFN$AW_REFCNT[R0]	; RAISE REFERENCE COUNT
	BRB	40$			;
30$:	EXTZV	#VA$V_VPN,#VA$S_VPN,R1,R1	; GET VPN OF PAGE TABLE
	MOVL	@W^MMG$GL_SPTBASE[R1],R1	; GET PAGE TABLE PTE
	EXTZV	#PTE$V_PFN,#PTE$S_PFN,R1,R1	; EXTRACT PFN 
		PFN_REFERENCE	-
	TSTW	<@W^PFN$Ax_SHRCNT[R1]>,-	; CHECK FOR FIRST REFERENCE TO PTABLE
		LONG_OPCODE=TSTL,-
		IMAGE=SYS_NONPAGED
	BNEQ	35$			; NO
	BUG_CHECK GBLPAGSZRO,FATAL	; GLOBAL PAGE SHARE COUNT ZERO
35$:		PFN_REFERENCE	-
	INCW	<@W^PFN$Ax_SHRCNT[R1]>,-	; RAISE GLOBAL PAGE TABLE SHARE COUNT
		LONG_OPCODE=INCL,-
		IMAGE=SYS_NONPAGED
40$:		PFN_REFERENCE	-
	INCW	<@W^PFN$Ax_SHRCNT[R0]>,-	; RAISE SHARE COUNT FOR GLOBAL PAGE
		LONG_OPCODE=INCL,-
		IMAGE=SYS_NONPAGED
	BRW	RECONNECT		; RECONNECT AND REFERENCE PAGE TABLE
50$:	EXTZV	#PFN$V_BAK,#PFN$S_BAK,R2,@W^PFN$AL_BAK[R0] ; SAVE BACKING ADDR
	BICL	#^C<PTE$M_PROT!PTE$M_OWN>,R2	; SAVE PROTECTION AND OWNER FIELDS
	BISL	R11,R2			; SET PTE VALID
	BISL3	R0,R2,(R1)		; AND STORE WITH PFN IN GPT
	MOVL	R1,@W^PFN$AL_PTE[R0]	; SET SVAGPTE IN PFN DATA BASE
	MOVB	#PFN$C_ACTIVE,@W^PFN$AB_STATE[R0] ; SET STATE TO ACTIVE
	MOVB	#PFN$C_GLOBAL,@W^PFN$AB_TYPE[R0]  ; AND TYPE TO GLOBAL
	BRB	30$			; NOW GO SETUP SLAVE PTE

55$:	; PAGE READ ERROR IN GPTE
	;  THE PFN IN THE GPTE WILL BE DEALLOCATED
	;  THE GPTE WILL BE ALTERED TO USE THE PFN FROM THE INSWAP IMAGE
	;  THE DATA BASE WILL BE ADJUSTED AS APPROPRIATE

	BICL3	R10, -4(R9), R2				; GET SWAP IMAGE PFN.
	MOVL	@W^PFN$AL_BAK[R0], @W^PFN$AL_BAK[R2]	; COPY BACKING STORE.
	MOVB	#PFN$C_ACTIVE, @W^PFN$AB_STATE[R2]	; SET STATE TO ACTIVE.
	MOVB	#PFN$C_GLOBAL, @W^PFN$AB_TYPE[R2]	; SET TYPE TO GLOBAL.
	PFN_REFERENCE -					; COPY SHARE COUNT.
	MOVW	< @W^PFN$Ax_SHRCNT[R0], @W^PFN$Ax_SHRCNT[R2] >, -
		LONG_OPCODE = MOVL, -
		IMAGE=SYS_NONPAGED
	CLRL	@W^PFN$AL_PTE[R0]			; SETUP FOR AND RELEASE
	BSBW	RELPAGE					; READ ERROR PFN.
							; NOBODY CAN USE IT.
	MOVL	R2, R0					; SETUP NEW MASTER PFN.
	INSV	R0, #PTE$V_PFN, #PTE$S_PFN, (R1)	; PLANT PFN IN GPTE.
	MOVL	R1, @W^PFN$AL_PTE[R0]			; PLANT PTE IN DATABASE.
	BISL	R11, (R1)				; MAKE PTE VALID.
	BRB	40$					; JOIN COMMON CODE.

60$:	BISB	#PFN$M_COLLISION,@W^PFN$AB_TYPE[R0]	; FLAG COLLISION FOR PAGEREAD
	PUSHR	#^M<R2,R3,R4,R5>	; SAVE REGS OVER WAIT
	MOVL	W^SCH$GL_CURPCB,R4	; AND SET PCB ADDRESS
	BSBW	SCH$NEWLVL		; SET ASTLVL CORRECTLY
	MOVAQ	W^SCH$GQ_COLPGWQ,R2	; GET ADDRESS OF WAIT QUEUE
	PUSHL	#0			; NULL KERNEL MODE PSL
	BSBW	SCH$WAITK		; WAIT WITH NO CALL FRAME
	SETIPL	#IPL$_SYNCH		; BLOCK SYSTEM EVENTS
	POPR	#^M<R2,R3,R4,R5>	; RESTORE REGS
	BICL3	R10,-4(R9),R0		; RESTORE CURRENT PFN
	BRW	GLOBAL			; AND ATTEMPT TO REASSOCIATE PAGE


;
;	SET PROPER AST LEVEL
;
SETASTLVL:				;
	MOVAL	PCB$L_ASTQFL(R4),R3	; GET POINTER TO HEAD OF AST QUEUE
	MOVL	(R3),R2			; GET POINTER TO FIRST AST CONTROL BLOCK
	CMPL	R3,R2			; IS LIST EMPTY?
	BEQL	20$			; YES, DONE
	CLRL	R0			; ASSUME KERNEL MODE
	MOVB	ACB$B_RMOD(R2),R3	; GET ACTUAL MODE
	BLSS	10$			; BR IF SPECIAL KERNEL AST
	EXTZV	#ACB$V_MODE,#ACB$S_MODE,R3,R0 ; GET ACCESS MODE
	BICB3	PCB$B_ASTACT(R4),PCB$B_ASTEN(R4),R1	; CHECK FOR DELIVERABILITY
	BBC	R0,R1,20$		; BR IF NOT PRESENTLY DELIVERABLE
10$:	MOVB	R0,PHD$B_ASTLVL(R5)	; SET AST LEVEL FOR PROCESS
20$:	BISL	#<<1@PCB$V_RES>!<1@PCB$V_INQUAN>>,PCB$L_STS(R4) ; MARK PROCESS RESIDENT
	MOVW	SCH$GW_QUAN,PHD$W_QUANT(R5)	; AND GIVE NEW QUANTUM
	MOVZBL	PCB$B_PRI(R4),R0	; GET CURRENT PRIORITY OF PROCESS
	SUBB3	R0,#31,R1		; COMPUTE EXTERNAL PRIORITY FOR COMPARE
	CMPB	R1,W^SYS$GB_DEFPRI	; IS THIS A "CRUNCHER"?
	BGTR	30$			; NO, CONTINUE
	MOVL	EXE$GQ_SYSTIME,R1	; GET CURRENT TIME IN APPROX. 10MS UNITS
	ADDL3	W^SCH$GL_SWPRATE,R1,W^SWP$GL_SWTIME ; SET NEW CRUNCHER INTERVAL
30$:	BSBW	SCH$CHSEP		; CHANGE TO RESIDENT COMPUTE
SWAPRETRY:				; RETRY SWAP SCHEDULING
	MOVL	W^SCH$GL_CURPCB,R4	; GET PCB ADDRESS
	BBSSI	#PCB$V_WAKEPEN,PCB$L_STS(R4),20$	; SET TO CANCEL HIBER
20$:
	.DSABL	LSB
SWAPEXIT:				; EXIT SWAPPER
	BBCC	S^#SCH$V_SIP,W^SCH$GB_SIP,10$	; CLEAR SWAP IN PROGRESS
10$:	
SWAPEXITA:				; ALTERNATE EXIT, LEAVING SIP SET
	POPR	#^M<R6,R7,R8,R9,R10,R11,AP,FP>	; RESTORE REGISTERS
	SETIPL	#0			; DROP IPL
	RSB				;
	.PAGE

	.SBTTL	FILLPHD - FILL SPT ENTRIES TO MAP PHD

;++
; FUNCTIONAL DESCRIPTION:
;	FILLPHD SETS THE PTE ENTRIES FOR THE PROCESS HEADER INTO THE
;	SPT.
;
; CALLING SEQUENCE:
;	BSB/JSB	FILLPHD
;
; INPUT PARAMETERS:
;	R3  -  POINTER TO FIRST SPT ENTRY FOR PHD
;	R9  -  ADDRESS OF SWAPPER MAP ENTRY TO BE MOVED TO SPT
;	R10 -  PTE$C_ERKW!PTE$M_VALID!PTE$M_MODIFY
;
; OUTPUT PARAMETERS:
;	R5 - ZERO
;	R6 - DESTROYED
;	R9 - UPDATED
;	R11 - DESTROYED
;	AP - DESTROYED
;	FP - DESTROYED
;--

FILLPHD:				;

	CLRL	R5			; SET PHD ADDRESS TO SWAPPER P0 SPACE
	INVALID				; TO SEE CORRECT PROCESS HEADER IN SWAPPER P0
	CLRL	R11			; INIT HEADER PAGE INDEX 
	MOVZWL	PHD$W_EMPTPG(R5),R6	; GET COUNT OF EMPTY PAGES
	ASHL	#9,R6,R6		; CONVERT TO BYTE OFFSET
	MOVL	PHD$L_WSLX(R5),AP	; FORM BASE ADDRESS FOR WSLX
	MOVAL	(R5)[AP],AP		; SAVE VECTOR FOR PHD
	MOVL	PHD$L_BAK(R5),FP	; FORM BASE ADDRESS FOR BACKING STORE ADDRESS
	MOVAL	(R5)[FP],FP		; VECTOR
	SUBL	R6,AP			; ACCOUNT FOR EMPTY PAGES
	SUBL	R6,FP			; BY SUBTRACTING THEIR SPACE
	MOVL	W^SWP$GL_BSLOTSZ,R6	; SET ITERATION COUNT FOR ENTIRE HEADER
10$:	MOVL	(FP)+,(R3)+		; SET BACKUP FORM OF PTE IN SPT SLOT
	BGEQ	30$			; DONE IF NOT VALID
	BICL3	R10,(R9)+,R0		; GET PAGE FROM SWAPPER MAP
	MOVAL	-(R3),@W^PFN$AL_PTE[R0]	; SET PTE BACK POINTER
	EXTZV	#PFN$V_BAK,#PFN$S_BAK,(R3),R1	; ISOLATE BACKING STORE ADDRESS
	INSV	PHD$B_PAGFIL(R5),#PFN$V_PGFLX,#PFN$S_PGFLX,R1	; ADD FILE NUMBER
	MOVL	R1,@W^PFN$AL_BAK[R0]	; SAVE IN PFN DATA BASE
		PFN_REFERENCE	-
	MOVW	<(AP)[R11],@W^PFN$Ax_WSLX[R0]>,-	; SAVE WORKING SET LIST INDEX
		LONG_OPCODE=MOVZWL,-
		IMAGE=SYS_NONPAGED
	BISL3	R0,R10,(R3)+		; SET VALID PTE FOR PAGE
	MOVB	#<PFN$C_ACTIVE!PFN$M_MODIFY>,@W^PFN$AB_STATE[R0] ; MARK PAGE ACTIVE
	MOVB	#PFN$C_PPGTBL,@W^PFN$AB_TYPE[R0]	; STORE TYPE IN PFN DATA BASE
30$:	AOBLSS	R6,R11,10$		; FILL ENTIRE PROCESS HEADER
	RSB
	.PAGE

	.SBTTL	RELINIT - INITIALIZE REGISTERS FOR PAGE RELEASE LOOP

;++
; FUNCTIONAL DESCRIPTION:
;	RELINIT SETS UP REGISTERS FOR THE PAGE RELEASE LOOPS FOLLOWING
;	OUTSWAP I/O OPERATIONS.
;
; CALLING SEQUENCE:
;	BSB/JSB	RELINIT
;
; INPUT PARAMETERS:
;	NONE
;
; OUTPUT PARAMETERS:
;	R0  -  0
;	R4  -  OUT SWAP PCB ADDRESS (OSWPPCB)
;	R7  -  PAGE COUNT TO RELEASE
;	R9  -  BASE ADDRESS FOR SWAPPER MAP (SWP$AL_MAP)
;	R10 -  PTE$C_ERKW!PTE$M_VALID!PTE$M_MODIFY
;	R11 -  BASE ADDRESS FOR SWAPPER MAP (SWP$AL_MAP)
;
;--

RELINIT:				; RELEASE LOOP INITIALIZATION
	MOVL	W^OSWPPCB,R4		; GET PCB ADDRESS OF OUT SWAP PROCESS
	MOVZWL	W^OSWPPGS,R7		; AND PAGE COUNT FOR RELEASE LOOP
;	BRB	OSINIT			; FALL INTO OSINIT
	.PAGE

	.SBTTL	OSINIT - OUTSWAP SCAN REGISTER INITIALIZATION

;++
; FUNCTIONAL DESCRIPTION:
;	OSINIT SETS UP REGISTERS FOR PAGE TABLE SCANS REQUIRED DURING
;	OUTSWAPPING.
;
; INPUT PARAMETERS:
;	NONE
;
; OUTPUT PARAMETERS:
;	R9 - BASE ADDRESS OF SWAPPER MAP (SWP$AL_MAP)
;	R10 - PTE$C_ERKW!PTE$M_VALID
;	R11 - BASE ADDRESS OF SWAPPER MAP (SWP$AL_MAP)
;
;--

OSINIT:					;
	MOVAL	@W^SWP$GL_MAP,R9		; SET BASE OF SWAPPER MAP
	MOVL	R9,R11			; AND MAKE REFERENCE COPY
	MOVL	#<PTE$C_ERKW!PTE$M_VALID!PTE$M_MODIFY>,R10 ; MASK TO VALIDATE SWAP PTE
	RSB				; RETURN
	.PAGE

	.SBTTL	RELPAGE - RELEASE DUPLICATE PAGE

;++
; FUNCTIONAL DESCRIPTION:
;	RELPAGE RELEASES A PHYSICAL PAGE WHICH DUPLICATES A PAGE ALREADY
;	PRESENT FOR THE PROCESS.  THIS SITUATION CAN ARISE DUE TO A PARTIAL
;	INSWAP OR A GLOBAL PAGE WHICH IS ALREADY PRESENT.
;
; CALLING SEQUENCE:
;	BSB/JSB	RELPAGE
;
; INPUT PARAMETERS:
;	R0 - PFN TO RELEASE
;	R3 - SVA OF PTE (RELDELPAGE ONLY)
;
; OUTPUT PARAMETERS:
;	R1 - PRESERVED (RELPAGE ONLY)
;	R2 - PRESERVED (RELPAGE ONLY)
;	R3 - PRESERVED (RELPAGE ONLY)
;
;--

RELDELPAGE:				; RELEASE PAGE THROUGH DELCONPFN
	BSBW	MMG$DELCONPFN		; DELETE PAGE CONTENT AND INIT PFN DATA
RELPAGE:				; RELEASE PAGE
	PUSHR	#^M<R1,R2,R3>		; PRESERVE REGISTERS
	CLRB	@W^PFN$AB_STATE[R0]	; INIT PFN DATA FOR RELEASE
	CLRW	@W^PFN$AW_REFCNT[R0]	; ZERO REFERENCE COUNT
	ASSUME	PFN$C_FREPAGLST EQ 0	;
	CLRL	R2			; INDICATE FREELIST
	BSBW	MMG$INSPFNH		; RELEASE PFN TO HEAD OF FREE LIST
	POPR	#^M<R1,R2,R3>		; RESTORE REGISTERS
	RSB				; AND RETURN TO CALLER
	.PAGE

	.SBTTL	SWPREAD/SWPWRITE - SWAPPER I/O ROUTINES

;++
; FUNCTIONAL DESCRIPTION:
;	SWPREAD AND SWPWRITE PERFORM THE DETAIL WORK REQUIRED TO READ
; 	OR WRITE A SET OF CONTIGUOUS PAGES IN A WORKING SET SWAP IMAGE.
;	THE CALL TO EITHER SWPREAD OR SWPWRITE IS ACTUALLY A CO-ROUTINE
;	CALL WHICH RETURNS ONLY AFTER ALL SEGMENTS OF THE I/O OPERATION
;	HAVE BEEN PERFORMED.  THIS RETURN IS EFFECTED BY A SPECIAL KERNEL
;	AST.
;
; CALLING SEQUENCE:
;	BSB/JSB	SWPREAD/SWPWRITE
;
; INPUT PARAMETERS:
;	R0 - SWAP FILE INDEX
;	R2 - WSSWP FORM DISK ADDRESS
;	R3 - SYSTEM VIRTUAL ADDRESS OF PTE
;	R4 - PAGE COUNT
;
;	00(SP) - RETURN ADDRESS AFTER I/O COMPLETION
;	04(SP) - SAVED R6
;	08(SP) - SAVED R7
;	12(SP) - SAVED R8
;	16(SP) - SAVED R9
;	20(SP) - SAVED R10
;	24(SP) - SAVED R11
;	28(SP) - SAVED AP
;	32(SP) - SAVED FP
;	36(SP) - SAVED IPL
;	40(SP) - RETURN TO PREVIOUS THREAD
;
; IMPLICIT INPUTS:
;	PAGE FILE TABLE ENTRY (PFL) SELECTED BY WSSWP INPUT
;
; OUTPUT PARAMETERS:
;	R0 - COMPLETION STATUS OF I/O OPERATION
;
;--

	.ENABL	LSB			
SWPREAD:				; SWAP READ INITIATION
	PUSHAB	W^EXE$BLDPKTSWPR	; SET ADDRESS OF BUILD PACKET ROUTINE
	BRB	10$			;
SWPWRITE:				; SWAP WRITE INITIATION
	PUSHAB	W^EXE$BLDPKTSWPW	; SET ADDRESS OF BUILD PACKET ROUTINE
10$:	MOVAB	W^IOROUTINE,R1		; ADDRESS OF I/O DATA
	MOVQ	(SP)+,(R1)+		; SAVE I/O END ACTION ADDRESS
	POPR	#^M<R6,R7,R8,R9,R10,R11,AP,FP>; RESTORE REGISTERS OTHER THAN STANDARD SET
15$:	EXTZV	#24,#8,R2,R0		; GET SWAP FILE INDEX
	MOVL	@W^MMG$GL_PAGSWPVC[R0],R0; GET BASE ADDRESS OF PAGE FILE TABLE
	MOVZBL	#127,R5			; SET I/O SIZE
	CMPL	R4,R5			; COMPARE REMAINING PGCNT WITH MAX TRANSFER
	BGTR	20$			; USE MAXIMUM TRANSFER
	MOVL	R4,R5			; SET TRANSFER TO REMAINING PAGES
20$:	ADDL3	R5,R2,(R1)+		; SAVE UPDATED DISK ADDRESS
	MOVAL	(R3)[R5],(R1)+		; AND UPDATED SAVPTE
	SETIPL	#0			; DROP IPL
	SUBW3	R5,R4,(R1)		; SAVE REMAINING PAGE COUNT
	PUSHL	R3			; SAVE SVAPTE
	PUSHL	PFL$L_WINDOW(R0)	; GET WINDOW ADDRESS 
	ROTL	#9,R5,-(SP)		; CONVERT PAGES TO BYTE COUNT
	EXTZV	#0,#24,R2,-(SP)		; AND ISOLATE BLOCK NUMBER
	ADDL	PFL$L_VBN(R0),(SP)	; ADD BASE VBN
	MOVL	W^SCH$GL_CURPCB,R4	; SET PCB ADDRESS
	REMQUE	@W^IOC$GL_IRPFL,R5	; GET A PACKET IF POSSIBLE
	BVC	30$			; BR IF ONE AVAILABLE
	BSBW	EXE$ALLOCIRP		; ALLOCATE ONE THE LONG WAY
	MOVL	R2,R5			; SET PACKET ADDRESS IN PROPER REGISTER
30$:	MOVAB	B^IODONE,IRP$L_ASTPRM(R5); SET ADDRESS FOR COMPLETION
	SUBB3	W^SWP$GB_PRIO,#31,IRP$B_PRI(R5)	; SET PRIORITY FOR TRANSFER
	POPR	#^M<R0,R1,R2,R3>	; RESTORE VBN,BYTECNT,WINDOW,SVAPTE
	JSB	@W^IOROUTINE		; CALL READ OR WRITE ROUTINE
	RSB				; AND RETURN TO ORIGINAL CALLER

IODONE:					; CONTINUATION CALLED AS KERNEL AST
	PUSHL	IRP$L_MEDIA(R5)		; SAVE COMPLETION STATUS
	MOVL	R5,R0			; SET PACKET ADDRESS FOR RELEASE
	BSBW	EXE$DEANONPAGED		; AND RELEASE IT
	MOVL	(SP)+,R0		; RESTORE STATUS
	SETIPL	#IPL$_SYNCH		; BLOCK SYSTEM EVENTS
	BLBC	R0,60$			; EXIT IF ERROR
	MOVAB	W^RWSSWP,R1		; GET ADDRESS OF REMAINING TRANSFER PARAMS
	MOVQ	(R1),R2			; RESTORE WSSWP,SVAPTE TO R2,R3
	MOVZWL	B^<RPGCNT-RWSSWP>(R1),R4	; AND REMAINING PAGE COUNT
	BEQL	60$			; DONE IF NO MORE PAGES REMAIN
	BRW	15$			; CONTINUE IF MORE PAGES REMAIN
60$:	PUSHR	#^M<R6,R7,R8,R9,R10,R11,AP,FP>; SAVE NON-STANDARD REGISTERS
	JMP	@W^IOEA			; AND CONTINUE SWAP

	.DSABL	LSB			;
	.END

