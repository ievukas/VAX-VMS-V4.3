	.TITLE	VMB730 - VMS Primary Bootstrap Routine for 11/730 only
	.IDENT	'V04-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
;++
;
; FACILITY:
;
;	Bootstrap module for VAX 11/730 hardware, Micro-VAX and full VAX
;	versions of the microcode
;
; ENVIRONMENT:
;
;	Runs at IPL 31, kernel mode, memory management is OFF, IS=1
;	(running on interrupt stack), and code must be PIC.
;
; ABSTRACT:
;
;	This module contains the primary bootstrap code. The main
;	routine -- START_BOOT -- gains control from CONSOLE, boot block
;	0 code, or from BOOT58. The code creates a System Control
;	Block (SCB), initializes XDELTA if requested, initializes the
;	Restart Parameter Block (RPB), creates a PFN bit map describing
;	all of physical memory, reads in a secondary bootstrap program,
;	and transfers control to that bootstrap.
;
; AUTHOR:
;
;	Kathleen D. Morse, Creation date:  15-Apr-1983
;
; MODIFIED BY:
;
;	V03-004	CWH3004		CW Hobbs		9-Sep-1983
;		Change the wording of the prompt string for switching console
;		volumes, add a message that we are resuming load operation.
;
;	V03-003	KDM0073		Kathleen D. Morse	26-Aug-1983
;		Make references to TENUSECTBL and UBDELAY PIC.
;		Move the following cells to BOOTDRIVR.MAR:  EXE$GL_UBDELAY
;		and EXE$GL_TENUSEC.
;
;	V03-002	KDM0062		Kathleen D. Morse	18-Jul-1983
;		Add data cells used by TIMEDWAIT macro, so that boot
;		drivers can use a standard time-wait macro.
;
;	V03-01	KDM0045		Kathleen D. Morse	14-Apr-1983
;		Created from VMB version V03-011.
;
;--

	.SBTTL	Declarations

	.DEFAULT DISPLACEMENT, WORD

;
; Macros to describe VMS data structures
;

	$BQODEF				; Boot QIO offsets
	$BTDDEF				; Boot device definitions
	$DMPDEF				; System dump file header definitions
	$IHDDEF				; Image header definitions
	$IODEF				; I/O function codes
	$MBADEF				; MASSBUS adapter registers
	$NDTDEF				; Nexus device types
	$PRDEF				; Processor registers
	$RPBDEF				; Restart parameter block
	$SSDEF				; System status codes
	$UBADEF				; UNIBUS adapter registers
	$VADEF				; Virtual address fields
	$VMBARGDEF			; Define VMB argument list offsets
;
; Processor-specific definitions
;
	$IO730DEF			; 11/730 definitions

;
; Macros
;

	.MACRO	ERROR,STR		; Outputs an error string to the
	BSBW	ERROUT			; console terminal.
	.ASCIZ	STR
	.ENDM	ERROR
;
; Equated symbols
;

	IO_SIZE		= 127		; Maximum # blocks in one read
	CR		= 13		; ASCII code for carriage return
	LF		= 10		; ASCII code for line feed
	BITMAP_PAG_CNT	= 4		; Number of pre-allocated
	STACK_PAG_CNT	= 3		; Number of stack pages to allocate
					; PFN bitmap pages

;
; Static storage
;

	.PSECT	__Z99BOOT,PAGE		; PSECT that always links at end
					; of bootstrap.
BOOTHIGH::				; Symbol to mark the start of
					; the first page after the code
					; in this module.

	.IF	DF,DEBUG		; If debugging code included,
EXE$MCHKVEC	== BOOTHIGH+4		; define a symbol used by XDELTA
	.ENDC				; to locate the SCB.

;
; Declare a code PSECT that will always link at the start of the image.
;

	.PSECT $$$$00BOOT,LONG		; Use default PSECT

	.SBTTL	START_BOOT, Primary bootstrap routine

;++
; Functional description:
;
;	VMB is loaded into physical memory and gains control via a JMP
;	instruction from CONSOLE, boot block 0 on the boot device, or
;	BOOT58. VMB gains control in the routine START_BOOT.
;
;	VMB begins by creating and initializing an SCB. If the software
;	bootstrap control flags specified a bootstrap breakpoint, VMB
;	then executes a BPT instruction that transfers control to
;	XDELTA.
;
;	After the XDELTA breakpoint, VMB initializes a system data
;	structure, i.e., a restart parameter block (RPB) that allows
;	a system reboot after a power failure or crash. The RPB holds
;	the bootstrap input registers, the boot device's CSR and bus
;	configuration register (CR), the address of the RPB itself, and
;	pointers to a primitive device driver.
;
;	VMB, the primary bootstrap, also identifies all physical memory
;	in the configuration by creating a bit map in which each bit
;	represents one page of physical memory. In the process of
;	testing all memory, VMB determines which NEXUSes on the system
;	bus are attached to adapters. For every adapter present, VMB
;	records the adapter type in the RPB.
;
;	Finally, VMB chooses a secondary bootstrap image -- either by
;	default, by boot flag settings, or by soliciting a file
;	specification from the user. VMB uses a minimal driver for the
;	bootstrap device to load the secondary image into memory, and
;	transfers control to that bootstrap.
;
;	The secondary bootstrap -- usually SYSBOOT.EXE -- uses the 
;	minimal driver from VMB for reading and writing to and from the
;	bootstrap device. Thus, SYSBOOT is device-independent.
;
;	VMB has CPU dependencies such as system bus addresses, memory
;	controller registers, and bus adapter register formats.
;	Therefore, VMB consists of common code that applies to all VAX
;	implementations, and CPU-specific code that applies to one
;	hardware implementation only. The current version supports the
;	following CPUs:
;
;		11/730	(NEBULA)
;
; Inputs:
;
;	R0	- <07:00> boot device type code (RPB$B_DEVTYP)
;
;			0	MASSBUS device (RM02/3,RP04/5/6/7,RM80)
;			1	RK06/7
;			2	RL01/2
;			3	IDC(almost an RA80) on 11/730
;			17	UDA-50
;			32	HSC on CI
;			64	Console block storage device
;
;		- <15:08> reserved for future expansion
;
;		- <31:16> device class dependent (RPB$W_R0UBVEC)
;
;			UNIBUS  - optional vector address; 0 implies
;					use the default vector
;
;			MASSBUS - not used
;
;	R1	- boot device's bus address
;
;			11/730	- <31:04> MBZ
;				  <03:00> TR number of adapter
;
;	R2	- UNIBUS:
;
;			<31:18> MBZ
;			<17:00> UNIBUS address of the device's CSR
;
;		- MASSBUS:
;
;			<31:04> MBZ
;			<03:00> adapter's controller/formatter number
;
;		- CI:
;			<31:08> MBZ
;			<07:00> HSC port number (station address)
;
;	R3	- boot device unit number
;
;	R4	- logical block number to boot from if bit 3 is set in R5
;
;	R5	- software boot control flags
;
;		Bit	Meaning
;		---	-------
;
;		 0	RPB$V_CONV.
;			Conversational boot. At various points in the
;			system boot procedure, the bootstrap code
;			solicits parameters and other input from the
;			console terminal. If the DIAG is also on, then
;			the diagnostic supervisor should enter "MENU"
;			mode and prompt user for devices to test.
;
;		 1	RPB$V_DEBUG.
;			Debug. If this flag is set, VMS maps the code
;			for the XDELTA debugger into the system page
;			tables of the running system.
;
;		 2	RPB$V_INIBPT.
;			Initial breakpoint. If RPB$V_DEBUG is set, VMS
;			executes a BPT instruction immediately after
;			enabling mapping.
;
;		 3	RPB$V_BBLOCK.
;			Secondary boot from boot block. Secondary
;			bootstrap is a single 512-byte block, whose
;			LBN is specified in R4.
;
;		 4	RPB$V_DIAG.
;			Diagnostic boot. Secondary bootstrap is image
;			called [SYSMAINT]DIAGBOOT.EXE.
;
;		 5	RPB$V_BOOBPT.
;			Bootstrap breakpoint. Stops the primary
;			and secondary bootstraps with a breakpoint
;			instruction before testing memory.
;
;		 6	RPB$V_HEADER.
;			Image header. Takes the transfer address of the
;			secondary bootstrap image from that file's
;			image header. If RPB$V_HEADER is not set, 
;			transfers control to the first byte of the
;			secondary boot file.
;
;		 7	RPB$V_NOTEST.
;			Memory test inhibit. Sets a bit in the PFN bit
;			map for each page of memory present. Does not
;			test the memory.
;
;		 8	RPB$V_SOLICT.
;			File name. VMB prompts for the name of a
;			secondary bootstrap file.
;
;		 9	RPB$V_HALT.
;		 	Halt before transfer. Executes a HALT
;			instruction before transferring control to the
;			secondary bootstrap.
;
;		10	RPB$V_NOPFND.
;			No PFN deletion (not implemented; intended to
;			tell VMB not to read a file from the boot device
;			that identifies bad or reserved memory pages,
;			so that VMB does not mark these pages as valid
;			in the PFN bitmap).
;
;		13	RPB$V_MEMTEST
;			Specifies that a more extensive algorithm be used
;			when testing main memory for hardware uncorrectable
;			(RDS) errors.
;
;		15	RPB$V_AUTOTEST
;			Used by Diagnostic Supervisor.
;
;		16	RPB$V_CRDTEST
;			Specifies that memory pages with correctable (CRD)
;			errors be discarded at bootstrap time.  If set in
;			conjunction with bit 13 (RPB$V_MEMTEST), then the
;			more extensive test algorithm is used to detect
;			CRD errors.
;
;		<31:28>	RPB$V_TOPSYS
;			Specifies the top level directory number for system
;			disks with multiple systems
;
;	The hardware or the CONSOLE program sets up the next 3 registers
;	after a system crash or power failure:
;
;	R10	- halt PC
;	R11	- halt PSL
;	AP	- halt code
;
;	SP	- <base_address + ^X200> of 64kb of good memory
;
; Implicit inputs:
;
;	When VMB gains control, physical memory looks like the diagram
;	below:
;
;	SP-^X200:	+--------------------------------------+
;			|     Restart Parameter Block (RPB)    |
;	SP:		+--------------------------------------+
;			|       Primary bootstrap (VMB)        |
;			+--------------------------------------+
;
; Outputs:
;
;	R10	- base address of region containing secondary bootstrap
;	R11	- address of restart parameter block
;	SP	- current stack pointer
;	PR$_SCBB- system control block address
;
; Implicit outputs:
;
;	When VMB transfers control to the secondary bootstrap, physical
;	memory is laid out as in the diagram below:
;
;	RPB$L_BASE:	+--------------------------------------+
;			|     Restart Parameter Block (RPB)    |
;	base+^X200:	+--------------------------------------+
;			|       Primary bootstrap (VMB)        |
;	PR$_SCBB:	+--------------------------------------+
;			|      System control block (SCB)      |
;			+--------------------------------------+
;			|             PFN Bitmap               |
;	PFNMAP+^X800:	+--------------------------------------+
;			|               Stack                  |
;	SP:		+--------------------------------------+
;			|     Secondary bootstrap (SYSBOOT)    |
;			+--------------------------------------+
;
; The design for the PFN bitmap has been extended to handle more than
; 4 pages of bitmap = 8mb of memory.  Bitmaps that do not fit in the
; 4 page reserved area are now allocated contiguous good pages in
; higher memory.  Assuming that the pages are actually good, the
; bitmap is placed at the RPB address + 1mb.  If a page in that area is
; bad, then the next contiguous run of pages that is big enough is
; where the bitmap will be placed.  For backward compatibility, the
; RPB$Q_PFNMAP descriptor in the RPB points at the pre-allocated
; 4 page bitmap, which is correct for the low 8mb of memory.  The
; real descriptor for the bitmap is passed in the argument list.
;
;--

START_BOOT::				; Start of primary bootstrap.

;
; Reserve space for a System Control Block (SCB) immediately after the
; VMB code. Write the address of a machine check fault handler in all
; vectors in the SCB. This handler is used during bootstrapping except
; when the bootstrap code specifically writes a different handler
; address in one of the SCB vectors.
;
; The low bit set in the address of the fault handler causes the handler
; to execute on the interrupt stack.
;

	MOVAB	BOOT_FAULT+1,R6		; Get the address of a handler.
	MOVAB	BOOTHIGH+^X200,R7	; Get the address of the first
					; byte past the SCB.

;
; Register usage in the loop below is as follows:
;
;	R6	- address (+1) of a machine check handler
;	R7	- address of 1 byte past a longword of SCB
;

FILL_SCB:				; Fill SCB vectors.
	MOVL	R6,-(R7)		; Write 1 vector.
	BITW	#^X1FF,R7		; Check for page boundary.
	BNEQ	FILL_SCB		; Need to write another vector.

;
; Write the address of the SCB into the SCB processor register.
;

	MTPR	R7,#PR$_SCBB		; Load SCB processor register.

;
; Read the system identification processor register to discover which
; kind of VAX is to be booted.
;

	MFPR	#PR$_SID,R8		; Read the CPU identification
					; processor register.
	ASHL	#-PR$V_SID_TYPE,R8,R8	; Get CPU identification code.
	CMPB	R8,#3			; Is this an 11/730?
	BEQL	SAVE_PROCID		; Yes, branch to save code.

;
; Error return from VMB. Output a message on the console terminal,
; and halt.
;

FATAL_ERROR:				; Not a known processor.
	ERROR	</%BOOT-F-Unknown processor/>

;
; Processor is of known type. Store type code for later use by BOOTDRIVR
; and XDELTA.
;

SAVE_PROCID:				; Store processor code.
	MOVB	R8,EXE$GB_CPUTYPE	; Save processor code globally.

;
; Now determine if this is a Micro-VAX architecture or a full VAX
; architecture machine.  If it is Micro-VAX, then load the appropriate
; SCB emulation exception vectors to point to the software emulator for
; the character string instructions.  Note that the decimal and floating
; point emulation is not loaded as part of VMB.
;
; Note:  No character string instructions may be used up until this point!
;	 No decimal or floating point instructions may be used at all in VMB!
;
	MOVAB	VAX$EMULATE,^XC8(R7)	; Load emulation exception vector
	MOVAB	VAX$EMULATE_FPD,^XCC(R7) ; Load FPD emulation vector

;
; If the DEBUG flag is defined (meaning that XDELTA has been linked
; with this primary bootstrap), set up 2 XDELTA handlers in the SCB --
; one for breakpoints and one for tbit traps. Then initialize the
; XDELTA breakpoint table, allocate 3 pages of stack, and, if requested,
; execute a breakpoint before proceeding with the bootstrap.
;

	.IF	DF,DEBUG
	MOVAB	XDELBPT,^X2C(R7)	; Set up BPT handler.
	MOVAB	XDELTBIT,^X28(R7)	; Set up TBIT handler.
	MOVAB	INI$BRK,XDELIBRK	; Store the initial breakpoint.
	.ENDC
	MOVL	SP,R6			; Save current top of stack.
	MOVAB	<<STACK_PAG_CNT+1>*^X200>(R7),SP ; Create a stack,
					; add 1 page for the SCB
	.IF	DF,DEBUG
	BBC	#RPB$V_BOOBPT,R5,-	; If no BPT was requested in the
		NOBRK			; boot flags, just proceed.

;
; Initial breakpoint.
;
; Current register status is as follows:
;
;	R0-R5	- initial VMB input values
;	R6	- SP value at start of VMB
;	R7	- address of the SCB
;	R8	- processor identification code
;	R9-FP	- initial VMB input values
;	SP	- address of a 3-page stack
;
; Code following the breakpoint is going to restore SP to its original
; value. If you want to modify SP in XDELTA, modify R8 instead.
;

INI$BRK::				; Debugging breakpoint.
	BPT				; Stop in XDELTA.

NOBRK:					; Proceed with bootstrapping.
	.ENDC
	MOVL	R6,SP			; Restore SP's original value.

	.SBTTL	Initialize RPB

;++
;
; The next section of VMB writes the restart parameters into the RPB.
; These parameters include
;
;	the VMB input registers
;	the base address of the RPB
;	the boot device's CSR
;	the boot device adapter's configuration register (CR)
;	the address of the PFN bitmap
;	the address and length of the bootstrap device driver
;
; Current register settings are as follows:
;
;	R0-R5	- unchanged from time that VMB gained control
;	R7	- address of the SCB
;	R8	- processor identification code
;	R9-FP	- unchanged from time that VMB gained control
;	SP	- SP value from time that VMB gained control
;	
;--

;
; Store the boot parameters in the RPB, as well as the RPB starting
; address. CONSOLE-controlled restart code looks for the starting
; address contained within itself as a clue to VMS restartability.
;

	MOVL	R11,R6			; Save Halt PSL temporarily
	MOVAB	-^X200(SP),R11		; Calculate base address of RPB.
	MOVL	R11,BOO$GL_RPBBASE	; Save address for callback.
	MOVL	R11,RPB$L_BASE(R11)	; Save address in RPB.
	MOVQ	R0,RPB$L_BOOTR0(R11)	; Save boot registers R0-R1.
	MOVQ	R2,RPB$L_BOOTR2(R11)	; Save boot registers R2-R3.
	MOVQ	R4,RPB$L_BOOTR4(R11)	; Save boot registers R4-R5.
	MOVL	R10,RPB$L_HALTPC(R11)	; Save Halt PC in RPB
	MOVL	R6,RPB$L_HALTPSL(R11)	; Save Halt PSL in RPB
	MOVAL	BOO$AL_VECTOR,-		; Save address of boot device
		RPB$L_IOVEC(R11)	; driver
	CLRL	RPB$L_IOVECSZ(R11)	; Correct size of boot-driver wil be
					; set by the first call to BOO$QIO
	MOVL	AP,RPB$L_HALTCODE(R11)	; Save the halt code.
	MNEGL	#1,RPB$L_ADPPHY(R11)	; Initialize adapter physical address
	MNEGL	#1,RPB$L_CSRPHY(R11)	; Initialize CSR physical address

;
; Move device characteristics from the input registers into the RPB.
;

	MOVW	R3,RPB$W_UNIT(R11)	; Save the device unit number.
	MOVB	R0,RPB$B_DEVTYP(R11)	; Save the device type.

;
; From this point on AP contains the address of the Secondary Boot
; argument list.
;

	MOVAL	SECOND_PARAM,AP		; Address of Secondary Boot arg list

;
; Reserve space for an PFN bitmap that will desecribe all of physical
; memory. Store the address and size of the PFN bitmap in the RPB.
;

	MOVAB	^X200(R7),R10		; Get base of free memory (1
					; page past SCB base address).
	MOVAB	RPB$Q_PFNMAP+4(R11),R9	; Get pointer to RPB bitmap
					; address field.
	MOVL	R10,(R9)		; Store PFN bitmap address.
	MOVAB	BITMAP_PAG_CNT*512(R10),R10 ; Reserve pre-allocated bitmap pages
	SUBL3	(R9),R10,-(R9)		; Store bitmap size in RPB.

;
; Allocate the stack again. The previous allocation was just for use
; in XDELTA.
;

	MOVAB	<STACK_PAG_CNT*^X200>(R10),SP ; Create an stack.
	MOVL	SP,R10			; Adjust pointer to 1st unused
					; byte of free memory.

	.SBTTL	Locate and test memory

;++
;
; The next section of the primary bootstrap program determines and
; records the size and pattern of available memory in a PFN bitmap.
; It does this by calling a processor specific subroutine linked with VMB.
; Each subroutine handles the sizing of memory and the testing of the
; pages.  A common routine (BOO$TEST_MEM) is called to allocate and
; initialize bitmap segments, and loop through the page testing.
; When the sizing and testing are complete, the resulting bitmap is
; neither contiguous nor necessarily dense.  There could be ranges of
; PFN's that are simply not present and will of course be assumed 
; to be bad.  At this point a contiguous chunk of memory is allocated
; and a clean, dense, contiguous bitmap is formed from the pieces.
;
; Current register settings are the following:
;
;	R0-R6	- scratch
;	R7	- address of the SCB
;	R9	- address of RPB$Q_PFNMAP
;	R10	- address of 1st byte of unused good memory
;	R11	- address of the RPB
;	AP	- address of secondary boot argument list
;	FP	- scratch
;	SP	- address of a 3 page stack
;
; For 11/730, the CONFREG array is filled in by INITADP
; at a later stage of bootstrapping.
;
;--

LOC_TEST_MEM:

;
; No assembly time initialization is allowed in VMB because the
; ERROR logic allows it to restart.
;
	CLRL	VMB$L_HI_PFN(AP)	; Init BITMAP data for
	ROTL	#21,#1,VMB$L_LO_PFN(AP)	; highest and lowest PFN
	CLRL	BITMAP_HI_INDX		; Highest bitmap page index
	ROTL	#<32-9>,R11,R0		; Base PFN for large bitmaps
	MOVAL	4096(R0),BITMAP_BAS_PFN ; is 2mb beyond RPB
;
; Initialize the pre-allocated PFN bitmap pages to zero.  There is
; at least one such page to hold the bitmap for the pre-tested
; block of memory in which we are running.  The size of this 
; pre-allocated bitmap is an integral number of pages.
;

	MOVL	4(R9),R6		; Get base of PFN bitmap.
	MOVC5	#0,(R6),#0,(R9),(R6)	; Set bitmap to all zeroes.
	MOVC5	#0,(R6),#0, -		; Zero fill the memory descriptors in
		#<RPB$C_MEMDSCSIZ*RPB$C_NMEMDSC>,RPB$L_MEMDSC(R11) ; the RPB
	CLRL	RPB$L_PFNCNT(R11)	; Init the count of good pages
	CLRL	RPB$L_BADPGS(R11)	; Init the count of bad pages
	MOVL	R10,BITMAP_VEC_PTR	; Address of vector of bitmap addresses
	MOVC5	#0,(R10),#-1,#512*4,(R10) ; Init bitmap address vector.
;
; A side effect of the above MOVC5 is that R1 = R10
;
	MOVL	R3,R10			; Next free address (page bounded)
	MOVL	4(R9),R3		; Address of pre-allocated bitmap
	MOVL	#BITMAP_PAG_CNT,R2	; Number of pages of pre-alloc bitmap
10$:	MOVL	R3,(R1)+		; Store address of bitmap page
	MOVAL	^X200(R3),R3		; Next pre-allocated bitmap page
	SOBGTR	R2,10$			; Loop through pre-allocated page(s)

;
; Allow the bitmap page containing the RPB to be above the pre-allocated
; (8mb max) PFN bitmap.
;
	ASHL	#-<9+12>,R11,R0		; Bitmap index for RPB
	TSTL	@BITMAP_VEC_PTR[R0]	; Need a bitmap page for this
					; portion of the PFN bitmap?
	BGEQ	20$			; Branch if not
	MOVL	R10,@BITMAP_VEC_PTR[R0] ; Use one more pre-tested page
	MOVC5	#0,(R10),#0,#512,(R10)	; as the bitmap page
	MOVL	R3,R10			; Keep track of next free address
20$:
;
; In the 11/730, the CONFREG field is not filled in by VMB, but
; initialized in INITADP at a later stage of bootstrapping.  The difference
; is to maintain backward compatibility of VMB for currently supported systems.
;

	MOVAB	RPB$B_CONFREG(R11),R5	; Point to start of
					; configuration field.

;
; Now call the CPU-specific routine to locate and test memory.
;

	PUSHR	#^M<R9,R10,AP>		; Save some registers
	BSBW	CHECKMEM_730		; Call a CPU-specific memory test rtn.
	POPR	#^M<R9,R10,AP>		; Restore saved registers
	CMPL	BITMAP_HI_INDX,#BITMAP_PAG_CNT-1 ; All bitmap pre-allocated?
	BGTR	ALLOC_BITMAP		; Branch if not
	ADDL3	#1,BITMAP_HI_INDX,R0	; Actual number of the pre-allocated
					; bitmap pages that were used
	ASHL	#9,R0,RPB$Q_PFNMAP(R11)	; Record possibly smaller descriptor
	BRW	BITMAP_IS_OK		; Yes, don't need to move it

;
; Need to allocate a contiguous PFN bitmap and move the scattered 
; bitmap pages into it.
;
; The starting point for trying to allocate is 4096 pages (2mb) after
; the RPB.  The only pages that can be in use here that appear to be
; good and usable are the bitmap pages themselves when they are
; allocated as the first good PFN in a given bitmap page.
;

ALLOC_BITMAP:
	SUBL3	#1,BITMAP_BAS_PFN,R2	; Desired location for bitmap
	CLRL	R5			; Init "first alloc failure" flag
	BRB	45$
10$:	AOBLSS	VMB$L_HI_PFN(AP),R2,20$	; Calculate the next PFN
	ERROR	</%BOOT-F-Failed to allocate PFN bitmap/>
20$:	EXTZV	#0,#12,R2,R0		; Bitmap page relative PFN
	EXTZV	#12,#9,R2,R1		; Index to bitmap page
	MOVL	@BITMAP_VEC_PTR[R1],R1	; Address of bitmap page
	BGEQ	30$			; Branch if present
	BISW	#^XFFF,R2		; Skip this entire bitmap page
	BRB	40$
30$:	BBC	R0,(R1),40$		; Branch if page is bad
	ASHL	#9,R2,R0		; Address from PFN
	CMPL	R0,R1			; Same as bitmap page adr?
	BNEQ	50$			; Branch if not, its ok
					; Otherwise treat as a bad page
40$:	BBSS	#0,R5,45$		; Branch if not first alloc failure
	ADDL3	BITMAP_HI_INDX,R4,R2	; Skip the entire "pre-planned"
					; allocation area.  Some bitmap pages
					; may be in it, but in the wrong place
45$:	ADDL3	#1,R2,R4		; Reset start point of search
	ADDL3	#1,BITMAP_HI_INDX,R3	; Reset no. of pages to look for
50$:	SOBGEQ	R3,10$			; Next page in contiguous cluster

;
; Now move all the bitmap pages into the contiguous space just found
;

MOVE_BITMAP:
	ASHL	#9,R4,R3		; Starting adr of new bitmap
	MOVL	R3,4(R9)		; Record base adr of PFN bitmap
	MOVL	BITMAP_VEC_PTR,R6	; Adr of array of bitmap page adrs
10$:	MOVL	(R6)+,R1		; Adr of next bitmap page
	BGEQ	20$			; Branch if page is allocated
	MOVC5	#0,(R3),#0,#512,(R3)	; No good pages in this 2mb
	BRB	50$
20$:	CMPL	R1,R3			; No move needed?
	BNEQ	30$			; Branch if must move the page
	MOVAL	512(R3),R3		; Just adjust the bitmap adr
	BRB	50$
30$:	MOVC3	#512,(R1),(R3)		; Move the bitmap page
50$:	SOBGEQ	BITMAP_HI_INDX,10$	; Loop through all bitmap pages
	SUBL3	4(R9),R3,(R9)		; Store size of PFN bitmap
BITMAP_IS_OK:
	MOVL	BITMAP_VEC_PTR,R10	; Reset first free byte pointer

	BSBW	BOO$CACHE_ALLOC		; Allocate the FILEREAD cache
	MOVZBL	RPB$B_DEVTYP(R11),R2	; Hold the devie type
	MOVL	RPB$L_IOVEC(R11),R0	; Pick up vector address
	MOVL	R11,R9			; Transfer RPB address
	JSB	@BQO$L_MOVE(R0)[R0]	; Move the boot driver

;
; Initialize the boot device's bus adapter.  If not console, call a
; CPU-specific subroutine to convert this data into the physical
; addresses of the adapter's configuration register (CR) and the
; device's control/status register (CSR). Store the addresses in the
; RPB.
;

ADPINIT:				; Initialize adapter.
	MOVQ	RPB$L_BOOTR1(R11),R1	; Pick up original R1/R2
	BSBW	SAVE_CSR_730		; Call a CPU-specific routine to
					; save boot device and adapter's CSRs
	MOVL	RPB$L_ADPPHY(R11),R0	; Get ADP CSR address.
	BSBW	INIT_ADP_730		; Call CPU-specific adapter init rtn.
10$:	MOVL	RPB$L_IOVEC(R11),R0	; Pick up vector address
	MOVL	VMB$Q_UCODE+4(AP),-
		BQO$L_UCODE(R0)		; Transfer the ucode address
	MOVL	BQO$L_UNIT_INIT(R0),R1	; Pick up any possible routine
	BEQL	15$			; None
	CALLG	(AP),(R0)[R1]		; Do any necessary unit init
	BLBS	R0,15$			; All is well
	ERROR	</%BOOT-F-Failed to initialize device/>

15$:

;
; The adapter initialization routines exit with RSB instructions. Thus,
; control returns here, and proceeds to obtain the secondary bootstrap
; specification as described on the next page.
;

	.SBTTL	Identify and read in the secondary boot image

;++
;
; Current register settings are the following:
;
;	R0-R6	- scratch
;	R7	- address of the SCB
;	R9	- scratch
;	R10	- address of the 1st byte of unused memory
;	R11	- address of the RPB
;	AP	- address of secondary boot parameter list
;	SP	- address of a 3 page stack
;
; Registers R0-R6 and R9 are available as scratch registers.
;
; The primary bootstrap now looks at a software bootstrap flag --
; RPB$V_BBLOCK. If the flag is set, the secondary bootstrap is a single
; block from the boot device. The LBN is stored in RPB$L_BOOTR4.
; Set up size of secondary bootstrap, transfer address, memory address,
; and LBN fields so that subsequent code can read the boot block into
; memory and transfer control to the code contained therein.
;
; If the RPB$V_BBLOCK flag is not set, the primary bootstrap must load
; a secondary bootstrap file specified by an ASCII file specification.
;
; If another boot flag -- RPB$V_SOLICT -- is set, the primary bootstrap
; asks the console user to type in a file specification.
;
; If the boot flag is not set, the bootstrap just selects a standard
; secondary bootstrap from the boot device. The bootstrap then calls I/O
; subroutines that locate the file, copy it into memory above the stack,
; and transfer control to the image's transfer address.
;
;--

;
; If we are booting from the console block storage device, it is 
; necessary to switch the media to the system floppy or cartridge.
; Type a message on console and wait for carriage return.
;

	CMPB	RPB$B_DEVTYP(R11),-	; Booting from console block
		#BTD$K_CONSOLE		; storage device?
	BRW	20$			; So we can reach it
103$:	PUSHAB	INPBUF			; Push address of input buffer
	PUSHL	#2			; Push size of buffer
	PUSHAB	SWITCHPROMPT		; Push address of prompt string
	CALLS	#3,BOO$READPROMPT	; Prompt and wait for <ret>
	CLRQ	-(SP)			; Null buffer means print only
	PUSHAB	RESUMEPROMPT1		; Give them some reassurance
	CALLS	#3,BOO$READPROMPT	; Print the message
					; Push arguments for QIO.
	PUSHL	R11			; Push phony channel number.
	PUSHL	#0			; Physical read mode.
	PUSHL	#IO$_READLBLK		; Read logical block function.
	PUSHL	#1			; Starting LBN.
	MOVZWL	#512,-(SP)		; Transfer size in bytes.
	PUSHL	R10			; Buffer address
	CALLS	#6,BOO$QIO		; Call a bootstrap QIO routine.
	BLBS	R0,101$
	ERROR	</%BOOT-F-Unable to read system volume/>
101$:	MOVAB	472(R10),R5		; Point R5 at the volume label
	MOVL	#12,R0			; Length of volume label
	MOVAB	(R5)[R0],R1		; Point R1 one past the end
201$:	MOVB	-(R1),R2		; R2 contains the byte
	BEQL	301$			; Byte is null, skip it
	CMPB	#^A" ",R2		; Is it a space
	BNEQ	401$			; End of name found, print it
301$:	SOBGTR	R0,201$			; Do the whole string
	BRB	501$			; No name, don't bother not printing it

401$:	CLRB	1(R1)			; Put a null after the string
	CLRQ	-(SP)			; Null buffer is print only
	PUSHL	R5			; R5 -> front of volume label
	CALLS	#3,W^BOO$READPROMPT	; Type the first string
501$:	CLRQ	-(SP)			; Null buffer means print only
	PUSHAB	RESUMEPROMPT2		; Give them some reassurance
	CALLS	#3,BOO$READPROMPT	; Print the message

;
; The next code paragraph is historical: refers only to the 11/780:
; If the boot block flag is set, prepare I/O input registers.
;

20$:	BBC	#RPB$V_BBLOCK,-		; If the boot from boot block
		RPB$L_BOOTR5(R11),-	; flag is not set, proceed to
		TEST_SOLICIT		; test the solicit bit.
	MOVL	#2,R5			; block to go, and transfer
					; address from start of block.
	MOVL	RPB$L_BOOTR4(R11),R8	; Get boot block LBN.
	MOVL	#1,R9			; Set block size to 1 block.
	BRW	READIN_BOOT		; Proceed to read in block.

;
; If the "solicit for secondary bootstrap file" flag is not set,
; just use a predefined file specification.
;

TEST_SOLICIT:				; Check for solicit.
	BBC	#RPB$V_SOLICT,-		; If "solicit" flag is not
		RPB$L_BOOTR5(R11),-	; set, just use a default file
		DEFAULT_SECOND		; specification.

;
; To solicit a file name, call a device-independent subroutine that
; writes a prompt string to the console terminal, and then reads the
; user typed file name. All device specifications are ignored.
;

	PUSHAB	RPB$T_FILE(R11)		; Set address of input buffer.
	PUSHL	#39			; Set maximum character count.
	PUSHAB	NAMEPROMPT		; Set address of prompt string.
	CALLS	#3,BOO$READPROMPT	; Prompt and read string.
	MOVL	#1,R9			; No retry if this file is not found
	BRB	FILEBOOT		; Go try to read the file.

;
; If the solicit boot flag was not set, use a default file name string.
; Usually, this file name is [SYSEXE]SYSBOOT.EXE. However, if the
; diagnostic boot flag is set, the file name is [SYSMAINT]DIAGBOOT.EXE.
;

DEFAULT_SECOND:				; Use default file name.
	MOVAB	VMSFILE,R7		; Assume SYSBOOT.EXE.
	BBC	#RPB$V_DIAG,-		; If the diagnostic flag is not
		RPB$L_BOOTR5(R11),-	; set, SYSBOOT is correct.
		COPY_NAME
	MOVAB	DIAGFILE,R7		; Otherwise, use predefined
					; name of diagnostic boot.

;
; Copy the file name to the RPB.
;

COPY_NAME:				; Copy file name.
	MOVZBL	(R7),R0			; Size of name string
	INCL	R0			; Include the byte count character
	MOVC3	R0,(R7),RPB$T_FILE(R11)	; Move name into RPB
	EXTZV	#RPB$V_TOPSYS,#RPB$S_TOPSYS,-
		RPB$L_BOOTR5(R11),R9 	; Value of 0-F means top level
					; system directory "SYS0" - "SYSF"
	CMPL	R9,#9			; 0 - 9 ?
	BLEQ	10$			; Branch if yes
	ADDL	#<<^A/A/>-<^A/9/>-1>,R9	; Add bias to make A - F
10$:	ADDB	R9,RPB$T_FILE+5(R11)	; Form "SYSn"

;
; Call a device-independent routine, FIL$OPENFILE to locate the named
; file on the disk.
;
; Registers set up are the following:
;
;	R10	- address of 1st byte of unused memory
;	R11	- address of the RPB
;


FILEBOOT:				; Locate the file.
	BSBW	BOO$CACHE_OPEN		; Open the FILEREAD cache
10$:	PUSHAB	RPB$T_FILE+1(R11)	; Address of file name string.
	MOVZBL	RPB$T_FILE(R11),-(SP)	; Character count of file name.
	MOVAL	-(SP),R6		; Allocate scratch for channel
					; and get adr of scratch storage
	PUSHAL	RPB$L_FILLBN(R11)	; RPB fields that receive file
					; statistics during OPEN.
	PUSHAL	(R10)			; File header buffer at end of
					; memory.
	PUSHAL	^X200(R10)		; Index file header buffer at
					; end of memory.
	PUSHAL	4(R6)			; Address in file name desc.
	PUSHAL	(R6)			; Address of phony channel.
	CALLS	#5,FIL$OPENFILE		; Call FILEREAD to locate file.
	ADDL2	#12,SP			; Clean up scratch space
	BLBS	R0,FILE_CONTIG		; Branch on success.

;
; File was not found.  If looking up default secondary boot file in
; SYS0 top level system directory, try the lookup with a null TOPSYS.
;

	CMPW	R0,#SS$_NOSUCHFILE	; If not "no such file"
	BNEQ	30$			; then don't consider a second try
	TSTL	R9			; If TOPSYS is not "SYS0"
	BNEQ	30$			; then don't consider a second try
	INCL	R9			; Only one extra try
	MOVZBL	(R7)+,R0		; Default string byte count
	SUBL	#6,R0			; Discard "[SYS0."
	ADDB3	#1,R0,RPB$T_FILE(R11)	; Store shorter byte count
					; Include the "["
	MOVC3	R0,6(R7),RPB$T_FILE+2(R11) ; From just after "[SYS0."
					; to just after "["
	BRB	10$			; Try again with a null TOPSYS
30$:

;
; File was not found. Report an error.
;

	CMPW	#SS$_NOSUCHDEV,R0	; "No such device" error?
	BNEQ	FILOPN_ERR		; Branch if not.
	BRW	NOSUCHDEV		; Report "no such device" error.

FILOPN_ERR:				; Report unknown error.
	ERROR	</%BOOT-F-Unable to locate BOOT file/>
					; Output error message.

;
; File was located successfully. Make sure that the file is contiguous.
; The file statistics block is the following:
;
;	+----------------------+
;	|     starting LBN     | (0 if file not contiguous)
;	+----------------------+
;	|    size in blocks    |
;	+----------------------+
;

	ASSUME	RPB$L_FILSIZ EQ RPB$L_FILLBN+4

FILE_CONTIG:				; Test for contiguity.
	MOVQ	RPB$L_FILLBN(R11),R8	; Get file statistics.
	TSTL	R8			; Contiguous file?
	BNEQ	READ_HEADER		; Yes, continue.
	ERROR	</%BOOT-F-Bootfile not contiguous/>
					; Output error message.

;
; If the software boot control flags indicate that that transfer
; address of the secondary bootstrap is stored in the image file's
; header block, read that header block. Otherwise, assume that the
; transfer address is simply the 1st byte in the image file.
;

READ_HEADER:				; Read header if necessary.
	CLRL	R5			; Assume no transfer address.
	BBC	#RPB$V_HEADER,-		; If no header requested,
		RPB$L_BOOTR5(R11),-	; then just branch past header
		READIN_BOOT		; reading code.
	MOVL	R10,R6			; Start of free memory
	MOVL	#1,R9			; Header is always only 1 block.
	BSBW	READFILE		; Read header block.
	MOVQ	RPB$L_FILLBN(R11),R8	; R8 = 1st LBN, R9 = block count
	MOVQ	R9,R2			; R2 = block count, R3 = hdr adr
	BSBW	BOO$IMAGE_ATT		; Get image attributes
;
; R1 = image header block count
; R2 = size of file in blocks excluding symbol table and patch text
;
	MOVL	R1,RPB$B_HDRPGCNT(R11)	; Store image header block count
	SUBL3	R1,R2,R9		; Blocks in image after header block(s)
	ADDL	R1,R8			; LBN of first block beyond headr block(s)
	MOVZWL	IHD$W_ACTIVOFF(R10),R1	; Get offset to image
					; activation data in header.
	ADDL	R10,R1			; Form transfer vector address.
	MOVL	(R1),R5			; Get transfer address.

;
; Now read in the file. If the file is too large for the remaining
; memory space, see if the required additional pages are usable.
; If they are, use them.  If not issue a fatal diagnostic and HALT.
;
; Registers set up now are the following:
;
;	R5	- transfer address
;	R8	- starting LBN of file (after header)
;	R9	- size of file in blocks
;	R10	- address of 1st byte in free memory
;	R11	- address of the RPB
;	AP	- secondary boot argument list
;

READIN_BOOT:

	MOVQ	RPB$Q_PFNMAP(R11),VMB$Q_PFNMAP(AP) ; Set up bit map descriptor
	MOVL	R10,R6			; Buffer for read

;
; Will the desired number of blocks fit in the space remaining in the
; pre-tested 64kb of memory?  If not, check that the additional pages
; required are usable.  If they are, then read it all, otherwise quit.
;

CHECK_BOOT_FIT:
	ROTL	#<32-9>,R11,R0		; PFN for RPB
	MOVAL	127(R0),R0		; Last PFN guaranteed to be good
	ROTL	#<32-9>,R10,R1		; Starting PFN for read
	ADDL	R9,R1			; Last+1 PFN needed to be good
	BRB	30$			; Zero or more iterations
10$:	BBC	R0,@VMB$Q_PFNMAP+4(AP),SECOND_TOO_BIG ; Branch if cannot
					; read the entire secondary boot
30$:	AOBLSS	R1,R0,10$		; Check the next page

;
; Now read the secondary boot code into memory
;

	BSBB	READFILE		; Read.

;
; The secondary bootstrap is now in memory. If the software boot control
; flags asked for a HALT before the secondary bootstrap gains control,
; execute a HALT instruction. Otherwise, transfer control to the new
; bootstrap image.
;

	BBC	#RPB$V_HALT,-		; If boot flags don't call for
		RPB$L_BOOTR5(R11),-	; halt, just transfer to new
		START_SECOND		; bootstrap image.
	HALT				; Otherwise, HALT.

START_SECOND:				; Transfer to secondary boot.
	JMP	(R5)[R10]		; Execute JUMP.

;
; Secondary bootstrap does not fit in the pre-tested 64kb and
; one or more of the required adjacent pages is not usable.
;

SECOND_TOO_BIG:
	ERROR	</%BOOT-F-Boot file too big/>


;
; No such device error reporting.
;

NOSUCHDEV:				; "No such device" I/O error.
	ERROR	</%BOOT-F-Nonexistent drive/>
					; Output error message.

	.SBTTL	READFILE, Reads bootstrap file in large chunks

;++
;
; Functional description:
;
;	Calls the device-independent bootstrap QIO routine to read
;	a file. Divides the file into pieces as large as possible, so
;	that the read is a small number (like 1) of DMA transfers.
;
; Inputs:
;
;	R6	- buffer address
;	R8	- logical block number (LBN)
;	R9	- number of blocks in file
;
; Implicit inputs:
;
;	IO_SIZE	- largest number of blocks possible in single transfer
;
; Outputs:
;
;	Registers R1-R4, and R5 must be preserved.
;
;	R6	- buffer address updated past last byte read
;	R8	- LBN updated to block after last block read
;	R9	- blocks in file (reduced to number not read)
;
; Implicit outputs:
;
;--

READFILE:				; Read file into memory.
	MOVZBL	#IO_SIZE,R7		; Assume maximum transfer size.
	CMPL	R7,R9			; Minimize with file size.
	BLEQ	10$			; Branch if file larger than
					; maximum transfer size.
	MOVL	R9,R7			; Set to remaining file size.

10$:					; Push arguments for QIO.
	PUSHL	R11			; Push phony channel number.
	PUSHL	#0			; Physical read mode.
	PUSHL	#IO$_READLBLK		; Read logical block function.
	PUSHL	R8			; Starting LBN.
	ROTL	#9,R7,-(SP)		; Transfer size in bytes.
	PUSHL	R6			; Buffer address
	ADDL	4(SP),R6		; Update buffer address.
	ADDL	R7,R8			; Update LBN.
	CALLS	#6,BOO$QIO		; Call a bootstrap QIO routine.
	BLBS	R0,20$			; Continue on success.
	CMPW	#SS$_NOSUCHDEV,R0	; "No such device" error?
	BEQL	NOSUCHDEV		; Branch if yes.
	ERROR	<\%BOOT-F-I/O error reading boot file\>
					; Output error message.

20$:					; Read more file if any left.
	SUBL	R7,R9			; Decrement blocks remaining.
	BGTR	READFILE		; Continue if not done.
	RSB				; Return to caller when done.

	.SBTTL	Test memory

;++
;
; Functional description:
;
;	This routine tests a given range of PFN's and builds one or
;	more bitmap pages.  Each bitmap page address is recorded in
;	the corresponding long word in the bitmap page address array.
;
; Calling Sequence:
;
;	JSB	BOO$TEST_MEM
;
; Inputs:
;
;	R2 = address of page test routine
;	R3 = number of pages to test
;	R9 = starting page number
;	R11 = address of Restart Parameter Block
;	BITMAP_VEC_PTR - contains the base address of the bitmap
;		page address array.
;	SECOND_PARAM - is the address of the Secondary Boot parameter
;		list.  The lowest and highest PFN's seen are to be
;		recorded here.
;
; Outputs:
;
;	R0,R1,R2,R3,R6,R9 altered
;	others preserved
;
;	Store address of newly allocated bitmap page(s) in the vector
;		pointed to by BITMAP_VEC_PTR and indexed by the
;		high 9 bits of the PFN's covered by the bitmap page.
;	Record the lowest (inclusive) and highest (exclusive) PFN's 
;		seen in the offsets VMB$L_LO_PFN and VMB$L_HI_PFN
;		of the Secondary Boot Parameter list (SECOND_PARAM).
;	Record the highest bitmap page index used in the vector of
;		bitmap page addresses (BITMAP_HI_INDX).
;
;--

;
; Scratch storage offset definitions
;
	$OFFSET	0,NEGATIVE,<-
	NXT_PFN,-		; Starting PFN for next segment of bitmap
	NXT_PAGCNT,-		; Page count remaining
	PRETST_PFN,-		; Pre-tested starting PFN
	PRETST_CNT,-		; Pre-tested page count
	PAGTST,-		; Address of page test routine
	<SCRATCH_SIZE,0>-	; Size of scratch area
	>

BOO$TEST_MEM::
	PUSHR	#^M<R4,R5,R7,R8,R10,FP,AP>
	MOVAL	SECOND_PARAM,AP		; Point at Secondary Boot Parameter list
	MOVL	SP,FP			; Use FP as a local pointer
	SUBL	#-SCRATCH_SIZE,SP	; Reserve local storage
	ROTL	#<32-9>,R11,PRETST_PFN(FP) ; Set start of pre-tested pages
	ROTL	#7,#1,PRETST_CNT(FP)	; 128 pre-tested pages
	MOVL	R2,PAGTST(FP)		; Save address of page test routine
	ADDL3	R3,R9,R0		; Last + 1 PFN
	CMPL	R0,VMB$L_HI_PFN(AP)	; Higher than last highest?
	BLEQ	10$			; Branch if not
	MOVL	R0,VMB$L_HI_PFN(AP)	; Yes, record the highest value
10$:	CMPL	R9,VMB$L_LO_PFN(AP)	; Is the starting PFN smaller than
					; the currently recorded smallest?
	BGEQ	20$			; Branch if not
	MOVL	R9,VMB$L_LO_PFN(AP)	; Yes, record the smallest one seen
20$:
NEXT_BITMAP:
	EXTZV	#0,#12,R9,R2		; No. of pages from beginning
					; of bitmap page (4096 bits/page)
	ADDL	R2,R3			; Page count is larger by that amount
	MOVL	R3,R1			; Save this page count
	ROTL	#12,#1,R0		; Max of 4096 pages per bitmap page
	CMPL	R3,R0			; More than a bitmap's worth?
	BLEQ	10$			; Branch if not
	MOVL	R0,R3			; Yes, use the max
10$:	SUBL3	R3,R1,NXT_PAGCNT(FP)	; No. of pages left for next iteration
	SUBL	R2,R3			; Actual no. of pages to test
	ADDL	R9,R3			; Last + 1 PFN to be tested
	MOVL	R3,NXT_PFN(FP)		; Save for next iteration if any
	ASHL	#-12,R9,R10		; Index to bitmap page address array
	CMPL	R10,BITMAP_HI_INDX	; Is this the highest index seen?
	BLEQ	20$			; Branch if not
	MOVL	R10,BITMAP_HI_INDX	; Keep track of the highest index
20$:	MCOML	#0,R6			; Bitmap page address not set yet
	BBS	#RPB$V_NOTEST,RPB$L_BOOTR5(R11),- ; If not testing memory
		INIT_BITMAP		; then fill in bit map as all good

;
; Test each page for gross errors unless RPB$V_NOTEST is set. For each
; page available and good (if tested), set the corresponding bit in
; the PFN bitmap.
;

MEM_LOOP:				; Test one controller's worth.
	CMPL	R9,PRETST_PFN(FP)	; Is this a the next pre-tested page?
	BNEQ	TEST_PAGE		; Branch if not, go test it

;
; Just handle these pre-tested pages one at a time.  There are only
; 128 of them, and handling them as a unit means they are restricted 
; to being in the same bitmap segment.  It is required that they be
; in one controller, but this further breakdown into 4096 page units
; which fit into a one page bitmap is artificial.
;

	INCL	PRETST_PFN(FP)		; Yes, step to next PFN
	SOBGTR	PRETST_CNT(FP),GOOD_PAGE ; Count these pages
					; Treat it as good, don't retest
	MCOML	#0,PRETST_PFN(FP)	; No, more pre-tested pages left
	BRB	GOOD_PAGE		; Last pre-tested page is good too
TEST_PAGE:
	ASHL	#9,R9,R0		; Convert page # to physical address
	ROTL	#6,#1,R1		; Loop counter for 64 quadwords.
	JSB	@PAGTST(FP)		; Test this page
GOOD_PAGE:				; Good page here.
	TSTL	R6			; Is the bitmap set up yet?
	BLSS	INIT_BITMAP		; Branch if no, must init one
COUNT_PAGE:
	BBSS	R9,(R6),NEXT_PAGE	; Set bit in bitmap; do next page
	INCL	RPB$L_PFNCNT(R11)	; Increment good page count.

;
; If more pages remain in this bitmap segment, continue looping.
;

NEXT_PAGE:				; Do next page, if any.
	AOBLSS	R3,R9,MEM_LOOP	; Process next page if any
CHK_NEXT_BITMAP:
	MOVL	NXT_PFN(FP),R9		; Starting PFN for next bitmap segment
	MOVL	NXT_PAGCNT(FP),R3	; Another bitmap segment to do?
	BNEQ	NEXT_BITMAP		; Branch if yes
	MOVL	FP,SP			; Clean off local storage
	POPR	#^M<R4,R5,R7,R8,R10,FP,AP> ; Recover saved registers
	RSB				; and return
;
; Handler that gains control when a page has gross memory errors.
; Entered via a BRW from the actual machine specific handler after it
; has done the machine specific thing necessary to clear the condition
;

BOO$PAGE_MCHECK::			; Skip current page.
	SUBL3	#-SCRATCH_SIZE,FP,SP	; Restore stack pointer.
	INCL	RPB$L_BADPGS(R11)	; Count number of bad pages found.
	BRB	NEXT_PAGE		; And get the next page
;
; Allocate and initialize a page of bitmap for this bitmap segment
;
INIT_BITMAP:
	MOVL	@BITMAP_VEC_PTR[R10],R6 ; Is bitmap page allocated?
	BGEQ	GOT_BITMAP		; Branch if yes
	ADDL3	R10,BITMAP_BAS_PFN,R2	; Desired PFN for this bitmap page
	EXTZV	#0,#12,R2,R0		; Bitmap page relative PFN
	EXTZV	#12,#9,R2,R1		; Index to bitmap page
	MOVL	@BITMAP_VEC_PTR[R1],R1	; Address of bitmap page
	BLSS	20$			; Branch if entire bitmap page not there
	BBC	R0,(R1),20$		; Branch if desired page was bad
					; or not yet tested
	ASHL	#9,R2,R6		; Form bitmap adr from PFN
	BRB	30$
20$:	ASHL	#9,R9,R6		; Use first good page mapped by this
					; bitmap to hold this bitmap page
30$:	PUSHL	R3			; Save last PFN to be tested
	MOVC5	#0,(R6),#0,#512,(R6)	; Init all PFN's bad
	POPR	#^M<R3>			; Restore last PFN to be tested
	MOVL	R6,@BITMAP_VEC_PTR[R10] ; Record adr of bitmap page
GOT_BITMAP:
	ASHL	#-3,R9,R0		; Form byte offset from the beginning
	BICW	#^X1FF,R0		; of the bitmap to PFN 0
	SUBL	R0,R6			; so that BBSS PFN,(R6) will work
	BBC	#RPB$V_NOTEST,RPB$L_BOOTR5(R11),- ; Branch if testing memory
		COUNT_PAGE
;
; Set bits for pages which are not to be tested, but assumed good.
;
	SUBL3	R9,R3,R2		; Count of pages to mark good
	ADDL	R2,RPB$L_PFNCNT(R11)	; Add them in as good pages
	MOVL	#32,R0			; Set 32 bits per iteration
	BICL3	#31,R2,R1		; Even no. of longwords worth
	MOVAB	-(R1)[R9],R1		; R1=R1-1+R9 = last PFN inclusive
					; for 32 at a time loop
20$:	INSV	#-1,R9,R0,(R6)		; Mark these pages good
	ACBL	R1,R0,R9,20$		; R9=R9+R0, If R9 LEQ R1 then GOTO 20$
	EXTZV	#0,#5,R2,R0		; No. of bits remaining to be set
	BEQL	30$			; Branch if all bits are set
	CLRL	R2			; Stop the next time around
	BRB	20$			; Set the remaining bits
30$:	BRW	CHK_NEXT_BITMAP

	.SBTTL	SAVE_CSRS, CPU-specific routines

;++
;
; Functional description:
;
;	One routine per CPU implementation follows. Each routine
;	determines from input registers the addresses of the boot
;	device's CSR and the attached adapter's CSR, and stores these
;	addresses in the RPB.
;
; Inputs:
;
;	R1	- address of the boot device's adapter
;
;			11/780	- <31:4> MBZ
;				  <3:0> TR number
;			11/750	- <31:24> MBZ
;				  <23:0> address of the I/O page for the
;					 boot device's adapter
;
;	R2	- UNIBUS:
;
;			<31:18> MBZ
;			<17:3> UNIBUS address of the device's CSR
;			<2:0> MBZ
;
;	R2	- MASSBUS or CI:
;
;			not used
;
;	R11	- address of the Restart Parameter Block
;
; Implicit inputs:
;
;	The boot device may be located on any UNIBUS, MASSBUS, or CI  adapter.
;
; Outputs:
;
;	R8, R11, and SP must be preserved.
;
; Implicit outputs:
;
;	The RPB fields RPB$L_ADPPHY and RPB$L_CSRPHY contain the
;	addresses of the adapter's register space and the boot device's
;	register space respectively. For CI or MASSBUS devices, these values
;	are identical.
;
;--

	.SBTTL	SAVE_CSR_730, Save CSRs for 11/730

;++
;
; SAVE_CSR_730, Save CSRs for 11/730
;
; Implicit inputs:
;
;	R1 contains the system bus address in the form of a TR number
;	because TR numbers map to fixed physical addresses.
;
;	Bus adapters on the 780 start at address IO780$AL_IOBASE for TR 0,
;	and increment by ^X2000 each subsequent adapter. UNIBUS address
;	space for the first UNIBUS in the configuration starts at
;	IO780$AL_UB0SP. The second through fourth UNIBUS start 64kb after
;	the previous UNIBUS. UNIBUS device CSRs are in the last 64kb of
;	the UNIBUS address space.
;
;	The I/O space layout for the 11/730 is the same as that
;	described above for the 11/780 except that the base of
;	TR 0 register space is IO730$AL_IOBASE and UNIBUS 0 space
;	starts at IO730$AL_UB0SP.  Also, only one UNIBUS will ever
;	be configured on an 11/730.
;
; Outputs:
;
;	R5-R11 and AP-SP are preserved.
;
;--

SAVE_CSR_730:				; Save CSRs for the 11/730.
	MOVAL	@#IO730$AL_IOBASE,R3	; Get adapter 0 space
	MOVAL	@#IO730$AL_UB0SP,R4	; Get UB0 space

;
; Compute and save adapter configuration register address:
;

	ROTL	#13,R1,R0		; Convert TR # to adapter
	ADDL	R3,R0			; configuration address
	MOVL	R0,RPB$L_ADPPHY(R11)	; Store in RPB
	MOVL	R0,RPB$L_CSRPHY(R11)	; Store in device CSR too in
					; case this is a MASSBUS or CI device.

;
; Read the configuration register to determine whether the adapter is
; for a UNIBUS, MASSBUS, or CI. Bits <31:3> of the configuration register
; identify the adapter type.
;

	MOVL	(R0),R3			; Read the adapter's CR.
	MOVB	R3,RPB$B_BOOTNDT(R11)	; Save boot adapter's nexus device type.
	BICL3	#3,R3,R0		; Clear the bits representing
					; a UBA number to obtain the
					; canonical adapter type.
	CMPB	#NDT$_UB0,R0		; Is this a UNIBUS adapter?
	BEQL	UBA_ADAPTER		; Yes. Go compute device's CSR.
	RSB				; RPB$L_CSRPHY already set for 
					; MASSBUS or CI, so return.

UBA_ADAPTER:				; Compute UNIBUS device's CSR.
	BISL3	R4,R2,-			; Add UNIBUS CSR value to
		RPB$L_CSRPHY(R11)	; base of all UNIBUS address
					; space.
	CLRL	R0			; Get start of this ub space
	INSV	R3,#18,#2,R0		; relative to UB0 space.
	ADDL	R0,RPB$L_CSRPHY(R11)	; Adjust CSR address to this UB space.
	RSB				; Return.

	.SBTTL	INIT_ADAP, CPU-specific adapter initialization routine

;++
;
; Functional description:
;
;	One routine per CPU implementation follows. Each routine
;	initializes the adapter for the boot device, if the adapter
;	requires such an initialization.
;
; Inputs:
;
;	R0	- physical address of the adapter
;	R1-R6	- scratch
;	R7	- address of the SCB
;	R9	- scratch
;	R10	- address of the 1st unused byte of good memory
;	R11	- address of the RPB
;
; Implicit inputs:
;
;	If the value in R0 is identical to the value in RPB$L_CSRPHY,
;	the adapter is for a UNIBUS. Otherwise, the adapter is for a
;	MASSBUS.
;
; Outputs:
;
;	R7-R8, R10-R11, and SP must be preserved.
;
; Implicit outputs:
;
;	The boot device's adapter is initialized.
;
;--

	.SBTTL	INIT_ADP_730, Initialize boot device 11/730 adapter

;++
;
; INIT_ADP_730, Initialize boot device adapter on the 11/730
;
; Implicit inputs:
;
;	The massbus is initialized by setting the init bit in the 
;	MBA adapter control register.  The unibus is initialized by
;	setting the UB reset IPR.  (On the 11/730 the adapter of
;	the boot device will always be a unibus.)
;
;--
	MCK_BER = ^X24			; Offset into machine check frame
					;  for Bus Error Register
	NEX	= 3			; Bit position for non-existent mem
	STEP	= ^X800			; Granularity of the step in memory
					;  probe algorithm

INIT_ADP_730:				; Initialize the 11/730 adapters.
	.ENABLE LSB
	CMPL	R0,RPB$L_CSRPHY(R11)	; Is ADP CSR addr = device CSR addr?
	BNEQ	10$			; No, must be UNIBUS
	MOVL	#MBA$M_CR_INIT,-	; Set the initialize bit
		MBA$L_CR(R0)		;
	RSB				; Done

10$:	MTPR	#0,#PR$_UBRESET		; Reset the UNIBUS adapter.

;
; Now check for any UNIBUS memory that may be on the adapter. If found
; disable the corresponding map registers.
;

	MOVZWL	#496,R1			; Pick up number to disable
	MOVAL	UBA$L_MAP(R0),R2	; Address of first
20$:	CLRL	(R2)+			; Invalidate it
	SOBGTR	R1,20$			; Loop until done
	PUSHL	4(R7)			; Save machine check vector
	MOVAL	B^MCHK_730,4(R7)	; Replace with a temporary
	MOVL	SP,R6			; Save stack pointer
	BICL3	#^X0003FFFF,-
		RPB$L_CSRPHY(R11),R1	; Get the start of UNIBUS space
	MOVL	R1,R2			; Copy
	MOVAB	-STEP(R1),LAST_MEM	; Initialize cell
	MOVAB	^X3C000(R2),R3		; Last 8KB of memory
30$:	TSTW	(R2)			; See if anything responds
40$:	CMPL	R1,R2			; First time in?
	BEQL	45$			; Yes, skip next test
	TSTL	BOO$GL_UMR_DIS		; Any registers already disabled?
	BEQL	55$			; No, memory not start at 0
	BLBS	MEM_FLAG,55$		; Yes, now the far side of a hole
	MOVL	R2,LAST_MEM		; Update counter
45$:	ADDL2	#STEP/512,BOO$GL_UMR_DIS; Up the count of registers to disable
50$:	ACBL	R3,#STEP,R2,30$		; Continue thru the entire space
55$:	SUBL2	LAST_MEM,R2		; Find size of hole
;
; NOTE:	This test is based on the fact that the bootdriver will only
;	allow a maximum of 127 pages in a single IO.  If that assumption
;	changes, this test will have to change.
;
	CMPL	R2,#<128*512>+STEP	; Is it big enough?
	BLSSU	TOO_MEM_ERR		; No, give error		
	POPL	4(R7)			; Restore old machine check handler
	RSB				; Done

	.ALIGN	LONG
MCHK_730:				; Temporary machine check handler
	MTPR	#^XF,#PR$_MCESR		; Reset machine check
	MOVL	#<1@NEX>,R4		; Set up
	CMPL	(SP),#^X0C		; Is this a 730 frame?
	BEQL	60$			; Yes, no further check
	MOVL	MCK_BER(SP),R4		; Save Bus error register
60$:	MOVL	R6,SP			; Clear machine check stack frame
	BBC	#NEX,R4,40$		; Branch if parity error on Umem
	MOVL	#1,MEM_FLAG		; Else non-existent memory, set flag
	BRB	50$			; Continue in line
	.DISABLE LSB			;

TOO_MEM_ERR:
	ERROR	</%BOOT-F-Too much UNIBUS memory/>

	.SBTTL	Strings used in File I/O

VMSFILE:				; Name of standard secondary
	.ASCIC	/[SYS0.SYSEXE]SYSBOOT.EXE/ ; bootstrap image file.

DIAGFILE:				; Name of standard diagnostic
	.ASCIC	/[SYS0.SYSMAINT]DIAGBOOT.EXE/ ; secondary bootstrap image.

NAMEPROMPT:				; Prompt string for secondary
	.ASCIZ	<CR><LF>/Bootfile:/	; boot file name.

DEVPROMPT:				; Prompt string for secondary
	.ASCIZ	<CR><LF>/Boot device name (ddcu):/
					; device mnemonic.

SWITCHPROMPT:				; Prompt string for switching console media
	.ASCII	<CR><LF><LF><LF><7>/Please insert the first standalone system diskette /
	.ASCIZ	<7>/or cartridge and press return: /<7>
RESUMEPROMPT1:				; Message that load is resuming
	.ASCIZ	/Resuming load operation on volume /
RESUMEPROMPT2:				; Message that load is resuming
	.ASCIZ	/, please stand by . . ./<CR><LF><LF>

	.SBTTL	Unexpected machine check handler, DEBUG labels

	.PSECT $$$$00BOOT,LONG		; Back to default PSECT

;
; Define handlers needed by XDELTA.
;

	.ALIGN	LONG			; All handlers longword-aligned.

	.IF	DF,DEBUG		; If debugging,

EXE$ACVIOLAT::				; Access violation vector.
EXE$BREAK::				; BPT vector.
EXE$ROPRAND::				; Reserved operand vector.
EXE$TBIT::				; Trace trap vector.
MMG$PAGEFAULT::				; Pagefault exception vector.

	.ENDC				; End of debugging conditional.

;
; Fault handler for unexpected exception conditions during bootstrap.
;
VAX$REFLECT_TO_VMS::			; Emulation error (except. frame on stk)
BOOT_FAULT:				; Handler for most of SCB.
	ERROR	</%BOOT-F-Unexpected Exception/>
					; Output error message.

	.ALIGN	LONG			; All handlers longword-aligned.

;
; Machine check handler.
;

UNEXP_MCHK::
	ERROR	</%BOOT-F-Unexpected Machine Check/>
					; Output error message.

;
; Labels required by XDELTA.
;

	.IF	DF,DEBUG		; If debugging, define labels.

INI$RDONLY::				; Dummy change protection
INI$WRITABLE::				; routines.
SYSL$CLRSBIA::				; Dummy routine to clear SBIA errors.
	RSB				; Just return.

EXE$GL_FLAGS::				; Dummy flags longword.
EXE$GL_SCB::				; Dummy SCB address pointer.
EXE$V_SIMULATOR	== 0			; This is not a simulator.

PFN$AB_STATE::
PFN$AB_TYPE::
PFN$AL_BAK::
PFN$AL_PTE::
PFN$Ax_BLINK::
PFN$Ax_FLINK::
PFN$AW_REFCNT::
PFN$AW_SWPVBN::

SYS$IOBASE::
SCH$GL_CURPCB::
SCH$GL_PCBVEC::

XDS$GT_WORD_PFN::
	.LONG	0

	.ENDC

	.SBTTL	Error message subroutine

;++
;
; Functional description:
;
;	This routine outputs a descriptive error message to the
;	console terminal. Then the routine restores the original
;	register settings from the time that the primary bootstrap
;	gained control, and executes a HALT instruction.
;
; Inputs:
;
;	SP	- points to address of message text
;
; Implicit inputs:
;
;	The RPB contains the contents of the original boot registers,
;	and the original stack pointer.
;
; Outputs:
;
;	Registers R0-R6, R10-R11, and AP are restored from the RPB.
;
; Implicit outputs:
;
;	When the HALT instruction executes, the console terminal reports
;	a halt and prompts the user for input.
;
;--

ERROUT::				; Report an error and HALT.
	MOVL	(SP)+,R8		; Get pointer to message text.
	CLRQ	-(SP)			; Null input buffer and size
					; arguments.
	PUSHL	R8			; Address of prompt string.
	CALLS	#3,BOO$READPROMPT	; Report the error.
	MOVL	BOO$GL_RPBBASE,R11	; Get the RPB address.
	MOVL	SP,R9			; Save old SP
	MOVL	RPB$L_BASE(R11),SP	; Set SP to base of memory.
	MOVAB	^X200(SP),SP		; Set SP to 1st page past RPB.
	MOVQ	RPB$L_BOOTR0(R11),R0	; Restore R0-R1.
	MOVQ	RPB$L_BOOTR2(R11),R2	; Restore R2-R3.
	MOVQ	RPB$L_BOOTR4(R11),R4	; Restore R4-R5.
	MOVL	RPB$L_HALTCODE(R11),AP	; Restore halt code.
	MOVQ	RPB$L_HALTPC(R11),R10	; Restore halt PC and PSL.
ERRHLT:
	HALT				; Halt the processor.

;
; If the user types CONTINUE to the console program, try to restart
; the bootstrap process.
;

	BLBS	MUST_HALT,ERRHLT	; Branch if cannot retart
	BRW	START_BOOT		; Restart the boot.

	.SBTTL	Declarations located at end of bootstrap

	.ALIGN	LONG
;
; Parameter list handed from primary boot to secondary boot
; The first location contains the argument count.  It is intended
; that the secondary boot will know what is in the list based on
; the argument count and the VMB version number.  This means that
; new information should be placed at new offsets even if older
; stuff becomes obsolete.  The VMB version number can be used to
; totally change the argument meanings if necessary.
;
SECOND_PARAM:
	FIL$GQ_CACHE	== .+VMB$Q_FILECACHE ; FILEREAD cache descriptor
	BOO$GB_SYSTEMID	== .+VMB$B_SYSTEMID  ; SCS system id
	.LONG	<VMB$C_ARGBYTCNT-4>/4	; Size of argument list
	.BLKB	VMB$C_ARGBYTCNT-4	; Reserve space for the arguments

BITMAP_VEC_PTR:
	.BLKL	1			; Address of bitmap page array
BITMAP_HI_INDX:				; Highest index to
	.BLKL	1			; bitmap page address array
BITMAP_BAS_PFN:				; Starting PFN for PFN bitmap
	.BLKL	1			; when it is bigger than the 
					; pre-allocated bitmap
INPBUF:	.LONG	0			; Dummy input buffer
BOO$GL_RPBBASE::
	.BLKL	1			; RPB base address
MUST_HALT:
	.LONG	0			; If LBS, ERROUT should not restart
					; rather it must halt.
UCODE_STAT:
	.LONG	0,0			; Statistics block for ucode file
LAST_MEM:
	.LONG	0			; Last memory location probed
MEM_FLAG:
	.LONG	0			; Flag for memory found

;
; If debugging flag is set, align end of bootstrap on a longword
; boundary.
;

	.IF	DF,DEBUG
	.ALIGN	LONG
	.ENDC

	.END	START_BOOT
