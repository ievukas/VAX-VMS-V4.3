	.TITLE	FILECMDS - FILE I/O COMMAND EXECUTION
	.IDENT	'V04-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; FILE I/O DCLS COMMAND EXECUTION
;
;	CLOSE FILE
;	OPEN FILE
;	READ FILE
;	WRITE FILE
;
; D. N. CUTLER 12-FEB-78
;
; MODIFIED BY:
;
;	V03-017	HWS0104		Harold Schultz		21-Aug-1984
;		Fix accvio in "invalid symbol" error path in READ
;		command.
;
;	V03-016 HWS0067		Harold Schultz		24-May-1984
;		Enable WRITE/SYMBOL to also handle quoted expressions
;		in addition to just symbols.
;
;	V03-015	HWS0063		Harold Schultz		27-Apr-1984
;		Initialize TIME_OUT flag in READ.
;
;	V03-014	HWS0050		Harold Schultz		03-Apr-1984
;		Add READ/TIME_OUT=n.
;		Add CLOSE/LOG.
;
;	V03-013	PCG0013		Peter George		14-Mar-1984
;		Get #11 right.  Allow writes to level-0 SYS$OUTPUT.
;		Fix PSL$C_USER access mode setting. Save status in
;		WRITE command when expanding symbols.
;
;	V03-012	HWS0023		Harold Schultz		08-Mar-1984
;		Set PSL$C_USER in FAB$V_FILE_MODE prior to opening a file.
;		Add /SYMBOL to WRITE command to allow output of symbols as
;		well as expressions.
;
;	V03-011	PCG0012		Peter George		25-Sep-1983
;		Allow writes to level-0 SYS$OUTPUT.
;
;	V03-010	PCG0011		Peter George		07-Sep-1983
;		Use new logical name services to create and delete
;		file logical names. Do not set PRN RAT attribute when
;		opening a file for read-only access.
;
;	V03-009	PCG0010		Peter George		15-Jul-1983
;		Modify READ symbol validation algorithm.
;
;	V03-008	PCG0009		Peter George		15-Jun-1983
;		Allow expressions in WRITE command.
;
;	V03-007	PCG0008		Peter George		01-Mar-1983
;		Call DCL$GETNVAL.
;		Understand that a terminal XAB exists.
;
;	V03-006	PCG0007		Peter George		14-Feb-1983
;		Fix OPEN/APPEND flag bit bug.
;
;	V03-005	PCG0006		Peter George		11-Jan-1983
;		Remove all references to ERRIFI and ERRRAB.
;		Fix READ/EOF bug.
;
;	V03-004	PCG0005		Peter George		07-Jan-1983
;		Fix WRITE/UPDATE accvio.  
;		Explicitly reset READ/MATCH mode.
;
;	V03-003	PCG0004		Peter George		29-Dec-1982
;		Allow + to delimit WRITE command parameters.
;		Use DCL$SAVE_STATUS instead of DCL$SET_STATUS.
;		Add READ/MATCH.
;
;	V03-002	PCG0003		Peter George		03-Dec-1982
;		Allocate write buffer on the stack.
;
;	V03-001	PCG0002		Peter George		23-Nov-1982
;		Use WRK_G_BUFFER instead of WRK_G_RECORD.
;---

;
; MACRO LIBRARY CALLS
;
 
	PRCDEF				;DEFINE PROCESS WORK AREA
	WRKDEF				;DEFINE COMMAND WORK AREA
	PTRDEF				;DEFINE RESULT PARSE DESCRIPTOR FORMAT
	IDFDEF				;DEFINE INDIRECT FRAME OFFSETS
	SYMDEF				;DEFINE TYPES OF SYMBOLS
	$CLIMSGDEF			;DEFINE ERROR/STATUS CODES
	$FABDEF				;DEFINE FAB OFFSETS
	$LNMDEF				;DEFINE LNM OFFSETS
	$NAMDEF				;DEFINE NAME BLOCK OFFSETS
	$PSLDEF				;DEFINE PROCESSOR STATUS FIELDS
	$RABDEF				;DEFINE RAB OFFSETS
	$STSDEF				;DEFINE STATUS LONG WORD VALUES
 
;
; PROCESS PERMANENT FILE PREFIX
;
 
ESCAPE=27
 
	.PSECT	DCL$ZCODE,BYTE,RD,NOWRT
;
; DATA INPUT PROMPT
;
DATAP:	.ASCIC	'Data:	'

;
; DEFAULT FILE NAME STRING
;
DFSPEC:	.ASCIC	'.DAT'
;
; KEYWORDS FOR OPEN/SHARE
;
READ:	.ASCII	'READ'
WRITE:	.ASCII	'WRIT'

LNM$PROCESS:
	.ASCIC	'LNM$PROCESS'

	.SBTTL	CLOSE FILE
;+
; DCL$CLOSE - CLOSE FILE
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO EXECUTE THE CLOSE FILE DCLS
; COMMAND.
;
; INPUTS:
;
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; OUTPUTS:
;
;	THE SPECIFIED FILE IS CLOSED.
;-
DCL$CLOSE::				;CLOSE FILE
	CLRBIT	WRK_V_CLOSERR,WRK_W_FLAGS2(R10)	;ASSUME /LOG
;
; ***** WARNING, GETID "RETURNS" VIA CO-ROUTINE CALL, NOTHING MAY BE ON THE STACK
;
	BSBW	GETID			;GET FILE IDENTIFICATION
	BLBS	R0,20$			;IF LBS FILE ID FOUND
;
; HAVE AN UNDEFINED FILE STATUS ERROR. CHECK FOR /NOLOG IN COMMAND LINE
;
	MOVAB	WRK_G_RESULT(R10),WRK_L_RSLNXT(R10)  ;RELOAD TOKEN POINTER
	MOVL	R0,-(SP)		;SAVE STATUS
10$:	BSBW	DCL$GETDVAL		;GET NEXT TOKEN IN COMMAND LINE
	CMPL	#PTR_K_ENDLINE,R5	;END OF THE LINE?
	BEQL	12$			;YES, GOTO EXIT
	CMPL	#PTR_K_COMDQUAL,R5	;COMMAND QUALIFIER?
	BNEQ	10$			;NO, CHECK NEXT TOKEN
	BSBW	DCL$GETNVAL		;GET QUALIFIER NUMBER
	CMPB	#CLI$K_CLOS_LOG,R1	;IS IT /LOG?
	BNEQ	10$			;NO, CHECK NEXT TOKEN

	CLRBIT	WRK_V_CLOSERR,WRK_W_FLAGS2(R10)	;ASSUME /LOG
	BBC	#PTR_V_NEGATE-PTR_V_FLAGS,R3,10$  ;SKIP REST IF /LOG
	SETBIT	WRK_V_CLOSERR,WRK_W_FLAGS2(R10) ;INDICATE /NOLOG
	BRB	10$			;CHECK NEXT TOKEN

12$:	MOVL	(SP)+,R0		;RESTORE STATUS
	BRB	30$

20$:	BSBW	CHECKPPF		;CHECK FOR PROCESS PERMANENT FILE
	BEQL	30$			;IF EQL, YES
;
; DELETE LOGICAL NAME.
;
	PUSHL	#PSL$C_SUPER		;PUSH ACCESS MODE
	MOVQ	R3,-(SP)		;BUILD LOGICAL NAME DECRIPTOR
	MOVAB	LNM$PROCESS,R1		;BUILD TABLE NAME DESCRIPTOR
	MOVZBL	(R1)+,R0		;
	MOVQ	R0,-(SP)		;
	MOVL	SP,R0			;SAVE ADDRESS OF DESCRIPTORS
	$DELLNM_S  TABNAM=(R0),-	;DELETE THE LOGICAL NAME
		LOGNAM=8(R0),-		;
		ACMODE=16(R0)		;
	ADDL	#4*5,SP			;CLEAN STACK

	MOVL	-(R9),(R7)		;REMOVE FILE DESCRIPTOR FROM LIST
	MOVL	PRC_L_INDFAB(R11),R8	;GET ADDRESS OF INDIRECT FAB
	MOVW	RAB$L_CTX+4(R9),FAB$W_IFI(R8) ;INSERT INTERNAL FILE INDEX
	MOVL	R9,R0			;SET ADDRESS OF BLOCK TO DEALLOCATE
	MOVZBL	#<RAB$C_BLN+4+7>&^C<7>,R1 ;SET LENGTH OF BLOCK TO DEALLOCATE
	BSBW	DCL$DEADYNMEM		;DEALLOCATE FILE DESCRIPTOR BLOCK
	$CLOSE	FAB=(R8)		;CLOSE FILE
30$:	RSB				;

	.SBTTL	OPEN FILE
;+
; DCL$OPEN - OPEN FILE
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO EXECUTE THE OPEN FILE DCLS
; COMMAND.
;
; INPUTS:
;
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; OUTPUTS:
;
;	THE SPECIFIED FILE IS OPENED AND A FILE DESCRIPTOR IS CONSTRUCTED.
;-
 
DCL$OPEN::				;OPEN FILE
	MOVL	PRC_L_INDFAB(R11),R8	;GET ADDRESS OF INDIRECT FAB
	CLRW	FAB$W_IFI(R8)		;CLEAR INTERNAL FILE INDEX
	CLRW	FAB$W_MRS(R8)		;USED FOR FLAGS TO "OPEN_CREATE"
	CLRL	FAB$L_ALQ(R8)		;CLEAR ALLOCATION QUANTITY
	CLRW	FAB$W_DEQ(R8)		;CLEAR DEFAULT FILE EXTENSION QUANTITY
	CLRB	FAB$B_FAC(R8)		;CLEAR FILE ACCESS TYPE
	CLRB	FAB$B_SHR(R8)		;CLEAR FILE SHARING
	INSV	#PSL$C_USER,#FAB$V_FILE_MODE,-  ;SET FILE ACCESS PROTECTION MODE
		#FAB$S_FILE_MODE,FAB$B_ACMODES(R8) 	;
	MOVL	#FAB$M_PPF,FAB$L_FOP(R8) ;SET FILE OPEN OPTIONS
	MOVB	DFSPEC,FAB$B_DNS(R8)	;SET SIZE OF DEFAULT NAME STRING
	MOVAB	DFSPEC+1,FAB$L_DNA(R8)	;SET ADDRESS OF DEFAULT NAME STRING
	MOVB	#FAB$C_SEQ,FAB$B_ORG(R8);SET FILE ORGANIZATION ASSUMING CREATE
	CLRB	FAB$B_RAT(R8) 		;CLEAR RECORD ATTRIBUTE TYPE
	MOVB	#FAB$C_VFC,FAB$B_RFM(R8) ;SET RECORD FORMAT
20$:	BSBW	DCL$GETDVAL		;GET NEXT DESCRIPTOR VALUES
	CMPL	#PTR_K_ENDLINE,R5	;END OF LINE?
	BNEQ	21$			;BRANCH IF NOT
	BRW	30$			;BRANCH IF DONE WITH SCAN
21$:	CMPL	#PTR_K_COMDQUAL,R5	;COMMAND QUALIFIER?
	BNEQ	20$			;IF NEQ NO
	BSBW	DCL$GETNVAL		;GET QUALIFIER NUMBER
	CMPB	#CLI$K_OPEN_READ,R1	;READ QUALIFER?
	BEQL	10$			;IF EQL YES
	CMPB	#CLI$K_OPEN_WRIT,R1	;WRITE QUALIFIER?
	BEQL	25$			;BRANCH IF YES
	CMPB	#CLI$K_OPEN_APPE,R1	;APPEND QUALIFIER?
	BEQL	26$			;BRANCH IF YES
	CMPB	#CLI$K_OPEN_SHAR,R1	;SHARE QUALIFIER?
	BEQL	28$			;BRANCH IF YES
	CMPB	#CLI$K_OPEN_ERRO,R1	;SUPRESS ERROR PRINTOUT?
	BNEQ	20$			;IF NEQ NO
	BISW	#2,FAB$W_MRS(R8)	;YES, SET PARAM TO "OPEN_CREATE"
	BRB	20$
10$:	BISB	#FAB$M_GET,FAB$B_FAC(R8) ;MARK /READ EXPLICITLY SPECIFIED
	BICW	#1,FAB$W_MRS(R8)	;USE $OPEN IN "OPEN_CREATE"
11$:	BRB	20$
26$:	BISW	#8,FAB$W_MRS(R8)	;SET EOF ROP BIT ON CONNECT (/APPEND)
	BISB	#FAB$M_PUT!FAB$M_DEL!FAB$M_UPD,FAB$B_FAC(R8) ;MARK WRITABLE
	MOVB	#FAB$M_PRN,FAB$B_RAT(R8) ;SET RECORD ATTRIBUTE TYPE
	BRB	20$
25$:	BISB	#FAB$M_PUT!FAB$M_DEL!FAB$M_UPD,FAB$B_FAC(R8) ;MARK /WRITE EXPLICITLY SPECIFIED
	MOVB	#FAB$M_PRN,FAB$B_RAT(R8) ;SET RECORD ATTRIBUTE TYPE
	BISW	#1,FAB$W_MRS(R8)	;USE $CREATE IN "OPEN_CREATE"
	BRB	20$			;
28$:	MOVB	#FAB$M_GET!FAB$M_PUT!FAB$M_DEL!FAB$M_UPD,FAB$B_SHR(R8) ;ASSUME /SHARE=WRITE
	CMPB	R4,#PTR_K_COLON		;DOES A VALUE FOLLOW /SHARE?
	BNEQ	20$			;IF NOT, GO WITH DEFAULT
	BSBW	DCL$GETDVAL		;GET REQUIRED VALUE OF QUALIFIER
	CMPL	R1,#4			;MORE THAN 4 CHARACTERS?
	BLEQ	29$			;BRANCH IF NOT
	MOVL	#4,R1			;TRUNCATE TO 4 CHARACTER KEYWORD
29$:	MOVQ	R1,R6			;SAVE DESCRIPTOR
	MOVB	#FAB$M_GET,FAB$B_SHR(R8) ;ALLOW OTHERS TO READ FILE
	CMPC3	R6,(R7),READ		;/SHARE=READ?
	BEQL	20$			;BRANCH IF YES
	MOVB	#FAB$M_GET!FAB$M_PUT!FAB$M_DEL!FAB$M_UPD,FAB$B_SHR(R8) ;ALLOW OTHERS TO READ/WRITE
	CMPC3	R6,(R7),WRITE		;/SHARE=WRITE?
	BEQL	11$			;BRANCH IF YES
	STATUS	IVKEYW			;INVALID KEYWORD
	RSB

30$:	BBC	#FAB$V_GET,FAB$B_FAC(R8),40$ ;IF /READ EXPLICITLY PRESENT,
	BICW	#1,FAB$W_MRS(R8)	;USE $OPEN EVEN IF /WRITE SPECIFIED TOO
40$:	TSTB	FAB$B_FAC(R8)		;WERE EITHER /READ OR /WRITE SPECIFIED?
	BNEQ	45$			;BRANCH IF AT LEAST ONE WAS
	BISB	#FAB$M_GET,FAB$B_FAC(R8) ;ASSUME /READ IF NOTHING SPECIFIED
;
; ***** WARNING, GETID "RETURNS" VIA CO-ROUTINE CALL, NOTHING MAY BE ON THE STACK
;
45$:	BSBW	GETID			;GET FILE ID
	BLBS	R0,60$			;IF LBS FILE ALREADY DEFINED
	MOVQ	R3,R6			;SAVE LOGICAL NAME PARAMETERS
	MOVZBL	#RAB$C_BLN+4,R1		;GET SIZE OF BLOCK REQUIRED
	BSBW	DCL$ALLDYNMEM		;ALLOCATE FILE DESCRIPTOR BLOCK
	BLBC	R0,50$			;IF LBC ALLOCATION FAILURE
	MOVL	R2,R9			;SAVE ADDRESS OF ALLOCATED BLOCK
	BSBW	DCL$GETDVAL		;GET FILE DESCRIPTOR VALUES
	MOVB	R1,FAB$B_FNS(R8)	;SET SIZE OF FILE NAME
	MOVL	R2,FAB$L_FNA(R8)	;SET ADDRESS OF FILE NAME
	MOVZWL	FAB$W_MRS(R8),R2	;GET FLAGS
	CLRW	FAB$W_MRS(R8)		;NO MAXIMUM RECORD SIZE
	BISW	#PRC_M_DISABL,PRC_W_FLAGS(R11) ;DISABLE CONTROL Y/C AST'S
	MOVL	R8,R0			;FAB ADDRESS TO OPEN/CREATE
	MOVL	R2,R1			;PASS OPEN/CREATE FLAGS (LOW 2 BITS)
	BSBW	DCL$OPEN_CREATE		;OPEN/CREATE THE FILE
	BLBC	R0,90$			;BRANCH IF ERROR
	MOVL	#CLI$_INVRFM,R0		;ASSUME RECORD FORMAT IS UNDEFINED
	CMPB	#FAB$C_UDF,FAB$B_RFM(R8);RECORD FORMAT UNDEFINED?
	BEQL	80$			;YES, THEN CLOSE FILE AND SET STATUS
	BLBS	R2,70$			;BRANCH IF CREATE
 
;
; OPEN FILE FOR READ ACCESS
;
	PUSHL	R2			;SAVE FLAGS
	MOVC	#RAB$C_BLN,@PRC_L_INPRAB(R11),4(R9) ;COPY INPUT RAB
	POPL	R2			;RESTORE FLAGS
	CLRL	RAB$L_ROP+4(R9)		;CLEAR ROP
	BBC	#3,R2,75$		;/APPEND?
	SETBIT	RAB$V_EOF,RAB$L_ROP+4(R9) ;SET EOF BIT FOR CONNECT
	BRB	75$			;PERFORM THE CONNECT
 
;
; SYMBOL TABLE OVERFLOW
;
 
50$:	STATUS	SYMOVF			;SET SYMBOL TABLE OVERFLOW
60$:	RSB				;
 
;
; OPEN FILE FOR WRITE ACCESS
;
 
70$:	MOVC	#RAB$C_BLN,@PRC_L_OUTRAB(R11),4(R9) ;COPY OUTPUT RAB
75$:	CLRW	RAB$W_ISI+4(R9)		;CLEAR INTERNAL STREAM INDEX
	$CONNECT RAB=4(R9)		;CONNECT RECORD STREAM
	BLBS	R0,100$			;IF LBS SUCCESSFUL CONNECT
 
;
; CONNECT OR LOGICAL NAME CREATION FAILURE
;
 
80$:	PUSHL	R0			;SAVE STATUS
	$CLOSE	FAB=(R8)		;CLOSE FILE
	POPL	R0			;RETREIVE STATUS
 
;
; OPEN FAILURE
;
 
90$:	PUSHL	R0			;SAVE STATUS
	MOVL	R9,R0			;SET ADDRESS OF BLOCK TO DEALLOCATE
	MOVZBL	#<RAB$C_BLN+4+7>&^C<7>,R1 ;SET SIZE OF BLOCK TO RELEASE
	BSBW	DCL$DEADYNMEM		;DEALLOCATE FILE DESCRIPTOR BLOCK
	POPL	R0			;RESTORE STATUS
	RSB				;
 
;
; SET IMPLIED CARRIAGE CONTROL IN ISI VALUE
;
 
100$:	INSV	#FAB$M_CR,#RAB$V_PPF_RAT,- ;SET IMPLIED CARRIAGE CONTROL
		#RAB$S_PPF_RAT,RAB$W_ISI+4(R9) ;
 
;
; FILE SUCCESSFULLY OPEN - CREATE LOGICAL NAME AND MERGE INTO 
; FILE DESCRIPTOR LIST
;
	MOVL	FAB$L_NAM(R8),R1	;GET ADDRESS OF NAME BLOCK
	SUBL	#16,SP			;ALLOCATE SPACE TO STORE DEVICE NAME
	MOVZBL	NAM$T_DVI(R1),R0	;GET LENGTH OF DEVICE NAME
	MOVQ	R0,-(SP)		;SAVE VOLATILE REGISTERS
	MOVC	R0,NAM$T_DVI+1(R1),8(SP) ;COPY DEVICE IDENTIFICATION
	MOVB	#^A/:/,(R3)		;APPEND A :
	MOVQ	(SP)+,R0		;RESTORE VOLATILE REGISTERS
	PUSHL	#ESCAPE			;BUILD INTERNAL FILE INDEX STRING
	MOVW	FAB$W_IFI(R8),2(SP)	;

	PUSHL	#LNM$M_CONFINE		;SET CONFINE NAME ATTRIBUTE
	PUSHL	#LNM$M_TERMINAL		;SET TERMINAL TRANSLATION ATTRIBUTE
	BBC	#NAM$V_CNCL_DEV,-	;IS DEVICE CONCEALED?
		NAM$L_FNB(R1),110$	;
	SETBIT	LNM$V_CONCEALED,(SP)	;SET CONCEALED TRANSLATION ATTRIBUTE
110$:	PUSHL	#PSL$C_SUPER		;SET ACCESS MODE

	CLRQ	-(SP)			;TERMINATE THE ITEM LIST
	PUSHAB	20(SP)			;BUILD EQUIVALENCE NAME ITEM
	PUSHAB	4(R0)			;SET LENGTH
	MOVW	#LNM$_STRING,2(SP)	;SET ITEM CODE
	CLRL	-(SP)			;BUILD TRANSLATION ATTRIBUTES ITEM
	PUSHAB	24(SP)			;SET ATTRIBUTES ADDRESS
	PUSHL	#LNM$_ATTRIBUTES@16+4	;SET ATTRIBUTES CODE AND LENGTH

	MOVAB	LNM$PROCESS,R1		;BUILD TABLE NAME DESCRIPTOR
	MOVZBL	(R1)+,R0		;
	MOVQ	R0,-(SP)		;
	MOVQ	R6,-(SP)		;BUILD LOGICAL NAME DESCRIPTOR

	MOVL	SP,R1			;SAVE ADDRESS OF LOGICAL NAME DESCRIPTOR
	$CRELNM_S  LOGNAM=(R1),-	;CREATE THE LOGICAL NAME
		TABNAM=8(R1),-		;
		ITMLST=16(R1),-		;
		ACMODE=44(R1),-		;
		ATTR=52(R1)		;
	ADDL	#20+<14*4>,SP		;RESTORE THE STACK
	BLBS	R0,120$			;IF LBC CREATION FAILURE
	BRW	80$			;

120$:	MOVZWL	FAB$W_IFI(R8),RAB$L_CTX+4(R9) ;RAB$L_CTX = FAB$W_IFI
	MOVB	FAB$B_ORG(R8),RAB$L_CTX+2+4(R9) ;RAB$L_CTX+2 = FAB$B_ORG
	MOVL	PRC_L_PPFLIST(R11),(R9)	;INSERT NEW FILE DESCRIPTOR INTO LIST
	MOVL	R9,PRC_L_PPFLIST(R11)	;
	RSB				;

	.SBTTL	READ FILE
;+
; DCL$READ - READ FILE
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO EXECUTE THE READ FILE DCLS
; COMMAND.
;
; INPUTS:
;
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; OUTPUTS:
;
;	A RECORD IS READ FROM THE SPECIFIED FILE AND STORED IN THE SPECIFIED
;	STRING VARIABLE.
;-
 
MAXRECSIZE	= 2048			;MAXIMUM LENGTH OF INPUT RECORD

DCL$READ::				;READ FILE
;
; ***** WARNING, GETID "RETURNS" VIA CO-ROUTINE CALL, NOTHING MAY BE ON THE STACK
;
	BSBW	GETID			;GET FILE IDENTIFICATION
	BLBS	R0,5$			;BRANCH IF FILE SPECIFICATION IS OK
	RSB				;EXIT WITH ERROR
5$:	BSBW	DCL$GETDVAL		;GET DESCRIPTOR OF SYMBOL NAME
	MOVQ	R1,R3			;SAVE SYMBOL NAME FOR POSSIBLE ERROR
	STATUS	SYMLNG			;ASSUME SYMBOL IS TOO LONG
	CMPL	R1,#255			;SYMBOL NAME TOO LARGE?
	BGTRU	10$			;IF GTRU YES
	MOVQ	R1,R6			;SAVE SYMBOL NAME DESCRIPTOR
	BSBW	DCL$CHKALPHA		;CHECK IF FIRST CHARACTER IS LEGAL
	BLBS	R0,20$			;IF LBS THEN YES
10$:	BRW	DSPXIT			;

;
; OBTAIN VALUES OF /KEY, /MATCH, /INDEX, /PROMPT, /TIME_OUT 
; AND PRESENCE OF /DELETE, /[NO]LOCK
;
20$:	ASSUME	RAB$C_SEQ EQ 0
	CLRW	@4(R8)			;ASSUME /NOTIME_OUT
	CLRB	RAB$B_RAC(R9)		;ASSUME /KEY ABSENT (SEQUENTIAL READ)
	CLRB	RAB$B_PSZ(R9)		;NO PROMPT STRING SPECIFIED YET
	SETBIT	RAB$V_PMT,RAB$L_ROP(R9)	;ASSUME PROMPTING ENABLED, THOUGH
	CLRBIT	RAB$V_NLK,RAB$L_ROP(R9)	;ASSUME /LOCK
	CLRBIT	RAB$V_RRL,RAB$L_ROP(R9)	;ASSUME RECORD LOCK CHECKING ON READ
	CLRBIT	RAB$V_KGE,RAB$L_ROP(R9)	;ASSUME /MATCH=EQ
	CLRBIT	RAB$V_KGT,RAB$L_ROP(R9)	;
	CLRBIT	RAB$V_ETO,RAB$L_ROP(R9)	;DO NOT USE THE TERMINAL XAB
	CLRL	-(SP)			;ASSUME /DELETE ABSENT (NO DELETION)
	MOVAB	WRK_G_RESULT(R10),WRK_L_RSLNXT(R10) ;RELOAD TOKEN POINTER
30$:	BSBW	DCL$GETDVAL		;GET NEXT DESCRIPTOR VALUES
	CMPL	#PTR_K_ENDLINE,R5	;END OF LINE?
	BNEQ	31$			;SKIP IF MORE TO PARSE
	BRW	60$			;DONE WITH SCAN
31$:	CMPL	#PTR_K_COMDQUAL,R5	;COMMAND QUALIFIER?
	BNEQ	30$			;IF NEQ NO
	BSBW	DCL$GETNVAL		;GET QUALIFIER NUMBER
	CMPB	#CLI$K_READ_KEY,R1	;/KEY QUALIFIER?
	BEQL	35$			;BRANCH IF YES
	CMPB	#CLI$K_READ_MATC,R1	;/MATCH QUALIFIER?
	BEQL	33$			;BRANCH IF YES
	CMPB	#CLI$K_READ_INDE,R1	;/INDEX QUALIFER?
	BEQL	40$			;BRANCH IF YES
	CMPB	#CLI$K_READ_PROM,R1	;/PROMPT QUALIFIER?
	BEQL	42$			;BRANCH IF YES
	CMPB	#CLI$K_READ_LOCK,R1	;/LOCK QUALIFIER?
	BEQL	45$			;BRANCH IF YES
	CMPB	#CLI$K_READ_TIME,R1	;/TIME_OUT QUALIFIER?
	BEQL	44$			;BRANCH IF YES
	CMPB	#CLI$K_READ_DELE,R1	;/DELETE QUALIFIER?
	BNEQ	30$			;BRANCH IF NOT
	MOVL	#1,(SP)			;MARK $DELETE TO BE DONE AFTER $GET
	BRB	30$
44$:	BRW	50$			;PROCESS /TIME_OUT QUALIFIER

45$:	BBC	#PTR_V_NEGATE-PTR_V_FLAGS,R3,30$ ;BRANCH IF /LOCK SPECIFIED (DEFAULT)
	SETBIT	RAB$V_NLK,RAB$L_ROP(R9)	;INHIBIT AUTOMATIC LOCKING ON GET
	SETBIT	RAB$V_RRL,RAB$L_ROP(R9)	;INHIBIT RECORD LOCK CHECKING AS WELL
	BRB	30$

35$:	BSBW	DCL$GETDVAL		;GET REQUIRED VALUE ON /KEY
	MOVB	R1,RAB$B_KSZ(R9)	;ASSUME KEY IS A STRING
	MOVL	R2,RAB$L_KBF(R9)
	MOVB	#RAB$C_KEY,RAB$B_RAC(R9) ;TELL RMS TO READ BY KEY
	BRB	30$

33$:	BSBW	DCL$GETDVAL		;GET REQUIRED VALUE ON /MATCH
	CMPW	#^A/GE/,(R2)		;IS IT GE?
	BLSSU	30$			;NO, EQ (DEFAULT)
	BGTRU	34$			;NO, GT
	SETBIT	RAB$V_KGE,RAB$L_ROP(R9)	;SET GE MATCH OPTION
	BRB	30$			;
34$:	SETBIT	RAB$V_KGT,RAB$L_ROP(R9)	;SET GT MATCH OPTION
	BRB	30$
	
42$:	BSBW	DCL$GETDVAL		;GET REQUIRED VALUE ON /PROMPT
	MOVL	R2,RAB$L_PBF(R9)	;SET PROMPT ADDRESS
	MOVB	R1,RAB$B_PSZ(R9)	;SET PROMPT SIZE
	BNEQ	43$			;BRANCH IF NON-NULL
	CLRBIT	RAB$V_PMT,RAB$L_ROP(R9)	;MARK NULL PROMPT BY TURNING IT OFF
43$:	BRW	30$

40$:	BSBW	DCL$GETDVAL		;GET REQUIRED VALUE ON /INDEX
	MOVQ	R1,R4			;SAVE DESCRIPTOR OVER CALL
	MOVQ	R1,R2			;SET DESCRIPTOR OF STRING TO CONVERT
	MOVZBL	#PRC_K_DEC,R1		;SET RADIX FOR CONVERSION
	BSBW	DCL$CNVASCBIN		;CONVERT DECIMAL ASCII TO BINARY
	BNEQ	32$			;IF ERROR, REPORT INVALID VALUE
	MOVB	R1,RAB$B_KRF(R9)	;STORE ISAM INDEX NUMBER
	BRW	30$
32$:	STATUS	IVCHAR			;INVALID CHARACTER
49$:	MOVQ	R4,R3			;SET DESCRIPTOR OF ERROR TEXT
	ADDL	#4,SP			;POP /DELETE FLAG OFF STACK
;
; RESTORE RAB TO ORIGINAL STATE
;
	SETBIT	RAB$V_ETO,RAB$L_ROP(R9)	;USE THE TERMINAL XAB IN THE FUTURE
	CLRBIT	RAB$V_NLK,RAB$L_ROP(R9)	;TURN OFF RECORD LOCKING
	CLRBIT	RAB$V_RRL,RAB$L_ROP(R9) ;    AND RECORD LOCK CHECKING
	BRW	DSPXIT			;REPORT ERROR AND EXIT

50$:	CLRW	@4(R8)			;ASSUME /NOTIME_OUT
	BBS	#PTR_V_NEGATE-PTR_V_FLAGS,R3,52$  ;SKIP IF /NOTIME_OUT
	BSBW	DCL$GETDVAL		;GET TIMEOUT VALUE
	MOVQ	R1,R4			;SAVE DESCRIPTOR FOR POSSIBLE ERROR
	MOVQ	R1,R2			;SET DESCRIPTOR OF STRING TO CONVERT
	MOVL	#PRC_K_DEC,R1		;DO ASCII DECIMAL TO BINARY CONVERSION
	BSBW	DCL$CNVNOEDIT		;CONVERT THE STRING
	TSTL	R1			;WAS VALUE NEGATIVE?
	BLSS	55$			;YES, REPORT ERROR
	CMPL	R1,#255			;VALUE > 255?
	BGTR	55$			;YES, REPORT ERROR
	MOVB	R1,@4(R8)		;SAVE TIMEOUT COUNT
	BISW	#^X4000,@4(R8)		;INDICATE /TIME_OUTPUT PRESENT
52$:	BRW	30$			;CHECK NEXT TOKEN

55$:	STATUS	INVRANGE		;SET INVALID RANGE ERROR STATUS
	BRB	49$			;REPORT ERROR


;
; READ RECORD
;

60$:	CLRBIT	RAB$V_TMO,RAB$L_ROP(R9)	;ASSUME /NOTIME_OUT
	BITW	#^X4000,@4(R8)		;WAS A TIMEOUT VALUE SPECIFIED
	BEQL	62$			;NO, SKIP TIMEOUT SETUP
	SETBIT	RAB$V_TMO,RAB$L_ROP(R9) ;SET TIMEOUT VALUE PRESENT FLAG
	MOVB	@4(R8),RAB$B_TMO(R9)	;SET TIMEOUT VALUE

62$:	MOVAB	-MAXRECSIZE(SP),SP	;ALLOCATE INPUT BUFFER ON STACK
	MOVL	SP,R8			;GET ADDRESS OF INPUT BUFFER
	MOVW	#MAXRECSIZE,RAB$W_USZ(R9) ;SET SIZE OF RECORD BUFFER
	MOVL	R8,RAB$L_UBF(R9)	;SET ADDRESS OF RECORD BUFFER
	;&&& This is a bug.  RAB$L_CTX is set to FAB$L_DEV for special PPF
	;&&& files like SYS$COMMAND, etc.
	CMPB	RAB$L_CTX+2(R9),#FAB$C_IDX ;ORG = ISAM?
	BEQL	65$			;IF SO, SKIP SETTING OF PROMPT STRING
	TSTB	RAB$B_PSZ(R9)		;PROMPT STRING EXPLICITLY SPECIFIED?
	BNEQ	65$			;IF NOT, SET THE FOLLOWING DEFAULT
	MOVB	DATAP,RAB$B_PSZ(R9)	;SET SIZE OF PROMPT STRING
	MOVAB	DATAP+1,RAB$L_PBF(R9)	;SET ADDRESS OF PROMPT STRING
65$:	BISW	#PRC_M_DISABL,PRC_W_FLAGS(R11) ;DISABLE CONTROL Y/C AST'S
	$GET	RAB=(R9)		;READ NEXT RECORD FROM FILE
	CLRBIT	RAB$V_TMO,RAB$L_ROP(R9) ;TURN TIMEOUT PROCESSING OFF
	BLBC	R0,80$			;IF LBC I/O ERROR
	MOVZWL	RAB$W_RSZ(R9),R1	;GET SIZE OF RECORD READ
	MOVL	R8,R2			;SET ADDRESS OF RECORD READ
	MOVQ	R6,R3			;SET DESCRIPTOR OF SYMBOL NAME
	MOVAB	PRC_Q_LOCAL(R11),R5	;SET ADDRESS OF SYMBOL TABLE LISTHEAD
	MOVL	#SYM_K_STRING,R0	;SET TYPE TO STRING
	BSBW	DCL$ALLOCSYM		;ALLOCATE AND INSERT SYMBOL IN TABLE
	BLBC	R0,80$			;IF LBC ALLOCATION FAILURE
	STATUS	NORMAL			;SET NORMAL COMPLETION STATUS
	BLBC	MAXRECSIZE(SP),80$	;BRANCH IF /DELETE NOT SPECIFIED
	$DELETE	RAB=(R9)		;DELETE CURRENT RECORD JUST READ
80$:	MOVAB	MAXRECSIZE+4(SP),SP	;DEALLOCATE INPUT BUFFER
;
; RESTORE RAB TO ORIGINAL STATE - SO THAT IN CASE WE ARE DEALING WITH A
; STANDARD PPF RAB, SUCH AS SYS$INPUT, NORMAL USE OF THE RAB FOR PROCEDURE
; INPUT IS NOT MESSED UP.
;
	SETBIT	RAB$V_ETO,RAB$L_ROP(R9)	;USE THE TERMINAL XAB IN THE FUTURE
	CLRBIT	RAB$V_NLK,RAB$L_ROP(R9)	;TURN OFF RECORD LOCKING
	CLRBIT	RAB$V_RRL,RAB$L_ROP(R9)	;   AND RECORD LOCK CHECKING
	RSB				;

	.SBTTL	WRITE FILE
;+
; DCL$WRITE - WRITE FILE
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO EXECUTE THE WRITE FILE DCLS
; COMMAND.
;
; INPUTS:
;
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; OUTPUTS:
;
;	THE SPECIFIED LIST OF STRING VARIABLES IS COLLECTED TOGETHER INTO A
;	SINGLE RECORD AND WRITTEN TO THE SPECIFIED FILE.
;-
 
DCL$WRITE::				;WRITE FILE
;
; ***** WARNING, GETID "RETURNS" VIA CO-ROUTINE CALL, NOTHING MAY BE ON THE STACK
;
	BSBW	GETID			;GET FILE IDENTIFICATION
	BLBS	R0,1$			;BRANCH IF OK
	RSB				;RETURN WITH ERROR
;
;	CHECK FOR PRESENCE OF /SYMBOL OR /UPDATE
;
1$:	CLRL	R6			;ASSUME /UPDATE ABSENT (NO $UPDATE)
	MOVAB	WRK_G_RESULT(R10),WRK_L_RSLNXT(R10) ;RELOAD TOKEN POINTER
2$:	BSBW	DCL$GETDVAL		;GET NEXT DESCRIPTOR VALUES
	CMPL	#PTR_K_PARAMETR,R5	;END OF LINE?
	BEQL	5$			;BRANCH IF DONE WITH SCAN
	CMPL	#PTR_K_COMDQUAL,R5	;COMMAND QUALIFIER?
	BNEQ	2$			;IF NEQ NO
	BSBW	DCL$GETNVAL		;GET QUALIFIER NUMBER
	CMPB	#CLI$K_WRIT_UPDA,R1	;/UPDATE QUALIFIER?
	BNEQ	3$			;BRANCH IF NOT
	BISB	#2,R6			;MARK $UPDATE TO BE DONE, NOT $PUT
	BRB	2$
3$:	CMPB	#CLI$K_WRIT_SYMB,R1	;/SYMBOL QUALIFIER?
	BNEQ	2$			;IF NEQ, NO
	BISB	#1,R6			;MARK /SYMBOL SEEN FLAG
	BRB	2$
;
;	GET SYMBOLS OR EXPRESSIONS AND CONCATENATE THEM IN THE OUTPUT BUFFER
;
5$:	MOVL	R6,-(SP)		;STORE /UPDATE AND /SYMBOL FLAG
	MOVL	SP,R8			;SET ENDING ADDRESS OF OUTPUT BUFFER
	MOVAB	-MAXRECSIZE(SP),SP	;ALLOCATE THE OUTPUT BUFFER ON THE STACK
	MOVL	SP,RAB$L_RBF(R9)	;SET ADDRESS OF OUTPUT BUFFER
	MOVL	SP,R7			;
10$:	BSBW	DCL$GETDVAL		;GET DESCRIPTOR VALUES
	MOVL	R4,R6			;SAVE TERMINATOR CLASS NUMBER
	STATUS	BUFOVF			;ASSUME OUTPUT BUFFER WILL OVERFLOW
	MOVQ	R1,R3			;SAVE VALUE DESCRIPT. FOR POSSIB. ERROR
	BLBC	(R8),30$		;IF CLEAR, VALUE IS AN EXPRESSION

	CMPL	#PTR_K_PLUS,R6		;IS TERMINATOR A '+'
	BNEQ	20$			;BRANCH IF NOT
	INCL	R3			;INCLUDE '+' IN ERROR MESSAGE
	STATUS	NOCCAT			;SET CONCAT. NOT ALLOWED ERROR MSG.
	BRB	90$			;REPORT ERROR

20$:	CMPB	#^A/"/,(R2)		;IS THIS A QUOTED STRING?
	BNEQ	25$			;NO, IT MUST BE A SYMBOL
	BSBW	DCL$COMPSTRING		;YES, COMPRESS STRING BEFORE COPYING
	BRB	30$			;COPY STRING

25$:	PUSHR	#^M<R0,R3,R4>		;SAVE SYMBOL DESCRIPTOR AND STATUS
	BSBW	DCL$SYM_STRING		;EVALUATE SYMBOL
	POPR	#^M<R0,R3,R4>		;RESTORE SYMBOL DESCRIPTOR AND STATUS
	TSTL	R1			;SYMBOL DEFINED?
	BEQL	60$			;NO, REPORT SYMBOL NOT FOUND

30$:	DECL	R1			;ANY MORE CHARACTERS TO MOVE?
	BLSS	40$			;IF LSS NO
	CMPL	R7,R8			;ANY ROOM IN OUTPUT BUFFER?
	BEQL	90$			;IF EQL NO
	MOVB	(R2)+,(R7)+		;MOVE CHARACTER TO OUTPUT BUFFER
	BRB	30$			;
40$:	CMPL	#PTR_K_COMMA,R6		;ANY MORE PARAMETERS TO COLLECT?
	BEQL	10$			;IF EQL YES
	SUBL	RAB$L_RBF(R9),R7	;CALCULATE LENGTH OF OUTPUT RECORD
	MOVW	R7,RAB$W_RSZ(R9)	;SET LENGTH OF OUTPUT RECORD

	BISW	#PRC_M_DISABL,PRC_W_FLAGS(R11) ;DISABLE CONTROL Y/C AST'S
	BBC	#1,(R8),78$			;BRANCH IF NOT /UPDATE
;
; UPDATE RECORD
;
	$UPDATE	RAB=(R9)		;UPDATE RECORD
	MOVAB	MAXRECSIZE+4(SP),SP	;RESTORE THE STACK PTR
	RSB
;
; OUTPUT RECORD
;
78$:	;&&& This is a bug.  RAB$L_CTX is set to FAB$L_DEV for special PPF
	;&&& files like SYS$COMMAND, etc.
	CMPB	RAB$L_CTX+2(R9),#FAB$C_IDX ;ORG = ISAM?
	BNEQ	45$			;BRANCH IF NOT
	MOVB	#RAB$C_KEY,RAB$B_RAC(R9) ;IF ISAM, ALWAYS INSERT IN KEY ORDER
45$:	$PUT	RAB=(R9)		;OUTPUT RECORD
	MOVAB	MAXRECSIZE+4(SP),SP	;RESTORE THE STACK PTR
	RSB				;
 
;
; UNDEFINED SYMBOL
;
 
60$:	STATUS	UNDSYM			;SET UNDEFINED SYMBOL STATUS

90$:	MOVAB	MAXRECSIZE+4(SP),SP	;RESTORE THE STACK PTR
 
;
; CALCULATE ADDRESS OF DISPLAY SEGMENT AND CLEAR COMMAND IN EXECUTION
;
 
DSPXIT:	MOVL	R4,WRK_L_MARKPTR(R10)	;SET ADDRESS OF DISPLAY SEGMENT
	ADDL3	R3,R4,WRK_L_EXPANDPTR(R10) ;CALCULATE ENDING ADDRESS OF DISPLAY SEGMENT
	CLRBIT	WRK_V_COMMAND,WRK_W_FLAGS(R10) ;DISPLAY ERROR TEXT WITH MESSAGE
	RSB				;

	.SBTTL	DCL$OPEN_CREATE - OPEN/CREATE FILE
;+
; DCL$OPEN_CREATE - OPEN/CREATE FILE
;
; THESE ROUTINES OPEN AN EXISTING FILE OR CREATE A NEW OUTPUT FILE
; GIVEN A FAB WHICH IS ALREADY SET UP TO CALL THE $OPEN OR $CREATE
; RMS SERVICES DIRECTLY.  IN ADDITION TO PERFORMING THE SPECIFIED
; RMS SERVICE THIS CODE PRODUCES GOOD ERROR MESSAGES.
;
; INPUTS:
;
;	R0 = FAB ADDRESS
;	R1 = FLAGS
;	     BIT 0 = 0 FOR OPEN
;		   = 1 FOR CREATE
;	     BIT 1 = 0 FOR NORMAL ERROR REPORTS IF ERROR
;		   = 1 IF NOT SUPPOSED TO ISSUE ERROR REPORT
;	     BIT 2 = 0 FOR NORMAL RESULT FILE SPEC PROCESSING
;		     1 IF RESULT STRING BUFFER IS ALREADY SPECIFIED
;	     BIT 3 = USED LOCALLY BY DCL$OPEN
;
;
; IMPLICIT INPUTS:
;
;	FAB$L_FNA AND FAB$B_FNS DESCRIBE THE FILE NAME STRING
;	FAB$L_NAM POINTS TO A NAME BLOCK
;	THE NAME BLOCK IN TURN HAS NO RESULT STRING OR EXPANDED STRING
;	ADDRESS SET UP
;
; OUTPUTS:
;
;	R0 = STATUS - IF ERROR, INIHIBIT MSG BIT IS SET
;	R1 ALTERED
;	ALL OTHER REGISTERS PRESERVED
;
;-
DCL$OPEN_CREATE::
	PUSHR	#^M<R2,R3,R4>		;SAVE SOME REGISTERS
	MOVQ	R0,R2			;R2=FAB ADR
					;R3=OPEN/CREATE, ERR REPORT FLAGS
	MOVL	FAB$L_NAM(R2),R4	;NAME BLOCK ADDRESS
	BBS	#2,R3,10$		;BRANCH IF ESA/RSA ALREADY SPECIFIED
	MOVAL	-<<NAM$C_MAXRSS+3>&^C<3>>(SP),SP ;RESERVE NAME STRING BUFFER
	MOVL	SP,NAM$L_RSA(R4)	;SET RESULT NAME STRING ADDRESS
	MOVL	SP,NAM$L_ESA(R4)	;SET EXPANDED NAME STRING ADDRESS
	ASSUME	NAM$B_RSS+1 EQ NAM$B_RSL
	MOVZBW	#NAM$C_MAXRSS,NAM$B_RSS(R4) ;RESULT STRING BUFFER SIZE
					;ZERO RESULT STRING LENGTH
	ASSUME	NAM$B_ESS+1 EQ NAM$B_ESL
	MOVZBW	#NAM$C_MAXRSS,NAM$B_ESS(R4) ;EXPANDED STRING BUFFER SIZE
					;ZERO EXPANDED STRING LENGTH
10$:	BLBS	R3,20$			;BRANCH IF CREATE FUNCTION
	$OPEN	(R2)			;OPEN THE FILE
	BRB	30$
20$:	$CREATE	(R2)			;CREATE THE FILE
30$:	BLBS	R0,80$			;BRANCH IF SUCCESSFUL
;
; ERROR OPENING OR CREATING THE FILE
;
	PUSHL	NAM$L_RSA(R4)		;ADDRESS OF RESULT NAME STRING
	MOVZBL	NAM$B_RSL(R4),-(SP)	;RESULT STRING SIZE
	BNEQ	50$			;BRANCH IF THERE WAS A RESULT STRING
	MOVZBL	NAM$B_ESL(R4),(SP)	;EXPANDED NAME STRING SIZE
	BNEQ	50$			;BRANCH IF THERE WAS AN EXPANDED NAME STRING
	MOVL	FAB$L_FNA(R2),4(SP)	;USE ORIGINAL FILE NAME, SET ADR
	MOVZBL	FAB$B_FNS(R2),(SP)	;SIZE OF ORIGINAL NAME
;
; NOW BUILD THE PUTMSG PARAMETER LIST
;
50$:	PUSHL	FAB$L_STV(R2)		;STV FOR THE RMS ERROR CODE
	PUSHL	R0			;RMS ERROR CODE
	PUSHAQ	8(SP)			;ADDRESS OF FILE NAME STRING DESCRIPTOR
	PUSHL	#1			;FAO ARGUMENT COUNT
	MOVW	#<CLI$_NORMAL & STS$M_FAC_NO>@-16,-(SP) ;PUT IN CLI FACILITY CODE
	MOVW	#<<SHR$_OPENIN & ^C<STS$M_SEVERITY>> ! -
		<STS$K_ERROR @ STS$V_SEVERITY>>,-(SP) ;ASSUME FUNCTION IS OPEN
	BLBC	R3,60$			;BRANCH IF IT IS OPEN
	MOVW	#<<SHR$_OPENOUT & ^C<STS$M_SEVERITY>> ! -
		<STS$K_ERROR @ STS$V_SEVERITY>>,(SP) ;IT WAS A CREATE
60$:	PUSHL	#5			;NUMBER OF PARAMETERS TO PUTMSG
	BBS	#1,R3,70$		;BRANCH IF NOT REPORTING ERROR
	MOVL	SP,R0			;ADDRESS OF PUTMSG PARAMETER LIST
	BSBW	DCL$PUTMSG		;DO THE PUTMSG CALL
70$:	BISL3	#STS$M_INHIB_MSG,16(SP),R0 ;RECOVER THE OPEN ERROR CODE (STS)
					;AND SET THE INHIBIT MESSAGE FLAG
	ADDL	#<6*4+8>,SP		;CLEAN OFF THE PUTMSG ARG LIST
					;AND THE FILE NAME DESCRIPTOR
80$:	BBS	#2,R3,90$		;BRANCH IF ESA/RSA ALREADY SPECIFIED
	MOVAL	<<NAM$C_MAXRSS+3>&^C<3>>(SP),SP ;NAME STRING SIZE TO RESERVE
	ASSUME	NAM$B_RSS+1 EQ NAM$B_RSL
	CLRW	NAM$B_RSS(R4)		;CLEAN UP THE NAME BLOCK
	ASSUME	NAM$B_ESS+1 EQ NAM$B_ESL
	CLRW	NAM$B_ESS(R4)		;NAME STRINGS ARE NOT VALID
90$:	POPR	#^M<R2,R3,R4>		;RESTORE SAVED REGISTERS
	RSB

	.SBTTL	LOCAL SUBROUTINES
;+
; CHECKPPF - CHECK FOR PROCESS PERMANENT FILE
;
; THIS ROUTINE IS CALLED TO CHECK IF AN ISI VALUE IS FOR A PROCESS PERMANENT FILE.
;
; INPUTS:
;
;	R6 = ISI VALUE.
;
; OUTPUTS:
;
;	Z = 0 IF NOT PROCESS PERMANENT FILE.
;
;	Z = 1 IF PROCESS PERMANENT FILE WITH:
;
;		R5 = ADDRESS OF ASSOCIATED RAB.
;-
 
CHECKPPF:				;CHECK FOR PROCESS PERMANENT FILE
	MOVL	PRC_L_STACKPT(R11),R1	;GET CURRENT INDIRECT STACK POINTER
	MOVL	PRC_L_INDINPRAB(R11),R5	;GET ADDRESS OF CURRENT INPUT RAB
	CMPW	R6,IDF_W_INPIFI(R1)	;IFI MATCH?
	BEQL	10$			;IF EQL YES
	MOVL	PRC_L_INDOUTRAB(R11),R5	;GET ADDRESS OF CURRENT OUTPUT RAB
	CMPW	R6,IDF_W_OUTIFI(R1)	;IFI MATCH?
	BEQL	10$			;IF EQL YES
4$:
	TSTL	IDF_L_LNK(R1)		;AT OUTER COMMAND LEVEL?
	BEQL	6$
	MOVL	IDF_L_LNK(R1),R1	;POINT BACK ONE LEVEL
	BRB	4$
6$:
	MOVL	PRC_L_INPRAB(R11),R5	;GET LEVEL-0 (SYS$COMMAND) INPUT RAB
	CMPW	R6,IDF_W_INPIFI(R1)	;IFI MATCH?
	BEQL	10$			;IF EQL YES
	MOVL	PRC_L_OUTRAB(R11),R5	;GET LEVEL-0 OUTPUT RAB
	CMPW	R6,PRC_W_OUTIFI(R11)	;IFI MATCH?
10$:	RSB				;

;+
; GETID - GET FILE ID
;
; THIS ROUTINE IS CALLED TO CONVERT THE FILE IDENTIFIER TO BINARY AND SEARCH THE
; FILE DESCRIPTOR LIST FOR A MATCH.
;
; INPUTS:
;
;	NONE
;
; OUTPUTS:
;
;	R0 LOW BIT CLEAR INDICATES FAILURE TO FIND SPECIFIED FILE ID.
;
;	R0 LOW BIT SET INDICATES SUCCESSFUL FILE DESCRIPTOR LIST SEARCH WITH:
;
;		R3 = LENGTH OF LOCIAL FILE NAME.
;		R4 = ADDRESS OF LOGICAL FILE NAME.
;		R5 = ADDRESS OF FILE DESCRIPTOR BLOCK.
;		R6 = FILE IDENTIFICATION NUMBER.
;		R7 = ADDRESS OF PREVIOUS FILE DESCRIPTOR.
;		R9 = ADDRESS OF ASSOCIATED RAB.
;
;	WRK_L_RSLNXT IS SET TO THE NEXT PARAMETER AFTER THE FILE ID.
;-
 
GETID:					;GET FILE ID
	MOVAB	WRK_G_RESULT(R10),WRK_L_RSLNXT(R10) ;RELOAD RESULT DESCRIPTOR POINTER
10$:	BSBW	DCL$GETDVAL		;GET DESCRIPTOR VALUES
	CMPL	#PTR_K_PARAMETR,R5	;PARAMETER DESCRIPTOR?
	BNEQ	10$			;IF NEQ NO
	MOVQ	R1,R3			;SAVE LOGICAL FILE PARAMETERS
	MOVQ	R1,-(SP)		;BUILD LOGICAL NAME DESCRIPTOR
	MOVL	SP,R5			;SAVE ADDRESS OF LOGICAL NAME DESCRIPTOR
	MOVZBL	#LNM$C_NAMLENGTH,R6	;GET MAXIMUM LENGTH OF LOGICAL NAME
	SUBL	R6,SP			;ALLOCATE LOGICAL NAME TRANSLATION BUFFER
	PUSHAB	(SP)			;BUILD TRANSLATION BUFFER DESCRIPTOR
	PUSHL	R6			;
	MOVL	SP,R6			;SAVE ADDRESS OF BUFFER DESCRIPTOR
	MOVL	#10,R2			;SET MAXIMUM LOOP COUNT
20$:	$TRNLOG_S (R5),(R5),(R6)	;TRANSLATE LOGICAL NAME
	CMPW	S^#SS$_NORMAL,R0	;NORMAL COMPLETION?
	BNEQ	80$			;IF NEQ NO
	CMPW	#4,(R5)			;TRANSLATED NAME LARGE ENOUGH?
	BGTRU	30$			;IF GTRU NO
	CMPW	#ESCAPE,8(R6)		;PROCESS PERMANENT FILE IFI?
	BEQL	40$			;IF EQL YES
30$:	MOVL	4(R6),4(R5)		;SET FOR NEXT TRANSLATION
	SOBGTR	R2,20$			;ANY MORE TANSLATIONS LEFT?
	BRB	80$			;
40$:	MOVW	10(R6),R6		;GET INTERNAL FILE INDEX
	MOVAB	LNM$C_NAMLENGTH+8+8(SP),SP ;REMOVE LOGICAL NAMES FROM STACK
	BSBW	CHECKPPF		;CHECK IF PROCESS PERMANENT FILE
	BEQL	70$			;IF EQL YES
	MOVAB	PRC_L_PPFLIST(R11),R7	;GET ADDRESS OF PREVIOUS FILE DESCRIPTOR
50$:	MOVL	(R7),R5			;GET ADDRESS OF NEXT FILE DESCRIPTOR
	BEQL	85$			;IF EQL END OF LIST
	CMPW	R6,RAB$L_CTX+4(R5)	;FILE IDENTIFICATION MATCH?
	BEQL	60$			;IF EQL YES
	MOVL	R5,R7			;SAVE ADDRESS OF PREVIOUS ENTRY
	BRB	50$			;
60$:	TSTL	(R5)+			;POINT TO ACTUAL RAB
70$:	MOVL	R5,R9			;SET ADDRESS OF ASSOCIATED RAB
	STATUS	NORMAL			;SET NORMAL COMPLETION STATUS
	BRB	90$			;
 
;
; FILE IDENTIFICATION NOT FOUND
;
 
80$:	MOVAB	LNM$C_NAMLENGTH+8+8(SP),SP ;REMOVE LOGICAL NAMES FROM STACK
85$:	STATUS	UNDFIL			;SET UNDEFINED FILE STATUS
 
;
; CALL THE CALLER BACK AS A CO-ROUTINE SO THAT /END= AND /ERR= QUALIFIERS CAN BE
; PROCESSED IN ONE PLACE.
;
 
90$:	JSB	@(SP)+			;CALL CALLER BACK
	BLBS	R0,110$			;IF LBS SUCCESSFUL COMPLETION
	MOVZBL	#CLI$K_OPEN_END_,R7	;ASSUME END OF FILE
	CMPL	#RMS$_EOF,R0		;END OF FILE?
	BNEQ	100$			;IF NEQ NO
	BSBB	LABEL_CHECK		;CHECK FOR END OF FILE LABEL
100$:	MOVZBL	#CLI$K_OPEN_ERRO,R7	;SET FOR ERROR
	BSBB	LABEL_CHECK		;CHECK FOR ERROR LABEL
	BBCC	#WRK_V_CLOSERR,WRK_W_FLAGS2(R10),110$  ;SKIP IF /L0G
	STATUS	NORMAL			;OTHER SUPPRESS ERROR MESSAGE
110$:	RSB				;

;+
; LABEL_CHECK - CHECK FOR LABEL
;
; THIS ROUTINE IS CALLED TO SCAN THE COMMAND LEVEL QUALIFIERS FOR AN /ERROR=
; OF /END_OF_FILE= QUALIFIER.
;
; INPUTS:
;
;	R7 = TYPE OF QUALIFIER TO SCAN FOR.
;	R8 = SAVED FINAL STATUS VALUE.
;
; OUTPUTS:
;
;	THE RESULT PARSE TABLE IS SCANNED FOR A QUALIFIER TYPE MATCH. IF A MATCH
;	IS FOUND, THEN A GOTO THE SPECIFIED LABEL IS EXECUTED. ELSE A RETURN TO
;	THE CALLER IS EXECUTED.
;-
 
LABEL_CHECK:				;CHECK LABEL
	MOVAB	WRK_G_RESULT(R10),WRK_L_RSLNXT(R10) ;RELOAD RESULT DESCRIPTOR POINTER
	MOVL	R0,R8			;SAVE FINAL STATUS VALUE
10$:	BSBW	DCL$GETDVAL		;GET NEXT DESCRIPTOR VALUES
	CMPL	#PTR_K_ENDLINE,R5	;END OF DESCRIPTORS?
	BEQL	20$			;IF EQL YES
	CMPL	#PTR_K_COMDQUAL,R5	;COMMAND QUALIFIER?
	BNEQ	10$			;IF NEQ NO
	BSBW	DCL$GETNVAL		;GET QUALIFIER NUMBER
	CMPL	R1,R7			;QUALIFIER TYPE MATCH?
	BNEQ	10$			;IF NEQ NO
	MOVL	R8,R0			;RESTORE ERROR STATUS CODE
	BSBW	DCL$SAVE_STATUS		;SET INTO $STATUS
	TSTL	(SP)+			;REMOVE RETURN FROM STACK
	BRW	DCL$GOTO		;EXECUTE GOTO
20$:	MOVL	R8,R0			;RESTORE FINAL STATUS
	RSB				;
 
	.END
