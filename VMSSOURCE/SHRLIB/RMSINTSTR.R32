! 
! ****************************************************************************
! *									    *
! *  Copyright (c) 1982, 1983		                                    *
! *  by DIGITAL Equipment Corporation, Maynard, Mass.			    *
! * 									    *
! *  This software is furnished under a license and may be used and  copied  *
! *  only  in  accordance  with  the  terms  of  such  license and with the  *
! *  inclusion of the above copyright notice.  This software or  any  other  *
! *  copies  thereof may not be provided or otherwise made available to any  *
! *  other person.  No title to and ownership of  the  software  is  hereby  *
! *  transferred.							    *
! * 									    *
! *  The information in this software is subject to change  without  notice  *
! *  and  should  not  be  construed  as  a commitment by DIGITAL Equipment  *
! *  Corporation.							    *
! * 									    *
! *  DIGITAL assumes no responsibility for the use or  reliability  of  its  *
! *  software on equipment which is not supplied by DIGITAL.		    *
! *									    *
! ****************************************************************************
! *********************************************************************************************************************************
!  Created 15-SEP-1984 22:54:35  by  VAX-11 SDL V2.0       Source: 15-SEP-1984 22:49:24 _$255$DUA28:[RMS.SRC]RMSINTSTR.SDL;1       
! *********************************************************************************************************************************
 
 
!*** MODULE $IFBDEF ***
! 
!   NOTE:  The fields thru JNLBDB inclusive are common between the ifb and irb
! 
literal IFB$C_BID = 11;                 !  ifab id code 
literal IFB$M_PUT = 1;
literal IFB$M_GET = 2;
literal IFB$M_DEL = 4;
literal IFB$M_UPD = 8;
literal IFB$M_TRN = 16;
literal IFB$M_BIO = 32;
literal IFB$M_BRO = 64;
literal IFB$M_EXE = 128;
literal IFB$C_SEQ = 0;                  !  sequential 
literal IFB$C_REL = 1;                  !  relative 
literal IFB$C_IDX = 2;                  !  indexed 
literal IFB$C_DIR = 3;                  !  direct 
literal IFB$C_MAXORG = 2;               !  release 1.5 maximum 
literal IFB$K_FHAEND = 102;             !  end of file header attributes 
literal IFB$C_FHAEND = 102;             !  end of file header attributes 
literal IFB$C_KBUFNUM = 6;              !  constant - the number of key buffers allocated 
literal IFB$M_ONLY_RU = 1;
literal IFB$M_RU = 2;
literal IFB$M_BI = 4;
literal IFB$M_AI = 8;
literal IFB$M_AT = 16;
literal IFB$M_NEVER_RU = 32;
literal IFB$M_RU_RECVR = 1;
literal IFB$M_AI_RECVR = 2;
literal IFB$M_BI_RECVR = 4;
literal IFB$M_VALID_AT = 1;
literal IFB$M_JNL = 2;
literal IFB$M_RUP = 4;
literal IFB$M_RU_RLK = 8;
literal IFB$M_DONE_ASS_JNL = 16;
literal IFB$K_BLN_SEQ = 172;
literal IFB$C_BLN_SEQ = 172;
! --
! 
!   organization-dependent fields
! 
!   the following fields are used differently
!   depending upon the file's organization
! 
! ++
! 
!   relative org specific fields
! 
literal IFB$S_IFBDEF = 172;
!  (but have definitions that allow them to
!   be referenced from the start of the ifab)
! ++
!   the following bits are defined in
!   common with the irab
! 
macro IFB$V_BUSY = 4,0,1,0 %;           !  stream busy 
macro IFB$V_EOF = 4,1,1,0 %;            !  file positioned at eof 
macro IFB$V_PPF_IMAGE = 4,2,1,0 %;      !  flag for indirect processing of process- 
!  permanent files (restricts allowable operations)
macro IFB$V_ASYNC = 4,3,1,0 %;          !  async i/o flag (must be zero for ifab) 
macro IFB$V_ASYNCWAIT = 4,4,1,0 %;      !  wait on async i/o (must be zero for ifab) 
! --
! 
!   ifab specific bits
! 
macro IFB$V_ACCESSED = 4,5,1,0 %;       !  file is accessed 
macro IFB$V_ANSI_D = 4,6,1,0 %;         !  ansi d variable records 
macro IFB$V_RWC = 4,7,1,0 %;            !  copy of fop bit from open 
macro IFB$V_DMO = 4,8,1,0 %;            !  copy of fop bit from open 
macro IFB$V_SPL = 4,9,1,0 %;            !  copy of fop bit from open 
macro IFB$V_SCF = 4,10,1,0 %;           !  copy of fop bit from open 
macro IFB$V_DLT = 4,11,1,0 %;           !  copy of fop bit from open 
macro IFB$V_DFW = 4,12,1,0 %;           !  deferred write (copy of fop bit from $open) 
macro IFB$V_SQO = 4,13,1,0 %;           !  sequential operations only 
macro IFB$V_PPF_INPUT = 4,14,1,0 %;     !  this is command 'input' stream 
macro IFB$V_NFS = 4,15,1,0 %;           !  non-file structured flag 
macro IFB$V_WRTACC = 4,16,1,0 %;        !  logical or of fac bits: 
!    put, upd, del, trn
macro IFB$V_MSE = 4,17,1,0 %;           !  multi-streams enabled 
macro IFB$V_CREATE = 4,18,1,0 %;        !  set if doing create (may be "create if") 
macro IFB$V_NORECLK = 4,19,1,0 %;       !  record locking not required 
!  (i.e., no shared access or multi-stream)
macro IFB$V_RW_ATTR = 4,20,1,0 %;       !  set if file attributes must be re-written 
macro IFB$V_TMP = 4,21,1,0 %;           !  temporary file (i.e., no directory entry) 
macro IFB$V_TEF = 4,22,1,0 %;           !  truncate at eof due to large auto extend 
macro IFB$V_STALL_LOCK = 4,23,1,0 %;    !  RMS is stalled for file lock 
macro IFB$V_SEQFIL = 4,24,1,0 %;        !  this is really a sequential file being shared 
macro IFB$V_SEARCH = 4,25,1,0 %;        !  search ifab - left during wildcard operations 
macro IFB$V_RMS_STALL = 4,26,1,0 %;     !  RMS is stalled on this file operation 
macro IFB$V_RESTART = 4,27,1,0 %;       !  Reopen or recreate operation in progress 
macro IFB$V_FILEFOUND = 4,28,1,0 %;     !  A file was found on a search operation 
macro IFB$V_DAP_OPEN = 4,29,1,0 %;      !  open/create function was performed via dap 
macro IFB$V_DAP = 4,30,1,0 %;           !  data access protocol transmission 
macro IFB$V_NSP = 4,31,1,0 %;           !  network services protocol transmission 
macro IFB$L_PRIM_DEV = 0,0,32,0 %;      !  device characteristics bits 
!  (for primary device - bit encoding same as for fab)
macro IFB$L_BKPBITS = 4,0,32,0 %;       !  bookkeeping bits 
! 
macro IFB$B_BID = 8,0,8,0 %;            !  block id 
macro IFB$B_BLN = 9,0,8,0 %;            !  block length in longwords 
macro IFB$B_MODE = 10,0,8,0 %;          !  caller's mode 
macro IFB$B_EFN = 11,0,8,0 %;           !  event flag used for synchronous qio 
macro IFB$L_IOS = 12,0,32,0 %;          !  internal i/o status block 
macro IFB$L_BWB = 12,0,32,0 %;          !  bucket wait block for inter stream waiting 
macro IFB$W_IOS2 = 14,0,16,0 %;         !  high word of io status block 
macro IFB$L_IOS4 = 16,0,32,0 %;         !  2nd longword of io status block 
macro IFB$L_ASBADDR = 20,0,32,0 %;      !  address of asynchronous context block 
macro IFB$L_ARGLST = 24,0,32,0 %;       !  user call parameters addr 
macro IFB$L_IRAB_LNK = 28,0,32,0 %;     !  pointer to irab(s) 
macro IFB$W_CHNL = 32,0,16,0 %;         !  i/o channel number 
macro IFB$B_FAC = 34,0,8,0 %;           !  file access 
macro IFB$V_PUT = 34,0,1,0 %;           !  (same as in fab's fac field) 
macro IFB$V_GET = 34,1,1,0 %;
macro IFB$V_DEL = 34,2,1,0 %;
macro IFB$V_UPD = 34,3,1,0 %;
macro IFB$V_TRN = 34,4,1,0 %;
macro IFB$V_BIO = 34,5,1,0 %;
macro IFB$V_BRO = 34,6,1,0 %;
macro IFB$V_EXE = 34,7,1,0 %;
!  note: if both bio and bro set, implies block i/o
!         access only allowed for this connect, resets
!         to bro on disconnect (seq. file org. only).
! 
macro IFB$B_ORGCASE = 35,0,8,0 %;       !  copy of org for case dispatching 
macro IFB$L_LAST_FAB = 36,0,32,0 %;     !  address of fab for last operation 
macro IFB$W_IFI = 40,0,16,0 %;          !  Internal file Identifier, the one we gave to the user 
macro IFB$W_ECHO_ISI = 42,0,16,0 %;     !  ISI of stream to echo records from SYS$INPUT 
macro IFB$L_ATJNLBUF = 44,0,32,0 %;     !  address of IFAB audit trail buffer 
macro IFB$L_JNLBDB = 48,0,32,0 %;       !  address of Journaling BDB for FAB operations 
! -----*****
macro IFB$L_EXTJNLBUF = 52,0,32,0 %;    !  pointer to buffer to contain extend journal record 
macro IFB$L_FWA_PTR = 56,0,32,0 %;      !  pointer to file work area control block 
macro IFB$L_NWA_PTR = 60,0,32,0 %;      !  pointer to network work area control block 
macro IFB$L_BDB_FLNK = 64,0,32,0 %;     !  pointer to bdb(s) 
macro IFB$L_BDB_BLNK = 68,0,32,0 %;     !  bdb backward link 
macro IFB$L_DEVBUFSIZ = 72,0,32,0 %;    !  device default (or bls if mt) buff size 
macro IFB$W_RTDEQ = 76,0,16,0 %;        !  run-time default extend quantity 
macro IFB$B_SHR = 78,0,8,0 %;           !  File sharing bits from users FAB 
macro IFB$B_AGENT_MODE = 79,0,8,0 %;    !  User's FAB$V_FILE_MODE field, maximized with mode of caller
! 
! +++++*****
! 
!   the following fields must remain as is since
!   they correspond to the rms attributes stored
!   in the file header
! 
macro IFB$B_RFMORG = 80,0,8,0 %;        !  organization and record format 
macro IFB$V_RFM = 80,0,4,0 %;
literal IFB$S_RFM = 4;                  !  record format (n.b. constant values defined in rfm field of fab) 
macro IFB$V_ORG = 80,4,4,0 %;
literal IFB$S_ORG = 4;                  !  file organization 
macro IFB$B_RAT = 81,0,8,0 %;           !  record attributes (n.b. bit offsets defined in rat field of fab) 
macro IFB$W_LRL = 82,0,16,0 %;          !  longest record's length (or fixed record length) 
macro IFB$L_HBK_DISK = 84,0,32,0 %;     !  hi vbn allocated (note: disk format!) 
macro IFB$L_EBK_DISK = 88,0,32,0 %;     !  eof vbn (note: disk format!) 
macro IFB$W_FFB = 92,0,16,0 %;          !  first free byte in eof block 
macro IFB$B_BKS = 94,0,8,0 %;           !  bucket size (! vbns) 
macro IFB$B_FSZ = 95,0,8,0 %;           !  record header size for vfc 
macro IFB$W_MRS = 96,0,16,0 %;          !  max record size allowable 
macro IFB$W_DEQ = 98,0,16,0 %;          !  default extend quantity 
macro IFB$W_GBC = 100,0,16,0 %;         !  global buffer count 
! -----*****
macro IFB$B_DRT_REHIT = 104,0,8,0 %;    !  hit count for local dirty buffers. 
macro IFB$B_GBL_REHIT = 105,0,8,0 %;    !  rehit count for gbl buffers. 
macro IFB$L_RNS_LEN = 108,0,32,0 %;     !  resultant name string length (used as a temp field by $search) 
macro IFB$L_LOCK_BDB = 108,0,32,0 %;    !  lock bdb address (used by $extend for rel. file) 
macro IFB$L_HBK = 112,0,32,0 %;         !  hi vbn allocated. 
macro IFB$L_EBK = 116,0,32,0 %;         !  eof vbn. 
macro IFB$L_SFSB_PTR = 120,0,32,0 %;    !  pointer to shared file synchronization block 
macro IFB$L_GBSB_PTR = 124,0,32,0 %;    !  pointer to global buffer synchronization block. 
macro IFB$L_PAR_LOCK_ID = 128,0,32,0 %; !  Parent lock ID for bucket locks (get from SFSB.) 
macro IFB$W_AVLCL = 132,0,16,0 %;       !  local buffers available. 
macro IFB$W_AVGBPB = 134,0,16,0 %;      !  gbl ptr blocks available. 
macro IFB$L_GBH_PTR = 136,0,32,0 %;     !  pointer to global header. 
macro IFB$L_AS_DEV = 140,0,32,0 %;      !  assigned device characteristics 
!                 AS_DEV and ASDEVBSIZ *)
macro IFB$L_ASDEVBSIZ = 148,0,32,0 %;   !  assigned device buffer size 
macro IFB$L_BLBFLNK = 152,0,32,0 %;     !  Forward link to BLB chain. 
macro IFB$L_BLBBLNK = 156,0,32,0 %;     !  Back link to BLB chain. 
macro IFB$B_JNLFLG = 160,0,8,0 %;       !  journaling attribute flags 
macro IFB$V_ONLY_RU = 160,0,1,0 %;      !  Recovery Unit journaling, no access outside RU 
macro IFB$V_RU = 160,1,1,0 %;           !  Recovery Unit journaling 
macro IFB$V_BI = 160,2,1,0 %;           !  Before Image journaling 
macro IFB$V_AI = 160,3,1,0 %;           !  After Image jouraling 
macro IFB$V_AT = 160,4,1,0 %;           !  Audit Trail journaling 
macro IFB$V_NEVER_RU = 160,5,1,0 %;     !  never do RU journaling 
macro IFB$B_RECVRFLGS = 161,0,8,0 %;    !  Recovery flags 
macro IFB$V_RU_RECVR = 161,0,1,0 %;     !  Recovery Unit Rollback in progress 
macro IFB$V_AI_RECVR = 161,1,1,0 %;     !  AI Roll Forward Recovery in progress 
macro IFB$V_BI_RECVR = 161,2,1,0 %;     !  BI Roll Backward Recovery in progress 
macro IFB$B_JNLFLG2 = 162,0,8,0 %;      !  Secondary journaling flags (generally operation specific) 
macro IFB$V_VALID_AT = 162,0,1,0 %;     !  AT entry in IFB buffer is valid and should be written 
macro IFB$V_JNL = 162,1,1,0 %;          !  Journaling Initialized for this file 
macro IFB$V_RUP = 162,2,1,0 %;          !  Recovery Unit in progress 
macro IFB$V_RU_RLK = 162,3,1,0 %;       !  Fake record locking during recovery unit 
macro IFB$V_DONE_ASS_JNL = 162,4,1,0 %; !  Journal channels already assigned 
macro IFB$L_RJB = 164,0,32,0 %;         !  RMS Journaling Block address 
macro IFB$W_BUFFER_OFFSET = 168,0,16,0 %; !  ANSI buffer offset
literal IFB$K_BLN_REL = 180;
literal IFB$C_BLN_REL = 180;
! --
! ++
! 
!   indexed org specific fields
! 
literal IFB$S_IFBDEF1 = 180;
macro IFB$L_MRN = 172,0,32,0 %;         !  (rel) max record number 
macro IFB$L_DVBN = 176,0,32,0 %;        !  (rel) first data bucket vbn 
literal IFB$K_BLN_IDX = 184;
literal IFB$C_BLN_IDX = 184;
literal IFB$K_BLN = 184;                !  ifab length 
literal IFB$C_BLN = 184;                !  ifab length 
! --
literal IFB$S_IFBDEF2 = 184;
macro IFB$L_IDX_PTR = 172,0,32,0 %;     !  (idx) pointer to primary key index descriptor 
macro IFB$B_AVBN = 176,0,8,0 %;         !  (idx) vbn of 1st area descriptor 
macro IFB$B_AMAX = 177,0,8,0 %;         !  (idx) total number of area descriptors 
macro IFB$B_NUM_KEYS = 178,0,8,0 %;     !  (idx) ! of keys in file 
macro IFB$B_UBUFSZ = 179,0,8,0 %;       !  (idx) update buffer size for keys 
macro IFB$W_KBUFSZ = 180,0,16,0 %;      !  (idx) key buffer size 
macro IFB$B_EXTRABUF = 182,0,8,0 %;     !  (idx) number of extra buffers for 'cache'ing 
macro IFB$B_PLG_VER = 183,0,8,0 %;      !  (idx) prologue version number 
 
!*** MODULE $IRBDEF ***
! 
!         IRB field definitions
! 
!         Internal rab (irb)
! 
!         There is 1 irab per connected record access stream
! 
! 
!   NOTE: The fields thru JNLBDB inclusive are common between the irb and ifb
! 
literal IRB$C_BID = 10;                 !  irab code 
literal IRB$M_POSINSERT = 1;
literal IRB$M_SRCHGT = 2;
literal IRB$M_POSDELETE = 4;
literal IRB$M_NEW_IDX = 8;
literal IRB$M_SRCHGE = 16;
literal IRB$M_NORLS_RNF = 32;
literal IRB$M_FIRST_TIM = 64;
literal IRB$M_PRM = 128;
literal IRB$M_DUP_KEY = 256;
literal IRB$M_DEL_SEEN = 512;
literal IRB$M_LAST_GT = 1024;
literal IRB$M_BKT_NO_LO = 1;
literal IRB$M_NEW_BKTS = 6;
literal IRB$M_REC_W_LO = 8;
literal IRB$M_CONT_BKT = 16;
literal IRB$M_CONT_R = 32;
literal IRB$M_EMPTY_BKT = 64;
literal IRB$M_DUPS_SEEN = 128;
literal IRB$M_BKT_NO = 3;
literal IRB$M_BIG_SPLIT = 4;
literal IRB$M_SPL_IDX = 1;
literal IRB$M_EMPT_SEEN = 2;
literal IRB$M_VALID_AT = 1;
literal IRB$K_BLN_REL = 100;
literal IRB$C_BLN_REL = 100;
! ++
! 
!   sequential org specific fields
! 
literal IRB$K_BLN_SEQ = 108;
literal IRB$C_BLN_SEQ = 108;
literal IRB$S_IRBDEF = 108;
!  to apply from start of irab
! ++
! 
!   the following bits are defined in common
!   with the ifab
! 
macro IRB$V_BUSY = 4,0,1,0 %;           !  file busy 
macro IRB$V_EOF = 4,1,1,0 %;            !  stream positioned at eof 
macro IRB$V_PPF_IMAGE = 4,2,1,0 %;      !  flag for indirect processing of process- 
!  permanent file
macro IRB$V_ASYNC = 4,3,1,0 %;          !  asynchronous i/o request 
macro IRB$V_ASYNCWAIT = 4,4,1,0 %;      !  $wait issued for asynchronous i/o request 
! --
! 
!    irab specific bits
! 
macro IRB$V_FIND_LAST = 4,5,1,0 %;      !  last operation was a find 
macro IRB$V_PUTS_LAST = 4,6,1,0 %;      !  last operation was a put sequential 
macro IRB$V_BIO_LAST = 4,7,1,0 %;       !  this/last operation is/was a block i/o operation 
!  note: this bit is set only if mixed block and record
!        operations (bro access).  after call to rm$rset
!         refers to the current operation and bro_sw gives
!         type of last operation.
macro IRB$V_BRO_SW = 4,8,1,0 %;         !  switched from record operation to block i/o operation 
macro IRB$V_FIND = 4,9,1,0 %;           !  operation is a find 
macro IRB$V_RAHWBH = 4,10,1,0 %;        !  read ahead or write behind processing 
macro IRB$V_SKIP_NEXT = 4,11,1,0 %;     !  skip to next record flag for index fo 
macro IRB$V_DUP = 4,12,1,0 %;           !  duplicate records seen 
macro IRB$V_UNLOCK_RP = 4,13,1,0 %;     !  release lock on current (rp) record 
macro IRB$V_PPF_EOF = 4,14,1,0 %;       !  give one-shot rms$_eof error on sys$input 
macro IRB$V_PPF_SKIP = 4,15,1,0 %;      !  skip sys$input record ($deck), redoing $get 
!  or $find on next record
macro IRB$V_PPF_FNDSV = 4,16,1,0 %;     !  save value for find bit when ppf_skip set 
macro IRB$V_IDX_ERR = 4,17,1,0 %;       !  index update error occurred 
macro IRB$V_RRV_ERR = 4,18,1,0 %;       !  rrv update error occurred 
macro IRB$V_UPDATE = 4,19,1,0 %;        !  operation is an update (indexed) 
macro IRB$V_UPDATE_IF = 4,20,1,0 %;     !  operation was a $PUT -> $UPDATE 
macro IRB$V_ABOVELCKD = 4,21,1,0 %;     !  level above was locked by search_tree 
macro IRB$V_GBLBUFF = 4,22,1,0 %;       !  global buffers are in use. 
macro IRB$V_CON_EOF = 4,23,1,0 %;       !  file positioned at EOF by $CONNECT (isam) 
macro IRB$V_NO_Q_WAIT = 4,24,1,0 %;     !  do not wait for enqueues on query_locks 
macro IRB$V_PPF_ECHO = 4,25,1,0 %;      !  echo SYS$INPUT records to SYS$OUTPUT 
macro IRB$V_RMS_STALL = 4,26,1,0 %;     !  RMS is stalled on this record operation 
macro IRB$V_RESTART = 4,27,1,0 %;       !  Reconnect operation in progress 
macro IRB$V_DAP_CONN = 4,28,1,0 %;      !  connect function was performed via dap 
macro IRB$V_RU_DELETE = 4,29,1,0 %;     !  recovery unit deletion in progress 
macro IRB$V_RU_UNDEL = 4,30,1,0 %;      !  recovery unit un-deletion in progress 
macro IRB$V_RU_UPDATE = 4,31,1,0 %;     !  place new record is special RU UPDATE format 
! 
!   the following are alternate definitions for alternate
!   (non-conflicting) use of the above bits
! 
macro IRB$V_WRITE = 4,9,1,0 %;          !  operation is a write 
macro IRB$L_IFAB_LNK = 0,0,32,0 %;      !  pointer to ifab 
macro IRB$L_BKPBITS = 4,0,32,0 %;       !  bookkeeping status bits 
! 
macro IRB$B_BID = 8,0,8,0 %;            !  block id 
macro IRB$B_BLN = 9,0,8,0 %;            !  block length in longwords 
macro IRB$B_MODE = 10,0,8,0 %;          !  caller's mode 
macro IRB$B_EFN = 11,0,8,0 %;           !  event flag for synchronous io 
macro IRB$L_IOS = 12,0,32,0 %;          !  internal i/o status block 
macro IRB$L_BWB = 12,0,32,0 %;          !  bucket wait block for inter stream locking 
macro IRB$W_IOS2 = 14,0,16,0 %;         !  high word of io status block 
macro IRB$L_IOS4 = 16,0,32,0 %;         !  io status block (2nd longword) 
macro IRB$L_ASBADDR = 20,0,32,0 %;      !  address of permanent asynchronous context block 
macro IRB$L_ARGLST = 24,0,32,0 %;       !  user arg list address 
!  if async, points to copy at head
!  of async context block
macro IRB$L_IRAB_LNK = 28,0,32,0 %;     !  pointer to next irab 
macro IRB$L_CURBDB = 32,0,32,0 %;       !  current bdb address 
macro IRB$L_LAST_RAB = 36,0,32,0 %;     !  address of rab for last operation 
macro IRB$W_ISI = 40,0,16,0 %;          !  Internal stream Identifier, the one we gave to the user 
macro IRB$L_ATJNLBUF = 44,0,32,0 %;     !  address of IRAB audit trail journaling buffer 
macro IRB$L_JNLBDB = 48,0,32,0 %;       !  address of journaling BDB for RAB operations 
! -----*****
macro IRB$L_IDENT = 52,0,32,0 %;        !  process unique identifier for the IRB 
macro IRB$L_RLB_LNK = 56,0,32,0 %;      !  pointer to RLBs 
macro IRB$L_NXTBDB = 60,0,32,0 %;       !  next bdb address 
macro IRB$L_NRP = 64,0,32,0 %;          !  next record pointer (relative record number) 
macro IRB$L_NRP_VBN = 64,0,32,0 %;      !  next record pointer (relative) 
macro IRB$B_CACHEFLGS = 64,0,8,0 %;     !  cacheflags for calls to getbkt,cache, etc. (indexed) 
macro IRB$B_STOPLEVEL = 65,0,8,0 %;     !  level to stop at on tree search (indexed) 
macro IRB$W_SRCHFLAGS = 66,0,16,0 %;    !  search flags (indexed) 
macro IRB$V_POSINSERT = 66,0,1,0 %;     !  position for insert 
macro IRB$V_SRCHGT = 66,1,1,0 %;        !  approximate search gt 
macro IRB$V_POSDELETE = 66,2,1,0 %;     !  position for delete 
macro IRB$V_NEW_IDX = 66,3,1,0 %;       !  need to read in new idx dsc from file 
macro IRB$V_SRCHGE = 66,4,1,0 %;        !  approximate search ge 
macro IRB$V_NORLS_RNF = 66,5,1,0 %;     !  don't release bkt on rnf error, if set 
macro IRB$V_FIRST_TIM = 66,6,1,0 %;     !  flag to indicate 1st time for seq. processing 
macro IRB$V_PRM = 66,7,1,0 %;           !  flag to indicate that the permanence bit in the bdb 
macro IRB$V_DUP_KEY = 66,8,1,0 %;       !  a duplicate key seen on scan of any data bucket 
macro IRB$V_DEL_SEEN = 66,9,1,0 %;      !  a deleted record has been encountered between current 
macro IRB$V_LAST_GT = 66,10,1,0 %;      !  result of last search of compressed key bucket was GT 
!  and a next record during a $GET/$FIND
!   should be set
macro IRB$L_NRP_OFF = 68,0,32,0 %;      !  next record pointer offset (relative) 
macro IRB$L_CURVBN = 68,0,32,0 %;       !  vbn of current record (relative) 
macro IRB$W_NRP_OFF = 68,0,16,0 %;      !  " 
macro IRB$B_SPL_BITS = 68,0,8,0 %;      !  bits for splitting (indexed) 
macro IRB$V_BKT_NO_LO = 68,0,1,0 %;     !  low bit of bucket number processing 
macro IRB$V_NEW_BKTS = 68,1,2,0 %;
literal IRB$S_NEW_BKTS = 2;             !  number of new buckets (0-3) 
macro IRB$V_REC_W_LO = 68,3,1,0 %;      !  if splitting at pos_insert than rec goes w/ lo 
macro IRB$V_CONT_BKT = 68,4,1,0 %;      !  middle bucket is a continuation bkt 
macro IRB$V_CONT_R = 68,5,1,0 %;        !  right bucket is a continuation bkt 
macro IRB$V_EMPTY_BKT = 68,6,1,0 %;     !  bucket contains no data records 
macro IRB$V_DUPS_SEEN = 68,7,1,0 %;     !  dups seen on scan of bucket, any key 
macro IRB$V_BKT_NO = 68,0,2,0 %;
literal IRB$S_BKT_NO = 2;
macro IRB$V_BIG_SPLIT = 68,2,1,0 %;
macro IRB$V_SPL_IDX = 68,0,1,0 %;       !  split up new index record and swing pointer 
macro IRB$V_EMPT_SEEN = 68,1,1,0 %;     !  empty bucket passed over on posinsert 
macro IRB$L_RP = 72,0,32,0 %;           !  record pointer (relative record !) 
macro IRB$L_RP_VBN = 72,0,32,0 %;       !  record pointer (relative) 
macro IRB$W_POS_INS = 72,0,16,0 %;      !  offset for position for insert for put (indexed) 
macro IRB$W_SPLIT = 74,0,16,0 %;        !  first split point (indexed) 
macro IRB$L_RP_OFF = 76,0,32,0 %;       !  record pointer offset 
macro IRB$L_LST_REC = 76,0,32,0 %;      !  last record address (indexed) 
macro IRB$L_PTR_VBN = 76,0,32,0 %;      !  pointer vbn used by find_by_rrv (indexed) 
macro IRB$W_RP_OFF = 76,0,16,0 %;       !  record pointer offset 
macro IRB$W_SPLIT_1 = 76,0,16,0 %;      !  second split point -- 3-bkt split (indexed) 
macro IRB$W_SPLIT_2 = 78,0,16,0 %;      !  third split point -- 4-bkt split (indexed) 
macro IRB$L_OWNER_ID = 80,0,32,0 %;     !  owner id used for record locks 
macro IRB$W_OWN_ID = 80,0,16,0 %;       !  index part of process id (pid) 
macro IRB$W_OWN_ISI = 82,0,16,0 %;      !  isi value for this irab 
macro IRB$B_PPF_ISI = 82,0,8,0 %;       !  isi value for this process-permanent irab 
macro IRB$B_BCNT = 84,0,8,0 %;          !  i/o buffer count 
macro IRB$B_MBC = 85,0,8,0 %;           !  multi-block count 
macro IRB$W_RSZ = 86,0,16,0 %;          !  record size from user 
macro IRB$L_RBF = 88,0,32,0 %;          !  user record buffer address 
macro IRB$B_MBF = 92,0,8,0 %;           !  Multi-buffer count from user's RAB 
macro IRB$B_JNLFLG3 = 93,0,8,0 %;       !  IRB journaling flags 
macro IRB$V_VALID_AT = 93,0,1,0 %;      !  IRB MJB contains valid AT entry to write 
! ++
! 
!   start of organization dependent fields
! 
! ++
! 
!  used by sequential and relative files
! 
macro IRB$W_CSIZ = 98,0,16,0 %;         !  current record size (seq) 
! ++
! 
!   relative org specific fields
! 
macro IRB$L_TEMP0 = 100,0,32,0 %;
macro IRB$W_ROVHDSZ = 100,0,16,0 %;     !  overhead size for record 
macro IRB$B_PRE_CCTL = 100,0,8,0 %;     !  'pre' carriage control 
macro IRB$B_POST_CCTL = 101,0,8,0 %;    !  'post' carriage control 
macro IRB$W_RTOTLSZ = 102,0,16,0 %;     !  total size for record 
macro IRB$L_TEMP1 = 104,0,32,0 %;
macro IRB$B_NVBNS = 104,0,8,0 %;        !  number of vbns transferred (nxtblk1) 
! 
!  indexed org specific fields
! 
literal IRB$K_BLN_IDX = 196;
literal IRB$C_BLN_IDX = 196;
literal IRB$S_IRBDEF1 = 196;
macro IRB$L_KEYBUF = 96,0,32,0 %;       !  address of internal key buffer & update buffer 
macro IRB$L_UPDBUF = 100,0,32,0 %;      !  address of internal update buffer 
macro IRB$L_RECBUF = 104,0,32,0 %;      !  address of internal record buffer 
macro IRB$L_OLDBUF = 108,0,32,0 %;      !  address of internal old record buffer (updates only) 
macro IRB$L_RFA_VBN = 112,0,32,0 %;     !  save record vbn for nrp data 
macro IRB$L_UPD_BDB = 112,0,32,0 %;     !  save current bdb during insert operation 
macro IRB$L_LAST_VBN = 112,0,32,0 %;    !  last vbn at data level for update 
macro IRB$W_RFA_ID = 116,0,16,0 %;      !  save record id for search data 
macro IRB$W_LAST_ID = 116,0,16,0 %;     !  id for udr during update (plg 3) 
macro IRB$W_SAVE_POS = 118,0,16,0 %;    !  save duplicate position for nrp data 
macro IRB$L_NEXT_VBN = 120,0,32,0 %;    !  save next user data record VBN for nrp data 
macro IRB$L_PUTUP_VBN = 120,0,32,0 %;   !  RFA VBN of $PUT/$UPDATE record 
macro IRB$L_FIRST_VBN = 124,0,32,0 %;   !  save SIDR first element VBN for search NRP data 
macro IRB$W_NEXT_ID = 128,0,16,0 %;     !  save next user data record ID for nrp data 
macro IRB$W_PUTUP_ID = 128,0,16,0 %;    !  ID of $PUT/$UPDATE record 
macro IRB$W_FIRST_ID = 130,0,16,0 %;    !  save SIDR first element ID for search NRP data 
macro IRB$L_LOCK_BDB = 132,0,32,0 %;    !  lock bdb addr of level below on splits 
macro IRB$L_VBN_LEFT = 136,0,32,0 %;    !  left vbn of split 
macro IRB$L_MIDX_TMP1 = 136,0,32,0 %;   !  temporary one for make index 
macro IRB$L_VBN_RIGHT = 140,0,32,0 %;   !  right vbn of split 
macro IRB$L_MIDX_TMP2 = 140,0,32,0 %;   !  temporary two for make index 
macro IRB$L_VBN_MID = 144,0,32,0 %;     !  middle vbn of split 
macro IRB$L_MIDX_TMP3 = 144,0,32,0 %;   !  temporary three for make index 
macro IRB$L_NEXT_DOWN = 144,0,32,0 %;   !  used by search_tree 
macro IRB$L_REC_COUNT = 148,0,32,0 %;   !  number of current record in this bucket (plg 3) 
macro IRB$L_LST_NCMP = 152,0,32,0 %;    !  address of last key with zero front compression (plg 3) 
macro IRB$L_SPL_COUNT = 156,0,32,0 %;   !  number of the first record to be moved into new bucket 
!   when splitting indexes and SIDRs
macro IRB$W_NID_RIGHT = 160,0,16,0 %;   !  Next record ID of the right bucket 
macro IRB$W_NID_MID = 162,0,16,0 %;     !  Next record ID of the middle bucket 
macro IRB$W_RFA_NID = 164,0,16,0 %;     !  Next record ID of the RFA bucket 
macro IRB$B_KEYSZ = 166,0,8,0 %;        !  size of key in keybuffer !2 
macro IRB$L_CUR_VBN = 168,0,32,0 %;     !  VBN of current record (primary/SIDR) 
macro IRB$L_POS_VBN = 172,0,32,0 %;     !  VBN of primary data record for NRP positioning 
macro IRB$L_UDR_VBN = 176,0,32,0 %;     !  VBN of current primary data record 
macro IRB$L_SIDR_VBN = 180,0,32,0 %;    !  SIDR array first element VBN of current record (SIDR) 
macro IRB$W_CUR_ID = 184,0,16,0 %;      !  ID of current record (primary) 
macro IRB$W_POS_ID = 186,0,16,0 %;      !  ID of primary data record for NRP positioning 
macro IRB$W_UDR_ID = 188,0,16,0 %;      !  ID of current primary data record 
macro IRB$W_SIDR_ID = 190,0,16,0 %;     !  SIDR array first element ID of current record (SIDR) 
macro IRB$W_CUR_COUNT = 192,0,16,0 %;   !  SIDR array count of current record (SIDR) 
macro IRB$B_RP_KREF = 194,0,8,0 %;      !  Key of reference by which next record is retrieved 
macro IRB$B_CUR_KREF = 195,0,8,0 %;     !  Key of reference of current record (primary/SIDR) 
 
!*** MODULE $ASBDEF ***
! 
!         ASB field definitions
! 
!         Asynchronous context block (asb)
! 
!         There is one asb per irab pointed to by irb$l_asbaddr allocated at
!         connect and one per ifab which is dynamicaly allocated at stall
! 
!         The asb$l_arglst is pointed to by the arglst field of the
!         irab if the irb$v_async bookkeeping bit is set
! 
!         All of the asb$c_bln_xxx must be longword aligned
! 
literal ASB$C_BID = 13;                 !  asb id = 13 
literal ASB$K_BLN_FIX = 48;             !  block length of fixed asb 
literal ASB$C_BLN_FIX = 48;             !  block length of fixed asb 
!   regs 4 and 5 are saved on stack
literal ASB$K_BLN_SEQ = 188;            !  block length for seq org irab operations 
literal ASB$C_BLN_SEQ = 188;            !  block length for seq org irab operations 
literal ASB$K_BLN_REL = 192;            !  block length for rel org irab operations 
literal ASB$C_BLN_REL = 192;            !  block length for rel org irab operations 
literal ASB$K_BLN_FAB = 352;            !  block length for fab-related operations 
literal ASB$C_BLN_FAB = 352;            !  block length for fab-related operations 
literal ASB$K_BLN_IDX = 512;
literal ASB$C_BLN_IDX = 512;
literal ASB$S_ASBDEF = 512;
macro ASB$W_STKLEN = 0,0,16,0 %;        !  save stack length (must be first word in block) 
!   STKLEN = BLN_org - BLN_FIX
macro ASB$W_STKSIZ = 2,0,16,0 %;        !  size of saved stack in bytes 
macro ASB$B_BID = 8,0,8,0 %;            !  block id 
macro ASB$B_BLN = 9,0,8,0 %;            !  block length in longwords 
macro ASB$L_ARGLST = 12,0,0,0 %;
literal ASB$S_ARGLST = 16;              !  saved argument list on async irab operations 
macro ASB$B_ARGCNT = 12,0,8,0 %;        !  argument count 
!  value will be 0, 1, 2, or 3
macro ASB$L_FABRAB = 16,0,32,0 %;       !  fab or rab address 
macro ASB$L_ERR = 20,0,32,0 %;          !  err routine addr 
macro ASB$L_SUC = 24,0,32,0 %;          !  suc routine addr 
macro ASB$L_REGS = 28,0,0,0 %;
literal ASB$S_REGS = 20;                !  save register area for regs 6, 7, 8, 10 and 11 
macro ASB$L_STK = 48,0,0,0 %;
literal ASB$S_STK = 140;                !  saved stack area 
 
!*** MODULE $BDBDEF ***
! 
!          BDB field definitions
! 
!         buffer descriptor block (bdb)
! 
!         there is one bdb per i/o buffer
!         ( the i/o buffers exist in separate pages, page aligned)
! 
literal BDB$C_BID = 12;                 !  bdb id code 
literal BDB$M_VAL = 1;
literal BDB$M_DRT = 2;
literal BDB$M_IOP = 4;
literal BDB$M_PRM = 8;
literal BDB$M_NOLOCATE = 16;
literal BDB$M_WFO = 32;
literal BDB$M_AST_DCL = 64;
literal BDB$S_BDBDEF = 80;
macro BDB$L_FLINK = 0,0,32,0 %;         !  forward link 
macro BDB$L_BLINK = 4,0,32,0 %;         !  backward link 
macro BDB$B_BID = 8,0,8,0 %;            !  block id 
macro BDB$B_BLN = 9,0,8,0 %;            !  block length in longwords 
macro BDB$B_FLGS = 10,0,8,0 %;          !  bdb flags 
macro BDB$V_VAL = 10,0,1,0 %;           !  buffer contents valid 
macro BDB$V_DRT = 10,1,1,0 %;           !  buffer content dirty 
macro BDB$V_IOP = 10,2,1,0 %;           !  buffer has i/o in progress 
macro BDB$V_PRM = 10,3,1,0 %;           !  buffer has permanence factor 
macro BDB$V_NOLOCATE = 10,4,1,0 %;      !  buffer shared - no locate mode 
macro BDB$V_WFO = 10,5,1,0 %;           !  other streams awaiting 
macro BDB$V_AST_DCL = 10,6,1,0 %;       !  ast has been declared for 
!  waiting stream
!  the releasing of this bdb
!  (set/cleared by rm$cache)
macro BDB$B_CACHE_VAL = 11,0,8,0 %;     !  relative value of buffer in cache 
macro BDB$B_VERTYP = 11,0,8,0 %;        !  version type (1 = wild) 
macro BDB$W_USERS = 12,0,16,0 %;        !  number of streams referencing this buffer 
macro BDB$W_BUFF_ID = 14,0,16,0 %;      !  buffer identification number 
macro BDB$L_BLB_PTR = 16,0,32,0 %;      !  pointer to BLB chain for this BDB 
macro BDB$W_NUMB = 20,0,16,0 %;         !  ! of bytes of buffer in use 
macro BDB$W_DIRSEQ = 20,0,16,0 %;       !  UCB$W_DIRSEQ at directory read time 
macro BDB$W_SIZE = 22,0,16,0 %;         !  ! bytes in buffer 
macro BDB$L_ADDR = 24,0,32,0 %;         !  address of buffer 
macro BDB$L_VBN = 28,0,32,0 %;          !  1st vbn in buffer 
macro BDB$L_VBNSEQNO = 32,0,32,0 %;     !  vbn seq number of validity check vs. bcb copy 
macro BDB$L_LAST = 32,0,32,0 %;         !  address of last directory record 
macro BDB$L_WAIT = 36,0,32,0 %;         !  wait thread (irab addr) 
!  (for inter-stream intra-
!   process locking only)
macro BDB$L_VERCOUNT = 36,0,32,0 %;     !  negative count of version entries scanned 
macro BDB$L_ALLOC_ADDR = 40,0,32,0 %;   !  buffer allocation addr 
macro BDB$W_ALLOC_SIZE = 44,0,16,0 %;   !  buffer allocation size 
macro BDB$L_BI_BDB = 48,0,32,0 %;       !  address of isam/block i/o bi journaling BDB 
macro BDB$L_AI_BDB = 52,0,32,0 %;       !  address of isam/block i/o ai journaling BDB 
macro BDB$T_JNLSEQ = 56,0,0,0 %;
literal BDB$S_JNLSEQ = 16;              !  Journaling Sequence Number Block 
macro BDB$L_WK1 = 72,0,32,0 %;          !  work area 
macro BDB$B_REL_VBN = 72,0,8,0 %;       !  current vbn rel to start of buffer 
macro BDB$B_VAL_VBNS = 73,0,8,0 %;      !  ! of valid vbns in buffer 
macro BDB$B_PRE_CCTL = 74,0,8,0 %;      !  unit record carriage control byte ('pre') 
macro BDB$B_POST_CCTL = 75,0,8,0 %;     !  unit record carriage control byte ('post') 
macro BDB$L_CURBUFADR = 76,0,32,0 %;    !  current buffer addr 
literal BDB$K_BLN = 80;                 !  length of bdb block 
literal BDB$C_BLN = 80;                 !  length of bdb block 
literal BDB$S_BDBDEF1 = 80;
macro BDB$L_IOSB = 72,0,0,0 %;
literal BDB$S_IOSB = 8;                 !  i/o status block for buffer 
macro BDB$L_VERSION = 72,0,32,0 %;      !  addr of current/next directory version entry 
macro BDB$L_RECORD = 76,0,32,0 %;       !  address of current/next directory record 
 
!*** MODULE $GBPBDEF ***
! 
!         GBPB field definitions
! 
!         Global Buffer Pointer Block (GBPB)
! 
!         The GBPB is the process local structure used in conjunction with
!         shared global i/o buffers.  In order to minimize the impact of
!         global buffers on existing code, the GBPB is identical to a BDB
!         in those fields which are referenced outside of the RM$CACHE and
!         RM$RELEASE routines.
! 
literal GBPB$C_BID = 21;                !  gbpb id code 
literal GBPB$K_BLN = 40;                !  Length of GBPB block 
literal GBPB$C_BLN = 40;                !  Length of GBPB block 
literal GBPB$S_GBPBDEF = 40;
macro GBPB$L_FLINK = 0,0,32,0 %;        !  forward link 
macro GBPB$L_BLINK = 4,0,32,0 %;        !  backward link 
macro GBPB$B_BID = 8,0,8,0 %;           !  block id 
macro GBPB$B_BLN = 9,0,8,0 %;           !  block length in longwords 
macro GBPB$B_FLGS = 10,0,8,0 %;         !  gbpb flags (use BDB flgs definitions) 
macro GBPB$B_CACHE_VL = 11,0,8,0 %;     !  relative cache value of this buffer 
macro GBPB$W_USERS = 12,0,16,0 %;       !  number of streams referencing this buffer 
macro GBPB$W_BUFF_ID = 14,0,16,0 %;     !  buffer identification number 
macro GBPB$L_BLB_PTR = 16,0,32,0 %;     !  pointer to BLB chain for this GBPB 
macro GBPB$W_NUMB = 20,0,16,0 %;        !  ! of bytes of buffer in use 
macro GBPB$W_SIZE = 22,0,16,0 %;        !  ! bytes in buffer 
macro GBPB$L_ADDR = 24,0,32,0 %;        !  address of buffer 
macro GBPB$L_VBN = 28,0,32,0 %;         !  1st vbn in buffer 
macro GBPB$L_VBNSEQNO = 32,0,32,0 %;    !  sequence number field. 
macro GBPB$L_GBD_PTR = 36,0,32,0 %;     !  Pointer to the GBD for this buffer. 
 
!*** MODULE $RLBDEF ***
! 
!         RLB field definitions
! 
!         record lock block (rlb)
! 
!         The rlb describes one locked record for a particular
!         process-record stream (rab/irab). if the owner field
!         is 0 then the rlb is available for use. otherwise, it
!         describes a locked record. note: when owner is 0 the
!         record rfa fields are zeroed (0).
! 
! 
!                 +---------------------------------------+
!         rlb:     !                link                   |
!                 +------------------+--------------------+
!                 |                   |        rfa4  id         |
!                 +---------+--------+----------+---------+
!                 |  flags  |reserved|   bln    |   bid   |
!                 +---------+--------+----------+---------+
!                 |                rfa0                   |
!                 +---------------------------------------+
!                  |                  owner                         |
!                  +---------------------------------------+
!         lksb:    | Still to be def- |  VMS status code   |
!                 | ined status bits |                    |
!                 +---------------------------------------+
!                 |  Lock Id. (Returned for new locks,    |
!                 |            input for conversions)     |
!                 +---------------------------------------+
! 
literal RLB$M_TIMER_INPROG = 1;
literal RLB$C_BID = 14;                 !  rlb code 
literal RLB$M_WAIT = 1;
literal RLB$M_CR = 2;
literal RLB$M_PW = 4;
literal RLB$M_PR = 8;
literal RLB$M_CONV = 16;
literal RLB$M_LV2 = 32;
literal RLB$M_FAKE = 64;
literal RLB$M_TMO = 128;
literal RLB$K_BLN = 28;                 !  length of rlb 
literal RLB$C_BLN = 28;                 !  length of rlb 
literal RLB$S_RLBDEF = 28;
macro RLB$L_LNK = 0,0,32,0 %;           !  link to next rlb 
macro RLB$L_MISC = 4,0,32,0 %;          !  longword definition to optimize clearing field 
macro RLB$W_FLAGS2 = 4,0,16,0 %;        !  more flag bits 
macro RLB$V_TIMER_INPROG = 4,0,1,0 %;   !  Timer queued. 
macro RLB$W_RFA4 = 6,0,16,0 %;          !  3'rd word of records rfa 
!  offset for seq f.o. (bits 0:14)
!  always 0 for rel f.o. (bits 0:14)
macro RLB$W_ID = 6,0,16,0 %;            !  id for idx f.o. 
macro RLB$B_BID = 8,0,8,0 %;            !  block id 
macro RLB$B_BLN = 9,0,8,0 %;            !  block length in longwords 
macro RLB$B_TMO = 10,0,8,0 %;           !  propagation of ROP TMO field 
macro RLB$B_FLAGS = 11,0,8,0 %;         !  various locking flags 
macro RLB$V_WAIT = 11,0,1,0 %;          !  propagation of ROP WAT bit 
macro RLB$V_CR = 11,1,1,0 %;            !  defines lock manager mode "concurrent read" 
macro RLB$V_PW = 11,2,1,0 %;            !  allow reader access to locked record flag 
macro RLB$V_PR = 11,3,1,0 %;            !  used to query lock database 
macro RLB$V_CONV = 11,4,1,0 %;          !  defines lock manager option "convert" 
macro RLB$V_LV2 = 11,5,1,0 %;           !  sets lock as "level 2" RU consistancy 
macro RLB$V_FAKE = 11,6,1,0 %;          !  this RLB contains no lock. 
macro RLB$V_TMO = 11,7,1,0 %;           !  propagation of ROP TMO bit 
!  indicate "lock for write, allow readers"
!  used to query lock database for records
macro RLB$L_RFA0 = 12,0,32,0 %;         !  1'st and 2'nd words of record's rfa 
!  seq f.o. vbn
!  rel f.o. relative record number
!  idx f.o. start vbn
macro RLB$L_OWNER = 16,0,32,0 %;        !  identification of owning stream 
macro RLB$L_LKSB = 20,0,32,0 %;         !  first longword of lock status block 
macro RLB$W_STATUS = 20,0,16,0 %;       !  VMS status code 
macro RLB$W_S_BITS = 22,0,16,0 %;       !  various status bits 
macro RLB$L_LOCK_ID = 24,0,32,0 %;      !  second longword of lksb is lock_id 
 
!*** MODULE $FLBDEF ***
! 
!   file lock block definitions
! 
literal FLB$C_BID = 23;
literal FLB$K_BLN = 20;
literal FLB$C_BLN = 20;
literal FLB$S_FLBDEF = 20;
macro FLB$L_FLB_LNK = 0,0,32,0 %;       !  pointer to next FLB 
macro FLB$L_RLB_LNK = 4,0,32,0 %;       !  pointer to RLBs 
macro FLB$B_BID = 8,0,8,0 %;            !  block id 
macro FLB$B_BLN = 9,0,8,0 %;            !  block length 
macro FLB$L_IFB_PTR = 12,0,32,0 %;      !  IFAB address 
macro FLB$L_LOCK_ID = 16,0,32,0 %;      !  lock id 
 
!*** MODULE $DRCDEF ***
! 
!   directory cache node definitions
! 
literal DRC$K_BLN = 62;                 !  length of directory cache node 
literal DRC$C_BLN = 62;                 !  length of directory cache node 
literal DRC$S_DRCDEF = 62;
macro DRC$L_NXTFLNK = 0,0,32,0 %;       !  link to next entry, this level 
macro DRC$L_NXTBLNK = 4,0,32,0 %;       !  link to previous entry, this level 
macro DRC$L_LVLFLNK = 8,0,32,0 %;       !  link to first entry, next lower level 
macro DRC$L_LVLBLNK = 12,0,32,0 %;      !  link to last entry, next lower level 
!  note: the links are maintained in lru order
macro DRC$T_NAME = 16,0,0,0 %;
literal DRC$S_NAME = 40;                !  directory name or device and unit 
!  note: stored as counted string counting count itself
macro DRC$W_DID = 56,0,0,0 %;
literal DRC$S_DID = 6;                  !  file id for directory 
macro DRC$W_DIRSEQ = 58,0,16,0 %;       !  directory sequence ! for device node 
 
!*** MODULE $RLSDEF ***
! 
!                 release option flag definitions
! 
literal RLS$M_RETURN = 1;
literal RLS$M_WRT_THRU = 2;
literal RLS$M_KEEP_LOCK = 4;
literal RLS$M_DEQ = 8;
literal RLS$S_RLSDEF = 1;
macro RLS$V_RETURN = 0,0,1,0 %;         !  return buffer and bdb to free space lists 
macro RLS$V_WRT_THRU = 0,1,1,0 %;       !  write buffer if dirty 
macro RLS$V_KEEP_LOCK = 0,2,1,0 %;      !  keep bdb locked 
macro RLS$V_DEQ = 0,3,1,0 %;            !  always release lock 
 
!*** MODULE $CSHDEF ***
! 
!                 cache option flag definitions
! 
literal CSH$M_LOCK = 1;
literal CSH$M_NOWAIT = 2;
literal CSH$M_NOREAD = 4;
literal CSH$M_NOBUFFER = 8;
literal CSH$S_CSHDEF = 1;
macro CSH$V_LOCK = 0,0,1,0 %;           !  obtain exclusive access to block 
macro CSH$V_NOWAIT = 0,1,1,0 %;         !  do not wait for block on access interlock 
macro CSH$V_NOREAD = 0,2,1,0 %;         !  do not read in block 
macro CSH$V_NOBUFFER = 0,3,1,0 %;       !  obtain access to block but don't allocate 
!  a buffer for it and don't read it
!  collision
 
!*** MODULE $PIODEF ***
! 
! 
!   rms overall status bit definitions
! 
literal PIO$S_PIODEF = 1;
macro PIO$V_INHAST = 0,0,1,0 %;         !  set if asts implicitly inhibited 
!  if reset by disabled ast, ast must be re-
!  enabled
macro PIO$V_EOD = 0,1,1,0 %;            !  set if searching for 'eod' string on 'input' 
macro PIO$V_SYNC1 = 0,2,1,0 %;          !  sync stalled operation using efn 27 
macro PIO$V_SYNC2 = 0,3,1,0 %;          !  sync stalled operation using efn 28 
 
!*** MODULE $FTLDEF ***
! 
!         definitions for rms debug failure codes
! 
! 
!   the following codes are for temporary bug check tests, and are
!   internal to rms.  all of the codes are negative, implying that they
!   do not return to the caller, probably killing the process (if not
!   the entire system).
! 
literal FTL$_SETPRTFAIL = -1;           !  set protection system service failed (rm0bufmgr) 
literal FTL$_STKTOOBIG = -2;            !  stack too big for asb (rm0stall) 
literal FTL$_BADIFAB = -3;              !  invalid ifab or irab (rm0fset,rm0conn,rm0rset,rm0prflnm) 
literal FTL$_GTCHNFAIL = -4;            !  get channel system service failure (rm0prflnm) 
literal FTL$_BADORGCASE = -5;           !  invalid orgcase value for dispatch (all rms$ 
!  level routines execept open and create)
literal FTL$_BADBDB = -6;               !  block not a bdb (rm0bufmgr) 
literal FTL$_ASBALLFAIL = -7;           !  couldn't allocate an asb (rm0stall) 
literal FTL$_BADASTPRM = -8;            !  ast parameter not a valid ifab/irab addr (rm0stall) 
literal FTL$_CANTDOAST = -9;            !  couldn't redeclare ast (insf. mem.) (rm0stall) 
literal FTL$_NOSTRUCT = -10;            !  rab or fab not same on ast (rm0stall) 
literal FTL$_NOASB = -11;               !  asb not allocated or stream not busy on ast (rm0stall) 
literal FTL$_NONXTBDB = -12;            !  no next bdb available (rm1seqxfr) 
literal FTL$_BADBUFSIZ = -13;           !  disk buffer size not = 512 (rm1conn) 
literal FTL$_ENQDEQFAIL = -14;          !  enq or deq service failed (rm0reclck) 
literal FTL$_NOCURBDB = -15;            !  no current bdb before calling rm$release (rm0reclck) 
literal FTL$_NOPARENT = -16;            !  no parent lock available for global buffer section lock (rm0share) 
literal FTL$_DEALLERR = -17;            !  ifab deallocation attempted with other block(s) 
!  still allocated (rms0close)
literal FTL$_IORNDN = -18;              !  i/o rundown inconsistency (either ifab or irab 
!  table entries not zeroed) (rms0rndwn)
literal FTL$_XFERSIZE = -19;            !  size of requested transfer not equal to 
!  or less than the current number of bytes
!  in use for the bdb (rm0cache)
literal FTL$_NOTLOCKED = -20;           !  bdb not locked and a keep lock request 
!  was made on a release request.
literal FTL$_NODIDORFID = -21;          !  neither a fid nor a did was set upon exit from 
!  rm$setdid (rms0erase)
literal FTL$_RELEASFAIL = -22;          !  release of non-dirty bdb failed (rm0xtnd23,rms0extend) 
literal FTL$_NOLOCKBDB = -23;           !  no lock bdb found (rm0xtnd23) 
literal FTL$_NONETWORK = -24;           !  network routine entered but no network support in rms 
literal FTL$_LOCKFAILED = -25;          !  failed to lock prolog (rm2create) 
literal FTL$_BADLEVEL = -26;            !  to search by id, structure level must be 0 
literal FTL$_ASTDECERR = -27;           !  ast declaration for file sharing failed 
literal FTL$_BADGBLCNT = -28;           !  Zero global buffer count found when not expected (rm1conn) 
literal FTL$_ACCNTOVFLO = -29;          !  access count overflow (rm0share) 
literal FTL$_BDBAVAIL = -30;            !  BDB was available and shouldn't have been. 
literal FTL$_GBLNOLK = -31;             !  Record locking was not set with global buffers. 
literal FTL$_LCKFND = -32;              !  A lock was found and we don't know what to do. 
literal FTL$_NOBLB = -33;               !  No BLB was found and there should have been one. 
literal FTL$_NOGBPB = -34;              !  No GBPB was found and should have been. 
literal FTL$_NOLCLBUF = -35;            !  Should have found a local buffer. 
literal FTL$_NORDNOTSET = -36;          !  NOREAD not set when NOBUFFER was. 
literal FTL$_NOTGBPB = -37;             !  Found an illegit BDB. 
literal FTL$_NOSFSB = -38;              !  No SFSB when allocating BLB. 
literal FTL$_LOCKHELD = -39;            !  Attempted to return a BLB with lock_id neq 0 
literal FTL$_RLSDRT = -40;              !  Dirty buffer found in releasall. 
literal FTL$_BADBLB = -41;              !  Bad BLB found in blocking AST routine. 
literal FTL$_BADOWNER = -42;            !  Owner field in BLB is bad in blocking AST routine. 
literal FTL$_GETLKIFAIL = -43;          !  $GETLKIW failed in last chance (rms0lstch).
literal FTL$_BADEBKHBK = -44;           !  tried to store an invalid EBK/HBK (rm0share).
 
!*** MODULE $BUGDEF ***
! 
!   the following internal codes are for non-fatal bug check reporting.
!   these codes are positive byte values.  they trigger a reporting action
!   and return to the caller with r0 set to rms$_bug+<8*the bug code>,
!   which is an externally documented rms error code.
! 
literal BUG$_BADDFLTDIR = 1;            ! DEFAULT DIRECTORY STRING INVALID (RM0XPFN) 
 
!*** MODULE $IDXDEF ***
! 
!         IDX field definitions
! 
!         index descriptor definition
! 
!         An index descriptor block exists for each key of reference in use.
!         they are not necessarily contiguous in memory.
! 
literal IDX$C_BID = 15;                 !  id for index descriptor block 
literal IDX$M_DUPKEYS = 1;
literal IDX$M_CHGKEYS = 2;
literal IDX$M_NULKEYS = 4;
literal IDX$M_IDX_COMPR = 8;
literal IDX$M_INITIDX = 16;
literal IDX$M_KEY_COMPR = 64;
literal IDX$M_REC_COMPR = 128;
literal IDX$C_STRING = 0;               !  string data type 
literal IDX$C_SGNWORD = 1;              !  signed binary word 
literal IDX$C_UNSGNWORD = 2;            !  unsigned binary word 
literal IDX$C_SGNLONG = 3;              !  signed binary long word 
literal IDX$C_UNSGNLONG = 4;            !  unsigned binary long word 
literal IDX$C_PACKED = 5;               !  packed decimal 
literal IDX$C_SGNQUAD = 6;              !  signed binary quadword 
literal IDX$C_UNSGNQUAD = 7;            !  unsigned binary quadword 
literal IDX$C_V2_BKT = 0;               !  Prologue two bucket 
literal IDX$C_CMPIDX = 1;               !  Prologue 3, index keys are compressed 
literal IDX$C_NCMPIDX = 2;              !  Prologue 3, index keys are not compressed 
literal IDX$C_CMPCMP = 3;               !  Prologue 3, primary key is compressed, data 
!   is compressed
!  Prologue 3, SIDR key is compressed
literal IDX$C_CMPNCMP = 4;              !  Prologue 3, primary key is compressed, 
!   data is not compressed
literal IDX$C_NCMPCMP = 5;              !  Prologue 3, primary key is not compressed 
!   data is compressed
literal IDX$C_NCMPNCMP = 6;             !  Prologue 3, primary key is not compressed 
!   data is not compressed
!  Prologue 3, SIDR key is compressed
literal IDX$K_FIXED_BLN = 44;
literal IDX$C_FIXED_BLN = 44;
! 
!  the following is the length of the fixed part of the index descriptor
! 
! 
!  the following is repeated for each key segment
! 
literal IDX$S_IDXDEF = 48;
macro IDX$L_IDXFL = 0,0,32,0 %;         !  forward link to next index descriptor 
macro IDX$B_BID = 8,0,8,0 %;            !  block id 
macro IDX$B_BLN = 9,0,8,0 %;            !  length of block 
macro IDX$L_VBN = 10,0,32,0 %;          !  VBN where the descriptor came from 
macro IDX$W_OFFSET = 14,0,16,0 %;       !  Offset into the block (VBN) of the descriptor 
macro IDX$B_DESC_NO = 16,0,8,0 %;       !  Descriptor number (index into update buffer) 
macro IDX$B_IANUM = 18,0,8,0 %;         !  area number for index buckets 
macro IDX$B_LANUM = 19,0,8,0 %;         !  area number for lower index buckets 
macro IDX$B_DANUM = 20,0,8,0 %;         !  area number for data buckets 
macro IDX$B_ROOTLEV = 21,0,8,0 %;       !  level of root 
macro IDX$B_IDXBKTSZ = 22,0,8,0 %;      !  size of index bucket in vbn's 
macro IDX$B_DATBKTSZ = 23,0,8,0 %;      !  size of data bucket in vbn's 
macro IDX$L_ROOTVBN = 24,0,32,0 %;      !  start vbn of root bucket 
macro IDX$B_FLAGS = 28,0,8,0 %;         !  index/key flags 
macro IDX$V_DUPKEYS = 28,0,1,0 %;       !  duplicate keys allowed 
macro IDX$V_CHGKEYS = 28,1,1,0 %;       !  keys can change values 
macro IDX$V_NULKEYS = 28,2,1,0 %;       !  null key value allowed 
macro IDX$V_IDX_COMPR = 28,3,1,0 %;     !  index is compressed 
macro IDX$V_INITIDX = 28,4,1,0 %;       !  index is not initialized 
macro IDX$V_KEY_COMPR = 28,6,1,0 %;     !  key has been compressed 
macro IDX$V_REC_COMPR = 28,7,1,0 %;     !  data record is in compressed form 
macro IDX$B_DATATYPE = 29,0,8,0 %;      !  data type of key field 
macro IDX$B_SEGMENTS = 30,0,8,0 %;      !  number of key field segments 
macro IDX$B_NULLCHAR = 31,0,8,0 %;      !  null character 
macro IDX$B_KEYSZ = 32,0,8,0 %;         !  total key size 
macro IDX$B_KEYREF = 33,0,8,0 %;        !  key of reference(0-primary) 
macro IDX$W_MINRECSZ = 34,0,16,0 %;     !  minimum record size 
macro IDX$W_IDXFILL = 36,0,16,0 %;      !  index fill 
macro IDX$W_DATFILL = 38,0,16,0 %;      !  data fill 
macro IDX$B_IDXBKTYP = 40,0,8,0 %;      !  PLG3 - type of index bucket and SIDR bucket 
macro IDX$B_DATBKTYP = 41,0,8,0 %;      !  PLG3 - type of primary data bucket 
macro IDX$W_POSITION = 44,0,16,0 %;     !  key segment position 
macro IDX$B_SIZE = 46,0,8,0 %;          !  key segment size (plg 3) 
macro IDX$B_TYPE = 47,0,8,0 %;          !  key segment datatype (plg 3) 
 
!*** MODULE $UPDDEF ***
! 
!  update buffer flags
! 
literal UPD$M_INS_NEW = 1;
literal UPD$M_OLD_DEL = 2;
literal UPD$S_UPDDEF = 1;
macro UPD$B_FLAGS = 0,0,8,0 %;
macro UPD$V_INS_NEW = 0,0,1,0 %;        !  alternate key to be inserted from record buffer 
macro UPD$V_OLD_DEL = 0,1,1,0 %;        !  delete this key value using old record 
 
!*** MODULE $GBHDEF ***
! 
!         GBH field definitions
! 
!         Global Buffer Header (GBH)
! 
!         There is a Global Buffer Header for every file's global buffer section.
! 
!         ***  WARNING - THIS STRUCTURE MUST BE QUADWORD ALIGNED  ***
! 
literal GBH$C_BID = 17;                 !  Block ID code for GBH 
literal GBH$M_CACHE_IN = 1;
literal GBH$M_CACHE_OUT = 2;
literal GBH$M_RLS_IN = 4;
literal GBH$M_RLS_OUT = 8;
literal GBH$M_QIO_START = 16;
literal GBH$M_QIO_DONE = 32;
literal GBH$M_STALL = 64;
literal GBH$M_THREADGO = 128;
literal GBH$M_BLB_ENQ = 256;
literal GBH$M_BLB_GRANT = 512;
literal GBH$M_BLB_DEQ = 1024;
literal GBH$M_BLB_BLOCK = 2048;
literal GBH$M_F1 = 4096;
literal GBH$M_F2 = 8192;
literal GBH$M_F3 = 16384;
literal GBH$M_F4 = 32768;
literal GBH$K_BLN = 88;                 !  Length of global buffer header structure 
literal GBH$C_BLN = 88;                 !  Length of global buffer header structure 
literal GBH$S_GBHDEF = 88;
macro GBH$L_GBD_FLNK = 0,0,32,0 %;      !  Self relative queue header for GBD's 
macro GBH$L_GBD_BLNK = 4,0,32,0 %;
macro GBH$B_BID = 8,0,8,0 %;            !  Block ID 
macro GBH$B_BLN = 9,0,8,0 %;            !  Length of GBH in longwords 
macro GBH$W_TRC_FLGS = 10,0,16,0 %;     !  Trace flags (set to trace given function) 
macro GBH$V_CACHE_IN = 10,0,1,0 %;      !  Cache inputs 
macro GBH$V_CACHE_OUT = 10,1,1,0 %;     !  Cache outputs 
macro GBH$V_RLS_IN = 10,2,1,0 %;        !  Release inputs 
macro GBH$V_RLS_OUT = 10,3,1,0 %;       !  Release outputs 
macro GBH$V_QIO_START = 10,4,1,0 %;     !  Qio inputs 
macro GBH$V_QIO_DONE = 10,5,1,0 %;      !  Qio outputs 
macro GBH$V_STALL = 10,6,1,0 %;         !  Stall inputs 
macro GBH$V_THREADGO = 10,7,1,0 %;      !  Stall outputs 
macro GBH$V_BLB_ENQ = 10,8,1,0 %;       !  Bucket lock ENQ inputs 
macro GBH$V_BLB_GRANT = 10,9,1,0 %;     !  Bucket lock grant status 
macro GBH$V_BLB_DEQ = 10,10,1,0 %;      !  Bucket lock DEQ request 
macro GBH$V_BLB_BLOCK = 10,11,1,0 %;    !  Blocking AST received 
macro GBH$V_F1 = 10,12,1,0 %;
macro GBH$V_F2 = 10,13,1,0 %;
macro GBH$V_F3 = 10,14,1,0 %;
macro GBH$V_F4 = 10,15,1,0 %;
macro GBH$L_HI_VBN = 12,0,32,0 %;       !  Highest possible VBN value (FFFFFFFF). 
macro GBH$L_GS_SIZE = 16,0,32,0 %;      !  Size of total section in bytes. 
macro GBH$L_LOCK_ID = 20,0,32,0 %;      !  Lock ID of system file lock. 
macro GBH$L_GS_LOCK_ID = 24,0,32,0 %;   !  Lock ID of system global section lock. 
macro GBH$L_USECNT = 28,0,32,0 %;       !  Accessor count for section.
macro GBH$L_TRC_FLNK = 32,0,32,0 %;     !  Trace blocks forward link 
macro GBH$L_TRC_BLNK = 36,0,32,0 %;     !  Trace blocks back link 
macro GBH$L_GBD_START = 40,0,32,0 %;    !  Offset to first GBD. 
macro GBH$L_GBD_END = 44,0,32,0 %;      !  Offset to last GBD. 
macro GBH$L_GBD_NEXT = 48,0,32,0 %;     !  Offset to next cache victim GBD. 
macro GBH$L_SCAN_NUM = 52,0,32,0 %;     !  Number of GBD's to scan for victim. 
! 
!  Global buffer statistics section
! 
macro GBH$L_HIT = 56,0,32,0 %;          !  Buffer found in global cache 
macro GBH$L_MISS = 60,0,32,0 %;         !  Buffer not found in global cache 
macro GBH$L_READ = 64,0,32,0 %;         !  Buffer read from disk into cache 
macro GBH$L_WRITE = 68,0,32,0 %;        !  Buffer written from cache to disk 
macro GBH$L_DFW_WRITE = 72,0,32,0 %;    !  Deferred writeback from cache to disk 
macro GBH$L_CROSS_HIT = 76,0,32,0 %;    !  Cross process hit count. 
macro GBH$L_OUTBUFQUO = 80,0,32,0 %;    !  Count of times GBLBUFQUO limit was hit.
macro GBH$L_FILL_1 = 84,0,32,0 %;       !  Force quadword alignment
 
!*** MODULE $TRCDEF ***
! 
!         TRC field definitions
! 
!         Trace block structure (TRC)
! 
!         Tracing saves at specific points in the RMS code for debugging and
!         algorithm analysis purposes.
! 
!         ***  WARNING - THIS STRUCTURE MUST BE QUADWORD ALIGNED  ***
! 
literal TRC$C_BID = 18;                 !  Trace block code 
literal TRC$K_BLN = 64;                 !  NOTE: should be quadwords multiple to 
literal TRC$C_BLN = 64;                 !  NOTE: should be quadwords multiple to 
literal TRC$S_TRCDEF = 64;
macro TRC$L_FLNK = 0,0,32,0 %;          !  Trace block forward link 
macro TRC$L_BLNK = 4,0,32,0 %;          !  Trace block back link 
macro TRC$B_BID = 8,0,8,0 %;            !  Block ID 
macro TRC$B_BLN = 9,0,8,0 %;            !  Length of block in longwords 
macro TRC$W_FUNCTION = 10,0,16,0 %;     !  Function code (see GBH definitions) 
macro TRC$L_STRUCTURE = 12,0,32,0 %;    !  Ifab/irab address. 
macro TRC$W_PID = 16,0,16,0 %;          !  Process ID 
macro TRC$W_SEQNUM = 18,0,16,0 %;       !  Sequence number. 
macro TRC$L_VBN = 20,0,32,0 %;          !  VBN requested. 
macro TRC$L_RETURN1 = 24,0,32,0 %;      !  Address of caller. 
macro TRC$L_RETURN2 = 28,0,32,0 %;      !  Caller's caller. 
macro TRC$L_ARGS = 32,0,0,0 %;
literal TRC$S_ARGS = 32;                !  Function specific arguments 
macro TRC$L_ARG_FLG = 32,0,32,0 %;      !  Argument flags (R3). 
macro TRC$L_BDB_ADDR = 36,0,32,0 %;     !  BDB address. 
macro TRC$W_BDB_USERS = 40,0,16,0 %;    !  Use count from BDB. 
macro TRC$W_BDB_BUFF = 42,0,16,0 %;     !  BDB buffer ID. 
macro TRC$B_BDB_CACHE = 44,0,8,0 %;     !  BDB cache value. 
macro TRC$B_BDB_FLAGS = 45,0,8,0 %;     !  Status flags from BDB. 
macro TRC$L_BDB_SEQ = 46,0,32,0 %;      !  Sequence number from BDB. 
macro TRC$B_BLB_MODE = 50,0,8,0 %;      !  Mode held in BLB. 
macro TRC$B_BLB_FLAGS = 51,0,8,0 %;     !  Flags from BLB. 
macro TRC$L_BLB_ADDR = 52,0,32,0 %;     !  Address of BLB. 
macro TRC$L_BLB_LOCK = 56,0,32,0 %;     !  Lock ID from BLB. 
macro TRC$L_BLB_SEQ = 60,0,32,0 %;      !  Sequence number from BLB. 
!  maintain quad alignment on header
 
!*** MODULE $GBDDEF ***
! 
!         GBD structure definitions
! 
!         Global Buffer Descriptor (GBD)
! 
!         There is a single GBD for every buffer in a global buffer
!         section (used only with shared files).  The GBD's themselves
!         are in the section also and linked from a queue header in
!         the Global Buffer Header (GBH).
! 
!         ***  WARNING - THIS STRUCTURE MUST BE QUADWORD ALIGNED  ***
! 
literal GBD$C_BID = 19;                 !  Block ID code for GBD 
literal GBD$M_VALID = 1;
literal GBD$K_BLN = 40;                 !  Length of Global Buffer Descriptor structure. 
literal GBD$C_BLN = 40;                 !  Length of Global Buffer Descriptor structure. 
literal GBD$S_GBDDEF = 40;
macro GBD$L_FLINK = 0,0,32,0 %;         !  Forward link - Note: This is a self relative queue 
macro GBD$L_BLINK = 4,0,32,0 %;         !  Back link 
macro GBD$B_BID = 8,0,8,0 %;            !  Block ID 
macro GBD$B_BLN = 9,0,8,0 %;            !  Block length of GBD 
macro GBD$B_FLAGS = 10,0,8,0 %;         !  Buffer status flags 
macro GBD$V_VALID = 10,0,1,0 %;         !  Buffer is valid. 
macro GBD$B_CACHE_VAL = 11,0,8,0 %;     !  Cache value of this bucket 
macro GBD$L_VBN = 12,0,32,0 %;          !  VBN of bucket the buffer describes 
macro GBD$L_VBNSEQNUM = 16,0,32,0 %;    !  VBN sequence number validity check 
macro GBD$L_LOCK_ID = 20,0,32,0 %;      !  Lock ID of system lock. 
macro GBD$W_NUMB = 24,0,16,0 %;         !  Number of bytes in use 
macro GBD$W_SIZE = 26,0,16,0 %;         !  Size of buffer in bytes 
macro GBD$L_REL_ADDR = 28,0,32,0 %;     !  Address of buffer relative to GBH 
macro GBD$W_USECNT = 32,0,16,0 %;       !  Accessor count for bucket 
macro GBD$B_REHIT_RD = 34,0,8,0 %;      !  Rehit by same process count. 
macro GBD$B_REHIT_LK = 35,0,8,0 %;      !  Rehit by same locker process. 
 
!*** MODULE $BLBDEF ***
! 
!         BLB field definitions
! 
!         Bucket Lock Block (BLB)
! 
!         The BLB contains the argument list for the SYS$ENQ system service
!         as well a pointer to the BDB it relates to and other status.
! 
literal BLB$C_BID = 16;                 !  BLB code 
literal BLB$M_LOCK = 1;
literal BLB$M_NOWAIT = 2;
literal BLB$M_NOREAD = 4;
literal BLB$M_NOBUFFER = 8;
literal BLB$M_IOLOCK = 16;
literal BLB$M_DFW = 32;
literal BLB$M_WRITEBACK = 64;
literal BLB$K_BLN = 56;                 !  Length of BLB 
literal BLB$C_BLN = 56;                 !  Length of BLB 
literal BLB$S_BLBDEF = 56;
macro BLB$L_FLNK = 0,0,32,0 %;          !  Link to next BLB 
macro BLB$L_BLNK = 4,0,32,0 %;          !  Back link 
macro BLB$B_BID = 8,0,8,0 %;            !  Block ID 
macro BLB$B_BLN = 9,0,8,0 %;            !  Block length 
macro BLB$B_BLBFLGS = 10,0,8,0 %;       !  Control flags for BLB 
macro BLB$V_LOCK = 10,0,1,0 %;          !  Corresponds to CSH$V_LOCK 
macro BLB$V_NOWAIT = 10,1,1,0 %;        !  Same as CSH$V_NOWAIT 
macro BLB$V_NOREAD = 10,2,1,0 %;        !  Same as CSH$V_NOREAD 
macro BLB$V_NOBUFFER = 10,3,1,0 %;      !  Same as CSH$V_NOBUFFER 
macro BLB$V_IOLOCK = 10,4,1,0 %;        !  Lock mode for read/write 
macro BLB$V_DFW = 10,5,1,0 %;           !  This is lock for deferred write buffer 
macro BLB$V_WRITEBACK = 10,6,1,0 %;     !  The associated buffer must be written back 
macro BLB$B_MODEHELD = 11,0,8,0 %;      !  Mode of current lock held. 
macro BLB$L_BDB_ADDR = 12,0,32,0 %;     !  BDB for which this lock is held 
macro BLB$L_OWNER = 16,0,32,0 %;        !  Address of stream owning this lock 
macro BLB$L_VBN = 20,0,32,0 %;          !  VBN of bucket lock (resource name) 
macro BLB$L_RESDSC = 24,0,0,0 %;
literal BLB$S_RESDSC = 8;               !  Resource name descriptor 
macro BLB$W_LKSTS = 32,0,16,0 %;        !  Lock status word 
macro BLB$L_LOCK_ID = 36,0,32,0 %;      !  Lock ID 
macro BLB$L_VALBLK = 40,0,0,0 %;
literal BLB$S_VALBLK = 16;              !  Lock value block 
macro BLB$L_VALSEQNO = 40,0,32,0 %;     !  Sequence number part of value block 
 
!*** MODULE $RJBDEF ***
! 
!         RJB Definitions
! 
!         RMS Journaling Block (RJB)
! 
!         This block contains the necessary control information to keep
!         track of the state of journaling on this file
! 
literal RJB$C_BID = 22;
literal RJB$K_BLN = 12;                 ! Length of RJB 
literal RJB$C_BLN = 12;                 ! Length of RJB 
literal RJB$M_RU = 1;
literal RJB$M_BI = 2;
literal RJB$M_AI = 4;
literal RJB$M_AT = 8;
literal RJB$M_OPEN = 16;
literal RJB$S_RJBDEF = 12;
macro RJB$Q_CHAN = 0,0,0,0 %;
literal RJB$S_CHAN = 8;                 ! Channel Block 
macro RJB$W_RUCHAN = 0,0,16,0 %;        !  channel for recovery unit journal 
macro RJB$W_BICHAN = 2,0,16,0 %;        !  channel for before image journal 
macro RJB$W_AICHAN = 4,0,16,0 %;        !  channel for after image journal 
macro RJB$W_ATCHAN = 6,0,16,0 %;        !  channel for audit trail journal 
macro RJB$B_BID = 8,0,8,0 %;            ! Block Id 
macro RJB$B_BLN = 9,0,8,0 %;            ! Block Length 
macro RJB$W_FLAGS = 10,0,16,0 %;        ! Flags word 
macro RJB$V_RU = 10,0,1,0 %;            ! Set to indicate RU channel open 
macro RJB$V_BI = 10,1,1,0 %;            ! Set to indicate BI channel open 
macro RJB$V_AI = 10,2,1,0 %;            ! Set to indicate AI channel open 
macro RJB$V_AT = 10,3,1,0 %;            ! Set to indicate AT channel open 
macro RJB$V_OPEN = 10,4,1,0 %;          ! Indicates $OPEN mapping entry written 
 
!*** MODULE $MJBDEF ***
! 
!         MJB field definitions
! 
!           Miscellaneous Journaling Buffer
! 
!         The MJB is used for writing miscellaneous journal entries,
!         for example, extend entries or audit-trail entries.
! 
literal MJB$C_BID = 24;
literal MJB$M_INIT = 1;
literal MJB$M_FORCE = 2;
literal MJB$M_FILE = 4;
literal MJB$M_SYNCH_SHARE = 8;
literal MJB$K_BLN = 32;
literal MJB$C_BLN = 32;
literal MJB$S_MJBDEF = 32;
macro MJB$B_BID = 8,0,8,0 %;            !  block id 
macro MJB$B_BLN = 9,0,8,0 %;            !  block length in longwords 
macro MJB$W_FLAGS = 10,0,16,0 %;        !  flags 
macro MJB$V_INIT = 10,0,1,0 %;          !  set if RJR overhead is initialized 
macro MJB$V_FORCE = 10,1,1,0 %;         !  set if RJR is to be written thru to journal 
macro MJB$V_FILE = 10,2,1,0 %;          !  set if file operation to journal 
macro MJB$V_SYNCH_SHARE = 10,3,1,0 %;   !  set if file lock can't be released during 
!  STALL
!  and not buffered by CJF (input to WRITE_MJB)
macro MJB$B_JNL = 12,0,8,0 %;           !  set to CJF$_"jnl type" as input to WRITE_MJB 
macro MJB$Q_DESC = 16,0,0,0 %;
literal MJB$S_DESC = 8;                 !  RJR descriptor used in $WRITEJNL service 
macro MJB$W_SIZE = 16,0,16,0 %;         !  size of RJR to write 
macro MJB$L_POINTER = 20,0,32,0 %;      !  pointer to RJR 
macro MJB$Q_IOSB = 24,0,0,0 %;
literal MJB$S_IOSB = 8;                 !  IOSB to use in $WRITEJNL 
macro MJB$T_RJR = 32,0,0,0 %;           !  the journal record begins here 
