MODULE DBGLEVEL3 (IDENT = 'V04-000') =

BEGIN

!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
! WRITTEN BY
!	John Francis	August, 1982
!
! MODULE FUNCTION
!	This module contains the DEBUG kernel code for performing the
!	EVALUATE, EXAMINE and DEPOSIT commands.
!

REQUIRE 'SRC$:DBGPROLOG.REQ';

LIBRARY 'LIB$:DBGGEN.L32';

FORWARD ROUTINE
    DBG$COLLECT: NOVALUE,
    DEPOSIT_HANDLER,
    DBG$DEPOSIT: NOVALUE,
    DBG$EVALUATE: NOVALUE,
    DBG$EXAMINE: NOVALUE,
    DBG$NEXTLOC,
    DBG$PREVLOC,
    MODIFY_PRIMARY,
    PRIMARY_ORDER,
    CHECK_TEXT_DESCRIPTOR,
    FIX_UP_LENGTH;

EXTERNAL
    DBG$GL_CURRENT_PRIMARY,		! Pointer to the primary being processed
    DBG$REG_VALUES: VECTOR[,LONG],	! Vector of user register values in the
    DBG$GL_CURLOC_VMSDESC,		! Override type for %CURLOC
    DBG$GL_DEPOSIT_TOKEN,		! Assignment operator token
    DBG$GL_IDENTITY_TOKEN,		! Identity operator token
    DBG$GL_DFLTTYP,			! Default type from "SET TYPE"
    DBG$GW_DFLTLENG: WORD,		! Length of default data-type
    DBG$GL_SIGN_FLAG;			! Print '+' before signed variable

EXTERNAL ROUTINE
    DBG$BUILD_PRIMARY_SUBNODE: NOVALUE,	! Add new primary sub-node
    DBG$DATA_LENGTH,			! Get length of a data-item
    DBG$DO_MAPPING,			! Perform "type mapping"
    DBG$EVAL_LANG_OPERATOR,		! Evaluate operator expressions
    DBG$FLUSHBUF: NOVALUE,		! Initialize a new print line
    DBG$GET_TEMPMEM,			! Allocate temporary memory
    DBG$IS_IT_ENTRY,			! Check for CALL entry-mask address
    DBG$INS_DECODE,			! Get length of instruction
    DBG$MAKE_VAL_DESC,			! Construct value descriptor
    DBG$NGET_PAGES,			! Construct page list
    DBG$PC_TO_LINE_LOOKUP,		! Get line & statement number
    DBG$PC_TO_SYMID,			! Look up address in SAT
    DBG$PRIM_TO_VAL,			! Obtain value of data-item
    DBG$PRINT: NOVALUE,			! Formats an output line.
    DBG$PRINT_AGGREGATE	: NOVALUE,	! Print array or record
    DBG$PRINT_FIELD_REF	: NOVALUE,	! Print <p,s,e> information
    DBG$PRINT_IDENTIFIER,		! Print name of data-item
    DBG$PRINT_VALUE: NOVALUE,		! Print value in a given radix
    DBG$PRINT_VALUE_AS_INTEGER: NOVALUE,! Print absolute address
    DBG$PUSH_TEMPMEM,			! Save temporary memory state
    DBG$POP_TEMPMEM: NOVALUE,		! Restore  "        "     "
    DBG$NEWLINE: NOVALUE,		! Outputs the output buffer.
    DBG$SAVE_LOC: NOVALUE,		! Save dot
    DBG$SAVE_VAL: NOVALUE,		! Save backslash
    DBG$SET_PAGE_PROT,			! Set page protections
    DBG$SRC_TYPE_PC_SOURCE: NOVALUE,	! Type source text
    DBG$STA_ADDRESS_TO_REGDESCR,	! Translate address to reg descr
    DBG$STA_REGISTER_NAME,		! Obtain reg name from reg descr
    DBG$STA_SETREGISTERS: NOVALUE,	! Store context register values
    DBG$STA_SETCONTEXT: NOVALUE,	! Set up context correctly
    DBG$STA_SYMKIND: NOVALUE,		! Get KIND of data item
    DBG$STA_SYMNAME: NOVALUE,		! Get NAME of data item
    DBG$STA_SYMSIZE: NOVALUE,		! Get SIZE of data item
    DBG$STA_SYMTYPE: NOVALUE,		! Get TYPE of data item
    DBG$STA_TYP_RECORD: NOVALUE,	! Get symbol table information
    DBG$STA_VARIANT_SELECT,		! Get entry from variant set
    DBG$TYPEID_FOR_ATOMIC,		! Make dummy RST entry
    DBG$UPDATE_WATCHPOINTS: NOVALUE,	! Update watched values after DEPOSIT
    LIB$SIGNAL;				! Signal an error

LITERAL

    ! Verb codes for the EVALUATE command.
    !
    EVALUATE			= 1,	! EVALUATE verb code
    EVALUATE_ADDR		= 2,	! EVALUATE/ADDRESS verb code
    EVALUATE_COND		= 3,	! EVALUATE/CONDITION verb code



    ! Verb codes for the EXAMINE command.
    !
    EXAMINE			= 1,	! EXAMINE verb code
    EXAMINE_INSTRUCTION		= 2,	! EXAMINE/INSTRUCTION verb code
    EXAMINE_REGISTER		= 3,	! EXAMINE register verb code
    EXAMINE_SOURCE		= 4,	! EXAMINE/SOURCE verb code
    EXAMINE_CONDITION_VALUE	= 5,	! EXAMINE/CONDITION verb code
    EXAMINE_PSL			= 6,	! EXAMINE the PSL verb code
    EXAMINE_PSW			= 7;	! EXAMINE the PSW verb code

OWN
    PAGE_LIST;				! Pointer to list of pages whose protec-
					!      tion we may have changed

GLOBAL ROUTINE DBG$CHANGE_DTYPE(PRM_DESC, NEW_TYPE, NEW_SIZE) =
!
! FUNCTION
!	------------------------------
!
! INPUTS
!	------------------------------
!
! OUTPUTS
!	------------------------------
!

    BEGIN

    MAP
	PRM_DESC: REF DBG$PRIMARY;	! Pointer to Primary Descriptor

    LOCAL
	ADDR,				! The current instruction address
	SIZE,				! Size of V-Value Descriptor header
	VAL_DESC: REF DBG$VALDESC;	! Pointer to Value Descriptor



    ! Determine what kind of descriptor we have.
    !
    SELECTONE .PRM_DESC[DBG$B_DHDR_TYPE] OF
	SET


	! Handle Primary Descriptors.
	!
	[DBG$K_PRIMARY_DESC]:
	    DBG$PRIM_TO_VAL(.PRM_DESC,DBG$K_V_VALUE_DESC,VAL_DESC);


	! Handle Volatile Value Descriptors.
	!
	[DBG$K_V_VALUE_DESC]:
	    BEGIN
	    SIZE = .PRM_DESC[DBG$W_DHDR_LENGTH];
	    VAL_DESC = DBG$GET_TEMPMEM((.SIZE + (%UPVAL - 1))/%UPVAL);
	    CH$MOVE(.SIZE,.PRM_DESC,.VAL_DESC);
	    IF .PRM_DESC[DBG$L_DHDR_SYMID0] NEQ 0
	    THEN
		DBG$STA_SETCONTEXT(.PRM_DESC[DBG$L_DHDR_SYMID0]);

	    END;


	! Any other descriptor type is invalid so we signal an internal
	! DEBUG error.
	!
	[OTHERWISE]:
	    SIGNAL(DBG$_ILLTYPE);

	TES;


    ! If the type is DBG$K_NOTYPE, meaning type instruction, we return now.
    !
    IF .NEW_TYPE EQL DBG$K_NOTYPE THEN RETURN .VAL_DESC;


    ! If we get here then we are overriding the type information.  In this
    ! case, set the FCODE to "descriptor".  Also set the "override" flag.
    !
    VAL_DESC[DBG$B_DHDR_FCODE] = RST$K_TYPE_DESCR;
    VAL_DESC[DBG$V_DHDR_OVERRIDE] = TRUE;
    SELECTONE .NEW_TYPE OF
	SET


	! Handle the /ASCIZ, /ASCIC, and /ASCIW qualifiers.  These refer to the
	! zero-terminated and counted ASCII string types.
	!
	[DSC$K_DTYPE_AZ,
	 DSC$K_DTYPE_AC,
	 DSC$K_DTYPE_VT]:
	    BEGIN
	    IF (.VAL_DESC[DBG$B_VALUE_CLASS] EQL DSC$K_CLASS_UBS)
	    THEN
		SIGNAL(DBG$_UNALIGNED);

	    VAL_DESC[DBG$B_VALUE_CLASS]  = DSC$K_CLASS_VS;
	    VAL_DESC[DBG$B_VALUE_DTYPE]  = .NEW_TYPE;
	    VAL_DESC[DBG$W_VALUE_LENGTH] =
				FIX_UP_LENGTH(VAL_DESC[DBG$A_VALUE_VMSDESC]);
	    END;


	! Handle the /ASCID qualifier (ASCII string via its descriptor).
	!
	[DBG$K_DTYPE_AD]:
	    BEGIN
	    IF NOT CHECK_TEXT_DESCRIPTOR(.VAL_DESC)
	    THEN
		SIGNAL(DBG$_DESCNOTSET);

	    END;


	! Handle the plain ASCII text string data type (the /ASCII qualifier).
	!
	[DSC$K_DTYPE_T]:
	    BEGIN
	    IF .NEW_SIZE NEQ 0
	    THEN
		VAL_DESC[DBG$W_VALUE_LENGTH] = .NEW_SIZE

	    ELSE
		VAL_DESC[DBG$W_VALUE_LENGTH] = DBG$DATA_LENGTH(
				VAL_DESC[DBG$A_VALUE_VMSDESC])/%BPUNIT;

	    VAL_DESC[DBG$B_VALUE_CLASS]  = DSC$K_CLASS_Z;
	    VAL_DESC[DBG$B_VALUE_DTYPE]  = DSC$K_DTYPE_T;
	    END;


	! Handle the /INSTRUCTION qualifier.
	!
	[DSC$K_DTYPE_ZI]:
	    BEGIN
	    VAL_DESC[DBG$B_VALUE_CLASS]  = DSC$K_CLASS_Z;
	    ADDR = .VAL_DESC[DBG$L_VALUE_POINTER];
	    IF DBG$IS_IT_ENTRY(.ADDR)
	    THEN
		BEGIN
		VAL_DESC[DBG$B_VALUE_DTYPE]  = DSC$K_DTYPE_ZEM;
		VAL_DESC[DBG$W_VALUE_LENGTH] = 2;
		END

	    ELSE
		BEGIN
		VAL_DESC[DBG$B_VALUE_DTYPE]  = DSC$K_DTYPE_ZI;
		VAL_DESC[DBG$W_VALUE_LENGTH] =
				DBG$INS_DECODE(.ADDR, FALSE, FALSE) - .ADDR;
		END;

	    END;


	! Handle the /PACKED qualifier.
	!
	[DSC$K_DTYPE_P]:
	    BEGIN
	    VAL_DESC[DBG$B_VALUE_CLASS]  = DSC$K_CLASS_Z;
	    VAL_DESC[DBG$B_VALUE_DTYPE]  = .NEW_TYPE;
	    IF .NEW_SIZE NEQ %X'0000FFFF'
	    THEN
		VAL_DESC[DBG$W_VALUE_LENGTH] = .NEW_SIZE

	    ELSE
		BEGIN

		FIELD
		    PACKED_FIELDS =
			SET
			SIGN_NIBBLE = [0,0,4,0]
			TES;
		BIND
		    PACKED_DATA = .VAL_DESC[DBG$L_VALUE_POINTER]:
				BLOCKVECTOR[16,1,BYTE] FIELD(PACKED_FIELDS);

		INCR I FROM 0 TO 15 DO
		    BEGIN
		    IF .PACKED_DATA[.I, SIGN_NIBBLE] GTR 9
		    THEN
			BEGIN
			VAL_DESC[DBG$W_VALUE_LENGTH] = (.I*2) + 1;
			EXITLOOP;
			END;

		    END;

		END;

	    END;


	! Handle any other data type.
	!
	[OTHERWISE]:
	    BEGIN
	    VAL_DESC[DBG$B_VALUE_CLASS]  = DSC$K_CLASS_Z;
	    VAL_DESC[DBG$B_VALUE_DTYPE]  = .NEW_TYPE;
	    VAL_DESC[DBG$W_VALUE_LENGTH] = .NEW_SIZE;
	    END;

	TES;

    RETURN .VAL_DESC;
    END;

GLOBAL ROUTINE DBG$COLLECT(PRM_DESC) : NOVALUE =
!
! FUNCTION
!	------------------------------
!
! INPUTS
!	------------------------------
!
! OUTPUTS
!	------------------------------
!

    BEGIN

    MAP
	PRM_DESC: REF DBG$PRIMARY;	! Pointer to Primary Descriptor

    BUILTIN
	REMQUE;				! Remove queue entry from list

    LOCAL
	XXXXXXX;			!<<-------------------------------------



    ! ---------------
    !
    IF (.PRM_DESC NEQA 0) THEN
     IF (.PRM_DESC[DBG$B_DHDR_TYPE] EQL DBG$K_PRIMARY_DESC) THEN
      IF .PRM_DESC[DBG$V_DHDR_AGGR] THEN
	BEGIN
	LOCAL SUB_NODE : REF DBG$PRIM_NODE;

	SUB_NODE = .PRM_DESC[DBG$L_PRIM_BLINK];

	IF (.SUB_NODE[DBG$B_PNODE_FCODE] EQL RST$K_TYPE_ARRAY)
				AND
	   (.SUB_NODE[DBG$B_PNARR_DTYPE] EQL DSC$K_DTYPE_T)
				AND
	   (.SUB_NODE[DBG$W_PNARR_LENGTH] EQL 1)
	THEN
	    BEGIN
	    BIND S_VECTOR = SUB_NODE[DBG$A_PNARR_SVECTOR] : DBG$PRIM_NODE_SUBS;
	    LOCAL DIMS,SIZE,BASE,TYPEID,SYMID;
	    DIMS = .SUB_NODE[DBG$B_PNARR_DIMCNT] - 1;
	    IF .S_VECTOR[.DIMS,DBG$L_PNSUB_STRIDE] NEQ 1 THEN RETURN;
	    IF .S_VECTOR[.DIMS,DBG$L_PNSUB_TYPEID] NEQ 0 THEN RETURN;

	    BASE =  .S_VECTOR[.DIMS,DBG$L_PNSUB_LBOUND];
	    SIZE = (.S_VECTOR[.DIMS,DBG$L_PNSUB_UBOUND] - .BASE) + 1;
	    PRM_DESC[DBG$W_PRIM_OFFSET] = .BASE;
	    PRM_DESC[DBG$W_PRIM_LENGTH] = .SIZE;
	    PRM_DESC[DBG$V_DHDR_SUBREF] = TRUE;
	    PRM_DESC[DBG$V_DHDR_TMPREF] = TRUE;
	    TYPEID = DBG$TYPEID_FOR_ATOMIC(DSC$K_DTYPE_T,.SIZE*%BPUNIT,FALSE);
	    IF .DIMS GTR 0
	    THEN
		BEGIN
		SUB_NODE[DBG$B_PNARR_DIMCNT]   = .DIMS;
		SUB_NODE[DBG$L_PNARR_CELLTYPE] = .TYPEID;
		END
	    ELSE
		BEGIN
		SYMID = .SUB_NODE[DBG$L_PNODE_SYMID];
		REMQUE(.SUB_NODE,SUB_NODE);
		DBG$BUILD_PRIMARY_SUBNODE(.PRM_DESC,RST$K_DATA,.SYMID,
					   RST$K_TYPE_ATOMIC,.TYPEID,0);
		PRM_DESC[DBG$V_DHDR_AGGR] = FALSE;
		SUB_NODE = .PRM_DESC[DBG$L_PRIM_BLINK];
		SUB_NODE[DBG$L_PNODE_RELOC] = -.BASE;
		END;
	    END;
	END;
    END;			! End of dbg$collect

ROUTINE DEPOSIT_HANDLER(SIGNAL_ARGS: REF BLOCK[,BYTE]) =
!
! FUNCTION
!	This routine is the handler for errors that are signalled during
!	the processing of a DEPOSIT command. A handler is necessary so
!	that we can restore page protections that we may have changed.
!
! INPUTS
!	NONE
!
! OUTPUTS
!	------------------------------
!

    BEGIN

    LOCAL
	MESSAGE_VECT;

    ! If we get here the second time around (on the unwind from the
    ! final handler) then resignal the exception. Do not free up
    ! the page list again.
    !
    IF .SIGNAL_ARGS[CHF$L_SIG_NAME] EQL SS$_UNWIND
    THEN
        RETURN SS$_RESIGNAL;    

    IF .PAGE_LIST NEQ 0
    THEN
        DBG$SET_PAGE_PROT(PAGE_LIST,TRUE,MESSAGE_VECT);

    RETURN SS$_RESIGNAL;
    END;

GLOBAL ROUTINE DBG$DEPOSIT(VERB_NODE : REF DBG$VERB_NODE) : NOVALUE =
!
! FUNCTION
!	This routine accepts as input the command execution tree constructed
!	by the parse network and performs the semantic actions corresponding to
!	the parsed DEPOSIT command. If the command cannot be executed, a message
!	argument vector is constructed and returned.
!
!	Upon entrance to this routine, the command has been classified as plain
!	DEPOSIT or Instruction DEPOSIT, and all default and override types have
!	been set up in the adverb nodes.
!
!	There should be two noun nodes. The first is the target of the deposit
!	while the second represents the source (either a value descriptor or a
!	pointer to a counted string for instruction DEPOSITS).
!
! INPUTS
!	VERB_NODE	- A longword containing the address of the verb (head)
!			  node of the command execution tree
!
! OUTPUTS
!	------------------------------
!

    BEGIN


    ROUTINE TEXT_LENGTH(VAL_DESC : REF DBG$VALDESC) =
	BEGIN
	LOCAL LENGTH;
	SELECTONE .VAL_DESC[DBG$B_VALUE_DTYPE] OF
	    SET
	    [DSC$K_DTYPE_T]:	LENGTH = .VAL_DESC[DBG$W_VALUE_LENGTH];
	    [DSC$K_DTYPE_VT]:	LENGTH = .(.VAL_DESC[DBG$L_VALUE_POINTER])<0,16,0>;
	    [DSC$K_DTYPE_AC]:	LENGTH = .(.VAL_DESC[DBG$L_VALUE_POINTER])<0, 8,0>;
	    [OTHERWISE]:	SIGNAL(DBG$_ILLTYPE);
	    TES;
	RETURN .LENGTH;
	END;


    LOCAL
	SOURCE_NN	: REF DBG$NOUN_NODE,		! Source of deposit
	TARGET_NN	: REF DBG$NOUN_NODE,		! Target of deposit
	TYPE_NODE	: REF DBG$ADVERB_NODE,		! Command qualifier
	PRIM_DESC	: REF DBG$PRIMARY,
	ADDR_DESC	: REF DBG$VALDESC,
	DATA_DESC	: REF DBG$VALDESC,
	MESSAGE_VECT;					! Error message vector

    BUILTIN CALLG;

    ENABLE DEPOSIT_HANDLER;

    TARGET_NN = .VERB_NODE[DBG$L_VERB_OBJECT_PTR];
    SOURCE_NN = .TARGET_NN[DBG$L_NOUN_LINK];
    PRIM_DESC = .TARGET_NN[DBG$L_NOUN_VALUE];
    DATA_DESC = .SOURCE_NN[DBG$L_NOUN_VALUE];
    PAGE_LIST = 0;

    ! Convert both the source and the target to value descriptors.
    ! eval_lang_operator is used to convert the source because it
    ! is sensitive to any language-specific rules for converting
    ! primaries to values (e.g., in BLISS we do primary->address,
    ! in other languages we do primary->value).
    !
    IF .DATA_DESC[DBG$B_DHDR_TYPE] EQL DBG$K_PRIMARY_DESC
    THEN
        DATA_DESC = DBG$EVAL_LANG_OPERATOR(DBG$GL_IDENTITY_TOKEN,
    			    	          .DATA_DESC, 0);
    DBG$PRIM_TO_VAL(.PRIM_DESC,DBG$K_V_VALUE_DESC,ADDR_DESC);

    IF (TYPE_NODE = .VERB_NODE[DBG$L_VERB_ADVERB_PTR]) EQLA 0
      THEN DBG$SAVE_LOC(.PRIM_DESC)
      ELSE
	BEGIN
	LOCAL OVERRIDE_TYPE,OVERRIDE_SIZE;
	ADDR_DESC[DBG$B_DHDR_FCODE] = RST$K_TYPE_DESCR;
	ADDR_DESC[DBG$V_DHDR_OVERRIDE] = TRUE;
	OVERRIDE_TYPE = .TYPE_NODE[DBG$B_ADVERB_LITERAL];
	OVERRIDE_SIZE = .TYPE_NODE[DBG$L_ADVERB_VALUE];
	SELECTONE .OVERRIDE_TYPE OF
	    SET
	    [DSC$K_DTYPE_AZ,DSC$K_DTYPE_AC,DSC$K_DTYPE_VT]:
		BEGIN
		IF .ADDR_DESC[DSC$B_CLASS] EQL DSC$K_CLASS_UBS THEN SIGNAL(DBG$_UNALIGNED);
		ADDR_DESC[DBG$B_VALUE_CLASS]  = DSC$K_CLASS_VS;
		ADDR_DESC[DBG$B_VALUE_DTYPE]  = .OVERRIDE_TYPE;
		ADDR_DESC[DBG$W_VALUE_LENGTH] = TEXT_LENGTH(.DATA_DESC);
		END;

	    [DBG$K_DTYPE_AD]:
		IF NOT CHECK_TEXT_DESCRIPTOR(.ADDR_DESC) THEN SIGNAL(DBG$_DESCNOTSET);

	    [OTHERWISE]:
		BEGIN
		IF (.ADDR_DESC[DBG$B_VALUE_CLASS] EQL DSC$K_CLASS_UBS)
		THEN
		    BEGIN
		    IF (.OVERRIDE_SIZE GTR 32)
		    OR (.OVERRIDE_TYPE EQL DSC$K_DTYPE_ZI)
		    OR (.OVERRIDE_TYPE EQL DSC$K_DTYPE_T)
		    THEN
			SIGNAL(DBG$_UNALIGNED);
		    END
		ELSE
		    ADDR_DESC[DBG$B_VALUE_CLASS]  =  DSC$K_CLASS_Z;

		IF (.OVERRIDE_TYPE EQL DSC$K_DTYPE_T)
				   AND
		   (.OVERRIDE_SIZE EQL 0)
		THEN OVERRIDE_SIZE = TEXT_LENGTH(.DATA_DESC);

		ADDR_DESC[DBG$B_VALUE_DTYPE]  = .OVERRIDE_TYPE;
		IF .OVERRIDE_TYPE EQL DSC$K_DTYPE_ZI
		THEN
		    BEGIN
		    LOCAL
			ADDR;

		    ADDR = .ADDR_DESC[DBG$L_VALUE_POINTER];
		    ADDR_DESC[DBG$W_VALUE_LENGTH] =
				DBG$INS_DECODE(.ADDR, FALSE, FALSE ) - .ADDR;
		    END

		ELSE
		    ADDR_DESC[DBG$W_VALUE_LENGTH] = .OVERRIDE_SIZE;

		END;

	    TES;
	DBG$SAVE_LOC(.PRIM_DESC,ADDR_DESC[DBG$A_VALUE_VMSDESC]);
	END;

    DBG$SAVE_VAL(.DATA_DESC);

    IF NOT DBG$NGET_PAGES(.PRIM_DESC,PAGE_LIST,MESSAGE_VECT)
     OR NOT DBG$SET_PAGE_PROT(PAGE_LIST,FALSE,MESSAGE_VECT)
      THEN
	BEGIN
	PAGE_LIST = 0;
	CALLG(.MESSAGE_VECT,LIB$SIGNAL);
	END;

    DBG$EVAL_LANG_OPERATOR(DBG$GL_DEPOSIT_TOKEN,.DATA_DESC,.ADDR_DESC);

    IF NOT DBG$SET_PAGE_PROT(PAGE_LIST,TRUE,MESSAGE_VECT)
    THEN
	BEGIN
	PAGE_LIST = 0;
        CALLG(.MESSAGE_VECT,LIB$SIGNAL);
	END;

    ! Set registers context and return
    !
    DBG$STA_SETREGISTERS();

    ! Update all watch point event entries after the DEPOSIT.
    !
    DBG$UPDATE_WATCHPOINTS();

    END;

GLOBAL ROUTINE DBG$EVALUATE(VERB_NODE): NOVALUE =
!
! FUNCTION
!	This routine is the command execution network for the EVALUATE command.
!	Various semantic actions are performed which correspond to the arguments
!	and operands of the parsed input string.
!
!	EVALUATE sets last val '\', EVALUTATE/ADDRESS sets '.', current loc.
!
! INPUTS
!	VERB_NODE		- A longword containing the address of the head
!				  node in the command execution tree
!
! OUTPUTS
!	NONE
!

    BEGIN

    MAP
	VERB_NODE: REF DBG$VERB_NODE;	! Pointer to the input Verb Node

    LOCAL
	RADIX,
	NOUN_NODE: REF DBG$NOUN_NODE,
	BASE_NODE: REF DBG$ADVERB_NODE,
	PRM_DESC: REF DBG$PRIMARY,
	VAL_DESC: REF DBG$VALDESC;




    ! Flush the current print buffer.  Then pick up the first Noun Node pointer,
    ! the Adverb Node pointer, and the radix setting for this command.
    !
    DBG$FLUSHBUF();
    NOUN_NODE = .VERB_NODE [DBG$L_VERB_OBJECT_PTR];
    BASE_NODE = .VERB_NODE [DBG$L_VERB_ADVERB_PTR];
    IF .BASE_NODE EQLA 0
    THEN
	RADIX = DBG$K_DEFAULT
    ELSE
	RADIX = .BASE_NODE[DBG$B_ADVERB_LITERAL];


    ! Loop through all the Noun Nodes to process each expression on the
    ! EVALUATE command.
    !
    WHILE .NOUN_NODE NEQ 0 DO
	BEGIN
	PRM_DESC = .NOUN_NODE[DBG$L_NOUN_VALUE];
	DBG$COLLECT(.PRM_DESC);


	! Case on the kind of EVALUATE command Verb Node we have as determined
	! by the command qualifiers.
	!
        CASE .VERB_NODE[DBG$B_VERB_COMPOSITE] FROM EVALUATE TO EVALUATE_COND OF
	    SET


	    ! Handle the plain EVALUATE and the EVALUATE/CONDITION_VALUE com-
	    ! mands.
	    !
	    [EVALUATE,
	     EVALUATE_COND]:
		BEGIN
		IF .PRM_DESC[DBG$V_DHDR_AGGR] THEN SIGNAL(DBG$_NOVALUE);
		IF .VERB_NODE[DBG$B_VERB_COMPOSITE] EQL EVALUATE_COND
		THEN
		    PRM_DESC[DBG$V_DHDR_FORMAT] = 1

		ELSE IF .RADIX NEQ DBG$K_DEFAULT
		THEN
		    PRM_DESC[DBG$V_DHDR_FORMAT] = 0;

		DBG$PRINT_VALUE(.PRM_DESC,.RADIX, .DBG$GL_SIGN_FLAG);
		END;


	    ! Handle the EVALUATE/ADDRESS command.
	    !
	    [EVALUATE_ADDR]:
		BEGIN
		LOCAL 
		    NAMEPTR,
		    REGDESCR,
		    VMS_DESC: DBG$STG_DESC;

		DBG$SAVE_LOC(.PRM_DESC);
		DBG$PRIM_TO_VAL(.PRM_DESC,DBG$K_V_VALUE_DESC,VAL_DESC);


		! Check whether the address is in the register save area.
		!
		REGDESCR = DBG$STA_ADDRESS_TO_REGDESCR(.VAL_DESC[DBG$L_VALUE_POINTER]); 
		IF .REGDESCR NEQ 0 THEN
		  BEGIN
		  NAMEPTR = DBG$STA_REGISTER_NAME(.REGDESCR);
		  DBG$PRINT(UPLIT BYTE(%ASCIC '!AC'), .NAMEPTR);
		  END

		ELSE
		  BEGIN
		  VMS_DESC[DSC$B_CLASS] = DSC$K_CLASS_Z;
		  VMS_DESC[DSC$B_DTYPE] = DSC$K_DTYPE_LU;
		  VMS_DESC[DSC$W_LENGTH] = 4;
		  VMS_DESC[DSC$A_POINTER] = VAL_DESC[DBG$L_VALUE_POINTER];
		  DBG$PRINT_VALUE_AS_INTEGER(VMS_DESC,.RADIX);
		  END;


		! If the address is a bit_field then also print the <p,s,e>.
		!
	        DBG$PRINT_FIELD_REF(.VAL_DESC,TRUE);
		END;


	    ! Any other kind of Verb Node should never occur.  If it does, we
	    ! signal an internal DEBUG coding error.
	    !
	    [INRANGE,OUTRANGE]:
		$DBG_ERROR('DBGLEVEL3\EVALUATE');

	    TES;


	! Close out the current print line, link to the next Noun Node on the
	! Noun Node list, and loop.
	!
	DBG$NEWLINE();
	NOUN_NODE = .NOUN_NODE[DBG$L_NOUN_LINK];

	END;				! End of WHILE loop over expressions


    ! The EVALUATE command is processed.  Now return.
    !
    RETURN;

    END;

GLOBAL ROUTINE DBG$EXAMINE(VERB_NODE: REF DBG$VERB_NODE): NOVALUE =
!
! FUNCTION
!	This routine performs the action associated with EXAMINE xxx.
!	We always get three adverb nodes linked to the verb node. See the
!	routine header for DBG$NPARSE_EXAMINE in DBGNEXMNE.B32 for details.
!
! INPUTS
!	VERB_NODE - A longword containing the address of the command
!		  execution tree verb (head) node.
!
! OUTPUTS
!	NONE
!

    BEGIN

    LOCAL
	NOUN_NODE	: REF DBG$NOUN_NODE,
	TYPE_NODE	: REF DBG$ADVERB_NODE,
	BASE_NODE	: REF DBG$ADVERB_NODE,
	MODE_NODE	: REF DBG$ADVERB_NODE,
	PRM_DESC	: REF DBG$PRIMARY,
	END_DESC	: REF DBG$PRIMARY,
	VAL_DESC	: REF DBG$VALDESC,
	NEW_SIZE	: WORD,
	NEW_TYPE	: BYTE,
	RADIX		: BYTE,
	FORMAT_ONE	: BYTE,
	FORMAT_TWO	: BYTE;

    NOUN_NODE = .VERB_NODE[DBG$L_VERB_OBJECT_PTR];
    TYPE_NODE = .VERB_NODE[DBG$L_VERB_ADVERB_PTR];
    BASE_NODE = .TYPE_NODE[DBG$L_ADVERB_LINK];
    MODE_NODE = .BASE_NODE[DBG$L_ADVERB_LINK];

    SELECTONE .VERB_NODE[DBG$B_VERB_COMPOSITE] OF
	SET
	[EXAMINE]:
	    BEGIN
	    NEW_TYPE   = .TYPE_NODE[DBG$B_ADVERB_LITERAL];
	    NEW_SIZE   = .TYPE_NODE[DBG$L_ADVERB_VALUE];
	    RADIX      = .BASE_NODE[DBG$B_ADVERB_LITERAL];
	    FORMAT_ONE = 0;
	    END;

	[EXAMINE_SOURCE]:	0;

	[EXAMINE_CONDITION_VALUE]:
	    BEGIN
	    NEW_TYPE   = DSC$K_DTYPE_LU;
	    NEW_SIZE   = 4;
	    RADIX      = DBG$K_DEFAULT;
	    FORMAT_ONE = 1;
	    END;

	[EXAMINE_PSL]:
	    BEGIN
	    NEW_TYPE   = DSC$K_DTYPE_LU;
	    NEW_SIZE   = 4;
	    RADIX      = DBG$K_DEFAULT;
	    FORMAT_ONE = 2;
	    END;

	[EXAMINE_PSW]:
	    BEGIN
	    NEW_TYPE   = DSC$K_DTYPE_WU;
	    NEW_SIZE   = 2;
	    RADIX      = DBG$K_DEFAULT;
	    FORMAT_ONE = 3;
	    END;


	! Any other kind of the Verb Node is invalid, so we signal an internal
	! DEBUG coding error.
	!
	[OTHERWISE]:
	    $DBG_ERROR('DBGLEVEL3\EXAMINE');

	TES;


    ! ------
    !
    DO  BEGIN
	DBG$FLUSHBUF();

	IF .VERB_NODE[DBG$B_VERB_COMPOSITE] EQL EXAMINE_SOURCE
	THEN
	    BEGIN
	    LOCAL
		VAL_DESC	: REF DBG$VALDESC,
		START_ADDRESS,
		FINAL_ADDRESS;

	    DBG$PRIM_TO_VAL(.NOUN_NODE[DBG$L_NOUN_VALUE ],DBG$K_V_VALUE_DESC,VAL_DESC);
	    START_ADDRESS = .VAL_DESC[DBG$L_VALUE_POINTER];
	    DBG$PRIM_TO_VAL(.NOUN_NODE[DBG$L_NOUN_VALUE2],DBG$K_V_VALUE_DESC,VAL_DESC);
	    FINAL_ADDRESS = .VAL_DESC[DBG$L_VALUE_POINTER];

	    ! Output the source. The third parameter indicates that the
	    ! module name is to be displayed.

	    DBG$SRC_TYPE_PC_SOURCE(.START_ADDRESS,.FINAL_ADDRESS,TRUE,FALSE);

	    PRM_DESC = .NOUN_NODE[DBG$L_NOUN_VALUE2];
!	    Commented out because screen windown does EXAMINE/SOURCE and
!	    we don't want to save dot there.
!
!	    DBG$SAVE_LOC(.PRM_DESC);
	    END		! EXAMINE/SOURCE


	! ------
	!
	ELSE
	    BEGIN	! Data Examine
	    PRM_DESC = .NOUN_NODE[DBG$L_NOUN_VALUE];
	    END_DESC = .NOUN_NODE[DBG$L_NOUN_VALUE2];
	    DBG$COLLECT(.PRM_DESC);
	    DBG$COLLECT(.END_DESC);

	    IF (.END_DESC NEQ 0) AND (.PRM_DESC NEQ .END_DESC)
	    THEN
		BEGIN
		!+
		! We have a ranged examine (EXAMINE <prm>:<end>)
    		! Check for the case where the two endpoints are part
    		! of th same structure. We have to ensure that a number
    		! of conditions are met, e.g., they are both primaries,
    		! they are not aggregates, and so on.
		!-
		IF 	(.PRM_DESC[DBG$B_DHDR_TYPE] EQL DBG$K_PRIMARY_DESC)
					    AND
		   	(.END_DESC[DBG$B_DHDR_TYPE] EQL DBG$K_PRIMARY_DESC)
					    AND
		 	(.PRM_DESC[DBG$L_DHDR_SYMID0] EQL .END_DESC[DBG$L_DHDR_SYMID0])
					    AND
			(.NEW_TYPE EQL DBG$K_NOTYPE)
    					    AND
    		   	(NOT .PRM_DESC[DBG$V_DHDR_AGGR])
    					    AND	
    			(NOT .END_DESC[DBG$V_DHDR_AGGR])
					    AND
			(NOT .PRM_DESC[DBG$V_DHDR_SUBREF])
					    AND
			(NOT .END_DESC[DBG$V_DHDR_SUBREF])
		THEN
		    BEGIN
		    ! +
		    ! The start and end of the ranged examine appear to be
		    ! part of the same aggregate structure. Check that the
		    ! start is earlier than the end
		    ! -
		    IF PRIMARY_ORDER(.PRM_DESC,.END_DESC) GTR 0 THEN SIGNAL(DBG$_EXARANGE);
		    WHILE TRUE DO
			BEGIN
			LOCAL MARK;
			MARK = DBG$PUSH_TEMPMEM();
			DBG$PRINT_IDENTIFIER(.PRM_DESC);
			DBG$PRINT(UPLIT BYTE(%ASCIC '!AD!_'), 1, UPLIT BYTE(':'));
			DBG$PRIM_TO_VAL(.PRM_DESC,DBG$K_VALUE_DESC,VAL_DESC);
			IF .FORMAT_ONE NEQ 0 THEN VAL_DESC[DBG$V_DHDR_FORMAT] = .FORMAT_ONE;
			DBG$PRINT_VALUE(.VAL_DESC,.RADIX, .DBG$GL_SIGN_FLAG);
			DBG$NEWLINE();
			DBG$SAVE_LOC(.PRM_DESC);
			DBG$POP_TEMPMEM(.MARK);
			IF PRIMARY_ORDER(.PRM_DESC,.END_DESC) GEQ 0 THEN EXITLOOP;
			IF NOT MODIFY_PRIMARY(.PRM_DESC,0) THEN EXITLOOP;
			END;
		    END
		ELSE
		    BEGIN
		    ! +
		    ! The start and end are NOT part of the same aggregate.
		    ! -
		    LOCAL
			MARK,
			LAST_ADDR,
			NEXT_ADDR,
			DESC_TYPE,
			ADDR_DESC	: REF DBG$VALDESC,
			RDESC_ONE	: DBG$REGDESCR,
			RDESC_TWO	: DBG$REGDESCR,
    			LENGTH;

		    ADDR_DESC = DBG$CHANGE_DTYPE(.END_DESC,.NEW_TYPE,.NEW_SIZE);
		    RDESC_ONE = DBG$STA_ADDRESS_TO_REGDESCR(.ADDR_DESC[DBG$L_VALUE_POINTER]);
		    LAST_ADDR = .ADDR_DESC[DBG$L_VALUE_POINTER];
		    ADDR_DESC = DBG$CHANGE_DTYPE(.PRM_DESC,.NEW_TYPE,.NEW_SIZE);
		    RDESC_TWO = DBG$STA_ADDRESS_TO_REGDESCR(.ADDR_DESC[DBG$L_VALUE_POINTER]);
		    IF ((.RDESC_ONE XOR .RDESC_TWO) AND %X'FFFF00FC') NEQ 0
		    THEN
			SIGNAL(DBG$_EXARANGE);

		    IF .LAST_ADDR LSSA .ADDR_DESC[DBG$L_VALUE_POINTER]
		    THEN
			SIGNAL(DBG$_EXARANGE);

		    IF (.ADDR_DESC[DBG$B_VALUE_CLASS] EQL DSC$K_CLASS_UBS)
		    THEN
			SIGNAL(DBG$_ILLTYPE);

		    DESC_TYPE = DBG$K_VALUE_DESC;
		    IF (.ADDR_DESC[DBG$B_VALUE_DTYPE] EQL DSC$K_DTYPE_ZEM) OR
		       (.ADDR_DESC[DBG$B_VALUE_DTYPE] EQL DSC$K_DTYPE_ZI)
		    THEN
			DESC_TYPE = DBG$K_V_VALUE_DESC;


		    ! ------
		    !
		    WHILE TRUE DO
			BEGIN
			MARK = DBG$PUSH_TEMPMEM();
			DBG$PRINT_IDENTIFIER(.ADDR_DESC);
			DBG$PRINT(UPLIT BYTE(%ASCIC '!AD!_'),1,UPLIT BYTE(':'));
			DBG$PRIM_TO_VAL(.ADDR_DESC,.DESC_TYPE,VAL_DESC);
			IF .FORMAT_ONE NEQ 0 THEN VAL_DESC[DBG$V_DHDR_FORMAT] = .FORMAT_ONE;
			DBG$PRINT_VALUE(.VAL_DESC,.RADIX, .DBG$GL_SIGN_FLAG);
			DBG$NEWLINE();
			DBG$POP_TEMPMEM(.MARK);

			! Get the increment we will add to the address for
			! the next line of the ranged examine. If the increment
			! is zero then signal an informational and get out of the loop.
			!
		        LENGTH = (DBG$DATA_LENGTH(ADDR_DESC[DBG$A_VALUE_VMSDESC]) + (%BPUNIT-1))/%BPUNIT;
			IF .LENGTH EQL 0
			THEN
			    BEGIN
			    SIGNAL(DBG$_ZEROINCR); ! Informational
			    EXITLOOP;
			    END;

			NEXT_ADDR = .ADDR_DESC[DBG$L_VALUE_POINTER] + .LENGTH;
			IF .NEXT_ADDR GTRA .LAST_ADDR THEN EXITLOOP;
			ADDR_DESC[DBG$L_VALUE_POINTER] = .NEXT_ADDR;
			IF ((.ADDR_DESC[DBG$B_VALUE_DTYPE] EQL DSC$K_DTYPE_ZEM)
			 OR (.ADDR_DESC[DBG$B_VALUE_DTYPE] EQL DSC$K_DTYPE_ZI))
			  THEN
			    BEGIN
			    IF DBG$IS_IT_ENTRY(.NEXT_ADDR)
			      THEN ADDR_DESC[DBG$B_VALUE_DTYPE]  = DSC$K_DTYPE_ZEM
			      ELSE ADDR_DESC[DBG$B_VALUE_DTYPE]  = DSC$K_DTYPE_ZI;
			    ADDR_DESC[DBG$W_VALUE_LENGTH] = DBG$INS_DECODE(.NEXT_ADDR,FALSE) - .NEXT_ADDR;
			    END
			  ELSE
			    ADDR_DESC[DBG$W_VALUE_LENGTH] = FIX_UP_LENGTH(ADDR_DESC[DBG$A_VALUE_VMSDESC]);
			END;
		    DBG$SAVE_LOC(.ADDR_DESC);
		    END;
		END
	    ELSE
		BEGIN


		! In the case where prm_desc is a volatile value descriptor
		! representing an absolute address, the print_identifier
		! will attempt to symbolize this address to a primary. If
		! it succeeds, it will return the newly-constructed primary..
		! In all other cases, it just returns the descriptor we pass
		! into it, unchanged.
		!
		PRM_DESC = DBG$PRINT_IDENTIFIER(.PRM_DESC);
		DBG$SAVE_LOC(.PRM_DESC);
		IF .NEW_TYPE EQL DBG$K_NOTYPE AND .PRM_DESC[DBG$V_DHDR_AGGR]
		THEN
		    DBG$PRINT_AGGREGATE(.PRM_DESC,.RADIX)
		ELSE
		    BEGIN
		    DBG$PRINT(UPLIT BYTE(%ASCIC '!AD!_'), 1, UPLIT BYTE(':'));
		    VAL_DESC = DBG$CHANGE_DTYPE(.PRM_DESC,.NEW_TYPE,.NEW_SIZE);
		    FORMAT_TWO = .FORMAT_ONE;
		    IF .NEW_TYPE NEQ DBG$K_NOTYPE
		    THEN
			DBG$SAVE_LOC(.PRM_DESC,VAL_DESC[DBG$A_VALUE_VMSDESC])
		    ELSE IF (.FORMAT_ONE EQL 0) AND (.RADIX EQL DBG$K_DEFAULT)
			  AND (.VAL_DESC[DBG$B_VALUE_CLASS] NEQ DSC$K_CLASS_UBS)
			   AND (.VAL_DESC[DBG$L_VALUE_POINTER] EQLA DBG$REG_VALUES[16])
			    THEN FORMAT_TWO = 2;

		    IF .VAL_DESC[DBG$B_VALUE_DTYPE] NEQ DSC$K_DTYPE_ZI
		    THEN
    			BEGIN
			DBG$PRIM_TO_VAL(.VAL_DESC,DBG$K_VALUE_DESC,VAL_DESC);
    			DBG$DO_MAPPING(.VAL_DESC);
    			END;

		    IF .FORMAT_TWO NEQ 0 THEN VAL_DESC[DBG$V_DHDR_FORMAT] = .FORMAT_TWO;
		    DBG$PRINT_VALUE(.VAL_DESC,.RADIX,.DBG$GL_SIGN_FLAG);
		    DBG$NEWLINE();
		    END;
		END;
	    END;
	END UNTIL (NOUN_NODE = .NOUN_NODE[DBG$L_NOUN_LINK]) EQL 0;

    RETURN STS$K_SUCCESS;
    END;

GLOBAL ROUTINE DBG$NEXTLOC(PRM_DESC) =
!
! FUNCTION
!	----------------------------
!
! INPUTS
!	----------------------------
!
! OUTPUTS
!	----------------------------
!

    BEGIN

    MAP
	PRM_DESC: REF DBG$PRIMARY;	! Pointer to Primary Descriptor

    LOCAL
	BYTE_OFFSET,
	LENGTH,
	REG_DESC: DBG$REGDESCR,
	STATUS,
	VAL_DESC: REF DBG$VALDESC;



    ! ------
    !
    STATUS = MODIFY_PRIMARY(.PRM_DESC,0);
    IF .STATUS THEN RETURN .PRM_DESC;
    IF .DBG$GL_CURLOC_VMSDESC NEQ 0
    THEN
	BEGIN
	VAL_DESC = DBG$MAKE_VAL_DESC(.DBG$GL_CURLOC_VMSDESC, DBG$K_V_VALUE_DESC);
	VAL_DESC[DBG$B_DHDR_LANG]   = .PRM_DESC[DBG$B_DHDR_LANG];
	VAL_DESC[DBG$L_DHDR_SYMID0] = .PRM_DESC[DBG$L_DHDR_SYMID0];
	END

    ELSE
	BEGIN
	IF .STATUS EQL 2 THEN SIGNAL(DBG$_NOSUCC);
	DBG$PRIM_TO_VAL(.PRM_DESC, DBG$K_V_VALUE_DESC, VAL_DESC);
	END;

    IF (.VAL_DESC[DBG$B_VALUE_CLASS] EQL DSC$K_CLASS_UBS)
    THEN
	SIGNAL(DBG$_NOSUCC);

    LENGTH = (DBG$DATA_LENGTH(VAL_DESC[DBG$A_VALUE_VMSDESC]) - 1)/%BPUNIT + 1;
    REG_DESC = DBG$STA_ADDRESS_TO_REGDESCR(.VAL_DESC[DBG$L_VALUE_POINTER]);
    IF .REG_DESC NEQ 0
    THEN
	BEGIN
	BYTE_OFFSET = 4*.REG_DESC[DBG$B_REGD_REGNUM]
		      + .REG_DESC[DBG$V_REGD_OFFSET]
		      + .LENGTH + .DBG$GW_DFLTLENG;
	IF (.BYTE_OFFSET GTR 16*%UPVAL) AND
	    ((.DBG$GW_DFLTLENG NEQ 2) OR (.DBG$GW_DFLTLENG NEQ 4) OR
	    (.BYTE_OFFSET NEQ (16*%UPVAL + .DBG$GW_DFLTLENG)))
	THEN
	    SIGNAL(DBG$_NOSUCC);

	END;


    ! Initialize the Value Descriptor to VMS descriptor class Z (unknown) and
    ! set the pointer to the next location to be the current location plus the
    ! length of the current object.
    !
    VAL_DESC[DBG$B_VALUE_CLASS]   = DSC$K_CLASS_Z;
    VAL_DESC[DBG$L_VALUE_POINTER] = .VAL_DESC[DBG$L_VALUE_POINTER] + .LENGTH;


    ! If the data type is instruction or entry point, determine the type of the
    ! next location by seeing if it is an instruction or entry mask.  Also com-
    ! pute its length by interpreting the instruction at that location.
    !
    IF (.VAL_DESC[DBG$B_VALUE_DTYPE] EQL DSC$K_DTYPE_ZI) OR
       (.VAL_DESC[DBG$B_VALUE_DTYPE] EQL DSC$K_DTYPE_ZEM)
    THEN
	BEGIN
	IF DBG$IS_IT_ENTRY(.VAL_DESC[DBG$L_VALUE_POINTER])
	THEN
	    VAL_DESC[DBG$B_VALUE_DTYPE]  = DSC$K_DTYPE_ZEM

	ELSE
	    VAL_DESC[DBG$B_VALUE_DTYPE]  = DSC$K_DTYPE_ZI;

	VAL_DESC[DBG$W_VALUE_LENGTH] =
			DBG$INS_DECODE(.VAL_DESC[DBG$L_VALUE_POINTER], FALSE) -
			.VAL_DESC[DBG$L_VALUE_POINTER];
	END


    ! The next location is not an instruction or entry mask.  It is thus a
    ! data object and we set up the Value Descriptor accordingly.
    !
    ELSE
	BEGIN
	VAL_DESC[DBG$B_DHDR_FCODE]   =  RST$K_TYPE_DESCR;
	VAL_DESC[DBG$V_DHDR_FORMAT]  =  0;
	VAL_DESC[DBG$B_VALUE_CLASS]  =  DSC$K_CLASS_S;
	VAL_DESC[DBG$B_VALUE_DTYPE]  = .DBG$GL_DFLTTYP;
	VAL_DESC[DBG$W_VALUE_LENGTH] = .DBG$GW_DFLTLENG;
	END;


    ! Return a pointer to the Value Descriptor for the next location.
    !
    RETURN .VAL_DESC;

    END;

GLOBAL ROUTINE DBG$PREVLOC(PRM_DESC) =
!
! FUNCTION
!	This routine finds the "previous location", denoted in the command
!	language as %PREVLOC or ^.  It accepts a Primary Descriptor for the
!	current location as input and returns either a Primary Descriptor or
!	a Volatile Value Descriptor for the previous location as output.  If
!	the current location is a structured object of some sort (like an
!	array), MODIFY_PRIMARY is called to find the logical predecessor and
!	the modified Primary Descriptor is returned.  Otherwise, this routine
!	determines the previous instruction location or the previous data
!	location and returns a Volatile Value Descriptor for that location.
!
! INPUTS
!	PRM_DESC - A pointer to the input Primary Descriptor for the location
!		  whose logical predecessor is to be computed.
!
! OUTPUTS
!	A pointer to the Primary Descriptor or Volatile Value Descriptor for
!		  the logical predecessor location is returned as this
!		  routine's value.
!

    BEGIN

    MAP
	PRM_DESC: REF DBG$PRIMARY;	! Pointer to Primary Descriptor

    LOCAL
	ADDRESS,			! Address of the current location - 1
	DUMMY,				! Dummy routine argument
    	LENGTH,
	LINE,				! Line number of the last instruction
	NEW_ADDR,			! Addess of the current instruction
	OLD_ADDR,			! Address of previous instruction
	PC_BEG,				! Beginning PC of current source line
	PC_END,				! Ending PC of current source line
	STATUS,
	STMT,				! Statement number of last instruction
	SYMID: REF RST$ENTRY,		! The SYMID of the nearest preceding
					!      symbol (used for instructions)
	REG_DESC: DBG$REGDESCR,
	VAL_DESC: REF DBG$VALDESC;	! Pointer to returned Value Descriptor



    ! If the input Primary Descriptor describes a structure object, like an
    ! array or record, let MODIFY_PRIMARY modify the Primary Descriptor to
    ! describe the logical predecessor.  Then return that Primary.
    !
    STATUS = MODIFY_PRIMARY(.PRM_DESC, 1);
    IF .STATUS THEN RETURN .PRM_DESC;


    ! If there is a defined "current location" (%CURLOC), then use the Primary
    ! or Value Descriptor for that entity to set up a Volatile Value Descriptor
    ! for the previous location.
    !
    IF .DBG$GL_CURLOC_VMSDESC NEQ 0
    THEN
	BEGIN
	VAL_DESC = DBG$MAKE_VAL_DESC(.DBG$GL_CURLOC_VMSDESC, DBG$K_V_VALUE_DESC);
	VAL_DESC[DBG$B_DHDR_LANG]   = .PRM_DESC[DBG$B_DHDR_LANG];
	VAL_DESC[DBG$L_DHDR_SYMID0] = .PRM_DESC[DBG$L_DHDR_SYMID0];
	END


    ! But if no current location is defined, give an error message or use the
    ! input Primary Descriptor to set up the previous location descriptor.
    !
    ELSE
	BEGIN
	IF .STATUS EQL 2 THEN SIGNAL(DBG$_NOPRED);
	DBG$PRIM_TO_VAL(.PRM_DESC, DBG$K_V_VALUE_DESC, VAL_DESC);
	END;


    ! There is no logical successor for an unaligned bit string, so for that
    ! case we signal an error.
    !
    IF .VAL_DESC[DBG$B_VALUE_CLASS] EQL DSC$K_CLASS_UBS
    THEN
	SIGNAL(DBG$_NOPRED);


    ! -----
    !
    LENGTH = (DBG$DATA_LENGTH(VAL_DESC[DBG$A_VALUE_VMSDESC]) - 1)/%BPUNIT + 1;
    REG_DESC = DBG$STA_ADDRESS_TO_REGDESCR(.VAL_DESC[DBG$L_VALUE_POINTER]);
    IF (.REG_DESC NEQ 0) AND (.REG_DESC<W_> LSSU (%X'00B4' + .DBG$GW_DFLTLENG))
    THEN
	SIGNAL(DBG$_NOPRED);


    ! Initialize the DTYPE of the logical predecessor to be type Z (unknown)
    ! and assume its address is one byte before the current location.  This
    ! may get changed below if appropriate.
    !
    VAL_DESC[DBG$B_VALUE_CLASS] = DSC$K_CLASS_Z;
    ADDRESS = .VAL_DESC[DBG$L_VALUE_POINTER] - 1;


    ! If the type of the current object is instruction or entry mask, try to
    ! locate the previous instruction.
    !
    IF (.VAL_DESC[DBG$B_VALUE_DTYPE] EQL DSC$K_DTYPE_ZI) OR
       (.VAL_DESC[DBG$B_VALUE_DTYPE] EQL DSC$K_DTYPE_ZEM)
    THEN
	BEGIN
	OLD_ADDR = .ADDRESS;


	! First try to symbolize the current location - 1 byte (the contents of
	! ADDRESS) to find the nearest routine, block, or label preceding the
	! current instruction.  If no such symbol is found, we just leave the
	! address as the current instruction address - 1; there is no way we can
	! locate the true previous instruction.
	!
	STATUS = DBG$PC_TO_SYMID(.ADDRESS, SYMID);
	IF .STATUS AND (.SYMID NEQ 0)
	THEN
	    BEGIN


	    ! A symbol preceding the current instruction was found.  If this
	    ! is an instruction symbol (a routine, block, or label), save its
	    ! address for the forward scan to the desired instruction.  However,
	    ! if a line number preceding the current instruction can be found,
	    ! use that address instead for a shorter forward scan.
	    !
	    IF (.SYMID[RST$B_KIND] EQL RST$K_ROUTINE) OR
	       (.SYMID[RST$B_KIND] EQL RST$K_BLOCK)   OR
	       (.SYMID[RST$B_KIND] EQL RST$K_LABEL)
	    THEN
		BEGIN
		OLD_ADDR = .SYMID[RST$L_STARTADDR];
		DUMMY = .SYMID;
		IF DBG$PC_TO_LINE_LOOKUP(.ADDRESS,
					LINE, STMT, PC_BEG, PC_END, DUMMY)
		THEN
		    OLD_ADDR = .PC_BEG;

		END;

	    END;			! End of code if we found a symbolization


	! We now some address where to start the forward scan that looks for
	! the previous instruction.  Scan forward from that address until the
	! desired previous instruction is found.
	!
	WHILE TRUE DO
	    BEGIN
	    NEW_ADDR = DBG$INS_DECODE(.OLD_ADDR, FALSE);
	    IF .NEW_ADDR GTRA .ADDRESS THEN EXITLOOP;
	    OLD_ADDR = .NEW_ADDR;
	    END;


	! Fill the address and length of the found previous instruction into
	! the Value Descriptor.  Also determine if this location is an entry
	! mask--if so, set the DTYPE to be ZEM instead of ZI.
	!
	VAL_DESC[DBG$L_VALUE_POINTER] = .OLD_ADDR;
	VAL_DESC[DBG$W_VALUE_LENGTH]  = .NEW_ADDR - .OLD_ADDR;
	VAL_DESC[DBG$B_VALUE_DTYPE] = DSC$K_DTYPE_ZI;
	IF DBG$IS_IT_ENTRY(.OLD_ADDR)
	THEN
	    VAL_DESC[DBG$B_VALUE_DTYPE] = DSC$K_DTYPE_ZEM;

	END				! End of code for previous instruction


    ! The current location is not an instruction location.  We therefore set
    ! up the Value Descriptor for a data object.
    !
    ELSE
	BEGIN
	VAL_DESC[DBG$B_DHDR_FCODE]    =  RST$K_TYPE_DESCR;
	VAL_DESC[DBG$V_DHDR_FORMAT]   =  0;
	VAL_DESC[DBG$B_VALUE_CLASS]   =  DSC$K_CLASS_S;
	VAL_DESC[DBG$B_VALUE_DTYPE]   = .DBG$GL_DFLTTYP;
	VAL_DESC[DBG$W_VALUE_LENGTH]  = .DBG$GW_DFLTLENG;
	VAL_DESC[DBG$L_VALUE_POINTER] = .VAL_DESC[DBG$L_VALUE_POINTER] - .LENGTH;
	END;


    ! Return a pointer to the Volatile Value Descriptor for the previous
    ! location.
    !
    RETURN .VAL_DESC;

    END;

ROUTINE MODIFY_PRIMARY(PRM_DESC: REF DBG$PRIMARY, DIRECTION) =
!
! FUNCTION
!	This routine takes a Primary Descriptor and attempts to find
!	the logical successor (DIRECTION=0) or logical predecessor 
!	(DIRECTION=1). For example, the Primary for X(0) might
!	be modified to be a Primary for X(1).
!
! INPUTS
!	PRM_DESC - points to a Primary Descriptor
!	DIRECTION - if 0, we want the logical successor.
!		    if 1, we want the logical predecessor.
!
! OUTPUTS
!	1 is returned if this routine is successful, and
!	the Primary pointed to by PRM_DESC is modified.
!	If this routine fails, it returns 0 or 2.
!

    BEGIN

    MAP
	PRM_DESC: REF DBG$PRIMARY;	! Pointer to input Primary Descriptor

    BUILTIN
	INSQUE,
	REMQUE;

    LABEL
	PASS,
	SCAN;

    LOCAL
	COMP_FLAG: BYTE,
	ERROR_STATUS,
	DUMMY,
	ROOT_ADR,
	SUB_NODE: REF DBG$PRIM_NODE,
	SYM_NAME: REF VECTOR[,BYTE];



    ! Save away the "current" primary. This is used by our stack
    ! machine code in RSTACCESS to evaluate the "push inner record
    ! address" and "push outer record address" instructions.
    !
    DBG$GL_CURRENT_PRIMARY = .PRM_DESC;

    ! Give up if the descriptor is not a Primary we can modify
    ! to get logical successor or predecessor.
    !
    IF (.PRM_DESC[DBG$B_DHDR_TYPE] NEQ DBG$K_PRIMARY_DESC) OR
       ((.PRM_DESC[DBG$B_DHDR_KIND] NEQ RST$K_DATA) AND 
	(.PRM_DESC[DBG$B_DHDR_KIND] NEQ RST$K_TYPCOMP)) OR
       (.PRM_DESC[DBG$V_DHDR_SUBREF])
    THEN
	RETURN 0;

    ERROR_STATUS = 0;

    WHILE TRUE DO
PASS:	BEGIN


	! This loop steps to the last/next component in the data aggregate.
	! In most cases this loop is executed exactly once. However to deal
	! properly with variant records it is sometimes necessary to repeat
	! this entire process until we find a valid component.  Examples of
	! invalid components are :
	!	An anonymous (zero-length) PASCAL Tag Field
	!	A VARIANT SET with no TAG, or an out-of-range Tag Value
	!
	ROOT_ADR = SUB_NODE = PRM_DESC[DBG$A_PRIM_FLINK];
SCAN:	    BEGIN
	    !+
	    ! Scan the entire primary backwards until we find a group
	    ! item (Array, Record or Variant) which has more components
	    ! left in it.
	    !-
	    WHILE (SUB_NODE = .SUB_NODE[DBG$L_PNODE_BLINK]) NEQ .ROOT_ADR
	     DO IF .SUB_NODE[DBG$V_PNODE_EVAL] THEN
	      SELECTONE .SUB_NODE[DBG$B_PNODE_FCODE] OF
		SET
		[RST$K_TYPE_ARRAY]:
		    BEGIN
		    LOCAL S,S_VECT	: REF DBG$PRIM_NODE_SUBS;

    		    ! The following code increments or decrements the 
    		    ! subscript vector. This must be incremented like
    		    ! an odometer in a car; that is, normally we 
    		    ! just increment the last one, but if that is 
    		    ! at its upper limit then set it back to the lower
    		    ! limit and attempt to increment the next one, and
    		    ! so on. We also have to take into account arrays
    		    ! that are stored in column order (first subscript
    		    ! varies fastest).
    		    ! 
		    ERROR_STATUS = 2;
		    S_VECT = SUB_NODE[DBG$A_PNARR_SVECTOR];
		    INCR DIMENSION FROM 1 TO .SUB_NODE[DBG$B_PNARR_DIMCNT] DO
			BEGIN
			S = (IF .SUB_NODE[DBG$V_PNARR_COLUMN]
				THEN .DIMENSION - 1
				ELSE .SUB_NODE[DBG$B_PNARR_DIMCNT] - .DIMENSION);

			IF .DIRECTION EQL 0		! 0 = NEXTLOC, 1 = PREVLOC
			THEN

    			    ! Logical successor.
    			    !
			    BEGIN

    			    ! Check for being at the upper bound.
    			    !
			    IF .S_VECT[.S,DBG$L_PNSUB_SVALUE] EQL .S_VECT[.S,DBG$L_PNSUB_UBOUND]
			    THEN
    			        BEGIN

				! If we have no more dimensions and we
				! are at the top subnode (i.e., there are
				! no "higher" levels at which we can
				! increment something) then go ahead
				! and increment it, (but giving a warning 
    				! that we are at the upper bound).
    				! For example, if X is a one-dimensional
    			  	! array from 1 to 3, and we want the logical
    				! successor of X(3), we'll go ahead and return
    				! X(4) but we'll give an informational saying
    				! you have walked past the upper bound.
    				! But if X were 2-dimensional, say 1:3 by 1:3,
    				! and you want the successor of X(1,3),
    				! then return X(2,1) and not X(1,4).
				! Or if X were a record of arrays,
			        ! and X.A(3) was the upper bound, then
				! you would want to go to the next 
				! record component, say X.B, instead of
				! going to X.A(4).
				! That is the reason for the checks for
				! DIMENSION EQL DIMCNT and BLINK EQL
				! ROOT_ADR.
				!
				IF (.DIMENSION EQL .SUB_NODE[DBG$B_PNARR_DIMCNT]) AND
	    			   (.SUB_NODE[DBG$L_PNODE_BLINK] EQL .ROOT_ADR)
			   	THEN
				    BEGIN
    				    SIGNAL(DBG$_SUBSCRNG, 3, UPLIT BYTE(%ASCIC 'upper'), .DIMENSION, .S_VECT[.S,DBG$L_PNSUB_UBOUND]);
				    S_VECT[.S,DBG$L_PNSUB_SVALUE]  =  .S_VECT[.S,DBG$L_PNSUB_SVALUE] + 1;
				    LEAVE SCAN;
				    END
    				ELSE    	

    				    ! Set back to lower bound.
    				    !
				    S_VECT[.S,DBG$L_PNSUB_SVALUE]  =  .S_VECT[.S,DBG$L_PNSUB_LBOUND]
    				END
			    ELSE
				BEGIN

    				! Increment and leave loop.
    				!
				S_VECT[.S,DBG$L_PNSUB_SVALUE]  =  .S_VECT[.S,DBG$L_PNSUB_SVALUE] + 1;
				LEAVE SCAN;
				END;
			    END
			ELSE

    			    ! Logical predecessor.
    			    !
			    BEGIN
			    IF .S_VECT[.S,DBG$L_PNSUB_SVALUE] EQL .S_VECT[.S,DBG$L_PNSUB_LBOUND]
			    THEN
    				BEGIN

    				! If we have no more dimensions then go ahead
    				! and decrement it, (but giving a warning 
    				! that we are at the lower bound).
    				! For example, if X is a one-dimensional
    			  	! array from 1 to 3, and we want the logical
    				! predecessor of X(1), we'll go ahead and return
    				! X(0) but we'll give an informational saying
    				! you have walked past the upper bound.
    				! But if X were 2-dimensional, say 1:3 by 1:3,
    				! and you want the predecessor of X(3,1),
    				! then return X(2,3) and not X(3,0).
    				! That is the reason for this check for
    				! DIMENSION EQL DIMCNT.
    				!
				IF (.DIMENSION EQL .SUB_NODE[DBG$B_PNARR_DIMCNT]) AND
	    			   (.SUB_NODE[DBG$L_PNODE_BLINK] EQL .ROOT_ADR)
			   	THEN
				    BEGIN
    				    SIGNAL(DBG$_SUBSCRNG, 3, UPLIT BYTE(%ASCIC 'lower'), .DIMENSION, .S_VECT[.S,DBG$L_PNSUB_UBOUND]);
				    S_VECT[.S,DBG$L_PNSUB_SVALUE]  =  .S_VECT[.S,DBG$L_PNSUB_SVALUE] - 1;
				    LEAVE SCAN;
				    END
    				ELSE    	

    				    ! Set back to upper bound.
    				    !
				    S_VECT[.S,DBG$L_PNSUB_SVALUE]  =  .S_VECT[.S,DBG$L_PNSUB_UBOUND]
    				END
			    ELSE
				BEGIN

    				! Decrement and leave loop.
    				!
				S_VECT[.S,DBG$L_PNSUB_SVALUE]  =  .S_VECT[.S,DBG$L_PNSUB_SVALUE] - 1;
				LEAVE SCAN;
				END;
			    END;
			END;
		    END;

		[RST$K_TYPE_RECORD,RST$K_TYPE_VARIANT]:
		    BEGIN
		    ERROR_STATUS = 2;
		    IF .DIRECTION EQL 0		! 0 = NEXTLOC, 1 = PREVLOC
		    THEN

    			! Logical successor.
    			!
			BEGIN

    			! If we can go to the next component, do so and exit 
    			! the loop.
    			!
			IF .SUB_NODE[DBG$W_PNREC_INDEX] LSSU .SUB_NODE[DBG$W_PNREC_NCOMPS]
			THEN
			    BEGIN
			    SUB_NODE[DBG$W_PNREC_INDEX] = .SUB_NODE[DBG$W_PNREC_INDEX] + 1;
			    LEAVE SCAN;
			    END;
			END
		    ELSE

    			! Logical predecessor.
    			!
			BEGIN

    			! If we can get to the previous component, do so
    			! and exit the loop.
    			!
			IF .SUB_NODE[DBG$W_PNREC_INDEX] GTRU 1
			THEN
			    BEGIN
			    SUB_NODE[DBG$W_PNREC_INDEX] = .SUB_NODE[DBG$W_PNREC_INDEX] - 1;
			    LEAVE SCAN;
			    END
			END;
		    END;
		[OTHERWISE]:0;
		TES;

    	    ! If we fall through to here without succeeding in incrementing
    	    ! or decrementing anything, then error status will still be
    	    ! 0 or 2 and we return it, indicating we did not succeed.
    	    !
	    RETURN .ERROR_STATUS;
	    END;			! End of block scan

	!+
	! The following test is a special case so that if the last item examined
	! was an array element we just examine the next (or previous) element of
	! the array, even if this is an aggregate (e.g. a record).  In all other
	! cases we will step down to an individual component of the aggregate.
	!-
	IF (.SUB_NODE[DBG$L_PNODE_FLINK] EQLA .PRM_DESC[DBG$L_PRIM_BLINK])
				    AND
	   (.SUB_NODE[DBG$B_PNODE_FCODE] EQL RST$K_TYPE_ARRAY) 

	  THEN RETURN 1;


	! We have found the composite entry we are going to modify. Strip off
	! all subsequent primary sub-nodes, and then add new sub_nodes to get
	! a primary which describes a single data item.
	!
	WHILE .SUB_NODE[DBG$L_PNODE_FLINK] NEQA .ROOT_ADR DO
	    REMQUE(.SUB_NODE[DBG$L_PNODE_FLINK],DUMMY);

	IF .PRM_DESC[DBG$V_DHDR_TMPREF] THEN
	    BEGIN
	    PRM_DESC[DBG$V_DHDR_TMPREF] = FALSE;
	    PRM_DESC[DBG$V_DHDR_SUBREF] = FALSE;
	    PRM_DESC[DBG$W_PRIM_OFFSET] = 0;
	    PRM_DESC[DBG$W_PRIM_LENGTH] = 0;
	    END;

	COMP_FLAG = FALSE;

	WHILE TRUE DO
	    BEGIN
	    LOCAL SYMID,TYPEID,FCODE,KIND;
	    SELECTONE .SUB_NODE[DBG$B_PNODE_FCODE] OF
		SET
		[RST$K_TYPE_ARRAY]:
		    BEGIN
		    IF .COMP_FLAG THEN
			BEGIN
			LOCAL S_VECT : REF DBG$PRIM_NODE_SUBS;
			S_VECT = SUB_NODE[DBG$A_PNARR_SVECTOR];
			DECR S FROM .SUB_NODE[DBG$B_PNARR_DIMCNT]-1 TO 0 DO
			  S_VECT[.S,DBG$L_PNSUB_SVALUE]  =  .S_VECT[.S,DBG$L_PNSUB_UBOUND];
			END;
		    SYMID = 0;
		    KIND = RST$K_DATA;
		    DBG$STA_SYMTYPE(.SUB_NODE[DBG$L_PNARR_CELLTYPE],FCODE,TYPEID);
		    END;

		[RST$K_TYPE_RECORD,RST$K_TYPE_VARIANT]:
		    BEGIN
		    LOCAL N_COMPS,S_VECT : REF VECTOR[,LONG];
		    IF .SUB_NODE[DBG$B_PNODE_FCODE] EQL RST$K_TYPE_RECORD
		      THEN DBG$STA_TYP_RECORD(.SUB_NODE[DBG$L_PNODE_TYPEID],N_COMPS,S_VECT,DUMMY)
		      ELSE
			BEGIN
			!+
			!  We have a variant set.  If the TYPEID field is non-zero this is
			! a new variant sub node (added by us on the last pass), and so we
			! need to obtain the current value of the TAG field. A zero-length
			! tag field (or an illegal tag value) cause this entire variant to
			! be ignored.
			!
			IF (TYPEID = .SUB_NODE[DBG$L_PNODE_TYPEID]) NEQ 0 THEN
			    BEGIN
			    LOCAL TAG,MARK,TYPE,CODE,
				  VAL_DESC : REF DBG$VALDESC,
				  VARIANT  : REF RST$VAR_ENTRY;
			    MAP   TYPEID   : REF RST$ENTRY;

			    REMQUE(.SUB_NODE,SUB_NODE);
			    IF (TAG  = .TYPEID[RST$L_VARTAGPTR]) EQL 0 THEN LEAVE PASS;
			    DBG$STA_SYMNAME(.TAG,SYM_NAME);
			    IF .SYM_NAME[0] EQL 0 THEN LEAVE PASS;
			    !+
			    ! We now need to obtain the actual tag value. This is done
			    ! by stripping off the VARIANT sub-node,  and adding a new
			    ! primary sub-node describing the Tag field.  We then call
			    ! dbg$prim_to_val to get a Debug Value descriptor, extract
			    ! the tag value, and restore the state of the primary.
			    !-
			    MARK = DBG$PUSH_TEMPMEM();
			    DBG$STA_SYMTYPE(.TAG,CODE,TYPE);
			    DBG$BUILD_PRIMARY_SUBNODE(.PRM_DESC,RST$K_DATA,.TAG,.CODE,.TYPE,0);
			    DBG$PRIM_TO_VAL(.PRM_DESC,DBG$K_VALUE_DESC,VAL_DESC);
			    TAG = .VAL_DESC[DBG$L_VALUE_VALUE0];
			    REMQUE(.PRM_DESC[DBG$L_PRIM_BLINK],DUMMY);
			    DBG$POP_TEMPMEM(.MARK);
			    IF (VARIANT = DBG$STA_VARIANT_SELECT(.TAG,.TYPEID)) EQL 0 THEN LEAVE PASS;
			    SUB_NODE[DBG$V_PNVAR_VALID]   = TRUE;
			    SUB_NODE[DBG$W_PNVAR_INDEX]   = 1;
			    SUB_NODE[DBG$L_PNODE_TYPEID]  = 0;
			    SUB_NODE[DBG$L_PNVAR_TAGID]   =  .TYPEID[RST$L_VARTAGPTR];
			    SUB_NODE[DBG$W_PNVAR_NCOMPS]  = .VARIANT[RST$L_VAR_COMPCNT];
			    SUB_NODE[DBG$L_PNVAR_COMPLST] =  VARIANT[RST$A_VAR_COMPLST];
			    SUB_NODE[DBG$L_PNVAR_DSTPTR]  = .VARIANT[RST$L_VAR_DSTPTR];
			    INSQUE(.SUB_NODE,.PRM_DESC[DBG$L_PRIM_BLINK]);
			    END;
			N_COMPS = .SUB_NODE[DBG$W_PNVAR_NCOMPS];
			S_VECT  = .SUB_NODE[DBG$L_PNVAR_COMPLST];
			END;
		    IF .COMP_FLAG THEN SUB_NODE[DBG$W_PNREC_INDEX] = .N_COMPS;
		    SYMID = .S_VECT[.SUB_NODE[DBG$W_PNREC_INDEX]-1];
		    DBG$STA_SYMKIND(.SYMID,KIND);
		    IF .KIND EQL RST$K_VARIANT
		      THEN
			BEGIN
			FCODE  = RST$K_TYPE_VARIANT;
			TYPEID = .SYMID;
			SYMID  = 0;
			END
		      ELSE
			DBG$STA_SYMTYPE(.SYMID,FCODE,TYPEID);
		    END;

		[OTHERWISE]:
		    EXITLOOP;
		TES;
	    SUB_NODE[DBG$V_PNODE_EVAL] = TRUE;
	    DBG$BUILD_PRIMARY_SUBNODE(.PRM_DESC,.KIND,.SYMID,.FCODE,.TYPEID, 0);
	    SUB_NODE = .PRM_DESC[DBG$L_PRIM_BLINK];
	    COMP_FLAG = .DIRECTION;
	    END;

	IF .SUB_NODE[DBG$L_PNODE_SYMID] EQL 0 THEN EXITLOOP;
	DBG$STA_SYMNAME(.SUB_NODE[DBG$L_PNODE_SYMID],SYM_NAME);
	IF .SYM_NAME[0] NEQ 0 THEN EXITLOOP;
	END;

    RETURN 1;
    END;			! End of modify_primary

ROUTINE PRIMARY_ORDER(PRIM_1: REF DBG$PRIMARY, PRIM_2: REF DBG$PRIMARY) =
!
! FUNCTION
!	----------------------------
!
! INPUTS
!	----------------------------
!
! OUTPUTS
!	----------------------------
!

    BEGIN
    LOCAL
	NODE_1	: REF DBG$PRIM_NODE,
	NODE_2	: REF DBG$PRIM_NODE,
	VALUE_1,
	VALUE_2;

    NODE_1 = .PRIM_1[DBG$L_PRIM_FLINK];
    NODE_2 = .PRIM_2[DBG$L_PRIM_FLINK];

    WHILE TRUE DO
	BEGIN

	SELECTONE .NODE_1[DBG$B_PNODE_FCODE] OF
	    SET
	    [RST$K_TYPE_RECORD,RST$K_TYPE_VARIANT]:
		BEGIN
		IF .NODE_1[DBG$B_PNODE_FCODE] EQL RST$K_TYPE_VARIANT THEN
		  IF .NODE_1[DBG$L_PNVAR_DSTPTR] NEQ .NODE_2[DBG$L_PNVAR_DSTPTR]
		    THEN SIGNAL(DBG$_EXARANGE);
		VALUE_1 = .NODE_1[DBG$W_PNREC_INDEX];
		VALUE_2 = .NODE_2[DBG$W_PNREC_INDEX];
		IF .VALUE_1 LSS .VALUE_2 THEN RETURN -1;
		IF .VALUE_1 GTR .VALUE_2 THEN RETURN +1;
		END;

	    [RST$K_TYPE_ARRAY]:
		BEGIN
		LOCAL
		    SUBS_1	: REF DBG$PRIM_NODE_SUBS,
		    SUBS_2	: REF DBG$PRIM_NODE_SUBS;

		IF .NODE_1[DBG$B_PNARR_SUBCNT] NEQ .NODE_2[DBG$B_PNARR_SUBCNT]
		  THEN SIGNAL(DBG$_EXARANGE);

		SUBS_1 = NODE_1[DBG$A_PNARR_SVECTOR];
		SUBS_2 = NODE_2[DBG$A_PNARR_SVECTOR];

		INCR DIMENSION FROM 0 TO .NODE_1[DBG$B_PNARR_DIMCNT]-1 DO
		    BEGIN
		    LOCAL D;
		    D = (IF .NODE_1[DBG$V_PNARR_COLUMN]
			    THEN .NODE_1[DBG$B_PNARR_DIMCNT] - .DIMENSION - 1
			    ELSE .DIMENSION);

		    VALUE_1 = .SUBS_1[.D,DBG$L_PNSUB_SVALUE] - .SUBS_1[.D,DBG$L_PNSUB_LBOUND];
		    VALUE_2 = .SUBS_2[.D,DBG$L_PNSUB_SVALUE] - .SUBS_2[.D,DBG$L_PNSUB_LBOUND];
		    IF .VALUE_1 LSS .VALUE_2 THEN RETURN -1;
		    IF .VALUE_1 GTR .VALUE_2 THEN RETURN +1;
		    END;
		END;

	    [OTHERWISE]:
		EXITLOOP;
	    TES;

	NODE_1 = .NODE_1[DBG$L_PNODE_FLINK];
	NODE_2 = .NODE_2[DBG$L_PNODE_FLINK];
	END;
    RETURN 0;
    END;			! End of primary_order

ROUTINE CHECK_TEXT_DESCRIPTOR(VAL_DESC: REF DBG$VALDESC) =
!
! FUNCTION
!	----------------------------
!
! INPUTS
!	----------------------------
!
! OUTPUTS
!	----------------------------
!

    BEGIN

    BUILTIN
	PROBER;

    BIND VMS_DESC = VAL_DESC[DBG$A_VALUE_VMSDESC]: DBG$STG_DESC;



    IF (.VAL_DESC[DBG$B_VALUE_CLASS] EQL DSC$K_CLASS_UBS) THEN SIGNAL(DBG$_UNALIGNED);

    IF NOT PROBER(%REF(0),%REF(8) ,.VAL_DESC[DBG$L_VALUE_POINTER])
      THEN SIGNAL(DBG$_NOACCESSR,1,.VAL_DESC[DBG$L_VALUE_POINTER]);

    CH$MOVE(8,.VAL_DESC[DBG$L_VALUE_POINTER],VAL_DESC[DBG$A_VALUE_VMSDESC]);

    IF (.VMS_DESC[DSC$B_DTYPE] EQL 0) AND (.VMS_DESC[DSC$B_CLASS] EQL 0)
    THEN
	BEGIN
	VMS_DESC[DSC$B_DTYPE] = DSC$K_DTYPE_T;
	VMS_DESC[DSC$B_CLASS] = DSC$K_CLASS_S;
	RETURN TRUE;
	END;

    IF  (.VMS_DESC[DSC$B_CLASS] EQL DSC$K_CLASS_D)
     THEN VMS_DESC[DSC$B_CLASS]  =  DSC$K_CLASS_S;

    IF  (.VMS_DESC[DSC$B_CLASS] EQL DSC$K_CLASS_VS)
    AND (.VMS_DESC[DSC$B_DTYPE] EQL DSC$K_DTYPE_T)
     THEN VMS_DESC[DSC$B_DTYPE]  =  DSC$K_DTYPE_VT;

    IF  (.VMS_DESC[DSC$B_CLASS] NEQ DSC$K_CLASS_VS)
    AND (.VMS_DESC[DSC$B_CLASS] NEQ DSC$K_CLASS_S)  THEN RETURN FALSE;
    
    SELECTONE .VMS_DESC[DSC$B_DTYPE] OF
	SET
	[DSC$K_DTYPE_T] :	VMS_DESC[DSC$B_CLASS] = DSC$K_CLASS_S;

	[DSC$K_DTYPE_AZ,
	 DSC$K_DTYPE_AC,
	 DSC$K_DTYPE_VT]:	VMS_DESC[DSC$B_CLASS] = DSC$K_CLASS_VS;

	[OTHERWISE]:		RETURN FALSE;

	TES;

    RETURN TRUE;
    END;			! End of routine check_text_descriptor

ROUTINE FIX_UP_LENGTH(VMS_DESC: REF DBG$STG_DESC) =
!
! FUNCTION
!	----------------------------
!
! INPUTS
!	----------------------------
!
! OUTPUTS
!	----------------------------
!

    BEGIN

    LOCAL
	SIZE,
	BASE: REF BLOCK[,BYTE];



    BASE = .VMS_DESC[DSC$A_POINTER];
    SELECTONE .VMS_DESC[DSC$B_DTYPE] OF
	SET

	[DSC$K_DTYPE_VT]:
    	    BEGIN
    	    BUILTIN PROBER;
    	    IF NOT PROBER(%REF(0),%REF(2) ,.BASE)
            THEN SIGNAL(DBG$_NOACCESSR,1,.BASE);
	    SIZE = .BASE[0,0,16,0];
    	    END;

	[DSC$K_DTYPE_AC]:
    	    BEGIN
    	    BUILTIN PROBER;
    	    IF NOT PROBER(%REF(0),%REF(1) ,.BASE)
            THEN SIGNAL(DBG$_NOACCESSR,1,.BASE);
	    SIZE = .BASE[0,0, 8,0];
    	    END;

	[DSC$K_DTYPE_AZ]:
	    BEGIN
	    BUILTIN LOCC,PROBER;
	    LOCAL ADDR;
    	    IF NOT PROBER(%REF(0),%REF(4) ,.BASE)
            THEN SIGNAL(DBG$_NOACCESSR,1,.BASE);
	    LOCC(%REF(0), %REF(2048), .BASE; ,ADDR);
	    SIZE = .ADDR - .BASE;
	    END;

	[OTHERWISE]:
	    SIZE = .VMS_DESC[DSC$W_LENGTH];

	TES;

    RETURN .SIZE;

    END;			! End of routine fix_up_length

END ELUDOM
