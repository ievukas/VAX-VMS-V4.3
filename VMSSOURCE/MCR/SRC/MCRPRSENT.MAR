	.TITLE	MCRPRSENT - PARSE PARAMETERS AND QUALIFIERS
	.IDENT	'V04-000'
 
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; W. H. BROWN 3-JAN-1978
;
; Modified by:
;
;	V03.03	MAJ0006		Melanie Johnson	28-Feb-1983
;		Convert to new structure level.  Bring top level command
;		parsing routines to this module from MCRCOMD. (Centralize
;		all the command parsing into one module.)
;
;	V03.02	MAJ0005		Melanie Johnson	11-Jan-1983
;		Replace needed check for address in P1 vs. P0 when changing
;		image names.
;
;	V03.01	MAJ0004		Melanie Johnson	07-Sep-1982
;		Use WRK_L_EXPANDPTR(FP) instead of R9 as the command expansion
;		buffer pointer.  Add keyword parsing.  Modularize various
;		parsing elements.
;
;	V003	MAJ0003		Melanie Johnson	02-Mar-1982
;		Allow negated qualifiers to have a value.
;		(For SET NOCONTROL=Y)
;
;	V002	MAJ0002		Melanie Johnson	03-Feb-81
;		Check entity block flag MCROPTDLM for special-casing of
;		SET /UIC=uic command which contains an optional equal sign.
;
;	V001	MAJ0001		Melanie Johnson		04-Nov-81
;		Change to use the command tables (built for DCL) defined
;		by the structures in CLIDEF.MDL.
;
; PARSE PARAMETERS AND QUALIFIERS
;
; MACRO LIBRARY CALLS
;

	$$CLITABDEF			; DEFINE COMMAND TABLE STRUCTURES
	DEFCMDWRK			; DEFINE PROCESS & COMMAND WORK AREAS
	DEFERRCOD			; DEFINE ERROR/STATUS VALUES
	PTRDEF				; DEFINE RESULT PARSE DESCRIPTOR FORMAT
;
; LOCAL DEFINITIONS BASED ON ASSUMPTIONS
;
	ASSUME	PTR_V_NEGATE EQ 20
	LOC_V_NEGAT	=  0		; QUALIFIER OR KEYWORD NEGATED FLAG
	LOC_M_NEGAT	=  1		; POS'N IN A TOKEN

	ASSUME	PTR_V_KEYWORD EQ 22	; KEYWORD FLAG LOCATION IN A TOKEN
	LOC_V_KEYWORD	=  2		; KEYWORD FLAG IN LOW END OF LONGWORD
	LOC_M_KEYWORD	=  4		; (FOR USE AND RELOCATION BY MCR$GENDESCR)

	ASSUME	PTR_V_SYNTAX EQ 23	; SYNTAX CHANGE FLAG LOC. IN A TOKEN
	LOC_V_SYNTAX	=  3		; SYNTAX FLAG IN LOW END OF LONGWORD
	LOC_M_SYNTAX	=  8		; (FOR USE & RELOCATION BY MCR$GENDESCR)

	LOC_V_AMBIG	=  4		; AMBIGUOUS KEYWORD FLAG
	LOC_M_AMBIG	=  16

	LOC_V_QUALCHNG  =  0		; QUALIFIER CHANGE FLAG - RET BY MCR$CHANGE_SYNTAX
	LOC_M_QUALCHNG  =  1

	.PSECT	MCR$ZCODE,BYTE,RD,NOWRT

	.ENABLE	LSB
	.SBTTL	PARSE A DCL-TYPE COMMAND
;+
; MCR$PARSE_DCL - PARSE A DCL-TYPE COMMAND
;
; THIS ROUTINE IS CALLED TO PARSE A COMMAND THAT MIMICS A DCL COMMAND
;
; INPUTS:
;
;	NONE.
;
; OUTPUTS:
;
;	R0 CONTAINS THE STATUS OF THE PARSE
;-

MCR$PARSE_DCL::

	SETBIT	WRK_V_VERB,WRK_W_FLAGS(FP) ;SET VERB PROCESSING FLAG
;
; ALLOW A KEYWORD PARAMETER TO BE EXPRESSED AS IF IT WERE A QUALIFIER.  IN
; OTHER WORDS, A PARAMETER KEYWORD MAY BE PRECEDED BY A SLASH.
; (E.G. ALLOW "SET/TERMINAL" FOR THE "SET TERMINAL")
;
	BSBW	MCR$SETCHAR		;PEEK AT NEXT CHARACTER IN INPUT BUFFER
	CMPB	#^A\/\,R0		;QUALIFIER?
	BEQL	10$			;IF EQL QUALIFIER OR PARAMETER KEYWORD
	CMPB	#^A/ /,R0		;NEXT CHARACTER A SPACE?
	BNEQ	PARSE_PARMS		;IF NOT (NEQ), INVALID PARAMETER DELIMITER
	BSBW	MCR$SETNBLK		;GET NEXT NON-BLANK CHARACTER
	CMPB	#^A\/\,R0		;QUALIFIER OR POSSIBLE KEYWORD PARAMETER?
	BNEQ	20$			;IF NEQ NO
10$:	MOVL	WRK_L_PROPTR(FP),R1	;GET ADDRESS OF P1 DESCRIPTOR
	BEQL	PARSE_QUAL		;BR IF NO PARAMETER ENTITY BLOCKS
	TSTL	ENT_L_USER_TYPE(R1)	;DOES P1 TAKE A KEYWORD VALUE
	BEQL	PARSE_QUAL		;IF NOT, PROCESS AS QUALIFIER
	MOVL	WRK_L_CHARPTR(FP),R0	;GET CURRENT CHARACTER POINTER
	MOVB	#^A/ /,1(R0)		;SET QUALIFIER SLASH TO A BLANK
	BRB	PARSE_PARMS		;PROCESS AS PARAMETER

20$:	MOVB	#^A/ /,@WRK_L_CHARPTR(FP) ;REPLACE BLANK BEFORE PARAMETER AS DELIMITER
	DECL	WRK_L_CHARPTR(FP)	;BACK UP INPUT BUFFER PTR TO THE BLANK
	BRB	PARSE_PARMS		;PROCESS THIS PARAMETER

PARSE_QUAL:
	BSBW	MCR$SETCHAR		;PEEK AT NEXT CHAR. IN INPUT BUFFER
	CMPB	#^A\/\,R0		;QUALIFIER?
	BNEQ	PARSE_PARMS		;IF NEQ NO
	BSBW	MCR$MARK		;SAVE DISPLAY PARAMETER
	BSBW	MCR$PROCQUAL		;PROCESS QUALIFIER
	BLBS	R0,PARSE_QUAL		;IF LBS SUCCESSFUL COMPLETION
	BRW	250$			;EXIT IF ERROR

;
; PROCESS COMMAND PARAMETERS AND THEIR ASSOCIATED QUALIFIERS
;

PARSE_PARMS:
150$:	CLRBIT	WRK_V_VERB,WRK_W_FLAGS(FP) ;CLEAR VERB PROCESSING
	MOVL	WRK_L_PROPTR(FP),R8	;GET ADDRESS OF P1 DESCRIPTOR
	MOVL	WRK_L_PARMCNT(FP),R0	;GET PARAMETER # BEING PARSED
	BEQL	155$			;BRANCH IF NO LOOP NEEDED
152$:	ADDL3	ENT_L_NEXT(R8),-	;GET ADDRESS OF NEXT ENTITY BLOCK
		WRK_L_TAB_VEC(FP),R8	;
	SOBGTR	R0,152$			;LOOP UNTIL PARAMETER FOUND
155$:	BSBW	MCR$MARK		;MARK CURRENT PARSE POSITION
	BSBW	MCR$SETCHAR		;PEEK AT NEXT CHARACTER IN INPUT BUFFER
	BNEQ	158$			;IF NEQ, NOT END OF LINE
	BRW	245$			;EOL
158$:	CMPB	#^A/ /,R0		;BLANK?
	BNEQ	230$			;IF NEQ NO
160$:	INCL	WRK_L_PARMCNT(FP)	;INCREMENT COUNT OF PARAMETERS
	CMPL	WRK_L_PARMCNT(FP),WRK_L_MAXPARM(FP) ;MAXIMUM PARAMETERS EXCEEDED?
	BGTR	200$			;BR IF TOO MANY PARAMETERS
165$:	BSBW	MCR$MARK		;MARK CURRENT PARSE POSITION
	MOVZBL	#PTR_K_PARAMETR,R3	;SET CLASSIFICATION FOR OPTION DETECTION
	BSBW	MCR$PARSE_VALUE		;PROCESS PARAMETER VALUE
170$:	BLBC	R0,215$			;IF LBC PARSE ERROR
	BSBW	MCR$SETCHAR		;PEEK AT NEXT CHARACTER IN INPUT BUFFER
	CMPB	#^A/:/,R0		;COLON (MOUNT, INIT COMMANDS DELIMITER)?
	BNEQ	175$			;IF NEQ NO
	BSBW	MCR$MOVCHAR		;MOVE THE COLON INTO THE BUFFER
	BSBW	MCR$SETCHAR		;LOOK AT THE NEXT CHARACTER
	CMPB	#^A\/\,R0		;QUALIFIER FOLOWING THE DEVICE SPEC?
	BEQL	178$			;IF EQL YES
	BSBW	MCR$BACKUPMOVE		;BACKUP TO THE COLON AGAIN
	BRB	190$			;AND CONTINUE PARSING
175$:	CMPB	#^A\/\,R0		;QUALIFIER?
	BNEQ	190$			;IF NEQ NO
178$:	MOVZBL	#PTR_K_PARMQUAL,R3	;SET CLASSIFICATION OF QUALIFIER
180$:	BSBW	MCR$PROCQUAL		;PROCESS QUALIFIER SPECIFICATION
	BRB	170$			;
190$:	CMPB	#^A/,/,R0		;MULTIPLE PARAMETERS?
	BEQL	210$			;IF EQL YES
	CMPB	#^A/+/,R0		;CONCATENATED PARAMETERS?
	BEQL	220$			;IF EQL YES
	BRW	150$			;IF LEQ NO

;
; MAXIMUM PARAMETER COUNT EXCEEDED
;

200$:	STATUS	MAXPARM			;ASSUME MAXIMUM PARAMETERS EXCEEDED
	BRB	250$			;

;
; PARAMETER LIST SPECIFIED
;

210$:	BBS	#ENT_V_LIST,ENT_W_FLAGS(R8),165$ ;IF SET, LISTS ALLOWED
	STATUS	NOLIST			;SET NO LISTS ALLOWED STATUS
215$:	BRB	250$			;

;
; PARAMETER CONCATENATION SPECIFIED
;

220$:	BBS	#ENT_V_CONCAT,ENT_W_FLAGS(R8),165$ ;IF SET, CONCATENATION ALLOWED
	STATUS	NOCCAT			;SET NO CONCATENATION ALLOWED STATUS
	BRB	250$			;

;
; INVALID PARAMETER DELIMITER
;

230$:	PUSHR	#^M<R0,R1,R8>		;SAVE REGISTERS
	MOVL	WRK_L_PROPTR(FP),R8	;GET P1 DESCRIPTOR AGAIN
	MOVL	WRK_L_PARMCNT(FP),R0	;GET CURRENT PARAMETER NUMBER
	BEQL	244$			;CHECK FOR THE CASE OF NO PARAMETERS
	DECL	R0			;BACK UP TO THE LAST PARAM BEFORE THIS ONE
	BEQL	240$			;IF EQL, WE WANT TO CHECK THE 1ST PARAM.
235$:	ADDL3	ENT_L_NEXT(R8),-	;GET ADDRESS OF NEXT ENTITY BLOCK
		WRK_L_TAB_VEC(FP),R8	;
	SOBGTR	R0,235$			;LOOP UNTIL WE FIND THE PARAM WE WANT
240$:	CMPB	#ENT_K_DEVICE,ENT_B_VALTYPE(R8) ;WAS PREVIOUS PARAM A DEVICE?
	BNEQ	242$			;IF NEQ NO (DELIMITER OTHER THAN BLANK ILLEGAL)
	POPR	#^M<R0,R1,R8>		;RESTORE RO=CHAR PTR, R8=CURRENT ENT. DESCR.
	CMPB	#^A/:/,R0		;COLON IS A VALID DELIMITER HERE
	BNEQ	243$			;IF NEQ, INVALID DELIMITER
	BRW	160$			;CONTINUE PARSING
242$:	POPR	#^M<R0,R1,R8>		;CLEAN STACK UP
243$:	STATUS	PARMDEL			;SET INVALID PARAMETER DELIMITER STATUS
	BRB	250$

244$:	POPR	#^M<R0,R1,R8>		;CLEAN STACK UP
	STATUS	IVOPER			;UNRECOGNIZED GARBAGE AFTER VERB
	BRB	250$

245$:	CMPL	WRK_L_PARMCNT(FP),WRK_L_MINPARM(FP) ;ENOUGH PARAMETERS?
	BGEQ	NORMAL_EXIT		;IF GEQ, YES
	STATUS	INSFPRM			;NOT ENOUGH PARAMETERS
	BRB	250$

NORMAL_EXIT:
	STATUS 	NORMAL

250$:	RSB


	.ENABLE LSB
	.SBTTL	PARSE MCR-TYPE COMMANDS
;+
; MCR$PARSE_MCR - PARSE MCR-TYPE COMMANDS
;
; THIS ROUTINE IS CALLED TO PARSE A COMMAND OF THE FORM:
;
;	OUTPUT[/QUALIFIERS] = INPUT(S)[/QUALIFIERS]
;
; INPUTS:
;
;	NONE
;
; OUTPUTS:
;
;	R0 CONTAINS THE STATUS OF THE PARSE
;-

MCR$PARSE_MCR::

;
; PROCESS COMMAND QUALIFIERS
;

	SETBIT	WRK_V_VERB,WRK_W_FLAGS(FP) ;SET VERB PROCESSING FLAG
	BSBW	MCR$TESTBLANK		;PEEK AT NEXT CHARACTER
5$:	CMPB	#^A\/\,R0		;QUALIFIER?
	BNEQ	10$			;IF NEQ NO
	BSBW	MCR$PROCQUAL		;PROCESS COMMAND QUALIFIER
	BSBW	MCR$TESTBLANK		;PEEK AT NEXT CHARACTER
	BNEQ	5$			;LOOK FOR MORE COMMAND QUALIFIERS

;
; PROCESS PARAMETERS - OUTPUTS FIRST, THEN INPUTS
;

10$:	CLRBIT	WRK_V_VERB,WRK_W_FLAGS(FP) ;CLEAR VERB PROCESSING
 	MOVL	WRK_L_PROPTR(FP),R8	;GET PARAMETER LIST PTR.
	TSTB	@WRK_L_PAROUT(FP)	;CHECK NUMBER OF OUTPUTS
	BEQL	60$			;NONE IF EQL
	CMPB	R0,#^A/,/		;PARAMETER LIST SEPARATOR
	BEQL	20$			; Yes if EQL
	CMPB	R0,#^A/=/		; Null output list?
	BNEQ	60$			;BR IF NO
20$:
	MOVB	#^A/ /,@WRK_L_CHARPTR(FP) ;SET A NULL PARAMETER
	DECL	WRK_L_CHARPTR(FP)	;BACK UP TO GET SPACE NEXT
	BBS	#ENT_V_VALREQ,ENT_W_FLAGS(R8),105$ ;ERROR IF PARM SHOULDN'T BE NULL
	BRB	70$			;PROCESS NULL FILE SPEC
60$:	BSBW	MCR$MARK		;SAVE ADDRESS INCASE ERROR
	BSBW	MCR$TESTBLANK		;PEEK AT NEXT CHARACTER IN INPUT BUFFER
	BEQL	102$			;IF EQL END OF LINE
	CMPB	#^A/ /,R0		;BLANK BEFORE 1ST PARAM. OR AS OUTPUT/INPUT SEPARATOR
	BNEQ	63$			;BR IF NOT A BLANK
	TSTL	WRK_L_PARMCNT(FP)	;LOOKING AT FIRST PARAMETER?
	BEQL	70$			;BR IF YES
	BRB	65$			;ELSE LINK TO NEXT PARAM. DESCRIP. AND CHECK PARAM.
63$:	CMPB	#^A/=/,R0		;TRADITIONAL INPUT/OUTPUT SEPARATOR?
	BNEQ	120$			;IF NEQ NO
	BBSS	#WRK_V_EQUAL,WRK_W_FLAGS(FP),120$ ;BR IF SECOND EQUAL SIGN
65$:	ADDL3	ENT_L_NEXT(R8),-	;GET ADDRESS OF NEXT ENTITY BLOCK
		WRK_L_TAB_VEC(FP),R8	;
70$:	BSBW	MCR$MARK		;SAVE DISPLAY PARAMETER
	INCL	WRK_L_PARMCNT(FP)	;INCREMENT NUMBER OF PARAMETERS SEEN
	CMPL	WRK_L_PARMCNT(FP),WRK_L_MAXPARM(FP) ;TOO MANY PARAMETERS?
	BGTR	140$			;BR IF YES
	BRB	PARMQUAL		;PROCESS THIS PARM AND ITS CORRESPONDING QUALS.
80$:	CMPB	#^A/,/,R0		;MULTIPLE PARAMETERS?
	BEQL	65$			;IF EQL YES
	CMPB	R0,#^A/+/		; Multiple parameters?
	BEQL	115$			; If EQL yes
	CMPB	@WRK_L_PAROUT(FP),WRK_L_PARMCNT(FP) ;HAVE WE PARSED ALL THE OUTPUTS?
	BEQL	60$			;BR IF YES
 	BLSS	100$
;
; Checking for and setting errors
;

	MOVL	WRK_L_PARMCNT(FP),R3	;SET UP A COUNTER TO FIND INPUT PARMS
;
; check to see if the remaining outputs are required
;
90$:	ADDL3	ENT_L_NEXT(R8),-	;GET ADDRESS OF NEXT ENTITY BLOCK
		WRK_L_TAB_VEC(FP),R8	;
	INCL	R3			;COUNTING PARAMETERS IN LIST
	CMPB	R3,@WRK_L_PAROUT(FP)	;HAVE WE LOOKED AT ALL LEFTOVER OUTPUTS?
	BEQL	60$			;IF GTR, YES - GO PARSE THE INPUTS
	BBS	#ENT_V_VALREQ,ENT_W_FLAGS(R8),105$ ;IF MISSING PARM IS REQ'D - ERROR
	BRB	90$


100$: 	; end of input parsing - do some cleanup checks
	BSBW	MCR$TESTBLANK		;LOOK AT NEXT CHARACTER IN INPUT BUFFER
	BNEQ	140$			;IF NOT EOL, TOO MANY PARAM.'S
102$:	BRB	145$			;EOL - AND AWAY WE GO!

105$:	STATUS	INSFPRM			;MISSING A PARAMETER(S)
	BRB	150$

115$:	BBS	#ENT_V_CONCAT,ENT_W_FLAGS(R8),65$ ;BR IF CONCATENATION ALLOWED
	STATUS	NOCCAT
	BRB	150$

120$:	STATUS	PARMDEL			;SET INVALID PARAMETER DELIMITER STATUS
	BRB	150$

130$:	STATUS	BADSTRLVL		;COMMAND TABLES ARE MESSED UP
	BRB	150$

140$:	STATUS	MAXPARM			;TOO MANY PARAMETERS
	BRB	150$

145$:	STATUS	NORMAL			;END OF LINE
	CMPL	WRK_L_PARMCNT(FP),WRK_L_MINPARM(FP) ;ENOUGH PARAMETERS?
	BLSS	105$			;BR IF NO
	CMPL	WRK_L_PARMCNT(FP),WRK_L_MAXPARM(FP) ;TOO MANY PARAMETERS?
	BGTR	140$			;BR IF YES

150$:	RSB


PARMQUAL:
	BSBW	MCR$PROCFILE		;PROCESS FILE SPECIFICATION
200$:	BLBC	R0,150$			;IF LBC PARSE ERROR
	BSBW	MCR$SETCHAR		;PEEK AT NEXT CHARACTER IN INPUT BUFFER
	CMPB	#^A\/\,R0		;QUALIFIER?
	BEQL	210$			;IF EQL YES
	BRW	80$			;GO BACK TO SEE IF THERE ARE MORE PARAMETERS
210$:	BSBW	MCR$PROCQUAL		;PROCESS QUALIFIER SPECIFICATION
	BRB	200$			;

	.DISABLE LSB

	.PAGE
	.SBTTL	PROCESS QUALIFIER SPCIFICATION
;+
; MCR$PROCQUAL - PROCESS QUALIFIER SPECIFICATION
;
; THIS ROUTINE IS CALLED TO PARSE A QUALIFIER SPECIFICATION AND EMIT A
; DESCRIPTOR TO THE RESULT PARSE TABLE.
;
; INPUTS:
;
;	R10 = RESULT PARSE DESCRIPTOR TABLE POINTER.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;	FP = BASE ADDRESS OF COMMAND WORK AREA.
;	WRK_L_EXPANDPTR(FP) = ADDRESS OF NEXT BYTE IN COMMAND BUFFER.
;
; OUTPUTS:
;
;	R0 LOW BIT CLEAR INDICATES FAILURE TO PARSE QUALIFIER SPECIFICATION.
;
;		R0 = MCR$_ABKEYW - AMBIGUOUS KEYWORD IN QUALIFIER.
;		R0 = MCR$_IMCHNG - MULTIPLE ATTEMPT TO CHANGE IMAGE NAME.
;		R0 = MCR$_IVKEYW - INVALID KEYWORD IN QUALIFIER.
;		R0 = MCR$_IVQLOC - INVALID QUALIFIER LOCATION.
;		R0 = MCR$_IVVALU - INVALID QUALIFIER VALUE SYNTAX.
;		R0 = MCR$_NOKEYW - NO KEYWORD IN QUALIFIER.
;		R0 = MCR$_NOQUAL - NO QUALIFIERS ALLOWED ON COMMAND.
;		R0 = MCR$_NOVALU - NO VALUE ALLOWED ON QUALIFIER.
;
;	R0 LOW BIT SET INDICATES SUCCESSFUL PARSE WITH THE QUALIFIER
;		DESCRIPTOR EMITTED AND THE QUALIFIER SPECIFICATION COPIED
;		TO THE COMMAND BUFFER.
;
;		R0 = MCR$_NORMAL - NORMAL COMPLETION.
;-

MCR$PROCQUAL::				; PROCESS QUALIFIER SPECIFICATION
	PUSHR	#^M<R6,R7,R8>		; SAVE REGISTERS
	BISW	#WRK_M_QUAL,WRK_W_FLAGS(FP) ; SET QUALIFIER PROCESSING IN PROGRESS
	CLRL	R6			; CLEAR KEYWORD NEGATION FLAG
	INCB	WRK_B_VALLEV(FP)	;INCREASE THE VALUE LEVEL
;
; GET QUALIFIER KEYWORD
;
5$:	BSBW	MCR$MOVCHAR		; MOVE TERMINATOR
	BSBW	MCR$MARK		; MARK CURRENT POSITION IN BUFFER
	BSBW	MCR$GETOKEN		; GET QUALIFIER NAME
	BNEQ	10$			; BR IF TOKEN FOUND
	CMPB	R0,#^A/-/		; QUALIFIER START WITH NEGATE SIGN
	BNEQ	90$			; BR IF NO
	BISL	#LOC_M_NEGAT,R6		; SET THE NEGATION FLAG
	BRB	5$			; TRY AGAIN

;
; CHECK THAT IT MATCHES AN ALLOWED QUALIFIER KEYWORD
;

10$:	STATUS	NOQUAL			; ASSUME NO QUALIFIERS ALLOWED ON COMMAND
	MOVL	WRK_L_QUABLK(FP),R8	; GET ADDRESS OF QUALIFIER DESCRIPTORS
	BEQL	100$			; IF EQL NONE
	BSBW	MCR$FIND_KEYWORD	; LOOKUP QUALIFIER
	BLBS	R0,110$			; IF SUCESSFUL, THEN CONTINUE
	BRW	390$			; OTHERWISE, EXIT WITH ERROR STATUS

;
; THIS IS A DCL-ONLY QUALIFIER
;

88$:	STATUS	INVQUAL			; INVALID QUALIFIER FOR MCR
	BRW	390$			; TAKE ERROR EXIT

;
; NO KEYWORD IN QUALIFIER
;
 
90$:	STATUS	NOKEYW			; SET NO KEYWORD STATUS
100$:	BRW	390$			; TAKE ERROR EXIT
 
;
; VALID KEYWORD MATCH FOUND - CHECK VALIDITY
;
 
110$:	BBS	#ENT_V_MCRIGNORE,ENT_W_FLAGS(R8),88$ ; IS THIS A DCL-ONLY QUALIFIER?
	STATUS	IVQLOC			; ASSUME INVALID QUALIFIER LOCATION
	BBS	#WRK_V_VERB,WRK_W_FLAGS(FP),120$ ; IF SET, PROCESSING VERB
	BBS	#ENT_V_PARM,ENT_W_FLAGS(R8),125$ ; IF SET, ALLOWED ON PARAMETERS
120$:	BBC	#ENT_V_VERB,ENT_W_FLAGS(R8),100$ ; IF CLR, NOT ALLOWED ON VERBS

;
; PROCESS CHANGE LIST IF ANY
;
125$:	TSTL	ENT_L_SYNTAX(R8)	; CHANGE COMMAND SYNTAX?
	BEQL	155$			; IF EQL, NO CHANGE LIST
	BSBW	MCR$CHANGE_SYNTAX	;
	BISL	#LOC_M_SYNTAX,R6	; SET SYNTAX CHANGE BIT
	BLBC	R0,155$			; BRANCH IF NO QUALIFIER CHANGE LIST
	CLRL	R7			; INVALIDATE THIS QUALIFIER


;
; KEYWORD VALID - CHECK NEGATION AND GENERATE QUALIFIER DESCRIPTOR
;

155$:	ASSUME	LOC_V_NEGAT EQ 0
	BLBC	R6,160$			; IF LBC QUALIFIER NOT NEGATED
	STATUS	NOTNEG			; ASSUME QUALIFIER NOT NEGATABLE
	BBC	#ENT_V_NEG,ENT_W_FLAGS(R8),100$ ; IF CLR, NOT NEGATABLE
;
; GENERATE QUALIFIER DESCRIPTOR
;
160$:	MOVZBL	#PTR_K_COMDQUAL,R5	; ASSUME COMMAND QUALIFIER
	BBS	#WRK_V_VERB,WRK_W_FLAGS(FP),170$ ; IF SET, PROCESSING VERB
	BBC	#ENT_V_PARM,ENT_W_FLAGS(R8),170$ ; IF CLR, COMMAND QUALIFIER
	MOVZBL	#PTR_K_PARMQUAL,R5	; SET TYPE TO PARAMETER QUALIFIER
170$:	MOVQ	R7,-(SP)		; SAVE REGISTERS
	MOVL	R7,R4			; GET QUALIFIER NUMBER
	MOVL	R8,R9			; COPY ENTITY BLOCK ADDRESS
	BSBW	MCR$MARKEDTOKEN		; GET QUALIFIER DESCRIPTOR
	MOVQ	R1,R7			; COPY DESCRIPTOR FOR CALL TO GENDESCR
	BSBW	MCR$GENDESCR		; GENERATE RESULT PARSE DESCRIPTOR
 	MOVQ	(SP)+,R7		; RESTORE REGISTERS

;
; CHECK FOR QUALIFIER VALUE(S)
;

	STATUS	NOVALU			; ASSUME VALUE NOT ALLOWED
	MOVZBL	#PTR_K_QUALVALU,R3	; SET VALUE TYPE TO QUALIFIER VALUE
	BSBW	MCR$CHECK_VALUES	; CHECK FOR VALUE(S)
	BLBC	R0,390$			; EXIT IF ERROR

;
; CLEAN UP AND EXIT
;

380$:	STATUS	NORMAL			;SET SUCCESSFUL COMPLETION

390$:	DECB	WRK_B_VALLEV(FP)	;DECREASE THE VALUE LEVEL
	BICW	#WRK_M_QUAL,WRK_W_FLAGS(FP) ;CLEAR QUALIFIER PROCESSING IN PROGRESS
	POPR	#^M<R6,R7,R8>		;RESTORE REGISTERS
	RSB				;
 




	.SBTTL	PARSE VALUE STRING
;+
; MCR$PARSE_VALUE - PARSE A SINGLE VALUE IN A VALUE LIST
;
; THIS ROUTINE IS CALLED TO SCAN A SINGLE VALUE AND STORE
; THE TOKEN DESCRIPTOR WHICH DESCRIBES IT.
;
; INPUTS:
;
;	R3 = CLASSIFICATION OF VALUE (PTR_K_QUALVALU OR PTR_K_PARAMETR)
;	R8 = ADDRESS OF ENTITY DESCRIPTOR BLOCK
;	FP = ADDRESS OF COMMAND WORK AREA
;
;	CHARACTER POINTER POINTS TO DELIMITER JUST BEFORE THE VALUE STRING
;
; OUTPUTS:
;
;	R0 = STATUS
;
;	INSIGNIFICANT BLANKS ARE THROWN AWAY FOLLOWING THE VALUE.
;	CHARACTER POINTER POINTS TO DELIMITER JUST AFTER THE VALUE STRING.
;
;	ONE (OR TWO) TOKEN DESCRIPTORS ARE OUTPUT DEPENDING ON WHETHER
;	THE SYNTAX WAS 'VALUE' OR 'KEYWORD=VALUE'.
;-

;
; VALID TERMINATOR LIST FOR VALUE STRINGS
;
TERM:	.ASCII	\ +,/()\<0>		; SPACE,PLUS,COMMA,SLASH,PARENS AND EOL
TERME:


MCR$PARSE_VALUE::
	PUSHR	#^M<R3,R4,R5,R6,R7,R8>	;SAVE REGISTERS
	INCB	WRK_B_VALLEV(FP)	;INCREASE THE VALUE LEVEL
	MOVZBL	ENT_B_VALTYPE(R8),R0	;GET VALUE TYPE
	CMPB	R0,#ENT_K_INFILE	;INPUT FILESPEC?
	BEQL	5$			;IF SO, PROCESS FILESPEC
	CMPB	R0,#ENT_K_OUTFILE	;OUTPUT FILESPEC?
	BEQL	5$			;IF SO, PROCESS FILESPEC
	CMPB	R0,#ENT_K_NODE		;NODE NAME?
	BEQL	5$			;IF SO, PROCESS AS FILESPEC
	CMPB	R0,#ENT_K_DEVICE	;DEVICE NAME?
	BEQL	5$			;IF SO, PROCESS AS FILESPEC
	CMPB	R0,#ENT_K_DIR		;DIRECTORY SPEC?
	BEQL	5$			;IF SO, PROCESS AS FILESPEC
	CMPB	R0,#ENT_K_UIC		;UIC SPEC?
	BEQL	5$			;IF SO, PROCESS AS FILESPEC
	CMPB	R0,#ENT_K_RESTOFLINE	;REST OF LINE AS VALUE STRING?
	BNEQ	10$			;BRANCH IF NOT
;
; PROCESS VALUE TYPED AS "RESTOFLINE"
;
	BSBW	MCR$MOVCHAR		;COPY TERMINATOR INTO EXPANSION BUFFER
	BSBW	MCR$SETNBLK		;SKIP LEADING BLANKS
	BSBW	MCR$MARK		;MARK START OF VALUE STRING
3$:	BSBW	MCR$MOVCHAR		;COPY NEXT CHARACTER
	BNEQ	3$			;LOOP UNTIL END OF LINE
	BSBW	MCR$MARKEDTOKEN		;GET DESCRIPTOR OF MARKED TOKEN
	DECL	R1			;SUBTRACT OUT EOL CHARACTER
	CLRL	R6			;CLEAR FLAGS
	BRB	60$			;STORE THE TOKEN AND EXIT
;
; PROCESS VALUE TYPED AS INFILE, OUTFILE, NODE, DEVICE, DIR OR UIC
;

5$:	BSBW	MCR$PROCFILE		;PARSE THE FILE SPEC
	BRW	90$
;
; PROCESS VALUE TYPED AS STRING (UNTYPED)
;
; GET VALUE (UP TO "=" OR ":" IF KEYWORDS ARE ALLOWED)
;
10$:	BSBW	MCR$MOVCHAR		;COPY TERMINATOR INTO EXPANSION BUFFER
	BSBW	MCR$SETNBLK		;SKIP LEADING BLANKS
	BSBW	MCR$MARK		;SAVE START OF VALUE STRING
20$:	BSBW	MCR$GTBTOKEN		;COPY TOKEN INTO EXPANSION BUFFER
	TSTL	ENT_L_USER_TYPE(R8)	;DOES VALUE TAKE KEYWORDS?
	BEQL	30$			;IF NOT, IGNORE EMBEDDED '=:'
	CMPB	R0,#^A'='		;VALUE SEPARATOR?
	BEQL	50$			;BR IF YES
	CMPB	R0,#^A':'		;CHECK IF END OF KEY AND START OF VALUE
	BEQL	50$			;BR IF YES
30$:	LOCC	R0,S^#TERME-TERM,B^TERM	;CHECK FOR VALUE STRING TERMINATOR
	BNEQ	50$			;BR IF TERMINATOR FOUND
	BSBW	MCR$MOVCHAR		;COPY CHARACTER WHICH STOPPED GETOKEN
	BRB	20$			;KEEP GETTING TOKENS UNTIL END OF VALUE
50$:	BSBW	MCR$MARKEDTOKEN		;GET DESCRIPTOR OF VALUE STRING
	BNEQ	52$			;IF NEQ VALUE FOUND
	BRW	100$			;ERROR IF NO VALUE
52$:	BSBW	MCR$COMPRESS		;COMPRESS QUOTED STRING


; IF KEYWORDS ARE ALLOWED, PROCESS THE KEYWORD
;
	MOVL	ENT_L_USER_TYPE(R8),R0	;ARE KEYWORDS ALLOWED?
	BEQL	60$			;BRANCH IF NOT
	MOVL	(SP),R3			;GET CLASSIFICATION OF VALUE
	BSBW	MCR$PROCESS_KEYWORD	;PROCESS KEYWORD
	BLBC	R0,90$			;BRANCH IF ERROR
	BRB	75$			;CLEAN UP AND RETURN
;
; VERIFY SYNTACTIC CORRECTNESS OF $NUMBER TYPE VALUES
;
60$:	MOVZBL	ENT_B_VALTYPE(R8),R0	;GET VALUE TYPE
	CMPB	#ENT_K_NUMBER,R0	;NUMBER?
	BNEQ	65$			;IF NEQ NO
	MOVQ	R1,-(SP)		;SAVE R1, R2
	MOVQ	R1,R2			;COPY DESCRIPTOR
	MOVL	#1,R1			;SET RADIX
;***************TBS***********************
;	BSBW	MCR$CNVNOEDIT		;CHECK THE NUMBER
;*****************************************
	MOVQ	(SP)+,R1		;RESTORE R1,R2
;	BLBC	R0,100$			;ERROR EXIT

;
; GENERATE VALUE (KEYWORD) DESCRIPTOR
;
65$:	CLRL	R4			;CLEAR ENTITY NUMBER
	MOVL	(SP),R5			;GET CLASSIFICATION OF VALUE TOKEN (R3)
	CLRL	R6			;CLEAR THE FLAGS
	MOVL	R8,R9			;COPY ENTITY BLOCK ADDRESS
	MOVQ	R1,R7			;SET LENGTH OF VALUE (OR NUM OF KEYWORD)
	BSBW	MCR$GENDESCR		;GENERATE RESULT PARSE DESCRIPTOR

;
; CLEAN UP AND EXIT
;
75$:	BSBW	MCR$TESTBLANK		;THROW AWAY INSIGNIFICANT BLANKS
	BSBW	MCR$GENTERM		;AND SET TERMINATOR IN LAST TOKEN
	STATUS	NORMAL			;SET SUCCESSFUL
90$:	DECB	WRK_B_VALLEV(FP)	;DESCREASE THE VALUE LEVEL
	POPR	#^M<R3,R4,R5,R6,R7,R8>	;RESTORE REGISTERS
	RSB

100$:	STATUS	IVVALU			;SET INVALID SYNTAX
	BRB	90$


	.SBTTL	PROCESS KEYWORD
;+
; MCR$PROCESS_KEYWORD - PROCESS KEYWORD
;
; THIS ROUTINE IS CALLED TO PROCESS A KEYWORD AND TO GENERATE A DESCRIPTOR
; IN THE RESULT PARSE TABLE.
;
; INPUTS:
;
;	R0    = ADDRESS OF KEYWORD LIST HEADER
;	R1/R2 = KEYWORD DESCRIPTOR
;	R3    = ENTITY TYPE
;	R8    = ADDRESS OF ENTITY BLOCK
;	R10   = BASE ADDRESS OF COMMAND WORK AREA
;
; OUTPUTS:
;
;	R0    = STATUS
;
;-

MCR$PROCESS_KEYWORD:

;
; VALIDATE THE KEYWORD
;
	ADDL3	R0,WRK_L_TAB_VEC(FP),R8	;GET ADDRESS OF KEYWORD LIST
	ASSUME	LOC_V_KEYWORD EQ 2
	MOVZBL	#LOC_M_KEYWORD,R6	;SPECIFY THAT FULL LENGTH BE VALIDATED
	BSBW	MCR$FIND_KEYWORD	;VALIDATE THE KEYWORD
	BLBC	R0,90$			;EXIT IF INVALID

;
; PROCESS CHANGE LIST - IF ANY
;
	TSTL	ENT_L_SYNTAX(R8)	;ALTERNATE COMMAND SYNTAX SPECIFIED?
	BEQL	10$			;BRANCH IF NOT
	PUSHL	R1			;SAVE R1
	BSBW	MCR$CHANGE_SYNTAX	;CHANGE COMMAND SYNTAX
	POPL	R1			;RESTORE R1
	ASSUME	LOC_V_SYNTAX EQ 3	;
	BISL	#LOC_M_SYNTAX,R6	;SET SYNTAX CHANGE BIT

;
; CHECK NEGATION
;
10$:	ASSUME	LOC_V_NEGAT EQ 0
	BLBC	R6,20$			;IF KEYWORD NOT NEGATED, THEN SKIP
	STATUS	NOTNEG			;ASSUME KEYWORD NOT NEGATABLE
	BBC	#ENT_V_NEG,ENT_W_FLAGS(R8),90$	;EXIT IF NEGATED

;
; GENERATE VALUE (KEYWORD) DESCRIPTOR
;
20$:	MOVL	R7,R4			;COPY KEYWORD NUMBER
	MOVL	R3,R5			;GET CLASSIFICATION OF VALUE TOKEN (R3)
	MOVQ	R7,-(SP)		;SAVE KEYWORD # AND ADDR OF ENTITY BLOCK
	MOVL	R8,R9			;COPY ENTITY BLOCK ADDRESS
	MOVQ	R1,R7			;SET LENGTH OF VALUE (OR NUM OF KEYWORD)
	BSBW	MCR$GENDESCR		;GENERATE RESULT PARSE DESCRIPTOR
	MOVQ	(SP)+,R7		;RESTORE KEYWORD # AND ADDR OF ENTITY BLOCK

;
; CHECK FOR OPTIONAL DELIMITER BETWEEN OPTION PARAMETER AND NEXT PARAMETER
; (FOR THE SET /UIC=[uic] COMMAND)
;
	CMPB	#PTR_K_PARAMETR,R3	; JUST PROCESSED A CHANGE SYNTAX? - OPTION?
	BNEQ	30$			; IF NEQ NO
	BSBW	MCR$SETCHAR		; LOOK AT NEXT CHARACTER
	CMPB	#^A/=/,R0		; IS IT '='? (AS IN SET /UIC= )
	BNEQ	30$			; IF NEQ NO
	BBC	#ENT_V_MCROPTDELIM,ENT_W_FLAGS(R8),30$ ;BR IF THIS EQUAL NOT OPTIONAL
	MOVL	WRK_L_CHARPTR(FP),R0	; GET CURRENT INPUT BUFF. CHAR. PTR.
	MOVB	#^A/ /,1(R0)		; CHANGE COLON OR EQUAL SIGN TO BLANK

;
; DO WE HAVE A KEYWORD VALUE LEFT TO PROCESS.
;
30$:	BSBW	MCR$CHECK_VALUES	;MAKE INDIRECTLY RECURSIVE CALL

90$:	RSB


	.SBTTL	CHECK FOR VALUES
;+
; MCR$CHECK_VALUES - CHECK FOR VALUES AND THEN PROCESS THEM
;
; THIS ROUTINE IS CALLED TO DETERMINE IF A VALUE OR LIST OF VALUES IS
; ASSOCIATED WITH THE LAST QUALIFIER OR PARAMETER PARSED, TO DETERMINE
; THE SYNTACTIC LEGALITY OF THE EXISTENCE OF VALUES, AND TO CALL
; MCR$PARSE_VALUE TO PARSE EACH VALUE FOUND.
;
; INPUTS:
;
;	R3 = CLASSIFICATION OF VALUE (PTR_K_QUALVALU OR PTR_K_PARAMETR)
;	R6 = NEGATION FLAG - LBS, IF KEYWORD NEGATED; LBC, IF NOT
;	R8 = ADDRESS OF ENTITY DESCRIPTOR BLOCK
;	FP = ADDRESS OF COMMAND WORK AREA
;
; IMPLICIT INPUTS:
;
;	WRK_L_EXPANDPTR(FP) - (THE EXPANSION BUFFER POINTER) IS POSITIONED AT
;	THE TERMINATOR OF THE PREVIOUS QUALIFIER OR PARAMETER.
;
; OUTPUTS:
;
;	R0 INDICATES THE SYNTACTIC CORRECTNESS OF INCORRECTNESS OF
;	WHAT WAS FOUND.
;
;-

MCR$CHECK_VALUES:
	PUSHL	R3			;SAVE VALUE TYPE

;
; CHECK IF VALUE HAS BEEN SPECIFIED
;
	BSBW	MCR$SETCHAR		;PEEK AT NEXT CHARACTER IN INPUT BUFFER
	CMPB	R0,#^A'='		;VALUE SPECIFIED?
	BEQL	10$			;IF EQL YES
	CMPB	R0,#^A':'		;VALUE SPECIFIED?
	BEQL	10$			;IF EQL YES

;
; IS VALUE REQUIRED?
;
	ASSUME	LOC_V_NEGAT EQ 0
	BLBS	R6,90$			;NO VALUE IS OK IF ENTITY WAS NEGATED
	STATUS	VALREQ			;ASSUME VALUE REQUIRED ERROR
	BBS	#ENT_V_VALREQ,ENT_W_FLAGS(R8),95$ ;IF SET, REPORT VALUE IS REQUIRED
	BRB	90$			;OTHERWISE, ITS OK

;
; IS VALUE ALLOWED?
;
10$:	STATUS	NOVALU			;ASSUME NO VALUE ALLOWED
	BBC	#ENT_V_VAL,ENT_W_FLAGS(R8),95$	;IF CLR, VALUE NOT ALLOWED
	CMPB	#ENT_K_QUALIFIER,ENT_B_TYPE(R8) ;ARE WE PARSING A QUALIFIER VALUE?
	BNEQ	15$			;IF NEQ NO
	ASSUME	LOC_V_NEGAT EQ 0
	BLBS	R6,95$			;NO VALUE ALLOWED ON A NEGATED QUALIFIER

;
; CHECK FOR VALUE LIST AND PROCESS VALUE(S)
;
15$:	MNEGL	#2,R5			;SET VALUE STATE VARIABLE
	BSBW	MCR$MOVCHAR		;MOVE EQUAL SIGN
	BSBW	MCR$SETNBLK		;PEEK AT FIRST NON-BLANK AFTER (=)
	CMPB	R0,#^A'('		;START OF VALUE LIST?
	BEQL	20$			;BR IF YES
	BSBW	MCR$BACKUPMOVE		;RESTORE EQUAL SIGN DELIMITER
	BRB	30$			;AND PARSE THE SINGLE VALUE
20$:	INCL	R5			;MARK LIST IS PRESENT
30$:	MOVL	(SP),R3			;SET TOKEN TYPE
	BSBW	MCR$PARSE_VALUE		;PARSE VALUE STRING
	BLBC	R0,95$			;BRANCH IF ERROR DETECTED
	INCL	R5			;COUNT UP THE VALUES SEEN
	BLSS	90$			;BR IF SINGLE VALUE QUALIFIER
	BSBW	MCR$SETCHAR		;PEEK AT NEXT CHARACTER
	CMPB	R0,#^A','		;TERMINATER SAY MORE VALUES COMING?
	BEQL	30$			;IF MORE COMING, PROCESS THEM
	CMPB	R0,#^A')'		;END OF VALUE LIST?
	BNEQ	80$			;IF NO-ITS AN ERROR
	BSBW	MCR$MOVCHAR		;COPY RIGHT PARENTHESIS DELIMITER
	BSBW	MCR$TESTBLANK		;THROW AWAY INSIGNIFICANT TRAILING BLANKSK
	BSBW	MCR$GENTERM		;SET ACTUAL TERMINATOR INSTEAD OF RPAREN
					;SINCE END OF LIST CAN BE DEDUCED BY
					;NON-QUALVALU TOKEN; AND SINCE BLANK
					;TERMINATOR MARKS A PARAMETER NEXT.
;
; DID WE GET MORE THAN ONE VALUE?  ARE VALUE LISTS ALLOWED?
;
	TSTL	R5			;DID WE GET MORE THAN ONE VALUE?
	BEQL	90$			;BR IF NO (PARENS WERE NOP)
	STATUS	ONEVAL			;ASSUME ONLY ONE VALUE ALLOWED
	BBC	#ENT_V_LIST,ENT_W_FLAGS(R8),95$ ;ERROR IF NO LISTS ALLOWED
	BRB	90$			;CONTINUE

;
; INVALID QUALIFIER VALUE SYNTAX
;
80$:	STATUS	IVVALU			;SET INVALID SYNTAX
	BRB	95$			;

;
; SINGLE VALUE QUALIFIER
;
90$:	STATUS	NORMAL			;SET SUCCESSFUL COMPLETION
95$:	POPL	R3			;RESTORE TOKEN TYPE
	RSB				;


	.SBTTL	FIND KEYWORD
;+
; MCR$FIND_KEYWORD - LOOK UP SPECIFIED KEYWORD IN SPECIFIED LIST
;
; THIS ROUTINE IS CALLED TO LOOK UP A SPECIFIED QUALIFIER OR KEYWORD
; IN THE APPROPRIATE LIST.  IF THE SEARCH IS SUCCESSFUL, THE QUALIFIER
; OR KEYWORD NUMBER IS RETURNED ALONG WITH THE ADDRESS OF THE ENTITY
; DESCRIPTOR BLOCK.  OTHERWISE, AN ERROR STATUS IS RETURNED.
;
; INPUTS:
;
;	R1/R2 = DESCRIPTOR OF KEYWORD TO LOOK UP
;	R6 = FLAGS - NEGATION IF LBS, REGULAR KEYWORD RATHER THAN QUALIFIER
;	     IF LOC_V_KEYWORD SET
;	R8 = ADDRESS OF LIST OF DESCRIPTOR BLOCKS
;	FP = ADDRESS OF COMMAND WORK AREA
;
; OUTPUTS:
;
;	R1/R2 = DESCRIPTOR OF KEYWORD (NEEDED BY MCR$PARSE_VALUE)
;	R6 = FLAGS - NEGATION IF LBS, REGULAR KEYWORD RATHER THAN QUALIFIER
;	     IF LOC_V_KEYWORD SET
;	R7 = QUALIFIER OR KEYWORD NUMBER (IF SUCCESSFUL)
;	R8 = ADDRESS OF ENTITY DESCRIPTOR BLOCK
;
;-

MCR$FIND_KEYWORD:
	ASSUME	LOC_V_NEGAT EQ 0
	PUSHR	#^M<R1,R2,R3,R4,R5,R9> ;SAVE REGISTERS

;
; IF KEYWORD LIST, THEN SKIP PAST TYPE BLOCK.
;
	CMPB	#BLOCK_K_TYPE,ENT_B_TYPE(R8)	;TYPE BLOCK?
	BNEQ	5$				;IF NEQ NO
	ADDL3	WRK_L_TAB_VEC(FP),TYPE_L_KEYWORDS(R8),R8 ;GET ADDR OF 1ST ENT BLOCK

;
; SAVE ADDRESS OF LIST OF DESCRIPTOR BLOCKS.
;
5$:	MOVL	R8,R9			;SAVE LIST ADDRESS

;
; IF QUALIFIER THEN ONLY CHECK FIRST FOUR CHARACTERS OF KEYWORD,
; ELSE CHECK THE WHOLE THING.
;
10$:	MOVL	R1,AP			;SAVE ORIGINAL TOKEN SIZE
	BBS	#LOC_V_KEYWORD,R6,20$ ;ARE WE LOOKING FOR A KEYWORD?
	CMPL	#4,R1			;KEYWORD LESS THAN 5 CHARACTERS?
	BGEQ	20$			;IF GEQ YES
	MOVL	#4,R1			;SET TO ONLY COMPARE 4 CHARACTERS

;
; INITIALIZE SEARCH PARAMETERS.
;
20$:	CLRL	R7			;CLEAR INITIAL OFFSET (R6)
					;  AND QUALIFIER NUMBER (R7)
	CLRQ	-(SP)			;SET NULL AS QUALIFIER FOUND

;
; GET NEXT QUALIFIER IN LIST
;
30$:	CVTWL	ENT_W_NAME(R8),R0	;GET OFFSET TO ASCIC QUALIFIER NAME
	MOVAB	(R8)[R0],R5		;FIND ADDRESS OF QUALIFIER KEY LENGTH
	MOVAB	1(R8)[R0],R0		;FIND ADDRESS OF QUALIFIER KEY TEXT
	MOVQ	R1,R3			;COPY QUALIFIER STRING DESCRIPTOR

;
; COMPARE THE QUALIFIER WITH THE INPUT
;
60$:	CMPB	#^A/ /,(R0)		;END OF QUALIFIER TEXT?
	BEQL	65$			;BR IF YES
	CMPB	(R0)+,(R4)+		;IS THIS THE QUALIFIER WERE LOOKIN FOR?
	BNEQ	70$			;BR IF DEFINITELY NOT!
	SOBGTR	R3,60$			;BR IF MORE TO CHECK

;
; WHAT KIND OF MATCH DO WE HAVE?
;
	CMPB	AP,(R5)			;IS TABLE QUALIFIER SAME LENGTH
	BNEQ	65$			;NO, THEN SKIP
	ADDL	#8,SP			;YES, THEN WE HAVE A UNIQUE MATCH
	BRB	83$			;RESTORE STACK, BRANCH TO EXIT

;
; CHECK FOR AMBIGUITY AND SAVE MATCH.
;
65$:	TSTL	4(SP)			;FIND MATCH BEFORE?
	BEQL	67$			;BR IF NOT AMBIGUOUS
	BISL	#LOC_M_AMBIG,R6		;SET AMBIGUOUS BIT
67$:	MOVQ	R7,(SP)			;SAVE MATCHED QUALIFIER VALUES

;
; CHECK NEXT QUALIFIER IN LIST.
;
70$:	INCL	R7			;INCREMENT QUALIFIER NUMBER
	MOVL	ENT_L_NEXT(R8),R8	;GET OFFSET TO NEXT QUALIFIER DESCRIPTOR
	BEQL	75$			;IF EQL THEN DONE
	ADDL	WRK_L_TAB_VEC(FP),R8	;CALCULATE ADDRESS
	BRW	30$			;IF NEQ TRY AGAIN

;
; ALL QUALIFERS HAVE BEEN CHECK WITHOUT AMBIGUITY, NOW SEE IF ANY MATCHED.
;
75$:	STATUS	ABKEYW			;ASSUME AMBIGUOUS
	BBSC	#LOC_V_AMBIG,R6,85$	;BR IF TRUE
	MOVQ	(SP)+,R7		;RESTORE MATCHED QUALIFER PARAMETERS
	BNEQ	83$			;BR IF ONE WAS FOUND

;
; QUALIFIER DESCRIPTOR TABLE EXHAUSTED - TRY NEGATION
;
	XORL	#LOC_M_NEGAT,R6		;COMPLEMENT NEGATION FLAG
	SUBL3	#2,AP,R1		;REDUCE CHARACTER COUNT
	BLEQ	80$			;IF LEQ NO MATCH POSSIBLE
	MOVL	R9,R8			;RESTORE ADDRESS OF DESCRIPTOR LIST
	CMPW	#^A/NO/,(R2)+		;KEYWORD START WITH 'NO'?
	BEQL	10$			;IF EQL YES
 
;
; SET STATUS, CLEAN UP, AND RETURN
;
80$:	STATUS	IVKEYW			;SET INVALID KEYWORD STATUS
	BRB	90$			;

83$:	STATUS	NORMAL			;SET SUCCESS STATUS
	BRB	90$			;

85$:	MOVQ	(SP)+,R7		;RESTORE MATCHED QUALIFIER PARAMETERS
90$:	INCL	R7			;ADJUST TO ACTUAL KEYWORD NUMBER
	POPR	#^M<R1,R2,R3,R4,R5,R9> ;RESTORE REGISTERS
	RSB

	.SBTTL	CHANGE COMMAND SYNTAX
;+
; MCR$CHANGE_SYNTAX - PROCESS A CHANGE LIST AND CHANGE THE COMMAND SYNTAX
;
; THIS ROUTINE IS CALLED TO REDEFINE THE SYTNAX OF THE COMMAND BEING PARSED
; ACCORDING TO THE DESCRIPTION IN THE CHANGE LIST.
;
; INPUTS:
;
;	R7 = QUALIFIER NUMBER
;	R8 = ADDRESS OF ENTITY DESCRIPTOR BLOCK
;	FP = ADDRESS OF COMMAND WORK AREA
;
; OUTPUTS:
;
;	R0 = 0 IF NO NEW QUALIFIER OR PARAMETER LISTS
;	     1 IF NEW QUALIFIER LIST
;
;	APPROPRIATE WRK BLOCK FIELDS ARE MODIFIED TO REFLECT THE
;	NEW COMMAND SYNTAX.
;
;		WRK_L_IMAGE -	NEW IMAGE ADDRESS
;		WRK_L_MINPARM -	MINIMUM PARAMETER COUNT
;		WRK_L_MAXPARM -	MAXIMUM PARAMETER COUNT
;		WRK_L_PROPTR -	PARAMETER LIST
;		WRK_L_QUABLK -	QUALIFIER LIST
;		WRK_G_RESULT -	TOKEN ARRAY
;
;-

MCR$CHANGE_SYNTAX:
	PUSHL	R6			;SAVE REGISTERS
	CLRL	-(SP)			;INIT PARAM/QUAL LIST STATUS
	BISW	#WRK_M_VERB,WRK_W_FLAGS(FP) ;SET VERB PROCESSING ON SYNTAX CHANGE
	ADDL3	ENT_L_SYNTAX(R8),WRK_L_TAB_VEC(FP),R6 ;GET ADDRESS OF CHANGE LIST
	TSTB	WRK_B_CMDOPT(FP)	;FIRST SYNTAX CHANGE SO FAR?
	BNEQ	10$			;ONLY RECORD THE FIRST CHANGE MADE
	MOVB	R7,WRK_B_CMDOPT(FP)	;SAVE QUAL # INDUCING THE FIRST CHANGE
					; FOR GETOPT CALLBACK (OPTION)
;
; CHANGE IMAGE TO BE EXECUTED
;	CLI ROUTINE OR IMAGE - GET ADDRESS OF ASCIC ROUTINE NAME OR FILE SPEC
;
10$:	CMPB	#CMD_K_SAME,CMD_B_HANDLER(R6) ;IMAGE CHANGE REQUESTED?
	BEQL	40$			;IF EQL NO
	CLRBIT	WRK_V_CLIRTN,WRK_W_FLAGS2(FP) ;CLEAR PREVIOUS IMAGE STATE
	CVTWL	CMD_W_IMAGE(R6),R0	;GET BR OFFSET TO ASCIC IMAGE NAME
	ADDL	R6,R0			;COMPUTE ADDRESS OF IMAGE/ROUTINE NAME
	CMPB	#CMD_K_CLI,CMD_B_HANDLER(R6) ;IS THIS A CLI ROUTINE?
	BNEQ	20$			;IF NEQ NO
	SETBIT	WRK_V_CLIRTN,WRK_W_FLAGS2(FP) ;SET CLI ROUTINE FLAG
20$:	MOVL	R0,WRK_L_IMAGE(FP)	;SET INDEX NUMBER OF NEW IMAGE NAME

;
; COPY THE STATE OF THE NEW SYNTAXES NOSTATUS BIT
;
40$:	CLRBIT	CMD_V_NOSTAT,WRK_B_CMDFLG(FP)	;CLEAR NOSTATUS FLAG
	BBC	#CMD_V_NOSTAT,CMD_W_FLAGS(R6),50$ ;BRANCH IF STATUS SHOULD BE SET
	SETBIT	CMD_V_NOSTAT,WRK_B_CMDFLG(FP)	;SET NOSTATUS FLAG
;
; CHANGE PARAMETER DEFINITIONS
;
50$:	BBC	#CMD_V_PARMS,CMD_W_FLAGS(R6),60$ ; BRANCH IF NO PARAMETER CHANGE
	EXTZV	#CMD_V_MINPARM,#CMD_S_MINPARM,- ;EXTRACT MINIMUM PARAMETERS
		CMD_B_PARMCNT(R6),WRK_L_MINPARM(FP)
	EXTZV	#CMD_V_MAXPARM,#CMD_S_MAXPARM,- ;EXTRACT MAXIMUM PARAMETERS
		CMD_B_PARMCNT(R6),WRK_L_MAXPARM(FP)
	MOVL	CMD_L_PARMS(R6),R0	;GET OFFSET TO NEW PARAMETER LIST
	BEQL	55$			;IF NONE, THEN NO MORE PARAMS ALLOWED
	ADDL	WRK_L_TAB_VEC(FP),R0	;GET ADDRESS OF PARAMETER LIST
55$:	MOVL	R0,WRK_L_PROPTR(FP)	;RESET ADDRESS OF PARAMETER LIST

;
; CHANGE QUALIFIER DEFINITIONS
;

60$:	BBC	#CMD_V_QUALS,CMD_W_FLAGS(R6),80$ ; BRANCH IF NO QUAL CHANGE
	MOVL	CMD_L_QUALS(R6),R0	;GET OFFSET TO NEW QUALIFIER LIST
	BEQL	65$			;IF NONE, NO MORE QUALIFIERS ALLOWED
	ADDL	WRK_L_TAB_VEC(FP),R0	;GET ADDRESS OF QUALIFIER LIST
65$:	MOVL	R0,WRK_L_QUABLK(FP)	;RESET ADDRESS OF QUALIFIER LIST
;
; INVALIDATE ALL QUALIFIERS IN THE TOKEN ARRAY, INCLUDING THE QUALIFIER WE
; MAY BE CURRENTLY PROCESSING, SO THAT ALL QUALIFIERS IN THE PREVIOUS SYNTAX
; ARE NO LONGER ACCESSIBLE.  THIS IS DONE TO PREVENT PREVIOUS QUALIFIERS
; FROM BEING CONFUSED WITH THE CURRENT QUALIFIER NUMBERING SCHEME.  THE
; INVALIDATION IS DONE BY ZEROING THE QUALIFIER NUMBER IN THE TOKEN ARRAY,
; ESSENTIALLY TO RECORD THAT A QUALIFIER WAS DETECTED IN THAT POSITION, BUT
; THAT IT DOESN'T REPRESENT ANY QUALIFIER IN THE CURRENT QUALIFIFER LIST.
;
	MOVL	#LOC_M_QUALCHNG,(SP)	;SET BIT TO INVALIDATE THIS QUALIFIER
	MOVAB	WRK_G_RESULT-PTR_C_LENGTH(FP),R0 ;GET ADDRESS OF TOKEN ARRAY
70$:	ADDL	#PTR_C_LENGTH,R0	;SKIP TO NEXT ENTRY
	CMPL	R0,R10			;REACHED LAST ENTRY STORED?
	BGEQU	80$			;BRANCH IF SO
	ASSUME	PTR_K_COMDQUAL EQ 0
	ASSUME	PTR_K_PARMQUAL EQ 1
	ASSUME	PTR_K_QUALVALU EQ 2
	CMPZV	#PTR_V_TYPE,#PTR_S_TYPE,(R0),#PTR_K_QUALVALU ;QUALIFIER?
	BGTRU	70$			;SKIP IF NOT
	INSV	#0,#PTR_V_VALUE,#PTR_S_VALUE,(R0) ;ZERO QUAL # (INVALIDATE IT)
	BRB	70$			;LOOP UNTIL ALL QUALIFIERS INVALIDATED

;
; RESTORE REGISTERS AND RETURN
;
80$:	POPL	R0			;SET QUAL/PARAM LIST STATUS
	POPL	R6			;RESTORE REGISTERS
	RSB

	.END
