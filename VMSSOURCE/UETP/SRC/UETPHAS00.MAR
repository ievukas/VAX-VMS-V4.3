	.TITLE TSTCNTRL TEST PACKAGE CONTROL PROGRAM
	.IDENT	'V04-000'
	.ENABLE SUPPRESSION
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:
;	UETP -- TEST PACKAGE CONTROL PROGRAM
;
; ABSTRACT:
;	This program will serve as the controlling program between various
;	test programs.  It will create the test programs (either .EXE or
;	.COM) as detached processes and run them either sychronously or
;	asychronously.
;
; ENVIRONMENT:
; 	This program will run in user access mode, with interrupts enabled
;	at all times.  This program requires the following privileges and
;	quotas:
;		either SETPRIV or (DETACH and WORLD)
;
;
; AUTHOR: Brian A. Axtell,	CREATION DATE: December, 1982
;
; MODIFIED BY:
;
;	V03-011	RNH0003		Richard N. Holstein,	07-Apr-1984
;		Adapt to security change which put mailbox logical names in
;		job tables rather than group tables.  When reporting failure
;		of some process, always return full text of error code.  Fix
;		bug which reported wrong status when process creation failed.
;		Indent all of copied log file lines uniformly.
;
;	V03-010	RNH0002		Richard N. Holstein,	22-Mar-1984
;		Fix bug which thought that turning off a test was a syntax
;		error.
;
;	V03-009	BAA0007		Brian A. Axtell,	17-Jan-1984
;		Added capability to change the parallel count number
;		 dynamically from within a data file.
;		Fixed other assignments	so that they don't write messages 
;		 if wrapping around.
;		Added "EXIT" keyword, so one could end with it instead of EOF.
;		Added the capability of using abbreviations of keywords.
;		Fixed bug with ABORT_PROCESSES. The FORCEX was stopping images
;		 so fast that the Process Termination AST was being called and
;		 distroying the queue before all the processes could be stopped.
;		 The fix was to calculate the offset to the next process before
;		 aborting the current process.
;
;	V03-008	BAA0006		Brian A. Axtell,	03-Jan-1984
;		Fixed problem with getting error messages when already
;		in ABORT sequence.
;
;	V03-007	RNH0001		Richard N. Holstein,	19-Dec-1983
;		Use LIB$SIGNAL or $PUTMSG throughout, instead of LIB$PUT_OUTPUT.
;
;	V03-006	BAA0005		Brian A. Axtell,	16-Aug-1983
;		Set flag so beginning and ending sentinels are always
;		printed out.
;
;	V03-005	BAA0004		Brian A. Axtell,	15-Jul-1983
;		Added <CR><LF> before prompt in interactive mode.
;		Changed locally defined symbol to global symbol
;		(PRC$M_LOGIN) for $CREPRC
;
;	V03-004	BAA0003		Brian A. Axtell,	21-Mar-1983
;		Changed attributes of the log file FAB's. Put a header
;		of blanks when copying records from log file.  Change
;		labels of the inputs from the CLD file.
;
;	V03-003	BAA0002		Brian A. Axtell,	17-Jan-1983
;		Changed process termination routine so that it reports
;		errors when a process aborts abnormally.
;
;	V03-002	BAA0001		Brian A. Axtell,	16-Dec-1982
;		Changed the way PRCINFO$_FLAGS was defined.
;
;	V03-001	LDJ0001		Larry D. Jones,		16-Dec-1982
;		Added a $ to the TCNTRLDEF macro call.
;
;++

	.SBTTL	Declarations

; INCLUDE FILES:

; MACROS:

	$SSDEF					; for system services
	$DEVDEF					; device charac. via RMS
	$DVIDEF					; for $GETDVI values
	$DCDEF					; for device characteristics
	$JPIDEF					; for GETJPI system service
	$LNMDEF					; Logical name services codes
	$PQLDEF					; for CREPRC system service
	$CHFDEF					; Condition handler frame definitions
	$DSCDEF					; include offsets for descriptor
	$DIBDEF					; Device Information Block
	$SHRDEF					; Shared messages
	$STSDEF					; Status return
	$ACCDEF					; accounting messages
	$PRVDEF					; privilege offset values
	$NAMDEF					; to get NAM offsets for parse
	$LIBDEF					; to get LIB error symbols
	$TPADEF					; to get TPARSE symbols
	$PRCDEF					; get masks for CREPRC
	$UETPDEF				; UETP symbols
	
	; now define the various offset used by the TSTCNTRL.  These include
	; TCNTRL$, PRCINFO$, PARSE$, CASE$, CRTPRC$, and ASSIGN$.

	$TCNTRLDEF				; definitions for the TSTCNTRL

; EQUATED SYMBOLS:

	;   Facility number definitions:

	TCNTRL_K = 195				; define the facility code
	RMS_K = 1

	;   SHR message definitions:

	TCNTRL = TCNTRL_K@STS$V_FAC_NO		; Define the TCNTRL facility code
	
	TCNTRL$_ABENDD   = TCNTRL!SHR$_ABENDD	; Define the TCNTRL message codes
	TCNTRL$_ABORT    = TCNTRL!SS$_ABORT
	TCNTRL$_CONTROLC = TCNTRL!SS$_CONTROLC
	TCNTRL$_BEGIND   = TCNTRL!SHR$_BEGIND
	TCNTRL$_ENDEDD   = TCNTRL!SHR$_ENDEDD
	TCNTRL$_OPENIN   = TCNTRL!SHR$_OPENIN
	TCNTRL$_TEXT     = TCNTRL!SHR$_TEXT

	; set up definitions

	; define the maximum number of processes which can run concurrently

	NUMB_OF_SLOTS = 50			; number of slots in one structure
	PAGE_SIZE = 512				; number of bytes in a page


	; misc. assignments
	
	RCRD_SIZE    =  132			; size of text strings
	LARGE_BUFFER =  256			; size of large output strings
	NAME_SIZE    =    9			; max size of a filename
	MAILBOX_SIZE =   84			; size of AST mailbox

	NBR_HDR_BLNKS = 4			; number of blanks in header of
						; output records

	; declarations of filespec information

	FILENAME_LNGTH = 9			; max length of VMS filename
	FILE_EXT_LNGTH = 4			; size of VMS file extension (inc .)
	PROCESS_NAME_SIZ = 15			; max length of VMS processname

	; declarations of information for TSTCNTRL ID number and process name

	ID_STR_SIZ   = 4			; number of digits in ID string
	ID_OVERHEAD_SIZ  = 2			; underscore and blank
	PNAME_FILNAM_SIZ = PROCESS_NAME_SIZ-
		-ID_STR_SIZ-ID_OVERHEAD_SIZ	; largest size the filename can
						;  be to be put into the process-
						;  name.  Anything larger is truncated.
	MAX_TMP_LOG_NAM = FILENAME_LNGTH-
		-ID_STR_SIZ			; maximum size of extracted 
						;  filename for temp. log files

	; declarations of timer ID's and delta time for waiting for aborted
	; process to terminate

	MAXTIME_ID  = 1				; ID for MAXTIME
	ABRT_TIM_ID = 2				; ID for the abort timer

	ABRT_DELT_SCNDS = 15			; set timer for 15 seconds

	; define symbols for carriage-return / line-feed

	CR = ^X0D				; ascii code for carriage rtn
	LF = ^X0A				; ascii code for line-feed

	.SBTTL	Read-Only Data
	.PSECT	RODATA,NOEXE,NOWRT,PAGE

	; prompt for interactive TSTCNTRL

TCNTRL_PRMT:					; prompt for interactive
	.BYTE	CR
	.BYTE	LF
	.ASCII	/TCNTRL> /

TCNTRL_PRMT_SIZ = . - TCNTRL_PRMT		; size of prompt


	; quadword delta time for the abort process timer

PROC_TERM_DELT:
	.LONG	-10*1000*1000*ABRT_DELT_SCNDS,-1  ; wait time for aborted proc.


	; data structures so that mailboxes which serve as SYS$INPUT to the
	; processes we create are created in our group logical name table.

LNMPRCDIR:				; Table name to force mbx logicals...
	.ASCID	/LNM$PROCESS_DIRECTORY/	; ...to appear in a group table

LNMTMPMBX:				; Logical name which tells $CREMBX...
	.ASCID	/LNM$TEMPORARY_MAILBOX/	; ...where to put mbx logical names

LNMITMLST:				; $CREMBX ITMLST naming where mbx...
	.WORD	LNMGRPLEN,LNM$_STRING	; ...logical name is to be defined
	.ADDRESS LNMGRPNUM,0
	.LONG	0

	; space for $GETJPI to get the quotas of the parent process

QUOTA_LIS:
	.WORD 4
	.WORD JPI$_ASTLM
	.ADDRESS ASTLM
	.LONG 0
	.WORD 4
	.WORD JPI$_BIOLM
	.ADDRESS BIOLM
	.LONG 0
	.WORD 4
	.WORD JPI$_BYTLM
	.ADDRESS BYTLM
	.LONG 0
	.WORD 4
	.WORD JPI$_CPULIM
	.ADDRESS CPULM
	.LONG 0
	.WORD 4
	.WORD JPI$_DIOLM
	.ADDRESS DIOLM
	.LONG 0
	.WORD 4
	.WORD JPI$_ENQLM
	.ADDRESS ENQLM
	.LONG 0
	.WORD 4
	.WORD JPI$_FILLM
	.ADDRESS FILLM
	.LONG 0
	.WORD 4
	.WORD JPI$_PGFLQUOTA
	.ADDRESS PGFLQUOTA
	.LONG 0
	.WORD 4
	.WORD JPI$_PRCLM
	.ADDRESS PRCLM
	.LONG 0
	.WORD 4
	.WORD JPI$_TQLM
	.ADDRESS TQELM
	.LONG 0
	.WORD 4
	.WORD JPI$_WSQUOTA
	.ADDRESS WSQUOTA
	.LONG 0
	.WORD 4
	.WORD JPI$_PRIB
	.ADDRESS BASPRI
	.LONG 0
	.LONG 0

	; error messages

ABORT_MSG:
	.ASCID 	/TSTCNTRL beginning abort sequence. All active process to be stopped./

TCNTRL_ABORT_MSG:
	.ASCID	/This process was aborted by the TSTCNTRL./

CNTRLCMSG:
	.ASCID	\Aborted via a user CTRL/C.\

FILNAM_ERR:
	.ASCID /FILNAM data file is invalid or was not found./

REPORT_ERR:
	.ASCID /Invalid REPORT, default used./

DATSTRUC_ERR:
	.ASCID /Internal data structure corrupted, returned process not found./

BAD_STATUS:
	.ASCID/The process -!AS- returned a final status of:/

NO_CRT_PRC:
	.ASCID \Could not create the -!AS- process, status returned was:\

TIME_OUT_ERR:
	.ASCID /Maximum time exceeded. Current test section aborted./

NO_SET_TIM:
	.ASCID /Maximum timer is already set, unable to change it./

FILE:	
	.ASCID /file/				; fills in RMS_ERR_STRING

RECORD:
	.ASCID /record/				; fills in RMS_ERR_STRING

RMS_ERR_STRING:					; announces an RMS error
	.ASCID /RMS !AS error in file !AD/

ZERO_PARCNT:
	.ASCID /PARCNT is less than, or equal to zero, PARCNT = 1 used./

PROC_ACT:
	.ASCID /Processes are currently active, unable to perform assignment./

NO_SET_LOG:
	.ASCID /Unable to change log file name, assignment skipped./


CNTRLC_MSK:					; mask which holds ASCII code for
	.LONG 0					;  the CNTRL-C
	.LONG ^X0008

	; to hold extension for log files

LOG_EXT_DESC:
	.ASCID /.LOG/				; descriptor of extension for log file

NIL_EXT_DESC:					; nil descriptor so that MAKE_
	.ASCID //				; TMP_LOG_NAM could be used to
						; make a logical name


	; area to hold records to be written into the temporary command procedure
	; which is created when parameters are to be passed to the command
	; procedure being started up

COM_STAT_DESC:					; descriptor to get the final
	.ASCID /$ TCNTRLSTAT = $STATUS/		; status of a command procedure
						; which has parameters

COM_EXIT_DESC:					; descriptor to return the final
	.ASCID /$ EXIT TCNTRLSTAT/		; status of a command procedure
						; which has parameters

	; to hold extension for temporary command file

TMP_COM_EXT_DESC:
	.ASCID /.CM1/				; descriptor of extension for
						;  command file with parameters

COM_IMAGE:
	.ASCID  /SYS$SYSTEM:LOGINOUT.EXE/	; image name for com file

	; READ-ONLY SECTION FOR PARSE
	;
	; FAO strings to hold the error messages for the parse routine.
	; message consists of printing the record that failed and the token 
	; that it failed on.

RCRD_ERR_MSG:					; syntax error in record
	.ASCID	\Syntax error with record. Record skipped -- !/ !AD \

TOKEN_ERR_MSG:					; token which failed
	.ASCID	\Invalid symbol or keyword. Symbol is -- !/ !AD \

	
	; ASCII strings of the various file types, used to determine what kind
	; of file we have

EXE_STR:
	.ASCII /.EXE/				; for images

COM_STR:
	.ASCII /.COM/				; for command procedures

	.SBTTL	Process Info Data Structure
	.PSECT	PROCINFO,WRT,NOEXE,PAGE
;++
; Now make a buffer to hold information regarding the detached processes.
;  When a process gets created it is given a slot. This slot holds information
;  regarding that process.  The format of an individual slot is as follows:
;
;  offset
;    		+--------------+
;    0		|   FLINK      |
;    		+--------------+
;    4		|   BLINK      |
;    		+--------------+
;    8		|  FINALSTS    |
;    		+--------------+
;    12		|     PID      |
;    		+--------------+
;    16		|  TERMTIME    |
;    		|              |
;    		+--------------+
;    24		|    CPUTIM    |
;    		+--------------+
;    28		|   PAGEFLTS   |
;    		+--------------+
;    32		|  PGFLPEAK    |
;    		+--------------+
;    36		|    WSPEAK    |
;    		+--------------+
;    40		|    BIOCNT    |
;    		+--------------+
;    44		|    DIOCNT    |
;    		+--------------+
;    48		|     LOGIN    |
;    		|              |
;    		+--------------+
;    56		| PRCINFO_FLGS |
;    		+--------------+
;    60		| CHAN | T_ID  |
;    		+--------------+
;    64		|  NODE ADDR   |    
;    		+--------------+
;    68		| DEVICE ADDR  |
;    		+--------------+
;    72		| DIRECT ADDR  |
;		+--------------+
;    76		| FILENAME ADDR|
;    		+--------------+
;    80		| FIL_EXT ADDR |
;    		+--------------+
;    84		| VERSION ADDR |
;    	        +--------------+
;    88         |NOD_SZ|SPC_SZ |
;               +--------------+
;    92		|DEV_SZ|DIR_SZ |
;		+--------------+
;    96		|FIL_SZ|EXT_SZ |
;               +--------------+
;   100		|VER_SZ| SPARE |
;               +--------------+
;   104         |              |
;               |              |
;               |   complete   |
;    		|     file     |
;    		| specification|
;    		\              \
;    		\              \
;    		|              |
;    		+--------------+
;
;   
; The structure is accessed by three pointers: the AVAIL_LIST_HEAD which points
;  to next available free slot, the COMPLETE_Q_HEAD which points to the head
;  of the queue of completed processes, and the CURRENT_LIST_HEAD which points
;  to a list of currently running processes.  As slots are returned to the
;  available list, they are inserted at the head.
;
;--

	; make enough initial space to hold NUMB_OF_SLOTS processes

PROC_INFO_TOP:					; top of proc_info list
	.BLKB	NUMB_OF_SLOTS * PRCINFO$S_PRC_INFO

	; now make headers for the different types of lists

	; first for the available slots list

AVAIL_LIST_HEAD:				; header for available list
	.BLKQ 	1

	; for the completed process queue

COMPLETE_Q_HEAD:				; header for completed 
	.BLKQ 	1				;  process queue

	; and for the currently running processes list

CURRENT_LIST_HEAD:				; header for currently running 
	.BLKQ	1				;  process list


	.SBTTL	Read/Write Data
	.PSECT	RWDATA,WRT,NOEXE,PAGE


	; set up space to hold the values of the various counters

PROCESS_RUNNING:
	.LONG 0					; # of active detached processes

TOTAL_PROC_RUN:
	.LONG 0 				; total # of detached processes

ACTIVE_PROC_LIMIT:
	.LONG 1					;   detached processes

TOTAL_PROC_LIMIT:			 	; PARCNT, limit of total 
	.LONG 0					;   detached processes

PRIV_MSK:
	.QUAD 0					; quadword to hold privileges

	;
	; data area for inputs to the TSTCNTRL (FILNAM, DELLOG, REPORT,
	; and PARCNT).  there are descriptors of the keywords for the 
	; CLI and buffer areas to put the value associated with the keywords.
	; 
	; also included here is the information needed to do a $GETDVI on
	; SYS$COMMAND. this is to find out if the TSTCNTRL is being run
	; from a terminal or not (so that we know whether or not to 
	; enable control-c ast's.
	;

	; descriptors of keywords for the CLI

FAC_DESC:					; descriptor of FACILITY_CODE
	.ASCID	/FACILITY_CODE/

FILNAM_DESC:					; descriptor of FILNAM
	.ASCID 	/FILE_SPEC/


PARCNT_DESC:					; descriptor of PARCNT
	.ASCID 	/PARALLEL_COUNT/

REPORT_DESC:					; descriptor of REPORT
	.ASCID	/REPORT_TYPE/

DELLOG_DESC:					; descriptor of DELLOG
	.ASCID	/DELETE_LOG_FILE/

	; and descriptor areas for the respective values

FAC_IN:						; desc for FAC value
	.BLKW	1
	.BYTE	DSC$K_DTYPE_T,DSC$K_CLASS_D
	.BLKL	1

FILNAM_IN:					; desc for FILNAM value
	.BLKW	1
	.BYTE	DSC$K_DTYPE_T,DSC$K_CLASS_D
	.BLKL	1

REPORT_IN:					; desc for REPORT value
	.BLKW	1
	.BYTE	DSC$K_DTYPE_T,DSC$K_CLASS_D
	.BLKL	1

PARCNT_IN:					; desc for PARCNT value
	.BLKW	1
	.BYTE	DSC$K_DTYPE_T,DSC$K_CLASS_D
	.BLKL	1

	; the facility code that may have been changed

FAC_CODE:					; new facility code
	.BLKL	1

	; item list for $GETDVI on SYS$COMMAND

COMMAND_ITM_LST:				; item list for $GETDVI
	.WORD	4,DVI$_DEVCLASS			; find out if it is a terminal
	.LONG	IN_DEVICE_CLASS			; put result here
	.LONG	0
	.WORD	64,DVI$_DEVNAM			; get X-lated name of device
	.LONG	IN_DEVICE_STR			; put name of device here
	.LONG	IN_DEVICE_DESC			; and size here
	.LONG	0				; end-of-item list

IN_DEVICE_DESC:					; descriptor to hold translated
	.LONG	64				; name of SYS$COMMAND
	.ADDRESS IN_DEVICE_STR

IN_DEVICE_STR:					; buffer to hold translated name
	.BLKB	64

IN_DEVICE_CLASS:				; buffer to hold value of class
	.LONG	0				; characteristics

SYS_COMMAND:					; descriptor of SYS$COMMAND
	.ASCID	/SYS$COMMAND/

MBX_CHAN:
	.WORD 0					; channel # of termination mailbox

TERM_BUFF:
	.BLKB MAILBOX_SIZE			; buffer to hold mailbox

LOG_FIL_DESC:					; desc. for perm. log  file name
	.LONG 12
	.ADDRESS LOG_FIL_STR

LOG_FIL_STR:
	.ASCII /TSTCNTRL.LOG/			; default name
	.BLKB NAM$C_MAXRSS			; room for more

MSG_BLOCK:
	.BLKB 4					; hold $GETMSG info


	; descriptors for start and stop sentinels

START_DESC:
	.LONG START_STR_LEN			; fill in with default
	.ADDRESS START_STR

START_STR:
	.ASCII /BEGIN/
	START_STR_LEN = .-START_STR
	.BLKB RCRD_SIZE				; extra space if needed


STOP_DESC:
	.LONG STOP_STR_LEN			; fill in with default
	.ADDRESS STOP_STR

STOP_STR:
	.ASCII /ENDED/
	STOP_STR_LEN = .-STOP_STR
	.BLKB RCRD_SIZE				; extra space if needed


GETCHN_DESC:
	.LONG DIB$K_LENGTH
	.ADDRESS GETCHN_BUF


GETCHN_BUF:
	.BLKB DIB$K_LENGTH			; buffer to hold get channel info


MBX_UNIT:
	.WORD 0					; hold the mailbox unit number

;++
; This area is for the $CREPRC parameter list.  It gets changed by the 
;  Create Process Subroutine.  The default values are the ones shown.
;--

CREPRC_LIS:
	.LONG 12				; number of parameters
PIDADR:
	.LONG 0
IMAGE:
	.LONG 0
INPUT:
	.LONG 0
OUTPUT:
	.LONG 0
ERROR:
	.LONG 0
PRVADR:
	.LONG 0
QUOTA:
	.ADDRESS QUOTA_TABLE				; use same quota's as parent
PRCNAM:
	.LONG 0
BASPRI:
	.LONG 2
UIC:
	.LONG 0
MBXUNT:
	.LONG 0
STSFLG:
	.LONG 0

	; table to hold results of $GETJPI of the quota's of the parent process
	;  to be used for $CREPRC

QUOTA_TABLE:
	.BYTE PQL$_ASTLM
ASTLM:
	.LONG 6
	.BYTE PQL$_BIOLM
BIOLM:
	.LONG 6
	.BYTE PQL$_BYTLM
BYTLM:
	.LONG 8192
	.BYTE PQL$_CPULM
CPULM:
	.LONG 0
	.BYTE PQL$_DIOLM
DIOLM:
	.LONG 6
	.BYTE PQL$_ENQLM
ENQLM:
	.LONG 50
	.BYTE PQL$_FILLM
FILLM:
	.LONG 10
	.BYTE PQL$_PGFLQUOTA
PGFLQUOTA:
	.LONG 2048
	.BYTE PQL$_PRCLM
PRCLM:
	.LONG 8
	.BYTE PQL$_TQELM
TQELM:
	.LONG 8
	.BYTE PQL$_WSDEFAULT
WSDEFAULT:
	.LONG 100
	.BYTE PQL$_WSQUOTA
WSQUOTA:
	.LONG 120
	.BYTE PQL$_LISTEND

	; area to hold longwords for the flags

	; hold the main control case statement flags

CONTROL_CASE:					; case statement flags
	.LONG 	0

	; hold the create process case statement flags

CREATE_PROC_CASE:				; create process case flags
	.LONG	0

	; hold the TSTCNTRL flags

FLAGS:						; TSTCNTRL flags
	.LONG	^X003E

ASSIGN_CASE:					; flags for the case for the 
	.LONG	0				; assignment routines

PROC_TERM_IOSB:		; IOSB to hold status of QIO for a terminated process
	.QUAD 0

PRCNAMDESC:					; descriptor for user process name
	.LONG 0
	.ADDRESS PRCNAMSTR

PRCNAMSTR:
	.BLKB PROCESS_NAME_SIZ

EXIT_DESC:					; Exit handler descriptor
	.LONG	0
	.ADDRESS EXIT_HANDLER
	.LONG	1
	.ADDRESS STATUS

STATUS:
	.LONG SS$_ABORT				; status on exit

GETUIC:
	.WORD 4					; buffer for UIC from $GETJPI
	.WORD JPI$_UIC				; code for UIC
	.ADDRESS UIC_CODE			; put it in this address
	.LONG 0					; not used here
	.WORD 15				; size for process name
	.WORD JPI$_PRCNAM			; get user process name
	.ADDRESS PRCNAMSTR			; put it here
	.ADDRESS PRCNAMDESC			; put size in descriptor
	.LONG 0					; terminate block

UIC_CODE:
	.LONG 0					; holds current UIC

LNMGRPNUM:				; Equivalence name giving the table...
	.ASCII	/LNM$GROUP_/		; ...name in which mbx logical names...
	LNMGRP = .-LNMGRPNUM
	.BYTE	^A/ /[6]
	LNMGRPLEN = .-LNMGRPNUM		; ...are to be put

LNMGRPNIL:				; Descriptor to convert...
	.WORD	LNMGRPLEN-LNMGRP,DSC$K_CLASS_S
	.ADDRESS LNMGRPNUM+LNMGRP


PRC_NAM_DESC:
	.LONG 8					; holds process name of TSTCNTRL
	.ADDRESS PRC_NAM_STR

PRC_NAM_STR:
	.ASCII /TSTCNTRL/			; default process name
	.BLKB 7					; space for a different name

	; for error messages

FAO_BUF:					; FAO output string descriptor
	.WORD RCRD_SIZE,0
	.ADDRESS BUFFER

BUFFER_PTR:					; fake buffer for misc. strings
	.WORD RCRD_SIZE,0
	.ADDRESS BUFFER

BUFFER:						; FAO output buffer
	.BLKB RCRD_SIZE

GETMSG_DESC:					; descriptor for $GETMSG string
	.WORD RCRD_SIZE,0
	.ADDRESS GETMSG_BUF

GETMSG_PTR:
	.WORD RCRD_SIZE,0
	.ADDRESS GETMSG_BUF

GETMSG_BUF:
	.BLKB RCRD_SIZE

TTCHAN:
	.LONG 0					; channel associated w/ contrl. terminal

	; READ/WRITE SECTION FOR PARSE
	;
	; this section holds the results of the parse routine.  The labels
	; here are global throughout the entire TSTCNTRL and are used by the
	; various routines. 

PARSE_FLAGS:					; flags which are used by the 
	.BLKL	1				; Parse routine

DATA_RCRD_DESC:					; descriptor of the input data
	.LONG	RCRD_SIZE			; record.  record is placed here
	.ADDRESS DATA_RCRD_STR			; by RMS

DATA_RCRD_STR:					; input record goes here
	.BLKB	RCRD_SIZE

COMMENT_DESC:					; descriptor to hold 
	.LONG	RCRD_SIZE			; comment field
	.ADDRESS COMMENT_STR

COMMENT_STR:					; comment goes here
	.BLKB	RCRD_SIZE

SPEC_DESC:					; descriptor to hold the T-parsed
	.QUAD	0				; filespec

	; the following all pertain to the resultant filespec. this includes
	; the complete filespec and descriptors pointing to the different 
	; pieces of it.

FILE_SPEC_DESC:					; descriptor of the resultant
	.LONG	NAM$C_MAXRSS			; filespec after RMS 
	.ADDRESS FILE_SPEC_STR			; $PARSE

FILE_SPEC_STR:					; the actual resultant filespec
	.BLKB	NAM$C_MAXRSS

	; these are the descriptors pointing into the filespec

NODE_DESC:					; point to the node part
	.BLKQ	1

DEVICE_DESC:					; point to the device part
	.BLKQ	1

DIRECTORY_DESC:					; point to the directory part
	.BLKQ	1

FILENAME_DESC:					; point to the filename part
	.BLKQ	1

TYPE_DESC:					; point to the type field
	.BLKQ	1

VERSION_DESC:					; point to the version number
	.BLKQ	1

	; now set up data area for the remaining parts which are the results of
	; the parse

ASSIGN_VALUE_DESC:				; descriptor to hold the value
	.LONG	RCRD_SIZE			; of an assignment 
	.ADDRESS ASSIGN_VALUE_STR		; statement

ASSIGN_VALUE_STR:				; the actual value 
	.BLKB	RCRD_SIZE


PARAM_DESC:					; descriptor to hold the 
	.LONG	RCRD_SIZE			; parameter string
	.ADDRESS PARAM_STR

PARAM_STR:					; the actual string
	.BLKB	RCRD_SIZE

DELIMIT:					; 1 byte buffer to hold delimiter
	.BLKB	1				; of parameter string

TIME_DESC:					; descriptor the hold unconverted
	.QUAD	0				; time string

TIME_VALUE:					; quadword to hold converted
	.BLKQ	1				;  system time


	; make RMS structures to parse the filespec
	.ALIGN LONG

PRSE_FILESPC_FAB:				; FAB for the parse
	$FAB-
	 NAM = PRSE_FILESPC_NAM

PRSE_FILESPC_NAM:				; NAM to hold the filespec
	$NAM-
	 ESA = FILE_SPEC_STR,-			; expanded filespec goes here
	 ESS = NAM$C_MAXRSS			; this is maximum size


	.SBTTL	RMS-32 Data Structures
	.ALIGN	LONG

DATA_FILE_FAB:	
	$FAB -					; FAB for the data file
	 ORG = <SEQ>,-				; sequential file only
	 MRS = RCRD_SIZE,-
	 RFM = VAR				; allow variable records

DATA_FILE_RAB:
	$RAB -					; RAB for the data file records
	 FAB = DATA_FILE_FAB,-
	 PBF = TCNTRL_PRMT,-			; address of prompt string
	 PSZ = TCNTRL_PRMT_SIZ,-		; size of prompt string
	 ROP = PMT,-
	 UBF = DATA_RCRD_STR,-
	 USZ = RCRD_SIZE

TMP_LOG_FAB:
	$FAB -					; FAB for temporary log files
	 ORG = <SEQ>,-				; FNA & FNS will be done dynamically
	 MRS = LARGE_BUFFER,-
	 RAT = <CR>,-
	 RFM = VAR

TMP_LOG_RAB:
	$RAB -
	 FAB = TMP_LOG_FAB,-
	 USZ = LARGE_BUFFER

CNTRL_LOG_FAB:
	$FAB - 					; FAB for perm log file
	 FNA = LOG_FIL_STR,-			; holds the name
	 FNS = 13,-				; holds the default size
	 ORG = <SEQ>,-
	 MRS = LARGE_BUFFER,-
	 RFM = VAR,-
	 RAT = <CR>

CNTRL_LOG_RAB:
	$RAB -					; RBF & RSZ fields will be 
	 FAB = CNTRL_LOG_FAB			;  inserted dynamically

COM_FAB:
	$FAB -					; FAB for temporary file used to 
	 ORG = <SEQ>,-				; start up .COM with parameters
	 MRS = LARGE_BUFFER,-
	 RAT = <CR>,-
	 RFM = VAR

COM_RAB:
	$RAB -					; RAB for .COM file with parameters
	 FAB = COM_FAB				; RBF and RSZ will be inserted dynamically

DEL_COM_FAB:					; FAB to erase temp. command files
	$FAB -
	 ORG = <SEQ>,-
	 MRS = LARGE_BUFFER,-
	 RFM = VAR


	.SBTTL Local area for ID descriptor
	.PSECT ID_DESC_LOCAL,ABS,NOEXE,NOWRT,PAGE

	; PSECT to define offsets of local variables to the create process-
	;  name subroutine.  No values are stored here, these are only
	;  offsets and the actual values are stored on the stack.

ID_DESC:
	.BLKL 	1				; to hold size of ID string

ID_ADDR:
	.BLKL 	1				; to hold address of string

ID_STR:
	.BLKB 	ID_STR_SIZ			; ID string

ID_NUMB:					; ID number
	.BLKL	1

ID_DESC_LENGTH = .				; length of block


	.SBTTL	Local area for Process Termination Subroutine
	.PSECT	PROC_TERM_LOCAL,ABS,NOEXE,NOWRT,PAGE

	; PSECT to define offsets of local variables for the Process Termination
	;  Subroutine.  No values are stored here, these are only offsets
	;  and the actual values are stored on the stack.

TRMNTN_COM_DESC:				; descriptor to delete temporary
	.BLKL 	1				;  command file
	.BLKL	1				;  address of string

TRMNTN_COM_STR:
	.BLKB	FILENAME_LNGTH+FILE_EXT_LNGTH	; temporary command file name

LOG_RCRD_DESC:					; descriptor to hold temporary
	.BLKL	1				;  log file record
	.BLKL	1				;  address of record

LOG_RCRD_STR:					; log file record
	.BLKB	LARGE_BUFFER

TEMP_BUFF_DESC:					; temp. buffer to hold capitalized
	.BLKL	1				;  record to check for sentinels
	.BLKL	1				;  address of string

TEMP_BUFF_STR:					; capitalized string
	.BLKB	LARGE_BUFFER

TRMNTN_FIL_DESC:				; descriptor for terminated 
	.BLKL	1				;  file name
	.BLKL	1				; pointer to filename

TRMNTN_LOG_DESC:				; descriptor for temp. log file
	.BLKL	1				;  name
	.BLKL	1				;  address of log file name

TRMNTN_LOG_STR:					; terminated log file
	.BLKB	FILENAME_LNGTH+FILE_EXT_LNGTH

RTN_NAM_DESC:					; descriptor for the returned
	.BLKL	1				;  process' process name
	.BLKL	1				;  address of process name

RTN_NAM_STR:					; returned process name
	.BLKB	PROCESS_NAME_SIZ

PROC_TERM_LENGTH = .				; length of this block


	.SBTTL	Local area for create command procedure w/ parameters
	.PSECT	TEMP_COM_LOCAL,ABS,NOEXE,NOWRT,PAGE

	; PSECT to define offsets of local variables for creating a command
	; procedure to which parameters are to be passed.  No values are
	; stored here, these are only the offsets and the actual values
	; are stored on the stack.

TEMP_COM_DESC:					; holds the filename for the
	.BLKL	1				;  temporary command file (used
	.BLKL	1				;  when passing parameters)

TEMP_COM_STR:					; holds the filename
	.BLKB	FILENAME_LNGTH+FILE_EXT_LNGTH

COM_LINE_DESC:					; holds the command line to start
	.BLKL	1				;  up the real procedure. done
	.BLKL	1				;  as an indirect procedure

COM_LINE_STR:					; the complete filespec (look like
	.BLKB	LARGE_BUFFER			;  "$@filespec -")

COM_PARM_LENGTH = .				; length of this block


	.SBTTL	Local area for Create Process Subroutine
	.PSECT	CREAT_PROC_LOCAL,ABS,NOEXE,NOWRT,PAGE

	; PSECT to define offsets of local variables for the Create Process
	; Subroutine.  No values are stored here, these are only offsets
	; and the actual values are stored on the stack.

TEMP_PNAM_DESC:					; holds the process name of
	.BLKL	1				;  the detached process
	.BLKL	1

TEMP_PNAM_STR:					; holds the actual process name
	.BLKB	PROCESS_NAME_SIZ

TEMP_LOG_DESC:					; holds the log filename of the
	.BLKL	1				;  detached process
	.BLKL	1

TEMP_LOG_STR:					; holds the actual log filename
	.BLKB	FILENAME_LNGTH+FILE_EXT_LNGTH

MBX_LOGNAM_DESC:				; holds the logical name of a 
	.BLKQ	1				; mailbox which holds the 
						; parameters to an image

MBX_LOGNAM_STR:					; logical name goes here
	.BLKB	FILENAME_LNGTH

STRCT_TOP_BOT:					; 1st longword holds top of new
	.BLKQ	1				; structure, 2nd holds bottom

CREATE_PROC_LENGTH = .				; length of this block


	.SBTTL Local area for TPARSE and Get/Parse Routine
	.PSECT GET_PARSE_LOCAL,ABS,NOEXE,NOWRT,PAGE

	; PSECT to define offsets of local variables for the TPARSE routine
	; and for getting a record and parsing that record.  No values are
	; stored here, these are only offsets and the actual values are stored
	; on the stack.

DAT_PARSE_BLK:					; parameter block for TPARSE
	.BLKL	1				; count field (initialized to 8)
	.BLKL	1				; flag field
	.BLKB	TPA$K_LENGTH0-8			; buffer for rest of block

RCRD_ERR_DESC:					; holds the syntax error message
	.BLKQ	1				; and the invalid record

RCRD_ERR_FAO:					; descriptor for input to the
	.BLKQ	1				; FAO service

RCRD_ERR_STR:					; error message goes here
	.BLKB	2*RCRD_SIZE

TOKEN_ERR_DESC:					; holds the invalid token message
	.BLKQ	1				; and the token

TOKEN_ERR_FAO:					; descriptor for input to the
	.BLKQ	1				; FAO service

TOKEN_ERR_STR:					; message goes here
	.BLKB	2*RCRD_SIZE

GET_PARSE_LENGTH = .				; length of this block


	.SBTTL	Main Program
;++
; FUNCTIONAL DESCRIPTION:
;
;	This is the main routine of the TSTCNTRL, it will determine what 
;	the input record is and take appropiate action according to what
;	the record is.
;
; CALLING SEQUENCE:
;
;	None
;
; INPUT PARAMETERS:
;
; 	The logical names: FILNAM, PARCNT, DELLOG, and REPORT.  The ASCII
;	data file -- FILNAM.
;
; IMPLICIT INPUTS:
;
;	None
;
; OUTPUT PARAMETERS:
;
;	None
;
; IMPLICIT OUTPUTS:
;
;	None
;
; COMPLETION CODES:
;
; 	The final status of the TSTCNTRL is sent to EXIT_HANDLER by the
;	longword STATUS.
;
; SIDE EFFECTS:
;
;	Leaves a log file called TSTCNTRL.LOG, may leave other log files
;	if DELLOG is false.
;
;--
	.PSECT	TSTCNTRL,EXE,NOWRT,PAGE

	.DEFAULT DISPLACEMENT,WORD

.ENTRY TSTCNTRL,^M<>				; Entry mask

	MOVAL	SSERROR,(FP)			; declare an exception handler

	$SETSFM_S ENBFLG = #1			; Enable system service failure mode
	$DCLEXH_S DESBLK = EXIT_DESC		; Declare an exit handler

	; get the facility code for output messages

	PUSHAQ	FAC_IN				; descriptor for fac. code
	PUSHAQ	FAC_DESC			; keyword FACILITY_CODE
	CALLS	#2,G^CLI$GET_VALUE		; get the new code

	; convert the code to binary

	PUSHAL	FAC_CODE			; binary code goes here
	PUSHAQ	FAC_IN				; ascii code number
	CALLS	#2,G^OTS$CVT_TI_L		; convert the number

	; get privileges

	INSV	#1,#PRV$V_WORLD,#1,PRIV_MSK	; need world in order to stop processes
	INSV	#1,#PRV$V_DETACH,#1,PRIV_MSK	; set mask for detach privilege
	$SETPRV_S ENBFLG = #1,-			; Get the detached privilege
		  PRVADR = PRIV_MSK

CHK_CNTL_C:
	; look at SYS$COMMAND and see if it is coming from a terminal.
	; if it is then get the channel number and enable control-c's
	; to that terminal.

	$GETDVIW_S DEVNAM = SYS_COMMAND,-	; look at SYS$COMMAND
		   EFN	 = #1,-			; wait for this event flag
		   ITMLST = COMMAND_ITM_LST	; get class and name

	; now, check the device class and see if it is a terminal

	CMPL	IN_DEVICE_CLASS,#DC$_TERM	; is device a terminal?
	BNEQ	10$				; no, don't enable control-c's

	; device is a terminal, so enable control-c's

	$ASSIGN_S DEVNAM = IN_DEVICE_DESC,-	; assign a channel to terminal
		  CHAN   = TTCHAN

	$QIOW_S	  CHAN   = TTCHAN,-		; with this channel,
		  FUNC   = #IO$_SETMODE!IO$M_CTRLCAST,- ; establish a control-c
		  P1     = CCASTHAND		; handler here.


10$:
	; get the data filename 

	PUSHAQ	FILNAM_IN			; descriptor for FILNAM
	PUSHAQ	FILNAM_DESC			; keyword for CLI
	CALLS	#2,G^CLI$GET_VALUE		; get the filnam

	; store filename in the FAB and OPEN it

	$FAB_STORE FAB = DATA_FILE_FAB,-	; the data fab
		   FNA = @<DSC$A_POINTER+FILNAM_IN>,- ;	address of filename
		   FNS = <DSC$W_LENGTH+FILNAM_IN> ; size of filename

PEN_FILE:

	; now open the data file.  File may be a PPF viz SYS$INPUT

	$OPEN	FAB = DATA_FILE_FAB		; open the data file

	BLBS	R0,10$				; if successful, then continue

	; OPEN failed, then something wrong with FILNAM
	; write error for invalid FILNAM

	PUSHAQ	FILNAM_ERR			; error message
	PUSHL	#1
	PUSHL	#TCNTRL$_TEXT!STS$K_SEVERE	; fatal error
	CALLS	#3,G^LIB$SIGNAL			; write message

	BRW	END_TCNTRL			; and exit

10$:
	; connect the data stream

	$CONNECT RAB = DATA_FILE_RAB,-		; connect the stream
		 ERR = RMSERR

GET_QUAL:
	; now get the other qualifiers from the CLI

	; the REPORT format

	PUSHAQ	REPORT_IN			; descriptor for the value
	PUSHAQ	REPORT_DESC			; descriptor of keyword for CLI
	CALLS	#2,G^CLI$GET_VALUE		; get the value

	CMPB	@<DSC$A_POINTER+REPORT_IN>,-	; is report short?
		#^A/S/

	BNEQ 	10$				; no, check again
	BICL2	#TCNTRL$M_LONG_REPORT,FLAGS	; yes, change flag
	BRB	20$				; continue
	
10$:
	CMPB	@<DSC$A_POINTER+REPORT_IN>,-	; is report long?
		#^A/L/
	BEQL	20$				; yes, change nothing

	; no, so print warning and use default 

	PUSHAL	REPORT_ERR
	PUSHL	#1
	PUSHL 	#TCNTRL$_TEXT!STS$K_WARNING
	CALLS	#3,G^LIB$SIGNAL

20$:
	; get the concurrent process count (PARCNT)

	PUSHAQ	PARCNT_IN			; descriptor for PARCNT
	PUSHAQ	PARCNT_DESC			; keyword name for CLI
	CALLS	#2,G^CLI$GET_VALUE		; get the value

	; convert PARCNT string into a number

	PUSHAL	TOTAL_PROC_LIMIT		; place for converted number
	PUSHAL	PARCNT_IN			; string to be converted
	CALLS 	#2,G^OTS$CVT_TI_L		; convert text to longword

	; see if valid PARCNT

	CMPL	TOTAL_PROC_LIMIT,#0		; is PARCNT <= 0?
	BGTR	30$				; no, continue
	PUSHAL	ZERO_PARCNT			; yes, print warning . . .
	PUSHL	#1
	PUSHL	#TCNTRL$_TEXT!STS$K_WARNING
	CALLS	#3,G^LIB$SIGNAL
	
	MOVL	#1,TOTAL_PROC_LIMIT		; . . . and use PARCNT = 1

30$:

	MOVL	TOTAL_PROC_LIMIT,-		; initialize maximum number of 
		ACTIVE_PROC_LIMIT		; active processes

	; lastly check to see if the temp. log files are to be deleted

	PUSHAQ	DELLOG_DESC			; keyword for CLI
	CALLS	#1,G^CLI$PRESENT		; is the keyword there?

	CMPL	#CLI$_NEGATED,R0		; was the value negated?
	BNEQ	40$				; no, use default

	BICL2	#TCNTRL$M_DELETE_TEMP_LOG,FLAGS	; yes, change flag

40$:
	; make connection for termination mailbox

	$CREMBX_S CHAN = MBX_CHAN,-		; create termination mailbox
		  MAXMSG = #MAILBOX_SIZE	; message from process

	$QIO_S    CHAN = MBX_CHAN,-		; do a read to mailbox
		  FUNC = #IO$_READVBLK,-
		  ASTADR = PROC_TERM_AST,-	; on read, goto process termination
		  IOSB = PROC_TERM_IOSB,-
		  P1 = TERM_BUFF,-
		  P2 = #MAILBOX_SIZE

	; get unit number of mailbox for create process

	$GETCHN_S CHAN = MBX_CHAN,-		; want unit # of mailbox
		  PRIBUF = GETCHN_DESC
	MOVAL	 GETCHN_BUF, R2			; get starting addr of getchan 
	MOVW	 DIB$W_UNIT(R2), MBX_UNIT	; get the unit #

	; initialize the data structure

	PUSHAQ	AVAIL_LIST_HEAD			; the avail. list pointer
	PUSHAL 	PROC_INFO_TOP			; the addr of the top of struct.
	PUSHL	#PRCINFO$S_PRC_INFO		; the byte count of the slot size
	PUSHL	#NUMB_OF_SLOTS			; the number of slots we have
	CALLS	#4,INIT_STRUCT			; initialize the structure

	; now get the UIC of the TSTCNTRL program

	$GETJPIW_S ITMLST = GETUIC,-		; all we want is the UIC
		   EFN	 = #1

	; ensure that processes we create can access their SYS$INPUT

	PUSHL	#2				; we'll convert a 2-byte...
	MOVZWL	LNMGRPNIL,-(SP)			; ...integer to ASCII...
	PUSHAL	LNMGRPNIL
	PUSHAL	UIC_CODE+2			; ...using group number of...
	CALLS	#4,G^OTS$CVT_L_TO		; ...the process which runs us
	$CRELNM_S TABNAM = LNMPRCDIR,-		; force SYS$INPUT mbx name...
		  LOGNAM = LNMTMPMBX,-		; ...to appear in...
		  ITMLST = LNMITMLST		; ...a group logical name table

	; now get the quotas and base priority of the parent process
	
	$GETJPIW_S ITMLST = QUOTA_LIS,-		; all quotas and priority
		   EFN    = #1

GET_DATA_RCRD:

	; the first two records may be special assignment statements
	; get them and find out.

	CLRL	CONTROL_CASE			; make sure nothing is set

	CALLS	#0,GET_PARSE_SBRTN		; get and parse the record

	; if it is an assignment statement, then go do it
	;  otherwise, go directly to the begin message and don't get second record

	BBC	#CASE$V_ASSIGN,CONTROL_CASE,STRT_MSG  ; it isn't assignment,
						; so goto start message

	PUSHAL	CONTROL_CASE
	CALLS	#1,ASSIGN_SBRTN			; perform the assignment


	; we had one assignment, see if we have a second one

	CALLS	#0,GET_PARSE_SBRTN		; get and parse the record

	; if it is an assignment statement, then go do it
	;  otherwise, go directly to the begin message 

	BBC	#CASE$V_ASSIGN,CONTROL_CASE,STRT_MSG  ; it isn't assignment,
						; so goto start message

	PUSHAL	CONTROL_CASE
	CALLS	#1,ASSIGN_SBRTN			; perform the assignment


STRT_MSG:
	; now, create the permanent log file

	BISL2	#TCNTRL$M_SET_LOGNAM,FLAGS	; cannot change the logfile name

	$CREATE FAB = CNTRL_LOG_FAB,-		; make the file
		ERR = RMSERR

	$CONNECT RAB = CNTRL_LOG_RAB,-		; establish a stream
		 ERR = RMSERR

	; set the process name of the controlling process

	$SETPRN_S  PRCNAM = PRC_NAM_DESC	; set default of process name

	; now print the starting time descriptor

	BISL2	#TCNTRL$M_WRT_MSG,FLAGS		; always print this message

	CLRL	-(SP)
	PUSHAL	PRC_NAM_DESC
	PUSHL	#2
	PUSHL	#TCNTRL$_BEGIND!STS$K_INFO
	CALLS	#4,G^LIB$SIGNAL

	; now set the PARSE bit and start the main case loop
	
	BISL2	#CASE$M_PARSE,CONTROL_CASE	; make sure we do a parse

MAIN_LOOP:
	; This is the loop which holds all the control for the various
	;  subroutines.  Control goes to each subroutine depending on which
	;  bits in CONTROL_CASE are set.

	; determine if we are to continue with loop.  use the following . . .
	; do while ~TCNTRL$V_EXIT v PROCESS_CNT > 0

	BBS	#TCNTRL$V_EXIT,FLAGS,10$	; is the exit flag set . . .
	BRB	20$				; no, so contine

10$:
	CMPL 	PROCESS_RUNNING,#0		; . . . is the number of running
	BGTR	20$				;  processes <= 0?
	BRW	END_MAIN			; yes, get out of loop

20$:
	; now find out where we are suppose to case to

	; find the first set bit in the case word and then case off of it.
	FFS	#0,-				; start looking from position zero
		#<CASE$S_CNTRL_CASE*8>,-	; the size is this many bits
		CONTROL_CASE,-			; this is the base
		R10				; and the results goes here

	CASEB	R10,#0,#<CASE$K_CNTRL_CASE_SIZE - 1>	; perform case
30$:
	.WORD	ABORT_TCNTRL_BLK - 30$
	.WORD	TIMER_EXP_BLK    - 30$
	.WORD	PROCESS_TERM_BLK - 30$
	.WORD	EOF_BLK          - 30$
	.WORD	FILE_BLK         - 30$
	.WORD 	ASSIGN_BLK       - 30$
	.WORD 	CREATE_PROC_BLK  - 30$
	.WORD	GET_PARSE_BLK    - 30$

HIBER_BLK:
	; reached here by falling through case with no match
	; go into HIBER and sleep.

	$HIBER_S

	; and do next case

	BRW	CONTIN_MAIN			; perform next case


ABORT_TCNTRL_BLK:
	; reached this via an AST setting CASE$V_ABORT
	; begin abnormal abortion of the TSTCNTRL

	PUSHAL	CONTROL_CASE			; flags for control case statement
	PUSHAL	FLAGS				; flags for TSTCNTRL
	CALLS	#2,ABORT_TCNTRL_SBRTN		; start termination

	; do next case

	BRW	CONTIN_MAIN			; perform next case

TIMER_EXP_BLK:
	; reached this via an AST setting CASE$V_TIME_EXP
	; stop currently running processes and continue

	PUSHAL	PARSE_FLAGS			; flags saying what has been parsed
	PUSHAL	CONTROL_CASE			; flags for control case statement
	PUSHAL	FLAGS				; flags for TSTCNTRL
	CALLS	#2,TIME_EXP_SBRTN		; stop processes

	; do next case

	BRW	CONTIN_MAIN			; perform next case
	
PROCESS_TERM_BLK:
	; reached this via an AST setting CASE$V_PROC_TERM
	; handle the terminated process

	PUSHAQ	AVAIL_LIST_HEAD			; header of available slots
	PUSHAQ	STOP_DESC			; descriptor of ending sentinel
	PUSHAQ	START_DESC			; descriptor of beginning sentinel
	PUSHAL	CONTROL_CASE			; flags for control case statement
	PUSHAL	FLAGS				; flags for TSTCNTRL
	PUSHAL	PROCESS_RUNNING			; number of processes still running
	PUSHAQ	COMPLETE_Q_HEAD			; header of completed process queue
	CALLS	#7,PROCESS_TERM_SBRTN		; handle the terminated process

	; and do next case

	BRW	CONTIN_MAIN			; perform next case


EOF_BLK:
	; reached this by GET_PARSE setting CASE$V_EOF
	; handle the end-of-file

	PUSHAL	DATA_FILE_RAB			; start of data file RAB
	PUSHAL	FLAGS				; flags for the TSTCNTRL
	PUSHAL 	CONTROL_CASE			; flags for control case statement
	CALLS	#3,EOF_SBRTN			; handle end-of-file

	; and do next case

	BRW	CONTIN_MAIN			; perform next case

FILE_BLK:
	; reached this by GET_PARSE or PROC_TERM setting CASE$V_FILE
	; handle having a file spec

	PUSHAL	ACTIVE_PROC_LIMIT		; max process active
	PUSHAL	PROCESS_RUNNING			; number processes currently active
	PUSHAL	PARSE_FLAGS			; flags set by GET_PARSE
	PUSHAL	FLAGS				; TSTCNTRL flags
	PUSHAL	CONTROL_CASE			; main case flags
	CALLS	#5,FILE_SBRTN			; see if we can start the process

	; and do next case

	BRW	CONTIN_MAIN			; perform next case

ASSIGN_BLK:
	; reached this by GET_PARSE setting CASE$V_ASSIGN
	; handle the assignment

	PUSHAL	CONTROL_CASE			; main case flags
	CALLS	#1,ASSIGN_SBRTN			; do the assignment

	; and do next case

	BRW	CONTIN_MAIN			; perform next case

CREATE_PROC_BLK:
	; reached this by FILE setting CASE$V_CREATE_PROC
	; create the detached process

	PUSHAL	PARSE_FLAGS			; flags from parse routine
	PUSHAL	TOTAL_PROC_LIMIT		; limit of allowed processes
	PUSHAQ	CURRENT_LIST_HEAD		; head of currently running list
	PUSHAQ	AVAIL_LIST_HEAD			; head of available slots
	PUSHAL	CREATE_PROC_CASE		; case of type of proc to start
	PUSHAL	CONTROL_CASE			; main case flags
	PUSHAL	FLAGS				; TSTCNTRL flags
	PUSHAL	PROCESS_RUNNING			; number of processes running
	PUSHAL	TOTAL_PROC_RUN			; number of processes ran so far
	CALLS	#9,CREATE_PROC_SBRTN		; create the process

	; and do next case

	BRW	CONTIN_MAIN			; perform next case

GET_PARSE_BLK:
	; reached by CASE$V_PARSE being set
	; get a record and parse it

	CALLS	#0,GET_PARSE_SBRTN		; parse the record

	; and do next case

	BRW	CONTIN_MAIN			; perform next case
	

CONTIN_MAIN:
	BRW	MAIN_LOOP			; continue loop


END_MAIN:
	; made it through, time to clean up

	; print ending time stamp

	BISL2	#TCNTRL$M_WRT_MSG,FLAGS		; always write this message

	PUSHL	#0
	PUSHAL	PRC_NAM_DESC
	PUSHL	#2
	PUSHL	#TCNTRL$_ENDEDD!STS$K_INFO
	CALLS	#4,G^LIB$SIGNAL


END_TCNTRL:

	; do clean up

	$CANEXH_S				; cancel the exit handler

	$SETAST_S  ENBFLG = #0			; disable any further AST's
	$SETSFM_S  ENBFLG = #0			; don't report sys service failure
	
	$DASSGN_S  CHAN = MBX_CHAN		; deassign the mailbox channel
	$DASSGN_S  CHAN = TTCHAN		; deassign the terminal channel

	$CLOSE	FAB = DATA_FILE_FAB		; close data file
	$CLOSE	FAB = CNTRL_LOG_FAB		; close the perm log file

	$SETPRN_S  PRCNAM = PRCNAMDESC		; reset users process name

	; now, find out how we are leaving, and set exit accordingly

	MOVL	#SS$_NORMAL,R0			; assume success

	BBC	#TCNTRL$V_EXIT_HAND,FLAGS,10$	; did we come from exit handler?
	RSB					; yes, so go back there

10$:
	BBC	#TCNTRL$V_ABORT,FLAGS,20$	; is this an abort condition?
	MOVL	#TCNTRL$_ABORT,R0		; yes, so signal that

20$:

	BISL2	#STS$M_INHIB_MSG,R0		; don't print message again

	RET					; time to go . . .

	.SBTTL Abort TSTCNTRL Subroutine

	; define offsets for parameters

	ABT_FLAGS  = 4
	ABT_C_CASE = 8
;++
; FUNCTIONAL DESCRIPTION:
;
;	This subroutine is called when the TSTCNTRL must be abnormally 
;	terminated.  The reasons for termination may be that a control-C has
;	been typed by the user, an unexpected system service or RMS error has
;	occured, or the TSTCNTRL is being forced to exit by another process.
;	This routine is reached by the CASE$V_ABORT bit being set.  The routine
;	terminates all currently running process, and clears all of the case 
;	flags (except for the PROC_TERM flag) and sets a flag (TCNTRL$V_ABORT)
;	so that all other subroutines know that the TSTCNTRL is in an abort 
;	phase.  Control then returns to the main case loop where it will stay
;	until all of the currently running process have terminated.
;
; CALLING SEQUENCE:
;
;	PUSHAL	CONTROL_CASE
;	PUSHAL	FLAGS
;	CALLS	#2,ABORT_TCNTRL_SBRTN
;
; INPUT PARAMETERS:
;
;	ABT_FLAGS(AP)  - the address of the TSTCNTRL flags
;	ABT_C_CASE(AP) - the address of the main control case flags
;
; IMPLICIT INPUTS:
;
;	None.
;
; OUTPUT PARAMETERS:
;
;	None.
;
; IMPLICIT OUTPUTS:
;
;	The main control case flag will be cleared of everything except for
;	CASE$V_PROC_TERM.
;	The TCNTRL$V_ABORT flag will be set.
;
; COMPLETION CODES:
;
;	SS$_NORMAL
;
; SIDE EFFECTS:
;
;	This will cause the currently running processes to be aborted.
;	It will cause the case to only go to PROC_TERM_SBRTN.
;--

ABORT_TCNTRL_SBRTN:
	.WORD ^M<R2>

	; clear the case flags of everything except the process termination
	; flag.

	MOVL	#-1,R2				; set all bits 
	BICL2	#CASE$M_PROC_TERM,R2		; clear the proc term bit
	BICL2	R2,@ABT_C_CASE(AP)		; and clear everything but 
						; process term bit

	; clear the process pending bit so we don't start it

	BICL2	#TCNTRL$M_PROC_PEND,@ABT_FLAGS(AP) ; no processes pending to start

	; print out a message saying that we are going to abort

	PUSHAQ	ABORT_MSG			; say we aborting
	PUSHL	#1
	PUSHL	#TCNTRL$_TEXT!STS$K_WARNING	; print it as a warning
	CALLS	#3,G^LIB$SIGNAL			; write the message

	; now stop all currently running processes

	CALLS	#0,ABORT_PROCESSES		; abort all detached processes

	; we are now in abort phase, so let everyone else know

	BISL2	#TCNTRL$M_EXIT,@ABT_FLAGS(AP)	; exit when we can

	MOVL	#SS$_NORMAL,R0			; return success

	RET


	.SBTTL	Timer Expiration Subtroutine

	; define offsets for parameters

	TIM_FLAGS  = 4
	TIM_C_CASE = 8
	TIM_PRSE   = 12

;++
; FUNCTIONAL DESCRIPTION:
;
;	This subroutine is reached when the timer (MAXTIME) to prevent processes
;	from hanging the TSTCNTRL expires.  The expiration of the timer sets a 
;	case flag, CASE$V_TIME_EXP, via the timer AST routine (TIME_EXP_AST).
;	This routine then writes a message, aborts all currently running 
;	processes, and sets a TSTCNTRL flag (TCNTRL$V_TIME_EXP) to signal other
;	routines that the timer has expired.
;
; CALLING SEQUENCE:
;
;	PUSHAL	PARSE_FLAGS
;	PUSHAL	CONTROL_CASE
;	PUSHAL	FLAGS
;	CALLS 	#2,TIME_EXP_SBRTN
;
; INPUT PARAMETERS:
;
;	TIM_FLAGS(AP)  - the address of the TSTCNTRL flags
;	TIM_C_CASE(AP) - the address of the main control case flags
;	TIM_PRSE(AP)   - the address of the parse flags
;
; IMPLICIT INPUTS:
;
;	None.
;
; OUTPUT PARAMETERS:
;
;	None.
;
; IMPLICIT OUTPUTS:
;
;	The flag TCNTRL$V_TIME_EXP will be set.
;	The flag TCNTRL$V_ABLE_TO_WRAP is cleared.
;
; COMPLETION CODES:
;
;	SS$_NORMAL
;
; SIDE EFFECTS:
;
;	The TCNTRL$V_TIME_EXP bit being set will cause the GET_PARSE_SBRTN to
;	keep getting records until the end of the current segment.  A segment
;	is defined to be ended when either the next process to be started is
;	a "runs alone" process (i.e., when PARSE$V_RUNS_OTHERS = 0), or when
;	the end-of-file is reached.
;
;
;	Wrapping of the data file is disabled.
;--

TIME_EXP_SBRTN:
	.WORD ^M<>

	; clear out the parse flag which got us here, and turn off wrapping

	BICL2	#CASE$M_TIME_EXP,@TIM_C_CASE(AP)  ; don't case back here
	BISL2	#CASE$M_PARSE,@TIM_C_CASE(AP)	; but do parse instead

	BICL2	#TCNTRL$M_ABLE_TO_WRAP,@TIM_FLAGS(AP) ; wrapping no longer allowed

	; now, print out message saying that the timer has expired

	PUSHAQ	TIME_OUT_ERR			; time was exceeded
	PUSHL	#1
	PUSHL	#TCNTRL$_TEXT!STS$K_WARNING
	CALLS	#3,G^LIB$SIGNAL			; write the message

	; set bit saying that timer expired

	BISL2	#TCNTRL$M_TIME_EXP,@TIM_FLAGS(AP)  ; say that timer expired

	; now abort all currently running processes

	CALLS	#0,ABORT_PROCESSES		; abort all detached processes

	; now, check to see if the record we just parsed is an End-of-segment.
	; That is, a process to be run by itself, or an EOF.  If it is EOS, then
	; goto the proper routine, else goto GET_PARSE.

	BBC	#TCNTRL$V_EXIT,@TIM_FLAGS(AP),10$ ; not time to exit, so see if
						; process is pending

	; we have an end-of-file, so turn off parse 

	BICL2	#CASE$M_PARSE,@TIM_C_CASE(AP)	; EOF, so turn off parse
	BRB	20$				; and leave turning off time expo.

10$:
	; do we have a process pending to be run?

	BBC	#TCNTRL$V_PROC_PEND,@TIM_FLAGS(AP),30$ ; no proc pending, exit

	; we have a process pending, is it to be run alone?

	BBS	#PARSE$V_PROC_RUNS_OTHERS,@TIM_PRSE(AP),30$ ; proc not seq, exit

	; we have a process to be run alone, prepare it to run

	BISL2	#CASE$M_FILE,@TIM_C_CASE(AP)	; try and start process now

	BICL2	#TCNTRL$M_PROC_PEND,@TIM_FLAGS(AP) ; clear pending flag

20$:
	; End-of-segment, so turn off time expired flag

	BICL2	#TCNTRL$M_TIME_EXP,@TIM_FLAGS(AP) ; since EOS, clear expired flag
30$:
	MOVL	#SS$_NORMAL,R0			; return success

	RET

	
	.SBTTL  Process Termination Subroutine

	; define offsets for parameters

	P_CMPLT_Q_HEAD = 4
	P_PROCESS_RUN  = 8
	P_TERM_FLG     = 12
	P_CNTRL_CASE   = 16
	STRT_DESC      = 20
	STP_DESC       = 24
	P_AVL_LST_HEAD = 28

;++
; FUNCTIONAL DESCRIPTION:
;
;	This subroutine is utilized whenever a detached process is completed.
;	It determines whether or not the detached process succeeded and
;	it will print to the console and the log file the proper records from
;	the process' temporary log file.
;
; CALLING SEQUENCE:
;
;	This is called when CASE$V_PROC_TERM is set (set by a previous AST).
;		PUSHAQ	AVAIL_LIST_HEAD
;		PUSHAQ	STOP_DESC
;		PUSHAQ	START_DESC
;		PUSHAL	CONTROL_CASE
;		PUSHAL	FLAGS
;		PUSHAL	PROCESS_RUNNING
;		PUSHAQ	COMPLETE_Q_HEAD
;		CALLS	#7,PROCESS_TERM_SBRTN
;
; INPUT PARAMETERS:
;
;	P_CMPLT_Q_HEAD(AP) - address of quadword header of the completed process
;		queue.
;	P_PROCESS_RUN(AP) - address of a longword holding a count of the currently
;		running processes (including this one).
;	P_CNTRL_CASE(AP) - address of a longword holding the CONTROL_CASE flags.
;	P_TERM_FLG(AP) - address of a longword holding the TSTCNTRL flags.
;	STRT_DESC(AP) - address of a quadword descriptor of the beginning sentinal.
;	STP_DESC(AP) - address of a quadword descriptor of the ending sentinal.
;	P_AVL_LST_HEAD(AP) - address of a quadword header of the available list.
;
; IMPLICIT INPUTS:
;
;	Termination information off of the completed process queue.
;
; OUTPUT PARAMETERS:
;
;	None
;
; IMPLICIT OUTPUTS:
;	
;	None
;
; COMPLETION CODES:
;
;	SS$_NORMAL
;
; SIDE EFFECTS:
;
;	May change the flags PRCINFO$V_MBX_CHAN, CASE$V_PROCTERM,
;	CASE$V_FILE, and TCNTRL$V_PROC_PEND.
;--


PROCESS_TERM_SBRTN:
	.WORD  ^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>

	; assume we don't have to come back here.

	BICL2	#CASE$M_PROC_TERM,@P_CNTRL_CASE(AP)  ;  clear flag to here

	; assume we want to parse again

	BISL2	#CASE$M_PARSE,@P_CNTRL_CASE(AP)	; assume we parse again

	; however, we don't want to parse if either EXIT v CREATE_PROC v
	; ABORT are set. 

	BBS	#TCNTRL$V_EXIT,@P_TERM_FLG(AP),3$ ; if exit, then clear parse

	BBS	#CASE$V_CREATE_PROC,@P_CNTRL_CASE(AP),3$ ; if create, clear parse

	BBS	#TCNTRL$V_ABORT,@P_TERM_FLG(AP),3$ ; if abort, clear parse

	BRB	5$				; none were set, parse next

3$:
	BICL2	#CASE$M_PARSE,@P_CNTRL_CASE(AP)	; don't parse again

5$:
	; initialize the stack area for local variables

	SUBL2	#PROC_TERM_LENGTH,SP		; allocate space for local storage

	MOVC5	#0,#0,#0,#PROC_TERM_LENGTH,(SP)	; clear out local storage
	MOVL	SP,R10				; keep pointer to local storage

	; see if any more completed processes are queued up

	; turn off AST's to avoid a race condition

	$SETAST_S ENBFLG = #0			; disable AST's
	CLRL	R7				; assume it was disabled
	CMPL	R0,#SS$_WASSET			; were AST's enabled?
	BNEQ	10$				; no, so continue
	MOVL	#1,R7				; yes, so save it to be reenabled

10$:
	; now, remove entry from head of queue and get address of entry 

	REMQHI	@P_CMPLT_Q_HEAD(AP),R11		; this is the address of entry

	; if queue is empty then turn off CASE$V_PROC_TERM flag, otherwise
	;  make sure it is set.

	BEQL	20$				; we just removed the last entry

	BISL2	#CASE$M_PROC_TERM,@P_CNTRL_CASE(AP)  ; there are still entries on
						;  the queue, so come back to this
						;  routine when done.

20$:
	; now reset AST's

	$SETAST_S ENBFLG = R7			; set AST to previous state

	
	; change the count of processes running

	DECL	@P_PROCESS_RUN(AP)		; one less process running

	; now see if timer should be canceled

	BNEQ	30$				; not zero, so just continue
	$CANTIM_S  REQIDT = #MAXTIME_ID		; none running, so cancel timer
	BICL2	#TCNTRL$M_TIMER_SET,@P_TERM_FLG(AP) ; no timer running, so clear flag
	
30$:
	; see if a mailbox was made to pass parameters to an image, if one
	; was made, deassign the channel

	BBCC	#PRCINFO$V_MBX_CHAN,-		; is there a channel?
		PRCINFO$L_FLAGS(R11),40$

	$DASSGN_S  CHAN = PRCINFO$W_MBX_CHAN(R11) ; yes, deassign it

40$:
	; make the termination file descriptor

	MOVZWL	PRCINFO$W_FILNAM_SIZ(R11),-
		TRMNTN_FIL_DESC(R10)		; get the size of filename

	MOVL	PRCINFO$A_FILNAM(R11),-
		<DSC$A_POINTER+TRMNTN_FIL_DESC>(R10) ; point to filename

	; initialize the descriptor area for the temporary command file

	MOVAL	TRMNTN_COM_STR(R10),-		; put address of string
		<TRMNTN_COM_DESC+DSC$A_POINTER>(R10)  ; in pointer area'

	; make the filename for the temporary command file
	
	PUSHAQ	TRMNTN_FIL_DESC(R10)		; the test filename
	PUSHAW	PRCINFO$W_ID_NUMB(R11)		; the ID number
	PUSHAQ	TMP_COM_EXT_DESC		; the file extension
	PUSHAQ	TRMNTN_COM_DESC(R10)		; where the new filename goes
	CALLS	#4,MAKE_TMP_LOG_NAM		; and make the name

	; delete the temporary command log file (if any), use TMP_LOG_RAB

	$FAB_STORE FAB = DEL_COM_FAB,-
		   FNA = TRMNTN_COM_STR(R10),-	; the file name is already made
		   FNS = TRMNTN_COM_DESC(R10)

	$ERASE	   FAB = DEL_COM_FAB,-
		   ERR = RMSERR			; erase the file, 

	; initialize descriptor area for temporary log file name

	MOVAL	TRMNTN_LOG_STR(R10),-		; put the address in the
		<TRMNTN_LOG_DESC+DSC$A_POINTER>(R10)  ; pointer area

	; now make the temporary log file name

	PUSHAQ	TRMNTN_FIL_DESC(R10)		; the test file name
	PUSHAW	PRCINFO$W_ID_NUMB(R11)		; the ID number
	PUSHAQ	LOG_EXT_DESC			; the temp log extension
	PUSHAQ	TRMNTN_LOG_DESC(R10)		; the temp log file
	CALLS	#4,MAKE_TMP_LOG_NAM		; and make the log name

	; now adjust FAB to hold this log filename

	$FAB_STORE FAB = TMP_LOG_FAB,-		; make FAB have log file name
		   FNS = TRMNTN_LOG_DESC(R10),-
		   FNA = TRMNTN_LOG_STR(R10)

	; initialize the descriptor area for the return process name

	MOVAL	RTN_NAM_STR(R10),-		; put the address in the
		<RTN_NAM_DESC+DSC$A_POINTER>(R10)  ; pointer area

	; now make the return process name

	PUSHAL	TRMNTN_FIL_DESC(R10)		; the test file name
	PUSHAL	PRCINFO$W_ID_NUMB(R11)		; the ID number
	PUSHAL	RTN_NAM_DESC(R10)		; the return process name
	CALLS	#3,MAKE_PROC_NAM		; and make the process name

CHK_ABT_PROC:
	; see if the process was aborted by the TSTCNTRL. If it was, then
	; check the timer which watches to see if a process aborts and 
	; then print out an abort message and skip the rest

	BBS	#PRCINFO$V_PROC_ABORTED,-	; aborted, so report error
		PRCINFO$L_FLAGS(R11),5$
	
	BRW	CHCK_ERROR			; not abort, continue

5$:
	; process was aborted, so check time and print out a message

	$CANTIM_S REQIDT = #ABRT_TIM_ID		; cancel the current timer

	; now, see if we are to reset the timer

	BBS	#TCNTRL$V_PROC_NUKED,-		; if $DELPRC has been used
		@P_TERM_FLG(AP),-		;  to nuke the processes, then
		20$				;  don't reset the timer

	TSTL	@P_PROCESS_RUN(AP)		; are we at 0 running processes?
	BNEQ	10$				; no, so reset the timer

	BICL2	#TCNTRL$M_PROC_NUKED,-		; yes, so clear out process
		@P_TERM_FLG(AP)			; nuked flag and
	BRB	20$				; don't reset timer

10$:
	$SETIMR_S DAYTIM = PROC_TERM_DELT,-	; reset timer to insure that at
		  ASTADR = NUKE_PROC_AST,-	; least one process terminates
		  REQIDT = #ABRT_TIM_ID		; in a reasonable time

20$:
	BICL2	#TCNTRL$M_WRT_MSG,@P_TERM_FLG(AP) ; don't print if short report

	PUSHAQ	TCNTRL_ABORT_MSG		; say TSTCNTRL aborted this
	PUSHL	#1
	PUSHL	#TCNTRL$_TEXT!STS$K_WARNING
	INSV	FAC_CODE,#STS$V_FAC_NO,-	; set the facility code of the
		#STS$S_FAC_NO,-			; message to be the defined
		(SP)				; facility code
	PUSHAQ	PRCINFO$Q_TERMTIME(R11)		; time it was aborted
	PUSHAQ	RTN_NAM_DESC(R10)		; name of the process
	PUSHL	#2
	PUSHL	#TCNTRL$_ABENDD!STS$K_WARNING	; give an abort warning
	CALLS	#7,G^LIB$SIGNAL			; write message

	BRW	RETURN_BLK			; and leave

CHCK_ERROR:
	; find out if the process returned successfully or not.  If it did,
	; then look for a log file; if it didn't, report the problem first.

	BICL3	#STS$M_INHIB_MSG,-		; set the status to print
		PRCINFO$L_FINALSTS(R11),R3
	BLBS	R3,CHK_LOG_FIL			; BR if there was no error

	; it did not complete successfully, determine the problem and
	; print it out

	MOVAQ	RTN_NAM_DESC(R10),R2		; get address of process name

	$FAO_S	CTRSTR = BAD_STATUS,-
		OUTLEN = FAO_BUF,-
		OUTBUF = BUFFER_PTR,-
		P1     = R2

	$GETMSG_S MSGID  = R3,-			; get message that goes with
		  MSGLEN = GETMSG_PTR,-		;  this status
		  BUFADR = GETMSG_DESC,-
		  FLAGS  = #15,-
		  OUTADR = MSG_BLOCK
	PUSHAL	GETMSG_PTR			; send descriptor address ...
	PUSHL	#8
	PUSHL	#^X10002			; ... and the error message
	PUSHL	#UETP$_COPY_LOG_LINE-STS$K_SUCCESS+STS$K_WARNING
	INSV	FAC_CODE,#STS$V_FAC_NO,-	; set the facility code of the
		#STS$S_FAC_NO,(SP)		; message to be the defined
	PUSHAL	FAO_BUF
	PUSHL	#1
	PUSHL	#TCNTRL$_TEXT!STS$K_WARNING
	CALLS	#7,G^LIB$SIGNAL

CHK_LOG_FIL:
	; now, check to see if the log file is there.  If it is, then look
	; at the records in it.  If it isn't, then leave.

	$OPEN	FAB = TMP_LOG_FAB,-		; open the temp  log file
		ERR = RMSERR

	CMPL	#RMS$_FNF,R0			; is there a log file
	BNEQ	PROCESS_CMPLT			; yes, so look at it

	BRW 	CLEAN_OUT			; no log file, so leave


PROCESS_CMPLT:
	; the process completed with a log file (may have completed successfully
	; or with error), print out the contents of the logfile

	; connect the data stream to the temporary log file, 
	; and pull records out of it

	$CONNECT RAB = TMP_LOG_RAB,-		; connect stream to temp log
		 ERR = RMSERR			;  file

	; make the termination filename uppercase, so that we can use it as
	;  part of the sentinels.  

	PUSHAQ	TRMNTN_FIL_DESC(R10)
	PUSHAQ	TRMNTN_FIL_DESC(R10)
	CALLS	#2,G^STR$UPCASE			; change filename to upper case

	; make descriptor for the log file records

	MOVAL	LOG_RCRD_STR(R10),-		; put address in the
		<LOG_RCRD_DESC+DSC$A_POINTER>(R10) ; pointer area

	; make descriptor for temporary buffer for log file records

	MOVAL	TEMP_BUFF_STR(R10),-		; put address in the
		<TEMP_BUFF_DESC+DSC$A_POINTER>(R10) ; pointer area

GET_RCRD:
	; now start getting records out of the temporary log file


	; set up TMP_LOG_RAB to put the newly fetched record in the right place

	$RAB_STORE RAB = TMP_LOG_RAB,-		; initialize the temp. log file RAb
		   UBF = LOG_RCRD_STR(R10)	; put the record here
		   
	$GET	RAB = TMP_LOG_RAB,-
		ERR = RMSERR

	CMPL	R0,#RMS$_EOF			; was there an end-of-file?
	BNEQ	10$				; no, so continue
	BRW	TRMNTN_END			; yes, so exit

10$:
	; we have a record, so finish making the descriptor for it and
	;  convert it to uppercase

	MOVZWL 	<TMP_LOG_RAB+RAB$W_RSZ>,-
		LOG_RCRD_DESC(R10)		; put size in descriptor

	PUSHAQ	LOG_RCRD_DESC(R10)
	PUSHAQ	LOG_RCRD_DESC(R10)
	CALLS	#2,G^STR$UPCASE			; change record to upper case

	; look for the beginning sentinel so that we may start copying records

	MOVL	STRT_DESC(AP),R7		; temporarily keep the address of
						; the beginning sentinel
 
	MATCHC	DSC$W_LENGTH(R7),@DSC$A_POINTER(R7),-
		LOG_RCRD_DESC(R10),-
		LOG_RCRD_STR(R10)		; is there a begin sentinel?

	BNEQ	GET_RCRD			; no, so keep looking for one

	; we found the beginning sentinel, now see if the filename is there
	;  (to make sure that this record is indeed a sentinel record and not
	;  simply a data record).

	MOVAQ	TRMNTN_FIL_DESC(R10),R1		; get address of term file
	MATCHC	DSC$W_LENGTH(R1),@DSC$A_POINTER(R1),-
		LOG_RCRD_DESC(R10),-
		LOG_RCRD_STR(R10)		; is filename in same record?
	BNEQ	GET_RCRD			; no, so start over again

COPY_RCRD:
	; we found a begin sentinel, now copy data records to SYS$OUTPUT
	; and perm log file

	$GET	RAB = TMP_LOG_RAB,-		; get next record
		ERR = RMSERR

	CMPL	#RMS$_EOF,R0			; was error end-of-file?
	BNEQ	10$				; no, so continue

	BRW	TRMNTN_END			; EOF, so clean up and leave

10$:
	; we have a record, so finish making the descriptor for it and
	;  convert it to uppercase

	MOVZWL 	<TMP_LOG_RAB+RAB$W_RSZ>,-
		LOG_RCRD_DESC(R10)		; put size in descriptor

	; since this may be a valid data record, we don't want to change
	;  the output version of the record to uppercase.  We will put
	;  the uppercase record in a temporary buffer to check the sentinel,
	;  and output the original record.

	MOVL	LOG_RCRD_DESC(R10),-		; put the size of buffer in
		TEMP_BUFF_DESC(R10)		; descriptor for STR$UPCASE

	PUSHAQ	LOG_RCRD_DESC(R10)		; this is the original record
	PUSHAQ	TEMP_BUFF_DESC(R10)		; and this is the temporary one
	CALLS	#2,G^STR$UPCASE			; change record to upper case


	; now see if we are at the end by looking for and ending sentinel

	MOVL	STP_DESC(AP),R7			; temporarly hold address of the
						;  ending sentinel

	MATCHC	DSC$W_LENGTH(R7),@DSC$A_POINTER(R7),-
		TEMP_BUFF_DESC(R10),-
		TEMP_BUFF_STR(R10)		; is there an ending sentinel?

	BNEQ	20$				; no, so copy this record

	; there was an ending sentinel, so check for the filename to insure
	;  that this is a sentinel record

	MOVAL	TRMNTN_FIL_DESC(R10),R1		; get address of term file

	MATCHC	DSC$W_LENGTH(R1),@DSC$A_POINTER(R1),-
		TEMP_BUFF_DESC(R10),-
		TEMP_BUFF_STR(R10)		; is filename in same record?

	BEQL	TRMNTN_END			; yes, so exit


20$:
	; we have a valid data record, so print it to the proper places

	BSBW	INDENT_LOG_RECORD		; indent it from left margin

	; first write it to the console (SYS$OUTPUT)

	PUSHAL	LOG_RCRD_DESC(R10)		; this is the record
	PUSHL	#^X10001
	PUSHL	#TCNTRL$_TEXT!STS$K_SUCCESS
	PUSHL	#3
	MOVL	SP,R0
	$PUTMSG_S MSGVEC = (R0)			; write to SYS$OUTPUT

	; and then write it to the permanent log file

	$RAB_STORE RAB = CNTRL_LOG_RAB,-
	 	   RSZ = LOG_RCRD_DESC(R10),-	; size to be output
		   RBF = LOG_RCRD_STR(R10)	; where located

	$PUT 	RAB = CNTRL_LOG_RAB,-		; write to perm file
		ERR = RMSERR
	
	BRW	COPY_RCRD			; get next record

TRMNTN_END:

	; all through with the temporary log file, so clean up
	
	$CLOSE	FAB = TMP_LOG_FAB,-		; close the temporary log file
		ERR = RMSERR

	; now see if we are to delete the temporary log file

	BBC	#TCNTRL$V_DELETE_TEMP_LOG,-
		@P_TERM_FLG(AP),CLEAN_OUT	; don't delete it, so continue

	; we are to delete it, so do it

	$ERASE	FAB = TMP_LOG_FAB,-		; delete the temp. log file
		ERR = RMSERR

CLEAN_OUT:

	; all done, so print out ending message

	BICL2	#TCNTRL$M_WRT_MSG,@P_TERM_FLG(AP) ; don't write this to the 
						;console if it is short report

	PUSHAL	PRCINFO$Q_TERMTIME(R11)		; addr of time process ended
	PUSHAQ 	RTN_NAM_DESC(R10)		; the process name
	PUSHL 	#2
	PUSHL	#TCNTRL$_ENDEDD!STS$K_INFO
	CALLS	#4,G^LIB$SIGNAL

RETURN_BLK:

	; now, put the used entry on the available list

	INSQHI	(R11),@P_AVL_LST_HEAD(AP)	; put entry at front of avail list

	; if abort is set, don't touch the case
	
	BBS	#TCNTRL$V_ABORT,@P_TERM_FLG(AP),-
		END_PROCESS_TERM_SBRTN ; don't touch case

	; now, see if there is a process ready to get started.  If there
	;  is, then set the proper flag to get it going.

	BBC	#TCNTRL$V_PROC_PEND,@P_TERM_FLG(AP),- ; no processes are pending, 
		END_PROCESS_TERM_SBRTN		;  so leave

	BISL2	#CASE$M_FILE,@P_CNTRL_CASE(AP)	; try and start pending process
	BICL2	#TCNTRL$M_PROC_PEND,@P_TERM_FLG(AP) ; and clear pending flag

END_PROCESS_TERM_SBRTN:
	
	MOVL	#SS$_NORMAL,R0			; return success

	RET

;
; Massage a record from the log file of a process we've created so that the
; record is uniformly indented from the left margin, even if it contains
; embedded carriage returns, line feeds and tabs.
;
INDENT_LOG_RECORD:
	MOVL	LOG_RCRD_DESC+4(R10),R1	; R1 and R0 are a string desc...
	MOVZWL	LOG_RCRD_DESC(R10),R0	; ...for the remainder of the record
	MOVW	R0,-(SP)		; Counts chars as indentation is done
	BRB	30$			; BR inside loop - indent string's start
10$:
	LOCC	#CR,R0,(R1)		; Is there a <RET> in rest of string?
	BEQL	40$			; Exit loop if not - no more indent
	DECL	R0			; Found one. LOCC has us pointing at it
	INCL	R1			; Point past the <RET>
	CMPB	#LF,(R1)		; Is there a <LINEFEED>?
	BNEQ	20$			; BR if we need not skip <LINEFEED>
	DECL	R0			; Must pass over <LINEFEED>...
	INCL	R1			; ...since they're new line to printers
20$:
	CMPB	#9,(R1)			; Is there a tab at start of line?
	BNEQ	30$			; BR if not - we can start indenting
	DECL	R0			; Must pass over the tab
	INCL	R1			; More of passing over the tab
	BRB	20$			; Inner loop to find multiple tabs
30$:
	TSTL	R0			; If we're at the end of the string...
	BEQL	40$			; ...we can exit the outer loop
	PUSHR	#^M<R0,R1>		; Save desc to rest of string
	MOVC3	R0,(R1),NBR_HDR_BLNKS(R1) ; Indent the rest of the string
	MOVC5	#0,#0,#^A/ /,-		; Fill indented spaces with blanks
		#NBR_HDR_BLNKS,@4(SP)
	POPR	#^M<R0,R1>		; Restore desc to rest of string
	ADDL2	#NBR_HDR_BLNKS,R1	; Point beyond the spaces just inserted
	ADDW2	#NBR_HDR_BLNKS,(SP)	; Count total length incl. indentation
	BRB	10$			; Loop to see if we need indent again
40$:
	MOVW	(SP)+,LOG_RCRD_DESC(R10) ; Set new record size
	RSB				; Return with finished record

	.SBTTL	End-of-file Subroutine

	; define offsets for parameters

	E_CNTRL_CASE = 4
	EOF_FLG      = 8
	DAT_FIL_RAB  = 12

;++
; FUNCTIONAL DESCRIPTION:
;
;	This subroutine is called whenever an end-of-file is reached in the
;	TSTCNTRL data file.  It determines whether or not to rewind the data
;	file and continue processing, or to clean up and exit.
;
; CALLING SEQUENCE:
;
;	This is called when CASE$V_EOF is set by the GET_PARSE_SBRTN.
;		PUSHAL	DATA_FILE_RAB
;		PUSHAL	FLAGS
;		PUSHAL	CONTROL_CASE
;		CALLS	#3,EOF_SBRTN
;
; INPUT PARAMETERS:
;
;	E_CNTRL_CASE(AP) - address of a longword holding the CONTROL_CASE flags.
;	EOF_FLG(AP) - address of a longword holding the TSTCNTRL flags.
;	DAT_FIL_RAB(AP) - address of the start of the RAB of the data file.
;
; IMPLICIT INPUTS:
;
;	None.
;
; OUTPUT PARAMETERS:
;
;	None.
;
; IMPLICIT OUTPUTS:
;
;	The flags CASE$V_EOF, TCNTRL$V_REWOUND, CASE$V_PARSE, and
;	TCNTRL$V_EXIT may be altered.
;
; COMPLETION CODES:
;
;	SS$_NORMAL
;
; SIDE EFFECTS:
;
;	May rewind the data file.
;--

EOF_SBRTN:
	.WORD ^M<R2,R3>

	; turn off EOF flag so we don't come back here

	BICL2	#CASE$M_EOF,@E_CNTRL_CASE(AP)	; clear EOF flag

	; get the address of the RAB

	MOVL	DAT_FIL_RAB(AP),R3		; get RAB address

	; see if data file is coming from a terminal
	; first find the FAB

	MOVL	RAB$L_FAB(R3),R2		; get FAB address

	; now, if data file is a terminal, then don't wrap, and time to exit

	BBS	#DEV$V_TRM,FAB$L_DEV(R2),10$	; terminal, so exit

	; see if we are to rewind the data file by using the following expression
	;   if TCNTRL$V_ABLE_TO_WRAP ^ TCNTRL$V_STRT_MORE ^ TCNTRL$V_FRST_FILE_REACHED
	;     then rewind data file.

	BBC	#TCNTRL$V_ABLE_TO_WRAP,@EOF_FLG(AP),10$  ; is wrap on?
	BBC	#TCNTRL$V_STRT_MORE,@EOF_FLG(AP),10$ ; yes it is, is start more on?
	BBC	#TCNTRL$V_FRST_FILE_REACHED,@EOF_FLG(AP),10$ ; yes, have we started
						;  at least one process?

	; all the conditions are true, so rewind the data file

	$REWIND  RAB = R3,-			; rewind the data file
		 ERR = RMSERR

	BISL2	#TCNTRL$M_REWOUND,@EOF_FLG(AP)	; and set flag saying we rewound

	BRB	END_EOF_SBRTN			; and leave

10$:
	; we are not to rewind the data file, so therefore it must be 
	; time to leave.

	BISL2	#TCNTRL$M_EXIT,@EOF_FLG(AP)	; time to exit now
	BICL2	#CASE$M_PARSE,@E_CNTRL_CASE(AP) ; don't do anymore parsing

END_EOF_SBRTN:

	MOVL	#SS$_NORMAL,R0			; success return

	RET


	.SBTTL	Filename found Subroutine

	; define offsets for parameters

	F_CNTRL_CASE = 4
	FIL_FLG      = 8
	F_PARSE_FLGS = 12
	F_PROC_RUN   = 16
	ACT_PROC_LIM = 20	

;++
; FUNCTIONAL DESCRIPTION:
;
;	This subroutine is called when a data record with a valid filename
;	is fetched.  It determines whether or not the process can be created
;	at this time or if we must wait for some currently running processes to
;	end before we can create a new one.
;
; CALLING SEQUENCE:
;
;	This is called when TCNTRL$V_FILE is set by the GET_PARSE_SBRTN.
;		PUSHAL	ACTIVE_PROC_LIMIT
;		PUSHAL	PROCESS_RUNNING
;		PUSHAL	PARSE_FLAGS
;		PUSHAL	FLAGS
;		PUSHAL	CONTROL_CASE
;		CALLS	#5,FILE_SBRTN
;
; INPUT PARAMETERS:
;
;	F_CNTRL_CASE(AP) - address of a longword holding the CONTROL_CASE flags.
;	FIL_FLG(AP) - address of a longword holding the TSTCNTRL flags.
;	F_PARSE_FLGS(AP) - address of a longword holding the PARSE_FLAGS.
;	F_PROC_RUN(AP) - address of a longword holding a count of the number
;		of processes currently running.
;	ACT_PROC_LIM(AP) - address of a longword holding a value of the number
;		of processes allowed to be active at the same time.
;
; IMPLICIT INPUTS:
;
;	None.
;
; OUTPUT PARAMETERS:
;
;	None.
;
; IMPLICIT OUTPUTS:
;
;	The flags TCNTRL$V_FILE, TCNTRL$V_PARSE, TCNTRL$V_CREATE_PROC,
;	and TCNTRL$V_PROC_PEND may be altered.
;
; COMPLETION CODES:
;
;	SS$_NORMAL
;
; SIDE EFFECTS:
;
;	None.
;--

FILE_SBRTN:
	.WORD ^M<>

	; turn off file flag and parse flag so that we don't go there when
	; through here.

	BICL2	#CASE$M_FILE,@F_CNTRL_CASE(AP)	; clear FILE flag
	BICL2	#CASE$M_PARSE,@F_CNTRL_CASE(AP)	; clear GET_PARSE flag

	; now, see if this file is to be run by itself and if the number of 
	;  current processes is zero

	BBC 	#PARSE$V_PROC_RUNS_OTHERS,-	; if can't run with others 
		@F_PARSE_FLGS(AP),-		; then process must be started 
		SEQUENTIAL_PROC			; by itself

	BRB	CONCURRENT_PROC			; process can run with others

SEQUENTIAL_PROC:
	; this process does run alone, now see if the number of running 
	; processes is zero

	BICL2	#TCNTRL$M_ABLE_TO_WRAP,-	; process runs sequentially,
		@FIL_FLG(AP)			; cannot wrap

	CMPL	#0,@F_PROC_RUN(AP)		; are any processes running?
	BEQL	10$				; yes, so don't start this one yet

	; other proceses are currently running, so make this one pending to 
	; be run

	BISL2	#TCNTRL$M_PROC_PEND,@FIL_FLG(AP) ; set process pending
	BRW	END_FILE_SBRTN			; and leave

10$:
	; no processes are running, so we can start this one up

	BISL2	#CASE$M_CREATE_PROC,@F_CNTRL_CASE(AP)  ; signal to start this process
	BRW	END_FILE_SBRTN			; and do it


CONCURRENT_PROC:
	; we couldn't start this process yet because it wasn't running
	; by itself.
	; since this process can run with others, see if the number
	; of currently running processes is less than the maximum number
	; of processes which are allowed to run together.

	; is the number of processes running less than the maximum?

	CMPL	@F_PROC_RUN(AP),@ACT_PROC_LIM(AP) ; see if we can start this one
	BGEQ	30$				; we can't so make it pending

	; we can start this process so signal that

	BISL2	#CASE$M_CREATE_PROC,@F_CNTRL_CASE(AP)  ; we can start this one
	BRB	END_FILE_SBRTN			; so do it

30$:
	; we cannot start this process yet, so make it pending

	BISL2	#TCNTRL$M_PROC_PEND,@FIL_FLG(AP) ; pending process

END_FILE_SBRTN:

	MOVL	#SS$_NORMAL,R0			; success return

	RET

	.SBTTL  Create Process Subroutine

	; define offsets for parameters

	TOT_PROC_RUN  = 4
	C_PROC_RUN    = 8
	CRT_PRC_FLG   = 12
	C_CNTRL_CASE  = 16
	CRT_PRC_CASE  = 20
	AVL_LST_HEAD  = 24
	CURR_LST_HEAD = 28
	C_TOT_PRC_LIM = 32
	C_PARSE_FLGS  = 36
	
;++
; FUNCTIONAL DESCRIPTION:
;
;	This subroutine is called when a process is ready to be created;
;	ie., after the filespec has been parsed out completely and after
;	the number of active processes is at a proper value.  The routine
;	GET_PARSE will parse out the filename and will also determine what
;	type of file it is to be started (it communicates this by setting
;	a flag in CREATE_PROC_CASE).
;	This routine will then perform all the actions required to start this
;	process and handle any problems caused by the process not activating.
;
; CALLING SEQUENCE:
;
;	This routine is called when CASE$V_CREATE_PROC is set by FILE_SBRTN
;		PUSHAL	PARSE_FLAGS
;		PUSHAL	TOTAL_PROC_LIMIT
;		PUSHAQ	CURRENT_LIST_HEAD
;		PUSHAQ	AVAIL_LIST_HEAD
;		PUSHAL	CREATE_PROC_CASE
;		PUSHAL	CONTROL_CASE
;		PUSHAL	FLAGS
;		PUSHAL	PROCESS_RUNNING
;		PUSHAL	TOTAL_PROC_RUN
;		CALLS	#9,CREATE_PROC_SBRTN
;	
; INPUT PARAMETERS:
;
;	TOT_PROC_RUN(AP) - address of the cumulative number of total processes 
;		run this session
;	C_PROC_RUN(AP) - address of the number of processes currently running
;	CRT_PRC_FLG(AP) - address of the TSTCNTRL flags
;	C_CNTRL_CASE(AP) - address of the CONTROL_CASE longword
;	CRT_PRC_CASE(AP) - address of the CREATE_PROC_CASE longword (initialized
;		by GET_PARSE_SBRTN)
;	AVL_LST_HEAD(AP) - quadword header of the list of available slots
;	CURR_LST_HEAD(AP) - quadword header of the list of processes which are
;		currently active
;	C_TOT_PRC_LIM(AP) - address of the number of allowed detached processes.
;	C_PARSE_FLGS(AP) - address of the flags resulting from the parse routine
;
; IMPLICIT INPUTS:
;
;	The parsed file specification is implicit input to this routine.
;	This is made by GET_PARSE_SBRTN	 and is a contiguous string with
;	descriptors for the various pieces of the specification.  Therefore,
;	the following descriptors are implicit inputs (again, note that these
;	get set by GET_PARSE_SBRTN):
;
;		FILE_SPEC_DESC - descriptor for the entire file specification
;		NODE_DESC      - descriptor for the node on which the file resides
;		DEVICE_DESC    - descriptor for the device designation 
;		DIRECTORY_DESC - descriptor for the directory of the file
;		FILENAME_DESC  - descriptor of the actual filename
;		TYPE_DESC      - descriptor of the extension of the file
;		VERSION_DESC   - descriptor of the files version number
;		PARAM_DESC     - descriptor of the parameters associated with the
;				 file (if there are any)
;		COMMENT_DESC   - descriptor of the comment field from the data
;				 file (if any)
;
;	Other information as needed in order to start detached process.
;		UIC_CODE - to be UIC of the detached process
;		MBX_UNIT - the mailbox unit number for the termination mailbox
;
;
; OUTPUT PARAMETERS:
;
;	None
;	
; IMPLICIT OUTPUTS:
;
;	Implicit outputs include filling in the values of the $CREPRC input
;	list. The values which are the same for all processes created are
;	the following:
;		PIDADR - points to where the PID of the created process is
;			to be placed
;		OUTPUT - points to what SYS$OUTPUT is (the temporary log file)
;		ERROR  - points to what SYS$ERROR is (the temporary log file)
;		PRCNAM - points to what the process name is
;		UIC    - points to what the UIC is to be
;		MBXUNT - points to the mailbox unit number of the termination 
;			mailbox
;
; COMPLETION CODES:
;	
;	SS$_NORMAL
;
; SIDE EFFECTS:
;
;	May create a detached process.
;--

CREATE_PROC_SBRTN:
	.WORD ^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>


	; set the control flags so that we don't come back here, and that
	; we go to the parse routine

	BICL2	#CASE$M_CREATE_PROC,@C_CNTRL_CASE(AP)  ; don't come back
	BISL2	#CASE$M_PARSE,@C_CNTRL_CASE(AP)	; but do parse instead

	BISL2	#TCNTRL$M_FRST_FILE_REACHED,-	; we've started at least one
		@CRT_PRC_FLG(AP)		; process

	; if we have a null file, don't do anything. go right to case.

	BBC	#CRTPRC$V_NULL,@CRT_PRC_CASE(AP),10$ ; if real file, continue
	BRW	CASE_FILE_TYPE			; if null, then case

10$:
	; now initialize the stack area for local storage

	SUBL2	#CREATE_PROC_LENGTH,SP		; allocate space for local storage

	MOVC5	#0,#0,#0,#CREATE_PROC_LENGTH,(SP)  ; clear out local storage
	MOVL	SP,R11				; keep pointer to local storage


	; now initialize the descriptors in the local area

	; first, the descriptor for the process name

	MOVAL	TEMP_PNAM_STR(R11),-
		<TEMP_PNAM_DESC+DSC$A_POINTER>(R11)  ; process name descriptor

	; then the descriptor for log file of the process

	MOVAL	TEMP_LOG_STR(R11),-
		<TEMP_LOG_DESC+DSC$A_POINTER>(R11)  ; log file name

	; now, make the process name

	PUSHAQ	FILENAME_DESC			; the test filename
	PUSHL	TOT_PROC_RUN(AP)		; the ID number
	PUSHAQ	TEMP_PNAM_DESC(R11)		; the process name
	CALLS	#3,MAKE_PROC_NAM		; now, make the process name

	; make the temporary log file name

	PUSHAQ	FILENAME_DESC			; the test filename
	PUSHL	TOT_PROC_RUN(AP)		; the ID number
	PUSHAQ	LOG_EXT_DESC			; the temp log file extension
	PUSHAQ	TEMP_LOG_DESC(R11)		; the temp. log file
	CALLS	#4,MAKE_TMP_LOG_NAM		; and make the log file name

20$:
	; get a slot off of the available list

	REMQHI	@AVL_LST_HEAD(AP),R10		; address of free slot

	BVC	30$				; we got the slot, now fill it in

	; the available queue is empty, allocate and initialize more slots and
	; try again

	; first allocate more space

	PUSHAQ	STRCT_TOP_BOT(R11)		; top & bottom of new structure
	PUSHL	#PRCINFO$S_PRC_INFO		; byte count of the slot size
	PUSHL	#NUMB_OF_SLOTS			; number of slots we want
	CALLS	#3,EXPND_REGION			; get more space

	; now initialize the space we've just acquired

	PUSHAQ	@AVL_LST_HEAD(AP)		; the available list pointer
	PUSHL	STRCT_TOP_BOT(R11)		; top of new structure
	PUSHL	#PRCINFO$S_PRC_INFO		; byte count of the slot size
	PUSHL	#NUMB_OF_SLOTS			; number of slots we want
	CALLS	#4,INIT_STRUCT			; init the structure

	BRB	20$				; now try and get a slot again

30$:
	; now fill the new slot with as much info as possible

	; first fill in the parsed file information.  Move the entire filespec
	;  to the new slot

	MOVC3	<FILE_SPEC_DESC+DSC$W_LENGTH>,-	; source length
		@<FILE_SPEC_DESC+DSC$A_POINTER>,-  ; source address
		PRCINFO$T_FILE_SPEC(R10)	; put it in the new slot

	; now fill in the sizes and the pointers of the parsed filespec

	MOVAL	PRCINFO$T_FILE_SPEC(R10),R5	; get the address of the start
						;  of the file spec

	; first the overall filespec

	MOVW	<FILE_SPEC_DESC+DSC$W_LENGTH>,-	; move the length to the 
		PRCINFO$W_FILESPEC_SIZ(R10)	;  new slot

	; next do the node name

	MOVW	<NODE_DESC+DSC$W_LENGTH>,-	; move the length to the
		PRCINFO$W_NODE_SIZ(R10)		;  place for the node size

	MOVL	R5,PRCINFO$A_NODE(R10)		; and put it in the slot

	MOVZWL	PRCINFO$W_NODE_SIZ(R10),R4	; clear upper word of length

	ADDL2	R4,R5				; adjust the address to be 
						; the device

	; then the device

	MOVW	<DEVICE_DESC+DSC$W_LENGTH>,-	; move the length to the
		PRCINFO$W_DEVICE_SIZ(R10)	;  place for the device size

	MOVL	R5,PRCINFO$A_DEVICE(R10)	;  and put it in the slot

	MOVZWL	PRCINFO$W_DEVICE_SIZ(R10),R4	; clear upper word of length

	ADDL2	R4,R5				; adjust the address to be
						; the directory

	; then the directory

	MOVW	<DIRECTORY_DESC+DSC$W_LENGTH>,-	; move the length to the
		PRCINFO$W_DIR_SIZ(R10)		;  place for directory size

	MOVL	R5,PRCINFO$A_DEVICE(R10)	; and put it in the slot

	MOVZWL	PRCINFO$W_DIR_SIZ(R10),R4	; clear upper word of length

	ADDL2	R4,R5				; adjust the address to be the
						; filename

	; then the filename

	MOVW	<FILENAME_DESC+DSC$W_LENGTH>,-	; move the length to the
		PRCINFO$W_FILNAM_SIZ(R10)	;  place for the filename size

	MOVL	R5,PRCINFO$A_FILNAM(R10)	; and put it in the slot

	MOVZWL	PRCINFO$W_FILNAM_SIZ(R10),R4	; clear upper word of length

	ADDL2	R4,R5				; adjust the address to be the 
						; file extension

	; then the file extension

	MOVW	<TYPE_DESC+DSC$W_LENGTH>,-	; move the length to the
		PRCINFO$W_EXTENSION_SIZ(R10)	;  place for the extension size

	MOVL	R5,PRCINFO$A_EXTENSION(R10)	; and put it in the slot

	MOVZWL	PRCINFO$W_EXTENSION_SIZ(R10),R4	; clear upper word of length

	ADDL2	R4,R5				; adjust the address to be the 
						; version number

	; and finally the version number

	MOVW	<VERSION_DESC+DSC$W_LENGTH>,-	; move the length to the
		PRCINFO$W_VERSION_SIZ(R10)	;  place for the version size

	MOVL	R5,PRCINFO$A_VERSION(R10)	; and put it in the slot

	; now, put the ID number in the process info slot

	MOVW	@TOT_PROC_RUN(AP),PRCINFO$W_ID_NUMB(R10)  ; put the ID number in slot


	; make sure all the flags are cleared

	CLRL	PRCINFO$L_FLAGS(R10)		; clear the flags

	; before creating a process, delete any left-over log files

	$FAB_STORE  FAB = TMP_LOG_FAB,-		; put in the name of current log file
		    FNA = TEMP_LOG_STR(R11),-
		    FNS = TEMP_LOG_DESC(R11)
	$ERASE	    FAB = TMP_LOG_FAB,-		; erase the log file
		    ERR = RMSERR

	; set up generic parameter list for $CREPRC

	MOVAL	PRCINFO$L_PID(R10),PIDADR	; get the PID
	MOVAQ	TEMP_LOG_DESC(R11),OUTPUT	; and what SYS$OUTPUT is
	MOVAQ	TEMP_PNAM_DESC(R11),PRCNAM	; and the process name
	MOVL	UIC_CODE,UIC			; and the UIC
	MOVZWL	MBX_UNIT,MBXUNT			; don't forget the mailbox

	; now assume that the process will be created successfully and
	; put the slot on the current_running list.

	INSQTI	(R10),@CURR_LST_HEAD(AP)	; put slot on curr. run. list

CASE_FILE_TYPE:
	; now, we will start up the process.  The GET_PARSE routine has
	; determined what type of process we are trying to start up, so
	; we will case on the results of that.

	FFS	#0,-				; case off of flag, start at zero
		#<CRTPRC$S_CRT_PROC_CASE*8>,-	; go this many bits
		@CRT_PRC_CASE(AP),-		; this holds the flags
		R9				; and put the results here

	CASEB	R9,#0,#<CRTPRC$K_CREAT_CASE_SIZE-1>  ; perform case
10$:	.WORD	EXE_FILE  - 10$
	.WORD	EXE_PARM  - 10$
	.WORD	COM_FILE  - 10$
	.WORD 	COM_PARM  - 10$
	.WORD	NULL_FILE - 10$


NULL_FILE:
	; can come here either by the proper bit being set, or by falling
	; through the case.  If we fall through the case (an error in the 
	; the filespec) handle it as if a null file.  With a null file,
	; don't do any processing, just exit.  This is used mainly to
	; to run down currently running processes (done by running a null
	; file sequentially).

	BRW	END_CREATE_PROC


EXE_FILE:
	; reached by the filespec being an executable image, and by having
	; no parameters.

	CALLS	#0,CRT_EXE_PRC			; create the process

	BRW	CHCK_STATUS			; see if finished without error

EXE_PARM:
	; reached by the filespec being an executable image, and by having
	; parameters

	; first make a unique logical name to be associated with the physical
	; name of the mailbox

	MOVAL	MBX_LOGNAM_STR(R11),-		; initialize the descriptor
		<MBX_LOGNAM_DESC+DSC$A_POINTER>(R11)

	; and make a unique name (which is the same as the temp log file 
	; name expect is doesn't have an extension).

	PUSHAQ	FILENAME_DESC			; use the name of the file
	PUSHL	TOT_PROC_RUN(AP)		; along with the ID number
	PUSHAQ	NIL_EXT_DESC			; and no extension
	PUSHAQ	MBX_LOGNAM_DESC(R11)		; and put results here
	CALLS	#4,MAKE_TMP_LOG_NAM		; make the logical name

	PUSHL	R10				; process info slot
	PUSHAQ	MBX_LOGNAM_DESC(R11)		; the logical name
	CALLS	#2,CRT_EXE_PARM			; create the process

	BRW	CHCK_STATUS			; see if finished without error

COM_FILE:
	; reached by the filespec being a command procedure, having no
	; parameters

	CALLS	#0,CRT_COM_PRC			; create the process

	BRW	CHCK_STATUS			; see if finished without error

COM_PARM:
	; reached by the filespec being a command procedure with parameters

	PUSHL	TOT_PROC_RUN(AP)		; total processes run thus far
	CALLS	#1,CRT_COM_PARM			; create the process

CHCK_STATUS:
	; we've attempted to create the detached processes, if for some reason
	; we did not succeed, then print out a warning message saying why.

	BLBS	R0,INC_COUNT			; Go increment count if no err

	; there was an error, so print it
	; make the output message

	MOVL	R0,R5				; save the error status

	; since the process did not get started, remove the slot from the 
	; current running list . . .

	REMQTI	@CURR_LST_HEAD(AP),R10		; remove from current running list

	; . . . and then return the slot to the available list

	INSQHI	(R10),@AVL_LST_HEAD(AP)		; put at head of available list

	$FAO_S	CTRSTR = NO_CRT_PRC,-		; make a string with this message
		OUTLEN = FAO_BUF,-		; get size of buffer
		OUTBUF = BUFFER_PTR,-		; put output here
		P1     = @TEMP_PNAM_DESC(R11)	; this is the process name 

	$GETMSG_S MSGID  = R5,-			; get the message that goes with
		  MSGLEN = GETMSG_PTR,-		;  this message
		  BUFADR = GETMSG_DESC,-
		  FLAGS  = #15,-
		  OUTADR = MSG_BLOCK
	PUSHAL	GETMSG_PTR			; Push the desc address
	PUSHL	#8
	PUSHL	#^X10002
	PUSHL	#UETP$_COPY_LOG_LINE-STS$K_SUCCESS+STS$K_WARNING
	PUSHAL	FAO_BUF				; send the error message
	PUSHL	#1
	PUSHL	#TCNTRL$_TEXT!STS$K_WARNING
	CALLS	#7,G^LIB$SIGNAL
	BRB	INC_TOTAL_RUN			; increment total number run

INC_COUNT:
	; now, increment the counters that we keep.  Increment both the
	; count of active processes, and the count of total processes run

	INCL	@C_PROC_RUN(AP)			; one more process running

	; print the begin time stamp for detached process

	BICL2	#TCNTRL$M_WRT_MSG,@CRT_PRC_FLG(AP) ; write only if long
	CLRL	-(SP)				; set up for begin time stamp
	PUSHAL	TEMP_PNAM_DESC(R11)
	PUSHL	#2
	PUSHL	#TCNTRL$_BEGIND!STS$K_INFO
	CALLS	#4,G^LIB$SIGNAL

	;print out the comments?

	BBC	#TCNTRL$V_PRNT_COMMENTS,@CRT_PRC_FLG(AP),-
		INC_TOTAL_RUN			; no comments wanted
	BICL2	#TCNTRL$M_WRT_MSG,@CRT_PRC_FLG(AP) ; write only if long
	PUSHAL	COMMENT_DESC
	PUSHL	#1
	PUSHL  	#TCNTRL$_TEXT!STS$K_INFO
	CALLS	#3,G^LIB$SIGNAL			; print comment

INC_TOTAL_RUN:
	; this is the number of total processes run.  If there was an error
	; while trying to start up the detached process, we will only increment
	; this value.  This is so that the TSTCNTRL will stop in some finite
	; amount of time, even though no processes can be started.

	INCL	@TOT_PROC_RUN(AP)		; and one more to the total

	; if the process we just started was to be run alone, then don't
	; parse anything until it stops

	BBS	#PARSE$V_PROC_RUNS_OTHERS,@C_PARSE_FLGS(AP),- ; if runs with 
		10$				; others, then continue
	BICL2	#CASE$M_PARSE,@C_CNTRL_CASE(AP)	; otherwise, don't parse until done

10$:
	; now see if we should start up more processes, or if the one just
	; started was our last one.

	CMPL	@TOT_PROC_RUN(AP),@C_TOT_PRC_LIM(AP) ; have we reached our limit?
	BLSS	END_CREATE_PROC			; no, start more up

	; we have started the requested number of processes, so don't start
	; any more

	BICL2	#TCNTRL$M_STRT_MORE,@CRT_PRC_FLG(AP) ; don't start any more

	; now see if it is time to exit (check ~STRT_MORE ^ ABLE_TO_WRAP ^
	; REWOUND)

	BBC	#TCNTRL$V_ABLE_TO_WRAP,@CRT_PRC_FLG(AP),- ; have we been able
		END_CREATE_PROC			; to wrap around?

	BBC	#TCNTRL$V_REWOUND,@CRT_PRC_FLG(AP),- ; has the data file 
		END_CREATE_PROC			; been rewound?

	; if the above expression is true, then we are to exit now!

	BISL2	#TCNTRL$M_EXIT,@CRT_PRC_FLG(AP)	; exit the TSTCNTRL	
	BICL2	#CASE$M_PARSE,@C_CNTRL_CASE(AP)	; don't parse any more

END_CREATE_PROC:

	MOVL	#SS$_NORMAL,R0			; return completion code

	RET

	.SBTTL	Create image procedure
;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called when a executable image is to be run as a 
;	detached process.  The routine is started by running the image as
;	a detached process.
;
; CALLING SEQUENCE:
;
;	CALLS	#0,CRT_EXE_PRC
;
; INPUT PARAMETERS:
;
;	None
;
; IMPLICIT INPUTS:
;
;	File specification information from GET_PARSE:
;	FILE_SPEC_DESC - descriptor of the entire file specification
;
; OUTPUT PARAMETERS:
;
;	None.
;
; IMPLICIT OUTPUTS:
;
;	None
;
; COMPLETION CODES:
;
;	SS$_NORMAL
;	Any completion code which may be produced by $CREPRC
;
; SIDE EFFECTS:
;
;	A detached process may be created
;--

CRT_EXE_PRC:
	.WORD ^M<>

	; set up generic parameters for executable images

	MOVL	#0,INPUT			; there is no input for an image
	MOVL	#0,STSFLG			; clear the status flag

	; put the name of the image in the parameter list

	MOVAQ	FILE_SPEC_DESC,IMAGE		; run the actual image

	; and create the process

	$CREPRC_G  CREPRC_LIS			; create the process

	RET					; return with status in R0

	.SBTTL	Create image procedure with parameters

	; define offsets for parameters

	LNAM_DESC = 4
	SLOT_TOP  = 8
;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called when a executable image is to be run as a 
;	detached process.  The parameters are passed by creating a mailbox
;	with the same name as the process name (thereby making the name unique)
;	and defining SYS$INPUT of the new image to be that mailbox.
;	a detached process.
;
; CALLING SEQUENCE:
;
;	PUSHAL	PROC_INFO_SLOT
;	PUSHAQ	MBX_LOGNAM_DESC
;	CALLS	#2,CRT_EXE_PARM
;
; INPUT PARAMETERS:
;
;	LNAM_DESC(AP) - the address of the logical name to be associated with
;			the mailbox holding the parameters
;	SLOT_TOP(AP)  - the address of the process info slot being used for
;			this process
;
; IMPLICIT INPUTS:
;
;	File specification information from GET_PARSE:
;	FILE_SPEC_DESC - descriptor of the entire file specification
;	PARM_DESC     - descriptor of the parameters to be passed to the image.
;
; OUTPUT PARAMETERS:
;
;	None.
;
; IMPLICIT OUTPUTS:
;
;	None
;
; COMPLETION CODES:
;
;	SS$_NORMAL
;	Any completion code which may be produced by $CREPRC
;
; SIDE EFFECTS:
;
;	A temporary mailbox will be created
;	A detached process may be created
;--

CRT_EXE_PARM:
	.WORD ^M<R2>

	; get the process info slot address

	MOVL	SLOT_TOP(AP),R2

	; set up generic parameters for executable images

	MOVL	#0,STSFLG			; clear the status flag

	; create the mailbox for the parameters

	$CREMBX_S  CHAN   = PRCINFO$W_MBX_CHAN(R2),-  ; put the channel number
						- ; in the process info slot
		   BUFQUO = <PARAM_DESC+DSC$W_LENGTH>,- ; large as param list
		   LOGNAM = @LNAM_DESC(AP)	; name is the logical name

	; say that we are holding a channel number

	BISL2	#PRCINFO$M_MBX_CHAN,PRCINFO$L_FLAGS(R2) ; we're holding a mailbox chan

	; now, write the parameter list to the mailbox

	$QIOW_S	CHAN = PRCINFO$W_MBX_CHAN(R2),-	; write to mailbox we just made
		FUNC = #IO$_WRITEVBLK!IO$M_NOW,- ; do the write now
		P1   = @<PARAM_DESC+DSC$A_POINTER>,-  ; the parameter string
		P2   = <PARAM_DESC+DSC$W_LENGTH>  ; size of parameter list

	; put the mailbox name as SYS$INPUT of the new image

	MOVL	LNAM_DESC(AP),INPUT		; input is the mailbox

	; now give the image we want to run

	MOVAQ	FILE_SPEC_DESC,IMAGE		; run the actual image

	; and create the process

	$CREPRC_G  CREPRC_LIS			; create the process

	RET					; return with status in R0

	.SBTTL	Create command procedure

	; define offsets for parameters

;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called when a command procedure is to be run as a 
;	detached process.  The routine is started by VMS's LOGINOUT with
;	the filespec as the input file.
;
; CALLING SEQUENCE:
;
;	CALLS	#0,CRT_COM_PRC
;
; INPUT PARAMETERS:
;
;	None
;
; IMPLICIT INPUTS:
;
;	File specification information from GET_PARSE:
;	FILE_SPEC_DESC - descriptor of the entire file specification
;
; OUTPUT PARAMETERS:
;
;	None.
;
; IMPLICIT OUTPUTS:
;
;	None
;
; COMPLETION CODES:
;
;	SS$_NORMAL
;	Any completion code which may be produced by $CREPRC
;
; SIDE EFFECTS:
;
;	A detached process may be created
;--

CRT_COM_PRC:
	.WORD ^M<>

	; set up generic parameters for command file

	MOVAQ	COM_IMAGE,IMAGE			; run under LOGINOUT

	CLRL	STSFLG				; re-init status flag
	BISL2	#PRC$M_LOGIN,STSFLG		; bypass the UAF

	; put the name of the procedure in the parameter list

	MOVAQ	FILE_SPEC_DESC,INPUT		; the procedure is the input

	; and create the process

	$CREPRC_G  CREPRC_LIS			; create the process

	RET					; return with status in R0

	.SBTTL	Create command procedure with parameters

	; define offsets for parameters

	TOT_PROC = 4
;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called when a command procedure is to be run as a 
;	detached process, and that procedure has parameters with it.  The
;	routine passes the parameters by creating a one line command
;	procedure (which has a unique one filename) which simply starts up
;	the original command procedure along with the parameters.
;
; CALLING SEQUENCE:
;
;	PUSHAL	TOT_PROC_RUN
;	CALLS	#1,CRT_COM_PARM
;
; INPUT PARAMETERS:
;
;	TOT_PROC(AP) - address of the cumulative number of total processes
;		run this session.
;
; IMPLICIT INPUTS:
;
;	File specification information from GET_PARSE.  Including --
;		FILE_SPEC_DESC - descriptor of the entire file specification
;		FILENAME_DESC - descriptor of the actual filename
;		PARAM_DESC    - descriptor of the parameter string
;
; OUTPUT PARAMETERS:
;
;	None.
;
; IMPLICIT OUTPUTS:
;
;	None.
;
; COMPLETION CODES:
;
;	SS$_NORMAL
;	any completion which may be produced by $CREPRC
;
; SIDE EFFECTS:
;
;	Makes a temporary command file (which is to be deleted by PROC_TERM).
;	May create a detached process.
;--
CRT_COM_PARM:
	.WORD ^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>

	; create a detached process for command file with parameters

	; initialize the stack area for local storage

	SUBL2	#COM_PARM_LENGTH,SP		; allocate space for local storage

	MOVC5	#0,#0,#0,#COM_PARM_LENGTH,(SP)	; clear out local storage
	MOVL	SP,R11				; keep pointer to local storage

	; first set up generic parameters for command file

	MOVAQ	COM_IMAGE,IMAGE			; run under LOGINOUT

	CLRL	STSFLG				; re-init status flag
	BISL2	#PRC$M_LOGIN,STSFLG		; bypass the UAF

	; since we must pass parameters, we will make a command file which
	; calls the command file we want to start and passes the parameters
	; along to it.  It will also capture the exit status of the command
	; file we want to start and will pass that status back to the TSTCNTRL.
	; The file that we make will look like:
	;	$@filespec -
	;	$parameter_list
	;	$ status = $status
	;	$ exit status

	; initialize descriptor for the temporary command filename

	MOVAL	TEMP_COM_STR(R11),-		; put the address in the
		<TEMP_COM_DESC+DSC$A_POINTER>(R11)  ; pointer area

	; make the filename for the temporary command file

	PUSHAQ	FILENAME_DESC			; the test filename
	PUSHL	TOT_PROC(AP)			; the ID number
	PUSHAQ	TMP_COM_EXT_DESC		; the file extension
	PUSHAQ 	TEMP_COM_DESC(R11)		; where the new filename goes
	CALLS	#4,MAKE_TMP_LOG_NAM		; and make the name

	; set up the record to handle .COM files with parameters by using
	;  COMMENT_DESC, by putting a $@ at the beginning of the filespec
	;  and concatenating a hyphen and a blank to the end of file spec 

	; set up an index to use to point to various pieces in the new record

	CLRL	R7				; index into new record

	; then initialize the desciptor for the indirect file spec

	MOVAL	COM_LINE_STR(R11),-		; put the address in the
		<COM_LINE_DESC+DSC$A_POINTER>(R11)  ; pointer area

	; now, move "$@" into the string

	MOVB	#^A/$/,COM_LINE_STR(R11)[R7]	; put $ in front 
	INCW	R7				; update the index

	MOVB	#^A/@/,COM_LINE_STR(R11)[R7]	; put @ in front of spec
	INCW	R7				; update the index

	; now, put the complete filespec in

	MOVC3	<FILE_SPEC_DESC+DSC$W_LENGTH>,-	; the size of the filespec
		@<FILE_SPEC_DESC+DSC$A_POINTER>,-  ; take it from here
		COM_LINE_STR(R11)[R7]		; and put it here

	ADDW2	<FILE_SPEC_DESC+DSC$W_LENGTH>,R7 ; update the index

	; and finally put the " -" on the end

	MOVB	#^A/ /,COM_LINE_STR(R11)[R7]	; add blank to the end
	INCW	R7				; update the index

	MOVB	#^A/-/,COM_LINE_STR(R11)[R7]	; add continuation character
	INCW	R7				; update the index (and the size)

	MOVZWL	R7,<COM_LINE_DESC+DSC$W_LENGTH>(R11)  ; put the size in the desc

	; now create the temporary command file, and write the proper
	; records into it.

	$FAB_STORE FAB = COM_FAB,-		; point to temporary command file
		   FNA = TEMP_COM_STR(R11),-	; the filename
		   FNS = TEMP_COM_DESC(R11)	; the size

	$CREATE    FAB = COM_FAB,-		; now make the file
		   ERR = RMSERR

	$CONNECT   RAB = COM_RAB,-		; connect the stream
		   ERR = RMSERR

	$RAB_STORE RAB = COM_RAB,-		; point to the filespec which we
		   RSZ = COM_LINE_DESC(R11),-	;  really want to use
		   RBF = COM_LINE_STR(R11)

	$PUT	   RAB = COM_RAB,-		; write that record
	  	   ERR = RMSERR

	$RAB_STORE RAB = COM_RAB,-		; point to the parameter list 
		   RSZ = PARAM_DESC,-		; associated with the above 
		   RBF = @<PARAM_DESC+DSC$A_POINTER>  ; command procedure

	$PUT	   RAB = COM_RAB,-		; write that record
	 	   ERR = RMSERR

	$RAB_STORE RAB = COM_RAB,-		; point to the record holding
		   RSZ = COM_STAT_DESC,-	; DCL to save the final status of
		   RBF = @<COM_STAT_DESC+DSC$A_POINTER> ; the command procedure

	$PUT	   RAB = COM_RAB,-		; put that record
		   ERR = RMSERR

	$RAB_STORE RAB = COM_RAB,-		; point to the record holding
		   RSZ = COM_EXIT_DESC,-	; the exit from the command 
		   RBF = @<COM_EXIT_DESC+DSC$A_POINTER>  ; procedure

	$PUT	   RAB = COM_RAB,-		; put that record
		   ERR = RMSERR

	$CLOSE	   FAB = COM_FAB,-		; close the file
		   ERR = RMSERR

	; we now have our indirect procedure to start up the want command
	; procedure and pass parameters to it

	; now let the input of LOGINOUT be the file we just made

	MOVAQ	TEMP_COM_DESC(R11),INPUT	; input is temp command file

	; and finally start up the procedure

	$CREPRC_G  CREPRC_LIS			; . . . and create the process

	MOVL	R0,R5				; save the completion status

	; see if create process worked.  If it didn't, then delete the 
	; temporary command procedure; otherwise, the process termination
	; routine will delete it.

	CMPL	#SS$_NORMAL,R5			; did the process get created
	BEQL	END_CRT_COM_PARM		; yes, so leave

	$ERASE	FAB = COM_FAB,-			; no, so delete the temporary
		ERR = RMSERR			; command procedure

END_CRT_COM_PARM:
	
	MOVL	R5,R0				; replace the status code

	RET					; return with status in R0


	.SBTTL Create Process-name

	; define offsets for parameters

	CP_PROCESS_NAME  = 4
	CP_ID_NUMBER     = 8
	CP_TEST_FILENAME = 12

;++
; FUNCTIONAL DESCRIPTION:
;
;	This subroutine is called to create the unique process name before the
;	creation of a detached process.  It does this by taking the filename
;	and concatenating an ID number which is generated by the TSTCNTRL.
;	Though the filenames may be repeated, the ID number is unique.
;
; CALLING SEQUENCE:
;
;	This routine is called by CREAT_PROC via: 
;		PUSHAL TEST_FILENAME
;		PUSHAL ID_NUMBER
;		PUSHAL PROCESS_NAME
;		CALLS  #3,MAKE_PROC_NAM
;
; INPUT PARAMETERS:
;
;	CP_PROCESS_NAME(AP)  - address of descriptor to hold process name
;	CP_ID_NUMBER(AP)  - address of longword holding ID number
;	CP_TEST_FILENAME(AP) - address of descriptor holding filename (without extension)
;
; IMPLICIT INPUTS:
;
;	None.
;
; OUTPUT PARAMETERS:
;
;	The process name (@CP_PROCESS_NAME(AP)).
;	Completion code in R0.
;
; IMPLICIT OUTPUTS:
;
;	None.
;
; COMPLETION CODES:
;
;	SS$_NORMAL, OTS$_OUTCONERR
;
; SIDE EFFECTS:
;
;	 None.
;--

MAKE_PROC_NAM:
	.WORD ^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>

	; first pad with leading blanks (if needed)
	
	MOVL	CP_TEST_FILENAME(AP),R10	; get addr of desc. for filename
	MOVZBL	(R10),R8			; get size of filnam (clear desc type)
	CMPL 	R8,#PNAME_FILNAM_SIZ		; is the size of filnam to large?
	BLEQ	10$				; no, so continue
	MOVL	#PNAME_FILNAM_SIZ,R8		; yes, so make filnam max allowed

10$:	MOVL	CP_PROCESS_NAME(AP),R11		; get addr of desc for procname
	
	CLRL	R6				; this is our counter and index
	SUBL3	R8,#PNAME_FILNAM_SIZ,R4		; number of blanks needed
	BEQL	30$				; no blanks are needed

20$:	MOVB	#^A/ /,@DSC$A_POINTER(R11)[R6]	; put blanks in
	AOBLSS	R4,R6,20$			; are all of them in?

	; now move the filename in, truncate it if too large.
	
30$:	MOVC3	R8,@DSC$A_POINTER(R10),-
		 @DSC$A_POINTER(R11)[R6]	; move the filename in
	ADDL2	R8,R6				; move index to end of string

	; add the underscore

	MOVB	#^A/_/,@DSC$A_POINTER(R11)[R6]	; put underscore in
	INCL	R6				; point to next character

	; now put the ID number in

	SUBL2	#ID_DESC_LENGTH,SP		; allocate space for local storage
	MOVC5	#0,#0,#0,#ID_DESC_LENGTH,(SP)	; clear out local storage
	MOVL	SP,R7				; keep the pointer to this area
	MOVAL	ID_STR(R7),ID_ADDR(R7)		; initialize the addr of desc.
	MOVL	#ID_STR_SIZ,ID_DESC(R7)		; initialize size of desc.

	MOVZWL	@CP_ID_NUMBER(AP),ID_NUMB(R7)	; clear upper word of ID number

	PUSHL	#ID_STR_SIZ			; this number of ascii digits
	PUSHAL	ID_DESC(R7)			; where the converted string goes
	PUSHAL	ID_NUMB(R7)			; the number to convert
	CALLS 	#3,G^OTS$CVT_L_TI		; convert the number to text

	; now move ID into process name

	MOVC3	#ID_STR_SIZ,ID_STR(R7),-
		 @DSC$A_POINTER(R11)[R6] 	; move ID in

	MOVL	#<PROCESS_NAME_SIZ-1>,-
		 DSC$W_LENGTH(R11)		; put size of process name in
						;  subtract one so a blank looks
						;  like it is there.

	MOVL	#SS$_NORMAL,R0			; signify success

	RET

	.SBTTL  Make temporary file name
	; define offsets for parameters

	MF_TEMP_FILE     = 4
	MF_TEMP_EXT      = 8
	MF_ID_NUMBER     = 12
	MF_TEST_FILENAME = 16

;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called to make the filespec for the temporary
;	files produced by the TSTCNTRL.  It makes each filespec 
;	unique by appending the sequence number to the spec.
;
; CALLING SEQUENCE:
;
;	This routine is called by CREAT_PROC via: 
;		PUSHAQ TEST_FILENAME
;		PUSHAL ID_NUMBER
;		PUSHAQ TEMP_EXT
;		PUSHAQ TEMP_FILE
;		CALLS  #4,MAKE_TMP_LOG_NAM
;
; INPUT PARAMETERS:
;
;	MF_TEMP_FILE(AP)  - address of descriptor to hold temporary log filename
;	MF_TEMP_EXT(AP)   - address of descriptor holding the temp file extension
;	MF_ID_NUMBER(AP)  - address of longword holding ID number
;	MF_TEST_FILENAME(AP) - address of descriptor holding filename (without extension)
;
; IMPLICIT INPUTS:
;
;	None.
;
; OUTPUT PARAMETERS:
;
;	The temporary filename (@MF_TEMP_FILE(AP)).
;	Completion code in R0.
;
; IMPLICIT OUTPUTS:
;
;	None.
;
; COMPLETION CODES:
;
;	SS$_NORMAL, OTS$_OUTCONERR
;
; SIDE EFFECTS:
;
;	 None.
;--

MAKE_TMP_LOG_NAM:
	.WORD ^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>

	; get input information

	MOVL	MF_TEMP_EXT(AP),R9		; get addr of desc of extension
	MOVL	MF_TEST_FILENAME(AP),R10	; get addr of desc. for filename
	MOVZBL	DSC$W_LENGTH(R10),R8		; get size of filnam (clear desc type)
	MOVL	MF_TEMP_FILE(AP),R11		; get addr of desc for log filnam

	; move up to MAX_TMP_LOG_NAM characters into file spec

	CMPL	R8,#MAX_TMP_LOG_NAM		; is size of filename more than
						;  we can handle?
	BLEQ	10$				; no, so don't truncate
	MOVL	#MAX_TMP_LOG_NAM,R8		; truncate it down to acceptable size
	
10$:
	MOVL	R8,DSC$W_LENGTH(R11)		; keep size of growing filespec
	CLRL	R6				; this is our index and pointer
	MOVC3	R8,@DSC$A_POINTER(R10),-
		 @DSC$A_POINTER(R11)[R6]	; move filename in
	ADDL2	R8,R6				; adjust pointer

	; now get the ID number

	SUBL2	#ID_DESC_LENGTH,SP		; allocate space for local storage
	MOVC5	#0,#0,#0,#ID_DESC_LENGTH,(SP)	; clear out local storage
	MOVL	SP,R7				; keep the pointer to this area
	MOVAL	ID_STR(R7),ID_ADDR(R7)		; initialize the addr of desc.
	MOVL	#ID_STR_SIZ,ID_DESC(R7)		; initialize size of desc.

	MOVZWL	@MF_ID_NUMBER(AP),ID_NUMB(R7)	; clear out upper word of ID

	PUSHL	#ID_STR_SIZ			; this number of ascii digits
	PUSHAL	ID_DESC(R7)			; where the converted string goes
	PUSHAL	ID_NUMB(R7)			; the number to convert
	CALLS 	#3,G^OTS$CVT_L_TI		; convert the number to text

	; now move ID into process name

	MOVC3	#ID_STR_SIZ,ID_STR(R7),-
		 @DSC$A_POINTER(R11)[R6] 	; move ID in
	ADDL2	#ID_STR_SIZ,R6			; adjust pointer
	ADDL2	#ID_STR_SIZ,DSC$W_LENGTH(R11)	; adjust size

	; now put file extension on

	MOVC3	DSC$W_LENGTH(R9),@DSC$A_POINTER(R9),-
		 @DSC$A_POINTER(R11)[R6] 	; put extension on
	ADDW2	DSC$W_LENGTH(R9),DSC$W_LENGTH(R11)  ; adjust size

	MOVL	#SS$_NORMAL,R0			; return success

	RET


	.SBTTL Assignment Expression Subroutine

	; define offsets for parameters

	ASG_CNT_CAS = 4
;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine is reached when the CASE$V_ASSIGN bit is set.  It
;	takes the results of the parse routine (which has already determined
;	the keyword and if it valid or not) and calls the proper assignment
;	routine for that particular keyword.
;
; CALLING SEQUENCE:
;
;	PUSHAL	CONTROL_CASE
;	CALLS	#1,ASSIGN_SBRTN
;
; INPUT PARAMETERS:
;
;	ASG_CNT_CAS(AP) - address of the longword holding the CONTROL_CASE
;
; IMPLICIT INPUTS:
;
;	The results of the parse routine are implicit inputs, namely
;		KEYWRD_EQ_VAL - a word which holds a numerical value equivalent
;		to each keyword.  These values are defined in the GET_PARSE
;		routine.
;		KEYVALUE_DESC - a descriptor which points to the value of the
;		assignment statement
;
; OUTPUT PARAMETERS:
;
;	None
;
; IMPLICIT OUTPUTS:
;	
;	This routine itself has no outputs; however, the routines which this
;	one calls may modify global variables.  These modifications are 
;	described in the subroutines.
;
; COMPLETION CODES:
;	
;	SS$_NORMAL
;
; SIDE EFFECTS:
;	
;	None
;--

ASSIGN_SBRTN:
	.WORD ^M<R2>

	; turn off assignment flag and turn on parse flag

	BICL2	#CASE$M_ASSIGN,@ASG_CNT_CAS(AP)  ; don't come back to assign
	BISL2	#CASE$M_PARSE,@ASG_CNT_CAS(AP)	; but go to parse 

	; now by using the results of the parse routine
	; case to proper assignment

	FFS	#0,-				; start looking at position 0
		#<ASSIGN$S_ASGN_CASE*8>,-	; this is how many bits
		ASSIGN_CASE,-			; this is the base
		R2				; put results here

	CASEB	R2,#0,#<ASSIGN$K_ASGN_CASE_SIZ - 1>  ; goto proper routine
10$:
	.WORD	LOG_ASG    - 10$
	.WORD	PNAME_ASG  - 10$
	.WORD	START_ASG  - 10$
	.WORD	STOP_ASG   - 10$
	.WORD	COM_ASG    - 10$
	.WORD	TIM_ASG    - 10$
	.WORD	PAR_ASG    - 10$

	BRW 	END_ASSIGN_SBRTN		; if no match, just exit

LOG_ASG:
	; do assignment to change name of the permanent log file

	PUSHAQ	FILE_SPEC_DESC			; location of new filename
	CALLS	#1,LOG_ASG_RTN			; do the assignment

	BRW	END_ASSIGN_SBRTN		; and leave

PNAME_ASG:
	; do assignment for the process name

	PUSHAQ	ASSIGN_VALUE_DESC		; the location of the new name
	CALLS	#1,PNAME_ASG_RTN		; do the assignment

	BRW	END_ASSIGN_SBRTN		; and leave

START_ASG:
	; do assignment to change the starting sentinel

	PUSHAQ	ASSIGN_VALUE_DESC		; the location of the new sentinel
	CALLS	#1,START_ASG_RTN		; do the assignment

	BRW	END_ASSIGN_SBRTN		; and leave

STOP_ASG:
	; do assignment to change the ending sentinel

	PUSHAQ	ASSIGN_VALUE_DESC		; the location of the new sentinel
	CALLS	#1,STOP_ASG_RTN			; do the assignment

	BRW	END_ASSIGN_SBRTN		; and leave

COM_ASG:
	; do assignment to determine if we turn on or off the comment flag

	PUSHAQ	ASSIGN_VALUE_DESC		; the location of the flag
	CALLS	#1,COM_ASG_RTN			; do the assignment

	BRW	END_ASSIGN_SBRTN		; and leave

TIM_ASG:
	; do assignment to set the watchdog timer

	PUSHAQ	TIME_VALUE			; location of the time
	CALLS	#1,TIM_ASG_RTN			; do the assignment

	BRW	END_ASSIGN_SBRTN		; and leave

PAR_ASG:
	; do assignment to change the parallel count

	PUSHAQ	ASSIGN_VALUE_DESC		; the new count
	CALLS	#1,PAR_ASG_RTN			; do the assignment

	BRW	END_ASSIGN_SBRTN		; and leave

END_ASSIGN_SBRTN:
	; all done with assignment, so leave

	MOVL	#SS$_NORMAL,R0			; leave with success

	RET					; exit

	.SBTTL	Assignment Routine for Process Name

	; define offsets for parameters

	PNAM_ASG_DSC = 4

;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called to change the current process name of the
;	TSTCNTRL.
;
; CALLING SEQUENCE:
;
;	PUSHAQ	ASSIGN_VALUE_DESC		; the new process name
;	CALLS	#1,PNAME_ASG_RTN
;
; INPUT PARAMETERS:
;
;	PNAM_ASG_DSC(AP) - address of a descriptor of the assignment value 
;			   (the process name)
;
; IMPLICIT INPUTS:
;
;	None.
;
; OUTPUT PARAMETERS:
;
;	None.
;
; IMPLICIT OUTPUTS:
;
;	None.
;
; COMPLETION CODES:
;
;	SS$_NORMAL
;
; SIDE EFFECTS:
;
;	The process name will be changed.
;--

PNAME_ASG_RTN:
	.WORD	^M<R2,R3,R4,R5,R6>

	; put the new process name in the descriptor

	MOVL	PNAM_ASG_DSC(AP),R2		; get the address of new name

	MOVW	DSC$W_LENGTH(R2),PRC_NAM_DESC	; get the new size

	MOVC3	DSC$W_LENGTH(R2),-		; and copy the new name in
		@DSC$A_POINTER(R2),PRC_NAM_STR	; the descriptor

	; call the system service to set the process name

	$SETPRN_S  PRCNAM = PRC_NAM_DESC	; set the process name

	MOVL	#SS$_NORMAL,R0			; return success

	RET					; exit

	.SBTTL	Assignment Routine for Starting Sentinel

	; define offsets for parameters

	STRT_ASG_DSC = 4

;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called to change the starting sentinel keyword used
;	when looking through the temporary log file.
;
; CALLING SEQUENCE:
;
;	PUSHAQ	ASSIGN_VALUE_DESC		; the new sentinel
;	CALLS	#1,PNAME_ASG_RTN
;
; INPUT PARAMETERS:
;
;	STRT_ASG_DSC(AP) - address of a descriptor of the assignment value 
;			   (the process name)
;
; IMPLICIT INPUTS:
;
;	None.
;
; OUTPUT PARAMETERS:
;
;	None.
;
; IMPLICIT OUTPUTS:
;
;	The value of START_DESC will be changed.
;
; COMPLETION CODES:
;
;	SS$_NORMAL
;
; SIDE EFFECTS:
;
;	None
;--

START_ASG_RTN:
	.WORD	^M<R2,R3,R4,R5,R6>

	; to make things simple, put the address of the descriptor in a regr.

	MOVL	STRT_ASG_DSC(AP),R2		; get the address of the desc.

	; now, move the assignment value into the actual sentinel descriptor

	MOVW	DSC$W_LENGTH(R2),START_DESC	; put size in descriptor
	MOVC3	DSC$W_LENGTH(R2),-		; put in the new sentinel
		@DSC$A_POINTER(R2),START_STR

	MOVL	#SS$_NORMAL,R0			; return success

	RET					; exit

	.SBTTL	Assignment Routine for Ending Sentinel

	; define offsets for parameters

	STP_ASG_DSC = 4

;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called to change the stopping sentinel keyword used
;	when looking through the temporary log file.
;
; CALLING SEQUENCE:
;
;	PUSHAQ	ASSIGN_VALUE_DESC		; the new sentinel
;	CALLS	#1,PNAME_ASG_RTN
;
; INPUT PARAMETERS:
;
;	STP_ASG_DSC(AP) - address of a descriptor of the assignment value 
;
; IMPLICIT INPUTS:
;
;	None.
;
; OUTPUT PARAMETERS:
;
;	None.
;
; IMPLICIT OUTPUTS:
;
;	The value of STOP_DESC will be changed.
;
; COMPLETION CODES:
;
;	SS$_NORMAL
;
; SIDE EFFECTS:
;
;	None
;--

STOP_ASG_RTN:
	.WORD	^M<R2,R3,R4,R5,R6>

	; to make things simple, put the address of the descriptor in a regr.

	MOVL	STP_ASG_DSC(AP),R2		; get the address of the desc.

	; now, move the assignment value into the actual sentinel descriptor

	MOVW	DSC$W_LENGTH(R2),STOP_DESC	; put size in descriptor
	MOVC3	DSC$W_LENGTH(R2),-		; put in the new sentinel
		@DSC$A_POINTER(R2),STOP_STR

	MOVL	#SS$_NORMAL,R0			; return success

	RET					; exit

	.SBTTL	Assignment Routine Changing Comment Flag

	; define offsets for parameters

	COM_ASG_DSC = 4

;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called to change the current value of the flag which
;	signals the TSTCNTRL to either print out comments or not.
;
; CALLING SEQUENCE:
;
;	PUSHAQ	ASSIGN_VALUE_DESC		; the comment string
;	CALLS	#1,COM_ASG_RTN
;
; INPUT PARAMETERS:
;
;	COM_ASG_DSC(AP) - address of a descriptor of the the comment value
;			  (either YES or NO)
;
; IMPLICIT INPUTS:
;
;	None.
;
; OUTPUT PARAMETERS:
;
;	None.
;
; IMPLICIT OUTPUTS:
;
;	May change the value of TCNTRL$V_PRNT_COMMENTS in FLAG
;
; COMPLETION CODES:
;
;	SS$_NORMAL
;
; SIDE EFFECTS:
;
;	Comments may or may not be printed out.
;--

COM_ASG_RTN:
	.WORD	^M<R2,R3>

	; put the address of the descriptor in a register to make things easy

	MOVL	COM_ASG_DSC(AP),R3
	; the keyword value is only allowed to be YES or NO
	; move the address of the string into a register so that we may
	; look at the first character easily

	MOVAL	@DSC$A_POINTER(R3),R2		; get the address of the string

	; look at first character for a Y or N

	CMPB	(R2),#^A/Y/			; is it yes?
	BNEQ 	10$				; no, try again

	; comments are to be printed, so turn flag on

	BISL2	#TCNTRL$M_PRNT_COMMENTS,FLAGS	; yes, turn it on
	BRW	END_COM_ASG_RTN			; all done

10$:
	; comments are not to be printed, so turn flag off

	BICL2	#TCNTRL$M_PRNT_COMMENTS,FLAGS	; turn comments off

END_COM_ASG_RTN:

	MOVL	#SS$_NORMAL,R0			; return success

	RET

	.SBTTL	Assignment Routine for Log File Name

	; define offsets for parameters

	LGN_ASG_DSC = 4

;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called to change the current name of the permanent
;	log file.  The name can only be changed BEFORE the file gets created.
;	There is a flag (TCNTRL$V_SET_LOGNAM) which gets set when the file
;	is created.
;
; CALLING SEQUENCE:
;
;	PUSHAQ	FILE_SPEC_DESC			; the new logfile name
;	CALLS	#1,LOG_ASG_RTN
;
; INPUT PARAMETERS:
;
;	LOG_ASG_DSC(AP) - address of a descriptor of the assignment value 
;			   (the new log filename)
;
; IMPLICIT INPUTS:
;
;	FLAGS - used to check if the name has already been set, and to
;		check to see if a error message is to be printed if it has.
;
; OUTPUT PARAMETERS:
;
;	None.
;
; IMPLICIT OUTPUTS:
;
;	None.
;
; COMPLETION CODES:
;
;	SS$_NORMAL
;
; SIDE EFFECTS:
;
;	The name of the log file may be changed.
;--

LOG_ASG_RTN:
	.WORD	^M<R2>

	; first check to see if the SET_LOGNAM flag has been set

	BBC	#TCNTRL$V_SET_LOGNAM,FLAGS,20$	; has not been set, so do assign
	BBS	#TCNTRL$V_REWOUND,FLAGS,10$	; skip message if wrapping

	; it has been set, so print a warning saying that it can't be changed

	PUSHAL	NO_SET_LOG			; say we can't change log name
	PUSHL	#1
	PUSHL	#TCNTRL$_TEXT!STS$K_WARNING
	CALLS	#3,G^LIB$SIGNAL

10$:
	; since it is too late to change the filename, just leave

	BRW	END_LOG_ASG_RTN			; if set, then skip it!

20$:
	; we can change the filename, so put the new one in the filename buffer

	; put the address of the filename descriptor in a register to make it easy

	MOVL	LGN_ASG_DSC(AP),R2		; address of descriptor

	; now, update the old log filename descriptor

	MOVW	DSC$W_LENGTH(R2),LOG_FIL_DESC	; put size in old descriptor
	MOVC3	DSC$W_LENGTH(R2),-		; put in new filename
		@DSC$A_POINTER(R2),LOG_FIL_STR

	$FAB_STORE  FAB = CNTRL_LOG_FAB,-	; change the FAB
		    FNS = LOG_FIL_DESC

END_LOG_ASG_RTN:

	MOVL	#SS$_NORMAL,R0			; return success

	RET					; and leave

	.SBTTL	Assignment Routine for Setting Watchdog Timer

	; define offsets for parameters

	TIM_VAL = 4

;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called to set the watchdog timer which is used to
;	prevent a process (or a group of processes) from hanging a number of
;	TSTCNTRL tests to be run.
;
; CALLING SEQUENCE:
;
;	PUSHAQ	TIME_VALUE			; the complete system time
;	CALLS	#1,TIM_ASG_RTN
;
; INPUT PARAMETERS:
;
;	TIM_VAL(AP) - address of the complete time in system format. The time
;			has already been parsed out and converted from ascii
;			to system.
;
; IMPLICIT INPUTS:
;
;	FLAGS - FLAGS is checked to see if we should set the timer and to see
;		see if would should an error message out.
;
; OUTPUT PARAMETERS:
;
;	None.
;
; IMPLICIT OUTPUTS:
;
;	FLAGS - If we set a timer the TCNTRL$V_TIMER_SET flag is set to 
;		indicated this.
;
; COMPLETION CODES:
;
;	SS$_NORMAL
;
; SIDE EFFECTS:
;
;	It will cause a timer to be set and active.  This timer may cause
;	the entire TSTCNTRL to abort if expired.
;--

TIM_ASG_RTN:
	.WORD	^M<R2,R3>

	; if timer is currently set, then print a warning, otherwise
	;   just do assignment

	BBC	#TCNTRL$V_TIMER_SET,FLAGS,20$	; not set, do assignment
	BBS	#TCNTRL$V_REWOUND,FLAGS,10$	; skip message if wrapping

	PUSHAQ	NO_SET_TIM			; say that we can't set it
	PUSHL	#1
	PUSHL	#TCNTRL$_TEXT!STS$K_WARNING
	CALLS	#3,G^LIB$SIGNAL

10$:
	; we can't  set the timer while one is active, so leave

	BRW	END_TIM_ASG_RTN

20$:
	; a timer is not currently running, so we are able to start one.

	BISL2	#TCNTRL$M_TIMER_SET,FLAGS	; say that a timer is active

	$SETIMR_S  DAYTIM = @TIM_VAL(AP),-	; start the timer
		   ASTADR = TIME_EXP_AST,-	; if expire, go here
		   REQIDT = #MAXTIME_ID		; timer id is 1


END_TIM_ASG_RTN:

	MOVL	#SS$_NORMAL,R0			; return success

	RET

	.SBTTL	Assignment Routine for Changing the Parallel Count

	; define offsets for parameters

	PAR_ASG_DSC = 4

;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called to change the value of the parallel count
;	(that is, the number of processes allowed to execute in parallel).
;	It will make sure that no processes are currently executing, and,
;	if this is true, will change the count for the next set.
;
; CALLING SEQUENCE:
;
;	PUSHAQ	ASSIGN_VALUE_DESC		; the new count
;	CALLS	#1,PAR_ASG_RTN
;
; INPUT PARAMETERS:
;
;	PAR_ASG_DSC(AP) - address of a descriptor of the assignment value 
;			   (the new count in ASCII)
;
; IMPLICIT INPUTS:
;
;	None.
;
; OUTPUT PARAMETERS:
;
;	None.
;
; IMPLICIT OUTPUTS:
;
;	The value of TOTAL_PROC_LIMIT and ACTIVE_PROC_LIMIT will be changed.
;
; COMPLETION CODES:
;
;	SS$_NORMAL
;
; SIDE EFFECTS:
;
;	None
;--

PAR_ASG_RTN:
	.WORD ^M<>

;
; First check to see if any processes are currently running. If some are,
; then print out a warning and ignore the assignment.
;

	TSTL	PROCESS_RUNNING			; are any processes running
	BEQL	10$				; no, then OK to do assignment

;
; Processes are still running, so unable to perform assignment,
; print out a warning.
;

	BBC	#TCNTRL$V_REWOUND,FLAGS,5$	; if not wrapping, then write msg
	BRW	30$				; if wrapping, just ignore asg

5$:
	PUSHAQ	PROC_ACT			; yes, print warning . . .
	PUSHL	#1
	PUSHL	#TCNTRL$_TEXT!STS$K_WARNING
	CALLS	#3,G^LIB$SIGNAL

	BRW	30$

10$:

;
; Everything is OK, so perform the assignment.
;

;
; Convert assignment value into a number
;

	PUSHAL	TOTAL_PROC_LIMIT		; place for converted number
	PUSHAQ	@PAR_ASG_DSC(AP)		; string to be converted
	CALLS 	#2,G^OTS$CVT_TI_L		; convert text to longword

;
; See if valid PARCNT
;

	CMPL	TOTAL_PROC_LIMIT,#0		; is PARCNT <= 0?
	BGTR	20$				; no, continue
	PUSHAL	ZERO_PARCNT			; yes, print warning . . .
	PUSHL	#1
	PUSHL	#TCNTRL$_TEXT!STS$K_WARNING
	CALLS	#3,G^LIB$SIGNAL
	
	MOVL	#1,TOTAL_PROC_LIMIT		; . . . and use PARCNT = 1

20$:
	MOVL	TOTAL_PROC_LIMIT,-		; set maximum number of 
		ACTIVE_PROC_LIMIT		; active processes

30$:
	MOVL	#SS$_NORMAL,R0			; return success
	RET


	.SBTTL Get and Parse Record
;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called whenever a new input record is required.  It
;	will perform a GET to fetch the record and will then parse the record
;	out into its various components setting parse flags to signal the type
;	of record which was just fetched.
;
; CALLING SEQUENCE:
;
;	CALLS 	#0,GET_PARSE_SBRTN
;
; INPUT PARAMETERS:
;
;	None.
;
; IMPLICIT INPUTS:
;
;	FLAGS -- the TSTCNTRL flags
;	CONTROL_CASE 
;	PARSE_FLAGS
;	The data file RMS structures are used to fetch the next data record.
;
; OUTPUT PARAMETERS:
;
;	None.
;
; IMPLICIT OUTPUTS:
;
;	All of the parse fields may be changed.  (See the parse read/write area
;	which describes all these fields.)
;
; COMPLETION CODES:
;
;	SS$_NORMAL
;
; SIDE EFFECTS:
;
;	May change the values of some the flags.
;--
GET_PARSE_SBRTN:
	.WORD ^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>

	; initialized the stack area for local storage

	SUBL2	#GET_PARSE_LENGTH,SP		; allocate space for local storage
	MOVC5	#0,#0,#0,#GET_PARSE_LENGTH,(SP)	; clear out local storage
	MOVL	SP,R11				; keep pointer to local area

GET_DAT_RCRD:
	; ready to get a record and set it up to be parsed

	; clear out the parse flags since we are working on a new record

	CLRL	PARSE_FLAGS			; reset flags from previous parse
	CLRL	ASSIGN_CASE			; reset assignment case flags
	CLRL	CREATE_PROC_CASE		; reset case for creating proc

	; get the record from the input data file and put it in a buffer from
	; which we can work

	$GET	RAB = DATA_FILE_RAB,-		; use the input file RAB
		ERR = RMSERR

	; see if we got a record or if we are at E-O-F

	CMPL	#RMS$_EOF,R0			; is status end-of-file?
	BNEQ	10$				; no, we have a record, continue

	; we are at end-of-file, so set a flag and skip the parse

	BISL2	#CASE$M_EOF,CONTROL_CASE	; at end-of-file
	BRW	CHK_END_SEG			; check for end-of-segment

10$:
	MOVW	<DATA_FILE_RAB+RAB$W_RSZ>,-	; put the size of the input string
		<DATA_RCRD_DESC+DSC$W_LENGTH>	; in the record descriptor

	; now, upcase the entire string so we don't have to worry about matches

	PUSHAQ	DATA_RCRD_DESC			; change the input string
	PUSHAQ	DATA_RCRD_DESC			;  to become
	CALLS	#2,G^STR$UPCASE			;  all caps

	; Ok, we now have a record in the proper format, so call TPARSE to
	; parse it out into its components

	; initialize the TPARSE parameter block

	MOVL	#TPA$K_COUNT0,-			; put count in the 
		TPA$L_COUNT+DAT_PARSE_BLK(R11)	; TPARSE block

	CLRL	TPA$L_OPTIONS+DAT_PARSE_BLK(R11) ; clear the options field
	BISL2	#TPA$M_ABBREV,-			; allow abbreviations
		TPA$L_OPTIONS+DAT_PARSE_BLK(R11)

PARSE_DAT_RCRD:

	; now copy the descriptor of the data record into the TPARSE block so
	; that it knows what it is looking at.

	MOVL	<DATA_RCRD_DESC+DSC$W_LENGTH>,-	; put the length in the TPARSE
		TPA$L_STRINGCNT+DAT_PARSE_BLK(R11)  ; count field

	MOVL	<DATA_RCRD_DESC+DSC$A_POINTER>,- ; put the address in the TPARSE
		TPA$L_STRINGPTR+DAT_PARSE_BLK(R11)  ; address field

	; finally call TPARSE


	PUSHAL	DAT_FIL_KEY			; use the data file keys
	PUSHAL	DAT_FIL_STATE			; and the data file state table
	PUSHAL	DAT_PARSE_BLK(R11)		; and the data file param. block
	CALLS	#3,G^LIB$TPARSE			; perform the parse
	
	; parse is done, did it succeed without syntax errors?

	BLBC	R0,SYNTAX_ERROR			; there was an error, so report it

CHK_END_SEG:

	; now, see if the watchdog timer expired.  If it did, then continue
	; to get and parse records until the end of a segment is reached. The
	; end of a segment is either an end-of-file, or a process to be run
	; sequentially.

	; first see if the timer expired

	BBC	#TCNTRL$V_TIME_EXP,FLAGS,GET_AGAIN ; did the timer expire?
	
	; maxtime is set, so get ready to get next record and see if at EOF

	BISL2	#PARSE$M_GET_NXT_RCRD,PARSE_FLAGS  ; prepare to get another record

	BBC	#CASE$V_EOF,CONTROL_CASE,10$	; not EOF, keep checking

	; EOF is set, so end-of-segment, stop gets

	BICL2	#PARSE$M_GET_NXT_RCRD,PARSE_FLAGS  ; stop gets
	BICL2	#TCNTRL$M_TIME_EXP,FLAGS	; reset max time flag

	BRB	GET_AGAIN			; continue

10$:
	; are we at a filespec?
	
	BBC	#CASE$V_FILE,CONTROL_CASE,GET_AGAIN ; no filespec, keep trying

	; we have a filespec, is it sequential?

	BBS	#PARSE$V_PROC_RUNS_OTHERS,-	; not sequential, keep trying
		PARSE_FLAGS,GET_AGAIN

	; it is sequential, end-of-segment

	BICL2	#PARSE$M_GET_NXT_RCRD,PARSE_FLAGS ; stop gets
	BICL2	#TCNTRL$M_TIME_EXP,FLAGS	; reset max time flag

GET_AGAIN:

	; the parse succeeded, but we may want to get another record

	BBS	#PARSE$V_GET_NXT_RCRD,PARSE_FLAGS,10$ ; see if we need a record
	BRW	END_GET_PARSE			; we don't so exit

10$:
	; the parse determined that we are to get another record, so start over

	BRW	GET_DAT_RCRD			; get another record

SYNTAX_ERROR:
	
	; there was a syntax error in the record, write out a message saying 
	; what record failed and what caused the error

	MOVL	R0,R5				; save the status


	; make the descriptor of the record in error

	; first initialize the descriptors

	MOVAL	RCRD_ERR_STR(R11),-		; put the address in the
		DSC$A_POINTER+RCRD_ERR_DESC(R11)  ; descriptor

	MOVAL	RCRD_ERR_STR(R11),-		; put the address in the
		DSC$A_POINTER+RCRD_ERR_FAO(R11)	; descriptor
	MOVZWL	#<RCRD_SIZE*2>,-		; put the size in the 
		DSC$W_LENGTH+RCRD_ERR_FAO(R11)	; descriptor

	; then make the error message

	MOVL	DSC$W_LENGTH+DATA_RCRD_DESC,R2	; get size for the FAO
	MOVL	DSC$A_POINTER+DATA_RCRD_DESC,R3  ; get address for the FAO

	$FAO_S	CTRSTR = RCRD_ERR_MSG,-		; the error message
		OUTLEN = DSC$W_LENGTH+RCRD_ERR_DESC(R11),-  ; the output length
		OUTBUF = RCRD_ERR_FAO(R11),-	; the output string
		P1     = R2,-			; length of invalid record
		P2     = R3			; address of invalid record

	; now see if we have a TPARSE error (which implies we are pointing
	; to the invalid token), or some other type of error (we just print
	; out the error message).

	CMPL	R5,#LIB$_SYNTAXERR		; is it a TPARSE syntax error?
	BNEQ	10$				; no, it is another type

	BRW	TPARSE_ERR			; it's a TPARSE error, write
						; the token

10$:
	; the syntax error was not found by TPARSE, so we don't have a token.
	; instead, we will print out the invalid line, and the error message.

	PUSHL	R5				; write the error message
	PUSHAQ	RCRD_ERR_DESC(R11)		; and the invalid record
	PUSHL	#1
	PUSHL	#TCNTRL$_TEXT!STS$K_WARNING
	CALLS	#4,G^LIB$SIGNAL			; output the message

	; since parsed failed, get another record and try again

	; we may have set control bits before the parse failed.  clear out
	; those bits and start again

	BICL2	#CASE$M_FILE,CONTROL_CASE	; clear file bit (may be set)
	BICL2	#CASE$M_ASSIGN,CONTROL_CASE	; clear assign bit (may be set)

	BRW	GET_DAT_RCRD			; get a new record


TPARSE_ERR:
	; the error was found by TPARSE, therefore we have an invalid token.
	; we will write out the invalid string along with the invalid token.


	; initialize the descriptors to do the FAO

	MOVAL	TOKEN_ERR_STR(R11),-		; put the address in the
		DSC$A_POINTER+TOKEN_ERR_DESC(R11)  ; descriptor


	MOVAL	TOKEN_ERR_STR(R11),-		; put the address in the
		DSC$A_POINTER+TOKEN_ERR_FAO(R11)  ; descriptor
	MOVZWL	#<RCRD_SIZE*2>,-		; put the size in the 
		DSC$W_LENGTH+TOKEN_ERR_FAO(R11)	; descriptor

	; make error message of the invalid token

	MOVL	TPA$L_TOKENCNT+DAT_PARSE_BLK(R11),R2  ; get size for the FAO
	MOVL	TPA$L_TOKENPTR+DAT_PARSE_BLK(R11),R3  ; get address for the FAO

	$FAO_S	CTRSTR = TOKEN_ERR_MSG,-	; the error message
		OUTLEN = DSC$W_LENGTH+TOKEN_ERR_DESC(R11),-  ; the output length
		OUTBUF = TOKEN_ERR_FAO(R11),-	; the output string
		P1     = R2,-			; length of invalid token
		P2     = R3			; address of invalid token

	; now write out the error

	PUSHL	R5				; TPARSE's complaint
	PUSHAQ	TOKEN_ERR_DESC(R11)		; the invalid token
	PUSHL	#1
	PUSHL	#TCNTRL$_TEXT!STS$K_INFO

	INSV	FAC_CODE,#STS$V_FAC_NO,-	; set the facility code of the
		#STS$S_FAC_NO,-			; message to be the defined
		(SP)				; facility code

	PUSHAQ	RCRD_ERR_DESC(R11)		; the invalid record
	PUSHL	#1
	PUSHL	#TCNTRL$_TEXT!STS$K_WARNING
	CALLS	#7,G^LIB$SIGNAL			; write the message

	; now, since the parse failed, get another record and try again

	; we may have set control bits before the parse failed.  clear out
	; those bits and start again

	BICL2	#CASE$M_FILE,CONTROL_CASE	; clear file bit (may be set)
	BICL2	#CASE$M_ASSIGN,CONTROL_CASE	; clear assign bit (may be set)

	BRW	GET_DAT_RCRD			; get a new record

END_GET_PARSE:

	; all done parsing, exit with success

	MOVL	#SS$_NORMAL,R0			; successful exit

	RET

	.SBTTL	State Table for Data File

	$INIT_STATE	DAT_FIL_STATE,DAT_FIL_KEY

	; start state. look for a keyword, a comment, or a blank line,
	; anything else is an error, so signal it and get the next line.

	$STATE	START
	 $TRAN	'Y*',RUN_PROC,,CASE$M_FILE,CONTROL_CASE
	 $TRAN	'N*',TPA$_EXIT,,PARSE$M_GET_NXT_RCRD,PARSE_FLAGS
	 $TRAN	'LOG',LOGFIL_ASG,,ASSIGN$M_LOG,ASSIGN_CASE
	 $TRAN	'NAME',GENERIC_ASG,,ASSIGN$M_NAME,ASSIGN_CASE
	 $TRAN	'START',GENERIC_ASG,,ASSIGN$M_START,ASSIGN_CASE
	 $TRAN	'STOP',GENERIC_ASG,,ASSIGN$M_STOP,ASSIGN_CASE
	 $TRAN	'COMMENTS',GENERIC_ASG,,ASSIGN$M_COM,ASSIGN_CASE
	 $TRAN	'MAXTIME',TIME_ASG,,ASSIGN$M_TIME,ASSIGN_CASE
	 $TRAN	'PARALLEL',GENERIC_ASG,,ASSIGN$M_PAR,ASSIGN_CASE
	 $TRAN	'!',TPA$_EXIT,,PARSE$M_GET_NXT_RCRD,PARSE_FLAGS
	 $TRAN	'EXIT',TPA$_EXIT,,CASE$M_EOF,CONTROL_CASE
	 $TRAN	TPA$_EOS,TPA$_EXIT,,PARSE$M_GET_NXT_RCRD,PARSE_FLAGS


	; get ready to parse the filespec, but first see if the process can
	; run with others, or if it must run alone.  PARSE$V_PROC_RUNS_OTHERS
	; is set to be zero (meaning that it doesn't run with others) unless
	; it is changed here.

	$STATE	RUN_PROC
	 $TRAN	'Y*',CHCK_FILESPC,,PARSE$M_PROC_RUNS_OTHERS,PARSE_FLAGS
	 $TRAN	'N*',CHCK_FILESPC

	; see if there is a filespec there before we try and parse one.  Null
	; filespecs are legal syntax, but we flag that it is null.

	$STATE	CHCK_FILESPC
	 $TRAN	'!',TPA$_EXIT,,CRTPRC$M_NULL,CREATE_PROC_CASE
	 $TRAN	TPA$_EOS,TPA$_EXIT,,CRTPRC$M_NULL,CREATE_PROC_CASE
	 $TRAN	TPA$_LAMBDA,,EXPLICIT_BLANKS

	; with blanks on, check for the blank before the filespec

	$STATE
	 $TRAN	TPA$_BLANK,FIND_FILESPEC

	; we are to the point where a filespec better exists or the syntax is
	; wrong.  we have set TPARSE so that it looks at ever blank (which we
	; will use as a delimiter unless it is in a quoted string). we will now
	; take apart what we think is a filespec and send that string to RMS
	; $PARSE to confirm whether or not it is a filespec.

	$STATE	FIND_FILESPEC
	 $TRAN	!FILE_SPEC,,IMPLICIT_BLANKS,,SPEC_DESC

	; we have a string which we think is a filespec, call action routine
	; which uses $PARSE to confirm it.

	$STATE
	 $TRAN	TPA$_LAMBDA,FINISH_LINE,PRS_FILE_SPEC

	; OK, we have a valid filespec, now finish parsing the rest of the line

	$STATE	FINISH_LINE
	 $TRAN	'!',TPA$_EXIT,GET_COMMENT	;  get associated comment
	 $TRAN	TPA$_EOS,TPA$_EXIT
	 $TRAN	TPA$_ANY,GET_PARAM,,,DELIMIT


	; states to parse out the parameter string.  the delimiters may be any
	; character except the exclimation point '!'.  when we get here the
	; first delimiter is in DELIMIT

	$STATE	GET_PARAM
	 $TRAN	TPA$_LAMBDA,,EXPLICIT_BLANKS

	; while accepting blanks, take every character as being valid. the
	; action routine copies the parameter list into a buffer

	$STATE
	 $TRAN	!PARAM_STRING,,COPY_PARAM

	; accept the last character (it is the ending delimiter) and ignore
	; blanks again

	$STATE
	 $TRAN	TPA$_ANY,,IMPLICIT_BLANKS

	; see if we have a comment, else leave

	$STATE
	 $TRAN	'!',TPA$_EXIT,GET_COMMENT
	 $TRAN	TPA$_EOS,TPA$_EXIT
	 $TRAN	TPA$_LAMBDA,TPA$_FAIL

	; this is the subexpression to accept every character which may be in 
	; the parameter string.  it calls an action routine which checks to
	; see if the character is a delimiter or not.

	$STATE	PARAM_STRING
	 $TRAN	TPA$_EOS,TPA$_FAIL
	 $TRAN	TPA$_ANY,PARAM_STRING,TST_DELIM
	 $TRAN	TPA$_LAMBDA,TPA$_EXIT

	; subexpression to get the file spec string.  successful completion
	; of this subexpression does not neccessarly guarantee that the string
	; is indeed a filespec.  this routine pulls out characters that may be
	; a filespec and then sends them to $PARSE to make sure.

	$STATE	FILE_SPEC
	 $TRAN	'"',Q_STRING
	 $TRAN	!NON_DELIMITER
	 $TRAN	TPA$_LAMBDA,TPA$_EXIT

	$STATE
	 $TRAN	TPA$_ANY,FILE_SPEC		; collect all non-delimiters

	; see if we have a valid quoted string

	$STATE	Q_STRING
	 $TRAN	'"',GET_REST
	 $TRAN	TPA$_ANY,Q_STRING

	; now, collect the rest of the supposed filespec

	$STATE	GET_REST
	 $TRAN	'"',TPA$_FAIL			; only 1 pair of quotes allowed
	 $TRAN	!NON_DELIMITER
	 $TRAN	TPA$_LAMBDA,TPA$_EXIT

	$STATE
	 $TRAN	TPA$_ANY,GET_REST

	; subexpression to determine whether the token is a valid delimiter
	; or not

	$STATE	NON_DELIMITER
	 $TRAN	TPA$_EOS,TPA$_FAIL
	 $TRAN	'!',TPA$_FAIL
	 $TRAN	TPA$_BLANK,TPA$_FAIL
	 $TRAN	TPA$_LAMBDA,TPA$_EXIT		; anything else is a non-delimiter

	; state tables for the various assignment statements	

	; we have an assignment to change the name of the logfile.  parse
	; out the filename

	$STATE	LOGFIL_ASG
	 $TRAN	'=',,EXPLICIT_BLANKS,CASE$M_ASSIGN,CONTROL_CASE

	$STATE
	 $TRAN	TPA$_BLANK
	 $TRAN	TPA$_EOS,TPA$_FAIL
	 $TRAN	TPA$_LAMBDA

	$STATE
	 $TRAN	!FILE_SPEC,,IMPLICIT_BLANKS,,SPEC_DESC

	; got the filespec, now $PARSE it and put it in the right place and
	; ignore the rest of the line

	$STATE
	 $TRAN	TPA$_LAMBDA,TPA$_EXIT,PRS_FILE_SPEC



	; we have a generic assignment, so just parse out the string and
	; put it in the proper buffer

	$STATE	GENERIC_ASG
	 $TRAN	'=',,,CASE$M_ASSIGN,CONTROL_CASE

	$STATE
	 $TRAN	TPA$_SYMBOL,TPA$_EXIT,GET_ASG_VAL

	; we have an assignment for the time, so parse out the time and 
	; convert it to system time

	$STATE	TIME_ASG
	 $TRAN	'=',,EXPLICIT_BLANKS,CASE$M_ASSIGN,CONTROL_CASE

	$STATE
	 $TRAN	TPA$_BLANK
	 $TRAN	TPA$_EOS,TPA$_FAIL
	 $TRAN	TPA$_LAMBDA


	$STATE
	 $TRAN	!GET_TIME_STRING,,IMPLICIT_BLANKS,,TIME_DESC

	; we now have the time string, send it to convert time via 
	; an action routine

	$STATE
	 $TRAN	TPA$_LAMBDA,TPA$_EXIT,CONVERT_TIME

	;++
	;
	; subexpressions to get the time string.  we will parse out anything
	; up to a blank, or if there is a double quote, we will parse out
	; the entire string with the quotes (including blanks).  this is
	; to keep with VMS standard.
	;
	; once we have the time string, we will then send it to an action
	; routine to convert the time into system format.  this action routine
	; uses the RTL function CVT_TIME also according to VMS standard.
	;
	;--

	$STATE	GET_TIME_STRING
	 $TRAN	'"',QUOTED_TIME_STRING
	 $TRAN	!NON_DELIMITER
	 $TRAN	TPA$_LAMBDA,TPA$_EXIT

	$STATE
	 $TRAN	TPA$_ANY,GET_TIME_STRING

	;
	; subexpression to parse a quoted time string
	;

	$STATE	QUOTED_TIME_STRING
	 $TRAN	'"',TPA$_EXIT
	 $TRAN	TPA$_ANY,QUOTED_TIME_STRING

	$END_STATE

	; here are the action routines for the various transitions.

	
EXPLICIT_BLANKS:
	.WORD	^M<>

	;++
	;
	; action routine to set TPARSE to accept blanks
	;
	;--

	BISL2	#TPA$M_BLANKS,TPA$L_OPTIONS(AP)	; turn on blanks

	RET


IMPLICIT_BLANKS:
	.WORD	^M<>

	;++
	;
	; action routine to set TPARSE to ignore blanks (its default)
	;
	;--

	BICL2	#TPA$M_BLANKS,TPA$L_OPTIONS(AP)	; turn off blanks

	RET

PRS_FILE_SPEC:
	.WORD	^M<R2,R3>

	;++
	;
	; action routine to use RMS to $PARSE the filespec (pointed to by
	; the token pointer) and to fill in the descriptors of the various 
	; fields
	;
	;--

	; adjust the FAB to point to this filespec

	$FAB_STORE FAB = PRSE_FILESPC_FAB,-
		   FNA = @<SPEC_DESC+DSC$A_POINTER>,-
		   FNS = SPEC_DESC+DSC$W_LENGTH

	$PARSE	FAB = PRSE_FILESPC_FAB		; now, parse the filespec

	BLBS	R0,COPY_FILESPEC		; OK, fill in data area

	BRW	END_PRS_FILE			; if error, then exit with status

COPY_FILESPEC:

	; the parse was successful, now copy everything into the descriptors
	; RMS $PARSE has put the resultant string in FILE_SPEC_STR

	MOVAL	PRSE_FILESPC_NAM,R2		; get the NAM block

	MOVZBW	NAM$B_ESL(R2),-			; put the size in the descriptor
		FILE_SPEC_DESC+DSC$W_LENGTH

	MOVL	NAM$L_NODE(R2),-		; fill in the node descriptor
		NODE_DESC+DSC$A_POINTER		; ... location
	MOVZBW	NAM$B_NODE(R2),-		; ... and size
		NODE_DESC+DSC$W_LENGTH

	MOVL	NAM$L_DEV(R2),-			; fill in the device descriptor
		DEVICE_DESC+DSC$A_POINTER	; ... location
	MOVZBW	NAM$B_DEV(R2),-			; ... and size
		DEVICE_DESC+DSC$W_LENGTH

	MOVL	NAM$L_DIR(R2),-			; fill in the directory descriptor
		DIRECTORY_DESC+DSC$A_POINTER	; ... location
	MOVZBW	NAM$B_DIR(R2),-			; ... and size
		DIRECTORY_DESC+DSC$W_LENGTH

	MOVL	NAM$L_NAME(R2),-		; fill in the filename descriptor
		FILENAME_DESC+DSC$A_POINTER	; ... location	
	MOVZBW	NAM$B_NAME(R2),-		; ... and size
		FILENAME_DESC+DSC$W_LENGTH

	MOVL	NAM$L_TYPE(R2),-		; fill in the type descriptor
		TYPE_DESC+DSC$A_POINTER		; ... location
	MOVZBW	NAM$B_TYPE(R2),-		; ... and size
		TYPE_DESC+DSC$W_LENGTH

	MOVL	NAM$L_VER(R2),-			; fill in the version descriptor
		VERSION_DESC+DSC$A_POINTER	; ... location
	MOVZBW	NAM$B_VER(R2),-			; ... and size
		VERSION_DESC+DSC$W_LENGTH

DETERMINE_TYPE:

	; determine what type of file it is 

	; if file is a log file, skip type ckeck

	BBS	#ASSIGN$V_LOG,ASSIGN_CASE,PRS_FILE_SUC ; log file, skip type check

	CMPC3	TYPE_DESC+DSC$W_LENGTH,-	; check the type of this filespec
		@<TYPE_DESC+DSC$A_POINTER>,-	; against that for 
		EXE_STR				; an image

	BNEQ	10$				; wasn't .EXE

	BISL2	#CRTPRC$M_EXE,CREATE_PROC_CASE	; say that we have an image
	BRW	PRS_FILE_SUC			; exit with success

10$:
	; wasn't an image, is it a command file?

	CMPC3	TYPE_DESC+DSC$W_LENGTH,-	; check the type of this filespec
		@<TYPE_DESC+DSC$A_POINTER>,-	; against that for
		COM_STR				; a command procedure

	BNEQ	20$				; wasn't .COM

	BISL2	#CRTPRC$M_COM,CREATE_PROC_CASE	; say we have a command procedure
	BRW	PRS_FILE_SUC			; exit with success

20$:
	; wasn't a command procedure, so we have a bad file type

	MOVL	#RMS$_TYP,R0			; not a valid type
	BRB	END_PRS_FILE			; exit with error

PRS_FILE_SUC:

	; all done, so return success status and leave

	MOVL	#SS$_NORMAL,R0			; return success

END_PRS_FILE:

	RET					; exit

CONVERT_TIME:
	.WORD	^M<>

	;++
	;
	; this action routine takes the time string just parsed out (and
	; whose descriptor should be sitting in TPARSE's parameter block)
	; and sends it to the RTL function CVT_TIME.  CVT_TIME will 
	; determine if the syntax is acceptable, and will produce the 64-bit
	; binary system time if it is.
	;
	;--

	PUSHAQ	TIME_VALUE			; where the system time goes
	PUSHAQ	TIME_DESC			; the descriptor of the time string
	CALLS	#2,G^LIB$CVT_DTIME		; convert the time

	RET					; return with status

GET_ASG_VAL:
	.WORD	^M<R2,R3,R4,R5>

	;++
	;
	; this action routine is used to copy a "generic" assignment value into
	; the proper parse buffer.  in order for an assignment to be considered
	; generic, it must be a simple character string which needs no further
	; parsing.
	;
	;--

	MOVW	TPA$L_TOKENCNT(AP),-		; put the size in the descriptor
		ASSIGN_VALUE_DESC+DSC$W_LENGTH	; field

	MOVC3	TPA$L_TOKENCNT(AP),-		; and move the string there
		@TPA$L_TOKENPTR(AP),-
		ASSIGN_VALUE_STR

	MOVL	#SS$_NORMAL,R0			; return success

	RET					; and exit


COPY_PARAM:
	.WORD	^M<R2,R3,R4,R5>

	;++
	;
	; this action routine is used to copy the parameters associated with
	; the current filespec into a buffer.  it also determines what type
	; of process the filespec is and sets the proper flag to signal this.
	;
	;--

	; well, we have parameters so first find out what type of file
	; we have and set the proper flag saying that that file has parameters

	; check for valid file types

	BBSC	#CRTPRC$V_EXE,CREATE_PROC_CASE,EXE_P  ; is it an image?
	BBSC	#CRTPRC$V_COM,CREATE_PROC_CASE,COM_P  ; is it a command procedure?

	; it is not a file type which allows parameters, so exit with error

	CLRL	R0				; signal an error
	BRW	END_COPY_PARAM			; and leave

EXE_P:
	; it is an image with parameters, set that flag

	BISL2	#CRTPRC$M_EXE_PARM,CREATE_PROC_CASE  ; set image with parameters
	BRW	CONT_COPY			; and copy them

COM_P:
	; it is a command procedure with parameters, set that flag

	BISL2	#CRTPRC$M_COM_PARM,CREATE_PROC_CASE  ; set com. with parameters
	BRW	CONT_COPY			; and copy them

CONT_COPY:
	; now, copy the parameters (the current token) into our parameter
	; buffer

	MOVC3	TPA$L_TOKENCNT(AP),-		; move the current token (the
		@TPA$L_TOKENPTR(AP),-		; parameter list) into our
		PARAM_STR			; parameter buffer

	MOVW	TPA$L_TOKENCNT(AP),-		; and put the size in 
		PARAM_DESC+DSC$W_LENGTH		; the descriptor

	; exit with success

	MOVL	#SS$_NORMAL,R0			; leave with success

END_COPY_PARAM:

	RET					; exit

GET_COMMENT:
	.WORD	^M<R2,R3,R4,R5>

	;++
	;
	; this action routine copies the comment field (at this point,
	; the remainder of the line) into the comment buffer.
	;
	;--

	; copy the rest of the line into the comment buffer

	MOVC3	TPA$L_STRINGCNT(AP),-		; count of remaining characters
		@TPA$L_STRINGPTR(AP),-		; location of remaining characters
		COMMENT_STR			; our comment buffer

	MOVW	TPA$L_STRINGCNT(AP),-		; put the size in our
		COMMENT_DESC+DSC$W_LENGTH	; comment descriptor

	MOVL	#SS$_NORMAL,R0			; exit with success

	RET					; and exit

TST_DELIM:
	.WORD	^M<>

	;++
	;
	; action routine to determine if the current token we are looking 
	; at is the ending delimiter of a string.
	;
	;--

	CMPB	TPA$B_CHAR(AP),DELIMIT		; is this character the delimiter
	BNEQ	10$				; no, so exit with success
	CLRL	R0				; it is, so reject the transition

10$:
	RET					; leave


	.SBTTL Initialize data structure

	; set up offsets for the parameters

	IDS_NUMBER_OF_SLOTS = 4
	IDS_SIZE_OF_SLOT    = 8
	IDS_BEGIN_OF_STRUCT = 12
	IDS_LIST_HEADER     = 16

	
;++
; FUNCTIONAL DESCRIPTION:
;
;	This subroutine is called to initalize the process_information
;	data structure.  The data structure is to be a linked list of 
;	individual "slots" where one slot is allocated per user.  This
;	routine sets up an available reservoir of free slots.  The header
;	points to the first slot and then the linked list continues from there.
;	
;	NOTE: it is a requirement that structure area be a contiguous area.
;		(There may, however, be seperate non-contiguous structure areas.)
;
; CALLING SEQUENCE:
;
;	This routine is called by
;		PUSHAQ LIST_HEADER
;		PUSHAL BEGIN_OF_STRUCT
;		PUSHL  SIZE_OF_SLOT
;		PUSHL  NUMBER_OF_SLOTS
;		CALLS  #4,INIT_STRUCT
;
; INPUT PARAMETERS:
;
;	IDS_NUMBER_OF_SLOTS(AP) -- this is a value of the total number of slots to
;		be in the structure.
;	IDS_SIZE_OF_SLOT(AP) -- this is a value of the size of each individual
;		slot
;	IDS_BEGIN_OF_STRUCT(AP) -- this is the address of the beginning of the 
;		entire structure.
;	IDS_LIST_HEADER(AP) -- this is the address of a quadword which will the
;		available list header for the structure (hold FLINK and BLINK)
;
; IMPLICIT INPUTS:
;
;	None.
;
; OUTPUT PARAMETERS:
;
;	None.
;
; IMPLICIT OUTPUTS:
;
;	None.
;
; COMPLETION CODES:
;
;	SS$_NORMAL
;
; SIDE EFFECTS:
;
;	Links throughout the structure will be modified.
;--

INIT_STRUCT:
	.WORD ^M<R2,R3,R4,R5>

	; move the parameters into registers 

	MOVL	IDS_NUMBER_OF_SLOTS(AP),R2	; number of slots to init
	MOVL	IDS_SIZE_OF_SLOT(AP),R3		; size of each slot
	MOVL	IDS_BEGIN_OF_STRUCT(AP),R4	; addr of top of structure
	MOVL	IDS_LIST_HEADER(AP),R5		; addr of structure header

	; now insert the various slots into a linked stack.  The slots
	; are inserted at the tail so that the header will be pointing to
	; low order memory and will work towards high order.

10$:
	INSQTI	(R4),(R5)			; put slot at tail of list
	ADDL2	R3,R4				; get address of next slot
	SOBGTR  R2,10$				; go through whole list

	MOVL	#SS$_NORMAL,R0			; return success

	RET

	.SBTTL Expand region for more data areas

	; set up offsets for the parameters

	ER_NUMBER_OF_SLOTS    = 4
	ER_SIZE_OF_SLOT       = 8
	ER_LOCATION_OF_STRUCT = 12

	
;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called if it is required to expand the current
;	virtual address space because the current number of slots in the
;	data structure are filled.  It does this by first calculating the
;	number of pages needed and then by doing an $EXPREG system service.
;
; CALLING SEQUENCE:
;
;	This routine is called by
;		PUSHAQ LOCATION_OF_STRUCT
;		PUSHL  SIZE_OF_SLOT
;		PUSHL  NUMBER_OF_SLOTS
;		CALLS  #3,EXPND_REGION
;
; INPUT PARAMETERS:
;
;	ER_NUMBER_OF_SLOTS(AP) -- this is a value of the total number of slots to
;		be in the structure.
;	ER_SIZE_OF_SLOT(AP) -- this is a value of the size of each individual slot
;	ER_LOCATION_OF_STRUCT(AP) -- this is the address of a quadword to hold the
;		starting location (first longword) of the expanded region and
;		the ending location (second longword) of the expanded region.
;
; IMPLICIT INPUTS:
;
;	None.
;
; OUTPUT PARAMETERS:
;
;	None.
;
; IMPLICIT OUTPUTS:
;
;	@ER_LOCATION_OF_STRUCT(AP) will hold the starting and the ending location
;		of the expanded region.
;
; COMPLETION CODES:
;
;	SS$_NORMAL
;	SS$_SSFAIL -- failed to expand region, system service failed
;	SS$_FLTDIV  -- attempted divide by zero (note: FAO arguments are not
;		included with this code).
;
; SIDE EFFECTS:
;
;	None.
;--

EXPND_REGION:
	.WORD ^M<R2,R3,R4,R5,R6>


	; move the parameters into registers 

	MOVL	ER_NUMBER_OF_SLOTS(AP),R2	; number of slots to init
	MOVL	ER_SIZE_OF_SLOT(AP),R3		; size of each slot
	MOVL	ER_LOCATION_OF_STRUCT(AP),R4	; addr of top of structure

	; calculate the number of pages we are to expand by

	; first see if we are going to divide by zero

	TSTL	#PAGE_SIZE			; make sure page size isn't zero
	BNEQ	10$				; isn't zero, so continue
	MOVL	#SS$_FLTDIV,R0			; tried div-by-zero, so error
	BRW	END_EXPND_REGION		; and leave

	; OK, now calculate the number of pages

10$:
	MULL3	R2,R3,R5			; total number of bytes needed
	ADDL2	#<PAGE_SIZE-1>,R5		; add another page minus 1 to
						;  do the rounding up
	DIVL2	#PAGE_SIZE,R5			; and get the number of pages

	; we now know how many pages we need, so do the expansion

	$SETSFM_S ENBFLG = #0			; errors are OK, turn failure off
	CLRL	R6				; assume failure was disabled
	CMPL	R0,#SS$_WASSET			; was SS failure mode disabled?
	BNEQ	20$				; no, so continue
	MOVL	#1,R6				; save it to be re-enabled

20$:	
	$EXPREG_S PAGCNT = R5,-			; expand by this number of pages
		  RETADR = (R4)			; put results here

	MOVL	#SS$_NORMAL,R2			; assume it succeeded

	CMPL	R0,#SS$_NORMAL			; did it succeed?
	BEQL	30$				; yes, so exit
	MOVL	#SS$_SSFAIL,R2			; no, so return error

30$:
	$SETSFM_S ENBFLG = R6			; set to previous state

	MOVL	R2,R0				; return the completion code

END_EXPND_REGION:
	RET					; and leave

	.SBTTL	Abort Detached Processes

;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine is used to stop all the detached processes created by
;	this TSTCNTRL.  It does this by going down the current process list
;	and doing a $FORCEX on each of the processes.  It will also set a bit
;	(PRCINFO$V_PROC_ABORTED) in each of the processes information block.
;	This bit is to signal the termination routine that this process was
;	aborted prematurely.  It then sets a timer to give the processes a 
;	chance to run down before they are nuked.
;
; CALLING SEQUENCE:
;
;	CALLS	#0,ABORT_PROCESSES
;
; INPUT PARAMETERS:
;
;	None.
;
; IMPLICIT INPUTS:
;
;	FLAGS -- the TSTCNTRL flags
;	CURRENT_LIST_HEAD -- location of the header for the list of currently
;	 running processes.
;
; OUTPUT PARAMETERS:
;
;	None.
;
; IMPLICIT OUTPUTS:
;
;	Sets a bit (PRCINFO$V_PROC_ABORTED) in each processes information block.
;
; COMPLETION CODES:
;
;	SS$_NORMAL
;
; SIDE EFFECTS:
;
;	Causes the current detached processes to run down and leave the system.
;--

ABORT_PROCESSES:
	.WORD ^M<R2,R3,R4>

	; get the list of currently running processes

	MOVAQ	CURRENT_LIST_HEAD,R3		; header of currently running 
						; processes
	TSTL	(R3)				; is the list empty?

	BNEQ	10$				; no, so stop current processes

	BRW	END_ABORT_PROC			; no current processes, so exit

10$:
	; go through list and stop all the processes

	MOVL	PRCINFO$A_FLINK(R3),R2		; get offset to next slot
	ADDL3	R2,R3,R4			; calculate address of next slot

STOP_PROC:

	MOVL	PRCINFO$A_FLINK(R4),R2		; get offset to next slot

	; stop the next process on the list . . .

	$SETSFM_S  ENBFLG = #0			; check this error by hand

	$FORCEX_S  PIDADR = PRCINFO$L_PID(R4)	; abort the process

	; see if process was aborted without error. if it had error, it may
	; be that the process was already terminated; so don't touch abort
	; bit

	CMPL	#SS$_NORMAL,R0			; did it abort OK?
	BNEQ	10$				; no, so don't set abort bit
						
	BISL2	#PRCINFO$M_PROC_ABORTED,-	; set bit saying this process
		PRCINFO$L_FLAGS(R4)		; was aborted

10$:
	$SETSFM_S ENBFLG = #1			; turn on failure mode

	; . . . stopped that process, now see if there is another one

	ADDL2	R2,R4				; calculate address of next slot

	CMPL	R4,R3				; are we at the end of the list?
	
	BEQL	END_ABORT_PROC			; yes, so leave

	BRW	STOP_PROC			; more processes left

END_ABORT_PROC:
	; now set the timer to insure that at least one process terminates in
	; a specified amount of time.  If the timer goes off (ie, no process
	; terminated), then all of the processes are to be nuked

	$SETIMR_S DAYTIM = PROC_TERM_DELT,-	; set watchdog timer to insure
		  ASTADR = NUKE_PROC_AST,-	; that processes start to 
		  REQIDT = #ABRT_TIM_ID		; terminate

	MOVL	#SS$_NORMAL,R0			; return success

	RET

	.SBTTL	Nuke Detached Processes AST 

;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called as a last resort when detached processes 
;	previously aborted by $FORCEX have still failed to terminate.  It
;	is called when not one process has terminated within a set waiting 
;	time (determined by ABRT_DELT_SCNDS).  This routine will go through
;	the current process list and do a $DELPRC on each of the processes
;	still in that list.
;
; CALLING SEQUENCE:
;
;	Called by AST when abort process timer expires.
;
; INPUT PARAMETERS:
;
;	None.
;
; IMPLICIT INPUTS:
;
;	FLAGS -- the TSTCNTRL flags
;	CURRENT_LIST_HEAD -- location of the header for the list of currently
;	 running processes.
;
; OUTPUT PARAMETERS:
;
;	None.
;
; IMPLICIT OUTPUTS:
;
;	None.
;
; COMPLETION CODES:
;
;	SS$_NORMAL
;
; SIDE EFFECTS:
;
;	Aborts detached process in the middle of whatever it is doing.
;	May cause detached process not to clean up when it leaves.
;--

NUKE_PROC_AST:
	.WORD ^M<R2,R3,R4>

	; get the list of currently running processes

	MOVAQ	CURRENT_LIST_HEAD,R3		; header of currently running 
						; processes
	TSTL	(R3)				; is the list empty?

	BNEQ	10$				; no, so stop current processes

	BRW	END_NUKE_PROC			; no current processes, so exit

10$:
	; go through list and stop all the processes

	MOVL	PRCINFO$A_FLINK(R3),R2		; get offset to next slot
	ADDL3	R2,R3,R4			; calculate address of next slot

NUKE_PROC:

	; stop the next process on the list . . .

	$SETSFM_S  ENBFLG = #0			; check this error by hand

	$DELPRC_S  PIDADR = PRCINFO$L_PID(R4)	; abort the process

	; see if process was aborted without error. if it had error, it may
	; be that the process was already terminated

	CMPL	#SS$_NORMAL,R0			; did it abort OK?
	BNEQ	10$				; no, so don't set abort bit
						
10$:
	$SETSFM_S ENBFLG = #1			; turn on failure mode

	; . . . stopped that process, now see if there is another one

	MOVL	PRCINFO$A_FLINK(R4),R2		; get offset to next slot
	ADDL2	R2,R4				; calculate address of next slot

	CMPL	R4,R3				; are we at the end of the list?
	
	BEQL	END_NUKE_PROC			; yes, so leave

	BRW	NUKE_PROC			; more processes left

END_NUKE_PROC:

	BISL2	#TCNTRL$M_PROC_NUKED,FLAGS	; set flag saying processes have
						; been nuked

	MOVL	#SS$_NORMAL,R0			; return success

	RET


	.SBTTL  Process Termination AST 
;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called when a currently executing detached process
;	terminates.  The terminated process sends a mailbox message back to the
;	the TSTCNTRL and notification of that mailbox sends control here.
;	This routine then locates the process info slot of the terminated
;	process, removes it from the current process list, fills it in with
;	process termination info, places it on the completed process list,
;	and signals that a process has terminated.  
;	
;
; CALLING SEQUENCE:
;
;	This is called as an AST routine when a termination mailbox is 
;	received.
;
; INPUT PARAMETERS:
;
;	None
;
; IMPLICIT INPUTS:
;
;	The termination mailbox.
;	CURRENT_LIST_HEAD  - header pointing to the list of currently running
;		processes.
;	COMPLETE_Q_HEAD    - header pointing to the queue of completed processes.
;	PROCESS_TERM_IOSVB - the IOSB for the terimination mailbox
;
; OUTPUT PARAMETERS:
;
;	None
;
; IMPLICIT OUTPUTS:
;
;	CONTROL_CASE - the set of flags to determine which case statement to 
;		perform	next.
;
; COMPLETION CODES:
;	
;	None.
;
; SIDE EFFECTS:
;
;	Will modify both the current process list and the complete process queue.
;	Will change the control of the main case loop by setting the
;	CASE$V_PROC_TERM flag.
;	If unable to find process info slot, it will not set CASE$V_PROC_TERM.
;--


PROC_TERM_AST:
	.WORD  ^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>

	MOVAL	SSERROR,(FP)			; declare exception handler for
						;  this routine

	; see if the QIO to the mailbox has been canceled or aborted
	; the QIO may have been canceled if it came during the exit handler,
	; if this is the case, ignore the QIO

	CMPW 	#SS$_ABORT,PROC_TERM_IOSB	; has QIO been aborted?	
	BNEQ	10$				; no, see if canceled
	BRW	END_PROC_TERM_AST		; yes, exit

10$:
	CMPW	#SS$_CANCEL,PROC_TERM_IOSB	; has QIO been canceled?
	BNEQ	20$				; no, so continue
	BRW	END_PROC_TERM_AST		; yes, exit

20$:
	; now, find the process info slot for this particular process

	MOVAL	TERM_BUFF,R11			; get address of termination
						;  mailbox

	PUSHL	ACC$L_PID(R11)			; find slot for this PID
	PUSHAQ	CURRENT_LIST_HEAD		; look for it in this list
	CALLS	#2,FIND_PROC_SLOT		; and find the slot

	; see if we were able to find the slot

	CMPL	#SS$_NORMAL,R0			; did it find the slot
	BEQL	30$				; yes, so continue

	BRW	END_PROC_TERM_AST		; no, so leave without setting flag

30$:
	; we now have the address of the slot, the status was returned in
	; R0 and the address of the slot in R1

	MOVL	R1,R10				; save address of slot

	; now, remove the slot from the current list and put it at the
	; tail of the completed queue.  we must remove the slot by the 
	; following equations:  BLINK(FLINK(SLOT)) = BLINK(SLOT) and
	; FLINK(BLINK(SLOT)) = FLINK(SLOT).
	; since the values in the FLINK's and BLINK's are offsets, we must 
	; calculate the actual addresses and then calculate the new offsets

	MOVL	PRCINFO$A_FLINK(R10),R2		; get offset to forward struct
	ADDL3	R10,R2,R3			; get addr. of forward structure

	MOVL	PRCINFO$A_BLINK(R10),R4		; get offset to backward struct
	ADDL3	R10,R4,R5			; get addr. of backward structure

	; now calculate new offsets and change links

	SUBL3	R3,R5,R6			; calc new offset of back. struct
	MOVL	R6,PRCINFO$A_BLINK(R3)		; put offset of backward struct
						; in BLINK of forward structure

	SUBL3	R5,R3,R6			; calc new offset of for. struct
	MOVL	R6,PRCINFO$A_FLINK(R5)		; put offset of forward struct
						; in FLINK of backward structure

	; now put the slot on the tail of the completed queue

	INSQTI	(R10),COMPLETE_Q_HEAD		; put slot at end of complete queue

	; now move items from the termination mailbox into the process info slot

	MOVL	ACC$L_FINALSTS(R11),PRCINFO$L_FINALSTS(R10) ; the final status

	MOVQ	ACC$Q_TERMTIME(R11),PRCINFO$Q_TERMTIME(R10) ; the termination time

	MOVL	ACC$L_CPUTIM(R11),PRCINFO$L_CPUTIM(R10) ; CPU time used

	MOVL	ACC$L_PAGEFLTS(R11),PRCINFO$L_PAGEFLTS(R10) ; page faults incurred

	MOVL	ACC$L_PGFLPEAK(R11),PRCINFO$L_PGFLPEAK(R10) ; peak page file usage

	MOVL	ACC$L_WSPEAK(R11),PRCINFO$L_WSPEAK(R10) ; working set peak

	MOVL	ACC$L_BIOCNT(R11),PRCINFO$L_BIOCNT(R10) ; buffered I/O operations

	MOVL	ACC$L_DIOCNT(R11),PRCINFO$L_DIOCNT(R10) ; direct I/O operations

	MOVQ	ACC$Q_LOGIN(R11),PRCINFO$Q_LOGIN(R10) ; time process logged in

	; we are all done here, signal for control to go to the process 
	; termination routine

	BISL2	#CASE$M_PROC_TERM,CONTROL_CASE ; handle the terminated process

	; now activate another read to get the next termination mailbox

	$QIO_S	CHAN   = MBX_CHAN,-		; try & read another mailbox
		FUNC   = #IO$_READVBLK,-
		ASTADR = PROC_TERM_AST,-
		IOSB   = PROC_TERM_IOSB,-
		P1     = TERM_BUFF,-
		P2     = #MAILBOX_SIZE

END_PROC_TERM_AST:

	$WAKE_S					; wake up and service this 
						;  terminated process

	MOVL	#SS$_NORMAL,R0			; return success

	RET					; return to where we were

	.SBTTL	Find Process Slot

	; define offsets for parameters

	FS_LIST_HEADER = 4
	FS_SLOT_PID    = 8

;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called from the AST routine PROC_TERM_AST and it is
;	used to go sequentially through the Current Process List to find the
;	the slot which corresponds to the process which just terminated.  It
;	does this by checking the PID's from the Current Process List with that
;	of the terminated process until it finds a match.  It then returns the
;	address of the slot in R1.
;
; CALLING SEQUENCE:
;
;	PUSHL	PID
;	PUSHAQ	CURRENT_LIST_HEAD
;	CALLS	#2,FIND_PROC_SLOT
;
; INPUT PARAMETERS:
;
;	FS_LIST_HEADER(AP) - address of the header of the Current Process List
;	FS_SLOT_PID(AP)    - value of the PID of the completed process
;
; IMPLICIT INPUTS:
;
;	None.
;
; OUTPUT PARAMETERS:
;
;	None
;
; IMPLICIT OUTPUTS:
;
;	R1 holds the address of the slot of the just completed process
;
; COMPLETION CODES:
;
;	SS$_NORMAL
;	SS$_NOSUCHSEC - we couldn't find the specified slot in the data structure
;
; SIDE EFFECTS:
;
;	None.
;--

FIND_PROC_SLOT:
	.WORD ^M<R2>

	; get the address of the current process list, this will be the base

	MOVL	FS_LIST_HEADER(AP),R2		; base of the list

	CMPL	#0,(R2)				; is the header empty?
	BEQL	SLOT_NOT_FND			; yes, then no slot

10$:
	; now calculate the address of the next slot

	ADDL2	PRCINFO$A_FLINK(R2),R2		; this is start of next slot

	; see if we are back to the header 

	CMPL	R2,@FS_LIST_HEADER(AP)		; are back to the header?
	BEQL	SLOT_NOT_FND			; yes, and we didn't find the slot

	; we have a valid slot, so check the PID and see if it is the one
	; we want

	CMPL	FS_SLOT_PID(AP),PRCINFO$L_PID(R2) ; is this the right slot?
	BNEQ	10$				; no, so try again

	; we found the slot we were looking for, get the address of it

	MOVL	R2,R1				; return the address of the slot
	MOVL	#SS$_NORMAL,R0			; return success
	BRW	END_FIND_PROC_SLOT		; and leave

SLOT_NOT_FND:
	; we went through the entire data structure and didn't find the right
	; slot.  Something must be very wrong.  Write out a message and return
	; an error status.

	; write out an error message

	PUSHAL	DATSTRUC_ERR			; an error with the data structure
	PUSHL	#1
	PUSHL	#TCNTRL$_TEXT!STS$K_WARNING	; we can try and continue
	CALLS	#3,G^LIB$SIGNAL			; write the error

	; and return an error status	

	MOVL	#SS$_NOSUCHSEC,R0		; say we couldn't find that slot

END_FIND_PROC_SLOT:

	RET					; and return

	.SBTTL	Maximum Timer Expiration AST 

;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called if the maximum time as defined by the
;	assignment statement MAXTIME =  hh:mm  has expired.  The routine 
;	prints out a message saying that max-time has expired, and sets
;	the case bit CASE$V_TIME_EXP.  Control then returns to the case loop
;	where proper action for the termination of currently running processes
;	will take place.
;
; CALLING SEQUENCE:
;
;	Called via an AST when timer expires.
;
; INPUT PARAMETERS:
;
;	None.
;
; IMPLICIT INPUTS:
;
;	None.
;
; OUTPUT PARAMETERS:
;
;	None.
;
; IMPLICIT OUTPUTS:
;
;	The CASE$V_TIME_EXP bit will be set in CONTROL_CASE.
;
; COMPLETION CODES:
;
;	SS$_NORMAL
;
; SIDE EFFECTS:
;
;	Will cause the MAX_TIME_EXP routine to be called to stop all
;	currently running processes.
;
;--

TIME_EXP_AST:
	.WORD	^M<>				; Entry mask

	MOVAL	SSERROR,(FP)			; declare exception handler for
						;  this routine

	; set case bit 

	BISL2	#CASE$M_TIME_EXP,CONTROL_CASE	; case to proper routine

	$WAKE_S					; do a wake to get out of possible
						; HIBER

	MOVL	#SS$_NORMAL,R0			; return success
	
	RET

	.SBTTL	System Service Exception Handler
;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine is executed if a system service or RMS error occurs or
;	if a LIB$SIGNAL system service is used to output a message.
;	Information about this method of handling messages and errors can be
;	found in the VMS COMMON RUN-TIME manual and in the VMS SYSTEM SERVICE
;	manual.
;
;	If a severe error or exception occurs, then the TSTCNTRL begins
;	the abort process to run down all currently running processes.  This
;	is done by calling the exit handler.  If a severe error or exception
;	occurs while in the abort process, then the TSTCNTRL gives up trying
;	to run down processes and simply exits.
;
; CALLING SEQUENCE:
;
;	Entered via an exception from the system
;
; INPUT PARAMETERS:
;
;	                -----------------
;	   AP ---->     !       2       !
;			!---------------!
;			! SIGNL ARY PNT !
;			!---------------!
;			! MECH  ARY PNT !
;			!---------------! ---------
;			!       4       !         ^
;			!---------------!         !
;			! ESTABLISH FP  !         !
;			!---------------!         !
;			!    DEPTH      ! Mechanism Array
;			!---------------!         !
;			!      R0       !         !
;			!---------------!         !
;			!      R1       !         v
;			!---------------! ---------
;			!       N       !         ^
;			!---------------!         !
;			! CONDITION NAME!         !
;			!---------------!         !
;			! N-3 ADDITIONAL!    Signal Array
;			! LONG WORD ARGS!         !
;			!---------------!         !
;			!      PC       !         !
;			!---------------!         !
;			!      PSL      !         v
;			!---------------! ---------
; IMPLICIT INPUTS:
;
;	None.
;
; OUTPUT PARAMETERS:
;
;	None.
;
; IMPLICIT OUTPUTS:
;
;	If the call was due to a system error, then the CASE$V_ABORT bit in
;	CONTROL_CASE will be set to start the termination process.
;
; COMPLETION CODES:
;
;	SS$_CONTINUE - return to what we were doing
;
; SIDE EFFECTS:
;
;	If the call was due to a LIB$SIGNAL, then just write out the message.
;	If the call was due to an error, write out the error and start the
;	termination processes of the TSTCNTRL.
;
;	If an error occurs while in abort phase; then the any currently 
;	running process is not stopped, and when it does stop it may be
;	left in the MWAIT state.
;
;--

SSERROR:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Entry mask

	MOVAL	SSERROR,(FP)			; re-declare the exception handler

	$SETAST_S ENBFLG = #0			; disable AST delivery
	CLRL	R10				; assume it was disabled
	CMPL	R0,#SS$_WASSET			; were AST's enabled?
	BNEQ	10$				; no, so continue
	MOVL	#1,R10				; save it to be reenabled

10$:
	$SETSFM_S ENBFLG = #0			; Disable SS failure mode for PUTMSG
	CLRL	R11				; assume it was disabled
	CMPL	R0,#SS$_WASSET			; was SS failure mode enabled?
	BNEQ	20$				; no, so continue
	MOVL	#1,R11				; save it to be reenabled

20$:
	MOVAL	CNTRL_LOG_RAB,R7		; get addr of perm log RAB

	MOVL	CHF$L_SIGARGLST(AP),R6		; Get the signal array pointer
	CMPZV	#STS$V_FAC_NO,#STS$S_FAC_NO,- 	; Is this a message from LIB$SIGNAL?
		CHF$L_SIG_NAME(R6),#TCNTRL_K
	BNEQ	30$				; BR if this is a system exception

	; set facility code to be new one

	INSV	FAC_CODE,#STS$V_FAC_NO,-	; set the facility code of the
		#STS$S_FAC_NO,-			; message to be the defined
		CHF$L_SIG_NAME(R6)		; facility code

	SUBL2	#2,CHF$L_SIG_ARGS(R6)		; Drop the PC and PSL
	$PUTMSG_S MSGVEC = CHF$L_SIG_ARGS(R6),-	; Print the message
		  ACTRTN = LNG_FORMAT

	BRW	END_SSERROR			; Return to the program

30$:
	CMPL	#SS$_SSFAIL,-			; see if system service failure
		CHF$L_SIG_NAME(R6)		; (which means it might be RMS)
	BNEQ	SYS_EXCEPT			; it is not an RMS error

	CMPZV	#STS$V_FAC_NO,#STS$S_FAC_NO,- 	; Is it an RMS failure?
		CHF$L_SIG_ARG1(R6),#RMS_K
	BNEQ	SYS_EXCEPT			; BR if not

	BRW	END_SSERROR			; Return to the program


SYS_EXCEPT:
	; we have a system error, see if we are in an abort state. If we are,
	; then we cannot clean up anymore, so we exit.  If we are not in an 
	; abort state, then we will print an error and start the abort process
	; by calling the exit handler.

	BBCS	#TCNTRL$V_ABORT,FLAGS,10$	; if not in abort, print error

	; we are in a abort sequence, cancel the exit handler and bail out

	$SETSFM_S ENBFLG = R11			; set to previous state
	$SETAST_S ENBFLG = R10			; set to previous state

	$CANEXH_S				; cancel our exit handler . . .
	$EXIT_S	CODE = STATUS			; . . . so that the system can 
						; worry about cleaning up

10$:
	; now produce the reason for the error

	MOVL	CHF$L_SIG_NAME(R6),STATUS 	; Save the status
	CLRL	R8				; Assume that it is not SS failure
	CMPL	#SS$_SSFAIL,STATUS		; But, is it a SS failure?
	BNEQ	30$				; No, so no special message
	$GETMSG_S MSGID  = CHF$L_SIG_ARG1(R6),- ; Get message for failure code
		  MSGLEN = GETMSG_PTR,-
		  BUFADR = GETMSG_DESC,-
		  FLAGS  = #14,-		; but without the text
		  OUTADR = MSG_BLOCK

	TSTB	MSG_BLOCK+1			; any FAO arguments?
	BEQL	20$				; no, so skip alternate message
	PUSHAL 	GETMSG_PTR			; write message w/out FAO text
	PUSHL	#1
	PUSHL	#TCNTRL$_TEXT			; put the message with an info message
	INSV	CHF$L_SIG_ARG1(R6),-		; and put correct severity code
		#STS$V_SEVERITY,-		;  with the message
		#STS$S_SEVERITY,(SP)

	INSV	FAC_CODE,#STS$V_FAC_NO,-	; set the facility code of the
		#STS$S_FAC_NO,-			; message to be the defined
		(SP)				; facility code

	MOVL	#3,R8				; number of arguments we pushed
	BRB	30$				; leave

20$:
	PUSHL	CHF$L_SIG_ARG1(R6)		; no FAO text, so write entire mesg.
	MOVL	#1,R8				; pushed one argument

30$:
	MULL3	#4,CHF$L_SIG_ARGS(R6),R7 	; Convert longwords to bytes
	SUBL2	R7,SP				; Save the current signal array...
	MOVC3	R7,CHF$L_SIG_NAME(R6),(SP) 	; ...on the stack

	ADDL3	R8,CHF$L_SIG_ARGS(R6),R9	; calculate the current number
						; of arguments

	ADDL2	#4,R9				; add the following arguments:

	PUSHL	#0				; the time parameter
	PUSHAL	PRC_NAM_DESC			; the process name
	PUSHL	#2
	PUSHL	#TCNTRL$_ABENDD!STS$K_SEVERE	; a severe problem
	CALLS	R9,G^LIB$SIGNAL			; write the message

	$SETSFM_S ENBFLG = R11			; set to previous state
	$SETAST_S ENBFLG = R10			; set to previous state

	; we want to start abort sequence, so we will do so by going through
	; the exit handler

	$EXIT_S CODE = STATUS			; start abort via exit handler

END_SSERROR:

	$SETSFM_S ENBFLG = R11			; set to previous state
	$SETAST_S ENBFLG = R10			; set to previous state

	MOVL	#SS$_CONTINUE,R0		; return to what we were doing

	RET

LNG_FORMAT:
	.WORD	^M<R2,R3>

	; prints the time stamps to the logfile

	MOVAL	CNTRL_LOG_RAB,R3		; get addr of perm log RAB
	MOVL	4(AP),R2			; get the message descriptor address
	MOVW	(R2),RAB$W_RSZ(R3)		; put the size in
	MOVL	4(R2),RAB$L_RBF(R3)		; put the address in
	$PUT	RAB = R3			; write the record
	MOVL	#SS$_NORMAL,R0			; set return status
	BBS	#TCNTRL$V_WRT_MSG,FLAGS,10$	; print mesg if suppose to
	BBS	#TCNTRL$V_LONG_REPORT,FLAGS,10$	; print mesg if report is long

	CLRL	R0				; else, don't print mesg

	BISL2	#TCNTRL$V_WRT_MSG,FLAGS		; turn wrt mesg back on

10$:
	RET					; keep working

	.SBTTL	RMS Error Handler
;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine handles error returns from RMS calls.
;
; CALLING SEQUENCE:
;
;	Called by RMS when a file processing error is found.
;
; INPUT PARAMETERS:
;
;	None.
;
; IMPLICIT INPUTS:
;
;	The FAB or RAB associated with the RMS call.
;
; OUTPUT PARAMETERS:
;
;	None.
;
; IMPLICIT OUTPUTS:
;
;	If the error is severe, the CASE$V_ABORT bit will be set to start
;	TSTCNTRL termination.
;
; COMPLETION CODES:
;
;	SS$_NORMAL
;
; SIDE EFFECTS:
;
;	Program may start termination sequence depending on severity of the 
;	error RMS errors RMS$_FNF and RMS$_EOF are ignored.
;
;--

RMSERR:
	.WORD	^M<R2,R3,R4,R5,R6> 		; Entry mask

	MOVL	4(AP),R2			; See whether we're dealing with...
	CMPB	#FAB$C_BID,FAB$B_BID(R2) 	; ...a FAB or a RAB
	BNEQ	RAB_ERROR			; BR if it's a RAB

FAB_ERROR:
	; error was caused in by the FAB, see if it is acceptable, write
	; message if it is not

	CMPL	#RMS$_FNF,FAB$L_STS(R2)		; FNF is acceptable,
	BNEQ	10$				; it isn't FNF, continue
	BRW	END_RMSERR			; it is FNF, so leave

10$:
	MOVAL	FILE,R3				; FAB-specific code:  text string...
	MOVL	R2,R4				; ...address of FAB...
	PUSHL	FAB$L_STV(R2)			; ...STV field for error...
	PUSHL	FAB$L_STS(R2)			; ...STS field for error...
	MOVL	FAB$L_STS(R2),R5		; ...and save the error code
	BRB	COMMON				; FAB and RAB share other code

RAB_ERROR:
	; error was caused in by the RAB, see if it is acceptable, write
	; message if it is not

	CMPL	#RMS$_EOF,RAB$L_STS(R2)		; EOF is acceptable
	BNEQ	10$				; not EOF, so write error
	BRW	END_RMSERR			; it is EOF, so leave

10$:
	MOVAL	RECORD,R3			; RAB-specific code:  text string...
	MOVL	RAB$L_FAB(R2),R4		; ...address of associated FAB...
	PUSHL	RAB$L_STV(R2)			; ...STV field for error...
	PUSHL	RAB$L_STS(R2)			; ...STS field for error...
	MOVL	RAB$L_STS(R2),R5		; ...and save the error code

COMMON:	
	; we have an RMS error, see if we are in an abort state. If we are,
	; then we cannot clean up anymore, so we exit.  If we are not in an 
	; abort state, then we will print an error and start the abort process
	; by calling the exit handler.

	BBC	#TCNTRL$V_ABORT,FLAGS,10$	; if not in abort, print error

	; we are in a abort sequence, cancel the exit handler and bail out


	$CANEXH_S				; cancel our exit handler . . .
	$EXIT_S	CODE = STATUS			; . . . so that the system can 

10$:
	MOVZBL	FAB$B_FNS(R4),R6
	$FAO_S	CTRSTR = RMS_ERR_STRING,- 	; Common code, prepare error message...
		OUTLEN = BUFFER_PTR,-
		OUTBUF = FAO_BUF,-
		P1     = R3,-
		P2     = R6,-
		P3     = FAB$L_FNA(R4)
	PUSHAL	BUFFER_PTR			; ...and arguments for ERROR_EXIT...
	PUSHL	#1				; ...
	PUSHL	#TCNTRL$_TEXT			; ...

	INSV	FAC_CODE,#STS$V_FAC_NO,-	; set the facility code of the
		#STS$S_FAC_NO,-			; message to be the defined
		(SP)				; facility code

	INSV	R5,-				; get the right serverity
		#STS$V_SEVERITY,-
		#STS$S_SEVERITY,-
		(SP)

	PUSHL	#0				; the time parameter
	PUSHAL	PRC_NAM_DESC			; the process name
	PUSHL	#2
	PUSHL	#TCNTRL$_ABENDD!STS$K_SEVERE	; a severe problem
	CALLS	#9,G^LIB$SIGNAL			; write the message

	; we want to start abort sequence, so we will do so by going through
	; the exit handler

	$EXIT_S	CODE = STATUS			; start abort via exit handler

END_RMSERR:

	MOVL	#SS$_NORMAL,R0			; return success

	RET

	.SBTTL	CTRL/C Handler
	.DEFAULT DISPLACEMENT,LONG
;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine is reached when a Control-C is typed by the user signaling
;	to abort the TSTCNTRL.  The routine activates a repeating control-C 
;	handler (via an out-of-band QIO) to "eat" up any further control-C's 
;	which the user may type.  A message is printed saying that the TSTCNTRL
;	has been aborted due to a control_C and the CASE$V_ABORT flag is set
;	to start the termination process.
;
; CALLING SEQUENCE:
;
;	Called via AST
;
; INPUT PARAMETERS:
;
;	None.
;
; IMPLICIT INPUTS:
;
;	None.
;
; OUTPUT PARAMETERS:
;
;	None.
;
; IMPLICIT OUTPUTS:
;
;	The CASE$V_ABORT flag will be set to start the termination process.
;
; COMPLETION CODES:
;
;	SS$_NORMAL
;
; SIDE EFFECTS:
;
;	All further Control-C's will be ignored.
;	Termination of the TSTCNTRL will begin.
;
;--

CCASTHAND:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Entry mask

	; set out-of-band so as to ignore any future Control-C's

	$QIO_S	CHAN = TTCHAN,-			; do a read from the TTY
		FUNC = #IO$_SETMODE!IO$M_OUTBAND,-   ; look at the control character
		P1 = RPT_CNTRLC_AST,-		; and handle it if it is a ^C
		P2 = #CNTRLC_MSK

	; write abort message

	PUSHAL	CNTRLCMSG			; Set message pointer
	PUSHL	#1				; Set arg count
	PUSHL	#TCNTRL$_TEXT!STS$K_WARNING	; Set signal name

	INSV	FAC_CODE,#STS$V_FAC_NO,-	; set the facility code of the
		#STS$S_FAC_NO,-			; message to be the defined
		(SP)				; facility code

	PUSHL	#0				; Indicate an abnormal termination
	PUSHAL	PRC_NAM_DESC
	PUSHL	#2
	PUSHL	#TCNTRL$_ABENDD!STS$K_WARNING 	; Say abort with the time
	CALLS	#7,G^LIB$SIGNAL			; Output the message

	; set case to abort

	BISL2	#CASE$M_ABORT,CONTROL_CASE	; start termination sequence

	$WAKE_S					; wake in case we are in HIBER

	MOVL	#SS$_NORMAL,R0			; return success

	RET

RPT_CNTRLC_AST:
	.WORD ^M<>
	; enter this AST if repeated CNTL-C's are issued. To handle the
	;   additional CNTRL-C, simply exit.
	RET

	.SBTTL	Exit Handler
;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine is invoke only if the TSTCNTRL is stopped by external means
;	(e.g., another process doing $FORCEX on it).  The routine is called as
;	an AST.  When invoke, it will set the CASE$V_ABORT bit to start 
;	termination of the TSTCNTRL, set the TCNTRL$V_EXIT_HAND bit to signal
;	that we executed the exit handler, clear the AST that brought us here 
;	(this is so that we may receive termination AST's), and do a branch 
;	subroutine to the main case loop so as to receive the terminating 
;	processes.  Right before the TSTCNTRL is about to exit, it will check
;	to see if the TCNTRL$V_EXIT_HAND bit is set, and if it is, control will
;	then return to this routine via a RSB.
;
; CALLING SEQUENCE:
;
;	Reached as an AST when termination is attempted by outside mechanism.
;
; INPUT PARAMETERS:
;
;	None.
;
; IMPLICIT INPUTS:
;
;	None.
;
; OUTPUT PARAMETERS:
;
;	None.
;
; IMPLICIT OUTPUTS:
;
;	TCNTRL$V_EXIT_HAND bit is set in FLAGS.
;	CASE$V_ABORT bit is set in CONTROL_CASE.
;
; COMPLETION CODES:
;
;	TCNTRL$_ABORT
;
; SIDE EFFECTS:
;
;	Will start the termination process.
;	Will clear the AST which brought us here.
;	Will send control to the main case loop
;
;--

EXIT_HANDLER:
	.WORD	^M<>				; Entry mask

	; set the proper flags

	BISL2	#CASE$M_ABORT,CONTROL_CASE	; to start termination process
	BISL2	#TCNTRL$M_ABORT,FLAGS		; say we are in abort mode
	BISL2	#TCNTRL$M_EXIT_HAND,FLAGS	; to say we came through the
						; exit handler

	; clear the AST which brought us here

	CALLS	#0,G^SYS$CLRAST			; clear current AST

	; and send control back to the main case loop

	BSBW	MAIN_LOOP			; start termination

	; set our error status and leave for good

	MOVL	#TCNTRL$_ABORT,R0		; abort status

	RET					; BYE NOW!

	.END TSTCNTRL
