MODULE RM3UPDATE (LANGUAGE (BLISS32) ,
		IDENT = 'V04-000'
		) =
BEGIN
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************

!++
!
! FACILITY:	RMS32 INDEX SEQUENTIAL FILE ORGANIZATION
!
! ABSTRACT:
!               High level update and other miscellaneous update specific
!		routines.
!
!
! ENVIRONMENT:
!
!		VAX/VMS OPERATING SYSTEM
!
!--

!
! AUTHOR:        Todd M. Katz	     RE-CREATION DATE:	22-Dec-1982
!
!
! MODIFIED BY:
!
!	V03-026	JWT0184		Jim Teague		21-Jun-1984
!		Fix invalid RRV corruption problem.  On an update,
!		if the new record is longer than the old record,
!		a delete + insert operation is performed.  However,
!		one thing that is different about the insert is 
!		that the new record has to have the same record
!		id as the old one.  RMS saves the record id 
!		very early on in the update process, and never
!		looks at it again before stuffing it into the new 
!		record.  If the desired record has been displaced 
!		by a bucket split since last_id has been saved, 
!		the record id of the new record will almost 
!		certainly be wrong.  To fix this, reevaluate
!		last_id at a point considerably later in the 
!		update operation.
!		
!	V03-025	JWT0183		Jim Teague		21-May-1984
!		Fix cause of famous "RFA-accessed record deleted"
!		error that occurred infrequently on $UPDATEs.
!		It was simply a case of RMS not trying hard
!		enough for the record.  RMS first tries to find the
!		record at the last place it saw it ( LAST_ID and
!		LAST_VBN ) by calling FIND_BY_RFA.  If someone
!		has split the bucket out from under us, and the
!		desired record described by the LAST fields was
!		not in its original bucket, FIND_BY_RFA will tell
!		us RMS$_DEL.  If that is the case, RMS will have
!		to simply follow the record from it's RRV in the 
!		original bucket using FIND_BY_RRV.  It used to 
!		give up if FIND_BY_RFA failed with RMS$_DEL.
!
!	V03-024 MCN0003		Maria del C. Nasr	04-Apr-1983
!		Change linkage of RM$NULLKEY to RL$JSB.
!
!	V03-023	TMK0014		Todd M. Katz		26-Mar-1983
!		Change the linkage for RM$RU_JOURNAL3 from RL$RABREG_467 to
!		RL$RABREG_67.
!
!	V03-022 MCN0002		Maria del C. Nasr	24-Mar-1983
!		More linkages reorganization
!
!	V03-021	RAS0135		Ron Schaefer		17-Mar-1983
!		Fix spelling of RJR$_UPDAT -> RJR$_UPDATE.
!
!	V03-020	TMK0013		Todd M. Katz		16-Mar-1983
!		Change the linkage for RM$RU_JOURNAL3 from RL$RABREG_67 to
!		RL$RABREG_467.
!
!	V03-019	TMK0012		Todd M. Katz		16-Mar-1983
!		Change the symbol RMSR_UPDAT to RJR_UPDAT.
!
!	V03-018 MCN0001		Maria del C. Nasr	28-Feb-1983
!		Reorganize linkages
!
!	V03-017	TMK0011		Todd M. Katz		12-Jan-1983
!		Add support for Recovery Unit Journalling and RU ROLLBACK 
!		Recovery of ISAM files. This involves modifications to
!		RM$REPLACE, RM$UPDATE_SCAN, and RM$UPDATE3B such that:
!
!		1. The RU Journalling is done before any permanent modifications
!		   are made to the file. 
!
!		2. No space is reclaimed as the result of $UPDATEs done within
!		   Recovery Units. Inotherwards, if old SIDRs are to be deleted
!		   they are just marked RU_DELETE, and no space is reclaimed.
!		   Likewise, if the new primary data record is smaller that the
!		   old record, the record is marked RU_UPDATE, it does not 
!		   shrink in size (in fact it may even grow by one byte), and 
!		   it is put into a special format so that the space maybe 
!		   reserved in case the Recovery Unit must be aborted.
!
!		3. If a Recovery Unit Rollback is in progress, there is no need
!		   to insert new SIDRs which are still represented in the file
!		   (they are marked RU_DELETE). Instead the RU_DELETE bit is
!		   cleared in the SIDR element's control byte.
!
!	V03-016	TMK0010		Todd M. Katz		05-Jan-1983
!		RM$UPDATE3B was saving, zeroing, and then restoring the current 
!		NRP key of reference while the old SIDRs were being deleted. 
!		This is no longer necessary.
!
!	V03-015	TMK0009		Todd M. Katz		22-Dec-1982
!		I have changed a sufficient amount of $UPDATE, including the
!		basic algorithms, so that the audit trail has been invalidated.
!
!*****

LIBRARY 'RMSLIB:RMS';

REQUIRE 'RMSSRC:RMSIDXDEF';

! Define default psects for code
!
PSECT
    CODE = RM$RMS3(PSECT_ATTR),
    PLIT = RM$RMS3(PSECT_ATTR);

! Linkages
!
LINKAGE
    L_COMPARE_KEY,
    L_ERROR_LINK1,
    L_ERROR_LINK2,
    L_JSB,
    L_JSB01,
    L_LINK_7_10_11,
    L_PRESERVE1,
    L_RABREG,
    L_RABREG_4567,
    L_RABREG_567,
    L_RABREG_67,
    L_RABREG_7,
    L_REC_OVHD,

    ! Local Linkage
    !
    RL$REPLACE = JSB () :
		 GLOBAL (R_BKT_ADDR, R_IRAB, R_IFAB, R_IDX_DFN, R_REC_ADDR),
    RL$UPDATE_SCAN = JSB() :
		     GLOBAL (R_REC_ADDR, R_IMPURE, R_IDX_DFN, R_IFAB, R_IRAB, R_RAB);

! External Routines
!
EXTERNAL ROUTINE
    RM$CLEAN_BDB	: RL$ERROR_LINK1 NOVALUE,
    RM$COMPARE_KEY	: RL$COMPARE_KEY,
    RM$DELETE_SIDR	: RL$RABREG_7,
    RM$EXPAND_KEYD	: RL$JSB01,
    RM$FIND_BY_RFA	: RL$RABREG_67,
    RM$FIND_BY_RRV	: RL$RABREG_67,
    RM$GET_NEXT_KEY	: RL$LINK_7_10_11,
    RM$INS_ALL_SIDR	: RL$RABREG_4567,
    RM$INSERT_UDR	: RL$RABREG_4567,
    RM$INSS_OR_IDX	: RL$RABREG_567,
    RM$KEY_DESC		: RL$RABREG_7,
    RM$MOVE		: RL$PRESERVE1,
    RM$NULLKEY		: RL$JSB,
    RM$PACK_REC		: RL$RABREG_567,
    RM$PUT_UPD_CHKS	: RL$RABREG_7,
    RM$PUTUPD_ERROR	: RL$ERROR_LINK2 NOVALUE,
    RM$PUT_UPD_FIN	: RL$RABREG,
    RM$PUT_UPD_SPL	: RL$RABREG_4567,
    RM$RECORD_ID	: RL$RABREG_67,
    RM$RECORD_KEY	: RL$PRESERVE1,
    RM$RECORD_VBN	: RL$PRESERVE1,
    RM$REC_OVHD		: RL$REC_OVHD,
    RM$RLSBKT		: RL$PRESERVE1,
    RM$RU_JOURNAL3	: RL$RABREG_67,
    RM$UNPACK_REC	: RL$JSB01,
    RM$UPDDELCOM	: RL$RABREG_67;

%SBTTL	'RM$REPLACE'
ROUTINE RM$REPLACE (NEW_REC_SIZE) : RL$REPLACE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
! This routine updates the record pointed to by REC_ADDR if the new record is 
! the same size or smaller than record being updated. Otherwise, this routine
! deletes entirely the old record thus setting up the conditions for performing 
! a bucket split.
!
! If the $UPDATE is taking place within a Recovery Unit and the new record is
! smaller then the old record by more than one byte then the record is marked
! RU_UPDATE and placed into a special format so that the old size maybe reserved
! in case it become necessary to ROLLBACK recover the Recovery Unit. This 
! special format is to have the size of the amount of space that is being 
! reserved in the primary data record overhead's record size field while the 
! true size of the record occupies the last two bytes of this reserved space.
!
! If the $UPDATE is taking place within a Recovery Unit and the new record is
! smaller that the old record by exactly one byte, then the primary data record
! must also be marked RU_UPDATE and placed into the special format. However, as
! placing the record in a special format would require it to grow in size by one
! byte, this routine does not replace the old with the new record. Instead, the
! old record is deleted, the state bit IRB$V_RU_UPDATE is set, and a 0 is 
! returned indicating that a strict replacement could not be done. When the new
! record is eventually inserted, the state bit IRB$V_RU_UPDATE indicates that
! its size must be increased by two, and that it should be put into this special
! format.
!
! If the $UPDATE is taking place as a RU ROLLBACK Recovery operation and the
! new record is smaller than the old record by more than one byte, then the 
! primary data record is also marked RU_UPDATE and is placed into the special 
! format. This special formatting is not necessary if the new record is exactly
! one byte smaller than the old record.
!
! CALLING SEQUENCE:
!
!	RM$REPLACE()
!
! INPUT PARAMETERS:
!
!	NEW_REC_SIZE	- size of the new record
!
! IMPLICIT INPUTS:
!
!	BKT_ADDR 		- address of the primary data bucket
!	    BKT$W_FREESPACE	- freespace offset pointer
!
!	IDX_DFN			- address of the primary key index descriptor
!	    IDX$V_KEY_COMPR	- if set, primary key compression is enabled
!
!	IFAB			- address of the IFAB
!	    IFB$W_KBUFSZ	- size of a keybuffer
!	    IFB$B_PLG_VER	- prologue version of the file
!	    IFB$V_RUP		- if set, Recovery Unit is in progress
!	    IFB$V_RU_RECVR	- if set, RU ROLLBACK Recovery in progress
!
!	IRAB			- address of the IRAB
!	    IRB$L_KEYBUF	- address of the contigious keybuffers
!	    IRB$L_RECBUF	- address of the record buffer
!	    IRB$L_RBF		- address of the user's record buffer
!
!	REC_ADDR		- address of the primary data record
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	BKT_ADDR 		- address of the primary data bucket
!	    BKT$W_FREESPACE	- freespace offset pointer
!
!	IRAB			- address of IRAB
!	    IRB$V_RU_UPDATE	- if set, build new record in special format
!
! ROUTINE VALUE:
!
!	0 	- if the new record did not replace the old record
!	1 	- if the new record replaced the old record
!
! SIDE EFFECTS:
!
!	AP and keybuffer 5 are trashed.
!
!	If STATUS = 0, then the old primary data record has been deleted, the
!	    bucket's freespace offset pointer has been updated to reflect this,
!	    and keybuffer 3 contains the primary key of the record.
!	If STATUS = 1, then the old primary data record has been replaced by the
!	    new record, and any difference in size between the two is reflected
!	    both within the record's size field, and in the bucket's freespace
!	    offset pointer.
!
!--

    BEGIN

    EXTERNAL REGISTER
	R_BKT_ADDR_STR,
	R_IDX_DFN_STR,
	R_IFAB_STR,
	R_IRAB_STR,
	R_REC_ADDR_STR;

    GLOBAL REGISTER
	R_RAB,
	R_IMPURE,
	R_BDB;

    BUILTIN
	AP;

    LOCAL
	DIFFERENCE	: SIGNED,
	RECORD_OVHD,
	STATUS,
	OLD_REC_SIZE,
	OLD_REC_ADDR;

    ! Retrive the size of the old record.
    !
    BEGIN

    LOCAL
	REC_SIZE;

    RECORD_OVHD = RM$REC_OVHD(0; REC_SIZE);
    OLD_REC_SIZE = .REC_SIZE;
    OLD_REC_ADDR = .REC_ADDR + .RECORD_OVHD;
    END;
	
    ! If the key is compressed, save in key buffer 5 the key of the record
    ! that will be deleted, including the compression overhead.  This might
    ! be used by RM$EXPAND_KEYD later.
    !
    IF .IDX_DFN[IDX$V_KEY_COMPR]
    THEN
	RM$MOVE (.(.OLD_REC_ADDR)<0,8> + 2, .OLD_REC_ADDR, KEYBUF_ADDR(5));

    ! Figure out what the difference in records sizes is.
    !
    DIFFERENCE = .OLD_REC_SIZE - .NEW_REC_SIZE;

    ! If the record will grow in size as a result of being updated, setup
    ! so the old record can be removed entirely from the bucket and for
    ! the split of the primary data bucket in case it becomes necessary.
    !
    ! If the record will shrink in size by one byte as a result of being updated
    ! and the process is currently in a Recovery Unit, then also setup so that 
    ! the old record can be removed entirely from the bucket. In addition, set
    ! the state bit IRB$V_RU_UPDATE so that when this record gets built, it 
    ! will be built in the special format that is required.
    !
    IF  .DIFFERENCE LSS 0
	 OR
	(.IFAB[IFB$V_RUP]
		 AND
		.DIFFERENCE EQL 1)
    THEN
	BEGIN

	IF .IFAB[IFB$V_RUP]
	    AND
	   .DIFFERENCE EQL 1
	THEN
	    IRAB[IRB$V_RU_UPDATE] = 1;
	
	DIFFERENCE = .OLD_REC_ADDR + .OLD_REC_SIZE - .REC_ADDR;
	OLD_REC_ADDR = .REC_ADDR;

	! Get primary key value into keybuffer 3 for use by RM$PUT_UPD_SPL.
	!
	REC_ADDR = .IRAB[IRB$L_RBF];

	AP = 3;	
	RM$RECORD_KEY(KEYBUF_ADDR(3));

	STATUS = 0;
	REC_ADDR = .OLD_REC_ADDR;
	END

    ! The new record will be able to fit into the space currently occupied
    ! by the old record either because the records are the same size, or the
    ! new record is smaller than the old record.
    !
    ELSE
	BEGIN

	LOCAL
	    BUFFER;

	! Assume that the record will not be in special format and clear the
	! appropriate record control bit.
	!
	REC_ADDR[IRC$V_RU_UPDATE] = 0;

	! The new record is smaller then the old record, so fix the record size.
	!
	IF .DIFFERENCE NEQ 0
	THEN

	    ! If the process is not currently within a Recovery Unit or the
	    ! operation is not a RU ROLLBACK Recovery operation; or, if the
	    ! current operation is a RU ROLLBACK Recovery operation but the
	    ! record's size would only decrease by one byte, then just move
	    ! in the new size into the record overhead's size field.
	    !
	    IF 	NOT (.IFAB[IFB$V_RUP]
			 OR
			.IFAB[IFB$V_RU_RECVR])
		 OR
		(.IFAB[IFB$V_RU_RECVR]
			 AND
			.DIFFERENCE EQLU 1)
	    THEN
		(.OLD_REC_ADDR - IRC$C_DATSZFLD)<0, 16> = .NEW_REC_SIZE

	    ! If the process is currently within a Recovery Unit then leave the
	    ! record size field in the record overhead alone, and instead move
	    ! the new size into the last two bytes in the record's reserved 
	    ! space. Set the RU_UPDATE bit in the record's control byte to
	    ! indicate that the record is in a special format, and zero 
	    ! DIFFERENCE so that no space is reclaimed from the record.
	    !
	    ! This sequence is also done if the current operation is a RU 
	    ! ROLLBACK Recovery operation and the record shrinks by more than 
	    ! one byte.
	    !
	    ELSE
		BEGIN
		REC_ADDR[IRC$V_RU_UPDATE] = 1;
		DIFFERENCE = 0;
		(.OLD_REC_ADDR + .OLD_REC_SIZE 
			       - IRC$C_DATSZFLD)<0,16> = .NEW_REC_SIZE;
		END;

	! Move in the new record. Where the new record is moved in from is
	! prologue dependent.
	!
	IF .IFAB[IFB$B_PLG_VER] LSSU PLG$C_VER_3
	THEN
	    BUFFER = .IRAB[IRB$L_RBF]
	ELSE
	    BUFFER = .IRAB[IRB$L_RECBUF];

	OLD_REC_ADDR = RM$MOVE (.NEW_REC_SIZE, .BUFFER, .OLD_REC_ADDR);

	STATUS = 1;
	END;

    ! If the new record grew in size delete it from the bucket and fix up the
    ! bucket's freespace offset pointer. If the record shrunk in size, then 
    ! shuffle all the trailing records in the bucket to take up this available
    ! space and fix up the bucket's freespace offset pointer.
    !
    BEGIN

    LOCAL
	LENGTH;

    IF .DIFFERENCE NEQ 0
    THEN
	BEGIN

	BKT_ADDR[BKT$W_FREESPACE] = .BKT_ADDR[BKT$W_FREESPACE] 
				     - .DIFFERENCE<0, 16>;

	LENGTH = .BKT_ADDR[BKT$W_FREESPACE] - (.OLD_REC_ADDR 
					        - .BKT_ADDR)<0, 16>;

	IF .LENGTH GTR 0
	THEN
	    RM$MOVE (.LENGTH, (.OLD_REC_ADDR + .DIFFERENCE), .OLD_REC_ADDR);

	END;

    ! If STATUS is 0, then the record grew in size, it has been deleted from
    ! the bucket, and a regular record insert must be done. If the key is 
    ! compressed, the key of the following record (if there is one) must be 
    ! expanded to reflect the deleted record.
    !
    IF  .IDX_DFN[IDX$V_KEY_COMPR]
	 AND 
	.STATUS EQLU 0
	 AND
	.LENGTH GTR 0
	 AND 
	NOT .REC_ADDR[IRC$V_RRV]
    THEN
	RM$EXPAND_KEYD (KEYBUF_ADDR(5), .REC_ADDR + .RECORD_OVHD);

    END;

    RETURN .STATUS;

    END;


%SBTTL	'RM$UPDATE_SCAN'
ROUTINE RM$UPDATE_SCAN : RL$UPDATE_SCAN =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Compare the old and new records to determine which new keys are to be
!	inserted and which old keys are to be deleted. If the file is a prologue
!	3 file, then unpack the primary data record into the old record buffer,
!	and if there are old alternate keys to be deleted and the file is a
!	prologue 1 or 2 file, move the primary data record into the old record
!	buffer as well.
!
! CALLING SEQUENCE:
!
!	RM$UPDATE_SCAN()
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!
!	IDX_DFN 		- address of the primary key index descriptor
!	    IDX$V_CHGKEYS	- if set, keys are allowed to change
!	    IDX$B_DESC_NO	- descriptor number
!	    IDX$B_KEYSZ		- size of key 
!	    IDX$W_MINRECSZ	- minimum size of record containing this key
!
!	IFAB			- address of IFAB
!	    IFB$B_PLG_VER	- prologue version of file
!
!	IRAB			- address of IRAB
!	    IRB$B_CUR_KREF	- current NRP key of reference
!	    IRB$L_OLDBUF	- address of old record buffer
!	    IRB$L_RBF		- address of new record buffer
!	    IRB$W_RSZ		- size of new record
!	    IRB$V_UPDATE_IF	- if set, $PUT converted into an $UPDATE
!	    IRB$L_UPDBUF	- address of update buffer
!
!	REC_ADDR 		- address of primary data record
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	IRAB			- address of IRAB
!	    IRB$V_FIND_LAST	- set to 0
!
! ROUTINE VALUE:
!
!	CHG - if primary key changes key value at all, or any alternate key
!		changes values and CHGKEYS not set
!	SUC - otherwise
!
! SIDE EFFECTS:
!
!	AP is trashed.
!	Each byte in the update buffer corresponds to an index with:
!	    INS_NEW set if a new key value is to be inserted
!	    OLD_DEL set if the old key value requires deletion.
!	The same flags for the primary key byte indicate whether any
!	    alternate keys require insertion or deletion at all.
!	If the file is a prologue 3 file then the old record has been unpacked
!	    into the old record buffer.
!	If the file is a prologue 1 or 2 file, and there are old altenate keys
!	    to be deleted then the old record has been moved into the old record
!	    buffer.
!
!--

    BEGIN

    EXTERNAL REGISTER
	R_IDX_DFN_STR,
	R_IFAB_STR,
	R_IMPURE,
	R_IRAB_STR,
	R_RAB,
	R_REC_ADDR_STR;

    BUILTIN
	AP;

    LOCAL
	OLD_REC_ADDR,
	OLD_REC_SIZE	: WORD;

    ! Retrieve the size of the old record, as it is in the bucket, and set
    ! up a pointer to the old data record itself.
    !
    BEGIN

    LOCAL
	REC_SIZE;

    OLD_REC_ADDR = .REC_ADDR + RM$REC_OVHD(0; REC_SIZE);
    OLD_REC_SIZE = .REC_SIZE;
    END;

    ! If the file is a prologue 3 file, then the old record must be unpacked
    ! into the old record buffer. Reset the pointer to the data portion of the
    ! old record so that it points into the old record buffer.
    !
    IF .IFAB[IFB$B_PLG_VER] EQLU PLG$C_VER_3
    THEN
	BEGIN

	GLOBAL REGISTER
	    R_BKT_ADDR;

	LOCAL
	    SAVE_REC_ADDR : REF BBLOCK;

	SAVE_REC_ADDR = .REC_ADDR;
	REC_ADDR = .OLD_REC_ADDR;
	OLD_REC_ADDR = .IRAB[IRB$L_OLDBUF] + 2;

	! If this record is marked RU_UPDATE then the last two bytes of the
	! reserved space of the record contain the actual size of the record.
	!
	IF .SAVE_REC_ADDR[IRC$V_RU_UPDATE]
	THEN
	    OLD_REC_SIZE = .(.REC_ADDR + .OLD_REC_SIZE - IRC$C_DATSZFLD)<0,16>;

	! If this operation is a $PUT converted into an $UPDATE, then the 
	! primary key of the old record maybe found in keybuffer 2. Likewise, 
	! if this is a $UPDATE and RMS positioned to the record by means of the
	! primary key of reference although not by a $FIND, then the primary 
	! key of the old record maybe found in keybuffer 1. Otherwise, a bucket 
	! scan must be done to re-expand the primary key.
	!
	IF .IRAB[IRB$V_UPDATE_IF]
	THEN
	    AP = 2
	ELSE
	    IF  .IRAB[IRB$B_CUR_KREF] EQLU 0
		 AND
		NOT .IRAB[IRB$V_FIND_LAST]
	    THEN
		AP = 1
	    ELSE
		AP = 0;

	OLD_REC_SIZE = RM$UNPACK_REC (.OLD_REC_ADDR, .OLD_REC_SIZE);
	(.IRAB[IRB$L_OLDBUF])<0,16> = .OLD_REC_SIZE;
	REC_ADDR = .SAVE_REC_ADDR
	END;

    IRAB[IRB$V_FIND_LAST] = 0;

    ! If the primary key has changed, return an error. This comparison does
    ! not have to be done if the operation is an UPDATE_IF.
    !
    IF NOT .IRAB[IRB$V_UPDATE_IF]
    THEN
	BEGIN
	AP = 0;

	IF RM$COMPARE_KEY (.OLD_REC_ADDR, 
			   .IRAB[IRB$L_RBF], 
			   .IDX_DFN[IDX$B_KEYSZ])
	THEN
	    RETURN RMSERR (CHG);
	END;

    ! The INS_NEW and OLD_DEL flags for the first byte of the update buffer
    ! (which would be for key 0) are used to indicate whether any inserts or 
    ! deletes are to be done at all. Zero these.
    !
    BBLOCK[.IRAB[IRB$L_UPDBUF], UPD$B_FLAGS] = 0;

    ! Process all of the alternate keys determing whether the alternate key has
    ! changed, the old key must be deleted, and a new key must be inserted.
    !
    WHILE RM$GET_NEXT_KEY()
    DO
	BEGIN

	LOCAL
	    UPD_BUF_ADDR	: REF BBLOCK;

	! Point to the update buffer associated with this index.
	!
	UPD_BUF_ADDR = .IRAB[IRB$L_UPDBUF] + .IDX_DFN[IDX$B_DESC_NO];
	UPD_BUF_ADDR[UPD$B_FLAGS] = 0;

	AP = 0;	

	! Set the flag INS_NEW for this key of reference if the key is present 
	! in the new record, disregardling for the time being whether the key 
	! is present in the old record and whether the two keys are the same.
	!
	IF .IRAB[IRB$W_RSZ] GEQU .IDX_DFN[IDX$W_MINRECSZ]
	    AND
	   RM$NULLKEY (.IRAB[IRB$L_RBF])
	THEN
	    UPD_BUF_ADDR[UPD$V_INS_NEW] = 1;

	! Determine whether this same key was present in the old record.
	!
	IF .OLD_REC_SIZE GEQU .IDX_DFN[IDX$W_MINRECSZ]
	    AND
	   RM$NULLKEY (.OLD_REC_ADDR)
	THEN

	    ! If the key was present in the old record but is not present in
	    ! the new record then flag that the old key for this key of 
	    ! reference should be deleted.
	    !
	    IF NOT .UPD_BUF_ADDR[UPD$V_INS_NEW]
	    THEN
		UPD_BUF_ADDR[UPD$V_OLD_DEL] = 1

	    ! If the key is present in both records then compare the two keys.
	    !
	    ELSE
		BEGIN
		AP = 0;

		! If there are keys present in both records but they are
		! different then flag that there is a new key to be inserted
		! (already has been done) and an old key to be deleted for
		! this key of reference.
		!
		IF RM$COMPARE_KEY (.OLD_REC_ADDR, 
				   .IRAB[IRB$L_RBF],
				   .IDX_DFN[IDX$B_KEYSZ])
		THEN
		    UPD_BUF_ADDR[UPD$V_OLD_DEL] = 1

		! If there are keys present in both records and they are 
		! identical, then there is no need to insert or delete any
		! keys for this key of reference.
		!
		ELSE
		    UPD_BUF_ADDR[UPD$V_INS_NEW] = 0;
		END;

	! If the keys have changed between the two records, and this key of
	! reference does not allow keys to change, return an error.
	!
	IF .UPD_BUF_ADDR[UPD$B_FLAGS] NEQU 0
	    AND
	   NOT .IDX_DFN[IDX$V_CHGKEYS]
	THEN
	    RETURN RMSERR (CHG);

	! Summarize the key 0 flags to this point in the key-by-key comparison.
	!
	BBLOCK[.IRAB[IRB$L_UPDBUF], UPD$B_FLAGS] =
			.BBLOCK[.IRAB[IRB$L_UPDBUF], UPD$B_FLAGS] 
			 OR
			.UPD_BUF_ADDR[UPD$B_FLAGS]

	END;

    ! If there are any old keys which will have to be deleted, and this is a
    ! prologue 1 or 2 file, then save the old record in the old record buffer.
    !
    IF  .BBLOCK[.IRAB[IRB$L_UPDBUF], UPD$V_OLD_DEL]
	 AND
	.IFAB[IFB$B_PLG_VER] LSSU PLG$C_VER_3
    THEN
	BEGIN

	GLOBAL REGISTER
	    R_BDB;

	RM$MOVE (.OLD_REC_SIZE, .OLD_REC_ADDR, .IRAB[IRB$L_OLDBUF] + 2);
	(.IRAB[IRB$L_OLDBUF])<0,16> = .OLD_REC_SIZE;
	END;

    ! Reset to primary key descriptor and return success.
    !
    RETURN RM$KEY_DESC(0)

    END;


%SBTTL	'RM$UPDATE3B'
GLOBAL ROUTINE RM$UPDATE3B : RL$RABREG_67 =

!++
!
! FUNCTIONAL DESCRIPTION:
!
! 	High level update routine, using the following update algorithm:
!
!	1. If the operation is an $UPDATE (and not a converted $PUT), then the
!	   current primary data record is retrieved using its RFA saved as part
!	   of the next record context.
!
!	2. Record sizes, null key status, and comparisons between the new and
!	   old versions of the current record are used to set flags in the 
!	   update buffer to determine which new secondary key values require 
!	   insertion and which old secondary key values require deletion. At 
!	   same time illegal key changes are detected.
!
!	3. If the file is a prologue 3 file, then the old version of the current
!	   primary data record is saved in expanded format within the old record
!	   buffer. If the file is a prologue 1 or 2 file, and there are old 
!	   secondary keys to be deleted, then the old version of the current
!	   record will also be moved into the old record buffer.
!
!	4. New secondary key values are inserted. This involves:
!		a. Releasing the primary data bucket containing the current 
!		   primary data record.
!		b. Inserting the new secondary keys requiring insertion.
!		c. Reclaiming the primary data bucket containing the current
!		   primary data record.
!
!	   If the file is being RU ROLLBACK Recovered, then as the new SIDRs
!	   already exists in the file they are un-deleted instead of inserted.
!
!	5. The new version of the current record is inserted in place of the old
!	   version, and any primary data bucket splits that are required in 
!	   order to make room for the new record are performed as is all 
!	   required updating of the primary index. 
!
!	   If the file is being RU Journalled and a Recovery Unit is in 
!	   progress, then the record is not allowed to shrink in size, and if 
!	   necessary even increases in size by one byte to reserve the space 
!	   the record currently occupies in case the Recovery Unit is aborted.
!
!	6. Old secondary key values requiring deletion are deleted. The keys
!	   themselves are extracted from the old version of the current primary
!	   data record which was saved earlier in the old record buffer. 
!
!	   If the file is being RU Journalled and a Recovery Unit is in 
!	   progress, then the old SIDRs are just marked RU_DELETE and no space 
!	   is reclaimed.
!
! CALLING SEQUENCE:
!
!	BSBW RM$UPDATE3B()
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!
!	IDX_DFN				- primary key index descriptor
!	    IDX$B_DATBKTYP		- primary data bucket type
!	    IDX$B_KEYSZ			- size of primary key
!
!	IFAB				- address of IFAB
!	    IFB$B_PLG_VER		- prologue version of file
!	    IFB$B_RFMORG		- format of records
!	    IFB$V_RUP			- if set, Recovery Unit in progress
!	    IFB$V_RU_RECVR		- if set, RU ROLLBACK in progress
!
!	IRAB				- address of IRAB
!	    IRB$V_ABOVELCKD		- if set, above level bucket is locked
!	    IRB$L_CURBDB		- address of primary data bucket's BDB
!	    IRB$B_CUR_KREF		- current NRP key of reference
!	    IRB$L_LOCK_BDB		- address of above level bucket's BDB
!	    IRB$L_OLDBUF		- address of old record buffer
!	    IRB$W_PUTUP_ID		- ID of current primary data record
!	    IRB$L_PUTUPD_VBN		- VBN of current primary data record
!	    IRB$W_RSZ			- size of updated record
!	    IRB$V_UPDATE		- if set, $UPDATE requested
!	    IRB$V_UPDATE_IF		- if set, converted $PUT requested
!	    IRB$L_UPDBUF		- address of update buffer
!
!	REC_ADDR			- address of current primary data record
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	IRAB				- address of IRAB
!	    IRB$B_CACHEFLGS		- CSH$V_LOCK maybe set
!	    IRB$V_IDX_ERR		- if set, error updating index
!	    IRB$W_LAST_ID		- ID of record's last known position
!	    IRB$L_LAST_VBN		- VBN of record's last known position
!	    IRB$L_LST_NCMP		- last zero-front compressed key record
!	    IRB$W_SRCHFLAGS		- IRB$V_POSINSERT maybe set 
!	    IRB$B_STOPLEVEL		- maybe set either to 0 or 1
!
! ROUTINE VALUE:
!
!	See errors from:
!
!	RM$FIND_BY_RFA
!	RM$FIND_BY_RRV
!	RM$INS_ALL_SIDR
!	RM$INSS_OR_IDX
!	RM$PUT_UPD_CHKS
!	RM$PUT_UPD_FIN
!	RM$PUT_UPD_SPL
!	RM$RLSBKT
!	RM$RU_JOURNAL3
!	RM$UPDATE_SCAN
!	RM$UPDELCOM
!
! SIDE EFFECTS:
!	NONE
!
!--

    BEGIN

    BUILTIN
	AP,
	TESTBITSS,
	TESTBITCS;

    LABEL
	GETBACK;

    EXTERNAL REGISTER
	COMMON_RAB_STR,
	R_IDX_DFN_STR,
	R_REC_ADDR_STR;

    GLOBAL REGISTER
	COMMON_IO_STR;

    ! This routine maybe called as the result of a $PUT converted into an 
    ! $UPDATE, or as the result of an $UPDATE. In the former case, this routine
    ! would have been called with the primary data bucket locked, and RMS
    ! positioned to the record to be updated so there would be no need to 
    ! perform this positioning. In the case of a straight $UPDATE, it would be
    ! necessary to perform this positioning. To differentiate between the two
    ! cases, the IRAB bit IRB$V_UPDATE is set on $UPDATEs but cleared on 
    ! converted $PUTs on entry to this routine.
    !
    ! On any errors from this point on, the routine RM$CLEAN_BDB will be called
    ! to make sure any locked buckets, including the bucket which might have
    ! been locked during lockabove optimization, are realeased.
    !
    IF TESTBITSS (IRAB[IRB$V_UPDATE])
    THEN
	BEGIN

	! This is an $UPDATE so make sure IRB$V_ABOVELCKD is clear as there 
	! cannot be any bucket locked at this time. Position to the record to 
	! be updated.
	!
	IRAB[IRB$V_ABOVELCKD] = 0;

	RETURN_ON_ERROR (RM$UPDDELCOM());
	END;

    ! Perform some common checks and set up the primary key descriptor. These
    ! checks have already been performed if this is a RU ROLLBACK Recovery
    ! operation.
    !
    IF NOT .IFAB[IFB$V_RU_RECVR]
    THEN
	RETURN_ON_ERROR (RM$PUT_UPD_CHKS(), RM$CLEAN_BDB());

    ! Set up the update buffer indicating which alternate keys in the record to
    ! be updated will need inserting and which will need deleting.
    !
    RETURN_ON_ERROR (RM$UPDATE_SCAN(), RM$CLEAN_BDB());

    IRAB[IRB$W_LAST_ID] = IRC$_ID(REC_ADDR);

    ! Before any permanent modification to the file takes place, RU Journal this
    ! operation if RU Journalling is enabled and the process is within a 
    ! Recovery Unit.
    !
    IF .IFAB[IFB$V_RUP]
    THEN
	BEGIN

	LOCAL
	    SAVE_REC_ADDR;

	SAVE_REC_ADDR = .REC_ADDR;
	REC_ADDR = .IRAB[IRB$L_OLDBUF] + 2;

	RETURN_ON_ERROR (RM$RU_JOURNAL3 (RJR$_UPDATE,
					 .IRAB[IRB$L_PUTUP_VBN],
					 .IRAB[IRB$W_PUTUP_ID],
					 .(.IRAB[IRB$L_OLDBUF])<0,16>),
			 RM$CLEAN_BDB());

	REC_ADDR = .SAVE_REC_ADDR;
	END;

    ! If any new alternate keys will have to be inserted as a result of this
    ! $UPDATE, then insert them at this time. To do so, first release the
    ! primary data bucket containing the old record, then insert all the 
    ! alternate keys which need to be inserted, and finally re-position back to
    ! the old primary data record.
    !
    IF .BBLOCK[.IRAB[IRB$L_UPDBUF], UPD$V_INS_NEW]
    THEN

GETBACK:
	BEGIN
	
	! If RMS has performed lockabove optimization to lock the bucket from 
	! the level above, then release this bucket whose BDB has been saved in 
	! IRB$L_LOCK_BDB. This is because SIDR inserts will also try to perform 
	! lockabove optimization.
	!
	IF TESTBITSC (IRAB[IRB$V_ABOVELCKD])
	THEN
	    RELEASE (IRAB[IRB$L_LOCK_BDB]);

	! Release the primary data bucket containing the old record. Before the
	! bucket is released, the permanence bit is set so that RMS will 
	! attempt to keep this bucket in the cache (it will eventually try to 
	! re-position back to the old data record). The setting of the 
	! permanence bit here should not ruin the setting of permanence for
	! alternate index root buckets with extra buffers because the bit 
	! will be cleared when this bucket is reaccessed.
	!
	BDB = .IRAB[IRB$L_CURBDB];
	IRAB[IRB$L_CURBDB] = 0;

	IRAB[IRB$L_LAST_VBN] = .BDB[BDB$L_VBN];
	BDB[BDB$V_PRM] = 1;
	RM$RLSBKT(0);

	! If this is not a RU ROLLBACK Recovery operation then insert all the
	! alternate keys required by the new record.
	!
	IF NOT .IFAB[IFB$V_RU_RECVR]
	THEN
	    RETURN_ON_ERROR (RM$INS_ALL_SIDR())

	! If this is a RU ROLLBACK Recovery operation then it is not necessary
	! to insert any new alternate keys since they already exist in the file.
	! It is only necessary to position to and un-delete them.
	!
	ELSE
	    BEGIN

	    ! Signal that the SIDRs positioned to are to be un-deleted, and 
	    ! position REC_ADDR to the new record so that the alternate keys
	    ! maybe extracted to be used in the positioning.
	    !
	    IRAB[IRB$V_RU_UNDEL] = 1;
	    REC_ADDR = .IRAB[IRB$L_RBF];

	    ! Continue until all the alternate keys of the new record have been
	    ! un-deleted.
	    !
	    WHILE RM$GET_NEXT_KEY()
	    DO

		! If there is a new SIDR to be un-deleted for this key of
		! reference then do so.
		!
		IF .BBLOCK[.IRAB[IRB$L_UPDBUF] + .IDX_DFN[IDX$B_DESC_NO], 
			   UPD$V_INS_NEW]
		THEN
		    BEGIN

		    ! Extract the alternate key from the new record, and 
		    ! un-delete the corresponding SIDR.
		    !
		    AP = 3;
		    RM$RECORD_KEY (KEYBUF_ADDR(2));
		    RM$DELETE_SIDR();
		    END;

	    IRAB[IRB$V_RU_UNDEL] = 0;
	    END;

	! Retrieve the primary key descriptor.
	!
	RM$KEY_DESC(0);

	! Clear IRB$V_ABOVELCKD as SIDR inserts may have left this bit set.
	!
	IRAB[IRB$V_ABOVELCKD] = 0;

	! Position back to the current primary data record so it maybe changed.
	!
	BEGIN

	LOCAL
	    STATUS;

	! First, try to position back to the record using its last known 
	! location. This should succeed unless the bucket containing the
	! current record has split, and the record has moved. The bit 
	! IRB$V_NORLS_RNF is set, so that RMS can always clear the BDB's 
	! permancence bit (set above before the bucket was released) regardless
	! of whether it was successful at position to the current record or not.
	! 
	IRAB[IRB$B_CACHEFLGS] = CSH$M_LOCK;
	IRAB[IRB$V_NORLS_RNF] = 1;

	AP = .IRAB[IRB$W_LAST_ID];
	STATUS = RM$FIND_BY_RFA (.IRAB[IRB$L_LAST_VBN]);

	! If RMS was able to find the current record in its last know location
	! verify, by comparing RFAs, that the record positioned to is in fact
	! the current record. If so, clear the BDB's permancance bit and 
	! proceed with the update; otherwise, a second attempt will made to 
	! position to the current record utilizing its RFA.
	!
	IF .STATUS
	THEN
	    BEGIN

	    AP = 3;
	    IF .IRAB[IRB$W_PUTUP_ID] EQL RM$RECORD_ID()
	    THEN
		IF .IRAB[IRB$L_PUTUP_VBN] EQL RM$RECORD_VBN()
		THEN
		    BEGIN
		    BBLOCK[.IRAB[IRB$L_CURBDB], BDB$V_PRM] = 0;
		    LEAVE GETBACK;
		    END;
	    END

	! If RMS was unable to position to the current primary data record in 
	! its last known location because of some obscure I/O error, return 
	! that error; otherwise, a second attempt will be made to position to 
	! the current record utilizing its RFA.
	! 
	ELSE
	    IF NOT (.STATUS<0,16> EQL RMSERR(RNF)
				or
		    .STATUS<0,16> EQL RMSERR(DEL))
	    THEN
		BEGIN
		RM$CLEAN_BDB();
		RM$PUTUPD_ERROR();
		RETURN .STATUS;
		END;
	END;

	! RMS was unable to locate the current primary data record in its
	! last known location although it was able to access the primary data
	! bucket in which it was last found. After clearing the permanence bit
	! in the BDB for this primary data bucket and releasing the bucket, RMS
	! attempts to position to the current primary data record by utilizing
	! the RFA of the current record.
	!
	BDB = .IRAB[IRB$L_CURBDB];
	BDB[BDB$V_PRM] = 0;
	RM$RLSBKT(0);
	IRAB[IRB$B_CACHEFLGS] = CSH$M_LOCK;

	RETURN_ON_ERROR 
	    (RM$FIND_BY_RRV (.IRAB[IRB$L_PUTUP_VBN], .IRAB[IRB$W_PUTUP_ID], 0),
	    	BEGIN
		RM$CLEAN_BDB();
		RM$PUTUPD_ERROR();
		END);

	END;		! of block GETBACK

    ! Having re-positioned to the current primary data record, RMS now replaces
    ! the old version of the record with the new version performing any primary
    ! data bucket splits and primary index updates that are required.
    !
    BEGIN

    LOCAL
	STATUS,
	RECORD_SIZE,
	RECOVH_SIZE;

    ! Retrieve the address of the primary data bucket containing the current
    ! primary data record.
    !
    BDB = .IRAB[IRB$L_CURBDB];
    BKT_ADDR = .BDB[BDB$L_ADDR];

    ! Determine the number of bytes the new version of the record will take up
    ! in the bucket, and the number of bytes the new version of the record will
    ! take up in the bucket including record overhead. Both of these quantites 
    ! are prologue dependent, and the latter also depends upon the attributes 
    ! of the records in the file.
    !	Also, reevaluate the record id for the record to be updated.  It may
    ! easily have been displaced (as a result of a split, for example) since
    ! IRB$W_LAST_ID was last saved.  We need this id in case the new record
    ! will be larger than the old one, causing a delete + insert operation
    ! to be performed.  If that happens, we need to use the same record id
    ! for the newly inserted record to keep the same RFA.  
    ! 
    !
    IF .IFAB[IFB$B_PLG_VER] LSSU PLG$C_VER_3
    THEN
	BEGIN
	RECORD_SIZE = .IRAB[IRB$W_RSZ];

	RECOVH_SIZE = .RECORD_SIZE + IRC$C_FIXOVHDSZ;
	IF .IFAB[IFB$B_RFMORG] NEQU FAB$C_FIX
	THEN
	    RECOVH_SIZE = .RECOVH_SIZE + IRC$C_DATSZFLD;
	IRAB[IRB$W_LAST_ID] = .REC_ADDR[IRC$B_ID];
	END
    ELSE
	BEGIN

	! The records in prologue 3 primary data buckets are packed. Record
	! packing includes key compression if it is enabled, and to insure that
	! the compression is done correctly, IRB$L_LST_NCMP is set to the last
	! known record with a zero front compressed primary key in the current
	! bucket.
	!
	IRAB[IRB$L_LST_NCMP] = .BKT_ADDR + BKT$C_OVERHDSZ;
	RECORD_SIZE = RM$PACK_REC();

	RECOVH_SIZE = .RECORD_SIZE + IRC$C_FIXOVHSZ3;
	IF .IFAB[IFB$B_RFMORG] NEQU FAB$C_FIX
	    OR 
	   (.IFAB[IFB$B_RFMORG] EQLU FAB$C_FIX
		 AND 
		.IDX_DFN[IDX$B_DATBKTYP] NEQU IDX$C_NCMPNCMP)
	THEN
	    RECOVH_SIZE = .RECOVH_SIZE + IRC$C_DATSZFLD;
	IRAB[IRB$W_LAST_ID] = .REC_ADDR[IRC$W_ID];
	END;

    ! Attempt to replace the old version of the current primary data record with
    ! the new version without splitting the primary data bucket. The routine
    ! RM$REPLACE will replace the old version with the new version if the latter
    ! is the same size or smaller than the former. Failing that, it will delete
    ! the old version of the primary data record, and RM$INSERT_UDR will try and
    ! insert the new version into the primary data bucket.
    ! 
    IF NOT (STATUS = RM$REPLACE (.RECORD_SIZE))
    THEN
	BEGIN

	! If the size of the new record is smaller than the old record by one
	! byte and a specially formatted record must be built because the
	! process is currently within a Recovery Unit and the file is RU 
	! Journalled, then increase the size of the record by two bytes to
	! allow for the specially formatted record to contain two record size
	! fields. 
	!
	IF .IRAB[IRB$V_RU_UPDATE]
	THEN
	    RECOVH_SIZE = .RECOVH_SIZE + IRC$C_DATSZFLD;

	STATUS = RM$INSERT_UDR (RECOVH_SIZE);
	END;

    ! If RMS is successful at replacing the old version of the current primary
    ! data record with the new version without causing a bucket split, then the
    ! modified primary data bucket maybe marked dirty and released.
    !
    IF .STATUS
    THEN
	BEGIN
	BDB[BDB$V_DRT] = 1;
	IRAB[IRB$L_CURBDB] = 0;

	RETURN_ON_ERROR (RM$RLSBKT (0),
					BEGIN
					RM$CLEAN_BDB();
					RM$PUTUPD_ERROR();
					END);

	! If an above level bucket was locked due to lockabove optimization, 
	! then release it at this time.
	!
	IF (BDB = .IRAB[IRB$L_LOCK_BDB]) NEQU 0
	THEN
	    BEGIN
	    RM$RLSBKT(0);
	    IRAB[IRB$L_LOCK_BDB] = 0;
	    END;
	END

	! RMS was not able to replace the old version of the current primary
	! data record with the new version without splitting the primary data
	! bucket. Therefore, split the primary data bucket inserting the new 
	! version of the current primary data record, and performing any index 
	! updates that are required.
	!
    ELSE
	BEGIN

	! Perform the split of the primary data level bucket and insert the new
	! version of the current primary data record.
	!
	IRAB[IRB$B_SPL_BITS] = 0;
	IRAB[IRB$B_KEYSZ] = .IDX_DFN[IDX$B_KEYSZ];

	RETURN_ON_ERROR (RM$PUT_UPD_SPL(.RECOVH_SIZE),
			BEGIN
			RM$CLEAN_BDB();
			RM$PUTUPD_ERROR();
			END);

	! Retrieve the BDB for the primary data bucket that has split, which is
	! still locked by this stream.
	!
	BDB = .IRAB[IRB$L_CURBDB];

	! If an index update is not required, just release the original primary 
	! data bucket. The routine RM$PUT_UPD_SPL will clear the bit 
	! IRB$V_UPDATE if an index update is not required following the primary 
	! data bucket split, and set it if an index update is required.
	!
	IF TESTBITCS(IRAB[IRB$V_UPDATE])
	THEN
	    BEGIN

	    IRAB[IRB$L_CURBDB] = 0;

	    RETURN_ON_ERROR (RM$RLSBKT(0), BEGIN
					   RM$CLEAN_BDB();
					   RM$PUTUPD_ERROR();
					   END);

	    ! If an above level bucket was locked due to lockabove optimization,
	    ! then release it at this time.
	    !
	    IF (BDB = .IRAB[IRB$L_LOCK_BDB]) NEQ 0
	    THEN
		BEGIN
		RM$RLSBKT(0);
		IRAB[IRB$L_LOCK_BDB] = 0;
		END;
	    END

	! The split of the primary data bucket requires updating of the primary
	! index. Perform the update at this time.
	!
	ELSE
	    BEGIN

	    IRAB[IRB$B_STOPLEVEL] = 1;
	    IRAB[IRB$W_SRCHFLAGS] = IRB$M_POSINSERT;

	    IF NOT (RAB[RAB$L_STV] = RM$INSS_OR_IDX())
	    THEN
		IRAB[IRB$V_IDX_ERR] = 1;
	    END
	END;
    END;

    ! If there are alternate keys from the old record to be deleted, then the
    ! old record has been saved in the IRB$L_OLDBUF record buffer. To delete
    ! the old SIDRs, the alternate key of each SIDR to be deleted is in turn 
    ! extracted into keybuffer 2 and the SIDR deletion routine is called.
    !
    IF .BBLOCK[.IRAB[IRB$L_UPDBUF],UPD$V_OLD_DEL]
    THEN
	BEGIN

	REC_ADDR = .IRAB[IRB$L_OLDBUF] + 2;

	! If the current operation is an UPDATE_IF, then the current record may
	! not be the record being updated. Yet, the routine RM$DELETE_SIDR 
	! operates only on the current record; therefore, setup the record 
	! being updated as the current record. Then is no need to restore these
	! fields because they will be zeroed out at the conclusion of the 
	! operation anyway.
	!
	IF .IRAB[IRB$V_UPDATE_IF]
	THEN
	    BEGIN
	    IRAB[IRB$L_UDR_VBN] = .IRAB[IRB$L_PUTUP_VBN];
	    IRAB[IRB$W_UDR_ID]  = .IRAB[IRB$W_PUTUP_ID];
	    END;

	! If this file is being Recovery Unit Journalled and the process is
	! currently within a recovery unit the set the IRB$V_RU_DELETE state
	! bit so that the SIDRs being deleted are only marked RU_DELETE and no
	! space is reclaimed.
	!
	IF .IFAB[IFB$V_RUP]
	THEN
	    IRAB[IRB$V_RU_DELETE] = 1;

	! Loop through the index descriptors deleting those SIDRs that need to
	! be deleted.
	!
	WHILE RM$GET_NEXT_KEY()
	DO

	    ! If this index has a SIDR which needs to be deleted, then delete 
	    ! it.
	    !
	    IF .BBLOCK[.IRAB[IRB$L_UPDBUF] + .IDX_DFN[IDX$B_DESC_NO],
			UPD$V_OLD_DEL]
	    THEN
		BEGIN

		! Extract the alternate key from the unpacked version of the
		! old data record, and delete the corresponding SIDR.
		!
		AP = 3;
		RM$RECORD_KEY (KEYBUF_ADDR(2));
		RM$DELETE_SIDR();
		END;

	IRAB[IRB$V_RU_DELETE] = 0;
	END;

    ! Having successfully completed the $UPDATE, finish up and return success.
    ! 
    RETURN RM$PUT_UPD_FIN()

    END;

END

ELUDOM
