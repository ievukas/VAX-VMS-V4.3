	.TITLE	DESCRVAL - TOKEN TABLE MANIPULATION ROUTINES
	.IDENT	'V04-000'
 
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; D. N. CUTLER 24-APR-77
;
; PARSE TABLE DESCRIPTOR VALUE MANIPULATION ROUTINES
;
; MODIFIED BY:
;
;	V03-004	PCG0004		Peter George		27-May-1983
;		Readd DCL$SORT_TOKENS.
;
;	V03-003	PCG0003		Peter George		06-May-1983
;		Move DCL$SORT_TOKENS to PARSENT.
;
;	V03-002	PCG0002		Peter George		30-Apr-1983
;		Add DCL$SORT_TOKENS.
;
;	V03-001	PCG0001		Peter George		01-Mar-1983
;		Add DCL$GETNVAL.
;---

;
; MACRO LIBRARY CALLS
;
 
	WRKDEF				;DEFINE COMMAND WORK AREA
	PTRDEF				;DEFINE TOKEN DESCRIPTOR

	.PSECT	DCL$ZCODE,BYTE,RD,NOWRT

	.SBTTL	GET RESULT PARSE DESCRIPTOR VALUES
;+
; DCL$GETDVAL - GET RESULT PARSE DESCRIPTOR VALUES
;
; THIS ROUTINE IS CALLED TO OBTAIN THE VALUES FROM THE NEXT DESCRIPTOR IN
; THE RESULT PARSE TABLE.
;
; INPUTS:
;
;	WRK_L_RSLNXT = NEXT TOKEN DESCRIPTOR TO PROCESS
;
; OUTPUTS:
;
;	R0 LOW BIT CLEAR INDICATES PARSE DESCRIPTOR TABLE IS EMPTY.
;
;	R0 LOW BIT SET INDICATES NEXT PARSE DESCRIPTOR HAS BEEN OBTAINED
;		WITH:
;
;	R1 = VALUE FIELD OF DESCRIPTOR.
;	R2 = ADDRESS OF ITEM IN COMMAND BUFFER.
;	R3 = FLAGS FIELD OF DESCRIPTOR.
;	R4 = FIELD TERMINATOR CLASS NUMBER.
;	R5 = TYPE OF ENTRY.
;-
 
DCL$GETDVAL::				;GET RESULT PARSE DESCRIPTOR VALUES
	CLRL	R0			;ASSUME TABLE IS EMPTY
	MOVL	WRK_L_RSLNXT(R10),R1	;GET ADDRESS OF NEXT TOKEN DESCRIPTOR
	CMPL	R1,WRK_L_RSLEND(R10)	;ANY MORE ENTRIES IN TABLE?
	BGEQU	10$			;IF GEQU NO
	ADDL	#PTR_C_LENGTH,WRK_L_RSLNXT(R10)	;POINT TO NEXT DESCRIPTOR IN TABLE
	EXTZV	#PTR_V_OFFSET,#PTR_S_OFFSET,- ;EXTRACT OFFSET TO ITEM
		PTR_L_DESCR(R1),R2	;
	MOVAB	WRK_G_BUFFER(R10)[R2],R2 ;CALCULATE ACTUAL ITEM ADDRESS
	EXTZV	#PTR_V_FLAGS,#PTR_S_FLAGS,- ;EXTRACT FLAGS
		PTR_L_DESCR(R1),R3	;
	EXTZV	#PTR_V_TERM,#PTR_S_TERM,- ;EXTRACT TERMINATOR CLASS
		PTR_L_DESCR(R1),R4	;
	EXTZV	#PTR_V_TYPE,#PTR_S_TYPE,- ;EXTRACT ITEM TYPE
		PTR_L_DESCR(R1),R5	;
	EXTZV	#PTR_V_VALUE,#PTR_S_VALUE,- ;EXTRACT VALUE
		PTR_L_DESCR(R1),R1	;
	INCL	R0			;INDICATE NEXT DESCRIPTOR OBTAINED
10$:	RSB				;
 

	.SBTTL	GET KEYWORD NUMBER
;+
; DCL$GETNVAL - GET KEYWORD NUMBER
;
; THIS ROUTINE IS CALLED TO OBTAIN THE KEYWORD NUMBER FROM THE CURRENT 
; DESCRIPTOR IN THE RESULT PARSE TABLE.
;
; INPUTS:
;
;	WRK_L_RSLNXT = NEXT TOKEN DESCRIPTOR TO PROCESS
;
; OUTPUTS:
;
;	R1 = NUMBER FIELD OF DESCRIPTOR.
;-
 
DCL$GETNVAL::					; GET KEYWORD NUMBER
	SUBL3	#PTR_K_LENGTH,-			; GET ADDRESS OF TOKEN DESCRIPTOR
		WRK_L_RSLNXT(R10),R1		;
	MOVZBL	PTR_B_NUMBER(R1),R1		; GET KEYWORD NUMBER
	RSB					;

	.SBTTL	SORT THE TOKEN DESCRIPTOR TABLE 
;+
; DCL$SORT_TOKENS - SORT THE TOKEN DESCRIPTOR TABLE.
;
; THIS ROUTINE IS CALLED TO SORT THE TOKEN DESCRIPTOR TABLE INTO 
; CMDQUAL,PARM,PARMQUAL ORDER TO MAKE GETDVAL PROCESSING IN INTERNAL 
; CLI ROUTINES EASIER AND TO MAKE DISALLOW PROCESSING EASIER.
;
; INPUTS:
;
;	R10 = ADDRESS OF WRK DATA STRUCUTURE
;
; OUTPUTS:
;
;	R0-R9 ARE DESTROYED.
;
;---
DCL$SORT_TOKENS::

	PUSHL	R10				;SAVE R10
	MOVAB	WRK_G_RESULT(R10),R7		;GET ADDRESS OF RESULT DESCRIPTOR ARRAY
	MOVL	R7,R8				;COPY ADDRESS OF RESULT DESCRIPTOR ARRAY
	MOVAB	-WRK_C_RSLBUFSIZ(SP),SP		;ALLOCATE TEMPORARY DESCRIPTOR ARRAY
	MOVL	SP,R9				;SAVE ADDRESS OF TEMPORARY DESCRIPTOR ARRAY
10$:	CMPL	R7,WRK_L_RSLNXT(R10)		;END OF RESULT DESCRIPTOR ARRAY?
	BEQL	30$				;IF EQL YES
	MOVC3	#PTR_C_LENGTH,(R7),(R9)		;MOVE DESCRIPTOR TO TEMPORARY ARRAY
	ADDL	#PTR_C_LENGTH,R7		;POINT PAST IT IN ORIGINAL ARRAY
	CMPZV	#PTR_V_TYPE,#PTR_S_TYPE,-	;COMMAND QUALIFIER?
		(R9),#PTR_K_COMDQUAL		;
	BNEQ	10$				;BRANCH IF NOT
	MOVC5	#0,(SP),#0,#PTR_C_LENGTH,-	;CLEAR COMMAND QUALIFIER DESCRIPTOR
		-PTR_C_LENGTH(R7)		;  IN ORIGINAL ARRAY
	ADDL	#PTR_C_LENGTH,R9		;POINT TO NEXT ITEM IN TEMPORARY ARRAY
20$:	CMPZV	#PTR_V_TYPE,#PTR_S_TYPE,- 	;QUALIFIER VALUE?
		(R7),#PTR_K_QUALVALU		;
	BNEQ	10$				;BRANCH IF NOT
	MOVC3	#PTR_C_LENGTH,(R7),(R9)		;MOVE DESCRIPTOR TO TEMPORARY ARRAY
	ADDL	#PTR_C_LENGTH,R9		;POINT PAST IT IN TEMPORARY ARRAY
	MOVC5	#0,(SP),#0,#PTR_C_LENGTH,(R7)	;CLEAR COMMAND QUALIFIER DESCRIPTOR
	ADDL	#PTR_C_LENGTH,R7		;POINT TO NEXT ITEM IN ORIGINAL ARRAY
	BRB	20$				;

30$:	MOVL	R7,R10				;COPY ADDRESS OF LAST DESCRIPTOR + 1
40$:	CMPL	R7,R8				;ANY MORE DESCRIPTORS TO EXAMINE?
	BEQL	50$				;IF EQL NO
	SUBL	#PTR_C_LENGTH,R7		;REMOVE DESCRIPTOR
	MOVL	R7,R6				;GET DESCRIPTOR ADDRESS
	TSTL	(R6)				;WAS THERE A DESCRIPTOR THERE?
	BEQL	40$				;BRANCH IF NOT
	SUBL	#PTR_C_LENGTH,R10		;POINT BEFORE IT IN ORIGINAL ARRAY
	MOVC3	#PTR_C_LENGTH,(R6),(R10)	;MOVE DESCRIPTOR TO NEW POSITION
	BRB	40$				;
50$:	CMPL	R9,SP				;ANY MORE TEMPORARY DESCRIPTORS?
	BEQL	60$				;IF EQL NO
	SUBL	#PTR_C_LENGTH,R10		;POINT BEFORE IT IN ORIGINAL ARRAY
	SUBL	#PTR_C_LENGTH,R9		;POINT BEFORE IT IN TEMPORARY ARRAY
	MOVC3	#PTR_C_LENGTH,(R9),(R10)	;MOVE DESCRIPTOR TO NEW POSITION
	BRB	50$				;

60$:	MOVAB	WRK_C_RSLBUFSIZ(SP),SP		;DEALLOCATE TEMPORARY DESCRIPTOR ARRAY
	POPL	R10				;RESTORE R10
	RSB					;

	.END
