	.title	pli$format
	.ident	/1-006/						; Edit CGN1006
								; Edit CGN1005
								; Edit CGN1004
								; Edit WHM1003

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; facility:
;
;	VAX/VMS PL1 runtime library
;
; abstract:
;
;	This module contains the pl1 runtime routines for getting the next
;	format item in a format list.
;
;
; author: c. spitz 28-nov-79
;
; modified:
;
;	1-002	Chip Nylander	7-September-1982
;
;		Modified GETCOL to conform to ANSI X3.53 page 259
;   		step 1.2.3.2.3: if a column request cannot be satisfied for
;		any reason, do an implicit getskip;  if the column request can
;		now be satisfied, perform the column positioning, otherwise
;		do nothing.
;
;
;	1-003	Bill Matthews	29-September-1982
;
;		Invoke macros $defdat and rtshare instead of $defopr and share.
;
;	1-004	Chip Nylander	03-Februaruy-1983
;
;		Save the parent frame pointer in R1 instead of R0 when calling
;		an expression routine.
;
;	1-005	Chip Nylander	23-February-1983
;
;		Make fixed-point edited output of floating binary values
;		round instead of truncate, per the ANSI Standard and our
;		own published documentation.
;
;	1-006	Chip Nylander	08-August-1983
;
;		Solve problem with uplevel references to automatic variables
;		in remote formats by using the parent pointer of the frame
;		containing the remote format.  Use the parent pointer instead
;		of -4(fp) for all vfe calls.
;
;--

;
; external definitions
;
	$defstr				;define stream block offsets
	$defdat				;define data types
	$defcvtind			;define convert indices
	$deffcb				;define file control block
	$defpic				;define picture node offsets
	$sfdef				;define stack offsets

; 
; local data
;

	rtshare				;sharable

bformattab:				;table of chars for B-radix conversion
	.byte	^a\0\,^a\1\		;entries for B1
	.byte	^a\0\,^a\2\,^a\1\,^a\3\	;entries for B2
	.byte	^a\0\,^a\4\,^a\2\,^a\6\	;entries for B3
	.byte	^a\1\,^a\5\,^a\3\,^a\7\	;
	.byte	^a\0\,^a\8\,^a\4\,^a\C\	;entries for B4
	.byte	^a\2\,^a\A\,^a\6\,^a\E\	;
	.byte	^a\1\,^a\9\,^a\5\,^a\D\	;
	.byte	^a\3\,^a\B\,^a\7\,^a\F\	;

;++
; pli$$getfmt_r6
;
; functional description:
;	control formats are processed and the next item is transmitted from the
;	file buffer via edit directed input. for data formats, the general
;	flow is: the compiled code jsb's to pli$gete**** routine. that
;	routine saves the source address and precision and jsb's to this
;	routine to get the next input item. this routine processes interceding
;	control formats until a data format is encountered. the data format
;	evaluates its parameters and gets the proper number of characters by
;	jsb'ing to pli$$getnedi. pli$$getnedi returns a character string
;	in the field area of the current format. the data format routine then
;	converts this character string to the a temporary, whose data type is
;	based on the format. it returns with the address, precision and data
;	type of this temporary. the pli$gete**** routine then restores the
;	target information and calls pli$cvrt_cg_r3 to finish processing.
;	note that the common control formats for input and output are located
;	in this section. all output control formats MUST PRESERVE R5, which is
;	used to store the offset of unaligned bit sources.
;
; inputs:
;	r11 - address of stream block
;	ap - address of fcb
; outputs:
;	r0 - address of field in stream block
;	r1 - precision / scale of temp in stream block
;	r4 - case index of temp as the source to any
; side effects:
;	r0-r6 are destroyed
;--

pli$$getfmt_r6::
	movb	@str_l_fp(r11),r0	;get format type
	incl	str_l_fp(r11)		;update format pointer
	case	type=b,r0,limit=#1,< -	;case on format type
		getbiter, -		;1 byte constant iteration
		getwiter, -		;2 word constant iteration
		getliter, -		;3 long constant iteration
		invfrm, -		;4 pc relative iter (invalid)
		getexpriter, -		;5 expression iteration (Version 1)
		geteof, -		;6 end of format
		getexpriter_v2, -	;7 expression iteration (Version 2)
		invfrm, -		;8 invalid format
		invfrm, -		;9 invalid format
		geta, -			;10 alphanumeric format
		getb1, -		;11 bit (1) format
		getb1, -		;12 bit 1 format
		getb2, -		;13 bit 2 format
		getb3, -		;14 bit 3 format
		getb4, -		;15 bit 4 format
		getcol, -		;16 column format
		getcol, -		;17 column format
		gete, -			;18 exp format
		getf, -			;19 fixed format
		invfrm, -		;20 line format invalid for get
		getp, -			;21 picture format
		invfrm, -		;22 page format invalid for get 
		getr, -			;23 remote format (PL/I version 1)
		getskip, -		;24 skip format
		invfrm, -		;25 tab format invalid for get
		getx, -			;26 blank format
		invfrm, -		;27 left paren (no longer used)
		getrparen, -		;28 right paren
		getr_v2>		;29 remote format (PL/I version 2)

	brw	invfrm			;none of the above, invalid format

; process an iteration factor. the iteration factor is stored on the format
; stack as a count and the address of its first item. if the iteration factor
; is less than or equal to 0, we will skip the format item(s) between the
; iteration and its matching right paren.

getbiter:				;byte constant iteration
	pushab	pli$$getfmt_r6		;set return addr
	brb	biter			;cont in common
putbiter:				;
	pushab	pli$$putfmt_r6		;set return addr
biter:	cvtbl	@str_l_fp(r11),r1	;get iteration count
	incl	str_l_fp(r11)		;update format pointer
	brb	getitercom		;cont in common

getwiter:				;word constant iteration
	pushab	pli$$getfmt_r6		;set return addr
	brb	witer			;cont in common
putwiter:				;
	pushab	pli$$putfmt_r6		;set return addr
witer:	cvtwl	@str_l_fp(r11),r1	;get iteration count
	addl	#2,str_l_fp(r11)	;update format pointer
	brb	getitercom		;cont in common

getliter:				;long constant iteration
	pushab	pli$$getfmt_r6		;set return addr
	brb	liter			;cont in common
putliter:				;
	pushab	pli$$putfmt_r6		;set return addr
liter:	movl	@str_l_fp(r11),r1	;get iteration count
	addl	#4,str_l_fp(r11)	;update format pointer
	brb	getitercom		;cont in common

getexpriter_v2:				;expression iteration (Version 2)
	pushab	pli$$getfmt_r6		;set return addr
	brb	exiter_v2		;cont in common
putexpriter_v2:				;
	pushab	pli$$putfmt_r6		;set return addr
exiter_v2:	
	movl	str_l_parent(r11),r1	;get parent frame pointer
	brb	exiter_common		;join common code

getexpriter:				;expression iteration
	pushab	pli$$getfmt_r6		;set return addr
	brb	exiter			;cont in common
putexpriter:				;
	pushab	pli$$putfmt_r6		;set return addr
exiter:	movl	-4(fp),r1		;get parent frame pointer
exiter_common:
	movl	@str_l_fp(r11),r0	;get rel addr
	addl	#4,str_l_fp(r11)	;update format pointer
	addl	str_l_fp(r11),r0	;get absolute addr
	calls	#0,(r0)			;call the routine
	movl	r0,r1			;set iteration factor

getitercom:				;process iteration factor
	movl	str_l_sp(r11),r2	;get format stack pointer
	movab	<str_l_stack_end+8>(r11),r0 ;get last place for an iteration
	cmpl	r0,r2			;is there room for another iteration?
	blequ	10$			;if lequ, yes continue
	movl	#pli$_formatovfl,r0	;set format stack overflow
	brw	fail			;and fail
10$:	movl	str_l_fp(r11),-(r2)	;push fp on stack
	movl	r1,-(r2)		;push iter count on stack
	movl	r2,str_l_sp(r11)	;store stack pointer
	sobgeq	(r2),30$		;do an iteration
; the format iteration is < 0, so we must skip all format items until the
; matching right paren is found.
	clrl	(r2)			;skip this iteration, clear paren count
20$:	movb	@str_l_fp(r11),r0	;get next format
	incl	str_l_fp(r11)		;increment format pointer
	case	type=b,r0,limit=#1,< -	;case on format type
		70$, -			;1 byte iter
		80$, -			;2 word iter
		90$, -			;3 long iter
		invfrm, -		;4 pc rel cons
		90$, -			;5 expression iter (Version 1)
		invfrm, -		;6 end of format (not expected)
		90$, -			;7 expression iter (Version 2)
		invfrm, -		;8 unused
		invfrm, -		;9 unused
		50$, -			;10 a
		50$, -			;11 b1
		50$, -			;12 b1
		50$, -			;13 b2
		50$, -			;14 b3
		50$, -			;15 b4
		50$, -			;16 col
		50$, -			;17 col
		40$, -			;18 e
		40$, -			;19 f
		50$, -			;20 lin
		50$, -			;21 pic
		20$, -			;22 page
		50$, -			;23 rem (PL/I version 1)
		50$, -			;24 skip
		50$, -			;25 tab
		50$, -			;26 x
		invfrm, -		;27 left paren
		60$, -			;28 right paren
		45$>			;29 rem (PL/I version 2)

	brw	invfrm			;invalid format
30$:	rsb				;process next format item
40$:	bsbw	get_format_parm		;get first parm
45$:	bsbw	get_format_parm		;get second parm
50$:	bsbw	get_format_parm		;get last parm
	brb	20$			;go again
60$:	decl	(r2)			;decrement paren count
	bgeq	20$			;if geq, then go again
	addl	#8,str_l_sp(r11)	;clean stack
	rsb				;process next format item
70$:	incl	str_l_fp(r11)		;skip iteration
	brb	100$			;continue
80$:	addl	#2,str_l_fp(r11)	;skip iteration
	brb	100$			;continue
90$:	addl	#4,str_l_fp(r11)	;skip iteration
100$:	incl	(r2)			;increment paren count
	brw	20$			;go again

; end of format - if processing remote format, return to 'caller'. otherwise
; repeat format.
geteof:	pushab	pli$$getfmt_r6		;set return addr
	brb	comeof			;cont in com
puteof:	pushab	pli$$putfmt_r6		;set return addr
comeof:	movab	str_l_stack(r11),r0	;get addr of top of stack
	cmpl	str_l_sp(r11),r0	;anything on the stack?
	blssu	10$			;if lssu, yes, its end of remote
	movl	str_l_stack(r11),str_l_fp(r11) ;restart the format
	rsb				;go again
10$:	movl	@str_l_sp(r11),str_l_parent(r11) ;reset parent pointer
	addl	#4,str_l_sp(r11)	;
	movl	@str_l_sp(r11),str_l_fp(r11) ;reset format pointer
	addl	#4,str_l_sp(r11)	;clean stack
	rsb				;go again

invfrm:	movl	#pli$_invformat,r0	;set invalid format
	brw	fail			;and fail

invfrmprm:
	movl	#pli$_invfmtparm,r0	;set invalid format parameter
	brw	fail			;and fail
invstrfmt:
	movl	#pli$_invstrfmt,r0	;set invalid stream format
	brw	fail			;and fail
; a format, input. get the width, get that number of chars and return.
geta:	bsbw	get_format_parm		;get the parameter
	bleq	invfrmprm		;if leq, then invalid format
	movl	r1,r0			;set width
	jsb	g^pli$$getnedi_r6	;get the item
	movl	#cvt_k_src_char,r4	;set case index
	rsb				;return

; b format, input
; set the radix factor
getb1:	pushl	#1			;push radix
	brb	getb			;continue in common	
getb2:	pushl	#2			;push radix
	brb	getb			;continue in common
getb3:	pushl	#3			;push radix
	brb	getb			;continue in common
getb4:	pushl	#4			;push radix
; get the width and that number of characters
getb:	bsbw	get_format_parm		;get the parameter
	bleq	invfrmprm		;if leq, then invalid format
	movl	r1,r0			;set width
	jsb	g^pli$$getnedi_r6	;get the item
; skip leading blanks. there must be at least 1 non-blank.
	skpc	#^x20,r1,str_b_field(r11) ;skip leading blanks
	bneq	20$			;if neq, non-blank found
10$:	movl	#pli$_cnverr,r0		;set conversion error
	brw	fail			;and fail
20$:	movl	r0,r6			;save length left
	movl	r1,r5			;save addr of 1st non-blank
; locate trailing blanks. we won't convert them
	locc	#^x20,r0,(r1)		;find next blank
	beql	30$			;if eql, not found, cont
	subl	r0,r6			;get new length for string
	skpc	#^x20,r0,(r1)		;anything left other than blanks?
	bneq	10$			;if neq, then yes, error
; copy the non-blank chars to the beginning of the field
30$:	movc3	r6,(r5),str_b_field(r11) ;copy to beginning of field
	movl	r3,str_l_fld_pt(r11)	;set field pointer
; convert the chars to a bit string based on the radix factor
	popl	r0			;restore radix
	jsb	g^pli$$chrbitn_r6	;convert to a bit string
	movl	#cvt_k_src_abit,r4	;set case index
	rsb				;return

; column format, input
; if the requested column is after current column, and before the end of the
; line, we just position the buffer pointer to the requested place.
; otherwise, perform a getskip;  if the column can now be positioned as
; requested, then do so, otherwise give up.

getcol:	bbc	#atr_v_string,fcb_l_attr(ap),5$ ;if string i/o
	brw	invstrfmt		;fail with invalid string format
5$:	bsbw	get_format_parm		;get the parameter
	bgtr	20$			;if gtr, cont
	beql	10$			;if eql, use 1
	brw	invfrmprm		;its lss, invalid format
10$:	incl	r1			;use 1 instead of 0
20$:	clrl	r2			;say that this is first time through
	cmpw	r1,fcb_w_column(ap)	;already past requested column?
	blss	30$			;if lss, then yes
25$:	subw3	fcb_w_column(ap),r1,r0	;get number to move
	movw	r1,fcb_w_column(ap)	;update column
	movzwl	r0,r0			;make it long
	addl3	r0,fcb_l_buf_pt(ap),r3	;make updated buffer pointer
	cmpl	r3,fcb_l_buf_end(ap)	;past end of this line?
	bgeq	30$			;if geq, then yes
	movl	r3,fcb_l_buf_pt(ap)	;update buffer pointer
	brb	40$			;exit
30$:	tstl	r2			;is this first time through?
	bgtr	40$			;if no, give up trying
	bicl	#atr_m_virgin,fcb_l_attr(ap) ;deflower file (so we don't skip
					; first record)
	movl	r1,r3			;save requested column
	jsb	g^pli$$getskp1_r2	;do a skip
	movl	r3,r1			;restore request
	movl	#1,r2			;say that this is second time through
	brb	25$			;go try to position on new line
40$:	brw	pli$$getfmt_r6		;go again

; e format, input
; get the parameters. w,d and s are supplied, but s is ignored.
gete:	bsbw	get_format_parm		;get width
	bgeq	10$			;if geq, cont
	brw	invfrmprm		;if lss, then invalid format
10$:	bneq	20$			;if neq, then cont
	brw	zero			;make result zero
20$:	movl	r1,r2			;save width
	bsbw	get_format_parm		;get fractional digits
	bgeq	30$			;if geq, cont
	brw	invfrmprm		;if lss, then invalid format
30$:	movl	r1,r4			;set frac digits for pli$fchrfltd_r6
	bsbw	get_format_parm		;get scale factor
	movl	r2,r0			;set width
; get the required number of chars
	jsb	g^pli$$getnedi_r6	;get the field
	bsbw	char_flt_ctx		; get the float context
	movab	str_b_field(r11),r2	; addr field as target
	movq	r2,-(sp)		; save destination
	calls	#0,g^pli$fchrfltd_r6	; convert fractioned char to float dec
	movq	(sp)+,r0		; use destination of cvt as src
	movl	#cvt_k_src_fltd,r4	; set case index for fltd src
	rsb				; return

	.enabl lsb
; f format, input
; get w,d,s. s is ignored
getf:	bsbw	get_format_parm		;get width
	bgeq	10$			;if geq, cont
	brw	invfrmprm		;its lss, invalid format
10$:	bneq	20$			;if neq, then cont
zero:	bsbw	get_format_parm		;get next parm
	bsbw	get_format_parm		;get last parm
	movab	str_b_field(r11),r0	;set addr of result
	clrl	(r0)			;clear result
	movl	#31,r1			;set precision
	movl	#cvt_k_src_fixb,r4	;set case index for fixb
	rsb				;return
20$:	movl	r1,r2			;save width
	bsbw	get_format_parm		;get fractional digits
	bgeq	30$			;if geq, ok
	brw	invfrmprm		;its lss, invalid format
30$:	movl	r1,r3			;save fractional digits
	bsbw	get_format_parm		;get scale factor
	movl	r2,r0			;set width
; get the required number of chars
	jsb	g^pli$$getnedi_r6	;get the field
	movl	r0,r6			;save start addr
	movl	r1,r2			;save length read
; if there is no decimal point in the input, we use the specified d to imply one
	locc	#^x2e,r1,(r0)		;find the decimal point
	beql	70$			;if eql, then use fractional digits
	movl	r1,r5			;save addr of point
; make sure there is nothing but trailing blanks
	locc	#^x20,r0,(r1)		;find trailing blank
	beql	40$			;if eql, then none
	subl	r0,r2			;get new length of field
	skpc	#^x20,r0,(r1)		;anything left other than blanks?
	beql	40$			;if eql, then no, ok
	movl	#pli$_cnverr,r0		;set conversion error
	brw	fail			;and fail
; pli$charfixd_r6 allows an exponent, but f format does not. we will append
; an exponent of 0, which will cause charfixd to signal error if the input
; already has an exponent.
40$:	addl3	r6,r2,r0		;get addr of end of field
	subl3	r5,r0,r3		;get number of fractional digits
	decl	r3			;
	movw	#^x3045,(r0)		;append 'E0', (its not allowed in f)
	addl3	#2,r2,r1		;set length for convert
	cmpl	r2,#31			;length > max fixd prec?
	bleq	50$			;if leq, then no, cont
	movl	#31,r2			;use max prec
50$:	ashl	#8,r3,r3		;set scale of temp = # digs in frac
	bisb	r2,r3			;put in the prec
	pushl	r3			;save prec,scale
	movab	str_b_field(r11),r0	;set addr of src
	movl	r0,r2			;set addr of dst
	calls	#0,g^pli$charfixd_r6	;convert to fixd
	popl	r1			;restore prec,scale
60$:	movab	str_b_field(r11),r0	;set addr of temp
	movl	#cvt_k_src_fixd,r4	;set case index
	rsb				;return
; there was no decimal point in the input string, so we will convert to a non-
; scaled fixd, and fix up the scale after the conversion.
70$:	movab	str_b_field(r11),r0	;get addr of field
	skpc	#^x20,r2,(r0)		;skip leading blanks
	locc	#^x20,r0,(r1)		;find trailing blank
	beql	90$			;if eql, no trail blanks, cont
	pushl	r1			;save start of blanks
	subl	r0,r2			;don't count blanks in len
	skpc	#^x20,r0,(r1)		;skip trail blanks.
	beql	80$			;if eql, ok
	movl	#pli$_cnverr,r0		;set conversion error (non blank found)
	brw	fail			;and fail
80$:	popl	r1			;get start of blanks
90$:	movw	#^x3045,(r1)		;append 'E0' (its not allowed in f)
	addl3	#2,r2,r1		;set len of src
	cmpl	r2,#31			;length > max fixd prec?
	bleq	100$			;if leq, then no, cont
	movl	#31,r2			;use max prec
100$:	ashl	#8,r3,r4		;set scale = numb digs in frac
	bisb	r2,r4			;set len
	pushl	r4			;save prec,scale
	movab	str_b_field(r11),r0	;set addr of src
	movl	r2,r3			;set len of dst
	movl	r0,r2			;set addr of dst
	calls	#0,g^pli$charfixd_r6	;convert to fixd
	popl	r1			;restore prec,scale
	brb	60$			;continue
	.dsabl	lsb
	
; picture format, input
; get the addr of the picture descriptor
getp:	bsbw	get_format_parm		;get the parm
	bneq	10$			;if neq, cont
	brw	invfrm			;
10$:	movl	r1,r6			;save picture descr addr
; get the required chars
	movzbl	pic$b_byte_size(r1),r0	;set size to read
	jsb	g^pli$$getnedi_r6	;get the field
; validate the picture. note that p format requires that the chars read be
; a valid picture string. this differs from list input of a picture variable
; where the input must be a valid fixed decimal number.
	pushl	r0			;set addr
	pushl	r1			;set length read
	pushl	r6			;set picture desc addr
	calls	#3,g^pli$valid_pic	;validate picture
	blbs	r0,20$			;if lbs, cont
	movl	#pli$_cnverr,r0		;set conversion error
	brw	fail			;and fail
20$:	movab	str_b_field(r11),r0	;set addr
	movl	r6,r1			;set pic desc addr
	movl	#cvt_k_src_pic,r4	;set src data type
	rsb				;return

; version 2 remote format.  a remote format is processed by using the nesting
; level difference passed as the first format param to calculate the parent
; pointer of the remote format.  this calculated parent pointer is then set
; info r1 for all vfe calls that occur in the remote format, and the vfes
; use r1 for uplevel references to automatic variables.
getr_v2:pushab	pli$$getfmt_r6		;set return addr
	brb	comr_v2			;cont in common
putr_v2:pushab	pli$$putfmt_r6		;set return addr
comr_v2:bsbw	get_format_parm		;get nesting level relative to referencer
	bgeq	10$			;if geq, continue
	brw	invfrm			;else invalid format
10$:	movl	str_l_parent(r11),r3	;get parent pointer of referencer
20$:	decl	r1			;decrement relative nesting level
	blss	remcom			;if lss then have correct parent pointer
	movl	sf$l_save_fp(r3),r3	;else get next higher parent pointer
	brb	20$			;and go back


; remote format. a remote format is processed by pushing the address of the
; next item in the original format onto the format stack. when the remote
; formats end of format is encountered, this address is popped, and control
; returns to the original format.
getr:	pushab	pli$$getfmt_r6		;set return addr
	brb	comr			;cont in common
putr:	pushab	pli$$putfmt_r6		;set return addr
comr:	movl	str_l_parent(r11),r3	;pickup default parent
remcom:	bsbw	get_format_parm		;get the remote format
	bneq	10$			;if neq, continue
	brw	invfrm			;invalid format
10$:	movab	<str_l_stack_end+8>(r11),r0 ;get addr of last place for remote
	movl	str_l_sp(r11),r2	;get format stack pointer
	cmpl	r0,r2			;room for this remote?
	blequ	20$			;if lequ, then yes
	movl	#pli$_formatovfl,r0	;set format stack overflow
	brw	fail			;and fail
20$:	movl	str_l_fp(r11),-(r2)	;push addr of next item in this format
	movl	str_l_parent(r11),-(r2)	;push parent pointer for this format
	movl	r2,str_l_sp(r11)	;store stack pointer
	movl	r1,str_l_fp(r11)	;set format pointer to remote format
	movl	r3,str_l_parent(r11)	;set parent pointer to remote format
	rsb				;go with remote format

; skip format, input
getskip:bbc	#atr_v_string,fcb_l_attr(ap),5$ ;if string i/o
	brw	invstrfmt		;fail with invalid string format
5$:	bsbw	get_format_parm_1	;get the number of records to skip
	bgeq	10$			;if geq, ok
	brw	invfrmprm		;its leq, invalid format
10$:	movl	r1,r2			;set number to skip
	jsb	g^pli$$getskip_r2	;skip em
	brw	pli$$getfmt_r6		;go again

; x format, input
getx:	bsbw	get_format_parm_1	;get the number of chars to skip
	beql	10$			;if eql, ignore it
	movl	r1,r0			;set width
	jsb	g^pli$$getnedi_r6	;get that number of chars
10$:	brw	pli$$getfmt_r6		;go again

; right paren - end of iteration. the iteration count on the format stack is
; decremented. if it is <= 0, we go on to the next format item. otherwise, we
; repeat the iterated items.
getrparen:
	pushab	pli$$getfmt_r6		;set return addr
	brb	comrparen		;cont in common
putrparen:
	pushab	pli$$putfmt_r6		;set return addr
comrparen:
	movl	str_l_sp(r11),r2	;get format sp
	sobgeq	(r2),10$		;do an iteration
	movab	8(r2),str_l_sp(r11)	;clean stack
	rsb				;process next format item
10$:	movl	4(r2),str_l_fp(r11)	;restart this format
	rsb				;process next format item

;get_format_parm_1 - get a format parm. if the parm is missing, 1 is supplied
; as default.
; inputs:
;	r11 - address of stream block
;	ap - address of fcb
; outputs:
;	r1 - value of parameter or 1 if item missing
;
get_format_parm_1:
	movl	#1,r1			;set missing parm value
	brb	get_format_com		;cont in common

;get_format_parm - get a format parm. if the parm is missing, 0 is supplied
; as default.
; inputs:
;	r11 - address of stream block
;	ap - address of fcb
; outputs:
;	r1 - value of parameter or 0 if item missing
;
get_format_parm:
	clrl	r1			;set missing parm value
get_format_com:
	bicl	#str_m_missing,str_l_fs(r11) ;clear missing parameter
; get the parameter type and case on it
	movb	@str_l_fp(r11),r0	;get parm type
	incl	str_l_fp(r11)		;increment format pointer
	case	type=b,r0,< -		;case on parameter type
		10$, -			;missing
		20$, -			;byte constant
		30$, -			;word constant
		40$, -			;long constant
		50$, -			;pc relative long constant
		60$, -			;pc relative long entry point (V1)
		 5$, -			;invalid format
		70$>			;pc relative long entry point (V2)
5$:	brw	invfrm			;none of the above, invalid format
; missing
10$:	bisl	#str_m_missing,str_l_fs(r11) ;set missing parameter
	tstl	r1			;set default value condition code
	rsb				;return
; byte constant
20$:	cvtbl	@str_l_fp(r11),r1	;get the parm
	incl	str_l_fp(r11)		;increment format pointer
	tstl	r1			;set cond codes
	rsb				;return
; word constant
30$:	cvtwl	@str_l_fp(r11),r1	;get the parm
	addl	#2,str_l_fp(r11)	;increment format pointer
	tstl	r1			;set cond codes
	rsb				;return
; long constant
40$:	movl	@str_l_fp(r11),r1	;get the parm
	addl	#4,str_l_fp(r11)	;increment format pointer
	tstl	r1			;set cond codes
	rsb				;return
; pc relative long constant, used for remote and picture formats
50$:	movl	@str_l_fp(r11),r1	;get the parm
	addl	#4,str_l_fp(r11)	;increment format pointer
	addl	str_l_fp(r11),r1	;make addr absolute
	rsb				;return
; version 1 pc relative entry point, used for expressions in format items
60$:	movl	@str_l_fp(r11),r0	;get the addr
	addl	#4,str_l_fp(r11)	;update format pointer
	addl	str_l_fp(r11),r0	;make addr absolute
	movl	-4(fp),r1		;set parent frame pointer
	calls	#0,(r0)			;call it
	movl	r0,r1			;set parm
	rsb				;return

; version 2 pc relative entry point, used for expressions in format items
70$:
	movl	@str_l_fp(r11),r0	;get the addr
	addl	#4,str_l_fp(r11)	;update format pointer
	addl	str_l_fp(r11),r0	;make addr absolute
	movl	str_l_parent(r11),r1	;set parent frame pointer
	calls	#0,(r0)			;call it
	movl	r0,r1			;set parm
	rsb				;return

fail:	movl	r0,fcb_l_error(ap)	;set error in fcb
	pushl	ap			;set fcb addr
	pushl	r0			;set error code
	pushl	#pli$_error		;set error condition
	calls	#3,g^pli$io_error	;signal error
	ret				;return
;++
; pli$$putfmt_r6
;
; functional description:
;	control formats are processed and the next item is transmitted to the
;	file buffer via edit directed output. for data formats, the general
;	flow is: the compiled code jsb's to pli$pute**** routine. that
;	routine pushes the address, scale and precision and the case index
;	for the	general conversion routine for the data type of the source.
;	for unaligned bit targets, the offset is passed in r5. thus r5 MUST
;	BE PRESERVED by all output control formats or the offset is lost.
;	the pli$pute**** routine then jmp's to this routine. this routine
;	finds the next data format (processing all intervening control formats)
;	and then enters the data format processing code. the data formats
;	convert the source to a standard type based on the format. this is then
;	placed in the files buffer by jumping to pli$$putnedi_r6.
;	note that some of the common control formats are above in the getformat
;	section.
;
; inputs:
;	0(sp) - data type as a case index for pli$cvrt_cg_r3 as source
;	4(sp) - address of next item to put
;	8(sp) - prec/scale of item
;	12(sp) - return address
;	r11 - address of stream block
;	ap - address of fcb
; outputs:
; side effects:
;	r0-r6 are destroyed
;--

pli$$putfmt_r6::
	movb	@str_l_fp(r11),r0	;get format type
	incl	str_l_fp(r11)		;update format pointer
	case	type=b,r0,limit=#1,< -	;case on format type
		putbiter, -		;1 byte constant iteration
		putwiter, -		;2 word constant iteration
		putliter, -		;3 long constant iteration
		invfrm, -		;4 pc relative iter (invalid)
		putexpriter, -		;5 expression iteration (Version 1)
		puteof, -		;6 end of format
		putexpriter_v2, -	;7 expression iteration (Version 2)
		invfrm, -		;8 invalid format
		invfrm, -		;9 invalid format
		puta, -			;10 alphanumeric format
		putb1, -		;11 bit (1) format
		putb1, -		;12 bit 1 format
		putb2, -		;13 bit 2 format
		putb3, -		;14 bit 3 format
		putb4, -		;15 bit 4 format
		putcol, -		;16 column format
		putcol, -		;17 column format
		pute, -			;18 exp format
		putf, -			;19 fixed format
		putline, -		;20 line format
		putp, -			;21 picture format
		putpage, -		;22 page format
		putr, -			;23 remote format (PL/I version 1)
		putskip, -		;24 skip format
		puttab, -		;25 tab format
		putx, -			;26 blank format
		invfrm, -		;27 left paren (no longer used)
		putrparen, -		;28 right paren
		putr_v2>		;29 remote format (PL/I version 2)

	brw	invfrm			;none of the above, invalid format

; a format, output
; get the width
puta:	bsbw	get_format_parm		;get the parameter
	bbc	#str_v_missing,str_l_fs(r11),20$ ;if parm missing then[
; if the width is missing, we convert the source to a char(1000) var.
	movl	#1000,r3		;set max size for vcha in field
	movab	str_b_field(r11),r2	;set addr
	addl3	#cvt_k_dst_vcha,(sp)+,r4 ;set case index for vcha dest
10$:	movq	(sp)+,r0		;set src addr, and prec
	calls	#0,g^pli$cvrt_cg_r3	;convert src to vcha
; put it out
	jmp	g^pli$$putnedi_r6	;put it in buffer and return]
;width present
20$:	tstl	r1			;else [set cond codes
	beql	50$			;if eql, ignore this field
	bgtr	30$			;if gtr, cont
	brw	invfrmprm		;its lss, invalid format
30$:	cmpl	r1,#1000		;len too big for field?
	bleq	40$			;if leg, no
	movl	#pli$_strovfl,r0	;set field overflow
	brw	fail			;and fail
40$:	movw	r1,str_b_field(r11)	;set len in field
	movl	r1,r3			;set dst len
	movab	<str_b_field+2>(r11),r2	;set dst addr
	addl3	#cvt_k_dst_char,(sp)+,r4 ;set case index for char dest
	brb	10$			;cont]
50$:	movab	12(sp),sp		;clean stack
	rsb				;its a(0), ignore field by returning

; b format, output
; set the radix
putb1:	pushl	#1			;set radix
	brb	putb			;cont in common
putb2:	pushl	#2			;set radix
	brb	putb			;cont in common
putb3:	pushl	#3			;set radix
	brb	putb			;cont in common
putb4:	pushl	#4			;set radix
	;stack at this point:
	;12(sp)	prec/scale of src
	; 8(sp)	addr of src
	; 4(sp)	datatype of src
	; 0(sp)	radix
putb:	bsbw	get_format_parm		;get the width
	bgtr	20$			;if gtr, cont
	beql	10$			;if eql, check for missing
	brw	invfrmprm		;its lss, invalid format
10$:	bbs	#str_v_missing,str_l_fs(r11),20$ ;if parm missing, use src prec
	movab	16(sp),sp		;its a(0), so clean stack 
	rsb				;return
; determine the binary precision of the src
20$:	movl	sp,str_b_field(r11)	;save current stack addr
	movl	r1,r6			;save width
	divl3	#9,4(sp),r0		;get data type of source
	case	type=b,r0,< -		;case on src data type
		35$, -			;0 pic, not yet implemented
		30$, -			;1 fixb
		30$, -			;2 fltb
		40$, -			;3 fixd
		40$, -			;4 fltd
		30$, -			;5 char
		60$, -			;6 vcha
		30$, -			;7 bit
		30$>			;8 abit
	brw	invfrm			;invalid data type, fail
30$:	movl	12(sp),r3		;set dst prec eql to src prec
	bicl	#^x80,r3		;clear gfloat indicator
	brb	70$			;cont
35$:	movl	12(sp),r1		;get addr of pic descr
	movzbl	pic$w_pq(r1),r3		;get src prec
	movzbl	pic$w_pq+1(r1),r1	;get src scale
	brb	45$			;cont
40$:	movzbl	12(sp),r3		;get src prec
	bicl	#^x80,r3		;clear gfloat indicator
	ashl	#-8,12(sp),r1		;get src scale
45$:	subl	r1,r3			;get number of digs in integer part
	bleq	50$			;if leq, then result is zero
	mull2	#332,r3			;get binary precision according to rule
	addl	#99,r3			;round for ceil and fixed divide
	divl2	#100,r3			;finish (r3=ceil((p-q)*3.32)) really!)
	cmpl	r3,#31			;prec > 31?
	bleq	70$			;if leq, no, continue
	movl	#31,r3			;use max fixb prec
	brb	70$			;cont
50$:	movab	str_b_field(r11),r1	;get addr of field
	movw	r6,(r1)+		;put in width
	movc5	#0,(sp),#^x20,r6,(r1)	;blank it out
	movab	16(sp),sp		;clean stack
	rsb				;return
60$:	movzwl	@8(sp),r3		;get cur len of vcha src
;get size of bit temp needed, based on src prec and radix
70$:	movl	(sp),r0			;get radix
	addl	r0,r3			;round prec up to next multiple of radix
	decl	r3			;
	divl	r0,r3			;
	mull	r0,r3			;
	addl3	#7,r3,r0		;round prec up to a byte
	ashl	#-3,r0,r0		;get number of bytes required
	beql	50$			;if eql, then result is 0
;allocate temp on stack and clear last byte
	subl	r0,sp			;get space for temp on stack
	clrb	-1(sp)[r0]		;clear last byte of temp
	movl	sp,r2			;set addr of temp
	movl	str_b_field(r11),r4	;get old stack pointer
	movq	8(r4),r0		;get original src
	movl	r3,8(r4)		;save number of bits in temp
	movl	r6,12(r4)		;save width of field
	bneq	80$			;if neq, cont
	divl3	(r4),r3,12(r4)		;use converted prec for missing width
80$:	addl3	#cvt_k_dst_abit,4(r4),r4 ;set case index for abit dst
	calls	#0,g^pli$cvrt_cg_r3	;convert src to abit temp
;convert abit temp to vcha in field using B-radix conversion
;local register usage for conversion:
; r0 - radix
; r1 - address of table for this radix
; r2 - current position in bit string
; r3 - output pointer
; r4 - current bits or char
; r5 - number of chars left to do
; r6 - requested width, number of blanks to append
	movl	str_b_field(r11),r4	;get old stack pointer
	movl	(r4),r0			;get radix
	movl	8(r4),r1		;get number of bits in temp
	movl	12(r4),r6		;get req width
	cmpl	r6,#1000		;width too big?
	bleq	90$			;if leq, no
	movl	#pli$_strovfl,r0	;set field overflow
	brw	fail			;and fail
90$:	movab	str_b_field(r11),r3	;get addr of start of output field
	movw	r6,(r3)+		;set length in field
	divl3	r0,r1,r5		;get number of bytes of output
	bicl	#str_m_blankend,str_l_fs(r11) ;assume we can fill req. width
	cmpl	r5,r6			;enough to fill requested width?
	blss	100$			;if lss, no
					;if gtr and stringsize supported
					;then raise it here
	movl	r6,r5			;set req width as length
	clrl	r6			;set no blanks on end
	brb	110$			;cont
100$:	bisl	#str_m_blankend,str_l_fs(r11) ;remember to blank out end
	subl	r5,r6			;get number of blanks for end
110$:	ashl	r0,#1,r1		;get table address
	movab	bformattab-2(pc)[r1],r1	;based on radix
	clrl	r2			;start at beginning of bit string
	pushl	r4			;save old stack pointer
	brb	130$			;enter loop
120$:	extzv	r2,r0,4(sp),r4		;get some bits
	movb	(r1)[r4],(r3)+		;store resulting char in field
	addl	r0,r2			;update pos in bit string
130$:	sobgeq	r5,120$			;go again
; append blanks if necessary
	bbc	#str_v_blankend,str_l_fs(r11),140$ ;if we must append blanks
	movc5	#0,(sp),#^x20,r6,(r3)	;append blanks
140$:	addl3	#16,(sp)+,sp		;clean stack
	jmp	g^pli$$putnedi_r6	;put it out

; column format, output
; if the requested column is greater than current column and less than the
; linesize, we put in enough blanks to position to the requested column.
; if the requested column is greater than linesize we do a skip. if the
; requested column is less than current column, we do a skip and then
; fill with blanks to get to the requested column
putcol:	bbc	#atr_v_string,fcb_l_attr(ap),5$ ;if string i/o
	brw	invstrfmt		;fail with invalid string format
5$:	bsbw	get_format_parm		;get the parameter
	bgtr	20$			;if gtr, cont
	beql	10$			;if eql, cont
	brw	invfrmprm		;parm < 0, invalid format
10$:	incl	r1			;use 1 instead of 0
20$:	movzwl	fcb_w_linesize(ap),r0	;get linesize
	cmpw	r1,r0			;req col > linesize
	bleq	30$			;if leq, no, cont
	movl	#1,r1			;use 1 for col
30$:	decl	r1			;get req col - 1
	cmpw	r1,fcb_w_column(ap)	;(requested col-1) > current col?
	bgtr	50$			;if gtr, then yes
	beql	40$			;if eql, then already at right col
	pushl	r1			;save req col
	jsb	g^pli$$putskp1_r2	;do a skip
	popl	r1			;restore req col
	bgtr	60$			;if eql, just return	
40$:	brw	pli$$putfmt_r6		;go again
50$:	subw	fcb_w_column(ap),r1	;get number of blanks to move
60$:	brw	blank_field		;fill with blanks, put in buf, go again

; e format, output
;get prec of float dec temp from src dtyp and prec
pute:	bicl	#str_m_gfloat,str_l_fs(r11) ;assume not g float src
	divl3	#9,(sp),r0		;get data type of source
	case	type=b,r0,< -		;case on data type
		5$, -			;0 pic
		10$, -			;1 fixb
		10$, -			;2 fltb
		30$, -			;3 fixd
		30$, -			;4 fltd
		50$, -			;5 char
		45$, -			;6 vcha
		40$, -			;7 bit
		40$>			;8 abit
	brw	invfrm			;invalid data type, fail
5$:	movl	8(sp),r1		;get addr of pic descr
	movzbl	pic$w_pq(r1),r3		;get prec of pic src
	brb	35$			;cont
10$:	movl	8(sp),r3		;get prec of binary src
	bbcc	#7,r3,20$		;if g float
	bisl	#str_m_gfloat,str_l_fs(r11) ;set gfloat
20$:	mull	#100,r3			;get pl1 decimal prec
	addl	#331,r3			;
	divl	#332,r3			;
	cmpb	(sp),#cvt_k_src_fltb	;float bin src?
	bneq	60$			;if neq, no, cont
	decl	r3			;correct prec for context computation
	brb	60$			;cont
30$:	movzbl	8(sp),r3		;get prec of decimal src
35$:	bbcc	#7,r3,60$		;if g float
	bisl	#str_m_gfloat,str_l_fs(r11) ;set gfloat
	brb	60$			;cont
40$:	movl	#31,r3			;use max fixb prec for bit
	brb	20$			;cont
45$:	movl	4(sp),r0		; get addr of string
	movzwl	(r0)+,r1		; and size (point past 1st word)
	brb	55$
50$:	movzbl	8(sp),r1		; get size of src
	movl	4(sp),r0		; get addr of src
55$:	bsbw	char_flt_ctx		; get flt dec context
60$:	pushl	r3			;save dec prec
; get context of fltb temp
	bbc	#str_v_gfloat,str_l_fs(r11),80$ ;if g float src
	pushl	#1			;set for g context
	bisl	#128,r3			;set g float bit for convert
	brb	100$			;cont
80$:	cmpl	#15,r3			;is it f or d?
	blss	90$			;if lss, no
	clrl	-(sp)			;set for d context
	movl	#15,r3			;set max prec of d
	brb	100$			;cont
90$:	pushl	#2			;set for h context
100$:	cmpb	8(sp),#cvt_k_src_fltb	;float bin src?
	bneq	105$			;if neq, no, cont
	incl	4(sp)			;correct dec prec
;allocate fltb temp on stack
105$:	subl	#16,sp			;get room for temp
	movl	sp,r2			;set temp addr for dst
	movq	28(sp),r0		;set src addr and prec
	addl3	#cvt_k_dst_fltd,24(sp),r4 ;set convert index, dst = fltd
; convert src to fltd
	calls	#0,g^pli$cvrt_cg_r3	;convert to fltd
; get w,d,s. s is ignored
	bsbw	get_format_parm		;get the width
	cmpl	r1,#1000		;too big?
	bleq	110$			;if leq, no
	movl	#pli$_strovfl,r0	;set field overflow
	brw	fail			;and fail
110$:	movl	r1,r6			;save it
	bsbw	get_format_parm		;get the digs in frac
	bbs	#str_v_missing,str_l_fs(r11),130$ ;if digs in frac not missing
	movl	r1,r3			;save digs in frac
	bgeq	140$			;if geq, cont
	brw	invfrmprm		;set invalid format
130$:	subl3	#1,20(sp),r3		;use dec prec of src-1 as digs in frac
	addl3	#7,16(sp),r0		;get number of chars for exp,sign, dot
	subl3	r0,r6,r0		;get max number of digs in frac
	cmpl	r3,r0			;src-1 digs too many?
	bleq	140$			;if leq, no, use src-1
	movl	r0,r3			;use number of digs in frac that fits
140$:	bsbw	get_format_parm		;get scale but ignore it
; set up parms for convert routine
	addl3	#2,16(sp),-(sp)		;set number of digits in exp
	pushl	#1			;set number of digits in int
	clrl	-(sp)			;set scale factor
	pushl	r3			;set number of digits in frac
	movab	<str_b_field+2>(r11),44(sp) ;set addr of dest in dscr
	movl	r6,40(sp)		;set size of dest in dscr
	movw	r6,str_b_field(r11)	;set size in field
	pushab	40(sp)			;set addr of dest descr
	pushab	20(sp)			;set addr of src
; convert from fltd to char
	case	type=b,40(sp),<160$,170$,180$> ;case on src type	
150$:	movl	#pli$_invfmtparm,r0	;set format overflow (really size)error
	brw	fail			;and fail
160$:	calls	#6,g^FOR$CVT_D_TE	;convert it
	brb	190$			;cont
170$:	calls	#6,g^FOR$CVT_G_TE	;convert it
	brb	190$			;cont
180$:	calls	#6,g^FOR$CVT_H_TE	;convert it
190$:	blbc	r0,150$			;if lbc, error
	addl	#36,sp			;clean stack
	jmp	g^pli$$putnedi_r6	;put it out

; f format, output
; get w,d,s. s is ignored
putf:
	bsbw	get_format_parm		;get width
	bgtr	20$			;if gtr, cont
10$:	brw	invfrmprm		;its leq, so invalid format
20$:	cmpl	r1,#1000		;width too big?
	bleq	30$			;if leq, no
	movl	#pli$_strovfl,r0	;set field overflow
	brw	fail			;and fail
30$:	pushl	r1			;save width
	bsbw	get_format_parm		;get digits in frac
	blss	10$			;if lss, invalid format
	pushl	r1			;save digs in frac
	bsbw	get_format_parm		;get scale, ignored for now
;
; we will convert the src to a fixd number with
; 1 more fractional digit than that required. then we round it to the correct
; number of fractional digits.
;
	divl3	#9,8(sp),r0		;get data type of source
	case	type=b,r0,< -		;case on data type
		65$, -			;0 pic
		90$, -			;1 fixb
		40$, -			;2 fltb
		70$, -			;3 fixd
		70$, -			;4 fltd
		90$, -			;5 char
		90$, -			;6 vcha
		90$, -			;7 bit
		90$>			;8 abit
	brw	invfrm			;invalid data type
40$:	;fltb
	cmpw	#99,16(sp)		;dec prec > 30?
	bgtr	90$			;if leq, then no, use common
;	movq	12(sp),r0		;set src addr and prec
;	movl	(sp),r3			;get digs in frac
	cmpl	#31,(sp)		;trying to print more than 31 digs?
	bgeq	60$			;if geq, no
50$:	brw	invfrmprm		;invalid format
60$:	brb	90$			;go output rounded format
;	ashl	#8,r3,r3		;use digs in frac as scale
;	movb	#31,r3			;use max fixd prec
;	subl	#16,sp			;get space for fixd temp
;	movl	sp,r2			;set tmp addr
;	calls	#0,g^pli$fltbfixd_r6	;convert fltb to fixd
;	brb	110$			;cont
65$:	movl	16(sp),r1		;get addr of picture descr
	movzwl	pic$w_pq(r1),r1		;get prec and scale
	cmpb	#31,r1			;prec >= 31?
	brb	75$			;cont
70$:	;decimal
	cmpb	#31,16(sp)		;prec >= 31?
75$:	bgtr	90$			;if gtr, no, use common
	blss	50$			;if lss, invalid src prec
	movq	12(sp),r0		;set src addr and prec
	movl	(sp),r3			;get digs in frac
	cmpl	r3,#31			;trying to print more than 31 digs?
	bgtr	50$			;if gtr, then yes, invalid format
	ashl	#8,r3,r3		;use digs in frac as scale
	movb	#31,r3			;use max fixd prec
	subl	#16,sp			;get room for fixd temp
	movl	sp,r2			;set addr of tmp
	calls	#0,g^pli$fixdfixd_r6	;convert fixd to fixd tmp
	brb	110$			;cont
90$:	movq	12(sp),r0		;set src addr and prec
	addl3	8(sp),#cvt_k_dst_fixd,r4 ;set case index	
	addl3	(sp),#1,r3		;get digs in frac + 1
	cmpl	r3,#31			;trying to print more than 31 digits?
	bleq	100$			;if leq, no
	brw	invfrmprm		;invalid format
100$:	ashl	#8,r3,r3		;use digs in frac + 1 as scale
	movb	#31,r3			;set max fixd prec
	subl	#16,sp			;get room for fixd temp
	movl	sp,r2			;set addr of tmp
	calls	#0,g^pli$cvrt_cg_r3	;convert src to fixd
	subl	#16,sp			;get room for another temp
	ashp	#-1,#31,16(sp),#5,#31,(sp) ;round temp
	movq	(sp)+,8(sp)		;copy to orig temp
	movq	(sp)+,8(sp)		;
110$:	;at this point stack looks like:
	; 0(sp) - rounded fixd(31,digs in frac) temp
	; 16(sp) - digs in frac
	; 20(sp) - width
	; 24(sp) - src data type
	; 28(sp) - src addr
	; 32(sp) - src prec
	; 36(sp) - return addr
	movl	sp,r0			;set addr of fixd temp src
	ashl	#8,16(sp),r1		;use digs in frac as scale
	movb	#31,r1			;use 31 as prec of fixd src
	subl	#34,sp			;get space for char temp
	movl	sp,r2			;set char temp addr of dst
	movl	#34,r3			;set 34 as len
	calls	#0,g^pli$fixdchar_r6	;convert fixd to char
	movl	54(sp),r6		;get width
	movw	r6,str_b_field(r11)	;set width in field
	cmpl	#34,r6			;width < 34?
	blss	140$			;if lss, no
	subl3	r6,#34,r4		;get number of leading blanks
	skpc	#^x20,r4,(sp)		;skip leading blanks
	beql	120$			;if eql, cont
	brw	invfrmprm		;and fail
120$:	movc3	r6,(r1),<str_b_field+2>(r11) ;copy result to field
130$:	movab	70(sp),sp		;clean stack
	jmp	g^pli$$putnedi_r6	;put it out
140$:	subl3	#34,r6,r1		;get number of blanks needed
	movc5	#0,(sp),#^x20,r1,<str_b_field+2>(r11) ;put in leading blanks
	movc3	#34,(sp),(r3)		;copy the result to field
	brb	130$			;cont	

; line format
putline:bbc	#atr_v_string,fcb_l_attr(ap),5$ ;if string i/o
	brw	invstrfmt		;fail with invalid string format
5$:	bbs	#atr_v_print,fcb_l_attr(ap),10$ ;if print, cont
	movl	#pli$_notprint,r0	;set not print file
	brw	fail			;and fail
10$:	bsbw	get_format_parm		;get the parm
	jsb	g^pli$$putline_r6	;process the line
	brw	pli$$putfmt_r6		;go again

; p format output
putp:	bsbw	get_format_parm		;get the pict desc
	bneq	10$			;if neq, cont
	brw	invfrm			;fail
10$:	movab	str_b_field(r11),r2	;set dst addr
	movl	r1,r3			;set addr of pict desc
	movzbw	pic$b_byte_size(r1),(r2)+ ;set size of resulting string
	addl3	#cvt_k_dst_pic,(sp)+,r4	;set data type
	movq	(sp)+,r0		;set addr, size of src
	calls	#0,g^pli$cvrt_cg_r3	;convert to pic
	jmp	g^pli$$putnedi_r6	;put it out

; page format
putpage:bbc	#atr_v_string,fcb_l_attr(ap),5$ ;if string i/o
	brw	invstrfmt		;fail with invalid string format
5$:	bbs	#atr_v_print,fcb_l_attr(ap),10$ ;if print, cont
	movl	#pli$_notprint,r0	;set not print file
	brw	fail			;and fail
10$:	jsb	g^pli$$putpage_r6	;do a put page
	brw	pli$$putfmt_r6		;go again

; skip format, output
putskip:bbc	#atr_v_string,fcb_l_attr(ap),5$ ;if string i/o
	brw	invstrfmt		;fail with invalid string format
5$:	bsbw	get_format_parm_1	;get the number to skip
	movl	r1,r2			;copy number to skip
	jsb	g^pli$$putskip_r2	;do the skips
	brw	pli$$putfmt_r6		;go again

; tab format
puttab:	bbc	#atr_v_string,fcb_l_attr(ap),5$ ;if string i/o
	brw	invstrfmt		;fail with invalid string format
5$:	bsbw	get_format_parm_1	;get the tab stop
	bgtr	10$			;if gtr, cont
	beql	30$			;if eql, go again
	brw	invfrmprm		;its lss, invalid format
10$:	movzwl	fcb_w_column(ap),r0	;get current column
	bicl3	#7,r0,r3		;round down to last tab stop
	ashl	#3,r1,r2		;get number of blanks for req tabs
	addl	r3,r2			;get ending column
	cmpw	fcb_w_linesize(ap),r2	;past end of line?
	blss	20$			;if lss, yes, cont
	subl3	r0,r2,r1		;get number of blanks needed
	brw	blank_field		;output blanks and go again
20$:	jsb	g^pli$$putskp1_r2	;do a skip
30$:	brw	pli$$putfmt_r6		;go again

; x format, output
putx:	bsbw	get_format_parm_1	;get the number of blanks
;	brw	blank_field		;put out blanks and go again

;+
;blank_field
; this routine puts the specified number of blanks in to the field in vcha
; format. it then calls pli$$putnedi_r6 and jumps to pli$$putfmt_r6.
; inputs:
;	r1 - number of blanks
; outputs:
;	none
; side effects:
;	r0-r4,r6 are destroyed
;	r5 is preserved for the offset to bit sources
;-
blank_field:
	pushl	r5			;save r5 in case a bit src is pending
	cmpl	r1,#1000		;trying to put too many blanks in?
	bleq	10$			;if leq, no
	movl	#pli$_strovfl,r0	;set field overflow
	brw	fail			;and fail
10$:	cvtlw	r1,str_b_field(r11)	;set size of string
	movc5	#0,(sp),#^x20,r1,str_b_field+2(r11) ;put in the blanks
	jsb	g^pli$$putnedi_r6	;output the field
	popl	r5			;restore r5
	brw	pli$$putfmt_r6		;go on to next format

;+
;
; char_flt_ctx
;
; finds the appropriate float decimal precision for a character
; string based on the number of digits in the mantissa and
; the value of the exponent.
;
; inputs:
;
;	r1 - string size
;	r0 - string addr
;	ap - addr of file control block
;
; outputs:
;
;	returns the precision in r3
;
;	all other registers preserved
;
;-
char_flt_ctx:
	bbc	#atr_v_flttrg,fcb_l_attr(ap),4$ ;if flt target
	movl	16(sp),r3		;set fltb prec of target
	rsb				;return
4$:	pushr	#^m<r0,r1,r2,r4,r5>	; save regs
	skpc	#32,r1,(r0)		; skip leading blanks
	bneq	5$			; if string not blank, br
	movl	#1,r4			; else set prec of 1
	brb	100$
;
5$:	movq	r0,r2			; save new addr and length from skip
	locc	#32,r0,(r3)		; throw out trailing blanks too
	subl	r0,r2			; find the number of non-blank chars
	cmpb	(r3),#^a/+/		; check for a sign
	beql	10$			; br if found
	cmpb	(r3),#^a/-/		; minus?
	bneq	20$			; br if no sign
10$:	incl	r3			; point past it
	decl	r2
20$:	movl	r2,r4			; make char. count the digit count
	locc	#^a/./,r2,(r3)		; check for decimal point
	beql	30$			; br if none
	decl	r4			; deduct dec. pt. from digit count
30$:	locc	#^a/E/,r2,(r3)		; look for E
	bneq	40$			; br if found
	locc	#^a/e/,r2,(r3)		; e?
	beql	100$			; if none, that's it
40$:	subl	r0,r4			; sub. exponent chars from digit count
	incl	r1			; point past the E/e
	decl	r0
	cmpb	(r1),#^a/+/		; check for exponent sign
	beql	45$			; br if found
	cmpb	(r1),#^a/-/		; minus?
	bneq	50$			; br if no sign
45$:	incl	r1			; point past the sign char
	decl	r0
50$:	cmpl	r4,#15			; is prec. huge?
	bgtr	100$			; if so, that's it
					; else, get exponent value
	subl	r0,sp			; get a stack temp
	pushr	#^m<r0,r4>		; save some regs
	movc3	r0,(r1),8(sp)		; copy exp. digits to temp
	popr	#^m<r0,r4>		; restore regs
	clrq	-(sp)			; more temps
	movb	#32,7(sp)		; make a leading sep. string
	pushl	r0			; save size
	cvtsp	r0,11(sp),#4,8(sp)	; cvrt exponent to packed
	cvtpl	#4,8(sp),4(sp)		; cvrt packed to long
	cmpl	4(sp),#38		; see if exponent is huge
	bleq	60$			; if not, br
	movl	#34,r4			; plug max. huge prec.
60$:	addl	(sp)+,sp		; clean off the stack
	clrq	(sp)+
100$:
	movl	r4,r3			; return result in r3
	popr	#^m<r0,r1,r2,r4,r5>	; restore regs
	rsb
 
	.end

