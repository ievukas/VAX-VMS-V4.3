	.TITLE UETUNAS00 VAX/VMS UETP DEVICE TEST FOR THE UNA
	.IDENT	'V04-000'
	.ENABLE SUPPRESSION
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:
;	This module will be distributed with VAX/VMS under the [SYSTEST]
;	account.
;
; ABSTRACT:
;	This test exercises a UNA device using VMS QIO's. It is run as
;	part of the VAX/VMS UETP.
;
; ENVIRONMENT:
; 	This program will run in user access mode, with ASTs enabled except
;	during error processing.  This program requires the following
;	privileges and quotas:
;
;--
;
; AUTHOR: Larry Jones,	CREATION DATE: September 03, 1982
;
; MODIFIED BY:
;
;	V03-010	RNH0010		Richard N. Holstein,	08-Aug-1984
;		Extend V03-009 and prevent potential hang.
;
;	V03-009	RNH0009		Richard N. Holstein,	11-Jul-1984
;		Make the test more robust when performing the remote loopback
;		operations - allow for the Ethernet's uncertainty by
;		retransmitting messages.
;
;	V03-008	RNH0006		Richard N. Holstein,	15-Feb-1984
;		Take advantage of new UETP message codes.  Fix SSERROR
;		interaction with RMS_ERROR.  Change UETUNT$T_FILSPC field
;		to be ASCID instead of ASCIC for better error messages.
;
;	V03-007	RNH0005		Richard N. Holstein,	03-Jan-1984
;		Bump MIN_MAXBUF to the new minimum value for the DEUNA.
;
;	V03-006	RNH0004		Richard N. Holstein,	19-Dec-1983
;		Give correct sentinels to Test Controller.  Use LIB$SIGNAL or
;		$PUTMSG throughout, instead of LIB$PUT_OUTPUT.
;
;	V03-005	RNH0003		Richard N. Holstein,	06-Dec-1983
;		Give an error message and abort execution if the SYSGEN MAXBUF
;		parameter is too small.  Change wording of CASE_FAILED message.
;
;	V03-004	RNH0002		Richard N. Holstein,	21-Nov-1983
;		Use decimal conversion routine for unit numbers.
;
;	V03-003	RNH0001		Richard N. Holstein,	11-Mar-1983
;		Don't signal ending message in EXIT_HANDLER.
;
;	V03-002	LDJ0002		Larry D. Jones,		28-Feb-1983
;		Fixed error message assembly error.
;
;	V03-001	LDJ0001		Larry D. Jones,		10-Feb-1983
;		Upgraded to conform to new template standards.
;**

	.SBTTL	Declarations
;
; INCLUDE FILES:
;
;	SYS$LIBRARY:LIB.MLB	for general definitions
;	SHRLIB$:UETP.MLB	for UETP definitions

;
; MACROS:
;
	$CHFDEF				; Condition handler frame definitions
	$DCDEF				; Device definitions
	$DIBDEF				; Device Information Block
	$DVIDEF				; $GETDVI ITMLST item codes
	$NMADEF				; Network management definition
	$SHRDEF				; Shared messages
	$SYIDEF				; $GETSYI ITMLST item codes
	$STSDEF				; Status return
	$UETUNTDEF			; UETP unit block offset definitions
	$UETPDEF			; UETP
	$XMDEF				; XMDRIVER symbols

	.MACRO TBL_ENT ENT,VALUE,STRING
		.=PC1...
		.WORD	<ENT@15>!VALUE
		.ADDRESS PC2...
		PC1...= .
		.=PC2...
		.ASCIC	/STRING/
		PC2...=.
	.ENDM TBL_ENT
;
; EQUATED SYMBOLS:
;
;   Facility number definitions:
	RMS$_FACILITY = 1

;   SHR message definitions:
	UETP = UETP$_FACILITY@STS$V_FAC_NO	; Define the UETP facility code
;
	UETP$_ABENDD = UETP!SHR$_ABENDD	; Define the UETP message codes
	UETP$_BEGIND = UETP!SHR$_BEGIND
	UETP$_ENDEDD = UETP!SHR$_ENDEDD
	UETP$_TEXT   = UETP!SHR$_TEXT

;   Internal flag bits...:
	DUMP_MODEV   = 0		; Set if running in dump mode
	ASSUME DUMP_MODEV EQ 0		; This so we can BLBx
	TEST_OVERV   = 1		; Set when test is over
	SAFE_TO_UPDV = 2		; Set when it's safe to update UETINIDEV
	BEGIN_MSGV   = 3		; Set if "BEGIN" msg has been printed
	FLAG_SHUTDNV = 4		; Set to indicate device should be
					; shutdown if errors occur
	ID_FNDV	     = 5		; Remote UNA found
	BRDCST_NEDEDV= 6		; Broadcast for another UNA required
	LONGORSHRTV  = 7		; Long or short report (if set then short)

;   ...and corresponding masks:
	DUMP_MODEM   = 1@DUMP_MODEV
	TEST_OVERM   = 1@TEST_OVERV
	SAFE_TO_UPDM = 1@SAFE_TO_UPDV
	BEGIN_MSGM   = 1@BEGIN_MSGV
	FLAG_SHUTDNM = 1@FLAG_SHUTDNV
	ID_FNDM      = 1@ID_FNDV
	BRDCST_NEDEDM= 1@BRDCST_NEDEDV
	LONGORSHRTM  = 1@LONGORSHRTV

;   Miscellany:
	LC_BITM        = ^X20		; Mask to convert lower case to upper
	REC_SIZE      = 40		; UETINIDEV.DAT record size
	TEXT_BUFFER   = 132		; Internal text buffer size
	XMIT_EFN       = 5		; EFN used for transmit QIO's
	RECV_EFN       = 6	        ; EFN used for receive QIO's
	RDID_EFN       = 7		; EFN used for read request
	EFN2           = 4		; EFN used for three minute timer
	SS_SYNCH_EFN  = 3		; Synch miscellaneous system services
	MAX_PROC_NAME  = 15		; Longest possible process name
	MAX_DEV_DESIG  = 10		; Longest possible controller name
	MAX_UNIT_DESIG = 5		; Longest possible unit number
	TBL_SIZE       = 7		; Number of device counters in table
	LIN            = 0		; Line counter ID number
	PRM            = 100		; Test AST parameter
	RECVPOOL_SIZ   = 4		; Number of preallocated message block
	RW_TIME_ID     = 3		; Timer ID to prevent hang when Read/write
	TIME_ID_1      = 1              ; Timer ID to prevent over all hang
	TIME_ID_2      = 2              ; Timer ID to use on REQUEST
	DIAG_BUF_SIZE  = 80		; UNA Diagnostic buffer size
	REQUEST_BUFSIZ = 1500		; Read request buffer size
	MAX_UNABUF_SIZE= 1500		; Maximum UNA transfer size
	FORWARD_MSG_SIZ= 14		; Size of a forward message header
	ERRCNT_LEN     = 128		; Counters size
	MIN_MAXBUF     = 1584		; Minimum value fo SYSGEN's MAXBUF
	RETRY_COUNT = 4			; Count of retries for remote loopback

	HARD_ADR       = ^X2A		; Diagnostic buffer offset to the
					; NI hardware address
	PCSR1	       = ^X1A		; Diagnostic buffer offset to the
					; PCSR1 register contents
	PCSR1$V_XPWR   = 15		; NI cable connected indicator
	PCSR1$V_ICAB   = 14		; Internal cable connected indicator
	PCSR1$V_SLFTST = 8		; Self test error code indicator
	PCSR1$S_SLFTST = 6

	LOOP_PROTOCOL  = ^X90		; Digital loop protocol number

;   The following definitions are set depending on the device under test.
;   Note that we use the UETUNT$T_FILSPC field differently from most tests.  We
;   have an ASCID data type instead of an ASCIC data type.
	DEVDEP_SIZE   = 0		; Size of device dependent part of UETUNT
	WRITE_SIZE    = 1500		; Size of device write buffer
	READ_SIZE     = 1500		; Size of device read buffer

	PAGES = <<UETUNT$C_INDSIZ+-	; Add together all of the pieces...
		  DEVDEP_SIZE+-		; ...which make up a UETP unit block...
		  WRITE_SIZE+-		; ...to give to the $EXPREG service below
		  READ_SIZE+-
		  511>/512>


	.SBTTL	Read-Only Data
	.PSECT	RODATA,NOEXE,NOWRT,PAGE

ACNT_NAME:				; Process name on exit
	.ASCID	/SYSTEST/

TEST_NAME:				; This test name
	.ASCID	/UETUNAS00/

SUPDEV_GBLSEC:				; How we access UETSUPDEV.DAT
	.ASCID	/UETSUPDEV/

CONTROLLER:				; Logical name of controller
	.ASCID	/CTRLNAME/

MODE:					; Run mode logical name
	.ASCID	/MODE/

LOGNAM:					; Logical name for remote address testing
	.ASCID	/TESTNIADR/

NO_RMS_AST_TABLE:			; List of errors for which...
	.LONG	RMS$_BLN		; ...RMS cannot deliver an AST...
	.LONG	RMS$_BUSY		; ...even if one has an ERR= arg
	.LONG	RMS$_CDA		; Note that we can search table...
	.LONG	RMS$_FAB		; ...via MATCHC since <31:16>...
	.LONG	RMS$_RAB		; ...pattern can't be in <15:0>
NRAT_LENGTH = .-NO_RMS_AST_TABLE

SYS$INPUT:				; Name of device from which...
	.ASCID	/SYS$INPUT/		; ...the test can be aborted

INPUT_ITMLST:				; $GETDVI arg list for SYS$INPUT
	.WORD	64,DVI$_DEVNAM		; We need the equivalence name
	.LONG	BUFFER,BUFFER_PTR
	.LONG	0			; Terminate the list

REPORT:					; Long or short report logical name
	.ASCID	/REPORT/

CS1:					; Device class and type control string
	.ASCID	/!2XB !2XB /

CS3:					; Device class-only control string
	.ASCID	/!2XB **/

INIDEV_UPDERR:				; Error during exit handler
	.ASCID	/Error updating UETINIDEV.DAT./

DUMP:					; Equivalence string for MODE logical...
	.ASCID	/DUMP/			; ...name to specify dump mode actions

NIADRWRONG:
	.ASCID	/NI address specified by logical name TESTNIADR is illegal length./

NIADRTESTING:
	.ASCID	/Remote UNA address testing is !2XB-!2XB-!2XB-!2XB-!2XB-!2XB./

ID_CTRSTR:
	.ASCID	/UNA hardware address is !2XB-!2XB-!2XB-!2XB-!2XB-!2XB./

REMOTE_ID_CTR:
	.ASCID	/Remote UNA address found of !2XB-!2XB-!2XB-!2XB-!2XB-!2XB./

REMOTE_NOTFND:
	.ASCID	/Remote UNA not detected on the NI./

BADLEN:					; Message received was wrong length
	.ASCID	/Message #!UL received with wrong length, got !UW, expected !UW./

COUNTER_MSG:
	.ASCID	/Non-zero UNA counter "!AC" = !UL./

CASE_FAILED:
	.ASCID	/Unrecognized counter in NICE message./

TTNAME_ROPTR:				; Descriptor for recursive...
	.WORD	63,0			; ...translation of TTNAME
	.ADDRESS TTNAME

CNTRLCMSG:
	.ASCID	\Aborted via a user CTRL/C\

NO_CTRLNAME:
	.ASCID	/No controller specified./

DEAD_CTRLNAME:
	.ASCID	/Can't test controller !AS, marked as unusable in UETINIDEV.DAT./

NOUNIT_SELECTED:
	.ASCID	/No units selected for testing./

CAB1_UNPLUGED:
	.ASCID	/WARNING the NI cable is disconnected./

CAB2_UNPLUGED:
	.ASCID	/The UNA inter-module cable is unplugged./

ILLEGAL_REC:
	.ASCID	/Illegal record format in file UETINIDEV.DAT!/

TIMEOUT1:
	.ASCID	/One shot startup timeout./

TIMEOUT2:
	.ASCID	/Normal mode startup timeout./

TIMEOUT3:
	.ASCID	\Echo mode transmit/receive loop timeout.\

TIMEOUT4:
	.ASCID	/Echo mode shutdown timeout./

TIMEOUT5:
	.ASCID	/Transmit to broadcast address startup timeout./

TIMEOUT6:
	.ASCID	/Transmit to broadcast address timeout./

TIMEOUT7:
	.ASCID	/Transmit to broadcast address shutdown timeout./

TIMEOUT8:
	.ASCID	/External loopback startup timeout./

TIMEOUT9:
	.ASCID	/Hung while trying to transmit during the remote loopback test./

TIMEOUT10:
	.ASCID	/Sensemode timeout./

TIMEOUT11:
	.ASCID	/Read counters timeout./

RETRY_MSG:				; Indicate retransmission in rmt loop
	.ASCID	\All !UL messages in the remote loopback test were transmitted\-
		\!/!_successfully, but only after some were retransmitted.\

LOOPBACK_FAIL_MSG:			; Couldn't loop some messages
	.ASCID	\!UL message!%S with size!%S of!#(5UL) were not received\-
		\!/!_by the remote loopback test, even after retransmission.\

RETRANS_MSG:				; Retransmit for remote loopback
	.ASCID	/!UL attempt!%S to send message #!UL failed, size !UW, !%T./

LOOPBACK_TMO_MSG:			; Timeout during remote loopback
	.ASCID	/Remote loopback timeout at !%T for message #!UL./

OUT_OF_SEQ_MSG:				; Wrong or duplicate msg received
	.ASCID	/Expected msg #!UL, length !UW, got msg #!UL, length !UW at !%T./

ABORT_MSG:				; IOSB has SS$_ABORT in remote loopback
					; Intentional failure, msg for info only
	.ASCID	/Unlooped messages through #!UL have been aborted./

TIME_STAMP_MSG:
	.ASCID	\Xmit=0/recv=1: !UW, length: !4UW, message #!5UL, time: !%T\

TIME_STAMP_INTRO_MSG:
	.ASCID	\IOSB is !XL, !XL; summary of recent messages follows:\

PASS_MSG:
	.ASCID	/End of pass !UL with !UL iterations at !%D./

;
;	Table containing the identification for the names of all the
;	UNA device counters.
;

CNTR_TBL:
	PC1... = .
	.=.+<TBL_SIZE*6>
TBL_END:

;
; *** WARNING *** TBL_SIZE must be modified to reflect the number of entries
;		  in the following table.
;

	PC2... = .
	.LIST MEB
	TBL_ENT LIN,NMA$C_CTLIN_RFL,<packets received in error>
	.NLIST MEB
	TBL_ENT LIN,NMA$C_CTLIN_OVR,<receives lost (internal buffer error)>
	TBL_ENT LIN,NMA$C_CTLIN_LBE,<receives lost (local buffer error)>
	TBL_ENT LIN,NMA$C_CTLIN_BSM,<packets transmitted with over 1 collision>
;	TBL_ENT LIN,NMA$C_CTLIN_TFL,<transmit packets aborted>
	TBL_ENT LIN,NMA$C_CTLIN_CDC,<transmit collision check failures>
;	TBL_ENT LIN,NMA$C_CTLIN_NPT,<no protocol type enabled>
	TBL_ENT LIN,NMA$C_CTLIN_SBU,<system buffer errors>
	TBL_ENT LIN,NMA$C_CTLIN_UBU,<user buffer errors>

SIZE_TBL:				; Table of transfer sizes for echo mode
	.LONG	1			; Smallest size transfer
	.LONG	43			; Smallest pad possible
	.LONG	44			; No padding done
	.LONG	1498			; Largest transfer with padding on
	SIZE_TBL_SIZE = <.-SIZE_TBL>/4

SIZE_TBL1:				; Table of transfer sizes for external
					; loopback mode
	.LONG	46			; Smallest size transfer
	.LONG	127			; Quarter page-1
	.LONG	511			; Page-1
	.LONG	1500			; Largest transfer with padding off
	ASSUME <<.-SIZE_TBL1>/4> EQ SIZE_TBL_SIZE 

TENSEC:					; 10 seconds delta time
	.LONG	-10*1000*1000*10,-1

TWENSEC:				; 20 seconds delta time
	.LONG	-10*1000*1000*20,-1

HALFMIN:				; 30 seconds delta time
	.LONG	-10*1000*1000*30,-1

TWOMIN:					; Two minute delta time
	.LONG	-10*1000*1000*120,-1

THREEMIN:				; 3 minute delta time
	.LONG	-10*1000*1000*180,-1

UNIT_DESC:				; Descriptor used to convert unit #
	.LONG	5
	.ADDRESS BUFFER+6

CONT_DESC:				; Descriptor used to convert controller...
	.WORD	REC_SIZE,0		; ...from lowercase to uppercase
	.ADDRESS BUFFER

FILE:					; Fills in RMS_ERR_STRING
	.ASCID	/file/

RECORD:					; Fills in RMS_ERR_STRING
	.ASCID	/record/

RMS_ERR_STRING:				; Announces an RMS error
	.ASCID	/RMS !AS error in file !AD/

PROMPT:
	.ASCII	/Controller designation?: /
	PMTSIZ = .-PROMPT

SENSE_ERRMSG:
	.ASCID	/Error in sense mode test /

ERRTEST_MSG:
	.ASCID	/Error in error test /

ASTPAR_ERRMSG:
	.ASCID	/Error in QIO AST parameter /

SLFTST_FAILED:
	.ASCID	/UNA self test failed with an error code of !XL./

GETSYI_ITMLST:				; Check system parameters...
	.WORD	4,SYI$_MAXBUF		; ...to see if we have sufficient MAXBUF
	.ADDRESS MAXBUF,0
	.LONG	0			; End of ITMLST

MAXBUF_MSG:				; Tell user to set adequate SYSGEN param
	.ASCID	\The SYSGEN MAXBUF parameter is only !UL.\-
		\!/!_This test requires that the value be at least !UL.\

	.SBTTL	Read/Write Data
	.PSECT	RWDATA,WRT,NOEXE,PAGE

TTCHAN:					; Channel associated with ctrl. term.
	.WORD	0

TTNAME_RWPTR:				; Descriptor for recursive...
	.WORD	TTNAME_LEN,0		; ...translation of TTNAME
	.ADDRESS TTNAME
TTNAME:
	.ASCII	/SYS$INPUT/
	TTNAME_LEN=.-TTNAME
	.BLKB	63-TTNAME_LEN

FLAG:					; Miscellaneous flag bits
	.WORD	0			; (See Equated Symbols for definitions)

FAO_BUF:				; FAO output string descriptor
	.WORD	TEXT_BUFFER,0
	.ADDRESS BUFFER

BUFFER_PTR:				; Fake .ASCID buffer for misc. strings
	.WORD	TEXT_BUFFER,0		; A word for length, a word for desc.
	.ADDRESS BUFFER

BUFFER:					; FAO output and other misc. buffer
	.BLKB	TEXT_BUFFER

REQUEST_BUF:
	.BLKB	REQUEST_BUFSIZ

DEVDSC:					; Device name descriptor
	.WORD	MAX_DEV_DESIG,0
	.ADDRESS DEV_NAME


PROCESS_NAME:				; Process name
	.ASCID	/UNAS/

	PROCESS_NAME_FREE = MAX_PROC_NAME-<.-8-PROCESS_NAME>
	.BLKB	PROCESS_NAME_FREE

DEV_NAME:				; Device name buffer
	.BLKB	MAX_DEV_DESIG+MAX_UNIT_DESIG
	NAME_LEN = .-DEV_NAME



DIB:					; Device Information Block
	.WORD	DIB$K_LENGTH,0
	.ADDRESS DIBBUF
DIBBUF:
	.BLKB	DIB$K_LENGTH

ERROR_COUNT:				; Cumulative error count at runtime
	.LONG	0

STATUS:					; Status value on program exit
	.LONG	0

QUAD_STATUS:				; IO status block for misc sys. svcs.
	.QUAD	0

INADDRESS:				; $CRMPSC address storage
	.LONG	0,0
OUTADDRESS:
	.LONG	0,0

UNIT_NUMBER:				; Current dev unit number for GET_LINE
	.WORD	0

DEVNAM_LEN:				; Current device name length
	.WORD	0

RANDOM1:				; Random word #1
	.LONG	^XAAAAAAAA

RANDOM2:				; Random word #2
	.LONG	^XA72EA72E

ITERATION:				; # of times all tests were executed
	.LONG	0

PASS:					; Pass count
	.LONG	0

MSG_BLOCK:				; Auxiliary $GETMSG info
	.BLKB	4

EXIT_DESC:				; Exit handler descriptor
	.LONG	0
	.ADDRESS EXIT_HANDLER
	.LONG	1
	.ADDRESS STATUS

ARG_COUNT:				; Argument counter used by ERROR_EXIT
	.LONG	0

;
; Head of self-relative UETP unit block list.
;
	.ALIGN QUAD

UNIT_LIST:				; Head of unit block circular list
	.QUAD	0

NEW_NODE:				; Newly acquired node address
	.QUAD	0

RSLLEN:
	.LONG	0

RSLBUF:
	.LONG	64
	.ADDRESS .+4
	.BLKB	64

CVTRSL:
	.LONG	0

XE_CHAN:				; UNA circuit channel
	.WORD	0

XE_CHAN1:				; UNA circuit channel for protocol 260
	.WORD	0

ARG_LIST:
	.BLKL	6

P1BUF:					; P1 Device char buffer
	.QUAD	0

P2_PARAM:
	.WORD	NMA$C_PCLI_BUS		; Buffer size
	.LONG	MAX_UNABUF_SIZE

	.WORD	NMA$C_PCLI_BFN		; Buffer number
	.LONG	5

	.WORD	NMA$C_PCLI_PRM		; Promiscuous mode
	.LONG	NMA$C_STATE_OFF		; OFF

	.WORD	NMA$C_PCLI_MLT		; Multicast address state
	.LONG	NMA$C_STATE_OFF		; OFF

	.WORD	NMA$C_PCLI_DCH		; Data chaining
	.LONG	NMA$C_STATE_OFF		; OFF

	.WORD	NMA$C_PCLI_CRC		; CRC
	.LONG	NMA$C_STATE_ON		; ON

	.WORD	NMA$C_PCLI_PAD		; Padding
PAD_SWITCH:
	.LONG	NMA$C_STATE_ON		; ON

	.WORD	NMA$C_PCLI_PTY		; Protocol type
PROTOCOL:
	.LONG	0			; 0 

	.WORD	NMA$C_PCLI_EKO		; Echo mode
ECHO_SWITCH:
	.LONG	NMA$C_STATE_ON		; ON

	.WORD	NMA$C_PCLI_CON		; Controller mode of
	.LONG	NMA$C_LINCN_NOR		; Normal mode

	.WORD	NMA$C_PCLI_MCA		; Multicast address 
	.WORD	8
	.WORD	NMA$C_LINMC_SET		; set of
ADR:
	.BYTE	^XAB,00,00,02,00,00	; AB-00-00-02-00-00 which is
					; Digital remote console address
P2_DESC:
	.LONG	.-P2_PARAM
	.ADDRESS P2_PARAM


P2_PARAM1:
	.WORD	NMA$C_PCLI_BUS		; Buffer size
	.LONG	MAX_UNABUF_SIZE

	.WORD	NMA$C_PCLI_BFN		; Buffer number
	.LONG	5

	.WORD	NMA$C_PCLI_PRM		; Promiscuous mode
	.LONG	NMA$C_STATE_OFF		; OFF

	.WORD	NMA$C_PCLI_MLT		; Multicast address state
	.LONG	NMA$C_STATE_OFF		; OFF

	.WORD	NMA$C_PCLI_DCH		; Data chaining
	.LONG	NMA$C_STATE_OFF		; OFF

	.WORD	NMA$C_PCLI_CRC		; CRC
	.LONG	NMA$C_STATE_ON		; ON

	.WORD	NMA$C_PCLI_PAD		; Padding
	.LONG	NMA$C_STATE_ON		; ON

	.WORD	NMA$C_PCLI_PTY		; Protocol type
	.LONG	^X260			; 60-02

	.WORD	NMA$C_PCLI_EKO		; Echo mode
	.LONG	NMA$C_STATE_ON		; ON

	.WORD	NMA$C_PCLI_CON		; Controller mode of
	.LONG	NMA$C_LINCN_NOR		; Loopback mode

	.WORD	NMA$C_PCLI_MCA		; Multicast address 
	.WORD	8
	.WORD	NMA$C_LINMC_SET		; set of
	.BYTE	^XAB,00,00,02,00,00	; AB-00-00-02-00-00 which is
					; Digital remote console address
P2_DESC1:
	.LONG	.-P2_PARAM1
	.ADDRESS P2_PARAM1

ADR1:					; Read QIO address to fill in
	.BLKB	14

ADR2:					; Remote UNA hardware address
	.BLKB	14

BRDCST_BUF:
	.WORD	0			; Skip
	.WORD	2			; Function = Forward
SELF_ADR:
	.BLKB	6			; Address of self
	.WORD	1			; Function = Reply
	.WORD	^A/LJ/			; Receipt number
	.BLKB	46-<.-BRDCST_BUF>	; Padding
	BRDCST_BUF_LEN = .-BRDCST_BUF
	
SENSE_P1BUF:				; P1 buffer for sense mode test
	.QUAD	0

SENSE_P2DESC:				; P2 buffer descrip for sense mode test
	.LONG	SENSE_P2LEN
	.ADDRESS SENSE_P2BUF

SENSE_P2BUF:				; P2 buffer for sense mode test
	.BLKW	<3*24>			; 8 quad quad words for dev information
SENSE_P2LEN = .-SENSE_P2BUF		; P2 buffer length

ERRTST_P2DESC:				; P2 desc for error test
	.LONG	ERRTST_P2LEN
	.ADDRESS ERRTST_P2BUF

ERRTST_P2BUF:				; P2 buffer for error test
	.BLKQ	1
ERRTST_P2LEN = .-ERRTST_P2BUF

ERRCOUNT_DESC:				; Error counter buffer descrip
	.LONG	ERRCNT_LEN
	.ADDRESS ERRCNT_BUF

ERRCNT_BUF:				; Buffer for error counters
	.BLKL	ERRCNT_LEN

COUNTER:				; Counter value variable
	.LONG	0

END_ADR:				; Counter table end address
	.LONG	0

XE_IOSB:				; QIO IO status block for transmit
	.BLKQ	1

RCV_IOSB:				; QIO Io status block for receive
	.BLKQ	1

SAVE_STAT:				; Set aside status storage
	.WORD	0

XMIT_BUF_ADR:				; Transmit buffer pointer
	.LONG	0

RECV_BUF_ADR:				; Receive buffer pointer
	.LONG	0

DIAG_BUF:
	.BLKB	DIAG_BUF_SIZE

MAXBUF:					; Value of the SYSGEN MAXBUF param
	.BLKL	1

LOOPBACK_ACK:				; Flag bytes to signal if some...
	.BLKB	SIZE_TBL_SIZE		; ...message was transmitted OK...
					; ...during the remote loopback test

SBP:					; Pointer to current slot in...
	.ADDRESS STAMP_BUFFER		; ...STAMP_BUFFER

STAMP_BUFFER:				; Circular list in which to keep time...
					; ...stamps for remote loopback msgs
	.REPEAT	16			; We will have this many "slots", i.e.,
					; a history of this many time stamps
	; Note that xxxx_STAMP have dependencies built into them for the 
	; contents and length of the slots defined here.
	.BLKW				; Transmit/receive flag
	.BLKW				; Message length
	.BLKL				; Message sequence number (ITERATION)
	.BLKQ				; Time stamp
	.ENDR				; End of slot definition
	TSCLL = .-STAMP_BUFFER		; Time stamp circular list length

	.SBTTL	RMS-32 Data Structures
	.ALIGN	LONG

SYSIN_FAB:				; Allocate FAB for SYS$INPUT
	$FAB-
	FNM = <SYS$INPUT>

SYSIN_RAB:				; Allocate RAB for SYS$INPUT
	$RAB-
	FAB = SYSIN_FAB,-
	ROP = PMT,-
	PBF = PROMPT,-
	PSZ = PMTSIZ,-
	UBF = DEV_NAME,-
	USZ = NAME_LEN

INI_FAB:				; Allocate FAB for UETINIDEV
	$FAB-
	FAC = <GET,PUT,UPD>,-
	RAT = CR,-
	SHR = <GET,PUT,UPI>,-
	FNM = <UETINIDEV.DAT>

INI_RAB:				; Allocate RAB for UETINIDEV
	$RAB-
	FAB = INI_FAB,-
	RBF = BUFFER,-
	UBF = BUFFER,-
	USZ = REC_SIZE

DDB_RFA:				; RFA storage for INI_RAB
	.BLKB	6

	.ALIGN	LONG
SUP_FAB:				; Allocate FAB for UETSUPDEV
	$FAB-
	FAC = GET,-
	SHR = <UPI,GET>,-
	RAT = CR,-
	FOP = UFO,-
	FNM = <UETSUPDEV.DAT>

;
; Dummy FAB and RAB to copy to the UETP unit blocks
; The following FAB and RAB must be contiguous and in this order!
;

DUMMY_FAB:
	$FAB

DUMMY_RAB:
	$RAB	RSZ = WRITE_SIZE,-
		USZ = READ_SIZE

	.SBTTL	Main Program
	.PSECT	UNAS,EXE,NOWRT,PAGE

	.DEFAULT DISPLACEMENT,WORD

;+
;	Start up the UNA test.  This entails some overhead necessary to cope
;	with both expected and unforseen conditions, figuring out just what
;	devices are to be tested, making sure we can test the indicated devices
;	and setting up writeable space for each device to be tested.
;-

.ENTRY UETUNAS00,^M<>			; Entry mask

	MOVAL	SSERROR,(FP)		; Declare exception handler
	$SETSFM_S ENBFLG = #1		; Enable system service failure mode
	$DCLEXH_S DESBLK = EXIT_DESC	; Declare an exit handler

	$OPEN	FAB = SYSIN_FAB,-	; Open SYS$INPUT
		ERR = RMS_ERROR
	$CONNECT RAB = SYSIN_RAB,-	; Connect RAB to SYS$INPUT
		 ERR = RMS_ERROR
	BBC	S^#DEV$V_TRM,-		; BR if SYS$INPUT is NOT a terminal
		SYSIN_FAB+FAB$L_DEV,10$
	$TRNLOG_S LOGNAM = CONTROLLER,-	; Allow terminal user to specify...
		  RSLLEN = DEVNAM_LEN,-	; ...a logial name...
		  RSLBUF = DEVDSC	; ...for the controller to test
	CMPL	R0,#SS$_NORMAL		; Was a controller specified?
	BEQL	PROC_CONT_NAME		; BR if it was - go process it
10$:
	$GET	RAB = SYSIN_RAB,-	; Read SYS$INPUT...
		ERR = RMS_ERROR		; ...for the controller name
	MOVW	SYSIN_RAB+RAB$W_RSZ,-	; Save the name length
		DEVNAM_LEN
	BNEQ	PROC_CONT_NAME		; BR if we got something
	MOVL	#SS$_BADPARAM,STATUS	; Save an exit status if not
	PUSHAL	NO_CTRLNAME		; Prepare for message...
	PUSHL	#1			; ...
	PUSHL	#UETP$_TEXT!STS$K_ERROR ; ...
	PUSHL	#3			; ...
	BRW	ERROR_EXIT		; ...to tell of bad setup

PROC_CONT_NAME:
	MOVZWL	DEVNAM_LEN,DEVDSC	; Set the device name length
	PUSHAL	DEVDSC			; Make sure...
	PUSHAL	DEVDSC			; ...that the specified controller...
	CALLS	#2,G^STR$UPCASE		; ...is all uppercase for later comaparison
	ADDL3	#1,DEVDSC,R2		; Estimate the eventual...
	ADDW2	R2,PROCESS_NAME		; ...process name length (incl. "_")
	MOVAL	PROCESS_NAME+8-		; Locate first available byte...
		+MAX_PROC_NAME-		; ...in process name handle...
		-PROCESS_NAME_FREE,R0	; ...for device name
	SUBL3	#PROCESS_NAME_FREE,-	; Will the device name fit...
		R2,R1			; ...in the remaining space?
	BLEQ	10$			; BR if it will
	SUBL2	R1,R0			    ; Overwrite handle otherwise...
	MOVW	#MAX_PROC_NAME,PROCESS_NAME ; ...and define the maximum length
10$:
	MOVB	#^A/_/,(R0)+		; Separate handle from device name
	MOVC3	DEVDSC,DEV_NAME,(R0)	; Concatenate handle with device name
	CLRL	-(SP)			; Set the time stamp flag
	PUSHAL	TEST_NAME		; Set the test name
	PUSHL	#2			; Push the argument count
	PUSHL	#UETP$_BEGIND!STS$K_SUCCESS ; Set the message code
	CALLS	#4,G^LIB$SIGNAL		; Print the startup message
	BISW2	#BEGIN_MSGM,FLAG	; Set flag so we don't print it again
	$SETPRN_S PRCNAM = PROCESS_NAME	; Set the process name to UETDMPF00_x

	BBC	S^#DEV$V_TRM,-		; BR if SYS$INPUT is NOT a terminal
		SYSIN_FAB+FAB$L_DEV,20$
	$GETDVI_S DEVNAM = SYS$INPUT,-   ; Get the name of...
		  EFN    = #SS_SYNCH_EFN,- ; ...device which may abort test
		  ITMLST = INPUT_ITMLST,-
		  IOSB   = QUAD_STATUS
	BLBC	QUAD_STATUS,20$		; Avoid CTRL/C handler if any error
	$ASSIGN_S DEVNAM = BUFFER_PTR,-	; Set up for CTRL/C AST handler
		  CHAN   = TTCHAN
	$QIOW_S	CHAN     = TTCHAN,-	; Enable CTRL/C AST's...
		FUNC     = #IO$_SETMODE!IO$M_CTRLCAST,-
		P1       = CCASTHAND
	PUSHAL	PROCESS_NAME		; ...and tell the user...
	PUSHL	#1			; ...
	PUSHL	#UETP$_ABORTC!STS$K_SUCCESS ; ...how to abort gracefully...
	CALLS	#3,G^LIB$SIGNAL		; ...
20$:

;
; From UETINIDEV.DAT and UETSUPDEV.DAT, get information which gives controller
; and unit configuration and lets us know if the setup to run this test was
; done correctly.
;
	$OPEN	FAB = INI_FAB,-		; Open file "UETINIDEV.DAT"
		ERR = RMS_ERROR
	$CONNECT RAB = INI_RAB,-	; Connect the RAB and FAB
		 ERR = RMS_ERROR
	$MGBLSC_S  INADR = INADDRESS,-	; Connect to UETSUPDEV global section
		  RETADR = OUTADDRESS,-
		  GSDNAM = SUPDEV_GBLSEC,-
		   FLAGS = #SEC$M_EXPREG
	CMPL	R0,#SS$_NOSUCHSEC	; Was the section already there?
	BNEQ	30$			; BR if it was...
	$OPEN	FAB = SUP_FAB,-		; ...else open "UETSUPDEV.DAT"
		ERR = RMS_ERROR
	$CRMPSC_S CHAN = SUP_FAB+FAB$L_STV,- ; Create the global section
		 INADR = INADDRESS,-
		RETADR = OUTADDRESS,-
		GSDNAM = SUPDEV_GBLSEC,-
		 FLAGS = #SEC$M_EXPREG!SEC$M_GBL
30$:
	SUBL3	OUTADDRESS,OUTADDRESS+4,R6 ; Compute global section length

FIND_IT:
	$GET	RAB = INI_RAB,-		; Get the first record
		ERR = RMS_ERROR
	PUSHAL	CONT_DESC		; Make sure...
	PUSHAL	CONT_DESC		; ...that the controller name...
	CALLS	#2,G^STR$UPCASE		; ...is all uppercase letters
	CMPB	#^A/D/,BUFFER		; Is this a DDB?
	BEQL	10$			; Go on if not
	CMPB	#^A/E/,BUFFER		; Is this the end of the file?
	BNEQ	FIND_IT			; Continue on if not
	PUSHAL	DEVDSC			; Push device not supported message
	PUSHAL	PROCESS_NAME		; Parameters on the stack
	PUSHL	#2
	PUSHL	#UETP$_DENOSU
	INSV	#STS$K_ERROR,-
		#STS$V_SEVERITY,-
		#STS$S_SEVERITY,(SP)	; Set the severity code...
	MOVL	(SP),STATUS		; ...and save it as the exit status
	PUSHL	#4
	BRW	ERROR_EXIT		; Exit in error
10$:
	CMPC	DEVNAM_LEN,BUFFER+6,DEV_NAME ; Is this the right controller?
	BNEQ	FIND_IT			; BR if not
	MOVC3	#6,INI_RAB+RAB$W_RFA,DDB_RFA ; Save the Record File Address
	CMPB	#^A/T/,BUFFER+4		; Can we test this controller?
	BEQL	FOUND_IT		; BR if we can...
	$FAO_S	CTRSTR = DEAD_CTRLNAME,- ; ...and yell at user if we can't
		OUTLEN = BUFFER_PTR,-
		OUTBUF = FAO_BUF,-
		P1     = #DEVDSC
	MOVL	#SS$_BADPARAM,STATUS	; Set return status
	PUSHAL	BUFFER_PTR		; ...
	PUSHL	#1			; ...
	PUSHL	#UETP$_TEXT!STS$K_ERROR	; ...
	PUSHL	#3			; ...
	BRW	ERROR_EXIT		; We can't test what we can't test

FOUND_IT:
	$GET	RAB = INI_RAB,-		; Get a record
		ERR = RMS_ERROR
	PUSHAL	CONT_DESC		; Make sure...
	PUSHAL	CONT_DESC		; ...that this line...
	CALLS	#2,G^STR$UPCASE		; ...is all uppercase letters
	CMPB	#^A/U/,BUFFER		; Is this a UCB?
	BEQL	30$			; BR if it is
	CMPB	#^A/D/,BUFFER		; Is this a DDB?
	BEQL	20$			; BR if yes
	CMPB	#^A/E/,BUFFER		; Is this the end?
	BEQL	20$			; BR if yes
10$:
	PUSHAL	ILLEGAL_REC		; Then this is an error in the record
	PUSHL	#1			; Push the error message
	PUSHL	#UETP$_TEXT!STS$K_ERROR ; Push the signal name
	PUSHL	#3			; Push the temp arg count
	BRW	ERROR_EXIT		; Finish for good
20$:
	BRW	ALL_SET			; Found DDB or END
30$:
	CMPB	#^A/T/,BUFFER+4		; Is the unit testable?
	BNEQ	FOUND_IT		; BR if not
	PUSHL	#1			; Flag to ignore blanks when converting
	PUSHL	#2			; Set byte size of results
	PUSHAL	UNIT_NUMBER		; Set address to receive word
	PUSHAL	UNIT_DESC		; Push string address
	CALLS	#4,G^OTS$CVT_TI_L	; Convert ASCII unit # to decimal
	BLBC	R0,10$			; Don't allow bogus unit to pass
	SKPC	#^A/ /,#MAX_UNIT_DESIG,- ; Find out where unit number really is
		BUFFER+6
	DECL	R0			; Units must all be at least one digit
	SKPC	#^A/0/,R0,(R1)		; Skip leading zeroes on the unit
	INCL	R0			; Compensate for DECL above
	ADDW3	R0,DEVNAM_LEN,DEVDSC	; Calculate device'unit string length
	MOVZWL	DEVNAM_LEN,R2		; Offset to unit number in DEVDSC
	MOVC3	R0,(R1),DEV_NAME(R2)	; Append unit number to device
	$GETDEV_S DEVNAM = DEVDSC,-	; Get the device characteristics
		  PRIBUF = DIB
	MOVZBL	DIBBUF+DIB$B_DEVCLASS,R7 ; Save the device class
	MOVZBL	DIBBUF+DIB$B_DEVTYPE,R8	; Save the device type
	$FAO_S	CTRSTR = CS1,-
		OUTBUF = FAO_BUF,-
		P1     = R7,-
		P2     = R8		; Make it into a string
	MATCHC	#6,BUFFER,R6,@OUTADDRESS ; Find the device class and type
	BEQL	40$			; BR if it was found
	$FAO_S	CTRSTR = CS3,-		; Try for full class support
		OUTBUF = FAO_BUF,-
		    P1 = R7
	MATCHC	#6,BUFFER,R6,@OUTADDRESS ; Find the device class only
	BNEQ	50$			; BR if not found
40$:
	MOVZBL	TEST_NAME,R5		; Get the test name length
	CMPC3	R5,(R3),TEST_NAME+8	; Are we the right test?
	BEQL	60$			; BR if yes
50$:
	PUSHAL	DEVDSC			; Push device not supported message
	PUSHAL	PROCESS_NAME		; Parameters on the stack
	PUSHL	#2			; Push the argument count
	PUSHL	#UETP$_DENOSU
	INSV	#STS$K_ERROR,-
		#STS$V_SEVERITY,-
		#STS$S_SEVERITY,(SP)	; Set the severity code...
	MOVL	(SP),STATUS		; ...and save it as the exit status
	PUSHL	#4			; Push the partial arg count...
	BRW	ERROR_EXIT		; ...and split this scene

;+
; The following code dynamically allocates enough memory for a unit block,
; a device dependent parameter area and I/O buffers. The unit block is inserted
; into the queue header UNIT_LIST.  It then initializes the unit block.
; A comment indicates where the device dependent parameters should be
; initialized.  The unit block format is as follows:
;
;			+---------------+ -------
;	UETUNT$L_FLINK	!		!	^
;			+---------------+	!
;	UETUNT$L_BLINK	!		!	!
;			+-----------+---+	!
;	UETUNT$B_TYPE		    !   !	!
;			    +-------+---+	!
;	UETUNT$W_SIZE	    !   !   !    contains DEVDEP_SIZE + UETUNT$C_INDSIZ
;			+---+-------+		!
;	UETUNT$B_FLAGS  !   !			!
;			+---+   +-------+	!
;	UETUNT$W_CHAN	        !   !   !	!
;			+-------+-------+	!
;	UETUNT$W_FUNC	!   !   !		!
;			+-------+-------+	+----- UETUNT$C_SIZE
;	UETUNT$L_ITER	!		!	!
;			+---------------+	!
;	UETUNT$T_FILSPC	!		!	!
;			!/\/\/\/\/\/\/\/!	!
;			NAM$C_MAXRSS bytes	!
;			!/\/\/\/\/\/\/\/!	!
;			!		!	!
;	UETUNT$K_FAB	!---------------!	!
;			!		!	!
;			!/\/\/\/\/\/\/\/!	!
;			 FAB$C_BLN bytes	!
;			!/\/\/\/\/\/\/\/!	!
;			!		!	!
;	UETUNT$K_RAB	+---------------+	!
;			!		!	!
;			!\/\/\/\/\/\/\/\!	!
;			 RAB$C_BLN bytes	!
;			!\/\/\/\/\/\/\/\!	!
;			!		!	v
;	UETUNT$K_DEVDEP	+---------------+ -------
;			!		!	^
;			!\/\/\/\/\/\/\/\!	!
;			   user defined		+----- DEVDEP_SIZE
;			!\/\/\/\/\/\/\/\!	!
;			!		!	v
;			+---------------+ -------
;    READ/WRITE buffers !		!	^
;			!\/\/\/\/\/\/\/\!	!
;			   user defined		+----- WRITE_SIZE and READ_SIZE
;			!/\/\/\/\/\/\/\/!	!
;			!		!	v
;			+---------------+ -------
;-

60$:
	$EXPREG_S PAGCNT = #PAGES,-	; Get a new node of demand zero memory
		  RETADR = NEW_NODE
	INSQTI	@NEW_NODE,UNIT_LIST	; Put the new node in the unit list
	MOVL	NEW_NODE,R6		; Save a copy of its address
	MOVB	#1,UETUNT$B_TYPE(R6)	; Set the structure type
	MOVW	#UETUNT$C_INDSIZ+DEVDEP_SIZE,-
		UETUNT$W_SIZE(R6)	; Set the structure size
	MOVL	DEVDSC,UETUNT$T_FILSPC(R6) ; Set the device name size...
	MOVAL	UETUNT$T_FILSPC+8(R6),-	   ; ...and pointer to the name
		UETUNT$T_FILSPC+4(R6)
	MOVC3	DEVDSC,@DEVDSC+4,-
		UETUNT$T_FILSPC+8(R6)	; Save the device name
	MOVC3	#FAB$C_BLN+RAB$C_BLN,-
		DUMMY_FAB,UETUNT$C_FAB(R6) ; Save a FAB and a RAB away
	MOVAL	UETUNT$K_FAB(R6),R7	; Save the FAB address
	MOVAL	UETUNT$K_RAB(R6),R8	; Save the RAB address
	MOVL	R7,RAB$L_FAB(R8)	; Set the FAB address in the RAB
	MOVB	UETUNT$T_FILSPC(R6),-
		FAB$B_FNS(R7)		; Set the FNS field in the FAB
	MOVAL	UETUNT$T_FILSPC+8(R6),-
		FAB$L_FNA(R7)		; Set the FNA field in the FAB
;
; Set the device dependent parameters in here
;
	BRW	FOUND_IT		; Do the next UCB

	.SBTTL	Test the DEUNA

;
; Arrive here when we have the device configuration.  In normal or loop forever
; mode, set a timer far enough in the future such that we can do a reasonable
; set of tests before the timer expires, but if our device gets hung, the
; program won't waste too much time before noticing.  Let one-shot mode be a
; special case.
;
ALL_SET:
	TSTL	UNIT_LIST		; Anything to test?
	BNEQ	10$			; BR if yes
	PUSHAL	NOUNIT_SELECTED		; Else set up the error message...
	PUSHL	#1			; ...argument count...
	PUSHL	#UETP$_TEXT!STS$K_ERROR	; ...signal name...
	PUSHL	#3			; ...and parameter count
	MOVL	#SS$_BADPARAM,STATUS	; Set return status
	BRW	ERROR_EXIT		; ...and give up, complaining
10$:
	BISW2	#SAFE_TO_UPDM,FLAG	; OK safe to update UETINIDEV.DAT now

	$GETSYI_S ITMLST = GETSYI_ITMLST ; Check for an adequate SYSGEN MAXBUF
	CMPL	#MIN_MAXBUF,MAXBUF	; Is it .GE. our minimum?
	BLEQ	12$			; BR if it is
	$FAO_S	CTRSTR = MAXBUF_MSG,-	; Complain if it isn't...
		OUTBUF = FAO_BUF,-
		OUTLEN = BUFFER_PTR,-
		P1     = MAXBUF,-
		P2     = #MIN_MAXBUF
	MOVZBL	S^#SS$_BADPARAM,STATUS
	PUSHAL	BUFFER_PTR
	PUSHL	#1
	PUSHL	#UETP$_TEXT!STS$K_SEVERE
	PUSHL	#3
	BRW	ERROR_EXIT		; ...and give up altogether
12$:
	$ASSIGN_S -			; Assign channel to the device
		DEVNAM = DEVDSC,-
		CHAN = XE_CHAN

	BLBC	R0,15$			; BR if no failure

	$ASSIGN_S -			; Assign channel to the device
		DEVNAM = DEVDSC,-
		CHAN = XE_CHAN1

	BLBS	R0,20$			; BR if no failure
15$:
	MOVL	R0,STATUS		; Save the failure status
	INCL	ERROR_COUNT		; Bump the error count
	PUSHL	STATUS			; Push the error code...
	PUSHL	STATUS
	PUSHAL	DEVDSC			; ...and the device designation...
	PUSHAL	TEST_NAME		; ...and the test name...
	PUSHL	#3			; ...and the arg count...
	PUSHL	#UETP$_DEUNUS!STS$K_ERROR ; ...and the signal name...
	PUSHL	#6			; ...and the total argument count...
	BRW	ERROR_EXIT		; ...and bail out completely
20$:
	$TRNLOG_S LOGNAM = REPORT,-	; Get the report mode
		  RSLLEN = BUFFER_PTR,-
		  RSLBUF = FAO_BUF
	BICB2	#LC_BITM,BUFFER		; Convert to upper case
	CMPB	#^A/S/,BUFFER		; Is this short report
	BNEQ	30$			; BR if not
	BISW2	#LONGORSHRTM,FLAG	; Set short report bit
30$:
	$TRNLOG_S LOGNAM = MODE,-	; Get the run mode
		  RSLLEN = BUFFER_PTR,-
		  RSLBUF = FAO_BUF
	PUSHAL	BUFFER_PTR
	PUSHAL	BUFFER_PTR
	CALLS	#2,G^STR$UPCASE
	MATCHC	DUMP,@DUMP+4,-		; Check for running in DUMP mode
		BUFFER_PTR,BUFFER
	BNEQ	35$			; BR if we are not
	BISW2	#DUMP_MODEM,FLAG	; Remember it if we are
35$:
	CMPB	#^A/O/,BUFFER		; Is this a one shot?
	BEQL	40$			; BR if not
	BRW	TIME_IT
40$:	; Fall into one shot testing

;
; Note: A startup is all that is needed to ONE SHOT test the UNA because
;	the driver performs an XE$C_DG_STEST diagnostic function on the
;	UNA in a startup sequence and the PCSR1 contents are checked by
;	the device test to make sure that the self test function completed
;	successfully. The XE$C_DG_STEST function performs a read write
;	verification of the UNA.
;

	$SETIMR_S -			; Set up ten second timer 
		DAYTIM = TWENSEC,-	; to prevent hang
		ASTADR = TIME_ERR_OUT,-
		REQIDT = #TIMEOUT1

	$SETSFM_S ENBFLG = #0		; Disable system service failure mode

	$QIOW_S FUNC = #IO$_SETCHAR!IO$M_CTRL!IO$M_STARTUP,-
		CHAN = XE_CHAN,-
		IOSB = XE_IOSB,-
		P2   = #P2_DESC,-
		P6   = #DIAG_BUF

	$SETSFM_S ENBFLG = #1		; Enable system service failure mode

	$CANTIM_S REQIDT = #TIMEOUT1	; OK, no timeout

	BBS	#LONGORSHRTV,FLAG,60$	; Skip output if short report
	CLRL	R2			; Make an index
	MOVAL	DIAG_BUF+HARD_ADR,R3	; Set address address
	MOVAL	ARG_LIST,R4		; Set arglist address
50$:
	MOVZBL	(R3)+,(R4)+		; Parse to bytes
	AOBLSS	#6,R2,50$

	$FAOL_S	CTRSTR = ID_CTRSTR,-
		OUTBUF = FAO_BUF,-
		OUTLEN = BUFFER_PTR,-
		PRMLST = ARG_LIST

	PUSHAL	BUFFER_PTR
	PUSHL	#^X10001
	PUSHL	#UETP$_TEXT!STS$K_INFO
	CALLS	#3,G^LIB$SIGNAL
60$:
	MOVL	DIAG_BUF+PCSR1,R2	; Get the PCSR1 register contents
	CMPW	R2,#3			; Is it error free and ready (3)
	BNEQ	70$			; BR if no
	BRW	100$			; BR if yes else...
70$:
	BBC	#PCSR1$V_ICAB,R2,80$	; ...check the internal cable connection.
	MOVZWL	XE_IOSB,STATUS		; Set return status
	PUSHAL	CAB2_UNPLUGED		; Push error message address
	PUSHL	#1
	PUSHL	#UETP$_TEXT!STS$K_WARNING ; Push message ID
	PUSHL	#3
	BRW	ERROR_EXIT		; Untestable if internal cable unplugged
80$:
	BBC	#PCSR1$V_XPWR,R2,90$	; Check the external cable connection.
	INCL	ERROR_COUNT		; Bump the error count
	PUSHAL	CAB1_UNPLUGED		; Push error message address
	PUSHL	#^XF0001
	PUSHL	#UETP$_TEXT!STS$K_WARNING ; Push message ID
	PUSHL	ERROR_COUNT		; Push the error count
	PUSHAL	PROCESS_NAME
	PUSHL	#^X10002
	PUSHL	#UETP$_ERBOXPROC!STS$K_WARNING
	CALLS	#7,G^LIB$SIGNAL		; Print the error message
90$:
	EXTZV	#PCSR1$V_SLFTST,-
		#PCSR1$S_SLFTST,-
		R2,R3			; Extract the self test error code

	$FAO_S	CTRSTR = SLFTST_FAILED,-
		OUTBUF = FAO_BUF,-
		OUTLEN = BUFFER_PTR,-
		P1 = R3

	MOVZWL	XE_IOSB,STATUS		; Set return status
	PUSHAL	BUFFER_PTR		; Push error message address
	PUSHL	#1
	PUSHL	#UETP$_TEXT!STS$K_ERROR ; Push message ID
	PUSHL	#3
	BRW	ERROR_EXIT		; Mark as untestable
100$:
	BSBW	CHECK_IOSB		; Check the IOSB results and exit if bad
	ADDL3	#UNIT_LIST,UNIT_LIST,R11 ; Get the unit block
	BISB2	#UETUNT$M_TESTABLE,-
		UETUNT$B_FLAGS(R11)	; This one is good
	$DASSGN_S CHAN = XE_CHAN1	; Deassign the extra channel
	BRW	CLEAN_EXIT		; ONE SHOT is over

TIME_IT:

;
; Set up P1 device char buffer, P2 buffer is set up in Read/write section
;
	MOVAL	P1BUF+2,R3		; Address of device char for p1
	MOVW	#MAX_UNABUF_SIZE,(R3)+	; Maximum message length
	MOVB	#XM$M_CHR_LOOPB,(R3) 	; Set loop back mode in char 
	MOVZBL	#^XAA,R2		; Random number 1
	MOVZBL	#^X2E,R3		; Random number 2
	MOVL	#MAX_UNABUF_SIZE,R4	; Maximum message length
	ADDL3	#UNIT_LIST,UNIT_LIST,R11 ; Get the unit block address
	MOVAL	UETUNT$K_DEVDEP(R11),R6 ; Get the transmit buffer address
	MOVAL	UETUNT$K_DEVDEP+WRITE_SIZE(R11),R10 ; Get the receive buffer address
	MOVAL	UETUNT$K_DEVDEP(R11),R8	; Xmit address
	MOVL	R8,XMIT_BUF_ADR		; Store xmit address
	MOVAL	WRITE_SIZE(R8),RECV_BUF_ADR ; Recv address
10$:
	ADDL2	R3,R2			; Random number as data
	MOVB	R2,(R6)+		; Fill in the transmit buffer
	SOBGTR	R4,10$			; Branch if more bytes to be filled

	$SETIMR_S DAYTIM = THREEMIN,-	; Set timer AST to 3 minutes
		  ASTADR = TIME_SUC_OUT,-
		  EFN    = #EFN2

	$TRNLOG_S LOGNAM = LOGNAM,-	; Get the TESTNIADR, if any
		  RSLLEN = RSLLEN,-
		  RSLBUF = RSLBUF

	CMPL	R0,#SS$_NOTRAN		; Was there any?
	BNEQ	20$			; BR if not
	BRW	70$			; Otherwise forget it
20$:
	CMPL	RSLLEN,#12		; Was it the right length?
	BEQL	30$			; BR if yes
	INCL	ERROR_COUNT
	PUSHAL	NIADRWRONG		; Report a bad address
	PUSHL	#^XF0001
	PUSHL	#UETP$_TEXT!STS$K_WARNING
	PUSHL	ERROR_COUNT
	PUSHAL	PROCESS_NAME
	PUSHL	#^X10002
	PUSHL	#UETP$_ERBOXPROC!STS$K_WARNING
	CALLS	#7,G^LIB$SIGNAL
	BRW	70$
30$:
	CLRL	R2			; Make an index
	MOVAL	ADR2+6,R3		; Set address address
	MOVAL	RSLBUF+8,R4		; Set arglist address
40$:
	PUSHAL	CVTRSL
	PUSHAB	(R4)
	PUSHL	#2
	CALLS	#3,G^LIB$CVT_HTB
	MOVB	CVTRSL,(R3)+
	ADDL2	#2,R4
	AOBLSS	#6,R2,40$
	BBS	#LONGORSHRTV,FLAG,60$	; Skip message if short report
	CLRL	R2			; Make an index
	MOVAL	ADR2+6,R3		; Set address address
	MOVAL	ARG_LIST,R4		; Set arglist address
50$:
	MOVZBL	(R3)+,(R4)+		; Parse to bytes
	AOBLSS	#6,R2,50$

	$FAOL_S CTRSTR = NIADRTESTING,- ; Format address
		OUTBUF = FAO_BUF,-
		OUTLEN = BUFFER_PTR,-
		PRMLST = ARG_LIST

	PUSHAL	BUFFER_PTR		; Output message
	PUSHL	#1
	PUSHL	#UETP$_TEXT+STS$K_INFO
	CALLS	#3,G^LIB$SIGNAL
60$:
	BRW	XMIT_START
70$:
	MOVL	#NMA$C_STATE_ON,PAD_SWITCH ; Set up dynamic characteristics
	MOVL	#NMA$C_STATE_ON,ECHO_SWITCH
	MOVL	#LOOP_PROTOCOL,PROTOCOL

	$SETIMR_S -			; Set up half minute timer 
		DAYTIM = HALFMIN,-	; to prevent hang
		ASTADR = TIME_ERR_OUT,-
		REQIDT = #TIMEOUT2
START_CONT:
	PUSHAL	XE_CHAN			; Start the UNA on the first channel
	PUSHAL	P2_DESC
	CALLS	#2,UNA_STARTUP

	PUSHAL	XE_CHAN1		; Start the UNA on the second channel
	PUSHAL	P2_DESC1
	CALLS	#2,UNA_STARTUP

	BISW2	#FLAG_SHUTDNM,FLAG	; Set flag to say shut down the
					; device if errors occur

	$CANTIM_S REQIDT = #TIMEOUT2	; Cancel hang timer

	MOVL	DIAG_BUF+HARD_ADR,SELF_ADR ; Set up NI return address
	MOVW	DIAG_BUF+HARD_ADR+4,-
		SELF_ADR+4

	$SETIMR_S DAYTIM = TWOMIN,-	; Set timer AST to 2 minutes
		  ASTADR = REQUEST_NOTFND,-
		  REQIDT = #TIME_ID_2

	$QIO_S -			; Do a read of data
		CHAN   = XE_CHAN1,-
		FUNC   = #IO$_READVBLK,-
		EFN    = #RDID_EFN,-
		IOSB   = XE_IOSB,-
		ASTADR = REQUEST_FND,-
		P1     = REQUEST_BUF,-
		P2     = #REQUEST_BUFSIZ,-
		P5     = #ADR2



RESTART:

;
; Loopback test transmit and receive random data with different message length
;

XMIT_LOOP:
	$SETIMR_S -			; Set half minute timer to prevent hang
		DAYTIM = HALFMIN,-
		ASTADR = TIME_ERR_OUT,-
		REQIDT = #TIMEOUT3

	CLRL	R6			; Set an index
	MOVAL	SIZE_TBL,R7		; Get size table address
XMIT:
	$QIO_S -			; Transmit data message
		EFN = #XMIT_EFN,-	; Event flag
		CHAN = XE_CHAN,-	; Channel
		FUNC = #IO$_WRITEVBLK,- ; Transmit
		IOSB = XE_IOSB,-	; IOSB
		ASTADR = CHK_QIO_AST,-	; Completion ast routine
		ASTPRM = #PRM,-		; Ast parameter
		P1 = @XMIT_BUF_ADR,-	; Addr of transmit buffer
		P2 = (R7)[R6],-		; message length in bytes
		P5 = #DIAG_BUF+HARD_ADR ; NI address

	$QIOW_S -			; Read data message
		EFN = #RECV_EFN,-	; Event flag
		CHAN = XE_CHAN,-	; Channel
		FUNC = #IO$_READVBLK,-	; Receive message
		IOSB = RCV_IOSB,-	; IOSB
		ASTADR = RECV_AST,-	; Completion ast to check data received
		ASTPRM = (R7)[R6],-	; Ast parameter = message length
		P1 = @RECV_BUF_ADR,-	; Receive buffer
		P2 = (R7)[R6],-		; Message length in bytes
		P5 = #ADR1		; NI address

	MOVC5	#0,@#RECV_BUF_ADR,#0,-
		#MAX_UNABUF_SIZE,@RECV_BUF_ADR ; Clear the read buffer
	INCL	ITERATION		; Increment iteration count
	AOBLSS	#SIZE_TBL_SIZE,R6,XMIT	; Loop for size_tbl_size times

	$CANTIM_S -			; Cancel hang timer
		REQIDT = #TIMEOUT3

	BBC	#TEST_OVERV,FLAG,10$	; Is the test over?
	BRW	SENSE_TEST
10$:
	BBC	#BRDCST_NEDEDV,FLAG,-
		20$			; BR if UNA adr found
	BRW	 DO_BRDCST		; BR if no UNA adr found in 2 minute
					; Read request
20$:
	BBS	#ID_FNDV,FLAG,30$	; BR if UNA adr found
	BRW	XMIT_LOOP		; BR if no UNA adr found yet
30$:
	$SETIMR_S -			; Set ten sec timer to prevent hang
		DAYTIM = TENSEC,-
		ASTADR = TIME_ERR_OUT,-
		REQIDT = #TIMEOUT4

	PUSHAL	XE_CHAN			; Shutdown the UNA on the first channel
	CALLS	#1,UNA_SHUTDOWN

	PUSHAL	XE_CHAN1		; Shutdown the UNA on the second channel
	CALLS	#1,UNA_SHUTDOWN

	$CANTIM_S REQIDT = #TIMEOUT4

XMIT_START:
	MOVL	#NMA$C_STATE_OFF,PAD_SWITCH ; Turn off padding
	MOVL	#NMA$C_STATE_OFF,ECHO_SWITCH ; Turn off echo mode
	MOVL	#LOOP_PROTOCOL,PROTOCOL ; Set to loop back protocol type

	$SETIMR_S -			; Set twenty sec timer to prevent hang
		DAYTIM = TWENSEC,-
		ASTADR = TIME_ERR_OUT,-
		REQIDT = #TIMEOUT5

	PUSHAL	XE_CHAN			; Startup a UNA channel in loopback
	PUSHAL	P2_DESC
	CALLS	#2,UNA_STARTUP

	MOVL	DIAG_BUF+HARD_ADR,SELF_ADR ; Set up NI return address
	MOVW	DIAG_BUF+HARD_ADR+4,-
		SELF_ADR+4


	$CANTIM_S REQIDT = #TIMEOUT5

	BRW	XMIT_SETUP		; Start external looping.

DO_BRDCST:
	$SETSFM_S ENBFLG = #0		; Disable errors
	$CANCEL_S CHAN = XE_CHAN1	; Give up the pending read request...
	$WAITFR_S EFN = #RDID_EFN	; ...and wait for it to die
	BICW2	#<ID_FNDM!BRDCST_NEDEDM>,FLAG ; Init the ID found and brdcst flag
	$SETSFM_S ENBFLG = #1		; Safe to turn on errors again

	$SETIMR_S -			; Set ten sec timer to prevent hang
		DAYTIM = TENSEC,-
		ASTADR = TIME_ERR_OUT,-
		REQIDT = #TIMEOUT4

	PUSHAL	XE_CHAN			; Shutdown the UNA on the first channel
	CALLS	#1,UNA_SHUTDOWN

	PUSHAL	XE_CHAN1		; Shutdown the UNA on the second channel
	CALLS	#1,UNA_SHUTDOWN

	$CANTIM_S REQIDT = #TIMEOUT4

	MOVL	#-1,ADR2		; UNA address to broadcast
	MOVW	#-1,ADR2+4
	MOVL	#NMA$C_STATE_OFF,PAD_SWITCH ; Turn off padding
	MOVL	#NMA$C_STATE_OFF,ECHO_SWITCH ; Turn off echo mode
	MOVL	#LOOP_PROTOCOL,PROTOCOL ; Set to loop back protocol type

	$SETIMR_S -			; Set twenty sec timer to prevent hang
		DAYTIM = TWENSEC,-
		ASTADR = TIME_ERR_OUT,-
		REQIDT = #TIMEOUT5

	PUSHAL	XE_CHAN			; Startup a UNA channel in loopback
	PUSHAL	P2_DESC
	CALLS	#2,UNA_STARTUP

	$CANTIM_S REQIDT = #TIMEOUT5

	$SETSFM_S ENBFLG = #0		; If not don't error hard

	$SETIMR_S -			; Set ten sec timer to prevent hang
		DAYTIM = TENSEC,-
		ASTADR = TIME_ERR_OUT,-
		REQIDT = #TIMEOUT6

	$QIO_S CHAN = XE_CHAN,-		; Xmit to the broadcast address
		FUNC = #IO$_WRITEVBLK,-
		IOSB = XE_IOSB,-
		ASTADR = CHK_QIO_AST,-	; Completion ast routine
		ASTPRM = #PRM,-		; Ast parameter
		P1 = BRDCST_BUF,-	; Addr of transmit buffer
		P2 = #BRDCST_BUF_LEN,-	; message length in bytes
		P5 = #ADR2		; NI broadcast address

	$CANTIM_S REQIDT = #TIMEOUT6

	$SETIMR_S DAYTIM = TENSEC,-	; Should get a response in ten seconds
		  ASTADR = ABRT_BRDCST,-
		  REQIDT = #TIME_ID_2

	$QIOW_S CHAN = XE_CHAN,-	; Receive from the broadcast address
		FUNC = #IO$_READVBLK,-
		IOSB = XE_IOSB,-
		ASTADR = REQUEST_FND,-	; Completion ast routine
		ASTPRM = #PRM,-		; Ast parameter
		P1 = @RECV_BUF_ADR,-	; Addr of receive buffer
		P2 = #MAX_UNABUF_SIZE,-	; message length in bytes
		P5 = #ADR2		; NI address

	MOVW	XE_IOSB,SAVE_STAT	; Save the read status

	$SETIMR_S -			; Set ten sec timer to prevent hang
		DAYTIM = TENSEC,-
		ASTADR = TIME_ERR_OUT,-
		REQIDT = #TIMEOUT7

	PUSHAL	XE_CHAN			; Shutdown the UNA
	CALLS	#1,UNA_SHUTDOWN

	$CANTIM_S REQIDT = #TIMEOUT7

	BLBS	SAVE_STAT,10$		; BR if read made it
	MOVL	#NMA$C_STATE_ON,PAD_SWITCH ; Turn padding back on
	MOVL	#NMA$C_STATE_ON,ECHO_SWITCH ; Turn echo back on
10$:

	$SETIMR_S -			; Set twenty sec timer to prevent hang
		DAYTIM = TWENSEC,-
		ASTADR = TIME_ERR_OUT,-
		REQIDT = #TIMEOUT8

	PUSHAL	XE_CHAN			; Restart the UNA
	PUSHAL	P2_DESC
	CALLS	#2,UNA_STARTUP

	$CANTIM_S REQIDT = #TIMEOUT8

	BLBS	SAVE_STAT,XMIT_SETUP	; If we got one then start external loopback

	PUSHAL	REMOTE_NOTFND		; Else report an error
	PUSHL	#1
	PUSHL	#UETP$_TEXT!STS$K_WARNING
	CALLS	#3,G^LIB$SIGNAL

	$SETSFM_S ENBFLG = #1		; It's OK now
	BICW2	#BRDCST_NEDEDM,FLAG	; We're giving up
	BRW	XMIT_LOOP		; Carry on in Echo mode

;
; When requesting looped back messages from a remote node, we have to account
; for the Ethernet's uncertainty:  messages are not guaranteed to reach their
; destination and it is the responsibility of the sender to retransmit them
; if they do not.  At the same time, UETP must terminate.  We therefore limit
; the number of attempts we will make at retransmission and the time we will
; wait for any one attempt to transmit.  Any I/O is $CANCELled after it
; completes or after we time out; if it were to complete later in the test it
; could give us inconsistent results.
;

XMIT_SETUP:
	MOVC3	#FORWARD_MSG_SIZ,-	 ; Put the forward message header in...
		BRDCST_BUF,@XMIT_BUF_ADR ; ...the transmit buffer
	MOVC5	#0,#0,#0,#TSCLL,-	; Clear out time stamps from previous...
		STAMP_BUFFER		; ...run (needed for LOOP mode)

REMOTE_LOOPBACK_TEST:
	MOVC5	#0,#0,#0,#SIZE_TBL_SIZE,- ; Clear flags which say that some...
		LOOPBACK_ACK		  ; ...transmission size succeeded
	CLRQ	R6			; Initialize counter for msg sizes...
					; ...and retransmission flag
	MOVAL	SIZE_TBL1,R8		; Point to table of message sizes
	MOVZWL	XE_CHAN,R9		; Stick channel in convenient holder
	$SETIMR_S DAYTIM = HALFMIN,-	; Allow time for messages to complete
		  ASTADR = LOOPBACK_TMO,-
		  REQIDT = #LOOPBACK_TMO
10$:	INCL	ITERATION		; Count the messages we're to receive
	CLRL	R10			; Limits retransmission attempts 
	MOVC5	#0,#0,#0,#MAX_UNABUF_SIZE,- ; Clear buffer into which...
		@RECV_BUF_ADR		    ; ...messages are read
	$QIO_S	EFN    = #RECV_EFN,-	; Be ready to read if the msg arrives
		CHAN   = R9,-
		FUNC   = #IO$_READLBLK,-
		IOSB   = RCV_IOSB,-
		ASTADR = LOOPBACK_AST,-
		ASTPRM = R6,-
		P1     = @RECV_BUF_ADR,-
		P2     = (R8),-
		P5     = #ADR1		; NI address

	BLBC	FLAG,20$		; Skip sequence number if normal running
	MOVL	XMIT_BUF_ADR,R11	; In dump mode, use sequence number...
	MOVL	ITERATION,10(R11)	; ...(ITERATION) to verify message
20$:	PUSHL	10(R11)
	PUSHL	(R8)
	CALLS	#2,XMIT_STAMP		; In dump mode, keep track of messages
	$QIOW_S	EFN    = #XMIT_EFN,-	; Tell some node to loop back a message
		CHAN   = R9,-
		FUNC   = #IO$_WRITELBLK,-
		IOSB   = XE_IOSB,-
		P1     = @XMIT_BUF_ADR,-
		P2     = (R8),-
		P5     = #ADR2+6	; Remote NI address
	$WAITFR_S EFN = #RECV_EFN	; Wait for message to be returned
	BLBS	LOOPBACK_ACK(R6),30$	; BR if this size message got through
	MOVL	#1,R7			; Indicate retransmission
	$CLREF_S EFN = #RECV_EFN	; Flag was set by timeout routine
	INCL	R10			; Figure which retransmission is next
	BLBC	FLAG,25$		; Skip message if normal running
	$FAO_S	CTRSTR = RETRANS_MSG,-
		OUTLEN = BUFFER_PTR,-
		OUTBUF = FAO_BUF,-
		P1     = R10,-
		P2     = ITERATION,-
		P3     = (R8),-
		P4     = #0
	BSBW	DUMP_SIGNAL
25$:	CMPL	#RETRY_COUNT,R10	; Loop to re-xmit...
	BGTR	20$			; ...if any attempts left
30$:	TSTL	(R8)+			; Point to the next message size
	ACBL	#SIZE_TBL_SIZE-1,#1,R6,10$ ; Loop while there are more msg sizes
	BLBC	R7,70$			; Skip msg if no retransmissions
	MOVL	SP,R10			; Save original SP for later cleanup
	CLRQ	R6			; Counter for msg sizes which failed...
					; ...(R7) and loop index (R6)
40$:	BLBS	LOOPBACK_ACK(R6),50$	; BR if this size message got across
	INCL	R7			; Count size(s) which failed
	PUSHL	SIZE_TBL1[R6]		; Save the message size
50$:	AOBLSS	#SIZE_TBL_SIZE,R6,40$	; Loop through remainder of flags
	MOVAL	RETRY_MSG,R8		; Assume we want msg for all sizes OK
	PUSHL	#SIZE_TBL_SIZE		; Save total count of message sizes
	TSTL	R7			; Did all msg sizes eventually make it?
	BEQL	60$			; BR if they did
	MOVAL	LOOPBACK_FAIL_MSG,R8	; Use other message if they did not
	MOVL	R7,(SP)			; Finally, save count of failed msgs...
	PUSHL	R7			; ...for !%S and !# both
60$:	MOVL	SP,R9			; Save pointer to $FAO args
	$FAOL_S	CTRSTR = (R8),-		; Form msg indicating fails or attempts
		OUTBUF = FAO_BUF,-
		OUTLEN = BUFFER_PTR,-
		PRMLST = (R9)
	BSBW	DUMP_SIGNAL		; Tell the user of our difficulties
	MOVL	R10,SP			; Clean $FAOL args from the stack
70$:	$CANCEL_S CHAN = XE_CHAN	; We can't afford to get old msgs later
	$CANTIM_S REQIDT = #LOOPBACK_TMO ; Now we know test won't hang

	BBS	#TEST_OVERV,FLAG,SENSE_TEST ; Is the test over?
	BRW	REMOTE_LOOPBACK_TEST	; Continue in external looping

;
; If in ten seconds the transmit to the broadcast address does not succeed
; either the device is broken or there is no one else on the NI so abort
; the read request and continue looping in Echo mode.
;

ABRT_BRDCST:
	.WORD	0
	BISW2	#BRDCST_NEDEDM,FLAG	; Signal the CANCELed AST routine
	$CANCEL_S CHAN = XE_CHAN	; Give up completely
	RET

SENSE_TEST:

	$SETIMR_S -			; Set ten sec timer to prevent hang
		DAYTIM = TENSEC,-
		ASTADR = TIME_ERR_OUT,-
		REQIDT = #TIMEOUT10

	$QIOW_S -			; Read device characteristics
		CHAN = XE_CHAN,-
		FUNC = #IO$_SENSEMODE!IO$M_CTRL,-
		IOSB = XE_IOSB,-
		P1 = SENSE_P1BUF,-
		P2 = #SENSE_P2DESC

	$CANTIM_S REQIDT = #TIMEOUT10

	BSBW	CHECK_IOSB		; Check status

	MOVZWL	XE_IOSB+2,R4		; Number of bytes returned for p2 buff
	MOVAL	ADR,R5			; Digital multicast NI address
	MOVL	#6,R7			; Adr length
10$:
	MOVAL	SENSE_P2BUF,R6		; Address of P2 buff returned
	MATCHC  #6,(R5),R4,(R6)		; Check the parameters returned
	BNEQ	30$			; Br if not match
	BRW	ERROR_TEST		; Otherwise go to test error case
30$:
	PUSHAL	SENSE_ERRMSG		; Error message
	BRW	FAIL_OUT		; Failure exit

ERROR_TEST:	
	$SETSFM_S ENBFLG = #0		; Turn off system service mode

;
; Read data with IO$M_NOW specified but no data available
;
	$QIOW_S -			; Read data message 
		CHAN = XE_CHAN,-
		FUNC = #IO$_READVBLK!IO$M_NOW,-
		IOSB = XE_IOSB,-
		P1 = @RECV_BUF_ADR,-
		P2 = #MAX_UNABUF_SIZE

	CMPW	XE_IOSB,#SS$_ENDOFFILE	; Correct error code?
	BNEQ	ERRTST_ERR		; Br if not

;
; Buffer not enough to hold all information from IO$_SENSEMODE
;

	$QIOW_S -			; Read device characteristics
		CHAN = XE_CHAN,-
		FUNC = #IO$_SENSEMODE!IO$M_CTRL,-
		IOSB = XE_IOSB,-
		P1 = SENSE_P1BUF,-
		P2 = #ERRTST_P2DESC

	CMPW	XE_IOSB,#SS$_BUFFEROVF	; Error code = buffer overflow?
	BNEQ	ERRTST_ERR		; Error if not

;
; Bad parameter due to message too big for the buffer
;
	$QIOW_S -			; Transmit data message with leng = 514
		EFN = #XMIT_EFN,-
		CHAN = XE_CHAN,-
		FUNC = #IO$_WRITEVBLK,-
		IOSB = XE_IOSB,-
		P1 = @XMIT_BUF_ADR,-
		P2 = #MAX_UNABUF_SIZE+2,-
		P5 = #DIAG_BUF+HARD_ADR

	CMPL	R0,#SS$_IVBUFLEN	; Should be invalid buffer size
	BNEQ	ERRTST_ERR		
	BRW	READ_ERRCOUNT		; Br to read and clear error count

ERRTST_ERR:
	PUSHAL	ERRTEST_MSG		; Error message
	BRW	FAIL_OUT		; Failure exit

REQUEST_FND:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	BBS	#BRDCST_NEDEDV,FLAG,20$ ; Skip this if being CANCELed
	BBS	#LONGORSHRTV,FLAG,15$	; Skip message if short report
	CLRL	R2			; Make an index
	MOVAL	ADR2+6,R3		; Set address address
	MOVAL	ARG_LIST,R4		; Set arglist address
10$:
	MOVZBL	(R3)+,(R4)+		; Parse to bytes
	AOBLSS	#6,R2,10$

	$FAOL_S CTRSTR = REMOTE_ID_CTR,- ; Format address
		OUTBUF = FAO_BUF,-
		OUTLEN = BUFFER_PTR,-
		PRMLST = ARG_LIST

	PUSHAL	BUFFER_PTR		; Output message
	PUSHL	#1
	PUSHL	#UETP$_TEXT+STS$K_INFO
	CALLS	#3,G^LIB$SIGNAL
15$:
	$CANTIM_S REQIDT = #TIME_ID_2	; Kill two minute timer

	PUSHAL	XE_CHAN1		; Shutdown the read request channel
	CALLS	#1,UNA_SHUTDOWN

	BISW2	#ID_FNDM,FLAG		; Set request found
20$:
	RET

REQUEST_NOTFND:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>

	BISW2	#BRDCST_NEDEDM,FLAG	; Set the broadcast needed flag
	RET

READ_ERRCOUNT:
	$SETSFM_S ENBFLG = #1		; Turn on  system service mode

	$SETIMR_S -			; Set ten sec timer to prevent hang
		DAYTIM = TENSEC,-
		ASTADR = TIME_ERR_OUT,-
		REQIDT = #TIMEOUT11

	$QIOW_S -			; Read and clear the error counters
		CHAN = XE_CHAN,-
		FUNC = #IO$_SENSEMODE!IO$M_RD_COUNT!IO$M_CLR_COUNT!IO$M_CTRL,-
		IOSB = XE_IOSB,-
		P2 = #ERRCOUNT_DESC

	$CANTIM_S REQIDT = #TIMEOUT11

	BSBW	CHECK_IOSB		; Check IO status block
	MOVZWL	XE_IOSB+2,ERRCOUNT_DESC ; Set the counter size
	PUSHAL	ERRCOUNT_DESC		; Push address of counters
	CALLS	#1,COUNTER_CHECK	; and check the counters for errors
	MOVL	#ERRCNT_LEN,ERRCOUNT_DESC ; Reset the buffer size

CLEAN_EXIT:

	BICW2	#FLAG_SHUTDNM,FLAG	; Clear the shutdown flag

	$QIOW_S -			; Shut down the device
		CHAN = XE_CHAN,-
		FUNC = #IO$_SETMODE!IO$M_CTRL!IO$M_SHUTDOWN,-
		IOSB = XE_IOSB

	BSBW	CHECK_IOSB		; Check IO status block

SUC_EXIT:
	$TRNLOG_S LOGNAM = MODE,-
		  RSLLEN = BUFFER_PTR,-
		  RSLBUF = FAO_BUF	; Get the run mode
	BICB2	#LC_BITM,BUFFER		; Convert to upper case
	CMPB	#^A/L/,BUFFER		; Is this a loop for ever?
	BNEQ	10$			; BR if not
	BICW2	#<TEST_OVERM!ID_FNDM>,FLAG ; Reset the termination flag
	INCL	PASS			; Bump the pass count
	$FAO_S	CTRSTR = PASS_MSG,-
		OUTLEN = BUFFER_PTR,-
		OUTBUF = FAO_BUF,-
		P1     = PASS,-
		P2     = ITERATION,-
		P3     = #0		; Make the end of pass message
	PUSHAL	BUFFER_PTR		; Push the string desc.
	PUSHL	#1			; Push arg count
	PUSHL	#UETP$_TEXT!STS$K_INFO	; Push the signal name
	CALLS	#3,G^LIB$SIGNAL		; Print the end of pass message
	CLRL	ITERATION		; Reset the iteration count
	BRW	TIME_IT			; Do the next pass
10$:
	$DASSGN_S CHAN = XE_CHAN	; All done with the channel

	MOVL	#SS$_NORMAL!STS$M_INHIB_MSG,STATUS ; Set successful exit status
	$EXIT_S STATUS			; Exit with the status

FAIL_OUT:				; Failure exit
	PUSHL	#1			; Arg count
	PUSHL	#UETP$_TEXT!STS$K_ERROR	; Signal name
	MOVL	(SP),STATUS		; Set up status 
	PUSHL	#3			; Arg count
	BRW	ERROR_EXIT		; Error exit


	.SBTTL	UNA Startup Routine
;++
; FUNCTIONAL DESCRIPTION:
;	This routine will be called to start up the UNA device.
;	It checks IO status block and the AST parameter
;
; CALLING SEQUENCE:
;	PUSHAL CHAN
;	PUSHAL P2
;	CALLS	#2,UNA_STARTUP
;
; INPUT PARAMETERS:
;	CHAN = Address to store the returned channel in
;	P2   = Address of the P2 parameter list for the UNA
;
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;	CHAN = channel associated to the UNA device on startup
;
; IMPLICIT OUTPUTS:
;	Error message if error
;
; COMPLETION CODES:
;	IO status in XE_IOSB if error
;
; SIDE EFFECTS:
;	Program exit if error
;
;--

UNA_STARTUP:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Entry mask

	$QIOW_S -			; Start the controller
		CHAN = @8(AP),-
		FUNC = #IO$_SETCHAR!IO$M_CTRL!IO$M_STARTUP,-
		IOSB = XE_IOSB,-
		ASTADR = CHK_QIO_AST,-
		ASTPRM = #PRM,-
		P2 = 4(AP),-
		P3 = #RECVPOOL_SIZ,-
		P6 = #DIAG_BUF
	RET

	.SBTTL	UNA Shutdown Routine
;++
; FUNCTIONAL DESCRIPTION:
;	This routine will be called to shutdown the UNA device.
;	It checks IO status block and the AST parameter
;
; CALLING SEQUENCE:
;	PUSHAL CHAN
;	CALLS	#1,UNA_SHUTDOWN
;
; INPUT PARAMETERS:
;	CHAN = Address to store the returned channel in
;
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	Error message if error
;
; COMPLETION CODES:
;	IO status in XE_IOSB if error
;
; SIDE EFFECTS:
;	Program exit if error
;
;--

UNA_SHUTDOWN:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Entry mask

	$QIOW_S -			; Shut down the device
		CHAN = @4(AP),-
		FUNC = #IO$_SETMODE!IO$M_CTRL!IO$M_SHUTDOWN,-
		IOSB = XE_IOSB,-
		ASTADR = CHK_QIO_AST,-
		ASTPRM = #PRM
	RET

	.SBTTL	CHECKIOSB - Check IO status block
;++
; FUNCTIONAL DESCRIPTION:
; 	This routine checks the IO status block = #SS$_NORMAL
;
; CALLING SEQUENCE:
;	BSBW	CHECK_IOSB
;
; INPUT PARAMETERS:
;	NONE
;
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	Exit with status if IOSB not right
;
; COMPLETION CODES:
;	IO status in STATUS if error
;
; SIDE EFFECTS:
;	Program exit if error found
;
;--
CHECK_IOSB:
	CMPW	XE_IOSB,#SS$_NORMAL	; Is the QIO O.K.?
	BNEQ	10$			; Br if not
	RSB				; Return
10$:
	MOVZWL	XE_IOSB,-(SP)		; Push the error status code
	MOVL	(SP),STATUS		; Set return status
	PUSHL	#1			; Argument count
	BRW	ERROR_EXIT		; Error exit


	.SBTTL	Check QIO AST Routine
;++
; FUNCTIONAL DESCRIPTION:
;	This routine will be called as a QIO completion AST routine 
;	It checks IO status block and the AST parameter
;
; CALLING SEQUENCE:
;	Called via AST at $QIO completion
;
; INPUT PARAMETERS:
;	NONE
;
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	Error message if error
;
; COMPLETION CODES:
;	IO status in STATUS if error
;
; SIDE EFFECTS:
;	Program exit if error
;
;--
CHK_QIO_AST:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Entry mask
	BSBW	CHECK_IOSB		; Go check IO status block
	CMPL	#PRM,4(AP)		; Check AST parameter
	BNEQ	10$			; Branch if not #1 (STARTUP)
	RET
10$:
	PUSHAL	ASTPAR_ERRMSG		; Error message
	BRW	FAIL_OUT

	.SBTTL	Remote Loopback I/O Timeout AST Routine
;++
; FUNCTIONAL DESCRIPTION:
;	This routine services the completion AST if during the remote loopback
;	test we time out while waiting for a message to be returned.  It forces
;	the test to continue by setting the event flag for which we were waiting
;	when we timed out.
;
; CALLING SEQUENCE:
;	Called via AST
;
; INPUT PARAMETERS:
;	04(AP) - Ignored
;
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	NONE
;
; COMPLETION CODES:
;	Status from $SETEF
;
; SIDE EFFECTS:
;	Another timer AST is enabled.
;	Synchronous test continues because event flag is set.
;
;--

LOOPBACK_TMO:
	.WORD	^M<>

	BLBC	FLAG,5$			; Skip this msg if normal running...
					; ...since there will be another anyway
	$FAO_S	CTRSTR = LOOPBACK_TMO_MSG,-
		OUTLEN = BUFFER_PTR,-
		OUTBUF = FAO_BUF,-
		P1     = #0,-
		P2     = ITERATION
	BSBW	DUMP_SIGNAL
	CALLS	#0,DUMP_STAMPS
5$:	MOVAL	-(SP),R0		; Create STATE holder for following
	$READEF_S EFN = #XMIT_EFN,-	; Check to see...
		STATE = (R0)		; ...if we hung while trying to transmit
	BITL	#XMIT_EFN,(SP)+		; Have we transmitted successfully?
					; Note: flag is set except while in...
					; ...the $QIOW in REMOTE_LOOPBACK_TEST
	BNEQ	10$			; BR if transmit is complete - we're...
					; ...waiting for recv, and that will
					; ...eventually terminate
	BBC	#TEST_OVERV,FLAG,10$	; BR if overall timer hasn't rung yet
	PUSHAL	TIMEOUT9		; We seem to be hung in transmit. Abort
	CALLS	#1,TIME_ERR_OUT
10$:
	$SETIMR_S DAYTIM = HALFMIN,-	; Allow time for messages to complete
		  ASTADR = LOOPBACK_TMO,-
		  REQIDT = #LOOPBACK_TMO
	$SETEF_S EFN = #RECV_EFN
	RET

	.SBTTL	Remote Loopback I/O Completion AST Routine
;++
; FUNCTIONAL DESCRIPTION:
;	This routine services the completion AST from the remote loopback test's
;	attempt to read.  It has to be a bit more forgiving than most routines,
;	since we may have $CANCElled the I/O due to a timeout.  The timeout
;	happens occasionally since not all Ethernet messages are delivered.
;
; CALLING SEQUENCE:
;	Called via AST at $QIO READ
;
; INPUT PARAMETERS:
;	04(AP) - Index into SIZE_TBL1 for the size of the message we attempted
;		to read.  This index may be used for LOOPBACK_ACK as well, a
;		parallel table.
;
; IMPLICIT INPUTS:
;	RCV_IOSB - $QIO read completion status
;	SIZE_TBL1 - Table of message sizes
;	ITERATION - Count of successful messages sent
;
; OUTPUT PARAMETERS:
;	ITERATION - Incremented if this message was successful
;
; IMPLICIT OUTPUTS:
;	LOOPBACK_ACK - Bit set to indicate that a particular message size was
;		received
;
; COMPLETION CODES:
;	Status from RECV_AST
;
; SIDE EFFECTS:
;	Message and program exit if error found
;
;--

LOOPBACK_AST:
	.WORD	^M<R6,R7>

	MOVL	04(AP),R6		; Get index into SIZE_TBL1
	MOVL	RECV_BUF_ADR,R7		; Get pointer to message buffer
	PUSHL	10(R7)
	MOVZWL	RCV_IOSB+2,-(SP)
	CALLS	#2,RECV_STAMP		; Remember message received if dump mode
	CMPW	#SS$_ABORT,RCV_IOSB	; Did we $CANCEL this transmission?
	BEQL	20$			; BR if so, no point in normal checks
	BLBC	FLAG,10$		; Skip sequence check if normal running
	CMPL	ITERATION,10(R7)	; Check message sequence number...
	BEQL	10$			; ...and skip if it's OK
	$FAO_S	CTRSTR = OUT_OF_SEQ_MSG,-
		OUTLEN = BUFFER_PTR,-
		OUTBUF = FAO_BUF,-
		P1     = ITERATION,-
		P2     = SIZE_TBL1[R6],-
		P3     = 10(R7),-
		P4     = RCV_IOSB+2,-
		P5     = #0
	BSBW	DUMP_SIGNAL
	CALLS	#0,DUMP_STAMPS		; List the last several msgs sent & recv
	MOVL	ITERATION,10(R7)	; Fix up sequence number...
					; ...so data comparison can be done
10$:
	BISB2	#1,LOOPBACK_ACK(R6)	; Flag that this size was received
	PUSHL	SIZE_TBL1[R6]		; Now call general routine...
	CALLS	#1,RECV_AST		; ...to check message's correctness
	RET

20$:	$FAO_S	CTRSTR = ABORT_MSG,-
		OUTLEN = BUFFER_PTR,-
		OUTBUF = FAO_BUF,-
		P1     = ITERATION
	BSBW	DUMP_SIGNAL
	CALLS	#0,DUMP_STAMPS		; List the last several msgs sent & recv
	RET

	.SBTTL	Receive data AST routine
;++
; FUNCTIONAL DESCRIPTION:
;	This routine will be called as receive data AST routine
;	It checks IO status and compare the data in the receive buffer
;	against the transmit buffer
;
; CALLING SEQUENCE:
;	Called via AST at $QIO READ
;
; INPUT PARAMETERS:
;	AST parameter = message length
;
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	Error message if error found
;
; COMPLETION CODES:
;	in STATUS
;
; SIDE EFFECTS:
;	Program exit if error found
;
;--
RECV_AST:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Entry mask

	MOVL	4(AP),R4		; Message length as ast param
	MOVL	RECV_BUF_ADR,R5		; Address of receive buffer
	MOVL	XMIT_BUF_ADR,R6		; Address of transmit buffer
	CMPW	(R5),#8			; Is this an external transfer with a...
					; ...skip count modification?
	BNEQ	10$			; BR if not
	CLRW	(R5)			; Reset the skip count to zero
10$:
	CMPW	#SS$_DATAOVERUN,RCV_IOSB ; Is our buffer too small for message?
	BEQL	12$			; Length problems are recoverable (below)
	CMPW	#SS$_NORMAL,RCV_IOSB	; Is the QIO O.K.?
	BNEQ	20$			; BR if not
12$:	CMPW	RCV_IOSB+2,R4		; Did we get an entire message?
	BEQL	15$			; BR if we did
	$FAO_S	CTRSTR = BADLEN,-	; Complain if we did not...
		OUTLEN = BUFFER_PTR,-
		OUTBUF = FAO_BUF,-
		P1     = ITERATION,-
		P2     = RCV_IOSB+2,-	; ...telling actual size...
		P3     = R4		; ...versus requested size
	BSBW	DUMP_SIGNAL
	CALLS	#0,DUMP_STAMPS		; If in DUMP mode, print a history
	RET				; Treat this as a recoverable error
15$:
	CMPC3	R4,(R5),(R6)		; Compare the data
	BNEQ	30$
	RET
20$:
	MOVZWL	RCV_IOSB,-(SP)		; Push the error status code
	MOVL	(SP),STATUS		; Set return status
	PUSHL	#1			; Argument count for the error message
	BRW	ERROR_EXIT		; Error exit

30$:
	MOVZBL	(R1),-(SP)		; Get good byte
	MOVZBL	(R3),-(SP)		; Get bad byte
	SUBL3	R0,R4,-(SP)		; Get the byte number
	ADDL3	#UNIT_LIST,UNIT_LIST,R11 ; Get the unit block address
	PUSHAL	UETUNT$T_FILSPC(R11)	; Use it to point to the device name
	PUSHL	#4			; Push arg count
	PUSHL	#UETP$_DATADEVERR!STS$K_ERROR ; Push the signal name
	PUSHL	#6			; Push arg count
	MOVL	#UETP$_DATADEVERR!STS$K_ERROR,-
		STATUS			; Push the signal name
	BRW	ERROR_EXIT		; Failure exit

	.SBTTL	DUMP Mode Routines
;+
; Being a set of routines to keep track of the last several messages sent
; and received during the remote loopback test if running in DUMP mode.
; To call XMIT_STAMP ($QIO transmit time stamp) or RECV_STAMP (AST received
; time stamp):
;	PUSHL	MESSAGE-SEQUENCE-NUMBER
;	PUSHL	BUFFER-LENGTH
;	CALLS	#1,{XMIT,RECV}_STAMP
;
; To call DUMP_STAMPS (dump recent time stamps):
;	CALLS	#0,DUMP_STAMPS

	.ENABLE	LSB
XMIT_STAMP:
	.WORD	^M<R2>
	CLRL	R0			; Remember that we're XMIT_STAMP
	BRB	10$
RECV_STAMP:
	.WORD	^M<R2>
	MOVL	#1,R0			; Remember that we're RECV_STAMP
10$:	MOVL	SBP,R2			; Get pointer into time stamp list
	MOVW	R0,(R2)+		; Save RECV/XMIT...
	MOVW	04(AP),(R2)+		; ...length of message...
	MOVL	08(AP),(R2)+		; ...message sequence number...
	$GETTIM_S TIMADR = (R2)		; ...and time when sent or received
	ADDL2	#8,R2			; Point to the next time stamp slot
	CMPL	#STAMP_BUFFER+TSCLL,R2	; It's a circular list - have we...
	BGTR	20$			; ...gone around?  BR if we have not
	MOVAL	STAMP_BUFFER,R2		; Reuse slots at beginning if we have
20$:	MOVL	R2,SBP			; Save pointer into time stamp list
	RET
	.DISABLE LSB

DUMP_STAMPS:
	.WORD	^M<R2>
	BLBC	FLAG,30$		; Skip dump if not in DUMP mode
	$FAO_S	CTRSTR = TIME_STAMP_INTRO_MSG,-
		OUTLEN = BUFFER_PTR,-
		OUTBUF = FAO_BUF,-
		P1     = RCV_IOSB,-
		P2     = RCV_IOSB+4
	BSBB	DUMP_SIGNAL		; Indicate what's to follow
	MOVL	SBP,R2			; Pick up pointer into time stamp list
10$:	SUBL2	#16,R2			; Point to previous slot
	CMPL	#STAMP_BUFFER-16,R2	; Are we at the start of the list?
	BLSS	20$			; BR if not - slot is legit
	MOVAL	STAMP_BUFFER+TSCLL-16,R2 ; Set pointer to last slot
20$:	CMPL	R2,SBP			; Have we gone full circle yet?
	BEQL	30$			; BR if we have - exit routine
	MOVAL	8(R2),R0		; Get address of time stamp in slot
	$FAO_S	CTRSTR = TIME_STAMP_MSG,-
		OUTLEN = BUFFER_PTR,-
		OUTBUF = FAO_BUF,-
		P1     = (R2),-
		P2     = 2(R2),-
		P3     = 4(R2),-
		P4     = R0
	BSBB	DUMP_SIGNAL		; Type one time stamp...
	BRB	10$			; ...and loop for the next
30$:	RET

DUMP_SIGNAL:
	PUSHAL	BUFFER_PTR
	PUSHL	#1
	PUSHL	#UETP$_TEXT!STS$K_INFO
	CALLS	#3,G^LIB$SIGNAL
	RSB

	.SBTTL	COUNTER_CHECK Routine
;++
; FUNCTIONAL DESCRIPTION:
;	This routine is the UNA counters checking routine. A list of
;	specific UNA counters which are considered to indicate errors
;	is referenced at CNTR_TBL. When the counters are read their
;	value is checked to see if it is non zero.  If non zero a warning
;	message will be printed containing the name of the counter and
;	it's value.
;
; CALLING SEQUENCE:
;	PUSHAL	COUNTER_DESC
;	CALLS	#1, COUNTER_CHECK
;
; INPUT PARAMETERS:
;	4(AP) = Address of the counters to check.
;
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;	Sets the error occured flag if a warning message is printed.
;
; IMPLICIT OUTPUTS:
;	Error or success messages
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	NONE
;
;--

COUNTER_CHECK:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>

	MOVL	4(AP),R6		; Get the descriptor address
	MOVZWL	(R6),R7			; Get the buffer size
	ADDL3	R7,4(R6),END_ADR	; Save the buffer end address
	MOVL	4(R6),R6		; Get the buffer address
	MOVAL	CNTR_TBL,R9		; Set table address
CHK_LOOP:
	CMPL	R6,END_ADR		; All done?
	BNEQ	10$			; BR if not...
	BRW	COUNTER_EXIT		; ...else bail out
10$:
	MOVZWL	(R6)+,R8		; Get cntrl desc
	EXTZV	#NMA$V_CNT_TYP,-
		#NMA$S_CNT_TYP,-
		R8,R8			; Get the counter type
20$:
	MOVZWL	(R9)+,R10		; Get a table code
	EXTZV	#NMA$V_CNT_TYP,-
		#NMA$S_CNT_TYP,-
		R10,R11			; Get the counter type
	CMPL	R8,R11			; Is this it?
	BEQL	80$			; BR if yes
	ADDL2	#4,R9			; Skip name pointer
	CMPL	R9,#TBL_END		; End of table?
	BNEQ	20$			; BR if not
	MOVAL	CNTR_TBL,R9		; Set table address
	EXTZV	#NMA$V_CNT_WID,-
		#NMA$S_CNT_WID,-
		-2(R6),R8		; Get the counter width
	BBC	#NMA$V_CNT_MAP,-2(R6),30$ ; If not a mapped counter then carry on else...
	ADDL2	#2,R6			; ...skip the map word
30$:
	CASEB	R8,#1,#2		; Skip the counter
40$:
	.WORD	50$-40$
	.WORD	60$-40$
	.WORD	70$-40$
	PUSHAL	CASE_FAILED		; Push the string address
	PUSHL	#1			; Push the argument count
	PUSHL	#UETP$_TEXT!STS$K_ERROR ; Push the signal name
	PUSHL	#3			; Push the argument count
	BRW	ERROR_EXIT		; Thats it
50$:
	INCL	R6			; Skip a byte counter
	BRW	CHK_LOOP
60$:
	ADDL2	#2,R6			; Skip a word counter
	BRW	CHK_LOOP
70$:
	ADDL2	#4,R6			; Skip a long word counter	
	BRW	CHK_LOOP
80$:
	EXTZV	#NMA$V_CNT_WID,-
		#NMA$S_CNT_WID,-
		-2(R6),R8		; Get the counter width
	BBC	#NMA$V_CNT_MAP,-2(R6),90$ ; If not a mapped counter then carry on else...
	ADDL2	#2,R6			; ...skip the map word
90$:
	CASEB	R8,#1,#2		; Skip the counter
100$:
	.WORD	110$-100$
	.WORD	120$-100$
	.WORD	130$-100$
	PUSHAL	CASE_FAILED		; Push the string address
	PUSHL	#1			; Push the argument count
	PUSHL	#UETP$_TEXT!STS$K_ERROR ; Push the signal name
	PUSHL	#3			; Push the argument count
	BRW	ERROR_EXIT		; Thats it
110$:
	MOVZBL	(R6)+,COUNTER		; Get a byte counter
	BRW	140$
120$:
	MOVZWL	(R6)+,COUNTER		; Get a word counter
	BRW	140$
130$:
	MOVL	(R6)+,COUNTER		; Get a long word counter	
140$:
	BNEQ	150$
	MOVAL	CNTR_TBL,R9		; Reset the table address
	BRW	CHK_LOOP		; BR if counter was zero
150$:
	$FAO_S	CTRSTR = COUNTER_MSG,-	; Generate a bad counter message
		OUTLEN = BUFFER_PTR,-
		OUTBUF = FAO_BUF,-
		P1     = (R9),-
		P2     = COUNTER
	PUSHAL	BUFFER_PTR		; Push the string address
	PUSHL	#1			; Push the argument count
	PUSHL	#UETP$_TEXT!STS$K_INFO	; Push the signal name
	CALLS	#3, G^LIB$SIGNAL	; Print the error message
	MOVAL	CNTR_TBL,R9		; Reset the counter table pointer
	BRW	CHK_LOOP		; Thats it
	
COUNTER_EXIT:
	RET

	.SBTTL	Half Minute Timer Expiration Routine
;++
; FUNCTIONAL DESCRIPTION:
;	This routine will be called only if the timer which was set to prevent
;	program hangs goes off.
;
; CALLING SEQUENCE:
;	Called via AST at $SETIMR expiration.
;
; INPUT PARAMETERS:
;	NONE
;
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	Time out error message
;
; COMPLETION CODES:
;	#SS$_TIMEOUT
;
; SIDE EFFECTS:
;	Program exit
;
;--

TIME_ERR_OUT:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Entry mask
	PUSHL	#SS$_TIMEOUT		; Push the signal name = timeout
	MOVL	(SP),STATUS		; Set exit status
	PUSHL	4(AP)			; Push the REQIDT which is the timeout
					; string address
	PUSHL	#1			; Push the argument count total
	PUSHL	#UETP$_TEXT!STS$K_ERROR	; Push the message number
	PUSHL	#4			; Push the argument count
	BRW	ERROR_EXIT		; Bail out completely

	.SBTTL	Test End Timer Expiration Routine
;++
; FUNCTIONAL DESCRIPTION:
;	This routine will be called only if the timer which was set to
;	terminate the test goes off.
;
; CALLING SEQUENCE:
;	Called via AST at $SETIMR expiration.
;
; INPUT PARAMETERS:
;	NONE
;
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	NONE
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	NONE
;
;--

TIME_SUC_OUT:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Entry mask

	BISW2	#TEST_OVERM,FLAG		; Set test over flag
	RET


	.SBTTL	System Service Exception Handler
;++
; FUNCTIONAL DESCRIPTION:
;	This routine is executed if a software or hardware exception occurs or
;	if a LIB$SIGNAL system service is used to output a message.
;	Information about this method of handling messages and errors can be
;	found in the VMS COMMON RUN-TIME manual and in the VMS SYSTEM SERVICE
;	manual.
;
; CALLING SEQUENCE:
;	Entered via an exception from the system
;
; INPUT PARAMETERS:
;	ERROR_COUNT   = previous cumulative error count
;	                -----------------
;	   AP ---->     !       2       !
;			!---------------!
;			! SIGNL ARY PNT !
;			!---------------!
;			! MECH  ARY PNT !
;			!---------------! ---------
;			!       4       !         ^
;			!---------------!         !
;			! ESTABLISH FP  !         !
;			!---------------!         !
;			!    DEPTH      ! Mechanism Array
;			!---------------!         !
;			!      R0       !         !
;			!---------------!         !
;			!      R1       !         v
;			!---------------! ---------
;			!       N       !         ^
;			!---------------!         !
;			! CONDITION NAME!         !
;			!---------------!         !
;			! N-3 ADDITIONAL!    Signal Array
;			! LONG WORD ARGS!         !
;			!---------------!         !
;			!      PC       !         !
;			!---------------!         !
;			!      PSL      !         v
;			!---------------! ---------
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	NONE
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	May branch to ERROR_EXIT
;--

SSERROR:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Entry mask

	$SETAST_S ENBFLG = #0		; Disable AST delivery
	PUSHL	#1			; Assume ASTs were enabled
	CMPL	S^#SS$_WASSET,R0	; Were ASTs enabled?
	BEQL	10$			; BR if they were
	CLRL	(SP)			; Set ASTs to remain disabled
10$:
	$SETSFM_S ENBFLG = #0		; Disable SS failure mode
	PUSHL	#1			; Assume SS failure mode was enabled
	CMPL	S^#SS$_WASSET,R0	; Was SS failure mode enabled?
	BEQL	20$			; BR if it was
	CLRL	(SP)			; Set SS failure mode to remain off
20$:
	MOVL	CHF$L_SIGARGLST(AP),R6	; Get the signal array pointer
	MOVQ	CHF$L_SIG_NAME(R6),R9	; Get NAME in R9 and ARG1 in R10
	CMPZV	#STS$V_FAC_NO,-		; Is this a message from LIB$SIGNAL?
		#STS$S_FAC_NO,-
		R9,#UETP$_FACILITY
	BNEQ	30$			; BR if this is not a UETP exception
	SUBL2	#2,CHF$L_SIG_ARGS(R6)	; Drop the PC and PSL
	$PUTMSG_S MSGVEC = CHF$L_SIG_ARGS(R6) ; Print the message
	BRB	40$			; Restore ASTs and SS fail mode
30$:
	CMPL	#SS$_SSFAIL,R9		; RMS failures are SysSvc failures
	BNEQ	50$			; BR if this can't be an RMS failure
	CMPZV	#STS$V_FAC_NO,-		; Is it an RMS failure?
		#STS$S_FAC_NO,-
		R10,#RMS$_FACILITY
	BNEQ	50$			; BR if not
	BICL2	#^XF0000000,R10		; Strip control bits from status code
	MATCHC	#4,CHF$L_SIG_ARG1(R6),-	; Is it an RMS failure for which...
		#NRAT_LENGTH,-
		NO_RMS_AST_TABLE	; ...no AST can be delivered?
	BEQL	50$			; BR if so - must give error here
40$:
	POPR	#^M<R0>			; Restore SS failure mode...
	$SETSFM_S ENBFLG = R0		; ...
	POPR	#^M<R0>			; Restore AST enable...
	$SETAST_S ENBFLG = R0		; ...
	MOVL	S^#SS$_NORMAL,R0	; Supply a standard status for exit
	RET				; Resume processing (or goto RMS_ERROR)
50$:
	MOVL	R9,STATUS		; Save the status
	CLRL	R8			; Assume for now it's not SS failure
	CMPL	#SS$_SSFAIL,R9		; But is it a System Service failure?
	BNEQ	70$			; BR if not - no special case message
	$GETMSG_S MSGID = R10,-		; Get SS failure code associated text
		 MSGLEN = BUFFER_PTR,-
		 BUFADR = FAO_BUF,-
		 FLAGS  = #14,-
		 OUTADR = MSG_BLOCK
	TSTB	MSG_BLOCK+1		; Get FAO arg count for SS failure code
	BEQL	60$			; Don't use $GETMSG if no $FAO args...
	PUSHAL	BUFFER_PTR		; ...else build up...
	PUSHL	#1			; ...a message describing...
	PUSHL	#UETP$_TEXT		; ...why the System Service failed
	INSV	R10,#STS$V_SEVERITY,-	; Give the message...
		#STS$S_SEVERITY,(SP)	; ...the correct severity code
	MOVL	#3,R8			; Count the number of args we pushed
	BRB	70$
60$:
	PUSHL	R10			; Save SS failure code
	MOVL	#1,R8			; Count the number of args we pushed
70$:
	MULL3	#4,CHF$L_SIG_ARGS(R6),R7 ; Convert longwords to bytes
	SUBL2	R7,SP			   ; Save the current signal array...
	MOVC3	R7,CHF$L_SIG_NAME(R6),(SP) ; ...on the stack
	ADDL3	R8,CHF$L_SIG_ARGS(R6),-(SP) ; Push the current arg count
	BRW	ERROR_EXIT

	.SBTTL	RMS Error Handler
;++
; FUNCTIONAL DESCRIPTION:
;	This routine handles error returns from RMS calls.
;
; CALLING SEQUENCE:
;	Called by RMS when a file processing error is found.
;
; INPUT PARAMETERS:
;	NONE
;
; IMPLICIT INPUTS:
;	The FAB or RAB associated with the RMS call.
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	Error message
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	Program may exit, depending on severity of the error.
;
;--

RMS_ERROR:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Entry mask

	MOVL	4(AP),R6		; See whether we're dealing with...
	CMPB	#FAB$C_BID,FAB$B_BID(R6) ; ...a FAB or a RAB
	BNEQ	10$			; BR if it's a RAB
	MOVAL	FILE,R7			; FAB-specific code:  text string...
	MOVL	R6,R8			; ...address of FAB...
	PUSHL	FAB$L_STV(R6)		; ...STV field for error...
	PUSHL	FAB$L_STS(R6)		; ...STS field for error...
	MOVL	FAB$L_STS(R6),STATUS	; ...and save the error code
	BRB	COMMON			; FAB and RAB share other code
10$:
	MOVAL	RECORD,R7		; RAB-specific code:  text string...
	MOVL	RAB$L_FAB(R6),R8	; ...address of associated FAB...
	PUSHL	RAB$L_STV(R6)		; ...STV field for error...
	PUSHL	RAB$L_STS(R6)		; ...STS field for error...
	MOVL	RAB$L_STS(R6),STATUS	; ...and save the error code
COMMON:
	MOVZBL	FAB$B_FNS(R8),R10	; Get the file name size
	$FAO_S	CTRSTR = RMS_ERR_STRING,- ; Common code, prepare error message...
		OUTLEN = BUFFER_PTR,-
		OUTBUF = FAO_BUF,-
		P1     = R7,-
		P2     = R10,-
		P3     = FAB$L_FNA(R8)
	PUSHAL	BUFFER_PTR		; ...and arguments for ERROR_EXIT...
	PUSHL	#1			; ...
	PUSHL	#UETP$_TEXT		; ...
	EXTZV	#STS$V_SEVERITY,-
		#STS$S_SEVERITY,-
		STATUS,R9 		; ...get the severity code...
	BISB2	R9,(SP)			; ...and add it into the signal name
	PUSHL	#5			; Current arg count
	BRW	ERROR_EXIT

	.SBTTL	CTRL/C Handler
;++
; FUNCTIONAL DESCRIPTION:
;	This routine handles CTRL/C AST's
;
; CALLING SEQUENCE:
;	Called via AST
;
; INPUT PARAMETERS:
;	NONE
;
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	NONE
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	NONE
;
;--

CCASTHAND:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Entry mask

	PUSHAL	CNTRLCMSG		; Set message pointer
	PUSHL	#1			; Set arg count
	PUSHL	#UETP$_TEXT!STS$K_WARNING ; Set signal name
	PUSHL	#0			; Indicate an abnormal termination
	PUSHAL	PROCESS_NAME		; ...
	PUSHL	#2			; ...
	PUSHL	#UETP$_ABENDD!STS$K_WARNING ; ...
	CALLS	#7,G^LIB$SIGNAL		; Output the message
	MOVL	#<STS$M_INHIB_MSG!-	; Set the exit status
		SS$_CONTROLC--
		STS$K_SUCCESS+STS$K_WARNING>,-
		STATUS
	$EXIT_S	STATUS			; Terminate program cleanly

	.SBTTL	Error Exit
;++
; FUNCTIONAL DESCRIPTION:
;	This routine prints an error message and exits.
;
; CALLING SEQUENCE:
;	MOVx  error status value,STATUS
;	PUSHx error specific information on the stack
;	PUSHL current argument count
;	BRW   ERROR_EXIT
;
; INPUT PARAMETERS:
;	Arguments to LIB$SIGNAL, as above
;
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;	Message to SYS$OUTPUT and SYS$ERROR
;
; IMPLICIT OUTPUTS:
;	Program exit
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	NONE
;
;--

ERROR_EXIT:

	$SETAST_S ENBFLG = #0		; ASTs can play havoc with messages
	BBS	#BEGIN_MSGV,FLAG,10$	; BR if "begin" msg already printed
	CLRL	-(SP)			; Set the time stamp flag
	PUSHAL	TEST_NAME		; Set the test name
	PUSHL	#2			; Push the argument count
	PUSHL	#UETP$_BEGIND!STS$K_SUCCESS ; Set the message code
	CALLS	#4,G^LIB$SIGNAL		; Print the startup message
10$:
	ADDL3	(SP)+,#8,ARG_COUNT	; Get total # args, pop partial count
	INCL	ERROR_COUNT		; Keep running error count
	PUSHL	#0			; Push the time parameter
	PUSHAL	PROCESS_NAME		; Push test name...
	PUSHL	#^XF0002		; ...arg count...
	PUSHL	#UETP$_ABENDD!STS$K_ERROR ; ...and signal name
	PUSHL	ERROR_COUNT		; Finish off arg list...
	PUSHAL	PROCESS_NAME		; ...
	PUSHL	#^X10002		; ...
	PUSHL	#UETP$_ERBOXPROC!STS$K_ERROR ; ...for error box message
	CALLS	ARG_COUNT,G^LIB$SIGNAL	; Truly bitch

	TSTL	STATUS			; Did we exit with an error code?
	BNEQ	20$			; BR if we did
	MOVL	#UETP$_ABENDD!STS$K_ERROR,- ; Supply a generic one otherwise
		STATUS
20$:
	BISL	#STS$M_INHIB_MSG,STATUS	; Don't print messages twice!
	$EXIT_S STATUS			; Exit in error

	.SBTTL	Exit Handler
;++
; FUNCTIONAL DESCRIPTION:
;	This routine handles cleanup at exit.  If the MODE logical name is
;	equated to "ONE", the routine will update the test flag in the
;	UETINIDEV.DAT file depending on the UETUNT$M_TESTABLE flag state in the
;	UETUNT$B_FLAGS field of the unit block for each unit for the device
;	under test.
;
; CALLING SEQUENCE:
;	Invoked automatically by $EXIT System Service.
;
; INPUT PARAMETERS:
;	STATUS  contains the exit status.
;	FLAG    has synchronizing bits.
;	DDB_RFA contains the RFA of the DDB record for this device in UETINIDEV.
;
; IMPLICIT INPUTS:
;	UNIT_LIST points to the head of a doubly linked circular list of unit
;		  blocks for the device under test.
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	Various files are de-accessed, the process name is reset, and any
;	necessary synchronization with UETPDEV01 is carried out.
;	If the MODE logical name is equated to "ONE", the routine will update
;	the test flag in the UETINIDEV.DAT file depending on the 
;	UETUNT$M_TESTABLE flag state in the UETUNT$B_FLAGS field of the unit
;	block for each unit for the device under test.
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	NONE
;
;--

EXIT_HANDLER:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Entry mask

	$SETSFM_S ENBFLG = #0		; Turn off System Service failure mode
	$SETAST_S ENBFLG = #0		; We're finished - no more ASTs
	$TRNLOG_S LOGNAM = MODE,-	; Get the run mode
		  RSLLEN = BUFFER_PTR,-
		  RSLBUF = FAO_BUF
	BICB2	#LC_BITM,BUFFER		; Convert to upper case
	CMPB	#^A/O/,BUFFER		; Is this a one shot?
	BEQL	10$			; BR if yes...
	BRW	END_UPDATE		; ...else don't update UETINIDEV.DAT
10$:
	BBS	#SAFE_TO_UPDV,FLAG,20$	; Only update if it's safe
	BRW	END_UPDATE		; Else forget it
20$:
	MOVAL	INI_RAB,R10		; Set the RAB address
	MOVB	#RAB$C_RFA,RAB$B_RAC(R10) ; Set RFA mode
	MOVC3	#6,DDB_RFA,RAB$W_RFA(R10) ; Set RFA to DDB line
	$GET	RAB = (R10)		; Go back to the DDB record
	BLBC	R0,UPDATE_FAILED	; If failure then forget it
	MOVB	#RAB$C_SEQ,RAB$B_RAC(R10) ; Set back to sequential mode
	ADDL3	#UNIT_LIST,UNIT_LIST,R11 ; Set the unit block list header
	CLRL	R9			; Init a counter
UNIT_LOOP:
	BBC	#UETUNT$V_TESTABLE,-	; BR if this unit is not testable
		UETUNT$B_FLAGS(R11),10$
	INCL	R9			; Count testable units
10$:
	ADDL2	(R11),R11		; Next unit block
	CMPL	R11,#UNIT_LIST		; Are we full circle in the list?
	BNEQ	UNIT_LOOP		; BR if not
	TSTL	R9			; Any testable units?
	BNEQ	20$			; BR if yes...
	MOVB	#^A/N/,BUFFER+4		; ...else disable the DDB record...
	$UPDATE RAB = (R10)		; ...here
	BLBC	R0,UPDATE_FAILED	; If error then forget it
20$:
	ADDL2	(R11),R11		; Next unit block
	CMPL	R11,#UNIT_LIST		; Are we full circle in the list?
	BEQL	END_UPDATE		; BR if yes
	$GET	RAB = (R10)		; Get a record
	BLBC	R0,UPDATE_FAILED	; If error then forget it
	BICB2	#LC_BITM,BUFFER		; Convert to uppercase
	CMPB	#^A/U/,BUFFER		; Is it a UCB record?
	BNEQ	END_UPDATE		; BR if not
	BBS	#UETUNT$V_TESTABLE,-	; BR if this unit is testable...
		UETUNT$B_FLAGS(R11),20$
	MOVB	#^A/N/,BUFFER+4		; ...else disable the UCB record...
	$UPDATE RAB = (R10)		; ...here
	BLBS	R0,20$			; Look at the next record if no error
UPDATE_FAILED:
	PUSHL	RAB$L_STV(R10)		; Do a simple message...
	PUSHL	R0			; ...to tell of the failure
	PUSHAL	INIDEV_UPDERR
	PUSHL	#1
	EXTZV	#STS$V_SEVERITY,-	; Copy the severity from RMS status...
		#STS$S_SEVERITY,R0,-(SP)
	BISL2	#UETP$_TEXT,(SP)	; ...to our message
	CALLS	#5,G^LIB$SIGNAL
END_UPDATE:
	PUSHL	#0			; Set the time flag
	PUSHAL	TEST_NAME		; Push the test name
	PUSHL	#2			; Push arg count
	EXTZV	#STS$V_SEVERITY,-	; Push the proper exit severity...
		#STS$S_SEVERITY,-
		STATUS,-(SP)
	BISL2	#UETP$_ENDEDD,(SP)	; ...and use it in our message code
	PUSHL	#4
	MOVL	SP,R1
	$PUTMSG_S MSGVEC = (R1)		; Output the message
	$SETPRN_S PRCNAM = ACNT_NAME	; Reset the process name
	RET				; That's all folks!

	.END	UETUNAS00
