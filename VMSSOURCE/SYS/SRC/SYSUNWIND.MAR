	.TITLE	SYSUNWIND - SYSTEM SERVICE UNWIND PROCEDURE CALL STACK
	.IDENT	'V04-000'
 
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; D. N. CUTLER 16-DEC-76
;
; MODIFIED BY:
;
;	V03-006	ACG0383		Andrew C. Goldstein,	19-Dec-1983  16:15
;		Fix register use bug in skipping active signal
;
;	V03-005	ACG0357		Andrew C. Goldstein,	9-Sep-1983  18:08
;		Turn off T bit when unwinding through AST's and
;		into the frame of the exception.
;
;	V03-004	ACG0348		Andrew C. Goldstein,	4-Aug-1983  17:07
;		Fix unwinding into frame of exception
;
;	V03-003	ACG0336		Andrew C. Goldstein,	16-May-1983  15:48
;		Add signal/stop longword to signal args in SS$_UNWIND
;
;	V03-002	KDM0002		Kathleen D. Morse	28-Jun-1982
;		Add $PSLDEF.
;
;	V03-001	ACG0294		Andrew C. Goldstein,	10-Jun-1982  18:22
;		Fix storing of PC into AST frame when unwinding thru AST
;
;
;**
;
; SYSTEM SERVICE UNWIND PROCEDURE CALL STACK
;
; MACRO LIBRARY CALLS
;
 
	$CHFDEF				;DEFINE CONDITION HANDLING ARGLIST OFFSETS
	$PSLDEF				;DEFINE PROGRAM STATUS LONGWORD
	$SSDEF				;DEFINE SYSTEM STATUS VALUES
 
;
; LOCAL SYMBOLS
;
; ARGUMENT LIST OFFSET DEFINITIONS
;
 
DEPADR=4				;ADDRESS OF NUMBER OF FRAMES TO UNWIND
NEWPC=8					;CHANGE OF FLOW FINAL RETURN ADDRESS
 
;
; CALL FRAME OFFSET DEFINITIONS
;
 
HANDLER=0				;CONDITION HANDLER ADDRESS
SAVPSW=4				;SAVED PSW FROM CALL
SAVMSK=6				;REGISTER SAVE MASK
SAVAP=8					;SAVED AP REGISTER IMAGE
SAVFP=12				;SAVED FP REGISTER IMAGE
SAVPC=16				;SAVED PC REGISTER IMAGE
SAVRG=20				;OTHER SAVED REGISTER IMAGES

	.PSECT	YEXEPAGED,BYTE		;PAGED PSECT
	.PAGE
	.SBTTL	UNWIND PROCEDURE CALL STACK
;+
; EXE$UNWIND - UNWIND PROCEDURE CALL STACK
;
; THIS SERVICE PROVIDES THE CAPABILITY TO UNWIND THE PROCEDURE CALL STACK
; TO A SPECIFIED DEPTH AFTER A HARDWARE- OR SOFTWARE-DETECTED EXCEPTION
; CONDITION HAS BEEN SIGNALLED. OPTIONALLY A CHANGE OF FLOW RETURN ADDRESS
; MAY ALSO BE SPECIFIED. THE ACTUAL UNWIND IS NOT PERFORMED IMMEDIATELY BY
; THE SERVICE, BUT RATHER THE RETURN ADDRESSES IN THE CALL STACK ARE MODIFIED
; SUCH THAT WHEN THE CONDITION HANDLER RETURNS THE UNWIND OCCURS.
;
; INPUTS:
;
;	DEPADR(AP) = ADDRESS OF NUMBER OF FRAMES TO UNWIND.
;	NEWPC(AP) = CHANGE OF FLOW FINAL RETURN ADDRESS.
;
;	R4 = CURRENT PROCESS PCB ADDRESS.
;
; OUTPUTS:
;
;	R0 LOW BIT CLEAR INDICATES FAILURE TO FULLY UNWIND CALL STACK.
;
;		R0 = SS$_ACCVIO - CALL STACK NOT ACCESSIBLE TO CALLING ACCESS
;			MODE.
;
;		R0 = SS$_INSFRAME - INSUFFICIENT CALL FRAMES TO UNWIND TO
;			SPECIFIED DEPTH.
;
;		R0 = SS$_NOSIGNAL - NO SIGNAL IS CURRENTLY ACTIVE TO UNWIND.
;
;		R0 = SS$_UNWINDING - UNWIND ALREADY IN PROGRESS.
;
;	R0 LOW BIT SET INDICATES SUCCESSFUL COMPLETION.
;
;		R0 = SS$_NORMAL - NORMAL COMPLETION.
;-
 
	.ENTRY	EXE$UNWIND,^M<R2,R3,R4,R5>
	MOVAB	W^EXE$SIGTORET,(FP)	;ESTABLISH CONDITION HANDLER
	MOVL	FP,R4			;SET ADDRESS OF FIRST FRAME TO EXAMINE
 
;
; SEARCH CALL STACK FOR A FRAME THAT WAS CREATED BY A CALL FROM THE SIGNAL
; DISPATCH VECTOR OR BY A CALL FROM THE UNWIND SIGNAL DISPATCHER.
;
 
	MOVZWL	#SS$_NOSIGNAL,R0	;ASSUME NO SIGNAL ACTIVE
10$:	MOVL	SAVFP(R4),R4		;GET ADDRESS OF PREVIOUS FRAME
	BEQL	20$			;IF EQL END OF CALL STACK
	CMPL	#SYS$CALL_HANDL+4,SAVPC(R4) ;CALL FROM CONDITION HANDLER DISPATCHER?
	BEQL	30$			;IF EQL YES
	CMPL	#CALLUNWIND+4,SAVPC(R4)	;CALL FROM UNWIND SIGNAL DISPATCHER?
	BNEQ	10$			;IF NEQ NO
	MOVZWL	#SS$_UNWINDING,R0	;SET ALREADY UNWINDING
20$:	RET				;
 
;
; SET TO UNWIND PROCEDURE CALL STACK TO SPECIFIED DEPTH
;
 
30$:	MOVL	DEPADR(AP),R3		;GET ADDRESS OF NUMBER OF FRAMES TO UNWIND
	BEQL	40$			;IF EQL NONE SPECIFIED
	MOVL	(R3),R3			;GET NUMBER OF FRAMES TO UNWIND
	BRB	50$			;
40$:	MOVL	R4,R2			;COPY CURRENT FRAME ADDRESS
	BSBW	OLDSP			;CALCULATE VALUE OF SP BEFORE CALL
	MOVL	CHF$L_MCHARGLST+4(R2),R2 ;GET ADDRESS OF MECHANISM ARGUMENT LIST
	ADDL3	#1,CHF$L_MCH_DEPTH(R2),R3 ;CALCULATE DEPTH OF ESTABLISHER'S CALLER
50$:	BLEQ	90$			;IF LEQ NO FRAMES TO REMOVE
	MOVAL	W^STARTUNWIND,R0	;SET CONDITION HANDLER UNWIND ADDRESS
	BSBW	SETPC			;
 
;
; SCAN THROUGH SPECIFIED NUMBER OF FRAMES SETTING EACH FRAME TO UNWIND ON RETURN
;
 
60$:	MOVL	SAVFP(R4),R4		;GET ADDRESS OF PREVIOUS FRAME
	BEQL	100$			;IF EQL INSUFFICIENT FRAMES
	DECL	R3			;ANY MORE FRAMES TO CONSIDER?
	BGTR	65$			;BRANCH IF YES
	TSTL	DEPADR(AP)		;ARE WE UNWINDING TO CALLER OF ESTABLISHER?
	BEQL	90$			;BRANCH IF YES - DON'T TOUCH HANDLER FRAMES
65$:	CMPL	#SYS$CALL_HANDL+4,SAVPC(R4) ;CALL FROM CONDITION DISPATCHER?
	BNEQ	80$			;IF NEQ NO
	MOVL	R4,R2			;COPY ADDRESS OF CURRENT FRAME
	BSBW	OLDSP			;CALCULATE VALUE OF SP BEFORE CALL
	MOVL	CHF$L_MCHARGLST+4(R2),R2 ;GET ADDRESS OF MECHANISM ARGUMENT LIST
	TSTL	CHF$L_MCH_DEPTH(R2)	;CHECK IF THIS IS A VECTORED HANDLER
	BLSS	80$			;IF SO, DON'T SKIP ANY FRAMES
	MOVL	CHF$L_MCH_FRAME(R2),R5	;GET ESTABLISHER FP
70$:	CMPL	R4,R5			;UNWOUND TO ESTABLISHER FRAME?
	BEQL	65$			;IF EQL YES
	MOVAL	B^LOOPUNWIND,R0		;SET FRAME UNWIND ADDRESS
	BSBB	SETPC
	MOVL	SAVFP(R4),R4		;GET ADDRESS OF PREVIOUS FRAME
	BNEQ	70$			;LOOP AS LONG AS LINKAGE IS VALID
	BRB	100$			;ZERO FP - BAD STACK

80$:	TSTL	R3			;ANY MORE FRAMES TO CONSIDER?
	BLEQ	90$			;IF LEQ NO
	MOVAL	B^LOOPUNWIND,R0		;SET FRAME UNWIND ADDRESS
	BSBB	SETPC			;
	BRB	60$			;
 
;
; MODIFY CHANGE OF FLOW RETURN IF NEW ADDRESS SPECIFIED
;
 
90$:	MOVL	NEWPC(AP),R0		;GET CHANGE OF FLOW RETURN ADDRESS
	BEQL	95$			;IF EQL NONE SPECIFIED
	CMPL	SAVPC(R4),#SYS$CALL_HANDL+4 ;CHECK IF THIS IS A HANDLER FRAME
	BNEQ	94$			;BRANCH IF NOT
;
; TO HERE IF THE FRAME BEING UNWOUND TO IS THE FRAME IN WHICH THE SIGNAL
; OCCURRED (DETECTED BY THE FACT THAT SAVPC IN THE FRAME ABOUT TO BE
; PLUGGED IS THE HANDLER CALL SITE). IF WE ARE STORING A NEW PC HERE,
; WE HAVE TO TAKE SPECIAL HANDLING SO THAT THE SIGNAL ARGUMENT LIST IS
; REMOVED BEFORE ALLOWING EXECUTION TO PROCEED. THIS IS DONE BY STORING
; THE DESIRED NEW PC IN THE PC OF THE SIGNAL VECTOR, AND SETTING THE
; RETURN PC TO A PIECE OF CODE THAT WILL CLEAN UP THE EXCEPTION.
;
110$:	MOVL	R4,R2			;GET POINTER TO STACK FRAME
	BSBW	OLDSP			;FIND THE EXCEPTION ARG LIST
	MOVL	CHF$L_SIGARGLST+4(R2),R2 ;GET SIGNAL VECTOR
	MOVZBL	-1(R2),R1		;GET ORIGINAL SIG ARG COUNT
	MOVL	R0,-4(R2)[R1]		;STORE PC IN NEXT TO LAST LONGWORD
	BICL	#PSL$M_CM!PSL$M_FPD!PSL$M_TBIT!PSL$M_TP,(R2)[R1]
					;CLEAN OUT OLD INSTRUCTION CONTEXT
	MOVAB	W^REMSIGNAL,R0		;ADDRESS OF CLEANUP ROUTINE

94$:	BSBB	SETPC			;SET NEW FINAL RETURN ADDRESS
95$:	MOVZWL	#SS$_NORMAL,R0		;SET NORMAL COMPLETION
	RET				;
100$:	MOVZWL	#SS$_INSFRAME,R0	;SET INSUFFICIENT FRAMES
	RET				;

;
; SUBROUTINE TO STORE UNWIND PC. IT CHECKS IF THE FRAME BEING ALTERED
; IS AN AST CALL FRAME. RATHER THAN PLUG ITS RETURN PC, WE LET
; IT RETURN TO THE AST DISPATCHER, WHO WILL DISMISS THE AST. INSTEAD,
; WE PLUG THE INTERRUPT PC OF THE AST, SO THE REI GOES BACK TO
; LOOPUNWIND TO CONTINUE WITH THE AST DISMISSED.
;

SETPC:	CMPL	SAVPC(R4),#EXE$ASTRET	;CHECK IF FRAME IS AN AST
	BEQL	10$			;BRANCH IF YES
	MOVL	R0,SAVPC(R4)		;SET FRAME UNWIND ADDRESS
	RSB

10$:	MOVL	R4,R2
	BSBW	OLDSP			;FIND THE START OF THE AST ARG LIST
	MOVL	R0,16(R2)		;AND STUFF THE AST PC
	BICL	#PSL$M_CM!PSL$M_FPD!PSL$M_TBIT!PSL$M_TP,20(R2)
					;CLEAN OUT OLD INSTRUCTION CONTEXT
	RSB
;
; UNWIND HANDLER FRAME
;
 
STARTUNWIND:				;START OF ACTUAL UNWIND
	MOVL	CHF$L_MCHARGLST+4(SP),R0 ;GET ADDRESS OF MECHANISM ARGUMENT LIST
	MOVQ	CHF$L_MCH_SAVR0(R0),R0	;RESTORE REGISTERS R0 AND R1
 
;
; UNWIND CALL FRAME SIGNALING CONDITION HANDLER IF ONE IS SPECIFIED
;
 
	.ENABL	LSB
LOOPUNWIND:				;UNWIND CALL FRAME
	TSTL	(FP)			;CONDITION HANDLER SPECIFIED?
	BEQL	10$			;IF EQL NO
	MOVZWL	#SS$_UNWIND,-(SP)	;PUSH UNWIND SIGNAL CONDITION
	PUSHL	#1			;PUSH NUMBER OF SIGNAL ARGUMENTS
	PUSHL	#2			;PUSH STOP INDICATOR
	PUSHR	#^M<R0,R1>		;PUSH REGISTERS R0 AND R1
	PUSHL	#0			;PUSH FRAME DEPTH
	PUSHL	FP			;PUSH FRAME ADDRESS
	PUSHL	#4			;PUSH NUMBER OF MECHANISM ARGUMENTS
	PUSHAL	(SP)			;PUSH ADDRESS OF MECHANISM ARGUMENTS
	PUSHAL	28(SP)			;PUSH ADDRESS OF SIGNAL ARGUMENTS
CALLUNWIND:				;SIGNAL UNWIND
	CALLS	#2,@(FP)		;CALL CONDITION HANDLER
	MOVQ	CHF$L_MCH_SAVR0(SP),R0	;RETRIEVE NEW VALUES FOR R0 AND R1
10$:	MOVAL	SAVRG(FP),AP		;GET ADDRESS OF REGISTER SAVE AREA
	BLBC	SAVMSK(FP),20$		;IF LBC R0 NOT SAVED
	MOVL	R0,(AP)+		;SAVE R0 FOR SUBSEQUENT RESTORATION
20$:	BBC	#1,SAVMSK(FP),30$	;IF CLR, R1 NOT SAVED
	MOVL	R1,(AP)			;SAVE R1 FOR SUBSEQUENT RESTORATION
30$:	CMPL	SAVPC(FP),#EXE$ASTRET	;ABOUT TO UNWIND AN AST?
	BNEQ	40$			;BRANCH IF NOT
	PUSHR	#^M<R1,R2>		;SAVE R1 AND R2
	MOVL	FP,R2
	BSBB	OLDSP			;FIND THE AST PARAMETER LIST
	POPL	R1			;GET BACK R1
	MOVQ	R0,8(R2)		;STUFF R0 AND R1 SO THEY WILL PASS THROUGH
	POPL	R2			;RESTORE R2
40$:	RET				;

;
; UNWIND TRANSFERS TO HERE WHEN A NEW PC IS GIVEN IN UNWINDING TO THE
; FRAME IN WHICH THE SIGNAL OCCURRED. WE MUST CLEAN THE EXCEPTION OFF
; THE STACK BEFORE RESUMING EXECUTION.
;
REMSIGNAL:
	TSTL	(SP)+			;REMOVE JSB RETURN ADDRESS
	BRW	EXE$CONTSIGNAL		;LET EXCEPTION MODULE DO THE REST
	.DSABL	LSB
	.PAGE
	.SBTTL	CALCULATE VALUE OF SP BEFORE CALL
;
; SUBROUTINE TO CALCULATE VALUE OF SP BEFORE CALL
;
 
OLDSP:	EXTZV	#14,#2,SAVMSK(R2),-(SP)	;GET STACK ALIGNMENT BIAS
	EXTZV	#0,#12,SAVMSK(R2),R1	;GET REGISTER SAVE MASK
	ADDL	#SAVRG,R2		;ADD OFFSET TO REGISTER SAVE AREA
	ADDL	(SP)+,R2		;ADD STACK ALIGNMENT BIAS
10$:	BLBC	R1,20$			;IF LBC CORRESPONDING REGISTER NOT SAVED
	ADDL	#4,R2			;ADJUST FOR SAVED REGISTER
20$:	ASHL	#-1,R1,R1		;ANY MORE REGISTERS SAVED?
	BNEQ	10$			;IF NEQ YES
	RSB				;
 
	.END
