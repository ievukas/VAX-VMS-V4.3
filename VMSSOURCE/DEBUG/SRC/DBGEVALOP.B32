MODULE DBGEVALOP (IDENT = 'V04-000') =

BEGIN

!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
! WRITTEN BY
!	R. Title	May, 1982
!	P. Sager	Jun, 1982
!
! MODULE FUNCTION
!	The top level routine in this module, DBG$EVAL_LANG_OPERATOR,
!	is called by the expression parser to perform an operation.
!	This routine does type conversion, as specified by language
!	specific type conversion tables, if needed. It then calls
!	the routine specified by language specific operator routine
!	tables, in order to actually perform the operation.
!

REQUIRE 'SRC$:DBGPROLOG.REQ';

LINKAGE
    PLI_LINK = CALL(REGISTER=0, REGISTER=1, REGISTER=2, REGISTER=3);

FORWARD ROUTINE
    AAA_DUMMY,				! Dummy routine to force dump of tables
    DBG$BLISS_BITSELECT: NOVALUE,	! Perform BLISS bit selection X<p,s,e>
    DBG$BLISS_INDIRECTION,		! Performs BLISS indirection
    DBG$CONV_TEXT_VALUE,		! Convert text string to value
    DBG$CONV_TQUADWORD_VALUE,		! Convert text string to QUADWORD
    DBG$CONV_TOCTAWORD_VALUE,		! Convert text string to OCTAWORD
    DBG$CONV_TRFA_VALUE,		! Convert text string to RFA value
    DBG$DO_MAPPING: NOVALUE,		! Perform type mapping
    DBG$EVALOP_SET_LANGUAGE: NOVALUE,	! Set up pointer to Operator Information
    					!    Tables
    DBG$EVAL_LANG_OPERATOR,		! Evaluate a language expr. operator
    DBG$GET_SET_TYPEID,			! Set the parent TYPEID for SET data type
    DBG$GET_DTYPE,			! Obtain dtype from Value Descriptor
    DBG$LANGUAGE_TYPE_CONV,		! Language-specific type converter
    DBG$MAP_DTYPE_CLASS,		! Given DTYPE, do a best guess at the
    					!    CLASS
    DBG$NUM_BYTES,			! Returns number of bytes to hold
    					!    a given DTYPE.
    DBG$PERFORM_TYPEID_CHECK,		! Perform typeid check on non-atomic
    					!    data types
    DBG$TYPE_CONV,			! Top level DEBUG type converter
    CONV_TEXT_PACK_VALUE,		! A routine convert the unconverted
    					!    string packed decimal 
    GET_DATA_LENGTH,			! Get the length of the data
    GET_SCALE,				! Get scaling factor for Floating Point
    					!    data to packed decimal conversion
    FIND_JOIN,				! Find join in directed acyclic graph
    FIND_PATH,				! Find path in directed acyclic graph
    FIND_PATH_DEPOSIT,			! Similar to FIND_PATH, used for DEPOSIT
    FIXUP_EMPTY_SET,			! Fix up typeid for empty set
    INTMED_DATA_FOR_DEP,		! Create intermediate data for deposit
    MAKE_VAL_DESC,			! Build a dummy value descriptor
    MAP_NRO_DTYPE_IN_RPG,		! Map normal and alternate least
    					!    significant digit and sign into
    					!    RPG standard output format
    MAP_PACKED:  NOVALUE,		! Maps packed decimal to correct type.
    MAP_PLI_TYPE_SIZE:  NOVALUE,	! Maps dtype to PL/I specific type; calculates size.
    MODIFY_PLI_TARGET_TYPE: NOVALUE,	! Modify PLI target type
    PLI_TYPE_CONV,			! PLI Type Conv. used for PLI bit-string
    					!    conversion
    PLI_HANDLER,			! Catches PL/I conversion errors.
    TYPEID_CHECK_ENUM,			! Perform typeid check on a pair of enum.
    TYPEID_CHECK_SET,			! Perform typeid check on a pair of sets
    TYPEID_RANGE_CHECK_ENUM,		! Perform range check for enum data type
    TYPEID_RANGE_CHECK_SUBRNG;		! Perform range check for subrange data type

EXTERNAL ROUTINE
    FOR$CVT_D_TE,			! Fortran E format routine
    FOR$CVT_G_TE,			! Fortran E format routine
    FOR$CVT_H_TE,			! Fortran E format routine
    MTH$JNOT,				! Bitwise complement of a Longword
    OTS$CVT_TB_L,			! Convert text Binary to Longword
    OTS$CVT_TI_L,			! Convert text (signed) to Longword
    OTS$CVT_T_F,			! Convert text to single Floating
    OTS$CVT_T_D,			! Convert text to Double Float
    OTS$CVT_T_G,			! Convert text to G_Float
    OTS$CVT_T_H,			! Convert text to H_Float
    OTS$CVT_TO_L,			! Convert text (octal) to Longword
    OTS$CVT_TZ_L,			! Convert text (hexadecimal) to Longword
    PLI$CHARABIT_R6:  PLI_LINK,		! Convert text to aligned bit-string.
    PLI$CVRT_ANY,			! Used in PL/I bit-strings conversions.
    DBG$COLLECT: NOVALUE,		! "Sanitize" Primary Descriptors
    DBG$COVER_DX_DX,			! Debug type converter.
    DBG$CVT_DX_DX:  NOVALUE,		! Debug version of LIB$CVT_DX_DX
    DBG$CVT_TQUADWORD_TO_VALUE,		! Convert into QUADWORD value
    DBG$CVT_TUQUADWORD_TO_VALUE,	! Convert into unsigned QUADWORD value
    DBG$CVT_TOCTAWORD_TO_VALUE,		! Convert into OCTAWORD value
    DBG$CVT_TRFA_TO_VALUE,		! Convert into RFA value
    DBG$GET_DST_NAME,			! Obtain name of symbol
    DBG$GET_TEMPMEM,			! Allocate temporary memory
    DBG$MAKE_SKELETON_DESC,		! Create skeleton Value Descriptor
    DBG$MAKE_VAL_DESC,			! Convert VMS desc to valdesc
    DBG$MAKE_VMS_DESC,			! Convert Primary to VMS desc
    DBG$NEWLINE: NOVALUE,		! Close print line and start new line
    DBG$PERFORM_OPERATOR: NOVALUE,	! Perform arithmetic operation
    DBG$PRIM_TO_ADDR,			! Convert primary descriptor to value
    				 	!    descriptor containing the address
    					!    of the primary.
    DBG$PRIM_TO_VAL,			! Converts a primary descriptor
    					!    to a value descriptor
    DBG$PRINT: NOVALUE,			! Print FAO-formatted text
    DBG$STA_SYMVALUE: NOVALUE,		! Get symbol's value
    DBG$STA_TYP_ATOMIC: NOVALUE,	! Get symbol information
    DBG$STA_TYP_ENUM: NOVALUE,		! Get symbol information
    DBG$STA_TYP_PICT: NOVALUE,		! Get symbol information
    DBG$STA_TYP_SET: NOVALUE,		! Get symbol information
    DBG$STA_TYP_SUBRNG: NOVALUE,	! Get symbol information
    DBG$STA_TYP_TYPEDPTR: NOVALUE,	! Get symbol information
    DBG$TYPEID_FOR_SET;			! Construct a Set Constant typeid

EXTERNAL
    DBG$GB_LANGUAGE: BYTE,		! Current lang setting
    DBG$GL_NEG_CONST_TOKEN,		! Negative constant token 
    DBG$GL_POS_CONST_TOKEN,		! Positive constant token 
    DBG$GL_NEG_SIGN_TOKEN,		! Negative constant token (--> unary minus)
    DBG$GL_POS_SIGN_TOKEN,		! Positive constant token (--> unary plus)
    DBG$GL_DEVELOPER: BITVECTOR[];	! Set developer flag

BUILTIN
    ASHP,
    EDITPC;

LITERAL 
    DBG$K_DTYPE_ARRAY  = DBG$K_MAXIMUM_DTYPE + RST$K_TYPE_ARRAY,
    DBG$K_DTYPE_ENUM   = DBG$K_MAXIMUM_DTYPE + RST$K_TYPE_ENUM,
    DBG$K_DTYPE_TPTR   = DBG$K_MAXIMUM_DTYPE + RST$K_TYPE_TPTR,
    DBG$K_DTYPE_SET    = DBG$K_MAXIMUM_DTYPE + RST$K_TYPE_SET,
    DBG$K_DTYPE_SUBRNG = DBG$K_MAXIMUM_DTYPE + RST$K_TYPE_SUBRNG,
    DBG$K_DTYPE_PTR    = DBG$K_MAXIMUM_DTYPE + RST$K_TYPE_PTR,
    DBG$K_DTYPE_PICT   = DBG$K_MAXIMUM_DTYPE + RST$K_TYPE_PICT,
    DBG$K_DTYPE_RFA    = DBG$K_MAXIMUM_DTYPE + RST$K_TYPE_RFA;


! The following is so that the map table can do a mapping from
! DST$K_BOOL to DSC$K_DTYPE_TF
!
LITERAL
    DSC$K_DTYPE_BOOL = DST$K_BOOL;


! The following is so that the lang. cvt table can do a conversion from
! DST$K_DTYPE_ANY to a specify dtype or a specify dtype to DST$K_DTYPE_ANY.
! 
LITERAL
    DSC$K_DTYPE_ANY = %X'FF';


BIND 
    TABLEBASE = UPLIT BYTE (%ASCII 'BASE');

! OPCODE_NAME is global so that the type converter can get at it for
! purposes of signalling error messages.
!
GLOBAL
    DBG$GL_OPCODE_NAME: REF VECTOR [,BYTE];	! Operator name in ASCIC

OWN
    BLISS_BITSELECTION_FLAG1:INITIAL(0),! Flag saying we've done a bit select
    					!    operator in BLISS
    BLISS_BITSELECTION_FLAG2:INITIAL(0),! Flag saying we've done a bit select
    					!    operator in BLISS
    BLISS_INDIRECTION_FLAG,		! Flag saying whether we've done an
    					!    indirection yet
    CVT_ROUND_FLAG,			! A flag set to TRUE indicate the 
    					!    conversion result is rounded
    CVT_TBL: REF VECTOR [,LONG],	! Pointer to a Language Dependent Type 
    					!    Conversion Table
    CVT_TBL_SIZE,			! Number of entries in CVT_TBL
    CVTINFO_TABLE: REF CVTINFO$TABLE,	! Pointer to the Type Conversion
    					!    Table for the current language
    MAP_TBL: REF VECTOR [,WORD],	! Pointer to a Type Mapping Table
    MAP_TBL_SIZE,			! Number of entries in MAP_TBL
    MAX_DEPTH,				! Maxinum search depth for graphs
    OPINFO_TABLE: REF OPINFO$TABLE,	! Pointer to the Operator Information
    					!    Table for the current language
    SAVE_RESULT_DESC: DBG$STG_DESC;	! Saved descriptor for commnication
    					!    between <> and . in BLISS

!	M A C R O S   F O R   O P E R A T O R   R O U T I N E   T A B L E S
!
!
!
!	These macros are used to generate the tables which are used to select
!	operator routines based on the operand data types and which define any
!	type conversion behavior appropriate to the operator.  For example,
!	INT*REAL has to be converted to REAL*REAL in most languages, after
!	which the REAL*REAL multiply routine is invoked; this kind of behavior
!	is specified in the tables whose structure is defined here.
!
!
!
!

! OPERATOR ROUTINE TABLE
!
!
! The Operator Routine Table for a given operator contains one entry for each
! routine which can be associated with that operator.  Each such entry contains
! the operand types accepted by that routine (e.g., REAL,REAL for F_Floating
! multiply) and a routine index which identifies the routine to be invoked.
! And also there is an optional routine index for typeid check.
! The types are represented as standard Dtypes and
! the routine index is simply a CASE index used to select the routine body.
!
! An Operator Routine Table for an operator is declared as follows:
!
!	OPERATOR_ROUTINE_TABLE(TBLNAME,
!	    OPERATOR_ROUTINE(LEFT_TYPE, RIGHT_TYPE, RESULT_TYPE, ROUT_NAME, 
!			     TYPEID_CHECK_ROUT_NAME),
!			...
!	    OPERATOR_ROUTINE(LEFT_TYPE, RIGHT_TYPE, RESULT_TYPE, ROUT_NAME,
!			     TYPEID_CHECK_ROUT_NAME));
!
! Here TBLNAME is the name of the table.  LEFT_TYPE is the Type Index Value of
! the left argument (or the only argument if the operator is unary), RIGHT_TYPE
! is the Type Index Value of the right argument (or 0 if the operator is unary),
! and ROUT_NAME is the name of the corresponding semantic routine.  ROUT_NAME
! is automatically prefixed by "ORT$K_" to yield the routine index value.
! TYPEID_CHECK_ROUT_NAME is the name of the corresponding typeid check semantic
! routine.  TYPEID_CHECK_ROUT_NAME is automatically prefixed by "ORT$K_TYPEID" 
! to yield the routine index value.
!
! Define the macros that generate the Operator Routine Table.
!
MACRO
    OPERATOR_ROUTINE_TABLE(TBLNAME) =
	BIND TBLNAME = PLIT BYTE(%REMAINING): VECTOR[,BYTE] %;

MACRO
    OPERATOR_ROUTINE(LEFT_TYPE, RIGHT_TYPE, RESULT_TYPE, ROUT_NAME, 
    			TYPEID_CHECK_ROUT_NAME) =
        %IF %DECLARED (%NAME ('RST$K_TYPE_', RIGHT_TYPE))
    	%THEN
    	    DBG$K_MAXIMUM_DTYPE + %NAME ('RST$K_TYPE_', RIGHT_TYPE)
    	%ELSE
    	    %NAME ('DSC$K_DTYPE_', RIGHT_TYPE)
    	%FI , 
        %IF %DECLARED (%NAME ('RST$K_TYPE_', LEFT_TYPE))
    	%THEN
    	    DBG$K_MAXIMUM_DTYPE + %NAME ('RST$K_TYPE_', LEFT_TYPE)
    	%ELSE
    	    %NAME ('DSC$K_DTYPE_', LEFT_TYPE)
    	%FI , 
    	%NAME ('ORT$K_', ROUT_NAME) AND %X'00FF', 
    	%NAME ('ORT$K_', ROUT_NAME)^-8,
    	%IF %LENGTH LEQ 4
    	%THEN
            0
    	%ELSE
    	    %NAME ('ORT$K_TYPEID_', TYPEID_CHECK_ROUT_NAME) AND %X'00FF'
    	%FI,
    	%IF %LENGTH LEQ 4
    	%THEN
    	    0
    	%ELSE
    	    %NAME ('ORT$K_TYPEID_', TYPEID_CHECK_ROUT_NAME)^-8
    	%FI,
    	%IF %DECLARED (%NAME ('ORT$K_RESULT_', RESULT_TYPE))
    	%THEN
    	    %NAME ('ORT$K_RESULT_', RESULT_TYPE)
    	%ELSE
            (%IF %DECLARED (%NAME ('RST$K_TYPE_', RESULT_TYPE))
    	     %THEN
    	         DBG$K_MAXIMUM_DTYPE + %NAME ('RST$K_TYPE_', RESULT_TYPE)
    	     %ELSE
    	         %NAME ('DSC$K_DTYPE_', RESULT_TYPE)
    	     %FI)
    	%FI, 
    	0%; 


! The TYPE_GRAPH_EDGE macro is used by the tables below.
!
MACRO
    TYPE_GRAPH_EDGE (LOWER_TYPE, HIGHER_TYPE) =
        (%IF %DECLARED (%NAME ('RST$K_TYPE_', HIGHER_TYPE))
    	%THEN
    	    DBG$K_MAXIMUM_DTYPE + %NAME ('RST$K_TYPE_', HIGHER_TYPE)
    	%ELSE
    	    %NAME ('DSC$K_DTYPE_', HIGHER_TYPE)
    	%FI)^8 
    	OR
        (%IF %DECLARED (%NAME ('RST$K_TYPE_', LOWER_TYPE))
    	%THEN
    	    DBG$K_MAXIMUM_DTYPE + %NAME ('RST$K_TYPE_', LOWER_TYPE)
    	%ELSE
    	    %NAME ('DSC$K_DTYPE_', LOWER_TYPE)
    	%FI) %; 

! TYPE HIERARCHY TABLE
!
! The Type Hierarchy Table specifies the implicit type conversions to 
! be done within an expression. A type hierarchy table may be specific
! to a given operator in a given language, or may be shared across 
! operators and languages.
!
! The Type Hierarchy Table is a directed acyclic graph. For example,
! for the addition operator in Fortran, a part of the Type Hierarchy
! Table might look like this:
!
!			  F_COMPLEX  -> D_COMPLEX
!			 ^		   ^
!			/		  /
!	LONG -> F_FLOAT  		 /
!	  		\		/	
!	  		 v	       /
!	  		  D_FLOAT -> H_FLOAT
!
! A Type Hierarchy Table is specified by giving its edges. 
!
! An example of a Type Hierarchy Table definition is:
!
! TYPE_HIERARCHY_TABLE ( FORADD_TYPE_HIER_TABLE,
!	TYPE_GRAPH_EDGE (L, F),
!	TYPE_GRAPH_EDGE (F, FC),
!	TYPE_GRAPH_EDGE (F, D),
!	...,0 );
!

! Define the macro which declares a Type Hierarchy Table.
!
MACRO
    TYPE_HIERARCHY_TABLE (TBLNAME) =
    	BIND TBLNAME = PLIT WORD(%REMAINING) : VECTOR [,WORD] %;


! TYPE INCOMPATIBILITY TABLE
!
! The Type Incompatibility Table specifies which pairs of types are
! incompatible (i.e., it is illegal for both to be in the same
! operator expression). For example, D_FLOAT and G_FLOAT are
! incompatible in FORTRAN. A Type Incompatibility Table may be specific  
! to a given operator in a given language, or may be shared across 
! operators and languages.
!
! A Type Incompatibility Table is specified by giving a list of 
! incompatible type pairs. 
!
! An example of a Type Incompatibility Table definition is:
!
! TYPE_INCOMP_TABLE ( FORADD_TYPE_INCOMP_TABLE,
!	TYPE_GRAPH_EDGE (D, G),0);
!

! Define the macro which declares a Type Hierarchy Table.
!
MACRO
    TYPE_INCOMP_TABLE (TBLNAME)
    	= BIND TBLNAME = PLIT WORD(%REMAINING) : VECTOR [,WORD] %;


!
! OPERATOR INFORMATION TABLE
!
!
! The Operator Information Table for a language is a blockvector indexed by
! operator code.  For each operator, it gives the address of the corresponding
! Operator Routine Table, Type Hierarchy Table, Type Incompatibility Table, 
! and a flag.  All addresses are relative to TABLEBASE.  An Operator 
! Information Table is declared as follows:
!
!	OPERATOR_INFO_TABLE(TBLNAME,
!		OPERATOR_INFO_ENTRY(OPCODE, ROUTTBL, HIERTBL, INCOMPTBL, 
!				FETCH_FLAG),
!			...
!		OPERATOR_INFO_ENTRY(OPCODE, ROUTTBL, HIERTBL, INCOMPTBL, 
!				FETCH_FLAG));
!
! Here TBLNAME is the name of the whole Operator Information Table.  For each
! operator accepted by the language, OPCODE is the operator code name for the
! operator (this is automatically prefixed by "TOKEN$K_" by the macro).
!
! Define the macros which declare Operator Information Tables.
!
MACRO
    OPERATOR_INFO_TABLE(TBLNAME) =
    	OWN TBLNAME : OPINFO$TABLE PSECT(DBG$PLIT) PRESET(%REMAINING) %;

MACRO
    OPERATOR_INFO_ENTRY (OPERATOR, ROUTTBL, HIERTBL, INCOMPTBL, FALSE) = 
	[ %NAME ('TOKEN$K_', OPERATOR), OPINFO$L_ROUTTBL] =
    		ROUTTBL - TABLEBASE,
    	[ %NAME ('TOKEN$K_', OPERATOR), OPINFO$L_HIERTBL] =
    		HIERTBL - TABLEBASE,
    	[ %NAME ('TOKEN$K_', OPERATOR), OPINFO$L_INCOMPTBL] =
    		INCOMPTBL - TABLEBASE,
    	%IF %LENGTH LEQ 4
    	%THEN
    	     [ %NAME ('TOKEN$K_', OPERATOR), OPINFO$V_FETCH] = TRUE
    	%ELSE
    	     [ %NAME ('TOKEN$K_', OPERATOR), OPINFO$V_FETCH] = FALSE
    	%FI %;

! TYPE MAPPING TABLE
!
! The Type Mapping Table specifies the mapping of data types to be done
! prior to any expression evaluation. For example, in FORTRAN data type
! WU is treated the same as type W in expressions, so the mapping from
! WU to W is done here.
!
! A Type Mapping Table is represented as a sequence of pairs of data types.
!
! An example of a Type Mapping Table definition is:
!
! TYPE_MAPPING_TABLE ( FORTRAN_TYPE_MAPPING_TABLE,
!	TYPE_GRAPH_EDGE (BU, B),
!	TYPE_GRAPH_EDGE (WU, W),
!	TYPE_GRAPH_EDGE (LU, L),
!	0);
!

! Define the macro which declares a Type Mapping Table.
!
MACRO
    TYPE_MAPPING_TABLE (TBLNAME)
    	= BIND TBLNAME = PLIT WORD (%REMAINING) : VECTOR [,WORD] %;


!
! TYPE CONVERSION INFORMATION TABLE
!
!
! The Type Conversion Table for a language is a vector of longwords.  For
! each longword, it gives the address of the corresponding Type Mapping Table, 
! Type Conversion Table needed for the language.  All addresses are relative 
! to TABLEBASE.  An Operator Information Table is declared as follows:
!
!	CONVERSION_INFO_TABLE(TBLNAME,
!		CONVERSION_INFO_ENTRY(MAPTBL, CONVTBL, CVT_ROUNDING_FLAG));
!
! Here TBLNAME is the name of the whole Type Conversion Information Table.  
!
! Define the macros which declare Type Conversion Information Tables.
!
MACRO
    CONVERSION_INFO_TABLE(TBLNAME) =
    	OWN TBLNAME : CVTINFO$TABLE PSECT(DBG$PLIT) PRESET(%REMAINING) %;

MACRO
    CONVERSION_INFO_ENTRY (MAPTBL, CVTTBL, TRUE) = 
    	[CVTINFO$L_MAPTBL] = MAPTBL - TABLEBASE,
    	[CVTINFO$L_CVTTBL] = CVTTBL - TABLEBASE,
    	%IF %LENGTH LEQ 2
    	%THEN
    	    [CVTINFO$V_ROUND] = FALSE
    	%ELSE
    	    [CVTINFO$V_ROUND] = TRUE
    	%FI %;

! LANGUAGE SPECIFIC TYPE CONVERSION TABLE
!
! The Language Specific Type Conversion Table specifies which type conversions
! are to be done in a language specific manner.  For example, although PL/I 
! bit-strings have a dtype of V or VU, they are handled very differently from
! most other data having those data types (as in BLISS or Pascal).
!
! A language specific conversion table is specified by giving a case index,
! and a higher and lower type.
!
! An example of a language specific conversion table entry is:
!	LANG_CVT_TABLE (PLI_CVT_TABLE,
!	    LANG_CVT_INDEX (CVT$PLI_TF_L, L, TF),
!	    0);
!


! Define the macro which declares the entries for Language Specific Type
! Conversion Table.
!
MACRO
    LANG_CVT_ENTRY (INDEX, LOWER_TYPE, HIGHER_TYPE) =
	((((%NAME ('CVT$K_', INDEX))^8)
	OR
        (%IF %DECLARED (%NAME ('RST$K_TYPE_', HIGHER_TYPE))
	%THEN
	    DBG$K_MAXIMUM_DTYPE + %NAME ('RST$K_TYPE_', HIGHER_TYPE)
	%ELSE
	    %NAME ('DSC$K_DTYPE_', HIGHER_TYPE)
	%FI))^8)
	OR
        (%IF %DECLARED (%NAME ('RST$K_TYPE_', LOWER_TYPE))
	%THEN
	    DBG$K_MAXIMUM_DTYPE + %NAME ('RST$K_TYPE_', LOWER_TYPE)
	%ELSE
	    %NAME ('DSC$K_DTYPE_', LOWER_TYPE)
	%FI) %; 


! Define the macro which declares a Language Specific Type Conversion Table.
!
MACRO
    LANG_CVT_TABLE (TBLNAME)
	= BIND TBLNAME = PLIT LONG (%REMAINING):  VECTOR[, LONG] %;


! 	A D A    O P E R A T O R   I N F O R M A T I O N   T A B L E S
!
! This section contains the Operator Routine and Type tables needed to
! evaluate expressions in the ADA language.


! Define the Type Conversion Information Table for ADA.
! For now, there are no exceptions to the standard DBG$CVT_DX_DX conversion
! rules so we do not specify any tables here.
!
CONVERSION_INFO_TABLE (ADA_CVTINFO_TABLE,
    CONVERSION_INFO_ENTRY (TABLEBASE, TABLEBASE));


! Define the Type Hierarchy Table for ADA. This table specifies the implicit
! type conversions to be done on arithmetic operations.
!
! For debugging purposes, we have decided to adopting looser rules than
! the compiler. For example, to add an integer X to a float Y in ADA,
! you have to say something like "FLOAT(X) + Y". But in the debugger, we
! will do the implicit conversion and allow just "X + Y".
!
! We thus allow integer to be converted to either FIXED or FLOAT.
! We allow the conversion of FIXED to H float (but not to F, D, or G
! since that could lose precision).
!
!     BU,WU,LU              G
!	       \          /   \
!       B,W ----> L -> F -> D -> H
!		   \            /
!		     - FIXED --
!
TYPE_HIERARCHY_TABLE (ADA_HIER_TABLE,
    TYPE_GRAPH_EDGE (B,  L),
    TYPE_GRAPH_EDGE (BU, L),
    TYPE_GRAPH_EDGE (W,  L),
    TYPE_GRAPH_EDGE (WU, L),
    TYPE_GRAPH_EDGE (LU, L),
    TYPE_GRAPH_EDGE (L,  F),
    TYPE_GRAPH_EDGE (L,  FIXED),
    TYPE_GRAPH_EDGE (F,  D),
    TYPE_GRAPH_EDGE (F,  G),
    TYPE_GRAPH_EDGE (FIXED, H),
    TYPE_GRAPH_EDGE (D,  H),
    TYPE_GRAPH_EDGE (G,  H),
    0);


! Define the Type Hierarchy Table for ADA deposit. 
!
TYPE_HIERARCHY_TABLE (ADA_DEPOSIT_TABLE,

    ! Allow any numeric type to any other numeric type.
    !
    TYPE_GRAPH_EDGE (B, BU),
    TYPE_GRAPH_EDGE (BU, W),
    TYPE_GRAPH_EDGE (W, WU),
    TYPE_GRAPH_EDGE (WU, L),
    TYPE_GRAPH_EDGE (L, LU),
    TYPE_GRAPH_EDGE (LU, FIXED),
    TYPE_GRAPH_EDGE (FIXED, F),
    TYPE_GRAPH_EDGE (F ,D),
    TYPE_GRAPH_EDGE (D, G),
    TYPE_GRAPH_EDGE (G, H),
    TYPE_GRAPH_EDGE (H, B),

    ! Allow number -> SUBRNG. The constraint check should be done
    ! by the DBG$PERFORM_TYPEID_CHECK routine. Also allow ENUM->SUBRNG
    ! and character -> SUBRNG.
    !
    TYPE_GRAPH_EDGE (ENUM, SUBRNG),
    TYPE_GRAPH_EDGE (T, SUBRNG),
    TYPE_GRAPH_EDGE (L, SUBRNG),
    TYPE_GRAPH_EDGE (FIXED, SUBRNG),
    TYPE_GRAPH_EDGE (F, SUBRNG),
    TYPE_GRAPH_EDGE (D, SUBRNG),
    TYPE_GRAPH_EDGE (G, SUBRNG),
    TYPE_GRAPH_EDGE (H, SUBRNG),
    0);


! Define the Operator Routine Table for ADA unary plus.
!
OPERATOR_ROUTINE_TABLE (ADA_UNARY_PLUS_TABLE,

! The following are not language dependent types.  This is needed for DEBUG
! types.  For example, DEP/QUAD L= +1.
!
    OPERATOR_ROUTINE (B, B, B, UNARY_PLUS_B),
    OPERATOR_ROUTINE (W, W, W, UNARY_PLUS_W),
    OPERATOR_ROUTINE (P, P, P, UNARY_PLUS_P),
    OPERATOR_ROUTINE (Q, Q, Q, UNARY_PLUS_Q),
    OPERATOR_ROUTINE (O, O, O, UNARY_PLUS_O),

    OPERATOR_ROUTINE (L, L, L, UNARY_PLUS_L),
    OPERATOR_ROUTINE (FIXED, FIXED, FIXED, UNARY_PLUS_FIXED),
    OPERATOR_ROUTINE (F, F, F, UNARY_PLUS_F),
    OPERATOR_ROUTINE (D, D, D, UNARY_PLUS_D),
    OPERATOR_ROUTINE (G, G, G, UNARY_PLUS_G),
    OPERATOR_ROUTINE (H, H, H, UNARY_PLUS_H));


! Define the Operator Routine Table for ADA unary minus.
!
OPERATOR_ROUTINE_TABLE (ADA_UNARY_MINUS_TABLE,

! The following are not language dependent types.  This is needed for DEBUG
! types.  For example, DEP/QUAD L= -1.
!
    OPERATOR_ROUTINE (B, B, B, UNARY_MINUS_B),
    OPERATOR_ROUTINE (W, W, W, UNARY_MINUS_W),
    OPERATOR_ROUTINE (P, P, P, UNARY_MINUS_P),
    OPERATOR_ROUTINE (Q, Q, Q, UNARY_MINUS_Q),
    OPERATOR_ROUTINE (O, O, O, UNARY_MINUS_O),

    OPERATOR_ROUTINE (L, L, L, UNARY_MINUS_L),
    OPERATOR_ROUTINE (FIXED, FIXED, FIXED, UNARY_MINUS_FIXED),
    OPERATOR_ROUTINE (F, F, F, UNARY_MINUS_F),
    OPERATOR_ROUTINE (D, D, D, UNARY_MINUS_D),
    OPERATOR_ROUTINE (G, G, G, UNARY_MINUS_G),
    OPERATOR_ROUTINE (H, H, H, UNARY_MINUS_H));


! Define the Operator Routine Table for ADA absolute value.
!
OPERATOR_ROUTINE_TABLE (ADA_ABSOLUTE_TABLE,
    OPERATOR_ROUTINE (L, L, L, ABS_L),
    OPERATOR_ROUTINE (FIXED, FIXED, FIXED, ABS_FIXED),
    OPERATOR_ROUTINE (F, F, F, ABS_F),
    OPERATOR_ROUTINE (D, D, D, ABS_D),
    OPERATOR_ROUTINE (G, G, G, ABS_G),
    OPERATOR_ROUTINE (H, H, H, ABS_H));


! Define the Operator Routine Table for ADA addition.
!
OPERATOR_ROUTINE_TABLE (ADA_ADD_TABLE,
    OPERATOR_ROUTINE (L, L, L, ADD_L_L),
    OPERATOR_ROUTINE (FIXED, FIXED, FIXED, ADD_FIXED_FIXED),
    OPERATOR_ROUTINE (F, F, F, ADD_F_F),
    OPERATOR_ROUTINE (D, D, D, ADD_D_D),
    OPERATOR_ROUTINE (G, G, G, ADD_G_G),
    OPERATOR_ROUTINE (H, H, H, ADD_H_H));


! Define the Operator Routine Table for ADA subtraction.
!
OPERATOR_ROUTINE_TABLE (ADA_SUBTRACT_TABLE,
    OPERATOR_ROUTINE (L, L, L, SUB_L_L),
    OPERATOR_ROUTINE (FIXED, FIXED, FIXED, SUB_FIXED_FIXED),
    OPERATOR_ROUTINE (F, F, F, SUB_F_F),
    OPERATOR_ROUTINE (D, D, D, SUB_D_D),
    OPERATOR_ROUTINE (G, G, G, SUB_G_G),
    OPERATOR_ROUTINE (H, H, H, SUB_H_H));


! Define the Operator Routine Table for ADA multiplication.
!
OPERATOR_ROUTINE_TABLE (ADA_MULTIPLY_TABLE,
    OPERATOR_ROUTINE (L, L, L, MUL_L_L),
    OPERATOR_ROUTINE (FIXED, FIXED, FIXED, MUL_FIXED_FIXED),
    OPERATOR_ROUTINE (F, F, F, MUL_F_F),
    OPERATOR_ROUTINE (D, D, D, MUL_D_D),
    OPERATOR_ROUTINE (G, G, G, MUL_G_G),
    OPERATOR_ROUTINE (H, H, H, MUL_H_H));


! Define the Operator Routine Table for ADA division.
!
OPERATOR_ROUTINE_TABLE (ADA_DIVIDE_TABLE,
    OPERATOR_ROUTINE (L, L, L, DIV_L_L),
    OPERATOR_ROUTINE (FIXED, FIXED, FIXED, DIV_FIXED_FIXED),
    OPERATOR_ROUTINE (F, F, F, DIV_F_F),
    OPERATOR_ROUTINE (D, D, D, DIV_D_D),
    OPERATOR_ROUTINE (G, G, G, DIV_G_G),
    OPERATOR_ROUTINE (H, H, H, DIV_H_H));


! Define the Operator Routine Table for ADA Modulus.
!
OPERATOR_ROUTINE_TABLE (ADA_MODULUS_TABLE,
    OPERATOR_ROUTINE (L, L, L, MOD_L_L));


! Define the Operator Routine Table for ADA Remainder.
!
OPERATOR_ROUTINE_TABLE (ADA_REMAINDER_TABLE,
    OPERATOR_ROUTINE (L, L, L, REM_L_L));


! Define the Operator Routine Table for ADA Exponentiation.
!
OPERATOR_ROUTINE_TABLE (ADA_POWER_OF_TABLE,
    OPERATOR_ROUTINE (L, L, L, POWER_L_L),
    OPERATOR_ROUTINE (F, F, F, POWER_F_F),
    OPERATOR_ROUTINE (D, D, D, POWER_D_D),
    OPERATOR_ROUTINE (G, G, G, POWER_G_G),
    OPERATOR_ROUTINE (H, H, H, POWER_H_H));


! Define the Operator Routine Table for ADA Logical Not.
!
OPERATOR_ROUTINE_TABLE (ADA_NOT_TABLE,
    OPERATOR_ROUTINE (TF, TF, TF, NOT_L));


! Define the Operator Routine Table for ADA Logical And.
!
OPERATOR_ROUTINE_TABLE (ADA_AND_TABLE,
    OPERATOR_ROUTINE (TF, TF, TF, AND_L_L));


! Define the Operator Routine Table for ADA Logical Or.
!
OPERATOR_ROUTINE_TABLE (ADA_OR_TABLE,
    OPERATOR_ROUTINE (TF, TF, TF, OR_L_L));


! Define the Operator Routine Table for ADA Logical Exclusive Or.
!
OPERATOR_ROUTINE_TABLE (ADA_XOR_TABLE,
    OPERATOR_ROUTINE (TF, TF, TF, XOR_L_L));


! Define the Operator Routine Table for ADA Equal.
!
OPERATOR_ROUTINE_TABLE (ADA_EQUAL_TABLE,
    OPERATOR_ROUTINE (ENUM, ENUM, TF, EQL_L_L, ENUM_ENUM),
    OPERATOR_ROUTINE (L,  L,  TF, EQL_L_L),
    OPERATOR_ROUTINE (FIXED, FIXED, TF, EQL_FIXED_FIXED),
    OPERATOR_ROUTINE (F,  F,  TF, EQL_F_F),
    OPERATOR_ROUTINE (D,  D,  TF, EQL_D_D),
    OPERATOR_ROUTINE (G,  G,  TF, EQL_G_G),
    OPERATOR_ROUTINE (H,  H,  TF, EQL_H_H),
    OPERATOR_ROUTINE (TF, TF, TF, EQL_TF_TF));


! Define the Operator Routine Table for ADA Not Equal.
!
OPERATOR_ROUTINE_TABLE (ADA_NOT_EQUAL_TABLE,
    OPERATOR_ROUTINE (ENUM, ENUM, TF, NEQ_L_L, ENUM_ENUM),
    OPERATOR_ROUTINE (L,  L,  TF, NEQ_L_L),
    OPERATOR_ROUTINE (FIXED, FIXED, TF, NEQ_FIXED_FIXED),
    OPERATOR_ROUTINE (F,  F,  TF, NEQ_F_F),
    OPERATOR_ROUTINE (D,  D,  TF, NEQ_D_D),
    OPERATOR_ROUTINE (G,  G,  TF, NEQ_G_G),
    OPERATOR_ROUTINE (H,  H,  TF, NEQ_H_H),
    OPERATOR_ROUTINE (TF, TF, TF, NEQ_TF_TF));


! Define the Operator Routine Table for ADA Less Than.
!
OPERATOR_ROUTINE_TABLE (ADA_LSS_THAN_TABLE,
    OPERATOR_ROUTINE (ENUM, ENUM, TF, LSS_L_L, ENUM_ENUM),
    OPERATOR_ROUTINE (L,  L,  TF, LSS_L_L),
    OPERATOR_ROUTINE (FIXED, FIXED, TF, LSS_FIXED_FIXED),
    OPERATOR_ROUTINE (F,  F,  TF, LSS_F_F),
    OPERATOR_ROUTINE (D,  D,  TF, LSS_D_D),
    OPERATOR_ROUTINE (G,  G,  TF, LSS_G_G),
    OPERATOR_ROUTINE (H,  H,  TF, LSS_H_H),
    OPERATOR_ROUTINE (TF, TF, TF, LSS_TF_TF));


! Define the Operator Routine Table for ADA Greater Than.
!
OPERATOR_ROUTINE_TABLE (ADA_GTR_THAN_TABLE,
    OPERATOR_ROUTINE (ENUM, ENUM, TF, GTR_L_L, ENUM_ENUM),
    OPERATOR_ROUTINE (L,  L,  TF, GTR_L_L),
    OPERATOR_ROUTINE (FIXED, FIXED, TF, GTR_FIXED_FIXED),
    OPERATOR_ROUTINE (F,  F,  TF, GTR_F_F),
    OPERATOR_ROUTINE (D,  D,  TF, GTR_D_D),
    OPERATOR_ROUTINE (G,  G,  TF, GTR_G_G),
    OPERATOR_ROUTINE (H,  H,  TF, GTR_H_H),
    OPERATOR_ROUTINE (TF, TF, TF, GTR_TF_TF));


! Define the Operator Routine Table for ADA Less Than or Equal to.
!
OPERATOR_ROUTINE_TABLE (ADA_LSS_EQUAL_TABLE,
    OPERATOR_ROUTINE (ENUM, ENUM, TF, LEQ_L_L, ENUM_ENUM),
    OPERATOR_ROUTINE (L,  L,  TF, LEQ_L_L),
    OPERATOR_ROUTINE (FIXED, FIXED, TF, LEQ_FIXED_FIXED),
    OPERATOR_ROUTINE (F,  F,  TF, LEQ_F_F),
    OPERATOR_ROUTINE (D,  D,  TF, LEQ_D_D),
    OPERATOR_ROUTINE (G,  G,  TF, LEQ_G_G),
    OPERATOR_ROUTINE (H,  H,  TF, LEQ_H_H),
    OPERATOR_ROUTINE (TF, TF, TF, LEQ_TF_TF));


! Define the Operator Routine Table for ADA Greater Than or Equal to.
!
OPERATOR_ROUTINE_TABLE (ADA_GTR_EQUAL_TABLE,
    OPERATOR_ROUTINE (ENUM, ENUM, TF, GEQ_L_L, ENUM_ENUM),
    OPERATOR_ROUTINE (L,  L,  TF, GEQ_L_L),
    OPERATOR_ROUTINE (FIXED, FIXED, TF, GEQ_FIXED_FIXED),
    OPERATOR_ROUTINE (F,  F,  TF, GEQ_F_F),
    OPERATOR_ROUTINE (D,  D,  TF, GEQ_D_D),
    OPERATOR_ROUTINE (G,  G,  TF, GEQ_G_G),
    OPERATOR_ROUTINE (H,  H,  TF, GEQ_H_H),
    OPERATOR_ROUTINE (TF, TF, TF, GEQ_TF_TF));


! Define the Operator Routine Table for ADA Concatenate.
!
OPERATOR_ROUTINE_TABLE (ADA_CONCATENATE_TABLE,
    OPERATOR_ROUTINE (T, T, T, CONCAT_T_T));


! Define the Operator Information Table for ADA.
!
OPERATOR_INFO_TABLE (ADA_OPINFO_TABLE,

    ! Unary arithmetic.
    !
    OPERATOR_INFO_ENTRY
    	(UNARY_PLUS, 	ADA_UNARY_PLUS_TABLE, 	ADA_HIER_TABLE, TABLEBASE),
    OPERATOR_INFO_ENTRY
    	(UNARY_MINUS, 	ADA_UNARY_MINUS_TABLE, 	ADA_HIER_TABLE, TABLEBASE),
    OPERATOR_INFO_ENTRY
    	(ABSOLUTE, 	ADA_ABSOLUTE_TABLE, 	ADA_HIER_TABLE, TABLEBASE),

    ! Binary arithmetic.
    !
    OPERATOR_INFO_ENTRY 
    	(ADD, 		ADA_ADD_TABLE, 	 	ADA_HIER_TABLE, TABLEBASE),
    OPERATOR_INFO_ENTRY
    	(SUBTRACT, 	ADA_SUBTRACT_TABLE, 	ADA_HIER_TABLE, TABLEBASE),
    OPERATOR_INFO_ENTRY
    	(MULTIPLY, 	ADA_MULTIPLY_TABLE, 	ADA_HIER_TABLE, TABLEBASE),
    OPERATOR_INFO_ENTRY
    	(DIVIDE, 	ADA_DIVIDE_TABLE, 	ADA_HIER_TABLE, TABLEBASE),
    OPERATOR_INFO_ENTRY
    	(MODULUS, 	ADA_MODULUS_TABLE, 	ADA_HIER_TABLE, TABLEBASE),
    OPERATOR_INFO_ENTRY
    	(REMAINDER, 	ADA_REMAINDER_TABLE, 	ADA_HIER_TABLE, TABLEBASE),
    OPERATOR_INFO_ENTRY
    	(POWER_OF, 	ADA_POWER_OF_TABLE, 	ADA_HIER_TABLE, TABLEBASE),

    ! Logical operations.
    !
    OPERATOR_INFO_ENTRY
    	(NOT, 		ADA_NOT_TABLE, 		ADA_HIER_TABLE, TABLEBASE),
    OPERATOR_INFO_ENTRY
    	(AND, 		ADA_AND_TABLE, 		ADA_HIER_TABLE, TABLEBASE),
    OPERATOR_INFO_ENTRY
    	(OR, 		ADA_OR_TABLE, 		ADA_HIER_TABLE, TABLEBASE),
    OPERATOR_INFO_ENTRY
    	(XOR, 		ADA_XOR_TABLE, 		ADA_HIER_TABLE, TABLEBASE),

    ! Relationals.
    !
    OPERATOR_INFO_ENTRY
    	(EQUAL, 	ADA_EQUAL_TABLE, 	ADA_HIER_TABLE, TABLEBASE),
    OPERATOR_INFO_ENTRY
    	(NOT_EQUAL, 	ADA_NOT_EQUAL_TABLE, 	ADA_HIER_TABLE, TABLEBASE),
    OPERATOR_INFO_ENTRY
    	(LSS_THAN, 	ADA_LSS_THAN_TABLE, 	ADA_HIER_TABLE, TABLEBASE),
    OPERATOR_INFO_ENTRY
    	(GTR_THAN, 	ADA_GTR_THAN_TABLE, 	ADA_HIER_TABLE, TABLEBASE),
    OPERATOR_INFO_ENTRY
    	(LSS_EQUAL, 	ADA_LSS_EQUAL_TABLE, 	ADA_HIER_TABLE, TABLEBASE),
    OPERATOR_INFO_ENTRY
    	(GTR_EQUAL, 	ADA_GTR_EQUAL_TABLE, 	ADA_HIER_TABLE, TABLEBASE),

    ! String operations.
    !
    OPERATOR_INFO_ENTRY
    	(CONCATENATE, 	ADA_CONCATENATE_TABLE, 	ADA_HIER_TABLE, TABLEBASE),

    ! Convert, Deposit, and Identity.
    !
    OPERATOR_INFO_ENTRY
    	(CONVERT, 	TABLEBASE, 		ADA_DEPOSIT_TABLE, TABLEBASE),
    OPERATOR_INFO_ENTRY
    	(DEPOSIT, 	TABLEBASE, 		ADA_DEPOSIT_TABLE, TABLEBASE),
    OPERATOR_INFO_ENTRY
    	(IDENTITY, 	TABLEBASE, 		TABLEBASE, TABLEBASE));


!
!   B A S I C   O P E R A T O R   I N F O R M A T I O N   T A B L E S
!
! This section contains the Operator Routine and Type tables needed to
! evaluate expressions in the BASIC language.
!
!
! The following summarizes the information in the BASIC manual about
! data types, type conversions, and operators. There is further documentation
! within the tables below, describing exactly how we translate this into
! the DEBUG tables.
!
! BASIC Data Types:
!	. Integer (signed only)
!	  byte (8-bit), word (16-bit), long (32-bit)
!	. Real
!	  single (f-float), double (d-float), gfloat, hfloat
!	. Packed Decimal
!	  0-16 bytes; specifies number of digits and location of decimal point
!	. String
!	  one character per byte
!	. RFA
!	  6 bytes; specifies record file address - block number and offset
!
! BASIC Constants:
!	. Any of BASIC's data types
!
! BASIC Aggregates:
!	. Array
!	. Record
!	  
! Expressions:
!	. Numeric
!	  Floating-point or integer operands separated by arithmetic operators
!	  (+, -, *, /, ^, **) and optionally grouped by parentheses.
!	  Result:  numeric (see type conversion).
!	. String
!	  Strings separated by "+" (concatenation) or by combinations of
!	  string functions.
!	  Result:  string.
!	. Relational
!	  Operands may be either numeric or string (not mixed)
!	  Operators:  =, <, >, <= (or =<), >= (or =>), <> (or ><), ==
!	  	(note:  "==" is different for string and numeric)
!	  Result:  true (-1) or false (0)
!	. Logical
!	  Operands:  integer only.
!	  Operators:  NOT, AND, OR, XOR, EQV, IMP
!	  Result:  true (-1) or false (0)
!	. Assignment, conditional
!
! Type Conversion:
!	. Arithmetic
!	  Note that, with one exception, the resulting data type is the same
!	  as that of the operand with the higher data type.  The exception is
!	  when the operands are DOUBLE and GFLOAT:  BASIC promotes both values
!	  to HFLOAT, and the result is HFLOAT.  This preserves both precision
!	  and magnitude.
!
!		      |  BYTE    WORD    LONG    SINGLE  DOUBLE  GFLOAT  HFLOAT
! 	  --------------------------------------------------------------------
!    	       BYTE   |  BYTE    WORD    LONG    SINGLE  DOUBLE  GFLOAT  HFLOAT
! 	  --------------------------------------------------------------------
!    	       WORD   |  WORD    WORD    LONG    SINGLE  DOUBLE  GFLOAT  HFLOAT
! 	  --------------------------------------------------------------------
!    	       LONG   |  LONG    LONG    LONG    SINGLE  DOUBLE  GFLOAT  HFLOAT
! 	  --------------------------------------------------------------------
!   	      SINGLE  |  SINGLE  SINGLE  SINGLE  SINGLE  DOUBLE  GFLOAT  HFLOAT
! 	  --------------------------------------------------------------------
!   	      DOUBLE  |  DOUBLE  DOUBLE  DOUBLE  DOUBLE  DOUBLE  HFLOAT  HFLOAT
! 	  --------------------------------------------------------------------
!   	      GFLOAT  |  GFLOAT  GFLOAT  GFLOAT  GFLOAT  HFLOAT  GFLOAT  HFLOAT
! 	  --------------------------------------------------------------------
!   	      HFLOAT  |  HFLOAT  HFLOAT  HFLOAT  HFLOAT  HFLOAT  HFLOAT  HFLOAT
!
!
!	. Packed Decimal Conversion
!	  1.  If both operands are Decimal with the same digit and scale
!	      values, no conversion is performed.  If the operands have
!	      different digit and scale values, BASIC always used the larger
!	      number of specified digits for the result.  The debugger uses
!	      a large enough digit and scale factor to avoid overflows if
!	      possible.
!	  2.  If one operand is Decimal and one is integer, the following
!	      integer --> decimal coversions occur (in BASIC):
!		  BYTE --> DECIMAL(3,0)
!		  WORD --> DECIMAL(5,0)
!		  LONG --> DECIMAL(10,0)
!	      The debugger converts them all to DECIMAL(31,0).
!	  3.  If one operand is Decimal(d,s) and one is floating-point, the
!	      following decimal --> floating-point conversions occur:
!		  if range of d is <=1  thru <=6  --> SINGLE
!		  if range of d is <=7  thru <=15 --> DOUBLE----|
!							GFLOAT  | <-- depends on floating-point operand
!							HFLOAT__|
!		  if range of d is  =16           --> DOUBLE
!		  if range of d is <=17 thru <=31 --> HFLOAT
!	      The debugger employs this same scheme.
!


! Define the Type Conversion Information Table for BASIC.
! There is no CVT_TABLE specifying exceptions to the DBG$CVT_DX_DX rules.
!
CONVERSION_INFO_TABLE (BASIC_CVTINFO_TABLE,
    CONVERSION_INFO_ENTRY (TABLEBASE, TABLEBASE));


! Define the Type Hierarchy Table for BASIC.
! This table is described above when we talk about conversion rules.
! Leaving out the G edges, the graph specified by this table is:
!
!	     	B -> W -> L -> F -> D -> H
!			   \
!			    P
! The case of converting packed to float is handled by the routine
! MAP_PACKED in DBGEVALOP.
!


! Define a Type Hierarachy Table for BASIC.
!
TYPE_HIERARCHY_TABLE (BASIC_HIER1_TABLE,
    TYPE_GRAPH_EDGE (B, W),
    TYPE_GRAPH_EDGE (W, L),
    TYPE_GRAPH_EDGE (L, F),
    TYPE_GRAPH_EDGE (L, P),
    TYPE_GRAPH_EDGE (F, D),
    TYPE_GRAPH_EDGE (F, G),
    TYPE_GRAPH_EDGE (D, H),
    TYPE_GRAPH_EDGE (G, H),
    0);


! Define another Type Hierarachy Table for BASIC.
! This is a subset of the HIER1 table. It is used for those operators that
! only accept integer types. It would also be OK to use the HIER1 table,
! but providing a smaller table speeds up the code.
!
TYPE_HIERARCHY_TABLE (BASIC_HIER2_TABLE,
    TYPE_GRAPH_EDGE (B, W),
    TYPE_GRAPH_EDGE (W, L),
    0);

! Define the Type Hierarchy Table for BASIC deposit.
! This is a circular table which includes all types except T.
! This means that any of the numeric types are convertible to any
! of the other numeric types on a DEPOSIT.
!
TYPE_HIERARCHY_TABLE (BASIC_HIERD_TABLE,
    TYPE_GRAPH_EDGE (B, W),
    TYPE_GRAPH_EDGE (W, L),
    TYPE_GRAPH_EDGE (L, P),
    TYPE_GRAPH_EDGE (P, F),
    TYPE_GRAPH_EDGE (F, D),
    TYPE_GRAPH_EDGE (D, G),
    TYPE_GRAPH_EDGE (G, H),
    TYPE_GRAPH_EDGE (H, B),
    0);


!++
! Most of the arithmetic routines operate on two arguments of the same type.
! That type may be B, W, L, F, D, G, H, P, so we provide all of those case
! indices.
!--

! Define the Operator Routine Table for BASIC addition.
! Note that addition of text strings is actually concatenation.
!
OPERATOR_ROUTINE_TABLE (BASIC_ADD_TABLE,
    OPERATOR_ROUTINE (B, B, B, ADD_B_B),
    OPERATOR_ROUTINE (W, W, W, ADD_W_W),
    OPERATOR_ROUTINE (L, L, L, ADD_L_L),
    OPERATOR_ROUTINE (F, F, F, ADD_F_F),
    OPERATOR_ROUTINE (D, D, D, ADD_D_D),
    OPERATOR_ROUTINE (G, G, G, ADD_G_G),
    OPERATOR_ROUTINE (H, H, H, ADD_H_H),
    OPERATOR_ROUTINE (P, P, P, ADD_P_P),
    OPERATOR_ROUTINE (T, T, T, CONCAT_T_T));


! Define the Operator Routine Table for BASIC subtraction.
!
OPERATOR_ROUTINE_TABLE (BASIC_SUB_TABLE,
    OPERATOR_ROUTINE (B, B, B, SUB_B_B),
    OPERATOR_ROUTINE (W, W, W, SUB_W_W),
    OPERATOR_ROUTINE (L, L, L, SUB_L_L),
    OPERATOR_ROUTINE (F, F, F, SUB_F_F),
    OPERATOR_ROUTINE (D, D, D, SUB_D_D),
    OPERATOR_ROUTINE (G, G, G, SUB_G_G),
    OPERATOR_ROUTINE (H, H, H, SUB_H_H),
    OPERATOR_ROUTINE (P, P, P, SUB_P_P));


! Define the Operator Routine Table for BASIC multiplication.
!
OPERATOR_ROUTINE_TABLE (BASIC_MUL_TABLE,
    OPERATOR_ROUTINE (B, B, B, MUL_B_B),
    OPERATOR_ROUTINE (W, W, W, MUL_W_W),
    OPERATOR_ROUTINE (L, L, L, MUL_L_L),
    OPERATOR_ROUTINE (F, F, F, MUL_F_F),
    OPERATOR_ROUTINE (D, D, D, MUL_D_D),
    OPERATOR_ROUTINE (G, G, G, MUL_G_G),
    OPERATOR_ROUTINE (H, H, H, MUL_H_H),
    OPERATOR_ROUTINE (P, P, P, MUL_P_P));


! Define the Operator Routine Table for BASIC division.
!
OPERATOR_ROUTINE_TABLE (BASIC_DIV_TABLE,
    OPERATOR_ROUTINE (B, B, B, DIV_B_B),
    OPERATOR_ROUTINE (W, W, W, DIV_W_W),
    OPERATOR_ROUTINE (L, L, L, DIV_L_L),
    OPERATOR_ROUTINE (F, F, F, DIV_F_F),
    OPERATOR_ROUTINE (D, D, D, DIV_D_D),
    OPERATOR_ROUTINE (G, G, G, DIV_G_G),
    OPERATOR_ROUTINE (H, H, H, DIV_H_H),
    OPERATOR_ROUTINE (P, P, P, DIV_P_P));


! Define the Operator Routine Table for BASIC unary plus.
!
OPERATOR_ROUTINE_TABLE (BASIC_UNARY_PLUS_TABLE,

! The following are not language dependent types.  This is needed for DEBUG
! types.  For example, DEP/QUAD L= +1.
!
    OPERATOR_ROUTINE (Q, Q, Q, UNARY_PLUS_Q),
    OPERATOR_ROUTINE (O, O, O, UNARY_PLUS_O),

    OPERATOR_ROUTINE (B, B, B, UNARY_PLUS_B),
    OPERATOR_ROUTINE (W, W, W, UNARY_PLUS_W),
    OPERATOR_ROUTINE (L, L, L, UNARY_PLUS_L),
    OPERATOR_ROUTINE (F, F, F, UNARY_PLUS_F),
    OPERATOR_ROUTINE (D, D, D, UNARY_PLUS_D),
    OPERATOR_ROUTINE (G, G, G, UNARY_PLUS_G),
    OPERATOR_ROUTINE (H, H, H, UNARY_PLUS_H),
    OPERATOR_ROUTINE (P, P, P, UNARY_PLUS_P));


! Define the Operator Routine Table for BASIC unary minus.
!
OPERATOR_ROUTINE_TABLE (BASIC_UNARY_MINUS_TABLE,
! The following are not language dependent types.  This is needed for DEBUG
! types.  For example, DEP/QUAD L= +1.
!
    OPERATOR_ROUTINE (Q, Q, Q, UNARY_MINUS_Q),
    OPERATOR_ROUTINE (O, O, O, UNARY_MINUS_O),

    OPERATOR_ROUTINE (B, B, B, UNARY_MINUS_B),
    OPERATOR_ROUTINE (W, W, W, UNARY_MINUS_W),
    OPERATOR_ROUTINE (L, L, L, UNARY_MINUS_L),
    OPERATOR_ROUTINE (F, F, F, UNARY_MINUS_F),
    OPERATOR_ROUTINE (D, D, D, UNARY_MINUS_D),
    OPERATOR_ROUTINE (G, G, G, UNARY_MINUS_G),
    OPERATOR_ROUTINE (H, H, H, UNARY_MINUS_H),
    OPERATOR_ROUTINE (P, P, P, UNARY_MINUS_P));


! Define the Operator Routine Table for BASIC exponentiation.
! Exponentiation has some mixed forms. For example, if you raise a
! floating number to an integer power, you do not necessarily
! want to first convert the int to float. Instead, a special
! routine indices such as  POWER_F_L are provided to do the right thing here.
!
OPERATOR_ROUTINE_TABLE (BASIC_POWER_TABLE,
    OPERATOR_ROUTINE (W, W, W, POWER_W_W),
    OPERATOR_ROUTINE (L, L, L, POWER_L_L),
    OPERATOR_ROUTINE (F, L, F, POWER_F_L),
    OPERATOR_ROUTINE (D, L, D, POWER_D_L),
    OPERATOR_ROUTINE (G, L, G, POWER_G_L),
    OPERATOR_ROUTINE (H, L, H, POWER_H_L),
    OPERATOR_ROUTINE (F, F, F, POWER_F_F),
    OPERATOR_ROUTINE (D, F, D, POWER_D_F),
    OPERATOR_ROUTINE (F, D, D, POWER_F_D),
    OPERATOR_ROUTINE (D, D, D, POWER_D_D),
    OPERATOR_ROUTINE (G, G, G, POWER_G_G),
    OPERATOR_ROUTINE (H, H, H, POWER_H_H));


! Define the Operator Routine Table for BASIC equal.
! This operator can be done on strings as well as all the numeric
! types.
!
OPERATOR_ROUTINE_TABLE (BASIC_EQL_TABLE,
    OPERATOR_ROUTINE (RFA, RFA, L, EQL_RFA_RFA),
    OPERATOR_ROUTINE (T, T, L, EQL_T_T),
    OPERATOR_ROUTINE (B, B, L, EQL_B_B),
    OPERATOR_ROUTINE (W, W, L, EQL_W_W),
    OPERATOR_ROUTINE (L, L, L, EQL_L_L),
    OPERATOR_ROUTINE (F, F, L, EQL_F_F),
    OPERATOR_ROUTINE (D, D, L, EQL_D_D),
    OPERATOR_ROUTINE (G, G, L, EQL_G_G),
    OPERATOR_ROUTINE (H, H, L, EQL_H_H),
    OPERATOR_ROUTINE (P, P, L, EQL_P_P));


! Define the Operator Routine Table for BASIC not equal.
! This operator can be done on strings as well as all the numeric types.
!
OPERATOR_ROUTINE_TABLE (BASIC_NEQ_TABLE,
    OPERATOR_ROUTINE (RFA, RFA, L, NEQ_RFA_RFA),
    OPERATOR_ROUTINE (T, T, L, NEQ_T_T),
    OPERATOR_ROUTINE (B, B, L, NEQ_B_B),
    OPERATOR_ROUTINE (W, W, L, NEQ_W_W),
    OPERATOR_ROUTINE (L, L, L, NEQ_L_L),
    OPERATOR_ROUTINE (F, F, L, NEQ_F_F),
    OPERATOR_ROUTINE (D, D, L, NEQ_D_D),
    OPERATOR_ROUTINE (G, G, L, NEQ_G_G),
    OPERATOR_ROUTINE (H, H, L, NEQ_H_H),
    OPERATOR_ROUTINE (P, P, L, NEQ_P_P));

! In the tables for the comparison operators,
! we allow strings to be compared, and also all the numeric types.
! Define the Operator Routine Table for BASIC greater than.
!
OPERATOR_ROUTINE_TABLE (BASIC_GTR_TABLE,
    OPERATOR_ROUTINE (T, T, L, GTR_T_T),
    OPERATOR_ROUTINE (B, B, L, GTR_B_B),
    OPERATOR_ROUTINE (W, W, L, GTR_W_W),
    OPERATOR_ROUTINE (L, L, L, GTR_L_L),
    OPERATOR_ROUTINE (F, F, L, GTR_F_F),
    OPERATOR_ROUTINE (D, D, L, GTR_D_D),
    OPERATOR_ROUTINE (G, G, L, GTR_G_G),
    OPERATOR_ROUTINE (H, H, L, GTR_H_H),
    OPERATOR_ROUTINE (P, P, L, GTR_P_P));


! Define the Operator Routine Table for BASIC greater than or equal to.
!
OPERATOR_ROUTINE_TABLE (BASIC_GEQ_TABLE,
    OPERATOR_ROUTINE (T, T, L, GEQ_T_T),
    OPERATOR_ROUTINE (B, B, L, GEQ_B_B),
    OPERATOR_ROUTINE (W, W, L, GEQ_W_W),
    OPERATOR_ROUTINE (L, L, L, GEQ_L_L),
    OPERATOR_ROUTINE (F, F, L, GEQ_F_F),
    OPERATOR_ROUTINE (D, D, L, GEQ_D_D),
    OPERATOR_ROUTINE (G, G, L, GEQ_G_G),
    OPERATOR_ROUTINE (H, H, L, GEQ_H_H),
    OPERATOR_ROUTINE (P, P, L, GEQ_P_P));


! Define the Operator Routine Table for BASIC less than.
!
OPERATOR_ROUTINE_TABLE (BASIC_LSS_TABLE,
    OPERATOR_ROUTINE (T, T, L, LSS_T_T),
    OPERATOR_ROUTINE (B, B, L, LSS_B_B),
    OPERATOR_ROUTINE (W, W, L, LSS_W_W),
    OPERATOR_ROUTINE (L, L, L, LSS_L_L),
    OPERATOR_ROUTINE (F, F, L, LSS_F_F),
    OPERATOR_ROUTINE (D, D, L, LSS_D_D),
    OPERATOR_ROUTINE (G, G, L, LSS_G_G),
    OPERATOR_ROUTINE (H, H, L, LSS_H_H),
    OPERATOR_ROUTINE (P, P, L, LSS_P_P));


! Define the Operator Routine Table for BASIC less than or equal to.
!
OPERATOR_ROUTINE_TABLE (BASIC_LEQ_TABLE,
    OPERATOR_ROUTINE (T, T, L, LEQ_T_T),
    OPERATOR_ROUTINE (B, B, L, LEQ_B_B),
    OPERATOR_ROUTINE (W, W, L, LEQ_W_W),
    OPERATOR_ROUTINE (L, L, L, LEQ_L_L),
    OPERATOR_ROUTINE (F, F, L, LEQ_F_F),
    OPERATOR_ROUTINE (D, D, L, LEQ_D_D),
    OPERATOR_ROUTINE (G, G, L, LEQ_G_G),
    OPERATOR_ROUTINE (H, H, L, LEQ_H_H),
    OPERATOR_ROUTINE (P, P, L, LEQ_P_P));


! The logical operators .AND., .OR., .EQV., .NEQV., .NOT. can be applied
! only to integer data types.

! Define the Operator Routine Table for BASIC not.
!
OPERATOR_ROUTINE_TABLE (BASIC_BIT_NOT_TABLE,
    OPERATOR_ROUTINE (B, B, B, BIT_NOT_B),
    OPERATOR_ROUTINE (W, W, W, BIT_NOT_W),
    OPERATOR_ROUTINE (L, L, L, BIT_NOT_L));


! Define the Operator Routine Table for BASIC and.
!
OPERATOR_ROUTINE_TABLE (BASIC_BIT_AND_TABLE,
    OPERATOR_ROUTINE (B, B, B, BIT_AND_B_B),
    OPERATOR_ROUTINE (W, W, W, BIT_AND_W_W),
    OPERATOR_ROUTINE (L, L, L, BIT_AND_L_L));


! Define the Operator Routine Table for BASIC or.
!
OPERATOR_ROUTINE_TABLE (BASIC_BIT_OR_TABLE,
    OPERATOR_ROUTINE (B, B, B, BIT_OR_B_B),
    OPERATOR_ROUTINE (W, W, W, BIT_OR_W_W),
    OPERATOR_ROUTINE (L, L, L, BIT_OR_L_L));


! Define the Operator Routine Table for BASIC xor, neqv
!
OPERATOR_ROUTINE_TABLE (BASIC_BIT_XOR_TABLE,
    OPERATOR_ROUTINE (B, B, B, BIT_XOR_B_B),
    OPERATOR_ROUTINE (W, W, W, BIT_XOR_W_W),
    OPERATOR_ROUTINE (L, L, L, BIT_XOR_L_L));


! Define the Operator Routine Table for BASIC eqv.
!
OPERATOR_ROUTINE_TABLE (BASIC_BIT_EQV_TABLE,
    OPERATOR_ROUTINE (B, B, B, BIT_EQV_B_B),
    OPERATOR_ROUTINE (W, W, W, BIT_EQV_W_W),
    OPERATOR_ROUTINE (L, L, L, BIT_EQV_L_L));


! Define the Operator Routine Table for BASIC imp.
!
OPERATOR_ROUTINE_TABLE (BASIC_BIT_IMP_TABLE,
    OPERATOR_ROUTINE (B, B, B, BIT_IMP_B_B),
    OPERATOR_ROUTINE (W, W, W, BIT_IMP_W_W),
    OPERATOR_ROUTINE (L, L, L, BIT_IMP_L_L));


! Define the Operator Information Table for BASIC.
!
OPERATOR_INFO_TABLE (BASIC_OPINFO_TABLE,

    ! The following are arithmetic tables that accept all numeric data types,
    ! including complex. They thus go through the larger HIER1 table, and
    ! need to specify an incompatibility table.
    !
    OPERATOR_INFO_ENTRY (ADD, BASIC_ADD_TABLE, BASIC_HIER1_TABLE, 
    	TABLEBASE),
    OPERATOR_INFO_ENTRY (SUBTRACT, BASIC_SUB_TABLE, BASIC_HIER1_TABLE, 
    	TABLEBASE),
    OPERATOR_INFO_ENTRY (MULTIPLY, BASIC_MUL_TABLE, BASIC_HIER1_TABLE, 
    	TABLEBASE),
    OPERATOR_INFO_ENTRY (DIVIDE, BASIC_DIV_TABLE, BASIC_HIER1_TABLE, 
    	TABLEBASE),
    OPERATOR_INFO_ENTRY (UNARY_PLUS, BASIC_UNARY_PLUS_TABLE, 
    	BASIC_HIER1_TABLE, TABLEBASE),
    OPERATOR_INFO_ENTRY (UNARY_MINUS, BASIC_UNARY_MINUS_TABLE, 
    	BASIC_HIER1_TABLE, TABLEBASE),
    OPERATOR_INFO_ENTRY (POWER_OF, BASIC_POWER_TABLE, BASIC_HIER1_TABLE, 
    	TABLEBASE),

    ! The relationals accept all numeric types and thus need the larger
    ! hierarchy table.  There is no incompatibility table.
    !
    OPERATOR_INFO_ENTRY (EQUAL, BASIC_EQL_TABLE, BASIC_HIER1_TABLE, 
    	TABLEBASE),
    OPERATOR_INFO_ENTRY (NOT_EQUAL, BASIC_NEQ_TABLE, BASIC_HIER1_TABLE, 
    	TABLEBASE),
    OPERATOR_INFO_ENTRY (GTR_THAN, BASIC_GTR_TABLE, BASIC_HIER1_TABLE, 
    	TABLEBASE),
    OPERATOR_INFO_ENTRY (GTR_EQUAL, BASIC_GEQ_TABLE, BASIC_HIER1_TABLE, 
    	TABLEBASE),
    OPERATOR_INFO_ENTRY (LSS_THAN, BASIC_LSS_TABLE, BASIC_HIER1_TABLE, 
    	TABLEBASE),
    OPERATOR_INFO_ENTRY (LSS_EQUAL, BASIC_LEQ_TABLE, BASIC_HIER1_TABLE, 
    	TABLEBASE),

    ! The logical operators accept only integer quantities so they can
    ! use the smallest hierarchy table. They also do not need an
    ! incompatibility table.
    !
    OPERATOR_INFO_ENTRY (BIT_NOT, BASIC_BIT_NOT_TABLE, BASIC_HIER2_TABLE, 
    	TABLEBASE),
    OPERATOR_INFO_ENTRY (BIT_AND, BASIC_BIT_AND_TABLE, BASIC_HIER2_TABLE, 
    	TABLEBASE),
    OPERATOR_INFO_ENTRY (BIT_OR, BASIC_BIT_OR_TABLE, BASIC_HIER2_TABLE, 
    	TABLEBASE),
    OPERATOR_INFO_ENTRY (BIT_XOR, BASIC_BIT_XOR_TABLE, BASIC_HIER2_TABLE, 
    	TABLEBASE),
    OPERATOR_INFO_ENTRY (BIT_EQV, BASIC_BIT_EQV_TABLE, BASIC_HIER2_TABLE, 
    	TABLEBASE),
    OPERATOR_INFO_ENTRY (BIT_IMP, BASIC_BIT_IMP_TABLE, BASIC_HIER2_TABLE, 
    	TABLEBASE),

    ! The CONVERT operator gets called to convert subscripts to integer
    ! type and to convert expressions in FOR, IF, WHILE, REPEAT statements
    ! to integer type. It can thus use the smaller HIER2 table to specify
    ! the rules for conversion to integer.
    !
    OPERATOR_INFO_ENTRY (CONVERT, TABLEBASE, BASIC_HIER2_TABLE,
    	TABLEBASE),

    ! The DEPOSIT operator gets called on the DEPOSIT command. It has
    ! its own hierarchy table which allows any numeric type to be 
    ! converted to any other numeric type. The incompatibility table,
    ! however, still prevents depositing D types into G types and
    ! vice versa.
    !
    OPERATOR_INFO_ENTRY (DEPOSIT, TABLEBASE, BASIC_HIERD_TABLE, 
    	TABLEBASE),


    ! The IDENTITY operator gets called at the end of an EVALUATE command
    ! to apply the PRIM_TO_VAL routine and then apply the appropriate
    ! type mappings. This will ensure that EV BU will print as a signed integer,
    ! for example.
    ! 
    ! The identity operator does not require any tables.
    !
    OPERATOR_INFO_ENTRY (IDENTITY, TABLEBASE, TABLEBASE, TABLEBASE)
    );


!
! 	B L I S S   O P E R A T O R   I N F O R M A T I O N   T A B L E S
!
!
! This section contains the Operator Routine and Type tables needed to
! evaluate expressions in BLISS.
!


! Here is the list of types that we may get back from DBG$PRIM_TO_VAL
! when we pass it a BLISS primary:
!
!	B	- byte signed
!	BU	- byte unsigned
!	W	- word signed
!	WU	- word unsigned
!	L	- longword signed
!	LU	- longword unsigned
!	V	- aligned bitstring. e.g., the primary X<0,5,0>
!	SV	- signed aligned bitstring. e.g., X<0,5,1>
!	VU	- unaligned bitstring. e.g., 	X<1,5,0>
!	SVU	- signed unaligned bitstring, e.g., X<1,5,1>
!	PTR	- we get this back for REF items
!	Z	- "unknown" - we get this back for BLISS field names
!		   e.g., X[fieldname]. No operations are allowed on
!		   fieldnames so this type does not appear in the
!		   tables.
!	ZI	- instruction, %LINE 10
!	ZEM	- entry mask, e.g., EV ROUT_NAME
!
! DBG$PRIM_TO_ADDR always returns type L.


! Define a table that maps PTR type into integer. Type PTR can come
! back from REF objects.
!
TYPE_MAPPING_TABLE (BLISS_MAP_TABLE,
    TYPE_GRAPH_EDGE (PTR,L));

! Define the Type Conversion Information Table for BLISS.
! This points to the above mapping table.
!
CONVERSION_INFO_TABLE (BLISS_CVTINFO_TABLE,
    CONVERSION_INFO_ENTRY (BLISS_MAP_TABLE, TABLEBASE));


! Define the Type Hierarchy Table. All operations are done on signed longwords.
! Thus we provide a path for all types to be converted to signed longwords.
!
TYPE_HIERARCHY_TABLE (BLISS_HIER_TABLE,
    TYPE_GRAPH_EDGE (BU, WU),
    TYPE_GRAPH_EDGE (WU, LU),
    TYPE_GRAPH_EDGE (LU,  L),
    TYPE_GRAPH_EDGE (B ,  W),
    TYPE_GRAPH_EDGE (W ,  L),
    0);


! Define the Type Hierarchy Table for DEPOSIT.
! This is a circular graph which includes all types that can be obtained
! from calling PRIM_TO_VAL on a BLISS primary. What this means is that
! any type is convertible to any other type on a DEPOSIT.
!
TYPE_HIERARCHY_TABLE (BLISS_HIERD_TABLE,
    TYPE_GRAPH_EDGE (B, BU),
    TYPE_GRAPH_EDGE (BU, W),
    TYPE_GRAPH_EDGE (W, WU),
    TYPE_GRAPH_EDGE (WU, L),
    TYPE_GRAPH_EDGE (L, LU),
    TYPE_GRAPH_EDGE (LU, VU),
    TYPE_GRAPH_EDGE (VU, SVU),
    TYPE_GRAPH_EDGE (SVU, SV),
    TYPE_GRAPH_EDGE (SV, V),
    TYPE_GRAPH_EDGE (V, B),
    0);

!++
! All of the arithmetic operations below are defined to work on signed
! longwords. 
!
! Note that only the fetch operator (.) does an implicit fetch for BLISS.
! This means, for example, that
!	EVAL A+B
! will add the addresses of A and B, not the values. Addresses are obtained
! from the DBG$PRIM_TO_ADDR, and their type is always L.
!
! If the fetch is done, the DBG$PRIM_TO_VAL routine gets called, and the value
! is pulled from that value descriptor and put into the result value
! descriptor, which is of type longword. Thus the result of the fetch
! operator is always longword. Any extraction of byte, word, bitfield, etc.
! values is done inside of DBG$PRIM_TO_VAL.
!
! For example,
!	EVAL .W + .BU  ! W is word signed, BU is byte unsigned
! The .W operator is first applied. DBG$PRIM_TO_VAL is called and it
! extracts the word quantity for W, sign extends it to a longword,
! and places the longword value in the Value Descriptor. We copy that
! value into the Value Descriptor containing the result of the .W operation.
! Similarly we obtain a type L descriptor with the value of BU, properly
! zero-extended. These are then added as longwords, and the result is 
! a longword.
!
! So the upshot of all this is that none of the operations except FETCH
! ever see anything except dtype L.
!--

! Define the Operator Routine Table for BLISS addition.
!
OPERATOR_ROUTINE_TABLE (BLISS_ADD_TABLE,
    OPERATOR_ROUTINE (L, L, L, ADD_L_L));

! Define the Operator Routine Table for BLISS subtraction.
!
OPERATOR_ROUTINE_TABLE (BLISS_SUB_TABLE,
    OPERATOR_ROUTINE (L, L, L, SUB_L_L));

! Define the Operator Routine Table for BLISS Multiplication.
!
OPERATOR_ROUTINE_TABLE (BLISS_MUL_TABLE,
    OPERATOR_ROUTINE (L, L, L, MUL_L_L));

! Define the Operator Routine Table for BLISS Division.
!
OPERATOR_ROUTINE_TABLE (BLISS_DIV_TABLE,
    OPERATOR_ROUTINE (L, L, L, DIV_L_L));

! Define the Operator Routine Table for BLISS Modulus.
! The BLISS modulus function is actually a remainder function.
!
OPERATOR_ROUTINE_TABLE (BLISS_MOD_TABLE,
    OPERATOR_ROUTINE (L, L, L, REM_L_L));

! Define the Operator Routine Table for BLISS arithmetic shift.
! There is only one shift operation in BLISS. It uses the "^" symbol.
! A positive right argument indicates left shift and a negative right
! argument indicates right shift. This is how the SHIFT_LEFT_L_L routine
! behaves.
!
OPERATOR_ROUTINE_TABLE (BLISS_SHIFT_TABLE,
    OPERATOR_ROUTINE (L, L, L, SHIFT_LEFT_L_L));

! Define the Operator Routine Table for BLISS Equal.
!
OPERATOR_ROUTINE_TABLE (BLISS_EQUAL_TABLE,
    OPERATOR_ROUTINE (L, L, L, EQL_L_L));

! Define the Operator Routine Table for BLISS Not Equal.
!
OPERATOR_ROUTINE_TABLE (BLISS_NOT_EQUAL_TABLE,
    OPERATOR_ROUTINE (L, L, L, NEQ_L_L));

! Define the Operator Routine Table for BLISS Less Than.
!
OPERATOR_ROUTINE_TABLE (BLISS_LSS_THAN_TABLE,
    OPERATOR_ROUTINE (L, L, L, LSS_L_L));

! Define the Operator Routine Table for BLISS Less Than Unsigned.
!
OPERATOR_ROUTINE_TABLE (BLISS_LSSU_THAN_TABLE,
    OPERATOR_ROUTINE (L, L, L, LSS_LU_LU));

! Define the Operator Routine Table for BLISS Greater Than.
!
OPERATOR_ROUTINE_TABLE (BLISS_GTR_THAN_TABLE,
    OPERATOR_ROUTINE (L, L, L, GTR_L_L));

! Define the Operator Routine Table for BLISS Greater Than Unsigned.
!
OPERATOR_ROUTINE_TABLE (BLISS_GTRU_THAN_TABLE,
    OPERATOR_ROUTINE (L, L, L, GTR_LU_LU));

! Define the Operator Routine Table for BLISS Less Than or Equal.
!
OPERATOR_ROUTINE_TABLE (BLISS_LSS_EQUAL_TABLE,
    OPERATOR_ROUTINE (L, L, L, LEQ_L_L));

! Define the Operator Routine Table for BLISS Less Than or Equal Unsigned.
!
OPERATOR_ROUTINE_TABLE (BLISS_LSSU_EQUAL_TABLE,
    OPERATOR_ROUTINE (L, L, L, LEQ_LU_LU));

! Define the Operator Routine Table for BLISS Greater Than or Equal.
!
OPERATOR_ROUTINE_TABLE (BLISS_GTR_EQUAL_TABLE,
    OPERATOR_ROUTINE (L, L, L, GEQ_L_L));

! Define the Operator Routine Table for BLISS Greater Than or Equal Unsigned.
!
OPERATOR_ROUTINE_TABLE (BLISS_GTRU_EQUAL_TABLE,
    OPERATOR_ROUTINE (L, L, L, GEQ_LU_LU));

! Define the Operator Routine Table for BLISS Bitwise And.
!
OPERATOR_ROUTINE_TABLE (BLISS_BIT_AND_TABLE,
    OPERATOR_ROUTINE (L, L, L, BIT_AND_L_L));

! Define the Operator Routine Table for BLISS Bitwise Or.
!
OPERATOR_ROUTINE_TABLE (BLISS_BIT_OR_TABLE,
    OPERATOR_ROUTINE (L, L, L, BIT_OR_L_L));

! Define the Operator Routine Table for BLISS Bitwise Xor.
!
OPERATOR_ROUTINE_TABLE (BLISS_BIT_XOR_TABLE,
    OPERATOR_ROUTINE (L, L, L, BIT_XOR_L_L));

! Define the Operator Routine Table for BLISS Bitwise Eqv.
!
OPERATOR_ROUTINE_TABLE (BLISS_BIT_EQV_TABLE,
    OPERATOR_ROUTINE (L, L, L, BIT_EQV_L_L));

! Define the Operator Routine Table for BLISS Unary Plus.
!
OPERATOR_ROUTINE_TABLE (BLISS_UNARY_PLUS_TABLE,

! The following are not language dependent types.  This is needed for DEBUG
! types.  For example, DEP/QUAD L= +1.
!
    OPERATOR_ROUTINE (B, B, B, UNARY_PLUS_B),
    OPERATOR_ROUTINE (W, W, W, UNARY_PLUS_W),
    OPERATOR_ROUTINE (F, F, F, UNARY_PLUS_F),
    OPERATOR_ROUTINE (D, D, D, UNARY_PLUS_D),
    OPERATOR_ROUTINE (G, G, G, UNARY_PLUS_G),
    OPERATOR_ROUTINE (H, H, H, UNARY_PLUS_H),
    OPERATOR_ROUTINE (P, P, P, UNARY_PLUS_P),
    OPERATOR_ROUTINE (Q, Q, Q, UNARY_PLUS_Q),
    OPERATOR_ROUTINE (O, O, O, UNARY_PLUS_O),

    OPERATOR_ROUTINE (L, L, L, UNARY_PLUS_L));

! Define the Operator Routine Table for BLISS Unary Minus.
!
OPERATOR_ROUTINE_TABLE (BLISS_UNARY_MINUS_TABLE,

! The following are not language dependent types.  This is needed for DEBUG
! types.  For example, DEP/QUAD L= +1.
!
    OPERATOR_ROUTINE (B, B, B, UNARY_MINUS_B),
    OPERATOR_ROUTINE (W, W, W, UNARY_MINUS_W),
    OPERATOR_ROUTINE (F, F, F, UNARY_MINUS_F),
    OPERATOR_ROUTINE (D, D, D, UNARY_MINUS_D),
    OPERATOR_ROUTINE (G, G, G, UNARY_MINUS_G),
    OPERATOR_ROUTINE (H, H, H, UNARY_MINUS_H),
    OPERATOR_ROUTINE (P, P, P, UNARY_MINUS_P),
    OPERATOR_ROUTINE (Q, Q, Q, UNARY_MINUS_Q),
    OPERATOR_ROUTINE (O, O, O, UNARY_MINUS_O),

    OPERATOR_ROUTINE (L, L, L, UNARY_MINUS_L));

! Define the Operator Routine Table for BLISS Bitwise Not.
!
OPERATOR_ROUTINE_TABLE (BLISS_BIT_NOT_TABLE,
    OPERATOR_ROUTINE (L, L, L, BIT_NOT_L));

! Define the Operator Routine Table for BLISS bit selection.
! The bit-select operator X<p,s,e> can be applied to any
! BLISS expression. It goes through the DBG$BLISS_BITSELECT
! routine in DBGEVALOP.
!
! The <p,s,e> operation can be viewed as just modifying the
! address given by X. That is, X can be any BLISS expression,
! and the result of all BLISS expressions is a longword.
! If the X<p,s,e> expression does not have a fetch associated with
! it, the value of X<p,s,e> is just X+p/8
!
! If there is a fetch, then what happens is:
! (1) The <p,s,e> operator is done first. The DBG$BLISS_BITSELECT routine just
!     squirels away the information inside of DBGEVALOP.
!     Nothing is done with it until the fetch.
! (2) the extraction of the BLISS field is
!     done at the evaluation of the fetch operator. (DBG$BLISS_INDIRECTION 
!     in the DBGEVALOP module.)
!
OPERATOR_ROUTINE_TABLE (BLISS_BITSELECT_TABLE,
    OPERATOR_ROUTINE (L, L, L, BITSELECT));

! Define the Operator Routine Table for BLISS indirection.
! Indirection is the only operator that call DBG$PRIM_TO_VAL to do
! the implicit fetch, so it is the only one that may see all the possible
! dtypes that we may get back from a BLISS primary. We thus include
! those dtypes where it is legal to do a fetch.(E.g., .ROUT-NAME is not
! legal, so that is not here).
!
OPERATOR_ROUTINE_TABLE (BLISS_INDIRECT_TABLE,
    OPERATOR_ROUTINE (B, B, L, INDIRECT_LU),
    OPERATOR_ROUTINE (W, W, L, INDIRECT_LU),
    OPERATOR_ROUTINE (BU, BU, L, INDIRECT_LU),
    OPERATOR_ROUTINE (WU, WU, L, INDIRECT_LU),
    OPERATOR_ROUTINE (LU, LU, L, INDIRECT_LU),
    OPERATOR_ROUTINE (V, V, L, INDIRECT_LU),
    OPERATOR_ROUTINE (VU, VU, L, INDIRECT_LU),
    OPERATOR_ROUTINE (SV, SV, L, INDIRECT_LU),
    OPERATOR_ROUTINE (SVU, SVU, L, INDIRECT_LU),
    OPERATOR_ROUTINE (L, L, L, INDIRECT_LU));


! Define the Operator Information Table for BLISS.
!
OPERATOR_INFO_TABLE (BLISS_OPINFO_TABLE,

    ! All of the arithmetic operators use the same hierarchy table, 
    ! BLISS_HIER_TABLE. They all have the fetch flag turned off, meaning
    ! they do address arithmetic in the absence of an explicit fetch.
    ! There is not incompatibility table for any of the BLISS operators.
    !
    OPERATOR_INFO_ENTRY
    	(UNARY_PLUS, BLISS_UNARY_PLUS_TABLE, BLISS_HIER_TABLE, TABLEBASE, FALSE),
    OPERATOR_INFO_ENTRY 
    	(UNARY_MINUS, BLISS_UNARY_MINUS_TABLE, BLISS_HIER_TABLE, TABLEBASE, FALSE),
    OPERATOR_INFO_ENTRY 
    	(BIT_NOT, BLISS_BIT_NOT_TABLE, BLISS_HIER_TABLE, TABLEBASE, FALSE),
    OPERATOR_INFO_ENTRY 
    	(ADD, BLISS_ADD_TABLE, BLISS_HIER_TABLE, TABLEBASE, FALSE),
    OPERATOR_INFO_ENTRY 
    	(SUBTRACT, BLISS_SUB_TABLE, BLISS_HIER_TABLE, TABLEBASE, FALSE),
    OPERATOR_INFO_ENTRY 
    	(MULTIPLY, BLISS_MUL_TABLE, BLISS_HIER_TABLE, TABLEBASE, FALSE),
    OPERATOR_INFO_ENTRY 
    	(DIVIDE, BLISS_DIV_TABLE, BLISS_HIER_TABLE, TABLEBASE, FALSE),
    OPERATOR_INFO_ENTRY 
    	(REMAINDER, BLISS_MOD_TABLE, BLISS_HIER_TABLE, TABLEBASE, FALSE),
    OPERATOR_INFO_ENTRY
    	(LEFT_SHIFT, BLISS_SHIFT_TABLE, BLISS_HIER_TABLE, TABLEBASE, FALSE),
    OPERATOR_INFO_ENTRY 
    	(EQUAL, BLISS_EQUAL_TABLE, BLISS_HIER_TABLE, TABLEBASE, FALSE),
    OPERATOR_INFO_ENTRY 
    	(NOT_EQUAL, BLISS_NOT_EQUAL_TABLE, BLISS_HIER_TABLE, TABLEBASE, FALSE),
    OPERATOR_INFO_ENTRY 
    	(GTR_THAN, BLISS_GTR_THAN_TABLE, BLISS_HIER_TABLE, TABLEBASE, FALSE),
    OPERATOR_INFO_ENTRY
    	(GTR_THAN_U, BLISS_GTRU_THAN_TABLE, BLISS_HIER_TABLE, TABLEBASE, FALSE),
    OPERATOR_INFO_ENTRY 
    	(LSS_THAN, BLISS_LSS_THAN_TABLE, BLISS_HIER_TABLE, TABLEBASE, FALSE),
    OPERATOR_INFO_ENTRY
    	(LSS_THAN_U, BLISS_LSSU_THAN_TABLE, BLISS_HIER_TABLE, TABLEBASE, FALSE),
    OPERATOR_INFO_ENTRY 
    	(GTR_EQUAL, BLISS_GTR_EQUAL_TABLE, BLISS_HIER_TABLE, TABLEBASE, FALSE),
    OPERATOR_INFO_ENTRY
    	(GTR_EQUAL_U, BLISS_GTRU_EQUAL_TABLE, BLISS_HIER_TABLE, TABLEBASE, FALSE),   
    OPERATOR_INFO_ENTRY 
    	(LSS_EQUAL, BLISS_LSS_EQUAL_TABLE, BLISS_HIER_TABLE, TABLEBASE, FALSE),
    OPERATOR_INFO_ENTRY
    	(LSS_EQUAL_U, BLISS_LSSU_EQUAL_TABLE, BLISS_HIER_TABLE, TABLEBASE, FALSE),
    OPERATOR_INFO_ENTRY 
    	(BIT_AND, BLISS_BIT_AND_TABLE, BLISS_HIER_TABLE, TABLEBASE, FALSE),
    OPERATOR_INFO_ENTRY 
    	(BIT_OR, BLISS_BIT_OR_TABLE, BLISS_HIER_TABLE, TABLEBASE, FALSE),
    OPERATOR_INFO_ENTRY 
    	(BIT_XOR, BLISS_BIT_XOR_TABLE, BLISS_HIER_TABLE, TABLEBASE, FALSE),
    OPERATOR_INFO_ENTRY 
    	(BIT_EQV, BLISS_BIT_EQV_TABLE, BLISS_HIER_TABLE, TABLEBASE, FALSE),
    OPERATOR_INFO_ENTRY
    	(BITSELECT, BLISS_BITSELECT_TABLE, BLISS_HIER_TABLE, TABLEBASE, FALSE),

    ! CONVERT gets called to convert subscripts to integer type.
    ! It also gets called to convert expressions in FOR loops or
    ! REPEAT counts, or expressions in WHILE or IF statements, to
    ! integer type. As far as I know, conversion to type L is the
    ! only conversion we see for BLISS. The normal hierarchy table
    ! should thus be adequate.
    !
    OPERATOR_INFO_ENTRY
    	(CONVERT, TABLEBASE, BLISS_HIER_TABLE, TABLEBASE, FALSE),

    ! The fetch operator is the one that has the fetch flag set to TRUE.
    !
    OPERATOR_INFO_ENTRY
    	(INDIRECT, BLISS_INDIRECT_TABLE, BLISS_HIER_TABLE, TABLEBASE, TRUE),

    ! DEPOSIT uses its own hierarchy table, allowing DEPOSIT of any type
    ! into any type. The fetch_flag is still false, indicating that
    ! no implicit fetch is done on the right-hand-side of the deposit.
    ! E.g., DEP X = Y  will put the address of Y into X; DEP X = .Y
    ! will put the value of Y into X.
    !
    OPERATOR_INFO_ENTRY
    	(DEPOSIT, TABLEBASE, BLISS_HIERD_TABLE, TABLEBASE, FALSE),

    ! The identity operator is called at the end of an evaluate if
    ! we still have a primary, e.g., EVAL X  will call DBG$EVAL_LANG_OPERATOR
    ! with "IDENTITY" and we can then do our thing. In the BLISS case,
    ! "doing our thing" means calling DBG$PRIM_TO_ADDR, and returning
    ! that descriptor.
    !
    ! The reason for an "identity" operator is to ensure that EVAL A
    ! will go through the same code paths as, say, EVAL A+0 or EVAL +A
    !
    ! The identity operator uses no tables.
    !
    OPERATOR_INFO_ENTRY
    	(IDENTITY, TABLEBASE, TABLEBASE, TABLEBASE, FALSE)
    );


!
! 	C   O P E R A T O R   I N F O R M A T I O N   T A B L E S
!
!
! This section contains the Operator Routine and Type tables needed to
! evaluate expressions in the C language.
!
! C constants:
!	Integer: decimal, octal, hexdecimal.  Double, String
!
! C Data Types:
!	. Integer (signed, unsigned)
!	  char ( 8-bit byte), short (16-bit integer), int (32-bit integer)
!	. Floating-point numbers
!	  float (f_float), double (D_float)
!	. Enum values
!	  Scalars of a user-defined type
!	. Pointers (typed)
!	  32-bit addresses of other variables
!
! C aggregates:
!	. Array
!	. Structure
!	. Union
!
! Expressions:
!	. Primary
!
!	. Negating Arithmetic (-E, TC applied)
!	  E: an E of any arithmetic type.
!	  Result: the arithmetic negative of the expression.  (The negative of
!	  an unsigned quantity is computed by subtracting its value from 2**32)
!
!	. Negating Logical (!E, TC applied)
!	  E: pointer (or other address-valued E, array), or an E of any 
!	  arithmetic type.  Result: the logical negative of the expression, 
!	  result type is int.
!
!	. Incrementing and Decrementing Variables (--, ++)
!
!	. Computing address (&lvalue)
!	  Result: the address of the object to which the lvalue refers.
!	  (The & may not be applied to register or to bit fields in structure
!	   or union).
!
!	. Dereferencing Pointers (*E)
!	  E: Pointer or other address-valued E.
!	  Result: a reference to the object to which the expression points,
!	  the type of the addressed object is the type of the result.
!
!	. One's complement (~E, TC applied)
!	  E: integer or character
!	
!	. Additive - (+, -, TC applied)
!	  1. Operand: Address of an array element and a value of any integral
!	     type can be added (integer is converted to an address offset by
!	     by integer * length of the addressed object).  Result: the address
!	     of an object of the same type.
!	  2. Operand: A value of any integral type may be subtracted from a 
!	     pointer or address.
!	  3. Operand: enum + enum, or enum - enum.  Result: int
!	  4. If two addresses of objects of the same type are substracted,
!	     the result is int.
!
!	. Multiplicative - (*, /, %: mod, TC applied)
!	  Operand: integral mod integral.
!
!	. Equality - (==, !=, TC applied)  Result: type int.
!	  1. Two pointers or addresses (if they identify the same storage
!	     location then they are equal).
!	  2. A pointer or address can be compared with an integer.
!
!	. Relational - (<, >, <=, >=, TC applied)  Result: type int.
!	  same as above.
!
!	. Bitwise - (&: and, ^: xor, |:or, TC applied)
!	  Operand: both must be integrals.
!
!	. Logical - (&&: and, ||: or)  Result: type int.
!	  Operand: fundamentatal types or a pointer, or address-valued E.
!
!	. Shift - (<<, >>, TC applied)
!	  Operand: both must be inegral.  the right-hand operand --> int, and
!	  the type of the result is the type of the left operand.
!	  E1 << E2: the value of E1 shifted to the left by E2 bits, vacated
!	            bits are cleard.
!	  E1 >> E2: the value of E1 shifted to the right by E2 bits.  Vacated
!	            bits are cleared if E1 is unsigned, else, vacated bits 
!	            are filled with a copy of E1's sign bit.
!	  (The result of the shift is undefined if E2 is negative, or the
!	   value of E2 > 32 bits)
!
!	. Assignment, conditional, and comma (we do not support)
!
! Type Conversion: (operands of different types appear in an expression)
!	. Arithmetic
!	  1. char or short (signed or unsigned) --> int (signed, or unsigned)
!	     f_float --> d_float.  Char is treated as signed.
!	  2. If either operand is double, the other --> double.  Result: double.
!	  3. If either operand is unsigned, the other --> unsigned.  Result: unsigned.
!	  4. Otherwise, both operands must be int.  Result: integer.
!	  5. Whenever an unsigned integer and a signed integer are combined,
!	     signed --> signed int --> unsigned.  Result: unsigned.
!	  6. For some operators require integers as operands, f or d --> int.
!


! Define the Type Conversion Information Table for C.
! C has no special rules for type conversions, so we do not have a language
! specific type conversion table.
!
CONVERSION_INFO_TABLE (C_CVTINFO_TABLE,
    CONVERSION_INFO_ENTRY (TABLEBASE, TABLEBASE));


! Define the Type Hierarchy Table for C.
! This table defines what is refered to as the "usual type conversion rules"
! in the C manual. These rules state, basically, that:
!
! char -> longword integer
! short integer -> longword integer (with the same sign attribute)
! signed integer -> unsigned
! integer -> float
! float -> double float
!
! The first edge, T->B, is there so that variables declared as CHAR can
! be treated as integers, as C allows. The conversion should check that
! the length of the char string is 1.
!
! We also include an edge for ENUM->L. This will allow any arithmetic with
! enumeration types that is also allowed for integers. This may be a more
! permissive implementation than the language allows.
!
! We also include V -> LU, VU -> LU, SV -> L, and SVU -> L.
! C declares components of a packed record to be of type V, VU, SV, or SVU,
! but operations on these are just integer operations. So we convert
! these to integer.
!
TYPE_HIERARCHY_TABLE (C_HIER_TABLE,
    TYPE_GRAPH_EDGE (T, B),

    TYPE_GRAPH_EDGE (ENUM, L),

    TYPE_GRAPH_EDGE (V,  LU),
    TYPE_GRAPH_EDGE (VU, LU),
    TYPE_GRAPH_EDGE (SV, L),
    TYPE_GRAPH_EDGE (SVU, L),

    TYPE_GRAPH_EDGE (B , W),
    TYPE_GRAPH_EDGE (W , L),
    TYPE_GRAPH_EDGE (BU, WU),
    TYPE_GRAPH_EDGE (WU, LU),
    TYPE_GRAPH_EDGE (L, LU),
    TYPE_GRAPH_EDGE (L , D),
    TYPE_GRAPH_EDGE (LU, D),
    TYPE_GRAPH_EDGE (F , D),
    0);


! The HIERD table defines what pairs are legal in a DEPOSIT.
! Give a circular graph which allows DEPOSIT any-any.
!
TYPE_HIERARCHY_TABLE (C_HIERD_TABLE,
    TYPE_GRAPH_EDGE (T, B),
    TYPE_GRAPH_EDGE (B , BU),
    TYPE_GRAPH_EDGE (BU, W),
    TYPE_GRAPH_EDGE (W , WU),
    TYPE_GRAPH_EDGE (WU, LU),
    TYPE_GRAPH_EDGE (LU, L),
    TYPE_GRAPH_EDGE (L, F),
    TYPE_GRAPH_EDGE (F , D),
    TYPE_GRAPH_EDGE (D, ENUM),
    TYPE_GRAPH_EDGE (ENUM, TPTR),
    TYPE_GRAPH_EDGE (TPTR, V),
    TYPE_GRAPH_EDGE (V, SV),
    TYPE_GRAPH_EDGE (SV, VU),
    TYPE_GRAPH_EDGE (VU, SVU),
    TYPE_GRAPH_EDGE (SVU, T),
    0);


! Add, subtract, multiply, divide, unary minus
! These accept all numeric types.

! Define the Operator Routine Table for C Addition.
! Add also has special cases for TPTR + L, which is a special kind
! of addition in which the integer is scaled to the size of the
! pointed-to object.
!
OPERATOR_ROUTINE_TABLE (C_ADD_TABLE,
    OPERATOR_ROUTINE (L, L, L, ADD_L_L),
    OPERATOR_ROUTINE (LU, LU, LU, ADD_LU_LU),
    OPERATOR_ROUTINE (D, D, D, ADD_D_D),
    OPERATOR_ROUTINE (TPTR, LU, TPTR, ADD_TPTR_L),
    OPERATOR_ROUTINE (LU, TPTR, TPTR, ADD_TPTR_L));


! Define the Operator Routine Table for C Subtraction.
! There is a special case routine for TPTR - L, which is a  special kind
! of subtraction in which the integer is scaled to the size of the
! pointed-to object. Also, TPTR-TPTR is another special case in which
! the result is scaled.
!
OPERATOR_ROUTINE_TABLE (C_SUB_TABLE,
    OPERATOR_ROUTINE (L, L, L, SUB_L_L),
    OPERATOR_ROUTINE (LU, LU, LU, SUB_LU_LU),
    OPERATOR_ROUTINE (D, D, D, SUB_D_D),
    OPERATOR_ROUTINE (TPTR, LU, TPTR, SUB_TPTR_L),
    OPERATOR_ROUTINE (TPTR, TPTR, L, SUB_TPTR_TPTR));


! Define the Operator Routine Table for C Multiplication.
!
OPERATOR_ROUTINE_TABLE (C_MUL_TABLE,
    OPERATOR_ROUTINE (L, L, L, MUL_L_L),
    OPERATOR_ROUTINE (LU, LU, LU, MUL_LU_LU),
    OPERATOR_ROUTINE (D, D, D, MUL_D_D));


! Define the Operator Routine Table for C Division.
!
OPERATOR_ROUTINE_TABLE (C_DIV_TABLE,
    OPERATOR_ROUTINE (L, L, L, DIV_L_L),
    OPERATOR_ROUTINE (LU, LU, LU, DIV_LU_LU),
    OPERATOR_ROUTINE (D, D, D, DIV_D_D));


! Define the Operator Routine Table for C Unary Minus (Negating Arithmetic). 
!
OPERATOR_ROUTINE_TABLE (C_UNARY_MINUS_TABLE,

! The following are not language dependent types.  This is needed for DEBUG
! types.  For example, DEP/QUAD L= +1.
!
    OPERATOR_ROUTINE (B, B, B, UNARY_MINUS_B),
    OPERATOR_ROUTINE (W, W, W, UNARY_MINUS_W),
    OPERATOR_ROUTINE (F, F, F, UNARY_MINUS_F),
    OPERATOR_ROUTINE (G, G, G, UNARY_MINUS_G),
    OPERATOR_ROUTINE (H, H, H, UNARY_MINUS_H),
    OPERATOR_ROUTINE (P, P, P, UNARY_MINUS_P),
    OPERATOR_ROUTINE (Q, Q, Q, UNARY_MINUS_Q),
    OPERATOR_ROUTINE (O, O, O, UNARY_MINUS_O),

    OPERATOR_ROUTINE (L, L, L, UNARY_MINUS_L),
    OPERATOR_ROUTINE (LU, LU, LU, UNARY_MINUS_LU),
    OPERATOR_ROUTINE (D, D, D, UNARY_MINUS_D));


! This table is needed for the +/- constant.
!
OPERATOR_ROUTINE_TABLE (C_UNARY_PLUS_TABLE,

! The following are not language dependent types.  This is needed for DEBUG
! types.  For example, DEP/QUAD L= +1.
!
    OPERATOR_ROUTINE (B, B, B, UNARY_PLUS_B),
    OPERATOR_ROUTINE (W, W, W, UNARY_PLUS_W),
    OPERATOR_ROUTINE (L, L, L, UNARY_PLUS_L),
    OPERATOR_ROUTINE (F, F, F, UNARY_PLUS_F),
    OPERATOR_ROUTINE (D, D, D, UNARY_PLUS_D),
    OPERATOR_ROUTINE (G, G, G, UNARY_PLUS_G),
    OPERATOR_ROUTINE (H, H, H, UNARY_PLUS_H),
    OPERATOR_ROUTINE (P, P, P, UNARY_PLUS_P),
    OPERATOR_ROUTINE (Q, Q, Q, UNARY_PLUS_Q),
    OPERATOR_ROUTINE (O, O, O, UNARY_PLUS_O));


! Define the Operator Routine Table for C Modulus.
! Modulus is only defined for integer types.
! Note: The C Modulus function is really the remainder function.
!
OPERATOR_ROUTINE_TABLE (C_MOD_TABLE,
    OPERATOR_ROUTINE (L, L, L, REM_L_L),
    OPERATOR_ROUTINE (LU, LU, LU, REM_LU_LU));


! Relational operators. These accept all three numeric types, 
! and also pointer type (which is just treated as integer).

! Define the Operator Routine Table for C Equal.
! Signed and usigned equal are the same so they both use the EQL_L_L
! routine.
!
OPERATOR_ROUTINE_TABLE (C_EQL_TABLE,
    OPERATOR_ROUTINE (TPTR, LU, L, EQL_L_L),
    OPERATOR_ROUTINE (LU, TPTR, L, EQL_L_L),
    OPERATOR_ROUTINE (TPTR, TPTR, L, EQL_L_L),
    OPERATOR_ROUTINE (L, L, L, EQL_L_L),
    OPERATOR_ROUTINE (LU, LU, L, EQL_L_L),
    OPERATOR_ROUTINE (D, D, L, EQL_D_D));


! Define the Operator Routine Table for C Not Equal.
! Signed and usigned not-equal are the same so they both use the EQL_L_L
! routine.
!
OPERATOR_ROUTINE_TABLE (C_NEQ_TABLE,
    OPERATOR_ROUTINE (TPTR, LU, L, NEQ_L_L),
    OPERATOR_ROUTINE (LU, TPTR, L, NEQ_L_L),
    OPERATOR_ROUTINE (TPTR, TPTR, L, NEQ_L_L),
    OPERATOR_ROUTINE (L, L, L, NEQ_L_L),
    OPERATOR_ROUTINE (LU, LU, L, NEQ_L_L),
    OPERATOR_ROUTINE (D, D, L, NEQ_D_D));


! Define the Operator Routine Table for C Less Than.
! Unsigned less than used a different routine than signed less than.
!
OPERATOR_ROUTINE_TABLE (C_LSS_TABLE,
    OPERATOR_ROUTINE (TPTR, L, L, LSS_L_L),
    OPERATOR_ROUTINE (TPTR, LU, L, LSS_LU_LU),
    OPERATOR_ROUTINE (L, TPTR, L, LSS_L_L),
    OPERATOR_ROUTINE (LU, TPTR, L, LSS_LU_LU),
    OPERATOR_ROUTINE (TPTR, TPTR, L, LSS_L_L),
    OPERATOR_ROUTINE (L, L, L, LSS_L_L),
    OPERATOR_ROUTINE (LU, LU, L, LSS_LU_LU),
    OPERATOR_ROUTINE (D, D, L, LSS_D_D));


! Define the Operator Routine Table for C Greater Than.
! Unsigned greater than uses a different routine than signed greater than.
!
OPERATOR_ROUTINE_TABLE (C_GTR_TABLE,
    OPERATOR_ROUTINE (TPTR, L, L, GTR_L_L),
    OPERATOR_ROUTINE (TPTR, LU, L, GTR_LU_LU),
    OPERATOR_ROUTINE (L, TPTR, L, GTR_L_L),
    OPERATOR_ROUTINE (LU, TPTR, L, GTR_LU_LU),
    OPERATOR_ROUTINE (TPTR, TPTR, L, GTR_L_L),
    OPERATOR_ROUTINE (L, L, L, GTR_L_L),
    OPERATOR_ROUTINE (LU, LU, L, GTR_LU_LU),
    OPERATOR_ROUTINE (D, D, L, GTR_D_D));


! Define the Operator Routine Table for C Less Than or Equal To.
! Unsigned less than/equal to uses a different routine than signed
! less than/equal to.
!
OPERATOR_ROUTINE_TABLE (C_LEQ_TABLE,
    OPERATOR_ROUTINE (TPTR, L, L, LEQ_L_L),
    OPERATOR_ROUTINE (TPTR, LU, L, LEQ_LU_LU),
    OPERATOR_ROUTINE (L, TPTR, L, LEQ_L_L),
    OPERATOR_ROUTINE (LU, TPTR, L, LEQ_LU_LU),
    OPERATOR_ROUTINE (TPTR, TPTR, L, LEQ_L_L),
    OPERATOR_ROUTINE (L, L, L, LEQ_L_L),
    OPERATOR_ROUTINE (LU, LU, L, LEQ_LU_LU),
    OPERATOR_ROUTINE (D, D, L, LEQ_D_D));


! Define the Operator Routine Table for C Greater Than or Equal.
! Unsigned greater than or equal to uses a different routine than
! signed greater than or equal to.
!
OPERATOR_ROUTINE_TABLE (C_GEQ_TABLE,
    OPERATOR_ROUTINE (TPTR, L, L, GEQ_L_L),
    OPERATOR_ROUTINE (TPTR, LU, L, GEQ_LU_LU),
    OPERATOR_ROUTINE (L, TPTR, L, GEQ_L_L),
    OPERATOR_ROUTINE (LU, TPTR, L, GEQ_LU_LU),
    OPERATOR_ROUTINE (TPTR, TPTR, L, GEQ_L_L),
    OPERATOR_ROUTINE (L, L, L, GEQ_L_L),
    OPERATOR_ROUTINE (LU, LU, L, GEQ_LU_LU),
    OPERATOR_ROUTINE (D, D, L, GEQ_D_D));


! Bitwise operators.
! These accept only integer data types (no float).

! Define the Operator Routine Table for C Bitwise And.
!
OPERATOR_ROUTINE_TABLE (C_BIT_AND_TABLE,
    OPERATOR_ROUTINE (L, L, L, BIT_AND_L_L),
    OPERATOR_ROUTINE (LU, LU, LU, BIT_AND_L_L));


! Define the Operator Routine Table for C Bitwise Or.
!
OPERATOR_ROUTINE_TABLE (C_BIT_OR_TABLE,
    OPERATOR_ROUTINE (L, L, L, BIT_OR_L_L),
    OPERATOR_ROUTINE (LU, LU, LU, BIT_OR_L_L));


! Define the Operator Routine Table for C Bitwise Xor.
!
OPERATOR_ROUTINE_TABLE (C_BIT_XOR_TABLE,
    OPERATOR_ROUTINE (L, L, L, BIT_XOR_L_L),
    OPERATOR_ROUTINE (LU, LU, LU, BIT_XOR_L_L));

! Define the Operator Routine Table for C Bitwise Not (One's Complement).
!
OPERATOR_ROUTINE_TABLE (C_BIT_NOT_TABLE,
    OPERATOR_ROUTINE (L, L, L, BIT_NOT_L),
    OPERATOR_ROUTINE (LU, LU, LU, BIT_NOT_L));


! Logical operations.
! These just do the Boolean operations with TRUE <-> not zero,
! FALSE <-> zero.
! For mixed int-float logical operations, we convert both to float.
! This is not identical to what the compiler does. But hopefully,
! conversion to float should preserve the zero/notzero characteristic,
! so we should get the same final answer except in obscure boundary
! conditions.
! We also allow pointers, which are just treated as integer.

! Define the Operator Routine Table for C Logical And.
!
OPERATOR_ROUTINE_TABLE (C_AND_TABLE,
    OPERATOR_ROUTINE (TPTR, TPTR, L, AND_L_L),
    OPERATOR_ROUTINE (TPTR, LU, L, AND_L_L),
    OPERATOR_ROUTINE (LU, TPTR, L, AND_L_L),
    OPERATOR_ROUTINE (L, L, L, AND_L_L),
    OPERATOR_ROUTINE (LU, LU, L, AND_L_L),
    OPERATOR_ROUTINE (D, D, L, AND_D_D));


! Define the Operator Routine Table for C Logical Or.
!
OPERATOR_ROUTINE_TABLE (C_OR_TABLE,
    OPERATOR_ROUTINE (TPTR, TPTR, L, OR_L_L),
    OPERATOR_ROUTINE (TPTR, LU, L, OR_L_L),
    OPERATOR_ROUTINE (LU, TPTR, L, OR_L_L),
    OPERATOR_ROUTINE (L, L, L, OR_L_L),
    OPERATOR_ROUTINE (LU, LU, L, OR_L_L),
    OPERATOR_ROUTINE (D, D, L, OR_D_D));


! Define the Operator Routine Table for C Logical Not.
!
OPERATOR_ROUTINE_TABLE (C_NOT_TABLE,
    OPERATOR_ROUTINE (TPTR, TPTR, L, NOT_L),
    OPERATOR_ROUTINE (L, L, L, NOT_L),
    OPERATOR_ROUTINE (LU, LU, L, NOT_L),
    OPERATOR_ROUTINE (D, D, L, NOT_D));


! Shift operators.
! These accept only integer types.

! Define the Operator Routine Table for C Left Shift.
!
OPERATOR_ROUTINE_TABLE (C_SHIFT_LEFT_TABLE,
    OPERATOR_ROUTINE (L, L, L, SHIFT_LEFT_L_L),
    OPERATOR_ROUTINE (LU, LU, LU, SHIFT_LEFT_L_L));


! Define the Operator Routine Table for C Right Shift.
! Unsigned right shift is different from signed. For unsigned right
! shift, we always shift in zeros. For signed right shift, we shift
! in copies of the sign bit.
!
OPERATOR_ROUTINE_TABLE (C_SHIFT_RT_TABLE,
    OPERATOR_ROUTINE (L, L, L, SHIFT_RT_L_L),
    OPERATOR_ROUTINE (LU, LU, LU, SHIFT_RT_LU_LU));


! Define Operator Routine Tables for ++X  X++ --X  X--
!
OPERATOR_ROUTINE_TABLE (C_PRE_INCR_TABLE,
    OPERATOR_ROUTINE (L, L, L, PRE_INCR_L),
    OPERATOR_ROUTINE (LU, LU, LU, PRE_INCR_LU),
    OPERATOR_ROUTINE (D, D, D, PRE_INCR_D),
    OPERATOR_ROUTINE (TPTR, TPTR, TPTR, PRE_INCR_TPTR));

OPERATOR_ROUTINE_TABLE (C_POST_INCR_TABLE,
    OPERATOR_ROUTINE (L, L, L, POST_INCR_L),
    OPERATOR_ROUTINE (LU, LU, LU, POST_INCR_LU),
    OPERATOR_ROUTINE (D, D, D, POST_INCR_D),
    OPERATOR_ROUTINE (TPTR, TPTR, TPTR, POST_INCR_TPTR));

OPERATOR_ROUTINE_TABLE (C_PRE_DECR_TABLE,
    OPERATOR_ROUTINE (L, L, L, PRE_DECR_L),
    OPERATOR_ROUTINE (LU, LU, LU, PRE_DECR_LU),
    OPERATOR_ROUTINE (D, D, D, PRE_DECR_D),
    OPERATOR_ROUTINE (TPTR, TPTR, TPTR, PRE_DECR_TPTR));

OPERATOR_ROUTINE_TABLE (C_POST_DECR_TABLE,
    OPERATOR_ROUTINE (L, L, L, POST_DECR_L),
    OPERATOR_ROUTINE (LU, LU, LU, POST_DECR_LU),
    OPERATOR_ROUTINE (D, D, D, POST_DECR_D),
    OPERATOR_ROUTINE (TPTR, TPTR, TPTR, POST_DECR_TPTR));


! Define the Operator Routine Table for C Address Of.
! The address-of operator will have the FETCH_FLAG off in the operator
! information table. This means that PRIM_TO_ADDR will get called.
! The value of the result will thus be the address of the operand.
! The type of the result is "pointer to xxx", where "xxx" is the type
! of the operand. This means that the the routine which is called to
! do "address_of" must construct a typeid for the result.
!
OPERATOR_ROUTINE_TABLE (C_ADDRESS_TABLE,
    OPERATOR_ROUTINE (L, L, TPTR, ADDRESS_L));


! Define the Operator Routine Table for the size of operator.
! Size-of will look up the typeid in the symbol table and determine
! the declared size of the object. The FETCH_FLAG will be FALSE, so
! PRIM_TO_ADDR will be called instead of PRIM_TO_VAL. This is 
! because we do not need the value of the object.
!
OPERATOR_ROUTINE_TABLE (C_SIZEOF_TABLE,
    OPERATOR_ROUTINE (L, L, L, SIZEOF_L));


! Define the Operator Routine Table for C Indirection (Dereferencing Pointers).
! The indirection operator (*) will do a pointer dereference of
! its argument. The type of the returned object depends on the
! type of the pointer. (We will have to do a symbol table lookup
! on the TYPEID).
!
OPERATOR_ROUTINE_TABLE (C_INDIRECT_TABLE,
    OPERATOR_ROUTINE (TPTR, TPTR, UNKNOWN, INDIRECT_TPTR));


! Define the Operator Information Table for C.
!
OPERATOR_INFO_TABLE (C_OPINFO_TABLE,

    ! All C operators use the same hierarchy table, and have no
    ! type incompatibility table.

    ! Arithmetic operators.
    !
    OPERATOR_INFO_ENTRY 
    	(ADD, C_ADD_TABLE, C_HIER_TABLE, TABLEBASE),
    OPERATOR_INFO_ENTRY 
    	(SUBTRACT, C_SUB_TABLE, C_HIER_TABLE, TABLEBASE),
    OPERATOR_INFO_ENTRY 
    	(MULTIPLY, C_MUL_TABLE, C_HIER_TABLE, TABLEBASE),
    OPERATOR_INFO_ENTRY 
    	(DIVIDE, C_DIV_TABLE, C_HIER_TABLE, TABLEBASE),
    OPERATOR_INFO_ENTRY 
    	(REMAINDER, C_MOD_TABLE, C_HIER_TABLE, TABLEBASE),
    OPERATOR_INFO_ENTRY
    	(UNARY_MINUS, C_UNARY_MINUS_TABLE, C_HIER_TABLE, TABLEBASE),

    ! This is needed for /Qualifier for depositing the +/- constant.
    !
    OPERATOR_INFO_ENTRY
    	(UNARY_PLUS, C_UNARY_PLUS_TABLE, C_HIER_TABLE, TABLEBASE),

    ! Relational operators.
    !
    OPERATOR_INFO_ENTRY 
    	(EQUAL, C_EQL_TABLE, C_HIER_TABLE, TABLEBASE),
    OPERATOR_INFO_ENTRY 
    	(NOT_EQUAL, C_NEQ_TABLE, C_HIER_TABLE, TABLEBASE),
    OPERATOR_INFO_ENTRY 
    	(LSS_THAN, C_LSS_TABLE, C_HIER_TABLE, TABLEBASE),
    OPERATOR_INFO_ENTRY 
    	(GTR_THAN, C_GTR_TABLE, C_HIER_TABLE, TABLEBASE),
    OPERATOR_INFO_ENTRY 
    	(LSS_EQUAL, C_LEQ_TABLE, C_HIER_TABLE, TABLEBASE),
    OPERATOR_INFO_ENTRY 
    	(GTR_EQUAL, C_GEQ_TABLE, C_HIER_TABLE, TABLEBASE),

    ! Bitwise logical operators.
    !
    OPERATOR_INFO_ENTRY 
    	(BIT_AND, C_BIT_AND_TABLE, C_HIER_TABLE, TABLEBASE),
    OPERATOR_INFO_ENTRY 
    	(BIT_OR, C_BIT_OR_TABLE, C_HIER_TABLE, TABLEBASE),
    OPERATOR_INFO_ENTRY 
    	(BIT_XOR, C_BIT_XOR_TABLE, C_HIER_TABLE, TABLEBASE),
    OPERATOR_INFO_ENTRY 
    	(BIT_NOT, C_BIT_NOT_TABLE, C_HIER_TABLE, TABLEBASE),

    ! Logical operators.
    !
    OPERATOR_INFO_ENTRY 
    	(SHORT_AND, C_AND_TABLE, C_HIER_TABLE, TABLEBASE),
    OPERATOR_INFO_ENTRY 
    	(SHORT_OR, C_OR_TABLE, C_HIER_TABLE, TABLEBASE),
    OPERATOR_INFO_ENTRY 
    	(NOT, C_NOT_TABLE, C_HIER_TABLE, TABLEBASE),

    ! Shift operators.
    !
    OPERATOR_INFO_ENTRY 
    	(LEFT_SHIFT, C_SHIFT_LEFT_TABLE, C_HIER_TABLE, TABLEBASE),
    OPERATOR_INFO_ENTRY 
    	(RIGHT_SHIFT, C_SHIFT_RT_TABLE, C_HIER_TABLE, TABLEBASE),

    ! Operators with side effects.
    !
    OPERATOR_INFO_ENTRY
    	(PRE_INCR, C_PRE_INCR_TABLE, C_HIER_TABLE, TABLEBASE),
    OPERATOR_INFO_ENTRY
    	(POST_INCR, C_POST_INCR_TABLE, C_HIER_TABLE, TABLEBASE),
    OPERATOR_INFO_ENTRY
    	(PRE_DECR, C_PRE_DECR_TABLE, C_HIER_TABLE, TABLEBASE),
    OPERATOR_INFO_ENTRY
    	(POST_DECR, C_POST_DECR_TABLE, C_HIER_TABLE, TABLEBASE),

    ! Operators that work on the SYMID or TYPEID.
    !
    OPERATOR_INFO_ENTRY
    	(ADDRESS_OF, C_ADDRESS_TABLE, C_HIER_TABLE, TABLEBASE, FALSE),
    OPERATOR_INFO_ENTRY
    	(SIZEOF, C_SIZEOF_TABLE, C_HIER_TABLE, TABLEBASE, FALSE),

    ! Indirection
    !
    OPERATOR_INFO_ENTRY 
    	(INDIRECT, C_INDIRECT_TABLE, C_HIER_TABLE, TABLEBASE),

    ! DEPOSIT is used to implement the DEPOSIT command.
    !
    OPERATOR_INFO_ENTRY
    	(DEPOSIT, TABLEBASE, C_HIERD_TABLE, TABLEBASE),

    ! CONVERT is used for things like converting subscripts.
    !
    OPERATOR_INFO_ENTRY
    	(CONVERT, TABLEBASE, C_HIER_TABLE, TABLEBASE),

    ! Identity is called at the end of an EVALUATE if we still have
    ! a Primary.
    !
    OPERATOR_INFO_ENTRY
    	(IDENTITY, TABLEBASE, TABLEBASE, TABLEBASE));


!
! 	C O B O L   O P E R A T O R   I N F O R M A T I O N   T A B L E S
!
!
! This section contains the Operator Routine and Type tables needed to
! evaluate expressions in the COBOL language.
!
!
! The following summarizes the information in the COBOL manual, and from
! our old cobol support about data types, type conversions and operators.
! There is further documentation within the tables below, describing 
! exactly how we translate this into the DEBUG tables.
!
! Cobol Data Types:
!
!	.Elementary
!	 Alphabetic, Alphanumeric:         (Text string)
!	 Numeric:
!	   Binary 
!	     PIC 9     -- PIC 9(4)  COMP   (Scaled W, WU)
!	     PIC 9(5)  -- PIC 9(9)  COMP   (Scaled L, LU)
!	     PIC 9(10) -- PIC 9(18) COMP   (Scaled Q, QU)
!	     INDEX                         (L)
!	   Floating
!	     COMP-1                        (Floating)
!	     COMP-2                        (Double)	   
!	   Packed-Decimal
!	     COMP-3                        (Packed with/without Scaled)
!	   Decimal
!	     PIC 99...                     (Scaled NU)
!	     PIC S9... LEADING SEPARATE    (Scaled NL)
!	     PIC S9... LEADING             (Scaled NLO)
!	     PIC S9... TRAILING SEPARATE   (Scaled NR)
!	     PIC S9... TRAILING	           (Scaled NRO)
!
!	.Group
!	 Alphanumeric                      (Text String)
!
!       .Edited data                       (Text String)
!
! Expressions:
!	.Arithmetic
!        operator: + - * / (** - not support) unary+ unary-
!	 operand:  numeric literal or numeric elementary identifier
!
!	.Conditional (TRUE, FALSE)
!	 operator: =, NOT =, >, NOT >, <, NOT <
!	 operand:  elementary identifier, literal, or AE
!
!	.Complex Conditional (TRUE, FALSE)
!	 operator: NOT, AND, OR
!	 operand:  conditions
!
!       Note: abbreviated forms are not supported.
!
! Type Conversion:
!
! SD	WU==W ---------------+
! SD    LU==L ---------------|
! SD    QU==Q ---------------|
!       NU, NL, NLO, NR, NRO-|--> P  
!       F--------------------|
!       D--------------------+
!
! 1.    All the integer and float constants are picked up as packed decimal if 
!	one of the operand is SD descriptor type.
!
! 2.	If one of the operand is Scaled Descriptor or Packed decimal
!	data type the operation is always done in Packed Form.  The
!	operation even includes the deposit.
!
!	So in COBOL, one will have the following case:
!         DEP SC2V2=F
!	  F converts to P, make a packed decimal place holder for SC2V2
!	  (which is word scaled -2), convert P to this place holder,
!	  final conversion will convert this place holder to SC2V2 data type.
!
!         EV F+F
!	  the operation is done by adding F to F. 
!
!	  EV F+P
!	  the operation is done by adding P to P.
!
!         DEP P=123.123
!         in here 123.123 is picked up as packed decimal constant instead of
!         float.
!
!         DEP (SD, WU) = -123
!         the value we got is the absolute value.
!
!         EV  1.1+1
!         the operation is done in Packed form.
!
! Define the COBOL Specific Type Conversion Table.  This allows proper
! handling of COBOL Edited Data type.
!
LANG_CVT_TABLE (COBOL_CVT_TABLE,
    LANG_CVT_ENTRY (COB_PICT, PICT, ANY),
    0);


! Define the Type Conversion Information Table for COBOL.  No rounding
! takes place in COBOL.
!
CONVERSION_INFO_TABLE (COBOL_CVTINFO_TABLE,
    CONVERSION_INFO_ENTRY (TABLEBASE, COBOL_CVT_TABLE));

! Define Type Hierarchy Table for COBOL.
!
TYPE_HIERARCHY_TABLE (COBOL_HIER_TABLE,
    TYPE_GRAPH_EDGE (WU, P),
    TYPE_GRAPH_EDGE (W, P),
    TYPE_GRAPH_EDGE (LU, P),
    TYPE_GRAPH_EDGE (L, P),
    TYPE_GRAPH_EDGE (QU, P),
    TYPE_GRAPH_EDGE (Q, P),
    TYPE_GRAPH_EDGE (NU, P),
    TYPE_GRAPH_EDGE (NL, P),
    TYPE_GRAPH_EDGE (NLO, P),
    TYPE_GRAPH_EDGE (NR, P),
    TYPE_GRAPH_EDGE (NRO, P),
    TYPE_GRAPH_EDGE (F, D),
    TYPE_GRAPH_EDGE (D, P),
    0);

! Define the Type Hierarchy Table for COBOL deposit.
!
TYPE_HIERARCHY_TABLE (COBOL_HIERD_TABLE,
    TYPE_GRAPH_EDGE (PICT, WU),
    TYPE_GRAPH_EDGE (WU, W),
    TYPE_GRAPH_EDGE (W, LU),
    TYPE_GRAPH_EDGE (LU, L),
    TYPE_GRAPH_EDGE (L, QU),
    TYPE_GRAPH_EDGE (QU, Q),
    TYPE_GRAPH_EDGE (Q, NU),
    TYPE_GRAPH_EDGE (NU, NL),
    TYPE_GRAPH_EDGE (NL, NLO),
    TYPE_GRAPH_EDGE (NLO, NR),
    TYPE_GRAPH_EDGE (NR, NRO),
    TYPE_GRAPH_EDGE (NRO, P),
    TYPE_GRAPH_EDGE (P, F),
    TYPE_GRAPH_EDGE (F, D),
    TYPE_GRAPH_EDGE (D, PICT),
    0);

! Define the Operator Routine Table for COBOL addition.
!
OPERATOR_ROUTINE_TABLE (COBOL_ADD_TABLE,
    OPERATOR_ROUTINE (P, P, P, ADD_P_P),
    OPERATOR_ROUTINE (F, F, F, ADD_F_F),
    OPERATOR_ROUTINE (D, D, D, ADD_D_D));

! Define the Operator Routine Table for COBOL subtraction.
!
OPERATOR_ROUTINE_TABLE (COBOL_SUB_TABLE,
    OPERATOR_ROUTINE (P, P, P, SUB_P_P),
    OPERATOR_ROUTINE (F, F, F, SUB_F_F),
    OPERATOR_ROUTINE (D, D, D, SUB_D_D));

! Define the Operator Routine Table for COBOL multiplication.
!
OPERATOR_ROUTINE_TABLE (COBOL_MUL_TABLE,
    OPERATOR_ROUTINE (P, P, P, MUL_P_P),
    OPERATOR_ROUTINE (F, F, F, MUL_F_F),
    OPERATOR_ROUTINE (D, D, D, MUL_D_D));

! Define the Operator Routine Table for COBOL division.
!
OPERATOR_ROUTINE_TABLE (COBOL_DIV_TABLE,
    OPERATOR_ROUTINE (P, P, P, DIV_P_P),
    OPERATOR_ROUTINE (F, F, F, DIV_F_F),
    OPERATOR_ROUTINE (D, D, D, DIV_D_D));

! Define the Operator Routine Table for COBOL unary plus.
!
OPERATOR_ROUTINE_TABLE (COBOL_UNARY_PLUS_TABLE,

! The following are not language dependent types.  This is needed for DEBUG
! types.  For example, DEP/QUAD L= +1.
!
    OPERATOR_ROUTINE (B, B, B, UNARY_PLUS_B),
    OPERATOR_ROUTINE (W, W, W, UNARY_PLUS_W),
    OPERATOR_ROUTINE (L, L, L, UNARY_PLUS_L),
    OPERATOR_ROUTINE (G, G, G, UNARY_PLUS_G),
    OPERATOR_ROUTINE (H, H, H, UNARY_PLUS_H),
    OPERATOR_ROUTINE (Q, Q, Q, UNARY_PLUS_Q),
    OPERATOR_ROUTINE (O, O, O, UNARY_PLUS_O),

    OPERATOR_ROUTINE (P, P, P, UNARY_PLUS_P),
    OPERATOR_ROUTINE (F, F, F, UNARY_PLUS_F),
    OPERATOR_ROUTINE (D, D, D, UNARY_PLUS_D));

! Define the Operator Routine Table for COBOL unary minus.
!
OPERATOR_ROUTINE_TABLE (COBOL_UNARY_MINUS_TABLE,

! The following are not language dependent types.  This is needed for DEBUG
! types.  For example, DEP/QUAD L= +1.
!
    OPERATOR_ROUTINE (B, B, B, UNARY_MINUS_B),
    OPERATOR_ROUTINE (W, W, W, UNARY_MINUS_W),
    OPERATOR_ROUTINE (L, L, L, UNARY_MINUS_L),
    OPERATOR_ROUTINE (G, G, G, UNARY_MINUS_G),
    OPERATOR_ROUTINE (H, H, H, UNARY_MINUS_H),
    OPERATOR_ROUTINE (Q, Q, Q, UNARY_MINUS_Q),
    OPERATOR_ROUTINE (O, O, O, UNARY_MINUS_O),

    OPERATOR_ROUTINE (P, P, P, UNARY_MINUS_P),
    OPERATOR_ROUTINE (F, F, F, UNARY_MINUS_F),
    OPERATOR_ROUTINE (D, D, D, UNARY_MINUS_D));

! Define the Operator Routine Table for COBOL =.
!
OPERATOR_ROUTINE_TABLE (COBOL_EQL_TABLE,
    OPERATOR_ROUTINE (T, T, TF, EQL_T_T),
    OPERATOR_ROUTINE (P, P, TF, EQL_P_P),
    OPERATOR_ROUTINE (F, F, TF, EQL_F_F),
    OPERATOR_ROUTINE (D, D, TF, EQL_D_D));

! Define the Operator Routine Table for COBOL NOT =.
!
OPERATOR_ROUTINE_TABLE (COBOL_NEQ_TABLE,
    OPERATOR_ROUTINE (T, T, TF, NEQ_T_T),
    OPERATOR_ROUTINE (P, P, TF, NEQ_P_P),
    OPERATOR_ROUTINE (F, F, TF, NEQ_F_F),
    OPERATOR_ROUTINE (D, D, TF, NEQ_D_D));

! Define the Operator Routine Table for COBOL >.
!
OPERATOR_ROUTINE_TABLE (COBOL_GTR_TABLE,
    OPERATOR_ROUTINE (T, T, TF, GTR_T_T),
    OPERATOR_ROUTINE (P, P, TF, GTR_P_P),
    OPERATOR_ROUTINE (F, F, TF, GTR_F_F),
    OPERATOR_ROUTINE (D, D, TF, GTR_D_D));

! Define the Operator Routine Table for COBOL NOT <.
!
OPERATOR_ROUTINE_TABLE (COBOL_GEQ_TABLE,
    OPERATOR_ROUTINE (T, T, TF, GEQ_T_T),
    OPERATOR_ROUTINE (P, P, TF, GEQ_P_P),
    OPERATOR_ROUTINE (F, F, TF, GEQ_F_F),
    OPERATOR_ROUTINE (D, D, TF, GEQ_D_D));

! Define the Operator Routine Table for COBOL <.
!
OPERATOR_ROUTINE_TABLE (COBOL_LSS_TABLE,
    OPERATOR_ROUTINE (T, T, TF, LSS_T_T),
    OPERATOR_ROUTINE (P, P, TF, LSS_P_P),
    OPERATOR_ROUTINE (F, F, TF, LSS_F_F),
    OPERATOR_ROUTINE (D, D, TF, LSS_D_D));

! Define the Operator Routine Table for COBOL NOT >.
!
OPERATOR_ROUTINE_TABLE (COBOL_LEQ_TABLE,
    OPERATOR_ROUTINE (T, T, TF, LEQ_T_T),
    OPERATOR_ROUTINE (P, P, TF, LEQ_P_P),
    OPERATOR_ROUTINE (F, F, TF, LEQ_F_F),
    OPERATOR_ROUTINE (D, D, TF, LEQ_D_D));

! Define the Operator Routine Table for COBOL NOT.
!
OPERATOR_ROUTINE_TABLE (COBOL_NOT_TABLE,
    OPERATOR_ROUTINE (TF, TF, TF, NOT_L));

! Define the Operator Routine Table for COBOL AND.
!
OPERATOR_ROUTINE_TABLE (COBOL_AND_TABLE,
    OPERATOR_ROUTINE (TF, TF, TF, AND_L_L));

! Define the Operator Routine Table for COBOL OR.
!
OPERATOR_ROUTINE_TABLE (COBOL_OR_TABLE,
    OPERATOR_ROUTINE (TF, TF, TF, OR_L_L)); 


! Define the Operator Information Table for COBOL.
!
OPERATOR_INFO_TABLE (COBOL_OPINFO_TABLE,
    OPERATOR_INFO_ENTRY 
    	(ADD, COBOL_ADD_TABLE, COBOL_HIER_TABLE, TABLEBASE),
    OPERATOR_INFO_ENTRY
    	(SUBTRACT, COBOL_SUB_TABLE, COBOL_HIER_TABLE, TABLEBASE),
    OPERATOR_INFO_ENTRY
    	(MULTIPLY, COBOL_MUL_TABLE, COBOL_HIER_TABLE, TABLEBASE),
    OPERATOR_INFO_ENTRY
    	(DIVIDE, COBOL_DIV_TABLE, COBOL_HIER_TABLE, TABLEBASE),
    OPERATOR_INFO_ENTRY
    	(UNARY_PLUS, COBOL_UNARY_PLUS_TABLE, COBOL_HIER_TABLE, TABLEBASE),
    OPERATOR_INFO_ENTRY
    	(UNARY_MINUS, COBOL_UNARY_MINUS_TABLE, COBOL_HIER_TABLE, TABLEBASE),
    OPERATOR_INFO_ENTRY
    	(EQUAL, COBOL_EQL_TABLE, COBOL_HIER_TABLE, TABLEBASE),
    OPERATOR_INFO_ENTRY
    	(NOT_EQUAL, COBOL_NEQ_TABLE, COBOL_HIER_TABLE, TABLEBASE),
    OPERATOR_INFO_ENTRY
    	(GTR_THAN, COBOL_GTR_TABLE, COBOL_HIER_TABLE, TABLEBASE),
    OPERATOR_INFO_ENTRY
    	(GTR_EQUAL, COBOL_GEQ_TABLE, COBOL_HIER_TABLE, TABLEBASE),
    OPERATOR_INFO_ENTRY
    	(LSS_THAN, COBOL_LSS_TABLE, COBOL_HIER_TABLE, TABLEBASE),
    OPERATOR_INFO_ENTRY
    	(LSS_EQUAL, COBOL_LEQ_TABLE, COBOL_HIER_TABLE, TABLEBASE),
    OPERATOR_INFO_ENTRY
    	(NOT, COBOL_NOT_TABLE, COBOL_HIER_TABLE, TABLEBASE),
    OPERATOR_INFO_ENTRY
    	(AND, COBOL_AND_TABLE, COBOL_HIER_TABLE, TABLEBASE),
    OPERATOR_INFO_ENTRY
    	(OR, COBOL_OR_TABLE, COBOL_HIER_TABLE, TABLEBASE),
    OPERATOR_INFO_ENTRY
    	(CONVERT, TABLEBASE, COBOL_HIERD_TABLE, TABLEBASE),
    OPERATOR_INFO_ENTRY
    	(DEPOSIT, TABLEBASE, COBOL_HIERD_TABLE, TABLEBASE),
    OPERATOR_INFO_ENTRY
    	(IDENTITY, TABLEBASE, TABLEBASE, TABLEBASE));


!
!   F O R T R A N   O P E R A T O R   I N F O R M A T I O N   T A B L E S
!
! This section contains the Operator Routine and Type tables needed to
! evaluate expressions in the FORTRAN language.
!
!
! The following summarizes the information in the FORTRAN manual about
! data types, type conversions, and operators. There is further documentation
! within the tables below, describing exactly how we translate this into
! the DEBUG tables.
!
! Fortran Data:
!	Constants, Integer, Real, Character variables, Integer, Real, Character
!	Array
!
! Fortran Data Types:
!	. Logical	
!	  logical*1 (byte), logical*2 (word), logical*4 (long)
!	. Integer
!	  integer*2 (word), integer*4 (long)
!	. Real
!	  real*4 (f_float), real*8 (d_float, g_float), real*16 (h_float)
!	. Complex
!	  complex*8 (f_float), complex*16 (d_float, g_float)
!	. Character
!	  
! Expressions:
!	. Arithmetic
!	  Operand: numeric (logical, integer, real).  Result: numeric values.
!	  Operator: ** (exponentiation), * (multiplication), / (division), 
!	  + (addition, unary plus), - (subtraction, unary minus)
!
!	. Character
!	  Operand: character.  Result: character values.
!	  Operator: // (concatenation)
!
!	. Relational
!	  Operand: numerics or characters.  Result: logical values.
!	  Operator: .LT. (less than), .LE. (less than or equal to), 
!	  .EQ. (equal to), .NE. (not equal to), .GT. (greater than), 
!	  .GE. (greater than or equal to)
!
!	. Logical
!	  Operand: integer or logical.  Result: logical values.
!	  Operator: .AND., .OR., .XOR., .NEQV. (.XOR.), .EQV., .NOT.
!
! Type Conversion:
!	. Arithmetic
!	  1. Operands are of the same data type, the result is also of that 
!	     data type.
!
!	  2. Otherwise, Logical --> integer*2 --> integer*4 --> real*4 -->
!	     real*8 --> real*16 --> complex*8 --> complex*16.
!
!	     *** Note - although a chart such as the one given above
!	     *** does appear in the FORTRAN manual, that is not
!	     *** exactly how things are really done. A more precise graph
!	     *** is:
!	     	B -> W -> L -> F -> D -> H
!			        \    \  /
!    				 FC -> DC
!
! 	     That is, things become non-linear when complex is involved.
!	     For example, if a real*16 is added to a complex*8 then
!	     both are converted up to complex*16
!
!	     This second diagram is our hierarchy table.
!
!	     If the user specified /G_FLOAT then the diagram is the same
!	     except that G is substituted for D.
!
!	  3. An operation involving a complex*8 and a real*16
!	     produces complex*16 result.
!
!	  4. Integer operations are performed on integers. (Logical is treated
!	     as integers)
!
!	  5. Real operations are perfomred only on reals or combinations of
!	     real, integer, and logcal.  Integer --> real before the operation.
!
!	  6. Real*8, Real*16 operations.  Elements --> higher-precision (see 2)
!
!	  7. Complex operations.  (see 2, 4, 5, 6, and 3)
!
! 	.Relational
!	  1. Complex can be related only by the .EQ. and .NE.
!	  2. Lower-ranked data type --> higher-ranked data type before the
!	     the comparison is made.
!
!	.Logical
!	  1. Logical operator operates on logical, the result is logical.
!	  2. Logical operator operates on integer, the operation is carried
!	     out bit-by-bit on the corresponding bits of the internal of the
!	     integer, the result is integer.
!	  3. Logical operator operates on combined logical, integer, logical
!	     --> integer, then (see 2).
!


! Define the Type Mapping Table for FORTRAN
! In FORTRAN, data that was declared as logical*1, logical*2, or logical*4
! appears in the DST as BU, WU, and LU. However, for our purposes, we
! want to treat it as B, W, or L. We thus "map" the dtypes. 
!
! For example, if BU contains -1, and L contains 1, then we
! want EV BU+L to give 0, not 256.
! The type mapping table is thus needed to turn BU->B, WU->W, and LU->L
!
TYPE_MAPPING_TABLE (FORTRAN_MAP_TABLE,
    TYPE_GRAPH_EDGE (BU, B),
    TYPE_GRAPH_EDGE (WU, W),
    TYPE_GRAPH_EDGE (LU, L),
    0);


! Define the Type Conversion Information Table for FORTRAN.
! This points to the mapping table define above. There is no CVT_TABLE
! specifying exceptions to the DBG$CVT_DX_DX rules.
!
CONVERSION_INFO_TABLE (FORTRAN_CVTINFO_TABLE,
    CONVERSION_INFO_ENTRY (FORTRAN_MAP_TABLE, TABLEBASE));


! Define the Type Hierarchy Table for FORTRAN.
! This table is described above when we talk about conversion rules.
! Note that the Incompatibility Table prevents mixing D with G types.
! Leaving out the G edges, the graph specified by this table is:
!
!	     	B -> W -> L -> F -> D -> H
!			        \    \  /
!    				 FC -> DC
!
TYPE_HIERARCHY_TABLE (FORTRAN_HIER1_TABLE,
    TYPE_GRAPH_EDGE (B, W),
    TYPE_GRAPH_EDGE (W, L),
    TYPE_GRAPH_EDGE (L, F),
    TYPE_GRAPH_EDGE (F, D),
    TYPE_GRAPH_EDGE (F, G),
    TYPE_GRAPH_EDGE (F, FC),
    TYPE_GRAPH_EDGE (D, H),
    TYPE_GRAPH_EDGE (D, DC),
    TYPE_GRAPH_EDGE (G, H),
    TYPE_GRAPH_EDGE (G, GC),
    TYPE_GRAPH_EDGE (H, DC),
    TYPE_GRAPH_EDGE (H, GC),
    TYPE_GRAPH_EDGE (FC, DC),
    TYPE_GRAPH_EDGE (FC, GC),
    0);


! Define a Type Hierarachy Table for FORTRAN
! This is a subset of the HIER1 table, which is used for operators that
! do not accept complex types. It would also be OK to use the HIER1 table
! for those operators, but giving a smaller table makes the code run
! faster.
!
TYPE_HIERARCHY_TABLE (FORTRAN_HIER2_TABLE,
    TYPE_GRAPH_EDGE (B, W),
    TYPE_GRAPH_EDGE (W, L),
    TYPE_GRAPH_EDGE (L, F),
    TYPE_GRAPH_EDGE (F, D),
    TYPE_GRAPH_EDGE (F, G),
    TYPE_GRAPH_EDGE (D, H),
    TYPE_GRAPH_EDGE (G, H),
    0);


! Define a Type Hierarachy Table for FORTRAN
! This is a subset of the HIER2 and HIER1 tables. It is used for those
! operators that only accept integer types. It would also be OK to
! use the HIER1 table but providing a smaller table speeds up the code.
!
TYPE_HIERARCHY_TABLE (FORTRAN_HIER3_TABLE,
    TYPE_GRAPH_EDGE (B, W),
    TYPE_GRAPH_EDGE (W, L),
    0);

! Define the Type Hierarchy Table for FORTRAN deposit.
! This is a circular table which includes all types except T.
! This means that any of the numeric types are convertible to any
! of the other numeric types on a DEPOSIT.
!
TYPE_HIERARCHY_TABLE (FORTRAN_HIERD_TABLE,
    TYPE_GRAPH_EDGE (B, W),
    TYPE_GRAPH_EDGE (W, L),
    TYPE_GRAPH_EDGE (L, F),
    TYPE_GRAPH_EDGE (F, D),
    TYPE_GRAPH_EDGE (D, G),
    TYPE_GRAPH_EDGE (G, H),
    TYPE_GRAPH_EDGE (H, FC),
    TYPE_GRAPH_EDGE (FC, DC),
    TYPE_GRAPH_EDGE (DC, GC),
    TYPE_GRAPH_EDGE (GC, B),
    0);

! Define the Type Incompatibility Table for FORTRAN.
! This prevents the user from mixing D and G types in an expression.
!
TYPE_INCOMP_TABLE (FORTRAN_INCOMP_TABLE,
    TYPE_GRAPH_EDGE (D, G),
    TYPE_GRAPH_EDGE (D, GC),
    TYPE_GRAPH_EDGE (G, DC),
    TYPE_GRAPH_EDGE (DC, GC),
    0);

!++
! Most of the arithmetic routines operate on two arguments of the same type.
! That type may be B, W, L, F, D, G, H, FC, DC, GC, so we provide all
! of those case indices.
!--

! Define the Operator Routine Table for FORTRAN addition.
!
OPERATOR_ROUTINE_TABLE (FORTRAN_ADD_TABLE,
    OPERATOR_ROUTINE (B, B, B, ADD_B_B),
    OPERATOR_ROUTINE (W, W, W, ADD_W_W),
    OPERATOR_ROUTINE (L, L, L, ADD_L_L),
    OPERATOR_ROUTINE (F, F, F, ADD_F_F),
    OPERATOR_ROUTINE (D, D, D, ADD_D_D),
    OPERATOR_ROUTINE (G, G, G, ADD_G_G),
    OPERATOR_ROUTINE (H, H, H, ADD_H_H),
    OPERATOR_ROUTINE (FC, FC, FC, ADD_FC_FC),
    OPERATOR_ROUTINE (DC, DC, DC, ADD_DC_DC),
    OPERATOR_ROUTINE (GC, GC, GC, ADD_GC_GC));


! Define the Operator Routine Table for FORTRAN subtraction.
!
OPERATOR_ROUTINE_TABLE (FORTRAN_SUB_TABLE,
    OPERATOR_ROUTINE (B, B, B, SUB_B_B),
    OPERATOR_ROUTINE (W, W, W, SUB_W_W),
    OPERATOR_ROUTINE (L, L, L, SUB_L_L),
    OPERATOR_ROUTINE (F, F, F, SUB_F_F),
    OPERATOR_ROUTINE (D, D, D, SUB_D_D),
    OPERATOR_ROUTINE (G, G, G, SUB_G_G),
    OPERATOR_ROUTINE (H, H, H, SUB_H_H),
    OPERATOR_ROUTINE (FC, FC, FC, SUB_FC_FC),
    OPERATOR_ROUTINE (DC, DC, DC, SUB_DC_DC),
    OPERATOR_ROUTINE (GC, GC, GC, SUB_GC_GC));


! Define the Operator Routine Table for FORTRAN multiplication.
!
OPERATOR_ROUTINE_TABLE (FORTRAN_MUL_TABLE,
    OPERATOR_ROUTINE (B, B, B, MUL_B_B),
    OPERATOR_ROUTINE (W, W, W, MUL_W_W),
    OPERATOR_ROUTINE (L, L, L, MUL_L_L),
    OPERATOR_ROUTINE (F, F, F, MUL_F_F),
    OPERATOR_ROUTINE (D, D, D, MUL_D_D),
    OPERATOR_ROUTINE (G, G, G, MUL_G_G),
    OPERATOR_ROUTINE (H, H, H, MUL_H_H),
    OPERATOR_ROUTINE (FC, FC, FC, MUL_FC_FC),
    OPERATOR_ROUTINE (DC, DC, DC, MUL_DC_DC),
    OPERATOR_ROUTINE (GC, GC, GC, MUL_GC_GC));


! Define the Operator Routine Table for FORTRAN division.
!
OPERATOR_ROUTINE_TABLE (FORTRAN_DIV_TABLE,
    OPERATOR_ROUTINE (B, B, B, DIV_B_B),
    OPERATOR_ROUTINE (W, W, W, DIV_W_W),
    OPERATOR_ROUTINE (L, L, L, DIV_L_L),
    OPERATOR_ROUTINE (F, F, F, DIV_F_F),
    OPERATOR_ROUTINE (D, D, D, DIV_D_D),
    OPERATOR_ROUTINE (G, G, G, DIV_G_G),
    OPERATOR_ROUTINE (H, H, H, DIV_H_H),
    OPERATOR_ROUTINE (FC, FC, FC, DIV_FC_FC),
    OPERATOR_ROUTINE (DC, DC, DC, DIV_DC_DC),
    OPERATOR_ROUTINE (GC, GC, GC, DIV_GC_GC));


! Define the Operator Routine Table for FORTRAN unary plus.
!
OPERATOR_ROUTINE_TABLE (FORTRAN_UNARY_PLUS_TABLE,

! The following are not language dependent types.  This is needed for DEBUG
! types.  For example, DEP/QUAD L= +1.
!
    OPERATOR_ROUTINE (P, P, P, UNARY_PLUS_P),
    OPERATOR_ROUTINE (Q, Q, Q, UNARY_PLUS_Q),
    OPERATOR_ROUTINE (O, O, O, UNARY_PLUS_O),

    OPERATOR_ROUTINE (B, B, B, UNARY_PLUS_B),
    OPERATOR_ROUTINE (W, W, W, UNARY_PLUS_W),
    OPERATOR_ROUTINE (L, L, L, UNARY_PLUS_L),
    OPERATOR_ROUTINE (F, F, F, UNARY_PLUS_F),
    OPERATOR_ROUTINE (D, D, D, UNARY_PLUS_D),
    OPERATOR_ROUTINE (G, G, G, UNARY_PLUS_G),
    OPERATOR_ROUTINE (H, H, H, UNARY_PLUS_H),
    OPERATOR_ROUTINE (FC, FC, FC, UNARY_PLUS_FC),
    OPERATOR_ROUTINE (DC, DC, DC, UNARY_PLUS_DC),
    OPERATOR_ROUTINE (GC, GC, GC, UNARY_PLUS_GC));


! Define the Operator Routine Table for FORTRAN unary minus.
!
OPERATOR_ROUTINE_TABLE (FORTRAN_UNARY_MINUS_TABLE,

! The following are not language dependent types.  This is needed for DEBUG
! types.  For example, DEP/QUAD L= +1.
!
    OPERATOR_ROUTINE (P, P, P, UNARY_MINUS_P),
    OPERATOR_ROUTINE (Q, Q, Q, UNARY_MINUS_Q),
    OPERATOR_ROUTINE (O, O, O, UNARY_MINUS_O),

    OPERATOR_ROUTINE (B, B, B, UNARY_MINUS_B),
    OPERATOR_ROUTINE (W, W, W, UNARY_MINUS_W),
    OPERATOR_ROUTINE (L, L, L, UNARY_MINUS_L),
    OPERATOR_ROUTINE (F, F, F, UNARY_MINUS_F),
    OPERATOR_ROUTINE (D, D, D, UNARY_MINUS_D),
    OPERATOR_ROUTINE (G, G, G, UNARY_MINUS_G),
    OPERATOR_ROUTINE (H, H, H, UNARY_MINUS_H),
    OPERATOR_ROUTINE (FC, FC, FC, UNARY_MINUS_FC),
    OPERATOR_ROUTINE (DC, DC, DC, UNARY_MINUS_DC),
    OPERATOR_ROUTINE (GC, GC, GC, UNARY_MINUS_GC));


! Define the Operator Routine Table for FORTRAN exponentiation.
! Exponentiation has some mixed forms. For example, if you raise a
! floating number to an integer power, you do not necessarily
! want to first convert the int to float. Instead, a special
! routine indices such as  POWER_F_L are provided to do the right thing here.
!
OPERATOR_ROUTINE_TABLE (FORTRAN_POWER_TABLE,
    OPERATOR_ROUTINE (W, W, W, POWER_W_W),
    OPERATOR_ROUTINE (L, L, L, POWER_L_L),
    OPERATOR_ROUTINE (F, L, F, POWER_F_L),
    OPERATOR_ROUTINE (D, L, D, POWER_D_L),
    OPERATOR_ROUTINE (G, L, G, POWER_G_L),
    OPERATOR_ROUTINE (H, L, H, POWER_H_L),
    OPERATOR_ROUTINE (FC, L, FC, POWER_FC_L),
    OPERATOR_ROUTINE (DC, L, DC, POWER_DC_L),
    OPERATOR_ROUTINE (GC, L, GC, POWER_GC_L),
    OPERATOR_ROUTINE (F, F, F, POWER_F_F),
    OPERATOR_ROUTINE (D, F, D, POWER_D_F),
    OPERATOR_ROUTINE (F, D, D, POWER_F_D),
    OPERATOR_ROUTINE (D, D, D, POWER_D_D),
    OPERATOR_ROUTINE (G, G, G, POWER_G_G),
    OPERATOR_ROUTINE (H, H, H, POWER_H_H),
    OPERATOR_ROUTINE (FC, FC, FC, POWER_FC_FC),
    OPERATOR_ROUTINE (DC, DC, DC, POWER_DC_DC),
    OPERATOR_ROUTINE (GC, GC, GC, POWER_GC_GC));


! Define the Operator Routine Table for FORTRAN concatenate.
! Concatenate can only be done on strings. 
!
OPERATOR_ROUTINE_TABLE (FORTRAN_CONCAT_TABLE,
    OPERATOR_ROUTINE (T, T, T, CONCAT_T_T));


! Define the Operator Routine Table for FORTRAN equal.
! This operator can be done on strings as well as all the numeric
! types.
!
OPERATOR_ROUTINE_TABLE (FORTRAN_EQL_TABLE,
    OPERATOR_ROUTINE (T, T, L, EQL_T_T),
    OPERATOR_ROUTINE (B, B, L, EQL_B_B),
    OPERATOR_ROUTINE (W, W, L, EQL_W_W),
    OPERATOR_ROUTINE (L, L, L, EQL_L_L),
    OPERATOR_ROUTINE (F, F, L, EQL_F_F),
    OPERATOR_ROUTINE (D, D, L, EQL_D_D),
    OPERATOR_ROUTINE (G, G, L, EQL_G_G),
    OPERATOR_ROUTINE (H, H, L, EQL_H_H),
    OPERATOR_ROUTINE (FC, FC, L, EQL_FC_FC),
    OPERATOR_ROUTINE (DC, DC, L, EQL_DC_DC),
    OPERATOR_ROUTINE (GC, GC, L, EQL_GC_GC));


! Define the Operator Routine Table for FORTRAN not equal.
! This operator can be done on strings as well as all the numeric types.
!
OPERATOR_ROUTINE_TABLE (FORTRAN_NEQ_TABLE,
    OPERATOR_ROUTINE (T, T, L, NEQ_T_T),
    OPERATOR_ROUTINE (B, B, L, NEQ_B_B),
    OPERATOR_ROUTINE (W, W, L, NEQ_W_W),
    OPERATOR_ROUTINE (L, L, L, NEQ_L_L),
    OPERATOR_ROUTINE (F, F, L, NEQ_F_F),
    OPERATOR_ROUTINE (D, D, L, NEQ_D_D),
    OPERATOR_ROUTINE (G, G, L, NEQ_G_G),
    OPERATOR_ROUTINE (H, H, L, NEQ_H_H),
    OPERATOR_ROUTINE (FC, FC, L, NEQ_FC_FC),
    OPERATOR_ROUTINE (DC, DC, L, NEQ_DC_DC),
    OPERATOR_ROUTINE (GC, GC, L, NEQ_GC_GC));

! In the tables for the comparison operators,
! we allow strings to be compared, and also all the numeric types except
! for the complex floats.

! Define the Operator Routine Table for FORTRAN greater than.
!
OPERATOR_ROUTINE_TABLE (FORTRAN_GTR_TABLE,
    OPERATOR_ROUTINE (T, T, L, GTR_T_T),
    OPERATOR_ROUTINE (B, B, L, GTR_B_B),
    OPERATOR_ROUTINE (W, W, L, GTR_W_W),
    OPERATOR_ROUTINE (L, L, L, GTR_L_L),
    OPERATOR_ROUTINE (F, F, L, GTR_F_F),
    OPERATOR_ROUTINE (D, D, L, GTR_D_D),
    OPERATOR_ROUTINE (G, G, L, GTR_G_G),
    OPERATOR_ROUTINE (H, H, L, GTR_H_H));


! Define the Operator Routine Table for FORTRAN greater than or equal to.
!
OPERATOR_ROUTINE_TABLE (FORTRAN_GEQ_TABLE,
    OPERATOR_ROUTINE (T, T, L, GEQ_T_T),
    OPERATOR_ROUTINE (B, B, L, GEQ_B_B),
    OPERATOR_ROUTINE (W, W, L, GEQ_W_W),
    OPERATOR_ROUTINE (L, L, L, GEQ_L_L),
    OPERATOR_ROUTINE (F, F, L, GEQ_F_F),
    OPERATOR_ROUTINE (D, D, L, GEQ_D_D),
    OPERATOR_ROUTINE (G, G, L, GEQ_G_G),
    OPERATOR_ROUTINE (H, H, L, GEQ_H_H));


! Define the Operator Routine Table for FORTRAN less than.
!
OPERATOR_ROUTINE_TABLE (FORTRAN_LSS_TABLE,
    OPERATOR_ROUTINE (T, T, L, LSS_T_T),
    OPERATOR_ROUTINE (B, B, L, LSS_B_B),
    OPERATOR_ROUTINE (W, W, L, LSS_W_W),
    OPERATOR_ROUTINE (L, L, L, LSS_L_L),
    OPERATOR_ROUTINE (F, F, L, LSS_F_F),
    OPERATOR_ROUTINE (D, D, L, LSS_D_D),
    OPERATOR_ROUTINE (G, G, L, LSS_G_G),
    OPERATOR_ROUTINE (H, H, L, LSS_H_H));


! Define the Operator Routine Table for FORTRAN less than or equal to.
!
OPERATOR_ROUTINE_TABLE (FORTRAN_LEQ_TABLE,
    OPERATOR_ROUTINE (T, T, L, LEQ_T_T),
    OPERATOR_ROUTINE (B, B, L, LEQ_B_B),
    OPERATOR_ROUTINE (W, W, L, LEQ_W_W),
    OPERATOR_ROUTINE (L, L, L, LEQ_L_L),
    OPERATOR_ROUTINE (F, F, L, LEQ_F_F),
    OPERATOR_ROUTINE (D, D, L, LEQ_D_D),
    OPERATOR_ROUTINE (G, G, L, LEQ_G_G),
    OPERATOR_ROUTINE (H, H, L, LEQ_H_H));


! The logical operators .AND., .OR., .EQV., .NEQV., .NOT. can be applied
! only to integer data types.

! Define the Operator Routine Table for FORTRAN not.
!
OPERATOR_ROUTINE_TABLE (FORTRAN_BIT_NOT_TABLE,
    OPERATOR_ROUTINE (B, B, B, BIT_NOT_B),
    OPERATOR_ROUTINE (W, W, W, BIT_NOT_W),
    OPERATOR_ROUTINE (L, L, L, BIT_NOT_L));


! Define the Operator Routine Table for FORTRAN and.
!
OPERATOR_ROUTINE_TABLE (FORTRAN_BIT_AND_TABLE,
    OPERATOR_ROUTINE (B, B, B, BIT_AND_B_B),
    OPERATOR_ROUTINE (W, W, W, BIT_AND_W_W),
    OPERATOR_ROUTINE (L, L, L, BIT_AND_L_L));


! Define the Operator Routine Table for FORTRAN or.
!
OPERATOR_ROUTINE_TABLE (FORTRAN_BIT_OR_TABLE,
    OPERATOR_ROUTINE (B, B, B, BIT_OR_B_B),
    OPERATOR_ROUTINE (W, W, W, BIT_OR_W_W),
    OPERATOR_ROUTINE (L, L, L, BIT_OR_L_L));


! Define the Operator Routine Table for FORTRAN xor, neqv
!
OPERATOR_ROUTINE_TABLE (FORTRAN_BIT_XOR_TABLE,
    OPERATOR_ROUTINE (B, B, B, BIT_XOR_B_B),
    OPERATOR_ROUTINE (W, W, W, BIT_XOR_W_W),
    OPERATOR_ROUTINE (L, L, L, BIT_XOR_L_L));


! Define the Operator Routine Table for FORTRAN eqv.
!
OPERATOR_ROUTINE_TABLE (FORTRAN_BIT_EQV_TABLE,
    OPERATOR_ROUTINE (B, B, B, BIT_EQV_B_B),
    OPERATOR_ROUTINE (W, W, W, BIT_EQV_W_W),
    OPERATOR_ROUTINE (L, L, L, BIT_EQV_L_L));


! Define the Operator Information Table for FORTRAN.
!
OPERATOR_INFO_TABLE (FORTRAN_OPINFO_TABLE,

    ! The following are arithmetic tables that accept all numeric data types,
    ! including complex. They thus go through the larger HIER1 table, and
    ! need to specify an incompatibility table.
    !
    OPERATOR_INFO_ENTRY (ADD, FORTRAN_ADD_TABLE, FORTRAN_HIER1_TABLE, 
    	FORTRAN_INCOMP_TABLE),
    OPERATOR_INFO_ENTRY (SUBTRACT, FORTRAN_SUB_TABLE, FORTRAN_HIER1_TABLE, 
    	FORTRAN_INCOMP_TABLE),
    OPERATOR_INFO_ENTRY (MULTIPLY, FORTRAN_MUL_TABLE, FORTRAN_HIER1_TABLE, 
    	FORTRAN_INCOMP_TABLE),
    OPERATOR_INFO_ENTRY (DIVIDE, FORTRAN_DIV_TABLE, FORTRAN_HIER1_TABLE, 
    	FORTRAN_INCOMP_TABLE),
    OPERATOR_INFO_ENTRY (UNARY_PLUS, FORTRAN_UNARY_PLUS_TABLE, 
    	FORTRAN_HIER1_TABLE, FORTRAN_INCOMP_TABLE),
    OPERATOR_INFO_ENTRY (UNARY_MINUS, FORTRAN_UNARY_MINUS_TABLE, 
    	FORTRAN_HIER1_TABLE, FORTRAN_INCOMP_TABLE),
    OPERATOR_INFO_ENTRY (POWER_OF, FORTRAN_POWER_TABLE, FORTRAN_HIER1_TABLE, 
    	FORTRAN_INCOMP_TABLE),

    ! Equal/Notequal can accept all numeric types including complex and
    ! thus also need the larger hierarchy table and the incompatibility
    ! table.
    !
    OPERATOR_INFO_ENTRY (EQUAL, FORTRAN_EQL_TABLE, FORTRAN_HIER1_TABLE, 
    	FORTRAN_INCOMP_TABLE),
    OPERATOR_INFO_ENTRY (NOT_EQUAL, FORTRAN_NEQ_TABLE, FORTRAN_HIER1_TABLE, 
    	FORTRAN_INCOMP_TABLE),

    ! The other relationals do not accept complex so they can get by with
    ! the smaller hierarachy table.
    !
    OPERATOR_INFO_ENTRY (GTR_THAN, FORTRAN_GTR_TABLE, FORTRAN_HIER2_TABLE, 
    	FORTRAN_INCOMP_TABLE),
    OPERATOR_INFO_ENTRY (GTR_EQUAL, FORTRAN_GEQ_TABLE, FORTRAN_HIER2_TABLE, 
    	FORTRAN_INCOMP_TABLE),
    OPERATOR_INFO_ENTRY (LSS_THAN, FORTRAN_LSS_TABLE, FORTRAN_HIER2_TABLE, 
    	FORTRAN_INCOMP_TABLE),
    OPERATOR_INFO_ENTRY (LSS_EQUAL, FORTRAN_LEQ_TABLE, FORTRAN_HIER2_TABLE, 
    	FORTRAN_INCOMP_TABLE),

    ! The logical operators accept only integer quantities so they can
    ! use the smallest hierarchy table. They also do not need an
    ! incompatibility table.
    !
    OPERATOR_INFO_ENTRY (NOT, FORTRAN_BIT_NOT_TABLE, FORTRAN_HIER3_TABLE, 
    	TABLEBASE),
    OPERATOR_INFO_ENTRY (AND, FORTRAN_BIT_AND_TABLE, FORTRAN_HIER3_TABLE, 
    	TABLEBASE),
    OPERATOR_INFO_ENTRY (OR, FORTRAN_BIT_OR_TABLE, FORTRAN_HIER3_TABLE, 
    	TABLEBASE),
    OPERATOR_INFO_ENTRY (XOR, FORTRAN_BIT_XOR_TABLE, FORTRAN_HIER3_TABLE, 
    	TABLEBASE),
    OPERATOR_INFO_ENTRY (EQV, FORTRAN_BIT_EQV_TABLE, FORTRAN_HIER3_TABLE, 
    	TABLEBASE),

    ! Concatenate accepts only string types and there are no conversions
    ! so we do not need a hierarchy table or an incompatibility table.
    !
    OPERATOR_INFO_ENTRY (CONCATENATE, FORTRAN_CONCAT_TABLE, TABLEBASE, 
    	TABLEBASE),

    ! The CONVERT operator gets called to convert subscripts to integer
    ! type and to convert expressions in FOR, IF, WHILE, REPEAT statements
    ! to integer type. It can thus use the smaller HIER3 table to specify
    ! the rules for conversion to integer.
    !
    OPERATOR_INFO_ENTRY (CONVERT, TABLEBASE, FORTRAN_HIER3_TABLE,
    	TABLEBASE),

    ! The DEPOSIT operator gets called on the DEPOSIT command. It has
    ! its own hierarchy table which allows any numeric type to be 
    ! converted to any other numeric type. The incompatibility table,
    ! however, still prevents depositing D types into G types and
    ! vice versa.
    !
    OPERATOR_INFO_ENTRY (DEPOSIT, TABLEBASE, FORTRAN_HIERD_TABLE, 
    	FORTRAN_INCOMP_TABLE),


    ! The IDENTITY operator gets called at the end of an EVALUATE command
    ! to apply the PRIM_TO_VAL routine and then apply the appropriate
    ! type mappings. This will ensure that EV BU will print as a signed integer,
    ! for example.
    ! 
    ! The identity operator does not require any tables.
    !
    OPERATOR_INFO_ENTRY (IDENTITY, TABLEBASE, TABLEBASE, TABLEBASE)
    );


!
! 	M A C R O   O P E R A T O R   I N F O R M A T I O N   T A B L E S
!
!
! This section contains the Operator Routine and Type tables needed to
! evaluate expressions in the MACRO language.
!

! Although MACRO does not contain run-time expressions in the language,
! we provide a set of operators much the same as that provided for BLISS:
!
! Arithmetic: + - * / @ MOD	(binary @ is the shift operator)
! Relational: EQL NEQ LSS LEQ GTR GEQ LSSU LEQU GTRU GEQU
! Logical: AND OR XOR EQV NOT
! Bit selection: X<p,s,e>
! Indirection: @

! Define a Type Mapping Table for MACRO.
! MACRO declares all its data to be labels, which means we get type ZI,
! even though we really want to treat it as integer. To simplify things,
! we just map ZI to integer here.
!
TYPE_MAPPING_TABLE (MACRO_MAP_TABLE,
    TYPE_GRAPH_EDGE (ZI, L),
    0);

! Define the Type Conversion Information Table for MACRO.
! We specify the Mapping Table defined above. There is no language
! specific table for conversions - we just use the rules in DBG$CVT_DX_DX
!
CONVERSION_INFO_TABLE (MACRO_CVTINFO_TABLE,
    CONVERSION_INFO_ENTRY (MACRO_MAP_TABLE, TABLEBASE));


! Define the Type Hierarchy Table. All operations are done on signed longwords.
! Thus we provide a path for all types to be converted to signed longwords.
! Note - even though we do not get dtypes B, W, BU, WU, LU from the
! MACRO DST, we provide conversion paths here, in case the user is debugging
! a module produced by another language but with language set to MACRO.
!
TYPE_HIERARCHY_TABLE (MACRO_HIER_TABLE,
    TYPE_GRAPH_EDGE (BU, WU),
    TYPE_GRAPH_EDGE (WU, LU),
    TYPE_GRAPH_EDGE (LU,  L),
    TYPE_GRAPH_EDGE (B ,  W),
    TYPE_GRAPH_EDGE (W ,  L),
    0);

! Define the Type Hierarchy Table for DEPOSIT.
! This is a circular graph which includes all types that can be obtained
! from calling PRIM_TO_VAL on a MACRO primary.  (Plus some other types as
! well - see above note).
! What this means is that
! any type is convertible to any other type on a DEPOSIT.
!
TYPE_HIERARCHY_TABLE (MACRO_HIERD_TABLE,
    TYPE_GRAPH_EDGE (B, BU),
    TYPE_GRAPH_EDGE (BU, W),
    TYPE_GRAPH_EDGE (W, WU),
    TYPE_GRAPH_EDGE (WU, L),
    TYPE_GRAPH_EDGE (L, LU),
    TYPE_GRAPH_EDGE (LU, VU),
    TYPE_GRAPH_EDGE (VU, SVU),
    TYPE_GRAPH_EDGE (SVU, SV),
    TYPE_GRAPH_EDGE (SV, V),
    TYPE_GRAPH_EDGE (V, ZI),
    TYPE_GRAPH_EDGE (ZI, ZEM),
    TYPE_GRAPH_EDGE (ZEM, B),
    0);

! All of the arithmetic, relational, and logical
! operators just operate on longword quantities.

! Define the Operator Routine Table for MACRO addition.
!
OPERATOR_ROUTINE_TABLE (MACRO_ADD_TABLE,
    OPERATOR_ROUTINE (L, L, L, ADD_L_L));

! Define the Operator Routine Table for MACRO subtraction.
!
OPERATOR_ROUTINE_TABLE(MACRO_SUB_TABLE,
    OPERATOR_ROUTINE (L, L, L, SUB_L_L));

! Define the Operator Routine Table for MACRO multiplication.
!
OPERATOR_ROUTINE_TABLE (MACRO_MUL_TABLE,
    OPERATOR_ROUTINE (L, L, L, MUL_L_L));

! Define the Operator Routine Table for MACRO Division.
!
OPERATOR_ROUTINE_TABLE (MACRO_DIV_TABLE,
    OPERATOR_ROUTINE (L, L, L, DIV_L_L));

! Define the Operator Routine Table for MACRO arithmetic shift.
!
OPERATOR_ROUTINE_TABLE (MACRO_SHIFT_TABLE,
    OPERATOR_ROUTINE (L, L, L, SHIFT_LEFT_L_L));

! Define the Operator Routine Table for MACRO modulus.
!
OPERATOR_ROUTINE_TABLE (MACRO_MOD_TABLE,
    OPERATOR_ROUTINE (L, L, L, MOD_L_L));

! Define the Operator Routine Table for MACRO Unary Plus.
!
OPERATOR_ROUTINE_TABLE (MACRO_UNARY_PLUS_TABLE,

! The following are not language dependent types.  This is needed for DEBUG
! types.  For example, DEP/QUAD L= +1.
!
    OPERATOR_ROUTINE (B, B, B, UNARY_PLUS_B),
    OPERATOR_ROUTINE (W, W, W, UNARY_PLUS_W),
    OPERATOR_ROUTINE (F, F, F, UNARY_PLUS_F),
    OPERATOR_ROUTINE (D, D, D, UNARY_PLUS_D),
    OPERATOR_ROUTINE (G, G, G, UNARY_PLUS_G),
    OPERATOR_ROUTINE (H, H, H, UNARY_PLUS_H),
    OPERATOR_ROUTINE (P, P, P, UNARY_PLUS_P),
    OPERATOR_ROUTINE (Q, Q, Q, UNARY_PLUS_Q),
    OPERATOR_ROUTINE (O, O, O, UNARY_PLUS_O),

    OPERATOR_ROUTINE (L, L, L, UNARY_PLUS_L));

! Define the Operator Routine Table for MACRO Unary Minus.
!
OPERATOR_ROUTINE_TABLE (MACRO_UNARY_MINUS_TABLE,

! The following are not language dependent types.  This is needed for DEBUG
! types.  For example, DEP/QUAD L= +1.
!
    OPERATOR_ROUTINE (B, B, B, UNARY_MINUS_B),
    OPERATOR_ROUTINE (W, W, W, UNARY_MINUS_W),
    OPERATOR_ROUTINE (F, F, F, UNARY_MINUS_F),
    OPERATOR_ROUTINE (D, D, D, UNARY_MINUS_D),
    OPERATOR_ROUTINE (G, G, G, UNARY_MINUS_G),
    OPERATOR_ROUTINE (H, H, H, UNARY_MINUS_H),
    OPERATOR_ROUTINE (P, P, P, UNARY_MINUS_P),
    OPERATOR_ROUTINE (Q, Q, Q, UNARY_MINUS_Q),
    OPERATOR_ROUTINE (O, O, O, UNARY_MINUS_O),

    OPERATOR_ROUTINE (L, L, L, UNARY_MINUS_L));

! Define the Operator Routine Table for MACRO Equal.
!
OPERATOR_ROUTINE_TABLE (MACRO_EQUAL_TABLE,
    OPERATOR_ROUTINE (L, L, L, EQL_L_L));

! Define the Operator Routine Table for MACRO Not Equal.
!
OPERATOR_ROUTINE_TABLE (MACRO_NOT_EQUAL_TABLE,
    OPERATOR_ROUTINE (L, L, L, NEQ_L_L));

! Define the Operator Routine Table for MACRO Less Than.
!
OPERATOR_ROUTINE_TABLE (MACRO_LSS_THAN_TABLE,
    OPERATOR_ROUTINE (L, L, L, LSS_L_L));

! Define the Operator Routine Table for MACRO Greater Than.
!
OPERATOR_ROUTINE_TABLE (MACRO_GTR_THAN_TABLE,
    OPERATOR_ROUTINE (L, L, L, GTR_L_L));

! Define the Operator Routine Table for MACRO Less Than or Equal.
!
OPERATOR_ROUTINE_TABLE (MACRO_LSS_EQUAL_TABLE,
    OPERATOR_ROUTINE (L, L, L, LEQ_L_L));

! Define the Operator Routine Table for MACRO Greater Than or Equal.
!
OPERATOR_ROUTINE_TABLE (MACRO_GTR_EQUAL_TABLE,
    OPERATOR_ROUTINE (L, L, L, GEQ_L_L));

! Define the Operator Routine Table for MACRO Less Than Unsigned.
!
OPERATOR_ROUTINE_TABLE (MACRO_LSSU_THAN_TABLE,
    OPERATOR_ROUTINE (L, L, L, LSS_LU_LU));

! Define the Operator Routine Table for MACRO Greater Than Unsigned.
!
OPERATOR_ROUTINE_TABLE (MACRO_GTRU_THAN_TABLE,
    OPERATOR_ROUTINE (L, L, L, GTR_LU_LU));

! Define the Operator Routine Table for MACRO Less Than or Equal Unsigned.
!
OPERATOR_ROUTINE_TABLE (MACRO_LSSU_EQUAL_TABLE,
    OPERATOR_ROUTINE (L, L, L, LEQ_LU_LU));

! Define the Operator Routine Table for MACRO Greater Than or Equal Unsigned.
!
OPERATOR_ROUTINE_TABLE (MACRO_GTRU_EQUAL_TABLE,
    OPERATOR_ROUTINE (L, L, L, GEQ_LU_LU));

! Define the Operator Routine Table for MACRO Bitwise And.
!
OPERATOR_ROUTINE_TABLE (MACRO_BIT_AND_TABLE,
    OPERATOR_ROUTINE (L, L, L, BIT_AND_L_L));

! Define the Operator Routine Table for MACRO Bitwise Or.
!
OPERATOR_ROUTINE_TABLE (MACRO_BIT_OR_TABLE,
    OPERATOR_ROUTINE (L, L, L, BIT_OR_L_L));

! Define the Operator Routine Table for MACRO Bitwise Xor.
!
OPERATOR_ROUTINE_TABLE (MACRO_BIT_XOR_TABLE,
    OPERATOR_ROUTINE (L, L, L, BIT_XOR_L_L));

! Define the Operator Routine Table for MACRO Bitwise Eqv.
!
OPERATOR_ROUTINE_TABLE (MACRO_BIT_EQV_TABLE,
    OPERATOR_ROUTINE (L, L, L, BIT_EQV_L_L));

! Define the Operator Routine Table for MACRO Bitwise Not.
!
OPERATOR_ROUTINE_TABLE (MACRO_BIT_NOT_TABLE,
    OPERATOR_ROUTINE (L, L, L, BIT_NOT_L));

! Define the Operator Routine Table for MACRO bit selection.
! Bit selection is a little unusual. It basically just modifies
! the descriptor for the address.
!
! When not combined with a fetch, X<p,s,e> is equivalent to X+p/8
! When combined with a fetch, @X<p,s,e> extracts s bits starting from
! position p, with sign extension in e is 1.
!
! See the routines DBG$BLISS_BITSELECT and DBG$BLISS_INDIRECTION,
! and also the comments in the BLISS tables.
!
OPERATOR_ROUTINE_TABLE (MACRO_BITSELECT_TABLE,
    OPERATOR_ROUTINE (L, L, L, BITSELECT));

! Define the Operator Routine Table for MACRO indirection.
! This operator is the only one that fetches its arguments, so
! it is the only one that may see all of the possible data types.
! The result of the fetch is always a longword.
!
OPERATOR_ROUTINE_TABLE (MACRO_INDIRECT_TABLE,
    OPERATOR_ROUTINE (B, B, L, INDIRECT_LU),
    OPERATOR_ROUTINE (W, W, L, INDIRECT_LU),
    OPERATOR_ROUTINE (BU,BU,L, INDIRECT_LU),
    OPERATOR_ROUTINE (WU,WU,L, INDIRECT_LU),
    OPERATOR_ROUTINE (LU,LU,L, INDIRECT_LU),
    OPERATOR_ROUTINE (V, V, L, INDIRECT_LU),
    OPERATOR_ROUTINE (VU,VU,L, INDIRECT_LU),
    OPERATOR_ROUTINE (SV,SV,L, INDIRECT_LU),
    OPERATOR_ROUTINE (SVU,SVU,L, INDIRECT_LU),
    OPERATOR_ROUTINE (L, L, L, INDIRECT_LU));

! Define the Operator Information Table for MACRO.
!
OPERATOR_INFO_TABLE (MACRO_OPINFO_TABLE,

    ! All of the arithmetic, logical, and relational operators use the
    ! same hierarchy table. The FALSE fetch flag means that, like BLISS,
    ! if the operands are not explicitly fetched, address arithmetic 
    ! is done. E.g.,
    ! EVAL A+B  will add the addresses of A and B
    ! EVAL @A+@B  will add the contents of A and B
    !    
    OPERATOR_INFO_ENTRY
    	(UNARY_PLUS, MACRO_UNARY_PLUS_TABLE, MACRO_HIER_TABLE, TABLEBASE, FALSE),
    OPERATOR_INFO_ENTRY 
    	(UNARY_MINUS, MACRO_UNARY_MINUS_TABLE, MACRO_HIER_TABLE, TABLEBASE, FALSE),
    OPERATOR_INFO_ENTRY 
    	(BIT_NOT, MACRO_BIT_NOT_TABLE, MACRO_HIER_TABLE, TABLEBASE, FALSE),
    OPERATOR_INFO_ENTRY 
    	(ADD, MACRO_ADD_TABLE, MACRO_HIER_TABLE, TABLEBASE, FALSE),
    OPERATOR_INFO_ENTRY 
    	(SUBTRACT, MACRO_SUB_TABLE, MACRO_HIER_TABLE, TABLEBASE, FALSE),
    OPERATOR_INFO_ENTRY 
    	(MULTIPLY, MACRO_MUL_TABLE, MACRO_HIER_TABLE, TABLEBASE, FALSE),
    OPERATOR_INFO_ENTRY 
    	(DIVIDE, MACRO_DIV_TABLE, MACRO_HIER_TABLE, TABLEBASE, FALSE),
    OPERATOR_INFO_ENTRY
    	(LEFT_SHIFT, MACRO_SHIFT_TABLE, MACRO_HIER_TABLE, TABLEBASE, FALSE),
    OPERATOR_INFO_ENTRY 
    	(EQUAL, MACRO_EQUAL_TABLE, MACRO_HIER_TABLE, TABLEBASE, FALSE),
    OPERATOR_INFO_ENTRY 
    	(NOT_EQUAL, MACRO_NOT_EQUAL_TABLE, MACRO_HIER_TABLE, TABLEBASE, FALSE),
    OPERATOR_INFO_ENTRY 
    	(GTR_THAN, MACRO_GTR_THAN_TABLE, MACRO_HIER_TABLE, TABLEBASE, FALSE),
    OPERATOR_INFO_ENTRY 
    	(LSS_THAN, MACRO_LSS_THAN_TABLE, MACRO_HIER_TABLE, TABLEBASE, FALSE),
    OPERATOR_INFO_ENTRY 
    	(GTR_EQUAL, MACRO_GTR_EQUAL_TABLE, MACRO_HIER_TABLE, TABLEBASE, FALSE),
    OPERATOR_INFO_ENTRY 
    	(LSS_EQUAL, MACRO_LSS_EQUAL_TABLE, MACRO_HIER_TABLE, TABLEBASE, FALSE),
    OPERATOR_INFO_ENTRY
    	(REMAINDER, MACRO_MOD_TABLE, MACRO_HIER_TABLE, TABLEBASE, FALSE),
    OPERATOR_INFO_ENTRY
    	(GTR_THAN_U, MACRO_GTRU_THAN_TABLE, MACRO_HIER_TABLE, TABLEBASE, FALSE),
    OPERATOR_INFO_ENTRY
    	(LSS_THAN_U, MACRO_LSSU_THAN_TABLE, MACRO_HIER_TABLE, TABLEBASE, FALSE),
    OPERATOR_INFO_ENTRY
    	(GTR_EQUAL_U, MACRO_GTRU_EQUAL_TABLE, MACRO_HIER_TABLE, TABLEBASE, FALSE),   
    OPERATOR_INFO_ENTRY
    	(LSS_EQUAL_U, MACRO_LSSU_EQUAL_TABLE, MACRO_HIER_TABLE, TABLEBASE, FALSE),
    OPERATOR_INFO_ENTRY 
    	(BIT_AND, MACRO_BIT_AND_TABLE, MACRO_HIER_TABLE, TABLEBASE, FALSE),
    OPERATOR_INFO_ENTRY 
    	(BIT_OR, MACRO_BIT_OR_TABLE, MACRO_HIER_TABLE, TABLEBASE, FALSE),
    OPERATOR_INFO_ENTRY 
    	(BIT_XOR, MACRO_BIT_XOR_TABLE, MACRO_HIER_TABLE, TABLEBASE, FALSE),
    OPERATOR_INFO_ENTRY 
    	(BIT_EQV, MACRO_BIT_EQV_TABLE, MACRO_HIER_TABLE, TABLEBASE, FALSE),
    OPERATOR_INFO_ENTRY
    	(BITSELECT, MACRO_BITSELECT_TABLE, MACRO_HIER_TABLE, TABLEBASE, FALSE),

    ! CONVERT gets used to convert value descriptors to integer type.
    !
    OPERATOR_INFO_ENTRY
    	(CONVERT, TABLEBASE, MACRO_HIER_TABLE, TABLEBASE, FALSE),


    ! The INDIRECT operator (@) is the only one that does a fetch, so the 
    ! fetch flag is set to TRUE for this operator.
    !
    OPERATOR_INFO_ENTRY
    	(INDIRECT, MACRO_INDIRECT_TABLE, MACRO_HIER_TABLE, TABLEBASE, TRUE),

    ! DEPOSIT uses its own hierarchy table which allows any dtype to be
    ! deposited into any other. The fetch flag is false, meaning no implicit
    ! fetch is done on the right-hand-side of the deposit.
    ! E.g,  DEP A = B  deposits the address of B into A;
    !	    DEP A = @B  deposits the contents of B into A.
    !
    OPERATOR_INFO_ENTRY
    	(DEPOSIT, TABLEBASE, MACRO_HIERD_TABLE, TABLEBASE, FALSE),

    ! The IDENTITY operator is used to turn primaries into values at
    ! the end of an evaluate command. This ensures that EVAL A will
    ! do exactly the same thing (go through the same code path)
    ! as EVAL A+0  or  EVAL +A
    !
    OPERATOR_INFO_ENTRY
    	(IDENTITY, TABLEBASE, TABLEBASE, TABLEBASE, FALSE)
    );


!
! P A S C A L  O P E R A T O R   I N F O R M A T I O N   T A B L E S
!
!
! This section contains the Operator Routine and Type tables needed to
! evaluate expressions in the PASCAL language.
!
! The following summarizes the information from the PASCAL manual.
!
! PASCAL Data Types:
!
!	. Ordinal (Scalar)
!	  .Integer (signed L, -2**31+1 to 2**31-1, unsigned L, 0 to 2**32-1) 
!	   in binary, octal, and hexdecimal.  Note: Integer value > MAXINT,
!	   that value is treated unsigned, otherwise is always treated as 
!	   signed.
!	  .Character (single character). 
!	  .Boolean (TRUE, FALSE).
!	  .Enumerated (an ordered set of constant values denoted by 1 to 65535
!	   identifiers).
!	  .Subrange (a limited portion of another ordinal type for use as a
!	   distinct type).
!
!	. Real (Scalar)
!	  F_float -0.29e-38, -1.70e38, 0.29e-38, 1.70e38
!	  D_float -0.29d-38, -1.70d38, 0.29d-38, 1.70d38
!	  G_float -0.56d-308, -0.90d308, 0.56d-308, 0.90d308
!	  H_float -0.84q-4932, -0.59q4932, 0.84q-4932, 0.59q4932
!
!	. Structured
!	  RECORD, ARRAY, VARYING OF CHAR, SET, and FILE
!	  Note: 
!	   1. use constructor to set constant value, except FILE
!	   2. an item of any structured type can be packed, except VARYING
!	  RECORD, RECORD with Variants, ARRAY, VARYING OF CHAR, SET, FILE 
!	  (of ordinal, real, structured and pointer).
!
!	. Pointer
!	  dynamic variable, NIL.
!
! Compatibility:
!	. Structural
!	. Assignment
!
! Type Conversions:
!	.Arithmetic Types
!	 INTEGER		(lowest)
!	 UNSIGNED
!	 REAL
!	 DOUBLE
!	 QUARD			(highest)
!
!	.Character Types
!	 CHAR			(lowest)
!	 PACKED ARRAY OF CHAR	
!	 VARYING OF CHAR	(highest)
!	
! Operators
!	.Arithmetic (+ - * ** / DIV REM MOD)
!	 + - * ** operate on Arithmetic Types and produces a result of the
!	   same type as the values.
!	 / operates on Arithmetic Types and produces a Real result.
!	 DIV REM MOD operate on integer and unsigned and produces an integer or
!	   unsigned result.
!
!	.Relational (= <> < <= > >=)
!	 Test Ordinal, Real, String or Set expressions and return a Boolean
!	   result.
!
!	.Logical (AND OR NOT)
!	 Operate on Boolean expressions and produce a Boolean Value.
!
!	.String	(+ = <> < <= > >=)
!	 Operate on String expressions.
!
!	.Set (+ * - = <> <= >= IN)
!	 Form the union, intersection, or difference of two sets, compares two
!	   sets, or tests an ordinal value for inclusion in a set.
!


! Define a Mapping Table for PASCAL.
! The compiler gives us a dtype of DST$K_BOOL.
! We've defined a DSC$K_DTYPE_BOOL = DST$K_BOOL. But we then
! map this dtype into our new DSC$K_DTYPE_TF. This keeps the dtype codes
! dense and also compatible across langauges.
!
TYPE_MAPPING_TABLE (PASCAL_MAP_TABLE,
    TYPE_GRAPH_EDGE (TPTR, LU),
    TYPE_GRAPH_EDGE (BOOL, TF));

! Define the Type Conversion Information Table for PASCAL.
! PASCAL has a mapping table but no language-specific table of 
! exceptions. It thus uses the DEBUG conversions given in DBG$CVT_DX_DX.
!
CONVERSION_INFO_TABLE (PASCAL_CVTINFO_TABLE,
    CONVERSION_INFO_ENTRY (PASCAL_MAP_TABLE, TABLEBASE, TRUE));

! Define the Type Hierarchy Table for PASCAL.
! This specifies that, for numeric types,
! implicit conversions always go up along
! the hierarchy
!
! B -> W -> L -> LU -> F -> D -> H
!
! If /G_FLOAT was specified then substitute G for D in the above.
! Note - the PASCAL compiler never generates B or W, but we allow
! a conversion path so that such data can be accessed if your language
! is set to PASCAL in a mixed-language environment.
!
! Text can be converted to varying text for string operations.
!
TYPE_HIERARCHY_TABLE (PASCAL_HIER_TABLE,
    TYPE_GRAPH_EDGE (T, VT),
    TYPE_GRAPH_EDGE (B, W),
    TYPE_GRAPH_EDGE (W, L),
    TYPE_GRAPH_EDGE (L, LU),
    TYPE_GRAPH_EDGE (LU, F),
    TYPE_GRAPH_EDGE (F, D),
    TYPE_GRAPH_EDGE (F, G),
    TYPE_GRAPH_EDGE (D, H),
    TYPE_GRAPH_EDGE (G, H),
    0);

! Define a smaller Type Hierarchy Table for PASCAL.
! This is a subset of the above table, and can be used for operators
! that only allow integer types.
!
TYPE_HIERARCHY_TABLE (PASCAL_HIER1_TABLE,
    TYPE_GRAPH_EDGE (B, W),
    TYPE_GRAPH_EDGE (W, L),
    TYPE_GRAPH_EDGE (L, LU),
    0);

! Define the Type Hierarchy Table for PASCAL deposit.
! This specifies what we will allow on a DEPOSIT command. That is,
! if there is a path from one dtype to another in the table below
! then we will allow the first to be deposited into the second.
!
! We have adopted similar rules as the PASCAL compiler; that is, in
! general, if the compiler allows the assignment we will allow the deposit.
! There may be a few cases where we are more permissive than the compiler.
!
TYPE_HIERARCHY_TABLE (PASCAL_HIERD_TABLE,
    TYPE_GRAPH_EDGE (L, LU),

    ! Allow integers to be deposited into any of SUBRNG, or ENUM.
    ! The type converter will call a TYPEID_CHECK routine which will
    ! give an informational if the language does not allow the 
    ! assignment. We do, however, do the operation anyway.
    !
    TYPE_GRAPH_EDGE (LU, SUBRNG),
    TYPE_GRAPH_EDGE (LU, ENUM),
    TYPE_GRAPH_EDGE (LU, SET),

    ! Allow assignments in an upward direction.
    !
    TYPE_GRAPH_EDGE (LU, F),
    TYPE_GRAPH_EDGE (F, D),
    TYPE_GRAPH_EDGE (F, G),
    TYPE_GRAPH_EDGE (D, H),
    TYPE_GRAPH_EDGE (G, H),

    ! Text can be assigned into a VT variable.
    !
    TYPE_GRAPH_EDGE (T, VT),

    ! Allow assignments of T, ENUM, and TF to subrange. Subrange
    ! can be such things as 'a'..'z', red..green, or false..true
    !
    TYPE_GRAPH_EDGE (T, SET),
    TYPE_GRAPH_EDGE (T, SUBRNG),
    TYPE_GRAPH_EDGE (ENUM, SET),
    TYPE_GRAPH_EDGE (ENUM, SUBRNG),
    TYPE_GRAPH_EDGE (TF, SET),
    TYPE_GRAPH_EDGE (TF, SUBRNG));


! Define the Type Incompatibility Table for PASCAL
! We do not allow types D and G to be mixed in arithmetic statements.
!
TYPE_INCOMP_TABLE (PASCAL_INCOMP_TABLE,
    TYPE_GRAPH_EDGE (D, G),
    0);


! Define the Operator Routine Table for PASCAL Addition.
! We can add any of the numeric types. "+" can also be applied to sets,
! in which case it means set union. It can be applied to varying strings
! and in this case it means string concatenation.
! The additional specifier for strings and sets refers to a typeid check
! routine that checks that the arguments are really of compatible type.
! See the routine DBG$PERFORM_TYPEID_CHECK in DBGEVALOP.
!
OPERATOR_ROUTINE_TABLE (PASCAL_ADD_TABLE,
    OPERATOR_ROUTINE (VT, VT, VT, CONCAT_T_T),
    OPERATOR_ROUTINE (SET, SET, SET, UNION_SET_SET, SET_SET),
    OPERATOR_ROUTINE (L, L, L, ADD_L_L),
    OPERATOR_ROUTINE (LU, LU, LU, ADD_LU_LU),
    OPERATOR_ROUTINE (F, F, F, ADD_F_F),
    OPERATOR_ROUTINE (D, D, D, ADD_D_D),
    OPERATOR_ROUTINE (G, G, G, ADD_G_G),
    OPERATOR_ROUTINE (H, H, H, ADD_H_H));


! Define the Operator Routine Table for PASCAL Subtraction.
! Subtraction can be done to any of the numeric type.
! "-" can also be applied to sets, in which case it means set difference.
! The additional specifier for sets refers to a typeid check
! routine that checks that the arguments are really of compatible type.
! See the routine DBG$PERFORM_TYPEID_CHECK in DBGEVALOP.
!
OPERATOR_ROUTINE_TABLE (PASCAL_SUB_TABLE,
    OPERATOR_ROUTINE (SET, SET, SET, DIFFERENCE_SET_SET, SET_SET),
    OPERATOR_ROUTINE (L, L, L, SUB_L_L),
    OPERATOR_ROUTINE (LU, LU, LU, SUB_LU_LU),
    OPERATOR_ROUTINE (F, F, F, SUB_F_F),
    OPERATOR_ROUTINE (D, D, D, SUB_D_D),
    OPERATOR_ROUTINE (G, G, G, SUB_G_G),
    OPERATOR_ROUTINE (H, H, H, SUB_H_H));


! Define the Operator Routine Table for PASCAL Multiplication.
! Multiplication can be applied to any of the numeric types.
! "*" can also be applied to sets, in which case it means set difference.
! The additional specifier for sets refers to a typeid check
! routine that checks that the arguments are really of compatible type.
! See the routine DBG$PERFORM_TYPEID_CHECK in DBGEVALOP.
!
OPERATOR_ROUTINE_TABLE (PASCAL_MUL_TABLE,
    OPERATOR_ROUTINE (SET, SET, SET, INTERSECT_SET_SET, SET_SET),
    OPERATOR_ROUTINE (L, L, L, MUL_L_L),
    OPERATOR_ROUTINE (LU, LU, LU, MUL_LU_LU),
    OPERATOR_ROUTINE (F, F, F, MUL_F_F),
    OPERATOR_ROUTINE (D, D, D, MUL_D_D),
    OPERATOR_ROUTINE (G, G, G, MUL_G_G),
    OPERATOR_ROUTINE (H, H, H, MUL_H_H));


! Define the Operator Routine Table for PASCAL Exponentiation.
! This can be applied to any of the numeric types.
!
OPERATOR_ROUTINE_TABLE (PASCAL_POWER_TABLE,
    OPERATOR_ROUTINE (L, L, L, POWER_L_L),
    OPERATOR_ROUTINE (LU, LU, LU, POWER_L_L),
    OPERATOR_ROUTINE (F, F, F, POWER_F_F),
    OPERATOR_ROUTINE (D, D, D, POWER_D_D),
    OPERATOR_ROUTINE (G, G, G, POWER_G_G),
    OPERATOR_ROUTINE (H, H, H, POWER_H_H));


! Define the Operator Routine Table for PASCAL Division.
! PASCAL "/" is only for floating division, "DIV" is used for integer
! division.
!
OPERATOR_ROUTINE_TABLE (PASCAL_DIV_TABLE,
    OPERATOR_ROUTINE (F, F, F, DIV_F_F),
    OPERATOR_ROUTINE (D, D, D, DIV_D_D),
    OPERATOR_ROUTINE (G, G, G, DIV_G_G),
    OPERATOR_ROUTINE (H, H, H, DIV_H_H));

! Unary Plus and Minus can be applied to any of the numeric types.

! Define the Operator Routine Table for PASCAL Unary plus.
!
OPERATOR_ROUTINE_TABLE (PASCAL_UNARY_PLUS_TABLE,

! The following are not language dependent types.  This is needed for DEBUG
! types.  For example, DEP/QUAD L= +1.
!
    OPERATOR_ROUTINE (B, B, B, UNARY_PLUS_B),
    OPERATOR_ROUTINE (W, W, W, UNARY_PLUS_W),
    OPERATOR_ROUTINE (P, P, P, UNARY_PLUS_P),
    OPERATOR_ROUTINE (Q, Q, Q, UNARY_PLUS_Q),
    OPERATOR_ROUTINE (O, O, O, UNARY_PLUS_O),

    OPERATOR_ROUTINE (L, L, L, UNARY_PLUS_L),
    OPERATOR_ROUTINE (LU, LU, LU, UNARY_PLUS_L),
    OPERATOR_ROUTINE (F, F, F, UNARY_PLUS_F),
    OPERATOR_ROUTINE (D, D, D, UNARY_PLUS_D),
    OPERATOR_ROUTINE (G, G, G, UNARY_PLUS_G),
    OPERATOR_ROUTINE (H, H, H, UNARY_PLUS_H));


! Define the Operator Routine Table for PASCAL unary minus.
!
OPERATOR_ROUTINE_TABLE (PASCAL_UNARY_MINUS_TABLE,

! The following are not language dependent types.  This is needed for DEBUG
! types.  For example, DEP/QUAD L= +1.
!
    OPERATOR_ROUTINE (B, B, B, UNARY_MINUS_B),
    OPERATOR_ROUTINE (W, W, W, UNARY_MINUS_W),
    OPERATOR_ROUTINE (P, P, P, UNARY_MINUS_P),
    OPERATOR_ROUTINE (Q, Q, Q, UNARY_MINUS_Q),
    OPERATOR_ROUTINE (O, O, O, UNARY_MINUS_O),

    OPERATOR_ROUTINE (L, L, L, UNARY_MINUS_L),
    OPERATOR_ROUTINE (LU, LU, LU, UNARY_MINUS_L),
    OPERATOR_ROUTINE (F, F, F, UNARY_MINUS_F),
    OPERATOR_ROUTINE (D, D, D, UNARY_MINUS_D),
    OPERATOR_ROUTINE (G, G, G, UNARY_MINUS_G),
    OPERATOR_ROUTINE (H, H, H, UNARY_MINUS_H));


! Define the Operator Routine Table for PASCAL Integer Division.
! PASCAL has a DIV operator for integer divide.
!
OPERATOR_ROUTINE_TABLE (PASCAL_INTDIV_TABLE,
    OPERATOR_ROUTINE (L, L, L, DIV_L_L),
    OPERATOR_ROUTINE (LU, LU, LU, DIV_LU_LU));

! MOD and REM can only be applied to integer arguments.

! Define the Operator Routine Table for PASCAL Modulus.
!
OPERATOR_ROUTINE_TABLE (PASCAL_MOD_TABLE,
    OPERATOR_ROUTINE (L, L, L, MOD_L_L),
    OPERATOR_ROUTINE (LU, LU, LU, MOD_LU_LU));


! Define the Operator Routine Table for PASCAL Remainder.
!
OPERATOR_ROUTINE_TABLE (PASCAL_REM_TABLE,
    OPERATOR_ROUTINE (L, L, L, REM_L_L),
    OPERATOR_ROUTINE (LU, LU, LU, REM_LU_LU));


! Equal/Notequal can be applied to numeric types, sets, enumeration types, 
! strings, pointers, and Booleans. 
! The SET_SET, and ENUM_ENUM parameters below
! specify a typeid check to be done to ensure that operands being compared
! are really of compatible types. See the DBG$PERFORM_TYPEID_CHECK routine
! in DBGEVALOP.

! Define the Operator Routine Table for PASCAL equal.
!
OPERATOR_ROUTINE_TABLE (PASCAL_EQL_TABLE,
    OPERATOR_ROUTINE (SET, SET, TF, EQL_SET_SET, SET_SET),
    OPERATOR_ROUTINE (TF, TF, TF, EQL_L_L),
    OPERATOR_ROUTINE (ENUM, ENUM, TF, EQL_L_L, ENUM_ENUM),
    OPERATOR_ROUTINE (VT, VT, TF, EQL_VT_VT),
    OPERATOR_ROUTINE (L, L, TF, EQL_L_L),
    OPERATOR_ROUTINE (LU, LU, TF, EQL_L_L),
    OPERATOR_ROUTINE (F, F, TF, EQL_F_F),
    OPERATOR_ROUTINE (D, D, TF, EQL_D_D),
    OPERATOR_ROUTINE (G, G, TF, EQL_G_G),
    OPERATOR_ROUTINE (H, H, TF, EQL_H_H));


! Define the Operator Routine Table for PASCAL not equal.
!
OPERATOR_ROUTINE_TABLE (PASCAL_NEQ_TABLE,
    OPERATOR_ROUTINE (SET, SET, TF, NEQ_SET_SET, SET_SET),
    OPERATOR_ROUTINE (TF, TF, TF, NEQ_L_L),
    OPERATOR_ROUTINE (ENUM, ENUM, TF, NEQ_L_L, ENUM_ENUM),
    OPERATOR_ROUTINE (VT, VT, TF, NEQ_VT_VT),
    OPERATOR_ROUTINE (L, L, TF, NEQ_L_L),
    OPERATOR_ROUTINE (LU, LU, TF, NEQ_L_L),
    OPERATOR_ROUTINE (F, F, TF, NEQ_F_F),
    OPERATOR_ROUTINE (D, D, TF, NEQ_D_D),
    OPERATOR_ROUTINE (G, G, TF, NEQ_G_G),
    OPERATOR_ROUTINE (H, H, TF, NEQ_H_H));


! Define the Operator Routine Table for PASCAL greater than or equal to.
! Greater/equal can be applied to numeric types, sets, enumeration types, 
! strings, and Booleans. 
! On sets, it means "contains".
!
OPERATOR_ROUTINE_TABLE (PASCAL_GEQ_TABLE,
    OPERATOR_ROUTINE (SET, SET, TF, GEQ_SET_SET, SET_SET),
    OPERATOR_ROUTINE (TF, TF, TF, GEQ_L_L),
    OPERATOR_ROUTINE (ENUM, ENUM, TF, GEQ_L_L, ENUM_ENUM),
    OPERATOR_ROUTINE (VT, VT, TF, GEQ_VT_VT),
    OPERATOR_ROUTINE (L, L, TF, GEQ_L_L),
    OPERATOR_ROUTINE (LU, LU, TF, GEQ_LU_LU),
    OPERATOR_ROUTINE (F, F, TF, GEQ_F_F),
    OPERATOR_ROUTINE (D, D, TF, GEQ_D_D),
    OPERATOR_ROUTINE (G, G, TF, GEQ_G_G),
    OPERATOR_ROUTINE (H, H, TF, GEQ_H_H));


! Define the Operator Routine Table for PASCAL great than.
! Greater than can be applied to numeric types, enumeration types, 
! strings, and Booleans. 
!
OPERATOR_ROUTINE_TABLE (PASCAL_GTR_TABLE,
    OPERATOR_ROUTINE (TF, TF, TF, GTR_L_L),
    OPERATOR_ROUTINE (ENUM, ENUM, TF, GTR_L_L, ENUM_ENUM),
    OPERATOR_ROUTINE (VT, VT, TF, GTR_VT_VT),
    OPERATOR_ROUTINE (L, L, TF, GTR_L_L),
    OPERATOR_ROUTINE (LU, LU, TF, GTR_LU_LU),
    OPERATOR_ROUTINE (F, F, TF, GTR_F_F),
    OPERATOR_ROUTINE (D, D, TF, GTR_D_D),
    OPERATOR_ROUTINE (G, G, TF, GTR_G_G),
    OPERATOR_ROUTINE (H, H, TF, GTR_H_H));




! Define the Operator Routine Table for PASCAL less than.
! Less than can be applied to numeric types, enumeration types, 
! strings, and Booleans. 
!
OPERATOR_ROUTINE_TABLE (PASCAL_LSS_TABLE,
    OPERATOR_ROUTINE (TF, TF, TF, LSS_L_L),
    OPERATOR_ROUTINE (ENUM, ENUM, TF, LSS_L_L, ENUM_ENUM),
    OPERATOR_ROUTINE (VT, VT, TF, LSS_VT_VT),
    OPERATOR_ROUTINE (L, L, TF, LSS_L_L),
    OPERATOR_ROUTINE (LU, LU, TF, LSS_LU_LU),
    OPERATOR_ROUTINE (F, F, TF, LSS_F_F),
    OPERATOR_ROUTINE (D, D, TF, LSS_D_D),
    OPERATOR_ROUTINE (G, G, TF, LSS_G_G),
    OPERATOR_ROUTINE (H, H, TF, LSS_H_H));


! Define the Operator Routine Table for PASCAL less than or equal to.
! Less/equal can be applied to numeric types, sets, enumeration types, 
! strings, and Booleans. 
! On sets it means "is contained in".
!
OPERATOR_ROUTINE_TABLE (PASCAL_LEQ_TABLE,
    OPERATOR_ROUTINE (SET, SET, TF, LEQ_SET_SET, SET_SET),
    OPERATOR_ROUTINE (TF, TF, TF, LEQ_L_L),
    OPERATOR_ROUTINE (ENUM, ENUM, TF, LEQ_L_L, ENUM_ENUM),
    OPERATOR_ROUTINE (VT, VT, TF, LEQ_VT_VT),
    OPERATOR_ROUTINE (L, L, TF, LEQ_L_L),
    OPERATOR_ROUTINE (LU, LU, TF, LEQ_LU_LU),
    OPERATOR_ROUTINE (F, F, TF, LEQ_F_F),
    OPERATOR_ROUTINE (D, D, TF, LEQ_D_D),
    OPERATOR_ROUTINE (G, G, TF, LEQ_G_G),
    OPERATOR_ROUTINE (H, H, TF, LEQ_H_H));


! The logical operators can only be applied to Booleans.

! Define the Operator Routine Table for PASCAL not.
!
OPERATOR_ROUTINE_TABLE (PASCAL_NOT_TABLE,
    OPERATOR_ROUTINE (TF, TF, TF, NOT_L));


! Define the Operator Routine Table for PASCAL and.
!
OPERATOR_ROUTINE_TABLE (PASCAL_AND_TABLE,
    OPERATOR_ROUTINE (TF, TF, TF, AND_L_L));


! Define the Operator Routine Table for PASCAL or.
!
OPERATOR_ROUTINE_TABLE (PASCAL_OR_TABLE,
    OPERATOR_ROUTINE (TF, TF, TF, OR_L_L));


! Define the Operator Routine Table for PASCAL Set IN.
! Sets can be composed of integers, characters, Booleans, or
! enumeration types, so we allow the inquiry whether an element
! of one of those types is in the set. The typeid_check routine
! is present to check that the type of the left arg matches the
! element type of the set.
!
OPERATOR_ROUTINE_TABLE (PASCAL_IN_TABLE,
    OPERATOR_ROUTINE (L, SET, TF, IN_SET_SET, SET_SET),
    OPERATOR_ROUTINE (LU, SET, TF, IN_SET_SET, SET_SET),
    OPERATOR_ROUTINE (T, SET, TF, IN_SET_SET, SET_SET),
    OPERATOR_ROUTINE (TF, SET, TF, IN_SET_SET, SET_SET),
    OPERATOR_ROUTINE (ENUM, SET, TF, IN_SET_SET, SET_SET));


! Define the Operator Routine Table for the PASCAL built-in function SUCC.
!
OPERATOR_ROUTINE_TABLE (PASCAL_SUCCESSOR_TABLE,
    OPERATOR_ROUTINE (ENUM, ENUM, ENUM, SUCC_ENUM, ENUM_ENUM));


! Define the Operator Routine Table for the PASCAL built-in function PRED.
!
OPERATOR_ROUTINE_TABLE (PASCAL_PREDECESSOR_TABLE,
    OPERATOR_ROUTINE (ENUM, ENUM, ENUM, PRED_ENUM, ENUM_ENUM));


! Define the Operator Information Table for PASCAL.
!
OPERATOR_INFO_TABLE (PASCAL_OPINFO_TABLE,

    ! The following arithmetic operators use the normal hierarchy table and
    ! the incompatibility table.
    !
    OPERATOR_INFO_ENTRY 
    	(ADD, PASCAL_ADD_TABLE, PASCAL_HIER_TABLE, PASCAL_INCOMP_TABLE),
    OPERATOR_INFO_ENTRY 
    	(SUBTRACT, PASCAL_SUB_TABLE, PASCAL_HIER_TABLE, PASCAL_INCOMP_TABLE),
    OPERATOR_INFO_ENTRY 
    	(MULTIPLY, PASCAL_MUL_TABLE, PASCAL_HIER_TABLE, PASCAL_INCOMP_TABLE),
    OPERATOR_INFO_ENTRY
    	(POWER_OF, PASCAL_POWER_TABLE, PASCAL_HIER_TABLE, PASCAL_INCOMP_TABLE),
    OPERATOR_INFO_ENTRY 
    	(DIVIDE, PASCAL_DIV_TABLE, PASCAL_HIER_TABLE, PASCAL_INCOMP_TABLE),
    OPERATOR_INFO_ENTRY
    	(UNARY_PLUS, PASCAL_UNARY_PLUS_TABLE, PASCAL_HIER_TABLE, PASCAL_INCOMP_TABLE),
    OPERATOR_INFO_ENTRY
    	(UNARY_MINUS, PASCAL_UNARY_MINUS_TABLE, PASCAL_HIER_TABLE, PASCAL_INCOMP_TABLE),

    ! DIV, MOD, and REM operate only on integers and thus use the smaller
    ! hierarchy table HIER1. It would also be OK to use the HIER table
    ! but a smaller table makes the code run faster.
    !
    OPERATOR_INFO_ENTRY
    	(INT_DIVIDE, PASCAL_INTDIV_TABLE, PASCAL_HIER1_TABLE, TABLEBASE),
    OPERATOR_INFO_ENTRY
    	(MODULUS, PASCAL_MOD_TABLE, PASCAL_HIER1_TABLE, TABLEBASE),
    OPERATOR_INFO_ENTRY 
    	(REMAINDER, PASCAL_REM_TABLE, PASCAL_HIER1_TABLE, PASCAL_INCOMP_TABLE),

    ! The relational operators all use the normal HIER table and the
    ! normal incompatibility table.
    !
    OPERATOR_INFO_ENTRY 
    	(EQUAL, PASCAL_EQL_TABLE, PASCAL_HIER_TABLE, PASCAL_INCOMP_TABLE),
    OPERATOR_INFO_ENTRY 
    	(NOT_EQUAL, PASCAL_NEQ_TABLE, PASCAL_HIER_TABLE, PASCAL_INCOMP_TABLE),
    OPERATOR_INFO_ENTRY 
    	(LSS_THAN, PASCAL_LSS_TABLE, PASCAL_HIER_TABLE, PASCAL_INCOMP_TABLE),
    OPERATOR_INFO_ENTRY 
    	(GTR_THAN, PASCAL_GTR_TABLE, PASCAL_HIER_TABLE, PASCAL_INCOMP_TABLE),
    OPERATOR_INFO_ENTRY 
    	(LSS_EQUAL, PASCAL_LEQ_TABLE, PASCAL_HIER_TABLE, PASCAL_INCOMP_TABLE),
    OPERATOR_INFO_ENTRY 
    	(GTR_EQUAL, PASCAL_GEQ_TABLE, PASCAL_HIER_TABLE, PASCAL_INCOMP_TABLE),

    ! The logical operators only operate on the type TF. They thus need no
    ! hierarchy table and no incompatibility table.
    !
    OPERATOR_INFO_ENTRY 
    	(AND, PASCAL_AND_TABLE, TABLEBASE, TABLEBASE),
    OPERATOR_INFO_ENTRY 
    	(OR, PASCAL_OR_TABLE, TABLEBASE, TABLEBASE),
    OPERATOR_INFO_ENTRY 
    	(NOT, PASCAL_NOT_TABLE, TABLEBASE, TABLEBASE),

    ! Set member is only allowed between the pairs given in the operator
    ! table above, with no implicit conversions.
    !
    OPERATOR_INFO_ENTRY
    	(SET_MEMBER, PASCAL_IN_TABLE, TABLEBASE, TABLEBASE),

    ! CONVERT gets used to convert subscripts to the appropriate type.
    ! We specify the HIERD table to allow the same conversions
    ! that we allow on a DEPOSIT.
    !
    OPERATOR_INFO_ENTRY
    	(CONVERT, TABLEBASE, PASCAL_HIERD_TABLE, PASCAL_INCOMP_TABLE),

    ! DEPOSIT gets used in the DEPOSIT operator. The HIERD table allows,
    ! for the most part, the same combinations that the PASCAL compiler
    ! allows on assignment.
    !
    OPERATOR_INFO_ENTRY
    	(DEPOSIT, TABLEBASE, PASCAL_HIERD_TABLE, PASCAL_INCOMP_TABLE),

    ! The identity operator is called at the end of an EVALUATE command
    ! if we still have a Primary and we need to convert it to a Value
    ! Descriptor.
    !
    OPERATOR_INFO_ENTRY
    	(IDENTITY, TABLEBASE, TABLEBASE, TABLEBASE),

    ! Built-in functions use only the tables required by the particular
    ! function.  Most need not use the hierarchy table or the incompatibility
    ! table.
    !
    OPERATOR_INFO_ENTRY
    	(SUCCESSOR, PASCAL_SUCCESSOR_TABLE, TABLEBASE, TABLEBASE),

    OPERATOR_INFO_ENTRY
    	(PREDECESSOR, PASCAL_PREDECESSOR_TABLE, TABLEBASE, TABLEBASE)
    );


!
! 	P L I   O P E R A T O R   I N F O R M A T I O N   T A B L E S
!
!
! This section contains the Operator Routine and Type tables needed to
! evaluate expressions in the PLI language.
!
! Summary of Data Types
!
! .Computational data types
!
!  .Arithmetic data types
!
!   - fix-point binary    (integers)
!     FIXED [BINARY] [(p)]           1 <=p<=7  (byte)
!                                    8 <=p<=15 (word)
!                                    16<=p<=31 (longword)
!                                    default=(31)
!     Note: all integer constants are represented as fixed-point decimal.
!
!   - fixed-point decimal (decimal integers and fractions)
!     [FIXED] DECIMAL [(p[,q])]      1<=p<=31
!                                    0<=q<=p
!                                    default=(10,0)
!
!   - floating-point      (binary and decimal)
!     FLOAT [DECIMAL/BINARY] [(p)]   
!            BINARY: default         1<=p<=113      p: no. of bits in mantissa
!                                    default=(24) 
!	     DECIMAL                 1<=p<=34       p: no. of digits in mantissa
!                                    default=(7)
!
!     floating point values    sign bits    exponent bits  fractional bits
!     .F (1<=p<=7)/(1<=p<=24)    1             8             24
!     .D (8<=p<=15)/(25<=p<=53)  1             8             53
!     .G (same as above)         1             11            53
!     .H (16<=p<=34)/(54<=p<=113)1             15            113
!
!   - pictured            (fixed-point data stored in character form)
!     PICTURE 'picture'
!
!  .Character-string data
!   CHARACTER [(n)] [VARYING]        n<=32767
!                                    default=(1)
!
!  .Bit-string data
!   BIT [(n)] [ALIGNED]              n<=32767 bits
!                                    default=(1)
!
!   PLI pads the bit-string value in the direction of least significance with
!   zeros or truncates the least significant bits from the bit-string value.
!
!   note: DECLARE ABIT BIT (10);
!         ABIT = '1011'B;
!         (high memory) 0000001101 (low memory)
!
!         'character-string'Bn is not supported.  
!	  (n is with bases other than 2. B/B1:0,1;B2:0,1,2,3
!                                        B3:0...7;B4:0...F)
!
! .Noncomputational data types
!
!  .Entry constants and variables
!  .Label constants and variables
!  .File constants and variables
!  .Pointers
!  .Areas and offsets
!
! Aggregates
! .Arrays
! .Structures
!
! Operators and Operands
! .Arithmetic  (+ - / * **)             Arithmetic operands
! .Relational  (> < ^> ^< >= <=         computational operands only
!               = ^=)                   two operands of the same type of all
! .Logical     (^ & |)                  Bit-string operands
! .Concatenation (||)                   Bit-string/Character-string
!
! Note: / should not be used to divide two fixed-point binary operand.
!
! Precedence:
! ** +(unary) -(unary) ^ * / + - || > < ^> ^< = ^= <= >= & |
!
! Conversion:
! .If any operand has BINARY, the derived base is BINARY.  Otherwise, the
!  derived base is DECIMAL.
! .If any operand has FLOAT, the derived scale is FLOAT.  Otherwise, the
!  derived base is FIXED.
!
! Conversion and arithmetic operation:
!  fixed-point decimal integer --> fixed-point binary (with zero scale) if
!  one operand is fixed-point binary.
!
!  note:
!   ev fixbin/2   (in PLI is not allowed, we perform the operation)
!   ev fixbin+2.2 (in PLI is not allowed, we perform the operation)
!  
!  fixed-point binary/fixed-point decimal --> fixed-point float.
!
!  picture --> fixed decimal with precision and scale.
!
!  Offsets and Pointers:  ptr <- ptr, offset <- offset,
!                         ptr <- offset, offset <- ptr (offset must have been
!                                                       declared with an area)
!  
! Rules for conversion of data
!
! target\source  |  Arithmetic  |  Pictured  |  Bit String  |  Character String
! -----------------------------------------------------------------------------
! Arithmetic       
! FIXED BINARY    (fixedoverflow)  Pictured     Nonnegative    Arithmetic
! FIXED DECIMAL    src p > dst q   values have  FIXED BINARY   constant
!                                  FIXED      (fixedoverflow)  (error)
! FIXED BINARY    (fixedoverflow)  DECIMAL     src value >     invalid numeric
!                  src value >     format,     2**31,          characters
!                  dst storage     followed    followed        -> dst type
!                                  the same    the same        (fixedoverflow)
! FIXED DECIMAL   (truncated)      rules as    rules as        src p is too
!                  src q > dst q   arith. ->   arith. ->       large
!                 (padded 0 right) arith.      arith.          (truncated)
!                  src q < dst q                               src q is large
!
! FLOAT           (overflow)                   null is 0       null/spaces is 0
!                  src |value| >                               
!                  dst flt value
!                 (underflow)
!                  src |value|
!                  is too small
! -----------------------------------------------------------------------------
! Bit String      takes absolute   same as     (padded 0)     character string
!                 value ->         arith.      src n <        of 0s and 1s ->
!                 FIXED BINARY                 dst n          bit-string
!                 (31)                         (truncated)    (error)
!                 (fixedoverflow)              src n >        any other char.
!                 src value >                  dst n
!                 dst value
!                 sign and q are
!                 lost during
!                 the conversion
! -----------------------------------------------------------------------------
! Char. String    FIXED BINARY ->  character   bit string ->  (padded trailing
!                 FIXED DECIMAL    string      char. string    spaces)
!                 FLOAT BINARY ->  represent.                 intmed. >
!                 FLOAT DECIMAL    is used                    dst (not varying)
!                                                             (truacted)
!                                                             dst > intmed.
! -----------------------------------------------------------------------------
! Pictured        src -> fixed decimal
! FIXED DECIMAL
!
!
!
! This section contains the Operator Routine and Type tables needed to
! evaluate expressions in the PASCAL language.
!
! 	P L I   O P E R A T O R   I N F O R M A T I O N   T A B L E S
!
!
! This section contains the Operator Routine and Type tables needed to
! evaluate expressions in the PLI language.
!
!


! Define a Type Mapping Table for PL/I.  
!
TYPE_MAPPING_TABLE (PLI_MAP_TABLE,
    TYPE_GRAPH_EDGE (PTR, L),
    TYPE_GRAPH_EDGE (TF, V),
    0);


! Define the Type Incompatibility Table for PL/I.  This prevents mixing
! D and G types in an expression or deposit.
!
TYPE_INCOMP_TABLE (PLI_INCOMP_TABLE,
    TYPE_GRAPH_EDGE (D, G),
    0);


! Define the PL/I Specific Type Conversion Table.  This allows proper
! handling of PL/I bit-strings.
!
LANG_CVT_TABLE (PLI_CVT_TABLE,
    LANG_CVT_ENTRY (PLI_CVT, ANY, V),
    LANG_CVT_ENTRY (PLI_CVT, V, ANY),
    LANG_CVT_ENTRY (PLI_CVT, ANY, VU),
    LANG_CVT_ENTRY (PLI_CVT, VU, ANY),
    LANG_CVT_ENTRY (PLI_CVT, ANY, T),
    LANG_CVT_ENTRY (PLI_CVT, T, ANY),
    LANG_CVT_ENTRY (PLI_CVT, ANY, VT),
    LANG_CVT_ENTRY (PLI_CVT, VT, ANY),
    LANG_CVT_ENTRY (PLI_CVT, PICT, ANY),
    LANG_CVT_ENTRY (PLI_CVT, ANY, PICT),
    0);


! Define the Type Conversion Information Table for PLI.  PL/I bit-strings
! require PL/I specific conversions (they are stored in reverse order).
!
CONVERSION_INFO_TABLE (PLI_CVTINFO_TABLE,
    CONVERSION_INFO_ENTRY (PLI_MAP_TABLE, PLI_CVT_TABLE));


! Define the Type Hierarchy Table for PLI.
!


! Define a Type Hierarachy Table for PLI.
!
TYPE_HIERARCHY_TABLE (PLI_HIER1_TABLE,

! The following 4 entries are made to validate the valid operand.  To
! decide the target type, there is additional code to help.
!
    TYPE_GRAPH_EDGE (T, P),
    TYPE_GRAPH_EDGE (VT, P),
    TYPE_GRAPH_EDGE (V, P),
    TYPE_GRAPH_EDGE (VU, P),

    TYPE_GRAPH_EDGE (PICT, P),
    TYPE_GRAPH_EDGE (B, W),
    TYPE_GRAPH_EDGE (W, P),
    TYPE_GRAPH_EDGE (P, L),
    TYPE_GRAPH_EDGE (L, F),
    TYPE_GRAPH_EDGE (L, FIXED),
    TYPE_GRAPH_EDGE (F, D),
    TYPE_GRAPH_EDGE (F, G),
    TYPE_GRAPH_EDGE (FIXED, H),
    TYPE_GRAPH_EDGE (D, H),
    TYPE_GRAPH_EDGE (G, H),
    0);


! Define a Type Hierarachy Table for PLI. (Relational)
!
TYPE_HIERARCHY_TABLE (PLI_HIER2_TABLE,
    TYPE_GRAPH_EDGE (VT, P),
    TYPE_GRAPH_EDGE (VT, T),
    TYPE_GRAPH_EDGE (T, P),
    TYPE_GRAPH_EDGE (VU, P),
    TYPE_GRAPH_EDGE (VU, T),
    TYPE_GRAPH_EDGE (VU, VT),
    TYPE_GRAPH_EDGE (VU, V),
    TYPE_GRAPH_EDGE (V, P),
    TYPE_GRAPH_EDGE (V, T),
    TYPE_GRAPH_EDGE (V, VT),

    TYPE_GRAPH_EDGE (PICT, P),
    TYPE_GRAPH_EDGE (B, W),
    TYPE_GRAPH_EDGE (W, P),
    TYPE_GRAPH_EDGE (P, L),
    TYPE_GRAPH_EDGE (L, F),
    TYPE_GRAPH_EDGE (L, FIXED),
    TYPE_GRAPH_EDGE (F, D),
    TYPE_GRAPH_EDGE (F, G),
    TYPE_GRAPH_EDGE (FIXED, H),
    TYPE_GRAPH_EDGE (D, H),
    TYPE_GRAPH_EDGE (G, H),
    0);


! Define a Type Hierarachy Table for PLI. (Logical)
!
TYPE_HIERARCHY_TABLE (PLI_HIER3_TABLE,
    TYPE_GRAPH_EDGE (B, V),
    TYPE_GRAPH_EDGE (W, V),
    TYPE_GRAPH_EDGE (L, V),
    TYPE_GRAPH_EDGE (P, V),
    TYPE_GRAPH_EDGE (F, V),
    TYPE_GRAPH_EDGE (D, V),
    TYPE_GRAPH_EDGE (G, V),
    TYPE_GRAPH_EDGE (H, V),
    TYPE_GRAPH_EDGE (PICT, V),
    TYPE_GRAPH_EDGE (T, V),
    TYPE_GRAPH_EDGE (VT, V),
    TYPE_GRAPH_EDGE (VU, V),
    0);


! Define a Type Hierarachy Table for PLI. (Concatination)
!
TYPE_HIERARCHY_TABLE (PLI_HIER4_TABLE,
    TYPE_GRAPH_EDGE (B, T),
    TYPE_GRAPH_EDGE (W, T),
    TYPE_GRAPH_EDGE (L, T),
    TYPE_GRAPH_EDGE (P, T),
    TYPE_GRAPH_EDGE (F, T),
    TYPE_GRAPH_EDGE (D, T),
    TYPE_GRAPH_EDGE (G, T),
    TYPE_GRAPH_EDGE (H, T),
    TYPE_GRAPH_EDGE (PICT, T),
    TYPE_GRAPH_EDGE (VT, T),
    TYPE_GRAPH_EDGE (VU, V),
    TYPE_GRAPH_EDGE (V, T),
    0);


! Define a Type Hierarachy Table for PLI. (Unary +/-)
!
TYPE_HIERARCHY_TABLE (PLI_HIER5_TABLE,
    TYPE_GRAPH_EDGE (T, P),
    TYPE_GRAPH_EDGE (VT, P),
    TYPE_GRAPH_EDGE (V, L),
    TYPE_GRAPH_EDGE (VU, L),
    TYPE_GRAPH_EDGE (PICT, P),
    TYPE_GRAPH_EDGE (B, W),
    TYPE_GRAPH_EDGE (W, P),
    TYPE_GRAPH_EDGE (P, L),
    TYPE_GRAPH_EDGE (L, F),
    TYPE_GRAPH_EDGE (L, FIXED),
    TYPE_GRAPH_EDGE (F, D),
    TYPE_GRAPH_EDGE (F, G),
    TYPE_GRAPH_EDGE (FIXED, H),
    TYPE_GRAPH_EDGE (D, H),
    TYPE_GRAPH_EDGE (G, H),
    0);


! For PLI DEPOSIT. 
!
TYPE_HIERARCHY_TABLE (PLI_HIERD_TABLE,
    TYPE_GRAPH_EDGE (B, W),
    TYPE_GRAPH_EDGE (W, L),
    TYPE_GRAPH_EDGE (L, P),
    TYPE_GRAPH_EDGE (P, FIXED),
    TYPE_GRAPH_EDGE (FIXED, F),
    TYPE_GRAPH_EDGE (F, D),
    TYPE_GRAPH_EDGE (D, G),
    TYPE_GRAPH_EDGE (G, H),
    TYPE_GRAPH_EDGE (H, V),
    TYPE_GRAPH_EDGE (V, VU),
    TYPE_GRAPH_EDGE (VU, T),
    TYPE_GRAPH_EDGE (T, VT),
    TYPE_GRAPH_EDGE (VT, PICT),
    TYPE_GRAPH_EDGE (PICT, B),
    0);


! Most of the arithmetic routines operate on two arguments of the same type.
! That type may be B, W, L, F, D, G, H, P, so we provide all of those case
! indices.
!
! Define the Operator Routine Table for PLI addition.
!
OPERATOR_ROUTINE_TABLE (PLI_ADD_TABLE,
    OPERATOR_ROUTINE (B, B, B, ADD_B_B),
    OPERATOR_ROUTINE (W, W, W, ADD_W_W),
    OPERATOR_ROUTINE (L, L, L, ADD_L_L),
    OPERATOR_ROUTINE (F, F, F, ADD_F_F),
    OPERATOR_ROUTINE (D, D, D, ADD_D_D),
    OPERATOR_ROUTINE (G, G, G, ADD_G_G),
    OPERATOR_ROUTINE (H, H, H, ADD_H_H),
    OPERATOR_ROUTINE (P, P, P, ADD_P_P),
    OPERATOR_ROUTINE (FIXED, FIXED, FIXED, ADD_FIXED_FIXED));


! Define the Operator Routine Table for PLI subtraction.
!
OPERATOR_ROUTINE_TABLE (PLI_SUB_TABLE,
    OPERATOR_ROUTINE (B, B, B, SUB_B_B),
    OPERATOR_ROUTINE (W, W, W, SUB_W_W),
    OPERATOR_ROUTINE (L, L, L, SUB_L_L),
    OPERATOR_ROUTINE (F, F, F, SUB_F_F),
    OPERATOR_ROUTINE (D, D, D, SUB_D_D),
    OPERATOR_ROUTINE (G, G, G, SUB_G_G),
    OPERATOR_ROUTINE (H, H, H, SUB_H_H),
    OPERATOR_ROUTINE (P, P, P, SUB_P_P),
    OPERATOR_ROUTINE (FIXED, FIXED, FIXED, SUB_FIXED_FIXED));


! Define the Operator Routine Table for PLI multiplication.
!
OPERATOR_ROUTINE_TABLE (PLI_MUL_TABLE,
    OPERATOR_ROUTINE (B, B, B, MUL_B_B),
    OPERATOR_ROUTINE (W, W, W, MUL_W_W),
    OPERATOR_ROUTINE (L, L, L, MUL_L_L),
    OPERATOR_ROUTINE (F, F, F, MUL_F_F),
    OPERATOR_ROUTINE (D, D, D, MUL_D_D),
    OPERATOR_ROUTINE (G, G, G, MUL_G_G),
    OPERATOR_ROUTINE (H, H, H, MUL_H_H),
    OPERATOR_ROUTINE (P, P, P, MUL_P_P),
    OPERATOR_ROUTINE (FIXED, FIXED, FIXED, MUL_FIXED_FIXED));


! Define the Operator Routine Table for PLI division.
!
OPERATOR_ROUTINE_TABLE (PLI_DIV_TABLE,
    OPERATOR_ROUTINE (B, B, B, DIV_B_B),
    OPERATOR_ROUTINE (W, W, W, DIV_W_W),
    OPERATOR_ROUTINE (L, L, L, DIV_L_L),
    OPERATOR_ROUTINE (F, F, F, DIV_F_F),
    OPERATOR_ROUTINE (D, D, D, DIV_D_D),
    OPERATOR_ROUTINE (G, G, G, DIV_G_G),
    OPERATOR_ROUTINE (H, H, H, DIV_H_H),
    OPERATOR_ROUTINE (P, P, P, DIV_P_P),
    OPERATOR_ROUTINE (FIXED, FIXED, FIXED, DIV_FIXED_FIXED));


! Define the Operator Routine Table for PLI unary plus.
!
OPERATOR_ROUTINE_TABLE (PLI_UNARY_PLUS_TABLE,

! The following are not language dependent types.  This is needed for DEBUG
! types.  For example, DEP/QUAD L= +1.
!
    OPERATOR_ROUTINE (Q, Q, Q, UNARY_PLUS_Q),
    OPERATOR_ROUTINE (O, O, O, UNARY_PLUS_O),

    OPERATOR_ROUTINE (B, B, B, UNARY_PLUS_B),
    OPERATOR_ROUTINE (W, W, W, UNARY_PLUS_W),
    OPERATOR_ROUTINE (L, L, L, UNARY_PLUS_L),
    OPERATOR_ROUTINE (F, F, F, UNARY_PLUS_F),
    OPERATOR_ROUTINE (D, D, D, UNARY_PLUS_D),
    OPERATOR_ROUTINE (G, G, G, UNARY_PLUS_G),
    OPERATOR_ROUTINE (H, H, H, UNARY_PLUS_H),
    OPERATOR_ROUTINE (P, P, P, UNARY_PLUS_P),
    OPERATOR_ROUTINE (FIXED, FIXED, FIXED, UNARY_PLUS_FIXED));


! Define the Operator Routine Table for PLI unary minus.
!
OPERATOR_ROUTINE_TABLE (PLI_UNARY_MINUS_TABLE,

! The following are not language dependent types.  This is needed for DEBUG
! types.  For example, DEP/QUAD L= +1.
!
    OPERATOR_ROUTINE (Q, Q, Q, UNARY_MINUS_Q),
    OPERATOR_ROUTINE (O, O, O, UNARY_MINUS_O),

    OPERATOR_ROUTINE (B, B, B, UNARY_MINUS_B),
    OPERATOR_ROUTINE (W, W, W, UNARY_MINUS_W),
    OPERATOR_ROUTINE (L, L, L, UNARY_MINUS_L),
    OPERATOR_ROUTINE (F, F, F, UNARY_MINUS_F),
    OPERATOR_ROUTINE (D, D, D, UNARY_MINUS_D),
    OPERATOR_ROUTINE (G, G, G, UNARY_MINUS_G),
    OPERATOR_ROUTINE (H, H, H, UNARY_MINUS_H),
    OPERATOR_ROUTINE (P, P, P, UNARY_MINUS_P),
    OPERATOR_ROUTINE (FIXED, FIXED, FIXED, UNARY_MINUS_FIXED));


! Define the Operator Routine Table for PLI exponentiation.
! Exponentiation has some mixed forms. For example, if you raise a
! floating number to an integer power, you do not necessarily
! want to first convert the int to float. Instead, a special
! routine indices such as  POWER_F_L are provided to do the right thing here.
!
OPERATOR_ROUTINE_TABLE (PLI_POWER_TABLE,
    OPERATOR_ROUTINE (F, L, F, POWER_F_L),
    OPERATOR_ROUTINE (D, L, D, POWER_D_L),
    OPERATOR_ROUTINE (G, L, G, POWER_G_L),
    OPERATOR_ROUTINE (H, L, H, POWER_H_L),
    OPERATOR_ROUTINE (F, F, F, POWER_F_F),
    OPERATOR_ROUTINE (D, F, D, POWER_D_F),
    OPERATOR_ROUTINE (F, D, D, POWER_F_D),
    OPERATOR_ROUTINE (D, D, D, POWER_D_D),
    OPERATOR_ROUTINE (G, G, G, POWER_G_G),
    OPERATOR_ROUTINE (H, H, H, POWER_H_H));


! Define the Operator Routine Table for PLI concatenation.
! Concatenate can only be done on character or bit strings.
!
OPERATOR_ROUTINE_TABLE (PLI_CONCAT_TABLE,
    OPERATOR_ROUTINE (T, T, T, CONCAT_T_T),
    OPERATOR_ROUTINE (V, V, V, CONCAT_TF_TF));


! In the tables for the comparison operators, we allow strings to be
! compared, and also all the numeric types.
!
! Define the Operator Routine Table for PLI equal.
!
OPERATOR_ROUTINE_TABLE (PLI_EQL_TABLE,
    OPERATOR_ROUTINE (B, B, TF, EQL_B_B),
    OPERATOR_ROUTINE (W, W, TF, EQL_W_W),
    OPERATOR_ROUTINE (L, L, TF, EQL_L_L),
    OPERATOR_ROUTINE (F, F, TF, EQL_F_F),
    OPERATOR_ROUTINE (D, D, TF, EQL_D_D),
    OPERATOR_ROUTINE (G, G, TF, EQL_G_G),
    OPERATOR_ROUTINE (H, H, TF, EQL_H_H),
    OPERATOR_ROUTINE (P, P, TF, EQL_P_P),
    OPERATOR_ROUTINE (FIXED, FIXED, TF, EQL_FIXED_FIXED),
    OPERATOR_ROUTINE (T, T, TF, EQL_T_T),
    OPERATOR_ROUTINE (VT, VT, TF, EQL_VT_VT),
    OPERATOR_ROUTINE (V, V, TF, EQL_TF_TF),
    OPERATOR_ROUTINE (VU, VU, TF, EQL_TF_TF),
!
! This one should have non-computational data item as well.
!
!   entry, label, file, pointer (which we map into L), area and offsets
!
    );


! Define the Operator Routine Table for PLI not equal.
!
OPERATOR_ROUTINE_TABLE (PLI_NEQ_TABLE,
    OPERATOR_ROUTINE (B, B, TF, NEQ_B_B),
    OPERATOR_ROUTINE (W, W, TF, NEQ_W_W),
    OPERATOR_ROUTINE (L, L, TF, NEQ_L_L),
    OPERATOR_ROUTINE (F, F, TF, NEQ_F_F),
    OPERATOR_ROUTINE (D, D, TF, NEQ_D_D),
    OPERATOR_ROUTINE (G, G, TF, NEQ_G_G),
    OPERATOR_ROUTINE (H, H, TF, NEQ_H_H),
    OPERATOR_ROUTINE (P, P, TF, NEQ_P_P),
    OPERATOR_ROUTINE (FIXED, FIXED, TF, NEQ_FIXED_FIXED),
    OPERATOR_ROUTINE (T, T, TF, NEQ_T_T),
    OPERATOR_ROUTINE (VT, VT, TF, NEQ_VT_VT),
    OPERATOR_ROUTINE (V, V, TF, NEQ_TF_TF),
    OPERATOR_ROUTINE (VU, VU, TF, NEQ_TF_TF),

!
! This one should have non-computational data item as well.
!
!   entry, label, file, pointer (which we map into L), area and offsets
!
    );


! Define the Operator Routine Table for PLI greater than.
!
OPERATOR_ROUTINE_TABLE (PLI_GTR_TABLE,
    OPERATOR_ROUTINE (B, B, TF, GTR_B_B),
    OPERATOR_ROUTINE (W, W, TF, GTR_W_W),
    OPERATOR_ROUTINE (L, L, TF, GTR_L_L),
    OPERATOR_ROUTINE (F, F, TF, GTR_F_F),
    OPERATOR_ROUTINE (D, D, TF, GTR_D_D),
    OPERATOR_ROUTINE (G, G, TF, GTR_G_G),
    OPERATOR_ROUTINE (H, H, TF, GTR_H_H),
    OPERATOR_ROUTINE (P, P, TF, GTR_P_P),
    OPERATOR_ROUTINE (FIXED, FIXED, TF, GTR_FIXED_FIXED),
    OPERATOR_ROUTINE (T, T, TF, GTR_T_T),
    OPERATOR_ROUTINE (VT, VT, TF, GTR_VT_VT),
    OPERATOR_ROUTINE (VU, VU, TF, GTR_TF_TF),
    OPERATOR_ROUTINE (V, V, TF, GTR_TF_TF));


! Define the Operator Routine Table for PLI greater than or equal to.
!
OPERATOR_ROUTINE_TABLE (PLI_GEQ_TABLE,
    OPERATOR_ROUTINE (B, B, TF, GEQ_B_B),
    OPERATOR_ROUTINE (W, W, TF, GEQ_W_W),
    OPERATOR_ROUTINE (L, L, TF, GEQ_L_L),
    OPERATOR_ROUTINE (F, F, TF, GEQ_F_F),
    OPERATOR_ROUTINE (D, D, TF, GEQ_D_D),
    OPERATOR_ROUTINE (G, G, TF, GEQ_G_G),
    OPERATOR_ROUTINE (H, H, TF, GEQ_H_H),
    OPERATOR_ROUTINE (P, P, TF, GEQ_P_P),
    OPERATOR_ROUTINE (FIXED, FIXED, TF, GEQ_FIXED_FIXED),
    OPERATOR_ROUTINE (T, T, TF, GEQ_T_T),
    OPERATOR_ROUTINE (VT, VT, TF, GEQ_VT_VT),
    OPERATOR_ROUTINE (VU, VU, TF, GEQ_TF_TF),
    OPERATOR_ROUTINE (V, V, TF, GEQ_TF_TF));


! Define the Operator Routine Table for PLI less than.
!
OPERATOR_ROUTINE_TABLE (PLI_LSS_TABLE,
    OPERATOR_ROUTINE (B, B, TF, LSS_B_B),
    OPERATOR_ROUTINE (W, W, TF, LSS_W_W),
    OPERATOR_ROUTINE (L, L, TF, LSS_L_L),
    OPERATOR_ROUTINE (F, F, TF, LSS_F_F),
    OPERATOR_ROUTINE (D, D, TF, LSS_D_D),
    OPERATOR_ROUTINE (G, G, TF, LSS_G_G),
    OPERATOR_ROUTINE (H, H, TF, LSS_H_H),
    OPERATOR_ROUTINE (P, P, TF, LSS_P_P),
    OPERATOR_ROUTINE (FIXED, FIXED, TF, LSS_FIXED_FIXED),
    OPERATOR_ROUTINE (T, T, TF, LSS_T_T),
    OPERATOR_ROUTINE (VT, VT, TF, LSS_VT_VT),
    OPERATOR_ROUTINE (VU, VU, TF, LSS_TF_TF),
    OPERATOR_ROUTINE (V, V, TF, LSS_TF_TF));


! Define the Operator Routine Table for PLI less than or equal to.
!
OPERATOR_ROUTINE_TABLE (PLI_LEQ_TABLE,
    OPERATOR_ROUTINE (B, B, TF, LEQ_B_B),
    OPERATOR_ROUTINE (W, W, TF, LEQ_W_W),
    OPERATOR_ROUTINE (L, L, TF, LEQ_L_L),
    OPERATOR_ROUTINE (F, F, TF, LEQ_F_F),
    OPERATOR_ROUTINE (D, D, TF, LEQ_D_D),
    OPERATOR_ROUTINE (G, G, TF, LEQ_G_G),
    OPERATOR_ROUTINE (H, H, TF, LEQ_H_H),
    OPERATOR_ROUTINE (P, P, TF, LEQ_P_P),
    OPERATOR_ROUTINE (FIXED, FIXED, TF, LEQ_FIXED_FIXED),
    OPERATOR_ROUTINE (T, T, TF, LEQ_T_T),
    OPERATOR_ROUTINE (VT, VT, TF, LEQ_VT_VT),
    OPERATOR_ROUTINE (VU, VU, TF, LEQ_TF_TF),
    OPERATOR_ROUTINE (V, V, TF, LEQ_TF_TF));


! The logical operators AND, OR, and NOT can be applied only to
! bit-string data types.
!
! Define the Operator Routine Table for PLI NOT.
!
OPERATOR_ROUTINE_TABLE (PLI_BIT_NOT_TABLE,
    OPERATOR_ROUTINE (V, V, V, BIT_NOT_TF));


! Define the Operator Routine Table for PLI AND.
!
OPERATOR_ROUTINE_TABLE (PLI_BIT_AND_TABLE,
    OPERATOR_ROUTINE (V, V, V, BIT_AND_TF));


! Define the Operator Routine Table for PLI OR.
!
OPERATOR_ROUTINE_TABLE (PLI_BIT_OR_TABLE,
    OPERATOR_ROUTINE (V, V, V, BIT_OR_TF));


! Define the Operator Information Table for PLI.
!
OPERATOR_INFO_TABLE (PLI_OPINFO_TABLE,


    ! The following are arithmetic tables that accept all numeric data types.
    ! They thus need to specify an incompatibility table.
    !
    OPERATOR_INFO_ENTRY (ADD, PLI_ADD_TABLE, PLI_HIER1_TABLE, 
    	PLI_INCOMP_TABLE),
    OPERATOR_INFO_ENTRY (SUBTRACT, PLI_SUB_TABLE, PLI_HIER1_TABLE, 
    	PLI_INCOMP_TABLE),
    OPERATOR_INFO_ENTRY (MULTIPLY, PLI_MUL_TABLE, PLI_HIER1_TABLE, 
    	PLI_INCOMP_TABLE),
    OPERATOR_INFO_ENTRY (DIVIDE, PLI_DIV_TABLE, PLI_HIER1_TABLE, 
    	PLI_INCOMP_TABLE),
    OPERATOR_INFO_ENTRY (UNARY_PLUS, PLI_UNARY_PLUS_TABLE, 
    	PLI_HIER5_TABLE, PLI_INCOMP_TABLE),
    OPERATOR_INFO_ENTRY (UNARY_MINUS, PLI_UNARY_MINUS_TABLE, 
    	PLI_HIER5_TABLE, PLI_INCOMP_TABLE),
    OPERATOR_INFO_ENTRY (POWER_OF, PLI_POWER_TABLE, PLI_HIER1_TABLE, 
    	PLI_INCOMP_TABLE),


    ! The relationals accept all numeric and bit-string types.
    ! There is no incompatibility table.
    !
    OPERATOR_INFO_ENTRY (EQUAL, PLI_EQL_TABLE, PLI_HIER2_TABLE, 
    	PLI_INCOMP_TABLE),
    OPERATOR_INFO_ENTRY (NOT_EQUAL, PLI_NEQ_TABLE, PLI_HIER2_TABLE, 
    	PLI_INCOMP_TABLE),
    OPERATOR_INFO_ENTRY (GTR_THAN, PLI_GTR_TABLE, PLI_HIER2_TABLE, 
    	PLI_INCOMP_TABLE),
    OPERATOR_INFO_ENTRY (GTR_EQUAL, PLI_GEQ_TABLE, PLI_HIER2_TABLE, 
    	PLI_INCOMP_TABLE),
    OPERATOR_INFO_ENTRY (LSS_THAN, PLI_LSS_TABLE, PLI_HIER2_TABLE, 
    	PLI_INCOMP_TABLE),
    OPERATOR_INFO_ENTRY (LSS_EQUAL, PLI_LEQ_TABLE, PLI_HIER2_TABLE, 
    	PLI_INCOMP_TABLE),


    ! The logical operators accept only bit-string quantities so they do
    ! not need a hierarchy table. They also do not need an incompatibility
    ! table.
    !
    OPERATOR_INFO_ENTRY (BIT_NOT, PLI_BIT_NOT_TABLE, PLI_HIER3_TABLE, 
    	PLI_INCOMP_TABLE),
    OPERATOR_INFO_ENTRY (BIT_AND, PLI_BIT_AND_TABLE, PLI_HIER3_TABLE, 
    	PLI_INCOMP_TABLE),
    OPERATOR_INFO_ENTRY (BIT_OR, PLI_BIT_OR_TABLE, PLI_HIER3_TABLE, 
    	PLI_INCOMP_TABLE),


    ! Concatenation allows only character or bit string operands, so it does
    ! not need a hierarchy table. The incompatibility table is not required,
    ! either.
    !
    OPERATOR_INFO_ENTRY (CONCATENATE, PLI_CONCAT_TABLE, PLI_HIER4_TABLE,
    	PLI_INCOMP_TABLE),

    OPERATOR_INFO_ENTRY (CONVERT, TABLEBASE, PLI_HIERD_TABLE,
    	TABLEBASE),


    ! The DEPOSIT operator gets called on the DEPOSIT command. It has
    ! its own hierarchy table which allows any numeric type to be 
    ! converted to any other numeric type. The incompatibility table,
    ! however, still prevents depositing D types into G types and
    ! vice versa.
    !
    OPERATOR_INFO_ENTRY (DEPOSIT, TABLEBASE, PLI_HIERD_TABLE, 
    	PLI_INCOMP_TABLE),


    ! The IDENTITY operator gets called at the end of an EVALUATE command
    ! to apply the PRIM_TO_VAL routine and then apply the appropriate
    ! type mappings. This will ensure that EV BU will print as a signed integer,
    ! for example.
    ! 
    ! The identity operator does not require any tables.
    !
    OPERATOR_INFO_ENTRY (IDENTITY, TABLEBASE, TABLEBASE, TABLEBASE)
    );


!
! 	R P G   O P E R A T O R   I N F O R M A T I O N   T A B L E S
!
!
! This section contains the Operator Routine and Type tables needed to
! evaluate expressions in the RPG language.
!
!
! The following summarizes the information in the RPG-11 manual,
! RPGV1DPLN by Treggiari.
!
! There is further documentation within the tables below, describing 
! exactly how we translate this into the DEBUG tables.
!
! RPG Data Types:
!
!	Trailing overpunched numeric (scaled)
!	Packed numeric               (scaled)
!	word			     (scaled)
!       long-word                    (scaled)
!       character
!
!       1-dimensional array of the above types
!       table data type
!       special registers which begin with an asterisk
!
! Expressions:
!	.Arithmetic
!        operator: + - * / unary+ unary-
!	 operand:  numeric literal/identifier
!
!	.Conditional (TRUE, FALSE)
!	 operator: =, NOT =, >, NOT >, <, NOT <
!	 operand:  identifier, literal, or AE
!
! Type Conversion:
!
!	W ----------------+
!       L ----------------|
!       NRO---------------|--> P  
!
!	If one of the operand is Scaled Descriptor or Packed decimal
!	data type the operation is always done in Packed Form.  The
!	operation even includes the deposit.
!
!


! Define the Type Conversion Information Table for RPG.  No rounding
! takes place in RPG.
!
CONVERSION_INFO_TABLE (RPG_CVTINFO_TABLE,
    CONVERSION_INFO_ENTRY (TABLEBASE, TABLEBASE));

! Define Type Hierarchy Table for RPG.
!
TYPE_HIERARCHY_TABLE (RPG_HIER_TABLE,
    TYPE_GRAPH_EDGE (W, P),
    TYPE_GRAPH_EDGE (L, P),
    TYPE_GRAPH_EDGE (NRO, P),
    0);

! Define the Type Hierarchy Table for RPG deposit.
!
TYPE_HIERARCHY_TABLE (RPG_HIERD_TABLE,
    TYPE_GRAPH_EDGE (W, L),
    TYPE_GRAPH_EDGE (L, NRO),
    TYPE_GRAPH_EDGE (NRO, P),
    TYPE_GRAPH_EDGE (P, W),
    0);

! Define the Operator Routine Table for RPG addition.
!
OPERATOR_ROUTINE_TABLE (RPG_ADD_TABLE,
    OPERATOR_ROUTINE (P, P, P, ADD_P_P));

! Define the Operator Routine Table for RPG subtraction.
!
OPERATOR_ROUTINE_TABLE (RPG_SUB_TABLE,
    OPERATOR_ROUTINE (P, P, P, SUB_P_P));

! Define the Operator Routine Table for RPG multiplication.
!
OPERATOR_ROUTINE_TABLE (RPG_MUL_TABLE,
    OPERATOR_ROUTINE (P, P, P, MUL_P_P));

! Define the Operator Routine Table for RPG division.
!
OPERATOR_ROUTINE_TABLE (RPG_DIV_TABLE,
    OPERATOR_ROUTINE (P, P, P, DIV_P_P));

! Define the Operator Routine Table for RPG unary plus.
!
OPERATOR_ROUTINE_TABLE (RPG_UNARY_PLUS_TABLE,

! The following are not language dependent types.  This is needed for DEBUG
! types.  For example, DEP/QUAD L= +1.
!
    OPERATOR_ROUTINE (B, B, B, UNARY_PLUS_B),
    OPERATOR_ROUTINE (W, W, W, UNARY_PLUS_W),
    OPERATOR_ROUTINE (L, L, L, UNARY_PLUS_L),
    OPERATOR_ROUTINE (F, F, F, UNARY_PLUS_F),
    OPERATOR_ROUTINE (D, D, D, UNARY_PLUS_D),
    OPERATOR_ROUTINE (G, G, G, UNARY_PLUS_G),
    OPERATOR_ROUTINE (H, H, H, UNARY_PLUS_H),
    OPERATOR_ROUTINE (Q, Q, Q, UNARY_PLUS_Q),
    OPERATOR_ROUTINE (O, O, O, UNARY_PLUS_O),

    OPERATOR_ROUTINE (P, P, P, UNARY_PLUS_P));

! Define the Operator Routine Table for RPG unary minus.
!
OPERATOR_ROUTINE_TABLE (RPG_UNARY_MINUS_TABLE,

! The following are not language dependent types.  This is needed for DEBUG
! types.  For example, DEP/QUAD L= +1.
!
    OPERATOR_ROUTINE (B, B, B, UNARY_MINUS_B),
    OPERATOR_ROUTINE (W, W, W, UNARY_MINUS_W),
    OPERATOR_ROUTINE (L, L, L, UNARY_MINUS_L),
    OPERATOR_ROUTINE (F, F, F, UNARY_MINUS_F),
    OPERATOR_ROUTINE (D, D, D, UNARY_MINUS_D),
    OPERATOR_ROUTINE (G, G, G, UNARY_MINUS_G),
    OPERATOR_ROUTINE (H, H, H, UNARY_MINUS_H),
    OPERATOR_ROUTINE (Q, Q, Q, UNARY_MINUS_Q),
    OPERATOR_ROUTINE (O, O, O, UNARY_MINUS_O),

    OPERATOR_ROUTINE (P, P, P, UNARY_MINUS_P));

! Define the Operator Routine Table for RPG =.
!
OPERATOR_ROUTINE_TABLE (RPG_EQL_TABLE,
    OPERATOR_ROUTINE (T, T, TF, EQL_T_T),
    OPERATOR_ROUTINE (P, P, TF, EQL_P_P));

! Define the Operator Routine Table for RPG NOT =.
!
OPERATOR_ROUTINE_TABLE (RPG_NEQ_TABLE,
    OPERATOR_ROUTINE (T, T, TF, NEQ_T_T),
    OPERATOR_ROUTINE (P, P, TF, NEQ_P_P));

! Define the Operator Routine Table for RPG >.
!
OPERATOR_ROUTINE_TABLE (RPG_GTR_TABLE,
    OPERATOR_ROUTINE (T, T, TF, GTR_T_T),
    OPERATOR_ROUTINE (P, P, TF, GTR_P_P));

! Define the Operator Routine Table for RPG NOT <.
!
OPERATOR_ROUTINE_TABLE (RPG_GEQ_TABLE,
    OPERATOR_ROUTINE (T, T, TF, GEQ_T_T),
    OPERATOR_ROUTINE (P, P, TF, GEQ_P_P));

! Define the Operator Routine Table for RPG <.
!
OPERATOR_ROUTINE_TABLE (RPG_LSS_TABLE,
    OPERATOR_ROUTINE (T, T, TF, LSS_T_T),
    OPERATOR_ROUTINE (P, P, TF, LSS_P_P));

! Define the Operator Routine Table for RPG NOT >.
!
OPERATOR_ROUTINE_TABLE (RPG_LEQ_TABLE,
    OPERATOR_ROUTINE (T, T, TF, LEQ_T_T),
    OPERATOR_ROUTINE (P, P, TF, LEQ_P_P));

! Define the Operator Routine Table for RPG NOT.
!
OPERATOR_ROUTINE_TABLE (RPG_NOT_TABLE,
    OPERATOR_ROUTINE (TF, TF, TF, NOT_L));

! Define the Operator Routine Table for RPG AND.
!
OPERATOR_ROUTINE_TABLE (RPG_AND_TABLE,
    OPERATOR_ROUTINE (TF, TF, TF, AND_L_L));

! Define the Operator Routine Table for RPG OR.
!
OPERATOR_ROUTINE_TABLE (RPG_OR_TABLE,
    OPERATOR_ROUTINE (TF, TF, TF, OR_L_L)); 


! Define the Operator Information Table for RPG.
!
OPERATOR_INFO_TABLE (RPG_OPINFO_TABLE,
    OPERATOR_INFO_ENTRY 
    	(ADD, RPG_ADD_TABLE, RPG_HIER_TABLE, TABLEBASE),
    OPERATOR_INFO_ENTRY
    	(SUBTRACT, RPG_SUB_TABLE, RPG_HIER_TABLE, TABLEBASE),
    OPERATOR_INFO_ENTRY
    	(MULTIPLY, RPG_MUL_TABLE, RPG_HIER_TABLE, TABLEBASE),
    OPERATOR_INFO_ENTRY
    	(DIVIDE, RPG_DIV_TABLE, RPG_HIER_TABLE, TABLEBASE),
    OPERATOR_INFO_ENTRY
    	(UNARY_PLUS, RPG_UNARY_PLUS_TABLE, RPG_HIER_TABLE, TABLEBASE),
    OPERATOR_INFO_ENTRY
    	(UNARY_MINUS, RPG_UNARY_MINUS_TABLE, RPG_HIER_TABLE, TABLEBASE),
    OPERATOR_INFO_ENTRY
    	(EQUAL, RPG_EQL_TABLE, RPG_HIER_TABLE, TABLEBASE),
    OPERATOR_INFO_ENTRY
    	(NOT_EQUAL, RPG_NEQ_TABLE, RPG_HIER_TABLE, TABLEBASE),
    OPERATOR_INFO_ENTRY
    	(GTR_THAN, RPG_GTR_TABLE, RPG_HIER_TABLE, TABLEBASE),
    OPERATOR_INFO_ENTRY
    	(GTR_EQUAL, RPG_GEQ_TABLE, RPG_HIER_TABLE, TABLEBASE),
    OPERATOR_INFO_ENTRY
    	(LSS_THAN, RPG_LSS_TABLE, RPG_HIER_TABLE, TABLEBASE),
    OPERATOR_INFO_ENTRY
    	(LSS_EQUAL, RPG_LEQ_TABLE, RPG_HIER_TABLE, TABLEBASE),
    OPERATOR_INFO_ENTRY
	(NOT, RPG_NOT_TABLE, RPG_HIER_TABLE, TABLEBASE),
    OPERATOR_INFO_ENTRY
	(AND, RPG_AND_TABLE, RPG_HIER_TABLE, TABLEBASE),
    OPERATOR_INFO_ENTRY
	(OR,  RPG_OR_TABLE,  RPG_HIER_TABLE, TABLEBASE),
    OPERATOR_INFO_ENTRY
    	(CONVERT, TABLEBASE, RPG_HIERD_TABLE, TABLEBASE),
    OPERATOR_INFO_ENTRY
    	(DEPOSIT, TABLEBASE, RPG_HIERD_TABLE, TABLEBASE),
    OPERATOR_INFO_ENTRY
    	(IDENTITY, TABLEBASE, TABLEBASE, TABLEBASE));


!
! 	U N K N O W N   O P E R A T O R   I N F O R M A T I O N   T A B L E S
!
!
! This section contains the Operator Routine and Type tables needed to
! evaluate expressions in the UNKNOWN language.
!
! The purpose of "UNKNOWN" is to provide some level of support for other
! languages by allowing SET LANG UNKNOWN. E.g., if somebody is writing a
! compiler for a language other than one which DEBUG supports such as
! JOVIAL, HAL, SIMULA, ..., they can get some level of DEBUG support
! by generating DST and saying SET LANG UNK
!
! So, the guiding principal below is to allow as many data types as possible
! and be very permissive about conversions between data types. This will 
! increase the chance of covering the allowed operations and data types
! in a given language. (Although it probably means we will be allowing
! many things that the language does not allow).
!

! Define the Type Conversion Information Table for UNKNOWN.
! There are no initial type mappings or exceptions to language-specific
! conversion rules.
!
CONVERSION_INFO_TABLE (UNKNOWN_CVTINFO_TABLE,
    CONVERSION_INFO_ENTRY (TABLEBASE, TABLEBASE));


! Define the Type Hierarchy Table for UNKNOWN.
! This allows most integer-based types to be converted to L,
! and L can then be converted up to F, D, G, and H.
! The complex types are not included here - they increase the size 
! of all the tables, and most languages do not support complex
! arithmetic, so it was not deemed worth it.
!
TYPE_HIERARCHY_TABLE (UNKNOWN_HIER_TABLE,
    TYPE_GRAPH_EDGE (TF, L),
    TYPE_GRAPH_EDGE (PTR, L),
    TYPE_GRAPH_EDGE (TPTR, L),
    TYPE_GRAPH_EDGE (ENUM, L),
    TYPE_GRAPH_EDGE (BU, WU),
    TYPE_GRAPH_EDGE (WU, LU),
    TYPE_GRAPH_EDGE (LU, L),
    TYPE_GRAPH_EDGE (B, W),
    TYPE_GRAPH_EDGE (W, L),
    TYPE_GRAPH_EDGE (L, F),
    TYPE_GRAPH_EDGE (F , D),
    TYPE_GRAPH_EDGE (F, G),
    TYPE_GRAPH_EDGE (F, FC),
    TYPE_GRAPH_EDGE (D, H),
    TYPE_GRAPH_EDGE (D, DC),
    TYPE_GRAPH_EDGE (G, H),
    TYPE_GRAPH_EDGE (G, GC),
    TYPE_GRAPH_EDGE (FC, DC),
    TYPE_GRAPH_EDGE (FC, GC),
    0);


! Define the Type Hierarchy Table for UNKNOWN deposit.
! This is a circular graph which allows any type to be deposited
! into any other (even though DBG$CVT_DX_DX may not allow all
! of the combinations.)
!
TYPE_HIERARCHY_TABLE (UNKNOWN_HIERD_TABLE,
    TYPE_GRAPH_EDGE (BU, B),
    TYPE_GRAPH_EDGE (B, WU),
    TYPE_GRAPH_EDGE (WU, W),
    TYPE_GRAPH_EDGE (W, LU),
    TYPE_GRAPH_EDGE (LU, L),
    TYPE_GRAPH_EDGE (L, F),
    TYPE_GRAPH_EDGE (F ,D),
    TYPE_GRAPH_EDGE (F, G),
    TYPE_GRAPH_EDGE (D, H),
    TYPE_GRAPH_EDGE (G, H),
    TYPE_GRAPH_EDGE (H, FC),
    TYPE_GRAPH_EDGE (FC, DC),
    TYPE_GRAPH_EDGE (FC, GC),
    TYPE_GRAPH_EDGE (DC, ENUM),
    TYPE_GRAPH_EDGE (GC, ENUM),
    TYPE_GRAPH_EDGE (ENUM, TPTR),
    TYPE_GRAPH_EDGE (TPTR, PTR),
    TYPE_GRAPH_EDGE (PTR, TF),
    TYPE_GRAPH_EDGE (TF, BU),
    0);

! Define the Type Incompatibility Table for language UNKNOWN.
! D and G arithmetic is always incompatible.
!
TYPE_INCOMP_TABLE (UNKNOWN_INCOMP_TABLE,
    TYPE_GRAPH_EDGE (D, G),
    TYPE_GRAPH_EDGE (D, GC),
    TYPE_GRAPH_EDGE (G, DC),
    TYPE_GRAPH_EDGE (DC, GC),
    0);


! Allow arithmetic on any of the numeric types.
! Other types (PTR, TPTR, ENUM, unsigned types) can be converted to L before doing
! any arithmetic.

! Define the Operator Routine Table for UNKNOWN addition.
!
OPERATOR_ROUTINE_TABLE (UNKNOWN_ADD_TABLE,
    OPERATOR_ROUTINE (L, L, L, ADD_L_L),
    OPERATOR_ROUTINE (F, F, F, ADD_F_F),
    OPERATOR_ROUTINE (D, D, D, ADD_D_D),
    OPERATOR_ROUTINE (G, G, G, ADD_G_G),
    OPERATOR_ROUTINE (H, H, H, ADD_H_H),
    OPERATOR_ROUTINE (FC, FC, FC, ADD_FC_FC),
    OPERATOR_ROUTINE (DC, DC, DC, ADD_DC_DC),
    OPERATOR_ROUTINE (GC, GC, GC, ADD_GC_GC));


! Define the Operator Routine Table for UNKNOWN subtraction.
!
OPERATOR_ROUTINE_TABLE (UNKNOWN_SUB_TABLE,
    OPERATOR_ROUTINE (L, L, L, SUB_L_L),
    OPERATOR_ROUTINE (F, F, F, SUB_F_F),
    OPERATOR_ROUTINE (D, D, D, SUB_D_D),
    OPERATOR_ROUTINE (G, G, G, SUB_G_G),
    OPERATOR_ROUTINE (H, H, H, SUB_H_H),
    OPERATOR_ROUTINE (FC, FC, FC, SUB_FC_FC),
    OPERATOR_ROUTINE (DC, DC, DC, SUB_DC_DC),
    OPERATOR_ROUTINE (GC, GC, GC, SUB_GC_GC));


! Define the Operator Routine Table for UNKNOWN multiplication.
!
OPERATOR_ROUTINE_TABLE (UNKNOWN_MUL_TABLE,
    OPERATOR_ROUTINE (L, L, L, MUL_L_L),
    OPERATOR_ROUTINE (F, F, F, MUL_F_F),
    OPERATOR_ROUTINE (D, D, D, MUL_D_D),
    OPERATOR_ROUTINE (G, G, G, MUL_G_G),
    OPERATOR_ROUTINE (H, H, H, MUL_H_H),
    OPERATOR_ROUTINE (FC, FC, FC, MUL_FC_FC),
    OPERATOR_ROUTINE (DC, DC, DC, MUL_DC_DC),
    OPERATOR_ROUTINE (GC, GC, GC, MUL_GC_GC));


! Define the Operator Routine Table for UNKNOWN division.
!
OPERATOR_ROUTINE_TABLE (UNKNOWN_DIV_TABLE,
    OPERATOR_ROUTINE (L, L, L, DIV_L_L),
    OPERATOR_ROUTINE (F, F, F, DIV_F_F),
    OPERATOR_ROUTINE (D, D, D, DIV_D_D),
    OPERATOR_ROUTINE (G, G, G, DIV_G_G),
    OPERATOR_ROUTINE (H, H, H, DIV_H_H),
    OPERATOR_ROUTINE (FC, FC, FC, DIV_FC_FC),
    OPERATOR_ROUTINE (DC, DC, DC, DIV_DC_DC),
    OPERATOR_ROUTINE (GC, GC, GC, DIV_GC_GC));


! Define the Operator Routine Table for UNKNOWN unary plus.
!
OPERATOR_ROUTINE_TABLE (UNKNOWN_UNARY_PLUS_TABLE,

! The following are not language dependent types.  This is needed for DEBUG
! types.  For example, DEP/QUAD L= +1.
!
    OPERATOR_ROUTINE (B, B, B, UNARY_PLUS_B),
    OPERATOR_ROUTINE (W, W, W, UNARY_PLUS_W),
    OPERATOR_ROUTINE (P, P, P, UNARY_PLUS_P),
    OPERATOR_ROUTINE (Q, Q, Q, UNARY_PLUS_Q),
    OPERATOR_ROUTINE (O, O, O, UNARY_PLUS_O),

    OPERATOR_ROUTINE (L, L, L, UNARY_PLUS_L),
    OPERATOR_ROUTINE (F, F, F, UNARY_PLUS_F),
    OPERATOR_ROUTINE (D, D, D, UNARY_PLUS_D),
    OPERATOR_ROUTINE (G, G, G, UNARY_PLUS_G),
    OPERATOR_ROUTINE (H, H, H, UNARY_PLUS_H),
    OPERATOR_ROUTINE (FC, FC, FC, UNARY_PLUS_FC),
    OPERATOR_ROUTINE (DC, DC, DC, UNARY_PLUS_DC),
    OPERATOR_ROUTINE (GC, GC, GC, UNARY_PLUS_GC));


! Define the Operator Routine Table for UNKNOWN unary minus.
!
OPERATOR_ROUTINE_TABLE (UNKNOWN_UNARY_MINUS_TABLE,

! The following are not language dependent types.  This is needed for DEBUG
! types.  For example, DEP/QUAD L= +1.
!
    OPERATOR_ROUTINE (B, B, B, UNARY_MINUS_B),
    OPERATOR_ROUTINE (W, W, W, UNARY_MINUS_W),
    OPERATOR_ROUTINE (P, P, P, UNARY_MINUS_P),
    OPERATOR_ROUTINE (Q, Q, Q, UNARY_MINUS_Q),
    OPERATOR_ROUTINE (O, O, O, UNARY_MINUS_O),

    OPERATOR_ROUTINE (L, L, L, UNARY_MINUS_L),
    OPERATOR_ROUTINE (F, F, F, UNARY_MINUS_F),
    OPERATOR_ROUTINE (D, D, D, UNARY_MINUS_D),
    OPERATOR_ROUTINE (G, G, G, UNARY_MINUS_G),
    OPERATOR_ROUTINE (H, H, H, UNARY_MINUS_H),
    OPERATOR_ROUTINE (FC, FC, FC, UNARY_MINUS_FC),
    OPERATOR_ROUTINE (DC, DC, DC, UNARY_MINUS_DC),
    OPERATOR_ROUTINE (GC, GC, GC, UNARY_MINUS_GC));


! Define the Operator Routine Table for UNKNOWN exponentiation.
! We special-case the mixed cases F**L, D**L, G**L, and H**L because
! we do not want the exponent converted to float there. Note - this
! is the same table as for FORTRAN.
!
OPERATOR_ROUTINE_TABLE (UNKNOWN_POWER_TABLE,
    OPERATOR_ROUTINE (W, W, W, POWER_W_W),
    OPERATOR_ROUTINE (L, L, L, POWER_L_L),
    OPERATOR_ROUTINE (F, L, F, POWER_F_L),
    OPERATOR_ROUTINE (D, L, D, POWER_D_L),
    OPERATOR_ROUTINE (G, L, G, POWER_G_L),
    OPERATOR_ROUTINE (H, L, H, POWER_H_L),
    OPERATOR_ROUTINE (FC, L, FC, POWER_FC_L),
    OPERATOR_ROUTINE (DC, L, DC, POWER_DC_L),
    OPERATOR_ROUTINE (GC, L, GC, POWER_GC_L),
    OPERATOR_ROUTINE (F, F, F, POWER_F_F),
    OPERATOR_ROUTINE (D, F, D, POWER_D_F),
    OPERATOR_ROUTINE (F, D, D, POWER_F_D),
    OPERATOR_ROUTINE (D, D, D, POWER_D_D),
    OPERATOR_ROUTINE (G, G, G, POWER_G_G),
    OPERATOR_ROUTINE (H, H, H, POWER_H_H),
    OPERATOR_ROUTINE (FC, FC, FC, POWER_FC_FC),
    OPERATOR_ROUTINE (DC, DC, DC, POWER_DC_DC),
    OPERATOR_ROUTINE (GC, GC, GC, POWER_GC_GC));
    

! The relationals are defined on strings and on numeric types.
! We do not specially handle types like ENUM, TPTR, and so on, as
! in PASCAL - here we just convert them to integer and do integer
! comparison. The intent is to be looser about type-checking
! than is PASCAL.

! Define the Operator Routine Table for UNKNOWN equal.
!
OPERATOR_ROUTINE_TABLE (UNKNOWN_EQL_TABLE,
    OPERATOR_ROUTINE (T, T, TF, EQL_T_T),
    OPERATOR_ROUTINE (L, L, TF, EQL_L_L),    
    OPERATOR_ROUTINE (F, F, TF, EQL_F_F),
    OPERATOR_ROUTINE (D, D, TF, EQL_D_D),
    OPERATOR_ROUTINE (G, G, TF, EQL_G_G),
    OPERATOR_ROUTINE (H, H, TF, EQL_H_H),
    OPERATOR_ROUTINE (FC, FC, TF, EQL_FC_FC),
    OPERATOR_ROUTINE (DC, DC, TF, EQL_DC_DC),
    OPERATOR_ROUTINE (GC, GC, TF, EQL_GC_GC));

! Define the Operator Routine Table for UNKNOWN not-equal.
!
OPERATOR_ROUTINE_TABLE (UNKNOWN_NEQ_TABLE,
    OPERATOR_ROUTINE (T, T, TF, NEQ_T_T),
    OPERATOR_ROUTINE (L, L, TF, NEQ_L_L),    
    OPERATOR_ROUTINE (F, F, TF, NEQ_F_F),
    OPERATOR_ROUTINE (D, D, TF, NEQ_D_D),
    OPERATOR_ROUTINE (G, G, TF, NEQ_G_G),
    OPERATOR_ROUTINE (H, H, TF, NEQ_H_H),
    OPERATOR_ROUTINE (FC, FC, TF, NEQ_FC_FC),
    OPERATOR_ROUTINE (DC, DC, TF, NEQ_DC_DC),
    OPERATOR_ROUTINE (GC, GC, TF, NEQ_GC_GC));


! Define the Operator Routine Table for UNKNOWN less than.
!
OPERATOR_ROUTINE_TABLE (UNKNOWN_LSS_THAN_TABLE,
    OPERATOR_ROUTINE (T, T, TF, LSS_T_T),
    OPERATOR_ROUTINE (L, L, TF, LSS_L_L),    
    OPERATOR_ROUTINE (F, F, TF, LSS_F_F),
    OPERATOR_ROUTINE (D, D, TF, LSS_D_D),
    OPERATOR_ROUTINE (G, G, TF, LSS_G_G),
    OPERATOR_ROUTINE (H, H, TF, LSS_H_H));

! Define the Operator Routine Table for UNKNOWN greater than.
!
OPERATOR_ROUTINE_TABLE (UNKNOWN_GTR_THAN_TABLE,
    OPERATOR_ROUTINE (T, T, TF, GTR_T_T),
    OPERATOR_ROUTINE (L, L, TF, GTR_L_L),    
    OPERATOR_ROUTINE (F, F, TF, GTR_F_F),
    OPERATOR_ROUTINE (D, D, TF, GTR_D_D),
    OPERATOR_ROUTINE (G, G, TF, GTR_G_G),
    OPERATOR_ROUTINE (H, H, TF, GTR_H_H));


! Define the Operator Routine Table for UNKNOWN less than or equal.
!
OPERATOR_ROUTINE_TABLE (UNKNOWN_LEQ_TABLE,
    OPERATOR_ROUTINE (T, T, TF, LEQ_T_T),
    OPERATOR_ROUTINE (L, L, TF, LEQ_L_L),    
    OPERATOR_ROUTINE (F, F, TF, LEQ_F_F),
    OPERATOR_ROUTINE (D, D, TF, LEQ_D_D),
    OPERATOR_ROUTINE (G, G, TF, LEQ_G_G),
    OPERATOR_ROUTINE (H, H, TF, LEQ_H_H));

! Define the Operator Routine Table for UNKNOWN greater than or equal.
!
OPERATOR_ROUTINE_TABLE (UNKNOWN_GEQ_TABLE,
    OPERATOR_ROUTINE (T, T, TF, GEQ_T_T),
    OPERATOR_ROUTINE (L, L, TF, GEQ_L_L),    
    OPERATOR_ROUTINE (F, F, TF, GEQ_F_F),
    OPERATOR_ROUTINE (D, D, TF, GEQ_D_D),
    OPERATOR_ROUTINE (G, G, TF, GEQ_G_G),
    OPERATOR_ROUTINE (H, H, TF, GEQ_H_H));

! The logical operators AND, OR, NOT, EQV and XOR are defined only
! on integers. Other types such as TF can be converted to Boolean.

! Define the Operator Routine Table for UNKNOWN AND.
!
OPERATOR_ROUTINE_TABLE (UNKNOWN_AND_TABLE,
    OPERATOR_ROUTINE (L, L, L, BIT_AND_L_L));

! Define the Operator Routine Table for UNKNOWN OR.
!
OPERATOR_ROUTINE_TABLE (UNKNOWN_OR_TABLE,
    OPERATOR_ROUTINE (L, L, L, BIT_OR_L_L));

! Define the Operator Routine Table for UNKNOWN XOR.
!
OPERATOR_ROUTINE_TABLE (UNKNOWN_XOR_TABLE,
    OPERATOR_ROUTINE (L, L, L, BIT_XOR_L_L));

! Define the Operator Routine Table for UNKNOWN EQV.
!
OPERATOR_ROUTINE_TABLE (UNKNOWN_EQV_TABLE,
    OPERATOR_ROUTINE (L, L, L, BIT_EQV_L_L));

! Define the Operator Routine Table for UNKNOWN NOT.
!
OPERATOR_ROUTINE_TABLE (UNKNOWN_NOT_TABLE,
    OPERATOR_ROUTINE (L, L, L, BIT_NOT_L));

! Define the Operator Routine Table for UNKNOWN concatenate.
!
OPERATOR_ROUTINE_TABLE (UNKNOWN_CONCATENATE_TABLE,
    OPERATOR_ROUTINE (T, T, T, CONCAT_T_T));

! Define the Operator Information Table for UNKNOWN.
!
OPERATOR_INFO_TABLE (UNKNOWN_OPINFO_TABLE,

    ! All of the arithmetic, logical, and relational operators use
    ! the same hierarchy table and the same incompatibility table.

    ! Arithmetic.
    !
    OPERATOR_INFO_ENTRY 
    	(ADD, UNKNOWN_ADD_TABLE, 
    	 UNKNOWN_HIER_TABLE, UNKNOWN_INCOMP_TABLE),
    OPERATOR_INFO_ENTRY 
    	(SUBTRACT, UNKNOWN_SUB_TABLE, 
    	 UNKNOWN_HIER_TABLE, UNKNOWN_INCOMP_TABLE),
    OPERATOR_INFO_ENTRY 
    	(MULTIPLY, UNKNOWN_MUL_TABLE, 
    	 UNKNOWN_HIER_TABLE, UNKNOWN_INCOMP_TABLE),
    OPERATOR_INFO_ENTRY 
    	(DIVIDE, UNKNOWN_DIV_TABLE, 
    	 UNKNOWN_HIER_TABLE, UNKNOWN_INCOMP_TABLE),
    OPERATOR_INFO_ENTRY 
    	(UNARY_PLUS, UNKNOWN_UNARY_PLUS_TABLE, 
    	 UNKNOWN_HIER_TABLE, UNKNOWN_INCOMP_TABLE),
    OPERATOR_INFO_ENTRY 
    	(UNARY_MINUS, UNKNOWN_UNARY_MINUS_TABLE, 
    	 UNKNOWN_HIER_TABLE, UNKNOWN_INCOMP_TABLE),
    OPERATOR_INFO_ENTRY 
    	(POWER_OF, UNKNOWN_POWER_TABLE, 
    	 UNKNOWN_HIER_TABLE, UNKNOWN_INCOMP_TABLE),

    ! Relationals
    !
    OPERATOR_INFO_ENTRY 
    	(EQUAL, UNKNOWN_EQL_TABLE, 
    	 UNKNOWN_HIER_TABLE, UNKNOWN_INCOMP_TABLE),
    OPERATOR_INFO_ENTRY 
    	(NOT_EQUAL, UNKNOWN_NEQ_TABLE, 
    	 UNKNOWN_HIER_TABLE, UNKNOWN_INCOMP_TABLE),
    OPERATOR_INFO_ENTRY 
    	(LSS_THAN, UNKNOWN_LSS_THAN_TABLE, 
    	 UNKNOWN_HIER_TABLE, UNKNOWN_INCOMP_TABLE),
    OPERATOR_INFO_ENTRY 
    	(GTR_THAN, UNKNOWN_GTR_THAN_TABLE, 
    	 UNKNOWN_HIER_TABLE, UNKNOWN_INCOMP_TABLE),
    OPERATOR_INFO_ENTRY 
    	(LSS_EQUAL, UNKNOWN_LEQ_TABLE, 
    	 UNKNOWN_HIER_TABLE, UNKNOWN_INCOMP_TABLE),
    OPERATOR_INFO_ENTRY 
    	(GTR_EQUAL, UNKNOWN_GEQ_TABLE, 
    	 UNKNOWN_HIER_TABLE, UNKNOWN_INCOMP_TABLE),

    ! Logicals.
    !
    OPERATOR_INFO_ENTRY 
    	(AND, UNKNOWN_AND_TABLE, 
    	 UNKNOWN_HIER_TABLE, UNKNOWN_INCOMP_TABLE),
    OPERATOR_INFO_ENTRY 
    	(OR, UNKNOWN_OR_TABLE, 
    	 UNKNOWN_HIER_TABLE, UNKNOWN_INCOMP_TABLE),
    OPERATOR_INFO_ENTRY 
    	(XOR, UNKNOWN_XOR_TABLE, 
    	 UNKNOWN_HIER_TABLE, UNKNOWN_INCOMP_TABLE),
    OPERATOR_INFO_ENTRY 
    	(EQV, UNKNOWN_EQV_TABLE, 
    	 UNKNOWN_HIER_TABLE, UNKNOWN_INCOMP_TABLE),
    OPERATOR_INFO_ENTRY 
    	(NOT, UNKNOWN_NOT_TABLE, 
    	 UNKNOWN_HIER_TABLE, UNKNOWN_INCOMP_TABLE),

    ! String operations.
    !
    OPERATOR_INFO_ENTRY 
    	(CONCATENATE, UNKNOWN_CONCATENATE_TABLE,
    	 UNKNOWN_HIER_TABLE, UNKNOWN_INCOMP_TABLE),

    ! CONVERT is used for things like converting subscripts.
    !
    OPERATOR_INFO_ENTRY
    	(CONVERT, TABLEBASE, UNKNOWN_HIER_TABLE, UNKNOWN_INCOMP_TABLE),

    ! DEPOSIT is used in the DEPOSIT command.
    !
    OPERATOR_INFO_ENTRY
    	(DEPOSIT, TABLEBASE, UNKNOWN_HIERD_TABLE, UNKNOWN_INCOMP_TABLE),

    ! IDENTITY is used at the end of an EVALUATE to turn the primary
    ! into a value descriptor.
    !
    OPERATOR_INFO_ENTRY
    	(IDENTITY, TABLEBASE, TABLEBASE, TABLEBASE));


! The following data structure holds a type pair in a word and is used 
! to search for the type pair in the Operator Routine Table.
!
FIELD
    TYPE_PAIR_FLDS =
    	SET
    	B$_RIGHT_TYPE = [0,B0_],
    	B$_LEFT_TYPE  = [0,B1_],
    	W$_TYPE_PAIR  = [0,W0_]
    	TES;

MACRO
    TYPE$PAIR = BLOCK [1, WORD] FIELD (TYPE_PAIR_FLDS) %;


ROUTINE AAA_DUMMY =
!
! FUNCTION
!	This routine just causes the above tables to be dumped in the
!	listing.
!
    BEGIN
    0
    END;	

GLOBAL ROUTINE DBG$BLISS_BITSELECT (OPERATOR, ARG_DESC, RESULT_DESC): NOVALUE =
!
! FUNCTION
!
!	This routine is called from DBG$PERFORM_OPERATOR to do the
!	BLISS bit select operation (e.g, X<p,s,e>). It receives
!	the operator token containing the p,s,e information and
!	a pointer to the descriptor for X. It builds a new descriptor with
!	the new bit offset, length, and sign extension information.
!
! INPUTS
!
!	OPERATOR	- points to the operator token for the BITSELECT operator.
!			  The p,s,e information can be extracted from the token
!			  in the BIT_OFFSET, BIT_LENGTH, and SGNEXT fields.
!	ARG_DESC	- points to the VMS descriptor representing the argument
!			  of the bit-select operator.
!	RESULT_DESC	- points to the VMS descriptor representing the result.
!
! OUTPUTS
!
!	The result VMS descriptor is filled in.
!	No value is returned.
!	
    BEGIN
    MAP
    	OPERATOR	: REF TOKEN$ENTRY,
    	ARG_DESC	: REF DBG$STG_DESC,
    	RESULT_DESC	: REF DBG$STG_DESC;

    LOCAL
    	ADDRESS,		! The address of the data
       	BIT_OFFSET,		! New bit offset from byte address
    	DTYPE;			! New dtype

    ! Obtain the address.
    !
    ADDRESS = ..ARG_DESC[DSC$A_POINTER];

    ! Obtain the bit offsets.
    !
    BIT_OFFSET = .OPERATOR [TOKEN$W_BIT_OFFSET];
    	    
    ! Compute the new byte address.
    !
    ADDRESS = .ADDRESS + .BIT_OFFSET / 8;

    ! Compute the bit offset. From it and the sign extension bit,
    ! determine the new class and dtype.	
    !
    BIT_OFFSET = .BIT_OFFSET MOD 8;
    IF .BIT_OFFSET EQL 0
    THEN
    	BEGIN
    	IF .OPERATOR [TOKEN$V_SGNEXT]
    	THEN
    	    DTYPE = DSC$K_DTYPE_SV
    	ELSE
    	    DTYPE = DSC$K_DTYPE_V;
    	SAVE_RESULT_DESC[DSC$B_CLASS] = DSC$K_CLASS_S;
    	END
    ELSE
    	BEGIN
    	IF .OPERATOR [TOKEN$V_SGNEXT]
    	THEN
    	    DTYPE = DSC$K_DTYPE_SVU
    	ELSE
    	    DTYPE = DSC$K_DTYPE_VU; 
    	SAVE_RESULT_DESC[DSC$B_CLASS] = DSC$K_CLASS_UBS;
    	END;

    ! Save away the new dtype, bit offset, and length.
    !
    SAVE_RESULT_DESC [DSC$B_DTYPE] = .DTYPE;
    SAVE_RESULT_DESC [DSC$W_LENGTH] = .OPERATOR [TOKEN$W_BIT_LENGTH];
    SAVE_RESULT_DESC [DSC$A_POINTER] = .ADDRESS;
    SAVE_RESULT_DESC [DSC$L_POS] = .BIT_OFFSET;

    ! Fill in the new address.
    !
    .RESULT_DESC[DSC$A_POINTER] = .ADDRESS;

    ! Set a flag saying we've done a BLISS bit selection.
    !
    BLISS_BITSELECTION_FLAG1 = TRUE;
    END;

GLOBAL ROUTINE DBG$BLISS_INDIRECTION (ARG_DESC) =
! 
! FUNCTION
!	This routine is called from DBG$PERFORM_OPERATOR to perform a
!	BLISS indirection. The routine just fetches the object
!	given by the VMS descriptor, and returns the object as a longword
!	value.
!
! INPUTS
!	ARG_DESC - A VMS descriptor representing the argument
!
! OUTPUTS
!	The object that the VMS descriptor points to is fetched.
!	This value is returned. If there was no read access to the 
!	address in the descriptor, the NOACCESSR message is
!	signalled.
!

    BEGIN
    BUILTIN
    	PROBER;

    LOCAL
    	VALDESC: REF DBG$VALDESC;		! Pointer to a value descriptor

    ! Turn the VMS desc into a value descriptor
    !
    IF .BLISS_BITSELECTION_FLAG2
    THEN
        VALDESC = DBG$MAKE_VAL_DESC (SAVE_RESULT_DESC, DBG$K_VALUE_DESC)
    ELSE
        VALDESC = DBG$MAKE_VAL_DESC (.ARG_DESC, DBG$K_VALUE_DESC);

    ! If we have already done the fetch, 
    ! return the value in the descriptor.
    !
    IF .BLISS_INDIRECTION_FLAG OR .BLISS_BITSELECTION_FLAG2
    THEN
        RETURN .VALDESC[DBG$L_VALUE_VALUE0]
    
    ELSE

    	! Check for read access.
    	!
    	IF PROBER (%REF(0), %REF(1), .VALDESC[DBG$L_VALUE_VALUE0])
    	THEN
    	    RETURN ..VALDESC[DBG$L_VALUE_VALUE0]

    	ELSE
    	    SIGNAL (DBG$_NOACCESSR, 1, .VALDESC[DBG$L_VALUE_VALUE0])
    END;

GLOBAL ROUTINE DBG$CONV_TEXT_VALUE(VALUE1, VALUE2, NEW_TYPE) =
!
! FUNCTION
!	Perform type conversion from an unconverted string to a value.
!	Note: this routine accepts unsigned dtype, and treat the
!	unsigned value as signed value (in other words, the T --> value
!	is signed.).  
!
! INPUTS
!	VALUE1	- Pointer to a value descriptor to be type-converted.
!	VALUE2	- Pointer to the target value descriptor.
! 	NEW_TYPE- The eventual type of the value
!
! OUTPUTS
!	Pointer to VALUE2 is returned.
!
    BEGIN

    MAP
    	VALUE1: REF DBG$VALDESC,	! Pointer to Value Descr to convert
    	VALUE2: REF DBG$VALDESC;	! Pointer to Target Descr

    LOCAL
    	LENGTH,				! Length of the input data.
    	STATUS,				! Return code from library routines
    	STG_DESC: DBG$STG_DESC, 	! String descriptor for the input
    	STR_PTR,			! ASCIC pointer
    	TARGET_DTYPE,			! Target dtype
    	TARGET_LENGTH;			! Target length


    ! Fill in a string descriptor to be used as the source for the
    ! conversion.
    !
    STG_DESC[DSC$B_CLASS] = DSC$K_CLASS_S;
    STG_DESC[DSC$B_DTYPE] = DSC$K_DTYPE_T;
    LENGTH = .VALUE1[DBG$W_VALUE_LENGTH];
    STG_DESC[DSC$W_LENGTH] = .LENGTH;
    STG_DESC[DSC$A_POINTER] = DBG$GET_TEMPMEM((3+.LENGTH)/4); 

    ! If language is ADA then we may have to strip underscores from the
    ! text.
    !
    IF .DBG$GB_LANGUAGE EQL DBG$K_ADA
    THEN
    	BEGIN
    	LOCAL
    	    IN_PTR: REF VECTOR[,BYTE],
    	    OUT_PTR: REF VECTOR[,BYTE];
    	IN_PTR = .VALUE1[DBG$L_VALUE_POINTER];
    	OUT_PTR = .STG_DESC[DSC$A_POINTER];
    	INCR I FROM 1 TO .LENGTH DO
    	    BEGIN
    	    IF .IN_PTR[0] NEQ '_' THEN
    		BEGIN
    		OUT_PTR[0] = .IN_PTR[0];
    		OUT_PTR = .OUT_PTR + 1;
    		END;
    	    IN_PTR = .IN_PTR + 1;
    	    END;
    	STG_DESC[DSC$W_LENGTH] = .OUT_PTR - .STG_DESC[DSC$A_POINTER];
    	END
    ELSE
        CH$MOVE(.LENGTH, .VALUE1[DBG$L_VALUE_POINTER], .STG_DESC[DSC$A_POINTER]);


    ! Case on the dtype to decide which conversion routine to call.
    !
    CASE .NEW_TYPE FROM DBG$K_MINIMUM_DTYPE TO DBG$K_MAXIMUM_DTYPE OF
        SET


    	! Short integers. If the string input looked like an integer
    	! then convert it to longword.
    	! 
    	[DSC$K_DTYPE_B, DSC$K_DTYPE_BU, DSC$K_DTYPE_W, DSC$K_DTYPE_WU,
    	 DSC$K_DTYPE_L]:
    	    BEGIN
    	    IF .VALUE1[DBG$W_VALUE_TOKENCODE] EQL TOKEN$K_INTEGER OR
    	       .VALUE1[DBG$W_VALUE_TOKENCODE] EQL TOKEN$K_HEX_INTEGER OR
               .VALUE1[DBG$W_VALUE_TOKENCODE] EQL TOKEN$K_BIN_INTEGER OR
               .VALUE1[DBG$W_VALUE_TOKENCODE] EQL TOKEN$K_OCT_INTEGER
    	    THEN
    		TARGET_DTYPE = DSC$K_DTYPE_L
    	    ELSE
    		TARGET_DTYPE = .VALUE1[DBG$B_VALUE_DTYPE];
    	    END;


    	! If the target type is long integer and the input string looked
    	! like an integer then convert the string directly to the long
    	! integer. This ensures that we accept things like
    	! DEP/QUAD X = 11111111111
    	! If we first converted to longword and then to quad we would 
    	! overflow.
    	!
    	[DSC$K_DTYPE_LU, DSC$K_DTYPE_Q, DSC$K_DTYPE_QU,
    	 DSC$K_DTYPE_O, DSC$K_DTYPE_OU]:
    	    BEGIN
    	    IF .VALUE1[DBG$W_VALUE_TOKENCODE] EQL TOKEN$K_INTEGER OR
    	       .VALUE1[DBG$W_VALUE_TOKENCODE] EQL TOKEN$K_HEX_INTEGER OR
               .VALUE1[DBG$W_VALUE_TOKENCODE] EQL TOKEN$K_BIN_INTEGER OR
               .VALUE1[DBG$W_VALUE_TOKENCODE] EQL TOKEN$K_OCT_INTEGER
    	    THEN
    		TARGET_DTYPE = .NEW_TYPE
    	    ELSE
    		TARGET_DTYPE = .VALUE1[DBG$B_VALUE_DTYPE];
    	    END;

    	! If the target type is float, if the input string is in hex, bin,
    	! or oct radix, then hex, bin, oct always goes to Longword integer.
    	! For if we DEP f = %hex 1, we want to convert text in hex to integer
    	! value, then coverts 1 to float 1, then performs the DEP.
    	!
    	[DSC$K_DTYPE_F, DSC$K_DTYPE_D, DSC$K_DTYPE_G, DSC$K_DTYPE_H, 
    	 DSC$K_DTYPE_P]:
    	    BEGIN
	    IF .VALUE1[DBG$W_VALUE_TOKENCODE] NEQ TOKEN$K_HEX_INTEGER AND
               .VALUE1[DBG$W_VALUE_TOKENCODE] NEQ TOKEN$K_BIN_INTEGER AND
               .VALUE1[DBG$W_VALUE_TOKENCODE] NEQ TOKEN$K_OCT_INTEGER AND
    	       .VALUE1[DBG$W_VALUE_TOKENCODE] NEQ TOKEN$K_COMPLEMENT
    	    THEN
    		TARGET_DTYPE = .NEW_TYPE
    	    ELSE
    		TARGET_DTYPE = .VALUE1[DBG$B_VALUE_DTYPE];
    	    END;
    	    

    	! All the other types are either unsupported or fixed type conversion.
    	! For example, bit-string.
    	!
    	[INRANGE, OUTRANGE]:
    	    TARGET_DTYPE = .VALUE1[DBG$B_VALUE_DTYPE];

    	TES;

    STR_PTR = UPLIT BYTE(%ASCIC '');
    CASE .VALUE1[DBG$W_VALUE_TOKENCODE] FROM TOKEN$K_MIN_OPERAND
    					TO   TOKEN$K_MAX_OPERAND OF
        SET
    	[TOKEN$K_INTEGER]:
    	    STR_PTR = UPLIT BYTE(%ASCIC 'decimal ');

    	[TOKEN$K_HEX_INTEGER]:
    	    STR_PTR = UPLIT BYTE(%ASCIC 'hexadecimal ');

    	[TOKEN$K_FLOATING]:
    	    STR_PTR = UPLIT BYTE(%ASCIC 'f_float ');

    	[TOKEN$K_EXP_E_FLOAT]:
    	    STR_PTR = UPLIT BYTE(%ASCIC 'f_float ');

    	[TOKEN$K_EXP_D_FLOAT]:
    	    STR_PTR = UPLIT BYTE(%ASCIC 'd_float ');

    	[TOKEN$K_EXP_Q_FLOAT]:
    	    STR_PTR = UPLIT BYTE(%ASCIC 'h_float ');

    	[TOKEN$K_BIN_INTEGER]:
    	    STR_PTR = UPLIT BYTE(%ASCIC 'binary ');

    	[TOKEN$K_OCT_INTEGER]:
    	    STR_PTR = UPLIT BYTE(%ASCIC 'octal ');

    	[TOKEN$K_BIT_STRING]:
    	    STR_PTR = UPLIT BYTE(%ASCIC 'bit-string ');

    	[TOKEN$K_PACK_DECIMAL]:
    	    STR_PTR = UPLIT BYTE(%ASCIC 'packed decimal ');

    	[TOKEN$K_EXP_G_FLOAT]:
    	    STR_PTR = UPLIT BYTE(%ASCIC 'g_float ');

    	[INRANGE, OUTRANGE]:
    	    0;

    	TES;


    CASE .TARGET_DTYPE FROM DBG$K_MINIMUM_DTYPE 
    		       TO   DBG$K_MAXIMUM_DTYPE OF
        SET

    
	! Signed integers. Call a runtime routine to do the conversion
    	! from text to integer.  
    	!    	
    	! Notes - known problems with this code:
    	! 1) In here, we treat the signed and unsigned
    	! are the same, this may need to be fixed in the future to do the
    	! the unsigned conversion. This only affects unsigned constants
    	! between 2*31-1 and 2*32-1 (we treat these as signed longword,
    	! so they overflow).
    	! 2) Another problem is that
    	! the largest negative longword integer will overflow because
    	! we are converting it to longword and then negating it at the end.
    	! 
    	! Since these problems only affect very large constants in 
    	! infrequent situations, they are being ignored at the present time.
    	!
    	[DSC$K_DTYPE_B, DSC$K_DTYPE_W, DSC$K_DTYPE_L, 
    	 DSC$K_DTYPE_BU, DSC$K_DTYPE_WU, DSC$K_DTYPE_LU]:
    	    BEGIN
	    SELECTONE .TARGET_DTYPE OF
		SET
		[DSC$K_DTYPE_B, DSC$K_DTYPE_BU]:
    		    TARGET_LENGTH = 1;

		[DSC$K_DTYPE_W, DSC$K_DTYPE_WU]:
    		    TARGET_LENGTH = 2;

		[DSC$K_DTYPE_L, DSC$K_DTYPE_LU]:
    		    TARGET_LENGTH = 4;

    		TES;
    	    
    	    CASE .VALUE1[DBG$W_VALUE_TOKENCODE] FROM TOKEN$K_MIN_OPERAND 
    						TO   TOKEN$K_MAX_OPERAND OF
    		SET
    		[TOKEN$K_INTEGER]:
    		    BEGIN
	    	    STATUS = OTS$CVT_TI_L(STG_DESC, 
    			.VALUE2[DBG$L_VALUE_POINTER], .TARGET_LENGTH);
    		    END;

    		[TOKEN$K_HEX_INTEGER]:
    		    BEGIN
	            STATUS = OTS$CVT_TZ_L(STG_DESC, 
    			.VALUE2[DBG$L_VALUE_POINTER], .TARGET_LENGTH);
    		    END;

    		[TOKEN$K_BIN_INTEGER]:
    		    BEGIN
	    	    STATUS = OTS$CVT_TB_L(STG_DESC, 
    			.VALUE2[DBG$L_VALUE_POINTER], .TARGET_LENGTH);
    		    END;

    		[TOKEN$K_OCT_INTEGER]:
    		    BEGIN
	    	    STATUS = OTS$CVT_TO_L(STG_DESC, 
    			.VALUE2[DBG$L_VALUE_POINTER], .TARGET_LENGTH);
    		    END;

    		[TOKEN$K_COMPLEMENT]:
    		    BEGIN
    		    STATUS = 1;
    		    .VALUE2[DBG$L_VALUE_POINTER] = 
    			MTH$JNOT(.STG_DESC[DSC$A_POINTER]);
    		    END;

    		[INRANGE, OUTRANGE]:
    		    $DBG_ERROR('DBGEVALOP\DBG$CONV_TEXT_VALUE');

    		TES;
    		
    	    IF NOT .STATUS 
    	    THEN
    		BEGIN
    		SELECTONE .TARGET_DTYPE OF
    		    SET
    		    [DSC$K_DTYPE_B]:
    			SIGNAL(DBG$_UNACVT, 4, .STR_PTR, .LENGTH,
		       	       .STG_DESC[DSC$A_POINTER],
    		               UPLIT BYTE (%ASCIC 'byte integer'),
    		               .STATUS);

    		    [DSC$K_DTYPE_BU]:
    			SIGNAL(DBG$_UNACVT, 4, .STR_PTR, .LENGTH,
		       	       .STG_DESC[DSC$A_POINTER],
    		               UPLIT BYTE (%ASCIC 'byte logical'),
    		               .STATUS);

    		    [DSC$K_DTYPE_W]:
    			SIGNAL (DBG$_UNACVT, 4, .STR_PTR, .LENGTH,
			        .STG_DESC[DSC$A_POINTER],
    			        UPLIT BYTE (%ASCIC 'word integer'),
    			        .STATUS);

    		    [DSC$K_DTYPE_WU]:
    			SIGNAL (DBG$_UNACVT, 4, .STR_PTR, .LENGTH,
			        .STG_DESC[DSC$A_POINTER],
    			        UPLIT BYTE (%ASCIC 'word logical'),
    			        .STATUS);

    		    [DSC$K_DTYPE_L]:
    	 		SIGNAL (DBG$_UNACVT, 4, .STR_PTR, .LENGTH,
			        .STG_DESC[DSC$A_POINTER],
    			        UPLIT BYTE (%ASCIC 'longword integer'),
    			        .STATUS);

    		    [DSC$K_DTYPE_LU]:
    	 		SIGNAL (DBG$_UNACVT, 4, .STR_PTR, .LENGTH,
			        .STG_DESC[DSC$A_POINTER],
    			        UPLIT BYTE (%ASCIC 'longword logical'),
    			        .STATUS);
    		    TES;
    		END;
    	    
    	    VALUE2[DBG$B_VALUE_DTYPE] = .TARGET_DTYPE;
    	    VALUE2[DBG$W_VALUE_LENGTH] = .TARGET_LENGTH;
    	    END;

	[DSC$K_DTYPE_Q, DSC$K_DTYPE_QU]:
    	    BEGIN
	    STATUS =
		DBG$CONV_TQUADWORD_VALUE(.VALUE1, .VALUE2);
    	    IF NOT .STATUS 
    	    THEN
    		BEGIN
    		SELECTONE .TARGET_DTYPE OF
    		    SET
    		    [DSC$K_DTYPE_Q]:
    			SIGNAL(DBG$_UNACVT, 4, .STR_PTR, .LENGTH,
		       	       .STG_DESC[DSC$A_POINTER],
    		               UPLIT BYTE (%ASCIC 'quadword integer'),
    		               .STATUS);

    		    [DSC$K_DTYPE_QU]:
    			SIGNAL(DBG$_UNACVT, 4, .STR_PTR, .LENGTH,
		       	       .STG_DESC[DSC$A_POINTER],
    		               UPLIT BYTE (%ASCIC 'quadword logical'),
    		               .STATUS);
    		    TES;
    		END;

    	    VALUE2[DBG$B_VALUE_DTYPE] = .TARGET_DTYPE;
	    VALUE2[DBG$W_VALUE_LENGTH] = 8;
    	    END;


    	[DSC$K_DTYPE_O, DSC$K_DTYPE_OU]:
    	    BEGIN
	    STATUS =
		DBG$CONV_TOCTAWORD_VALUE(.VALUE1, .VALUE2);
    	    IF NOT .STATUS 
    	    THEN
    		BEGIN
    		SELECTONE .TARGET_DTYPE OF
    		    SET
    		    [DSC$K_DTYPE_O]:
    			SIGNAL(DBG$_UNACVT, 4, .STR_PTR, .LENGTH,
		       	       .STG_DESC[DSC$A_POINTER],
    		               UPLIT BYTE (%ASCIC 'octaword integer'),
    		               .STATUS);

    		    [DSC$K_DTYPE_OU]:
    			SIGNAL(DBG$_UNACVT, 4, .STR_PTR, .LENGTH,
		       	       .STG_DESC[DSC$A_POINTER],
    		               UPLIT BYTE (%ASCIC 'octaword logical'),
    		               .STATUS);
    		    TES;
    		END;

    	    VALUE2[DBG$B_VALUE_DTYPE] = .TARGET_DTYPE;
	    VALUE2[DBG$W_VALUE_LENGTH] = 16;
    	    END;

    	! Floating point. Call a runtime routine to do the conversion
    	! from text to float value.
    	!
    	[DSC$K_DTYPE_F] : 
    	    BEGIN
    	    STATUS = OTS$CVT_T_F(STG_DESC, .VALUE2[DBG$L_VALUE_POINTER]);
    	    IF NOT  .STATUS 
    	    THEN
    		SIGNAL (DBG$_UNACVT, 4, .STR_PTR, .LENGTH,
			.STG_DESC[DSC$A_POINTER],
    			UPLIT BYTE (%ASCIC 'floating'),
    			.STATUS);

    	    VALUE2[DBG$B_VALUE_DTYPE] = .TARGET_DTYPE;
	    VALUE2[DBG$W_VALUE_LENGTH] = 4;
    	    END;

    	! Double floating point. Call a runtime routine to do the conversion
    	! from text to double float value.
    	!
    	[DSC$K_DTYPE_D] :
    	    BEGIN
    	    STATUS = OTS$CVT_T_D(STG_DESC, .VALUE2[DBG$L_VALUE_POINTER]);
    	    IF NOT  .STATUS 
    	    THEN
    		SIGNAL (DBG$_UNACVT, 4, .STR_PTR, .LENGTH,
			.STG_DESC[DSC$A_POINTER],
    			UPLIT BYTE (%ASCIC 'double floating'),
    			.STATUS);

    	    VALUE2[DBG$B_VALUE_DTYPE] = .TARGET_DTYPE;
    	    VALUE2[DBG$W_VALUE_LENGTH] = 8;
    	    END;

    	! G Floating point. Call a runtime routine to do the conversion
    	! from text to G float value.
    	!
    	[DSC$K_DTYPE_G] :
    	    BEGIN
    	    STATUS = OTS$CVT_T_G(STG_DESC, .VALUE2[DBG$L_VALUE_POINTER]);
    	    IF NOT  .STATUS 
    	    THEN
    		SIGNAL (DBG$_UNACVT, 4, .STR_PTR, .LENGTH,
			.STG_DESC[DSC$A_POINTER],
    			UPLIT BYTE (%ASCIC 'g_floating'),
    			.STATUS);

    	    VALUE2[DBG$B_VALUE_DTYPE] = .TARGET_DTYPE;
    	    VALUE2[DBG$W_VALUE_LENGTH] = 8;
    	    END;

    	! H Floating point. Call a runtime routine to do the conversion
    	! from text to H float value.
    	!
    	[DSC$K_DTYPE_H] :
    	    BEGIN
    	    STATUS = OTS$CVT_T_H(STG_DESC, .VALUE2[DBG$L_VALUE_POINTER]);
    	    IF NOT  .STATUS 
    	    THEN
    		SIGNAL (DBG$_UNACVT, 4, .STR_PTR, .LENGTH,
			.STG_DESC[DSC$A_POINTER],
    			UPLIT BYTE (%ASCIC 'h_floating'),
    			.STATUS);

    	    VALUE2[DBG$B_VALUE_DTYPE] = .TARGET_DTYPE;
	    VALUE2[DBG$W_VALUE_LENGTH] = 16;
    	    END;

    	! Pack decimal.  Call a user routine to do the conversion
    	! from text to pack decimal.
    	!
    	[DSC$K_DTYPE_P]:
    	    VALUE2 = CONV_TEXT_PACK_VALUE(.VALUE1);

    	! Text string. There is no conversion to be done here since the value
    	! is already in the right format.
    	!
    	[DSC$K_DTYPE_T] :
    	    0;

	! Bit-string.  Call a Debug routine to do the conversion from text to
	! bit-string format.  The Debug routine actually calls a PL/I
	! run-time routine to do the conversion; it is written in macro to
	! simplify the interface (PL/I run-time routines notoriously do not 
	! adhere to the VAX calling standard).  The bit-string format is thus
	! PL/I specific.
	!
	[DSC$K_DTYPE_V]:
	    BEGIN
	    LOCAL
		STG_PTR:  REF VECTOR[, BYTE];


	    ! At present, allow only binary constants.  Catch errors here,
	    ! because PL/I run-time routines do not return a status.
	    !
	    STG_PTR = .STG_DESC[DSC$A_POINTER];
	    INCR I FROM 0 TO .LENGTH-1 DO
	 	BEGIN
		IF .STG_PTR[.I] NEQ %C'0' AND .STG_PTR[.I] NEQ %C'1'
		THEN
		    SIGNAL (DBG$_UNACVT, 4, .STR_PTR, .LENGTH, 
		            .STG_DESC[DSC$A_POINTER],
			    UPLIT BYTE (%ASCIC 'bit-string'), .STATUS);
		END;

	    PLI$CHARABIT_R6(.STG_DESC[DSC$A_POINTER], .LENGTH,
		.VALUE2[DBG$L_VALUE_POINTER], .VALUE2[DBG$W_VALUE_LENGTH]);
	    END;


    	! We do not expect any other dtype, so signal an error if we see one.
    	!
    	[INRANGE, OUTRANGE] :
    	    $DBG_ERROR ('DBGEVALOP\DBG$CONV_TEXT_VALUE');

    	TES;

    
    ! The conversion has been completed.  Turn off the "unconverted" bit in
    ! the value descriptor.  Return a pointer to the Value Descriptor which
    ! contains the converted value.
    !
    VALUE2[DBG$V_DHDR_UNCVT] = 0;
    VALUE2[DBG$W_VALUE_TOKENCODE] = 0;


    ! Take care of the sign.
    !
    IF .VALUE1[DBG$W_VALUE_SIGN_CODE] EQL TOKEN$K_NEGCONST OR
       .VALUE1[DBG$W_VALUE_SIGN_CODE] EQL TOKEN$K_POSCONST
    THEN
    	BEGIN
        IF .VALUE1[DBG$W_VALUE_SIGN_CODE] EQL TOKEN$K_NEGCONST
        THEN
            BEGIN
            VALUE2[DBG$W_VALUE_SIGN_CODE] = 0;
    	    VALUE2 = DBG$EVAL_LANG_OPERATOR(DBG$GL_NEG_CONST_TOKEN,
    		    	.VALUE2, 0);
    	    END

        ELSE
    	    BEGIN
            VALUE2[DBG$W_VALUE_SIGN_CODE] = 0;
    	    VALUE2 = DBG$EVAL_LANG_OPERATOR(DBG$GL_POS_CONST_TOKEN,
    			.VALUE2, 0);
    	    END;

    	END;

    RETURN .VALUE2;

    END;

GLOBAL ROUTINE DBG$CONV_TQUADWORD_VALUE(VAL_DESC1, VAL_DESC2) =
!
! FUNCTION
!	This routine takes in unconverted ascii string and converts it into 
!	8 bytes	Quardword value according to the given radix 
!	(tokencode).
!
! INPUTS
!	VAL_DESC1 - Pointer to a value descriptor to be converted.
!
!	VAL_DESC2 - Pointer to a value descriptor to be returned.
!
! OUTPUTS
!	Overflow status is returned.
!

    BEGIN

    MAP
    	VAL_DESC1: REF DBG$VALDESC,	! Pointer to value descriptor
    	VAL_DESC2: REF DBG$VALDESC;	! Pointer to value descriptor

    LOCAL
    	CHAR_VALUE: VECTOR[8, BYTE],	! Value of the character
    	LENGTH,				! Lenght of the input data
    	PTR: REF VECTOR[,BYTE],		! Pointer to a vector of bytes
    	QUADWORD: VECTOR[8, BYTE],	! 8 bytes of QUADWORD value
    	STATUS,				! Return status from conversion
    	STG_DESC: DBG$STG_DESC;		! String descriptor for signal


    ! Prepare the string descriptor for signaling.
    !
    STG_DESC[DSC$B_CLASS] = DSC$K_CLASS_S;
    STG_DESC[DSC$B_DTYPE] = DSC$K_DTYPE_T;
    LENGTH = .VAL_DESC1[DBG$W_VALUE_LENGTH];
    STG_DESC[DSC$W_LENGTH] = .LENGTH;
    STG_DESC[DSC$A_POINTER] = DBG$GET_TEMPMEM((3+.LENGTH)/4);
    CH$MOVE(.STG_DESC[DSC$W_LENGTH], .VAL_DESC1[DBG$L_VALUE_POINTER],
    	.STG_DESC[DSC$A_POINTER]);


    INCR I FROM 0 TO 7 DO
    	BEGIN
    	QUADWORD[.I] = 0;
    	CHAR_VALUE[.I] = 0;
    	END;


    ! Convert the value into 8 bytes one by one byte.
    !
    PTR = .VAL_DESC1[DBG$L_VALUE_POINTER];
    DECR I FROM .LENGTH TO 1 BY 1 DO
    	BEGIN
    	CASE .VAL_DESC1[DBG$W_VALUE_TOKENCODE] FROM TOKEN$K_MIN_OPERAND
    					       TO   TOKEN$K_MAX_OPERAND OF
    	    SET


    	    ! Validate legal 0-9 characters in decimal radix.
    	    !
    	    [TOKEN$K_INTEGER]:
    		BEGIN
    		IF .PTR[0] GEQ 48 AND .PTR[0] LEQ 57
    		THEN
    		    CHAR_VALUE[0] = .PTR[0] - 48
    		ELSE
    		    SIGNAL(DBG$_INVNUMBER, 1, STG_DESC);
    		END;


    	    ! Validate legal 0-9, A-F, a-f characters in hexdecimal radix.
    	    !
    	    [TOKEN$K_HEX_INTEGER]:
    		BEGIN
    		SELECTONE .PTR[0] OF
    		    SET
    		    [48 TO 57]:
    	    		CHAR_VALUE[0] = .PTR[0] - 48;
    		    [65 TO 70]:
    			CHAR_VALUE[0] = .PTR[0] - 55;
    		    [97 TO 102]:
    			CHAR_VALUE[0] = .PTR[0] - 87;
    		    [OTHERWISE]:
    		        SIGNAL(DBG$_INVNUMBER, 1, STG_DESC);
    		    TES;
    		END;


    	    ! Validate legal 0-1 characters in binary radix.
    	    !
    	    [TOKEN$K_BIN_INTEGER]:
    		BEGIN
    		IF .PTR[0] GEQ 48 AND .PTR[0] LEQ 49
    		THEN
    		    CHAR_VALUE[0] = .PTR[0] - 48
    		ELSE
    		    SIGNAL(DBG$_INVNUMBER, 1, STG_DESC);
    		END;


    	    ! Validate legal 0-7 characters in octal radix.
    	    !
    	    [TOKEN$K_OCT_INTEGER]:
    		BEGIN
    		IF .PTR[0] GEQ 48 AND .PTR[0] LEQ 55
    		THEN
    		    CHAR_VALUE[0] = .PTR[0] - 48
    		ELSE
    		    SIGNAL(DBG$_INVNUMBER, 1, STG_DESC);
    		END;

    	    [INRANGE, OUTRANGE]:
    		$DBG_ERROR('DBGEVALOP\DBG$CONV_TQUADWORD_VALUE');

    	    TES;

    	STATUS = 
    	    DBG$CVT_TQUADWORD_TO_VALUE(QUADWORD, CHAR_VALUE, .VAL_DESC1[DBG$W_VALUE_TOKENCODE]);

    	! Test overflow status.
    	!
    	IF NOT .STATUS
        THEN
            BEGIN

            ! If we could convert to an unsigned Quadword, do that with message.
            !
            STATUS =
                DBG$CVT_TUQUADWORD_TO_VALUE(QUADWORD, CHAR_VALUE, .VAL_DESC1[DBG$W_VALUE_TOKENCODE]);

            IF NOT .STATUS THEN EXITLOOP;
            SIGNAL(DBG$_IINTOVF, 1, .DBG$GL_OPCODE_NAME);
            END;
    
    	PTR = .PTR + 1;
    	END;


    ! Install the value and fix up the value descriptor.
    !
!    CH$FILL(%C'0', 16, .VAL_DESC1[DBG$L_VALUE_POINTER]);
    CH$MOVE(8, QUADWORD, .VAL_DESC2[DBG$L_VALUE_POINTER]);
!    .VAL_DESC2 = .VAL_DESC1;
    RETURN .STATUS;
    END;

GLOBAL ROUTINE DBG$CONV_TOCTAWORD_VALUE(VAL_DESC1, VAL_DESC2) =
!
! FUNCTION
!	This routine takes in unconverted ascii string and converts it into 
!	16 bytes octaword value according to the given radix 
!	(tokencode).
!
! INPUTS
!	VAL_DESC1 - Pointer to a value descriptor to be converted.
!
!	VAL_DESC2 - Pointer to a value descriptor to be returned.
!
! OUTPUTS
!	Overflow status is returned.
!

    BEGIN

    MAP
    	VAL_DESC1: REF DBG$VALDESC,	! Pointer to value descriptor
    	VAL_DESC2: REF DBG$VALDESC;	! Pointer to value descriptor

    LOCAL
    	CHAR_VALUE: VECTOR[16, BYTE],	! Value of the character
    	LENGTH,				! Lenght of the input data
    	PTR: REF VECTOR[,BYTE],		! Pointer to a vector of bytes
    	OCTAWORD: VECTOR[16, BYTE],	! 16 bytes of octaword value
    	STATUS,				! Return status from conversion
    	STG_DESC: DBG$STG_DESC;		! String descriptor for signal


    ! Prepare the string descriptor for signaling.
    !
    STG_DESC[DSC$B_CLASS] = DSC$K_CLASS_S;
    STG_DESC[DSC$B_DTYPE] = DSC$K_DTYPE_T;
    LENGTH = .VAL_DESC1[DBG$W_VALUE_LENGTH];
    STG_DESC[DSC$W_LENGTH] = .LENGTH;
    STG_DESC[DSC$A_POINTER] = DBG$GET_TEMPMEM((3+.LENGTH)/4);
    CH$MOVE(.STG_DESC[DSC$W_LENGTH], .VAL_DESC1[DBG$L_VALUE_POINTER],
    	.STG_DESC[DSC$A_POINTER]);

    INCR I FROM 0 TO 15 DO
    	BEGIN
    	OCTAWORD[.I] = 0;
    	CHAR_VALUE[.I] = 0;
    	END;


    ! Convert the value into 16 bytes one by one byte.
    !
    PTR = .VAL_DESC1[DBG$L_VALUE_POINTER];
    DECR I FROM .LENGTH TO 1 BY 1 DO
    	BEGIN
    	CASE .VAL_DESC1[DBG$W_VALUE_TOKENCODE] FROM TOKEN$K_MIN_OPERAND
    					       TO   TOKEN$K_MAX_OPERAND OF
    	    SET


    	    ! Validate legal 0-9 characters in decimal radix.
    	    !
    	    [TOKEN$K_INTEGER]:
    		BEGIN
    		IF .PTR[0] GEQ 48 AND .PTR[0] LEQ 57
    		THEN
    		    CHAR_VALUE[0] = .PTR[0] - 48
    		ELSE
    		    SIGNAL(DBG$_INVNUMBER, 1, STG_DESC);
    		END;


    	    ! Validate legal 0-9, A-F, a-f characters in hexdecimal radix.
    	    !
    	    [TOKEN$K_HEX_INTEGER]:
    		BEGIN
    		SELECTONE .PTR[0] OF
    		    SET
    		    [48 TO 57]:
    	    		CHAR_VALUE[0] = .PTR[0] - 48;
    		    [65 TO 70]:
    			CHAR_VALUE[0] = .PTR[0] - 55;
    		    [97 TO 102]:
    			CHAR_VALUE[0] = .PTR[0] - 87;
    		    [OTHERWISE]:
    		        SIGNAL(DBG$_INVNUMBER, 1, STG_DESC);
    		    TES;
    		END;


    	    ! Validate legal 0-1 characters in binary radix.
    	    !
    	    [TOKEN$K_BIN_INTEGER]:
    		BEGIN
    		IF .PTR[0] GEQ 48 AND .PTR[0] LEQ 49
    		THEN
    		    CHAR_VALUE[0] = .PTR[0] - 48
    		ELSE
    		    SIGNAL(DBG$_INVNUMBER, 1, STG_DESC);
    		END;


    	    ! Validate legal 0-7 characters in octal radix.
    	    !
    	    [TOKEN$K_OCT_INTEGER]:
    		BEGIN
    		IF .PTR[0] GEQ 48 AND .PTR[0] LEQ 55
    		THEN
    		    CHAR_VALUE[0] = .PTR[0] - 48
    		ELSE
    		    SIGNAL(DBG$_INVNUMBER, 1, STG_DESC);
    		END;

    	    [INRANGE, OUTRANGE]:
    		$DBG_ERROR('DBGEVALOP\DBG$CONV_TOCTAWORD_VALUE');

    	    TES;

    	STATUS = 
    	    DBG$CVT_TOCTAWORD_TO_VALUE(OCTAWORD, CHAR_VALUE, .VAL_DESC1[DBG$W_VALUE_TOKENCODE]);

    	! Test overflow status.
    	!
    	IF NOT .STATUS THEN EXITLOOP;

    	PTR = .PTR + 1;
    	END;

    ! Check for integer overflow on the sign bit.
    !
    IF .OCTAWORD[15] GEQ 128
    THEN
        SIGNAL(DBG$_IINTOVF, 1, .DBG$GL_OPCODE_NAME);

    ! Install the value and fix up the value descriptor.
    !
    CH$MOVE(16, OCTAWORD, .VAL_DESC2[DBG$L_VALUE_POINTER]);
    RETURN .STATUS;
    END;

GLOBAL ROUTINE DBG$CONV_TRFA_VALUE(VAL_DESC) =
!
! FUNCTION
!	This routine takes in unconverted ascii string and converts it into 
!	6 bytes	Record File Address value according to the given radix 
!	(tokencode).
!
! INPUTS
!	VAL_DESC - Pointer to a value descriptor to be converted.
!
! OUTPUTS
!	Converted value is returned in VAL_DESC.
!

    BEGIN

    MAP
    	VAL_DESC: REF DBG$VALDESC;	! Pointer to value descriptor

    LOCAL
    	CHAR_VALUE: VECTOR[6, BYTE],	! Value of the character
    	LENGTH,				! Lenght of the input data
    	PTR: REF VECTOR[,BYTE],		! Pointer to a vector of bytes
    	RFA: VECTOR[6, BYTE],		! 6 bytes of RFA value
    	STATUS,				! Return status from conversion
    	STG_DESC: DBG$STG_DESC;		! String descriptor for signal


    ! Won't accept the negative constant.
    !
    IF .VAL_DESC[DBG$W_VALUE_SIGN_CODE] EQL TOKEN$K_NEGCONST
    THEN
    	SIGNAL(DBG$_CVTNEGUNS, 1, .DBG$GL_OPCODE_NAME);


    ! Prepare the string descriptor for signaling.
    !
    STG_DESC[DSC$B_CLASS] = DSC$K_CLASS_S;
    STG_DESC[DSC$B_DTYPE] = DSC$K_DTYPE_T;
    LENGTH = .VAL_DESC[DBG$W_VALUE_LENGTH];
    STG_DESC[DSC$W_LENGTH] = .LENGTH;
    STG_DESC[DSC$A_POINTER] = DBG$GET_TEMPMEM((3+.LENGTH)/4);
    CH$MOVE(.STG_DESC[DSC$W_LENGTH], .VAL_DESC[DBG$L_VALUE_POINTER],
    	.STG_DESC[DSC$A_POINTER]);


    INCR I FROM 0 TO 5 DO
    	BEGIN
    	RFA[.I] = 0;
    	CHAR_VALUE[.I] = 0;
    	END;


    ! Convert the value into 6 bytes one by one byte.
    !
    PTR = .VAL_DESC[DBG$L_VALUE_POINTER];
    DECR I FROM .LENGTH TO 1 BY 1 DO
    	BEGIN
    	CASE .VAL_DESC[DBG$W_VALUE_TOKENCODE] FROM TOKEN$K_MIN_OPERAND
    					      TO   TOKEN$K_MAX_OPERAND OF
    	    SET


    	    ! Validate legal 0-9 characters in decimal radix.
    	    !
    	    [TOKEN$K_INTEGER]:
    		BEGIN
    		IF .PTR[0] GEQ 48 AND .PTR[0] LEQ 57
    		THEN
    		    CHAR_VALUE[0] = .PTR[0] - 48
    		ELSE
    		    SIGNAL(DBG$_INVNUMBER, 1, STG_DESC);
    		END;


    	    ! Validate legal 0-9, A-F, a-f characters in hexdecimal radix.
    	    !
    	    [TOKEN$K_HEX_INTEGER]:
    		BEGIN
    		SELECTONE .PTR[0] OF
    		    SET
    		    [48 TO 57]:
    	    		CHAR_VALUE[0] = .PTR[0] - 48;
    		    [65 TO 70]:
    			CHAR_VALUE[0] = .PTR[0] - 55;
    		    [97 TO 102]:
    			CHAR_VALUE[0] = .PTR[0] - 87;
    		    [OTHERWISE]:
    		        SIGNAL(DBG$_INVNUMBER, 1, STG_DESC);
    		    TES;
    		END;


    	    ! Validate legal 0-1 characters in binary radix.
    	    !
    	    [TOKEN$K_BIN_INTEGER]:
    		BEGIN
    		IF .PTR[0] GEQ 48 AND .PTR[0] LEQ 49
    		THEN
    		    CHAR_VALUE[0] = .PTR[0] - 48
    		ELSE
    		    SIGNAL(DBG$_INVNUMBER, 1, STG_DESC);
    		END;


    	    ! Validate legal 0-7 characters in octal radix.
    	    !
    	    [TOKEN$K_OCT_INTEGER]:
    		BEGIN
    		IF .PTR[0] GEQ 48 AND .PTR[0] LEQ 55
    		THEN
    		    CHAR_VALUE[0] = .PTR[0] - 48
    		ELSE
    		    SIGNAL(DBG$_INVNUMBER, 1, STG_DESC);
    		END;

    	    [INRANGE, OUTRANGE]:
    		$DBG_ERROR('DBGEVALOP\DBG$CONV_TRFA_VALUE');

    	    TES;

    	STATUS = 
    	    DBG$CVT_TRFA_TO_VALUE(RFA, CHAR_VALUE, .VAL_DESC[DBG$W_VALUE_TOKENCODE]);


    	! Test overflow status.
    	!
    	IF NOT .STATUS
    	THEN
    	    BEGIN
    	    SIGNAL(DBG$_IRFAOVF, 1, .DBG$GL_OPCODE_NAME);
    	    EXITLOOP;
    	    END;

    	PTR = .PTR + 1;
    	END;


    ! Install the value and fix up the value descriptor.
    !
    VAL_DESC[DBG$V_DHDR_UNCVT] = 0;
    VAL_DESC[DBG$B_DHDR_FCODE] = RST$K_TYPE_RFA;
    VAL_DESC[DBG$B_VALUE_CLASS] = 0;
    VAL_DESC[DBG$B_VALUE_DTYPE] = 0;
    VAL_DESC[DBG$W_VALUE_LENGTH] = 6;
    CH$FILL(%C'0', 16, .VAL_DESC[DBG$L_VALUE_POINTER]);
    CH$MOVE(6, RFA, .VAL_DESC[DBG$L_VALUE_POINTER]);
    VAL_DESC[DBG$W_VALUE_TOKENCODE] = 0;
    VAL_DESC[DBG$W_VALUE_SIGN_CODE] = 0;
    RETURN .VAL_DESC;
    END;


GLOBAL ROUTINE DBG$DO_MAPPING (LEFT_ARG) : NOVALUE =
!
! FUNCTION
!	Perform a language-specific "type mapping" on the given 
!	value descriptor. For example, in FORTRAN, we map unsigned integer
!	types to signed integer types, because the compiler is given us
!	the BU, WU, or LU types, while the language really does signed
!	arithmetic on these.
!
! INPUTS
!	LEFT_ARG	- points to the value descriptor to be mapped.
!
! OUTPUTS
!	The value descriptor pointed to by LEFT_ARG may be modified.
!
    BEGIN
    MAP
    	LEFT_ARG: REF DBG$VALDESC;

    LOCAL
    	COMPLIST: REF VECTOR[,LONG],
    	DSTPTR,
	LEFT_TYPE,			! Dtype for original left operand type
    	MAKE_BOOLEAN_FLAG,
    	MAP_TBL_ENTRY: TYPE_GRAPH$ENTRY,! An entry in the Type Mapping Table
    	NAME: REF VECTOR[,BYTE],	! Name corresponding to typeid
    	SYMID: REF RST$ENTRY,
    	TYPEID: REF RST$ENTRY;		! Typeid in descriptor


    ! For ADA, we map the enumeration type BOOLEAN into the dtype
    ! DSC$K_DTYPE_TF. The reason for this is that we want the logical
    ! operators AND, OR, XOR, NOT to work on BOOLEAN (but not other
    ! enumeration types).
    !
    IF .DBG$GB_LANGUAGE EQL DBG$K_ADA
    THEN
    	BEGIN
    	IF .LEFT_ARG[DBG$B_DHDR_FCODE] EQL RST$K_TYPE_ENUM
    	THEN
    	    BEGIN
    	    TYPEID = .LEFT_ARG[DBG$L_DHDR_TYPEID];
    	    IF .TYPEID NEQ 0
    	    THEN
    	        BEGIN
    	        DSTPTR = .TYPEID[RST$L_DSTPTR];
    	        NAME = DBG$GET_DST_NAME(.DSTPTR);
    	        IF .NAME[0] EQL 7
    	        THEN
    		    BEGIN
    	            IF CH$EQL(7, NAME[1], 7, UPLIT (%ASCII 'BOOLEAN'))
    		    THEN
    		        BEGIN
    
    			! We have determined we have data of type "BOOLEAN".
    		        ! Do some additional checking here:
    		        ! check that the enumeration elements are
    		        ! (FALSE, TRUE). The reason is that the user may
    		        ! have redefined BOOLEAN so we may not be looking
    		        ! at a "real" boolean type. 
    		        !
    			IF .TYPEID[RST$L_TYPCOMPCNT] EQL 2
    			THEN
    			    BEGIN
    			    COMPLIST = TYPEID[RST$A_TYPCOMPLST];
    			    SYMID = .COMPLIST[0];
    			    DSTPTR = .SYMID[RST$L_DSTPTR];
    	        	    NAME = DBG$GET_DST_NAME(.DSTPTR);
    			    IF .NAME[0] EQL 5 
    			    THEN
    				BEGIN
    	            		IF CH$EQL(5, NAME[1], 
    					  5, UPLIT (%ASCII 'FALSE'))
    		    		THEN
    				    BEGIN
    			    	    SYMID = .COMPLIST[1];
    			            DSTPTR = .SYMID[RST$L_DSTPTR];
    	        	            NAME = DBG$GET_DST_NAME(.DSTPTR);
    				    IF .NAME[0] EQL 4 
    				    THEN
    					BEGIN
    	            		        IF CH$EQL(4, NAME[1], 
    						  4, UPLIT (%ASCII 'TRUE'))
    		    		        THEN
    					    BEGIN

    					    ! We have finally decided that it
    					    ! is OK to change the dtype to TF.
    					    !
    		        		    LEFT_ARG[DBG$B_DHDR_FCODE] = RST$K_TYPE_ATOMIC;
    		        		    LEFT_ARG[DBG$B_VALUE_CLASS] = DSC$K_CLASS_S;
    		        		    LEFT_ARG[DBG$B_VALUE_DTYPE] = DSC$K_DTYPE_TF;
    		        		    LEFT_ARG[DBG$W_VALUE_LENGTH] = 1;
    					    END;
    					END;
    			 	    END;
    				END;
    			    END;
    			END;
    		    END;
    		END;
    	    END;
    	END;


    ! Consult the Type Mapping Table to see if we need to change the dtype
    ! of either the left or the right operand.
    !
    LEFT_TYPE = DBG$GET_DTYPE (.LEFT_ARG);
    IF .MAP_TBL NEQ TABLEBASE
    THEN
    	BEGIN
        INCR I FROM 0 TO .MAP_TBL_SIZE - 1 DO
    	    BEGIN
    	    MAP_TBL_ENTRY = .MAP_TBL[.I]; 
    	    IF .MAP_TBL_ENTRY EQL 0 THEN EXITLOOP;
    	    IF .MAP_TBL_ENTRY[TYPE_GRAPH$B_LOWER_TYPE] EQL .LEFT_TYPE
    	    THEN
    		BEGIN

    	 	! We have found a mapping. Change all the information
    		! in the descriptor accordingly.
    		!
    		LEFT_TYPE = .MAP_TBL_ENTRY[TYPE_GRAPH$B_HIGHER_TYPE];

    		! If we are mapping to a non-vax_standard type, we need
    		! to change the fcode.
    		!
    		IF .LEFT_TYPE GTR DBG$K_MAXIMUM_DTYPE
    		THEN
    		    BEGIN
    		    LEFT_ARG[DBG$B_DHDR_FCODE] = .LEFT_TYPE - DBG$K_MAXIMUM_DTYPE;
    		    LEFT_ARG[DBG$B_VALUE_CLASS] = DSC$K_CLASS_Z;
    		    LEFT_ARG[DBG$B_VALUE_DTYPE] = DSC$K_DTYPE_Z;
    		    END
    		ELSE
    		    BEGIN
    		    LEFT_ARG[DBG$B_DHDR_FCODE] = RST$K_TYPE_ATOMIC;
    		    LEFT_ARG[DBG$B_VALUE_CLASS]  = DBG$MAP_DTYPE_CLASS(
    			.LEFT_TYPE, 
    			(IF .LEFT_ARG[DBG$B_VALUE_CLASS] EQL DSC$K_CLASS_SD
    			 THEN TRUE ELSE FALSE));
    		    LEFT_ARG[DBG$B_VALUE_DTYPE]  = .LEFT_TYPE;
    		    END;
    		END;
    	    END;			! End of INCR.
    	END;
    END;	! End of DBG$DO_MAPPING

GLOBAL ROUTINE DBG$EVALOP_SET_LANGUAGE (LANGUAGE) : NOVALUE = 
!
! FUNCTION
!	This routine gets called during processing of the SET LANGUAGE
!	command. It sets up the pointer to the Operator Information Table
!	and Type Conversion Information Table for the language being set.
!
! INPUTS
!	LANGUAGE	- The language code for the language being set
!
! OUTPUTS
!	NONE
!
    BEGIN


    ! Case on the language, and set the own variable OPINFO_TABLE and 
    ! CVTINFO_TABLE to point to the Operator Information Table and Type
    ! Conversion Table for that language.
    !
    CASE .LANGUAGE FROM DBG$K_MIN_LANGUAGE TO DBG$K_MAX_LANGUAGE OF
    	SET
    	[DBG$K_ADA]:
    		BEGIN
    		OPINFO_TABLE = ADA_OPINFO_TABLE;
    		CVTINFO_TABLE = ADA_CVTINFO_TABLE;
    		END;

    	[DBG$K_BASIC]:
    		BEGIN
    		OPINFO_TABLE = BASIC_OPINFO_TABLE;
    		CVTINFO_TABLE = BASIC_CVTINFO_TABLE;
    		END;

    	[DBG$K_BLISS]:
    		BEGIN
    		OPINFO_TABLE = BLISS_OPINFO_TABLE;
    		CVTINFO_TABLE = BLISS_CVTINFO_TABLE;
    		END;

    	[DBG$K_C]:
    		BEGIN
    		OPINFO_TABLE = C_OPINFO_TABLE;
    		CVTINFO_TABLE = C_CVTINFO_TABLE;
    		END;

        [DBG$K_COBOL]:
    		BEGIN
    		OPINFO_TABLE = COBOL_OPINFO_TABLE;
    		CVTINFO_TABLE = COBOL_CVTINFO_TABLE;
    		END;

    	[DBG$K_FORTRAN]:
    		BEGIN
    		OPINFO_TABLE = FORTRAN_OPINFO_TABLE;
    		CVTINFO_TABLE = FORTRAN_CVTINFO_TABLE;
    		END;

    	[DBG$K_MACRO]:
    		BEGIN
    		OPINFO_TABLE = MACRO_OPINFO_TABLE;
    		CVTINFO_TABLE = MACRO_CVTINFO_TABLE;
    		END;

    	[DBG$K_PASCAL]:
    		BEGIN
    		OPINFO_TABLE = PASCAL_OPINFO_TABLE;
    		CVTINFO_TABLE = PASCAL_CVTINFO_TABLE;
    		END;

    	[DBG$K_PLI]:
    		BEGIN
    		OPINFO_TABLE = PLI_OPINFO_TABLE;
    		CVTINFO_TABLE = PLI_CVTINFO_TABLE;
    		END;

    	[DBG$K_RPG]:
    		BEGIN
    		OPINFO_TABLE = RPG_OPINFO_TABLE;
    		CVTINFO_TABLE = RPG_CVTINFO_TABLE;
    		END;

    	[DBG$K_UNKNOWN]:
    		BEGIN
    		OPINFO_TABLE = UNKNOWN_OPINFO_TABLE;
    		CVTINFO_TABLE = UNKNOWN_CVTINFO_TABLE;
    		END;

    	[INRANGE]:
    		$DBG_ERROR ('DBGEVALOP\DBG$EVALOP_SET_LANGUAGE');

    	[OUTRANGE]:
    		BEGIN
    		OPINFO_TABLE = UNKNOWN_OPINFO_TABLE;
    		CVTINFO_TABLE = UNKNOWN_CVTINFO_TABLE;
    		END;

    	TES;


    ! Load in Type Mapping Table from Type Conversion Information Table
    ! for the current language.
    !
    MAP_TBL = .CVTINFO_TABLE[CVTINFO$L_MAPTBL] + TABLEBASE;
    IF .MAP_TBL NEQ TABLEBASE THEN MAP_TBL_SIZE = .(.MAP_TBL - 4) * 2;


    ! Load in Type Conversion Table from Type Conversion Information Table
    ! for the current language.
    !
    CVT_TBL = .CVTINFO_TABLE[CVTINFO$L_CVTTBL] + TABLEBASE;
    IF .CVT_TBL NEQ TABLEBASE THEN CVT_TBL_SIZE = .(.CVT_TBL - 4) * 1;


    ! Set up the conversion rounding flag.
    !
    CVT_ROUND_FLAG = .CVTINFO_TABLE[CVTINFO$V_ROUND];

    RETURN;
    END;

GLOBAL ROUTINE DBG$EVAL_LANG_OPERATOR (OPERATOR, LEFT_ARG, RIGHT_ARG) =
!
! FUNCTION
!	This routine does the evaluation of a language expression operator.
!
!	It determines the operand type or types, it determines what type
!	conversions must be done on the operands (if any), it calls the
!	type conversion routines to do whatever conversions are needed, it selects
!	the actual routine to do the operation based on the final operand data
!	types, and it calls the DBG$PERFORM_OPERATOR routine to actually perform
!	the selected operation.
!
!	This routine uses the Operator Routine Table for this operator to
!	determine which actual routine will do the operation on operands of
!	the given data types. If a routine is not found to handle the operation
! 	on the given types, then the Type Hierarchy Table
!	is consulted to determine what type conversions
!	may have to be done. If type conversions need to be done,  
!	DBG$TYPE_CONV is called to actually do the conversions.
!	DBG$PERFORM_OPERATOR is then called with an index specifying the desired
!	operator routine--that is where the actual operation is finally done.
!
!	The routine result Value Descriptor is then returned as the value
!	of the DBG$EVAL_LANG_OPERATOR call.  
!
!	A Primary Descriptor may be returned as the routine value as well, 
!	if the computation involved is address-valued operands as in C.
!
! INPUTS
!	OPERATOR - A pointer to the Operator Lexical Token Entry for the
!		  operator to be evaluated.
!
!	LEFT_ARG - A pointer to the left argument Descriptor.
!		  If the operator
!		  is a unary operator, LEFT_ARG points to the operator's one
!		  argument.
!
!	RIGHT_ARG - A pointer to the right argument Descriptor. 
!		  If the operator
!		  is a unary operator, RIGHT_ARG must be zero.
!
! OUTPUTS
!	A pointer to the Value Descriptor which results from the evaluation of
!		  the operator is returned as this routine's result.  Or,
!	A pointer to the Primary Descritpor.
!

    BEGIN

    MAP
	OPERATOR: REF TOKEN$ENTRY,	! Token Entry for operator to perform
	LEFT_ARG: REF DBG$VALDESC,	! Left operand Token Entry
	RIGHT_ARG: REF DBG$VALDESC;	! Right operand Token Entry

    LOCAL
        HIER_TBL: REF VECTOR [,WORD],	! Pointer to a Type Hierarchy Table
        HIER_TBL_SIZE,			! Number of entries in HIER_TBL
        INCOMP_TBL: REF VECTOR [,WORD],	! Pointer to a Type Incompatibility Table
        INCOMP_TBL_SIZE,		! Number of entries in INCOMP_TBL
        ROUT_TBL: REF ORT$TABLE,	! Pointer to an Operator Routine Table
        ROUT_TBL_SIZE,			! Number of entrie in ROUT_TBL
    	BINARY_FLAG: BYTE,		! A flag set to TRUE for binary operators
    	DIGITS,				! The number of digits for packed decimal
	LEFT_TYPE,			! Dtype for original left operand type
    	LENGTH,				! Length of the data
    	MAP_TBL_ENTRY: TYPE_GRAPH$ENTRY,! An entry in the Type Mapping Table
	NEW_LEFT_ARG: REF DBG$VALDESC,	! Pointer to left argument Token Entry
					!      after type conversion if needed
	NEW_LEFT_TYPE,			! Dtype for converted left operand type
	NEW_RIGHT_ARG: REF DBG$VALDESC,	! Pointer to right argument Token Entry
					!      after type conversion if needed
	NEW_RIGHT_TYPE,			! Dtype for converted right operand type
	OPCODE,				! Operator code for current operator
    	SD_CLASS_FLAG,			! Flag to indicate SD class overrides
	RESULT: REF DBG$VALDESC,	! Pointer to result value descriptor
    	RESULT_TYPE,			! Dtype of result of operation
	RIGHT_TYPE,			! Dtype for original right operand type
    	ROUT_TBL_INDEX,			! Index into Operator Routine Table
	ROUT_INDEX,			! Routine CASE index for code that does
					!      operation on operand types
    	SYMID: REF RST$ENTRY,		! Symid in primary descriptor
    	TYPEID,				! Pointer to a typeid
    	TYPEID_INDEX,			! Routine CASE index for code that does
    					!      typeid check
	TYPES: TYPE$PAIR;		! Type indecies for original operand
					!      types in Type Conv Table format


    ! Trap out one special case.  If the incoming token is Unary minus or
    ! Unary plus, and the unconverted bit is on, We know we have a 
    ! constant, say like -1.  We do not want to turn this -1 into negative
    ! integer right away, for those languages have packed decimal we are 
    ! not sure at this point we have an integer or packed decimal number.
    ! We make this decision at the evaluation time or depositting time.
    ! So if we have one of this token, we mark it, then simply returns.
    !
    IF .OPERATOR[TOKEN$W_CODE] EQL TOKEN$K_UNARY_PLUS OR
       .OPERATOR[TOKEN$W_CODE] EQL TOKEN$K_UNARY_MINUS
    THEN
    	BEGIN
        IF .LEFT_ARG[DBG$V_DHDR_UNCVT]
        THEN
    	    BEGIN


    	    ! In this case, there should not be any right argument.
    	    !
    	    IF .RIGHT_ARG NEQ 0
    	    THEN
    		$DBG_ERROR('DBGEVALOP\DBG$EVAL_LANG_OPERATOR, inconsistency 1');


    	    ! In this case, the left arg. should not be primary or volatile
    	    ! value descriptor.
    	    !
    	    IF (.LEFT_ARG[DBG$B_DHDR_TYPE] EQL DBG$K_PRIMARY_DESC) OR
    	       (.LEFT_ARG[DBG$B_DHDR_TYPE] EQL DBG$K_V_VALUE_DESC)
    	    THEN
    		$DBG_ERROR('DBGEVALOP\DBG$EVAL_LANG_OPERATOR, inconsistency 2');


    	    ! Mark the sign and return.  Check to see if it is already marked,
    	    ! if it is, flip the sign, for we may have -(-1) case, this is
    	    ! the same as +1.
    	    !
    	    IF .OPERATOR[TOKEN$W_CODE] EQL TOKEN$K_UNARY_MINUS
    	    THEN
    		BEGIN
    		IF .LEFT_ARG[DBG$W_VALUE_SIGN_CODE] EQL TOKEN$K_NEGCONST
    		THEN
    		    LEFT_ARG[DBG$W_VALUE_SIGN_CODE] = TOKEN$K_POSCONST
    		ELSE
    		    LEFT_ARG[DBG$W_VALUE_SIGN_CODE] = TOKEN$K_NEGCONST;
    		END

    	    ELSE
    		IF .OPERATOR[TOKEN$W_CODE] EQL TOKEN$K_UNARY_PLUS
    		THEN
    		    BEGIN
    		    IF .LEFT_ARG[DBG$W_VALUE_SIGN_CODE] EQL TOKEN$K_NEGCONST
    		    THEN
    			LEFT_ARG[DBG$W_VALUE_SIGN_CODE] = TOKEN$K_NEGCONST
    		    ELSE
    		        LEFT_ARG[DBG$W_VALUE_SIGN_CODE] = TOKEN$K_POSCONST;
    		    END

    		ELSE
    		    $DBG_ERROR('DBGEVALOP\DBG$EVAL_LANG_OPERATOR, inconsistency 3');

    	    RETURN .LEFT_ARG;
    	    END;
    	END;


    ! This is called from DBG$EVAL_LANG_OPEARTOR with TOKEN$K_NEGCONST or
    ! TOKEN$K_POSCONST token, replaced it to TOKEN$K_NEG_SIGN or
    ! TOKEN$K_POS_SIGN, so the normal unary minus or unary plus operation
    ! can take place.
    !
    IF .OPERATOR[TOKEN$W_CODE] EQL TOKEN$K_NEGCONST
    THEN
    	OPERATOR = DBG$GL_NEG_SIGN_TOKEN;

    IF .OPERATOR[TOKEN$W_CODE] EQL TOKEN$K_POSCONST
    THEN
    	OPERATOR = DBG$GL_POS_SIGN_TOKEN;


    ! Initialize table pointers and flags.
    !
    MAX_DEPTH = 1;
    IF .BLISS_BITSELECTION_FLAG1
    THEN
    	BLISS_BITSELECTION_FLAG2 = TRUE
    ELSE
        BLISS_BITSELECTION_FLAG2 = FALSE;
    BLISS_BITSELECTION_FLAG1 = FALSE;
    BLISS_INDIRECTION_FLAG = FALSE;
    OPCODE = .OPERATOR[TOKEN$W_CODE];
    DBG$GL_OPCODE_NAME = OPERATOR[TOKEN$B_OPLEN];
    BINARY_FLAG = .OPERATOR[TOKEN$B_KIND] EQL TOKEN$K_INFIX_OP;
    ROUT_TBL = .OPINFO_TABLE[.OPCODE, OPINFO$L_ROUTTBL] + TABLEBASE;
    IF .ROUT_TBL EQL TABLEBASE
    THEN
    	BEGIN
    	IF .OPCODE NEQ TOKEN$K_DEPOSIT AND .OPCODE NEQ TOKEN$K_CONVERT
    	AND .OPCODE NEQ TOKEN$K_IDENTITY
    	THEN
    	    $DBG_ERROR ('DBGEVALOP\DBG$EVAL_LANG_OPERATOR routine table missing');
    	END
    ELSE
        ROUT_TBL_SIZE = .(.ROUT_TBL - 4) / 2;
    HIER_TBL = .OPINFO_TABLE[.OPCODE, OPINFO$L_HIERTBL] + TABLEBASE;
    IF .HIER_TBL NEQ TABLEBASE
    THEN 
    	BEGIN
    	HIER_TBL_SIZE = .(.HIER_TBL - 4) * 2;
    	MAX_DEPTH = .MAX_DEPTH + .HIER_TBL_SIZE * 2;
    	END;
    INCOMP_TBL = .OPINFO_TABLE[.OPCODE, OPINFO$L_INCOMPTBL] + TABLEBASE;
    IF .INCOMP_TBL NEQ TABLEBASE THEN INCOMP_TBL_SIZE = .(.INCOMP_TBL - 4) * 2;


    ! Convert primary descriptors or volatile value descriptors
    ! to value descriptors. Something should be done to
    ! clean up the structure of the code below. The basic idea of what
    ! it is doing is:
    ! If we get a Primary for "X", say, or a volatile value descriptor for
    ! address "200" in the user program, then:
    ! - If the language does an implicit fetch on operands (i.e., all languages
    !   except BLISS and MACRO), then we do the fetch here by calling PRIM_TO_VAL.
    ! - For BLISS and MACRO we call PRIM_TO_ADDR in order to get the address
    !   of the operand into a value descriptor.
    ! - Special case for arrays in C.
    ! - Special case for records in COBOL.
    ! (It's these special cases that make the code such a mess.)
    !
    IF (.LEFT_ARG[DBG$B_DHDR_TYPE] EQL DBG$K_PRIMARY_DESC) OR
       (.LEFT_ARG[DBG$B_DHDR_TYPE] EQL DBG$K_V_VALUE_DESC) 
    THEN

    	! Most operators in most languages do an implicit fetch on primaries. 
    	! E.g., in FORTRAN, if we say EV X we want to fetch the value at X.
    	! DBG$PRIM_TO_VAL is the routine that converts primaries to value
    	! descriptors, and does the fetch in the process.
    	! The exceptions are: in BLISS, we only do the fetch when we see
    	! the fetch operator (.). Also, for the "address of" operator
    	! (& in C), we want to suppress this fetch. For these cases,
    	! we use a routine DBG$PRIM_TO_ADDR which converts a primary
    	! descriptor to a value descriptor containing the address of the
    	! primary.

    	! We consult a flag in the Operator Information Table that tells
    	! us whether or not to do this fetch.
    	!
    	IF .OPINFO_TABLE [.OPCODE, OPINFO$V_FETCH]
    	THEN
    	    BEGIN
    	    BLISS_INDIRECTION_FLAG = TRUE;
    	
    	    ! Special case for arrays in C. We want to treat un-subscripted
    	    ! arrays as pointers, and be able to add, subtract, and do
    	    ! dereferencing on the addresses.
    	    !
    	    IF  (.DBG$GB_LANGUAGE EQL DBG$K_C)
    	    AND (.LEFT_ARG[DBG$B_DHDR_FCODE] EQL RST$K_TYPE_ARRAY)
    	    THEN
    		BEGIN

    		! Save the typeid.
    		!
    		TYPEID = .LEFT_ARG[DBG$L_DHDR_TYPEID];

    		! Build a descriptor with the address of the array.
    		!
    	        IF NOT DBG$PRIM_TO_ADDR(.LEFT_ARG, DSC$K_DTYPE_L, LEFT_ARG)
   	        THEN
    		    $DBG_ERROR('DBGEVALOP\DBGEVAL_LANG_OPERATOR, prim to addr failed');
    		    
    		! Dummy in the FCODE as TPTR. Also fill in the typeid.
    		!
    		LEFT_ARG[DBG$B_DHDR_FCODE] = RST$K_TYPE_TPTR;
    		LEFT_ARG[DBG$L_DHDR_TYPEID] = .TYPEID;
    		END

    	    ELSE 
    		BEGIN

    		! If we have an aggregate, first try calling the
    		! routine that turns a 1-dimensional array of characters
    		! into a string.
    		!
    		IF .LEFT_ARG[DBG$V_DHDR_AGGR]
    		THEN
    		    DBG$COLLECT(.LEFT_ARG);

    		! If we still have an aggregate, we check for the special
    		! case of COBOL records. For all other cases, we signal
    		! an error, because operations on aggregates are not
    		! supported.
    		!
    		SYMID = 0;
        	IF .LEFT_ARG[DBG$V_DHDR_AGGR]
    		THEN    	
    		    BEGIN
    		    IF .LEFT_ARG[DBG$B_DHDR_FCODE] NEQ RST$K_TYPE_RECORD
    		    THEN
    		        SIGNAL(DBG$_NOVALUE);


    		    ! This is record aggregate, if the language code is cobol, treated as text string.
    		    !
    		    SYMID = .LEFT_ARG[DBG$L_DHDR_SYMID0];
    		    IF .SYMID EQL 0 THEN SIGNAL(DBG$_NOVALUE);
    		    WHILE .SYMID[RST$B_KIND] NEQ RST$K_MODULE DO
    			BEGIN    			
    			SYMID = .SYMID[RST$L_UPSCOPEPTR];
    		        IF .SYMID EQL 0 THEN SIGNAL(DBG$_NOVALUE);
    			END;
    		    IF .SYMID[RST$B_LANGUAGE] NEQ DBG$K_COBOL
	 	    THEN
			SIGNAL(DBG$_NOVALUE);
    		    END;

    		IF NOT DBG$PRIM_TO_VAL(.LEFT_ARG, DBG$K_VALUE_DESC, LEFT_ARG)
    	    	THEN
    	            $DBG_ERROR('DBGEVALOP\DBG$EVAL_LANG_OPERATOR, prim to val failed');

    		END;
    	    END

    	ELSE
    	    IF NOT DBG$PRIM_TO_ADDR(.LEFT_ARG, DSC$K_DTYPE_L, LEFT_ARG)
   	    THEN
		$DBG_ERROR('DBGEVALOP\DBGEVAL_LANG_OPERATOR, prim to addr failed');


    ! If this is a binary operator, do the same for the right operand.
    !
    IF .BINARY_FLAG
    THEN
        IF (.RIGHT_ARG[DBG$B_DHDR_TYPE] EQL DBG$K_PRIMARY_DESC) OR
    	   ((.RIGHT_ARG[DBG$B_DHDR_TYPE] EQL DBG$K_V_VALUE_DESC) AND
    	    (.OPCODE NEQ TOKEN$K_DEPOSIT) AND (.OPCODE NEQ TOKEN$K_CONVERT))
        THEN
    	    IF .OPINFO_TABLE [.OPCODE, OPINFO$V_FETCH]
    	    THEN
    		BEGIN
    	        BLISS_INDIRECTION_FLAG = TRUE;

    	        ! Special case for arrays in C. We want to treat un-subscripted
    	        ! arrays as pointers, and be able to add, subtract, and do
    	        ! dereferencing on the addresses.
    	        !
    	        IF (.DBG$GB_LANGUAGE EQL DBG$K_C) AND
    	           (.RIGHT_ARG[DBG$B_DHDR_FCODE] EQL RST$K_TYPE_ARRAY)
    	        THEN
    		    BEGIN

    		    ! Save the typeid.
    		    !
    		    TYPEID = .RIGHT_ARG[DBG$L_DHDR_TYPEID];

    		    ! Build a descriptor with the address of the array.
    		    !
    	            IF NOT DBG$PRIM_TO_ADDR(.RIGHT_ARG, DSC$K_DTYPE_L, RIGHT_ARG)
   	            THEN
    			$DBG_ERROR('DBGEVALOP\DBGEVAL_LANG_OPERATOR, prim to addr failed');
    		    
    		    ! Dummy in the FCODE as TPTR. Also fill in the typeid.
    		    !
    		    RIGHT_ARG[DBG$B_DHDR_FCODE] = RST$K_TYPE_TPTR;
    		    RIGHT_ARG[DBG$L_DHDR_TYPEID] = .TYPEID;
    		    END

    	    	ELSE 
    		    BEGIN

    		    
    		    ! If we have an aggregate, first try calling the
    		    ! routine that turns a 1-dimensional array of characters
    		    ! into a string.
    		    !
    		    IF .RIGHT_ARG[DBG$V_DHDR_AGGR]
    		    THEN
    		        DBG$COLLECT(.RIGHT_ARG);

    		    ! If we still have an aggregate, we check for the special
    		    ! case of COBOL records. For all other cases, we signal
    		    ! an error, because operations on aggregates are not
    		    ! supported.
    	 	    !
    		    SYMID = 0;
        	    IF .RIGHT_ARG[DBG$V_DHDR_AGGR]
    		    THEN    		
    		        BEGIN
    		        IF .RIGHT_ARG[DBG$B_DHDR_FCODE] NEQ RST$K_TYPE_RECORD
    		        THEN
    		            SIGNAL(DBG$_NOVALUE);


    		        ! This is record aggregate, if the language code is cobol, treated as text string.
    		        !
    		        SYMID = .RIGHT_ARG[DBG$L_DHDR_SYMID0];
    		        IF .SYMID EQL 0 THEN SIGNAL(DBG$_NOVALUE);
    			WHILE .SYMID[RST$B_KIND] NEQ RST$K_MODULE DO
    			    BEGIN
    			    SYMID = .SYMID[RST$L_UPSCOPEPTR];
    		            IF .SYMID EQL 0 THEN SIGNAL(DBG$_NOVALUE);
    			    END;
    			IF .SYMID[RST$B_LANGUAGE] NEQ DBG$K_COBOL
    			THEN
    			    SIGNAL(DBG$_NOVALUE);
    		        END;

    		    IF NOT DBG$PRIM_TO_VAL(.RIGHT_ARG, DBG$K_VALUE_DESC, RIGHT_ARG)
    	    	    THEN
    	                $DBG_ERROR('DBGEVALOP\DBG$EVAL_LANG_OPERATOR, prim to val failed');

    		    END;
    		END
    	    ELSE
    		IF NOT DBG$PRIM_TO_ADDR(.RIGHT_ARG, DSC$K_DTYPE_L, RIGHT_ARG)
   		THEN
		    $DBG_ERROR('DBGEVALOP\DBGEVAL_LANG_OPERATOR, prim to addr failed');


    ! Take care of DEP rfa data type = constant case.
    !
    IF .OPCODE EQL TOKEN$K_DEPOSIT
    THEN
    	BEGIN
        IF .LEFT_ARG[DBG$V_DHDR_UNCVT]
        THEN
    	    BEGIN
            IF .RIGHT_ARG[DBG$B_DHDR_FCODE] EQL RST$K_TYPE_RFA
            THEN
    		BEGIN
    		LEFT_ARG[DBG$L_DHDR_TYPEID] = .RIGHT_ARG[DBG$L_DHDR_TYPEID];
    		LEFT_ARG = DBG$CONV_TRFA_VALUE(.LEFT_ARG);
    		END;
    	    END;
    	END;
    		

    ! At this point we should have value descriptors.  Perform special
    ! NRO Data type map check for RPG.
    !
    IF .DBG$GB_LANGUAGE EQL DBG$K_RPG
    THEN
    	BEGIN
    	IF .LEFT_ARG[DBG$B_VALUE_DTYPE] EQL DSC$K_DTYPE_NRO
    	THEN
    	    LEFT_ARG = MAP_NRO_DTYPE_IN_RPG(.LEFT_ARG);

        IF .BINARY_FLAG
    	THEN
    	    BEGIN
    	    IF (.OPCODE NEQ TOKEN$K_DEPOSIT AND
    		.OPCODE NEQ TOKEN$K_CONVERT)
    	    THEN
    		IF .RIGHT_ARG[DBG$B_VALUE_DTYPE] EQL DSC$K_DTYPE_NRO
    		THEN
    		    RIGHT_ARG = MAP_NRO_DTYPE_IN_RPG(.RIGHT_ARG);
    	    END;
    	END;


    ! Take care of the [] (empty set).
    !
    IF .LEFT_ARG[DBG$B_DHDR_LANG] EQL %X'FF' AND
       .LEFT_ARG[DBG$B_VALUE_CLASS] EQL %X'FF' AND
       .LEFT_ARG[DBG$B_VALUE_DTYPE] EQL %X'FF'
    THEN
    	LEFT_ARG = FIXUP_EMPTY_SET(.LEFT_ARG, .RIGHT_ARG);

    IF .BINARY_FLAG
    THEN
        IF .RIGHT_ARG[DBG$B_DHDR_LANG] EQL %X'FF' AND
           .RIGHT_ARG[DBG$B_VALUE_CLASS] EQL %X'FF' AND
           .RIGHT_ARG[DBG$B_VALUE_DTYPE] EQL %X'FF'
        THEN
    	    RIGHT_ARG = FIXUP_EMPTY_SET(.RIGHT_ARG, .LEFT_ARG);

    	
    ! Perform "type mapping". Do not map left-hand-side of deposit when
    ! override applied.
    !
    DBG$DO_MAPPING(.LEFT_ARG);
    IF .BINARY_FLAG
    THEN
        IF (.OPCODE NEQ TOKEN$K_DEPOSIT) OR
           (NOT .RIGHT_ARG [DBG$V_DHDR_OVERRIDE])
        THEN
            DBG$DO_MAPPING(.RIGHT_ARG);


    ! Get a Type for the left operand.  
    !
    LEFT_TYPE = DBG$GET_DTYPE (.LEFT_ARG);
    NEW_LEFT_TYPE = .LEFT_TYPE;


    ! Get a Type for the right operand.  
    !
    IF .BINARY_FLAG THEN
        BEGIN
    	RIGHT_TYPE = DBG$GET_DTYPE (.RIGHT_ARG);
        NEW_RIGHT_TYPE = .RIGHT_TYPE;
    	END

    ! Unary operator.
    !
    ELSE
	BEGIN
	RIGHT_TYPE = 0;
	NEW_RIGHT_TYPE = 0;
	END;


    ! If we are processing the identity operator, then just return
    ! the left argument here.  Before we return, check to see if any
    ! unconverted is left undone.  Make sure we take care of the
    ! unary minus/unary plus case that was returned from earlier
    ! call.  (Note: if you EV -1, -1 was not converted the first
    ! time around, now we are hit by this token$k_identity and
    ! unconverted constant).
    !
    IF .OPCODE EQL TOKEN$K_IDENTITY
    THEN
    	BEGIN
    	IF .LEFT_ARG[DBG$V_DHDR_UNCVT]
    	THEN
    	    LEFT_ARG = DBG$CONV_TEXT_VALUE(.LEFT_ARG, .LEFT_ARG, 0);

    	RETURN .LEFT_ARG;
    	END;


    ! Consult the Type Hierarchy Table to see if any data type conversions need
    ! to be done.
    !
    ! There are basically three cases here. They all use the hierarchy table,
    ! but in different ways. The FIND_PATH and FIND_JOIN routines also
    ! use the Operator Routine Table.
    !
    ! 1. Binary operators, such as +, which may do implicit conversions on
    ! their operands. Here we call the FIND_JOIN routine. This routine assumes
    ! we are trying to convert both left and right operand to the same type.
    ! It finds a type that both can be converted to and which is legal for
    ! the given operator. If there are several such types, it chooses the
    ! one with the shortest conversion path.
    !
    ! 2. Unary operators. Here we call the FIND_PATH routine. This tries
    ! to find a type that the operand can be converted to which is legal
    ! for the given operator. If there are several, it chooses the one 
    ! with the shortest conversion path.
    !
    ! 3. The ASSIGNMENT operator and the CONVERT operator. Here we know
    ! the target type, and we are just trying to determine if there is 
    ! a path from the source type. We use the routine FIND_PATH_DEPOSIT
    ! to determine this.
    !
    IF .BINARY_FLAG
    THEN
    	BEGIN


	! If an override was present on the DEPOSIT command, e.g.,
	! DEPOSIT/FLOAT 1000 = 1.1
	! then we skip the FIND_PATH_DEPOSIT routine which checks whether
	! the deposit is legal in the current language. We just call
	! the TYPE_CONV_DEBUG routine directly to do the deposit in a
	! language-independent fashion. Also call the routine directly
    	! for instruction deposits.
    	!
	IF .OPCODE EQL TOKEN$K_DEPOSIT 
    	AND (.RIGHT_ARG [DBG$V_DHDR_OVERRIDE]
    	  OR (.LEFT_TYPE EQL DSC$K_DTYPE_T AND .RIGHT_TYPE EQL DSC$K_DTYPE_ZI))
	THEN
    	    BEGIN
    	    IF .LEFT_ARG[DBG$V_DHDR_UNCVT]
    	    THEN
    		LEFT_ARG = DBG$CONV_TEXT_VALUE(.LEFT_ARG, .LEFT_ARG, .RIGHT_TYPE);

    	    RETURN DBG$COVER_DX_DX (.LEFT_ARG, .RIGHT_ARG, .CVT_ROUND_FLAG);
    	    END;


    	! Check for the special data, FCODE = PICT, DTYPE = T. for DEPOSIT.
    	! In Type Hierd. table, this case is catched by DBG$K_DTYPE_PICT.
    	! If both operands are text data, then we want to treat this as 
    	! standard Text String.
    	!
    	IF .OPCODE EQL TOKEN$K_DEPOSIT OR
    	   .OPCODE EQL TOKEN$K_CONVERT
    	THEN
    	    BEGIN
    	    IF .RIGHT_ARG[DBG$B_DHDR_FCODE] EQL RST$K_TYPE_PICT AND
    	       .LEFT_ARG[DBG$B_VALUE_DTYPE] NEQ DSC$K_DTYPE_T AND
    	       .DBG$GB_LANGUAGE EQL DBG$K_COBOL
    	    THEN
    		NEW_RIGHT_TYPE = DBG$K_DTYPE_PICT;
    	    END;


    	IF .OPCODE EQL TOKEN$K_DEPOSIT OR .OPCODE EQL TOKEN$K_CONVERT 
    	THEN
    	    IF FIND_PATH_DEPOSIT (.NEW_LEFT_TYPE, .NEW_RIGHT_TYPE, 0, 
    		.HIER_TBL, .HIER_TBL_SIZE, 
    		.INCOMP_TBL, .INCOMP_TBL_SIZE,
    		.ROUT_TBL, .ROUT_TBL_SIZE)
    	    THEN
    		BEGIN


	        ! Change the dtype for date type PICT, so the LANGUAGE type
    		! conversion can take place.
    		!
    		IF .RIGHT_ARG[DBG$B_DHDR_FCODE] EQL RST$K_TYPE_PICT AND
    		   .LEFT_ARG[DBG$B_VALUE_DTYPE] NEQ DSC$K_DTYPE_T AND
    		   .DBG$GB_LANGUAGE EQL DBG$K_COBOL
    		THEN
    		    RIGHT_ARG[DBG$B_VALUE_DTYPE] = DBG$K_DTYPE_PICT;


    		! If the target is SD, make the new type to be packed.
    		!
    		IF (.RIGHT_ARG[DBG$B_VALUE_CLASS] EQL DSC$K_CLASS_SD) AND
    		   (NOT .RIGHT_ARG[DBG$V_VALUE_FL_BINSCALE])
    		THEN
    		    NEW_RIGHT_TYPE = DSC$K_DTYPE_P;


    		! Check for unconverted bit.  At this point, long interger
    		! string or floating string may be converted to Packed 
    		! decimal if the new_right_type is a Packed decimal data item.
    		!
    		IF .LEFT_ARG[DBG$V_DHDR_UNCVT]
    		THEN
    		    BEGIN


    		    ! This is a special case in COBOL.  We can only take the value
    		    ! and deposit it into unsigned variable. 
    		    ! For example: DEP C4V4 (SD, WU) = -1234.1234.  The value
    		    ! in C4V4 is 1234.1234.
    		    !
    		    IF .DBG$GB_LANGUAGE EQL DBG$K_COBOL OR
    		       .DBG$GB_LANGUAGE EQL DBG$K_RPG
    		    THEN
    		        BEGIN


    		        ! Check to see if the target is unsigned data type.
    		        !
    		        IF .RIGHT_ARG[DBG$B_VALUE_DTYPE] EQL DSC$K_DTYPE_WU OR
    		           .RIGHT_ARG[DBG$B_VALUE_DTYPE] EQL DSC$K_DTYPE_LU OR
    		           .RIGHT_ARG[DBG$B_VALUE_DTYPE] EQL DSC$K_DTYPE_QU OR
    		           .RIGHT_ARG[DBG$B_VALUE_DTYPE] EQL DSC$K_DTYPE_NU
    		        THEN
    			    BEGIN
    			    IF .LEFT_ARG[DBG$W_VALUE_SIGN_CODE] EQL TOKEN$K_NEGCONST
    			    THEN
    				BEGIN
    				LEFT_ARG[DBG$W_VALUE_SIGN_CODE] = TOKEN$K_POSCONST;
    			        SIGNAL(DBG$_IVALOUTBNDS, 1, OPERATOR[TOKEN$B_OPLEN]);
    				END;

    			    END;

    			END;
    		
    		    LEFT_ARG = DBG$CONV_TEXT_VALUE(.LEFT_ARG, .LEFT_ARG,
    						   .RIGHT_TYPE); 
    		    END;


	        ! There are cases the intermediate data type is needed
    		! before the deposit, for example, DEP P=F, F needs to
    		! convert to Packed decimal before deposit into P.
    		!
    		IF ((.RIGHT_ARG[DBG$B_VALUE_CLASS] EQL DSC$K_CLASS_SD) AND
    		    (NOT .RIGHT_ARG[DBG$V_VALUE_FL_BINSCALE])) OR
    		   (.RIGHT_ARG[DBG$B_VALUE_DTYPE] EQL DSC$K_DTYPE_P) OR
    		   (.RIGHT_ARG[DBG$B_VALUE_DTYPE] EQL DSC$K_DTYPE_NU) OR
    		   (.RIGHT_ARG[DBG$B_VALUE_DTYPE] EQL DBG$K_DTYPE_PICT)
    	        THEN
    		    LEFT_ARG = INTMED_DATA_FOR_DEP(.LEFT_ARG, DSC$K_DTYPE_P,
    			FALSE);


    		! We catch none-constant cases in here, for the ease of checking
    		! sign for different data types.  In cobol, we should have
    		! the source converted into Packed decimal at this point.
    		! (in intermediate).
    		!
	        ! This is a special case in COBOL.  We can only take the value
    		! and deposit it into unsigned variable. 
    		! For example: DEP C4V4 (SD, WU) = SC4V4 (SD, W)  The value
    		! in C4V4 is 1234.1234, in SC4V4 is -1234.1234.
    		!
    		IF .DBG$GB_LANGUAGE EQL DBG$K_COBOL OR
    		   .DBG$GB_LANGUAGE EQL DBG$K_RPG
    		THEN
    		    BEGIN


    		    ! Check to see if the target is unsigned data type.
    		    !
    		    IF (.RIGHT_ARG[DBG$B_VALUE_DTYPE] EQL DSC$K_DTYPE_WU OR
    		        .RIGHT_ARG[DBG$B_VALUE_DTYPE] EQL DSC$K_DTYPE_LU OR
    		        .RIGHT_ARG[DBG$B_VALUE_DTYPE] EQL DSC$K_DTYPE_QU OR
    		        .RIGHT_ARG[DBG$B_VALUE_DTYPE] EQL DSC$K_DTYPE_NU) AND
    		       (.LEFT_ARG[DBG$B_VALUE_DTYPE] EQL DSC$K_DTYPE_P)
    		    THEN
    			BEGIN
    			LOCAL DIG, SIGN: BYTE, SIGN_POS: REF VECTOR[,BYTE];


    			! Find out the sign position in number string.
    			!
    			DIG = .LEFT_ARG[DBG$W_VALUE_LENGTH];
    			SIGN_POS = .LEFT_ARG[DBG$L_VALUE_POINTER] 
    				+ (.DIG / 2 + 1) - 1;


    			! Make it into positive.
    			!
    			SIGN = .SIGN_POS[0] AND %X'0D';
    			IF .SIGN EQL %X'0D'
    			THEN
    			    BEGIN
    			    SIGN_POS[0] = .SIGN_POS[0] AND %X'FE';
    			    SIGNAL(DBG$_IVALOUTBNDS, 1, OPERATOR[TOKEN$B_OPLEN]);
    			    END;

    			END;

    		    END;


    		! The following case is done for COBOL only.  In cobol, 
    		! if we do DEP sc2v2=999.888, sc2v2 is (SD, W with digits 4 and
    		! scaled -2). the answer we want is 99.88, instead of -310.xx.
    		! However if there is no digits specified in the Descriptor
    		! the base digits used is 5 then you'll get -310.xx as an
    		! answer.
    		!
    		! The following code is a hack to force the type convertor
    		! to do the right thing for cobol, for example, if we deposit 
    		! into a SD integer type, the way we make the type convertor to
    		! do the right thing is to create an intermediate data type of 
    		! (SD, P) for left hand side as well, so the path looks like:
    		! right hand side converts (SD, P), creates a (SD, P) descriptor
    		! for left hand side, performs conversion from right (SD, P) to
    		! left (SD, P), final converts right (SD, P) to right hand side.
    		!
    		IF .DBG$GB_LANGUAGE EQL DBG$K_COBOL OR
    		   .DBG$GB_LANGUAGE EQL DBG$K_RPG
    		THEN
    		    BEGIN
    		    IF .RIGHT_ARG[DBG$B_VALUE_CLASS] EQL DSC$K_CLASS_SD
    		    THEN
    		        BEGIN


    		        ! Get the SD, P form intermediate data for the left hand side.
    		        ! Create a place holder.  Note, the intermediate may not
    			! be created, for example, if we deposit P-->P, there
    			! is no need for it.  So the NEW_RIGHT_ARG may be the
    			! same as RIGHT_ARG.
    			!
    		        NEW_RIGHT_ARG = INTMED_DATA_FOR_DEP(.RIGHT_ARG, DSC$K_DTYPE_P, 
    				TRUE);


    		        ! Perform convert from intermediate to intermediate.  The last
    		        ! conversion is convert the intermediate to original left
    		        ! hand side data type.
    		        !
    			IF .NEW_RIGHT_ARG NEQ .RIGHT_ARG
    			THEN
    			    BEGIN
    		            LEFT_ARG = DBG$TYPE_CONV(.LEFT_ARG, .NEW_RIGHT_ARG);
    			    END;
    		        END;
    		    END;

    		RIGHT_ARG = DBG$TYPE_CONV (.LEFT_ARG, .RIGHT_ARG);

    		IF .RIGHT_ARG[DBG$B_DHDR_FCODE] EQL RST$K_TYPE_PICT AND
    		   .RIGHT_ARG[DBG$B_VALUE_DTYPE] EQL DBG$K_DTYPE_PICT AND
    	           .DBG$GB_LANGUAGE EQL DBG$K_COBOL
    		THEN
    		    RIGHT_ARG[DBG$B_VALUE_DTYPE] = DSC$K_DTYPE_T;

    		RETURN .RIGHT_ARG;
    		END

    	    ELSE
    		SIGNAL(DBG$_OPNOTALLOW, 1, OPERATOR[TOKEN$B_OPLEN])

    	ELSE 
	    BEGIN
    	    IF .DBG$GB_LANGUAGE EQL DBG$K_BASIC
    	    THEN
    		BEGIN
	        IF .NEW_LEFT_TYPE EQL DSC$K_DTYPE_P 
	        THEN
		    MAP_PACKED (NEW_LEFT_TYPE, .LEFT_ARG[DBG$W_VALUE_LENGTH], .NEW_RIGHT_TYPE)
	        ELSE
		    IF .NEW_RIGHT_TYPE EQL DSC$K_DTYPE_P
		    THEN
		        MAP_PACKED (NEW_RIGHT_TYPE, .RIGHT_ARG[DBG$W_VALUE_LENGTH], .NEW_LEFT_TYPE);

    		END;

    	    IF .MAX_DEPTH EQL FIND_JOIN(
    		.NEW_LEFT_TYPE, .NEW_RIGHT_TYPE,
    		 NEW_LEFT_TYPE,  NEW_RIGHT_TYPE, 
    		 ROUT_TBL_INDEX,
    		 0, .MAX_DEPTH,
    		.HIER_TBL, .HIER_TBL_SIZE, 
    		.INCOMP_TBL, .INCOMP_TBL_SIZE,
    		.ROUT_TBL, .ROUT_TBL_SIZE)
    	    THEN
	        SIGNAL(DBG$_OPNOTALLOW, 1, OPERATOR[TOKEN$B_OPLEN]);

	    END;

    	END

    ELSE
    	BEGIN
    	IF .MAX_DEPTH EQL FIND_PATH(
    		.NEW_LEFT_TYPE, NEW_LEFT_TYPE, 
    		ROUT_TBL_INDEX,
    		.HIER_TBL, .HIER_TBL_SIZE, 
    		.INCOMP_TBL, .INCOMP_TBL_SIZE,
    		.ROUT_TBL, .ROUT_TBL_SIZE)
    	THEN
	    SIGNAL(DBG$_OPNOTALLOW, 1, OPERATOR[TOKEN$B_OPLEN]);

    	END;


    ! If one of the operand has T, VT, V, or VU in relational and arithmetic
    ! operation in PLI.  The target type for T, VT, V, or VU depends on
    ! the other operand.  This is not what we do normally.  So, we use
    ! the normal way to validate the operand, and then use this routine
    ! to modify the other information.  This is not the best way to do
    ! it, but there is no other way I can think of is easier.
    !
    IF .BINARY_FLAG AND
       .DBG$GB_LANGUAGE EQL DBG$K_PLI 
    THEN
        MODIFY_PLI_TARGET_TYPE(.OPERATOR, .LEFT_TYPE, .RIGHT_TYPE,
    		NEW_LEFT_TYPE, NEW_RIGHT_TYPE, ROUT_TBL_INDEX,
    		.HIER_TBL, .HIER_TBL_SIZE,
    		.INCOMP_TBL, .INCOMP_TBL_SIZE,
    		.ROUT_TBL, .ROUT_TBL_SIZE);


    ! Check for unconverted bit.
    !
    IF .LEFT_ARG[DBG$V_DHDR_UNCVT]
    THEN
    	LEFT_ARG = DBG$CONV_TEXT_VALUE(.LEFT_ARG, .LEFT_ARG, .NEW_LEFT_TYPE);


    ! For the left operand, check whether we need to convert to a new type.
    ! If so, allocate space to hold the result value descriptor, and then
    ! call a routine to do the conversion. 
    !
    IF .LEFT_TYPE NEQ .NEW_LEFT_TYPE
    THEN
    	BEGIN
    	LENGTH = GET_DATA_LENGTH(.LEFT_TYPE, .NEW_LEFT_TYPE,
    	    .LEFT_ARG[DBG$W_VALUE_LENGTH]);
    	SD_CLASS_FLAG = FALSE;
    	IF .DBG$GB_LANGUAGE EQL DBG$K_COBOL OR
           .DBG$GB_LANGUAGE EQL DBG$K_RPG
    	THEN
    	    BEGIN
    	    IF .LEFT_ARG[DBG$B_VALUE_CLASS] EQL DSC$K_CLASS_SD
    	    THEN
    		SD_CLASS_FLAG = TRUE;
    	    END;

    	NEW_LEFT_ARG = MAKE_VAL_DESC(.NEW_LEFT_TYPE, 
    				     .LENGTH,
    				     .LEFT_ARG,
    				     .SD_CLASS_FLAG);

    	IF .NEW_LEFT_ARG[DBG$B_VALUE_CLASS] EQL DSC$K_CLASS_SD
    	THEN
    	    BEGIN


    	    ! If left_arg is one of the floating-point data type, we need to
    	    ! get the exponent value and that is the scaling factor.  For
    	    ! example F --> P, F = 0.1234567E+04  --> P = 1234.567.
    	    !
    	    IF .LEFT_ARG[DBG$B_VALUE_DTYPE] EQL DSC$K_DTYPE_F OR
    	       .LEFT_ARG[DBG$B_VALUE_DTYPE] EQL DSC$K_DTYPE_D OR
    	       .LEFT_ARG[DBG$B_VALUE_DTYPE] EQL DSC$K_DTYPE_G OR
    	       .LEFT_ARG[DBG$B_VALUE_DTYPE] EQL DSC$K_DTYPE_H
    	    THEN
    		BEGIN
    		NEW_LEFT_ARG[DBG$B_VALUE_SCALE] =  GET_SCALE(.LEFT_ARG, DIGITS);
    		NEW_LEFT_ARG[DBG$B_VALUE_DIGITS] = .DIGITS;
    		NEW_LEFT_ARG[DBG$W_VALUE_LENGTH] = .DIGITS;
    		END

    	    ELSE
    	        NEW_LEFT_ARG[DBG$B_VALUE_SCALE] = .LEFT_ARG[DBG$B_VALUE_SCALE];
    	    END;

    	NEW_LEFT_ARG = DBG$TYPE_CONV (.LEFT_ARG, .NEW_LEFT_ARG);
    	END
    

    ! If there is no conversion to be done, just copy the left arg 
    ! into NEW_LEFT_ARG.
    !
    ELSE
        NEW_LEFT_ARG = .LEFT_ARG;


    ! Check for unconverted bit.
    !
    IF .BINARY_FLAG
    THEN
    	IF .RIGHT_ARG[DBG$V_DHDR_UNCVT]
        THEN
    	    RIGHT_ARG = DBG$CONV_TEXT_VALUE(.RIGHT_ARG, .RIGHT_ARG, .NEW_RIGHT_TYPE);


    ! If this is a binary operator, do the same for the right argument.
    !
    IF .BINARY_FLAG
    THEN
    	IF .RIGHT_TYPE NEQ .NEW_RIGHT_TYPE
    	THEN
    	    BEGIN
    	    LENGTH = GET_DATA_LENGTH(.RIGHT_TYPE, .NEW_RIGHT_TYPE,
    		.RIGHT_ARG[DBG$W_VALUE_LENGTH]);
    	    SD_CLASS_FLAG = FALSE;
    	    IF .DBG$GB_LANGUAGE EQL DBG$K_COBOL OR
               .DBG$GB_LANGUAGE EQL DBG$K_RPG
    	    THEN
    	        BEGIN
    	        IF .RIGHT_ARG[DBG$B_VALUE_CLASS] EQL DSC$K_CLASS_SD
    	        THEN
    		    SD_CLASS_FLAG = TRUE;
    	        END;

    	    NEW_RIGHT_ARG = MAKE_VAL_DESC(.NEW_RIGHT_TYPE, 
    					  .LENGTH,
    					  .RIGHT_ARG,
    					  .SD_CLASS_FLAG);

    	    IF .NEW_RIGHT_ARG[DBG$B_VALUE_CLASS] EQL DSC$K_CLASS_SD
    	    THEN
    		BEGIN

    	        ! If right_arg is one of the floating-point data type, we need to
    	        ! get the exponent value and that is the scaling factor.  For
    		! example F --> P, F = 0.1234567E+04  --> P = 1234.567.
    	        !
    	        IF .RIGHT_ARG[DBG$B_VALUE_DTYPE] EQL DSC$K_DTYPE_F OR
    	           .RIGHT_ARG[DBG$B_VALUE_DTYPE] EQL DSC$K_DTYPE_D OR
    	           .RIGHT_ARG[DBG$B_VALUE_DTYPE] EQL DSC$K_DTYPE_G OR
    	           .RIGHT_ARG[DBG$B_VALUE_DTYPE] EQL DSC$K_DTYPE_H
    	        THEN
    		    BEGIN
    		    NEW_RIGHT_ARG[DBG$B_VALUE_SCALE] =  GET_SCALE(.RIGHT_ARG, DIGITS);
    		    NEW_RIGHT_ARG[DBG$B_VALUE_DIGITS] = .DIGITS;
    		    NEW_RIGHT_ARG[DBG$W_VALUE_LENGTH] = .DIGITS;
    		    END

    	        ELSE
    	            NEW_RIGHT_ARG[DBG$B_VALUE_SCALE] = .RIGHT_ARG[DBG$B_VALUE_SCALE];
    		END;

            NEW_RIGHT_ARG = DBG$TYPE_CONV (.RIGHT_ARG, .NEW_RIGHT_ARG);
    	    END

        ELSE
    	    NEW_RIGHT_ARG = .RIGHT_ARG;


    ROUT_INDEX = .ROUT_TBL[.ROUT_TBL_INDEX, ORT$W_ROUT];
    TYPEID_INDEX = .ROUT_TBL[.ROUT_TBL_INDEX, ORT$W_TYPEID_ROUT];
    RESULT_TYPE = .ROUT_TBL[.ROUT_TBL_INDEX, ORT$B_RESULT_TYPE];
    IF (.NEW_LEFT_ARG[DBG$B_VALUE_CLASS] EQL DSC$K_CLASS_SD) OR
       (.BINARY_FLAG AND (.NEW_RIGHT_ARG[DBG$B_VALUE_CLASS] EQL DSC$K_CLASS_SD))
    THEN 
    	SD_CLASS_FLAG = TRUE 
    ELSE 
    	SD_CLASS_FLAG = FALSE;

    LENGTH = 0;
    IF .ROUT_INDEX EQL ORT$K_CONCAT_T_T OR
       .ROUT_INDEX EQL ORT$K_CONCAT_TF_TF
    THEN
    	LENGTH = .NEW_LEFT_ARG[DBG$W_VALUE_LENGTH] + 
    		 .NEW_RIGHT_ARG[DBG$W_VALUE_LENGTH];

    IF .LENGTH EQL 0
    THEN
    	BEGIN
    	IF .RESULT_TYPE EQL DSC$K_DTYPE_V OR
    	   .RESULT_TYPE EQL DSC$K_DTYPE_VU OR
    	   .RESULT_TYPE EQL DSC$K_DTYPE_SV OR
    	   .RESULT_TYPE EQL DSC$K_DTYPE_SVU
    	THEN
    	    BEGIN
    	    LENGTH = .NEW_LEFT_ARG[DBG$W_VALUE_LENGTH];
    	    IF .BINARY_FLAG
    	    THEN
    		BEGIN
    		IF .NEW_RIGHT_ARG[DBG$W_VALUE_LENGTH] GTR
    		   .NEW_LEFT_ARG[DBG$W_VALUE_LENGTH]
    		THEN
    		    LENGTH = .NEW_RIGHT_ARG[DBG$W_VALUE_LENGTH];
    		END;

    	    END

    	ELSE
    	    LENGTH = DBG$NUM_BYTES(.RESULT_TYPE);

    	END;

    RESULT = MAKE_VAL_DESC(.RESULT_TYPE, 
    			   .LENGTH,
    			   0,
    			   .SD_CLASS_FLAG);


    ! Make sure we did not turn SD_CLASS_FLAG on for the following
    ! data types. (in order words, ignore the incoming data types).
    !
    CASE .RESULT[DBG$B_VALUE_DTYPE] FROM DSC$K_DTYPE_LOWEST
				    TO   DSC$K_DTYPE_HIGHEST OF
	SET
	[DSC$K_DTYPE_F, DSC$K_DTYPE_D, DSC$K_DTYPE_G, DSC$K_DTYPE_H,
	 DSC$K_DTYPE_FC, DSC$K_DTYPE_DC, DSC$K_DTYPE_GC, DSC$K_DTYPE_HC]:
	    RESULT[DBG$B_VALUE_CLASS] = DSC$K_CLASS_S;
	[INRANGE, OUTRANGE]:
	    0;
	TES;


    ! Call the routine which performs the operation. We pass in
    ! the routine index, which is used as a case index inside the
    ! routine, the addresses of the operand value descriptors,
    ! and the address of a longword containing a pointer to the result
    ! value descriptor. The reason for the extra level of indirection
    ! for the result is that sometimes DBG$PERFORM_OPERATOR will construct
    ! a new descriptor instead of using the one we pass in.
    !
    DBG$PERFORM_OPERATOR (.OPERATOR,
    			  .ROUT_INDEX, 
    			  .NEW_LEFT_ARG, 
    			  (IF .BINARY_FLAG 
    			  THEN .NEW_RIGHT_ARG
    			  ELSE 0),
    			  RESULT);

    
    ! Call TYPEID routine to do type check on non-atomic data types.  And
    ! also fix up the Result Value Descriptor.
    !
    IF .TYPEID_INDEX NEQ 0 
    THEN 
    	BEGIN
    	IF NOT DBG$PERFORM_TYPEID_CHECK(.TYPEID_INDEX, .NEW_LEFT_ARG,
    				        .NEW_RIGHT_ARG, .RESULT)
    	THEN
    	    SIGNAL(DBG$_OPNOTALLOW, 1, OPERATOR[TOKEN$B_OPLEN]);

    	END;


    ! Return a pointer to the RESULT value descriptor.
    !
    RETURN .RESULT;
    END;

GLOBAL ROUTINE DBG$GET_SET_TYPEID(TYPEID, PARENT_TYPEID) =
!
! FUNCTION
!	This routine is a recursive routine to get the parent type for SET data
!	type.
!
! INPUTS
!	PARENT_TYPEID - Parent typeid. (only used for the subrange type).
!	TYPEID	- Typeid for a given set data.
!
! OUTPUTS
!	Pointer to parent typeid of set data.
!

    BEGIN

    MAP
    	PARENT_TYPEID: REF VECTOR[1],
    	TYPEID: REF RST$ENTRY;

    LOCAL
    	PARENT_TYPE,
    	HIGHPTR,
    	LOWPTR,
    	SIZE;

    
    CASE .TYPEID[RST$B_FCODE] FROM RST$K_TYPE_MINIMUM 
    			      TO   RST$K_TYPE_MAXIMUM OF
    	SET
    	[RST$K_TYPE_SET]:
    	    BEGIN
	    DBG$STA_TYP_SET(.TYPEID, PARENT_TYPE, SIZE);
    	    TYPEID = DBG$GET_SET_TYPEID(.PARENT_TYPE, PARENT_TYPEID[0]);
    	    RETURN .TYPEID;
    	    END;

    	[RST$K_TYPE_ATOMIC, RST$K_TYPE_DESCR, RST$K_TYPE_ENUM]:
    	    RETURN .TYPEID;

    	[RST$K_TYPE_SUBRNG]:
    	    BEGIN
    	    PARENT_TYPEID[0] = .TYPEID;
    	    DBG$STA_TYP_SUBRNG(.TYPEID, PARENT_TYPE, LOWPTR, HIGHPTR, SIZE);
    	    TYPEID = DBG$GET_SET_TYPEID(.PARENT_TYPE, PARENT_TYPEID[0]);
    	    RETURN .TYPEID;
    	    END;

    	[INRANGE]:
    	    $DBG_ERROR('DBGEVALOP\DBG$GET_SET_TYPEID, fcode cannot be set type');
    	TES;

    RETURN 0;
    END;

GLOBAL ROUTINE DBG$GET_DTYPE (VALDESC) =
! 
! FUNCTION
!	Given a Value Descriptor, this routine returns a 1-byte type code
!	for the descriptor. This type code is ordinarily just taken from
!	the dtype field, but if the fcode is not atomic or descriptor, the
!	1-byte type code is DBG$K_MAXIMUM_DTYPE + FCODE.
!
! INPUT
!	VALDESC	-	A pointer to the value descriptor for which a 
!			type code is desired.
!
! OUTPUT
!	A type code is returned.
!
    BEGIN
    MAP
    	VALDESC: REF DBG$VALDESC;


    ! Check for data. Note that record components A.B come back with
    ! KIND = TYPCOMP, and these are also data.
    !
    IF .VALDESC[DBG$B_DHDR_KIND] EQL RST$K_DATA
    OR .VALDESC[DBG$B_DHDR_KIND] EQL RST$K_TYPCOMP
    THEN
    	BEGIN

    	! Cobol and Pli picture are treated differently, in COBOL, picture
    	! is treated as T, in PLI, we want to have FCODE + 200 as the dtype.
    	!
    	IF .VALDESC [DBG$B_DHDR_FCODE] EQL RST$K_TYPE_PICT
    	THEN
    	    BEGIN
    	    IF .DBG$GB_LANGUAGE EQL DBG$K_COBOL
    	    THEN
    	        RETURN .VALDESC [DBG$B_VALUE_DTYPE]
    	    ELSE
    	        RETURN .VALDESC [DBG$B_DHDR_FCODE] + DBG$K_MAXIMUM_DTYPE;
    	    END;


    	! The argument is data. Check the fcode.
    	!
    	IF .VALDESC [DBG$B_DHDR_FCODE] EQL RST$K_TYPE_ATOMIC
    	OR .VALDESC [DBG$B_DHDR_FCODE] EQL RST$K_TYPE_DESCR
    	THEN

    	    ! Special case for ADA fixed point and PL/1 fixed binary.
    	    ! These come in as
    	    ! class SD with the BINSCALE bit set. Return a special
    	    ! dtype for "FIXED" in this case.
    	    !
    	    IF (.VALDESC[DBG$B_VALUE_CLASS] EQL DSC$K_CLASS_SD) AND
    	       (.VALDESC[DBG$V_VALUE_FL_BINSCALE])
    	    THEN
    		RETURN DSC$K_DTYPE_FIXED

    	    ELSE

    	        ! VAX standard type.
    	        !
    	        RETURN .VALDESC [DBG$B_VALUE_DTYPE]

    	ELSE

    	    ! Not VAX standard. Represent type as 200 + fcode.
    	    !    	
    	    RETURN .VALDESC [DBG$B_DHDR_FCODE] + DBG$K_MAXIMUM_DTYPE
    	END

    ELSE

    	! Other kinds include RST$K_ROUTINE, RST$K_LINE, etc.
    	! Some languages (BLISS, MACRO) allow operations on code addresses,
    	! e.g., EVAL SUBR + 100 where SUBR is a subroutine.
    	! In this case, we expect dtype to be ZI or ZEM.
    	!
    	IF .VALDESC [DBG$B_DHDR_KIND] EQL RST$K_ROUTINE
    	OR .VALDESC [DBG$B_DHDR_KIND] EQL RST$K_BLOCK
    	OR .VALDESC [DBG$B_DHDR_KIND] EQL RST$K_LABEL
    	OR .VALDESC [DBG$B_DHDR_KIND] EQL RST$K_LINE
    	OR .VALDESC [DBG$B_DHDR_KIND] EQL RST$K_ENTRY
    	THEN

    	    ! The type should be ZI or ZEM unless an override was present.
    	    !
    	    RETURN .VALDESC [DBG$B_VALUE_DTYPE]

    	ELSE

    	    ! Any other kind is an error.	
    	    !
    	    BEGIN
    	    $DBG_ERROR ('DBGEVALOP\DBG$GET_TYPECODE unknown rst kind');
    	    RETURN 0;
    	    END;
    END;

ROUTINE DBG$LANGUAGE_TYPE_CONV (CVT_ROUT_INDEX,	VALUE1, VALUE2) =
!
! FUNCTION
!	Performs language-specific type conversion on the given 
!	descriptors, according to the routine index given
!	by CVT_ROUT_INDEX.
!
! INPUTS
!	CVT_ROUT_INDEX	- A routine index indicating which operation
!			  is to be performed. The possible values for
!			  this index are given in DBGLIB under CVT$K_
!	VALUE1  	- DEBUG value descriptor for the source
!	VALUE2  	- DEBUG value descriptor for the target
!
! OUTPUTS
!	A pointer to the result descriptor is returned.
!
    BEGIN

    MAP
    	VALUE1 : REF DBG$VALDESC,	! Pointer to the source value descriptor
    	VALUE2 : REF DBG$VALDESC;	! Pointer to the target value descriptor


    ! Case on the routine index.
    !
    CASE .CVT_ROUT_INDEX FROM CVT$K_MIN_ROUT TO CVT$K_MAX_ROUT OF
    	SET

    	[CVT$K_PLI_CVT]:
    	    VALUE2 = PLI_TYPE_CONV(.VALUE1, .VALUE2);

    	[CVT$K_COB_PICT]:
    	    BEGIN
    	    LOCAL
    		BUFFER: VECTOR[4, LONG],! Buffer area
    		CHANGE_SCALE: BYTE,	! Change of scale
    		LANGCODE,		! Language code
    		PICTPTR: REF VECTOR[,BYTE],
    					! Pointer to picture representation
    		PICTVAL,		! Pointer to language specific encoding
    		PSCALE: VECTOR[2, BYTE];! Digits and Scale


    	    IF .VALUE2[DBG$B_DHDR_FCODE] NEQ RST$K_TYPE_PICT
    	    THEN
    		$DBG_ERROR('DBGEVALOP\DBG$LANGUAGE_TYPE_CONV, fcode neq pict');

    	    DBG$STA_TYP_PICT(.VALUE2[DBG$L_DHDR_TYPEID], LANGCODE, PICTPTR, 
    				PICTVAL, PSCALE);
    	    CASE .LANGCODE FROM DBG$K_MIN_LANGUAGE TO DBG$K_MAX_LANGUAGE OF
    		SET
    		[DBG$K_COBOL]:
    		    BEGIN
    		    CHANGE_SCALE = .VALUE1[DBG$B_VALUE_SCALE] - .PSCALE[0];
    		    ASHP(CHANGE_SCALE, VALUE1[DBG$W_VALUE_LENGTH],
    			.VALUE1[DBG$L_VALUE_POINTER], %REF (0), PSCALE[1],
    			BUFFER);
    		    EDITPC(PSCALE[1], BUFFER, .PICTVAL, .VALUE2[DBG$L_VALUE_POINTER]);
    		    END;
    
    		[INRANGE, OUTRANGE]:
    		    SIGNAL(DBG$_UNIMPLENT);

    		TES;

    	    END;

    	[INRANGE, OUTRANGE]: 
    	    $DBG_ERROR ('DBGEVALOP\DBG$LANGUAGE_TYPE_CONV unknown routine index');

    	TES;

    RETURN .VALUE2;
    END;

GLOBAL ROUTINE DBG$MAP_DTYPE_CLASS(IN_TYPE, FLAG) =
!
! FUNCTION
! 	This routine is used to obtain the class for the given dtype.
!	(When DEBUG override type qualifier is given, the class field
!	in the VMS value descriptor is zero, in order to call LIB$CVT_DX_DX,
!	class field must be supplied.)
!
! INPUT
!	IN_TYPE		- a dtype code
!	FLAG		- if the flag is set that means we take SD as class
!			instead of S.
!
! OUTPUT
!	CLASS is returned.
!
    BEGIN 
    RETURN 
    	(CASE .IN_TYPE  FROM 0 TO DBG$K_MAXIMUM_DTYPE + RST$K_TYPE_MAXIMUM OF
    	SET
    	[DSC$K_DTYPE_Z]:
    		0;
    	[DSC$K_DTYPE_V,DSC$K_DTYPE_BU,DSC$K_DTYPE_WU,DSC$K_DTYPE_LU,
    	 DSC$K_DTYPE_QU,DSC$K_DTYPE_B,DSC$K_DTYPE_W,DSC$K_DTYPE_L,
    	 DSC$K_DTYPE_Q,DSC$K_DTYPE_F,DSC$K_DTYPE_D,DSC$K_DTYPE_FC,
    	 DSC$K_DTYPE_DC,DSC$K_DTYPE_T,DSC$K_DTYPE_NU,DSC$K_DTYPE_NL,
    	 DSC$K_DTYPE_NLO,DSC$K_DTYPE_NR,DSC$K_DTYPE_NRO,DSC$K_DTYPE_NZ,
    	 DSC$K_DTYPE_ZI,DSC$K_DTYPE_ZEM,DSC$K_DTYPE_DSC,DSC$K_DTYPE_ADT,
    	 DSC$K_DTYPE_OU,DSC$K_DTYPE_O,DSC$K_DTYPE_G,DSC$K_DTYPE_H,
    	 DSC$K_DTYPE_GC,DSC$K_DTYPE_HC,DSC$K_DTYPE_CIT,DSC$K_DTYPE_BPV,
    	 DSC$K_DTYPE_BLV,DSC$K_DTYPE_SV]:
    	        IF .FLAG THEN DSC$K_CLASS_SD ELSE DSC$K_CLASS_S;
    	[DSC$K_DTYPE_VU,DSC$K_DTYPE_TF,DSC$K_DTYPE_SVU]: 
    		DSC$K_CLASS_UBS;
    	[DSC$K_DTYPE_VT,DSC$K_DTYPE_AC,DSC$K_DTYPE_AZ]:
    		DSC$K_CLASS_VS;
	[DSC$K_DTYPE_P]:
		DSC$K_CLASS_SD;
    	[DSC$K_DTYPE_FIXED]:
    		DSC$K_CLASS_SD;
    	[INRANGE]:
    		DSC$K_CLASS_Z;
    	[OUTRANGE]:
		$DBG_ERROR ('DBGEVALOP\DBG$MAP_DTYPE_CLASS');
    	TES);
    END;

GLOBAL ROUTINE DBG$NUM_BYTES(IN_TYPE) =
!
! FUNCTION
! 	This routine is used to obtain the number of bytes of storage that
! 	are needed to hold data of a given dtype.
!
! INPUT
!	IN_TYPE		- a dtype code
!
! OUTPUT
!	The number of bytes of storage needed to hold data of type dtype
!	is returned.
!
    BEGIN 
    RETURN 
    	(CASE .IN_TYPE  FROM 0 TO DBG$K_MAXIMUM_DTYPE + RST$K_TYPE_MAXIMUM OF
    	SET
    	[DSC$K_DTYPE_Z]		: 4;
    	[DSC$K_DTYPE_BU]	: 1;
    	[DSC$K_DTYPE_B]		: 1;
    	[DSC$K_DTYPE_WU]	: 2;
    	[DSC$K_DTYPE_W]		: 2;
    	[DSC$K_DTYPE_LU]	: 4;
    	[DSC$K_DTYPE_L]		: 4;
    	[DSC$K_DTYPE_QU]	: 4;
    	[DSC$K_DTYPE_Q]		: 8;
    	[DSC$K_DTYPE_OU]	: 16;
    	[DSC$K_DTYPE_O]		: 16;
    	[DSC$K_DTYPE_F]		: 4;
    	[DSC$K_DTYPE_D]		: 8;
    	[DSC$K_DTYPE_G]		: 8;
    	[DSC$K_DTYPE_H]		: 16;
    	[DSC$K_DTYPE_FC]	: 8;
    	[DSC$K_DTYPE_DC]	: 16;
    	[DSC$K_DTYPE_GC]	: 16;
    	[DSC$K_DTYPE_HC]	: 32;
	[DSC$K_DTYPE_P]		: 31;
    	[DSC$K_DTYPE_TF]	: 1;
    	[DSC$K_DTYPE_FIXED]	: 4;
    	[DBG$K_DTYPE_ENUM]	: 4;
    	[DBG$K_DTYPE_TPTR]	: 4;
    	[DBG$K_DTYPE_PTR]	: 4;
    	[INRANGE]		: 64; 	! Default to 64 bytes
    	[OUTRANGE]		: $DBG_ERROR ('DBGEVALOP\DBG$NUM_BYTES');
    	TES);
    END;

GLOBAL ROUTINE DBG$PERFORM_TYPEID_CHECK(TYPE_INDEX, LEFT_ARG, RIGHT_ARG, RESULT) =
!
! FUNCTION
!	This routine performs type check on the arguments according to
!	the given type index.  This routine requires to have left argument,
!	and one of the right argument or result, or both.  For non-atomic data 
!	items, left argument, right argument must have TYPEID.  For non-atomic 
!	data item, if the result's typeid is zero, then TYPEID is taken from
!	left argument. (This only should occur after MAKE_VAL_DESC is called
!	to create the result value descriptor).  TYPEID check will be performed
!	on left argument and right argument for non-atomic data types.  And/Or
!	TYPEID check will be performed on left argument and result, and also
!	range check is done on the result.
!
! 	This routine is called from DEPOSIT command with left_arg (src) and
!	right_arg (dst) to perform the typeid check before the DEPOSIT.  
!	Then it is also called called from DEPOSIT command with left_arg 
!	(src) and result (dst) to perform the range check after the DEPOSIT.
!
!	This routine is called from EV command to have standard left_arg,
!	or right_arg (operands) and result.
!
! INPUTS
!	TYPE_INDEX	- Type check index.
!
!	LEFT_ARG	- Left argument value descriptor.  This argument
!			must have typeid for non-atomic data types.
!
!	RIGHT_ARG	- Right argument value descriptor.  This argument
!			must have typeid for non-atomic data types.  This
!			argument may not present.
!
!	RESULT		- Result argument value descriptor.  This argument
!			may not present.  Its typeid may be zero for non-
!			atomic data types.
!
! OUTPUTS
!	Returned status:
!
!	TRUE or FALSE
!

    BEGIN

    MAP
    	LEFT_ARG: REF DBG$VALDESC,	! Pointer to left argument
    	RIGHT_ARG: REF DBG$VALDESC,	! Pointer to right argument
    	RESULT: REF DBG$VALDESC;	! Pointer to rusult argument

    LOCAL
    	DUMMY1,
    	DUMMY2,
    	LEFT_DTYPE,			! Left arg's data type
    	LEFT_FCODE,			! Left arg's fcode
    	LEFT_TYPEID: REF RST$ENTRY,	! Left arg's typeid
    	PARENT_TYPE: REF RST$ENTRY,	! Parent typeid for subrange
    	RESULT_DTYPE,		 	! Result's data type
    	RESULT_FCODE,			! Result's fcode
    	RESULT_TYPEID: REF RST$ENTRY,	! Result's typeid
    	RIGHT_DTYPE,			! Right arg's data type
    	RIGHT_FCODE,			! Right arg's fcode
    	RIGHT_TYPEID: REF RST$ENTRY,	! Right arg's typeid
    	SIZE,				! The size of the elements
    	STATUS;				! TRUE or FALSE


    ! Make sure left argument is supplied.
    !
    IF .LEFT_ARG EQL 0
    THEN
    	$DBG_ERROR('DBGEVALOP\DBG$PERFORM_TYPEID_CHECK');


    ! Make sure left arg has TYPEID for non-atomic data types.
    !
    IF NOT ((.LEFT_ARG[DBG$B_DHDR_FCODE] EQL RST$K_TYPE_ATOMIC) OR
            (.LEFT_ARG[DBG$B_DHDR_FCODE] EQL RST$K_TYPE_DESCR))
    THEN
    	IF .LEFT_ARG[DBG$L_DHDR_TYPEID] EQL 0
    	THEN
    	    $DBG_ERROR('DBGEVALOP\DBG$PERFORM_TYPEID_CHECK, no typeid for non-atomic data');


    ! If there is right argument, make sure right arg has TYPEID for non-atomic
    ! data types.  (ie, for unary operand).
    !
    IF .RIGHT_ARG NEQ 0
    THEN
    	BEGIN
    	IF NOT ((.RIGHT_ARG[DBG$B_DHDR_FCODE] EQL RST$K_TYPE_ATOMIC) OR
    	        (.RIGHT_ARG[DBG$B_DHDR_FCODE] EQL RST$K_TYPE_DESCR))
    	THEN
	    IF .RIGHT_ARG[DBG$L_DHDR_TYPEID] EQL 0
    	    THEN
    	        $DBG_ERROR('DBGEVALOP\DBG$PERFORM_TYPEID_CHECK, no typeid for non-atomic data');

    	END;


    ! One may only want to perform TYPEID check on the operands.  In this
    ! case, there is no need to have result operand.  
    !
    IF .RIGHT_ARG EQL 0 AND .RESULT EQL 0
    THEN
        $DBG_ERROR('DBGEVALOP\DBG$PERFORM_TYPEID_CHECK');


    ! Perform type check.
    !
    STATUS = TRUE;
    PARENT_TYPE = 0;
    CASE .TYPE_INDEX FROM ORT$K_TYPEID_MIN_ROUT TO ORT$K_TYPEID_MAX_ROUT OF
    	SET
    	[ORT$K_TYPEID_ENUM_ENUM]:
    	    BEGIN
    	    IF .RIGHT_ARG NEQ 0
    	    THEN
    		BEGIN


    		! If this is called from DEPOSIT command, if RESULT is not
    		! presented, this must be one of the sanity check to make
    		! sure DEPOSIT is possible.  Note: DRINK = 1 is valid
    		! case, so in here we allow this case to be legal.
    		! (LEFT_ARG is the source, RIGHT_ARG is the target).
    		!
	        IF .LEFT_ARG[DBG$L_DHDR_TYPEID] NEQ 0
    		THEN
    		    BEGIN
    		    STATUS = TYPEID_CHECK_ENUM(.LEFT_ARG[DBG$L_DHDR_TYPEID],
    				       .RIGHT_ARG[DBG$L_DHDR_TYPEID]);
    		    END

    		ELSE
    		    BEGIN
    		    IF .RESULT EQL 0
    		    THEN
    			BEGIN
    			IF (.LEFT_ARG[DBG$B_VALUE_DTYPE] EQL DSC$K_DTYPE_L OR
    			    .LEFT_ARG[DBG$B_VALUE_DTYPE] EQL DSC$K_DTYPE_LU)
    			THEN
    			    STATUS = TRUE
    			ELSE
    			    STATUS = FALSE;
    			END;
    		    END;
    		END;
   

    	    ! If there is no result, or result is atomic data, or left and 
    	    ! right TYPEID check failed, returns.
    	    !
    	    IF (.RESULT EQL 0) OR
    	       (.RESULT[DBG$B_DHDR_FCODE] EQL RST$K_TYPE_ATOMIC) OR
    	       (.RESULT[DBG$B_DHDR_FCODE] EQL RST$K_TYPE_DESCR) OR
    	       NOT .STATUS
    	    THEN 
    		RETURN .STATUS;


    	    ! Perform result TYPEID check and range check.
    	    !
    	    CASE .RESULT[DBG$B_DHDR_FCODE] FROM RST$K_TYPE_MINIMUM 
    					   TO   RST$K_TYPE_MAXIMUM OF
    		SET
    		[RST$K_TYPE_ENUM]:
    		    BEGIN
    		    IF .RESULT[DBG$L_DHDR_TYPEID] EQL 0
    		    THEN
    			RESULT[DBG$L_DHDR_TYPEID] = .LEFT_ARG[DBG$L_DHDR_TYPEID];

    		    IF .LEFT_ARG[DBG$L_DHDR_TYPEID] NEQ 0
    		    THEN
    			BEGIN
    		        STATUS = TYPEID_CHECK_ENUM(.LEFT_ARG[DBG$L_DHDR_TYPEID],
    					       .RESULT[DBG$L_DHDR_TYPEID]);
    			END

    		    ELSE
    			BEGIN
    			IF NOT (.LEFT_ARG[DBG$B_VALUE_DTYPE] EQL DSC$K_DTYPE_L OR
    			        .LEFT_ARG[DBG$B_VALUE_DTYPE] EQL DSC$K_DTYPE_LU)
    			THEN
    			    STATUS = FALSE;
    			END;

    		    IF NOT .STATUS THEN RETURN .STATUS;

    		    RETURN TYPEID_RANGE_CHECK_ENUM(.LEFT_ARG, .RESULT[DBG$L_DHDR_TYPEID]);
    		    END;

    		[INRANGE, OUTRANGE]:
    		    STATUS = FALSE;
    		TES;

    	    END;

    	[ORT$K_TYPEID_SET_SET]:
    	    BEGIN
    	    LEFT_TYPEID = .LEFT_ARG[DBG$L_DHDR_TYPEID];
    	    LEFT_FCODE = .LEFT_ARG[DBG$B_DHDR_FCODE];
    	    LEFT_DTYPE = .LEFT_ARG[DBG$B_VALUE_DTYPE];
    	    IF .LEFT_ARG[DBG$B_DHDR_FCODE] EQL RST$K_TYPE_SET
    	    THEN
    		BEGIN
    	    	LEFT_TYPEID = DBG$GET_SET_TYPEID(
    		    .LEFT_ARG[DBG$L_DHDR_TYPEID], PARENT_TYPE);
    		LEFT_FCODE = .LEFT_TYPEID[RST$B_FCODE];
    		IF .LEFT_FCODE EQL RST$K_TYPE_ATOMIC
    		THEN
    		    BEGIN
    		    DBG$STA_TYP_ATOMIC(.LEFT_TYPEID, LEFT_DTYPE, SIZE);
    		    IF .LEFT_DTYPE EQL DST$K_BOOL THEN LEFT_DTYPE = DSC$K_DTYPE_TF;
    		    END;

    		END;

    	    IF .RIGHT_ARG NEQ 0
    	    THEN
    		BEGIN
    		RIGHT_TYPEID = .RIGHT_ARG[DBG$L_DHDR_TYPEID];
    		RIGHT_FCODE = .RIGHT_ARG[DBG$B_DHDR_FCODE];
    		RIGHT_DTYPE = .RIGHT_ARG[DBG$B_VALUE_DTYPE];
    		IF .RIGHT_ARG[DBG$B_DHDR_FCODE] EQL RST$K_TYPE_SET
    		THEN
    		    BEGIN
	    	    RIGHT_TYPEID = DBG$GET_SET_TYPEID(
    			.RIGHT_ARG[DBG$L_DHDR_TYPEID], PARENT_TYPE);
    		    RIGHT_FCODE = .RIGHT_TYPEID[RST$B_FCODE];
    		    IF .RIGHT_FCODE EQL RST$K_TYPE_ATOMIC
    		    THEN
    			BEGIN
    			DBG$STA_TYP_ATOMIC(.RIGHT_TYPEID, RIGHT_DTYPE, SIZE);
    			IF .RIGHT_DTYPE EQL DST$K_BOOL THEN RIGHT_DTYPE = DSC$K_DTYPE_TF;
    			END;

    		    END;

    		STATUS = TYPEID_CHECK_SET(.LEFT_TYPEID, .RIGHT_TYPEID,
    					  .LEFT_FCODE, .RIGHT_FCODE,
    					  .LEFT_DTYPE, .RIGHT_DTYPE);
    		END;

    	    IF (.RESULT EQL 0) OR
    	       (.RESULT[DBG$B_DHDR_FCODE] EQL RST$K_TYPE_ATOMIC) OR
    	       (.RESULT[DBG$B_DHDR_FCODE] EQL RST$K_TYPE_DESCR) OR
    	       NOT .STATUS
    	    THEN
    		RETURN .STATUS;

    	    CASE .RESULT[DBG$B_DHDR_FCODE] FROM RST$K_TYPE_MINIMUM
    					   TO   RST$K_TYPE_MAXIMUM OF
    		SET
    		[RST$K_TYPE_SET]:
    		    BEGIN
    		    RESULT_FCODE = .RESULT[DBG$B_DHDR_FCODE];
    		    RESULT_DTYPE = .RESULT[DBG$B_VALUE_DTYPE];
    		    IF .RESULT[DBG$L_DHDR_TYPEID] EQL 0
    		    THEN
    			RESULT[DBG$L_DHDR_TYPEID] = .LEFT_ARG[DBG$L_DHDR_TYPEID];

    		    RESULT_TYPEID = DBG$GET_SET_TYPEID(
    			.RESULT[DBG$L_DHDR_TYPEID], PARENT_TYPE);
    		    RESULT_FCODE = .RESULT_TYPEID[RST$B_FCODE];
    		    IF .RESULT_FCODE EQL RST$K_TYPE_ATOMIC
    		    THEN
    			BEGIN
    			DBG$STA_TYP_ATOMIC(.RESULT_TYPEID, RESULT_DTYPE, SIZE);
    			IF .RESULT_DTYPE EQL DST$K_BOOL THEN RESULT_DTYPE = DSC$K_DTYPE_TF;
    			END;

    		    STATUS = TYPEID_CHECK_SET(.LEFT_TYPEID, .RESULT_TYPEID,
    					      .LEFT_FCODE, .RESULT_FCODE,
    					      .LEFT_DTYPE, .RESULT_DTYPE);

    		    IF NOT .STATUS THEN RETURN .STATUS;


    		    ! Set the typeid for subrange.  Typeid is set in routine
    		    ! DBG$GET_SET_TYPEID.
    		    ! 
    		    IF .PARENT_TYPE NEQ 0
    		    THEN
    		        IF .PARENT_TYPE[RST$B_FCODE] EQL RST$K_TYPE_SUBRNG
    		        THEN
    			    RESULT_TYPEID = .PARENT_TYPE;


    		    ! Perform range check.
    		    !
    		    SELECTONE .RESULT_TYPEID[RST$B_FCODE] OF
    			SET
    			[RST$K_TYPE_SUBRNG]:
    			    RETURN TYPEID_RANGE_CHECK_SUBRNG(.LEFT_ARG, .RESULT_TYPEID);

    			TES;
	    	    END;

    		[INRANGE, OUTRANGE]:
    		    STATUS = FALSE;
    		TES;

    	    END;


    	! Typeid pointer typeid check would be always called from DEPOSIT 
    	! command with Left_arg (src) and Right_arg (dst).  There is no
    	! result. It turns out this is not supported.  For we have mapped
    	! the TPTR into LU, so there is no typeid check required.
    	!
    	[ORT$K_TYPEID_TPTR_TPTR]:
    	    BEGIN
    	    0;
    	    END;


    	! Subrange typeid check would be always called from DEPOSIT
    	! command with Left_arg (src) and Right_arg (dst) for typeid
    	! check and also called with Left_arg (src) and Result (dst) for
    	! range check.
    	!
    	[ORT$K_TYPEID_SUBRNG_SUBRNG]:
    	    BEGIN
    	    IF .RESULT EQL 0
    	    THEN
    		BEGIN
    	        PARENT_TYPE = .RIGHT_ARG[DBG$L_DHDR_TYPEID];
    	        WHILE .PARENT_TYPE[RST$B_FCODE] EQL RST$K_TYPE_SUBRNG DO
    		    DBG$STA_TYP_SUBRNG(.PARENT_TYPE, PARENT_TYPE, DUMMY1, DUMMY2, SIZE);

    		SELECTONE .PARENT_TYPE[RST$B_FCODE] OF
    		    SET
    		    [RST$K_TYPE_ENUM]:
    			BEGIN
    		        IF .LEFT_ARG[DBG$L_DHDR_TYPEID] NEQ 0
    		        THEN
    			    BEGIN
    		            STATUS = TYPEID_CHECK_ENUM(.LEFT_ARG[DBG$L_DHDR_TYPEID],
    					       	       .PARENT_TYPE);
    			    END

    		        ELSE
    			    BEGIN
    			    IF NOT (.LEFT_ARG[DBG$B_VALUE_DTYPE] EQL DSC$K_DTYPE_L OR
    			            .LEFT_ARG[DBG$B_VALUE_DTYPE] EQL DSC$K_DTYPE_LU)
    			    THEN
    			        STATUS = FALSE;
    			    END;
    			END;

    		    [RST$K_TYPE_ATOMIC]:
    			BEGIN
    			DBG$STA_TYP_ATOMIC(.PARENT_TYPE, RESULT_DTYPE, SIZE);
    			IF .RESULT_DTYPE EQL DST$K_BOOL THEN RESULT_DTYPE = DSC$K_DTYPE_TF;
    			IF .RESULT_DTYPE EQL .LEFT_ARG[DBG$B_VALUE_DTYPE]
    			THEN
    			    STATUS = TRUE

    			ELSE
    			    STATUS = FALSE;
    			END;

    		    [OTHERWISE]:
    			STATUS = FALSE;
    		    TES;

    		RETURN .STATUS;
    		END

    	    ELSE
    	        RETURN TYPEID_RANGE_CHECK_SUBRNG(.LEFT_ARG, .RESULT[DBG$L_DHDR_TYPEID]);
    	    END;

    	[INRANGE, OUTRANGE]:
    	    $DBG_ERROR('DBGEVALOP\DBG$PERFORM_TYPEID_CHECK, unknown type check index');
    	TES;

    RETURN .STATUS;
    END;

ROUTINE DBG$TYPE_CONV (VALUE1, VALUE2) =
!
! FUNCTION
!	This routine is the top-level type converter for DEBUG. It takes a
!	source value descriptor and a target value descriptor. It first
!	checks whether there are any language-specific type conversion
!	rules to use. If not, it calls the language-independent routine
!	DBG$COVER_DX_DX.
!
! INPUTS
!	VALUE1	- Pointer to a value descriptor to be type-converted.
!
!	VALUE2	- Pointer to the target value descriptor.
!
! OUTPUTS
!	A pointer to a value descriptor is returned.  The target descriptor 
!	is filled in with the result of the conversion.
!
    BEGIN

    MAP
   	VALUE1: REF DBG$VALDESC,
    	VALUE2: REF DBG$VALDESC;

    LOCAL
   	CVT_TBL_ENTRY: TYPE_CVT$ENTRY,	! An entry in the Type Conversion Table
    	CVT_TYPE_PAIR: TYPE$PAIR,	! Data Type Pairs
    	STATUS;				! Return status from lib$cvt_dx_dx


    ! Perform Type Conversion indicated by Language Dependent Type Conversion 
    ! Table.
    ! (Left type in Type Pair = The type we want to convert into,
    !  Right type             = From type)
    !
    IF .CVT_TBL NEQ TABLEBASE
    THEN
    	BEGIN
        CVT_TYPE_PAIR[B$_LEFT_TYPE] = .VALUE2[DBG$B_VALUE_DTYPE];
        CVT_TYPE_PAIR[B$_RIGHT_TYPE] = .VALUE1[DBG$B_VALUE_DTYPE];
    	INCR I FROM 0 TO .CVT_TBL_SIZE - 1 DO
    	    BEGIN
    	    CVT_TBL_ENTRY = .CVT_TBL[.I];
    	    IF .CVT_TBL_ENTRY EQL 0 THEN EXITLOOP;
    	    IF (.CVT_TBL_ENTRY[TYPE_CVT$B_LOWER_TYPE] EQL DSC$K_DTYPE_ANY AND
    	        .CVT_TBL_ENTRY[TYPE_CVT$B_HIGHER_TYPE] EQL .CVT_TYPE_PAIR[B$_RIGHT_TYPE]) OR
    	       (.CVT_TBL_ENTRY[TYPE_CVT$B_HIGHER_TYPE] EQL DSC$K_DTYPE_ANY AND
    		.CVT_TBL_ENTRY[TYPE_CVT$B_LOWER_TYPE] EQL .CVT_TYPE_PAIR[B$_LEFT_TYPE]) OR
    	       (.CVT_TBL_ENTRY[TYPE_CVT$W_MAP_PAIR] EQL  .CVT_TYPE_PAIR[W$_TYPE_PAIR])
    	    THEN
    		BEGIN
    	    	IF .CVT_TBL_ENTRY[TYPE_CVT$W_ROUT] NEQ 0
    	    	THEN
    		    DBG$LANGUAGE_TYPE_CONV (.CVT_TBL_ENTRY[TYPE_CVT$W_ROUT],
    			      .VALUE1, .VALUE2);
    		RETURN .VALUE2;
    		END;
    	    END;
    	END;


    	! Just in case, the there was no entry found in CVT_TBL for depositing
    	! a dtype into PICT type.  We treated PICT as 'T'.
    	!
    	IF .VALUE2[DBG$B_VALUE_DTYPE] EQL DBG$K_DTYPE_PICT AND
    	   .VALUE2[DBG$B_DHDR_FCODE] EQL RST$K_TYPE_PICT
    	THEN
    	    VALUE2[DBG$B_VALUE_DTYPE] = DSC$K_DTYPE_T;

        VALUE2 = DBG$COVER_DX_DX (.VALUE1, .VALUE2, .CVT_ROUND_FLAG);

    RETURN .VALUE2;
    END;

ROUTINE CONV_TEXT_PACK_VALUE(VAL_DESC) =
!
! FUNCTION
! 	This routine is used to convert the text string to pack decimal.
!
! INPUTS
!	VAL_DESC	- Unconverted constant.
!
! OUTPUTS
!	A converted value descriptor is returned.
!

    BEGIN

    MAP
    	VAL_DESC: REF DBG$VALDESC;


    LOCAL
	DOT: REF VECTOR[,BYTE],
	END_PTR: REF VECTOR[,BYTE],
    	P_VAL_DESC: REF DBG$VALDESC,
    	SCALE;


    P_VAL_DESC = MAKE_VAL_DESC(DSC$K_DTYPE_P, 
    			       DBG$NUM_BYTES(DSC$K_DTYPE_P),
    			       0,
    			       TRUE);

    DOT = CH$FIND_CH(.VAL_DESC[DBG$W_VALUE_LENGTH],
    		     .VAL_DESC[DBG$L_VALUE_POINTER],
    		     %C'.');


    ! A string of digits has no '.'.
    !
    IF .DOT EQL 0
    THEN
    	BEGIN
    	SCALE = 0;
    	P_VAL_DESC[DBG$W_VALUE_LENGTH] = .VAL_DESC[DBG$W_VALUE_LENGTH];
    	P_VAL_DESC[DBG$B_VALUE_DIGITS] = .VAL_DESC[DBG$W_VALUE_LENGTH];
    	END


    ! A string of digits has '.'.
    !
    ELSE
    	BEGIN
    	END_PTR = .VAL_DESC[DBG$L_VALUE_POINTER] + .VAL_DESC[DBG$W_VALUE_LENGTH] - 1;
    	SCALE = .END_PTR - .DOT;


    	! Fill in the digits and fill in scaling factor after the
    	! type conversion.
    	!
    	P_VAL_DESC[DBG$W_VALUE_LENGTH] = .VAL_DESC[DBG$W_VALUE_LENGTH] - 1;
    	P_VAL_DESC[DBG$B_VALUE_DIGITS] = .P_VAL_DESC[DBG$W_VALUE_LENGTH];


    	! Fix up the original value descriptor.
    	!
    	IF .DOT LSS .END_PTR
    	THEN
    	    CH$MOVE(.SCALE, .DOT+1, .DOT);

    	END_PTR = .END_PTR AND %X'00';
    	VAL_DESC[DBG$W_VALUE_LENGTH] = .P_VAL_DESC[DBG$W_VALUE_LENGTH];
    	END;


    ! Convert the string to decimal.
    !
    VAL_DESC[DBG$B_VALUE_DTYPE] = DSC$K_DTYPE_T;
    VAL_DESC[DBG$W_VALUE_TOKENCODE] = 0;
    P_VAL_DESC = DBG$TYPE_CONV(.VAL_DESC, .P_VAL_DESC);
    P_VAL_DESC[DBG$B_VALUE_SCALE] = -.SCALE;
    RETURN .P_VAL_DESC;
    END;


ROUTINE GET_DATA_LENGTH(FROM_DTYPE, TO_DTYPE, FROM_LENGTH) =
!
! FUNCTION
!	This routine trys to guess the length of the TO_DTYPE given
!	FROM_DTYPE.  Sometimes, it is not obivious what is the length
!	for the TO_DTYPE, for example, L --> V.  This routine first
!	will fill in the normal length, then will correct the length
!	by the language rules.  Note: language code in here is not
!	tested for most of the cases are isolated.
!
! INPUTS
!	FROM_DTYPE	- Source dtype.
!
!	TO_DTYPE	- Target dtype.
!
!	FROM_LENGTH	- Source dtype length.
!
! OUTPUTS
!	TO_LENGTH (target dtype length) is returned.
!

    BEGIN

    LOCAL
    	TO_LENGTH;			! Target dtype length


    ! Fill in the length by normal way.  Just in case, we did not update
    ! the length correctly later on, we still have a length.
    !
    TO_LENGTH = DBG$NUM_BYTES(.TO_DTYPE);


    ! Update the length by specified rules.
    !
    CASE .TO_DTYPE FROM DBG$K_MINIMUM_DTYPE TO DBG$K_MAXIMUM_DTYPE OF
    	SET
    	

    	! If we are converting to FIXED then we use the length from
    	! the source descriptor.
    	!
    	[DSC$K_DTYPE_FIXED]:
    	    TO_LENGTH = .FROM_LENGTH;
    	

    	[DSC$K_DTYPE_V, DSC$K_DTYPE_VU]:
    	    BEGIN
    	    CASE .FROM_DTYPE FROM DSC$K_DTYPE_LOWEST TO DSC$K_DTYPE_HIGHEST OF
    		SET
    		[DSC$K_DTYPE_V, DSC$K_DTYPE_VU]:
    		    TO_LENGTH = .FROM_LENGTH;
    		[DSC$K_DTYPE_B]:
    		    TO_LENGTH = 7;
    		[DSC$K_DTYPE_W]:
    		    TO_LENGTH = 15;
    		[DSC$K_DTYPE_P]:
    		    BEGIN
    		    TO_LENGTH = ((.FROM_LENGTH * 332) + 99) / 100;
    		    TO_LENGTH = MIN(31, .TO_LENGTH);
    		    END;
    		[INRANGE]:
    		    TO_LENGTH = 31;
    		[OUTRANGE]:
    		    BEGIN
    		    IF .FROM_DTYPE EQL DBG$K_DTYPE_PICT
    		    THEN
    			TO_LENGTH = 31
    		    ELSE
    		        $DBG_ERROR('DBGEVALOP\GET_DATA_LENGTH');
    		    END;
    		TES;
    	    END;

    	[DSC$K_DTYPE_T, DSC$K_DTYPE_VT]:
    	    BEGIN
    	    CASE .FROM_DTYPE FROM DSC$K_DTYPE_LOWEST TO DSC$K_DTYPE_HIGHEST OF
    		SET
    		[DSC$K_DTYPE_V, DSC$K_DTYPE_VU, DSC$K_DTYPE_T, DSC$K_DTYPE_VT]:
    		    TO_LENGTH = .FROM_LENGTH;
    		[DSC$K_DTYPE_B]:
    		    TO_LENGTH = 7;
    		[DSC$K_DTYPE_W]:
    		    TO_LENGTH = 7;
    		[DSC$K_DTYPE_L]:
    		    TO_LENGTH = 15;
    		[DSC$K_DTYPE_F]:
    		    TO_LENGTH = 15;
    		[DSC$K_DTYPE_D, DSC$K_DTYPE_G]:
    		    TO_LENGTH = 25;
    		[DSC$K_DTYPE_H]:
    		    TO_LENGTH = 42;
    		[DSC$K_DTYPE_P]:
    		    TO_LENGTH = .FROM_LENGTH + 5;
    		[INRANGE, OUTRANGE]:
    		    BEGIN
    		    IF .FROM_DTYPE EQL DBG$K_DTYPE_PICT
    		    THEN
    			TO_LENGTH = .FROM_LENGTH
    		    ELSE
    		        $DBG_ERROR('DBGEVALOP\GET_DATA_LENGTH');
    		    END;
    		TES;
    	    END;

    	[INRANGE, OUTRANGE]:
    	    BEGIN
    	    0;
    	    END;

    	TES;

    RETURN .TO_LENGTH;
    END;


ROUTINE GET_SCALE(VAL_DESC, DIGITS) =
!
! FUNCTION
!	This routine takes Floating-Point value descriptor data, convert its 
!	value to text string, get the exponent and number of digits information
!	from the text string.  Then we get the scaling factor from these
!	two numbers.
!
! INPUT
!	VAL_DESC	- Floating-Point value descriptor.
!
!	DIGITS		- Address of the number of the digits.
!
! OUTPUT
!	The scaling factor is returned.
!

    BEGIN

    MAP
    	DIGITS: REF VECTOR[1],		! Address of the number of the
    					!     digits.
    	VAL_DESC: REF DBG$VALDESC;	! Pointer to value descriptor.

    LOCAL
    	BUFFER: VECTOR[50, BYTE],	! Text string buffer
    	DESCRIPTOR: BLOCK[8, BYTE],	! Vax standard descriptor.
    	DIGITS_IN_FRACT,		! The number of digits in the fraction
    	D_PTR: REF VECTOR[,BYTE],	! Pointer to text string at the '.'
    	E_FLAG,				! Flag set to indicate the E-format 
    					!	text string has 'E'
    	E_PTR: REF VECTOR[,BYTE],	! Pointer to text string at E position
    	EXPONENT,			! The exponent of the floating-point 
    	SCALE,				! The scaling factor
    	STATUS;				! Return status from library routine


    ! Set up the descriptor.
    !
    DESCRIPTOR[DSC$B_CLASS] = DSC$K_CLASS_S;
    DESCRIPTOR[DSC$B_DTYPE] = DSC$K_DTYPE_T;
    DESCRIPTOR[DSC$W_LENGTH] = 50;
    DESCRIPTOR[DSC$A_POINTER] = BUFFER;


    ! Convert Floating-Point data to E formatted text string.
    !
    CASE .VAL_DESC[DBG$B_VALUE_DTYPE] FROM DSC$K_DTYPE_F TO DSC$K_DTYPE_H OF
    	SET
    	[DSC$K_DTYPE_F, DSC$K_DTYPE_D]:
    	    BEGIN
    	    CASE .VAL_DESC[DBG$B_VALUE_DTYPE] FROM DSC$K_DTYPE_F TO DSC$K_DTYPE_D OF
    		SET
    		[DSC$K_DTYPE_F]:
    		    DIGITS_IN_FRACT = 7;
    		[DSC$K_DTYPE_D]:
    		    DIGITS_IN_FRACT = 16;
    		TES;


    	    ! In here, the exponent digits is default to 2.
    	    !
    	    STATUS = FOR$CVT_D_TE(.VAL_DESC[DBG$L_VALUE_POINTER], DESCRIPTOR,
    		.DIGITS_IN_FRACT);
    	    END;

    	[DSC$K_DTYPE_G]:
    	    BEGIN
    	    DIGITS_IN_FRACT = 15;
    	    STATUS = FOR$CVT_G_TE(.VAL_DESC[DBG$L_VALUE_POINTER], DESCRIPTOR,
    		.DIGITS_IN_FRACT, 0, 0, 3);
    	    END;

    	[DSC$K_DTYPE_H]:
    	    BEGIN
    	    DIGITS_IN_FRACT = 33;
    	    STATUS = FOR$CVT_H_TE(.VAL_DESC[DBG$L_VALUE_POINTER], DESCRIPTOR,
    		.DIGITS_IN_FRACT, 0, 0, 4);
    	    END;

    	[INRANGE, OUTRANGE]:
    	    $DBG_ERROR('DBGEVALOP\GET_SCALE, not floating-point data');

    	TES;

    IF NOT .STATUS THEN $DBG_ERROR('DBGEVALOP\GET_SCALE, FOR$CVT_x_yE error');
    	    

    ! Locate "+" or "-".  
    ! (E+nn or E-nn for exp. <= 99), (+nnn or -nnn for exp. <=999)
    ! is the standard Fortran E-format.
    !
    E_FLAG = CH$FIND_CH(50, BUFFER, %C'E');
    E_PTR = CH$FIND_CH(50, BUFFER, %C'+');
    IF .E_PTR EQL 0
    THEN
    	E_PTR = CH$FIND_CH(50, BUFFER, %C'-');

    IF .E_PTR EQL 0 THEN $DBG_ERROR('DBGEVALOP\GET_SCALE, not E-format expected');


    ! Locate the '.'.  For example: 0.48E+06.
    !
    D_PTR = CH$FIND_CH(50, BUFFER, %C'.');


    ! Convert the next few characters into integer (+/- and digits).
    !
    DESCRIPTOR[DSC$W_LENGTH] = BUFFER[49] - .E_PTR + 1;
    DESCRIPTOR[DSC$A_POINTER] = .E_PTR;
    STATUS = OTS$CVT_TI_L(DESCRIPTOR, EXPONENT);
    IF NOT .STATUS THEN $DBG_ERROR('DBGEVALOP\GET_SCALE, OTS$CVT_TI_L error');

    DIGITS[0] = .E_PTR - .D_PTR - 1;
    IF .E_FLAG NEQ 0 THEN DIGITS[0] = .DIGITS[0] - 1;
    SCALE = .EXPONENT - .DIGITS[0];
    RETURN .SCALE;

    END;


ROUTINE FIND_JOIN (LEFT_TYPE, RIGHT_TYPE,
    		   NEW_LEFT_TYPE, NEW_RIGHT_TYPE, ROUT_INDEX,
    		   DEPTH, MIN,
    		   HIER_TBL, HIER_TBL_SIZE, 
    		   INCOMP_TBL, INCOMP_TBL_SIZE,
    		   ROUT_TBL, ROUT_TBL_SIZE) =

!
! FUNCTION
!	Given a pair of types and a Type Hierarchy Graph, this routine attempts
!	to determine what conversions should be done on the types. It does
!	this by finding the "join" of the two nodes in the graph. Usually,
!	this will just be a path from the lower type to the higher type; e.g.,
!	if integer is added to float, float is the higher type, and a path
!	from integer to float is found, so the integer is converted to float.
!	There may be cases where both are converted to a higher type; e.g.,
!	in FORTRAN, if FLOAT COMPLEX is added to D_FLOAT, both are promoted
!	to D_FLOAT COMPLEX. 
!
! INPUTS
!	HIER_TBL	- Hier. Table
!	HIER_TBL_SIZE	- Hier. Table Size
!    	INCOMP_TBL	- Incomp. Table
!	INCOMP_TBL_SIZE - Incomp. Table Size
!	ROUT_TBL	- Rout. Table
!	ROUT_TBL_SIZE	- Rout. Table Size
!	LEFT_TYPE	- The type of the left operand.
!	RIGHT_TYPE	- The type of the right operand.
!	NEW_LEFT_TYPE 	- The address in which to place the new type of the
!				left operand.
!	NEW_RIGHT_TYPE	- The address in which to place the new type of the
!				right operand.
!	ROUT_INDEX	- An address in which to fill in a routine index from
!			-       the Operator Routine Table
!	DEPTH		- Depth of recursion. DBG$EVAL_LANG_OPERATOR passes
!			        in zero, and this routine passes 1+.DEPTH when
!			        it calls itself, so it can keep track of the
!				recursion depth.
!	MIN		- The minimum length conversion path so far. 
!
! OUTPUTS
!	Routine Value: If a set of conversions to legal types was found,
!	the length of the paths through the conversion graph is returned.
!	Otherwise, MAX_DEPTH is returned. (I.e., a set of conversions were
!	found if the return value is less than MAX_DEPTH. The reason for
!	doing it this way (instead of just returning TRUE/FALSE) is so that
!	a recursive method can be used to find the minimal path).
!
!	The following output parameters are filled in:
!	NEW_LEFT_TYPE  - The type to convert the left operand to.
!	NEW_RIGHT_TYPE - The type to convert the right operand to.
!	ROUT_INDEX     - An index into the Operator Routine Table, pointing
!			    to a legal operator on the new types
!

    BEGIN

    MAP
        HIER_TBL: REF VECTOR [,WORD],	! Pointer to a Type Hierarchy Table
        INCOMP_TBL: REF VECTOR [,WORD],	! Pointer to a Type Incompatibility Table
        ROUT_TBL: REF ORT$TABLE;	! Pointer to an Operator Routine Table

    LOCAL
    	HIER_TBL_ENTRY : TYPE_GRAPH$ENTRY,	! An entry in the Type Hierarchy
    						!     Table.
    	INCOMP_TBL_ENTRY: TYPE_GRAPH$ENTRY,	! An entry in the Type
    						!     Incompatibility Table
    	LEFT_DONE: BYTE,			! Flag saying we have searched
    						!     recursively from left sone
    	LEFT_FOUND: BYTE,			! A flag saying whether we found
    						!     LEFT_TYPE in the Type
    						!     Hierarchy Table.
    	LEFT_INDEX,				! Index of the first occurence
    						!     of LEFT_TYPE in the
    						!     Type Hierarchy Table
    	LEFT_POTENTIAL_TYPE,			! Potential new left type.
    	POTENTIAL_DEPTH,			! Possible minimum length path
    	POTENTIAL_INDEX,			! A candidate for an index into
    						!     the Operator Routine Table
    	REVERSE_TYPES: TYPE$PAIR,		! A type pair
    	RIGHT_DONE: BYTE,			! Flag saying we have searched
    						!     recursively from the 
    						!     right son.
    	RIGHT_FOUND: BYTE,			! A flag saying whether we found
    						!     RIGHT_TYPE in the Type
    						!     Hierarchy Table.
    	RIGHT_INDEX,				! Index of the first occurence 
    						!     of RIGHT_TYPE in the
    						!     Type Hierarchy Table
    	RIGHT_POTENTIAL_TYPE,			! Potential new right type
    	TYPES: TYPE$PAIR;			! A type pair.


    ! First see if the given type pair is legal, by searching the Operator
    ! Routine Table. If it is, then the length of the path to a legal
    ! type pair is zero and this is what we return.
    !
    TYPES [B$_LEFT_TYPE] = .LEFT_TYPE;
    TYPES [B$_RIGHT_TYPE] = .RIGHT_TYPE;
    INCR I FROM 0 TO .ROUT_TBL_SIZE - 1 DO
    	IF .TYPES EQL .ROUT_TBL [.I, ORT$W_TYPES]
    	THEN
    	    BEGIN
    	    .NEW_LEFT_TYPE = .LEFT_TYPE;
    	    .NEW_RIGHT_TYPE = .RIGHT_TYPE;
    	    .ROUT_INDEX = .I;
    	    RETURN .DEPTH;
       	    END;    	
    	
    ! Terminate further searching if minimum so far is already smaller
    ! than potential paths.
    !
    IF .DEPTH + 1 GEQ .MIN
    THEN
    	RETURN .MAX_DEPTH;

    ! Check for incompatibility of the given types.
    !
    REVERSE_TYPES [B$_LEFT_TYPE] = .RIGHT_TYPE;
    REVERSE_TYPES [B$_RIGHT_TYPE] = .LEFT_TYPE;
    IF .INCOMP_TBL NEQ TABLEBASE
    THEN
    	INCR I FROM 0 TO .INCOMP_TBL_SIZE - 1 DO
    	    BEGIN
    	    INCOMP_TBL_ENTRY = .INCOMP_TBL [.I];
    	    IF .INCOMP_TBL_ENTRY EQL 0 THEN EXITLOOP;
    	    IF .TYPES EQL .INCOMP_TBL_ENTRY [TYPE_GRAPH$W_BOTH_TYPES]
    	    THEN
    		RETURN .MAX_DEPTH;
    	    IF .REVERSE_TYPES EQL .INCOMP_TBL_ENTRY [TYPE_GRAPH$W_BOTH_TYPES]
    	    THEN
    		RETURN .MAX_DEPTH;
    	    END;    

    ! Check for no Hierarchy Table being present.
    !
    IF .HIER_TBL EQL TABLEBASE
    THEN
    	RETURN .MAX_DEPTH;

    ! Find the first edges emanating from LEFT_TYPE and RIGHT_TYPE
    ! in the Type Hierarchy Table.
    !
    LEFT_FOUND = FALSE;
    RIGHT_FOUND = FALSE;
    INCR I FROM 0 TO .HIER_TBL_SIZE - 1 DO
    	BEGIN
    	HIER_TBL_ENTRY = .HIER_TBL [.I];
    	IF .HIER_TBL_ENTRY EQL 0 THEN EXITLOOP;
    	IF NOT .LEFT_FOUND
    	THEN
    	    IF .HIER_TBL_ENTRY [TYPE_GRAPH$B_LOWER_TYPE] EQL .LEFT_TYPE
    	    THEN
    	        BEGIN
    	        LEFT_FOUND = TRUE;
    		LEFT_INDEX = .I;
    	        END;
    	IF NOT .RIGHT_FOUND
    	THEN
       	    IF .HIER_TBL_ENTRY [TYPE_GRAPH$B_LOWER_TYPE] EQL .RIGHT_TYPE
    	    THEN
    	        BEGIN
    	        RIGHT_FOUND = TRUE;
    		RIGHT_INDEX = .I;
    	        END;
    	IF .LEFT_FOUND AND .RIGHT_FOUND THEN EXITLOOP;
    	END;

    ! Now do the recursive calls on the edges emanating out of the given
    ! types. As a heuristic to speed up the search, start with the lower
    ! index.
    !
    LEFT_DONE = FALSE;
    RIGHT_DONE = FALSE;
    WHILE TRUE DO
    	BEGIN
        IF .LEFT_FOUND
        THEN
    	    BEGIN

    	    ! Only do the recursive call from here if either we have already
    	    ! searched from the right son, or if the left index comes before
    	    ! the right index.
    	    !
    	    IF .RIGHT_DONE OR .LEFT_INDEX LEQ .RIGHT_INDEX
    	    THEN 
    		BEGIN
    		LEFT_DONE = TRUE;

    		! Loop through all the successors to LEFT_TYPE.
    		!
    	 	HIER_TBL_ENTRY = .HIER_TBL [.LEFT_INDEX];
    		WHILE .HIER_TBL_ENTRY [TYPE_GRAPH$B_LOWER_TYPE] EQL .LEFT_TYPE DO
    	    	    BEGIN
    	    	    POTENTIAL_DEPTH = FIND_JOIN (
    				.HIER_TBL_ENTRY [TYPE_GRAPH$B_HIGHER_TYPE],
    				.RIGHT_TYPE,
    				LEFT_POTENTIAL_TYPE,
    				RIGHT_POTENTIAL_TYPE,
    				POTENTIAL_INDEX,
    				1+.DEPTH,
    				.MIN,
    	    			.HIER_TBL, .HIER_TBL_SIZE, 
    				.INCOMP_TBL, .INCOMP_TBL_SIZE,
    				.ROUT_TBL, .ROUT_TBL_SIZE);

    		    ! If we have a new minimum length path, then record
    		    ! all the relevant information.
    		    !
    	    	    IF .POTENTIAL_DEPTH LSS .MIN
    	    	    THEN
    		    	BEGIN
    		    	MIN = .POTENTIAL_DEPTH;
    		    	.NEW_LEFT_TYPE = .LEFT_POTENTIAL_TYPE;
    		    	.NEW_RIGHT_TYPE = .RIGHT_POTENTIAL_TYPE;
    		    	.ROUT_INDEX = .POTENTIAL_INDEX;
		    	END;

    		    ! Set up for next time around loop.
    		    !
    	    	    LEFT_INDEX = .LEFT_INDEX + 1;
    	    	    HIER_TBL_ENTRY = .HIER_TBL [.LEFT_INDEX];
    	    	    END;
    		END;
    	    END;

    	IF .RIGHT_FOUND
    	THEN    	
    	    BEGIN

    	    ! Only do the recursive call from here if either we have already
    	    ! searched from the left son, or if the right index comes before
    	    ! the right index.
    	    !
    	    IF .LEFT_DONE OR .RIGHT_INDEX LEQ .LEFT_INDEX
    	    THEN
    	        BEGIN
    		RIGHT_DONE = TRUE;

    		! Loop through all the successors to RIGHT_TYPE.
    		!
    	    	HIER_TBL_ENTRY = .HIER_TBL [.RIGHT_INDEX];
    		WHILE .HIER_TBL_ENTRY [TYPE_GRAPH$B_LOWER_TYPE] EQL .RIGHT_TYPE DO
    	    	    BEGIN
    	    	    POTENTIAL_DEPTH = FIND_JOIN (
    				.LEFT_TYPE,
    				.HIER_TBL_ENTRY [TYPE_GRAPH$B_HIGHER_TYPE],
    				LEFT_POTENTIAL_TYPE,
    				RIGHT_POTENTIAL_TYPE,
    				POTENTIAL_INDEX,
    				1+.DEPTH,
    				.MIN,
    				.HIER_TBL, .HIER_TBL_SIZE, 
    				.INCOMP_TBL, .INCOMP_TBL_SIZE,
    				.ROUT_TBL, .ROUT_TBL_SIZE);


    		    ! If we have a new minimum length path, then record
    		    ! all the relevant information.
    		    !
    	    	    IF .POTENTIAL_DEPTH LSS .MIN
    	    	    THEN
    			BEGIN
    			MIN = .POTENTIAL_DEPTH;
    			.NEW_LEFT_TYPE = .LEFT_POTENTIAL_TYPE;
    			.NEW_RIGHT_TYPE = .RIGHT_POTENTIAL_TYPE;
    			.ROUT_INDEX = .POTENTIAL_INDEX;
    			END;


    		    ! Set up for next time around loop.
    		    !
    	    	    RIGHT_INDEX = .RIGHT_INDEX + 1;
    	    	    HIER_TBL_ENTRY = .HIER_TBL [.RIGHT_INDEX];
    		    END;
    		END;
    	    END;

    	! If we have searched both paths, we are done.
    	!
    	IF (.RIGHT_DONE OR NOT .RIGHT_FOUND) AND (.LEFT_DONE OR NOT .LEFT_FOUND)
    	THEN 
    	    EXITLOOP;
    	END;

    RETURN .MIN;

    END;

ROUTINE FIND_PATH (OLD_TYPE, NEW_TYPE, ROUT_INDEX,
    		HIER_TBL, HIER_TBL_SIZE, 
    		INCOMP_TBL, INCOMP_TBL_SIZE,
    		ROUT_TBL, ROUT_TBL_SIZE) =
!
! FUNCTION
!	This routine handles implicit type conversions on unary operators.
!	It determines whether the given OLD_TYPE can be converted to
!	a type that is legal for the current operator. The legal types
!	can be determined using ORT_TBL. HIER_TBL gives the legal conversion
!	paths. Thus, what this routine is doing is finding a path in 
!	HIER_TBL from the OLD_TYPE to a type that is legal for the
!	current operator.
!
!	The value returned by the routine is the length of the shortest
!	path to a legal type. If there are no paths, the value MAX_DEPTH
!	is returned.
!
!	The search for a path uses the following recursive method:
!	1) If the input type is legal, return 0
!	2) If there are no edges out of the type, return MAX_DEPTH.
!	3) For each edge out of the type, do a recursive call to obtain
!	   MIN(MAX_DEPTH,1+FIND_PATH(edge)). Return the minimum of these.
!
!	*** Note - This routine may also require additional input to
!	    disambiguate cases where there are two or more paths of 
!	    equal length. 
!
! INPUTS
!	HIER_TBL	- Hier. Table
!	HIER_TBL_SIZE	- Hier. Table Size
!    	INCOMP_TBL	- Incomp. Table
!	INCOMP_TBL_SIZE - Incomp. Table Size
!	ROUT_TBL	- Rout. Table
!	ROUT_TBL_SIZE	- Rout. Table Size
!	OLD_TYPE	- The type of the operand (A VAX standard type code.)
!	NEW_TYPE	- The address in which to leave the result type.
!	ROUT_INDEX	- The address in which to leave an index into the
!			     Operator Routine Table, pointing to a routine
!			     that handles the new type.
!
! OUTPUTS
!	NEW_TYPE	- This output parameter is filled in with the type
!			     to convert to.
!	ROUT_INDEX	- Filled in with an index into the Operator Routine
!			     Table, pointing to a routine that handles the
!			     new type.
!
! ROUTINE VALUE
!	The length of the shortest path is returned. If this is equal to
!	MAX_DEPTH then no path was found.
!

    BEGIN

    MAP
        HIER_TBL: REF VECTOR [,WORD],	! Pointer to a Type Hierarchy Table
        INCOMP_TBL: REF VECTOR [,WORD],	! Pointer to a Type Incompatibility Table
        ROUT_TBL: REF ORT$TABLE;	! Pointer to an Operator Routine Table

    LOCAL
	FOUND,				     ! A flag saying whether 
    					     !    we have found a new type
    	HIER_TBL_ENTRY: TYPE_GRAPH$ENTRY,    ! An entry in the Type Hierarchy Table
    	II,				     ! A loop counter
    	MIN,				     ! The minimum depth so far
    	POTENTIAL_DEPTH,		     ! A candidate for shortest depth
    	POTENTIAL_ROUT_INDEX,		     ! A candidate for routine index
       	POTENTIAL_TYPE;			     ! A candidate for the new type


    ! First see if the given type is legal, by searching the Operator
    ! Routine Table. If it is, then the length of the path to a legal
    ! type is zero and this is what we return.
    !
    INCR I FROM 0 TO .ROUT_TBL_SIZE - 1 DO
    	IF .OLD_TYPE EQL .ROUT_TBL [.I, ORT$B_LEFT_TYPE]
    	THEN
    	    BEGIN
    	    .NEW_TYPE = .OLD_TYPE;
    	    .ROUT_INDEX = .I;
    	    RETURN 0;
       	    END;    	

    ! Check for no Hierarchy Table being present.
    !
    IF .HIER_TBL EQL TABLEBASE
    THEN
    	RETURN .MAX_DEPTH;

    ! Find the first edge emanating from OLD_TYPE in the Type Hierarchy Table.
    !
    FOUND = FALSE;
    INCR I FROM 0 TO .HIER_TBL_SIZE - 1 DO
    	BEGIN
    	II = .I;
    	HIER_TBL_ENTRY = .HIER_TBL [.I];
    	IF .HIER_TBL_ENTRY EQL 0 THEN EXITLOOP;
    	IF .HIER_TBL_ENTRY [TYPE_GRAPH$B_LOWER_TYPE] EQL .OLD_TYPE
    	THEN
    	    BEGIN
    	    FOUND = TRUE;
    	    EXITLOOP;
    	    END;
    	END;

    ! If there were no edges emanating from OLD_TYPE, then no type conversion
    ! can be done. Indicate this by returning MAX_DEPTH.
    !
    IF NOT .FOUND THEN RETURN .MAX_DEPTH;

    ! For each edge out of OLD_TYPE, chase down the target of that edge.
    ! Do a recursive call on that target to find a path from the target
    ! to a legal type. Keep track of the minimum length path in the
    ! variable MIN.
    !
    MIN = .MAX_DEPTH;
    WHILE .HIER_TBL_ENTRY [TYPE_GRAPH$B_LOWER_TYPE] EQL .OLD_TYPE DO
    	BEGIN

    	POTENTIAL_DEPTH = FIND_PATH (
    		.HIER_TBL_ENTRY [TYPE_GRAPH$B_HIGHER_TYPE], POTENTIAL_TYPE,
    		POTENTIAL_ROUT_INDEX,
    		.HIER_TBL, .HIER_TBL_SIZE, 
    		.INCOMP_TBL, .INCOMP_TBL_SIZE,
    		.ROUT_TBL, .ROUT_TBL_SIZE);

    	IF .POTENTIAL_DEPTH LSS .MIN
    	THEN
    	    BEGIN
    	    MIN = .POTENTIAL_DEPTH;
    	    .NEW_TYPE = .POTENTIAL_TYPE;	
    	    .ROUT_INDEX = .POTENTIAL_ROUT_INDEX;
    	    END;

    	! Set up for next time around loop.
    	II = .II + 1;
    	HIER_TBL_ENTRY = .HIER_TBL [.II];
    	END;

    IF .MIN EQL .MAX_DEPTH
    THEN 
    	RETURN .MAX_DEPTH
    ELSE
    	RETURN .MIN + 1;

    END; ! FIND_PATH

ROUTINE FIND_PATH_DEPOSIT (OLD_TYPE, NEW_TYPE, DEPTH,
    		HIER_TBL, HIER_TBL_SIZE, 
    		INCOMP_TBL, INCOMP_TBL_SIZE,
    		ROUT_TBL, ROUT_TBL_SIZE) =
!
! FUNCTION
!	This routine handles explicit type conversions on unary operators.
!	It is used to determine whether the type given in OLD_TYPE
!	can be converted to the type given in NEW_TYPE. The main
!	application of this is when the user is doing a DEPOSIT of a
!	value of type OLD_TYPE into a primary of type NEW_TYPE.
!	The routine may also get used to implement the "cast" operator
!	or to implement type conversions of subscript values. 
!
!	This routine uses HIER_TBL and attempts to find a path from
!	OLD_TYPE to NEW_TYPE. The value TRUE is returned if a path
!	is found and FALSE is returned if a path is not found.
!
!	The search for a path uses the following recursive method:
!	1) If the two types are the same, return TRUE
!	2) If there are no edges out of OLD_TYPE, return FALSE.
!	3) For each edge out of OLD_TYPE, do a recursive call. If
!	   any of these return TRUE, then return TRUE.
!
!
! INPUTS
!	HIER_TBL	- Hier. Table
!	HIER_TBL_SIZE	- Hier. Table Size
!    	INCOMP_TBL	- Incomp. Table
!	INCOMP_TBL_SIZE - Incomp. Table Size
!	ROUT_TBL	- Rout. Table
!	ROUT_TBL_SIZE	- Rout. Table Size
!	OLD_TYPE	- The type of the source operand (A VAX standard type code.)
!	NEW_TYPE	- The target type (A VAX standard type code).
!	DEPTH		- The current recursion depth
!
! OUTPUTS
!	The routine value is one of:
!	TRUE	- The source can be converted to the target type
!	FALSE	- The source cannot be converted to the target type.
!

    BEGIN

    MAP
        HIER_TBL: REF VECTOR [,WORD],	! Pointer to a Type Hierarchy Table
        INCOMP_TBL: REF VECTOR [,WORD],	! Pointer to a Type Incompatibility Table
        ROUT_TBL: REF ORT$TABLE;	! Pointer to an Operator Routine Table

    LOCAL
	FOUND,				     ! A flag saying whether 
    					     !    we have found a new type
    	HIER_TBL_ENTRY: TYPE_GRAPH$ENTRY,    ! An entry in the Type Hierarchy Table
    	II;				     ! A loop counter


    ! First see if the source and target are already of the same type.
    !
    IF .NEW_TYPE EQL .OLD_TYPE
    THEN
    	RETURN TRUE;

    ! Then check whether we have already surpassed the maximum depth
    ! to which we have to search.
    !
    IF .DEPTH GTR .MAX_DEPTH
    THEN
    	RETURN FALSE;

    ! Check for no Hierarchy Table being present.
    !
    IF .HIER_TBL EQL TABLEBASE
    THEN
    	RETURN FALSE;

    ! Find the first edge emanating from OLD_TYPE in the Type Hierarchy Table.
    !
    FOUND = FALSE;
    INCR I FROM 0 TO .HIER_TBL_SIZE - 1 DO
    	BEGIN
    	II = .I;
    	HIER_TBL_ENTRY = .HIER_TBL [.I];
    	IF .HIER_TBL_ENTRY EQL 0 THEN EXITLOOP;
    	IF .HIER_TBL_ENTRY [TYPE_GRAPH$B_LOWER_TYPE] EQL .OLD_TYPE
    	THEN
    	    BEGIN
    	    FOUND = TRUE;
    	    EXITLOOP;
    	    END;
    	END;

    ! If there were no edges emanating from OLD_TYPE, then no type conversion
    ! can be done. Indicate this by returning FALSE.
    !
    IF NOT .FOUND 
    THEN 
    	RETURN FALSE;

    ! For each edge out of OLD_TYPE, chase down the target of that edge.
    ! Do a recursive call on that target to find out whether there is
    ! a path from the edge.
    !
    WHILE .HIER_TBL_ENTRY [TYPE_GRAPH$B_LOWER_TYPE] EQL .OLD_TYPE DO
    	BEGIN

    	IF FIND_PATH_DEPOSIT (
    		.HIER_TBL_ENTRY [TYPE_GRAPH$B_HIGHER_TYPE], .NEW_TYPE,
    		.DEPTH+1,
    		.HIER_TBL, .HIER_TBL_SIZE, 
    		.INCOMP_TBL, .INCOMP_TBL_SIZE,
    		.ROUT_TBL, .ROUT_TBL_SIZE)
    	THEN
    	    RETURN TRUE;


    	! Set up for next time around loop.
    	II = .II + 1;
    	HIER_TBL_ENTRY = .HIER_TBL [.II];
    	END;

    ! If we didn't return true from within the loop, then we failed to
    ! find a path. Thus, return false here.
    !
    RETURN FALSE;

    END; ! FIND_PATH_DEPOSIT


ROUTINE FIXUP_EMPTY_SET(EMPTY_SET, VAL_DESC) =
!
! FUNCTION
!	This routine sets up the typeid in empty set value descriptor
!	either by taking it from val_desc or creating a new one by
!	calling DBG$TYPEID_FOR_SET.
!
! INPUTS
!	EMPTY_SET	- [] value descriptor.
!
!	VAL_DESC	- Value descriptor.  This may be 0 for unary operation,
!			This may be another [], or standard value descriptor.
!
! OUTPUTS
!	Fixed Empty Set Value Descriptor is returned.
!

    BEGIN

    MAP
    	EMPTY_SET: REF DBG$VALDESC,
    	VAL_DESC: REF DBG$VALDESC;


    EMPTY_SET[DBG$B_DHDR_LANG] = .DBG$GB_LANGUAGE;
    EMPTY_SET[DBG$B_VALUE_CLASS] = 0;
    EMPTY_SET[DBG$B_VALUE_DTYPE] = 0;
    IF .VAL_DESC EQL 0 OR
       .VAL_DESC[DBG$B_DHDR_FCODE] NEQ RST$K_TYPE_SET OR
       (.VAL_DESC[DBG$B_DHDR_LANG] EQL %X'FF' AND
    	.VAL_DESC[DBG$B_VALUE_CLASS] EQL %X'FF' AND
    	.VAL_DESC[DBG$B_VALUE_DTYPE] EQL %X'FF')
    THEN
    	EMPTY_SET[DBG$L_DHDR_TYPEID] = DBG$TYPEID_FOR_SET(
    	    DSC$K_DTYPE_L, RST$K_TYPE_SET, 256, TRUE)

    ELSE
    	BEGIN
        EMPTY_SET[DBG$L_DHDR_TYPEID] = .VAL_DESC[DBG$L_DHDR_TYPEID];
    	EMPTY_SET[DBG$W_VALUE_LENGTH] = .VAL_DESC[DBG$W_VALUE_LENGTH];
    	END;

    RETURN .EMPTY_SET;
    END;


ROUTINE INTMED_DATA_FOR_DEP(FROM_DESC, TO_DATA_TYPE, FLAG) = 
!
! FUNCTION
!	There are times an intermediate data is needed before the deposit.
!	This routine takes the from descriptor converts to intermediate
!	data, return the intermediate data back to the caller.  The caller
!	takes intermediate data then performs the deposit into TO_DESC.
!
! INPUTS
!	FROM_DESC	- From value descriptor.
!
!	TO_DATA_TYPE	- Intermediate data type.
!
!	FLAG		- Flag set to TRUE to indidate left hand side
!			of the deposit.
!
! OUTPUTS
!	Intermediate data type is returned.
!

    BEGIN

    MAP
    	FROM_DESC: REF DBG$VALDESC;	! Pointer to value descriptor.

    LOCAL
    	DIGITS,				! The number of digits.
    	INTMED_DESC: REF DBG$VALDESC;	! Intermediate data value descriptor.


    CASE .FROM_DESC[DBG$B_VALUE_DTYPE] FROM 0 TO DBG$K_MAXIMUM_DTYPE +
    						 RST$K_TYPE_MAXIMUM    OF
    	SET


    	[DSC$K_DTYPE_NL, DSC$K_DTYPE_NLO, DSC$K_DTYPE_NR, DSC$K_DTYPE_NRO,
    	 DSC$K_DTYPE_NZ]:
    	    BEGIN
    	    IF .FLAG THEN RETURN .FROM_DESC;
    	    INTMED_DESC = MAKE_VAL_DESC(.TO_DATA_TYPE, 
    				        DBG$NUM_BYTES(.TO_DATA_TYPE),
    					0,
    				        TRUE);
    	    INTMED_DESC[DBG$B_VALUE_DIGITS] = .FROM_DESC[DBG$B_VALUE_DIGITS];
    	    INTMED_DESC[DBG$B_VALUE_SCALE] = .FROM_DESC[DBG$B_VALUE_SCALE];
    	    INTMED_DESC[DBG$W_VALUE_LENGTH] = .FROM_DESC[DBG$W_VALUE_LENGTH];
    	    INTMED_DESC = DBG$TYPE_CONV (.FROM_DESC, .INTMED_DESC);
    	    END;


        ! If right hand side is one of the floating-point data type, we need to
    	! get the exponent value and that is the scaling factor.  For
    	! example F --> P, F = 0.1234567E+04  --> P = 1234.567.  This should
    	! not appear on the left hand side.
    	!
    	[DSC$K_DTYPE_F, DSC$K_DTYPE_D, DSC$K_DTYPE_G, DSC$K_DTYPE_H]:
    	    BEGIN
    	    INTMED_DESC = MAKE_VAL_DESC(.TO_DATA_TYPE, 
    				        DBG$NUM_BYTES(.TO_DATA_TYPE),
    					0,
    				        TRUE);
    	    INTMED_DESC[DBG$B_VALUE_SCALE] = GET_SCALE(.FROM_DESC, DIGITS);
    	    INTMED_DESC[DBG$B_VALUE_DIGITS] = .DIGITS;
    	    INTMED_DESC[DBG$W_VALUE_LENGTH] = .DIGITS;
    	    INTMED_DESC = DBG$TYPE_CONV (.FROM_DESC, .INTMED_DESC);
    	    END;


    	! If we deposit a interger data type into a scaled data type,
    	! change its class to be scaled.  This can be on the left
    	! hand side of the deposit (may be voliatile) or on the
    	! right hand side.
    	!
    	[DSC$K_DTYPE_B, DSC$K_DTYPE_W, DSC$K_DTYPE_L, DSC$K_DTYPE_Q,
    	 DSC$K_DTYPE_BU, DSC$K_DTYPE_WU, DSC$K_DTYPE_LU, DSC$K_DTYPE_QU]:
    	    BEGIN
    	    INTMED_DESC = MAKE_VAL_DESC(.TO_DATA_TYPE, 
    			                DBG$NUM_BYTES(.TO_DATA_TYPE),
    					0,
    				        TRUE);


    	    ! Put in the scale information.
    	    !
    	    IF .FROM_DESC[DBG$B_VALUE_CLASS] EQL DSC$K_CLASS_SD
    	    THEN
    		BEGIN
    		INTMED_DESC[DBG$B_VALUE_SCALE] = .FROM_DESC[DBG$B_VALUE_SCALE];


    		! The number of digits is assigned according to the COBOL rule.
    		! This should be adequate for all the languages.
    		!
    		SELECTONE .FROM_DESC[DBG$B_VALUE_DTYPE] OF
    		    SET
    		    [DSC$K_DTYPE_B, DSC$K_DTYPE_BU]:
    			BEGIN
    			IF .FROM_DESC[DBG$B_VALUE_DIGITS] EQL 0
    			THEN
    			    BEGIN
		            INTMED_DESC[DBG$W_VALUE_LENGTH] = 3;
    			    INTMED_DESC[DBG$B_VALUE_DIGITS] = 3;
    			    END
    			ELSE
    			    BEGIN
    			    INTMED_DESC[DBG$W_VALUE_LENGTH] = .FROM_DESC[DBG$B_VALUE_DIGITS];
    			    INTMED_DESC[DBG$B_VALUE_DIGITS] = .FROM_DESC[DBG$B_VALUE_DIGITS];
    			    END;
    			END;

    		    [DSC$K_DTYPE_W, DSC$K_DTYPE_WU]:
    			BEGIN
    			IF .FROM_DESC[DBG$B_VALUE_DIGITS] EQL 0
    			THEN
    			    BEGIN
		            INTMED_DESC[DBG$W_VALUE_LENGTH] = 5;
    			    INTMED_DESC[DBG$B_VALUE_DIGITS] = 5;
    			    END
    			ELSE
    			    BEGIN
    			    INTMED_DESC[DBG$W_VALUE_LENGTH] = .FROM_DESC[DBG$B_VALUE_DIGITS];
    			    INTMED_DESC[DBG$B_VALUE_DIGITS] = .FROM_DESC[DBG$B_VALUE_DIGITS];
    			    END;

    			END;

    		    [DSC$K_DTYPE_L, DSC$K_DTYPE_LU]:
    			BEGIN
    			IF .FROM_DESC[DBG$B_VALUE_DIGITS] EQL 0
    			THEN
    			    BEGIN
		            INTMED_DESC[DBG$W_VALUE_LENGTH] = 10;
    			    INTMED_DESC[DBG$B_VALUE_DIGITS] = 10;
    			    END
    			ELSE
    			    BEGIN
    			    INTMED_DESC[DBG$W_VALUE_LENGTH] = .FROM_DESC[DBG$B_VALUE_DIGITS];
    			    INTMED_DESC[DBG$B_VALUE_DIGITS] = .FROM_DESC[DBG$B_VALUE_DIGITS];
    			    END;

    			END;

    		    [DSC$K_DTYPE_Q, DSC$K_DTYPE_QU]:
    			BEGIN
    			IF .FROM_DESC[DBG$B_VALUE_DIGITS] EQL 0
    			THEN
    			    BEGIN
		            INTMED_DESC[DBG$W_VALUE_LENGTH] = 20;
    			    INTMED_DESC[DBG$B_VALUE_DIGITS] = 20;
    			    END
    			ELSE
    			    BEGIN
    			    INTMED_DESC[DBG$W_VALUE_LENGTH] = .FROM_DESC[DBG$B_VALUE_DIGITS];
    			    INTMED_DESC[DBG$B_VALUE_DIGITS] = .FROM_DESC[DBG$B_VALUE_DIGITS];
    			    END;

    			END;

    		    TES;

    		END;


    	    ! There is no real conversion needed for left hand side
    	    ! of the deposit, we only want to make a place holder.
    	    !
    	    IF NOT .FLAG 
    	    THEN 
    		INTMED_DESC = DBG$TYPE_CONV(.FROM_DESC, .INTMED_DESC);

    	    RETURN .INTMED_DESC;
    	    END;


    	! Does nothing, return the from_desc.
    	!
    	[INRANGE, OUTRANGE]:
    	    RETURN .FROM_DESC;

    	TES;

    RETURN .INTMED_DESC;
    END;


ROUTINE MAKE_VAL_DESC (TYPE, LENGTH, DESC, FLAG) =
!
! FUNCTION
!	Allocates space for a value descriptor of the given type, and
!	fills in the fields.
!
! INPUTS
!	TYPE  - 	A VAX standard dtype code.
!	LENGTH -	Length of the value descriptor
! 	DESC -		Points to a Value descriptor which is
!			used in some cases to determine the fields
!			of this new descriptor. This is described
!			in more detail in the code.
!	FLAG  -         Flag set to indicate when call dbg$map_dtype_class
!			the returned class should be SD instead of S for
!			returning S case.
!
! OUTPUTS
!	Returns the address of a value descriptor allocated out of temporary
!	memory.
!

    BEGIN
    MAP
    	DESC: REF DBG$VALDESC;
    LOCAL
    	ALLOC_LENGTH,			! Allocated length of descriptor
    					!    in bytes
    	DESCR_LENGTH,			! Length of the descriptor
    	RESULT: REF DBG$VALDESC;	! Address of the result descriptor


    DESCR_LENGTH = .LENGTH;
    IF .TYPE EQL DSC$K_DTYPE_VT
    THEN
    	BEGIN
    	IF .DESCR_LENGTH LSS 14 
    	THEN 
    	    DESCR_LENGTH = 16 
    	ELSE 
    	    DESCR_LENGTH = .DESCR_LENGTH + 2;
    	RESULT = DBG$GET_TEMPMEM (ALLOC_LENGTH = DBG$K_VALDESC_BASE_SIZE +
    		(3 + MIN (.DESCR_LENGTH, 256 + 2)) / 4);
    	END

    ELSE
    	BEGIN
    	IF .TYPE EQL DSC$K_DTYPE_P
    	THEN
    	    DESCR_LENGTH = MAX (16, (.DESCR_LENGTH + 1) / 4)
    	ELSE
            DESCR_LENGTH = MAX (16, .DESCR_LENGTH);

    	RESULT = DBG$GET_TEMPMEM (ALLOC_LENGTH = DBG$K_VALDESC_BASE_SIZE + 
    		(3 + MIN (.DESCR_LENGTH, 256)) / 4); 
    	END;


    ! Fill in the fields of the new value descriptor.
    !
    RESULT [DBG$B_DHDR_LANG] = .DBG$GB_LANGUAGE;
    RESULT [DBG$B_DHDR_TYPE] = DBG$K_VALUE_DESC;
    RESULT [DBG$W_DHDR_LENGTH] = 4*.ALLOC_LENGTH;
    RESULT [DBG$B_DHDR_KIND] = RST$K_DATA;
    IF .TYPE GTR DBG$K_MAXIMUM_DTYPE
    THEN
    	BEGIN
        RESULT [DBG$B_DHDR_FCODE] = .TYPE - DBG$K_MAXIMUM_DTYPE;
    	RESULT [DBG$B_VALUE_CLASS] = 0;
    	RESULT [DBG$B_VALUE_DTYPE] = 0;
    	END

    ELSE
    	BEGIN
    	IF .FLAG
    	THEN
    	    RESULT [DBG$B_DHDR_FCODE] = RST$K_TYPE_DESCR

    	ELSE
            RESULT [DBG$B_DHDR_FCODE] = RST$K_TYPE_ATOMIC;
    	RESULT [DBG$B_VALUE_CLASS] = DBG$MAP_DTYPE_CLASS(.TYPE, .FLAG);
    	RESULT [DBG$B_VALUE_DTYPE] = .TYPE;
    	END;

    RESULT [DBG$W_VALUE_LENGTH] = MIN(.LENGTH, 256);
    RESULT [DBG$L_VALUE_POINTER] = RESULT[DBG$A_VALUE_ADDRESS];

    ! If we are converting to "FIXED" then we need to fill in the
    ! dtype field. We also need to light the binscale flag.
    !
    IF .TYPE EQL DSC$K_DTYPE_FIXED
    THEN
    	BEGIN
    	RESULT[DBG$V_VALUE_FL_BINSCALE] = 1;
        RESULT[DBG$B_VALUE_DTYPE] = DSC$K_DTYPE_L;
    	END;

    RETURN .RESULT;
    END;   ! MAKE_VAL_DESC 

ROUTINE MAP_NRO_DTYPE_IN_RPG(VAL_DESC) =
!
! FUNCTION
!	This routine maps the representation of least significant digit and
!	sign into RPG standard output format acceptting both normal or 
!	alternate as inputs.
!
! INPUTS
!	VAL_DESC	- Pointer to NRO data type value descriptor.
!
! OUTPUTS
!	VAL_DESC is returned.
!

    BEGIN

    MAP
    	VAL_DESC: REF DBG$VALDESC;	! Pointer to value descriptor

    LOCAL
    	LEAST_SIG_DIGIT: REF VECTOR[,BYTE];! Pointer to the least significant
    					   !	digit


    ! In RPG, representation of least significant digit and sign
    ! both normal/alternate ASCII char. can be accepted in RPG.
    ! but RPG choose one format to be the standard output format.
    ! In here we simply map it into the standard output format.
    !
    LEAST_SIG_DIGIT = .VAL_DESC[DBG$L_VALUE_POINTER] + 
    		.VAL_DESC[DBG$W_VALUE_LENGTH] - 1;


    ! We perform the following mapping:
    ! 
    ! Input               Output
    ! norm.  alt.
    !  {     0 [ ?          0
    !  A     1              1
    !  B     2              2
    !  C     3              3
    !  D     4              4
    !  E     5              5
    !  F     6              6
    !  G     7              7
    !  H     8              8
    !  I     9              9
    !  }     ] : !          }
    !
    IF .LEAST_SIG_DIGIT[0] EQL '{' OR
       .LEAST_SIG_DIGIT[0] EQL '0' OR
       .LEAST_SIG_DIGIT[0] EQL '[' OR
       .LEAST_SIG_DIGIT[0] EQL '?'
    THEN
    	LEAST_SIG_DIGIT[0] = '0';

    IF .LEAST_SIG_DIGIT[0] GEQ 'A' AND
       .LEAST_SIG_DIGIT[0] LEQ 'I'
    THEN
    	LEAST_SIG_DIGIT[0] = .LEAST_SIG_DIGIT[0] - %X'10';

    IF .LEAST_SIG_DIGIT[0] EQL '}' OR
       .LEAST_SIG_DIGIT[0] EQL ']' OR
       .LEAST_SIG_DIGIT[0] EQL ':' OR
       .LEAST_SIG_DIGIT[0] EQL '!'
    THEN
    	LEAST_SIG_DIGIT[0] = '}';

    RETURN .VAL_DESC;
    END;


ROUTINE MAP_PACKED (NEW_TYPE, DIGITS, OTHER_TYPE):  NOVALUE =
!
! FUNCTION
!	This routine maps a packed decimal type to another type.  This cannot
!	always be done in the hierarchy tables; in the case of converting
!	packed to floating point, it is necessary to know how many digits are
!	involved before mapping the type.
!
! INPUTS
!	NEW_TYPE	- The address in which to place the new type.  On
!			  entering the routine, it should already point to 
!			  type DSC$K_DTYPE_P.
!	DIGITS		- The number of digits in the packed decimal number.
!	OTHER_TYPE	- In certain instances, the other operand helps in 
!			  determining how to map the packed decimal number.
!			  For example, if there are 15 digits in the packed
!			  decimal number:  it is mapped to gfloat if the other
!			  operand is gfloat, hfloat if the other operand is
!			  hfloat, otherwise double.
!
! OUTPUTS
!	A new type may be returned in NEW_TYPE.
!
    BEGIN


    ! Expect NEW_TYPE to already point to a packed decimal type.  This assures
    ! that we have at least one packed decimal operand, and can case on the 
    ! other.
    !
    IF ..NEW_TYPE NEQ DSC$K_DTYPE_P
    THEN
	RETURN;

    CASE .OTHER_TYPE FROM 0 TO DBG$K_MAXIMUM_DTYPE + RST$K_TYPE_MAXIMUM OF
	SET


	! If the other operand is floating, then the conversion is packed ->
	! float.  The type of floating point conversion (whether to single or
	! double precision, or to gfloat or hfloat) depends on both the number
	! of digits in the packed decimal number, and in some cases, on the
	! type of the other operand.
	!
	[DSC$K_DTYPE_F, DSC$K_DTYPE_D, DSC$K_DTYPE_G, DSC$K_DTYPE_H]:
	    BEGIN
	    CASE .DIGITS FROM 1 TO DBG$K_LARGEST_PACKED OF
		SET

		[1 TO 6]:
		    .NEW_TYPE = DSC$K_DTYPE_F;

		[7 TO 15]:
		    BEGIN
		    IF .OTHER_TYPE EQL DSC$K_DTYPE_G OR
		       .OTHER_TYPE EQL DSC$K_DTYPE_H
		    THEN
			.NEW_TYPE = .OTHER_TYPE
		    ELSE
			.NEW_TYPE = DSC$K_DTYPE_D;
		    END;

		[16]:
		    .NEW_TYPE = DSC$K_DTYPE_D;

		[17 TO 31]:
	  	    .NEW_TYPE = DSC$K_DTYPE_H;

		[OUTRANGE]:
		    SIGNAL (DBG$_ILLTYPE);
		TES;
	    RETURN;
	    END;


	! Presently, the other type conversions involving packed decimal types
	! can be handled through the hierarchy tables.
	!
	[INRANGE]:
	    RETURN;

	[OUTRANGE]:
	    $DBG_ERROR ('DBGEVALOP\MAP_PACKED');
	TES;
    END;

ROUTINE MAP_PLI_TYPE_SIZE (VALDESC, TYPE, SIZE, SRC_FLAG):  NOVALUE =
!
! FUNCTION
!	PL/I run-time routines do not follow the VAX calling standard.  They
!	also do not understand VMS descriptors.  Consequently, this routine
!	was developed to map dtypes to PL/I specific types, and to determine
!	the correct size for that specific type.  This information is
!	required in the interface to a PL/I routine.
!
! INPUTS
!	VALDESC	- Pointer to a value descriptor.
!
!	TYPE 	- Address where to place the PL/I specific type.
!
!	SIZE	- Address where to place the size of the type.
!
!	SRC_FLAG - Set to TRUE to indicate this is the source,
!		 set to FALSE to indicate this is the target.
!
! OUTPUTS
!	The PL/I specific data type and size are returned in TYPE and SIZE.
!
    BEGIN

    MAP
    	TYPE: REF VECTOR[1],
    	SIZE: REF VECTOR[1],
 	VALDESC:  REF DBG$VALDESC;

    LOCAL
    	SIZE_BYTE: REF VECTOR[,BYTE],   ! Size in byte vector
    	LANGCODE,			! Language code
    	PICTPTR: REF VECTOR[,BYTE],	! Pointer to picture representation
    	PICTVAL,			! Pointer to language specific encoding
    	PSCALE: VECTOR[2, BYTE];	! Digits and Scale

    	
    SIZE_BYTE = .SIZE;
    SIZE[0] = 0;
    CASE .VALDESC[DBG$B_VALUE_DTYPE] FROM 0 TO DBG$K_MAXIMUM_DTYPE OF
	SET
	[DSC$K_DTYPE_B]:
	    BEGIN
	    TYPE[0] = DBG$K_PLI_FIX_BIN;
	    SIZE[0] = 7;
	    END;
        [DSC$K_DTYPE_W]:
	    BEGIN
	    TYPE[0] = DBG$K_PLI_FIX_BIN;
	    SIZE[0] = 15;
	    END;
        [DSC$K_DTYPE_L]:
	    BEGIN
	    TYPE[0] = DBG$K_PLI_FIX_BIN;
	    SIZE[0] = 31;
	    END;
	[DSC$K_DTYPE_F]:
	    BEGIN
	    TYPE[0] = DBG$K_PLI_FLO_DEC;
	    SIZE[0] = 7;
	    END;
	[DSC$K_DTYPE_D, DSC$K_DTYPE_G]:
	    BEGIN
	    TYPE[0] = DBG$K_PLI_FLO_DEC;
	    SIZE[0] = 15;
	    END;
	[DSC$K_DTYPE_H]:
	    BEGIN
	    TYPE[0] = DBG$K_PLI_FLO_DEC;
	    SIZE[0] = 34;
	    END;
	[DSC$K_DTYPE_T]:
	    BEGIN
	    IF .VALDESC[DBG$B_DHDR_FCODE] EQL RST$K_TYPE_PICT
    	    THEN
	        BEGIN
	        TYPE[0] = DBG$K_PLI_PIC;
    		DBG$STA_TYP_PICT(.VALDESC[DBG$L_DHDR_TYPEID], LANGCODE,
    			PICTPTR, PICTVAL, PSCALE);
    		SIZE[0] = .PICTVAL;
	        END
    	    ELSE
    		BEGIN
	    	TYPE[0] = DBG$K_PLI_CHAR;
	    	SIZE[0] = .VALDESC[DBG$W_VALUE_LENGTH];
    		END;
	    END;
	[DSC$K_DTYPE_VT]:
	    BEGIN
    	    LOCAL
    		VALPTR: REF VECTOR[,WORD];

	    TYPE[0] = DBG$K_PLI_CHAR_VAR;
    	    IF .SRC_FLAG
    	    THEN
    		BEGIN
    	        VALPTR = .VALDESC[DBG$L_VALUE_POINTER];
	        SIZE[0] = .VALPTR[0];
    		END
    	    ELSE
    		SIZE[0] = .VALDESC[DBG$W_VALUE_LENGTH];

	    END;
	[DSC$K_DTYPE_P]:
	    BEGIN
	    TYPE[0] = DBG$K_PLI_FIX_DEC;


    	    ! PLI runtime library routine expect to see 1234.1234 (8 digits
    	    ! and 4 as scale factor, normally, would be -4 as scale factor).
    	    !
	    SIZE_BYTE[1] = - .VALDESC[DBG$B_VALUE_SCALE];
	    SIZE_BYTE[0] = .VALDESC[DBG$W_VALUE_LENGTH];
	    END;
	[DSC$K_DTYPE_V]:
	    BEGIN
	    TYPE[0] = DBG$K_PLI_ABIT;
	    SIZE[0] = .VALDESC[DBG$W_VALUE_LENGTH];
	    END;
	[DSC$K_DTYPE_VU]:
	    BEGIN
	    TYPE[0] = DBG$K_PLI_UBIT;
	    SIZE[0] = .VALDESC[DBG$W_VALUE_LENGTH];
	    END;
	[INRANGE, OUTRANGE]:
    	    BEGIN
    	    $DBG_ERROR ('DBGEVALOP\MAP_PLI_TYPE_SIZE:  invalid dtype');
    	    END;
	TES;
	    
    END;

ROUTINE MODIFY_PLI_TARGET_TYPE(OPERATOR, LEFT_TYPE, RIGHT_TYPE, 
    	NEW_LEFT_TYPE, NEW_RIGHT_TYPE, NEW_ROUT_INDEX,
    	HIER_TBL, HIER_TBL_SIZE, 
    	INCOMP_TBL, INCOMP_TBL_SIZE,
    	ROUT_TBL, ROUT_TBL_SIZE) : NOVALUE =

!
! FUNCTION
!	This routine is used to adjust the target data type based on
!	the type of the other operand for arithmetic and relational
!	operators in PLI.
!
!	PLI has very unique type conversion rule, which differs from
!	the other language, graph hierarchy scheme stand alone can
!	not satisfy the needs without modification.  This routine
!	is a separate routine to serve the needs.
!
!	After the walking the graph from previous FIND_JOIN, we know
!	the data types we work with are valid.  First we check the
!	operator, if the operator is not one of the arithmetic/relational
!	operators, we know the result from FIND_JOIN is ok.  Second,
!	we check to see if one of the operands has data type V, VU, T, or VT,
!	if not, we know the result from FIND_JOIN is ok.  Third, we modify
!	the target based on the following tables:
!
!	+---------+---------+---------+---------+---------+---------+
!       !         !  B,W,L  !    P    ! F,D,G,H !  V,VU   !  T,VT   !
!       +---------+---------+---------+---------+---------+---------+
!       !  B,W,L  !  B,W,L  !  B,W,L  ! F,D,G,H !    L    !    L    !
!	+---------+---------+---------+---------+---------+---------+
!	!    P    !    L    !    P    ! F,D,G,H !    L    !    P    !
!	+---------+---------+---------+---------+---------+---------+
!       ! F,D,G,H ! F,D,G,H ! F,D,G,H ! F,D,G,H ! F,D,G,H ! F,D,G,H !
!	+---------+---------+---------+---------+---------+---------+
!	!  V,VU   !    L    !    L    ! F,D,G,H !   *1    !    L    !
!	+---------+---------+---------+---------+---------+---------+
!	!  T,VT   !    L    !    P    ! F,D,G,H !    L    !   *2    !
!	+---------+---------+---------+---------+---------+---------+
!
!	*1 - Relational operator: no change for data types.
!	     Arithmetic operator: L
!
!	*2 - Relational operator: no change for data types.
!	     Arithmetic operator: P
!
!	Note: Unary operator does not have the problem, so this routine
!	only works with binary operator.
!
!	Note: FIXED_BIN, FIXED_DEC, FLOAT_DEC, CHAR, CHAR_VAR, BIT, and
!	BIT_ALGNED are the data types we know in PLI.  (there are others
!	ie., FLOAT_BIN, BIT_VAR.).
!
! INPUTS
!	OPERATOR	- Token Operator.
!	LEFT_TYPE	- Original left data type.
!	RIGHT_TYPE	- Original right data type.
!	NEW_LEFT_TYPE	- The address of the new left data type.
!	NEW_RIGHT_TYPE	- The address of the new right data type.
!	NEW_ROUT_INDEX	- The address of the new corresponding routine index.
!	HIER_TBL	- Hier. table.
!	HIER_TBL_SIZE	- Hier. table size.
!	INCOMP_TBL	- Incomp. table.
!	INCOMP_TBL_SIZE	- Incomp. table size.
!	ROUT_TBL	- Rout. table.
!	ROUT_TBL_SIZE	- Rout. table size.
!
! OUTPUTS
!	If there is modification NEW targer data type is returned along
!	with corresponding routine index.
!	

    BEGIN

    MAP
    	OPERATOR: REF TOKEN$ENTRY,
    	NEW_LEFT_TYPE: REF VECTOR[,LONG],
    	NEW_RIGHT_TYPE: REF VECTOR[,LONG],
    	NEW_ROUT_INDEX: REF VECTOR[,LONG];

    LOCAL
    	LEFT,
    	RIGHT,
    	GROUP1,
    	GROUP2;


    ! We only worry about this set of tokens.  If the token is not in the set
    ! simply returns.
    !
    GROUP1 = FALSE;
    GROUP2 = FALSE;
    IF .OPERATOR[TOKEN$W_CODE] EQL TOKEN$K_ADD OR
       .OPERATOR[TOKEN$W_CODE] EQL TOKEN$K_SUBTRACT OR
       .OPERATOR[TOKEN$W_CODE] EQL TOKEN$K_MULTIPLY OR
       .OPERATOR[TOKEN$W_CODE] EQL TOKEN$K_DIVIDE 
    THEN
    	GROUP1 = TRUE

    ELSE
    	BEGIN
    	IF .OPERATOR[TOKEN$W_CODE] EQL TOKEN$K_EQUAL OR
           .OPERATOR[TOKEN$W_CODE] EQL TOKEN$K_NOT_EQUAL OR
           .OPERATOR[TOKEN$W_CODE] EQL TOKEN$K_GTR_THAN OR
           .OPERATOR[TOKEN$W_CODE] EQL TOKEN$K_GTR_EQUAL OR
           .OPERATOR[TOKEN$W_CODE] EQL TOKEN$K_LSS_THAN OR
           .OPERATOR[TOKEN$W_CODE] EQL TOKEN$K_LSS_EQUAL
        THEN
    	    GROUP2 = TRUE

    	ELSE
            RETURN 0;
    	END;


    ! Smash VT to T, VU to V.  As far as this routine's concern, they are
    ! treated the same.  In this way, we reduce some data types to handle.
    !
    LEFT = .LEFT_TYPE;
    RIGHT = .RIGHT_TYPE;
    IF .LEFT EQL DSC$K_DTYPE_VT THEN LEFT = DSC$K_DTYPE_T;
    IF .LEFT EQL DSC$K_DTYPE_VU THEN LEFT = DSC$K_DTYPE_V;
    IF .RIGHT EQL DSC$K_DTYPE_VT THEN RIGHT = DSC$K_DTYPE_T;
    IF .RIGHT EQL DSC$K_DTYPE_VU THEN RIGHT = DSC$K_DTYPE_V;


    ! We only worry about this set of data types.  If one of the operand
    ! is V or T then we need to modify the target.  Otherwise, simply
    ! returns.
    !
    IF .LEFT_TYPE NEQ DSC$K_DTYPE_V AND
       .LEFT_TYPE NEQ DSC$K_DTYPE_T AND
       .RIGHT_TYPE NEQ DSC$K_DTYPE_V AND
       .RIGHT_TYPE NEQ DSC$K_DTYPE_T 
    THEN
    	RETURN 0;


    ! Filter out V op V, T op T, V op T, T op V cases.
    !
    IF (.LEFT EQL DSC$K_DTYPE_V AND .RIGHT EQL DSC$K_DTYPE_V) OR
       (.LEFT EQL DSC$K_DTYPE_T AND .RIGHT EQL DSC$K_DTYPE_T) OR
       (.LEFT EQL DSC$K_DTYPE_V AND .RIGHT EQL DSC$K_DTYPE_T) OR
       (.LEFT EQL DSC$K_DTYPE_T AND .RIGHT EQL DSC$K_DTYPE_V)
    THEN
    	BEGIN


    	! If this is relational operator, then we all set.
    	!
    	IF .GROUP2
    	THEN
    	    RETURN 0


    	! If this is arithmetic operator, modify the target.
    	! 
    	ELSE
    	    BEGIN
    	    IF .LEFT EQL DSC$K_DTYPE_T AND .RIGHT EQL DSC$K_DTYPE_T
    	    THEN
    		BEGIN
    		NEW_LEFT_TYPE[0] = DSC$K_DTYPE_P;
    		NEW_RIGHT_TYPE[0] = DSC$K_DTYPE_P;
    		END

    	    ELSE
    		BEGIN
    		NEW_LEFT_TYPE[0] = DSC$K_DTYPE_L;
    		NEW_RIGHT_TYPE[0] = DSC$K_DTYPE_L;
    		END;


    	    ! Get the corresponding routine table index.
    	    !
    	    IF .MAX_DEPTH EQL FIND_JOIN(
    		    .NEW_LEFT_TYPE[0], .NEW_RIGHT_TYPE[0],
    		    NEW_LEFT_TYPE[0],  NEW_RIGHT_TYPE[0], 
    		    NEW_ROUT_INDEX[0],
    		    0, .MAX_DEPTH,
    		    .HIER_TBL, .HIER_TBL_SIZE, 
    		    .INCOMP_TBL, .INCOMP_TBL_SIZE,
    		    .ROUT_TBL, .ROUT_TBL_SIZE)
    	    THEN
	        SIGNAL(DBG$_OPNOTALLOW, 1, OPERATOR[TOKEN$B_OPLEN]);

    	    RETURN 0;
            END;
    	END;


    ! Now we have V op (B, W, L, P, F, D, G, H) or T op (B, W, ...) cases.
    !
    INCR I FROM 0 TO 1 DO
        BEGIN
    	LOCAL
    	    TYPE, OTHER_TYPE;

    	IF .I EQL 0
        THEN
    	    BEGIN
    	    TYPE = .LEFT;
    	    OTHER_TYPE = .RIGHT;
    	    END

    	ELSE
    	    BEGIN
    	    TYPE = .RIGHT;
    	    OTHER_TYPE = .LEFT;
    	    END;

    	SELECTONE .TYPE OF
    	    SET
    	    [DSC$K_DTYPE_L]:
    		BEGIN
    		NEW_LEFT_TYPE[0] = DSC$K_DTYPE_L;
    		NEW_RIGHT_TYPE[0] = DSC$K_DTYPE_L;
    		END;

    	    [DSC$K_DTYPE_B, DSC$K_DTYPE_W, DSC$K_DTYPE_P]:
    		BEGIN

! Apparently, PLI documentation and PLI compiler have a different point
! of view to decide which target to assign.  This is the reason we
! commented out this piece.  We take PLI compiler's result.
!    		IF .OTHER_TYPE EQL DSC$K_DTYPE_V
!    		THEN
!    		    BEGIN
!    		    NEW_LEFT_TYPE[0] = DSC$K_DTYPE_L;
!    		    NEW_RIGHT_TYPE[0] = DSC$K_DTYPE_L;
!    		    END
!
!    		ELSE
!    		    BEGIN
    		    NEW_LEFT_TYPE[0] = DSC$K_DTYPE_P;
    		    NEW_RIGHT_TYPE[0] = DSC$K_DTYPE_P;
!    		    END;
    		END;


    	    ! This is not really needed.  Because the graph can take care
    	    ! of these nicely.  I left this in for documentation purpose.
    	    !
    	    [DSC$K_DTYPE_F, DSC$K_DTYPE_D, DSC$K_DTYPE_G, DSC$K_DTYPE_H]:
    		BEGIN
	        NEW_LEFT_TYPE[0] = .TYPE;
    		NEW_RIGHT_TYPE[0] = .TYPE;
    		END;

    	    [DSC$K_DTYPE_V, DSC$K_DTYPE_T]:
    		0;

    	    TES;

    	END;

    IF .MAX_DEPTH EQL FIND_JOIN(
    	 	.NEW_LEFT_TYPE[0], .NEW_RIGHT_TYPE[0],
    	 	NEW_LEFT_TYPE[0],  NEW_RIGHT_TYPE[0], 
    	 	NEW_ROUT_INDEX[0],
    	 	0, .MAX_DEPTH,
    		.HIER_TBL, .HIER_TBL_SIZE, 
    		.INCOMP_TBL, .INCOMP_TBL_SIZE,
    		.ROUT_TBL, .ROUT_TBL_SIZE)
    THEN
        SIGNAL(DBG$_OPNOTALLOW, 1, OPERATOR[TOKEN$B_OPLEN]);

    RETURN 0;
    END;


ROUTINE PLI_TYPE_CONV (VALUE1, VALUE2) =
!
! FUNCTION
!	Performs PLI language-specific type conversion on the given 
!	descriptors.
!
! INPUTS
!	VALUE1  	- DEBUG value descriptor for the source
!	VALUE2  	- DEBUG value descriptor for the target
!
! OUTPUTS
!	A pointer to the result descriptor is returned.
!
    BEGIN

    ENABLE
  	PLI_HANDLER;

    MAP
    	VALUE1 : REF DBG$VALDESC,
    	VALUE2 : REF DBG$VALDESC;

    LOCAL
	SRC_ADDR,   DST_ADDR,
	SRC_TYPE,   DST_TYPE,
	SRC_SIZE,   DST_SIZE,
	SRC_OFFSET, DST_OFFSET;


    ! In PL/I, special conversions are required when going to/from
    ! bit-strings.  PL/I bit-strings are stored in reverse order in
    ! memory; although they are mapped to type DSC$K_DTYPE_TF, this
    ! means that they cannot be converted by DBG$CVT_DX_DX, which
    ! treats bit-strings like integers.
    !
    ! Get the source and destination pointers.
    !
    SRC_ADDR = .VALUE1[DBG$L_VALUE_POINTER];
    DST_ADDR = .VALUE2[DBG$L_VALUE_POINTER];


    ! Map the current dtype to PL/I specific types; calculate the
    ! size for the type.
    !
    MAP_PLI_TYPE_SIZE(.VALUE1, SRC_TYPE, SRC_SIZE, TRUE);


    ! Get the digit and scale info from picture data type.
    !
    IF .VALUE1[DBG$B_DHDR_FCODE] EQL RST$K_TYPE_PICT AND
       .VALUE2[DBG$B_VALUE_DTYPE] EQL DSC$K_DTYPE_P
    THEN
    	BEGIN
    	LOCAL
    	    PICTVAL: REF VECTOR[,BYTE];

    	PICTVAL = .SRC_SIZE;
    	VALUE2[DBG$B_VALUE_DIGITS] = .PICTVAL[0];


    	! note: PLIRTL expects to see positive scale 2 for (12.34),
    	! normally we'll have -2 as the scale.  
    	!
    	VALUE2[DBG$B_VALUE_SCALE] = - .PICTVAL[1];
    	END;
    	
    MAP_PLI_TYPE_SIZE(.VALUE2, DST_TYPE, DST_SIZE, FALSE);


    ! Determine the bit offset.  This should be zero for aligned types.
    ! The [DBG$L_VALUE_POS] field of the value descriptor could be
    ! garbage for packed decimal types, but PLI$CVRT_ANY ignores the
    ! offset for any types except those that might be unaligned.
    !
    SRC_OFFSET = 0;
    DST_OFFSET = 0;
    IF .VALUE1[DBG$B_VALUE_DTYPE] EQL DSC$K_DTYPE_VU
    THEN
        SRC_OFFSET = .VALUE1[DBG$L_VALUE_POS];

    IF .VALUE2[DBG$B_VALUE_DTYPE] EQL DSC$K_DTYPE_VU
    THEN
        DST_OFFSET = .VALUE2[DBG$L_VALUE_POS];


    ! Call a PL/I run-time routine to do the conversion.
    !
    PLI$CVRT_ANY (SRC_ADDR, .SRC_TYPE, .SRC_SIZE, .SRC_OFFSET,
		  DST_ADDR, .DST_TYPE, .DST_SIZE, .DST_OFFSET);

    RETURN .VALUE2;
    END;

ROUTINE PLI_HANDLER (SIG, MECH) =
!
! FUNCTION
!	This handler catches PL/I specific data type conversion errors, and 
!	signals them as Debug errors.  It resignals all other conditions.
!
! INPUTS
!	SIG  - A counted vector of parameters describing the condition.
!
!	MECH - A counted vector of parameters from CHF.
!
! OUTPUTS
!	
!
    BEGIN

    MAP
    	SIG: REF VECTOR[,LONG];

    !Translate all numeric exceptions to debug's facility code.
    !Also, translate SS$_ROPRAND to DBG$_ROPRANDF.
    !
    SELECTONE .SIG[1] OF
	SET
	[SS$_INTOVF]:
	    SIGNAL (DBG$_IINTOVF, 1, .DBG$GL_OPCODE_NAME);
	[SS$_DECOVF]:
	    SIGNAL (DBG$_DECOVF, 1, .DBG$GL_OPCODE_NAME);
	[SS$_FLTOVF, SS$_FLTOVF_F]:
	    SIGNAL (DBG$_FLTOVF, 1, .DBG$GL_OPCODE_NAME);
	[SS$_FLTUND, SS$_FLTUND_F]:
	    SIGNAL (DBG$_IFLTUND, 1, .DBG$GL_OPCODE_NAME);
	[SS$_ROPRAND]:
	    SIGNAL (DBG$_ROPRANDF, 1, .DBG$GL_OPCODE_NAME);
	[SS$_UNWIND]:
	    RETURN (SS$_RESIGNAL);
    	[OTHERWISE]:
    	    SIGNAL (DBG$_PLICVTERR, 1, .DBG$GL_OPCODE_NAME);
	TES;

    SETUNWIND();
    RETURN 0;
    END;					! End of PLI_HANDLER

ROUTINE TYPEID_CHECK_ENUM(TYPEID1, TYPEID2) =
!
! FUNCTION
!	This routine performs typeid check on the given TYPEIDs for enumeration
!	data types.
!
! INPUTS
!	TYPEID1	- TYPEID RST entry pointer.
!
!	TYPEID2	- TYPEID RST entry pointer.
!
! OUTPUTS
!	Returned Status: TRUE or FALSE.
!

    BEGIN

    MAP
    	TYPEID1: REF RST$ENTRY,		! Typeid pointer to RST entry
    	TYPEID2: REF RST$ENTRY;		! Typeid pointer to RST entry

    LOCAL
    	STATUS;				! Return status


    IF .TYPEID1 EQL 0 OR .TYPEID2 EQL 0
    THEN
    	RETURN FALSE;

    IF .TYPEID1 EQL .TYPEID2
    THEN
        STATUS = TRUE

    ELSE
        BEGIN
    	IF .TYPEID1[RST$B_FCODE] EQL .TYPEID2[RST$B_FCODE]
    	THEN
    	    BEGIN
    	    IF .TYPEID1[RST$B_FCODE] EQL RST$K_TYPE_ENUM
    	    THEN
    	        BEGIN
    		IF .TYPEID1[RST$L_DSTPTR] EQL .TYPEID2[RST$L_DSTPTR]
    		THEN
    		    STATUS = TRUE
    		ELSE
    		    STATUS = FALSE;

    		END

    	    ELSE
    	        STATUS = FALSE;

    	    END

    	ELSE
    	    STATUS = FALSE;

    	END;

    RETURN .STATUS;

    END;

ROUTINE TYPEID_CHECK_SET(TYPEID1, TYPEID2, FCODE1, FCODE2, DTYPE1, DTYPE2) =
!
! FUNCTION
!	This routine performs typeid check on the given TYPEIDs for set
!	data types.
!
! INPUTS
!	TYPEID1	- TYPEID RST entry pointer.
!
!	TYPEID2	- TYPEID RST entry pointer.
!
!	FCODE1	- Fcode
!
!	FCODE2	- Fcode
!
!	DTYPE1	- Data type
!
!	DTYPE2	- Data type
!
! OUTPUTS
!	Returned Status: TRUE or FALSE.
!

    BEGIN

    MAP
    	TYPEID1: REF RST$ENTRY,		! Typeid pointer to RST entry
    	TYPEID2: REF RST$ENTRY;		! Typeid pointer to RST entry

    LOCAL
     	STATUS;				! Return status


    IF .TYPEID1 EQL .TYPEID2
    THEN
        STATUS = TRUE
    ELSE
        BEGIN
    	IF .FCODE1 EQL .FCODE2
    	THEN
    	    BEGIN
    	    IF .FCODE1 EQL RST$K_TYPE_ATOMIC
    	    THEN
    		BEGIN
    		IF .DTYPE1 EQL .DTYPE2
    		THEN
    		    BEGIN
    		    IF .DTYPE1 EQL DSC$K_DTYPE_TF OR
    		       .DTYPE1 EQL DSC$K_DTYPE_L OR
    		       .DTYPE1 EQL DSC$K_DTYPE_LU OR
    		       .DTYPE1 EQL DSC$K_DTYPE_T
    		    THEN
    		        STATUS = TRUE
    		    ELSE
    			STATUS = FALSE;

    		    END

    		ELSE
    		    STATUS = FALSE;

    		END

    	    ELSE
    		BEGIN
    		IF .FCODE1 EQL RST$K_TYPE_ENUM
    		THEN
    		    BEGIN
    		    IF .TYPEID1[RST$L_DSTPTR] EQL .TYPEID2[RST$L_DSTPTR]
    		    THEN
    			STATUS = TRUE
    		    ELSE
    			STATUS = FALSE;

    		    END

    		ELSE
    		    STATUS = FALSE;

    		END;

    	    END

    	ELSE
    	    STATUS = FALSE;

    	END;

    RETURN .STATUS;
    END;


ROUTINE TYPEID_RANGE_CHECK_ENUM(VAL_DESC, TYPEID) =
!
! FUNCTION
!	This routine takes given typeid in the value descriptor and 
!	performs the value range check for enumeration type.
!
! INPUTS
!	VAL_DESC	- Pointer to value descriptor.
!
!	TYPEID		- Typeid of the data type.
!
! OUTPUTS
!	Return True to indicate the value is in the range else
!	return false.
!

    BEGIN

    MAP
    	TYPEID: REF RST$ENTRY,
    	VAL_DESC: REF DBG$VALDESC;

    LOCAL
    	ADR_KIND, 			! Address kind
    	ADR_PTRS: VECTOR[3,LONG],	! Address value
    	NELTS,				! Number of elements
	NLTVECPTR: REF VECTOR[,LONG],	! A vector of RST entries for the elements
    	SIZE;


    IF .TYPEID[RST$B_FCODE] NEQ RST$K_TYPE_ENUM
    THEN
    	$DBG_ERROR('DBGEVALOP\TYPEID_RANGE_CHECK_ENUM');

    DBG$STA_TYP_ENUM(.TYPEID, NELTS, NLTVECPTR, SIZE);
    INCR I FROM 0 TO .NELTS - 1 DO
    	BEGIN
    	DBG$STA_SYMVALUE(.NLTVECPTR[.I], ADR_PTRS, ADR_KIND);
    	IF .(.ADR_PTRS[0])<.ADR_PTRS[1], .SIZE, 0> EQL
    	   .(.VAL_DESC[DBG$L_VALUE_POINTER])
    	THEN
    	    RETURN TRUE;
    	END;

    RETURN FALSE;

    END;

ROUTINE TYPEID_RANGE_CHECK_SUBRNG(VAL_DESC, TYPEID) =
!
! FUNCTION
!	This routine takes given typeid in the value descriptor and 
!	performs the value range check for subrange type.
!
! INPUTS
!	VAL_DESC	- Pointer to value descriptor.
!
!	TYPEID		- Typeid of the data type.  This is not
!			necessary from the VAL_DESC directly.
!
! OUTPUTS
!	Return True to indicate the value is in the range else
!	return false.
!

    BEGIN

    MAP
    	VAL_DESC: REF DBG$VALDESC,
    	TYPEID: REF RST$ENTRY;

    LOCAL
    	LENGTH,				! Length
    	HIGHPTR,			! High range value
    	LOWPTR,				! Low range value
    	PARENT_TYPE,			! Parent typeid
    	SETVAL: VECTOR[8, LONG],
    	SETVALUE: REF BITVECTOR[],
    	SET_VAL_DESC: REF VECTOR[, LONG],
    	SIZE;

    IF .TYPEID[RST$B_FCODE] NEQ RST$K_TYPE_SUBRNG
    THEN
    	$DBG_ERROR('DBGEVALOP\TYPEID_RANGE_CHECK_SUBRNG');

    DBG$STA_TYP_SUBRNG(.TYPEID, PARENT_TYPE, LOWPTR, HIGHPTR, SIZE);
    IF .VAL_DESC[DBG$B_DHDR_FCODE] EQL RST$K_TYPE_SET
    THEN
    	BEGIN
    	LENGTH = (.VAL_DESC[DBG$W_VALUE_LENGTH] - 1) / 4 + 1;
    	INCR I FROM 0 TO .LENGTH - 1 DO
    	    SETVAL[.I] = %X'FFFFFFFF';
    	SETVALUE = SETVAL[0];
    	INCR I FROM ..LOWPTR TO ..HIGHPTR DO
    	    SETVALUE[.I] = 0;
    	SET_VAL_DESC = .VAL_DESC[DBG$L_VALUE_POINTER];
    	INCR I FROM 0 TO .LENGTH - 1 DO
    	    BEGIN
    	    SETVAL[.I] = .SET_VAL_DESC[.I] AND .SETVAL[.I];
    	    IF .SETVAL[.I] NEQ 0 THEN RETURN FALSE;
            END;

    	RETURN TRUE;
    	END

    ELSE
    	BEGIN
    	IF (..HIGHPTR GEQ ..VAL_DESC[DBG$L_VALUE_POINTER]) AND
           (..LOWPTR LEQ ..VAL_DESC[DBG$L_VALUE_POINTER])
    	THEN
    	    RETURN TRUE
        ELSE
    	    RETURN FALSE;
    	END;

    END;

END ELUDOM
