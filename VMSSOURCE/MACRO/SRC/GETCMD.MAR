	.TITLE	MAC$GETCMD	GET COMMAND MODULE
	.IDENT	'V04-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:	VAX MACRO ASSEMBLER OBJECT LIBRARY
;
; ABSTRACT:
;
; The VAX-11 MACRO assembler translates MACRO-32 source code into object
; modules for input to the VAX-11 LINKER.
;
; ENVIRONMENT:	USER MODE
;
; AUTHOR: Benn Schreiber, CREATION DATE: 28-AUG-78
;
; MODIFIED BY:
;
;	V03-010		RRB0031		Rowland R. Bradley	15-Jul-1984
;		Reinit dynamic string desc. prior to calling LIST_QUAL.  This
;		avoids trashing the output filename.
;
;	V03-009		RRB0030		Rowland R. Bradley	06-Jul-1984
;		Fix concatenated file lists.  Handle library files in
;		searchlists(use current global context) and flag errors 
;		appropriately.  Enable user to specify object and listing 
;		in different places.  Replace NAM block(it is needed by
;		SUM$xxx routines).  Fix problem with /UPDATES to properly 
;		handle an update file.
;
;	V03-008		RRB0025		Rowland R. Bradley	21-May-1984
;		Add support for proper handling of input files
;		using LIB$FIND_FILE.  Add appropriate comments and
;		clean up existing comments.  Signal LIB$FIND_FILE errors
;		correctly.  Reorganize GET_INPUT to more efficiently handle
;		input files.  Handle positional qualifiers on libraries.
;
;	V03-007		RRB0014		Rowland R. Bradley	27-Feb-1984
;		Bug fix which handles positional /LIST qualifiers on libraries
;		as a global /LIST qualifier.
;
;	V03-006		RRB0011		Rowland R. Bradley	29-Jan-1984
;		Modify to handle locally present /LIST & /OBJECT qualifiers
;		correctly(added GET_LOC_LIST, GET_LOC_OBJECT, and modified
;		GET_LIST and GET_OBJECT).  Fix length of filename for
;		to handle long filenames in INP_FILE. 
;
;	V03-005		MTR0030		Mike Rhodes		28-Mar-1983
;		Modify code to handle GLOBAL vs. LOCALly PRESENT qualifiers.
;
;	V03-004		MTR0029		Mike Rhodes		18-Mar-1983
;		Check for explicit negation of qualifiers, before performing
;		the negation actions (due to new CLI interface).
;
;	V03-003		MTR0026		Mike Rhodes		24-Feb-1983
;		Remember the length of the last input file opened with its
;		expanded string in MAC$INP_NAM_BUF.  The cell holding the
;		length is MAC$GB_INPNAMLEN.
;
;	V03-002		MTR0022		Mike Rhodes		01-Feb-1983
;		Convert to new CLI interface.
;
;	V03-001		MTR0020		Mike Rhodes		07-Jul-1982
;		Modify the handling of the /ENABLE /DISABLE /SHOW and /NOSHOW
;		qualifiers, such that they truly override their corresponding
;		assembler directives actions.  A new flag MAC$GL_DSLISF has
;		been employed to facilitate this manipulation.
;		Affected modules are SHOW_ENAB and DBG_NEXT_OPT.
;
;	V03-000		MTR0010		Mike Rhodes		15-Mar-1982
;		Remove $CLIDEFQUALMACR macro, since the symbols which it
;		defined are globally available during the build.
;
;	V02-014		MTR0002		Mike Rhodes		01-Dec-1981
;		Modify the /DEBUG action routine to allow the SYMBOLS and
;		TRACEBACK qualifier values to coexist in a qualifier list
;		without negating one another.
;
;	V02-013		MTR0001		Mike Rhodes		09-Nov-1981
;		Add a new action routine (called by the CLI parsing routines)
;		to process the /[NO]DEBUG qualifier and its parameters.  The
;		processing consists of setting/clearing bits in the options
;		vector MAC$GL_ENLISF.
;
;	V02-012		BLS0057		Benn Schreiber		13-Jun-1981
;		Correct reference to SUM$OPEN to use General addressing mode
;
;--

	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;

;
; MACROS:
;

	$MAC_MLFDEF			; Define MLF offsets
	$MAC_CTLFLGDEF			;DEFINE VAX MACRO CONTROL FLAGS
	$MAC_SYMBLKDEF			;DEFINE MAX LENGTH OF SYMBOL NAME
	$MAC_CRFLAGDEF			;DEFINE CREF FLAG BITS
	$CLIDEF				;CLI DEFINITIONS
	$DSCDEF				;DESCRIPTOR DEFINITIONS
	$FABDEF				;DEFINE FAB OFFSETS
	$NAMDEF				;DEFINE NAM BLOCK OFFSETS

;
; EQUATED SYMBOLS:
;

	_VIELD	MAC,1,<-
		LIST,-			;LIST FILE PRESENT FLAG
		OBJECT,-		;OBJECT FILE PRESENT FLAG
		INPFIL,-		;INPUT FILE IS PRESENT
		CROSSREF,-		;CROSS REFERENCE REQUESTED
		<LIBRARY,,M>, -		;Input file is a library
		<UPDATE,,M>, -		;Input file has updates
		>

;
; OWN STORAGE:
;
	.PSECT	MAC$RW_DATA,NOEXE,RD,WRT

UPDATE_LIST:	.BLKL	1			; Update list address.
LOC_LST_FLAG:	.LONG	0			; Positional Flags to 
LOC_OBJ_FLAG:	.LONG	0			;   used to save the 
						;   positional /NOLIST, 
						;   /LIST, /NOOBJ, or /OBJ
						;  status.

	.PSECT	MAC$RO_DATA,NOEXE,NOWRT,GBL,LONG

RESULT:		.LONG				;ADDRESS OF RESULT DESC
						;
INP_DEFEXT:	.ASCIC	/.MAR/			;DEFAULT FILE SPEC FOR INPUT
						;
;
; CLI PARSING INFORMATION
;
COMMAND_LINE:	.ASCID	/$LINE/
CROSS:		.ASCID	/CROSS_REFERENCE/
DEBUG:		.ASCID	/DEBUG/
DISABLE:	.ASCID	/DISABLE/
ENABLE:		.ASCID	/ENABLE/
FILE:		.ASCID	/FILE/
LIBRARY:	.ASCID	/LIBRARY/
LISTING:	.ASCID	/LISTING/
NOSHOW:		.ASCID	/NOSHOW/
OBJECT:		.ASCID	/OBJECT/
SHOW:		.ASCID	/SHOW/
UPDATE:		.ASCID	/UPDATE/


	.SBTTL	PARSE COMMAND LINE
;++
; Functional Description:
;
;	This routine obtains the command line and the associated input,
;	object, and listing file(s) information supplied by call backs
;	to the CLI.
;
; Implicit Inputs:
;
;	Global Data (et.al.)
;
; Implicit Outputs:
;
;	The input file(s) are validated and set up in the input queue
;	MAC$GL_INPQUE, the library file(s) have been initialized, all
;	of the qualifier(s) have been parsed, the update file(s) have
;	been set up, and the output and listing file(s) have been created
;	(if they were requested).
;--
	.PSECT	MAC$RO_CODE_P35,NOWRT,GBL,LONG

MAC$GETCMD::
	PUSHR	#^M<R7,R8,R9,R10,R11>	; SAVE REGISTERS
	PUSHAB	L^MAC$GQ_RNT_CMD	; STACK TIMING BLOCK ADDRESS
	CALLS	#1,G^MAC$TIMER_ON	; BEGIN TIMING COMMAND PROCESSING
;
; Create a dynamic string descriptor for parsing the command line.
;
	MOVAB	-8(SP), SP		; Create a dynamic string descriptor
	CLRQ	(SP)			; which will be used for parsing the
	MOVB	#DSC$K_CLASS_D,-	; command line.  It will be passed to
		DSC$B_CLASS (SP)	; the various processing routines.
	BBSC	#FLG$V_MOREINP,(R11),10$; BR IF THIS IS NOT THE FIRST CALL

;
; Obtain a local copy of the command line.
;
	PUSHL	SP			; Address of dynamic string descriptor.
	PUSHAB	COMMAND_LINE		; '$LINE' CLI keyword to get command line.
	CALLS	#2, G^CLI$GET_VALUE	; Get the command line locally.
	MOVZWL	(SP), G^MAC$GL_CMDLEN	; Save the length of the command line
	MOVL	DSC$A_POINTER (SP),-	; and its address for later printing
		G^MAC$GL_CMDLIN		; on the LISTING and/or the TERMINAL.
	CLRL	DSC$A_POINTER (SP)	; Reset address for next segment.
	CLRW	DSC$W_LENGTH (SP)	; Reset length for next segment.

;
; Process the INPUT file(s) specification(s)	(plus:	/CROSS_REFERENCE      )
;						(	/DEBUG    /DISABLE    )
10$:	PUSHL	SP			;	(	/ENABLE   /LIBRARY    )
	CALLS	#1, GET_INPUT		;	(	/LISTING  /OBJECT     )
					;	(	/SHOW     /NOSHOW     )
					;	(	/UPDATE               )
;
; TERMINATE PARSE
;
	MOVAB	G^MAC$GL_INPQUE,R0	; POINT TO THE INPUT QUEUE
	CMPL	4(R0),R0		; WERE THERE ANY INPUT FILES?
	BNEQ	OPEN_OUTPUTS		; IF NEQ YES--GO AHEAD
	MOVAB	G^MAC$MSG_NO_FILE,R0	; NO--GET MESSAGE ADDRESS
	CALLS	#0,G^MAC$ERR_TEXT	; REPORT THE ERROR
	BRW	MAC$LAST_CHANCE		; AND GO DIE

;
; OPEN OBJECT AND LISTING FILES IF REQUESTED
;
OPEN_OUTPUTS:
	MOVAB	G^MAC$GL_CTLMSK,R10	; POINT TO CONTROL MASK
	BBC	#MAC_V_OBJECT,(R10),20$	; BRANCH IF NO OBJECT FILE

	$CREATE	FAB=G^MAC$OBJECT_FAB,-	; CREATE THE OBJECT FILE
		ERR=G^MAC$ERR_OPN_OUT
	BLBC	R0,40$			; BRANCH IF OPEN ERROR
	$CONNECT RAB=G^MAC$OBJECT_RAB,-	; CONNECT THE RECORD STREAM
		ERR=G^MAC$ERR_OPN_OUT
	BLBC	R0,40$			; BRANCH IF CONNECT ERROR
	BBCS	#FLG$V_OBJXST,-		; FLAG OBJECT FILE OPEN
		G^MAC$GL_FLAGS,	20$

20$:	BBC	#MAC_V_LIST,(R10),30$	; BRANCH IF NO LISTING FILE
	$CREATE	FAB=G^MAC$LIST_FAB,-	; CREATE THE LISTING FILE
		ERR=G^MAC$ERR_OPN_OUT
	BLBC	R0,40$			; BRANCH IF OPEN ERROR
	$CONNECT RAB=G^MAC$LIST_RAB,-	; CONNECT THE RECORD STREAM
		ERR=G^MAC$ERR_OPN_OUT
	BLBC	R0,40$			; BRANCH IF CONNECT ERROR
	BBCS	#FLG$V_LSTXST,-		; FLAG THERE IS A LISTING FILE
		G^MAC$GL_FLAGS, 30$

30$:	BBC	#MAC_V_CROSSREF,(R10),35$ ; BRANCH IF NOT CROSS-REFERENCE
	BBSS	#FLG$V_CRF,(R11),35$	; YES--SET IN FLAGS WORD

35$:	PUSHAB	L^MAC$GQ_RNT_CMD	; STACK TIMING BLOCK ADDRESS
	CALLS	#1,G^MAC$TIMER_OFF	; STOP TIMING COMMAND PROCESSING

	ADDL	#8, SP			; Clean up the stack.
	POPR	#^M<R7,R8,R9,R10,R11>	; RESTORE REGISTERS
	RSB
;
; COULD NOT OPEN A FILE
;
40$:	BRW	MAC$LAST_CHANCE		; LAST CHANCE HANDLER


	.SBTTL	GET_OBJECT Obtain object file specification
;++
;
; Functional Description:
;
;	Call the CLI to obtain the GLOBAL object file specification.
;
; Inputs:
;
;	4(AP)	adr	address of a dynamic string descriptor
;			(ultimately either a null string or the globally
;			 specified value)
;
; Implicit Inputs:
;
;	LOC_OBJ_FLAG	specifies if /obj is locally present.
;
; Implicit Outputs:
;
;	If an object file specification was supplied, the address and length
;	of the output file specification is set into the output file FAB.
;
; Side Effects:
;
;	1)  The address field of the dynamic descriptor is cleared 
;	    (to force a new buffer to be allocated on the next invocation 
;	    of the CLI).  This preserves the buffer address and its contents 
;	    (the OBJECT file specification).
;	2)  /LIST locally specified overrides global list specification.
;
;--
	.ENTRY	GET_OBJECT,^M<>		; Get the object file specification.
	PUSHAB	OBJECT			; 
	CALLS	#1, G^CLI$PRESENT	; Was /OBJECT specified?
	BLBC	R0, 20$			; No, Return.
	CMPL	R0, #CLI$_LOCPRES	; If locally present then fall thru
	BEQL	20$			;   and handle in procedure GET_LOC_OBJ.

	CMPL	LOC_OBJ_FLAG, -		; /NOOBJ positionally overrides
		#CLI$_LOCNEG		;   global /OBJ 
	BEQL	20$			; ... Return
	INSV	R0,#MAC_V_OBJECT,-	; (Toggle /OBJECT flag.)
		#1,G^MAC$GL_CTLMSK	;
	INSV	#1,#FAB$V_OFP,-		
		#1,MAC$OBJECT_FAB+FAB$L_FOP
					; Set OFP bit - Use only portions
					;	of related filename.
	PUSHL	4(AP)			; Push the descriptor address.
	PUSHAB	OBJECT			; Push 'OBJECT' qualifier descriptor.
	CALLS	#2, G^CLI$GET_VALUE	; Get the file specification.
	BLBC	R0, 20$			; ...exit... use first input file
	PUSHL	4(AP)			; Push the string desc address.
	CALLS	#1, OBJ_FILE		; Set up the OBJECT file FAB.
20$:	MOVL	4(AP), R0		; Get the address of the descriptor
	CLRL	DSC$A_POINTER (R0)	; and reset it to force a new buffer.
	CLRW	DSC$W_LENGTH (R0)	; Also reset length for next segment.
	RET				; Return to continue the parse.

	.SBTTL	GET_LISTING Obtain the listing file spec (et. al.)
;++
;
; Functional Description:
;
;	Call the CLI to obtain the global list file specification
;	and all the associated listing control qualifiers.
;
; Inputs:
;
;	4(AP)	adr	address of a dynamic string descriptor
;
; Implicit Inputs:
;
;	LOC_LST_FLAG	specifies if /list is locally present.
;
; Implicit Outputs:
;
;	If /LISTING was supplied, the /CROSS_REFERENCE and /SHOW options
;	are selected either explicitly or by default action.
;
; Side Effects:
;
;	1) The address field of the dynamic descriptor is cleared.  This 
;	   preserves the buffer address and its contents (the LISTING file 
;	   specification).
;	2) If a LISTING is specified both locally and globally then thE
;	   local listing is produced.
;--
	.ENTRY	GET_LISTING, ^M<>	; Get the listing file specification.
	PUSHAB	LISTING			
	CALLS	#1, G^CLI$PRESENT	; See if /LISTING was specified.
	BLBC	R0,20$			; Then ...Return.
	CMPL	R0, #CLI$_LOCPRES	; If locally present then fall thru
	BEQL	10$			;   and handle GLOBAL list qualifiers

	CMPL	LOC_LST_FLAG, -		; /NOLIST positionally overrides
		#CLI$_LOCNEG		;   global /LIST 
	BEQL	20$			; ... Return
	INSV	R0,#MAC_V_LIST,-	; (Toggle /LISTING flag.)
		#1,G^MAC$GL_CTLMSK	;
	INSV	#1,#FAB$V_OFP,-		
		#1,MAC$OBJECT_FAB+FAB$L_FOP
					; Set OFP bit - Use only portions
					;	of related filename.
	PUSHL	4(AP)			; Push the descriptor address.
	PUSHAB	LISTING			; Push 'LISTING' qualifier descriptor.
	CALLS	#2, G^CLI$GET_VALUE	; Get the file specification 
					;	or null string.
	BLBC	R0, 5$			; ...exit... use first input file

	PUSHL	4(AP)			; Push the default file specification
					;	as the string desc address.
	CALLS	#1, LIST_FILE		; Set up the LISTING file FAB.
					;
5$:	MOVL	4(AP), R0		; Get the address of the descriptor
	CLRL	DSC$A_POINTER (R0)	; and reset it to force a new buffer.
	CLRW	DSC$W_LENGTH (R0)	; Also reset length for next segment.
	PUSHL	4(AP)			; 
	CALLS	#1, LIST_QUALS		; get the rest of the qualifiers.

10$:	MOVL	4(AP), R0		; Get the address of the descriptor
	CLRL	DSC$A_POINTER (R0)	; and reset it to force a new buffer.
	CLRW	DSC$W_LENGTH (R0)	; Also reset length for next segment.
20$:	RET


	.SBTTL	GET_LOC_OBJECT Obtain the positional object file spec (et. al.)
;++
;
; Functional Description:
;
;	This routine obtains the positional object file specification and 
;	and sets up the OFP bit in FAB FOP for object file related name.
;
; Inputs:
;
;	4(AP)	adr	address of a dynamic string descriptor (if object
;			  file specified locally)
;
; Implicit Outputs:
;
;	LOC_OBJ_FLAG 	Flag to hold status of CLI$PRESENT when qualifier
;			  is locally present 
;
; Side Effects:
;
;	1)  The address field of the dynamic descriptor is cleared.  This 
;	    preserves the buffer address and its contents (the LISTING file 
;	    specification).  
;	2)  If a OBJECT file is marked locally as /NOOBJECT then the object
;	    flag is reset here.
;--
	.ENTRY	GET_LOC_OBJECT, ^M<R2,R4,R6>
	PUSHAB	OBJECT			; 
	CALLS	#1, G^CLI$PRESENT	; See if /OBJECT was specified.
	CMPL	R0, #CLI$_LOCPRES	; locally present
	BEQL	5$
	CMPL	R0, #CLI$_LOCNEG	; locally negated
					;
	BNEQ	20$			; ...exit...
					;
	MOVL	LOC_OBJ_FLAG, R0	; Check for prev file's
	CMPL	R0, #CLI$_LOCPRES	; 	positional /OBJ qual and
					;	avoid clearing global flag
	BEQL	20$			; ...exit...
					;
	MOVL	R0, LOC_OBJ_FLAG	; Save locally negative flag for later
	INSV	#0,#MAC_V_OBJECT,-	; Clear object flag bit
		#1,G^MAC$GL_CTLMSK	;
	BRB	20$			; ...exit...
					;
5$:	MOVL	R0, LOC_OBJ_FLAG	; Indicate that local object specified
	INSV	R0,#MAC_V_OBJECT,-	; (Toggle /OBJECT flag to "ON".)
		#1,G^MAC$GL_CTLMSK	;
	INSV	#1,#FAB$V_OFP,-		
		#1,MAC$OBJECT_FAB+FAB$L_FOP
					; Set OFP bit - Use related filename.
					;
	PUSHL	4(AP)			; 
	PUSHAB	OBJECT			; 
	CALLS	#2, G^CLI$GET_VALUE	; Get the file specification or null 
					;	string.
	BLBS	R0, 15$			; Dont clear the OFP 
	INSV	#0,#FAB$V_OFP,-		
		#1,MAC$OBJECT_FAB+FAB$L_FOP
					; Set OFP bit - Use related filename.
15$:	PUSHL	4(AP)			; 
	CALLS	#1, OBJ_FILE		; Set up the OBJ file FAB specified.
	BRB	20$			; ...exit...
					;
					;
20$:	MOVL	4(AP), R0		; Get the address of the descriptor
	CLRL	DSC$A_POINTER (R0)	; and reset it to force a new buffer.
	CLRW	DSC$W_LENGTH (R0)	; Also reset length for next segment.
	RET
;

	.SBTTL	GET_LOC_LIST Obtain the positional listing file spec (et. al.)
;++
;
; Functional Description:
;
;	This routine obtains the positional listing file specification and 
;	sets up the related name for the listing file, and gets any qualifiers
;	specified with the local listing.
;
; Inputs:
;
;	4(AP)	adr	address of a dynamic string descriptor (used if
;			  specific list file is specified locally)
;
; Implicit Outputs:
;
;	LOC_LST_FLAG 	Flag to hold status of CLI$PRESENT when qualifier
;			  is locally present 
;
;	If /LISTING was supplied, the /CROSS_REFERENCE and /SHOW options
;	are selected either explicitly or by default action.
;
; Side Effects:
;
;	1)  The address field of the dynamic descriptor is cleared.  This 
;	    preserves the buffer address and its contents (the LISTING 
;	    file specification).  
;	2)  If a LISTING file is marked locally as /NOLIST then the listing
;	    flag is reset here.
;--
	.ENTRY	GET_LOC_LIST,	^M<R2,R4,R6>
	PUSHAB	LISTING			; 
	CALLS	#1, G^CLI$PRESENT	; See if /LISTING was specified.
	CMPL	R0, #CLI$_LOCPRES	; locally present
	BEQL	5$
	CMPL	R0, #CLI$_LOCNEG	; locally negated
	BNEQ	20$			; ...exit...
					;
3$:	MOVL	LOC_LST_FLAG, R0	; Check for prev file's
	CMPL	R0, #CLI$_LOCPRES	; 	positional /LIST qual and
					;	avoid clearing global flag
	BEQL	20$			; ...exit...
					;
4$:	MOVL	R0, LOC_LST_FLAG	; Save locally negative flag for later
	INSV	#0,#MAC_V_LIST,-	; Clear LIST flag bit
		#1,G^MAC$GL_CTLMSK	;
	BRB	20$			; ...exit...
					;
5$:	MOVL	R0, LOC_LST_FLAG	; Indicate that local list specified
	INSV	#1,#FAB$V_OFP,-		
		#1,MAC$LIST_FAB+FAB$L_FOP
					; Set OFP bit - Use related filename.
	INSV	R0,#MAC_V_LIST,-	; (Toggle /LIST flag to "ON".)
		#1,G^MAC$GL_CTLMSK	;
					;
	PUSHL	4(AP)			; 
	PUSHAB	LISTING			; 
	CALLS	#2, G^CLI$GET_VALUE	; Get the file specification or null 
					;	string.
	BLBS	R0, 15$			; Dont clear the OFP 
	INSV	#0,#FAB$V_OFP,-		
		#1,MAC$LIST_FAB+FAB$L_FOP
					; Set OFP bit - Use related filename.
15$:	PUSHL	4(AP)			; Push the string descriptor address.
	CALLS	#1, LIST_FILE		; Set up the LIST file FAB specified.
	BRB	17$			; list_quals ...exit...
					;
17$:	MOVL	4(AP), R0		; Get the address of the descriptor
	CLRL	DSC$A_POINTER (R0)	; and reset it to force a new buffer.
	CLRW	DSC$W_LENGTH (R0)	; Also reset length for next segment.
	PUSHL	4(AP)			; 
	CALLS	#1, LIST_QUALS		; get the rest of the qualifiers.
					;
20$:	MOVL	4(AP), R0		; Get the address of the descriptor
	CLRL	DSC$A_POINTER (R0)	; and reset it to force a new buffer.
	CLRW	DSC$W_LENGTH (R0)	; Also reset length for next segment.
	RET
;

	.SBTTL	LIST_QUALS Obtain the listing file associated qualifiers(et. al.)
;++
;
; Functional Description:
;
;	This routine processes all the associated listing control qualifiers.
;
; Inputs:
;
;	4(AP)	adr	address of a dynamic string descriptor
;
; Implicit Outputs:
;
;	If /LISTING was supplied, the /CROSS_REFERENCE and /SHOW options
;	are selected either explicitly or by default action.
;
; Side Effects:	
;
;	None
;
;--
	.ENTRY	LIST_QUALS, ^M<>		; Get the listing file specification.
	PUSHAB	CROSS			; Push the CROSS_REFERENCE desc.
	CALLS	#1, G^CLI$PRESENT	; Was /CROSS_REFERENCE specified?
	BLBC	R0, 15$			; No, skip ahead.
	INSV	R0,#MAC_V_CROSSREF,-	; Toggle /CROSS_REFERENCE flag.
		#1,G^MAC$GL_CTLMSK	;
	PUSHL	4(AP)			; Yes, push the address of string descriptor
	CALLS	#1, MACR_CROS		; and process the keywords seperately.

15$:	PUSHAB	SHOW			; Push the SHOW qulaifier descriptor.
	CALLS	#1, G^CLI$PRESENT	; Was /SHOW specified?
	BLBC	R0, 20$			; No, go process the /NOSHOW qualifier.
	PUSHL	4(AP)			; Address of string descriptor to use...
	CALLS	#1, MACR_SHOW		; Yes, so process the keywords seprately

20$:	PUSHAB	NOSHOW			; Push the NOSHOW qulaifier descriptor.
	CALLS	#1, G^CLI$PRESENT	; Was /NOSHOW specified?
	BLBC	R0, 30$			; No, return to complete parse.
	PUSHL	4(AP)			; Address of string descriptor to use...
	CALLS	#1, MACR_NOSH		; Yes, parse /NOSHOW's keywords...

30$:	RET				;

	.SBTTL	GET_INPUT Obtain the input file specification(s)
;++
;
; Functional Description:
;
;	The input file specification is obtained and all associated qualifiers
;	are processed.
;
; Inputs:
;
;	4(AP)	adr	address of a dynamic string descriptor
;
; Implicit Inputs:
;	The default qualifiers defined in the .CLD are inputs to this routine.
;
; Implicit Outputs:
;
;	The input file specification is parsed and processed, and the qualifiers
;	(/DEBUG, /DISABLE, /ENABLE) options have been set.
;
; Side Effects:
;
;	Allocation of STACK LOCAL Storage is used as follows:
;
;		+-------------------+
;		|class|type| length | 0(SP)
;		+-------------------+
;		|   string address  | 4(SP)
;		+-------------------+
;		|    saved status   | 8(SP)
;		+-------------------+
;
;--
	.ENTRY	GET_INPUT, ^M<>		; Get the input file specification
;
; Initialization...
;
	MOVAB	-12(SP), SP		; Allocate some LOCAL storage.
	CLRQ	(SP)			; Initialize a dynamic string
	MOVB	#DSC$K_CLASS_D,-	; descriptor.  The remaining longword
		DSC$B_CLASS (SP)	; is used to hold a 'saved status'.
	CLRL	R0
	MOVL	R0, LOC_LST_FLAG	; Initialize positional flags
	MOVL	R0, LOC_OBJ_FLAG	; 	for every concat file list.
10$:	CLRL	G^MAC$GL_DIRFLG		; Reset the LIBRARY flag and
	CLRL	UPDATE_LIST		; the UPDATE flag (MUTEX)
	BICL2	#<MAC_M_LIBRARY!MAC_M_UPDATE>, -
		G^MAC$GL_CTLMSK		; /LIBRARY and /UPDATE are mutually
					; exclusive on a SINGLE file spec!
					; 	...(Reset qualifier bits)
	PUSHL	SP			; Push address of descriptor
	PUSHAB	FILE			; Push the 'FILE' parameter descriptor.
	CALLS	#2, G^CLI$GET_VALUE	; Get the input file specification.
	INSV	R0,#MAC_V_INPFIL,-	; Toggle INPUT file parsed flag.
		#1,G^MAC$GL_CTLMSK	;
	MOVL	R0, 8(SP)		; Save status...
					;	check later for more files.
	BLBS	R0, 20$			; Any more input files?
	BRW	90$			; No, return and finish processing.
;
; Input file qualifier processing...
;
20$:	PUSHAB	ENABLE			; Push the ENABLE qualifier descriptor.
	CALLS	#1, G^CLI$PRESENT	; Was /ENABLE specified?
	BLBC	R0, 30$			; No, check the next qualifier.
	PUSHL	4(AP)			; Use common dynamic string descriptor.
	CALLS	#1, MACR_ENAB		; Yes, process the ENABLE keywords.

30$:	PUSHAB	DISABLE			; Push the DISABLE qualifier descriptor.
	CALLS	#1, G^CLI$PRESENT	; Was /DISABLE specified?
	BLBC	R0, 40$			; No, check the next qualifier.
	PUSHL	4(AP)			; Use common dynamic string descriptor.
	CALLS	#1, MACR_DISA		; Yes, process the DISABLE keywords.

40$:	PUSHAB	DEBUG			; Push the DEBUG qualifier descriptor.
	CALLS	#1, G^CLI$PRESENT	; Was /DEBUG specified?
	BLBC	R0, 50$			; No, see if negations are performed.
	PUSHL	4(AP)			; Yes, use common dynamic string desc.
	CALLS	#1, MACR_DEBU		; and process the DEBUG keywords.
	BRB	60$			; Done, go process the next qualifier.
50$:	CMPL	R0, #CLI$_NEGATED	; Was /NODEBUG explicitly specified? 
	BNEQ	60$			; No, skip over negation activities.
	PUSHL	4(AP)			; Yes, use common dynamic string desc.
	CALLS	#1, MACR_NODE		; and process negations.

60$:	PUSHAB	UPDATE			; Push the UPDATE qualifier descriptor.
	CALLS	#1, G^CLI$PRESENT	; Was /UPDATE specified?
	INSV	R0,#MAC_V_UPDATE,-	; Toggle /UPDATE flag.
		#1,G^MAC$GL_CTLMSK	;
	BLBC	R0, 65$			; No, process /LIBR, /OBJ and /LIST.
	PUSHL	4(AP)			; Use common dynamic string descriptor.
	CALLS	#1, MACR_UPDA		; Yes, set up UPDATE file list.
;
;  Process global library, listing & object qualifiers...
;
65$:	PUSHAB	LIBRARY			; Push the LIBRARY qualifier descriptor.
	CALLS	#1, G^CLI$PRESENT	; Is this file a LIBRARY?
	INSV	R0,#MAC_V_LIBRARY,-	; Toggle /LIBRARY flag.
		#1,G^MAC$GL_CTLMSK	;
	INSV	R0,#0,#1,G^MAC$GL_DIRFLG; Set TRUE or FALSE in the FLAGS.
					;
	CMPL	R0, #CLI$_LOCPRES	; /LIBRARY positionally specified
	BEQL	75$			; then skip global file processing
					;
	BLBS	LOC_OBJ_FLAG, 70$	; Skip if prev local obj spec
	PUSHL	4(AP)			; Process the OBJECT file specification
	CALLS	#1, GET_OBJECT		; (/OBJECT).
70$:	BLBS	LOC_LST_FLAG, 75$	; Skip if prev local list spec
	PUSHL	4(AP)			; Process the LISTING file specification
	CALLS	#1, GET_LISTING		; (/LISTING, /CROSS_REFERENCE and /SHOW)

75$:	PUSHL	SP			; Now, process the input file...
	CALLS	#1, INP_FILE		; (source or library file).
;
;  Process positional listing/object qualifiers
;
	PUSHL	4(AP)			; Process the OBJECT file specification
	CALLS	#1, GET_LOC_OBJECT	; (/OBJECT).
	PUSHL	4(AP)			; Process any new LISTING file 
					;	specification
	CALLS	#1, GET_LOC_LIST	; Local /LISTING, /CROSS_REFERENCE 
					;	and /SHOW.
;
;  Process cleanup...
;
	MOVL	SP, R0			; Get the address of the descriptor
	CLRL	DSC$A_POINTER (R0)	; and reset it to force a new buffer.
	CLRW	DSC$W_LENGTH (R0)	; Also reset length for next segment.

	CMPL	#CLI$_CONCAT, 8(SP)	; Is this a concatinated input file?
	BNEQ	80$			; No, but there may be more input files
	BRW	10$			; Yes, continue processing the 
					; 	next file.
80$:	CMPL	#CLI$_COMMA, 8(SP)	; Check to see if there really are any
	BNEQ	90$			; more input file(s).
	BBSS	#FLG$V_MOREINP,(R11),90$; Indicate more input file(s) expected.
90$:	RET				; Return, to complete current command.


	.SBTTL	ACTION ROUTINE FOR INPUT FILE SPECIFICATION

;++
; FUNCTIONAL DESCRIPTION
;
;	THIS ROUTINE CREATES A FAB AND LINKS IT INTO THE LIST OF
;	INPUT FABS.  IT THEN OPENS THE FILE TO MAKE SURE IT EXISTS
;	BEFORE EXITING.
;
;--
	.ENTRY	INP_FILE, ^M<R2, R3, R4, R5, R6, R7>
					;HANDLE INPUT FILE SPECIFICATION
	BLBC	L^MAC$GL_DIRFLG,10$	;BRANCH IF NOT LIBRARY FILE
	BRW	INP_LIBR_FILE		;ELSE GO HANDLE LIBRARY SPECIALLY
	;
	; CREATE INPUT FILE DESCR. BLOCK
	;
10$:	CALLG	L^MAC$G_1_PAGE,G^LIB$GET_VM
					;ALLOCATE AN FDB
	BLBS	R0,20$			;BR IF SUCCESS
	BRW	100$			;NO--GO REPORT ERROR
20$:	MOVL	G^MAC$GL_BASEADDR,R6	;GET BLOCK ADDRESS
	MOVC5	#0,(SP),#0,#512,(R6)	;CLEAR THE BLOCK
	ADDL2	#8,R6			;POINT TO FDB (SKIP THE LINKS)
	MOVW	#<<FAB$C_BLN>@8+FAB$C_BID>,-
			FAB$B_BID(R6)	;IDENTIFY AS A FAB WITH IDENT AND LENGTH
	BISB2	#FAB$M_GET,FAB$B_FAC(R6);SET FOR GETS
	MOVB	L^INP_DEFEXT,FAB$B_DNS(R6)
					;SET LENGTH OF DEFAULT NAME STRING
	MOVAB	L^INP_DEFEXT+1,FAB$L_DNA(R6)
					;AND ITS ADDRESS
	MOVAB	L^MAC$INPUT_XAB,-	;STORE ADDRESS OF XAB FOR DATE
			FAB$L_XAB(R6)
	;
	; NAM BLOCK FOR SUM$xxxx ROUTINES USED THROUGHOUT MACRO
	;
	MOVAB	FAB$C_BLN(R6),R1	;POINT TO NAM BLOCK
	MOVL	R1,FAB$L_NAM(R6)	;STORE NAM ADDRESS IN FAB
	MOVB	#NAM$C_MAXRSS,NAM$B_RSS(R1)
					;STORE IN NAM BLOCK
	MOVAB	L^MAC$INP_NAM_BUF,NAM$L_RSA(R1)
					;AND ITS ADDRESS
	MOVW	#<<NAM$C_BLN>@8+NAM$C_BID>,-
			FAB$C_BLN+NAM$B_BID(R6)
					;IDENTIFY NAM BLOCK AS A NAM BLOCK
	MOVAB	L^MAC$INPUT_RLFNM,NAM$L_RLF(R1)
					;SET RELATED NAM BLOCK ADDRESS
	MOVAB	L^MAC$INP_NAM_BUF,NAM$L_ESA(R1)
					;SET EXPANDED STRING BUFFER ADDRESS
	MOVB	#NAM$C_MAXRSS,NAM$B_ESS(R1)
					;  AND ITS SIZE
	;
	; USE LIB$FIND_FILE TO GET THE INPUT FILE NAME
	;
	CLRQ	-(SP)			; Initialize a dynamic string
	MOVB	#DSC$K_CLASS_D,-	; descriptor.
		DSC$B_CLASS (SP)	;
	MOVB	#DSC$K_DTYPE_T,-	;SETUP THE TYPE
		DSC$B_DTYPE (SP)
	MOVL	SP, R7			; RESULT WILL CONTAIN THE RESULT DESC
					;
	PUSHAL	L^MAC$GC_FFLAGS		;USER FLAGS
	PUSHAL	L^MAC$GL_STV_ADDR	;STV_ADDR
	PUSHL	#0			;RELATED NAME(zero - not used)
	PUSHAB	L^MAC$INP_DEFNAM	;DEFAULT NAME (filename extension)
	PUSHAL	L^MAC$GL_CONTEXT	;CONTEXT (of previous call)
	PUSHL	R7			;RESULT DESC ADDRESS
	PUSHL	4(AP)			;FILENAME DESC ADDRESS
	CALLS	#7, G^LIB$FIND_FILE	;SEARCH FOR FILENAME
					;
	BLBS	R0,30$
	BRW	120$			;ERROR - REPORT UNABLE TO FIND
	;
	;  PERFORM THE REQUIRED BOOKKEEPING
	;
30$:	MOVL	DSC$A_POINTER(R7),-	;STORE ADDRESS OF FILENAME STRING
			FAB$L_FNA(R6)	; IN THE FAB
	MOVB	DSC$W_LENGTH(R7),-	;STORE LENGTH OF FILENAME STRING
			FAB$B_FNS(R6)	; IN THE FAB

	$PARSE	FAB=(R6),-		;OPEN THE INPUT FILE TO ENSURE EXISTENCE
		ERR=W^MAC$ERR_OPN_INP
	BLBS	R0,35$
	BRW	115$			;BR IF THERE WAS AN ERROR

35$:	MOVAB	FAB$C_BLN(R6),R1	;POINT TO NAM BLOCK
	;
	; SET LENGTHS FOR SUM$xxx ROUTINES
	;
	
	MOVB	DSC$W_LENGTH(R7),-
		L^MAC$INPUT_RLFNM+NAM$B_ESL
					;COPY LENGTH INTO EXPANDED STRING
	MOVB	DSC$W_LENGTH(R7),-
		L^MAC$INPUT_RLFNM+NAM$B_RSL
					;COPY LENGTH AND
					; CONTENTS
	MOVB	DSC$W_LENGTH(R7),-
		NAM$B_RSL(R1)

	MOVC3	DSC$W_LENGTH(R7), @DSC$A_POINTER(R7), -
		L^MAC$INP_NAM_BUF
	

	INSQUE	-8(R6),@L^MAC$GL_INPQUE+4
					;INSERT THE FDB INTO THE INPUT QUE
	;
	;  SAVE RESULT STRING FOR LISTING AND OBJECT FILES
	;  WHICH ARE SPECIFIED POSITIONALLY
	;
	MOVAL	L^MAC$GL_RESULT, R2	;SAVE THE RESULT NAME STRING
	MOVW	DSC$W_LENGTH(R7),-
		 DSC$W_LENGTH(R2)	;COPY LENGTH OF EXPANDED STRING
					; FOR OBJECT AND LISTING FILES
	MOVC3	DSC$W_LENGTH(R7), @DSC$A_POINTER(R7), -
		L^MAC$GL_RESADDR	;COPY EXPANDED NAME STRING
	;
	;
					;FOR OBJECT AND LISTING FILES
	BLBS	G^MAC$GL_FINPTF, 40$	;BRANCH IF NOT FIRST INPUT FILE
	INCL	G^MAC$GL_FINPTF		;FLAG FIRST INPUT FILE DONE

	;
	;  SAVE THE NAME FOR DEFAULT OBJECT FILENAME DETERMINATION
	;
	MOVB	DSC$W_LENGTH(R7),-
		L^MAC$OBJPT_RLFNM+NAM$B_RSL
					;COPY LENGTH OF EXPANDED STRING
	MOVC3	DSC$W_LENGTH(R7), @DSC$A_POINTER(R7), -
		L^MAC$OBJ_NAM_BUF	;COPY EXPANDED NAME STRING
					;FOR OBJECT AND LISTING FILES
	MOVB	DSC$W_LENGTH(R7),-
		 L^MAC$LISPT_RLFNM+NAM$B_RSL
					;COPY LENGTH OF EXPANDED STRING
	MOVC3	DSC$W_LENGTH(R7), @DSC$A_POINTER(R7), -
		L^MAC$LIS_NAM_BUF	;COPY EXPANDED NAME STRING
					;
40$:	BISL2	#FAB$M_NAM, FAB$L_FOP(R6)
					;SET TO OPEN BY NAM BLOCK
	MOVL	L^UPDATE_LIST, -	;Store update files list
		FAB$C_BLN+NAM$C_BLN(R6)
	BEQL	60$			;If EQL there is no list
	PUSHAL	FAB$C_BLN+NAM$C_BLN(R6)	;Update list
	PUSHAL	FAB$C_BLN(R6)		;NAM block address
	CALLS	#2,G^SUM$OPEN		;Open update files
	BLBC	R0,115$			;Error if LBC
60$:	RET
	;
	; COULD NOT ALLOCATE AN FDB
	;
100$:	CALLS	#0,G^MAC$ERR_NOMEM_0	;REPORT ERROR
115$:	BRW	MAC$LAST_CHANCE		;GO TO LAST CHANCE HANDLER
	;
	; COULD NOT OPEN INPUT FILE
	;
120$:	PUSHL	R0			;SAVE RMS STS
	PUSHAL	L^MAC$GL_STV_ADDR	;SAVE THE STATUS VALUE ADDRESS
	PUSHL	R7			;SAVE THE RESULT ADDRESS AND
	CALLS	#3,G^MAC$ERR_FIND_INP	;REPORT ERROR
	BRW	MAC$LAST_CHANCE		;GO TO LAST CHANCE HANDLER


	.SBTTL	PROCESS LIBRARY FILE SPECIFIER

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED WHEN THE /LIBRARY QUALIFIER IS SEEN
;	IN A FILE SPECIFICATION.  ALL THAT IS DONE IS TO SET THE
;	LOW BIT IN MAC$GL_DIRFLG.  THIS WILL CAUSE THE INP_FILE
;	ROUTINE TO TRANSFER CONTROL TO INP_LIBR_FILE WHEN IT IS
;	EVENTUALLY CALLED.
;--

LIBR_FILE:
	.WORD	0			;REGISTER SAVE MASK
	BISB	#1,L^MAC$GL_DIRFLG	;SET LIBRARY FILE FLAG FOR INP_FILE
	RET

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED WHEN THE INPUT SPECIFICATION IS COMPLETE
;	AND THE SPECIFICATION HAS /LIBRARY ON IT.  THE LIBRARY IS OPENED,
;	AND AN IN-CORE INDEX IS CREATED.  THIS ROUTINE USES LIB$FIND_FILE
;	WITH THE CURRENT GLOBAL CONTEXT.  THIS ALLOWS STICKINESS
;	WITH OTHER FILES ON THE COMMAND LINE.
;
;
;--

INP_LIBR_FILE:
					;NO SAVE MASK SINCE WE BRW HERE
					;FROM INP_FILE
	BSBW	MAC$ALL_MLB_MLF		; Allocate and initialise MLF block
	;
	; USE LIB$FIND_FILE TO GET THE INPUT FILE NAME (Use same context as
	;	as that used in Routine INP_FILE )
	;
	CLRQ	-(SP)			; Initialize a dynamic string
	MOVB	#DSC$K_CLASS_D,-	; descriptor.
		DSC$B_CLASS (SP)	;
	MOVB	#DSC$K_DTYPE_T,-	;SETUP THE TYPE
		DSC$B_DTYPE (SP)
	MOVL	SP, R7			; RESULT WILL CONTAIN THE RESULT DESC
					;
	PUSHAL	L^MAC$GC_FFLAGS		;USER FLAGS
	PUSHAL	L^MAC$GL_STV_ADDR	;STV_ADDR
	PUSHL	#0			;RELATED NAME(zero - not used)
	PUSHAB	L^MAC$MLB_DEFNAM	;DEFAULT NAME (filename extension)
	PUSHAL	L^MAC$GL_CONTEXT	;CONTEXT (of previous call)
	PUSHL	R7			;RESULT DESC ADDRESS
	PUSHL	4(AP)			;FILENAME DESC ADDRESS
	CALLS	#7, G^LIB$FIND_FILE	;SEARCH FOR FILENAME
					;
	BLBS	R0,5$
	BRW	20$			;ERROR - REPORT UNABLE TO FIND
;
; Call librarian procedure to initialise library
;
5$:	PUSHAB	MLF$X_NAMBLK(R6)	; Address of NAM block
	PUSHAB	L^MAC$GL_LIBTYPE	; Address of type = MLB
	PUSHAB	L^MAC$GL_LIBFUNC	; Address of function = READ
	PUSHAB	MLF$L_CTINDEX(R6)	; Address of control table index
	CALLS	#4,G^LBR$INI_CONTROL	; Initialise control block
	BLBC	R0,10$			; If LBC error
;
; Call librarian procedure to open library file
;
	PUSHAB	MLF$Q_FNAMDS(R6)	; Address of resultant length
	PUSHAB	MLF$Q_FNAMDS(R6)	; Address of resultant descriptor
	PUSHAB	L^MAC$INPUT_RLFNM	; Address of related file NAM block
	PUSHAB	L^MAC$MLB_DEFNAM	; Address of default file name descriptor
	PUSHL	#0			; Create options = 0
	PUSHAB	DSC$W_LENGTH(R7)	; Address of file name descriptor
	PUSHAB	MLF$L_CTINDEX(R6)	; Address of control table index
	CALLS	#7,G^LBR$OPEN		; Open library file
	BLBC	R0,10$			; Error if LBC
	MOVAB	MLF$T_FNAM(R6),-	; Set up related name NAM block to
		MAC$INPUT_RLFNM+NAM$L_RSA ; point to current expanded file name
	MOVB	MLF$X_NAMBLK+NAM$B_ESL(R6),- ; Set up related file name block
		L^MAC$INPUT_RLFNM+NAM$B_RSL  ; to point to currect expanded name
	INSQUE	(R6),L^MAC$GL_MLB_QUE	;INSERT AT FRONT OF MLB QUEUE
	INCL	G^MAC$GL_MLB_CNT	; Increment macro library count
					;
	;
	;  SAVE RESULT STRING FOR LISTING AND OBJECT FILES
	;  WHICH ARE SPECIFIED POSITIONALLY
	;
	MOVAL	MLF$Q_FNAMDS(R6), R7	;GET ADDR OF THE RESULT DESCRIPTOR
	MOVAL	L^MAC$GL_RESULT, R2	;SAVE IN THE GLOBAL RESULT NAME STRING
	MOVB	(R7), DSC$W_LENGTH(R2)	;COPY LENGTH OF EXPANDED STRING
					; FOR OBJECT AND LISTING FILES
	MOVC3	DSC$W_LENGTH(R7), @DSC$A_POINTER(R7), -
		L^MAC$GL_RESADDR	;COPY EXPANDED NAME STRING
					; FOR OBJECT AND LISTING FILES
					;
	RET				;RETURN TO CLI
;
; LIBRARY OPEN ERROR
;
10$:
	PUSHL	R6			; Address of MLF
	CALLS	#1,MAC$ERR_LBROPEN	; Report error
	BRW	MAC$LAST_CHANCE

	;
	; COULD NOT OPEN INPUT FILE
	;
20$:	PUSHL	R0			;SAVE RMS STS
	PUSHAL	L^MAC$GL_STV_ADDR	;SAVE THE STATUS VALUE ADDRESS
	PUSHL	R7			;SAVE THE RESULT ADDRESS AND
	CALLS	#3,G^MAC$ERR_FIND_INP	;REPORT ERROR
	BRW	MAC$LAST_CHANCE		;GO TO LAST CHANCE HANDLER

	.SBTTL	ACTION ROUTINE FOR OBJECT AND LISTING FILES

;++
; FUNCTIONAL DESCRIPTION:
;
;	THESE ROUTINES, LIST_FILE AND OBJ_FILE, ARE CALLED BY
;	GET_LISTING, GET_OBJECT, GET_LOC_LIST, GET_LOC_OBJECT
;	WHEN THE QUALFIERS ARE FOUND IN A COMMAND LINE.
;	THE INFORMATION IS FILLED INTO THE PROPER FAB.
;
; Side Effects:
;	THE CURRENT RESULTANT NAME (is stored in a global descriptor) IS
;	INSERTED INTO THE RELATED FILENAME BLOCK.  THIS IS DONE HERE 
;	BECAUSE THIS IS THE "ONLY" PLACE THAT HANDLES LIST FILES AND 
;	OBJECT FILES AFTER THE RESULTANT NAME IS COMPLETE FOR POSITIONAL
;	QUALIFIERS.  ALSO THE IFI FEILD IS CLEARED.
;
;--

LIST_FILE:
	.WORD	0			;REGISTER SAVE MASK
	;
	; INSERT THE RESULTANT FILENAME INTO THE RELATED FILE NAME BLOCK.
	;
	MOVAL	L^MAC$GL_RESULT, R7	;SAVE THE RESULT NAME STRING
	MOVB	DSC$W_LENGTH(R7),-
		 L^MAC$LISPT_RLFNM+NAM$B_RSL
					;COPY LENGTH OF EXPANDED STRING
	MOVC3	DSC$W_LENGTH(R7), @DSC$A_POINTER(R7), -
		L^MAC$LIS_NAM_BUF	;COPY EXPANDED NAME STRING
					;FOR OBJECT AND LISTING FILES
	MOVAB	L^MAC$LIST_FAB,R0	;GET THE FAB ADDRESS
	BRB	OPEN_FILE		;AND GO HANDLE THE REST

OBJ_FILE:
	.WORD	0			;REGISTER SAVE MASK
	;
	; INSERT THE RESULTANT FILENAME INTO THE RELATED FILE NAME BLOCK.
	;
	MOVAL	L^MAC$GL_RESULT, R7	;SAVE THE RESULT NAME STRING
	MOVB	DSC$W_LENGTH(R7),-
		 L^MAC$OBJPT_RLFNM+NAM$B_RSL
					;COPY LENGTH OF EXPANDED STRING
	MOVC3	DSC$W_LENGTH(R7), @DSC$A_POINTER(R7), -
		L^MAC$OBJ_NAM_BUF	;COPY EXPANDED NAME STRING
					;FOR OBJECT AND LISTING FILES
	MOVAB	L^MAC$OBJECT_FAB,R0	;GET THE FAB ADDRESS

OPEN_FILE:
	MOVL	4(AP), R1		;GET THE RESULTING FILENAME
	MOVL	DSC$A_POINTER(R1),-	;STORE ADDRESS OF FILENAME STRING
			FAB$L_FNA(R0)	;	IN THE FAB
	MOVB	DSC$W_LENGTH(R1),-	;STORE LENGTH OF FILENAME STRING
			FAB$B_FNS(R0)	;	IN THE FAB
	MOVW	#0, FAB$W_IFI(R0)	; CLEAR IFI... VALIDATES THE FAB
	RET


	.SBTTL	GET_KEYWORDS Obtain qualifier keywords
;++
;
; Functional Description:
;
;	This routine is called to obtain the next (if any) keyword for the
;	indicated qualifier.
;
; Inputs:
;
;	(SP)	adr	Return address (result of JSB entry)
;	4(SP)	adr	Address of a dynamic string descriptor
;	R7	adr	Address of a dynamic string descriptor for the qualifier
;
; Outputs:
;
;	4(SP)	adr	The descriptor now points to the latest keyword parsed
;
; Routine Value:
;
;	R0	contains the return status from the CLI.
;
;--

GET_KEYWORDS:
	PUSHL	4(SP)			; Push address of descriptor.
	PUSHL	R7			; Push the address of the qualifier descriptor.
	CALLS	#2, G^CLI$GET_VALUE	; Get the next keyword.
	RSB



	.SBTTL	PROCESS CROSS QUALIFIER

;++
; FUNCTIONAL DESCRIPTION:
;
;	THE KEYWORDS ARE SCANNED AND MAC$GL_CRF_FLG IS FILLED IN WITH
;	THE CORRESPONDING BITS.
;
;--

MACR_CROS:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ;REGISTER SAVE MASK
	MOVAB	L^MAC$GL_FLAGS,R11	;POINT R11 TO FLAGS
	PUSHL	4(AP)			; Address of dynamic string descriptor.
	MOVAB	CROSS, R7		; Address of qualifier descriptor.
	JSB	GET_KEYWORDS		; Get the first keyword (if any).
	BLBS	R0, 15$			; Got one, go look it up!
	MOVZWL	#CRF$M_SYMBOLS!CRF$M_MACROS,- ;NO--SET THE DEFAULT
			L^MAC$GL_CRF_FLG      ;OF SYMBOLS AND MACROS
	RET				;AND LEAVE IT AT THAT

;
; LOOP, LOOKING UP KEYWORDS AND SETTING BITS IN MAC$GL_CRF_FLG
;
10$:	JSB	GET_KEYWORDS		; Get the keyword
	BLBC	R0, 40$			; All done?

15$:	MOVL	(SP), R6		; Get the descriptor's address.
	MOVZWL	DSC$W_LENGTH(R6), R0	;GET LENGTH OF ASCII STRING
	BEQL	40$			;IF EQL THEN ALL DONE
	MOVAB	L^MAC$AB_TMPSYM,R1	;THERE IS A STRING--PT TO NAME BLK
	MOVB	R0,(R1)+		;STORE LENGTH OF STRING
	MOVC5	R0,@DSC$A_POINTER(R6),-	;COPY NAME INTO TMPSYM
		#0,#SYM$K_MAXLEN,(R1)	;WITH ZERO FILL
	MOVAB	L^MAC$CRF_OPTIONS,R5	;POINT TO THE LIST OF OPTIONS
	BSBW	MAC$SRC_KEYS		;LOOK UP THE OPTION
	BLBS	R0,20$			;BRANCH IF FOUND
	CALLS	#0,G^MAC$ERR_KEY_WD	;ERROR--REPORT IT
	BRW	MAC$LAST_CHANCE		;AND EXIT
20$:	MOVL	SYM$L_VAL(R1),R0	;GET THE VALUE
	BGTR	30$			;IF GTR THEN OK
	MCOML	R0,R0			;ELSE THIS IS "NOXXXX"
	BICL2	R0,L^MAC$GL_CRF_FLG	;CLEAR THE CREF FLAG
	BRB	10$			;CONTINUE
30$:	BISL2	R0,L^MAC$GL_CRF_FLG	;SET IN CREF FLAGS
	BRB	10$			;GO GET NEXT OPTION
40$:	RET				;RETURN TO CLI


	.SBTTL	PROCESS SHOW/NOSHOW,ENABLE/DISABLE QUALIFIERS

;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO PROCESS THE /SHOW QUALIFIER.
;	THE KEYWORDS ARE SCANNED AND THE APPROPRIATE BITS ARE
;	SET IN THE LIST/ENABLE FLAGS WORD, MAC$GL_ENLISF
;
;--

MACR_SHOW:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ;REGISTER SAVE MASK
	MOVL	#1,R10			;FLAG SETTING OPTIONS
	MOVAB	SHOW, R7		; Address of qualifier descriptor.
	BRB	SHOW_NOSH		;

MACR_NOSH:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ;REGISTER SAVE MASK
	CLRL	R10			;FLAG CLEARING OPTIONS
	MOVAB	NOSHOW, R7		; Address of qualifier descriptor.

SHOW_NOSH:
	MOVAB	L^LST$G_DIRLIST,R9	;POINT TO SHORT NAME TABLE
	MOVAB	L^LST$G_LONGNAMES,R8	;AND LONG NAME TABLE
	BRB	SHOW_ENAB

MACR_ENAB:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ;REGISTER SAVE MASK
	MOVL	#1,R10			;FLAG SETTING OPTIONS
	MOVAB	ENABLE, R7		; Address of qualifier descriptor.
	BRB	ENAB_DSAB		;

MACR_DISA:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ;REGISTER SAVE MASK
	CLRL	R10			;FLAG CLEARING OPTIONS
	MOVAB	DISABLE, R7		; Address of qualifier descriptor.

ENAB_DSAB:
	MOVAB	L^ENB$G_OPTIONS,R9	;POINT TO SHORT NAME TABLE
	MOVAB	L^ENB$G_LONGNAMES,R8	;AND LONG NAME TABLE

;
; Fall into the common code...
;


;
; COMMON CODE FOR ENABLE/DISABLE/SHOW/NOSHOW.  THE VALUES ARE SCANNED,
; BITS SET OR CLEARED IN SYMBOL BLOCK, AND BITS SET OR CLEARED IN
; MAC$GL_ENLISF (COMMAND ENABLE / LIST FLAGS) UNTIL NO MORE VALUES.
;
SHOW_ENAB:
	MOVAB	L^MAC$GL_FLAGS,R11	;R11 MUST POINT AT FLAGS
	PUSHL	4(AP)			; Address of dynamic string descriptor.
	JSB	GET_KEYWORDS		; No, any keywords specified?
	BLBS	R0, 15$			; Yes, process them.
	RET				;***SHOULD DO DEFAULT THING!

10$:	JSB	GET_KEYWORDS		; Get the next keyword.
	BLBC	R0, 50$			; All done, return.

15$:	MOVL	(SP), R6		; Get the descriptor's address.
	MOVZWL	DSC$W_LENGTH(R6), R0	;ANOTHER VALUE?
	BEQL	50$			;IF EQL NO--EXIT
	MOVAB	L^MAC$AB_TMPSYM,R1	;COPY TO TEMP BUFFER
	MOVB	R0,(R1)+		;COPY NAME LENGTH
	MOVC5	R0,@DSC$A_POINTER(R6),-	;COPY NAME INTO TMPSYM
		#0,#SYM$K_MAXLEN,(R1)	;...
	MOVL	R9,R5			;LOOK UP NAME IN SHORT NAME TABLE
	BSBW	MAC$SRC_LIST		;IN THE SHORT NAMES
	BLBS	R0,30$			;BRANCH IF WE FOUND IT
	MOVL	R8,R5			;NO--TRY THE LONG NAMES
	BSBW	MAC$SRC_KEYS		;...
	BLBS	R0,20$			;BRANCH IF WE FOUND IT
	CALLS	#0,G^MAC$ERR_KEY_WD	;NO--ERROR--REPORT PROBLEM
	BRW	MAC$LAST_CHANCE		;AND EXIT
20$:	MOVL	SYM$L_VAL(R1),R1	;POINT TO THE REAL OPTION NAME BLOCK
	BEQL	10$			;BRANCH IF "NONE" (/SHOW W/NO VALUES)
30$:	BLBC	R10,40$			;BRANCH IF CLEARING OPTIONS
	BISW2	SYM$W_FLAG(R1),L^MAC$GL_ENLISF ;NO--SET IN COMMAND FLAGS
	CVTBL	#-1,SYM$L_VAL(R1)	;SET FLAG IN SYMBOL BLOCK
	BICW2	SYM$W_FLAG(R1),L^MAC$GL_DSLISF ;NOTE FLAG SET, IN DISABLE FLAGS
	BRW	10$			;PROCESS NEXT OPTION
40$:	BICW2	SYM$W_FLAG(R1),L^MAC$GL_ENLISF ;CLEAR IN COMMAND FLAGS
	CLRL	SYM$L_VAL(R1)		;AND IN SYMBOL BLOCK
	BISW2	SYM$W_FLAG(R1),L^MAC$GL_DSLISF ;NOTE FLAG CLEARED, IN DISABLE FLAGS
	BRW	10$			;PROCESS NEXT OPTION
50$:	RET


	.SBTTL	PROCESS DEBUG/NODEBUG QUALIFIERS
;++
; FUNCTIONAL DESCRIPTION:
;
;	The /DEBUG qualifier (plus its associated parameters) issued with the
;	DCL MACRO command will behave in the same manner as issuing a com-
;	bination of the /ENABLE and /DISABLE qualifiers utilizing the DEBUG
;	and TRACEBACK parameters.
;
;	This routine searchs for a specific parameter for the /DEBUG command.
;	Upon recognition of a parameter, the associated action (setting and/or
;	clearing bits) is performed.  The list of parameters and thier
;	value/actions are enumerated below.
;--

MACR_NODE:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ;REGISTER SAVE MASK
	MOVAB	DBG$G_LONGNAMES,R1	;DISABLE BOTH DEBUG AND TRACEBACK
	BRW	DEBU_NODE		;NO NEED TO DO ANY LOOK UPS, JUST DO IT

MACR_DEBU:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ;REGISTER SAVE MASK
	CLRL	R10			;FLAG FOR SYMBOLS AND/OR TRACEBACK SEEN
	MOVAB	G^MAC$GL_FLAGS, R11	;POINT TO FLAGS.
	PUSHL	4(AP)			; Address of dynamic string descriptor.
	MOVAB	DEBUG, R7		; Push address of DEBUG qualifier descriptor.

DBG_NEXT_OPT:
	JSB	GET_KEYWORDS		; Get the keywords (if any).
	BLBS	R0, 5$			; Got one, process it!
	BRW	DBG_RETURN		; No more, so return (Will handle default case)

5$:	MOVL	(SP), R6		; Get the descriptor's address.
	MOVZWL	DSC$W_LENGTH(R6),R0	;ANOTHER VALUE?
	BNEQ	10$			;IF NEQ YES -- CONTINUE PROCESSING IT
	BRW	DBG_RETURN		;IF EQL NO -- EXIT

10$:	MOVAB	L^MAC$AB_TMPSYM,R1	;COPY TO TEMP BUFFER
	MOVB	R0,(R1)+		;COPY NAME LENGTH
	MOVC5	R0,@DSC$A_POINTER(R6),-	;COPY NAME INTO TMPSYM
		#0,#SYM$K_MAXLEN,(R1)	;...
	MOVAB	G^DBG$G_LONGNAMES,R5	;LOOK UP THE OPTION IN THE LONG NAMES
	BSBW	MAC$SRC_KEYS		;...
	BLBS	R0,DEBU_NODE		;BRANCH IF WE FOUND IT
	CALLS	#0,G^MAC$ERR_KEY_WD	;NO--ERROR--REPORT PROBLEM
	BRW	MAC$LAST_CHANCE		;AND EXIT


;++
; COMMON CODE FOR DEBUG/NODEBUG.
; Bits are set/cleared in the symbol block and in MAC$GL_ENLISF
; (Command Enable/List Flags) until no more values are encountered.
;
; First execute some common code to set up addressing of the necessary 
; symbol blocks.
;--

DEBU_NODE:
	MOVAB	G^ENB$G_DEBUG,R2	;POINT TO DEBUG SYMBOL BLOCK ENTRY
	MOVAB	G^ENB$G_TRACEBACK,R3	;AND TO THE TRACEBACK ENTRY.

;++
; Begin looking for the specific qualifier parameters...
;
; The parameter code values are...
;
;     Value	Qualifier	Action
;	0	None		Disable both the DEBUG and TRACEBACK options
;	1	Symbols		Disable TRACEBACK and Enable DEBUG option
;	2	Traceback	Disable DEBUG and Enable TRACEBACK option
;	3	All (default)	Enable both the DEBUG and TRACEBACK options
;--

	MOVL	SYM$L_VAL(R1),R1	;CHECK WHICH OPTION WAS SELECTED
	BGTR	10$			;BRANCH IF PARAM IS NOT "NONE"
	BICW2	SYM$W_FLAG(R2),G^MAC$GL_ENLISF	;SINCE IT IS NONE, WE DISABLE
	CLRL	SYM$L_VAL(R2)		;BOTH THE DEBUG AND THE TRACE-
	BICW2	SYM$W_FLAG(R3),G^MAC$GL_ENLISF	;BACK QUALIFIER BITS IN THE
	CLRL	SYM$L_VAL(R3)		;GLOBAL AND LOCAL CONTROL BLOCKS.
	BISW2	SYM$W_FLAG(R2),L^MAC$GL_DSLISF ;NOTE FLAG CLEARED, IN DISABLE FLAGS
	BISW2	SYM$W_FLAG(R3),L^MAC$GL_DSLISF ;NOTE FLAG CLEARED, IN DISABLE FLAGS
	BRW	DBG_RETURN		;ALL DONE, CONTINUE OTHER PROCESSING.

10$:	CMPL	R1,#1			;CHECK FOR THE "SYMBOLS" QUAL
	BGTR	20$			;BRANCH IF NOT "SYMBOLS"
	BISW2	SYM$W_FLAG(R2),L^MAC$GL_ENLISF	;SET IN COMMAND FLAGS
	CVTBL	#-1,SYM$L_VAL(R2)	;SET FLAG IN SYMBOL BLOCK
	BICW2	SYM$W_FLAG(R2),L^MAC$GL_DSLISF ;NOTE FLAG SET, IN DISABLE FLAGS
	BLBS	R10,15$			;TRACEBACK or SYMBOLS PREVIOUSLY SET?
	BICW2	SYM$W_FLAG(R3),G^MAC$GL_ENLISF	;DISABLE TRACEBACK IN COMMAND
	CLRL	SYM$L_VAL(R3)		;FLAGS AND SYMBOL BLOCK
	BISW2	SYM$W_FLAG(R3),L^MAC$GL_DSLISF ;NOTE FLAG CLEARED, IN DISABLE FLAGS
	MOVL	#1,R10			;SHOW THAT "SYMBOLS" HAS BEEN SEEN.
15$:	BRW	DBG_NEXT_OPT		;PROCESS NEXT OPTION

20$:	CMPL	R1,#2			;CHECK FOR THE "TRACEBACK" QUAL
	BGTR	30$			;BRANCH IF NOT "TRACEBACK"
	BISW2	SYM$W_FLAG(R3),G^MAC$GL_ENLISF	;SET IN COMMAND FLAGS
	CVTBL	#-1,SYM$L_VAL(R3)	;SET FLAG IN SYMBOL BLOCK
	BICW2	SYM$W_FLAG(R3),L^MAC$GL_DSLISF ;NOTE FLAG SET, IN DISABLE FLAGS
	BLBS	R10,25$			;SYMBOLS or TRACEBACK PREVIOUSLY SET?
	BICW2	SYM$W_FLAG(R2),L^MAC$GL_ENLISF	;DISABLE DEBUG IN COMMAND
	CLRL	SYM$L_VAL(R2)		;FLAGS AND SYMBOL BLOCK
	BISW2	SYM$W_FLAG(R2),L^MAC$GL_DSLISF ;NOTE FLAG CLEARED, IN DISABLE FLAGS
	MOVL	#1,R10			;SHOW THAT "TRACEBACK" HAS BEEN SEEN.
25$:	BRW	DBG_NEXT_OPT		;PROCESS NEXT OPTION

;++
; IF you are here, we assume the ALL parameter was specified...
; In other words Both the DEBUG and TRACEBACK options are enabled.
;--

30$:	BISW2	SYM$W_FLAG(R2),G^MAC$GL_ENLISF
	CVTBL	#-1,SYM$L_VAL(R2)
	BISW2	SYM$W_FLAG(R3),G^MAC$GL_ENLISF
	CVTBL	#-1,SYM$L_VAL(R3)
	BICW2	SYM$W_FLAG(R2),L^MAC$GL_DSLISF ;NOTE FLAG SET, IN DISABLE FLAGS
	BICW2	SYM$W_FLAG(R3),L^MAC$GL_DSLISF ;NOTE FLAG SET, IN DISABLE FLAGS
	BRW	DBG_NEXT_OPT

;++
; That's all for now...continue with the other processing
;--

DBG_RETURN:	RET

	.SBTTL	PROCESS /UPDATE QUALIFIER

;++
; Functional description
;
;	This routine is called to process the /UPDATE qualifer.
;	The Source update merge procedure SUM$UPDATE_QUAL is called to
;	process any values on the qualifier
;
; Inputs:
;
;	4(AP)	adr	Address of a dynamic string descriptor.
;
; Implicit Inputs:
;
;	CLI$GET_VALUE	adr	Address of CLI call back routine.
;	UPDATE		adr	Address of the qualifier name descriptor.
;	UPDATE_LIST	adr	Address of list head for the update file list.
;
; Outputs:
;
;	Update files list
;
;--

MACR_UPDA:
	.WORD	0			; Register save mask
	PUSHL	4(AP)			; Address of the descriptor.
	PUSHAL	UPDATE_LIST		; Address to put update files list
	PUSHAB	UPDATE			; Address of the qualifier descriptor.
	PUSHAB	G^CLI$GET_VALUE		; Address of the CLI call back routine.
	CALLS	#4,G^SUM$UPDATE_QUAL	; Process list
	RET				; Return to finish input file processing

	.END
