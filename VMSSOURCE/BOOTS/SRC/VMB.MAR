	.TITLE	VMB - VMS Primary Bootstrap Routine
	.IDENT	'V04-002'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
;++
;
; FACILITY:
;
;	Bootstrap module for VAX 11/780, 11/750, and 11/730 hardware
;
; ENVIRONMENT:
;
;	Runs at IPL 31, kernel mode, memory management is OFF, IS=1
;	(running on interrupt stack), and code must be PIC.
;
; ABSTRACT:
;
;	This module contains the primary bootstrap code. The main
;	routine -- START_BOOT -- gains control from CONSOLE, boot block
;	0 code, or from BOOT58. The code creates a System Control
;	Block (SCB), initializes XDELTA if requested, initializes the
;	Restart Parameter Block (RPB), creates a PFN bit map describing
;	all of physical memory, reads in a secondary bootstrap program,
;	and transfers control to that bootstrap.
;
; AUTHOR:
;
;	RICHARD I. HUSTVEDT, Creation date:	18-OCT-1977
;
; MODIFIED BY:
;
;	V04-002	TCM0019		Trudy C. Matthews	07-Sep-1984
;		Change the venus delay constants in TENUSECTBL and UBDELAY.
;		Cache is not enabled in this early stage of bootstrap so
;		the delay values must be decreased from 10 to 2.
;
;	V04-001	WMC0033		Wayne Cardoza		05-Sep-1984
;		CI page table mut account for bad pages.
;
;	V03-033	TCM0018		Trudy C. Matthews	01-Aug-1984
;		Fix more bugs in FIND_CI_790.
;
;	V03-032	CWH3032		CW Hobbs		25-Jul-1984
;		Remove test for 750 cpu in console boot, those will now start
;		with BOOT58 and ask for first floppy so that CI780 and PCS
;		are available to 750.  Also, lengthen buffer for confirmation
;		prompt so that overruns won't smash RPBBASE as soon.
;
;	V03-031	TCM0017		Trudy C. Matthews	23-Jul-1984
;		Fix boot adapter register space calculation in SAVE_CSR_790.
;		Also add support for a new RPB field: RPB$B_CTRLLTR.  This
;		field allows a controller letter for the boot device's
;		controller to be an explicit input to VMB (in R2).  We made
;		this option available because INIT's algorithm for deriving
;		the boot device's controller letter is less than perfect.
;
;	V03-030	TCM0016		Trudy C. Matthews	04-Apr-1984
;		Fix some bugs in routine FIND_CI_790.
;
;	V03-029	CWH3029		CW Hobbs		15-Mar-1984
;		Require a "Y" response when switching console volumes,
;		rather than accepting a carriage return.
;
;	V03-028	WHM0002		Bill Matthews		13-Mar-1984
;		Modify support for common system files so the interface
;		between VMB and SYSBOOT doesn't have to change.
;
;	V03-027	KTA3109		Kerbey T. Altmann	08-Mar-1984
;		Add support for loading PCS750 ucode.
;
;	V03-026	KPL0001		Peter Lieberwirth	 7-Mar-1984
;		Use MOVZBW to fill in RPB BOOTNDT field.  We'll have no
;		16-bit device types until the BI, but those system routines
;		starting to use the word field need to be protected
;		against mutant memory (non-zeroed memory).
;
;	V03-025	WHM0001		Bill Matthews		24-Feb-1984
;		Add support for booting off a set of common system files.
;
;	V03-024	TCM0015		Trudy C. Matthews	16-Jan-1984
;		Add $PAMMDEF and $PR790DEF missing from TCM0014.
;
;	V03-023	WMC0023		Wayne Cardoza		12-Jan-1984
;		Add a missing .ENABL LSB
;
;	V03-022	TCM0014		Trudy C. Matthews	12-Dec-1983
;		Use PAMM to determine if an adapter is present on the
;		ABUS in FIND_CI_790.
;
;	V03-021	RLRSCORP	Robert L. Rappaport	8-Nov-1983
;		Begin to add Scorpio support.
;
;	V03-020	TCM0012		Trudy C. Matthews	08-Nov-1983
;		Correct several address calculation bugs in routines
;		SAVE_CSR_790 and FIND_CI_790.  Move VMB's "permanent" stack
;		allocation logic to before the first XDELTA breakpoint.  This
;		allows VMB to be linked with XDELTA's instruction decode
;		logic for easier debugging.
;
;	V03-019	TCM0011		Trudy C. Matthews	28-Oct-1983
;		Initialize RPB$B_FLAGS field to zero.
;
;	V03-018	CWH3018		CW Hobbs		9-Sep-1983
;		Change the wording of the prompt string for switching console
;		volumes, add a message that we are resuming load operation.
;
;	V03-017	KDM0073		Kathleen D. Morse	22-Aug-1983
;		Make references to TENUSECTBL and UBDELAY PIC.
;		Move the following cells to BOOTDRIVR.MAR:  EXE$GL_UBDELAY
;		and EXE$GL_TENUSEC.
;
;	V03-016	TCM0010		Trudy C. Matthews	02-Aug-1983
;		Store contents of PR$_SID in EXE$GB_CPUDATA cell before
;		any CPUDISP macros are executed.  Also update TENUSECTBL
;		and UBDELAY tables with appropriate values for the 11/785.
;
;	V03-015	KDM0062		Kathleen D. Morse	18-Jul-1983
;		Add data cells used by TIMEDWAIT macro, so that boot
;		drivers can use a standard time-wait macro.
;
;	V03-014	KTA3074		Kerbey T. Altmann	13-Jul-1983
;		If booting DIAG SUPRV, put CI pagetables in hi mem.
;
;	V03-013	RLRCPUDISP	Robert L. Rappaport	15-Jun-1983
;		Use new CPUDISP macro to check for supported CPU's.
;
;	V03-012	TCM0009		Trudy C. Matthews	27-Apr-1983
;		Change sense of BOOTR5 CRDTEST bit from an enable to an
;		inhibit (i.e. by default, pages with CRD errors are removed
;		during the memory test).
;
;	V03-011	KTA3039		Kerbey T. Altmann	08-Mar-1983
;		More elegant fix for TCM0008/KTA3037.
;
;	V03-010	TCM0008		Trudy C. Matthews	21-Feb-1983
;		Change invalid comparison made in KT13037.
;
;	V03-009	KTA3037		Kerbey T. Altmann	10-Feb-1983
;		Enhance SAVE_CSR_750 to handle floating adapters.
;
;	V03-008	TCM0007		Trudy C. Matthews	25-Jan-1983
;		Add routines to detect a CI adapter on any supported CPU.
;		Add a new R5 flag bit that requests that pages with
;		correctable memory errors be discarded at bootstrap time.
;
;	V03-007	TCM0006		Trudy C. Matthews	11-Jan-1983
;		Change 11/790 machine check handler to not clear out SBIA
;		error bits (will be done later before enabling interrupts).
;		Change 11/780 machine check handler to write PR$_SBIFS back
;		to itself to clear 11/780 error.  Define routine
;		SYSL$CLRSBIA for linkage to XDELTA.
;
;	V03-006	TCM0005		Trudy C. Matthews	8-Nov-1982
;		Add 11/790 machine check handler to Unibus memory scan
;		code.  Add RPB$L_BADPGS field to RPB; contains number of
;		bad pages found during VMB's memory scan.
;
;	V03-005	KTA3008		Kerbey T. Altmann	11-Oct-1982
;		Protect R7 across a call to file system.
;		Make UNIBUS memory scan more sophisticated.
;
;	V03-004	TCM0004		Trudy C. Matthews	28-Jul-1982
;		Change "7VV" symbols to "790" symbols.
;
;
;--

	.SBTTL	Declarations

	.DEFAULT DISPLACEMENT, WORD

;
; Macros to describe VMS data structures
;

	$BQODEF				; Boot QIO offsets
	$BTDDEF				; Boot device definitions
	$DMPDEF				; System dump file header definitions
	$EHSRDEF			; 11/790 Error handling status reg.
	$IHDDEF				; Image header definitions
	$IODEF				; I/O function codes
	$IO750DEF			; 11/750 definitions
	$IO780DEF			; 11/780 definitions
	$IO730DEF			; 11/730 definitions
	$IO790DEF			; 11/790 definitions
	$IO8SSDEF			; 11/8SS definitions
	$MBADEF				; MASSBUS adapter registers
	$MCF790DEF			; 11/790 machine check stack frame
	$MSTAT2DEF			; 11/790 memory status register
	$NDTDEF				; Nexus device types
	$PAMMDEF			; 11/790 physical address memory map
	$PRDEF				; Processor registers
	$PR790DEF			; 11/790 Processor registers
	$PR8SSDEF			; 11/8SS Processor registers
	$RPBDEF				; Restart parameter block
	$SBIADEF			; 11/790 SBI adapter definitions
	$SSDEF				; System status codes
	$UBADEF				; UNIBUS adapter registers
	$UBIDEF				; 11/750 UNIBUS adapter
	$VADEF				; Virtual address fields
	$VMBARGDEF			; Define VMB argument list offsets

 ; 
 ; Field definitions of the CPU-specific data block used by VMB.EXE 
 ; 
  
	$DEFINI	CPU,GLOBAL

 $DEF	CPU_W_SAVE_CSRS		 	; Routine to save CSRs. 
 			.BLKW	1 
 $DEF	CPU_W_CHECKMEM		 	; Routine to test memory. 
 			.BLKW	1 
 $DEF	CPU_W_INIT_ADAP		 	; Routine to initialize adapters.
 			.BLKW	1
 $DEF	CPU_W_FIND_CI			; Routine to find CI port.
			.BLKW	1

 	$DEFEND	CPU

;
; Macros
;

	.MACRO	ERROR,STR		; Outputs an error string to the
	BSBW	ERROUT			; console terminal.
	.ASCIZ	STR
	.ENDM	ERROR

;
; Generate a word-relative address.
;

	.MACRO	RELADR	ADDRESS,BASE
	.WORD	ADDRESS-BASE
	.ENDM	RELADR

;
; Turns a CPU identification code into the relative address of a table.
;

	.MACRO	CPU_IDENT LABEL,TABLE
	RELADR	CPU_DATA_'TABLE',LABEL
	.ENDM	CPU_IDENT
		
;
; Defines a table of data that is CPU-specific, and PIC.
;

	.MACRO	CPU_DEF	LABEL
CPU_DATA_'LABEL':			; Name of table.
	RELADR	SAVE_CSR_'LABEL',CPU_DATA_'LABEL'
					; Routine to compute CSRs.
	RELADR	CHECKMEM_'LABEL',CPU_DATA_'LABEL'
					; Routine to test memory.
	RELADR	INIT_ADP_'LABEL',CPU_DATA_'LABEL'
					; Routine to init adapters.
	RELADR	FIND_CI_'LABEL',CPU_DATA_'LABEL'
					; Routine to find CI port.
	.ENDM	CPU_DEF


;
; Branch to a new PSECT
;

	.MACRO	BRW_PSECT LABEL,PSECT=<$$$$00BOOT,LONG>
	.SHOW	EXPANSIONS

	BRW	LABEL
;
; ***** Change Program Section
;
	.PSECT	PSECT

LABEL:
	.NOSHOW	EXPANSIONS
	.ENDM	BRW_PSECT

;
; Set new PSECT
;

	.MACRO	SET_PSECT PSECT=<$$$$00BOOT,LONG>
	.SHOW	EXPANSIONS
;
; ***** Change Program Section
;
	.PSECT	PSECT

	.NOSHOW	EXPANSIONS
	.ENDM	SET_PSECT

;
; Build a table of memory size and ranges
;
	.MACRO	MEM_TABLE,MEM_SIZE,START
	.LONG	MEM_SIZE-<MEM_SIZE/10>
	.WORD	START
	.ENDM	MEM_TABLE

;
; Equated symbols
;

	IO_SIZE		= 127		; Maximum # blocks in one read
	DEBUG		= 1		; Assemble DEBUG code
	CR		= 13		; ASCII code for carriage return
	LF		= 10		; ASCII code for line feed
	BITMAP_PAG_CNT	= 4		; Number of pre-allocated
	STACK_PAG_CNT	= 3		; Number of stack pages to allocate
					; PFN bitmap pages

;
; Static storage
;

	.PSECT	__Z99BOOT,PAGE		; PSECT that always links at end
					; of bootstrap.
BOOTHIGH::				; Symbol to mark the start of
					; the first page after the code
					; in this module.
	.PSECT	BOOTDRIV_9,PAGE		; PSECT at end of drivers
OVERLAY_START:				; Start overlaying VMB here

	.IF	DF,DEBUG		; If debugging code included,
EXE$MCHKVEC	== BOOTHIGH+4		; define a symbol used by XDELTA
	.ENDC				; to locate the SCB.

;
; Declare a code PSECT that will always link at the start of the image.
;

	SET_PSECT			; Use default PSECT

	.SBTTL	START_BOOT, Primary bootstrap routine

;++
; Functional description:
;
;	VMB is loaded into physical memory and gains control via a JMP
;	instruction from CONSOLE, boot block 0 on the boot device, or
;	BOOT58. VMB gains control in the routine START_BOOT.
;
;	VMB begins by creating and initializing an SCB. If the software
;	bootstrap control flags specified a bootstrap breakpoint, VMB
;	then executes a BPT instruction that transfers control to
;	XDELTA.
;
;	After the XDELTA breakpoint, VMB initializes a system data
;	structure, i.e., a restart parameter block (RPB) that allows
;	a system reboot after a power failure or crash. The RPB holds
;	the bootstrap input registers, the boot device's CSR and bus
;	configuration register (CR), the address of the RPB itself, and
;	pointers to a primitive device driver.
;
;	VMB, the primary bootstrap, also identifies all physical memory
;	in the configuration by creating a bit map in which each bit
;	represents one page of physical memory. In the process of
;	testing all memory, VMB determines which NEXUSes on the system
;	bus are attached to adapters. For every adapter present, VMB
;	records the adapter type in the RPB.
;
;	Finally, VMB chooses a secondary bootstrap image -- either by
;	default, by boot flag settings, or by soliciting a file
;	specification from the user. VMB uses a minimal driver for the
;	bootstrap device to load the secondary image into memory, and
;	transfers control to that bootstrap.
;
;	The secondary bootstrap -- usually SYSBOOT.EXE -- uses the 
;	minimal driver from VMB for reading and writing to and from the
;	bootstrap device. Thus, SYSBOOT is device-independent.
;
;	VMB has CPU dependencies such as system bus addresses, memory
;	controller registers, and bus adapter register formats.
;	Therefore, VMB consists of common code that applies to all VAX
;	implementations, and CPU-specific code that applies to one
;	hardware implementation only. The current version supports the
;	following CPUs:
;
;		11/780	(STAR)
;		11/750	(COMET)
;		11/730	(NEBULA)
;		11/790	(VENUS)
;
; Inputs:
;
;	R0	- <07:00> boot device type code (RPB$B_DEVTYP)
;
;			0	MASSBUS device (RM02/3,RP04/5/6/7,RM80)
;			1	RK06/7
;			2	RL01/2
;			3	IDC(almost an RA80) on 11/730
;			17	UDA-50
;				(note: values 1 - 31 are reserved for
;				 Unibus devices)
;			32	HSC on CI
;			64	Console block storage device
;
;		- <15:08> reserved for future expansion
;
;		- <31:16> device class dependent (RPB$W_R0UBVEC)
;
;			UNIBUS  - optional vector address; 0 implies
;					use the default vector
;
;			MASSBUS - not used
;
;	R1	- boot device's bus address
;
;			11/780 &
;			11/730	- <31:04> MBZ
;				  <03:00> TR number of adapter
;
;			11/750	- <31:24> MBZ
;				  <23:00> address of the I/O page for the
;					  boot device's adapter
;
;			11/790	- <31:06> MBZ
;				  <05:04> A-bus Adapter number
;				  <03:00> TR number of the adapter
;
;			11/8SS - <31:04> MBZ
;				 <03:00> BI node number of adapter
;	R2
;		- all controllers:
;			<31:24>	- controller letter designator (optional)
;
;		- UNIBUS:
;
;			<31:18> MBZ
;			<17:00> UNIBUS address of the device's CSR
;
;			-11/8SS - <31:00> BI address of boot device's CSR
;
;		- MASSBUS:
;
;			<31:04> MBZ
;			<03:00> adapter's controller/formatter number
;
;		- CI:
;			<31:08> MBZ
;			<07:00> HSC port number (station address)
;
;	R3	- boot device unit number
;
;	R4	- logical block number to boot from if bit 3 is set in R5
;			(not supported on 11/750)
;
;	R5	- software boot control flags.  The value -1 is reserved.
;
;		Bit	Meaning
;		---	-------
;
;		 0	RPB$V_CONV.
;			Conversational boot. At various points in the
;			system boot procedure, the bootstrap code
;			solicits parameters and other input from the
;			console terminal. If the DIAG is also on, then
;			the diagnostic supervisor should enter "MENU"
;			mode and prompt user for devices to test.
;
;		 1	RPB$V_DEBUG.
;			Debug. If this flag is set, VMS maps the code
;			for the XDELTA debugger into the system page
;			tables of the running system.
;
;		 2	RPB$V_INIBPT.
;			Initial breakpoint. If RPB$V_DEBUG is set, VMS
;			executes a BPT instruction immediately after
;			enabling mapping.
;
;		 3	RPB$V_BBLOCK.
;			Secondary boot from boot block. Secondary
;			bootstrap is a single 512-byte block, whose
;			LBN is specified in R4.
;
;		 4	RPB$V_DIAG.
;			Diagnostic boot. Secondary bootstrap is image
;			called [SYSMAINT]DIAGBOOT.EXE.
;
;		 5	RPB$V_BOOBPT.
;			Bootstrap breakpoint. Stops the primary
;			and secondary bootstraps with a breakpoint
;			instruction before testing memory.
;
;		 6	RPB$V_HEADER.
;			Image header. Takes the transfer address of the
;			secondary bootstrap image from that file's
;			image header. If RPB$V_HEADER is not set, 
;			transfers control to the first byte of the
;			secondary boot file.
;
;		 7	RPB$V_NOTEST.
;			Memory test inhibit. Sets a bit in the PFN bit
;			map for each page of memory present. Does not
;			test the memory.
;
;		 8	RPB$V_SOLICT.
;			File name. VMB prompts for the name of a
;			secondary bootstrap file.
;
;		 9	RPB$V_HALT.
;		 	Halt before transfer. Executes a HALT
;			instruction before transferring control to the
;			secondary bootstrap.
;
;		10	RPB$V_NOPFND.
;			No PFN deletion (not implemented; intended to
;			tell VMB not to read a file from the boot device
;			that identifies bad or reserved memory pages,
;			so that VMB does not mark these pages as valid
;			in the PFN bitmap).
;
;		11	RPB$V_MPM.
;			Specifies that multi-port memory is to be used
;			for the total exec memory requirement.  No local
;			memory is to be used.  This is for tightly-coupled
;			multi-processing.
;
;		12	RPB$V_USEMPM.
;			Specifies that multi-port memory should be used in
;			addition to local memory, as though both were one
;			single pool of pages.
;
;		13	RPB$V_MEMTEST
;			Specifies that a more extensive algorithm be used
;			when testing main memory for hardware uncorrectable
;			(RDS) errors.
;
;		14	RPB$V_FINDMEM
;			Requests use of MA780 memory if MS780 is insufficient
;			for booting.  Used for 11/782 installations.
;
;		15	RPB$V_AUTOTEST
;			Used by Diagnostic Supervisor.
;
;		16	RPB$V_CRDTEST
;			Specifies that memory pages with correctable (CRD)
;			errors NOT be discarded at bootstrap time.  By default,
;			pages with CRD errors are removed from use during the
;			bootstrap memory test.
;
;		<31:28>	RPB$V_TOPSYS
;			Specifies the top level directory number for system
;			disks with multiple systems
;
;	The hardware or the CONSOLE program sets up the next 3 registers
;	after a system crash or power failure:
;
;	R10	- halt PC
;	R11	- halt PSL
;	AP	- halt code
;
;	SP	- <base_address + ^X200> of 64kb of good memory
;
; Implicit inputs:
;
;	When VMB gains control, physical memory looks like the diagram
;	below:
;
;	SP-^X200:	+--------------------------------------+
;			|     Restart Parameter Block (RPB)    |
;	SP:		+--------------------------------------+
;			|       Primary bootstrap (VMB)        |
;			+--------------------------------------+
;
; Outputs:
;
;	R10	- base address of region containing secondary bootstrap
;	R11	- address of restart parameter block
;	SP	- current stack pointer
;	PR$_SCBB- system control block address
;
; Implicit outputs:
;
;	When VMB transfers control to the secondary bootstrap, physical
;	memory is laid out as in the diagram below:
;
;	RPB$L_BASE:	+--------------------------------------+
;			|     Restart Parameter Block (RPB)    |
;	base+^X200:	+--------------------------------------+
;			|       Primary bootstrap (VMB)        |
;	PR$_SCBB:	+--------------------------------------+
;			|      System control block (SCB)      |
;			+--------------------------------------+
;			|             PFN Bitmap               |
;	PFNMAP+^X800:	+--------------------------------------+
;			|               Stack                  |
;	SP:		+--------------------------------------+
;			|     Secondary bootstrap (SYSBOOT)    |
;			+--------------------------------------+
;
; The design for the PFN bitmap has been extended to handle more than
; 4 pages of bitmap = 8mb of memory.  Bitmaps that do not fit in the
; 4 page reserved area are now allocated contiguous good pages in
; higher memory.  Assuming that the pages are actually good, the
; bitmap is placed at the RPB address + 1mb.  If a page in that area is
; bad, then the next contiguous run of pages that is big enough is
; where the bitmap will be placed.  For backward compatibility, the
; RPB$Q_PFNMAP descriptor in the RPB points at the pre-allocated
; 4 page bitmap, which is correct for the low 8mb of memory.  The
; real descriptor for the bitmap is passed in the argument list.
;
;--

START_BOOT::				; Start of primary bootstrap.

;
; Reserve space for a System Control Block (SCB) immediately after the
; VMB code. Write the address of a machine check fault handler in all
; vectors in the SCB. This handler is used during bootstrapping except
; when the bootstrap code specifically writes a different handler
; address in one of the SCB vectors.
;
; The low bit set in the address of the fault handler causes the handler
; to execute on the interrupt stack.
;

	CLRL	CONTINUE_INDEX		; Indicate initial execution of VMB
	BRW	START_BOOT_1		; Continue in other psect
	SET_PSECT <YBTMEM,LONG>

START_BOOT_1::				; Entry point for re-execution of VMB

	MOVAB	BOOT_FAULT+1,R6		; Get the address of a handler.
	MOVAB	BOOTHIGH+^X200,R7	; Get the address of the first
					; byte past the SCB.

;
; Register usage in the loop below is as follows:
;
;	R6	- address (+1) of a machine check handler
;	R7	- address of 1 byte past a longword of SCB
;

FILL_SCB:				; Fill SCB vectors.
	MOVL	R6,-(R7)		; Write 1 vector.
	BITW	#^X1FF,R7		; Check for page boundary.
	BNEQ	FILL_SCB		; Need to write another vector.

;
; Write the address of the SCB into the SCB processor register.
;

	MTPR	R7,#PR$_SCBB		; Load SCB processor register.

;
; Read the system identification processor register to discover which
; kind of VAX is to be booted.
;

	MFPR	#PR$_SID,R8		; Read the CPU identification
					; processor register.
	MOVL	R8,EXE$GB_CPUDATA	; Save contents of SID.
	ASHL	#-PR$V_SID_TYPE,R8,R8	; Get CPU identification code.
	MOVB	R8,EXE$GB_CPUTYPE	; Save processor code globally.

	CPUDISP	<<780,VALID_PROCID>,-	; Test for VAX-11/780 
		 <750,VALID_PROCID>,-	;  and VAX-11/750
		 <730,VALID_PROCID>,-	;  and VAX-11/730
		 <790,VALID_PROCID>,-	;  and VAX-11/790
		 <8SS,VALID_PROCID>>,-	;  and VAX-11/8SS
		ENVIRON=VMB;

;
; Processor is of known type.
;

VALID_PROCID:				; Continue after determining valid CPU.

;
; Now set up temporary values for the time-wait macros, used only by
; the boot drivers.  Later on in the boot process actual values will
; be computed.
;
	MOVZBL	TENUSECTBL-1[R8],EXE$GL_TENUSEC ; Ten micro-sec loop counter
	MOVZBL	UBDELAY-1[R8],EXE$GL_UBDELAY ; Unibus delay loop counter

;
; If the DEBUG flag is defined (meaning that XDELTA has been linked
; with this primary bootstrap), set up 2 XDELTA handlers in the SCB --
; one for breakpoints and one for tbit traps. Then initialize the
; XDELTA breakpoint table, allocate 3 pages of stack, and, if requested,
; execute a breakpoint before proceeding with the bootstrap.
;

	.IF	DF,DEBUG		; If debugging is going on,
	MOVAB	XDELBPT,^X2C(R7)	; Set up BPT handler.
	MOVAB	XDELTBIT,^X28(R7)	; Set up TBIT handler.
	MOVAB	INI$BRK,XDELIBRK	; Store the initial breakpoint.
	MOVL	SP,R6			; Save current top of stack.
	MOVAB	<<^X200>+<BITMAP_PAG_CNT*^X200>+<STACK_PAG_CNT*^X200>>(R7),-
		SP 			; Create a stack above the SCB and
					; pre-allocated bitmap.
	BBC	#RPB$V_BOOBPT,R5,-	; If no BPT was requested in the
		NOBRK			; boot flags, just proceed.

;
; Initial breakpoint.
;
; Current register status is as follows:
;
;	R0-R5	- initial VMB input values
;	R6	- SP value at start of VMB
;	R7	- address of the SCB
;	R8	- processor identification code
;	R9-FP	- initial VMB input values
;	SP	- address of a 3-page stack
;
;

INI$BRK::				; Debugging breakpoint.
	BPT				; Stop in XDELTA.

NOBRK:					; Proceed with bootstrapping.
	.ENDC				; End of debug conditional.


	.SBTTL	Initialize RPB

;++
;
; The next section of VMB writes the restart parameters into the RPB.
; These parameters include
;
;	the VMB input registers
;	the base address of the RPB
;	the boot device's CSR
;	the boot device adapter's configuration register (CR)
;	the address of the PFN bitmap
;	the address and length of the bootstrap device driver
;
; Current register settings are as follows:
;
;	R0-R5	- unchanged from time that VMB gained control
;	R6	- SP value from time that VMB gained control
;	R7	- address of the SCB
;	R8	- processor identification code
;	R9-FP	- unchanged from time that VMB gained control
;	SP	- top of VMB's stack
;	
;--

;
; Store the boot parameters in the RPB, as well as the RPB starting
; address. CONSOLE-controlled restart code looks for the starting
; address contained within itself as a clue to VMS restartability.
;

	MOVL	R11,-(SP)		; Save Halt PSL temporarily
	MOVAB	-^X200(R6),R11		; Calculate base address of RPB.
	MOVL	(SP)+,RPB$L_HALTPSL(R11); Save Halt PSL in RPB
	MOVL	R10,RPB$L_HALTPC(R11)	; Save Halt PC in RPB
	MOVL	R11,BOO$GL_RPBBASE	; Save address for callback.
	MOVL	R11,RPB$L_BASE(R11)	; Save address in RPB.
	MOVQ	R0,RPB$L_BOOTR0(R11)	; Save boot registers R0-R1.
	MOVQ	R2,RPB$L_BOOTR2(R11)	; Save boot registers R2-R3.
	MOVB	RPB$L_BOOTR2+3(R11), -	; Move high byte of BOOTR2 to
		RPB$B_CTRLLTR(R11)	; another RPB location.
	CLRB	RPB$L_BOOTR2+3(R11)	; Clear the high byte (for compatibility).
	MOVQ	R4,RPB$L_BOOTR4(R11)	; Save boot registers R4-R5.
	MOVAL	BOO$AL_VECTOR,-		; Save address of boot device
		RPB$L_IOVEC(R11)	; driver
	CLRL	RPB$L_IOVECSZ(R11)	; Correct size of boot-driver wil be
					; set by the first call to BOO$QIO
	CLRB	RPB$B_FLAGS(R11)	; Initialize flags field
	MOVL	AP,RPB$L_HALTCODE(R11)	; Save the halt code.
	MNEGL	#1,RPB$L_ADPPHY(R11)	; Initialize adapter physical address
	MNEGL	#1,RPB$L_CSRPHY(R11)	; Initialize CSR physical address

;
; Move device characteristics from the input registers into the RPB.
;

	MOVW	R3,RPB$W_UNIT(R11)	; Save the device unit number.
	MOVB	R0,RPB$B_DEVTYP(R11)	; Save the device type.

;
; From this point on AP contains the address of the Secondary Boot
; argument list.
;

	MOVAL	SECOND_PARAM,AP		; Address of Secondary Boot arg list

;
; Calculate the address of the CPU-specific table. CPU_CODES is a list
; of offsets from start of CPU_CODES to start of a CPU-specific data
; table.
;

	MOVZWL	CPU_CODES[R8],R8	; For a CPU, get offset to CPU
					; data from CPU-list table.
	MOVAB	CPU_CODES[R8],R8	; Add offset to address of
					; CPU-list table.

;
; Reserve space for an PFN bitmap that will desecribe all of physical
; memory. Store the address and size of the PFN bitmap in the RPB.
;

	MOVAB	RPB$Q_PFNMAP+4(R11),R9	; Get pointer to RPB bitmap
					; address field.
	MOVAB	^X200(R7),(R9)		; Store PFN bitmap address
					; (1 page past SCB base address).
	MOVL	#BITMAP_PAG_CNT*512,-(R9); Store bitmap size in RPB.
	MOVAB	<<^X200>+<BITMAP_PAG_CNT*^X200>+<STACK_PAG_CNT*^X200>>(R7),-
		R10			; Adjust pointer to 1st unused
					; byte of free memory (past the SCB
					; and the PFN bitmap and the stack).
;
; Now continue execution of VMB in the appropriate place, based on
; whether this is the first execution of VMB (normal boot procedure)
; or whether this is a recursive execution of VMB (as requested via
; RPB$V_FINDMEM flag).
;
	MOVAB	CONTINUE_TBL,R6		; Get adr of continuation code adrs
	MOVL	CONTINUE_INDEX,R0	; Get continuation index code
	CVTWL	(R6)[R0],R0		; Calculate address of appropriate code
	JMP	(R6)[R0]		; Continue executing where left off

;
; Table of continuation addresses for continuation of
; algorithm that uses MA780 memory instead of MS780 memory
; for booting.  (Requested via RPB$V_FINDMEM flag.)  Each
; entry in this table points to the code at which execution
; continues after VMB has been moved into memory on a different
; memory controller.  This is to allow the physical addresses
; of memory to be altered by VMB.
;
CONTINUE_TBL:				; Table of continuation addresses
	RELADR	NORMAL_PATH,CONTINUE_TBL ; Path for normal VMB execution
	RELADR	CONT1_PATH,CONTINUE_TBL	; Continuation of VMB in MA780 memory
	RELADR	CONT2_PATH,CONTINUE_TBL	; Continuation of VMB in MS780 memory

CONTINUE_INDEX::			; Index into continuation table
	.LONG	0			; Normal VMB path index is 0
NORMAL_PATH:

	.SBTTL	Locate and test memory

;++
;
; The next section of the primary bootstrap program determines and
; records the size and pattern of available memory in a PFN bitmap.
; It does this by calling a processor specific subroutine linked with VMB.
; Each subroutine handles the sizing of memory and the testing of the
; pages.  A common routine (BOO$TEST_MEM) is called to allocate and
; initialize bitmap segments, and loop through the page testing.
; When the sizing and testing are complete, the resulting bitmap is
; neither contiguous nor necessarily dense.  There could be ranges of
; PFN's that are simply not present and will of course be assumed 
; to be bad.  At this point a contiguous chunk of memory is allocated
; and a clean, dense, contiguous bitmap is formed from the pieces.
;
; Current register settings are the following:
;
;	R0-R6	- scratch
;	R7	- address of the SCB
;	R8	- address of the CPU-specific table
;	R9	- address of RPB$Q_PFNMAP
;	R10	- address of 1st byte of unused good memory
;	R11	- address of the RPB
;	AP	- address of secondary boot argument list
;	FP	- scratch
;	SP	- address of a 3 page stack
;
; In previous versions of VMB, the RPB CONFREG field was filled in with
; a code indexed by TR number which identifies the adapter type of each
; NEXUS.  This is still done for 11/780 and 11/750 for backward compatibility
; of VMB.  For 11/730 and 11/790, the CONFREG array is filled in by INITADP
; at a later stage of bootstrapping.
;
;--

LOC_TEST_MEM:

;
; No assembly time initialization is allowed in VMB because the
; ERROR logic allows it to restart.
;
	CLRL	VMB$L_HI_PFN(AP)	; Init BITMAP data for
	ROTL	#21,#1,VMB$L_LO_PFN(AP)	; highest and lowest PFN
	CLRL	BITMAP_HI_INDX		; Highest bitmap page index
	ROTL	#<32-9>,R11,R0		; Base PFN for large bitmaps
	MOVAL	4096(R0),BITMAP_BAS_PFN ; is 2mb beyond RPB
;
; Initialize the pre-allocated PFN bitmap pages to zero.  There is
; at least one such page to hold the bitmap for the pre-tested
; block of memory in which we are running.  The size of this 
; pre-allocated bitmap is an integral number of pages.
;

	MOVL	4(R9),R6		; Get base of PFN bitmap.
	MOVC5	#0,(R6),#0,(R9),(R6)	; Set bitmap to all zeroes.
	MOVC5	#0,(R6),#0, -		; Zero fill the memory descriptors in
		#<RPB$C_MEMDSCSIZ*RPB$C_NMEMDSC>,RPB$L_MEMDSC(R11) ; the RPB
	CLRL	RPB$L_PFNCNT(R11)	; Init the count of good pages
	CLRL	RPB$L_BADPGS(R11)	; Init the count of bad pages
	MOVL	R10,BITMAP_VEC_PTR	; Address of vector of bitmap addresses
	MOVC5	#0,(R10),#-1,#512*4,(R10) ; Init bitmap address vector.
;
; A side effect of the above MOVC5 is that R1 = R10
;
	MOVL	R3,R10			; Next free address (page bounded)
	MOVL	4(R9),R3		; Address of pre-allocated bitmap
	MOVL	#BITMAP_PAG_CNT,R2	; Number of pages of pre-alloc bitmap
10$:	MOVL	R3,(R1)+		; Store address of bitmap page
	MOVAL	^X200(R3),R3		; Next pre-allocated bitmap page
	SOBGTR	R2,10$			; Loop through pre-allocated page(s)

;
; Allow the bitmap page containing the RPB to be above the pre-allocated
; (8mb max) PFN bitmap.
;
	ASHL	#-<9+12>,R11,R0		; Bitmap index for RPB
	TSTL	@BITMAP_VEC_PTR[R0]	; Need a bitmap page for this
					; portion of the PFN bitmap?
	BGEQ	20$			; Branch if not
	MOVL	R10,@BITMAP_VEC_PTR[R0] ; Use one more pre-tested page
	MOVC5	#0,(R10),#0,#512,(R10)	; as the bitmap page
	MOVL	R3,R10			; Keep track of next free address
20$:
;
; In the 11/780 and 11/750 CPU implementations, the memory test routines
; check up to 16 slots (positions)  on the system bus for adapters or memory
; controllers. The 16-byte field RPB$B_CONFREG in the RPB stores each
; type of adapter/controller as the bootstrap finds it. Set up registers
; to facilitate this loop in the CPU-specific routines.
; In the 11/730 and 11/790, the CONFREG field is not filled in by VMB, but

; initialized in INITADP at a later stage of bootstrapping.  The difference
; is to maintain backward compatibility of VMB for currently supported systems.
;

	MOVAB	RPB$B_CONFREG(R11),R5	; Point to start of
					; configuration field.

;
; Now call the CPU-specific routine to locate and test memory.
;

	PUSHR	#^M<R9,R10,AP>		; Save some registers
	CVTWL	CPU_W_CHECKMEM(R8),R0	; Calculate address of a
	JSB	(R8)[R0]		; CPU-specific memory test
					; routine and call it.
	POPR	#^M<R9,R10,AP>		; Restore saved registers
	CMPL	BITMAP_HI_INDX,#BITMAP_PAG_CNT-1 ; All bitmap pre-allocated?
	BGTR	ALLOC_BITMAP		; Branch if not
	ADDL3	#1,BITMAP_HI_INDX,R0	; Actual number of the pre-allocated
					; bitmap pages that were used
	ASHL	#9,R0,RPB$Q_PFNMAP(R11)	; Record possibly smaller descriptor
	BRW	BITMAP_IS_OK		; Yes, don't need to move it

;
; Need to allocate a contiguous PFN bitmap and move the scattered 
; bitmap pages into it.
;
; The starting point for trying to allocate is 4096 pages (2mb) after
; the RPB.  The only pages that can be in use here that appear to be
; good and usable are the bitmap pages themselves when they are
; allocated as the first good PFN in a given bitmap page.
;

ALLOC_BITMAP:
	SUBL3	#1,BITMAP_BAS_PFN,R2	; Desired location for bitmap
	CLRL	R5			; Init "first alloc failure" flag
	BRB	45$
10$:	AOBLSS	VMB$L_HI_PFN(AP),R2,20$	; Calculate the next PFN
	ERROR	</%BOOT-F-Failed to allocate PFN bitmap/>
20$:	EXTZV	#0,#12,R2,R0		; Bitmap page relative PFN
	EXTZV	#12,#9,R2,R1		; Index to bitmap page
	MOVL	@BITMAP_VEC_PTR[R1],R1	; Address of bitmap page
	BGEQ	30$			; Branch if present
	BISW	#^XFFF,R2		; Skip this entire bitmap page
	BRB	40$
30$:	BBC	R0,(R1),40$		; Branch if page is bad
	ASHL	#9,R2,R0		; Address from PFN
	CMPL	R0,R1			; Same as bitmap page adr?
	BNEQ	50$			; Branch if not, its ok
					; Otherwise treat as a bad page
40$:	BBSS	#0,R5,45$		; Branch if not first alloc failure
	ADDL3	BITMAP_HI_INDX,R4,R2	; Skip the entire "pre-planned"
					; allocation area.  Some bitmap pages
					; may be in it, but in the wrong place
45$:	ADDL3	#1,R2,R4		; Reset start point of search
	ADDL3	#1,BITMAP_HI_INDX,R3	; Reset no. of pages to look for
50$:	SOBGEQ	R3,10$			; Next page in contiguous cluster

;
; Now move all the bitmap pages into the contiguous space just found
;

MOVE_BITMAP:
	ASHL	#9,R4,R3		; Starting adr of new bitmap
	MOVL	R3,4(R9)		; Record base adr of PFN bitmap
	MOVL	BITMAP_VEC_PTR,R6	; Adr of array of bitmap page adrs
10$:	MOVL	(R6)+,R1		; Adr of next bitmap page
	BGEQ	20$			; Branch if page is allocated
	MOVC5	#0,(R3),#0,#512,(R3)	; No good pages in this 2mb
	BRB	50$
20$:	CMPL	R1,R3			; No move needed?
	BNEQ	30$			; Branch if must move the page
	MOVAL	512(R3),R3		; Just adjust the bitmap adr
	BRB	50$
30$:	MOVC3	#512,(R1),(R3)		; Move the bitmap page
50$:	SOBGEQ	BITMAP_HI_INDX,10$	; Loop through all bitmap pages
	SUBL3	4(R9),R3,(R9)		; Store size of PFN bitmap
BITMAP_IS_OK:
	MOVL	BITMAP_VEC_PTR,R10	; Reset first free byte pointer


	.SBTTL	Load CI microcode
;
; Check for the presence of a CI port on the SBI.  If present try to locate
; the appropriate microcode file on the console medium (CI780.BIN).  If found,
; then load it into memory.  If not found and not booting from it, merely issue
; a warning message and continue on - presumably some human will correct the
; situation later.  If not found and booting, then give an error and HALT!
;

	.ENABLE LSB
	BBS	#RPB$V_DIAG,-		; If this is a DIAG SUPRV boot,
		 RPB$L_BOOTR5(R11),2$	;  then do NOT allocate.
	BSBW	BOO$CACHE_ALLOC		; Allocate the FILEREAD cache
2$:	MOVZBL	RPB$B_DEVTYP(R11),R2	; Hold the device type
	CVTWL	CPU_W_FIND_CI(R8),R0	; Get CPU-specific routine to find CI.
	JSB	(R8)[R0]		; Call it.
	BNEQ	10$			; NEQ => CI port on the system.
	CMPB	#BTD$K_HSCCI,R2		; Booting off the HSC/CI?
	BEQL	5$			; Yes, error
	BRW	50$			; No, just leave quietly

5$:	ERROR	</%BOOT-F-No such device/>

10$:	MOVB	#BTD$K_CONSOLE,-	; Temp set for reading from console
		RPB$B_DEVTYP(R11)	;  the ucode file
	MOVAB	CI_UCODEV,R3		; Pick up the ucode vector
	BSBW	OPEN_UCODE_FILE		; Find and open it
	BLBS	R0,30$			; Found it, continue
	BRW	40$			; Did not find it, but not booting
;
; Found the CI and the CI ucode.  Now determine the place in memory to read
; the code into as well as put the page table.  The search starts at place
; indicated in the following table and stops just short of the FILEREAD
; cache (which is why the cache-init was done earlier).  If not enough
; memory can be found, halt with a message.
;
; NOTE:	If this table is changed, a corresponding table near the label
;	MEM_CACHE_TABLE needs to be checked for consistency.
;
MEM_TAB:
;		   SIZE,START
;		   ---- -----
	MEM_TABLE  8192,512		; More than 4 megabyte
	MEM_TABLE  2048,256		; More than 1 megabyte
	MEM_TABLE     0,  0		;

30$:	PUSHL	R2			; Save old devtype
	MOVL	RPB$L_PFNCNT(R11),R1	; Maximum memory
	ADDL	RPB$L_BADPGS(R11),R1	; Add in the bad pages
	MOVAB	MEM_TAB,R3		; Addr of table
32$:	MOVL	(R3)+,R4		; Get the next table entry
	BEQL	34$			; Memory too small
	MOVZWL	(R3)+,R0		; Starting page number
	CMPL	R1,R4			; More memory than this entry?
	BLSS	32$			; Branch if not, get next entry
	MOVAB	127(R1),R1		; Set to round up
	ASHL	#-7,R1,R1		; Number of pages of page table needed
	ADDL	CI_UCODE_STAT+4,R1	; Add in the ucode length
	MOVL	R1,R4			; Will not settle for less
	ASHL	#9,VMB$Q_FILECACHE+4(AP),R5; Start addr of FILEREAD cache
	BNEQ	60$			; Okay, if somethere there, else ..
	ASHL	#-2,RPB$L_PFNCNT(R11),R5 ; Use 1/4 of max as limit	
60$:	BBC	#RPB$V_DIAG,-		; If this is NOT a DIAG SUPRV boot,
		 RPB$L_BOOTR5(R11),33$	;  skip next
	MOVZWL	#768,R0			; Start at ^X60000
	MOVL	RPB$L_PFNCNT(R11),R5	; Go to top
;
; Attempt to allocate the pages necessary: A page table to encompass all of
; physical memory and the full microcode file.  The entire size must fit
; at a lower address than the FILEREAD cache, since this allocation cannot
; be either stepped on or deallocated until INIT time.
;
33$:	BSBW	BOO$ALLOC_PAGES		; Grab the pages
	BGEQ	35$			; Success
34$:	ERROR	</%BOOT-F-Insufficient memory for CI/>

35$:	ADDL3	R2,R3,VMB$L_CI_HIPFN(AP); Set the highest PFN used
	ASHL	#9,R3,R6		; Address to read into
	MOVL	R6,VMB$Q_UCODE+4(AP)	; Store address away
	MOVQ	R7,-(SP)		; Save registers
;
; Now attempt to find and load the PCS file for 750's.
;
	CMPB	EXE$GB_CPUTYPE,-	; Check if this is 750
		 #PR$_SID_TYP750	
	BEQL	64$			; Okay
	BRW	80$			; No, so skip all this

64$:	CMPB	EXE$GB_CPUDATA+1,#^X5F	; Is this a REV 95 ucode machine?
	BGEQU	65$			; Yes, continue
	ERROR	</%BOOT-F-Base CPU not at proper rev level for CI/>

65$:	MOVAB	PCS_UCODEV,R3		; Pick up ucode vector
	BSBW	OPEN_UCODE_FILE		; Find and open it
	MOVQ	PCS_UCODE_STAT,R8	; Starting LBN and size
	BSBW	READFILE		; Read it in
;
; This routine loads the Patchbits.  The Patchbits are extracted one bit at 
; a time from longwords and written to the Patchbits.  To write to the
; Patchbits a '1' has to be written to the Patchbit Enable Register (CMI
; address F0C000). Upon completion of this routine the Patchbit Enable
; Register is cleared.
;
	MOVL	VMB$Q_UCODE+4(AP),R6	; Grab starting address
	MOVL	#^X00F00000,R4		; Physical address of patchbits
	MOVL	#1,@#^X00F0C000		; Enable writing to Patchbits
	CLRL	R2			; Clear counter
70$:	EXTZV	R2,#1,(R6),(R4)		; Write Patchbits
	ADDL2	#4,R4			; Next CMI location
	AOBLSS	#^X2000,R2,70$		; Done ?
	CLRL	@#^X00F0C000		; Disable writing to Patchbits
;
; This routine loads PCS with the microcode.
;
;	MOVL	#^X00F08000,R4		; Map to PCS address on CMI
	MOVAB	^X400(R6),R6		; R6 -> start of PCS Ucode in buffer
	MOVZWL	#^X400,R2		; Number of microwords
	PUSHL	R4			; Save first address for later enable
	EXTZV	#0,#20,(R6),R0		; Save first 20 bits for later enable
	CLRL	R1			; Clear counter
72$:	MOVZWL	#4,R5			; Short loop control
74$:	EXTZV	R1,#20,(R6),(R4)+	; Store one 20 bit unit
	ADDL2	#20,R1			; Increment BIT position
	SOBGTR	R5,74$			; Finish one microword
	SOBGTR	R2,72$			; Finish all microwords
	BISL3	#^XFFF00000,R0,@(SP)+	; Set and write bits
;
; Read in the CI ucode file into the allocated area.
;
80$:	MOVQ	CI_UCODE_STAT,R8	; Starting LBN and size
	ASHL	#9,R9,VMB$Q_UCODE(AP)	; Store size away
	MOVL	VMB$Q_UCODE+4(AP),R6	; Grab starting address
	BSBW	READFILE		; Read it in
	MOVQ	(SP)+,R7		; Restore
	POPL	R2			; Restore old devtype
	BBSS	S^#VMB$V_LOAD_SCS,-	; Tell SYSBOOT to load SCS code
		VMB$L_FLAGS(AP),40$
40$:	MOVB	R2,RPB$B_DEVTYP(R11)	; Restore the 'real' boot device
50$:	MOVL	RPB$L_IOVEC(R11),R0	; Pick up vector address
	MOVL	R11,R9			; Transfer RPB address
	JSB	@BQO$L_MOVE(R0)[R0]	; Move the boot driver
	.DISABLE LSB

;
; Initialize the boot device's bus adapter.  If not console, call a
; CPU-specific subroutine to convert this data into the physical
; addresses of the adapter's configuration register (CR) and the
; device's control/status register (CSR). Store the addresses in the
; RPB.
;

ADPINIT:				; Initialize adapter.
	CMPB	RPB$B_DEVTYP(R11),-	; Skip over if booting from
		#BTD$K_CONSOLE		; console block storage device
	BEQL	15$
	MOVQ	RPB$L_BOOTR1(R11),R1	; Pick up original R1/R2
	CVTWL	CPU_W_SAVE_CSRS(R8),R5	; Calculate address of a
	JSB	(R8)[R5]		; CPU-specific routine to
					; calculate and save boot device
					; and adapter's CSRs in RPB.
	CMPB	RPB$B_DEVTYP(R11),-	; Skip over if booting from
		#BTD$K_HSCCI		;  HSC/CI adapter
	BEQL	10$
	MOVL	RPB$L_ADPPHY(R11),R0	; Get ADP CSR address.
	CVTWL	CPU_W_INIT_ADAP(R8),R1	; Calculate address of a
	JSB	(R8)[R1]		; CPU-specific adapter init.
					; routine and call it.
10$:	MOVL	RPB$L_IOVEC(R11),R0	; Pick up vector address
	MOVL	VMB$Q_UCODE+4(AP),-
		BQO$L_UCODE(R0)		; Transfer the ucode address
	MOVL	BQO$L_UNIT_INIT(R0),R1	; Pick up any possible routine
	BEQL	15$			; None
	CALLG	(AP),(R0)[R1]		; Do any necessary unit init
	BLBS	R0,15$			; All is well
	ERROR	</%BOOT-F-Failed to initialize device/>

15$:

;
; The adapter initialization routines exit with RSB instructions. Thus,
; control returns here, and proceeds to obtain the secondary bootstrap
; specification as described on the next page.
;

	.SBTTL	Identify and read in the secondary boot image

;++
;
; Current register settings are the following:
;
;	R0-R6	- scratch
;	R7	- address of the SCB
;	R8	- address of the CPU-specific table
;	R9	- scratch
;	R10	- address of the 1st byte of unused memory
;	R11	- address of the RPB
;	AP	- address of secondary boot parameter list
;	SP	- address of a 3 page stack
;
; Registers R0-R6 and R9 are available as scratch registers.
;
; The next 2 paragraphs refer to an 11/780-specific function. The
; function is historical; not implemented on later processors:
;
; The primary bootstrap now looks at a software bootstrap flag --
; RPB$V_BBLOCK. If the flag is set, the secondary bootstrap is a single
; block from the boot device. The LBN is stored in RPB$L_BOOTR4.
; Set up size of secondary bootstrap, transfer address, memory address,
; and LBN fields so that subsequent code can read the boot block into
; memory and transfer control to the code contained therein.
;
; If the RPB$V_BBLOCK flag is not set, the primary bootstrap must load
; a secondary bootstrap file specified by an ASCII file specification.
;
; If another boot flag -- RPB$V_SOLICT -- is set, the primary bootstrap
; asks the console user to type in a file specification.
;
; If the boot flag is not set, the bootstrap just selects a standard
; secondary bootstrap from the boot device. The bootstrap then calls I/O
; subroutines that locate the file, copy it into memory above the stack,
; and transfer control to the image's transfer address.
;
;--

;
; If we are booting from the console block storage device, it is 
; necessary to switch the media to the system floppy or cartridge.
; Type a message on console and wait for carriage return.
;

	CMPB	RPB$B_DEVTYP(R11),-	; Booting from console block
		#BTD$K_CONSOLE		; storage device?
	BNEQ	104$			; No
	PUSHAB	REMOVEPROMPT2		; Pass first part of remove message
	PUSHAB	REMOVEPROMPT1		; Pass second part of message
	MOVL	SP,R9			; Pass the address for the resume message
	BSBB	105$			; Print the message
	ADDL2	#8,SP			; Pop the arguments
103$:	PUSHAB	INPBUF			; Push address of input buffer
	PUSHL	#4			; Push size of buffer
	PUSHAB	SWITCHPROMPT		; Push address of prompt string
	CALLS	#3,BOO$READPROMPT	; Prompt and wait for <ret>
	BICB	#32,INPBUF+1		; Force answer to upper case (ASCIC string)
	CMPB	INPBUF+1,#^A"Y"		; We want to see a Yes
	BNEQ	103$			; Not "Y", ask again
	PUSHAB	RESUMEPROMPT2		; Pass first part of resume message
	PUSHAB	RESUMEPROMPT1		; Pass second part of message
	MOVL	SP,R9			; Pass the address for the resume message
	BSBB	105$			; Print the message
	ADDL2	#8,SP			; Pop the arguments
104$:	BRW	20$			; And continue

;
; Local subroutine to print a message with a volume label stuck in the
; middle.
; Input:	R9 -> two longwords containing the addresses of the front
;		     and rear parts of the message (two ASCIZ strings)
;
105$:					; Push arguments for QIO.
	PUSHL	R11			; Push phony channel number.
	PUSHL	#0			; Physical read mode.
	PUSHL	#IO$_READLBLK		; Read logical block function.
	PUSHL	#1			; Starting LBN.
	MOVZWL	#512,-(SP)		; Transfer size in bytes.
	PUSHL	R10			; Buffer address
	CALLS	#6,BOO$QIO		; Call a bootstrap QIO routine.
	BLBS	R0,101$
	ERROR	</%BOOT-F-Unable to read console volume/>
101$:	CLRQ	-(SP)			; Null buffer means print only
	PUSHL	(R9)+			; Move address of first message
	CALLS	#3,BOO$READPROMPT	; Print the message
	MOVAB	472(R10),R5		; Point R5 at the volume label
	MOVL	#12,R0			; Length of volume label
	MOVAB	(R5)[R0],R1		; Point R1 one past the end
201$:	MOVB	-(R1),R2		; R2 contains the byte
	BEQL	301$			; Byte is null, skip it
	CMPB	#^A" ",R2		; Is it a space
	BNEQ	401$			; End of name found, print it
301$:	SOBGTR	R0,201$			; Do the whole string
	BRB	501$			; No name, don't bother not printing it

401$:	CLRB	1(R1)			; Put a null after the string
	CLRQ	-(SP)			; Null buffer is print only
	PUSHL	R5			; R5 -> front of volume label
	CALLS	#3,W^BOO$READPROMPT	; Type the first string
501$:	CLRQ	-(SP)			; Null buffer means print only
	PUSHL	(R9)			; Pass address of second message
	CALLS	#3,BOO$READPROMPT	; Print the message
	RSB

;
; The next code paragraph is historical: refers only to the 11/780:
; If the boot block flag is set, prepare I/O input registers.
;

20$:	BBC	#RPB$V_BBLOCK,-		; If the boot from boot block
		RPB$L_BOOTR5(R11),-	; flag is not set, proceed to
		TEST_SOLICIT		; test the solicit bit.
	MOVL	#2,R5			; block to go, and transfer
					; address from start of block.
	MOVL	RPB$L_BOOTR4(R11),R8	; Get boot block LBN.
	MOVL	#1,R9			; Set block size to 1 block.
	BRW	READIN_BOOT		; Proceed to read in block.

;
; If the "solicit for secondary bootstrap file" flag is not set,
; just use a predefined file specification.
;

TEST_SOLICIT:				; Check for solicit.
	BBC	#RPB$V_SOLICT,-		; If "solicit" flag is not
		RPB$L_BOOTR5(R11),-	; set, just use a default file
		DEFAULT_SECOND		; specification.

;
; To solicit a file name, call a device-independent subroutine that
; writes a prompt string to the console terminal, and then reads the
; user typed file name. All device specifications are ignored.
;

	PUSHAB	RPB$T_FILE(R11)		; Set address of input buffer.
	PUSHL	#39			; Set maximum character count.
	PUSHAB	NAMEPROMPT		; Set address of prompt string.
	CALLS	#3,BOO$READPROMPT	; Prompt and read string.
	MOVL	#1,R9			; No retry if this file is not found
	MOVAB	RPB$T_FILE(R11),R7	; Get address of file name string
	BRB	FILEBOOT		; Go try to read the file.

;
; If the solicit boot flag was not set, use a default file name string.
; Usually, this file name is [SYSEXE]SYSBOOT.EXE. However, if the
; diagnostic boot flag is set, the file name is [SYSMAINT]DIAGBOOT.EXE.
;

DEFAULT_SECOND:				; Use default file name.
	MOVAB	VMSFILE,R7		; Assume SYSBOOT.EXE.
	BBC	#RPB$V_DIAG,-		; If the diagnostic flag is not
		RPB$L_BOOTR5(R11),-	; set, SYSBOOT is correct.
		COPY_NAME
	MOVAB	DIAGFILE,R7		; Otherwise, use predefined
					; name of diagnostic boot.

;
; Copy the file name to the RPB.
;

COPY_NAME:				; Copy file name.
	EXTZV	#RPB$V_TOPSYS,#RPB$S_TOPSYS,-
		RPB$L_BOOTR5(R11),R9 	; Value of 0-F means top level
					; system directory "SYS0" - "SYSF"
	CMPL	R9,#9			; 0 - 9 ?
	BLEQ	10$			; Branch if yes
	ADDL	#<<^A/A/>-<^A/9/>-1>,R9	; Add bias to make A - F
10$:	ADDB	R9,W^FIL$GT_TOPSYS+4	; Form "SYSn"
	MOVZBL	(R7),R0			; Size of name string
	ADDB3	#5,R0,RPB$T_FILE(R11)	; Add "SYSn" size and one for a dot
	MOVB	#^A/[/,RPB$T_FILE+1(R11); Start directory spec
	MOVL	W^FIL$GT_TOPSYS+1,-	; Put top level sys name
		RPB$T_FILE+2(R11)	;
	MOVC3	R0,1(R7),RPB$T_FILE+6(R11); Move name into RPB
	MOVB	#^A/./,RPB$T_FILE+6(R11); Put in dot

;
; Call a device-independent routine, FIL$OPENFILE to locate the named
; file on the disk.
;
; Registers set up are the following:
;
;	R7	- address of counted ascii file name string
;	R10	- address of 1st byte of unused memory
;	R11	- address of the RPB
;


FILEBOOT:				; Locate the file.
	BSBW	BOO$CACHE_OPEN		; Open the FILEREAD cache
10$:	PUSHAB	1(R7)			; Address of file name string.
	MOVZBL	(R7),-(SP)		; Character count of file name.
	MOVAL	-(SP),R6		; Allocate scratch for channel
					; and get adr of scratch storage
	PUSHAL	RPB$L_FILLBN(R11)	; RPB fields that receive file
					; statistics during OPEN.
	PUSHAL	(R10)			; File header buffer at end of
					; memory.
	PUSHAL	^X200(R10)		; Index file header buffer at
					; end of memory.
	PUSHAL	4(R6)			; Address in file name desc.
	PUSHAL	(R6)			; Address of phony channel.
	CALLS	#5,FIL$OPENFILE		; Call FILREAD to locate file.
	ADDL2	#12,SP			; Clean up scratch space
	BLBS	R0,FILE_CONTIG		; Branch on success.

;
; File was not found.  If looking up default secondary boot file in
; SYS0 top level system directory, try the lookup with a null TOPSYS.
;

	CMPW	R0,#SS$_NOSUCHFILE	; If not "no such file"
	BNEQ	30$			; then don't consider a second try
	TSTB	W^FIL$GT_TOPSYS		; Try this second lookup once only
	BEQL	30$			; Branch if no TOPSYS in use
	CLRB	W^FIL$GT_TOPSYS		; Disable TOPSYS
	CMPB	#^A/0/,W^FIL$GT_TOPSYS+4 ; Trying to boot from [SYS0.SYSEXE]?
	BEQL	10$			; Yes, try again from [SYSEXE]
30$:

;
; File was not found. Report an error.
;

	CMPW	#SS$_NOSUCHDEV,R0	; "No such device" error?
	BNEQ	FILOPN_ERR		; Branch if not.
	BRW	NOSUCHDEV		; Report "no such device" error.

FILOPN_ERR:				; Report unknown error.
	ERROR	</%BOOT-F-Unable to locate BOOT file/>
					; Output error message.

;
; File was located successfully. Make sure that the file is contiguous.
; The file statistics block is the following:
;
;	+----------------------+
;	|     starting LBN     | (0 if file not contiguous)
;	+----------------------+
;	|    size in blocks    |
;	+----------------------+
;

	ASSUME	RPB$L_FILSIZ EQ RPB$L_FILLBN+4

FILE_CONTIG:				; Test for contiguity.
	MOVQ	RPB$L_FILLBN(R11),R8	; Get file statistics.
	TSTL	R8			; Contiguous file?
	BNEQ	READ_HEADER		; Yes, continue.
	ERROR	</%BOOT-F-Bootfile not contiguous/>
					; Output error message.

;
; If the software boot control flags indicate that that transfer
; address of the secondary bootstrap is stored in the image file's
; header block, read that header block. Otherwise, assume that the
; transfer address is simply the 1st byte in the image file.
;

READ_HEADER:				; Read header if necessary.
	CLRL	R5			; Assume no transfer address.
	BBC	#RPB$V_HEADER,-		; If no header requested,
		RPB$L_BOOTR5(R11),-	; then just branch past header
		READIN_BOOT		; reading code.
	MOVL	R10,R6			; Start of free memory
	MOVL	#1,R9			; Header is always only 1 block.
	BSBW	READFILE		; Read header block.
	MOVQ	RPB$L_FILLBN(R11),R8	; R8 = 1st LBN, R9 = block count
	MOVQ	R9,R2			; R2 = block count, R3 = hdr adr
	BSBW	BOO$IMAGE_ATT		; Get image attributes
;
; R1 = image header block count
; R2 = size of file in blocks excluding symbol table and patch text
;
	MOVL	R1,RPB$B_HDRPGCNT(R11)	; Store image header block count
	SUBL3	R1,R2,R9		; Blocks in image after header block(s)
	ADDL	R1,R8			; LBN of first block beyond headr block(s)
	MOVZWL	IHD$W_ACTIVOFF(R10),R1	; Get offset to image
					; activation data in header.
	ADDL	R10,R1			; Form transfer vector address.
	MOVL	(R1),R5			; Get transfer address.

;
; Now read in the file. If the file is too large for the remaining
; memory space, see if the required additional pages are usable.
; If they are, use them.  If not issue a fatal diagnostic and HALT.
;
; Registers set up now are the following:
;
;	R5	- transfer address
;	R8	- starting LBN of file (after header)
;	R9	- size of file in blocks
;	R10	- address of 1st byte in free memory
;	R11	- address of the RPB
;	AP	- secondary boot argument list
;

READIN_BOOT:

	BRW_PSECT READIN_BOOT_1

;
; The following code disables XDELTA and sets up to read the secondary
; bootstrap in over most of VMB.  The picture of memory is still
; preserved for backwards compatibility.  Only the size of the primary
; boot is smaller.
;

	MOVAL	OVERLAY_START,R7	; End of all drivers, page aligned
	MOVQ	RPB$Q_PFNMAP(R11),R0	; Descriptor for PFN bitmap
	MOVQ	R0,R2			; Save a copy
	ROTL	#9,#BITMAP_PAG_CNT,R1	; Max pre-allocated byte count
	CMPL	R0,R1			; Use the smaller for the
	BLEQ	20$			; backward compatible
	MOVL	R1,R0			; maximum 8mb bitmap
20$:	MOVAL	^X200(R7),R1		; backward compatible bitmap
	MOVQ	R0,RPB$Q_PFNMAP(R11)	; Store new descriptor for small bitmap
	CMPL	R3,SP			; If this is a large bitmap,
	BGTR	30$			; then it is above VMB
	MOVQ	R0,R2			; Otherwise use the new
30$:	MOVQ	R2,VMB$Q_PFNMAP(AP)	; descriptor of the small bitmap
	MOVAL	^X200(R0),R0		; Additional page of SCB to move
	PUSHL	R5			; Preserve this from MOVC
	INCL	MUST_HALT		; Disable restart from ERROUT
	MOVC3	R0,BOOTHIGH,(R7)	; Move the SCB and pre-allocated bitmap
	POPR	#^M<R5>			; Restore image start offset
	MOVAB	<STACK_PAG_CNT*^X200>(R3),SP ; Move stack adjacent to bitmap
	MOVL	SP,R10			; First free address above VMB
	MOVL	R10,R6			; Buffer for read

;
; Will the desired number of blocks fit in the space remaining in the
; pre-tested 64kb of memory?  If not, check that the additional pages
; required are usable.  If they are, then read it all, otherwise quit.
;

CHECK_BOOT_FIT:
	ROTL	#<32-9>,R11,R0		; PFN for RPB
	MOVAL	127(R0),R0		; Last PFN guaranteed to be good
	ROTL	#<32-9>,R10,R1		; Starting PFN for read
	ADDL	R9,R1			; Last+1 PFN needed to be good
	BRB	30$			; Zero or more iterations
10$:	BBC	R0,@VMB$Q_PFNMAP+4(AP),SECOND_TOO_BIG ; Branch if cannot
					; read the entire secondary boot
30$:	AOBLSS	R1,R0,10$		; Check the next page

;
; Disable XDELTA, no debugging from here on.  The following read will
; overwrite the XDELTA code.
;

	MOVAB	BOOT_FAULT+1,^X28(R7)	; Shut off XDELTA TBIT handler and
	MOVAB	BOOT_FAULT+1,^X2C(R7)	; BPT handler in new copy of SCB
	MTPR	R7,#PR$_SCBB		; Set new SCB address

;
; Now read the secondary boot code into memory
;

	BSBB	READFILE		; Read.

;
; The secondary bootstrap is now in memory. If the software boot control
; flags asked for a HALT before the secondary bootstrap gains control,
; execute a HALT instruction. Otherwise, transfer control to the new
; bootstrap image.
;

	BBC	#RPB$V_HALT,-		; If boot flags don't call for
		RPB$L_BOOTR5(R11),-	; halt, just transfer to new
		START_SECOND		; bootstrap image.
	HALT				; Otherwise, HALT.

START_SECOND:				; Transfer to secondary boot.
	JMP	(R5)[R10]		; Execute JUMP.

;
; Secondary bootstrap does not fit in the pre-tested 64kb and
; one or more of the required adjacent pages is not usable.
;

SECOND_TOO_BIG:
	ERROR	</%BOOT-F-Boot file too big/>


;
; No such device error reporting.
;

NOSUCHDEV:				; "No such device" I/O error.
	ERROR	</%BOOT-F-Nonexistent drive/>
					; Output error message.

	.SBTTL	READFILE, Reads bootstrap file in large chunks

;++
;
; Functional description:
;
;	Calls the device-independent bootstrap QIO routine to read
;	a file. Divides the file into pieces as large as possible, so
;	that the read is a small number (like 1) of DMA transfers.
;
; Inputs:
;
;	R6	- buffer address
;	R8	- logical block number (LBN)
;	R9	- number of blocks in file
;
; Implicit inputs:
;
;	IO_SIZE	- largest number of blocks possible in single transfer
;
; Outputs:
;
;	Registers R1-R4, and R5 must be preserved.
;
;	R6	- buffer address updated past last byte read
;	R8	- LBN updated to block after last block read
;	R9	- blocks in file (reduced to number not read)
;
; Implicit outputs:
;
;--

READFILE:				; Read file into memory.
	BSBB	READX			; Do the actual read
	BLBS	R0,10$			; Success
	CMPW	#SS$_NOSUCHDEV,R0	; "No such device" error?
	BEQL	NOSUCHDEV		; Branch if yes.
	ERROR	<\%BOOT-F-I/O error reading boot file\>
					; Output error message.
10$:	RSB

READX:
	MOVZBL	#IO_SIZE,R7		; Assume maximum transfer size.
	CMPL	R7,R9			; Minimize with file size.
	BLEQ	10$			; Branch if file larger than
					; maximum transfer size.
	MOVL	R9,R7			; Set to remaining file size.

10$:					; Push arguments for QIO.
	PUSHL	R11			; Push phony channel number.
	PUSHL	#0			; Physical read mode.
	PUSHL	#IO$_READLBLK		; Read logical block function.
	PUSHL	R8			; Starting LBN.
	ROTL	#9,R7,-(SP)		; Transfer size in bytes.
	PUSHL	R6			; Buffer address
	ADDL	4(SP),R6		; Update buffer address.
	ADDL	R7,R8			; Update LBN.
	CALLS	#6,BOO$QIO		; Call a bootstrap QIO routine.
	BLBS	R0,20$			; Continue on success.
	RSB

20$:					; Read more file if any left.
	SUBL	R7,R9			; Decrement blocks remaining.
	BGTR	READFILE		; Continue if not done.
	RSB				; Return to caller when done.

;
; Entry point for reading a single logical block from a device.  Needed
; by the RT file open routine.
;

	SET_PSECT <YFILEREAD,BYTE>

	.ENTRY	FIL$READ_LBN,^M<R6,R7,R8,R9>


	MOVL	8(AP),R6		; The buffer address
	MOVL	4(AP),R8		; The LBN to grab
	MOVL	#1,R9			; One block only
	BSBW	READX			; Do it
	RET				; Leave

	.SBTTL	CPU-specific Tables.

	SET_PSECT <YBTMEM,LONG>

;
; Map CPU identification codes to CPU-specific data tables.
;

CPU_CODES:				; CPU identification table.
	.WORD	0			; Code 0 is not valid.
	CPU_IDENT-			; Identify 11/780 (code 1).
		LABEL=CPU_CODES,-	; Name of table.
		TABLE=780		; Table address.

	CPU_IDENT,-			; Identify 11/750 (code 2).
		LABEL=CPU_CODES,-	; Name of table.
		TABLE=750		; Table address.

	CPU_IDENT,-			; Identify 11/730 (code 3)
		LABEL=CPU_CODES,-	; Name of table.
		TABLE=730		; Table address

	CPU_IDENT,-			; Identify 11/790 (code 4)
		LABEL=CPU_CODES,-	; Name of table
		TABLE=790		; Table address

	CPU_IDENT,-			; Identify 11/8SS (code 5)
		LABEL=CPU_CODES,-	; Name of table
		TABLE=8SS		; Table address

;
; Tables of CPU-specific information.
;

	CPU_DEF	LABEL=780		; 11/780 CPU-specific table.

	CPU_DEF	LABEL=750		; 11/750 CPU-specific table.

	CPU_DEF	LABEL=730		; 11/730 CPU-specific table.

	CPU_DEF	LABEL=790		; 11/790 CPU-specific table

	CPU_DEF	LABEL=8SS		; 11/8SS CPU-specific table

;
; Tables of cpu-specific time-wait data cells values.
;

TENUSECTBL:				; Ten micro-second loop counter
	.BYTE	4			;   11/780 and 11/785 value
	.BYTE	1			;   11/750 value
	.BYTE	1			;   11/730 value
	.BYTE	2			;   11/790 value
	.BYTE	5			;   11/8SS value pulled from a hat

UBDELAY:				; Unibus delay loop counter
	.BYTE	4			;   11/780 and 11/785 value
	.BYTE	1			;   11/750 value
	.BYTE	1			;   11/730 value
	.BYTE	2			;   11/790 value
	.BYTE	5			;   11/8SS value pulled from a hat

	.SBTTL	Test memory

;++
;
; Functional description:
;
;	This routine tests a given range of PFN's and builds one or
;	more bitmap pages.  Each bitmap page address is recorded in
;	the corresponding long word in the bitmap page address array.
;
; Calling Sequence:
;
;	JSB	BOO$TEST_MEM
;
; Inputs:
;
;	R2 = address of page test routine
;	R3 = number of pages to test
;	R9 = starting page number
;	R11 = address of Restart Parameter Block
;	BITMAP_VEC_PTR - contains the base address of the bitmap
;		page address array.
;	SECOND_PARAM - is the address of the Secondary Boot parameter
;		list.  The lowest and highest PFN's seen are to be
;		recorded here.
;
; Outputs:
;
;	R0,R1,R2,R3,R6,R9 altered
;	others preserved
;
;	Store address of newly allocated bitmap page(s) in the vector
;		pointed to by BITMAP_VEC_PTR and indexed by the
;		high 9 bits of the PFN's covered by the bitmap page.
;	Record the lowest (inclusive) and highest (exclusive) PFN's 
;		seen in the offsets VMB$L_LO_PFN and VMB$L_HI_PFN
;		of the Secondary Boot Parameter list (SECOND_PARAM).
;	Record the highest bitmap page index used in the vector of
;		bitmap page addresses (BITMAP_HI_INDX).
;
;--

;
; Scratch storage offset definitions
;
	$OFFSET	0,NEGATIVE,<-
	NXT_PFN,-		; Starting PFN for next segment of bitmap
	NXT_PAGCNT,-		; Page count remaining
	PRETST_PFN,-		; Pre-tested starting PFN
	PRETST_CNT,-		; Pre-tested page count
	PAGTST,-		; Address of page test routine
	<SCRATCH_SIZE,0>-	; Size of scratch area
	>

BOO$TEST_MEM::
	PUSHR	#^M<R4,R5,R7,R8,R10,FP,AP>
	MOVAL	SECOND_PARAM,AP		; Point at Secondary Boot Parameter list
	MOVL	SP,FP			; Use FP as a local pointer
	SUBL	#-SCRATCH_SIZE,SP	; Reserve local storage
	ROTL	#<32-9>,R11,PRETST_PFN(FP) ; Set start of pre-tested pages
	ROTL	#7,#1,PRETST_CNT(FP)	; 128 pre-tested pages
	MOVL	R2,PAGTST(FP)		; Save address of page test routine
	ADDL3	R3,R9,R0		; Last + 1 PFN
	CMPL	R0,VMB$L_HI_PFN(AP)	; Higher than last highest?
	BLEQ	10$			; Branch if not
	MOVL	R0,VMB$L_HI_PFN(AP)	; Yes, record the highest value
10$:	CMPL	R9,VMB$L_LO_PFN(AP)	; Is the starting PFN smaller than
					; the currently recorded smallest?
	BGEQ	20$			; Branch if not
	MOVL	R9,VMB$L_LO_PFN(AP)	; Yes, record the smallest one seen
20$:
NEXT_BITMAP:
	EXTZV	#0,#12,R9,R2		; No. of pages from beginning
					; of bitmap page (4096 bits/page)
	ADDL	R2,R3			; Page count is larger by that amount
	MOVL	R3,R1			; Save this page count
	ROTL	#12,#1,R0		; Max of 4096 pages per bitmap page
	CMPL	R3,R0			; More than a bitmap's worth?
	BLEQ	10$			; Branch if not
	MOVL	R0,R3			; Yes, use the max
10$:	SUBL3	R3,R1,NXT_PAGCNT(FP)	; No. of pages left for next iteration
	SUBL	R2,R3			; Actual no. of pages to test
	ADDL	R9,R3			; Last + 1 PFN to be tested
	MOVL	R3,NXT_PFN(FP)		; Save for next iteration if any
	ASHL	#-12,R9,R10		; Index to bitmap page address array
	CMPL	R10,BITMAP_HI_INDX	; Is this the highest index seen?
	BLEQ	20$			; Branch if not
	MOVL	R10,BITMAP_HI_INDX	; Keep track of the highest index
20$:	MCOML	#0,R6			; Bitmap page address not set yet
	BBS	#RPB$V_NOTEST,RPB$L_BOOTR5(R11),- ; If not testing memory
		INIT_BITMAP		; then fill in bit map as all good

;
; Test each page for gross errors unless RPB$V_NOTEST is set. For each
; page available and good (if tested), set the corresponding bit in
; the PFN bitmap.
;

MEM_LOOP:				; Test one controller's worth.
	CMPL	R9,PRETST_PFN(FP)	; Is this a the next pre-tested page?
	BNEQ	TEST_PAGE		; Branch if not, go test it

;
; Just handle these pre-tested pages one at a time.  There are only
; 128 of them, and handling them as a unit means they are restricted 
; to being in the same bitmap segment.  It is required that they be
; in one controller, but this further breakdown into 4096 page units
; which fit into a one page bitmap is artificial.
;

	INCL	PRETST_PFN(FP)		; Yes, step to next PFN
	SOBGTR	PRETST_CNT(FP),GOOD_PAGE ; Count these pages
					; Treat it as good, don't retest
	MCOML	#0,PRETST_PFN(FP)	; No, more pre-tested pages left
	BRB	GOOD_PAGE		; Last pre-tested page is good too
TEST_PAGE:
	ASHL	#9,R9,R0		; Convert page # to physical address
	ROTL	#6,#1,R1		; Loop counter for 64 quadwords.
	JSB	@PAGTST(FP)		; Test this page
GOOD_PAGE:				; Good page here.
	TSTL	R6			; Is the bitmap set up yet?
	BLSS	INIT_BITMAP		; Branch if no, must init one
COUNT_PAGE:
	BBSS	R9,(R6),NEXT_PAGE	; Set bit in bitmap; do next page
	INCL	RPB$L_PFNCNT(R11)	; Increment good page count.

;
; If more pages remain in this bitmap segment, continue looping.
;

NEXT_PAGE:				; Do next page, if any.
	AOBLSS	R3,R9,MEM_LOOP	; Process next page if any
CHK_NEXT_BITMAP:
	MOVL	NXT_PFN(FP),R9		; Starting PFN for next bitmap segment
	MOVL	NXT_PAGCNT(FP),R3	; Another bitmap segment to do?
	BNEQ	NEXT_BITMAP		; Branch if yes
	MOVL	FP,SP			; Clean off local storage
	POPR	#^M<R4,R5,R7,R8,R10,FP,AP> ; Recover saved registers
	RSB				; and return
;
; Handler that gains control when a page has gross memory errors.
; Entered via a BRW from the actual machine specific handler after it
; has done the machine specific thing necessary to clear the condition
;

BOO$PAGE_MCHECK::			; Skip current page.
	SUBL3	#-SCRATCH_SIZE,FP,SP	; Restore stack pointer.
	INCL	RPB$L_BADPGS(R11)	; Count number of bad pages found.
	BRB	NEXT_PAGE		; And get the next page
;
; Allocate and initialize a page of bitmap for this bitmap segment
;
INIT_BITMAP:
	MOVL	@BITMAP_VEC_PTR[R10],R6 ; Is bitmap page allocated?
	BGEQ	GOT_BITMAP		; Branch if yes
	ADDL3	R10,BITMAP_BAS_PFN,R2	; Desired PFN for this bitmap page
	EXTZV	#0,#12,R2,R0		; Bitmap page relative PFN
	EXTZV	#12,#9,R2,R1		; Index to bitmap page
	MOVL	@BITMAP_VEC_PTR[R1],R1	; Address of bitmap page
	BLSS	20$			; Branch if entire bitmap page not there
	BBC	R0,(R1),20$		; Branch if desired page was bad
					; or not yet tested
	ASHL	#9,R2,R6		; Form bitmap adr from PFN
	BRB	30$
20$:	ASHL	#9,R9,R6		; Use first good page mapped by this
					; bitmap to hold this bitmap page
30$:	PUSHL	R3			; Save last PFN to be tested
	MOVC5	#0,(R6),#0,#512,(R6)	; Init all PFN's bad
	POPR	#^M<R3>			; Restore last PFN to be tested
	MOVL	R6,@BITMAP_VEC_PTR[R10] ; Record adr of bitmap page
GOT_BITMAP:
	ASHL	#-3,R9,R0		; Form byte offset from the beginning
	BICW	#^X1FF,R0		; of the bitmap to PFN 0
	SUBL	R0,R6			; so that BBSS PFN,(R6) will work
	BBC	#RPB$V_NOTEST,RPB$L_BOOTR5(R11),- ; Branch if testing memory
		COUNT_PAGE
;
; Set bits for pages which are not to be tested, but assumed good.
;
	SUBL3	R9,R3,R2		; Count of pages to mark good
	ADDL	R2,RPB$L_PFNCNT(R11)	; Add them in as good pages
	MOVL	#32,R0			; Set 32 bits per iteration
	BICL3	#31,R2,R1		; Even no. of longwords worth
	MOVAB	-(R1)[R9],R1		; R1=R1-1+R9 = last PFN inclusive
					; for 32 at a time loop
20$:	INSV	#-1,R9,R0,(R6)		; Mark these pages good
	ACBL	R1,R0,R9,20$		; R9=R9+R0, If R9 LEQ R1 then GOTO 20$
	EXTZV	#0,#5,R2,R0		; No. of bits remaining to be set
	BEQL	30$			; Branch if all bits are set
	CLRL	R2			; Stop the next time around
	BRB	20$			; Set the remaining bits
30$:	BRW	CHK_NEXT_BITMAP

	.SBTTL	SAVE_CSRS, CPU-specific routines

;++
;
; Functional description:
;
;	One routine per CPU implementation follows. Each routine
;	determines from input registers the addresses of the boot
;	device's CSR and the attached adapter's CSR, and stores these
;	addresses in the RPB.
;
; Inputs:
;
;	R1	- address of the boot device's adapter
;
;			11/780	- <31:4> MBZ
;				  <3:0> TR number
;			11/750	- <31:24> MBZ
;				  <23:0> address of the I/O page for the
;					 boot device's adapter
;
;	R2	- UNIBUS:
;
;			<31:18> MBZ
;			<17:3> UNIBUS address of the device's CSR
;			<2:0> MBZ
;
;	R2	- MASSBUS or CI:
;
;			not used
;
;	R11	- address of the Restart Parameter Block
;
; Implicit inputs:
;
;	The boot device may be located on any UNIBUS, MASSBUS, or CI  adapter.
;
; Outputs:
;
;	R8, R11, and SP must be preserved.
;
; Implicit outputs:
;
;	The RPB fields RPB$L_ADPPHY and RPB$L_CSRPHY contain the
;	addresses of the adapter's register space and the boot device's
;	register space respectively. For CI or MASSBUS devices, these values
;	are identical.
;
;--

	.SBTTL	SAVE_CSR_780, Save CSRs for 11/780
	.SBTTL	SAVE_CSR_730, Save CSRs for 11/730
	.SBTTL	SAVE_CSR_790, Save CSRs for 11/790

;++
;
; SAVE_CSR_780, Save CSRs for 11/780
; SAVE_CSR_730, Save CSRs for 11/730
; SAVE_CSR_790, Save CSRs for 11/790
;
; Implicit inputs:
;
;	R1 contains the system bus address in the form of a TR number
;	because TR numbers map to fixed physical addresses.
;
;	Bus adapters on the 780 start at address IO780$AL_IOBASE for TR 0,
;	and increment by ^X2000 each subsequent adapter. UNIBUS address
;	space for the first UNIBUS in the configuration starts at
;	IO780$AL_UB0SP. The second through fourth UNIBUS start 64kb after
;	the previous UNIBUS. UNIBUS device CSRs are in the last 64kb of
;	the UNIBUS address space.
;
;	The I/O space layout for the 11/730 is the same as that
;	described above for the 11/780 except that the base of
;	TR 0 register space is IO730$AL_IOBASE and UNIBUS 0 space
;	starts at IO730$AL_UB0SP.  Also, only one UNIBUS will ever
;	be configured on an 11/730.
;
;	The I/O space on the 11/790 allows for multiple (2) SBIA's.
;	The offsets for NEXUS within an SBI are the same as on the 11/780.
;	For the 11/790, R1 can have a value from 1 to 16, with bits 4 and 5
;	indicating which A-bus adapter hosts the system bus.
;
; Outputs:
;
;	R5-R11 and AP-SP are preserved.
;
;--

SAVE_CSR_780:				; Save CSRs for the 11/780
	MOVAL	@#IO780$AL_IOBASE,R3	; Get adapter 0 space.
	MOVAL	@#IO780$AL_UB0SP,R4	; Get UB 0 space
	BRB	SAVE_CSR_COMMON		; Join common code

SAVE_CSR_730:				; Save CSRs for the 11/730.
	MOVAL	@#IO730$AL_IOBASE,R3	; Get adapter 0 space
	MOVAL	@#IO730$AL_UB0SP,R4	; Get UB0 space
	BRB	SAVE_CSR_COMMON		; Join common code

SAVE_CSR_790:
	MOVAL	@#IO790$AL_IOA0,R3	; Assume start of 1st SBIA
	EXTZV	#RPB$V_ABUS,#RPB$S_ABUS,R1,R4	; Get A-bus adapter number
	INSV	R4,#25,#RPB$S_ABUS,R3	; Insert to make physical address ********
	MOVAL	IO790$AL_UB0SP(R3),R4	; Get UB 0 space for this SBIA
	EXTZV	#RPB$V_NEXUS,#RPB$S_NEXUS,R1,R1	; Extract nexus number


SAVE_CSR_COMMON:			; Common code from here on

;
; Compute and save adapter configuration register address:
;

	ROTL	#13,R1,R0		; Convert TR # to adapter
	ADDL	R3,R0			; configuration address
	MOVL	R0,RPB$L_ADPPHY(R11)	; Store in RPB
	MOVL	R0,RPB$L_CSRPHY(R11)	; Store in device CSR too in
					; case this is a MASSBUS or CI device.

;
; Read the configuration register to determine whether the adapter is
; for a UNIBUS, MASSBUS, or CI. Bits <31:3> of the configuration register
; identify the adapter type.
;

	MOVL	(R0),R3			; Read the adapter's CR.
	MOVZBW	R3,RPB$W_BOOTNDT(R11)	; Save boot adapter's nexus device type.
	BICL3	#3,R3,R0		; Clear the bits representing
					; a UBA number to obtain the
					; canonical adapter type.
	CMPB	#NDT$_UB0,R0		; Is this a UNIBUS adapter?
	BEQL	UBA_ADAPTER		; Yes. Go compute device's CSR.
	RSB				; RPB$L_CSRPHY already set for 
					; MASSBUS or CI, so return.

UBA_ADAPTER:				; Compute UNIBUS device's CSR.
	BISL3	R4,R2,-			; Add UNIBUS CSR value to
		RPB$L_CSRPHY(R11)	; base of all UNIBUS address
					; space.
	CLRL	R0			; Get start of this ub space
	INSV	R3,#18,#2,R0		; relative to UB0 space.
	ADDL	R0,RPB$L_CSRPHY(R11)	; Adjust CSR address to this UB space.
	RSB				; Return.

	.SBTTL	SAVE_CSR_750, Save CSRs for 11/750

;
;*****
; Add code to accept a slot number between 0 and 15 in R1.
;*****
;

;++
;
; SAVE_CSR_750, Save CSRs for 11/750
;
; Implicit inputs:
;
;	For a MASSBUS boot device, R1 contains a 24-bit address of the
;	MASSBUS adapter's address space. The MBAs start at fixed
;	addresses that correspond to NEXUS slots 20-23:
;
;		MBA0	^XF28000, slot 20	IO750$AL_MBBASE
;		MBA1	^XF2A000, slot 21	IO750$AL_MBBASE+^X2000
;		MBA2	^XF2C000, slot 22	IO750$AL_MBBASE+^X4000
;		MBA3	^XF2E000, slot 23	IO750$AL_MBBASE+^X6000
;
; 	For a UNIBUS boot device, R1 contains a 24-bit address of the
;	boot device UNIBUS' I/O page. The I/O pages start at fixed
;	addresses that correspond to UNIBUS adapters also at fixed
;	addresses that correspond to NEXUS slots 24-25:
;
;		UNIBUS 0 I/O page	^XFFE000,
;		  IO750$AL_UBBASE, UBI0	^XF30000, slot 24
;
;		UNIBUS 1 I/O page	^XFBE000,
;		  IO750$AL_UBBASE+^X2000,
;		  		   UBI1	^XF32000, slot 25
;
;	UNIBUS address space:
;
;		UBI0	^XFC0000:^XFFFFFF	IO750$AL_UB0SP
;		UBI1	^XF80000:^XFBFFFF	IO750$AL_UB0SP+^X40000
;
;	For a boot device in the floating space, R1 contains a 24-bit
;	address of the adapter's address space. The floating adapters
;	start at the CMI address that correspond to NEXUS slots 26-31:
;
;		float_A	^XF34000, slot 26	IO750$AL_FLOAT
;		...
;		float_F	^XF3E000, slot 31	IO750$AL_FLOAT+^XA000
;
;	The routine reduces the adapter's physical address to a slot
;	number from 0-15, and stores the number in the RPB for later
;	use by INIT.
;
; Outputs:
;
;	R1-R11 and AP-SP are preserved.
;
; Implicit outputs:
;
;	This routine derives the slot number (less 16) for the boot
;	device's adapter and loads the number into RPB$L_BOOTR1. Later
;	INIT uses the value in RPB$L_BOOTR1 as an index into the RPB
;	CONFREG field to find the adapter type of the boot device.
;
;--

SAVE_CSR_750:				; Save CSRs for the 11/750.
	CMPL	R1,#IO750$AL_FLOAT+ -
		 <6*IO750$AL_PERNEX>	; Is this adapter in the float space?
	BGEQU	10$			; No, must be MASSBUS or UNIBUS
	CMPL	R1,#IO750$AL_FLOAT	; Is this adapter in the float space?
	BLSSU	10$			; No, must be MASSBUS or UNIBUS
;
; Read the configuration register to determine the adapter. Bits <31:3> of
; the configuration register identify the adapter type.
;
	MOVL	(R1),R3			; Read the adapter's CR.
	MOVZBW	R3,RPB$W_BOOTNDT(R11)	; Save boot adapter's nexus device type.
	BRB	20$			; Continue in common code
	
10$:	CMPL	R1,#IO750$AL_UBBASE	; Is this a MASSBUS adapter?
	BGEQU	DERIVE_UBIADDR		; No. Go derive UBI address.
	MOVZBW	#NDT$_MB, -		; Save boot adapter's nexus device
		RPB$W_BOOTNDT(R11)	; type.
20$:	MOVL	R1,RPB$L_ADPPHY(R11)	; Yes, store MBA's CR in RPB.
	MOVL	R1,RPB$L_CSRPHY(R11)	; And store in RPB$L_CSRPHY too.
	BRB	DERIVE_SLOTNUM		; Branch to derive slot number.

DERIVE_UBIADDR:				; Reduce R1 to UBI address.
	CMPL	R1,#IO750$AL_UB0SP	; Is this UNIBUS 1 or UNIBUS 0?
	BGTRU	10$			; UNIBUS 0. Go load addresses.
	MOVZBW	#NDT$_UB1, -		; Save boot adapter's nexus device
		RPB$W_BOOTNDT(R11)	; type.
	ADDL3	#IO750$AL_UBBASE,-	; UNIBUS 1. Load the ADPPHY
		#IO750$AL_PERNEX,-	; field with UBI1 address.
		RPB$L_ADPPHY(R11)
	BISL3	#<IO750$AL_UB0SP-	; Create and store away the
		-^X40000+^O760000>,R2,-	; boot device's CSR address.
		RPB$L_CSRPHY(R11)
	BRB	GET_UBI_ADDR		; Branch to common UBI code.

10$:					; UNIBUS 0. Load addresses.
	MOVZBW	#NDT$_UB0, -		; Save boot adapter's nexus device
		RPB$W_BOOTNDT(R11)	; type.
	MOVL	#IO750$AL_UBBASE,-	; Store address of 1st UNIBUS
		RPB$L_ADPPHY(R11)	; adapter.
	BISL3	#<IO750$AL_UB0SP-	; Calculate and load the full
		+^O760000>,R2,-		; CSR address into RPB.
		RPB$L_CSRPHY(R11)

GET_UBI_ADDR:				; Obtain UBI address.
	MOVL	RPB$L_ADPPHY(R11),R1	; Get address of associated UBI.

DERIVE_SLOTNUM:				; Derive and save slot number.
	SUBL3	#IO750$AL_IOBASE,R1,R0	; Get adapter's offset from base
					; of I/O space.
	DIVL	#IO750$AL_PERNEX,R0	; Divide by size of one adapter.
	MOVL	R0,RPB$L_BOOTR1(R11)	; Save the slot number.
	RSB				; Return to caller.

	.SBTTL	SAVE_CSR_8SS, Save CSRs for 11/8SS

;+
;
; SAVE_CSR_8SS, Save CSRs for 11/8SS
;
; Inputs:
;
;	R1  =  BI node number for Boot device's adapter
;	R2  =  BI address of Boot device's CSR if booting on BUA
;	R11 => RPB
;
; Implicit inputs:
;
;	The BI physical address space is as follows:
;
;		I/O space begins at ^x20000000 - symbolically IO8SS$AL_IOBASE
;
;		Each node has an 8KB register space.  The first node
;		register space begins at IO8SS$AL_IOBASE, and the next
;		one begins at an 8KB offset from it, and the next 8KB, etc.
;
;		Each node has a 256KB node space reserved for it.  These
;		node spaces begin at physical address ^x20400000 -
;		symbolically this is IO8SS$AL_NODESP.  The node space
;		for node 0 begins at this physical address and the
;		subsequent ones begin at 256KB intervals.
;
; Outputs:
;
;	Registers R0 - R3 modified.  All others preserved.
;
;-


SAVE_CSR_8SS:

	ASHL	#13,R1,R0		; Multiply node # by 8K so that
					;  R0 contains the offset, into I/O
					;  space for this node's register space.

	ADDL	#IO8SS$AL_IOBASE,R0	; R0 => Node's register space.
	MOVL	R0,RPB$L_ADPPHY(R11)	; Store in RPB.

	MOVL	(R0),R3			; Read node Device type register.
	CMPW	#<NDT$_BUA&^xFFFF>,R3	; See if a UNIBUS adapter. NOTE
					;  anding with ^xFFFF is to avoid
					;  truncation warning from assembler.
	BNEQ	10$			; If NOT, branch around.
	MOVL	R2,R0			; If UNIBUS device, R0 => CSR.
10$:
	MOVL	R0,RPB$L_CSRPHY(R11)	; Save address of CSR in RPB.
	RSB

	.SBTTL	INIT_ADAP, CPU-specific adapter initialization routine

;++
;
; Functional description:
;
;	One routine per CPU implementation follows. Each routine
;	initializes the adapter for the boot device, if the adapter
;	requires such an initialization.
;
; Inputs:
;
;	R0	- physical address of the adapter
;	R1-R6	- scratch
;	R7	- address of the SCB
;	R8	- address of the CPU-specific table
;	R9	- scratch
;	R10	- address of the 1st unused byte of good memory
;	R11	- address of the RPB
;
; Implicit inputs:
;
;	If the value in R0 is identical to the value in RPB$L_CSRPHY,
;	the adapter is for a UNIBUS. Otherwise, the adapter is for a
;	MASSBUS.
;
; Outputs:
;
;	R7-R8, R10-R11, and SP must be preserved.
;
; Implicit outputs:
;
;	The boot device's adapter is initialized.
;
;--

	.SBTTL	INIT_ADP_780, Initialize 11/780 boot device adapter
	.SBTTL	INIT_ADP_790, Initialize 11/790 boot device adapter

;++
;
; INIT_ADP_780, Initialize boot device adapter on the 11/780
; INIT_ADP_790, Initialize boot device adapter on the 11/790
;
; Implicit inputs:
;
;	Both the UNIBUS and MASSBUS adapters must be initialized for
;	the 11/780 and the 11/790.  The initialization bit is in the same position
;	in both the UNIBUS and MASSBUS adapter configuration register.
;
;	This routine sets the initialization bit in the CR; then loops
;	to wait for initialization completion for the UNIBUS; assumes
;	immediate completion for the MASSBUS.
;
;--

INIT_ADP_780:				; Initialize 11/780 adapters.
	MOVAL	W^MCHK_780,R5		; Get address of 780 mcheck handler.
	BRB	INIT_ADP_COMMON		; Go to common code.

INIT_ADP_790:
	MOVAL	W^MCHK_790,R5		; Get address of 790 mcheck handler.

INIT_ADP_COMMON:
	MOVL	#MBA$M_CR_INIT,-	; Set the initialize bit. Bit
		MBA$L_CR(R0)		; # is same for MBA and UBA.
	CMPL	R0,RPB$L_CSRPHY(R11)	; Is ADP CSR address = device
					; CSR address?
	BNEQU	WAIT_UBA		; No. This is a UBA.
	RSB				; Yes. MBA. Return, no wait.

;
; For a UNIBUS adapter, must wait for a CSR bit to be written by the
; adapter before knowing that initialization is complete.
;

WAIT_UBA:				; Wait for the UBA.
	.ENABLE LSB
	BITL	#UBA$M_CSR_UBIC,-	; Did the adapter set the init
		UBA$L_CSR(R0)		; complete bit?
	BEQL	WAIT_UBA		; No, wait longer.

;
; Now check for any UNIBUS memory that may be on the adapter. If found
; disable the corresponding map registers.
;

	PUSHL	4(R7)			; Save machine check vector
	MOVL	R5,4(R7)		; Replace with a temporary
	MOVL	SP,R6			; Save stack pointer
	BICL3	#^X0003FFFF,-
		RPB$L_CSRPHY(R11),R1	; Get the start of UNIBUS space
	MOVL	R1,R2			; Copy
	MOVAB	^X3C000(R2),R3		; Last 8KB of memory
	MOVL	#^X7C000000,UBA$L_CR(R0); Disable all UNIBUS map regs
10$:	TSTW	(R2)			; See if anything responds
	MOVL	UBA$L_SR(R0),UBA$L_SR(R0) ; Clear and read status
	BNEQ	20$			; Nothing there, try higher
15$:	CMPL	R1,R2			; Found memory, first time in?
	BEQL	17$			; Yes, skip next test
	TSTL	BOO$GL_UMR_DIS		; Any registers already disabled?
	BEQL	UNI_MEM_ERR		; No, memory not start at 0
17$:	ADDL2	#16,BOO$GL_UMR_DIS	; Up the count of registers to disable
20$:	ACBL	R3,#^X2000,R2,10$	; Continue thru the entire space
	ASHL	#22,BOO$GL_UMR_DIS,-	; Div by 16 and shift left 26 bits
		UBA$L_CR(R0)		; Disable the UMR's
	POPL	4(R7)			; Restore machine check vector
	RSB				; Initialization complete.

	.ALIGN	LONG
MCHK_780:
	MFPR	#PR$_SBIFS,R4		; Get SBI fault status register
	BBCC	#25,R4,25$		; Clear "error 1st pass" bit
25$:	MTPR	R4,#PR$_SBIFS		; Write back to clear SBI fault
	MOVL	4(SP),R4		; Pick up summary parameter
	MOVL	R6,SP			; Clear off frame
	CMPB	R4,#5			; Is it Read Data Substitute?
	BEQL	15$			; Yes, then it is a read w/bad parity
	BRB	20$			; No, its nonexitent

	.ALIGN	LONG
MCHK_790:
	MFPR	#PR$_EHSR,R4		; Get error handling status register.
	BBCC	#EHSR$V_VMS,R4,30$	; Clear "VMS entered" bit.
30$:	MTPR	R4,#PR$_EHSR		; Write back to clear machine check.
	MOVL	MCF790$L_MSTAT2(SP),R4	; Pick up memory status register.
	MOVL	R6,SP			; Clear mcheck frame off stack.
	BBS	#MSTAT2$V_IOBUFF,R4,20$	; Branch if NXM => no Unibus memory.
	BRB	15$			; Ignore any other error.
	.DISABLE LSB

UNI_MEM_ERR:
	ERROR	</%BOOT-F-UNIBUS memory does not start at 0/>

	.SBTTL	INIT_ADP_750, Initialize boot device 11/750 adapter
	.SBTTL	INIT_ADP_730, Initialize boot device 11/730 adapter

;++
;
; INIT_ADP_750, Initialize boot device adapter on the 11/750
; INIT_ADP_730, Initialize boot device adapter on the 11/730
;
; Implicit inputs:
;
;	The massbus is initialized by setting the init bit in the 
;	MBA adapter control register.  The unibus is initialized by
;	setting the UB reset IPR.  (On the 11/730 the adapter of
;	the boot device will always be a unibus.)
;
;--
	MCK_BER = ^X24			; Offset into machine check frame
					;  for Bus Error Register
	NEX	= 3			; Bit position for non-existent mem
	STEP	= ^X800			; Granularity of the step in memory
					;  probe algorithm

INIT_ADP_750:				; Initialize 11/750 adapters.
INIT_ADP_730:				; Initialize the 11/730 adapters.
	.ENABLE LSB
	CMPL	R0,RPB$L_CSRPHY(R11)	; Is ADP CSR addr = device CSR addr?
	BNEQ	10$			; No, must be UNIBUS
	MOVL	#MBA$M_CR_INIT,-	; Set the initialize bit
		MBA$L_CR(R0)		;
	RSB				; Done

10$:	MTPR	#0,#PR$_UBRESET		; Reset the UNIBUS adapter.

;
; Now check for any UNIBUS memory that may be on the adapter. If found
; disable the corresponding map registers.
;

	MOVZWL	#496,R1			; Pick up number to disable
	MOVAL	UBA$L_MAP(R0),R2	; Address of first
20$:	CLRL	(R2)+			; Invalidate it
	SOBGTR	R1,20$			; Loop until done
	PUSHL	4(R7)			; Save machine check vector
	MOVAL	B^MCHK_750,4(R7)	; Replace with a temporary
	MOVL	SP,R6			; Save stack pointer
	BICL3	#^X0003FFFF,-
		RPB$L_CSRPHY(R11),R1	; Get the start of UNIBUS space
	MOVL	R1,R2			; Copy
	MOVAB	-STEP(R1),LAST_MEM	; Initialize cell
	MOVAB	^X3C000(R2),R3		; Last 8KB of memory
30$:	TSTW	(R2)			; See if anything responds
40$:	CMPL	R1,R2			; First time in?
	BEQL	45$			; Yes, skip next test
	TSTL	BOO$GL_UMR_DIS		; Any registers already disabled?
	BEQL	55$			; No, memory not start at 0
	BLBS	MEM_FLAG,55$		; Yes, now the far side of a hole
	MOVL	R2,LAST_MEM		; Update counter
45$:	ADDL2	#STEP/512,BOO$GL_UMR_DIS; Up the count of registers to disable
50$:	ACBL	R3,#STEP,R2,30$		; Continue thru the entire space
55$:	SUBL2	LAST_MEM,R2		; Find size of hole
;
; NOTE:	This test is based on the fact that the bootdriver will only
;	allow a maximum of 127 pages in a single IO.  If that assumption
;	changes, this test will have to change.
;
	CMPL	R2,#<128*512>+STEP	; Is it big enough?
	BLSSU	TOO_MEM_ERR		; No, give error		
	POPL	4(R7)			; Restore old machine check handler
	RSB				; Done

	.ALIGN	LONG
MCHK_750:				; Temporary machine check handler
	MTPR	#^XF,#PR$_MCESR		; Reset machine check
	MOVL	#<1@NEX>,R4		; Set up
	CMPL	(SP),#^X0C		; Is this a 730 frame?
	BEQL	60$			; Yes, no further check
	MOVL	MCK_BER(SP),R4		; Save Bus error register
60$:	MOVL	R6,SP			; Clear machine check stack frame
	BBC	#NEX,R4,40$		; Branch if parity error on Umem
	MOVL	#1,MEM_FLAG		; Else non-existent memory, set flag
	BRB	50$			; Continue in line
	.DISABLE LSB			;

TOO_MEM_ERR:
	ERROR	</%BOOT-F-Too much UNIBUS memory/>

	.SBTTL	INIT_ADP_8SS, Initialize boot device 11/8SS adapter

;++
;
; INIT_ADP_8SS, Initialize boot device adapter on the 11/8SS
;
; Implicit inputs:
;
;
;--

INIT_ADP_8SS:				; Initialize 11/8SS adapters.

	ASHL	#1,RPB$L_BOOTR1(R11),R1	; R1 = 1 in bit position corresponding
					;  to Adapter BI Node.
	MTPR	R1,#PR8SS$_BIINIT	; Send BI INIT command to this node.
	CMPL	R0,RPB$L_CSRPHY(R11)	; See if a BUA.
	BEQL	10$			; EQL implies NO.
10$:
	RSB				; Return to caller.

	.SBTTL	OPEN_UCODE_FILE, Find and open a ucode file on console

;++
;
; Functional description:
;
;	This routine contains code common to all file opens for any file
;	on the console.  It also handles errors.
;
; Inputs:
;
;	R2	Boot device type
;	R3	Address of vector of address
;
; Outputs:
;
;	R0	Status
;
;--

OPEN_UCODE_FILE:
	MOVL	(R3)+,UCODE_NAME	; Set the error name
	ADDL3	R3,(R3)+,R1		; Pick up name for ucode file
	MOVZBL	(R1)+,R0		; Size to R0
	MOVQ	R0,-(SP)		; Form descriptor
	ADDL3	R3,(R3)+,-(SP)		; Temp area for the stat block
	PUSHL	R10			; Start of memory buffer area
	PUSHAQ	8(SP)			; File descriptor
	CALLS	#5,RTF$OPENFILE		; Look it up on the console medium
	BLBS	R0,40$			; Success, try to read it in
	BLBS	(R3),10$		; If set, all errors fatal
	CMPB	#BTD$K_HSCCI,R2		; Booting off the CI?
	BNEQ	20$			; No, leave severity
10$:	MOVB	#^A/F/,UCODE_SEVER	; Yes, change to FATAL
20$:	CLRQ	-(SP)			; Null input buffer descriptor
	PUSHAB	UCODE_FAIL		; Error text
	CALLS	#3,BOO$READPROMPT	; Report the problem
	BLBS	(R3),30$		; If set, all errors fatal
	CLRL	R0			; Set possible return indicator
	CMPB	#BTD$K_HSCCI,R2		; Booting off the CI?
	BNEQ	40$			; No, finish the boot anyway
30$:	HALT				; Yes, **** FATAL ERROR ****

40$:	RSB

	.SBTTL	FIND_CI, CPU-specific routine to locate CI port

;++
;
; Functional description:
;
;	One routine per CPU implementation follows. Each routine
;	attempts to locate a CI port on the CPU.
;
; Inputs:
;
;	R7	Address of SCB
;
; Implicit inputs:
;
;	11/780 and 11/750:	RPB$B_CONFREG array
;	11/730:			No CI implementation exists for the 11/730
;	11/790:			Knowledge of I/O space layout
;
; Outputs:
;
;	CC = EQL means no CI on the system; CC = NEQ means CI present.
;	R0,R1 destroyed,
;	All other registers preserved.
;
;--

;
; For the 11/780 and 11/750, the size and test memory routines have set
; up an array in the RPB that contains the type code of each adapter on
; the system.  Search that array for a CI adapter type code.
;
FIND_CI_780:
FIND_CI_750:
	LOCC	S^#NDT$_CI,#16,-	; Look for the CI780
		RPB$B_CONFREG(R11)	; in the CONFREG array.
10$:	RSB				; Return w/ condition code set
					; appropriately.

FIND_CI_730:
	CLRL	R0			; Signal no CI730.
	RSB

FIND_CI_8SS:
	CLRL	R0			; Signal no CI8SS for now.
	RSB

;
; For the 11/790, the array of adapter type codes isn't set up until later
; in the boot process.  Search the SBI nexuses for a CI adapter.
;
	.ENABLE LSB
FIND_CI_790:
	PUSHR	#^M<R2,R3,R4>		; Save some registers.
	PUSHL	4(R7)			; Save machine check vector.
	MOVAL	NXMCHK_790+1,4(R7)	; Replace with a temporary.
	MOVL	SP,R4			; Save stack pointer.
	MOVL	#IO790$AL_IOA0,R1	; Get address space for 1st ABUS slot.
10$:	MTPR	R1,#PR790$_PAMLOC	; Request PAMM code for this phys addr.
	MFPR	#PR790$_PAMACC,R0	; Read the PAMM code.
	CMPZV	#PAMM$V_CODE,#PAMM$S_CODE, -	; Is there an adapter present?
		R0,#PAMM$C_NEXM
	BEQL	30$			; No, go to next slot.
	MOVL	IO790$AL_IOACR(R1),R0	; Read ABUS configuration register.
	CMPZV	#4,#4,R0,#IO790$C_SBIA	; Is there an SBI here?
	BNEQ	30$			; No, go to next slot.
;
; Found an SBI.  Now look for a CI adapter.
;
	MOVAL	IO790$AL_PERNEX(R1),R2	; Get addr of SBI TR #1 (#0 is unused).
20$:	MOVL	(R2),R0			; Read config. register on SBI.
	CMPB	R0,S^#NDT$_CI		; Is this a CI adapter?
	BEQL	40$			; Yes; we found one.
25$:	MOVAL	IO790$AL_PERNEX(R2),R2	; Step to next TR.
	CMPZV	#12,#6,R2,#^X20		; Have we looked at all slots on this SBI?
	BLSS	20$			; Not yet, go on to the next.
;
; Looked unsuccessfully at all slots on this SBI.  See if there's another SBI.
;
30$:	MOVAL	IO790$AL_PERABS(R1),R1	; Step to next ABUS slot.
	CMPL	#IO790$AL_IOA0+<IO790$AL_PERABS*4>, -	; Have we looked at
		R1			; all possible ABUS slots?
	BGTR	10$			; Not yet, go on to next.
	MOVL	(SP)+,4(R7)		; Restore machine check handler to SCB.
	CLRL	R0			; Signal failure.
	BRB	50$			; Return.
;
; Come here on finding a CI adapter.
;
40$:	MOVL	(SP)+,4(R7)		; Restore machine check handler to SCB.
	MOVL	#1,R0			; Signal success.
50$:	POPR	#^M<R2,R3,R4>		; Restore registers.
	RSB	
;
; Non-existent memory machine check handler.
;
	.ALIGN	LONG
NXMCHK_790:
	MFPR	#PR$_EHSR,R0		; Get error handling status register.
	BBCC	#EHSR$V_VMS,R0,100$	; Clear "VMS entered" bit.
100$:	MTPR	R0,#PR$_EHSR		; Write back to clear machine check.
	MOVL	R4,SP			; Clear mcheck frame off stack.
	BRB	25$			; Scan next SBI slot.

	.DISABLE	LSB

	.SBTTL	Strings used in File I/O

VMSFILE:				; Name of standard secondary
	.ASCIC	/[SYSEXE]SYSBOOT.EXE/ ; bootstrap image file.

DIAGFILE:				; Name of standard diagnostic
	.ASCIC	/[SYSMAINT]DIAGBOOT.EXE/ ; secondary bootstrap image.

FIL$GT_TOPSYS::
	.ASCIC	/SYS0/			; Default top level system dir name
	.BLKB	10-<.-FIL$GT_TOPSYS>	; Fill to 10 bytes

NAMEPROMPT:				; Prompt string for secondary
	.ASCIZ	<CR><LF>/Bootfile:/	; boot file name.

DEVPROMPT:				; Prompt string for secondary
	.ASCIZ	<CR><LF>/Boot device name (ddcu):/
					; device mnemonic.

SWITCHPROMPT:				; Prompt string for switching console media
	.ASCII	<CR><LF><7>/Insert the first standalone system volume /
	.ASCIZ	/and enter "YES" when ready: /

; Message to remove current volume.  Note that besides giving the user some useful
; feedback, this message causes the volume to be rewound so that the volume label
; can be read.  This will prevent device timeouts (processor timeouts) on TU58 drives,
; since the processor has been seen to timeout waiting for a TU58 to rewind.

REMOVEPROMPT1:	.ASCIZ	<CR><LF><LF><LF><7>/Please remove the volume "/<7>
REMOVEPROMPT2:	.ASCIZ	/" from the console device./<7><CR><LF>

; Message to resume loading

RESUMEPROMPT1:	.ASCIZ	<CR><LF>/Resuming load operation on volume "/
RESUMEPROMPT2:	.ASCIZ	/", please stand by . . ./<CR><LF><LF>

CI_UCODE_FILE:
	.ASCIC	/CI780.BIN/		; Name of the binary file

PCS_UCODE_FILE:
	.ASCIC	/PCS750.BIN/		; Name of the binary file

UCODE_FAIL:
	.ASCIZ	<CR><LF>/%BOOT-W-Unable to locate ucode file - xxxx/<CR><LF>
UCODE_SEVER = UCODE_FAIL+8		; Severity code
UCODE_NAME = UCODE_FAIL+40		; File name

PCS_UCODE_STAT:
	.LONG	0
	.LONG	0

PCS_UCODEV:
	.ASCII	/PCS /
	.LONG	PCS_UCODE_FILE-.
	.LONG	PCS_UCODE_STAT-.
	.LONG	1			; Fatal

CI_UCODEV:
	.ASCII	/CI  /
	.LONG	CI_UCODE_FILE-.
	.LONG	CI_UCODE_STAT-.
	.LONG	0			; Non-fatal



	.SBTTL	Unexpected machine check handler, DEBUG labels

	SET_PSECT			; Back to default PSECT

;
; Define handlers needed by XDELTA.
;

	.ALIGN	LONG			; All handlers longword-aligned.

	.IF	DF,DEBUG		; If debugging,

EXE$ACVIOLAT::				; Access violation vector.
EXE$BREAK::				; BPT vector.
EXE$ROPRAND::				; Reserved operand vector.
EXE$TBIT::				; Trace trap vector.
MMG$PAGEFAULT::				; Pagefault exception vector.

	.ENDC				; End of debugging conditional.

;
; Fault handler for unexpected exception conditions during bootstrap.
;

BOOT_FAULT:				; Handler for most of SCB.
	ERROR	</%BOOT-F-Unexpected Exception/>
					; Output error message.

	.ALIGN	LONG			; All handlers longword-aligned.

;
; Machine check handler.
;

UNEXP_MCHK::
	ERROR	</%BOOT-F-Unexpected Machine Check/>
					; Output error message.

;
; Labels required by XDELTA.
;

	.IF	DF,DEBUG		; If debugging, define labels.

INI$RDONLY::				; Dummy change protection
INI$WRITABLE::				; routines.
SYSL$CLRSBIA::				; Dummy routine to clear SBIA errors.
	RSB				; Just return.

EXE$GL_FLAGS::				; Dummy flags longword.
EXE$GL_SCB::				; Dummy SCB address pointer.
EXE$V_SIMULATOR	== 0			; This is not a simulator.

PFN$AB_STATE::
PFN$AB_TYPE::
PFN$AL_BAK::
PFN$AL_PTE::
PFN$Ax_BLINK::
PFN$Ax_FLINK::
PFN$AW_REFCNT::
PFN$AW_SWPVBN::

SYS$IOBASE::
SCH$GL_CURPCB::
SCH$GL_PCBVEC::

XDS$GT_WORD_PFN::
	.LONG	0

	.ENDC

	.SBTTL	Error message subroutine

;++
;
; Functional description:
;
;	This routine outputs a descriptive error message to the
;	console terminal. Then the routine restores the original
;	register settings from the time that the primary bootstrap
;	gained control, and executes a HALT instruction.
;
; Inputs:
;
;	SP	- points to address of message text
;
; Implicit inputs:
;
;	The RPB contains the contents of the original boot registers,
;	and the original stack pointer.
;
; Outputs:
;
;	Registers R0-R6, R10-R11, and AP are restored from the RPB.
;
; Implicit outputs:
;
;	When the HALT instruction executes, the console terminal reports
;	a halt and prompts the user for input.
;
;--

ERROUT::				; Report an error and HALT.
	MOVL	(SP)+,R8		; Get pointer to message text.
	CLRQ	-(SP)			; Null input buffer and size
					; arguments.
	PUSHL	R8			; Address of prompt string.
	CALLS	#3,BOO$READPROMPT	; Report the error.
	MOVL	BOO$GL_RPBBASE,R11	; Get the RPB address.
	MOVL	SP,R9			; Save old SP
	MOVL	RPB$L_BASE(R11),SP	; Set SP to base of memory.
	MOVAB	^X200(SP),SP		; Set SP to 1st page past RPB.
	MOVQ	RPB$L_BOOTR0(R11),R0	; Restore R0-R1.
	MOVQ	RPB$L_BOOTR2(R11),R2	; Restore R2-R3.
	MOVQ	RPB$L_BOOTR4(R11),R4	; Restore R4-R5.
	MOVL	RPB$L_HALTCODE(R11),AP	; Restore halt code.
	MOVQ	RPB$L_HALTPC(R11),R10	; Restore halt PC and PSL.
ERRHLT:
	HALT				; Halt the processor.

;
; If the user types CONTINUE to the console program, try to restart
; the bootstrap process.
;

	BLBS	MUST_HALT,ERRHLT	; Branch if cannot retart
	BRW	START_BOOT		; Restart the boot.

	.SBTTL	Declarations located at end of bootstrap

	.ALIGN	LONG
;
; Parameter list handed from primary boot to secondary boot
; The first location contains the argument count.  It is intended
; that the secondary boot will know what is in the list based on
; the argument count and the VMB version number.  This means that
; new information should be placed at new offsets even if older
; stuff becomes obsolete.  The VMB version number can be used to
; totally change the argument meanings if necessary.
;
SECOND_PARAM:
	FIL$GQ_CACHE	== .+VMB$Q_FILECACHE ; FILEREAD cache descriptor
	BOO$GB_SYSTEMID	== .+VMB$B_SYSTEMID  ; SCS system id
	.LONG	<VMB$C_ARGBYTCNT-4>/4	; Size of argument list
	.BLKB	VMB$C_ARGBYTCNT-4	; Reserve space for the arguments

BITMAP_VEC_PTR:
	.BLKL	1			; Address of bitmap page array
BITMAP_HI_INDX:				; Highest index to
	.BLKL	1			; bitmap page address array
BITMAP_BAS_PFN:				; Starting PFN for PFN bitmap
	.BLKL	1			; when it is bigger than the 
					; pre-allocated bitmap
INPBUF:	.QUAD	0			; Dummy input buffer, with a cushion
BOO$GL_RPBBASE::
	.BLKL	1			; RPB base address
MUST_HALT:
	.LONG	0			; If LBS, ERROUT should not restart
					; rather it must halt.
CI_UCODE_STAT:
	.LONG	0,0			; Statistics block for ucode file
LAST_MEM:
	.LONG	0			; Last memory location probed
MEM_FLAG:
	.LONG	0			; Flag for memory found

;
; If debugging flag is set, align end of bootstrap on a longword
; boundary.
;

	.IF	DF,DEBUG
	.ALIGN	LONG
	.ENDC

	.END	START_BOOT
