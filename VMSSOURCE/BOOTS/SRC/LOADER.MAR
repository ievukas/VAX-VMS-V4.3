	.TITLE	LOADER - LOAD A DRIVER AND/OR DEVICE CONTROL BLOCKS
	.IDENT	'V04-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:	SYSGEN
;
; ABSTRACT:	LOAD A DRIVER AND/OR DEVICE CONTROL BLOCKS
;
;
; ENVIRONMENT:	USER MODE PRIVILEGED CODE
;
; AUTHOR:	LEN KAWELL, CREATION DATE:16-JUN-1978
;
; MODIFICATION HISTORY:
;
;	V03-015	WHM0005		Bill Matthews		19-Jul-1984
;		Don't issue vector in use error message if the vector has
;		been in use by the console terminal driver(CON$INTINP).
;
;	V03-014	LMP0275		L. Mark Pilant,		12-Jul-1984  12:10
;		Initialize the ACL info in the ORB to be a null descriptor
;		list rather than an empty queue.  This avoids the overhead
;		of locking and unlocking the ACL mutex, only to find out
;		that the ACL was empty.
;
;	V03-013	LMP0221		L. Mark Pilant,		31-Mar-1984  10:46
;		Add support for an ORB, the Object's Rights Block.
;
;	V03-012	WHM0004		Bill Matthews		16-Feb-1984
;		Added part 2 of a 2 part change to clean up the support of
;		combo style devices.
;
;	V03-011	WHM0003		Bill Matthews		04-Feb-1984
;		Added part 1 of a 2 part change to clean up the support
;		of combo style devices.
;
;	V03-010	LMP0185		L. Mark Pilant,		26-Jan-1984  15:28
;		Add support for ACLs on devices.
;
;	V03-009	WHM0002		Bill Matthews		03-Jan-1984
;		In LOAD_DB don't assume the I/O database hasn't been
;		modified since SYSGEN called SGN$GET_DEVICE. The CONFIGURE
;		process could have altered the I/O database. ACF$GL_LASTDDB
;		isn't necessarily the last DDB and the UCB may have been
;		created.
;
;	V03-008	WHM0001		Bill Matthews		14-Dec-1983
;		Use IDB$B_COMBO_VECTOR to replace IDB$B_VECTOR functionality.
;
;	V03-007	ROW0221		Ralph O. Weber		 8-SEP-1983
;		In LOAD_DB guarantee that a success status is available to 
;		allow IOC$UNITINIT to be called, even if the call to 
;		IOGEN$CNTRL_INI is skipped.
;
;	V03-006	ROW0203		Ralph O. Weber		 5-AUG-1983
;		Change LOAD_DB to use IOC$CTRLINIT, the common, system-wide 
;		routine for calling driver's unit initialization routines.
;
;	V03-005	TCM0001		Trudy C. Matthews	01-Jun-1983
;		Initialize the DDB$L_ALLOCLS (device allocation class field)
;		in routine CREATE_DDB.
;
;	V03-004	MSH0004		Maryann Hinden		09-Feb-1983
;		Add support for cluster device names.
;
;	V03-003	MSH0003		Maryann Hinden		06-Oct-1982
;		Modify MSH0002.
;
;	V03-002	MSH0002		Maryann Hinden		05-Oct-1982
;		Change check for zero UCB pointer when loading 
;		database.
;
;	V03-001	MSH0001		Maryann Hinden		31-JUL-1982
;		Add check for missing DDT's.
;--
	.PAGE
	.SBTTL	DECLARATIONS


;
; INCLUDE FILES:
;

;
; MACROS:
;

;
; EQUATED SYMBOLS:
;

	$SYSGMSGDEF			;DEFINE SYSGEN MESSAGES
	$IPLDEF				;DEFINE SYSTEM IPL'S
	$DCDEF				;DEFINE ADAPTER TYPE SYMBOLS
	$DYNDEF				;DEFINE DYNAMIC MEMORY TYPES
	$DDBDEF				;DEFINE DEVICE DATA BLOCK
	$UCBDEF				;DEFINE UNIT CONTROL BLOCK
	$CRBDEF				;DEFINE CHANNEL CONTROL BLOCK
	$VECDEF				;DEVICE INTERRUPT VECTOR 
	$IDBDEF				;DEFINE INTERRUPT DISPATCH BLOCK
	$ADPDEF				;DEFINE ADAPTER CONTROL BLOCK
	$PRDEF				;DEFINE PROCESSOR REGISTERS
	$DPTDEF				;DEFINE DRIVER PROLOGUE TABLE
	$ACFDEF				;DEFINE AUTO-CONFIGURE ARG LIST
	$PTEDEF				;DEFINE PAGE TABLE ENTRIES
	$UBADEF				;DEFINE UNIBUS ADAPTER
	$DDTDEF				;DEFINE DDT
	$ORBDEF				;DEFINE OBJECT'S RIGHTS BLOCK OFFSETS
;
; OWN STORAGE:
;

	.PSECT	NONPAGED_DATA	rd,wrt,noexe,quad

LOAD_FLAGS:				;CONTROL BLOCKS CREATED FLAGS
	.BLKB	1
	_VIELD	LOAD,0,<-		; FLAG DEFINTIONS
		<DDB,,M>,-		;  DDB CREATED
		<CRB,,M>,-		;  CRB CREATED
		<IDB,,M>,-		;  IDB CREATED
		<UCB,,M>,-		;  UCB CREATED
		>
DDB_BLINK:				;DDB BACKWARD LINK
	.BLKL	1
UCB_BLINK:				;UCB BACKWARD LINK
	.BLKL	1

	.PSECT	NONPAGED_CODE	rd,nowrt,exe,long

MBINT_DISP:				;MBA INTERRUPT DISPATCHER MODEL
	PUSHR	#^M<R2,R3,R4,R5>
	JSB	@#0

INT_DISP:				;GENERAL INTERRUPT DISPATCHER MODEL
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>
	JSB	@#0

	.PAGE
	.SBTTL	LOADER - LOAD A DEVICE DRIVER/DATABASE

;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine will load a device driver, a device driver and
;	database, or just a single unit into an already existing
;	database.
;
; CALLING SEQUENCE:
;
;	CALL IOGEN$LOADER(ACF_LIST)
;
; INPUT PARAMETERS:
;
;	ACF_LIST -
;
;	ACF$L_ADAPTER(AP) = ADDRESS OF ADAPTER CONTROL BLOCK
;	ACF$L_CONFIGREG(AP) = ADDRESS OF CONFIGURATION STATUS REGISTER
;	ACF$W_AVECTOR(AP) = OFFSET TO ADAPTER INTERRUPT VECTOR (SCB)
;	ACF$B_AUNIT(AP) = ADAPTER UNIT NUMBER
;	ACF$B_AFLAG(AP) = ADAPTER GENERATION CONTROL FLAGS
;	ACF$L_CONTRLREG(AP) = ADDRESS OF CONTROL REGISTER
;	ACF$W_CVECTOR(AP) = OFFSET TO CONTROLLER INTERRUPT VECTOR (TABLE)
;	ACF$W_CUNIT(AP) = CONTROLLER UNIT NUMBER
;	ACF$B_CNUMVEC(AP) = NUMBER OF CONTROLLER VECTORS
;	ACF$L_DEVNAME(AP) = ADDRESS OF DEVICE NAME COUNTED STRING
;	ACF$L_DRVNAME(AP) = ADDRESS OF DRIVER NAME COUNTED STRING
;	ACF$B_COMBO_CSR_OFFSET(AP) = OFFSET BACK TO THE START OF THE CSRS FOR
;					A COMBO DEVICE
;	ACF$B_COMBO_VECTOR_OFFSET(AP) = OFFSET BACK TO THE START OF THE VECTORS FOR
;					FOR A COMBO DEVICE

;
; IMPLICIT INPUTS:
;
;	NONE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT OUTPUTS:
;
;	DRIVER AND/OR DATABASE LOADED
;
; COMPLETION CODES:
;
;	R0 = STATUS OF OPERATION
;
; SIDE EFFECTS:
;
;	NONE
;
;--

.Entry	IOGEN$LOADER,0
;
; See if driver needs to be loaded
;
	BBS	#ACF$V_RELOAD,ACF$B_AFLAG(AP),10$ ;BR IF RELOAD REQUESTED
	$CMKRNL_S W^CHECK_DRV,(AP)	;CHECK IF DRIVER LOADED
	CMPW	R0,#SS$_NOPRIV		;NO PRIVILEGE?
	BEQLU	40$			;BR IF YES
	BLBS	R0,20$			;BR IF DRIVER LOADED

10$:	PUSHL	ACF$L_DRVNAME(AP)	;SET ADDR OF DRIVER NAME
	CALLS	#1,IOGEN$LOADDRIV	;LOAD THE DRIVER

; Note that the errors from this call are suppressed if this is a load driver
; call only (If ACF$V_NOLOAD_DB is set). This is because the subsequent
; call from AUTOCONFIGURE takes this same code path and will report the
; error at that time. Unsupported devices do not print out the error message.

20$:	BBS	#ACF$V_NOLOAD_DB,-
		ACF$B_AFLAG(AP),30$	;EXIT IF LOAD DRIVER CALL ONLY

	BLBC	R0,50$			;BR IF ERROR LOADING DRIVER

	TSTL	ACF$L_DEVNAME(AP)	;DEVICE NAME SPECIFIED?
	BEQL	30$			;BR IF NOT - DON'T LOAD DATABASE
	$CMKRNL_S W^LOAD_DB,(AP)	;LOAD THE DATABASE
	BRB	40$			; EXIT WITH STATUS

30$:	MOVL	#1,R0
40$:	RET

;
; Error occured loading driver
;
50$:	BBC	#ACF$V_SUPPORT,-
		ACF$B_AFLAG(AP),40$	;BRANCH IF SUPPORTED DEVICE
	BRB	30$			;ALWAYS SUCCESS FOR UNSUPPORTED


	.PAGE
	.SBTTL	CHECK_DRV - CHECK IF DRIVER ALREADY LOADED
;++
;
; Local kernel mode routine to check if the driver is already loaded.
;
;--
CHECK_DRV:
	.WORD	^M<R2,R3,R4,R5,R6,R7>
	BSBW	IOGEN$LOCK_IODB		;LOCK THE I/O DATABASE
	MOVL	ACF$L_DRVNAME(AP),R5	;GET ADDR OF DRIVER NAME
	MOVZBL	(R5)+,R4		;GET SIZE OF DRIVER NAME
	MOVAB	G^IOC$GL_DPTLIST,R6	;GET ADDR OF DPT LIST
	MOVL	R6,R7			;SAVE IT
10$:
	CLRL	R0			;ASSUME NOT LOADED
	MOVL	DPT$L_FLINK(R6),R6	;GET ADDR OF NEXT DRIVER PROLOGUE
	CMPL	R6,R7			;END OF LIST?
	BEQL	20$			;BR IF YES
	MOVAB	DPT$T_NAME(R6),R1	;GET ADDR OF DRIVER NAME
	MOVZBL	(R1)+,R0		;GET SIZE OF DRIVER NAME
	CMPC5	R0,(R1),#0,R4,(R5)	;COMPARE DRIVER NAMES
	BNEQ	10$			;BR IF NOT EQUAL
	MOVL	R6,W^ACF$GL_DPT	;SET ADDR OF DRIVER PROLOGUE
	MOVL	#1,R0			;SET SUCCESS
20$:
	PUSHL	R0			;SAVE STATUS
	BSBW	IOGEN$UNLK_IODB		;UNLOCK THE I/O DATABASE
	POPL	R0			;RESTORE THE STATUS
	RET

	.PAGE
	.SBTTL	LOAD_DB - LOAD THE DATABASE
;++
;
; Local kernel mode routine to load the UCB and if not loaded yet,
; the DDB, CRB, and IDB.
;
;--
LOAD_DB:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	CLRB	W^LOAD_FLAGS		;CLEAR LOADER FLAGS
	MOVL	W^ACF$GL_DPT,R11	;GET ADDR OF DRIVER PROLOGUE
	BSBW	IOGEN$LOCK_IODB		;LOCK THE I/O DATABASE
;
; CHECK IF DEVICE DATABASE ALREADY LOADED
;
	BBSC	#ACF$V_GETDONE,-
		ACF$B_AFLAG(AP),2$	; Skip the scan if done in CONNECT
	MOVZWL	ACF$W_CUNIT(AP),-(SP)	; Push unit number
	PUSHL	ACF$L_DEVNAME(AP)	; Push device name address
	BSBW	SGN$GET_DEVICE		; Get device addresses if they exist
	ADDL2	#8,SP			; Pop input off stack

2$:	SETIPL	#IPL$_SYNCH		; Synchronize I/O database access
	MOVL	W^ACF$GL_DDB,R10	; Address of DDB
	BEQL	CREATE_DDB		; Branch if it doesn't exist

	TSTL	W^ACF$GL_UCB		; Is there a UCB for this unit?
	BEQL	10$			; Branch if no
5$:	BRW	DB_EXIT			; Branch to common exit point

10$:	MOVL	W^ACF$GL_CRB,R9		; Address of CRB
	BEQL	5$			; If none, exit
	MOVL	W^ACF$GL_IDB,R8		; Address of IDB
	BEQL	5$			; If none, exit
	MOVL	DDB$L_UCB(R10),R7	; Get address of first UCB
	BEQL	30$			; If eql no UCB'S go create one.
20$:	CMPW	UCB$W_UNIT(R7),ACF$W_CUNIT(AP); Is UCB already loaded?
	BEQL	5$			; If eql yes, nothing left to do
	MOVL	UCB$L_LINK(R7),R7	; Get address of next UCB
	BNEQ	20$			; If neq then there is another UCB
30$:	BRW	CREATE_UCB		; Create UCB for this unit

;
; CREATE THE DDB
;
CREATE_DDB:
	MOVL	W^ACF$GL_LASTDDB,R10	;Get address of last DDB in list
	MOVZBL	#DDB$K_LENGTH,R1	;GET SIZE OF DDB
	BSBW	IOGEN$ALLOBLOCK		;CREATE THE DDB
	BLBS	R0,10$			;BR IF SUCCESS
	BRW	DB_ERROR		;ELSE - ERROR
10$:	BISB	#LOAD_M_DDB,W^LOAD_FLAGS ;SET DDB LOADED FLAG
	MOVW	R1,DDB$W_SIZE(R2)	;SET SIZE
	MOVB	#DYN$C_DDB,DDB$B_TYPE(R2) ;SET TYPE
	MOVAL	DDB$L_LINK(R10),W^DDB_BLINK ;SAVE DDB BACKWARD LINK
	MOVL	DDB$L_LINK(R10),R1	;SAVE LINK TO NEXT DDB
	MOVL	R2,DDB$L_LINK(R10)	;SET LINK TO THIS DDB
	MOVL	R2,R10			;GET ADDR OF DDB
	MOVL	R1,DDB$L_LINK(R10)	;SET LINK TO NEXT DDB
	INCB	DPT$B_REFC(R11)		;INCREMENT DPT REFERENCE COUNT
	MOVZBL	@ACF$L_DEVNAME(AP),R0	;GET SIZE OF DEVICE NAME
	INCL	R0			;ADD 1 BYTE FOR COUNT
	MOVC	R0,@ACF$L_DEVNAME(AP),DDB$T_NAME(R10) ;SET DEVICE NAME
	MOVZBL	@ACF$L_DRVNAME(AP),R0	;GET SIZE OF DRIVER NAME
	INCL	R0			;ADD 1 BYTE FOR COUNT
	MOVC	R0,@ACF$L_DRVNAME(AP),DDB$T_DRVNAME(R10) ;SET DRIVER NAME
	MOVL	W^ACF$GL_SB,DDB$L_SB(R10) ;INSERT THE ADDRESS OF SYSTEM BLOCK
	MOVL	G^CLU$GL_ALLOCLS, -	;COPY THE DEVICE ALLOCATION CLASS
		DDB$L_ALLOCLS(R10)	;FROM THE SYSTEM-WIDE PARAMETER
;
; CHECK IF CRB/IDB NEED TO BE CREATED
;
	MOVL	ACF$L_ADAPTER(AP),R9	; CONTAINS ADDR. OF CRB IF CRBBLT FLAG IS SET
	BBS	#ACF$V_CRBBLT,-
		ACF$B_AFLAG(AP),20$ 		; BR. IF CRB & IDB ARE BUILT
	BBS	#DPT$V_SUBCNTRL,-
		DPT$B_FLAGS(R11),CREATE_CRB 	; BR IF SUBCONTROLLER

	CMPB	#AT$_MBA,DPT$B_ADPTYPE(R11) 	; MBA ADAPTER?
	BEQL	15$				; BRANCH IF YES
	CMPB	#AT$_DR,DPT$B_ADPTYPE(R11) 	; DR ADAPTER?
	BEQL	15$				; BRANCH IF YES
	CMPB	#AT$_CI,DPT$B_ADPTYPE(R11)	; CI ADAPTER ?
	BEQL	15$				; BRANCH IF YES
	BRB	CREATE_CRB			; BRANCH IF OTHER
;
; USE EXISTING CRB (IF ONE EXISTS)
;
15$:	MOVL	ACF$L_ADAPTER(AP),R0		; GET ADDR OF ADP
	MOVL	ADP$L_CRB(R0),R9		; GET ADDR OF EXISTING CRB
	BEQL	CREATE_CRB			; BRANCH IF NONE
20$:	MOVL	CRB$L_INTD+VEC$L_IDB(R9),R8	; GET ADDR. OF IDB
	BRW	CREATE_UCB			; CREATE A NEW UCB
;
; CREATE CRB
;
CREATE_CRB:
	MOVZBL	ACF$B_CNUMVEC(AP),R1	;GET NUMBER OF INT VECTORS
	DECL	R1			;ONE IS ALWAYS ASSUMED
	MULW	#VEC$K_LENGTH,R1	;COMPUTE SIZE OF EXTRA DISPATCHERS
	ADDW	#CRB$K_LENGTH,R1	;COMPUTE TOTAL SIZE OF CRB
	BSBW	IOGEN$ALLOBLOCK		;ALLOCATE THE CRB
	BLBS	R0,10$			;BR IF SUCCESS
	BRW	DB_ERROR		;ELSE - ERROR
10$:	BISB	#LOAD_M_CRB,W^LOAD_FLAGS ;SET CRB LOADED FLAG
	MOVL	R2,R9			;GET ADDR OF CRB
	MOVL	R9,ACF$GL_CRB		; *** SAVE FOR ACF$UDA IN AUTOCONFG
	MOVW	R1,CRB$W_SIZE(R9)	;SET SIZE
	MOVB	#DYN$C_CRB,CRB$B_TYPE(R9) ;SET TYPE
	MOVAL	CRB$L_WQFL(R9),CRB$L_WQFL(R9) ;SET WAIT QUEUE LISTHEAD
	MOVAL	CRB$L_WQFL(R9),CRB$L_WQBL(R9) ;...
	BBC	#DPT$V_SUBCNTRL,DPT$B_FLAGS(R11),CREATE_IDB ;BR IF NOT SUBCONTROLLER
	MOVL	ACF$L_ADAPTER(AP),R0	;GET ADDR OF ADAPTER CONTROL BLOCK
	MOVL	ADP$L_CRB(R0),R1	;GET ADDR OF SECONDARY CRB
	MOVL	R1,CRB$L_LINK(R9)	;SET ADDR OF SECONDARY CRB
	MOVL	CRB$L_INTD+VEC$L_IDB(R1),R2 ;GET ADDR OF SECONDARY IDB
	MOVZBL	ACF$B_AUNIT(AP),R3	;GET ADAPTER UNIT NUMBER
	MOVAB	CRB$L_INTD+1(R9),IDB$L_UCBLST(R2)[R3] ;SET ADDR OF DISPATCHER
;
; CREATE IDB
;
CREATE_IDB:
	MOVZBL	#IDB$K_LENGTH-<8*4>,R1	;GET STANDARD LENGTH OF IDB
					;(LESS NORMAL 8 UNITS)
	MOVZWL	DPT$W_MAXUNITS(R11),R4	;GET MAXIMUM NUMBER OF UNITS
	TSTW	ACF$W_MAXUNITS(AP)	;WAS A VALUE SPECIFIED AT CONNECT?
	BEQL	5$			;BR IF NO
	MOVW	ACF$W_MAXUNITS(AP),R4	;USE THE SPECIFIED VALUE INSTEAD
5$:	MOVAL	(R1)[R4],R1		;COMPUTE TOTAL SIZE NEEDED
	CVTLW	R1,R1			;IS MAXUNITS TOO LARGE ?
	BVC	7$			;BRANCH IF NO
	MOVL	#SYSG$_MAXTOOBIG,R0	;SET ERROR
	BRW	DB_ERROR		;BRANCH TO ERROR
7$:	BSBW	IOGEN$ALLOBLOCK		;ALLOCATE THE IDB
	BLBS	R0,10$			;BR IF SUCCESS
	BRW	DB_ERROR		;ELSE - ERROR
10$:	BISB	#LOAD_M_IDB,W^LOAD_FLAGS ;SET IDB LOADED FLAG
	MOVL	R2,R8			;GET ADDR OF IDB
	MOVW	R1,IDB$W_SIZE(R8)	;SET SIZE
	MOVB	#DYN$C_IDB,IDB$B_TYPE(R8) ;SET TYPE
	MOVW	R4,IDB$W_UNITS(R8)	    ;SET MAXIMUM UNITS
	CMPB	#AT$_NULL,DPT$B_ADPTYPE(R11);NULL ADAPTER ?
	BNEQ	30$			    ;IF NOT, BRANCH
	MOVL	R8,CRB$L_INTD+VEC$L_IDB(R9) ;STORE IDB POINTER IN CRB
	CLRL	CRB$L_INTD+VEC$L_ADP(R9)    ;NULLIFY ADP POINTER
	CLRL	IDB$L_ADP(R8)		    ;NULLIFY ADP POINTER
	CLRL	IDB$L_CSR(R8)		    ;NULLIFY CSR POINTER
	MOVL	W^INT_DISP,-		;STORE INTERRUPT DISPATCHER CODE
		CRB$L_INTD+VEC$Q_DISPATCH(R9)
	BRW	CREATE_UCB		;CONTINUE

30$:
	MOVL	ACF$L_ADAPTER(AP),IDB$L_ADP(R8) ;SET ADDR OF ADP
	MOVL	ACF$L_CONTRLREG(AP),IDB$L_CSR(R8) ;SET ADDR OF CSR
	MOVB	ACF$B_COMBO_CSR_OFFSET(AP),-	;SET OFFSET TO CSR START
		IDB$B_COMBO_CSR_OFFSET(R8)	;

; Vector is now saved in IDB. The two least significant bits are always
; zero, so the nine bit field is taken as bits 2 through 9 and placed
; in a byte field. IDB$B_VECTOR is the field, and is currently not filled
; in for a system booted from a UNIBUS boot device (e.g. an RK07).
;	
	extzv	#2,#7,acf$w_cvector(ap),r1	; Get right shifted vector
	movb	r1,idb$b_vector(r8)		; Place in IDB

	MOVB	ACF$B_COMBO_VECTOR_OFFSET(AP),-	;SET OFFSET TO VECTOR START
		IDB$B_COMBO_VECTOR_OFFSET(R8)

;
; CREATE INTERRUPT VECTOR DISPATCHER(S)
;
CREATE_VEC:
	CVTWL	ACF$W_CVECTOR(AP),R6	;GET VECTOR TABLE OFFSET
	BGTR	5$			;BR IF VECTOR SPECIFIED
	MOVL	#SYSG$_INVVEC,R0	;SET INVALID VECTOR ERROR
	BRW	DB_ERROR		;...EXIT
5$:	MOVZBL	ACF$B_CNUMVEC(AP),R5	;GET NUMBER OF INTERRUPT VECTORS
	MOVAL	CRB$L_INTD(R9),R4	;GET ADDR OF FIRST DISPATCHER
10$:	MOVL	W^MBINT_DISP,VEC$Q_DISPATCH(R4) ;ASSUME MBA DEVICE:  SET
						;  "PUSHR #^M<R2,R3,R4,R5>"
					; AND "JSB @#"
	MOVL	ACF$L_ADAPTER(AP),VEC$L_ADP(R4) ;SET ADDR OF ADP
	MOVL	R8,VEC$L_IDB(R4)	;SET ADDR OF IDB
	BBC	#ACF$V_SCBVEC,-		;BR IF NOT VECTORING DIRECTLY
		ACF$B_AFLAG(AP),13$	;FROM SCB
	ADDL3	MMG$A_SYSPARAM+<EXE$GL_SCB-EXE$A_SYSPARAM>,-  ;USE SYS.EXE
		R6,R0			;COPY OF SCB ADDR TO GET ADDRESS
					;OF VECTOR IN SCB
	MOVAB	VEC$Q_DISPATCH+1(R4),-	;CONNECT DISPATCHER TO VECTOR
		(R0)			;THE +1 MEANS USE THE INTERRUPT STACK
	MOVL	W^INT_DISP,VEC$Q_DISPATCH(R4)	;STORE DISPATCHER CODE
	BRB	30$

13$:	MOVL	ACF$L_ADAPTER(AP),R0	;GET ADDR OF ADP
	ADDL3	ADP$L_VECTOR(R0),R6,R0	;GET ADDR OF VECTOR TABLE ENTRY
	CMPB	#AT$_UBA,DPT$B_ADPTYPE(R11) ;UBA DEVICE?
	BEQL	15$			;BR IF YES
	CMPB	#AT$_MPM,DPT$B_ADPTYPE(R11) ;MULTI-PORT MEMORY DEVICE?
	BNEQ	30$			;BR IF NOT
	MOVAB	VEC$Q_DISPATCH+2(R4),(R0) ;CONNECT DISPATCHER
	BRB	30$			;
15$:
	BICL3	#3,(R0),R1		;GET CURRENT VECTOR CONTENT
					; EXCLUDING STACK SPECIFICATION
	CMPL	R1,#UBA$UNEXINT		;IS VECTOR IN USE?
	BEQL	20$			;BR IF NOT
	CMPL	R1,#CON$INTINP		;IS VECTOR IN USE BY THE CONSOLE TERMINAL DRIVER?
	BEQL	20$			;IF EQL YES CONNECT THE TRUE DRIVER.
	MOVL	#SYSG$_VECINUSE,R0	;SET ERROR STATUS
	BRW	DB_ERROR		;...EXIT
20$:
	BSBW	IOGEN$CONN_VEC		;CONNECT UB DEVICE VECTOR
30$:	ADDL	#4,R6			;INCREMENT VECTOR OFFSET
	ADDL	#VEC$K_LENGTH,R4	;INCREMENT DISPATCH ADDR
	SOBGTR	R5,10$			;DECREMENT VECTOR COUNT - BR IF MORE
;
; CREATE A UCB
;
CREATE_UCB:
	CLRL	R7			;SET NO UCB
	MOVZWL	DPT$W_UCBSIZE(R11),R1	;GET SIZE OF UCB
	BNEQ	2$			;BRANCH IF NON-NULL
	BRW	INIT_DB			;BRANCH IF NO UCB FOR THIS DRIVER

2$:	MOVL	R1,R7			;COPY UCB SIZE FOR LATER
	ADDL2	#ORB$C_LENGTH,R1	;ALLOCATE ORB ADJACENT TO THE UCB
	BSBW	IOGEN$ALLOBLOCK		;ALLOCATE THE UCB AND ORB
	BLBS	R0,5$			;BR IF SUCCESS
	BRW	DB_ERROR		;ELSE - ERROR
5$:	BISB	#LOAD_M_UCB,W^LOAD_FLAGS ;SET UCB LOADED FLAG
	MOVW	R7,UCB$W_SIZE(R2)	;SET SIZE OF UCB
	ADDL3	R7,R2,UCB$L_ORB(R2)	;SET ORB ADDRESS
	MOVL	R2,R7			;COPY ADDR OF UCB
	MOVB	#DYN$C_UCB,UCB$B_TYPE(R7) ;SET TYPE
	MOVAL	UCB$L_ASTQFL(R7),UCB$L_ASTQFL(R7) ;SET AST QUEUE LISTHEAD
	MOVAL	UCB$L_ASTQFL(R7),UCB$L_ASTQBL(R7) ;...
	MOVL	R9,UCB$L_CRB(R7)	;SET ADDR OF CRB
	INCW	CRB$W_REFC(R9)		;INCREMENT CRB REFERENCE COUNT
	MOVZWL	ACF$W_CUNIT(AP),R0	;GET CONTROLLER UNIT NUMBER
	CMPW	R0,IDB$W_UNITS(R8)	;MAXIMUM UNITS EXCEEDED?
	BLSSU	8$			;BR IF NOT
	MOVL	#SYSG$_MAXUNITS,R0	;SET MAXIMUM UNITS EXCEEDED
	BRW	DB_ERROR		;...EXIT
8$:
	MOVL	R7,IDB$L_UCBLST(R8)[R0]	;SET ADDR OF UCB IN IDB
	MOVL	R10,UCB$L_DDB(R7)	;SET ADDR OF DDB
	MOVAL	UCB$L_IOQFL(R7),UCB$L_IOQFL(R7) ;SET I/O QUEUE LISTHEAD
	MOVAL	UCB$L_IOQFL(R7),UCB$L_IOQBL(R7) ;...
	MOVW	ACF$W_CUNIT(AP),UCB$W_UNIT(R7) ;SET UNIT NUMBER
	MOVL	CRB$L_INTD+VEC$L_IDB(R9),R1 ;IDB ADDRESS
	MOVL	IDB$L_ADP(R1),R1	;ADP ADDRESS
	BEQL	9$			;PHYSICAL DEVICE IF NON-ZERO
	CMPW	#AT$_MBA,ADP$W_ADPTYPE(R1) ;IS IT A MASSBUS
	BNEQ	9$			;BRANCH IF NOT
	MOVB	ACF$B_AUNIT(AP),UCB$B_SLAVE(R7) ;SET SLAVE CNTRLER NUMBER

; BEFORE HOOKING THE UCB UP TO THE DDB CHAIN, INITIALIZE THE ORB.

9$:	MOVL	UCB$L_ORB(R7),R1	;GET THE ORB ADDRESS
	MOVB	#DYN$C_ORB,ORB$B_TYPE(R1)	;SET BLOCK TYPE
	MOVW	#ORB$C_LENGTH,ORB$W_SIZE(R1)	;SET BLOCK SIZE
	MOVB	#ORB$M_PROT_16,ORB$B_FLAGS(R1)	;SOGW PROT WORD & NO ACL QUEUE

	ASSUME	ORB$L_ACL_DESC EQ ORB$L_ACL_COUNT+4

	CLRQ	ORB$L_ACL_COUNT(R1)	;ACL IS EMPTY

; NOW HOOK THE UCB INTO THE DDB CHAIN

	MOVAL	DDB$L_UCB(R10),R1	;GET ADDR OF ADDR OF FIRST UCB
	MOVL	(R1),R0			;GET ADDR OF FIRST UCB
	BEQL	20$			;BR IF NONE
10$:	MOVAL	UCB$L_LINK(R0),R1	;GET ADDR OF ADDR OF NEXT UCB
	MOVL	(R1),R0			;GET ADDR OF NEXT UCB
	BNEQ	10$			;BR IF IT EXISTS
20$:	MOVL	R1,W^UCB_BLINK		;SAVE UCB BACKWARD LINK
	MOVL	R7,(R1)			;SET FORWARD LINK TO UCB

	BBC	#DPT$V_SVP,DPT$B_FLAGS(R11),INIT_DB ;BR IF NO SYS PAGE REQUIRED
	MOVAB	MMG$A_SYSPARAM,R2	;GET ADDR OF SYS PARAMS
	MOVL	BOO$GL_SPTFREL-EXE$A_SYSPARAM(R2),R0 ;GET NEXT FREE SPT ENTRY
	CMPL	R0,BOO$GL_SPTFREH-EXE$A_SYSPARAM(R2) ;SPT FULL?
	BLEQU	30$			;BR IF NO
	MOVL	#SYSG$_SPTFULL,R0	;SET ERROR STATUS
	BRW	DB_ERROR		;...EXIT
30$:	INCL	BOO$GL_SPTFREL-EXE$A_SYSPARAM(R2) ;INCREMENT NEXT FREE  POINTER
	MOVL	MMG$GL_SPTBASE-EXE$A_SYSPARAM(R2),R1 ;GET ADDR OF SPT
	MOVL	#<PTE$M_VALID!PTE$C_KW!PTE$M_PFN>,(R1)[R0] ;VALIDATE THIS ENTRY
	MOVL	R0,UCB$L_SVPN(R7)	;SET SYS PAGE NUMBER IN UCB
;
; INITIALIZE ALL THE CONTROL BLOCKS
;
INIT_DB:
	MOVL	R11,R4			;SET ADDR OF DRIVER PROLOGUE
	MOVL	R7,R5			;SET ADDR OF UCB
	JSB	G^IOC$INITDRV		;INIT THE CONTROL BLOCKS
	TSTL	DDB$L_DDT(R10)		;CHECK IF DDT EXISTS
	BEQL	10$			;IF EQL, BAD DDB
	BLBS	R0,70$			;BR IF SUCCESS
10$:	MOVL	#SYSG$_INVDPTINI,R0	;SET ERROR STATUS
	BRW	DB_ERROR		;...EXIT
;
; Relocate the DDT and FDT to SYSTEM VIRTUAL ADDRESSES.
;
70$:	PUSHL	R11			;SAVE DPT ADDRESS
	MOVL	R10,R11			;SET ADDRESS OF DDB
	JSB	G^IOC$RELOC_DDT		;RELOCATE DDT and FDT
	POPL	R11			;RESTORE DPT
;
; CALL THE CONTROLLER AND DRIVE INITIALIZATION ROUTINES
;
INIT_CNTRL:

	DSBINT				;DISABLE INTERRUPTS
	MOVL	#1,R0			;INSURE CSR TEST SEE SUCCESS EVEN IF
					;IOGEN$CNTRL_INI IS NOT CALLED
	BBC	#LOAD_V_CRB,W^LOAD_FLAGS,INIT_UNIT ;BR IF CRB NOT JUST CREATED
	MOVL	R10,R6			;SET ADDR OF DDB
	BSBW	IOGEN$CNTRL_INI		;INITIALIZE THE CONTROLLER
					;***BEWARE*** DON'T CORRUPT R0
					;BEFORE THE BLBC BELOW

INIT_UNIT:

	MOVL	R7,R5			;SETUP UCB ADDRESS
	BEQL	ENABLE_INT		;BRANCH IF NO UCB TO INIT
	MOVL	DDB$L_DDT(R10), -	;COPY DDT ADDRESS TO UCB
		UCB$L_DDT(R5)
	BLBC	R0,ENABLE_INT		;BRANCH IF ERROR TESTING CSR
					;(RETURNED BY IOGEN$CNTRL_INI ABOVE)
	PUSHL	R8			;SAVE IDB ADDRESS
	MOVL	R9,R8			;SETUP CRB ADDRESS
	JSB	G^IOC$UNITINIT		;CALL COMMON DRIVER UNIT INIT CALLER
	POPL	R8			;RESTORE IDB ADDRESS

ENABLE_INT:
	ENBINT				;RE-ENABLE INTERRUPTS

NEXT_UCB:
;
; Increment current unit number
; Loop through Create UCB code once for each unit
;
	TSTB	ACF$B_NUMUNIT(AP)	; TEST NO. OF UNITS TO CONFIGURE
	BEQL	DB_EXIT			; EXIT IF ZERO
	DECB	ACF$B_NUMUNIT(AP)	; DECREMENT NO. OF UNITS TO CONFIGURE
	BLEQ	DB_EXIT			; ALL DONE!
	INCW	ACF$W_CUNIT(AP)		; MOVE TO NEXT UNIT NO.
	BRW	CREATE_UCB		; AND LOOP

;
; OPERATION COMPLETED - UNLOCK I/O DATABASE AND EXIT
;
DB_EXIT:
	BSBW	IOGEN$UNLK_IODB		;UNLOCK I/O DATABASE
					; AND LOWER IPL
	MOVL	#1,R0			;SET SUCCESS
	RET				;...EXIT

	.PAGE
	.SBTTL	DB_ERROR - ERROR LOADING DATABASE
;++
;
; DB_ERROR - LOCAL ROUTINE TO UNLOAD A PARTIALLY LOADED DATABASE
;
;	This routine checks the loading flags (LOAD_FLAGS) and
;	unload and unlinks any control blocks that were just created.
;
; INPUTS:
;
;	LOAD_FLAGS = FLAGS INDICATING CONTROL BLOCKS THAT HAVE JUST
;		     BEEN CREATED
;
; OUTPUTS:
;
;	R0 = ERROR STATUS THAT CAUSED UNLOADING
;
;--
DB_ERROR:
	PUSHL	R0			;SAVE ERROR STATUS
;
; UCB UNLOADING
;
	BBC	#LOAD_V_UCB,W^LOAD_FLAGS,20$ ;BR IF UCB NOT CREATED
	CMPL	#SYSG$_MAXUNITS,R0	;WAS IT A MAXUNITS ERROR?
	BEQL	5$			;IF SO, NO BLINK
	CLRL	@W^UCB_BLINK		;CLEAR POINTER TO UCB
5$:	DECW	CRB$W_REFC(R9)		;DECREMENT CRB REFERENCE COUNT
	MOVZWL	ACF$W_CUNIT(AP),R0	;GET CONTROLLER UNIT NUMBER
	CLRL	IDB$L_UCBLST(R8)[R0]	;CLEAR IDB POINTER TO UCB
	MOVL	R7,R0			;SET ADDR OF UCB
	BSBB	10$			;DEALLOCATE THE UCB
	BRB	20$			;
;
; LOCAL SUBROUTINE TO DEALLOCATE A CONTROL BLOCK
;
; 	INPUT - R0 = ADDRESS OF BLOCK TO DEALLOCATE
;
10$:	JSB	G^EXE$DEANONPAGED	;DEALLOCATE TO NON-PAGED POOL
	RSB

;
; IDB UNLOADING
;
20$:	BBC	#LOAD_V_IDB,W^LOAD_FLAGS,30$ ;BR IF IDB NOT CREATED
	MOVL	R8,R0			;SET ADDR OF IDB
	BSBB	10$			;DEALLOCATE THE IDB
;
; CRB UNLOADING
;
30$:	BBC	#LOAD_V_CRB,W^LOAD_FLAGS,50$ ;BR IF CRB NOT CREATED
	BBC	#DPT$V_SUBCNTRL,DPT$B_FLAGS(R11),40$ ;BR IF NOT SUBCONTROLLER
	MOVL	CRB$L_LINK(R9),R1	;GET ADDR OF SECONDARY CRB
	MOVL	CRB$L_INTD+VEC$L_IDB(R1),R1 ;GET ADDR OF SECONDARY IDB
	MOVZBL	ACF$B_AUNIT(AP),R0	;GET ADAPTER UNIT NUMBER
	CLRL	IDB$L_UCBLST(R1)[R0]	;CLEAR DISPATCHER POINTER
40$:	MOVL	R9,R0			;SET ADDR OF CRB
	BSBB	10$			;DEALLOCATE THE CRB
;
; DDB UNLOADING
;
50$:	BBC	#LOAD_V_DDB,W^LOAD_FLAGS,60$ ;BR IF DDB NOT CREATED
	DECB	DPT$B_REFC(R11)		;DECREMENT DPT REFERENCE COUNT
	MOVL	DDB$L_LINK(R10),@W^DDB_BLINK;UPDATE THE DDB CHAIN
	MOVL	R10,R0			;SET ADDR OF DDB
	BSBB	10$			;DEALLOCATE THE DDB
60$:
	BSBW	IOGEN$UNLK_IODB		;UNLOCK THE I/O DATABASE
					; AND LOWER IPL
	POPL	R0			;RESTORE STATUS
	RET				;...EXIT

	.END
