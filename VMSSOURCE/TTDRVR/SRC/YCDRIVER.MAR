	.TITLE	YCDRIVER - Port Driver for DMF  Async
	.IDENT	'V04-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
;++
; FACILITY:
;
;	VAX/VMS TERMINAL DRIVER
;
; ABSTRACT:
;
;	DMF  ASYNC PORT DRIVER
;
; AUTHOR:
;
;	RICK SPITZ
;
; Revision history:
;
;	V03-032	WHM0003		Bill Matthews		24-Jul-1984
;		Set the device type field in the CRB.
;
;	V03-231	LMP0275		L. Mark Pilant,		12-Jul-1984  21:04
;		Initialize the ACL info in the ORB to be a null descriptor
;		list rather than an empty queue.  This avoids the overhead
;		of locking and unlocking the ACL mutex, only to find out
;		that the ACL was empty.
;
;	V03-030 EMD0089		Ellen M. Dusseault	30-Apr-1984
;		Add DEV$M_NNM characteristic to DEVCHAR2 so that these
;		devices will have the prefix "node$".
;
;	V03-029	LMP0221		L. Mark Pilant,		31-Mar-1984  10:23
;		Change UCB$L_OWNUIC to ORB$L_OWNER and UCB$W_VPROT to
;		ORB$W_PROT.
;
;	V03-028 MIR0360		Michael I. Rosenblum	20-Mar-1984
;		Add code to check for DMF honoring XON and XOFF.
;		Remove Callback to BURST_OUTPUT when resume is called
;		This illiminates unnecessry interrupts when the silo
;		Goes empty and we get a control-Q.
;
;	V03-027	WHM0002		Bill Matthews	29-Feb-1984
;		Second part of change to control_init to support
;		multiple comm devices on one board.
;
;	V03-026	WHM0001		Bill Matthews		28-Dec-1983
;		Use IDB$B_COMBO_VECTOR and IDB$B_COMBO_CSR_OFFSET to find
;		the start of the combo device's CSR and load the soft
;		interrupt vector.
;
;	V03-025	JLV0318		Jake VanNoy		 9-DEC-1983
;		comment out DPT_STORE for parity to fix build problem.
;
;	V03-024	MIR0083		Michael I. Rosenblum		02-Aug-1983
;		Add Field test DMZ-32 support.  Remove local def of
;		IO$M_AUTXOF_ENA and IO$M_AUTXOF_DIS and move them into STARDEF.
;
;	V03-023	MIR0062		Michael I. Rosenblum		30-Jun-1983
;		Change controler and unit init to use newly defined
;		macros.  Remove code that looked at the logical UCB
;		(code moved to the class drivers setup ucb and transition
;		routine) Remove into the class driver on resume with nothing
;		to resume.
;
;	V03-022	MIR0060		Michael I. Rosenblum		 1-Jun-1983
;		Add code to combat against silo full conditions and spurious
;		DMA completeion interupts.
;
;	V03-021	MIR0050		Michael I. Rosenblum		11-May-1983
;		Remove STOP2 entery point (no longer necessary)
;		add code in set_line to allow the use of the auto xon xoff
;		feature of the dmf.  Fix bug that would cause setting of the
;		XON bit not to restart a write.
;
;	V03-020	RKS0020		RICK SPITZ			14-MAR-1983
;		ADD ENHANCEMENTS TO SUPPORT LOGICAL UCB
;
;	V03-019	RKS0019		RICK SPITZ			1-FEB-1983
;		DMA CODE HAS BEEN MOVED INTO THE DMF PORT DRIVER. THIS
;		CODE HAS BEEN REMOVED FROM THE CLASS LEVEL. ALL OUTPUT
;		FROM CLASS TO PORT IS NOW HANDLED USING THE SAME INTERFACE.
;		RESUME LOGIC HAS BEEN CHANGED TO INSURE INT IS ON DURING
;		DMA BURST AND BYTE COUNT = 0 TO INSURE NO NEW OUTPUT IS
;		STARTED DURING THAT WINDOW.
;
;	V03-018	MIR0022		Michael I. Rosenblum		18-Jan-1983
;		Replace old vector table with new vector table macro.
;		Remove references to UCB$L_DEVDEPEND and UCB$Q_TT_STATE
;		move these references into the class driver jacket routines
;
;	V03-017	MIR0017		Michael I. Rosenblum		04-Jan-1983
;		Add powerfail check in the Unit init routine to allow the
;		terminal class drier to take positive action on powerfail.
;
;	V03-016	MIR0016		Michael I. Rosenblum		29-Dec-1982
;		Replace time calculation code with TIMSET macro call.
;
;	V03-015 MIR0015		Michael I. Rosenblum	22-Dec-1982
;		Change code in YC$DISCONNECT to reflect the change
;		in functionality.  Remove code that referenced
;		DMAABO and DMA  state bits.
;
;	V03-014	MIR0014		Michael I. Rosenblum	17-Dec-1982
;		move code to figure out what flow control character
;		to send to TTYSUB.
;
;	V03-013	RKS0013		RICK SPITZ		18-OCT-1982
;		CORRECT SENSE OF PARITY BIT
;
;	V03-010	RKS0012		RICK SPITZ		16-SEP-1982
;		Remove check for powerfail in unit init which prevents
;		SETUP_UCB from being called. This is needed to allow
;		Unibus switches to connect a line and then switch the
;		device on the bus, followed by a psuedo powerfail recovery.
;
;		Check reference count in unit init to determine if
;		modem control should be initialized or hungup. This
;		is needed to insure that a hangup ^Y is posted on
;		powerfail on modem lines.
;
;		Refrain from clearing INT in the port abort logic.
;		This prevents output data following a flush from being
;		lost during a small time window.
;		The DMF will interrupt on silo flush complete, at
;		which point INT will be handled.
;
;	V03-009	KDM0002		Kathleen D. Morse	28-Jun-1982
;		Added $DEVDEF and $SSDEF.
;
;	V03-008	RKS008		RICK SPITZ		23-MAR-1982
;		USE SYSGEN VALUE FOR COMBO INPUT SILO TIMER.
;		CHANGE OUTPUT DELAY.
;
;	V03-007	RKS007		RICK SPITZ		13-FEB-1982
;		ADD DELAY LOGIC WHEN OUTPUTING TO TRANSMIT SILO
;
;	V03-006	RKS0006		RICK SPITZ		8-FEB-1982
;		DO NOT ALLOW UNLOAD
;		FIX CHARACTER TIMER
;		DO UNSIGNED COMPARISON IN SILO OUTPUT.
;
;	V03-005	RKS0005		RICK SPITZ		11-JAN-1982
;		REPAIR MODEM INTERRUPT LOGIC
;		ADD INPUT SILO TIMER.
;
;	V03-004	RKS0004		RICK SPITZ		15-DEC-1981
;		FIX MAINTENANCE BIT OFFSETS, ADD EXTERNAL LOOP SUPPORT.
;		ENHANCE RESUME LOGIC IN DMA MODE TO AVOID WRITING 0 BYTE
;		COUNT. 
;		USE SYSPARAM VALUES FOR CLASS DRIVER LOCATION,PARITY,RSPEED
;		CHANGE TYPE CODE TO DMF-32.
;
;	V03-003	JLV0104		Jake VanNoy		27-Oct-1981
;		Changed TTYDEFS to $TTYDEFS.
;
;	V03-002	RKS002		RICK SPITZ			8-OCT-1981
;		USE SUBTRACT TO COMPUTE VECTOR ADDRESS TO BE LOADED INTO
;		DMF-32 VECTOR REGISTER.
;
;
;--
	.PAGE
	.SBTTL	DECLARATIONS

;
; EXTERNAL DEFINITIONS:
;
	$ACBDEF				; DEFINE ACB
	$CRBDEF				; DEFINE CRB
	$DCDEF				; DEFINE ADAPTER TYPES
	$DDBDEF				; DEFINE DDB
	$DEVDEF				; DEFINE DEVICE TYPES
	$DYNDEF				; DEFINE DYNAMIC STRUCTURE TYPES
	$IDBDEF				; DEFINE IDB OFFSETS
	$IODEF				; DEFINE I/O FUNCTION CODES
	$IRPDEF				; DEFINE IRP
	$ORBDEF				; DEFINE OBJECT'S RIGHTS BLOCK OFFSETS
	$SSDEF				; DEFINE SYSTEM STATUS CODES
	$TTYDEF				; DEFINE TERMINAL DRIVER SYMBOLS
	$TTDEF				; DEFINE TERMINAL TYPES
	$TT2DEF				; DEFINE EXTENDED CHARACTERISTICS
	$TQEDEF				; DEFINE TIMER QUEUE OFFSETS
	$UCBDEF				; DEFINE UCB
	$UBADEF				; DEFINE UBA
	$VECDEF				; DEFINE VECTOR FOR CRB
	$TTYMACS			; DEFINE TERMINAL DRIVER MACROS
.show me
	$TTYDEFS			; DEFINE TERMINAL DRIVER SYMBOLS
.noshow me
	$TTYMODEM			; DEFINE MODEM DEFINITIONS


;
; LOCAL STORAGE
;
	.PSECT	$$$105_PROLOGUE

;
; Driver prologue table:
;

YC$DPT::				; DRIVER START
	DPTAB	-			; DRIVER PROLOGUE TABLE
		END=YC$END,-		; End and offset to INIT's vectors
		UCBSIZE=UCB$C_TT_LENGTH,- ; SIZE OF UCB
		FLAGS=DPT$M_NOUNLOAD,-	; NO UNLOAD ALLOWED
		ADAPTER=UBA,-		; ADAPTER TYPE
		DEFUNITS=8,-		; Number of units to create
		NAME=YCDRIVER,-		; NAME OF DRIVER
		VECTOR=PORT_VECTOR	; PORT DRIVER VECTOR TABLE
	DPT_STORE INIT
	DPT_STORE UCB,UCB$B_FIPL,B,8	; FORK IPL
	DPT_STORE UCB,UCB$L_DEVCHAR,L,<-; CHARACTERISTICS
			DEV$M_REC!-	;
			DEV$M_AVL!-	;
			DEV$M_IDV!-	;
			DEV$M_ODV!-	;
			DEV$M_TRM!-	;
			DEV$M_CCL>
    	DPT_STORE UCB,UCB$L_DEVCHAR2,L,-; DEVICE CHARACTERISTICS
    			<DEV$M_NNM>	; PREFIX WITH "NODE$"
	DPT_STORE UCB,UCB$B_DEVCLASS,B,DC$_TERM;
	DPT_STORE UCB,UCB$B_TT_DETYPE,B,TT$_UNKNOWN	; TYPE
	DPT_STORE UCB,UCB$W_TT_DESIZE,@W,TTY$GW_DEFBUF	; BUFFER SIZE
	DPT_STORE UCB,UCB$L_TT_DECHAR,@L,TTY$GL_DEFCHAR	; DEFAULT CHARACTERS
	DPT_STORE UCB,UCB$L_TT_DECHA1,@L,TTY$GL_DEFCHAR2; DEFAULT CHARACTERS
	DPT_STORE UCB,UCB$W_TT_DESPEE,@B,TTY$GB_DEFSPEED; DEFAULT SPEED
	DPT_STORE UCB,UCB$W_TT_DESPEE+1,@B,TTY$GB_RSPEED; DEFAULT RSPEED
	DPT_STORE UCB,UCB$B_TT_DEPARI,@B,TTY$GB_PARITY	; DEFAULT PARITY
;**	DPT_STORE UCB,UCB$B_TT_PARITY,@B,TTY$GB_PARITY	; DEFAULT PARITY
	DPT_STORE UCB,UCB$B_DEVTYPE,B,TT$_UNKNOWN	; TYPE
	DPT_STORE UCB,UCB$W_DEVBUFSIZ,@W,TTY$GW_DEFBUF	; BUFFER SIZE
	DPT_STORE UCB,UCB$L_DEVDEPEND,@L,TTY$GL_DEFCHAR	; DEFAULT CHARACTERS
	DPT_STORE UCB,UCB$L_DEVDEPND2,@L,TTY$GL_DEFCHAR2; DEFAULT CHARACTERS
	DPT_STORE UCB,UCB$W_TT_SPEED,@B,TTY$GB_DEFSPEED	; DEFAULT SPEED
	DPT_STORE UCB,UCB$W_TT_SPEED+1,@B,TTY$GB_RSPEED	; DEFAULT RSPEED
	DPT_STORE UCB,UCB$B_DIPL,B,21			; DEVICE IPL
	DPT_STORE UCB,UCB$L_TT_WFLINK,L,0		; Zero write queue.
	DPT_STORE UCB,UCB$L_TT_WBLINK,L,0		; Zero write queue.
	DPT_STORE UCB,UCB$L_TT_RTIMOU,L,0		; Zero read timed out disp.
	DPT_STORE ORB,ORB$B_FLAGS,B,-		; Protection block flags
			   <ORB$M_PROT_16>	; SOGW protection word
	DPT_STORE ORB,ORB$W_PROT,@W,TTY$GW_PROT ; Default allocation protection
	DPT_STORE ORB,ORB$L_OWNER,@L,TTY$GL_OWNUIC ; Default owner UIC
	DPT_STORE DDB,DDB$L_DDT,D,YC$DDT

	DPT_STORE REINIT
	DPT_STORE CRB,CRB$L_INTD+4,D,YC$INTINP	; RECEIVER INTERRUPT
	DPT_STORE CRB,CRB$L_INTD2+4,D,YC$INTOUT	; TRANSMITTER INTERRUPT
	DPT_STORE CRB,CRB$L_INTD+VEC$L_INITIAL,D,YC$INITIAL  ; CONTROLLER INIT
	DPT_STORE CRB,CRB$L_INTD+VEC$L_UNITINIT,D,YC$INITLINE; UNIT INIT
	DPT_STORE END

	DDTAB	DEVNAM = YC,-	; DUMMY DMF PORT DRIVER DISPATCH TABLE
		START  = 0,-
		FUNCTB = 0

	.PSECT	$$$115_DRIVER,LONG

;
; THE ASSOCIATED CLASS DRIVER USES THIS TABLE TO COMMAND THE PORT DRIVER.
; THE ADDRESS OF THIS TABLE IS CONTAINED IN THE TERMINAL UCB EXTENSION AREA.
; THE OFFSET DEFINITONS ARE DEFINED BY TTYDEFS.
;
YC$L_SIL_ERROR:
	.LONG	0
YC$L_ERROR:
	.LONG	0
YC$L_DMAXMT_ERROR:
	.LONG	0
PORT_VECTOR:			

;
; DMF SPECIFIC DISPATCH TABLE
;
	$VECINI	YC,YC$NULL
	$VEC	STARTIO,YC$STARTIO		; START NEW OUTPUT
	$VEC	SET_LINE,YC$SET_LINE		; SET NEW SPEED/PARITY
	$VEC	DS_SET,YC$DS_SET		; SET OUTPUT MODEM SIGNALS
	$VEC	XON,YC$XON			; SEND XON SEQUENCE
	$VEC	XOFF,YC$XOFF			; SEND XOFF SEQUENCE
	$VEC	STOP,YC$STOP			; STOP OUTPUT
	$VEC	ABORT,YC$ABORT			; ABORT OUTPUT IN PROGRESS
	$VEC	RESUME,YC$RESUME		; RESUME STOPPED OUTPUT
	$VEC	MAINT,YC$MAINT			; INVOKE MAINTENANCE FUNCTION
	$VEC	FORKRET,YC$FORK			; PORT FORK CALLBACK
	$VECEND


;
YC$NULL:					; NULL PORT ROUTINE
	RSB

	.PAGE
	.SBTTL	REGISTER DEFINITIONS
 
;
; CSR BIT DEFINITIONS ( CSR ) ( READ/WRITE )
; (NOTE: THIS REGISTER MUST ONLY BE READ IN RESPONSE TO A TRANSMIT INTERRUPT.
;	TO LOAD AN INDIRECT REGISTER, ONLY WRITE OPERATIONS MAY BE USED)
       
	$VIELD	DMFCSR,0,<-
		<IADDR,5,M>,-	; INDERECT REGISTER ADDRESS
		<CLEAR,1,M>,-	; MASTER RESET
		<RCVINT,1,M>,-	; RECEIVER INTERRUPT ENABLE
		<,1,>,-		; DON'T USE THIS BIT
		<LINE,3,M>,-	; LINE NUMBAE (0 - 7)
		<,1,>,-
		<DMAERR,1,M>,-	; DMA TRANSMIT ERROR
		<,1,>,-
		<SNDINT,1,M>,-	; TRANSMIT INTERRUPT ENABLE
		<SNDRDY,1,M>-	; TRANSMITTER READY
		> 
;
; RECEIVER BUFFER ( CSR+4 ) ( READ ONLY )
;
	$VIELD	DMFRCV,0,<-
		<BUF,8,M>,-	; RECEIVER DATA
		<LINE,3,M>,-	; LINE NUMBER (0 - 7)
		<DS_CHG,1,M>,-	; DATA SET CHANGE INTERRUPT
		<PARERR,1,M>,-	; PARITY ERROR
		<FRAMER,1,M>,-	; FRAME ERROR
		<OVERRUN,1,M>,-	; OVERRUN ERROR
		<VALID,1,M>-	; DATA VALID
		> 
;
; LINE PARAMETER REGISTER ( CSR+2 ) ( WRITE ONLY )
;
 
	$VIELD	DMFLPR,0,<-
		<LINE,3,M>,-	; LINE NUMBER (0-7)
		<SIZE,2,M>,-	; CHARACTER SIZE
		<PARITY,1,M>,-	; PARITY ENABLE
		<ODD,1,M>,-	; ODD PARITY
		<STOP,1,M>,-	; NUMBER STOP BITS
		<RSPEED,4,M>,-	; RECEIVER LINE SPEED
		<TSPEED,4,M>,-	; TRANSMITTER LINE SPEED (BOTH RVC/TX FOR LINES 2-7)
		>
;
; LINE CONTROL INDIRECT REGISTER (INDIRECT REGISTER #2)
;

	$VIELD	DMFLCT,0,<-
		<XMIT,1,M>,-	; TRANSMIT ENABLE
		<AUTOX,1,M>,-	; AUTO XON/OFF 
		<RCV,1,M>,-	; RECEIVER ENABLE
		<BREAK,1,M>,-	; SEND BREAK
		<FLUSH,1,M>,-	; FLUSH OUTPUT SILO/ABORT TRANSMIT
		<DS_ENABLE,1,M>,- ; ENABLE MODEM TRANSITION INTERRUPTS
		<MAINT,2,M>,-	;
		<,7,>,-
		<PREMPT,1,M>,-	; PREMPT CURRENT OUTPUT
		>

;
; MACRO USED TO ACCESS INDIRECT REGISTERS
;

	.MACRO	GETIND	OFFSET,RX
	MOVL	UCB$L_CRB(R5),R0			; GET CRB ADDRESS
	MOVL	@CRB$L_INTD+VEC$L_IDB(R0),R0		; GET CSR ADDRESS
	BISW3	#<<^X4040>+<OFFSET*8>>,UCB$W_UNIT(R5),(R0); SELECT INDIRECT FIELD
	.IF	NB	RX
	MOVW	6(R0),RX				; GET CONTENTS OF INDIRECT FIELD
	.ENDC
	.ENDM	GETIND

;	OUTPUT DELAY MACRO
;	TO RELEASE THE UNIBUS

	.MACRO	DELAY
	.REPEAT	3
	NOP
	.ENDR
	.ENDM

	.PAGE
	.SBTTL	CONTROLLER INITIALIZATION 



;++
; YC$INITIAL - INITIALIZE INTERFACE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS ENTERED AT SYSTEM STARTUP AND POWER RECOVERY.
;
; INPUTS:
;
;	R4 = ADDRESS OF THE UNIT CSR
;	R5 = IDB OF UNIT
;	R8 = ADDRESS OF THE UNIT CRB
;
; OUTPUTS:
;
;	R2 is destroyed.
;
; IMPLICIT INPUTS:
;
;	IPL = IPL$_POWER
;
;--
YC$INITIAL::				; INITIALIZE DMF UNIT
;
; SET UP CONTROLLER
;
	CLASS_CTRL_INIT YC$DPT,PORT_VECTOR; RELOCATE THE NECESSARY TABLES
25$:
	TSTB	CRB$B_TT_TYPE(R8)		; CONTROLLER TYPE INITIALIZED?
	BNEQ	30$				; IF NEQ YES
	MOVB	#DT$_DMF32,CRB$B_TT_TYPE(R8)	; ASSUME DMF32
	TSTB	IDB$B_COMBO_VECTOR_OFFSET(R5)	; DMF32 HAS A VECTOR OFFSET OF 16
	BNEQ	30$				; IF NEQ NO, MUST BE A DMZ32
	MOVB	#DT$_DMZ32,CRB$B_TT_TYPE(R8)	; SET CONTROLLER TYPE DMZ32
30$:
	CVTBL	IDB$B_COMBO_CSR_OFFSET(R5),R0	; GET THE OFFSET TO THE MAIN CSR
	SUBB3	IDB$B_COMBO_VECTOR_OFFSET(R5),-	; LOAD THE SOFT VECTOR
		IDB$B_VECTOR(R5),(R4)[R0]	;
	MOVW	#DMFCSR$M_CLEAR,(R4)		; CONTROLLER RESET

;
;	WAIT TILL CONTROLLER INITIALIZATION IS COMPLETE
;
	TIMEWAIT	#100,#DMFCSR$M_CLEAR,(R4),W,.FALSE.

	MOVW	#<<DMFCSR$M_RCVINT>!-	; ENABLE RECEIVER INTERRUPTS
		<DMFCSR$M_SNDINT>>,(R4)	; ENABLE TRANSMITTER INTERRUPTS
	BLBC	R0,YC$CTRL_ERROR


100$:
	MOVB	G^TTY$GB_SILOTIME,4(R4)	; INIT INPUT SILO TIMEOUT VALUE



	RSB

YC$CTRL_ERROR:
	RSB
	
	.PAGE
	.SBTTL	UNIT INITIALIZATION

; YC$INITLINE - UNIT INITIALIZATION
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE PERFORMS A SIMPLE UNIT INITIALIZATION.
;
; INPUTS:
;
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R4,R5 ARE PRESERVED.
;--

YC$INITLINE::				
	MOVAL	YC$VEC,R0		; GET THE DISPATCH TABLE ADDRESS
	CLASS_UNIT_INIT
	BISW	#UCB$M_ONLINE,UCB$W_STS(R5); SET ONLINE

10$:	ASHL	UCB$W_UNIT(R5),#1,R3	; BUILD UNIT'S BIT MASK
	MOVW	R3,UCB$W_TT_UNITBIT(R5)	; SAVE IT

	BISW	#TTY$M_PC_DMAAVL!TTY$M_PC_XOFAVL,-; SHOW DMA FEATURE AVAILABLE FOR USE
		UCB$W_TT_PRTCTL(R5)	; IN PORT LEVEL

	MOVL	UCB$L_TT_CLASS(R5),R1	; ADDRESS CLASS VECTOR TABLE
	JSB	@CLASS_SETUP_UCB(R1)	; INIT UCB FIELDS

;SET MODE CODE NEEDS TO TOGGLE THESE BITS

	JSB	YC$SET_LINE		; INIT SPEED/PARITY
	

;
; ENABLE LINE RECEIVER , TRANSMITTER AND MODEM INTERRUPTS
;

	BISW3	#^X4048,UCB$W_UNIT(R5),(R4)	; SELECT LCT
	MOVW	#<<DMFLCT$M_XMIT>!-		; ENABLE TRANSMIT
		<DMFLCT$M_RCV>!-		; ENABLE RECEIVE
		<DMFLCT$M_DS_ENABLE>>,6(R4)	; AND MODEM INTERRUPTS
;
; INIT RECEIVER MODEM STATUS FOR DMF
;
	
	BISW3	#^X4040,UCB$W_UNIT(R5),(R4)	; SELECT RECV MODEM INDIRECT REG
	MOVB	7(R4),UCB$B_TT_DS_RCV(R5)	; UPDATE RECEIVER MODEM STATUS

25$:
	MOVZBL	#MODEM$C_INIT,R1	; ASSUME INIT MODEM PROTOCOL
	MOVL	UCB$L_TT_CLASS(R5),R0	; ADDRESS CLASS VECTOR TABLE
	JSB	@CLASS_DS_TRAN(R0)	; INVOKE TO INIT MODEM PROTOCOL
30$:
	BBC	#UCB$V_POWER,UCB$W_STS(R5),40$; DID WE DETECT A POWER FAIL
	MOVL	UCB$L_TT_CLASS(R5),R0	; GET THE CLASS VECTOR TABLE ADDRESS
	JMP	@CLASS_POWERFAIL(R0)	; AND GOTO THE POWERFAIL CODE

40$:	RSB
;
; ERROR DETECTED DURING INITIALIZATION
;

YC$UNIT_ERROR:
	BICW	#UCB$M_ONLINE,UCB$W_STS(R5)	; UNIT NOT ON LINE
	RSB

	.PAGE
	.SBTTL	MAINTENANCE ROUTINES
;++
; YC$MAINT - MAINTENANCE FUNCTIONS
;
; FUNCTIONAL DESCRIPTION:
; THIS ROUTINE PERFORMS MAINTENANCE FUNCTIONS FOR THE DMF
; (LOOPBACK IS ONLY ALLOWED ON LINES 0 AND 1)
;
; INPUTS:
;
;	R5 = UBC ADDRESS
;	UCB$B_TT_MAINT = FUNCTION TO BE PERFORMED
;
; OUTPUTS:
;	R0-R4 SCRATCH
;--

YC$MAINT:
	BITB	#IO$M_LOOP@-7,-			; LOOPBACK FUNCTION
		UCB$B_TT_MAINT(R5)	
	BEQL	5$				; NO
	MOVW	#TT$M_DS_DTR!TT$M_DS_RTS,-	; SET REQUIRED MODEM LINES
		R2
	JSB	YC$DS_SET			; SET THEM TO ALLOW LOOPBACK
	MOVZWL	#^X02,R2			; SPECIFY LOOPBACK CODE
	BRB	10$
5$:
	BITB	#IO$M_UNLOOP@-7,-		; RESET LOOPBACK FUNCTION
		UCB$B_TT_MAINT(R5)	
	BEQL	15$				; NO
	MOVW	#256*<TT$M_DS_DTR!TT$M_DS_RTS!^X01>,-; RESET REQUIRED MODEM LINES
		R2
	JSB	YC$DS_SET			; SET THEM TO ALLOW LOOPBACK
	MOVZWL	#^X00,R2			; SPECIFY UNLOOP CODE
10$:
	MOVL	UCB$L_CRB(R5),R1		; GET THE CRB ADDRESS
	CMPB	#DT$_DMZ32,CRB$B_TT_TYPE(R1)	; IS THIS A DMZ
	BEQL	12$				; YES THEN MODEM CONTROL ON ALL UNITS
	CMPW	#2,UCB$W_UNIT(R5)		; ALLOWED ON THIS UNIT?
	BLEQ	50$				; NO
12$:	GETIND	1,R1				; GET INDIRECT FIELD
	INSV	R2,#DMFLCT$V_MAINT,#2,R1	; SET MAINT FIELD
	MOVW	R1,6(R0)			; UPDATE
	MOVZBL	#1,R0				; INDICATE SUCCESS
	RSB
50$:
	CLRL	R0
	RSB

15$:
	BITB	#IO$M_AUTXOF_ENA@-7,-
		UCB$B_TT_MAINT(R5)		;AUTOXON ENABLED
	BEQL	17$				; NO THEN MAYBE DISABLE
	BISW	#TTY$M_PC_XOFAVL,-
		UCB$W_TT_PRTCTL(R5)		; SET THE BIT AVAILABLE

17$:	BITB	#IO$M_AUTXOF_DIS@-7,-
		UCB$B_TT_MAINT(R5)		;AUTOXON disabled
	BEQL	19$				; no then don't disable it
	BICW	#TTY$M_PC_XOFAVL,-
		UCB$W_TT_PRTCTL(R5)

19$:

	BITB	#IO$M_LOOP_EXT@-7,-		; LOOPBACK FUNCTION
		UCB$B_TT_MAINT(R5)	
	BEQL	20$				; NO
	MOVW	#<TT$M_DS_DTR!TT$M_DS_RTS!^X01>,-; SET REQUIRED MODEM LINES
		R2
	JSB	YC$DS_SET			; SET THEM TO ALLOW LOOPBACK
	MOVZWL	#^X00,R2			; SPECIFY  NO LOOPBACK CODE
	BRB	10$
20$:						; CHECK OTHER FUNCTIONS
	BITB	#IO$M_LINE_OFF@-7,-		; LINE OFF
		UCB$B_TT_MAINT(R5)
	BEQL	30$				; NO
	GETIND	1,R1				; GET FIELD
	BICW	#<<DMFLCT$M_XMIT>!-		; DISABLE TRANSMIT AND RECEIVE
		<DMFLCT$M_RCV>>,R1
	MOVW	R1,6(R0)			; UPDATE
	BRB	40$
30$:
	BITB	#IO$M_LINE_ON@-7,-		; LINE ON
		UCB$B_TT_MAINT(R5)
	BEQL	50$				; NO
	GETIND	1,R1				; GET FIELD
	BISW	#<<DMFLCT$M_XMIT>!-		; ENABLE TRANSMIT AND RECEIVE
		<DMFLCT$M_RCV>>,R1
	MOVW	R1,6(R0)			; UPDATE

40$:	MOVZBL	#1,R0
	RSB


	.PAGE
	.SBTTL	OUTPUT MODEM CONTROL
;++
; YC$DS_SET - SET OUTPUT MODEM SIGNALS
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE OUTPUTS THE OUTPUT MODEM SIGNALS FOR THE SPECIFIED UNIT
;
; INPUTS:
;
;	R2 = LOW BYTE - SIGNALS TO ACTIVATE
;	     HIGH BYTE- SIGNALS TO DEACTIVATE
;	
;	R5 = UCB ADDRESS
;	
; OUTPUTS:
;
;	R0-R3 ARE USED.
;--

YC$DS_SET:
	BISB	R2,UCB$B_TT_DS_TX(R5)	; SET NEW OUTPUT SIGNALS
	ASHL	#-8,R2,R2		; ACCESS SIGNALS TO RESET
	BICB	R2,UCB$B_TT_DS_TX(R5)	; RESET THEM
	GETIND	1,-(SP)
	BICB3	#^X0E0,UCB$B_TT_DS_TX(R5),- ; OR IN OUTPUT MODEM SIGNALS
		1(SP)
	MOVW	(SP)+,6(R0)		; OUTPUT UPDATED VALUE
	RSB


	.PAGE
	.SBTTL	RECEIVER INTERRUPT SERIVCE
;++
; YC$INTINP - DMF RECEIVER READY INTERRUPTS
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS ENTERED WHEN A CHARACTER IS AVAILABLE IN THE UNIT'S
; SILO. THE CHARACTER IS EXTRACTED AND IS PASSED TO THE ASSOCIATED
; CLASS DRIVER. IF THE CLASS DRIVER RETURNS CHARACTERS(S) THEN NEW
; OUTPUT IT INITIATED (NORMALLY ECHO).
;
; INPUTS:
;
;	00(SP) = ADDRESS OF IDB
;
; IMPLICIT INPUTS:
;
;	R0,R1,R2,R3,R4,R5 ARE SAVED ON STACK.
;
; OUTPUTS:
;
;	THE INTERRUPT IS DISMISSED WHEN THE SILO IS EMPTY.
;
;--
YC$INTINP::				; DMF INPUT INTERRUPTS
;
; GET THE CSR ADDRESS
;
	MOVL	@(SP)+,R4		; GET THE IDB ADDRESS
	PUSHL	R4			; SAVE IDB ADDRESS
	MOVL	(R4),R0			; GET THE CSR ADDRESS
;
; GET THE CHARACTER FROM THE INTERFACE
;
25$:	MOVW	4(R0),R3		; GET THE CHARACTER,ERRORS AND LINE NUMBER
	BGEQ	100$			;SILO EMPTY
	BITW	#<DMFRCV$M_PARERR>!-
		<DMFRCV$M_OVERRUN>!-
		<DMFRCV$M_FRAMER>!-
		<DMFRCV$M_DS_CHG>,R3	;ERRORS OR MODEM TRANSITION ?
		
	BNEQ	50$			;YES,PROCESS THEM
27$:	ASHL	#-8,R3,R2		; GET THE LINE NUMBER
	BICL	#^C<7>,R2		; 
	MOVZBL	R3,R3			; CLEAR THE HIGH BYTES OF CHARACTER
	MOVL	IDB$L_UCBLST(R4)[R2],R5	; GET THE UCB FOR THAT LINE
	BEQL	25$			; IF EQL THEN NOT THERE
	JSB	@UCB$L_TT_PUTNXT(R5)	; BUFFER THE CHARACTER
	BLEQ	40$			; NONE OR STRING OUTPUT
	BISW3	#^X4040,UCB$W_UNIT(R5),(R0)	; SELECT OUTPUT SILO INDIRECT REGISTER
	MOVB	R3,6(R0)		; OUTPUT CHARACTER
30$:	MOVL	(SP),R4			; GET IDB ADDRESS
	BRB	25$			; CONTINUE
40$:
	BEQL	30$			; NO CHARACTER
	JSB	BURST_OUTPUT		; START BURST
	BRB	30$
;
50$:
;
; PROCESS PARITY, FRAME OVERRUN ERROR OR MODEM TRANSITION
;
	ASHL	#-8,R3,R2		; GET LINE NUMBER
	BICL	#^C<7>,R2		;
	MOVL	IDB$L_UCBLST(R4)[R2],R5	; GET UCB ADDRESS
	BEQL	70$			; IF EQL THEN NO UCB
	BBS	#DMFRCV$V_DS_CHG,R3,200$; MODEM TRANSITION
	MOVL	UCB$L_TT_CLASS(R5),R2	; GET CLASS DISPATCH
	JSB	@CLASS_READERROR(R2)	; SIGNAL ERROR
	BNEQ	27$			; CHRRACTER TO ECHO
70$:
	BRB	30$

100$:	ADDL	#4,SP			; REMOVE IDB ADDRESS
	MOVQ	(SP)+,R0		; RESTORE REGISTERS
	MOVQ	(SP)+,R2		;
	MOVQ	(SP)+,R4		;
	REI
200$:
	BISW3	#^X4040,R2,(R0)		; SELECT MODEM INDIRECT REGISTER
	MOVZBL	7(R0),R2		; GET CURRENT RECEIVE MODEM SIGNALS
	MOVB	R2,UCB$B_TT_DS_RCV(R5)	; UPDATE CURRENT INPUT MODEM SIGNALS
	MOVZBL	#MODEM$C_DATASET,R1	; TRANSITION TYPE IS DATASET 
	PUSHL	R0			; SAVE CSR ADDRESS
	MOVL	UCB$L_TT_CLASS(R5),R4	; GET CLASS DISPATCH
	JSB	@CLASS_DS_TRAN(R4)	; INVOKE TRANSITION ROUTINE
	POPL	R0			; RESTORE CSR ADDRESS
	BRW	30$
	

	.PAGE
	.SBTTL	 START I/O ROUTINE
;++
; YC$STARTIO - START I/O OERATION ON DMF
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS ENTERED FROM THE DEVICE INDEPENDENT TERMINAL STARTIO
; ROUTINE TO ENABLE OUTPUT INTERRUPTS ON AN IDLE DMF UNIT.
;
; INPUTS:
;
;	R3 =	CHARACTER	AND	CC = PLUS
;		ADDRESS		AND	CC = NEGATIVE
;
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R5 = UCB ADDRESS
;--
	.ENABLE	LSB
YC$STARTIO::				; START I/O ON UNIT
	BGEQ	90$			; SINGLE CHARACTER
	MOVL	UCB$L_CRB(R5),R0	; GET CRB OF UNIT
	MOVL	@CRB$L_INTD+VEC$L_IDB(R0),R0; GET CSR

BURST_OUTPUT:
	MOVZWL	UCB$W_TT_OUTLEN(R5),R2	; GET LENGTH
	BBC	#TTY$V_PC_DMAENA,-	; USE SILO IF DMA NOT ENABLED ON THIS LINE
		UCB$W_TT_PRTCTL(R5),SILO_OUTPUT
	CMPW	R2,G^TTY$GW_DMASIZE	; LARGE ENOUGH FOR DMA
	BGEQ	DMA_START		; YES SO DO DMA

SILO_OUTPUT:
	BISW3	#^X4040,UCB$W_UNIT(R5),(R0); SELECT TRANSMIT SILO
	MOVZBL	6(R0),R1		; GET SILO DEPTH
	SUBL3	R1,#32,R1			; CONVERT TO NUMBER SLOTS AVAILABLE

	CMPW	R2,R1			; BURST LARGER THAN SILO?
	BLEQU	50$			; NO
	MOVZBL	R1,R2			; SLOTS AVAILABLE IS MAXIMUM
50$:
	MOVL	UCB$L_TT_OUTADR(R5),R3	; GET ADDRESS
	ADDL	R2,UCB$L_TT_OUTADR(R5)	; UPDATE POINTER
	SUBW	R2,UCB$W_TT_OUTLEN(R5)	; AND COUNT
	BEQL	60$			; ALL DONE, NO NEED FOR BURST
	BISW	#TTY$M_TANK_BURST,-	; SIGNAL BURST ACTIVE
		UCB$W_TT_HOLD(R5)
60$:
	BLBC	R2,70$			; EVEN TRANSFER
	MOVB	(R3)+,6(R0)		; OUTPUT ODD BYTE
	DECL	R2			; UPDATE COUNT
	BEQL	80$			; DONE
70$:
	ASHL	#-1,R2,R2		; CONVERT TO WORD COUNT
75$:
	MOVW	(R3)+,6(R0)
	DELAY				; TO RELEASE THE UNIBUS
	SOBGTR	R2,75$			; LOOP TILL DONE

80$:	RSB				; RETURN TO CALLER

90$:
	BEQL	100$			; SKIP IF NONE
	GETIND	0			; SELECT OUTPUT SILO
	MOVB	R3,6(R0)		; OUTPUT CHARACTER
100$:
	RSB
	.DISABLE	LSB

	.PAGE
	.SBTTL	PORT DMA ROUTINES
;++
; DMA_START	-	INITIATE DMA OUTPUT
;
; FUNCTIONAL DESCRIPTION:
;
; THESE ROUTINES ARE CALLED BY THE PORT INPUT INTERRUPT, OUTPUT
; INTERRUPT, AND STARTIO TO INITIATE NEW DAM OUTPUT.
; THEY HANDLE ALLOCATION AND LOADING OF MAP REGISTERS
; TO HANDLE DMA OUTPUT. MAP REGISTERS ARE ALLOCATED IN PAIRS
; TO ALLOW OUTPUT BURSTS UP TO 512 BYTES. TRANSFERS LARGER THAN
; THAT ARE DONE IN SEGMENTS. IF INSUFFICIENT MAPS ARE AVAILABLE,
; THE TRANSFER IS DONE SILO MODE.
;
;
; INPUTS:
;
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R5 = UCB ADDRESS
;
;	R0 PRESERVED
;	R1,R2,R3,R4 DESTROYED
;--
DMA_START:
	BISW	#TTY$M_TANK_DMA,-	; SHOW DMA MODE ACTIVE
		UCB$W_TT_HOLD(R5)
	BICB	#TTY$M_TP_ABORT,-	; RESET ANY OLD ABORT REQUESTS
		UCB$B_TP_STAT(R5)

;	CHECK IF UNIT HAS PERMANENT MAP REGISTERS
	
	BBC	#TTY$V_PC_PRMMAP,-	; SKIP IF NOT AUTHORIZED FOR PERM MAPS
		UCB$W_TT_PRTCTL(R5),5$
	BBS	#TTY$V_PC_MAPAVL,-	; SKIP FORK IF MAPS ALLOCATED ALREADY
		UCB$W_TT_PRTCTL(R5),DMA_CONTINUE
5$:
	BISB	#TTY$M_TP_ALLOC,-	; SHOW ALLOC FORK ACTIVE
		UCB$B_TP_STAT(R5)
	MOVL	UCB$L_TT_CLASS(R5),R1	; GET CLASS VECTOR ADDRESS
	JSB	@CLASS_FORK(R1)		; FORK TO FIPL FOR MAP
					; REGISTER ALLOCATION
	RSB				; RETURN TO CALLER WITH
					; "INT" LEFT ON TO INTERLOCK
					; OUTPUT. FORK ROUTINE WILL
					; RESUME AT DMA_ALLOC.
DMA_ALLOC:


5$:
	MOVZBL	#2,R3			; REQUEST 2 MAP REGISTERS
	JSB	G^IOC$ALOUBAMAPN	; 

	SETIPL	UCB$B_DIPL(R5)		; INTERLOCK TO DEVICE IPL
	BISW	#TTY$M_PC_MAPAVL,-	; SHOW MAP ALLOCATED
		UCB$W_TT_PRTCTL(R5)
	BICB	#TTY$M_TP_ALLOC,-	; SHOW ALLOC FORK DONE
		UCB$B_TP_STAT(R5)
	BLBS	R0,20$			; SUCCESS

	MOVL	UCB$L_CRB(R5),R0	; GET CRB OF UNIT
	MOVL	@CRB$L_INTD+VEC$L_IDB(R0),R0; GET CSR
	BICW	#TTY$M_TANK_DMA,-	; RESET DMA MODE
		UCB$W_TT_HOLD(R5)
	MOVZWL	UCB$W_TT_OUTLEN(R5),R2	; RESTORE OUTPUT LENGTH
	BRW	SILO_OUTPUT		; USE SILO FOR OUTPUT

20$:
	MOVL	UCB$L_CRB(R5),R0	; GET CRB ADDRESS
	MOVL	CRB$L_INTD+VEC$W_MAPREG(R0),-
		UCB$L_TP_MAP(R5)	; SAVE  MAP FIELD IN UCB


DMA_CONTINUE:
	BBS	#TTY$V_TP_ABORT,-	; BRANCH IF DMA TO BE ABORTED
		UCB$B_TP_STAT(R5),2$

	MOVL	UCB$L_TT_OUTADR(R5),R3	; GET ADDRESS OF NEXT STRING
	MOVZWL	UCB$W_TT_OUTLEN(R5),R2	; LENGTH OF OUTPUT
	BNEQ	4$			; SKIP IF MORE TO DO
2$:	BRW	DMA_DONE		; BRANCH IF TRANSFER IS DONE
4$:
	PUSHL	R0			; SAVE INPUT VOLITAL REGISTER "CSR"

	CMPL	R2,#512			; NEXT BURST TOO LONG FOR MAPS?
	BLEQ	5$			; NO
	MOVZWL	#512,R2


5$:	ADDL	R2,UCB$L_TT_OUTADR(R5)	; UPDATE CHARACTER POINTER FOR NEXT TIME
	SUBW	R2,UCB$W_TT_OUTLEN(R5)	; UPDATE COUNT FOR NEXT TIME

	TIMSET	R2,R1,LOCKOUTPUT	;RECOMPUTE TIMEOUT VALUE FOR THIS
					;PORTION OF THE DMA BURST


;		R3 - STRING ADDRESS
;		R2 - LENGTH
;		R5 - UCB

	PUSHR	#^M<R2,R5>
	MOVL	UCB$L_CRB(R5),R0	; GET CRB ADDRESS
	MOVL	@CRB$L_INTD+VEC$L_ADP(R0),R1	; CONFIG REGISTER
	EXTZV	#VEC$V_MAPREG,#VEC$S_MAPREG,-
		UCB$L_TP_MAP(R5),R0	; GET STARTING MAP REGISTER
	MOVAL	UBA$L_MAP(R1)[R0],R1	; GET 1ST MAP REGISTER ADDRESS
	
	BICL3	#^X80000000,R3,R4	; CALC SVAPTE OF BUFFER
	ASHL	#-9,R4,R4		; ISOLATE PAGE
	MOVL	G^MMG$GL_SPTBASE,R5	; GETS SVAPTE OF BUFFER
	MOVAL	(R5)[R4],R4		; INTO R4
	BICL	#^C^X1FF,R3		; COMPUTE BYTE OFFSET IN PAGE

;	LOAD MAP REGISTERS
;		R0 - MAP REGISTER NUMBER
;		R1 - ADDRESS OF FIRST MAP REGISTER
;		R2 - BUFFER LENGTH
;		R3 - BYTE OFFSET IN PAGE
;		R4 - SVAPTE OF BUFFER

	MOVZBL	#2,R2
10$:	MOVL	(R4)+,R5		; GET CONTENTS OF NEXT PTE

;	THIS CODE ASSUMES THAT DMA IS FROM NONPAGED POOL

	INSV	#^X400,#21,#11,R5	; SET VALID BIT, DATA PATH 0
	MOVL	R5,(R1)+		; LOAD INTO MAP REGISTER
	SOBGTR	R2,10$
		
	POPR	#^M<R2,R5>		; RESTORE LENGTH,WRITE BUFFER, UCB

	INSV	R0,#9,#9,R3		; COMPUTE UNIBUS ADDRESS
	EXTZV	#16,#2,R3,R0		; GET HIGH 2 UNIBUS ADDRESS BITS
	INSV	R0,#14,#2,R2		; MERGE WITH BYTE COUNT 

	GETIND	2			; SELECT DMA INDIRECT REGISTERS
	MOVW	R3,6(R0)		; LOAD ADDRESS (INDIRECT REGISTER
					; AUTO INCREMTS TO COUNT)
	MOVW	R2,6(R0)		; LOAD COUNT/ INIT TRANSFER

	POPL	R0			; RESTORE CSR ADDRESS
	RSB				; RETURN TO CALLER
					; FORK DISPATCHER, ISR, OR STARTIO

DMA_DONE:				; DMA COMPLETION


	BBS	#TTY$V_PC_PRMMAP,-	; SKIP FORK IF MAPS PERMANENT
		UCB$W_TT_PRTCTL(R5),DMA_POST
	BISB	#TTY$M_TP_DLLOC,-	; SHOW DEALLOC FORK ACTIVE
		UCB$B_TP_STAT(R5)
	MOVL	UCB$L_TT_CLASS(R5),R1	; GET CLASS VECTOR ADDRESS
	JSB	@CLASS_FORK(R1)		; SCHEDULE FORK TO FIPL FOR MAP
					; REGISTER DEALLOCATION
	RSB				; RETURN TO CALLER, FORK WILL RESUME
					; AT DMA_DEALLOC

DMA_DEALLOC:
	MOVL	UCB$L_CRB(R5),R0	; GET CRB ADDRESS
	MOVL	UCB$L_TP_MAP(R5),-
		CRB$L_INTD+VEC$W_MAPREG(R0); RESTORE MAP FIELD IN CRB
	BEQL	5$			; SKIP IF NONE
	JSB	G^IOC$RELMAPREG		; RELEASE MAP REGISTERS

5$:	SETIPL	UCB$B_DIPL(R5)		; INTERLOCK TO DEVICE IPL
	BICW	#TTY$M_PC_MAPAVL,-	; SHOW MAP ALLOCATED
		UCB$W_TT_PRTCTL(R5)
	BICB	#TTY$M_TP_DLLOC,- 	; SHOW DEALLOC FORK DONE
		UCB$B_TP_STAT(R5)			

DMA_POST:
	BICB	#TTY$M_TP_ABORT,- 	; RESET ABORT REQUEST
		UCB$B_TP_STAT(R5)			
	BICW	#TTY$M_TANK_DMA,-	; RESET DMA MODE
		UCB$W_TT_HOLD(R5)

;	CALL GETNEXT TO CONTINUE PROCESSING
;
	BICB	#UCB$M_TIM!UCB$M_INT,-	;CLEAR TIMEOUT AND INT EXPECTED
		UCB$W_STS(R5)		
	JSB	@UCB$L_TT_GETNXT(R5)	; GET NEXT BURST
	BRW	YC$STARTIO		; AND PROCEED

YC$FORK:				; 
	SAVIPL				; SAVE CURRENT IPL ON THE STACK
	PUSHAL	20$			; BUILD RETURN ADDRESS ON STACK
	BBC	#TTY$V_TP_ALLOC,-	; SKIP IF NOT ALLOCATE FORK
		UCB$B_TP_STAT(R5),10$
	BRW	DMA_ALLOC		; RESUME AT ALLOCATE CODE THREAD
10$:
	BBC	#TTY$V_TP_DLLOC,-	; CHECK FOR DEALLOCATE
		UCB$B_TP_STAT(R5),20$
	BRW	DMA_DEALLOC
20$:
	ENBINT				; RESTORE SAVED FORK IPL FROM STACK

	RSB


	.PAGE
	.SBTTL	PORT ROUTINES  STOP,RESUME,XON,XOFF
;++
; YC$XOFF -	SEND XOFF
; YC$XON -	SEND XON
; YC$STOP -	STOP OUTPUT
; YC$ABORT -	ABORT CURRENT OUTPUT
; YC$RESUME -	RESUME STOPPED OUTPUT
;
; FUNCTIONAL DESCRIPTION:
;
; THESE ROUTINES ARE USED BY THE THE TERMINAL CLASS DRIVER TO
; CONTROL OUTPUT ON THE PORT
;
; INPUTS:
;
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R5 = UCB ADDRESS
;--
;
; SCHEDULE XOFF OR XON TO BE SEND
;
; INPUTS:
;
;	R3 - CONTAINS THE CHARACTER TO SEND AS FLOW CONTROL.
;
YC$XOFF:
YC$XON:
	PUSHR	#^M<R0,R1>
	GETIND	1,R1
	BISW3	#DMFLCT$M_PREMPT,R1,6(R0)	; PREMPT ANY CURRENT OUTPUT
	BISW3	#^X4040,UCB$W_UNIT(R5),(R0)	; SELECT TRANSMIT SILO
	MOVB	R3,6(R0)			; OUTPUT CHARACTER
	POPR	#^M<R0,R1>
	RSB
;
; STOP PORT OUTPUT
;
YC$STOP:
	PUSHR	#^M<R0,R1>
	BICB	#UCB$M_INT!UCB$M_TIM,-		; RESET TIMER AND OUTPUT ACTIVE
		UCB$W_STS(R5)
	GETIND	1				; 

	BBC	#TTY$V_PC_XOFAVL,UCB$W_TT_PRTCTL(R5),10$; AUTOXON XOFF AVAILABLE ON THIS LINE
						; YES THEN IS
	BBS	#TTY$V_PC_XOFENA,UCB$W_TT_PRTCTL(R5),20$; AUTOXON XOFF ENABLED
10$:	BICW2	#DMFLCT$M_XMIT,6(R0)		; RESET TRANSMIT ENABLE	
20$:
	POPR	#^M<R0,R1>
	RSB
;
; ABORT ANY CURRENT PORT OUTPUT ACTIVITY
;
YC$ABORT:
	PUSHR	#^M<R0,R1>
	BBCC	#TTY$V_TANK_BURST,UCB$W_TT_HOLD(R5),-	; RESET BURST ACTIVE
		10$					; 
10$:
	GETIND	1
	BISW2	#<DMFLCT$M_XMIT>,6(R0)			; SET XMIT
	BBC	#UCB$V_INT,UCB$W_STS(R5),15$		; SKIP IF NOT BUSY.
	BISW2	#<DMFLCT$M_FLUSH>,6(R0)			; FLUSH OUTPUT
	BISB	#TTY$M_TP_ABORT,UCB$B_TP_STAT(R5)	; REQUEST DMA ABORT
15$:		
	POPR	#^M<R0,R1>
	RSB

;
; RESUME PREVIOUSLY STOPPED PORT OUTPUT
;
YC$RESUME:
	PUSHR	#^M<R0,R1,R2,R3>
	GETIND	1

	BBC	#TTY$V_PC_XOFAVL,UCB$W_TT_PRTCTL(R5),10$; AUTOXON XOFF AVAILABLE ON THIS LINE
						; NO THEN RESUME TRANSMITION
	BBS	#TTY$V_PC_XOFENA,UCB$W_TT_PRTCTL(R5),20$; AUTOXON XOFF ENABLED
							; YES THEN DON'T ENABLE THE TRANSMITTER
10$:	BISW2	#DMFLCT$M_XMIT,6(R0)			; ENABLE TRANSMIT
20$:	BBS	#UCB$V_INT,UCB$W_STS(R5),40$		; SKIP IF OUTPUT ON
	BBS	#TTY$V_TANK_DMA,-			; SPECIAL IF DMA ACTIVE
		UCB$W_TT_HOLD(R5),50$
	BBC	#TTY$V_TANK_BURST,UCB$W_TT_HOLD(R5),40$	; NO BURST IN PROGRESS
							; (RESET ANYWAY. WILL BE
							; SET IF NEEDED BY BURST_OUTPUT)
	BISW3	#^X4040,UCB$W_UNIT(R5),(R0)		; SELECT TRANSMIT SILO
	MOVZBL	6(R0),R1				; GET SILO DEPTH
	TIMSET	R1,R1,LOCKOUTPUT			; COMPUTE TIMEOUT AND
							; SET INTERUPT EXPECTED

40$:
	POPR	#^M<R0,R1,R2,R3>
	RSB

50$:
	BISW3	#^X4058,UCB$W_UNIT(R5),(R0)		; GET CURRENT BYTE COUNT
	MOVZWL	6(R0),R1
	BICW	#^X0C000,R1				; MASK OFF ADDRESS BITS
	TIMSET	R1,R1,LOCKOUTPUT			; COMPUTE TIMEOUT AND
							; SET INTERUPT EXPTECTEDD
	BRB	40$

	.PAGE
	.SBTTL	OUTPUT INTERRUPT SERVICE
;++
; YC$INTOUT - DMF OUTPUT INTERRUPT SERVICE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS ENTERED WHEN THE DMF FINDS A LINE ENABLED
; AND AN EMPTY UART. THE CORRESPONDING UCB IS FOUND AND 
; ANY OUTSTANDING PORT OUTPUT IS DONE. WHEN ALL OUTSTANDING PORT
; OUTPUT IS COMPLETED, THE CLASS DRIVER IS CALLED TO RETURN THE NEXT
; CHARACTER OR STRING TO BE OUTPUT. IF NO MORE OUTPUT IS FOUND, THEN
; THE LINE IS DISBALED.
;
; INPUTS:
;
;	SP(00) = ADDRESS OF THE IDB
;
; IMPLICIT INPUTS:
;
;	R0,R1,R2,R3,R4,R5 SAVED ON THE STACK.
;
; OUTPUTS:
;
;	THE INTERRUPT IS DISMISSED.
;
;--
YC_OUT_EXIT:				; EXIT OUTPUT INTERRUPT
	ADDL	#4,SP			; REMOVE IDB ADDRESS
	MOVQ	(SP)+,R0		; RESTORE REGISTERS
	MOVQ	(SP)+,R2		;
	MOVQ	(SP)+,R4		;
	REI				; DISMISS INTERRUPT

YC$INTOUT::				; DMF OUTPUT INTERRUPT SERVICE

YC_OUT_LOOP:
	MOVL	@(SP),R4		; GET THE IDB ADDRESS
	MOVL	(R4),R0			; GET THE CSR ADDRESS
;
; GET THE LINE INFO FROM THE CSR
;

	MOVW	(R0),R2			; GET THE CSR VALUE
	BGEQ	YC_OUT_EXIT		; NO MORE LINES
	ASHL	#-8,R2,R1		; GET THE LINE NUMBER
	BICL	#^C<7>,R1		;
	MOVL	IDB$L_UCBLST(R4)[R1],R5	; GET THE UCB ADDRESS
	BEQL	YC_OUT_LOOP		; IF EQL THEN DISMISS 
;
; CHECK TO MAKE SURE NO DATA IS PENDING BEFORE ASKING FOR MORE
;
	BISW3	#^X4040,UCB$W_UNIT(R5),(R0); GET THE SILO INDIRECT REGISTER
	TSTB	6(R0)			; ANY DATA STILL IN THE SILO
	BNEQ	40$			; YES THEN LET IT COMPLETE
;
;	CHECK FOR BURST OR DMA ACTIVE ON LINE
;

	CMPB	#TTY$M_TANK_BURST@-8,-	; ONLY BURST ACTIVE?
		UCB$W_TT_HOLD+1(R5)
	BEQL	YC_SILO			; YES, CONTINUE SILO OUTPUT

	BITB	#TTY$M_TANK_DMA@-8,-	; DMA ACTIVE?
		UCB$W_TT_HOLD+1(R5)
	BNEQ	YC_DMA_INTERRUPT	; YES, PROCESS IT.
;
; NO PENDING DATA - LOOK FOR NEXT CHARACTER
;
10$:	BICB	#UCB$M_TIM!UCB$M_INT,UCB$W_STS(R5); CLEAR TIMEOUT AND EXPECTED
;
; CALL CLASS DRIVER FOR MORE OUTPUT
;
	JSB	@UCB$L_TT_GETNXT(R5)	; GET THE NEXT CHARACTER
	BLSS	YC_START_BURST		; BURST SPECIFIED
	BEQL	YC_OUT_LOOP		; NONE
;
; OUTPUT A CHARACTER TO THE DMF
;
20$:
	BISW3	#^X4040,UCB$W_UNIT(R5),(R0)	; SELECT OUTPUT SILO INDIRECT REGISTER
	MOVB	R3,6(R0)		; OUTPUT CHARACTER
	BRB	YC_OUT_LOOP

40$:	INCL	YC$L_SIL_ERROR
	BRB	YC_OUT_LOOP
	.PAGE
	
YC_START_BURST:
	JSB	BURST_OUTPUT		; START OUTPUT SILO OR DMA
	BRB	YC_OUT_LOOP

;
;  CONTINUE SILO OUTPUT
;
YC_SILO:
	BISW3	#^X4040,UCB$W_UNIT(R5),(R0)	; SELECT OUTPUT SILO INDIRECT REGISTER
	MOVZBL	6(R0),R1		; GET SILO DEPTH
	SUBL3	R1,#32,R1			; CONVERT TO NUMBER SLOTS AVAILABLE

	MOVZWL	UCB$W_TT_OUTLEN(R5),R2	; GET CURRENT LENGTH
	MOVL	UCB$L_TT_OUTADR(R5),R3	; GET CURRENT ADDRESS
	CMPW	R2,R1			; BURST LARGER THAN SILO?
	BLEQU	50$			; NO
	MOVZBL	R1,R2			; MAXIMUM
50$:
	ADDL	R2,UCB$L_TT_OUTADR(R5)	; UPDATE POINTER
	SUBW	R2,UCB$W_TT_OUTLEN(R5)	; AND COUNT
	BNEQ	60$			; NOT DONE 
	BICW	#TTY$M_TANK_BURST,-	; RESET BURST ACTIVE
		UCB$W_TT_HOLD(R5)
60$:	TSTL	R2			; ANY ROOM AT ALL
	BEQL	80$			; NO THEN EXIT

	BLBC	R2,70$			; EVEN TRANSFER
	MOVB	(R3)+,6(R0)		; OUTPUT ODD BYTE
	DECL	R2			; UPDATE COUNT
	BEQL	80$			; DONE
70$:
	ASHL	#-1,R2,R2		; CONVERT TO WORD COUNT
75$:
	MOVW	(R3)+,6(R0)
	DELAY				; TO RELEASE THE UNIBUS
	SOBGTR	R2,75$			; LOOP TILL DONE

80$:	BRW	YC_OUT_LOOP


YC_DMA_INTERRUPT:
	PUSHAL	YC_OUT_LOOP		; BUILD RETURN ADDRESS ON STACK
	BBC	#DMFCSR$V_DMAERR,R2,30$	; CHECK FOR A DMA ERROR
	INCL	YC$L_DMAXMT_ERROR	; ERROR OCCURED INCREMENT COUNTS
30$:
	BITB	#TTY$M_TP_ALLOC!TTY$M_TP_DLLOC,- ;CHECK FOR FORKS ACTIVE
		UCB$B_TP_STAT(R5)	; AND IGNORE IF SO
	BNEQ	10$
	BBS	#TTY$V_TP_ABORT,UCB$B_TP_STAT(R5),-; ABORT ACTIVE DMA
		20$
	BISW3	#^X4058,UCB$W_UNIT(R5),(R0); GET CURRENT BYTE COUNT
	MOVZWL	6(R0),R1
	BICW	#^X0C000,R1		; MASK OFF ADDRESS BITS
	BEQL	20$			; DMA BYTE COUNT DONE.
	INCL	YC$L_ERROR
	BRB	10$			; NO THEN CONTINUE

20$:
	BRW	DMA_CONTINUE		; OTHERWISE, CONTINUE THE DMA

					; IF THIS INTERRUPT WAS THE RESULT
					; OF AN ABORT, THIS WILL BE HANDLED
					; BY DMA_CONTINUE
10$:
	RSB				

	.PAGE
	.SBTTL	SET SPEED, PARITY PARAMETERS

;++
; YC$SET_LINE - RESET SPEED, PARITY
;
; FUNCTIONAL DESCRIPTION:
;
; INPUTS:
;
;	R5 - UCB ADDRESS
;
; OUTPUTS:
;
;	R4 USED
;--

YC$SET_LINE:
	PUSHL	R3
	MOVL	UCB$L_CRB(R5),R4	; ADDRESS CRB
	MOVL	@CRB$L_INTD+VEC$L_IDB(R4),R4	; GET THE CSR ADDRESS VIA CRB
	BISW3	#^X4048,UCB$W_UNIT(R5),(R4)	; GET THE RIGHT INDIRECT REGISTER
	BBC	#TTY$V_PC_XOFAVL,UCB$W_TT_PRTCTL(R5),4$; AUTOXON XOFF AVAILABLE ON THIS LINE
						; YES THEN IS
	BBS	#TTY$V_PC_XOFENA,UCB$W_TT_PRTCTL(R5),2$; AUTOXON XOFF ENABLED
	BICW	#DMFLCT$M_AUTOX,6(R4)		; NO THEN CLEAR THE AUTOXOFF ENABLE
	BRB	4$				; AND CONTINUE
2$:	BISW	#DMFLCT$M_AUTOX,6(R4)		; ENABLED THEN SET AUTOXOFF
4$:
	CLRL	-(SP)				; RESET A TEMPORARY LOCATION
;
;	SET UP LINE SPEED AND PARITY
;

	TSTB	UCB$W_TT_SPEED+1(R5)	; RECEIVE SPEED SPECIFIED?
	BNEQ	5$			; YES
	MOVB	UCB$W_TT_SPEED(R5),-	; NO, SO USE TRANSMITTER SPEED
		UCB$W_TT_SPEED+1(R5)
5$:	SUBB3	#1,UCB$W_TT_SPEED(R5),R3	; ADJUST TRANSMIT SPEED
	INSV	R3,#DMFLPR$V_TSPEED,#4,(SP)	; SET TRANSMIT SPEED
	SUBB3	#1,UCB$W_TT_SPEED+1(R5),R3	; ADJUST RECEIVER SPEED
	INSV	R3,#DMFLPR$V_RSPEED,#4,(SP)	; SET RECEIVE SPEED

;	NONSTANDARD PARITY/STOP LAYOUT

	EXTV	#UCB$V_TT_LEN,#2,UCB$B_TT_PARITY(R5),R3		; GET CHAR SIZE
	INSV	R3,#DMFLPR$V_SIZE,#2,(SP)			; SET IT
	EXTV	#UCB$V_TT_PARTY,#2,UCB$B_TT_PARITY(R5),R3	; GET PARITY/ODD
	INSV	R3,#DMFLPR$V_PARITY,#2,(SP)
	XORB	#DMFLPR$M_ODD,(SP)				; INVERT PARITY BIT
	EXTV	#UCB$V_TT_STOP,#1,UCB$B_TT_PARITY(R5),R3	; GET STOP
	INSV	R3,#DMFLPR$V_STOP,#1,(SP)

	BICW	#^X0007,(SP)		; CLEAR SPECIAL FIELDS
	BISW	UCB$W_UNIT(R5),(SP)	; SET LINE NUMBER
	CVTLW	(SP)+,2(R4)		; INSERT AS LINE PARAMETER
	POPL	R3
	RSB



YC$END:					; End of driver

	.END
