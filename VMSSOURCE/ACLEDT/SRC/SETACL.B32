MODULE AED$SETACL (
		   LANGUAGE (BLISS32),
		   IDENT = 'V04-000',
		   ADDRESSING_MODE (EXTERNAL = GENERAL)
		   ) =
BEGIN

!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************

!++
!
! FACILITY:	SET utility
!
! ABSTRACT:
!
!	This module contains all the routines necessary to support the
!	DCL commands SET FILE/ACL, SET DIRECTORY/ACL, SET DEVICE/ACL,
!	and SET ACL with the exception of the /EDIT qualifier.
!
! ENVIRONMENT:
!
!	VAX/VMS operating system, user mode utilities.
!
!--
!
!
! AUTHOR:	L. Mark Pilant		CREATION DATE:	4-May-1983  9:20
!
! MODIFIED BY:
!
!	V03-019	LMP0296		L. Mark Pilant,		6-Aug-1984  15:02
!		Change the location of the code that determines if the target
!		file is a directory file to correct a bug where the default
!		option was being cleared.
!
!	V03-018	LMP0283		L. Mark Pilant,		25-Jul-1984  12:40
!		Make sure the default object type is a file.
!
!	V03-017	LMP0260		L. Mark Pilant,		27-Jun-1984  9:11
!		Add support for the /DEFAULT qualifier.
!
!	V03-016	LMP0253		L. Mark Pilant,		4-Jun-1984  10:41
!		Fix the error handling in COPY_ACL so that SS$_NOMOREACE
!		and SS$_ACLEMPTY are (again) turned into SS$_NORMAL.
!
!	V03-015	LMP0244		L. Mark Pilant,		1-May-1984  16:02
!		Fix a bug intruduced by LMP0238 that caused the wrong
!		item code to be used.
!
!	V03-014	LMP0238		L. Mark Pilant,		19-Apr-1984  13:35
!		Use the size of the ACE being twiddled, when possible.
!
!	V03-013	LMP0236		L. Mark Pilant,		18-Apr-1984  13:25
!		Correct a bug that caused an ACCVIO to be returned from the
!		$CHANGE_ACL system service when an attempt was made to lock
!		a file's ACL for writing.
!
!	V03-012	LMP0230		L. Mark Pilant,		16-Apr-1984  10:45
!		Track interface changes to $CHANGE_ACL system service.
!
!	V03-011	LMP0226		L. Mark Pilant,		9-Apr-1984  9:32
!		Make sure all ACEs to be modified exist and are in the
!		correct order (if more than one).
!
!	V03-010	LMP0224		L. Mark Pilant,		7-Apr-1984  13:50
!		Use enhanced lib$file_scan features for stickyness.
!
!	V03-009	LMP0223		L. Mark Pilant,		6-Apr-1984  12:49
!		Use the correct amount of storage for the $CHANGE_ACL
!		lock block.
!
!	V03-008	LMP0213		L. Mark Pilant,		24-Mar-1984  12:23
!		Add support for locking and unlocking the object's ACL.
!		Also, modify it so that the DCL commands SET ACL and SHOW
!		ACL call the same image.
!
!	V03-007	LMP0210		L. Mark Pilant,		23-Mar-1984  14:33
!		Change the /MODIFY qualifier to /REPLACE.
!
!	V03-006	LMP0198		L. Mark Pilant,		28-Feb-1984  12:05
!		Open the object specified by the /LIKE qualifier for
!		shared read access.
!
!	V03-005	LMP0185		L. Mark Pilant,		4-Feb-1984  12:15
!		Add support for device ACLs.
!
!	V03-004	LMP0181		L. Mark Pilant,		15-Dec-1983  9:54
!		Change code to use $CHANGE_ACL instead of the ACP to do
!		the ACL twiddling.
!
!	V03-003	LMP0168		L. Mark Pilant,		11-Nov-1983  10:58
!		Make use of the HIDDEN ACE option illegal.
!
!	V03-002	LMP0137		L. Mark Pilant,		12-Aug-1983  9:36
!		Add support for the qualifiers: /BEFORE, /SINCE,
!		and /CREATED.
!
!	V03-001	LMP0126		L. Mark Pilant,		5-Jul-1983  11:00
!		Correctly use a 'sticky' input file-spec.  Also, handle
!		errors while processing multiple files correctly.
!
!**

LIBRARY 'SYS$LIBRARY:LIB';
LIBRARY 'SYS$LIBRARY:TPAMAC';

!  Routines contained within this module.

FORWARD ROUTINE
	SET_ACL,				! Main processing routine
	GET_FILE,				! Get next output file spec
	PROCESS_FILE,				! Act upon the specified file
	ADD_ACL,				! Add to an existing ACL
	DELETE_ACL,				! Delete ACEs or an ACL
	REPLACE_ACL,				! Modify existing ACEs
	COPY_ACL,				! Copy a object's ACL
	INPUT_ERROR,				! Signal file scanning error
	FILE_ERROR;				! Signal general file error

! Define common error message codes.

$SHR_MSGDEF	(SET, 119, LOCAL,
		(SYNTAX, SEVERE),
		(OPENIN, ERROR),
		(CLOSEIN, ERROR),
		(OPENOUT, ERROR),
		(CLOSEOUT, ERROR),
		(READERR, SEVERE),
		(WRITEERR, SEVERE)
		);

! Define necessary macros.

MACRO
	SIGNAL	(ARG) =
		BEGIN
		EXTERNAL ROUTINE	LIB$SIGNAL;
		LIB$SIGNAL (ARG %IF %LENGTH-1 GTR 0 %THEN, %REMAINING %FI);
		IF NOT ARG AND
		   (.WORST_ERROR AND STS$M_SEVERITY) LSS
		   (ARG AND STS$M_SEVERITY) THEN WORST_ERROR = ARG OR
							       STS$M_INHIB_MSG;
		END
		%;

MACRO
	ALLOCATE (SIZE, ADDRESS) =
		BEGIN
		EXTERNAL ROUTINE	LIB$GET_VM;
		LOCAL	VM_STATUS;
		VM_STATUS = LIB$GET_VM (%REF (SIZE), ADDRESS);
		IF .VM_STATUS THEN CH$FILL (0, SIZE, .ADDRESS);
		.VM_STATUS
		END
		%;

! Various needed flags.

MACRO
	QUAL_AFTER	= 0, 0, 1, 0 %,		! /AFTER qualifier seen
	QUAL_DELETE	= 0, 1, 1, 0 %,		! /DELETE qualifier seen
	QUAL_LIKE	= 0, 2, 1, 0 %,		! /LIKE qualifier seen
	QUAL_LOG	= 0, 3, 1, 0 %,		! /LOG qualifier seen
	QUAL_REPLACE	= 0, 4, 1, 0 %,		! /REPLACE qualifier seen
	QUAL_NEW	= 0, 5, 1, 0 %,		! /NEW qualifier seen
	QUAL_DEFAULT	= 0, 6, 1, 0 %,		! /DEFAULT qualifier seen
	DIRECTORY	= 0, 10, 1, 0 %,	! Target file is a directory file
	IN_ELLIPSE	= 0, 11, 1, 0 %,	! In ellipse processing
	SET_DEV_CMD	= 0, 12, 1, 0 %,	! SET DEVICE command
	SET_FILE_CMD	= 0, 13, 1, 0 %,	! SET FILE command
	SET_DIR_CMD	= 0, 14, 1, 0 %,	! SET DIRECTORY command
	SET_ACL_CMD	= 0, 15, 1, 0 %;	! SET ACL command

! Structure definition for the old and new ACE queues.

MACRO
	ACEQ_L_FLINK	= 0, 0, 32, 0 %,	! Forward link
	ACEQ_L_BLINK	= 4, 0, 32, 0 %,	! Backward link
	ACEQ_T_ACE	= 8, 0, 32, 0 %;	! Start of the actual ACE

LITERAL
	ACEQ_C_LENGTH	= 8;			! Length of the overhead area

! Semi-permanent storage.

OWN
	FLAGS		: $BBLOCK [2],		! Needed flags
	WORST_ERROR,				! Worst error encountered
	ACL_LOCKID	: $BBLOCK [ACL$S_RLOCK_ACL],	! Lock-id for ACL lock
	OBJECT_TYPE,				! Object type code
	OBJECT_NAME	: $BBLOCK [DSC$C_S_BLN],	! Object name descriptor
	OBJECT_FAB	: $FAB_DECL,		! Output object FAB
	OBJECT_NAM	: $NAM_DECL,		! Output object NAMe block
	OBJECT_EXP_NAME	: $BBLOCK [NAM$C_MAXRSS],	! Expanded name string
	OBJECT_RES_NAME	: $BBLOCK [NAM$C_MAXRSS],	! Resultant name string
	RELATED_NAM	: $NAM_DECL,		! Related object spec
	CHAN,					! Input object channel
	ACL_CONTEXT,				! ACL context used by $CHANGE_ACL
	SACL_LOCKID	: $BBLOCK [ACL$S_RLOCK_ACL],	! Lock-id for ACL lock
	SOBJECT_TYPE,				! Source object type code
	SOBJECT_DESC	: $BBLOCK [DSC$C_S_BLN],	! Source object descr
	SOBJECT_FAB	: $FAB_DECL,		! Source object FAB
	SOBJECT_NAM	: $NAM_DECL,		! Source object NAMe block
	SOBJECT_EXP_NAME	: $BBLOCK [NAM$C_MAXRSS],	! Expanded name string
	SOBJECT_RES_NAME	: $BBLOCK [NAM$C_MAXRSS],	! Resultant name string
	SCHAN,					! Source object channel
	SACL_CONTEXT,				! ACL context for $CHANGE_ACL
	SDEVICE_DESC	: $BBLOCK [DSC$C_S_BLN],	! Source device desc
	SFIB_DESC	: $BBLOCK [DSC$C_S_BLN],	! Source file FIB desc
	SFILE_FIB	: $BBLOCK [FIB$C_LENGTH],	! Source file FIB
	COMMON_CTX,				! Common qual context
	ATR_ARGLIST	: BLOCKVECTOR [3, ITM$S_ITEM, BYTE],	! ACP attribute descr
	CLI_ACE_DESC	: $BBLOCK [DSC$C_S_BLN],	! ACE string from CLI
	ERROR_POS,				! Error position parsing ACE
	ACE_DESC	: $BBLOCK [DSC$C_S_BLN],	! Binary ACE descriptor
	ACE		: $BBLOCK [ACL$S_READACL],	! Binary ACE storage
	ACE_POINTER	: REF $BBLOCK,		! Pointer to ACE queue entry
	ACE_TEXT_DESC	: $BBLOCK [DSC$C_S_BLN],	! Text ACE descriptor
	ACE_TEXT	: $BBLOCK [3072],	! AE text storage
	OLD_ACE_HEAD	: $BBLOCK [ACEQ_C_LENGTH],	! Old ACE queue head
	NEW_ACE_HEAD	: $BBLOCK [ACEQ_C_LENGTH],	! New ACE queue head
	DIR_GROUP,				! Group of UIC format directory
	DIR_MEMBER;				! Member of UIC format directory

EXTERNAL
	SET$_NOHIDDEN,				! No HIDDEN ACEs allowed
	SET$_OBJLOCKED,				! Object locked by another user
	SET$_IVORDER,				! Incorrect ordering of ACEs to be modified
	SET$_NOSUCHACE,				! Specified ACE doesn't exist
	SET$_MODIFIED;				! Object modified message

EXTERNAL ROUTINE
	CLI$GET_VALUE,				! Get qualifier value
	CLI$PRESENT,				! See if qualifier present
	LIB$FID_TO_NAME,			! Translate FID to file-spec
	LIB$FILE_SCAN,				! Search wildcard file spec
	LIB$QUAL_FILE_MATCH,			! Check for match
	LIB$QUAL_FILE_PARSE,			! Set match context
	LIB$TPARSE;				! General purpose parser

! TPARSE table for UIC format directory names.

$INIT_STATE	(DIR_STATE, DIR_KEYS);

$STATE	(,(TPA$_OCTAL,,,,DIR_GROUP));
$STATE	(,(','));
$STATE	(,(TPA$_OCTAL,,,,DIR_MEMBER));

GLOBAL ROUTINE SET_ACL =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine is the main routine.  It parses the command line to
!	determine what modifications to the object (or objects) ACL are to
!	occur.
!
!--

BEGIN

BUILTIN
	INSQUE;

LOCAL
	SCAN_CONTEXT,				! LIB$FILE_SCAN context storage
	CMD_DESC	: $BBLOCK [DSC$C_S_BLN],	! DCL command descr
	STATUS,					! Local routine return status
	IO_STATUS	: VECTOR [4, WORD];	! I/O status block

! Initialize local storage.

CH$FILL (0, 3*ITM$S_ITEM, ATR_ARGLIST);
CH$FILL (0, FIB$C_LENGTH, SFILE_FIB);
CH$FILL (0, DSC$C_S_BLN, CLI_ACE_DESC);
CH$MOVE (DSC$C_S_BLN, CLI_ACE_DESC, ACE_DESC);
CH$MOVE (DSC$C_S_BLN, CLI_ACE_DESC, ACE_TEXT_DESC);
CH$MOVE (DSC$C_S_BLN, CLI_ACE_DESC, OBJECT_NAME);
CH$MOVE (DSC$C_S_BLN, CLI_ACE_DESC, SOBJECT_DESC);
CH$MOVE (DSC$C_S_BLN, CLI_ACE_DESC, CMD_DESC);
CH$MOVE (DSC$C_S_BLN, CLI_ACE_DESC, SFIB_DESC);

FLAGS = 0;
SCAN_CONTEXT = 0;
OBJECT_TYPE = SOBJECT_TYPE = 0;
CHAN = SCHAN = 0;
WORST_ERROR = SS$_NORMAL;
CLI_ACE_DESC[DSC$B_CLASS] = DSC$K_CLASS_D;
OBJECT_NAME[DSC$B_CLASS] = DSC$K_CLASS_D;
SOBJECT_DESC[DSC$B_CLASS] = DSC$K_CLASS_D;
CMD_DESC[DSC$B_CLASS] = DSC$K_CLASS_D;
SFIB_DESC[DSC$W_LENGTH] = 10;
SFIB_DESC[DSC$A_POINTER] = SFILE_FIB;
ACE_DESC[DSC$A_POINTER] = ACE;
OLD_ACE_HEAD[ACEQ_L_FLINK] = OLD_ACE_HEAD[ACEQ_L_BLINK]
			   = OLD_ACE_HEAD[ACEQ_L_FLINK];	! Null queue
NEW_ACE_HEAD[ACEQ_L_FLINK] = NEW_ACE_HEAD[ACEQ_L_BLINK]
			   = NEW_ACE_HEAD[ACEQ_L_FLINK];	! Null queue

! Determine what DCL command was used to invoke this image.  Also, set the
! appropriate default object type code.

CLI$GET_VALUE ($DESCRIPTOR ('OPTION'), CMD_DESC);
IF CH$EQL (.CMD_DESC[DSC$W_LENGTH], .CMD_DESC[DSC$A_POINTER],
	   MINU (.CMD_DESC[DSC$W_LENGTH], %CHARCOUNT ('FILE')), UPLIT ('FILE'),
	   0)
THEN
    BEGIN
    FLAGS[SET_FILE_CMD] = 1;
    OBJECT_TYPE = ACL$C_FILE;
    SOBJECT_TYPE = ACL$C_FILE;
    END;

IF CH$EQL (.CMD_DESC[DSC$W_LENGTH], .CMD_DESC[DSC$A_POINTER],
	   MINU (.CMD_DESC[DSC$W_LENGTH], %CHARCOUNT ('DIRECTORY')), UPLIT ('DIRECTORY'),
	   0)
THEN
    BEGIN
    FLAGS[SET_DIR_CMD] = 1;
    OBJECT_TYPE = ACL$C_FILE;
    SOBJECT_TYPE = ACL$C_FILE;
    END;

IF CH$EQL (.CMD_DESC[DSC$W_LENGTH], .CMD_DESC[DSC$A_POINTER],
	   MINU (.CMD_DESC[DSC$W_LENGTH], %CHARCOUNT ('DEVICE')), UPLIT ('DEVICE'),
	   0)
THEN
    BEGIN
    FLAGS[SET_DEV_CMD] = 1;
    OBJECT_TYPE = ACL$C_DEVICE;
    SOBJECT_TYPE = ACL$C_DEVICE;
    END;

IF CH$EQL (.CMD_DESC[DSC$W_LENGTH], .CMD_DESC[DSC$A_POINTER],
	   MINU (.CMD_DESC[DSC$W_LENGTH], %CHARCOUNT ('ACL')), UPLIT ('ACL'),
	   0)
THEN
    BEGIN
    FLAGS[SET_ACL_CMD] = 1;
    OBJECT_TYPE = ACL$C_FILE;
    SOBJECT_TYPE = ACL$C_FILE;
    END;

! Determine what qualifiers are present.

FLAGS[QUAL_AFTER] = CLI$PRESENT ($DESCRIPTOR ('AFTER'));
FLAGS[QUAL_DEFAULT] = CLI$PRESENT ($DESCRIPTOR ('DEFAULT'));
FLAGS[QUAL_DELETE] = CLI$PRESENT ($DESCRIPTOR ('DELETE'));
FLAGS[QUAL_LOG] = CLI$PRESENT ($DESCRIPTOR ('LOG'));
FLAGS[QUAL_REPLACE] = CLI$PRESENT ($DESCRIPTOR ('REPLACE'));
FLAGS[QUAL_NEW] = CLI$PRESENT ($DESCRIPTOR ('NEW'));

! If the /LIKE qualifier is present, get the source object type and name.  If it
! is a file, access it for later use.

IF (FLAGS[QUAL_LIKE] = CLI$PRESENT ($DESCRIPTOR ('LIKE')))
THEN
    BEGIN

! Determine the characteristics of the source object.

    IF .FLAGS[SET_ACL_CMD]
    THEN
	BEGIN
	IF CLI$PRESENT ($DESCRIPTOR ('LIKE.OBJECT_TYPE.FILE')) THEN SOBJECT_TYPE = ACL$C_FILE;
	IF CLI$PRESENT ($DESCRIPTOR ('LIKE.OBJECT_TYPE.DEVICE')) THEN SOBJECT_TYPE = ACL$C_DEVICE;
	IF CLI$PRESENT ($DESCRIPTOR ('LIKE.OBJECT_TYPE.QUEUE')) THEN SOBJECT_TYPE = ACL$C_JOBCTL_QUEUE;
	IF CLI$PRESENT ($DESCRIPTOR ('LIKE.OBJECT_TYPE.EVENT_CLUSTER')) THEN SOBJECT_TYPE = ACL$C_COMMON_EF_CLUSTER;
	IF CLI$PRESENT ($DESCRIPTOR ('LIKE.OBJECT_TYPE.LOGICAL_NAME_TABLE')) THEN SOBJECT_TYPE = ACL$C_LOGICAL_NAME_TABLE;
	IF CLI$PRESENT ($DESCRIPTOR ('LIKE.OBJECT_TYPE.PROCESS')) THEN SOBJECT_TYPE = ACL$C_PROCESS;
	IF CLI$PRESENT ($DESCRIPTOR ('LIKE.OBJECT_TYPE.GLOBAL_SECTION')) THEN SOBJECT_TYPE = ACL$C_GLOBAL_SECTION;
	CLI$GET_VALUE ($DESCRIPTOR ('LIKE.OBJECT_NAME'), SOBJECT_DESC);
	END
    ELSE CLI$GET_VALUE ($DESCRIPTOR ('LIKE'), SOBJECT_DESC);

! Attempt to obtain a read lock for the source object.

    ATR_ARGLIST[0, ITM$W_ITMCOD] = ACL$C_RLOCK_ACL;
    ATR_ARGLIST[0, ITM$W_BUFSIZ] = ACL$S_RLOCK_ACL;
    ATR_ARGLIST[0, ITM$L_BUFADR] = SACL_LOCKID;
    STATUS = $CHANGE_ACL (CHAN = .SCHAN,
			  OBJTYP = SOBJECT_TYPE,
			  OBJNAM = SOBJECT_DESC,
			  ITMLST = ATR_ARGLIST);
    IF NOT .STATUS
    THEN
	BEGIN
	IF .STATUS EQL SS$_NOTQUEUED
	THEN SIGNAL (SET$_OBJLOCKED)
	ELSE SIGNAL (.STATUS);
	RETURN .WORST_ERROR;
	END;

! Open the source object to get the ACL being copied; if it is a file.

    IF .SOBJECT_TYPE EQL ACL$C_FILE
    THEN
	BEGIN
	$FAB_INIT (FAB = SOBJECT_FAB,
		   FAC = GET,
		   FNA = .SOBJECT_DESC[DSC$A_POINTER],
		   FNS = .SOBJECT_DESC[DSC$W_LENGTH],
		   FOP = UFO,
		   NAM = SOBJECT_NAM,
		   SHR = <GET, UPI>);
	$NAM_INIT (NAM = SOBJECT_NAM,
		   ESA = SOBJECT_EXP_NAME,
		   ESS = NAM$C_MAXRSS,
		   RSA = SOBJECT_RES_NAME,
		   RSS = NAM$C_MAXRSS);
	IF NOT $OPEN (FAB = SOBJECT_FAB)
	THEN
	    BEGIN
	    FILE_ERROR (SET$_OPENIN, SOBJECT_FAB, .SOBJECT_FAB[FAB$L_STS],
						  .SOBJECT_FAB[FAB$L_STV]);
	    RETURN SET$_OPENIN OR STS$M_INHIB_MSG;
	    END;
	SCHAN = .SOBJECT_FAB[FAB$L_STV];
	END;
    END;

! Determine the characteristics of the target object.

IF .FLAGS[SET_ACL_CMD]
THEN
    BEGIN
    IF CLI$PRESENT ($DESCRIPTOR ('OBJECT_TYPE.FILE')) THEN OBJECT_TYPE = ACL$C_FILE;
    IF CLI$PRESENT ($DESCRIPTOR ('OBJECT_TYPE.DEVICE')) THEN OBJECT_TYPE = ACL$C_DEVICE;
    IF CLI$PRESENT ($DESCRIPTOR ('OBJECT_TYPE.QUEUE')) THEN OBJECT_TYPE = ACL$C_JOBCTL_QUEUE;
    IF CLI$PRESENT ($DESCRIPTOR ('OBJECT_TYPE.EVENT_CLUSTER')) THEN OBJECT_TYPE = ACL$C_COMMON_EF_CLUSTER;
    IF CLI$PRESENT ($DESCRIPTOR ('OBJECT_TYPE.LOGICAL_NAME_TABLE')) THEN OBJECT_TYPE = ACL$C_LOGICAL_NAME_TABLE;
    IF CLI$PRESENT ($DESCRIPTOR ('OBJECT_TYPE.PROCESS')) THEN OBJECT_TYPE = ACL$C_PROCESS;
    IF CLI$PRESENT ($DESCRIPTOR ('OBJECT_TYPE.GLOBAL_SECTION')) THEN OBJECT_TYPE = ACL$C_GLOBAL_SECTION;
    END;

! Now get any ACEs specified on the /ACL qualifier.

WHILE CLI$GET_VALUE ($DESCRIPTOR ('ACL'), CLI_ACE_DESC)
DO
    BEGIN
    ACE_DESC[DSC$W_LENGTH] = ACL$S_READACL;		! Reset buffer size
    STATUS = $PARSE_ACL (ACLSTR = CLI_ACE_DESC,
			 ACLENT = ACE_DESC,
			 ERRPOS = ERROR_POS);
    IF NOT .STATUS
    THEN
	BEGIN
	CLI_ACE_DESC[DSC$A_POINTER] = .CLI_ACE_DESC[DSC$A_POINTER] + .ERROR_POS;
	CLI_ACE_DESC[DSC$W_LENGTH] = .CLI_ACE_DESC[DSC$W_LENGTH] - .ERROR_POS;
	SIGNAL (SET$_SYNTAX, 1, CLI_ACE_DESC, .STATUS, 0);
	RETURN .WORST_ERROR;
	END;
    IF .ACE[ACE$V_HIDDEN]
    THEN
	BEGIN
	SIGNAL (SET$_NOHIDDEN);
	RETURN .WORST_ERROR;
	END;
    STATUS = ALLOCATE (.ACE[ACE$B_SIZE] + ACEQ_C_LENGTH, ACE_POINTER);
    IF NOT .STATUS
    THEN
	BEGIN
	SIGNAL (.STATUS);
	RETURN .WORST_ERROR;
	END;
    CH$MOVE (.ACE[ACE$B_SIZE], ACE, ACE_POINTER[ACEQ_T_ACE]);
    INSQUE (.ACE_POINTER, (IF .FLAGS[QUAL_DELETE] OR .FLAGS[QUAL_REPLACE]
			   THEN .OLD_ACE_HEAD[ACEQ_L_BLINK]
			   ELSE .NEW_ACE_HEAD[ACEQ_L_BLINK]));
    END;

! Now get any ACEs specified on the /REPLACE or /AFTER qualifiers.

WHILE CLI$GET_VALUE ((IF .FLAGS[QUAL_REPLACE]
		      THEN $DESCRIPTOR ('REPLACE')
		      ELSE $DESCRIPTOR ('AFTER')), CLI_ACE_DESC)
DO
    BEGIN
    ACE_DESC[DSC$W_LENGTH] = ACL$S_READACL;		! Reset buffer size
    STATUS = $PARSE_ACL (ACLSTR = CLI_ACE_DESC,
			 ACLENT = ACE_DESC,
			 ERRPOS = ERROR_POS);
    IF NOT .STATUS
    THEN
	BEGIN
	CLI_ACE_DESC[DSC$A_POINTER] = .CLI_ACE_DESC[DSC$A_POINTER] + .ERROR_POS;
	CLI_ACE_DESC[DSC$W_LENGTH] = .CLI_ACE_DESC[DSC$W_LENGTH] - .ERROR_POS;
	SIGNAL (SET$_SYNTAX, 1, CLI_ACE_DESC, .STATUS, 0);
	RETURN .WORST_ERROR;
	END;
    IF .ACE[ACE$V_HIDDEN]
    THEN
	BEGIN
	SIGNAL (SET$_NOHIDDEN);
	RETURN .WORST_ERROR;
	END;
    STATUS = ALLOCATE (.ACE[ACE$B_SIZE] + ACEQ_C_LENGTH, ACE_POINTER);
    IF NOT .STATUS
    THEN
	BEGIN
	SIGNAL (.STATUS);
	RETURN .WORST_ERROR;
	END;
    CH$MOVE (.ACE[ACE$B_SIZE], ACE, ACE_POINTER[ACEQ_T_ACE]);
    INSQUE (.ACE_POINTER, (IF .FLAGS[QUAL_REPLACE]
			   THEN .NEW_ACE_HEAD[ACEQ_L_BLINK]
			   ELSE .OLD_ACE_HEAD[ACEQ_L_BLINK]));
    END;

! Check for syntax errors on the command.

IF .OLD_ACE_HEAD[ACEQ_L_FLINK] EQLA OLD_ACE_HEAD[ACEQ_L_FLINK]
AND .NEW_ACE_HEAD[ACEQ_L_FLINK] EQLA NEW_ACE_HEAD[ACEQ_L_FLINK]
THEN
    BEGIN
    IF .FLAGS[QUAL_AFTER] OR .FLAGS[QUAL_REPLACE]
    OR (.FLAGS[QUAL_NEW] AND NOT .FLAGS[QUAL_LIKE])
    THEN
	BEGIN
	SIGNAL (SET$_SYNTAX, 1, $DESCRIPTOR ('command line'));
	RETURN .WORST_ERROR;
	END;
    END
ELSE
    BEGIN
    IF .FLAGS[QUAL_LIKE]
    THEN
	BEGIN
	SIGNAL (SET$_SYNTAX, 1, $DESCRIPTOR ('command line'));
	RETURN .WORST_ERROR;
	END;
    END;

! If the object is a file, loop through all the specifications supplied.
! For any other object, simply dispatch to the appropriate routine from here.

IF .OBJECT_TYPE EQL ACL$C_FILE
THEN
    BEGIN
    $FAB_INIT (FAB = OBJECT_FAB,
	       FAC = <GET, PUT>,
	       FOP = UFO,
	       NAM = OBJECT_NAM,
	       SHR = <GET, UPI>);
    $NAM_INIT (NAM = OBJECT_NAM,
	       ESA = OBJECT_EXP_NAME,
	       ESS = NAM$C_MAXRSS,
	       RSA = OBJECT_RES_NAME,
	       RSS = NAM$C_MAXRSS);

! LIB$QUAL_FILE_PARSE is called to parse the common qualifiers.  It sets up
! a data base which describes the results for LIB$QUAL_FILE_MATCH to use.

    STATUS = LIB$QUAL_FILE_PARSE (%REF (LIB$M_CQF_BEFORE OR
					LIB$M_CQF_BYOWNER OR
					LIB$M_CQF_CONFIRM OR
					LIB$M_CQF_CREATED OR
					LIB$M_CQF_EXCLUDE OR
					LIB$M_CQF_SINCE), COMMON_CTX);
    IF NOT .STATUS
    THEN
	BEGIN
	SIGNAL (.STATUS);
	RETURN .WORST_ERROR;
	END;

! Sit in a loop processing each 'input' file specified.  For the copy
! operation, the 'input' file is really the output file.

    FLAGS[IN_ELLIPSE] = 0;			! For initial directory processing
    WHILE GET_FILE (OBJECT_FAB)
    DO
	BEGIN

! If this is the /DEFAULT processing, and a channel has been assigned,
! deaccess the directory file, and deassign the channel.

	IF .FLAGS[QUAL_DEFAULT] AND .SCHAN NEQ 0
	THEN
	    BEGIN
	    STATUS = $QIOW (CHAN = .SCHAN,
			    FUNC = IO$_DEACCESS,
			    IOSB = IO_STATUS);
	    IF .STATUS THEN STATUS = .IO_STATUS[0];
	    IF NOT .STATUS THEN SIGNAL (SET$_CLOSEIN, 1, SOBJECT_DESC, .STATUS, 0);
	    STATUS = $DASSGN (CHAN = .SCHAN);
	    IF NOT .STATUS THEN SIGNAL (SET$_CLOSEIN, 1, SOBJECT_DESC, .STATUS, 0);

! Now release the read lock that was taken out for the directory file.

	    ATR_ARGLIST[0, ITM$W_ITMCOD] = ACL$C_UNLOCK_ACL;
	    ATR_ARGLIST[0, ITM$W_BUFSIZ] = 4;
	    ATR_ARGLIST[0, ITM$L_BUFADR] = SACL_LOCKID;
	    STATUS = $CHANGE_ACL (CHAN = .SCHAN,
				  OBJTYP = SOBJECT_TYPE,
				  OBJNAM = SOBJECT_DESC,
				  ITMLST = ATR_ARGLIST);
	    IF NOT .STATUS THEN SIGNAL (SET$_CLOSEIN, 1, SOBJECT_DESC, .STATUS, 0);
	    SCHAN = 0;
	    END;
	LIB$FILE_SCAN (OBJECT_FAB,
		       PROCESS_FILE,		! File found action routine
		       INPUT_ERROR,		! Input error action routine
		       SCAN_CONTEXT);		! Stickiness context
	END;
    END
ELSE
    BEGIN

! Get the object's name.

    CLI$GET_VALUE ($DESCRIPTOR ('INPUT'), OBJECT_NAME);

! Attempt to obtain a write lock for the target object.

    ATR_ARGLIST[0, ITM$W_ITMCOD] = ACL$C_WLOCK_ACL;
    ATR_ARGLIST[0, ITM$W_BUFSIZ] = ACL$S_WLOCK_ACL;
    ATR_ARGLIST[0, ITM$L_BUFADR] = ACL_LOCKID;
    STATUS = $CHANGE_ACL (CHAN = .CHAN,
			  OBJTYP = OBJECT_TYPE,
			  OBJNAM = OBJECT_NAME,
			  ITMLST = ATR_ARGLIST);
    IF NOT .STATUS
    THEN
	BEGIN
	IF .STATUS EQL SS$_NOTQUEUED
	THEN SIGNAL (SET$_OBJLOCKED)
	ELSE SIGNAL (.STATUS);
	RETURN .WORST_ERROR;
	END;

! Call the necessary routine based upon the command line qualifiers.

    IF .FLAGS[QUAL_LIKE] THEN STATUS = COPY_ACL (OBJECT_NAME)		! /LIKE
    ELSE IF .FLAGS[QUAL_DELETE] THEN STATUS = DELETE_ACL (OBJECT_NAME)	! /DELETE
	 ELSE IF .FLAGS[QUAL_REPLACE] THEN STATUS = REPLACE_ACL (OBJECT_NAME)	! /REPLACE
	      ELSE STATUS = ADD_ACL (OBJECT_NAME);		! /AFTER, /NEW, or just /ACL

! If logging is being done, indicate that the object has been modified.

    IF .FLAGS[QUAL_LOG] AND .STATUS
    THEN SIGNAL (SET$_MODIFIED, 1, OBJECT_NAME);
    END;

RETURN .WORST_ERROR;

END;						! End of routine SET_ACL

ROUTINE GET_FILE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine gets the next file specification in the command line.
!	If there are no more specifications, the routine returns zero.
!	Otherwise, the next file specification is placed in the specified
!	FAB for later searching and parsing.
!
! CALLING SEQUENCE:
!
!	GET_FILE
!
! INPUT PARAMETERS:
!	none
!
! INPLICIT INPUTS:
!	none
!
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	1 if a specification was found
!	0 otherwise
!
! SIDE EFFECTS:
!	The retrieved file specification is placed into the specified FAB.
!
!--

BEGIN

OWN
	FILE_DESC	: $BBLOCK [DSC$C_S_BLN]	! File name descr
			  INITIAL (REP DSC$C_S_BLN OF (BYTE (0)));

LOCAL
	DESC		: $BBLOCK [DSC$C_S_BLN],	! Temp descriptor
	ENDCHAR		: BYTE,			! Dir spec terminator
	EOS,					! End addr of dir spec
	PTR,					! Moving pointer in dir spec
	STR_PTR,				! Pointer to remainder of spec
	STR_LEN,				! Remaining length of dir spec
	TEMP_STRING	: VECTOR [NAM$C_MAXRSS, BYTE],	! Temp dir spec storage
	TEMP,					! Location of string to find
	STATUS;					! Local routine exit status

! Determine whether or not it is necessary to get another input specification.

IF NOT .FLAGS[SET_DIR_CMD] OR (.FLAGS[SET_DIR_CMD] AND NOT .FLAGS[IN_ELLIPSE])
THEN
    BEGIN

! If there are no more specifications, return 0.

    FILE_DESC[DSC$B_CLASS] = DSC$K_CLASS_D;
    IF NOT CLI$GET_VALUE ($DESCRIPTOR ('INPUT'), FILE_DESC) THEN RETURN 0;

! Fill in the FAB fields for the normal (or simple) case.

    OBJECT_FAB[FAB$L_FNA] = .FILE_DESC[DSC$A_POINTER];
    OBJECT_FAB[FAB$B_FNS] = .FILE_DESC[DSC$W_LENGTH];
    END;

! If this is a SET DIRECTORY command, it is necessary to do some additional
! processing of the input file specification.  In other words, it will be
! necessary to turn the directory specification into a file specification.

IF .FLAGS[SET_DIR_CMD]
THEN
    BEGIN

! Check here to see if a trailing ellipse is being treated.  If so,
! then FLAGS[IN_ELLIPSE] will be set to 1, and there's no need
! to search and see if such a trailing ellipse is present.  However,
! if the value is set to 0, then get a new directory spec.

    IF NOT .FLAGS[IN_ELLIPSE]			! If not processing an ellipse
    THEN					! then get the next directory
	BEGIN
	OBJECT_FAB[FAB$L_FNA] = .FILE_DESC[DSC$A_POINTER];
	OBJECT_FAB[FAB$B_FNS] = .FILE_DESC[DSC$W_LENGTH];

! Since this is a new entry, it must be checked for a trailing ellipse.

	CH$MOVE (.FILE_DESC[DSC$W_LENGTH],	! Move this many chars
		 .FILE_DESC[DSC$A_POINTER],	! From the CLI area
		 TEMP_STRING);			! To the temp string
	STR_PTR = TEMP_STRING;			! Set up pointer
	STR_LEN = .FILE_DESC[DSC$W_LENGTH];	! and length.

! Look for ellipses.

	WHILE NOT CH$FAIL (TEMP = CH$FIND_SUB (.STR_LEN, .STR_PTR,
					       3, UPLIT ('...')))
	DO
	    BEGIN
	    STR_PTR = .TEMP + 3;		! Update pointer
	    STR_LEN = .STR_LEN - (.TEMP - .STR_PTR) - 3;
	    END;

! After the final ellipse, check to see if it is at the end of the
! directory specification.  If so, then change the context field of
! the fab, and insert an end bracket at the beginning of the ellipse.

	IF (.STR_PTR EQL TEMP_STRING + .OBJECT_FAB[FAB$B_FNS] -1)
	THEN
	    BEGIN
	    FLAGS[IN_ELLIPSE] = 1;		! Show that there's a trailing ellipse
	    CH$WCHAR (..STR_PTR, .STR_PTR - 3);	! Put the end bracket in place
	    OBJECT_FAB[FAB$L_FNA] = TEMP_STRING;	! Set up FAB fields
	    OBJECT_FAB[FAB$B_FNS] = .STR_PTR - 3 - TEMP_STRING + 1;
	    END;
	END

! If here, then the trailing ellipse has been processed, and this is the 
! second time thru.  Restore the original file name.

    ELSE
	BEGIN
	OBJECT_FAB[FAB$L_FNA] = .FILE_DESC[DSC$A_POINTER];	! Original filename
	OBJECT_FAB[FAB$B_FNS] = .FILE_DESC[DSC$W_LENGTH];	! Original length
	FLAGS[IN_ELLIPSE] = 0;				! Ellipse processed
	END;

! Parse the input string

    $NAM_INIT (NAM = RELATED_NAM);			! Re-init the RLF
    IF (.OBJECT_NAM[NAM$B_DEV] NEQ 0)			! If a device was
    THEN						! specified, then
	BEGIN
	OBJECT_FAB[FAB$L_DNA] = .OBJECT_NAM[NAM$L_DEV];	! Make device sticky
	OBJECT_FAB[FAB$B_DNS] = .OBJECT_NAM[NAM$B_DEV];
	END;
    IF NOT (STATUS = $PARSE (FAB = OBJECT_FAB))
    THEN
	BEGIN
	DESC[DSC$W_LENGTH] = .OBJECT_FAB[FAB$B_FNS];
	DESC[DSC$A_POINTER] = .OBJECT_FAB[FAB$L_FNA];
	FILE_ERROR (SET$_SYNTAX, OBJECT_FAB, .STATUS, 0);
	END;

! Check the parsed string for legality, i.e. nothing after the directory

    IF (.OBJECT_NAM[NAM$B_NAME] NEQ 0 OR
	.OBJECT_NAM[NAM$B_TYPE] NEQ 1 OR
	.OBJECT_NAM[NAM$B_VER]  NEQ 1 )
    THEN 
	BEGIN
	DESC[DSC$W_LENGTH] = .OBJECT_FAB[FAB$B_FNS];
	DESC[DSC$A_POINTER] = .OBJECT_FAB[FAB$L_FNA];
	FILE_ERROR (SET$_SYNTAX, OBJECT_FAB, SS$_BADIRECTORY, 0);
	END;

! Determine what the directory terminator character was, and save it.

    ENDCHAR = .(.OBJECT_NAM[NAM$L_DIR] + .OBJECT_NAM[NAM$B_DIR] - 1);

! The directory string must now be analyzed and manipulated so that the
! final directory entry becomes a file.  First, initialize some pointers.

    DESC[DSC$W_LENGTH] = .OBJECT_NAM[NAM$B_ESL] - 2;
    DESC[DSC$A_POINTER] = .OBJECT_NAM[NAM$L_ESA];
    STR_PTR = .DESC[DSC$A_POINTER];
    STR_LEN = .DESC[DSC$W_LENGTH];
    PTR = 0;
    EOS = .DESC[DSC$A_POINTER] + .DESC[DSC$W_LENGTH] -1;

! Look for wildcard ellipses

    WHILE NOT CH$FAIL (TEMP = CH$FIND_SUB (.STR_LEN, .STR_PTR,
					   3, UPLIT ('...')))
    DO
	BEGIN

! Make PTR point to the beginning of the "...", and advance the string
! pointer to the character just past the "..."

	PTR = .TEMP;
	STR_LEN = .STR_LEN - (.TEMP - .STR_PTR) -3;
	STR_PTR = .TEMP + 3;
	END;

! If there was any occurrence of "...", point just past it.

    IF .PTR NEQ 0 THEN PTR = .PTR + 3;

! Find the last directory in the specification

    WHILE NOT CH$FAIL ( TEMP = CH$FIND_CH (.STR_LEN, .STR_PTR, '.'))
    DO
	BEGIN

! Make PTR point to the ".", and advance the string pointer to 
! the first character after the "."

	PTR = .TEMP;
	STR_LEN = .STR_LEN - (.TEMP - .STR_PTR) - 1;
	STR_PTR = .TEMP + 1;
	END;

    IF .PTR NEQ 0
    THEN
	BEGIN

! If here, then either a trailing ellipse, or a final sub-directory
! was specified.  If the pointer is at the bracket, then there is a 
! trailing ellipse, in which case only a "*" is required.

	IF .PTR EQL .EOS
	THEN
	    BEGIN
	    CH$A_WCHAR ('*', PTR);		! Stick an asterisk after the bracket.
	    PTR = .PTR + 1;			! Adjust the pointer.
	    END

! If the pointer is inside the bracket, then the last directory name
! must be moved out of the brackets.

	ELSE
	    BEGIN

! Check to see if the directory is [main.sub] or [main...sub]

	    IF .PTR EQLU .STR_PTR
	    THEN
		BEGIN				! [main...sub] form
		STR_LEN = .EOS - .PTR;
		CH$MOVE (.STR_LEN, .PTR, .PTR+1);
		CH$WCHAR (.ENDCHAR, .PTR);
		PTR = .PTR + .STR_LEN + 1;
		END				! end of [main...sub] processing
	    ELSE
		BEGIN				! [main.sub] form
		STR_LEN = .EOS - .STR_PTR;
		CH$WCHAR_A (.ENDCHAR, PTR);
		PTR = .PTR + .STR_LEN;
		END;				! end of [main.sub] processing
	    END;
	END					! End of non-zero pointer stuff
    ELSE
	BEGIN

! If the pointer is still zero, then there is either a wildcard, a main
! directory, or a [g,m] directory.  In all such cases, a main directory
! of [000000] must be fabricated.

	STATUS = CH$FIND_CH (.STR_LEN, .STR_PTR, ',');	! Save for later

! Move the string out seven spaces and insert "000000]"

	STR_PTR = .DESC[DSC$A_POINTER] + .OBJECT_NAM[NAM$B_DEV] + 1;
	TEMP = CH$MOVE (.EOS - .STR_PTR, .STR_PTR, .STR_PTR + 7);
	STR_PTR = CH$MOVE (6, UPLIT ('000000'), .STR_PTR);
	CH$MOVE (1, ENDCHAR, .STR_PTR);

! If no comma was found, then all that is required is to update the 
! pointer.

	IF CH$FAIL (.STATUS) THEN PTR = .TEMP

! Otherwise, it's a [g,m] directory.  Convert it.

	ELSE
	    BEGIN

	    LOCAL TPARSE_BLOCK : $BBLOCK[TPA$K_LENGTH0];	! Define a TPARSE block

	    CH$FILL (0, TPA$K_LENGTH0, TPARSE_BLOCK);	! Zero it.
	    TPARSE_BLOCK[TPA$L_COUNT] = TPA$K_COUNT0;	! Fill in size

	    TPARSE_BLOCK[TPA$L_STRINGCNT] = .EOS - .STR_PTR;
	    TPARSE_BLOCK[TPA$L_STRINGPTR] = .STR_PTR + 7;
	    IF NOT (STATUS = LIB$TPARSE (TPARSE_BLOCK,
					 DIR_STATE,
					 DIR_KEYS))
	    THEN FILE_ERROR (SET$_SYNTAX, OBJECT_FAB, .STATUS, 0)
	    ELSE
		BEGIN
		LOCAL TEMP_DESC : $BBLOCK[DSC$C_S_BLN];
		TEMP_DESC[DSC$W_LENGTH] = 6;
		TEMP_DESC[DSC$A_POINTER] = .STR_PTR + 7;
		IF NOT (STATUS = $FAO ($DESCRIPTOR('!2(3OW)'),
				       TEMP_DESC,
				       TEMP_DESC,
				       .DIR_GROUP,
				       .DIR_MEMBER))
		THEN FILE_ERROR (SET$_SYNTAX, OBJECT_FAB, .STATUS, 0)
		ELSE PTR = .STR_PTR + 14;
		END;
	    END;
	END;
    PTR = CH$MOVE (4, UPLIT ('.DIR'), .PTR);
    OBJECT_FAB[FAB$B_FNS] = .PTR - .DESC[DSC$A_POINTER];
    OBJECT_FAB[FAB$L_FNA] = .DESC[DSC$A_POINTER];
    END;

RETURN 1;

END;						! End of routine GET_FILE

ROUTINE PROCESS_FILE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine takes the spec from LIB$FILE_SCAN, and calls the
!	appropriate routine based upon the command line qualifiers.
!
! CALLING SEQUENCE:
!	PROCESS_FILE
!
! INPUT PARAMETERS:
!	none
!
! IMPLICIT INPUTS:
!	none
!
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	1 if successful
!	error code otherwise
!
! SIDE EFFECTS:
!	none
!
!--

BEGIN

LOCAL
	FILE_NAME	: $BBLOCK [DSC$C_S_BLN],	! File name to log
	FAB		: $FAB_DECL,		! Storage for the FAB
	NAM		: $NAM_DECL,		! Storage for the NAMe block
	XABDAT		: $XABDAT_DECL,		! Date XAB storage
	XABPRO		: $XABPRO_DECL,		! Protection XAB storage
	FILE_CHAR	: $BBLOCK [4],		! Target file characteristics
	IO_STATUS	: VECTOR [4, WORD],	! I/O status block
	STATUS,					! Local routine return status
	STATUS1;				! Second local routine exit status

! Open the the specified file.

CH$FILL (0, 3 * ITM$S_ITEM, ATR_ARGLIST);
CH$MOVE (NAM$C_BLN, .OBJECT_FAB[FAB$L_NAM], NAM);
$FAB_INIT (FAB = FAB,
	   FAC = <GET, PUT>,
	   FOP = <NAM, UFO>,
	   NAM = NAM,
	   SHR = NIL,
	   XAB = XABDAT);
$XABDAT_INIT (XAB = XABDAT,
	      NXT = XABPRO);
$XABPRO_INIT (XAB = XABPRO);

STATUS = $OPEN (FAB = FAB);

! Set up the actual file name.

CH$FILL (0, DSC$C_S_BLN, FILE_NAME);
IF .NAM[NAM$B_RSL] NEQ 0
THEN
    BEGIN
    FILE_NAME[DSC$W_LENGTH] = .NAM[NAM$B_RSL];
    FILE_NAME[DSC$A_POINTER] = .NAM[NAM$L_RSA];
    END
ELSE IF .NAM[NAM$B_ESL] NEQ 0
THEN
    BEGIN
    FILE_NAME[DSC$W_LENGTH] = .NAM[NAM$B_ESL];
    FILE_NAME[DSC$A_POINTER] = .NAM[NAM$L_ESA];
    END
ELSE
    BEGIN
    FILE_NAME[DSC$W_LENGTH] = .FAB[FAB$B_FNS];
    FILE_NAME[DSC$A_POINTER] = .FAB[FAB$L_FNA];
    END;

! If there are any errors on the open, note them.

IF NOT .STATUS
THEN
    BEGIN

! If the error is a "file locked by another user" error and the file-id of the
! source and tarket files match, simply ignore the error and go process the next
! in line.  Otherwise, note the error.

    IF .FAB[FAB$L_STS] NEQ RMS$_FLK
    OR CH$NEQ (6, SOBJECT_NAM[NAM$W_FID], 6, OBJECT_NAM[NAM$W_FID], 0)
    THEN FILE_ERROR (SET$_OPENIN, FAB, .FAB[FAB$L_STS], .FAB[FAB$L_STV]);
    RETURN 1;
    END;

CHAN = .FAB[FAB$L_STV];

! See if the file matches the criteria specified by the common command
! qualifiers.

IF NOT LIB$QUAL_FILE_MATCH (COMMON_CTX,
			    FAB,
			    0,
			    $DESCRIPTOR ('%SET-I-MODIFY, modify ACL on !AS [N]:'),
			    %REF (FILE_NAME),
			    0) THEN RETURN 1;

! Determine whether or not the target file is a directory file.

ATR_ARGLIST[0, ITM$W_ITMCOD] = ATR$C_UCHAR;
ATR_ARGLIST[0, ITM$W_BUFSIZ] = ATR$S_UCHAR;
ATR_ARGLIST[0, ITM$L_BUFADR] = FILE_CHAR;
STATUS = $QIOW (CHAN = .CHAN,
		FUNC = IO$_ACCESS,
		IOSB = IO_STATUS,
		P5 = ATR_ARGLIST);
IF .STATUS THEN STATUS = .IO_STATUS[0];
IF NOT .STATUS
THEN
    BEGIN
    SIGNAL (SET$_OPENIN, 1, FILE_NAME, .STATUS, 0);
    RETURN 1;				! Return without doing anything
    END;
FLAGS[DIRECTORY] = .FILE_CHAR[FCH$V_DIRECTORY];

! If the /DEFAULT qualifier is being processed, make sure that the parent
! directory of the current file is accessed on the source object channel.

IF .FLAGS[QUAL_DEFAULT]
THEN
    BEGIN

! If a channel has not been assigned to the source object, assign a channel
! to the device for the  parent directory.

    IF .SCHAN EQL 0
    THEN
	BEGIN
	CH$FILL (0, DSC$C_S_BLN, SDEVICE_DESC);
	SDEVICE_DESC[DSC$W_LENGTH] = .VECTOR [NAM[NAM$T_DVI], 0;, BYTE];
	SDEVICE_DESC[DSC$A_POINTER] = NAM[NAM$T_DVI] + 1;
	STATUS = $ASSIGN (DEVNAM = SDEVICE_DESC, CHAN = SCHAN);
	IF NOT .STATUS
	THEN
	    BEGIN
	    SIGNAL (SET$_OPENIN, 1, SDEVICE_DESC, .STATUS, 0);
	    RETURN 1;
	    END;
	END;

! If there is already a directory accessed on the source object channel, and
! the file-IDs are not the same, deaccess the directory file.

    IF .SFILE_FIB[FIB$W_FID_NUM] NEQ 0
    AND CH$NEQ (FIB$S_FID, SFILE_FIB[FIB$W_FID], FIB$S_FID, NAM[NAM$W_DID], 0)
    THEN
	BEGIN
	STATUS = $QIOW (CHAN = .SCHAN,
			FUNC = IO$_DEACCESS,
			IOSB = IO_STATUS);
	IF .STATUS THEN STATUS = .IO_STATUS[0];
	IF NOT .STATUS THEN SIGNAL (SET$_CLOSEIN, 1, SOBJECT_DESC, .STATUS, 0);
	SFILE_FIB[FIB$W_FID_NUM] = 0;		! To force access below

! Now release the read lock that was taken out for the directory file.

	ATR_ARGLIST[0, ITM$W_ITMCOD] = ACL$C_UNLOCK_ACL;
	ATR_ARGLIST[0, ITM$W_BUFSIZ] = 4;
	ATR_ARGLIST[0, ITM$L_BUFADR] = SACL_LOCKID;
	STATUS = $CHANGE_ACL (CHAN = .SCHAN,
			      OBJTYP = SOBJECT_TYPE,
			      OBJNAM = SOBJECT_DESC,
			      ITMLST = ATR_ARGLIST);
	IF NOT .STATUS THEN SIGNAL (SET$_CLOSEIN, 1, SOBJECT_DESC, .STATUS, 0);
	END;

! If there is not a directory file currently accessed, do so now.

    IF .SFILE_FIB[FIB$W_FID_NUM] EQL 0
    THEN
	BEGIN
	SFILE_FIB[FIB$L_ACCTL] = 0;
	CH$MOVE (FIB$S_FID, NAM[NAM$W_DID], SFILE_FIB[FIB$W_FID]);
	STATUS = $QIOW (CHAN = .SCHAN,
			FUNC = IO$_ACCESS OR IO$M_ACCESS,
			IOSB = IO_STATUS,
			P1 = SFIB_DESC);
	IF .STATUS THEN STATUS = .IO_STATUS[0];
	IF NOT .STATUS
	THEN
	    BEGIN
	    SIGNAL (SET$_OPENIN, 1, SDEVICE_DESC, .STATUS, 0);
	    RETURN 1;
	    END;

! Get the file spec for the parent directory file, in case any errors occur.

	LIB$FID_TO_NAME (SDEVICE_DESC, SFILE_FIB[FIB$W_FID],
			 SOBJECT_DESC, SOBJECT_DESC,
			 0, STATUS1);

! Attempt to obtain a read lock for the source object.

	ATR_ARGLIST[0, ITM$W_ITMCOD] = ACL$C_RLOCK_ACL;
	ATR_ARGLIST[0, ITM$W_BUFSIZ] = ACL$S_RLOCK_ACL;
	ATR_ARGLIST[0, ITM$L_BUFADR] = SACL_LOCKID;
	STATUS = $CHANGE_ACL (CHAN = .SCHAN,
			      OBJTYP = SOBJECT_TYPE,
			      OBJNAM = SOBJECT_DESC,
			      ITMLST = ATR_ARGLIST);
	IF NOT .STATUS
	THEN
	    BEGIN
	    IF .STATUS EQL SS$_NOTQUEUED
	    THEN SIGNAL (SET$_OBJLOCKED)
	    ELSE SIGNAL (.STATUS);
	    RETURN 1;
	    END;
	END;
    END;

! Attempt to obtain a write lock for the target object.

ATR_ARGLIST[0, ITM$W_ITMCOD] = ACL$C_WLOCK_ACL;
ATR_ARGLIST[0, ITM$W_BUFSIZ] = ACL$S_WLOCK_ACL;
ATR_ARGLIST[0, ITM$L_BUFADR] = ACL_LOCKID;
STATUS = $CHANGE_ACL (CHAN = .CHAN,
		      OBJTYP = OBJECT_TYPE,
		      OBJNAM = FILE_NAME,
		      ITMLST = ATR_ARGLIST);
IF NOT .STATUS
THEN
    BEGIN
    IF .STATUS EQL SS$_NOTQUEUED
    THEN SIGNAL (SET$_OBJLOCKED)
    ELSE SIGNAL (.STATUS);
    RETURN 1;
    END;

! Call the necessary routine based upon the command line qualifiers.

IF .FLAGS[QUAL_LIKE] OR .FLAGS[QUAL_DEFAULT] THEN STATUS = COPY_ACL (FILE_NAME)
ELSE IF .FLAGS[QUAL_DELETE] THEN STATUS = DELETE_ACL (FILE_NAME)
     ELSE IF .FLAGS[QUAL_REPLACE] THEN STATUS = REPLACE_ACL (FILE_NAME)
	  ELSE STATUS = ADD_ACL (FILE_NAME);

! Now release the write lock that was taken out.

ATR_ARGLIST[0, ITM$W_ITMCOD] = ACL$C_UNLOCK_ACL;
ATR_ARGLIST[0, ITM$W_BUFSIZ] = 4;
ATR_ARGLIST[0, ITM$L_BUFADR] = ACL_LOCKID;
STATUS = $CHANGE_ACL (CHAN = .CHAN,
		      OBJTYP = OBJECT_TYPE,
		      OBJNAM = FILE_NAME,
		      ITMLST = ATR_ARGLIST);

! If logging is being done, indicate that the object has been modified.

IF .FLAGS[QUAL_LOG] AND .STATUS
THEN SIGNAL (SET$_MODIFIED, 1, FILE_NAME);

! Tie off the opened input file, if necessary.

IF .STATUS
THEN
    BEGIN
    STATUS = $QIOW (CHAN = .CHAN,
		    FUNC = IO$_DEACCESS,
		    IOSB = IO_STATUS);
    IF .STATUS THEN STATUS = .IO_STATUS[0];
    IF NOT .STATUS
    THEN
	BEGIN
	FILE_ERROR (SET$_CLOSEIN, FAB, .STATUS, 0);
	RETURN 1;
	END;
    STATUS = $DASSGN (CHAN = .CHAN);
    IF NOT .STATUS
    THEN
	BEGIN
	FILE_ERROR (SET$_CLOSEIN, FAB, .STATUS, 0);
	RETURN 1;
	END;
    END;

RETURN 1;

END;						! End of routine PROCESS_FILE

ROUTINE ADD_ACL (OBJECT_NAME_DESC) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine adds ACEs to the end of the ACL or inserts ACEs into
!	various points within the ACL.
!
! CALLING SEQUENCE:
!	ADD_ACL (ARG1)
!
! INPUT PARAMETERS:
!	ARG1: address of the FAB
!
! IMPLICIT INPUTS:
!	none
!
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	1 if successful
!	error code otherwise
!
! SIDE EFFECTS:
!	none
!
!--

BEGIN

LOCAL
	STATUS;					! Local routine return status

! Preset the context to start adding ACEs at the beginning of the ACL.

ACL_CONTEXT = 0;

! If this is a new ACL, delete any ACL that currently exists on the object.

IF .FLAGS[QUAL_NEW]
THEN
    BEGIN
    ATR_ARGLIST[0, ITM$W_ITMCOD] = ACL$C_DELETEACL;
    ATR_ARGLIST[0, ITM$W_BUFSIZ] = ACL$S_DELETEACL;
    ATR_ARGLIST[0, ITM$L_BUFADR] = ACE;
    STATUS = $CHANGE_ACL (CHAN = .CHAN,
			  OBJTYP = OBJECT_TYPE,
			  OBJNAM = .OBJECT_NAME_DESC,
			  ITMLST = ATR_ARGLIST,
			  CONTXT = ACL_CONTEXT);
    IF NOT .STATUS
    THEN
	BEGIN
	SIGNAL (SET$_WRITEERR, .OBJECT_NAME_DESC, .STATUS, 0);
	RETURN SET$_WRITEERR OR STS$M_INHIB_MSG;
	END;
    END;

! For an insert, first locate the ACE after which the new ACEs will be added.

IF .FLAGS[QUAL_AFTER]
THEN
    BEGIN
    ACE_POINTER = .OLD_ACE_HEAD[ACEQ_L_FLINK];
    CH$MOVE (.$BBLOCK[ACE_POINTER[ACEQ_T_ACE], ACE$B_SIZE],
	     ACE_POINTER[ACEQ_T_ACE], ACE);
    ATR_ARGLIST[0, ITM$W_ITMCOD] = ACL$C_FNDACLENT;
    ATR_ARGLIST[0, ITM$W_BUFSIZ] = .ACE[ACE$B_SIZE];
    ATR_ARGLIST[0, ITM$L_BUFADR] = ACE;
    STATUS = $CHANGE_ACL (CHAN = .CHAN,
			  OBJTYP = OBJECT_TYPE,
			  OBJNAM = .OBJECT_NAME_DESC,
			  ITMLST = ATR_ARGLIST,
			  CONTXT = ACL_CONTEXT);
    IF NOT .STATUS
    THEN
	BEGIN
	SIGNAL (SET$_WRITEERR, 1, .OBJECT_NAME_DESC, .STATUS, 0);
	RETURN SET$_WRITEERR OR STS$M_INHIB_MSG;
	END;
    IF .ACE[ACE$B_SIZE] EQL 0
    THEN
	BEGIN
	IF .ACE[ACE$W_FLAGS] NEQ SS$_ACLEMPTY
	THEN
	    BEGIN
	    SIGNAL (SET$_WRITEERR, 1, .OBJECT_NAME_DESC, .ACE[ACE$W_FLAGS], 0);
	    RETURN SET$_WRITEERR OR STS$M_INHIB_MSG;
	    END;
	END;
    ACL_CONTEXT = .ACL_CONTEXT + 1;
    END;

! Now that the context has been set, add the new ACEs.

ACE_POINTER = .NEW_ACE_HEAD[ACEQ_L_FLINK];
UNTIL .ACE_POINTER EQLA NEW_ACE_HEAD[ACEQ_L_FLINK]
DO
    BEGIN
    CH$MOVE (.$BBLOCK[ACE_POINTER[ACEQ_T_ACE], ACE$B_SIZE],
	     ACE_POINTER[ACEQ_T_ACE], ACE);
    ATR_ARGLIST[0, ITM$W_ITMCOD] = ACL$C_ADDACLENT;
    ATR_ARGLIST[0, ITM$W_BUFSIZ] = .ACE[ACE$B_SIZE];
    ATR_ARGLIST[0, ITM$L_BUFADR] = ACE;
    STATUS = $CHANGE_ACL (CHAN = .CHAN,
			  OBJTYP = OBJECT_TYPE,
			  OBJNAM = .OBJECT_NAME_DESC,
			  ITMLST = ATR_ARGLIST,
			  CONTXT = ACL_CONTEXT);
    IF NOT .STATUS
    THEN
	BEGIN
	SIGNAL (SET$_WRITEERR, 1, .OBJECT_NAME_DESC, .STATUS, 0);
	RETURN SET$_WRITEERR OR STS$M_INHIB_MSG;
	END;
    ACE_POINTER = .ACE_POINTER[ACEQ_L_FLINK];
    END;

RETURN 1;

END;						! End of routine ADD_ACL

ROUTINE DELETE_ACL (OBJECT_NAME_DESC) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine deletes one or more ACEs (or the entire ACL) from
!	the specified object.
!
! CALLING SEQUENCE:
!	ADD_ACL (ARG1)
!
! INPUT PARAMETERS:
!	ARG1: address of the FAB
!
! IMPLICIT INPUTS:
!	none
!
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	1 if successful
!	error code otherwise
!
! SIDE EFFECTS:
!	none
!
!--

BEGIN

LOCAL
	STATUS;					! Local routine return status

! If there were ACEs given on the /ACL qualifier, just those specified ACEs
! are deleted.  Otherwise, the entire ACL is deleted.

IF .OLD_ACE_HEAD[ACEQ_L_FLINK] NEQA OLD_ACE_HEAD[ACEQ_L_FLINK]
THEN
    BEGIN

! Before deleting any of the given ACEs, make sure that they all exist.

    ACE_POINTER = .OLD_ACE_HEAD[ACEQ_L_FLINK];
    UNTIL .ACE_POINTER EQLA OLD_ACE_HEAD[ACEQ_L_FLINK]
    DO
	BEGIN
	CH$MOVE (.$BBLOCK[ACE_POINTER[ACEQ_T_ACE], ACE$B_SIZE],
		 ACE_POINTER[ACEQ_T_ACE], ACE);
	ATR_ARGLIST[0, ITM$W_ITMCOD] = ACL$C_FNDACLENT;
	ATR_ARGLIST[0, ITM$W_BUFSIZ] = .ACE[ACE$B_SIZE];
	ATR_ARGLIST[0, ITM$L_BUFADR] = ACE;
	STATUS = $CHANGE_ACL (CHAN = .CHAN,
			      OBJTYP = OBJECT_TYPE,
			      OBJNAM = .OBJECT_NAME_DESC,
			      ITMLST = ATR_ARGLIST,
			      CONTXT = ACL_CONTEXT);
	IF NOT .STATUS
	THEN
	    BEGIN
	    IF .STATUS NEQ SS$_ACLEMPTY
	    AND .STATUS NEQ SS$_NOENTRY
	    THEN
		BEGIN
		SIGNAL (SET$_WRITEERR, 1, .OBJECT_NAME_DESC, .STATUS, 0);
		RETURN SET$_WRITEERR OR STS$M_INHIB_MSG;
		END;
	    ACE_DESC[DSC$W_LENGTH] = .$BBLOCK[ACE_POINTER[ACEQ_T_ACE], ACE$B_SIZE];
	    ACE_DESC[DSC$A_POINTER] = ACE_POINTER[ACEQ_T_ACE];
	    ACE_TEXT_DESC[DSC$W_LENGTH] = 3072;
	    ACE_TEXT_DESC[DSC$A_POINTER] = ACE_TEXT;
	    $FORMAT_ACL (ACLENT = ACE_DESC,
			 ACLLEN = ACE_TEXT_DESC[DSC$W_LENGTH],
			 ACLSTR = ACE_TEXT_DESC,
			 WIDTH = %REF (80),
			 TRMDSC = $DESCRIPTOR (%CHAR (13), %CHAR (10)),
			 INDENT = %REF (4));
	    SIGNAL (SET$_NOSUCHACE, 2, .OBJECT_NAME_DESC, ACE_TEXT_DESC);
	    END;
	ACE_POINTER = .ACE_POINTER[ACEQ_L_FLINK];
	END;

! Delete the specified ACEs.

    ACE_POINTER = .OLD_ACE_HEAD[ACEQ_L_FLINK];
    UNTIL .ACE_POINTER EQLA OLD_ACE_HEAD[ACEQ_L_FLINK]
    DO
	BEGIN
	CH$MOVE (.$BBLOCK[ACE_POINTER[ACEQ_T_ACE], ACE$B_SIZE],
		 ACE_POINTER[ACEQ_T_ACE], ACE);
	ATR_ARGLIST[0, ITM$W_ITMCOD] = ACL$C_DELACLENT;
	ATR_ARGLIST[0, ITM$W_BUFSIZ] = .ACE[ACE$B_SIZE];
	ATR_ARGLIST[0, ITM$L_BUFADR] = ACE;
	STATUS = $CHANGE_ACL (CHAN = .CHAN,
			      OBJTYP = OBJECT_TYPE,
			      OBJNAM = .OBJECT_NAME_DESC,
			      ITMLST = ATR_ARGLIST,
			      CONTXT = ACL_CONTEXT);
	IF NOT .STATUS
	THEN
	    BEGIN
	    SIGNAL (SET$_WRITEERR, 1, .OBJECT_NAME_DESC, .STATUS, 0);
	    RETURN SET$_WRITEERR OR STS$M_INHIB_MSG;
	    END;
	ACE_POINTER = .ACE_POINTER[ACEQ_L_FLINK];
	END;
    END
ELSE
    BEGIN

! Delete any ACL that currently exists on the object.

    ATR_ARGLIST[0, ITM$W_ITMCOD] = ACL$C_DELETEACL;
    ATR_ARGLIST[0, ITM$W_BUFSIZ] = ACL$S_DELETEACL;
    ATR_ARGLIST[0, ITM$L_BUFADR] = ACE;
    STATUS = $CHANGE_ACL (CHAN = .CHAN,
			  OBJTYP = OBJECT_TYPE,
			  OBJNAM = .OBJECT_NAME_DESC,
			  ITMLST = ATR_ARGLIST,
			  CONTXT = ACL_CONTEXT);
    IF NOT .STATUS
    THEN
	BEGIN
	SIGNAL (SET$_WRITEERR, 1, .OBJECT_NAME_DESC, .STATUS, 0);
	RETURN SET$_WRITEERR OR STS$M_INHIB_MSG;
	END;
    END;

RETURN 1;

END;						! End of routine DELETE_ACL

ROUTINE REPLACE_ACL (OBJECT_NAME_DESC) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine deletes the indicated ACEs, and then replaces them
!	with the new ones specified on the /REPLACE qualifier.
!
! CALLING SEQUENCE:
!	ADD_ACL (ARG1)
!
! INPUT PARAMETERS:
!	ARG1: address of the FAB
!
! IMPLICIT INPUTS:
!	none
!
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	1 if successful
!	error code otherwise
!
! SIDE EFFECTS:
!	none
!
!--

BEGIN

LOCAL
	OLD_ACLCTX,				! Old ACL context
	STATUS;					! Local routine return status

! Before deleting any of the given ACEs, make sure that they all exist and
! the order is correct.

OLD_ACLCTX = 0;
ACE_POINTER = .OLD_ACE_HEAD[ACEQ_L_FLINK];
UNTIL .ACE_POINTER EQLA OLD_ACE_HEAD[ACEQ_L_FLINK]
DO
    BEGIN
    CH$MOVE (.$BBLOCK[ACE_POINTER[ACEQ_T_ACE], ACE$B_SIZE],
	     ACE_POINTER[ACEQ_T_ACE], ACE);
    ATR_ARGLIST[0, ITM$W_ITMCOD] = ACL$C_FNDACLENT;
    ATR_ARGLIST[0, ITM$W_BUFSIZ] = .ACE[ACE$B_SIZE];
    ATR_ARGLIST[0, ITM$L_BUFADR] = ACE;
    STATUS = $CHANGE_ACL (CHAN = .CHAN,
			  OBJTYP = OBJECT_TYPE,
			  OBJNAM = .OBJECT_NAME_DESC,
			  ITMLST = ATR_ARGLIST,
			  CONTXT = ACL_CONTEXT);
    IF NOT .STATUS
    THEN
	BEGIN
	IF .STATUS NEQ SS$_ACLEMPTY
	AND .STATUS NEQ SS$_NOENTRY
	THEN
	    BEGIN
	    SIGNAL (SET$_WRITEERR, 1, .OBJECT_NAME_DESC, .STATUS, 0);
	    RETURN SET$_WRITEERR OR STS$M_INHIB_MSG;
	    END;
	ACE_DESC[DSC$W_LENGTH] = .$BBLOCK[ACE_POINTER[ACEQ_T_ACE], ACE$B_SIZE];
	ACE_DESC[DSC$A_POINTER] = ACE_POINTER[ACEQ_T_ACE];
	ACE_TEXT_DESC[DSC$W_LENGTH] = 3072;
	ACE_TEXT_DESC[DSC$A_POINTER] = ACE_TEXT;
	$FORMAT_ACL (ACLENT = ACE_DESC,
		     ACLLEN = ACE_TEXT_DESC[DSC$W_LENGTH],
		     ACLSTR = ACE_TEXT_DESC,
		     WIDTH = %REF (80),
		     TRMDSC = $DESCRIPTOR (%CHAR (13), %CHAR (10)),
		     INDENT = %REF (4));
	SIGNAL (SET$_NOSUCHACE, 2, .OBJECT_NAME_DESC, ACE_TEXT_DESC);
	RETURN SET$_NOSUCHACE OR STS$M_INHIB_MSG;
	END;

! The ACE exists.  Is the ordering correct?

    IF .OLD_ACLCTX NEQ 0
    THEN
	BEGIN
	IF .OLD_ACLCTX<0,24> + 1 NEQ .ACL_CONTEXT
	THEN
	    BEGIN
	    SIGNAL (SET$_IVORDER, 1, .OBJECT_NAME_DESC);
	    RETURN SET$_IVORDER OR STS$M_INHIB_MSG;
	    END;
	END;
    OLD_ACLCTX = .ACL_CONTEXT;
    ACE_POINTER = .ACE_POINTER[ACEQ_L_FLINK];
    END;

! Delete any ACEs specified on the /ACL qualifier.

ACE_POINTER = .OLD_ACE_HEAD[ACEQ_L_FLINK];
UNTIL .ACE_POINTER EQLA OLD_ACE_HEAD[ACEQ_L_FLINK]
DO
    BEGIN
    CH$MOVE (.$BBLOCK[ACE_POINTER[ACEQ_T_ACE], ACE$B_SIZE],
	     ACE_POINTER[ACEQ_T_ACE], ACE);
    ATR_ARGLIST[0, ITM$W_ITMCOD] = ACL$C_DELACLENT;
    ATR_ARGLIST[0, ITM$W_BUFSIZ] = .ACE[ACE$B_SIZE];
    ATR_ARGLIST[0, ITM$L_BUFADR] = ACE;
    STATUS = $CHANGE_ACL (CHAN = .CHAN,
			  OBJTYP = OBJECT_TYPE,
			  OBJNAM = .OBJECT_NAME_DESC,
			  ITMLST = ATR_ARGLIST,
			  CONTXT = ACL_CONTEXT);
    IF NOT .STATUS
    THEN
	BEGIN
	SIGNAL (SET$_WRITEERR, 1, .OBJECT_NAME_DESC, .STATUS, 0);
	RETURN SET$_WRITEERR OR STS$M_INHIB_MSG;
	END;
    IF .ACE[ACE$B_SIZE] EQL 0
    THEN
	BEGIN
	IF .ACE[ACE$W_FLAGS] EQL SS$_ACLEMPTY
	THEN EXITLOOP
	ELSE
	    BEGIN
	    SIGNAL (SET$_WRITEERR, 1, .OBJECT_NAME_DESC, .ACE[ACE$W_FLAGS], 0);
	    RETURN SET$_WRITEERR OR STS$M_INHIB_MSG;
	    END;
	END;
    ACE_POINTER = .ACE_POINTER[ACEQ_L_FLINK];
    END;

! Add the new ACEs specified on the /REPLACE qualifier.

ACE_POINTER = .NEW_ACE_HEAD[ACEQ_L_FLINK];
UNTIL .ACE_POINTER EQLA NEW_ACE_HEAD[ACEQ_L_FLINK]
DO
    BEGIN
    CH$MOVE (.$BBLOCK[ACE_POINTER[ACEQ_T_ACE], ACE$B_SIZE],
	     ACE_POINTER[ACEQ_T_ACE], ACE);
    ATR_ARGLIST[0, ITM$W_ITMCOD] = ACL$C_ADDACLENT;
    ATR_ARGLIST[0, ITM$W_BUFSIZ] = .ACE[ACE$B_SIZE];
    ATR_ARGLIST[0, ITM$L_BUFADR] = ACE;
    STATUS = $CHANGE_ACL (CHAN = .CHAN,
			  OBJTYP = OBJECT_TYPE,
			  OBJNAM = .OBJECT_NAME_DESC,
			  ITMLST = ATR_ARGLIST,
			  CONTXT = ACL_CONTEXT);
    IF NOT .STATUS
    THEN
	BEGIN
	SIGNAL (SET$_WRITEERR, 1, .OBJECT_NAME_DESC, .STATUS, 0);
	RETURN SET$_WRITEERR OR STS$M_INHIB_MSG;
	END;
    ACE_POINTER = .ACE_POINTER[ACEQ_L_FLINK];
    END;

RETURN 1;

END;						! End of routine REPLACE_ACL

ROUTINE COPY_ACL (OBJECT_NAME_DESC) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine is called to copy the ACL from the specified input object
!	to the selected output object.  It is also used to delete the ACL of
!	a object.
!
! CALLING SEQUENCE:
!	COPY_ACL (ARG1)
!
! INPUT PARAMETERS:
!	ARG1: address of the FAB
!
! IMPLICIT INPUTS:
!	none
!
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	1 if successful
!	error code otherwise
!
! SIDE EFFECTS:
!	The ACL is copied from one object to another.
!
!--

BEGIN

LOCAL
	DEVICE_DESC	: $BBLOCK [DSC$C_S_BLN],	! Device name descr
	DEVICE		: $BBLOCK [NAM$C_DVI],	! Device name storage
	OBJECT_FIB_DESC	: $BBLOCK [DSC$C_S_BLN],	! Object's FIB descr
	OBJECT_FIB	: $BBLOCK [FIB$C_LENGTH],	! Object's FIB
	STATUS;					! Local routine return status

! Delete any ACL that currently exists on the object.

ATR_ARGLIST[0, ITM$W_ITMCOD] = ACL$C_DELETEACL;
ATR_ARGLIST[0, ITM$W_BUFSIZ] = ACL$S_DELETEACL;
ATR_ARGLIST[0, ITM$L_BUFADR] = ACE;
STATUS = $CHANGE_ACL (CHAN = .CHAN,
		      OBJTYP = OBJECT_TYPE,
		      OBJNAM = .OBJECT_NAME_DESC,
		      ITMLST = ATR_ARGLIST,
		      CONTXT = ACL_CONTEXT);
IF NOT .STATUS
THEN
    BEGIN
    SIGNAL (SET$_WRITEERR, 1, .OBJECT_NAME_DESC, .STATUS, 0);
    RETURN SET$_WRITEERR OR STS$M_INHIB_MSG;
    END;

! Now that the input and output objects are open, copy the ACL if necessary.

SACL_CONTEXT = 0;

WHILE 1
DO
    BEGIN
    ATR_ARGLIST[0, ITM$W_ITMCOD] = ACL$C_READACE;
    ATR_ARGLIST[0, ITM$W_BUFSIZ] = ACL$S_READACE;
    ATR_ARGLIST[0, ITM$L_BUFADR] = ACE;
    STATUS = $CHANGE_ACL (CHAN = .SCHAN,
			  OBJTYP = SOBJECT_TYPE,
			  OBJNAM = SOBJECT_DESC,
			  ITMLST = ATR_ARGLIST,
			  CONTXT = SACL_CONTEXT);
    IF NOT .STATUS
    THEN
	BEGIN

! Check for the end of the ACL.

	IF .STATUS EQL SS$_ACLEMPTY OR .STATUS EQL SS$_NOMOREACE THEN EXITLOOP;

! Not the end, return the error.

	SIGNAL (SET$_READERR, 1, .SOBJECT_DESC, .STATUS, 0);
	RETURN SET$_READERR OR STS$M_INHIB_MSG;
	END;

! If possible, copy the ACE to the target object.

    IF NOT .ACE[ACE$V_NOPROPAGATE]
    AND (IF .FLAGS[QUAL_DEFAULT]
	 THEN .ACE[ACE$V_DEFAULT] OR .FLAGS[DIRECTORY]
	 ELSE NOT .ACE[ACE$V_HIDDEN])
    THEN
	BEGIN

! If this is a default ACE and the target is not a directory file, clear the
! default option in the ACE.

	IF .FLAGS[QUAL_DEFAULT]
	THEN IF .ACE[ACE$V_DEFAULT]
	     AND NOT .FLAGS[DIRECTORY]
	     THEN ACE[ACE$V_DEFAULT] = 0;

! Now add the ACE to the object's ACL.

	ACL_CONTEXT = -1;
	ATR_ARGLIST[0, ITM$W_ITMCOD] = ACL$C_ADDACLENT;
	ATR_ARGLIST[0, ITM$W_BUFSIZ] = .ACE[ACE$B_SIZE];
	ATR_ARGLIST[0, ITM$L_BUFADR] = ACE;
	STATUS = $CHANGE_ACL (CHAN = .CHAN,
			      OBJTYP = OBJECT_TYPE,
			      OBJNAM = .OBJECT_NAME_DESC,
			      ITMLST = ATR_ARGLIST,
			      CONTXT = ACL_CONTEXT);
	IF NOT .STATUS
	THEN
	    BEGIN
	    SIGNAL (SET$_WRITEERR, 1, .OBJECT_NAME_DESC, .STATUS, 0);
	    RETURN SET$_WRITEERR OR STS$M_INHIB_MSG;
	    END;
	END;
    END;

! Now that the ACL has been copied, return to clean things up.

RETURN 1;

END;						! End of routine COPY_ACL

ROUTINE INPUT_ERROR (FILE_FAB) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine is used to signal errors received on the file scan.
!
! CALLING SEQUENCE:
!	INPUT_ERROR (ARG1)
!
! INPUT PARAMETERS:
!	ARG1: address of the FAB
!
! IMPLICIT INPUTS:
!	none
!
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	1
!
! SIDE EFFECTS:
!	The error is signaled by placing the appropriate message into
!	the output file.
!
!--

BEGIN

MAP
	FILE_FAB	: REF $BBLOCK;		! FAB address

LOCAL
	STATUS;					! Error to signal;

STATUS = SET$_OPENOUT;
IF .FILE_FAB[FAB$L_STS] EQL RMS$_FNF
THEN STATUS = SET$_OPENOUT AND NOT STS$M_SEVERITY OR STS$K_WARNING;

FILE_ERROR (.STATUS, .FILE_FAB, .FILE_FAB[FAB$L_STS],
			        .FILE_FAB[FAB$L_STV]);

RETURN 1;

END;						! End of routine INPUT_ERROR

ROUTINE FILE_ERROR (ERROR_CODE, FILE_FAB, STS, STV) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine is used to signal errors received on files.
!
! CALLING SEQUENCE:
!	FILE_ERROR (ARG1, ARG2, ARG3, ARG4)
!
! INPUT PARAMETERS:
!	ARG1: error code
!	ARG2: address of the FAB
!	ARG3: primary error status
!	ARG4: secondary error status
!
! IMPLICIT INPUTS:
!	none
!
! OUTPUT PARAMETERS:
!	none
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!	1
!
! SIDE EFFECTS:
!	none
!
!--

BEGIN

MAP
	FILE_FAB	: REF $BBLOCK;		! FAB address

BIND
	FILE_NAM	= .FILE_FAB[FAB$L_NAM]	: $BBLOCK;	! NAMe block address

LOCAL
	FILE_NAME	: $BBLOCK [DSC$C_S_BLN];	! Local file name descr

CH$FILL (0, DSC$C_S_BLN, FILE_NAME);
IF .FILE_NAM[NAM$B_RSL] NEQ 0
THEN
    BEGIN
    FILE_NAME[DSC$W_LENGTH] = .FILE_NAM[NAM$B_RSL];
    FILE_NAME[DSC$A_POINTER] = .FILE_NAM[NAM$L_RSA];
    END
ELSE IF .FILE_NAM[NAM$B_ESL] NEQ 0
THEN
    BEGIN
    FILE_NAME[DSC$W_LENGTH] = .FILE_NAM[NAM$B_ESL];
    FILE_NAME[DSC$A_POINTER] = .FILE_NAM[NAM$L_ESA];
    END
ELSE
    BEGIN
    FILE_NAME[DSC$W_LENGTH] = .FILE_FAB[FAB$B_FNS];
    FILE_NAME[DSC$A_POINTER] = .FILE_FAB[FAB$L_FNA];
    END;

SIGNAL (.ERROR_CODE, 1, FILE_NAME, .STS, .STV);

RETURN 1;

END;						! End of routine FILE_ERROR

END
ELUDOM
