%TITLE 'EDT$SCRUPDATE - update the screen'
MODULE EDT$SCRUPDATE (				! Update the screen
		IDENT = 'V04-000'			! File: SCRUPDATE.BLI Edit: JBS1080
		) =
BEGIN
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY:	EDT -- The DEC Standard Editor
!
! ABSTRACT:
!
!	This module does a screen update.
!
! ENVIRONMENT:	Runs at any access mode - AST reentrant
!
! AUTHOR: Bob Kushlis, CREATION DATE: September 8, 1979
!
! MODIFIED BY:
!
! 1-001	- Original.  DJS 12-Feb-1981.  This module was created by
!	extracting the routine EDT$$SC_UPD  from module SCREEN.
! 1-002	- Regularize headers.  JBS 13-Mar-1981
! 1-003	- Make sure the [EOB] test is valid when scrolling backwards.
!	   JBS 17-Sep-1981
! 1-004	- Revise autorepeat subroutine call.  JBS 30-Jan-1982
! 1-005	- Correct some spelling errors in comments.  JBS 02-Apr-1982
! 1-006	- Use new flag for scrolling logic.  JBS 02-Sep-1982
! 1-007 - Use the new screen structure and logic.  SMB 21-Sep-1982
! 1-008	- Remove unused external declaration of EDT$$FMT_LIT.  JBS 05-Oct-1982
! 1-009 - More debugging of screen scrolling and select.  SMB 08-Oct-1982
! 1-010	- Debug NOTRUNCATE mode.  JBS 12-Oct-1982
! 1-011 - Add insert and delete scrolling.  SMB 13-Oct-1982
! 1-012	- Clear EDT$$G_RECS_INSERTED.  JBS 21-Oct-1982
! 1-013 - Scrolling debugging.  SMB 21-Oct-1982
! 1-014	- Move the code for marking select changes for repaint.  JBS 23-Oct-1982
! 1-015	- Simplify the logic that repaints the old screen.  JBS 24-Oct-1982
! 1-016	- Make sure all lines off the screen are marked for repaint, and
!	   support non-scrolling-region terminals.  JBS 24-Oct-1982
! 1-017	- Fix a performance problem with deselecting.  JBS 24-Oct-1982
! 1-018	- Watch out for deleted lines when updating the old screen.  JBS 24-Oct-1982
! 1-019	- Create UPDATE_LINE, so we can add fancy screen stuff for inserted and
!	   deleted lines.  JBS 23-Oct-1982
! 1-021 - Add scrolling to inset and delete line code.  SMB 25-Oct-1982
! 1-022 - Fix scrolling bug - add more notruncate code.  SMB 27-Oct-1982
! 1-023	- If we delete the top line, make the next line top.  JBS 01-Nov-1982
! 1-024	- Don't lose the line number if we must repaint but need not rebuild
!	   the screen data base.  JBS 01-Nov-1982
! 1-025	- Add the call to EDT$$FIX_NOTRUNC.  JBS 01-Nov-1982
! 1-026	- Fix a problem scrolling up on a small screen.  JBS 02-Nov-1982
! 1-027	- Speed up deselecting.  JBS 09-Nov-1982
! 1-028	- Rearrange select range processing.  JBS 10-Nov-1982
! 1-029	- Watch out for deleting the last line of the screen.  JBS 11-Nov-1982
! 1-030	- Recover from running out of memory.  JBS 15-Nov-1982
! 1-031 - Fix bug with cuts on noscroll terminal.  SMB 16-Nov-1982
! 1-032 - Fix notruncate bugs.  SMB 23-Nov-1982
! 1-033	- Worry about deleted lines.  JBS 25-Nov-1982
! 1-034	- Make a few efficiency improvements.  JBS 02-Dec-1982
! 1-035 - Add two paramaters to the SC_LNINS routine.  SMB 03-Dec-1982
! 1-036 - Change calculation of distance to select line. STS 07-Dec-1982
! 1-037	- When scrolling down, if we do not have scrolling regions
!	   erase the line that should have scrolled out of view.  JBS 14-Dec-1982
! 1-038 - Fix small bugs with boundary conditions.  SMB 20-Dec-1982
! 1-039	- Remove the edit buffer.  JBS 27-Dec-1982
! 1-040	- Do less repainting on select.  JBS 27-Dec-1982
! 1-041	- Add a missing dot in edit 1-040.  JBS 28-Dec-1982
! 1-042	- Collapse inserts and deletes together.  JBS 28-Dec-1982
! 1-043	- Add more TOP logic, to recover from rebuilds better.  JBS 29-Dec-1982
! 1-044	- Fix a bug that caused unnecessary rebuilding in NOTRUNCATE mode.  JBS 30-Dec-1982
! 1-045 - Modify setting of scrolling regions for multiple inserts.  SMB 30-Dec-1982
! 1-046 - Bug fixes on setting of top and more multiple insert work.  SMB 05-Jan-1983
! 1-047 - Fix bugs introduced in edit 046.  SMB 11-Jan-1983
! 1-048 - Bug fixes for "moving window" problems on deletes.  SMB 14-Jan-1983
! 1-049	- Worry about deleting the only line in the buffer.  JBS 18-Jan-1983
! 1-050	- Fix painting select regions on continuation lines.  JBS 19-Jan-1983
! 1-051	- Be more cautious about using the old cursor line after a rebuild.  JBS 20-Jan-1983
! 1-052 - Fix scrolling problems for NOSCROLL terminals.  SMB 25-Jan-1983
! 1-053 - Repair backwards scrolling bug introduced by edit 1-052.  SMB 26-Jan-1983
! 1-054	- We were updating the screen wrong if all of the following happened:
!	   1) we reset the screen, 2) we show the current position, and 3) we
!	   must jump to, rather than scroll to, the new position.  In showing
!	   the new position we should not assume that the screen is still erased.  JBS 28-Jan-1983
! 1-055	- Fix unreversing of backward select ranges.  JBS 28-Jan-1983
! 1-056 - Fix VT52 erase to end of screen bug with messages.  SMB 01-Feb-1983
! 1-057 - Avoid excess repainting after a CUT that crosses a line boundry.  JBS 25-Feb-1983
! 1-058	- Don't initialize the screen so often.  JBS 02-Mar-1983
! 1-059	- Mark the select region better on continued lines.  JBS 07-Mar-1983
! 1-060	- If we cut 20 lines and move forward 21 lines in a single keystroke we can
!	   scroll onto the screen lines inserted by the computation of BOTTOM.
!	   Don't fail when encountering such lines.  JBS 19-Mar-1983
! 1-061	- Don't update the screen based on starting or ending a selection if the
!	   screen has just been erased or if the (former) select buffer is not
!	   on the screen.  JBS 21-Mar-1983
! 1-062	- Try to improve performance by skipping over code not needed
!	   in simple cases.  JBS 05-Apr-1983
! 1-063	- We must mark all lines off the screen for repaint if any scrolling
!	   may be needed, because the motion may be done by jumping to the
!	   new area.  JBS 06-Apr-1983
! 1-064	- Add LOAD entry point so we can overlay the notruncate code against
!	   this module, and improve the scrolling heuristics.  JBS 18-Apr-1983
! 1-065	- Don't reference an undefined variable.  JBS 21-Apr-1983
! 1-066	- Fix deleting the top line when a previous line exists.  JBS 29-Apr-1983
! 1-067	- Fix message line handling on non-scrolling-region terminals.  JBS 02-May-1983
! 1-068	- Fix repainting an inserted line which is followed by a deleted line.  JBS 06-May-1983
! 1-069	- Handle the message line correctly on a non-scrolling terminal when deleting
!	   one text line.  JBS 06-May-1983
! 1-070	- Fix some inefficiencies when inserting and deleting lines on terminals that
!	   do not have scrolling regions.  JBS 09-May-1983
! 1-071	- More work on scrolling efficiency.  JBS 10-May-1983
! 1-072	- Don't set the scrolling region so often.  JBS 11-May-1983
! 1-073	- Paint the selected area correctly even if the cursor is moved after the select
!	   and before the screen is updated.  JBS 17-May-1983
! 1-074	- Improve performance when inserting a line in a buffer smaller than
!	   the screen size.  JBS 17-May-1983
! 1-075	- Fix a problem with lines moving into the message area on non-scrolling terminals.  JBS 18-May-1983
! 1-076	- Avoid a timing problem in VT52s by not doing reverse scrolls so fast.  JBS 18-May-1983
! 1-077	- Improve performance when deleting lines on noscrolling terminals.  JBS 19-May-1983
! 1-078	- Watch out for losing EDT$$A_CSR_SCRPTR.  JBS 20-May-1983
! 1-079	- Correct deleting a line when the top line is a continuation line.  JBS 27-May-1983
! 1-080	- Mark lines added to the screen data base as modified rather than inserted, since
!	   they do not come between two existing lines.  JBS 01-Jun-1983
!--


%SBTTL 'Declarations'
!
! TABLE OF CONTENTS:
!

REQUIRE 'EDTSRC:TRAROUNAM';

FORWARD ROUTINE
    EDT$$SC_UPD : NOVALUE,
    DELETE_LINE,
    INSERT_LINE,
    EDT$$LOAD_SCRUPDATE : NOVALUE;

!
! INCLUDE FILES:
!

REQUIRE 'EDTSRC:EDTREQ';

!
! MACROS:
!
!	NONE
!
! EQUATED SYMBOLS:
!
!	NONE
!
! OWN STORAGE:
!
!	NONE
!
! EXTERNAL REFERENCES:
!
!	In the routine

%SBTTL 'EDT$$SC_UPD  - update the screen'

GLOBAL ROUTINE EDT$$SC_UPD 			! Update the screen
    : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is called to do a screen update.  Most of the work done
!	by this routine involves deciding on whether or not scrolling should
!	be done.  Basically, it figures out which line should be on the top
!	of the screen, then determines how far away from the current line it
!	has moved.  The actual update is handled by the EDT$$SC_RFRELN routine.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	EDT$$A_OLD_SEL
!	EDT$$L_LNO_EMPTY
!	EDT$$G_SCR_REBUILD
!	EDT$$A_EOB_SCRPTR
!	EDT$$G_SCR_CHGD
!	EDT$$T_LN_BUF
!	EDT$$A_LST_SCRPTR
!	EDT$$A_CUR_SCRPTR
!	EDT$$A_WK_LN
!	EDT$$Z_EOB_LN
!	EDT$$A_SCR_BUF
!	EDT$$A_FST_SCRPTR
!	EDT$$G_CS_CHNO
!	EDT$$G_CS_OLDCHNO
!	EDT$$L_CS_LN
!	EDT$$G_CS_LNO
!	EDT$$G_CUR_COL
!	EDT$$G_LN_NO
!	EDT$$A_SEL_BUF
!	EDT$$L_TOP_LN
!	EDT$$A_CUR_BUF
!	EDT$$G_SCR_LNS
!	EDT$$G_SCLL_TOP
!	EDT$$G_SCLL_BOT
!	EDT$$G_TI_TYP
!	EDT$$A_LN_PTR
!	EDT$$G_TI_SCROLL
!	EDT$$A_CSR_SCRPTR
!	EDT$$A_TOP_SCRPTR
!	EDT$$A_BOT_SCRPTR
!	EDT$$L_CUR_SCRLN
!	EDT$$A_FST_AVLN
!	EDT$$G_TRUN
!	EDT$$G_RECS_INSERTED
!	EDT$$G_BOT_LINE
!	EDT$$G_TOP_RECNO
!	EDT$$G_ANY_CHANGES
!	EDT$$G_REVID
!
! IMPLICIT OUTPUTS:
!
!	EDT$$A_OLD_SEL
!	EDT$$G_SCR_REBUILD
!	EDT$$A_CSR_SCRPTR
!	EDT$$A_TOP_SCRPTR
!	EDT$$L_CUR_SCRLN
!	EDT$$A_SEL_BUF
!	EDT$$G_CS_CHNO
!	EDT$$G_CS_OLDCHNO
!	EDT$$L_CS_LN
!	EDT$$G_CS_LNO
!	EDT$$G_LN_NO
!	EDT$$L_TOP_LN
!	EDT$$G_CUR_COL
!	EDT$$G_RECS_INSERTED
!	EDT$$A_FST_AVLN
!	EDT$$A_BOT_SCRPTR
!	EDT$$G_MEM_CNT
!	EDT$$G_BOT_LINE
!	EDT$$G_TOP_RECNO
!	EDT$$G_ANY_CHANGES
!	EDT$$G_MSGFLG
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	MANY
!
!--

    BEGIN

    EXTERNAL ROUTINE
	EDT$$SC_SETSCLLREG,			! Set the scrolling region
	EDT$$SC_LNINS,				! Insert a record into the screen data base
	EDT$$FMT_LIT,				! Output a literal string
	EDT$$SC_FNDREC,				! Find the current screen pointer
	EDT$$OUT_FMTBUF,			! Output the format buffer to the screen
	EDT$$RPL_CHGDLN,			! Replace a modified line in the work file
	EDT$$SC_INIT,				! Initialize the screen
	EDT$$SC_CPUCSPOS : NOVALUE,		! Compute the cursor position
	EDT$$SC_POSCSIF : NOVALUE,		! Position the cursor
	EDT$$SC_ERAALL : NOVALUE,		! Erase the screen
	EDT$$SC_MOVTOLN,		! Move to a record in the work file relative to the current record
	EDT$$SC_RFRELN : NOVALUE,		! Refresh a screen line
	EDT$$SC_NONREVID : NOVALUE,		! Put the screen in normal video mode
	EDT$$SC_REPAINT : NOVALUE,		! Mark some lines in the screen data base for repaint
	EDT$$TI_ENBLAUTREP : NOVALUE,		! Enable or disable autorepeat
	EDT$$FIX_NOTRUNC_NOOVERLAY : NOVALUE;	! Fix screen data base in NOTRUNCATE mode

    EXTERNAL
	EDT$$A_BOT_SCRPTR : REF SCREEN_LINE,	! Address of bottom screen line
	EDT$$A_OLD_SEL,				! Address of old select buffer
	EDT$$L_LNO_EMPTY : LN_BLOCK,		! Code for empty line
	EDT$$G_SCR_REBUILD,			! Rebuild the screen
	EDT$$A_EOB_SCRPTR : REF SCREEN_LINE,	! EOB screen pointer
	EDT$$G_SCR_CHGD,			! non-zero = the screen has been mangled
	EDT$$G_MESSAGE_LINE,			! Message line
	EDT$$T_LN_BUF,				! Start of line buffer
	EDT$$A_CSR_SCRPTR : REF SCREEN_LINE,	! Current cursor line screen info
	EDT$$A_CUR_SCRPTR : REF SCREEN_LINE,	! Current workfile line screen pointer
	EDT$$A_LST_SCRPTR : REF SCREEN_LINE,	! Last data structure pointer
	EDT$$A_WK_LN : REF LIN_BLOCK,		! Pointer to current line in work file
	EDT$$Z_EOB_LN,				! Special structure for [EOB] line
	EDT$$A_SCR_BUF : REF TBCB_BLOCK,	! Current screen buffer
	EDT$$A_FST_SCRPTR : REF SCREEN_LINE,	! First screen line info address
	EDT$$A_TOP_SCRPTR : REF SCREEN_LINE,	! Top screen line info address
	EDT$$L_CUR_SCRLN : LN_BLOCK,		! Current screen line record number
	EDT$$G_CS_CHNO,				! character position of cursor
	EDT$$G_CS_OLDCHNO,			! Previous character position of cursor
	EDT$$L_CS_LN : LN_BLOCK,		! record number of cursor line
	EDT$$G_CS_LNO,				! current cursor line
	EDT$$G_CUR_COL,				! current cursor column
	EDT$$G_LN_NO,				! current line number.
	EDT$$A_SEL_POS,				! select character position
	EDT$$L_SEL_LN : LN_BLOCK,		! select record
	EDT$$A_SEL_BUF,				! select buffer.
	EDT$$L_TOP_LN : LN_BLOCK,		! Line number of enforced top line.
	EDT$$A_CUR_BUF : REF TBCB_BLOCK,	! The current buffer tbcb.
	EDT$$G_SCR_LNS,				! No of lines on screen
	EDT$$G_SCLL_TOP,			! Top line for scrolling up
	EDT$$G_SCLL_BOT,			! Bottom line for scrolling down
	EDT$$G_TI_TYP,				! Terminal type.
	EDT$$A_LN_PTR,				! Current character pointer.
	EDT$$G_TI_SCROLL,			! 1 = we have scrolling regions
	EDT$$G_RECS_INSERTED,			! Number of records inserted since the last screen update
	EDT$$A_FST_AVLN : REF SCREEN_LINE,	! List of available screen line data blocks
	EDT$$G_TRUN,				! 0 = SET NOTRUNCATE
	EDT$$G_MEM_CNT,				! Number of lines in the screen data base
	EDT$$G_BOT_LINE,			! All lines below this one have been erased
	EDT$$G_TOP_RECNO,			! Record number of top line
	EDT$$G_ANY_CHANGES,			! 1 = an edit has been made
	EDT$$G_REVID,				! 1 = screen is in reverse video
	EDT$$G_MSGFLG;				! 1 = there is a message in the message area

    LOCAL
	SCROLLING_NEEDED,			! 0 = no scrolling needed
	TOP_DIST,				! Displacement to top scrptr
	TEMP_LINE : LN_BLOCK,			! Temp line number
	TOP_DISP,				! Top line displacement from current
	DIR,					! Direction of motion since last screen update
	SCLL_NUM,				! Scroll line limit
	TOP_SET,				! Top record successfully set
	DISP,					! Displacement from cursor screen line
	ABOVE,					! Number of lines above current
	BUILD_SCR,				! Flag which says rebuild screen
	SCRPTR : REF SCREEN_LINE,		! Address of a current screen line buffer
	CURSOR_POS,				! Column position of cursor
	CURSOR_LINE,				! Number of screen lines before cursor.
	BELOW,					! No. of screen lines below cursor line.
	REC_NO,					! Current relative reocrd number
	OLD_TOP_RECNO,				! Rel record number of old top record
	OLD_BOT_RECNO,				! Rel record number of old bottom record
	TOP_RECNO,				! Rel record number of new top record
	TOP_SCRPTR : REF SCREEN_LINE,		! Address of the top line on the screen
	ERASE_ALL,				! 1 = we have erased the text part of the screen
	LNINS_VAL,				! Value returned by EDT$$SC_LNINS
	ANY_CHANGES;				! 1 = we must scan the screen data base for changes

!+
! Make sure we are in normal video if no select range.
!-

    IF ((.EDT$$G_REVID NEQ 0) AND (.EDT$$A_SEL_BUF NEQA .EDT$$A_CUR_BUF)) THEN EDT$$SC_NONREVID ();

!+
! Remember the original character position and relative line number in
! work file terms.
!-
    EDT$$G_LN_NO = 0;
    EDT$$G_CS_CHNO = .EDT$$A_LN_PTR - EDT$$T_LN_BUF;
    MOVELINE (EDT$$A_CUR_BUF [TBCB_CUR_LIN], EDT$$L_CS_LN);
    EDT$$RPL_CHGDLN ();
!+
! If we are in NOTRUNCATE mode, make sure lines get adjusted due to carry from
! or borrow to earlier lines.
!-

    IF ( NOT .EDT$$G_TRUN)
    THEN
	BEGIN

	IF .EDT$$G_ANY_CHANGES THEN EDT$$FIX_NOTRUNC_NOOVERLAY ();

	END;

    SCRPTR = 0;
!+
! Compute the cursor position.  We will recompute if we must rebuild the screen data base.
!-
    EDT$$SC_CPUCSPOS (CURSOR_LINE, CURSOR_POS);
    CURSOR_LINE = .EDT$$G_CS_LNO;
!+
! If the screen has been mangled, or we have changed buffers or deleted or inserted a lot of lines,
! erase the screen and repaint all the lines.
!-

    IF ((.EDT$$G_SCR_CHGD NEQ 0) OR (.EDT$$A_SCR_BUF NEQA .EDT$$A_CUR_BUF) OR 	!
	(.EDT$$G_RECS_INSERTED GTR (2*.EDT$$G_SCR_LNS)))
    THEN
	BEGIN
!+
! Don't initialize the terminal unless it has been requested.
!-

	IF (.EDT$$G_SCR_CHGD EQL 2) THEN EDT$$SC_INIT ();

!+
! Erase the screen.
!-
	EDT$$G_CS_LNO = 0;
	EDT$$SC_ERAALL ();
	EDT$$G_BOT_LINE = 0;
	ERASE_ALL = 1;
	END
    ELSE
	ERASE_ALL = 0;

!+
! Determine whether the screen structure has to be rebuilt.
!-
    BUILD_SCR = .EDT$$G_SCR_REBUILD;
!+
! If the current position is not in the screen data base, rebuild.
!-

    IF ( NOT .BUILD_SCR)
    THEN
	BEGIN
	EDT$$A_CUR_SCRPTR = EDT$$SC_FNDREC ((.EDT$$A_LN_PTR - EDT$$T_LN_BUF), DISP);

	IF ((.EDT$$A_CUR_SCRPTR EQLA 0) OR (.EDT$$A_TOP_SCRPTR EQLA 0)	!
	    OR (.EDT$$A_CSR_SCRPTR EQLA 0))
	THEN
	    BUILD_SCR = 1;

	END;

!+
! Compute whether or not we must scan the screen data base for any changes.
!-
    ANY_CHANGES = .EDT$$G_ANY_CHANGES;
!+
! Compute the direction of motion since the last screen update.
! If we have changed buffers, assume forward.
!-

    IF ((LINNOEQL (EDT$$L_LNO_EMPTY, EDT$$L_CUR_SCRLN)) OR (.EDT$$A_SCR_BUF NEQA .EDT$$A_CUR_BUF))
    THEN
	DIR = 1
    ELSE
	DIR = CMPLNO (EDT$$L_CS_LN, EDT$$L_CUR_SCRLN);

!+
! Compute whether or not any scrolling may be necessary.
!-

    IF ((.EDT$$G_RECS_INSERTED NEQ 0)		!
	OR (.EDT$$A_CSR_SCRPTR NEQA .EDT$$A_CUR_SCRPTR)	!
	OR ( NOT LINNOEQL (EDT$$L_TOP_LN, EDT$$L_LNO_EMPTY))	!
	OR (.DIR NEQ 0))
    THEN
	SCROLLING_NEEDED = 1
    ELSE
	SCROLLING_NEEDED = 0;

    IF ( NOT .BUILD_SCR)
    THEN
	BEGIN

	IF ((.EDT$$A_SEL_BUF NEQA .EDT$$A_OLD_SEL) AND (.EDT$$G_TI_TYP EQL TERM_VT100) AND 	!
	    ((.EDT$$A_SCR_BUF EQLA .EDT$$A_OLD_SEL) OR (.EDT$$A_SCR_BUF EQLA .EDT$$A_SEL_BUF)) AND 	!
	    ( NOT .ERASE_ALL))
	THEN
	    BEGIN
!+
! We have started or ended a selection.  Repaint all selected or formerly selected lines.
!-

	    LOCAL
		SELDIR,
		REC_OFFSET,
		OUR_LINE : LN_BLOCK,
		OUR_CHNO,
		OUR_SCRPTR : REF SCREEN_LINE;

!+
! If this is a deselection we must repaint from the old line to the select line.
! If this is a selection we must repaint from the current line to the select line.
!-

	    IF (.EDT$$A_SEL_BUF EQLA 0)
	    THEN
		BEGIN
		MOVELINE (EDT$$L_CUR_SCRLN, OUR_LINE);
		SUBLINE (EDT$$L_CUR_SCRLN, EDT$$L_CS_LN, TEMP_LINE);
		REC_OFFSET = .(TEMP_LINE [LN_LO])<0, 16, 1>;
		OUR_CHNO = .EDT$$G_CS_OLDCHNO;
		OUR_SCRPTR = .EDT$$A_CSR_SCRPTR;
		END
	    ELSE
		BEGIN
		MOVELINE (EDT$$L_CS_LN, OUR_LINE);
		REC_OFFSET = 0;
		OUR_CHNO = .EDT$$G_CS_CHNO;
		OUR_SCRPTR = .EDT$$A_CUR_SCRPTR;
		END;

	    SUBLINE (OUR_LINE, EDT$$L_SEL_LN, TEMP_LINE);

	    IF ((.TEMP_LINE [LN_HI] AND %X'8000') NEQ 0)
	    THEN
		SELDIR = -1
	    ELSE

		IF (.TEMP_LINE [LN_LO] NEQU 0) THEN SELDIR = 1 ELSE SELDIR = 0;

	    REC_NO = .(TEMP_LINE [LN_LO])<0, 16, 1> - .REC_OFFSET;
	    EDT$$SC_MOVTOLN (.REC_NO);
	    SCRPTR = EDT$$SC_FNDREC (.EDT$$A_SEL_POS - EDT$$T_LN_BUF, DISP);

	    IF (.SCRPTR EQLA 0)
	    THEN
		BUILD_SCR = 1
	    ELSE
		BEGIN

		IF (.SELDIR EQL 0)
		THEN
		    BEGIN

		    IF ((.EDT$$A_SEL_POS - EDT$$T_LN_BUF) LSS .OUR_CHNO)	!
		    THEN
			EDT$$SC_REPAINT (.SCRPTR, 	!
			    .OUR_SCRPTR, 	!
			    .EDT$$A_SEL_POS - EDT$$T_LN_BUF - .SCRPTR [SCR_CHR_FROM],
			    .OUR_CHNO - .OUR_SCRPTR [SCR_CHR_FROM] - 1, 0)
		    ELSE

			IF ((.EDT$$A_SEL_POS - EDT$$T_LN_BUF) GTR .OUR_CHNO)	!
			THEN
			    EDT$$SC_REPAINT (.OUR_SCRPTR, 	!
				.SCRPTR, 	!
				.OUR_CHNO - .OUR_SCRPTR [SCR_CHR_FROM], 	!
				.EDT$$A_SEL_POS - EDT$$T_LN_BUF - .SCRPTR [SCR_CHR_FROM] - 1, 0);

		    END
		ELSE

		    IF (.SELDIR GTR 0)
		    THEN
			EDT$$SC_REPAINT (.OUR_SCRPTR, 	!
			    .SCRPTR, 		!
			    .OUR_CHNO - .OUR_SCRPTR [SCR_CHR_FROM], 	!
			    .EDT$$A_SEL_POS - EDT$$T_LN_BUF - .SCRPTR [SCR_CHR_FROM] - 1, 0)
		    ELSE

			IF (.SELDIR LSS 0)
			THEN
			    EDT$$SC_REPAINT (.SCRPTR, 	!
				.OUR_SCRPTR, 	!
				.EDT$$A_SEL_POS - EDT$$T_LN_BUF - .SCRPTR [SCR_CHR_FROM], 	!
				.OUR_CHNO - .OUR_SCRPTR [SCR_CHR_FROM] - 1, 0)
			ELSE
			    ASSERT (0);

		END;

	    ANY_CHANGES = 1;
	    END;

	END;

    IF (( NOT .BUILD_SCR) AND ( NOT .ERASE_ALL))
    THEN
	BEGIN

	IF ((.EDT$$A_SEL_BUF EQLA .EDT$$A_CUR_BUF) AND (.EDT$$G_TI_TYP EQL TERM_VT100))
	THEN
	    BEGIN
!+
! The select range is in the current buffer.  Repaint lines between the previous
! and the current cursor, to be sure they are properly reversed or not.
!-

	    IF (.DIR LSS 0)
	    THEN
		EDT$$SC_REPAINT (.EDT$$A_CUR_SCRPTR, .EDT$$A_CSR_SCRPTR,
		    .EDT$$G_CS_CHNO - .EDT$$A_CUR_SCRPTR [SCR_CHR_FROM],
		    .EDT$$G_CS_OLDCHNO - .EDT$$A_CSR_SCRPTR [SCR_CHR_FROM] - 1, 0)
	    ELSE

		IF (.DIR GTR 0)
		THEN
		    EDT$$SC_REPAINT (.EDT$$A_CSR_SCRPTR, .EDT$$A_CUR_SCRPTR,
			.EDT$$G_CS_OLDCHNO - .EDT$$A_CSR_SCRPTR [SCR_CHR_FROM], 	!
			.EDT$$G_CS_CHNO - .EDT$$A_CUR_SCRPTR [SCR_CHR_FROM] - 1, 0)
		ELSE

		    IF (.EDT$$G_CS_CHNO LSS .EDT$$G_CS_OLDCHNO)	!
		    THEN
			EDT$$SC_REPAINT (.EDT$$A_CUR_SCRPTR, 	!
			    .EDT$$A_CSR_SCRPTR, 	!
			    .EDT$$G_CS_CHNO - .EDT$$A_CUR_SCRPTR [SCR_CHR_FROM],
			    .EDT$$G_CS_OLDCHNO - .EDT$$A_CSR_SCRPTR [SCR_CHR_FROM] - 1, 0)
		    ELSE

			IF (.EDT$$G_CS_CHNO GTR .EDT$$G_CS_OLDCHNO)	!
			THEN
			    EDT$$SC_REPAINT (.EDT$$A_CSR_SCRPTR, 	!
				.EDT$$A_CUR_SCRPTR, 	!
				.EDT$$G_CS_OLDCHNO - .EDT$$A_CSR_SCRPTR [SCR_CHR_FROM], 	!
				.EDT$$G_CS_CHNO - .EDT$$A_CUR_SCRPTR [SCR_CHR_FROM] - 1, 0);

	    ANY_CHANGES = 1;
	    END;

	END;

!+
! Mark all lines off the screen for repaint.
!-

    IF ( NOT .BUILD_SCR)
    THEN
	BEGIN
!+
! If the screen has been erased we must repaint everything, otherwise only lines
! off the screen will need to be repainted.  Marking the lines off the screen for
! repaint removes the deleted lines from the screen data base, to avoid confusing
! our count of the number of lines above and below the current line.
!-

	IF .ERASE_ALL
	THEN
	    BEGIN
	    EDT$$SC_REPAINT (.EDT$$A_FST_SCRPTR, .EDT$$A_LST_SCRPTR, 0, 255, 1);
	    ANY_CHANGES = 1;
	    END
	ELSE
	    BEGIN

	    IF .SCROLLING_NEEDED
	    THEN
		BEGIN
		SCRPTR = .EDT$$A_TOP_SCRPTR [SCR_PRV_LINE];

		IF (.SCRPTR NEQA 0) THEN EDT$$SC_REPAINT (.EDT$$A_FST_SCRPTR, .SCRPTR, 0, 255, 1);

		IF (.EDT$$A_BOT_SCRPTR NEQA 0)
		THEN
		    BEGIN
		    SCRPTR = .EDT$$A_BOT_SCRPTR [SCR_NXT_LINE];

		    IF (.SCRPTR NEQA 0) THEN EDT$$SC_REPAINT (.SCRPTR, .EDT$$A_LST_SCRPTR, 0, 255, 1);

		    END;

		END;

	    END;

	END;

!+
! If we have lost our record of the top of the screen we must rebuild.
!-

    IF (.EDT$$A_TOP_SCRPTR EQLA 0) THEN BUILD_SCR = 1;

    IF ( NOT .BUILD_SCR)
    THEN
	BEGIN
!+
! Find the relative record number of the old cursor line.
! We must be careful of deleted lines.  The convention is that a deleted line
! has the record number of the next lower line.  This prevents deleted
! lines before record zero from having negative absolute record numbers.
!-
	SCRPTR = .EDT$$A_CUR_SCRPTR;
	REC_NO = 0;

	CASE .DIR FROM -1 TO 1 OF
	    SET

	    [1] :
		BEGIN
!+
! The new line is after the old.  We must move back in the work file.
!-

		DO
		    BEGIN

		    IF ((.SCRPTR [SCR_LINE_IDX] EQL 0) OR 	!
			((.SCRPTR [SCR_EDIT_FLAGS] AND SCR_EDIT_DELLN) NEQ 0))
		    THEN
			BEGIN

			LOCAL
			    PREV_SCRPTR : REF SCREEN_LINE;

			PREV_SCRPTR = .SCRPTR [SCR_PRV_LINE];

			IF (.PREV_SCRPTR NEQA 0)
			THEN
			    BEGIN

			    IF ((.PREV_SCRPTR [SCR_EDIT_FLAGS] AND SCR_EDIT_DELLN) EQL 0)
			    THEN
				REC_NO = .REC_NO - 1;

			    END;

			END;

		    SCRPTR = .SCRPTR [SCR_PRV_LINE];
		    END
		UNTIL ((.SCRPTR EQLA .EDT$$A_CSR_SCRPTR) OR (.SCRPTR EQLA 0));

		END;

	    [0] :
		BEGIN
!+
! We are positioned correctly in the work file.
!-
		SCRPTR = .EDT$$A_CSR_SCRPTR;
		END;

	    [-1] :
		BEGIN
!+
! The new line is before the old.  We must move forward in the work file.
!-

		DO
		    BEGIN

		    LOCAL
			NEXT_SCRPTR : REF SCREEN_LINE;

		    NEXT_SCRPTR = .SCRPTR [SCR_NXT_LINE];

		    IF (.NEXT_SCRPTR NEQA 0)
		    THEN
			BEGIN

			IF (((.SCRPTR [SCR_EDIT_FLAGS] AND SCR_EDIT_DELLN) EQL 0) AND 	!
			    ((.NEXT_SCRPTR [SCR_LINE_IDX] EQL 0) OR 	!
			    ((.NEXT_SCRPTR [SCR_EDIT_FLAGS] AND SCR_EDIT_DELLN) NEQ 0)))
			THEN
			    REC_NO = .REC_NO + 1;

			END;

		    SCRPTR = .SCRPTR [SCR_NXT_LINE];
		    END
		UNTIL ((.SCRPTR EQLA .EDT$$A_CSR_SCRPTR) OR (.SCRPTR EQLA 0));

		END;

	    [OUTRANGE] :
		ASSERT (0);
	    TES;

!+
! If we couldn't find it, rebuild the screen.
!-

	IF ((.SCRPTR NEQA .EDT$$A_CSR_SCRPTR) OR (.SCRPTR EQLA 0)) THEN BUILD_SCR = 1;

	END;

!+
! Now find the relative record number of the old top line.  We can use the value
! from last time if no scrolling will be needed.
!-

    IF ( NOT .BUILD_SCR)
    THEN
	BEGIN

	IF ( NOT .SCROLLING_NEEDED)
	THEN
	    OLD_TOP_RECNO = .EDT$$G_TOP_RECNO
	ELSE
	    BEGIN

	    WHILE ((.SCRPTR NEQA .EDT$$A_TOP_SCRPTR) AND (.SCRPTR NEQA 0)) DO
		BEGIN

		IF ((.SCRPTR [SCR_LINE_IDX] EQL 0) OR 	!
		    ((.SCRPTR [SCR_EDIT_FLAGS] AND SCR_EDIT_DELLN) NEQ 0))
		THEN
		    BEGIN

		    LOCAL
			PREV_SCRPTR : REF SCREEN_LINE;

		    PREV_SCRPTR = .SCRPTR [SCR_PRV_LINE];

		    IF (.PREV_SCRPTR NEQA 0)
		    THEN
			BEGIN

			IF ((.PREV_SCRPTR [SCR_EDIT_FLAGS] AND SCR_EDIT_DELLN) EQL 0)
			THEN
			    REC_NO = .REC_NO - 1;

			END;

		    END;

		SCRPTR = .SCRPTR [SCR_PRV_LINE];
		END;

	    OLD_TOP_RECNO = .REC_NO;
!+
! If we didn't find it, rebuild the screen data base.
!-

	    IF (.SCRPTR NEQA .EDT$$A_TOP_SCRPTR) THEN BUILD_SCR = 1;

	    END;

	END;

    IF ((.ANY_CHANGES OR .SCROLLING_NEEDED) AND ( NOT .BUILD_SCR))
    THEN
!+
! Update the lines which are on the screen.  This is needed even if no lines have been changed if
! we must do scrolling, in order to compute the relative record number of the bottom line.
!-
	BEGIN

	LOCAL
	    UPDATE_DONE,
	    ANOTHER_PASS,
	    BEG_SCRPTR : REF SCREEN_LINE,
	    INS_COUNT,
	    PREV_INS_COUNT;

!+
! Check for regions containing an equal number of inserted and deleted lines.
! Avoid double scrolling (and scrolling lines off the screen then back on) by
! changing all inserted lines in such regions into modified lines, and freeing
! the deleted lines.
!-

	IF (.EDT$$G_RECS_INSERTED NEQ 0)
	THEN
	    BEGIN

	    DO
		BEGIN
		ANOTHER_PASS = 0;
		INS_COUNT = 0;
		SCRPTR = .EDT$$A_TOP_SCRPTR;

		DO
		    BEGIN
		    UPDATE_DONE = 0;
		    PREV_INS_COUNT = .INS_COUNT;

		    IF ((.SCRPTR [SCR_EDIT_FLAGS] AND SCR_EDIT_INSLN) NEQ 0) THEN INS_COUNT = .INS_COUNT + 1;

		    IF ((.SCRPTR [SCR_EDIT_FLAGS] AND SCR_EDIT_DELLN) NEQ 0) THEN INS_COUNT = .INS_COUNT - 1;

		    IF ((.INS_COUNT NEQ 0) AND (.PREV_INS_COUNT EQL 0)) THEN BEG_SCRPTR = .SCRPTR;

		    IF ((.INS_COUNT EQL 0) AND (.PREV_INS_COUNT NEQ 0))
		    THEN
			BEGIN
!+
! Move the top line down, if it was deleted.
!-

			IF (.BEG_SCRPTR EQLA .EDT$$A_TOP_SCRPTR)
			THEN

			    WHILE ((.EDT$$A_TOP_SCRPTR [SCR_EDIT_FLAGS] AND SCR_EDIT_DELLN) NEQ 0) DO
				EDT$$A_TOP_SCRPTR = .EDT$$A_TOP_SCRPTR [SCR_NXT_LINE];

!+
! Free deleted lines and mark all other lines to be repainted.
!-
			EDT$$SC_REPAINT (.BEG_SCRPTR, .SCRPTR, 0, 255, 1);
			UPDATE_DONE = 1;
			ANOTHER_PASS = 1;
			END
		    ELSE
			BEGIN

			IF (.SCRPTR EQLA .EDT$$A_BOT_SCRPTR) OR (.SCRPTR [SCR_NXT_LINE] EQLA 0)
			THEN
			    UPDATE_DONE = 1
			ELSE
			    SCRPTR = .SCRPTR [SCR_NXT_LINE];

			END;

		    END
		UNTIL .UPDATE_DONE;

		END
	    UNTIL ( NOT .ANOTHER_PASS);

!+
! If more than 2/3 of the lines on the screen are to be deleted or inserted,
! just repaint the screen; repainting is likely to be faster.
!-

	    IF (ABS (.INS_COUNT) GTR ((2*.EDT$$G_SCR_LNS)/3)) THEN BUILD_SCR = 1;

	    END;

	END;

    IF ((.ANY_CHANGES OR .SCROLLING_NEEDED) AND ( NOT .BUILD_SCR))
    THEN
	BEGIN
!+
! Now repaint all the lines so marked, and do any residual inserts and deletes on the screen.
!-

	LOCAL
	    STATUS,				! Insert or Delete status
	    ANOTHER_PASS,			! 1 = make another pass over the data structure
	    UPDATE_DONE,			! 1 = this pass is complete
	    ANY_INS_DEL,			! 1 = some inserts or deletes done during this pass
	    INS_DEL_DONE;			! 1 = all inserts and deletes are complete

!+
! If no records were inserted or deleted then no screen lines should need to be inserted or deleted.
!-
	INS_DEL_DONE = (.EDT$$G_RECS_INSERTED EQL 0);

	DO
	    BEGIN
	    ANOTHER_PASS = 0;
	    ANY_INS_DEL = 0;
	    REC_NO = .OLD_TOP_RECNO;
	    SCRPTR = .EDT$$A_TOP_SCRPTR;
	    EDT$$G_CS_LNO = 0;

	    DO
		BEGIN
		UPDATE_DONE = 0;

		IF ((.SCRPTR [SCR_EDIT_FLAGS] AND 	!
		    (SCR_EDIT_MODIFY OR SCR_EDIT_INSLN OR SCR_EDIT_DELLN)) NEQ 0)
		THEN
		    BEGIN
!+
! Is this a deleted line?
!-

		    IF ((.SCRPTR [SCR_EDIT_FLAGS] AND SCR_EDIT_DELLN) NEQ 0)
		    THEN
			BEGIN
			ASSERT ( NOT .INS_DEL_DONE);
			STATUS = DELETE_LINE (.SCRPTR, OLD_TOP_RECNO);
			ANY_INS_DEL = 1;
			ASSERT ( NOT .STATUS);
			END
		    ELSE

			IF ((.SCRPTR [SCR_EDIT_FLAGS] AND SCR_EDIT_INSLN) NEQ 0)
			THEN
			    BEGIN
			    ASSERT ( NOT .INS_DEL_DONE);
			    STATUS = INSERT_LINE (.SCRPTR, .REC_NO, OLD_TOP_RECNO);
			    ANY_INS_DEL = 1;
!+
! If INSERT_LINE returns true, repaint the current line.  INSERT_LINE will have created a blank
! line for it.
!-

			    IF .STATUS
			    THEN
				BEGIN
				ASSERT (EDT$$SC_MOVTOLN (.REC_NO));
				EDT$$SC_REPAINT (.SCRPTR, .SCRPTR, 0, 255, 1);
				EDT$$SC_RFRELN (.SCRPTR, 1);
				END;

			    END
			ELSE
			    BEGIN
!+
! This line is marked as modified.  If all the processing from lines inserted and deleted is complete
! repaint this line.
!-

			    IF .INS_DEL_DONE
			    THEN
				BEGIN
				ASSERT (EDT$$SC_MOVTOLN (.REC_NO));
				EDT$$SC_RFRELN (.SCRPTR, .ERASE_ALL);
				END;

			    STATUS = 1;
			    END;

		    IF ( NOT .STATUS)
		    THEN
			BEGIN
			UPDATE_DONE = 1;
			ANOTHER_PASS = 1;
			END;

		    END;

		IF ( NOT .UPDATE_DONE)
		THEN
		    BEGIN
		    EDT$$G_CS_LNO = .EDT$$G_CS_LNO + 1;

		    IF (.EDT$$G_CS_LNO EQL .EDT$$G_SCR_LNS)
		    THEN
			UPDATE_DONE = 1
		    ELSE
			BEGIN

			IF (.SCRPTR [SCR_NXT_LINE] EQLA 0)
			THEN
			    BEGIN
!+
! We have run out of screen data base, but we have not yet filled the screen.  If we
! are at [EOB] that is OK, otherwise extend the screen data base.
!-

			    IF (.SCRPTR EQLA .EDT$$A_EOB_SCRPTR)
			    THEN
				BEGIN
!+
! We have reached [EOB] before filling the screen.  This will be fixed by scrolling later,
! if that is possible.  Erase the rest of the screen unless the whole screen has been
! erased already.
!-

				IF (.EDT$$G_CS_LNO LSS .EDT$$G_BOT_LINE) THEN EDT$$SC_ERAALL ();

				UPDATE_DONE = 1
				END
			    ELSE
				BEGIN
!+
! We are not at [EOB].  Add another record to the screen data base, and keep
! painting the screen.
!-
				REC_NO = .REC_NO + 1;
				ASSERT (EDT$$SC_MOVTOLN (.REC_NO));
				LNINS_VAL = EDT$$SC_LNINS (0, EDT$$A_WK_LN [LIN_TEXT],
				    .EDT$$A_WK_LN [LIN_LENGTH]);

				IF (.LNINS_VAL EQL 0)
				THEN
				    UPDATE_DONE = 1
				ELSE
				    BEGIN
				    SCRPTR = .SCRPTR;
				    ASSERT (.SCRPTR [SCR_NXT_LINE] NEQA 0);
				    SCRPTR = .SCRPTR [SCR_NXT_LINE];
				    ASSERT (.SCRPTR [SCR_LINE_IDX] EQL 0);
				    SCRPTR [SCR_EDIT_FLAGS] = SCR_EDIT_MODIFY;
				    END;

				END;

			    END
			ELSE
			    BEGIN

			    LOCAL
				NEXT_SCRPTR : REF SCREEN_LINE;

			    NEXT_SCRPTR = .SCRPTR [SCR_NXT_LINE];

			    IF (.NEXT_SCRPTR NEQA 0)
			    THEN
				BEGIN

				IF (((.SCRPTR [SCR_EDIT_FLAGS] AND SCR_EDIT_DELLN) EQL 0) AND 	!
				    ((.NEXT_SCRPTR [SCR_LINE_IDX] EQL 0) OR 	!
				    ((.NEXT_SCRPTR [SCR_EDIT_FLAGS] AND SCR_EDIT_DELLN) NEQ 0)))
				THEN
				    REC_NO = .REC_NO + 1;

				END;

			    SCRPTR = .SCRPTR [SCR_NXT_LINE];
			    END;

			END;

		    END;

		END
	    UNTIL .UPDATE_DONE;

!+
! If we have just been looking for inserts and deletes we must make another pass over the screen data base.
!-

	    IF ( NOT .INS_DEL_DONE) THEN ANOTHER_PASS = 1;

!+
! If there were no inserts or deletes on this pass then the next pass can look for modified lines.
!-

	    IF ( NOT .ANY_INS_DEL)
	    THEN
		BEGIN
		INS_DEL_DONE = 1;
!+
! Make sure the scrolling region is normal for the final update pass.
!-
		EDT$$SC_SETSCLLREG (0, .EDT$$G_SCR_LNS);
		END;

	    END
	UNTIL ( NOT .ANOTHER_PASS);

	EDT$$G_BOT_LINE = .EDT$$G_CS_LNO;
	OLD_BOT_RECNO = .REC_NO;
	EDT$$A_BOT_SCRPTR = .SCRPTR;
!+
! The screen is no longer erased.
! Painting subsequent lines must blank out the end of a completely painted line,
! except in special cases such as scrolling a line onto the screen.
!-
	ERASE_ALL = 0;
	END;

    IF .BUILD_SCR
    THEN
	BEGIN
!+
! We must rebuild the screen data base.  Put all the screen line
! blocks on the free list.
!-

	IF (.EDT$$A_FST_SCRPTR NEQA 0)
	THEN
	    BEGIN
	    EDT$$A_LST_SCRPTR [SCR_NXT_LINE] = .EDT$$A_FST_AVLN;
	    EDT$$A_FST_AVLN = .EDT$$A_FST_SCRPTR;
	    END;

	EDT$$A_FST_SCRPTR = 0;
	EDT$$A_LST_SCRPTR = 0;
	EDT$$A_TOP_SCRPTR = 0;
	EDT$$A_CUR_SCRPTR = 0;
	EDT$$A_BOT_SCRPTR = 0;
	EDT$$A_EOB_SCRPTR = 0;
	EDT$$G_MEM_CNT = 0;
	END;

!+
! Align the cursor screen pointer with the current screen pointer.
!-
    REC_NO = 0;
    ASSERT (EDT$$SC_MOVTOLN (.REC_NO));
    EDT$$A_SCR_BUF = .EDT$$A_CUR_BUF;
    MOVELINE (EDT$$A_CUR_BUF [TBCB_CUR_LIN], EDT$$L_CUR_SCRLN);

    IF .BUILD_SCR
    THEN
	BEGIN
	EDT$$SC_LNINS (0, EDT$$A_WK_LN [LIN_TEXT], .EDT$$A_WK_LN [LIN_LENGTH]);
	EDT$$A_CSR_SCRPTR = .EDT$$A_FST_SCRPTR;

	IF (.EDT$$G_TRUN EQL 0)			!
	THEN
	    EDT$$A_CUR_SCRPTR = EDT$$SC_FNDREC (.EDT$$G_CS_CHNO, DISP)
	ELSE
	    EDT$$A_CUR_SCRPTR = .EDT$$A_CSR_SCRPTR;

	END;

!+
! When we reach this point either the old screen has been updated, if necessary,
! or we will be rebuilding the screen data base.
! Determine which line should be at the top of the screen
!-

    IF (.SCROLLING_NEEDED OR .BUILD_SCR)
    THEN
	BEGIN

	LOCAL
	    AT_BOTTOM;

	SCRPTR = .EDT$$A_CUR_SCRPTR;
	REC_NO = 0;
	BELOW = 0;
	ABOVE = 0;
!+
! Calculate the number of lines above and below the current line
! because we might have to move the cursor.  This may cause the screen
! data structure to be extended.
!-
	AT_BOTTOM = 0;

	WHILE ((.BELOW LSS (.EDT$$G_SCR_LNS*2)) AND ( NOT .AT_BOTTOM)) DO
	    BEGIN

	    IF (.SCRPTR EQLA 0)
	    THEN
		BEGIN
		ASSERT (EDT$$SC_MOVTOLN (.REC_NO));
		LNINS_VAL = EDT$$SC_LNINS (0, EDT$$A_WK_LN [LIN_TEXT], .EDT$$A_WK_LN [LIN_LENGTH]);

		IF (.LNINS_VAL EQL 0)
		THEN
		    AT_BOTTOM = 1
		ELSE
		    BEGIN
		    BELOW = .BELOW + .LNINS_VAL;
		    REC_NO = .REC_NO + 1;

		    IF (.EDT$$A_WK_LN EQLA EDT$$Z_EOB_LN)
		    THEN
			BEGIN
			EDT$$A_EOB_SCRPTR = .EDT$$A_LST_SCRPTR;
			AT_BOTTOM = 1;
			END;

		    END;

		END
	    ELSE
		BEGIN
		BELOW = .BELOW + 1;

		IF (.SCRPTR EQLA .EDT$$A_EOB_SCRPTR)
		THEN
		    AT_BOTTOM = 1
		ELSE
		    BEGIN
		    SCRPTR = .SCRPTR [SCR_NXT_LINE];

		    IF (.SCRPTR EQLA 0)
		    THEN
			REC_NO = .REC_NO + 1
		    ELSE

			IF (.SCRPTR [SCR_LINE_IDX] EQL 0) THEN REC_NO = .REC_NO + 1;

		    END;

		END;

	    END;

!+
! Now see how many lines are available above the current line.
!-
	SCRPTR = .EDT$$A_CUR_SCRPTR;
	REC_NO = 0;
	BEGIN

	LOCAL
	    AT_TOP;

	AT_TOP = 0;

	WHILE ((.ABOVE LSS (.EDT$$G_SCR_LNS*2)) AND ( NOT .AT_TOP)) DO
	    BEGIN

	    IF (.SCRPTR NEQA 0)
	    THEN
		BEGIN

		IF (.SCRPTR [SCR_LINE_IDX] EQL 0) THEN REC_NO = .REC_NO - 1;

		SCRPTR = .SCRPTR [SCR_PRV_LINE];
		END;

!+
! If the screen data structure ends, try to add new items to the front of it.
!-

	    IF (.SCRPTR EQLA 0)
	    THEN
		BEGIN

		IF EDT$$SC_MOVTOLN (.REC_NO)
		THEN
		    BEGIN
		    LNINS_VAL = EDT$$SC_LNINS (.EDT$$A_FST_SCRPTR, EDT$$A_WK_LN [LIN_TEXT],
			.EDT$$A_WK_LN [LIN_LENGTH]);

		    IF (.LNINS_VAL EQL 0)
		    THEN
			AT_TOP = 1
		    ELSE
			BEGIN
			ABOVE = .ABOVE + .LNINS_VAL;
			SCRPTR = .EDT$$A_FST_SCRPTR;
			END;

		    END
		ELSE
		    AT_TOP = 1;

		END
	    ELSE
		ABOVE = .ABOVE + 1;

	    END;

	END;
	SCRPTR = .EDT$$A_CUR_SCRPTR;
!+
! Now compute the top line.  If there is an enforced top line, we try to use it.
! If there is not, we try to use the old top line.  Otherwise we go up a number of
! lines depending on the direction of the last move, to preserve as much context
! as possible.
!-
	TOP_SET = 0;

	IF ( NOT LINNOEQL (EDT$$L_TOP_LN, EDT$$L_LNO_EMPTY))
	THEN
	    BEGIN
!+
! There is a request for a top line.  If it is below the current line, reject it.
!-

	    IF (CMPLNO (EDT$$L_TOP_LN, EDT$$L_CS_LN) GTR 0)
	    THEN
		MOVELINE (EDT$$L_LNO_EMPTY, EDT$$L_TOP_LN)
	    ELSE
		BEGIN
!+
! The requested top line is above or on the current line.  If it is too far above, reject it.
!-
		TOP_DIST = 0;
		SCRPTR = .EDT$$A_CUR_SCRPTR;
		MOVELINE (EDT$$L_CS_LN, TEMP_LINE);

		WHILE (( NOT LINNOEQL (TEMP_LINE, EDT$$L_TOP_LN)) AND 	!
		    (.TOP_DIST LSS .EDT$$G_SCLL_BOT) AND 	!
		    (.SCRPTR NEQA 0)) DO
		    BEGIN

		    IF (.SCRPTR [SCR_LINE_IDX] EQL 0) THEN SUBLINE (NUMBER_ONE, TEMP_LINE);

		    SCRPTR = .SCRPTR [SCR_PRV_LINE];

		    IF (.SCRPTR NEQA 0) THEN TOP_DIST = .TOP_DIST + 1;

		    END;

!+
! If we found the line and it would not require [EOB] to be above the bottom
! of the screen, accept it.
!-

		IF (LINNOEQL (TEMP_LINE, EDT$$L_TOP_LN) AND ((.BELOW + .TOP_DIST) GEQ .EDT$$G_SCR_LNS))
		THEN
		    TOP_SET = 1
		ELSE
		    MOVELINE (EDT$$L_LNO_EMPTY, EDT$$L_TOP_LN);

		END;

	    END;

!+
! If we have no top determined yet, try to use the old top.
!-

	IF (( NOT .TOP_SET) AND (.EDT$$A_TOP_SCRPTR NEQA 0))
	THEN
	    BEGIN
	    SCRPTR = .EDT$$A_CUR_SCRPTR;
	    REC_NO = 0;
	    TOP_DIST = 0;

	    WHILE ((.TOP_DIST LEQ .EDT$$G_SCLL_BOT) AND 	!
		(.SCRPTR NEQA .EDT$$A_TOP_SCRPTR) AND 	!
		(.SCRPTR NEQA 0)) DO
		BEGIN

		IF (.SCRPTR [SCR_LINE_IDX] EQL 0) THEN REC_NO = .REC_NO - 1;

		SCRPTR = .SCRPTR [SCR_PRV_LINE];

		IF (.SCRPTR NEQA 0) THEN TOP_DIST = .TOP_DIST + 1;

		END;

!+
! If we found the old top line and it will leave the cursor line in range
! and not put the [EOB] above the bottom of the screen, use it.
!-

	    IF ((.TOP_DIST LEQ .EDT$$G_SCLL_BOT) AND 	!
		(.TOP_DIST GEQ .EDT$$G_SCLL_TOP) AND 	!
		((.BELOW + .TOP_DIST) GEQ .EDT$$G_SCR_LNS) AND 	!
		(.SCRPTR EQLA .EDT$$A_TOP_SCRPTR))
	    THEN
		TOP_SET = 1;

	    END;

!+
! If top is still not set and there is a record of a previous cursor line
! and we are rebuilding the screen data base, try to compute the top line
! such that the cursor stays where it was.  This is useful in case the code
! for fixing notruncated lines must force a rebuild of the screen data base.
! Try to keep the cursor in proper boundries.
!-

	IF (( NOT .TOP_SET) AND .EDT$$G_SCR_REBUILD)
	THEN
	    BEGIN

	    LOCAL
		TARGET_LINE;

	    TARGET_LINE = MAX (MIN (.CURSOR_LINE, .EDT$$G_SCLL_BOT), .EDT$$G_SCLL_TOP);
	    SCRPTR = .EDT$$A_CUR_SCRPTR;
	    TOP_DIST = -1;

	    WHILE ((.SCRPTR NEQA 0) AND (.TOP_DIST NEQ .TARGET_LINE)) DO
		BEGIN
		SCRPTR = .SCRPTR [SCR_PRV_LINE];
		TOP_DIST = .TOP_DIST + 1;
		END;

	    IF ((.TOP_DIST EQL .TARGET_LINE) AND ((.BELOW + .TARGET_LINE) GEQ .EDT$$G_SCR_LNS))
	    THEN
		TOP_SET = 1;

	    END;

!+
! If top is still not set, try to find a new top line a suitable distance
! above the current line.
!-

	IF ( NOT .TOP_SET)
	THEN
	    BEGIN

	    LOCAL
		TARGET_LINE;

!+
! Work back until the beginning of the screen data structure or until TOP_DIST is
! big enough for the direction we are moving.
! The (.CURSOR_LINE + .EDT$$G_RECS_INSERTED) code is here to fix a problem on VT52's
! with the screen scrolling too far up on a paste.
!-

	    IF ((.DIR GEQ 0) OR (((.CURSOR_LINE + .EDT$$G_RECS_INSERTED) GTR .EDT$$G_SCLL_BOT)	!
		AND (.EDT$$G_RECS_INSERTED GTR 0)))
	    THEN
		TARGET_LINE = .EDT$$G_SCLL_BOT
	    ELSE
		TARGET_LINE = .EDT$$G_SCLL_TOP;

!+
! If necessary, work back further to avoid lifting the [EOB] above the last line
! of the screen.
!-
	    TARGET_LINE = MAX (.TARGET_LINE, .EDT$$G_SCR_LNS - .BELOW);
!
	    REC_NO = 0;
	    SCRPTR = .EDT$$A_CUR_SCRPTR;
	    TOP_DIST = -1;

	    WHILE ((.SCRPTR NEQA 0) AND (.TOP_DIST NEQ .TARGET_LINE)) DO
		BEGIN
		SCRPTR = .SCRPTR [SCR_PRV_LINE];
		TOP_DIST = .TOP_DIST + 1;
		END;

!+
! If we found the line we were looking for, accept it.
!-

	    IF (.TOP_DIST EQL .TARGET_LINE) THEN TOP_SET = 1;

	    END;

!+
! If no line is suitable, use the first line in the screen data base.  This can happen when we
! have a buffer that fits on the screen.
!-

	IF ( NOT .TOP_SET)
	THEN
	    BEGIN
	    TOP_DIST = -1;
	    SCRPTR = .EDT$$A_CUR_SCRPTR;

	    WHILE (.SCRPTR NEQA 0) DO
		BEGIN
		TOP_DIST = .TOP_DIST + 1;
		SCRPTR = .SCRPTR [SCR_PRV_LINE];
		END;

	    END;

!+
! Now that TOP_DIST is computed, find the new top screen pointer.
!-
	SCRPTR = .EDT$$A_CUR_SCRPTR;
	REC_NO = 0;

	INCR I FROM 1 TO .TOP_DIST DO
	    BEGIN

	    IF (.SCRPTR [SCR_LINE_IDX] EQL 0) THEN REC_NO = .REC_NO - 1;

	    SCRPTR = .SCRPTR [SCR_PRV_LINE];
	    END;

	TOP_RECNO = .REC_NO;
	TOP_SCRPTR = .SCRPTR;
!+
! Compute the number of lines between the old and new top lines,
! so we can see how far to scroll, and in which direction.
!-

	IF ((.EDT$$A_TOP_SCRPTR NEQA .TOP_SCRPTR) AND (.EDT$$A_TOP_SCRPTR NEQA 0))
	THEN
	    BEGIN

	    LOCAL
		SEEN_OLD,
		SEEN_NEW;

	    SEEN_OLD = 0;
	    SEEN_NEW = 0;
	    SCLL_NUM = 0;
	    SCRPTR = .EDT$$A_FST_SCRPTR;

	    WHILE ((.SCRPTR NEQA 0) AND ( NOT (.SEEN_OLD AND .SEEN_NEW))) DO
		BEGIN

		IF (.SEEN_OLD AND ( NOT .SEEN_NEW)) THEN SCLL_NUM = .SCLL_NUM + 1;

		IF (.SEEN_NEW AND ( NOT .SEEN_OLD)) THEN SCLL_NUM = .SCLL_NUM - 1;

		IF (.SCRPTR EQLA .TOP_SCRPTR) THEN SEEN_NEW = 1;

		IF (.SCRPTR EQLA .EDT$$A_TOP_SCRPTR) THEN SEEN_OLD = 1;

		SCRPTR = .SCRPTR [SCR_NXT_LINE];
		END;

	    ASSERT (.SEEN_NEW);
!+
! If the old top line is not in the data base, it must be too far away
! to scroll.
!-

	    IF ( NOT .SEEN_OLD) THEN SCLL_NUM = 0;

!+
! If the amount to scroll is too large, don't do any scrolling.
!-

	    IF (ABS (.SCLL_NUM) GEQ .EDT$$G_SCR_LNS) THEN SCLL_NUM = 0;

!+
! The sign of SCLL_NUM says which way to scroll, and the magnitude says
! how much.  First position to the bottom or top of the old screen,
! depending on which way we are scrolling.
!-

	    WHILE (.SCLL_NUM NEQ 0) DO
		BEGIN

		IF (.SCLL_NUM GTR 0)
		THEN
		    BEGIN
!+
! The cursor is moving down, so scroll the screen up.
!-
		    SCRPTR = .EDT$$A_BOT_SCRPTR;
		    REC_NO = .OLD_BOT_RECNO;
		    SCRPTR = .SCRPTR [SCR_NXT_LINE];

		    IF (.SCRPTR [SCR_LINE_IDX] EQL 0) THEN REC_NO = .REC_NO + 1;

		    OLD_BOT_RECNO = .REC_NO;

		    IF .EDT$$G_TI_SCROLL
		    THEN
			BEGIN
			EDT$$SC_POSCSIF (.EDT$$G_SCR_LNS - 1, 0);
			EDT$$FMT_LIT (UPLIT (BYTE (ASC_K_LF)), 1);
			END
		    ELSE
			BEGIN
			EDT$$SC_POSCSIF (.EDT$$G_MESSAGE_LINE + 1, 0);
			EDT$$FMT_LIT (UPLIT (BYTE (ASC_K_LF)), 1);
			EDT$$SC_POSCSIF (.EDT$$G_SCR_LNS - 1, 0);
			END;

!+
! If this is a non-scrolling-region terminal, text may have moved down into the message
! region or a message may have moved up one line.  Erase the message region.
!-

		    IF ( NOT .EDT$$G_TI_SCROLL)
		    THEN
			BEGIN
			EDT$$G_MSGFLG = 0;	! Any message is lost
			EDT$$G_CS_LNO = .EDT$$G_SCR_LNS;
			EDT$$SC_ERAALL ();
			END;

		    EDT$$G_CS_LNO = .EDT$$G_SCR_LNS - 1;
		    ASSERT (EDT$$SC_MOVTOLN (.REC_NO));
		    EDT$$SC_RFRELN (.SCRPTR, .EDT$$G_TI_SCROLL);
		    EDT$$A_TOP_SCRPTR = .EDT$$A_TOP_SCRPTR [SCR_NXT_LINE];
		    EDT$$A_BOT_SCRPTR = .SCRPTR;
		    SCLL_NUM = .SCLL_NUM - 1;
		    END
		ELSE
		    BEGIN
!+
! The cursor is moving up, so scroll the screen down.
!-
		    SCRPTR = .EDT$$A_TOP_SCRPTR;
		    REC_NO = .OLD_TOP_RECNO;

		    IF (.SCRPTR [SCR_LINE_IDX] EQL 0) THEN REC_NO = .REC_NO - 1;

		    OLD_TOP_RECNO = .REC_NO;
		    SCRPTR = .SCRPTR [SCR_PRV_LINE];
		    EDT$$SC_POSCSIF (0, 0);

		    IF (.EDT$$G_TI_TYP EQL TERM_VT52)	!
		    THEN
			EDT$$FMT_LIT (UPLIT (BYTE (ASC_K_ESC, %C'I')), 2)
		    ELSE
			EDT$$FMT_LIT (UPLIT (BYTE (ASC_K_ESC, %C'M')), 2);

!+
! If this is a non-scrolling-region terminal, text may have moved down into the message
! region or a message may have moved up one line.  Erase the message region.  It is important
! to erase the message region before painting the new line at the top of the screen.  Because
! of what appears to be a problem within the VT52, if EDT paints the new line first and then
! erases the message area, some of the leading characters will sometimes be lost from the
! newly painted line.  To demonstrate the problem, SET LINES 10 and edit a file of 22 80-character
! lines on a VT52.  Go to the bottom of the buffer and type GOLD 8 up arrow.  A more extreme
! case is to SET LINES 5 and type GOLD 4 up arrow.
!-

		    IF ( NOT .EDT$$G_TI_SCROLL)
		    THEN
			BEGIN
			EDT$$G_MSGFLG = 0;	! Any message is lost
			EDT$$G_CS_LNO = .EDT$$G_SCR_LNS;
			EDT$$SC_ERAALL ();
			END;

		    EDT$$G_CS_LNO = 0;
		    ASSERT (EDT$$SC_MOVTOLN (.REC_NO));
		    EDT$$SC_RFRELN (.SCRPTR, 1);
		    EDT$$A_TOP_SCRPTR = .SCRPTR;
		    EDT$$A_BOT_SCRPTR = .EDT$$A_BOT_SCRPTR [SCR_PRV_LINE];
		    SCLL_NUM = .SCLL_NUM + 1;
		    END;

		END;

	    END;

	END					! of .SCROLLING_NEEDED OR .BUILD_SCR
    ELSE
	BEGIN
	TOP_SCRPTR = .EDT$$A_TOP_SCRPTR;
	TOP_RECNO = .EDT$$G_TOP_RECNO;
	END;

!+
! Make a final update pass over the screen.  This will be needed if
! no scrolling took place due to the new screen being too far from
! the old screen, or if we erased the screen, or if we are rebuilding
! the screen data base from scratch.  If scrolling was needed then
! this pass is necessary to recompute CURSOR_LINE, even if no updates
! need to be made.
!-

    IF (.SCROLLING_NEEDED OR .ERASE_ALL OR .BUILD_SCR)
    THEN
	BEGIN
	REC_NO = .TOP_RECNO;
	SCRPTR = .TOP_SCRPTR;
	CURSOR_LINE = -1;
	EDT$$G_CS_LNO = 0;

	WHILE ((.EDT$$G_CS_LNO LSS .EDT$$G_SCR_LNS) AND (.SCRPTR NEQA 0)) DO
	    BEGIN

	    IF ((.SCRPTR [SCR_EDIT_FLAGS] AND (SCR_EDIT_MODIFY OR SCR_EDIT_INSLN OR SCR_EDIT_DELLN)) NEQ 0)
	    THEN
		BEGIN
		ASSERT (EDT$$SC_MOVTOLN (.REC_NO));
		EDT$$SC_RFRELN (.SCRPTR, .ERASE_ALL);
		END;

	    EDT$$A_BOT_SCRPTR = .SCRPTR;

	    IF (.SCRPTR EQLA .EDT$$A_CUR_SCRPTR) THEN CURSOR_LINE = .EDT$$G_CS_LNO;

	    SCRPTR = .SCRPTR [SCR_NXT_LINE];
	    EDT$$G_CS_LNO = .EDT$$G_CS_LNO + 1;

	    IF (.SCRPTR NEQA 0)
	    THEN
		BEGIN

		IF (.SCRPTR [SCR_LINE_IDX] EQL 0) THEN REC_NO = .REC_NO + 1;

		END;

	    END;

!+
! Be sure that we leave the screen updater positioned on the current record.
!-
	REC_NO = 0;
	ASSERT (EDT$$SC_MOVTOLN (.REC_NO));
!+
! If there is more room on the screen, erase it if necessary.
!-

	IF (.EDT$$G_CS_LNO LSS .EDT$$G_BOT_LINE) THEN EDT$$SC_ERAALL ();

	EDT$$G_BOT_LINE = .EDT$$G_CS_LNO;
	END;

!+
! Do the clean-up on the screen data pointers.
!-
    EDT$$G_TOP_RECNO = .TOP_RECNO;
    EDT$$A_TOP_SCRPTR = .TOP_SCRPTR;
    EDT$$G_SCR_REBUILD = 0;
    EDT$$G_ANY_CHANGES = 0;
    EDT$$A_CSR_SCRPTR = .EDT$$A_CUR_SCRPTR;
    EDT$$G_RECS_INSERTED = 0;
    EDT$$A_OLD_SEL = .EDT$$A_SEL_BUF;
    EDT$$G_CS_OLDCHNO = .EDT$$G_CS_CHNO;
    EDT$$SC_POSCSIF (.CURSOR_LINE, .CURSOR_POS);
    EDT$$G_CUR_COL = .CURSOR_POS;
    EDT$$G_CS_LNO = .CURSOR_LINE;
    EDT$$TI_ENBLAUTREP (1);
    EDT$$OUT_FMTBUF ();
    EDT$$A_LN_PTR = .EDT$$G_CS_CHNO + EDT$$T_LN_BUF;
    END;					! of routine EDT$$SC_UPD


%SBTTL 'DELETE_LINE - delete a line on the screen'
ROUTINE DELETE_LINE (				! Delete a line on the screen
    SCRPTR, 					! The line to delete
    OLD_TOP_RECNO				! Record number of the top line
    ) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Delete one screen line.
!
! FORMAL PARAMETERS:
!
!  SCRPTR		The screen data block to delete
!
!  OLD_TOP_RECNO	Record number of the top line
!
! IMPLICIT INPUTS:
!
!	EDT$$G_FST_SCRPTR
! 	EDT$$G_LST_SCRPTR
!	EDT$$G_TI_SCROLL
!	EDT$$A_TOP_SCRPTR
!	EDT$$G_SCR_LNS
!	EDT$$G_SCLL_TOP
!	EDT$$G_SCLL_BOT
!	EDT$$G_BOT_SCRPTR
!	EDT$$G_CS_LNO
!	EDT$$A_LST_SCRPTR
!	EDT$$G_BOT_LINE
!
! IMPLICIT OUTPUTS:
!
!	EDT$$A_TOP_SCRPTR
!	EDT$$A_BOT_SCRPTR
!	EDT$$G_BOT_LINE
!	EDT$$G_MSGFLG
!
! ROUTINE VALUE:
!
!	0 = must start update over
!
! SIDE EFFECTS:
!
!	Will store into the format buffer
!
!--

    BEGIN

    MAP
	SCRPTR : REF SCREEN_LINE;

    EXTERNAL ROUTINE
	EDT$$SC_ERAALL,				! Erase to end of screen
	EDT$$SC_MOVTOLN,		! Move to a record in the work file relative to the current record
	EDT$$SC_RFRELN : NOVALUE,		! Refresh a screen line
	EDT$$SC_LNDEL,				! Delete a line from data structure
	EDT$$SC_SETSCLLREG,			! Set scrolling region
	EDT$$FMT_LIT,				! Format a literal for output
	EDT$$SC_POSCSIF : NOVALUE,		! Position the cursor
	EDT$$SC_REPAINT : NOVALUE;		! Mark some lines in the screen data base for repaint

    EXTERNAL
	EDT$$G_MSGFLG,				! Is a message on the screen
	EDT$$G_MESSAGE_LINE,			! Line number for prompts
	EDT$$G_TI_TYP,				! Terminal type
	EDT$$G_TI_EDIT,				! VT102 editing features
	EDT$$G_SCR_LNS,				! Number of lines on screen
	EDT$$G_SCLL_TOP,			! Top line the cursor is allowed to be on
	EDT$$G_SCLL_BOT,			! Bottom line the cursor is allowed to be on
	EDT$$A_FST_SCRPTR : REF SCREEN_LINE,	! First data structure pointer
	EDT$$A_BOT_SCRPTR : REF SCREEN_LINE,	! Bottom screen pointer
	EDT$$A_LST_SCRPTR : REF SCREEN_LINE,	! Last data structure pointer
	EDT$$A_TOP_SCRPTR : REF SCREEN_LINE,	! Top screen line info address
	EDT$$A_EOB_SCRPTR : REF SCREEN_LINE,	! EOB screen pointer
	EDT$$G_CS_LNO,				! current cursor line
	EDT$$G_TI_SCROLL,			! 1 = we have scrolling regions
	EDT$$G_BOT_LINE;			! All lines below this one have been erased

    LOCAL
	PRV_SCRPTR : REF SCREEN_LINE,		! Previous screen pointer
	NXT_SCRPTR : REF SCREEN_LINE,		! Next screen pointer
	TOP_SCRPTR : REF SCREEN_LINE,		! Top screen pointer (at entry)
	SCLL_CENTER;				! Number of center screen line

    PRV_SCRPTR = .SCRPTR [SCR_PRV_LINE];
    NXT_SCRPTR = .SCRPTR [SCR_NXT_LINE];
    TOP_SCRPTR = .EDT$$A_TOP_SCRPTR;
    SCLL_CENTER = (.EDT$$G_SCLL_TOP + .EDT$$G_SCLL_BOT)/2;
!+
! If we are deleting the top line, make the following line the top line
! unless there are lines preceding it that have been modified or inserted,
! in which case we will paint over the deleted line instead of scrolling.
!-

    IF (.SCRPTR EQLA .TOP_SCRPTR)
    THEN
	BEGIN

	IF (.PRV_SCRPTR NEQA 0)
	THEN
!+
! Test for insertion or modification of previous lines.
!-

	    IF ((.PRV_SCRPTR [SCR_EDIT_FLAGS] AND (SCR_EDIT_INSLN OR SCR_EDIT_MODIFY)) NEQ 0)
	    THEN
		BEGIN
!+
! Delete the current line and backup to the previous line for a
! repaint.  The top screen pointer and record number offsets
! must also be updated.  No further processing is needed on this pass.
! The new top line will be repainted on the next pass.
!-

		IF (.SCRPTR [SCR_LINE_IDX] EQL 0) THEN .OLD_TOP_RECNO = ..OLD_TOP_RECNO - 1;

		EDT$$SC_LNDEL (.SCRPTR);
		EDT$$A_TOP_SCRPTR = .PRV_SCRPTR;
		RETURN (0);
		END;

!+
! The previous line is non-existent or has not been modified.  Handle this in the usual way.
!-
	END;

    IF (((.EDT$$A_EOB_SCRPTR EQLA .EDT$$A_BOT_SCRPTR) OR (.EDT$$G_CS_LNO LEQ .SCLL_CENTER))	!
	AND (.TOP_SCRPTR [SCR_PRV_LINE] NEQA 0))
    THEN
	BEGIN
!+
! The buffer is long enough that there is a line before the top line that appears on the screen,
! and either the [EOB] appears on the screen or the line being deleted is above the center of
! the screen.  We will be scrolling down, bringing a new line onto the top screen line.
! Move the top screen pointer up one line.  This must be done before deleting
! the current line in case the top line is the current line.
!-
	EDT$$A_TOP_SCRPTR = .TOP_SCRPTR [SCR_PRV_LINE];
!+
! Adjust the record number of the top line.
!-

	IF (.TOP_SCRPTR [SCR_LINE_IDX] EQL 0) THEN .OLD_TOP_RECNO = ..OLD_TOP_RECNO - 1;

	IF .EDT$$G_TI_SCROLL
	THEN
	    BEGIN

	    LOCAL
		TMP_SCRPTR : REF SCREEN_LINE,
		SCLL_LINE;

!+
! Use the scrolling region or DL command to avoid having to repaint part of the screen.
!-
	    SCLL_LINE = .EDT$$G_CS_LNO;
	    TMP_SCRPTR = .SCRPTR;
!+
! To speed up deletes, the scrolling line will be the last line
! for which we will scroll down.
!-

	    DO
		BEGIN
		SCLL_LINE = .SCLL_LINE + 1;
		TMP_SCRPTR = .TMP_SCRPTR [SCR_NXT_LINE];
		END
	    UNTIL (((.TMP_SCRPTR [SCR_EDIT_FLAGS] AND SCR_EDIT_DELLN) EQL 0) OR 	!
		((.SCLL_LINE GTR .SCLL_CENTER) AND (.EDT$$A_EOB_SCRPTR NEQA .EDT$$A_BOT_SCRPTR)));

!+
! Scroll down
!-
	    EDT$$SC_SETSCLLREG (0, .SCLL_LINE);
	    EDT$$SC_POSCSIF (0, 0);
	    EDT$$FMT_LIT (UPLIT (BYTE (ASC_K_ESC, %C'M')), 2);
	    EDT$$SC_LNDEL (.SCRPTR);
	    END
	ELSE
	    BEGIN
!+
! We do not have scrolling regions.  If the line to be deleted is high
! on the screen then repaint from the top line to the current line.  If
! the line to be deleted is low on the screen, scroll the screen down
! and repaint the lines below this one.
!-

	    IF (.EDT$$G_CS_LNO LEQ (.EDT$$G_BOT_LINE/2))
	    THEN
		BEGIN
!+
! We have a high line, so we will repaint the top of the screen.
! Ignore deleted lines right after this one, since there could be enough to
! make us decide to also repaint the bottom half of the screen.
!-
		EDT$$SC_LNDEL (.SCRPTR);

		IF ((.SCRPTR NEQA .EDT$$A_BOT_SCRPTR) AND 	!
		    ((.NXT_SCRPTR [SCR_EDIT_FLAGS] AND SCR_EDIT_DELLN) NEQ 0))
		THEN
		    DELETE_LINE (.NXT_SCRPTR, .OLD_TOP_RECNO);

		IF (.PRV_SCRPTR NEQA 0) THEN EDT$$SC_REPAINT (.EDT$$A_TOP_SCRPTR, .PRV_SCRPTR, 0, 255, 0);

		END
	    ELSE
		BEGIN
!+
! We have a low line.  Scroll the whole screen down and repaint the lines below the deleted line.
!-
		EDT$$SC_POSCSIF (0, 0);

		IF (.EDT$$G_TI_TYP EQL TERM_VT52)	!
		THEN
		    EDT$$FMT_LIT (UPLIT (BYTE (ASC_K_ESC, %C'I')), 2)
		ELSE
		    EDT$$FMT_LIT (UPLIT (BYTE (ASC_K_ESC, %C'M')), 2);

!+
! Make sure the message area is blank, since we may have moved text into the message area.
!-
		BEGIN

		LOCAL
		    SAV_CS_LN;

		EDT$$G_MSGFLG = 0;
		SAV_CS_LN = .EDT$$G_CS_LNO;
		EDT$$G_CS_LNO = .EDT$$G_SCR_LNS;
		EDT$$SC_ERAALL ();
		EDT$$G_CS_LNO = .SAV_CS_LN;
		END;
!+
! Now mark the bottom of the screen to be repainted.
!-
		EDT$$SC_REPAINT (.SCRPTR, .EDT$$A_LST_SCRPTR, 0, 255, 1);
		END;

	    END;

	END
    ELSE
	BEGIN
!+
! Either there is no line before the current top line or the cursor is below the
! center of the screen.  Scroll up, which will bring a new line onto the
! bottom line of the screen, unless the [EOB] is already on the screen.
! If we are deleting the top line, make the next line the top line.  We don't need to
! worry about the top line record number since deleted lines have the record number
! of the next following non-deleted line.
!-

	IF (.SCRPTR EQLA .TOP_SCRPTR) THEN EDT$$A_TOP_SCRPTR = .NXT_SCRPTR;

	IF ((.EDT$$G_TI_SCROLL) AND (.EDT$$G_CS_LNO LSS (.EDT$$G_SCR_LNS - 1)))
	THEN
	    BEGIN
!+
! Set the scrolling region so we can update the screen without repainting text
! that has moved up.
!-

	    IF (.EDT$$G_TI_EDIT)
	    THEN
!+
! Use VT102 edit feature
!-
		BEGIN
		EDT$$SC_SETSCLLREG (0, .EDT$$G_SCR_LNS);
		EDT$$SC_POSCSIF (.EDT$$G_CS_LNO, 0);
		EDT$$FMT_LIT (UPLIT (%STRING (%CHAR (ASC_K_ESC), '[M')), 3);
		END
	    ELSE
		BEGIN
!+
! Simulate edit feature.
!-
		EDT$$SC_SETSCLLREG (.EDT$$G_CS_LNO, .EDT$$G_SCR_LNS);
		EDT$$SC_POSCSIF (.EDT$$G_SCR_LNS - 1, 0);
		EDT$$FMT_LIT (UPLIT (%CHAR (ASC_K_LF)), 1);
		END;

!+
! Free the deleted line.
!-
	    EDT$$SC_LNDEL (.SCRPTR);
	    END
	ELSE
	    BEGIN
!+
! If we cannot use the scrolling region, repaint the screen from the point
! of the deletion to the bottom.  If we're deleting a high line, then
! scroll up instead of repainting the whole bottom.
!-

	    IF (.EDT$$G_CS_LNO LEQ (.EDT$$G_BOT_LINE/2))
	    THEN
		BEGIN
!+
! The line being deleted is high on the screen.  Scroll the screen up and repaint
! all of the lines above the deleted line.
!-

		LOCAL
		    SAV_CS_LN;

		EDT$$SC_REPAINT (.TOP_SCRPTR, .SCRPTR, 0, 255, 1);
		SAV_CS_LN = .EDT$$G_CS_LNO;
		EDT$$SC_POSCSIF (.EDT$$G_MESSAGE_LINE + 1, 0);
		EDT$$FMT_LIT (UPLIT (BYTE (ASC_K_LF)), 1);
!+
! If we've done a scroll then the message is no longer on the screen.
!-
		EDT$$G_MSGFLG = 0;
		EDT$$G_BOT_LINE = .EDT$$G_BOT_LINE + 1;
		EDT$$G_CS_LNO = .EDT$$G_SCR_LNS;
		EDT$$SC_ERAALL ();
		EDT$$G_CS_LNO = .SAV_CS_LN;
		END
	    ELSE
		BEGIN
!+
! The line being deleted is low on the screen.  Repaint it and all lines below it.
!-
		EDT$$SC_REPAINT (.SCRPTR, .EDT$$A_LST_SCRPTR, 0, 255, 1);
		END;

	    END;

!+
! Adjust the bottom screen pointer if it is not the EOB.
!-

	IF ((.EDT$$A_BOT_SCRPTR NEQA 0) AND (.EDT$$A_BOT_SCRPTR NEQA .EDT$$A_EOB_SCRPTR))
	THEN
	    EDT$$A_BOT_SCRPTR = .EDT$$A_BOT_SCRPTR [SCR_NXT_LINE];

	END;

!+
! Make another pass over the screen data.
!-
    RETURN (0);
    END;					! of routine DELETE_LINE

%SBTTL 'INSERT_LINE - insert a line on the screen'
ROUTINE INSERT_LINE (				! Insert a line on the screen
    SCRPTR, 					! The line to insert
    REC_NO, 					! It's relative record number
    OLD_TOP_RECNO				! Record number of the top line
    ) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Insert one screen line.  It may be marked inserted or deleted.
!	This routine is not called unless it has some kind of edit.
!
! FORMAL PARAMETERS:
!
!  SCRPTR		The screen data block to insert
!
!  REC_NO		The relative record number of that line
!
!  OLD_TOP_RECNO	Record number of the top line
!
! IMPLICIT INPUTS:
!
!	EDT$$G_TI_SCROLL
!	EDT$$A_TOP_SCRPTR
!	EDT$$G_SCR_LNS
!	EDT$$G_SCLL_BOT
!	EDT$$G_SCLL_TOP
!	EDT$$G_BOT_SCRPTR
!	EDT$$G_CS_LNO
!	EDT$$A_LST_SCRPTR
!	EDT$$G_BOT_LINE
!	EDT$$G_MSGFLG
!	EDT$$G_TI_TYP
!
! IMPLICIT OUTPUTS:
!
!	EDT$$A_TOP_SCRPTR
!	EDT$$A_BOT_SCRPTR
!	EDT$$G_BOT_LINE
!	EDT$$G_MSGFLG
!
! ROUTINE VALUE:
!
!	1 = repaint this line and continue this pass, 0 = must start update over
!
! SIDE EFFECTS:
!
!	Will store into the format buffer
!
!--

    BEGIN

    MAP
	SCRPTR : REF SCREEN_LINE;

    EXTERNAL ROUTINE
	EDT$$SC_LNDEL,				! Free a deleted line
	EDT$$SC_SETSCLLREG,			! Set scrolling region
	EDT$$FMT_LIT,				! Format a literal for output
	EDT$$SC_POSCSIF : NOVALUE,		! Position the cursor
	EDT$$SC_ERATOEOL : NOVALUE,		! Erase to end of line
	EDT$$SC_MOVTOLN,		! Move to a record in the work file relative to the current record
	EDT$$SC_ERAALL : NOVALUE,		! Erase part of the screen
	EDT$$SC_REPAINT : NOVALUE;		! Mark some lines in the screen data base for repaint

    EXTERNAL
	EDT$$G_MESSAGE_LINE,			! Line number for error msgs
	EDT$$G_TI_EDIT,				! VT102 editing features
	EDT$$G_SCR_LNS,				! Number of lines on screen
	EDT$$G_SCLL_TOP,			! Top line the cursor is allowed to stay on
	EDT$$G_SCLL_BOT,			! Bottom line the cursor is allowed to stay on
	EDT$$A_BOT_SCRPTR : REF SCREEN_LINE,	! Bottom screen pointer
	EDT$$A_LST_SCRPTR : REF SCREEN_LINE,	! Last data structure pointer
	EDT$$A_TOP_SCRPTR : REF SCREEN_LINE,	! Top screen line info address
	EDT$$A_EOB_SCRPTR : REF SCREEN_LINE,	! EOB screen pointer
	EDT$$G_CS_LNO,				! current cursor line
	EDT$$G_TI_SCROLL,			! 1 = we have scrolling regions
	EDT$$G_TI_TYP,				! Terminal type
	EDT$$G_BOT_LINE,			! All lines below this one have been erased
	EDT$$G_MSGFLG;				! 1 = there is a message on the screen

    LOCAL
	NXT_SCRPTR : REF SCREEN_LINE,		! Next screen pointer
	SCLL_CENTER;				! The center line of the screen

!+
! There must always be a line after an inserted line, since the [EOB] is never inserted.
!-
    NXT_SCRPTR = .SCRPTR [SCR_NXT_LINE];
    ASSERT (.NXT_SCRPTR NEQA 0);

    IF ((.NXT_SCRPTR [SCR_EDIT_FLAGS] AND SCR_EDIT_DELLN) NEQ 0)
    THEN
	BEGIN
!+
! The next line is deleted.  Combine an inserted line and a deleted line by
! just repainting the inserted line and ignoring the deleted line.
!-
	EDT$$SC_REPAINT (.SCRPTR, .NXT_SCRPTR, 0, 255, 1);
!+
! Erase the deleted line so we can just paint the inserted line over it as though
! we had opened a line for the inserted text.
!-
	EDT$$SC_POSCSIF (.EDT$$G_CS_LNO, 0);
	EDT$$SC_ERATOEOL ();
	RETURN (1);
	END;

!+
! Decide whether we will be scrolling up or down.  If we scroll up then the lines above
! the inserted line are moved up to make room for the inserted line, and the top line
! is removed from the screen.  Lines below the inserted line are not changed.  If we
! scroll down then the lines below the inserted line are moved down to make room for
! the inserted line, and the bottom line, if there is one, is removed from the screen.
!-
    SCLL_CENTER = (.EDT$$G_SCLL_TOP + .EDT$$G_SCLL_BOT)/2;

    IF ((.EDT$$G_CS_LNO GEQ .SCLL_CENTER) AND (.EDT$$G_BOT_LINE GEQ .EDT$$G_SCR_LNS))
    THEN
	BEGIN

	LOCAL
	    RET_VALUE;

!+
! The inserted line is low on the screen and the screen is full.  Move a new line onto
! the bottom of the screen.  This will require scrolling the top of the screen up one
! and having a new top line.
!-

	IF .EDT$$G_TI_SCROLL
	THEN
	    BEGIN
!+
! We have scrolling regions, so we can avoid repainting the bottom of the screen.
!-
	    EDT$$G_CS_LNO = .EDT$$G_CS_LNO - 1;
	    EDT$$SC_SETSCLLREG (0, .EDT$$G_CS_LNO + 1);
	    EDT$$SC_POSCSIF (.EDT$$G_CS_LNO, 0);
	    EDT$$FMT_LIT (UPLIT (%STRING (%CHAR (ASC_K_LF))), 1);	! Scroll up
	    RET_VALUE = 1;			! Paint this line and continue
	    END
	ELSE
	    BEGIN
!+
! We do not have scrolling regions, we must repaint the bottom of the screen.
! Make sure the message area is blank, since otherwise we may scroll a message
! into the text area.
!-
	    BEGIN

	    LOCAL
		SAV_CS_LN;

	    EDT$$G_MSGFLG = 0;
	    SAV_CS_LN = .EDT$$G_CS_LNO;
	    EDT$$G_CS_LNO = .EDT$$G_SCR_LNS;
	    EDT$$SC_ERAALL ();
	    EDT$$G_CS_LNO = .SAV_CS_LN;
	    END;
!+
! Now scroll the whole screen up by one.
!-
	    EDT$$SC_POSCSIF (.EDT$$G_MESSAGE_LINE + 1, 0);
	    EDT$$FMT_LIT (UPLIT (BYTE (ASC_K_LF)), 1);
!+
! Arrange to repaint all lines below the deleted line.
!-
	    EDT$$SC_REPAINT (.SCRPTR, .EDT$$A_LST_SCRPTR, 0, 255, 1);
	    RET_VALUE = 0;			! Start a new pass
	    END;

!+
! Mark the top line for repaint since it is moving off the screen.
!-
	EDT$$SC_REPAINT (.EDT$$A_TOP_SCRPTR, .EDT$$A_TOP_SCRPTR, 0, 255, -1);
	EDT$$A_TOP_SCRPTR = .EDT$$A_TOP_SCRPTR [SCR_NXT_LINE];
!+
! Adjust the record number of the top line.
!-

	IF ((.EDT$$A_TOP_SCRPTR [SCR_LINE_IDX] EQL 0) AND 	!
	    ((.EDT$$A_TOP_SCRPTR [SCR_EDIT_FLAGS] AND SCR_EDIT_DELLN) EQL 0))
	THEN
	    .OLD_TOP_RECNO = ..OLD_TOP_RECNO + 1;

	RETURN (.RET_VALUE);
	END
    ELSE
	BEGIN

	LOCAL
	    RET_VALUE;

!+
! The inserted line is high on the screen, or the screen is not full.
! Scroll the bottom of the screen down.
!-

	IF .EDT$$G_TI_SCROLL
	THEN
	    BEGIN
!+
! We have scrolling regions, so we do not have to repaint the top of the screen.
!-

	    IF (.EDT$$G_TI_EDIT)
	    THEN
!+
! Use VT102 edit feature
!-
		BEGIN
		EDT$$SC_POSCSIF (.EDT$$G_CS_LNO, 0);
		EDT$$FMT_LIT (UPLIT (%STRING (%CHAR (ASC_K_ESC), '[L')), 3);
		END
	    ELSE
		BEGIN
!+
! Simulate edit feature
!-
		EDT$$SC_SETSCLLREG (.EDT$$G_CS_LNO, .EDT$$G_SCR_LNS);
		EDT$$SC_POSCSIF (.EDT$$G_CS_LNO, 0);
		EDT$$FMT_LIT (UPLIT (%STRING (%CHAR (ASC_K_ESC), 'M')), 2);	! Scroll down
		END;

	    RET_VALUE = 1;			! Repaint this line and continue
	    END
	ELSE
	    BEGIN
!+
! This is a terminal without scrolling regions.  If the inserted line is high on the screen
! scroll down then repaint from the beginning of the screen to this point.  If the inserted
! line is low on the screen just repaint from here to the bottom of the screen.
!-

	    IF (.EDT$$G_CS_LNO LSS (.EDT$$G_BOT_LINE/2))
	    THEN
		BEGIN
!+
! The inserted line is high on the screen.  Scroll down and repaint the part of the screen
! above the inserted line.
!-
		EDT$$SC_POSCSIF (0, 0);

		IF (.EDT$$G_TI_TYP EQL TERM_VT52)	!
		THEN
		    EDT$$FMT_LIT (UPLIT (BYTE (ASC_K_ESC, %C'I')), 2)
		ELSE
		    EDT$$FMT_LIT (UPLIT (BYTE (ASC_K_ESC, %C'M')), 2);

!+
! Make sure the message area is blank,
! since we may have moved text into the message area.
!-
		BEGIN

		LOCAL
		    SAV_CS_LN;

		EDT$$G_MSGFLG = 0;
		SAV_CS_LN = .EDT$$G_CS_LNO;
		EDT$$G_CS_LNO = .EDT$$G_SCR_LNS;
		EDT$$SC_ERAALL ();
		EDT$$G_CS_LNO = .SAV_CS_LN;
		END;
!+
! Now mark the top of the screen to be repainted.
!-
		EDT$$SC_REPAINT (.EDT$$A_TOP_SCRPTR, .SCRPTR, 0, 255, 1);
		RET_VALUE = 0;			! Start a new update pass
		END
	    ELSE
		BEGIN
!+
! The inserted line is low on the screen.  Just repaint the inserted line and all lower lines.
!-
		EDT$$SC_REPAINT (.SCRPTR, .EDT$$A_LST_SCRPTR, 0, 255, 1);
		RET_VALUE = 0;			! Start a new pass
		END;

	    END;

!+
! If the bottom line will move off the screen, arrange to repaint it if it should move back on.
!-

	IF ((.EDT$$A_BOT_SCRPTR NEQA 0) AND (.EDT$$G_BOT_LINE GEQ (.EDT$$G_SCR_LNS - 1)))
	THEN
	    BEGIN
	    EDT$$SC_REPAINT (.EDT$$A_BOT_SCRPTR, .EDT$$A_BOT_SCRPTR, 0, 255, 0);
	    EDT$$A_BOT_SCRPTR = .EDT$$A_BOT_SCRPTR [SCR_PRV_LINE];
	    END;

!+
! The bottom line may be lower on the screen.  It doesn't matter much if EDT$$G_BOT_LINE is too large.
!-
	EDT$$G_BOT_LINE = .EDT$$G_BOT_LINE + 1;
	RETURN (.RET_VALUE);
	END;

    END;					! of routine INSERT_LINE

%SBTTL 'EDT$$LOAD_SCRUPDATE - load this module into memory'

GLOBAL ROUTINE EDT$$LOAD_SCRUPDATE 		! Load this module into memory
    : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine has no function.  It exists as an entry point so that
!	EDT$$FIXNOTRUNC_NOOVERLAY can call this module back into memory before
!	returning to it.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN
    0
    END;					! of routine EDT$$LOAD_SCRUPDATE

!<BLF/PAGE>

END						! of module EDT$SCRUPDATE

ELUDOM
