.TITLE	CRTRUB	SCOPE TYPE DETERMINATION, TABLES, SEQUENCES
.NLIST	TTM
.LIST	TOC,MEB,BEX
.ENABL	REG,GBL,LC
.SBTTL	SCOPE TYPE DETERMINATION, TABLES, SEQUENCES

; LAST EDIT ON 02-JUN-83 BY MARK BRAMHALL

.IDENT	/V39.00/

;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

.SBTTL	ASSEMBLY PARAMETERS

; RSTS		ASSEMBLE FOR RSTS/E SCOPE TYPE DETERMINATION	(D=NO)
; RSX		ASSEMBLE FOR RSX-11 SCOPE TYPE DETERMINATION	(D=NO)
; RT11		ASSEMBLE FOR RT-11 SCOPE TYPE DETERMINATION	(D=NO)
; VMS		ASSEMBLE FOR VAX/VMS SCOPE TYPE DETERMINATION	(D=NO)

; NOTE: YOU MUST SELECT EXACTLY ONE OPERATING SYSTEM FROM THE FOUR ABOVE.

; WATCH		ASSEMBLE TO INCLUDE "WATCH" SUPPORT		(D=YES)
; SCROLL	ASSEMBLE TO INCLUDE SCROLLING SUPPORT		(D=YES)
; IMMEDC	ASSEMBLE TO INCLUDE IMMEDIATE MODE COMMANDS	(D=YES)
; I$$SOB	ASSEMBLE FOR HARDWARE 'SOB' INSTRUCTION		(D=NO)
; I$$DIV	ASSEMBLE FOR HARDWARE 'DIV' INSTRUCTION		(D=NO)

.SBTTL	DEFAULT AND SET UP THE ASSEMBLY PARAMETERS

.IIF	NDF	RSTS,	RSTS=0	;DEFAULT TO NOT RSTS/E
.IIF	NDF	RSX,	RSX=0	;DEFAULT TO NOT RSX-11
.IIF	NDF	RT11,	RT11=0	;DEFAULT TO NOT RT-11
.IIF	NDF	VMS,	VMS=0	;DEFAULT TO NOT VAX/VMS

$$$$$$	=	0

.IF	NE	RSTS

$$$$$$	=	$$$$$$+1

.SBTTL		ASSEMBLED FOR RSTS/E SCOPE TYPE DETERMINATION

.ENDC	;NE	RSTS

.IF	NE	RSX

$$$$$$	=	$$$$$$+1

.SBTTL		ASSEMBLED FOR RSX-11 SCOPE TYPE DETERMINATION

.ENDC	;NE	RSX

.IF	NE	RT11

$$$$$$	=	$$$$$$+1

.SBTTL		ASSEMBLED FOR RT-11 SCOPE TYPE DETERMINATION

.ENDC	;NE	RT11

.IF	NE	VMS

$$$$$$	=	$$$$$$+1

.SBTTL		ASSEMBLED FOR VAX/VMS SCOPE TYPE DETERMINATION

.ENDC	;NE	VMS

.IF	NE	$$$$$$-1

.ERROR	;NO OR MORE THAN ONE SCOPE TYPE DETERMINATION ROUTINE SPECIFIED

.ENDC	;NE	$$$$$$-1

.IIF	NDF	WATCH,	WATCH=1		;DEFAULT TO INCLUDING "WATCH" SUPPORT
.IIF	NDF	SCROLL,	SCROLL=1	;DEFAULT TO INCLUDING SCROLL SUPPORT
.IIF	NDF	IMMEDC,	IMMEDC=1	;DEFAULT TO INCLUDING IMMEDIATE MODE

.IF	NE	WATCH

.IF	NE	SCROLL

.SBTTL		ASSEMBLED TO INCLUDE "WATCH" SUPPORT W/ SCROLLING

.IFF	;NE	SCROLL

.SBTTL		ASSEMBLED TO INCLUDE "WATCH" SUPPORT W/O SCROLLING

.ENDC	;NE	SCROLL

.IFF	;NE	WATCH

.SBTTL		ASSEMBLED TO NOT INCLUDE "WATCH" SUPPORT

SCROLL	=	0			;TURN OFF SCROLLING IF NO "WATCH"

.ENDC	;NE	WATCH

.IF	NE	IMMEDC

.SBTTL		ASSEMBLED TO INCLUDE IMMEDIATE MODE COMMANDS

.IFF	;NE	IMMEDC

.SBTTL		ASSEMBLED TO NOT INCLUDE IMMEDIATE MODE COMMANDS

.ENDC	;NE	IMMEDC

.IIF	NDF	I$$SOB,	I$$SOB=0	;DEFAULT TO NO HARDWARE 'SOB'

.IF	EQ	I$$SOB

.MACRO	SOB	REG,DST
	 DEC	REG
	 BNE	DST
.ENDM	SOB

.SBTTL		ASSEMBLED WITHOUT HARDWARE 'SOB' INSTRUCTION

.IFF	;EQ	I$$SOB

.SBTTL		ASSEMBLED WITH HARDWARE 'SOB' INSTRUCTION

.ENDC	;EQ	I$$SOB

.IIF	NDF	I$$DIV,	I$$DIV=0	;DEFAULT TO NO HARDWARE 'DIV'

.IF	EQ	I$$DIV

.MACRO	DIVR0	AMT
	 MOV	AMT,R0
	 JSR	PC,DIVR0
.ENDM	DIVR0

.SBTTL		ASSEMBLED WITHOUT HARDWARE 'DIV' INSTRUCTION

.IFF	;EQ	I$$DIV

.MACRO	DIVR0	AMT
	 CLR	R0
	 DIV	AMT,R0
.ENDM	DIVR0

.SBTTL		ASSEMBLED WITH HARDWARE 'DIV' INSTRUCTION

.ENDC	;EQ	I$$DIV

.SBTTL	FIXED FORMAT PREAMBLE

.PSECT	CRTRUB,RO,I,GBL,REL,OVR

CRTRUB:	BR	CRTSET		;BRANCH TO THE SET UP ROUTINE

.IIF	NE	.-CRTRUB-2, .ERROR ;ERASE CHARACTER INCORRECTLY LOCATED
CRTERC:	.WORD	ERCTBL		;ERASE CHARACTER SEQUENCE POINTERS POINTER

.IIF	NE	.-CRTRUB-4, .ERROR ;CURSOR UP INCORRECTLY LOCATED
CRTCUP:	.WORD	CUPTBL		;CURSOR UP SEQUENCE POINTERS POINTER

.IIF	NE	.-CRTRUB-6, .ERROR ;<CR><ERASE LINE> INCORRECTLY LOCATED
CRTERL:	.WORD	ERLTBL		;<CR><ERASE LINE> SEQUENCE POINTERS POINTER

.SBTTL	DETERMINE SCOPE TYPE

;+
; CRTSET - DETERMINE SCOPE TYPE.
;
;*RSTS*	R4 -> FIRQB @ +6 WITH CHARACTERISTICS (UU.TRM) OF SCOPE TERMINAL
;*RSX*	R4 -> HORIZONTAL SIZE BYTE (@ +0) & TYPE BYTE (@ +2) OF SCOPE TERMINAL
;*RT11*	R4 -> TERMINAL STATUS BLOCK @ +6 (M.TWID) OF SCOPE TERMINAL
;*VMS*	R4 -> SENSEMODE INFORMATION BUFFER @ +2 (DEVBUFSIZ) OF SCOPE TERMINAL
;	CRTYPE(R5) = 0 (I.E., PRE-SET FOR DEFAULT SCOPE SUPPORT)
;
;	JSR	PC,CRTRUB
;
;	R4 =  SIZE OF "WATCH" STATIC READ/WRITE REGION (0 => NONE)
;	CRTYPE(R5) =  0. FOR SCOPE SUPPORT TYPE #1 (VT52)
;		      2. FOR SCOPE SUPPORT TYPE #2 (VT100 IN VT52 MODE)
;		      4. FOR SCOPE SUPPORT TYPE #3 (VT100 IN ANSI MODE)
;		      6. FOR SCOPE SUPPORT TYPE #4 (VT05)
;		      8. FOR SCOPE SUPPORT TYPE #5 (VT102)
;		     10. FOR SCOPE SUPPORT TYPE #6 (VK100)
;	VTSIZE+RWSIZE(R5) = VERTICAL SIZE IF "WATCH" SUPPORT (10.-127.)
;	HTSIZE+RWSIZE(R5) = HORIZONTAL SIZE IF "WATCH" SUPPORT (10.-254.&EVEN)
;	SCROLN+RWSIZE(R5) = 0 (NO SCROLLING INITIALLY)
;	"ET$CRT" SET IN "ETYPE(R5)" IF SCOPE SUPPORTED FOR RUBOUT & CONTROL/U
;	"ET$IAS" SET IN "ETYPE(R5)" IF SCOPE SUPPORTED FOR "WATCH"
;-

CRTMAX	==	10.		;MAXIMUM LEGAL SCOPE TYPE IS 10.

.MACRO	CRTTBL	LIST		;MACRO TO BUILD CRTYPE POINTER TABLES
$$$$$$	=	.
.IRP	ENTRY,<LIST>
.NLIST	MEB
	.WORD	ENTRY
.LIST	MEB
.ENDM	;ENTRY,<LIST>
.IIF	NE	.-$$$$$$-CRTMAX-2, .ERROR ;INCORRECT NUMBER OF TABLE ENTRIES
.ENDM	CRTTBL

CRTSET:	MOV	R0,-(SP)	;SAVE R0
	MOV	#CRTMAX,R0	;PRESET SCOPE TYPE TO MAXIMUM

.IF	NE	RSTS

	DECB	(R4)		;FORM THE TRUE HORIZONTAL SIZE
	CMPB	(R4),#84.	;IS SCOPE A VK100 (WIDTH = 84.)?
	BEQ	60$		;YES
	CMPB	(R4),#72.	;IS SCOPE A VT05 (WIDTH = 72.)?
	BEQ	40$		;YES
	INCB	12-6(R4)	;REALLY A VT100 ("XON")?
	BEQ	30$		;YES, USE IT IN ANSI MODE
.IIF	NE	.-10$, .ERROR	;ELSE DEFAULT TO VT52...

.ENDC	;NE	RSTS

.IF	NE	RSX

	CMPB	2(R4),#T.V102	;IS SCOPE A VT102?
	BEQ	50$		;YES
	CMPB	2(R4),#T.VT05	;IS SCOPE A VT05?
	BEQ	40$		;YES
	CMPB	2(R4),#T.V100	;IS SCOPE A VT100?
	BEQ	30$		;YES, USE IT IN ANSI MODE
	CMPB	(R4),#72.	;IS SCOPE A VT05 (WIDTH = 72.)?
	BEQ	40$		;YES
	CMPB	2(R4),#T.VT52	;IS SCOPE A VT52?
	BNE	30$		;NO, DEFAULT TO VT100 IN ANSI MODE...
.IIF	NE	.-10$, .ERROR	;YES

.ENDC	;NE	RSX

.IF	NE	RT11

	CMPB	(R4),#72.	;IS SCOPE A VT05 (WIDTH = 72.)?
	BEQ	40$		;YES
	BIT	#TANSI$,0-6(R4)	;REALLY A VT100 ("ANSI")?
	BNE	30$		;YES, USE IT IN ANSI MODE
.IIF	NE	.-10$, .ERROR	;ELSE DEFAULT TO VT52...

.ENDC	;NE	RT11

.IF	NE	VMS

;	 0-2(R4) [BYTE] = DEVCLASS
;	 1-2(R4) [BYTE] = DEVTYPE
;	 2-2(R4) [WORD] = DEVBUFSIZ (WIDTH)
;	 4-2(R4) [LONG] = DEVDEPEND
;	10-2(R4) [LONG] = DEVDEPEND2

	CMPB	1-2(R4),#T$VT05	;IS SCOPE A VT05 (T$VT05 = TT$_VT05)?
	BEQ	40$		;YES
	BIT	<10+2>-2(R4),#T$EDIT ;'EDIT' FUNCTIONS? (T$EDIT = TT2$M_EDIT)?
	BNE	50$		;YES, CALL IT A VT102
	BIT	<10+2>-2(R4),#T$DEC ;A 'DEC CRT' (T$DEC = TT2$M_DECCRT)?
	BNE	30$		;YES, CALL IT A VT100 IN ANSI MODE
	BIT	<10+2>-2(R4),#T$ANSI ;AN 'ANSI CRT' (T$ANSI = TT2$M_ANSICRT)?
	BNE	60$		;YES, CALL IT A VK100
.IIF	NE	.-10$, .ERROR	;ELSE DEFAULT TO VT52...

.ENDC	;NE	VMS

10$:	TST	-(R0)		;CHANGE SCOPE TYPE TO  0. (VT52)
20$:	TST	-(R0)		;CHANGE SCOPE TYPE TO  2. (VT100 IN VT52 MODE)
30$:	TST	-(R0)		;CHANGE SCOPE TYPE TO  4. (VT100 IN ANSI MODE)
40$:	TST	-(R0)		;CHANGE SCOPE TYPE TO  6. (VT05)
50$:	TST	-(R0)		;CHANGE SCOPE TYPE TO  8. (VT102)
60$:				;LEAVE  SCOPE TYPE AS 10. (VK100)
.IIF	NE	60$-10$-CRTMAX, .ERROR ;INCORRECT SCOPE TYPE FORMATION
	MOV	R0,CRTYPE(R5)	;SET THE SCOPE TYPE
	BIS	#ET$CRT,ETYPE(R5) ; AND ENABLE SCOPE RUBOUT SUPPORT

.IF	NE	WATCH

	MOV	90$(R0),VTSIZE+RWSIZE(R5) ;SAVE VERTICAL SIZE FOR "WATCH"
	MOV	100$(R0),HTSIZE+RWSIZE(R5) ;SAVE HORIZONTAL SIZE FOR "WATCH"
	BNE	80$		;THE HORIZONTAL SIZE IS EXPLICIT
	CMPB	(R4),#132.	;IS CURRENT SIZE FROM 132 COLUMN MODE?
	BEQ	70$		;YES, GO SET 132 AS THE CORRECT SIZE
	MOVB	#80.,(R4)	;NO, JAM ALL OTHERS TO BE SIMPLY 80 COLUMNS
70$:	MOVB	(R4),HTSIZE+RWSIZE(R5) ;SET THE CORRECT HORIZONTAL SIZE
80$:				;CONTINUE

.IF	NE	SCROLL

	CLR	SCROLN+RWSIZE(R5) ;SET NOT SCROLLING INITIALLY

.ENDC	;NE	SCROLL

	BIS	#ET$IAS,ETYPE(R5) ;ENABLE "WATCH" SUPPORT
	MOV	#SRWSIZ,R4	; AND SET SIZE OF STATIC READ/WRITE REGION

.IFF	;NE	WATCH

	CLR	R4		;NO STATIC READ/WRITE REGION SINCE NO "WATCH"

.IFTF	;NE	WATCH

	MOV	(SP)+,R0	;RESTORE R0
	RTS	PC		; AND EXIT

.IFT	;NE	WATCH

90$:	CRTTBL	<24.,24.,24.,20.,24.,24.> ;TABLE OF VERTICAL SIZES

100$:	CRTTBL	<80.,80., 0 ,72., 0 ,80.> ;TABLE OF HORIZONTAL SIZES

.ENDC	;NE	WATCH

.SBTTL	NECESSARY SEQUENCES FOR RUBOUT AND CONTROL/U

ERCTBL:	CRTTBL	<10$,10$,10$,10$,10$,10$> ;ERASE CHARACTER SEQUENCE POINTERS

10$:	.BYTE	30$-20$		;ALL TYPES =>
20$:	.BYTE	010		;	<BS>
	.BYTE	040		;	<SPACE>
	.BYTE	010		;	<BS>
30$:	.EVEN

CUPTBL:	CRTTBL	<10$,10$,40$,70$,40$,40$> ;CURSOR UP SEQUENCE POINTERS

10$:	.BYTE	30$-20$		;VT52 & VT100(VT52) =>
20$:	.BYTE	033,'A		;	<ESC><A>
30$:	.EVEN

40$:	.BYTE	60$-50$		;VT100(ANSI), VT102, & VK100 =>
50$:	.BYTE	033,'\		;	ENSURE END OF DCS STRING (IF ANY)
	.BYTE	033,'<		;	ENSURE ANSI MODE
	.BYTE	033,'[,'A	;	<ESC><[><A>
60$:	.EVEN

70$:	.BYTE	90$-80$		;VT05 =>
80$:	.BYTE	232		;	<CUP>
	.BYTE	000,000,000,000	;	<NUL><NUL><NUL><NUL>
90$:	.EVEN

ERLTBL:	CRTTBL	<10$,10$,40$,70$,40$,40$> ;<CR><ERASE LINE> SEQUENCE POINTERS

10$:	.BYTE	30$-20$		;VT52 & VT100(VT52) =>
20$:	.BYTE	015		;	ENSURE LEFT MARGIN
	.BYTE	033,'K		;	<ESC><K>
	.BYTE	015		;	ENSURE LEFT MARGIN
30$:	.EVEN

40$:	.BYTE	60$-50$		;VT100(ANSI), VT102, & VK100 =>
50$:	.BYTE	015		;	ENSURE LEFT MARGIN
	.BYTE	033,'\		;	ENSURE END OF DCS STRING (IF ANY)
	.BYTE	033,'<		;	ENSURE ANSI MODE
	.BYTE	033,'[,'K	;	<ESC><[><K>
	.BYTE	015		;	ENSURE LEFT MARGIN
60$:	.EVEN

70$:	.BYTE	90$-80$		;VT05 =>
80$:	.BYTE	015		;	ENSURE LEFT MARGIN
	.BYTE	236		;	<EOL>
	.BYTE	015		;	ENSURE LEFT MARGIN
90$:	.EVEN

.IF	NE	WATCH

.SBTTL	NECESSARY TABLES AND SEQUENCES FOR "WATCH" SUPPORT

.PSECT	SCRSEQ,RO,D,GBL,REL,CON

; POSTBL - TABLE OF NUMBER OF CHARACTERS NEEDED TO POSITION CURSOR.
;
;	THIS TABLE IS USED FOR A CURSOR MOVEMENT OPTIMIZATION:
;	IF THE NUMBER OF PLACES TO MOVE THE CURSOR RIGHT (ON THE
;	SAME LINE) IS LESS THAN THIS TABLE'S ENTRY, THEN THE
;	PRECEEDING TEXT CHARACTERS ARE OUTPUT INSTEAD. THIS ENSURES
;	THAT WE ARE ALWAYS SENDING THE MINIMAL NUMBER OF CHARACTERS
;	TO THE SCREEN.

POSTBL::.WORD	1+1+1+1		;<ESC><Y><LINE #><COLUMN #>
	.WORD	1+1+1+1		;<ESC><Y><LINE #><COLUMN #>
	.WORD	1+1+1+1		;<ESC><[><# MOVES><C>
	.WORD	1+1+4+1		;<CTRL/N><LINE #><4 FILL'S><COLUMN #>
	.WORD	1+1+1+1		;<ESC><[><# MOVES><C>
	.WORD	1+1+1+1		;<ESC><[><# MOVES><C>
.IIF	NE	.-POSTBL-CRTMAX-2, .ERROR ;INCORRECT NUMBER OF TABLE ENTRIES

; FIXSEQ - CLEAN UP MODES.
;	NULL => NO FIXING UP IS NEEDED

.ENABL	LSB

FIXSEQ::CRTTBL	<10$,10$,20$,NULL,20$,30$> ;CLEAN UP MODES (IF ANY)

10$:	.BYTE	033,'[,'?,'2,'L+40 ;ENSURE VT52 MODE
	.BYTE	033,'\		;EXIT HOLD SCREEN MODE (IF ON)
	.BYTE	010,010,010,040,040,040 ;CLEAN UP THE "?2L" JUNK...
V52GOF:	.BYTE	033,'G		;EXIT GRAPHICS MODE (IF ON)
	.BYTE	200

20$:	.BYTE	033,'\		;ENSURE END OF DCS STRING (IF ANY)
	.BYTE	033,'<		;ENSURE ANSI MODE
	.BYTE	033,'7		;SAVE CURSOR POSITION
	.BYTE	033,'[,'?,'6	;ENSURE ORIGIN MODE
	.BYTE	    ';,'7,'L+40	; AND AUTO WRAP ARE OFF
	.BYTE	033,'8		;RESTORE CURSOR POSITION
30$:	.BYTE	033,'\		;ENSURE END OF DCS STRING (IF ANY)
	.BYTE	033,'<		;ENSURE ANSI MODE
	.BYTE	033,'[,'4,'L+40	;ENSURE REPLACE (NOT INSERT) MODE
	.BYTE	033,'[,'M+40	;TURN OFF ALL CHARACTER ATTRIBUTES
	.BYTE	033,'),'0	;SET GRAPHICS MODE TO GRAPHICS CHARACTER SET
ANSGOF:	.BYTE	017		;EXIT GRAPHICS MODE (IF ON)
	.BYTE	200

	.EVEN

.DSABL	LSB

; HOMSEQ - GO TO HOME.

HOMSEQ::CRTTBL	<10$,10$,20$,30$,20$,20$> ;GO TO HOME

10$:	.BYTE	033,'H		;GO TO HOME
	.BYTE	200

20$:	.BYTE	033,'[,'H	;GO TO HOME
	.BYTE	200

30$:	.BYTE	035		;GO TO HOME
FILL4:	.BYTE	000,000,000,000	;4 FILL'S
NULL:	.BYTE	200		;NULL SEQUENCE

	.EVEN

; EOLSEQ - ERASE FROM CURSOR TO END OF LINE.

EOLSEQ::CRTTBL	<10$,10$,20$,40$,20$,30$> ;ERASE FROM CURSOR TO END OF LINE

10$:	.BYTE	033,'K		;ERASE FROM CURSOR TO END OF LINE
	.BYTE	200

20$:	.BYTE	033,'#,'5	;ENSURE A NORMAL HEIGHT/WIDTH LINE
30$:	.BYTE	033,'[,'K	;ERASE FROM CURSOR TO END OF LINE
	.BYTE	200

40$:	.BYTE	036		;ERASE FROM CURSOR TO END OF LINE
	.BYTE	200

	.EVEN

; EOSSEQ - ERASE FROM CURSOR TO END OF SCREEN.
;	NULL => USE MULTIPLE EOLSEQ'S (DUE TO VARIABLE SCROLLING REGION)

EOSSEQ::CRTTBL	<10$,10$,NULL,30$,NULL,20$> ;ERASE FROM CURSOR TO END OF SCREEN

10$:	.BYTE	033,'J		;ERASE FROM CURSOR TO END OF SCREEN
	.BYTE	200

20$:	.BYTE	033,'[,'J	;ERASE FROM CURSOR TO END OF SCREEN
	.BYTE	200

30$:	.BYTE	037		;ERASE FROM CURSOR TO END OF SCREEN
	.BYTE	000,000,000,000	;4 FILL'S
	.BYTE	200

	.EVEN

; SCUSEQ - SCROLL SCREEN UP (WITH CURSOR AT LOWER LEFT).

SCUSEQ::CRTTBL	<10$,10$,10$,VT05LF,10$,10$> ;SCROLL SCREEN UP

10$:	.BYTE	012		;SCROLL SCREEN UP
	.BYTE	200

VT05LF:	.BYTE	012		;SCROLL SCREEN UP
	.BYTE	000,000,000,000	;4 FILL'S
	.BYTE	200

	.EVEN

; SCDSEQ - SCROLL SCREEN DOWN (WITH CURSOR AT UPPER LEFT).
;	NULL => FEATURE IS NOT AVAILABLE

SCDSEQ::CRTTBL	<10$,10$,20$,NULL,20$,20$> ;SCROLL SCREEN DOWN

10$:	.BYTE	033,'I		;SCROLL SCREEN DOWN
	.BYTE	200

20$:	.BYTE	033,'M		;SCROLL SCREEN DOWN
	.BYTE	200

	.EVEN

; GONSEQ - TURN ON GRAPHICS MODE.
;	NULL => FEATURE IS NOT AVAILABLE

GONSEQ::CRTTBL	<10$,10$,20$,NULL,20$,20$> ;TURN ON GRAPHICS MODE

10$:	.BYTE	033,'F		;TURN ON GRAPHICS MODE
	.BYTE	200

20$:	.BYTE	016		;TURN ON GRAPHICS MODE
	.BYTE	200

	.EVEN

; GOFSEQ - TURN OFF GRAPHICS MODE.
;	NULL => FEATURE IS NOT AVAILABLE

GOFSEQ::CRTTBL	<V52GOF,V52GOF,ANSGOF,NULL,ANSGOF,ANSGOF> ;GRAPHICS MODE OFF

; MONSEQ - TURN ON MARK'D REGION MODE.
;	NULL => FEATURE IS NOT AVAILABLE

MONSEQ::CRTTBL	<NULL,NULL,10$,NULL,10$,10$> ;TURN ON MARK'D REGION MODE

10$:	.BYTE	033,'[,'7,'M+40	;SET REVERSE VIDEO ATTRIBUTE
	.BYTE	200

	.EVEN

; MOFSEQ - TURN OFF MARK'D REGION MODE.
;	NULL => FEATURE IS NOT AVAILABLE

MOFSEQ::CRTTBL	<NULL,NULL,10$,NULL,10$,10$> ;TURN OFF MARK'D REGION MODE

10$:	.BYTE	033,'[,'M+40	;CLEAR ALL ATTRIBUTES
	.BYTE	200

	.EVEN

; GRPTBL - TABLE OF GRAPHICS MODE CHARACTERS.
;
;	EACH TABLE CONTAINS 15. BYTES CORRESPONDING TO THE GRAPHICS
;	MODE CHARACTERS FOR:
;
;		 1) A LINE WHICH OVERFLOWS THE SCREEN'S WIDTH
;		 2) CURSOR POSITIONED ON <LF> IMMEDIATELY AFTER <CR>
;		    ALSO, "SEE ALL" MODE SYMBOL FOR <LF>
;		 3) "SEE ALL" MODE SYMBOL FOR CONTROL CHARACTER FLAG
;		 4) "SEE ALL" MODE SYMBOL FOR <VT>
;		 5) AT END OF BUFFER ENDING WITHOUT <FF>
;		 6) AT END OF BUFFER ENDING WITH <FF>
;		    ALSO, "SEE ALL" MODE SYMBOL FOR <FF>
;		 7) "SEE ALL" MODE SYMBOL FOR <HT>
;		 8) "SEE ALL" MODE SYMBOL FOR NULL SPACING
;		 9) "SEE ALL" MODE SYMBOL FOR <CR>
;		10) "SEE ALL" MODE SYMBOL FOR OVERPRINT <CR>
;		11) "SEE ALL" MODE SYMBOL FOR HEX PAIR START
;		12) "SEE ALL" MODE SYMBOL FOR COMPOSE SEQUENCE START
;		13) "SEE ALL" MODE SYMBOL FOR HEX PAIR END
;		14) "SEE ALL" MODE SYMBOL FOR COMPOSE SEQUENCE END
;		15) "SEE ALL" MODE SYMBOL FOR <ESC>

GRPTBL::CRTTBL	<10$,20$,20$,30$,20$,20$> ;TABLE OF GRAPHICS CHARACTERS

10$:	.BYTE	'H+40		;RIGHT ARROW
	.BYTE	'K+40		;DOWN ARROW
	.BYTE	'G+40		;PLUS OR MINUS
	.BYTE	'J+40		;DIVIDED BY
	.BYTE	'^+40		;PARAGRAPH
	.BYTE	'A+40		;SOLID RECTANGLE
	.BYTE	'F+40		;DEGREES
	.BYTE	'I+40		;ELIPSIS
	.BYTE	'@+40		;"CD"
	.BYTE	'D+40		;"5/"
	.BYTE	'[		;NO SPECIAL GRAPHIC...
	.BYTE	'<		;NO SPECIAL GRAPHIC...
	.BYTE	']		;NO SPECIAL GRAPHIC...
	.BYTE	'>		;NO SPECIAL GRAPHIC...
	.BYTE	'C+40		;"3/"

20$:	.BYTE	'H+40		;"NL"
	.BYTE	'E+40		;"LF"
	.BYTE	'G+40		;PLUS OR MINUS
	.BYTE	'I+40		;"VT"
	.BYTE	'@+40		;DIAMOND
	.BYTE	'C+40		;"FF"
	.BYTE	'B+40		;"HT"
	.BYTE	'^+40		;CENTERED DOT
	.BYTE	'D+40		;"CR"
	.BYTE	'\+40		;NOT EQUALS
	.BYTE	'M+40		;LOWER LEFT CORNER
	.BYTE	'Y+40		;LESS THAN OR EQUAL TO
	.BYTE	'J+40		;LOWER RIGHT CORNER
	.BYTE	'Z+40		;GREATER THAN OR EQUAL TO
	.BYTE	'[+40		;PI

30$:	.BYTE	'+		;+
	.BYTE	''		;'
	.BYTE	'^		;NO GRAPHICS...
	.BYTE	040		;NO GRAPHICS...
	.BYTE	'%		;%
	.BYTE	'@		;@
	.BYTE	040		;NO GRAPHICS...
	.BYTE	040		;NO GRAPHICS...
	.BYTE	040		;NO GRAPHICS...
	.BYTE	040		;NO GRAPHICS...
	.BYTE	'[		;NO GRAPHICS...
	.BYTE	'<		;NO GRAPHICS...
	.BYTE	']		;NO GRAPHICS...
	.BYTE	'>		;NO GRAPHICS...
	.BYTE	'$		;NO GRAPHICS...

	.EVEN

.IF	NE	SCROLL

.SBTTL	NECESSARY SEQUENCES FOR SCROLLING SUPPORT

; CONSEQ - TURN ON CURSOR CHARACTER ATTRIBUTES.
;	NULL => FEATURE IS NOT AVAILABLE

CONSEQ::CRTTBL	<NULL,NULL,10$,NULL,10$,NULL> ;CURSOR CHARACTER ATTRIBUTES ON

10$:	.BYTE	033,'[,'1	;SET BOLD
	.BYTE	    ';,'7,'M+40	; AND REVERSE VIDEO ATTRIBUTES
	.BYTE	200

	.EVEN

; COFSEQ - TURN OFF CURSOR CHARACTER ATTRIBUTES.
;	NULL => FEATURE IS NOT AVAILABLE

COFSEQ::CRTTBL	<NULL,NULL,10$,NULL,10$,NULL> ;CURSOR CHARACTER ATTRIBUTES OFF

10$:	.BYTE	033,'[,'M+40	;CLEAR ALL ATTRIBUTES
	.BYTE	017		;TURN OFF GRAPHICS MODE
	.BYTE	200

	.EVEN

; SAVCUR - SAVE CURSOR POSITION AND ATTRIBUTES.
;	NULL => FEATURE IS NOT AVAILABLE

SAVCUR::CRTTBL	<NULL,NULL,10$,NULL,10$,NULL> ;SAVE CURSOR POSITION/ATTRIBUTES

10$:	.BYTE	033,'7		;SAVE CURSOR POSITION AND ATTRIBUTES
	.BYTE	200

	.EVEN

; RESCUR - RESTORE CURSOR POSITION AND ATTRIBUTES.
;	NULL => FEATURE IS NOT AVAILABLE

RESCUR::CRTTBL	<NULL,NULL,10$,NULL,10$,NULL> ;RESTORE POSITION/ATTRIBUTES

10$:	.BYTE	033,'8		;RESTORE CURSOR POSITION AND ATTRIBUTES
	.BYTE	200

	.EVEN

.ENDC	;NE	SCROLL

.SBTTL	NECESSARY SUBROUTINES FOR "WATCH" SUPPORT

.PSECT	SCRSUB,RO,I,GBL,REL,CON

;+
; NWIDTH - A NEW HORIZONTAL SIZE (WIDTH) WAS SET.
;
;	R3 =  OLD WIDTH
;	HTSIZE+RWSIZE(R5) = NEW WIDTH
;
;	JSR	PC,NWIDTH
;
;	R0 =  UNDEFINED
;	R2 =  UNDEFINED
;	R3 =  UNDEFINED
;-

NWIDTH::			;A NEW WIDTH WAS SET

.IF	NE	RSTS
	JSR	PC,SAVFQB	;SAVE AND CLEAR THE FIRQB
	MOVB	#UU.TRM,(R4)+	;SET "SET TERMINAL" FUNCTION
	MOV	(PC)+,(R4)+	; AND OUR KB: TERMINAL
	 .BYTE	0,-1
	MOVB	HTSIZE+RWSIZE(R5),(R4) ;SET THE NEW SCOPE WIDTH
	INCB	(R4)		; PLUS 1
	.UUO			;NOW GO DO IT
	JSR	PC,@(SP)+	; THEN RESTORE THE FIRQB
.ENDC	;NE	RSTS

.IF	NE	RSX
				;ANYTHING TO DO FOR RSX???
.ENDC	;NE	RSX

.IF	NE	RT11
				;NOTHING TO DO FOR RT-11...
.ENDC	;NE	RT11

.IF	NE	VMS
	EMT	$WIDTH		;LET NATIVE MODE KNOW THE NEW WIDTH
.ENDC	;NE	VMS

	JSR	PC,20$		;GET SEQUENCE POINTER FOR OLD WIDTH
	MOV	R3,-(SP)	; AND SAVE IT
	MOV	HTSIZE+RWSIZE(R5),R3 ;GET THE NEW WIDTH
	JSR	PC,20$		;GET NEW WIDTH'S SEQUENCE POINTER
	CMP	R3,(SP)+	;ARE THE SEQUENCES THE SAME?
	BEQ	30$		;YES, NO NEED TO EMIT THE SEQUENCE
	JSR	PC,DOTYPE	;NO, GO EMIT SEQUENCE TO CHANGE THE WIDTH

.IF	NE	SCROLL

	TST	SCROLN+RWSIZE(R5) ;IS SCROLLING ENABLED?
	BEQ	10$		;NOPE
	JSR	PC,SCREOS	;YEP, POSITION TO BOTTOM OF SCREEN
10$:				;CONTINUE

.ENDC	;NE	SCROLL

	JMP	TYPEBC		;FORCE OUT ANY PARTIAL BUFFER & EXIT

20$:	CMP	R3,#80.+1	;IS WIDTH 81 COLUMNS OR GREATER?
	MOV	#40$,R3		;SET SEQUENCE POINTER FOR 80 COLUMN MODE
	BCS	30$		;GOOD GUESS? [BCS = BLO]
	MOV	#50$,R3		;SET SEQUENCE POINTER FOR 132 COLUMN MODE
30$:	RTS	PC		;EXIT

40$:	CRTTBL	<NULL,NULL,60$,NULL,60$,NULL> ;80 COLUMN MODE

50$:	CRTTBL	<NULL,NULL,70$,NULL,70$,NULL> ;132 COLUMN MODE

60$:	.BYTE	033, '[, '?, '3, 'L+40 ;CLEAR 132 COLUMN MODE
	.BYTE	200

70$:	.BYTE	033, '[, '?, '3, 'H+40 ;SET 132 COLUMN MODE
	.BYTE	200

	.EVEN

;+
; USRSET - SET A USER CONTROLLED PARAMETER.
;
;	R0 =  USER PARAMETER NUMBER (256.<=X<=32767.)
;	R4 =  NEW USER PARAMETER VALUE
;
;	JSR	PC,USRSET
;-

USRSET::			;SET A USER CONTROLLED PARAMETER
	RTS	PC		;EXIT

;+
; USRPRM - READ A USER CONTROLLED PARAMETER.
;
;	R0 =  0
;	R4 =  USER PARAMETER NUMBER (256.<=X<=32767.)
;
;	JSR	PC,USRPRM
;
;	R0 =  USER PARAMETER VALUE
;-

USRPRM::			;READ A USER CONTROLLED PARAMETER
	RTS	PC		;EXIT

;+
; DIGITS - OUTPUT ASCII DIGITS.
;
;	R1 =  NUMBER TO OUTPUT, 0 BASED
;
;	JSR	PC,DIGITS
;
;	R0 =  UNDEFINED
;	R1 =  UNDEFINED
;-

DIGITS:	INC	R1		;ANSI WANTS NUMBER "1" BASED
	DIVR0	#100.		;DIVIDE FOR HUNDREDS
	MOV	R0,-(SP)	;SAVE HUNDREDS
	BEQ	10$		;NO HUNDREDS, SO SKIP THEM
	JSR	PC,30$		;HUNDREDS, GO OUTPUT IT
10$:	DIVR0	#10.		;DIVIDE FOR TENS
	BIS	R0,(SP)+	;DO TENS AND/OR HUNDREDS EXIST?
	BEQ	20$		;NOPE
	JSR	PC,30$		;YEP, GO OUTPUT THE TENS
20$:	MOV	R1,R0		;SET UNITS
30$:	ADD	#'0,R0		;MAKE INTO AN ASCII DIGIT
	JMP	TYPEBF		;OUTPUT CHARACTER, THEN EXIT

;+
; DIRECT - DO DIRECT CURSOR ADDRESSING.
;
;	R0 =  DESIRED LINE NUMBER (ROW), 0 BASED
;	R2 =  DESIRED COLUMN NUMBER, 0 BASED
;	PRELIN+RWSIZE(R5) = CURRENT CURSOR LINE NUMBER (ROW), 0 BASED
;	PRECOL+RWSIZE(R5) = CURRENT CURSOR COLUMN NUMBER, 0 BASED
;
;	JSR	PC,DIRECT
;
;	R0 =  UNDEFINED
;	R3 =  UNDEFINED
;-

DIRECT::MOV	R1,-(SP)	;SAVE R1
	MOV	CRTYPE(R5),R1	;GET THE SCOPE TYPE
	MOV	R0,-(SP)	;COPY DESIRED LINE NUMBER (ROW)
	SUB	PRELIN+RWSIZE(R5),(SP) ; AND FIND # LINES (ROWS) TO MOVE
	BEQ	40$		;NONE, LINE (ROW) IS ALREADY CORRECT
	CMP	(SP),#1		;SOME, ARE WE ONLY GOING TO THE NEXT LINE?
	BNE	10$		;NOPE, WE MUST GO FURTHER THAN THAT...
	TST	R2		;ARE WE GOING TO THE NEXT LINE'S FIRST COLUMN?
	BEQ	20$		;YES, A SIMPLE <LF><CR> WILL DO THAT
10$:	CMP	R2,PRECOL+RWSIZE(R5) ;IS COLUMN NUMBER ALREADY CORRECT?
	BNE	90$		;NOPE, DO DIRECT CURSOR ADDRESSING
	MOV	#180$,R3	;SET SEQUENCE FOR CURSOR DOWN (& UP)
	TST	(SP)		;CHECK THAT MOVEMENT DIRECTION
	BR	60$		; AND GO USE IT

20$:	MOV	#012,R0		;SET CHARACTER TO <LF>
	JSR	PC,TYPEBF	; AND GO OUTPUT IT
30$:	TST	(SP)+		;JUNK THAT MOVEMENT AMOUNT
	MOV	#015-40,R0	;SET FINAL CHARACTER TO <CR> (LESS 40)
	BR	110$		; AND GO EXIT OUTPUTTING FINAL

40$:	TST	R1		;CHECK FOR VT52 (0.) SCOPE TYPE
	BNE	50$		;NOT A VT52
	MOV	#24.,R0		;THIS IS TO HELP STOP VT52 FROM FLICKER...
50$:	MOV	#190$,R3	;SET SEQUENCE FOR CURSOR RIGHT (& LEFT)
	MOV	R2,(SP)		;COPY DESIRED COLUMN NUMBER
	BEQ	30$		;GOING TO FIRST COLUMN, TREAT SPECIALLY
	SUB	PRECOL+RWSIZE(R5),(SP) ;ELSE FIND # COLUMNS TO MOVE
60$:	BPL	70$		;WE NEED TO MOVE THE CURSOR DOWN -OR- RIGHT
	NEG	(SP)		;CORRECT FOR A POSITIVE MOVEMENT AMOUNT
	ADD	#CRTMAX+2,R3	; AND CHANGE TO CURSOR UP -OR- LEFT
70$:	CMP	(SP),200$(R1)	;WITHIN THE MAXIMUM RANGE?
	BHIS	90$		;NOPE, DO DIRECT CURSOR ADDRESSING
	MOV	(SP)+,R0	;YEP, PUT THE COUNT INTO A REGISTER
	TST	210$(R1)	;ANSI MODE?
	BNE	130$		;YES, DO DIFFERENTLY
80$:	JSR	PC,DOTYPE	;DO 1 CURSOR DOWN/UP -OR- RIGHT/LEFT
	SOB	R0,80$		; AND LOOP...
	MOV	(SP)+,R1	;RESTORE R1
	RTS	PC		; AND EXIT

90$:	TST	(SP)+		;JUNK THAT MOVEMENT AMOUNT
	MOV	#220$,R3	;SET SEQUENCE FOR DIRECT CURSOR ADDRESSING
	JSR	PC,DOTYPE	; AND START DIRECT CURSOR ADDRESSING
	TST	210$(R1)	;ANSI MODE?
	BNE	140$		;YES, DO DIFFERENTLY
	JSR	PC,120$		;NO, ADJUST AND OUTPUT LINE NUMBER (ROW)
	CMP	R1,#6.		;VT05 (6.) NEEDING FILL?
	BNE	100$		;NOPE
	MOV	#230$,R3	;YEP, SET FILLER SEQUENCE
	JSR	PC,DOTYPE	; AND GO DO IT
100$:	MOV	R2,R0		;NOW SET COLUMN NUMBER
110$:	MOV	(SP)+,R1	;RESTORE R1
120$:	ADD	#40,R0		;ADJUST LINE (ROW) OR COLUMN NUMBER
	JMP	TYPEBF		;OUTPUT CHARACTER, THEN EXIT

130$:	ADD	R1,R3		;INDEX BY THE SCOPE TYPE
	MOV	(R3),-(SP)	; AND STACK THE FINAL CHARACTER (LESS 40)
	MOV	#220$,R3	;SET START OF MOVE SEQUENCE
	JSR	PC,DOTYPE	; AND GO DO IT
	MOV	R0,R1		;COPY THE MOVE COUNT
	DEC	R1		; MAKING IT 0 BASED
	BR	160$		;NOW GO DO IT

140$:	MOV	210$(R1),-(SP)	;SET FINAL CHARACTER (LESS 40)
	MOV	R0,R1		;COPY THE LINE NUMBER (ROW)
	BEQ	150$		;NO NEED FOR OUTPUT IF WOULD BE "1"
	JSR	PC,DIGITS	;ELSE OUTPUT AS ASCII DIGITS
150$:	MOV	#';,R0		;SET THE SEPERATOR
	JSR	PC,TYPEBF	; AND OUTPUT IT
	MOV	R2,R1		;COPY THE COLUMN NUMBER
160$:	BEQ	170$		;NO NEED FOR OUTPUT IF WOULD BE "1"
	JSR	PC,DIGITS	;ELSE OUTPUT AS ASCII DIGITS
170$:	MOV	(SP)+,R0	;SET THE FINAL CHARACTER (LESS 40)
	BR	110$		; AND GO EXIT OUTPUTTING FINAL

180$:	CRTTBL	<240$,240$,'B-40,VT05LF,'B-40,'B-40> ;CURSOR DOWN
	CRTTBL	<250$,250$,'A-40,260$,  'A-40,'A-40> ;CURSOR UP

190$:	CRTTBL	<270$,270$,'C-40,280$,'C-40,'C-40> ;CURSOR RIGHT
	CRTTBL	<290$,290$,'D-40,300$,'D-40,'D-40> ;CURSOR LEFT

200$:	.WORD	<2+1+0+1>/2	;<ESC><Y><L><C> VS. N*(<ESC><B/A/C/D>)
	.WORD	<2+1+0+1>/2	;<ESC><Y><L><C> VS. N*(<ESC><B/A/C/D>)
	.WORD	-1		;<ESC><[><L><;><C><H> VS. <ESC><[><N><B/A/C/D>
	.WORD	<1+1+4+1>/1	;<^N><L><0><0><0><0><C> VS. N*(<^X/BS>)
	.WORD	-1		;<ESC><[><L><;><C><H> VS. <ESC><[><N><B/A/C/D>
	.WORD	-1		;<ESC><[><L><;><C><H> VS. <ESC><[><N><B/A/C/D>
.IIF	NE	.-200$-CRTMAX-2, .ERROR ;INCORRECT NUMBER OF TABLE ENTRIES

210$:	CRTTBL	<0,   0,   'H-40,0,   'H-40,'H-40> ;ANSI MODE 'DCA' FINAL (-40)

220$:	CRTTBL	<310$,310$, ANSI,320$, ANSI, ANSI> ;START 'DCA' SEQUENCE

230$:	CRTTBL	<NULL,NULL,NULL,FILL4,NULL,NULL> ;FILL AS REQUIRED

240$:	.BYTE	033,'B		;VT52 & VT100(VT52) => <ESC><B>
	.BYTE	200

250$:	.BYTE	033,'A		;VT52 & VT100(VT52) => <ESC><A>
	.BYTE	200

260$:	.BYTE	032,		;VT05 => <CTRL/Z>
	.BYTE	000,000,000,000	; & 4 FILL'S
	.BYTE	200

270$:	.BYTE	033,'C		;VT52 & VT100(VT52) => <ESC><C>
	.BYTE	200

280$:	.BYTE	030		;VT05 => <CTRL/X>
	.BYTE	200

290$:	.BYTE	033,'D		;VT52 & VT100(VT52) => <ESC><D>
	.BYTE	200

300$:	.BYTE	010		;VT05 => <BS>
	.BYTE	200

310$:	.BYTE	033,'Y		;VT52 & VT100(VT52) => <ESC><Y>
	.BYTE	200

320$:	.BYTE	016		;VT05 => <CTRL/N>
	.BYTE	200

ANSI:	.BYTE	033,'[		;VT100(ANSI), VT102, & VK100 => <ESC><[>
	.BYTE	200

	.EVEN

.IF	NE	SCROLL

;+
; SETSCR - SET SCROLLING REGION.
;
;	R1 = STARTING LINE NUMBER (ROW) OF SCROLLING REGION, 0 BASED
;	R2 = SIZE OF SCROLLING REGION
;
;	JSR	PC,SETSCR
;
;	R0 =  UNDEFINED
;	R1 =  UNDEFINED
;	R2 =  UNDEFINED
;	R3 =  UNDEFINED
;-

SETSCR::MOV	#10$,R3		;SET SEQUENCE TO START THE OPERATION
	JSR	PC,DOTYPE	; AND GO DO IT
	ADD	R1,R2		;CALCULATE THE ENDING SCROLLED LINE (ROW) +1
	JSR	PC,DIGITS	;EMIT THE STARTING LINE (ROW) AS DIGITS
	MOV	#';,R0		;SET THE ";" SEPARATOR
	JSR	PC,TYPEBF	; AND OUTPUT IT
	MOV	R2,R1		;SET THE ENDING SCROLLED LINE (ROW) +1
	DEC	R1		; THEN CORRECT IT
	JSR	PC,DIGITS	;EMIT ENDING LINE (ROW) AS DIGITS
	MOV	#20$,R3		;SET SEQUENCE TO END THE OPERATION
	JSR	PC,DOTYPE	; AND GO DO IT
	JMP	SCRHOM		;EXIT BY GOING TO HOME...

10$:	CRTTBL	<NULL,NULL,ANSI,NULL,ANSI,NULL> ;SET SCROLLING SEQUENCE START

20$:	CRTTBL	<NULL,NULL, 30$,NULL, 30$,NULL> ;SET SCROLLING SEQUENCE END

30$:	.BYTE	'R+40		;END THE ANSI SCROLLING REGION SEQUENCE
	.BYTE	200

	.EVEN

.ENDC	;NE	SCROLL

.IF	EQ	I$$DIV

DIVR0:	MOV	R0,-(SP)	;SAVE DIVISOR ON THE STACK
	MOV	#-1,R0		;PRE-SET BIASED RESULT
10$:	INC	R0		;COUNT 1 MORE IN RESULT
	SUB	(SP),R1		; AND DO TRIAL SUBTRACT FROM DIVIDEND
	BHIS	10$		;NO UNDERFLOW YET...
	ADD	(SP)+,R1	;UNDERFLOW, CORRECT REMAINDER
	RTS	PC		; AND EXIT

.ENDC	;EQ	I$$DIV

.ENDC	;NE	WATCH

.IF	NE	IMMEDC

.SBTTL	NECESSARY SUBROUTINE FOR IMMEDIATE MODE COMMAND SUPPORT

.PSECT	TECOLS,RO,I,GBL,REL,OVR

TECOLS:	TST	QPNTR(R5)	;IS THIS THE FIRST INPUT REQUEST?
	BNE	10$		;NOPE, CAN'T BE IMMEDIATE MODE COMMAND
	BIT	#ED$IMD,EDIT(R5) ;ARE IMMEDIATE MODE COMMANDS ALLOWED?
	BEQ	10$		;NOPE, QUIT RIGHT NOW
	TST	INDIR(R5)	;AN INDIRECT COMMAND FILE ACTIVE?
	BNE	10$		;YEP, NO IMMEDIATE COMMANDS WANTED HERE
	MOV	QZ(R5),-(SP)	;GET CURRENT Q-REG ACTIVE STORAGE SIZE
	ADD	#20.,(SP)	; AND ADD IN A FUDGE FACTOR
	CMP	(SP)+,QMAX(R5)	;IS ENOUGH SPACE FREE TO PLAY WITH?
	BHIS	10$		;NOT ENOUGH SPACE, DON'T TRY FOR AN IMMEDIATE
	MOV	#20$,-(SP)	;THERE'S ENOUGH SPACE, CHECK FOR IMMEDIATES
10$:	JMP	LISTEN		;GO CALL THE REAL 'LISTEN' ROUTINE

20$:	JSR	PC,DECODE	;GO POSSIBLY DECODE A SEQUENCE
	BCS	60$		;NO SEQUENCE WAS DECODED...
	MOV	R0,-(SP)	;SAVE THE SEQUENCE FINAL CODE/VALUE
	MOV	R1,-(SP)	;SAVE THE SEQUENCE TYPE CODE
	BIT	#ET$CRT,ETYPE(R5) ;SCOPE TYPE TERMINAL?
	BEQ	30$		;NO
	JSR	PC,DELLIN	;YES, ERASE TECO'S PROMPT
	MOV	#012,R0		;SET A "DELETED" CHARACTER OF <LF>
	JSR	PC,DELCHR	; TO MOVE THE CURSOR UP A LINE
30$:	CLR	ERRPOS(R5)	;NO ERROR POSITION IF STORING
	CLR	QLCMD(R5)	;NO LAST COMMAND IF STORING ANYTHING
	MOV	QZ(R5),R1	;GET RELATIVE PLACE TO STORE CHARACTERS
	ADD	QRSTOR(R5),R1	; AND MAKE IT ABSOLUTE
	MOV	#70$,R2		;GET POINTER TO THE COMMAND STRING LAYOUT
40$:	INC	QZ(R5)		;INDICATE 1 MORE IN COMMAND
	INC	QPNTR(R5)	; Q-REGISTER
	MOVB	(R2)+,(R1)+	;STORE NEXT COMMAND STRING CHARACTER
	BNE	50$		;IT'S A REGULAR CHARACTER
	MOVB	(SP)+,-1(R1)	;SET TYPE CODE FIRST, CHARACTER CODE SECOND
50$:	TSTB	(R2)		;JUST STORED THE FINAL <ESCAPE>?
	BPL	40$		;NOPE, LOOP...
	MOVB	-(R1),R0	;YEP, SET TO RETURN WITH AN <ESCAPE>
	MOV	R0,TEMP(R5)	;SAVE CHARACTER LAST STORED (THE <ESCAPE>)
60$:	RTS	PC		;RETURN

70$:	.BYTE	'^&37, 0, ',, '^&37, 0, 'M, 'A, 033, -1 ;PROTOTYPE COMMAND
	.EVEN

.SBTTL	NECESSARY SUBROUTINE FOR :^T COMMAND SUPPORT

.PSECT	TECOLT,RO,I,GBL,REL,OVR

TECOLT:	JSR	PC,TLISTN	;GET THE FIRST CHARACTER
	CLR	R1		;SET CODE 0 FOR NORMAL CHARACTER
	BIT	R0,#^C<237>	;A CONTROL CHARACTER?
	BNE	10$		;NOPE, GO EXIT WITH CODE 0
	INC	R1		;SET CODE 1 FOR CONTROL CHARACTER
	CMP	R0,#015		;IS IT <CR>?
	BEQ	20$		;YES, GO READ THE <LF> AFTER THE <CR>
	JSR	PC,DECODE	;GO POSSIBLY DECODE A SEQUENCE
	BCS	10$		;NO SEQUENCE DECODED...
	CMPB	(R1)+,(R1)+	;BIAS THE SEQUENCE TYPE CODE BY TWO
10$:	RTS	PC		;EXIT

20$:	JSR	PC,TLISTN	;READ THE <LF> AFTER THE <CR>
	MOV	#015,R0		;RESTORE RETURNED CODE AS <CR>
	RTS	PC		; AND EXIT

;+
; DECODE - DECODE ESCAPE/SS3/CSI SEQUENCE IF NEEDED.
;
;	R0 =  ORIGINAL CHARACTER (<ESCAPE>, <SS3>, OR <CSI> => DECODE)
;
;	JSR	PC,DECODE
;
; IF NO DECODE (NOT <ESCAPE>, <SS3>, OR <CSI>) THEN
;
;	C-BIT = 1
;	R0 =  ORIGINAL CHARACTER
;
; IF DECODED (<ESCAPE>, <SS3>, OR <CSI>) THEN
;
;	C-BIT = 0
;	R0 =  SEQUENCE FINAL CODE/VALUE
;	R1 =  SEQUENCE TYPE CODE:
;		0 => <ESCAPE><CTRL-CHAR>
;		1 => <ESCAPE><CHAR>
;		     <ESCAPE><O><UC-CHAR>
;		     <SS3><UC-CHAR>
;		     <ESCAPE><[><CHAR>
;		     <CSI><CHAR>
;		2 => <ESCAPE><?><CHAR>
;		     <ESCAPE><O><LC-CHAR>
;		     <SS3><LC-CHAR>
;		3 => <ESCAPE><[><DIGIT(S)><TILDE>
;		     <CSI><DIGIT(S)><TILDE>
;	R2 =  UNDEFINED
;-

DECODE:	CMP	R0,#033		;IS IT <ESCAPE>?
	BEQ	10$		;YES, SO GO DECODE
	CMPB	R0,#217		;IS IT <SS3>?
	BEQ	10$		;YES, SO GO DECODE
	CMPB	R0,#233		;IS IT <CSI>?
	BNE	80$		;NONE OF THE ABOVE, GO EXIT C=1

10$:	MOV	ETYPE(R5),-(SP)	;SAVE ORIGINAL "ET" FLAG
	BIS	#ET$CC!ET$LC,ETYPE(R5) ;CONTROL/C TRAP, ENABLE LOWER CASE
	BIC	#ET$CKE,ETYPE(R5) ;ALWAYS STALL
	CLR	R1		;SET CODE FOR <ESCAPE><CTRL-CHAR> (0)
	TSTB	R0		;WAS INITIAL CHARACTER <SS3> OR <CSI>?
	BMI	90$		;YEP, DO SPECIAL PROCESSING...
	JSR	PC,TLISTN	;READ THE NEXT CHARACTER
	BIT	R0,#^C<237>	;A CONTROL CHARACTER?
	BEQ	60$		;YEP, THAT'S CODE 0
	INC	R1		;NOPE, SET CODE FOR <ESCAPE><CHAR> (1)
	CMP	R0,#'[		;IS IT <ESCAPE><[><CHAR>?
	BEQ	100$		;YES, WE MUST DO FURTHER CHECKING...
	CMP	R0,#'?		;IS IT <ESCAPE><?><CHAR>?
	BEQ	30$		;YES, THAT'S CODE 2 ON THE NEXT CHARACTER
	CMP	R0,#'O		;IS IT <ESCAPE><O><CHAR>?
	BNE	50$		;NONE OF THE ABOVE, IT'S CODE 1
20$:	JSR	PC,TLISTN	;WE NEED THE NEXT CHARACTER AT THIS POINT
	CMP	R0,#'A		;IS IT UPPER CASE ALPHABETIC?
	BLO	40$		;NOPE, USE CODE 2
	CMP	R0,#'Z		;REALLY UPPER CASE ALPHABETIC?
	BHI	40$		;NOPE, USE CODE 2
	BR	50$		;YEP, IT'S CODE 1

30$:	JSR	PC,TLISTN	;READ THE FINAL CHARACTER
40$:	INC	R1		;SET CODE FOR <ESCAPE><?><CHAR> (2)
50$:	BIC	#^C<37>,R0	;TRIM CHARACTER TO 5 BITS
60$:	TST	ETYPE(R5)	;IS CONTROL/C TRAP STILL ON?
	BMI	70$		;YES
;.IIF	NE	ET$CC-100000, .ERROR ;THE ABOVE WON'T WORK
	BIC	#ET$CC,(SP)	;NO, ENSURE IT STAYS OFF
70$:	BIC	#^C<ET$CC!ET$CKE!ET$LC>,(SP) ;TRIM SAVED "ETYPE"
	BIC	#ET$CC!ET$CKE!ET$LC,ETYPE(R5) ;TURN OFF OUR BITS
	BIS	(SP)+,ETYPE(R5)	; THEN RESTORE ORIGINAL "ETYPE"
	TST	(PC)+		;SET C=0 FOR DECODED SEQUENCE
80$:	SEC			;SET C=1 FOR NO DECODE
	RTS	PC		;EXIT

90$:	INC	R1		;SET CODE FOR <ESCAPE><CHAR> (1)
	CMPB	R0,#217		;WAS INITIAL CHARACTER <SS3>?
	BEQ	20$		;YEP, GO CHECK THE NEXT CHARACTER...
100$:	JSR	PC,TLISTN	;GET CHARACTER FOLLOWING <ESCAPE><[>
	JSR	PC,120$		;CHECK FOR DIGIT (0-9) RANGE
	BHI	50$		;NOT A DIGIT, IT'S CODE 1
	CLR	R1		;ELSE ZERO OUR SEQUENCE VALUE
110$:	MOV	R1,R0		;SAVE OLD VALUE *1
	ASL	R1		;NOW HAVE OLD VALUE *2
	ASL	R1		; THEN *4
	ADD	R0,R1		;FORM OLD VALUE *5
	ASL	R1		;NOW OLD VALUE *10.
	ADD	R2,R1		;ADD NEW DIGIT TO OLD VALUE
	JSR	PC,TLISTN	;GET THE NEXT CHARACTER
	JSR	PC,120$		;CHECK FOR STILL DIGIT (0-9) RANGE
	BLOS	110$		;A DIGIT, LOOP...
	MOV	R1,R0		;ELSE MOVE SEQUENCE VALUE TO HERE
	MOV	#3,R1		;CODE FOR <ESCAPE><[><DIGIT(S)><TILDE> (3)
	BR	60$		;GO EXIT

120$:	MOV	R0,R2		;COPY THE CHARACTER
	SUB	#'0,R2		; AND CONVERT (POSSIBLE) DIGIT TO BINARY
	CMP	R2,#9.		;COMPARE AGAINST HIGHEST VALID BINARY DIGIT
	RTS	PC		; AND EXIT W/ CC'S SET ('BHI' => NON-DIGIT)

.ENDC	;NE	IMMEDC

.END

