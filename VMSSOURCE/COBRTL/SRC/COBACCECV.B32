%TITLE 'COB$ACCECV - ACCEPT Conversion routines'
MODULE COB$ACCECV (			!
		   IDENT = '1-001'	! File: COBACCECV.B32 EDIT:LGB1001
				   ) =
BEGIN
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY:  COBOL SUPPORT
!
! ABSTRACT:
!
!	Supports the COBOL ACCEPT statement.
!
! ENVIRONMENT:  VAX-11 User Mode
!
! AUTHOR: Linda Baillie, CREATION DATE: 7-FEB-84
!
! MODIFIED BY:
!
! 1-001	- Original.  LGB 7-FEB-84
!--

!
! PROLOGUE FILE
!
REQUIRE 'RTLIN:COBPROLOG' ;			! Switches, Psects, Include
						! files
!
! LINKAGES:
!
LINKAGE
	JSB_678 = JSB
		(REGISTER = 6, REGISTER = 7, REGISTER = 8):
		NOPRESERVE (2, 3, 4, 5, 6, 7, 8)
		NOTUSED (9, 10, 11),

	JSB_6789 = JSB
		(REGISTER = 6, REGISTER = 7, REGISTER = 8, REGISTER = 9):
		NOPRESERVE (2, 3, 4, 5, 6, 7, 8, 9)
		NOTUSED (10, 11);
!
! TABLE OF CONTENTS:
!
FORWARD ROUTINE
	COB$$ACC_CONVERT,			! Conversion routine
	COB$$NUMERIC_CONV,			! Convert to numeric text strings
	COB$$COMP_CONV, 			! Convert to Word, Longword, 
						! Quadword and Packed strings
	COB$$FLOAT_CONV,			! Convert to Floating and Double
						! Floating Point strings
	COB$$STRIP_BLANKS_SIGN,			! Strip blanks and sign from
						! input numeric string
	COB$$ZERO_FILL		:  NOVALUE,	! Initialize STRING_DEST with
						! zeroes
	COB$$VERIFY_FL_RANGE,			! Check that input for Floating
						! Point data items is within range
	COB$$SCAN_INPUT ;			! Scan input data

!
! EQUATED SYMBOLS
!
LITERAL
	V_DEC_PT = 64 ;				! Bit flag for 'DECIMAL POINT
						! IS COMMA'
!
! EXTERNAL REFERENCES:
!
EXTERNAL ROUTINE

	COB$CVTIL_R8: JSB_678,			! Convert CIT to long
	COB$CVTIP_R9: JSB_6789,			! Convert CIT to packed
	COB$CVTIQ_R8: JSB_678,			! Convert CIT to quad
	COB$CVTIW_R8: JSB_678,			! Convert CIT to word
	COB$CVTTI_R8: JSB_678,			! Convert text to CIT 
	LIB$STOP : NOVALUE,			! Signals fatal error
	STR$GET1_DX,				! Allocate a string
	STR$DUPL_CHAR,				! Duplicate character n times
	STR$FREE1_DX,				! Deallocate a string
	STR$COPY_R,				! Copy a string by ref
	COB$$FREE_STRINGS,			! Free local strings
	OTS$CVT_T_F,				! Convert Text to Floating point
	OTS$CVT_T_D ;				! Convert Text to Double Fl point

EXTERNAL LITERAL
	COB$_INVARG ;				! Invalid Argument(s)

%SBTTL 'COB$$ACC_CONVERT - Conversion'
GLOBAL ROUTINE COB$$ACC_CONVERT (STRING_DEST  :  REF $STR$DESCRIPTOR,
						! Final destination for input chars
			  FLAGS,		! Enhancement flag
			  DEFAULT      :  REF $STR$DESCRIPTOR,
						! Input default value
			  PUT_HERE     :  REF BLOCK [8, BYTE],
						! Contains input characters
			  CHARS_READ,		! # of input characters
			  YES_DEFAULT,		! =1 if DEFAULT was used
			  YES_SIGN		! =1 if sign should be included
		         )  =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Convert TEXT input string to specified VAX COBOL data type.
!	This routine selects the appropriate routine to convert the specified
!	data type.
!
! FORMAL PARAMETERS:
!
!
!	STRING_DEST.mt.ds   Address of descriptor to receive the read input.
!
!	FLAGS.rlu.v	Screen enhancement flag;
!
!	DEFAULT.rt.dx	Default source moved to destination descriptor
!			(STRING_DEST) in the event of null input.
!
!	PUT_HERE.rt.dx	Buffer to hold input characters.
!
!	CHARS_READ.rlu.v   Number of characters accepted as input.
!
!	YES_DEFAULT.rlu.v  Flag = 1 if DEFAULT used because of null input.
!
!	YES_SIGN.rlu.v	Flag = 1 if sign should be included in COMP or COMP3
!			data type.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	1 - Conversion Success
!	0 - Conversion Failure
!
! SIDE EFFECTS:
!
!	Signals COB$_INVARG if the syntax of the number is wrong,
!--

    BEGIN
	LOCAL
	    ERROR 	  :  INITIAL (0),	    	! = 1, Conversion error
	    PUT_HERE_BUF  :  REF VECTOR [1100, BYTE],   ! Temp for special case
							! Conversion check
	    CONV_OK	  :  INITIAL (0) ;		! Return Status

	    !+
	    !  This validity check does not apply to TEXT, FLOATING or 
	    !  DOUBLE FLOATING POINT data types.
	    !- 
	    IF ( .STRING_DEST [DSC$B_DTYPE] NEQ DSC$K_DTYPE_T AND
	         .STRING_DEST [DSC$B_DTYPE] NEQ DSC$K_DTYPE_F AND
	         .STRING_DEST [DSC$B_DTYPE] NEQ DSC$K_DTYPE_D )
	    THEN
		BEGIN					! Begin special case
		!+
		!  Looking for two special case conversion errors not caught
		!  in other conversion routines.
		!  Check for invalid value  '.-9' and '0000-1234'
		!  ('9-.' found in COB$$NUMERIC_CONV).
		!-

		IF .YES_DEFAULT				! Use local buffer for
		THEN					! convenience
		    PUT_HERE_BUF = .DEFAULT [DSC$A_POINTER]
		ELSE
		    PUT_HERE_BUF = .PUT_HERE [DSC$A_POINTER] ;

		INCR X FROM 0 TO .CHARS_READ - 1 DO
		    BEGIN
		    !+
		    !  Work through characters one at a time.
		    !-
		    SELECTONE .PUT_HERE_BUF [.X] OF
		    	SET

			[%C'0' TO %C'9'] :
			    0 ;				! Legal
			[%C' '] :
			    0 ;				! Legal

			[%C'-', %C'+'] :
			    IF .X NEQ 0 AND .X NEQ .CHARS_READ - 1
			    THEN
				!+
				! Looking for 0000-1234 case - a sign in middle
				! of digits.  Sign should be first or last
				! character.  Note: bbbb-1234 is legal.
				!-
				IF (( .PUT_HERE_BUF [.X-1] GEQ %C'0'  AND
				      .PUT_HERE_BUF [.X-1] LEQ %C'9' ) AND
				    ( .PUT_HERE_BUF [.X+1] GEQ %C'0'  AND
				      .PUT_HERE_BUF [.X+1] LEQ %C'9' ))
				THEN
				    BEGIN
				    ERROR = 1 ;
				    EXITLOOP ;
				    END ;

			[%C'.', %C','] :
			    BEGIN
			    IF .X NEQ .CHARS_READ - 1
			    THEN
				!+
				! Looking for .-9 case - a sign separating a
				! decimal point and digit.  -.9 and .9- are
				! acceptable.  (9-. caught by COB$$NUMERIC_CONV)
				!-
				IF .PUT_HERE_BUF [.X+1] EQL %C'-'  OR
				   .PUT_HERE_BUF [.X+1] EQL %C' '
				THEN
				    BEGIN
				    ERROR = 1 ;
				    EXITLOOP ;
				    END ;
			    END ;

			[ OTHERWISE ]:
			    0;			       ! Let conversion routines
						       ! handle other errors
			TES ;
		    END ;
		END ;					! End special case

		IF .ERROR
		THEN
		    CONV_OK = 0				! Return failure status
		ELSE
		!+
		! Continue with rest of conversion check.  Call appropriate
		! routine (determined by data type).
		!-
		CASE .STRING_DEST [DSC$B_DTYPE] FROM DSC$K_DTYPE_WU TO
								DSC$K_DTYPE_P OF
		    SET
		
		    [DSC$K_DTYPE_NU,			! Numeric string
		     DSC$K_DTYPE_NL, DSC$K_DTYPE_NR,
		     DSC$K_DTYPE_NLO, DSC$K_DTYPE_NRO] :
		
			BEGIN
			CONV_OK = COB$$NUMERIC_CONV (( IF .YES_DEFAULT
					        THEN .DEFAULT
					        ELSE .PUT_HERE ), 
				.STRING_DEST, .CHARS_READ, .FLAGS ) ;
			END ;

		    [DSC$K_DTYPE_W, DSC$K_DTYPE_WU, 	! Word
		     DSC$K_DTYPE_L, DSC$K_DTYPE_LU, 	! Longword
		     DSC$K_DTYPE_Q, DSC$K_DTYPE_QU, 	! Quadword
		     DSC$K_DTYPE_P] :			! Packed Decimal

			BEGIN
			CONV_OK = COB$$COMP_CONV ( .STRING_DEST,
						   .FLAGS, .DEFAULT, .PUT_HERE,
						   .CHARS_READ, .YES_DEFAULT,
						   .YES_SIGN  ) ;
			END ;

		    [DSC$K_DTYPE_F, DSC$K_DTYPE_D] :	! Floating and Double
							! Floating Point
			BEGIN
			!+
			!  Since DEFAULT is Read-only, copy it to PUT_HERE if
			!  it was used, just in case it is necessary to WRITE
			!  a DOT to override a COMMA in routine COB$$FLOAT_CONV.
			!-

			IF .YES_DEFAULT
			THEN
			    CH$MOVE ( .CHARS_READ, .DEFAULT [DSC$A_POINTER],
						.PUT_HERE [DSC$A_POINTER] ) ;

			CONV_OK = COB$$FLOAT_CONV ( .STRING_DEST, .FLAGS,
						    .PUT_HERE, .CHARS_READ ) ;
			END ;

		    [DSC$K_DTYPE_T] :			! Text
	
			!+
			!  Copy ACCEPTed data to STRING_DEST.  If more chars
			!  are ACCEPTed than STRING_DEST[DSC$W_LENGTH] can
			!  handle, accept only the leftmost characters and
			!  ignore the extra characters.
			!  Use STR$COPY because it BLANK fills.
			!-

			BEGIN
			    LOCAL
				COPY_NUM ;

			IF .CHARS_READ LSS .STRING_DEST[DSC$W_LENGTH]
			THEN
			    COPY_NUM = .CHARS_READ
			ELSE
			    COPY_NUM = .STRING_DEST[DSC$W_LENGTH] ;

			STR$COPY_R ( .STRING_DEST, COPY_NUM,
					(IF .YES_DEFAULT
					THEN .DEFAULT [DSC$A_POINTER]
					ELSE .PUT_HERE [DSC$A_POINTER] )) ;
			CONV_OK = 1 ;			! no need to conv TEXT
			END ;

		    [INRANGE, OUTRANGE] :

			LIB$STOP ( COB$_INVARG ) ;

		    TES ;

    RETURN .CONV_OK ;
    END ;					!  End of COB$$ACC_CONVERT


%SBTTL 'COB$$NUMERIC_CONV - Convert to numeric string'
ROUTINE COB$$NUMERIC_CONV (			! Scan a number and divide it up
	ARG_DESC	:  REF BLOCK [8, BYTE],	! The number to scan
	STRING_DEST	:  REF BLOCK [12,BYTE], ! Final resting place of input
	CHARS_READ,				! Number of characters read
	FLAGS ) =				! Needed for DECIMAL POINT IS COMMA

!++
! FUNCTIONAL DESCRIPTION:
!
!	Convert a TEXT input string to the appropriate VAX COBOL Text
!	Numeric data type.  Pull off decimal point, pull off sign then
!	place it in the correct position for internal representation.
!	Do nothing about errors in this routine, return control to COB$ACC_SCR
!	via COB$$ACC_CONVERT.
!
! FORMAL PARAMETERS:
!
!	ARG_DESC.rt.dx	    The number to parse
!
!	STRING_DEST.mt.ds   Address of descriptor to receive the read input.
!
!	CHARS_READ.rlu.v    Number of characters accepted as input.
!
!	FLAGS.rlu.v	    Screen enhancement flag;
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	1 = Conversion Success
!	0 = Conversion Failure
!
! SIDE EFFECTS:
!
!	Signals COB$_INVARG if the syntax of the number is wrong,
!--

    BEGIN

    LOCAL
	SIGN_VAL : BYTE,			! Holds + or - sign
	BUF_DESC : BLOCK [8, BYTE] VOLATILE,	! Temporary buffer
	SIGN_SEEN   :  INITIAL (0),		! 1 = we have seen a + or -
	DIGIT_SEEN  :  INITIAL (0),		! 1 = we have seen at least one digit
	DOT_SEEN    :  INITIAL (0),		! 1 = we have seen a decimal point
	BLANKS_SEEN :  INITIAL (0),		! 1 = we have seen trailing blanks
	ZERO_SEEN   :  INITIAL (0),		! 1 = zero seen
	PUTTER	    :  INITIAL (0),		! Counts position in the output buffer
	BUF : REF VECTOR [1100, BYTE],		! Addresses result
	ARG : REF VECTOR [1100, BYTE],		! Addresses source
	ARG_LEN,				! Length of the source
	NUM_DIGITS  :  INITIAL (0),		! Number of digits in ARG_DESC
	LEFT_DEC    :  INITIAL (0),		! Number of digits to left of dec pt
	RIGHT_DEC   :  INITIAL (0),		! Number of digits to right of dec pt
	LEADING_ZEROES: INITIAL (0),		! Counter of leading zeroes
	OK_LEFT ;				! Correct number of digits allowed	
						! to left of decimal point

    BIND
	ZERO = UPLIT ('0');

!+
! Enable a handler to free the local string in case of an error.
!-
    ENABLE
	COB$$FREE_STRINGS (BUF_DESC);

!+
! Allocate enough space to hold the digits.  It is convenient to
! allocate before scanning, so we may allocate a little too much,
! but the space will be freed before we return.
!-
    BUF_DESC [DSC$W_LENGTH] = 0;
    BUF_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_NU;
    BUF_DESC [DSC$B_CLASS] = DSC$K_CLASS_D;
    BUF_DESC [DSC$A_POINTER] = 0;
    ARG_LEN = .ARG_DESC [DSC$W_LENGTH];
    STR$GET1_DX (%REF (.ARG_LEN + 20), BUF_DESC);
!+
!  Set pointers.
!-
    BUF = .BUF_DESC [DSC$A_POINTER];
    ARG = .ARG_DESC [DSC$A_POINTER];
    SIGN_VAL = %C'+';

!+
!  Scan the input number, put result in BUF.
!-

    IF NOT ( COB$$SCAN_INPUT ( .ARG_DESC, .CHARS_READ, .FLAGS, BUF_DESC,
	      LEFT_DEC, NUM_DIGITS, SIGN_VAL, PUTTER, LEADING_ZEROES, SIGN_SEEN,
			DIGIT_SEEN, DOT_SEEN, ZERO_SEEN, BLANKS_SEEN ) )
    THEN
	RETURN 0 ;

!+
!  Now ensure that a number of the form 1.0000 has the trailing
!  zeroes stripped off.
!-
    IF .DOT_SEEN 
    THEN
	BEGIN
	  LOCAL
	    X;

	X = .PUTTER - 1;
	IF .X NEQ 0
	THEN
	    BEGIN
	    WHILE .BUF[.X] EQL %C'0' DO
		BEGIN					! Throw out trailing
		NUM_DIGITS = .NUM_DIGITS - 1;		! zeroes after dec pt.
		IF .X EQL 0
	        THEN
		    BEGIN				! Get here if all digits
	            DIGIT_SEEN = 0;			! after decimal point
		    DOT_SEEN = 0;			! are zeroes, and zeroes
		    EXITLOOP;				! are the only digits in
		    END;				! the string (eg. .0000)
		X = .X - 1;
	      END;
	    END;
	END;

!+
!  NOTE: Call to COB$$ZERO_FILL was originally done here, however because
!	 VAX RPG wants an illegal string returned in its original state,
!	 it was necessary to be more selective about where and when to 
!	 call COB$$ZERO_FILL.
!_

!+
! If there are no digits, or only leading zeros, take the number to
! be zero.  Don't be too gullible, however.
!-
    IF ( NOT .DIGIT_SEEN)
    THEN
	BEGIN

	IF (.SIGN_SEEN OR .DOT_SEEN OR .BLANKS_SEEN) AND (.ZERO_SEEN EQL 0)
	THEN RETURN 0 ;

	!+
	!  Fill STRING_DEST with zeroes
	!-

	COB$$ZERO_FILL ( .STRING_DEST ) ;
	RETURN 1 ;

	END

!+
!  Validate size of entered data, left and right of decimal point.
!  If everything is OK, copy the input string to STRING_DEST with
!  the sign set up correctly.
!  Return if DEFAULT is being converted (there will never be a decimal point
!  in the DEFAULT parameter)
!-
    ELSE
	BEGIN

	LOCAL
	    DEST_PTR ,					! Pointer where result will go in destination
	    DIGITS_IN_STRING ,				! Number of digits in destination string
	    DEST_LENGTH ,				! Destination length
	    LENGTH_DIFF ;				! Difference between number of digits 
							! to the left of the decimal point
							! in the number typed in and the dest

	LITERAL
	    POSOP = 16,					! Number to add to make overpunched +
	    NEGOP = 25,					! Number to add to make overpunched -
	    POSZEROP = 123,				! +0 overpunched
	    NEGZEROP = 125;				! -0 overpunched


	IF NOT (.DOT_SEEN)				! No dec pt. therefore
	THEN LEFT_DEC = .NUM_DIGITS ;			! all digits are left_dec
	RIGHT_DEC = .NUM_DIGITS - .LEFT_DEC ;

	DEST_LENGTH = .STRING_DEST [DSC$W_LENGTH];

	SELECTONE .STRING_DEST [DSC$B_CLASS] OF
	    SET

	    [ DSC$K_CLASS_S ] :

		BEGIN

		!+
		! If a decimal point was typed in, all the digits after it
		! MUST be zeroes.
		!-
		
		IF .RIGHT_DEC GTR 0
		THEN
		    INCR I FROM (.PUTTER - .RIGHT_DEC) TO .PUTTER DO
			IF .BUF[.I] NEQ %C'0' 
			THEN RETURN 0;
		
		!+
		! If the number of digits typed in is less than the number of
		! digits in the destination string, then a pointer must be
		! set up here so that the typed in digits get moved to the 
		! correct place in the destination.
		!-

		DIGITS_IN_STRING = 
			( IF (.STRING_DEST [DSC$B_DTYPE] EQL DSC$K_DTYPE_NL) OR
			     (.STRING_DEST [DSC$B_DTYPE] EQL DSC$K_DTYPE_NR)
			  THEN .DEST_LENGTH - 1
		  	  ELSE .DEST_LENGTH );
		IF .LEFT_DEC GTR .DIGITS_IN_STRING
		THEN RETURN 0;				! Data entered too bit

		STR$DUPL_CHAR (.STRING_DEST, DEST_LENGTH, ZERO);! Zero the destination
		LENGTH_DIFF = .DIGITS_IN_STRING - .LEFT_DEC;
		IF .LENGTH_DIFF GTR 0
		THEN
		    DEST_PTR = .STRING_DEST [DSC$A_POINTER] + .LENGTH_DIFF
		ELSE
		    DEST_PTR = .STRING_DEST [DSC$A_POINTER];

		END ;

	    [ DSC$K_CLASS_SD ] :

		BEGIN
		!+
		!  All code for "P" data types are in lowercase.
		!-

		LOCAL
		    ok_right,
		    LENGTH_DIFF2;			! Difference between number of digits
							! to the right of the decimal point
							! in the typed in number and the dest

		dest_length = .string_dest[dsc$b_digits];

		!+
		! This is checking for the P Picture of 99PP.			
		! If the scale is positive and the number of digits in the 	
		! number equal the scale factor, then simply copy the digits	
		! in BUF to the destination descriptor.				
		!-

		if .string_dest[dsc$b_scale] gtr 0
		then
		    begin
		
		    local
			tot_digits,
			diff;

		    if ((.right_dec gtr 0) or (.num_digits gtr (.string_dest[dsc$b_digits] + .string_dest[dsc$b_scale]))) 		! illogical case or -
		    then				! number too large
			return 0;			! re-prompt - error

		    if .num_digits leq .string_dest[dsc$b_scale]
		    then

		    !+
		    ! Zero out the destination field using the digits as the proper	
		    ! number of zero fill characters, rather than using the length	
		    ! as found in the descriptor, since class SD is a special case.	
		    !-
			begin
			str$dupl_char (.string_dest, dest_length, zero);
			return 1;			! answer is zero
			end ;

		    if .leading_zeroes neq 0
		    then
			begin

			diff = (.string_dest[dsc$b_digits]+.string_dest[dsc$b_scale]) - .num_digits;  
			dest_ptr = .string_dest[dsc$a_pointer]+.diff;

			end
		    else
			begin

			diff = .num_digits - .string_dest[dsc$b_scale];
			if .diff eql .string_dest[dsc$b_digits]
			then
			    dest_ptr = .string_dest[dsc$a_pointer]
			else
			    begin

			    tot_digits = (.string_dest[dsc$b_digits] + .string_dest[dsc$b_scale]) - .num_digits;
			    dest_ptr = .string_dest[dsc$a_pointer]+.tot_digits;

			    end;

			num_digits = .diff;

			end;

		    end
		else
		    begin

		    OK_LEFT = .STRING_DEST [DSC$B_DIGITS] + .STRING_DEST [DSC$B_SCALE] ;
	 	    if .ok_left lss 0
		    then 
			!+
			! Here we have a P Picture field of type PP99.		
			! We know this when OK_LEFT is less than zero.		
			! It requires some special casing.			
			!-
		    	begin

			local
 			    diff,
			    diff2,
			    ptr,
			    buf_ptr;
	
		     	if .left_dec gtr 0		! error no '.' entered
		      	then				! ring bell and reprompt
			    return 0;

		    	ok_left = 0;
		    	ok_right = abs(.string_dest[dsc$b_scale]);
		    	if .right_dec gtr .ok_right
		      	then
			    return 0;

			!+
			! This handles case where the number of digits 
			! entered is less than the absolute value of the 
			! scale factor, meaning that the number returned 
			! would have to be zero.  The first part of the
			! if statement takes care of the case where the 
			! number of digits entered equals the number of 
			! digits expected taking into account if the absolute 
			! value of the scale factor is equal to the number 
			! of digits entered to the right of the decimal point
			! thereby giving us a result of zero again.		
			!-
	
			diff = (abs(.string_dest[dsc$b_scale]) -
					.string_dest[dsc$b_digits]);	! Number of Placeholders in picture
			if ((.right_dec eql .string_dest[dsc$b_digits]) and
			(.right_dec eql .diff)) OR
			(.right_dec leq .diff)
			then
			    begin
			    str$dupl_char (.string_dest, dest_length, zero);
			    return 1;			! done - answer is zero
			    end ;

			buf_ptr = .buf_desc [dsc$a_pointer] + .diff;
			diff = .num_digits - .diff;	! Number of digits minus placeholders
			ch$move (.diff, .buf_ptr, .buf_desc[dsc$a_pointer]);
			diff2 = .string_dest[dsc$b_digits] - .diff; 	! Number of digits to zero fill
			ptr = .buf_desc[dsc$a_pointer] + .diff;
			incr i from 0 to .diff2 - 1 do
			    ch$move (1, zero, .ptr + .i);

			dest_ptr = .string_dest[dsc$a_pointer];
			num_digits = .string_dest[dsc$b_digits] ;	! should only reflect number of digit in picture

		    	end
		    else
		  	begin

			LENGTH_DIFF = .OK_LEFT - .LEFT_DEC;
			LENGTH_DIFF2 = (.STRING_DEST [DSC$B_DIGITS] - .OK_LEFT) - .RIGHT_DEC;
			IF ( .LENGTH_DIFF LSS 0) OR ( .LENGTH_DIFF2 LSS 0)
			THEN 	
			    RETURN 0 ;			! Data entered too big

			!+
			! If the number of digits to the left of the decimal 
			! point of the number typed in is less than what 
			! should be in the destination string, then a pointer 
			! must be set up here so that the typed in digits get 
			! moved to the correct place in the destination.
			!-
			IF .LENGTH_DIFF GTR 0
			THEN
		    	    DEST_PTR = .STRING_DEST [DSC$A_POINTER] + .LENGTH_DIFF
			ELSE
		    	    DEST_PTR = .STRING_DEST [DSC$A_POINTER];

			!+
			! If the number of digits to the right of the decimal 
			! point of the number typed in is less than what 
			! should be in the destination string, then the typed 
			! in number must be padded with trailing zeroes so that 
			! sign placement can be done correctly.
			!-
			IF .LENGTH_DIFF2 GTR 0
			THEN
			    BEGIN

			    LOCAL
				PTR;			! Pointer into input buffer
							!  past the digits that were typed in

	 	    	    PTR = .BUF_DESC [DSC$A_POINTER] + .NUM_DIGITS - 1;
		    	    NUM_DIGITS = .NUM_DIGITS + .LENGTH_DIFF2;

		    	    DO
				BEGIN

				LOCAL
				    PTR2;		! Loop pointer

				PTR2 = .PTR + .LENGTH_DIFF2;
				CH$MOVE (1, ZERO, .PTR2);
				LENGTH_DIFF2 = .LENGTH_DIFF2 - 1;

				END
			    UNTIL .LENGTH_DIFF2 EQL 0;

			    END;

		  	end;
		    end;
		END ;

	    [ OTHERWISE ] :
	
		LIB$STOP ( COB$_INVARG ) ;

	    TES ;

	!+
	!  Fill STRING_DEST with zeroes.
	!  If everything is OK, copy the input string to STRING_DEST with
	!  the sign set up correctly.
	!-

	COB$$ZERO_FILL ( .STRING_DEST ) ;

	CASE .STRING_DEST [DSC$B_DTYPE] FROM DSC$K_DTYPE_NU TO DSC$K_DTYPE_NRO
	    OF
	    SET

	    [DSC$K_DTYPE_NU]:				! Numeric unsigned
		!+
		!  Simply ignore a sign if it was part of the input
		!  string.
		!-
	    	CH$MOVE (.NUM_DIGITS, .BUF_DESC [DSC$A_POINTER], .DEST_PTR);
			
	    [DSC$K_DTYPE_NL]:				! Numeric left separate

		BEGIN
			
		CH$MOVE (1, SIGN_VAL, .STRING_DEST [DSC$A_POINTER]);
	    	CH$MOVE (.NUM_DIGITS, .BUF_DESC [DSC$A_POINTER], .DEST_PTR + 1);

		END;
			
	    [DSC$K_DTYPE_NR]:				! Numeric right separate

		BEGIN
			
		BUF [.NUM_DIGITS] = .SIGN_VAL;
	    	CH$MOVE (.NUM_DIGITS + 1, .BUF_DESC [DSC$A_POINTER], .DEST_PTR);

		END;
			
	    [DSC$K_DTYPE_NLO]:				! Numeric left overpunched

		BEGIN
		LOCAL
		    FIRST_TWO    : VECTOR [2, BYTE],    ! To be compared with
							! first two bytes of STRING_DEST
		    FIRST_DIGIT  :  BYTE ;		! First digit and overpunch sign

		FIRST_TWO [0] = %X'7B' ;		! Positive overpunched 0
		FIRST_TWO [1] = %X'30' ;		! Regular 0

		!+
		!  First byte of initial state STRING_DEST is always 7B,
		!  therefore have to look at first two bytes.
		!-
	
	    	CH$MOVE (.NUM_DIGITS, .BUF_DESC [DSC$A_POINTER], .DEST_PTR) ;
		IF CH$EQL (2, .STRING_DEST [DSC$A_POINTER], 2, FIRST_TWO )
	
		THEN
		    FIRST_DIGIT =
			( IF .SIGN_VAL EQL %C'+' 
			  THEN POSZEROP
			  ELSE NEGZEROP )
		ELSE
		    !+
		    !  Special treatment needed when .NUM_DIGITS is less
		    !  than total # STRING_DEST can hold.
		    !  For example :  S99V99 - input 3.00 ->
		    !  First two bytes of STRING_DEST now hold '7B' and '33',
		    !  but want POSZEROP not POSOP as POSOP will result in wrong
		    !  number 33.00.
		    !-
		    IF .NUM_DIGITS LSS .STRING_DEST [DSC$W_LENGTH]
		    THEN
			FIRST_DIGIT =
			    ( IF .SIGN_VAL EQL %C'+' 
				  THEN POSZEROP
				  ELSE NEGZEROP )
		    ELSE
			FIRST_DIGIT =
			    !+
			    !  Add whatever necessary to a regular hex number
			    !  to put it in overpunch format.  Have to special
			    !  case zero.
			    !-
			    ( IF .SIGN_VAL EQL %C'+' 
			      THEN 
				  IF .BUF [0] EQL %C'0'
				  THEN POSZEROP
				  ELSE .BUF [0] + POSOP
			      ELSE 
				  IF .BUF [0] EQL %C'0'
				  THEN NEGZEROP
				  ELSE .BUF [0] + NEGOP );

	    	CH$MOVE (1, FIRST_DIGIT, .STRING_DEST [DSC$A_POINTER] ) ;

		END;
			
	    [DSC$K_DTYPE_NRO]:				! Numeric right overpunched

		BEGIN
		!+
		!  Add whatever necessary to a regular hex number
		!  to put it in overpunch format.  Have to special
		!  case zero.
		!-
			
		IF .BUF [.NUM_DIGITS - 1] EQL %C'0'
		THEN
		    BUF [.NUM_DIGITS - 1] =
			( IF .SIGN_VAL EQL %C'+' 
			  THEN POSZEROP
			  ELSE NEGZEROP )
		ELSE
		    BUF [.NUM_DIGITS - 1] =
			( IF .SIGN_VAL EQL %C'+' 
			  THEN .BUF [.NUM_DIGITS - 1] + POSOP
			  ELSE .BUF [.NUM_DIGITS - 1] + NEGOP );

	    	CH$MOVE (.NUM_DIGITS, .BUF_DESC [DSC$A_POINTER], .DEST_PTR);

		END;

	    TES;		

	END ;

!+
! Free local string
!-
    STR$FREE1_DX (BUF_DESC);
    RETURN 1 ;
    END;					! end of COB$$NUMERIC_CONV

%SBTTL 'COB$$FLOAT_CONV - Convert to Floating Point'
ROUTINE COB$$FLOAT_CONV (STRING_DEST  :  REF $STR$DESCRIPTOR,
						! Final destination for input chars
			 FLAGS,			! Enhancement flag
			 PUT_HERE     :  REF BLOCK [8, BYTE],
			 			! Contains input characters
			 CHARS_READ		! # of input characters
		        ) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Convert TEXT input string to Floating or Double Floating Point.
!	Do nothing about errors in this routine, return control to calling
!	routine.
!
! FORMAL PARAMETERS:
!
!	STRING_DEST.mt.ds   Address of descriptor to receive the read input.
!
!	FLAGS.rlu.v	Screen enhancement flag;
!
!	PUT_HERE.rt.dx	Buffer to hold input characters.
!
!	CHARS_READ.rlu.v   Number of characters accepted as input.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	1 = Conversion Success
!	0 = Conversion Failure
!
! SIDE EFFECTS:
!
!	Signals COB$_INVARG if the syntax of the number is wrong,
!--

    BEGIN
	LOCAL
	    CONV_OK  :  INITIAL (0) ;			! Conversion flag
							! =0 error, =1 no error
    LABEL
	FLOAT_PROCESSOR ;

	FLOAT_PROCESSOR:
		    BEGIN
			LOCAL
			    TEMP_PUT_HERE   :  BLOCK [12,BYTE] VOLATILE ;
						! Temporary buffer with length
						! reflecting number of chars read
			LITERAL
			    ONLY_E_ALLOWED = 15 ;	! Bit 0 - blanks are ignored
							! Bit 1 - only E or e for exp
							! Bit 2 - underflow is an error
							! Bit 3 - do not round
			BIND
			    COMMA = UPLIT (','),
			    DOT = UPLIT ('.');

			!+
			! Pick appropriate conversion routine based on
			! data type.
			!-
			BIND ROUTINE CVTTX = (
				IF .STRING_DEST [DSC$B_DTYPE] EQL DSC$K_DTYPE_F
				THEN OTS$CVT_T_F
			
				ELSE IF .STRING_DEST [DSC$B_DTYPE] EQL DSC$K_DTYPE_D
				THEN OTS$CVT_T_D
				ELSE 0 );
			
			!+
			!  Make TEMP_PUT_HERE a fixed length descriptor -
			!  don't need STR$GET1_DX or STR$FREE1_DX.
			!-
			TEMP_PUT_HERE [DSC$W_LENGTH]  = .CHARS_READ ;
			TEMP_PUT_HERE [DSC$B_DTYPE]   = DSC$K_DTYPE_NL ;
			TEMP_PUT_HERE [DSC$B_CLASS]   = DSC$K_CLASS_S ;
			TEMP_PUT_HERE [DSC$A_POINTER] = .PUT_HERE [DSC$A_POINTER] ;

			!+
			! If DECIMAL POINT IS COMMA is set and a comma came in,
			! must change it to a decimal point before the convert.
			! OTS$ routines expect a decimal point.
			! Also must not allow a dec pt as input in that case.
			!-
			IF (.FLAGS AND V_DEC_PT) NEQ 0
			THEN
			    BEGIN

			    INCR PTR FROM 0 TO (.CHARS_READ - 1) DO
				BEGIN

				IF CH$EQL (1,.TEMP_PUT_HERE [DSC$A_POINTER] + .PTR,
					   1, DOT)
				THEN
				    BEGIN

				    CONV_OK = 0;	   ! Illegal, looking
				    LEAVE FLOAT_PROCESSOR; ! for a comma

				    END;

				IF CH$EQL (1, .TEMP_PUT_HERE [DSC$A_POINTER] + .PTR,
					   1, COMMA)
				THEN
				    CH$MOVE (1, DOT, .TEMP_PUT_HERE [DSC$A_POINTER] + .PTR);
				END;
			    END
			!+
			! If DECIMAL POINT IS COMMA is NOT set and a comma
			! came in, this is a conversion error
			!-
			ELSE
			    BEGIN

			    INCR PTR FROM 0 TO (.CHARS_READ - 1) DO
				BEGIN

				IF CH$EQL (1,.TEMP_PUT_HERE [DSC$A_POINTER] + .PTR,
					   1, COMMA)
				THEN
				    BEGIN

				    CONV_OK = 0;	   ! Illegal, looking
				    LEAVE FLOAT_PROCESSOR; ! for a decimal pt

				    END;
				END ;
			    END ;

			!+
			! Check that input data is not out of range.
			!-
			BEGIN
			    LOCAL
				MAX ;	! Maximum significant digits allowed
				
			MAX = (	IF .STRING_DEST [DSC$B_DTYPE] EQL DSC$K_DTYPE_F
				THEN 7			! Floating
				ELSE 16 ) ;		! Double Floating

			CONV_OK = COB$$VERIFY_FL_RANGE ( TEMP_PUT_HERE, .CHARS_READ,
									.MAX ) ;
			IF .CONV_OK
			THEN
			    BEGIN
			    !+
			    ! Convert to float or double.
			    !-
			    IF NOT ( CVTTX ( TEMP_PUT_HERE, 
					.STRING_DEST[DSC$A_POINTER], 
					0, 0, ONLY_E_ALLOWED ) )
			    THEN CONV_OK = 0		! Conversion error
			    ELSE
			        CONV_OK = 1 ;		! No error
			    END ;
			END ;
		    END ;

    RETURN .CONV_OK ;
    END ;						! End of COB$$FLOAT_CONV

%SBTTL 'COB$$COMP_CONV - Convert to COMP and COMP3'
ROUTINE COB$$COMP_CONV (STRING_DEST  :  REF $STR$DESCRIPTOR,
						! Final destination for input chars
			FLAGS,			! Enhancement flag
			DEFAULT	     :  REF $STR$DESCRIPTOR,
			PUT_HERE     :  REF BLOCK [8, BYTE],
						! Contains input characters
			CHARS_READ,		! # of input characters
			YES_DEFAULT,		! =1 if DEFAULT value is used
			YES_SIGN		! =1 if sign should be included
		       )  =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Convert TEXT input string to appropriate VAX COBOL COMP or COMP3
!	data type.
!	Do nothing about errors in this routine, return control to calling
!	routine.
!
! FORMAL PARAMETERS:
!
!	STRING_DEST.mt.ds   Address of descriptor to receive the read input.
!
!	FLAGS.rlu.v	Screen enhancement flag;
!
!	DEFAULT.rt.dx	Default source moved to destination descriptor
!			(STRING_DEST) in the event of null input.
!
!	PUT_HERE.rt.dx	Buffer to hold input characters.
!
!	CHARS_READ.rlu.v   Number of characters accepted as input.
!
!	YES_DEFAULT.rlu.v  Flag = 1 if DEFAULT used because of null input.
!
!	YES_SIGN.rlu.v	Flag = 1 if sign should be included in COMP or COMP3
!			data type.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	1 = Conversion Success
!	0 = Conversion Failure
!
! SIDE EFFECTS:
!
!	Signals COB$_INVARG if the syntax of the number is wrong,
!--

    BEGIN
	LOCAL
	    CONV_OK  :  INITIAL (0) ;			! Conversion flag,
							! =0 error, =1 no error
			BEGIN

			LOCAL
			    EXPONENT: INITIAL (0),	! Exponent for the CIT
			    I_VALUE: VECTOR[12, BYTE],	! COBOL intermediate temporary
			    SIGN: BYTE,			! Sign of the input string
			    SEND_CHARS_READ;		! Local to hold .CHARS_READ 
							
			!+
			!  COB$$STRIP_BLANKS_SIGN may change the value of
			!  SEND_CHARS_READ therefore it is important to send
			!  this local instead of CHARS_READ (which should NEVER
			!  be altered).
			!-
			SEND_CHARS_READ = .CHARS_READ ;

			!+
			! First must strip off leading and trailing blanks and
			! the sign because COB$CVTTI won't accept them.
			!-
			IF .YES_DEFAULT
			THEN
			    !+
			    !  This move must be done because STRIP routine
			    !  writes back into the 1st parameter and DEFAULT
			    !  is read-only.
			    !-
      			    CH$MOVE (.CHARS_READ, .DEFAULT [DSC$A_POINTER], 
					 .PUT_HERE [DSC$A_POINTER]);

			CONV_OK = COB$$STRIP_BLANKS_SIGN (.PUT_HERE, .STRING_DEST,
				       SEND_CHARS_READ, EXPONENT, SIGN, .FLAGS);
			IF .CONV_OK
			THEN
			    !+
			    ! Convert the stripped input string to CIT.
			    ! Must do convert to CIT, THEN to destination data 
			    ! type because these COBOL conversion routines take
			    ! into account the scale factor.
			    !-
	    		    CONV_OK = COB$CVTTI_R8 (.SEND_CHARS_READ,
				 .PUT_HERE [DSC$A_POINTER], I_VALUE);

			IF .CONV_OK
			THEN
			    BEGIN

			    LOCAL
				SCALE;

			    !+
			    ! Pick the appropriate conversion routine based
			    ! on data type.  Note that routines have the
			    ! same linkage.  At this point we can be sure that
			    ! we are dealing with one of these six data types.
			    !-
			    BIND ROUTINE CVTIX = (
				IF .STRING_DEST [DSC$B_DTYPE] EQL DSC$K_DTYPE_W
				THEN COB$CVTIW_R8 

				ELSE IF .STRING_DEST [DSC$B_DTYPE] EQL DSC$K_DTYPE_WU
				THEN COB$CVTIW_R8 

				ELSE IF .STRING_DEST [DSC$B_DTYPE] EQL DSC$K_DTYPE_L
				THEN COB$CVTIL_R8 

				ELSE IF .STRING_DEST [DSC$B_DTYPE] EQL DSC$K_DTYPE_LU
				THEN COB$CVTIL_R8 

				ELSE IF .STRING_DEST [DSC$B_DTYPE] EQL DSC$K_DTYPE_Q
				THEN COB$CVTIQ_R8 

				ELSE IF .STRING_DEST [DSC$B_DTYPE] EQL DSC$K_DTYPE_QU
				THEN COB$CVTIQ_R8 
				ELSE 0) : JSB_678 ;

			    !+
			    ! First must re-insert the sign in the CIT.
			    ! The sign of the CIT is contained in byte 12
			    ! (see appendix C of the RTL Ref Manual for a
			    ! description of the CIT).  'C' means + and 'D'
			    ! means -.  COB$CVTTI always returns a positive
			    ! number, so if the input number was really
			    ! negative, must make the sign byte negative.
			    ! Check to see if sign should be included.
			    !-
			    IF .SIGN EQL %C'-' AND .YES_SIGN
			    THEN
				    I_VALUE[11] = .I_VALUE[11] + 1;

			    !+
			    ! Next must insert the exponent in the CIT.
			    ! The first word of the CIT contains the exponent.
			    !-
			    CH$MOVE (2, EXPONENT, I_VALUE);

			    !+
			    ! Convert from CIT to destination data type taking
			    ! into account the scale factor.
			    !-
			    SCALE = ( IF .STRING_DEST [DSC$B_CLASS] EQL DSC$K_CLASS_SD
			    	      THEN -.STRING_DEST [DSC$B_SCALE]
				      ELSE 0 );

			    CONV_OK = (	IF CVTIX EQL 0
			    		THEN
					    !+
					    ! Packed
					    !-
			    		    COB$CVTIP_R9 (.SCALE, I_VALUE,
						.STRING_DEST [DSC$W_LENGTH], .STRING_DEST [DSC$A_POINTER])
					ELSE
					    !+
					    ! Integer types
					    !-
					    CVTIX (.SCALE, I_VALUE, .STRING_DEST [DSC$A_POINTER]) ) ;
			    END;
			END ;

    RETURN .CONV_OK ;
    END ;						! End of COB$$COMP_CONV

%SBTTL 'COB$$STRIP_BLANKS_SIGN - Pull blanks and sign'
ROUTINE COB$$STRIP_BLANKS_SIGN (		! Strip blanks and sign from
						! input numeric string
	INPUT_STRING	: REF $STR$DESCRIPTOR,	! Numeric string to scan
	STRING_DEST	: REF $STR$DESCRIPTOR,	! Destination string
	NUM_DIGITS,				! Number of characters read
						! Will contain the number of
						! chars after the stripping
	EXPONENT,				! Will contain the exponent
	SIGN_VAL	: REF BLOCK [,BYTE],	! Will contain the sign char
	FLAGS   ) =				! Needed for COMMA verification

!++
! FUNCTIONAL DESCRIPTION:
!
!	Strips leading and trailing blanks from the input numeric string.
!	Puts the remaining string back and adjusts the number of digits
!	accordingly.  Also strips off the sign char and puts it into the
!	output parameter SIGN_VAL.
!	Strips the decimal point and figures out the exponent.
!	Does nothing about errors in this routine, returns control to 
!	calling routine.
!
! FORMAL PARAMETERS:
!
!	INPUT_STRING.rt.dx	The numeric string to scan
!	STRING_DESC.rt.dx	The destination string 
!	NUM_DIGITS.ml.r 	As input, its the number of chars read
!				As output, its the number of chars after 
!				the stripping
!	EXPONENT.wl.r		The exponent
!	SIGN_VAL.wb.r		The sign character
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	0 = failure, 1 = success
!
! SIDE EFFECTS:
!
!	NONE
!--

    BEGIN

    LOCAL
	TEMP_NUM_DIGITS : INITIAL (0),		! Tally of stripped number of digits
	BUF_DESC : BLOCK [8, BYTE] VOLATILE,	! Temporary buffer
	SIGN_SEEN : INITIAL (0),		! 1 = we have seen a + or -
	DIGIT_SEEN : INITIAL (0),		! 1 = we have seen at least one digit
	DOT_SEEN : INITIAL (0),			! 1 = we have seen a decimal point
	ZERO_SEEN   :  INITIAL (0),		! 1 = zero seen
	BLANKS_SEEN : INITIAL (0),		! 1 = we have seen trailing blanks
	PUTTER : INITIAL (0),			! Counts position in the output buffer
	LEFT_DEC : INITIAL (0),			! Number of digits to left of dec. pt.
	PDATA_FLAG: INITIAL (0),		! Flag to indicate if a P Picture item
	BUF : REF VECTOR [1100, BYTE],		! Addresses result
	INP : REF VECTOR [1100, BYTE],		! Addresses result in input_string
	LEADING_ZEROES:INITIAL (0),		! Counter of leading zeroes
	ARG : REF VECTOR [1100, BYTE];		! Addresses source

    LITERAL
	SUCCESS = 1,
	FAILURE = 0;

   BIND
	ZERO = UPLIT ('0');
!+
! Enable a handler to free the local string in case of an error.
!-

    ENABLE
	COB$$FREE_STRINGS (BUF_DESC);

!+
! If there were no digits input, it means that a <CR> was hit.
!-
    IF ..NUM_DIGITS EQL 0
    THEN
	RETURN SUCCESS;

!+
! Allocate enough space to hold the digits.  It is convenient to
! allocate before scanning, so we may allocate a little too much,
! but the space will be freed before we return.
!-
    BUF_DESC [DSC$W_LENGTH] = 0;
    BUF_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_NU;
    BUF_DESC [DSC$B_CLASS] = DSC$K_CLASS_D;
    BUF_DESC [DSC$A_POINTER] = 0;
    STR$GET1_DX (.NUM_DIGITS, BUF_DESC);

!+
!  Set pointers.
!-
    BUF = .BUF_DESC [DSC$A_POINTER];
    ARG = .INPUT_STRING [DSC$A_POINTER];
    .SIGN_VAL = %C'+';

!+
!  Scan the input number, put result in BUF.
!-

    IF NOT ( COB$$SCAN_INPUT ( .INPUT_STRING, ..NUM_DIGITS, .FLAGS, BUF_DESC,
			LEFT_DEC, TEMP_NUM_DIGITS, .SIGN_VAL, PUTTER,
			LEADING_ZEROES, SIGN_SEEN, DIGIT_SEEN, DOT_SEEN,
			ZERO_SEEN, BLANKS_SEEN ) )
    THEN
	RETURN 0 ;

!+
! If there are no digits, or only leading zeros, take the number to
! be zero.  Don't be too gullible, however.
!-
    IF ( NOT .DIGIT_SEEN)
    THEN
	BEGIN

	IF (.SIGN_SEEN OR .DOT_SEEN OR .BLANKS_SEEN) AND (.ZERO_SEEN EQL 0)
	THEN RETURN FAILURE ;

	BUF [.PUTTER] = %C'0' ;
	PUTTER = .PUTTER + 1 ;
	TEMP_NUM_DIGITS = .TEMP_NUM_DIGITS + 1;

	END

!+
!  Validate size of entered data, left and right of decimal point.
!-
    ELSE
	BEGIN

	LOCAL
	    DEST_LENGTH ,				! Destination length
	    OK_LEFT ,					! Correct number of digits allowed	
							! to left of decimal point
	    RIGHT_DEC   :  INITIAL (0) ;		! Number of digits to right of dec pt


	IF NOT (.DOT_SEEN)				! No dec pt. therefore
	THEN LEFT_DEC = .TEMP_NUM_DIGITS ;		! all digits are left_dec
	RIGHT_DEC = .TEMP_NUM_DIGITS - .LEFT_DEC ;
	!+
	! Strip trailing zeroes after the decimal point.
	!-
	INCR GETTER FROM 1 TO .RIGHT_DEC DO
	    IF .BUF [.TEMP_NUM_DIGITS - .GETTER] EQL %C'0'
	    THEN
		RIGHT_DEC = .RIGHT_DEC - 1
	    ELSE
		EXITLOOP;


	DEST_LENGTH = .STRING_DEST [DSC$W_LENGTH];

	SELECTONE .STRING_DEST [DSC$B_CLASS] OF
	    SET

	    [ DSC$K_CLASS_S ] :

		BEGIN

		!+
		! If a decimal point was typed in, all the digits after it
		! MUST be zeroes.
		!-
		
		IF .RIGHT_DEC GTR 0
		THEN
		    INCR I FROM (.PUTTER - .RIGHT_DEC) TO .PUTTER DO
			IF .BUF[.I] NEQ %C'0' 
			THEN RETURN FAILURE;
		
		IF .LEFT_DEC GTR .DEST_LENGTH
		THEN RETURN FAILURE;			! Data entered too big

		END ;

	    [ DSC$K_CLASS_SD ] :

		BEGIN

		LOCAL
		    LENGTH_DIFF,			! Difference between number of digits
							!  to the left of the decimal point
							!  in the typed in number and the dest
		    LENGTH_DIFF2;			! Difference between number of digits
							!  to the right of the decimal point
							!  in the typed in number and the dest
		!+
		! This is checking for the P Picture of 99PP.		
		! If the scale is positive and the number of digits in the 
		! number equal the scale factor, then simply copy the digits
		! in BUF to the destination descriptor.			
		! NOTE: Code for P Picture left in lowercase.
		!-
		if .string_dest[dsc$b_scale] gtr 0
		then
		    begin
		
		    local
			tot_digits,
			diff;

		    tot_digits = (.string_dest[dsc$b_digits] + .string_dest[dsc$b_scale]);
		    if ((.right_dec gtr 0) or (.temp_num_digits gtr .tot_digits))					 		! illogical case or -
		    then				! number too large
			return 0;			! re-prompt - error

		    if .temp_num_digits leq .string_dest[dsc$b_scale]
		    then
			begin

			str$dupl_char (.input_string,temp_num_digits,zero);
			pdata_flag = 1;			! answer is zero

			end
		    else
			begin
			!+
			! Zero out the destination field using the digits as 
			! proper number of zero fill characters, rather than 
			! using the length as found in the descriptor, since 
			! class SD is a special case.	
			!-
			str$dupl_char (.input_string,tot_digits,zero);
			if .leading_zeroes neq 0
			then
			    begin

			    diff = (.string_dest[dsc$b_digits] + .string_dest[dsc$b_scale]) - .temp_num_digits;
			    ch$move (.string_dest[dsc$b_digits],.buf,.input_string[dsc$a_pointer]+.diff);
			    end
			else
			    begin

			    diff = .temp_num_digits - .string_dest[dsc$b_scale];
			    if .diff eql .string_dest[dsc$b_digits]
			    then
				ch$move (.diff,.buf,.input_string[dsc$a_pointer])
			    else
				begin

				tot_digits = .tot_digits - .temp_num_digits;
			        ch$move (.diff,.buf,.input_string[dsc$a_pointer]+.tot_digits);

				end;

			    end;
			pdata_flag = 1;
			.num_digits = .string_dest[dsc$b_digits] + .string_dest[dsc$b_scale];

			end;

		end
		else
		    begin

		    if .string_dest[dsc$b_scale] gtr 0
		    then
		        ok_left = .string_dest[dsc$b_digits]
		    else
		        OK_LEFT = .STRING_DEST [DSC$B_DIGITS] + .STRING_DEST [DSC$B_SCALE] ;
	 	    if .ok_left lss 0
		    then 
		        begin
			!
			! Here we have a P Picture field of type PP99.		
			! We know this when OK_LEFT is less than zero.		
			! It requires some special casing.			
			!-
		        local
			    diff,
			    ok_right,
			    buf_ptr;
	
		        if .left_dec gtr 0		! error no '.' entered
		        then				! ring bell and reprompt
			    return 0;

		        ok_left = 0;
		        ok_right = abs(.string_dest[dsc$b_scale]);
		        if .right_dec gtr .ok_right
		        then
			    return 0;

			!+
			! This handles case where the number of digits entered 
			! is less than the absolute value of the scale factor, 
			! meaning that the number returned would have to be 0.
			! The first part of the if statement takes care of the 
			! case where the number of digits entered equals the 
			! number of digits expected taking into account if the 
			! absolute value of the scale factor is equal to the
			! number of digits entered to the right of the decimal 
			! point thereby giving us a result of zero again.	
			!-
		        diff = (abs(.string_dest[dsc$b_scale]) - .string_dest[dsc$b_digits]);
		        if ((.right_dec eql .string_dest[dsc$b_digits]) and
			    (.right_dec eql .diff)) OR
			    (.right_dec leq .diff)
		        then
			    begin

			    str$dupl_char (.input_string,temp_num_digits,zero);
			    pdata_flag = 1;			! done - result is zero

			    end
			else
			    begin

			    buf_ptr = .buf_desc[dsc$a_pointer] + .diff;
		            diff = .right_dec - .diff;		! move only necessary digits
			    !+
			    ! Zero out the destination field using the digits 
			    ! as the proper number of zero fill characters, 
			    ! rather than using the length as found in the 
			    ! descriptor, since class SD is a special case.
			    !-
			    str$dupl_char (.input_string,temp_num_digits,zero);
		            ch$move (.diff,.buf_ptr,(.input_string[dsc$a_pointer]+(.temp_num_digits-.diff)));
			    pdata_flag = 1;

			    end;

		        end
	            else

	        	begin					! ok_left is not < zero
			OK_LEFT = .STRING_DEST [DSC$B_DIGITS] + .STRING_DEST [DSC$B_SCALE] ;
			LENGTH_DIFF = .OK_LEFT - .LEFT_DEC;
			LENGTH_DIFF2 = (.STRING_DEST [DSC$B_DIGITS] - .OK_LEFT) - .RIGHT_DEC;
			IF ( .LENGTH_DIFF LSS 0)
				OR
		   	( .LENGTH_DIFF2 LSS 0)
			  THEN RETURN FAILURE ;			! Data entered too big
	        	end;
		  end;
		END ;

	    [ OTHERWISE ] :
	
		LIB$STOP ( COB$_INVARG ) ;

	    TES ;

	END;

!+
! Figure out the exponent.
!-
    IF NOT (.DOT_SEEN)				! No decimal pt, therefore
    THEN 					! all digits are left_dec
	LEFT_DEC = .TEMP_NUM_DIGITS;

    IF .LEFT_DEC EQL 0
    THEN
	!+
	! Figure out exponent if all digits are to right of decimal point.
	!-
    if .pdata_flag
      then
	begin
	inp = .input_string [dsc$a_pointer];	! point to re-written data
	.EXPONENT = 0;
	INCR GETTER FROM 0 TO (.TEMP_NUM_DIGITS - 1) DO
	    !+
	    ! Exponent decreases for every leading zero.
	    !-
	    IF .inp [.GETTER] EQL %C'0'
	    THEN
		.EXPONENT = ..EXPONENT - 1
	    ELSE
		EXITLOOP;

	END
    ELSE
	BEGIN
	.EXPONENT = 0;
	INCR GETTER FROM 0 TO (.TEMP_NUM_DIGITS - 1) DO
	    !+
	    ! Exponent decreases for every leading zero.
	    !-
	    IF .BUF [.GETTER] EQL %C'0'
	    THEN
		.EXPONENT = ..EXPONENT - 1
	    ELSE
		EXITLOOP;

	END
    ELSE
	!+
	! If all digits are to left of decimal point, exponent is equal
	! to left_dec.
	!-
        .EXPONENT = .LEFT_DEC;

!+
! Move the stripped string into the buffer and adjust the number-of-digits
!-
    
    if .pdata_flag eql 0
    then
	begin
      	CH$MOVE (.TEMP_NUM_DIGITS, .BUF_DESC [DSC$A_POINTER], 
		 .INPUT_STRING [DSC$A_POINTER]);
	.NUM_DIGITS = .TEMP_NUM_DIGITS;
	end
    else
	if .string_dest[dsc$b_scale] lss 0
	then
	    .num_digits = .temp_num_digits ;

!+
! Free our local string
!-
    STR$FREE1_DX (BUF_DESC);
    RETURN SUCCESS ;

    END;					! end of COB$$STRIP_BLANKS_SIGN

%SBTTL 'COB$$ZERO_FILL - Initialize destination'
ROUTINE COB$$ZERO_FILL ( STRING_DEST  :  REF $STR$DESCRIPTOR
						! Destination for input 
		       )  :  NOVALUE  =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine will initialize STRING_DEST to zeroes before the input
!	data is copied to it.
!
! FORMAL PARAMETERS:
!
!	STRING_DEST.mt.ds   Address of descriptor to receive the read input.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!--

	BEGIN

	LOCAL
	    SIGN	: BYTE,
	    ZERO	: BYTE,
	    DEST_PTR ,					! Pointer where result will go in destination
	    DEST_LENGTH ;				! Destination length

	LITERAL
	    ZERO_O   = 48,				! Zero
	    POS_SIGN = 43,				! Plus sign
	    POSZEROP = 123 ;				! +0 overpunched


	ZERO = ZERO_O ;
	DEST_PTR    = .STRING_DEST [DSC$A_POINTER] ;
	DEST_LENGTH = .STRING_DEST [DSC$W_LENGTH] ;

	!+
	!  Zero fill, then handle sign correctly.
	!-

	STR$DUPL_CHAR ( .STRING_DEST, DEST_LENGTH, ZERO ) ;

	CASE .STRING_DEST [DSC$B_DTYPE] FROM DSC$K_DTYPE_NU TO DSC$K_DTYPE_NRO
	    OF
	    SET

	    [DSC$K_DTYPE_NU]:				! Numeric unsigned
		!+
		!  Move all zeroes to STRING_DEST
		!-
		0 ;					! No further action	
				
	    [DSC$K_DTYPE_NL]:				! Numeric left separate
		!+
		!  Move sign then all zeroes to STRING_DEST
		!-

		BEGIN
			
		SIGN = POS_SIGN ;
		CH$MOVE (1, SIGN, .STRING_DEST [DSC$A_POINTER]);

		END;
			
	    [DSC$K_DTYPE_NR]:				! Numeric right separate
		!+
		!  Move all zeroes followed by sign to STRING_DEST
		!-

		BEGIN
			
		SIGN = POS_SIGN ;
	    	CH$MOVE ( 1, SIGN, (.DEST_PTR + (.DEST_LENGTH - 1)) ) ;

		END;
			
	    [DSC$K_DTYPE_NLO]:				! Numeric left overpunched
		!+
		!  Move all zeroes to STRING_DEST
		!  First digit has overpunch sign (positive)
		!-

		BEGIN

		SIGN = POSZEROP ;
		CH$MOVE (1, SIGN, .STRING_DEST[DSC$A_POINTER]);

		END;
			
	    [DSC$K_DTYPE_NRO]:				! Numeric right overpunched
		!+
		!  Move all zeroes to STRING_DEST
		!  Last digit has overpunch sign (positive)
		!-

		BEGIN
			
		SIGN = POSZEROP ;
	    	CH$MOVE (1, SIGN, (.DEST_PTR + (.DEST_LENGTH - 1)) );

		END;

	    TES;		

    END ;					! End of COB$$ZERO_FILL

%SBTTL 'COB$$VERIFY_FL_RANGE - Verify Float Pt range'
ROUTINE COB$$VERIFY_FL_RANGE (
			  TEMP_PUT_HERE  :  REF BLOCK [8, BYTE], ! # to scan
			  CHARS_READ,		! # of chars in TEMP_PUT_HERE
			  MAX			! # of significant digits allowed
		       )  =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Check range of Floating and Double Floating Point input data.
!	Do nothing about errors in this routine, return to calling routine.
!
! FORMAL PARAMETERS:
!
!	TEMP_PUT_HERE.rt.dx	Input data to be verified.
!
!	CHARS_READ.rlu.v	Number of input characters.
!
!	MAX.rlu.v		Number of significant digits allowed in
!				mantissa of E notation representation.
!				7 for Floating Point
!				16 for Double Floating Point
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	1 = SUCCESS
!	0 = FAILURE
!
! SIDE EFFECTS:
!
!	NONE
!--

    BEGIN
    !+
    !  This routine counts the significant digits (1-9) and significant zeroes
    !  of data that is input to either a floating point or a double floating
    !  point data item.   Some zeroes can be ignored.
    !
    !     0000000000012.3400000000000000000
    !     \_________/     \_______________/
    !          |		  |
    !        ignore		ignore
    !
    !     000.00000000000000000000000000012345
    !     \_/ \_________________________/
    !      |		  |
    !    ignore	    do not ignore
    !
    !     12340000000000000000000000000000.000
    !         \__________________________/ \_/
    !      		  |		    |
    !   	    do not ignore	 ignore
    !-


	LOCAL
		PUT_BUF		:  REF VECTOR [1100, BYTE],
		COUNT		:  INITIAL (0),		! Count for TEMP_PUT_HERE
		DOT_SEEN	:  INITIAL (0),		! =1 Decimal point seen
		DIGIT_SEEN	:  INITIAL (0),		! =1 At least 1 digit seen
		SIGN_SEEN	:  INITIAL (0),		! =1 Sign seen
		E_SEEN		:  INITIAL (0),		! =1 E/e of exponent seen
		R_SIGNIF	:  INITIAL (0),		! Signigicant digits to
							! right of decimal point
		L_SIGNIF	:  INITIAL (0),		! Significant digits to
							! left of decimal point
		R_ZERO		:  INITIAL (0), 	! Significant zeroes to
							! right of decimal point
					! Calculated after incr loop .00...00123
		L_ZERO		:  INITIAL (0) ;	! Significant zeroes to 
							! left of decimal point
					! Calculated in incr loop 1200...0.0

			PUT_BUF = .TEMP_PUT_HERE [DSC$A_POINTER] ;

			INCR X FROM 0 TO .CHARS_READ - 1 DO
			    BEGIN				! Begin INCR loop
				!+
				!  Count significant digits and significant zeroes.
				!-
				SELECTONE .PUT_BUF [.X] OF
				    SET

				    [ %C'1' TO %C'9' ] :
					!+
					!  Count significant digits to the left
					!  or right of the decimal point.
					!-

					BEGIN
					DIGIT_SEEN = 1 ;
					IF .DOT_SEEN
					THEN
					    R_SIGNIF = .R_SIGNIF + 1
					ELSE
					    L_SIGNIF = .L_SIGNIF + 1 ;
					COUNT = .COUNT + 1 ;
					END ;

				    [ %C'0' ] :
					!+
					!  Count zeroes after DIGIT_SEEN 
					!  and/or after DOT_SEEN. 
					!-

					BEGIN
					IF .DIGIT_SEEN
					THEN
					    IF .DOT_SEEN
					    THEN
						R_SIGNIF = .R_SIGNIF + 1
					    ELSE
						L_SIGNIF = .L_SIGNIF + 1
					ELSE
					    !+
					    !  Count zeroes after decimal point,
					    !  but before significant digits
					    !-
					    IF .DOT_SEEN
					    THEN
						R_ZERO = .R_ZERO + 1 ;
					COUNT = .COUNT + 1 ;
					END ;

				    [ %C'-', %C'+' ] :
					!+
					!  Only one sign is valid
					!-

					IF .SIGN_SEEN EQL 0
					THEN
					    BEGIN
					    SIGN_SEEN = 1 ;
					    COUNT = .COUNT + 1 ;
					    END
					ELSE
					    RETURN 0 ;

				    [ %C'.', %C',' ] :

					BEGIN
					DOT_SEEN = 1 ;
					COUNT = .COUNT + 1 ;
					END ;

				    [ %C' '] :
					!+
					!  Spaces are allowed
					!-
					    COUNT = .COUNT + 1 ;

				    [ %C'E', %C'e' ] :

					!+
					! Don't check range of exponent, leave
					! that for OTS$CVT_T_F/D
					!-
					BEGIN
					E_SEEN = 1 ;
					EXITLOOP ;
					END ;

				    [ OTHERWISE] :

					RETURN 0 ;

				    TES ;

			    !+
			    !  If maximum significant digits allowed has already
			    !  been reached, or all is left is the exponent
			    !  - pull out of loop.
			    !-

			    IF (.L_SIGNIF + .R_SIGNIF EQL .MAX)  OR 
							( .E_SEEN )
			    THEN EXITLOOP ;

			    END ;				! End INCR loop

				!+
				!  Make sure all remaining digits (if any) 
				!  are zeroes
				!  Count zeroes after significant digits, but 
				!  before decimal point.
				!-

				IF .COUNT LSS .CHARS_READ
				THEN
				    !+
				    !  All input characters have not yet been processed.
				    !-
				    BEGIN
				    INCR Y FROM .COUNT TO .CHARS_READ - 1 DO
					BEGIN

					SELECTONE .PUT_BUF [.Y] OF
					    SET

					    [ %C'E', %C'e' ] :

						!+
						! Don't check range of exponent,
						! leave that for OTS$CVT_T_F/D
						!-
						EXITLOOP ;

					    [ %C'0' ] :
						!+
						!  Count zeroes to left
						!  of decimal point.
						!-
						    IF .DOT_SEEN EQL 0
						    THEN
							L_ZERO = .L_ZERO + 1 ;

					    [ %C'.', %C',', %C'-', %C'+', %C' ' ] :
						!+
						!  Of no consequence here
						!-
						0 ;

					    [ OTHERWISE ]:

						RETURN 0 ;
					    TES ;

					END ;
				    END ;

				!+
				!  Check range.  At this point you are only concerned
				!  about the  # of zeroes beteen the decimal point and
				!  the significant digits.  Anything greater then 38
				!  is out of range.  For example the following are out
				!  of range -
				!     0.00000000000000000000000000000000000000123
				! 	because R_SIGNIF + R_ZERO GTR 38
				!     1230000000000000000000000000000000000000000
				! 	because L_SIGNIF + L_ZERO GTR 38
				! 
				! NOTE :  The following error would have been caught
				!  	  by the loop above -
				!     120000000.00000000000000000000000000000034
				!		out of range
				!-

				IF .R_SIGNIF + .R_ZERO GTR %X'38' OR
				   .L_SIGNIF + .L_ZERO GTR %X'38'
				THEN
				    RETURN 0 ;		! Out of range

    RETURN 1 ;
    END ;						! End COB$$VERIFY_FL_RANGE

%SBTTL 'COB$$SCAN_INPUT - Scan the input string'
ROUTINE COB$$SCAN_INPUT ( ARG_DESC 	:  REF $STR$DESCRIPTOR,	
			  CHARS_READ,
			  FLAGS,
			  BUF_DESC	:  REF $STR$DESCRIPTOR,
			  LEFT_DEC,
			  NUM_DIGITS,
			  SIGN_VAL,
			  PUTTER,
			  LEADING_ZEROES,
			  SIGN_SEEN,
			  DIGIT_SEEN,
			  DOT_SEEN,
			  ZERO_SEEN,
			  BLANKS_SEEN
			)  : =

!++
! FUNCTIONAL DESCRIPTION:
!
!  Scan the input number, put result in BUF.
!
! FORMAL PARAMETERS:
!
!	ARG_DESC.rt.dx		The numeric string to scan
!	CHARS_READ.rlu.v	Number of input characters read
!	FLAGS.rlu.v		Screen enhancement flag
!	BUF_DESC.rt.dx		Deposit for scanned input 
!	LEFT_DEC.ml.r		# of digits to left of decimal point
!	NUM_DIGITS.ml.r		# of digits in ARG_DESC
!	SIGN_VAL.ml.r		Temp to hold sign
!	PUTTER.ml.r		Counts position in buffer BUF_DESC
!	LEADING_ZEROES.ml.r	# of leading zeroes
!	SIGN_SEEN.ml.r		= 1 if '+' or '-' scanned 
!	DIGIT_SEEN.ml.r		= 1 if a digit 0-9 was scanned
!	DOT_SEEN.ml.r		= 1 if '.' or ',' scanned
!	ZERO_SEEN.ml.r		= 1 if digit 0 scanned
!	BLANKS_SEEN.ml.r	= 1 if trailing blanks scanned
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	0 = Failure, 1 = Success
!
! SIDE EFFECTS:
!
!	NONE
!--

    BEGIN
	LOCAL
	BUF : REF VECTOR [1100, BYTE],		! Addresses result
	ARG : REF VECTOR [1100, BYTE] ;		! Addresses source

    BUF = .BUF_DESC [DSC$A_POINTER];
    ARG = .ARG_DESC [DSC$A_POINTER];

!+
!  Scan Input, put result in BUF.
!-

    INCR GETTER FROM 0 TO (.CHARS_READ - 1) DO

	SELECTONE .ARG [.GETTER] OF
	    SET

	    [%C'0' TO %C'9'] :

		BEGIN				! Decimal digit
		IF ( .ARG [.GETTER] NEQ %C'0' ) OR (..DOT_SEEN EQL 1) OR
		   ((.ARG [.GETTER] EQL %C'0' ) AND ..DIGIT_SEEN EQL 1)	
		THEN
		    BEGIN
		    !+
		    ! This is not a leading zero
		    !-
		    IF ..BLANKS_SEEN		! Ensure no imbedded blanks
		    THEN RETURN 0;

		    .DIGIT_SEEN = 1;
		    BUF [..PUTTER] = .ARG [.GETTER];
		    .PUTTER = ..PUTTER + 1;

		    .NUM_DIGITS = ..NUM_DIGITS + 1 ;
		    END
		ELSE
		    BEGIN
		    .LEADING_ZEROES = ..LEADING_ZEROES + 1;
		    .ZERO_SEEN = 1 ;		! 00. is valid - dot_seen and
						! zero_seen
		    END;
		END;

	    [%C'+', %C'-'] :

		BEGIN				! Plus or minus sign
		IF ( ..SIGN_SEEN ) THEN RETURN 0 ;
		IF .GETTER NEQ .CHARS_READ - 1	! Ensure no imbedded signs
		THEN
		    IF (( ..DIGIT_SEEN ) AND ( .ARG [.GETTER + 1] NEQ %C' ' ))
		    THEN RETURN 0 ;

		.SIGN_SEEN = 1;
		.SIGN_VAL = .ARG [.GETTER];
		END;

	    [%C'.'] :

		BEGIN				! Decimal point
		IF ( ..DOT_SEEN ) THEN RETURN 0;
		!+
		!  Is decimal point a valid character - look at bit 6 of FLAGS
		!-
		IF ( .FLAGS AND V_DEC_PT ) NEQ 0
		THEN
		    RETURN 0			! Decimal point is illegal
		ELSE
		    BEGIN
		    .DOT_SEEN = 1;
		    .LEFT_DEC = ..NUM_DIGITS ;	! Count for validating size of
		    END ;			! entered data.  NUM_DIGITS
		END;				! calculated below.

	    [%C','] :

		BEGIN				! Decimal point is Comma
		IF ( ..DOT_SEEN ) THEN RETURN 0;
		!+
		!  Is comma a valid character - look at bit 6 of FLAGS
		!-
		IF ( .FLAGS AND V_DEC_PT ) NEQ 0
		THEN
		    BEGIN			! Comma is an illegal character
		    .DOT_SEEN = 1;
		    .LEFT_DEC = ..NUM_DIGITS ;	! Count for validating size of
		    END				! entered data.  NUM_DIGITS
		ELSE				! calculated below.
		    RETURN 0 ;
		END;

	    [%C' '] :

		BEGIN				! Blank, better be leading or trailing.
		IF (..SIGN_SEEN OR ..DIGIT_SEEN OR ..DOT_SEEN) 
		THEN .BLANKS_SEEN = 1;
		END;

	    [OTHERWISE] :	!  reprompt by passing back a routine value of 0

		RETURN 0 ;	     
 	    TES;

    RETURN 1 ;
    END ;					! End COB$$SCAN_INPUT

    END						! End of module COB$ACCECV
    ELUDOM
