module lnk_objpass1 
		(ident = 'V04-000' 
		,addressing_mode
			(external    = general
			,nonexternal = long_relative
			)
		) =
begin
!
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
!++
!
! MODULE:	LNK_OBJPASS1
!
! FACILITY:	LINKER
!
! ABSTRACT:	Pass one of all object modules of this link.
!
! HISTORY:
!
!	VERSION: X01.00
!
!	AUTHOR: T.J. PORTER 30-DEC-76
!
! MODIFIED BY:
!
!	V04-045 JWT0182		Jim Teague		14-May-1984
!		Adjust logic in PROSYMBOL so that lnk$gw_nudfsyms
!		doesn't get decremented too many times.
!
!	V04-044	ADE0003		Alan D. Eldridge	 4-May-1984
!		Fix access violation in routine PROSYMBOL.
!
!	V04-043	ADE0002		Alan D. Eldridge	 1-May-1984
!		Fix bug in reporting 'illegal module name length'.
!
!	V04-042	ADE0001		Alan D. Eldridge	 3-Mar-1984
!		If GSMATCH high bit is set, then ignore date comparison
!		between shareable image library entry and shareable image
!		itself.
!
!	V04-041	JWT0154		Jim Teague		 9-Feb-1984
!		MPC blocks are not always clean when memory is
!		allocated for them.  This caused ridiculous values
!		for psect length to show up in the data produced 
!		in the Debugger Module/Psect Table (DMT).
! 
!	V03-040	JWT0132		Jim Teague		16-Aug-1983
!		Adjust ordering of LNKOPT fdbs that are created.
!		A module that specifies several files in LNKOPT
!		records caused the linker to append the LNKOPT
!		file fdbs in reverse order!
!
!	V03-039	JWT0130		Jim Teague		28-Jul-1983
!		More scrutiny for Linker Options Records.
!
!	V03-038	JWT0128		Jim Teague		24-Jul-1983
!		Fix environment ref/def problem.
!
!	V03-037	JWT0125		Jim Teague		23-Jun-1983
! 		Reincarnate univ=* when accompanied by /noexe.
!
!	V03-036	JWT0121		Jim Teague		20-May-1983
!		Sound the death knell for UNIVERSAL=*.
!
!	V03-035	JWT0113		Jim Teague		20-Apr-1983
!		Filter universal bit out of incoming symbols;
!		Call $getjpi to get number of open files left.
!
!	V03-034 JWT0109		Jim Teague		13-Apr-1983
!		Adjust code for Linker Options Record.
!
!	V03-033	JWT0099		Jim Teague		14-Mar-1983
!		New CLI interface.  Also implemented code for
!		Linker Options Record.
!
!	V03-032	JWT0071		Jim Teague		02-Dec-1982
!		Added NAME and IDENTIFICATION options.
!
!	V03-031	JWT0061		Jim Teague		22-Oct-1982
!		Add debugger image section to images linked /debug.
!
!	V03-030	JWT0052		Jim Teague		15-Sep-1982
!		Fix bug which caused option-defined symbols to be
!		excluded from STB.
!
!	V03-029 JWT0047		Jim Teague		06-Aug-1982
!		Fix the linker psect alignment bug, once and for all!
!
!	V03-028 JWT0045		Jim Teague		30-Jul-1982
!		Fix bug in entity id mismatch error message.
!
!	V03-027	JWT0043		Jim Teague		15-Jul-1982
!		Fix psect alignment bug which caused all contributions to
!		a psect to have maximized alignment.
!
!	V03-026	JWT0039		Jim Teague		23-Jun-1982
!		Add mask in order to retain SYM$V_LCLSYM attribute.
!		This keeps module local symbols out of cross references.
!
!	V03-025 JWT0033		Jim Teague		25-May-1982
!		Or OMD$V_NOBINs for each FDB and propagate to FDB$V_OMDNOBIN
!		Use option-specified psect alignment if present in PROPSECTDEF
!
!	V03-024	BLS0161		Benn Schreiber		19-Mar-1982
!		Correct V03-021 handling of selective search procedures
!
!
!--

!++
!
! FUNCTIONAL DESCRIPTION:
!
! THIS ROUTINE IS CALLED TO PROCESS ALL OBJECT MODULES
! DURING PASS ONE OF THE LINK. IT VALIDATES OBJECT MODULE
! FORMAT, READS THE MODULE HEADER, ALL GSD AND THE
! END OF MODULE RECORDS AND BUILDS SYMBOL AND P-SECTION
! TABLES. IT IS IN THIS ROUTINE ALONE THAT THE LINKER
! DETERMINES WHETHER THE MODULE IS CONCATENATED. IT IS
! ALSO HERE THAT ANY USER DEFINED TRANSFER ADDRESS IS
! EXTRACTED.
!
! THIS ROUTINE IGNORES THE CONTENT OF TIR, DBG AND LNK RECORDS.
!
!--
require 'PREFIX';
forward routine
    prolnkrec,					! PROCESS LINKER OPTIONS RECORD
    checkpddentry,				! CHECK PSECT DEF. ENTRY AND DEFINE IT
    lnk$insudfsym : novalue,			! INSERT SYMBOL IN UNDEFINED SYMBOL LIST
    seqchk,					! CHECK RECORD SEQUENCE
    prohdr,					! PROCESS MODULE HEADER RECORDS
    delete_psect,				! DELETE SHAREABLE IMAGE PSECT FROM OTHER CLUSTERS
    fndpscmapent,				! FIND PSECT MAPPING TABLE ENTRY
    alloc_omdnode,				! ALLOCATE OMD NODE BLOCK
    lnk$compare_omd,				! COMPARE OMD NODE BLOCKS
    propsectdef,				! PROCESS PSECT DEFINITIONS
    crefilter,					! CROSS REFERENCE FILTER FOR SYMBOLS
    prosymbol,					! PROCESS SYMBOLS
    symbols,					! FRONT END FOR SYMBOL DEFS/REFS
    entpnts,					! FRONT END FOR ENTRY POINTS
    procedef,					! FRONT END FOR PROCEDURE DEFINITIONS
    proeom,					! PROCESS END OF MODULE RECORDS
    countdbg,					! COUNT DEBUG AND TRACEBACK RECORDS
    compare_idc,				! COMPARE RANDOM IDENT BLOCKS
    alloc_idc,					! ALLOCATE RANDOM IDENT BLOCK
    randentity,					! PROCESS RANDOM IDENTS
    compare_env,				! COMPARE ENVIRONMENT BLOCKS
    alloc_env,					! ALLOCATE ENVIRONMENT BLOCK
    insudfenv		: novalue,		! INSERT UNDEFINED ENVIRONMENT
    lnk$fndenvmap,				! FIND ENVIRONMENT MAPPING TABLE ENTRY
    proenv,					! PROCESS ENVIRONMENT
    localsymbols,				! FRONT END FOR LOCAL SYMBOLS
    localentpnt,				! FRONT END FOR LOCAL ENTRY POINTS
    localprocedef,				! FRONT END FOR LOCAL PROCEDURE DEFS
    progsd,					! PROCESS GSD RECORDS
    lnk$procsobj,				! PROCESS AN OBJECT MODULE
    lnk$objpass1 ;				! DO PASS 1

library 'LIBL32' ;				! SYSTEM DATA STRUCTURES

library 'DATBAS' ;				! INTERNAL DATA BASE DEFINITIONS

require 'ISGENC' ;				! IMAGE SECTION DEFINITIONS AND OBJECT LANG. DEFS.
!
!
! ENSURE THAT SYM$ SYMBOLS CORRESPOND TO GSY$ SYMBOLS
!  AND THE PSC$ SYMBOLS CORRESPOND TO GPS$ SYMBOLS
!
%if (sym$m_weak and gsy$m_weak) eql 0	%then %warn ('SYM$M_WEAK NEQ GSY$M_WEAK') %fi;
%if  (sym$m_def and gsy$m_def)	eql 0	%then %warn  ('SYM$M_DEF NEQ GSY$M_DEF') %fi;
%if  (sym$m_uni and gsy$m_uni)	eql 0	%then %warn  ('SYM$M_UNI NEQ GSY$M_UNI') %fi;
%if  (sym$m_rel and gsy$m_rel)	eql 0	%then %warn  ('SYM$M_REL NEQ GSY$M_REL') %fi;
%if  (psc$m_pic and gps$m_pic)	eql 0	%then %warn  ('PSC$M_PIC NEQ GPS$M_PIC') %fi;
%if  (psc$m_lib and gps$m_lib)	eql 0	%then %warn  ('PSC$M_LIB NEQ GPS$M_LIB') %fi;
%if  (psc$m_ovr and gps$m_ovr)	eql 0	%then %warn  ('PSC$M_OVR NEQ GPS$M_OVR') %fi;
%if  (psc$m_rel and gps$m_rel)	eql 0	%then %warn  ('PSC$M_REL NEQ GPS$M_REL') %fi;
%if  (psc$m_gbl and gps$m_gbl)	eql 0	%then %warn  ('PSC$M_GBL NEQ GPS$M_GBL') %fi;
%if  (psc$m_shr and gps$m_shr)	eql 0	%then %warn  ('PSC$M_SHR NEQ GPS$M_SHR') %fi;
%if  (psc$m_exe and gps$m_exe)	eql 0	%then %warn  ('PSC$M_EXE NEQ GPS$M_EXE') %fi;
%if  (psc$m_rd  and gps$m_rd)	eql 0	%then %warn   ('PSC$M_RD NEQ GPS$M_RD') %fi;
%if  (psc$m_wrt and gps$m_wrt)	eql 0	%then %warn  ('PSC$M_WRT NEQ GPS$M_WRT') %fi;
%if  (psc$m_vec and gps$m_vec)	eql 0	%then %warn  ('PSC$M_VEC NEQ GPS$M_VEC') %fi;
 
global literal
    psc$m_pscbits =    psc$m_pic or psc$m_lib or psc$m_ovr	! PSECT ATTRIBUTES ALL TOGETHER
		    or psc$m_rel or psc$m_gbl or psc$m_shr 
		    or psc$m_exe or psc$m_rd  or psc$m_wrt 
		    or psc$m_vec,

    psc$m_shrbits =    psc$m_gbl or psc$m_shr or psc$m_ovr ;	! PSECTS CONSIDERED FOR SHAREABLE IMAGE

external routine
    lnk$closefile,
    lnk$filnamdsc,
    lnk$openlib,
    lnk$allofdb,
    crf$insrtkey,				! INSERT KEY IN CREF TABLE
    crf$insrtref,				! INSERT REF TO KEY IN CREF TABLE
    lib$insert_tree,				! INSERT INTO BINARY TREE
    lib$lookup_tree,				! LOOKUP IN BINARY TREE
    lib$traverse_tree,				! TRAVERSE BINARY TREE
    lnk$compare_pscnod,				! COMPARE PSECT NAME WITH GPSLST NODE
    lnk$srcpscdef,				! FIND PSECT DEFINED IN OPTION FILE
    lnk$bintim,					! CONVERT DATE/TIME TO BINARY
    lnk$alloblk 	: novalue,		! DYNAMIC MEMORY ALLOCATION
    lnk$dealblk 	: novalue,		! AND DEALLOCATION
    lnk$exit 		: novalue,		! EXIT ROUTINE
    lnk$fndpscnam,				! SEARCH FOR A P-SECTION ENTRY BY NAME
    lnk$insert,					! SYMBOL TABLE INSERTION
    lnk$nxtfil,					! GET NEXT INPUT FILE
    lnk$nxtrec,					! OBTAIN NEXT RECORD OF OBJECT MODULE
    lnk$procshrim,				! PROCESS SHAREABLE IMAGES
    lnk$procslib,				! PROCESS AN OBJECT LIBRARY FILE
    lnk$search,					! SYMBOL TABLE SEARCH
    lnk$searchlocal,				! MODULE-LOCAL SYMBOL TABLE SEARCH
    lnk$addimage;				! ADD SHAREABLE IMAGE CLUSTER

external literal
    lib$_keyalrins,				! KEY ALREADY INSERTED IN TREE
    lin$_openin,
    lin$_badccc,				! BAD COMPILER COMPLETION CODE
    lin$_badpsc,				! ILLEGAL P-SECTION REFERENCED
    lin$_datmismch,				! CREATION DATE/TIME MISMATCH
    lin$_eomftl,				! EOM RECORD SPECIFIES ABORT
    lin$_errors,				! COMPILATION HAD FATAL ERRORS
    lin$_excpsc,				! TOO MANY PSECTS DEFINED
    lin$_fatalerror,				! FATAL ERROR MESSAGE ISSUED
    lin$_format,				! OBJECT MODULE FORMAT ERROR
    lin$_gsdtyp,				! ILLEGAL GSD TYPE
    lin$_entidmtch,				! ASCIC IDENT MISMATCH
    lin$_entidmtchb,				! BINARY IDENT MISMATCH
    lin$_entidmtcho,				! IDENT OBJECT TYPE MISMATCH
    lin$_entidmtcht,				! IDENT TYPE MISMATCH
    lin$_illfmlcnt,				! ILLEGAL FORMAL ARGUMENT COUNTS
    lin$_illnamelen,				! ILLEGAL NAME LENGTH
    lin$_illrectyp,				! ILLEGAL RECORD TYPE
    lin$_illreclen,				! ILLEGAL RECORD LENGTH
    lin$_modnam,				! ILLEGAL MODULE NAME
    lin$_muldef,				! MULTIPLE SYMBOL DEFINITION
    lin$_muldefpsc,				! MULT. DEF OF PSECT IN SAME MODULE
    lin$_mulpsc,				! MULTIPLE PSECT ATTRIBUTES DEF.
    lin$_multfr,				! MULTIPLE TRANSFER ADDRESSES
    lin$_mulshrpsc,				! MULTIPLY DEFINED SHAREABLE IMAGE PSECT
    lin$_noeom,					! MISSING END OF MODULE ERROR
    lin$_noimgfil,				! IMAGE FILE NOT CREATED
    lin$_nomods,				! NO MODULES FOUND (IN THE LIBRARIES)
    lin$_nopscts,				! NO PROGRAM SECTIONS FOUND
    lin$_nudfenvs,				! NUMBER OF UNDEFINED ENVIRONMENTS
    lin$_nudfsyms,				! NUMBER OF UNDEFINED SYMBOLS
    lin$_nudflsyms,				! NUMBER OF UNDEFINED LOCAL SYMBOLS
    lin$_ovrali,				! OVERLAYED P-SECTION WITH DIFFERERENT ALIGNMENT
    lin$_pscali,				! ILLEGAL P-SECTION ALIGNMENT
    lin$_pscnxr,				! P-SECTION CONTAINING TRANSFER ADDRESS IS NOT EXE/REL
    lin$_reclng,				! ILLEGAL RECORD LENGTH
    lin$_rectyp,				! ILLEGAL RECORD TYPE
    lin$_seqnce,				! RECORDS IN ILLEGAL SEQUENCE
    lin$_shrpsclng,				! PSECT IN OBJ MOD BIGGER THAN ONE IN SHR IMAGE
    lin$_strlvl,				! ILLEGAL STRUCTURE LEVEL IN MODULE
    lin$_udfenv,				! LIST AN UNDEFINED ENVIRONMENT
    lin$_udfsym,				! EACH UNDEFINED SYMBOL
    lin$_wrners,				! COMPILER ISSUED WARNINGS
    lnk$k_max_filename_length ;			! MAXIMUM FILENAME LENGTH

external
    lnk$gt_jpilst,
    lnk$gl_filesleft,
    lnk$al_rab 		: block [rab$c_bln, byte],	! RAB USED TO OPEN THE FILE
    lnk$al_sytblfmt,					! SYMBOL LISTING FORMAT DESCRIPTION TABLE ADDRESS
    lnk$al_valctltb,					! CREF BY VALUE CONTROL TABLE ADDRESS
    lnk$aw_version	: block [lid$c_size, byte],	! VERSION ARRAY
    lnk$gl_ctlmsk 	: block [, byte],		! LINK CONTROL MASK
    lnk$gl_pshrnum,					! NUMBER OF PSECT TO BE OUTPUT TO SHAREABLE IMAGE
    lnk$gt_imgsta 	: block [, byte],		! NAME OF "SYS$IMGSTA"
    lnk$gl_clulst 	: vector [2],			! CLUSTER DESCRIPTOR LISTHEAD
    lnk$gl_defclu 	: block [, byte],
    lnk$gl_record,					! RECORD NUMBER IN THE FILE
    lnk$gl_shrsyms,					! NUMBER OF SHAREABLE IMAGE SYMBOLS REFERENCED
    lnk$gl_shrimgs,					! NUMBER OF SHAREABLE IMAGES REFERENCED
    lnk$gl_pscdflst,					! PSECTS DEFINED BY OPTION LIST
    lnk$gl_maxsymsz,					! MAXIMUM SYMBOL LENGTH SEEN
    lnk$gl_maxmodsz,					! MAXIMUM MODULE LENGTH SEEN
    lnk$gl_curclu 	: ref block [, byte],		! CURRENT CLUSTER POINTER
    lnk$gl_curfil 	: ref block [, byte],		! CURRENT FDB POINTER
    lnk$gl_curomd 	: ref block [, byte],		! CURRENT OMD POINTER
    lnk$gl_libsym 	: ref block [, byte],		! POINTS TO SYMBOL CAUSING LOAD OF LIBRARY MODULE
    lnk$gt_imgid 	: vector [, byte],		! STORAGE OF IMAGE IDENT
    shrfiltype,						! .EXE string
    defiletype,						! .OBJ string
    libfiltype;						! .OLB string

global
    lnk$gl_omddst 	: initial (0),			! COUNT OF OBJMODS WHICH CONTRIBUTE TO DST
    lnk$gw_pscdst 	: word initial (0),		! COUNT OF PSECTS IN THE ABOVE OBJMODS
    lnk$gl_udflst 	: vector [2] initial (		! UNDEFINED SYMBOL LISTHEAD
					lnk$gl_udflst,	! INITIALLY POINTS TO
					lnk$gl_udflst),	! ITSELF, SINCE EMPTY
    lnk$gl_envtree,					! TREE HEAD FOR ENVIRONMENTS
    lnk$gl_udfenv 	: vector [2] initial (		! UNDEFINED ENVIRONMENT LISTHEAD
					lnk$gl_udfenv,
					lnk$gl_udfenv),
    lnk$gl_udflsy 	: vector [2] initial (		! LIST HEAD FOR UNDEFINED LOCAL SYMBOLS
					lnk$gl_udflsy,
					lnk$gl_udflsy),
    lnk$gl_entitree,					! TREE HEAD FOR ENTITIES IDENT CHECK
    lnk$gl_dbgtfr,					! DEBUGGER TRANSFER ADDRESS
    lnk$gl_dbgtfps 	: ref block [, byte],		! POINTER TO PSECT CONTAINING IT
    lnk$gl_tfradr,					! TRANSFER ADDRESS
    lnk$gl_tfrpsc	: ref block [, byte],		! POINTER TO PSECT CONTAINING IT
    lnk$gl_dbgestim,					! ESTIMATE OF NUMBER OF BYTES FOR DST
    lnk$gl_omdtree,					! TREE HEAD FOR OBJ MODULE DESCRIPTORS
    lnk$gw_dbgrecs 	: word,				! NUMBER OF DEBUG RECORDS
    lnk$gw_nfiles 	: word,				! NUMBER OF FILES OPENED
    lnk$gw_nmodules 	: word,				! NUMBER OF MODULES FOUND
    lnk$gw_npsects 	: word,				! NUMBER OF PSECTS IN TABLE
    lnk$gw_nsymbols 	: word,				! NUMBER OF SYMBOLS IN TABLE
    lnk$gw_lsymbols 	: word,				! NUMBER OF SYMBOLS IN THIS IMAGE
    lnk$gw_ncrosrfs 	: word,				! NUMBER OF CROSS REFERENCES ENTERED
    lnk$gw_nudfsyms 	: word,				! NUMBER OF UNDEFINED SYMBOLS
    lnk$gw_nlsyms 	: word,				! NUMBER OF MODULE-LOCAL SYMBOLS
    lnk$gw_nudflsyms 	: word,				! NUMBER OF UNDEFINED MODULE-LOCAL SYMBOLS
    lnk$gw_nudfenvs 	: word ;			! NUMBER OF UNDEFINED ENVIRONMENTS

own
    omd_has_dbg 	: byte initial (0),		! CURRENT OBJMOD HAS DBG RECORDS
    lastobjmod 		: ref block [, byte],		! POINTER TO LAST OBJ MODULE DESCRIPTOR
    weaktfradr 		: byte,				! TRUE IF CURRENT XFR ADDR IS WEAK
    lclsymgsd 		: byte,				! TRUE IF GSD SUBTYPE IS LOCAL SYMBOL
    wordpsectgsd 	: byte,				! TRUE IF GSD SUBTYPE HAS WORD OF PSECT NUMBER
    mhdseen 		: byte initial (0),		! FLAG MHD SUB-HEADER AS YET NOT SEEN
    lnmseen 		: byte initial (0),		! FLAG THAT COMPILER NAME SUB-HEADER IS SEEN
    lastrectyp 		: byte,				! TYPE OF THE PREVIOUS RECORD
    currectyp 		: byte initial (obj$c_eom),	! TYPE OF THE CURRENT RECORD
    gsdoffset 		: word,				! OFFSET INTO CONCATENATED GSD RECORD
    entrymask 		: word,				! ENTRY POINT MASK OF CURRENT SYMBOL
    maxreclng 		: word initial (obj$c_maxrecsiz), ! MAXIMUM LENGTH PERMISSIBLE IN THIS MODULE
    objrecdesc 		: block [dsc$c_s_bln, byte],	! STRING DESCRIPTOR FOR OBJECT RECORD
    symbolstring 	: ref vector [, byte],		! POINTER TO CURRENT SYMBOL
    symtabent 		: ref block [, byte],		! POINTER TO SYMBOL TABLE ENTRY
    symentnam 		: ref block [, byte],		! POINTER TO SYMBOL NAME BLOCK
    							! PART OF SYMBOL
    imageidstring 	: vector [sym$c_maxlng+1, byte],! DEFAULT IMAGE IDENT STORAGE
    obmodesc 		: block [omd$c_size, byte],	! STATIC COPY OF OBJECT MODULE DESCRIPTOR
    last_lnkopt_fdb 	: ref block [,byte]	;	! FDB OF LAST LNKOPT FILE FOR THIS MODULE

bind
    reclng = objrecdesc [dsc$w_length]  : word,			! SIZE OF RECORD READ
    objrec = objrecdesc [dsc$a_pointer] : ref block [, byte],	! NAME POINTER PART OF DESCRIPTOR
    objvec = objrecdesc [dsc$a_pointer] : ref vector [, byte],	! MUST ALSO ACCESS RECORD AS BYTE VECTOR
    recdispatch = plit (					! SET UP MAXIMUM ALLOWED RECORD TYPE (i.e., not uplit!)
			prohdr,					! 0 - MODULE HEADER
			progsd,					! 1 - GSD RECORDS
			seqchk,					! 2 - TIR - JUST CHECK CORRECT SEQUENCE
			proeom,					! 3 - END OF MODULE
			countdbg,				! 4 - DBG - CHECK SEQUENCE AND COUNT RECORDS AND BYTES
			countdbg,				! 5 - TBT - COUNT AND CHECK SEQUENCE O.K.
			prolnkrec) : vector ;			! 6 - OPTIONS RECORD

global bind
    lnk$gt_envstring = cstring ('Environment'),
    lnk$gt_modstring = cstring ('Module'),			! FOR THE ERROR MESSAGE
    lnk$gt_symstring = cstring ('Symbol'),
    lnk$gt_pscstring = cstring ('Psect'),
    lnk$gt_clustring = cstring ('Cluster'),
    lnk$gt_entity    = cstring ('Entity'),
    lnk$gt_ident     = cstring ('Ident'),
    lnk$gt_objnam    = cstring ('Entity type'),
    lnk$gt_sysver    = cstring ('SYS$K_VERSION') ;		! SYSTEM VERSION SYMBOL

!
routine dummy = return 1 ;					! FORCE BLISS TO PRINT THE
								! ABOVE DECLARATIONS

routine prolnkrec =
begin

	routine setup_include_list ( omdlstadr ) : novalue =
	begin
	!
	!  This routine sets up an include list (in simple linked
	!    list form) for modules in a library file spec
	!
	bind	lnkoptrec = .objrec : block [, byte];
	local	recptr,
		prevmodule,
		currentmodule;

	recptr = .objvec + $byteoffset (lnk$t_name)		! Point to module list in the
			 + .lnkoptrec[lnk$w_namlng] ;		!  LNKOPT record
	prevmodule = 0;
	while .(.recptr)<0,8> neq 0				! Count field of 0 is end of 
	do  begin						!   module list
	    lnk$alloblk ((.(.recptr)<0,8>)+5, currentmodule);	! Allocate memory for name
	    if .prevmodule eql 0				! If first module
	    then .omdlstadr  = .currentmodule			!   then set up list header
	    else .prevmodule = .currentmodule;			!   otherwise, just place in

	    prevmodule = .currentmodule;			!   linked list
	    ch$move (.(.recptr)<0,8>, .recptr+1, .currentmodule+5); 	! Move in name,
	    (.currentmodule+4)<0,8> = .(.recptr)<0,8>;			!   fill in length
	    .currentmodule	    =  0;
	    recptr 		    = .recptr + .(.recptr)<0,8> + 1;	! Move ptr to next module name
	    end;
	return;
	end;	

local
	lastfdb		: ref block [,byte],
	auxfnb		: ref block [,byte],
	input_fab	: block [fab$c_bln, byte],
	errorcode,
	next_fdb,
	filnamadr,
	fildesblk	: ref block [,byte];
bind 
	lnkoptrec = .objrec : block [, byte];
!
! PROCESS LINKER OPTIONS RECORD
!
if .lnkoptrec [lnk$b_lnktyp] gtr lnk$c_maxrectyp		! Valid subrecord type?
or .lnkoptrec [lnk$w_namlng] gtr nam$c_maxrss			! Reasonable-looking name length?
then return false;

lnk$alloblk (.lnkoptrec [lnk$w_namlng], filnamadr);		! allocate storage for filename
ch$move (.lnkoptrec [lnk$w_namlng] , lnkoptrec [lnk$t_name] , .filnamadr);
lnk$allofdb (fildesblk);
auxfnb = fildesblk [fdb$t_auxfnb];
$fab_init (fab = input_fab					! intialize the fab
	  ,fac = get						! for input
	  ,fop = sqo
	  ,shr = (upi,get,put)
	  ,fns = .lnkoptrec [lnk$w_namlng]
	  ,fna = .filnamadr
	  ,nam = .auxfnb
	  ,dns = 4
	  ,dna = ch$ptr (libfiltype)
	  );
fildesblk [fdb$w_usrnamlen] = .lnkoptrec [lnk$w_namlng];	! fill in file name
fildesblk [fdb$l_usrnamadr] = .filnamadr;			

select .lnkoptrec [lnk$b_lnktyp] of				! determine the file type
	set
	[lnk$c_olb,
	 lnk$c_oli] : fildesblk [fdb$v_libr]   	= true;			! all of these are libraries
	[lnk$c_olb] : fildesblk [fdb$v_libsrch] = true;			! olb to be searched
	[lnk$c_shr] : fildesblk [fdb$v_imglib]  = true;			! shareable image LIBRARY
	[lnk$c_oli] : begin						! object lib with include list
		      fildesblk [fdb$v_libextr] = true;	
		      fildesblk [fdb$v_libsrch] = .lnkoptrec [lnk$v_libsrch];
		      setup_include_list (fildesblk [fdb$l_omdlst]) ;	! put modules in linked list
		      end ;
	[lnk$c_obj] : begin						! regular object module
		      fildesblk [fdb$v_selser]  = .lnkoptrec [lnk$v_selser];
		      input_fab [fab$l_dna]     = ch$ptr (defiletype) ;
		      end ;
	[lnk$c_sha] : begin						! shareable image
		      fildesblk [fdb$v_shr]	= true;
		      input_fab [fab$l_dna]     = ch$ptr (shrfiltype) ;
		      end ;
	tes;	


if  .fildesblk[fdb$v_libr] or .fildesblk[fdb$v_imglib]		! if a library file
then begin
     $parse (fab=input_fab);					!   then fill in name block enough
     if (errorcode = $search (fab=input_fab))
     then begin							!    to do a library open by name block
	  local		savcurfil;
	  savcurfil     = .lnk$gl_curfil;			! set ptr to current fdb for the temporary benefit
	  lnk$gl_curfil = .fildesblk;
	  errorcode     =  lnk$openlib (.auxfnb);		!   of lnk$openlib
	  lnk$gl_curfil = .savcurfil;				! must now restore it 
	  end;
     end
else begin							! not a library file
     $getjpi (itmlst=lnk$gt_jpilst);
     if .lnk$gl_filesleft leq 3 then lnk$closefile ();		! close a file if needed
     errorcode = $open (fab=input_fab);				!     and try again
     fildesblk [fdb$w_ifi] = .input_fab [fab$w_ifi];		! save ifi
     end;


if not .errorcode 						!  if either of the opens was a failure,
then signal_stop (lin$_openin, 1				!    then signal and quit
		 ,lnk$filnamdsc (input_fab), .errorcode
		 ,.input_fab [fab$l_stv]
		 );

if .fildesblk [fdb$v_shr]					! Shareable image...?
then begin
     local	moduledsc : vector [2, long];

     moduledsc [0] = .auxfnb [nam$b_name];			! Shareable image spec: set up name
     moduledsc [1] = .auxfnb [nam$l_name];			!   and create its very own cluster 
     lnk$addimage (moduledsc);		
     end
else begin							! Not a shareable image spec
     if  .last_lnkopt_fdb eql 0					! if first LNKOPT rec for this file
     then last_lnkopt_fdb = .lnk$gl_curfil;			! set last_lnkopt_fdb to current file

     if  .lnk$gl_curclu[clu$l_lstfdb] eql .last_lnkopt_fdb	! If last fdb is last in current cluster
     then lnk$gl_curclu[clu$l_lstfdb] = .fildesblk; 		! then must update last cluster fdb

     next_fdb			    = .last_lnkopt_fdb [fdb$l_nxtfdb];  ! Save ptr to next fdb 
     last_lnkopt_fdb [fdb$l_nxtfdb] = .fildesblk;		! Point current to this new fdb 
     fildesblk [fdb$l_nxtfdb]	    = .next_fdb;		! Point new fdb to last
     last_lnkopt_fdb 		    = .fildesblk;		! Update fdb of last LNKOPT file
     end;
return true;
end;

routine checkpddentry (pdd) =
    begin
!
! ROUTINE CALLED BY LIB$TRAVERSE_TREE FOR EACH PSECT DEFINED BY OPTION
!
map
	pdd : ref block [, byte];
local
	psctdesc : ref block [, byte];

if (.pdd [pdd$b_namlng] and %x'80') eql 0			! IF NOT DEFINED YET
then begin
     lnk$fndpscnam (pdd [pdd$b_namlng], .pdd [pdd$w_flags] 	! THEN DO SO NOW
		   ,((.pdd [pdd$w_flags] and gps$m_gbl) neq 0)
		   ,psctdesc
		   );
      psctdesc [psc$w_flags] = .pdd [pdd$w_flags];		! SET THE FLAGS

     if  (psctdesc [psc$b_align] = .pdd [pdd$b_align]) eql %x'FF' ! AND THE ALIGNMENT
     then psctdesc [psc$b_align] = 0;
     end;

return true
end;

global routine lnk$insudfsym (symboladdr) : novalue =
    begin
!
!	THIS ROUTINE INSERTS AN UNDEFINED SYMBOL INTO THE LINKED LIST
!	OF UNDEFINED SYMBOLS.
!
map
	symboladdr : ref block [, byte];	! REALLY A POINTER
builtin
	insque;
local
	ch_result,
	listhead	: ref vector [, long],
	nxtsyment	: ref block [, byte];		! POINTER TO SYMBOL VALUE BLOCK
bind
	symbolname = .symboladdr 			! POINT TO NAME PART
			- .symboladdr [sym$b_namlng] 
			- snb$c_fxdlen 			: block [, byte];

!
!	FIND THE SPOT TO INSERT THE NEW SYMBOL IN THE UNDEFINED LIST
!
listhead = lnk$gl_udflst;
if .lclsymgsd then listhead = lnk$gl_udflsy;

nxtsyment = .listhead;					! SCAN THE UNDEFINED LIST

while (nxtsyment = .nxtsyment [sym$l_udflink]) neq .listhead 
do  begin
    bind  						! POINT TO NAME PART
	nxtsymnam = .nxtsyment - .nxtsyment [sym$b_namlng] 
				- snb$c_fxdlen 		: block [, byte];

    if (ch_result = ch$compare	(.nxtsymnam [snb$b_namlng] 	! IF GREATER
				, nxtsymnam [snb$t_name]
				,.symbolname [snb$b_namlng]
				, symbolname [snb$t_name]
				)
	) gtr 0
    then exitloop 					! THEN WE ARE ALL DONE
    else if .ch_result eql 0				! IF EQUAL
	 then return;					! THEN ALREADY IN LIST, SO RETURN
    end;

insque (symboladdr [sym$l_udflink], .nxtsyment [sym$l_udfblink]);	! INSERT IN UNDEFINED LIST

if not .symboladdr [sym$v_weak]				! IF NOT A WEAK REFERENCE
then if .lclsymgsd
     then lnk$gw_nudflsyms = .lnk$gw_nudflsyms + 1	! THEN COUNT AS UNDEFINED
     else lnk$gw_nudfsyms  = .lnk$gw_nudfsyms + 1;

return;
end;


routine seqchk =
!
!	ROUTINE WHICH VALIDATES THAT RECORDS ARE IN CORRECT SEQUENCE.
!	RETURNS VALUE FALSE IF NOT, TRUE OTHERWISE. ALSO TURNS OFF THE NO
!	BINARY FLAG WHEN A TIR RECORD IS SEEN.
!
begin
bind
	hdrsubtyp = objrec [obj$b_subtyp] : byte;

if .currectyp eql obj$c_hdr					! IF THIS RECORD IS A HEADER
then if .hdrsubtyp eql obj$c_hdr_mhd				! AND IT IS THE MAIN MODULE HEADER
     then 							! THEN WE HAVE VALID SEQUENCE
	  if (.lastrectyp eql obj$c_eom)			! IF AND ONLY IF THE PREVIOUS WAS END OF MODULE
	  or (.lastrectyp eql obj$c_eomw)
	  then	begin
		mhdseen = true; 
		lnmseen = false; 
		return true					! IS THIS CASE SET MHD RECORD SEEN AND RETURN
		end
	  else	begin
		signal  (lin$_seqnce, 2			 	! ELSE REPORT ERROR
			,obmodesc [omd$b_namlng]
			,lnk$gl_curfil [fdb$q_filename]
			);
		return false;
		end
     else if .mhdseen						! IF SOME OTHER KIND OF HEADER
	  then	(if .hdrsubtyp eql obj$c_hdr_lnm		! WE MUST HAVE SEEN A MAIN HEADER
		 then lnmseen = true; 
		 return true
		)
	  else	begin
		signal	(lin$_seqnce, 2			 	! ELSE REPORT ERROR
			,obmodesc [omd$b_namlng]
			,lnk$gl_curfil [fdb$q_filename]
			);
		return false;
		end
else if .mhdseen and .lnmseen
     then begin							! IF WE HAVE SEEN A MAIN HEADER
	  if (.currectyp eql obj$c_eom)				! THEN TURN OFF FLAG ON END OF MODULE.
	  or (.currectyp eql obj$c_eomw)
	  then	mhdseen = false					! SEQUENCE ERROR IF HAVE NOT SEEN
	  else	if .currectyp eql obj$c_tir 
		then obmodesc [omd$v_nobin] = false;

	  return true;						! MAIN HEADER AND THIS IS NOT ONE.
	  end
     else begin
	  signal (lin$_seqnce, 2		 		! ELSE REPORT ERROR
		 ,obmodesc [omd$b_namlng]
		 ,lnk$gl_curfil [fdb$q_filename]
		 );
	  return false;
	  end;
end;


routine prohdr =
!++
!	PROCESS MODULE HEADER RECORDS AS FOLLOWS:
!		(1) VALIDATE SEQUENCE
!		(2) IGNORE ALL BUT MAIN MODULE HEADERS
!		(3) VERIFY STRUCTURE LEVEL IS LESS THAN
!		    OR EQUAL TO OBJ$C_STRLVL
!		(4) VERIFY MAXIMUM RECORD LENGTH
!		    PARAMETER IS LESS THAN OR EQUAL TO
!		    OBJ$C_MAXRECSIZ
!		(5) RECORD MAXIMUM RECORD LENGTH PARAMETER
!                   FOR CHECKING SUBSEQUENT RECORDS
!		(6) CHECK MODULE TITLE > 0 AND LESS THAN OR
!		    EQUAL TO SYM$C_MAXLNG CHARACTERS
!		(7) ALLOCATE AN OBJECT MODULE DESCRIPTOR
!		    AND PUT ON END OF THE LIST (WHOSE
!		    HEAD IS FILE DESCRIPTOR BLOCK).
!		(8) COPY IN THE MODULE TITLE
!		(9) INITIALIZE FLAGS AND P-SECTION COUNT IN
!			THE OBJECT MODULE DESCRIPTOR
!--
begin
bind
	mhdrec = .objrec : block [, byte] ;
local
	module_max_length ;

if not seqchk () then return false ;				! VALIDATE CORRECT SEQUENCE OF RECORD

if .objrec [obj$b_subtyp] neq obj$c_hdr_mhd then return true ;	! IGNORE ALL HEADERS EXCEPT MAIN ONES

lnk$gw_nmodules = .lnk$gw_nmodules + 1 ;			! COUNT THIS MODULE

if  .mhdrec [mhd$b_strlvl] gtru obj$c_strlvl			! COMPARE ITS OBJ FORMAT
then begin							! LEVEL AND IF BEYOND THIS AND GIVE UP
     signal (lin$_strlvl, 4
	    ,.mhdrec [mhd$b_strlvl], obj$c_strlvl
	    , mhdrec [mhd$b_namlng], lnk$gl_curfil [fdb$q_filename]
	    ) ;
     return false ;
     end ;

if (maxreclng = .mhdrec [mhd$w_recsiz]) gtru obj$c_maxrecsiz	! COMPARE MAX WITH MAX ALLOWED
then begin							! AND IF GREATER
     signal (lin$_illreclen, 3					! ISSUE ERROR MESSAGE
	    ,.maxreclng, mhdrec [mhd$b_namlng]
	    , lnk$gl_curfil [fdb$q_filename]
	    ) ;
     return false ;
     end ;

module_max_length = lnk$k_max_filename_length ;			! SETUP FOR ERROR REPORT
								! IN CASE mhd$b_namlng = 0
if .mhdrec [mhd$b_namlng] eql 0 				! CHECK MODULE NAME LENGTH
or begin							!  IS WITHIN LEGAL LIMITS...
   if   .lnk$gl_curclu [clu$v_shrimg]				! 1 to 39 for shareable images...
   then if .mhdrec [mhd$b_namlng] gtru lnk$k_max_filename_length
	then begin
	     module_max_length = lnk$k_max_filename_length ;
	     true
	     end
	else false
   else	if .mhdrec [mhd$b_namlng] gtru sym$c_maxlng		! 1 TO 31 FOR OBJECTS...
	then begin
	     module_max_length = sym$c_maxlng ;
	     true
	     end
	else false
   end
then
    begin							! AND IF NOT ISSUE ERROR
    signal ( lin$_illnamelen, 6, lnk$gt_modstring 		! MESSAGE AND QUIT
	   , mhdrec [mhd$b_namlng], .mhdrec [mhd$b_namlng]
	   ,.module_max_length, mhdrec [mhd$b_namlng]
	   , lnk$gl_curfil [fdb$q_filename]
	   ) ;
    return false ;
    end ;

obmodesc [omd$l_ownfdb]	  = .lnk$gl_curfil ;			! SET POINTER TO OWNING FDB
obmodesc [omd$l_modvbn]	  = .lnk$al_rab [rab$l_rfa0] ;		! THIS IS NOW THE LAST. CAPTURE THE
obmodesc [omd$w_bytoff]	  = .lnk$al_rab [rab$w_rfa4] ;		! MODULE'S RFA FOR LATER
obmodesc [omd$b_namlng]	  = .mhdrec [mhd$b_namlng] ;		! COPY THE STRING LENGTH

ch$copy (.mhdrec [mhd$b_namlng], mhdrec [mhd$t_name], 0 	! AND THE STRING ZERO FILLED
	 ,sym$c_maxlng, obmodesc [omd$t_name]) ;		! INTO THE DESCRIPTOR

obmodesc [omd$w_hipsct]   = -1 ;				! SET HIGHEST POSSIBLE P-SECTION NUMBER
obmodesc [omd$w_hienv]	  = -1 ;				! SET HIGHEST POSSIBLE ENVIRONMENT NUMBER
obmodesc [omd$b_flags]	  = omd$m_nopsct or omd$m_nobin		! FLAG NO P-SECTS AND NO BINARY YET
			                 or omd$m_noenv ;	!  AND NO ENVIRONMENTS DEFINED
obmodesc [omd$v_shrimg]	  = .lnk$gl_curfil [fdb$v_shr] ;	! EXTRACT THE SHAREABLE IMAGE ATTRIB 
								!  FROM FILE DESCRIPTOR
obmodesc [omd$v_selser]	  = .lnk$gl_curfil [fdb$v_selser] ;	! AS WELL AS THE SELECTIVE SEARCH ATTRIBUTE
obmodesc [omd$v_debuger]  = .lnk$gl_curfil [fdb$v_debuger] ;	! COPY DEBUGGER MODULE FLAG
obmodesc [omd$l_omdnum]   = .lnk$gw_nmodules ;			! SET MODULE NUMBER INTO DESCRIPTOR

if not .lnk$gl_ctlmsk [lnk$v_intfil]				! IF THIS IS NOT STARLET
then obmodesc [omd$v_mapmod] = true ;				! SET TO MAP THE MODULE ON PASS 2
	

    begin
    bind modidstring = mhdrec [mhd$t_name] + 			! POINT TO THE MODULE ID IN HEADER
		      .mhdrec [mhd$b_namlng] : vector [, byte],	! RECORD (COUNTED STRING)
	 modcredat    = modidstring [0] + 			!  POINT TO THE MODULE CREATION DATE/TIME
		      .modidstring [0] + 1   : vector [, byte] ;

    local bincredat : vector [2, long] ;

    if  .lnk$gl_curclu [clu$v_shrimg]				! IF THIS IS A SHAREABLE IMAGE THAT 
	  and 							! WAS PICKED UP FROM A 
	.(lnk$gl_curclu [clu$q_credat])<0, 32, 0> neq 0		! SHAREABLE IMAGE LIBRARY
    then begin							!  (CREDAT WILL BE 0 IF NOT)
	 lnk$bintim (modcredat, bincredat) ;			! CONVERT TIME TO BINARY

	 if  not .(lnk$gl_curclu [clu$l_gsmatch])<31, 1 ,0>	! IF HIGH BIT CLEAR THEN DO DATE CHECK
	 then if not ch$eql (8, bincredat, 8, lnk$gl_curclu [clu$q_credat])  	! IF THE DATES ARE DIFFERENT
	      then signal (lin$_datmismch, 4, bincredat			     	! THEN WARN THE USER, 
			  ,lnk$gl_curfil [fdb$q_filename]			! BUT CONTINUE
			  ,lnk$gl_curclu [clu$q_credat]
			  ,lnk$gl_curfil [fdb$q_libnamdsc]
			  ) ;
	 ch$fill (0, 8, lnk$gl_curclu [clu$q_credat]) ;		! ZERO QUADWORD DATE/TIME, SINCE IT 
	 end ;							! GETS REUSED

    if not .obmodesc [omd$v_debuger]				! IF THIS IS NOT A DEBUGGER MODULE
	and 
	(.lnk$gt_imgid [0] eql 0   or   .lnk$gl_tfrpsc eql 0)	! IF THERE IS NO IMAGE IDENT SET UP
    then begin
	 imageidstring [0] = minu (.modidstring [0]		! EXTRACT THE LENGTH MINIMIZED WITH
				  , sym$c_maxlng) ;		! MAXIMUM ALLOWED STRING LENGTH
	 if .imageidstring [0]  neq 0				! AND IF NOT NULL
	 then  ch$move	(.imageidstring [0]				! SAVE IT TILL END OF MODULE SO THAT WE
			, modidstring [1]				! MAY USE IT IF THIS HAS A TRANSFER
			, imageidstring [1]				! ADDRESS
			) ;
	 end ;
    end ;
return true ;
end ;								! OF MODULE HEADER PROCESSING


routine delete_psect (psectname, retdescadr) =
    begin
!
! THIS ROUTINE SEARCHES ALL CLUSTERS FOR ANOTHER DEFINITION OF THE
! NAMED GLOBAL PSECT.  IF ONE IS FOUND, IT IS DELETED (BY SETTING
! A FLAG IN THE DESCRIPTOR).  IF THE CLUSTER IT IS FOUND IN IS
! A SHAREABLE IMAGE, THEN AN ERROR MESSAGE IS ISSUED, SINCE A
! PSECT CANNOT BE CONTAINED IN TWO SHAREABLE IMAGES AT THE SAME
! TIME.
!
    map
	psectname : ref vector [, byte],
	retdescadr : ref vector [, long];
    local
	cludesc : ref block [, byte],
	fdb : ref block [, byte],
	pdesc : ref block [, byte];

    cludesc = lnk$gl_clulst;
!
! LOOP OVER ALL CLUSTERS, SEARCHING THE GLOBAL PSECT LIST FOR
! A MATCH
!

    while (cludesc = .cludesc [clu$l_nxtclu]) neq 0 do

	if lib$lookup_tree (cludesc [clu$l_gpslst], .psectname, lnk$compare_pscnod, pdesc) and not (pdesc =
	    .pdesc [node$l_ptr];		! GET PSECT DESCRIPTOR ADDRESS
	    .pdesc [psc$v_deleted])		! TEST IF PSECT HAS BEEN DELETED
	then
	    begin
	    pdesc [psc$v_deleted] = true;	! FLAG PSECT DELETED FROM THIS CLUSTER

	    if .cludesc [clu$v_shrimg]		! IF CLUSTER IS A SHAREABLE IMAGE
	    then
		begin
		fdb = .cludesc [clu$l_fstfdb];	! GET FDB ADDRESS FOR SHAREABLE IMAGE
		signal (lin$_mulshrpsc, 3, .psectname, 	! ISSUE ERROR MESSAGE
		    fdb [fdb$q_filename], lnk$gl_curfil [fdb$q_filename], lin$_noimgfil);
		lnk$gl_ctlmsk [lnk$v_image] = false;	! IMAGE WOULD ONLY BE INVALID
		end;

	    retdescadr [0] = .pdesc;		! RETURN ADDRESS TO CALLER
	    return true;
	    end;

    return false
    end;

routine fndpscmapent (psctnum, omdptr) =
    begin
!
!	THIS ROUTINE RETURNS THE ADDRESS OF THE MAPPING
!	TABLE ENTRY FOR P-SECTION NUMBER "PSCTNUM" IN
!	THE CURRENT MODULE.
!	THE P-SECT MAPPING TABLE IS AN ARRAY APPENDED
!	TO THE MODULE DESCRIPTOR BLOCK. IT IS INITIALLY
!	ALLOCATED WITH SPACE SUFFICIENT FOR 256
!	ENTRIES.  IF MORE THAN 256 PSECTS ARE ENCOUNTERED DURING
!	THE PROCESSING OF THE OBJECT MODULE, THE INITIAL TABLE IS
!	COPIED OUT TO ANOTHER BLOCK, AND THE MAP TABLE APPENDED TO
!	THE OBJECT MODULE DESCRIPTOR BLOCK IS A TABLE OF TABLE ADDRESSES.
!
!	THE SECOND ARGUMENT IS OPTIONAL.  IF NOT SUPPLIED, THE OWN OBJ MODULE
!	DESCRIPTOR (OBMODESC) WILL BE USED.
    literal
	tablesize = 256*pmt$c_size;		! SIZE IN BYTES OF A BLOCK
    local
	blockoff,				! OFFSET OF ENTRY IN EXTENDED BLOCK
	first_entry : ref block[, byte],
	omdesc : ref block [, byte],		! POINTER TO OBJ MODULE DESCRIPTOR
	mapent : ref block [, byte],		! ADDRESS IN PSECT MAPPING TABLE
	first256 : ref block [,byte],		! address of block of first 256
	mapoff : ref block [, byte];		! ADDRESS OF EXTENDED MAPPING BLOCK
    builtin
	nullparameter;

    if nullparameter (2)			! SETUP POINTER TO OBJ MODULE DESCRIPTOR
    then
	omdesc = obmodesc
    else
	omdesc = .omdptr;

    mapent = omdesc [omd$t_pscmap] + .psctnum*pmt$c_size;	! GET ENTRY ADDRESS IN BASE MAPPING TABLE

    if not .omdesc [omd$v_p256]			! IF NOT INTO EXTENDED MAP TABLE
	and .psctnum lequ 255			!  AND LEQU 255 PSECTS
    then
	return .mapent
!
! EXTENDED PSECT ENTRY
!
    else
	begin
	blockoff = (.psctnum mod 256)*pmt$c_size;	! OFFSET OF ENTRY WITHIN EXTENDED TABLE
	mapent = omdesc [omd$t_pscmap] + (.psctnum/256)*pmt$c_size;
						! GET ADDRESS OF EXTENDED TABLE ADDRESS

	if ..mapent neq 0			! IF EXTENDED TABLE PRESENT
	    and .omdesc [omd$v_p256]		!  AND THERE REALLY IS AN EXTENDED TABLE
	then
	    return ..mapent + .blockoff		!  THEN RETURN ENTRY ADDRESS
	else
	    begin
	    lnk$alloblk (tablesize, mapoff);	! ALLOCATE EXTENDED TABLE BLOCK

	    if not .omdesc [omd$v_p256]		! IF THIS IS THE FIRST ONE
	    then
		begin
		first_entry = omdesc[omd$t_pscmap];
		lnk$alloblk(tablesize,first256);			! first, allocate space for first 256 entries
		ch$move(tablesize,omdesc[omd$t_pscmap],.first256);	! move data for first 256
		ch$fill (0, tablesize, omdesc [omd$t_pscmap]);		! ZERO BASE TABLE
		first_entry[pmt$l_secpmt] = .first256;
		omdesc [omd$v_p256] = true;				! FLAG INTO EXTENDED TABLE
		end;

	    ch$fill (0, tablesize, .mapoff);	!  ZERO NEW BLOCK

	    !
	    ! POINT ENTRY IN BASE TABLE TO NEW BLOCK
	    !
	    mapent [pmt$l_secpmt] = .mapoff;
	    return .mapoff + .blockoff
	    end;
	end;
    end;

routine alloc_omdnode (omdnum, retnodeadr, omdesc) =
!
! THIS ROUTINE IS CALLED BY LIB$INSERT_TREE TO ALLOCATE
! STORAGE FOR A NODE
!
begin
map
	retnodeadr	: ref vector [, long],
	omdesc		: ref block [, byte];
local
	node		: ref block [, byte];

lnk$alloblk (node$c_long, node);			! ALLOCATE A NODE
node [node$l_ptr] = .omdesc;				! POINT TO OBJ MODULE DESCRIPTOR
retnodeadr [0]    = .node;				! RETURN ADDRESS TO CALLER
return true
end;


global routine lnk$compare_omd (omdnum, curnode, omdesc) =
!
! THIS ROUTINE IS CALLED BY LIB$INSERT_TREE AND LIB$LOOKUP_TREE
! TO COMPARE CURRENT NODE WITH THE NUMBER WE ARE LOOKING FOR
!
begin
map
	curnode : ref block [, byte];
bind
	curomd = .curnode [node$l_ptr] : block [, byte];

if .omdnum lss .curomd [omd$l_omdnum]			! COMPARE THIS WITH CURRENT NODE
then return -1						! RETURN -1 IF LSS
else if .omdnum eql .curomd [omd$l_omdnum]		! IF EQUAL
     then return 0					!  THEN RETURN 0
     else return 1					!  ELSE IT'S GTR, RETURN 1
end;


routine propsectdef =
    begin
!++
!	PROCESS P-SECTION DEFINITIONS AS FOLLOWS:
!		(0) CHECK LEGAL P-SECTION NAME AND ALIGNMENT PARAMETER
!		(1) SEARCH FOR P-SECTION DEFINED
!		(2) IF DEFINED:
!			1. CHECK COMPATIBLE ATTRIBUTES
!			2. IF OVERLAYED, CHECK EQUAL ALIGNMENT
!			3. MAXIMIZE P-SECTIONS'S BASE ALIGNMENT
!			4. GO TO (3)
!		    IF NOT DEFINED:
!			1. INSERT IN P-SECTION LIST
!			2. COPY FLAGS AND ALIGNMENT
!		(3) ALLOCATE A MODULE CONTRIBUTION ENTRY AND INSERT
!			IT LEXICALLY IN THE LIST BY MODULE NAME
!		(4) UPDATE CURRENT BASE BY THIS ALIGNMENT THEN COPY
!			CURRENT BASE INTO MAPPING TABLE ENTRY
!		(5) ADD THAT ROUND UP TO PSECTIONS ACCUMULATED LENGTH
!		(6) ADD P-SECTIONS LENGTH CONTRIBUTION TO THE ACCUMULATION
!			IF CONCATENATED. IF OVERLAYED, MAXIMIZE LENGTH.
!		(7) COPY CONTRIBUTION LENGTH INTO MAPPING TABLE ENTRY
!		(8) COPY ALIGNMENT INTO MAPPING TABLE
!		(9) COPY MODULE DESCRIPTOR ADDRESS INTO MAPPING TABLE
!		(10) COUNT THIS P-SECTION AND CLEAR NO P-SECTIONS FLAG
!		(11) IF NECESSARY EXTEND MODULE DESCRIPTOR FOR ANOTHER
!			P-SECTION AND INSERT ADDRESS OF P-SECTION
!			IN TABLE.
!		(12) IF ANY PREMATURE SYMBOL DEFINITIONS, REMOVE EACH FROM
!			LIST, ADDING P-SECTION BASE TO RELOCATABLE VALUES
!			AND LINKING THEM ON THE P-SECION'S LIST OF SYMBOLS
!--
    local
	psctdesc : ref block [, byte],		! CURRENT P-SECT DESCRIPTOR
	modpscontriblk : ref block [, byte],	! MODULE CONTRIBUTION DATA BLOCK
	lastmodpscontriblk : ref block [, byte],
	psectname : ref vector [, byte],	! POINTER TO PSECT NAME
	newpsect,				! TRUE IF NEW PSECT
	sgpstype,				! TRUE IF GSD$C_SGPS
	pscope,					! P-SECTION SEARCH SCOPE
	psflags,
	prevdfound,				! TRUE IF PREV. DEF. OF COMMON FROM SHR IMAGE
	delpscdesc : ref block [, byte],	! POINTER TO DELETED PSECT DESCRIPTOR
	psctmapent : ref block [, byte],	! P-SECTION MAPPING TABLE ENTRY
	around,					! ROUND UP FOR ALIGNMENT
	pddptr : ref block [, byte],
	localpdd : block [pdd$c_size, byte],
	premsymlst,				! SAVE PREMATURE SYMBOL LIST
	premsym : ref block [, byte];		! PREMATURELY DEFINED SYMBOL

    bind
	length = around,
	psctdef = objvec [.gsdoffset] : block [, byte];

!
! DETERMINE WHICH PSECT SUBRECORD TYPE THIS IS
!
    sgpstype = false;

    if .psctdef [gps$b_gsdtyp] eql gsd$c_psc
    then
	psectname = psctdef [gps$b_namlng]
    else
	begin
	psectname = psctdef [sgps$b_namlng];	! SHAREABLE IMAGE PSECT
	sgpstype = true;
	end;

!
!	FIRST CHECK FOR LEGAL P-SECTION NAME
!

    if .psectname [0] gtru sym$c_maxlng		! CHECK NAME WITHIN THE LEGAL
	or .psectname [0] eql 0			! RANGE FOR SYMBOL AND P-SECTION
    then
	begin
	signal (lin$_illnamelen, 6, 		! NAMES AND IF NOT
	    lnk$gt_pscstring, .psectname, .psectname [0], sym$c_maxlng, 	! ISSUE AN ERROR MESSAGE
	    obmodesc [omd$b_namlng], lnk$gl_curfil [fdb$q_filename]);
	return false;
	end;

!
! SEE IF PSECT DEFINED BY OPTION
!
    ch$fill (0, pdd$c_size, localpdd);		! ZERO ALL FIELDS IN LOCAL PDD
    localpdd [pdd$b_align] = %x'FF';		! SET ITS ALIGNMENT TO ALL ONES
    pddptr = localpdd;				! PRESET IN CASE NOT FOUND
    psflags = .psctdef [gps$w_flags];		! ASSUME NOT DEFINED BY OPTION

    if lnk$srcpscdef (.psectname, pddptr)	! SEE IF DEFINED BY OPTION
    then
	begin
	pddptr [pdd$b_namlng] = .pddptr [pdd$b_namlng] or %x'80';	! AND IF SO, MARK AS DEFINED
	psflags = .pddptr [pdd$w_flags] or 	! SET THE FLAGS
	(.psflags and not .pddptr [pdd$w_flgmsk]);	! QUALIFIED BY THE MASK
	end;

!
! IF THIS IS A SHAREABLE IMAGE CLUSTER AND THIS IS A GLOBAL PSECT
! (COMMON), THEN SEE IF DEFINED SOMEWHERE ELSE
!

    if .lnk$gl_curclu [clu$v_shrimg] and (.psctdef [gps$w_flags] and psc$m_shrbits) eql psc$m_shrbits
    then
	prevdfound = delete_psect (.psectname, delpscdesc)
    else
	prevdfound = false;

!
! CHECK ALIGNMENT
!

    if .psctdef [gps$b_align] gtru obj$c_pscalilim	! IF THE ALIGNMENT IS GREATER
    then
	begin
	signal (lin$_pscali, 4, .psectname, .psctdef [gps$b_align], 	! THAN THE MAXIMUM, ISSUE
	    obmodesc [omd$b_namlng], lnk$gl_curfil [fdb$q_filename]);	! ERROR AND QUIT
	psctdef [gps$b_align] = obj$c_pscalilim;	! USE OBJ LANG MAX
	end;

!
!	SEARCH FOR P-SECTION DEFINED, CREATING DESCRIPTOR IF NOT.
!

    if .obmodesc [omd$v_shrimg]			! IF THIS IS A SHAREABLE IMAGE
    then
	pscope = 0				! THEN P-SECTION SEARCH IS ONLY IN THIS CLUSTER
    else

	if (pscope = .psctdef [gps$v_gbl]) eql 0	! ELSE DEPENDS ON PSECT SCOPE
	then
	    pscope = .pddptr [pdd$w_flags] and gps$m_gbl;	! OR OPTION DEFINITION SCOPE

    if lnk$fndpscnam (.psectname, .psflags, .pscope, psctdesc)	! GET DESCRIPTOR ADDRESS
	and .psctdesc [psc$v_usrpsc]		! AND PSECT WAS SEEN IN SOURCE
    then
	begin					! AND IF FOUND
	newpsect = false;

! ** THIS CHECK DISABLED UNTIL C ISSUE RESOLVED
!
!	if .psctdesc [psc$l_omdnum] eql .lnk$gw_nmodules	! IF PSECT ALREADY DEFINED IN THIS MODULE
!	then signal (lin$_muldefpsc, 3			 	!  THEN ISSUE A WARNING MESSAGE
!		    ,psctdesc [psc$b_namlng]
!		    ,obmodesc [omd$b_namlng]
!		    ,lnk$gl_curfil [fdb$q_filename]
!		    );
!
! ** END OF DISABLED CODE

	psctdesc [psc$l_omdnum] = .lnk$gw_nmodules;	! SET DEFINED IN CURRENT MODULE

	if not .psctdesc [psc$v_optpsc]			! IF PSECT NOT MODIFIED BY OPTION
	then
	    begin

	    if .psctdef [gps$w_flags] neq ((.psctdesc [psc$w_flags]	! CHECK COMPATIBLE
		and not (psc$m_supres or psc$m_usrpsc)) and psc$m_pscbits)
	    then
		signal (lin$_mulpsc, 3, 				! ATTRIBUTES, ISSUING ERROR
		    .psectname, obmodesc [omd$b_namlng], 		! IF NOT
		    lnk$gl_curfil [fdb$q_filename]);

	    if .psctdesc [psc$v_ovr]					! IF OVERLAYED
	    then

		if .psctdef [gps$b_align] neq .psctdesc [psc$b_align]	! CHECK EQUAL
		then
		    signal (lin$_ovrali, 3, 	! ALIGNMENT
			.psectname, obmodesc [omd$b_namlng], lnk$gl_curfil [fdb$q_filename]);

	    end;				! PSECT NOT MODIFIED BY OPTION

	if .psctdef [gps$b_align] gtru .psctdesc [psc$b_align]	! MAXIMIZE
	    and .pddptr [pdd$b_align] eql %x'FF'
	then
	    psctdesc [psc$b_align] = .psctdef [gps$b_align];	! THE ALIGNMENT

	end
!
!	P-SECTION IS NOT YET DEFINED - SO DO THAT
!
    else
	begin					! AND INSERT P-SECTION
	lnk$gw_npsects = .lnk$gw_npsects + 1;	! AFTER COUNTING IT
	newpsect = true;
	psctdesc [psc$b_align] = .pddptr [pdd$b_align];	! SET THE ALIGNMENT FROM PDD

	if .psctdesc [psc$b_align] eql %x'FF'	! BUT IF NONE SPECIFIED
	then
	    psctdesc [psc$b_align] = .psctdef [gps$b_align];	! THEN USE INPUT FILE

	psctdesc [psc$w_flags] = .psflags;	! SET THE FLAGS
	psctdesc [psc$v_usrpsc] = true;		! FLAG DEFINED BY USER SOURCE
	psctdesc [psc$v_shrimg] = .lnk$gl_curclu [clu$v_shrimg];
						! PROPOGATE SHR IMG FLAG INTO PSECT DESCRIPTOR
	psctdesc [psc$v_newdef] = .sgpstype;	! REMEMBER IF SGPS DEFINITION

	if .lnk$gl_ctlmsk [lnk$v_shr]		! IF CREATING A SHAREABLE IMAGE
	    and not .obmodesc [omd$v_shrimg]	!  AND THIS IS NOT A SHAREABLE IMAGE INPUT MODULE
	    and (.psctdesc [psc$w_flags] and psc$m_shrbits)
						!  AND IF PSECT WILL BE OUTPUT TO SHAREABLE IMAGE
	    eql psc$m_shrbits			! (MUST BE RELOCATABLE, GLOBAL AND OVERLAID
	then
	    begin
	    lnk$gl_pshrnum = .lnk$gl_pshrnum + 1;	! THEN COUNT IT FOR LNKSYMOUT

	    if .lnk$gl_pshrnum eql lnk$c_maxpsects + 1	! IF THERE ARE TOO MANY
	    then
		signal_stop (lin$_excpsc, 2, obmodesc [omd$b_namlng], lnk$gl_curfil [fdb$q_filename],
		    lin$_format);

	    end;

	if .lnk$gl_ctlmsk [lnk$v_intfil]	! IF THIS IS THE INTERNAL (SYSLIB) FILE
	    and .lnk$gl_ctlmsk [lnk$v_supsys]	! AND SYSLIB SUPPRESSION IS ON
	then
	    psctdesc [psc$v_supres] = true;	! THEN SUPPRESS THIS P-SECTION

	if .obmodesc [omd$v_shrimg]		! IF A SHAREABLE IMAGE P-SECTION
	then

	    if .sgpstype
	    then
		psctdesc [psc$l_base] = .psctdef [sgps$l_base]
	    else
		psctdesc [psc$l_base] = .psctdef [gps$l_alloc];

						! ITS BASE IS GIVEN BY SIZE FIELD IF NORMAL PSECT DEF
	end;

!
! IF THIS IS A SHAREABLE IMAGE PSECT THAT WAS FOUND ELSEWHERE,
! WE HAVE TO RUN AROUND AND FIX UP THE POINTERS IN THE PSECT
! MAPPING TABLES FOR THE PREVIOUS DEF. TO POINT TO THIS NEW
! DEFINITION.  ALSO, PUT THE OLD PSECT MAPPING LIST ONTO THE
! NEW DESCRIPTOR
!

    if .prevdfound
    then
	begin
	modpscontriblk = .delpscdesc [psc$l_mpclst];	! GET MPC LIST POINTER
	psctdesc [psc$l_mpclst] = .modpscontriblk;	! SET INTO NEW DESCRIPTOR
	psctdesc [psc$l_lstmpc] = .delpscdesc [psc$l_lstmpc];	! COPY END OF LIST POINTER

	while .modpscontriblk neq 0 do
	    begin
	    psctmapent = fndpscmapent (.modpscontriblk [mpc$w_pscnum], 	! FIND PSECT MAPPING ENTRY
		.modpscontriblk [mpc$l_ownomd]);
	    psctmapent [pmt$l_pscdes] = .psctdesc;	! SET POINTER TO NEW DESCRIPTOR
	    modpscontriblk = .modpscontriblk [mpc$l_nxtmpc];
	    end;

	end;

!
!	NOW TO CREATE A BLOCK OF DATA DESCRIBING THIS
!	MODULE'S CONTRIBUTION TO THE P-SECTION, LINK THE
!	BLOCK TO END OF THE P-SECTION MODULAR CONTRIBUTION LIST
!	AND POINT MODULE DESCRIPTOR
!	MAPPING TABLE ENTRY AT THIS BLOCK.
!
    lnk$alloblk (mpc$c_size, modpscontriblk);			! ALLOCATE THE BLOCK
    ch$fill ( 0, mpc$c_size, .modpscontriblk );			!  (make sure it's clean)
    modpscontriblk [mpc$l_ownomd] = .obmodesc [omd$l_nxtomd];	! LINK INTO TEMP LIST
    obmodesc [omd$l_nxtomd] = .modpscontriblk;			! TO BE FIXED UP AT PROEOM TIME
    lastmodpscontriblk = .psctdesc [psc$l_lstmpc];		! GET POINTER TO LAST CONTRIB. BLOCK FOR PSECT

    if .lastmodpscontriblk neq 0				! IF THERE IS A LAST
    then
	lastmodpscontriblk [mpc$l_nxtmpc] = .modpscontriblk;	! THEN LINK NEW BLOCK INTO LIST

    psctdesc [psc$l_lstmpc] = .modpscontriblk;			! AND MAKE IT THE NEW LAST.
!

    if .obmodesc [omd$w_hipsct] eql lnk$c_maxpsects	! IF TOO MANY PSECTS ALREADY
	and not .obmodesc [omd$v_nopsct]
    then 					! BEEN SEEN FOR THIS MODULE
	signal_stop (lin$_excpsc, 2, 		! ISSUE AN ERROR MESSAGE AND GIVE UP
	    obmodesc [omd$b_namlng], lnk$gl_curfil [fdb$q_filename], lin$_format);

!
    obmodesc [omd$v_nopsct] = false;		! CLEAR NO PSECTS FLAG
    obmodesc [omd$w_hipsct] = .obmodesc [omd$w_hipsct] + 1;	! COUNT NEW P-SECTION
    modpscontriblk [mpc$w_pscnum] = .obmodesc [omd$w_hipsct];	! SAVE PSECT NUMBER IN MPC
    psctmapent = fndpscmapent (.obmodesc [omd$w_hipsct]);	! GET MAP TABLE ENTRY
    premsymlst = .psctmapent [pmt$l_symlst];	! SAVE PREMATURE SYMBOL LIST
    psctmapent [pmt$l_pscdes] = .psctdesc;	! POINT IT TO PSECTION DESCRIPTOR
    psctmapent [pmt$l_modcon] = .modpscontriblk;	! AND TO THE NEW CONTRIBUTION BLOCK.
    modpscontriblk [mpc$b_align] = .psctdef [gps$b_align];	! COPY ITS ALIGNMENT
    modpscontriblk [mpc$l_offset] = 0;		! ASSUME ABSOLUTE AND/OR OVERLAYED
    						! AND THUS 0 OFFSET CONTRIBUTION

    if .psctdesc [psc$v_rel]			! THAT IS ALL FOR ABSOLUTE
    then
	begin					! P-SECTIONS

	if not .psctdesc [psc$v_ovr]		! IF A CONCATENATED PSECT NOT FROM SHR IMAGE
	    and not .obmodesc [omd$v_shrimg]
	then
	    begin
	    around = (1^.psctdef [gps$b_align]) - 1;
	    modpscontriblk [mpc$l_offset] = (.psctdesc [psc$l_base] + .around)
						! ADD IN THE ROUNDING AND TRUNCATE
	    and not .around;
	    around = .modpscontriblk [mpc$l_offset] - .psctdesc [psc$l_base];	! THEN COMPUTE AMOUNT ADDED
	    psctdesc [psc$l_base] = .psctdesc [psc$l_base] + .around + 	! UPDATE THE BASE FOR NEXT
	    .psctdef [gps$l_alloc];		! CONTRIBUTOR.
	    psctdesc [psc$l_length] = .psctdesc [psc$l_base];	! WHICH IS ALSO TOTAL LENGTH
	    end
	else
	    begin				! FOR OVERLAYED

	    local
		omd : ref block [, byte],
		fdb : ref block [, byte];

	    if (.sgpstype			! IF SHAREABLE IMAGE PSECT TYPE
		and .psctdesc [psc$v_ovr] and .prevdfound	!  AND IT WAS DEFINED BEFORE IN OBJ MODULE
		and (.delpscdesc [psc$l_length] gtru .psctdef [sgps$l_alloc]))
						! TO BE LARGER THAN ONE IN SHR IMG
	    then
		begin
		lib$lookup_tree (lnk$gl_omdtree, .delpscdesc [psc$l_omdnum], 	! FIND DEFINING MODULE OMD
		    lnk$compare_omd, omd);
		omd = .omd [node$l_ptr];	! POINT TO OMD FROM NODE
		fdb = .omd [omd$l_ownfdb];	! GET POINTER TO FDB FOR MODULE
		signal (lin$_shrpsclng, 6, .psectname, .delpscdesc [psc$l_length], omd [omd$b_namlng],
		    fdb [fdb$q_filename], .psctdef [sgps$l_alloc], lnk$gl_curfil [fdb$q_filename],
		    lin$_noimgfil);
		lnk$gl_ctlmsk [lnk$v_image] = false;	! DISABLE IMAGE PRODUCTION
		end;

	    if (.psctdesc [psc$v_shrimg] and .psctdesc [psc$v_newdef]	! IF PSECT DEFINED IN SHAREABLE IMAGE
		and .psctdesc [psc$v_ovr] and not .newpsect	! AND THIS IS NOT FIRST DEFINITION
		and (.psctdef [gps$l_alloc] gtru .psctdesc [psc$l_length]))
						! AND THIS DEFINITION IS BIGGER THAN SHR IMAGE ONE
	    then
		begin				! THAT IS AN ERROR
		fdb = .psctdesc [psc$l_cludsc];	! GET CLUSTER DESCRIPTOR POINTER
		fdb = .fdb [clu$l_fstfdb];	! GET POINTER TO FDB FOR SHAREABLE IMAGE
		signal (lin$_shrpsclng, 6, .psectname, .psctdef [gps$l_alloc], 	! SIGNAL THE PROBLEM
		    obmodesc [omd$b_namlng], lnk$gl_curfil [fdb$q_filename], .psctdesc [psc$l_length],
		    fdb [fdb$q_filename], lin$_noimgfil);
		lnk$gl_ctlmsk [lnk$v_image] = false;	! TURN OFF THE IMAGE
		end;

	    if not .obmodesc [omd$v_shrimg]	! IF NOT A SHAREABLE IMAGE
	    then
		begin

		if .psctdef [gps$l_alloc] gtru .psctdesc [psc$l_length]	! P-SECTION MAXIMIZE
		then
		    psctdesc [psc$l_length] = .psctdef [gps$l_alloc];	! THE ALLOCATION

		end
	    else
		begin

		if .sgpstype			! IF SPECIAL SHAREABLE IMAGE PSECT
		then
		    psctdesc [psc$l_length] = .psctdef [sgps$l_alloc];	!  THEN SET LENGTH OF PSECT

		end;

	    end;

	if not .obmodesc [omd$v_shrimg]
	then
	    begin
	    modpscontriblk [mpc$l_length] = .psctdef [gps$l_alloc];	! SET MODULE'S CONTRIBUTION
	    obmodesc [omd$l_alloc] = .obmodesc [omd$l_alloc] + 	! FINALLY ACCUMULATE THE CONTRIBUTION
	    .modpscontriblk [mpc$l_length];
	    end;

	end;

!
!	NOW GO DOWN THE LIST OF PREMATURE SYMBOLS
!		(THOSE AWAITING DEFINITION OF THIS PSECTION)
!		AND RELOCATE THEM (IF THEY ARE RELOCATABLE)
!		AND THEN LINK THEM ON TO THE P-SECTON LIST
!

    while (premsym = .premsymlst) neq 0 do 	! RELOCATABLE AND THERE
	begin					! ARE SOME PREMATURE

	if .premsym [sym$v_rel]			! FOR EACH THAT IS RELOCATABLE
	then
	    premsym [sym$l_value] = .premsym [sym$l_value] + 	! ADD IN THE BASE OFFSET
	    .modpscontriblk [mpc$l_offset];	! OF THE MODULE'S

	premsymlst = .premsym [sym$l_psclst];	! TAKE IT OFF LIST
	premsym [sym$l_psclst] = .psctdesc [psc$l_symlst];	! AND PUT ON THE
	psctdesc [psc$l_symlst] = .premsym;	! P-SECTION SYMBOL LIST
	end;

!
! COMPUTE LENGTH OF THIS GSD SUBRECORD
!

    if .sgpstype
    then
	length = psctdef [sgps$t_name] - psctdef [sgps$t_start] + .psectname [0]
    else
	length = psctdef [gps$t_name] - psctdef [gps$t_start] + .psectname [0];

    gsdoffset = .gsdoffset + .length;		! UPDATE GSD OFFSET INTO RECORD
    return true;
    end;					! OF P-SECTION PROCESSOR

routine crefilter (definition, weakflag, altomd) =
    begin
!
!	THIS ROUTINE FILTERS FROM THE CROSS REFERENCE THE SYMBOLS
!	OF THE DEBUGGER AND ALSO MASKS THEM FROM APPEARING IN ANY
!	OTHER SYMBOL TABLE OUTPUT. (STB FILE OR GST OF IMAGE)
!
!	IT ALSO DECIDES IF ANY CROSS REFERENCE IS TO BE DONE
!	AT ALL.
!
!	THE ARGUMENT "DEFINITION" HAS VALUE TRUE OR FALSE.
!
    map
	altomd : ref block [, byte];
    builtin
	nullparameter;
    bind
	objmodesc = (if nullparameter (3) then obmodesc	! IF NOT SPECIFIED, THEN USE THE LOCAL ONE
	    else .altomd) : block [, byte];	! IF SPECIFIED, USE IT

    if .symtabent [sym$v_lclsym]		! NO CROSS REF OF MODULE LOCAL SYMBOLS
    then
	return true;

    if .lnk$gl_curfil [fdb$v_debuger]		! IF THIS FILE CONTAINS THE DEBUGGER
    then
	begin

	if .definition				! AND IF THIS IS A DEFINITION
	then
	    symtabent [sym$v_supres] = true;	! SUPPRESS IT FROM STB OUTPUT

	if .lnk$gl_ctlmsk [lnk$v_supdbg]	! IF ALSO SUPRESSING
	then
	    return true;			! DEBUGGER SYMBOLS FROM MAP

	end;					! THAT IS ALL

    if .lnk$gl_ctlmsk [lnk$v_brief]		! IF A BRIEF MAP THEN
    then
	return true;				! ALSO ALL DONE

    if .lnk$gl_ctlmsk [lnk$v_intfil]		! IF THIS IS THE INTERNAL (SYSLIB) FILE
	and .lnk$gl_ctlmsk [lnk$v_supsys]	! AND ITS CONTENTS ARE SUPPRESSED
    then

	if not .lnk$gl_ctlmsk [lnk$v_cros]	! IF NO CROSS REFERENCE
	    or not .definition			! OR THIS IS A REFERENCE
	    or .symtabent [sym$v_supres]	! OR THE SYMBOL HAS BEEN SUPPRESSED
	then
	    return true				! THEN ALL DONE
	else
	    objmodesc [omd$v_mapmod] = true;	! BUT IF SYMBOL IS ENTERED MAKE SURE MODULE GETS MAPPED

    if (.definition or .lnk$gl_ctlmsk [lnk$v_cros])	! IF WE ARE GOING TO CREF THIS SYMBOL
    then
	begin

	if .symentnam [snb$b_namlng] gtr .lnk$gl_maxsymsz
						! IF THIS SYMBOL NAME IS BIGGER THAN BIGGEST SEEN
	then
	    lnk$gl_maxsymsz = .symentnam [snb$b_namlng];	!  THEN MAKE THIS THE BIGGEST

	if .objmodesc [omd$b_namlng] gtr .lnk$gl_maxmodsz	! ALSO CHECK THE MODULE NAME LENGTH
	then
	    lnk$gl_maxmodsz = .objmodesc [omd$b_namlng];

	end;

    if .definition				! IF THIS IS A DEFINITION MUST
    then
	begin
	crf$insrtkey (lnk$al_sytblfmt, symentnam [snb$b_namlng], 	! AT LEAST ENTER THE VALUE
	    symtabent [sym$l_value], .symtabent [sym$w_flags]);
						! BY ADDRESS AND PASSING THE FLAGS AS VALUE FLAGS
	symtabent [sym$v_crosref] = true;	! FLAG SYMBOL HAS BEEN CROSS REFERENCED IF DEFINITION
	end;

    if .lnk$gl_ctlmsk [lnk$v_cros]		! IF A CROSS REFERENCE IS BEING PRODUCED
    then
	begin
	crf$insrtref (lnk$al_sytblfmt, symentnam [snb$b_namlng], 	! THEN INSERT THIS REFERENCE
	    objmodesc [omd$b_namlng], .weakflag, .definition);
	lnk$gw_ncrosrfs = .lnk$gw_ncrosrfs + 1;	! AND COUNT IT
	end;

    return true
    end;

routine prosymbol (entmskflg) =
!++
!  This routine does all the work of processing symbols on PASS 1, including 
!  entry points, simple symbol definitions and references and procedure names. 
!  the following operations are performed:
!
!    1.	If the current object module is a selective search module, then only 
!	definitions are considered. these are ignored unless there is a current
!	outstanding reference to that symbol.
!
!    2.	If a definition already exists in the table and this incoming symbol is
!	a definition, produce an error unless they are equal, absolute symbols 
!	or unless this is a selective search module.
!
!    3.	If there is no symbol in the table, insert this one.
!
!    4.	If the entry found is a reference and the in coming symbol is a 
!	definition, the flags, data type and value are copied into the entry 
!	after removing it from the undefined list.
!
!    5.	If the p-section specification has been seen, the base of this module's 
!	contribution to the p-section is added, and the symbol linked on to the
!	p-section symbol list.
!
!    6.	If p-section has not been seen, find the mapping table entry and link 
!	this symbol on to its list of prematurely defined symbols. The symbol
!	will be relocated when p-section is defined.
!
!    7.	Undefined symbols are linked on to the undefined symbol list and a count
!	of them is kept if the references to them are not weak.
!
!
!  ENTMSKFLG =	1 if the symbol contains an entry mask, 
!		0 otherwise.
!
!
!--
!
begin
    routine shrimgsym =
	begin
	!
	!   THIS ROUTINE LINKS A SYMBOL TABLE ENTRY INTO THE LIST OF REFERENCED SYMBOLS
	!   IN A SHAREABLE IMAGE.  THE SYMBOL IS COUNTED ALSO.
	!
	bind	shrimgclu = .symtabent [sym$l_cludsc] : block [, byte];

	if .shrimgclu [clu$v_based] or .lnk$gl_defclu [clu$v_based] 
	or  not .symtabent [sym$v_rel]
	then return true;

	if .shrimgclu [clu$l_shrsyms] eql 0				! IF NO SYMBOLS YET THIS CLUSTER
	then lnk$gl_shrimgs = .lnk$gl_shrimgs + 1;			! THEN COUNT THIS SHAREABLE IMAGE

	shrimgclu [clu$l_shrsyms] = .shrimgclu [clu$l_shrsyms] + 1;	! COUNT THIS SYMBOL IN CLUSTER
	lnk$gl_shrsyms		  = .lnk$gl_shrsyms + 1;		! COUNT IN TOTAL NUMBER OF SYMBOLS
	symtabent [sym$l_shrlnk]  = .shrimgclu [clu$l_shrlst];		! LINK SYMBOL INTO LIST OFF CLUSTER DESCRIPTOR
	symtabent [sym$v_gref]    =  true;				! FLAG SYMBOL HAS BEEN ENTERED INTO SHR LST
	shrimgclu [clu$l_shrlst]  = .symtabent;
	return true
	end;
!
! MAIN BODY OF PROSYMBOL
!
local
	found,						! TRUE IF FOUND IN TABLE
	symbolvalue,					! VALUE OF SYMBOL FROM OBJECT FILE
	symbolcluster	: ref block [, byte],		! POINTER TO CLUSTER DESCRIPTOR
	nxtsyment	: ref block [, byte],		! USED AS POINTER IN SCAN OF UNDEFINED LIST
	psctmapent	: ref block [, byte],		! POINTER TO MAPPING TABLE ENTRY
	psctdesc	: ref block [, byte],		! POINTER TO P-SECT DESCRIPTION
	modpscontriblk	: ref block [, byte];		! POINTER TO THIS MODULE'S
    							! CONTRIBUTION BLOCK
bind
	symbolrec = objvec [.gsdoffset] : block [, byte];
builtin
	insque,
	remque;

symtabent = 0;

!
!   FIRST CHECK VALID SYMBOL NAME
!

if .symbolstring [0] gtru sym$c_maxlng				! IF THE SYMBOL LENGTH IS OUTSIDE
or .symbolstring [0] eql 0					! LEGAL RANGE
then begin	
     signal (lin$_illnamelen, 6, lnk$gt_symstring		! ISSUE AN ERROR MESSAGE
	    ,symbolstring [0], .symbolstring [0]
	    ,sym$c_maxlng, obmodesc [omd$b_namlng]
	    ,lnk$gl_curfil [fdb$q_filename]
	    );
     return false;
     end;

symbolvalue =  (if .symbolrec [gsy$v_def]
		then (if not .lclsymgsd 
		      then (if .wordpsectgsd			! EXTRACT THE SYMBOL VALUE FROM THE RECORD
			    then .symbolrec [sdfw$l_value] 
			    else .symbolrec [sdf$l_value]
			   ) 
		      else .symbolrec [lsdf$l_value]
		     )
		 else 0
		) ;

if not (found = (if .lclsymgsd 					! Test for local symbol...
		 then lnk$searchlocal (symbolstring [0], .symbolrec [lsy$w_envindx], symtabent, symentnam) 
		 else lnk$search (symbolstring [0], symtabent, symentnam)
	)       )
then if  .obmodesc [omd$v_selser] and .symbolrec [gsy$v_def]	! IF SELECTIVE SEARCH MODULE, AND THIS 
     then return true 						! IS A DEFINITION, IGNORE IT 
     else begin							! ELSE, NOT SEL SEARCH OR IT'S A REFERENCE
	  lnk$insert (symbolstring [0], symtabent, symentnam);	! INSERT IT 
	  if  .lclsymgsd 					! AND COUNT IT
	  then lnk$gw_nlsyms   = .lnk$gw_nlsyms + 1 
	  else lnk$gw_nsymbols = .lnk$gw_nsymbols + 1;

	  symtabent [sym$v_weak]   = .symbolrec [gsy$v_weak];	! COPY THE WEAK, RELOCATABLE
	  symtabent [sym$v_rel]    = .symbolrec [gsy$v_rel];	! (OMIT DEF FOR NOW)
	  symtabent [sym$v_lclsym] = .lclsymgsd;		! SET FLAG IF LOCAL SYMBOL

	  if  .lnk$gl_ctlmsk [lnk$v_intfil]			! IF THIS IS THE INTERNAL (SYSTEM
		and 
	      .lnk$gl_ctlmsk [lnk$v_supsys]			! LIBARY FILE) AND THE DSUPPRESSION
	  or  .symtabent [sym$v_lclsym]				! OR IT'S A MODULE-LOCAL SYMBOL
	  then symtabent [sym$v_supres] = true;			! THEN SUPRESS THIS SYMBOL

	  if not .symbolrec [gsy$v_def]				! IF IT WAS A REFERENCE
	  then	begin						! JUST INSERTED IN TABLE
		lnk$insudfsym (.symtabent);			! INSERT IN UNDEFINED SYMBOL LIST
		if  not .symtabent [sym$v_weak]			! IF THE REFERENCE IS NOT WEAK REFERENCE
		and not .symtabent [sym$v_lclsym]		!   AND NOT A LOCAL SYMBOL
		then begin
		     if .lnk$gl_libsym neq 0
		     then begin
			  !   
			  !   IF THE CURRENT FILE IS A SEARCH LIBRARY AND THE MODULE IS PULLED
			  !   AND THE LIST HAS EMPTIED DURING THE PROCESSING OF THE MODULE OR
			  !   FOR THE FILE SO THAT THE LIBRARY SEARCH WILL RETURN TO THE TOP OF
			  !   UNDEFINED LIST ONE MORE TIME.
			  !
			  bind   libsymnam = .lnk$gl_libsym - .lnk$gl_libsym [sym$b_namlng] 
						- snb$c_fxdlen		: block [, byte];

			  if  .lnk$gl_curfil [fdb$v_libsrch]
			  	and
			     (.lnk$gl_libsym eql lnk$gl_udflst
				or 
			      ch$lss (.symentnam [snb$b_namlng], symentnam [snb$t_name]
				     ,.libsymnam [snb$b_namlng], libsymnam [snb$t_name]
			     )	     )
			  then lnk$gl_curfil [fdb$v_newudf] = true;  
			  end;
		     end;

		crefilter (false, .symbolrec [gsy$v_weak]);
		return true;					! AND WE ARE DONE WITH THIS
		end;						! UNRESOLVED REFERENCE SO RETURN SUCCESS
	  end;

if .symtabent [sym$v_def]					! IF THE ENTRY IN
then begin							! THE SYMBOL TABLE IS
     if .obmodesc [omd$v_selser]				! A DEFINITION AND
     then return true						! THIS IS SELECTIVE
     else if not .symbolrec [gsy$v_def]				! SEARCH, IGNORE SYMBOL.
	  then	begin					! IGNORE REFERENCE TO DEFINED SYMBOL EXCEPT FOR CREF
		if      .symtabent [sym$v_shrimg]	! IF SYMBOL IS FROM SHAREABLE IMAGE
		and not .symtabent [sym$v_crosref]	!  AND HAS NOT BEEN CROSS-REF'D YET
		then begin
		     local	defomdptr : ref block [, byte];

		     if not .symtabent [sym$v_gref]		! ENTER SYMBOL INTO SHR LIST IF NOT DONE YET
		     then shrimgsym ();

		     lib$lookup_tree ( lnk$gl_omdtree		! FIND OMD FOR MODULE THIS SYMBOL DEFINED IN
				     ,.symtabent [sym$l_omdnum]
				     , lnk$compare_omd
				     , defomdptr
				     );
		     crefilter ( true, .symtabent [sym$v_weak]	! CROSS REF THE DEFINITION
			       ,.defomdptr [node$l_ptr]
			       );

		     if      .lnk$gl_ctlmsk [lnk$v_long]	! IF A LONG FORM MAP IS REQUIRED
		     and not .symtabent [sym$v_rel]		! AND THIS SYMBOL IS BASED
		     and not .symtabent [sym$v_supres]		!  AND NOT SUPRESSED
		     then crf$insrtref	( lnk$al_valctltb 		! INSERT THIS
					, symtabent [sym$l_value] 	! SYMBOL AS A REFERENCE TO ITS
					, symentnam [snb$b_namlng] 	! VALUE
					,.symtabent [sym$w_flags]
					, 0
					);
		     end;

		crefilter (false, .symbolrec [gsy$v_weak]);

		if      .symtabent [sym$v_shrimg]		! IF SYMBOL IS FROM SHAREABLE IMAGE
		and not .symtabent [sym$v_gref]			!  AND HAS NOT BEEN LINKED INTO SHR LIST
		then shrimgsym ();				! THEN DO SO NOW

		return true;					! AND ALL DONE
		end;

     !
     !   HERE WE HAVE A MULTIPLE DEFINITION FROM A NON SELECTIVE SEARCH MODULE. 
     !   IF BOTH DEFINITIONS ARE ABSOLUTE AND THE VALUES ARE EQUAL ALL IS WELL. 
     !   OTHERWISE WE HAVE AN ERROR.
     !

     if      .symbolvalue eql .symtabent [sym$l_value] 
     and not .symbolrec [gsy$v_rel] 
     and not .symtabent [sym$v_rel]
     then return true;

     if      .symtabent [sym$v_optsym]				! IF DEFINED BY OPTION
     and not .symbolrec [gsy$v_rel]				! AND 2ND DEF. IS ABSOLUTE THEN WE WON'T REDEFINE
     then begin							! THE SYMBOL, BUT WE NEED TO INDICATE WHICH PSECT
	  psctmapent = fndpscmapent ((if not .lclsymgsd		! OWNS IT
				      then (if .wordpsectgsd			! FIND PSECT MAPPING TABLE ENTRY
					    then .symbolrec [sdfw$w_psindx] 
					    else .symbolrec [sdf$b_psindx]
					   ) 
				       else .symbolrec [lsdf$w_psindx]
				     ));
	  psctdesc = .psctmapent [pmt$l_pscdes];			! GET ADDRESS OF PSECT DESCRIPTOR

	  if .psctdesc neq 0						! IF P-SECTION IS
	  then	begin							!  DEFINED, GET THIS
		symtabent [sym$l_psclst] = .psctdesc [psc$l_symlst];	!  P-SECT BASE
		psctdesc [psc$l_symlst]  = .symtabent;			!  LINK SYMBOL
		end							!  LIST
	  else	begin							! P-SECTION NOT
		symtabent [sym$l_psclst]  = .psctmapent [pmt$l_symlst];	!  DEFINED YET, SO
		psctmapent [pmt$l_symlst] = .symtabent;			!  LINK SYMBOL
		end;							!  MAPPING TABLE

	  return true;							! NOW WE CAN LEAVE QUIETLY...
	  end;

     if  .symtabent [sym$v_shrimg]					! IF SYMBOL FROM SHAREABLE IMAGE
     and (if (symbolcluster = .symtabent [sym$l_cludsc]) eql 0		!  AND THE IMAGE IS BASED
	  then  false 
	  else .symbolcluster [clu$v_based] 				! AND THIS IS A BASED 
	 )
     and .lnk$gl_curclu [clu$v_shrimg]					! SHARED IMAGE
     and .lnk$gl_curclu [clu$v_based]					!  WHICH IS BASED
     and (.symtabent [sym$l_value] + .symbolcluster [clu$l_base]	!  AND THE VALUES ARE THE SAME
			eql 
	   .symbolvalue + .lnk$gl_curclu [clu$l_base]
	  )
     then  return true;							! THEN IGNORE THIS DEFINITION COMPLETELY

     signal (lin$_muldef, 3, symbolstring [0], obmodesc [omd$b_namlng], lnk$gl_curfil [fdb$q_filename]);

     if   not .symbolrec [gsy$v_rel]					! IF BOTH ARE ABSOLUTE
     and  not .symtabent [sym$v_rel]					! THEN WE SIMPLY RE-DEFINE
     then symtabent [sym$l_value] = .symbolvalue;			! THE VALUE

     return true;
     end
else
    !
    !	THE ENTRY IN THE SYMBOL TABLE IS EITHER A NEW REFERENCE
    !	JUST INSERTED OR A REFERENCE AWAITING DEFINITION.
    !
    !	IF THIS IS AN INCOMING DEFINITION WE PROCEED TO DEFINE THE
    !	SYMBOL. THAT IS:
    !			IF UDFLINK FIELD IS NON ZERO, THE TABLE ENTRY
    !			IS ON THE UNDEFINED SYMBOL LIST, SO REMOVE IT
    !			AND DECREMENT THE UNDEFINED COUNT (PROVIDED IT IS
    !			NOT A WEAK REFERENCE).
    !
    !			THEN COPY INTO THE SYMBOL TABLE ENTRY THE FLAGS,
    !			VALUE, ENTRY MASK, DATA TYPE AND FINALLY
    !			LINK THE SYMBOL ON THE OWNING P-SECTION LIST
    !
    !	IF THIS IS (ANOTHER) INCOMING REFERENCE, AND IT IS
    !	NOT A WEAK REFERENCE, ENSURE THAT THE SYMBOL TABLE ENTRY IS
    !	ALSO NOT A WEAK REFERENCE AND THAT THIS STRONG REFERENCE
    !	TO AN UNDEFINED SYMBOL IS COUNTED.
    !
    begin
    if not .symbolrec [gsy$v_def]				! IF THIS IS
    then begin							! ANOTHER REFERENCE THEN
	 crefilter (false, .symbolrec [gsy$v_weak]);		! CROSS REFERENCE IT 

	 if .symbolrec [gsy$v_weak]				! IF WEAK, IGNORE IT SINCE THE ONE WE
	 then return true;					! HAVE IS AT LEAST WEAK AND NOTHING TO
								! BE DONE
	 if .symtabent [sym$v_weak]				! IF A STRONG REFERENCE AND SYMBOL TABLE
	 then	begin						! ENTRY IS WEAK
		symtabent [sym$v_weak] = false;			! MAKE SURE IT IS STRONG

		if .symtabent [sym$v_lclsym]
		then lnk$gw_nudflsyms = .lnk$gw_nudflsyms + 1	! AND COUNT THE STRONG REFERENCE
		else lnk$gw_nudfsyms  = .lnk$gw_nudfsyms + 1;
		end;
	 return true;						! AND THAT'S IT FOR REFERENCES.
	 end;

    !
    !   AND NOW FOR A DEFINITION
    !
    if .symtabent [sym$l_udflink] neq 0				! IF THIS SYMBOL TABLE ENTRY IS ON
    then begin							! UNDEFINED SYMBOL LIST,
	 remque (symtabent [sym$l_udflink], nxtsyment);		! REMOVE FROM THE LIST

	 if .nxtsyment eql .lnk$gl_libsym			! IF THE ONE REMOVED IS THE ONE TO SEARCH
	 then lnk$gl_libsym = .nxtsyment [sym$l_udflink];	! FOR NEXT, MOVE TO ONE BEYOND

	 if not .symtabent [sym$v_weak]				! IF IT IS NOT A WEAK REFERENCE
	 then
		if .symtabent [sym$v_lclsym]
		then lnk$gw_nudflsyms = .lnk$gw_nudflsyms - 1
		else lnk$gw_nudfsyms  = .lnk$gw_nudfsyms - 1;		! DECREMENT NUMBER UNDEFINED 
	 end;

    !
    !	Allow the symbol table entry to inherit the suppress and local symbol flags, but ignore
    !	the universal flag.  If the symbol is to be universal, then it has either been
    !	already declared that way (via the UNIVERSAL=name option), or will be set by a 
    !	redefinition later (i.e., a transfer vector).  It is not clear what an incoming 
    !	universal symbol (ref OR def) means.
    !

    symtabent [sym$w_flags] = (.symtabent [sym$w_flags] and (sym$m_lclsym or sym$m_supres or sym$m_uni))
				or 
			       (.symbolrec [gsy$w_flags] and (not sym$m_uni));

    symtabent [sym$v_entmsk] = .entmskflg;			! COPY THE ENTRY MASK FLAG

    if .lnk$gl_ctlmsk [lnk$v_alluniv]				! If all globals are to be promoted
    then symtabent[sym$v_uni] = true;				!   to universal, do this one now

    symtabent [sym$b_datyp]   = .symbolrec [gsy$b_datyp];	! COPY DATA TYPE
    symtabent [sym$l_value]   = .symbolvalue;			! COPY THE VALUE
    symtabent [sym$w_entmsk]  = .entrymask;			! COPY THE MASK
    symtabent [sym$v_shrimg]  = .obmodesc [omd$v_shrimg];	! SET/CLEAR SHAREABLE IMAGE FLAG
    psctmapent = fndpscmapent ((if not .lclsymgsd 
				then (if .wordpsectgsd		! FIND PSECT MAPPING TABLE ENTRY
				      then .symbolrec [sdfw$w_psindx] 
				      else .symbolrec [sdf$b_psindx]
				     ) 
				else .symbolrec [lsdf$w_psindx]
			      ));
    psctdesc 		     = .psctmapent [pmt$l_pscdes];	! GET ADDRESS OF PSECT DESCRIPTOR
    symtabent [sym$l_cludsc] = .lnk$gl_curclu;			! SET POINTER TO CLUSTER DESCRIPTOR
    symtabent [sym$l_omdnum] = .lnk$gw_nmodules;		! SET INDEX OF DEFINING MODULE

    if .symtabent [sym$v_shrimg]				! COPY SHR IMAGE FLAG
    then begin
	 symtabent [sym$v_uni] = false;				! CLEARING UNI IF SYMBOL FROM ANOTHER IMAGE

	 if .found and not .symtabent [sym$v_gref]		! AND HAS NOT BEEN LINKED INTO THE LIST YET
	 then shrimgsym ();					! THEN DO IT NOW

	    					! DON'T CREF SHAREABLE IMAGE SYMBOLS ON DEF.  IT WILL
	    					! BE CREF'ED WHEN A REFERENCE TO IT IS ENCOUNTERED
	 end
    else							! NOT FROM A SHR IMAGE, 
	 lnk$gw_lsymbols = .lnk$gw_lsymbols + 1;		! COUNT ANOTHER SYMBOL THIS IMAGE

    if .found							! IF SYMBOL ALREADY REFERENCED
    or not .symtabent [sym$v_shrimg]				!  OR NOT FROM A SHAREABLE IMAGE
    then begin
	 crefilter (true, .symbolrec [gsy$v_weak]);		! SO CROSS-REFERENCE IT NOW

	 if	 .lnk$gl_ctlmsk [lnk$v_long]			! IF A LONG FORM MAP IS REQUIRED
	 and not .symtabent [sym$v_rel]				!  AND SYMBOL IS ABSOLUTE
	 and not .symtabent [sym$v_supres]			!  AND NOT SUPRESSED
	 then
		crf$insrtref ( lnk$al_valctltb			! INSERT THIS
			     , symtabent [sym$l_value]		! SYMBOL AS A REFERENCE TO ITS
			     , symentnam [snb$b_namlng] 	! VALUE
		    	     ,.symtabent [sym$w_flags]
			     , 0
			     );
	 end;

    if .psctdesc neq 0						! IF P-SECTION IS
    then begin							! DEFINED, GET THIS MODULE'S
	 modpscontriblk		  = .psctmapent [pmt$l_modcon];	! CONTRIBUTION BLOCK AND
	 symtabent [sym$l_value]  = .symtabent [sym$l_value] + 	! ADD THE OFFSET FROM
				    .modpscontriblk [mpc$l_offset];
	 symtabent [sym$l_psclst] = .psctdesc [psc$l_symlst];	! P-SECT BASE
	 psctdesc [psc$l_symlst]  = .symtabent;			! LINK SYMBOL ON TO P-SECT LIST
	 end
    else begin							! P-SECTION NOT DEFINED YET
	 symtabent [sym$l_psclst]  = .psctmapent [pmt$l_symlst];! LINK SYMBOL ON LIST OFF
	 psctmapent [pmt$l_symlst] = .symtabent;		! MAPPING TABLE
	 end;

    return true;
    end;							! END OF DEFINITION

end;								! END OF SYMBOL ROUTINE


routine symbols =
begin
local
	length;
bind
	symbolrec = objvec [.gsdoffset] : block [, byte];

entrymask = 0;						! ZERO THE ENTRY MASK SINCE NONE EXISTS

if not .symbolrec [gsy$v_def]				! IF NOT DEFINED
then	  begin
	  length	= symbolrec [srf$t_name] - symbolrec [srf$t_start] + .symbolrec [srf$b_namlng];
	  symbolstring	= symbolrec [srf$b_namlng];
	  end
else if .wordpsectgsd					! IF A WORD OF PSECT NUMBER
     then begin
	  length	= symbolrec [sdfw$t_name] - symbolrec [sdfw$t_start] + .symbolrec [sdfw$b_namlng];
	  symbolstring	= symbolrec [sdfw$b_namlng];
	  end
     else begin
	  length	= symbolrec [sdf$t_name] - symbolrec [sdf$t_start] + .symbolrec [sdf$b_namlng];
	  symbolstring	= symbolrec [sdf$b_namlng];
	  end;

if not prosymbol (0)					! GO PROCESS THIS SYMBOL
then return false;					! AND EXIT IF FAILURE

gsdoffset = .gsdoffset + .length;			! UPDATE THE GSD OFFSET FOR NEXT
return true;
end;


routine entpnts =
begin
local
	length;
bind
	symbolrec = objvec [.gsdoffset] : block [, byte];

if .wordpsectgsd
then begin
     entrymask    = .symbolrec [epmw$w_mask];		! EXTRACT THE ENTRY POINT MASK
     symbolstring =  symbolrec [epmw$b_namlng];		! POINT TO THE SYMBOL
     length       =  symbolrec [epmw$t_name] - symbolrec [epmw$t_start] + .symbolrec [epmw$b_namlng];
     end
else begin
     entrymask    = .symbolrec [epm$w_mask];		! EXTRACT THE ENTRY POINT MASK
     symbolstring =  symbolrec [epm$b_namlng];		! POINT TO THE SYMBOL
     length       =  symbolrec [epm$t_name] - symbolrec [epm$t_start] + .symbolrec [epm$b_namlng];
     end;

if not prosymbol (1)					! GO PROCESS THE SYMBOL
then return false;					! AND EXIT IF FAILURE

gsdoffset = .gsdoffset + .length;			! ELSE UPDATE THE OFFSET FOR NEXT
return true;
end;

routine procedef =
    begin
!
!	A PROCEDURE DEFINITION IS AN EXTENDED ENTRY POINT DEFINITION, CARRYING WITH
!	IT A DESCRIPTION OF THE PROCEDURE'S FORMAL ARGUMENTS. PROCESSING THESE CONSISTS
!	IN NORMAL SYMBOL DEFINITION PROCESSING FOLLOWED BY:-
!		(1) VALIDATION OF THE FORMAT OF FORMAL DESCRIPTION (I.E. JUST CHECK
!			THAT MINIMUM NUMBER OF ARGUMENTS SPECIFIED IS LESS THAN
!			OR EQUAL TO THE MAXIMUM.
!		(2) ALLOCATION OF AN ARGUMENT VALIDATION DATA ARRAY WHICH
!			HAS THE FOLLOWING FORMAT:
!				------------
!				!  N+2     ! LENGTH OF ARRAY WHERE N = MAXIMUM # ARGUMENTS
!				------------
!				!  MIN     ! MINIMUM NUMBER OF ARGS
!				------------
!				! PASS M 1 ! PASSING MECHANISM OF ARG 1
!				------------
!				! PASS M 2 !    "        "         "  2
!				------------
!				   ETC TO N ARGUMENTS
!
!	NOTE THAT ONLY THE VALIDATION CONTROL BYTE, ARGUMENT PASSING MECHANISM
!	IS EXTRACTED FROM THE FORMAL ARGUMENT DESCRIPTORS. THE REST OF SUCH
!	DESCRIPTORS IS IGNORED.
!
!	THE SYMBOL TABLE ENTRY POINTS TO THIS ARRAY. NOTE THAT MULTIPLE DEFINITION OF THE
!	SAME PROCEDURE WILL REPLACE THE VALIDATION DATA WITH NEW DATA.

    local
	entflag,
	argvaldata : ref vector [, byte],
	argcount;

    if not entpnts () then return false;	! PROCESS THE ENTRY POINT SYMBOL PART

    entflag = .symtabent neq 0;			! SEE IF ENTERED
    begin

    bind
	formals = objvec [.gsdoffset] : block [, byte];	! THE FORMAL DESCRIPTION

    if .formals [fml$b_minargs] gtru .formals [fml$b_maxargs]	! IF THERE IS AN INCONSISTENT
    then
	begin					! DESCRIPTION OF FORMALS
	signal (lin$_illfmlcnt, 5, 		! OUTPUT ERROR MESSAGE
	    .formals [fml$b_minargs], .formals [fml$b_maxargs],
	    (if .wordpsectgsd then objrec [prow$b_namlng] else objrec [pro$b_namlng]),
	    obmodesc [omd$b_namlng], lnk$gl_curfil [fdb$q_filename]);
	return false;
	end;

    gsdoffset = .gsdoffset + fml$c_size;	! UPDATE RECORD POINTER

    if .entflag and (argvaldata = .symtabent [sym$l_valdata]) neq 0	! IF VALIDATION DATA ALREADY EXISTS
    then
	begin					! MUST BE A NEW DEFINITION
	lnk$dealblk (.argvaldata [0], argvaldata [0]);	! SO DISPOSE OF OLD DATA
	symtabent [sym$l_valdata] = 0;		! AND FORGET IT
	end;

    if (argcount = .formals [fml$b_maxargs]) eql 0	! IF MAXIMUM NUMBER ARGUMENTS
    then
	return true;				! IS ZERO, ALL DONE

    if .entflag
    then
	begin
	lnk$alloblk (.argcount + 2, symtabent [sym$l_valdata]);	! ALLOCATE A VALIDATION DATA BLOCK
	argvaldata = .symtabent [sym$l_valdata];
	argvaldata [0] = .argcount + 2;		! SET ITS SIZE
	argvaldata [1] = .formals [fml$b_minargs];	! SAVE MINIMUM ARGUMENT SPECIFICATION
	end;

    incr i from 1 to .argcount			! BEGIN A LOOP THROUGH
	do
	begin					! ALL FORMAL ARGUMENT DESCRIPTORS

	bind
	    argdesc = objvec [.gsdoffset] : block [, byte];	! POINT TO NEXT DESCRIPTOR

	if .entflag then argvaldata [.i + 1] = .argdesc [arg$v_passmech];

						! EXTRACT THE PASSING MECHANISM
	gsdoffset = .gsdoffset + .argdesc [arg$b_bytecnt] + 	! AND UPDATE RECORD POINTER
	arg$c_size;
	end;

    return true;
    end;
    end;

routine proeom (seqchkflg) =
    begin
!
!	PROCESS END OF MODULE RECORDS:
!		(1) VALIDATE SEQUENCE
!		(2) INTERPRET COMPILER COMPLETION CODE,
!		    ISSUING APPROPRIATE ERROR OR WARNING
!		    MESSAGE
!		(3) VALIDATE THE TRANSFER ADDRESS
!			(IF ANY) FOR:
!			(A) P-SECTION DEFINED
!			(B) P-SECTION EXECUTABLE AND RELOCATABLE
!			(C) ADDRESS IS WITHIN THAT P-SECTION
!			(D) NOT A MULTIPLE SPECIFICATION -( RETAIN THE FIRST)
!		(4) RECORD THE  TRANSFER ADDRESS, SEPARATING AN ADDRESS IN
!			THE DEBUGGER FROM THAT OF THE USER.
!		(5) TRUNCATE THE MODULE DESCRIPTOR (MAPPING TABLE PORTION) TO ITS
!			CORRECT SIZE FOR NUMBER OF P-SECTS CONTRIBUTED TO.
!
    bind
	eomrec = .objvec : block [, byte];
    builtin
	nullparameter;
    local
	comcode,
	deferredsym : ref block [, byte],	! POINTER TO DEFERRED SYMBOL
	deferredsnb : ref block [, byte],	! DEFERRED SYMBOL NAME BLOCK
	modpscontriblk : ref block [, byte],	! THE MODULE'S CONTRIBUTION TO P-SECT
	wordpsecteom,				! TRUE IF EOMW RATHER THAN EOM
	psctmap : ref block [, byte],		! PSECT MAPPING TABLE POINTER
	psctnum,				! P-SECTION NUMBER OF TRANSFER ADDRESS
	tfrweak,				! TRUE IF TRANSFER ADDRESS THIS EOM IS WEAK
	tfradr,					! TEMP FOR TRANSFER ADDRESS
	tfrpsc : ref block [, byte],		! TEMP FOR P-SECT DESC. ADDR.
	objdesc : ref block [, byte],		! POINTER TO ALLOCATED OBJ MOD DESCRIPTOR
	omdnode,
	curcontriblk : ref block [, byte],
	nextcontriblk : ref block [, byte],
	objdescsize;				! SIZE OF OBJ MOD DESCRIPTOR TO ALLOCATE

    if nullparameter (1)
    then

	if not seqchk () then return false;	! VALIDATE THE SEQUENCE OF EOM

    lnk$gl_curfil [fdb$v_omdnobin] = 		! IF ANY OBMODS FOR THIS FDB ARE
    .lnk$gl_curfil [fdb$v_omdnobin] or .obmodesc [omd$v_nobin];	! WITHOUT TIR RECS, FLAG IN FDB
    wordpsecteom = (.eomrec [eom$b_rectyp] eql obj$c_eomw);	! DECIDE IF EOM OR EOMW

    if (if .wordpsecteom			! CHECK LENGTH OF RECORD
	then (.reclng neq eomw$c_eommin and ((.reclng lss eomw$c_eommx1) or (.reclng gtr eomw$c_eommax))) else
	(.reclng neq eom$c_eommin		! AND ITS LENGTH
	    and ((.reclng lss eom$c_eommx1) or (.reclng gtr eom$c_eommax))))
    then
	begin
	signal (lin$_illreclen, 3, 		! AND ISSUE ERROR
	    .reclng, obmodesc [omd$b_namlng], lnk$gl_curfil [fdb$q_filename]);
	return false;
	end;

    if (comcode = .eomrec [eom$b_comcod]) neq 0	! IF NON ZERO COMPILATION CPLETE CODE
    then
	begin					! CHECK

	if .comcode gtru 3
	then
	    begin
	    signal (lin$_badccc, 3, 		! IF AN ILLEGAL COMPLETION
		.comcode, obmodesc [omd$b_namlng], 	!  THEN TELL THAT AND QUIT
		lnk$gl_curfil [fdb$q_filename]);
	    return false;
	    end;

	case .comcode from eom$c_warning to eom$c_abort	! SIGNAL MESSAGE BASED ON ERROR CLASS
	of
	    set

	    [eom$c_warning] :
		signal (lin$_wrners, 2, obmodesc [omd$b_namlng], lnk$gl_curfil [fdb$q_filename]);

	    [eom$c_error] :
		begin
		signal (lin$_errors, 2, obmodesc [omd$b_namlng], lnk$gl_curfil [fdb$q_filename],
		    lin$_noimgfil);
		lnk$gl_ctlmsk [lnk$v_image] = false;	! DISABLE IMAGE IF ERROR
		end;

	    [eom$c_abort] :
		begin
		signal (lin$_eomftl, 2, obmodesc [omd$b_namlng], lnk$gl_curfil [fdb$q_filename]);
		lnk$exit (lin$_fatalerror);	! LINK ABORT
		end;
	    tes;

	end;

    if .obmodesc [omd$w_hipsct] eql lnk$c_maxpsects	! IF HIGHEST NUMBERED P-SECT
	and .obmodesc [omd$v_nopsct]		! IS LNK$C_MAXPSECTS AND STILL NO DEFINITIONS
    then 					! BEEN SEEN
	signal_stop (lin$_nopscts, 2, 		! THERE IS A FORMAT ERROR
	    obmodesc [omd$b_namlng], 		! ISSUE MESSAGE
	    lnk$gl_curfil [fdb$q_filename], lin$_format);

    if (if .wordpsecteom then (.reclng geq eomw$c_eommx1) else (.reclng geq eom$c_eommx1))
						! IF RECORD LENGTH IS (MX1)
						! OR (MAX)
    then
	begin					! A TRANSFER ADDRESS EXISTS, SO
	psctnum = (if .wordpsecteom		! GET THE P-SECTION INDEX AND
	then .eomrec [eomw$w_psindx] else .eomrec [eom$b_psindx]);

	if .psctnum gtru .obmodesc [omd$w_hipsct] or .obmodesc [omd$v_nopsct]
	then
	    begin
	    signal (lin$_badpsc, 3, 		! IF P-SECTION NOT DEFINED
		.psctnum, obmodesc [omd$b_namlng], 	! THEN OUTPUT ERROR AND QUIT
		lnk$gl_curfil [fdb$q_filename]);
	    return false;
	    end
	else
	    begin
	    psctmap = fndpscmapent (.psctnum);	! GET MAPPING TABLE ENTRY

	    if (tfrpsc = .psctmap [pmt$l_pscdes]) eql 0	! SET THE POINTER TO THAT P-SECTION
	    then
		begin
		signal (lin$_badpsc, 3, 	!  BUT ISSUE AN ERROR IF UNDEFINED
		    .psctnum, obmodesc [omd$b_namlng], lnk$gl_curfil [fdb$q_filename]);
		return false;
		end;

	    if not .tfrpsc [psc$v_exe]		! IF THE P-SECTION CONTAINING THE
		or not .tfrpsc [psc$v_rel]	! TRANSFER ADDRESS IS NOT
	    then
		signal (lin$_pscnxr, 2, 	! THEN ISSUE AN ERROR MESSAGE
		    obmodesc [omd$b_namlng], lnk$gl_curfil [fdb$q_filename]);

	    modpscontriblk = .psctmap [pmt$l_modcon];
	    tfradr = (if .wordpsecteom then .eomrec [eomw$l_tfradr] else .eomrec [eom$l_tfradr]) +
						! BUT IN ANY CASE COMPUTE THE
	    .modpscontriblk [mpc$l_offset];	! ADDRESS RELATIVE TO THE WHOLE P-SECT
	    tfrweak = (if .wordpsecteom then ((.reclng eql eomw$c_eommax) and
						! SET FLAG FOR WEAKNESS OF TRANSFER ADDRESS
		.eomrec [eomw$v_wktfr]) else ((.reclng eql eom$c_eommax) and .eomrec [eom$v_wktfr]));

	    if not .lnk$gl_curfil [fdb$v_debuger]	! IF THE CURRENT INPUT FILE
						! DOES NOT CONTAIN THE DEBUGGER
		and (.lnk$gl_tfrpsc eql 0	! AND NO PREVIOUS TRANSFER ADDRESS WAS SPECIFIED
		or (.weaktfradr and not .tfrweak))
						! OR IT WAS A WEAK TRANSFER ADDRESS AND THIS ONE IS NOT
	    then
		begin

		if ( not .lnk$gl_ctlmsk [lnk$v_imgidopt]) and 	! IF IMAGE ID NOT MANUALLY SET
		    (.lnk$gt_imgid [0] eql 0	! IF STILL NO IMAGE IDENT
		    or .lnk$gl_tfrpsc eql 0)	!  OR IDENT WAS FROM MODULE W/O TRANSFER ADDRESS
		then
		    ch$move (.imageidstring [0] + 1, imageidstring [0], 	! THEN MOVE IN THE ONE OF
			lnk$gt_imgid [0]);	! THIS MODULE AS SAVED ON MHD RECORD

		lnk$gl_tfrpsc = .tfrpsc;	! THEN THIS IS THE USER'S
		lnk$gl_tfradr = .tfradr;	! TRANSFER ADDRESS
		weaktfradr = .tfrweak;		! REMEMBER IF THIS WAS WEAK OR STRONG TRANSFER ADDRESS
		end
	    else

		if .lnk$gl_curfil [fdb$v_debuger]
						! OTHERWISE IF THIS IS THE DEBUGGER FILE AND THERE HAS NOT
		    and .lnk$gl_dbgtfps eql 0	! PREVIOUSLY BEEN A DEBUGGER TRANSFER
		then
		    begin			! ADDRESS, MAKE THIS THE
		    lnk$gl_dbgtfps = .tfrpsc;	! DEBUGGER TRANSFER ADDRESS
		    lnk$gl_dbgtfr = .tfradr;	!
		    end				!
		else

		    if not .tfrweak
!
! THERE WAS A MULTIPLE TRANSFER ADDRESS AND THE TRANSFER ADDRESS FLAG
! BYTE WAS NOT PRESENT, OR WAS PRESENT AND THE WEAK TRANSFER ADDRESS
! FLAG WAS NOT ON.
!
		    then
			signal (lin$_multfr, 2, obmodesc [omd$b_namlng], lnk$gl_curfil [fdb$q_filename]);

	    end;

	end;					! END OF TRANSFER ADDRESS PROCESSING

    if .lnk$gt_imgid [0] eql 0			! IF NO IMAGE IDENT YET
    then
	ch$move (.imageidstring [0] + 1, imageidstring [0],
				!  THEN SET THIS MODULE'S AS THE IDENT (WILL GET OVERWRITTEN IF XFR ADR
	    lnk$gt_imgid [0]);			!    LATER)

    objdescsize = obmodesc [omd$t_pscmap] - obmodesc + 	! COMPUTE SIZE OF OBJ MOD DESC TO ALLOCATE
    pmt$c_size*((if not .obmodesc [omd$v_p256] 
		 then .obmodesc [omd$w_hipsct] + 1 
		 else (.obmodesc [omd$w_hipsct] + 256)/256));
    lnk$alloblk (.objdescsize, objdesc);	! ALLOCATE THE DESCRIPTOR
    lastobjmod [omd$l_nxtomd] = .objdesc;	! LINK INTO THE LIST
    lastobjmod = .objdesc;			! AND NEW BECOMES THE LAST THEN
    ch$move (.objdescsize, obmodesc, .objdesc);	! COPY THE DESCRIPTOR OUT
    lib$insert_tree (lnk$gl_omdtree, .objdesc [omd$l_omdnum], 	! INSERT OMD INTO OMD TREE
	%ref (0), lnk$compare_omd, alloc_omdnode, omdnode, .objdesc);
    objdesc [omd$l_nxtomd] = 0;			! ZERO LINK IN THE DESCRIPTOR

    if .obmodesc [omd$l_lsterr] eql obmodesc [omd$l_errtxt]	! CHECK FOR NO ERRORS
    then
	objdesc [omd$l_lsterr] = objdesc [omd$l_errtxt];

!
! IF DEBUG RECORDS IN THIS OBJ MOD, THEN ADD COUNT OF PSECTS IN DEBUG OBJ MODS.
!	THEN RESET PER-OBJ-MOD PSECT COUNT, AND DEBUG FLAG.
!

    if .omd_has_dbg
    then
	begin
	lnk$gw_pscdst = .lnk$gw_pscdst + .obmodesc [omd$w_hipsct] + 1;
	omd_has_dbg = false;
	end;

!
! FILL IN THE FIELD MPC$L_OWNOMD FOR ALL PSECTS DEFINED IN THIS MODULE
!
    curcontriblk = .obmodesc [omd$l_nxtomd];	! GET LIST POINTER OF PSECT CONTRIBUTION BLOCKS

    while .curcontriblk neq 0 do
	begin
	nextcontriblk = .curcontriblk [mpc$l_ownomd];	! GET LINK TO NEXT
	curcontriblk [mpc$l_ownomd] = .objdesc;	! SET OWNER POINTER
	curcontriblk = .nextcontriblk;
	end;

    ch$fill (0, .objdescsize, obmodesc);	! ZERO THE PROTOTYPE DESCRIPTOR
    obmodesc [omd$l_lsterr] = obmodesc [omd$l_errtxt];
    maxreclng = obj$c_maxrecsiz;		! RESET TO MAX ALLOWED BY LANGUAGE
    return true;
    end;					! END OF EOM PROCESSING

routine countdbg =
    begin
!
!	ROUTINE TO COUNT THE NUMBER OF DEBUG (TYPES 4 AND 5) RECORDS SEEN AND TO
!	TOTAL THE NUMBER OF BYTES CONTAINED FOR USE AS AN ESTIMATE OF THE
!	SIZE OF DEBUG SYMBOL TABLE TO BE WRITTEN AT END OF BINARY
!	IF THE DEBUGGER IS LINKED IN. ALSO IF AN EXECUTABLE IMAGE
!	WITH THE DEBUGGER IS BEING PRODUCED, TURN OFF THE NO BINARY FLAG FOR
!	THIS MODULE (PROVIDED IT IS NOT THE DEBUGGER ITSELF).
!

    if not seqchk ()				! CHECK LEGAL SEQUENCE
    then
	return false;

    if .obmodesc [omd$v_debuger]		! IF THIS IS THE DEBUGER ITSELF
    then
	return true;				! IGNORE ANY DEBUG RECORDS

    if not .omd_has_dbg and .lnk$gl_ctlmsk [lnk$v_dbg]	! IF DBG REC FLAG IS CLEAR AND THE
    then 					!  DEBUGGER IS BEING INCLUDED
	begin					!  IN THE IMAGE,
	omd_has_dbg = true;			!  THEN SET FLAG NOW AND
	lnk$gl_omddst = .lnk$gl_omddst + 1;	! ADD TO COUNT OF DBG OBJ MODS
	end;

    lnk$gl_dbgestim = .lnk$gl_dbgestim + .reclng;	! ADD IN THE LENGTH OF THIS RECORD
    lnk$gw_dbgrecs = .lnk$gw_dbgrecs + 1;	! AND COUNT THE RECORD

    if .lnk$gl_ctlmsk [lnk$v_dbg]		! IF IT CONTAINS THE DEBUGGER IT NOW HAS
	or .lnk$gl_ctlmsk [lnk$v_trace]		!
    then
	obmodesc [omd$v_nobin] = false;		! BINARY WE CARE ABOUT

    return true;				! AND THAT IS ALL
    end;

routine compare_idc (entityname, node, idcrec) =
    begin
!
! COMPARE AN ENTITY NAME WITH THE CURRENT NODE
!

    map
	entityname : ref vector [, byte],
	node : ref block [, byte],
	idcrec : ref block [, byte];

    return ch$compare (.entityname [0], entityname [1], .node [idcd$b_namlng], node [idcd$t_name], 0)
    end;

routine alloc_idc (entityname, retnodeadr, idcrec) =
    begin
!
! ALLOCATE AND FILL IN A NEW IDCD BLOCK
!
    map
	entityname : ref vector [, byte],	! POINTS TO ASCIC NAME
	retnodeadr : ref vector [, long],
	idcrec : ref block [, byte];		! THE IDC GSD SUB-RECORD
    bind
	identstring = idcrec [idc$b_namlng] + 1 + .idcrec [idc$b_namlng] : vector [, byte],
						! IDENT STRING IN RECORD
	binaryident = identstring [1],		! ADDR OF BINARY IDENT
	objectname = identstring [1] + .identstring [0] : vector [, byte];	! ADDR OF OBJECT NAME STRING

    local
	ptr,
	idsize,
	newnode : ref block [, byte];

!
! COMPUTE SIZE OF IDENT STRING
!
    idsize = 0;

    if not .idcrec [idc$v_binident] then idsize = .identstring [0] + 1;

!
! ALLOCATE A NEW IDCD BLOCK
!
    lnk$alloblk (idcd$c_size + .entityname [0] + .idsize + .objectname [0] + 1, newnode);
						!+1 FOR SIZE OF OBJECTNAME IN ASCIC STRING
    newnode [idcd$w_flags] = .idcrec [idc$w_flags];	! COPY FLAGS FROM IDC SUBRECORD
    newnode [idcd$l_defomd] = .lnk$gw_nmodules;	! SET DEFINING MODULE NUMBER
    newnode [idcd$l_deffdb] = .lnk$gl_curfil;	!  DEFINING FILE FDB ADDRESS
    newnode [idcd$b_idlng] = .identstring [0];	! LENGTH OF IDENT STRING
    newnode [idcd$b_objlng] = .objectname [0];	! LENGTH OF OBJECT NAME STRING
    newnode [idcd$b_namlng] = .idcrec [idc$b_namlng];	! ENTITY NAME LENGTH
    ptr = ch$move (.idcrec [idc$b_namlng], 	! COPY IN THE ENTITY NAME
	idcrec [idc$b_namlng] + 1, newnode [idcd$t_name]);
    newnode [idcd$l_objnam] = .ptr;		! SET POINTER TO OBJECT NAME
    ptr = ch$move (.objectname [0] + 1, objectname [0], .ptr);	! MOVE IN THE OBJECT NAME

    if .newnode [idcd$v_binident]		! IF BINARY IDENT, SET IN THE IDENT
    then
	newnode [idcd$l_ident] = .binaryident
    else
	begin
	newnode [idcd$l_ident] = .ptr;		! ASCIC IDENT, SET POINTER TO IDENT STRING
	ch$move (.identstring [0] + 1, identstring [0], .ptr);	!  AND COPY IN THE IDENT
	end;

!
! RETURN NODE ADDRESS TO CALLER
!
    retnodeadr [0] = .newnode;
    return true
    end;

routine randentity =
    begin
!
! THIS ROUTINE PROCESSES THE IDC GSD RECORD.
!
    local
	status,
	length,
	defomd : ref block [, byte],		! DEFINING OMD ADDRESS
	deffdb : ref block [, byte],		! DEFINING FDB ADDRESS
	identstring : ref vector [, byte],	! POINTER TO IDENT STRING
	objectname : ref vector [, byte],	! POINTER TO OBJECT NAME STRING
	entry : ref block [, byte];		! ADDRESS OF ENTRY

    bind
	idcrec = objvec [.gsdoffset] : block [, byte];	! POINT TO THE IDC SUBRECORD

!
! CHECK THE LENGTH OF ALL THE NAME STRINGS
!
!
! THE ENTITY NAME
!

    if .idcrec [idc$b_namlng] eql 0 or .idcrec [idc$b_namlng] gtru sym$c_maxlng
    then
	begin
	signal (lin$_illnamelen, 6, lnk$gt_entity, idcrec [idc$b_namlng], .idcrec [idc$b_namlng],
	    sym$c_maxlng, obmodesc [omd$b_namlng], lnk$gl_curfil [fdb$q_filename]);
	return false
	end;

!
! THE IDENT STRING
!
    identstring = idcrec [idc$b_namlng] + 1 + .idcrec [idc$b_namlng];

    if .identstring [0] eql 0 or .identstring [0] gtru sym$c_maxlng
    then
	begin
	signal (lin$_illnamelen, 6, lnk$gt_ident, identstring [0], .identstring [0], sym$c_maxlng,
	    obmodesc [omd$b_namlng], lnk$gl_curfil [fdb$q_filename]);
	return false
	end;

!
! AND THE OBJECT NAME
!
    objectname = identstring [1] + .identstring [0];

    if .objectname [0] eql 0 or .objectname [0] gtru sym$c_maxlng
    then
	begin
	signal (lin$_illnamelen, 6, lnk$gt_objnam, objectname [0], .objectname [0], sym$c_maxlng,
	    obmodesc [omd$b_namlng], lnk$gl_curfil [fdb$q_filename]);
	return false
	end;

!
! UPDATE GSD OFFSET INTO RECORD
!
    length = objectname [1] + .objectname [0] - idcrec;
    gsdoffset = .gsdoffset + .length;
!
! ENTRY APPEARS GOOD.  LET'S ENTER IT
!

    if (status = lib$insert_tree (lnk$gl_entitree, idcrec [idc$b_namlng], %ref (0), compare_idc, alloc_idc,
	    entry, idcrec)) eql lib$_keyalrins
    then
	begin
	lib$lookup_tree (lnk$gl_omdtree, .entry [idcd$l_defomd], 	! FIND DEFINING MODULE OMD
	    lnk$compare_omd, defomd);
	defomd = .defomd [node$l_ptr];		! REALLY POINT TO THE OMD
	deffdb = .entry [idcd$l_deffdb];	! GET THE DEFINING FDB

	if (.idcrec [idc$v_binident] neq .entry [idcd$v_binident])
						! IF BOTH ARE NOT THE SAME (ASCIC OR BINARY)
	    or (.idcrec [idc$v_binident]	! OR BINARY IDENT WITH DIFFERENT MATCH CONTROL
	    and (.idcrec [idc$v_idmatch] neq .entry [idcd$v_idmatch]))
	then
	    signal ((lin$_entidmtcht and not sts$m_severity) or .idcrec [idc$v_errsev], 5,
		idcrec [idc$b_namlng], 		! ISSUE WARNING
		obmodesc [omd$b_namlng], lnk$gl_curfil [fdb$q_filename], defomd [omd$b_namlng],
		deffdb [fdb$q_filename]);

	if not ch$eql (.objectname [0], objectname [1], 	! CHECK THAT OBJECT NAMES THE SAME
		.entry [idcd$b_objlng], .entry [idcd$l_objnam] + 1)
	then
	    signal ((lin$_entidmtcho and not sts$m_severity) or .idcrec [idc$v_errsev], 7, objectname [0],
		idcrec [idc$b_namlng], obmodesc [omd$b_namlng], lnk$gl_curfil [fdb$q_filename],
		.entry [idcd$l_objnam], defomd [omd$b_namlng], deffdb [fdb$q_filename]);

	if not .entry [idcd$v_binident]		! NOW CHECK THE IDENT MATCH
	then
	    begin

	    if not ch$eql (.identstring [0], identstring [1], 	! CHECK ASCII IDENTS
		    .entry [idcd$b_idlng], .entry [idcd$l_ident] + 1, 0)
	    then
		signal ((lin$_entidmtch and not sts$m_severity) or .idcrec [idc$v_errsev], 8, objectname [0],
		    identstring [0], idcrec [idc$b_namlng], obmodesc [omd$b_namlng],
		    lnk$gl_curfil [fdb$q_filename], .entry [idcd$l_ident], defomd [omd$b_namlng],
		    deffdb [fdb$q_filename]);

	    end
	else
	    begin
!
! CHECK BINARY IDENTS
!

	    bind
		ident1 = identstring [1] : block [, byte],
		ident2 = entry [idcd$l_ident] : block [, byte];

	    local
		ident1majid,
		ident1minid,
		ident2majid,
		ident2minid;

	    ident1majid = .ident1 [gmt$b_majorid];	! BLISS GENERATES BETTER CODE THIS WAY
	    ident1minid = .ident1 [gmt$b_minorid];
	    ident2majid = .ident2 [gmt$b_majorid];
	    ident2minid = .ident2 [gmt$b_minorid];

	    if .ident1majid neq .ident2majid	! MAJOR IDS MUST BE EQUAL
		or (if .entry [idcd$v_idmatch] eql idc$c_leq	! COMPARE MINOR IDS BASED ON MATCH CONTROL
		then .ident2minid gtru .ident1minid else .ident2minid neq .ident1minid)
	    then
		signal ((lin$_entidmtchb and not sts$m_severity) or .idcrec [idc$v_errsev], 10,
		    objectname [0], .ident1majid, .ident1minid, idcrec [idc$b_namlng],
		    obmodesc [omd$b_namlng], lnk$gl_curfil [fdb$q_filename], .ident2majid, .ident2minid,
		    defomd [omd$b_namlng], deffdb [fdb$q_filename]);

	    end;

	end;

    return true
    end;

routine compare_env (envname, node, envrec) =
    begin
!
!	COMPARE AN ENVIRONMENT NAME WITH THE CURRENT NODE IN TREE
!
    map
	envname : ref vector [, byte],
	node : ref block [, byte];
    bind
	envdesc = .node + node$c_short : block [, byte];

    return ch$compare (.envname [0], envname [1], .envdesc [nvd$b_namlng], envdesc [nvd$t_name], 0)
    end;

routine alloc_env (envname, retnodeadr, envrec) =
    begin
!
!	ALLOCATE A NEW ENVIRONMENT DESCRIPTOR BLOCK
!
    map
	envname : ref vector [, byte],
	retnodeadr : ref vector [, long],
	envrec : ref block [, byte];

    local
	newnode : ref block [, byte],
	envdesc : ref block [, byte];

    lnk$alloblk (node$c_short + nvd$c_size + .envname [0], newnode);
    envdesc = .newnode + node$c_short;
    ch$fill (0, nvd$c_size, .envdesc);
    envdesc [nvd$l_omdnum] = .lnk$gw_nmodules;
    ch$move (.envname [0] + 1, envname [0], envdesc [nvd$b_namlng]);
    retnodeadr [0] = .newnode;
    return true
    end;

routine insudfenv (envnode) : novalue =
    begin
!
!	THIS ROUTINE ENTERS AN ENVIRONMENT INTO THE UNDEFINED
!	ENVIRONMENT LIST.
!
    map
	envnode : ref block [, byte];
    builtin
	insque;

    bind
	envdesc = .envnode + node$c_short : block [, byte];

    local
	ch_result,
	nxtenv : ref block [, byte];		! POINTER TO SYMBOL VALUE BLOCK

!
!	FIND THE SPOT TO INSERT THE NEW ENVIRONMENT IN THE UNDEFINED LIST
!
    nxtenv = lnk$gl_udfenv;			! SCAN THE UNDEFINED LIST

    while (nxtenv = .nxtenv [nvd$l_udflink]) neq lnk$gl_udfenv do
	begin

	if (ch_result = ch$compare (.nxtenv [nvd$b_namlng], 	! IF GREATER
		nxtenv [nvd$t_name], .envdesc [nvd$b_namlng], envdesc [nvd$t_name])) gtr 0
	then
	    exitloop 				! THEN WE ARE ALL DONE
	else

	    if .ch_result eql 0			! IF EQUAL
	    then
		return;				! THEN ALREADY IN LIST, SO RETURN

	end;

    insque (envdesc [nvd$l_udflink], 		! INSERT IN UNDEFINED LIST
	.nxtenv [nvd$l_udblink]);
    lnk$gw_nudfenvs = .lnk$gw_nudfenvs + 1;	! COUNT THE UNDEFINED ENVIRONMENT
    return;
    end;


global routine lnk$fndenvmap (envnum) =
    begin
!
!	THIS ROUTINE RETURNS THE ADDRESS OF THE MAPPING
!	TABLE ENTRY FOR ENVIRONMENT NUMBER "ENVNUM" IN
!	THE CURRENT MODULE.
!	THE ENVIRONMENT MAPPING TABLE IS AN ARRAY POINTED TO BY
!	THE MODULE DESCRIPTOR BLOCK. IT IS INITIALLY
!	ALLOCATED WITH SPACE SUFFICIENT FOR 256
!	ENTRIES.  IF MORE THAN 256 ENVIRONMENTS ARE ENCOUNTERED DURING
!	THE PROCESSING OF THE OBJECT MODULE, THE INITIAL TABLE IS
!	COPIED OUT TO ANOTHER BLOCK, AND THE MAP TABLE ORIGINAL MAP TABLE
!	BECOMES A TABLE OF TABLE ADDRESSES.
!
    literal
	tablesize = 256*pmt$c_size;		! SIZE IN BYTES OF A BLOCK
    local
	blockoff,				! OFFSET OF ENTRY IN EXTENDED BLOCK
	first_entry : ref block [, byte],
	first_256 : ref block [, byte],		! address of block of first 256
	mapent : ref block [, byte],		! ADDRESS IN PSECT MAPPING TABLE
	mapoff : ref block [, byte];		! ADDRESS OF EXTENDED MAPPING BLOCK

    if .lnk$gl_curomd [omd$l_envmap] eql 0	! IF NO TABLE ALLOCATED YET
    then
	begin
	lnk$alloblk (tablesize, lnk$gl_curomd [omd$l_envmap]);	! ALLOCATE IT NOW
	ch$fill (0, tablesize, .lnk$gl_curomd [omd$l_envmap]);
	end;

    mapent = .lnk$gl_curomd [omd$l_envmap] + .envnum*pmt$c_size;
						! GET ENTRY ADDRESS IN BASE MAPPING TABLE

    if not .lnk$gl_curomd [omd$v_e256]		! IF NOT INTO EXTENDED MAP TABLE
	and .envnum lequ 255			!  AND LEQU 255 ENVIRONMENTS
    then
	return .mapent
!
! EXTENDED ENVIRONMENT ENTRY
!
    else
	begin
	blockoff = (.envnum mod 256)*pmt$c_size;	! OFFSET OF ENTRY WITHIN EXTENDED TABLE
	mapent = .lnk$gl_curomd [omd$l_envmap] + ((.envnum )/256)*pmt$c_size;
						! GET ADDRESS OF EXTENDED TABLE ADDRESS

	if ..mapent neq 0			! IF EXTENDED TABLE PRESENT
	    and .lnk$gl_curomd [omd$v_e256]	!  AND THERE REALLY IS AN EXTENDED TABLE
	then
	    return ..mapent + .blockoff		!  THEN RETURN ENTRY ADDRESS
	else
	    begin
	    lnk$alloblk (tablesize, mapoff);	! ALLOCATE EXTENDED TABLE BLOCK

	    if not .lnk$gl_curomd [omd$v_e256]	! IF THIS IS THE FIRST ONE
	    then
		begin
		first_entry = lnk$gl_curomd[omd$l_envmap];
		lnk$alloblk(tablesize,first_256);
		ch$move (tablesize, .lnk$gl_curomd [omd$l_envmap], .first_256);	! AND COPY BASE TABLE OUT
		ch$fill (0, tablesize, .lnk$gl_curomd [omd$l_envmap]);	! ZERO BASE TABLE
		first_entry[pmt$l_secpmt] = .first_256;
		lnk$gl_curomd [omd$v_e256] = true;	! FLAG INTO EXTENDED TABLE
		end;

	    ch$fill (0, tablesize, .mapoff);	!  ZERO NEW BLOCK

	    !
	    ! POINT ENTRY IN BASE TABLE TO NEW BLOCK
	    !
	    mapent [pmt$l_secpmt] = .mapoff;
	    return .mapoff + .blockoff
	    end;

	end;

    end;


routine proenv =
!
!	THIS ROUTINE PROCESSES ENVIRONMENT DEFINITION/REFERENCE
!	SUBRECORDS.
!
    begin
    bind
	envrec = objvec [.gsdoffset] : block [, byte];
    builtin
	remque;
    local
	ptr,
	envmap : ref block [, byte],
	envnode : ref block [, byte],
	envdesc : ref block [, byte];

    if .envrec [env$b_namlng] eql 0 or .envrec [env$b_namlng] gtru sym$c_maxlng
    then
	(signal (lin$_illnamelen, 6, lnk$gt_envstring, envrec [env$b_namlng], .envrec [env$b_namlng],
	    sym$c_maxlng, obmodesc [omd$b_namlng], lnk$gl_curfil [fdb$q_filename]); return false);

!
! INSERT ENVIRONMENT RECORD INTO ENVIRONMENT TREE
!
    lib$insert_tree (lnk$gl_envtree, envrec [env$b_namlng], %ref (0), compare_env, alloc_env, 
			envnode, envrec);
    envdesc = .envnode + node$c_short;
!
! PUT ENVIRONMENT INTO THE ENVIRONMENT MAP TABLE
!
    obmodesc [omd$v_noenv] = false;
    obmodesc [omd$w_hienv] = .obmodesc [omd$w_hienv] + 1;
    envmap = lnk$fndenvmap (.obmodesc [omd$w_hienv]);
    envmap [pmt$l_pscdes] = .envnode;
 
!IF .ENVMAP[PMT$L_SYMLST] NEQ 0			! SYMBOLS DEFINED BEFORE THE ENVIRONMENT?
!THEN BEGIN				!**ONLY NEED TO ASSOCIATE SYMBOLS WITH ENVIRONMENT FOR CROSS REF
!    TRUE
!    END;
!
! IF THIS IS A DEFINITION, REMOVE FROM UNDEFINED LIST IF IT'S
! ON IT.  IF IT'S THE FIRST REFERENCE TO THIS ENVIRONMENT,
! THEN PUT IT ON THE UNDEFINED LIST.
!

    if .envrec [env$v_def]
    then
	begin

	if .envdesc [nvd$l_udflink] neq 0
	then
	    (remque (envdesc [nvd$l_udflink], ptr);
	    lnk$gw_nudfenvs = .lnk$gw_nudfenvs - 1);

	envdesc [nvd$v_def] = true;

	if .envmap[pmt$l_symlst] neq 0
	then
	    begin
	    envdesc[nvd$l_symtbl] = .envmap[pmt$l_symlst];
	    envmap[pmt$l_symlst] = 0;
	    end;
	end
    else

	if not .envdesc [nvd$v_def] and .envdesc [nvd$l_udflink] eql 0 
	then 
	    insudfenv (.envnode);

    gsdoffset = .gsdoffset + envrec [env$t_name] - envrec [env$b_gsdtyp] + .envrec [env$b_namlng];
    return true
    end;

routine localsymbols =
begin
local
	length;
bind
	symbolrec = objvec [.gsdoffset] : block [, byte];

entrymask = 0;							! ZERO THE ENTRY MASK SINCE NONE EXISTS

if not .symbolrec [lsy$v_def]					! IF NOT DEFINED
then begin
     symbolstring = symbolrec [lsrf$b_namlng];			! POINT TO THE SYMBOL STRING
     length       = symbolrec [lsrf$t_name] - symbolrec [lsrf$t_start] + .symbolrec [lsrf$b_namlng];
     end
else begin
     symbolstring = symbolrec [lsdf$b_namlng];			! POINT TO THE SYMBOL
     length       = symbolrec [lsdf$t_name] - symbolrec [lsdf$t_start] + .symbolrec [lsdf$b_namlng];
     end;

if not prosymbol (0)						! GO PROCESS THIS SYMBOL
then return false;						! AND EXIT IF FAILURE

gsdoffset = .gsdoffset + .length;				! UPDATE THE GSD OFFSET FOR NEXT
return true
end;

routine localentpnt =
begin
local
	length;
bind
	symbolrec = objvec [.gsdoffset] : block [, byte];

entrymask    = .symbolrec [lepm$w_mask];			! EXTRACT THE ENTRY POINT MASK
symbolstring =  symbolrec [lepm$b_namlng];			! POINT TO THE SYMBOL
length       =  symbolrec [lepm$t_name] - symbolrec [lepm$t_start] + .symbolrec [lepm$b_namlng];

if not prosymbol (1)						! GO PROCESS THE SYMBOL
then return false;						! AND EXIT IF FAILURE

gsdoffset = .gsdoffset + .length;				! ELSE UPDATE THE OFFSET FOR NEXT
return true
end;

routine localprocedef =
    begin
!
!	PROCESS PROCEDURE DEFINTION OF MODULE LOCAL SYMBOL
!	SEE PROCEDEF FOR AN EXPLANATION OF WHAT A PROCEDURE
!	DEFINITION LOOKS LIKE.
!

    local
	entflag,
	argvaldata : ref vector [, byte],
	argcount;

!

    if not localentpnt () then return false;	! PROCESS THE ENTRY POINT SYMBOL PART

    entflag = .symtabent neq 0;			! SEE IF ENTERED
    begin

    bind
	formals = objvec [.gsdoffset] : block [, byte];	! THE FORMAL DESCRIPTION

    if .formals [fml$b_minargs] gtru .formals [fml$b_maxargs]	! IF THERE IS AN INCONSISTENT
    then
	begin					! DESCRIPTION OF FORMALS
	signal (lin$_illfmlcnt, 5, 		! OUTPUT ERROR MESSAGE
	    .formals [fml$b_minargs], .formals [fml$b_maxargs], symentnam [snb$b_namlng],
	    obmodesc [omd$b_namlng], lnk$gl_curfil [fdb$q_filename]);
	return false;
	end;

    gsdoffset = .gsdoffset + fml$c_size;	! UPDATE RECORD POINTER

    if .entflag					! DELETE OLD VALIDATAION DATA
	and (argvaldata = .symtabent [sym$l_valdata]) neq 0
    then
	begin					! MUST BE A NEW DEFINITION
	lnk$dealblk (.argvaldata [0], argvaldata [0]);	! SO DISPOSE OF OLD DATA
	symtabent [sym$l_valdata] = 0;		! AND FORGET IT
	end;

    if (argcount = .formals [fml$b_maxargs]) eql 0	! IF MAXIMUM NUMBER ARGUMENTS
    then
	return true;				! IS ZERO, ALL DONE

    if .entflag
    then
	begin
	lnk$alloblk (.argcount + 2, symtabent [sym$l_valdata]);	! ALLOCATE A VALIDATION DATA BLOCK
	argvaldata [0] = .argcount + 2;		! SET ITS SIZE
	argvaldata [1] = .formals [fml$b_minargs];	! SAVE MINIMUM ARGUMENT SPECIFICATION
	end;

    incr i from 1 to .argcount			! BEGIN A LOOP THROUGH
	do
	begin					! ALL FORMAL ARGUMENT DESCRIPTORS

	bind
	    argdesc = objvec [.gsdoffset] : block [, byte];	! POINT TO NEXT DESCRIPTOR

	if .entflag then argvaldata [.i + 1] = .argdesc [arg$v_passmech];

						! EXTRACT THE PASSING MECHANISM
	gsdoffset = .gsdoffset + .argdesc [arg$b_bytecnt] + 	! AND UPDATE RECORD POINTER
	arg$c_size;
	end;

    return true;
    end;
    end;

routine progsd =
    begin
!

!++
!	VERIFY GSD RECORDS AND DISPATCH ON THE FOUR SUB-TYPES:
!		(0) P-SECTION DEFINITION
!		(1) SYMBOL DEFINITION/REFERENCE
!		(2) ENTRY POINT DEFINITION
!		(3) PROCEDURE DECLARATION
!--

!

    bind
	gsddispatch = plit (
			propsectdef,
			symbols,
			entpnts,
			procedef,
			symbols,
			entpnts,
			procedef,
			randentity,
			proenv,
			localsymbols,
			localentpnt,
			localprocedef,
			propsectdef) : vector;

!

    local
	gsdtype;

!

    if not seqchk () then return false;

    gsdoffset = obj$c_subtyp;
!

    while .gsdoffset lssu .reclng do
	begin

	if (gsdtype = .objvec [.gsdoffset]) gequ .gsddispatch [-1]
	then
	    begin
	    signal (lin$_gsdtyp, 3, .gsdtype, obmodesc [omd$b_namlng], lnk$gl_curfil [fdb$q_filename]);
	    return false;
	    end
	else
	    begin
	    wordpsectgsd = ((.gsdtype gequ gsd$c_symw)	! TEST FOR WORD OF PSECT NUMBER
	    and (.gsdtype lequ gsd$c_prow));
	    lclsymgsd = ((.gsdtype gequ gsd$c_lsy)	! TEST FOR LOCAL SYMBOL
	    and (.gsdtype lequ gsd$c_lpro));

	    if not (.gsddispatch [.gsdtype]) () then return false;

	    end;

	end;					! OF LOOP ON A CONCATENATED GSD RECORD

    return true					! ALL DONE
    end;					! OF PROGSD


global routine lnk$procsobj (modrfa) =
!
! READ AND PROCESS ALL REQUIRED OBJECT MODULE RECORDS OF THE FILE JUST OPENED
! THAT IS, KEEP READING RECORDS TO END OF FILE EXCEPT IF THIS FILE IS A LIBRARY, 
! STOP AT THE FIRST END OF MODULE RECORD.
! 
! MODRFA EXISTS IN THE CASE OF A LIBRARY MODULE OR SHAREABLE IMAGE AND
! IS A POINTER TO THE RECORD FILE ADDRESS OF THE MODULE.
!
begin
map
	modrfa : ref block [, byte] ;				! REALLY A POINTER
bind
	auxfnb = lnk$gl_curfil [fdb$t_auxfnb] : block [, byte];	! AUXILIRIARY FILENAME BLOCK

while lnk$nxtrec (objrecdesc)					! IF THERE IS ANOTHER RECORD
do  begin
    local	status ;

    if .reclng gtru .maxreclng					! AND ITS LENGTH IS ILLEGAL
    then begin
	 if .mhdseen 
	 then signal (lin$_illreclen, 3		 		! TELL MODULE NAME IF IT IS KNOWN
		     ,.reclng, obmodesc [omd$b_namlng] 
		     ,lnk$gl_curfil [fdb$q_filename]
		     ) 
	 else signal (lin$_reclng, 2 				! OUTPUT AN ERROR AND QUIT ON SEVERE ERROR
		     ,lnk$gl_curfil [fdb$q_filename]
		     ,.reclng
		     ) ; 
	 end
    else begin							! LENGTH OF RECORD OR SO
	 lastrectyp = .currectyp ;				! COPY OLD CURRENT TO LAST TYPE
	 currectyp  = .objrec [obj$b_rectyp] ;			! AND GET NEW TYPE
	 if .currectyp lssu .recdispatch [-1]			! CHECK IT IS WITH RANGE
	 and not (not .mhdseen and (.currectyp neq obj$c_hdr))	! MUST BE "hdr" IF HEADER NOT SEEN YET
	 then (.recdispatch [.currectyp]) ()			! DISPATCH TO RECORD SPECIFIC ROUTINE
	 else begin
	      if .mhdseen 
	      then signal (lin$_illrectyp, 4		 	! TELL MODULE NAME IF KNOWN
			  ,.currectyp, obmodesc [omd$b_namlng]
			  ,.lnk$gl_record, lnk$gl_curfil [fdb$q_filename]
			  )
	      else signal (lin$_rectyp, 3		 	! ELSE OUTPUT ERROR
			  ,lnk$gl_curfil [fdb$q_filename]
			  ,.lnk$gl_record, .currectyp
			  ) ;
	      end ;
	 end ;

    if ((.currectyp eql obj$c_eom)   or   (.currectyp eql obj$c_eomw))	! IF THAT RECORD WAS AN EOM
	and 								! OR CONTAINS A SHAREABLE IMAGE
	(.lnk$gl_curfil [fdb$v_libr] or .lastobjmod [omd$v_shrimg])	! AND THE FILE IS A LIBRARY
    then
	begin								! THEN THE FILE IS DONE
	lastobjmod [omd$l_modvbn] = .modrfa [rfa$l_vbn] ;		! AS SOON AS WE EXTRACT THE RFA
	lastobjmod [omd$w_bytoff] = .modrfa [rfa$w_offset] ;		! OF THE MODULE
	return true ;
	end ;
    end ;								! OF RECORDS LOOP

!
!   ALL OBJECT RECORDS HAVE BEEN READ AND PROCESSED
!
if  (.currectyp neq obj$c_eom)			
and (.currectyp neq obj$c_eomw)
then begin
     local	eomrec : block [eom$c_eommin, byte] ;

     signal (lin$_noeom, 2
	    ,obmodesc [omd$b_namlng]			 	! IF DID NOT END WITH EOM, THEN WARNING
	    ,lnk$gl_curfil [fdb$q_filename]
	    ) ;
     eomrec [eom$b_rectyp] = obj$c_eom ;			! CREATE FAKE EOM RECORD
     eomrec [eom$b_comcod] = eom$c_error;
     reclng    = 2 ;						! SET LENGTH OF RECORD
     objrec    = eomrec ;					! AND IT'S ADDRESS
     currectyp = obj$c_eom ;					! SET RECORD TYPE
     proeom (1) ; 						! FINISH EOM PROCESSING
     mhdseen   = false ;					! RESET MHD FLAGS
     lnmseen   = false ;
     end ;

return true ;							! FINALLY RETURN AFTER NO MORE
end ;								! OF PASS 1 OBJ READING ROUTINE


global routine lnk$objpass1 (arglist) =
!
!	THIS IS THE MAIN DRIVING ROUTINE OF PASS ONE. IT OPENS
!	EACH FILE AND IF A LIBRARY, CALLS THE LIBRARY PROCESSING ROUTINE
!	OR IF NOT A LIBRARY ASSUMES IT IS A CONCATENATED OBJ FILE
!	AND CALLS THE OBJ MODULE PROCESSOR.
!	WHEN NO MORE FILES REMAIN, IF THERE ARE STILL UNDEFINED SYMBOLS
!	THE SYSTEM LIBRARY IS MATERAILIZED AS AN INPUT FILE AND
!	PROCESSED.
!
!	ARGLIST CONTAINS THE ADDRESS OF THE ARGUMENT LIST WITH WHICH THE LINKER
!	WAS ORIGINALLY CALLED. IT IS MERELY PASSED ON TO THE OBJECT
!	LIBRARY PROCESSOR SO IT CAN RE-CALL CLI TO OBTAIN THE NAMES (IF ANY)
!	OF MODULES TO BE EXPLICITLY EXTRACTED FROM THE LIBRARY.
!
begin
builtin
	insque,					! QUE INSERTION AND
	remque;					! QUE REMOVING INSTRUCTIONS
local
	suffix,					! UNDEFINED SYMBOL LIST SUFFIX POINTER
	nxtsymnam : ref block [, byte],		! NEXT SYMBOL NAME BLOCK POINTER
	nxtsyment : ref block [, byte];		! FOR SCANNING LIST OF UNDEFINED SYMBOLS

!
!   INSERT THE SYMBOL "SYS$K_VERSION" INTO THE SYMBOL TABLE AS AN UNDEFINED
!   WEAK ABSOLUTE REFERENCE WITH THE SPECIAL INTERNALLY CREATED SYMBOL
!   FLAG.
!
lnk$search (lnk$gt_sysver, symtabent, symentnam);		! FIND WHERE IT GOES
lnk$insert (lnk$gt_sysver, symtabent, symentnam);		! AND INSERT IT
symtabent [sym$v_weak]	 = true;				! FLAG WEAK
symtabent [sym$v_intsym] = true;				! AND INTERNALLY CREATED
lnk$insudfsym (.symtabent);					! INSERT IN UDEFINED SYMBOL LIST
obmodesc [omd$l_lsterr]	 = obmodesc [omd$l_errtxt];
lnk$gl_curomd 		 = obmodesc;				! POINT TO THE DESCRIPTOR

!
!   BEGIN THE LOOP WHICH OPENS EACH INPUT FILE
!
while lnk$nxtfil ()						! WHILE THERE REMAIN
do  begin							! MORE OBJ FILES
    last_lnkopt_fdb = 0;					! Haven't seen linker opt recs in this file yet
    lnk$gw_nfiles   = .lnk$gw_nfiles + 1;			! COUNT THE FILE
    lastobjmod      = lnk$gl_curfil [fdb$l_omdlst];		! INITIALIZE LAST DESCRIPTOR TO LISTHEAD

    if not (if  .lnk$gl_curfil [fdb$v_libr]			! IF THIS INPUT FILE IS A LIBRARY
	    then lnk$procslib (.arglist)			! GO PROCESS IT
	    else if  .lnk$gl_curfil [fdb$v_shr]			! IF A SHAREABLE IMAGE
		 then lnk$procshrim ()				! GO PROCESS IT
		 else lnk$procsobj ()				! OTHERWISE ASSUME CONCATENATED OBJECT
	   )
    then return false;						! EXIT NOW ON FAILURE

    lastobjmod [omd$l_nxtomd] = 0;				! END OF USER INPUT FILES
    end;							! END OF USER INPUT FILES

!
!   NOW CHECK THAT WE DID GET SOME MODULES AND IF SO
!   CHECK FOR UNDEFINED SYMBOLS.
!
lnk$gl_curomd = 0;						! NO OBJECT MODULE NOW

if .lnk$gw_nmodules eql 0 then signal_stop (lin$_nomods);

if .lnk$gw_nudfsyms neq 0					! IF THERE ARE STILL SOME UNDEFINED (STRONG REFS)
then signal (lin$_nudfsyms, 1, .lnk$gw_nudfsyms);		! THEN REPORT THE NUMBER

while not remque (.lnk$gl_udflst, nxtsyment)			! AND REMOVE EACH FROM TOP
do  begin							! OF THE LIST, OUTPUTTING
    bind nxtsymnam = .nxtsyment - .nxtsyment [sym$b_namlng] 	! POINT TO SYMBOL NAME BLOCK
			- snb$c_fxdlen	: block [, byte];

    if not .nxtsyment [sym$v_intsym]
    then begin
	 if not .nxtsyment [sym$v_weak]				! THE SYMBOL NAME
	 then suffix = cstring (' ')				! WITH NULL OR 'WEAK'
	 else begin
	      suffix = cstring (' (Weak Reference)');		! SUFFIX DEPENDING ON THE REFERENCE
	      nxtsyment [sym$v_def] = true;			! BEING WEAK OR STRONG AND
	      end;						! ENSURE WEAKS ARE NOW DEFINED

	 if .lnk$gw_nudfsyms neq 0				! NOW LIST THE SYMBOL PROVIDED
	 then signal (lin$_udfsym, 2				! NOT ALL WERE WEAK
		     ,nxtsymnam [snb$b_namlng], .suffix
		     );

	 nxtsyment [sym$l_value] = 0;				! SET ITS VALUE TO 0
	 nxtsyment [sym$v_rel]   = false;			!  AND MAKE IT ABSOLUTE

	 if not .lnk$gl_ctlmsk [lnk$v_brief]			! PROVIDED THIS IS NOT A
	 and    .lnk$gl_ctlmsk [lnk$v_map]			! BRIEF MAP
	 then crf$insrtkey ( lnk$al_sytblfmt			! INSERT THE KEY (SYMBOL) IN
			   , nxtsymnam [snb$b_namlng]		! CREF'S TABLE SO THAT WE MAY
		    	   , nxtsyment [sym$l_value] 		! MAP UNDEFINED SYMBOLS
			   ,.nxtsyment [sym$w_flags]		! AND IGNORE ERROR FROM CREF
			   ) ;
	 end							! NOT INTERNALLY CREATED SYMBOL
    else begin
	 nxtsyment [sym$l_value] = 0;				! INTERNALLY CREATED--ZERO VALUE
	 nxtsyment [sym$v_rel]   = false;			!  AND MAKE IT ABSOLUTE
	 end;
    end;

!
!   LIST ANY UNDEFINED ENVIRONMENTS
!
if .lnk$gw_nudfenvs neq 0
then begin
     local	envdesc : ref block [, byte];

     signal (lin$_nudfenvs, 1, .lnk$gw_nudfenvs);

     envdesc = .lnk$gl_udfenv [0];
     while .envdesc neq lnk$gl_udfenv 
     do	begin
	signal (lin$_udfenv, 1, envdesc [nvd$b_namlng]);
	envdesc = .envdesc [nvd$l_udflink];
	end;
     end;

!
!   LIST ANY UNDEFINED MODULE-LOCAL SYMBOLS
!
if .lnk$gw_nudflsyms neq 0
then begin
     signal (lin$_nudflsyms, 1, .lnk$gw_nudflsyms);		! TELL THAT THERE ARE UNDEF. LOCAL SYMBOLS
	
     while not remque (.lnk$gl_udflsy, nxtsyment)		! FOR EACH ONE OF THEM
     do	begin
	bind nxtsymnam = .nxtsyment - .nxtsyment [sym$b_namlng] - snb$c_fxdlen : block [, byte];

	if not .nxtsyment [sym$v_weak]				! SET SUFFIX TO SYMBOL MESSAGE
	then suffix = cstring (' ')
	else begin
	     suffix = cstring (' (Weak Reference)');		! IF IT'S WEAK, THEN SAY SO
	     nxtsyment [sym$v_def] = true;
	     end;

	signal (lin$_udfsym, 2, nxtsymnam [snb$b_namlng], .suffix);	! TELL USER OF UNDEFINED LOCAL SYMBOL
	nxtsyment [sym$l_value] = 0;				! DEFINE IT AS ABSOLUTE 0
	nxtsyment [sym$v_rel]   = false;
	end;
     end;

if .lnk$gl_dbgtfps eql 0					! IF NO DEBUGGER TRANSFER ADDRESS SEEN
then if lnk$search (lnk$gt_imgsta, symtabent, symentnam)	! THEN LOOK UP SYS$IMGSTA
     then if .symtabent [sym$v_def]				! AND IF DEFINED
	  then	begin
		lnk$gl_dbgtfr  = .symtabent [sym$l_value];	! SET ITS ADDRESS
		lnk$gl_dbgtfps = 1;				! FLAG THERE IS A DEBUG XFR ADDRESS
		end;

!
!   DEFINE ANY PSECTS SPECIFIED IN A PSECT= OPTION THAT WERE NOT
!   SPECIFIED IN A COLLECT PSECT OPTION
!
lnk$gl_curclu = lnk$gl_defclu;					! SET TO DEFAULT CLUSTER
lib$traverse_tree (lnk$gl_pscdflst, checkpddentry);		! TRAVERSE THE TREE

return true;
end;



end
eludom
