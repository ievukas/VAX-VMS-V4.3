MODULE common_file_qualifiers(
    		%TITLE 'Common file qualifier'
    		IDENT = 'V04-000'
		) =

BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY:
!	VAX/VMS Run-Time Library
!
! ABSTRACT:
!	This module contains routines which perform command qualifier parsing
!	and analysis for a set of qualifiers which select files based on
!	information contained in the RMS control blocks.
!
! ENVIRONMENT:
!	VAX/VMS user mode
!
!--
!
! AUTHOR:  Tamar Krichevsky,	CREATION DATE: 29-Jun-1982
!	   (with acknowledgements to Marty Jack and BACKUP)
!
! MODIFIED BY:
!
!       V03-013 TSK0012		Tamar Krichevky		 19-Jul-1984
!		Use the most complete name when signaling invalid qualifier
!		value for the /EXCLUDE qualifier.  In other words, if there
!		is and resultant or expanded name string, use those, instead
!		of the value on the command line.
!
!       V03-012 TSK0011		Tamar Krichevky		 28-Mar-1984
!		Check the return status from TPARSE, after it attempts to
!		parse the value given by the /BY_OWNER qualifier.  If the
!		return status is SS$_NOSUCHID, then signal that -- instead of
!		CLI$_INVQUALVAL.
!
!       V03-011 TSK0010		Tamar Krichevky		 5-Mar-1984
!		Replace a call to CLEAN_UP, in LIB$QUAL_FILE_MATCH, with a 
!		direct return to the calling routine.  This avoids referencing
!		the varaible XAB_HOLDER before it is initialized.
!
!		Also, pass back the appropriate value after the answer to the
!		/CONFIRM prompt has been evaluated.  
!
!       V03-010 TSK0009		Tamar Krichevky		 7-Feb-1984
!		Make sure /BEFORE or /SINCE is specified whenever any of
!		the time qualifiers are given (/CREATED, /EXPIRED...)
!		Also, retrun LIB$_QUIPRO for all files encountered after
!		^Z or "QUIT" is given as response to a /CONFIRM prompt.
!
!	V03-009	LMP0140		L. Mark Pilant,		24-Aug-1983  1:16
!		Add support for alphanumeric UICs.
!
!       V03-008 TSK0008		Tamar Krichevky		14-Mar-83
!		Change addressing modes to longword relative to avoid
!		truncation errors when linking with large images.
!
!       V03-007 TSK0007		Tamar Krichevky		14-Mar-83
!		Change "qdesc_byowner" reference to "qdesc_by_owner".
!
!       V03-006 TSK0006		Tamar Krichevky		11-Mar-83
!		By popular demand the /BYOWNER qualifier is changed to 
!		/BY_OWNER.  Also, fix logic so that the presence of the 
!		confirm prompt arguement is only checked after it is determined 
!		that it is needed.
!
!       V03-005 TSK0005		Tamar Krichevky		11-FEB-83
!		Change the /UIC qualifier to /BYOWNER.
!
!       V03-004 TSK0004		Tamar Krichevky		29-Dec-82
!		Parse the file name passed to LIB$QUAL_FILE_MATCH and use
!		the expanded name string, if the resultant name string has
!		not been defined (the file has not been open), as the
!		canidate string for MATCH.
!
!       V03-003 TSK0003		Tamar Krichevky		23-NOV-82
!		General clean up and modification.  Several people had 
!		suggestions such as removing OWN storage, freeing virtual
!		memory, not signalling RMS returns, etc.  The following lists
!		the changes:
!		- Remove OWN storage, used for TPARSE, and replace it with
!		  action routines to make these routines re-entrant.
!		- Clean up PARSE_EXCL_SPEC a little bit: fix some if statements,
!		  take out extra $PARSE call, etc.
!		- Replace the miriad of IF statements in LEGAL_ANSWER with
!		  a table and loop.
!		- Insert PSECT declarations to make the code PIC and sharable.
!		- Return RMS file errors instead of signalling them.
!		- Change signalled conditions to have the CLI facility code,
!		  instead of LIB.
!		- Add the LIB$QUAL_FILE_END routine, which cleans up the virtual
!		  memory allocated by LIB$QUAL_FILE_PARSE and used by 
!		  LIB$QUAL_FILE_MATCH.
!
!	V03-002 TSK0002		Tamar Krichevsky	 8-NOV-82
!		Change logical expression from "IF stmt = 0" to "IF stmt EQL 0".
!		
!	V03-001 TSK0001		Tamar Krichevsky	11-Oct-82
!		Change the bit field names to match those in STARLET.  To 
!		prevent potential duplicate declarations the format for Common 
!		Qualifier Flags names is LIB$V_CQF_...
!**

!
! PSECTS
!
PSECT
    CODE = $CODE (READ, NOWRITE, EXECUTE, SHARE, PIC,
    	ADDRESSING_MODE (LONG_RELATIVE)),
    PLIT = $CODE (READ, NOWRITE, EXECUTE, SHARE, PIC,
    	ADDRESSING_MODE (LONG_RELATIVE)),
    OWN = $DATA (READ, WRITE, NOEXECUTE, NOSHARE, PIC,
    	ADDRESSING_MODE (LONG_RELATIVE)),
    GLOBAL = $DATA (READ, WRITE, NOEXECUTE, NOSHARE, PIC,
    	ADDRESSING_MODE (LONG_RELATIVE))
    ;

!
! SWITCHES:
!
SWITCHES ADDRESSING_MODE
    (EXTERNAL = GENERAL, NONEXTERNAL = LONG_RELATIVE)
    ;
!
! TABLE OF CONTENTS
!
FORWARD ROUTINE
    get_vm,				! Allocate some virtual memory
    get_zero_vm,			! Allocate & clear some virtual memory
    parse_excl_spec : NOVALUE,		! Parse the file spec given in /EXCLUDE
    set_uic_value,			! Retrieve the UIC values given by /BY_OWNNER
    clean_up,				! Clean_up RMS blocks and return
    legal_answer,			! Check answer to /CONFIRM prompt
    find_rms_blocks : NOVALUE,		! Locates needed XAB's in a chain
    lib$confirm_act,			! /CONFIRM action routine
    lib$qual_file_parse,		! Parse the common file qualifiers
    lib$qual_file_match,		! Evaluate file match criteria
    lib$qual_file_end			! Free up any virtual memory allocated
    ;


!
! INCLUDE FILES
!
LIBRARY
    'SYS$LIBRARY:TPAMAC'
    ;
LIBRARY
    'SYS$LIBRARY:STARLET'
    ;

!
! Structure declaration used for system defined structures. This structure
! is byte sized.
!

STRUCTURE

	BBLOCKVECTOR [I, O, P, S, E; N, BS] =
	    [N*BS]
	    ((BBLOCKVECTOR+I*BS)+O)<P,S,E>
	;


!
! MACROS
!
MACRO

    ! Field definitions for the QUALIFIER database. (QUALIFIER bblock)
    !
    !
    ! The following bit fields in the QUALIFIER area are set if a qualifier
    ! is legal (selected by the caller) and also present on the command line.
    !
    confirm_present	=  0,  0,  1, 0 %,	! /CONFIRM 
    exclude_present	=  0,  1,  1, 0 %,	! /EXCLUDE 
    before_present	=  0,  2,  1, 0 %,	! /BEFORE 
    since_present	=  0,  3,  1, 0 %,	! /SINCE 
    created_present	=  0,  4,  1, 0 %,	! /CREATED 
    modified_present	=  0,  5,  1, 0 %,	! /MODIFIED 
    expired_present	=  0,  6,  1, 0 %,	! /EXPIRED
    backup_present	=  0,  7,  1, 0 %,	! /BACKUP
    byowner_present	=  0,  8,  1, 0 %,	! /BY_OWNER
    						!
    !
    ! These fields point to or contain values that appear on the command
    ! line.
    !
    exclude_list	=  4,  0, 32, 0 %,	! List head for /EXCLUDE list
    before_value	=  8,  0,  0, 0 %,	! /BEFORE time value, quadword
    since_value 	= 16,  0,  0, 0 %,	! /SINCE time value, quadword
    uic_value		= 24,  0, 32, 0 %,	! /BY_OWNER UIC value
    uic_member     	= 24,  0, 16, 0 %,	! 	member portion
    uic_group   	= 26,  0, 16, 0 %,	! 	group portion
    uic_wldmem   	= 28,  0,  1, 0 %,	! 	member value was wild
    uic_wldgrp   	= 28,  1,  1, 0 %,	! 	group value was wild
    uic_grp_parsed   	= 28,  2,  1, 0 %,	! Group portion has been parsed
    !
    ! Field defiintions for flags, which when set effect the operaton of
    ! LIB$QUAL_FILE_MATCH.
    !
    callers_fab		= 28,  3,  1, 0 %,	! caller passed a file name not  a FAB
    file_open		= 28,  4,  1, 0 %,	! caller has file already open
    display_hdr		= 28,  5,  1, 0 %,	! information in file header will be looked at
    quit_processing	= 28,  6,  1, 0 %	! Response to /CONFIRM prompt was ^Z or QUIT
    ;


MACRO

    ! Field descriptions for varying string descriptor.
    !
    var_str_len		=  0,  0, 16, 0 %,	! current length of string
    var_str_body	=  2,  0,  0, 0 %,	! body of string


    ! These MACROS describe an element of the exclude list.  This list
    ! contains the file specifications given in the /EXCLUDE qualifier.
    ! An element consists of a pointer to the next element and a descriptor
    ! for the file specification.
    !
    next_excl_blk  	=  0,  0, 32, 0 %,	! Pointer to next element
    excl_spec_desc 	=  4,  0,  0, 0 %	! Descriptor in element
    ;

    ;
!
! EQUATED SYMBOLS
!

LITERAL
    true 	= 1,
    false	= 0,
    success	= 1,
    failure	= 0,
    quad	= 8			! Size of a quad word, for declarations
    ;

LITERAL
    qual_blk_len = 32,			! Length qualifier database
    excl_blk_len = 12			! Length of exclude list element
    ;


!
! EXTERNAL REFERENCES
!
EXTERNAL ROUTINE
    CLI$GET_VALUE,			! Get a qualifier or value from the command line
    CLI$PRESENT,			! Determine if entity is present
    LIB$GET_VM, 			! Allocate some virtual memory
    LIB$CVT_TIME,			! Convert an ASCII time to 64-bits
    LIB$TPARSE,				! Table driven parser
    LIB$SIG_TO_RET,			! Convert a signal to a return
    LIB$GET_COMMAND,			! Get a sring from SYS$COMMAND
    STR$UPCASE, 			! Up case a string
    MATCH,				! Compare a file spec to a pattern
    LIB$FREE_VM				! Deallocate virtual memory
    ;


EXTERNAL LITERAL
    LIB$_FILFAIMAT,
    LIB$_INTLOGERR,
    LIB$_INVARG,
    LIB$_INVXAB,
    LIB$_NEGANS,
    LIB$_QUIPRO,
    LIB$_QUICONACT
    ;

$SHR_MSGDEF( CLI, 3, GLOBAL,
    (CONFQUAL, SEVERE),
    (INVQUAVAL, SEVERE),
    (QUALMISS, SEVERE),
    (NOSUCHID, SEVERE)
    );

! Address of the qualifier data base has been placed in the TPA$L_PARAM field
! of the TPARSE parameter block.  THIS FIELD MUST NOT BE ALTERED by any of the
! state transitions or the action routine will not work.
!
$INIT_STATE( cq_uic_states, cq_uic_keys );

$STATE( ,
    (TPA$_IDENT,,set_uic_value)
    );
$STATE( ,
    (TPA$_EOS,TPA$_EXIT)
    );



%SBTTL 'GET_VM'
ROUTINE get_vm( size ) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine calls LIB$GET_VM to allocate a block of virtual memory.
!
! FORMAL PARAMETERS:
!
!	SIZE	:  The size of the area, in bytes
!
! IMPLICIT INPUTS:
!
!	None
!
! IMPLICIT OUTPUTS:
!
!	None
!
! ROUTINE VALUE:
!
!	Address of the allocated area
!
! COMPLETION CODES:
!
!	Any completion code from LIB$GET_VM
!
! SIDE EFFECTS:
!
!	If allocation fails, fatal error is signalled
!
!--

BEGIN

LOCAL
    rtn_status,				! Status returns from LIB$GET_VM call
    area_loc				! Pointer to the allocated area
    ;



! Allocate some virtual memory; check the return status.  If it isn't 
! successful, signal.
!
IF NOT ( rtn_status = LIB$GET_VM( size, area_loc ))
THEN
    SIGNAL( .rtn_status );


! Return the location of the memory.
!
RETURN .area_loc;

END;					! End of routine get_vm

%SBTTL 'GET_ZERO_VM'
ROUTINE get_zero_vm( size ) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine calls LIB$GET_VM to allocate a block of virtual memory
!	and clears the allocted area.
!
! FORMAL PARAMETERS:
!
!	SIZE	:  The size of the area, in bytes
!
! IMPLICIT INPUTS:
!
!	None
!
! IMPLICIT OUTPUTS:
!
!	None
!
! ROUTINE VALUE:
!
!	Address of the allocated area
!
! COMPLETION CODES:
!
!	Any completion code from LIB$GET_VM
!
! SIDE EFFECTS:
!
!	If allocation fails, fatal error is signalled
!
!--

BEGIN

LOCAL
    rtn_status,				! Status returns from LIB$GET_VM call
    area_loc				! Pointer to the allocated area
    ;


! Allocate some virtual memory; check the return status.  If it isn't 
! successful, signal.
!
IF NOT ( rtn_status = LIB$GET_VM( size, area_loc ))
THEN
    SIGNAL( .rtn_status );


! Zero out the area just allocated.
!
CH$FILL( 0, .size, .area_loc );


! Return the location of the memory.
!
RETURN .area_loc;

END;					! End of routine get_zero_vm

%SBTTL 'PARSE_EXCL_SPEC'
ROUTINE parse_excl_spec( src_desc    : REF $BBLOCK, 
    			 esl_desc    : REF $BBLOCK,
    			 rln_desc    : REF $BBLOCK,
    			 qual_desc   : REF $BBLOCK ) : NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine parses and checks a value specified for the /EXCLUDE 
!	qualifier.
!
! FORMAL PARAMETERS:
!
!	src_desc	:  pointer to the string return by the CLI (PL/I
!			   varying).
!	rln_desc	:  descriptor for related file name string
!	qual_desc	:  descriptor for /EXCLUDE qualifier; used for
!			   signalling an error.
!
! IMPLICIT INPUTS:
!
!	None
!
! OUTPUTS PARAMETERS:
!
!	esl_desc	: descrptor for the expanded string returned by the
!			  $PARSE operation.
!
! IMPLICIT OUTPUTS:
!
!	None
!
! ROUTINE VALUE:
!
!	None
!
! COMPLETION CODES:
!
!	None
!
! SIDE EFFECTS:
!
!	Virtual memory is allocated to hold the expanded name string.
!
!--

BEGIN

LOCAL
    rtn_status,				! Return status from external calls
    fab :				! Local FAB, for parsing file name
    	$FAB_DECL,
    nam :				! Local NAM block, for parsing
    	$NAM_DECL,
    rel_nam :				! Local related NAM block, for parsing
    	$NAM_DECL,
    esa :				! Area to hold expanded name string
    	VECTOR[ NAM$C_MAXRSS, BYTE ],
    desc:				! Descriptor used when signaling errors
	$BBLOCK[ DSC$K_S_BLN ] INITIAL (REP DSC$K_S_BLN OF BYTE (0))
    ;





! Initialize the RMS control blocks for the $PARSE operation.
!
$FAB_INIT(
    	  FAB = fab,
    	  FNA = .src_desc[ DSC$A_POINTER ],
    	  FNS = .src_desc[ DSC$W_LENGTH ],
    	  DNM = '[000000...]*.*;*',
    	  NAM = nam
    	 );

$NAM_INIT(
    	  NAM = nam,
    	  ESA = esa,
    	  ESS = NAM$C_MAXRSS
    	 );

IF .rln_desc NEQ 0
THEN
    BEGIN
    nam[ NAM$L_RLF ] = rel_nam;
    $NAM_INIT(
    	      NAM = rel_nam,
    	      RSA = .rln_desc[ DSC$A_POINTER ],
    	      RSS = .rln_desc[ DSC$W_LENGTH ]
    	     );
    END;



! Parse the file name using $PARSE.
!
IF NOT (rtn_status = $PARSE( FAB = fab ))
THEN
    BEGIN
    !
    ! The $PARSE operation was not successful.  Use the most complete name
    ! possible in signaling the error.
    !
    IF .nam[ NAM$B_RSL ] NEQ 0
    THEN
	BEGIN
	!
	! There is a resultant name string, use it.
	!
	desc[ DSC$A_POINTER ] = .nam[ NAM$L_RSA ];
	desc[ DSC$W_LENGTH ]  = .nam[ NAM$B_RSL ];
	END
    ELSE	
	BEGIN
	IF .nam[ NAM$B_ESL ] NEQ 0
	THEN
	    BEGIN
	    !
	    ! There is an expanded name string, use it.
	    !
	    desc[ DSC$A_POINTER ] = .nam[ NAM$L_ESA ];
	    desc[ DSC$W_LENGTH ]  = .nam[ NAM$B_ESL ];
	    END
	ELSE	
	    BEGIN
	    !
	    ! Use the qualifier value given on the command line.
	    !
	    desc[ DSC$A_POINTER ] = .src_desc[ DSC$A_POINTER ];
	    desc[ DSC$W_LENGTH ]  = .src_desc[ DSC$W_LENGTH ];
	    END;				! inner else stmt
	END;					! outer else stmt
    SIGNAL(CLI$_INVQUAVAL, 2, desc, .qual_desc, .rtn_status );
    END;

! Check to make sure an acceptable name was returned.  No null strings, node 
! names, quoted strings or device names.
!
IF .nam[ NAM$B_ESL ] EQL 0
    	OR
   ( .nam[ NAM$L_FNB ] AND 
    	( NAM$M_EXP_DEV  OR  NAM$M_NODE  OR  NAM$M_QUOTED )) NEQ 0
THEN
    SIGNAL(CLI$_INVQUAVAL, 2, .src_desc, .qual_desc );


! Initalize the descriptor for the expanded name string.
!
esl_desc[ DSC$W_LENGTH ] = .nam[ NAM$B_ESL ];
esl_desc[ DSC$B_DTYPE ]  = DSC$K_DTYPE_T;
esl_desc[ DSC$B_CLASS ]  = DSC$K_CLASS_S;


! Allocate virtual memory to hold the expanded name string. Have the descriptor
! point to this new memory.
!
esl_desc[ DSC$A_POINTER ] = get_vm( .nam[ NAM$B_ESL ] );


! Copy the expanded name string into the allocated memory.
!
CH$MOVE(
    	.nam[ NAM$B_ESL ],
    	esa,
    	.esl_desc[ DSC$A_POINTER ]
       );

END;					! End of routine parse_excl_spec

%SBTTL 'SET_UIC_VALUE'
ROUTINE set_uic_value =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine places the group and member numbers, given on the 
!	line, in the qualifier data-base.
!
! FORMAL PARAMETERS:
!
!	None
!
! IMPLICIT INPUTS:
!
!	AP, most notable the offset TPA$L_PARAM, which contains the address
!	of the qualifier data-base.
!
! IMPLICIT OUTPUTS:
!
!	None
!
! ROUTINE VALUE:
!
!	True, unless something is screwed up.
!
! COMPLETION CODES:
!
!	None
!
! SIDE EFFECTS:
!
!	The UIC fields in the qualifier database are changed.
!
!--

BEGIN

BUILTIN 
    AP
    ;

LOCAL
    qualifier : REF $BBLOCK,
    number
    ;

MAP
    AP : REF $BBLOCK
    ;



qualifier = .AP[ TPA$L_PARAM ];
number    = .AP[ TPA$L_NUMBER ];

qualifier[uic_value] = .number;
if .qualifier[uic_group] eql uic$k_wild_group then qualifier[uic_wldgrp] = true;
if .qualifier[uic_member] eql uic$k_wild_member then qualifier[uic_wldmem] = true;
    	
RETURN true;

END;					! End of routine set_uic_value

%SBTTL 'CLEAN_UP'
ROUTINE clean_up( qualifier  : REF $BBLOCK, 
    		  rtn_status, 
    		  fab        : REF $BBLOCK, 
    		  xab_holder ) =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	clean_up puts the user's FAB back in order -- returns the user's
!	XAB chain to the FAB, if the file was not open when LIB$QUAL_FILE_MATCH
!	was called and then closes the file.  If the status was anything
!	unexpected the condition is signalled.
!
! FORMAL PARAMETERS:
!
!	fab		:  User's FAB
!	rtn_status	:  Status to exit procedure with
!	xab_holder	:  Pointer to user's xab chain
!
! IMPLICIT INPUTS:
!
!	None
!
! IMPLICIT OUTPUTS:
!
!	None
!
! ROUTINE VALUE:
!
!	rtn_status
!
! COMPLETION CODES:
!
!	rtn_status
!
! SIDE EFFECTS:
!
!	None
!
!--

BEGIN

IF NOT .qualifier[ file_open ] 
THEN
    BEGIN

    ! If the file is currently open and was not open before, close it and
    ! return the original XAB chain.
    !
    IF .fab[ FAB$W_IFI ] NEQ 0
    THEN $CLOSE( FAB = .fab );

    fab[ FAB$L_XAB ] = .xab_holder;
    END;

IF NOT ( .rtn_status OR 
    	 .rtn_status EQL LIB$_FILFAIMAT OR 
    	 .rtn_status EQL LIB$_QUIPRO )
THEN SIGNAL( .rtn_status );

RETURN .rtn_status;

END;					! End of routine clean_up

%SBTTL 'LEGAL_ANSWER'
ROUTINE legal_answer( desc : REF $BBLOCK ) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
! 	legal_answer checks the user's response to the /CONFIRM prompt to
!	make sure it was a legal response.
!
! FORMAL PARAMETERS:
!
!	desc	:  Address of descriptor for the user's answer
!
! IMPLICIT INPUTS:
!
!	None
!
! IMPLICIT OUTPUTS:
!
!	None
!
! ROUTINE VALUE:
!
!	SS$_NORMAL	:  positive answer
!	LIB$_NEGANS	:  negative answer
!	LIB$_QUIPRO	:  quit processing
!	LIB$_QUICONACT  :  continue processing, but cease prompting
!
! COMPLETION CODES:
!
!	None
!
! SIDE EFFECTS:
!
!	The response string will be up cased.
!
!--

BEGIN

MACRO

    ! This macro creates an entry in the answer table.
    !
    table_entry[ ans_str, rtn_val ] = 
	    WORD (%CHARCOUNT( ans_str)),  ! max length of valid response
	    UPLIT BYTE ( ans_str ),	! pointer to answer string
	    rtn_val %,			! return value, if a match occurs

    ans_len = 0, 0, 16, 0 %,		! length field
    ans_str = 2, 0, 32, 0 %,		! string address field
    ans_rtn = 6, 0, 32, 0 %		! return value field
    ;


LITERAL
    entry_len  = 10			! length table entry in bytes 
    ;
    
BIND
    ans_table = PLIT( table_entry(
    		 'TRUE',  SS$_NORMAL,
    		 'YES',   SS$_NORMAL,
    		 '1',     SS$_NORMAL,
    		 'FALSE', LIB$_NEGANS,
    		 'NO',    LIB$_NEGANS,
    		 '0',     LIB$_NEGANS,
    		 'ALL',   LIB$_QUICONACT,
    		 'QUIT',  LIB$_QUIPRO )) : bblockvector[,entry_len]
    ;


LOCAL
    str_len,  				! Length of user's response string
    entry_count				! number of entries in the table
    ;




! <CR> defaults to a NO of FALSE; that is, the user does not want this
! file operated on.
!
IF .desc[ DSC$W_LENGTH ] EQL 0
THEN RETURN LIB$_NEGANS;


! Up case the string.
!
STR$UPCASE( .desc, .desc );
str_len = .desc[ DSC$W_LENGTH ];


! See what the user's response was, and return the appropriate value.  First,
! determine the number of entries in the table and then compare the user's 
! response to the the table entries.
!
entry_count = (.(ans_table - 4) * 4) / entry_len;
INCR i FROM 0 TO .entry_count - 1
DO
    IF( CH$EQL( .str_len, .desc[ DSC$A_POINTER ], 
        MINU( .str_len, .ans_table[ .i, ans_len ]), .ans_table[ .i, ans_str ]))
    THEN  RETURN .ans_table[ .i, ans_rtn ];

    
! The answer given was not legal.
!
RETURN false;

END;					! End of routine legal_answer

%SBTTL 'FIND_RMS_BLOCK'
ROUTINE find_rms_blocks( qualifier     : REF $BBLOCK,
    			 fab           : REF $BBLOCK, 
    			 xabdat,
    			 xabpro,
    			 lcl_xabdat    : REF $BBLOCK,  
    			 lcl_xabpro    : REF $BBLOCK,
    			 xab_holder )  : NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	FIND_RMS_BLOCKS locates the RMS control blocks attached to the 
!	user's FAB.  If the file isn't open, local XAB's are used.
!
! FORMAL PARAMETERS:
!
!	QUALIFIER   :  Pointer to the qualiier data base
!	FAB    	    :  The user's fab
!	LCL_XABDAT  :  Address of local date XAB, used if file is closed
!	LCL_XABPRO  :  Address of local protection XAB, used if file is closed
!	XAB_HOLDER  :  Pointer to the user's XAB chain
!
! FORMAL OUTPUTS
!
!	XABDAT	    :  Pointer to the date XAB  
!	XABPRO	    :  Pointer to the protection XAB  
!
! IMPLICIT INPUTS:
!
!	None
!
! IMPLICIT OUTPUTS:
!
!	None
!
! ROUTINE VALUE:
!
!	None
!
! COMPLETION CODES:
!
!	Any RMS code or LIB$INVXAB (Invalid XAB chain)
!
! SIDE EFFECTS:
!
!	File will be opened, if it is not already open.
!
!--

BEGIN

LOCAL
    rtn_status,				! Status returned from externla calls
    current_xab	:			! XAB being evaluated
    	REF $BBLOCK,
    xabdat_fnd,				! Boolean, date XAB was located
    xabpro_fnd				! Boolean, protection XAB was located
    ;



! Is the file already open?
!
IF NOT .qualifier[ file_open ]
THEN
    BEGIN

    ! Have the FAB point to the local XAB's and save their addresses.
    !
    fab[ FAB$L_XAB ]          = .lcl_xabdat;
    .xabdat		      = .lcl_xabdat;
    lcl_xabdat[ XAB$L_NXT ]   = .lcl_xabpro;
    .xabpro		      = .lcl_xabpro;


    ! Open the file and display the header information.
    !
    IF NOT (rtn_status = $OPEN( FAB = .fab ))
    THEN clean_up( .qualifier, .rtn_status, .fab, .xab_holder );

    END
ELSE
    BEGIN

    ! Assume neither XAB is needed.  Get the first XAB in the chain.
    !
    xabdat_fnd  = NOT (.qualifier[ before_present ] or .qualifier[ since_present ]);
    xabpro_fnd  = NOT .qualifier[ byowner_present ];
    current_xab = .fab[ FAB$L_XAB ];


    ! For each XAB in the chain, check to see if it is a protection or date XAB.
    !
    WHILE NOT( .xabdat_fnd and .xabpro_fnd )
    DO
    	BEGIN

	! If we have encountered the end of the XAB chain, then a necessary XAB
	! was not found.  Signal the condition.
	!
	IF .current_xab EQL 0
	THEN clean_up( .qualifier, LIB$_INVXAB, .fab, .xab_holder );

	IF .current_xab[ XAB$B_COD ] EQL XAB$C_DAT
	THEN
	    BEGIN

	    ! The date XAB has been found.  Save it's address and note that it
	    ! was found.
	    !
	    .xabdat    = .current_xab;
	    xabdat_fnd = true;
	    END;

	IF .current_xab[ XAB$B_COD ] EQL XAB$C_PRO
	THEN
	    BEGIN

	    ! The protection XAB has been found.  Save it's address and note 
	    ! that it was found.
	    !
	    .xabpro    = .current_xab;
	    xabpro_fnd = true;
	    END;

	! Get the address of the next XAB in the chain.
	!
	current_xab = .current_xab[ XAB$L_NXT ];

	END;				! while loop
    END;				! wlse statement    
END;					! End of routine find_rms_blocks

%SBTTL 'LIB$QUAL_FILE_PARSE'
GLOBAL ROUTINE lib$qual_file_parse ( flags : REF $BBLOCK, context ) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine parses a selected set of command qualifiers for the
!	calling utility.  A database, which describes the results of the
!	parse, is set up for LIB$QUAL_FILE_MATCH to use in determining if a
!	file matches the necessary criteria.
!
! FORMAL PARAMETERS:
!
!	flags		the address of a longword of flag-bits.  Each bit is
!			associated with a specific qualifier.  If the bit
!			is set, then the qualifier should be parsed.
!
! OUTPUT PARAMETERS
!
!	context		the address of a longword to hold the location the 
!			qualifier data base;  the contents of this longword
!			is passed, by the caller, to LIB$QUAL_FILE_MATCH.
!
! IMPLICIT INPUTS:
!
!	None
!
! IMPLICIT OUTPUTS:
!
!	None
!
! ROUTINE VALUE:
!
!	SS$_NORMAL	the routine completed successfully.
!
!	LIB$_INVARG	invalid argument; a bit in the flags parameter was set
!			and there was no qualifier associated with it.
!
! COMPLETION CODES:
!
!	CLI$_INVQUAVAL	an unusable value was given on the command line for
!			any of the following qualifiers: /EXCLUDE, /BEFORE, 
!			/SINCE, /BY_OWNER.  (i.e. /BEFORE=mintchip or /EXCLUDE=A#A.B)
!
!	CLI$_CONFQUAL   more than one of the following appeared on the command
!			line at the same time: /CREATED, /MODIFIED, /EXPIRED,
!			/BACKUP.
!
!	Any completion status from LIB$GET_VM.
!	
! SIDE EFFECTS:
!
!	Virtual memory may be allocated to hold the /EXCLUDE list.
!
!--

BEGIN

MACRO
    
    ! Generate string descriptors
    !
    qdesc[n] = BIND %NAME('qdesc_', n) = $DESCRIPTOR( n ) %
    ;


LITERAL
    max_string	 =  1024		! maximum length of a command line
    ;


! Declare the string descriptors which contain the qualifier names.
!
qdesc(
       'CONFIRM',		! /CONFIRM
       'EXCLUDE',		! /EXCLUDE
       'BEFORE',		! /BEFORE
       'SINCE',			! /SINCE
       'CREATED',		! /CREATED
       'MODIFIED',		! /MODIFIED
       'EXPIRED',		! /EXPIRED
       'BACKUP',		! /BACKUP
       'BY_OWNER'		! /BY_OWNER
     );


BUILTIN
    NULLPARAMETER
    ;


LOCAL
    status,			! return status from external routines
    qualifier :			! qualifier database
    	REF $BBLOCK,
    buffer :			! buffer for string values
    	$BBLOCK[ max_string ],
    cli_desc :			! descriptor for values returned by CLI
    	$BBLOCK[ dsc$c_vs_bln ],
    excl_desc_blk :		! descriptor for file spec given by /EXCLUDE
    	REF $BBLOCK,
    last_excl_blk :		! pointer to last descriptor in list
    	REF $BBLOCK INITIAL( 0 ),
    previous_excl_desc :	! pointer to previous descriptor in list
    	INITIAL( 0 ),
    tpa_param :			! parameter block for LIB$TPARSE
    	$BBLOCK[ TPA$K_LENGTH0 ] 
    	INITIAL( REP TPA$K_LENGTH0 OF BYTE( 0 ))
    ;




  
! Are any bits set in the flags parameter which should not be?
!
IF .flags[ LIB$V_CQF_UNASSIGNED ] NEQU 0
THEN RETURN( LIB$_INVARG );

  
! The CONTEXT argument MUST be specified.
!
IF NULLPARAMETER( 2 )
THEN RETURN( LIB$_INVARG );


! Allocate virtual memory for the qualifier data base.  Pass the address
! back to the user.
!
qualifier = get_zero_vm( qual_blk_len );
.context  = .qualifier;

! Intialize the descriptor as a dynamic string descriptor which points to 
! nothing.
!
cli_desc[ DSC$W_MAXSTRLEN ] 	= 0;
cli_desc[ DSC$B_DTYPE ]		= DSC$K_DTYPE_T;
cli_desc[ DSC$B_CLASS ]		= DSC$K_CLASS_D;
cli_desc[ DSC$A_POINTER ]	= 0;

! Process the /CONFIRM qualifier, if it has been selected. Set a flag, if it is
! on the command line.
!
IF .flags[ LIB$V_CQF_CONFIRM ]
THEN
    qualifier[ confirm_present ] = CLI$PRESENT( qdesc_confirm );


! Process the /EXCLUDE qualifier, if it has been selected. 
!
IF .flags[ LIB$V_CQF_EXCLUDE ]
THEN

    ! For each file specification in the list:
    !
    WHILE CLI$GET_VALUE( qdesc_exclude, cli_desc ) DO
    BEGIN

	! Set a flag, if it is on the command line.
	!
	qualifier[ exclude_present ] = true;


	! Allocate some virtual memory to hold the descriptor for the file
	! specification.  Place it at the end of the exclude list.
	!	
	excl_desc_blk = get_zero_vm( excl_blk_len );

	IF .last_excl_blk EQL 0
	THEN
	    qualifier[ exclude_list ] = .excl_desc_blk
	ELSE
	    BEGIN
	    last_excl_blk[ next_excl_blk ] = .excl_desc_blk;
	    previous_excl_desc = last_excl_blk[ excl_spec_desc ];
	    END;

	last_excl_blk = .excl_desc_blk;


	! Parse the file specifiction and fill in the descriptor.
	!
	parse_excl_spec( cli_desc, 
			 excl_desc_blk[ excl_spec_desc ],
			 .previous_excl_desc,
			 qdesc_exclude );

    END;				! while loop to get exclude file specs


! Process the /BEFORE qualifier, if it has been selected. 
!
IF .flags[ LIB$V_CQF_BEFORE ]
THEN

    ! Set a flag, if it appears on the command line; and retreive the value
    !
    IF (qualifier[ before_present ] = CLI$GET_VALUE( qdesc_before, cli_desc ))
    THEN
    	BEGIN

    	! Convert the time into 64-bit format.  Signal, if this didn't work.
    	!
	IF NOT LIB$CVT_TIME( cli_desc, qualifier[ before_value ] )
	THEN
	    SIGNAL( CLI$_INVQUAVAL, 2, cli_desc, qdesc_before );

    	! The file header needs to be read; therefore the file must be 
    	! opened to evaluate the selection criteria.
    	!
	qualifier[ display_hdr ] = true;
    	END;


! Process the /SINCE qualifier, if it has been selected. 
!
IF .flags[ LIB$V_CQF_SINCE ]
THEN

    ! Set a flag, if it appears on the command line; and retreive the value
    !
    IF (qualifier[ since_present ] = CLI$GET_VALUE( qdesc_since, cli_desc ))
    THEN
    	BEGIN

    	! Convert the time into 64-bit format.  Signal, if this didn't work.
    	!
	IF NOT LIB$CVT_TIME( cli_desc, qualifier[ since_value ] )
	THEN
	    SIGNAL( CLI$_INVQUAVAL, 2, cli_desc, qdesc_since );

	qualifier[ display_hdr ] = true;
    	END;


! Process the /CREATED qualifier, if it has been selected. Set a flag, if it is
! on the command line.
!
IF .flags[ LIB$V_CQF_CREATED ]
THEN
    BEGIN
    qualifier[ created_present ] = CLI$PRESENT( qdesc_created );

    qualifier[ display_hdr ] = .qualifier[ created_present ] OR .qualifier[ display_hdr ];
    END;


! Process the /MODIFIED qualifier, if it has been selected. Set a flag, if it
! is on the command line.
!
IF .flags[ LIB$V_CQF_MODIFIED ]
THEN
    BEGIN
    qualifier[ modified_present ] = CLI$PRESENT( qdesc_modified );

    qualifier[ display_hdr ] = .qualifier[ modified_present ] OR .qualifier[ display_hdr ];
    END;


! Process the /EXPIRED qualifier, if it has been selected. Set a flag, if it is
! on the command line.
!
IF .flags[ LIB$V_CQF_EXPIRED ]
THEN
    BEGIN
    qualifier[ expired_present ] = CLI$PRESENT( qdesc_expired );

    qualifier[ display_hdr ] = .qualifier[ expired_present ] OR .qualifier[ display_hdr ];
    END;


! Process the /BACKUP qualifier, if it has been selected. Set a flag, if it is
! on the command line.
!
IF .flags[ LIB$V_CQF_BACKUP ]
THEN
    BEGIN
    qualifier[ backup_present ] = CLI$PRESENT( qdesc_backup );

    qualifier[ display_hdr ] = .qualifier[ backup_present ] OR .qualifier[ display_hdr ];
    END;


! Make sure that only one of /CREATED, /MODIFIED, /EXPIRED and /BACKUP was
! given on the command line.  If none were specified default to /CREATED.
! Check to be sure that /BEFORE or /SINCE was specified if one of the date
! qualifiers was given.
!
CASE
    .qualifier[ created_present ]  +
    .qualifier[ modified_present ] +
    .qualifier[ expired_present ]  +
    .qualifier[ backup_present ]   
FROM 0 TO 1 OF SET

    [ 0 ] 	 : qualifier[ created_present ] = true;
    [ 1 ]        : IF NOT (.qualifier[ since_present] OR .qualifier[ before_present])
    		   THEN SIGNAL( CLI$_QUALMISS, 1, $DESCRIPTOR('/BEFORE or /SINCE') );
    [ OUTRANGE ] : SIGNAL( CLI$_CONFQUAL );
TES;

! Process the /BY_OWNER qualifier, if it has been selected. 
!
IF .flags[ LIB$V_CQF_BYOWNER ]
THEN

    ! Set a flag, if it is  on the command line. Get the UIC or default it.
    !
    IF (qualifier[ byowner_present ] = CLI$PRESENT( qdesc_by_owner ))
    THEN
	BEGIN

	IF NOT CLI$GET_VALUE( qdesc_by_owner, cli_desc )
	THEN
	    BEGIN

	    ! Declare and initialize the item list needed for $GETJPI.
	    !
	    LOCAL 
	    	item_list : VECTOR[ 4 ] 
	    		    INITIAL( WORD( 4, JPI$_UIC ), 0, 0, 0);
	    		    item_list[ 1 ] = qualifier[ uic_value ];

	    ! No UIC was given; use the current process's UIC.  Since the GETJPI
	    ! is being done for the current process it will be synchronous.  If
	    ! $GETJPI becomes asynchronous for the current process, a $WAITFR 
	    ! must be placed after the $GETJPI call.
	    !
	    IF NOT( status = $GETJPI( ITMLST = item_list ))
	    THEN
	        SIGNAL( .status );

	    qualifier[ uic_wldmem ] = false;
	    qualifier[ uic_wldgrp ] = false;
	    END

	ELSE
	    BEGIN

	    ! A value was given on the command line.  Prepare to parse it.
    	    ! Initialize the TPARSE parameter block.  The PARAM field of the 
    	    ! will contain the address of the qualifier data base, so that
    	    ! the action routine may access the structure.
    	    !
	    tpa_param[ TPA$L_COUNT ]     = TPA$K_COUNT0;
	    tpa_param[ TPA$L_STRINGCNT ] = .cli_desc[ DSC$W_LENGTH ];
	    tpa_param[ TPA$L_STRINGPTR ] = .cli_desc[ DSC$A_POINTER ];
	    tpa_param[ TPA$L_PARAM ]     = .qualifier;

	    ! Parse the UIC and check the validaty of the results.
	    !
	    status = LIB$TPARSE( tpa_param, cq_uic_states, cq_uic_keys );
	    IF NOT .status
	    THEN
		IF .status NEQ SS$_NOSUCHID
	    	THEN
		    SIGNAL( CLI$_INVQUAVAL, 2, cli_desc, qdesc_by_owner )
	    	ELSE
		    SIGNAL( CLI$_NOSUCHID );
	    END;

	qualifier[ display_hdr ] = .qualifier[ byowner_present ] OR .qualifier[ display_hdr ];
	END;


RETURN SS$_NORMAL;

END;					! End of routine lib$qual_file_parse

%SBTTL 'LIB$CONFIRM_ACT'
GLOBAL ROUTINE lib$confirm_act( prompt_string, prompt_args, prompt_rtn ) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	lib$confirm_act prompts the user with a given string and evaluates
!	answer.  A value is returned indicating positivte and negative 
!	responses.  The user may also request to quit processing or continue
!	processing and cease prompting.
!
! FORMAL PARAMETERS:
!
!	prompt_string:	address of a descriptor for an $FAOL control string to 
!			be used as a /CONFIRM prompt.
!
!	prompt_args  :  address of argument list for $FAOL call.  This parameter
!			is optional.
!
!
!	prompt_rtn   :  address of user's prompt routine, in case 
!			LIB$GET_COMMAND is inappropriate.  This parameter is
!			optional.  The routine is called with the address of the
!			descriptor for the expanded prompt string and the 
!			address of the answer descriptor.
!
! IMPLICIT INPUTS:
!
!	None
!
! IMPLICIT OUTPUTS:
!
!	None
!
! ROUTINE VALUE:
!
!	SS$_NORMAL	:  positive answer
!	LIB$_NEGANS	:  negative answer
!	LIB$_QUIPRO	:  quit processing
!	LIB$_QUICONACT  :  continue processing, but cease prompting
!
! COMPLETION CODES:
!
!	Any $FAOL return or value returned from the caller's prompt 
!	routine.
!
! SIDE EFFECTS:
!
!	None
!
!--

BEGIN

BUILTIN
    NULLPARAMETER
    ;

LITERAL
    prompt_max_str = 256,		! Maximum length of the /CONF prompt
    answer_max_str = 8			! Maximum length of the answer
    ;

LOCAL
    rtn_status,				! Status returned from external calls
    prompt_buffer :			! Buffer for /CONFIRM prompt
    	VECTOR [ prompt_max_str, BYTE ],
    prompt_desc :			! Descriptor for the prompt string
    	$BBLOCK[ DSC$K_S_BLN ],
    answer_buffer :			! Buffer for user's answer to /CONFIRM prompt
    	VECTOR [ answer_max_str, BYTE ],
    answer_desc :			! Descriptor for the answer string
    	$BBLOCK[ DSC$K_S_BLN ]
    ;



! Initialize descriptors for the prompt and the answer.
!
prompt_desc[ DSC$W_LENGTH  ] = prompt_max_str;
prompt_desc[ DSC$B_DTYPE   ] = DSC$K_DTYPE_T;
prompt_desc[ DSC$B_CLASS   ] = DSC$K_CLASS_S;
prompt_desc[ DSC$A_POINTER ] = prompt_buffer;

answer_desc[ DSC$B_DTYPE   ] = DSC$K_DTYPE_T;
answer_desc[ DSC$B_CLASS   ] = DSC$K_CLASS_S;
answer_desc[ DSC$A_POINTER ] = answer_buffer;


! Use $FAOL to insert the prompt arguments into the the prompt string.
!
IF NOT( RTN_STATUS = $FAOL( CTRSTR = .prompt_string,
			    OUTLEN = prompt_desc[ DSC$W_LENGTH ],
			    OUTBUF = prompt_desc,
			    PRMLST = (IF NULLPARAMETER( 2 )
    				     	  THEN 0 ELSE .prompt_args )))
THEN 
    SIGNAL( .rtn_status );


! Prompt the user for consent to do whatever to the current file.  If the caller
! wishes, do not use LIB$GET_COMMAND.  Do not accept anything except legal 
! answers!
!
DO
    BEGIN
    answer_desc[ DSC$W_LENGTH ] = answer_max_str;
    IF( NULLPARAMETER( 3 ))
    THEN
	rtn_status = LIB$GET_COMMAND( answer_desc, 
				      prompt_desc, 
				      answer_desc[ DSC$W_LENGTH ] )
    ELSE
    	IF NOT( rtn_status = (.prompt_rtn)( prompt_desc, answer_desc ))
    	THEN RETURN .rtn_status;

    ! Does the user wish to quit processing (^Z for an answer)?
    !
    IF .rtn_status EQL RMS$_EOF
    THEN RETURN LIB$_QUIPRO;

    END
UNTIL ((rtn_status = legal_answer( answer_desc )) NEQ 0);

RETURN .rtn_status;

END;					! End of routine lib$confirm_act

%SBTTL 'LIB$QUAL_FILE_MATCH'
GLOBAL ROUTINE lib$qual_file_match ( context,
    				     user_fab  : REF $BBLOCK, 
    				     file_name : REF $BBLOCK,
    				     prompt_string, 
    				     prompt_args,
    				     prompt_rtn ) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	lib$qual_file_match determines if a given file matches the selection
!	criteria given in the command line.
!
! FORMAL PARAMETERS:
!
!	context	     :  address of longword containing pointer to the qualifier
!			data base.
!
!	user_fab     :  address of FAB for file to be evaluated.  This FAB must
!			point to a valid NAM block. If the user already has the
!			the file open and the file header criteria are to be 
!			evaluated, the appropriate XAB's must be chained to the
!			FAB.  If the file is not open when this routine is 
!			called, then the XAB chain is not necessary, but may be
!			present.  This argument is optional; if it is not given
!			the file_name parameter MUST be present.  Both arguments
!			may not be present att he same time.
!
!	file_name    :  address of a descriptor for the file name of the file
!			to be processed.  This parameter may be used instead of
!			the user_fab argument.  It is optional.
!			NOTE: LIB$QUAL_FILE_MATCH does not do either a $PARSE
!			or a $SEARCH with the given file name.
!
!	prompt_string:	address of a descriptor for an $FAOL control string to 
!			be used as a /CONFIRM prompt.  This parameter is 
!			optional, if /CONFIRM is not being processed.
!
!	prompt_args  :  address of argument list for $FAOL call.  This 
!			parameter is optional.
!
!	prompt_rtn   :  address of user's prompt routine, in case 
!			LIB$GET_COMMAND is inappropriate.  This parameter is
!			optional.  The routine is called with the address of the
!			descriptor for the expanded prompt string and the 
!			address of the answer descriptor.
!
! IMPLICIT INPUTS:
!
!	None
!
! IMPLICIT OUTPUTS:
!
!	None
!
! ROUTINE VALUE:
!
!	SS$_NORMAL   :	the file matches the criteria and may be processed.
!
!	LIB$_FILFAIMAT:	the file failed the evaluation and should not be 
!			processed.
!
!	LIB$QUIPRO   :  quit processing; the user requested the processing 
!			cease.
!
!	LIB$_INVARG  :  caller passed both the user_fab and file_name 
!			arguments or neither of them or the context parameter
!			was not given.
!
!	LIB$_INVXAB  :  invalid XAB chain; a neccessary XAB (XABPRO or XABDAT)
!			was missing from the opened file's XAB chain.
!
!	Any completion code from $OPEN, $FAOL or the user's prompt routine.
!
! COMPLETION CODES:
!
!	None
!
! SIDE EFFECTS:
!
!	None
!
!--

BEGIN

BUILTIN
    NULLPARAMETER,
    FP
    ;

LOCAL
    rtn_status,				! Status returned from external calls
    qualifier 	:			! address of qualifier data base
    	REF $BBLOCK,
    rsa_buffer	:			! Resultant name buffer
    	VECTOR[ NAM$C_MAXRSS, BYTE ],
    esa_buffer	:			! Expanded name buffer
    	VECTOR[ NAM$C_MAXRSS, BYTE ],
    lcl_xabdat  :			! Local date XAB
    	$XABDAT(),
    lcl_xabpro  :			! Local protection XAB
    	$XABPRO(),
    lcl_nam	:			! Local name block
    	$NAM(),
    lcl_fab	:			! Local FAB
    	$FAB(),
    fab		:
    	REF $BBLOCK,
    nam		:			! NAM block
    	REF $BBLOCK,
    xabpro	:			! Protection XAB
    	REF $BBLOCK,
    xabdat	:			! Date XAB
    	REF $BBLOCK,
    xab_holder,				! temporary pointer to user's XAB
    					! chain (used if file is closed)
    file_date	:			! Pointer to file selection date
    	REF VECTOR,
    qual_date	:			! Pointer to command selection date
    	REF VECTOR,
    result_desc :			! Descriptor for resultant file name
    	VECTOR [ 2 ],
    excl_blk	:			! Pointer to the current exclude block
    	REF $BBLOCK
    ;


! Establish the condition handler.
!
.FP = LIB$SIG_TO_RET;

! Retrieve the address of the qualifier data base. If the caller didn't give it
! to us, then give up.
!
IF NULLPARAMETER( 1 )
THEN 
    RETURN( LIB$_INVARG )
ELSE
    qualifier = ..context;


! If user previously responded that processing be terminated (^Z or QUIT) to
! a /CONFIRM prompt, then return LIB$QUIPRO status.
!
IF .qualifier[ quit_processing ]
THEN
    RETURN( LIB$_QUIPRO );


! Check the mutually exclusive parameters.
!
IF NOT NULLPARAMETER( 2 )
THEN
    BEGIN

    IF NOT NULLPARAMETER( 3 )
    THEN 
    	RETURN( LIB$_INVARG );

    ! Is the file open?
    !
    IF .user_fab[ FAB$W_IFI ] NEQ 0
    THEN
    	qualifier[ file_open ] = true
    ELSE
    	BEGIN
    	qualifier[ file_open ] = false;
    	xab_holder = .user_fab[ FAB$L_XAB ];
    	END;

    ! Remember that it is the caller's FAB, not our own.
    !
    qualifier[ callers_fab ] = true;
    fab = .user_fab;
    END
ELSE
    IF NOT NULLPARAMETER( 3 )
    THEN
    	BEGIN

    	! Initialize local RMS control blocks.
	!
	$NAM_INIT( NAM = lcl_nam,
    		RSA = rsa_buffer,
		RSS = NAM$C_MAXRSS,
		ESA = esa_buffer,
		ESS = NAM$C_MAXRSS );

	$FAB_INIT( FAB = lcl_fab,
		FNS = .file_name[ DSC$W_LENGTH ],
		FNA = .file_name[ DSC$A_POINTER ],
		NAM = lcl_nam );

	qualifier[ file_open ]   = false;
	qualifier[ callers_fab ] = false;
	fab = lcl_fab;

    	! Parse the file spec to be sure it's okay.
    	!
        IF NOT (rtn_status = $PARSE( FAB = .fab ))
        THEN 
    	    RETURN .rtn_status;

	END
    ELSE

	! Neither the file name or the FAB was given, and we need at least
	! one of them.
	!
	RETURN( LIB$_INVARG );




! Evalulate the file header criteria.
!
IF .qualifier[ display_hdr ]
THEN
    BEGIN

    ! Find the necessary RMS control blocks.
    !
    find_rms_blocks( .qualifier,
    		     .fab,
    		     xabdat,
    		     xabpro,
    		     lcl_xabdat,
    		     lcl_xabpro,
    		     .xab_holder );

    ! If /BEFORE or /SINCE were given on the command line, compare the 
    ! appropriate file dates to the ones the user requested.
    !
    IF .qualifier[ before_present] OR .qualifier[ since_present ]
    THEN

	! Point to the appropriate date in the file's XABDAT
	!
	SELECTONE true OF
	SET
	    [ .qualifier[ created_present ]]  : ! Creation date was requested
    						file_date = xabdat[ XAB$Q_CDT ];

	    [ .qualifier[ modified_present ]] : ! Revision date was requested
		    				file_date = xabdat[ XAB$Q_RDT ];

	    [ .qualifier[ expired_present ]]  : ! Expiration date was requested
		    				file_date = xabdat[ XAB$Q_EDT ];

	    [ .qualifier[ backup_present ]]   : ! Backup date was requested
		    				file_date = xabdat[ XAB$Q_BDT ];
	TES;


    ! /BEFORE was on the command line
    !
    IF .qualifier[ before_present ]
    THEN
    	BEGIN

	! Point to the date given on the command line.
	!
	qual_date = qualifier[ before_value ];

	! Compare the file's date to the one on the command line.
	!
	IF .file_date[ 1 ] GTRU .qual_date[ 1 ] OR
	   (.file_date[ 1 ] EQLU .qual_date[ 1 ] AND .file_date[ 0 ] GEQU .qual_date[ 0 ])
	THEN
	    RETURN clean_up( .qualifier, LIB$_FILFAIMAT, .fab, .xab_holder );

	END;


    ! /SINCE was on the command line
    !
    IF .qualifier[ since_present ]
    THEN
	BEGIN

	! Point to the date given on the command line.
	!
	qual_date = qualifier[ since_value ];

	! Compare the file's date to the one on the command line.
	!
	IF .file_date[ 1 ] LSSU .qual_date[ 1 ] OR
	   (.file_date[ 1 ] EQLU .qual_date[ 1 ] AND .file_date[ 0 ] LSSU .qual_date[ 0 ])
	THEN
	    RETURN clean_up( .qualifier, LIB$_FILFAIMAT, .fab, .xab_holder );
	    
    	END;


    ! /BY_OWNER was given on the command line.
    !
    IF .qualifier[ byowner_present ]
    THEN

    	! Compare the UIC of the file to the UIC given on the command line.
	!
	IF NOT (( .qualifier[ uic_wldgrp ] OR
		.xabpro[ XAB$W_GRP ] EQL .qualifier[ uic_group ])
			AND
		( .qualifier[ uic_wldmem ] OR
		.xabpro[ XAB$W_MBM ] EQL .qualifier[ uic_member ]))
	THEN
	    RETURN clean_up( .qualifier, LIB$_FILFAIMAT, .fab, .xab_holder );

    END;				! File header criteria evaluation


! Evaluate the file name criteria (/EXCLUDE).
!
IF .qualifier[ exclude_present ]
THEN
    BEGIN

    ! Get the current file's name.  Use the resultant file name, if it is 
    ! present (the file was previously opened).  Otherwise, use the expanded
    ! name string.
    !
    nam = .fab[ FAB$L_NAM ];
    IF .nam[ NAM$B_RSL ] NEQ 0
    THEN
    	BEGIN
        result_desc[ 0 ] = .nam[ NAM$B_RSL ];
        result_desc[ 1 ] = .nam[ NAM$L_RSA ];
    	END
    ELSE
    	BEGIN
        result_desc[ 0 ] = .nam[ NAM$B_ESL ];
        result_desc[ 1 ] = .nam[ NAM$L_ESA ];
    	END;


    ! Compare the file name to the file specifications in the exclude list.
    ! If a match is found, then LIB$_FILFAIMAT should be returned, indicating
    ! the file is to be excluded.
    !
    excl_blk = .qualifier[ exclude_list ];

    WHILE .excl_blk NEQ 0 
    DO
	BEGIN
	IF MATCH( result_desc, excl_blk[ excl_spec_desc ] )
	THEN
	    RETURN clean_up( .qualifier, LIB$_FILFAIMAT, .fab, .xab_holder );
	
	excl_blk = .excl_blk[ next_excl_blk ];
	END;

    END;				! File name criteria evaluation


! Evaluate the user selection criteria (/CONFIRM).
!
IF .qualifier[ confirm_present ]
THEN
    BEGIN

    ! The prompt string must be present if /CONFIRM is to work.
    !
    IF NULLPARAMETER( 4 )
    THEN RETURN clean_up( .qualifier, LIB$_INVARG, .fab, .xab_holder );

    ! Prompt for the user's opinion about the current file.  If necessary, 
    ! turn off further prompting.  Return the user's answer to the caller.
    !
    rtn_status = lib$confirm_act( .prompt_string, 
    				  (IF NULLPARAMETER( 5 ) 
    					THEN 0 ELSE .prompt_args ), 
    				  (IF NULLPARAMETER( 6 )
    					THEN 0 ELSE .prompt_rtn ));

    IF .rtn_status EQL LIB$_QUICONACT
    THEN
	BEGIN
	qualifier[ confirm_present ] = false;
	rtn_status = SS$_NORMAL;
	END;
    	

    IF .rtn_status EQL LIB$_NEGANS
    THEN 
    	rtn_status = LIB$_FILFAIMAT;


    IF .rtn_status EQL LIB$_QUIPRO
    THEN 
    	qualifier[ quit_processing ] = true;


    RETURN clean_up( .qualifier, .rtn_status, .fab, .xab_holder);
    END;				! Confirm criteria evaluation


RETURN clean_up( .qualifier, SS$_NORMAL, .fab, .xab_holder);

END;					! End of routine lib$qual_file_match

%SBTTL 'LIB$QUAL_FILE_END'
GLOBAL ROUTINE lib$qual_file_end( context ) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Clean up any virtual memory which was allocated while processing the
!	common file qualifiers.
!
! FORMAL PARAMETERS:
!
!	context		address of the pointer to the qualifier data base
!
! IMPLICIT INPUTS:
!
!	None
!
! IMPLICIT OUTPUTS:
!
!	None
!
! ROUTINE VALUE:
!
!	SS$_NORMAL	routine completed successfully
!	
!	Any status return from LIB$FREE_VM
!
! COMPLETION CODES:
!
!	None
!
! SIDE EFFECTS:
!
!	None
!
!--

BEGIN

LOCAL
    rtn_status,				! status returned by external calls
    qualifier : ref $BBLOCK,		! qualifier data base
    excl_blk  : ref $BBLOCK,		! pointer to the current exclude block
    next_blk  : ref $BBLOCK,		! pointer to the next exclude block
    desc_blk  : ref $BBLOCK		! pointer to the descriptor for the 
    ;					!   exclude file spec 


! Locate the qualifier data base and the first exclude block.
!
qualifier = ..context;
excl_blk  = .qualifier[ exclude_list ];


! Free the virtual memory for each exclude block and exclude file spec.
!
UNTIL .excl_blk EQL 0 DO
    BEGIN

    ! Locate the exclude file descriptor and the next exclude block in the
    ! list.
    !
    desc_blk = excl_blk[ excl_spec_desc ];
    next_blk = .excl_blk[ next_excl_blk ];

    ! Get rid of the virtual memory.
    !
    IF NOT ( rtn_status = LIB$FREE_VM( %REF(.desc_blk[ DSC$W_LENGTH ]), desc_blk[ DSC$A_POINTER ] ))
    THEN RETURN .rtn_status;

    IF NOT ( rtn_status = LIB$FREE_VM( %REF(excl_blk_len), excl_blk ))
    THEN RETURN .rtn_status;

    ! Point to the next exclude block.
    !
    excl_blk = .next_blk;
    END;

! Free up the memory which holds the qualifier data base and zero the context
! pointer.
!
IF NOT ( rtn_status = LIB$FREE_VM( %REF(qual_blk_len), qualifier ))
THEN RETURN .rtn_status;

.context = 0;

RETURN true;
END;					! End of routine lib$qual_file_end

END
ELUDOM
