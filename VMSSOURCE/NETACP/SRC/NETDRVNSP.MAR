
	.TITLE	NETDRVNSP - DECnet NSP module for NETDRIVER
	.IDENT	'V04-000'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
; FACILITY:	DECnet, Executive
;
; ABSTRACT:
;		This module implements that NSP layer of NETDRIVER.  NSP
;		is the protocol spoken over logical-links.  The NSP layer
;		is sandwiched between the Session and Routing layers; each
;		of which is implemented in a separate NETDRIVER module.
;
; ENVIRONMENT:	Standard driver environment
;--


	.SBTTL	MODIFICATION HISTORY
;
; AUTHOR:	Alan D. Eldridge,  CREATION DATE: 11-Mar-1982
;
; MODIFIED BY:
;
;	V03-033	ADE0043		A. Eldridge		10-Aug-1984
;		Don't update remote node address in XWB since that address is
;		used as part of the NETACP hashing to locate the node counter
;		block, etc.
;		
;	V03-032	ADE0042		A. Eldridge		21-Jul-1984
;		Fix race condition in receiver which was causing segments to
;		be copied out of order.
;
;	V03-031	ADE0041		A. Eldridge		28-Jun-1984
;		Move window and buffer control parameters to storage area so
;		that they can be more easily played with via PATCH for 
;		experimentation.
;
;		Don't allow ACK delay on data message exactly halfway into
;		the pipeline.  This allows overlap of the data and returning
;		ACK message streams.
;
;		Change max pipeline window to 40 (was 7).  Modify window
;		adjustment algorithms.
;
;		Fix bug in INTerrupt message FDT routine that called
;		CHK_INT_AVL with the wrong LSB pointer in R2.
;
;	V03-030	ADE0040		A. Eldridge		10-Sep-1983
;		Major rewrite to build data segments as needed (rather than 
;		just at FDT time) by using kernel mode AST's to nibble away at
;		the user buffer. 
;
;


	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;
	$AQBDEF
	$ACBDEF
	$CCBDEF
	$CRBDEF
	$CXBDEF
	$DDBDEF
	$DPTDEF
	$DRDEF
	$DYNDEF
	$IPLDEF
	$IRPDEF
	$IODEF
	$JIBDEF
	$MSGDEF
	$PCBDEF
	$PHDDEF
	$PRDEF
	$RSNDEF
	$SSDEF
	$TQEDEF
	$UCBDEF
	$VADEF
	$VECDEF

	$ICBDEF
	$IDBDEF
	$LLIDEF
	$LTBDEF
	$RCBDEF

	$NETSYMDEF
	$NETUPDDEF
	$NSPMSGDEF

	$CXBEXTDEF		; NETDRIVER CXB extensions
	$XWBDEF			; XWB and LSB definitions



;
; EQUATED SYMBOLS
;
P1	 = 0			; QIO P1 parameter offset from AP
P2	 = 4			; QIO P2 parameter offset from AP

NDC	 = XWB$Z_NDC		; Shortened symbol name for counter offset

IRP$L_SES_BUF	== IRP$L_SEGVBN
IRP$B_QUO 	== 4
IRP$B_CXBCNT	== 5

.iif ndf,IRP$Q_STATION,	IRP$Q_STATION = 8+IRP$L_IOST1
.iif ndf,IO$V_MULTIPLE, IO$V_MULTIPLE = 1+IO$V_INTERRUPT
.iif ndf,IO$M_MULTIPLE, IO$M_MULTIPLE = 1@IO$V_MULTIPLE

NSP$C_ADJ_XPW	= 32
NSP$C_MAX_XPW	= 40
NSP$C_MAX_RBF	=  7
NSP$C_R_CXBTHR  =  5

NSP$V_ACK_XCH	= 13
NSP$V_SEQ_NAR	= 14
NSP$M_SEQ_NAR	= 1@NSP$V_SEQ_NAR
NSP$V_DATA_NAR	= NSP$V_DATA_EOM + 1
NSP$M_DATA_NAR	= NSP$M_DATA_EOM * 2

NSP$C_INF_V40	= NSP$C_INF_V33
NSP$C_MSG_CR	= ^X<68>	; Retransmitted Connect Initiate
				;; put in library
;
; MACROS:
;

;
;  Bit definition macro
;
.MACRO	BITDEF	BLK,SYM,BITVAL

	'BLK'$V_'SYM' = BITVAL
	'BLK'$M_'SYM' = 1@<BITVAL>
.ENDM


	.SBTTL	NSP MESSAGE FORMAT

;++
;
;  <0eb0 0000><4b_LINK>{2b_ACK}<2b_SEG><DATA>			DATA MSG
;  <0011 0000><4b_LINK>{2b_ACK}<2b_SEG><u16_DATA>		INT. MSG
;  <0001 0000><4b_LINK>{2b_ACK}<2b_SEG><2b_FLOW>		L.S. MSG
;
;  <0000 0100><4b_LINK><2b_ACK>					DATA ACK
;  <0001 0100><4b_LINK><2b_ACK>					OTH. ACK
;  <0010 0100><2b_DST>						CA
;
;  <0001 1000><2k_0><2b_SRC><1b_SRV><1b_INFO><2b_SEGSIZ><CTL>	CI
;  <0101 1000><2k_0><2b_SRC><1b_SRV><1b_INFO><2b_SEGSIZ><CTL>	CR
;  <0010 1000><4b_LINK><1b_SRV><1b_INFO><2b_SEGSIZ><i16_DATA>	CC
;  <0011 1000><4b_LINK><2b_REA><i16_DATA>			DI
;  <0100 1000><4b_LINK><2b_REA>					DC
;  <0100 1000><2b_DST><2k_0><2k_1>				CT
;  <0100 1000><4b_LINK><2k_42>					DT
;  <0100 1000><4b_LINK><2k_41>					NLT
; 
;  <0101 1000>------						START
;
;  <4b_LINK   ::=  <2b_DST><2b_SRC>  		link address, not = 0
;  <2b_ACK    ::=  <1001><12 bit seg number>	if NAK
; 		   <1000><12 bit seg number>	if ACK
;  <2b_SEG>   ::=  <0000><12 bit seg number>
;  <2b_FLOW>  ::=  <00000><1 bit subchannel><2 bit mode><1 byte count>
;  			   0 => data	     00 => no change
;			   1 => interrupt    01 => stop
;					     10 => start
;
;  <1b_SRV>   ::=  <00000001>			if no flow control
;		   <00000101> 			if segment flow control
;		   <00001001>			if message flow control
;  <1b_INFO>  ::=  <00000001>			if NSP V3.1
;		   <00000000>			if NSP V3.2
;
;
;  <CTL>      ::=  <DNAME><SNAME><000000da><ACCOUNT><i16_DATA>
;					     if a      if d 
;		    <DNAME> ::= <NAME>
;		    <SNAME> ::= <NAME>
;		    <NAME>  ::= <1k_0><1b_objtyp>  objtyp not= 0
;				<1k_1><1k_0><i16_desc>
;				<1k_2><1k_0><2b_gcod><2b_ucod><i12_desc>
;		    <ACCT>  ::= <i39_id><i39_psw><i39_acc>
;
;
;--

	.SBTTL	FLOW CONTROL OVERVIEW

;
;  The DATA subchannel transmitter is either message, segment, or null
;  flowed controlled by the remote receiver.  For details consult the
;  NSP Functional Spec.  Briefly, the rules are as follows:
;
;  - Null Flow Control
;
;    There is no flow control.  Backpressure is the only way that the
;    receiver can force the transmitter to stop transmitting.
;
;  - Message Flow Control
;
;    The receive increments the flow control variable once for each
;    message which it may receive.   It may never decrement it.  This
;    value must never exceed 127.
;
;  - Segment Flow Control
;
;    The adds the flow control value to the current flow control 
;    variable, this may increment it (not past 127) or decrement it (not
;    below zero).
;
;
;  Managing DATA Transmission Control Variables
;
;  To control the xmitter, the following parameters are defined.  Each
;  is a signed 12 bit number referring to an NSP message sequence number.
;  Since NSP may not "pipeline" more than 2098 messages on any given
;  subchannel, sequence number A is less than sequence number B if 
;  B-A < 2098 (mod 4096).
;
;

	.SBTTL	LSB State Variable Description

;
;
;  LSB Transmitter segment number variables:
;
;	HAR	Highest ACK Received.  This value is increased upon receiving 
;		an ACK for a transmitted segment.  It is never decreased.
;
;	HXS	Highest Xmt-able Segment.  This value represents the highest
;		segment number which is both currently queued and allowed to
;		be sent according to the remote receivers flow control credits,
;		flow control type (message, segment, none), and the transmit-
;		packet window.  It is independent of the current backpressure
;		setting.  It may be increased whenever:
;
;		  - a new message segment is Queued from by the session layer.
;		  - positive flow control credits are received.
;		  - the transmit-packet-window is opened.
;
;		It may be decreased whenever:
;
;		  - negative flow control credits are received.
;		  - the transmit-packet-window is opened.
;		  - the session layer does a $CANCEL (not yet supported since
;		    this currently breaks the logical-link).
;		
;
;	LNX	Last Number Xmt'd.  This is the number of the last segment
;		sent to the Routing layer for transmission.  It is decreased
;		whenever messages need to be retransmitted due to a timeout
;		or a received NAK.  It is increased whenever a segment is 
;		sent to the Routing layer for transmission.
;
;	LUX	Last Used Xmt-number.  This is the number of the last segment
;		number assigned to a segment.  On the DATA channel, segment
;		numbers are assigned to the buffered data segements as they are
;		built at FDT (or ALTSTART) time.  On the LS/INTERRUPT channel
;		they are assigned as a message is sent for the first time. 
;		The latter technique could be used on the DATA channel as well,
;		but it would make the calculation of HXS (and this happens
;		very frequently) inefficient.
;
;		Hence, this variable increases whenever a new segement number
;		is assigned and never decreases.
;
;
;	HAA	Highest ACK Acceptable.  It is increased when a message is 
;		transmitted and the new LNX is greater than the old HAA.  It is
;		decreased if the trasnmitter is "segment" flow controlled and
;		receives negative flow credits which caused the old HAA to be 
;		no longer flow controlled.
;
;
;		
;  LSB Rules
;
;	HAR		0a.  Increases but never decreases
;	HXS		0b.  Increases and decreases
;	LNX		0c.  Increases and decreases
;	LUX		0d.  Increases but never decreases
;	HAA		0e.  Increases and decreases
;
;    	HAR leq HXS	1a.  Never advance HAR beyond HXS without advancing HXS
;			1b.  Never shrink  HXS below  HAR
;
;	HAR leq LNX	2a.  Never advance HAR beyond LNX without advancing LNX
;			2b.  Never shrink  LNX below  HAR
;
;	HAR leq LUX	3a.  Never advance HAR beyond LUX (done via 1a. + 5a.)
;			3b.  Never shrink  LUX below  HAR (done via 0d.)
;
;	HXS geq LNX	4a.  Never shrink  HXS below  LNX without shrinking LNX
;			4b.  Never advance LNX beyond HXS
;
;	HXS leq LUX	5a.  Never advance HXS beyond LUX
;			5b.  Never shrink  LUX below  HXS (done via 0d.)
;
;	LNX leq LUX	6a.  Never advance LNX beyond LUX (done via 4b. + 5a.)
;			6b.  Never shrink  LUX below  LNX (done via 0d.)
;
;	HAA geq HAR	7a.  Never advance HAR beyond HAA
;			7b.  Never shrink  HAA below  HAR (done via 1b.)
;
;	HAA --- HXS	8a.  Can be less than, equal to, or greater than
;
;	HAA geq LNX	9a.  Never advance LNX beyond HAA without advancing HAA
;			9b.  Never shrink  HAA below  LNX without shrinking LNX
;							  (done via 4a.)
;
;	HAA leq LUX	10a. Never advance HAA beyond LUX (done via 6a. + 9a.)
;			10b. Never shrink  LUX below  HAA (done via 0d.)
;
;
;  LSB Receiver segment number variables:
;
;	HAX leq HNR	11a. Never advance HAX beyond HNR
;			     (HAX never shinks)
;
;


	.PSECT	$$$115_DRIVER,LONG,EXE,RD,WRT

NSP$B_ADJ_XPW::	.BYTE	NSP$C_ADJ_XPW	
NSP$B_MAX_XPW::	.BYTE	NSP$C_MAX_XPW
NSP$B_MAX_RBF::	.BYTE	NSP$C_MAX_RBF
NSP$B_R_CXBTHR::.BYTE  	NSP$C_R_CXBTHR

;
;
;  The following table is used to map a received message into an event.  It
;  is ordered according to the most likely received event and is terminated
;  with a longword of zero.
;
;  It also contains miscellaneous information -- what the minimum size of the
;  message is, and whether or not the message size is fixed or variable
;
;
RCVMAP_B_MSG = 0
RCVMAP_B_SIZ = 1
RCVMAP_B_EVT = 2
RCVMAP_C_END = ^X<FFFF>			; MSG code used to terminate table

.MACRO	MAP_RCV_MSG	MSG,FIXED,MIN_SIZ

	.BYTE	NSP$C_MSG_'msg'		; Message type
	.IF  NB,FIXED			; 1 if fixed sized message, else 0
		.BYTE	min_siz		; fixed - enter minimum msg size
	.IFF				;
		.BYTE	-min_siz	; variable - enter negative min msg siz
	.ENDC				;
	.BYTE	NETEVT$_'msg'		; Event code

.ENDM	MAP_RCV_MSG

NET$AT_RCVMSG:

MAP_RCV_MSG	DATA,	 ,  7		; Data message
MAP_RCV_MSG	DTACK,	 ,  7		; Data Ack
MAP_RCV_MSG	LS,	 ,  9  		; Link service message
MAP_RCV_MSG	LIACK,	 ,  7		; Link service/Interrupt Ack
MAP_RCV_MSG	INT,	 ,  7  		; Interrupt message
MAP_RCV_MSG	CI,	 , 10  		; Connect Initiate
MAP_RCV_MSG	CA,	F,  3		; Connect Ack
MAP_RCV_MSG	CC,	 ,  9  		; Connect Confirm
MAP_RCV_MSG	DI,	 ,  7  		; Disconnect Initiate
MAP_RCV_MSG	DC,	F,  7		; Disconnect Confirm

		.LONG	-1		; Terminate the table
.ALIGN	LONG


	.SBTTL	NET$SETUP_RUN	- Setup XWB for the RUN state
;+
;
;  INPUTS:  R5	XWB address
;	    R0	Scratch
;
;  OUTPUTS: R0  Low bit set
;
;	    All other registers are preserved.
;
;
;-
NET$SETUP_RUN::					  ; Setup XWB for RUN state

	PUSHR	#^M<R1,R2,R3,R4,R6,R7,R8,R9,R10>  ; Save regs
	;
	;
	;    Determine XWB$W_REMSIZ - it can be no larger than XWB$W_LOCSIZ.
	;
	;
	MOVL	XWB$L_VCB(R5),R2		  ; Get RCB
	CMPW	XWB$W_REMSIZ(R5),XWB$W_LOCSIZ(R5) ; Compare sizes.
	BLEQU	20$				  ; If LEQU then okay
	MOVL	XWB$W_LOCSIZ(R5),XWB$W_REMSIZ(R5) ; Use smaller for REMSIZ
20$:	;
	;
	;    Links are to a given path by having a non-zero XWB$W_PATH value.
	;    Since the path selection is forced the link is 'non-adaptive' but 
	;    is much more efficient since it uses a faster interface an may
	;    use a larger buffer than RCB$W_ECLSEGSIZ.
	;
	;    If this is a 'non-adaptive' link, then convert the permanent copy
	;    of the route-header since it's format is path dependent.
	;
	;
	MOVZBL	XWB$W_PATH(R5),R3		; Get path index
	BEQL	30$				; If EQL, path is not forced
	MOVL	XWB$L_PTR_RTHD(R5),R1		; Get route-header pointer
	BSBW	QRL$SETUP_CHAN			; Setup QRL channel
	BLBC	R0,30$				; If LBC, no channel
	MOVB	R4,XWB$B_ADJ_INX(R5)		; Save the Adjacency index
	MOVL	R1,XWB$L_PTR_RTHD(R5)		; Get route-header pointer
	MOVL	R3,-(R1)			; Store the route-header size
30$:	;
	;
	;    Determine the number of receive and transmit buffers 'donated' by
	;    the system.
	;
	;    Although this buffer 'donation' does not strictly adhere to VMS 
	;    conventions it is bounded (fixed number of buffers per link in the
	;    worst case) and allows for a significant performance gain and much
	;    simpler code.  In addition, it means that processes can use DECnet
	;    efficiently even though they may have low BYTLM quota, and hence
	;    BYTLM does not have to be set ridiculously high (and thus rendering
	;    it just about useless).
	;
	;    The number of buffers donated for transmits is currently derived
	;    from the NCP "Pipeline Quota" parameter -- hence this pool use
	;    (or misuse) is controlled by the system manager since the maximum
	;    pool used will be "Pipeline Quota" times "Maximum Links".
	;
	;    The number of buffers used for receives has not been made a
	;    parameter for simplicity.  It is possible that, rather than making
	;    it a parameter, it would be better to bound the buffer occupancy
	;    time by periodically:
	;
	;		- deallocating the oldest Rcv CXB's queue to the LSB
	;		  (it hasn't been ACKed yet)
	;		- using the Special Kernel AST to copy partial messages
	;		  attached to Rcv IRP's to the user buffer (this is now
	;		  done using an attached CXB count rather than a timer).
	;
	;	NOTE:	Perhaps limiting the number of CXB's moved to the IRP
	;		could make the above schemes work better.  This means
	;		that the AST code would have to start processing the
	;		LSB list (RCV_IRP?) after emptying the IRP list.
	;
	;    Keep in mind that allowing flexible receive buffering may save
	;    wasted datalink bandwidth and CPU cycles by reducing the number
	;    of back-pressure messages and data segment retransmission.
	;
	;	NOTE:	It has been found that being able to buffer at least
	;		one incoming segment per logical-link is essential for
	;		for performance -- otherwise too many backpressure
	;		messages need to be sent.  The segment, once buffered,
	;		should not be ACK'd until the user issue's a receive or
	;		until the same segment is retransmitted by the remote
	;		end (in which case the link should be backpressured
	;		until the use issues a receive).
	;
	;		For this reason, it is essential for the system to 
	;		donate at least one receive buffer per logical-link.
	;		
	;
	CLRL	R8				; Take no additional quota
						; until implemented
						;
	ASSUME	NSP$C_MAX_XPW  LE  254		; Make sure it can fit in a byte
						;
	MOVZBL	RCB$B_ECL_RFLW(R2),R7		; Get default max XMT CXB's
	BNEQ	60$				; If NEQ, okay
	INCB	R7				; Else, use 1 as a minimum
60$:	CMPB	R7,#NSP$C_MAX_XPW		; With bounds ?
	BLEQU	70$				; If LEQU, okay
	MOVZBL	NSP$B_MAX_XPW,R7		; Else use maximum
70$:	MOVZBL	NSP$B_MAX_RBF,R8		; Max unACK'd rcv CXB's allowed
	;
	;
	;    Complete IO$_ACCESS IRP with success 
	;
	;
	MOVL	S^#SS$_NORMAL,R0		; Setup IOSB image
	MOVZWL	XWB$W_REMSIZ(R5),R1		; IOSB second longword
	BSBW	NET$CMPL_ACC			; Complete the access QIO
	;
	;
	;    Setup the DATA LSB.  
	;
	;
	MOVAB	XWB$T_DT(R5),R0			; Get DATA LSB address
	BSBB	SETUP_LSB			; Init it
	MOVAB	XWB$T_LI(R5),LSB$L_CROSS(R0)	; Setup cross channel pointer
	MOVB	#LSB$M_BOM,LSB$B_STS(R0)	; Next seg should set 'BOM' flag
	MOVB	#3,R1				; Default "xmt packet window"
	CMPB	R1,R7				; Larger than X_CXBQUO ?
	BGEQU	80$				; If GEQU yes, shrink it
	DIVB3	#3,R7,R1			; Else, enlarge packet window
	ADDB	R1,R1				; Use two thirds CXBQUO
	INCB	R1				; Plus one (to avoid zero)
	BRB	90$				; Continue
80$:	MOVB	R7,R1				; Else shrink XPW value
90$:	MOVB	R1,LSB$B_X_PKTWND(R0)		; Setup "xmt packet window"
	MOVB	NSP$B_ADJ_XPW,LSB$B_X_ADJ(R0)	; Init window adjust counter
	MOVB	R7,LSB$B_X_CXBQUO(R0)		; Setup max xmt CXB to allocate
	MOVB	R8,LSB$B_R_CXBQUO(R0)		; Init max rcv CXB's NSP may 
						; buffer before passing some to
						; the session layer (user space)
	;
	;
	;    Setup the Link-Service/Interrupt LSB
	;
	;
	MOVAB	XWB$T_LI(R5),R0			; Get LI LSB address
	BSBB	SETUP_LSB			; Init it
	MOVAB	XWB$T_DT(R5),LSB$L_CROSS(R0)	; Setup cross channel pointer
	MOVB	#LSB$M_LI,LSB$B_STS(R0)		; Mark it as LI subchannel
	MOVB	#1,LSB$B_X_PKTWND(R0)		; Init the "xmt packet window"
	INCB	LSB$B_X_REQ(R0)			; NSP says that 1 Interrupt 
	INCB	LSB$B_R_CXBQUO(R0)		;  message is implicitly 
						;  requested upon connect
	;
	;
	;    Finish setting up the XWB and return to the event processor to 
	;    change state and re-process the same event again.
	;
	;
	MOVW	XWB$W_TIM_INACT(R5),XWB$W_TIMER(R5) ; Reset timer
	BICW   #XWB$M_STS_CON,XWB$W_STS(R5)	    ; XWB now in "RUN" format
						    ;
	POPR   #^M<R1,R2,R3,R4,R6,R7,R8,R9,R10>     ; Restore regs
	MOVL   #1,R0				    ;
	RSB



SETUP_LSB:					; Common LSB initialization
	PUSHR	#^M<R0,R5>			; Save regs
	MOVC5	#0,(SP),#0,#LSB$S_LSB,(R0)	; Fill LSB with zero's
	POPR	#^M<R0,R5>			; Restore regs
	RSB					; Done


	.SBTTL	NET$ALTENTRY	- Driver alternate entry point
;+
;
;  This routine is called by the Executive to pass an "internal" IRP to the 
;  driver.  "Internal" IRP's are those not built via QIO.  These IRPs are used
;  by higher level software used to request I/O and should not be confused with
;  the IRPs built and passed by the Transport layer to NSP.  The action here is
;  to setup the IRP fields as if the packet had been processed by the FDT 
;  routines.
;
;
;  INPUTS: 	R5 = UCB address
;		R3 = IRP address
;
;  OUTPUTS:	R5-R0 may be clobbered.
;
;
;-
NET$ALTENTRY::					; Accept an "internal" IRP
	BBC	#31,IRP$L_PID(R3),110$		; If BC, not legal ALSTART IRP
	PUSHR	#^M<R3,R5,R6,R7,R8,R9,R10,R11>	; Save regs
						;
	MOVZWL	IRP$W_BCNT(R3),R1		; Get message size
	CLRL	R11				; Say "can't go to IPL 2"
	BSBB	ALT_ENTRY			; Dispatch on function type
						;
100$:	POPR	#^M<R3,R5,R6,R7,R8,R9,R10,R11>	; Restore regs
	BLBC	R0,120$				; If LBC, IRP was not consumed
	RSB					; Done

110$:	MOVZWL	#SS$_ABORT,R0			; Indicate error
120$:	MOVZWL	R0,IRP$L_IOST1(R3)		; Setup error status
	JMP	G^COM$POST			; Another packet for the heap



	.SBTTL	NET$FDT_RCV	- Process IO$_READxBLK  requests
	.SBTTL	NET$FDT_XMT	- Process IO$_WRITExBLK requests
;+
;
;  The user message is segmented into CXB buffers which are queued to the
;  DATA LSB.  These CXB's are to be passed to the Transport layer for
;  transmission at the appropriate time.
;
;
;  INPUTS:	AP	Pointer to the QIO P1 parameter
;		R11-R9	Scratch
;		R8	Must be saved/restored if return to Exec for next
;			FDT routine
;		R7	I/O function code without modifiers
;		R6	CCB address
;		R5	UCB address
;		R4	PCB address
;		R3	IRP address
;		R2-R0	Scratch
;
;  OUTPUTS:	R5,R3	Preserved
;
;		All other regs are clobbered.
;
;-
NET$FDT_RCV::					; Receiver FDT routine
	CLRL	IRP$L_SES_BUF(R3)		; QIO does not use this buffer
	BISW   #IRP$M_COMPLX!-			; QIO interface uses complex,
		IRP$M_CHAINED!-			; chained buffers
		IRP$M_FUNC,IRP$W_STS(R3)	; and mark as "read" function
	MOVAB	B^RCV_COMMON,R0			; Setup initial action routine
	BRB	RW_FDT				; Continue
						;
NET$FDT_XMT::					; Xmitter's FDT routine
	MOVAB	B^XMT_COMMON,R0			; Setup initial action routine
						;
RW_FDT:	PUSHR	#^M<R3,R5>			; Save reg's
						;
	MOVL	P1(AP),R2			; Get user VA
	MOVZWL	P2(AP),R1			; Get length of transfer
	CLRL	IRP$L_SVAPTE(R3)		; Say "no buffer"
	CLRW	IRP$W_BOFF(R3)			; No byte count quota taken yet
	MOVL	R1,IRP$L_BCNT(R3)		; Setup byte count
	MOVL	#1,R11				; Say "okay to go to IPL 2"
	JSB	(R0)				; Dispatch 
						;
	POPR	#^M<R3,R5>			; Restore reg's
						;
	SETIPL	#IPL$_ASTDEL			; Restore IPL
	BLBC	R0,100$				; If LBC, error
	JMP	G^EXE$QIORETURN			; Return to user with success

100$:	BBSC	#31,R0,110$			; If BS, return error via IOSB
	JMP	G^EXE$ABORTIO			; Abort the I/O
110$:	JMP	G^EXE$FINISHIOC			; Return error via IOSB



		.ENABL	LSB

ALT_ENTRY:					; ALTSTART dispatching
	BBC    #IRP$V_FUNC,IRP$W_STS(R3),ALT_XMT; If BC, write function
						;
ALT_RCV:					; Receiver's ALTSTART routine
	;
	;
	;    Setup buffer address (if any)
	;
	;
	CLRL	R2				; Assume no attach buffer
	MOVL	IRP$L_SVAPTE(R3),IRP$L_SES_BUF(R3) ; Copy buffer address, if any
	BEQL	RCV_COMMON			; If EQL, none
	BBS    #IRP$V_CHAINED,IRP$W_STS(R3),200$; If chained, report error
	CLRL	IRP$L_SVAPTE(R3)		; Detach buffer
	MOVL   @IRP$L_SES_BUF(R3),R2		; Get pointer to data region
						;
RCV_COMMON:					; Common receive entry point
						;
	BSBB	XMT_RCV_CO			; Co-routine common processing
	BSBW	NEW_RCV_IRP			; Queue the request
	TSTL	LSB$L_R_IRP(R8)			; IRP still there ?
	BEQL	100$				; If EQL no, sent to IOPOST
	;
	;
	;    If the receiver is back-pressured off, then open it up again.
	;
	;
	BICW   #XWB$M_FLG_TBPR,XWB$W_FLG(R5)	; Assume toggling not needed
	BBC    #XWB$V_STS_RBP,XWB$W_STS(R5),100$; If BC, not back-pressured off
	BISW   #XWB$M_FLG_TBPR,XWB$W_FLG(R5)	; Toggle back-pressure
100$:	RSB					; Done

200$:	MOVZWL	#SS$_ABORT,R0			; Setup error status
	RSB					; Done
		.DSABL	LSB



ALT_XMT:					; Xmitter's ALTSTART routine
	MOVL	@IRP$L_SVAPTE(R3),R2		; Get start of data
						;
XMT_COMMON:
	BBC    #IO$V_INTERRUPT,IRP$W_FUNC(R3),50$ ; If BC, DATA subchannel
	BSBB	XMT_INT_CO			; INT msg setup co-routine
	MOVAB	XWB$T_LI(R5),R8			; Get LS/INT LSB
	MOVAB	B^100$,R7			; Replace build routine ptr
	BRB	60$				; Contine
50$:	BSBB	XMT_RCV_CO			; Common setup co-routine 
	MOVAB	W^XMT_COPY,R7			; Setup message building routine
60$:	;
	;
	;    Attach IRP to request list
	;
	;
	MOVAB	LSB$L_X_PND(R8),R0		; Perpare for scan
70$:	MOVL	R0,R1				; Make a copy
	MOVL	(R0),R0				; Get next IRP
	BNEQ	70$				; If NEQ, not last
	MOVL	R3,(R1)				; Attach IRP to end of list.
	;
	;
	;    Start building and sending data segments
	;
	;
	JSB	(R7)				; Build as many CXB's as we can
	MOVL	R8,R2				; Setup LSB ptr for subr call
	BRW	CALC_HXS_XMT			; Determine new HXS value
						; -- update XWB$M_FLG_WHGL


100$:	TSTL	(SP)+				; Avoid call to CALC_HXS_XMT
	BRW	CHK_INT_AVL_R8			; Schedule Interrupt message
						; transmission if possilbe


		.ENABL	LSB
XMT_INT_CO:					; Xmt INT message co-routine
	BSBB	COPY_INT_DATA			; Copy data to IRP
	BLBC	R0,900$				; If LBC, error
	BRB	10$				; Continue
						;
XMT_RCV_CO:					; Common XMT/RCV co-routine
	MOVW	#SS$_NORMAL,IRP$L_IOST1(R3)	; Init status
	MOVW	R1,IRP$L_IOST1+2(R3)		; Save buffer size
	MOVL	R2,IRP$L_IOST2(R3)		; Save buffer address
						;

10$:	ASSUME	IRP$L_IOQFL  EQ  0
	ASSUME	IRP$B_QUO    EQ  4
	ASSUME	IRP$B_CXBCNT EQ  5

	CLRQ	(R3)				; Clear linkage and CXB quota
	;
	;	
	;    Switch to XWB context, verify RUN state, locate LSB
	;
	;
	SETIPL	#NET$C_IPL			; Synchronize with XWB, etc.
	BICL3	#1,IRP$L_WIND(R3),R5		; Go to XWB context
	BEQL	200$				; If EQL, no XWB
	CMPB	#XWB$C_STA_RUN,XWB$B_STA(R5)	; RUN state ?
	BNEQ	300$				; If NEQ no, return error
	MOVL	XWB$L_VCB(R5),R2		; Setup RCB pointer 
	MOVAB	XWB$T_DT(R5),R8			; Get DATA LSB
	;
	;
	;    Call back
	;
	;
	JSB	@(SP)+
	;
	;
	;    Send any new messages and return "success"
	;
	;
	BSBW	NET$SCH_MSG			; Schedule message transmission
	MOVZWL	S^#SS$_NORMAL,R0		; Indicate success
	RSB					; Done.

200$:	MOVL	#SS$_FILNOTACC,R0		; Say "no logical-link"
	BRB	900$				; Continue
300$:	MOVZWL	#SS$_LINKABORT,R0		; Say "not in RUN state"
800$:	BBSS	#31,R0,900$			; Say "return error via IOSB"
900$:	TSTL	(SP)+				; Pop co-routine address
	RSB					; Done

		.DSABL	LSB





COPY_INT_DATA:
	;
	;
	;    This is an INTERRUPT message.  
	;
	;    Probe data if QIO interface.  Move the data into the IRP starting
	;    at IRP$L_IOST1 with IRP$W_BCNT used to contain the size.
	;
	;    When the sequence number is assigned to this IRP (see NET$SCH_MSG)
	;    the IO$V_INTERRUPT flag is cleared in IRP$W_FUNC in order to flag
	;    the IRP state change.
	;
	;
	MOVZWL	#SS$_TOOMUCHDATA,R0		; Assume length violation
	CMPL	#16,R1				; Check data length
	BLSSU	100$				; If LSSU, too much data
	BBS	#31,IRP$L_PID(R3),30$		; If BS, then ALSTART interface
	EXTZV	#0,#2,IRP$B_RMOD(R3),R4		; Get mode for probe
	MOVZWL	#SS$_ACCVIO,R0			; Assume 
	IFNORD	R1,(R2),100$,R4			; Goto 500$ if can't read data
						;

30$:	ASSUME	IRP$L_IOST1	EQ   0+IRP$L_MEDIA	; Make sure there's 
	ASSUME	IRP$L_IOST2	EQ   4+IRP$L_MEDIA	; enough scratch space
	ASSUME	IRP$Q_STATION	EQ   8+IRP$L_MEDIA	; for the data in the
							; IRP itself.

	PUSHR	#^M<R3,R5>			; Save regs
	MOVC3	R1,(R2),IRP$L_IOST1(R3)		; Copy data into IRP
	POPR	#^M<R3,R5>			; Restore regs
						;
	MOVL	#1,R0				; Say "success"
100$:	RSB					; Done



	.SBTTL	NET$UNSOL_INTR	- Receive from Transport Layer 
;++
;
;  The following "unsolicited interrupt" routine is called by Transport
;  whenever it has received a message addressed to NSP.  NSP must process the
;  message completely and return to Transport without forking.  The message can
;  be found in a single buffer of "complex chained" (CXB) format.  If NSP 
;  wishes to keep the message it must zero its the CXB pointer before returning
;  to Transport.
;
;  NSP may need to return the message to its sender.  For instance, the
;  message may be addressed to a link which no longer exists.  If this
;  is the case, the CXB is kept and used as the context block for soliciting 
;  permission to transmit.
;
;
;  INPUTS:	R8	Scratch
;		R7	Length of NSP message  (w/o route-header)
;		R6	Address of CXB containing the message
;		R5-R3	Scratch
;		R2	RCB address
;		R1	Pointer to first NSP byte in message
;		R0	Scratch
;
;
;		CXB$L_R_RCB	RCB address			 (copy of R2)
;		CXB$L_R_MSG	Ptr to 1st NSP byte in message   (copy of R1)
;		CXB$W_R_BCNT	Length of NSP message 		 (copy of R7)
;		CXB$W_R_SRCNOD	Source node address
;		CXB$W_R_DSTNOD  Local node address 
;		CXB$B_R_FLG	LBS if CXB cannot be conusmed due to
;				receiver buffering problems
;		CXB$W_R_PATH	Path number over which message was received
;
;  OUTPUTS: (upon return to Transport)
;
;		R8,R7	Garbage
;		R6	0 if CXB was consumed.
;			Else, original CXB address with CXB$W_SIZE and
;			      CXB$B_TYPE unchanged.
;		R5-R0	Garbage
;
;--
NET$UNSOL_INTR::			; Receive message from Transport layer
	PUSHR	#^M<R9,R10,R11>		; Extend to 'event' context -
					;
	CLRL	R11			; Say "can't go to IPL 2"
;;	BUMP	L,NDC+NDC$L_PRC(R5) 	; Inc 'packets rcvd' counter
	BSBB	RCV_MSG			; Process received message
					;
	POPR	#^M<R9,R10,R11>		; Revert to 'fork' context
	RSB				; Return to Transport

RCV_MSG:;
	;
	;    Map the message into an event code and check for message size
	;    violations.
	;
	;
	ASSUME	RCVMAP_B_MSG    EQ  0
	ASSUME	RCVMAP_B_SIZ    EQ  1
	ASSUME	RCVMAP_B_EVT    EQ  2
	ASSUME	NSP$C_MSG_DATA  EQ  0

	MOVZBL	(R1)+,R9		; Get message type code
5$:	MOVB	R9,CXB$B_R_NSPTYP(R6)	; Store it
	MOVAB	NET$AT_RCVMSG+1,R8	; Assume DATA message
	BITB	#^C<NSP$M_DATA_EOM!-	;
		    NSP$M_DATA_BOM>,R9 	; Test all but DATA msg modifier bits
	BEQL	20$			; Br if DATA message
10$:	CMPW	#RCVMAP_C_END,(R8)+	; Advance to next entry
	BEQL	35$			; If NEQ, at end of table -- ignore msg
	CMPB	R9,(R8)+		; Message type match ?
	BNEQ	10$			; If NEQ no, loop to try again
20$:	CVTBL	(R8)+,R0		; Get min size by message type
	BLSS	40$			; If LSS then variable message size
	SUBL	R0,R7			; Dec. msg length by expected size
	BEQL	50$			; If EQL then okay
30$:	BRW	FMT_ERROR		; Message too short
35$:	;
	;
	;    Message type unknown.  Check to see if its a retransmitted CI, and
	;    if so, convert the code in R9 and try again.  Else, report the 
	;    event.
	;
	;
	CMPB	R9,#NSP$C_MSG_CR	; Retransmitted Connect Initiate ?
	BNEQ	37$			; If NEQ no, report event
	MOVB	S^#NSP$C_MSG_CI,R9	; Convert to CI 
	BRB	5$			; Look up table entry for CI's
37$:	BRW	UNK_MSG			; Message type unknown
40$:	;
	;
	;    Message type found, continue processing
	;
	;
	ADDL	R0,R7			; Reduce message by minimum size
	BLSS	30$			; If LSS then too short
50$:	CMPB	R9,S^#NSP$C_MSG_CI	; Is message Connect Initiate ?
	BNEQ	70$			; If NEQ, no
	;
	;
	;    First check to see if this is a message being returned since
	;    the remote node is unreachable.  
	;
	;
	BBC	#1,CXB$B_R_FLG(R6),60$	; If BC then not "return to sender"
					;; use a symbol
	MOVZWL	2(R1),R3		; Get local link i.d.
	BSBW	NET$XWB_LOCLNK		; Switch to XWB context
					; -- destroys R4
	BLBS	R5,55$			; No associated XWB if LBS
	CMPW	CXB$W_R_SRCNOD(R6),-	; Does the remote node i.d. match ?
		XWB$W_REMNOD(R5)	;
	BNEQ	55$			; If NEQ then no, forget it
	MOVZWL	#NETEVT$_RTS,R7		; Setup "returned to sender" event code
	BRW	200$			; Dispatch to process the event
55$:	BRW	DISCARD	
60$:	;
	;
	;    Its an incoming connect request.  Create an XWB
	;
	;
	TSTW	(R1)+			; Skip over local link field
	BNEQ	30$			; Message format error if non-zero
	MOVZWL	CXB$W_R_SRCNOD(R6),R3	; Get source node address for subr calls
	MOVL	R3,R0			; Setup remote node address for subr.
	BSBW	TR$TEST_REACH		; Is it reachable ?
	BLBC	R0,DISCARD		; If LBC, not reachable -- forget it
	MOVL	RCB$L_ACP_UCB(R2),R5	; Get UCB address
	BSBW	NET$CREATE_XWB		; Get a new XWB and link slot
	BLBS	R5,NO_RSRC		; Br if no resources
;;	BUMP	W,NDC$W_CRC(R10)	;; need to account for resource errors
	BUMP	W,NDC+NDC$W_CRC(R5)	; Increment "connects received"
	MOVW	CXB$W_R_PATH(R6),-	; Store the path over which the message
		XWB$W_CI_PATH(R5)	; was received
	SUBW3	#1,XWB$W_RETRAN(R5),-	; Init PROGESS -- we want to break the
		   XWB$W_PROGRESS(R5)	; link if we timeout before user issues
					; the IO$_ACCESS function
	MOVW	(R1)+,XWB$W_REMLNK(R5)	; Store remote link address
	BRB	100$			; Continue in common
70$:	;
	;
	;    Not a Connect Intiate.  Find the XWB and verify the partner's
	;    node address.  
	;
	;
	MOVZWL	(R1)+,R3		; Get 'destination' link address
	BSBW	NET$XWB_LOCLNK		; Switch to XWB context
					; -- destroys R4
	BLBS	R5,RTS_NLT		; No associated XWB if LBS
;	TSTW	XWB$W_REMLNK(R5)	; Remote link address known yet?
;	BEQL	75$			; If EQL no, skip remote node check
;					; (for "cluster" node implementation
	CMPW	CXB$W_R_SRCNOD(R6),-	; Is msg from proper remote?
		XWB$W_REMNOD(R5)	; node ?
;	BEQL	80$			; If so, continue
;	TSTW	XWB$W_REMNOD(R5)	; Was the remote address zero?
	BNEQ	RTS_NLT			; If not, branch
75$: ;	MOVW	CXB$W_R_SRCNOD(R6),-	; Else udpate to use new address
     ;		XWB$W_REMNOD(R5)	; (this is the local node starting
					;  and changing its address)
80$:	;
	;
	;    If the state is Connect Initiate Sending (CIS) or Connect Ack
	;    Received (CAR) then no remote link address has been established
	;    yet.
	;
	;    If the state is Closed (CLO) then the logical-link has been
	;    dissolved at this end we must send a "No-link, terminate" message.
	;
	;
	ASSUME	XWB$C_STA_CLO  EQ  0
	ASSUME	XWB$C_STA_CIS  EQ  1
	ASSUME	XWB$C_STA_CAR  EQ  2

	BUMP	L,NDC+NDC$L_PRC(R5) 	; Inc 'packets rcvd' counter
	CMPB	XWB$B_STA(R5),#2	; Have remote link address yet ?
	BGTRU	90$			; If GTRU then yes
	TSTB	XWB$B_STA(R5)		; CLOSED state?
	BEQL	RTS_NLT			; If EQL yes, there's no link
	MOVW	(R1),XWB$W_REMLNK(R5)	; Store remote link address
90$:	CMPW	(R1)+,XWB$W_REMLNK(R5)	; Is the remote link correct ?
	BNEQ	RTS_NLT			; If not, branch
100$:	MOVL	R7,R2			; Setup # of unaccounted for msg bytes
	MOVZBL	(R8),R7			; Get corresponding event code
200$:	BRW	NET$EVENT		; Process the message

FMT_ERROR:				; Message format error
UNK_MSG:				; Unknown message type
DISCARD:				; Discard message
	RSB				; Ignore the message
					; (someday may want to log them)


	.SBTTL	ACT$RTS_NLT	- Return to sender as "no-link-terminate"
;+
;
;  The logical-link addressed by this message does not exist or could not be
;  created.  Use the CXB as the context block with which to solicit Transport's
;  permission to send a response message.
;
;  If the received message type was a Connect Initiate, then send a
;  "no-resources" message.  Else, send a "no-link-terminate" message.
;
;
;  INPUTS:  R6	   CXB address
;	    R5	   Not used
;	    R4-R0  Scratch
;
;  OUTPUTS: R6	   CXB address or 0 if the CXB is consumed
;	    R4-R0  Garbage
;
;	    All other regs are preserved
;
;-
RTS_NLT:				; Return to sender as no-link-terminate
NO_RSRC:				; No resources for inbound connect
					; fall thru to ACT$RTS_NLT
ACT$RTS_NLT::				; Return to sender as no-link-terminate
	PUSHR	#^M<R5,R6,R7,R8,R9,R10>	; Save regs
					;
	MOVL	CXB$L_R_MSG(R6),R1	; Recover original rcv'd msg pointer
	CMPB	#NSP$C_MSG_DC,(R1)	; Is this a DC message
	BEQL	5$			; If EQL yes, ignore the message
	MOVL	#9,R2			; Specify enough bytes to include NSP 
					; header
	BSBW	CLONE_RCV_CXB		; Clone a copy of a rcv'd CXB
	BLBC	R0,5$			; If LBC then failure
	MOVL	R1,CXB$L_R_MSG(R6)	; Save message pointer
	MOVL	R6,R5			; Use CXB as 'request block'
	BSBB	10$			; Continue in common
					;
5$:	POPR	#^M<R5,R6,R7,R8,R9,R10>	; Save regs
	RSB				; Done


10$:	;
	;
	;    Solicit permission from Transport to transmit a message.  Note
	;    that the request could suspend us indefinitely.  The call is 
	;    made with:
	;
	;
	; 	R5	Fork block address.
	;		The FPC,FR3,FR4 fields are all scratch and must not
	;		be modified by while Transport owns the fork block.
	;	R4	Destination node address 
	;	R3	Index of LPD to xmit over 
	;		Zero if Transport is to choose the LPD 
	;	R1,R0	Scratch	
	;
	;	(SP)	Return address of caller
	;      4(SP)	Return address of caller's caller
	;
	;
	MOVZWL	CXB$W_R_SRCNOD(R5),R4 	; Get remote node addresses
	CLRL	R3			; Indicate no predetermined line
	MOVL	CXB$L_R_RCB(R5),R2	; Setup RCB address
	BSBW	TR$SOLICIT		; Solicit permission to xmit
					; (return may suspended indefinitely)
	;
	;
	;   Return from Transport with:
	;
	;	R7,R6	Scratch
	;	R5	Fork block address
	;	R4	Scratch
	;	R3	Not available -- must be saved/restored
	;	R2	RCB address
	;	R1	Scratch
	;	R0	Low bit set if permission granted
	;		Low bit clear if permission denied
	;
	;
	BLBS	R0,20$			; If LBS then okay to xmit
	MOVL	R5,R0			; Get block address
	BSBW	NET$DEALLOCATE		; Deallocate the block
	BRB	40$			; Return
20$:	;
	;
	;    Okay to xmit.  Build the message on the stack since the CXB will
	;    be corrupted before the final message is built.  Reformat the CXB,
	;    move the new message to the CXB, and return to Transport.
	;
	;    The message is built on the stack starting with the last byte so
	;    that when it is moved off of the stack conveniently.
	;
	;
	PUSHR	#^M<R3,R9,R10,R11>	; Save regs
					;
	CLRL	R11			; Say "can't go to IPL 2"
;;	BUMP	L,NDC$L_PSN(R10)	; Update "packets sent"
					; Build the message backwards
	MOVL	CXB$L_R_MSG(R5),R0	; Get ptr to original message
	MOVW	#NET$C_DR_NOLINK,-(SP)	; Assume "no link terminate"
	CMPB	#NSP$C_MSG_CI,(R0)	; If rcvd message is a Connect Initiate
	BEQL	25$			;  then terminate or...
	CMPB	#NSP$C_MSG_CR,(R0)	;  a retransmitted Connect Initiate
	BNEQ	30$			;  
25$:	MOVW	#NET$C_DR_RSU,(SP)	;  then set reason as "no resources"
30$:	;
	;
	;    Reverse destination and source of the logical link and
	;    node addresses in the new message
	;
	;
	MOVW	NSP$W_DSTLNK(R0),-(SP)	; Enter local link address as source
	MOVW	NSP$W_SRCLNK(R0),-(SP)	; Enter remote link address as dest
	MOVB	#NSP$C_MSG_DC,-(SP)	; Enter msg type
	CLRB	-(SP)			; Enter the Transport "visits" field
	MOVW	CXB$W_R_DSTNOD(R5),-(SP); Enter local node address
	MOVW	CXB$W_R_SRCNOD(R5),-(SP); Enter remote node address
	MOVAB	CXB$T_X_XPORT(R5),R1	; Get ptr to message to be built
	MOVL	R1,R3			; Make a working copy 
	MOVB	#TR3$C_MSG_DATA,(R3)+	; Enter Transport message type
	MOVL	(SP)+,(R3)+		; Enter Dst,Src node addresses
	MOVQ	(SP)+,(R3)+		; Enter Visits, NSP msg type, Dst and
					;       Src link addresses, Reason code
	SUBL3	R1,R3,R7		; Setup message size
	MOVAB	G^COM$DRVDEALMEM,R2	; Address of I/O "end-action" routine
	MOVL	R5,R6			; Setup buffer address
	MOVL	#1,R0			; Tell Transport "okay to xmit"
					;
	POPR	#^M<R3,R9,R10,R11>	; Restore regs
	;
	;
	;   Return to Transport with:
	;
	;    On return, the CXB and registers are setup as follows:
	;
	;
	;   +---------------+
	;   |   standard    |	11 bytes long.  CXB$L_FLINK and CXB$L_BLINK may
	;   |     VMS	    |	be used by the Transport layer.  CXB$W_SIZE 
	;   | buffer header |	must be correct.  CXB$B_TYPE must be DYN$C_CXB.
	;   +---------------+
	;   |		    |	Starts with CXB$B_CODE (byte 11) and continues
	;   |      ECL	    |	to CXB$C_LENGTH.  This area is read-only to
	;   |   pure area   |	Transport and below.  It cannot even be
	;   |               |	saved/restored.
	;   +---------------+
	;   |    Datalink   |	Starts at CXB$C_LENGTH and is at least 
	;   |     Layer	    |	CXB$C_DLL bytes long.  Used by the datalink for
	;   |  impure area  |	protocol header or state information.
	;   +---------------+
	;   |		    |	
	;   .    body of    .	Must be quadword aligned and starting no sooner
	;   .    message    .   than CXB$C_LENGTH + CXB$C_DLL (= CXB$C_HEADER)
	;   |		    |
	;   +---------------+
	;   |    Datalink   |	Used by the datalink layer for protocol (e.g.,
	;   |     Layer     |	checksum) or state information.  Must be at
	;   |  impure area  |	least CXB$C_TRAILER in length.
	;   +---------------+
	;
	;
	;	R7	Size of message
	;	R6	CXB address
	;	R5	Garbage
	;	R4	0 if "quick solicit" not requested
	;		Else, pointer to request block (XWB fork block) with
	;		FRK$L_FPC  pointing to the "quick solicit" routine
	;	R3	IRP address -- unmodified from call
	;	R2	Address of End-action routine to call on I/O competion
	;	R1	Ptr to 1st byte in standard Phase III route-header
	;	R0	Low bit set   -	if message is to be xmitted
	;		Low bit clear -	if no message to xmit.  In this case
	;				R7-R4,R2,R1 contain garbage.
	;
	;
40$:	CLRL	R4			; Say "quick solicit not wanted"
	RSB


	.SBTTL	ACT$RCV_CC	- Respond to a received Connect Confirm message
	.SBTTL	ACT$RCV_CA	- Respond to Connect Acknowledge
	.SBTTL	ACT$RCV_CI	- Process received Connect Initiate message
;++
;
;  These routines process received connect messages
;
;
;  INPUTS:  R8	Scratch
;	    R7	Scratch
;	    R6	CXB address
;	    R5	XWB address
;	    R4	Scratch
;	    R3	Scratch
;	    R2	Number of as yet unaccounted bytes in message
;	    R1	Pointer to first unparsed byte in message
;	    R0	Scratch
;
;  OUTPUTS: R8,R7,R4,R3,R2,R1 are garbage
;
;	    R6	Preserved
;	    R5  Preserved
;	    R0	Standard VMS status code
;
;--
		.ENABL	LSB
ACT$RCV_CC::				; Repond to rcv'd CC msg
	MOVZWL #NET$C_DR_ZERO*2,R0	; Assume error
	TSTW	XWB$W_REMLNK(R5)	; Test new remote link address
	BEQL	12$			; If EQL then illegal
	BSBW	PRS_CHR			; Parse link characteristics
	BLBC	R0,12$			; If LBC then unsuccessful
	CMPB	XWB$B_STA(R5),-		; Establish timer estimate
	       #XWB$C_STA_CAR		; unless its been done already
	BEQL	10$
	BSBB	ACT$RCV_CA		; Set timer seed value
10$:	UPDATE	L,R2,NDC+NDC$L_BRC(R5)	; Bump "bytes received"
	MOVZWL #MSG$_CONFIRM,R8		; Set mbx message code
	BSBW	NET$SEND_CS_MBX		; Notify user
	BLBC	R0,50$			; Br if error
	BSBW	NET$SETUP_RUN		; Setup XWB for the RUN state
	MOVZWL #NETEVT$_CC,R7		; Set original event code
	BRW	NET$COMPLEX_EV		; Enter the RUN state and process new
					; event
12$:	BRW	100$			; Report protocol error

ACT$RCV_CA::				; Respond to rcv'd CA msg
	MOVW	#1,R3			; Setup minimum timer value
	MOVW	XWB$W_ELAPSE(R5),R0	; Get elapsed time
	BEQL	15$			; If EQL then use minimum
	MOVW	#NSP$C_MAX_DELAY,R3	; Setup maximum timer value
	CMPW	R0,R3			; Compare max timer, elapsed time
	BGEQU	15$			; If GEQU then R3 is smaller
	MOVW	R0,R3			; Else use elapsed time
15$:	MOVW	R3,XWB$W_DELAY(R5)	; Setup seed value for timer
	MOVL	XWB$L_ICB(R5),R0	; Get the ICB
	ADDW3	#1,ICB$W_TIM_OCON(R0),R0; Get outbound connect timer (the 1
					; is for possible clock skew)
	SUBW3	XWB$W_TIMER(R5),R0,-	; Replace TIMER with the amount of time 
		XWB$W_TIMER(R5)		; left before the connect times out
	BGTR	17$			; If GTR then okay
	MOVW	#1,XWB$W_TIMER(R5)	; Else use 1 second as minimum value
17$:	RSB				; May change state on return

ACT$RCV_CR::				; Process retransmitted CI message
	BISW	#XWB$M_FLG_SCD,-	; Set "send connect/disconnect" flag
		 XWB$W_FLG(R5)		;
	RSB				; Done

ACT$RCV_CI::				; Process CI message
	BSBW	PRS_CHR			; Parse the link characteristics
	BLBC	R0,100$			; Br on error
	BSBW	GETCTL			; Parse remainder of message
	BLBC	R0,100$			; Br on error
	BRW	NET$QUE_XWB		; Queue XWB to NETACP

;
;
;  Catch errors here.  In each case the return is with the low bit clear
;  to flag a new event to be processed.
;
;
50$:	TSTL	R0			; 0=> counted str format error
	BNEQ	200$			; If eql then protocol error
100$:	MOVZBL	#NETEVT$_PROERR,R7	; Setup new event
	DIVW3	#2,R0,XWB$W_X_REASON(R5); Set disconnect reason
	BRB	300$			; Continue
200$:	MOVW	#NET$C_DR_RSU,-		; Setup disconnect reason as
		XWB$W_X_REASON(R5)	; "no resources"
	MOVZBL	#NETEVT$_MBXERR,R7	; Setup new event
300$:	BRW	NET$PRE_EMPT		; Pre-empt with new event


		.DSABL	LSB


	.SBTTL	PRS_CHR    	- Get characteristics from Connect message
;
;
;
PRS_CHR:				; Get link characteristics
	;
	;
	;    If any part of the SERVICES field is not recognized then
	;    reject the connect.
	;
	;
	BICB3	#^C<NSP$M_SRV_REQ>,(R1),R0 ; Get pertinent service bits
	CMPB	#NSP$C_SRV_REQ,R0	; Are they correct ?
	BNEQ	200$			; If NEQ no
	MOVB	(R1)+,R0		; Get SERVICES field
	EXTZV	#NSP$V_SRV_FLW,-	; Get flow control bits
		#NSP$S_SRV_FLW,R0,R0	;	
	MOVL	#XWB$M_PRO_NFC,R4	; Assume "no-flow"
	CMPB	#NSP$C_SRV_NFC,R0	; Is it ?
	BEQL	10$			; If EQL yes	
	MOVL	#XWB$M_PRO_SFC,R4	; Assume "seg flow"
	CMPB	#NSP$C_SRV_SFC,R0	; Is it ?
	BEQL	10$			; If EQL yes
	CLRL	R4			; Assume "msg-flow"
	CMPB	#NSP$C_SRV_MFC,R0	; Is it ?
	BNEQ	200$			; If NEQ no, reject message
10$:	BISB	R4,XWB$B_PRO(R5)	; Insert flow control info
	;
	;
	;    Parse the INFO field.  Ignore any part of the field which is
	;    not recognized.
	;
	BICB3	#^C<NSP$M_INF_VER>,(R1)+,R0 ; Get NSP version, advance msg ptr
					
	MOVL	#XWB$M_PRO_PH2,R4	; Assume Phase II
	CMPB	#NSP$C_INF_V31,R0	; Phase	II ?
	BEQL	50$			; If EQL, no further capabilities
	CLRL	R4			; Init capabilities mask
	CMPB	#NSP$C_INF_V32,R0	; Version 3.2 ?
	BEQL	50$			; If EQL, no cross channel ACKing 
	CMPB	#NSP$C_INF_V40,R0	; Version 4.0 ?
	BNEQ	50$			; If NEQ, version is unknown
	BISB	#XWB$M_PRO_CCA!-	; Cross channel ACKing allowed
		 XWB$M_PRO_NAR,R4	; "No ACK requested" flag allowed
50$:	BISB	R4,XWB$B_PRO(R5)	; Remember capabilities
	;
	;
	;    Parse the SEGSIZ field
	;
	;    Make sure it's nonzero (the NSP spec has a higher minimum, but 
	;    TOPS 20 violates it and there's no sense being overly picky).
	;
	MOVZWL	#<NET$C_DR_SEGSIZ>@1,R0	; Assume illegal segment size
	MOVW	(R1)+,XWB$W_REMSIZ(R5) 	; Get remote's rcv seg size
	BEQL	210$			; If EQL then illegal
	MOVB	#1,R0			; Indicate success
	RSB

200$:	MOVL	#NET$C_DR_PROTCL@1,R0	; Indicate error
210$:	RSB				; Return with error


		.ENABL	LSB
;
;
;  Supporting parse CI routines
;
;
GETCTL:	MOVAB	XWB$B_LPRNAM(R5),R3	; Setup destination pointer
	BSBW	MOVPRNAM		; Move the dest. process name
					;  - no return if error
	MOVAB	XWB$B_RPRNAM(R5),R3	; Setup destination pointer
	BSBW	MOVPRNAM		; Move the src. process name
					;  - no return if error
	MOVB	(R1)+,R4		; Save flags
	MOVAB	(R3)+,R8		; Save current output ptr
					; and advance past count field
	BLBC	R4,70$			; Br if no accounting info
	MOVB	#XWB$C_LOGIN-3,(R8)	; Setup total space available
	BSBB	MOVCS_39		; Move User field
					;  - no return if error
	BSBB	MOVCS_39		; Move Password field
	BSBB	MOVCS_39		; Move Account field
	SUBL	R8,R3			; Get count of bytes moved -
	DECL	R3			;  adjusting for count field
	MOVB	R3,(R8)			; Store count
	SUBL	R3,R2			; Account for "optional" bytes
	BRB	90$			; Continue
70$:	MOVL	#3,(R8)			; A null access string is a 3
					; (string count) followed by
					; 3 zero's (substring counts)
90$:	MOVAW	XWB$B_DATA(R5),R3	; Get next XWB field address
	CLRL	(R3)			; Assume no optional data
	MOVL	#1,R0			; Assume success
	BBC	#1,R4,100$		; Br if no optional data
	UPDATE	L,R2,NDC+NDC$L_BRC(R5)	; Bump "bytes received"
	BSBW	MOVCSFX_17		; Move optional data field
					;  NO return if error
100$:	TSTL	R2			; Any bytes left in message ?
	BNEQ	130$			; Illegal message if NEQ
	;
	;
	;  Move remote user i.d. to non-muliplexed portion of the XWB.
	;
	;  The RPRNAM field, as stored, is one of:
	;
	; <1 byte count><1 byte = 0><1 byte object type  not = 0>
	; <1 byte count><1 byte = 1><1 byte = 0><I-16 process name>
	; <1 byte count><1 byte = 2><1 byte = 0><4 byte UIC><I-12 process name>
	;
	;
	PUSHR	#^M<R1,R2,R4,R5>	; Save regs
					;
	MOVAB	XWB$B_RPRNAM(R5),R1	; Point to remote process name
	MOVAB	XWB$B_RID(R5),R3	; Point to permanent storage
	SUBB3	#2,(R1)+,R2		; Get total number of bytes minus those
					; used for format type and object number
	BLEQ	110$			; If LEQ then no username text
	MOVZBL	(R1)+,R0		; Get format type
	BEQL	110$			; If EQL then no name text
	DECL	R0			; Format type 1?
	BEQL	105$			; If EQL then yes
	DECL	R0			; Format type 2?
	BNEQ	110$			; If NEQ then no, unknown format type
	ADDL	#4,R1			; Account for UIC bytes
105$:	INCL	R1			; Skip over object number
	MOVZBL	(R1)+,R2		; Get count field
	CMPB	#XWB$C_RID,R2		; Too large?
	BLSSU	110$			; If LSSU then use
	MOVB	R2,(R3)+		; Enter count field
	MOVC3	R2,(R1),(R3)		; Enter remainder of text
					;
110$:	POPR	#^M<R1,R2,R4,R5>	; Restore regs
	MOVL	S^#SS$_NORMAL,R0	; Indicate success
	RSB				; Done



MOVCS_39:
	CMPB	#39,(R1)		; Test max string count value
	BLSSU	120$			; Br if too large
	SUBB	(R1),(R8)		; Account for space to be used
	BLSS	120$			; Br if not enough space left
	BSBW	NET$MOV_CSTR		; Else move it
	RSB				; Done

120$:	TSTL	(SP)+			; Pop return address
130$:	MOVZWL	#<NET$C_DR_ACCESS>*2,R0	; Setup failure code
	RSB
		
		.DSABL	LSB


;++
;  MOVCSFX	Move counted string to fixed length field
;  MOVCSFX_17	Move counted string to field 17 bytes long
;  MOVPRNAM	Move process name
;
;
;  The field pointed to by R1 is moved to the fixed length field pointed to by 
;  R3.  The resultant field is always stored as a counted string.  If the an 
;  error is encountered, the caller's  return address is poped off the stack 
;  and the return is to the caller's caller.
;
;  The process name field, as stored, is one of:
;
;  <1 byte count><1 byte = 0><1 byte object type  not = 0>
;  <1 byte count><1 byte = 1><1 byte = 0><I-16 process name>
;  <1 byte count><1 byte = 2><1 byte = 0><4 byte UIC><I-12 process name>
;
;  The process name source field is the same but without the count field
;
;
;  INPUTS:	R3	Pointer to the desination field
;		R2	Number of message bytes not yet accounted for
;		R1	Pointer to first byte of message
;		R0	Size of destination field (MOVCXFX only)
;
;	       (SP)	Return address of caller
;	      4(SP)	Return address of caller's caller
;
;  OUTPUTS:	R3	Pointer to first byte beyond fixed length dest. field
;		R2	Reduced by number of source field bytes moved
;		R1	Pointer to first unmoved byte in message
;		R0	1 if successfull, 0 otherwise
;
;--

;+
;   NOTE: These routines assume that the count in R2 of the remaining
;	  bytes left is a longword and that the total bytes to be moved
;	  is less than 255.
;-

		.ENABL	LSB

MOVPRNAM:				; Move process name
	PUSHR	#^M<R2,R4,R5>		; Save R4,R5; COPY R2
	PUSHL	#<NET$C_DR_FMT>*2	; Assume error
					;
	MOVL	#2,R2			; Establish min. src field size
	$DISPATCH  TYPE=B,(R1),-	; Dispatch on format type
	<-
	    <0,  5$>,-			;  non-zero object number only
	    <1, 10$>,-			;  object #0, I-16  taskname
	    <2, 20$>,-			;  object #0, 4 byte UIC, I-12 taskname
	>
	BRB	100$			; Error if unrecognized format type
5$:	TSTB	1(R1)			; Test object number
	BEQL	100$			; If EQL then format error
	BRB	30$			; Continue in common 
10$:	INCB	R2			; Inc for string count subfield
	ADDB	2(R1),R2		; Inc for string text subfield
	BRB	25$			; Continue in common
20$:	ADDB	#4+1,R2			; Inc for UIC, string count subfields
	ADDB	6(R1),R2		; Inc for string text subfield
25$:	TSTB	1(R1)			; Object number zero ?
	BNEQ	100$			; If NEQ then format error
30$:	MOVB	R2,(R3)+		; Insert length of process name
	MOVL	#XWB$C_LPRNAM-1,R0	; Establish fixed dst field size
					;  (not including the XWB$B_xPRNAM
					;   field which was just moved)
	BRB	40$			; Continue

MOVCSFX_17:
	MOVL	#17,R0			; Setup size of fixed field
MOVCSFX:
	PUSHR	#^M<R2,R4,R5>		; Save R4,R5; COPY R2
	CLRL	-(SP)			; Push error flag
					;
	MOVZBL	(R1),R2			; Get length of source string
	INCL	R2			; Update for count field
40$:	SUBL	R2,4(SP)		; Update remaining byte count
	BLSS	100$			; Error if LSS
	CMPW	R2,R0			; Is source larger then destination
	BGTRU	100$			; If GTRU then source was too long
	MOVC5	R2,(R1),#0,R0,(R3)	; Move the string, update R1,R3
					;
	POPR	#^M<R0,R2,R4,R5>	; Restore R4,R2, UPDATE R2
	INCB	R0			; Flag success 
	RSB

;
;
;  Catch the errors here
;
;
100$:	POPR	#^M<R0,R2,R4,R5>	; Restore R4,R2, UPDATE R2
					; error code in R0
	TSTL	(SP)+			; Pop caller's return address
	RSB				; Return to its caller

		.DSABL	LSB


	.SBTTL	ACT$RCV_RTS	- Receive CI message being "returned to sender"
	.SBTTL	ACT$RCV_Dx	- Recieve DI/DC message 
	.SBTTL	ACT$ABORT	- Disconnect or abort a link 
	.SBTTL	ACT$CANLNK	- Disconnect link due to user's $CANCEL
;+
;
;  The user is notified of the disconnect via the mailbox associated 
;  with the link's UCB.  All pending IRPs are completed.
;
;
;  INPUTS:  R8	Scratch
;	    R7	Scratch
;	    R6	CXB address
;	    R5	XWB address
;	    R4	Scratch
;	    R3	Scratch
;	    R2	Number of as yet unaccounted bytes in message
;	    R1	Pointer to first unparsed byte in message
;	    R0	Scratch
;
;	    Note:    R1,R2,R6 are listed above for ACT$RCV_Dx_xxx only.
;		     They carry no useful information for the other routines.
;
;  OUTPUTS: R6	Preserved
;	    R5	Preserved
;
;	    R8,R7,R4,R3,R2,R1,R0 are garbage
;
;--
ACT$CANLNK::				; Cancel I/O request
	MNEGL	#1,R2			; No disconnect mailbox message
	BRB	SET_X			; Continue
					;
ACT$RCV_RTS::				; Receive "returned to sender" CI msg
	MOVZWL #NET$C_DR_NOPATH,-	; Phony up a received disconnect code
		XWB$W_R_REASON(R5)	; and fall thru to ACT$ABORT
					; 
ACT$ABORT::				; Abort a logical link
	CLRL	R2			; No disconnect data
SET_X:	MOVZWL	 XWB$W_R_REASON(R5),R7	; Received reason already set?
	CMPW	#NET$C_DR_INVALID,R7	;
	BNEQ	 10$			; If NEQ yes 
	MOVZWL	#NET$C_DR_ABORT,R7	; Else, use abort disconnect
	MOVW	 R7,XWB$W_X_REASON(R5)	; Set disconnect reason for remote
10$:	BRB	 CMPL_DISCON		; 


ACT$RCV_Dx::
	MOVZWL	 (R1)+,R7		; Get actual disconnect reason
	MOVW	#NET$C_DR_CONF,-	; Confirm DI message for remote
		 XWB$W_X_REASON(R5)	;

CMPL_DISCON:				; Complete disconnect
	;
	;
	;    Find disconnect reason code map table entry
	;
	;
	MOVW	R7,XWB$W_R_REASON(R5)	; Setup reason code
	BSBW	NET$MAP_R_REASON	; Find mapping table entry address
	;
	;
	;    Notify user of disconnect via mailbox, if any
	;
	;
	PUSHL	R0			; Save table entry address
					;
	MOVZWL	B^REASON_W_MBX(R0),R8	; Get mailbox MSG$_xxx code
	TSTW	R2			; Any user data ?
	BLSS	40$			; If LSS then don't send a message
	UPDATE	L,R2,NDC+NDC$L_BRC(R5)	; Bump "bytes received"
30$:	BSBW	NET$SEND_CS_MBX		; Notify user
40$:	BSBW	NET$PURG_RUN		; Cleanup if exiting RUN state
					;
	POPL	R0			; Restore table entry address
	MOVZWL	B^REASON_W_DR(R0),R1	; Setup second IOSB longword value
	MOVZWL	B^REASON_W_SS(R0),R0	; Setup first IOSB longword value
	BRW	NET$CMPL_ACC		; Complete IO$_ACCESS if its still 
					; pending and return to change state


	.SBTTL	ACT$RCV_DTACK 	- DATA ACK message processing
	.SBTTL	ACT$RCV_LIACK	- INT/LI ACK message processing
	.SBTTL	NET$PIG_ACK	- Common piggy-backed ACK processing
;+
;
;  If the ACK value is within range, the subchannel block is updated. For valid
;  NAK's, the value of the 'last segment xmitted' is always updated since the
;  remote node is requesting retransmissions.  If poaaible, LNX can be advanced
;  on ACKs to prevent retransmitting unnecessarily.
;
;  The ACK is completely processed.  A user IRP for DATA or INT message may be 
;  completed as a result.  'Piggy-backed' ACKs are considered to be independent
;  from the remainder of the message.  Any errors encountered with respect to
;  the ACK number being out of range are not reported to the calling routine.
;
;  Since 'piggy-backed' ACKS are common, The following code is optimized
;  to exit with minimal processing in the expected  case that the ACK value has
;  already been seen.  Optimization also considers NAKs to be rare events.
;
;  INPUTS:  R8	 If NET$PIG_ACK   - Ptr to LSB
;		 If ACT$RCV...ACK - Garbage
;	    R7	 Scratch
;	    R6	 Msg CXB address
;	    R5	 XWB address
;	    R4	 Scratch
;	    R3	 ACK field value
;	    R2	 Number of bytes in message not yet accounted for
;	    R1	 If ACT$RCV_ACK then ptr to ACK field in message
;		 Else pointer to SEG field following the ACK
;	    R0	 Scratch
;	    SP	 Caller's return address
;	  4(SP)	 Caller's caller's return address
;
;  OUTPUTS: R8	 LSB address
;	    R7	 Garbage
;	    R4	 Garbage
;	    R3	 If ACT$RCV_ACK then garbage
;		 Else the value of SEG field following the ACK
;	    R2	 Decremented by 2 since piggy-backed ACK field is 
;	 	 optional and therefore had not yet been accounted for
;	    R1	 Advance by two bytes
;	    R0	 Garbage
;
;	    All other registers are preserved.
;
;--
		.ENABL	LSB
NET$PIG_ACK:				; Piggy-backed ACK processing
	SUBL	#2,R2			; Account for ACK field
	BLSS	10$			; If LSS then msg is too small
	BSBB	PROC_ACK		; Process the ACK
	MOVW	(R1)+,R3		; Get SEGNUM field
	BLSS	NET$PIG_ACK		; If LSS, it's another ACK
	RSB				; Done

10$:	TSTL	(SP)+			; Pop caller's address
	MOVZBL	#NETEVT$_PROERR,R7	; Setup new event
	BRW	NET$PRE_EMPT		; Pre-empt with new event
					;
ACT$RCV_LIACK::				; INT/LI ACK message processing
	MOVAB	XWB$T_LI(R5),R8		; Get LSB
	BRB	15$			; Continue
					;
ACT$RCV_DTACK::				; DATA ACK message processing
	MOVAB	XWB$T_DT(R5),R8		; Get LSB
15$:	MOVW	(R1)+,R3		; Get ACK field
	BSBB	PROC_ACK		; Process it
	SUBL	#2,R2			; Is there a 2nd ACK field
	BEQL	15$			; If EQL yes
	RSB				; Else, done

XCHAN:	MOVL	LSB$L_CROSS(R8),R8	; Get cross-channel LSB
	BSBB	20$			; Process the ACK
	MOVL	LSB$L_CROSS(R8),R8	; Get original LSB
	RSB				;
					;
PROC_ACK:				; Process ACK value
	BBS	#NSP$V_ACK_XCH,R3,XCHAN	; If BS, cross channel ACK
20$:	BICW3	#^X<F000>,R3,R7		; Get ACK'd segment number
	SUBW3	LSB$W_HAR(R8),R7,R4	; Get distance to high ACK rcv'd
	BNEQ	50$			; If EQL, we've seen it before
	BBS	#NSP$V_ACK_NAK,R3,50$	; If BS its a NAK, process it
40$:	RSB				; Done


50$:	EXTV	#0,#12,R4,R4		; MUST SIGN EXTEND
	BLSS	40$			; If LSS we saw this before
	SUBW3	R7,LSB$W_HAA(R8),R0	; Greater than 'highest ACK acceptable'
	BBS	#11,R0,40$		; If BS yes,  we can't take it (it must
					; be old or a race in "segment" flow 
					; control which will resolve itself).
					; ...branch to enforce LSB Rule 7a.
	;
	;
	;    The ACK value is 'legal', i.e, it can be processed.  
	;
	;
	MOVW	R7,LSB$W_HAR(R8)	; Advance HAR
	SUBW3	R7,LSB$W_HXS(R8),R0	; LEQ than 'highest Xmt-able seg' ?
	BBC	#11,R0,60$		; If BC yes
	MOVW	R7,LSB$W_HXS(R8)	; Else, advance HXS
					; ...enforces LSB Rule 1a.
60$:	SUBW3	R7,LSB$W_LNX(R8),R0	; Greater than 'last number xmt'd' ?
	BBS	#11,R0,70$		; If BS yes, advance LNX
					; ...enforces LSB Rule 2a.
	BBC	#NSP$V_ACK_NAK,R3,80$	; Always update LNX if legal NAK
70$:	MOVW	R7,LSB$W_LNX(R8)	; Reset "Last Number Xmtted"
80$:	ASSUME	LSB$V_LI  EQ  0		;
	BLBS	LSB$B_STS(R8),PROC_LIACK; If LBS, LS/INT subchanel

		.DSABL	LSB

	.SBTTL	PROC_DTACK	- Process of DATA ACK
;++
;
;  The DATA subchannel block is updated according to the ACK value received.  
;  Newly ACK'd segements are (conditionally) deallocated and as many user
;  transmit IRPs as possible are completed.
;
;
;  INPUTS:  R8 = DATA subchannel (LSB) pointer
;	    R7 = New HAR value
;	    R5 = XWB pointer
;	    R4 = Number of 'new' ACKs received
;	    R3 = ACK field from message
;	    R0 = Scratch
;
;  OUTPUTS: R7 = Garbage
;	    R4 = Garbage
;	    R3 = Garbage
;	    R0 = Garbage
;
;	    All other registers preserved
;
;--
PROC_DTACK:					; DATA subchannel ACK processing
	MOVQ	R1,-(SP)			; Save regs
						;
	TSTL	R4				; Any new segment's ACK'd ?
	BEQL	100$				; If EQL no, must be a NAK
	;
	;
	;    See if timed segment has been ACK'd
	;
	;
	ASSUME	XWB$V_STS_TID  EQ 0

	BLBC	XWB$W_STS(R5),40$		; If LBC timer is unowned
	BBS    #XWB$V_STS_TLI,XWB$W_STS(R5),40$	; If BS, owned by LI channel
	SUBW3	XWB$W_TIM_ID(R5),R7,R0		; Prepare 12 bit compare
	BBS    #11,R0,40$			; If BS, owner seg # is larger
	BSBW	TIMED_SEG_ACKED			; Timed segment has been ACK'd
40$:	;
	;
	;    ACK the CXB's and determine new "HXS" value
	;
	;
	BSBB	NET$ACK_XMT_SEGS		; Cleanup IRP's, CXB's, etc.
100$:	MOVL	R8,R2				; Setup LSB address
	BSBW	CALC_HXS_LUX			; Calculate new HXS value
						;
	MOVQ	(SP)+,R1			; Restore regs
	RSB					; Done


	.SBTTL	PROC_LIACK	- Process INT/LS ACK 
;++
;
;  The INT/LS subchannel state is updated according to the ACK value.  If an
;  Interrupt message which has been ACK'd then it is posted for completion.
;
;
;  INPUTS:  R8 = INT/LS subchannel (LSB) pointer
;	    R7 = New HAR value
;	    R5 = XWB pointer
;	    R4 = Number of 'new' ACKs received
;	    R3 = ACK field from message
;	    R0 = Scratch
;
;  OUTPUTS: R7 = Garbage
;	    R4 = Garbage
;	    R3 = Garbage
;	    R0 = Garbage
;
;	    All other preserved
;
;--
PROC_LIACK:					; Process INT/LS ACKs
	MOVQ	R1,-(SP)			; Save regs
						;
	CMPL	R4,#1				; Is the next msg being ACK'd
	BNEQ	100$				; If LSSU then no
	BICW   #NSP$M_FLW_INUSE,XWB$B_X_FLW(R5)	; Free the LI message slot
	BICW   #XWB$M_FLG_SLI,XWB$W_FLG(R5) 	; Nothing left to send for now
	;
	;
	;    See if timed segment has been ACK'd
	;
	;
	ASSUME	XWB$V_STS_TID  EQ 0

	BLBC	XWB$W_STS(R5),20$		; If LBC timer is unowned
	BBC    #XWB$V_STS_TLI,XWB$W_STS(R5),20$	; If BC, owned by DATA channel
	BSBW	TIMED_SEG_ACKED			; Cleanup and handoff timer 
20$:	BBC    #NSP$V_FLW_INT,XWB$B_X_FLW(R5),90$ ; If BC, not "Interrupt" msg
	;
	;
	;    "ACK" the Interrupt segment and complete the user Xmt IRP if
	;    possible.  If there is another interrupt message and the flow 
	;    control allows, then schedule the message for transmission
	;
	;
	DECB	LSB$B_X_REQ(R8)			; Remote request completed
	MOVL	LSB$L_X_PND(R8),R7		; Get the associated IRP
	MOVQ	#SS$_NORMAL,R0			; I/O completion status w/o size
	BSBB	XMT_REQ_DONE			; Complete the user I/O
90$:	BSBW	CHK_INT_AVL_R8			; Try to set XWB$V_FLG_IAVL
						;
100$:	MOVQ	(SP)+,R1			; Restore regs
	RSB					; Done


	.SBTTL	NET$ACK_XMT_SEGS  - ACK Xmt Segs, Complete User Xmt IRP's
;++
;
;  ACK each CXB and remove if from the list.  If CXB$B_CODE=0 then then 
;  deallocate it.  The next newly ACK'd CXB is always the first CXB in the 
;  list.
;
;  If the byte quota and transmit-packet-window constrains allow, complete all
;  pending user xmit IRP's.
;
;
;  INPUTS:	R8	DATA channel LSB pointer
;		R5	XWB pointer
;		R4	Number of new segments ACK'd -- must be GTR 0
;		R3-R0	Scratch
;
;  OUTPUTS:	R4-R0  Garbage
;
;		All other registers are preserved
;
;-
NET$ACK_XMT_SEGS::					; ACK new segments
	BICW   #XWB$M_FLG_WDAT,XWB$W_FLG(R5)		; Clear flag 
10$:	MOVL	LSB$L_X_CXB(R8),R0			; Get next CXB
	MOVL	CXB$L_LINK(R0),LSB$L_X_CXB(R8)		; Remove CXB from list
	DECB	LSB$B_X_CXBACT(R8)			; Account for it
	BITW   #XWB$M_PRO_SFC!XWB$M_PRO_NFC,XWB$B_PRO(R5) ; Msg flow control ?
	BNEQ	20$					; If NEQ no 
	BBC    #NSP$V_DATA_EOM,CXB$B_X_NSPTYP(R0),30$	; If BS, end of message
20$:	DECB	LSB$B_X_REQ(R8)				; One more request done
30$:	;
	;
	;    Clear the ACK-outstanding flag.  If there are no more flags set
	;    then the CXB is idle and we can either queue it to the free queue
	;    or, if we are over-quota, deallocate it.  If any flags remain set,
	;    then decrement the current CXB count since the CXB will be 
	;    deallocated when the final flag eventually clears.
	;
	;
	BICB   #CXB$M_CD_ACK,CXB$B_CODE(R0)		; "ACK" the segment
	BNEQ	40$					; If NEQ, still on some
							; datalink's xmt queue
	CMPB	LSB$B_X_CXBCNT(R8),LSB$B_X_CXBQUO(R8)	; Within CXB quota ?
	BLEQU	50$					; If GTRU, over quota
	BSBW	NET$DEALLOCATE				; Deallocate CXB in R0
40$:	DECB	LSB$B_X_CXBCNT(R8)			; CXB no longer in use
	BRB	60$					; Continue
50$:	INSQUE	(R0),XWB$Q_FREE_CXB(R5)			; Queue CXB
60$:	SOBGTR	R4,10$					; Loop for each new ACK
							;
100$:	MOVL	LSB$L_X_IRP(R8),R3			; Get first IRP
	BNEQ	CHK_XMT_DONE				; If NEQ then got one
	RSB						; Else, done



XMT_REQ_DONE:
	;
	;
	;    Setup IRP for completion, move it to 'done' queue, and attempt
	;    I/O completion.
	;
	;
	MOVQ	R0,IRP$L_IOST1(R7)			; Set IOSB image
XMT_REQ_DONE_OK:
	MOVW	IRP$W_BCNT(R7),IRP$L_IOST1+2(R7)	; Size of transfer
	SUBB	IRP$B_QUO(R7),LSB$B_X_CXBQUO(R8)	; Reclaim donated quota
	MOVAB	LSB$L_X_IRP(R8),R0			; Perpare for scan
30$:	MOVL	R0,R1					; Make a copy
	MOVL	(R0),R0					; Get next IRP
	BNEQ	30$					; If NEQ, not last
	MOVL	(R7),LSB$L_X_PND(R8)			; Remove IRP from 'PND'
	CLRL	(R7)					; Zero it's linkage
	MOVL	R7,(R1)					; Attach it to 'IRP'
	MOVL	LSB$L_X_IRP(R8),R3			; Get first IRP

CHK_XMT_DONE:						; Check Xmt IRP list
	;
	;
	;    Complete all the  xmit IRP's allowed by the CXB quota and
	;    transmit-packet-window and CXB contraints.
	;
	;    If the number of unACK'd CXB's is GTRU the current packet-window
	;    then completing the I/O now may serve to cause the user to queue
	;    another transmit request and thus consume pool for CXB's which
	;    cannot be sent.  Hence, in order to avoid using pool unnecessarily,
	;    don't complete the I/O request until the number of unACK'd CXB's
	;    is LEQU the packet-window.
	;
	;
	BBS	#XWB$V_PRO_NAR,XWB$B_PRO(R5),NET$XMT_DONE ; If BS, keep pipeline
							; as full as possible
	CMPB	LSB$B_X_CXBACT(R8),LSB$B_X_PKTWND(R8)	; Within packet-window ?
	BGTRU	200$					; If GTRU then no
110$:	CMPB	LSB$B_X_CXBACT(R8),LSB$B_X_CXBQUO(R8)	; Within CXB quota ?
	BLEQU	NET$XMT_DONE				; If LEQU yes
200$:	RSB						; Done

NET$XMT_DONE::
	PUSHL	R5					; Save XWB pointer
							;
10$:	MOVL	IRP$L_IOQFL(R3),LSB$L_X_IRP(R8)		; Detach IRP
	MOVL	IRP$L_UCB(R3),R5			; Get UCB address
	JSB	G^COM$POST				; Post IRP 
	MOVL	LSB$L_X_IRP(R8),R3			; Get next IRP
	BNEQ	10$					; If EQL then none left
							;
	POPL	R5					; Recover XWB address
	RSB						; Done


	.SBTTL	ACT$RCV_LI	- Receive INT/LS message
;++
;
;  Process a received Interrupt or Link Service message.  The format of the
;  message is given below.
;
;
;	15	       8|7		0
;	+---------------+---------------+
;	| flw ctl value	|    flags	|
;	+---------------+---------------+
;
;			 bit 0	set to turn on DATA backpressure
;			 bit 1	set to turn off DATA    "
;			 bit 2	set if 'flw ctl value' for INT/LS
;				clear if      "		for DATA
;
;  INPUTS:	R8,R7	Scratch	
;		R6	CXB address
;		R5	XWB address
;		R4,R3	Scratch
;		R2	Number of as yet unaccounted bytes in message
;		R1	Pointer to first unparsed byte in message
;		R0	Scratch
;
;  OUTPUTS:	R6	CXB address or "0" if CXB is consumed
;		R5	XWB address
;		R0	Standard VMS status code
;
;		R8,R7,R4,R3,R2,R1 are garbage, all others are unmodified
;
;--
ACT$RCV_LI::					; Receive LINK SERVICE messages
	;
	;**********************************************************************
	;
	; NOTE:	Since this buffer may be owned by the remote end of the logical
	;	link if both ends of the link are on the local node, the CXB
	;	contents, starting with the NSP header, cannot be modified.
	;		
	;**********************************************************************
	;
	BISW   #XWB$M_FLG_SIACK,XWB$W_FLG(R5)	; ALWAYS send an ACK
	MOVAB	XWB$T_LI(R5),R8			; Get INT/LS LSB
	;
	;
	;    Process optional ACK and required SEGMENT NUMBER fields
	;
	;
	MOVW	(R1)+,R3			; Get SEG field
	BGEQ	10$				; If LSS then really ACK field
	BSBW	NET$PIG_ACK			; Process the ACK field 
						; - returns to caller's caller
						;   on detected errors
10$:	PUSHL	R6				; Save reg - CXB is never 
						; consumed here
						;
	SUBW3	LSB$W_HAX(R8),R3,R0		; Distance from high ACK xmt'd
	EXTV   #0,#12,R0,R0			; MUST SIGN EXTEND
	DECW	R0				; Is this the next seq number ?
	BLSS	40$				; If LSS, we've seen this before
	BGTR	30$				; If GTR, seq # is too advanced
	BBC    #NSP$V_MSG_INT,CXB$B_R_NSPTYP(R6),50$ ; If BC, LINK SERVICE msg
	;
	;
	;    Received message is an INTERRUPT message.  Validate INTERRUPT data
	;    and move it to the user's mailbox.
	;
	;
	CMPL	R2,#16				; Check size of interrupt data
	BGTRU	30$				; If GTR then illegal
	TSTB	LSB$B_R_CXBQUO(R8)		; Can we accept this ?
	BEQL	40$				; If EQL no, link is running 
						; down (don't NAK if Phase II)
	UPDATE	L,R2,NDC+NDC$L_BRC(R5)		; Bump "bytes received"
						;
	MOVB	-(R1),-(SP)			; Backup ptr, save its contents
	MOVB	R2,(R1)				; Setup count field
	INCB	R2				; R2 should be total length
	MOVL   #MSG$_INTMSG,R8			; Setup mbx msg type
	BSBW	NET$SEND_CS_MBX			; Build and send mbx msg
	MOVB	(SP)+,(R1)			; Restore clobbered cell
						;
	CMPW	R0,#SS$_NOMBX!1			; If 'success' implicit due to 
	BEQL	20$				;  no mbx, ACK INT message but 
						;  don't flow control another
	BLBC	R0,30$				; If LBC, assume mailbox is full
	BISW   #XWB$M_FLG_SIFL,XWB$W_FLG(R5)	; Flow control another INT msg
	DECB	XWB$T_LI+LSB$B_R_CXBQUO(R5)	; And use our quota for this one
20$:	BRW	120$				; ACK the INT message
30$:	;
	;
	;    Cause a NAK to be sent if partner is phase II.
	;
	;
	BBC    #XWB$V_PRO_PH2,XWB$B_PRO(R5),40$	; If BC, not Phase II
	BISW   #XWB$M_STS_LINAK,XWB$W_STS(R5)	; Schedule the NAK message
40$:	BRW	140$				; Continue
50$:	;
	;
	;    Process received LINK SERVICE message
	;
	;
	BICB3  #NSP$M_FLW_DRV,(R1)+,R4		; Mask out driver internal bits
	CVTBL	(R1)+,R0			; Get flow value
	BBC    #NSP$V_FLW_LISUB,R4,60$		; If BC, for DATA subchannel
						;
	MOVAB	XWB$T_LI(R5),R2			; Use INT/LS subchannel
	MOVAB	B^CHK_INT_AVL,R3		; Setup action routine for LI
	BRB	70$				; Continue
						;
60$:	MOVAB	XWB$T_DT(R5),R2	  		; Get subchannel block
	MOVAB	W^NEW_DATA_FLOW,R3		; Setup action routine address
	BBS    #XWB$V_PRO_NFC,XWB$B_PRO(R5),90$	; If BS, "no flow" control
	BBS    #XWB$V_PRO_SFC,XWB$B_PRO(R5),80$	; If BS, "segment flow" control
						; Else,  "message flow" control
						;
70$:	TSTB	R0				; Check flow control value
	BLSS	30$				; Negative values are illegal
80$:	ADDB	LSB$B_X_REQ(R2),R0		; Okay to add to current count ?
	BVS	30$				; If overflow -- ignore msg 
	MOVB	R0,LSB$B_X_REQ(R2)		; Else, setup new X_REQ
90$:	;
	;
	;    Call action routine with:
	;
	;	R5 = XWB
	;	R2 = LSB
	;
	;    On return, all but R0,R1,R2,R3 must be preserved.
	;
	;
	ASSUME	NSP$V_FLW_XOFF  EQ  0		; Make sure 'XOFF' is low bit
						;
	BLBC	R4,100$				; If LBC the 'XOFF' bit is clear
	BISW   #XWB$M_FLG_WBP,XWB$W_FLG(R5)	; Backpressure our transmitter
	BBC    #NSP$V_FLW_LISUB,R4,95$		; If BC, we're on DATA sub-chan
	JSB	(R3)				; Call LI action routine now
95$:	MOVAB	B^SHRINK_XPW,R3			; Setup new action routine 
100$:	BBC    #NSP$V_FLW_XON,R4,110$		  ; If BC, 'XON' bit is clear
	BBCC   #XWB$V_FLG_WBP,XWB$W_FLG(R5),110$  ; Relax backpressure
	BBS    #XWB$V_STS_TID,XWB$W_STS(R5),110$  ; If BS timer is in use
	BSBW	CANCEL_TIMER			  ; Start timer on any msg that
						  ;  needs it -- clobbers R0
110$:	JSB	(R3)				  ; Update request count
120$:	;
	;
	;    Update LSB$W_HAX on the LI channel
	;
	;
	INCW	XWB$T_LI+LSB$W_HAX(R5)		; Update ACK value to send
	BICW   #^X<F000>,-			; Mask off junk bits
		XWB$T_LI+LSB$W_HAX(R5)		;
	MOVW	XWB$T_LI+LSB$W_HAX(R5),-	; Also the highest msg rcv'd
		XWB$T_LI+LSB$W_HNR(R5)		;
						;
140$:	MOVB   #1,R0				; Set success
						;
	POPL	R6				; Restore reg
	RSB					; Done


	.SBTTL	CHK_INT_AVL	- Conditionally set XWB$V_FLG_IAVL
	.SBTTL	CHK_INT_AVL_R8	- Conditionally set XWB$V_FLG_IAVL
;+
;
;  The routine is called after an Interrupt flow control message is received.
;  If the new flow control count is non-zero, and if there are Interrupt 
;  messages queued for transmission but with no sequence number yet assigned,
;  then and interrupt message is scheduled for transmission.
;
;
;  INPUTS:  R5	XWB address
;	    R2	INT/LS subchannel LSB address
;	    R0	Scratch
;
;  OUTPUTS: R2	Garbage
;
;	    All registers are preserved.
;
;
;-
CHK_INT_AVL_R8:					; Try to set XWB$M_FLG_IAVL
	MOVL	R8,R2				; Setup LSB pointer
CHK_INT_AVL:					; Try to set XWB$M_FLG_IAVL
	TSTB	LSB$B_X_REQ(R2)			; Any Interrupt msg requested ?
	BEQL	10$				; If EQL then no
	MOVL	LSB$L_X_PND(R2),R0		; Get pending IRP
	BEQL	10$				; If EQL then none
	BBC    #IO$V_INTERRUPT,IRP$W_FUNC(R0),10$ ; If BC, already used
	BISW   #XWB$M_FLG_IAVL,XWB$W_FLG(R5)	; Flag need to build INT msg 
10$:	RSB					; Done


	.SBTTL	SHRINK_XPW	- Shrink the DATA transmit-packet-window 
	.SBTTL	NEW_DATA_FLOW	- React to flow control msg 
;+
;
;  The DATA channels Link Subchannel Block (LSB) is processed in conjunction 
;  with the transmitter's flow control type and the transmitter's IRP queue to 
;  determine the value of the highest transmittable segment.  This value 
;  replaces LSB$W_HXS.
;
;
;  INPUTS:  R5	XWB address
;	    R3	Scratch
;	    R2	Scratch
;	    R1	Scratch
;	    R0	Scratch
;
;  OUTPUTS: R5	Preserved
;	    R3	Garbage
;	    R2	DATA channel LSB address
;	    R1	Garbage
;	    R0	Garbage
;
;	    All other registers are preserved.
;
;
;-

;
;   The following two routines are the only routines which may result in
;   lowering the value of LSB$W_HXS.
;

SHRINK_XPW:					; Shrink DATA xmt-packet-window
	MOVAB	XWB$T_DT(R5),R2			; Setup R2
	DIVB	#2,LSB$B_X_PKTWND(R2)		; Cut it in half
	BBC	#XWB$V_PRO_NAR,XWB$B_PRO(R5),20$; If BC, almost done
	DIVB3	#2,LSB$B_X_PKTWND(R2),-(SP)	; Get 1/4 of original
	ADDB	(SP)+,LSB$B_X_PKTWND(R2)	; And add it in
	BNEQ	30$				; If NEQ, okay
20$:	INCB	LSB$B_X_PKTWND(R2)		; Add 1 to prevent zero
30$:	MULB3	#3,NSP$B_ADJ_XPW,-		; Get adjustment threshold
		LSB$B_X_ADJ(R2)			; Reset threshold (trebled
						; since we were unsuccessful)
						; Fall thru
NEW_DATA_FLOW:					; Respond to new DATA_FLOW msg
	BSBB	CALC_HXS_LUX			; Calculate new HXS value 
	;
	;
	;    Since we may be reducing the LSB$W_HXS value, we cannot assume the
	;    validity of LSB Rule 4a. until the next few instructions have been 
	;    executed.  
	;
	;    Enforce LSB Rule 4a. here by reducing LSB$W_LNX if LSB$W_HXS was
	;    reduced below the current LSB$W_LNX value.
	;
	;
	SUBW3	LSB$W_LNX(R2),R1,R0		; Prepare 12 bit compare
	BBC    #11,R0,70$			; If BC, LNX leq HXS 
						; Else, HXS lss LNX  (illegal)
	MOVW	R1,LSB$W_LNX(R2)		; ...enforces LSB rule 4a.
	BISW   #XWB$M_FLG_WHGL,XWB$W_FLG(R5) 	; Set wait flag
70$:	;
	;
	;    If the timer ticking on the DATA subchannel then it needs to be 
	;    cancelled if HXS has just shrunk below the segment currently 
	;    being timed, or if the link is now backpressured off.
	;
	;
	ASSUME	XWB$V_STS_TID  EQ  0		  ; 
						  ;  
	BLBC	XWB$W_STS(R5),100$		  ; If LBC, no msg being timed
	BBS    #XWB$V_STS_TLI,XWB$W_STS(R5),100$  ; If BS, LI channel has timer 
	BBS    #XWB$V_FLG_WBP,XWB$W_FLG(R5),90$	  ; If BS, backpressured 
	SUBW3	XWB$W_TIM_ID(R5),R1,R0 		  ; Prepare for 12 bit compare
	BBC    #11,R0,100$			  ; If BC, timed i.d. is leq HXS
90$:	BSBW	CANCEL_TIMER			  ; Timer is available for any 
						  ; channel which  can use it
100$:	RSB					  ; Return


	.SBTTL	CALC_HXS...	- Calc 'highest xmt seg sendable'
;+
;
;  The DATA channels Link Subchannel Block (LSB) is processed in conjunction 
;  with the transmitter's flow control type and the transmitter's IRP queue to 
;  determine the value of the highest transmittable segment (HXS)
;
;
;  INPUTS:  R5	XWB address
;	    R3	Scratch
;	    R2	DATA channel LSB address
;	    R1	Current LSB$W_LUX value 
;	    R0	Scratch
;
;  OUTPUTS: R5	Preserved
;	    R3	Garbage
;	    R2	Preserved
;	    R1	New LSB$W_HXS value 
;	    R0	Garbage
;
;	    All other registers are preserved.
;
;
;-
CALC_HXS_LUX:				; Calc HXS, process FLG_WHGL
	BSBW	FILL_XMT_CXBS		; Try to fill some
CALC_HXS_XMT:				;
	MOVW	LSB$W_LUX(R2),R1	; Get LUX value
	BBS    #XWB$V_PRO_NFC,-		; If BS, "no flow" control
		XWB$B_PRO(R5),30$	;   (most commonly used)
	MOVZBL	LSB$B_X_REQ(R2),R3	; Get number of seg/msg requests
	BBS    #XWB$V_PRO_SFC,-		; If BS, "segment flow" control
		XWB$B_PRO(R5),20$	; Else,  "message flow" control
	;
	;
	;    Message flow control 
	;
	;    R3 contains number of 'end-of-message' segments requested but not 
	;    yet ACKed.  Find the number of the highest segment queued within
	;    this limit.
	;
	;
	MOVW	LSB$W_HAR(R2),R1	; Preset R1 assuming X_REQ was zero
					; -- this gets us to 30$ with the
					;    correct value in R1.
	MOVAB	-CXB$L_LINK -		;
		+LSB$L_X_CXB(R2),R0	; Prepare for CXB scan
	BRB	10$			; Go to end of loop
5$:	MOVL	CXB$L_LINK(R0),R0	; Get next segment
	BEQL	30$			; If EQL then none left
	BICW3  #^X<F000>,-		;
		CXB$W_X_NSPSEQ(R0),R1	; Setup 'highest seg sendable'
	BBC    #NSP$V_DATA_EOM,-	;
		CXB$B_X_NSPTYP(R0),5$	; If BC, not end of message
10$:	SOBGEQ	R3,5$			; Loop for each message requested
	BRB	30$			; Continue
20$:	;
	;
	;    Segment flow control 
	;
	;    R3 contains the number of segments requested but not yet ACKed.  
	;    Determine thenumber of the highest segment queued with this limit.
	;
	;
	ADDW	LSB$W_HAR(R2),R3	; Calc. highest seg requested
	SUBW3	R1,R3,R0		; Prepare 12 bit compare
	BBC    #11,R0,30$		; If BC, LUX leq the high seq requested
	BICW3  #^X<F000>,R3,R1		; Else use high seg requested
	SUBW	LSB$W_HAA(R2),R3	; Have we already sent a larger seg?
	BBC    #11,R3,30$		; If BC no
	MOVW	R1,LSB$W_HAA(R2)	; Else yes, we must have just received
					; negative flow control credits.  Reset
					; HAA to make appear that we've never
					; sent the excess segments.
30$:	;
	;
	;    Calculate the number of the highest segment we're allowed to send
	;    based on the transmitter-packet-window.   Use the minimum of this
	;    value and the value allowed by flow control.
	;
	;    In order to increase pipelining to the maximum extent allowed by 
	;    the network capacity (which is always changing), everytime the 
	;    packet-window was a factor in reducing HXS we decrement a counter.
	;    When that counter reaches zero we open up packet-window by 1.  If
	;    it is opened too far then some other event (e.g., a need to 
	;    retransmit) will cause it to close again.
	;
	;	NOTE:	The adjustment counter is decremented whenever HXS is
	;		greater than or EQUAL to HAR plus the currenty window
	;		value.  The EQUAL is important since HXS is also limited
	;		(see above) by the number of available segments and the
	;		number of available segments is limited by the rate of
	;		I/O completion to the user which is limited by the
	;		packet window value (refer to routine CHK_XMT_DONE).
	;
	;		Hence, the window value and the number of available
	;		segments would limit each other unless pressure is 
	;		applied to open the window when the size of the window
	;		is in equilibrium with the amount of data available.
	;
	;
	ASSUME	NSP$C_MAX_XPW  LE  254	; Make sure it can fit in a byte
					;
	MOVZBL	LSB$B_X_PKTWND(R2),R3	; Get transmit-packet-window value
	ADDW	LSB$W_HAR(R2),R3	; Add in last ACK value received
	BICW	#^X<F000>,R3		; Mask off junk bits
	SUBW3	R3,R1,R0		; Prepare for 12 bit compare
	BBS	#11,R0,40$		; If BS, tentative HXS lss HAR+window
	;
	;
	;    The packet window has restricted the amount of data which we can
	;    send.  Therefore, try to increase the packet window.
	;
	;
	MOVW	R3,R1			; Update HXS value
	CMPB	NSP$B_MAX_XPW,-		; Are we already at the maximum ?
		LSB$B_X_PKTWND(R2)	;
	BLEQU	40$			; If LEQU then yes
	DECB	LSB$B_X_ADJ(R2)		; Another need to adjust window detected
	BNEQ	40$			; If NEQ, don't adjust it yet
	MOVB	NSP$B_ADJ_XPW,-		; Reset threshold
		LSB$B_X_ADJ(R2)		; 
	INCB	LSB$B_X_PKTWND(R2)	; Open the window by one packet
40$:	;
	;
	;    Setup the new HXS value and the WHGL flag 
	;
	;
	MOVW	R1,LSB$W_HXS(R2)		; Setup new HXS
	CMPW	R1,LSB$W_LNX(R2)		; HXS < LNX ?  (LNX never > HXS)
	BEQL	200$				; If EQL no
	BICW   #XWB$M_FLG_WHGL,XWB$W_FLG(R5)	; Clear wait condition
	RSB					; Done

200$:	BISW   #XWB$M_FLG_WHGL,XWB$W_FLG(R5)	; Set "wait for HXS gtr LNX"
	RSB					; Done



		.ENABL	LSB

NEW_RCV_IRP:
	PUSHAB	W^RCV_COPY			; Setup intercept routine addr.
	MOVL	LSB$L_R_IRP(R8),R0		; Get first IRP
	BNEQ	200$				; If NEQ none
	MOVL	R3,LSB$L_R_IRP(R8)		; This IRP is the first one
60$:	MOVL	LSB$L_R_CXB(R8),R6		; Get first CXB
	BEQL	100$				; If EQL, none
	MOVL	CXB$L_LINK(R6),LSB$L_R_CXB(R8)	; Remove CXB from list
	DECB	LSB$B_R_CXBCNT(R8)		; Account for it
	MOVZWL	CXB$W_LENGTH(R6),R2		; Get amount of data
	MOVZBL	CXB$B_R_NSPTYP(R6),R4		; Get message flags
	BSBW	CXB_TO_IRP			; Attach CXB to this IRP
RCV_IRP:
	MOVL	LSB$L_R_IRP(R8),R3		; Get IRP
	BNEQ	60$				; If NEQ, got one
100$:	RSB					; Done


200$:	MOVL	R0,R1				; Copy IRP address
	MOVL	(R1),R0				; Get next IRP
	BNEQ	200$				; If NEQ, got one
	MOVL	R3,(R1)				; Else, attach this IRP
	RSB					; Done
		.DSABL	LSB


	.SBTTL	ACT$RCV_DATA	- Process rcv'd DATA message
;++   
;
;  A received data segment is processed.  If it is acceptable then the
;  IRP's message buffer (CXB) is moved to the LSB.  
;
;
;  INPUTS:	R8,R7	Scratch	
;		R6	CXB address
;		R5	XWB address
;		R4,R3	Scratch
;		R2	Number of as yet unaccounted bytes in message
;		R1	Pointer to first unparsed byte in message
;		R0	Scratch
;
;  OUTPUTS:	R6	CXB address or  "0"  if CXB is consumed
;		R5	XWB address
;		R0	Standard VMS status code
;
;		R8,R7,R4,R3,R2,R1 are garbage, all others are unmodified
;
;--
			.ENABL	LSB
OVF:						; Process overflow segment
	;
	;
	;    This is the next logical segment but we cannot take it since the
	;    receiver is in the "overflow" state.   While we are in this state,
	;    continue ACKing and discarding message segments up to and including
	;    the next "end-of-message" segment.  As soon as the next "end-of-
	;    message" is processed, exit from the "overflow" state.
	;
	;
	MOVW	R3,LSB$W_HAX(R8)		; Becomes "highest ack xmitted"
	MOVW	R3,LSB$W_HNR(R8)		; Becomes "highest number rcvd"
	BBC    #NSP$V_DATA_EOM,R0,10$		; If BC then not last message
	BICW   #XWB$M_STS_OVF,XWB$W_STS(R5)	; Clear overflow status
10$:	BRB	30$				; Cause ACK to be sent

NOT_NEXT:					; Segment arrived out of order
	;
	;
	;    This segment was not the next one expected.   If the segment number
	;    was larger than expected, it is probably due to congestion loss in
	;    the Routing Layer -- for that reason, don't send a NAK since we 
	;    may contribute to congestion at a time when the network needs to 
	;    slow down its traffic rate.   
	;
	;    If the segment number was less than expected, then it is probably
	;    a retransmission.   Send an ACK since the original one could have
	;    gotten lost due to congestion.
	;
	;
	EXTV   #0,#12,R4,R4			; Is it already buffered ?
	BLEQ	NO_BUF				; If LEQ then yes
	;    Put caching here
NO_BUF:						; Cannot take buffer
	;
	;
	;    We cannot take the buffer, either because the datalink layer needs
	;    it or because the user process is over its allowed outstanding
	;    segment count.
	;
	;    If the partner is phase II we must send a NAK.  
	;
	;
	BSBB	BACK_PRESSURE			; Request XOFF to be sent
	BBC    #XWB$V_PRO_PH2,XWB$B_PRO(R5),30$	; If BC, not Phase II
	BISW   #XWB$M_STS_DTNAK,XWB$W_STS(R5)	; Send a NAK on next ACK
30$:	BISW   #XWB$M_FLG_SDACK,XWB$W_FLG(R5)	; Cause ACK to be sent
40$:	RSB					; Done


BACK_PRESSURE:					; Back-pressure remote xmitter
	;
	;
	;    If the XWB$L_PID field is zero, then there is no current owner for
	;    this link.  It is in the RUN state trying to transmit the data
	;    message currently committed to the pipeline.  However, the fact 
	;    that we've gotten a receive that we cannot buffer means that the 
	;    link is about to deadlock since the absence of an owner process 
	;    implies that we'll never be able to buffer it.  Therefore, if the
	;    XWB$L_PID field is zero then mark the link for disconnect.
	; 
	;    NOTE:  This works in conjuction with the backround timer no-op
	;	    flow control messages in routine T_O_RUN.
	;
	;
	TSTL	XWB$L_PID(R5)			; Any owner process ?
	BNEQ	50$				; If NEQ then yes
	BSBW	NET$MARK_LINK			; Else cause link to disconnect
50$:	;
	;
	;    If the remote transmitter is already back-pressured, then cancel
	;    any attempt to toggle its state.  Else, toggle its state.
	;
	;    Back-pressure the remote transmitter ONLY if there are currently 
	;    no receive IRP's linked to the LSB (otherwise there would be no 
	;    way to know when to relax the back-pressure).
	;
	;
	TSTL	LSB$L_R_IRP(R8)			; Any IRP's ?
	BNEQ	60$				; If NEQ yes, don't send XOFF
	BICW   #XWB$M_FLG_TBPR,XWB$W_FLG(R5)	; Assume no message needed
	BBS    #XWB$V_STS_RBP, XWB$W_STS(R5),60$; If BS, already back-pressured
	BISW   #XWB$M_FLG_TBPR,XWB$W_FLG(R5)	; Send back-pressure message
60$:	RSB					; Done

		.DSABL	LSB


ACT$RCV_DATA::					; Process rcv'd DATA msg
	MOVAB	XWB$T_DT(R5),R8			; Get DATA LSB
	;
	;
	;    Process optional ACK and required SEGMENT NUMBER fields
	;
	;
	MOVW	(R1)+,R3			; Get SEG field
	BGEQ	10$				; If LSS, really ACK field
	BSBW	NET$PIG_ACK			; Parse and process the ACK
10$:	BBC    #NSP$V_SEQ_NAR,R3,15$		; If BC, no ACK suppression 
	BISB   #NSP$M_DATA_NAR,CXB$B_R_NSPTYP(R6) ; Else, allow ACK suppression
15$:	BICW   #^X<F000>,R3			; Mask off segment # junk bits
	SUBW3	LSB$W_HNR(R8),R3,R4		; Distance from 'high seg rcvd'
	CMPV   #0,#12,R4,#1			; Is this next in sequence ?
	BNEQ	NOT_NEXT			; If NEQ then no
	BBS    #XWB$V_STS_OVF,XWB$W_STS(R5),OVF	; If BS, in overflow state
	;
	;
	;    See how many CXB's NSP currently has buffered.  This does not count
	;    the ones which have been ACK'd since the session layer owns those.
	;
	;    LSB$B_R_CXBQUO goes to zero when we're running the link down.
	;
	;	NOTE:	It is not necessary to check if there is an IRP waiting
	;		for the incoming CXB since the difference between
	;		LSB$W_HAX and LSB$W_HNR is always zero if there is an
	;		IRP waiting.
	;
	;
	;
	CMPB	LSB$B_R_CXBCNT(R8),LSB$B_R_CXBQUO(R8)	; Already at limit ?
	BGEQU	NO_BUF					; If GEQU yes
	;
	;
	;    It is important to signal the transmitter to slow down (shrink its
	;    transmit-packet-window if it has one) if it starts consuming too
	;    many unACK'd buffers.  
	;
	;    The intent is to help the packet flow rate to stabilize with a
	;    minimum number of unACK'd buffers consumed at both the transmitter 
	;    and receiver ends.  The stable packet rate is not affected -- only
	;    the number of buffers required to sustain that rate.
	;
	;    The value chosen as the threshold for signalling the transmitter
	;    must be large enough to accomodate a slight variance in the 
	;    session layer receiver rate, but small enough to avoid excess 
	;    buffer consumption.  It is NOT the number of buffers consumed when
	;    the stable rate is achieved, but attempts to be an upper limit on 
	;    that value.
	;
	;
	BBS	#XWB$V_PRO_NAR,XWB$B_PRO(R5),20$; If BS, allow queue to build
						; to CXBQUO limit.
	CMPB	#2,LSB$B_R_CXBCNT(R8)		; Is this the 3rd buffer ?
	BNEQ	20$				; If NEQ no, continue
	BSBB	BACK_PRESSURE			; Back-pressure and continue
20$:	MOVB	CXB$B_R_NSPTYP(R6),R4		; Get message type
	BLBC	CXB$B_R_FLG(R6),40$		; If LBC, okay to take the CXB
	;
	;
	;    Clone a new CXB since we cannot take this one.  Complete remaining 
	;    processing via a subroutine, and return to our caller with the 
	;    original CXB pointer intact.
	;
	;
	BSBW	CLONE_RCV_CXB			; Clone a new one
	BLBS	R0,30$				; If LBS, okay
	BRW	NO_BUF				; Else, allocation failure
30$:	PUSHL	R7				; Save original CXB address
						;
	BSBB	40$				; Complete processing CXB
						;
	POPL	R6				; Recover original CXB address
	RSB					; Done

40$:	;
	;
	;    Complete setting up CXB
	;
	;
	CLRL	CXB$L_LINK(R6)			; Init the linked list pointer
	MOVB	R4,CXB$B_R_NSPTYP(R6)		; Save msg type in the CXB
	MOVW	R3,CXB$W_R_NSPSEQ(R6)		; Remember the seg #
	MOVW	R2,CXB$W_LENGTH(R6)		; Enter length of data
	SUBW3	R6,R1,CXB$W_OFFSET(R6)		; Enter offset to data
	MOVL	R1,(R6)				; Enter pointer to data 
	;
	;
	;    Consume buffer, update the receiver state.  Attach the CXB to 
	;    either an IRP if there is one, or to the LSB if there isn't.
	;
	;    Must check for a none-empty LSB CXB list first to avoid a race
	;    condition which could result in copying segments out of order.
	;
	;
	MOVW	R3,LSB$W_HNR(R8)		; Becomes new "highest # rcv'd"
	MOVL	LSB$L_R_CXB(R8),R1		; Any CXB's on LSB?
	BNEQ	90$				; If so, put this on at the end
	MOVL	LSB$L_R_IRP(R8),R3		; Get IRP
	BNEQ	CXB_TO_IRP			; If NEQ, got one
	;
	;
	;    Attach CXB to the end of the LSB list
	;
	;
	MOVAB	-CXB$L_LINK+LSB$L_R_CXB(R8),R1	; Prepare for CXB scan
90$:	MOVL	R1,R0				; Travel CXB list
	MOVL	CXB$L_LINK(R0),R1		; Get next CXB
	BNEQ	90$				; If NEQ then not end of list
	CLRL	CXB$L_LINK(R6)			; Init link-list pointer
	MOVL	R6,CXB$L_LINK(R0)		; Chain CXB to list
	CLRL	R6				; Consume CXB 
	INCB	LSB$B_R_CXBCNT(R8)		; Account for new CXB
	RSB					; Done

		.DSABL	LSB



R7_CXB_TO_IRP:					; Attach R7 CXB to IRP
	MOVL	R7,R6				; Pickup original CXB
CXB_TO_IRP:					; Attach CXB to IRP
	;
	;		Inputs			Outputs
	;		------			-------
	;	R8	LSB ptr			unchanged
	;	R7	scratch			garbage
	;	R6	CXB pointer		0 if consumed, else unchanged
	;	R5	XWB pointer		unchanged
	;	R4	Message flags		garbage
	;	R3	IRP pointer		garbage
	;	R2	Segment byte count	garbage
	;	R1	scratch			garbage
	;	R0	scratch			garbage
	;
	;
	;
	CMPW	R2,IRP$L_IOST1+2(R3)		; Enough buffer space left ?
	BLEQU	50$				; If LEQU okay, attach to IRP
	BBC	#IO$V_MULTIPLE,IRP$W_FUNC(R3),40$ ; If BC, data over-run
	;
	;
	;    The message overflows the user buffer, but the user has requested
	;    that a partial message be returned without error if needed -- the
	;    user will issue another read to continue reading the same message.
	;
	;    Clone the CXB and adjust each CXB such that one contains the first
	;    portion of the segment and the other contains the final portion.
	;    Attach the first to the IRP, and the second to the LSB.
	;
	;
	MOVW	#SS$_BUFFEROVF,IRP$L_IOST1(R3)	; Indicate "partial message"
	BSBW	CLONE_RCV_CXB_1			; Clone a new CXB
	MOVW	LSB$W_HAX(R8),CXB$W_R_NSPSEQ(R7); Backup sequence number
						;  in 'first half' CXB
	MOVZWL	IRP$L_IOST1+2(R3),R2		; Get amount 'first half' data
	MOVW	R2,CXB$W_LENGTH(R7)		; Setup 'first half' length
	BISW	#NSP$M_DATA_EOM,R4		; Trigger IRP I/O completion
	BLBC	R0,20$				; If LBC, allocation failure
	ADDL	R2,(R6)				; Update 'last half' data ptr
	ADDW	R2,CXB$W_OFFSET(R6)		; Setup  'last half' offset
	SUBW	R2,CXB$W_LENGTH(R6)		; Setup  'last half' length
	MOVL	LSB$L_R_CXB(R8),CXB$L_LINK(R6)	; Move CXB to BEGINING of list
	MOVL	R6,LSB$L_R_CXB(R8)		;
	BRB	R7_CXB_TO_IRP			; Loop to process original CXB
20$:	;
	;
	;    Failed to clone a 'last half' CXB.
	;
	;    Routine CXB_TO_IRP is called in one of two cases:  either a new
	;    CXB has arrived, or a new IRP has arrived.  In the former, the
	;    LSB$L_R_CXB list should be empty.  In the latter, the LSB$L_R_CXB
	;    list may be non-empty, and in this case we must drain it since it
	;    now has a missing CXB (the 'last half' CXB that we couldn't clone).
	;    Hence, draining the CXB list is either a no-op or it is required.
	;
	;
	;
	;    NOTE: On RCV IRP draining, always drain IRP$L_SVAPTE and move
	;	   IRP$L_IOST2 to IRP$L_SVAPTE if its negative and CHAINED is 
	;	   clear.
	;
	MOVW	LSB$W_HAX(R8),LSB$W_HNR(R8)	; LSB's CXB list is empty
	BISW	#XWB$M_STS_DTNAK,XWB$W_STS(R5)	; Next Data ACK should be a NAK
	BICW	#NSP$M_DATA_NAR,R4		; Trigger sending of ACK
	BSBW	NET$DRAIN_R_LSBCXB		; Deallocate all CXB's attached
						; to the LSB
	BRB	R7_CXB_TO_IRP			; Process original CXB
40$:	;
	;
	;    Shrink data in CXB down to what we can handle
	;
	;
	MOVW	#SS$_DATAOVERUN,IRP$L_IOST1(R3)	; Report data over-run
	BBSS	#NSP$V_DATA_EOM,R4,45$		; If BS, last seg in message
						; (set bit to trigger IRP I/O 
						;  completion)
	BISW	#XWB$M_STS_OVF,XWB$W_STS(R5)	; Else, set "overflow flag"
45$:	MOVZWL	IRP$L_IOST1+2(R3),R2		; Take as much as we can
	MOVW	R2,CXB$W_LENGTH(R6)		; Adjust length of data
50$:	;
	;
	;    Move CXB to IRP
	;
	;
	MOVL	IRP$L_SVAPTE(R3),R0		; Get attached CXB ?
	BNEQ	60$				; If NEQ, there was one there
	;
	;
	;    This is the first CXB to be attached to this IRP.
	;
	;
	MOVL	R6,IRP$L_SVAPTE(R3)		; Attach this one
	BBS    #IRP$V_CHAINED,IRP$W_STS(R3),70$	; If BS, chaining allowed
	BBS    #NSP$V_DATA_EOM,R4,70$		; If BS, this is the first and
						;  last CXB for this IRP
	BBS    #31,IRP$L_SES_BUF(R3),70$	; If BS, session buffer present
	MOVZWL	IRP$W_BCNT(R3),R1		; Get size of buffer area needed
	MOVAB	 NSP$C_HSZ_DATA -		; Add in overhead
		+TR3$C_HSZ_DATA -		;
		+CXB$C_OVERHEAD(R1),R1		;
	BSBW	NET$ALONONPAGED			; Allocate buffer
	BLBC	R0,200$				; If LBC, failed
	MOVL	R2,IRP$L_SES_BUF(R3)		; Save buffer address
	MOVAB	CXB$T_X_DATA(R2),(R2)		; Stuff address of the data area
	MOVL	(R2),IRP$L_IOST2(R3)		;  in both the CXB and the IRP
	MOVZWL	CXB$W_LENGTH(R6),R2		; Recover amount of data in CXB
	BRB	70$				; Continue
60$:	;
	;
	;    Attach new CXB to end of IRP's CXB chain
	;
	;
	MOVL	R0,R1				; Copy CXB address
	MOVL	CXB$L_LINK(R0),R0		; Get next CXB
	BNEQ	60$				; If NEQ, contine
	MOVL	R6,CXB$L_LINK(R1)		; Attach CXB
70$:	CLRL	CXB$L_LINK(R6)			; Terminate linked list
	BSBB	150$				; Update state variables etc.
	CLRL	R6				; Indicate "CXB consumed"
100$:	RSB					; Done

150$:	;
	;
	;    CXB has been attached to the IRP.  Update state variables,
	;    byte counts, and schedule an ACK message.
	;
	;
	UPDATE	L,R2,NDC+NDC$L_BRC(R5)		; Add to total for remote node
	MOVW	CXB$W_R_NSPSEQ(R6),LSB$W_HAX(R8); Update "highest ack to xmit"
	BBS	#NSP$V_DATA_NAR,R4,160$		; If BS, no need to send ACK yet
	BISW	#XWB$M_FLG_SDACK,XWB$W_FLG(R5)	; Cause ACK to be sent 
160$:	INCB	IRP$B_CXBCNT(R3)		; Bump CXB count
	MOVL	IRP$L_IOST2(R3),4(R6)		; Save user VA
	ADDL	R2,IRP$L_IOST2(R3)		; Update user VA pointer
	SUBW	R2,IRP$L_IOST1+2(R3)		; Consume bytes
	;
	;
	;    If the IRP CXB count is at its threshold, then dispatch to the
	;    action routine to move the data to the user buffer.  Since moving
	;    the data may involve going to IPL 2, the XWB may not be in the
	;    RUN state upon return.
	;
	;
	BBS	#NSP$V_DATA_EOM,R4,RCV_DONE	; If BS, last CXB for this IRP
	CMPB	IRP$B_CXBCNT(R3),NSP$B_R_CXBTHR	; Too many CXB accumulating?
	BGEQU	RCV_COPY			; If GEQU yes, copy to them
						; to the user's buffer
	RSB					; Done

200$:	CLRL	IRP$L_SVAPTE(R3)		; Detach CXB
	RSB					; Done



NET$RCV_DONE::
	BLBS	IRP$L_IOST1(R3),RCV_DONE	; Branch if successful
	BSBW	NET$DRAIN_R_IRPCXB		; Drain all attached CXB's
RCV_DONE:
	;
	;    Detach IRP from LSB.  If there is a Session layer buffer attached
	;    to the IRP (this only happens on non-chained buffer ALTSTART 
	;    requests), then the CXB data must first be moved into it.
	;
	;
	BBC	#31,IRP$L_SES_BUF(R3),30$	; If BC, no attached buffer
	BBC	#31,IRP$L_PID(R3),300$		; If BC, it's a bug
	BSBB	RCV_COPY			; Move CXB data to buffer
	MOVL	LSB$L_R_IRP(R8),R3		; Recover IRP
	BBS	#31,IRP$L_SVAPTE(R3),300$	; If BS bug, CXB's not copied
	MOVL	IRP$L_SES_BUF(R3),IRP$L_SVAPTE(R3) ; Move attached buffer 
30$:	MOVL	(R3),LSB$L_R_IRP(R8)		; Detach IRP
	BEQL	50$				; If EQL, this is the last IRP
	PUSHAB	RCV_IRP				; Cause return to intercept 
						; routine
50$:	;
	;
	;    Send IRP to I/O completion
	;
	;
	SUBW	IRP$L_IOST1+2(R3),IRP$W_BCNT(R3); Calc xfer size for IOPOST 
	MOVW	IRP$W_BCNT(R3),IRP$L_IOST1+2(R3); Store xfer size for IOSB
	CLRL	IRP$L_IOST2(R3)			; Zero second IOSB longword
	MOVL	IRP$L_UCB(R3),R5		; Get UCB address
	JSB	G^COM$POST			; Another packet for the heap
	MOVAB	-XWB$T_DT(R8),R5		; Recover XWB
	RSB					; Done

300$:	BUG_CHECK  NETNOSTATE,FATAL



		.ENABL	LSB

RCV_COPY2:
	BLBC	R11,NET$QAST			; If LBC, can't go to IPL 2
RCV_COPY1:
	;
	;
	;    Detaching the CXB is essential since we may go to IPL 2 to probe 
	;    the user buffer and an IPL 8 event may cause all CXB's, IRP's etc 
	;    to be deallocated.
	;
	;
	MOVL	CXB$L_LINK(R6),IRP$L_SVAPTE(R7)	; Detach it
	DECB	IRP$B_CXBCNT(R7)		; Account for it
	;
	;
	;    Get user VA descriptor, copy data from CXB
	;
	;
	MOVZWL	CXB$W_LENGTH(R6),R2		; Get number of bytes
	MOVL	4(R6),R1			; Get user address
	BSBW	COPY_DATA			; Update desc., copy data
	BLBC	R0,200$				; If LBC, error
	MOVL	R6,R0				; Prepare for deallocation
	BSBW	NET$DEALLOCATE			; Deallocate the block
RCV_COPY:
	;
	;    
	;    If there is an IRP and its PID field is non-negative, then the
	;    IRP comes from QIO and we must get back to the user process at
	;    IPL 2 to copy the data into the user buffer.
	;
	;    If the PID is negative the IRP came from ALTSTART. If a destination
	;    buffer does not exists, then simply exit without copying the CXBs.
	;
	;
	MOVL	LSB$L_R_IRP(R8),R7		; Get first IRP
	BEQL	100$				; If EQL, none
	MOVL	IRP$L_SVAPTE(R7),R6		; Get next CXB
	BEQL	100$				; If EQL, none
	BBC	#31,IRP$L_PID(R7),RCV_COPY2	; If BC, must go to IPL 2
	BBS	#31,IRP$L_SES_BUF(R7),RCV_COPY1	; If BS, there's a buffer to 
						; copy CXB's into
100$:	RSB					; Else, ignore request	


200$:	CMPL	LSB$L_R_IRP(R8),R7		; Same IRP still there ?
	BNEQ	210$				; If NEQ, we're done
	MOVZWL	R0,IRP$L_IOST1(R7)		; Setup status
	CLRW	IRP$W_BCNT(R7)			; Must zero byte-count
210$:	RSB					; Done

		.DSABL	LSB



NET$QAST::					; Schedule Special Kernel AST
	TSTL	XWB$L_PID(R5)			; XWB still assigned to process?
	BEQL	100$				; If EQL, no
	BISW	#XWB$M_STS_ASTREQ,XWB$W_STS(R5)	; Indicate AST request
	BBSS	#XWB$V_STS_ASTPND,XWB$W_STS(R5),100$ ; Request use of AST block
						;
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>		; Save regs
	MOVL	#1,R4				; Use I/O completion priority
	BSBB	200$				; Fork to get below IPL$_SYNC
	POPR	#^M<R0,R1,R2,R3,R4,R5>		; Recover XWB address
						;
100$:	RSB					; Done

200$:	MOVAB	XWB$$(R5),R5			; Goto AST block context
	MOVB	#IPL$_QUEUEAST,11(R5)		; Setup fork level
	JSB	G^EXE$FORK			; Fork
	MOVL	R4,R2				; Get priority boost class
	MOVB	#^X<80>,ACB$B_RMOD(R5)		; Setup Special Kernel mode
	MOVAB	B^NET$KAST,ACB$L_KAST(R5)	; Setup AST address
	MOVL	-XWB$$+XWB$L_PID(R5),ACB$L_PID(R5) ; Setup PID
	BEQL	NET$KAST			; If EQL, link is not accessed
	JMP	G^SCH$QAST			; Queue the Kernel AST

NET$KAST::					; Special Kernel AST service
	PUSHR	#^M<R6,R7,R8,R9,R10,R11>	; Save regs
	DSBINT	#NET$C_IPL			; Go to sychronizing IPL
  						;
	MOVAB	-XWB$$(R5),R5			; Got XWB context
	MOVAB	XWB$T_DT(R5),R8			; Get LSB
	CLRL	R11				; Say "can't go to IPL 2"
	MOVL	XWB$L_PID(R5),XWB$$+ACB$L_PID(R5) ; Setup PID, again
	BEQL	5$				; If EQL, no longer accessed
	INCL	R11				; Say "okay to go to IPL 2"
5$:	PUSHL	LSB$W_LUX(R8)			; Save current "last used xmt #"
						;
	BICW	#XWB$M_FLG_WDAT,XWB$W_FLG(R5)	; Init wait for buffer flag
	BICW	#XWB$M_STS_ASTREQ,XWB$W_STS(R5)	; Clear request flag
10$:	BBC	#XWB$V_FLG_SDT,XWB$W_FLG(R5),20$; If BC, not in RUN state
	BSBW	XMT_COPY			; Process transmitter needs
	BSBW	RCV_COPY			; Process receiver needs
20$:	BBSC	#XWB$V_STS_ASTREQ,-		; If BS, new AST request came in
		 XWB$W_STS(R5),10$		; while we we're at IPL 2
	BICW	#XWB$M_STS_ASTPND,XWB$W_STS(R5)	; Release AST block
						;
	POPL	R0				; Get former LUX value
	BBC	#XWB$V_FLG_SDT,XWB$W_FLG(R5),30$; If BC, not in RUN state
	CMPW	R0,LSB$W_LUX(R8)		; Has it changed ?
	BEQL	30$				; If EQL, no
	MOVL	R8,R2				; Copy LSB address
	BSBW	CALC_HXS_XMT			; Calc new HXS value
30$:	BSBW	NET$SCH_MSG			; Schedule new work
						;
	ENBINT					; Restore IPL
	POPR	#^M<R6,R7,R8,R9,R10,R11>	; Restore regs
	RSB					; Done



FILL_XMT_CXBS:
	MOVL	LSB$L_X_PND(R2),R0	; Get pending IRP
	BEQL	30$			; If EQL none
	CMPB	LSB$B_X_CXBACT(R2),-	; Active CXB count within packet window?
		LSB$B_X_PKTWND(R2)	; 
	BGTRU	30$			; If GTRU, no
10$:	CMPB	LSB$B_X_CXBACT(R2),-	; Active CXB count within quota ?
		LSB$B_X_CXBQUO(R2)	; 
	BGEQU	30$			; If GEQU, can't allocate any more CXB's
	BLBS	R11,30$			; If LBS, okay to go to IPL 2
	BBS	#31,IRP$L_PID(R0),50$	; If BS then ALTSTART, don't need IPL 2
					;
	BSBW	NET$QAST		; Startup AST 
30$:	RSB				; Done

50$:	PUSHR	#^M<R1,R2,R3,R4,R6,R7,R8>	; Save regs
	MOVL	R2,R8				; Setup LSB pointer
	BSBB	XMT_COPY			; Build xmt segments
						;; Any trouble resetting HGL ?
	POPR	#^M<R1,R2,R3,R4,R6,R7,R8>	; Save regs
	RSB					; Done


	.ENABL	LSB

	ASSUME	IRP$L_IOQFL  EQ  0		; IRP queue linkage is offset 0

300$:	;
	;
	;    Copy failed.  The CXB has been deallocated.
	;
	;
	DECB	LSB$B_X_CXBCNT(R8)		; Account for lost CXB
	CMPL	R7,LSB$L_X_PND(R8)		; IRP still there ?
	BNEQ	100$				; If NEQ, no
	CLRW	IRP$W_BCNT(R7)			; Zero eventual transfer size
	BSBW	XMT_REQ_DONE			; Move to completion queue
						; with status in R0
100$:	RSB					; Done

400$:	BRW	NET$QAST			; Startup kernel mode ast

200$:	BISW	#XWB$M_FLG_WDAT,XWB$W_FLG(R5)	; Flag need to get try again
	RSB					; Return with LBC in R0

XMT_COPY1:
	BLBC	R0,300$				; If LBC, then error
	;
	;
	;    Enter sequence number.
	;
	;
	ADDW3	#1,LSB$W_LUX(R8),R1		; Get new 'last used seq #'
	BICW	#^X<F000>,R1			; Trim to 12 bits
	MOVW	R1,CXB$W_X_NSPSEQ(R6)		; Enter it into message
	MOVW	R1,LSB$W_LUX(R8)		; Store new LUX
	;
	;
	;    Attach CXB and request permission to transmit it.
	;
	;
	MOVB	#CXB$M_CD_ACK,CXB$B_CODE(R6)	; Say "not yet ACK'ed"
	MOVAB	-CXB$L_LINK+LSB$L_X_CXB(R8),R0	; Prepare for scan
10$:	MOVL	R0,R1				; Save last pointer value
	MOVL	CXB$L_LINK(R1),R0		; Get next CXB
	BNEQ	10$				; If NEQ, not last
	CLRL	CXB$L_LINK(R6)			; Zero this CXB's link
	MOVL	R6,CXB$L_LINK(R1)		; Link it into end of chain
	INCB	LSB$B_X_CXBACT(R8)		; Account for it
						;
	TSTW	IRP$L_IOST1+2(R7)		; Any data left ?
	BNEQ	XMT_COPY			; If NEQ, yes
	BSBW	XMT_REQ_DONE_OK			; Move request for completion
XMT_COPY:					;
	MOVL	LSB$L_X_PND(R8),R7		; Get next IRP
	BEQL	100$				; If EQL, none left
	BLBS	R11,30$				; If LBS, okay to goto IPL 2
	BBC	#31,IRP$L_PID(R7),400$		; If BC not ALTSTART, must
30$:	;
	;
	;    Get a free CXB.  Expand CXB list if needed and if possible.
	;
	;
	REMQUE	@XWB$Q_FREE_CXB(R5),R6		; Get next CXB
	BVC	50$				; If VC, got one
	CLRL	R6				; Init pointer
	CMPB	LSB$B_X_CXBCNT(R8),-		; Can we allocate another CXB ?
		LSB$B_X_CXBQUO(R8)		;
	BGEQU	100$				; If GEQ, no
	MOVZWL	XWB$W_REMSIZ(R5),R1		; Get remote size
						;; trim upon ENT_RUN if needed
	MOVAB	 NSP$C_HSZ_DATA -		; Add in overhead
		+TR3$C_HSZ_DATA -		;
		+CXB$C_OVERHEAD(R1),R1		;
	JSB	G^EXE$ALONONPAGED		; Allocate the buffer
	BLBC	R0,200$				; If LBC then allocation failure
	MOVL	R2,R6				; Setup CXB pointer
	MOVB   #DYN$C_CXB,CXB$B_TYPE(R6)	; Setup block type
	MOVW	R1,CXB$W_SIZE(R6)		; Setup the size
	INCB	LSB$B_X_CXBCNT(R8)		; Account for CXB
50$:	;    
	;
	;    Enter message type code.  Process 'bom' and 'eom' flags.
	;
	;
	ASSUME 	NSP$C_MSG_DATA  EQ  0 		; 'Data' message type code for 
	ASSUME	NSP$V_DATA_BOM  EQ  LSB$V_BOM
	ASSUME	NSP$V_DATA_EOM	EQ  LSB$V_EOM
						;
	BICB3	#^C<LSB$M_BOM>,LSB$B_STS(R8),-	; Enter message type code
		CXB$B_X_NSPTYP(R6)		;
	BICB	#LSB$M_BOM,LSB$B_STS(R8)	; Preset next type code
	MOVZWL	XWB$W_REMSIZ(R5),R2		; Get segment size
	CMPW	R2,IRP$L_IOST1+2(R7)		; More data left after this ?
	BLSSU	70$				; If LSSU, more data left
	MOVZWL	IRP$L_IOST1+2(R7),R2		; Else, take it all
	BBS	#IO$V_MULTIPLE,IRP$W_FUNC(R7),70$  ; If BS, not 'end of msg'
	BISB	#NSP$M_DATA_EOM,CXB$B_X_NSPTYP(R6) ; Set 'end of message flag'
	BISB	#LSB$M_BOM,LSB$B_STS(R8)	   ; Preset next type code
70$:	;
	;
	;    Update user VA descriptor in IRP, copy data into CXB
	;
	;
	MOVAB	CXB$T_X_DATA(R6),4(R6)		; Setup destination pointer
	MOVL	IRP$L_IOST2(R7),R1		; Get address of user data
	MOVL	R1,(R6)				; Save user VA
	MOVW	R2,CXB$W_LENGTH(R6)		; Save # user bytes in CXB
	ADDL	R2,IRP$L_IOST2(R7)		; Update address
	SUBW	R2,IRP$L_IOST1+2(R7)		; Consume bytes
	PUSHAB	XMT_COPY1			; Setup return address
						; fall thru to COPY_DATA
		.DSABL	LSB


COPY_DATA:
	BBS	#31,IRP$L_PID(R7),70$		; If BS, then 'ALTSTART'
	;
	;
	;    Probe the user buffer.  The probing code relies on the fact that
	;    the first and last pages in the probe range are simultaneously
	;    probed -- hence we can probe two pages at a time.
	;
	;    Enter data into message.  Since we may be at IPL 2, it is possible
	;    that an NET$C_IPL event could cause the link to break and the
	;    IRP's to be cleaned up.  Therefore, the IRP cannot be referenced
	;    once we go below NET$C_IPL.
	;
	;
	EXTZV	#0,#2,IRP$B_RMOD(R7),R4		; Get request access mode
	CVTWL	#-512,R3			; Set addition constant
	ADDL3	R2,R1,R0			; Calc end of buffer
	BICW	#VA$M_BYTE,R1			; Must go to begining of page
						; (since two pages worth of data
						; could otherwise span 3 frames)
	SUBL	R1,R0				; Calc # of bytes to probe
	SETIPL	#IPL$_ASTDEL			; Allow paging
						;
30$:	BBC	#IRP$V_FUNC,IRP$W_STS(R7),50$	; If BC, IO$_WRITELBLK
						; (IRP$W_STS is remains valid
						;  even if IRP has been sent to
						;  IOPOST).
	PROBEW	R4,R0,(R1)			; Can user VA be written ?
	BNEQ	60$				; If NEQ, yes
	BRB	200$				; Report access violation
						;
50$:	PROBER	R4,R0,(R1)			; Can user VA be read ?
	BEQL	200$				; If EQL no, report error
60$:	SUBL	R3,R1				; Update address of buffer
	MOVAW	(R0)[R3],R0			; Shrink total by 2 pages
	BGTR	30$				; If GTR, more to probe
						;
70$:	MOVC3	R2,@(R6),@4(R6)			; Enter data
						;
100$:	SETIPL	#NET$C_IPL			; Go back to synchronizing IPL
	MOVAB	-XWB$T_DT(R8),R5		; Recover XWB address
	BBC	#XWB$V_FLG_SDT,XWB$W_FLG(R5),210$ ; If BC, not in RUN state
	MOVB	#1,R0				; Say "success"
	RSB					; Done



200$:	;
	;
	;    Access violations are fatal.  We have no choice but to break the 
	;    link since a portion of the user's buffer may have already been
	;    transmitted.
	;
	;
	SETIPL	#NET$C_IPL			; Go back to synchronizing IPL
	MOVAB	-XWB$T_DT(R8),R5		; Recover XWB address
	BISW	#XWB$M_FLG_BREAK,XWB$W_FLG(R5)	; Cause link to break
	PUSHL	#SS$_ACCVIO			; Store error status
	BRB	220$				; Continue
						;
210$:	PUSHL	#SS$_ABORT			; Store error state
220$:	MOVL	R6,R0				; Prepare for deallocation
	CLRL	R6				; Clear former CXB pointer
	BSBW	NET$DEALLOCATE			; Deallocate the block
	POPL	R0				; Pickup error status
	RSB					; Done


	.SBTTL	CLONE_RCV_CXB	- Clone a copy of a rcv'd CXB
;+
;
;  INPUTS:	R7	Scratch
;		R6	Current CXB address
;		R2	Bytes left in message
;		R1	Current message pointer
;		R0	Scratch
;
;  OUTPUTS:	R7	Old CXB address
;		R6	New CXB address if successful
;			otherwise unchanged
;		R1	Updated message pointer if successful
;			garbage otherwise
;		R0	Low bit set if successful
;			Low bit cleared otherwise
;
;		All other registers are preserved
;
;-
CLONE_RCV_CXB_1:				;
	MOVL	(R6),R1				; Get pointer to data
CLONE_RCV_CXB:					;
	;
	;
	;    If we cannot take the buffer, then we can only write in the 
	;    CXB$x_R_xxx fields since that is the "datalink" area and the rest
	;    of the CXB is off limits to us.
	;
	;    NOTE: If this is a local-local link then this is the same CXB as
	;	   on some LSB CXB list and modifying anything before CXB$T_DLL
	;	   or after CXB$C_HEADER could be dangeous.  Remember that for
	;	   local-local links the flag is set in the CXB which prohibits
	;	   its being consumed here.
	;
	;
	PUSHR	#^M<R2,R3,R4,R5,R8>	; Save regs
					;
	MOVL	R6,R7			; Copy CXB address
	MOVL	R1,(R7)			; Enter pointer to data
	MOVZWL	R2,R2			; Clear out high order bits
	ADDL	#CXB$C_TRAILER,R2	; Add in required trailer
	ADDL	R2,R1			; Calculate end address
	SUBL	R7,R1			; Get total used buffer size
	MOVL	R1,R8			; Save a copy
	JSB	G^EXE$ALONONPAGED	; Allocate buffer
	BLBC	R0,10$			; If LBC then error
	MOVL	R2,R6			; Setup new CXB address
	MOVC3	R8,(R7),(R6)		; Copy relavent data
	MOVW	R8,CXB$W_SIZE(R6)	; Reset size -- corrupted by MOVC
	SUBL3	R7,(R7),R1		; Get offset to data
	ADDL	R6,R1			; Make it a pointer in new CXB
	MOVL	R1,(R6)			; Store it
	CLRB	CXB$B_R_FLG(R6)		; Clear all flags
	MOVL	#1,R0			; Success
					; 
10$:	POPR	#^M<R2,R3,R4,R5,R8>	; Restore regs
	RSB				; Done




NET$DRAIN_R_IRPCXB::
10$:	MOVL	IRP$L_SVAPTE(R3),R0		; Get attached CXB, if any
	BEQL	100$				; If EQL, done
	MOVL	CXB$L_LINK(R0),IRP$L_SVAPTE(R3)	; Remove CXB from list
	DECB	IRP$B_CXBCNT(R3)		; Account for its loss
	BSBW	NET$DEALLOCATE			; Deallocate the block
	BRB	10$				; Loop
100$:	RSB					; Done


NET$DRAIN_R_LSBCXB:
						;
10$:	MOVL	LSB$L_R_CXB(R8),R0		; Get attached CXB, if any
	BEQL	100$				; If EQL, done
	MOVL	CXB$L_LINK(R0),LSB$L_R_CXB(R8)	; Remove CXB from list
	DECB	LSB$B_R_CXBCNT(R8)		; Account for its loss
	BSBW	NET$DEALLOCATE			; Deallocate the block
	BRB	10$				; Loop
100$:	RSB					; Done


	.SBTTL	NSP$SOLICIT  	- Solicit permission to transmit
;+
;
;  It is asssumed that XWB$V_STS_SOL has just be set prior to the call to this
;  routine.
;
;
;  INPUTS:	R5	XWB address
;		R4-R0	Scratch
;
;		R5-R0	Garbage
;
;		All other registers are preserved.
;
;
;-
NSP$SOLICIT::				; Solicit xmit permission from Trasnport
	;
	;
	;    Solicit permission from Transport to transmit a message.  Note that
	;    the request could suspend us indefinitely.  The call is made with:
	;
	;
	; 	R5	Fork block address.
	;		The FPC,FR3,FR4 fields are all scratch and must not
	;		be modified by while Transport owns the fork block.
	;	R4	Destination node address 
	;	R3	I.d. of LPD to xmit over 
	;		Zero if Transport is to choose the LPD 
	;	R2	RCB address
	;	R1,R0	Scratch	
	;
	;	(SP)	Return address of caller
	;      4(SP)	Return address of caller's caller
	;
	;
20$:	MOVL	XWB$L_VCB(R5),R2		; Get RCB address
	MOVZWL	XWB$W_PATH(R5),R3		; Get path i.d. for xmt 
	MOVAB	XWB$Q_FORK(R5),R5		; Switch to fork block context
	PUSHAB	B^QUICK_SOL			; Setup return address
	MOVZBL	W^XWB$B_ADJ_INX-XWB$Q_FORK(R5),R4 ; Setup adjacency index
;;	BEQL	30$				; If EQL, none
;;	BRW	QRL$SOLICIT			; Call quick routing layer
30$:	MOVZWL	XWB$W_REMNOD-XWB$Q_FORK(R5),R4	; Setup remote node address
	BRW	TR$SOLICIT			; Call Transport

QUICK_SOL:
	;
	;
	;   Return (or called) from Transport with:
	;
	;	R7,R6	Scratch
	;	R5	Fork block address
	;	R4	Scratch
	;	R3	Not available -- must be saved/restored
	;	R2	RCB address
	;	R1	Scratch
	;	R0	Low bit set if permission granted
	;		Low bit clear if permission denied
	;
	;
	;
	PUSHR  #^M<R3,R8,R9,R10,R11>		; Save regs
						;
	CLRL	R11				; Say "can't go to IPL 2"
	MOVAB  -XWB$Q_FORK(R5),R5		; Switch to XWB context
	BICW   #XWB$M_STS_SOL,XWB$W_STS(R5)	; Mark fork block idle
	FFS    #0,#16,XWB$W_FLG(R5),R4		; Find something to do
	MOVAB	W^NET$IO_STATUS,R9		; Default I/O end-action routine
	BSBB	BLD_DISPATCH			; Dispatch to build message
	BLBC	R0,200$				; If LBC then no msg was built
	BUMP	L,NDC+NDC$L_PSN(R5)		; Update "packets sent"
	UPDATE	L,R1,NDC+NDC$L_BSN(R5)		; Update "user bytes sent"
	;
	;
	;    Build the route header
	;
	;
	MOVL	XWB$L_PTR_RTHD(R5),R2		; Get route-header pointer
	MOVAB	CXB$B_X_NSPTYP(R6),R1		; Setup pointer to msg NSP header
	SUBL	-4(R2),R1			; 
	SUBL3	R1,R3,R7			; Setup total message size
						;
	PUSHR	#^M<R0,R1,R5>			; Save regs
	MOVC3	-4(R2),(R2),(R1)		; Move in the route-header
	POPR	#^M<R0,R1,R5>			; Save regs
						;
	MOVL	R9,R2				; Setup 'end-action' routine 
	BNEQ	120$				; If NEQ then okay
	MOVAB	W^NET$IO_STATUS,R2		; Use standard status routine
	BISB   #TR3$M_RTFLG_RQR,(R1)		; 
						;
120$:	POPR   #^M<R3,R8,R9,R10,R11>		; Restore status and saved regs
	;
	;
	;
	;    On return, the CXB and registers are setup as follows:
	;
	;
	;   +---------------+
	;   |   standard    |	11 bytes long.  CXB$L_FLINK and CXB$L_BLINK may
	;   |     VMS	    |	be used by the Transport layer.  CXB$W_SIZE 
	;   | buffer header |	must be correct.  CXB$B_TYPE must be DYN$C_CXB.
	;   +---------------+
	;   |		    |	Starts with CXB$B_CODE (byte 11) and continues
	;   |      ECL	    |	to CXB$C_LENGTH.  This area is read-only to
	;   |   pure area   |	Transport and below.  It cannot even be
	;   |               |	saved/restored.
	;   +---------------+
	;   |    Datalink   |	Starts at CXB$C_LENGTH and is at least 
	;   |     Layer	    |	CXB$C_DLL bytes long.  Used by the datalink for
	;   |  impure area  |	protocol header or state information.
	;   +---------------+
	;   |		    |	
	;   .    body of    .	Must be quadword aligned and starting no sooner
	;   .    message    .   than CXB$C_LENGTH + CXB$C_DLL (= CXB$C_HEADER)
	;   |		    |
	;   +---------------+
	;   |    Datalink   |	Used by the datalink layer for protocol (e.g.,
	;   |     Layer     |	checksum) or state information.  Must be at
	;   |  impure area  |	least CXB$C_TRAILER in length.
	;   +---------------+
	;
	;
	;	R7	Size of message
	;	R6	CXB address
	;	R5	Garbage
	;	R4	0 if "quick solicit" not requested
	;		Else, pointer to request block (XWB fork block) with
	;		FRK$L_FPC  pointing to the "quick solicit" routine
	;	R3	IRP address -- unmodified from call
	;	R2	Address of End-action routine to call on I/O competion
	;	R1	Ptr to 1st byte in standard Phase III route-header
	;	R0	Low bit set   -	if message is to be xmitted
	;		Low bit clear -	if no message to xmit.  In this case
	;				R7-R4,R2,R1 contain garbage.
	;
	;
	;
	FFS    #0,#XWB$V_FLG_CLO+1,XWB$W_FLG(R5),R4  ; Get next work bit
	BBC	R4,W^NET$GL_WORKBITS,300$	; If BC, no work needed
	BBSS   #XWB$V_STS_SOL,XWB$W_STS(R5),310$; If BS, fork block in-use
	MOVAB	W^QUICK_SOL,XWB$L_FPC(R5)	; Setup "quick solicit" return
	MOVAB	XWB$Q_FORK(R5),R4		; Say "quick solicit requested"
	RSB					; Return to Transport


200$:	POPR   #^M<R3,R8,R9,R10,R11>		; Restore status and saved regs
300$:	BBC    #XWB$V_STS_DIS,XWB$W_STS(R5),310$; If BC, disconnect not pending
						;
	PUSHL	R0				; Save R0
	BSBW	NET$CHK_X_IDLE			; Ok to restart disc. sequence?
	BLBC	R0,305$				; If LBC no, XWB is not idle
	BSBW	NET$FORK			; Fork to resume disconnect
						; (return with LBS in R0)
305$:	POPL	R0				; Restore R0
						;
310$:	CLRL	R4				; Say "quick solicit not wanted"
	RSB					; Return to Transport


	.SBTTL	BLD_DISPATCH	- Dispatch to build message
;+
;
;  Dispatch with:
;
;	R9	Default end-action routine (NET$IO_STATUS) address
;	R8-R6	Scratch
;	R5	XWB address
;	R4	XWB$W_FLG work bit
;	R3-R1	Scratch
;	R0	LBS if permission granted to transmit
;		LBC if permission denied
;
;  On return:
;
;	R9	Address of NET$IO_STATUS or some other end-action routine
;	R6	Address of CXB containing message to be transmitted
;	R3	Address of first byte beyond the message text
;	R1	User bytes entered into message
;	R0	1 if message is to be xmitted,
;		0 otherwise
;
;	R8,R7,R4,R2  are clobbered, all others are unmodified.
;
;-
BLD_DISPATCH:
	BLBC	R0,DENIED			; If LBC then we were denied
						; permission to transmit
	;
	;
	;    We have been given permission to transmit. 
	;
	;
	$DISPATCH  R4,-				; Case on work bit
	<-
	    <XWB$V_FLG_CLO,	NET$RET_SLOT>,-
	    <XWB$V_FLG_BREAK,   BREAK>,-
	    <XWB$V_FLG_SCD,	BLD_CD>,-
	    <XWB$V_FLG_SIACK,   BLD_LIACK>,-
	    <XWB$V_FLG_SDACK,   BLD_DTACK>,-
	    <XWB$V_FLG_SLI,	BLD_LI>,-
	    <XWB$V_FLG_SDT,     BLD_DAT>,-
	>
	BRB	NONE				; Continue

DENIED:	;
	;
	;    Permission to Xmit has been denied
	;
	;
	$DISPATCH	R4,-			; Case on work bit
	<-
	   <XWB$V_FLG_CLO,  NET$RET_SLOT>,-
	>	
						; For all other bits, come here
	;
	;    If this is the first transmission of a CI then assume the node
	;    is unreachable
	;
	;
	CMPB   #XWB$C_STA_CIS,XWB$B_STA(R5)	; Is a CI being sent ?
	BNEQ	50$				; If NEQ no
	TSTW	XWB$W_PROGRESS(R5)		; Is this the 1st transmission ?
	BNEQ	50$				; If NEQ no
	MOVW	#NET$C_DR_NOPATH,XWB$W_R_REASON(R5) ; Set up disconnect reason
	MOVW   #1,XWB$W_RETRAN(R5)		; Reduce msg retransmissions
	MOVW   #1,XWB$W_PROGRESS(R5)		; Cause link to break
50$:	BSBW	UPD_PROGRESS			; Update the progress counter
	BBS    #XWB$V_STS_TID,XWB$W_STS(R5),140$; If BS then timer is owned
	MOVW   #5,XWB$W_TIMER(R5)		; Try again in 5 seconds
140$:	BBC    #XWB$V_FLG_BREAK,XWB$W_FLG(R5),NONE ; If BS, link is to be broken

BREAK:	;
	;
	;    Generate an event to break the link
	;
	;
	PUSHR	#^M<R1,R6,R7,R8,R9>		; Save regs
						;
	BICW	#XWB$M_FLG_BREAK,XWB$W_FLG(R5)	; Prevent infinite looping
	MOVZBL	#NETEVT$_DSCLNK,R7		; Setup event code
	BSBW	 NET$EVENT			; Process event
						;
	POPR	#^M<R1,R6,R7,R8,R9>		; Restore regs
NONE:	CLRQ	 R0				; Say "nothing to send" and
						;     "no user bytes in msg"
	RSB				   	; Done


	.SBTTL	BLD_CD  	- Build Connect/Disconnect messages
	.SBTTL  BLD_CI  	- Build a CI msg from XWB contents
	.SBTTL	BLD_CA  	- Build a CA msg from XWB contents
	.SBTTL	BLD_CC  	_ Build a CC msg from XWB contents
	.SBTTL	BLD_DI  	- Build a DI msg from XWB contents
	.SBTTL	BLD_DC  	- Build A DC msg from XWB contents
;++
;
;  The appropriate control message is contructed from the information
;  in the XWB.
;
;
;  INPUTS:	R9	Default end-action routine (NET$IO_STATUS) address
;		R8-R6	Scratch
;		R5	XWB address
;		R4	XWB$M_FLG work bit
;		R3-R0	Scratch
;
;  OUTPUTS:	R10	Preserved
;		R9	Address of NET$IO_STATUS or NET$CSS_IOSTAT
;			Zero implies NET$IO_STATUS and also requests that
;			the "return to send bit" be set in the route-header
;		R6	Address of CXB containing the message
;		R5	Preserved
;		R3	Pointer to first byte beyond the message
;		R1	Number of user bytes entered into message
;		R0	LBS if a message was constucted
;			LBC otherwise
;
;		R8,R7,R4,R2  are garbage
;
;
;-
BLD_CD:					; Build Connect or Disconnect message
	MOVZBL	#NSP$C_HSZ_CD,R1	; Setup maximum buffer size needed
	BSBW	GET_XMT_BUF		; Get buffer
					; - no return on error
	BICW	#XWB$M_FLG_SCD,-	; Clear the bit which brought us here
		 XWB$W_FLG(R5)		;
	$DISPATCH XWB$B_STA(R5),TYPE=B,-; Dispatch according to state
	<-
	   <XWB$C_STA_CIS,  BLD_CI>,-	; Build Connect Initate msg
	   <XWB$C_STA_CIR,  BLD_CA>,-	; Build Connect Ack msg
	   <XWB$C_STA_CCS,  BLD_CC>,-	; Build Connect Confirm msg
	   <XWB$C_STA_DIS,  BLD_DI>,-	; Build Disconnect Initiate msg
	   <XWB$C_STA_DIR,  BLD_DC>,-	; Build Disconnect Confirm msg
	>
	MOVL	R6,R0			; Else, setup for deallocation
	BSBW	NET$DEALLOCATE		; Deallocate the block
	CLRL	R0			; Indicate nothing to send
10$:	RSB


		.ENABL	LSB

BLD_CI:					; Build CI from XWB
	CLRL	R9			; Request "return to sender"
	MOVB	#NSP$C_MSG_CR,(R3)+	; Enter msg type - CI "retransmit"
	TSTW	XWB$W_PROGRESS(R5)	; Is this the first transmission ?
	BNEQ	5$			; If NEQ then no
	MOVB	#NSP$C_MSG_CI,-1(R3)	; Else setup for initial CI 

5$:	ASSUME	XWB$W_LOCLNK   EQ  2+XWB$W_REMLNK
	ASSUME	NSP$C_SRV_NFC  EQ  0
	ASSUME	NSP$V_INF_VER  EQ  0

	MOVL	XWB$W_REMLNK(R5),(R3)+	; Enter dst,src link addresses
	MOVW   #NSP$C_SRV_REQ!-		; Enter required SERVICE bits and
	         -			;  say "no flow control" 
		<NSP$C_INF_V40@8>,(R3)+	;   and indicate Version 3.2
	MOVW	XWB$W_LOCSIZ(R5),(R3)+	; Enter rcv segment size
	MOVL	XWB$L_ICB(R5),R4	; Get ICB
	MOVAB	ICB$B_RPRNAM(R4),R1	; Get dst process name address
	BSBW	NET$MOV_USTR		; Move string without the count field
	MOVAB	ICB$B_LPRNAM(R4),R1	; Get src process name address
	BSBW	NET$MOV_USTR		; Move string without the count field
	PUSHL	R3			; Save current output ptr
	CLRB	(R3)+			; Assume no data or access info
	MOVAB	ICB$B_ACCESS(R4),R1	; Point to access info strings
	TSTB	(R1)			; Are access strings null ?
	BEQL	10$			; If EQL then null
	MOVB	#1,@(SP)		; Flag 'access info present'
	BSBW	NET$MOV_USTR		; Move string without the count field
10$:	BISB	#2,@(SP)+		; Flag 'data present' - it may be null
	BUMP	W,NDC+NDC$W_CSN(R5)	; Update "connects sent"
	BRB	30$			; Continue in common

BLD_CC:					; Build the Connect Confirm message
	BBC    #XWB$V_PRO_PH2,-		; If BC, not Phase II
		XWB$B_PRO(R5),15$	; 
	MOVAB	W^NET$CCS_IOSTAT,R9	; Setup I/O status return address
15$:	MOVB   #NSP$C_MSG_CC,(R3)+	; Setup message type

	ASSUME	XWB$W_LOCLNK   EQ  2+XWB$W_REMLNK
	ASSUME	NSP$C_SRV_NFC  EQ  0
	ASSUME	NSP$V_INF_VER  EQ  0

	MOVL	XWB$W_REMLNK(R5),(R3)+	; Enter dst,src link addresses
	MOVW   #NSP$C_SRV_REQ!-		; Enter required SERVICE bits and
	         -			;  say "no flow control" 
		<NSP$C_INF_V40@8>,(R3)+	;   and indicate Version 3.2
	MOVW	XWB$W_LOCSIZ(R5),(R3)+	; Enter rcv segment size
	BRB	30$			; Move user data
	
BLD_CA:					; Build CA from XWB contents
	MOVB	#NSP$C_MSG_CA,(R3)+	; Enter msg typ
	MOVW	XWB$W_REMLNK(R5),(R3)+	; Enter dst link address
	BRB	25$			; Take "no data" exit

BLD_DC:					; Build DC msg
	MOVB	#NSP$C_MSG_DC,(R3)+	; Enter msg type
	BSBB	BLD_DX_COMMON		; Setup msg header
25$:	CLRL	R1			; No user data
	BRB	50$			; Exit in common

BLD_DI:					; Build DI from XWB
	MOVB	#NSP$C_MSG_DI,(R3)+	; Enter msg type
	BSBB	BLD_DX_COMMON		; Setup msg header
	MNEGW	#1,R7			; Set timer i.d. (-1 => connect/discon)
	BSBW	RESET_TIMER		; Set the retransmission timer
					; -- don't zero XWB$W_PROGRESS (it was
					;    zeroed as this state was entered)
30$:	MOVAB	XWB$B_DATA(R5),R1	; Get address of optional data
	BSBW	NET$MOV_CSTR		; Move data as a counted string
	MOVZBL	XWB$B_DATA(R5),R1	; Setup number of data bytes in message
50$:	BICW	#XWB$M_FLG_SCD,-	; Clear flag which got us here
		 XWB$W_FLG(R5)		;
	MOVL	#1,R0			; Indicate that msg was built
					; R1 has # of optional data bytes
	RSB				; Done

		.DSABL	LSB


BLD_DX_COMMON:				; Common disconnet msg building
	;
	;
	;    If the partner is Phase II (V3.1) convert it to V3.2 so that
	;    we get the benefit of timer support.   This ensures that broken
	;    Phase II logical-links will always cleanup.
	;
	;
	BICB   #XWB$M_PRO_PH2,XWB$B_PRO(R5)  ; Enable timer support
10$:	;
	;
	;    Insert logical link address and disconnect reason code
	;
	;
	ASSUME	XWB$W_LOCLNK  EQ  2+XWB$W_REMLNK

	MOVL	XWB$W_REMLNK(R5),(R3)+	; Enter dst,src link addresses
	MOVW	XWB$W_X_REASON(R5),(R3)	; Enter disconnect reason
	CMPW	(R3)+,#NET$C_DR_INVALID	; Valid reason code ?
	BLSSU	20$			; If LSSU, okay
	MOVW	#NET$C_DR_ABORT,-2(R3)	; Else, jam in a default
20$:	RSB				; Done


	.SBTTL	BLD_LIACK	- Build a INT/LS ACK message
	.SBTTL	BLD_DTACK	- Build a DATA ACK message
	.SBTTL	BLD_LI  	- Build INT/LS message
	.SBTTL	BLD_DAT 	- Build DATA message
;+
;
;  The appropriate message is built.  If the message to be built is an ACK and
;  XWB$W_FLG indicates that there is a message which may be sent on the sub-
;  channel then the ACK is sent 'piggy-backed' within that message - otherwise,
;  an ACK message is built and sent.  Messages sent on either subchannel will 
;  always 'piggy-back' and ACK to help reduce retransmissions by the remote 
;  node in the lost message environment offered by Transport.
;
;
;  INPUTS:	R9	Not used
;		R8-R6	Scratch
;		R5	XWB address
;		R4	XWB$M_FLG work bit
;		R3-R0	Scratch
;
;  OUTPUTS:	R6	Address of CXB containing the message
;		R3	Pointer to first byte beyond the message
;		R1	Number of user bytes entered into message
;		R0	LBS if a message was constucted
;			LBC otherwise
;
;		R8,R7,R4,R2  are garbage.  All others are preserved.
;
;-
BLD_LIACK:					   ; Build INT/LS ACK
	BBS    #XWB$V_FLG_SLI,XWB$W_FLG(R5),BLD_LI ; Piggy-back ACK if possible
	BRW	BLD_ACK_LI			   ; Build header

BLD_LI:						   ; Build INT or LS message
	BSBW	BLD_ACK_LI			   ; Build header
	BLBC	R0,50$				   ; Failed if LBC
	MOVW	R7,(R3)+			   ; Enter segment number
	BBC    #NSP$V_FLW_INT,XWB$B_X_FLW(R5),10$  ; If BC then "Link Service"
	;
	;
	;    Xmit an INTERRUPT message
	;
	;
	MOVB   #NSP$C_MSG_INT,CXB$B_X_NSPTYP(R6); Enter message type code
	MOVL	LSB$L_X_PND(R8),R0		; Get associated IRP
	MOVZWL	IRP$W_BCNT(R0),R1		; Setup number of user bytes
						;
	PUSHR	#^M<R1,R4,R5>			; Save regs
	MOVC3	R1,IRP$L_IOST1(R0),(R3)		; Move data
	POPR	#^M<R1,R4,R5>			; Restore regs
						;
	BRB	30$				; Finish in common
10$:	;
	;
	;    Xmit LINK SERVICE (flow control/back-pressure) message
	;
	;
	MOVB   #NSP$C_MSG_LS,CXB$B_X_NSPTYP(R6)	    ; Enter message type code
	BICB3  #NSP$M_FLW_DRV,XWB$B_X_FLW(R5),(R3)+ ; Enter flow control mode 
	MOVB	XWB$B_X_FLWCNT(R5),(R3)+	    ; Enter flow control value
	CLRL	R1				    ; Setup # of user bytes 
30$:	;
	;
	;    Common LS/INT message completion
	;
	;
	BICW   #XWB$M_FLG_SLI,XWB$W_FLG(R5)	; Clear work bit
						;
	ASSUME	XWB$V_STS_TID  EQ  0		;
						;
	BLBC	XWB$W_STS(R5),40$		; If LBC, timer is unowned
	BRW	EX				; Else, take common exit
40$:	BISW   #XWB$M_STS_TLI,XWB$W_STS(R5)	; Mark INT/LI channel as owner
	BRW	EX_T				; Set the timer
50$:	RSB					; Done


BLD_DTACK:					; Build DATA ACK
	BITW   #XWB$M_FLG_WHGL!-		; Any wait conditions preventing
		XWB$M_FLG_WBP,XWB$W_FLG(R5)	; DATA message xmission ?
	BEQL	BLD_DAT				; If not, piggy-back this ACK
	MOVZBL #NSP$C_HSZ_ACK,R1		; Setup size of NSP message
	BSBW	GET_XMT_BUF			; Get buffer for ACK
						; - no return on error
	MOVAB	XWB$T_DT(R5),R8			; Get subchannel block
	MOVB   #NSP$C_MSG_DTACK,(R3)+		; Enter message type
	BRW	BLD_ACK_DAT			; Build common header

BLD_DAT:					; Build a DATA message
	MOVAB	XWB$T_DT(R5),R8			; Get subchannel pointer
	BSBW	GET_XMT_CXB			; Get next CXB for transmission
						; No return on error
	BSBW	BLD_ACK_DAT			; Build header past ACK field
	CMPW	R7,LSB$W_HXS(R8)		; Highest sendable segment ?
	BNEQ	70$				; If NEQ no, there's more
	BISW	#XWB$M_FLG_WHGL,XWB$W_FLG(R5)	; Set wait condition
	CMPW	R7,LSB$W_LUX(R8)		; Is this the last seq queued ?
	BNEQ	80$				; If NEQ no, there's more
							;
	CMPB	LSB$B_X_CXBACT(R8),LSB$B_X_CXBQUO(R8)	; At our limit ?
	BGEQU	80$					; If GEQU, yes
	CMPB	LSB$B_X_CXBACT(R8),LSB$B_X_PKTWND(R8)	; Could we send more ?
	BGEQU	80$					; If GEQU, no
	MOVL	R8,R2				; Setup LSB for call
	BSBW	FILL_XMT_CXBS			; Try to get more data
						;
70$:	BBC	#XWB$V_PRO_NAR,XWB$B_PRO(R5),80$; If BC, NAR option not allowed
	;
	;
	;   We may request that the ACK be delayed in order to reduce the number
	;   of messages being processed.  In order to get an overlap between the
	;   the pipelined data stream and the returning ACK stream, we must ask
	;   for an ACK half way (arbitrarily chosen) between into the maximum
	;   pipeline currently allowed.
	;
	;
;	SUBW3	LSB$W_HAR(R8),LSB$W_HXS(R8),R0	; Get # of packets in the pipe
	SUBW3	LSB$W_HAR(R8),R7,R0		; Get # of packets in the pipe
	ADDW	R0,R0				; Double it
	BLBC	LSB$B_X_PKTWND(R8),75$		; If even okay
	INCB	R0				; Else adjust the threshold
75$:	CMPB	R0,LSB$B_X_PKTWND(R8)		; Half that allowed?
	BEQL	80$				; If so, ask for an ACK
	BISW	#NSP$M_SEQ_NAR,(R3)+		; Suppress ACK for effeciency
	BRB	90$				; Continue
						;
						;
80$:	BICW	#NSP$M_SEQ_NAR,(R3)+		; Make sure ACK is sent
						;
90$:	MOVZWL	CXB$W_LENGTH(R6),R1		; Setup number of user bytes
	ADDL	R1,R3				; Advance R3 to end of message	
	ASSUME	XWB$V_STS_TID EQ 0		;
						;
	BLBS	XWB$W_STS(R5),EX		; If LBS, timer already owned
	BICW   #XWB$M_STS_TLI,XWB$W_STS(R5)	; Mark DATA channel as owner
EX_T:	;
	;
	;    Common exits for sequenced messages
	;
	;
	MOVW	R7,XWB$W_TIM_ID(R5)		; Setup timed segment's number
	BSBW	SET_TIMER_RUN			; Set the timer in RUN state
EX:	MOVW	R7,LSB$W_LNX(R8)		; This will be 'last no. sent'
	SUBW3	R7,LSB$W_HAA(R8),R0		; Gtr than 'high ACK acceptable'
	BBC    #11,R0,100$			; If BC then LNX leq HAA
	MOVW	R7,LSB$W_HAA(R8)		; Else update HAA as well
100$:	MOVL   #1,R0				; Indicate message was built
	RSB					; Done


BLD_ACK_LI:					; Build LS/INT common header
	MOVAB	XWB$T_LI(R5),R8			; Get subchannel block

	ASSUME	NSP$C_HSZ_ACK+2+16 LE IRP$C_LENGTH ; Use lookaside list

	MOVZBL #IRP$C_LENGTH,R1			; Setup size of NSP message
						; large enough for Interrupt msg
	BSBW	GET_XMT_BUF			; Get buffer for message
						; - no return on error
	ADDW3  #1,LSB$W_LNX(R8),R7		; Get next segment number
	BICW   #^X<F000>,R7			; Mask off junk bits
						;
	MOVB   #NSP$C_MSG_LIACK,(R3)+		; Set message type
	BICW   #XWB$M_FLG_SIACK,XWB$W_FLG(R5)	; Need to send ACK is satisfied
	BBCC	R4,XWB$W_FLG(R5),10$		; Clear flag that got us here
10$:	BICW3  #^X<F000>,LSB$W_HAX(R8),R0	; Get ACK value
	BBCC   #XWB$V_STS_LINAK,XWB$W_STS(R5),ACK ; Br unless NAK is to be sent
	BRB	NAK				; Send as a NAK


BLD_ACK_DAT:					; Build DATA ACK header
	BICW   #XWB$M_FLG_SDACK,XWB$W_FLG(R5)	; Clear the work bit
	BICW3  #^X<F000>,LSB$W_HAX(R8),R0	; Get ACK value
	BBCC   #XWB$V_STS_DTNAK,XWB$W_STS(R5),ACK ; Br unless NAK is to be sent
NAK:	BISW   #NSP$M_ACK_NAK,R0		; Set the NAK flag
ACK:						;
	ASSUME	XWB$W_LOCLNK  EQ  2+XWB$W_REMLNK;
						;
	MOVL	XWB$W_REMLNK(R5),(R3)+		; Enter link addresses
	BISW3  #NSP$M_ACK_VALID,R0,(R3)+	; Enter ACK field
	MOVQ   #1,R0				; R1=0  =>  no user bytes in msg
						; R0=1  =>  success, xmt message
	RSB					; Done


	.SBTTL	GET_XMT_CXB	- Get xmt CXB while in FDT context
;+
;
;  INPUTS:	R8	LSB address
;		R7,R6	Scratch
;		R5	XWB address
;		R3-R0	Scratch
;
;  OUTPUTS:	R8	Preserved
;		R7	Segment number
;		R6	CXB address if LBS in R0
;		R5,R4	Preserved
;		R3	Pointer to CXB$B_X_NSPTYP+1(R6)
;		R2,R1	Garbage
;		R0	Low bit set if return to caller's caller
;			Else, garbage
;
;-
GET_XMT_CXB:
	ADDW3	#1,LSB$W_LNX(R8),R7		; Get next sequence number
	EXTZV	#0,#12,R7,R7			; Strip off the junk
	MOVAB	LSB$L_X_CXB-CXB$L_LINK(R8),R6	; Init for CXB scan
10$:	MOVL	CXB$L_LINK(R6),R6		; Get next CXB
	BLSS	20$				; If LSS then got one
						;
	BUG_CHECK  NETNOSTATE,FATAL		; CXB list was empty
						;
20$:	CMPZV	#0,#12,CXB$W_X_NSPSEQ(R6),R7	; This it?
	BNEQ	10$				; If NEQ no, loop
	;
	;
	;    If CXB$V_CD_XMT is currently set in CXB$B_CODE then it is already
	;    queued to some datalink output queue --  since the datalink driver
	;    may be using the datalink-header portion of the buffer, we must
	;    clone a new CXB for transmission.
	;
	;
	BBCS	#CXB$V_CD_XMT,CXB$B_CODE(R6),80$; If BC then buffer is free
	MOVZWL	CXB$W_SIZE(R6),R1		; Get size of buffer
	JSB	G^EXE$ALONONPAGED		; Allocate the buffer
	BLBC	R0,200$				; If LBC then allocation failure
						;
	PUSHR	#^M<R4,R5>			; Save regs
	MOVL	R6,R5				; Copy old CXB pointer
	MOVL	R2,R6				; Setup new CXB pointer
	MOVC3	R1,(R5),(R6)			; Clone the original message
	MOVB	#CXB$M_CD_XMT,CXB$B_CODE(R6)	; Say "xmt in progress" 
	POPR	#^M<R4,R5>			; Recover XWB address
						;
80$:	MOVAB	CXB$B_X_NSPTYP+1(R6),R3		; Setup output pointer
	MOVL	#1,R0				; Indicate sucess
	RSB					; Done

200$:	BISW   #XWB$M_FLG_WBUF,XWB$W_FLG(R5)	; Set wait flag
	TSTL	(SP)+				; Pop caller's address
	RSB					; Return R0 to caller's caller

	.SBTTL	GET_XMT_BUF	- Get xmt buffer while in fork context
;+
;
;  INPUTS:	R6	Scratch
;		R3,R2	Scratch
;		R1	Size of NSP portion of message 
;		R0	Scratch
;
;  OUTPUTS:	R6	Buffer (CXB) address
;		R3	Pointer to message NSP area within buffer
;		R2,R1	Garbage
;		R0	Status
;
;		All other registers are unchanged
;
;		CXB$W_SIZE	Actual CXB block size
;		CXB$B_TYPE	DYN$C_CXB
;		CXB$B_CODE	CXB$M_CD_XMT
;
;
;   If allocation failure, return is to caller's caller.
;
;
;-
GET_XMT_BUF:					; Get xmt buffer
	MOVAB	 CXB$C_OVERHEAD -		; Add in CXB 
	 	+TR3$C_HSZ_DATA(R1),R1		; + Transport msg overhead
	JSB	G^EXE$ALONONPAGED		; Allocate the buffer
	BLBC	R0,200$				; If LBC then allocation failure
	MOVL	R2,R6				; Setup CXB pointer
	;
	;
	;    Fill in common CXB fields
	;
	;
	ASSUME	CXB$B_CODE  EQ  1+CXB$B_TYPE

	MOVW   #DYN$C_CXB+<1@<CXB$V_CD_XMT+8>>,-; Setup block type
		CXB$B_TYPE(R6) 			; ...and setup CXB$B_CODE
	MOVW	R1,CXB$W_SIZE(R6)		; Setup the size
	MOVAB	CXB$B_X_NSPTYP(R6),R3		; Point to message area in buffer
100$:	RSB					; Return status in R0

200$:	BISW   #XWB$M_FLG_WBUF,XWB$W_FLG(R5)	; Set wait flag
	TSTL	(SP)+				; Pop caller's address
	RSB					; Return to caller's caller
						; with LBC in R0


	.SBTTL	NET$IO_STATUS	- Receive xmit status from Transport layer
	.SBTTL	NET$CCS_IOSTAT	- Receive xmit status for Phase II CC message
;++
;
;  This routine is called by Transport to return transmit status to NSP.  The
;  action is to deallocate the CXB if it is no longer in use.
;
;
;  INPUTS:	R5	IRP address
;		R4,R3	Scratch
;		R2	RCB pointer
;		R1	Scratch
;		R0	CXB address (no longer attached to IRP)
;
;
;  OUTPUTS:	R4,R3,R1,R0  are garbage.  All others are unchanged.
;
;
;--
NET$CCS_IOSTAT::			; Receive status after sending a
					; Connect Confirm to a Phase II node

	PUSHR	#^M<R0,R2,R5,R6,R7,R8,R9,R10,R11> ; Save regs
					;
	MOVL	R0,R8			; Save temp copy of CXB address
	MOVL	R5,R6			; Save temp copy of IRP address
	MOVZWL	CXB$W_X_NSPLOC(R8),R3	; Get local link number
	BSBW	NET$XWB_LOCLNK		; Find the XWB
	BLBS	R5,20$			; If LBS not found
	MOVZBL	#NETEVT$_PH2CCS,R7	; Setup event
	BLBS	IRP$L_IOST1(R6),10$	; If LBS then no I/O error
	MOVZBL	#NETEVT$_DSCLNK,R7	; Else indicate link failure
10$:	CLRL	R11			; Say "can't go to IPL 2"
	BSBW	NET$EVENT		; Report the event
					;
20$:	POPR	#^M<R0,R2,R5,R6,R7,R8,R9,R10,R11> ; Restore all regs
					;
					; Fall thru to NET$IO_STATUS

NET$IO_STATUS::				; Receive xmit status
	BICB	#CXB$M_CD_XMT,-		; I/O no longer pending
		 CXB$B_CODE(R0)		;
	BNEQ	10$			; If NEQ then don't deallocate
	BSBW	NET$DEALLOCATE		; Deallocate the block
10$:	RSB



	.SBTTL	NET$TIMER	- Process NETDRIVER clock tick
;+
;
;  *** t.b.s.***
;
;
;
;-
NET$TIMER::					; ...tick...
	PUSHR	#^M<R4,R5,R10,R11>		; Save regs
	DSBINT	UCB$B_FIPL(R4)			; Raise to driver IPL
	CLRL	R11				; Say "can't go to IPL 2"
	;
	;
	;    If mount count = 0 then we're shutting down the network -- stop
	;    the clock and signal NETACP by deactivating the local LPD.
	;
	;
	MOVL	UCB$L_VCB(R4),R2		; Get RCB
	TSTW	RCB$W_MCOUNT(R2)		; Still active
	BNEQ	5$				; If NEQ then yes
	BSBW	TR$KILL_LOC_LPD			; Kill the local LPD
	BLBC	R0,20$				; Br on error
	BICB	#TQE$M_REPEAT,TQE$B_RQTYPE(R5)	; Stop the clock
	MOVAB	W^NET$GL_OFF_DPTFLG,R0		; Get address of offset
	ADDL	W^NET$GL_OFF_DPTFLG,R0		; Point to DPT$B_FLAG
	BICB	#DPT$M_NOUNLOAD,(R0)		; Allow driver to be reloaded
	BRB	20$				; Done
5$:	;
	;
	;    Call the Transport layer timer service routine
	;
	;
	BSBW	TR$TIMER			; Call Transport layer timer
	;
	;
	;    Process all NSP level clocks
	;
	;
	MOVL	RCB$L_PTR_LTB(R2),R4		; Get LTB 
	BEQL	20$				; If EQL then none
	MOVAB  -XWB$L_LINK+LTB$L_XWB(R4),R5	; Prepare for scan
10$:	MOVL	XWB$L_LINK(R5),R5		; Get next XWB
	BEQL	20$				; If EQL then none left
	BITW   #XWB$M_FLG_WBUF!-		; Waiting for buffer
		XWB$M_FLG_WDAT,XWB$W_FLG(R5)	;  or need to try for more data?
	BEQL	12$				; If EQL no 
	BSBW	NET$FORK			; Service WBUF
	BSBW	NET$QAST			; Service WDAT
12$:	REMQUE	@XWB$Q_FREE_CXB(R5),R0		; Get next idle buffer
	BVS	13$				; If BS, none
	BSBW	NET$DEALLOCATE			; Deallocate the block
	DECB	XWB$T_DT+LSB$B_X_CXBCNT(R5)	; Account for it
13$:	INCW	XWB$W_ELAPSE(R5)		; Track elapsed time
	DECW	XWB$W_TIMER(R5)			; Update time left
	BGTRU	10$				; Br unless timeout
	BBC    #XWB$V_STS_SOL,XWB$W_STS(R5),15$ ; If BC, not on solicit queue
	INCW	XWB$W_TIMER(R5)			; Come back in another second
	BRB	10$				; Done for now
15$:	MOVL	XWB$L_VCB(R5),R2		; Setup RCB pointer
	BSBB	TIMEOUT				; Process timeout
	BRB	10$				; Loop
20$:	;
	;
	;    Return to the Exec
	;
	;
	ENBINT					; Restore IPL
	POPR	#^M<R4,R5,R10,R11>		; Restore context
	RSB


		.ENABL LSB

TIMEOUT:
	$DISPATCH TYPE=B,XWB$B_STA(R5),-	; Dispatch on link state
	<-					;
	    <XWB$C_STA_RUN, T_O_RUN>,-		; RUN state
	    <XWB$C_STA_CIS, T_O_CI>,-		; Connect Initiate Sending state
	    <XWB$C_STA_CCS, T_O_CC>,-		; Connect Confirm Sending state
	    <XWB$C_STA_DIS, T_O_DI>,-		; Disconnect Init Sending state
	>					; else,  fall thru
	BRB	70$				; Continue

T_O_CI:						; Timeout xmting CI msg
T_O_CC:						; Timeout xmting CC msg
T_O_DI:						; Timeout xmting DI msg
	BISW	#XWB$M_FLG_SCD,XWB$W_FLG(R5)	; Set 'send Connect/disconnect
	BRB	70$				; Continue

T_O_RUN:;
	;
	;    Force a retransmission of all unACKed messages.  If the inactivity 
	;    timer has expired but there are no outstanding ACKs, then send a 
	;    harmless flow control message, which requires an ACK, to test the 
	;    viability of the link.
	;
	;    Phase II logical-link do not timeout waiting for an ACK, but a
	;    message should still be send every "inactivity timer" interval in
	;    order to make sure the other side is still up.  If the other side
	;    is not up then the "progress" count on the XWB will reach its limit
	;    and the link will break.  If the the other end of the logical-link
	;    is gone but its node is up (e.g., other node crashes and reboots)
	;    then when it receives this message it will send a Disconnect 
	;    Confirm as a response -- thus also breaking the link.
	;
	;
	BBS    #XWB$V_PRO_PH2,XWB$B_PRO(R5),60$	; If BS, Phase II
						;
	ASSUME	XWB$V_STS_TID  EQ  0		;
	BLBC	XWB$W_STS(R5),60$		; If LBC then inactivity timer
	BBS    #XWB$V_STS_TLI,XWB$W_STS(R5),50$	; If BS, LI subchannel owns timer
	;
	;
	;    Timeout on DATA subchannel.  Reset LNX and shrink the transmit-
	;    packet-window.
	;
	;
	MOVAB	XWB$T_DT(R5),R2			; Setup LSB pointer
	MOVW	LSB$W_HAR(R2),LSB$W_LNX(R2)	; Rexmt all unACKed segs
						; ...and enforce LSB Rule 2b.
	BSBW	SHRINK_XPW			; Shrink the xmt-packet-window
						; - clobbers R0-R4.  May pass
						;   off timer to a different
						;   message
	BLBC	XWB$W_STS(R5),60$		; If LBC, timer is now unowned
	BBS    #XWB$V_STS_TLI,-			; If BS, timer given to LI
		XWB$W_STS(R5),80$		; subchannel
	BRB	70$				; Else, update PROGRESS even if
						; new XWB$W_TIM_ID value
50$:	;
	;
	;    Timeout on LI subchannel
	;
	;
	MOVAB	XWB$T_LI(R5),R2			; Get LI LSB
	MOVW	LSB$W_HAR(R2),LSB$W_LNX(R2)	; Rexmt all unACKed segs
						; ...and enforce LSB Rule 2b.
	BISW   #XWB$M_FLG_SLI,XWB$W_FLG(R5)	; Set 'send LI' flag
	BRB	70$				; Continue
60$:	;
	;
	;    Cause (possibly null) flow control message to be sent in order to
	;    cause the partner node to send and ACK.  This is done to make sure
	;    that the partner node is still there.
	;
	;
	MOVW	XWB$W_TIM_INACT(R5),XWB$W_TIMER(R5) ; Reset timer
	BISW   #XWB$M_FLG_SDFL,XWB$W_FLG(R5)	    ; Schedule flow ctl msg 
	;
	;
	;    If the XWB$L_PID field is zero, then there is no current owner of
	;    this link and we are in the RUN state waiting to transmit the 
	;    message currently committed to the pipeline.  Hence, make sure that
	;    backpressure relaxed in order to avoid deadlock -- e.g., if both 
	;    ends of the link were in this state we would have deadlock.
	;
	;    The reason both relaxing backpressure avoids the deadlock is that
	;    receiving a message that we cannot buffer while in the RUN state
	;    with XWB$L_PID equal to zero will cause the link to be marked for
	;    disconnect (see routine BACK_PRESSURE).
	;
	;
	TSTL	XWB$L_PID(R5)			; Any owner process
	BNEQ	80$				; If NEQ yes
	TSTL	XWB$T_DT+LSB$L_R_CXB(R5)	; Any data currently
	BEQL	65$				; If EQL then none
	BSBW	NET$MARK_LINK			; Cause link to break
65$:	BBC	#XWB$V_STS_RBP,XWB$W_STS(R5),80$; If BC then no backpressure
	BISW	#XWB$M_FLG_TBPR,XWB$W_FLG(R5)	; Relax (toggle) backpressure
	BRB	80$				; Continue
70$:	;
	;
	;    Common timeout processing
	;
	;
	BUMP	W,NDC+NDC$W_RTO(R5)		; Account for response timeout
	BSBB	UPD_PROGRESS			; Update progress count
80$:	BSBW	NET$FORK			; Fork to do new work
100$:	RSB					; Done

		.DSABL	LSB



RESET:	CMPW	LSB$W_HAR(R0),LSB$W_LNX(R0)	; Anything to rexmt ?
	BEQL	10$				; If EQL no
	MOVW	LSB$W_HAR(R0),LSB$W_LNX(R0)	; Rexmt all unACKed segs
						; ...and enforce LSB Rule 2b.
	INCB	R0				; Indicate this LSB was reset
	MOVB	#1,R1				; Set retransmit flag
10$:	RSB					; Done


UPD_PROGRESS:					; Decrement progress count
	INCW	XWB$W_PROGRESS(R5)		; Account for lack of progress
	CMPW	XWB$W_PROGRESS(R5),-		; Has it grown too large ?
		XWB$W_RETRAN(R5)		;
	BLSSU	20$				; If LSSU then okay
	BSBB	NET$MARK_LINK			; Mark link for break
	BISW   #XWB$M_STS_TMO,XWB$W_STS(R5)	; Indicate timeout
	CMPW   #NET$C_DR_INVALID,-		;
		XWB$W_R_REASON(R5)		; Reason code set yet?
	BNEQ	10$				; If NEQ then yes
	MOVW   #NET$C_DR_NOPATH,-		; Setup local reason code
		XWB$W_R_REASON(R5)		;
10$:	CMPW   #NET$C_DR_INVALID,-		;
		XWB$W_X_REASON(R5)		; Remote reason be set yet?
	BNEQ	20$				; If NEQ then yes
	MOVW   #NET$C_DR_EXIT,-			; Setup code to send to partner
		XWB$W_X_REASON(R5)		;
20$:	BRW	RESET_TIMER			; Set NSP timer


NET$MARK_LINK::					; Mark the link for break
	BICW   #XWB$M_STS_TID,XWB$W_STS(R5)	; Free-up the timer
	BISW   #XWB$M_FLG_BREAK,XWB$W_FLG(R5)	; Mark link for abort
	BSBW	NET$FORK			; Fork to do new work
	RSB					; Done


	.SBTTL	TIMED_SEG_ACKED	- Timed segment has been ACK'd

		.ENABL	LSB

TIMED_SEG_ACKED:			; Timed segment has been ACK'd
	;
	;
	;    INPUTS:	R5  XWB pointer
	;		R0  Scratch
	;
	;    OUTPUTS:	R0  Garbage
	;
	;		All other regs are unchanged
	;
	;
	;    Update delay estimate as a function of the former delay, the new 
	;    round trip time (delta) and the 'weight' parameter (this value is 
	;    store after being incremented by one).  The following shows the 
	;    derivation of the formula used to compute 'delay'.
	;
	;     delay = ((delay*weight)+delta)/(weight+1)
	;     delay = delay + ((delta-delay)/(weight+1))
	;
	;     elapse = delta - delay	('elapse' is biased to minus 'delay' 
	;				(when the msg was first sent and 
	;				(incremented each clock tick - it may 
	;				(be negative
	;
	;     delay = delay + elapse/(weight+1)
	;
	;
	MOVW	XWB$W_ELAPSE(R5),R0	; Get elapsed time
	BGEQ	5$			; If GEQ then arrived late
	MNEGW	R0,R0			; Convert to positive number
	DIVW	XWB$W_DLY_WGHT(R5),R0	; Get weighted adjustment
	INCW	R0			; Ensure minimum of 1 sec change
					; to allow for loss of fractional part
	SUBW	R0,XWB$W_DELAY(R5)	; Get new delay value
	BRB	25$			; 
5$:	DIVW	XWB$W_DLY_WGHT(R5),R0	; Get weighted adjustment
	INCW	R0			; Ensure minimum of 1 sec change
					; to allow for loss of fractional part
	ADDW	XWB$W_DELAY(R5),R0	; Get new delay value
	CMPW	R0,#NSP$C_MAX_DELAY	; Compare  against max delay allowed
	BLEQU	20$			; If LEQ (unsigned) then okay
	MOVZWL #NSP$C_MAX_DELAY,R0	; Else use the max delay allowed
20$:	MOVW	R0,XWB$W_DELAY(R5)	; Update the delay
25$:	BGTR	30$			; If GTR (signed) then okay
	MOVW   #1,XWB$W_DELAY(R5)	; Use 1 sec as minimum delay
30$:					; Fall thru
CANCEL_TIMER:				;
	;
	;
	;    See if an already xmitted segment is waiting to be ACK'd.  
	;
	;    On the LI sub-channel, since neither negative flow control or
	;    backpressure are allowed, this is merely a matter of checking 
	;    for HAR < LNX.
	;
	;    On the DATA sub-channel, since negative flow control and back-
	;    pressure are allowed, it is necessary to check for  HAR < LNX,
	;    and that the link is not backpressured off.
	;
	;
	;    NOTE:  LSB Rule 2a + 2b imply that HAR is always leq LNX.  This
	;	    fact is used below to avoid messy 12 bit comparisons
	;
	;
	;
	BICW   #XWB$M_STS_TID!-			; Timer is unowned and init 
		XWB$M_STS_TLI,XWB$W_STS(R5)	; subchannel flag to known value
	MOVAB	XWB$T_DT(R5),R0			; Get DATA sub-channel LSB
	CMPW	LSB$W_HAR(R0),LSB$W_LNX(R0)	; Anything sent but unACK'd
	BEQL	40$				; If EQL then no
	BBC    #XWB$V_FLG_WBP,XWB$W_FLG(R5),60$	; If BC then no backpressure
40$:	MOVAB	XWB$T_LI(R5),R0			; Get LI sub-channel LSB
	MOVW	XWB$W_TIM_INACT(R5),-		; Setup inactivity timer 
		XWB$W_TIMER(R5)			; assuming nothing to send
	CMPW	LSB$W_HAR(R0),LSB$W_LNX(R0)	; Anything sent but unACK'd
	BEQL	100$				; If EQL, no
	BISW   #XWB$M_STS_TLI,XWB$W_STS(R5)	; Timer owner is LI subchannel
	;
	;
	;    Hand off the timer to the next un-ACKed segment
	;
	;
60$:	ADDW3  #1,LSB$W_HAR(R0),R0		; Get next unACKed seg number
	BICW3  #^X<F000>,R0,XWB$W_TIM_ID(R5)	; Setup timed segment number
						;
SET_TIMER_RUN:					; Set timer while in RUN state
	BISW   #XWB$M_STS_TID,XWB$W_STS(R5)	; Claim ownership of timer
	MNEGW	XWB$W_DELAY(R5),XWB$W_ELAPSE(R5); Bias the elapsed time timer
	CLRW	XWB$W_PROGRESS(R5) 		; Init PROGRESS


NET$RESET_TIMER::				; Reset logical-link timer
RESET_TIMER:					; Reset logical-link timer
	ASSUME	NSP$C_MAX_DELAY  LT  <^X7FFF>

	MULW3	XWB$W_DLY_FACT(R5),-		;
		XWB$W_DELAY(R5),R0		; Get timer value
	BVS	80$				; If BS then overflow
	CMPW	R0,#NSP$C_MAX_DELAY		; Greater than max ?
	BLEQU	90$				; If LEQU no, its okay
80$:	MOVW   #NSP$C_MAX_DELAY,R0		; Use max delay
90$:	ADDW3  #1,R0,XWB$W_TIMER(R5)		; Set timer (+1 for clock skew)
	BLEQ	80$				; If LEQ (signed) then overflow
100$:	RSB					; Done


		.DSABL LSB

.END




