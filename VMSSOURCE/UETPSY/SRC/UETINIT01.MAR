	.TITLE UETINIT01 VAX/VMS UETP SYSTEM CONFIGURATION SIZER
	.IDENT	'V04-000'
	.ENABLE SUPPRESSION
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:
;	This module will be distributed with VAX/VMS under the [SYSTEST]
;	account.
;
; ABSTRACT:
;	This program creates a file called UETINIDEV.DAT containing all device
;	names and unit numbers of devices that are supported by the UETP.
;	Various lists internal to VMS are searched to collect this information.
;	As this file is being created, the device, if supported, has a quick
;	test done on it to make sure that it is basically functional.  If
;	the device is not functional it is deselected from further UETP
;	testing by modifying UETINIDEV.DAT.
;
; ENVIRONMENT:
; 	This program will run primarily in user access mode, with ASTs enabled
;	except during error processing.  The UETP$CLSIODB subroutine runs in
;	kernel mode.  We require the following privileges and quotas:
;			CMKRNL
;			GRPNAM
;			TMPMBX
;
;--
;
; AUTHOR: Larry D. Jones,	CREATION DATE: November, 1980
;
; MODIFIED BY:
;
;	V03-008	RNH0009		Richard N. Holstein,	06-Jul-1984
;		Add NOA as known, but not testable.
;
;	V03-007	RNH0008		Richard N. Holstein,	15-Feb-1984
;		Take advantage of the new UETP message codes.  Fix SSERROR
;		interaction with RMS_ERROR.  Fix algorithm which checks for
;		known, but not testable devices.
;
;	V03-006	RNH0007		Richard N. Holstein,	10-Jul-1983
;		Add NDA as known, but not testable.
;
;	V03-005	RNH0006		Richard N. Holstein,	06-Mar-1983
;		Be even more cautious if a process hangs - time out $DELPRC.
;
;	V03-004	RNH0005		Richard N. Holstein,	14-Jan-1983
;		Define SYS$ERROR as NL: for the device test subprocesses.
;
;	V03-003	RNH0004		Richard N. Holstein,	07-Jan-1983
;		Convert to use UETP$CLSIODB routine to search VMS's I/O
;		database.  Redesign logic which deals with known, but
;		untestable devices.  Fix SSERROR to be reentrent.  Have
;		AST routines specifically set up SSERROR as their error
;		handler as necessary.  Clean out the remains of pre-V2.
;		Miscellaneous fixes listed in the V3B UETP Workplan.
;		Indent lines copied from subprocess device test log files.
;
;	V03-002	RNH0003		Richard N. Holstein,	22-Jun-1982
;		Fixed problem of ACCVIO in kernal mode if a controller has no
;		units connected to it.  Related problems of bogus line in
;		UETINIDEV.DAT and wrong unit number in error messages also
;		fixed.
;
;	V03-001	LDJ0003		Larry D. Jones,		15-Apr-1982
;		Fixed MA780 extra UCB record in the inidev file bug.
;
;	V02-007	RNH0002		Richard N. Holstein,	18-Jan-9182
;		Increase TEXT_BUFFER size to hold larger messages.  Fix
;		bug where BBS tested mask instead of bit position.
;
;	V02-006 RNP0003		Robert N. Perron,	31-Dec-1981
;		Removed upper casing of begin sentinels
;
;	V02-005	RNP0002		Robert N. Perron,	23-Dec-1981
;		Fixed so that non-supported devices do not appear in 
;		UETINIDEV.DAT. Added device summary printout to SUC_EXIT and
;		removed printing of DDB and UCB lines. Fixed handling of
;		remote terminals - skip them.
;
;	V02-004 RNP0001		Robert N. Perron,	05-Nov-1981
;		Modified to allow batch execution.
;
;	V02-003	LDJ0002		Larry D. Jones,		14-Oct-1981
;		Reset DNTM before creating each new subprocess.
;
;	V02-002	RNH0001		Richard N. Holstein,	05-Oct-1981
;		Change SS$_CONTROLC to be a warning.  Use secondary device
;		characteristics for DDB devices as appropriate.  Remove
;		ALWAYS flag - it prevents useful info from being typed and
;		is redundantly implemented by judicious use of SHRT_RPRT.
;
;	V02-001	LDJ0001		Larry D. Jones,		08-Sep-1981
;		Fixed reporting of NET as a non-supported device.
;
;**

	.SBTTL	Declarations
;
; INCLUDE FILES:
;

;
; MACROS:
;
	$ACCDEF				; Accounting definitions
	$CHFDEF				; Condition handler frame definitions
	$DCDEF				; Device classes and types
	$DIBDEF				; Device Information Block
	$DVIDEF				; $GETDVI ITMLST item codes
	$IODEF				; $QIO function codes
	$JPIDEF				; JPI definitions
	$PQLDEF				; Process quota list definitions
	$SECDEF				; Section definitions
	$SHRDEF				; Shared messages
	$SSDEF				; System service status codes
	$STSDEF				; Status return
	$UETIDBDEF			; UETP I/O database definitions
	$UETPDEF			; UETP
;
; EQUATED SYMBOLS:
;
;   Facility number definitions:
	RMS$_FACILITY = 1

;   SHR message definitions:
	UETP = UETP$_FACILITY@STS$V_FAC_NO ; Make a mask of UETP facility code
	UETP$_ABENDD = UETP!SHR$_ABENDD	; Define the UETP message codes
	UETP$_BEGIND = UETP!SHR$_BEGIND
	UETP$_ENDEDD = UETP!SHR$_ENDEDD
	UETP$_OPENIN = UETP!SHR$_OPENIN
	UETP$_TEXT   = UETP!SHR$_TEXT

;   Internal flag bits...:
	SHRT_RPRTV   = 0		; Set if short report format desired
	BEGIN_MSGV   = 1		; Set when "begin" msg has been output
;   ...and corresponding masks:
	SHRT_RPRTM   = 1@SHRT_RPRTV
	BEGIN_MSGM   = 1@BEGIN_MSGV

;   Miscellany:
	LC_BITM       = ^X20		; Mask to convert lower case to upper
	REC_SIZE      = 40		; UETINIDEV.DAT maximum record size
	TEXT_BUFFER   = 250		; Internal text buffer size
	SS_SYNCH_EFN  = 3		; Synch miscellaneous system services
	MAX_DEV_DESIG = 10		; Longest possible controller name
	MAX_UNIT_DESIG= 5		; Longest possible unit number
	MBX_SIZE      = 256		; Mailbox buffer size
	MAX_SUMM_LINE = 80		; Longest summary line we'll create
	INDENT	      = 4		; Indentation when copying log files

	.SBTTL	Read-Only Data
	.PSECT	RODATA,NOEXE,NOWRT,PAGE

ACNT_NAME:				; Process name on exit
	.ASCID	/SYSTEST/

TEST_NAME:				; This test name
	.ASCID	/UETINIT01/

SUPDEV_GBLSEC:				; How we access UETSUPDEV.DAT
	.ASCID	/UETSUPDEV/

MODE:					; Run mode logical name
	.ASCID	/MODE/

REPORT_NAME:				; Long or short report indicator
	.ASCID	/REPORT/		; See note where $TRNLOG is done

EQUA1:
	.ASCID	/ONE/

SUBPROC_ERROR:				; SYS$ERROR for the device tests
	.ASCID	/NL:/

SYS$COMMAND:				; Name of device from which we...
	.ASCID	/SYS$COMMAND/		; ...get any input

NO_RMS_AST_TABLE:			; List of errors for which...
	.LONG	RMS$_BLN		; ...RMS cannot deliver an AST...
	.LONG	RMS$_BUSY		; ...even if one has an ERR= arg
	.LONG	RMS$_CDA		; Note that we can search table...
	.LONG	RMS$_FAB		; ...via MATCHC since <31:16>...
	.LONG	RMS$_RAB		; ...pattern can't be in <15:0>
NRAT_LENGTH = .-NO_RMS_AST_TABLE

COMMAND_ITMLST:				; $GETDVI arg list for SYS$COMMAND
	.WORD	4,DVI$_DEVCLASS		; We need the device class...
	.LONG	DEVBUF,0
	.WORD	64,DVI$_DEVNAM		; ...and the equivalence name
	.LONG	BUFFER,BUFFER_PTR
	.LONG	0			; Terminate the list

CLSIODB_ARGLST:				; What we send to UETP$CLSIODB
	.LONG	4
	.ADDRESS CLSPTR,LCLPTR,MPMPTR
	.LONG	UIDFLAG$M_DDB!UIDFLAG$M_UCB!UIDFLAG$M_MPM!UIDFLAG$M_SID

; There is some trickiness in using the following.  We have a table of short
; ASCIC strings to compare against a short ASCIC device name.  If we just used
; a MATCHC of ASCII strings on ASCII strings, one string could "slur" into the
; next, resulting in a bogus match.  With ASCIC strings though, the length
; byte (assuming "short" strings of all printable characters!) serves as a
; marker to prevent string overlap and allows the MATCHC to work as we wish.
KNOWN_BUT_NOT_TESTABLE:			; Start of ASCIC string table
	.ASCIC	/OPA/			; Operator console name
	.ASCIC	/CSA/			; Diagnostic load device name
	.ASCIC	/NLA/			; Null device
	.ASCIC	/CRA/			; First card reader
	.ASCIC	/CRB/			; Second card reader
	.ASCIC	/RTA/			; Remote terminals
	.ASCIC	/NET/			; Networks
	.ASCIC	/MBA/			; Mailboxes (local)
	.ASCIC	/MBB/			; Mailboxes (shared memory)
	.ASCIC	/NDA/			; Network dummy
	.ASCIC	/NOA/			; Asynchronous DECnet
	.ASCIC	/PT /			; Generic UDA for magtapes
	.ASCIC	/PU /			; Generic UDA for disks
	.ASCIC	/PA /			; Generic CI as a cluster connect
	.ASCIC	/CN /			; DECnet over a CI
	.ASCIC	/CJ /			; Generic common journalling
KBNT_LENGTH = .-KNOWN_BUT_NOT_TESTABLE
	.BLKB	8			; Space for patching other devices

CS1:					; Device class and type control string
	.ASCID	/!2XB !2XB /

CS3:					; Device class-only control string
	.ASCID	/!2XB ** /

MPM_CS:					; Faked $FAO result...
	.ASCID	/   ** /		; ...from MPM "characteristics"

CONT00_OVERHEAD:			; Table of overhead lines...
	.ADDRESS PHASE_NAME		; ...that begin UETCONT00.DAT
	.ADDRESS LOG_NAME
	.ADDRESS HEADER_REC
OVERHEAD_LENGTH = . - CONT00_OVERHEAD/4
PHASE_NAME:				; Phase name for the device test phase
	.ASCIC	/NAME = UETPDEV00/
LOG_NAME:				; UETCONT00 file log name
	.ASCIC	/LOG  = UETPDEV00.LOG/
HEADER_REC:				; UETCONT00.DAT init records
	.ASCIC	/! UETP Device Test Phase/

THREEMIN:				; Time out value when creating...
	.LONG	-10*1000*1000*180,-1	; ...device test subprocesses

ONEMIN:					; Time out when $DELPRCing...
	.LONG	-10*1000*1000*60,-1	; ...device test subprocesses

BLANK_LINE_PTR:				; $PUTMSG MSGVEC for writing blank line
	.WORD	3,1
	.LONG	UETP$_TEXT!STS$K_SUCCESS
	.LONG	1
	.ADDRESS BLANK_LINE

LOG_BEGIN:				; $PUTMSG MSGVEC for copying log file
	.WORD	3,^XF
	.LONG	UETP$_COPY_LOG
	.LONG	1
	.ADDRESS TESTING_MSG

BLANK_LINE:
	.ASCID	//			; This line intentionally left blank

LOGEXT:					; Log file type
	.ASCII	/.LOG/

CONT_STR:				; Control string for UETCONT00 records
	.ASCID	/Y Y !AS "!AS"/

TEST_COUNT:				; Testable count logical name...
	.ASCID	/TEST_COUNT/		; ...for UETCONT00 file

TST_CNT_STR:				; Control string for UETCONT00 records
	.ASCID	/!UL/

DDB_CTRSTR:				; UETINIDEV.DAT...
	.ASCID	/DDB T !AC/		; ...DDB record control string

UCB_CTRSTR:				; UETINIDEV.DAT...
	.ASCID	/UCB T !5ZW/		; ...UCB record control string

END_MSG:				; UETINIDEV.DAT...
	.ASCII	/END OF UETINIDEV.DAT/	; ...ending message
	END_MSGL = .-END_MSG

JPI_LIST:
	.WORD	4,JPI$_UIC		; List for the $GETJPI service
	.ADDRESS UIC,0
	.WORD	4,JPI$_ASTLM
	.ADDRESS ASTLM,0
	.WORD	4,JPI$_BIOLM
	.ADDRESS BIOLM,0
	.WORD	4,JPI$_DIOLM
	.ADDRESS DIOLM,0
	.WORD	4,JPI$_TQLM
	.ADDRESS TQLM,0
	.LONG	0

CONT_DESC:				; Desc used to convert controller...
	.WORD	0,3			; ...from lowercase to uppercase
	.ADDRESS BUFFER+6

MPM_LITERAL:				; Shared memory must be called "MPM"
	.ASCIC	/MPM/

TESTABLE:				; Message summarizing testable units
	.REPT	MAX_DEV_DESIG+1		; Leave space for controller (which...
	.ASCII	/ /			; ...is overwritten) and colon
	.ENDR
	.ASCII	/ testable     /	; Corresponds to UNTESTABLE
TESTABLE_LEN = .-TESTABLE

UNTESTABLE:				; Message summarizing untestable units
	.REPT	MAX_DEV_DESIG+1		; Corresponds to TESTABLE
	.ASCII	/ /
	.ENDR
	.ASCII	/ untestable   /	; Also corresponds to TESTABLE
.IIF NE .-UNTESTABLE-TESTABLE_LEN, .ERROR ; TESTABLE & UNTESTABLE must be same length!

NONE:					; Message saying no testable units
	.ASCII	/none/
NONE_LEN = .-NONE


SUMM_HEADER:
	.ASCID	/ *** Summary of testable and untestable devices. ***/

FORMAT_ERR_MSG:
	.ASCID	/Error in UETINIDEV.DAT format./

START_DESC:				; Sentinel for...
	.ASCID /BEGIN/			; ...start of useful log file info

STOP_DESC:				; Sentinel for...
	.ASCID /ENDED/			; ...end of useful log file info

FNF_MSG:				; Message for missing subprocess log
	.ASCID	/Log file !AS was not found from testing controller !AS./

FLK_MSG:				; Proc hasn't terminated, can't get log
	.ASCID	/Log file !AS is locked from testing controller !AS./

CNTRLCMSG:
	.ASCID	\Aborted via a user CTRL/C\

FILE:					; Fills in RMS_ERR_STRING
	.ASCID	/file/
RECORD:					; Fills in RMS_ERR_STRING
	.ASCID	/record/
RMS_ERR_STRING:				; Announces an RMS error
	.ASCID	/RMS !AS error in file !AD/

GETDVI_FAIL:
	.ASCID	/$GETDVI failed - status was:/

CLSIODB_FAIL:
	.ASCID	/Unable to read list of devices available to this system./

BAD_P0_LIST:
	.ASCID	/Illegal format in list of devices available to this system./

MBXW_QIO_FAIL:
	.ASCID	/$QIO failed when writing mailbox - status was:/

CREPRC_QIO_FAIL:
	.ASCID	/$QIO failed when creating subprocess - status was:/

SUBPROCESS_FAIL:
	.ASCID	/Error running !AS for controller !AS - final status was:/

PROCESS_STOP_MSG:			; Message if we must stop subprocess...
	.ASCID	\!AS testing controller !AS was stopped ($DELPRC) at !%T\-
		\!/!_because it seemed hung or because UETINIT01 was aborted.\
					; ...before getting termination mailbox

PASS_OVER_MSG:				; Message if $DELPRC couldn't stop proc
	.ASCID	\!AS testing controller !AS did not stop despite $DELPRC.\-
		\!/!_No longer waiting (!%T) for the termination mailbox.\

	.SBTTL	Read/Write Data
	.PSECT	RWDATA,WRT,NOEXE,PAGE

UIC:					; Our UIC
	.LONG	0
QUOTA_LIST:				; Quota list for created subprocess
	.BYTE	PQL$_ASTLM
ASTLM:
	.LONG	0
	.BYTE	PQL$_BIOLM
BIOLM:
	.LONG	0
	.BYTE	PQL$_DIOLM
DIOLM:
	.LONG	0
	.BYTE	PQL$_TQELM
TQLM:
	.LONG	0
	.BYTE	PQL$_LISTEND

TTCHAN:					; Channel associated with ctrl. term.
	.WORD	0

MBXCHN:					; Mailbox channels - termination mbx
	.WORD	0
MBX_UNIT:				; Unit number for termination mailbox
	.WORD	0

MBX1_CHAN:				; SYS$INPUT of created subprocesses
	.WORD	0

FLAG:					; Miscellaneous flag bits
	.WORD	0			; (See Equated Symbols for definitions)

LOG_RCD:				; Message vector for $PUTMSG
	.WORD	3			; Arg count
	.WORD	^B0001			; Message only flag
	.LONG	UETP$_TEXT		; Message ID
	.WORD	1			; FAO arg count
	.WORD	0			; No new msg flags
MSG_PTR:
	.LONG	BUFFER_PTR		; Message buffer for $PUTMSG

FAO_BUF:				; FAO output string descriptor
	.WORD	TEXT_BUFFER,0
	.ADDRESS BUFFER
BUFFER_PTR:				; Fake .ASCID buffer for misc. strings
	.WORD	TEXT_BUFFER,0		; A word for length, a word for desc.
	.ADDRESS BUFFER
BUFFER:					; FAO output and other misc. buffer
	.BLKB	TEXT_BUFFER

FAO_ALT:				; FAO output string descriptor #2
	.LONG	MAX_SUMM_LINE
	.ADDRESS ALTBUF
ALTBUF_PTR:				; Output string descriptor #2
	.LONG	0
	.ADDRESS ALTBUF
ALTBUF:					; FAO output buffer #2
	.BLKB	MAX_SUMM_LINE

DEVDSC:					; Device name descriptor
	.BLKL	2			; This gets filled at runtime

MBX_BUF:
	.BLKB	MBX_SIZE		; Mailbox read buffer

TEST_DSC:				; Device test file name descriptor...
	.LONG	13			; ...for the subprocess we create
	.ADDRESS TEST_IMAGE
TEST_IMAGE:				; Device test file name
	.BLKB	13

PIDADR:					; Receives PID of the subprocesses...
	.LONG	0			; ...we create for each controller

LOGNAM_DSC:				; Descriptor for log file name
	.LONG	0
	.ADDRESS LOGNAM
LOGNAM:
	.BLKB	17

DEV:					; Device Information Block
	.LONG	DIB$K_LENGTH
	.ADDRESS DEVBUF
DEVBUF:
	.BLKB	DIB$K_LENGTH

ERROR_COUNT:				; Cumulative error count at runtime
	.LONG	0

STATUS:					; Status value on program exit
	.LONG	0

QUAD_STATUS:				; Status block for return from...
	.QUAD	0			; ...miscellaneous asynch services

INADDRESS:				; $CRMPSC address storage
	.LONG	0,0
OUTADDRESS:
	.LONG	0,0

TST_CNT:				; Count of UETCONT00 data records
	.LONG	0

MSG_BLOCK:				; Auxiliary $GETMSG info
	.BLKB	4

EXIT_DESC:				; Exit handler descriptor
	.LONG	0
	.ADDRESS EXIT_HANDLER
	.LONG	1
	.ADDRESS STATUS

ARG_COUNT:				; Argument counter used by ERROR_EXIT
	.LONG	0

TEMP_BUFF_DESC:
	.WORD TEXT_BUFFER,0		; Temp buffer to hold capitalized...
	.ADDRESS TEMP_BUFF_STR		; ...record to check for sentinel
TEMP_BUFF_STR:
	.BLKB TEXT_BUFFER

LCLPTR:					; Receives results of UETP$CLSIODB...
	.LONG	0,0			; ...call for local peripherals

MPMPTR:					; Receives results of UETP$CLSIODB...
	.LONG	0,0			; ...call for shared memories

CLSPTR:					; Receives results of UETP$CLSIODB...
	.LONG	0,0			; ...call for cluster peripherals

TESTING_MSG:				; This becomes part of the message...
	.WORD	0,0			; ...surrounding a copy of a...
	.ADDRESS .+4			; ...log file from a subprocess
	.ASCII	/testing /
TESTING_MSG_LENGTH = .-TESTING_MSG-8
TESTING_MSG_TEXT:
	.REPEAT	MAX_DEV_DESIG
	.ASCII	/ /			; Gets overwritten with controller name
	.ENDR

	.SBTTL	RMS-32 Data Structures
	.ALIGN	LONG

INI_FAB:				; Allocate FAB for UETINIDEV
	$FAB-
	FAC = <GET,PUT,UPD,TRN>,-
	RAT = CR,-
	SHR = <GET,PUT,UPI>,-
	FNM = <UETINIDEV.DAT>

INI_RAB:				; Allocate RAB for UETINIDEV
	$RAB-
	FAB = INI_FAB,-
	UBF = BUFFER,-
	RBF = BUFFER,-
	USZ = REC_SIZE

SUP_FAB:				; Allocate FAB for UETSUPDEV
	$FAB-
	FAC = GET,-
	SHR = <UPI,GET>,-
	FOP = UFO,-
	FNM = <UETSUPDEV.DAT>

CON_FAB:				; Allocate FAB for UETCONT00
	$FAB-
	FAC = <PUT>,-
	RAT = CR,-
	FNM = <UETCONT00.DAT>

CON_RAB:				; Allocate RAB for UETCONT00
	$RAB-
	FAB = CON_FAB

LOG_FAB:				; Allocate FAB for UETINIT01 log
	$FAB	FNM = <UETINIT01.LOG>,-
		RAT = CR,-
		FAC = PUT
LOG_RAB:				; Allocate RAB for UETINIT01 log
	$RAB	FAB = LOG_FAB,-
		RBF = BUFFER,-
		RSZ = TEXT_BUFFER

TMPLOG_FAB:				; Allocate FAB for subprocess log
	$FAB	RAT = CR,-
		FAC = GET

TMPLOG_RAB:				; Allocate RAB for subprocess log
	$RAB	FAB = TMPLOG_FAB,-
		UBF = BUFFER,-
		USZ = TEXT_BUFFER
DDB_RFA:				; Storage for current DDB RFA
	.BLKB	6
END_RFA:				; Storage for END line RFA
	.BLKB	6

	.SBTTL	Main Program
	.PSECT	UETINIT01,EXE,NOWRT,PAGE

	.DEFAULT DISPLACEMENT,WORD

.ENTRY UETINIT01,^M<>			; Entry mask
;+
;	Start to set things up.  We need our own overhead tasks (exception,
;	CTRL/C and exit handlers, name and log file), the items for
;	what we produce (UETINIDEV.DAT, UETCONT00.DAT) and the means of
;	producing them (UETSUPDEV.DAT, various logical names, communication
;	for subprocesses).
;-

;
; Overhead tasks.
;
	MOVAL	SSERROR,(FP)		; Declare exception handler
	$SETSFM_S ENBFLG = #1		; Enable system service failure mode
	$DCLEXH_S DESBLK = EXIT_DESC	; Declare an exit handler

	$CREATE FAB = LOG_FAB,-		; Create our own log file
		ERR = RMS_ERROR
	$CONNECT RAB = LOG_RAB,-
		 ERR = RMS_ERROR
	CLRL	-(SP)			; Set the time stamp flag
	PUSHAL	TEST_NAME		; Set the test name
	PUSHL	#2			; Push the argument count
	PUSHL	#UETP$_BEGIND!STS$K_SUCCESS ; Set the message code
	CALLS	#4,G^LIB$SIGNAL		; Print the startup message
	BISW2	#BEGIN_MSGM,FLAG	; Set flag so we don't type it twice
	$SETPRN_S PRCNAM = TEST_NAME 	; Set the process name

	$GETDVI_S DEVNAM = SYS$COMMAND,-   ; Get the name of...
		     EFN = #SS_SYNCH_EFN,- ; ...device which may abort test
		  ITMLST = COMMAND_ITMLST,-
		    IOSB = QUAD_STATUS
	BLBS	QUAD_STATUS,20$		; BR if all went OK
	MOVZWL	QUAD_STATUS,R2		; Set up arglist so we can appease...
	BSBW	FAO_CHECK		; ...LIB$SIGNAL's use of $PUTMSG
	PUSHL	R2			; Save flags and FAO count for $PUTMSG
	BEQL	10$			; BR if there are no FAO args
	PUSHL	#1			; There are args - save dummy for count
10$:
	ADDL3	#4,(SP)+,R2		; Pop bogus arg and get arg count
	MOVZWL	QUAD_STATUS,-(SP)	; Save the error status
	PUSHAL	GETDVI_FAIL		; Explain what went wrong
	PUSHL	#1
	PUSHL	#UETP$_TEXT!STS$K_ERROR
	PUSHL	R2			; Arg count for ERROR_EXIT
	BRW	ERROR_EXIT
20$:
	CMPB	#DC$_TERM,DEVBUF	; Were we invoked from a terminal?
	BNEQ	30$			; BR if not
	$ASSIGN_S DEVNAM = BUFFER_PTR,-	; Set up for CTRL/C ASTs if we were
		    CHAN = TTCHAN
	$QIOW_S	CHAN = TTCHAN,-		; Enable CTRL/C ASTs...
		FUNC = #IO$_SETMODE!IO$M_CTRLCAST,-
		  P1 = CCASTHAND
	PUSHAL	TEST_NAME		; ...and tell the user...
	PUSHL	#1
	PUSHL	#UETP$_ABORTC!STS$K_SUCCESS
	CALLS	#3,G^LIB$SIGNAL		; ...how to abort gracefully
;
; What we produce.
;
30$:
	$CREATE	FAB = INI_FAB,-		; Create UETINIDEV.DAT
		ERR = RMS_ERROR
	$CONNECT RAB = INI_RAB,-
		 ERR = RMS_ERROR
	MOVAL	CON_RAB,R11		; Set the RAB pointer for UETCONT00.DAT
	$CREATE FAB = CON_FAB,-		; Create UETCONT00.DAT
		ERR = RMS_ERROR
	$CONNECT RAB = (R11),-
		 ERR = RMS_ERROR
	CLRL	R10			; Initialize counter for overhead lines
40$:					; Write UETCONT00.DAT overhead lines
	MOVL	CONT00_OVERHEAD[R10],R9	; Point to the next ASCIC overhead line
	MOVZBW	(R9),RAB$W_RSZ(R11)	; Set the record size
	ADDL3	#1,R9,RAB$L_RBF(R11)	; Set the record address
	$PUT	RAB = (R11),-		; Write a line
		ERR = RMS_ERROR
	AOBLSS	#OVERHEAD_LENGTH,R10,40$ ; Repeat until overhead lines written
;
; What we need to use in order to produce.
;
	$OPEN	FAB = SUP_FAB,-		; Open UETSUPDEV.DAT
		ERR = RMS_ERROR
	$CRMPSC_S INADR = INADDRESS,-	; Create its global section
		   CHAN = SUP_FAB+FAB$L_STV,-
		 RETADR = OUTADDRESS,-
		 GSDNAM = SUPDEV_GBLSEC,-
		  FLAGS = #SEC$M_EXPREG!SEC$M_GBL
	$TRNLOG_S RSLBUF = FAO_BUF,-	; Get long or short report format
		  LOGNAM = REPORT_NAME
; We need not check SS$_NOTRAN; BUFFER will contain "REPORT" on errors.
	BICB2	#LC_BITM,BUFFER		; Convert to upper case
	CMPB	#^A/S/,BUFFER		; Do we want a short report?
	BNEQ	50$			; BR if not
	BISW2	#SHRT_RPRTM,FLAG	; Else set the short report flag bit
50$:
	$CRELOG_S TBLFLG = #1,-		; Set group logical name MODE...
		  LOGNAM = MODE,-	; ...to ONE
		  EQLNAM = EQUA1
	$CREMBX_S CHAN = MBXCHN		; Create subprocess termination mailbox
	$GETCHN_S CHAN = MBXCHN,-	; Get the mailbox unit number
		PRIBUF = DEV
	MOVW	DEVBUF+DIB$W_UNIT,MBX_UNIT ; Save the mailbox unit number
	$GETJPI_S ITMLST = JPI_LIST	; Get our current quotas, etc.
	$CREMBX_S CHAN   = MBX1_CHAN,-	; Create SYS$INPUT for subprocesses
		  MAXMSG = #MAX_DEV_DESIG,-
		  LOGNAM = TEST_NAME
; Fall into loop to build UETINIDEV.DAT.

;+
;	Form a representation in user mode P0 space of the devices which are
;	visible to this system.  Cull from the list those devices which we
;	know of, but know that we have no specific test for.  Cull from the
;	remainder those devices we don't know at all (i.e., devices which
;	don't appear in UETSUPDEV.DAT).  Use what remains to write
;	UETINIDEV.DAT.  See CLSIODB.MAR for a description of the database
;	we read.  Use the list to see which devices are really testable.
;
;	Note that R10 and R11 remain assigned throughout the range of
;	BUILD_INIDEV.
;-

	$CMKRNL_S ROUTIN = UETP$CLSIODB,- ; Form a list of devices we can see
		  ARGLST = CLSIODB_ARGLST
	BLBS	R0,110$			; BR if the list was formed
	MOVL	R0,R3			; Save status over routine call
	MOVL	R3,R2			; Set up arglist so we can appease...
	BSBW	FAO_CHECK		; ...LIB$SIGNAL's use of $PUTMSG
	PUSHL	R2			; Save flags and FAO count for $PUTMSG
	BEQL	100$			; BR if there are no FAO args
	PUSHL	#1			; There are args - save dummy for count
100$:
	ADDL3	#4,(SP)+,R2		; Pop bogus arg and get arg count
	PUSHL	R3			; Save the error status
	PUSHAL	CLSIODB_FAIL		; Explain what went wrong
	PUSHL	#1
	PUSHL	#UETP$_TEXT!STS$K_ERROR
	PUSHL	R2			; Arg count for ERROR_EXIT
	BRW	ERROR_EXIT
110$:

	SUBL3	OUTADDRESS,OUTADDRESS+4,R10 ; Figure UETSUPDEV section length
	MOVL	LCLPTR,R11		; Point to first local peripheral rec
	BSBB	BUILD_INIDEV		; Build UETINIDEV.DAT for local p's
	MOVL	MPMPTR,R11		; Point to first shared memory record
	BSBB	BUILD_INIDEV		; Build UETINIDEV.DAT for MPMs
	MOVL	CLSPTR,R11		; Point to first cluster periph. record
	BSBB	BUILD_INIDEV		; Build UETINIDEV.DAT for clus. periph.
	BRW	DO_SUMMARY		; Finish off with summary, etc.

BUILD_INIDEV:
	CASEB	UIDGNRC$B_TYPE(R11),-	; Dispatch based on record type...
		#UID$K_NULL_RTYPE,-	; ...in the list we just got
		#UID$K_END_RTYPE
10$:		.WORD	NULL_RECORD-10$
		.WORD	SID_RECORD-10$
		.WORD	PATH_RECORD-10$
		.WORD	DDB_RECORD-10$
		.WORD	UCB_RECORD-10$
		.WORD	MPM_RECORD-10$
		.WORD	END_RECORD-10$

; Still in BUILD_INIDEV loop.
; Fall into the routine for illegal or out of sequence record types.

;
; Null records are supposedly used as bookeeping and error recovery devices
; by UETP$CLSIODB.  However, there really is no case when they should appear.
;
NULL_RECORD:
;
; This can be reached two ways.  It is the default branch from the CASEB
; above, indicating an illegal record type was seen.  We also get here if
; a record is out of sequence, e.g., a UCB record precedes a DDB record.
;
PATH_RECORD:
UCB_RECORD:
	PUSHAL	BAD_P0_LIST		; Explain what went wrong
	PUSHL	#1
	PUSHL	#UETP$_TEXT!STS$K_ERROR
	PUSHL	#3			; Arg count for ERROR_EXIT
	BRW	ERROR_EXIT



;
; End records mark the end of a group of records returned by UETP$CLSIODB.
;
END_RECORD:
	RSB

; Still in BUILD_INIDEV loop.

;
; A system id record introduces a potential tree of DDB and UCB records for
; devices on that SCS cluster node.  Items for UETINIDEV.DAT will look similar
; to those for local devices, except that the DDB line will have the full SCS
; node name.  Once set up, we can use the same routines as local DDBs.
;
SID_RECORD:
	PUSHAB	UIDSID$T_NODENAME+1(R11)     ; Form descriptor...
	MOVZBL	UIDSID$T_NODENAME(R11),-(SP) ; ...to cluster node name
	MOVZWL	UIDGNRC$W_SIZE(R11),R0	; Get the length of this record...
	ADDL2	R0,R11			; ...so we can point to the next
10$:
	CMPB	#UID$K_DDB_RTYPE,-	; Is this a DDB record?
		UIDGNRC$B_TYPE(R11)
	BEQL	20$			; BR if so - we can process it
	POPR	#^M<R0,R1>		; Finished the tree - fix up stack...
	BRB	BUILD_INIDEV		; ...and look to the next tree
20$:

	MOVAB	UIDDDB$T_NAME+1(R11),R7	; From the ASCIC, form a descriptor...
	MOVZBL	-1(R7),R6		; ...to the controller name
	; See the note where KNOWN_BUT_NOT_TESTABLE table is defined.
	MATCHC	R6,(R7),#KBNT_LENGTH,-	; See if specific device is known...
		KNOWN_BUT_NOT_TESTABLE	; ...but not testable
	BEQL	30$			; BR if we found it in table
	SUBL3	#1,R7,R0		; See if generic device is known but...
	MATCHC	R6,(R0),#KBNT_LENGTH,-	; ...not testable. (We strip "c"...
		KNOWN_BUT_NOT_TESTABLE	; ...of "devc" but include ASCIC count)
	BNEQ	40$			; BR if device may be testable
30$:
	BSBW	SKIP_CLUS_RECORDS	; Device is not testable, skip it...
	BRB	10$			; ...and look to the next
40$:

	MOVQ	(SP),R4			; Restore desc for cluster node name
	ADDL3	R4,R6,DEVDSC		; Figure the length of...
	INCL	DEVDSC			; ...the complete cluster device name
	SUBL2	DEVDSC,SP		; Save the space to form a string
	MOVL	SP,DEVDSC+4		; Finish ASCID pointer to device name
	MOVC3	R4,(R5),(SP)		; Concatenate cluster node name...
	MOVB	#^A/$/,(R3)+		; ...with syntax character...
	MOVC3	R6,(R7),(R3)		; ...and with device name
	MOVB	DEVDSC,-(SP)		; Set up ASCIC device name on stack

	MOVZWL	UIDGNRC$W_SIZE(R11),R0	; Temporarily point...
	ADDL3	R0,R11,R8		; ...to the next record in the list
	CMPB	#UID$K_UCB_RTYPE,-	; Is this a UCB record?
		UIDGNRC$B_TYPE(R8)
	BEQL	50$			; BR if so
	BSBW	SKIP_CLUS_RECORDS	; We can't figure out device, skip it
	BRW	70$
50$:
	MOVZBL	UIDUCB$B_DEVCLASS(R8),R4 ; We now need to check to see...
	MOVZBL	UIDUCB$B_DEVTYPE(R8),R5  ; ...if this device is known to UETP
	$FAO_S	CTRSTR = CS1,-		; Try first for an exact match...
		OUTBUF = FAO_ALT,-
		OUTLEN = ALTBUF_PTR,-
		    P1 = R4,-
		    P2 = R5
	MATCHC	ALTBUF_PTR,ALTBUF,R10,-	; ...of device class and type
		@OUTADDRESS
	BEQL	60$			; BR if we have a hit
	$FAO_S	CTRSTR = CS3,-		; Next try a wildcard match...
		OUTBUF = FAO_ALT,-
		OUTLEN = ALTBUF_PTR,-	; ...on device class only
		    P1 = R4
	MATCHC	ALTBUF_PTR,ALTBUF,R10,-	; Match device class only
		@OUTADDRESS
	BEQL	60$			; BR if we matched
	BSBB	SUPDEV_CLUS_DENOSU	; We can't find device - complain...
	BRB	70$			; ...and skip to the next
60$:

	MOVL	SP,R5			; Save ASCIC pointer for $FAO
	$FAO_S	CTRSTR = DDB_CTRSTR,-	; Set up a default UETINIDEV DDB line
		OUTLEN = BUFFER_PTR,-
		OUTBUF = FAO_BUF,-
		P1     = R5
	BSBW	POTENTIALLY_OK		; Set up UETINIDEV.DAT
	BSBW	CREATE_SUBPROCESS	; See if the device is really testable
	BSBW	COPY_LOG_FILE		; Copy the results of the test
	BSBW	FINISH_CONTROLLER	; Analyze the results of the test
70$:
	INCL	SP			; Clean up ASCIC device name...
	ADDL2	DEVDSC,SP		; ...from the stack
	BRW	10$			; Loop to process next record

;
; We found a device class and type with no match in UETSUPDEV.DAT.  Complain
; and skip over it.
;
SUPDEV_CLUS_DENOSU:
	PUSHAL	DEVDSC			; No match at all,...
	PUSHAL	TEST_NAME		; ...so yell at the user
	PUSHL	#2
	PUSHL	#UETP$_DENOSU
	INSV	#STS$K_WARNING,-
		#STS$V_SEVERITY,-
		#STS$S_SEVERITY,(SP)	; Set the severity code
	CALLS	#4,G^LIB$SIGNAL		; And print the message
	;BSBB	SKIP_CLUS_RECORDS	; Fall into SKIP_CLUS_RECORDS
;
; We can't test this device for some reason, so skip over this DDB and any
; associated UCBs.  Any complaints about the situation have been issued.
; R11 still points to the DDB record from UETP$CLSIODB.  Note that we must
; look at each record we want to skip rather than chain to the next record
; of a specific type and that we skip the first record (DDB) without checking
; its type.
;
SKIP_CLUS_RECORDS:
	MOVZWL	UIDGNRC$W_SIZE(R11),R0	; Pick up the record length...
	ADDL2	R0,R11			; ...and point to the next record
	CMPB	#UID$K_UCB_RTYPE,-	; Is it a UCB record?
		UIDGNRC$B_TYPE(R11)
	BEQL	SKIP_CLUS_RECORDS	; Loop if so
	RSB

;
; A DDB record has a testable device if the DDB name doesn't appear on the
; list of known but untestable devices and if the first UCB attached to the
; DDB has a device class and type that match something in UETSUPDEV.DAT.
;
; Because the data returned for shared memory are similar to those for
; ordinary peripherals, we can share most of the same code.  We will
; occasionally need to pick up data from different places.
;
; R10 and R11 are already assigned as the length of the UETSUPDEV section
; and the pointer to the current I/O database record, respectively.
;
MPM_RECORD:
	MOVAB	MPM_LITERAL+1,R7	; Shared memory name is always "MPM"
	MOVZBL	-1(R7),R6		; Parallel actions for DDB record
	MOVQ	R6,DEVDSC		; Put desc in a safe place
	MOVL	R11,R8			; Fake a temp pointer to next record
	MOVC3	MPM_CS,MPM_CS+8,ALTBUF	; Fake $FAO device class and type
	MOVW	MPM_CS,ALTBUF_PTR	; Fake $FAO OUTLEN
	BRW	MPM_AND_DDB_BOTH


DDB_RECORD:
	MOVAB	UIDDDB$T_NAME+1(R11),R7	; From the ASCIC, form a descriptor...
	MOVZBL	-1(R7),DEVDSC		; ...
	MOVL	R7,DEVDSC+4		; ...to the controller name
	; See the note where KNOWN_BUT_NOT_TESTABLE table is defined.
	MATCHC	DEVDSC,(R7),#KBNT_LENGTH,- ; See if specific device is known...
		KNOWN_BUT_NOT_TESTABLE	   ; ...but not testable
	BEQL	10$			; BR if we found it in table
	SUBL3	#1,R7,R0		; See if generic device is known but...
	MATCHC	DEVDSC,(R0),#KBNT_LENGTH,- ; ...not testable. (We strip "c"...
		KNOWN_BUT_NOT_TESTABLE	; ...of "devc" but include ASCIC count)
	BNEQ	20$			; BR if device may be testable
10$:
	BRW	SKIP_RECORDS		; Device is not testable, skip it
20$:
	MOVZWL	UIDGNRC$W_SIZE(R11),R0	; Temporarily point...
	ADDL3	R0,R11,R8		; ...to the next record in the list
	CMPB	#UID$K_UCB_RTYPE,-	; Is this a UCB record?
		UIDGNRC$B_TYPE(R8)
	BEQL	30$
	BRW	SKIP_RECORDS		; BR if not, we can't figure out device
30$:	MOVZBL	UIDUCB$B_DEVCLASS(R8),R4 ; We now need to check to see...
	MOVZBL	UIDUCB$B_DEVTYPE(R8),R5  ; ...if this device is known to UETP
	$FAO_S	CTRSTR = CS1,-		; Try first for an exact match...
		OUTBUF = FAO_ALT,-
		OUTLEN = ALTBUF_PTR,-
		    P1 = R4,-
		    P2 = R5
	MATCHC	ALTBUF_PTR,ALTBUF,R10,-	; ...of device class and type
		@OUTADDRESS
	BEQL	SUPDEV_MATCH		; BR if we have a hit
	$FAO_S	CTRSTR = CS3,-		; Next try a wildcard match...
		OUTBUF = FAO_ALT,-
		OUTLEN = ALTBUF_PTR,-	; ...on device class only
		    P1 = R4

MPM_AND_DDB_BOTH:
	MATCHC	ALTBUF_PTR,ALTBUF,R10,-	; Match device class only
		@OUTADDRESS
	BNEQ	SUPDEV_DENOSU		; BR if we can't find this device
SUPDEV_MATCH:
	MOVAL	-1(R7),R5		; Save ASCIC pointer for $FAO
	$FAO_S	CTRSTR = DDB_CTRSTR,-	; Set up a default UETINIDEV DDB line
		OUTLEN = BUFFER_PTR,-
		OUTBUF = FAO_BUF,-
		P1     = R5
	BSBW	POTENTIALLY_OK		; Set up UETINIDEV.DAT
	BSBW	CREATE_SUBPROCESS	; See if the device is really testable
	BSBW	COPY_LOG_FILE		; Copy the results of the test
	BSBW	FINISH_CONTROLLER	; Analyze the results of the test
	BRW	BUILD_INIDEV		; Loop for the next device

;
; We found a device class and type with no match in UETSUPDEV.DAT.  Complain
; and skip over it.
;
SUPDEV_DENOSU:
	PUSHAL	DEVDSC			; No match at all,...
	PUSHAL	TEST_NAME		; ...so yell at the user
	PUSHL	#2
	PUSHL	#UETP$_DENOSU
	INSV	#STS$K_WARNING,-
		#STS$V_SEVERITY,-
		#STS$S_SEVERITY,(SP)	; Set the severity code
	CALLS	#4,G^LIB$SIGNAL		; And print the message
	;BRB	SKIP_RECORDS		; Fall into SKIP_RECORDS
;
; We can't test this device for some reason, so skip over records until we
; get to the next DDB or MPM in the UETP$CLSIODB group.  Any complaints about
; the situation have been issued.  R11 still points to the original DDB or
; MPM record from UETP$CLSIODB.  Note that we must look at each record as we
; skip over it rather than chain directly to the next record of a given type.
;
SKIP_RECORDS:
	MOVL	#UID$K_UCB_RTYPE,R6	; Assume we will skip UCB records
	CMPB	#UID$K_DDB_RTYPE,-	; See what we are actually skipping
		UIDGNRC$B_TYPE(R11)
	BEQL	10$			; BR if our assumption was correct
	MOVL	#UID$K_NULL_RTYPE,R6	; We will skip exactly one MPM record
10$:
	MOVZWL	UIDGNRC$W_SIZE(R11),R0	; Pick up the record length...
	ADDL2	R0,R11			; ...and point to the next record
	CMPB	R6,UIDGNRC$B_TYPE(R11)	; Is this a record we want to skip?
	BEQL	10$			; BR if it is
	BRW	BUILD_INIDEV		; We've skipped intervening records

	.SBTTL	Summarize UETINIDEV.DAT

;+
;	We've tried out all the supportable devices in the system and have
;	listed in UETINIDEV.DAT the testable/non-testable status of each.
;	Summarize those results in a more humanly readable form.  We will
;	keep certain register assignments throughout the summary:
;		R11 - Pointer to RAB for UETINIDEV.DAT
;		R10 - Count of characters on a line.  May use ALTBUF(R10)
;		R9  - Unit record type (T or N) targetted by APPEND_UNITS
;		R8  - Count of unwanted records found by APPEND_UNITS
;		R7  - Pointer to string descriptor for SUMM_OUTPUT
;-

DO_SUMMARY:
	MOVAL	INI_RAB,R11		; Keep pointer handy to UETINIDEV
	MOVAL	END_MSG,RAB$L_RBF(R11)	; Set the end message address
	MOVW	#END_MSGL,RAB$W_RSZ(R11) ; Set the end message size
	$PUT	RAB = (R11),-		; Write the end message
		ERR = RMS_ERROR
	$FLUSH	RAB = (R11),-		; Make sure everything gets output
		ERR = RMS_ERROR
	$REWIND	RAB = (R11),-		; Go back to beginning of UETINIDEV
		ERR = RMS_ERROR
	MOVAL	ALTBUF_PTR,R7		; Skip a line before we start...
	CLRW	(R7)			; ...
	BSBW	SUMM_OUTPUT		; ...
	MOVAL	SUMM_HEADER,R7		; Set up to output summary header
	BSBW	SUMM_OUTPUT		; Go output line
	MOVAL	ALTBUF_PTR,R7		; We'll write from here, evermore
	$GET	RAB = (R11),-		; Prime pump with the first DDB record
		ERR = RMS_ERROR
DDB_LOOP:
	CLRW	(R7)			; Skip a line between controllers
	BSBW	SUMM_OUTPUT		; Go output empty line
	CMPB	#^A/D/,BUFFER		; Is the next line for a DDB?
	BEQL	20$			; BR if it is
	CMPB	#^A/E/,BUFFER		; Or is it the end of UETINIDEV.DAT?
	BNEQ	10$			; BR if not - we have an error
	BRW	SUC_EXIT		; Summary complete, finish UETINIT01
10$:
	PUSHAL	FORMAT_ERR_MSG		; Something is wrong with...
	PUSHL	#1			; ...UETINIDEV.DAT - output msg and...
	PUSHL	#UETP$_TEXT!STS$K_ERROR	; ...quit
	PUSHL	#3			; Current arg count
	BRW	ERROR_EXIT
20$:
;
; We have a DDB line from UETINDEV.DAT.  We know that if the controller is
; not testable, no devices will be testable (FINISH_CONTROLLER routine).
;
	MOVC3	#TESTABLE_LEN,TESTABLE,- ; Set up initial msg
		ALTBUF
	MOVL	#TESTABLE_LEN,R10	; Set up count of chars on line
	SUBW3	#6,RAB$W_RSZ(R11),R0	; Calc controller name length
	MOVC3	R0,BUFFER+6,ALTBUF	; Put controller name in output...
					; ...buffer, overwriting blanks
	MOVB	#^A/:/,(R3)		; Insert ":" after controller name
	$FIND	RAB = (R11),-		; Move RFA to the first UCB...
		ERR = RMS_ERROR		; ...but leave BUFFER unscathed
	MOVC3	#6,RAB$W_RFA(R11),END_RFA ; Save 1st UCB RFA for poss reread
	CMPB	#^A/T/,BUFFER+4		; Is DDB marked testable?
	BEQL	UCB_T			; BR if it is
	MOVC3	#NONE_LEN,NONE,-	; Indicate DDB has no testable units
		ALTBUF+TESTABLE_LEN
	MOVW	#TESTABLE_LEN+NONE_LEN,(R7) ; Set line length indicating that
	BSBW	SUMM_OUTPUT		; Write the line
	BRB	UCB_N			; Now summarize the untestable units
UCB_T:
	MOVZBL	#^A/T/,R9		; We will search for testable units
	BSBW	APPEND_UNITS		; Form line(s) of testable units
	TSTL	R8			; Any untestable units found?
	BEQL	DDB_LOOP		; Get next controller if not
	MOVB	#RAB$C_RFA,RAB$B_RAC(R11) ; Some untestables - we must reread
	MOVC3	#6,END_RFA,RAB$W_RFA(R11) ; Point us back to first UCB
UCB_N:
	MOVC3	#TESTABLE_LEN,-		; Set up a line for untestable units
		UNTESTABLE,ALTBUF
	MOVL	#TESTABLE_LEN,R10	; Set up count of chars on line
	MOVZBL	#^A/N/,R9		; We'll search for untestable units
	BSBW	APPEND_UNITS		; Form line(s) of untestable units
	BRW	DDB_LOOP		; This controller is summarized

;
; Append unit numbers to a line.  Wrap around to a new line if the line gets
; too long.  Write out the lines when done or when wrapping to a new line.
; Register assignments are listed near DO_SUMMARY.
;
APPEND_UNITS:
	CLRL	R8			; Init counter of unwanted records
10$:
	$GET	RAB = (R11),-		; Get some record - our access mode...
		ERR = RMS_ERROR		; ...is determined externally
	MOVB	#RAB$C_SEQ,RAB$B_RAC(R11) ; We must read UCBs sequentially
	CMPB	#^A/U/,BUFFER		; Have we a UCB?
	BEQL	20$			; Continue on if so
	SUBW3	#2,R10,(R7)		; Write line, stripping separator
	BRB	SUMM_OUTPUT		; Exit APPEND_UNITS via SUMM_OUTPUT
20$:
	CMPB	R9,BUFFER+4		; Is this the kind of unit we want?
	BEQL	30$			; BR if so
	INCL	R8			; Count opposites if not
	BRB	10$			; Continue with next record
30$:
	SKPC	#^A/0/,#MAX_UNIT_DESIG-1,- ; Skip over leading zeros...
		BUFFER+6		   ; ...in unit number
	INCL	R0			; Compensate for short length search
	ADDW3	#2,R0,R2		; Figure out if we can...
	ADDW2	R10,R2			; ...fit unit number and separator...
	CMPW	#MAX_SUMM_LINE,R2	; ...on this line
	BGEQ	40$			; BR if we will fit
	MOVW	R10,(R7)		; We need to wrap to a new line
	PUSHR	#^M<R0,R1>		; Save these over routine call
	BSBB	SUMM_OUTPUT		; Write out the old line first
	MOVC5	#0,#0,#^A/ /,-		; Start out the next line by lining...
		#TESTABLE_LEN,ALTBUF	; ...up next unit beneath the first
	MOVL	#TESTABLE_LEN,R10	; Reinitialize character count on line
	POPR	#^M<R0,R1>		; Restore length and pointer to unit
40$:
	MOVC3	R0,(R1),ALTBUF(R10)	; Append the unit to the line
	MOVW	#^A/, /,(R3)+		; Append separator to that
	SUBL3	#ALTBUF,R3,R10		; Calculate new line length
	BRB	10$			; Go look for the next unit

;
; Write a line to the UETINIT01 log file.  If long report is specified,
; write that same line to SYS$OUTPUT also.
;
SUMM_OUTPUT:
	MOVW	(R7),LOG_RAB+RAB$W_RSZ	; Get the message size
	MOVL	4(R7),LOG_RAB+RAB$L_RBF ; Set the message address
	$PUT	RAB = LOG_RAB,-		; Write the log file
		ERR = RMS_ERROR
	BBS	#SHRT_RPRTV,FLAG,10$	; Skip if short report
	MOVL	R7,MSG_PTR		; Set up $PUTMSG message descriptor
	$PUTMSG_S MSGVEC = LOG_RCD	; Write everything to SYS$OUTPUT
10$:
	RSB

	.SBTTL	Close Up Shop

SUC_EXIT:
	$FAO_S	CTRSTR = TST_CNT_STR,-	; Create a string giving...
		OUTBUF = FAO_BUF,-	; ...the number of testable controllers
		OUTLEN = BUFFER_PTR,-
		P1     = TST_CNT
	$CRELOG_S TBLFLG = #1,-		; Create a logical name for...
		  LOGNAM = TEST_COUNT,-	; ...the count of testable controllers
		  EQLNAM = BUFFER_PTR
	MOVL	#SS$_NORMAL!STS$M_INHIB_MSG,- ; Set successful exit status
		STATUS
	$EXIT_S STATUS			; Exit with the status

	.SBTTL	BUILD_INIDEV Routines - POTENTIALLY_OK
;
; We have a device (controller and unit number) that we've identified as
; potentially testable.  To see if it really is, have its associated image
; (from UETSUPDEV) check out each unit.  The DDB and UCB or MPM info has to be
; written to UETINIDEV for that.  The DDB line is described by BUFFER_PTR and
; R8 points to the first UCB or MPM record.  R3 is left over from a MATCHC.
; We are still in the BUILD_INIDEV loop, so R10 and R11 are in use as
; described therein.
;
POTENTIALLY_OK:
	MOVL	R3,R9			; Save pointer to start of image name
	MOVL	R8,R11			; It's safe to update real database ptr
	MOVW	BUFFER_PTR,-		; Set line size
		INI_RAB+RAB$W_RSZ
	$PUT	RAB = INI_RAB,-		; Write a UETINIDEV.DAT line...
		ERR = RMS_ERROR		; ...for the DDB or MPM
	MOVC3	#6,INI_RAB+RAB$W_RFA,-	; Save RFA so we can reread record
		DDB_RFA
10$:
	MOVZWL	UIDUCB$W_NUMBER(R11),R6	; Assume we're looking at a UCB
	CMPB	#UID$K_UCB_RTYPE,-	; But are we really?
		UIDGNRC$B_TYPE(R11)
	BEQL	20$			; BR if we are
	MOVZWL	UIDMPM$W_NUMBER(R11),R6	; Get the equivalent MPM value if not
20$:
	$FAO_S	CTRSTR = UCB_CTRSTR,-	; Form a UETINIDEV line for UCB or MPM
		OUTLEN = BUFFER_PTR,-
		OUTBUF = FAO_BUF,-
		    P1 = R6
	MOVW	BUFFER_PTR,-		; Set line size
		INI_RAB+RAB$W_RSZ
	$PUT	RAB = INI_RAB,-		; Write a UETINIDEV.DAT line...
		ERR = RMS_ERROR		; ...for the UCB or MPM
	MOVZWL	UIDGNRC$W_SIZE(R11),R0	; Pick up the record length...
	ADDL2	R0,R11			; ...to point to the next record
	CMPB	#UID$K_UCB_RTYPE,-	; Is this also a UCB?
		UIDGNRC$B_TYPE(R11)
	BEQL	10$			; BR if it is
	CMPB	#UID$K_MPM_RTYPE,-	; Or is this also an MPM record?
		UIDGNRC$B_TYPE(R11)
	BEQL	10$			; BR if it is

	MOVAL	END_MSG,INI_RAB+RAB$L_RBF ; Set up to write end-of-file line
	MOVW	#END_MSGL,INI_RAB+RAB$W_RSZ
	$PUT	RAB = INI_RAB,-		; Write the end of file line
		ERR = RMS_ERROR
	MOVC3	#6,INI_RAB+RAB$W_RFA,-	; Save the RFA of the END line...
		END_RFA			; ...to make truncation faster
	$FLUSH	RAB = INI_RAB,-		; Make sure the device test sees...
		ERR = RMS_ERROR		; ...everything we think we wrote
	MOVAL	BUFFER,INI_RAB+RAB$L_RBF ; Restore typical buffer address
	RSB

	.SBTTL	BUILD_INIDEV Routines - CREATE_SUBPROCESS
;
; Make the sub-process which will see if the devices found above have any
; testable units.  R9 still points to the start of the image name from
; the UETSUPDEV global section.  R10 and R11 are in use from BUILD_INIDEV.
;
CREATE_SUBPROCESS:
	BBS	#SHRT_RPRTV,FLAG,10$	; Skip separation if short report
	$PUTMSG_S MSGVEC = BLANK_LINE_PTR,- ; Separate all of this process'...
		  ACTRTN = ACTRTN	    ; ...msg's from the previous one's
10$:	$QIOW_S	CHAN = MBX1_CHAN,-	; Tell process's SYS$INPUT what to test
		 EFN = #SS_SYNCH_EFN,-
		FUNC = #IO$_WRITEVBLK!IO$M_NOW,-
		IOSB = QUAD_STATUS,-
		  P1 = @DEVDSC+4,-
		  P2 = DEVDSC
	BLBS	QUAD_STATUS,30$		; BR if all went OK
	MOVZWL	QUAD_STATUS,R2		; Set up arglist so we can appease...
	BSBW	FAO_CHECK		; ...LIB$SIGNAL's use of $PUTMSG
	PUSHL	R2			; Save flags and FAO count for $PUTMSG
	BEQL	20$			; BR if there are no FAO args
	PUSHL	#1			; There are args - save dummy for count
20$:
	ADDL3	#4,(SP)+,R2		; Pop bogus arg and get arg count
	MOVZWL	QUAD_STATUS,-(SP)	; Save the error status
	PUSHAL	MBXW_QIO_FAIL		; Explain what went wrong
	PUSHL	#1
	PUSHL	#UETP$_TEXT!STS$K_ERROR
	PUSHL	R2			; Arg count for ERROR_EXIT
	BRW	ERROR_EXIT
30$:
	MOVC3	TEST_DSC,(R9),TEST_IMAGE ; Set up image filespec to test device
	MOVZWL	TEST_DSC,LOGNAM_DSC	   ; SYS$OUTPUT for that image...
	MOVC3	TEST_DSC,TEST_IMAGE,LOGNAM ; ...will be the image name...
	LOCC	#^A/./,LOGNAM_DSC,LOGNAM   ; ...but have a file type...
	MOVL	LOGEXT,(R1)		   ; ...of of .LOG
	$CREPRC_S IMAGE  = TEST_DSC,-	; Create the subprocess to test device
		  PIDADR = PIDADR,-
		  INPUT  = TEST_NAME,-
                  OUTPUT = LOGNAM_DSC,-
		  ERROR  = SUBPROC_ERROR,-
		  QUOTA  = QUOTA_LIST,-
		  MBXUNT = MBX_UNIT
	$SETIMR_S DAYTIM = THREEMIN,-	; Set up a timer to catch test hangs
		  ASTADR = KILL_SUBPROCESS,-
		  REQIDT = PIDADR
	$QIOW_S	CHAN = MBXCHN,-		; Set up read for termination mailbox 
		 EFN = #SS_SYNCH_EFN,-
		FUNC = #IO$_READVBLK,-
		IOSB = QUAD_STATUS,-
		  P1 = MBX_BUF,-
		  P2 = #MBX_SIZE
	$CANTIM_S REQIDT = PIDADR	; QIOW finished, we're no longer hung
	CLRL	PIDADR			; Indicate to us that proc is finished
	BLBS	QUAD_STATUS,50$		; BR if all went OK
	MOVZWL	#SS$_OPINCOMPL,-	; Assume for now that we $CANCELled...
		MBX_BUF+ACC$L_FINALSTS	; ...the QIOW
	CMPW	#SS$_CANCEL,QUAD_STATUS	; But did we really?
	BEQL	50$			; BR if so, we can recover
	CMPW	#SS$_ABORT,QUAD_STATUS	; We get SS$_ABORT if I/O in progress
	BEQL	50$			; BR if so, we can recover
	MOVZWL	QUAD_STATUS,R2		; Set up arglist so we can appease...
	BSBW	FAO_CHECK		; ...LIB$SIGNAL's use of $PUTMSG
	PUSHL	R2			; Save flags and FAO count for $PUTMSG
	BEQL	40$			; BR if there are no FAO args
	PUSHL	#1			; There are args - save dummy for count
40$:
	ADDL3	#4,(SP)+,R2		; Pop bogus arg and get arg count
	MOVZWL	QUAD_STATUS,-(SP)	; Save the error status
	PUSHAL	CREPRC_QIO_FAIL		; Explain what went wrong
	PUSHL	#1
	PUSHL	#UETP$_TEXT!STS$K_ERROR
	PUSHL	R2			; Arg count for ERROR_EXIT
	BRW	ERROR_EXIT
50$:
	MOVL	MBX_BUF+ACC$L_FINALSTS,R2 ; Save termination status
	BNEQ	60$			  ; BR if we got a real status
	MOVL	#SS$_ABORT,R2		  ; No status, must have been...
					  ; ...$DELPRC, so give a dummy status
	MOVL	R2,MBX_BUF+ACC$L_FINALSTS ; Save status here, too
60$:
	BLBS	R2,80$			  ; BR if process completed OK
	$FAO_S	CTRSTR = SUBPROCESS_FAIL,- ; Give some indication now...
		OUTLEN = BUFFER_PTR,-	   ; ...if the subprocess failed...
		OUTBUF = FAO_BUF,-	   ; ...so that we don't just...
		    P1 = #TEST_DSC,-	   ; ...die suddenly...
		    P2 = #DEVDSC	   ; ...if there's some other problem
	BSBW	FAO_CHECK		; See if error takes any FAO args
	PUSHL	R2			; Save flags/FAO count for LIB$SIGNAL
	BEQL	70$			; BR if there are no FAO args
	PUSHL	#1			; There are args - save dummy for count
70$:
	ADDL3	#4,(SP)+,R2		; Pop bogus arg and get arg count
	PUSHL	MBX_BUF+ACC$L_FINALSTS
	BICL	#STS$M_INHIB_MSG,(SP)	; Allow message to be printed, always!
	PUSHAL	BUFFER_PTR
	PUSHL	#^XF0001
	PUSHL	#UETP$_TEXT!STS$K_ERROR
	CALLS	R2,ERROR_MSG		; Note that we don't exit on this error
	$QIO_S	CHAN = MBX1_CHAN,-	; Throw away "SYS$INPUT" message,...
		FUNC = #IO$_READVBLK!IO$M_NOW,-
		  P1 = @DEVDSC+4,-	; ...it can screw up...
		  P2 = DEVDSC		; ...the next subprocess we create
80$:
	RSB

	.SBTTL	BUILD_INIDEV Routines - COPY_LOG_FILE
;
; Copy the log file of the process which just finished to our own log file.
; If we are in "long report" mode, also copy the part of the log file between
; the begining and ending "sentinels" (inclusive) to SYS$OUTPUT.  R10 and R11
; are in use from BUILD_INIDEV.
;
COPY_LOG_FILE:
	MOVB	LOGNAM_DSC,-		; Set the file name size
		TMPLOG_FAB+FAB$B_FNS
	MOVAL	LOGNAM,TMPLOG_FAB+FAB$L_FNA ; Set the file name address
	MOVAL	BUFFER,LOG_RAB+RAB$L_RBF ; Set the buffer write address
	$OPEN	FAB = TMPLOG_FAB	; Open the temp log file
	BLBS	R0,20$			; BR if we can read it
	MOVAL	FNF_MSG,R1		; Assume the error was a missing log
	CMPL	#RMS$_FNF,R0		; Is the log file missing?
	BEQL	10$			; BR if so - a special case
	MOVAL	FLK_MSG,R1		; Assume now that the log was locked
	CMPL	#RMS$_FLK,R0		; Did the process not terminate?
	BEQL	10$			; BR if so - a special case
	PUSHAL	TMPLOG_FAB		; There's some other error, so...
	CALLS	#1,RMS_ERROR		; ...exit with a useful message
10$:
	$FAO_S	CTRSTR = (R1),-		; Recover from this error,...
		OUTLEN = BUFFER_PTR,-	; ...because it's probably...
		OUTBUF = FAO_BUF,-	; ...a fault somewhere else,...
		    P1 = #LOGNAM_DSC,-	; ...but complain
		    P2 = #DEVDSC
	PUSHAL	BUFFER_PTR		; Set up to give the message
	PUSHL	#^XF0001
	PUSHL	#UETP$_TEXT!STS$K_ERROR
	CALLS	#3,ERROR_MSG
	RSB
20$:
	$CONNECT RAB = TMPLOG_RAB,-	; Connect the temp log file
		 ERR = RMS_ERROR
	BBS	#SHRT_RPRTV,FLAG,30$	; Skip announcement in short report
	MOVC3	DEVDSC,@DEVDSC+4,-	; Form message telling device to test...
		TESTING_MSG_TEXT
	ADDW3	#TESTING_MSG_LENGTH,-	; ...and its length
		DEVDSC,TESTING_MSG
	$PUTMSG_S MSGVEC = LOG_BEGIN,-	; Give msg saying what we're about to do
		  ACTRTN = ACTRTN
30$:
	BSBW	COPY_RECORD		; Copy from temp log to our log file
	BLBC	R0,70$			; BR on any error
	MATCHC	START_DESC,START_DESC+8,- ; Did we find beginning sentinel?
		TEMP_BUFF_DESC,TEMP_BUFF_STR
	BNEQ	30$			; Loop if not
	BBS	#SHRT_RPRTV,FLAG,40$	; Sentinel to only log if short report
	$PUTMSG_S MSGVEC = LOG_RCD	; Copy sentinel line to SYS$OUTPUT
40$:
	BSBB	COPY_RECORD		; Copy from temp log to our log file
	BLBC	R0,70$			; BR on any error
	MATCHC	STOP_DESC,STOP_DESC+8,-	; Did we find ending sentinel?
		TEMP_BUFF_DESC,TEMP_BUFF_STR
	BEQL	50$			; Exit loop if we did
	$PUTMSG_S MSGVEC = LOG_RCD	; Copy a line to SYS$OUTPUT
	BRB	40$			; Loop for another temp log record
50$:
	BBS	#SHRT_RPRTV,FLAG,60$	; Sentinel to only log if short report
	$PUTMSG_S MSGVEC = LOG_RCD	; Copy sentinel line to SYS$OUTPUT
60$:
	BSBB	COPY_RECORD		; Copy from temp log to our log file
	BLBS	R0,60$			; Loop while there are more records
70$:
	$CLOSE	FAB = TMPLOG_FAB,-	; Close the temp log file
		ERR = RMS_ERROR
	$ERASE	FAB = TMPLOG_FAB,-	; Delete the temp log file
		ERR = RMS_ERROR
	RSB				; Exit copy loop

;
; Massage a record from the (temp) log file of a device test process that's just
; finished.  Massaging includes reading the record, indenting it from the left
; margin, and forming an uppercase copy of the record so that it may be checked
; for a beginning or ending sentinel.
;
COPY_RECORD:
	$GET	RAB = TMPLOG_RAB	; Read a temp log record
	BLBS	R0,20$			; BR if we have no error
	CMPL	#RMS$_EOF,R0		; Is it EOF, i.e., reasonable error?
	BEQL	10$			; BR if so
	PUSHAL	TMPLOG_RAB		; We have some unknown error...
	CALLS	#1,RMS_ERROR		; ...so let RMS error handler eat it
10$:	RSB
20$:
	MOVL	TMPLOG_RAB+RAB$L_RBF,R1	; R1 and R0 are a string desc...
	MOVZWL	TMPLOG_RAB+RAB$W_RSZ,R0	; ...for the remainder of the record
	MOVW	R0,-(SP)		; Counts chars as indentation is done
	BRB	50$			; BR inside loop - indent string's start
30$:	LOCC	#13,R0,(R1)		; Is there a <RET> in rest of string?
	BEQL	60$			; Exit loop if not - no more indent
	DECL	R0			; Found one. LOCC has us pointing at it
	INCL	R1			; Point past the <RET>
	CMPB	#10,(R1)		; Is there a <LINEFEED>?
	BNEQ	40$			; BR if we need not skip <LINEFEED>
	DECL	R0			; Must pass over <LF>...
	INCL	R1			; ...since they're new line to printers
40$:	CMPB	#9,(R1)			; Is there a <TAB> at start of line?
	BNEQ	50$			; BR if not - we can start indenting
	DECL	R0			; Must pass over the <TAB>
	INCL	R1			; More of passing over the <TAB>
	BRB	40$			; Inner loop to find multiple <TAB>s
50$:	TSTL	R0			; If we're at the end of the string...
	BEQL	60$			; ...we can exit the outer loop
	PUSHR	#^M<R0,R1>		; Save desc to rest of string
	MOVC3	R0,(R1),INDENT(R1)	; Indent the rest of the string
	MOVC5	#0,#0,#^A/ /,#INDENT,@4(SP) ; Fill indented spaces with blanks
	POPR	#^M<R0,R1>		; Restore desc to rest of string
	ADDL2	#INDENT,R1		; Point beyond the spaces just inserted
	ADDW2	#INDENT,(SP)		; Count total length incl. indentation
	BRB	30$			; Loop to see if we need indent again
60$:
	MOVW	(SP),LOG_RAB+RAB$W_RSZ	; Set log rec size from indented rec
	$PUT	RAB = LOG_RAB,-		; Copy the record
		ERR = RMS_ERROR
	MOVW	(SP)+,BUFFER_PTR	; Set size of indented record...
	PUSHAQ	BUFFER_PTR		; ...so we can make it...
	PUSHAQ	TEMP_BUFF_DESC
	CALLS	#2,G^STR$UPCASE		; ...uniform case for sentinel checking
	MOVZBL	#SS$_NORMAL,R0
	RSB

	.SBTTL	BUILD_INIDEV Routines - FINISH_CONTROLLER
;
; We now have to check up on the subprocess we created to see what it really
; did to UETINIDEV.DAT.  If the process failed or found no testable units, the
; DDB and UCB lines will be marked untestable.  If it found testable units,
; write a line to UETCONT00.DAT so the device will be tested in the Device
; Test phase.  Remove the end-of-file record from UETINIDEV because there are
; probably more devices to check.  We'll rewrite the record if we really have
; finished testing.  For convenient access, R6 will point to INI_RAB and R7
; will point to CON_RAB.  R10 and R11 are in use from BUILD_INIDEV.
;
FINISH_CONTROLLER:
	MOVAL	INI_RAB,R6		; Set up...
	MOVAL	CON_RAB,R7		; ...convenient RAB pointers
	MOVB	#RAB$C_RFA,RAB$B_RAC(R6) ; Set RFA mode
	MOVC3	#6,DDB_RFA,RAB$W_RFA(R6) ; Set RFA to point to the DDB line
	$GET	RAB = (R6),-		; Go back to the DDB record
		ERR = RMS_ERROR
	CMPB	#^A/N/,BUFFER+4		; Any testable devices?
	BEQL	10$			; BR if not
	BLBS	MBX_BUF+ACC$L_FINALSTS,30$ ; All was OK if success status
10$:
	MOVB	#RAB$C_SEQ,RAB$B_RAC(R6) ; Reset UETINIDEV to sequential access
20$:
	MOVB	#^A/N/,BUFFER+4		; Set DDB or UCB not testable
	$UPDATE	RAB = (R6)		; Update each record
	$GET	RAB = (R6),-		; Get a UCB record
		ERR = RMS_ERROR
	CMPC3	#6,RAB$W_RFA(R6),END_RFA ; Are all records updated?
	BNEQ	20$			; Loop if not
	BRB	40$			; Skip success stuff if so
30$:
	$FAO_S	CTRSTR = CONT_STR,-	; Make the UETCONT00 record
		OUTBUF = FAO_ALT,-
		OUTLEN = ALTBUF_PTR,-
		    P1 = #TEST_DSC,-
		    P2 = #DEVDSC
	MOVW	ALTBUF_PTR,RAB$W_RSZ(R7) ; Set the record size
	MOVAL	ALTBUF,RAB$L_RBF(R7)	; Set the record address
	$PUT	RAB = (R7),-		; Write the record
		ERR = RMS_ERROR
	INCL	TST_CNT			; One more device test to run
	MOVB	#RAB$C_RFA,RAB$B_RAC(R6) ; Set RFA mode in UETINIDEV.DAT
	MOVC3	#6,END_RFA,RAB$W_RFA(R6) ; Point to the END line in UETINIDEV
	$FIND	RAB = (R6),-		; Get the END line as current
		ERR = RMS_ERROR
	MOVB	#RAB$C_SEQ,RAB$B_RAC(R6) ; Reset UETINIDEV to sequential access
40$:
	$TRUNCATE RAB = (R6),-		; Eat the END OF UETINDEV.DAT line
		  ERR = RMS_ERROR
	RSB

	.SBTTL	Stop a Subprocess
;++
; FUNCTIONAL DESCRIPTION:
;	We must terminate a subprocess either because it seems to be hung or
;	because UETINIT01 is terminating.  Fix things up so we can try to
;	continue with the next controller in the system, if need be.
;
; CALLING SEQUENCE:
;	Called at AST level
;
; INPUT PARAMETERS:
;	04(AP) - PID of the subprocess we must terminate
;
; IMPLICIT INPUTS:
;	DEVDSC has the name of the controller we wanted to test.
;	TEST_DSC has the name of the image to test the controller.
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	NONE
;
; COMPLETION CODES:
;	Value from ERROR_MSG.
;
; SIDE EFFECTS:
;	Subprocess is deleted, if it was created.
;	Error message given.
;--

KILL_SUBPROCESS:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Entry mask

	TSTL	04(AP)			; Was the subprocess created?
	BEQL	10$			; BR if not
	$DELPRC_S PIDADR = 04(AP)	; Ensure that the subprocess dies
	$FAO_S	CTRSTR = PROCESS_STOP_MSG,- ; Indicate what happened
		OUTBUF = FAO_BUF,-
		OUTLEN = BUFFER_PTR,-
		P1     = #TEST_DSC,-
		P2     = #DEVDSC,-
		P3     = #0
	PUSHAL	BUFFER_PTR
	PUSHL	#^XF0001
	PUSHL	#UETP$_TEXT!STS$K_ERROR
	CALLS	#3,ERROR_MSG
	$SETIMR_S DAYTIM = ONEMIN,-	; Another timer will catch cases...
		  ASTADR = PASS_OVER_SUBPROCESS,-
		  REQIDT = PIDADR	; ...where $DELPRC isn't enough
10$:
	RET

	.SBTTL	Pass Over a Subprocess If $DELPRC Fails
;++
; FUNCTIONAL DESCRIPTION:
;	Image rundown has not yet terminated a process we believe to be hung
;	(KILL_SUBPROCESS).  We can do no more, so prevent further waiting for
;	the process' termination mailbox.
;
; CALLING SEQUENCE:
;	Called at AST level
;
; INPUT PARAMETERS:
;	04(AP) - PID of the subprocess we must terminate
;
; IMPLICIT INPUTS:
;	DEVDSC has the name of the controller we wanted to test.
;	TEST_DSC has the name of the image to test the controller.
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	NONE
;
; COMPLETION CODES:
;	Value from ERROR_MSG.
;
; SIDE EFFECTS:
;	$QIOW is cancelled for termination mailbox.
;	Error message given.
;--

PASS_OVER_SUBPROCESS:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Entry mask

	$CANCEL_S CHAN = MBXCHN		; Stop waiting for termination mailbox
	$FAO_S	CTRSTR = PASS_OVER_MSG,- ; Indicate what happened
		OUTBUF = FAO_BUF,-
		OUTLEN = BUFFER_PTR,-
		P1     = #TEST_DSC,-
		P2     = #DEVDSC,-
		P3     = #0
	PUSHAL	BUFFER_PTR
	PUSHL	#^XF0001
	PUSHL	#UETP$_TEXT!STS$K_ERROR
	CALLS	#3,ERROR_MSG
	RET

	.SBTTL	Check Whether a Message Needs $FAO Arguments
;++
; FUNCTIONAL DESCRIPTION:
;	To enable more useful error messages, we'd like to print out the
;	message associated with failures as well as the message we provide
;	ourself.  Some of those messages have $FAO arguments, the values
;	for which are lost.  Provide a $PUTMSG length of zero and a set of
;	appropriate flag bits so that messages which have no arguments get
;	printed in their entirety but those that do have arguments omit the
;	text part.
;
; CALLING SEQUENCE:
;	MOVL	status,R2
;	BSBW	FAO_CHECK
;
; IMPLICIT INPUTS:
;	R2 has the status to check.
;
; IMPLICIT OUTPUTS:
;	R2 returns a flag-length longword suitable for $PUTMSG or zero (to
;		indicate a null message).
;
; SIDE EFFECTS:
;	ALTBUF, ALTBUF_PTR and MSG_BLOCK get written into.
;--

FAO_CHECK:
	$GETMSG_S MSGID = R2,-		; Check if we need flags to suppress...
		 MSGLEN = ALTBUF_PTR,-
		 BUFADR = FAO_ALT,-
		  FLAGS = #0,-
		 OUTADR = MSG_BLOCK
	TSTB	MSG_BLOCK+1		; ...any $FAO args in message text
	BNEQ	10$			; BR if there are $FAO args
	CLRL	R2			; Set flags arg to look like null msg
	RSB
10$:
	MOVL	#^XE0000,R2		; Suppress the text of the message
	RSB

	.SBTTL	System Service Exception Handler
;++
; FUNCTIONAL DESCRIPTION:
;	This routine is executed if a system service or RMS error occurs or
;	if a LIB$SIGNAL system service is used to output a message.
;
; CALLING SEQUENCE:
;	Entered via an exception from the system
;
; INPUT PARAMETERS:
;	ERROR_COUNT   = previous cumulative error count
;	                -----------------
;	   AP ---->     !       2       !
;			!---------------!
;			! SIGNL ARY PNT !
;			!---------------!
;			! MECH  ARY PNT !
;			!---------------! ---------
;			!       4       !         ^
;			!---------------!         !
;			! ESTABLISH FP  !         !
;			!---------------!         !
;			!    DEPTH      ! Mechanism Array
;			!---------------!         !
;			!      R0       !         !
;			!---------------!         !
;			!      R1       !         v
;			!---------------! ---------
;			!       N       !         ^
;			!---------------!         !
;			! CONDITION NAME!         !
;			!---------------!         !
;			! N-3 ADDITIONAL!    Signal Array
;			! LONG WORD ARGS!         !
;			!---------------!         !
;			!      PC       !         !
;			!---------------!         !
;			!      PSL      !         v
;			!---------------! ---------
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	NONE
;
; COMPLETION CODES:
;	SS$_NORMAL if it's a UETP condition or RMS error.
;	Error status from exception, otherwise.
;
; SIDE EFFECTS:
;	May branch to ERROR_EXIT.
;	May print a message.
;--

SSERROR:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Entry mask

	$SETAST_S ENBFLG = #0		; Disable AST delivery
	PUSHL	#1			; Assume ASTs were enabled
	CMPL	S^#SS$_WASSET,R0	; Were ASTs enabled?
	BEQL	10$			; BR if they were
	CLRL	(SP)			; Set ASTs to remain disabled
10$:
	$SETSFM_S ENBFLG = #0		; Disable SS failure mode
	PUSHL	#1			; Assume SS failure mode was enabled
	CMPL	S^#SS$_WASSET,R0	; Was SS failure mode enabled?
	BEQL	20$			; BR if it was
	CLRL	(SP)			; Set SS failure mode to remain off
20$:
	MOVL	CHF$L_SIGARGLST(AP),R6	; Get the signal array pointer
	MOVQ	CHF$L_SIG_NAME(R6),R9	; Get NAME in R9 and ARG1 in R10
	CMPZV	#STS$V_FAC_NO,-		; Is this a message from LIB$SIGNAL?
		#STS$S_FAC_NO,-
		R9,#UETP$_FACILITY
	BNEQ	30$			; BR if this is not a UETP exception
	SUBL2	#2,CHF$L_SIG_ARGS(R6)	; Drop the PC and PSL
	$PUTMSG_S MSGVEC = CHF$L_SIG_ARGS(R6),- ; Print the message
		  ACTRTN = ACTRTN
	BRB	40$			; Restore ASTs and SS fail mode
30$:
	CMPL	#SS$_SSFAIL,R9		; RMS failures are SysSvc failures
	BNEQ	50$			; BR if this can't be an RMS failure
	CMPZV	#STS$V_FAC_NO,-		; Is it an RMS failure?
		#STS$S_FAC_NO,-
		R10,#RMS$_FACILITY
	BNEQ	50$			; BR if not
	BICL2	#^XF0000000,R10		; Strip control bits from status code
	MATCHC	#4,CHF$L_SIG_ARG1(R6),-	; Is it an RMS failure for which...
		#NRAT_LENGTH,-
		NO_RMS_AST_TABLE	; ...no AST can be delivered?
	BEQL	50$			; BR if so - must give error here
40$:
	POPR	#^M<R0>			; Restore SS failure mode...
	$SETSFM_S ENBFLG = R0		; ...
	POPR	#^M<R0>			; Restore AST enable...
	$SETAST_S ENBFLG = R0		; ...
	MOVL	S^#SS$_NORMAL,R0	; Supply a standard status for exit
	RET				; Resume processing (or goto RMS_ERROR)
50$:
	MOVL	R9,STATUS		; Save the status
	CLRL	R8			; Assume for now it's not SS failure
	CMPL	#SS$_SSFAIL,R9		; But is it a System Service failure?
	BNEQ	70$			; BR if not - no special case message
	$GETMSG_S MSGID = R10,-		; Get SS failure code associated text
		 MSGLEN = BUFFER_PTR,-
		 BUFADR = FAO_BUF,-
		 FLAGS  = #14,-
		 OUTADR = MSG_BLOCK
	TSTB	MSG_BLOCK+1		; Get FAO arg count for SS failure code
	BEQL	60$			; Don't use $GETMSG if no $FAO args...
	PUSHAL	BUFFER_PTR		; ...else build up...
	PUSHL	#1			; ...a message describing...
	PUSHL	#UETP$_TEXT		; ...why the System Service failed
	INSV	R10,#STS$V_SEVERITY,-	; Give the message...
		#STS$S_SEVERITY,(SP)	; ...the correct severity code
	MOVL	#3,R8			; Count the number of args we pushed
	BRB	70$
60$:
	PUSHL	R10			; Save SS failure code
	MOVL	#1,R8			; Count the number of args we pushed
70$:
	MULL3	#4,CHF$L_SIG_ARGS(R6),R7 ; Convert longwords to bytes
	SUBL2	R7,SP			   ; Save the current signal array...
	MOVC3	R7,CHF$L_SIG_NAME(R6),(SP) ; ...on the stack
	ADDL3	R8,CHF$L_SIG_ARGS(R6),-(SP) ; Push the current arg count
	BRW	ERROR_EXIT

	.SBTTL	$PUTMSG Action Routine
;++
; FUNCTIONAL DESCRIPTION:
;	This routine is called as the action routine from $PUTMSG to copy
;	messages to our own log file as well as have them written to SYS$OUTPUT.
;
; CALLING SEQUENCE:
;	Called by $PUTMSG system service if present as the ACTRTN parameter.
;
; INPUT PARAMETERS:
;	04(AP) - Descriptor for an ASCID string with the message
;
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	NONE
;
; COMPLETION CODES:
;	Always successful if it returns.
;
; SIDE EFFECTS:
;	Message copied to log file.
;	Program may exit, if RMS encounters an error.
;
;--

ACTRTN:
	.WORD	^M<R2>

	MOVW	LOG_RAB+RAB$W_RSZ,-(SP)	; Save vital info in case we're asynch
	PUSHL	LOG_RAB+RAB$L_RBF
	MOVL	4(AP),R2		; Get the message descriptor address
	MOVZWL	(R2),LOG_RAB+RAB$W_RSZ	; Get the message size
	MOVL	4(R2),LOG_RAB+RAB$L_RBF	; Set the message address
	$PUT	RAB = LOG_RAB,-
		ERR = RMS_ERROR		; Write the log file
	MOVL	S^#SS$_NORMAL,R0	; Set the return status code
	MOVL	(SP)+,LOG_RAB+RAB$L_RBF	; Restore vital info
	MOVW	(SP)+,LOG_RAB+RAB$W_RSZ
	RET

	.SBTTL	RMS Error Handler
;++
; FUNCTIONAL DESCRIPTION:
;	This routine handles error returns from RMS calls.
;
; CALLING SEQUENCE:
;	Called by RMS when a file processing error is found.  May also be
;	called inline to process an RMS error.
;
; INPUT PARAMETERS:
;	The FAB or RAB associated with the RMS call.
;
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	Error message
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	Program may exit, depending on severity of the error.
;
;--

RMS_ERROR:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Entry mask

	MOVAL	SSERROR,(FP)		; Set up our exception handler
	MOVL	4(AP),R6		; See whether we're dealing with...
	CMPB	#FAB$C_BID,FAB$B_BID(R6) ; ...a FAB or a RAB
	BNEQ	10$			; BR if it's a RAB
	MOVAL	FILE,R7			; FAB-specific code:  text string...
	MOVL	R6,R8			; ...address of FAB...
	PUSHL	FAB$L_STV(R6)		; ...STV field for error...
	PUSHL	FAB$L_STS(R6)		; ...STS field for error...
	MOVL	FAB$L_STS(R6),STATUS	; ...and save the error code
	BRB	RMS_COMMON		; FAB and RAB share other code
10$:
	MOVAL	RECORD,R7		; RAB-specific code:  text string...
	MOVL	RAB$L_FAB(R6),R8	; ...address of associated FAB...
	PUSHL	RAB$L_STV(R6)		; ...STV field for error...
	PUSHL	RAB$L_STS(R6)		; ...STS field for error...
	MOVL	RAB$L_STS(R6),STATUS	; ...and save the error code
RMS_COMMON:
	MOVZBL	FAB$B_FNS(R8),R10	; Get the file name size
	$FAO_S	CTRSTR = RMS_ERR_STRING,- ; Common code, prepare error message...
		OUTLEN = BUFFER_PTR,-
		OUTBUF = FAO_BUF,-
		P1     = R7,-
		P2     = R10,-
		P3     = FAB$L_FNA(R8)
	PUSHAL	BUFFER_PTR		; ...and arguments for ERROR_EXIT...
	PUSHL	#1			; ...
	PUSHL	#UETP$_TEXT		; ...
	EXTZV	#STS$V_SEVERITY,-
		#STS$S_SEVERITY,-
		STATUS,R9 		; ...get the severity code...
	BISB2	R9,(SP)			; ...and add it into the signal name
	PUSHL	#5			; Current arg count
	BRW	ERROR_EXIT

	.SBTTL	CTRL/C Handler
;++
; FUNCTIONAL DESCRIPTION:
;	This routine handles CTRL/C AST's
;
; CALLING SEQUENCE:
;	Called via AST
;
; INPUT PARAMETERS:
;	NONE
;
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	NONE
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	NONE
;
;--

CCASTHAND:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Entry mask

	PUSHL	PIDADR			; Clean up any subprocess...
	CALLS	#1,KILL_SUBPROCESS	; ...
	PUSHAL	CNTRLCMSG		; Set message pointer
	PUSHL	#1			; Set arg count
	PUSHL	#UETP$_TEXT!STS$K_WARNING ; Set signal name
	PUSHL	#0			; Indicate an abnormal termination
	PUSHAL	TEST_NAME		; ...
	PUSHL	#2			; ...
	PUSHL	#UETP$_ABENDD!STS$K_WARNING ; ...
	CALLS	#7,G^LIB$SIGNAL		; Output the message
	MOVL	#<STS$M_INHIB_MSG!-	; Set the exit status
		SS$_CONTROLC--
		STS$K_SUCCESS+STS$K_WARNING>,-
		STATUS
	$EXIT_S	STATUS			; Terminate program cleanly

	.SBTTL	Error Message
;++
; FUNCTIONAL DESCRIPTION:
;	Print an error message preceded by the UETP error box message.
;
; CALLING SEQUENCE:
;	Form a LIB$SIGNAL set of message except for the error box message
;	CALLS	count-of-messages,ERROR_MSG
;
; INPUT PARAMETERS:
;	List of LIB$SIGNAL arguments to which more may be added.  There is no
;		limit on the number or type other than what LIB$SIGNAL imposes.
;
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	NONE
;
; COMPLETION CODES:
;	Value from LIB$SIGNAL.
;
; SIDE EFFECTS:
;	Message from LIB$SIGNAL.
;--

ERROR_MSG:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Entry mask

	MULL3	#4,0(AP),R0		; Figure bytes already used for msgs
	SUBL2	R0,SP			; Reserve stack space for them
	MOVC3	R0,4(AP),(SP)		; Copy start of LIB$SIGNAL args
	INCL	ERROR_COUNT		; Keep a count of recoverable errors
	PUSHL	ERROR_COUNT		; Form the rest of LIB$SIGNAL args
	PUSHAL	TEST_NAME
	PUSHL	#^X10002
	PUSHL	#UETP$_ERBOXPROC!STS$K_ERROR
	ADDL3	#4,0(AP),R0		; Count total number of LIB$SIGNAL args
	CALLS	R0,G^LIB$SIGNAL
	MOVL	#SS$_NORMAL,R0
	RET				; Continue with recovery

	.SBTTL	Error Exit
;++
; FUNCTIONAL DESCRIPTION:
;	This routine prints an error message and exits.
;
; CALLING SEQUENCE:
;	MOVx  error status value,STATUS
;	PUSHx error specific information on the stack
;	PUSHL current argument count
;	BRW   ERROR_EXIT
;
; INPUT PARAMETERS:
;	Arguments to LIB$SIGNAL, as above
;
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;	Message to SYS$OUTPUT and SYS$ERROR
;
; IMPLICIT OUTPUTS:
;	Program exit
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	NONE
;
;--

ERROR_EXIT:

	$SETAST_S ENBFLG = #0		; ASTs can play havoc with messages
	BBS	#BEGIN_MSGV,FLAG,10$	; BR if "begin" msg already printed
	CLRL	-(SP)			; Set the time stamp flag
	PUSHAL	TEST_NAME		; Set the test name
	PUSHL	#2			; Push the argument count
	PUSHL	#UETP$_BEGIND!STS$K_SUCCESS ; Set the message code
	CALLS	#4,G^LIB$SIGNAL		; Print the startup message
10$:
	ADDL3	(SP)+,#8,ARG_COUNT	; Get total # args, pop partial count
	INCL	ERROR_COUNT		; Keep running error count
	PUSHL	#0			; Push the time parameter
	PUSHAL	TEST_NAME		; Push test name...
	PUSHL	#^XF0002		; ...arg count...
	PUSHL	#UETP$_ABENDD!STS$K_ERROR ; ...and signal name
	PUSHL	ERROR_COUNT		; Finish off arg list...
	PUSHAL	TEST_NAME		; ...
	PUSHL	#^X10002		; ...
	PUSHL	#UETP$_ERBOXPROC!STS$K_ERROR ; ...for error box message
	CALLS	ARG_COUNT,G^LIB$SIGNAL	; Truly bitch

	TSTL	STATUS			; Did we exit with an error code?
	BNEQ	20$			; BR if we did
	MOVL	#UETP$_ABENDD!STS$K_ERROR,- ; Supply a generic one otherwise
		STATUS
20$:
	BISL	#STS$M_INHIB_MSG,STATUS	; Don't print messages twice!
	$EXIT_S STATUS			; Exit in error

	.SBTTL	Exit Handler
;++
; FUNCTIONAL DESCRIPTION:
;	This routine handles cleanup on exits.
;
; CALLING SEQUENCE:
;	Invoked automatically by $EXIT System Service.
;
; INPUT PARAMETERS:
;	Location STATUS contains the exit status, FLAG has synchronizing bits.
;
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	Various files are de-accessed, the process name is reset, and any
;	necessary synchronization with UETPDEV01 is carried out.
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	NONE
;
;--

EXIT_HANDLER:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11> ; Entry mask

	$SETSFM_S ENBFLG = #0		; Turn off System Service failure mode
	$SETAST_S ENBFLG = #0		; We're finished - no more ASTs
	$DELLOG_S LOGNAM = MODE,-
		  TBLFLG = #1		; Clean up the logical names
	PUSHL	#0			; Set the time flag
	PUSHAL	TEST_NAME		; Push the test name
	PUSHL	#2			; Push arg count
	PUSHL	#UETP$_ENDEDD!STS$K_SUCCESS ; Push signal name
	CALLS	#4,G^LIB$SIGNAL		; Output the message
	$SETPRN_S PRCNAM = ACNT_NAME	; Reset the process name
	RET				; That's all folks!

	.END	UETINIT01
