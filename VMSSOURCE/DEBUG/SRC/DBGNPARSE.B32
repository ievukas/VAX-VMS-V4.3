MODULE DBGNPARSE (IDENT = 'V04-000') =

BEGIN
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
!
! WRITTEN BY
!	David Plummer	April 15, 1980
!
! MODIFIED BY
!	Rich Title
!	Vicki Holt
!	Bert Beander
!
! MODULE FUNCTION
!	This module contains the highest level parse network, DBG$NPARSE_CMD, and
!	several parsing associated routines. Legal command verbs are recognized by
!	DBG$NPARSE_CMD and control is passed to the subnetwork responsible for parsing
!	the rest of the input associated with the verb recognized. In total, the
!	routines produce a command execution tree which is the version 3 debugger
!	form of intermediate code.
!
!	Also contained in this module are the routines DBG$NPARSE_ADDRESS and
!	DBG$NPARSE_EXPRESSION which are the interfaces between the debugger
!	parser and the Address Expression Interpreter and Expression Interpreter.
!

REQUIRE 'SRC$:DBGPROLOG.REQ';

FORWARD ROUTINE
    DBG$NPARSE_CMD,			! Highest level network for parsing
    DBG$NMATCH,				! String matching routine
    DBG$NNEXT_WORD,			! Produces a counted string from the input
    DBG$NPARSE_EXPRESSION,		! Interface to expression interpreters
    DBG$NPARSE_ADDRESS,			! Interface to address expression interpreters
    DBG$NSAVE_DECIMAL_INTEGER,		! Converts ASCII input to integer
    DBG$NSAVE_STRING,			! Stores a string from input
    DBG$NGET_DIR_LIST,			! Parses a directory list.
    DBG$EXPAND_DEFINE_NAME,		! Expands name defined with DEFINE
    DBG$SYNTAX_ERROR: NOVALUE;		! Signal a syntax error in command

EXTERNAL ROUTINE
    DBG$ADDR_EXP_INT,			! Address Expression Interpreter
    DBG$DEF_SYM_FIND,			! Look up a symbol in the
    					!     DEFINE symbol table
    DBG$GET_MEMORY,			! Allocates space
    DBG$GET_TEMPMEM,			! Allocates and lists dynamic storage
    DBG$EXP_INT,			! Expression Interpreter
    DBG$NPARSE_ALLOCATE,		! ALLOCATE command parse network
    DBG$NPARSE_AT_SIGN,			! @ filespec parse network
    DBG$NPARSE_ATTACH,			! ATTACH command parse network
    DBG$NPARSE_CALL,			! CALL command parse network
    DBG$NPARSE_CANCEL,			! CANCEL command parse network
    DBG$NPARSE_DECLARE,			! DECLARE command parse network
    DBG$NPARSE_DEFINE,			! DEFINE command parse network
    DBG$NPARSE_DELETE,			! DELETE/KEY command
    DBG$NPARSE_DEPOSIT,			! DEPOSIT command parse network
    DBG$NPARSE_DUMP,			! DUMP command parse network
    DBG$NPARSE_EDIT,			! EDIT command parse network
    DBG$NPARSE_EVALUATE,		! EVALUATE command parse network
    DBG$NPARSE_EXAMINE,			! EXAMINE command parse network
    DBG$NPARSE_EXIT,			! EXIT command parse network
    DBG$NPARSE_EXITLOOP,		! EXITLOOP command parse network
    DBG$NPARSE_FOR,			! FOR command parse network
    DBG$NPARSE_GO,			! GO command parse network
    DBG$NPARSE_HELP,			! HELP command parse network
    DBG$NPARSE_IF,			! IF command parse network
    DBG$NPARSE_REPEAT,			! REPEAT command parse network
    DBG$NPARSE_SEARCH,			! SEARCH command parse network
    DBG$NPARSE_SET,			! SET command parse network
    DBG$NPARSE_SHOW,			! SHOW command parse network
    DBG$NPARSE_SPAWN,			! SPAWN command parse network
    DBG$NPARSE_STEP,			! STEP command parse network
    DBG$NPARSE_SYMBOLIZE,		! SYMBOLIZE command parse network
    DBG$NPARSE_TYPE,			! TYPE command parse network
    DBG$NPARSE_UNDEFINE,		! UNDEFINE command parse network
    DBG$NPARSE_WHILE,			! WHILE command parse network
    DBG$NMAKE_ARG_VECT,			! Constructs a message vector
    DBG$NOUT_INFO,			! Outputs an info message
    DBG$NREAD_NAME,			! Reads a name that is
    					!     a potential DEFINEd name
    DBG$NSET_LAST_TYPLEN,		! Sets type and length of current location
    DBG$NSYNTAX_ERROR,			! Constructs a message vector for a syntax error
    DBG$REL_MEMORY,			! Release memory from pool
    DBG$SCR_PARSE_DISPLAY_CMD: NOVALUE,	! Parse the DISPLAY command
    DBG$SCR_PARSE_SAVE_CMD: NOVALUE,	! Parse the SAVE command
    DBG$SCR_PARSE_SCROLL_CMD: NOVALUE,	! Parse the SCROLL command
    DBG$SCR_PARSE_SELECT_CMD: NOVALUE,	! parse the SELECT command
    DBG$STA_SETCONTEXT : NOVALUE;	! Sets registers context

EXTERNAL
    DBG$GL_DEVELOPER: BITVECTOR[],	! Developer flags
    DBG$GL_EDIT_ENABLED,		! Flag saying whether the EDIT
    					!    command is enabled.
    DBG$GB_RADIX: VECTOR[3, BYTE],	! Radix settings
    DBG$GB_EXC_BRE_FLAG: BYTE,		! Flag set if we are in exception break
    DBG$GB_LANGUAGE: BYTE,		! Current language code
    DBG$GL_SCREEN_NOGO,			! Flag to disable STEP, GO, and CALL in
					!      screen display command lists
    DBG$GB_VERB: BYTE;			! Holds command verb value

LITERAL
    ALLOCATE_VERB = DBG$K_ALLOCATE_VERB,! Code for ALLOCATE command
    AT_SIGN_VERB = DBG$K_AT_SIGN_VERB,	! Code for indirect command file execution
    ATTACH_VERB = DBG$K_ATTACH_VERB,	! Code for ATTACH command
    CALL_VERB = DBG$K_CALL_VERB,	! Code for CALL command
    CANCEL_VERB = DBG$K_CANCEL_VERB,	! Code for CANCEL command
    DECLARE_VERB = DBG$K_DECLARE_VERB,	! Code for DECLARE command
    DEFINE_VERB = DBG$K_DEFINE_VERB,	! Code for DEFINE command
    DELETE_VERB = DBG$K_DELETE_VERB,	! Code for DELETE command
    DEPOSIT_VERB = DBG$K_DEPOSIT_VERB,	! Code for DEPOSIT command
    DISPLAY_VERB = DBG$K_DISPLAY_VERB,	! Code for DISPLAY command
    DUMP_VERB = DBG$K_DUMP_VERB,	! Code for DUMP command
    EDIT_VERB = DBG$K_EDIT_VERB,	! Code for EDIT command
    EVALUATE_VERB = DBG$K_EVALUATE_VERB,! Code for EVALUATE command
    EXAMINE_VERB = DBG$K_EXAMINE_VERB,	! Code for EXAMINE command
    EXIT_VERB = DBG$K_EXIT_VERB,	! Code for EXIT command
    EXITLOOP_VERB = DBG$K_EXITLOOP_VERB,! Code for EXITLOOP command
    FOR_VERB = DBG$K_FOR_VERB,		! Code for FOR command
    GO_VERB = DBG$K_GO_VERB,		! Code for GO command
    HELP_VERB = DBG$K_HELP_VERB,	! Code for HELP command
    IF_VERB = DBG$K_IF_VERB,		! Code for IF command
    REPEAT_VERB = DBG$K_REPEAT_VERB,	! Code for REPEAT command
    SAVE_VERB = DBG$K_SAVE_VERB,	! Code for SAVE command
    SCROLL_VERB = DBG$K_SCROLL_VERB,	! Code for SCROLL command
    SEARCH_VERB = DBG$K_SEARCH_VERB,	! Code for SEARCH command
    SELECT_VERB = DBG$K_SELECT_VERB,	! Code for SELECT command
    SET_VERB = DBG$K_SET_VERB,		! Code for SET command
    SHOW_VERB = DBG$K_SHOW_VERB,	! Code for SHOW command
    SPAWN_VERB = DBG$K_SPAWN_VERB,	! Code for SPAWN command
    STEP_VERB = DBG$K_STEP_VERB,	! Code for STEP command
    SYMBOLIZE_VERB = 
    		DBG$K_SYMBOLIZE_VERB,	! Code for SYMBOLIZE command
    TYPE_VERB = DBG$K_TYPE_VERB,	! Code for TYPE command
    UNDEFINE_VERB = DBG$K_UNDEFINE_VERB,! Code for UNDEFINE command
    WHILE_VERB = DBG$K_WHILE_VERB,	! Code for WHILE command
    WORD_SIZE = 80;			! Maximum word size

OWN
    WORD_BUF : VECTOR [WORD_SIZE + 1, BYTE]; ! Buffer for counted string word

GLOBAL ROUTINE DBG$NPARSE_CMD (INPUT_DESC, VERB_NODE_PTR, MESSAGE_VECT) =
!
! FUNCTIONAL DESCRIPTION:
!
!	Highest level command parsing ATN network. This routine recognizes the
!	verb portion of the input command and transfers control to the appropriate
!	ATN subnetwork to parse the rest of the command.
!
! FORMAL PARAMETERS:
!
!	INPUT_DESC	- Standard VAX string descriptor of the input command.
!
!	VERB_NODE_PTR	- Pointer to the verb (head) node of the command
!			  execution tree.
!
!	MESSAGE_VECT	- Address of a longword to contain the address of
!			  a message argument vector.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	The command execution tree is constructed and verb_node_ptr is set to point
!	to the dynamically allocated verb node which is the head node of the tree.
!
! ROUTINE VALUE:
!
!	unsigned longword integer completion code
!
! COMPLETION CODES:
!
!	STS$K_SEVERE (4) -	unsuccessful parse
!
!	STS$K_SUCCESS (1) -	successful parse of the input command
!

    BEGIN

    MAP
	INPUT_DESC : REF DBG$STG_DESC;	! Input string descriptor


    ! Define strings used at this level of parsing
    !
    BIND
    	DBG$CS_ALLOCATE  = UPLIT BYTE(%ASCIC 'ALLOCATE'),
	DBG$CS_AT_SIGN	 = UPLIT BYTE(1, DBG$K_AT_SIGN),
    	DBG$CS_ATTACH	 = UPLIT BYTE(%ASCIC 'ATTACH'),
    	DBG$CS_CALL	 = UPLIT BYTE(%ASCIC 'CALL'),
	DBG$CS_CANCEL	 = UPLIT BYTE(%ASCIC 'CANCEL'),
    	DBG$CS_DECLARE	 = UPLIT BYTE(%ASCIC 'DECLARE'),
	DBG$CS_DEFINE	 = UPLIT BYTE(%ASCIC 'DEFINE'),
    	DBG$CS_DELETE	 = UPLIT BYTE(%ASCIC 'DELETE'),
	DBG$CS_DEPOSIT	 = UPLIT BYTE(%ASCIC 'DEPOSIT'),
	DBG$CS_DISPLAY   = UPLIT BYTE(%ASCIC 'DISPLAY'),
    	DBG$CS_DUMP	 = UPLIT BYTE(%ASCIC 'DUMP'),
    	DBG$CS_EDIT	 = UPLIT BYTE(%ASCIC 'EDIT'),
	DBG$CS_EVALUATE	 = UPLIT BYTE(%ASCIC 'EVALUATE'),
	DBG$CS_EXAMINE	 = UPLIT BYTE(%ASCIC 'EXAMINE'),
	DBG$CS_EXIT	 = UPLIT BYTE(%ASCIC 'EXIT'),
	DBG$CS_EXITLOOP	 = UPLIT BYTE(%ASCIC 'EXITLOOP'),
    	DBG$CS_FOR	 = UPLIT BYTE(%ASCIC 'FOR'),
	DBG$CS_GO	 = UPLIT BYTE(%ASCIC 'GO'),
	DBG$CS_HELP	 = UPLIT BYTE(%ASCIC 'HELP'),
	DBG$CS_IF	 = UPLIT BYTE(%ASCIC 'IF'),
	DBG$CS_REPEAT	 = UPLIT BYTE(%ASCIC 'REPEAT'),
	DBG$CS_SAVE	 = UPLIT BYTE(%ASCIC 'SAVE'),
	DBG$CS_SCROLL    = UPLIT BYTE(%ASCIC 'SCROLL'),
	DBG$CS_SEARCH	 = UPLIT BYTE(%ASCIC 'SEARCH'),
	DBG$CS_SELECT    = UPLIT BYTE(%ASCIC 'SELECT'),
	DBG$CS_SET	 = UPLIT BYTE(%ASCIC 'SET'),
	DBG$CS_SHOW	 = UPLIT BYTE(%ASCIC 'SHOW'),
    	DBG$CS_SPAWN	 = UPLIT BYTE(%ASCIC 'SPAWN'),
	DBG$CS_STEP	 = UPLIT BYTE(%ASCIC 'STEP'),
	DBG$CS_SYMBOLIZE = UPLIT BYTE(%ASCIC 'SYMBOLIZE'),
	DBG$CS_TYPE	 = UPLIT BYTE(%ASCIC 'TYPE'),
    	DBG$CS_UNDEFINE  = UPLIT BYTE(%ASCIC 'UNDEFINE'),
	DBG$CS_WHILE	 = UPLIT BYTE(%ASCIC 'WHILE'),
	DBG$CS_CR	 = UPLIT BYTE(1, DBG$K_CAR_RETURN);

    LOCAL
	VERB_NODE : REF DBG$VERB_NODE;	! Verb node (head of tree)


    ! Construct and link the verb node
    !
    VERB_NODE = DBG$GET_TEMPMEM(DBG$K_VERB_NODE_SIZE);
    .VERB_NODE_PTR = .VERB_NODE;
    DBG$GB_VERB = 0;


    ! Set registers to current context as a default
    !
    DBG$STA_SETCONTEXT (0);


    ! Try to recognize a legal verb. If one is found, transfer control
    ! to a command parse subnetwork.
    !
    IF (SELECTONE TRUE OF
	    SET

    	    [DBG$NMATCH (.INPUT_DESC, DBG$CS_ALLOCATE, 2)]:
    		BEGIN
    		VERB_NODE [DBG$B_VERB_LITERAL] = ALLOCATE_VERB;
    		DBG$GB_VERB = DBG$K_ALLOCATE_VERB;
    		DBG$NPARSE_ALLOCATE (.INPUT_DESC, .VERB_NODE, .MESSAGE_VECT)
    		END;

	    [DBG$NMATCH (.INPUT_DESC, DBG$CS_AT_SIGN, 1)]:
		BEGIN
		VERB_NODE [DBG$B_VERB_LITERAL] = AT_SIGN_VERB;
		DBG$GB_VERB = DBG$K_AT_SIGN_VERB;
		DBG$NPARSE_AT_SIGN (.INPUT_DESC, .VERB_NODE, .MESSAGE_VECT)
		END;

    	    [DBG$NMATCH (.INPUT_DESC, DBG$CS_ATTACH, 3)]:
    		BEGIN
    		VERB_NODE [DBG$B_VERB_LITERAL] = ATTACH_VERB;
    		DBG$GB_VERB = DBG$K_ATTACH_VERB;
    		DBG$NPARSE_ATTACH (.INPUT_DESC, .VERB_NODE, .MESSAGE_VECT)
    		END;


	    ! Check for the CALL command.  If this is the CALL command, we
	    ! signal an error if we are currently in an exception break
	    ! (we cannot do a CALL if we will restart the program by re-
	    ! signalling instead of continuing) or if we are currently
	    ! executing the DEBUG command list of a screen display (which
	    ! would cause an infinite loop of screen display updating).
	    ! Otherwise we parse the command normally.
	    !
    	    [DBG$NMATCH (.INPUT_DESC, DBG$CS_CALL, 3)]:
    		BEGIN
    		VERB_NODE [DBG$B_VERB_LITERAL] = CALL_VERB;
    		DBG$GB_VERB = DBG$K_CALL_VERB;
		IF .DBG$GB_EXC_BRE_FLAG THEN SIGNAL(DBG$_STEFROEXC);
		IF .DBG$GL_SCREEN_NOGO THEN SIGNAL(DBG$_NOSTEPGO);
		DBG$NPARSE_CALL (.INPUT_DESC, .VERB_NODE, .MESSAGE_VECT)
    		END;

	    [DBG$NMATCH (.INPUT_DESC, DBG$CS_CANCEL, 3)]:
		BEGIN
		VERB_NODE [DBG$B_VERB_LITERAL] = CANCEL_VERB;
		DBG$GB_VERB = DBG$K_CANCEL_VERB;
		DBG$NPARSE_CANCEL (.INPUT_DESC, .VERB_NODE, .MESSAGE_VECT)
		END;

    	    [DBG$NMATCH (.INPUT_DESC, DBG$CS_DECLARE, 3)]:
    		BEGIN
    		VERB_NODE [DBG$B_VERB_LITERAL] = DECLARE_VERB;
    		DBG$GB_VERB = DBG$K_DECLARE_VERB;
    		DBG$NPARSE_DECLARE (.INPUT_DESC, .VERB_NODE, .MESSAGE_VECT)
    		END;

	    [DBG$NMATCH (.INPUT_DESC, DBG$CS_DEFINE, 3)]:
		BEGIN
		VERB_NODE [DBG$B_VERB_LITERAL] = DEFINE_VERB;
		DBG$GB_VERB = DBG$K_DEFINE_VERB;
		DBG$NPARSE_DEFINE (.INPUT_DESC, .VERB_NODE, .MESSAGE_VECT)
		END;

    	    [DBG$NMATCH (.INPUT_DESC, DBG$CS_DELETE, 3)]:
    		BEGIN
    		VERB_NODE [DBG$B_VERB_LITERAL] = DELETE_VERB;
    		DBG$GB_VERB = DBG$K_DELETE_VERB;
    		DBG$NPARSE_DELETE (.INPUT_DESC, .VERB_NODE, .MESSAGE_VECT)
    		END;

	    [DBG$NMATCH (.INPUT_DESC, DBG$CS_DEPOSIT, 1)]:
		BEGIN
		VERB_NODE [DBG$B_VERB_LITERAL] = DEPOSIT_VERB;
		DBG$GB_VERB = DBG$K_DEPOSIT_VERB;
		DBG$NPARSE_DEPOSIT (.INPUT_DESC, .VERB_NODE, .MESSAGE_VECT)
		END;

	    [DBG$NMATCH (.INPUT_DESC, DBG$CS_DISPLAY, 3)]:
		BEGIN
		VERB_NODE [DBG$B_VERB_LITERAL] = DISPLAY_VERB;
		DBG$GB_VERB = DBG$K_DISPLAY_VERB;
		DBG$SCR_PARSE_DISPLAY_CMD(.INPUT_DESC, FALSE, .VERB_NODE);
		TRUE
		END;

    	    [DBG$NMATCH (.INPUT_DESC, DBG$CS_DUMP, 2)]:
    		BEGIN
    		VERB_NODE [DBG$B_VERB_LITERAL] = DUMP_VERB;
    		DBG$GB_VERB = DBG$K_DUMP_VERB;
    		DBG$NPARSE_DUMP (.INPUT_DESC, .VERB_NODE, .MESSAGE_VECT)
    		END;


    	    ! The EDIT command is our interface to the EDITH text editor.
    	    ! We allow this command if a certain global flag is set.
    	    ! That way, the command can be disabled for version 4.0,
    	    ! and enabled with a patch in a future release. The 
    	    ! all-purpose developer bit 0 also enables this command,
    	    ! so that developers can easily test it.
    	    !
    	    [  (IF .DBG$GL_EDIT_ENABLED OR .DBG$GL_DEVELOPER[0]
    	        THEN
    		    DBG$NMATCH (.INPUT_DESC, DBG$CS_EDIT, 2)
    	        ELSE
    		    FALSE)]:
    		BEGIN
    		VERB_NODE [DBG$B_VERB_LITERAL] = EDIT_VERB;
    		DBG$GB_VERB = DBG$K_EDIT_VERB;
    		DBG$NPARSE_EDIT (.INPUT_DESC, .VERB_NODE, .MESSAGE_VECT)
    		END;


	    [DBG$NMATCH (.INPUT_DESC, DBG$CS_EVALUATE, 2)]:
		BEGIN
		VERB_NODE [DBG$B_VERB_LITERAL] = EVALUATE_VERB;
		DBG$GB_VERB = DBG$K_EVALUATE_VERB;
		DBG$NPARSE_EVALUATE (.INPUT_DESC, .VERB_NODE, .MESSAGE_VECT)
		END;

	    [DBG$NMATCH (.INPUT_DESC, DBG$CS_EXAMINE, 1)]:
		BEGIN
		VERB_NODE [DBG$B_VERB_LITERAL] = EXAMINE_VERB;
		DBG$GB_VERB = DBG$K_EXAMINE_VERB;
		DBG$NPARSE_EXAMINE (.INPUT_DESC, .VERB_NODE, .MESSAGE_VECT)
		END;

	    [DBG$NMATCH (.INPUT_DESC, DBG$CS_EXIT, 3)]:
		BEGIN
		VERB_NODE [DBG$B_VERB_LITERAL] = EXIT_VERB;
		DBG$GB_VERB = DBG$K_EXIT_VERB;
		DBG$NPARSE_EXIT (.INPUT_DESC, .VERB_NODE, .MESSAGE_VECT)
		END;

	    [DBG$NMATCH (.INPUT_DESC, DBG$CS_EXITLOOP, 5)]:
		BEGIN
		VERB_NODE [DBG$B_VERB_LITERAL] = EXITLOOP_VERB;
		DBG$GB_VERB = DBG$K_EXITLOOP_VERB;
		DBG$NPARSE_EXITLOOP (.INPUT_DESC, .VERB_NODE, .MESSAGE_VECT)
		END;

    	    [DBG$NMATCH (.INPUT_DESC, DBG$CS_FOR, 1)]:
    		BEGIN
    		VERB_NODE [DBG$B_VERB_LITERAL] = FOR_VERB;
    		DBG$GB_VERB = DBG$K_FOR_VERB;
    		DBG$NPARSE_FOR (.INPUT_DESC, .VERB_NODE, .MESSAGE_VECT)
    		END;

	    [DBG$NMATCH (.INPUT_DESC, DBG$CS_GO, 1)]:
		BEGIN
		VERB_NODE [DBG$B_VERB_LITERAL] = GO_VERB;
		DBG$GB_VERB = DBG$K_GO_VERB;
		IF .DBG$GL_SCREEN_NOGO THEN SIGNAL(DBG$_NOSTEPGO);
		DBG$NPARSE_GO (.INPUT_DESC, .VERB_NODE, .MESSAGE_VECT)
		END;

	    [DBG$NMATCH (.INPUT_DESC, DBG$CS_HELP, 1)]:
		BEGIN
		VERB_NODE [DBG$B_VERB_LITERAL] = HELP_VERB;
		DBG$GB_VERB = DBG$K_HELP_VERB;
		DBG$NPARSE_HELP (.INPUT_DESC, .VERB_NODE, .MESSAGE_VECT)
		END;

	    [DBG$NMATCH (.INPUT_DESC, DBG$CS_IF, 1)]:
		BEGIN
		VERB_NODE [DBG$B_VERB_LITERAL] = IF_VERB;
		DBG$GB_VERB = DBG$K_IF_VERB;
		DBG$NPARSE_IF (.INPUT_DESC, .VERB_NODE, .MESSAGE_VECT)
		END;

	    [DBG$NMATCH (.INPUT_DESC, DBG$CS_REPEAT, 2)]:
		BEGIN
		VERB_NODE [DBG$B_VERB_LITERAL] = REPEAT_VERB;
		DBG$GB_VERB = DBG$K_REPEAT_VERB;
		DBG$NPARSE_REPEAT (.INPUT_DESC, .VERB_NODE, .MESSAGE_VECT)
		END;

	    [DBG$NMATCH (.INPUT_DESC, DBG$CS_SAVE, 3)]:
		BEGIN
		VERB_NODE [DBG$B_VERB_LITERAL] = SAVE_VERB;
		DBG$GB_VERB = DBG$K_SAVE_VERB;
		DBG$SCR_PARSE_SAVE_CMD(.INPUT_DESC, .VERB_NODE);
		TRUE
		END;

	    [DBG$NMATCH (.INPUT_DESC, DBG$CS_SCROLL, 3)]:
		BEGIN
		VERB_NODE [DBG$B_VERB_LITERAL] = SCROLL_VERB;
		DBG$GB_VERB = DBG$K_SCROLL_VERB;
		DBG$SCR_PARSE_SCROLL_CMD(.INPUT_DESC, .VERB_NODE);
		TRUE
		END;

	    [DBG$NMATCH (.INPUT_DESC, DBG$CS_SEARCH, 3)]:
		BEGIN
		VERB_NODE [DBG$B_VERB_LITERAL] = SEARCH_VERB;
		DBG$GB_VERB = DBG$K_SEARCH_VERB;
		DBG$NPARSE_SEARCH (.INPUT_DESC, .VERB_NODE, .MESSAGE_VECT)
		END;

	    [DBG$NMATCH (.INPUT_DESC, DBG$CS_SELECT, 3)]:
		BEGIN
		VERB_NODE [DBG$B_VERB_LITERAL] = SELECT_VERB;
		DBG$GB_VERB = DBG$K_SELECT_VERB;
		DBG$SCR_PARSE_SELECT_CMD(.INPUT_DESC, .VERB_NODE);
		TRUE
		END;

	    [DBG$NMATCH (.INPUT_DESC, DBG$CS_SET, 2)]:
		BEGIN
		VERB_NODE [DBG$B_VERB_LITERAL] = SET_VERB;
		DBG$GB_VERB = DBG$K_SET_VERB;
		DBG$NPARSE_SET (.INPUT_DESC, .VERB_NODE, .MESSAGE_VECT)
		END;

	    [DBG$NMATCH (.INPUT_DESC, DBG$CS_SHOW, 2)]:
		BEGIN
		VERB_NODE [DBG$B_VERB_LITERAL] = SHOW_VERB;
		DBG$GB_VERB = DBG$K_SHOW_VERB;
		DBG$NPARSE_SHOW (.INPUT_DESC, .VERB_NODE, .MESSAGE_VECT)
		END;

    	    [DBG$NMATCH (.INPUT_DESC, DBG$CS_SPAWN, 2)]:
    		BEGIN
    		VERB_NODE [DBG$B_VERB_LITERAL] = SPAWN_VERB;
    		DBG$GB_VERB = DBG$K_SPAWN_VERB;
    		DBG$NPARSE_SPAWN (.INPUT_DESC, .VERB_NODE, .MESSAGE_VECT)
    		END;

	    [DBG$NMATCH (.INPUT_DESC, DBG$CS_STEP, 1)]:
		BEGIN
		VERB_NODE [DBG$B_VERB_LITERAL] = STEP_VERB;
		DBG$GB_VERB = DBG$K_STEP_VERB;
		IF .DBG$GL_SCREEN_NOGO THEN SIGNAL(DBG$_NOSTEPGO);
		DBG$NPARSE_STEP (.INPUT_DESC, .VERB_NODE, .MESSAGE_VECT)
		END;

	    [DBG$NMATCH (.INPUT_DESC, DBG$CS_SYMBOLIZE, 2)]:
		BEGIN
		VERB_NODE [DBG$B_VERB_LITERAL] = SYMBOLIZE_VERB;
		DBG$GB_VERB = DBG$K_SYMBOLIZE_VERB;
		DBG$NPARSE_SYMBOLIZE (.INPUT_DESC, .VERB_NODE, .MESSAGE_VECT)
		END;

	    [DBG$NMATCH (.INPUT_DESC, DBG$CS_TYPE, 1)]:
		BEGIN
		VERB_NODE [DBG$B_VERB_LITERAL] = TYPE_VERB;
		DBG$GB_VERB = DBG$K_TYPE_VERB;
		DBG$NPARSE_TYPE (.INPUT_DESC, .VERB_NODE, .MESSAGE_VECT)
		END;

    	    [DBG$NMATCH (.INPUT_DESC, DBG$CS_UNDEFINE, 1)]:
    		BEGIN
    		VERB_NODE [DBG$B_VERB_LITERAL] = UNDEFINE_VERB;
    		DBG$GB_VERB = DBG$K_UNDEFINE_VERB;
    		DBG$NPARSE_UNDEFINE (.INPUT_DESC, .VERB_NODE, .MESSAGE_VECT)
    		END;

	    [DBG$NMATCH (.INPUT_DESC, DBG$CS_WHILE, 1)]:
		BEGIN
		VERB_NODE [DBG$B_VERB_LITERAL] = WHILE_VERB;
		DBG$GB_VERB = DBG$K_WHILE_VERB;
		DBG$NPARSE_WHILE (.INPUT_DESC, .VERB_NODE, .MESSAGE_VECT)
		END;


	    ! Any other command name constitutes a syntax error.
	    !
	    [OTHERWISE]:
		BEGIN
		.MESSAGE_VECT = DBG$NSYNTAX_ERROR (DBG$NNEXT_WORD (.INPUT_DESC));
		FALSE
		END;

	    TES)
    THEN
	RETURN


	    ! Check for exhausted input
	    !
	    (IF .INPUT_DESC [DSC$W_LENGTH] EQL 0 OR
		DBG$NMATCH (.INPUT_DESC, DBG$CS_CR, 1)
	    THEN
		STS$K_SUCCESS

	    ELSE
		BEGIN
		.MESSAGE_VECT = DBG$NSYNTAX_ERROR (DBG$NNEXT_WORD (.INPUT_DESC));
		STS$K_SEVERE
		END
	    )
    ELSE
	RETURN STS$K_SEVERE;

    END;

GLOBAL ROUTINE DBG$NMATCH (STRING_DESC, COUNTED_STRING, UNIQUE_CHARS) =
!
! FUNCTION
!	This routine is used extensively during command parsing. What it does is
!	to compare the first word of the command input string against the supplied
!	counted string to see if they match. If they do, the matched word is removed
!	from the head of the command input string and success is returned as the value
!	of the routine. Note that the input word may be shorter than the counted
!	string to allow for abbreviations of commands.
!
! FORMAL PARAMETERS:
!
!	STRING_DESC	- VAX standard string descriptor of the input command.
!
!	COUNTED_STRING	- The counted string against which the input word is
!			  to be compared.
!
!	UNIQUE_CHARS	- The number of characters which the input word must
!			  match against the counted string for purposes of
!			  disambiguating the input word.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	Unsigned integer longword.
!
! COMPLETION CODES:
!
!	STS$K_SEVERE (4)  - The input word did not match the counted string.
!
!	STS$K_SUCCESS (1) - The input word did match.
!
! SIDE EFFECTS:
!
!	On a successful match, the input string descriptor is updated to just beyond
!	the word of input matched against the counted string.
!

    BEGIN

    MAP
	STRING_DESC : REF DBG$STG_DESC,
	COUNTED_STRING: REF VECTOR[,BYTE];

    LOCAL
	WORD_STRING: REF VECTOR[,BYTE],	! Holds the next input word
	SAVE_PTR,			! Saves the address of the input buffer
	SAVE_LEN,			! Saves the length of the input buffer
	MATCH_FLAG;			! Signals a match



    ! Save the original descriptor buffer address and length
    !
    SAVE_PTR = .STRING_DESC [DSC$A_POINTER];
    SAVE_LEN = .STRING_DESC [DSC$W_LENGTH];


    ! Get the next input word
    !
    WORD_STRING = DBG$NNEXT_WORD (.STRING_DESC);


    ! Perform the match, check for special cases
    !
    MATCH_FLAG = TRUE;
    SELECTONE TRUE OF
	SET


	! Match
	!
	[.COUNTED_STRING [0] EQL 0]:
	    0;


	! No match
	!
	[.WORD_STRING [0] GTR .COUNTED_STRING [0]]:
	    MATCH_FLAG = FALSE;


	! No match
	!
	[.WORD_STRING [0] EQL 0]:
	    MATCH_FLAG = FALSE;


	! No match
	!
	[.WORD_STRING [0] LSS .UNIQUE_CHARS]:
	    MATCH_FLAG = FALSE;


	! Normal match
	!
	[OTHERWISE]:
	    BEGIN

	    LOCAL
		I;			! Loop counter

	    I = 1;
	    WHILE .I LEQ .WORD_STRING [0] DO
		BEGIN
		IF .WORD_STRING [.I] NEQ .COUNTED_STRING [.I]
		THEN
		    MATCH_FLAG = FALSE;

		I = .I + 1;
		END;

	    END;

	TES;


    ! Return successfully if we found a match.  Otherwise, restore the old
    ! descriptor and return failure to find a match.
    !
    IF .MATCH_FLAG THEN RETURN STS$K_SUCCESS;
    STRING_DESC [DSC$A_POINTER] = .SAVE_PTR;
    STRING_DESC [DSC$W_LENGTH] = .SAVE_LEN;
    RETURN STS$K_SEVERE;

    END;

GLOBAL ROUTINE DBG$NNEXT_WORD (STRING_DESC) =
!
! FUNCTION
!	Routine DBG$NNEXT_WORD isolates the next word of the input command. A word
!	is defined to be any number of alphabetic characters delimited by blanks
!	or a single non-alphabetic character. The word isolated is represented as
!	a counted string.
!
!	The input string is assumed to be terminated by a <cr>.
!
!	Maximum word size is 80 characters.
!
! FORMAL PARAMETERS:
!
!	STRING_DESC	- VAX standard string descriptor of the input command.
!
! IMPLICIT INPUTS:
!
!	WORD_BUF	- OWNed byte vector to contain the word of input.
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	The address of WORD_BUF, the counted string representing the next word
!	of input.
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	WORD_BUF is always filled with the next word of input. WORD_BUF[0]
!	contains the count of the characters in the word.  On exhausted input,
!	WORD_BUF[0] equals 0.  The command string descriptor is updated past
!	the word of input.
!

    BEGIN

    MAP
	STRING_DESC : REF DBG$STG_DESC;	! Input string descriptor

    LOCAL
	CHAR : BYTE,			! Holds next character of input
	POINTER,			! Temp pointer
	COUNT;				! Count of characters



    ! Check for exhausted input
    !
    IF .STRING_DESC [DSC$W_LENGTH] LEQ 0
    THEN
	BEGIN
	STRING_DESC [DSC$W_LENGTH] = 0;
	WORD_BUF [0] = 0;		! No word
	STRING_DESC [DSC$A_POINTER] = 0;
	RETURN WORD_BUF [0];
	END;


    ! Ignore leading white space
    !
    WHILE CH$RCHAR (.STRING_DESC [DSC$A_POINTER]) EQL ' ' DO
	BEGIN
	STRING_DESC [DSC$A_POINTER] = CH$PLUS (.STRING_DESC [DSC$A_POINTER], 1);
	STRING_DESC [DSC$W_LENGTH] = .STRING_DESC [DSC$W_LENGTH] - 1;
	END;


    ! Count the number of characters in the next word.  Note that we always
    ! return at least one character.
    !
    POINTER = .STRING_DESC [DSC$A_POINTER];
    CHAR = CH$RCHAR (.STRING_DESC [DSC$A_POINTER]);
    IF (.CHAR GEQ 'A' AND .CHAR LEQ 'Z')
    THEN
	BEGIN


	! We take more than one char
	!
	CHAR = CH$A_RCHAR (STRING_DESC [DSC$A_POINTER]);
	STRING_DESC [DSC$W_LENGTH] = .STRING_DESC [DSC$W_LENGTH] - 1;
	WHILE ((.CHAR GEQ 'A' AND .CHAR LEQ 'Z') OR .CHAR EQL '_') AND
	      CH$DIFF (.STRING_DESC [DSC$A_POINTER], .POINTER) LEQU WORD_SIZE
	DO
	    BEGIN
	    CHAR = CH$A_RCHAR (STRING_DESC [DSC$A_POINTER]);
	    STRING_DESC [DSC$W_LENGTH] = .STRING_DESC [DSC$W_LENGTH] - 1;
	    END;

	END


    ! Take one character only.
    !
    ELSE
	BEGIN
	CHAR = CH$A_RCHAR (STRING_DESC [DSC$A_POINTER]);
	STRING_DESC [DSC$W_LENGTH] = .STRING_DESC [DSC$W_LENGTH] - 1;
	END;


    ! Calculate the number of characters in the new word
    !
    COUNT = CH$DIFF (.STRING_DESC [DSC$A_POINTER], .POINTER);


    ! Now copy over th appropriate number of chars.
    !
    WORD_BUF [0] = .COUNT;
    CH$MOVE (.COUNT, .POINTER, WORD_BUF [1]);


    ! Check for exhausted input
    !
    IF .STRING_DESC [DSC$W_LENGTH] LEQ 0
    THEN
	BEGIN
	STRING_DESC [DSC$W_LENGTH] = 0;
	STRING_DESC [DSC$A_POINTER] = 0;
	END;

    RETURN WORD_BUF[0];

    END;

GLOBAL ROUTINE DBG$NPARSE_EXPRESSION(INPUT_DESC, RADIX,
				VALUE_DESC_PTR, TERM_INDEX, MESSAGE_VECT) =
!
! FUNCTION
!	This routine interfaces to the Expression Interpreter.
!	It first checks whether the expression is a DEFINEd name, in
!	which case the expansion is done.
!
! FORMAL PARAMETERS:
!
!	INPUT_DESC	- The address of a VAX Standard ASCII string descriptor
!			  which describes the user input.
!
!	RADIX		- A longword containing an integer encoding of the
!			  radix to be used for the interpretation of numeric
!			  literals.
!
!	VALUE_DESC_PTR	- The address of a longword to contain the address
!			  of a language specific value descriptor.
!
!	TERM_INDEX	- The "terminator index" value which indicates which
!			  lexical tokens are valid expression terminators in
!			  the current context.  For example, in the IF command,
!			  the keyword "THEN" is the valid expression termina-
!			  tor.  These index values have names of the form
!			  TOKEN$K_TERM_xxx.
!
!	MESSAGE_VECT	- The address of a longword to contain the address
!			  of a message argument vector for errors.
!
!	6th Optional Parameter - If this is present, and the value is
!			DBG$K_DEPOSIT_VERB then pass this into DBG$EXP_INT,
!			and into DBG$EXPRESSION_PARSER, so that in 
!			DBG$EXPRESSION_PARSER, when the expression is not
!			address expression and in deposit command, 
!			DBG$EVAL_LANG_OPERATOR will not be called with
!			DBG$GL_IDENTITY_TOKEN.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	Same as the Expression Interpreter.
!
! COMPLETION CODES:
!
!	Same as the Expression Interpreter.
!
! SIDE EFFECTS:
!
!	Same as the Expression Interpreter.
!

    BEGIN

    BUILTIN ACTUALCOUNT,ACTUALPARAMETER;


    ! Translate default radix.
    !    
    IF .RADIX EQL DBG$K_DEFAULT
    THEN
    	RADIX = .DBG$GB_RADIX[DBG$B_RADIX_INPUT];

    IF ACTUALCOUNT() GTR 5
    THEN
    	BEGIN
    	IF ACTUALPARAMETER(6) NEQ DBG$K_DEPOSIT_VERB
    	THEN
    	    $DBG_ERROR('DBGNPARSE\DBG$NPARSE_EXPRESSION');

        RETURN DBG$EXP_INT (.INPUT_DESC, .RADIX, .VALUE_DESC_PTR, .TERM_INDEX,
    		DBG$K_DEPOSIT_VERB);
    	END

    ELSE
        RETURN DBG$EXP_INT (.INPUT_DESC, .RADIX, .VALUE_DESC_PTR, .TERM_INDEX);
    END;

GLOBAL ROUTINE DBG$NPARSE_ADDRESS(INPUT_DESC, ADDR_EXP_PTR,
					RADIX, TERM_INDEX, MESSAGE_VECT) =
!
! FUNCTION
!	This routine interfaces to the Address Expression Interpreter to obtain
!	an address expression descriptor. Address expression descriptors are
!	used to describe the object of commands which use address expressions.
!	The descriptor may contain a pointer to a primary descriptor, a pointer
!	to a permanent symbol descriptor, an untyped L-value, or an L-value of
!	type instruction.
!
! INPUTS
!	INPUT_DESC	- A longword containing the address of a standard
!			  string descriptor describing the input command.
!
!	ADDR_EXP_PTR	- The address of a longword to contain the address
!			  of an address expression descriptor.
!
!	RADIX		- A longword containing the integer code of the
!			  radix to be used in interpreting numeric literals.
!
!	TERM_INDEX	- The "terminator index" value which indicates which
!			  lexical tokens are valid expression terminators in
!			  the current context.  For example, in the EXAMINE
!			  command, comma and colon are valid terminators (as
!			  is carriage-return).  These index values have names
!			  of the form TOKEN$K_TERM_xxx.
!
!	MESSAGE_VECT	- The address of a longword to contain the address
!			  of a message argument vector for errors.
!
! OUTPUTS
!	INPUT_DESC	- The input string descriptor is updated to point to
!			  the first character after the address expression
!			  that was just parsed.
!
!	ADDR_EXP_PTR	- An Address Expression Descriptor is constructed and
!			  its address is returned to ADDR_EXP_PTR.
!
!	MESSAGE_VECT	- If an error is encountered, a message argument vector
!			  may be constructed (unless the error is singalled)
!			  and its address returned to MESSAGE_VECT.
!
!	An unsigned integer longword completion code is returned as the routine
!			  value.  This is whatever completion code the Address
!			  Expression Interpreter returns.
!
    BEGIN

    MAP
    	INPUT_DESC: REF DBG$STG_DESC;

    BIND
	DBG$CS_CR = UPLIT BYTE (1, DBG$K_CAR_RETURN);

    LOCAL
	LENGTH,				! Current location length
	STATUS,				! Return status
	TYPE;				! Current location type



    ! Initialize type and length
    !
    TYPE = DBG$K_NOTYPE;
    LENGTH = 0;


    ! Translate default radix.
    !    
    IF .RADIX EQL DBG$K_DEFAULT
    THEN
    	RADIX = .DBG$GB_RADIX[DBG$B_RADIX_INPUT];


    ! Now call the Address Expression Interpreter appropriate for the current
    ! language.
    !
    STATUS = DBG$ADDR_EXP_INT(.INPUT_DESC, .ADDR_EXP_PTR,
					TYPE, LENGTH, .RADIX, .TERM_INDEX);

    ! Set the potential type and length for current location.
    !
    DBG$NSET_LAST_TYPLEN (.TYPE, .LENGTH);
    RETURN .STATUS;

    END;

GLOBAL ROUTINE DBG$NSAVE_DECIMAL_INTEGER(INPUT_DESC, RESULT) =
!
! FUNCTION
!	Extracts a numeric string from the command input string and converts it
!	to a binary longword integer.  Decimal radix is assumed for the input.
!
! INPUTS
!	INPUT_DESC - The address of a standard ASCII string descriptor
!		  pointing to the input command line to be scanned.
!
!	RESULT	- The address of a longword to receive the result, meaning
!		  the scanned integer value in internal format.
!
! OUTPUTS
!	INPUT_DESC - The input string descriptor is updated to point to the
!		  first character after the scanned integer constant.
!
!	RESULT	- The scanned integer value (in internal format) is returned
!		  the RESULT location.
!
!	The value STS$K_SUCCESS is always returned as the routine value.
!

    BEGIN

    BUILTIN
	EMUL;				! Multiply and add two longwords
    					!      to produce quadword result.

    MAP
	INPUT_DESC : REF DBG$STG_DESC;	! Input string descriptor

    BIND
	DBG$CS_CR = UPLIT BYTE(1, DBG$K_CAR_RETURN);

    LOCAL
	VALUE: VECTOR[2],		! Result quadword
	STRING_PTR,			! Pointer to input string
	TRUNC_FLAG,			! Indicates truncation
	CHAR;				! Holds characters



    ! Check for null input
    !
    IF DBG$NMATCH (.INPUT_DESC, DBG$CS_CR, 1)
    THEN
	SIGNAL(DBG$_NEEDMORE);


    ! Delete leading white space
    !
    STRING_PTR = .INPUT_DESC [DSC$A_POINTER];
    WHILE .INPUT_DESC [DSC$W_LENGTH] GTR 0 DO
	BEGIN
	CHAR = CH$RCHAR_A (STRING_PTR);
	INPUT_DESC [DSC$W_LENGTH] = .INPUT_DESC [DSC$W_LENGTH] - 1;
	IF (.CHAR NEQ DBG$K_BLANK) AND (.CHAR NEQ DBG$K_TAB) THEN EXITLOOP;
	END;


    ! Check for a numeric character. If we don't have one - syntax error.
    !
    IF (.CHAR LSS '0') OR (.CHAR GTR '9')
    THEN
	BEGIN
	INPUT_DESC [DSC$A_POINTER] = CH$PLUS (.STRING_PTR, -1);
	DBG$SYNTAX_ERROR(.INPUT_DESC);
	END;


    ! Now continue to accept numeric chars and convert them.  Loop until we
    ! find a non-numeric character.  In the loop, append each new digit to
    ! the number being accumulated, check for overflow, and loop for the next
    ! character.
    !
    VALUE [0] = 0;
    VALUE [1] = 0;
    TRUNC_FLAG = FALSE;
    WHILE (.CHAR GEQ '0') AND (.CHAR LEQ '9') DO
	BEGIN
	CHAR = .CHAR - '0';
	EMUL (VALUE [0], %REF (10), CHAR, VALUE);
	IF .VALUE [1] NEQ 0 THEN TRUNC_FLAG = TRUE;
	INPUT_DESC [DSC$W_LENGTH] = .INPUT_DESC [DSC$W_LENGTH] - 1;
	CHAR = CH$RCHAR_A (STRING_PTR);
	END;


    ! If the next character is an alphabetic character, signal a syntax error.
    ! This can happen if the user tries to enter a hex number, for example.
    !
    IF (.CHAR GEQ 'A') AND (.CHAR LEQ 'Z')
    THEN
	SIGNAL(DBG$_INVDIGDEC, 2, 1, CHAR);


    ! Update the input pointer and length. Remember that char right now contains
    ! the first non-numeric character of the remaining string. Therefore, string_ptr
    ! points one place to the right too far.
    !
    INPUT_DESC [DSC$W_LENGTH] = .INPUT_DESC [DSC$W_LENGTH] + 1;
    INPUT_DESC [DSC$A_POINTER] = CH$PLUS (.STRING_PTR, -1);


    ! Set up the result, check for truncation, and check for a negative number.
    !
    IF .TRUNC_FLAG THEN SIGNAL(DBG$_NUMTRUNC);
    IF .VALUE [0] LSS 0 THEN VALUE [0] = -.VALUE [0];
    .RESULT = .VALUE [0];
    RETURN STS$K_SUCCESS;

    END;

GLOBAL ROUTINE DBG$NSAVE_INTEGER(INPUT_DESC, RESULT) =
!
! FUNCTION
!	Extracts a numeric string from the command input string and converts it
!	to a binary longword integer.  The default radix is assumed for the
!	input.
!
! INPUTS
!	INPUT_DESC - The address of a standard ASCII string descriptor
!		  pointing to the input command line to be scanned.
!
!	RESULT	- The address of a longword to receive the result, meaning
!		  the scanned integer value in internal format.
!
! OUTPUTS
!	INPUT_DESC - The input string descriptor is updated to point to the
!		  first character after the scanned integer constant.
!
!	RESULT	- The scanned integer value (in internal format) is returned
!		  the RESULT location.
!
!	The value STS$K_SUCCESS is always returned as the routine value.
!

    BEGIN

    BUILTIN
	EMUL;				! Multiply and add two longwords
    					!      to produce quadword result.

    MAP
	INPUT_DESC : REF DBG$STG_DESC;	! Input string descriptor

    BIND
	DBG$CS_CR = UPLIT BYTE(1, DBG$K_CAR_RETURN);

    LOCAL
	VALUE: VECTOR[2],		! Result quadword
	STRING_PTR,			! Pointer to input string
	TRUNC_FLAG,			! Indicates truncation
	CHAR;				! Holds characters



    ! Check for null input
    !
    IF DBG$NMATCH (.INPUT_DESC, DBG$CS_CR, 1)
    THEN
	SIGNAL(DBG$_NEEDMORE);


    ! Delete leading white space
    !
    STRING_PTR = .INPUT_DESC [DSC$A_POINTER];
    WHILE .INPUT_DESC [DSC$W_LENGTH] GTR 0 DO
	BEGIN
	CHAR = CH$RCHAR_A (STRING_PTR);
	INPUT_DESC [DSC$W_LENGTH] = .INPUT_DESC [DSC$W_LENGTH] - 1;
	IF (.CHAR NEQ DBG$K_BLANK) AND (.CHAR NEQ DBG$K_TAB) THEN EXITLOOP;
	END;

    ! Case on the current radix setting.  We will believe this number to
    ! be in that radix.
    !
    SELECTONE .DBG$GB_RADIX[DBG$B_RADIX_INPUT] OF
        SET

        [DBG$K_BINARY] :
            BEGIN

            ! Check for a binary character. If we don't have one - syntax error.
            !
            IF (.CHAR LSS '0') OR (.CHAR GTR '1')
            THEN
	        BEGIN
	        INPUT_DESC [DSC$A_POINTER] = CH$PLUS (.STRING_PTR, -1);
	        DBG$SYNTAX_ERROR(.INPUT_DESC);
	    END;

            ! Now continue to accept binary chars and convert them.  Loop
            ! until we find a non-numeric character.  In the loop, append
            ! each new digit to the number being accumulated, check for
            ! overflow, and loop for the next character.
            !
            VALUE [0] = 0;
            VALUE [1] = 0;
            TRUNC_FLAG = FALSE;
            WHILE (.CHAR GEQ '0') AND (.CHAR LEQ '1') DO
	    BEGIN
	        CHAR = .CHAR - '0';
	        EMUL (VALUE [0], %REF (2), CHAR, VALUE);
	        IF .VALUE [1] NEQ 0 THEN TRUNC_FLAG = TRUE;
	        INPUT_DESC [DSC$W_LENGTH] = .INPUT_DESC [DSC$W_LENGTH] - 1;
	        CHAR = CH$RCHAR_A (STRING_PTR);
	    END;

            ! If the next character is an alphabetic character, signal a
            ! syntax error.  This can happen if the user tries to enter a
            ! hex number, for example.
            !
            IF (.CHAR GEQ 'A') AND (.CHAR LEQ 'Z') OR
               (.CHAR GEQ '2') AND (.CHAR LEQ '9')
            THEN
	        SIGNAL(DBG$_INVDIGBIN, 2, 1, CHAR);

            END;

        [DBG$K_OCTAL] :
            BEGIN

            ! Check for a octal character. If we don't have one - syntax error.
            !
            IF (.CHAR LSS '0') OR (.CHAR GTR '7')
            THEN
	        BEGIN
	        INPUT_DESC [DSC$A_POINTER] = CH$PLUS (.STRING_PTR, -1);
	        DBG$SYNTAX_ERROR(.INPUT_DESC);
	    END;

            ! Now continue to accept numeric chars and convert them.  Loop
            ! until we find a non-numeric character.  In the loop, append
            ! each new digit to the number being accumulated, check for
            ! overflow, and loop for the next character.
            !
            VALUE [0] = 0;
            VALUE [1] = 0;
            TRUNC_FLAG = FALSE;
            WHILE (.CHAR GEQ '0') AND (.CHAR LEQ '7') DO
	    BEGIN
	        CHAR = .CHAR - '0';
	        EMUL (VALUE [0], %REF (8), CHAR, VALUE);
	        IF .VALUE [1] NEQ 0 THEN TRUNC_FLAG = TRUE;
	        INPUT_DESC [DSC$W_LENGTH] = .INPUT_DESC [DSC$W_LENGTH] - 1;
	        CHAR = CH$RCHAR_A (STRING_PTR);
	    END;

            ! If the next character is an alphabetic character, signal a
            ! syntax error.  This can happen if the user tries to enter a
            ! hex number, for example.
            !
            IF (.CHAR GEQ 'A') AND (.CHAR LEQ 'Z') OR
               (.CHAR GEQ '8') AND (.CHAR LEQ '9')
            THEN
	        SIGNAL(DBG$_INVDIGOCT, 2, 1, CHAR);

            END;

        [DBG$K_DECIMAL] :
            BEGIN

            ! Check for a decimal character. If we don't have one - syntax error.
            !
            IF (.CHAR LSS '0') OR (.CHAR GTR '9')
            THEN
	        BEGIN
	        INPUT_DESC [DSC$A_POINTER] = CH$PLUS (.STRING_PTR, -1);
	        DBG$SYNTAX_ERROR(.INPUT_DESC);
	    END;

            ! Now continue to accept numeric chars and convert them.  Loop
            ! until we find a non-numeric character.  In the loop, append
            ! each new digit to the number being accumulated, check for
            ! overflow, and loop for the next character.
            !
            VALUE [0] = 0;
            VALUE [1] = 0;
            TRUNC_FLAG = FALSE;
            WHILE (.CHAR GEQ '0') AND (.CHAR LEQ '9') DO
	    BEGIN
	        CHAR = .CHAR - '0';
	        EMUL (VALUE [0], %REF (10), CHAR, VALUE);
	        IF .VALUE [1] NEQ 0 THEN TRUNC_FLAG = TRUE;
	        INPUT_DESC [DSC$W_LENGTH] = .INPUT_DESC [DSC$W_LENGTH] - 1;
	        CHAR = CH$RCHAR_A (STRING_PTR);
	    END;

            ! If the next character is an alphabetic character, signal a
            ! syntax error.  This can happen if the user tries to enter a
            ! hex number, for example.
            !
            IF (.CHAR GEQ 'A') AND (.CHAR LEQ 'Z')
            THEN
	        SIGNAL(DBG$_INVDIGDEC, 2, 1, CHAR);

            END;

        [DBG$K_HEX] :
            BEGIN

            ! Check for a hexidecimal character. If we don't have one - syntax error.
            !
            IF ((.CHAR LSS '0') OR (.CHAR GTR '9')) AND
               ((.CHAR LSS 'A') OR (.CHAR GTR 'F'))
            THEN
	        BEGIN
	        INPUT_DESC [DSC$A_POINTER] = CH$PLUS (.STRING_PTR, -1);
	        DBG$SYNTAX_ERROR(.INPUT_DESC);
	    END;

            ! Now continue to accept hexidecimal chars and convert them.
            ! Loop until we find a non-numeric character.  In the loop,
            ! append each new digit to the number being accumulated, check
            ! for overflow, and loop for the next character.
            !
            VALUE [0] = 0;
            VALUE [1] = 0;
            TRUNC_FLAG = FALSE;
            WHILE (.CHAR GEQ '0') AND (.CHAR LEQ '9') OR
                  (.CHAR GEQ 'A') AND (.CHAR LEQ 'F') DO
	    BEGIN
                IF (.CHAR GEQ '0') AND (.CHAR LEQ '9')
                THEN
                    CHAR = .CHAR - '0'
                ELSE
                    CHAR = .CHAR - 55;
	        EMUL (VALUE [0], %REF (16), CHAR, VALUE);
	        IF .VALUE [1] NEQ 0 THEN TRUNC_FLAG = TRUE;
	        INPUT_DESC [DSC$W_LENGTH] = .INPUT_DESC [DSC$W_LENGTH] - 1;
	        CHAR = CH$RCHAR_A (STRING_PTR);
	    END;

            ! If the next character is an alphabetic character, signal a
            ! syntax error.
            !
            IF (.CHAR GEQ 'G') AND (.CHAR LEQ 'Z')
            THEN
	        SIGNAL(DBG$_INVDIGHEX, 2, 1, CHAR);

            END;

        [OTHERWISE] :
            BEGIN
            $DBG_ERROR('DBGNPARSE\DBG$NSAVE_INTEGER, DBG$GB_RADIX is invalid');
            END;

        TES;

    ! Update the input pointer and length. Remember that char right now contains
    ! the first non-numeric character of the remaining string. Therefore, string_ptr
    ! points one place to the right too far.
    !
    INPUT_DESC [DSC$W_LENGTH] = .INPUT_DESC [DSC$W_LENGTH] + 1;
    INPUT_DESC [DSC$A_POINTER] = CH$PLUS (.STRING_PTR, -1);


    ! Set up the result, check for truncation, and check for a negative number.
    !
    IF .TRUNC_FLAG THEN SIGNAL(DBG$_NUMTRUNC);
    IF .VALUE [0] LSS 0 THEN VALUE [0] = -.VALUE [0];
    .RESULT = .VALUE [0];
    RETURN STS$K_SUCCESS;

    END;

GLOBAL ROUTINE DBG$NSAVE_STRING(INPUT_DESC, BUFF_PTR, MESSAGE_VECT) =
!
! FUNCTION
!	This routine accepts the next string from the input buffer
!	and stores it away in a dynamic buffer. Leading white space is ignored.
!	Trailing white space, comma, or <cr> terminate the string.
!	The saved string is stored as a counted string.
!
! FORMAL PARAMETERS:
!
!	INPUT_DESC	- The address of a VAX standard ASCII string
!			  descriptor which describes input user command.
!
!	BUFF_PTR	- The address of a longword to contain the beginning
!			  address of the stored counted string.
!
!	MESSAGE_VECT	- The address of a longword to contain the address
!			  of a message argument vector for errors.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	On success, the stored counted ASCII string.
!
!	On failure, a message argument vector.
!
! ROUTINE VALUE:
!
!	An unsigned integer longword completion code
!
! COMPLETION CODES:
!
!	STS$K_SUCCESS (1)	- Success. String isolated and stored.
!
!	STS$K_SEVERE  (4)	- Failure. No string stored. Message argument
!				  vector returned.
!
!				  Note that this routine returns failure if a
!				  string cannot be found. A NEEDMORE
!				  message is constructed in such cases.
!
! SIDE EFFECTS:
!
!	The input buffer is updated to reflect one character beyond the last
!	character accepted.
!

    BEGIN

    MAP
	INPUT_DESC : REF DBG$STG_DESC;	! Input string descriptor

    BIND
	DBG$CS_CR = UPLIT BYTE(1, DBG$K_CAR_RETURN);

    LOCAL
	STRING: REF VECTOR[,BYTE],	! Will hold the string
	COUNT,				! Count of characters in string
	POINTER;			! Temporary pointer



    ! Check for null input
    !
    IF DBG$NMATCH (.INPUT_DESC, DBG$CS_CR, 1)
    THEN
	BEGIN
	.MESSAGE_VECT = DBG$NMAKE_ARG_VECT (DBG$_NEEDMORE);
	RETURN STS$K_SEVERE;
	END;


    ! Delete leading white space
    !
    WHILE CH$RCHAR (.INPUT_DESC [DSC$A_POINTER]) EQL ' ' DO
	BEGIN
	INPUT_DESC [DSC$A_POINTER] = CH$PLUS (.INPUT_DESC [DSC$A_POINTER], 1);
	INPUT_DESC [DSC$W_LENGTH] = .INPUT_DESC [DSC$W_LENGTH] - 1;
	END;


    ! Save the start of the string
    !
    POINTER = .INPUT_DESC [DSC$A_POINTER];


    ! Now look for a comma, a blank, or <cr>
    !
    WHILE CH$RCHAR (.INPUT_DESC [DSC$A_POINTER]) NEQ ' ' AND CH$RCHAR (.INPUT_DESC [DSC$A_POINTER]) NEQ ','
	AND CH$RCHAR (.INPUT_DESC [DSC$A_POINTER]) NEQ DBG$K_CAR_RETURN DO
	BEGIN
	INPUT_DESC [DSC$A_POINTER] = CH$PLUS (.INPUT_DESC [DSC$A_POINTER], 1);
	INPUT_DESC [DSC$W_LENGTH] = .INPUT_DESC [DSC$W_LENGTH] - 1;
	END;


    ! Figure out how many characters to save
    !
    COUNT = CH$DIFF (.INPUT_DESC [DSC$A_POINTER], .POINTER);


    ! Allocate the proper size buffer
    !
    STRING = DBG$GET_TEMPMEM ((.COUNT/%UPVAL) + 1);


    ! Copy over the count and the characters.
    !
    STRING [0] = .COUNT;
    CH$MOVE (.COUNT, .POINTER, STRING [1]);


    ! Set up the output parameter and return
    !
    .BUFF_PTR = STRING [0];
    RETURN STS$K_SUCCESS;

    END;

GLOBAL ROUTINE DBG$NGET_DIR_LIST (LEX_STG_DESC, RESULT_PTR, MESSAGE_VECT) =
!
! FUNCTION
!
!	Parse a directory list. Used by the command
!	SET SOURCE dir-list
!
! INPUTS
!
!	LEX_STG_DESC   - A string descriptor for the unparsed
!			 directory list.
!	RESULT_PTR     - The result of the parse will be placed at the
!			 address given by result_ptr.
!	MESSAGE_VECT   - Address of a longword to contain the address of
!			 the message argument vector.
!
! OUTPUTS
!
!	This routine builds a linked list of directory names and
!	leaves a pointer to this list in result_ptr.
!
! ROUTINE VALUE
!
!	A completion code which is one of either:
!	STS$K_SEVERE (4)	Unsuccessful parse
!	STS$K_SUCCESS (1)	Successful parse
!
! ALGORITHM
!
!	The directory list will be of the form:
!	[dir1]file1,[dir2]file2,...[dirn]filen
!	Do until end of list is reached:
!	    Pick up a single directory name by scanning until
!	    a separating comma is reached (commas inside of
!	    square brackets are ignored)
!	    Allocate space for a node containing the directory name.
!	    Copy the directory name into this node, and
!	    link the node into the list.
!

    BEGIN

    MAP
	LEX_STG_DESC : REF BLOCK [, BYTE]; ! Input string descriptor

    LOCAL
	TOT_LENGTH,			! Number of chars to be read from
					!      PARSE_STG_DESC
	TOT_CHARS_READ,			! Number of chars read from
					!      PARSE_STG_DESC so far
	CHARS_READ,			! Number of chars in directory name
					!      under construction
	IN_BRACKETS,			! TRUE if we are inside of square
					!      brackets
	CHAR,				! Current character
	PREV_CHAR_PTR,			! ???
	FIRST_DIR_FLAG,			! TRUE if this is first directory in
					!      list
	PREV_DIRNAME: REF SDSL$ENTRY,	! Previous directory name
	CURR_DIRNAME: REF SDSL$ENTRY,	! Current directory name
	FIRST_DIRNAME,			! Pointer to first directory name
					!      (head of linked list)
	INPUT_PTR,			! ???
	OUTPUT_PTR,			! ???
	NEW_INPUT_PTR,			! ???
	PREV_CHAR,			! ???
	QUOTE_FLAG,			! TRUE if the directory currently being
					!      processed is inside of quotes
	DBLQUOTE_FLAG;			! TRUE if the directory currently being
					!      processed is inside double quotes



    ! Initialize the various flags and counters we need.
    !
    IN_BRACKETS = FALSE;
    TOT_LENGTH = .LEX_STG_DESC [DSC$W_LENGTH];
    TOT_CHARS_READ = 0;
    QUOTE_FLAG = FALSE;
    DBLQUOTE_FLAG = FALSE;
    CHARS_READ = 0;


    ! FIRST_DIR_FLAG is true initially because we are processing the
    ! first directory in the list.
    !
    FIRST_DIR_FLAG = TRUE;
    PREV_DIRNAME = 0;
    WHILE .TOT_CHARS_READ LSS .TOT_LENGTH DO
	BEGIN
	INPUT_PTR = CH$PTR (.LEX_STG_DESC [DSC$A_POINTER]);
	CHAR = CH$RCHAR_A (INPUT_PTR);


	! Skip leading blanks
	!
	WHILE .CHAR EQL DBG$K_BLANK AND .TOT_CHARS_READ LSS .TOT_LENGTH DO
	    BEGIN
	    CHAR = CH$RCHAR_A (INPUT_PTR);
	    TOT_CHARS_READ = .TOT_CHARS_READ + 1;
	    LEX_STG_DESC [DSC$A_POINTER] =
				CH$PLUS(.LEX_STG_DESC [DSC$A_POINTER], 1);
	    LEX_STG_DESC [DSC$W_LENGTH] = .LEX_STG_DESC [DSC$W_LENGTH] - 1;
	    END;

	IF .CHAR EQL DBG$K_QUOTE OR .CHAR EQL DBG$K_DBLQUOTE
	THEN
	    BEGIN
	    IF .CHAR EQL DBG$K_QUOTE
	    THEN
		QUOTE_FLAG = TRUE

	    ELSE
		DBLQUOTE_FLAG = TRUE;


	    ! Advance the pointer past the quote.
	    !
	    LEX_STG_DESC [DSC$A_POINTER] =
				CH$PLUS(.LEX_STG_DESC [DSC$A_POINTER], 1);
	    LEX_STG_DESC [DSC$W_LENGTH] = .LEX_STG_DESC [DSC$W_LENGTH] - 1;
	    TOT_CHARS_READ = .TOT_CHARS_READ + 1;
	    CHAR = CH$RCHAR_A (INPUT_PTR);
	    END;


	! Pick up next directory name.
	!
	WHILE .TOT_CHARS_READ LSS .TOT_LENGTH AND
	      .CHAR NEQ DBG$K_CAR_RETURN AND
	      (.CHAR NEQU %C',' OR .IN_BRACKETS)
	DO
		BEGIN
	    IF .CHAR EQLU %C'[' OR .CHAR EQLU %C'<' THEN IN_BRACKETS = TRUE;
	    IF .CHAR EQLU %C']' OR .CHAR EQLU %C'>' THEN IN_BRACKETS = FALSE;
	    IF .CHAR NEQ DBG$K_BLANK
	    THEN
		PREV_CHAR_PTR = CH$PLUS (.INPUT_PTR, -1);

	    PREV_CHAR = .CHAR;
	    CHAR = CH$RCHAR_A (INPUT_PTR);


	    ! If this is a doubled up quote character, undouble them and mark
	    ! the position.
	    !
	    IF .DBLQUOTE_FLAG           AND
	       .CHAR EQL DBG$K_DBLQUOTE AND
	       .PREV_CHAR EQL DBG$K_DBLQUOTE
	    THEN
		(.PREV_CHAR_PTR)<0, 8, 0> = 0;

	    TOT_CHARS_READ = .TOT_CHARS_READ + 1;
	    CHARS_READ = .CHARS_READ + 1;
	    END;			! End of inner while loop


	! We now have a complete directory name.  Allocate space for it.
	!
	CURR_DIRNAME = DBG$GET_MEMORY (2 + (1 + .CHARS_READ)/%UPVAL);
	IF (.FIRST_DIR_FLAG)
	THEN
	    BEGIN
	    FIRST_DIR_FLAG = FALSE;
	    FIRST_DIRNAME = .CURR_DIRNAME;
	    END;


	! Link in next directory name
	!
	IF (.PREV_DIRNAME NEQA 0)
	THEN
	    PREV_DIRNAME [SDSL$L_ENT_FLINK] = .CURR_DIRNAME;


	! Set PREV_DIRNAME for next time around loop.
	!
	PREV_DIRNAME = .CURR_DIRNAME;


	! Fill in the fields of CURR_DIRNAME.
	!
	CURR_DIRNAME [SDSL$L_ENT_FLINK] = 0;
	CURR_DIRNAME [SDSL$B_ENT_DIRLEN] = 0;
	NEW_INPUT_PTR = CH$PTR (.LEX_STG_DESC [DSC$A_POINTER]);
	OUTPUT_PTR = CH$PTR (.CURR_DIRNAME + 5);
	INCR I FROM 0 TO .CHARS_READ - 1 DO
	    BEGIN
	    CHAR = CH$RCHAR_A (NEW_INPUT_PTR);
	    IF .CHAR NEQ 0
	    THEN
		BEGIN
		CH$WCHAR_A (.CHAR, OUTPUT_PTR);
		CURR_DIRNAME [SDSL$B_ENT_DIRLEN] =
				.CURR_DIRNAME [SDSL$B_ENT_DIRLEN] + 1;
		END;

	    END;


	! Strip off trailing quote.
	!
	IF .QUOTE_FLAG
	THEN
	    BEGIN
	    IF CH$RCHAR (.PREV_CHAR_PTR) EQL DBG$K_QUOTE
	    THEN
		BEGIN
		CURR_DIRNAME [SDSL$B_ENT_DIRLEN] = .CURR_DIRNAME[SDSL$B_ENT_DIRLEN]
					- (.INPUT_PTR - .PREV_CHAR_PTR - 1);
		QUOTE_FLAG = FALSE;
		END

	    END


	! ???
	!
	ELSE IF .DBLQUOTE_FLAG
	THEN
	    BEGIN
	    IF CH$RCHAR (.PREV_CHAR_PTR) EQL DBG$K_DBLQUOTE
	    THEN
		BEGIN
		CURR_DIRNAME [SDSL$B_ENT_DIRLEN] = .CURR_DIRNAME [SDSL$B_ENT_DIRLEN] - (.INPUT_PTR -
		.PREV_CHAR_PTR - 1);
		DBLQUOTE_FLAG = FALSE;
		END;

	    END;


	! If there are still characters left in the input string, increment
	! CHARS_READ to take us past the separating comma.
	!
	IF .TOT_CHARS_READ LSS .TOT_LENGTH
	THEN
	    BEGIN
	    CHARS_READ = .CHARS_READ + 1;
	    TOT_CHARS_READ = .TOT_CHARS_READ + 1;
	    END;

	LEX_STG_DESC [DSC$W_LENGTH] = .LEX_STG_DESC [DSC$W_LENGTH] - .CHARS_READ;
	LEX_STG_DESC [DSC$A_POINTER] = CH$PLUS (.LEX_STG_DESC [DSC$A_POINTER], .CHARS_READ);
	CHARS_READ = 0;
	END;				! End of outer while loop

    IF .QUOTE_FLAG OR .DBLQUOTE_FLAG THEN SIGNAL (DBG$_MATQUOMIS);


    ! Place pointer to linked list into into the result pointer.
    .RESULT_PTR = .FIRST_DIRNAME;
    RETURN STS$K_SUCCESS

    END;

GLOBAL ROUTINE DBG$EXPAND_DEFINE_NAME(INPUT_DESC, KIND, RESULT_ADDR) =
!
! FUNCTION
!	This routine checks for the next symbol in the input stream being
!	a name which has been define with the DEFINE command. If so, and
!	if the kind matches the kind given in the input parameter, then
!	the corresponding value is returned in result_addr.
!
! INPUTS
!	INPUT_DESC -	A string descriptor for the remaining input.
!
!	KIND -		The kind of DEFINE symbol we are expecting (one
!			of define_address, define_command, define_procedure,
!			define_string, or define_value)
!
!	RESULT_ADDR -	The address in which to leave the result
!
! OUTPUTS
!	The routine value is one of:
!	TRUE -	A matching symbol was found
!	FALSE -	A matching symbol was not found
!
!	If TRUE, the output parameter RESULT_ADDR is filled in.
!	Also, the input descriptor is updated to point past the name
!	that was read.
!

    BEGIN

    MAP
	INPUT_DESC: REF BLOCK[,BYTE];	! Input string descriptor

    LOCAL
	FOUND_FLAG,			! TRUE if we found a DEFINEd
					!     symbol matching the input
	GLOBAL_FLAG,			! Holds an output value for
					!     DBG$DEF_SYM_FIND
	MESSAGE_VECT,			! Dummy error message vector
	NAME_PTR: REF VECTOR[,BYTE],	! Points to a name which
					!     could potentially be
					!     a DEFINEd symbol.
	SAVED_INPUT_LENGTH,		! Copy of the length from the
					!     original input descriptor
	SAVED_INPUT_POINTER,		! Copy of the pointer from the
					!     original input descriptor
	SYMBOL_KIND,			! Kind of defined symbol
	SYMBOL_VALUE;			! Value of DEFINEd symbol



    ! Initialize found_flag.
    !
    FOUND_FLAG = FALSE;


    ! First save away the input descriptor.
    !
    SAVED_INPUT_POINTER = .INPUT_DESC [DSC$A_POINTER];
    SAVED_INPUT_LENGTH = .INPUT_DESC [DSC$W_LENGTH];


    ! Now attempt to read a name which potentially could be DEFINEd.
    !
    IF DBG$NREAD_NAME (.INPUT_DESC, NAME_PTR, MESSAGE_VECT)
    THEN
	BEGIN


	! If we read a name, we now attempt to look it up.
	!
	IF DBG$DEF_SYM_FIND (.NAME_PTR, SYMBOL_KIND,
				SYMBOL_VALUE, GLOBAL_FLAG, MESSAGE_VECT)
	THEN
	    BEGIN


	    ! Found a definition. Check the type of symbol. We expect
	    ! the kind to match what is given in "kind" at this point.
	    !
	    IF .SYMBOL_KIND EQL .KIND
	    THEN
		BEGIN
		.RESULT_ADDR = .SYMBOL_VALUE;
		FOUND_FLAG = TRUE;
		END;

	    END;


	! Deallocate the space for the name.
	!
	DBG$REL_MEMORY(.NAME_PTR);
	END;


    ! If we found a symbol, return success.  Otherwise, back up the input
    ! descriptor so that it will be returned unchanged.
    !
    IF .FOUND_FLAG THEN RETURN TRUE;
    INPUT_DESC [DSC$A_POINTER] = .SAVED_INPUT_POINTER;
    INPUT_DESC [DSC$W_LENGTH] = .SAVED_INPUT_LENGTH;
    RETURN FALSE;

    END;

GLOBAL ROUTINE DBG$SYNTAX_ERROR(INPUT_DESC): NOVALUE =
!
! FUNCTION
!	This routine is called when a syntax error has occurred because
!	an expected piece of input was not found.  The routine accepts
!	an input string descriptor as input which is expected to point
!	to the start of the offending piece of command input.  It then
!	signals the "need more input" message if the next character is
!	a carriage-return (unexpected end of input) or the "syntax error"
!	error message otherwise.
!
! INPUTS
!	INPUT_DESC - A pointer to a string descriptor which points to the
!		  current parse position in the input command line.
!
! OUTPUTS
!	INPUT_DESC - The input string descriptor may be updated to point
!		  to the first character after the offending syntactic
!		  entity.
!
!	Since this routine always exits by signalling out, no value is
!		  ever returned.  Control is not returned either.
!

    BEGIN

    BIND
	DBG$CS_CR	= UPLIT BYTE(1, 13);	! Carriage return character

    LOCAL
	STRDESC: BLOCK[8,BYTE],		! String descriptor
	STRPTR: REF VECTOR[,BYTE];	! Pointer to error string



    ! If the line has already ended, signal the "need more" error message.
    ! Otherwise, signal the "syntax error" error message.
    !
    IF DBG$NMATCH(.INPUT_DESC, DBG$CS_CR, 1) THEN SIGNAL(DBG$_NEEDMORE);
    STRPTR = DBG$NNEXT_WORD(.INPUT_DESC);
    STRDESC[DSC$B_CLASS] = DSC$K_CLASS_S;
    STRDESC[DSC$B_DTYPE] = DSC$K_DTYPE_T;
    STRDESC[DSC$W_LENGTH] = .STRPTR[0];
    STRDESC[DSC$A_POINTER] = STRPTR[1];
    SIGNAL(DBG$_SYNTAX, 1, STRDESC);
    RETURN;

    END;

END ELUDOM
