	.TITLE	GOTO - GOTO COMMAND EXECUTION
	.IDENT	'V04-000'
 
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; GOTO COMMAND EXECUTION
;
; D. N. CUTLER 6-MAY-77
;
; MODIFIED BY:
;
;	V03-007	HWS0003		Harold Schultz		06-FEB-1984
;		Treat lines that begin without a '$' and end with a
;		'-' as a line of data and not as a command continuation.
;
;	V03-006	PCG0006		Peter George		28-Nov-1983
;		Allow blanks to appear between label and trailing colon.
;
;	V03-005	PCG0005		Peter George		15-Jul-1983
;		Use multi-national upcase algorithm.
;		Support null nodes.
;
;	V03-004	PCG0004		Peter George		23-Jun-1983
;		Clear DCL_L_SYMBOL after deallocating it.
;
;	V03-003	PCG0003		Peter George		25-Apr-1983
;		Do not return if success.  Branch to DCL$RESTART.
;
;	V03-002	PCG0002		Peter George		01-Apr-1983
;		Perform foward goto scanning here.
;
;	V03-001	PCG0001		Peter George		24-Feb-1983
;		Remove SETBIT WRK_V_NOSTAT.
;---

;
; MACRO LIBRARY CALLS
;
	PRCDEF				;DEFINE PROCESS WORK AREA
	WRKDEF				;DEFINE COMMAND WORK AREA
	SYMDEF				;DEFINE SYMBOL ENTRY OFFSETS
	$CLIMSGDEF			;DEFINE ERROR/STATUS VALUES
	$DEVDEF				;DEFINE DEVICE CHARACTERISTIC BITS
	$RABDEF				;DEFINE RAB OFFSETS
	$STSDEF				;DEFINE MESSAGE BITS

	.PSECT	DCL$ZCODE,BYTE,RD,NOWRT

TERM:	.ASCII	\:/+,-()]>?=^#@*'[<.; !	\
	.BYTE	0
TERMEND:

	.SBTTL	GOTO LABEL
;+
; DCL$GOTO - GOTO LABEL
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO EXECUTE THE GOTO LABEL DCLS
; COMMAND.
;
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; OUTPUTS:
;
;	THE SPECIFIED LABEL IS SEARCHED FOR IN THE CURRENT LABEL TABLE, AND IF
;	FOUND, A RANDOM FIND IS EXECUTED TO POSITION THE INPUT FILE FOR SUBSE-
;	QUENT GET OPERATIONS. OTHERWISE A FORWARD GOTO SEARCH IS EXECUTED.
;-

DCL$GOTO::					;GOTO LABEL

;
; DISABLE CTRL/Y AST'S.
;
	DISABLE					;DISABLE CTRL/Y'S
	CLRQ	(SP)+				;REMOVE RETURN INFO FROM STACK
	SETBIT	WRK_V_NOSTAT,WRK_W_FLAGS(R10)	;DO NOT CHANGE $STATUS ON SUCCESS

;
; CHECK IF GOTO'S ARE ALLOWED.
;
	MOVL	PRC_L_INDINPRAB(R11),R0		;GET CURRENT INPUT RAB
	BBC	#DEV$V_RND,RAB$L_CTX(R0),10$ 	;IF CLR, NOT RANDOM ACCESS DEVICE

;
; GET DESTINATION.  CHECK IF IT'S ALREADY DEFINED.
;
	BSBW	DCL$GETDVAL			;GET LABEL DESCRIPTOR VALUES
	MOVQ	R1,-(SP)			;SAVE LABEL DESCRIPTOR
	MOVAB	PRC_Q_LABEL(R11),R0		;GET ADDRESS OF LABEL TABLE LISTHEAD
	BSBW	DCL$SEARCHT			;SEARCH TABLE FOR LABEL
	MOVQ	(SP)+,R1			;RESTORE LABEL DESCRIPTOR
	BLBC	R0,30$				;IF LBC LABEL NOT FOUND

;
; LABEL DEFINED - POINT TO PROPER RECORD
;
	MOVL	R3,R6				;COPY SYMBOL ADDRESS
	MOVQ	R1,R4				;COPY LABEL DESCRIPTOR
5$:	MOVL	PRC_L_INDINPRAB(R11),R7		;GET ADDRESS OF INDIRECT FILE RAB
	MOVC	#6,SYM_T_SYMBOL+3(R6)[R4],-	;RESTORE RECORD FILE ADDRESS
		RAB$W_RFA(R7) 			;
	MOVB	#RAB$C_RFA,RAB$B_RAC(R7) 	;SET ACCESS MODE FOR RANDOM FIND
	$FIND	RAB=(R7)			;FIND RECORD THAT HAS LABEL
	BLBC	R0,20$				;SIGNAL ANY ERRORS
	MOVB	#RAB$C_SEQ,RAB$B_RAC(R7) 	;RESET TO SEQUENTIAL ACCESS MODE
	BRW	DCL$RESTART			;EXECUTE THE SPECIFIED COMMAND
10$:	STATUS	NORMAL				;SET NORMAL STATUS
20$:	RSB					;RETURN

;
; RETURN SYMOVF.
;
22$:	STATUS	SYMOVF				;
	RSB					;

;
; LABEL NOT DEFINED.  SAVE IT IN THE SYMBOL TABLE.
;
30$:	MOVQ	R1,R4				;SAVE DESCRIPTOR OF LABEL
	ADDL	#1,R1				;ADD IN LABEL_SIZE BYTE
	BSBW	DCL$ALLDYNMEM			;ALLOCATE DYNAMIC MEMORY
	BLBC	R0,22$				;BR IF FAILED
	MOVL	R2,PRC_L_SYMBOL(R11)		;SAVE TARGET FOR GOTO
	MOVB	R4,(R2)+			;SET SIZE OF LABEL STRING
	MOVC	R4,(R5),(R2)			;FILL IN LABEL NAME

;
; LOOK AHEAD FOR THE LABEL.
;
	BISW	#PRC_M_GOTO,PRC_W_FLAGS(R11) 	;SET FORWARD GOTO IN PROGRESS
40$:	BISW	#PRC_M_IND,PRC_W_FLAGS(R11) 	;IGNORE @ SIGNS
	BSBW	DCL$INPUT			;GET NEXT COMMAND
	BICW	#PRC_M_IND,PRC_W_FLAGS(R11) 	;RESTORE @ SIGNS
	BBC	#PRC_V_GOTO,PRC_W_FLAGS(R11),25$;BRANCH IF EOF
	MOVL	WRK_L_CHARPTR(R10),R3		;POINT TO FIRST CHARACTER
	DECL	R3				;BACK UP A CHAR

;
; IGNORE LEADING BLANKS, LEADING "$", AND LINES THAT ARE ENTIRELY BLANK.
;
	CLRL	R0				;ASSUME NO "$"
50$:	INCL	R3				;GET NEXT CHAR
	TSTB	(R3)				;EOL?
	BEQL	40$				;YES, THEN GET NEXT LINE
	CMPB	#^X20,(R3)			;SKIP LEADING BLANKS
	BEQL	50$				;
	CMPB	#^X09,(R3)			;
	BEQL	50$				;
	CMPB	#^A/$/,(R3)			;SKIP LEADING "$"
	BNEQ	53$				;BRANCH IF NOT
	BBCS	#0,R0,50$			;SET FLAG, GET NEXT CHAR
	BRW	70$				;FLUSH IF PREVIOUSLY SET

;
; EOF ENCOUNTERED.  RETURN USGOTO.
;
25$:	MOVL	#CLI$_USGOTO!STS$M_INHIB_MSG,R0	;SET UNSATISFIED GOTO STATUS
	RSB					;

;
; DETERMINE IF THERE IS A LABEL ON THIS LINE.
;
53$:	MOVL	R3,R2				;SAVE START OF LABEL PTR
55$:	LOCC	(R3),#TERMEND-TERM,TERM		;FIND THE FIRST TERMINATOR
	BNEQ	58$				;BRANCH IF FOUND
	CMPB	(R3),#^A/a/			;CHECK LOW LIMIT OF LOW RANGE
	BLSSU	57$				;BR IF FAILED
	CMPB	(R3),#^A/z/			;CHECK HIGH LIMIT OF LOW RANGE
	BLEQU	56$				;BR IF VALID CHARACTER
	CMPB	(R3),#^XE0			;CHECK LOW LIMIT OF HIGH RANGE
	BLSSU	57$				;BR IF FAILED
	CMPB	(R3),#^XFE			;CHECK HIGH LIMIT OF HIGH RANGE
	BGTRU	57$				;BR IF FAILED
56$:	BICB	#^X20,(R3)			;UPCASE THE CHARACTER
57$:	INCL	R3				;GET NEXT CHAR
	BRB	55$				;CHECK NEXT CHAR

58$:	MOVL	R3,R1				;SAVE END OF LABEL PTR
	BRB	60$				;

59$:	INCL	R3				;GET NEXT CHAR
60$:	CMPB	#^X20,(R3)			;SKIP BLANKS
	BEQL	59$				;
	CMPB	#^X09,(R3)			;
	BEQL	59$				;
	CMPB	#^A/:/,(R3)			;WAS IT A COLON?
	BNEQ	70$				;NO, FLUSH THIS RECORD
	CMPB	#^A/:/,1(R3)			;IS IT A NULL NODE?
	BEQL	70$				;YES, FLUSH THIS RECORD
	CMPB	#^A/=/,1(R3)			;IS IT AN ASSIGNMENT?
	BEQL	70$				;YES, FLUSH THIS RECORD

;
; A LABEL HAS BEEN FOUND.  INSERT IT IN THE LABEL TABLE.
;
	SUBL	R2,R1				;GET LENGTH OF LABEL
	BSBW	DCL$ALLOC_LABEL			;ALLOCATE A LABEL SYMBOL FOR IT
	BLBS	R0,65$				;BRANCH IF SUCCESS
	BICW	#PRC_M_GOTO,PRC_W_FLAGS(R11)	;CLEAR GOTO IN PROGRESS FLAGS
	BSBW	DCL$DEALGOTO			;DEALLOCATE THE GOTO SYMBOL
	BRW	22$				;SIGNAL THE ERROR

;
; DOES IT MATCH THE ONE WE WERE LOOKING FOR?  IF SO, RESET RMS CONTEXT 
; TO REREAD THIS RECORD.
;
65$:	MOVL	PRC_L_SYMBOL(R11),R2		;GET TARGET OF GOTO
	MOVZBL	(R2)+,R1			;CREATE LABEL DESCRIPTOR
	CMPL	R4,R1				;DOES LENGTH MATCH?
	BNEQ	70$				;NO, FLUSH THIS RECORD
	CMPC3	R4,(R5),(R2)			;DOES THE STRING MATCH
	BNEQ	70$				;NO, FLUSH THIS RECORD
	BICW	#PRC_M_GOTO,PRC_W_FLAGS(R11)	;CLEAR GOTO IN PROGRESS FLAGS
	BSBW	DCL$DEALGOTO			;DEALLOCATE THE GOTO SYMBOL
	BRW	5$				;POSITION FILE TO GOTO LABEL

;
; FLUSH THE RECORD.
;
70$:	BSBB	FLUSH				;FLUSH THE RECORD
	BBC	#PRC_V_GOTO,PRC_W_FLAGS(R11),71$;BRANCH IF EOF
	BRW	40$				;GET THE NEXT RECORD
71$:	BRW	25$				;

	.SBTTL	FLUSH CURRENT RECORD AND ANY CONTINUATIONS
;+
; FLUSH - FLUSH CURRENT RECORD AND ANY CONTINUATIONS
;
; THIS ROUTINE IS CALLED TO FLUSH CURRENT RECORD AND ANY CONTINUATIONS.
;
; INPUTS:
;
;	R10 = ADDRESS OF WRK DATA STRUCTURE
;	R11 = ADDRESS OF PRC DATA STRUCTURE
;	
; OUTPUTS:
;
;	R0 = STATUS
;-

FLUSH:						;FLUSH THE INPUT
	CLRL	-(SP)				;USE STACK AS TEMP. FLAG
	CMPB	@WRK_L_CHARPTR(R10),#^A/$/	;IS FIRST CHAR. A '$' ?
	BNEQ	2$				;NO, TREAT LINE AS DATA.
	INCL	(SP)				;YES, TREAT AS A COMMAND LINE
;
; POINT TO FIRST CHARACTER IN RECORD AND INIT QUOTE FLAG.
;
2$:	MOVL	WRK_L_CHARPTR(R10),R1		;POINT TO FIRST CHARACTER
	DECL	R1				;BACK UP A CHAR
	MOVL	R1,R2				;SAVE UNDERFLOW CHAR PTR
	CLRL	R3				;INIT QUOTE FLAG

;
; SEARCH FOR EOL OR TRAILING COMMENT.
;
10$:	INCL	R1				;GET NEXT CHAR
	TSTB	(R1)				;EOL?
	BEQL	40$				;YES, THEN CHECK FOR "-"
	CMPB	#^A/"/,(R1)			;QUOTE?
	BNEQ	20$				;BRANCH IF NOT
	INCL	R3				;TOGGLE THE FLAG
	BRB	10$				;GET NEXT CHAR
20$:	BLBS	R3,10$				;BRANCH IF IN QUOTES
	CMPB	#^A/!/,(R1)			;COMMENT?
	BEQL	40$				;YES, THEN CHECK FOR "-"
	BRB	10$				;GET NEXT CHAR

;
; BACK UP OVER TRAILING BLANKS.
;
40$:	DECL	R1				;BACK UP A CHAR
	CMPL	R1,R2				;CHECK FOR START OF LINE
	BEQL	90$				;IF FOUND, THEN DONE
	CMPB	#^X20,(R1)			;SPACE?
	BEQL	40$				;YES, THEN BACK UP AGAIN
	CMPB	#^X09,(R1)			;TAB?
	BEQL	40$				;YES, THEN BACK UP AGAIN

;
; CHECK FOR CONTINUATION CHARACTER.
;
	CMPB	#^A/-/,(R1)			;CONTINUATION?
	BNEQ	90$				;NO, THEN DONE
	BISW	#PRC_M_IND,PRC_W_FLAGS(R11) 	;IGNORE @ SIGNS
	BLBC	(SP),90$			;IF DATA, THEN DONE
	BSBW	DCL$INPUT			;GET CONTINUATION LINE
	BICW	#PRC_M_IND,PRC_W_FLAGS(R11) 	;RESTORE @ SIGNS
	BBC	#PRC_V_GOTO,PRC_W_FLAGS(R11),90$;BRANCH IF EOF
	BRB	2$				;FLUSH IT TOO

90$:	ADDL	#4,SP				;REMOVE TEMP. FLAG FROM STACK
	STATUS	NORMAL				;SET NORMAL STATUS
	RSB					;RETURN

	.SBTTL	ALLOCATE A LABEL SYMBOL TABLE ENTRY
;+
; DCL$ALLOC_LABEL - ALLOCATE A LABEL SYMBOL TABLE ENTRY
;
; THIS ROUTINE IS CALLED TO ALLOCATE A LABEL SYMBOL TABLE ENTRY.
;
; INPUTS:
;
;	R1/R2 = LABEL DESCRIPTOR
;	R11 = ADDRESS OF PRC DATA STRUCTURE
;	
; OUTPUTS:
;
;	R0 = STATUS
;	R4/R5 = LABEL DESCRIPTOR
;	R6 = SYMBOL ADDRESS
;
; CTRL/Y'S ARE ASSUMED TO HAVE BEEN DISABLED.
;
;-
DCL$ALLOC_LABEL::				;
	MOVQ	R1,-(SP)			;SAVE R1/R2
	MOVAB	PRC_Q_LABEL(R11),R5		;SET ADDRESS OF TABLE LIST HEAD
	MOVQ	R1,R3				;SET LABEL NAME
	MOVL	PRC_L_INDINPRAB(R11),R0		;GET RAB ADDRESS
	MOVAB	RAB$W_RFA(R0),R2		;SET ADDRESS OF RFA
	MOVZBL	#6,R1				;SET LENGTH OF RFA
	MOVL	#SYM_K_LABEL,R0			;SET SYMBOL TYPE
	BSBW	DCL$ALLOCSYM			;CREATE THE LABEL ENTRY
	MOVL	R1,R6				;GET SYMBOL ADDRESS
	MOVQ	(SP)+,R4			;RESTORE R1/R2
	RSB					;

	.SBTTL	DEALLOCATE GOTO CONTROL BLOCK
;+
; DCL$DEALGOTO - DEALLOCATE GOTO CONTROL BLOCK
;
; THIS ROUTINE IS CALLED TO DEALLOCATE AN OUTSTANDING GOTO CONTROL
; BLOCK WHEN IT IS SATISFIED OR AN END OF FILE IS REACHED WITHOUT
; FINDING THE LABEL.
;
;-
DCL$DEALGOTO::				;
	MOVL	PRC_L_SYMBOL(R11),R0	; ADDRESS OF GOTO CONTROL BLOCK
	MOVZBL	(R0),R1			; GET LENGTH AND POINT AT START OF BLOCK
	INCL	R1			; INCLUDE LABEL LENGTH BYTE
	BSBW	DCL$DEADYNMEM		; DEALLOCATE THE BLOCK
	CLRL	PRC_L_SYMBOL(R11)	; CLEAR ADDRESS OF GOTO CONTROL BLOCK
	RSB				;

	.END
