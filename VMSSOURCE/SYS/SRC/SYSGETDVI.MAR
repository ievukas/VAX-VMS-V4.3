	.TITLE	SYSGETDVI - System Services to Get Device Information
	.IDENT	'V04-000'
 
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; AUTHOR: Peter H. Lipman,  CREATION DATE: 20-Oct-1981
;
; MODIFIED BY:
;
;	V03-022	CWH3022		CW Hobbs		25-Jul-1984
;		Change special items for shadow set information to call
;		loadable support routine in mount verification (sysloa).
;		This makes V4.n support of shadowing much simpler.
;
;	V03-021	LY0512		Larry Yetto		20-JUL-1984 13:01
;		Fix bug in MEDIA_NAME code
;
;	V03-020	LY0502		Larry Yetto		10-JUL-1984 10:12
;		Add support for the MEDIA_NAME and MEDIA_TYPE item codes
;
;	V03-019	TMK0001		Todd M. Katz		29-Apr-1984
;		Add support for full length ( i.e. - LNM$C_NAMLENGTH )
;		logical volume names. This support is accomplished through
;		the following changes:
;
;		1. Change the scratch storage area within the local stack 
;		   storage from LOG$C_NAMLENGTH to 4 bytes. This scratch area
;		   will now be used only to temporarily store values up to a
;		   longword in size.
;
;		2. Previously this scratch storage area had also been used to 
;		   temporarily store character strings. Now, whenever a string
;		   must temporarily be stored, a KRP is used to provide the
;		   storage space. The KRP is allocated from the lookaside list
;		   the first time temporary storage is required for a character 
;		   string. It remains allocated, and maybe utilized for 
;		   temporarily storing other character strings, for the 
;		   remainder of the current $GETDVI invocation at which time it
;		   is returned to the KRP lookaside list.
;
;	V03-018	RKS0018		RICK SPITZ		11-APR-1984
;		Enhance DVI_USE_DEVNAM to redirect references from a
;		physical terminal UCB to the associated logical UCB.
;
;	V03-017	LMP0221		L. Mark Pilant,		30-Mar-1984  16:35
;		Change UCB$L_OWNUIC to ORB$L_OWNER and UCB$W_VPROT to
;		ORB$W_PROT.
;
;	V03-016	MHB0115		Mark Bramhall		20-Mar-1984
;		Check for network device in SPC_TT_PHYDEVNAM.
;
;	V03-015	MHB0104		Mark Bramhall		 1-Mar-1984
;		Added SPC_TT_PHYDEVNAM for DVI$_TT_PHYDEVNAM.
;
;	V03-014	CWH3014		CW Hobbs		28-Feb-1984
;		Fix accvio when DVI$_VOLSETMEM item is directed at a non-mounted
;		device.  Add special routine to get DVI$_FREEBLOCKS for XQP
;		disks, and several new routines for dual-pathed devices and
;		shadow sets.
;
;	V03-013	HH0002		Hai Huang		01-Feb-1984
;		Add job-wide mount support.
;
;	V03-012	TCM0002		Trudy C. Matthews	04-Jan-1984
;		Document relationship between invocations of DVI_ITEM_CODE
;		and DVI$_xxx item codes defined by $DVIDEF.  Add warning
;		to DVI_ITEM_CODE if this relationship is not preserved.
;
;	V03-011	KFH0006		Ken Henderson		 9 Sep 1983
;		Add documentation about adding itemcodes.
;		Add SPC_DEVLOCKNAM, SPC_VOLSETMEM.
;
;	V03-010	KFH0005		Ken Henderson		30 Jul 1983
;		Removed debugging definitions
;
;	V03-009	TCM0001		Trudy C. Matthews	24-Jun-1983
;		Add SPC_ALLDEVNAM:
;
;	V03-008	DMW4040		DMWalp			31-May-1983
;		Intergate new logical name structures.
;
;	V03-007	KFH0004		Ken Henderson		18 May 1983
;		Changed SPC_FULLDEVNAM to new spec.
;		Added HEXSTR datatype to macro.
;
;	V03-006	KFH0003		Ken Henderson		29 Apr 1983
;		Added SPC_FULLDEVNAM:
;
;	V03-005	KFH0002		Ken Henderson		11 Mar 1983
;		Made .WARN for undefined item-codes more
;		specific.
;
;	V03-004	CWH1002		CW Hobbs		1-Mar-1983
;		Add special item routines for DVI$_PID and DVI$_ACPPID
;
;	V03-003	KFH0001		Ken Henderson		23 Feb 1983
;		Changed name of module to SYSGETDVI.
;		Added DVI_ITEM_CODE macro to replace ITEM
;		and SPECIAL macros. Moved tables and code
;		YF$$SYSGETDVI psect.
;
;	V03-002	PHL0103		Peter H. Lipman		24-Jul-1982
;		Fix return status in IOSB to be SS$_CONCEALED if device
;		was concealed.  It was always being returned as SS$_NORMAL
;		unless their was an error.
;
;	V03-001	KDM0002		Kathleen D. Morse	28-Jun-1982
;		Added $DEVDEF, $PCBDEF, $PRDEF, and $PSLDEF.  Fix comment.
;
;
;**

;		DEVO's GUIDE TO GETJPI/GETSYI/GETDVI
;		------------------------------------
;
;Overview
;--------
;
;These three system services are table-driven. The macro definition files
;that help define their tables are shared with DCL and the RTL. This results
;in new item-codes becoming useable with DCL's F$GETXXI lexical functions and
;the RTL's LIB$GETXXI routines automatically. Additionally, new SYSBOOT
;parameters become item-codes to the GETSYIs.
;
;The macro definition files are called JPITABLE.MAR, SYITABLE.MAR, and
;DVITABLE.MAR, and live in MASD$:<VMSLIB.SRC>. During a systembuild, they
;are inserted into the library SYS$LIBRARY:SYSBLDMLB.MLB. DCL and the RTL
;and SYS use this library to define their GETXXI tables. The system
;parameter file <SYS.SRC>SYSPARAM.MAR has also been conditionalized to be
;used to define GETSYI item-codes and is also inserted into SYSBLDMLB.MLB.
;
;
;NOTE:	SYSBLDMLB.MLB is a general macro library for holding macro
;	definitions that are shared between facilities, but will not
;	ship to the customer.
;
;
;When adding an item-code, at least two files need to be edited. One of the
;macro files listed above, as well as an SDL file that defines the 16-bit
;number which is the user-visible item-code. Also, if a SYSBOOT parameter is
;added, an SDL file needs to be updated to define the new GETSYI item-code.
;
;The GETDVI service actually uses only one table, but the GETSYI and GETJPI
;services use several. The JPITABLE file defines all the tables for GETJPI
;and the SYITABLE file defines all the tables for GETSYI. The different
;tables group the peices of data according to method of retrieval.
;
;In some cases, the peice of data to be returned by the service requires
;special processing to fetch, calculate, or format it before returning it.
;In these cases, the code of the system service needs to be enhanced.
;And if the data returned is a new format for DCL, the lexical function
;module of DCL may need to be enhanced as well. Possibly the RTL code may
;need enhancing as well.


;The Macros
;----------
;
;A two-level scheme exists for defining the item tables used by the three
;services and the other facilities. A commonly defined macro (called
;JPI_GENERATE_TABLE, SYI_GENERATE_TABLE, or DVI_GENERATE_TABLE) contains
;multiple calls to a lower-level macro (called JPI_ITEM_CODE, SYI_ITEM_CODE,
;or DVI_ITEM_CODE) which actually defines each element in the table.
;While the _GENERATE_TABLE macros are commonly defined, the _ITEM_CODE macros
;are individually defined according to the needs of facility. (For instance,
;the LEXICON module must store the name of the item as an ASCIC string - in
;order to match it with the string supplied in the F$GETXXI function call;
;the other facilities need not store the item name in text.)
;
;When an item-code must be added, an additional call to the _ITEM_CODE macro
;must be added to the appropriate _GENERATE_TABLE macro. In the case of GETJPI
;and GETDVI, the _GENERATE_TABLE macro is defined in the JPITABLE and DVITABLE
;modules.  For GETDVI, an item-code definition must also be added to $DVIDEF.
;BE SURE THAT THE ORDER OF THE ITEM CODE DEFINITIONS IN $DVIDEF IS THE SAME AS
;THE ORDER OF INVOCATIONS OF DVI_ITEM_CODE IN DVITABLE.  The item-code number
;generated by $DVIDEF will be used as an index into DVI_ITEM_TABLE to locate
;the appropriate information about that item.
;
;The SYI_GENERATE_TABLE macro is defined by the SYSPARAM module
;- all the calls to the PARAMETER and PQL macros are 'collected' into the
;SYI_GENERATE_TABLE macro. When used in that mode (when GETSYISW is defined),
;the SYI_ITEMTABLES macro also becomes part of the SYI_GENERATE_TABLE macro.
;SYI_ITEMTABLES is defined in the SYITABLE module and contains all the calls
;to the SYI_ITEM_CODE macro that are Not related to SYSBOOT parameters.
;When GETSYISW is defined in SYSPARAM, the PARAMETER macro does not allocate
;or store memory, but rather passes some of the arguments to it on through via
;a call to SYI_ITEM_CODE. That is how all the calls to PARAMETER become calls
;to SYI_ITEM_CODE.
;
;The following is the situation that exists when the symbol GETSYISW is defined.
;The non-SYSBOOT items are defined by the macro SYI_ITEMTABLES in SYITABLE.MAR.
;The SYSBOOT items are defined by each invokation of the PARAMETER macro in
;SYSPARAM.MAR. Note that each invokation of the PQL macro in SYSPARAM.MAR
;invokes the PARAMETER macro twice. When GETSYISW is defined, the PARAMETER
;macro merely passes its arguments through to a call to the SYI_ITEM_CODE
;macro. The SYI_ITEM_CODE macro is locally defined as needed by the facility.
;
;+---------------------------------------------------------------------+
;|                    SYI_GENERATE_TABLE                               |
;|   SYI_ITEMTABLES          |                                         |
;|                           | PARAMETER   |           PQL             |
;|                           |             | PARAMETER   | PARAMETER   |
;|             |             |             |             |             |
;|SYI_ITEM_CODE|SYI_ITEM_CODE|SYI_ITEM_CODE|SYI_ITEM_CODE|SYI_ITEM_CODE|
;+---------------------------------------------------------------------+
;\                          / \                                       /
; \                        /   \                                     /
;     FROM SYITABLE.MAR                  FROM SYSPARAM.MAR
;    (NON-SYSBOOT ITEMS)                  (SYSBOOT ITEMS)

	.SBTTL	DATA DECLARATIONS

;
; System Services to Get Device Information
;
;	$GETDEV and $GETCHN are obsolete and frozen starting with V3
;	$GETDVI replaces them and all new items are only available
;		via this system service.
;

;
; MACRO LIBRARY CALLS
;
 
	$AQBDEF				; Define AQB offsets
	$CCBDEF				; Define CCB offsets
	$CDDBDEF			; Define CDDB offsets
	$DCDEF				; Define adapter type codes
	$DDBDEF				; Define DDB offsets
	$DEVDEF				; Define device type codes
	$DIBDEF				; Define DIB offsets
	$DVIDEF				; Define Device/Volume Information constants
	$JIBDEF				; Define Job Information Block offsets
	$LKIDEF				; Define Get lock info codes
	$LNMSTRDEF			; Define logical name structure offsets
	$MTLDEF				; Define Mount List entry offsets
	$ORBDEF				; Define Object's Rights Block offsets
	$PCBDEF				; Define Process Control Block offsets
	$PRDEF				; Define Processor Register numbers
	$PSLDEF				; Define Program Status Longword fields
	$RVTDEF				; Define RVT offsets
	$SBDEF				; Define SB offsets
	$SSDEF				; Define system status values
	$TTDEF				; Define terminal DEVDEPEND bits
	$TT2DEF				; Define terminal DEVDEPND2 bits
	$TTYUCBDEF			; Define terminal UCB offsets
	$UCBDEF				; Define UCB offsets
	$VCBDEF				; Define VCB offsets
 
;
; LOCAL MACROS
;
; Generate device information control table - $GETDEV and $GETCHN only
;
 
	.MACRO	GENTAB OFFSET,LENGTH
	.BYTE	LENGTH
	.ENDM	GENTAB

;
; Generate field definitions for item value long word
;
	.MACRO	DVIBITS	NAME,SIZE
	DVI_V_'NAME' = DVI_BIT
	DVI_S_'NAME' = SIZE
	DVI_BIT = DVI_BIT + SIZE
	.ENDM	DVIBITS

;
; Generate the item-code table
;
	.MACRO	DVI_ITEM_CODE	NAME,-		; of the item-code
				SPECIAL,-	; flag
				SOURCE,-	; of the data
				DTYPE,-		; of returned value
				BITPOS,-	; of bitfield data
				OUTLEN,-	; of returned value
				STRUCT,-	; where the data lives
				DEVTYP		; flag

	.IF NOT_DEFINED DVI$_'NAME
		.WARN ; DVI$_'NAME IS NOT DEFINED IN STARDEFAE.SDL
	.IF_FALSE
		.IF NE	ITEM_CODE-DVI$_'NAME
			.WARN ; DEFINITION FOR ITEM CODE 'NAME IS OUT OF ORDER
		.ENDC
	.ENDC

	ITEM_CODE = ITEM_CODE + 2

	.IF IDENTICAL <SPECIAL><T>

	.ADDRESS	SPC_'NAME'

	.IF_FALSE	; IDENTICAL <SPECIAL><T>

	.IF DIFFERENT <SPECIAL><F>
	.WARN ; ERROR INVOKING DVI_ITEM_CODE FOR DVI$_'NAME
	.ENDC	; DIFFERENT <SPECIAL><F>

	XTYPE = DVI_C_VALUE
	.IIF IDENTICAL <DTYPE><HEXNUM>,	XTYPE = DVI_C_VALUE
	.IIF IDENTICAL <DTYPE><DECNUM>,	XTYPE = DVI_C_VALUE
	.IIF IDENTICAL <DTYPE><PRVMSK>,	XTYPE = DVI_C_VALUE
	.IIF IDENTICAL <DTYPE><PRTMSK>,	XTYPE = DVI_C_VALUE
	.IIF IDENTICAL <DTYPE><HEXSTR>,	XTYPE = DVI_C_VALUE
	.IIF IDENTICAL <DTYPE><PADSTR>,	XTYPE = DVI_C_VALUE
	.IIF IDENTICAL <DTYPE><CNTSTR>,	XTYPE = DVI_C_CSTRING
	.IIF IDENTICAL <DTYPE><STRDSC>,	XTYPE = DVI_C_VALUE
	.IIF IDENTICAL <DTYPE><BITVEC>,	XTYPE = DVI_C_VALUE
	.IIF IDENTICAL <DTYPE><BITVAL>,	XTYPE = DVI_C_BOOLEAN
	.IIF IDENTICAL <DTYPE><STDUIC>,	XTYPE = DVI_C_VALUE
	.IIF IDENTICAL <DTYPE><STDTIM>,	XTYPE = DVI_C_VALUE
	.IIF IDENTICAL <DTYPE><ACPTYP>,	XTYPE = DVI_C_VALUE

	.IF IDENTICAL <STRUCT><RVT>
	OFFVAL	= DVI_C_'SOURCE'
	.IF_FALSE
	OFFVAL	= 'STRUCT'$'SOURCE'
	.ENDC

	.LONG	<OFFVAL@DVI_V_OFFSET> ! -
		<'OUTLEN'@DVI_V_BYTCNT> ! -
		<DVI_C_'STRUCT'@DVI_V_STRUCT> ! -
		<XTYPE@DVI_V_DATATYPE> ! -
		<DVI_C_'DEVTYP'@DVI_V_DEVTYPE> ! -
		<'BITPOS'@DVI_V_POSIT>

	.ENDC	; IF_FALSE IDENTICAL <SPECIAL><T>

	.ENDM	DVI_ITEM_CODE

;
; LOCAL SYMBOLS
;
; $GETDEV, $GETCHN Argument List Offset Definitions
;
 
	CHAN_DEVNAM=4			; I/O channel number
					; Device name descriptor
	PRILEN=8			; Address to store length of primary string
	PRIBUF=12			; Address of primary buffer descriptor
	SCDLEN=16			; Address to store length of secondary string
	SCDBUF=20			; Address of secondary buffer descriptor
;
; Bit Field Definititions for Item Value long word
;
	DVI_BIT = 0
	DVIBITS	OFFSET,10		; Offset in specified data structure
	DVIBITS	BYTCNT,9		; Size of item in bytes
	DVIBITS	STRUCT,3		; Structure (UCB, VCB)
	DVIBITS	DATATYPE,3		; Type of data item
	DVIBITS	DEVTYPE,1		; Device to which item is specific
	DVIBITS POSIT,5			; Bit position of BITVAL dtype
	DVIBITS SPCLFLG,1		; THIS BIT MUST BE BIT 31!!!
;
; Datatype symbols for $GETDVI
;
	DVI_C_VALUE = 0			; Binary Value
	DVI_C_CSTRING = 1		; Counted String
	DVI_C_BOOLEAN = 2		; Bit value
;
; Mount type codes for SPC_DEVLOCKNAM
;
	DVI_K_PRIVATE = 1
	DVI_K_SHAREABLE = 2

;
; Structure code symbols for $GETDVI
;
	DVI_C_UCB = 0			; Unit Control Block
	DVI_C_DDB = 1			; Device Data Block
	DVI_C_VCB = 2			; Volume Control Block
	DVI_C_RVT = 3			; Relative Volume Table
	DVI_C_AQB = 4			; ACP Queue Header Block
	DVI_C_ORB = 5			; Object's Rights Block
;
; Device type codes for $GETDVI
;
	DVI_C_ANY = 0			; Any device
	DVI_C_DISK = 1			; Disk only
;
; Relative Volume Table Item Sub Codes for $GETDVI - in OFFSET field
;
	DVI_C_VOLCOUNT = 0		; Count of volumes in volume set
	DVI_C_ROOTDEVNAM = 1		; Device name for first volume in vol set
	DVI_C_NEXTDEVNAM = 2		; Device name for next volume in  vol set
;
; Local Storage Offsets
;
	$OFFSET	0,NEGATIVE,<-
	<PRIMARY_UCB,16>, -		; Primary UCB/VCB, Secondary UCB/VCB
	<CURRENT_UCB,8>, -		; Current UCB/VCB
	RETLEN_ADR,-			; Address to return length
	SCRATCH,-			; Scratch storage - 4 bytes ONLY
	KRP,-				; Address of allocated KRP
	<SCRATCH_SIZE,0>, -		; Size of local storage
	STATUS, -			; Returned Success Status
	SAVED_ASTADR, -			; Saved ASTADR parameter
	IOUNLOCK, -			; Need to unlock I/O data base if LBS
	>
	RETLEN = STATUS+2		; Return length $GETDEV, $GETCHN
	PRIMARY_VCB = PRIMARY_UCB+4	; Primary VCB address
	SECONDARY_UCB = PRIMARY_UCB+8	; Seconday UCB address
	SECONDARY_VCB = PRIMARY_UCB+12	; Secondary VCB address
	CURRENT_VCB = CURRENT_UCB+4	; Current VCB address
;
; The following ASSUMES guarantee the consistency of the ACP type
; definition in $AQBDEF and the user visible constants in $DVIDEF
;
	ASSUME	AQB$K_F11V1 EQ DVI$C_ACP_F11V1 ; FILES-11 STRUCTURE LEVEL 1
	ASSUME	AQB$K_F11V2 EQ DVI$C_ACP_F11V2 ; FILES-11 STRUCTURE LEVEL 2
	ASSUME	AQB$K_MTA EQ DVI$C_ACP_MTA ; MAGTAPE
	ASSUME	AQB$K_NET EQ DVI$C_ACP_NET ; NETWORKS
	ASSUME	AQB$K_REM EQ DVI$C_ACP_REM ; REMOTE I/O
	ASSUME	AQB$K_JNL EQ DVI$C_ACP_JNL ; JOURNAL
 
;
; LOCAL DATA
;
; Device Information Control Table - $GETDEV, $GETCHN
;
 
	.PSECT	YF$$SYSGETDVI
DEVTAB:					;
	GENTAB	L_DEVCHAR,4		; Device characteristics
	GENTAB	B_DEVCLASS,1		; DEVCLASS - Device Class
	GENTAB	B_DEVTYPE,1		; DEVTYPE - Device Type
	GENTAB	W_DEVBUFSIZ,2		; DEVBUFSIZ - buffer size
	GENTAB	L_DEVDEPEND,4		; DEVDEPEND - device dependent info
	GENTAB	W_UNIT,<2+2>		; Device unit number
					; DIB$W_DEVNAMOFF <-- 0
	GENTAB	L_PID,4			; Device owner process identification
	GENTAB	L_OWNUIC,4		; Device owner user identification code
	GENTAB	W_VPROT,2		; Device protection mask
	GENTAB	W_ERRCNT,2		; Device error count
	GENTAB	L_OPCNT,<4+2>		; Device operations complete count
					; DIB$W_VOLNAMOFF <-- 0
	GENTAB	W_RECORDSZ,2		; Blocked Record Size
	.BYTE	-DIB$L_MAXBLOCK+DIB$T_DEVNAME ; Skip over string area
	GENTAB	L_MAXBLOCK,4		; Disk size in blocks
	.BYTE	0			; End of table
;
;****************************************
;
;	GENERATE THE ITEM-CODE TABLE
;
;****************************************
;
DVI_ITEM_TABLE:

	; Index 0 is not used by EXE$GETDVI
	;
	.LONG	0

	ITEM_CODE = 2

	DVI_GENERATE_TABLE

	MAX_ITEM_CODE = <<.-DVI_ITEM_TABLE>/2>-1

	.SBTTL	$GETCHN - Get Channel Information
;+
; EXE$GETCHN - Get channel information
;
; This service provides the capability to retrieve information about a
; device that is assigned to a channel and its associated device if any.
;
; INPUTS:
;
;	CHAN(AP) = I/O channel number.
;	PRILEN(AP) = Address to store length of primary device information.
;	PRIBUF(AP) = Address of primary buffer descriptor.
;	SCDLEN(AP) = Address to store length of secondary device information.
;	SCDBUF(AP) = Address of secondary buffer descriptor.
;
;	R4 = Current process PCB address.
;
; OUTPUTS:
;
;	R0 low bit clear indicates failure to retrieve device information.
;
;		R0 = SS$_ACCVIO - primary or secondary buffer descriptor
;			cannot be read by calling access mode, or primary
;			buffer, primary buffer length, secondary buffer, or
;			secondary buffer length cannot be written by calling
;			access mode.
;
;		R0 = SS$_IVCHAN - invalid channel number specified.
;
;		R0 = SS$_NOPRIV - specified channel is not assigned to a
;			device or the calling access mode does not have
;			privilege to access the channel.
;
;	R0 low bit set indicates successful completion.
;
;		R0 = SS$_BUFFEROVF - normal completion, all characteristic
;			information did not fit in specified buffer(s).
;
;		R0 = SS$_NORMAL - normal completion, all characteristic
;			information transfered.
;-
 
	.PSECT	Y$EXEPAGED

	.ENTRY	EXE$GETCHN,^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	MOVAB	W^DVI_USE_CHAN,R1	; Use channel parameter
	BRW	EXE_GETDEV		; Join GETDEV code

	.SBTTL	$GETDEV - Get Device Information
;+
; EXE$GETDEV - Get device information
;
; This service provides the capability to retrieve information about a
; device and its associated device if any.
;
; INPUTS:
;
;	DEVNAM(AP) = Address of device name descriptor.
;	PRILEN(AP) = Address to store length of primary device information.
;	PRIBUF(AP) = Address of primary buffer descriptor.
;	SCDLEN(AP) = Address to store length of secondary device information.
;	SCDBUF(AP) = Address of secondary buffer descriptor.
;
;	R4 = Current process PCB address.
;
; OUTPUTS:
;
;	R0 low bit clear indicates failure to retrieve device information.
;
;		R0 = SS$_ACCVIO - Device name string, device name string
;			descriptor, primary buffer descriptor, or secondary
;			buffer descriptor cannot be read by calling access
;			mode, or primary buffer, primary buffer length,
;			secondary buffer, or secondary buffer length cannot
;			be written by calling access mode.
;
;		R0 = SS$_IVDEVNAM - Device name string contains invalid
;			characters, or no device device name string descriptor
;			specified.
;
;		R0 = SS$_IVLOGNAM - Zero or greater than maximum length device
;			name string specified.
;
;		R0 = SS$_NONLOCAL - Device exists on a remote system.
;
;		R0 = SS$_NOSUCHDEV - Specified device does not exist on host
;			system.
;
;	R0 low bit set indicates successful completion.
;
;		R0 = SS$_BUFFEROVF - Normal completion, all characteristic
;			information did not fit in specified buffer(s).
;
;		R0 = SS$_NORMAL - Normal completion, all characteristic
;			information transfered.
;-
 
	.ENTRY	EXE$GETDEV,^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	MOVAB	W^DVI_USE_DEVNAM,R1	; Use device name descriptor
	BRW	EXE_GETDEV

	.PSECT	YF$$SYSGETDVI
;
; R1 = address of USE_CHAN or USE_DEVNAM entry point
;
	.ENABLE	LSB

EXE_GETDEV:
	MOVAL	SCRATCH_SIZE-4(SP),SP	; Reserve scratch storage
					; include uninitialized return status
	CLRQ	-(SP)			; Init SAVED_ASTADR and IOUNLOCK flag
;
; The above stack locations are all referenced by offsets from FP
;
	MOVL	CHAN_DEVNAM(AP),R0	; Get CHAN or DEVNAM parameter
	JSB	(R1)			; Set up UCB's to be used
	BLBC	R0,40$			; Branch if error
	MOVL	#SS$_NORMAL,STATUS(FP)	; Init normal success status
					; Overwrite possible SS$_CONCEALED
	CLRL	R9			; Primary device items
	MOVQ	PRILEN(AP),R7		; Get primary buffer parameters
	BSBB	FILBUF			; Fill primary buffer
	BLBC	R0,40$			; Branch if error
	MOVL	#1,R9			; Secondary device items
	MOVQ	SCDLEN(AP),R7		; Get secondary buffer parameters
	BSBB	FILBUF			; Fill secondary buffer
	BLBC	R0,40$			; Branch if error
30$:	MOVZWL	STATUS(FP),R0		; Get normal or overflow status to return
40$:	BLBS	IOUNLOCK(FP),50$	; Branch if must unlock I/O data base
	RET
50$:	JMP	G^IOC$UNLOCK		; Unlock I/O database and return

	.DSABL	LSB
 
;
; Subroutine to fill characteristic buffer
;
; INPUTS:
;
;	R7 = Address to return length of data stored
;	R8 = Descriptor of DIB buffer
;	R9 = 0 if getting primary characteristics
;	   = 1 if getting secondary characteristics
;
; OUTPUTS:
;
;	R0 = Status
;	R1 through R11 altered
;
ACCVIO_1:
	BRW	ACCVIO
FILBUF:	TSTL	R8			; Any buffer specified?
	BNEQ	5$			; Branch if yes
	BRW	160$			; No, nothing to do
5$:	MOVQ	PRIMARY_UCB(FP)[R9],CURRENT_UCB(FP) ; Set current UCB/VCB address
	MOVL	R7,RETLEN_ADR(FP)	; Save address for return length
	IFNORD	#8,(R8),ACCVIO_1	; ACCVIO if cannot read out buf decriptor
	MOVL	4(R8),R7		; Get the address
	MOVZWL	(R8),R6			; and the size of the buffer
	ASSUME  DIB$K_LENGTH LE 512
	CMPW	R6,#DIB$K_LENGTH	; If buffer is larger than needed
	BGEQU	20$			; then use the maximum size for probe
	MOVW	#SS$_BUFFEROVF,STATUS(FP) ; Record buffer overflow status
	BRB	30$
20$:	MOVZBL	#DIB$K_LENGTH,R6	; Actual size of data to be returned
30$:	MOVW	R6,RETLEN(FP)		; Remember how much data will be returned
	IFNOWRT	R6,(R7),ACCVIO		; Can entire buffer be written?
	MOVAL	W^DEVTAB,R11		; Address of item lengths
	CLRL	R8			; No item return length
	MOVQ	R6,-(SP)		; Save DIB descriptor
	PUSHL	R6			; Scratch copy of length
40$:	CVTBL	(R11)+,R10		; Length of buffer for next item
	BGTR	50$			; Branch if item to move
	BEQL	90$			; Branch if end of table
	MNEGL	R10,R10			; Skip over section of DIB
	BRB	70$
50$:	ADDL	#2,R9			; Next item code
	CMPL	R10,(SP)		; Enough room for this item?
	BLEQ	60$			; Branch if yes
	MOVL	(SP),R10		; No, use what space is left
	BLEQ	90$			; All done if no space left
60$:	BSBW	DVI_DO_ITEM		; Put the next item in the DIB
70$:	ADDL	R10,R7			; Next free location in DIB
	SUBL	R10,(SP)		; Adjust space left in DIB
	BGTR	40$			; Branch if room for another item
;
; The DIB is now filled in except for the device controller name string
; and the volume name string and their respective offset locations.  
; DIB$W_DEVNAMOFF and DIB$W_VOLNAMOFF are currently 0.  The string area
; is deliberately NOT backgrounded so that no data is written except that
; which is explicitly returned.
;
90$:	POPR	#^M<R5,R6,R7>		; Clean off scratch cell,
					; recover DIB descriptor
	SUBW	#DIB$T_DEVNAME,R6	; Room for CTLNAM and VOLNAM string
	BLEQ	150$			; Branch if no room for strings
	MOVAL	DIB$T_DEVNAME(R7),R3	; Starting adr in DIB for strings
	MOVL	CURRENT_UCB(FP),R5	; Address of UCB
	ADDL3	#DDB$T_NAME,UCB$L_DDB(R5),R5 ; Address of ASCIC controller name
	MOVZBL	(R5)+,R4		; Size in R4, adr in R5
	BEQL	110$			; Branch if controller name null
	MOVAL	DIB$W_DEVNAMOFF(R7),R8	; Address to store offset to string
	BSBB	MOVE_NAME		; Move the name, set up the offset
110$:	MOVL	CURRENT_VCB(FP),R5	; Address of VCB
	BEQL	150$			; Branch if volume not mounted
	MOVAL	VCB$T_VOLNAME(R5),R5	; Adr of 12 byte blank filled volume name
	MOVL	#12,R4			; Size of name string
	MOVAL	DIB$W_VOLNAMOFF(R7),R8	; Address to store offset to string
	BSBB	MOVE_NAME		; Move the name, set up the offset
;
; DIB is now totally filled in, return length to caller if requested
;
150$:	MOVL	RETLEN_ADR(FP),R0	; Address to return DIB length
	BEQL	160$			; Branch if none specified
	IFNOWRT	#2,(R0),ACCVIO		; Branch if length cannot be written
	MOVW	RETLEN(FP),(R0)		; Return the DIB length
160$:	MOVZWL	#SS$_NORMAL,R0		; Set successful completion
	RSB
ACCVIO:
	MOVZWL	#SS$_ACCVIO,R0		; Access violation
	RSB
;
; Move name string and fill in DIB offset to it
;
; INPUTS:
;
;	R3 = Address to store data
;	R4 = Byte count to store
;	R5 = Source string to store
;	R6 = Count of bytes remaining in output buffer
;	R7 = Base address of DIB
;	R8 = Address to store offset to string
;
; OUTPUTS:
;
;	R3 = Updated address to store next string
;	R6 = Updated space remaining to store next string
;	R0 through R5 altered
;	Other registers preserved
;
MOVE_NAME:
	DECL	R6			; Room for byte count for string
	BLSS	20$			; Branch if not, don't store offset
	SUBL3	R7,R3,R0		; Offset to string
	MOVW	R0,(R8)			; Store offset in DIB
	MOVB	R4,(R3)+		; Store count for ASCIC string
	CMPL	R4,R6			; Enough room for rest of string?
	BLEQ	10$			; Branch if yes
	MOVL	R6,R4			; No, use what is left
10$:	SUBL	R4,R6			; Keep track of space remaining
	MOVC3	R4,(R5),(R3)		; Store the string
20$:	RSB

	.SBTTL	$GETDVI - Get Device Information
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This service allows a process to get information about a device
;	it currently has a channel assigned to, or one it explicitly names.
;	
; CALLING SEQUENCE:
;
;	CALLS/CALLG
;
; INPUTS:
;
;	EFN(AP)	   = number of the event flag to set when all of the requested
;		     data is valid. 
;	CHAN(AP)   = channel to which desired device is assigned or 0
;		     if specifying device by name.
;	DEVNAM(AP) = address of a string descriptor for the device name
;		     or logical device name desired.  This is only used
;		     if the channel parameter is 0.
;	ITMLST(AP) = address of a list of item descriptors of the form:
;
;		+-----------------------------+
;		!  ITEM CODE   !  BUF. LENGTH !
;		+-----------------------------+
;		!      BUFFER ADDRESS         !
;		+-----------------------------+
;		!  ADDRESS TO RETURN LENGTH   !
;		+-----------------------------+
;
;	IOSB(AP)   = address of a quadword I/O status block to receive final
;		     status
;	ASTADR(AP) = address of an AST routine to be called when all of the
;		     requested data has been supplied.
;	ASTPRM(AP) = 32 bit ast parameter
;	NULARG(AP) = Reserved argument - address of a buffer descriptor
;		     for wild device context.
;
;	R4 = Current process PCB address
;
; IMPLICIT INPUTS:
;
;	none
;
; OUTPUTS:
;
;	none
;
; IMPLICIT OUTPUTS:
;
;	none
;
; ROUTINE VALUE:
;
;	R0 low bit clear indicates failure to retrieve device information
;
;		R0 = SS$_ACCVIO - Device name string descriptor, device
;			name string, or ITMLST cannot be read by the
;			calling access mode.  Item buffer or return
;			length word cannot be written by the calling
;			access mode.
;
;		R0 = SS$_IVCHAN - Invalid channel number specified
;
;		R0 = SS$_IVDEVNAM - Device name string contains invalid
;			characters, or no device name string was
;			specified and no channel number was specified.
;
;		R0 = SS$_IVLOGNAM - Zero or greater than maximum length
;			device name string specified.
;
;		R0 = SS$_NONLOCAL - Device exists on a remote system
;
;		R0 = SS$_NOSUCHDEV - Specified device does not exist on
;			host system
;
;		R0 = SS$_BADPARAM - An invalid item identifier was specified
;
;		R0 = SS$_EXASTLM - An AST was requested and the AST quota
;			was exceeded.
;
;	R0 low bit set indicates successful completion.
;
;		R0 = SS$_NORMAL - Normal completion
;
; SIDE EFFECTS:
;
;	none
;--

;
; Equated Symbols:
;
;	Argument List Offsets
;

	EFN = 4				; Event flag number argument
	CHAN = 8			; Channel assigned to device or 0
	DEVNAM = 12			; Address of device name string descriptor
	ITMLST = 16			; Address of item identifiers
	IOSB = 20			; I/O status block address
	ASTADR = 24			; AST routine address
	ASTPRM = 28			; AST parameter
	NULARG = 32			; Reserved argument - wild context buf dsc


	.PSECT	Y$EXEPAGED

	.ENTRY	EXE$GETDVI,^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	BRW	EXE_GETDVI

	.PSECT	YF$$SYSGETDVI

	.ENABL	LSB

EXE_GETDVI:
	MOVAL	SCRATCH_SIZE(SP),SP	; Allocate local storage
	CLRL	KRP(FP)			; Initially no KRP is allocated
	PUSHL	#SS$_NORMAL		; Set presumed normal success status
	CLRQ	-(SP)			; Zero SAVED_ASTADR and IOUNLOCK
;
; The above stack locations are all referenced by offsets from FP
;
	MOVZBL	EFN(AP),R3		; Get event flag number
	JSB	G^SCH$CLREF		; Clear this event flag
	BLBC	R0,DVI_ERROR		; If error, exit with error status
	MOVL	IOSB(AP),R1		; Get IOSB address if specified
	BEQL	10$			; Branch in none specified
	IFNOWRT	#8,(R1),DVI_ACCVIO	; If not writable by caller then ACCVIO
	CLRQ	(R1)			; Clear the IOSB
10$:	MOVL	ASTADR(AP),SAVED_ASTADR(FP) ; Save ASTADR parameter
	BEQL	20$			; Branch if none specified
	TSTW	PCB$W_ASTCNT(R4)	; If AST limit is exceeded
	BLEQ	DVI_EXASTLM		; then indicate error
;
; See if Channel parmeter was specified
;
20$:	MOVZWL	CHAN(AP),R0		; Fetch channel parameter if specified
	BEQL	30$			; Branch if not specified
	BSBW	DVI_USE_CHAN		; Get UCB address from channel
	BLBS	R0,40$			; Branch if no error
DVI_ERROR:
	BRB	DVI_ERROR_1
DVI_ACCVIO:
	MOVL	S^#SS$_ACCVIO,R0	; Access violation
	BRB	DVI_ERROR
DVI_EXASTLM:
	MOVZWL	#SS$_EXASTLM,R0		; Exceeded ASTLM quota
	BRB	DVI_ERROR
DVI_BADPARAM:
	MOVZWL	#SS$_BADPARAM,R0	; Bad parameter
	BRB	DVI_ERROR
;
; Use Device Name String parameter to locate desired device
;
30$:	MOVL	DEVNAM(AP),R0		; Get the device name descriptor
	BSBW	DVI_USE_DEVNAM		; Get UCB using device name
	BLBC	R0,DVI_ERROR		; Branch if error
;
; I/O data base locked for reading
;
40$:	MOVL	ITMLST(AP),R11		; Address of list of items
	IFNORD	#4,(R11),DVI_ACCVIO	; Check first long word readable
50$:	MOVZWL	2(R11),R9		; Item code for next item
	BEQL	DVI_COMPLETE		; Done if zero, take normal exit
	CMPW	R9,#MAX_ITEM_CODE	; Valid item code?
	BGTRU	DVI_BADPARAM		; Branch if not
	CMPL	R9,#1			; 0 and 1 are not used
	BLEQ	DVI_BADPARAM		; Branch if bad item code
	MOVAQ	(R11)+,R1		; R1 = R11 = Adr of item buf descriptor
					; R11 = R11 + 8
	JSB	G^EXE$PROBEW_DSC	; See if caller can read buf dsc
					; and write the buffer it describes
	BLBC	R0,DVI_ERROR		; Branch if not
	MOVL	R2,R7			; Save item buffer address
	MOVZWL	R1,R10			; and its size
	CMPL	R10,#4			; Item buffer at least 4 bytes?
	BLSS	DVI_BADPARAM		; Branch if not
	IFNORD	#8,(R11),DVI_ACCVIO	; Check access to rest of this item
					; and first long word of the next
	MOVL	(R11)+,R8		; R8 = Address to return length
	BEQL	60$			; Branch if return length not requested
	IFNOWRT	#2,(R8),DVI_ACCVIO	; Make sure caller can write this
60$:	EXTZV	#0,#1,R9,R0		; Get primary/secondary flag
	MOVQ	PRIMARY_UCB(FP)[R0],CURRENT_UCB(FP) ; Set current UCB/VCB
	BSBW	DVI_DO_ITEM		; Process this item
	BRB	50$			; Get next item
;
; R0 = error status
;
DVI_ERROR_1:
	MOVW	R0,STATUS(FP)		; Save error status
;
; Normal completion, saved status already set
;
DVI_COMPLETE:
	MOVL	@#CTL$GL_PCB,R4		; Get PCB address
	BLBC	IOUNLOCK(FP),70$	; Branch if no read lock to release
	JSB	G^SCH$IOUNLOCK		; Unlock I/O data base
	SETIPL	#0			; Allow all interrupts
70$:	MOVL	PCB$L_PID(R4),R1	; Get process's PID
	CLRL	R2			; Set null priority increment
	MOVL	EFN(AP),R3		; Get event flag number to set
	JSB	G^SCH$POSTEF		; Set the event flag
	MOVL	IOSB(AP),R1		; Get address of IOSB
	BEQL	80$			; Branch if none
	IFNOWRT	#8,(R1),80$		; Check if writable
	MOVW	STATUS(FP),(R1)		; Store completion status
80$:	MOVL	SAVED_ASTADR(FP),R5	; Get address of AST routine
	BEQL	90$			; Branch if none specified
	MOVPSL	R4			; Get PSL
	EXTZV	#PSL$V_PRVMOD,#PSL$S_PRVMOD,R4,R4 ; Extract previous mode
	$DCLAST_S (R5),ASTPRM(AP),R4	; Queue the completion AST
90$:	MOVZWL	STATUS(FP),R0		; Return saved status

	MOVL	KRP(FP),R7		; Retrieve address of allocated KRP
	BEQL	100$			; Immediately return if no KRP allocated
	MOVAB	G^CTL$GL_KRPFL,R6	; Else retrieve address of KRP listhead
	INSQUE	(R7),@4(R6)		; and deallocate KRP to lookaside list
100$:	RET				; Exit system service
	.DSABL	LSB

	.SBTTL	DVI_DO_ITEM - Validate and move desired item

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	Routine to validate item identifier and return the desired
;	information to the caller's buffer.
;
; CALLING SEQUENCE:
;
;	JSB/BSB
;
; INPUTS:
;
;	R7  = Address of buffer to return item - already probed
;	R8  = Address of buffer to return length - already probed
;	      0 if not returning length
;	R9  = Item code
;	R10 = Size of buffer for item
;
; IMPLICIT INPUTS:
;
;	CURRENT_UCP(FP)   - Address of the UCB
;	CURRENT_VCB(FP)   - Address of the VCB
;	SCRATCH(FP)	  - 4 bytes of scratch storage
;	KRP(FP)		  - Address of allocated KRP, if any
;
; OUTPUTS:
;
;	none
;
; IMPLICIT OUTPUTS:
;
;	KRP(FP)		  - Address of KRP if one is allocated
;
; ROUTINE VALUE:
;
;	none
;
; SIDE EFFECTS:
;
;	none
;--

DVI_DO_ITEM:
	MOVL	CURRENT_UCB(FP),R6	; Get current UCB address
	ASHL	#-1,R9,R1		; Item index
	MOVL	W^DVI_ITEM_TABLE[R1],R0	; Fetch associated item value
	BGEQ	20$			; Branch if not a special item
	JMP	(R0)			; Handle special items
20$:	BBC	#DVI_V_DEVTYPE,R0,40$	; Branch if no specific device type
	CMPB	UCB$B_DEVCLASS(R6),#DC$_DISK ; Disk only item, is it a disk?
	BEQL	40$			; Branch if not, null item
	BRW	EXE$DVI_NULL_ITEM
40$:	EXTZV	#DVI_V_STRUCT,#DVI_S_STRUCT,R0,R1 ; Get structure code
	CASE	R1,<-
		DVI_UCB,-		; UCB
		DVI_DDB,-		; DDB
		DVI_VCB_RVT_AQB,-	; VCB
		DVI_VCB_RVT_AQB,-	; RVT
		DVI_VCB_RVT_AQB,-	; AQB
		DVI_ORB -		; ORB
	>
;
; Fall through for VCB, RVT, or AQB
;
DVI_VCB_RVT_AQB:
	MOVL	CURRENT_VCB(FP),R5	; Get VCB address if any
	BNEQ	45$			; Branch if none
	BRW	EXE$DVI_NULL_ITEM

45$:	ASSUME	DVI_C_RVT EQ DVI_C_VCB+1
	ASSUME	DVI_C_AQB EQ DVI_C_VCB+2
	SUBL	#DVI_C_RVT,R1		; -1 = VCB, 0 = RVT, 1 = AQB
	BLSS	DVI_STRUCT		; Branch if VCB
	BGTR	DVI_AQB			; Branch if AQB
;
; Get Relative Volume Table Address if any
;
	BSBW	DVI_GET_RVT		; Get relative volume table adr
	BEQL	DVI_NO_RVT		; Branch if not a volume set
	MOVZBL	RVT$B_NVOLS(R3),R4	; Number of volumes in volume set
	BRB	DVI_RVT
DVI_NO_RVT:
	MOVL	#1,R2			; This is volume 1 of single volume set
	MOVL	#1,R4			; This is a single volume set
DVI_RVT:
	EXTZV	#DVI_V_OFFSET,#DVI_S_OFFSET,R0,R1 ; Offset is RVT item
;
; R2 = volume number for this volume, 1 if not a volume set
; R3 = RVT address or 0 if not a volume set
; R4 = volume count or 1 if not a volume set
;
	CASE	R1,< -
		RVT_VOLCNT, - 		; VOLCNT - Number of volumes in the vol set
		RVT_ROOTDEVNAM, - 	; ROOTDEVNAM - Device name for root vol in set
		RVT_NEXTDEVNAM -	; NEXTDEVNAM - Next device name in vol set
		>
;
; Get ACP queue header block address - AQB
;
DVI_AQB:
	MOVL	VCB$L_AQB(R5),R5	; Get AQB address
	BLSS	DVI_STRUCT		; Branch if system space address
	BRB	EXE$DVI_NULL_ITEM	; No AQB, no item data to return
DVI_ORB:
	MOVL	UCB$L_ORB(R6),R5	; Get ORB address
	BRB	DVI_STRUCT
DVI_DDB:
	MOVL	UCB$L_DDB(R6),R5	; Get DDB address
	BRB	DVI_STRUCT
DVI_UCB:
	MOVL	R6,R5			; Get UCB address
;
; R5 = Address of structure containing desired field
;
DVI_STRUCT:
	EXTZV	#DVI_V_OFFSET,#DVI_S_OFFSET,R0,R1 ; Stucture offset
	ADDL	R1,R5			; Source address of item to move
	EXTZV	#DVI_V_DATATYPE,#DVI_S_DATATYPE,R0,R1 ; Data type
	CASE	R1,<-
		EXE$DVI_VALUE, -	; VALUE - move specified bytcnt
		EXE$DVI_CSTRING, -	; CSTRING - move the ascic string
		DVI_BOOLEAN -		; BOOLEAN - test the bit
	>
	BRB	EXE$DVI_NULL_ITEM	; Out of range DTYPE
;
; Boolean data type
;
DVI_BOOLEAN:
	EXTZV	#DVI_V_POSIT,#DVI_S_POSIT,R0,R1 ; Bit position
	EXTZV	R1,#1,(R5),SCRATCH(FP)	; Get the bit and save it
	MOVAL	SCRATCH(FP),R5		; Point to the saved bit
	BRB	EXE$DVI_VALUE
;
; Counted string data type
;
EXE$DVI_CSTRING::
	MOVZBL	(R5)+,R4		; Get size of string, advance adr
	BRB	EXE$DVI_MOVE_ITEM
;
; Null item to return to user
;
EXE$DVI_NULL_ITEM::
	CLRL	R0			; Set size field to 0
EXE$DVI_VALUE::
	EXTZV	#DVI_V_BYTCNT,#DVI_S_BYTCNT,R0,R4 ; Size of item to move
;
; R4  = size of item to move in bytes
; R5  = source address to move from
; R7  = Destination address - already probed
; R8  = Address to return length or 0 - already probed
; R10 = Size of return buffer for item, zero fill this buffer
;
EXE$DVI_MOVE_ITEM::
	CMPL	R10,R4			; If user buffer is too small
	BGEQ	10$
	MOVL	R10,R4			; Move as much as will fit
10$:	TSTL	R8			; Return length requested?
	BEQL	20$			; Branch if not
	MOVW	R4,(R8)			; Set size of data returned
20$:	MOVC5	R4,(R5),#0,R10,(R7)	; Store item zero filled
	RSB

	.SBTTL	Special Items
;
; CONCEALED - return boolean indicating whether device is concealed
;
SPC_CONCEALED:
	CLRL	SCRATCH(FP)		; Will hold bit to indicate concealed
	CMPW	#SS$_CONCEALED,STATUS(FP) ; Is it actually concealed?
	BNEQ	15$			; NEQ means answer is false
	INCL	SCRATCH(FP)		; Set answer to true
15$:	MOVL	#1,R4			; Set length of data to move
	MOVAL	SCRATCH(FP),R5		; Point to data
	BRB	EXE$DVI_MOVE_ITEM
;
; VOLNUMBER - return relative volume number
;
SPC_VOLNUMBER:
	MOVL	CURRENT_VCB(FP),R5	; If not mounted,
	BEQL	EXE$DVI_NULL_ITEM	; Then return zero
	MOVZWL	VCB$W_RVN(R5),R4	; Fetch RVN field
	BNEQ	EXE$DVI_VALUE_IN_R4	; Non-zero if in a vol set
	INCL	R4			; It should really be vol 1
;
; ***** Fall through to EXE$DVI_VALUE_IN_R4
;
; RVT items - VOLCNT, ROOTDEVNAM, NXTDEVNAM
;
; R4 = Number of volumes in volume set, 1 if not a volume set
;
RVT_VOLCNT:
;
; R4 = long word value to return to caller
;
EXE$DVI_VALUE_IN_R4::
	MOVAL	SCRATCH(FP),R5		; Address to store VOLCNT
	MOVL	R4,(R5)			; Save the volume count
	MOVL	#4,R4			; Number of bytes to return
	BRB	EXE$DVI_MOVE_ITEM
;
; PID - Convert internal PID in UCB to extended PID for return
;
SPC_PID:
	MOVL	UCB$L_PID(R6),R0	; Internal PID into R0
CVTPID:	JSB	EXE$IPID_TO_EPID	; Convert to extended
PUT4:	MOVL	R0,R4			; Put value in register 4
	BRB	EXE$DVI_VALUE_IN_R4	; Join the common code
;
; ACPPID - Convert internal PID in AQB to extended PID for return
;
SPC_ACPPID:
	MOVL	CURRENT_VCB(FP),R0	; R0 -> volume control block
	BEQL	PUT4			; Return null item if zero
	MOVL	VCB$L_AQB(R0),R0	; Now R0 -> ACP Queue Block
	BEQL	PUT4			; Return null item if zero
	MOVL	AQB$L_ACPPID(R0),R0	; Now R0 has the internal pid
	BRB	CVTPID			; Convert the pid and return
;
; R2 = Volume number of this volume, 1 if not a volume set
; R3 = RVT address, 0 if not a volume set
; R4 = Volume count, 1 if not a volume set
;
RVT_ROOTDEVNAM:
	TSTL	R3			; If not a volume set
	BEQL	SPC_DEVNAM		; Return this volume's device name
	CLRL	R2			; Otherwise return devnam for first vol
RVT_NEXTDEVNAM:
	BRB	20$			; Loop 0 or more times
10$:	MOVL	RVT$L_UCBLST-4(R3)[R2],R6 ; Get UCB for this RVN
					; RVN is base 1, table is base 0
	BLSS	SPC_DEVNAM		; Branch if UCB present
20$:	AOBLEQ	R4,R2,10$		; Try next RVN
DVI_NULL_ITEM_1:
	BRW	EXE$DVI_NULL_ITEM
;
; Device Name String - DEVNAM
;
SPC_ALLDEVNAM:
	MOVL	#1,R4			; flag IOC$CVT_DEVNAM to return the
	BRB	SPC2			; allocation class + device name

SPC_FULLDEVNAM:
	CLRL	R4			; flag IOC$CVT_DEVNAM to return the
	BRB	SPC2			; fully qualified device name

SPC_TT_PHYDEVNAM:
	BBC	#DEV$V_TRM,UCB$L_DEVCHAR(R6),DVI_NULL_ITEM_1 ; Non-terminal?
	BBS	#DEV$V_NET,UCB$L_DEVCHAR(R6),DVI_NULL_ITEM_1 ; Network dev?
	BBS	#DEV$V_RTT,UCB$L_DEVCHAR2(R6),SPC_DEVNAM ; Skip remote term's
	MOVL	UCB$L_TL_PHYUCB(R6),R6	; Fetch physical UCB from virtual
	BEQL	DVI_NULL_ITEM_1		; None, go return null string
SPC_DEVNAM:
	MNEGL	#1,R4			; Force nodename to be left off
SPC2:	MOVL	R6,R5			; UCB Address
	MOVL	R10,R0			; Size of return buffer
	MOVL	R7,R1			; Address of return buffer - pre probed
	JSB	G^IOC$CVT_DEVNAM	; Get device name "_ddcu:"
	MOVL	R1,R4			; Size of string returned
	MOVL	R7,R5			; Address of string
	BRW	EXE$DVI_MOVE_ITEM	; Move to self, zero filling.
;
; Device lock name
;
LCK_FOR:
	BBS	S^#DEV$V_CLU,UCB$L_DEVCHAR2(R6),SPC_ALLDEVNAM ; Cluster-visible?
	BRB	SPC_FULLDEVNAM		; Not cluster-visible
SPC_DEVLOCKNAM:
	MOVL	#16,	R4		; OUTLEN is 16 bytes
	MOVL	CURRENT_UCB(FP),R6	; Setup for DVI_GET_RVT routine
	MOVL	CURRENT_VCB(FP),R5
	BEQL	LCK_FOR			; EQL means not mounted
	BBS	S^#DEV$V_FOR,UCB$L_DEVCHAR(R6),LCK_FOR ; Foreign?

	MOVL	KRP(FP),R1		; Retrieve allocated KRP
	BNEQ	20$			; Continue if KRP has been allocated
	MOVAB	G^CTL$GL_KRPFL,R1	; Retrieve address of KRP queue listhead
	REMQUE	@4(R1),R1		; Retrieve KRP from lookaside list
	BVC	10$			; Continue if got one
	BUG_CHECK	KRPEMPTY,FATAL	; Otherwise bugcheck

10$:	MOVL	R1,KRP(FP)		; Save address of KRP in local storage
20$:	TSTL	UCB$L_PID(R6)		; Is the device allocated?
	BEQL	30$			; EQL means it is not
	MOVB	#DVI_K_PRIVATE,(R1) 	; Setup the prefix byte in KRP
	BRB	40$
30$:	MOVB	#DVI_K_SHAREABLE,(R1)	; Setup the prefix byte in KRP
40$:	BSBW	DVI_GET_RVT		; Get relative volume table address
	BNEQ	50$			; NEQ means it is a volume set
	ADDL	#VCB$T_VOLCKNAM,R5	; Add in offset to 'name'
	BRB	60$
50$:	ADDL3	#RVT$T_VLSLCKNAM,R3,R5	; Add in offset to 'name'
60$:	MOVQ	(R5)+,1(R1)		; Move the 12 bytes to the buffer
	MOVL	(R5),9(R1)
	CLRL	13(R1)			; Zero bytes 14-16
	MOVAL	(R1),R5			; Point to the whole buffer
	BRW	EXE$DVI_MOVE_ITEM
;
; Volume set member
;
SPC_VOLSETMEM:
	MOVL	#1,R4			; Boolean answer is one byte long
	CLRL	SCRATCH(FP)		; Assume not a volume set
	MOVL	CURRENT_UCB(FP),R6	; Setup for DVI_GET_RVT
	MOVL	CURRENT_VCB(FP),R5
	BEQL	20$			; EQL means not mounted
	BSBW	DVI_GET_RVT		; Get relative volume table address
	BEQL	20$			; EQL means not a volume set
	INCL	SCRATCH(FP)		; Set volume set to True
20$:	MOVAB	SCRATCH(FP),R5		; scratch(fp) is were the answer is
	BRW	EXE$DVI_MOVE_ITEM

DVI_NULL_ITEM_2:
	BRW	EXE$DVI_NULL_ITEM
;
; Volume name - strip trailing blanks
;
SPC_VOLNAM:
	MOVL	CURRENT_VCB(FP),R5	; VCB address
	BEQL	DVI_NULL_ITEM_2		; No data if not mounted
	ADDL	#VCB$T_VOLNAME,R5	; Address of volname string
	MOVL	#11,R4			; Base 0 count of characters in name
10$:	CMPB	(R5)[R4],#^A/ /		; Strip off trailing blanks
	BNEQ	20$			; Branch if not a blank
	SOBGEQ	R4,10$			; Try next character
20$:	INCL	R4			; Actual byte count
	BRW	EXE$DVI_MOVE_ITEM	; Go move the volume name

;
; LOGVOLNAM - logical volume name
;
SPC_LOGVOLNAM:
	MOVL	KRP(FP),R1		; Retrieve allocated KRP
	BNEQ	5$			; Continue if KRP has been allocated
	MOVAB	G^CTL$GL_KRPFL,R1	; Retrieve address of KRP queue listhead
	REMQUE	@4(R1),R1		; Retrieve KRP from lookaside list
	BVC	1$			; Continue if got one
	BUG_CHECK	KRPEMPTY,FATAL	; Otherwise bugcheck

1$:	MOVL	R1,KRP(FP)		; Save address of KRP in local storage
5$:	CLRL	(R1)			; Set up a null LOGVOLNAM
	MOVL	CURRENT_VCB(FP),R5	; If no volume control block
	BEQL	80$			; then no logical volume name
	BSBW	DVI_GET_RVT		; Return RVT in R3 or zero
	BEQL	10$			; Branch if not a volume set
	MOVL	RVT$L_UCBLST(R3),R6	; Get Root UCB address
	BEQL	80$			; Branch if no UCB, really an error
10$:	MOVL	@#CTL$GL_PCB,R4		; Get the PCB address for this process
	MOVL	PCB$L_JIB(R4),R4	; Get the JIB address
	MOVAL	JIB$L_MTLFL(R4),R4	; Get the job-wide mount list head

	ASSUME	VCB$V_GROUP EQ VCB$V_SYSTEM-1
	EXTZV	#VCB$V_GROUP,#2,VCB$B_STATUS(R5),R1 ; 0 = Process
					; 1 = Group, 2 = System
	BEQL	20$			; Branch if not mounted /SYSTEM or /GROUP
	MOVAL	IOC$GQ_MOUNTLST,R4	; Search System/Group Mounted Vol List
	MNEGL	R1,R1			; System = -2, Group = -1
20$:	MOVL	R4,R2			; Copy list head address

	ASSUME	MTL$L_MTLFL EQ 0
30$:	MOVL	MTL$L_MTLFL(R2),R2	; Get next entry on list
	CMPL	R2,R4			; End of list?
	BEQL	80$			; Branch if yes, no MTL, really error
	CMPL	R6,MTL$L_UCB(R2)	; MTL entry for this UCB?
	BNEQ	30$			; Try next if not
	TSTL	R3			; Volume set?
	BEQL	40$			; Branch if not, this MTL is it
	BBC	#MTL$V_VOLSET,MTL$B_STATUS(R2),30$ ; Yes, get the right MTL entry
;
; R2 = Mounted Volume List (MTL) entry address
;

40$:	MOVL	@#CTL$GL_PCB,R4		; PCB address for this process
	PUSHL	R4			; Save for unlock call
	JSB	LNM$LOCKR		; Lock Logical name Mutex for reading
;
; ***** Note that R2 is preserved across the above call
;
	MOVL	MTL$L_LOGNAME(R2),R2	; Get logical name table entry adr
	BEQL	50$			; Branch if none present
	MOVZBL	LNMB$T_NAME(R2),R1	; Size of name
	INCL	R1			; Include count byte
	MOVC3	R1,LNMB$T_NAME(R2),@KRP(FP)
				        ; Save logical name in KRP
50$:	POPL	R4			; Get parameters for unlock call
	JSB	LNM$UNLOCK		; Release Logical Name Table Mutex
80$:	MOVL	KRP(FP),R5		; Address of counted string to return
	BRW	EXE$DVI_CSTRING		; Go move counted string

;
; Functional Description:
;
;	Get Relative Volume Table address if any
;
; Calling Sequence:
;
;	BSBW	DVI_GET_RVT
;
; Inputs:
;
;	R5 = VCB address
;	R6 = UCB address
;
; Outputs:
;
;	If this UCB is part of a volume set:
;		Condition code Z is CLEAR
;		R2 = RVN for this volume
;		R3 = RVT address
;		Other registers are preserved
;
;	If this UCB is NOT part of a volume set:
;		Condition code Z is SET
;		R3 = 0
;		Other registers are preserved
;
DVI_GET_RVT:
	CLRL	R3			; Assume not a volume set
	BBS	S^#DEV$V_FOR,UCB$L_DEVCHAR(R6),20$ ; If FOREIGN, not a volume set
	MOVZWL	VCB$W_RVN(R5),R2	; Relative volume number
	BEQL	20$			; Branch if not a volume set
	MOVL	VCB$L_RVT(R5),R3	; Fetch RVT address (still could be 0)
20$:	RSB				; Return Z bit set if R3 = 0

;
; Volume free blocks
;
SPC_FREEBLOCKS:
	MOVAL	SCRATCH(FP),R5		; Stash a pointer to the answer
	CLRL	(R5)			; Assume zero blocks
	MOVL	CURRENT_UCB(FP),R6	; Get the ucb address
	CMPB	UCB$B_DEVCLASS(R6),#DC$_DISK ; Is it a disk?
	BNEQ	20$			; NEQ means not a disk, return 0 blocks
	MOVL	CURRENT_VCB(FP),R6	; Get the vcb for the disk
	BEQL	20$			; EQL means not mounted
	MOVL	VCB$L_FREE(R6),(R5)	; Assume that we will use free blocks from VCB
	MOVL	VCB$L_AQB(R6),R4	; Get pointer to AQB
	BEQL	20$			; EQL means no AQB, use vcb$l_free (strange device, tho)
	CMPB	AQB$B_ACPTYPE(R4),#AQB$K_F11V2 ; Is it an ODS-2 ACP?
	BNEQ	20$			; NEQ means not ODS-2, use vcb$l_free
	MOVL	VCB$L_VOLLKID(R6),R4	; Get the lock id for the volume lock
	BEQL	20$			; EQL means no lock id, use vcb$l_free (shouldn't happen)
	MOVQ	R4,-(SP)		; Push the lock id and return value address onto stack
	CALLS	#2,EXE$DVI_FREEBLOCKS	; Call the routine to check the lock
					; If error, then vcb$l_free will be used
20$:	MOVL	#4,R4			; Answer is 4 bytes long
	BRW	EXE$DVI_MOVE_ITEM	; Go move the item

;+
; EXE$DVI_FREEBLOCKS 
;	Procedure to fetch the correct free block count from the XQP's volume
; lock block.  This procedure is also called by SHOW DEVICE (SHODEVUTL.B32) DCL
; command to fetch the correct free blocks for SHOW DEVICE displays.
;
; Input:
;	4(AP) - Lockid to fetch value block
; Output:
;	8(AP) - Address to store freeblocks field
; Routine value:
;	R0 -    Status from getlki call
;-

; Offsets from frame pointer for scratch storage
;
VALBLK = -32		; Address to return value block
FREEBL = VALBLK + 4	; Free blocks are in second longword of value block
ITMLST = -16		; Build 4 longword item list

.ENTRY	EXE$DVI_FREEBLOCKS,0
	SUBL2	#32,SP				; Get scratch area
	MOVL	#<<LKI$_VALBLK@16>!16>,ITMLST(FP) ; Item code and buffer length
	MOVAB	VALBLK(FP),ITMLST+4(FP)		; Address of value block
	CLRQ	ITMLST+8(FP)			; No return length, end of list
	$GETLKIW_S EFN=S^#EXE$C_SYSEFN, LKIDADR=4(AP), ITMLST=ITMLST(FP)
	BLBC	R0,10$				; Error? Then exit
	MOVL	FREEBL(FP),@8(AP)		; Send it back
10$:	RET




;
; R6  = UCB address
; R7  = Destination address - already probed
; R8  = Address to return length or 0 - already probed
; R10 = Size of return buffer for item, zero fill this buffer
;
SPC_MEDIA_NAME:
	CMPB	UCB$B_DEVCLASS(R6), #DC$_DISK	; If disk class OK
	BEQL	10$
	CMPB	UCB$B_DEVCLASS(R6), #DC$_TAPE	; If tape class OK
	BEQL	10$
 5$:	BRW	EXE$DVI_NULL_ITEM		; If not disk or tape return null
10$:	TSTL	UCB$L_MEDIA_ID(R6)		; Test to make sure field is not 0
	BEQL	5$				; If 0 then return null item
	MOVL	KRP(FP), R1			; Get address of KRP to build 
	BNEQ	30$				;  the string (may be >4 chars)
	MOVAB	G^CTL$GL_KRPFL, R1		; Get Q head
	REMQUE	@4(R1), R1			; Get next KRP
	BVC	20$				; Branch if not empty
	BUG_CHECK	KRPEMPTY, FATAL
20$:	MOVL	R1, KRP(FP)			; Save address of KRP address
30$:	CLRL	R4				; Init string length
	EXTZV	#UCB$V_MEDIA_ID_N0, -
		#UCB$S_MEDIA_ID_N0, -
		UCB$L_MEDIA_ID(R6), -
		R0				; Extract character number
	BEQL	40$				; If zero null character
	BSBB	DVI_DECODE_MEDIA_CHAR		; place ASCII char in string
40$:	
	EXTZV	#UCB$V_MEDIA_ID_N1, -
		#UCB$S_MEDIA_ID_N1, -
		UCB$L_MEDIA_ID(R6), -
		R0				; Extract character number
	BEQL	50$				; If zero null character
	BSBB	DVI_DECODE_MEDIA_CHAR		; place ASCII char in string
50$:
	EXTZV	#UCB$V_MEDIA_ID_N2, -
		#UCB$S_MEDIA_ID_N2, -
		UCB$L_MEDIA_ID(R6), -
		R0				; Extract character number
	BEQL	60$				; If zero null character
	BSBB	DVI_DECODE_MEDIA_CHAR		; place ASCII char in string
60$:
	EXTZV	#UCB$V_MEDIA_ID_NN, -
		#UCB$S_MEDIA_ID_NN, -		; value of two decimal
		UCB$L_MEDIA_ID(R6), -
		R0				;  digits
	CMPL	R0, #100
	BLSSU	70$				; If < 100 skip to tens
	CLRL	R2				; Clear hundreds counter
65$:	SUBB2	#100, R0			; Subtract 100 from value
	BLSS	66$				; Branch if go negative
	INCL	R2				; Incre tens counter
	BRB	65$				; Loop
66$:	ADDB2	#100, R0			; Get back to positive #
	ADDB2	#^X30, R2			; Convert to acsii char
	MOVB	R2, (R1)+			; Move into string
	INCL	R4				; Adjust length
70$:	CLRL	R2				; Clear tens counter
75$:	SUBB2	#10, R0				; Subtract 10 from value
	BLSS	80$				; Branch if go negative
	INCL	R2				; Incre tens counter
	BRB	75$				; Loop
80$:	ADDB2	#^X30, R2			; Convert to acsii char
	MOVB	R2, (R1)+			; Move into string
	ADDB2	#^X3A, R0			; Convert neg number to
						;  pos ascii character
	MOVB	R0, (R1)+			; Move it into the string
	ADDB2	#2, R4				; Adjust the length
	MOVL	KRP(FP), R5			; Set source address
	BRW	EXE$DVI_MOVE_ITEM		; Move the string and process
						;  the next item

;
; R0 = character number
; R1 = address of next free byte in string
; R4 = length of string
;
DVI_DECODE_MEDIA_CHAR:
	CMPL	R0, #26				; Only 26 chars in alphabet
	BGTRU	20$				; If not 0-26 place "." in string
	ADDL2	#^X40, R0			; Convert number to ascii char
10$:	INCL	R4				; increment length
	MOVB	R0, (R1)+			; Move the char into string
	RSB
20$:	MOVZBL	#^X2E, R0			; Set  "."
	BRB	10$

;
; R6  = UCB address
; R7  = Destination address - already probed
; R8  = Address to return length or 0 - already probed
; R10 = Size of return buffer for item, zero fill this buffer
;
SPC_MEDIA_TYPE:
	CMPB	UCB$B_DEVCLASS(R6), #DC$_DISK	; If disk class OK
	BEQL	10$
	CMPB	UCB$B_DEVCLASS(R6), #DC$_TAPE	; If tape class OK
	BEQL	10$
	BRW	EXE$DVI_NULL_ITEM		; If not disk or tape return null
10$:	MOVAL	SCRATCH(FP), R1			; Set address to build string
	CLRL	R4				; Init char count
	EXTZV	#UCB$V_MEDIA_ID_T0, -
		#UCB$S_MEDIA_ID_T0, -
		UCB$L_MEDIA_ID(R6), -
		R0				; Extract character number
	BEQL	20$				; If zero null character
	BSBB	DVI_DECODE_MEDIA_CHAR		; place ASCII char in string
20$:
	EXTZV	#UCB$V_MEDIA_ID_T1, -
		#UCB$S_MEDIA_ID_T1, -
		UCB$L_MEDIA_ID(R6), -
		R0				; Extract character number
	BEQL	30$				; If zero null character
	BSBB	DVI_DECODE_MEDIA_CHAR		; place ASCII char in string
30$:
	MOVAL	SCRATCH(FP), R5			; Set source address
	BRW	EXE$DVI_MOVE_ITEM		; Move the string and process
						;  the next item


	.SBTTL	Dual path and shadow set items
;
; Items for shadow sets
;
SPC_SHDW_CATCHUP_COPYING:		; Catchup copy in progress
SPC_SHDW_MERGE_COPYING:			; Merge copy in progress
SPC_SHDW_spare_bit_1:			; Just in case
SPC_SHDW_spare_bit_2:			; Just in case
	MOVAB	EXE$DVI_RETURN_FALSE, R0
	BRB	MV_JUMP
SPC_SHDW_MASTER_NAME:			; Master name for set
SPC_SHDW_NEXT_MBR_NAME:			; Name of next member
SPC_SHDW_spare_string_1:		; Just in case
SPC_SHDW_spare_string_2:		; Just in case
	MOVAB	EXE$DVI_NULL_ITEM, R0
	BRB	MV_JUMP
SPC_SHDW_spare_integer_1:		; Just in case
SPC_SHDW_spare_integer_2:		; Just in case
	MOVAB	EXE$DVI_RETURN_ZERO, R0
	;fall through to MV_JUMP
;
; Since Shadow support is latent, we will jump into the mount verification
; code in SYSLOA to process the item.  This is a lot simpler than trying
; to patch SYS at some future date.
;
MV_JUMP:
	JMP	G^EXE$MNTVER_DVI_ASSIST	; For now, this just does a JMP (R0)

;
; DVI$_REMOTE_DEVICE - Device is served by a host other than the local VAX
;
SPC_REMOTE_DEVICE:
	MOVAB	G^SCS$GA_LOCALSB, R0	; Get the address of the local system block
	MOVL	CURRENT_UCB(FP), R6	; Get the address of the UCB
	MOVL	UCB$L_DDB(R6), R6	; Move down to the DDB
	CMPL	DDB$L_SB(R6), R0	; Compare DDB's SB with the local SB
	BEQL	EXE$DVI_RETURN_FALSE	; EQL means that it is the local block
	BRB	EXE$DVI_RETURN_TRUE	; Set the flag, it is remote

;
; DVI$_SHDW_MASTER - The device is really the "virtual" name for the shadow set
;
SPC_SHDW_MASTER:
	MOVL	CURRENT_UCB(FP), R6	; Get the address of the UCB
	BBC	#DEV$V_MSCP, -		; See if the mscp bit is set in the
		UCB$L_DEVCHAR2(R6), -	;  second characteristics longword
		EXE$DVI_RETURN_FALSE	;  and return false if not set
	TSTW	UCB$W_MSCPUNIT(R6)	; Unit # with high bit set is shadow master
	BGEQ	EXE$DVI_RETURN_FALSE	; GEQ means that high bit is not set
	BRB	EXE$DVI_RETURN_TRUE	; Set the flag, it is the master

;
; Routines to return specific values
;
EXE$DVI_RETURN_TRUE::			; Boolean TRUE
	MOVAL	SCRATCH(FP),R5		; Grab pointer to scratch area
	MOVL	#1,(R5)			; Return a one
	BRB	RETURN_TF
EXE$DVI_RETURN_FALSE::			; Boolean FALSE
	MOVAL	SCRATCH(FP),R5		; Grab pointer to scratch area
	CLRL	(R5)			; Return a zero
RETURN_TF:
	MOVL	#1,R4			; Booleans are one byte long
	BRW	EXE$DVI_MOVE_ITEM
EXE$DVI_RETURN_ZERO::			; Integer 0
	CLRL	R4			; Set the zero
	BRW	EXE$DVI_VALUE_IN_R4

;
; DVI$_HOST_AVAIL - Host for the primary path is available
; DVI$_ALT_HOST_AVAIL  - Host for the secondary path is available
;
SPC_ALT_HOST_AVAIL:
	MOVL	CURRENT_UCB(FP), R6	; Get the UCB address
	BBC	#DEV$V_2P, -		; If the dual-port bit is 
		UCB$L_DEVCHAR2(R6), -	;  clear in the characteristics,
		EXE$DVI_RETURN_FALSE	;  return a false
	BBC	#DEV$V_MSCP, -		; If the MSCP device bit is 
		UCB$L_DEVCHAR2(R6), -	;  clear in the characteristics,
		EXE$DVI_RETURN_FALSE	;  return a false
	BBS	#DEV$V_CDP, -		; If the class driver path bit is
		UCB$L_DEVCHAR2(R6), -	;  set in the characteristics,
		EXE$DVI_RETURN_FALSE	;  return a false (no 2P_CDDB for these)
	MOVL	UCB$L_2P_CDDB(R6), R6	; Get the CDDB address for the second path
	BGEQ	EXE$DVI_RETURN_FALSE	; Extra paranoia (false if not system address)
	BRB	HOST_AVAIL		; Join the common code

SPC_HOST_AVAIL:
	MOVL	CURRENT_UCB(FP), R6	; Get the UCB address
	BBC	#DEV$V_MSCP, -		; If the MSCP device bit is clear, then
		UCB$L_DEVCHAR2(R6), -	;  it is a local path
		EXE$DVI_RETURN_TRUE	;  and always return true
	MOVL	UCB$L_CDDB(R6), R6	; Get the DDB address for the primary path
HOST_AVAIL:
	BBS	#CDDB$V_NOCONN, -	; If the NOCONNECTION bit is set
		CDDB$W_STATUS(R6), -	;  in the status, then it is not avail
		EXE$DVI_RETURN_FALSE	;  and return a false
	BRB	EXE$DVI_RETURN_TRUE	; Set the flag, it is available

;
; DVI$_HOST_COUNT - Number of hosts serving the device (either 0 or 1)
;
SPC_HOST_COUNT:
	MOVL	#4, R4			; Four is length of integer items
	MOVAB	SCRATCH(FP), R5		; Get the pointer to the scratch longword
	MOVL	#1, (R5)		; Assume that the device has one server
	MOVL	CURRENT_UCB(FP), R6	; Get the address of the UCB
	BBC	#DEV$V_2P, -		; See if the dual path bit is clear in the
		UCB$L_DEVCHAR2(R6), 10$	;  second characteristics longword
	INCL	(R5)			; Bump the flag, it has a second path
10$:	BRW	EXE$DVI_MOVE_ITEM	; Go move it

DVI_NULL_ITEM_3:
	BRW	EXE$DVI_NULL_ITEM

;
; DVI$_HOST_NAME - Node name of the host for the primary path
; DVI$_ALT_HOST_NAME  - Node name of the host for the secondary path
;
SPC_ALT_HOST_NAME:
	MOVL	CURRENT_UCB(FP), R6	; Get the UCB address
	BBC	#DEV$V_2P, -		; If the dual-port bit is not
		UCB$L_DEVCHAR2(R6), -	;  set in the characteristics,
		DVI_NULL_ITEM_3		;  return a null string
	MOVL	UCB$L_2P_DDB(R6), R6	; Get the DDB address for the second path
	BRB	HOST_NAME		; Join the common code
SPC_HOST_NAME:
	MOVL	CURRENT_UCB(FP), R6	; Get the UCB address
	MOVL	UCB$L_DDB(R6), R6	; Get the DDB address for the primary path
HOST_NAME:
	MOVL	DDB$L_SB(R6), R6	; Get the SB address
	MOVZBL	SB$T_NODENAME(R6), R4	; Pick up length of ASCIC string
	MOVAB	SB$T_NODENAME+1(R6), R5	; Pick up address of ASCIC string
	BRW	EXE$DVI_MOVE_ITEM	; Go move the item

;
; DVI$_HOST_TYPE - Type of node of the host for the primary path
; DVI$_ALT_HOST_TYPE  - Type of node of the host for the secondary path
;
SPC_ALT_HOST_TYPE:
	MOVL	CURRENT_UCB(FP), R6	; Get the UCB address
	BBC	#DEV$V_2P, -		; If the dual-port bit is not
		UCB$L_DEVCHAR2(R6), -	;  set in the characteristics,
		DVI_NULL_ITEM_3		;  return a null string
	MOVL	UCB$L_2P_DDB(R6), R6	; Get the DDB address for the second path
	BRB	HOST_TYPE		; Join the common code
SPC_HOST_TYPE:
	MOVL	CURRENT_UCB(FP), R6	; Get the UCB address
	MOVL	UCB$L_DDB(R6), R6	; Get the DDB address for the primary path
HOST_TYPE:
	MOVL	DDB$L_SB(R6), R6	; Get the SB address
	MOVAB	SB$T_HWTYPE(R6), R5	; Pick up address of padded string
	LOCC	#^A" ", #4, (R5)	; Look for the first blank
	SUBL3	R0, #4, R4		; R0 contains number of blanks (or zero)
	BRW	EXE$DVI_MOVE_ITEM	; Go move the item

	.SBTTL	Get UCB from channel or device name
;
; FUNCTIONAL DESCRIPTION:
;
;	Given either the channel or the device name string, return
; the primary UCB/VCB addresses and the secondary UCB/VCB addresses
;
; INPUTS:
;
;	R0 = CHAN if entered at DVI_USE_CHAN
;	   = DEVNAM if entered at DVI_USE_DEVNAM
;	     Neither the descriptor nor the string have been probed
;	R4 = Current Process PCB Address
;
; OUTPUTS:
;
;	R0 = status
;	STATUS(FP) = Returned success status from IOC$SEARCHDEV
;		   = SS$_NORMAL or SS$_CONCEALED
;		     Only returned when entered at DVI_USE_DEVNAM
;	PRIMARY_UCB(FP) = Address of the primary UCB
;	PRIMARY_VCB(FP) = Address of the primary VCB
;	SECONDARY_UCB(FP) = Address of the secondary UCB
;	SECONDARY_VCB(FP) = Address of the secondary VCB
;
	.ENABL	LSB

DVI_USE_CHAN:
	JSB	G^IOC$VERIFYCHAN	; Verify channel number
	BLBC	R0,60$			; Branch if error
	PUSHL	CCB$L_UCB(R1)		; Get UCB out of CCB
	JSB	G^SCH$IOLOCKR		; Lock I/O database for read access
	INCL	IOUNLOCK(FP)		; Note that unlock is required
	POPR	#^M<R1>			; Recover UCB address
	BRB	30$
10$:	MOVZWL	#SS$_IVDEVNAM,R0	; Invalid device name error
	BRB	60$
20$:	MOVL	#SS$_ACCVIO,R0		; Access violation
	BRB	60$
DVI_USE_DEVNAM:
	MOVL	R0,R1			; Device name string specified?
	BEQL	10$			; Branch if not, IVDEVNAM
	IFNORD	#8,(R1),20$		; Branch if descriptor cannot be read
	JSB	G^SCH$IOLOCKR		; Lock I/O database for read access
	INCL	IOUNLOCK(FP)		; Note that unlock is required
;
; ***** Note that the device name string still must be probed
;
	JSB	G^IOC$SEARCHDEV		; Search for device
	BLBC	R0,60$			; If error, return status
	MOVW	R0,STATUS(FP)		; Save success status
					; SS$_NORMAL or SS$_CONCEALED

    	BBC	S^#DEV$V_RED,UCB$L_DEVCHAR2(R1),30$; Skip if not redirected
					; physical terminal UCB
	MOVL	UCB$L_TT_LOGUCB(R1),R1	; redirect to associated logical tty UCB

;
; R1 = desired UCB
; If the device has an associated mail box and it is not spooled, then
; the UCB in the AMB field is the secondary device.  If, however the
; device is spooled, the AMB field (intermediate device) is the primary
; device and the final destination device is the secondary.
;
30$:	MOVL	R1,R2			; Assume primary = secondary
	MOVL	UCB$L_AMB(R1),R3	; Get associated mail box if any
	BEQL	50$			; Branch if none
	BBC	S^#DEV$V_SPL,UCB$L_DEVCHAR(R1),40$ ; Branch if not spooled
	MOVL	R3,R2			; Spooled dev, primary = AMB = intermed dev
	BRB	50$
40$:	MOVL	R3,R1			; Not spooled, secondary = AMB
;
; R2 = primary UCB
; R1 = secondary UCB
;
50$:	MOVAL	PRIMARY_UCB(FP),R0	; Address to store primary UCB/VCB
	BSBB	SET_UCB_VCB		; Store UCB and VCB
	MOVL	R1,R2			; Secondary UCB
	BSBB	SET_UCB_VCB		; Store secondary UCB/VCB
	MOVL	#SS$_NORMAL,R0		; Set success status
60$:	RSB

	.DSABL	LSB
;
; Store UCB and its associated VCB address if any
;
; Inputs:
;
;	R2 = UCB address
;	R0 = address to store UCB/VCB
;
; Outputs:
;
;	R0 updated to next quad word
;	R1,R2 preserved
;	R3 altered
;	other registers preserved
;
SET_UCB_VCB:
	CLRL	R3			; Assume volume not mounted
	BBC	S^#DEV$V_MNT,UCB$L_DEVCHAR(R2),10$ ; Branch if not mounted
	MOVL	UCB$L_VCB(R2),R3	; Get VCB address
10$:	MOVQ	R2,(R0)+		; Store UCB/VCB
	RSB

	.END
