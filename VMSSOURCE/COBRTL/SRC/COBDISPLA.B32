MODULE COB$DISPLAY ( %TITLE 'VAX-11 COBOL DISPLAY statement'
		   IDENT = '1-015'	! File: COBDISPLA.B32 EDIT:LGB1015
				   ) =
BEGIN
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
!

!++
! FACILITY:  COBOL SUPPORT
!
! ABSTRACT:
!
!	Supports the COBOL DISPLAY and DISPLAY WITH NO ADVANCING
!	statements.  Enhanced to perform the new screen handling
!	extensions for VAX-11 COBOL Version 3.
!
!	Contains COB$$OPEN_OUT	to open an RMS file for output.
!
!	Avoids use of STR$CONCAT to avoid its overhead.  The 
!	concatenation which needs to be done is done inline since
!	all required lengths are known.
!
! ENVIRONMENT:  VAX-11 User Mode
!
! AUTHOR: Rich Reichert, CREATION DATE: 17-JULY-79
!
! MODIFIED BY:
!
! 1-001	- Original.  RKR 17-JULY-79
! 1-002 - Remove usage of STR$CONCAT and associated string routines,
!	  as well as minor code rearrangements to improve resulting
!	  code.  RKR 17-SEPT-79
! 1-003 - Change basic algorithm for concatenation.
!	  If 1 string, write from caller's buffer
!	  If more than 1 string and total length less than 132 chars,
!		concatenated on stack.
!	  Else concatenate in heap storage.
!	  RKR 25-SEPT-79
! 1-004 - Change symbolic name of LIBRARY file. RKR 1-OCT-79
! 1-005 - Change references to LIB$_INVARG to COB$_INVARG
!	  Cosmetic changes.  RKR 21-OCT-79
! 1-006 - Make sensitive to REQUIRE file.  RKR 21-OCT-79
! 1-007 - Improve error messages.  RKR 21-OCT-79
! 1-008 - Pass filename descriptor to COB$$WRITE_RMS so that we have
!	  filename available for signaling if errors arise.
!	  RKR 05-NOV-79
! 1-009 - Make smaller by creating additional common code.
!	  RKR 07-NOV-79
! 1-010	- Imperative clean-ups, also try SYS$ logicals.
!	  PDG 00-FEB-81
! 1-011 - Added EDIT phrase so CHECKIN creates a valid audit trail.  Also
!	  updated copyright date.  LB 9-AUG-81
! 1-012 - Added routines to perform the new screen handling extensions for
!	  Version 3 of VAX-11 COBOL.
!	  New routines;
!			COB$DISP_SCR
!			COB$DISP_SCR_NO_ADV
!			COMMON_SCREEN
!			DISP_CONVERT
!			DISP_PARSE
!			COB$$FREE_STRINGS
!	  Changes to old routines;
!			COB$$OPEN_OUT  -  made it a GLOBAL routine
!	  LGB 11-MAR-83
! 1-013 - Additional code for screen handling extensions.
!		ADJUST_FL_PT macro.
!		Version 1 / Version 3 DISPLAY and ACCEPT statement interaction,
!		COB$$AB_PREV initial state changed from 0 to 9.
!		VAX-11 COBOL Compiler now passing a bit in FLAGS if they do
!		not want a SIGN printed in a COMP data item.
!		PIC P data item addressed.
!	  LGB 15-AUG-83
! 1-014 - Added routine to return address of COB$$AB_PREV.  This is needed
!	  by RPG$DSPLY.  Routine is COB$$RET_A_AB_PREV.		MDL 29-AUG-1983
! 1-015 - Parameter added to COB$$OPEN_OUT to bypass some COBOL code for
!	  RPG.  Now uses COBPROLOG.REQ.				LGB 24-OCT-83
!--

!
! PROLOGUE FILE
!
REQUIRE 'RTLIN:COBPROLOG' ;				! Switches, Psects,
!							! Include files.
! LINKAGES:
!
LINKAGE
	CVT_JSB = JSB (REGISTER = 6, REGISTER = 7, REGISTER = 8, REGISTER = 9) :
		      NOPRESERVE (2, 3, 4, 5, 6, 7, 8)
		      NOTUSED (10, 11) ;
!
! TABLE OF CONTENTS:
!
FORWARD ROUTINE
	COB$DISPLAY:		NOVALUE,	! Display with normal advancing
	COB$DISP_NO_ADV:	NOVALUE,	! Display with no advancing
	COB$DISP_SCR:		NOVALUE,	! Display with screen enhancements
						! and normal advancing
	COB$DISP_SCR_NO_ADV:	NOVALUE,	! Display with screen enhancements
						! and no advancing
	COMMON_CODE:		NOVALUE,	! Code which is common to
						! COB$DISPLAY and COB$DISP_NO_ADV
	COMMON_CODE_1:		NOVALUE,	! Code which is common to 
						! COB$DISPLAY and COB$DISP_NO_ADV
	COB$$OPEN_OUT:		NOVALUE,	! Open for output
	COMMON_SCREEN:		NOVALUE,	! Code which is common to COB$DISP_SCR 
						! and COB$DISP_SCR_NO_ADV
	DISP_CONVERT:		NOVALUE,	! Numeric conversions
	DISP_PARSE:		NOVALUE,	! Put together string for output
	COB$$FREE_STRINGS,			! Free local strings
	COB$$RET_A_AB_PREV ;			! Retrn address of COB$$AB_PREV
!
! EQUATED SYMBOLS:
!
LITERAL
    NUM_UNITS = COB$K_UNIT_MAX - COB$K_UNIT_MIN + 1 ;	! Number of units

LITERAL
    DISP      =	0,		! Code for DISPLAY
    DNA       =	1,		! Code for DISPLAY with no advancing
    POS       =	2,		! Code for COB$POS_ERASE being called prior to
				! entrance to this module (prev - display)
    POS_DNA   =	3,		! Code for COB$POS_ERASE being called prior to
				! entrance to this module (prev - disp no adv)
    ACC_ADV   = 4,		! Code for ACCEPT Advancing (V3)
    ACC_DNA   = 5,		! Code for ACCEPT No Advancing (V3)
    CRR       =	%X'8D',		! Code for carriage return
    LINE_FEED =	%X'8A',		! Code for line-feed
    V_BELL    = 16,		! Bit flag for terminal bell
    V_CONV    = 32,		! Bit flag for conversion
    V_DEC_PT  = 64,		! Bit flag for 'decimal point is comma'
    V_NO_SIGN = 128,		! Bit flag for COMP data items, 1=do not print sign
    V_COB_RPG = 2048,		! Bit flag for VAX COBOL / VAX RPG
    FLAG_MASK = 15 ;		! Masks first four bits of FLAGS (0-3) for call
				! to COB$$SET_ATTRIBUTES (bold, reverse, blink,
				! and underline)
!
! GUARDS:
!
!   Since the code assumes that COB$K_UNIT_MIN equals 0, and COB_TABLE
!	has only 7 items in it, we safeguard this module.
!
%IF COB$K_UNIT_MIN NEQ 0 %THEN %ERROR('Unexpected COB$K_UNIT_MIN value') %FI
%IF COB$K_UNIT_MAX GTR 6 %THEN %ERROR('Unexpected COB$K_UNIT_MAX value') %FI

!
! OWN STORAGE:
!
!   The following GLOBAL cells are used by the file I/O routines.
!
GLOBAL
    COB$$AL_WRITE_RAB:	VECTOR[NUM_UNITS] 
		INITIAL (REP NUM_UNITS  OF LONG (0)),	! Address of output RAB
    COB$$AW_WRITE_IFI:	VECTOR[NUM_UNITS, WORD] 
		INITIAL	(REP NUM_UNITS  OF WORD (0)),	! Internal file identifiers
    COB$$AB_USPCODE:	VECTOR[2,BYTE],			! byte 0 is prefix upspacing
							! byte 1 is post upspacing
    COB$$AB_PREV:	VECTOR [NUM_UNITS, BYTE]	! History of whether previous call was
		INITIAL (REP NUM_UNITS OF BYTE (9)) ;	! a DISPLAY or DISPLAY_NO_ADV
!
!   MACROS:
!
!	Adjust the output of the OTS$ routines that convert Floating Point
!	and Double Floating Point to Text.
!		Old result 0.1110000E+03, now want 1.110000E+02
!	
MACRO
    ADJUST_FL_PT =
	
	BEGIN						! Begin FL macro

	LOCAL
	    ANS_BUF	:  REF VECTOR [25,BYTE],
	    E_SIGN,					! sign position of exp
	    E_ONES,					! ones position of exp
	    E_TENS,					! tens position of exp
	    SHIFT_ALL,					! # of chars to shift
	    SEARCH,					! # of chars to search
	    CHANGE,					! =1 if e+00 should be
							! changed to e-01
	    TEMP	:  BYTE ;			! Needed for exchange

	ANS_BUF = .ANS_STRING [DSC$A_POINTER] ;
	IF (.STRING [DSC$B_DTYPE] EQL DSC$K_DTYPE_F )
	THEN
	    BEGIN					! Floating
	    E_SIGN    = 11 ;				! Where to find exponent
	    E_ONES    = 13 ;				! in ANS_STRING
	    E_TENS    = 12 ;
	    SHIFT_ALL = 12 ;				! Shift 12 chars for FL
	    END
	ELSE						! Double Floating
	    BEGIN
	    E_SIGN    = 20 ;				! Where to find exponent
	    E_ONES    = 22 ;				! in ANS_STRING
	    E_TENS    = 21 ;
	    SHIFT_ALL = 21 ;				! Shift 21 chars for D FL
	    END ;

	!+
	!  'Decimal Point is Comma' - place comma in ANS_BUF to overwrite
	!   decimal point that is already there.
	!-

	IF (.FLAGS AND V_DEC_PT) NEQ 0
	THEN
	    ANS_BUF [2] = %C',' ;

	!+
	!  Adjust exponent - decrement if positive, increment if negative.
	!  However leave 0.00..00E+00 as is.
	!-

	IF (.ANS_BUF [.E_ONES] EQL %C'0' ) AND (.ANS_BUF [.E_TENS] EQL %C'0')
	THEN
	    BEGIN
	    !+
	    !  E+00 -> E-01 -> but leave 0.00...00E+00 as is.
	    !-
	    IF .SHIFT_ALL EQL 12
	    THEN SEARCH = 9
	    ELSE SEARCH = 18 ;	
	    INCR P FROM 3 TO .SEARCH DO
		IF .ANS_BUF [.P] NEQ %C'0'
		THEN CHANGE = 1 ;

	    IF .CHANGE EQL 1				! Change xxxE+00 to
	    THEN					! xxxE-01
	    BEGIN
	    ANS_BUF [.E_SIGN] = %C'-' ;
	    ANS_BUF [.E_TENS] = %X'30' ;
	    ANS_BUF [.E_ONES] = %X'31' ;
	    END ;
	    END
	ELSE
	    BEGIN
	    IF (.ANS_BUF [.E_SIGN] EQL %C'+' ) 
	    THEN
		!+
		!  Exponent is positive - decrement it
		!-
		BEGIN
		IF (.ANS_BUF [.E_ONES] NEQ %C'0')
		THEN						! E+18 -> E+17
		    ANS_BUF [.E_ONES] = .ANS_BUF [.E_ONES] - 1
		ELSE
		    BEGIN					! E+20 -> E+19
		    ANS_BUF [.E_ONES] = %X'39' ;
		    ANS_BUF [.E_TENS] = .ANS_BUF [.E_TENS] - 1 ;
		    END ;
		END
	    ELSE
		!+
		!  Exponent negative - increment it
		!-
		BEGIN
		IF (.ANS_BUF [.E_ONES] NEQ %C'9')
		THEN						! E-15 -> E-16
		    ANS_BUF [.E_ONES] = .ANS_BUF [.E_ONES] + 1
		ELSE
		    BEGIN					! E+20 -> E+19
		    ANS_BUF [.E_ONES] = %X'30' ;
		    ANS_BUF [.E_TENS] = .ANS_BUF [.E_TENS] + 1 ;
		    END ;
		END ;
	    END ;

	!+
	!  Exchange decimal point and digit you want before the decimal point
	!  Mantissa was 0.123... now will be 01.23...
	!-

	TEMP        = .ANS_BUF [2] ;
	ANS_BUF [2] = .ANS_BUF [3] ;
	ANS_BUF [3] = .TEMP ;

	!+
	!  Pull the zero that is before the decimal point.  Shift the other
	!  digits by one.
	!  	Old result 	    0.1110000E+03,
	!	from exchange above 01.110000E+02,
	!	now want 	    1.110000E+02
	!-

	INCR X FROM 1 TO .SHIFT_ALL DO
	    ANS_BUF [.X] = .ANS_BUF [.X+1] ;

	!+
	!  Adjust length of ANS_STRING
	!-
	
	ANS_STRING [DSC$W_LENGTH] = .ANS_STRING [DSC$W_LENGTH] - 1 ;

	END ;							! End FL macro
    % ; 
!
!
!   The following tables convert the UNIT number into a logical name.
!
MACRO
    DESC_(A) = UPLIT BYTE(%ASCIC A) - BASE %;
BIND
    BASE = UPLIT(REP 0 OF (0)),
    COB_TABLE = UPLIT(
	DESC_('COB$INPUT'),
	DESC_('COB$OUTPUT'),
	DESC_('COB$CONSOLE'),
	DESC_('COB$CARDREADER'),
	DESC_('COB$PAPERTAPEREADER'),
	DESC_('COB$LINEPRINTER'),
	DESC_('COB$PAPERTAPEPUNCH')):	VECTOR[NUM_UNITS],
    SYS_TABLE = UPLIT(
	DESC_('SYS$INPUT'),
	DESC_('SYS$OUTPUT'),
	DESC_('SYS$ERROR'),
	DESC_('SYS$INPUT'),
	DESC_('SYS$INPUT'),
	DESC_('SYS$OUTPUT'),
	DESC_('SYS$OUTPUT')):		VECTOR[NUM_UNITS];

!
! EXTERNAL REFERENCES:
!
EXTERNAL ROUTINE
	LIB$STOP : NOVALUE,			! Signals fatal error
	LIB$GET_VM,				! Get virtual memory
	LIB$FREE_VM,				! Free virtual memory
	STR$DUPL_CHAR,				! Duplicate a character n times
	STR$GET1_DX,				! Allocate a string
	STR$FREE1_DX,				! Deallocate a string
	STR$COPY_R,				! Copy a string by ref
	COB$CNVOUT,				! Convert from D and F floating
						! to Fortran E format
	COB$CVTQP_R9 : CVT_JSB,			! Convert quad to packed
	COB$$SETUP_TERM_TYPE,			! Setup terminal type
	COB$$SET_ATTRIBUTES ;			! Set bold, reverse, blink,
						! underline
EXTERNAL LITERAL
	COB$_ERRDURDIS,				! Error during DISPLAY
	COB$_FAIGET_VM,				! Failure to get VM
	COB$_INVARG;				! Invalid Argument(s)

EXTERNAL
	COB$TERM_TYPE;				! Terminal type

GLOBAL ROUTINE COB$DISPLAY (
			    UNIT,	! Unit # of output device
			    STRING      ! Input string
			   ) : NOVALUE =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Performs COBOL DISPLAY statement given a unit number and
!	one or more strings to display.  If more than one string is
!	specified, these strings are concatenated into a single string
!	before being output.  The upspacing to be employed is a function
!	of this call (normal ADVANCING) and the upspacing used on a
!	previous call to this routine or to COB$DISP_NO_ADV, or
!	COB$DISP_SCR, or COB$DISP_SCR_NO_ADV.
!
!
! FORMAL PARAMETERS:
!
!	UNIT.rl.v	integer unit number designating the device
!			on which the string(s) is(are) to be displayed.
!
!	STRING.rt.dx	address of 1st of up to 254 string descriptors
!			which are to concatenated and displayed on the
!			specified device.
!
! IMPLICIT INPUTS:
!
!	Status information as to whether the output file in question
!	is currently open.
!
! IMPLICIT OUTPUTS:
!
!	Updated status information for this file.
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	Outputs a record on the specified file.
!--
    BEGIN
    BUILTIN
	CALLG,
	AP;

    COB$$AB_USPCODE[1] = CRR;		! Upspace code is carriage return
    CALLG(.AP, COMMON_CODE_1);
    COB$$AB_PREV[0] = DISP;		! Prev. unit to become DISPLAY

    END;

GLOBAL ROUTINE COB$DISP_NO_ADV (
				UNIT,			! Unit # of output device
				STRING	 		! Input string
			       ) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Performs COBOL DISPLAY with NO ADVANCING statement given a unit number and
!	one or more strings to display.  If more than one string is
!	specified, these strings are concatenated into a single string
!	before being output.  The upspacing to be employed is a function
!	of this call (NO ADVANCING )and the upspacing used on a
!	previous call to this routine or to COB$DISPLAY or COB$DISP_SCR,
!	or COB$DISP_SCR_NO_ADV.
!
!
! FORMAL PARAMETERS:
!
!	UNIT.rl.v	integer unit number designating the device
!			on which the string(s) is(are) to be displayed.
!
!	STRING.rt.dx	address of 1st of up to 254 string descriptors
!			which are to concatenated and displayed on the
!			specified device.
!
! IMPLICIT INPUTS:
!
!	Status information as to whether the output file in question
!	is currently open.
!
! IMPLICIT OUTPUTS:
!
!	Updated status information for this file.
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	Outputs a record on the specified file.
!
!--
    BEGIN
    BUILTIN
	CALLG,
	AP;

    COB$$AB_USPCODE[1] = 0;			! Upspace code is 0
    CALLG(.AP, COMMON_CODE_1);
    COB$$AB_PREV[0] = DNA;			! Prev. unit to become DISPLAY_NO_ADV

    END;

GLOBAL ROUTINE COB$DISP_SCR (
				UNIT,	 	! Unit # of output device
				STRING,  	! Input string
				FLAGS		! Screen enhancement flag
			    ) : NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!
!
!	Performs COBOL DISPLAY statement with screen enhancements.
!	Given a unit number and one string to display using a flag that
!	contains selected enhancements. 
!	A call to COB$POS_ERASE is made by the VAX-11 COBOL Compiler
!	prior to the call to COB$DISP_SCR  to set cursor position and
!	perform any screen or line erasing.
!	The upspacing to be employed is a function of COB$POS_ERASE and
!	the upspacing used on a previous call to this routine or to
!	either COB$DISPLAY, COB$DISP_NO_ADV or COB$DISP_SCR_NO_ADV.
!
!
! FORMAL PARAMETERS:
!
!	UNIT.rl.v	integer unit number designating the device
!			on which the string is to be displayed.
!
!	STRING.rt.dx	address of string descriptor which is to be
!			displayed on the specified device.
!
!	FLAGS.rlu.v	screen enhancement flag;
!
!				bit 0  -  bold
!				bit 1  -  reverse
!				bit 2  -  blinking
!				bit 3  -  underline
!				bit 4  -  bell
!				bit 5  -  conversion
!				bit 6  -  decimal point is comma
!				bit 7  -  0 print sign, 1 do not print sign
!				bit 11 -  0 for VAX COBOL, 1 for VAX RPG
!					  
!
! IMPLICIT INPUTS:
!
!	Status information as to whether the output file in question
!	is currently open.
!
! IMPLICIT OUTPUTS:
!
!	Updated status information for this file.
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	Outputs a record on the specified file.
!--
    BEGIN
    BUILTIN
	CALLG,
	AP;

    COB$$AB_USPCODE[1] = CRR;		! Upspace code is carriage return
    CALLG(.AP, COMMON_SCREEN);		! Do common processing
    COB$$AB_PREV[0] = DISP ;		! Prev. unit to become DISPLAY

    END;				! end COB$DISP_SCR

GLOBAL ROUTINE COB$DISP_SCR_NO_ADV (
				    UNIT,	! Unit # of output device
				    STRING,     ! Input string
				    FLAGS	! Screen enhancement flag
				   ) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Performs COBOL DISPLAY NO ADVANCING statement with screen
!	enhancements.  Given a unit number and one string to display using 
!	a flag that contains selected enhancements. 
!	A call to COB$POS_ERASE is made by the VAX-11 COBOL Compiler
!	prior to the call to COB$DISP_SCR_NO_ADV to set cursor position
!	and perform any screen or line erasing.
!	The upspacing to be employed is a function of COB$POS_ERASE and
!	the upspacing used on a previous call to this routine or to
!	either COB$DISPLAY, COB$DISP_NO_ADV or COB$DISP_SCR.
!
!
! FORMAL PARAMETERS:
!
!	UNIT.rl.v	integer unit number designating the device
!			on which the string is to be displayed.
!
!	STRING.rt.dx	address of string descriptor which is to be
!			displayed on the specified device.
!
!	FLAGS.rlu.v	screen enhancement flag;
!				bit 0  -  bold
!				bit 1  -  reverse
!				bit 2  -  blinking
!				bit 3  -  underline
!				bit 4  -  bell
!				bit 5  -  conversion
!				bit 6  -  decimal point is comma
!				bit 7  -  0 print sign, 1 do not print sign
!				bit 11 -  0 for VAX COBOL, 1 for VAX RPG
!
!
! IMPLICIT INPUTS:
!
!	Status information as to whether the output file in question
!	is currently open.
!
! IMPLICIT OUTPUTS:
!
!	Updated status information for this file.
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	Outputs a record on the specified file.
!
!--
    BEGIN
    BUILTIN
	CALLG,
	AP;

    COB$$AB_USPCODE[1] = 0;		! Upspace code is 0
    CALLG(.AP, COMMON_SCREEN);		! Do common processing
    COB$$AB_PREV[0] = DNA;		! Prev. unit to become DISPLAY_NO_ADV

    END;				! end COB$DISP_SCR_NO_ADV

ROUTINE COMMON_CODE_1 (UNIT, STRING): NOVALUE =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Performs common part of DISPLAY and DISPLAY_NO_ADV processing.
!
!
! FORMAL PARAMETERS:
!
!	UNIT.rl.v	integer unit number designating the device
!			on which the string(s) is(are) to be displayed.
!
!	STRING.rt.dx	address of 1st of up to 254 string descriptors
!			which are to concatenated and displayed on the
!			specified device.
!
! IMPLICIT INPUTS:
!
!	Status information as to whether the output file in question
!	is currently open.
!
! IMPLICIT OUTPUTS:
!
!	Updated status information for this file.
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	Outputs a record on the specified file.
!--
    BEGIN
    BUILTIN
	ACTUALPARAMETER,
	ACTUALCOUNT;

    LOCAL
	TEMP:	VECTOR [COB$K_DIS_SIZE,BYTE],	! Temp buffer on stack
	COUNT,					! Total chars to output
	ADDR,					! Pointer into allocated storage
	STATUS,					! Status from LIB$GET_VM call
	DESC:	BLOCK [8,BYTE];			! Dynamically constructed desc.
						!  for concatenating strings


    ! If there is only one item to display, write directly from caller's buffer
    !
    IF ACTUALCOUNT() EQL 2
    THEN
	BEGIN
	COMMON_CODE(.UNIT, .STRING);		! Do common processing
	RETURN;
	END;


    ! Count total text to be displayed
    !
    COUNT = 0;
    INCR I FROM 2 TO ACTUALCOUNT() DO
	BEGIN
	COUNT = .COUNT + .BLOCK[ ACTUALPARAMETER(.I), DSC$W_LENGTH; , BYTE];
	END;


    ! Build a fixed string descriptor
    !
    DESC[DSC$W_LENGTH]  = 0;
    DESC[DSC$B_DTYPE]   = DSC$K_DTYPE_T;
    DESC[DSC$B_CLASS]   = DSC$K_CLASS_S;
    DESC[DSC$A_POINTER] = TEMP;			! Assume stack is used


    ! Concatenate the caller's string(s) into a single string.
    ! If there are more than "COB$K_DIS_SIZE" characters to be displayed,
    ! allocate heap storage -- else use the stack.
    !
    IF .COUNT GTR COB$K_DIS_SIZE
    THEN
	BEGIN
	!
	! Allocate space and store its address into descriptor
	!
	IF NOT (STATUS = LIB$GET_VM(COUNT, DESC[DSC$A_POINTER]))
	THEN
	    LIB$STOP(COB$_FAIGET_VM, 0, .STATUS);
	END;


    ADDR = .DESC[DSC$A_POINTER];

    INCR I FROM 2 TO ACTUALCOUNT() DO
	BEGIN
	LOCAL
	    PTR: REF BLOCK[,BYTE];
	PTR = ACTUALPARAMETER(.I);
	CH$MOVE(.PTR[DSC$W_LENGTH], .PTR[DSC$A_POINTER], .ADDR);
	ADDR = .ADDR + .PTR[DSC$W_LENGTH];
	END;

    DESC[DSC$W_LENGTH] = .ADDR - .DESC[DSC$A_POINTER];


    COMMON_CODE(.UNIT, DESC);		! Do common processing


    ! If we've been using heap storage, give it back
    !
    IF .COUNT GTR COB$K_DIS_SIZE
    THEN
	LIB$FREE_VM(COUNT, .DESC[DSC$A_POINTER]);

    END;

ROUTINE COMMON_CODE (UNIT, STRING): NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Performs processing which is common to both DISPLAY and
!	DISPLAY WITH NO ADVANCING.
!	consisting of:
!		Open unit if currently not open
!		Complete calculation of upspace code
!		Writes out the string
!
!
!
! FORMAL PARAMETERS:
!
!	UNIT.rl.v	integer unit number designating the device
!			on which the string(s) is(are) to be displayed.
!
!	STRING.rt.dx	address of descriptor for the concatenated
!			strings.
!
! IMPLICIT INPUTS:
!
!	Status information as to whether the output file in question
!	is currently open.
!
! IMPLICIT OUTPUTS:
!
!	Updated status information for this file.
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	Outputs a record on the specified file.
!
!--
    BEGIN
    MAP
	STRING:	REF BLOCK[8, BYTE];

    LOCAL
	FILE_NAME:	BLOCK [8,BYTE],		! dynamically constructed desc.
	RAB:		REF $RAB_DECL;

    LITERAL
	INIT_VALUE = 9 ;			! Initial COB$$AB_PREV value

    IF .UNIT GTRU COB$K_UNIT_MAX
    THEN
	LIB$STOP(COB$_INVARG);


    ! If file is not yet open, open it.
    !
    IF .COB$$AL_WRITE_RAB[.UNIT] EQL 0
    THEN
	!+
	!  Second parameter of 0 signifies that COB$$OPEN_OUT is called on
	!  behave of VAX COBOL.
	!-
	COB$$OPEN_OUT(.UNIT, 0);


    ! Calculate the upspacing codes needed to use on this action
    ! If previous operation was a DISPLAY, a line-feed is needed
    !
    COB$$AB_USPCODE[0] = 0;
    IF .COB$$AB_PREV[0] EQL DISP  OR  .COB$$AB_PREV[0] EQL POS  OR  .COB$$AB_PREV[0] EQL ACC_ADV
						OR  .COB$$AB_PREV[0] EQL INIT_VALUE
    THEN
	COB$$AB_USPCODE[0] = LINE_FEED;


    ! Write out the concatenated string
    !
    RAB = .COB$$AL_WRITE_RAB[.UNIT];
    RAB[RAB$L_RBF] = .STRING[DSC$A_POINTER];
    RAB[RAB$W_RSZ] = .STRING[DSC$W_LENGTH];


    ! Write the record.  Retry certain errors, signal others.
    !
    WHILE $PUT(RAB = .RAB) EQL RMS$_RSA DO $WAIT(RAB = .RAB);


    IF NOT .RAB[RAB$L_STS]
    THEN
	LIB$STOP(COB$_ERRDURDIS, 1, .RAB+RAB$C_BLN, .RAB[RAB$L_STS], .RAB[RAB$L_STV]);

    END;

GLOBAL ROUTINE COB$$OPEN_OUT (UNIT, RPG): NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Open a file for writing, given a unit number.
!
! FORMAL PARAMETERS:
!
!	UNIT.rl.v	integer unit number designating the device
!			on which the string(s) is(are) to be displayed.
!
!	RPG.rl.v	= 1 if COB$$OPEN_OUT called for VAX RPG
!			= 0 if COB$$OPEN_OUT called for VAX COBOL
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	Opens a file.  On error, Signals a fatal condition.
!
!--

    BEGIN
    LITERAL
	MAX_BUF =	MAX(64, NAM$C_MAXRSS);
    LOCAL
	FAB:		$FAB_DECL,
	NAM:		$NAM_DECL,
	RAB:		REF $RAB_DECL,
	FILE_NAME:	BLOCK[8, BYTE],		! Descriptor for the file name
	TRANSLATE:	BLOCK[8, BYTE],
	P:		REF VECTOR[,BYTE],
	RSLBUF:		VECTOR[MAX_BUF,BYTE],
	STATUS;


    ! Determine whether the COB$xxx name is defined.
    ! If so, use it.  If not, use the corresponding SYS$xxx name.
    !
    TRANSLATE[DSC$B_DTYPE]   = DSC$K_DTYPE_T;
    TRANSLATE[DSC$B_CLASS]   = DSC$K_CLASS_S;
    TRANSLATE[DSC$W_LENGTH]  = MAX_BUF;
    TRANSLATE[DSC$A_POINTER] = RSLBUF;

    !+
    !  If VAX RPG is calling this routine, bypass COB_TABLE.
    !-

    IF .RPG EQL 1
    THEN
	BEGIN					! Use the SYS$xxx logical
	P = .SYS_TABLE[.UNIT] + BASE;
	FILE_NAME[DSC$W_LENGTH] = .P[0];
	FILE_NAME[DSC$A_POINTER] = P[1];
	END
    ELSE
	BEGIN					! Use the COB$xxx logical
	P = .COB_TABLE[.UNIT] + BASE;
	FILE_NAME[DSC$B_DTYPE]   = DSC$K_DTYPE_T;	
	FILE_NAME[DSC$B_CLASS]   = DSC$K_CLASS_S;
	FILE_NAME[DSC$W_LENGTH]  = .P[0];
	FILE_NAME[DSC$A_POINTER] = P[1];
	IF $TRNLOG(LOGNAM = FILE_NAME, RSLBUF = TRANSLATE) NEQ SS$_NORMAL
	THEN
	    BEGIN				! Use the SYS$xxx logical
	    P = .SYS_TABLE[.UNIT] + BASE;
	    FILE_NAME[DSC$W_LENGTH] = .P[0];
	    FILE_NAME[DSC$A_POINTER] = P[1];
	    END;
	END ;


    $FAB_INIT(
	FAB = FAB,
	NAM = NAM,
	FAC = PUT,
	FNA = .FILE_NAME[DSC$A_POINTER],
	FNS = .FILE_NAME[DSC$W_LENGTH],
	RAT = PRN,
	FOP = SQO,
	RFM = VFC);

    $NAM_INIT(
	NAM = NAM,
	ESA = RSLBUF,
	ESS = NAM$C_MAXRSS,
	RSA = RSLBUF,
	RSS = NAM$C_MAXRSS);

    STATUS = $CREATE(FAB = FAB);
    IF (TRANSLATE[DSC$W_LENGTH] = .NAM[NAM$B_RSL]) EQL 0 THEN
    IF (TRANSLATE[DSC$W_LENGTH] = .NAM[NAM$B_ESL]) EQL 0
    THEN
	BEGIN
	TRANSLATE[DSC$W_LENGTH] = .FAB[FAB$B_FNS];
	TRANSLATE[DSC$A_POINTER]= .FAB[FAB$L_FNA];
	END;


    IF NOT .STATUS
    THEN
	LIB$STOP(COB$_ERRDURDIS, 1, TRANSLATE, .FAB[FAB$L_STS], .FAB[FAB$L_STV]);


    IF NOT (STATUS = LIB$GET_VM(%REF(RAB$C_BLN + 8 + .NAM[NAM$B_RSL]), RAB))
    THEN
	LIB$STOP(COB$_FAIGET_VM, 0, .STATUS);


    ! Save a descriptor for the resultant file name string,
    ! and the string itself, after the RAB
    !
    BEGIN
    LOCAL
	Q: REF BLOCK[,BYTE];
    Q = .RAB + RAB$C_BLN;
    Q[DSC$B_DTYPE]   = DSC$K_DTYPE_T;
    Q[DSC$B_CLASS]   = DSC$K_CLASS_S;
    Q[DSC$W_LENGTH]  = .TRANSLATE[DSC$W_LENGTH];
    Q[DSC$A_POINTER] = .RAB+RAB$C_BLN+8;
    CH$MOVE( .Q[DSC$W_LENGTH], .TRANSLATE[DSC$A_POINTER], .RAB+RAB$C_BLN+8 );
    END;


    $RAB_INIT(
	RAB = .RAB,
	FAB = FAB,
	ROP = EOF,
	RHB = COB$$AB_USPCODE);

    IF NOT $CONNECT(RAB = .RAB)
    THEN
	LIB$STOP(COB$_ERRDURDIS, 1, .RAB+RAB$C_BLN, .RAB[RAB$L_STS], .RAB[RAB$L_STV]);

    COB$$AL_WRITE_RAB[.UNIT] = .RAB;
    COB$$AW_WRITE_IFI[.UNIT] = .FAB[FAB$W_IFI];
    END;						! end of COB$$OPEN_OUT

ROUTINE COMMON_SCREEN (				! Common processing
		UNIT, 				! Unit # of output device
		STRING  :  REF BLOCK [8,BYTE],  ! Input string
		FLAGS				! Screen enhancement flag
		): NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Performs processing which is common to both COB$DISP_SCR and
!	COB$DISP_SCR_NO_ADV.
!	This includes :
!		Open unit if currently not open
!		Complete calculation of upspace code
!		Call conversion routine DISP_CONVERT
!		Call COB$$SETUP_TERM_TYPE
!		Call COB$$SET_ATTRIBUTES
!		Write out the string
!
!
! FORMAL PARAMETERS:
!
!	UNIT.rl.v	integer unit number designating the device
!			on which the string is to be displayed.
!
!	STRING.rt.dx	address of string descriptor which is to be
!			displayed on the specified device.
!
!	FLAGS.rlu.v	screen enhancement flag;
!
!				bit 0  -  bold
!				bit 1  -  reverse
!				bit 2  -  blinking
!				bit 3  -  underline
!				bit 4  -  bell
!				bit 5  -  conversion
!				bit 6  -  decimal point is comma
!				bit 7  -  0 print sign, 1 do not print sign
!				bit 11 -  0 for VAX COBOL, 1 for VAX RPG
!
! IMPLICIT INPUTS:
!
!	Status information as to whether the output file in question
!	is currently open.
!
! IMPLICIT OUTPUTS:
!
!	Updated status information for this file.
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	Outputs a record on the specified file.
!
!--
    BEGIN

    BUILTIN
	ACTUALPARAMETER,
	ACTUALCOUNT;

    LOCAL
	ANS_STRING  :  BLOCK [8,BYTE],		! Descriptor for output
	PUT_FLAG    :  INITIAL (0),		! Longword flag for $PUT
	FAB	    :  REF $FAB_DECL,		! Fab for output device
	RAB	    :  REF $RAB_DECL,		! Rab for output device
	OUT_BUF	    :  VECTOR [COB$K_ACC_SIZE,BYTE],  ! Buffer passed to
						      ! COB$$SET_ATTRIBUTES
	OUT_LEN	    :  INITIAL (0) ;		! Passed to COB$$SET_ATTRIBUTES

    LITERAL
	INIT_VALUE = 9 ;			! Initial COB$$AB_PREV value

    !+
    ! There should be no more than 3 parameters
    !-

    IF ACTUALCOUNT() GTR 3
    THEN
	LIB$STOP(COB$_INVARG);

    IF .UNIT GTRU COB$K_UNIT_MAX
    THEN
	LIB$STOP(COB$_INVARG);

    !+
    ! If file is not yet open, open it.
    !-

    IF .COB$$AL_WRITE_RAB[.UNIT] EQL 0
    THEN
	!+
	!  Second parameter tells COB$$OPEN_OUT whether VAX COBOL (0)
	!  or VAX RPG (1) is the caller.
	!-
	COB$$OPEN_OUT ( .UNIT,
			IF ( .FLAGS AND V_COB_RPG ) NEQ 0
			THEN 1
			ELSE 0 ) ;
    !+
    ! Calculate the upspacing codes we need to use on this action.
    ! If previous operation was a DISPLAY (COB$DISPLAY or COB$DISP_SCR),
    ! a line-feed is needed.
    !-

    COB$$AB_USPCODE[0] = 0;
    IF .COB$$AB_PREV[0] EQL DISP  OR  .COB$$AB_PREV[0] EQL POS  OR  .COB$$AB_PREV[0] EQL ACC_ADV
						OR  .COB$$AB_PREV[0] EQL INIT_VALUE
    THEN
	COB$$AB_USPCODE[0] = LINE_FEED;

    !+
    !  Create descriptor ANS_STRING.  All TYPEs and CLASSes of input
    !  string descriptors will eventually be deposited (through conversion
    !  and parsing) into ANS_STRING for output.
    !  Because STR$COPY_R is used there is no need to allocate and
    !  deallocate space for ANS_STRING as STR$COPY_R will do this.
    !-

    ANS_STRING [DSC$W_LENGTH]  = 0 ;
    ANS_STRING [DSC$B_DTYPE]   = DSC$K_DTYPE_T ;
    ANS_STRING [DSC$B_CLASS]   = DSC$K_CLASS_D ;
    ANS_STRING [DSC$A_POINTER] = 0 ;

    !+
    !  Check FLAGS parameter.  If conversion requested (bit 5),
    !  call routine to convert and parse the various data types.
    !  Convert all data types to Text.
    !-	

    IF ( .FLAGS AND V_CONV ) NEQ 0
    THEN DISP_CONVERT ( .STRING, .FLAGS, ANS_STRING )

    !+
    !  This will handle TEXT without CONVERSION and anything else
    !  without conversion.
    !  Note - if user does not request conversion for any data type,
    !  the string will be output as is (same results as old DISPLAY).
    !-

    ELSE
	IF NOT (STR$COPY_R ( ANS_STRING, STRING[DSC$W_LENGTH],
						 .STRING [DSC$A_POINTER] ))
	THEN LIB$STOP (COB$_ERRDURDIS) ;

    !+
    !  Conversion and Parsing completed (if requested) - Display string.
    !  Break down FLAGS parameter to a valid parameter for $PUT.  
    !  (ie. the first four bits (0-3) of FLAGS parameter are passed to $PUT)
    !  Determine whether or not to ring terminal bell (bit 4).
    !-

    PUT_FLAG  = .FLAGS AND FLAG_MASK ;
    IF ( .FLAGS AND V_BELL ) NEQ 0
    THEN
	BEGIN
	OUT_BUF[0] = BELL ; 
	OUT_LEN    = .OUT_LEN + 1 ;
	END ;

    !+
    !  Request for bold, reverse, blinking, underline, or any combination 
    !  thereof.  It is first necessary to determine terminal type.
    !  COB$$SETUP_TERM_TYPE puts this information in COB$TERM_TYPE.
    !  Call COB$$SET_ATTRIBUTES to turn on requested terminal attributes.
    !  After call OUT_BUF contains concatenation of -
    !		bell sequence, if requested
    !		escape sequence to turn on attributes,
    !		final form of input string to be displayed, and
    !		escape sequence to turn off attributes.
    !  OUT_LEN is updated in COB$$SET_ATTRIBUTES.
    !  COB$$SET_ATTRIBUTES is called even if no terminal attributes
    !  are requested to copy ANS_STRING to OUT_BUF.
    !-

    RAB = .COB$$AL_WRITE_RAB [.UNIT];
    IF .COB$TERM_TYPE EQL 0				!  If terminal type not
    THEN						!  yet determined
	BEGIN 
	LOCAL
	    NAM_DSC : REF BLOCK [,BYTE] ;		!  Name dsc (from
							!  COB$$OPEN_OUT)
	NAM_DSC = .RAB + RAB$C_BLN ;
	IF NOT ( COB$$SETUP_TERM_TYPE ( .NAM_DSC [DSC$A_POINTER],
					.NAM_DSC [DSC$W_LENGTH],
					COB$TERM_TYPE ) )
	THEN LIB$STOP (COB$_ERRDURDIS) ;

	IF .COB$TERM_TYPE EQL UNKNOWN
	THEN
	    COB$TERM_TYPE = VT100;		! treat file as VT100
	
	END ;

    IF NOT ( COB$$SET_ATTRIBUTES ( .COB$TERM_TYPE, .ANS_STRING [DSC$A_POINTER],
				   .ANS_STRING [DSC$W_LENGTH], .PUT_FLAG,
				   OUT_BUF[0], OUT_LEN ) )
    THEN LIB$STOP (COB$_ERRDURDIS) ;

    !+
    !  Put OUT_BUF in RAB
    !-

    RAB [RAB$L_RBF] = OUT_BUF [0] ;
    RAB [RAB$W_RSZ] = .OUT_LEN ;

    !+
    !  Display the final form of the original input string.
    !-

    WHILE $PUT(RAB = .RAB) EQL RMS$_RSA DO $WAIT(RAB = .RAB) ;

    IF NOT .RAB [RAB$L_STS]
    THEN
	 LIB$STOP (COB$_ERRDURDIS, 1, .RAB+RAB$C_BLN, .RAB[RAB$L_STS], 
				.RAB[RAB$L_STV]) ;

    END ;					! end COMMON_SCREEN

ROUTINE DISP_CONVERT (				! Convert all data types to Text
	STRING      :  REF $STR$DESCRIPTOR,	! Input string
	FLAGS,					! Screen enhancement flag
	ANS_STRING  :  REF $STR$DESCRIPTOR	! Final form of string for output
    ) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Convert the various VAX-11 COBOL data types to Text for output.
!	Call DISP_PARSE to add the final touches.
!
!
! FORMAL PARAMETERS:
!
!	STRING.rt.dx	address of input string descriptor
!
!	FLAGS.rlu.v	screen enhancement flag (not used in this routine
!						 but passed to DISP_PARSE) 
!				bit 0  -  bold
!				bit 1  -  reverse
!				bit 2  -  blinking
!				bit 3  -  underline
!				bit 4  -  bell
!				bit 5  -  conversion
!				bit 6  -  decimal point is comma
!				bit 7  -  0 print sign, 1 do not print sign
!				bit 11 -  0 for VAX COBOL, 1 for VAX RPG
!
!	ANS_STRING.wt.dx  address of descriptor to hold final form of
!			  string to be displayed on specified device
!
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	Updated status information.
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	Converts all VAX-11 COBOL data types to TEXT.
!--

    BEGIN

    EXTERNAL
	LIB$AB_CVTTP_O,		! for CVTTP
	LIB$AB_CVTTP_U,		! for CH$TRANSLATE
	LIB$AB_CVT_O_U ;	! for CVTTP after CH$TRANSLATE

    BUILTIN
	CVTTP,
	CVTPS,
	CVTLP ;

    LOCAL
	TEMP_DESC :  BLOCK [12,BYTE] INITIAL (0) VOLATILE,
						! Local temporary descriptor
	TEMP	  :  VECTOR [10,BYTE],		! Must hold up to 18 packed digits
	TEMP_LEN  :  INITIAL (0),		! Length of temporary desc
	RES_DESC  :  BLOCK [12,BYTE] INITIAL (0) VOLATILE,
						! Local temporary descriptor
	RES       :  VECTOR [23,BYTE],		! Must hold up to 23 digits 
						! for double floating
	TEMP_BUF  :  VECTOR [8,BYTE],		! Needed for CH$TRANSLATE to reshuffle
	STRING_BUF:  REF VECTOR [8,BYTE],	! Needed for DSC$K_DTYPE_NLO
						! conversion
	SIGN    	:  INITIAL (0),		! Hold sign for DSC$K_DTYPE_NLO
	WORD_TO_LONG    :  INITIAL (0),		! Needed for CVTWL
	STR_LEN   	:  WORD INITIAL (0),	! Used by STR$COPY_R
	LOOK_FOR_SIGN   :  INITIAL (0), 	! = 1 if data type requires sign
	EXPONENT,				! Scale of string to be converted
	DIGITS		:  INITIAL (0),		! Number of digits in a COMP data item
	CHECK_COMP	:  INITIAL (0),		! TRUNC / NOTRUNC
	COMP_SCALE	:  INITIAL (0),		! TRUNC / NOTRUNC
	PASS_RES  	:  INITIAL (0),		! Flag for DISP_PARSE call
	ITS_TEXT  	:  INITIAL (0) ;	! Flag, if = 1 no need to call
						! DISP_PARSE
    LITERAL
	F_SIZE    = 7,		! Needed for call to COB$CNVOUT in DISP_CONVERT
	D_SIZE    = 16,		! Needed for call to COB$CNVOUT in DISP_CONVERT
	OVERPUNCH_NEG_ZERO      = %X'7D',	!  Representation of overpunch -0
	LOW_OVERPUNCH_NEG_SIGN  = %X'4A',	!  Representation of overpunch -1
	HIGH_OVERPUNCH_NEG_SIGN = %X'52' ;	!  Representation of overpunch -9

    !+
    !  Create local descriptors - TEMP_DESC and RES_DESC.
    !  STR$GET1_DX and STR$FREE1_DX are not used in this routine
    !  because we are dealing with CLASSes other than Dynamic
    !-

    TEMP_DESC [DSC$W_LENGTH]  = .STRING [DSC$W_LENGTH] ;
    TEMP_DESC [DSC$B_DTYPE]   = DSC$K_DTYPE_P ;
    TEMP_DESC [DSC$B_CLASS]   = DSC$K_CLASS_SD ;
    TEMP_DESC [DSC$A_POINTER] = TEMP[0] ;
    TEMP_LEN = .STRING[DSC$W_LENGTH] ;

    RES_DESC [DSC$W_LENGTH]  = .STRING [DSC$W_LENGTH] ;
    RES_DESC [DSC$B_DTYPE]   = DSC$K_DTYPE_NL ;
    RES_DESC [DSC$B_CLASS]   = DSC$K_CLASS_SD ;
    RES_DESC [DSC$A_POINTER] = RES[0] ;

    IF .STRING [DSC$B_CLASS] EQL DSC$K_CLASS_SD
    THEN
	BEGIN

	TEMP_DESC [DSC$B_SCALE]   = .STRING [DSC$B_SCALE] ;
	TEMP_DESC [DSC$B_DIGITS]  = .STRING [DSC$B_DIGITS] ;
	RES_DESC [DSC$B_SCALE]   = .STRING [DSC$B_SCALE] ;
	RES_DESC [DSC$B_DIGITS]  = .STRING [DSC$B_DIGITS] ;

	END;

    !+
    !  Get EXPONENT, if class is DSC$K_CLASS_SD, to pass to DISP_PARSE
    !-

    EXPONENT = ( IF .STRING [DSC$B_CLASS] EQL DSC$K_CLASS_SD
   		 THEN .STRING [DSC$B_SCALE]
		 ELSE 0 ) ;

    !+
    !  Select DATA TYPE of string to be converted and perform the
    !  necessary conversions.
    !  Object of conversion is to fold all data types to Text.
    !
    !  Values :
    !
    !  	Although this routine converts all the various data types to TEXT,
    !   it is necessary to remember what the original data types were.
    !   This information is stored in LOOK_FOR_SIGN (with data types grouped
    !   together when possible) to be used by routine DISP_PARSE in deciding
    !   whether a plus sign, minus sign, or space is to be output.
    !
    !	LOOK_FOR_SIGN = 0 	No sign insertion
    !	LOOK_FOR_SIGN = 1 	Sign is part of string (leading)
    !   LOOK_FOR_SIGN = 2       Trailing sign
    !	LOOK_FOR_SIGN = 3	Pos overpunch sign, COMP data types (word,
    !				longword, and quadword), and Packed data type
    !	LOOK_FOR_SIGN = 4 	'-' sign insertion
    !				DSC$K_DTYPE_NLO	case where minus sign 'gets
    !				lost' in conversion.	
    !
    !   PASS_RES = 0		Pass STRING to DISP_PARSE
    !   PASS_RES = 1		Pass RES_DESC to DISP_PARSE
    !
    !   ITS_TEXT = 0		Call DISP_PARSE
    !   ITS_TEXT = 1		No need to call DISP_PARSE
    !-

    CASE .STRING [DSC$B_DTYPE] FROM DSC$K_DTYPE_WU TO DSC$K_DTYPE_P OF
	SET

	    [DSC$K_DTYPE_NU] :			!  Unsigned numeric

		LOOK_FOR_SIGN = 0 ;

	    [DSC$K_DTYPE_NL] :			!  Left separate sign

		LOOK_FOR_SIGN = 1 ;

	    [DSC$K_DTYPE_NR] :			!  Right separate sign

		!+
		!  EXPONENT is adjusted because of trailing sign that is
		!  included in the string.
		!-

		BEGIN
		IF .EXPONENT LSS 0
		THEN
		    EXPONENT = .EXPONENT - 1 ;
		LOOK_FOR_SIGN = 2 ;
		END ;

	    [DSC$K_DTYPE_NRO] :			!  Right overpunch sign

		BEGIN
		CVTTP ( STRING[DSC$W_LENGTH], .STRING[DSC$A_POINTER],
			LIB$AB_CVTTP_O, TEMP_LEN, TEMP );

		CVTPS ( TEMP_LEN, TEMP, TEMP_LEN, RES );

		LOOK_FOR_SIGN = 3 ;
		PASS_RES = 1 ;
		END ;

	     [DSC$K_DTYPE_NLO] :		!  Left overpunch sign

		BEGIN

		LOOK_FOR_SIGN = 3 ;

		!+
		!  CH$TRANSLATE loses '-' sign.
		!  Read sign before performing CH$TRANSLATE.  If a minus
		!  sign was part of the original string, preserve it through
		!  LOOK_FOR_SIGN.  DISP_PARSE will insert the lost minus sign
		!  in the final form of the string.
		!  Note :  a plus sign is not lost, plus sign is always given
		!  by CH$TRANSLATE regardless of the original sign.
		!-

		STRING_BUF = .STRING[DSC$A_POINTER] ;
		SIGN	   = .STRING_BUF[0] ;
		IF .SIGN GEQ  LOW_OVERPUNCH_NEG_SIGN  AND  !  If between -1
		   .SIGN LEQ HIGH_OVERPUNCH_NEG_SIGN	   !  and -9 then
		THEN					   !  preserve neg sign
		    LOOK_FOR_SIGN = 4
		ELSE
		    IF .SIGN EQL OVERPUNCH_NEG_ZERO	   !  If -0 then
		THEN					   !  preserve neg sign
		    LOOK_FOR_SIGN = 4 ;
 

		CH$TRANSLATE ( LIB$AB_CVT_O_U, .STRING[DSC$W_LENGTH],
			.STRING[DSC$A_POINTER], 0,
			.STRING[DSC$W_LENGTH], TEMP_BUF[0] );

		CVTTP ( STRING[DSC$W_LENGTH], TEMP_BUF[0],
			LIB$AB_CVTTP_U, TEMP_LEN, TEMP );

		CVTPS ( TEMP_LEN, TEMP, TEMP_LEN, RES );

		PASS_RES = 1 ;
		END ;

	    [DSC$K_DTYPE_P] :			!  Packed decimal

		BEGIN
		CVTPS ( STRING[DSC$W_LENGTH], .STRING[DSC$A_POINTER],
			STRING[DSC$W_LENGTH], RES );

		LOOK_FOR_SIGN = 3 ;
		PASS_RES = 1 ;
		CHECK_COMP = 2 ;
		END ;

	    [DSC$K_DTYPE_W, DSC$K_DTYPE_WU] :	!  Signed and unsigned word
!
!*** NOTE:  For COMP data items (WORD, LONGWORD, QUADWORD), VAX-11 COBOL
!		is passing an SD decriptor for both the S and SD class.
! 
		BEGIN

		!+
		!  Although 4 is the maximum number of digits in a VAX-11
		!  COBOL Word Integer, a length of 9 is used because conversion
		!  is actually from Longword to Packed.  Need the number of
		!  digits possible in Longword.
		!  Suppression of leading zeros will be necessary  (done in
		!  DISP_PARSE).
		!-

		TEMP_LEN = 9 ;
		RES_DESC [DSC$W_LENGTH] = 9 ;
		WORD_TO_LONG = .BLOCK[.STRING[DSC$A_POINTER],0,0,16,1;,BYTE] ;

		CVTLP ( WORD_TO_LONG , TEMP_LEN, TEMP ) ;
		CVTPS ( TEMP_LEN, TEMP, TEMP_LEN, RES );

		LOOK_FOR_SIGN = 3 ;
		PASS_RES = 1 ;
		!+
		! Read number digits in COMP data item to pass to DISP_PARSE.
		! .STRING [DSC$W_LENGTH] is always 2 for WORDs.
		! Number of digits is between 1 and 4 for WORDs.
		! If DIS$K_CLASS_S -> During the conversion process the WORD
		! data type was first converted to a LONGWORD.  This introduced
		! five 'extra' preceding zeroes which will be disgarded by
		! DISP_PARSE.
		!-
		CHECK_COMP = 1 ;
		IF .STRING[DSC$B_CLASS] EQL DSC$K_CLASS_SD
		THEN
		    BEGIN
		    DIGITS = .STRING[DSC$B_DIGITS] ;
		    COMP_SCALE = .STRING[DSC$B_SCALE] ;
		    END
		ELSE
		    DIGITS = -1 ;
		END ;

	    [DSC$K_DTYPE_L, DSC$K_DTYPE_LU] :	!  Signed and unsigned longword
						
		BEGIN

		!+
		!  9 is the maximum number of digits in a VAX-11 COBOL 
		!  Longword Integer.
		!  Suppression of leading zeros will be necessary if length
		!  of input string is less than 9 (done in DISP_PARSE).
		!-

		TEMP_LEN = 9 ;
		RES_DESC [DSC$W_LENGTH] = 9 ;

		CVTLP ( .STRING[DSC$A_POINTER], TEMP_LEN, TEMP ) ;
		CVTPS ( TEMP_LEN, TEMP, TEMP_LEN, RES );

		LOOK_FOR_SIGN = 3 ;
		PASS_RES = 1 ;
		!+
		! Read number digits in COMP data item to pass to DISP_PARSE.
		! .STRING [DSC$W_LENGTH] is always 4 for LONGWORDs.
		! Number of digits is between 5 and 9 for LONGWORDs.
		!-
		CHECK_COMP = 1 ;
		IF .STRING[DSC$B_CLASS] EQL DSC$K_CLASS_SD
		THEN
		    BEGIN
		    DIGITS = .STRING[DSC$B_DIGITS] ;
		    COMP_SCALE = .STRING[DSC$B_SCALE] ;
		    END
		ELSE
		    DIGITS = 0 ;

		END ;

	    [DSC$K_DTYPE_QU, DSC$K_DTYPE_Q] :	!  Signed and unsigned quadword
							
		BEGIN

		!+
		!  18 is the maximum number of digits in a VAX-11 COBOL
		!  Quadword Integer.
		!  Suppression of leading zeros will be necessary if length
		!  of input string is less than 18 (done in DISP_PARSE).
		!-

		TEMP_LEN = 18 ;
		RES_DESC [DSC$W_LENGTH] = 18 ;
		(COB$CVTQP_R9 (0,.STRING[DSC$A_POINTER],.TEMP_LEN,TEMP)) ;
		CVTPS ( TEMP_LEN, TEMP, TEMP_LEN, RES );

		LOOK_FOR_SIGN = 3 ;
		PASS_RES = 1 ;
		!+
		! Read number digits in COMP data item to pass to DISP_PARSE.
		! .STRING [DSC$W_LENGTH] is always 8 for QUADWORDs.
		! Number of digits is between 10 and 18 for QUADWORDs.
		!-
		CHECK_COMP = 1 ;
		IF .STRING[DSC$B_CLASS] EQL DSC$K_CLASS_SD
		THEN
		    BEGIN
		    DIGITS = .STRING[DSC$B_DIGITS] ;
		    COMP_SCALE = .STRING[DSC$B_SCALE] ;
		    END
		ELSE
		    DIGITS = 0 ;

		END ;

	    [DSC$K_DTYPE_F] :			!  Floating point

		BEGIN

		!+
		!  14 is the length of the E-Notation format that is used
		!  for the Floating Point data type.
		!  ( E_Notarion representation of -1 is   -0.1000000E+01 )
		!  STR$COPY_R is done here because DISP_PARSE will not be called
		!-

		RES_DESC [DSC$W_LENGTH] = 14 ;
		STR_LEN = 14 ;
		IF NOT ( COB$CNVOUT (.STRING[DSC$A_POINTER], RES_DESC, F_SIZE))
		THEN
		    LIB$STOP (COB$_ERRDURDIS) ;
		IF NOT ( STR$COPY_R ( .ANS_STRING, STR_LEN,
						.RES_DESC [DSC$A_POINTER] ) )
		THEN
		    LIB$STOP (COB$_ERRDURDIS) ;
		!+
		!  Change the result 0.1110000E+03, to 1.110000E+02
		!-
		ADJUST_FL_PT ;
		ITS_TEXT = 1 ;
		END ;

	    [DSC$K_DTYPE_D] :			!  Double floating point

		BEGIN

		!+
		!  23 is the length of the E-Notation format that is used
		!  for the Double Floating Point data type.
		!  ( E_Not representation of -1 is   -0.1000000000000000E+01 )
		!  STR$COPY_R is done here because DISP_PARSE will not be called
		!-

 		RES_DESC [DSC$W_LENGTH] = 23 ;
		STR_LEN = 23 ;
		IF NOT ( COB$CNVOUT ( .STRING[DSC$A_POINTER], RES_DESC, D_SIZE))
		THEN
		    LIB$STOP (COB$_ERRDURDIS) ;
		IF NOT ( STR$COPY_R ( .ANS_STRING, STR_LEN,
						.RES_DESC [DSC$A_POINTER] ) )
		THEN
		    LIB$STOP (COB$_ERRDURDIS) ;
		!+
		!  Change the result 0.1234567890123456E-07 to
		!  1.234567890123456E-08 to
		!-
		ADJUST_FL_PT ;
		ITS_TEXT = 1 ;
		END ;

	    [DSC$K_DTYPE_T] :			!  Text

		BEGIN

		!+
		!  User requested conversion of a TEXT string.  Empty request,
		!  no harm done - don't call DISP_PARSE,
		!  STR$COPY_R is done here.
		!-

		STR_LEN = .STRING [DSC$W_LENGTH] ;
		IF NOT ( STR$COPY_R ( .ANS_STRING, STR_LEN,
					.STRING [DSC$A_POINTER] ) )
		THEN
		    LIB$STOP (COB$_ERRDURDIS) ;
		ITS_TEXT = 1 ;
		END ;


	    [INRANGE, OUTRANGE] :
		LIB$STOP(COB$_INVARG) ;
	TES ;

    !+
    !  Call routine to parse the converted string and put it in acceptable
    !  form for the call to $PUT in COMMON_SCREEN.
    !  DISP_PARSE will
    !		insert sign
    !		insert decimal point or comma
    !		suppress leading zeroes
    !		copy final form of input string to ANS_STRING
    !-

    IF .ITS_TEXT EQL 0
    THEN
	BEGIN
		LOCAL
		YES_ZERO : INITIAL (0) ;

		IF (.STRING[DSC$B_CLASS] EQL DSC$K_CLASS_S)
		THEN
		    YES_ZERO = 1
		ELSE 
		     BEGIN
		     YES_ZERO = .STRING[DSC$B_DIGITS] + .STRING[DSC$B_SCALE] ;
		     IF .YES_ZERO  NEQ 0
		     THEN
			YES_ZERO = 1 ;
		     END ;

	DISP_PARSE (( IF .PASS_RES
		      THEN RES_DESC
		      ELSE .STRING ) ,

		     .FLAGS, .LOOK_FOR_SIGN, .EXPONENT, .DIGITS, .ANS_STRING,
			.YES_ZERO, .COMP_SCALE, .CHECK_COMP ) ;
	END ;

    END ;					! End DISP_CONVERT

ROUTINE DISP_PARSE (				! Put together a number
	STRING	    : REF BLOCK [12, BYTE],	! Input string, result of conversion
	FLAGS,					! Screen enhancement flag
	LOOK_FOR_SIGN,				! Flag for sign insertion
	EXPONENT,				! Decimal exponent
	DIGITS,					! Number of digits in COMP data items
	ANS_STRING  : REF BLOCK [12, BYTE],	! Holds final form of string
						! for output
	YES_ZERO,				! =1 Print the 0 before the dec pt
	COMP_SCALE,				! Scale of Comp data item
	CHECK_COMP				! TRUNC / NOTRUNC issue with COMP
						! Make sure that no more digits
						! are Displayed than the number
	) : NOVALUE =				! in the PIC of the Comp data item

!++
! FUNCTIONAL DESCRIPTION:
!
!	Put string in final form for output -
!		insert sign
!		insert decimal point or comma
!		suppress leading zeroes
!		copy final form of input string to ANS_STRING
!
!
! FORMAL PARAMETERS:
!
!	STRING.rt.dx	address of input string descriptor
!
!	FLAGS.rlu.v	screen enhancement flag
!
!				bit 0  -  bold
!				bit 1  -  reverse
!				bit 2  -  blinking
!				bit 3  -  underline
!				bit 4  -  bell
!				bit 5  -  conversion
!				bit 6  -  decimal point is comma
!				bit 7  -  0 print sign, 1 do not print sign
!				bit 11 -  0 for VAX COBOL, 1 for VAX RPG
!
!	LOOK_FOR_SIGN.rlu.v   flag set in DISP_CONVERT to aid in sign insertion
!			       and parameter list for call to DISP_PARSE.
!
!				0   No sign insertion
!				1   Sign is part of string (leading)
!				2   Trailing sign
!				3   Pos overpunch sign, COMP data types (word,
!				    longword, and quadword) and packed data type
!				4   minus sign must be inserted (DSC$DTYPE_NLO
!				    case)
!
!	EXPONENT.rlu.v	  Decimal exponent - signed power of ten from DSC$B_SCALE 
!			  used to convert internal to external form
!
!	DIGITS.rl.v	  Number of digits in a VAX-11 COBOL COMP data item,
!			  Word, Longword and Quadword.
!
!	ANS_STRING.wt.dx  address of descriptor to hold final form of
!			  string to be displayed on specified device
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	Status updated for STR$COPY_R
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	Copy the final form of the string to ANS_STRING.
!--

    BEGIN

    LOCAL
	BUF_DESC   :  BLOCK [8, BYTE] VOLATILE,	! Local temporary buffer
	BUF 	   :  REF VECTOR [65535, BYTE],	! Addresses temp buffer BUF_DESC
	PUTTER	   :  INITIAL (0),		! Counter for BUF
	STRING_BUF :  REF VECTOR [65535, BYTE],	! Addresses STRING
	STRING_LEN :  WORD,			! Length of STRING
	HIGH_POS,				! Max power of ten in result
	LOW_POS,				! Min power of ten in result
	SIGN_STR   :  BYTE INITIAL (BYTE(0)),	! Temp to hold sign of string
	FIRST_GOOD :  INITIAL (0),		! Used for leading zero suppression,
						! signals first non-zero signigicant
						! digit was encountered.
	ZERO_OK	   :  INITIAL (0),		! Used for leading zero suppression,
						! signals that the only 'ok' leading
						! zero is the zero in front of the
						! decimal point if the # is a fraction.
	DOT_HERE   :  INITIAL (0),
	EXTRA  	   :  WORD INITIAL (0),		! # of extra leading zeroes in a
						! COMP data item that resulted
						! from the conversion process.
	PULL	   :  WORD INITIAL (0),		! Keeps track of the # of leading
						! zeroes pulled from STRING.
	MINUS	   :  INITIAL (0) ;		! Signals that a minus sign is
						! to be inserted

    BIND
	ZERO = UPLIT ('0') ;

    !+
    !  Enable a handler to free the local string in case of error.
    !-

    ENABLE
	COB$$FREE_STRINGS (BUF_DESC);

    !+
    !  Create local descriptor BUF_DESC.  Allocate enough space to hold the
    !  digits, a leading sign (or space), and an imbedded decimal point (or
    !  comma).
    !  Calculate limits for loop that reads digits.
    !-

    STRING_LEN = .STRING [DSC$W_LENGTH];
    STRING_BUF = .STRING [DSC$A_POINTER];

    BUF_DESC [DSC$W_LENGTH]  = 0;
    BUF_DESC [DSC$B_DTYPE]   = DSC$K_DTYPE_T;
    BUF_DESC [DSC$B_CLASS]   = DSC$K_CLASS_D;
    BUF_DESC [DSC$A_POINTER] = 0;

    !+
    !  Calculate limits for loop that reads digits.
    !-

    HIGH_POS = MAX (.STRING_LEN + .EXPONENT - 1, -1);
    LOW_POS = MIN (.EXPONENT, 0);

    !+
    ! If the resultant number has too many digits to be represented on
    ! VAX, give an error message.
    !-

    IF ((.HIGH_POS - .LOW_POS + 3) GTR 65535)
    THEN
	LIB$STOP (COB$_INVARG) ;

    !+
    !  Allocate space for local string.
    !  STR$COPY_R allocates space for ANS_STRING but not for BUF_DESC.
    !-

    IF NOT ( STR$GET1_DX (%REF (.HIGH_POS - .LOW_POS + 3), BUF_DESC) )
    THEN
	LIB$STOP (COB$_ERRDURDIS) ;
    BUF = .BUF_DESC [DSC$A_POINTER];

    !+
    !  Calculate number of extra leading zreoes introduced in DISP_CONVERT
    !  that were not part of the original input string passed to COB$DISPLAY.
    !-

    IF .DIGITS EQL -1
    THEN
	EXTRA = 5 ;
    IF .DIGITS GTR 0
    THEN 
	EXTRA = .STRING_LEN - .DIGITS ;

    !+
    !  Read sign, put either '+', '-', or space into BUF, incr PUTTER
    !  (Can't read trailing sign yet)
    !-

    IF .LOOK_FOR_SIGN EQL 1  OR  .LOOK_FOR_SIGN EQL 3
    THEN

	!+
	!  These data types will not output a '+' if the number was positive,
	!  a space will be output instead.
	!-

	BEGIN

	LOCAL
	    P_IND : INITIAL (0);	! Equals 1 if string has P in picture

	IF .STRING [DSC$B_CLASS] EQL DSC$K_CLASS_SD
	THEN
	    IF (P_IND = ABS(.STRING [DSC$B_SCALE]) GTR .STRING [DSC$B_DIGITS]) 
	    THEN
	    	!+
	    	! Strings with Ps in the picture have the sign in STRING_BUF[0].
		! Replace sign with zero so there won't be a double sign in
		! the result.
	    	!-
		BEGIN

	    	SIGN_STR = .STRING_BUF [0] ;
		CH$MOVE (1, ZERO, STRING_BUF [0]);

		END
	    ELSE
	    	SIGN_STR = .STRING_BUF [(.EXPONENT + .STRING_LEN - 1) - .HIGH_POS] 
	ELSE
	    SIGN_STR = .STRING_BUF [(.EXPONENT + .STRING_LEN - 1) - .HIGH_POS] ;

	!+
	!  If no sign in original input string, insert a space before
	!  the number.
	!  Do not output the plus sign if present - output a
	!  space instead.  Minus sign will be inserted IMMEDIATELY before the
	!  first significant digit   ( bb-12.3 not -bb12.3 ).   For now,
	!  put a space in BUF as a place holder, take care of sign
	!  insertion later.
	!-
	BUF [.PUTTER] = %C' ' ;
	PUTTER   = .PUTTER + 1 ;

	!+
	! A minus sign is always included for output.  Signal through
	! MINUS = 1 that a minus sign is to be inserted in BUF.
  	!-
	IF .SIGN_STR EQL %C'+' OR .SIGN_STR EQL %C'-'
	THEN 
	    BEGIN

	    IF .SIGN_STR EQL %C'-'
	    THEN
		MINUS = 1 ;
	    IF (.LOOK_FOR_SIGN EQL 1) AND (NOT (.P_IND))
	    THEN 
		HIGH_POS = .HIGH_POS - 1 ;

	    END ;

	END;

    !+
    !  Case where minus sign was lost in routine DISP_CONVERT - signal through
    !  MINUS = 1 that a minus sign is to be inserted in BUF.  Minus sign will
    !  be inserted IMMEDIATELY before the first significant digit  ( bb-12.3
    !  not -bb12.3 ).  For now, put a space in BUF as a place holder, take
    !  care of sign insertion later, incr PUTTER.
    !-
    IF .LOOK_FOR_SIGN EQL 4
    THEN
	BEGIN

	MINUS = 1 ;
	SIGN_STR = %C'-' ;
	BUF [.PUTTER] = %C' ' ;
	PUTTER = .PUTTER + 1 ;

	END ;

    !+
    ! Must create a dummy string for strings with picture of the form
    ! 9(x)P(x).  The reason for this is that what is in STRING does not 
    ! reflect the placeholders at all and therefore the code that puts 
    ! the result in BUF does not work properly.  
    ! NOTE: NEW_DIGITS
    !-
    IF (.STRING [DSC$B_CLASS] EQL DSC$K_CLASS_SD) AND (.DIGITS EQL 0)
    THEN IF .STRING [DSC$B_SCALE] GTR 0
    THEN
	BEGIN
	!+
	! Picture is of the form 9(x)P(x).
	!-
	LOCAL
	    DUMMY :	BLOCK [8,BYTE],	! Dummy string which will have placeholders in it
	    DUM_STR : VECTOR [20,BYTE],	! Must hold up to 18 numeric string 
					!  digits - also making room for sign
					!  and decimal point
	    NUM_CHARS;

    	DUMMY [DSC$W_LENGTH]  = 20;
    	DUMMY [DSC$B_DTYPE]   = DSC$K_DTYPE_T;
    	DUMMY [DSC$B_CLASS]   = DSC$K_CLASS_S;
     	DUMMY [DSC$A_POINTER] = DUM_STR [0];

	!+
	! Zero the whole dummy string so that zeroes will end up wherever
	! the digits and sign aren't
	!-
	NUM_CHARS = .DUMMY [DSC$W_LENGTH];
	STR$DUPL_CHAR (DUMMY, NUM_CHARS, ZERO);

	IF .STRING [DSC$B_DTYPE] EQL DSC$K_DTYPE_NR
	THEN
	    BEGIN
	    !+
	    ! Right separate -
	    ! Dummy string should have the digits in STRING moved 
	    ! into it first, then the placeholder zeroes, then the 
 	    ! sign.
	    !-
	    NUM_CHARS = .STRING [DSC$W_LENGTH] - 1;	! Number of digits
	    CH$MOVE (.NUM_CHARS, .STRING [DSC$A_POINTER], .DUMMY [DSC$A_POINTER]);
	    CH$MOVE (1, .STRING [DSC$A_POINTER] + .NUM_CHARS, .DUMMY [DSC$A_POINTER] + .NUM_CHARS + .EXPONENT);

	    END
	ELSE
	    IF .STRING [DSC$W_LENGTH] EQL .STRING [DSC$B_DIGITS]
	    THEN
	    	!+
	    	! Left and right overpunched -
	    	! Dummy string should have the sign moved into it first,
	    	! then the digits in STRING, then the placeholder zeroes.
		!-
	        CH$MOVE (.STRING [DSC$W_LENGTH] + 1, .STRING [DSC$A_POINTER], .DUMMY [DSC$A_POINTER])
	    ELSE
	    	!+
	    	! Left separate -
	    	! Dummy string should have the digits in STRING moved
	    	! into it first then the placeholder zeroes.
		!-
		BEGIN

	        CH$MOVE (.STRING [DSC$W_LENGTH] - 1, .STRING [DSC$A_POINTER] + 1, .DUMMY [DSC$A_POINTER]);
	    	HIGH_POS = .HIGH_POS - 1;
	    	STRING_LEN = .STRING_LEN - 1;

		END;

	STRING_BUF = .DUMMY [DSC$A_POINTER];

	END;

    !+
    !  Now read (rest of) number inserting decimal point (or comma). 
    !  Put result in BUF.
    !-

    DECR POS FROM .HIGH_POS TO .LOW_POS DO
	BEGIN					!  Begin loop

	IF (.POS EQL -1)			!  Decimal point/comma insertion
	THEN					!  When pos = -1 we are about to
	    BEGIN				!  read the first digit to the
						!  right of the decimal point
	    !+
	    !  Do not suppress zeroes immediately following the decimal point
	    !  (.002  should not get  .2  as a result)
	    !  If the decimal point is the first significant character in the
	    !  number, check to see if it is necessary to insert a minus sign
	    !  before the decimal point.  ( .002 might be -.002 )
	    !-

	    IF .HIGH_POS EQL -1
	    THEN
		BEGIN
		FIRST_GOOD = 1 ;
		IF .MINUS EQL 1
		THEN
		    BUF [.PUTTER - 1] = .SIGN_STR ;
		END ;

	    !+
	    !  When requested, use a comma in place of a decimal point, 
	    !-

	    IF (.FLAGS AND V_DEC_PT) NEQ 0
	    THEN
		BUF [.PUTTER] = %C','
	    ELSE
		BUF [.PUTTER] = %C'.';
	    DOT_HERE = .PUTTER ;
	    PUTTER = .PUTTER + 1;
	    END;

	!+
	!  Read number, one digit at a time.  Put digit in BUF, incr PUTTER
	!-

	IF .LOOK_FOR_SIGN EQL 2  AND  .POS EQL .LOW_POS
	THEN

	    !+
	    !  Trailing sign - this case also outputs a space instead of a
	    !  '+' sign.
	    !  When .POS = .LOW_POS we are reading the last digit, if we
	    !  have a trailing sign data type - that last digit is the sign.
	    !  Make sure there is something in BUF before inserting the sign.
	    !-

	    BEGIN

	    IF .PUTTER EQL 0				! Check for nothing in
	    THEN 					! BUF
		BEGIN
		BUF [.PUTTER] = %C'0' ;
		PUTTER = 1 ;
		END
	    ELSE
		IF .BUF [.PUTTER - 1] EQL %C' '		! Check for only spaces
		THEN					! in BUF
		    BUF [.PUTTER - 1] = %C'0' ;
	
	    SIGN_STR = .STRING_BUF [(.EXPONENT + .STRING_LEN - 1) - .POS] ;
	    IF .SIGN_STR EQL %C'+'
	    THEN
		BUF [.PUTTER] = %C' ' 
	    ELSE
		BUF [.PUTTER] = .SIGN_STR ;
	    END
	ELSE
	    BEGIN
	    !+
	    ! ??? This needs a comment.
	    !-
	    IF ((.POS GTR (.STRING_LEN + .EXPONENT - 1)) OR (.POS LSS .EXPONENT))
	    THEN
		!+
		!  Put trailing, but significant, zeroes in BUF.
		!  (zeroes to left of decimal point)
		!  NOTE - this also puts placeholder zeroes to the right of
		!  the decimal point for STRING with picture of form P(x)9(x).
		!  This is why a dummy string did not have to be set up for
		!  that form.
		!-
		BUF [.PUTTER] = %C'0'
	    ELSE

		!+
		!  Put digit in BUF.
		!-

		IF .LOOK_FOR_SIGN GEQ 0  AND  .LOOK_FOR_SIGN LEQ 2
		THEN
		    BUF [.PUTTER] = .STRING_BUF [(.EXPONENT + .STRING_LEN - 1)
								- .POS]
		ELSE
		    BUF [.PUTTER] = .STRING_BUF [(.EXPONENT + .STRING_LEN - 1)
								- (.POS - 1)] ;
	    END ;

	!+
	!  Search for leading zeroes.
	!  If a leading zero is encountered - replace it with a space,
	!  and leave FIRST_GOOD set at 0.
	!  The first digit encountered that is not a zero will turn off
	!  the search by setting FIRST_GOOD to 1.
	!-

	IF .FIRST_GOOD EQL 0
	THEN
	    IF .BUF [.PUTTER] EQL %C'0'
	    THEN
		IF (.ZERO_OK EQL 0  AND 
		   (( .POS EQL 0) OR 
		    ((.POS EQL 1) AND (.STRING[DSC$B_DTYPE] EQL DSC$K_DTYPE_NR)
						AND (.EXPONENT GEQ 0))
		   ) AND .YES_ZERO EQL 1)
		THEN
		    BEGIN
		    !-
		    !  Leave zero before decimal point if number is less
		    !  than 1.  ( ie. -.1 should be output as -0.1 )
		    !-
		    ZERO_OK = 1 ;
		    FIRST_GOOD = 1 ;
		    IF .MINUS EQL 1
		    THEN
			BEGIN
			!+
			!  Insert minus sign immediately before the first 
			!  significant digit.  Reset MINUS to zero to signal
			!  completion of sign insertion.
			!-
			BUF [.PUTTER - 1] = .SIGN_STR ;
			MINUS = 0 ;
			END ;
		    END
		ELSE
		    IF .DIGITS NEQ 0
		    THEN
			!+
			!  Pull out leading zeroes that were introduced in the
			!  conversion process (to COMP data items).
			!-
			IF .PULL LSS .EXTRA
			THEN
			    BEGIN
			    PUTTER = .PUTTER - 1 ;
			    PULL = .PULL + 1 ;
			    END
			ELSE
			    !+
			    !  No more 'extra' leading zeroes to pull.  Replace
			    !  leading zeroes that were part of the original
			    !  string (string passed to COB$DISPLAY) with
			    !  spaces.
			    !-
			    if .putter lss .dot_here or .dot_here eql 0
			    then
				BUF [.PUTTER] = %C' '
			    else
				buf [.putter] = %c'0'
		    ELSE
			!+
			!  We are not dealing with a COMP data item (original
			!  string before conversion), there are no 'extra'
			!  leading zeroes.  Replace a leading zero, that was
			!  part of the original string, with a space.
			!-
			    if .putter lss .dot_here or .dot_here eql 0
			    then
				BUF [.PUTTER] = %C' '
			    else
				buf [.putter] = %c'0'

	    ELSE
		BEGIN
		!+
		!  We have encountered a digit that is not a zero, stop search
		!  for leading zeroes.
		!-
		FIRST_GOOD = 1 ;
		IF .MINUS EQL 1
		THEN
			!+
			!  Insert minus sign immediately before the first 
			!  significant digit.  No need to reset MINUS as
			!  FIRST_GOOD = 1 prevents this section of code from
			!  being entered again.
			!
			!  Do not write over the decimal point if we have
			!  space - dec pt - significant digit in BUF
			!  Bug was comp SV9 value -.9 giving -9
			!-
			IF .DOT_HERE EQL 1
			THEN
			    BUF [.PUTTER - 2] = .SIGN_STR
			ELSE
			    BUF [.PUTTER - 1] = .SIGN_STR ;
		    END ;


	PUTTER = .PUTTER + 1;

	END;						!  End loop

    !+
    !  Check that at least one zero digit is DISPLAYed if the number is zero.
    !  Do not allow only a sign, decimal point/comma or space to be output
    !  without at least one zero.
    !  Getting " . " want " .0"
    !-

    IF ((.PUTTER EQL 3) AND (.BUF[0] EQL %C' ' OR .BUF[0] EQL %C'-')
		        AND (.BUF[1] EQL %C'.' OR .BUF[1] EQL %C',')
		        AND (.BUF[2] EQL %C' ' OR .BUF[2] EQL %C'-'))
    THEN				
	BEGIN						! space dot space
	BUF[2] = %C'0' ;
	END ;

    !+
    !  Avoid display of too many digits for a COMP item - look at the
    !  DIGITS and SCALE field of the input STRING (from ACC_CONVERT)
    !  Trunc/Notrunc issue
    !-

    IF .CHECK_COMP EQL 1
    THEN
	BEGIN					! Begin COMP data item check
	    LOCAL
		LEFT_DEC,			! # of digits you SHOULD have
		RIGHT_DEC,			! to left and right of dec pt
		HAVE_LEFT,			! # of digits you DO have
		HAVE_RIGHT ;			! to left and right of dec pt

	IF .COMP_SCALE NEQ 0
	THEN
	    BEGIN				! Class SD - look at DIGITS
	    LEFT_DEC  = .DIGITS + .COMP_SCALE ; ! field for 'true' number of
	    RIGHT_DEC = .DIGITS - .LEFT_DEC ;	! digits to DISPLAY
	    END
	ELSE
	    BEGIN				! Class S - VAX COBOL has passed
	    LEFT_DEC  = .DIGITS ;		! an SD desctipter - look at
	    RIGHT_DEC = 0 ;			! DIGITS field for 'true' number
	    END ;				! of digits to DISPLAY

	!+
	!  Is what I have within the limits ?
	!  If what we have is greater than what we expect (according to DIGITS),
	!  pull the extra digits.
	!  ex: Pic 99v99  gets 123.456 but should be changed to 23.45
	!-

	IF .DOT_HERE NEQ 0 
	THEN
	    BEGIN					! Begin SD Class
	    !+
	    !  Use DOT_HERE (postion of decimal point in BUF) to calculate
	    !  the character you have to the left and right of the dec pt.
	    !-
	    HAVE_LEFT  = .DOT_HERE - 1 ;		! -1 for sign
	    HAVE_RIGHT = .PUTTER - .DOT_HERE - 1 ;

	    IF (.HAVE_LEFT  GTR .LEFT_DEC  OR
		.HAVE_RIGHT GTR .RIGHT_DEC )
	    THEN					! Too many digits
		BEGIN
		    LOCAL
			TEMP  :  VECTOR [25, BYTE],
			Y     :  INITIAL (0),		! Ptr to TEMP
			K     :  INITIAL (0) ;		! New PUTTER

							! Peel from BUF backwards
		INCR X FROM 1 TO .DOT_HERE - 1 DO	! Leave sign alone
		    BEGIN
		    TEMP [.Y] = .BUF [.DOT_HERE - .X] ;
		    Y = .Y + 1 ;
		    END ;

		DECR  I FROM .LEFT_DEC TO 1 DO		! Put desired # of 
		    BEGIN				! digits before dec pt.
		    BUF [.I] = .TEMP [.K] ;
		    K = .K + 1 ;
		    END ;

		BUF [.K+1] = .BUF [.DOT_HERE] ;		! Put dec pt/comma in
		K = .K + 2 ;				! new position in BUF

		INCR S FROM 1 TO .RIGHT_DEC	DO	! Put desired # of
		    BEGIN				! digits after dec pt.
		    BUF [.K] = .BUF [.DOT_HERE + .S] ;
		    K = .K + 1 ;
		    END ;
		PUTTER = .K ;

		END ;
	    END						! End SD Class
	ELSE
	    BEGIN					! Begin S Class
	    !+
	    !  PUTTER - 1 (for sign) is the number of characters you have.
	    !-
	    HAVE_LEFT  = .PUTTER - 1 ;
	    HAVE_RIGHT = 0 ;

	    IF (.HAVE_LEFT  GTR .LEFT_DEC  OR
	        .HAVE_RIGHT GTR .RIGHT_DEC )
	    THEN
	        BEGIN
		    LOCAL
			TEMP  :  VECTOR [25, BYTE],
			Y     :  INITIAL (0),		! Ptr to TEMP
			K     :  INITIAL (0) ;		! New PUTTER

							! Peel from BUF backwards
		INCR X FROM 1 TO .PUTTER - 1 DO		! Leave sign alone
		    BEGIN
		    TEMP [.Y] = .BUF [.PUTTER - .X] ;
		    Y = .Y + 1 ;
		    END ;

		DECR  I FROM .LEFT_DEC TO 1 DO		! Put desired # of 
		    BEGIN				! digits before dec pt.
		    BUF [.I] = .TEMP [.K] ;
		    K = .K + 1 ;
		    END ;
		PUTTER = .K + 1 ;
		END ;
	    END ;					! End Class S
	END ;						! End COMP data item check

    !+
    !  Distinguish between signed COMP/COMP3 and unsigned COMP/COMP3.
    !  Look at bit 7 of FLAGS passed by the COBOL Compiler.  There is
    !  no such data item in the COBOL compiler as an unsigned COMP.
    !  TO get rid of sign - shift contents of BUF up 1, overwriting the sign
    !  with is in BUF [0].  Decrement PUTTER by 1.
    !-

    IF ( .FLAGS AND V_NO_SIGN ) NEQ 0 AND .CHECK_COMP NEQ 0
    THEN
	BEGIN
	!+
	!  There is a difference between a string coming into the DISPLAY
	!  routines from the ACCEPT routines than one that does not
	!  pass through the ACCEPT routines.
	!-
	    LOCAL
		Y    :   INITIAL (0) ;

	INCR X FROM 1 TO .PUTTER - 1 DO
	    BEGIN
	    BUF [.Y] = .BUF [.X] ;
	    Y = .Y + 1 ;
	    END ;
	PUTTER = .PUTTER - 1 ;
	END ;

    !+
    !  Copy the final form of the string to ANS_STRING
    !-

    IF NOT ( STR$COPY_R (.ANS_STRING, PUTTER, .BUF ) )
    THEN
	LIB$STOP (COB$_ERRDURDIS) ;

    !+
    !  Free local string.
    !  No need to worry about problems with VM as the length of BUF_DESC has
    !  not been changed since STR$GET1_DX (BUF_DESC).
    !-

    STR$FREE1_DX (BUF_DESC);
    END;					! end of DISP_PARSE

GLOBAL ROUTINE COB$$FREE_STRINGS (		! Free local strings
	SIG, 					! Signal vector
	MECH, 					! Mechanism vector
	ENBL					! Enable vector
    ) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	If we are unwinding, free the local strings.  They are passed
!	in the enable vector.
!
! FORMAL PARAMETERS:
!
!	SIG.rl.a	A counted vector of parameters to LIB$SIGNAL/STOP
!	MECH.rl.a	A counted vector of info from CHF
!	ENBL.ra.a	A counted vector of ENABLE argument addresses.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	Always SS$_RESIGNAL, which is ignored when unwinding.
!
! SIDE EFFECTS:
!
!	Frees all of the strings passed as enable arguments.
!
!--

    BEGIN

    MAP
	SIG : REF VECTOR,
	MECH : REF VECTOR,
	ENBL : REF VECTOR;

!+
! Only free the strings if this is the UNWIND condition.
!-

!    IF ( NOT (LIB$MATCH_COND (SIG [1], %REF (SS$_UNWIND)))) THEN RETURN (SS$_RESIGNAL);

!+
! Go through the enable arguments, freeing them.
!-

    INCR ARG_NO FROM 1 TO .ENBL [0] DO

	IF (..ENBL [.ARG_NO] NEQ 0) THEN STR$FREE1_DX (.ENBL [.ARG_NO]);

    RETURN (SS$_RESIGNAL);
    END;					! end of COB$$FREE_STRINGS

GLOBAL ROUTINE COB$$RET_A_AB_PREV =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Returns address of COB$$AB_PREV for code outside the COBRTL image
!	that needs this variable.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	Address of COB$$AB_PREV.
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    RETURN COB$$AB_PREV;

    END;					! end of COB$$RET_A_AB_PREV

END						! end of module COB$DISPLAY
ELUDOM
