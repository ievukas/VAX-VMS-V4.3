MODULE PATWRT (%IF %VARIANT EQL 1
		%THEN
			ADDRESSING_MODE (EXTERNAL = LONG_RELATIVE,
					NONEXTERNAL = LONG_RELATIVE),
		%FI
		IDENT = 'V04-000'
		) =
BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************

!++
! FACILITY:	PATCH
!
! ABSTRACT:	THIS MODULE CONTAINS THE ROUTINE TO WRITE THE PATCHED IMAGE FILE.
!
! ENVIRONMENT:
!
! AUTHOR: K.D. MORSE	, CREATION DATE: 3-NOV-77
!
! MODIFIED BY:
!
!	V03-006	MCN0166		Maria del C. Nasr	23-Apr-1984
!		Put the missing '.' in BYTES_TO_READ to load the buffer size
!		in NEWRAB, so that we use the size and not the address.
!		
!	V03-005	MCN0157		Maria del C. Nasr	20-Feb-1984
!		Replace $READ to input file to $QIO since file is user opened.
!		Add routine GET_IMAGE_BLOCK to do this.
!
!	V03-004	MTR0025		Mike Rhodes		 8-Aug-1983
!		Add routine WRITE_BINARY to support patching files in
!		absolute mode.
!
!	V03-003	MTR0019		Mike Rhodes		 5-Jan-1983
!		Add code to place the DMT (Debug Module/psect Table) between
!		the DST and GST respectively in the image header in routine
!		PAT$WRTIMG.
!
!	V03-002	MTR0014		Mike Rhodes		 9-Sep-1982
!		Correct the computation of the address of the next header block
!		when the number of header blocks change.  Also, added code to
!		preserve the last word of the image header (VBN 1) which is the
!		image type identifier.
!
!	V03-001	MTR0007		Mike Rhodes		14-Jun-1982
!		Use shared system messages.  Affected modules include:
!		DYNMEM.B32, PATBAS.B32, PATCMD.B32, PATIHD.B32, PATINT.B32,
!		PATIO.B32, PATMAI.B32, PATMSG.MSG, PATWRT.B32, and PATSPA.B32.
!
!		The shared messages are defined by DYNMEM.B32's invocation of
!		SHRMSG.REQ and we simply link against these symbols.  They are
!		declared as external literals below.
!
!	V0207	PCG0001		Peter George		02-FEB-1981
!		Add require statement for LIB$:PATDEF.REQ
!
!	V0206	CNH0017		Chris Hume		10-Oct-1979	12:00
!		Added OFP bit to PAT$GL_COMFAB.  Removed support for /COMMAND.
!		Added support for /VOLUME.  (PATSTO.B32 01.17, PATPRE.REQ 01.03,
!		PATMAI.B32 02.27, [VMSLIB]QUADEF.MAR 01.20)
!
!	V0205	KDM0008		KATHLEEN D. MORSE	16-OCT-1978	13:13
!		Output updating message to SYS$OUTPUT. (V0205)
!
!	V0204	KDM0002		KATHLEEN D. MORSE	25-AUG-1978	13:13
!		Check for global sections with no local copy in the
!		image. (V0204)
!
! MODIFICATIONS:
!
!
!  NO	DATE		PROGRAMMER		PURPOSE
!  --	----		----------		-------
!
!  01	25-APR-78	K.D. MORSE		CONVERT TO NATIVE COMPILER.
!  02	13-JUN-78	K.D. MORSE		ALLOW NON-CONTIGUOUS IMAGE FILES
!						BUT TRY TO PRESERVE INPUT ATRIBS.
!  03	13-JUN-78	K.D. MORSE		ADD FAO COUNTS TO SIGNALS.
!
!--

!
! TABLE OF CONTENTS:
!

FORWARD ROUTINE
	PAT$WRTIMG : NOVALUE,				! Writes out patched image
	GET_IMAGE_BLOCK,
	WRITE_BINARY : NOVALUE;				! Writes patched file.

!
! INCLUDE FILES:
!

LIBRARY 'SYS$LIBRARY:LIB.L32';
REQUIRE 'SRC$:PATPCT.REQ';
REQUIRE 'SRC$:PREFIX.REQ';
REQUIRE 'SRC$:PATPRE.REQ';
REQUIRE 'LIB$:PATDEF.REQ';				! Defines literals
REQUIRE 'LIB$:PATMSG.REQ';
REQUIRE 'SRC$:VXSMAC.REQ';
REQUIRE 'SRC$:PATGEN.REQ';
!
! MACROS:
!

!
! EQUATED SYMBOLS:
!

!
! OWN STORAGE:
!
OWN
	NUM_OF_UPDATES;					! Open vs create indicator

!
! EXTERNAL REFERENCES:
!

EXTERNAL ROUTINE
	PAT$CREMAP : NOVALUE,				! Maps image sections
	PAT$WRITEFILE,					! Writes message to a file
	PAT$FAO_PUT,					! Formats message
	PAT$ALLOBLK : NOVALUE,				! Routine to allocate storage
	GETFILDSC,					! Returns the address of a file name descriptor
	IMG$DECODE_IHD : ADDRESSING_MODE(GENERAL),	! Decode image header desc
	IMG$GET_NEXT_ISD : ADDRESSING_MODE(GENERAL);	! Read next image header desc

EXTERNAL
	PAT$GB_ECOLVL : BYTE,				! Eco level for current patch
	PAT$GL_CHANUM,					! Channel number of input file
	PAT$GL_JNLRAB,					! RAB for journal file
	PAT$GL_NEWVBNMX,				! Max image section binary VBN in new file
	PAT$GL_OLDVBNMX,				! Max image section binary VBN in old file
	PAT$GL_IMGBLKS,					! Number of blocks in new image
	PAT$GW_IMGVOL : WORD,				! Relative Volume Number for new image
	PAT$GL_NEWXABALL : BLOCK [,BYTE],		! New image file ALLocation XAB
	PAT$GL_NEWRAB : BLOCK[,BYTE],			! New image file RAB
	PAT$GL_NEWFAB : BLOCK[,BYTE],			! New image file FAB
	PAT$GL_NEWNBK : BLOCK[,BYTE],			! New image file name block
	PAT$GB_NEWNAME,						! NAME OF NEW IMAGE FILE
	PAT$GL_OLDRAB : BLOCK[,BYTE],				! OLD IMAGE FILE RAB
	PAT$GL_OLDFAB : BLOCK[,BYTE],				! OLD IMAGE FILE FAB
	PAT$GL_OLDNBK : BLOCK[,BYTE],				! OLD IMAGE FILE NAME BLOCK
	PAT$GB_OLDNAME,						! NAME OF OLD IMAGE FILE
	PAT$GB_INPBUF,
	PAT$GL_IMGHDR : REF BLOCK[,BYTE],			! FIXED PART OF IMAGE HEADER
	PAT$GL_IHPPTR : REF BLOCK[,BYTE],			! POINTER TO PATCH SECTION OF OLD IMAGE HEADER
	PAT$GL_ISELHD,						! LIST HEAD OF IMAGE SECTION TABLE
	PAT$GL_ISETAIL,						! TAIL OF THE IMAGE SECTION TABLE
	PAT$GL_TXTLHD : REF VECTOR[,BYTE],			! LIST HEAD FOR COMMAND TEXT
	PAT$GL_FLAGS : BITVECTOR [32],				! PATCH FILE FLAGS
	PAT$GL_ERRCODE,						! GLOBAL ERROR CODE
	PAT$GW_IMGTYP : WORD;					! IMAGE TYPE IDENTIFIER

EXTERNAL LITERAL
!
! Define shared message references.  (resolved @ link time)
!
	PAT$_CLOSEIN,						! Error closing input file.
	PAT$_CLOSEOUT,						! Error closing output file.
	PAT$_OPENIN,						! Error opening input file.
	PAT$_OPENOUT,						! Error opening output file.
	PAT$_OVERLAY,						! !AS being overwritten. (/ABS/NONEW)
	PAT$_READERR,						! Error reading from file.
	PAT$_SYSERROR,						! System Service error.
	PAT$_WRITEERR;						! Error writing to file.


GLOBAL ROUTINE PAT$WRTIMG : NOVALUE =					! WRITES OUT NEW IMAGE FILE

!++
! FUNCTIONAL DESCRIPTION:
!
!	THIS ROUTINE WRITES OUT THE NEW IMAGE FILE.
!	IT PERFORMS THE FOLLOWING STEPS:
!		1) Copies the fixed portion of the image header
!		2) Moves in the image section descriptors
!		3) Updates the header if necessary
!		4) WRITES THE IMAGE HEADER
!		5) WRITES OUT IMAGE BINARY, READING IT FROM OLD FILE IF NECESSARY
!		6) WRITES OUT THE SYMBOL TABLE
!		7) WRITES OUT THE APPENDED PATCH COMMANDS
!		8) APPENDS THE PATCH COMMANDS FOR THIS PATCH SESSION
!
!	FIRST IT BUILDS THE IMAGE HEADER.  AT PRESENT THE IMAGE HEADER MUST FIT
!	WITHIN THE ORIGINAL SIZE PLUS TWO BLOCKS AS THIS IS THE SIZE OF THE BUFFER.
!	THIS IS ACCOMPLISHED BY MOVING IN THE FIXED PART OF THE HEADER AND THEN
!	THE IMAGE SECTION DESCRIPTORS FROM THE IMAGE SECTION TABLE.
!	IMAGE SECTION DESCRIPTORS DO NOT CROSS BLOCK BOUNDARIES AND SO
!	THE REMAINING BYTES IN A BLOCK ARE FILLED WITH NEGATIVE ONES.
!	AFTER THE HEADER IS COMPLETELY BUILT, THE NUMBER OF HEADER BLOCKS IS
!	SET AND THE IMAGE SECTION DESCRIPTORS ARE UPDATED IF NECESSARY.
!	NOW THE HEADER IS WRITTEN.
!
!	NEXT A SECOND PASS IS MADE THROUGH THE IMAGE SECTION TABLE TO WRITE
!	OUT THE IMAGE BINARY.  THE IMAGE SECTION ENTRIES WITH ZEROS FOR
!	STARTING AND ENDING MAPPED ADDRESSES MUST FIRST BE MAPPED IN FROM THE
!	OLD IMAGE FILE AS THEY WERE NOT MAPPED IN DURING THE PATCH SESSION.
!
!	NOW THE SYMBOL TABLE IS WRITTEN INTO THE IMAGE FILE.  THIS SECTION
!	IS VARIABLE LENGTH RECORDS, SO THE FILE ATTRIBUTES MUST BE CHANGED.
!
!	LASTLY THE PATCH COMMAND INFORMATION, ALSO VARIABLE LENGTH RECORDS IS
!	IS COPIED FROM THE OLD IMAGE FILE.  THE PATCH COMMAND TEXT FROM THIS
!	PATCH SESSION IS APPENDED TO THE IMAGE FILE.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	THE IMAGE SECTION TABLE AND IMAGE HEADER MUST BE SET UP.
!	APPENDED COMMAND TEXT BLOCKS MUST BE SET UP.
!	SYMBOL TABLE IS IN MEMORY.
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	THE PATCHED IMAGE FILE IS OUTPUT.
!
!--

BEGIN

LITERAL
	OUT_BUF_BLKS = 10,					! NUMBER OF BLOCKS IN OUTPUT BUFFER
	OUT_BUF_SIZ = OUT_BUF_BLKS * A_PAGE,			! OUTPUT BUFFER SIZE
	NO_MORE = 0,						! INDICATOR OF NO MORE ISD'S
	FILL_CHAR = %X'FFFF';						! HEADER FILL CHARACTER

! Temporary FAB and RAB blocks to be used when we have to do record I/O on the
! input file instead of $QIO's.
!

LOCAL
	
	TMPFAB  : $FAB (NAM = PAT$GL_OLDNBK,
			FAC = GET),
	
	TMPRAB  : $RAB (RBF = PAT$GB_INPBUF,
			RSZ = 512,
			UBF = PAT$GB_INPBUF,
			USZ = 512,
			FAB = TMPFAB);
LOCAL
	CUR_VBN,						! VBN TO READ
	BYTES_TO_READ,						! NUMBER OF BYTES TO READ
	MAX_VBN_WRITTEN,					! VBN OF NEXT BLOCK TO BE WRITTEN INTO NEW IMAGE
	ECO_LEVEL_PTR : REF BITVECTOR,				! POINTER TO ECO LEVEL BITS IN IMAGE HEADER
	BLK_DIFF,						! DIFFERENCE BETWEEN OLD AND NEW HEADER BLOCK SIZE
	COUNTER,						! NUMBER OF GLOBAL SYMBOLS
	NUM_HDR_BLKS,						! NUMBER OF BLOCKS USED IN HEADER
	REM_BYTE_SIZ,						! NUMBER OF UNUSED BYTES IN CURREN OUTPUT BLOCK
	NEW_IHD_MAX,						! MAXIMUM SIZE IN BYTES OF NEW IMAGE HEADER
	OUT_BUF_PTR,						! POINTER TO OUTPUT BUFFER
	NXT_BYTE_PTR : REF VECTOR[,BYTE],			! POINTER TO NEXT BYTE OF OUTPUT BUFFER
	ISD_PTR : REF BLOCK[,BYTE],				! POINTER TO CURRENT ISD
	ISE_PTR : REF BLOCK[,BYTE],				! POINTER TO CURRENT ISE
	NEW_IHD_PTR : REF BLOCK[,BYTE],				! POINTER TO NEW IMAGE HEADER
	NEW_IHSYM_PTR : REF BLOCK[,BYTE],			! POINTER TO NEW IMAGE HEADER SYMBOL SECTION
	NEW_IHPAT_PTR : REF BLOCK[,BYTE],			! POINTER TO NEW IMAGE HEADER PATCH SECTION
	NEW_ISD_PTR : REF BLOCK[,BYTE],				! POINTER TO NEW IMAGE SECTION DESCRIPTOR
	COM_TXT_PTR : REF BLOCK[,BYTE],				! POINTER TO PATCH COMMAND TEXT BLOCK
	COM_PTR : REF VECTOR[,BYTE],				! POINTER TO NEXT PATCH COMMAND
	OLD_IHSYM_PTR : REF BLOCK[,BYTE];			! POINTER TO OLD IMAGE HEADER SYMBOL SECTION


IF .PAT$GL_FLAGS [PAT$S_ABSOLUTE]				! If the file has been patched in absolute mode
THEN								! write the file as a simple binary file.
    BEGIN							! The file is extracted from the 'ISE/ISD' list
    WRITE_BINARY ();						! and written to the new file in typical patch style.
    RETURN;							! Upon completion of this task return for further
    END;							! patch activity (normal course of action).

!++
! ALLOCATE A BUFFER FOR THE HEADER AND INITIALIZE POINTERS.
!--
IF .PAT$GL_IMGHDR[IHD$W_SYMDBGOFF] NEQ 0
THEN
	OLD_IHSYM_PTR=CH$PTR(.PAT$GL_IMGHDR, .PAT$GL_IMGHDR[IHD$W_SYMDBGOFF])
ELSE
	OLD_IHSYM_PTR=0;
NEW_IHD_MAX=(.PAT$GL_IMGHDR[IHD$B_HDRBLKCNT] +2) * A_PAGE;	! GET BUFFER SIZE
PAT$ALLOBLK(.NEW_IHD_MAX, NEW_IHD_PTR);				! ALLOCATE NEW IMAGE HEADER BUFFER
PAT$ALLOBLK(OUT_BUF_SIZ, OUT_BUF_PTR);				! ALLOCATE OUTPUT BUFFER
NXT_BYTE_PTR=CH$PTR(.NEW_IHD_PTR,0);				! INITIALIZE OUTPUT BUFFER POINTER

!++
! NOW MOVE IN THE FIXED SIZE PORTION OF THE IMAGE HEADER.
! INITIALIZE POINTERS TO PIECES OF THE NEW HEADER.
!--
NXT_BYTE_PTR=CH$MOVE(.PAT$GL_IMGHDR[IHD$W_SIZE], .PAT$GL_IMGHDR, .NXT_BYTE_PTR);
REM_BYTE_SIZ=A_PAGE - .PAT$GL_IMGHDR[IHD$W_SIZE];
IF .NEW_IHD_PTR[IHD$W_SYMDBGOFF] NEQ 0
THEN
	NEW_IHSYM_PTR=CH$PTR(.NEW_IHD_PTR, .NEW_IHD_PTR[IHD$W_SYMDBGOFF])
ELSE
	NEW_IHD_PTR = 0;
NEW_IHPAT_PTR=CH$PTR(.NEW_IHD_PTR, .NEW_IHD_PTR[IHD$W_PATCHOFF]);

!++
! NOW MOVE IN THE IMAGE SECTION DESCRIPTORS.
!--
NUM_HDR_BLKS = 1;						! COUNT THE FIRST HEADER BLOCK
ISE_PTR=CH$PTR(.PAT$GL_ISELHD,0);				! INITIALIZE POINTER TO FIRST ISE
REM_BYTE_SIZ = .REM_BYTE_SIZ - A_WORD;				! LEAVE ROOM FOR IMAGE TYPE IDENTIFIER -
WHILE .ISE_PTR NEQA 0						! WORD AT END OF BLOCK.
DO
	BEGIN
	IF .NUM_HDR_BLKS GTR .PAT$GL_IMGHDR[IHD$B_HDRBLKCNT]+2	! CHECK IF HEADER OVERFLOWED BUFFER
	THEN
		SIGNAL(PAT$_HDRBLK);
	ISD_PTR=CH$PTR(.ISE_PTR, ISE$C_SIZE);			! POINT TO ISD
	IF (.REM_BYTE_SIZ GTR					! CHECK IF THERE IS ENOUGH ROOM FOR: 
			(IF .ISE_PTR[ISE$L_NXTISE] EQLA 0	! (IF THIS IS LAST ISD, THEN
			 THEN .ISD_PTR[ISD$W_SIZE] + A_WORD	! THE ISD AND A NO-MORE INDICATOR,
			 ELSE .ISD_PTR[ISD$W_SIZE]))		! OTHERWISE, JUST THE ISD.)
	THEN
		BEGIN						! YES, THEN MOVE IT IN
		NXT_BYTE_PTR=CH$MOVE(.ISD_PTR[ISD$W_SIZE], .ISD_PTR, .NXT_BYTE_PTR);
		REM_BYTE_SIZ=.REM_BYTE_SIZ - .ISD_PTR[ISD$W_SIZE];
		ISE_PTR = .ISE_PTR[ISE$L_NXTISE];		! POINT TO NEXT ISE
		END
	ELSE
		BEGIN
		NXT_BYTE_PTR = CH$FILL(FILL_CHAR, .REM_BYTE_SIZ+A_WORD, .NXT_BYTE_PTR); ! INSERT FILL CHARACTER
		IF .NUM_HDR_BLKS EQL 1				! IF THIS IS THE FIRST HEADER BLOCK, RESTORE
		THEN .NXT_BYTE_PTR - 2 = .PAT$GW_IMGTYP;	! THE IMAGE TYPE IDENTIFIER WORD.
		NUM_HDR_BLKS = . NUM_HDR_BLKS + 1;		! ONE MORE HEADER BLOCK
		REM_BYTE_SIZ = A_PAGE - A_WORD;			! SET NEW BLOCK BYTE COUNT
		END;
	END;
NXT_BYTE_PTR = CH$FILL(NO_MORE, A_WORD, .NXT_BYTE_PTR);
NXT_BYTE_PTR = CH$FILL(FILL_CHAR, .REM_BYTE_SIZ, .NXT_BYTE_PTR);
IF .NUM_HDR_BLKS EQL 1						! IF THERE IS ONLY ONE HEADER BLOCK, RESTORE
THEN .NXT_BYTE_PTR - 2 = .PAT$GW_IMGTYP;			! THE IMAGE TYPE IDENTIFIER WORD HERE.

!++
! NOW UPDATE THE IMAGE HEADER IF THE NUMBER OF HEADER BLOCKS CHANGED.
!--
IF (.PAT$GL_IMGHDR[IHD$B_HDRBLKCNT] NEQ .NUM_HDR_BLKS) OR
   (.PAT$GL_NEWVBNMX NEQ .PAT$GL_OLDVBNMX)
THEN
	BEGIN
	!++
	! FILE HEADER EXPANDED.  ALL THE VBN'S IN THE ISD'S MUST BE CHANGED.
	! THAT IS, THE DIFFERENCE IN THE SIZE OF THE HEADERS MUST BE ADDED
	! TO EVERY VBN IN THE HEADER.
	!--
	BLK_DIFF = .NUM_HDR_BLKS - .NEW_IHD_PTR[IHD$B_HDRBLKCNT];
	NEW_ISD_PTR = CH$PTR(.NEW_IHD_PTR, .NEW_IHD_PTR[IHD$W_SIZE]);
	WHILE .NEW_ISD_PTR[ISD$W_SIZE] NEQ 0
	DO
		BEGIN
		IF (NOT .NEW_ISD_PTR[ISD$V_DZRO]) AND (NOT .NEW_ISD_PTR[ISD$V_GBL])
		THEN
			NEW_ISD_PTR[ISD$L_VBN] = .NEW_ISD_PTR[ISD$L_VBN] + .BLK_DIFF;
		NEW_ISD_PTR = CH$PTR(.NEW_ISD_PTR, .NEW_ISD_PTR[ISD$W_SIZE]);
		IF .NEW_ISD_PTR[ISD$W_SIZE] EQL FILL_CHAR
		THEN
			!
			! Compute the beginning address of the next header block by rounding
			! up to the next page boundary, then adding the amount of scew into the page.
			!
			NEW_ISD_PTR = ((.NEW_ISD_PTR + A_PAGE - 1)/ A_PAGE * A_PAGE) + 
					.NEW_IHD_PTR MOD A_PAGE;
		END;
	NEW_IHD_PTR[IHD$B_HDRBLKCNT] = .NUM_HDR_BLKS;		! RESET NUMBER OF HEADER BLOCKS
	BLK_DIFF = .BLK_DIFF + .PAT$GL_NEWVBNMX - .PAT$GL_OLDVBNMX;
	IF .NEW_IHSYM_PTR NEQA 0
	THEN
		BEGIN
		IF .NEW_IHSYM_PTR[IHS$L_DSTVBN] NEQ 0
		THEN
			NEW_IHSYM_PTR[IHS$L_DSTVBN] = .NEW_IHSYM_PTR[IHS$L_DSTVBN] + .BLK_DIFF;

		IF .NEW_IHSYM_PTR[IHS$L_DMTVBN] NEQ 0
		THEN
			NEW_IHSYM_PTR[IHS$L_DMTVBN] = .NEW_IHSYM_PTR[IHS$L_DMTVBN] + .BLK_DIFF;

		IF .NEW_IHSYM_PTR[IHS$L_GSTVBN] NEQ 0
		THEN
			NEW_IHSYM_PTR[IHS$L_GSTVBN] = .NEW_IHSYM_PTR[IHS$L_GSTVBN] + .BLK_DIFF;
		END;
	IF .NEW_IHPAT_PTR[IHP$L_PATCOMTXT] NEQ 0
	THEN
		NEW_IHPAT_PTR[IHP$L_PATCOMTXT] = .NEW_IHPAT_PTR[IHP$L_PATCOMTXT] + .BLK_DIFF;
	END
ELSE
	BLK_DIFF = 0;

!++
! NOW COMPUTE THE SIZE OF THE NEW IMAGE FILE.  THEN OPEN IT, ALLOCATING THE
! NEEDED CONTIGUOUS SPACE.
!--
COM_TXT_PTR = CH$PTR(.PAT$GL_TXTLHD, 0);			! POINT TO FIRST COMMAND TEXT BLOCK
WHILE .COM_TXT_PTR NEQA 0					! INCREMENT IMAGE SIZE FOR EACH
DO								! BLOCK OF COMMAND TEXT
	BEGIN
	PAT$GL_IMGBLKS = .PAT$GL_IMGBLKS + 1;
	COM_TXT_PTR = .COM_TXT_PTR[TXT$L_NXTBLK];		! POINT TO NEXT COMMAND TEXT BLOCK
	END;
PAT$GL_IMGBLKS = .PAT$GL_IMGBLKS + .BLK_DIFF;			! ADD IN DIFFERENCE IN HEADER SIZES
PAT$GL_NEWXABALL[XAB$L_ALQ] = .PAT$GL_IMGBLKS;			! INITIALIZE NUMBER OF BLOCKS TO ALLOCATE

IF .PAT$GL_FLAGS [PAT$S_VOLUME]					! The VOLUME qualifier specifies the RVN
THEN
	BEGIN
	PAT$GL_NEWXABALL[XAB$W_VOL] = .PAT$GW_IMGVOL;		! The Relative Volume Number
	PAT$GL_NEWXABALL[XAB$B_ALN] = XAB$C_LBN;		! To enable XAB$W_VOL
	END;

IF (.NUM_OF_UPDATES EQL 0)					! Check number of updates done
THEN
	BEGIN
	!++
	! Create the output image file.  Try to make it a contiguous file if
	! the input image file was contiguous, i.e., first try a create with
	! the same attributes.  If the file cannot be created with the same
	! attributes, then attempt a second try with contiguous-best-try.  If
	! this succeeds, then print an informational message.
	!--
	PAT$GL_NEWXABALL[XAB$V_CTG] = .PAT$GL_OLDFAB[FAB$V_CTG];
	PAT$GL_NEWXABALL[XAB$V_CBT] = .PAT$GL_OLDFAB[FAB$V_CBT];
	IF NOT (PAT$GL_ERRCODE=$CREATE(FAB=PAT$GL_NEWFAB))
	THEN
		BEGIN						! Attempt a contiguous best try
		PAT$GL_NEWXABALL[XAB$V_CBT] = TRUE;
		PAT$GL_ERRCODE = $CREATE(FAB=PAT$GL_NEWFAB);
		IF .PAT$GL_ERRCODE
		THEN
			SIGNAL(PAT$_NONCONTIG+MSG$K_INFO,.PAT$GL_ERRCODE,.PAT$GL_NEWRAB[RAB$L_STV]);
		END;
	END
ELSE
	PAT$GL_ERRCODE=$OPEN(FAB=PAT$GL_NEWFAB);		! OPEN OUTPUT FILE
IF NOT .PAT$GL_ERRCODE						! SUCCESS ON OPEN OR CREATE?
THEN
	SIGNAL(PAT$_OPENOUT,1,GETFILDSC(PAT$GL_NEWFAB),.PAT$GL_NEWFAB[FAB$L_STS],.PAT$GL_NEWRAB[RAB$L_STV]) ! REPORT FAILURE
ELSE
	BEGIN
	PAT$GL_ERRCODE=$CONNECT(RAB=PAT$GL_NEWRAB);		! CONNECT INPUT FILE
	IF NOT .PAT$GL_ERRCODE					! SUCCESS ON CONNECT?
	THEN
	SIGNAL(PAT$_OPENOUT,1,GETFILDSC(PAT$GL_NEWFAB),.PAT$GL_NEWRAB[RAB$L_STS],.PAT$GL_NEWRAB[RAB$L_STV]) ! REPORT FAILURE
	ELSE
		BEGIN
		NUM_OF_UPDATES = 1;				! SET INDICATOR FOR ALREADY CREATED
		PAT$GL_FLAGS [PAT$S_OUTPUT] = 1;		! SET FLAG FILE NOT OPEN
		PAT$GL_NEWFAB[FAB$V_ESC] = TRUE;
		PAT$GL_NEWFAB[FAB$L_CTX] = RME$C_SETRFM;	! SET MODIFY CODE
		PAT$GL_NEWFAB[FAB$B_RFM] = FAB$C_VAR;		! SET VARIABLE LENGTH RECORDS
		PAT$GL_ERRCODE = $MODIFY(FAB=PAT$GL_NEWFAB);
		IF NOT .PAT$GL_ERRCODE
		THEN
			SIGNAL(PAT$_MODIFYERR, 3, .PAT$GL_ERRCODE,
				.PAT$GL_NEWNBK[NAM$B_RSL], PAT$GB_NEWNAME,
				.PAT$GL_ERRCODE, .PAT$GL_NEWRAB[RAB$L_STV]);
		END
	END;

!++
! REPORT FILE BEING WRITTEN.
!--
SIGNAL(PAT$_WRTFIL+MSG$K_INFO, 2, .PAT$GL_NEWNBK[NAM$B_RSL], PAT$GB_NEWNAME);

!++
! MAKE SURE THE FILE IS OPEN.
!--
IF NOT .PAT$GL_FLAGS [PAT$S_OUTPUT]
OR NOT .PAT$GL_FLAGS [PAT$S_INPUT]
THEN	RETURN;							! CAN'T GET AT FILES, GIVE UP

!++
! Now write out the image binary.
!--
ISE_PTR=CH$PTR(.PAT$GL_ISELHD,0);				! POINT TO FIRST ISE
NEW_ISD_PTR = CH$PTR(.NEW_IHD_PTR, .NEW_IHD_PTR[IHD$W_SIZE]);	! POINT TO FIRST NEW ISD
MAX_VBN_WRITTEN = 0;						! NO VBN WRITTEN YET
WHILE .ISE_PTR NEQA 0						! LOOP UNTIL ISE'S ARE EXHAUSTED
DO
	BEGIN
	ISD_PTR = CH$PTR(.ISE_PTR, ISE$C_SIZE);			! FIND OLD ISD ADDRESS
	COUNTER = 0;						! SET COUNT OF BLOCKS WRITTEN FOR IMAGE SECTION
	IF (NOT .ISD_PTR[ISD$V_DZRO]) AND			! CHECK FOR NO IMAGE BINARY
	   (.ISD_PTR[ISD$B_TYPE] NEQ ISD$K_USRSTACK) AND	! AND FOR IMAGE STACK
	   (	(NOT .ISD_PTR[ISD$V_GBL])  OR			! AND FOR GLOBAL SECTIONS WITH
		(.ISD_PTR[ISD$V_GBL] AND (.ISD_PTR[ISD$L_VBN] NEQ 0))) ! NO LOCAL COPY.
	THEN
		BEGIN
		!++
		! SET VBN OF IMAGE SECTION IN OLD AND NEW FILES.
		!--
		CUR_VBN = .ISD_PTR[ISD$L_VBN];
		PAT$GL_NEWRAB[RAB$L_BKT] = .NEW_ISD_PTR[ISD$L_VBN];

		!++
		! NOW LOOP TO OUTPUT ALL OF THIS IMAGE SECTION.
		! (THE LOOP IS IN CASE THE IMAGE SECTION IS LARGER THAN THE OUTPUT BUFFER.)
		!--
		WHILE .COUNTER NEQ .ISD_PTR[ISD$W_PAGCNT]
		DO
			BEGIN
			IF .ISE_PTR[ISE$L_MAPVEND] EQLA 0	! IF THE IMAGE SECTION IS NOT MAPPED
			THEN					! THEN READ IT
				BEGIN
				!++
				! CHECK THAT THE BUFFER IS LARGE ENOUGH TO HOLD ALL OF IMAGE SECTION.
				!--
				IF OUT_BUF_SIZ GTR ((.ISD_PTR[ISD$W_PAGCNT]-.COUNTER)*A_PAGE)
				THEN
					BEGIN
					!++
					! BUFFER WAS LARGE ENOUGH.  SET UP TO READ ENTIRE IMAGE SECTION.
					!--
					BYTES_TO_READ = A_PAGE * (.ISD_PTR[ISD$W_PAGCNT]-.COUNTER);
					PAT$GL_NEWRAB[RAB$W_RSZ] = .BYTES_TO_READ;
					COUNTER = .ISD_PTR[ISD$W_PAGCNT];
					END
				ELSE
					BEGIN
					!++
					! BUFFER WAS NOT LARGE ENOUGH TO READ ENTIRE IMAGE SECTION.
					! THEREFORE, SET COUNTER TO READ TEN BLOCKS.
					!--
					BYTES_TO_READ = OUT_BUF_SIZ;
					PAT$GL_NEWRAB[RAB$W_RSZ] = OUT_BUF_SIZ;
					COUNTER = .COUNTER + 10;
					END;

				!++
				! NOW READ IMAGE SECTION.  IF IMAGE SECTION IS TOO LARGE
				! FOR BUFFER, READ TEN BLOCKS OF IT.
				!--
				PAT$GL_ERRCODE = GET_IMAGE_BLOCK ( .CUR_VBN,
								.OUT_BUF_PTR,
								.BYTES_TO_READ );
				IF NOT .PAT$GL_ERRCODE
				THEN
					SIGNAL(PAT$_READERR, 1, GETFILDSC(PAT$GL_OLDFAB),
						.PAT$GL_ERRCODE, 0);

				!++
				! INITIALIZE THE OUTPUT BUFFER ADDRESS.
				!--
				PAT$GL_NEWRAB[RAB$L_RBF] = .OUT_BUF_PTR;
				END
			ELSE
				BEGIN
				!++
				! THIS IMAGE SECTION WAS MAPPED.  CHECK IF
				! THE ENTIRE SECTION SHOULD BE WRITTEN OR TEN
				! BLOCKS AT A TIME.
				!--
				IF OUT_BUF_SIZ GTR ((.ISD_PTR[ISD$W_PAGCNT]-.COUNTER)*A_PAGE)
				THEN
					!++
					! SET THE OUTPUT BUFFER ADDRESS EQUAL
					! TO THE STARTING MAPPED ADDRESS PLUS
					! AN OFFSET FOR THE BLOCKS ALREADY WRITTEN.
					! OUTPUT THE REST OF THE IMAGE SECTION.
					!--
					BEGIN
					PAT$GL_NEWRAB[RAB$W_RSZ] = A_PAGE *
						 (.NEW_ISD_PTR[ISD$W_PAGCNT] - .COUNTER);
					PAT$GL_NEWRAB[RAB$L_RBF] = .ISE_PTR[ISE$L_MAPVST] + 
						(A_PAGE * .COUNTER);
					COUNTER = .ISD_PTR[ISD$W_PAGCNT];
					END
				ELSE
					BEGIN
					!++
					! BUFFER WAS NOT LARGE ENOUGH TO READ
					! ENTIRE IMAGE SECTION. THEREFORE, SET
					! COUNTER TO WRITE TEN BLOCKS.
					!--
					PAT$GL_NEWRAB[RAB$W_RSZ] = OUT_BUF_SIZ;
					PAT$GL_NEWRAB[RAB$L_RBF] =
						 .ISE_PTR[ISE$L_MAPVST] + (A_PAGE * .COUNTER);
					COUNTER = .COUNTER + 10;
					END;
				END;

			!++
			! NOW WRITE OUT THE IMAGE SECTION (OR PART OF IT).
			!--
			PAT$GL_ERRCODE = $WRITE(RAB=PAT$GL_NEWRAB);
			IF NOT .PAT$GL_ERRCODE
			THEN
				SIGNAL(PAT$_WRITEERR, 1, GETFILDSC(PAT$GL_NEWFAB),
					.PAT$GL_NEWRAB[RAB$L_STS],
					.PAT$GL_NEWRAB[RAB$L_STV]);

			!++
			! CHECK TO SEE THAT THE ENTIRE IMAGE SECTION HAS BEEN WRITTEN.
			! IF NOT, RESET THE VBN'S FOR THE NEXT TEN BLOCKS OF IT.
			!--
			IF .COUNTER NEQ .ISD_PTR[ISD$W_PAGCNT]
			THEN
				BEGIN
				CUR_VBN = .ISD_PTR[ISD$L_VBN] + .COUNTER;
				PAT$GL_NEWRAB[RAB$L_BKT] = .NEW_ISD_PTR[ISD$L_VBN] + .COUNTER;
				END;
			END;
		!++
		! Now update the pointer to the next highest VBN to be write.
		!--
		IF (.MAX_VBN_WRITTEN LSSU (.NEW_ISD_PTR[ISD$L_VBN] + .NEW_ISD_PTR[ISD$W_PAGCNT]))
		THEN
			MAX_VBN_WRITTEN = .NEW_ISD_PTR[ISD$L_VBN] + .NEW_ISD_PTR[ISD$W_PAGCNT];
		END;
	ISE_PTR = .ISE_PTR[ISE$L_NXTISE];
	NEW_ISD_PTR = CH$PTR(.NEW_ISD_PTR, .NEW_ISD_PTR[ISD$W_SIZE]);
	!++
	! Now position to the next block of ISD's.
	!--
	IF .NEW_ISD_PTR[ISD$W_SIZE] EQL FILL_CHAR
	THEN
		NEW_ISD_PTR = .NEW_IHD_PTR + 
				(((.NEW_ISD_PTR - .NEW_IHD_PTR + A_PAGE-1) / A_PAGE) * A_PAGE);
	END;

!++
! INITIALIZE THE OUTPUT FILE TO TRUNCATE THE FILE AFTER A PUT.  OTHERWISE, PATCH
! GETS AN NEF ERROR (NOT AT END OF FILE).
!--
PAT$GL_NEWRAB[RAB$V_TPT] = TRUE;

!++
! NOW WRITE OUT THE DEBUG SYMBOL TABLE BLOCKS.
!**** THIS CODE WILL BE CHANGE WHEN PATCH HANDLES SYMBOLS. ****
!--
IF (.OLD_IHSYM_PTR NEQA 0)
THEN
	BEGIN
	IF (.OLD_IHSYM_PTR[IHS$W_DSTBLKS] NEQ 0) AND (.OLD_IHSYM_PTR[IHS$L_DSTVBN] GTR 2)
	THEN
		BEGIN
		COUNTER = 0;
		NEW_IHSYM_PTR[IHS$L_DSTVBN] = .MAX_VBN_WRITTEN;
		PAT$GL_NEWRAB[RAB$L_BKT] = .MAX_VBN_WRITTEN;
		CUR_VBN = .OLD_IHSYM_PTR[IHS$L_DSTVBN];
		WHILE .COUNTER NEQ .OLD_IHSYM_PTR[IHS$W_DSTBLKS]
		DO
			BEGIN
			!++
			! CHECK THAT THE BUFFER IS LARGE ENOUGH TO HOLD ALL OF IMAGE SECTION.
			!--
			IF OUT_BUF_SIZ GTR ((.OLD_IHSYM_PTR[IHS$W_DSTBLKS]-.COUNTER)*A_PAGE)
			THEN
				BEGIN
				!++
				! BUFFER WAS LARGE ENOUGH.  SET UP TO READ ENTIRE IMAGE SECTION.
				!--
				BYTES_TO_READ = A_PAGE * (.OLD_IHSYM_PTR[IHS$W_DSTBLKS]-.COUNTER);
				PAT$GL_NEWRAB[RAB$W_RSZ] = .BYTES_TO_READ;
				COUNTER = .OLD_IHSYM_PTR[IHS$W_DSTBLKS];
				END
			ELSE
				BEGIN
				!++
				! BUFFER WAS NOT LARGE ENOUGH TO READ ENTIRE IMAGE SECTION.
				! THEREFORE, SET COUNTER TO READ TEN BLOCKS.
				!--
				BYTES_TO_READ = OUT_BUF_SIZ;
				PAT$GL_NEWRAB[RAB$W_RSZ] = OUT_BUF_SIZ;
				COUNTER = .COUNTER + 10;
				END;

			!++
			! NOW READ IMAGE SECTION.  IF IMAGE SECTION IS TOO LARGE
			! FOR BUFFER, READ TEN BLOCKS OF IT.
			!--
			PAT$GL_ERRCODE = GET_IMAGE_BLOCK ( .CUR_VBN,
							.OUT_BUF_PTR,
							.BYTES_TO_READ );
			IF NOT .PAT$GL_ERRCODE
			THEN
				SIGNAL(PAT$_READERR, 1, GETFILDSC(PAT$GL_OLDFAB), .PAT$GL_ERRCODE, 0);

			!++
			! INITIALIZE THE OUTPUT BUFFER ADDRESS.
			!--
			PAT$GL_NEWRAB[RAB$L_RBF] = .OUT_BUF_PTR;

			!++
			! NOW WRITE OUT THE DST (OR PART OF IT).
			!--
			PAT$GL_ERRCODE = $WRITE(RAB=PAT$GL_NEWRAB);
			IF NOT .PAT$GL_ERRCODE
			THEN
				SIGNAL(PAT$_WRITEERR, 1, GETFILDSC(PAT$GL_NEWFAB), .PAT$GL_NEWRAB[RAB$L_STS], .PAT$GL_NEWRAB[RAB$L_STV]);

			!++
			! CHECK TO SEE THAT THE ENTIRE DST HAS BEEN WRITTEN.
			! IF NOT, RESET THE VBN'S FOR THE NEXT TEN BLOCKS OF IT.
			!--
			IF .COUNTER NEQ .OLD_IHSYM_PTR[IHS$W_DSTBLKS]
			THEN
				BEGIN
				CUR_VBN = .OLD_IHSYM_PTR[IHS$L_DSTVBN] + .COUNTER;
				PAT$GL_NEWRAB[RAB$L_BKT] = .NEW_IHSYM_PTR[IHS$L_DSTVBN] + .COUNTER;
				END;
			END;
		END;
	IF (.MAX_VBN_WRITTEN LSSU (.NEW_IHSYM_PTR[IHS$L_DSTVBN] + .NEW_IHSYM_PTR[IHS$W_DSTBLKS]))
	THEN
		MAX_VBN_WRITTEN = .NEW_IHSYM_PTR[IHS$L_DSTVBN] + .NEW_IHSYM_PTR[IHS$W_DSTBLKS];

	!++
	!
	! NOW WRITE OUT THE DEBUG MODULE/PSECT TABLE (DMT) BLOCKS.
	!
	!--
	IF .PAT$GL_IMGHDR [IHD$V_DBGDMT]					! Did the latest linker generate this image?
	THEN									! If so, then ...
	    IF .OLD_IHSYM_PTR [IHS$L_DMTBYTES] NEQ 0				! ...are there any DMT entries?
	    THEN								! Yes, propagate the DMT to the new image.
		BEGIN								! NOTE: At this point it is safe to use BLK_DIFF LOCALLY!
	        BLK_DIFF = (.OLD_IHSYM_PTR[IHS$L_DMTBYTES] + A_PAGE) / A_PAGE;	! Number of pages used for the DMT.
	        COUNTER = 0;							! Reset local transfer count.
	        NEW_IHSYM_PTR [IHS$L_DMTVBN] = .MAX_VBN_WRITTEN;		! Set the new starting VBN of the DMT.
	        PAT$GL_NEWRAB[RAB$L_BKT] = .MAX_VBN_WRITTEN;			! Point to the DMT's VBN in the new image.
	        CUR_VBN = .OLD_IHSYM_PTR[IHS$L_DMTVBN];				! Point to the old starting VBN of the DMT.

	        WHILE .COUNTER LSS .BLK_DIFF DO					! Copy the entire DMT.
	            BEGIN
	            IF OUT_BUF_SIZ GEQ .OLD_IHSYM_PTR[IHS$L_DMTBYTES] -		! Is the buffer large enough to transfer
	                               (.COUNTER * A_PAGE)			! the entire (or remaining) DMT in one shot?
	            THEN
	                BEGIN							! Yes,
	                BYTES_TO_READ = (.BLK_DIFF - .COUNTER) * A_PAGE;	! Set the number of DMT bytes to transfer.
	                COUNTER = .COUNTER + (.BLK_DIFF - .COUNTER);		! Set number of blocks transferred.
	                END
	            ELSE
	                BEGIN							! No,
	                BYTES_TO_READ = OUT_BUF_SIZ;				! Copy a buffer full at a time, till done.
	                COUNTER = .COUNTER + OUT_BUF_BLKS;			! Update number of blocks transferred.
	                END;
    
	            PAT$GL_NEWRAB[RAB$W_RSZ] = .BYTES_TO_READ;			! Propagate the byte count to the new file rab.

	            !++
	            ! NOW READ IMAGE SECTION.  IF IMAGE SECTION IS TOO LARGE
	            ! FOR BUFFER, READ TEN BLOCKS OF IT.
	            !--
	            PAT$GL_ERRCODE = GET_IMAGE_BLOCK ( .CUR_VBN,
							.OUT_BUF_PTR,
							.BYTES_TO_READ );
	            IF NOT .PAT$GL_ERRCODE
	            THEN
	               SIGNAL(PAT$_READERR, 1, GETFILDSC(PAT$GL_OLDFAB), .PAT$GL_ERRCODE, 0);

	            !++
	            ! INITIALIZE THE OUTPUT BUFFER ADDRESS AND WRITE THE DMT (OR PART THERE OF...)
	            !--
	            PAT$GL_NEWRAB[RAB$L_RBF] = .OUT_BUF_PTR;
	            PAT$GL_ERRCODE = $WRITE(RAB=PAT$GL_NEWRAB);
	            IF NOT .PAT$GL_ERRCODE
	            THEN
	                SIGNAL(PAT$_WRITEERR, 1, GETFILDSC(PAT$GL_NEWFAB), .PAT$GL_NEWRAB[RAB$L_STS], .PAT$GL_NEWRAB[RAB$L_STV]);

	            !++
	            ! CHECK TO SEE THAT THE ENTIRE DMT HAS BEEN WRITTEN.
	            ! IF NOT, RESET THE VBN'S FOR THE NEXT TEN BLOCKS OF IT.
	            !--
	            IF .COUNTER NEQ .BLK_DIFF
	            THEN
	                BEGIN
	                CUR_VBN  = .OLD_IHSYM_PTR[IHS$L_DMTVBN] + .COUNTER;
	                PAT$GL_NEWRAB[RAB$L_BKT] = .NEW_IHSYM_PTR[IHS$L_DMTVBN] + .COUNTER;
	                END;

	            END; ! WHILE

                IF (.MAX_VBN_WRITTEN LSSU (.NEW_IHSYM_PTR[IHS$L_DMTVBN] + .BLK_DIFF))
                THEN
                    MAX_VBN_WRITTEN = .NEW_IHSYM_PTR[IHS$L_DMTVBN] + .BLK_DIFF;

	        END; ! IF (DMT present)

	END; ! of DST/DMT processing.


! Now reopen the input file with another FAB so that we can change
! the processing from QIO's to record I/O.  We need to do record I/O in the
! symbol table and patch commands since information needs to be appended to
! these in the new file.
!

TMPFAB [FAB$L_FNA] = PAT$GB_OLDNAME;
TMPFAB [FAB$B_FNS] = .PAT$GL_OLDNBK [NAM$B_RSL];
PAT$GL_ERRCODE = $OPEN (FAB=TMPFAB);
IF NOT .PAT$GL_ERRCODE
THEN
    SIGNAL (PAT$_OPENIN, 1, GETFILDSC(TMPFAB),
	    .TMPFAB [FAB$L_STS], .TMPFAB [FAB$L_STV]);

PAT$GL_ERRCODE = $CONNECT (RAB=TMPRAB);
IF NOT .PAT$GL_ERRCODE
THEN
    SIGNAL (PAT$_OPENIN, 1, GETFILDSC(TMPFAB),
	    .TMPRAB [RAB$L_STS], .TMPRAB [RAB$L_STV]);

! Change attributes to be able to do record I/O.
!
TMPFAB [FAB$V_ESC] = TRUE;
TMPFAB [FAB$L_CTX] = RME$C_SETRFM;
TMPFAB [FAB$B_RFM] = FAB$C_VAR;

IF NOT (PAT$GL_ERRCODE = $MODIFY (FAB=TMPFAB))
THEN
    SIGNAL (PAT$_OPENIN, 1, GETFILDSC(TMPFAB),
	    .TMPRAB [RAB$L_STS], .TMPRAB [RAB$L_STV]);

! THE FIRST GET/PUT MUST BE BY RFA AND THE REST SEQUENTIALLY.
!
PAT$GL_NEWRAB[RAB$W_USZ] = A_PAGE;
PAT$GL_NEWRAB[RAB$L_UBF] = .OUT_BUF_PTR;
IF (.NEW_IHSYM_PTR[IHS$L_GSTVBN] NEQ 0)
THEN
	NEW_IHSYM_PTR[IHS$L_GSTVBN] = .MAX_VBN_WRITTEN;
IF (.MAX_VBN_WRITTEN NEQ 0)
THEN
	PAT$GL_NEWRAB[RAB$L_BKT] = .MAX_VBN_WRITTEN - 1
ELSE
	SIGNAL(PAT$_PATERR);

PAT$GL_ERRCODE = $READ(RAB=PAT$GL_NEWRAB);
IF NOT .PAT$GL_ERRCODE
THEN
	SIGNAL(PAT$_READERR, 3, GETFILDSC(PAT$GL_NEWFAB), .PAT$GL_NEWRAB[RAB$L_STS], .PAT$GL_NEWRAB[RAB$L_STV]);

! Initialize to read the global symbol table.  The first record is read by RFA.
!
TMPRAB [RAB$L_RFA0] = .OLD_IHSYM_PTR[IHS$L_GSTVBN];
TMPRAB [RAB$W_RFA4] = 0;
TMPRAB [RAB$B_RAC] = RAB$C_RFA;

! Initialize buffer addresses.
!
PAT$GL_NEWRAB[RAB$L_RBF] = .OUT_BUF_PTR;
TMPRAB [RAB$L_UBF] = .OUT_BUF_PTR;

!++
! Now write out the variable length global symbol records.
! **** THIS CODE WILL CHANGE WHEN PATCH HANDLES SYMBOLS. ****
! **** IT WOULD BE VERY EASY TO EXPAND THE GLOBAL SYMBOL TABLE. ****
!--
IF (.OLD_IHSYM_PTR NEQA 0) AND (.OLD_IHSYM_PTR[IHS$W_GSTRECS] NEQ 0) AND
   (.OLD_IHSYM_PTR[IHS$L_GSTVBN] GTR 2)
THEN
	BEGIN
	COUNTER = .OLD_IHSYM_PTR[IHS$W_GSTRECS];		! COUNT THE RECORDS AS READ
	WHILE .COUNTER GTR 0
	DO
		BEGIN
		PAT$GL_ERRCODE = $GET(RAB=TMPRAB);
		IF NOT .PAT$GL_ERRCODE
		THEN
		    SIGNAL (PAT$_READERR, 1, GETFILDSC(TMPFAB),
			    .TMPRAB[RAB$L_STS], .TMPRAB[RAB$L_STV]);
		TMPRAB[RAB$B_RAC] = RAB$C_SEQ;			! SET FOR SEQUENTIAL I/O
		PAT$GL_NEWRAB[RAB$W_RSZ] = .TMPRAB[RAB$W_RSZ];
		PAT$GL_ERRCODE = $PUT(RAB=PAT$GL_NEWRAB);
		IF NOT .PAT$GL_ERRCODE
		THEN
			SIGNAL(PAT$_WRITEERR, 1, GETFILDSC(PAT$GL_NEWFAB), .PAT$GL_NEWRAB[RAB$L_STS], .PAT$GL_NEWRAB[RAB$L_STV]);
		COUNTER = .COUNTER - 1;
		END;

	!++
	! NOW WRITE A RECORD TO FILL THE REST OF THE BLOCK WITH A FILL CHARACTER.
	! THE SIZE OF THE FILLER RECORD IS THE NUMBER OF BYTES IN A BLOCK MINUS
	! THE LAST RECORD SIZE, THE LAST RECORD OFFSET INTO THE BLOCK, AND FOUR
	! BYTES FOR THE LAST RECORD LENGTH AND THE FILLER RECORD LENGTH.
	!--
	PAT$GL_NEWRAB[RAB$W_RSZ] = A_PAGE - .PAT$GL_NEWRAB[RAB$W_RSZ] - .PAT$GL_NEWRAB[RAB$W_RFA4] - 4;
	IF (.PAT$GL_NEWRAB[RAB$W_RSZ]  GTR 0) AND (.PAT$GL_NEWRAB[RAB$W_RSZ] LSS A_PAGE)
	THEN
		BEGIN
		CH$FILL(FILL_CHAR, .PAT$GL_NEWRAB[RAB$W_RSZ], .OUT_BUF_PTR);
		PAT$GL_ERRCODE = $PUT(RAB=PAT$GL_NEWRAB);
		IF NOT .PAT$GL_ERRCODE
		THEN
		SIGNAL(PAT$_WRITEERR, 1, GETFILDSC(PAT$GL_NEWFAB), .PAT$GL_NEWRAB[RAB$L_STS], .PAT$GL_NEWRAB[RAB$L_STV]);
		END
END;

!++
! SET THE VBN OF THE PATCH COMMAND TEXT IN THE NEW IMAGE HEADER, TO NEXT BLOCK.
!--
NEW_IHPAT_PTR[IHP$L_PATCOMTXT] = .PAT$GL_NEWRAB[RAB$L_RFA0] + 1;

!++
! NOW WRITE OUT THE OLD APPENDED PATCH COMMANDS.
! THEY ARE VARIABLE LENGTH, SEQUENTIAL RECORDS, ENDED BY EOF.
!--
IF .PAT$GL_IHPPTR[IHP$L_PATCOMTXT] NEQ 0
THEN
	BEGIN
	TMPRAB[RAB$B_RAC] = RAB$C_RFA;			! FIND THE FIRST BY RFA
	TMPRAB[RAB$L_RFA0] = .PAT$GL_IHPPTR[IHP$L_PATCOMTXT]; ! SET VBN
	TMPRAB[RAB$W_RFA4] = 0;				! SET BYTE OFFSET WITHIN BLOCK
	REPEAT
		BEGIN
		!++
		! THIS LOOP READS AND WRITES ALL THE PREVIOUS APPENDED PATCH
		! COMMANDS AND FINISHES WHEN EOF IS ENCOUNTERED.
		!--
		PAT$GL_ERRCODE = $GET(RAB=TMPRAB);
		IF .PAT$GL_ERRCODE EQL RMS$_EOF
		THEN
			EXITLOOP;
		IF NOT .PAT$GL_ERRCODE
		THEN
			SIGNAL(PAT$_READERR, 1, GETFILDSC(TMPFAB),
			 .TMPRAB[RAB$L_STS], .TMPRAB[RAB$L_STV]);
		TMPRAB[RAB$B_RAC] = RAB$C_SEQ;		! ALL THE REMAINING IS SEQUENTIAL I/O
		PAT$GL_NEWRAB[RAB$W_RSZ] = .TMPRAB[RAB$W_RSZ];
		PAT$GL_ERRCODE = $PUT(RAB=PAT$GL_NEWRAB);
		IF NOT .PAT$GL_ERRCODE
		THEN
			SIGNAL(PAT$_WRITEERR, 1, GETFILDSC(PAT$GL_NEWFAB), .PAT$GL_NEWRAB[RAB$L_STS], .PAT$GL_NEWRAB[RAB$L_STV]);
		END;
	END;

!++
! NOW APPEND THE PATCH COMMANDS FOR THIS SESSION.
! THE PATCH COMMANDS ARE STORED AS ASCIC STRINGS IN BLOCKS THAT ARE
! SINGULARLY LINKED TOGETHER.  THE COMMANDS DO NOT SPAN BLOCK BOUNDARIES.
! THE LAST COMMAND IN A BLOCK IS FOLLOWED BY A ZERO COUNT.
!--
COM_TXT_PTR = .PAT$GL_TXTLHD;
WHILE .COM_TXT_PTR NEQA 0
DO
	BEGIN
	COM_PTR = .COM_TXT_PTR + TXT$C_SIZE;			! POINT TO FIRST COMMAND IN BLOCK
	WHILE .COM_PTR[0] NEQ 0
	DO
		BEGIN
		PAT$GL_NEWRAB[RAB$W_RSZ] = .COM_PTR[0];		! SET LENGTH OF COMMAND
		PAT$GL_NEWRAB[RAB$L_RBF] = .COM_PTR + 1;	! SET ADDRESS OF COMMAND
		PAT$GL_ERRCODE = $PUT(RAB=PAT$GL_NEWRAB);	! WRITE ONE COMMAND
		IF NOT .PAT$GL_ERRCODE
		THEN
			SIGNAL(PAT$_WRITEERR, 1, GETFILDSC(PAT$GL_NEWFAB), .PAT$GL_NEWRAB[RAB$L_STS], .PAT$GL_NEWRAB[RAB$L_STV]);
		COM_PTR = CH$PTR(.COM_PTR, .COM_PTR[0] + 1);	! POINT TO NEXT COMMAND
		END;
	COM_TXT_PTR = .COM_TXT_PTR[TXT$L_NXTBLK];		! POINT TO NEXT COMMAND TEXT BLOCK
	END;


!++
! NOW WRITE OUT THE IMAGE HEADER.  THE IMAGE HEADER IS WRITTEN LAST BECAUSE
! THE VBN FOR THE PATCH COMMAND TEXT MUST BE FOUND FIRST.  THE ECO LEVEL BIT
! CORRESPONDING TO THIS PATCH MAY NOW BE SET IN THE IMAGE HEADER.  IF THE
! HEADER IS WRITTEN SUCCESSFULLY, THEN THE ECO LEVEL INDICATOR, PAT$GB_ECOLVL,
! IS RE-INITIALIZED TO ZERO.  THIS WILL ENABLE ANOTHER "SET ECO" COMMAND TO
! SPECIFY A NEW PATCH.
!--
IF (.PAT$GB_ECOLVL NEQ 0)					! DON'T TRY TO SET A LEVEL IF NONE SPECIFIED
THEN
	BEGIN
	ECO_LEVEL_PTR = CH$PTR(NEW_IHPAT_PTR[IHP$L_ECO1], 0);	! SET POINTER TO ECO LEVEL BITVECTOR
	ECO_LEVEL_PTR[.PAT$GB_ECOLVL-1] = 1;			! SET ECO BIT
	ECO_LEVEL_PTR = CH$PTR(PAT$GL_IHPPTR[IHP$L_ECO1], 0);	! SET POINTER TO ECO LEVEL BITVECTOR
	ECO_LEVEL_PTR[.PAT$GB_ECOLVL-1] = 1;			! SET ECO BIT
	END;
PAT$GL_NEWRAB[RAB$L_BKT] = 1;					! SET NUMBER OF BLOCK TO OUTPUT
PAT$GL_NEWRAB[RAB$W_RSZ] = .NUM_HDR_BLKS * A_PAGE;		! SET NUMBER OF BYTES TO WRITE
PAT$GL_NEWRAB[RAB$L_RBF] = .NEW_IHD_PTR;			! SET BUFFER ADDRESS

!++
! NOW CLEAR THE TRUNCATE BIT BEFORE PATCH WRITES THE IMAGE HEADER.  IF THIS
! IS NOT DONE, THE REST OF THE FILE IS LOST.
!--
PAT$GL_NEWRAB[RAB$V_TPT] = FALSE;
PAT$GL_ERRCODE=$WRITE(RAB=PAT$GL_NEWRAB);			! OUTPUT HEADER BLOCKS
IF NOT .PAT$GL_ERRCODE
THEN
	SIGNAL(PAT$_WRITEERR, 1, GETFILDSC(PAT$GL_NEWFAB), .PAT$GL_NEWRAB[RAB$L_STS], .PAT$GL_NEWRAB[RAB$L_STV]);
PAT$GB_ECOLVL = 0;						! ALLOW NEW PATCH ECO LEVEL

!++
! NOW RESET FILE ATTRIBUTES.
!--
PAT$GL_NEWFAB[FAB$V_ESC] = TRUE;
PAT$GL_NEWFAB[FAB$L_CTX] = RME$C_SETRFM;			! SET MODIFY CODE
PAT$GL_NEWFAB[FAB$B_RFM] = FAB$C_FIX;				! SET VARIABLE LENGTH RECORDS
PAT$GL_ERRCODE = $MODIFY(FAB=PAT$GL_NEWFAB);
IF NOT .PAT$GL_ERRCODE
THEN
	SIGNAL(PAT$_MODIFYERR, 3, .PAT$GL_ERRCODE, .PAT$GL_NEWNBK[NAM$B_RSL],
		 PAT$GB_NEWNAME, .PAT$GL_ERRCODE, .PAT$GL_NEWRAB[RAB$L_STV]);

!++
! NOW CLOSE THE OUTPUT IMAGE FILE.  THIS IS DONE HERE SO THAT THE "UPDATE"
! COMMAND CAN REWRITE THE FILE IF UPDATE IS SPECIFIED MORE THAN ONCE.
!--
PAT$GL_ERRCODE = $CLOSE(FAB=PAT$GL_NEWFAB);
IF NOT .PAT$GL_ERRCODE
THEN
	SIGNAL(PAT$_CLOSEOUT, 1, GETFILDSC(PAT$GL_NEWFAB), .PAT$GL_NEWFAB[FAB$L_STS], .PAT$GL_NEWFAB[FAB$L_STV])
ELSE
	PAT$GL_FLAGS [PAT$S_OUTPUT] = 0;

! Close the input file, we are all done with record I/O processing.
!

PAT$GL_ERRCODE = $CLOSE (FAB=TMPFAB);
IF NOT .PAT$GL_ERRCODE
THEN
    SIGNAL (PAT$_CLOSEIN, 1, GETFILDSC(TMPFAB), .TMPFAB[FAB$L_STS], .TMPFAB[FAB$L_STV]);

RETURN;
END;								! END OF PAT$WRTIMG

%SBTTL	'GET_IMAGE_BLOCK -- read block from input image'
ROUTINE GET_IMAGE_BLOCK (VBN, BUFFER, BYTES_TO_READ) =
!++
!
! Functional Description:
!	This routine is called to read a block from the input image file,
!	which is assumed to be open.
!
! FORMAL PARAMETERS
!	VBN - virtual block number of desired block
!	BUFFER	- Address of buffer pointer to fill in with the address of our 
!		buffer.
!	BYTES_TO_READ = number of bytes to read
!
! ROUTINE VALUE
!	$QIOW status
!
!--
BEGIN

LOCAL
    STATUS,
    IOSB : VECTOR [4,WORD];

! Read in the desired block to the static buffer.
!

STATUS = $QIOW ( EFN = 7,
		 CHAN = .PAT$GL_CHANUM,
		 FUNC = IO$_READVBLK,
		 IOSB = IOSB,
		 P1 = .BUFFER,
		 P2 = .BYTES_TO_READ,
		 P3 = .VBN );

IF NOT .STATUS
THEN
    RETURN (.STATUS);

! Point the caller's pointer at our buffer.  Then return the $QIOW status
!
RETURN (.IOSB[0]);

END;

%SBTTL	'write_binary -- Write a binary file after patching it /ABSOLUTE'
ROUTINE write_binary : NOVALUE =
!++
!
! Functional Description:
!
!	This routine writes the patched file as a binary data file.  The
!	output file is created/opened (or attempts to...) using the same
!	attributes of the file being patched, failing that it will attempt
!	to create the file contiguous best try (failing this its an error).
!
!	Once the output file is established we traverse the ISE list to
!	determine which sections must be copied from the orignal file to
!	the output file and which are already mapped into virtual memory.
!
! Side Effects:
!
!	Upon exit the the ISE list remains intact, however, the MAPVST/END
!	elements are set to zero and the sections are unmapped.  The output
!	file has been written and $CLOSEd.
!
!--
BEGIN

LITERAL
	MAX_TRANSFER = %X'FE00';				! Maximum number of bytes rms can write
								! per transfer.
LOCAL
	BYTE_COUNT : WORD,					! Number of bytes per transfer.
	ISD_PTR : REF BLOCK[,BYTE],				! Pointer to current ISD
	ISE_PTR : REF BLOCK[,BYTE],				! Pointer to current ISE
	REMAINDER,						! Number of byte remaining to be transfered.
	TRANSFER_COUNT,						! Number of bytes transfered.
	SECTION_SIZE,						! Size of this section in bytes.
	START_VA;						! Starting virtual address of the transfer

IF .PAT$GL_FLAGS [PAT$S_VOLUME]					! The VOLUME qualifier specifies the RVN
THEN
	BEGIN
	PAT$GL_NEWXABALL[XAB$W_VOL] = .PAT$GW_IMGVOL;		! The Relative Volume Number
	PAT$GL_NEWXABALL[XAB$B_ALN] = XAB$C_LBN;		! To enable XAB$W_VOL
	END;

IF .PAT$GL_FLAGS [PAT$S_NEW_VERSION]
THEN
    BEGIN
    IF (.NUM_OF_UPDATES EQL 0)					! Check number of updates done
    THEN
	BEGIN
	!++
	! Create the output file.  Try to make it a contiguous file if
	! the input file was contiguous, i.e., first try a create with
	! the same attributes.  If the file cannot be created with the same
	! attributes, then attempt a second try with contiguous-best-try.  If
	! this succeeds, then print an informational message.
	!--
	PAT$GL_NEWXABALL[XAB$L_ALQ] = .PAT$GL_OLDFAB[FAB$L_ALQ];	! Allocation quantity.
	PAT$GL_NEWXABALL[XAB$V_CTG] = .PAT$GL_OLDFAB[FAB$V_CTG];	! Contiguous.
	PAT$GL_NEWXABALL[XAB$V_CBT] = .PAT$GL_OLDFAB[FAB$V_CBT];	! Contiguous Best Try.
	PAT$GL_NEWFAB [FAB$B_DNS] = .PAT$GL_OLDNBK [NAM$B_TYPE];	! File type size.
	PAT$GL_NEWFAB [FAB$L_DNA] = .PAT$GL_OLDNBK [NAM$L_TYPE];	! File type address.
	PAT$GL_NEWFAB [FAB$W_MRS] = .PAT$GL_OLDFAB [FAB$W_MRS];		! Maximum record size.
	PAT$GL_NEWFAB [FAB$B_RAT] = .PAT$GL_OLDFAB [FAB$B_RAT];		! Record attributes.
	PAT$GL_NEWFAB [FAB$B_RFM] = .PAT$GL_OLDFAB [FAB$B_RFM];		! Record format.
	PAT$GL_NEWRAB [RAB$V_BIO] = TRUE;				! Perform Block IO.
	PAT$GL_NEWRAB [RAB$V_TPT] = TRUE;				! Truncate the file after each write.

	IF NOT (PAT$GL_ERRCODE=$CREATE(FAB=PAT$GL_NEWFAB))
	THEN
		BEGIN						! Attempt a contiguous best try
		PAT$GL_NEWXABALL[XAB$V_CBT] = TRUE;
		PAT$GL_ERRCODE = $CREATE(FAB=PAT$GL_NEWFAB);
		IF .PAT$GL_ERRCODE
		THEN
			SIGNAL(PAT$_NONCONTIG+MSG$K_INFO,.PAT$GL_ERRCODE,.PAT$GL_NEWRAB[RAB$L_STV]);
		END;
	END
    ELSE
	PAT$GL_ERRCODE=$OPEN(FAB=PAT$GL_NEWFAB);		! Open output file

    IF NOT .PAT$GL_ERRCODE					! Success on open?
    THEN SIGNAL(PAT$_OPENOUT,1,GETFILDSC(PAT$GL_NEWFAB),.PAT$GL_NEWFAB[FAB$L_STS],.PAT$GL_NEWRAB[RAB$L_STV]) ! REPORT FAILURE
    ELSE
	BEGIN
	PAT$GL_ERRCODE=$CONNECT(RAB=PAT$GL_NEWRAB);		! Connect input file
	IF NOT .PAT$GL_ERRCODE					! Success on connect?
	THEN
	    SIGNAL(PAT$_OPENOUT,1,GETFILDSC(PAT$GL_NEWFAB),
		  .PAT$GL_NEWRAB[RAB$L_STS],.PAT$GL_NEWRAB[RAB$L_STV]) ! REPORT FAILURE
	ELSE
	    BEGIN
	    NUM_OF_UPDATES = 1;				! Set indicator for already created
	    PAT$GL_FLAGS [PAT$S_OUTPUT] = 1;		! Set open file flag 
	    END;
	END;
    END;

!++
! Report file being written.
!--
IF .PAT$GL_FLAGS [PAT$S_NEW_VERSION]
THEN	SIGNAL(PAT$_WRTFIL+MSG$K_INFO, 2, .PAT$GL_NEWNBK[NAM$B_RSL], PAT$GB_NEWNAME)
ELSE	
	BEGIN
	LOCAL
		OLD_FILE : $BBLOCK [DSC$C_S_BLN];
	OLD_FILE [DSC$W_LENGTH] = .PAT$GL_OLDNBK[NAM$B_RSL];
	OLD_FILE [DSC$A_POINTER] = PAT$GB_OLDNAME;
	SIGNAL(PAT$_OVERLAY, 1, OLD_FILE);
	END;

ISE_PTR=CH$PTR(.PAT$GL_ISELHD,0);				! Point to first ise
WHILE .ISE_PTR NEQA 0						! Loop until ise's are exhausted
DO	BEGIN
	ISD_PTR = CH$PTR(.ISE_PTR, ISE$C_SIZE);			! Find old isd address

	IF .PAT$GL_FLAGS [PAT$S_NEW_VERSION]
	THEN							! We're creating a new patched copy of the file
	    BEGIN
	    IF .ISE_PTR[ISE$L_MAPVEND] EQLA 0			! If the image section is not mapped, then map it!!
	    THEN	PAT$CREMAP (.ISE_PTR);

	    START_VA = .ISE_PTR[ISE$L_MAPVST];			! Set the starting virtual address of the section.
	    SECTION_SIZE = .ISE_PTR [ISE$L_MAPVEND] - .ISE_PTR [ISE$L_MAPVST] + 1;

	    IF .SECTION_SIZE GTR MAX_TRANSFER			! If we can't write the section as a whole, break
	    THEN    BYTE_COUNT = MAX_TRANSFER			! it up into pieces that RMS can deal with and
	    ELSE    BYTE_COUNT = .SECTION_SIZE;			! transfer it one chunk at a time.

	    !++
	    ! Now write out the section (in whole or parts...)
	    !--
	    TRANSFER_COUNT = 0;
	    REMAINDER = 0;
	    WHILE .START_VA LSSA .ISE_PTR [ISE$L_MAPVEND] DO	! Transfer the entire section.
		BEGIN
		PAT$GL_NEWRAB[RAB$W_RSZ] = .BYTE_COUNT;		! Set the number of byte to transfer.
		PAT$GL_NEWRAB[RAB$L_RBF] = .START_VA;		! Set the starting address of the buffer.
		IF NOT (PAT$GL_ERRCODE = $WRITE(RAB=PAT$GL_NEWRAB)) ! Write it to the new file.
		THEN	SIGNAL(PAT$_WRITEERR, 1, GETFILDSC(PAT$GL_NEWFAB),
				.PAT$GL_NEWRAB[RAB$L_STS],
				.PAT$GL_NEWRAB[RAB$L_STV]);

		TRANSFER_COUNT = .TRANSFER_COUNT + .BYTE_COUNT; ! Update the transfer count
		START_VA = .START_VA + .BYTE_COUNT;		! and the starting address of the buffer.

		IF ((REMAINDER = .SECTION_SIZE - .TRANSFER_COUNT) LEQ MAX_TRANSFER)
		AND (.REMAINDER GTR 0)				! If there's still something to transfer,
		THEN BYTE_COUNT = .REMAINDER;			! modifiy the byte (once its less than max!).

		END; ! of WHILE
	    END
	ELSE							! We're patching the file in place, only update
	    IF .ISE_PTR [ISE$L_MAPVEND] NEQ 0			! those portions affected.
	    THEN IF NOT (PAT$GL_ERRCODE = $UPDSEC (INADR = ISE_PTR [ISE$L_MAPVST]))
		 THEN SIGNAL (PAT$_SYSERROR, 0, .PAT$GL_ERRCODE);
	!+
	! Conserve virtual address space!  Once were done writing a section, release the 
	! space back to the process for future use.
	!-
	IF .ISE_PTR [ISE$L_MAPVEND] NEQ 0
	THEN
	    BEGIN
	    IF NOT (PAT$GL_ERRCODE = $DELTVA (INADR = ISE_PTR [ISE$L_MAPVST]))
	    THEN	SIGNAL (PAT$_SYSERROR, 0, .PAT$GL_ERRCODE);
	    ISE_PTR [ISE$L_MAPVST] = ISE_PTR [ISE$L_MAPVEND] = 0;
	    END;

	ISE_PTR = .ISE_PTR[ISE$L_NXTISE];

	END; ! of WHILE

!++
! Now close the output image file.  This is done here so that the "update"
! command can rewrite the file if update is specified more than once.
!--
IF .PAT$GL_FLAGS [PAT$S_NEW_VERSION]
THEN
	BEGIN
	PAT$GL_ERRCODE = $CLOSE(FAB=PAT$GL_NEWFAB);
	IF NOT .PAT$GL_ERRCODE
	THEN	SIGNAL(PAT$_CLOSEOUT, 1, GETFILDSC(PAT$GL_NEWFAB), .PAT$GL_NEWFAB[FAB$L_STS], .PAT$GL_NEWFAB[FAB$L_STV])
	ELSE	PAT$GL_FLAGS [PAT$S_OUTPUT] = 0;
	END;

END;    ! of ROUTINE write_binary

END  ! of MODULE patwrt
ELUDOM
