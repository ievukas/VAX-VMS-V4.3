%TITLE 'SMG$DISPLAY_LINKS - Virtual Display Linkages'
MODULE SMG$DISPLAY_LINKS (
		IDENT = '1-096'	! File: SMGDISLIN.B32 Edit: STAN1096
		) =
BEGIN
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY:	Screen Management
!
! ABSTRACT:
!	The procedures in this module are conerned only with the
! allocation/deallocation of virtual displays, and with the pasting/
! unpasting of these virtual displays to pasteboards.  The are not
! concerned with their contents or output.
!
!	For the procedures which maintain and update the contents of
! virtual displays, see the module SMG$DISPLAY_CHANGE.
!
!	For the procedures which actually do output from these virtual
! displays, see the module SMG$DISPLAY_OUTPUT.
!
!	For procedures that support input operations, see the module
! SMG$DISPLAY_INPUT.
!
! ENVIRONMENT:	User mode, Shared library routines.
!
! AUTHOR: R. Reichert, CREATION DATE: 26-Jan-1983
!
! MODIFIED BY:
!
! 1-096 - Don't allow paste or unpaste if display is batched.
!	  STAN 27-Jun-1984.
! 1-095 - Use symbolic names SMG$K_TOP, etc. in SMG$LABEL_BORDER.
!	  Change error messages by SMG$SET_DISPLAY_SCROLLING_REGION.
!	  STAN 3-Jun-1984.
! 1-094 - Fix bug re borders occluding other borders. STAN 7-May-1984.
! 1-001	- Original.  Skeleton for future code.  RKR 26-Jan-1983
!--

%SBTTL 'Declarations'
!
! SWITCHES:
!

!
! LINKAGES:
!
!	NONE
!
! INCLUDE FILES
!

REQUIRE 'RTLIN:SMGPROLOG';		! defines psects, macros, tcb,
					!  wcb, & terminal symbols

REQUIRE 'RTLIN:STRLNK';			! Linkages to string JSB

!
! TABLE OF CONTENTS:
!

FORWARD ROUTINE

! Public entry points

    SMG$CHANGE_PBD_CHARACTERISTICS,	! Change characteristics of 
					! physical terminal

    SMG$CHANGE_VIRTUAL_DISPLAY,		! Change characteristics of
					! existing virtual display

    SMG$CHECK_FOR_OCCLUSION,		! Check to see if a virtual
					! display is occluded.

    SMG$CREATE_PASTEBOARD,		! Create pasteboard

    SMG$CREATE_VIRTUAL_DISPLAY,		! Create virtual display

    SMG$DELETE_PASTEBOARD,		! Get rid of pasteboard, terminate
					! all operations on this display

    SMG$DELETE_VIRTUAL_DISPLAY,		! Delete virtual display

    SMG$GET_DISPLAY_ATTR,		! Return current attributes of
					! virtual display

    SMG$LABEL_BORDER,			! Supply label for border

    SMG$MOVE_VIRTUAL_DISPLAY,		! Move position of virtual
					! display on pasteboard

    SMG$PASTE_VIRTUAL_DISPLAY,		! Paste virtual display to
					! pasteboard

    SMG$POP_VIRTUAL_DISPLAY,		! Pop off (and delete) all
					! virtual displays from given
					! to top of pasting stack.

    SMG$REPASTE_VIRTUAL_DISPLAY,	! Repaste virtual display to
					! pasteboard in new position

    SMG$RESTORE_PHYSICAL_SCREEN,	! Restore screen to where it
					! was after non-SMG user
					! munged it.

    SMG$SAVE_PHYSICAL_SCREEN,		! Save physical screen before
					! non-SMG user mungs its up.

    SMG$SET_DISPLAY_SCROLL_REGION,	! Set the scrolling region in
					! a virtual display

    SMG$UNPASTE_VIRTUAL_DISPLAY,	! Unpaste virtual display from
					! pasteboard.

! Private entry points

    SMG$$CALC_PASTE_TRANSF,		! Calculate pasting
					! transformation constants.

    SMG$$CHECK_OCCLUSION,		! Check current complement of
					! pasted virtual displays to
					! see who is occluded.

    SMG$$CHECK_OCCLUSION_FIRST,		! Check occlusion caused by
					! highest pasted virtual display.

    SMG$$CREATE_PASTEBOARD,		! Create pasteboard

    SMG$$CREATE_VIRTUAL_DISPLAY,	! Inner-most Create Virtual
					! Display routine

    SMG$$CREATE_WCB,			! Create WCB and its buffers

    SMG$$DEALLOCATE_WCB,		! Get rid of WCB and its buffers.

    SMG$$DUPL_VIRTUAL_DISPLAY,		! Duplicate a virtual display

    SMG$$LOCATE_PP,			! Locate PP which matches a
					! DCB and a PBCB.

    SMG$$PASTE_VIRTUAL_DISPLAY,		! Inner-most Paste Virtual
					! Display routine.

    SMG$$RECALC_PP_FIELDS,		! Recalculate pasting packet
					! fields after virtual display
					! batching ceases.
    SMG$$UNPASTE_VIRTUAL_DISPLAY;	! Inner-most Unpaste Virtual
					! Display routine.


					! routines.

!
! EXTERNAL REFERENCES
!
EXTERNAL ROUTINE
    LIB$ANALYZE_SDESC_R2 : LIB$ANALYZE_SDESC_JSB_LINK,
				! Get length and address of a string

    LIB$FREE_VM,		! Deallocate heap storage

    LIB$FREE_EF,		! Free an event flag

    LIB$GET_EF,			! Get an event flag

    LIB$GET_VM,			! Allocate heap storage

    LIB$SCOPY_DXDX,		! String copy by descriptor

    LIB$SFREE1_DD,		! Free a dynamic string

    SMG$$BEGIN_PASTEBOARD_UPDATE_R1 : SMG$$BEGIN_PBD_UPDATE$LNK,
				! Increase buffering level by 1

    SMG$$END_PASTEBOARD_UPDATE_R2   : SMG$$END_PBD_UPDATE$LNK,
				! Decrease buffering level by 1

    SMG$$ERASE_PASTEBOARD,	! Erase the physical screen

    SMG$$CHECK_FOR_OUTPUT_DCB,	! Force output if now is the time

    SMG$$CHECK_FOR_OUTPUT_PBCB, ! Force output

    SMG$$FILL_WINDOW_BUFFER,	! Move stuff from virt. display to 
				! pasteboard buffer and output.

    SMG$$FIND_MIN_CURSOR_POS,	! Set cursor on physical screen
    SMG$$FLUSH_BUFFER,		! Flush output buffer

    SMG$$FORCE_SCROLL_REG,	! Force scrolling region on screen.

    SMG$$OUTPUT,		! Output a string to terminal

    SMG$$OCCLUDE,		! Check for how two rectangular areas
				! overlap.

    SMG$$PBCB_EXIT_HANDLER,	! Output exit handler

    SMG$$SETUP_TERMINAL_TYPE;	! Get device characteristics

EXTERNAL LITERAL

    LIB$_EF_ALRFRE,	! Event flag already free
    SMG$_BATWAS_ON,	! Batching was enabled
    SMG$_FATERRLIB,	! Fatal error in library
    SMG$_INVARG,	! Invalid argument
    SMG$_ILLBATFNC,	! Operation not legal to batched display
    SMG$_INVDIS_ID,	! Invalid virtual display id
    SMG$_INVPAS_ID,	! Invalid pasteboard id
    SMG$_INVROW,	! Invalid row
    SMG$_NOTPASTED,	! Given display is not pasted to given 
			! pasteboard
    SMG$_PASALREXI,	! Pasteboard already exists for this device
    SMG$_TOOMANDIS,	! Too many virtual displays requested
    SMG$_TOOMANPAS,	! Too many pasteboards requested
    SMG$_WRONUMARG;	! Wrong number of arguments

!+
! Pasteboard Directory (PBD)
! --------------------------
! This data structure resides in OWN storage.  It is the primary vehicle
! for getting from a pasteboard id to the associated pasteboard control
! block.
!-

GLOBAL
    PBD_L_COUNT : INITIAL (0),	! No. of pasteboards we currently know 
				! about.

    PBD_A_PBCB : VECTOR  [PBD_K_MAX_PB, LONG]
		 INITIAL (REP PBD_K_MAX_PB OF (0)),
			! List of pasteboard addresses. Indexed by
			! pasteboard id (PID) to find address of 
			! corresponding PBCB.

    PBD_V_PB_AVAIL : BITVECTOR [PBD_K_MAX_PB]
		     INITIAL ( BYTE (REP ((PBD_K_MAX_PB+7)/8) OF (0)));
			! This is a bit-vector of pasteboard id's
			! still available.  The next available number
			! is found by doing a FFC instruction to find
			! first bit which is a 0.  The bit position so
			! computed is the next available PID.  The
			! bit found is set to 1 to mark it as in use.
			! (Presumably, a check has already been made to
			! insure that PBD_L_COUNT is LSS PBD_K_MAX_PB.)

! Some constants needed by reference for FFC instruction
OWN
    ZERO		: INITIAL ( 0 ),
    PBD_K_MAX_PB_BY_REF : INITIAL ( PBD_K_MAX_PB );

%SBTTL 'SMG$CHANGE_PBD_CHARACTERISTICS'
GLOBAL ROUTINE SMG$CHANGE_PBD_CHARACTERISTICS
	(PBID,
	 P_DESIRED_WIDTH,
	 P_RESULTING_WIDTH,
	 P_DESIRED_HEIGHT,
	 P_RESULTING_HEIGHT,
	 P_DESIRED_BACKGROUND_COLOR,
	 P_RESULTING_BACKGROUND_COLOR
	)=

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine lets you change the physical dimensions
!	of a pasteboard.  It also lets you change the background color.
!
! CALLING SEQUENCE:
!
!       ret_status.wlc.v = SMG$CHANGE_PBD_CHARACTERISTICS
!					( PBID.rl.r
!					[,DESIRED_WIDTH.rl.r]
!					[,RESULTING_WIDTH.wl.r]
!					[,DESIRED_HEIGHT.rl.r]
!					[,RESULTING_HEIGHT.wl.r]
!					[,DESIRED_BACKGROUND_COLOR.rl.r]
!					[,RESULTING_BACKGROUND_COLOR.wl.r]
!					)
!
! FORMAL PARAMETERS:
!
!       PBID.rl.r    		Pasteboard id of pasteboard.
!
!	DESIRED_WIDTH.rl.r	New width desired for pasteboard.
!				If omitted, the width is not changed.
!
!	RESULTING_WIDTH.wl.r	Physical width that resulted.  This may
!				be larger than the width requested if the
!				terminal width couldn't be set exactly to
!				the desired width.  This may be smaller
!				than the width requested if the terminal
!				width couldn't be set that wide.
!				In this case, the terminal was set to
!				it's maximum width.
!
!				Example:	(for VT100)
!
!				Width Desired	Width resulting
!
!				60		80
!				110		132
!				150		132
!
!				If desired width was omitted, this
!				argument receives the current pasteboard
!				width.
!				To find out what the pasteboard width is
!				(as opposed to the terminal width),
!				the caller should take the minimum
!				of his desired width and the resulting width.
!
!	DESIRED_HEIGHT.rl.r	New height desired for pasteboard.
!				If omitted, the height is not changed.
!
!	RESULTING_HEIGHT.wl.r	Physical height that resulted.  This may
!				be larger than the height requested if the
!				terminal height couldn't be set exactly to
!				the desired height.  This may be smaller
!				than the height requested if the terminal
!				height couldn't be set that high.
!				In this case, the terminal was set to
!				it's maximum height.
!
!				Example:	(for VT100)
!
!				Height Desired	Height resulting
!
!				15		24
!
!				35		24
!
!				To find out what the pasteboard height is
!				(as opposed to the terminal height),
!				the caller should take the minimum
!				of his desired height and the resulting height.
!
!	DESIRED_BACKGROUND_COLOR.rl.r	Symbolic name for the background
!					color wanted.  For example,
!					SMG$C_COLOR_WHITE.  These symbols
!					are defined in SMGDEF.SDL.
!					If omitted, the background color
!					is not changed.
!
!	RESULTING_BACKGROUND_COLOR.wl.r	Receives the actual background color
!					that was chosen.  If the terminal
!					does not support the exact color
!					desired, the nearest approximation
!					will be chosen.  This is determined
!					by comparing the frequency of the
!					desired light wave against the
!					available frequencies.  For more
!					information about colorimetry,
!					consult National Bureau of Standards
!					Circular 553, The ISCC-NBS method of
!					designating Colors.
!
!					Example: (VT100)
!
!					Color desired	Resulting Color
!
!					yellowish pink	white
!
!					navy blue	black
!
!					If the desired color is omitted,
!					the value of this variable is not
!					affected.
!
! IMPLICIT INPUTS:
!
!       NONE
!
! IMPLICIT OUTPUTS:
!
!       NONE
!
! COMPLETION STATUS:
!
!       SS$_NORMAL      Normal successful completion
!       SMG$_WRONUMARG  Wrong number of arguments.
!	SMG$_PBDIN_USE	Can't change characteristics while buffering is on
!	SMG$_INVWIDARG	Invalid width of 0 desired
!	SMG$_INVPAGARG	Invalid height of 0 desired
!	SMG$_INVCOLARG	Unknown background color specified
!
! SIDE EFFECTS:
!
!       Physical width and background color of terminal may change.
!--

BEGIN

EXTERNAL ROUTINE

	SMG$$CHECK_FOR_OUTPUT_PBCB,
	SMG$$CALC_PASTE_TRANSF,
	SMG$$CREATE_WCB,
	SMG$$DEALLOCATE_WCB,
	SMG$$ERASE_PASTEBOARD,
	SMG$$OUTPUT;

EXTERNAL LITERAL

	SMG$_INVWIDARG,		! width=0
	SMG$_INVPAGARG,		! HEIGHT=0
	SMG$_INVCOLARG,		! unknown color
	SMG$_PBDIN_USE;		! pasteboard was batched

BUILTIN

	NULLPARAMETER;

LOCAL

	STATUS,				! Status of subroutine calls
	PASTING_PACKET_PANIC,		! TRUE if we must adjust pasting packets
	CURR_PP : REF $PP_DECL,		! Pasting packet pointer

	PBCB    : REF $PBCB_DECL;	! Address of pasteboard control block

$SMG$VALIDATE_ARGCOUNT (1, 7);	! Test for right no. of args

$SMG$GET_PBCB (.PBID,PBCB);	! Get address of PBCB

PASTING_PACKET_PANIC=0;

!+
! If a desired width is specified, get it now.
!-

IF NOT NULLPARAMETER(P_DESIRED_WIDTH)
  THEN	BEGIN	! Change pasteboard width
	BIND	DESIRED_WIDTH=.P_DESIRED_WIDTH;
!(a)	LOCAL	CURRENT_MAX, DESIRED_MAX;
	LOCAL	PREVIOUS_WIDTH;
	LOCAL	RESULTANT_WIDTH;

	IF .DESIRED_WIDTH EQL 0
	  THEN	RETURN	SMG$_INVWIDARG;

	!+
	! Determine the physical setting of the terminal by rounding
	! up to 80 or 132 as necessary.  Do the same for the desired
	! width.  Compare these two numbers to see if we must change
	! the width.  This algorithm will have to change if we ever
	! support terminals with widths other than 80 and 132.
	!-

	IF .PBCB[PBCB_L_BATCH_LEVEL] NEQ 0
	  THEN	RETURN	SMG$_PBDIN_USE;
!(a)	IF .PBCB[PBCB_W_WIDTH] LEQU 80
!(a)	  THEN	CURRENT_MAX=80
!(a)	  ELSE	CURRENT_MAX=132;
!(a)	IF .DESIRED_WIDTH LEQU 80
!(a)	  THEN	DESIRED_MAX=80
!(a)	  ELSE	DESIRED_MAX=132;

!(a)	!+
!(a)	! If the desired max is the same as the current max,
!(a)	! then no escape sequence need be sent to the terminal.
!(a)	! Just adjust our internal width in the PBCB.
!(a)	!-

!(a)	IF .DESIRED_MAX NEQ .CURRENT_MAX
!(a)	  THEN

!+
!
!	Note: (a)
!
!	The lines marked !(a) could be added back in
!	if you want to avoid outputting the escape sequence
!	to change the terminal width if it isn't necessary.
!	However, that will mean the screen doesn't physically
!	blank and so extra code would have to be written to
!	blank the right part of a screen when changing width
!	(say) from 70 to 50 columns.
!-

		BEGIN	! Change physical width

		LOCAL

			NORMAL_WIDTH,
			WIDE_WIDTH;

		!+
		! First, clear the screen.
		!-

		$SMG$GET_TERM_DATA(ERASE_WHOLE_DISPLAY);
		IF .PBCB[PBCB_L_CAP_LENGTH] NEQ 0
		  THEN	BEGIN
			STATUS = SMG$$OUTPUT(.PBCB,.PBCB[PBCB_L_CAP_LENGTH],
						  .PBCB[PBCB_A_CAP_BUFFER]);
			IF NOT .STATUS THEN RETURN .STATUS
			END;

		!+
		! Second, get the normal size.
		!-

		$SMG$GET_TERM_DATA(COLUMNS);
		IF .PBCB[PBCB_L_CAP_LENGTH] NEQ 0
		  THEN	BEGIN
			BIND RESULT=.PBCB[PBCB_A_CAP_BUFFER];
			STATUS = SMG$$OUTPUT(.PBCB,.PBCB[PBCB_L_CAP_LENGTH],
						  .PBCB[PBCB_A_CAP_BUFFER]);
			IF NOT .STATUS THEN RETURN .STATUS;
			NORMAL_WIDTH=.RESULT
			END
		  ELSE	NORMAL_WIDTH=80;

		!+
		! Third, get the wide size.
		!-

		$SMG$GET_TERM_DATA(WIDTH_WIDE);
		IF .PBCB[PBCB_L_CAP_LENGTH] NEQ 0
		  THEN	BEGIN
			BIND RESULT=.PBCB[PBCB_A_CAP_BUFFER];
			STATUS = SMG$$OUTPUT(.PBCB,.PBCB[PBCB_L_CAP_LENGTH],
						  .PBCB[PBCB_A_CAP_BUFFER]);
			IF NOT .STATUS THEN RETURN .STATUS;
			WIDE_WIDTH=.RESULT
			END
		  ELSE	WIDE_WIDTH=80;

		!+
		! Decide which sequence to send.
		!-

		IF .DESIRED_WIDTH LEQ .NORMAL_WIDTH
		  THEN	BEGIN
			$SMG$GET_TERM_DATA(WIDTH_NARROW);
			RESULTANT_WIDTH=.NORMAL_WIDTH
			END
		  ELSE	BEGIN
			$SMG$GET_TERM_DATA(WIDTH_WIDE);
			RESULTANT_WIDTH=.WIDE_WIDTH
			END;

		IF .PBCB[PBCB_L_CAP_LENGTH] NEQ 0
		  THEN	BEGIN
			STATUS = SMG$$OUTPUT(.PBCB,.PBCB[PBCB_L_CAP_LENGTH],
						  .PBCB[PBCB_A_CAP_BUFFER]);
			IF NOT .STATUS THEN RETURN .STATUS;
			END;

		!+
		! If we asked for something smaller than the terminal
		! could handle (like a width of 60 on an 80-column terminal)
		! then we will software simulate the smaller width.
		!-

		RESULTANT_WIDTH=MINU(.RESULTANT_WIDTH,.DESIRED_WIDTH);

		END;	! Change physical width

	!+
	! Should we go back to the old scheme whereby we
	! output the escape sequence only if the max width has
	! changed, then we need the following line:
	!
	!(a)  ELSE	RESULTANT_WIDTH=.DESIRED_WIDTH;
	!-

	!+
	! Save away new pasteboard width in the PBCB.
	!-

	PREVIOUS_WIDTH=.PBCB[PBCB_W_WIDTH];
	PBCB[PBCB_W_WIDTH]=.RESULTANT_WIDTH;

	!+
	! If the width changed, we must recalculate all the pasting
	! packet parameters pronto. Make a note.
	!-

!	IF .PREVIOUS_WIDTH NEQ .RESULTANT_WIDTH
!	  THEN	PASTING_PACKET_PANIC=1;
	PASTING_PACKET_PANIC=1;

	!+
	! At some point in the future, we might want to tell VMS
	! about this new width.  If so, we would add that code here.
	! There is probably no need to do that since we will restore
	! the original width when we delete this pasteboard.
	!-

	END;	! Change pasteboard width

!+
! If the user wants the pasteboard width, give it to him now.
!-

IF NOT NULLPARAMETER(P_RESULTING_WIDTH)
  THEN	BEGIN	! Return pasteboard width
	BIND	RESULTING_WIDTH	= .P_RESULTING_WIDTH;
	RESULTING_WIDTH=.PBCB[PBCB_W_WIDTH]
	END;	! Return pasteboard width

!+
! If the user wants to change his height, do that now.
! If he specifies an illegal height, that's his problem;
! we don't know what sort of funny terminal he might have.
! This code will have to change if we ever support terminals
! that can change height by sending them escape sequences.
!-

IF NOT NULLPARAMETER(P_DESIRED_HEIGHT)
  THEN	BEGIN	! Change pasteboard height
	BIND	DESIRED_HEIGHT = .P_DESIRED_HEIGHT;
	IF .PBCB[PBCB_L_BATCH_LEVEL] NEQ 0
	  THEN	RETURN	SMG$_PBDIN_USE;
	IF .DESIRED_HEIGHT EQL 0
	  THEN	RETURN	SMG$_INVPAGARG;
	IF .PBCB[PBCB_B_ROWS] NEQ .DESIRED_HEIGHT
	  THEN	BEGIN
		!+
		! Blank screen if we are making screen smaller,
		! so as to get rid of items after the bottom of
		! the pasteboard.
		!-
		IF MINU(24,.DESIRED_HEIGHT) LSSU .PBCB[PBCB_B_ROWS]
		  THEN	BEGIN
			STATUS=SMG$$ERASE_PASTEBOARD(.PBCB);
			IF NOT .STATUS THEN RETURN .STATUS
			END;
		!+
		! All existing terminals have a maximum height of 24.
		!-
		PBCB[PBCB_B_ROWS]=MINU(24,.DESIRED_HEIGHT);
		PASTING_PACKET_PANIC=1
		END
	END;	! Change pasteboard height

!+
! If the user wants the pasteboard height, give it to him now.
!-

IF NOT NULLPARAMETER(P_RESULTING_HEIGHT)
  THEN	BEGIN	! Return pasteboard height
	BIND	RESULTING_HEIGHT=.P_RESULTING_HEIGHT;
	RESULTING_HEIGHT=.PBCB[PBCB_B_ROWS]
	END;	! Return pasteboard height

!+
! If we changed either the width or height of the pasteboard,
! then we must go adjust all the pasting packets now.
! We must also reallocate and reshape the buffers in the WCB.
!-

IF .PASTING_PACKET_PANIC
  THEN	BEGIN	! Update all pasting packets
	LOCAL CURR_PP	: REF $PP_DECL;
	!+
	! Deallocate the old WCB.
	!-
	STATUS=SMG$$DEALLOCATE_WCB(.PBCB[PBCB_A_WCB]);
	IF NOT .STATUS THEN RETURN .STATUS;
	!+
	! Allocate a new WCB.
	!-
	STATUS=SMG$$CREATE_WCB( %REF(.PBCB[PBCB_B_ROWS]),
				%REF(.PBCB[PBCB_W_WIDTH]),
				PBCB[PBCB_A_WCB]);
	IF NOT .STATUS THEN RETURN .STATUS;
	!+
	! Walk chain of DCB's for all displays currently pasted
	! to this pasteboard, and go update their pasting packet.
	! Start with first packet.
	!-
	CURR_PP=.PBCB[PBCB_A_PP_NEXT];
	WHILE .CURR_PP NEQ PBCB[PBCB_A_PP_NEXT] DO
		BEGIN	! Update a pasting packet
		LOCAL
		    PP_BASE	: REF $PP_DECL;		! Base addr of this PP

		PP_BASE = .CURR_PP - PP_PBCB_QUEUE_OFFSET;  ! Since queue header
							    ! not at top of
							    ! structure.
		STATUS=SMG$$CALC_PASTE_TRANSF(.PP_BASE);
		IF NOT .STATUS THEN RETURN .STATUS;
		CURR_PP = .PP_BASE [PP_A_NEXT_PBCB] ! Step to next PP
		END;	! Update a pasting packet

	!+
	! Force an update.
	!-

	STATUS=SMG$$CHECK_FOR_OUTPUT_PBCB(.PBCB);
	IF NOT .STATUS THEN SIGNAL(.STATUS);

	END;	! Update all pasting packets

!+
! If a new background color is desired, go do that now.
!-

IF NOT NULLPARAMETER(P_DESIRED_BACKGROUND_COLOR)
  THEN	BEGIN	! Change background color
	BIND	DESIRED_COLOR=.P_DESIRED_BACKGROUND_COLOR;
	BIND	RESULTING_COLOR=PBCB[PBCB_B_BACKGROUND_COLOR];

	IF .DESIRED_COLOR EQL SMG$C_COLOR_WHITE
	  THEN	$SMG$GET_TERM_DATA(LIGHT_SCREEN)
	  ELSE	$SMG$GET_TERM_DATA(DARK_SCREEN);

	IF .PBCB[PBCB_L_CAP_LENGTH] NEQ 0
	  THEN	BEGIN
		STATUS = SMG$$OUTPUT(.PBCB,.PBCB[PBCB_L_CAP_LENGTH],
					  .PBCB[PBCB_A_CAP_BUFFER]);
		IF NOT .STATUS THEN RETURN .STATUS
		END;

	RESULTING_COLOR=.DESIRED_COLOR;

	END;	! Change terminal coror

!+
! If the user wants the new background color, give it to him now.
!-

IF NOT NULLPARAMETER(P_RESULTING_BACKGROUND_COLOR)
  THEN	BEGIN	! Return background color
	BIND	RESULTING_COLOR=.P_RESULTING_BACKGROUND_COLOR;
	RESULTING_COLOR=.PBCB[PBCB_B_BACKGROUND_COLOR]
	END;	! Return background color

RETURN	SS$_NORMAL

END;			! Routine SMG$CHANGE_PBD_CHARACTERISTICS

%SBTTL 'SMG$CHANGE_VIRTUAL_DISPLAY - Change Virtual Display'
GLOBAL ROUTINE SMG$CHANGE_VIRTUAL_DISPLAY (
					   DISPLAY_ID,
                                           NUM_ROWS,
                                           NUM_COLS,
                                           DISPLAY_ATTRIBUTES,
                                           VIDEO_ATTRIBUTES,
					   CHAR_SET
                                          ) =
!++
! FUNCTIONAL DESCRIPTIOM:
!
!       This routine changes the size or default attributes of an 
!	existing virtual display.  The text which is currently in this
!	virtual display is remapped to fit the new dimensions starting
!	at row 1 column 1.  Resulting cursor position will be at row 1
!	column 1.
!
! CALLING SEQUENCE:
!
!       ret_status.wlc.v = SMG$CHANGE_VIRTUAL_DISPLAY ( 
!				DISPLAY_ID.rl.r,
!                               [,NUM_ROWS.rl.r]
!                               [,NUM_COLS.rl.r]
!                               [,DISPLAY_ATTRIBUTES.rl.r]
!                               [,VIDEO_ATTRIBUTES.rl.r]
!				[,CHAR_SET.rl.r])
!
! FORMAL PARAMETERS:
!
!	DISPLAY_ID.rl.r	Display id of virtual display to be changed.
!
!       NUM_ROWS.rl.r   Number of rows in new virtual display.
!			If omitted, the number of rows remains the same.
!
!       NUM_COLS.rl.r   Number of columns in new virtual display.
!			If omitted, the number of columns remains the same.
!
!       DISPLAY_ATTRIBUTES.rl.r The default display attributes:
!
!			SMG$M_BORDER if virtual display is to be
!				     displayed with a border.
!
!			SMG$M_TRUNC_ICON if an icon should be displayed
!				     when text overflows the display bounds.
!
!			SMG$M_DISPLAY_CONTROLS if carriage controls (CR, LF,
!				     (FF, VT, HT) should be displayed instead
!				     of executed.
!
!			If omitted, the default display attributes
!			currently associated with the display will be
!			retained.
!
!       VIDEO_ATTRIBUTES.rl.r   The default rendition code to be
!                       applied to all output to this display unless 
!                       overridden on a particular output call.
!			If omitted, the current video attributes are
!			retained.
!
!                       Values:
!
!                       SMG$M_BLINK	displays characters blinking.
!
!                       SMG$M_BOLD	displays characters in 
!					higher-than-normal intensity.
!
!                       SMG$M_REVERSE	displays characters in reverse 
!					video -- that is, using the
!					opposite default rendition of 
!					the virtual display.
!
!                       SMG$M_UNDERLINE	displays characters underlined.
!
!	CHAR_SET.rl.r	The default character set for all text
!			associated with this display.
!			Recognized values are:
!					SMG$C_UNITED_KINGDOM
!					SMG$C_ASCII (default)
!					SMG$C_SPEC_GRAPHICS
!					SMG$C_ALT_CHAR
!					SMG$C_ALT_GRAPHICS
!
! IMPLICIT INPUTS:
!
!       NONE
!
! IMPLICIT OUTPUTS:
!
!       NONE
!
! COMPLETION STATUS:
!
!       SS$_NORMAL      Normal successful completion
!       LIB$_INSVIRMEM  Insufficient virtual memory to reallocate needed
!                       buffers.
!       SMG$_INVARG     Unrecognized Video Attributes
!                    or Unrecognized Display Attributes
!       SMG$_WRONUMARG  Wrong number of arguments.
!
! SIDE EFFECTS:
!
!	Cursor for virtual display will be forced to row 1 column 1 if
!	display is redimensioned.
!	If a labeled border applies and does not fit newly redimensioned
!	display, the label will be deleted.
!--
    BEGIN
    BUILTIN
	NULLPARAMETER;

    LOCAL
	STATUS,			! Status of subroutine calls
	PP  : REF $PP_DECL,	! Addr. of a pasting packet
	NEW_ROWS,		! New number of rows
	NEW_COLS,		! New number of columns
	DCB : REF $DCB_DECL,	! Addr of display control block
	NEW_SIZE;		! New rows * columns

    $SMG$VALIDATE_ARGCOUNT (1, 6);	! Test for right no. of args

    $SMG$GET_DCB (.DISPLAY_ID, DCB);	! Get address of virtual display
					! control block.

!+
! Determine size of new buffer we need.
!-
    IF NOT NULLPARAMETER (NUM_ROWS)	! If new number of rows specified
    THEN
	NEW_ROWS = ..NUM_ROWS
    ELSE
	NEW_ROWS = .DCB [DCB_W_NO_ROWS];

    IF NOT NULLPARAMETER (NUM_COLS)	! If new number of columns specified
    THEN
	NEW_COLS = ..NUM_COLS
    ELSE
	NEW_COLS = .DCB [DCB_W_NO_COLS];

    NEW_SIZE = .NEW_ROWS * .NEW_COLS;

!+
! Adjust default display, video attributes and default character set if
! they are specified.
!-
    IF NOT NULLPARAMETER (DISPLAY_ATTRIBUTES)	! If display attributes specified
    THEN
	DCB [DCB_B_DEF_DISPLAY_ATTR] = ..DISPLAY_ATTRIBUTES;

    IF NOT NULLPARAMETER (VIDEO_ATTRIBUTES)	! If video attributes specified
    THEN
	DCB [DCB_B_DEF_VIDEO_ATTR] = ..VIDEO_ATTRIBUTES;

    IF NOT NULLPARAMETER (CHAR_SET)	! If char set specified
    THEN
	DCB [DCB_B_DEF_CHAR_SET] = ..CHAR_SET;

!+
! If the dimensions of the old buffer and the new buffers are different,
! we will have to allocate new buffer space and copy existing text into
! new buffers.
!-
    IF .DCB [DCB_L_BUFSIZE] NEQ .NEW_SIZE	OR
       .DCB [DCB_W_NO_ROWS] NEQ .NEW_ROWS	OR
       .DCB [DCB_W_NO_COLS] NEQ .NEW_COLS
    THEN
	BEGIN	! Redimensioning required
	LOCAL
	    STATUS,			! Status of subroutine calls
	    ROWS_TO_MOVE,	! No of rows that will be moved from
				! old buffer to new.
	    COLS_TO_MOVE,	! No of columns that will be moved from
				! old to new.
	    NEW_TEXT_BUF : REF VECTOR [,BYTE],	! Addr of new text
						! buffer
	    NEW_ATTR_BUF : REF VECTOR [,BYTE],	! Addr of new attr
						! buffer
	    NEW_CHAR_BUF : REF VECTOR [,BYTE],	! Addr of new char_set
						! buffer

	    TEXT_PTR : REF VECTOR [, BYTE],	! Address of current
						! text buffer in DCB.

	    ATTR_PTR : REF VECTOR [,BYTE],	! Address of current
						! attr buffer in DCB

	    CHAR_PTR : REF VECTOR [,BYTE];	! Address of current
						! char_set buffer in
						! DCB

	!+
	! Get space for two new, properly-dimensioned buffers.
	!-
	IF NOT (STATUS = LIB$GET_VM (%REF (2 * .NEW_SIZE), 
				     NEW_TEXT_BUF))
	THEN
	    RETURN (.STATUS);

	NEW_ATTR_BUF = .NEW_TEXT_BUF + .NEW_SIZE;

	!+
	! Now need to copy text and attribute information from
	! .DCB [DCB_A_TEXT_BUF] and .DCB [DCB_A_ATTR_BUF] to 
	! .NEW_TEST_BUF and .NEW_ATTR_BUF, preserving the line context.
	!	First pre-blank new text_buffer and attribute buffer in
	!  case old do not cover new area.
	!-
	CH$FILL ( %C' ',                       .NEW_SIZE, .NEW_TEXT_BUF);
	CH$FILL ( .DCB [DCB_B_DEF_VIDEO_ATTR], .NEW_SIZE, .NEW_ATTR_BUF);

	TEXT_PTR = .DCB [DCB_A_TEXT_BUF];
	ATTR_PTR = .DCB [DCB_A_ATTR_BUF];
	CHAR_PTR = .DCB [DCB_A_CHAR_SET_BUF];

	ROWS_TO_MOVE = MIN (.DCB [DCB_W_NO_ROWS], .NEW_ROWS);
	COLS_TO_MOVE = MIN (.DCB [DCB_W_NO_COLS], .NEW_COLS);

	INCR I FROM 1 TO .ROWS_TO_MOVE
	DO
	    BEGIN	! Move text and attrib. to new buffers.
	    LOCAL
		SOURCE_INDEX,
		DEST_INDEX;

	    SOURCE_INDEX = (.I -1) * .DCB [DCB_W_NO_COLS] ;
	    DEST_INDEX   = (.I -1) * ..NUM_COLS          ;

	    CH$MOVE ( .COLS_TO_MOVE, 			! No of chars.
		      TEXT_PTR [.SOURCE_INDEX],		! From
		      NEW_TEXT_BUF [.DEST_INDEX]);	! To

	    CH$MOVE ( .COLS_TO_MOVE,			! No. of chars.
		      ATTR_PTR [.SOURCE_INDEX],		! From
		      NEW_ATTR_BUF [.DEST_INDEX]);	! To


	    END;	! Move text and attrib to new buffers.

	!+
	! Deal with alternate character set buffers if they exist.
	!-
	IF .DCB [DCB_A_CHAR_SET_BUF] NEQ 0
	THEN
	    BEGIN	! Alt. char set buffer exists
	    !+
	    ! Allocate a new alternate character set buffer and init. it
	    !-
	    IF NOT (STATUS = LIB$GET_VM (NEW_SIZE, NEW_CHAR_BUF))
	    THEN
		BEGIN
		LIB$FREE_VM (%REF (2* .NEW_SIZE), NEW_TEXT_BUF);
		RETURN (.STATUS); ! Return LIB$_INSVIRMEM from GET call
		END;

	    CH$FILL ( .DCB [DCB_B_DEF_CHAR_SET], .NEW_SIZE, 
		      .NEW_CHAR_BUF);

	    !+
	    ! Move current contents row by row
	    !-
	    INCR I FROM 1 TO .ROWS_TO_MOVE
	    DO
		BEGIN	! Move loop
		LOCAL
		    SOURCE_INDEX,
		    DEST_INDEX;

		SOURCE_INDEX = (.I-1) * .DCB [DCB_W_NO_COLS] ;
		DEST_INDEX   = (.I-1) * ..NUM_COLS ;
		CH$MOVE ( .COLS_TO_MOVE,		! No of chars
			  CHAR_PTR [.SOURCE_INDEX],	! From
			  NEW_CHAR_BUF [.DEST_INDEX]);	! To
		END;	! Move loop

	    !+
	    ! Free old alternate char. set buffer and plug in new addr.
	    !-
	    IF NOT (STATUS = LIB$FREE_VM ( DCB [DCB_L_BUFSIZE],
					   DCB [DCB_A_CHAR_SET_BUF]))
	    THEN
		RETURN (.STATUS);

	    DCB [DCB_A_CHAR_SET_BUF] = .NEW_CHAR_BUF;

	    END;	! Alt. char set buffer exists

	!+
	! Now that the text and attributes are safe in their 
	! new buffers, we release the old buffers and put the addresses
	! of the new buffers in the DCB.
	!-
	IF NOT (STATUS = LIB$FREE_VM (%REF ( 2 * .DCB [DCB_L_BUFSIZE]),
				      DCB [DCB_A_TEXT_BUF]))
	THEN
	    RETURN (.STATUS);

	DCB [DCB_A_TEXT_BUF] = .NEW_TEXT_BUF;	! Plug in new addresses
	DCB [DCB_A_ATTR_BUF] = .NEW_ATTR_BUF;

	!+
	! If the number of rows changed, we need to reallocate the
	! line characteristics vector and copy over as much of it as
	! fits.
	!-
	IF .DCB [DCB_W_NO_ROWS] NEQ .NEW_ROWS
	THEN
	    BEGIN	! No. of rows changed
	    LOCAL
		NEW_LINE_CHAR : REF VECTOR [,BYTE],	! Addr of a new
							! line Char.
							! vector

		LINE_CHAR_PTR : REF VECTOR [,BYTE];	! Addr of curr.
							! line Char.
							! vector

	    LINE_CHAR_PTR = .DCB [DCB_A_LINE_CHAR];

	    !+
	    ! Allocate a new line characteristics vector of the right
	    ! length.  Quit if we can't get it.
	    !-
	    IF NOT (STATUS = LIB$GET_VM ( %REF (.NEW_ROWS + 1),
					  NEW_LINE_CHAR))
	    THEN
		BEGIN	! Error path
		!+
	        ! Give back all space acquired on this transaction, 
		! ignoring further errors, and quit.
		!-
		LIB$FREE_VM ( %REF (2 * .NEW_SIZE), NEW_TEXT_BUF);
		RETURN ( .STATUS );
		END;	! Error path

	    !+
	    ! Clear entire allocated vector to zero
	    !-
	    CH$FILL ( 0, .NEW_ROWS+1, .NEW_LINE_CHAR);

	    !+
	    ! Copy over as much of old line characteristics vector as
	    ! will fit.
	    !-
	    CH$MOVE ( .ROWS_TO_MOVE, 
		      LINE_CHAR_PTR [1], 
		      NEW_LINE_CHAR [1]);

	    !+
	    ! Free former line characteristics vector.
	    !-
	    IF NOT (STATUS = LIB$FREE_VM (
				 %REF (.DCB [DCB_W_NO_ROWS] +1),
				 DCB [DCB_A_LINE_CHAR]))
	    THEN
		RETURN (.STATUS);

	    !+
	    ! Store address of new line characteristics vector in DCB
	    !-
	    DCB [DCB_A_LINE_CHAR] = .NEW_LINE_CHAR;
	    END;	! No. of rows changed

	!+
	!  Adjust the no. of rows and no. of cols. recorded in the DCB.
	!-
	DCB [DCB_W_NO_ROWS] = .NEW_ROWS;	! Adjust row/column size
	DCB [DCB_W_NO_COLS] = .NEW_COLS;
	DCB [DCB_L_BUFSIZE] = .NEW_SIZE;

	!+
	! Force cursor to home.
	!-
	DCB [DCB_W_CURSOR_ROW] = 1;
	DCB [DCB_W_CURSOR_COL] = 1;

	!+
	! Knock down flags that indicate we are at end of a row and that
	! we are in last line.
	!-
	DCB [DCB_V_FULL]   = 0;
	DCB [DCB_V_COL_80] = 0;

	!+
	! Reset the scrolling region within the redimensioned virtual
	! display to be the whole display.
	!-
	DCB [DCB_W_TOP_OF_SCRREG]    = 1;
	DCB [DCB_W_BOTTOM_OF_SCRREG] = .NEW_ROWS;

	!+
	! Now deal with border data, if any exists.
	!-
	IF .DCB [DCB_V_BORDERED]
	THEN
	    BEGIN	! Bordered
	    LOCAL
		DESC : REF BLOCK [8,BYTE]; ! Pointer to dynamic string 
					   ! desc. for border label

	    DESC = DCB [DCB_Q_LABEL_DESC];
	    IF .DESC [DSC$A_POINTER] NEQ 0	! If label exists
	    THEN
		BEGIN	! Label exists
		LOCAL
		    TEMP;
		TEMP = .DCB [DCB_W_LABEL_UNITS];

		!+
		! Try to reapply our existing border label on this
		! redimensioned virtual display.  If it now doesn't
		! fit because of the new dimensions, delete the label.
		!-
		IF NOT (SMG$LABEL_BORDER (
				.DISPLAY_ID,
				.DESC,
				%REF (.DCB [DCB_B_LABEL_POS]),
				!+
				! Conditionalize UNITS parameter to 
				! LABEL_BORDER depending on whether 
				! caller originally specified
				! "centering" or gave us specific units.
				!-
				(IF .DCB [DCB_V_LABEL_CENTER] THEN 0 
							      ELSE TEMP),
				%REF ( .DCB [DCB_B_LABEL_REND])
				))
		THEN
		    LIB$SFREE1_DD ( .DESC);	! Delete label
		END;	! Label exists
	    END;	! Bordered
	END;	! Redimensioning required

!+
! Since the dimension of the virtual display may have changed, or we 
! may have added or deleted a border,  we need to recalculate the 
! transformation constants that occur in each pasting packet we are 
! involved in.
! Check to see if we can do it now or must wait because we are batched.
!-
    IF .DCB [DCB_L_BATCH_LEVEL] EQL 0
    THEN
	BEGIN	! Can do it now
	LOCAL
	    CURR_PP : REF $PP_DECL;	! Addr of a pasting packet

	IF NOT (STATUS = SMG$$RECALC_PP_FIELDS ( .DCB))
	THEN
	    RETURN (.STATUS) ;

	!+
	! Remap all pasteboard buffers to which we are pasted, from the
	! bottom outward.
	!-
	CURR_PP = .DCB [DCB_A_PP_NEXT];
	WHILE .CURR_PP NEQ DCB [DCB_A_PP_NEXT]
	DO
	    BEGIN	! Remap all pasteboards
	    LOCAL
		PBCB : REF $PBCB_DECL;	! Addr of a pasteboard control
					! block
	    PBCB = .CURR_PP [PP_A_PBCB_ADDR];
	    IF NOT (STATUS = SMG$$CHECK_FOR_OUTPUT_PBCB ( .PBCB))
	    THEN
		RETURN ( .STATUS);	! Quit if any one of them fails

	    CURR_PP = .CURR_PP [PP_A_NEXT_DCB];	! To next pasting packet
	    END;	! Remap all pasteboards

	RETURN ( SS$_NORMAL);
	END	! Can do it now

    ELSE

	BEGIN	! Must delay until end_display_batch
	DCB [DCB_V_PP_MISMATCH] = 1;	! Mark it for later update
	END;	! Must delay until end_display_batch

    RETURN ( SS$_NORMAL);
    END;			! Routine SMG$CHANGE_VIRTUAL_DISPLAY
!<BLF/PAGE>

%SBTTL 'SMG$CHECK_FOR_OCCLUSION - Check to see if display is occluded'
GLOBAL ROUTINE SMG$CHECK_FOR_OCCLUSION (
					DISPLAY_ID,
					PASTEBOARD_ID,
					OCCLUSION_STATE
				       ) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This procedure determines if the given virtual display, as
!	pasted to the given pasteboard, is occluded by another virtual 
!	display.  The OCCLUSION state is set to:
!
!			1	: if virtual display is occluded
!			0	: if virtual display is not occluded.
!		not meaningfull : if status is not SS$_NORMAL.
!
!	The returned status reflects whether the question could be
!	answered at all.
!
! CALLING SEQUENCE:
!
!	ret_status.wlc.v = SMG$CHECK_FOR_OCCLUSION (
!				      DISPLAY_ID.rl.r,
!				      PASTEBOARD_ID.rl.r,
!				      OCCLUSION_STATE.wl.r)
! FORMAL PARAMETERS:
!
!	DISPLAY_ID.rl.r		Address of a display id.
!
!	PASTEBOARD_ID.rl.r	Address of a pasteboard id.
!
!	OCCLUSION_STATE.wl.r	Set to		1  if occluded
!						0  if not occluded
!
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	SS$_NORMAL	Normal success.  OCCLUSION_STATE calculated.
!
!	SMG$_NOTPASTED	Given virtual display is not pasted to given
!			pasteboard.
!
!	SMG$_INVPAS_ID	Invalid pasteboard id.
!
!	SMG$_INVDIS_ID	Invalid display id.
!
! SIDE EFFECTS:
!
!	NONE
!--

    BEGIN
    LOCAL
	STATUS,			! Status of subroutine calls

	PP : REF $PP_DECL,	! Address of relevant pasting packet

	PBCB: REF $PBCB_DECL,	! Address of Pasteboard Control Block

	DCB : REF $DCB_DECL;	! Address of Display Control Block

!+
! Validate number of arguments.
!-
    $SMG$VALIDATE_ARGCOUNT (3, 3);

!+
! Get DCB and PBCB addresses that go with these display ids and
! pasteboard ids.
!-
    $SMG$GET_DCB (.DISPLAY_ID, DCB);
    $SMG$GET_PBCB (.PASTEBOARD_ID, PBCB);

!+
! Try to find the pasting packet that binds these two.  Return
! SMG$_NOTPASTED it can't be located.
!-
    IF NOT (STATUS = SMG$$LOCATE_PP ( .DCB, .PBCB, PP))
    THEN
	RETURN (.STATUS);

!+
! Check to see if occluded and return appropriate OCCLUSION_STATE.
!-
    .OCCLUSION_STATE = ( IF .PP [PP_V_OCCLUDED] THEN 1	  ! Occluded
						ELSE 0);  ! Not occluded

    RETURN SS$_NORMAL;
    END;		! End of routine SMG$CHECK_FOR_OCCLUSION
!<BLF/PAGE>

%SBTTL 'SMG$CREATE_PASTEBOARD - Create Pasteboard'
GLOBAL ROUTINE SMG$CREATE_PASTEBOARD (
				NEW_PBID,
				OUT_DEVICE,
				PB_ROWS,
				PB_COLS,
				PRESERVE_SCREEN_FLAG
				     ) =
!++
! FUNCTIONAL DESCRIPTION:
!
!       This routine creates a new pasteboard -- returning its assigned
!	pasteboard_id.  OUT_DEVICE is the device upon which this
!	pasteboard is to be written.  If not supplied, output will flow
!	to SYS$OUTPUT.
!
!	If PB_ROWS and/or PB_COLS are provided, they are filled in with
!	the number of rows and number of columns on the physical device.
!
!	If called upon to create a 2nd pasteboard on a device that
!	already has a pasteboard associated with it, we simply return
!	the id of the already-existing pasteboard and the qualified
!	success SMG$_PASALREXI.
!
! CALLING SEQUENCE:
!
!       ret_status.wlc.v = SMG$CREATE_PASTEBOARD ( 
!				NEW_PBID.wl.r
!				[,OUT_DEVICE.rt.dx]
!				[,PB_ROWS.wl.r]
!				[,PB_COLS.wl.r]
!				[,PRESERVE_SCREEN_FLAG.rl.r])
!
! FORMAL PARAMETERS:
!
!       NEW_PBID.wl.r     Pasteboard id of newly-created pasteboard.
!
!	OUT_DEVICE.rt.dx	[Optional].  If supplied, this parameter
!				is the file specification or logical
!				name upon which the output associated
!				with this pasteboard will be written.
!				If omitted, output goes to SYS$OUTPUT.
!
!	PB_ROWS		[Optional].  If provided, it is filled in with
!			the number of rows on the physical device.
!
!	PB_COLS		[Optional].  If provided, it is filled in with
!			the number of columns on the physical device.
!
!	PRESERVE_SCREEN_FLAG	[Optional].  If provided, and if has a
!				value of 1, then the screen will not
!				be initially cleared.
!
!
! IMPLICIT INPUTS:
!
!       NONE
!
! IMPLICIT OUTPUTS:
!
!       NONE
!
! COMPLETION STATUS:
!
!       SS$_NORMAL      Normal successful completion
!       LIB$_INSVIRMEM  Insufficient virtual memory to allocate needed
!                       buffer.
!	SMG$_PASALREXI	Pasteboard already exists for this device
!       SMG$_WRONUMARG  Wrong number of arguments.
!
! SIDE EFFECTS:
!
!       NONE
!--

    BEGIN

    BUILTIN
	NULLPARAMETER;

    LOCAL
	FS_LEN : WORD INITIAL (0),	! Length of filespec name to use.

	FS_ADDR,		! Address of filespec name to use.

	STATUS,			! Status of subroutine calls

	TERM_TYPE,		! terminal type

	CLEAR_FLAG,		! TRUE means clear screen

	PBID,			! Id of pasteboard being created.

	PBCB : REF $PBCB_DECL;	! Address of pasteboard control block
				! being created.

    EXTERNAL ROUTINE

	SMG$$ERASE_PASTEBOARD,
	SMG$$OUT_OF_BAND_HANDLER;

    $SMG$VALIDATE_ARGCOUNT (1, 5);	! Test for right no. of args

    $SMG$GET_NEXT_PID ( PBID);	! Allocate a new PBID

!+
! Decide what output device is to receive the the output of this 
! pasteboard.
!-
    FS_LEN  = %CHARCOUNT  ('SYS$OUTPUT');	! Assume default
    FS_ADDR = UPLIT (BYTE ('SYS$OUTPUT'));

    IF NOT NULLPARAMETER (OUT_DEVICE)
    THEN
	BEGIN	! User-supplied filespec
	IF NOT (STATUS = LIB$ANALYZE_SDESC_R2 ( .OUT_DEVICE ;
						FS_LEN, FS_ADDR))
	THEN
	    RETURN ( .STATUS);
	END;	! User-supplied filespec

!+
! Create a PBCB.  Allocate buffers, etc.
! Extract the necessary device attributes and store in PBCB.
!-
    STATUS = SMG$$SETUP_TERMINAL_TYPE ( 
		.FS_ADDR,		   ! filespec addr
		.FS_LEN,		   ! Len of filespec
		 TERM_TYPE,		   ! Gets terminal type
		 PBCB);			   ! Address to receive address of PBCB

    IF NOT .STATUS
    THEN
	BEGIN
	PBD_V_PB_AVAIL [.PBID] = 0;	! Release PBID number
	RETURN (.STATUS)
	END;

!+
! Decide whether we want to handle this output device ourselves
! or use RMS to handle it.  We use RMS if the output device is
! not a terminal.  We also use RMS if the output device is a terminal,
! but one we can't handle, such as a hardcopy terminal.
!-

PBCB [PBCB_V_RMS] = (.PBCB[PBCB_B_CLASS]   NEQ DC$_TERM ) OR
		    (.PBCB[PBCB_B_DEVTYPE] EQL UNKNOWN  ) OR
		    (.PBCB[PBCB_B_DEVTYPE] EQL HARDCOPY );

!+
! Loop through all the pasteboards we currently have trying to find 
! one whose associated resultant name string is the same as the one we 
! just created.
! If we can find one, we have just created a 2nd pasteboard for the same
! physical device and we want to get rid of the pasteboard we just
! created and return to the caller the id of the pasteboard that already
! exists for this device.
! We do this only if the output device is a terminal.
! If the output device is a file, we assume that the user wants
! to create a new file for each pasteboard he creates.
!-

IF NOT .PBCB [PBCB_V_RMS]
THEN
    INCR I FROM 0 TO .PBD_L_COUNT -1
    DO
	BEGIN	! Loop thru pasteboards
	LOCAL
	    SEARCH_PBCB : REF $PBCB_DECL;	! Addr of pasteboard
						! control blocks that
						! we are inspecting.

	IF (SEARCH_PBCB = .PBD_A_PBCB [.I]) NEQ 0
	THEN
	    BEGIN	! A valid pasteboard address
	    IF .SEARCH_PBCB [PBCB_W_DEVNAM_LEN] EQL 
	       .PBCB        [PBCB_W_DEVNAM_LEN]
	    THEN
		BEGIN ! Lengths match
		IF CH$EQL ( .SEARCH_PBCB [PBCB_W_DEVNAM_LEN],	! length
			     SEARCH_PBCB [PBCB_T_DEVNAM],	! addr
			    .PBCB [PBCB_W_DEVNAM_LEN],		! length
			     PBCB [PBCB_T_DEVNAM])		! addr
		THEN
		    BEGIN	! Match found
		    LOCAL
			STATUS;		! Local status of subr. calls

		    !+
		    ! This physical device already has a pasteboard
		    ! associated with it.
		    ! Get rid of the one we just created.
		    ! First return PBID number we consumed -- we won't
		    ! be using it.
		    !-
		    PBD_V_PB_AVAIL [.PBID] = 0;

		    !+
		    ! Second deallocate the WCB that got allocated.
		    !-
		    IF .PBCB [PBCB_A_WCB] NEQ 0
		    THEN
			IF NOT (STATUS = SMG$$DEALLOCATE_WCB (
					   .PBCB [PBCB_A_WCB]) )
			THEN
			    RETURN (.STATUS);

		    !+
		    ! Next release output buffer.
		    !-
		    IF .PBCB [PBCB_A_OUTPUT_BUFFER] NEQ 0
		    THEN
			IF NOT ( STATUS = LIB$FREE_VM ( 
				 %REF (.PBCB [PBCB_W_OUTPUT_BUFSIZ]),
				 PBCB [PBCB_A_OUTPUT_BUFFER]))
			THEN
			    RETURN (.STATUS);

		    !+
		    ! Finally release the PBCB itself.
		    !-
		    IF NOT (STATUS = LIB$FREE_VM ( %REF (PBCB_K_SIZE),
						   PBCB))
		    THEN
			RETURN (.STATUS);

		    !+
		    ! Return as an id the id of the one that already 
		    ! exists.
		    !-
		    .NEW_PBID = .SEARCH_PBCB [PBCB_L_PBID];

		    !+
		    ! If caller requested number of rows and columns on
		    ! device, tell him.
		    !-
		    IF NOT NULLPARAMETER (PB_ROWS) 
		    THEN .PB_ROWS = .SEARCH_PBCB [PBCB_B_ROWS];

		    IF NOT NULLPARAMETER (PB_COLS) 
		    THEN .PB_COLS = .SEARCH_PBCB [PBCB_W_WIDTH];

		    RETURN ( SMG$_PASALREXI );
		    END;	! Match found
		END;  ! Lengths match
	    END;	! A valid pasteboard address
	END;	! Loop thru pasteboards

!+
! If we fall out of loop, none of our current pasteboards are pasted to
! the same device.  Continue with the creation process.
! Store pasteboard id in the PBCB itself.
!-
    PBCB [PBCB_L_PBID] = .PBID;

!+
! Store the original name (that the user specified) for this device
! in the PBCB.  This name may include a filename as well as a
! device name.
! First we allocate virtual memory for this buffer and
! then we store the length and address in the PBCB for future reference.
!-

    STATUS=LIB$GET_VM(%REF(.FS_LEN), PBCB[PBCB_A_OUTNAM]);
    IF NOT .STATUS THEN RETURN (.STATUS);
    PBCB[PBCB_W_OUTNAM_LEN]=.FS_LEN;
    CH$MOVE(.FS_LEN,.FS_ADDR,.PBCB[PBCB_A_OUTNAM]);

!+
! If device is a terminal, assign a channel to it.
! If the device is not a terminal, allocate a FAB and RAB
! and open the file for output using RMS.
!-

IF .PBCB[PBCB_V_RMS]
  THEN	BEGIN	! use RMS to open output

	!+
	! Allocate a FAB and RAB to be used to talk to this file.
	!-

	STATUS=LIB$GET_VM(%REF(FAB$C_BLN),PBCB[PBCB_A_FAB]);
	IF NOT .STATUS THEN RETURN .STATUS;

	STATUS=LIB$GET_VM(%REF(RAB$C_BLN),PBCB[PBCB_A_RAB]);
	IF NOT .STATUS THEN RETURN .STATUS;

	!+
	! Allocate a record buffer.
	! This will be one byte larger than the width of
	! the pasteboard because sometimes we will prepend
	! a formfeed to the record.
	!-

	STATUS=LIB$GET_VM(%REF(.PBCB[PBCB_W_WIDTH]+1),PBCB[PBCB_A_RBF]);
	IF NOT .STATUS THEN RETURN .STATUS;

	!+
	! Initialize the FAB and RAB.
	!-

	$FAB_INIT(	FAB	= .PBCB[PBCB_A_FAB],
			DNM	= 'SMGOUTPUT.LIS',	! default filename
			CTX	= .PBCB,	! why not? pass the PBCB as user context
			FAC	= PUT,		! write access only
			FNA	= .FS_ADDR,
			FNS	= .FS_LEN,
			ORG	= SEQ,		! sequential file
			FOP	= SQO,		! sequential operations only
			RAT	= CR,		! carriage control
			RFM	= VAR,		! variable length records
			MRS	= .PBCB[PBCB_W_WIDTH]+1); ! max record size

	$RAB_INIT(	RAB	= .PBCB[PBCB_A_RAB],
			CTX	= .PBCB,	! pass the PBCB as user context
			FAB	= .PBCB[PBCB_A_FAB],
			RBF	= .PBCB[PBCB_A_RBF],
			RAC	= SEQ);		! sequential output

	!+
	! Open the file for output.
	!-

	STATUS=$CREATE(	FAB	= .PBCB[PBCB_A_FAB]);
	IF NOT .STATUS THEN RETURN .STATUS;

	!+
	! Connect a record stream to the file.
	!-

	STATUS=$CONNECT( RAB	= .PBCB[PBCB_A_RAB]);
	IF NOT .STATUS THEN RETURN .STATUS;

	END	! use RMS to open output
  ELSE	BEGIN	! assigning channel

	LOCAL	NAME_DESC	: VECTOR[2],	! Fixed length descriptor
		ASYNC_EFN	: LONG,		! Longword to hold efn
		TTIOSB		: VECTOR[4,WORD],! IOSB for SENSE MODE
		CHARBUF		: BLOCK[12,BYTE];! 12-byte characteristics buffer

	!+
	! Create a fixed length descriptor for our device name string
	! for use by $ASSIGN.
	!-

	NAME_DESC[0]=.PBCB[PBCB_W_DEVNAM_LEN];
	NAME_DESC[1]= PBCB[PBCB_T_DEVNAM];

	!+
	! Assign the channel.
	! Put the resulting channel number in PBCB[PBCB_W_CHAN].
	!-

	STATUS=$ASSIGN(	DEVNAM	= NAME_DESC,
			CHAN	= PBCB[PBCB_W_CHAN]);
	IF NOT .STATUS THEN RETURN .STATUS;

	!+
	! Assign an asynchronous event flag.
	!-

	STATUS=LIB$GET_EF(ASYNC_EFN);
	IF NOT .STATUS THEN RETURN .STATUS;

	!+
	! Store the value into a byte in the PBCB.
	!-

	PBCB [PBCB_B_ASYNC_EFN] = .ASYNC_EFN;

	!+
	! Do a SENSE MODE QIO to get additional characteristics
	! of interest.
	! Ignore everything returned in the characteristics buffer.
	! (We already got that stuff.)
	! The I/O status block has neat things of interest.
	!-

	STATUS=$QIOW(	CHAN	= .PBCB[PBCB_W_CHAN],
			FUNC	= IO$_SENSEMODE,
			IOSB	= TTIOSB,
			P1	= CHARBUF,
			P2	= 12);
	IF NOT .STATUS THEN RETURN .STATUS;
	IF NOT .TTIOSB[0] THEN RETURN .TTIOSB[0];

	PBCB [PBCB_W_SPEED]  = .TTIOSB[1];
	PBCB [PBCB_W_FILL]   = .TTIOSB[2];
	PBCB [PBCB_B_PARITY] = .TTIOSB[3]

	END;	! assigning channel

!+
! Set up our exit block which is contained within the PBCB.
! This exit block is used to establish an exit handler for
! this terminal. When the exit handler is called,
! it will flush the output buffers.
! This guarantees that the user will see all his output even if
! his program exits and he doesn't manually flush the buffers.
!-

    PBCB [PBCB_A_EXIT_ADDR] = SMG$$PBCB_EXIT_HANDLER;
					! Address of our exit handler
    PBCB [PBCB_B_EXIT_ARGCNT] = 2;	! Our exit handler gets called with
					! two arguments.
    PBCB [PBCB_A_EXIT_RSN] = PBCB [PBCB_L_EXIT_REASON];
					! The first argument is the address
					! of the longword to receive the
					! exit reason.  This longword appears
					! elsewhere in the PBCB (not in
					! the exit block).
    PBCB [PBCB_A_EXIT_PBCB] = .PBCB;	! The second argument is the address
					! of this PBCB.  This is needed
					! because there are many PBCBs and
					! one exit routine serves them all.
					! There is a separate exit block for
					! each pasteboard.

!+
! Establish the exit handler, using the exit block just created.
!-

    STATUS=$DCLEXH(DESBLK=PBCB [PBCB_R_EXIT_BLOCK]);
    IF NOT .STATUS THEN RETURN .STATUS;

!+
! Now we do an incredible strange thing.
! We build a 10-byte routine in the PBCB to service out-of-band ASTs.
! The routine has the form:
!
!	0000	entry mask
!	  FA	CALLG
!	  6C	(AP)
!	  9F	absolute addressing
!    address	longword address of SMG$$OUT_OF_BAND_HANDLER
!	  04	RET
!
! Symbolically, the routine looks as follows:
!
!    ROUTINE BAND_HANDLER =
!	BEGIN
!	EXTERNAL ROUTINE SMG$$OUT_OF_BAND_HANDER : ADDRESSING_MODE(ABSOLUTE);
!	BUILTIN AP,CALLG;
!	RETURN CALLG(.AP,SMG$$OUT_OF_BAND_HANDLER);
!	END;
!
! However, we don't actually create this routine in BLISS and then
! move it into our structure, because we can't be guaranteed that
! BLISS will continue to generate the same code in future releases.
! Thus we create the entire routine ourselves.
! This code would have to change if we ever tried to run this
! on a machine with a new arhitecture.
!-

    PBCB[PBCB_W_ENTRY_MASK]	= %X'0000';
    PBCB[PBCB_B_CALLG]		= %X  'FA';
    PBCB[PBCB_B_REG_AP]		= %X  '6C';
    PBCB[PBCB_B_ABS]		= %X  '9F';
    PBCB[PBCB_A_BAND_HANDLER]	= SMG$$OUT_OF_BAND_HANDLER;
    PBCB[PBCB_B_RET]		= %X  '04';

!+
! Since all went well, we can now adjust the count of how many PBCB's
! we have and plug its address into the pasteboard directory.
!-
    PBD_L_COUNT = .PBD_L_COUNT + 1;

    PBD_A_PBCB [.PBID] = .PBCB;

!+
! Initially clear the screen (unless we are asked to preserve it).
!-

    CLEAR_FLAG=1;
    IF NOT NULLPARAMETER(PRESERVE_SCREEN_FLAG)
    THEN  CLEAR_FLAG=NOT ..PRESERVE_SCREEN_FLAG;

    IF .CLEAR_FLAG
    THEN
	BEGIN
	STATUS=SMG$$ERASE_PASTEBOARD(.PBCB);
	IF NOT .STATUS THEN RETURN .STATUS;
	END
    ELSE
	BEGIN	! Just pretend we cleared the screen.
	LOCAL	WCB	: REF $WCB_DECL;
	WCB=.PBCB[PBCB_A_WCB];

	CH$FILL(%C' ',.WCB[WCB_L_BUFSIZE],.WCB[WCB_A_TEXT_BUF]);
	CH$FILL(%C' ',.WCB[WCB_L_BUFSIZE],.WCB[WCB_A_SCR_TEXT_BUF]);
	CH$FILL(0,    .WCB[WCB_L_BUFSIZE],.WCB[WCB_A_ATTR_BUF]);
	CH$FILL(0,    .WCB[WCB_L_BUFSIZE],.WCB[WCB_A_SCR_ATTR_BUF]);

	IF .WCB[WCB_A_CHAR_SET_BUF] NEQ 0
	THEN
		BEGIN
		CH$FILL(0,.WCB[WCB_L_BUFSIZE],.WCB[WCB_A_CHAR_SET_BUF]);
		END;

	IF .WCB[WCB_A_SCR_CHAR_SET_BUF] NEQ 0
	THEN
		BEGIN
		CH$FILL(0,.WCB[WCB_L_BUFSIZE],.WCB[WCB_A_SCR_CHAR_SET_BUF]);
		END;

	!+
	! The physical cursor moves to (1,1).
	!-

	! WCB[WCB_W_CURR_CUR_ROW]=1;
	! WCB[WCB_W_OLD_CUR_ROW] =1;
	! WCB[WCB_W_CURR_CUR_COL]=1;
	! WCB[WCB_W_OLD_CUR_COL] =1;

	!+
	! The line characteristics get set back to 0.
	!-

	CH$FILL(0,.WCB[WCB_W_NO_ROWS]+1,.WCB[WCB_A_LINE_CHAR]);
	CH$FILL(0,.WCB[WCB_W_NO_ROWS]+1,.WCB[WCB_A_SCR_LINE_CHAR]);

	END;	! Just pretend we cleared the screen

!+
! If caller is interested in number of rows and columns on device, tell
! him.
!-
    IF NOT NULLPARAMETER(PB_ROWS) THEN .PB_ROWS = .PBCB [PBCB_B_ROWS];
    IF NOT NULLPARAMETER(PB_COLS) THEN .PB_COLS = .PBCB [PBCB_W_WIDTH];

!+
! Return the new pasteboard id to caller
!-
    .NEW_PBID = .PBID;

    RETURN (SS$_NORMAL)
    END;			! Routine SMG$CREATE_PASTEBOARD
!<BLF/PAGE>

%SBTTL 'SMG$DELETE_PASTEBOARD - Delete Pasteboard'
GLOBAL ROUTINE SMG$DELETE_PASTEBOARD ( PBID, CLEAR_SCREEN_FLAG ) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine terminates all use of a given physical display.
!	It deallocates the pasteboard control block and all its 
!	substructures.  It gets rid of the event flag and the channel 
!	number.  It removes any associated exit handler.
!
! CALLING SEQUENCE:
!
!       ret_status.wlc.v = SMG$DELETE_PASTEBOARD ( PBID.rl.r
!						 [,CLEAR_SCREEN_FLAG.rl.r])
!
! FORMAL PARAMETERS:
!
!       PBID.rl.r    		 Pasteboard id of pasteboard.
!
!	CLEAR_SCREEN_FLAG.rl.r	Set to 1 to clear the screen,
!				0 to keep it as is.
!				The default is to clear the screen.
!
! IMPLICIT INPUTS:
!
!       NONE
!
! IMPLICIT OUTPUTS:
!
!       NONE
!
! COMPLETION STATUS:
!
!       SS$_NORMAL      Normal successful completion
!       SMG$_WRONUMARG  Wrong number of arguments.
!	SS$_xyz		errors from $DASSGN
!	LIB$_xyz	errors from LIB$FREE_VM or LIB$FREE_EF
!	SMG$_xyz	errors from SMG$$FLUSH_BUFFER
!
! SIDE EFFECTS:
!
!       NONE
!--

BEGIN

BUILTIN
	NULLPARAMETER;

LOCAL

	STATUS,				! Status of subroutine calls

	CURR_PP : REF $PP_DECL,		! Pasting packet pointer

	WCB	: REF $WCB_DECL,	! Window control block.

	PBCB    : REF $PBCB_DECL;	! Address of pasteboard control
					! block

EXTERNAL ROUTINE

	SMG$$FORCE_SCROLL_REG,
	SMG$$ERASE_PASTEBOARD,
	SMG$$FLUSH_BUFFER,
	SMG$CHANGE_PBD_CHARACTERISTICS;

$SMG$VALIDATE_ARGCOUNT (1, 2);	! Test for right no. of args

$SMG$GET_PBCB (.PBID,PBCB);	! Get address of PBCB

!+
! Batch up the unpastes, so that the whole screen disappears at once.
!-
    IF NOT (STATUS = SMG$$BEGIN_PASTEBOARD_UPDATE_R1(.PBCB))
    THEN
	RETURN (.STATUS);

!+
! Walk chain of all DCB's pasted to this pasteboard and unpaste each.
!-
    CURR_PP = .PBCB [PBCB_A_PP_PREV];
    WHILE .CURR_PP NEQ PBCB [PBCB_A_PP_NEXT]
    DO
	BEGIN	! Walk chain
	LOCAL
	    DCB		: REF $DCB_DECL,	! Address of DCB involved
	    PP_BASE	: REF $PP_DECL;		! Base addr of this PP

	PP_BASE = .CURR_PP - PP_PBCB_QUEUE_OFFSET;  ! Since queue header
						    ! not at top of
						    ! structure.
	DCB = .PP_BASE [PP_A_DCB_ADDR];
	IF NOT (STATUS = SMG$$UNPASTE_VIRTUAL_DISPLAY (
				.DCB,			! DCB involved
				.PBCB))			! PBCB involved
	THEN
	    RETURN (.STATUS);

	CURR_PP = .PP_BASE [PP_A_PREV_PBCB]; ! Step to next PP
	END;	! Walk chain

    PBCB[PBCB_L_BATCH_LEVEL]=0;

!+
! If the user asked for the screen to be erased, then
! release lock on pasteboard, force output of now-blank screen, and
! flush it out.
!-
    IF NULLPARAMETER(CLEAR_SCREEN_FLAG)
    OR (NOT NULLPARAMETER(CLEAR_SCREEN_FLAG) AND ..CLEAR_SCREEN_FLAG)
    THEN
	BEGIN	! clear screen

!(b)	IF NOT (STATUS = SMG$$END_PASTEBOARD_UPDATE_R2(.PBCB))
!(b)	THEN
!(b)	    RETURN (.STATUS);

!(b)	IF NOT ( STATUS = SMG$$CHECK_FOR_OUTPUT_PBCB(.PBCB))
!(b)	THEN
!(b)	    RETURN (.STATUS);

!(b)	IF NOT (STATUS = SMG$$FLUSH_BUFFER(.PBCB))
!(b)	THEN 
!(b)	    RETURN (.STATUS);

! Note (b): Erase pasteboard should clear the screen and
!	    we can bypass flushing since the user is deleting his
!	    pasteboard anyhow.

	PBCB[PBCB_V_BUF_ENABLED]=0;

	IF NOT (STATUS = SMG$$ERASE_PASTEBOARD(.PBCB))
	THEN
	    RETURN (.STATUS);

	!+
	! Set terminal back to it's orignal width.
	! This requires batching to be off.
	!-

	IF .PBCB[PBCB_W_WIDTH] NEQ .PBCB[PBCB_W_ORIG_WIDTH]
	  THEN	BEGIN
		STATUS=SMG$CHANGE_PBD_CHARACTERISTICS(.PBID,
				%REF(.PBCB[PBCB_W_ORIG_WIDTH]));
		IF NOT .STATUS THEN RETURN .STATUS;
		STATUS=SMG$$FLUSH_BUFFER(.PBCB);
		IF NOT .STATUS THEN RETURN .STATUS
		END;

	END	! clear screen
    ELSE
	BEGIN
	SMG$$FLUSH_BUFFER(.PBCB);
	PBCB[PBCB_V_BUF_ENABLED]=0;
	END;

WCB=.PBCB[PBCB_A_WCB];

!+
! If a scrolling region is set (other than the full screen),
! then reset it now, being careful to leave the cursor alone
! even though SET SCROLLING REGION may move it.
! Note that if we never established any scrolling regions,
! the TOP_SCROLL line will be 0.
!-

IF    .PBCB[PBCB_W_TOP_SCROLL_LINE] NEQ 0
AND  (.PBCB[PBCB_W_TOP_SCROLL_LINE] NEQ 1   OR
      .PBCB[PBCB_W_BOT_SCROLL_LINE] NEQ .WCB[WCB_W_NO_ROWS])
THEN
    BEGIN	! Remove scrolling regions

    LOCAL

	FINAL_ROW,	! Final cursor row
	FINAL_COL;	! Final cursor column

    !+
    ! Construct escape sequence (possibly null if not a supporting terminal)
    ! to set the hardware scroll region to the full height of the screen.
    !-

    $SMG$GET_TERM_DATA(SET_SCROLL_REGION,
			1,
			.WCB [WCB_W_NO_ROWS]);

    !+
    ! Output BUFFER.
    !-

    IF .PBCB[PBCB_L_CAP_LENGTH] NEQ 0
    THEN
	BEGIN	! Issue the reset

	!+
	! Remember where the user left the physical cursor, since
	! changing scrolling regions might upset this.
	!-

	FINAL_ROW=.WCB[WCB_W_CURR_CUR_ROW];
	FINAL_COL=.WCB[WCB_W_CURR_CUR_COL];

	STATUS = SMG$$OUTPUT(.PBCB,.PBCB[PBCB_L_CAP_LENGTH],
				   .PBCB[PBCB_A_CAP_BUFFER]);
	IF NOT .STATUS THEN RETURN .STATUS;

	!+
	! Move the cursor back to where it was.
	!-

	IF NOT NULLPARAMETER(CLEAR_SCREEN_FLAG)
	AND NOT ..CLEAR_SCREEN_FLAG
	  THEN	BEGIN	! Restore final cursor position

		$SMG$GET_TERM_DATA(SET_CURSOR_ABS,.FINAL_ROW,.FINAL_COL);

		STATUS = SMG$$OUTPUT(.PBCB,.PBCB[PBCB_L_CAP_LENGTH],
					   .PBCB[PBCB_A_CAP_BUFFER]);
		IF NOT .STATUS THEN RETURN .STATUS

		END	! Restore final cursor position

	END	! Issue the reset

    END;	! Remove scrolling regions

!+
! Get rid of our exit handler.  Ignore a no handler found error.
!-

STATUS=$CANEXH(DESBLK=PBCB[PBCB_R_EXIT_BLOCK]);
IF (NOT .STATUS) AND (.STATUS NEQ SS$_NOHANDLER)
  THEN	RETURN	.STATUS;

!+
! Deallocate the WCB if there is one.
!-

IF .PBCB[PBCB_A_WCB] NEQ 0
  THEN	BEGIN	! getting rid of WCB

	STATUS=SMG$$DEALLOCATE_WCB(.PBCB[PBCB_A_WCB]);
	PBCB[PBCB_A_WCB]=0;				! safety
	IF NOT .STATUS THEN RETURN .STATUS

	END;	! getting rid of WCB

!+
! If there is a channel assigned, deassign it now.
! This automatically cancels any I/O on the channel.
! In particular, it removes any out-of-band ASTs that
! were enabled.
!-

IF .PBCB[PBCB_W_CHAN] NEQ 0
  THEN	BEGIN	! deassigning channel

	STATUS=$DASSGN(CHAN=.PBCB[PBCB_W_CHAN]);
	PBCB[PBCB_W_CHAN]=0;			! just in case we get called
						! again after returning an error
	IF NOT .STATUS THEN RETURN .STATUS

	END;	! deassigning channel

!+
! Free the event flags now.
! Ignore error if it was already free.
!-

IF .PBCB[PBCB_B_EFN] NEQ 0
  THEN	BEGIN
	STATUS=LIB$FREE_EF( %REF(.PBCB[PBCB_B_EFN]) );
	IF (NOT .STATUS) AND (.STATUS NEQ LIB$_EF_ALRFRE)
	  THEN	RETURN .STATUS;
	PBCB[PBCB_B_EFN]=0
	END;

IF .PBCB[PBCB_B_ASYNC_EFN] NEQ 0
  THEN	BEGIN
	STATUS=LIB$FREE_EF( %REF(.PBCB[PBCB_B_ASYNC_EFN]) );
	IF (NOT .STATUS) AND (.STATUS NEQ LIB$_EF_ALRFRE)
	  THEN	RETURN .STATUS;
	PBCB[PBCB_B_ASYNC_EFN]=0
	END;

!+
! Free the output buffer now.
!-

IF .PBCB[PBCB_A_OUTPUT_BUFFER] NEQ 0
  THEN	BEGIN	! freeing output buffer

	STATUS=LIB$FREE_VM(%REF (.PBCB[PBCB_W_OUTPUT_BUFSIZ] ),
			   PBCB[PBCB_A_OUTPUT_BUFFER] );
	PBCB[PBCB_A_OUTPUT_BUFFER]=0;
	IF NOT .STATUS THEN RETURN .STATUS

	END;	! freeing output buffer

!+
! Free the output filename.
!-

IF .PBCB[PBCB_W_OUTNAM_LEN] NEQ 0
  THEN	BEGIN	! freeing outname
	STATUS=LIB$FREE_VM(%REF (.PBCB[PBCB_W_OUTNAM_LEN] ),
			   PBCB[PBCB_A_OUTNAM] );
	PBCB[PBCB_W_OUTNAM_LEN]=0;
	IF NOT .STATUS THEN RETURN .STATUS
	END;	! freeing outname

!+
! Close the output file, if there was one.
!-

IF .PBCB[PBCB_A_FAB] NEQ 0
  THEN	BEGIN	! Close output file
	STATUS=$CLOSE(	FAB = .PBCB[PBCB_A_FAB]);
	IF NOT .STATUS THEN RETURN .STATUS
	END;	! Close output file

!+
! Free the record buffer, if there was one.
!-

IF .PBCB[PBCB_A_RBF] NEQ 0
  THEN	BEGIN
	STATUS=LIB$GET_VM(%REF(.PBCB[PBCB_W_WIDTH]+1),PBCB[PBCB_A_RBF]);
	PBCB[PBCB_A_RBF]=0;
	IF NOT .STATUS THEN RETURN .STATUS;
	END;

!+
! Free any FAB or RAB that was created.
!-

IF .PBCB[PBCB_A_FAB] NEQ 0
  THEN	BEGIN	! freeing FAB
	STATUS=LIB$FREE_VM(%REF (FAB$C_BLN),
			   PBCB[PBCB_A_FAB] );
	PBCB[PBCB_A_FAB]=0;
	IF NOT .STATUS THEN RETURN .STATUS
	END;	! freeing FAB

IF .PBCB[PBCB_A_RAB] NEQ 0
  THEN	BEGIN	! freeing RAB
	STATUS=LIB$FREE_VM(%REF (RAB$C_BLN),
			   PBCB[PBCB_A_RAB] );
	PBCB[PBCB_A_RAB]=0;
	IF NOT .STATUS THEN RETURN .STATUS
	END;	! freeing RAB

!+
! Now go free the PBCB itself.
!-

IF NOT (STATUS=LIB$FREE_VM (%REF (PBCB_K_SIZE), PBCB)) 
THEN 
    RETURN (.STATUS);

!+
! Since all went well, we can now adjust the count of how many PBCB's
! we have and remove its address from the pasteboard directory.
!-

PBD_V_PB_AVAIL [..PBID] = 0;

PBD_L_COUNT = .PBD_L_COUNT - 1;

PBD_A_PBCB [..PBID] = 0;

RETURN	SS$_NORMAL

END;			! Routine SMG$DELETE_PASTEBOARD
!<BLF/PAGE>

%SBTTL 'SMG$CREATE_VIRTUAL_DISPLAY - Create Virtual Display'
GLOBAL ROUTINE SMG$CREATE_VIRTUAL_DISPLAY (
                                           NUM_ROWS,     ! height
                                           NUM_COLS,     ! width
                                           NEW_DISPLAY_ID,
                                           DISPLAY_ATTRIBUTES,
                                           VIDEO_ATTRIBUTES,
					   CHAR_SET
                                          ) =
!++
! FUNCTIONAL DESCRIPTION:
!
!       This routine creates a new virtual display -- returning its 
!       assigned display_id.  Its initial contents are blanks with
!	video attributes set to those specified or zero.  The cursor 
!	will be at row 1 column 1.
!
! CALLING SEQUENCE:
!
!       ret_status.wlc.v = SMG$CREATE_VIRTUAL_DISPLAY ( 
!                               NUM_ROWS.rl.r,           ! Height
!                               NUM_COLS.rl.r,           ! Width
!                               NEW_DISPLAY_ID.wl.r
!                               [,DISPLAY_ATTRIBUTES.rl.r]
!                               [,VIDEO_ATTRIBUTES.rl.r]
!				[,CHAR_SET.rl.r])
!
! FORMAL PARAMETERS:
!
!       NUM_ROWS.rl.r    Number of rows in new virtual display.
!
!       NUM_COLS.rl.r    Number of columns in new virtual display.
!
!       NEW_DISPLAY_ID.wl.r     Virtual display id of newly-created
!                               virtual display.
!
!       DISPLAY_ATTRIBUTES.rl.r The default display attributes.
!
!			SMG$M_BORDER if virtual display is to be 
!				     displayed with a border.
!
!			SMG$M_TRUNC_ICON if an icon should be displayed
!				     when text overflows the display bounds.
!
!			SMG$M_DISPLAY_CONTROLS if carriage controls (CR, LF,
!				     (FF, VT, HT) should be displayed instead
!				     of executed.
!			If omitted, none of the attributes will be set.
!
!       VIDEO_ATTRIBUTES.rl.r   The default rendition code to be
!                       applied to all output to this display unless 
!                       overridden on a particular output call.
!			If not supplied, default will be all zero (no
!			attributes).
!
!                       Values:
!
!                       SMG$M_BLINK	displays characters blinking.
!
!                       SMG$M_BOLD	displays characters in 
!					higher-than-normal intensity.
!
!                       SMG$M_REVERSE	displays characters in reverse 
!					video -- that is, using the
!					opposite default rendition of 
!					the virtual display.
!
!                       SMG$M_UNDERLINE	displays characters underlined.
!
!	CHAR_SET.rb.r	[Optional].  If provided, specifies the default
!			character set to be used for this display.
!			Recognized values are:
!					SMG$C_UNITED_KINGDOM
!					SMG$C_ASCII (default)
!					SMG$C_SPEC_GRAPHICS
!					SMG$C_ALT_CHAR
!					SMG$C_ALT_GRAPHICS
!
! IMPLICIT INPUTS:
!
!       NONE
!
! IMPLICIT OUTPUTS:
!
!       NONE
!
! COMPLETION STATUS:
!
!       SS$_NORMAL      Normal successful completion
!       LIB$_INSVIRMEM  Insufficient virtual memory to allocate needed
!                       buffer.
!       SMG$_INVARG     Unrecognized Video Attributes
!                    or Unrecognized Display Attributes
!       SMG$_WRONUMARG  Wrong number of arguments.
!
! SIDE EFFECTS:
!
!       NONE
!--
    BEGIN
    BUILTIN
	NULLPARAMETER;

    $SMG$VALIDATE_ARGCOUNT (3, 6);	! Test for right no. of args

    RETURN (SMG$$CREATE_VIRTUAL_DISPLAY(
		.NUM_ROWS,
		.NUM_COLS,
		.NEW_DISPLAY_ID,	! Gets the DCB address for the display created
		(IF NOT NULLPARAMETER(DISPLAY_ATTRIBUTES)
		  THEN	.DISPLAY_ATTRIBUTES
		  ELSE	UPLIT(0) ),
		(IF NOT NULLPARAMETER(VIDEO_ATTRIBUTES)
		  THEN	.VIDEO_ATTRIBUTES
		  ELSE	UPLIT(0) ),
		(IF NOT NULLPARAMETER(CHAR_SET)
		  THEN	.CHAR_SET
		  ELSE	UPLIT(0) ) ) );

    END;			! Routine SMG$CREATE_VIRTUAL_DISPLAY
!<BLF/PAGE>

%SBTTL 'SMG$DELETE_VIRTUAL_DISPLAY - Delete virtual display'
GLOBAL ROUTINE SMG$DELETE_VIRTUAL_DISPLAY ( DISPLAY_ID ) =
!++
! FUNCTIONAL DESCRIPTION:
!
!       This routine deletes a virtual display.  It is automatically
!       "unpasted" from any pasteboards on which it is pasted and
!       its associated buffer space is deallocated.
!
! CALLING SEQUENCE:
!
!       ret_status.wlc.v = SMG$DELETE_VIRTUAL_DISPLAY (DISPLAY_ID.rl.r )
!
! FORMAL PARAMETERS:
!
!       DISPLAY_ID.rl.r         Id of virtual display to be deleted.
!
! IMPLICIT INPUTS:
!
!       NONE
!
! IMPLICIT OUTPUTS:
!
!       NONE
!
! COMPLETION STATUS:
!
!       SS$_NORMAL      Normal successful completion
!       SMG$_INVDIS_ID  Invalid display id.
!       SMG$_WRONUMARG  Wrong number of arguments.
!
! SIDE EFFECTS:
!
!       NONE
!--
    BEGIN
    LOCAL
	STATUS,				! Status of subroutine calls
	CURR_PP : REF $PP_DECL,		! Addr of current pasting packet
	DCB	: REF $DCB_DECL;	! Addr of display control block

    $SMG$VALIDATE_ARGCOUNT (1, 1);	! Test for right no. of args

    $SMG$GET_DCB ( .DISPLAY_ID, DCB);	! Get DCB address

    CURR_PP = .DCB [DCB_A_PP_NEXT];

!+
! Loop through all pasteboards we're pasted to, undoing our linkage to
! each.
!-

    WHILE .CURR_PP NEQ DCB [DCB_A_PP_NEXT] ! While any remain...
    DO
	BEGIN	! Overall loop
	LOCAL
	    PBCB : REF $PBCB_DECL;	! Addr of pasteboard control blk

	PBCB = .CURR_PP [PP_A_PBCB_ADDR];

	!+
	! Update pasting packet pointer to next pasting packet, before
	! the unpaste operation makes current on go away.
	!-
	CURR_PP = .CURR_PP [PP_A_NEXT_DCB];

	!+
	! Now we can unpaste this linkage.
	!-
	IF NOT (STATUS = SMG$$UNPASTE_VIRTUAL_DISPLAY (
						.DCB,
						.PBCB ))
	THEN
	    RETURN (.STATUS);

	END;	! Overall loop

!+
! Having successfully severed our linkage with all the pasteboards to
! to which we were pasted, we can now get rid of the DCB itself.
! Before we can delete this DCB we must check to see if there is a
! backup DCB in existance.  If so, call outselves recursively to delete
! the backup DCB first.
    IF .DCB [DCB_A_BACKUP_DCB] NEQ 0
    THEN
	IF NOT ( STATUS =SMG$DELETE_VIRTUAL_DISPLAY (
					DCB [DCB_A_BACKUP_DCB])) 
	THEN 
	    RETURN (.STATUS);

! One remaining chore is to first release the buffer areas whose 
! addresses are in the DCB.  Recall that the two buffer (text and 
! attr) were initially allocated as a double-size buffer and split in 
! two.  This means we can return both at once by supplying the address 
! of the the text buffer and a length equal to twice its size.
!-
    IF NOT (STATUS = LIB$FREE_VM ( %REF (2* .DCB [DCB_L_BUFSIZE]), 
				   DCB [DCB_A_TEXT_BUF])) 
    THEN 
	RETURN (.STATUS);

!+
! Free the line characteristics vector
!-
    IF NOT (STATUS = LIB$FREE_VM (%REF ( .DCB [DCB_W_NO_ROWS] +1),
				  DCB [DCB_A_LINE_CHAR]))
    THEN
	RETURN ( .STATUS);

!+
! Free the char_set buffer if there is one.
!-
    IF .DCB [DCB_A_CHAR_SET_BUF] NEQ 0
    THEN
	IF NOT (STATUS = LIB$FREE_VM ( DCB [DCB_L_BUFSIZE], 
				       DCB [DCB_A_CHAR_SET_BUF])) 
	THEN 
	    RETURN (.STATUS);

!+
! If we have a dynamic string containing a border label, free the string
!-
    IF .DCB [DCB_V_BORDERED]
    THEN
	BEGIN	! Bordered
	LOCAL
	    DESC : REF BLOCK [8,BYTE];	! Pointer to dynamic string
					! descriptor in DCB
	DESC = DCB [DCB_Q_LABEL_DESC];
	IF .DESC [DSC$A_POINTER] NEQ 0
	THEN
	    IF NOT (STATUS = LIB$SFREE1_DD ( .DESC)) 
	    THEN 
		RETURN (.STATUS);
	END;	! Bordered
!+
! Now the DCB itself...
! Before freeing this area, we clobber the byte that makes it
! recognizable as a DCB.  That way, if someone inadvertantly tries to
! pass us this DCB address as a DCB after having deleted the virtual
! display, we can tell that it no longer is a valid DCB.
!-
    DCB [DCB_B_STRUCT_TYPE] = 0;
    RETURN (LIB$FREE_VM (%REF ( DCB_K_SIZE), DCB ));

    END;			! Routine SMG$DELETE_VIRTUAL_DISPLAY
!<BLF/PAGE>

%SBTTL 'SMG$GET_DISPLAY_ATTR - Get  display attributes'
GLOBAL ROUTINE SMG$GET_DISPLAY_ATTR (
                                DISPLAY_ID,
                                HEIGHT,
                                WIDTH,
                                DISPLAY_ATTRIBUTES,
                                VIDEO_ATTRIBUTES,
				CHAR_SET
                                        ) =
!++
! FUNCTIONAL DESCRIPTION:
!
!       This routine returns attributes of the virtual display.
!
! CALLING SEQUENCE:
!
!       ret_status.wlc.v = SMG$GET_DISPLAY_ATTR (
!                               DISPLAY_ID.rl.r,
!                               HEIGHT.wl.r,
!                               WIDTH.wl.r,
!                               [,DISPLAY_ATTRIBUTES.wl.r]
!                               [,VIDEO_ATTRIBUTES.wl.r]
!				[,CHAR_SET.wl.r])
!
! FORMAL PARAMETERS:
!
!       DISPLAY_ID.rl.r         The id of the display for which the
!				information is requested.
!
!       HEIGHT.wl.r             Height of display in rows
!
!       WIDTH.wl.r              Width of display in columns
!
!       DISPLAY_ATTRIBUTES.wl.r Optional.  If provided, the current
!			default display attributes will be returned.
!			These may be:
!
!			SMG$M_BORDER if display is displayed with a 
!			border.
!
!       VIDEO_ATTRIBUTES.wl.r   Optional.   If provided, the current
!			default video attributes are returned.  These
!			values may be:
!
!                       SMG$M_BLINK	displays characters blinking.
!
!                       SMG$M_BOLD	displays characters in 
!					higher-than-normal intensity.
!
!                       SMG$M_REVERSE	displays characters in reverse 
!					video -- that is, using the
!					opposite default rendition of 
!					the virtual display.
!
!                       SMG$M_UNDERLINE	displays characters underlined.
!
!	CHAR_SET.wb.r	Optional.  If provided, the current default
!			character set code is returned.
!			Possible values are:
!					SMG$C_UNITED_KINGDOM
!					SMG$C_ASCII (default)
!					SMG$C_SPEC_GRAPHICS
!					SMG$C_ALT_CHAR
!					SMG$C_ALT_GRAPHICS
!
! IMPLICIT INPUTS:
!
!       NONE
!
! IMPLICIT OUTPUTS:
!
!       NONE
!
! COMPLETION STATUS:
!
!       SS$_NORMAL      Normal successful completion
!       SMG$_WRONUMARG  Wrong number of arguments
!
! SIDE EFFECTS:
!
!       NONE
!--
    BEGIN
    BUILTIN
	NULLPARAMETER;

    LOCAL
	DCB : REF $DCB_DECL;		! Addr of display control block

    $SMG$VALIDATE_ARGCOUNT (3, 6);	! Test for right no. of args

    $SMG$GET_DCB ( .DISPLAY_ID, DCB);	! Get DCB address

    .HEIGHT = .DCB [DCB_W_NO_ROWS];
    .WIDTH  = .DCB [DCB_W_NO_COLS];

    IF NOT NULLPARAMETER (DISPLAY_ATTRIBUTES) 
    THEN .DISPLAY_ATTRIBUTES = .DCB [DCB_B_DEF_DISPLAY_ATTR];

    IF NOT NULLPARAMETER (VIDEO_ATTRIBUTES) 
    THEN .VIDEO_ATTRIBUTES   = .DCB [DCB_B_DEF_VIDEO_ATTR];

    IF NOT NULLPARAMETER (CHAR_SET)
    THEN .CHAR_SET = .DCB [DCB_B_DEF_CHAR_SET];

    RETURN (SS$_NORMAL);
    END;			! Routine SMG$GET_DISPLAY_ATTR
!<BLF/PAGE>

%SBTTL 'SMG$LABEL_BORDER - Specify label for border'
GLOBAL ROUTINE SMG$LABEL_BORDER (
				  DISPLAY_ID,
				  LABEL_TEXT,
				  POSITION,
				  UNITS,
				  RENDITION_SET,
				  RENDITION_COMPLEMENT,
				  CHAR_SET
				) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine allows the caller to specify what label text is to
!	be used with this display.  If the specified DISPLAY_ID does not
!	have the display attribute of SMG$M_BORDER, this attribute is 
!	forced.
!
!	If the text parameter is not supplied, this virtual display
!	no longer has a border text associated with it -- it becomes
!	an unlabeled border.  If a valid text string is provided, it
!	replaces the current label text for this border.
!	If the text (as positioned within the border) does not fit
!	fully within the border, SMG$_INVARG is returned.
!	E.g.
!		+-------LABEL
!		|        |
!		+--------+
!
!
!	POSITION and UNITS as a pair specify the starting position of 
!	the label text within the border.
!	If POSITION is omitted, the top border is assumed.  If UNITS is
!	omitted, a starting position will be chosen so as to center the
!	text either horizontally or vertically -- depending on implicit
!	or explicit POSITION.
!	If both are omitted, the text will be centered in the top border
!	line.
!
!	The following encoding is used:
!
!	POSITION			UNITS			SYMBOLIC
!	--------			-----			--------
!	0 = Top border line		Starting column number	SMG$K_TOP
!	1 = Bottom border line		Starting column number	SMG$K_BOTTOM
!	2 = Left border line		Starting row number	SMG$K_LEFT
!	3 = Right border line		Starting row number	SMG$K_RIGHT
!
!	Examples:
!
!	POSITION=0, UNITS=4		POSITION=1, UNITS=4
!
!	+--LABEL----------------+	+-----------------------+
!	|			|	|			|
!	|			|	|			|
!	|			|	|			|
!	|			|	|			|
!	|			|	|			|
!	|			|	|			|
!	+-----------------------+	+--LABEL----------------+
!	
!
!	POSITION=2, UNITS=3		POSITION=3, UNITS=3
!
!	+-----------------------+	+-----------------------+
!	|			|	|			|
!	L			|	|			L
!	A			|	|			A
!	B			|	|			B
!	E			|	|			E
!	L			|	|			L
!	|			|	|			|
!	+-----------------------+	+-----------------------+
!	
!
! CALLING SEQUENCE:
!
!       ret_status.wlc.v = SMG$LABEL_BORDER (
!					DISPLAY_ID.rl.r
!					[,LABEL_TEXT.rt.dx]
!					[,POSITION.rl.r]
!					[,UNITS.rl.r]
!					[,RENDITION_SET.rl.r]
!					[,RENDITION_COMPLEMENT.rlr.]
!					[,CHAR_SET.rl.r])
!
! FORMAL PARAMETERS:
!
!	DISPLAY_ID.rl.r	The display id of the virtual display whose
!			border is to be labeled.  This display must have
!			the display attribute of SMG$M_BORDER.
!
!	LABEL_TEXT.rt.dx	[Optional].  If supplied becomes the new
!				label for this display's border.  If
!				omitted, display becomes unlabeled.
!
!	POSITION.rl.r	[Optional].
!			Specifies which border will contain label.
!			If omitted, default to top border.
!
!	UNITS.rl.r	[Optional].
!			Specifies where within the border the text label
!			will start.
!			If omitted, center in line indicated by POSITION
!
!	RENDITION_SET.rl.r	[Optional].
!				Each 1 bit attribute in this parameter
!				causes the corresponding attribute to
!				be set in the display.  (See below for
!				list of settable attributes.)
!
!	RENDITION_COMPLEMENT.rl.r	[Optional].
!				Each 1 bit attribute in this parameter
!				causes the corresponding attribute to
!				be complemented in the display.  (See
!				below for list of complementable
!				attributes.)
!
!	If the same bit is specified in both the RENDITION_SET parameter
!	and in the RENDITION_COMPLEMENT parameter, the application is
!	RENDITION_SET followed by RENDITION complement.  Using these two
!	parameters together the caller can exercise arbitrary and
!	independent control over each attribute on a single call.  On an
!	attribute by attribute basis he can cause the following
!	transformations:
!
!		SET	COMPLEMENT	Action
!		---	__________	______
!		0	0		Attribute unchanged.
!		1	0		Attribute set to "on"
!		0	1		Attribute set to complement of
!					current setting.
!		1	1		Attribute set to "off".
!
!
!	Attributes which can be manipulated in this manner are:
!
!	SMG$M_BLINK  displays characters blinking.
!	SMG$M_BOLD  displays characters in higher-than-normal 
!		      intensity.
!	SMG$M_REVERSE  displays characters in reverse video -- that is, 
!		      using the opposite default rendition of the 
!		      virtual display.
!	SMG$M_UNDERLINE  displays characters underlined.
!
!	CHAR_SET.rl.r	[Optional].  If provided, the character set to
!			be used in displaying the label.
!			Recognized values are:
!					SMG$C_UNITED_KINGDOM
!					SMG$C_ASCII (default)
!					SMG$C_SPEC_GRAPHICS
!					SMG$C_ALT_CHAR
!					SMG$C_ALT_GRAPHICS
!
!
! IMPLICIT INPUTS:
!
!       None
!
! IMPLICIT OUTPUTS:
!
!       None
!
! COMPLETION STATUS:
!
!       SS$_NORMAL      Normal successful completion
!       SMG$_INVDIS_ID  Invalid virtual display id.
!	SMG$_INVARG	Positioning and/or units when considered with
!			length of text results in a position that is
!			outside of the border area.
!       SMG$_WRONUMARG  Wrong number of arguments.
!
! SIDE EFFECTS:
!
!       NONE
!--
    BEGIN

    LITERAL
	K_SET_ARG = 5,
	K_COMP_ARG= 6;

    BUILTIN
	NULLPARAMETER;

    LOCAL
	LUNITS,				! Implicit or explicit UNITS
	LPOS,				! Implicit or explicit POSITION
	REND_CODE,			! Rendition to be applied to
					! border label
	STATUS,				! Status of subroutine calls
	DESC : REF BLOCK [,BYTE],	! Pointer to dynamic string
					! descriptor in DCB for border
					! label.
	DCB : REF $DCB_DECL;		! Addr. of display control block

    $SMG$VALIDATE_ARGCOUNT (1, 7);	! Test for right no. of args

    $SMG$GET_DCB ( .DISPLAY_ID, DCB);	! Get addr of DCB

!+
! Get a copy of the label.
!-
    DESC = DCB [DCB_Q_LABEL_DESC];

    IF NULLPARAMETER (LABEL_TEXT)
    THEN
	BEGIN	! No text specified
	RETURN (LIB$SFREE1_DD ( .DESC));
	END;	! No text specified

    IF NOT (STATUS = LIB$SCOPY_DXDX (.LABEL_TEXT, .DESC))
    THEN
	RETURN (.STATUS);

!+
! Check to see if combination of POSITION and UNITS fit.
!-
    LPOS = ( IF NOT NULLPARAMETER (POSITION) THEN ..POSITION
				      ELSE 0);	! Default to top row

    CASE .LPOS FROM SMG$K_TOP TO SMG$K_RIGHT OF
    SET
	[SMG$K_TOP,SMG$K_BOTTOM]:	! Top or bottom row
	    BEGIN
	    LUNITS = ( IF NOT NULLPARAMETER (UNITS)
		       THEN ..UNITS
		       ELSE	! Center horizontally
			   ((.DCB[DCB_W_NO_COLS] -.DESC [DSC$W_LENGTH])
			     / 2) + 2 );

	    IF .LUNITS LEQ 0		OR
	       .LUNITS + .DESC[DSC$W_LENGTH] GTR .DCB [DCB_W_NO_COLS] +2
	    THEN 
		BEGIN
		LIB$SFREE1_DD (.DESC) ; ! Release our dynamic string
		RETURN (SMG$_INVARG);
		END;
	    END;

	[SMG$K_LEFT,SMG$K_RIGHT]:	! Left or right column
	    BEGIN
	    LUNITS = ( IF NOT NULLPARAMETER (UNITS)
		       THEN ..UNITS
		       ELSE	! Center vertically
			   ((.DCB[DCB_W_NO_ROWS] -.DESC[DSC$W_LENGTH]) 
			     / 2) + 2 );

	    IF .LUNITS LEQ 0		OR
	       .LUNITS + .DESC[DSC$W_LENGTH] GTR .DCB [DCB_W_NO_ROWS] +2
	    THEN 
		BEGIN
		LIB$SFREE1_DD (.DESC) ; ! Release our dynamic string
		RETURN (SMG$_INVARG);
		END;
	    END;

	[OUTRANGE]:
	    RETURN (SMG$_INVARG);
    TES;

    DCB [DCB_B_LABEL_POS] = .LPOS;
    DCB [DCB_W_LABEL_UNITS] = .LUNITS;

!+
! If UNITS parameter was omitted we centered the label.  Make a note of
! this fact so that if he later does a CHANGE_VIRTUAL_DISPLAY we can
! again center it in its new "center".
    DCB [DCB_V_LABEL_CENTER] = 0;
    IF NULLPARAMETER (UNITS) 
    THEN 
	DCB [DCB_V_LABEL_CENTER] = 1;

!+
! Calc. REND_CODE as a function of callers rendition arguments and
! the default rendition in the DCB.
!-
    $SMG$SET_REND_CODE (K_SET_ARG, K_COMP_ARG);
				! macro to use caller's args if present

    DCB [DCB_B_LABEL_REND] = .REND_CODE;

!+
! Deal with alternate character set.
!-
    IF NOT NULLPARAMETER(CHAR_SET)
    THEN
	BEGIN
	CASE ..CHAR_SET FROM SMG$C_UNITED_KINGDOM 
			  TO SMG$C_ALT_GRAPHICS OF
	SET
	    [SMG$C_UNITED_KINGDOM, 
	     SMG$C_ASCII, 
	     SMG$C_SPEC_GRAPHICS,
	     SMG$C_ALT_CHAR, 
	     SMG$C_ALT_GRAPHICS]:
				DCB [DCB_B_LABEL_CHAR_SET] = ..CHAR_SET;

	    [INRANGE, OUTRANGE]:
				RETURN (SMG$_INVARG);
	TES;
	END
    ELSE	! Use default for virtual display
	DCB [DCB_B_LABEL_CHAR_SET] = .DCB [DCB_B_DEF_CHAR_SET];

    DCB [DCB_V_BORDERED] = 1;	! Force bordered attribute in case it
				! wasn't previously.
!+
! We now need to recalculate the constants in the pasting packet.
! We may be making the transition from unbordered to bordered, so 
! this virtual display now has a bigger footprint in the pasteboard 
! buffer, and some display which previously was not occluded may now be.
! Even if we were previously bordered, the size and position of our
! label may have changed.
! If we are not batched at the display level, recalc. pasting packet 
! constants and initiate output.  Else, just remember that we need to do
! it later when batch level drops to zero.
!-
    IF .DCB [DCB_L_BATCH_LEVEL] EQL 0
    THEN
	BEGIN	! Do it now
	IF NOT (STATUS = SMG$$RECALC_PP_FIELDS ( .DCB))
	THEN
	    RETURN (.STATUS);

	RETURN ( SMG$$CHECK_FOR_OUTPUT_DCB ( .DCB, SMG$C_LABEL_BORDER));
	END	! Do it now

    ELSE

	BEGIN	! Defer the action
	DCB [DCB_V_PP_MISMATCH] =1; ! Remember for later
	END;	! Defer the action

    RETURN (SS$_NORMAL);
    END;			! Routine SMG$LABEL_BORDER
!<BLF/PAGE>

%SBTTL 'SMG$MOVE_VIRTUAL_DISPLAY - Move previously pasted virtual display'
GLOBAL ROUTINE SMG$MOVE_VIRTUAL_DISPLAY (
                                           DISPLAY_ID,
                                           PASTEBOARD_ID,
                                           PASTEBOARD_ROW,
                                           PASTEBOARD_COL
                                         ) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	The specified virtual display is moved with respect to the
! 	position where it is currently pasted to the specified pasteboard
!	preserving the pasting order.  If the display is not currently
!	pasted, it is pasted at the top of the pasting order in the
!	position specified.
!	This call is not permitted while display batching is in effect.
!
! CALLING SEQUENCE:
!
!       ret_status.wlc.v = SMG$MOVE_VIRTUAL_DISPLAY ( 
!                                             DISPLAY_ID.rl.r,
!                                             PASTEBOARD_ID.rl.r,
!                                             PASTEBOARD_ROW.rl.r,
!                                             PASTEBOARD_COL.rl.r)
!
! FORMAL PARAMETERS:
!
!       DISPLAY_ID.rl.r         Id of virtual display to be moved.
!
!       PASTEBOARD_ID.rl.r      The pasteboard id of the pasteboard on 
!				which the movement is to take place.
!
!       PASTEBOARD_ROW.rl.r     Row on pasteboard which is to contain
!                               row 1 of the specified virtual display.
!
!       PASTEBOARD_COL.rl.r     Column on pasteboard which is to contain
!                               column 1 of the specified virtual
!                               display.
!
! IMPLICIT INPUTS:
!
!       None
!
! IMPLICIT OUTPUTS:
!
!       None
!
! COMPLETION STATUS:
!
!       SS$_NORMAL      Normal successful completion
!       SMG$_INVDIS_ID  Invalid virtual display id.
!       SMG$_INVPAS_ID  Invalid pasteboard id.
!       SMG$_WRONUMARG  Wrong number of arguments.
!	SMG$_ILLBATFNC	Display is being batched, this operation is illegal.
!
! SIDE EFFECTS:
!
!       NONE
!--
    BEGIN
    BUILTIN
	AP,
	CALLG;

    LOCAL
	STATUS,				! Status of subroutine calls

	PP	: REF $PP_DECL,		! Addr of the pasting packet
	DCB	: REF $DCB_DECL,	! Addr. of display control block
	PBCB	: REF $PBCB_DECL;	! Addr of pasteboard control block

    $SMG$VALIDATE_ARGCOUNT (4, 4);	! Test for right no. of args

!+
! Get addresses of associated virtual display control block and
! pasteboard control block, validating both the display id and the
! pasteboard id.
!-
    $SMG$GET_DCB ( .DISPLAY_ID, DCB);		! Get addr of DCB
    $SMG$GET_PBCB ( .PASTEBOARD_ID, PBCB);	! Get addr of PBCB

!+
! Give an error if the display is batched.
!-

    IF .DCB[DCB_L_BATCH_LEVEL] NEQ 0
    THEN
	RETURN	SMG$_ILLBATFNC;

!+
! Determine if this virtual display is already pasted to this
! pasteboard.  If it is we can do the MOVE.  If it isn't we'll do a
! PASTE at the specified position.
!-
    IF NOT SMG$$LOCATE_PP( .DCB, .PBCB, PP)
    THEN
	RETURN SMG$$PASTE_VIRTUAL_DISPLAY(.DCB,.PBCB,
			.PASTEBOARD_ROW,.PASTEBOARD_COL);

!+
! Set new row and column into pasting packet
!-
    PP [PP_W_ROW]	= ..PASTEBOARD_ROW;
    PP [PP_W_COL]	= ..PASTEBOARD_COL;

!+
! Recalc. occlusions.
!-
    IF NOT ( STATUS = SMG$$CHECK_OCCLUSION ( .PBCB)) 
    THEN 
	RETURN (.STATUS);

!+
! Recalculate the transformation constants needed to copy this display's
! buffers into the associated window's buffers.
!-
    IF NOT ( STATUS = SMG$$CALC_PASTE_TRANSF (.PP)) 
    THEN 
	RETURN (.STATUS);

    RETURN (SMG$$CHECK_FOR_OUTPUT_PBCB (.PBCB));

    END;			! Routine SMG$MOVE_VIRTUAL_DISPLAY
!<BLF/PAGE>

%SBTTL 'SMG$PASTE_VIRTUAL_DISPLAY - Paste virtual display to pasteboard'
GLOBAL ROUTINE SMG$PASTE_VIRTUAL_DISPLAY (
                                           DISPLAY_ID,
                                           PASTEBOARD_ID,
                                           PASTEBOARD_ROW,
                                           PASTEBOARD_COL
                                         ) =
!++
! FUNCTIONAL DESCRIPTION:
!
!       The specified virtual display is "pasted" (oriented 
!       with respect to) a pasteboard.  This makes the display visible.
!
! CALLING SEQUENCE:
!
!       ret_status.wlc.v = SMG$PASTE_VIRTUAL_DISPLAY ( 
!                                             DISPLAY_ID.rl.r,
!                                             PASTEBOARD_ID.rl.r,
!                                             PASTEBOARD_ROW.rl.r,
!                                             PASTEBOARD_COL.rl.r)
!
! FORMAL PARAMETERS:
!
!       DISPLAY_ID.rl.r         Id of virtual display to be pasted.
!
!       PASTEBOARD_ID.rl.r      The pasteboard id of the pasteboard on 
!				which the pasting is to take place.
!
!       PASTEBOARD_ROW.rl.r     Row on pasteboard which is to contain
!                               row 1 of the specified virtual display.
!
!       PASTEBOARD_COL.rl.r     Column on pasteboard which is to contain
!                               column 1 of the specified virtual
!                               display.
!
! IMPLICIT INPUTS:
!
!       None
!
! IMPLICIT OUTPUTS:
!
!       None
!
! COMPLETION STATUS:
!
!       SS$_NORMAL      Normal successful completion
!       SMG$_INVDIS_ID  Invalid virtual display id.
!       SMG$_INVPAS_ID  Invalid pasteboard id.
!       SMG$_WRONUMARG  Wrong number of arguments.
!	SMG$_ILLBATFNC	Display is batched.
!
! SIDE EFFECTS:
!
!       NONE
!--
    BEGIN
    BUILTIN
	AP,
	CALLG;

    LOCAL
	STATUS,				! Status of subroutine calls

	PP	: REF $PP_DECL,		! Addr of the pasting packet
					! being created.
	DCB	: REF $DCB_DECL,	! Addr. of display control block
	WCB	: REF $WCB_DECL,	! Addr. of window control block
	PBCB	: REF $PBCB_DECL;	! Addr of pasteboard control
					! block

    $SMG$VALIDATE_ARGCOUNT (4, 4);	! Test for right no. of args

!+
! Get addresses of associated virtual display control block and
! pasteboard control block, validating both the display id and the
! pasteboard id.
!-
    $SMG$GET_DCB ( .DISPLAY_ID, DCB);	! Get addr of DCB
    $SMG$GET_PBCB ( .PASTEBOARD_ID, PBCB);	! Get addr of PBCB

!+
! Give an error if the display is batched.
!-

    IF .DCB[DCB_L_BATCH_LEVEL] NEQ 0
    THEN
	RETURN	SMG$_ILLBATFNC;

!+
! Check to make sure we're don't already have a pasting from this 
! virtual display to this pasteboard.  If it is, we employ the
! repaste logic to remove the current pasting before allowing this new 
! pasting.  This is necessary because we don't want ambiguous pastings.
! Note:  The repaste logic ends up recalling the paste routine 
! recursively (after doing an unpaste) -- but that's ok since there
! can be at most one such pasting.  The second time we are called this
! test will fail.
!-
    IF SMG$$LOCATE_PP( .DCB, .PBCB, PP)
    THEN
	RETURN (CALLG (.AP, SMG$REPASTE_VIRTUAL_DISPLAY));

    RETURN SMG$$PASTE_VIRTUAL_DISPLAY(.DCB,.PBCB,
			.PASTEBOARD_ROW,.PASTEBOARD_COL);

    END;			! Routine SMG$PASTE_VIRTUAL_DISPLAY
!<BLF/PAGE>

%SBTTL 'SMG$POP_VIRTUAL_DISPLAY - Pop off (delete) a sequence of virtual displays'
GLOBAL ROUTINE SMG$POP_VIRTUAL_DISPLAY (
					DISPLAY_ID,
					PASTEBOARD_ID
					) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This procedure deletes all the virtual displays on the specified
!	pasteboard, starting with the display specified, up through all
!	higher-pasted display.  Each of these displays is unpasted in
!	in the course of doing the deletion.
!
! CALLING SEQUENCE:
!
!	ret_status.wlc.v = SMG$POP_VIRTUAL_DISPLAY ( DISPLAY_ID.rl.r,
!						     PASTEBOARD_ID.rl.r)
!
! FORMAL PARAMETERS:
!
!	DISPLAY_ID.rl.r		Address of the display id of the lowest
!				pasted virtual display to be deleted.
!				All higher-pasted displays are deleted
!				as well.
!
!	PASTEBOARD_ID.rl.r	Address of the pasteboard id involved.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	SS$_NORMAL	Normal successful completion
!	SMG$_INVDIS_ID	Invalid display id
!	SMG$_INVPAS_ID	Invalid pasteboard id
!	SMG$_WRONUMARG	Wrong number of arguments
!
! SIDE EFFECTS:
!
!	NONE
!--

    BEGIN
    LOCAL
	STATUS,				! Status of subr. calls

	RET_STATUS,			! Accumulated status during
					! loop
	PBCB : REF $PBCB_DECL,		! Address of a pasteboard
					! control block

	DCB  : REF $DCB_DECL,		! Address of a virtual display
					! control block we started with

	PP : REF $PP_DECL;		! Addr of 2 longwords that form
					! queue header in PP currently
					! under inspection.
!+
! Check for right number of arguments.
!
    $SMG$VALIDATE_ARGCOUNT ( 2, 2);

!+
! Get addresses of virtual display control block and pasteboard control
! block and validate them.
!-
    $SMG$GET_PBCB ( .PASTEBOARD_ID, PBCB );
    $SMG$GET_DCB  ( .DISPLAY_ID,    DCB);

!+
! Locate the pasting packet that reflects this pasting (if one exists)
! .PP is the base address of the pasting packet.
!-
    IF NOT (STATUS = SMG$$LOCATE_PP ( .DCB, .PBCB, PP))
    THEN
	RETURN (.STATUS);

!+
! Change packet address to address of queue header.
!-
    PP = .PP + PP_PBCB_QUEUE_OFFSET; ! Start with specified packet

    RET_STATUS = SS$_NORMAL;	! Assume success to follow

!+
! Batch the sequence of updates we are about to do.
!-
    IF NOT ( STATUS = SMG$$BEGIN_PASTEBOARD_UPDATE_R1 (.PBCB))
    THEN
	RETURN (.STATUS);

!+
! Loop for all pasting packets starting with this one to the last-pasted
! one...
!-
    WHILE .PP NEQ PBCB [PBCB_A_PP_NEXT]
    DO
	BEGIN	! For all displays that need to be deleted
	LOCAL
	    STATUS,			! Status of delete calls

	    PP_BASE : REF $PP_DECL,	! Base address of the PP

	    DCB : REF $DCB_DECL; 	! Current virtual display that 
				        ! needs to be deleted.
	!+
	! Calc. the base address of this pasting packet since the queue
	! headers for this part of the chain are not at relative 0 in
	! the pasting packet.
	!-
	PP_BASE = .PP - PP_PBCB_QUEUE_OFFSET;

	!+
	! Find DCB that is in this pairing.
	!-
	DCB = .PP_BASE [PP_A_DCB_ADDR];

	!+
	! Delete this virtual display, causing it to be unpasted from
	! all pasteboards to which it is currently pasted.
	!-
	IF NOT ( STATUS = SMG$DELETE_VIRTUAL_DISPLAY ( DCB [DCB_L_DID]))
	THEN 
	    !+
	    ! If no error yet, save this one.
	    !-
	    BEGIN
	    IF .RET_STATUS THEN RET_STATUS = .STATUS;
	    END;

	!+
	! Walk this chain backwards, from the packet we	started with 
	! back to the head of the chain -- since the most recently 
	! pasted displays are at the head of the chain.
	!-
	PP = .PP_BASE [PP_A_PREV_PBCB]; 
	END;	! For all displays that need to be deleted


    IF NOT (STATUS = SMG$$END_PASTEBOARD_UPDATE_R2 ( .PBCB ))
    THEN
	RETURN (.STATUS);

    RETURN (.RET_STATUS);

    END;		! End of routine SMG$POP_VIRTUAL_DISPLAY
!<BLF/PAGE>

%SBTTL 'SMG$REPASTE_VIRTUAL_DISPLAY - Repaste virtual display to pasteboard'
GLOBAL ROUTINE SMG$REPASTE_VIRTUAL_DISPLAY (
                                           DISPLAY_ID,
                                           PASTEBOARD_ID,
                                           PASTEBOARD_ROW,
                                           PASTEBOARD_COL
                                         ) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	The specified virtual display is "unpasted" from the specified
!	pasteboard.  It is then "repasted" in the new position to the
!	same pasteboard.  The unpasting and repasting operation is done
!	under cover of a SMG$$BEGIN_PASTEBOARD_UPDATE_R1 and 
!	SMG$$END_PASTEBOARD_UPDATE_R2 pair so that there is no effect on the
!	screen while it is going on.  Only the completed results of the
!	operation become visible.
!
! CALLING SEQUENCE:
!
!       ret_status.wlc.v = SMG$REPASTE_VIRTUAL_DISPLAY ( 
!                                             DISPLAY_ID.rl.r,
!                                             PASTEBOARD_ID.rl.r,
!                                             PASTEBOARD_ROW.rl.r,
!                                             PASTEBOARD_COL.rl.r)
!
! FORMAL PARAMETERS:
!
!       DISPLAY_ID.rl.r         Id of virtual display to be repasted.
!
!       PASTEBOARD_ID.rl.r      The pasteboard id of the pasteboard on 
!				which the unpasting/pasting is to take 
!				place.
!
!       PASTEBOARD_ROW.rl.r     Row on pasteboard which is to contain
!                               row 1 of the specified virtual display 
!				after repasting.
!
!       PASTEBOARD_COL.rl.r     Column on pasteboard which is to contain
!                               column 1 of the specified virtual
!                               display after repasting.
!
! IMPLICIT INPUTS:
!
!       None
!
! IMPLICIT OUTPUTS:
!
!       None
!
! COMPLETION STATUS:
!
!       SS$_NORMAL      Normal successful completion
!       SMG$_INVDIS_ID  Invalid virtual display id.
!       SMG$_INVPAS_ID  Invalid pasteboard id.
!       SMG$_WRONUMARG  Wrong number of arguments.
!
! SIDE EFFECTS:
!
!       NONE
!--
    BEGIN

    LOCAL
	DCB	: REF $DCB_DECL,
	PBCB	: REF $PBCB_DECL,
	STATUS ;	! Status of subroutine calls

    $SMG$VALIDATE_ARGCOUNT (4, 4);	! Test for right no. of args

    $SMG$GET_PBCB(.PASTEBOARD_ID,PBCB);
    $SMG$GET_DCB(.DISPLAY_ID,DCB);

!+
! Set up an extra level of output inhibiting so that our UNPASTE 
! operation won't find its way to the screen until we're done.
!-
    IF NOT (STATUS = SMG$$BEGIN_PASTEBOARD_UPDATE_R1 (.PBCB))
    THEN
	RETURN (.STATUS);

!+
! Unpaste it from where it is.
!-
    IF NOT (STATUS = SMG$$UNPASTE_VIRTUAL_DISPLAY (.DCB, .PBCB))
    THEN
	BEGIN
	SMG$$END_PASTEBOARD_UPDATE_R2 (.PBCB); ! Reduce buffering level
	RETURN (.STATUS);			    ! Return error
	END;

!+
! Now repaste to the same pasteboard in a new position.
!-
    STATUS = SMG$$PASTE_VIRTUAL_DISPLAY(.DCB,.PBCB,
			.PASTEBOARD_ROW,.PASTEBOARD_COL);

!+
! Undo one buffering level so that we are back where we started.
!-
    SMG$$END_PASTEBOARD_UPDATE_R2 (.PBCB);

!+
! If last PASTE operation yielded an error, return that status, else
! return SS$_NORMAL;
!-
    IF NOT .STATUS THEN RETURN .STATUS;

    RETURN (SS$_NORMAL);

    END;			! Routine SMG$REPASTE_VIRTUAL_DISPLAY
!<BLF/PAGE>

%SBTTL 'SMG$RESTORE_PHYSICAL_SCREEN - Restore physical screen'
GLOBAL ROUTINE SMG$RESTORE_PHYSICAL_SCREEN (
					PASTEBOARD_ID,
					DISPLAY_ID
				     ) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine reverses the effect of SMG$SAVE_PHYSICAL_SCREEN,
!	thereby putting the physical screen back to the point it was
!	at just prior to the call to SMG$SAVE_PHYSICAL_SCREEN.
!	The display id returned by SMG$SAVE_PHYSICAL_SCREEN must be
!	passed to this routine to allow the restoration to happen.
!
! CALLING SEQUENCE:
!
!	ret_status.wlc.v = SMG$RESTORE_PHYSICAL_SCREEN (
!					PASTEBOARD_ID.rl.r,
!					DISPLAY_ID.rl.r)
!
! FORMAL PARAMETERS:
!
!	PASTEBOARD_ID.rl.r	Address of a pasteboard id which is to
!				be "restored".
!
!	DISPLAY_ID.rl.r		Returned display id invented to
!				perform requested function.
!				This must be the display id returned
!				by SMG$SAVE_PHYSCIAL_SCREEN.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!    SS$_NORMAL		Normal successful completion
!    SMG$_INVDIS_ID	Invalid Display Id.
!    SMG$_INVPAS_ID	Invalid Pasteboard Id.
!
!
! SIDE EFFECTS:
!	NONE
!
!--

    BEGIN
    LOCAL
	DCB  : REF $DCB_DECL,	! Address of virtual display control
				! block involved.

	PBCB : REF $PBCB_DECL,	! Address of pasteboard control block

	PP   : REF $PP_DECL,	! Address of the pasting packet that
				! joins the virtual display to the
				! pasteboard.

	STATUS;			! Status of subr. calls

!+
! Validate number of arguments.
!-
    $SMG$VALIDATE_ARGCOUNT( 2,2);

!+
! Map pasteboard id into a PBCB address, and display id into a DCB addr.
!-
    $SMG$GET_PBCB ( .PASTEBOARD_ID, PBCB);
    $SMG$GET_DCB  ( .DISPLAY_ID,    DCB);

!+
! Locate the pasting packet that joins this virtual display with this
! pasteboard.
!-
    IF NOT (STATUS = SMG$$LOCATE_PP ( .DCB, .PBCB, PP))
    THEN
	RETURN (.STATUS);

!+
! Invalidate our knowledge of where the physical scrolling region is on
! the screen, since we don't know where the non_SMG user may have left
! it.
!-
    PBCB [PBCB_W_TOP_SCROLL_LINE] = 0;
    PBCB [PBCB_W_BOT_SCROLL_LINE] = 0;

!+
! Determine best way to clear affected area.  If the whole screen is
! involved we erase the whole screen in one operation.  If only part
! of the screen is involved, we have to do it a line at at time.
!-
    IF .PP [PP_W_FIRST_WCB_ROW] LEQ 1		AND
       .PP [PP_W_LAST_WCB_ROW] GEQ .PBCB [PBCB_B_ROWS]
    THEN
	BEGIN	! Full screen involved
	!+
	! Clear the whole physical screen to get rid of what the non-SMG
	! user may have put there.
	!-
	IF NOT (STATUS = SMG$$ERASE_PASTEBOARD (.PBCB))
	THEN
	    RETURN (.STATUS);

	END	! Full screen involved

    ELSE

	BEGIN	! Only part of screen involved
	!+
	! Clear only the part of the screen involved.  We'll have to do
	! it line by line.
	! The code to do that should really reside in module SMGMINUPD
	! for modularity.  However, it is here for now.
	!-
	LOCAL
	    WCB : REF $WCB_DECL;	! Addr of window control block
					! involved.

	WCB = .PBCB [PBCB_A_WCB];

	!+
	! For each line involved, set cursor to column 1 of that line
	! and emit erase sequence.  Setting the cursor to column 1 of
	! the line is necessay for non-VT100 terminals.
	!-

	INCR I FROM .PP [PP_W_FIRST_WCB_ROW] TO .PP [PP_W_LAST_WCB_ROW]
	DO
	    BEGIN	! Row by row
	    !+
	    ! Set cursor to column 1 of row .I.
	    !-
	    SMG$$FIND_MIN_CURSOR_POS (
			.PBCB,
			.WCB [WCB_W_OLD_CUR_ROW],	! Current row
			.WCB [WCB_W_OLD_CUR_COL],	! Current col
			.I,				! Desired row
			1);				! Desired col

	    !+
	    ! Get escape sequence needed to erase a line.
	    ! (Can't move this outside the loop since data is left
	    ! in memory that FIND_MIN_CURSOR_POS might touch.
	    !-

	    $SMG$GET_TERM_DATA(ERASE_WHOLE_LINE);

	    !+
	    ! Erase the Ith line.
	    !-

	    IF NOT (STATUS = SMG$$OUTPUT ( .PBCB,
				.PBCB[PBCB_L_CAP_LENGTH],
				.PBCB[PBCB_A_CAP_BUFFER]))
	    THEN
		RETURN (.STATUS);

	    END;	! Row by row
	END;	! Only part of screen involved

!+
! Pop off the virtual display that SMG$SAVE_PHYSICAL_SCREEN placed on
! top to cover everything up.
!-
    IF NOT (STATUS = SMG$POP_VIRTUAL_DISPLAY ( .DISPLAY_ID,
					       .PASTEBOARD_ID))
    THEN
	RETURN (.STATUS);

    RETURN (SS$_NORMAL);

    END;		! End of routine SMG$RESTORE_PHYSICAL_SCREEN
!<BLF/PAGE>

%SBTTL 'SMG$SAVE_PHYSICAL_SCREEN - Save physical screen'
GLOBAL ROUTINE SMG$SAVE_PHYSICAL_SCREEN (
					 PASTEBOARD_ID,
					 DISPLAY_ID,
					 DESIRED_ROW_START,
					 DESIRED_ROW_END
				        ) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine should be called before calling a procedure which
!	may perform output to the screen without using the SMG$
!	This procedure saves the state of the screen so that it can be
!	restored via a later call to SMG$RESTORE_PHYSICAL_SCREEN.
!
!	This routine performs 4 functions:
!	It:
!	    a).	Creates a virtual display which is as wide as the
!		physical screen and is as high indicated by the
!		desired_row_start and desired_row_end.
!		The resulting virtual display id is returned
!		to the caller.
!
!	    b). Pastes this virtual display to cover the screen at a 
!		position corresponding to column 1 of desired_row_start.
!
!	    c). Set the physical cursor to (1,1) in the virtual display.
!		This corresponds to (desired_row_start, 1) on the
!		physical screen.
!
!	    d). Set the physical scrolling region to be the height
!		of the resulting virtual display.
!
!	If either desired_row_start or desired_row_end are omitted,
!	the first row of the physical display and the last row of the
!	physical display are used, respectively, in calculating the
!	height of the virtual display.
!
!	The effects of this routine can be reversed by doing a
!	SMG$RESTORE_PHYSICAL_SCREEN (Display_id.rl.r, Pasteboard_id.rl.r),
!	supplying the display_id returned by this routine.
!
! CALLING SEQUENCE:
!
!	ret_status.wlc.v = SMG$SAVE_PHYSICAL_SCREEN (
!					PASTEBOARD_ID.rl.r,
!					DISPLAY_ID.wl.r
!					[,DESIRED_ROW_START.rl.r]
!					[,DESIRED_ROW_END.rl.r])
!
! FORMAL PARAMETERS:
!
!	PASTEBOARD_ID.rl.r	Address of a pasteboard id which is to
!				be "saved".
!
!	DISPLAY_ID.wl.r		Returned display id invented to
!				perform requested function.
!
!	DESIRED_ROW_START.rl.r	Optional.  The address of the 1st row
!				to be "saved".  If omitted, row 1 of
!				the physical display is used.
!
!	DESIRED_ROW_END.rl.r	Optional.  The address of the last row
!				to be "saved".  If omitted, the last
!				row of the physical display is used.
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!		SS$_NORMAL	Normal successful completion
!
! From: SMG$CREATE_VIRTUAL_DISPLAY
!		LIB$_INSVIRMEM	Insufficient virtual memory
!
! From: SMG$PASTE_VIRTUAL_DISPLAY
!		SMG$_INVPAS_ID	Invalid Pasteboard Id.
!
!
! SIDE EFFECTS:
!
!	The appropriate part of the physical screen will be blanked, 
!	scrolling region will be full height of the past to be "saved",
!	and cursor will be at (desired_row_start,1) on screen.
!--

    BEGIN
    BUILTIN
	NULLPARAMETER;

    LOCAL
	ROW1,				! Resulting 1st row
	ROWN,				! Resulting last row
	FULL_SCREEN,			! Logical indicating that we
					! are saving the whole screen.
	PBCB : REF $PBCB_DECL,		! Address of pasteboard control
					! block

	NEW_DCB : REF $DCB_DECL,	! Address of a display control
					! block.  This will also
					! become the display_id
					! returned.

	STATUS;				! Status of subr. calls

!+
! Validate number of arguments and get the PBCB that goes with the
! Pasteboard id.
!-
    $SMG$VALIDATE_ARGCOUNT( 2,4);

    $SMG$GET_PBCB ( .PASTEBOARD_ID, PBCB);

!+
! Assume full screen case and intialize accordingly
!-
    FULL_SCREEN = 1;	! Assume full screen
    ROW1 = 1;
    ROWN = .PBCB [PBCB_B_ROWS];

!+
! See which optional parameters were supplied and re-adjust assumptions.
!-
    IF NOT NULLPARAMETER (DESIRED_ROW_START)
    THEN
	BEGIN	! Desired_row_start specified
	FULL_SCREEN = 0;
	ROW1 = ..DESIRED_ROW_START;
	END;	! Desired_row_start specified

    IF NOT NULLPARAMETER (DESIRED_ROW_END)
    THEN
	BEGIN	! Desired_row_end specified
	FULL_SCREEN = 0;
	ROWN = ..DESIRED_ROW_END;
	END;	! Desired_row_end specified
!+
! If either of the optional row parameters were supplied, make sure
! we got a consistant range.
!-
    IF NOT .FULL_SCREEN
    THEN
	BEGIN	! Validity check on rows
	IF .ROW1 LSS 1				OR ! Start off top
	   .ROW1 GEQ .PBCB [PBCB_B_ROWS] -1	OR ! need 2 lines to scroll
	   .ROWN LSS 1				OR ! End off top
	   .ROWN GTR .PBCB [PBCB_B_ROWS]	OR ! End off bottom
	   .ROWN - .ROW1 LSS 1			   ! Wrong order
	THEN
	    RETURN SMG$_INVROW;

	END;	! Validity check on rows

!+
! Create a virtual display the same width as the physical screen and 
! as high as desired.
!-
    IF NOT (STATUS = SMG$$CREATE_VIRTUAL_DISPLAY (
			%REF ( .ROWN - .ROW1 +1),	! # rows
			%REF (.PBCB [PBCB_W_WIDTH]),	! # columns
			NEW_DCB,			! new disp. id
			%REF(0),			! default display attr
			%REF(0),			! default video attr
			%REF(0)				! default alt char set
			))
    THEN
	RETURN (.STATUS);

!+
! Paste newly-create virtual display to (desired_row_start,1) of 
! pasteboard.
!-
    IF NOT (STATUS = SMG$$PASTE_VIRTUAL_DISPLAY (
			.NEW_DCB,		! DCB address
			.PBCB,			! Pasteboard control block
			ROW1,			! Row
			%REF (1)))		! Col 1
    THEN
	RETURN (.STATUS);


!+
! Set physical scrolling region to be full height of screen.
!-
    IF NOT (STATUS = SMG$$FORCE_SCROLL_REG ( .PBCB,	! Pasteboard
					     .ROW1,	! Top row
					     .ROWN))	! Bottom row
    THEN
	RETURN (.STATUS);

!+
! Return id of newly-create virtual display to caller.
!-
    .DISPLAY_ID = .NEW_DCB;

    RETURN (SS$_NORMAL);

    END;		! End of routine SMG$SAVE_PHYSICAL_SCREEN
!<BLF/PAGE>

%SBTTL 'SMG$SET_DISPLAY_SCROLL_REGION - Set scrolling region in a virtual display'
GLOBAL ROUTINE SMG$SET_DISPLAY_SCROLL_REGION (
                                   	DISPLAY_ID,
                                   	TOP_LINE_OF_REGION,
                                   	BOTTOM_LINE_OF_REGION
                                       ) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine sets the top and bottom lines of a 'scrolling region'
!	in a virtual display.  The scrolling region limits are used by
!	output routines which scroll (SMG$PUT_WITH_SCROLL and
!	SMG$PUT_LINE with line advancing).  If this routine is called
!	with only a display_id, the scrolling region defaults to the
!	entire display.
!
!	If a top and bottom line are passed, they must be within the
!	display bounds.  Scrolling can not occur outside the bounds of
!	a display.
!
!	This routine does not change the appearance of the screen or the
!	cursor position.
!
! CALLING SEQUENCE:
!
!       ret_status.wlc.v = SMG$SET_DISPLAY_SCROLL_REGION (
!                                       	    DISPLAY_ID.rl.r
!                                      		    [,TOP_LINE_OF_REGION.rl.r]
!                                       	    [,BOTTOM_LINE_OF_REGION.rl.r])
!
! FORMAL PARAMETERS:
!
!       DISPLAY_ID.rl.r         Display id of desired display.
!
!	TOP_LINE_OF_REGION.rl.r Optional.  The top line of a scrolling
!			  	region.  Defaults to line 1 of the display.
!
!	BOTTOM_LINE_OF_REGION.rl.r
!				Optional.  The bottom line of a scrolling
!				region.  Defaults to the bottom line of the
!				display.  
!
!
! IMPLICIT INPUTS:
!
!       NONE
!
! IMPLICIT OUTPUTS:
!
!       NONE
!
! COMPLETION STATUS:
!
!       SS$_NORMAL      Normal successful completion
!	SMG$_INVARG	Bottom line is less than or equal to top line.
!	SMG$_INVROW	Row number is negative or too large
!       SMG$_WRONUMARG  Wrong number arguments.
!
! SIDE EFFECTS:
!
!       NONE
!--
    BEGIN
    BUILTIN
	NULLPARAMETER;

    LOCAL
	TOP_LINE,			! working top line
	BOTTOM_LINE,			! working bottom line
	DCB : REF $DCB_DECL;		! Addr. of display control block

    $SMG$VALIDATE_ARGCOUNT (1,3);

    $SMG$GET_DCB ( .DISPLAY_ID, DCB);	! Get address of display control
					! block

!+
! Validate optional arguments.
!-

    TOP_LINE = .DCB [DCB_W_ROW_START]; 	! init to default

    IF NOT NULLPARAMETER (TOP_LINE_OF_REGION)
    THEN
	BEGIN
	IF ..TOP_LINE_OF_REGION GEQ .DCB [DCB_W_ROW_START] AND
           ..TOP_LINE_OF_REGION LEQ .DCB [DCB_W_NO_ROWS]
        THEN
	    TOP_LINE = ..TOP_LINE_OF_REGION
	ELSE
	    RETURN (SMG$_INVROW);	! can't be outside display
	END;

    BOTTOM_LINE = .DCB [DCB_W_NO_ROWS];	! init to default

    IF NOT NULLPARAMETER (BOTTOM_LINE_OF_REGION)
    THEN
	BEGIN
        IF ..BOTTOM_LINE_OF_REGION GEQ .DCB [DCB_W_ROW_START] AND
           ..BOTTOM_LINE_OF_REGION LEQ .DCB [DCB_W_NO_ROWS]
        THEN
	    BOTTOM_LINE = ..BOTTOM_LINE_OF_REGION
	ELSE
	    RETURN (SMG$_INVROW);	! can't be outside display
	END;

    IF .BOTTOM_LINE LEQ .TOP_LINE
    THEN
	RETURN (SMG$_INVARG);		! can't go backwards or
					! overlap

!+
! If we get here, we have a valid scrolling region.  Store it.
!-

    DCB [DCB_W_TOP_OF_SCRREG] = .TOP_LINE;
    DCB [DCB_W_BOTTOM_OF_SCRREG] = .BOTTOM_LINE;

    RETURN (SS$_NORMAL);
    END;		! end of routine SMG$SET_DISPLAY_SCROLL_REGION
!<BLF/PAGE>

%SBTTL 'SMG$UNPASTE_VIRTUAL_DISPLAY - Unpaste virtual display from pasteboard'
GLOBAL ROUTINE SMG$UNPASTE_VIRTUAL_DISPLAY (
                                            DISPLAY_ID,
                                            PASTEBOARD_ID
                                           ) =
!++
! FUNCTIONAL DESCRIPTION:
!
!       The specified virtual display is "unpasted" from a pasteboard.
!       Unpasting does not destroy the virtual display or its contents.
!       It merely removes its mapping to a particular pasteboard and
!	hence its visibility on that pasteboard.
!
! CALLING SEQUENCE:
!
!       ret_status.wlc.v = SMG$UNPASTE_VIRTUAL_DISPLAY ( 
!                                             DISPLAY_ID.rl.r,
!                                             PASTEBOARD_ID.rl.r)
!
! FORMAL PARAMETERS:
!
!       DISPLAY_ID.rl.r         Id of virtual display to be unpasted.
!
!       PASTEBOARD_ID.rl.r      The pasteboard id of the pasteboard from
!				which the unpasting is to take place.
!
! IMPLICIT INPUTS:
!
!       None
!
! IMPLICIT OUTPUTS:
!
!       None
!
! COMPLETION STATUS:
!
!       SS$_NORMAL      Normal successful completion
!       SMG$_INVDIS_ID  Invalid virtual display id.
!       SMG$_INVPAS_ID  Invalid pasteboard id.
!       SMG$_WRONUMARG  Wrong number of arguments.
!       SMG$_NOTPASTED  Specified virtual display is not currently
!                       pasted to the specified pasteboard.
!	SMG$_ILLBATFNC	Display is batched.
!
! SIDE EFFECTS:
!
!       NONE
!--
    BEGIN
    LOCAL
	STATUS,				! Status of subroutine call

	DCB	: REF $DCB_DECL,	! Addr of display control block
	PBCB	: REF $PBCB_DECL;	! Addr of pasteboard control block

    $SMG$VALIDATE_ARGCOUNT (2, 2);	! Test for right no. of args

!+
! Get addresses of virtual display control block and pasteboard control
! block and validate display id and pasteboard id.
!-
    $SMG$GET_PBCB ( .PASTEBOARD_ID, PBCB); 
					! Get addr of pasteboard control
					! block

    $SMG$GET_DCB ( .DISPLAY_ID, DCB);	! Get addr of virtual display
					! control block

!+
! Give an error if the display is batched.
!-

    IF .DCB[DCB_L_BATCH_LEVEL] NEQ 0
    THEN
	RETURN	SMG$_ILLBATFNC;

    RETURN SMG$$UNPASTE_VIRTUAL_DISPLAY(.DCB,.PBCB)

    END;			! Routine SMG$UNPASTE_VIRTUAL_DISPLAY
!<BLF/PAGE>

%SBTTL 'SMG$$CALC_PASTE_TRANSF - Calculate pasting transformation constants'
GLOBAL ROUTINE SMG$$CALC_PASTE_TRANSF ( PP  : REF $PP_DECL ) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This procedure precalculates the constants needed to efficiently
!	copy portions of the text and attributes from the virtual 
!	display buffers located in the DCB to the window buffer located 
!	in the WCB.
!	This data is derived from the pasting relationship between
!	the given virtual display and the pasteboard to which it is
!	pasted.  The calculated constants are stored in the pasting
!	packet that reflects this pasting.
!
!
! CALLING SEQUENCE:
!
!	ret_status.wlc.v = SMG$$CALC_PASTE_TRANSF ( PP.mab.r)
!
! FORMAL PARAMETERS:
!
!	PP.mab.r	Address of pasting packet.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	SS$_NORMAL	Normal successful completion
!
! SIDE EFFECTS:
!
!	NONE
!--

    BEGIN
    LOCAL
	TEMP	: BLOCK [8,BYTE],	! Temporary representation of
					! display buffer area as
					! projected on window buffer.
	DCB	: REF $DCB_DECL,	! Addr of DCB involved.
	WCB	: REF $WCB_DECL,	! Addr of WCB involved.
	PBCB	: REF $PBCB_DECL,	! Addr of PBCB involved.
	OVERLAP : BLOCK [8,BYTE];	! Describes area of overlap
					! between virtual display and
					! window buffer.

    PBCB = .PP [PP_A_PBCB_ADDR] ;
    WCB = .PBCB [PBCB_A_WCB] ;
    DCB = .PP [PP_A_DCB_ADDR] ;

!+
! Mark the border label as being invisible until it proves otherwise.
!-
    PP [PP_W_LABEL_BYTES_TO_MOVE] = 0;
    PP [PP_W_SRC_LABEL_OFF]	  = 0;
    PP [PP_W_DST_LABEL_OFF]	  = 0;


    TEMP [DCB_W_ROW_START] = .DCB [DCB_W_ROW_START] + .PP [PP_W_ROW]-1;
    TEMP [DCB_W_NO_ROWS]   = .DCB [DCB_W_NO_ROWS];
    TEMP [DCB_W_COL_START] = .DCB [DCB_W_COL_START] + .PP [PP_W_COL]-1;
    TEMP [DCB_W_NO_COLS]   = .DCB [DCB_W_NO_COLS];

!+
! Check to see what part (if any) of this virtual display maps onto
! the viewable part of the pasteboard -- i.e., the area that goes into
! the window control block buffer.
!-
    IF NOT SMG$$OCCLUDE ( 
			  WCB [WCB_Q_COORD],	! Area of window buffer
			  TEMP,			! Area of display buffer
			  OVERLAP )		! Area of overlap 
						! (if any)
    THEN
	BEGIN	! No overlap
	PP [PP_W_ROWS_TO_MOVE] = 0 ; ! There are no rows to move
	!+
	! If the display isn't visible, the border label isn't visible
	! either.    **** Not really true -- clean this up later ****
	!-
	END	! No overlap
    ELSE
	BEGIN	! Overlap
	LOCAL
	    DCB_START_ROW,	! 1st row of display buffer that lands
				! in window buffer.
	    DCB_START_COL;	! 1st column of display buffer that
				! lands in window buffer.

	PP [PP_W_ROWS_TO_MOVE] = .OVERLAP [DCB_W_NO_ROWS];
	PP [PP_W_MOVE_LENGTH]  = .OVERLAP [DCB_W_NO_COLS];

	PP [PP_W_FIRST_WCB_ROW] = .OVERLAP [DCB_W_ROW_START];
	PP [PP_W_LAST_WCB_ROW]  = .OVERLAP [DCB_W_ROW_START] +
				  .OVERLAP [DCB_W_NO_ROWS] - 1;

	PP [PP_W_FIRST_WCB_COL] = .OVERLAP [DCB_W_COL_START];
	PP [PP_W_LAST_WCB_COL]  = .OVERLAP [DCB_W_COL_START] +
				  .OVERLAP [DCB_W_NO_COLS] - 1;

	PP [PP_L_MOVE_SIZE] = .OVERLAP [DCB_W_NO_ROWS] *
			      .OVERLAP [DCB_W_NO_COLS];

	DCB_START_ROW = .OVERLAP [DCB_W_ROW_START] - .PP [PP_W_ROW] +1;
	DCB_START_COL = .OVERLAP [DCB_W_COL_START] - .PP [PP_W_COL] +1;

	PP [PP_W_FROM_INDEX] = (.DCB_START_ROW -1) *.DCB [DCB_W_NO_COLS]
			        + .DCB_START_COL - 1;

	PP [PP_W_TO_INDEX] = (.OVERLAP [DCB_W_ROW_START] -1) * 
			      .WCB [WCB_W_NO_COLS] + 
			      .OVERLAP [DCB_W_COL_START] -1;

	IF .DCB [DCB_V_BORDERED]
	THEN
	    BEGIN	! Bordered display
	    LOCAL
		UPPER_ROW,	! Row above top row of pasted display
		LOWER_ROW,	! Row below bottom row of pasted display
		LEFT_COL,		! Col. to left of pasted display
		RIGHT_COL,	! Col. to right of pasted display
		LDES : REF BLOCK [,BYTE];! Address of dynamic descr. in
					! DCB that points to label
					! string.

	    LDES = DCB [DCB_Q_LABEL_DESC];

	    !+
	    ! Compute the row and column numbers where the borders fall.
	    ! Note these rows and columns may not map into the buffer 
	    ! and need to be validated before use.
	    !-
	    UPPER_ROW = .PP [PP_W_ROW] - 1 ;
	    LOWER_ROW = .PP [PP_W_ROW] + .DCB [DCB_W_NO_ROWS];
	    LEFT_COL  = .PP [PP_W_COL] - 1 ;
	    RIGHT_COL = .PP [PP_W_COL] + .DCB [DCB_W_NO_COLS];

	    IF .LDES [DSC$W_LENGTH] NEQ 0
	    THEN
		BEGIN	! Label position computation
		CASE .DCB [DCB_B_LABEL_POS] FROM SMG$K_TOP TO SMG$K_RIGHT OF
		SET
		    [SMG$K_TOP]:
			BEGIN	! Label in top row
			IF .UPPER_ROW GEQ 1
			THEN
			    BEGIN	! Top row in buffer
			    LOCAL
				DCOLS : SIGNED;	! Dest. col. start

			    DCOLS =	  .PP [PP_W_COL] + 
					  .DCB [DCB_W_LABEL_UNITS] -2 ;

			    IF .DCOLS LEQ .WCB [WCB_W_NO_COLS]
			    THEN
				BEGIN	! partially on screen
				LOCAL
				    DCOLE : SIGNED; ! Dest. col end

			        DCOLE = MIN ( (.LDES [DSC$W_LENGTH] + .DCOLS -1),
					  (.PP [PP_W_COL] + 
					   .DCB [DCB_W_NO_COLS] ),
					   .WCB [WCB_W_NO_COLS]);

			        PP [PP_W_LABEL_BYTES_TO_MOVE] = 
					MAX ( 0, .DCOLE +1 - 
						 MAX (0, .DCOLS) );

			        IF .PP [PP_W_COL] LEQ 0
			        THEN
				    BEGIN	! Using tail end of label
				    PP [PP_W_SRC_LABEL_OFF] = 
					.LDES [DSC$W_LENGTH] -
					.PP [PP_W_LABEL_BYTES_TO_MOVE];
				    END	! Using tail end of label
			        ELSE
				    BEGIN	! Using front end of label
				    PP [PP_W_SRC_LABEL_OFF] = 0;
				    END;	! Using front end of label

			        PP [PP_W_DST_LABEL_OFF] = (.UPPER_ROW -1) *
						      .WCB [WCB_W_NO_COLS] +
						      MAX(0, .DCOLS - 1);
				END; ! Partially on screen

			    END;	! Top row in buffer
			END;	! Label in top row

		    [SMG$K_BOTTOM]:
			BEGIN	! Label in bottom row
			IF .LOWER_ROW LEQ .WCB [WCB_W_NO_ROWS]
			THEN
			    BEGIN	! Bottom row in buffer
			    LOCAL
				DCOLS : SIGNED;	! Dest. col. start

			    DCOLS =	  .PP [PP_W_COL] + 
					  .DCB [DCB_W_LABEL_UNITS] - 2;

			    IF .DCOLS LEQ .WCB [WCB_W_NO_COLS]
			    THEN
				BEGIN ! Partially visible
				LOCAL
				    DCOLE : SIGNED; ! Dest. col. end

			        DCOLE = MIN ( (.LDES [DSC$W_LENGTH] + .DCOLS -1),
					  (.PP [PP_W_COL] + 
					   .DCB [DCB_W_NO_COLS] ),
					   .WCB [WCB_W_NO_COLS]);

			        PP [PP_W_LABEL_BYTES_TO_MOVE] = 
					MAX ( 0, .DCOLE + 1 - 
						 MAX (0, .DCOLS) );


			        IF .PP [PP_W_COL] LEQ 0
			        THEN
				    BEGIN	! Using tail end of label
				    PP [PP_W_SRC_LABEL_OFF] = 
					.LDES [DSC$W_LENGTH] -
					.PP [PP_W_LABEL_BYTES_TO_MOVE];
				    END	! Using tail end of label
			        ELSE
				    BEGIN	! Using front end of label
				    PP [PP_W_SRC_LABEL_OFF] = 0;
				    END;	! Using front end of label
			        PP [PP_W_DST_LABEL_OFF] = (.LOWER_ROW -1) *
						      .WCB [WCB_W_NO_COLS] +
						      MAX(0, .DCOLS - 1);

				END ;! Partially visible
			    END;	! Bottom row in buffer
			END;	! Label in bottom row

		    [SMG$K_LEFT]:
			BEGIN	!Label in left column
			IF .LEFT_COL GEQ 1
			THEN
			    BEGIN	! Left column in buffer
			    LOCAL
				DROWS : SIGNED; ! Dest. row start

			    DROWS = 	  .PP [PP_W_ROW] + 
					  .DCB [DCB_W_LABEL_UNITS] - 2;

			    IF .DROWS LEQ .WCB [WCB_W_NO_ROWS]
			    THEN
				BEGIN ! Partially visible
				LOCAL
				    DROWE : SIGNED ; ! Dest. row end

			        DROWE = MIN ( (.LDES [DSC$W_LENGTH] + .DROWS -1),
					  (.PP [PP_W_ROW] + 
					   .DCB [DCB_W_NO_ROWS] ),
					   .WCB [WCB_W_NO_ROWS]);

			        PP [PP_W_LABEL_BYTES_TO_MOVE] = 
					MAX ( 0, .DROWE + 1 - 
						 MAX (0, .DROWS) );

			        IF .PP [PP_W_ROW] LEQ 0
			        THEN
				    BEGIN	! Using tail end of label
				    PP [PP_W_SRC_LABEL_OFF] = 
					.LDES [DSC$W_LENGTH] -
					.PP [PP_W_LABEL_BYTES_TO_MOVE];
				    END	! Using tail end of label
			        ELSE
				    BEGIN	! Using front end of label
				    PP [PP_W_SRC_LABEL_OFF] = 0;
				    END;	! Using front end of label

			        PP [PP_W_DST_LABEL_OFF] = (.DROWS -1) *
						      .WCB [WCB_W_NO_COLS] +
						      MAX(0, .LEFT_COL - 1);
				END; ! Partially visible
			    END;	! Left column in buffer
			END;	! Label in left column

		    [SMG$K_RIGHT]:
			BEGIN	! Label in right column
			IF .RIGHT_COL LEQ .WCB [WCB_W_NO_COLS]
			THEN
			    BEGIN	! Right column in buffer
			    LOCAL
				DROWS : SIGNED;	! Dest. row start

			    DROWS =	  .PP [PP_W_ROW] + 
					  .DCB [DCB_W_LABEL_UNITS] - 2;

			    IF .DROWS LEQ .WCB [WCB_W_NO_ROWS]
			    THEN
				BEGIN ! Partially visible
				LOCAL
				  DROWE : SIGNED ; ! Dest. row end

			        DROWE = MIN ( (.LDES [DSC$W_LENGTH] + .DROWS -1),
					  (.PP [PP_W_ROW] +
 					   .DCB [DCB_W_NO_ROWS] ),
					   .WCB [WCB_W_NO_ROWS]);

			        PP [PP_W_LABEL_BYTES_TO_MOVE] = 
					MAX ( 0, .DROWE + 1 - 
						 MAX (0, .DROWS) );


			        IF .PP [PP_W_ROW] LEQ 0
			        THEN
				    BEGIN	! Using tail end of label
				    PP [PP_W_SRC_LABEL_OFF] = 
					.LDES [DSC$W_LENGTH] -
					.PP [PP_W_LABEL_BYTES_TO_MOVE];
				    END	! Using tail end of label
			        ELSE
				    BEGIN	! Using front end of label
				    PP [PP_W_SRC_LABEL_OFF] = 0;
				    END;	! Using front end of label

			        PP [PP_W_DST_LABEL_OFF] = (.DROWS -1) *
						      .WCB [WCB_W_NO_COLS] +
						      MAX(0, .RIGHT_COL - 1);

				END; ! Partially visible
			    END;	! Right column in buffer
			END;	! Label in right column

		    [OUTRANGE]:
			RETURN (SMG$_FATERRLIB);

	        TES;
		END;	! Label position computation
	    END;	! Bordered display
	END;	! Overlap

!+
! If the virtual display width matches the window control block width,
! and the width of the data to be move during a mapping operation is
! this same width, then both the source area and the destination are
! contiguous sets of bytes and can be moved with a single CH$MOVE.
! If not, they have to be moved a row at a time since that is how many
! are piece-wise contiguous.
!-
    PP [PP_V_CONTIG] = 0; ! Assume not contiguous until so proven.
    IF .DCB [DCB_W_NO_COLS]   EQL .WCB [WCB_W_NO_COLS]    AND
       .PP [PP_W_MOVE_LENGTH] EQL .DCB [DCB_W_NO_COLS]
    THEN
	PP [PP_V_CONTIG] = 1;	! Contiguous

    RETURN (SS$_NORMAL);
    END;		! End of routine SMG$$CALC_PASTE_TRANSF
!<BLF/PAGE>

%SBTTL 'SMG$$CHECK_OCCLUSION - Check pastings for occlusion'
GLOBAL ROUTINE SMG$$CHECK_OCCLUSION (
				 PBCB : REF $PBCB_DECL
					) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This procedure checks the overlap in all the pastings to
!	a given pasteboard -- setting a bit in the respective pasting
!	packets to record whether each pasting is occluded by
!	higher (more-recently pasted) pastings.  This procedure is
!	invoked whenever there is a change in the pasting order or
!	pasting position of any virtual display.
!	If we can determine at pasting time that a particular virtual
!	display (as pasted) and with a given succession of higher-pasted
!	virtual displays is not occluded by any of them,
!	we can make mapping run faster since a change to a virtual 
!	display which is not occluded causes only the changed virtual 
!	display to be remapped.  Higher pasted virtual displays do not 
!	have to be remapped since it is known that they do not occlude 
!	the changed one.
!
! CALLING SEQUENCE:
!
!	ret_status.wlc.v = SMG$$CHECK_OCCLUSION ( PBCB.rab.r)
!
! FORMAL PARAMETERS:
!
!	PBCB.rab.r		Address of pasteboard control block
!				which has something new or different
!				pasted to it.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	SS$_NORMAL	Normal successful completion
!
! SIDE EFFECTS:
!
!	NONE
!--

    BEGIN
    LOCAL
	THIS_PP : REF $PP_DECL,	
			! Addr of pasting packet for upper-most pasted 
			! virtual display.

	THIS_Q_HEAD : REF BLOCK [,BYTE];
			! Addr of 2 longwords that form	queue header in
			! PP currently under inspection.

!+
! To initialize for the rest of the algorithm, run through whole pasting
! list marking all packets not occluded.
!-
    THIS_Q_HEAD = .PBCB [PBCB_A_PP_NEXT];	! 1st (more recent pasting)
    WHILE .THIS_Q_HEAD NEQ PBCB [PBCB_A_PP_NEXT]
    DO
	BEGIN	! Init. pass
	THIS_PP = .THIS_Q_HEAD - PP_PBCB_QUEUE_OFFSET; ! To top of packet
	THIS_PP [ PP_V_OCCLUDED] = 0;	! Init to not occluded
	THIS_Q_HEAD = .THIS_PP [PP_A_NEXT_PBCB];    ! To queue header in
						    !  next packet
	END;	! Init. pass

    THIS_Q_HEAD = .PBCB [PBCB_A_PP_NEXT];
    THIS_PP = .THIS_Q_HEAD - PP_PBCB_QUEUE_OFFSET;

!+
! Loop for all pasting packets starting with most-recently pasted one.
!-
    WHILE .THIS_Q_HEAD NEQ PBCB [PBCB_A_PP_NEXT]
    DO
	BEGIN	! For all displays from top to bottom
	LOCAL
	    NEXT_PP        : REF $PP_DECL,	
				! Addr of pasting packet currently under
				! inspection.

	    NEXT_PP_Q_HEAD : REF BLOCK [,BYTE],	
				! Addr of 2 longwords that form queue 
				! header in PP currently under 
				! inspection.

	    TEMP_THIS : BLOCK [8,BYTE],	
				! Area of projection of THIS virtual
				! display on pasteboard

	    TEMP_NEXT : BLOCK [8,BYTE],	
				! Area of projection of NEXT virtual
				! display on pasteboard

	    THIS_DCB : REF BLOCK [,BYTE]; 	
				! Addr of virtual display currently
				! under inspection.

	!+
	! Recalculate pasting packet address and DCB address for this
	! iteration.
	!-
	THIS_PP = .THIS_Q_HEAD - PP_PBCB_QUEUE_OFFSET;
	THIS_DCB = .THIS_PP [PP_A_DCB_ADDR];

	!+
	! It is safe to assume that there is at least one virtual 
	! display pasted to this pasteboard -- but there may not be more
	! than one.  Be careful about reaching ahead to a packet that
	! may not be a packet.  If doesn't exist, pointer will be
	! pointing back into PBCB -- and inner loop will not be
	! executed.
	!-
	NEXT_PP_Q_HEAD = .THIS_PP [PP_A_NEXT_PBCB];

	IF .NEXT_PP_Q_HEAD NEQ PBCB [PBCB_A_PP_NEXT]
	THEN
	    BEGIN	! NEXT exists
	    NEXT_PP = .NEXT_PP_Q_HEAD - PP_PBCB_QUEUE_OFFSET;
	    !+
	    ! Form a representation of the projection of THIS virtual
	    ! display onto pasteboard coordinate system.
	    !-
	    TEMP_THIS [DCB_W_ROW_START] = .THIS_DCB [DCB_W_ROW_START] +
					  .THIS_PP [PP_W_ROW] - 1;
	    TEMP_THIS [DCB_W_NO_ROWS]   = .THIS_DCB [DCB_W_NO_ROWS];
	    TEMP_THIS [DCB_W_COL_START] = .THIS_DCB [DCB_W_COL_START] +
					  .THIS_PP [PP_W_COL] - 1;
	    TEMP_THIS [DCB_W_NO_COLS]   = .THIS_DCB [DCB_W_NO_COLS];

	    !+
	    ! If this virtual display is bordered, its projection is
	    ! bigger than if it were not.  Adjust its projection
	    ! representation.
	    !-
	    IF .THIS_DCB [DCB_V_BORDERED]
	    THEN
		BEGIN	! Border adjustment
		TEMP_THIS [DCB_W_ROW_START] = .TEMP_THIS [DCB_W_ROW_START] - 1;
		TEMP_THIS [DCB_W_NO_ROWS]   = .TEMP_THIS [DCB_W_NO_ROWS] + 2;
		TEMP_THIS [DCB_W_COL_START] = .TEMP_THIS [DCB_W_COL_START] - 1;
		TEMP_THIS [DCB_W_NO_COLS]   = .TEMP_THIS [DCB_W_NO_COLS] + 2;
		END;	! Border adjustment

	    END;	! Next exists

	WHILE .NEXT_PP_Q_HEAD NEQ PBCB [PBCB_A_PP_NEXT]
	DO
	    BEGIN	! For all displays from current to bottom
	    LOCAL
		NEXT_DCB : REF $DCB_DECL,	
				! Addr of DCB associated with NEXT_PP
		OVERLAP : BLOCK [8,BYTE];	
				! Returned by SMG$$OCCLUDE, but not
				! used in this context

	    NEXT_PP = .NEXT_PP_Q_HEAD - PP_PBCB_QUEUE_OFFSET;
	    NEXT_DCB = .NEXT_PP [PP_A_DCB_ADDR];

	    !+
	    ! Form a representation of the projection of NEXT virtual
	    ! display onto pasteboard coordinate system.
	    !-
	    TEMP_NEXT [DCB_W_ROW_START] = .NEXT_DCB [DCB_W_ROW_START] +
					  .NEXT_PP [PP_W_ROW] - 1;
	    TEMP_NEXT [DCB_W_NO_ROWS]   = .NEXT_DCB [DCB_W_NO_ROWS];
	    TEMP_NEXT [DCB_W_COL_START] = .NEXT_DCB [DCB_W_COL_START] +
					  .NEXT_PP [PP_W_COL] - 1;
	    TEMP_NEXT [DCB_W_NO_COLS]   = .NEXT_DCB [DCB_W_NO_COLS];

	    !+
	    ! If this next virtual display is bordered, its projection is
	    ! bigger than if it were not.  Adjust its projection
	    ! representation.
	    !-
	    IF .NEXT_DCB [DCB_V_BORDERED]
	    THEN
		BEGIN	! Border adjustment
		TEMP_NEXT [DCB_W_ROW_START] = .TEMP_NEXT [DCB_W_ROW_START] - 1;
		TEMP_NEXT [DCB_W_NO_ROWS]   = .TEMP_NEXT [DCB_W_NO_ROWS] + 2;
		TEMP_NEXT [DCB_W_COL_START] = .TEMP_NEXT [DCB_W_COL_START] - 1;
		TEMP_NEXT [DCB_W_NO_COLS]   = .TEMP_NEXT [DCB_W_NO_COLS] + 2;
		END;	! Border adjustment

	    !+
	    ! Check to see if THIS virtual display occludes NEXT
	    ! vitual display and if so set occlusion bit of NEXT.
	    !-
	    IF SMG$$OCCLUDE ( TEMP_NEXT, TEMP_THIS, OVERLAP)
	    THEN
		NEXT_PP [PP_V_OCCLUDED] = 1;

	    !+
	    ! Walk chain in direction of earlier pasted packets.
	    !-
	    NEXT_PP_Q_HEAD = .NEXT_PP [PP_A_NEXT_PBCB];

	    END;	! For all displays from current to bottom

	!+
	! Walk chain in direction of earlier pasted packets.
	!-
	THIS_Q_HEAD = .THIS_PP [PP_A_NEXT_PBCB];

	END;	! For all displays from top to bottom

    RETURN (SS$_NORMAL);

    END;		! End of routine SMG$$CHECK_OCCLUSION
!<BLF/PAGE>

%SBTTL 'SMG$$CHECK_OCCLUSION_FIRST - Check pastings for occlusion'
GLOBAL ROUTINE SMG$$CHECK_OCCLUSION_FIRST (
				 PBCB : REF $PBCB_DECL
					) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This procedure updates the overlap bit in all the pastings to
!	a given pasteboard -- setting a bit in the respective pasting
!	packets to record whether each pasting is occluded by
!	the highest (most-recently pasted) pasting.  This procedure is
!	invoked whenever a virtual display is freshly pasted.
!
!	This routine differs from SMG$$CHECK_OCCLUSION it that that
!	routine compares all pastings to all other pasting.  This
!	routine only compares the top pasting to all the others since
!	the addition of this new top one can only add an occlusion to
!	a lower one.  Any occlusions already existing at a low level
!	cannot have been modified by pasting one more on top and there 
!	is no reason to recalculate their relationship to each other.
!
!	If we can determine at pasting time that a particular virtual
!	display (as pasted) and with a given succession of higher-pasted
!	virtual displays is not occluded by any of them,
!	we can make mapping run faster since a change to a virtual 
!	display which is not occluded causes only the changed virtual 
!	display to be remapped.  Higher pasted virtual displays do not 
!	have to be remapped since it is known that they do not occlude 
!	the changed one.
!
! CALLING SEQUENCE:
!
!	ret_status.wlc.v = SMG$$CHECK_OCCLUSION_FIRST ( PBCB.rab.r)
!
! FORMAL PARAMETERS:
!
!	PBCB.rab.r		Address of pasteboard control block
!				which has a new virtual display pasted
!				to it.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	SS$_NORMAL	Normal successful completion
!
! SIDE EFFECTS:
!
!	NONE
!--

    BEGIN
    LOCAL
	THIS_PP : REF $PP_DECL,	
			! Addr of pasting packet for upper-most pasted 
			! virtual display.

	THIS_Q_HEAD : REF BLOCK [,BYTE],
			! Addr of 2 longwords that form	queue header in
			! PP currently under inspection.

	NEXT_PP : REF $PP_DECL,	
			! Addr of pasting packet currently under
			! inspection.

	NEXT_PP_Q_HEAD : REF BLOCK [,BYTE],	
			! Addr of 2 longwords that form queue 
			! header in PP currently under 
			! inspection.

	TEMP_THIS : BLOCK [8,BYTE],	
			! Area of projection of THIS virtual
			! display on pasteboard

	TEMP_NEXT : BLOCK [8,BYTE],	
			! Area of projection of NEXT virtual
			! display on pasteboard

	THIS_DCB : REF $DCB_DECL; 	
			
			! Addr of virtual display currently
			! under inspection.

    THIS_Q_HEAD = .PBCB [PBCB_A_PP_NEXT];	! Most recent pasting
    THIS_PP = .THIS_Q_HEAD - PP_PBCB_QUEUE_OFFSET;

    THIS_DCB = .THIS_PP [PP_A_DCB_ADDR];

!+
! It is safe to assume that there is at least one virtual 
! display pasted to this pasteboard -- but there may not be more than 
! one.  Be careful about reaching ahead to a packet that may not be a 
! packet.  If doesn't exist, pointer will be pointing back into PBCB 
! -- and inner loop will not be executed.
!-
    NEXT_PP_Q_HEAD = .THIS_PP [PP_A_NEXT_PBCB];

    IF .NEXT_PP_Q_HEAD NEQ PBCB [PBCB_A_PP_NEXT]
    THEN
	BEGIN	! NEXT exists
	NEXT_PP = .NEXT_PP_Q_HEAD - PP_PBCB_QUEUE_OFFSET;
	!+
	! Form a representation of the projection of THIS virtual
	! display onto pasteboard coordinate system.
	!-
	TEMP_THIS [DCB_W_ROW_START] = .THIS_DCB [DCB_W_ROW_START] +
				      .THIS_PP [PP_W_ROW] - 1;
	TEMP_THIS [DCB_W_NO_ROWS]   = .THIS_DCB [DCB_W_NO_ROWS];
	TEMP_THIS [DCB_W_COL_START] = .THIS_DCB [DCB_W_COL_START] +
				      .THIS_PP [PP_W_COL] - 1;
	TEMP_THIS [DCB_W_NO_COLS]   = .THIS_DCB [DCB_W_NO_COLS];

	!+
	! If this virtual display is bordered, its projection is bigger
	! than if it were not.  Adjust its projection representation.
	!-
	IF .THIS_DCB [DCB_V_BORDERED]
	THEN
	    BEGIN	! Border adjustment
	    TEMP_THIS [DCB_W_ROW_START] = .TEMP_THIS [DCB_W_ROW_START] - 1;
	    TEMP_THIS [DCB_W_NO_ROWS]   = .TEMP_THIS [DCB_W_NO_ROWS] + 2;
	    TEMP_THIS [DCB_W_COL_START] = .TEMP_THIS [DCB_W_COL_START] - 1;
	    TEMP_THIS [DCB_W_NO_COLS]   = .TEMP_THIS [DCB_W_NO_COLS] + 2;
	    END;	! Border adjustment

	END;	! Next exists

    WHILE .NEXT_PP_Q_HEAD NEQ PBCB [PBCB_A_PP_NEXT]
    DO
	BEGIN	! For all displays from current to bottom
	LOCAL
	    NEXT_DCB : REF $DCB_DECL,	
				! Addr of DCB associated with NEXT_PP
	    OVERLAP : BLOCK [8,BYTE];	
				! Returned by SMG$$OCCLUDE, but not
				! used in this context

	NEXT_PP = .NEXT_PP_Q_HEAD - PP_PBCB_QUEUE_OFFSET;
	NEXT_DCB = .NEXT_PP [PP_A_DCB_ADDR];

	!+
	! Form a representation of the projection of NEXT virtual
	! display onto pasteboard coordinate system.
	!-
	TEMP_NEXT [DCB_W_ROW_START] = .NEXT_DCB [DCB_W_ROW_START] +
				      .NEXT_PP [PP_W_ROW] - 1;
	TEMP_NEXT [DCB_W_NO_ROWS]   = .NEXT_DCB [DCB_W_NO_ROWS];
	TEMP_NEXT [DCB_W_COL_START] = .NEXT_DCB [DCB_W_COL_START] +
				      .NEXT_PP [PP_W_COL] - 1;
	TEMP_NEXT [DCB_W_NO_COLS]   = .NEXT_DCB [DCB_W_NO_COLS];

	    !+
	    ! If this next virtual display is bordered, its projection is
	    ! bigger than if it were not.  Adjust its projection
	    ! representation.
	    !-
	    IF .NEXT_DCB [DCB_V_BORDERED]
	    THEN
		BEGIN	! Border adjustment
		TEMP_NEXT [DCB_W_ROW_START] = .TEMP_NEXT [DCB_W_ROW_START] - 1;
		TEMP_NEXT [DCB_W_NO_ROWS]   = .TEMP_NEXT [DCB_W_NO_ROWS] + 2;
		TEMP_NEXT [DCB_W_COL_START] = .TEMP_NEXT [DCB_W_COL_START] - 1;
		TEMP_NEXT [DCB_W_NO_COLS]   = .TEMP_NEXT [DCB_W_NO_COLS] + 2;
		END;	! Border adjustment

	!+
	! Check to see if THIS virtual display occludes NEXT
	! vitual display and if so set occlusion bit of NEXT.
	!-
	IF SMG$$OCCLUDE ( TEMP_NEXT, TEMP_THIS, OVERLAP)
	THEN
	    NEXT_PP [PP_V_OCCLUDED] = 1;

	!+
	! Walk chain in direction of earlier pasted packets.
	!-
	NEXT_PP_Q_HEAD = .NEXT_PP [PP_A_NEXT_PBCB];

	END;	! For all displays from current to bottom


    RETURN (SS$_NORMAL);

    END;		! End of routine SMG$$CHECK_OCCLUSION_FIRST
!<BLF/PAGE>

%SBTTL 'SMG$$CREATE_PASTEBOARD - Create Pasteboard Control Block (PBCB)'
GLOBAL ROUTINE SMG$$CREATE_PASTEBOARD (
				ROWS,
				COLS,
				PBCB_ADDR
				      ) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine allocates space for a pasteboard control block.
!	It also allocates a buffer called the output buffer
!	which is used to buffer output to this terminal
!	(if buffering is enabled).
!
! CALLING SEQUENCE:
!
!       ret_status.wlc.v = SMG$$CREATE_PASTEBOARD (
!						 ROWS.rl.r,
!						 COLS.rl.r,
!						 PBCB.wl.r)
!
! FORMAL PARAMETERS:
!
!	ROWS.rl.r	Max. number of rows that a window onto this
!			pasteboard will have.
!
!	COLS.rl.r	Max. number of columns that a window onto this
!			pasteboard will have.
!
!	PBCB_ADDR.wl.r	Address of the newly-created PBCB -- returned to
!			caller.
!
! IMPLICIT INPUTS:
!
!       NONE
!
! IMPLICIT OUTPUTS:
!
!       items in PBCB get filled in.
!	in particular, an output buffer is allocated.
!
! COMPLETION STATUS:
!
!       SS$_NORMAL      Normal successful completion
!       LIB$_INSVIRMEM  Insufficient virtual memory to allocate needed
!                       buffers.
!
! SIDE EFFECTS:
!
!       NONE
!--

    BEGIN
    LOCAL
	PBCB : REF $PBCB_DECL, ! Address of PBCB allocated.

	STATUS;		! Status of subroutine calls

    LITERAL

	PBCB_K_OUTBUF_DEFAULT_SIZE

	    = 256;	! Default size for output buffer
			! (if all other algorithms fail)

!+
! Allocate space for the PBCB itself.
!-
    IF NOT (STATUS = LIB$GET_VM (%REF (PBCB_K_SIZE), PBCB))
    THEN
	RETURN (.STATUS);

    CH$FILL (0, PBCB_K_SIZE, .PBCB);	! Clear all fields to default 0

!+
! Allocate the window control block that goes along with this
! pasteboard, returning failure if we can't.
!-
    IF NOT (STATUS = SMG$$CREATE_WCB (.ROWS, .COLS, PBCB [PBCB_A_WCB]))
    THEN
	BEGIN	! No more space
	!+
	! If we can't get space for WCB, we might as well give back
	! the PBCB space itself.
	!-
	LIB$FREE_VM (%REF (PBCB_K_SIZE), PBCB);
	RETURN (.STATUS);
	END;	! No more space

!+
! Allocate output buffer that goes along with this pasteboard, returning
! failure if we can't.
! This buffer is used (if buffering is enabled) to buffer all output to 
! this terminal.
! When V3B comes out, we should do a better job in figuring
! out a good size for this buffer by looking at sysgen paramaters
! and user quotas, etc.  For now, we just allocate a fixed space.
!-

    STATUS = LIB$GET_VM (%REF (PBCB_K_OUTBUF_DEFAULT_SIZE),
			 PBCB [PBCB_A_OUTPUT_BUFFER] );
    IF NOT .STATUS
    THEN
	BEGIN
	!+
	! If we can't get space for the output buffer, we might as well 
	! give back the PBCB space itself as well as the WCB space.
	! Ignore any errors that occur while trying to free this space.
	!-
	SMG$$DEALLOCATE_WCB( .PBCB [PBCB_A_WCB] );
	LIB$FREE_VM (%REF (PBCB_K_SIZE), PBCB);
	RETURN (.STATUS);
	END;

    PBCB [PBCB_W_OUTPUT_BUFSIZ] = PBCB_K_OUTBUF_DEFAULT_SIZE;	! allocation

!+
! Initialize pasting queue header to self.
!-
    PBCB [PBCB_A_PP_NEXT] = PBCB [PBCB_A_PP_NEXT];
    PBCB [PBCB_A_PP_PREV] = PBCB [PBCB_A_PP_NEXT];

!+
! Initialize mode settings to default.
!-
    PBCB [PBCB_L_MODE_SETTINGS] = PBCB_K_DEF_MODE_SETTINGS;

!+
! Return the address of the PBCB we've built.
!-
    .PBCB_ADDR = .PBCB;

    RETURN (SS$_NORMAL);
    END;			! Routine SMG$$CREATE_PASTEBOARD
!<BLF/PAGE>

%SBTTL 'SMG$$CREATE_VIRTUAL_DISPLAY - Create Virtual Display'
GLOBAL ROUTINE SMG$$CREATE_VIRTUAL_DISPLAY (
                                           NUM_ROWS,     ! height
                                           NUM_COLS,     ! width
                                           NEW_DISPLAY_ID,
                                           DISPLAY_ATTRIBUTES,
                                           VIDEO_ATTRIBUTES,
					   CHAR_SET
                                           ) =
!++
! FUNCTIONAL DESCRIPTION:
!
!       This routine creates a new virtual display -- returning its 
!       assigned display_id.  Its initial contents are blanks with
!	video attributes set to those specified.  The cursor 
!	will be at row 1 column 1.
!	This is the inner-most create_virtual_display routine.  It
!	assumes all of its parameters are present.
!
! CALLING SEQUENCE:
!
!       ret_status.wlc.v = SMG$$CREATE_VIRTUAL_DISPLAY ( 
!                               NUM_ROWS.rl.r,           ! Height
!                               NUM_COLS.rl.r,           ! Width
!                               NEW_DISPLAY_ID.wl.r,
!                               DISPLAY_ATTRIBUTES.rl.r,
!                               VIDEO_ATTRIBUTES.rl.r,
!				CHAR_SET.rl.r)
!
! FORMAL PARAMETERS:
!
!       NUM_ROWS.rl.r    Number of rows in new virtual display.
!
!       NUM_COLS.rl.r    Number of columns in new virtual display.
!
!       NEW_DISPLAY_ID.wl.r     Virtual display id of newly-created
!                               virtual display.
!
!       DISPLAY_ATTRIBUTES.rl.r The default display attributes.
!
!			SMG$M_BORDER if virtual display is to be 
!				     displayed with a border.
!
!			SMG$M_TRUNC_ICON if an icon should be displayed
!				     when text overflows the display 
!				     bounds.
!
!			SMG$M_DISPLAY_CONTROLS if carriage controls (CR, LF,
!				     (FF, VT, HT) should be displayed instead
!				     of executed.
!
!       VIDEO_ATTRIBUTES.rl.r   The default rendition code to be
!                       applied to all output to this display unless 
!                       overridden on a particular output call.
!
!                       Values:
!
!                       SMG$M_BLINK	displays characters blinking.
!
!                       SMG$M_BOLD	displays characters in 
!					higher-than-normal intensity.
!
!                       SMG$M_REVERSE	displays characters in reverse 
!					video -- that is, using the
!					opposite default rendition of 
!					the virtual display.
!
!                       SMG$M_UNDERLINE	displays characters underlined.
!
!	CHAR_SET.rb.r	Specifies the default character set to be used 
!			for this display.
!			Recognized values are:
!					SMG$C_UNITED_KINGDOM
!					SMG$C_ASCII (default)
!					SMG$C_SPEC_GRAPHICS
!					SMG$C_ALT_CHAR
!					SMG$C_ALT_GRAPHICS
!
! IMPLICIT INPUTS:
!
!       NONE
!
! IMPLICIT OUTPUTS:
!
!       NONE
!
! COMPLETION STATUS:
!
!       SS$_NORMAL      Normal successful completion
!       LIB$_INSVIRMEM  Insufficient virtual memory to allocate needed
!                       buffer.
!       SMG$_INVARG     Unrecognized Video Attributes
!                    or Unrecognized Display Attributes
!
! SIDE EFFECTS:
!
!       NONE
!--
    BEGIN
    LOCAL
	STATUS,			! Status of subroutine calls
	DCB : REF $DCB_DECL,	! Addr of display control block
	DESC : REF BLOCK [8,BYTE]; ! Pointer to dynamic descriptor in
				! DCB for border label

!+
! Allocate space for DCB itself.  Quit if we can't get it.
!-
    IF NOT (STATUS = LIB$GET_VM ( %REF (DCB_K_SIZE), DCB))
    THEN
	RETURN (.STATUS);

    CH$FILL (0, DCB_K_SIZE, .DCB);	! set all fields to default of 0

!+
! Set up dimensions of display
!-
    DCB [DCB_W_ROW_START] = 1;
    DCB [DCB_W_NO_ROWS]   = ..NUM_ROWS;
    DCB [DCB_W_COL_START] = 1;
    DCB [DCB_W_NO_COLS]   = ..NUM_COLS;
    DCB [DCB_L_BUFSIZE]	  = ..NUM_ROWS * ..NUM_COLS;

!+
! Record default display attributes, default video attributes and 
! default character set.
!-
    DCB [DCB_B_DEF_DISPLAY_ATTR] = ..DISPLAY_ATTRIBUTES;
    DCB [DCB_B_DEF_VIDEO_ATTR]   = ..VIDEO_ATTRIBUTES;
    DCB [DCB_B_DEF_CHAR_SET]     = ..CHAR_SET;

!+
! Set up various fields in the DCB
!-
    DCB [DCB_L_DID] = .DCB;		! Display id itself -- the
					! address of the DCB

    DCB [DCB_W_CURSOR_ROW] = 1;		! Cursor row and column to home
    DCB [DCB_W_CURSOR_COL] = 1;

    DCB [DCB_B_STRUCT_TYPE]  = DCB_K_STRUCT_TYPE; ! Mark as being a DCB
    DCB [DCB_W_DCB_LENGTH]   = DCB_K_SIZE;	  ! Size of structure

    DCB [DCB_W_TOP_OF_SCRREG] = .DCB [DCB_W_ROW_START];
    DCB [DCB_W_BOTTOM_OF_SCRREG] = .DCB [DCB_W_NO_ROWS];
					! init scrolling region
!+
! Allocate enough space for both the text buffer and the attribute
! buffer.
!-
    IF NOT (STATUS = LIB$GET_VM (%REF (.DCB [DCB_L_BUFSIZE] *2), 
				 DCB [DCB_A_TEXT_BUF]))
    THEN
	BEGIN	! Ran out of space
	!+
	! If we can't get enough space for the buffers, we might as well
	! give back the DCB space itself.
	!-
	LIB$FREE_VM ( %REF (DCB_K_SIZE), DCB); ! Return DCB space
	RETURN (.STATUS);	! Return the LIB$_INSVIRMEM from the
				! buffer allocation attempt
	END;	! Ran out of space

!+
! Use upper half of space allocated as the attribute buffer.
!-
    DCB [DCB_A_ATTR_BUF] = .DCB [DCB_A_TEXT_BUF] + .DCB [DCB_L_BUFSIZE];

!+
! Initialize text and attribute buffers.
!-
    CH$FILL (%C' ', .DCB [DCB_L_BUFSIZE], .DCB [DCB_A_TEXT_BUF]);
    CH$FILL (.DCB [DCB_B_DEF_VIDEO_ATTR], .DCB [DCB_L_BUFSIZE], 
	     .DCB [DCB_A_ATTR_BUF]);

!+
! If we are dealing with a non-standard character set, allocate the
! char_set buffer.  If we can't, bail out, giving back all the space
! allocated on this transaction.
!-
    IF .DCB [DCB_B_DEF_CHAR_SET] NEQ 0
    THEN
	BEGIN	! Will need char_set buffer
	IF NOT (STATUS = LIB$GET_VM ( DCB [DCB_L_BUFSIZE], 
				      DCB [DCB_A_CHAR_SET_BUF]))
	THEN
	    BEGIN	! Bailout
	    !+
	    ! If we can't get space for buffer we need, give back the
	    ! the text and attribute buffer, and DCB itself before
	    ! quitting.
	    !-
	    LIB$FREE_VM (%REF (2 * .DCB [DCB_L_BUFSIZE]), 
			 DCB [DCB_A_TEXT_BUF]);
	    LIB$FREE_VM (%REF (DCB_K_SIZE), DCB);
	    RETURN (.STATUS);
	    END;	! Bailout

	CH$FILL (.DCB [DCB_B_DEF_CHAR_SET], .DCB [DCB_L_BUFSIZE], 
		 .DCB [DCB_A_CHAR_SET_BUF]);

	END;	! Will need char_set buffer


!+
! Allocate and clear the line characteristics vector.
!-
    IF NOT (STATUS = LIB$GET_VM ( %REF ( .DCB [DCB_W_NO_ROWS] +1),
				  DCB [DCB_A_LINE_CHAR]))
    THEN
	BEGIN	! Error path
	!+
	! Give back all space accumulated on this trans. before
	! bailing out.
	!-
	LIB$FREE_VM (%REF (2 * .DCB [DCB_L_BUFSIZE]), 
		     DCB [DCB_A_TEXT_BUF]);

	IF .DCB [DCB_A_CHAR_SET_BUF] NEQ 0
	THEN
	    LIB$FREE_VM ( DCB [DCB_L_BUFSIZE], DCB [DCB_A_CHAR_SET_BUF]);

	LIB$FREE_VM (%REF (DCB_K_SIZE), DCB);

	RETURN (.STATUS);
	END;	! Error path

    CH$FILL ( 0, .DCB [DCB_W_NO_ROWS] + 1, .DCB [DCB_A_LINE_CHAR]);

!+
! Initialize pasting queue headers to point to self.
!-
    DCB [DCB_A_PP_NEXT] = DCB [DCB_A_PP_NEXT];
    DCB [DCB_A_PP_PREV] = DCB [DCB_A_PP_NEXT];

!+
! Initialize border label descriptor to virgin dynamic string descriptor
!-
    DESC = DCB [DCB_Q_LABEL_DESC];

    DESC [DSC$B_CLASS]		= DSC$K_CLASS_D;
    DESC [DSC$B_DTYPE]		= DSC$K_DTYPE_T;

!+
! Return the new display id to caller
!-
    .NEW_DISPLAY_ID = .DCB;

    RETURN (SS$_NORMAL);
    END;			! Routine SMG$$CREATE_VIRTUAL_DISPLAY
!<BLF/PAGE>

%SBTTL 'SMG$$CREATE_WCB - Create WCB and its buffers'
GLOBAL ROUTINE SMG$$CREATE_WCB (
				ROWS,
				COLS,
				WCB_ADDR
                                          ) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine allocates space for the window control block and 
!	its window text and attribute buffers and initializes them.
!	Two sets of these two buffers are built -- one to reflect what
!	is currently on the screen and one to build up what the next
!	screen image should look like.
!
! CALLING SEQUENCE:
!
!       ret_status.wlc.v = SMG$$CREATE_WCB (    ROWS.rl.r,
!						COLS.rl.r,
!						WCB_ADDR.wl.r)
!
! FORMAL PARAMETERS:
!
!	ROWS.rl.r	No. of rows in each of the buffers
!
!	COLS.rl.r	No. of columns in each of the buffers
!
!	WCB_ADDR.wl.r	Address of the newly-created WCB -- returned to
!			caller.
!
!
!
! IMPLICIT INPUTS:
!
!       NONE
!
! IMPLICIT OUTPUTS:
!
!       NONE
!
! COMPLETION STATUS:
!
!       SS$_NORMAL      Normal successful completion
!       LIB$_INSVIRMEM  Insufficient virtual memory to allocate needed
!                       buffer.
!
! SIDE EFFECTS:
!
!       NONE
!--
    BEGIN
    LOCAL
	WCB : REF $WCB_DECL,	! Address of WCB allocated.
	STATUS;			! Status of subroutine calls

!+
! Allocate space for the WCB itself.
!-
    IF NOT (STATUS = LIB$GET_VM (%REF (WCB_K_SIZE), WCB))
    THEN
	RETURN (.STATUS);

    CH$FILL (0, WCB_K_SIZE, .WCB);	! Clear all fields to default 0

    WCB [WCB_L_BUFSIZE] = ..ROWS * ..COLS; ! Overall size of each buffer

!+
! Attempt to get space for all 4 buffers at once, returning an error if
! we can't.
!-
    IF NOT (STATUS = LIB$GET_VM ( %REF (4 * .WCB [WCB_L_BUFSIZE]), 
				  WCB [WCB_A_TEXT_BUF]))
    THEN
	BEGIN	! No more space
	!+
	! If we can't get space for buffers, we might as well give back
	! the WCB space itself.
	!-
	LIB$FREE_VM (%REF (WCB_K_SIZE), WCB);
	RETURN (.STATUS);
	END;	! No more space

!+
! Carve up the space gotten into the 4 buffers we need.
!-
    WCB [WCB_A_ATTR_BUF]     = .WCB [WCB_A_TEXT_BUF] +     .WCB [WCB_L_BUFSIZE];
    WCB [WCB_A_SCR_TEXT_BUF] = .WCB [WCB_A_TEXT_BUF] + 2 * .WCB [WCB_L_BUFSIZE];
    WCB [WCB_A_SCR_ATTR_BUF] = .WCB [WCB_A_TEXT_BUF] + 3 * .WCB [WCB_L_BUFSIZE];

!+
! Initialize the working buffers.
!-
    CH$FILL (%C' ', .WCB [WCB_L_BUFSIZE], .WCB [WCB_A_TEXT_BUF]);
    CH$FILL (0,     .WCB [WCB_L_BUFSIZE], .WCB [WCB_A_ATTR_BUF]);

!+
! Initialize the buffers representing what's on the screen to non-
! matchable text as an initial state.  This means the first time
! minimum screen update looks at it it will cause the entire window
! to be repainted.
!-
    CH$FILL (-1, .WCB [WCB_L_BUFSIZE], .WCB [WCB_A_SCR_TEXT_BUF]);
    CH$FILL (0,  .WCB [WCB_L_BUFSIZE], .WCB [WCB_A_SCR_ATTR_BUF]);

!+
! Allocate the line characteristic vectors.  There are two of them --
! one for the text buffer and one for the screen text buffer.  We
! allocate and initialize them together for efficiency.
!-
    IF NOT (STATUS = LIB$GET_VM ( %REF (2 * (..ROWS + 1)),
				  WCB [WCB_A_LINE_CHAR]))
    THEN
	BEGIN	! Error path
	!+
	! Give back all space accumulated on this transaction.
	!-
	LIB$FREE_VM ( %REF (4 * .WCB [WCB_L_BUFSIZE]),
		      WCB [WCB_A_TEXT_BUF]);

	LIB$FREE_VM ( %REF (WCB_K_SIZE), WCB);
	END;	! Error path
!+
! Clear both buffer to zero at once
!-
    CH$FILL (0, 2 * (..ROWS + 1), .WCB [WCB_A_LINE_CHAR]);

!+
! Use upper half of space just allocated and cleared as the line
! characteristics vector for the screen text buffer.
!-
    WCB [WCB_A_SCR_LINE_CHAR] = .WCB [WCB_A_LINE_CHAR] + ..ROWS + 1;

!+
! Fill in rest of WCB and return the address of the WCB we've built.
!-
    WCB [WCB_W_NO_ROWS] = ..ROWS;
    WCB [WCB_W_ROW_START] = 1;
    WCB [WCB_W_NO_COLS] = ..COLS;
    WCB [WCB_W_COL_START]  = 1;

    .WCB_ADDR = .WCB;

    RETURN (SS$_NORMAL);
    END;			! Routine SMG$$CREATE_WCB
!<BLF/PAGE>

%SBTTL 'SMG$$DEALLOCATE_WCB - Get rid of WCB and its buffers'
GLOBAL ROUTINE SMG$$DEALLOCATE_WCB (WCB : REF $WCB_DECL) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine deallocates space for the window control block and 
!	its window text and attribute buffers.
!
! CALLING SEQUENCE:
!
!       ret_status.wlc.v = SMG$$CREATE_WCB ( WCB.wl.r)
!
! FORMAL PARAMETERS:
!
!	WCB.wl.r	Address of the previously-created WCB.
!
! IMPLICIT INPUTS:
!
!       contents of WCB
!
! IMPLICIT OUTPUTS:
!
!       NONE
!
! COMPLETION STATUS:
!
!       SS$_NORMAL      Normal successful completion
!	LIB$_xxx	Errors from LIB$FREE_VM
!
! SIDE EFFECTS:
!
!       NONE
!--
    BEGIN
    LOCAL
	RET_STATUS,		! Status to be returned to caller
	STATUS;			! Status of subroutine calls

!+
! Attempt to deallocate the space for all 4 buffers (text and attr) at 
! once.
!-
    RET_STATUS = LIB$FREE_VM ( %REF(4 * .WCB [WCB_L_BUFSIZE]), 
			       WCB [WCB_A_TEXT_BUF]);

!+
! Attempt to deallocate the alternate character set buffers if they 
! exist.
!-
    IF .WCB [WCB_A_CHAR_SET_BUF] NEQ 0
    THEN
	BEGIN	! Free alt char set buffers
	! NOTE: Right now we free them separately.  If it turns out
	! they are allocated as a adjacent pair, we can deallocate
	! them with a single call.

	STATUS = LIB$FREE_VM ( WCB [WCB_L_BUFSIZE], 
			       WCB [WCB_A_CHAR_SET_BUF]);

	IF NOT .STATUS THEN RET_STATUS = .STATUS ; ! Propagate an error
						   ! status

	STATUS = LIB$FREE_VM ( WCB [WCB_L_BUFSIZE], 
			       WCB [WCB_A_SCR_CHAR_SET_BUF]);

	IF NOT .STATUS THEN RET_STATUS = .STATUS ; ! Propagate an error
						   ! status
	END;	! Free alt char set buffers

!+
! Deallocate the line characteristics vectors.  These were allocated
! as a pair so can be deallocated as a pair.
!-
    STATUS = LIB$FREE_VM ( %REF ( 2 * (.WCB [WCB_W_NO_ROWS] + 1)),
			   WCB [WCB_A_LINE_CHAR]);

    IF NOT .STATUS THEN RET_STATUS = .STATUS;	! Propagate an error
						! status

!+
! Deallocate the WCB itself.
!-
    STATUS = LIB$FREE_VM (%REF(WCB_K_SIZE), WCB);
    IF NOT .STATUS THEN RET_STATUS = .STATUS ; ! Propagate an error status

    RETURN (.RET_STATUS);

    END;			! Routine SMG$$DEALLOCATE_WCB
!<BLF/PAGE>

%SBTTL 'SMG$$DUPL_VIRTUAL_DISPLAY - Duplicate a virtual display'
GLOBAL ROUTINE SMG$$DUPL_VIRTUAL_DISPLAY (
					    CURR_DISPLAY_ID,
					    NEW_DISPLAY_ID
                                          ) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine makes a copy of an existing virtual display, 
!	assigning it a new virtual display number.  The new virtual
!	will not be pasted anywhere -- even if the virtual display from
!	which it was created was.
!
! CALLING SEQUENCE:
!
!       ret_status.wlc.v = SMG$$DUPL_VIRTUAL_DISPLAY (CURR_DISPLAY_ID,
!						      NEW_DISPLAY_ID)
!
! FORMAL PARAMETERS:
!
!	CURR_DISPLAY_ID.rl.r	Display id of virtual display to be
!				replicated.
!
!	NEW_DISPLAY_ID.wl.r	Display id of newly-created virtual
!				display.
!
! IMPLICIT INPUTS:
!
!       NONE
!
! IMPLICIT OUTPUTS:
!
!       NONE
!
! COMPLETION STATUS:
!
!       SS$_NORMAL      Normal successful completion
!       LIB$_INSVIRMEM  Insufficient virtual memory to allocate needed
!                       buffer.
!
! SIDE EFFECTS:
!
!       NONE
!--
    BEGIN
    LOCAL
	DCB     : REF $DCB_DECL,	! Address of current DCB.
	DCB_NEW : REF $DCB_DECL,	! Address of new DCB
	STATUS;		! Status of subroutine calls

    $SMG$GET_DCB (.CURR_DISPLAY_ID, DCB); ! Get addr of DCB for current
					  ! display

!+
! If a backup DCB does not yet exist, allocate one.
! Make a new virtual display using the sizes and attributes of the old
! one.  Quit if we can't.
!-
    IF .DCB [DCB_A_BACKUP_DCB] EQL 0
    THEN
	BEGIN	! 1st time, create the backup
	IF NOT (STATUS = SMG$$CREATE_VIRTUAL_DISPLAY ( 
			%REF (.DCB [DCB_W_NO_ROWS]),		! #rows
			%REF (.DCB [DCB_W_NO_COLS]),		! #cols
			.NEW_DISPLAY_ID,			! new id
			%REF (.DCB [DCB_B_DEF_DISPLAY_ATTR]),	! disp
			%REF (.DCB [DCB_B_DEF_VIDEO_ATTR]),     ! video
			%REF (.DCB [DCB_B_DEF_CHAR_SET])))      ! alt char set
	THEN
	    RETURN (.STATUS);

	$SMG$GET_DCB (.NEW_DISPLAY_ID, DCB_NEW); ! Get DCB address of new

	!+
	! Store the new display id in the new DCB.
	!-
	DCB_NEW [DCB_L_DID] = ..NEW_DISPLAY_ID;

	END	! 1st time, create the backup

    ELSE
	BEGIN	! Backup already exists
	.NEW_DISPLAY_ID = .DCB [DCB_A_BACKUP_DCB]; ! Return id of existing
	DCB_NEW =         .DCB [DCB_A_BACKUP_DCB];
	END;	! Backup already exists

!+
! Now need to copy over the current text and attribute buffers from
! the current to the new.
!-

    CH$MOVE ( .DCB [DCB_L_BUFSIZE],				! #bytes
	      .DCB [DCB_A_TEXT_BUF],				! from
	      .DCB_NEW [DCB_A_TEXT_BUF]);			! to

    CH$MOVE ( .DCB [DCB_L_BUFSIZE],				! #bytes
	      .DCB [DCB_A_ATTR_BUF],				! from
	      .DCB_NEW [DCB_A_ATTR_BUF]);			! to

!+
! Copy over the line characteristics vector.
!-
    CH$MOVE ( .DCB [DCB_W_NO_ROWS] + 1,
	      .DCB [DCB_A_LINE_CHAR],
	      .DCB_NEW [DCB_A_LINE_CHAR]);

!+
! Copy over stuff relating to borders and labels.
!-
    IF .DCB_NEW [DCB_V_BORDERED]
    THEN
	BEGIN	! Bordered
	LOCAL
	    DESC : REF BLOCK [8,BYTE];	! Pointer to dynamic string
					! descriptor in DCB for border
					! label

	DESC = DCB [DCB_Q_LABEL_DESC];

	!+
	! If label exists, make a copy.
	!-
	IF .DESC [DSC$A_POINTER] NEQ 0
	THEN
	    BEGIN	! Labeled
	    IF NOT (STATUS = LIB$SCOPY_DXDX ( .DESC, 
					      DCB_NEW [DCB_Q_LABEL_DESC] ))
	    THEN
		RETURN (.STATUS);

	    DCB_NEW [DCB_W_LABEL_UNITS]    = .DCB [DCB_W_LABEL_UNITS];
	    DCB_NEW [DCB_B_LABEL_POS]      = .DCB [DCB_B_LABEL_POS];
	    DCB_NEW [DCB_B_LABEL_CHAR_SET] = .DCB [DCB_B_LABEL_CHAR_SET];
	    DCB_NEW [DCB_V_LABEL_CENTER]   = .DCB [DCB_V_LABEL_CENTER];

	    END;	! Labeled
	END;	! Bordered

!+
! If alternate character set buffer involved, copy it over as well.
!-
    IF .DCB_NEW [DCB_A_CHAR_SET_BUF] NEQ 0
    THEN
	BEGIN	! Alt char set buffer involved
	IF NOT (STATUS = LIB$GET_VM (DCB [DCB_L_BUFSIZE],
				     DCB_NEW [DCB_A_CHAR_SET_BUF]))
	THEN
	    RETURN (.STATUS);

	CH$MOVE (.DCB [DCB_L_BUFSIZE],			       ! Num.
		 .DCB [DCB_A_CHAR_SET_BUF],		       ! From
		 .DCB_NEW [DCB_A_CHAR_SET_BUF]);	       ! To

	END;	! Alt char set buffer involved

!+
! Also preserve the current cursor postion.
!-
    DCB_NEW [DCB_W_CURSOR_ROW] = .DCB [DCB_W_CURSOR_ROW];
    DCB_NEW [DCB_W_CURSOR_COL] = .DCB [DCB_W_CURSOR_COL];

    RETURN (SS$_NORMAL);
    END;			! Routine SMG$$DUPL_VIRTUAL_DISPLAY
!<BLF/PAGE>

%SBTTL 'SMG$$LOCATE_PP - Locate Pasting packet for given display and pasteboard'
GLOBAL ROUTINE SMG$$LOCATE_PP ( DCB  : REF $DCB_DECL,
				PBCB : REF $PBCB_DECL,
				PP ) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Locate the address of the pasting packet that joins this
!	virtual display to this pasteboard.
!
! CALLING SEQUENCE:
!
!       ret_status.wlc.v = SMG$$LOCATE_PP (	DCB.rab.r,
!						PBCB.rab.r,
!						PP.wl.r)
!
! FORMAL PARAMETERS:
!
!	DCB.rab.r	Address of a virtual display control block.
!
!	PBCB.rab.r	Address of a pasteboard control block.
!
!	PP.wl.r		Return address of the pasting packet that
!			represents the pasting of the given virtual
!			display to the given pasteboard control block.
!
! IMPLICIT INPUTS:
!
!       None
!
! IMPLICIT OUTPUTS:
!
!       None
!
! COMPLETION STATUS:
!
!       SS$_NORMAL      Normal successful completion
!	SMG$_NOTPASTED	Given display is not pasted to given pasteboard
!
! SIDE EFFECTS:
!
!       NONE
!--
    BEGIN
    LOCAL
        SEARCH_DCB : REF $DCB_DECL,	! Addr of the DCB we'll actually
					! search for

	CURR_PP : REF $PP_DECL;		! Addr of pasting packet being
					! inspected.

    CURR_PP = .DCB [DCB_A_PP_NEXT];	! Start with 1st PP in chain

!+
! If the virtual display is currently batched, the batch level will be non-zero.
! This means a match needs to be found on the backup DCB address instead of the
! DCB address.
!-
    SEARCH_DCB = .DCB;

    IF .DCB [DCB_L_BATCH_LEVEL] NEQ 0		! Currently batched
    THEN
	SEARCH_DCB = .DCB [DCB_A_BACKUP_DCB];


    WHILE .CURR_PP NEQ DCB [DCB_A_PP_NEXT]	! While any remain
    DO
	BEGIN	! Search for packet with matching PBCB addr
	IF .CURR_PP [PP_A_DCB_ADDR]  EQL .SEARCH_DCB	AND
	   .CURR_PP [PP_A_PBCB_ADDR] EQL .PBCB
	THEN
	    BEGIN	! Desired packet found
	    .PP = .CURR_PP;
	    RETURN (SS$_NORMAL);	! Return success
	    END;	! Desired packet found

	CURR_PP = .CURR_PP [PP_A_NEXT_DCB]; ! Otherwise step along DCB 
					    ! side of chain
	END;	! Search for packet with matching PBCB addr

!+
! If we fall out of the while loop, this virtual display is not pasted
! to the specified pasteboard -- according to the pasting packets.
!-
    .PP = 0;	! To reduce liklihood someone will try to use it
		! and disregard status.
    RETURN (SMG$_NOTPASTED);	! Return failure
    END;			! Routine SMG$$LOCATE_PP
!<BLF/PAGE>

%SBTTL 'SMG$$PASTE_VIRTUAL_DISPLAY - Paste virtual display to pasteboard'
GLOBAL ROUTINE SMG$$PASTE_VIRTUAL_DISPLAY (
					   DCB : REF $DCB_DECL,
					   PBCB : REF $PBCB_DECL,
                                           PASTEBOARD_ROW,
                                           PASTEBOARD_COL
                                         ) =
!++
! FUNCTIONAL DESCRIPTION:
!
!       The specified virtual display is "pasted" (oriented 
!       with respect to) a pasteboard.  This makes the display visible.
!	This is the inner paste routine.  It assumes input parameters
!	are all present and valid.  Further assumes that display
!	specified by DCB is not already pasted to pasteboard specified
!	by PBCB.
!
! CALLING SEQUENCE:
!
!       ret_status.wlc.v = SMG$$PASTE_VIRTUAL_DISPLAY ( 
!					      DCB.rab.r,
!                                             PBCB.rab.r,
!                                             PASTEBOARD_ROW.rl.r,
!                                             PASTEBOARD_COL.rl.r)
!
! FORMAL PARAMETERS:
!
!       DCB.rab.r		Address of virtual display to be pasted.
!
!       PBCB.rab.r		Address of the pasteboard on 
!				which the pasting is to take place.
!
!       PASTEBOARD_ROW.rl.r     Row on pasteboard which is to contain
!                               row 1 of the specified virtual display.
!
!       PASTEBOARD_COL.rl.r     Column on pasteboard which is to contain
!                               column 1 of the specified virtual
!                               display.
!
! IMPLICIT INPUTS:
!
!       None
!
! IMPLICIT OUTPUTS:
!
!       None
!
! COMPLETION STATUS:
!
!       SS$_NORMAL      Normal successful completion
!
! SIDE EFFECTS:
!
!       NONE
!--
    BEGIN
    LOCAL
	STATUS,				! Status of subroutine calls

	PP	: REF $PP_DECL,		! Addr of the pasting packet
					! being created.

	WCB	: REF $WCB_DECL;	! Addr. of window control block

!+
! Get space for pasting packet.
!-
    IF NOT (STATUS = LIB$GET_VM ( %REF (PP_K_SIZE), PP))
    THEN
	RETURN (.STATUS);

    CH$FILL (0, PP_K_SIZE, .PP);	! Clear all fields to default 0

!+
! Initialize pasting packet
!-
    PP [PP_A_DCB_ADDR]  = .DCB;
    PP [PP_A_PBCB_ADDR] = .PBCB;
    PP [PP_W_ROW]	= ..PASTEBOARD_ROW;
    PP [PP_W_COL]	= ..PASTEBOARD_COL;

!+
! Plug this packet onto both queues.
!-
    $SMG$INSERT_AT_HEAD ( PP [PP_A_NEXT_DCB],  DCB [DCB_A_PP_NEXT]);
    $SMG$INSERT_AT_HEAD ( PP [PP_A_NEXT_PBCB], PBCB [PBCB_A_PP_NEXT]);

!+
! If the display is batched, we want the backpointer in the PP to be
! pointing to our backup DCB.
!-
    IF .DCB [DCB_L_BATCH_LEVEL] NEQ 0
    THEN
	PP [PP_A_DCB_ADDR] = .DCB [DCB_A_BACKUP_DCB];

!+
! Recalc. occlusions introduced by this new pasting.
!-
    IF NOT ( STATUS = SMG$$CHECK_OCCLUSION_FIRST ( .PBCB)) 
    THEN 
	RETURN (.STATUS);

!+
! Calculate the transformation constants needed to copy this display's
! buffers into the associated window's buffers.
!-
    IF NOT ( STATUS = SMG$$CALC_PASTE_TRANSF (.PP)) 
    THEN 
	RETURN (.STATUS);

!+
! If pasteboard batching enabled, quit here.
!-
    IF .PBCB [PBCB_L_BATCH_LEVEL] NEQ 0
    THEN
	RETURN ( SMG$_BATWAS_ON);

!+
! Force physical display's cursor to be where this virtual display's
! cursor is.
! Chose between current DCB and backup DCB.
!-
    WCB = .PBCB [PBCB_A_WCB];

    IF .DCB [DCB_L_BATCH_LEVEL] EQL 0
    THEN
	BEGIN	! Get from current DCB
	WCB [WCB_W_CURR_CUR_ROW] = .DCB [DCB_W_CURSOR_ROW] - 1 + .PP [PP_W_ROW];
	WCB [WCB_W_CURR_CUR_COL] = .DCB [DCB_W_CURSOR_COL] - 1 + .PP [PP_W_COL];
	END	! Get from current DCB

    ELSE

	BEGIN	! Get from backup DCB
	LOCAL
	    BACK_DCB : REF $DCB_DECL; ! Addr of backup DCB

	BACK_DCB = .DCB [DCB_A_BACKUP_DCB];
	WCB [WCB_W_CURR_CUR_ROW] = .BACK_DCB [DCB_W_CURSOR_ROW] - 1 + .PP [PP_W_ROW];
	WCB [WCB_W_CURR_CUR_COL] = .BACK_DCB [DCB_W_CURSOR_COL] - 1 + .PP [PP_W_COL];
	END;	! Get from backup DCB

!+
! Move stuff from virtual display to pasteboard buffer and caused it
! to be output if pasteboard is not batched.
!-
    IF .PBCB [PBCB_L_BATCH_LEVEL] EQL 0
    THEN
	BEGIN
	PBCB [PBCB_W_FIRST_CHANGED_ROW] = 1;
	PBCB [PBCB_W_LAST_CHANGED_ROW]  = .PBCB [PBCB_B_ROWS];
	PBCB [PBCB_W_FIRST_CHANGED_COL] = 1;
	PBCB [PBCB_W_LAST_CHANGED_COL]  = .PBCB [PBCB_W_WIDTH];
	RETURN (SMG$$FILL_WINDOW_BUFFER (.PP));
	END;

!+
! Else just return Batch-was-On status.
!-
    RETURN ( SMG$_BATWAS_ON);

    END;			! Routine SMG$$PASTE_VIRTUAL_DISPLAY
!<BLF/PAGE>

%SBTTL 'SMG$$RECALC_PP_FIELDS - Recalc. Pasting Packet fields'
GLOBAL ROUTINE SMG$$RECALC_PP_FIELDS (
					DCB  : REF $DCB_DECL
				     )=
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine recalculates fields in the pasting packet that
!	need to change.
!	It walks the chain of pasting packets associated with the
!	given Display Control Block, updating each.
!
! CALLING SEQUENCE:
!
!       ret_status.wlc.v = SMG$$RECALC_PP_FIELDS ( DCB.rab.r )
!
! FORMAL PARAMETERS:
!
!	DCB.rab.r	Address of a virtual display control block.
!
! IMPLICIT INPUTS:
!
!       None
!
! IMPLICIT OUTPUTS:
!
!       None
!
! COMPLETION STATUS:
!
!       SS$_NORMAL      Normal successful completion
!	Statuses returned by SMG$$CHECK_OCCLUSION and 
!			     SMG$$CALC_PASTE_TRANF
!
! SIDE EFFECTS:
!
!       NONE
!--
    BEGIN
    LOCAL
	PP : REF $PP_DECL;		! Addr. of a pasting packet

!+
! Step through all associated pasting packets, updating each.
!-
    PP = .DCB [DCB_A_PP_NEXT];	! get 1st packet in DCB-oriented chain
    WHILE .PP NEQ DCB [DCB_A_PP_NEXT]	! While any remain...
    DO
	BEGIN
	LOCAL
	    STATUS,			! Status of subroutine calls
	    PBCB : REF $PBCB_DECL;	! Addr of pasteboard control blk

	PBCB = .PP [PP_A_PBCB_ADDR];
	!+
	! Calculate who occludes who in current pasting chain.
	!-
	IF NOT (STATUS =SMG$$CHECK_OCCLUSION ( .PBCB)) 	! Recalc. occlusion
	THEN 
	    RETURN (.STATUS);

	!+
	! Calculate critical constants used to map virtual displays
	! to their correct position within the pasteboard buffer.
	!-
	IF NOT ( STATUS = SMG$$CALC_PASTE_TRANSF ( .PP)) ! Clean up packet
	THEN 
	    RETURN (.STATUS);

	PP = .PP [PP_A_NEXT_DCB];	! Step to next packet
	END;

    RETURN ( SS$_NORMAL);
    END;			! Routine SMG$$RECALC_PP_FIELDS
!<BLF/PAGE>

%SBTTL 'SMG$$UNPASTE_VIRTUAL_DISPLAY - Unpaste virtual display from pasteboard'
GLOBAL ROUTINE SMG$$UNPASTE_VIRTUAL_DISPLAY (
						DCB :  REF $DCB_DECL,
						PBCB : REF $PBCB_DECL
                                            ) =
!++
! FUNCTIONAL DESCRIPTION:
!
!       The specified virtual display is "unpasted" from a pasteboard
!	if a pasting packet can be found.
!	This is the inner-most unpasting routine.  It assumes both
!	parameters are present and that they are valid (not necessarily
!	that the pasting packet which joins these two exists).
!
! CALLING SEQUENCE:
!
!       ret_status.wlc.v = SMG$$UNPASTE_VIRTUAL_DISPLAY ( 
!                                             DCB.rab.r,
!                                             PBCB.rab.r)
!
! FORMAL PARAMETERS:
!
!       DCB.rab.r		Address of DCB of virtual display to be 
!				unpasted.
!
!       PBCB.rab.r		Address of the pasteboard from
!				which the unpasting is to take place.
!
! IMPLICIT INPUTS:
!
!       None
!
! IMPLICIT OUTPUTS:
!
!       None
!
! COMPLETION STATUS:
!
!       SS$_NORMAL      Normal successful completion
!       SMG$_NOTPASTED	Specified virtual display is not currently
!                       pasted to the specified pasteboard.
!
! SIDE EFFECTS:
!
!       NONE
!--
    BEGIN
    LOCAL
	STATUS,				! Status of subroutine call
	PP	: REF $PP_DECL;		! Addr of pasting packet being
					! inspected.

!+
! Try to find the pasting packet joining this DCB and PBCB.
! Exit with SMG$_NOTPASTED if we can't.
!-

    IF NOT (STATUS = SMG$$LOCATE_PP ( .DCB, .PBCB, PP))
    THEN
	RETURN (.STATUS);   ! No common pasting packet exists

!+
! Located desired packet.  Remove it from both queues.
!-
    $SMG$REMOVE_FROM_QUEUE ( PP [PP_A_NEXT_DCB] );
    $SMG$REMOVE_FROM_QUEUE ( PP [PP_A_NEXT_PBCB] );

!+
! Give back the pasting packet space
!-
    IF NOT (STATUS = LIB$FREE_VM ( %REF(PP_K_SIZE), PP))
    THEN
	RETURN (.STATUS);

!+
! If other virtual displays are still pasted to this pasteboard, we need
! to recalculate their occlusion bits since they may have changed by
! removing this virtual display.
!-
    IF .PBCB [ PBCB_A_PP_NEXT] NEQ PBCB [ PBCB_A_PP_NEXT]
    THEN
	IF NOT ( STATUS = SMG$$CHECK_OCCLUSION ( .PBCB )) 
	THEN 
	    RETURN (.STATUS);

!+
! Cause pasteboard to reflect this change.
!-

    RETURN ( SMG$$CHECK_FOR_OUTPUT_PBCB ( .PBCB ));

    END;			! Routine SMG$$UNPASTE_VIRTUAL_DISPLAY
!<BLF/PAGE>

END			! End of module SMG$DISPLAY_LINKS

ELUDOM
