MODULE OUTPUT (	%TITLE 'Print Symbiont -- output routines'
	IDENT = 'V04-000',
	ADDRESSING_MODE (EXTERNAL = GENERAL)
	) =
BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY:
!	Print Symbiont.
!
! ABSTRACT:
!	Output routines.
!
! ENVIRONMENT:
!	VAX/VMS user mode.
!--
!
! AUTHOR: G. Robert, CREATION DATE: 31-Aug-1982
!
! MODIFIED BY:
!
!	3B-006	RRB3006		Rowland R. Bradley	24-Jul-1984
!		Add routine headers.
!
!	3B-005	GRR3005		Gregory R. Robert	29-Apr-1984
!		FT2 bugfixes.  Accept explict OPEN/CLOSE calls instead
!		of relying upon START_TASK.
!
!	3B-004	RRB3004		Rowland R. Bradley	27-Apr-1984
!		Add support for storage, initialization, and ultimate
!		display of the entire device name.
!
!	3B-003	GRR3003		Gregory R. Robert	23-Aug-1983
!		Bugfixes, page_setup_modules, form_setup_modules,
!		sheet_feed, symbiont initiated pause_task and stop_stream,
!		hangup code, read and write item services
!
!	3B-002	GRR3002		Gregory R. Robert	03-Aug-1983
!		Rewrite for new design.
!
!	3B-001	GRR3001		Gregory R. Robert	23-Jul-1983
!		Created new module.
!
!
!**

LIBRARY 'SYS$LIBRARY:LIB';
REQUIRE 'LIB$:SMBDEF';
REQUIRE 'SRC$:SMBREQ';

EXTERNAL ROUTINE
	PSM$REPORT,
	SMB$SEND_TO_JOBCTL,
	PSM$STORE_ERRORS
	;

EXTERNAL
	PSM$HANGUP_DISPATCH_TABLE
	;


FORWARD ROUTINE
	PSM$OUTPUT	,
	START_PRINTER	,
	STOP_PRINTER	,
	WRITE_AST	: NOVALUE
	;


%SBTTL 'PSM$OUTPUT'
! Functional Description:
!		?desc
!
! Formal Parameters:
!		?desc
! Implicit Inputs:
!		none
!
! Implicit Outputs:
!		none
!
! Returned Value:
!		none
!
! Side Effects:
!		none
!--
GLOBAL ROUTINE PSM$OUTPUT ( 
	SMB_CONTEXT	: REF $LONGWORD,
	USER_CONTEXT	: REF VECTOR,
	FUNCTION	: REF $LONGWORD,
	FUNC_DESC	: REF VECTOR,
	FUNC_ARG	: REF $LONGWORD
	)	=
BEGIN

SELECTONEU .FUNCTION[] OF
    SET

    [PSM$K_WRITE, PSM$K_WRITE_NOFORMAT]:
	BEGIN
	LOCAL IO_FUNC : INITIAL (IO$_WRITELBLK);
	LOCAL SIZE, ADDRESS;

	BIND IOB = .SMB_CONTEXT[] : $BBLOCK;
	BIND SCB = .IOB[IOB_A_CONTEXT] : $BBLOCK;

	! If device was hungup then mark it unavailable and request stop stream
	!
	IF TESTBITSC (SCB[PSM$V_HANGUP])
	THEN
	    BEGIN
	    SCB[PSM$L_DEVICE_STATUS] = .SCB[PSM$L_DEVICE_STATUS] OR
		(SMBMSG$M_UNAVAILABLE OR SMBMSG$M_STOP_STREAM);
	    RETURN SS$_HANGUP;
	    END;

	IF .FUNCTION[] EQL PSM$K_WRITE_NOFORMAT
	THEN
	    IF .SCB[PSM$L_DEVICE_CLASS] EQL DC$_TERM
	    THEN
		IO_FUNC = IO$_WRITELBLK OR IO$M_NOFORMAT
	    ELSE
		IO_FUNC = IO$_WRITEPBLK;

	STR$ANALYZE_SDESC_R1 (.FUNC_DESC; SIZE, ADDRESS);

	RETURN_IF_ERROR_ ($QIO (
	    FUNC	= .IO_FUNC,
	    CHAN	= .SCB[PSM$L_CHANNEL],
	    IOSB	= IOB[IOB_Q_IOSB],
	    ASTADR	= WRITE_AST,
	    ASTPRM	= IOB,
	    P1		= .ADDRESS,
	    P2		= .SIZE));
	END;

    [PSM$K_START_TASK]:
	BEGIN
	BIND SCB = .SMB_CONTEXT[] : $BBLOCK;
	LOCAL BUFFER : $BBLOCK [8];
	LOCAL DEVBUFSIZ : VOLATILE;
	LOCAL ITEM_LIST : $ITMLST_DECL (ITEMS=2);

	$ITMLST_INIT (ITMLST=ITEM_LIST,
	    (BUFADR=BUFFER +4,	ITMCOD=DVI$_DEVDEPEND OR DVI$C_SECONDARY),
	    (BUFADR=DEVBUFSIZ,	ITMCOD=DVI$_DEVBUFSIZ OR DVI$C_SECONDARY));

	RETURN_IF_ERROR_ ($GETDVIW
	    (CHAN=.SCB[PSM$L_CHANNEL], ITMLST=ITEM_LIST));

	! Set the page length so the driver can compute number of line
	! feeds for devices lacking mechanical form feed -- preserve the
	! class type and width information.
	!
	BUFFER [0,0,08,0] = .SCB[PSM$L_DEVICE_CLASS];
	BUFFER [1,0,08,0] = .SCB[PSM$L_DEVICE_TYPE];
	BUFFER [2,0,16,0] = .DEVBUFSIZ;			
	BUFFER [7,0,08,0] = .SCB[PSM$L_FORM_LENGTH];

	RETURN_IF_ERROR_ ($QIOW
	    (FUNC=IO$_SETMODE, CHAN=.SCB[PSM$L_CHANNEL], P1=BUFFER, P2=8));

	RETURN SS$_NORMAL;
	END;

    [PSM$K_CLOSE]:
	BEGIN
	BIND SCB = .SMB_CONTEXT[] : $BBLOCK;
	RETURN STOP_PRINTER (SCB[PSM$L_CHANNEL], SCB[PSM$Q_DEVICE_NAME]);
	END;

    [PSM$K_OPEN]:
	BEGIN
	BIND SCB = .SMB_CONTEXT[] : $BBLOCK;
	LOCAL DEVDEPEND : $BBLOCK[8];

	RETURN_IF_ERROR_ (START_PRINTER (
	    .FUNC_DESC,			! - specified device name
	    .FUNC_ARG,			! - resultant device status
	    SCB[PSM$L_CHANNEL],		! - channel assigned
	    SCB[PSM$L_DEVICE_CLASS],	! - device class
	    SCB[PSM$L_DEVICE_TYPE],	! - device type
	    .FUNC_DESC,			! - resultant device name
	    DEVDEPEND			! - device dependent bits
		));

	IF .SCB[PSM$L_DEVICE_CLASS] EQL DC$_TERM
	THEN
	    BEGIN
	    IF NOT .DEVDEPEND[TT$V_MECHTAB]
	    THEN
		SCB[PSM$V_EXPAND_TABS] = 1;

	    RETURN_IF_ERROR_ ($QIO (
		FUNC	= IO$_SETMODE OR IO$M_CTRLYAST,
		CHAN	= .SCB[PSM$L_CHANNEL],
		P1	= PSM$HANGUP_DISPATCH_TABLE +
			      (.SCB[PSM$L_STREAM_INDEX] *
			      PSM$S_HANGUP_DISPATCH_ENTRY),
		P2	= 0));
	    END
	ELSE
	    IF .SCB[PSM$L_DEVICE_TYPE] EQLU DT$_LP11
	    AND (NOT .DEVDEPEND[LP$V_TAB])
	    THEN
		SCB[PSM$V_EXPAND_TABS] = 1;

	RETURN SS$_NORMAL;
	END;

    [PSM$K_CANCEL]:
	BEGIN
	BIND SCB = .SMB_CONTEXT[] : $BBLOCK;
	RETURN_IF_ERROR_ ($CANCEL (CHAN=.SCB[PSM$L_CHANNEL]));
	END;

    [OTHERWISE]:
	RETURN PSM$_FUNNOTSUP;

    TES;

PSM$_PENDING

END;

%SBTTL 'START_PRINTER'
! Functional Description:
!		?desc
!
! Formal Parameters:
!		?desc
! Implicit Inputs:
!		none
!
! Implicit Outputs:
!		none
!
! Returned Value:
!		none
!
! Side Effects:
!		none
!--
ROUTINE START_PRINTER ( %SBTTL 'START_PRINTER'
	DEVICE_NAME,
	DEVICE_STATUS	: REF $LONGWORD,
	CHANNEL		: REF $WORD,
	DEVICE_CLASS	: REF $LONGWORD,
	DEVICE_TYPE	: REF $LONGWORD,
	OUT_DEVICE_NAME	,
	OUT_DEVDEPEND	: REF VECTOR
	) =
BEGIN
	PARAMETER_INDEX_ (DEVICE_NAME, DEVICE_STATUS, CHANNEL,
	    DEVICE_CLASS, DEVICE_TYPE, OUT_DEVICE_NAME, OUT_DEVDEPEND);

LOCAL
	CHAN		: INITIAL (0),
	ITEM_LIST	: $ITMLST_DECL (ITEMS=4),
	DEVDEPEND	: $BBLOCK[4] VOLATILE,
	DEVSTATUS	: INITIAL (0),
	DEVCLASS	: VOLATILE,
	DEVTYPE		: VOLATILE,
	DEVNAMSIZ	: INITIAL (0),
	DEVNAMBUF	: VECTOR [64, BYTE] VOLATILE,
	STATUS_1
	;

MAP
	DEVSTATUS	: $BBLOCK;

$ITMLST_INIT (ITMLST=ITEM_LIST,
    (BUFADR=DEVDEPEND,	ITMCOD=DVI$_DEVDEPEND	OR DVI$C_SECONDARY),
    (BUFADR=DEVCLASS,	ITMCOD=DVI$_DEVCLASS	OR DVI$C_SECONDARY),
    (BUFADR=DEVTYPE,	ITMCOD=DVI$_DEVTYPE	OR DVI$C_SECONDARY),
    (BUFADR=DEVNAMBUF,	ITMCOD=DVI$_FULLDEVNAM	OR DVI$C_SECONDARY,
    BUFSIZ=%ALLOCATION(DEVNAMBUF),  RETLEN=DEVNAMSIZ)
    );

IF PARAMETER_PRESENT_ (CHANNEL)
THEN
    CHANNEL[] = 0;

STATUS_1 = $ALLOC (DEVNAM=.DEVICE_NAME);
IF .STATUS_1 EQL SS$_DEVALRALLOC
THEN
    STATUS_1 = SS$_DEVALLOC;
IF NOT .STATUS_1
THEN
    RETURN .STATUS_1;

RETURN_IF_ERROR_ ($ASSIGN (DEVNAM=.DEVICE_NAME, CHAN=CHAN));

IF PARAMETER_PRESENT_ (CHANNEL)
THEN
    CHANNEL[] = .CHAN;

RETURN_IF_ERROR_ ($GETDVIW (CHAN=.CHAN, ITMLST=ITEM_LIST));

IF PARAMETER_PRESENT_ (OUT_DEVDEPEND)
THEN
    OUT_DEVDEPEND[0] = .DEVDEPEND;

SELECTONE .DEVCLASS OF
    SET

    [DC$_LP]:
	IF .DEVDEPEND[LP$V_LOWER]
	THEN
	    DEVSTATUS[SMBMSG$V_LOWERCASE] = 1;

    [DC$_TERM]:
	BEGIN
        DEVSTATUS[SMBMSG$V_TERMINAL] = 1;
	IF .DEVDEPEND[TT$V_MODEM]
	THEN
	    IF .DEVDEPEND[TT$V_REMOTE]
	    THEN
		DEVSTATUS[SMBMSG$V_REMOTE] = 1
	    ELSE
		RETURN SS$_HANGUP;
	IF .DEVDEPEND[TT$V_LOWER]
	THEN
	    DEVSTATUS[SMBMSG$V_LOWERCASE] = 1;
	END;

    [OTHERWISE]:
	BEGIN
	RETURN_IF_ERROR_ (STOP_PRINTER (CHANNEL[], .DEVICE_NAME));
	RETURN 0;		!*! Better message needed.
	END;

    TES;

IF NOT PARAMETER_PRESENT_ (CHANNEL)
THEN
    RETURN_IF_ERROR_ (STOP_PRINTER (CHANNEL[], .DEVICE_NAME));

IF PARAMETER_PRESENT_ (DEVICE_STATUS)
THEN
    DEVICE_STATUS[] = .DEVSTATUS;

IF PARAMETER_PRESENT_ (DEVICE_CLASS)
THEN
    DEVICE_CLASS[] = .DEVCLASS;

IF PARAMETER_PRESENT_ (DEVICE_TYPE)
THEN
    DEVICE_TYPE[] = .DEVTYPE;

IF PARAMETER_PRESENT_ (OUT_DEVICE_NAME)
THEN
    RETURN_IF_ERROR_ (STR$COPY_R (.OUT_DEVICE_NAME, DEVNAMSIZ, DEVNAMBUF));

SS$_NORMAL

END;

%SBTTL 'STOP_PRINTER'
! Functional Description:
!		?desc
!
! Formal Parameters:
!		?desc
! Implicit Inputs:
!		none
!
! Implicit Outputs:
!		none
!
! Returned Value:
!		none
!
! Side Effects:
!		none
!--
ROUTINE STOP_PRINTER ( 
	CHANNEL		: REF $WORD,
	DEVICE_NAME
	) =
BEGIN

LOCAL
	STATUS_1,
	STATUS_2
	;

STATUS_1 = $DASSGN (CHAN=.CHANNEL[]);

CHANNEL[] = 0;

STATUS_2 = $DALLOC (DEVNAM=.DEVICE_NAME);

IF NOT .STATUS_1
THEN
    RETURN .STATUS_1;

.STATUS_2

END;

%SBTTL 'WRITE_AST'
! Functional Description:
!		?desc
!
! Formal Parameters:
!		?desc
! Implicit Inputs:
!		none
!
! Implicit Outputs:
!		none
!
! Returned Value:
!		none
!
! Side Effects:
!		none
!--
ROUTINE WRITE_AST ( 
	IOB	: REF $BBLOCK
	)	: NOVALUE =
BEGIN

LOCAL
	FUNCTION_STATUS
	;

FUNCTION_STATUS = .IOB[IOB_W_IO_STATUS];

PSM$REPORT (IOB, FUNCTION_STATUS);

END;

END
ELUDOM
