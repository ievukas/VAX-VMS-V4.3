MODULE MAIL$ISAM_SUBS( %TITLE 'ISAM MAIL MESSAGE SUBROUTINES'
		IDENT = 'V04-000' ) =
BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY:	VAX/VMS MAIL UTILITY
!
! ABSTRACT:	Subroutines to read and write message files.
!
! ENVIRONMENT:	NATIVE/USER MODE
!
! AUTHOR: Benn Schreiber, CREATION DATE: 22-Dec-1982
!
! MODIFIED BY:
!
!	V03-022	ROP0031		Robert Posniak		02-AUG-1984
!		Make sure do not copy deleted messages between
!		folders during a COPY or MOVE command.
!
!	V03-021	ROP0027		Robert Posniak		23-JUL-1984
!		Change read cluster size from 127 to 32.
!
!	V03-020	ROP0003		Robert Posniak		 6-JUN-1984
!		Check for oversized record.  Fix COMPRESS
!		command to strip version number when opening
!		the newly created file.  Also, set the protection
!		on the .OLD file so that the owner can delete it.
!
!	V03-019	BLS0292		Benn Schreiber		 8-APR-1984
!		Pass accvios on in reclaim_handler
!
!	V03-018	BLS0263		Benn Schreiber		 4-FEB-1984
!		Add COMPRESS command. Use LIB$FIND_IMAGE_SYMBOL
!
!	V03-017	BLS0255		Benn Schreiber		28-Dec-1983
!		Global mail flags, sanitize flags to create_isam.  Add
!		support for exec mode logicals in create_isam.  Don't quit
!		on errors when emptying wastebasket.  If filing new message,
!		clear new message flag and decrement count (filed before
!		it was read).
!
!	V03-016	BLS0250		Benn Schreiber		 8-Dec-1983
!		Ensure users mail file is a disk file.
!
!	V03-015	BLS0246		Benn Schreiber		 7-Nov-1983
!		Put new mail count in VMSMAIL.DAT.  Confirm on non-existent
!		folder creation.  Remove check for uic ownership of external
!		mail files.
!
!	V03-014	BLS0238		Benn Schreiber		 1-Sep-1983
!		Check correct null parameter in mail$check_date, also
!		reinit descriptor before each fao
!
!	V03-013	BLS0237		Benn Schreiber		31-Aug-1983
!		Include end of file mark word in byte count.
!
!	V03-012	BLS0235		Benn Schreiber		23-Aug-1983
!		Have to read non-var files with $get's, since there is
!		no byte count.  Do not set folder name if no messages found
!		when selecting messages.  Filter trailing cr/lf's in
!		mail$get_i_msg.
!
!	V03-011	BLS0229		Benn Schreiber		16-Jul-1983
!		New routines to handle new message count in mail file.
!		Correct way messages are deleted on MOVE command.  Change
!		protection on external files and then $erase.  This then
!		requires no SYSPRV, and works over the net.
!
!	V03-010	BLS0227		Benn Schreiber		 1-Jul-1983
!		Remove system delete access from isam mail files.
!
!	V03-009	BLS0224		Benn Schreiber		 7-Jun-1983
!		Signal default folder not found in select_msgs, and
!		if /new, then go after default folder name, not MAIL.
!		Sort messages in add_message.  Enable DFW according to
!		MAIL$B_DFW (off for now).  Get rid of MAIL$GET_FILEDESC.
!
!	V03-008	BLS0222		Benn Schreiber		 7-May-1983
!		Modify reclaim operation to be automatic with a message
!
!	V03-007	BLS0221		Benn Schreiber		 5-May-1983
!		Remove temp message if $erase fails
!
!	V03-006	BLS0218		Benn Schreiber		18-Apr-1983
!		Enhance check_date to also ensure file doesn't exist
!		if optional 3rd dev/dir descr. is passed.
!
!	V03-005	BLS0217		Benn Schreiber		12-Apr-1983
!		Count bytes of deleted space, rather than number of messages.
!		Correct signalling of CONVERT/RECLAIM errors.  Tell
!		when new folder created with COPY command.  Add external
!		messages (stored in another file)
!
!	V03-004	BLS0216		Benn Schreiber		 1-Apr-1983
!		Use old message date time when copying messages
!
!	V03-003	BLS0215		Benn Schreiber		31-Mar-1983
!		Return "TO" string from MAIL$INFO_I_MSG
!
!	V03-002	BLS0214		Benn Schreiber		27-Mar-1983
!		Remove LASTREAD code.  Implement new scheme of NEWMAIL
!		handling.  Handle locked info records.  Add number of
!		records info in msg header.  Correct quoted sender name
!		parsing in MAIL$INFO_I_MSG.  Do not allow delete in waste
!		basket folder.  Tell user if new folder created.  Do not
!		update deleted msg count if number to add is 0.  Correct
!		handling of last message being deleted in MAIL$FIND_I_MSG.
!--

!
! TABLE OF CONTENTS:
!
!
! INCLUDE FILES:
!
    LIBRARY 'SYS$LIBRARY:LIB';
    REQUIRE 'SRC$:MAILREQ';
    LIBRARY 'LIB$:MAILDEF';

FORWARD ROUTINE
    MAIL$SELECT_MSGS;				!Select messages

GLOBAL
    MAIL$L_DELMSGCNT,				!Number deleted msgs
    MAIL$L_RECL_THRESHOLD : LONG INITIAL(32768),!Threshold before reclaim done
    MAIL$B_MSGTRAN : BYTE;			!Transition for get_i_msg

BIND
    MSGTRAN = MAIL$B_MSGTRAN : BYTE;

GLOBAL
    MAIL$Q_CURFOLDER : DYN_DESC_DECL,	!Descriptor of current folder name
    MAIL$Q_WASTEDESC : DYN_DESC_DECL,	!String descriptor for wastebasket
    MAIL$L_MSGMAX,			!Maximum number of messages in vector
    MAIL$L_NMSG,			!Number of messages currently in vector
    MAIL$L_CURMSG: REF $BBLOCK,		!Pointer to current message block
    MAIL$L_MSGTBL : REF VECTOR[,LONG];	!Pointer to message vector

EXTERNAL
    MAIL$GL_BIGBUFFER,			! and address
    MAIL$L_MYUIC,			!My UIC from SYSUAF
    MAIL$L_MYPID,			!My process pid
    MAIL$L_SIZLIM,			!Size of msg to externalize
    MAIL$Q_MSG_FNM : $BBLOCK,		!Descriptor of filename of mail file
    MAIL$B_DFW : BYTE,			!True if should use FOP=DFW
    MAIL$GL_FLAGS : $BBLOCK,		!Mail control flags
    MAIL$Q_MAILDEF : $BBLOCK,		!'dev:[dir]mail.mai' spec
    MAIL$Q_USERDEF : $BBLOCK,		!Default file spec
    MAIL$L_MSG_NUM,			!Current msg number
    MAIL$L_MSG_STS,			!msg status
    MAIL$L_RECBUF,			!Pointer to user record buffer
    MAIL$W_MSG_RSIZ : WORD,		!sequential msg size
    MAIL$L_MSG_RADR,			!seq. msg addr
    MAIL$Q_USERNAME : $BBLOCK,		!Descriptor for username
    MAIL$T_RD_RAB: $BBLOCK,		!RAB for reading input file
    MAIL$Q_RD_DESC: $BBLOCK;		!Descriptor of currently open mail file

EXTERNAL ROUTINE
    UTIL$GETFILENAME,
    LIB$FIND_IMAGE_SYMBOL,
    UTIL$REPORT_IO_ERROR,
    CLI$PRESENT,
    CLI$GET_VALUE,
    LIB$CVT_TIME,			!Convert date/time
    LIB$GET_VM,				!Allocate virtual memory
    LIB$PUT_OUTPUT,			!Write to SYS$OUTPUT
    LIB$FREE_VM,			!Dealocate it
    LIB$RENAME_FILE,
    LIB$SCOPY_R_DX,
    MAIL$CLOSE_FILE,			!Close msg file
    MAIL$CONFIRM,			!Ask question, get y/n answer
    MAIL$DISABLE_CTRLY,			!Disable CLI ctrl/y handling
    MAIL$ENABLE_CTRLY,			!Enable CLI ctrl/y handling
    MAIL$FIND_MSG,			!Find sequential message
    MAIL$FAO_GETMSG,			!GETMSG followed by FAO
    MAIL$GET_MSG,			!Get sequential file msg record
    MAIL$GETMSG,			!Get message text for message code
    MAIL$INCR_NEWMAIL,			!Increment new mail count
    MAIL$DECR_NEWMAIL,			! and decrement it
    MAIL$INFO_MSG,			!Get sequential file msg info
    MAIL$OPEN_FILE,			!Open msg file
    MAIL$RENAME_ERROR,			!Report error from lib$rename_file
    MAIL$RENAME_SUCCESS,		!Report success
    MAIL$REWIND_MSG,			!Rewind sequential message
    MAIL$TEST_SEQ_NEW,			!Test if message is new message
    MAIL$TEST_SUBJ,			!Test if subject present in seq. msg
    MAIL$WRITE_MSG,			!Write message to ISAM file
    STR$APPEND,				!String append
    STR$COPY_DX,			!String copy
    STR$CONCAT,				! concatenate
    STR$FREE1_DX,			!Deallocate dynamic string
    STR$TRIM,				!Trim trailing blanks
    SYS$FAO,
    UTIL$GETFILENAME;			!Get file spec from FAB

OWN
    YN_DESC : DYN_DESC_DECL,		!For yes/no answers
    SND_XABPRO : $XABPRO_DECL,		!Protection XAB
    DYN_DESC : DYN_DESC_DECL,
    DATEBUF : $BBLOCK[32],		!Temp buf for date/time
    DATEDESC : VECTOR[2,LONG];		!Descriptor for datebuf
!
! Define string descriptors
!
SD
    ('NEWMAIL',
    'CONVSHR',
    'MAIL');

BIND
    SD_NL = $DESCRIPTOR('NLA0:');

GLOBAL BIND
    MAIL$SD_NEWMAIL = SD_NEWMAIL,
    MAIL$SD_MAIL = SD_MAIL,
    MAIL$SD_EXTMSGNAM = $DESCRIPTOR('!ASMAIL$!XL!XL.MAI');
!
! Declare facility-specific versions of shared messages
!
$SHR_MSGDEF(MAIL,126,LOCAL,
	(COPIEDR,SUCCESS),
	(CREATED,SUCCESS),
	(INVQUAVAL,WARNING),
	(FILNOTDEL,ERROR),
	(OPENOUT,ERROR),
	(OPENIN,WARNING),
	(READERR,WARNING),
	(WRITEERR,WARNING),
	(CLOSEDEL,ERROR),
	(CLOSEOUT,WARNING));

LITERAL
	PRO_SYS		= $BITPOSITION(XAB$V_SYS),
	PRO_OWN		= $BITPOSITION(XAB$V_OWN),
	PRO_GRP		= $BITPOSITION(XAB$V_GRP),
	PRO_WLD		= $BITPOSITION(XAB$V_WLD),
	
	SND_PRO		= 			! Send file protection
(				  XAB$M_NOEXE OR XAB$M_NODEL) ^ PRO_SYS OR
(				  XAB$M_NOEXE OR XAB$M_NODEL) ^ PRO_OWN OR
(XAB$M_NOREAD OR XAB$M_NOWRITE OR XAB$M_NOEXE OR XAB$M_NODEL) ^ PRO_GRP OR
(XAB$M_NOREAD OR XAB$M_NOWRITE OR XAB$M_NOEXE OR XAB$M_NODEL) ^ PRO_WLD,
	DELETE_PRO		= 			! to delete a file
(				  XAB$M_NOEXE		    ) ^ PRO_SYS OR
(				  XAB$M_NOEXE 		    ) ^ PRO_OWN OR
(XAB$M_NOREAD OR XAB$M_NOWRITE OR XAB$M_NOEXE OR XAB$M_NODEL) ^ PRO_GRP OR
(XAB$M_NOREAD OR XAB$M_NOWRITE OR XAB$M_NOEXE OR XAB$M_NODEL) ^ PRO_WLD;

ROUTINE GET_MEM(SIZE,RETADR) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Allocate memory, signal error if unavailable and return status
!
!--
BEGIN

MAP
    RETADR : REF VECTOR[,LONG];

LOCAL
    STATUS;

IF NOT (STATUS = LIB$GET_VM(SIZE,RETADR[0]))
    THEN SIGNAL(.STATUS);

RETURN .STATUS
END;

ROUTINE ADD_MESSAGE(MSGADR) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Insert the message block into the message table.  If this message
!	causes the table to overflow, double the size of the table.
!
! INPUTS:
!	MSGADR is address of message descriptor block
!
!--
BEGIN

MAP
    MSGADR : REF $BBLOCK;

LOCAL
    NMSG,
    DATE1 : REF VECTOR[,LONG],
    DATE2 : REF VECTOR[,LONG],
    PTR : REF $BBLOCK;

IF .MAIL$L_NMSG EQL .MAIL$L_MSGMAX
THEN BEGIN
    IF .MAIL$L_MSGMAX NEQ 0		!If this is not first time...
    THEN BEGIN
	!
	! Allocate new table 2* size of old one
	!
	IF_ERR(GET_MEM((8*.MAIL$L_MSGMAX),PTR);,
			RETURN .STATUS);
	CH$MOVE(.MAIL$L_MSGMAX*4,.MAIL$L_MSGTBL,.PTR);
	LIB$FREE_VM(%REF(4*.MAIL$L_MSGMAX),MAIL$L_MSGTBL);
	MAIL$L_MSGTBL = .PTR;
	MAIL$L_MSGMAX = 2*.MAIL$L_MSGMAX;
	END
    ELSE BEGIN
	IF_ERR(GET_MEM(128*4,MAIL$L_MSGTBL);,
		RETURN .STATUS);
	MAIL$L_MSGMAX = 128;
	END;
    END;

!
! Assume message will go at the end of the vector list
!
DATE1 = MSGADR[MMB_T_HDREC];
MAIL$L_MSGTBL[.MAIL$L_NMSG] = .MSGADR;		!Preset in new slot in table
MAIL$L_NMSG = .MAIL$L_NMSG + 1;
IF .MAIL$L_NMSG GTRU 1
THEN BEGIN
    PTR = .MAIL$L_MSGTBL[.MAIL$L_NMSG-2];
    DATE2 = PTR[MMB_T_HDREC];
    IF (.DATE1[1] GTRU .DATE2[1])
	OR ((.DATE1[1] EQL .DATE2[1])
	    AND (.DATE1[0] GTRU .DATE2[0]))
	THEN RETURN TRUE;
    END;
!
! It didn't.  Run through the vector and find the message it goes
! in front of.
!
INCR I FROM 0 TO .MAIL$L_NMSG-2
DO BEGIN
    PTR = .MAIL$L_MSGTBL[.I];
    DATE2 = PTR[MMB_T_HDREC];
    IF (.DATE1[1] LSSU .DATE2[1])
	OR ((.DATE1[1] EQL .DATE2[1])
	    AND (.DATE1[0] LSSU .DATE2[0]))
    THEN BEGIN
	LOCAL J;

	J = .MAIL$L_NMSG - .I;
	CH$MOVE(.J*4,MAIL$L_MSGTBL[.I],MAIL$L_MSGTBL[.I+1]);
	MAIL$L_MSGTBL[.I] = .MSGADR;
	EXITLOOP;
	END;
    END;

RETURN TRUE
END;

GLOBAL ROUTINE MAIL$FORM_EXTFILE (DATIM,DESC) : NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Make the external file name
!
!--
BEGIN
MAP
    DESC : REF $BBLOCK;

LOCAL
    FDESC : VECTOR[2,LONG],
    TMPFAB : $FAB_DECL,
    TMPNAM : $NAM_DECL,
    NAMBUF : $BBLOCK[NAM$C_MAXRSS];

$FAB_INIT(FAB=TMPFAB,
	FNS=.MAIL$Q_RD_DESC[DSC$W_LENGTH],
	FNA=.MAIL$Q_RD_DESC[DSC$A_POINTER],
	NAM=TMPNAM);

$NAM_INIT(NAM=TMPNAM,
	ESS=NAM$C_MAXRSS,
	ESA=NAMBUF,
	RSS=NAM$C_MAXRSS,
	RSA=NAMBUF);

$PARSE(FAB=TMPFAB);
FDESC[0] = .TMPNAM[NAM$B_NODE] + .TMPNAM[NAM$B_DEV] + .TMPNAM[NAM$B_DIR];
FDESC[1] = (IF .TMPNAM[NAM$L_NODE] NEQ 0
		THEN .TMPNAM[NAM$L_NODE]
		ELSE .TMPNAM[NAM$L_DEV]);

SYS$FAO(MAIL$SD_EXTMSGNAM,.DESC,.DESC,FDESC,
			.(.DATIM)<32,32,0>,
			.(.DATIM)<0,32,0>);
RETURN;
END;

ROUTINE READ_SAVE_EXTMSG =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Read a message which is contained in an external message file
!
!--
BEGIN
LOCAL
    STATUS,
    TMPFAB : $FAB_DECL,
    TMPRAB : $RAB_DECL,
    TMPNAM : $NAM_DECL,
    NAMBUF : $BBLOCK[NAM$C_MAXRSS],
    TMPXAB : $XABFHC_DECL,
    TMPXAB1 : $XABPRO_DECL,
    LASTBLOCK : REF $BBLOCK,
    PTR : REF $BBLOCK,
    DESC : VECTOR[2,LONG],
    BUFSIZ,
    NBYTES,
    NBLOCKS;

MAIL$L_CURMSG[MMB_V_EXTFNF] = FALSE;
DESC[0] = NAM$C_MAXRSS;
DESC[1] = NAMBUF;
MAIL$FORM_EXTFILE(MAIL$L_CURMSG[MMB_Q_DATID],DESC);
!
! Open the external message file
!
$FAB_INIT(FAB=TMPFAB,
	FAC=(GET,BRO),
	FOP=SQO,
	FNS=.DESC[0],
	FNA=.DESC[1],
	CTX=MAIL$_OPENIN,
	XAB=TMPXAB,
	NAM=TMPNAM);

$XABFHC_INIT(XAB=TMPXAB,
	NXT=TMPXAB1);

$XABPRO_INIT(XAB=TMPXAB1,
	NXT=0);

$RAB_INIT(RAB=TMPRAB,
	ROP=BIO,
	FAB=TMPFAB);

$NAM_INIT(NAM=TMPNAM,
	ESS=NAM$C_MAXRSS,
	ESA=NAMBUF,
	RSS=NAM$C_MAXRSS,
	RSA=NAMBUF);

IF_ERR($OPEN(FAB=TMPFAB,ERR=UTIL$REPORT_IO_ERROR);,
	MAIL$L_CURMSG[MMB_V_EXTFNF] = TRUE;
	RETURN .STATUS);

!
! If file is not variable length sequential, then we have to
! read in records
!
IF .TMPFAB[FAB$B_RFM] NEQ FAB$C_VAR
    OR .TMPFAB[FAB$B_ORG] NEQ FAB$C_SEQ
    THEN MAIL$L_CURMSG[MMB_V_EXTNSTD] = NOT (TMPRAB[RAB$V_BIO] = FALSE);

IF_ERR($CONNECT(RAB=TMPRAB,ERR=UTIL$REPORT_IO_ERROR);,
	$CLOSE(FAB=TMPFAB);
	MAIL$L_CURMSG[MMB_V_EXTFNF] = TRUE;
	RETURN .STATUS);

IF .TMPRAB[RAB$V_BIO]
THEN BEGIN
    BUFSIZ = (.TMPXAB[XAB$L_EBK]*512);
    MAIL$L_CURMSG[MMB_L_NBLKS] = .BUFSIZ;	!Compute bytes, converted later
    NBYTES = ((.TMPXAB[XAB$L_EBK]-1)*512)+.TMPXAB[XAB$W_FFB];
    IF .BUFSIZ EQL 0
	THEN ($CLOSE(FAB=TMPFAB);
		RETURN TRUE);

    IF_ERR(GET_MEM(TXT_C_LENGTH+.BUFSIZ,PTR);,
	$CLOSE(FAB=TMPFAB);
	MAIL$L_CURMSG[MMB_V_EXTFNF] = TRUE;
	RETURN .STATUS);

    PTR[TXT_L_NEXT] = 0;
    MAIL$L_CURMSG[MMB_L_TXTLST] = .PTR;
    PTR[TXT_L_TEXTLEN] = .NBYTES;
    PTR[TXT_L_ALLOC] = .BUFSIZ;
    BUFSIZ = .BUFSIZ/512;
    TMPRAB[RAB$L_CTX] = MAIL$_READERR;
    TMPRAB[RAB$L_UBF] = PTR[TXT_T_TEXT];
    WHILE .BUFSIZ GTR 0
    DO BEGIN
	NBLOCKS = MINU(32,.BUFSIZ);
	TMPRAB[RAB$W_USZ] = .NBLOCKS*512;
	IF_ERR($READ(RAB=TMPRAB,ERR=UTIL$REPORT_IO_ERROR);,
		$CLOSE(FAB=TMPFAB);
		IF .NBYTES NEQ 0
		    THEN MAIL$L_CURMSG[MMB_V_EXTFNF] = TRUE;
		RETURN .STATUS);
	TMPRAB[RAB$L_UBF] = .TMPRAB[RAB$L_UBF] + .TMPRAB[RAB$W_RSZ];
	BUFSIZ = .BUFSIZ - .NBLOCKS;
	END;
    END
ELSE BEGIN
    !
    ! Record format is not variable length, read file in record mode
    !
    LASTBLOCK = MAIL$L_CURMSG[MMB_L_TXTLST];
    MAIL$L_CURMSG[MMB_L_NBLKS] = 0;
    TMPRAB[RAB$L_UBF] = .MAIL$GL_BIGBUFFER;
    TMPRAB[RAB$W_USZ] = MAIL$K_INBUFFSZ;
    WHILE (STATUS = $GET(RAB=TMPRAB,ERR=UTIL$REPORT_IO_ERROR)) NEQ RMS$_EOF
    DO BEGIN
	IF_ERR(GET_MEM(TXT_C_LENGTH+.TMPRAB[RAB$W_RSZ],PTR);,
		SIGNAL(.STATUS);
		MAIL$L_CURMSG[MMB_V_EXTFNF] = TRUE;
		$CLOSE(FAB=TMPFAB);
		RETURN .STATUS);
	PTR[TXT_L_NEXT] = 0;
	LASTBLOCK[TXT_L_NEXT] = .PTR;
	LASTBLOCK = .PTR;
	MAIL$L_CURMSG[MMB_L_NBLKS] = .MAIL$L_CURMSG[MMB_L_NBLKS] + 
					.TMPRAB[RAB$W_RSZ] + 2;
	PTR[TXT_L_TEXTLEN] = .TMPRAB[RAB$W_RSZ];
	PTR[TXT_L_ALLOC] = .PTR[TXT_L_TEXTLEN];
	CH$MOVE(.TMPRAB[RAB$W_RSZ],.TMPRAB[RAB$L_RBF],PTR[TXT_T_TEXT]);
	END;
    END;
$CLOSE(FAB=TMPFAB);
RETURN TRUE
END;

ROUTINE READ_SAVE_MSG =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Read the text records of the current message and stash them in
!	memory
!
!--
BEGIN

LOCAL
    LASTBLOCK : REF $BBLOCK,
    PTR : REF $BBLOCK,
    RECLEN,
    STATUS;

MAIL$L_CURMSG[MMB_L_NBLKS] = 0;

IF .MAIL$L_CURMSG[MMB_V_EXTMSG]
    THEN RETURN READ_SAVE_EXTMSG();

MAIL$T_RD_RAB[RAB$L_ROP] = RAB$M_LIM OR RAB$M_LOC OR RAB$M_NLK;
MAIL$T_RD_RAB[RAB$L_KBF] = MAIL$L_CURMSG[MMB_Q_DATID];
MAIL$T_RD_RAB[RAB$B_KSZ] = 8;
MAIL$T_RD_RAB[RAB$B_KRF] = 0;
MAIL$T_RD_RAB[RAB$B_RAC] = RAB$C_KEY;
MAIL$T_RD_RAB[RAB$L_CTX] = MAIL$_READERR;
MAIL$T_RD_RAB[RAB$L_UBF] = .MAIL$L_RECBUF;
IF_ERR($FIND(RAB=MAIL$T_RD_RAB);,
	IF .STATUS EQL RMS$_RNF
	    THEN RETURN TRUE;
	UTIL$REPORT_IO_ERROR(MAIL$T_RD_RAB);
	RETURN .STATUS);
MAIL$T_RD_RAB[RAB$B_RAC] = RAB$C_SEQ;
!
! Read in all records of this message
!
LASTBLOCK = MAIL$L_CURMSG[MMB_L_TXTLST];
WHILE 1
DO BEGIN
    STATUS = $GET(RAB=MAIL$T_RD_RAB);
    IF NOT .STATUS
    THEN BEGIN
	IF .STATUS NEQ RMS$_RNF
	AND .STATUS NEQ RMS$_EOF
	THEN RETURN UTIL$REPORT_IO_ERROR(MAIL$T_RD_RAB);
	EXITLOOP;
	END;
    IF .STATUS EQL RMS$_OK_LIM
	THEN EXITLOOP;
    IF .MAIL$T_RD_RAB[RAB$W_RSZ] GTRU 8		!Skip marker records
    THEN BEGIN
	RECLEN = .MAIL$T_RD_RAB[RAB$W_RSZ] - $BYTEOFFSET(MFR_T_DATA);
	IF_ERR(GET_MEM(TXT_C_LENGTH+.RECLEN,PTR);,
		RETURN .STATUS);
	PTR[TXT_L_NEXT] = .LASTBLOCK[TXT_L_NEXT];
	LASTBLOCK[TXT_L_NEXT] = .PTR;
	LASTBLOCK = .PTR;
	MAIL$L_CURMSG[MMB_L_NBLKS] = .MAIL$L_CURMSG[MMB_L_NBLKS] + .RECLEN + 2;
	PTR[TXT_L_TEXTLEN] = .RECLEN;
	PTR[TXT_L_ALLOC] = .RECLEN;
	CH$MOVE(.RECLEN,.MAIL$T_RD_RAB[RAB$L_RBF]+$BYTEOFFSET(MFR_T_DATA),
		PTR[TXT_T_TEXT]);
	END;
    END;

RETURN TRUE
END;

ROUTINE DEALLOC_MSG =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Deallocate all storage used for current msg
!
! IMPLICIT INPUTS:
!
!	MAIL$L_CURMSG points at message descriptor block
!--
BEGIN

LOCAL
    PTR : REF $BBLOCK,
    BUFSIZ,
    PTR1;

IF .MAIL$L_CURMSG EQL 0
    THEN RETURN TRUE;

PTR = .MAIL$L_CURMSG[MMB_L_TXTLST];
IF_ERR(LIB$FREE_VM(%REF(MMB_C_LENGTH+.MAIL$L_CURMSG[MMB_W_HDRECLEN]),
			MAIL$L_CURMSG);,
	SIGNAL((.STATUS AND NOT STS$M_SEVERITY) OR STS$K_ERROR));
MAIL$L_CURMSG = 0;
IF .PTR NEQ 0
THEN WHILE .PTR NEQ 0
DO BEGIN
    PTR1 = .PTR[TXT_L_NEXT];
    BUFSIZ = TXT_C_LENGTH+.PTR[TXT_L_TEXTLEN];
    IF_ERR(LIB$FREE_VM(%REF(TXT_C_LENGTH+.PTR[TXT_L_ALLOC]),PTR);,
		SIGNAL((.STATUS AND NOT STS$M_SEVERITY) OR STS$K_ERROR));
    PTR = .PTR1;
    END;
RETURN TRUE
END;

ROUTINE FIND_FILE_TYPE (IFAB) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine returns the file type in IFAB[FAB$B_ORG].  This is needed
!	if RMS returns RMS$_FLK.
!
! Inputs:
!
!	IFAB = addr of FAB after $OPEN has been tried (must have an attached
!		NAM block
!--
BEGIN
MAP
    IFAB : REF $BBLOCK;

BIND
    INAM = .IFAB[FAB$L_NAM] : $BBLOCK;

LOCAL
    STATUS,
    SAVE_STS,
    SAVE_STV,
    IOSB : VECTOR[4,WORD],
    CHANNEL : WORD,
    FIB_DESC : VECTOR[2,LONG],
    FIB : $BBLOCK[FIB$C_ACCDATA],
    ATR : BLOCKVECTOR[1,8,BYTE],
    FILATR : $BBLOCK[ATR$S_RECATTR];

SAVE_STS = .IFAB[FAB$L_STS];
SAVE_STV = .IFAB[FAB$L_STV];
IF (STATUS = $PARSE(FAB=.IFAB))
    THEN (STATUS = $SEARCH(FAB=.IFAB));
IFAB[FAB$L_STS] = .SAVE_STS;
IFAB[FAB$L_STV] = .SAVE_STV;
IF NOT .STATUS
    THEN RETURN .STATUS;
!
! Assign a channel to the device
!
FIB_DESC[0] = (IF .INAM[NAM$B_RSL] NEQ 0
		THEN .INAM[NAM$B_RSL]
		ELSE .INAM[NAM$B_ESL]);
FIB_DESC[1] = .INAM[NAM$L_RSA];
IF NOT (STATUS = $ASSIGN(DEVNAM=FIB_DESC,
			CHAN=CHANNEL))
    THEN RETURN .STATUS;

CH$FILL(0,FIB$C_ACCDATA,FIB);
FIB[FIB$L_ACCTL] = 0;		!No special options
FIB[FIB$W_FID_NUM] = .INAM[NAM$W_FID_NUM];
FIB[FIB$W_FID_SEQ] = .INAM[NAM$W_FID_SEQ];
FIB[FIB$W_FID_RVN] = .INAM[NAM$W_FID_RVN];

FIB_DESC[0] = FIB$C_ACCDATA;
FIB_DESC[1] = FIB;

ATR[0,ATR$W_TYPE] = ATR$C_RECATTR;
ATR[0,ATR$W_SIZE] = ATR$S_RECATTR;
ATR[0,ATR$L_ADDR] = FILATR;

STATUS = $QIOW(FUNC=IO$_ACCESS,
			CHAN=.CHANNEL,
			EFN=0,
			IOSB=IOSB,
			P1=FIB_DESC,
			P5=ATR);
IF .STATUS
    THEN STATUS = .IOSB[0];

$DASSGN(CHAN=.CHANNEL);

IF NOT .STATUS
    THEN RETURN .STATUS;

IFAB[FAB$B_ORG] = 0;
IF .FILATR[FAT$V_FILEORG] EQL FAT$C_INDEXED
    THEN IFAB[FAB$B_ORG] = FAB$C_IDX
    ELSE IF .FILATR[FAT$V_FILEORG] EQL FAT$C_SEQUENTIAL
	THEN IFAB[FAB$B_ORG] = FAB$C_SEQ;

RETURN TRUE
END;

GLOBAL ROUTINE MAIL$CREATE_ISAM (IFAB,IRAB,INAM,NAMDESC,UIC,FLAGS,DEFDESC) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Create/open the named ISAM file
!
! INPUTS:
!
!	IFAB is fab address
!	IRAB is rab address
!	INAM is nam block address
!	NAMDESC is descriptor for file spec
!	UIC is desired owner, or 0 if current
!	FLAGS are: MCR_V_CIF to create_if, 0 to unconditionally create
!		MCR_V_NIL to create with no sharing
!		MCR_V_EXEC to restrict to exec mode logicals
!	DEFDESC (optional) address of descriptor for default spec.  If
!		not specified, MAIL$Q_MAILDEF is used.
!
! ROUTINE VALUE:
!
!	RMS$_SHR - file is sequential
!	RMS$_FLK - isam file is locked
!	1 - SUCCESS
!--
BEGIN
BUILTIN
    NULLPARAMETER;

MAP
    IFAB : REF $BBLOCK,
    IRAB : REF $BBLOCK,
    INAM : REF $BBLOCK,
    NAMDESC : REF $BBLOCK,
    FLAGS : $BBLOCK,
    DEFDESC : REF $BBLOCK;

LOCAL
    STATUS,
    FILE_TYPE,
    DEFLEN,
    DEFADR,
    XABALL0 : $XABALL_DECL,
    XABALL1 : $XABALL_DECL,
    XABALL2 : $XABALL_DECL,
    XABKEY0 : $XABKEY_DECL,
    XABKEY1 : $XABKEY_DECL;

DEFLEN = .MAIL$Q_MAILDEF[DSC$W_LENGTH];
DEFADR = .MAIL$Q_MAILDEF[DSC$A_POINTER];
IF NOT NULLPARAMETER(7)
THEN BEGIN
    DEFLEN = .DEFDESC[DSC$W_LENGTH];
    DEFADR = .DEFDESC[DSC$A_POINTER];
    END;
$FAB_INIT(FAB=.IFAB,
	FNS=.NAMDESC[DSC$W_LENGTH],
	FNA=.NAMDESC[DSC$A_POINTER],
	DNS=.DEFLEN,
	DNA=.DEFADR,
	FAC=(DEL,PUT,GET,UPD),
	NAM=.INAM,
	CTX=MAIL$_OPENOUT,
	SHR=(DEL,PUT,GET,UPD),
	RFM=VAR,
	ORG=IDX,
	MRS=MFR_C_MAXLEN,
	XAB=SND_XABPRO);

IFAB[FAB$V_DFW] = .MAIL$B_DFW;
IFAB[FAB$V_CIF] = .FLAGS[MCR_V_CIF];
IF .FLAGS[MCR_V_NIL]
    THEN IFAB[FAB$B_SHR] = FAB$M_NIL;
IF .FLAGS[MCR_V_EXEC]
    THEN IFAB[FAB$V_LNM_MODE] = PSL$C_EXEC;

$XABPRO_INIT(XAB=SND_XABPRO,
	NXT=XABALL0);
SND_XABPRO[XAB$L_UIC]=.UIC;			! Use owner's UIC
SND_XABPRO[XAB$W_PRO]=SND_PRO;			! Set file protection

$XABALL_INIT(XAB=XABALL0,
		AID=0,
		AOP=CBT,
		BKZ=5,
		DEQ=15,
		NXT=XABALL1);

$XABALL_INIT(XAB=XABALL1,
		AID=1,
		AOP=CBT,
		BKZ=5,
		DEQ=5,
		NXT=XABALL2);

$XABALL_INIT(XAB=XABALL2,
		AID=2,
		AOP=CBT,
		BKZ=3,
		DEQ=3,
		NXT=XABKEY0);

$XABKEY_INIT(XAB=XABKEY0,
		KREF=0,
		FLG=DUP,
		DTP=BN8,
		POS=0,
		SIZ=8,
		DAN=0,
		IAN=1,
		LAN=1,
		NXT=XABKEY1);

$XABKEY_INIT(XAB=XABKEY1,
		KREF=1,
		FLG=(DUP,CHG,NUL),
		DTP=STG,
		POS0=$BYTEOFFSET(MFR_T_FILEKEY),
		SIZ0=MFR_S_FILEKEY,
		NUL=0,
		DAN=2,
		IAN=2,
		LAN=2,
		NXT=0);

STATUS = $CREATE(FAB=.IFAB);
IF.STATUS
    AND .UIC NEQ 0
    AND .SND_XABPRO[XAB$L_UIC] NEQ .UIC
THEN BEGIN
    $CLOSE(FAB=.IFAB);
    STATUS = RMS$_PRV;
    IFAB[FAB$L_STS] = RMS$_PRV;
    IFAB[FAB$L_STV] = SS$_NOPRIV;
    END;
SND_XABPRO[XAB$L_NXT] = 0;			!Disconnect other XAB's
IF NOT .STATUS
THEN BEGIN
    IF .STATUS EQL RMS$_FLK
    THEN IF FIND_FILE_TYPE(.IFAB)
	THEN IF .IFAB[FAB$B_ORG] EQL FAB$C_SEQ
	    THEN STATUS = RMS$_SHR;		!If sequential, return RMS$_SHR
    RETURN .STATUS
    END;

IF NOT .IFAB[$FAB_DEV(DIR)]
    OR .IFAB[$FAB_DEV(FOR)]
THEN BEGIN
    $CLOSE(FAB=.IFAB);
    STATUS = SS$_IVDEVNAM;
    IFAB[FAB$L_STS] = SS$_IVDEVNAM;
    IFAB[FAB$L_STV] = 0;
    RETURN .STATUS
    END;

$RAB_INIT(RAB=.IRAB,
	FAB=.IFAB,
	RAC=KEY);

IF_ERR($CONNECT(RAB=.IRAB);,
	IFAB[FAB$L_STS] = .IRAB[RAB$L_STS];
	IFAB[FAB$L_STV] = .IRAB[RAB$L_STV];
	RETURN .STATUS);
RETURN TRUE
END;

GLOBAL ROUTINE MAIL$UPDATE_I_MSG =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Update the header record of the current message
!
! INPUTS:
!
!	MAIL$L_CURMSG points at current msg
!--
BEGIN

BIND
    MMH = MAIL$L_CURMSG[MMB_T_HDREC] + $BYTEOFFSET(MFR_T_DATA) : $BBLOCK;

MAIL$T_RD_RAB[RAB$L_RFA0] = .MAIL$L_CURMSG[MMB_L_RFA0];
MAIL$T_RD_RAB[RAB$W_RFA4] = .MAIL$L_CURMSG[MMB_W_RFA4];
MAIL$T_RD_RAB[RAB$B_RAC] = RAB$C_RFA;
MAIL$T_RD_RAB[RAB$L_RBF] = MAIL$L_CURMSG[MMB_T_HDREC];
MAIL$T_RD_RAB[RAB$W_RSZ] = .MAIL$L_CURMSG[MMB_W_HDRECLEN];
MAIL$T_RD_RAB[RAB$L_ROP] = 0;
MAIL$T_RD_RAB[RAB$L_CTX] = MAIL$_WRITEERR;
IF_ERR($FIND(RAB=MAIL$T_RD_RAB,ERR=UTIL$REPORT_IO_ERROR);,
	RETURN .STATUS);

IF_ERR($UPDATE(RAB=MAIL$T_RD_RAB,ERR=UTIL$REPORT_IO_ERROR);,
	RETURN .STATUS);

!
! Update flags in module header
!
MAIL$L_CURMSG[MMB_V_NEWMSG] = .MMH[MMH_V_NEWMSG];
MAIL$L_CURMSG[MMB_V_REPLIED] = .MMH[MMH_V_REPLIED];
RETURN TRUE
END;

GLOBAL ROUTINE MAIL$READ_INFO_REC(MAILRAB,INDEX,LOCKFLAG,RECDESC,RECRFA) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Read the specified info record
!
! INPUTS:
!
!	MAILRAB = address of rab connected
!	INDEX = info record index
!	LOCKFLAG = 1 to lock record, 0 to not
!	RECDESC = addr of 2-lw vector to return record descriptor in
!	RECRFA = (optional) addr of 2-lw vector to return RFA of record
!
!--
BEGIN

MAP
    MAILRAB : REF $BBLOCK,
    RECDESC : REF VECTOR[,LONG],
    RECRFA : REF VECTOR[,LONG];

BUILTIN
    NULLPARAMETER;

LOCAL
    STATUS,
    COUNTER,
    KEYBUFFER : VECTOR[8,BYTE];

LITERAL
	RETRY_RLK = 10,			! number of retries for a locked record
	SLEEP_RLK = 75;			! ms to sleep before retrying

BIND
    !
    ! Define the delta time to sleep before retrying to GET a locked record.
    !
    WAKEDELTA = UPLIT LONG(-10*1000*SLEEP_RLK,-1),
    LWBUF = KEYBUFFER : VECTOR[,LONG];

IF NOT NULLPARAMETER(5)
THEN BEGIN
    RECRFA[0] = 0;
    RECRFA[1] = 0;
    END;

LWBUF[0] = .INDEX;
LWBUF[1] = 0;

MAILRAB[RAB$L_ROP] = RAB$M_LOC;
MAILRAB[RAB$B_KRF] = 0;
MAILRAB[RAB$B_KSZ] = 8;
MAILRAB[RAB$B_RAC] = RAB$C_KEY;
MAILRAB[RAB$L_KBF] = KEYBUFFER;
IF NOT .LOCKFLAG
    THEN MAILRAB[RAB$V_NLK] = TRUE;

IF .LOCKFLAG
THEN BEGIN
    COUNTER = RETRY_RLK; 
    WHILE ((STATUS = $GET(RAB=.MAILRAB)) EQL RMS$_RLK)
			AND ((COUNTER = .COUNTER - 1) GEQ 0)
	DO IF $SCHDWK(DAYTIM = WAKEDELTA) THEN $HIBER;
    IF NOT .STATUS
	THEN RETURN .STATUS;
    END
ELSE IF NOT (STATUS = $GET(RAB=.MAILRAB))
    THEN RETURN .STATUS;

RECDESC[0] = .MAILRAB[RAB$W_RSZ];
RECDESC[1] = .MAILRAB[RAB$L_RBF];

IF NOT NULLPARAMETER(5)
THEN BEGIN
    RECRFA[0] = .MAILRAB[RAB$L_RFA0];
    RECRFA[1] = .MAILRAB[RAB$W_RFA4];
    END;
RETURN TRUE
END;

GLOBAL ROUTINE MAIL$UPDATE_INFO_REC(MAILRAB,RECDESC,RECRFA) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Update an info record (or write it if non-existant)
!
! INPUTS:
!
!	MAILRAB is addr of RAB
!	RECDESC is addr of descriptor of record
!	RECRFA (optional) is addr of 2-lw containing RFA of record
!--
BEGIN

MAP
    MAILRAB : REF $BBLOCK,
    RECDESC : REF $BBLOCK,
    RECRFA : REF VECTOR[,LONG];

BUILTIN
    NULLPARAMETER;

LOCAL
    STATUS;

BIND
    RECORD_INDEX = .RECDESC[DSC$A_POINTER] : LONG,
    INDEX_DATIM = .RECDESC[DSC$A_POINTER] : VECTOR[,BYTE];

MAILRAB[RAB$L_ROP] = 0;
MAILRAB[RAB$W_RSZ] = .RECDESC[DSC$W_LENGTH];
MAILRAB[RAB$L_RBF] = .RECDESC[DSC$A_POINTER];
MAILRAB[RAB$L_CTX] = MAIL$_WRITEERR;
MAILRAB[RAB$L_KBF] = INDEX_DATIM;
MAILRAB[RAB$B_KSZ] = 8;
MAILRAB[RAB$B_KRF] = 0;

MAILRAB[RAB$L_RFA0] = 0;

IF NOT NULLPARAMETER(3)
    AND .RECRFA[0] NEQ 0
THEN BEGIN
    MAILRAB[RAB$L_RFA0] = .RECRFA[0];
    MAILRAB[RAB$W_RFA4] = .RECRFA[1];
    END;

IF .MAILRAB[RAB$L_RFA0] NEQ 0
THEN BEGIN
    MAILRAB[RAB$B_RAC] = RAB$C_RFA;
    IF_ERR($FIND(RAB=.MAILRAB,ERR=UTIL$REPORT_IO_ERROR);,
		RETURN .STATUS);
    IF_ERR($UPDATE(RAB=.MAILRAB,ERR=UTIL$REPORT_IO_ERROR);,
		RETURN .STATUS);
    END
ELSE BEGIN
    MAILRAB[RAB$B_RAC] = RAB$C_KEY;
    STATUS = $FIND(RAB=.MAILRAB);
    IF .STATUS
    THEN BEGIN
	MAILRAB[RAB$B_RAC] = RAB$C_RFA;
	IF_ERR($UPDATE(RAB=.MAILRAB,ERR=UTIL$REPORT_IO_ERROR);,
		RETURN .STATUS);
    END
    ELSE IF_ERR($PUT(RAB=.MAILRAB,ERR=UTIL$REPORT_IO_ERROR);,
		RETURN .STATUS);
    END;

RETURN TRUE
END;

ROUTINE RECLAIM_HANDLER (SIGARG,MECHARG) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Handler enabled when CONV$RECLAIM is called.
!
!--
BEGIN

ROUTINE PUT_OUT (DESC) = (LIB$PUT_OUTPUT(.DESC); RETURN 0);

MAP
    SIGARG : REF $BBLOCK,
    MECHARG : REF $BBLOCK;

BIND
    SIGNAME = SIGARG[CHF$L_SIG_NAME] : $BBLOCK;

IF .SIGARG[CHF$L_SIG_NAME] EQL SS$_UNWIND
    THEN RETURN SS$_CONTINUE;

IF .SIGARG[CHF$L_SIG_NAME] EQL SS$_ACCVIO
    THEN RETURN SS$_RESIGNAL;

SIGNAME[STS$V_FAC_NO] = MAIL$_FACILITY;
IF .SIGNAME[STS$V_SEVERITY] EQL STS$K_SEVERE
    THEN SIGNAME[STS$V_SEVERITY] = STS$K_ERROR;

SIGARG[CHF$L_SIG_ARGS] = .SIGARG[CHF$L_SIG_ARGS] - 2; !Don't count pc/psl
$PUTMSG(MSGVEC=SIGARG[CHF$L_SIG_ARGS],
		ACTRTN=PUT_OUT);
SIGARG[CHF$L_SIG_ARGS] = .SIGARG[CHF$L_SIG_ARGS] + 2;

SETUNWIND();
RETURN 0
END;

ROUTINE CALL_RECLAIM (STAT_FLAG) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Call CONV$RECLAIM.  If errors, will unwind to caller of this
!	routine.
!--
BEGIN

OWN
    RECLAIM_ROUTINE;

LOCAL
    STATUS,
    STATVEC : VECTOR[5,LONG];

BUILTIN
    FP;

CH$FILL(0,5*4,STATVEC);
STATVEC[0] = 4;
IF .RECLAIM_ROUTINE EQL 0
THEN IF_ERR(LIB$FIND_IMAGE_SYMBOL(SD_CONVSHR,$DESCRIPTOR('CONV$RECLAIM'),
				RECLAIM_ROUTINE);,
	RETURN .STATUS);

.FP = RECLAIM_HANDLER;
STATUS = (.RECLAIM_ROUTINE)(MAIL$Q_RD_DESC,STATVEC,%REF(1));
IF .STATUS
    AND .STAT_FLAG
	THEN SIGNAL(MAIL$_RECLSTAT,%X'10004',
		.STATVEC[1],.STATVEC[2],.STATVEC[3],.STATVEC[4]);
.FP = 0;
RETURN .STATUS

END;

GLOBAL ROUTINE MAIL$RECLAIM(STAT_FLAG) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Close the current ISAM file, call CONV$RECLAIM, and then re-open
!	the file
!
! INPUTS:
!
!	STAT_FLAG = 1 to print stats, 0 to not
!
!--
BEGIN

LOCAL
    RECDESC : VECTOR[2,LONG],
    RECPTR : REF $BBLOCK,
    RECRFA : VECTOR[2,LONG],
    STATUS;

MAIL$DISABLE_CTRLY();
$CLOSE(FAB=.MAIL$T_RD_RAB[RAB$L_FAB]);
MAIL$GL_FLAGS[MAIF_V_FILOPN] = 0;

STATUS = CALL_RECLAIM(.STAT_FLAG);
MAIL$OPEN_FILE(MAIL$Q_RD_DESC);
!
! Zero the count of deleted messages in the fileinfo record
!
IF .STATUS
THEN IF MAIL$READ_INFO_REC(MAIL$T_RD_RAB,MFR_C_FILEINFO,1,RECDESC,RECRFA)
THEN BEGIN
    RECPTR = .RECDESC[1];
    (RECPTR[MFR_T_DATA])<0,32,0> = 0;
    MAIL$L_DELMSGCNT = 0;
    MAIL$UPDATE_INFO_REC(MAIL$T_RD_RAB,RECDESC,RECRFA);
    END;

MAIL$ENABLE_CTRLY();
RETURN TRUE
END;

ROUTINE CALL_CONV_COMPRESS(FLAGS,INDESC,TMPDESC) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Call convert to copy the input file to SYS$LOGIN:CONVRTMAI.TMP
!	This file will then be renamed
!
! Inputs:
!
!	INDESC = Address of descriptor of input file
!	TMPDESC = address of descriptor of temporary output file
!--
BEGIN
MAP
    FLAGS : BITVECTOR;

OWN
    CONV_PASS_FILES,
    CONV_PASS_OPTIONS,
    CONV_CONVERT;

LOCAL
    STATUS,
    OPTION_ARRAY : VECTOR[7,LONG],
    STATVEC : VECTOR[5,LONG];

BUILTIN
    FP;

CH$FILL(0,5*4,STATVEC);
STATVEC[0] = 4;
CH$FILL(0,7*4,OPTION_ARRAY);
!
! If this is first time, then get addresses of CONVERT routines.
!
IF .CONV_PASS_FILES EQL 0
THEN BEGIN
    IF_ERR(LIB$FIND_IMAGE_SYMBOL(SD_CONVSHR,$DESCRIPTOR('CONV$PASS_FILES'),
				CONV_PASS_FILES);,
	RETURN .STATUS);
    IF_ERR(LIB$FIND_IMAGE_SYMBOL(SD_CONVSHR,$DESCRIPTOR('CONV$PASS_OPTIONS'),
				CONV_PASS_OPTIONS);,
	RETURN .STATUS);
    IF_ERR(LIB$FIND_IMAGE_SYMBOL(SD_CONVSHR,$DESCRIPTOR('CONV$CONVERT'),
				CONV_CONVERT);,
	RETURN .STATUS);
    END;

.FP = RECLAIM_HANDLER;
IF NOT (STATUS = (.CONV_PASS_FILES)(.INDESC,.TMPDESC,SD_NL,SD_NL,%REF(1)))
    THEN RETURN .STATUS;
OPTION_ARRAY[0] = 6;		!# of options
OPTION_ARRAY[3] = 1;		!Fast load
OPTION_ARRAY[6] = 0;		!No sort
IF NOT (STATUS = (.CONV_PASS_OPTIONS)(OPTION_ARRAY,%REF(1)))
    THEN RETURN .STATUS;
STATUS = (.CONV_CONVERT)(STATVEC,%REF(1));
.FP = 0;
IF .STATUS
    THEN SIGNAL(MAIL$_COPIEDR,3,.INDESC,.TMPDESC,.STATVEC[2]);
RETURN .STATUS

END;

GLOBAL ROUTINE MAIL$COMPRESS(FLAGS,OUTFILE,FDLFILE) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Compress the currently open file by use of CONVERT
!
! Inputs:
!
!	Flags = flags.  None currently defined
!	outfile = address of descriptor of output file.  If not specified
!		output file will be same as input file.
!	fdlfile = address of descriptor for fdl file.  If not specified,
!		MAIL's default fdl description will be used. (NYI)
!
!--
BEGIN
MAP
    FLAGS : BITVECTOR,
    OUTFILE : REF $BBLOCK,
    FDLFILE : REF $BBLOCK;

LOCAL
    STATUS,
    FILENAMEBUF : $BBLOCK[NAM$C_MAXRSS],
    FILENAMEDESC : VECTOR[2,LONG],
    DESC : VECTOR[2,LONG],
    OPEN_DESC : VECTOR[2,LONG],
    NAMRSS : $BBLOCK[NAM$C_MAXRSS],
    NAMESS : $BBLOCK[NAM$C_MAXRSS],
    OPENRSS : $BBLOCK[NAM$C_MAXRSS],
    OPENESS : $BBLOCK[NAM$C_MAXRSS],
    PROTBUF : $BBLOCK[NAM$C_MAXRSS],
    OPEN_FAB : $FAB_DECL,
    OPEN_NAM : $NAM_DECL,
    NEW_NAME : DYN_DESC_DECL,
    PROTFAB : $FAB_DECL,
    PROTXAB : $XABPRO_DECL,
    PROTNAM : $NAM_DECL,
    TFAB : $FAB_DECL,
    TRAB : $RAB_DECL,
    TNAM : $NAM_DECL;


STR$COPY_DX(DYN_DESC,MAIL$Q_RD_DESC);
MAIL$CLOSE_FILE();
FILENAMEDESC[0] = NAM$C_MAXRSS;
FILENAMEDESC[1] = FILENAMEBUF;
SYS$FAO($DESCRIPTOR('MAIL_!4XL_COMPRESS.TMP'),FILENAMEDESC,
		FILENAMEDESC,.MAIL$L_MYPID);
!
! Always create using MAIL's internal description.  /fdl not implemented.
!
!IF .FDLFILE[DSC$W_LENGTH] EQL 0
!THEN BEGIN
    $NAM_INIT(NAM=TNAM,
	RSS=NAM$C_MAXRSS,
	RSA=NAMRSS,
	ESS=NAM$C_MAXRSS,
	ESA=NAMESS);
    !
    ! Use input file as default to get created in same device/dir
    STATUS = MAIL$CREATE_ISAM(TFAB,TRAB,TNAM,
				FILENAMEDESC,0,MCR_M_NIL,
				(IF .OUTFILE[DSC$W_LENGTH] EQL 0
					THEN DYN_DESC
					ELSE .OUTFILE));
    IF NOT .STATUS
    THEN BEGIN
	UTIL$REPORT_IO_ERROR((IF NOT .TFAB[FAB$L_STS]
					THEN TFAB
					ELSE TRAB));
	TFAB[FAB$V_DLT] = 1;		!Delete if we created it
	$CLOSE(FAB=TFAB);
	RETURN .STATUS
	END;
    $CLOSE(FAB=TFAB);
!    END;
CH$MOVE(8,UTIL$GETFILENAME(TFAB),FILENAMEDESC);
CH$MOVE(.FILENAMEDESC[0],.FILENAMEDESC[1],FILENAMEBUF);
FILENAMEDESC[1] = FILENAMEBUF;
SIGNAL(MAIL$_CREATED,1,FILENAMEDESC);
STATUS = CALL_CONV_COMPRESS(.FLAGS,DYN_DESC,FILENAMEDESC);
IF NOT .STATUS
    THEN RETURN .STATUS;
!
! Now rename the input file to .OLD, and the temp file to the input file
!
NEW_NAME[DSC$B_DTYPE] = DSC$K_DTYPE_T;
NEW_NAME[DSC$B_CLASS] = DSC$K_CLASS_D;
IF .OUTFILE[DSC$W_LENGTH] EQL 0
    THEN IF_ERR(LIB$RENAME_FILE(DYN_DESC,$DESCRIPTOR('.OLD'),0,0,0,
			MAIL$RENAME_SUCCESS,MAIL$RENAME_ERROR,
			0,0,0,NEW_NAME);,
	RETURN .STATUS);
!
! Set the protection of the .OLD file so the the owner can delete it
!
$FAB_INIT(FAB=PROTFAB,
	FNS=.NEW_NAME[DSC$W_LENGTH],
	FNA=.NEW_NAME[DSC$A_POINTER],
	FAC=(GET,PUT),
	CTX=MAIL$_FILNOTDEL,
	NAM=PROTNAM,
	XAB=PROTXAB);

$NAM_INIT(NAM=PROTNAM,
	ESS=NAM$C_MAXRSS,
	ESA=PROTBUF,
	RSS=NAM$C_MAXRSS,
	RSA=PROTBUF);

$XABPRO_INIT(XAB=PROTXAB,
	NXT=0);

$OPEN(FAB=PROTFAB);
PROTXAB[XAB$W_PRO] = DELETE_PRO;
$CLOSE(FAB=PROTFAB);

!
! Do a parse to ensure that the output file has the correct file type
!
DESC[0] = .DYN_DESC[DSC$W_LENGTH];
DESC[1] = .DYN_DESC[DSC$A_POINTER];
IF .OUTFILE[DSC$W_LENGTH] NEQ 0
THEN BEGIN
    DESC[0] = .OUTFILE[DSC$W_LENGTH];
    DESC[1] = .OUTFILE[DSC$A_POINTER];
    END;
$FAB_INIT(FAB=TFAB,
	FNS=.DESC[0],
	FNA=.DESC[1],
	NAM=TNAM,
	DNS=4,
	DNA=UPLIT('.MAI'));
$NAM_INIT(NAM=TNAM,
	RSS=NAM$C_MAXRSS,
	RSA=NAMRSS,
	ESS=NAM$C_MAXRSS,
	ESA=NAMESS);
$PARSE(FAB=TFAB);
$SEARCH(FAB=TFAB);
CH$MOVE(8,UTIL$GETFILENAME(TFAB),DESC);
DESC[0] = .DESC[0] - .TNAM[NAM$B_VER];	!No specific version
IF_ERR(LIB$RENAME_FILE(FILENAMEDESC,DESC,0,0,0,
			MAIL$RENAME_SUCCESS,MAIL$RENAME_ERROR,0,DYN_DESC);,
	RETURN .STATUS);
!
! Open the newly created file
!
$FAB_INIT(FAB=OPEN_FAB,
	FNS=.DYN_DESC[DSC$W_LENGTH],
	FNA=.DYN_DESC[DSC$A_POINTER],
	NAM=OPEN_NAM,
	DNS=4,
	DNA=UPLIT('.MAI'));
$NAM_INIT(NAM=OPEN_NAM,
	RSS=NAM$C_MAXRSS,
	RSA=OPENRSS,
	ESS=NAM$C_MAXRSS,
	ESA=OPENESS);
$PARSE(FAB=OPEN_FAB);
$SEARCH(FAB=OPEN_FAB);
OPEN_DESC[0] = .DYN_DESC[DSC$W_LENGTH] - .OPEN_NAM[NAM$B_VER]; ! Strip version
OPEN_DESC[1] = .DYN_DESC[DSC$A_POINTER];
MAIL$OPEN_FILE(OPEN_DESC);

RETURN TRUE
END;

ROUTINE DECODE_MISCDATA(MSGDESC) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Decode the miscellaneous data and fill in fields in MMB
!
! INPUTS:
!
!	MSGDESC is addr of MMB for msg
!--
BEGIN

MAP
    MSGDESC : REF $BBLOCK;

BIND
    HDREC = MSGDESC[MMB_T_HDREC] : $BBLOCK,
    MMH = HDREC[MFR_T_DATA] : $BBLOCK;

LOCAL
    RECEND,
    PTR : REF VECTOR[,WORD];

CH$FILL(0,4*DSC$C_S_BLN,MSGDESC[MMB_Q_FROMDESC]);	!Zero all descriptors
MSGDESC[MMB_L_NRECS] = 0;
PTR = MMH[MMH_T_MISCDAT];

RECEND = HDREC + .MSGDESC[MMB_W_HDRECLEN];
WHILE .PTR LSSU .RECEND
DO BEGIN
    CASE .PTR[0] FROM MMH_C_FROM TO MMH_C_NREC
    OF SET
    [MMH_C_FROM] :
		BEGIN
		    (MSGDESC[MMB_Q_FROMDESC]) = .PTR[1];
		    MSGDESC[MMB_Q_FROMDESC]+4 = PTR[2];
		    END;
    [MMH_C_TO] :
		BEGIN
		    (MSGDESC[MMB_Q_TODESC]) = .PTR[1];
		    MSGDESC[MMB_Q_TODESC]+4 = PTR[2];
		    END;
    [MMH_C_SUBJ] :
		BEGIN
		    (MSGDESC[MMB_Q_SUBJDESC]) = .PTR[1];
		    MSGDESC[MMB_Q_SUBJDESC]+4 = PTR[2];
		    END;
    [MMH_C_NREC] :
		BEGIN
		    BIND
			NREC = PTR[2] : LONG;

		    MSGDESC[MMB_L_NRECS] = .NREC;
		    END;
    [INRANGE,
	OUTRANGE] :
		1;
    TES;
    PTR = PTR[2] + .PTR[1];			!Skip this entry
    END;

RETURN TRUE
END;


GLOBAL ROUTINE MAIL$DESELECT_MSGS =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Deallocate all msgs in msg table
!--
BEGIN

IF .MAIL$L_NMSG GTRU 0
THEN INCRU I FROM 0 TO .MAIL$L_NMSG-1
DO BEGIN
    MAIL$L_CURMSG = .MAIL$L_MSGTBL[.I];
    IF .MAIL$L_CURMSG NEQ 0
	THEN DEALLOC_MSG();
    END;

STR$FREE1_DX(MAIL$Q_CURFOLDER);
MAIL$L_NMSG = 0;
MAIL$L_MSG_NUM = 0;
MAIL$L_CURMSG = 0;
MAIL$L_MSG_STS = MAIL$_NOTREADIN;

RETURN TRUE
END;

GLOBAL ROUTINE MAIL$REWIND_I_MSG =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Rewind the current message in preparation for reading the text of it
!
! INPUTS:
!
!	MAIL$L_CURMSG points to current msg descriptor
!--
BEGIN

IF .MAIL$L_CURMSG EQL 0
    THEN RETURN MAIL$_NOTREADIN;

IF .MAIL$L_CURMSG[MMB_L_TXTLST] EQL 0
THEN BEGIN
    READ_SAVE_MSG();
    MAIL$L_CURMSG[MMB_L_NBLKS] = (.MAIL$L_CURMSG[MMB_L_NBLKS]+511)/512;
    END;

MSGTRAN = MMB_C_FROM;
MAIL$L_MSG_STS = TRUE;
RETURN TRUE
END;

GLOBAL ROUTINE MAIL$GET_I_MSG(OUTDESC,MORE_FLAG) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Get next unpacked text record of message
!
! OUTPUTS:
!
!	OUTDESC is the address of a two-longword vector filled in with
!	a descriptor of the text.  String must be copied if it is needed
!	later.
!
!	MORE_FLAG = true if more text, else false
!--
BEGIN
MAP
    OUTDESC : REF VECTOR[,LONG];

OWN
    CURTXT : REF $BBLOCK,
    TXTPTR : REF VECTOR[,WORD],
    TXTENDPTR,
    DESC : $BBLOCK[DSC$C_S_BLN]
		PRESET ([DSC$B_DTYPE] = DSC$K_DTYPE_T,
			[DSC$B_CLASS] = DSC$K_CLASS_D);

IF NOT .MAIL$GL_FLAGS[MAIF_V_ISAM]
THEN BEGIN
    IF .MAIL$L_MSG_STS EQL 0		!If already at eof, return it
    THEN RETURN RMS$_EOF
    ELSE BEGIN
	OUTDESC[0] = .MAIL$W_MSG_RSIZ;
	OUTDESC[1] = .MAIL$L_MSG_RADR;
	MAIL$GET_MSG();			!Get next record
	RETURN TRUE
	END;
    END;
.MORE_FLAG = 1;				!Assume more text
MAIL$L_MSG_STS = 1;
CASE .MSGTRAN FROM MMB_C_NONE TO MMB_C_FROMXDT
OF SET
 [MMB_C_NONE] :
    BEGIN
	IF .TXTPTR GEQU .TXTENDPTR
	THEN BEGIN
	    IF .CURTXT EQL 0
		OR (CURTXT = .CURTXT[TXT_L_NEXT]) EQL 0
	    THEN BEGIN
		OUTDESC[0] = 0;
		.MORE_FLAG = 0;
		MAIL$L_MSG_STS = 0;
		RETURN FALSE;
		END
	    ELSE BEGIN
		TXTPTR = CURTXT[TXT_T_TEXT];
		TXTENDPTR = .TXTPTR + .CURTXT[TXT_L_TEXTLEN];
		END;
	    END;
	IF .MAIL$L_CURMSG[MMB_V_EXTNSTD]
	THEN BEGIN
	    OUTDESC[0] = .CURTXT[TXT_L_TEXTLEN];
	    OUTDESC[1] = TXTPTR[0];
	    TXTPTR = .OUTDESC[0] + .OUTDESC[1];
	    END
	ELSE BEGIN
	    OUTDESC[0] = .TXTPTR[0];
	    OUTDESC[1] = TXTPTR[1];
	    TXTPTR = TXTPTR[1] + .TXTPTR[0];
	    IF .MAIL$L_CURMSG[MMB_V_EXTMSG]
		THEN TXTPTR = (.TXTPTR + 1) AND NOT 1;
	    END;
!
! If current record strays out of message buffer boundry
! or if the record is too big we must abort the message
!
	IF (.OUTDESC[1] + .OUTDESC[0] GTRU .TXTENDPTR) OR 
				(.OUTDESC[0] GTRU 2048) THEN
	BEGIN
		.MORE_FLAG = 0;
		MAIL$L_MSG_STS = 0;
		SIGNAL(MAIL$_RECTOBIG,1,.OUTDESC[0]);
		RETURN FALSE;
	END;
	IF .OUTDESC[0] GEQU 2
	    AND (.(.OUTDESC[1]+.OUTDESC[0]-2)<0,16>
						EQLU (CR OR LF^8))
	    THEN OUTDESC[0] = .OUTDESC[0] - 2;
	IF .TXTPTR GEQU .TXTENDPTR
	    AND .CURTXT[TXT_L_NEXT] EQL 0
	    THEN .MORE_FLAG = 0;
	END;

 [MMB_C_FROM,
  MMB_C_FROMXDT] :
    BEGIN
	BIND
	    MSGREC = MAIL$L_CURMSG[MMB_T_HDREC] : $BBLOCK;

	IF .MSGTRAN EQL MMB_C_FROM
	THEN BEGIN
	    DATEDESC[0] = 18;
	    DATEDESC[1] = DATEBUF;
	    $FAO($DESCRIPTOR(' !18%D'),DATEDESC,DATEDESC,MSGREC[MFR_Q_DATIM]);
	    END
	ELSE BEGIN
	    DATEDESC[0] = 0;
	    DATEDESC[1] = DATEBUF;
	    END;
	STR$CONCAT(DESC,MAIL$GETMSG(MAIL$_ISUB10),
			MAIL$L_CURMSG[MMB_Q_FROMDESC],DATEDESC);
	MSGTRAN = MMB_C_TO;
	OUTDESC[0] = .DESC[DSC$W_LENGTH];
	OUTDESC[1] = .DESC[DSC$A_POINTER];
	END;
 [MMB_C_TO] :
    BEGIN
	MSGTRAN = MMB_C_SUBJ;
	STR$CONCAT(DESC,MAIL$GETMSG(MAIL$_ISUB20),
			MAIL$L_CURMSG[MMB_Q_TODESC]);
	OUTDESC[0] = .DESC[DSC$W_LENGTH];
	OUTDESC[1] = .DESC[DSC$A_POINTER];
	END;

 [MMB_C_SUBJ] :
    BEGIN
	MSGTRAN = MMB_C_BLANK;
	STR$CONCAT(DESC,MAIL$GETMSG(MAIL$_ISUB30),
			MAIL$L_CURMSG[MMB_Q_SUBJDESC]);
	OUTDESC[0] = .DESC[DSC$W_LENGTH];
	OUTDESC[1] = .DESC[DSC$A_POINTER];
	END;

 [MMB_C_BLANK] :
    BEGIN
	MSGTRAN = MMB_C_TEXT;
	OUTDESC[0] = 0;
	OUTDESC[1] = .DESC[DSC$A_POINTER];
	END;

 [MMB_C_TEXT] :
    BEGIN
	CURTXT = .MAIL$L_CURMSG[MMB_L_TXTLST];
!
! Compute the message text boundry
!
	IF .CURTXT NEQ 0
	THEN BEGIN
	    TXTPTR = CURTXT[TXT_T_TEXT];
	    TXTENDPTR = .TXTPTR + .CURTXT[TXT_L_TEXTLEN];
	    END
	ELSE (TXTPTR = 1;TXTENDPTR = 0);
	MSGTRAN = MMB_C_NONE;
	RETURN MAIL$GET_I_MSG(.OUTDESC,.MORE_FLAG);
	END;
 TES;

RETURN TRUE

END;

GLOBAL ROUTINE MAIL$FIND_I_MSG(MSGNUM,NEXT_FLAG,DELMSG_FLAG) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Find the specified message. If MSGNUM is 0, the next message is found
!	If NEXT_FLAG = 1 and specified msg is deleted, then find next undeleted
!	message.  If NEXT_FLAG = -1 and specified msg is deleted, then find
!	previous undeleted msg
!
!--
BEGIN

BUILTIN
    NULLPARAMETER;

LOCAL
    DELF,
    NEXTF,
    SRCH_MSGNUM;

NEXTF = (IF NULLPARAMETER(2)
	    THEN 1
	    ELSE .NEXT_FLAG);
DELF = (IF NULLPARAMETER(3)
	    THEN 0
	    ELSE .DELMSG_FLAG);
SRCH_MSGNUM = (IF .MSGNUM EQL 0 
		THEN  .MAIL$L_MSG_NUM + 1
		ELSE MINU(.MSGNUM,.MAIL$L_NMSG));

IF .SRCH_MSGNUM GTRU .MAIL$L_NMSG
    OR .SRCH_MSGNUM EQL 0
THEN BEGIN
    MAIL$L_CURMSG = 0;
    IF .MAIL$L_NMSG EQL 0
	THEN RETURN (MAIL$L_MSG_STS = MAIL$_NOMSGS)
	ELSE (MAIL$L_MSG_NUM = .MAIL$L_NMSG+1;
		RETURN (MAIL$L_MSG_STS = MAIL$_NOMOREMSG));
    END;

MAIL$L_CURMSG = .MAIL$L_MSGTBL[.SRCH_MSGNUM-1];

!
! Special case LAST or 9999 when last message is deleted
!
IF .MSGNUM GEQU .MAIL$L_NMSG
    AND .MAIL$L_CURMSG EQL 0
    AND .NEXTF GTRU 0
    THEN NEXTF = -1;

IF .MAIL$L_CURMSG EQL 0
    AND NOT .DELF
THEN BEGIN
    IF .MSGNUM NEQ 0
	AND NOT .NEXTF
	THEN RETURN (MAIL$L_MSG_STS = MAIL$_DELMSG);
    IF .NEXTF GTR 0
    THEN BEGIN
	INCRU I FROM .SRCH_MSGNUM+1 TO .MAIL$L_NMSG
	DO BEGIN
	    MAIL$L_MSG_NUM = .I;
	    IF .MAIL$L_MSGTBL[.I-1] NEQ 0
	    THEN BEGIN
		MAIL$L_CURMSG = .MAIL$L_MSGTBL[.I-1];
		RETURN (MAIL$L_MSG_STS = TRUE)
		END;
	    END;
	END
    ELSE IF .NEXTF LSS 0
    THEN BEGIN
	DECRU I FROM .SRCH_MSGNUM-1 TO 1
	DO BEGIN
	    MAIL$L_MSG_NUM = .I;
	    IF .MAIL$L_MSGTBL[.I-1] NEQ 0
	    THEN BEGIN
		MAIL$L_CURMSG = .MAIL$L_MSGTBL[.I-1];
		RETURN (MAIL$L_MSG_STS = TRUE)
		END;
	    END;
    END;
    RETURN (MAIL$L_MSG_STS = MAIL$_NOMOREMSG)
    END;

MAIL$L_MSG_NUM = .SRCH_MSGNUM;
MAIL$L_MSG_STS = TRUE;
RETURN TRUE
END;

GLOBAL ROUTINE MAIL$INFO_I_MSG(SENDER,SUBJ,DATE,FLAGS,
					FULL_SENDER,SENDER_PATH,TO_DESC) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Return info about message for directory listing
!
! OUTPUTS:
!
!	SENDER = sender node-name and username
!	SUBJ = subject string
!	DATE = date-string
!	FLAGS = string of flags present (ascii description)
!	FULL_SENDER = complete sender including personal name
!	SENDER_PATH = complete sender excluding personal name
!	TO_DESC = "to" string
!
!--
BEGIN

BUILTIN
    NULLPARAMETER,
    ACTUALCOUNT;

BIND
    HDREC = MAIL$L_CURMSG[MMB_T_HDREC] : $BBLOCK;

LOCAL
    T_SENDER : VECTOR[2,LONG],
    PTR,
    TRY_SIZE,
    TRY_PTR;

IF .MAIL$L_CURMSG EQL 0
    THEN RETURN MAIL$_NOTREADIN;

IF NOT NULLPARAMETER(1)
THEN BEGIN
    CH$MOVE(DSC$C_S_BLN,MAIL$L_CURMSG[MMB_Q_FROMDESC],T_SENDER);
    !
    ! Trim sender name to only his nodename (if present) and username
    !
    TRY_SIZE = .T_SENDER[0];
    TRY_PTR = .T_SENDER[1];
    WHILE NOT CH$FAIL(PTR = CH$FIND_SUB(.TRY_SIZE,.TRY_PTR,
					%CHARCOUNT('::'),UPLIT('::')))
    DO BEGIN
	T_SENDER[0] = .TRY_SIZE;
	T_SENDER[1] = .TRY_PTR;
	TRY_SIZE = .TRY_SIZE - (.PTR + %CHARCOUNT('::') - .TRY_PTR);
	TRY_PTR = .PTR + %CHARCOUNT('::');
	END;
    IF NOT CH$FAIL(PTR = CH$FIND_CH(.T_SENDER[0],.T_SENDER[1],%ASCII ' '))
	THEN T_SENDER[0] = .PTR - .T_SENDER[1];
    STR$COPY_DX(.SENDER,T_SENDER);
    END;

IF NOT NULLPARAMETER(2)
    THEN STR$COPY_DX(.SUBJ,MAIL$L_CURMSG[MMB_Q_SUBJDESC]);
!
! FORMAT DATE/TIME
!
IF NOT NULLPARAMETER(3)
THEN BEGIN
    DATEDESC[0] = 20;
    DATEDESC[1] = DATEBUF;
    $FAO($DESCRIPTOR('!20%D'),DATEDESC,DATEDESC,HDREC[MFR_Q_DATIM]);
    STR$COPY_DX(.DATE,DATEDESC);
    END;
!
! FORMAT FLAGS
!
IF NOT NULLPARAMETER(4)
THEN BEGIN
    LOCAL
	NEWMSG,
	REPLIED;

    IF (NEWMSG = .MAIL$L_CURMSG[MMB_V_NEWMSG])
	OR (REPLIED = .MAIL$L_CURMSG[MMB_V_REPLIED])
	OR .MAIL$L_CURMSG[MMB_L_NRECS] NEQ 0
	OR .MAIL$L_CURMSG[MMB_V_EXTMSG]
    THEN BEGIN
	STR$COPY_DX(DYN_DESC,$DESCRIPTOR('	'));
	IF .NEWMSG
	    THEN STR$APPEND(DYN_DESC,MAIL$GETMSG(MAIL$_INFO10));
	IF .REPLIED
	    THEN STR$APPEND(DYN_DESC,MAIL$GETMSG(MAIL$_INFO20));
	IF .MAIL$L_CURMSG[MMB_L_NRECS] NEQ 0
	THEN BEGIN
	    IF .NEWMSG OR .REPLIED
		THEN STR$APPEND(DYN_DESC,$DESCRIPTOR(','));
	    STR$APPEND(DYN_DESC,
		MAIL$FAO_GETMSG(MAIL$_INFO30,.MAIL$L_CURMSG[MMB_L_NRECS]));
	    END;
	IF .MAIL$L_CURMSG[MMB_V_EXTMSG]
	THEN BEGIN
	    IF .NEWMSG OR .REPLIED
		OR .MAIL$L_CURMSG[MMB_L_NRECS] GTRU 0
		THEN STR$APPEND(DYN_DESC,$DESCRIPTOR(','));
	    STR$APPEND(DYN_DESC,
		MAIL$FAO_GETMSG(MAIL$_INFO50,
			.(MAIL$L_CURMSG[MMB_Q_DATID])<32,32,0>,
			.(MAIL$L_CURMSG[MMB_Q_DATID])<0,32,0>));
	    END;
	STR$COPY_DX(.FLAGS,DYN_DESC);
	END
    ELSE STR$FREE1_DX(.FLAGS);
    END;
!
! Get full sender name if requested
!
IF NOT NULLPARAMETER(5)
    THEN STR$COPY_DX(.FULL_SENDER,MAIL$L_CURMSG[MMB_Q_FROMDESC]);
!
! Get full sender name without stuff in quotes
!
IF NOT NULLPARAMETER(6)
THEN BEGIN
    LOCAL
	T_CHAR : BYTE,
	QUOTE_FLAG;

    CH$MOVE(DSC$C_S_BLN,MAIL$L_CURMSG[MMB_Q_FROMDESC],T_SENDER);
    QUOTE_FLAG = 0;
    INCRU I FROM 0 TO .T_SENDER[0] - 1
    DO BEGIN
	IF (T_CHAR = CH$RCHAR(.T_SENDER[1]+.I)) EQL %ASCII '"'
	    THEN QUOTE_FLAG = .QUOTE_FLAG XOR 1
	    ELSE IF .T_CHAR EQL %ASCII ' '
		AND NOT .QUOTE_FLAG
	    THEN BEGIN
		T_SENDER[0] = .I;
		EXITLOOP;
		END;
	END;
    STR$COPY_DX(.SENDER_PATH,T_SENDER);
    END;
	
IF NOT NULLPARAMETER(7)
    THEN STR$COPY_DX(.TO_DESC,MAIL$L_CURMSG[MMB_Q_TODESC]);

RETURN TRUE
END;

ROUTINE SELECT_MSGS (FOLDER_DESC,SELECT_DATA,OUT_DESC) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Perform the actual message selection
!
!--
BEGIN
MAP
    FOLDER_DESC : REF $BBLOCK,
    SELECT_DATA : REF VECTOR[,LONG],
    OUT_DESC : REF VECTOR[,LONG];

BIND
    QUAL_FLAGS = SELECT_DATA[0] : $BBLOCK;

LOCAL
    KEYBUFFER : $BBLOCK[MFR_S_FILEKEY],
    RECDESC : VECTOR[2,LONG],
    RECPTR : REF VECTOR[,BYTE],
    MSGDESC : REF $BBLOCK,
    PTR : REF $BBLOCK,
    MMH : REF $BBLOCK,
    DATIM : REF VECTOR[,LONG],
    STATUS;
!
! Read on the folder name.
!
MAIL$T_RD_RAB[RAB$L_ROP] = RAB$M_LIM;	!Read on folder name
MAIL$T_RD_RAB[RAB$B_KRF] = 1;
MAIL$T_RD_RAB[RAB$L_KBF] = KEYBUFFER;
MAIL$T_RD_RAB[RAB$B_KSZ] = MFR_S_FILEKEY;
CH$COPY(.FOLDER_DESC[DSC$W_LENGTH],.FOLDER_DESC[DSC$A_POINTER],0,
			MFR_S_FILEKEY,KEYBUFFER);
MAIL$T_RD_RAB[RAB$B_RAC] = RAB$C_KEY;
MAIL$T_RD_RAB[RAB$V_LOC] = TRUE;
MAIL$T_RD_RAB[RAB$V_NLK] = TRUE;
MAIL$T_RD_RAB[RAB$L_CTX] = MAIL$_READERR;
IF_ERR($FIND(RAB=MAIL$T_RD_RAB);,
	IF .QUAL_FLAGS[QUAL_NEW]
	THEN BEGIN
	    IF .QUAL_FLAGS[QUAL_IMPLIED_NEW]
	    THEN BEGIN
		QUAL_FLAGS[QUAL_NEW] = QUAL_FLAGS[QUAL_IMPLIED_NEW] = FALSE;
		OUT_DESC[0] = MAIL$Q_MSG_FNM;
		RETURN MAIL$SELECT_MSGS(MAIL$Q_MSG_FNM,.SELECT_DATA)
		END;
	    MAIL$INCR_NEWMAIL(MAIL$Q_USERNAME,0);	!Reset new mail count
	    RETURN SIGNAL(MAIL$_NONEWMAIL);
	    END;
	IF .STATUS NEQ RMS$_RNF
	    THEN RETURN UTIL$REPORT_IO_ERROR(MAIL$T_RD_RAB)
	    ELSE RETURN SIGNAL(MAIL$_NOTEXIST,1,.FOLDER_DESC));

MAIL$T_RD_RAB[RAB$B_RAC] = RAB$C_SEQ;
WHILE TRUE
DO BEGIN
    STATUS = $GET(RAB=MAIL$T_RD_RAB);
    IF .STATUS EQL RMS$_OK_LIM
	OR .STATUS EQL RMS$_RNF
	OR .STATUS EQL RMS$_EOF
	OR .MAIL$GL_FLAGS[MAIF_V_CTRLCFL]
	THEN EXITLOOP;
    IF NOT .STATUS
	AND .STATUS NEQ RMS$_RLK
    THEN RETURN UTIL$REPORT_IO_ERROR(MAIL$T_RD_RAB)
    ELSE BEGIN
	PTR = .MAIL$T_RD_RAB[RAB$L_RBF];
	DATIM = PTR[MFR_Q_DATIM];
	MMH = PTR[MFR_T_DATA];
	IF (.DATIM[1] GTRU .SELECT_DATA[4]
	    OR ((.DATIM[1] EQLU .SELECT_DATA[4])
		AND (.DATIM[0] GTRU .SELECT_DATA[3])))
	    AND (.DATIM[1] LSSU .SELECT_DATA[2]
		OR ((.DATIM[1] EQLU .SELECT_DATA[2])
		    AND (.DATIM[0] LSSU .SELECT_DATA[1])))
	    AND (IF .QUAL_FLAGS[QUAL_NEW]
		    THEN .MMH[MMH_V_NEWMSG]
		    ELSE TRUE)
	THEN BEGIN
	    IF_ERR(GET_MEM(MMB_C_LENGTH+.MAIL$T_RD_RAB[RAB$W_RSZ],MSGDESC);,
			RETURN .STATUS);
	    MSGDESC[MMB_L_RFA0] = .MAIL$T_RD_RAB[RAB$L_RFA0];
	    MSGDESC[MMB_W_RFA4] = .MAIL$T_RD_RAB[RAB$W_RFA4];
	    MSGDESC[MMB_L_TXTLST] = 0;
	    MSGDESC[MMB_W_HDRECLEN] = .MAIL$T_RD_RAB[RAB$W_RSZ];
	    CH$MOVE(.MSGDESC[MMB_W_HDRECLEN],
		.MAIL$T_RD_RAB[RAB$L_RBF],MSGDESC[MMB_T_HDREC]);
	    MSGDESC[MMB_W_FLAGS] = .MMH[MMH_W_FLAGS];
	    CH$MOVE(8,MMH[MMH_Q_DATID],MSGDESC[MMB_Q_DATID]);
	    DECODE_MISCDATA(.MSGDESC);
	    IF_ERR(ADD_MESSAGE(.MSGDESC);,
			RETURN .STATUS);
	    END;
	END;
    END;
!
! If selecting new messages and none found, clear user's new msg count
!
IF .MAIL$L_NMSG EQL 0
    AND .QUAL_FLAGS[QUAL_NEW]
THEN BEGIN
    IF .QUAL_FLAGS[QUAL_IMPLIED_NEW]
    THEN BEGIN
	QUAL_FLAGS[QUAL_NEW] = QUAL_FLAGS[QUAL_IMPLIED_NEW] = FALSE;
	OUT_DESC[0] = MAIL$Q_MSG_FNM;
	RETURN MAIL$SELECT_MSGS(MAIL$Q_MSG_FNM,.SELECT_DATA)
	END;
    IF NOT .MAIL$GL_FLAGS[MAIF_V_CTRLCFL]
	THEN MAIL$INCR_NEWMAIL(MAIL$Q_USERNAME,0);
    RETURN SIGNAL(MAIL$_NONEWMAIL)
    END;

RETURN TRUE
END;

GLOBAL ROUTINE MAIL$SELECT_MSGS(FOLDER_DESC,SELECT_DATA) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Select a new set of current msgs
!
! INPUTS:
!
!	FOLDER_DESC is addr of descriptor of folder
!	SELECT_DATA is addr of select data vector
!--
BEGIN

MAP
    FOLDER_DESC : REF $BBLOCK,
    SELECT_DATA : REF VECTOR[,LONG];

BIND
    QUAL_FLAGS = SELECT_DATA[0] : $BBLOCK;

LOCAL
    DESC : REF $BBLOCK,
    FOLDERSEL,
    STATUS;

!
! If explicit /NEW, ensure in default message file
!
IF .QUAL_FLAGS[QUAL_NEW]
    AND NOT .MAIL$GL_FLAGS[MAIF_V_DFMSG]
THEN BEGIN
    LOCAL
	TDESC : VECTOR[2,LONG];

    TDESC[0] = 0;
    TDESC[1] = TDESC[0];
    MAIL$OPEN_FILE(TDESC);
    IF NOT .MAIL$GL_FLAGS[MAIF_V_DFMSG]
	THEN RETURN FALSE;
    END;

MAIL$DESELECT_MSGS();			!Delete any current messages

FOLDERSEL = .FOLDER_DESC[DSC$W_LENGTH] NEQ 0;
IF NOT .FOLDERSEL
    THEN DESC = MAIL$Q_MSG_FNM
    ELSE DESC = .FOLDER_DESC;
IF .QUAL_FLAGS[QUAL_NEW]
    OR NOT (.QUAL_FLAGS[QUAL_BEFORE] OR .QUAL_FLAGS[QUAL_SINCE]
		OR .FOLDERSEL)
    AND .MAIL$GL_FLAGS[MAIF_V_DFMSG]
THEN BEGIN
    IF NOT .QUAL_FLAGS[QUAL_NEW]
	THEN QUAL_FLAGS[QUAL_IMPLIED_NEW] = TRUE;
    QUAL_FLAGS[QUAL_NEW] = TRUE;
    QUAL_FLAGS[QUAL_SINCE] = TRUE;
    DESC = MAIL$SD_NEWMAIL;
    END;
STATUS = SELECT_MSGS(.DESC,.SELECT_DATA,DESC);
MAIL$GL_FLAGS[MAIF_V_CTRLCFL] = 0;
IF .STATUS
    AND (.MAIL$L_NMSG GTRU 0)
    THEN STR$COPY_DX(MAIL$Q_CURFOLDER,.DESC);

RETURN .STATUS
END;

GLOBAL ROUTINE MAIL$REMOVE_I_MSG =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Deallocate memory for msg and zero entry in msg tbl
!
! INPUTS:
!
!	MAIL$L_CURMSG points to descriptor
!	MAIL$L_MSG_NUM is msg number
!--
BEGIN

DEALLOC_MSG();
MAIL$L_MSGTBL[.MAIL$L_MSG_NUM-1] = 0;

MAIL$L_MSG_STS = MAIL$_NOTREADIN;

RETURN TRUE

END;

GLOBAL ROUTINE MAIL$DELETE_I_MSG =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Delete msg by filing into wastebasket folder
!
! INPUTS:
!
!	MAIL$L_CURMSG points to msg
!	MAIL$L_MSG_NUM is msg number
!--
BEGIN

LOCAL
    MMH : REF $BBLOCK,
    HDREC : REF $BBLOCK;

IF .MAIL$L_CURMSG EQL 0
    THEN RETURN MAIL$_NOTREADIN;
!
! Don't allow a DELETE command in the wastebasket folder
!
IF CH$EQL(.MAIL$Q_CURFOLDER[DSC$W_LENGTH],.MAIL$Q_CURFOLDER[DSC$A_POINTER],
		.MAIL$Q_WASTEDESC[DSC$W_LENGTH],
		.MAIL$Q_WASTEDESC[DSC$A_POINTER],0)
    THEN RETURN MAIL$_DELWASTE;

HDREC = MAIL$L_CURMSG[MMB_T_HDREC];
IF .MAIL$L_CURMSG[MMB_V_NEWMSG]
THEN BEGIN
    MMH = HDREC[MFR_T_DATA];
    MMH[MMH_V_NEWMSG] = 0;
    MAIL$L_CURMSG[MMB_V_NEWMSG] = 0;
    MAIL$DECR_NEWMAIL(MAIL$Q_USERNAME);
    END;
HDREC[MFR_B_FILKEYLEN] = .MAIL$Q_WASTEDESC[DSC$W_LENGTH];
CH$COPY(.MAIL$Q_WASTEDESC[DSC$W_LENGTH],.MAIL$Q_WASTEDESC[DSC$A_POINTER],0,
		MFR_S_FILEKEY,HDREC[MFR_T_FILEKEY]);

IF_ERR(MAIL$UPDATE_I_MSG();,
	RETURN .STATUS);

MAIL$REMOVE_I_MSG();
RETURN TRUE

END;

GLOBAL ROUTINE MAIL$FILE_I_MSG (NEW_FOLDER,CONFIRM_FLAG) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	File a msg into a different folder
!
! INPUTS:
!
!	NEW_FOLDER addr of descriptor of new folder name
!	CONFIRM_FLAG = true to ask if new folder is about to be created,
!			false to just signal the fact
!
! IMPLICIT INPUTS:
!
!	MAIL$L_CURMSG points to msg
!
! ROUTINE VALUE:
!
!	Returns RMS$_RNF if not confirmed to create new folder
!--
BEGIN

MAP
    NEW_FOLDER : REF $BBLOCK;

LOCAL
    NEWF,
    MMH : REF $BBLOCK,
    HDREC : REF $BBLOCK;

IF .MAIL$L_CURMSG EQL 0
    THEN RETURN MAIL$_NOTREADIN;

HDREC = MAIL$L_CURMSG[MMB_T_HDREC];
HDREC[MFR_B_FILKEYLEN] = .NEW_FOLDER[DSC$W_LENGTH];
CH$COPY(.NEW_FOLDER[DSC$W_LENGTH],.NEW_FOLDER[DSC$A_POINTER],0,
		MFR_S_FILEKEY,HDREC[MFR_T_FILEKEY]);
!
! If folder doesn't exist, issue informational that folder created
!
MAIL$T_RD_RAB[RAB$L_ROP] = RAB$M_NLK;
MAIL$T_RD_RAB[RAB$L_KBF] = HDREC[MFR_T_FILEKEY];
MAIL$T_RD_RAB[RAB$B_KSZ] = MFR_S_FILEKEY;
MAIL$T_RD_RAB[RAB$B_KRF] = 1;
MAIL$T_RD_RAB[RAB$B_RAC] = RAB$C_KEY;
IF NOT (NEWF = $FIND(RAB=MAIL$T_RD_RAB))
THEN BEGIN
    IF .CONFIRM_FLAG
	THEN IF NOT MAIL$CONFIRM(YN_DESC,
			MAIL$FAO_GETMSG(MAIL$_CRENEWFOLD,.NEW_FOLDER))
	    THEN RETURN RMS$_RNF;
	END;

IF .MAIL$L_CURMSG[MMB_V_NEWMSG]
THEN BEGIN
    MMH = HDREC[MFR_T_DATA];
    MMH[MMH_V_NEWMSG] = 0;
    MAIL$L_CURMSG[MMB_V_NEWMSG] = 0;
    MAIL$DECR_NEWMAIL(MAIL$Q_USERNAME);
    END;

IF_ERR(MAIL$UPDATE_I_MSG();,
	RETURN .STATUS);

IF NOT .NEWF
    THEN SIGNAL(MAIL$_NEWFOLDER,1,.NEW_FOLDER);

MAIL$REMOVE_I_MSG();
RETURN TRUE

END;

GLOBAL ROUTINE MAIL$INFO_FOLDER(NAME_DESC,SEARCH_MODE) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Return next folder name
!
! INPUTS:
!
!	NAME_DESC = addr of descriptor of starting point
!	SEARCH_MODE = 0 to search KGT, 1 to search KGE
!--
BEGIN

MAP
    NAME_DESC : REF VECTOR[2,LONG];

BUILTIN
    NULLPARAMETER;

LOCAL
    STATUS,
    FOLDERBUF : $BBLOCK[MFR_S_FILEKEY];

IF .NAME_DESC[0] GTRU 0
    THEN CH$COPY(.NAME_DESC[0],.NAME_DESC[1],0,MFR_S_FILEKEY,FOLDERBUF)
    ELSE CH$FILL(0,MFR_S_FILEKEY,FOLDERBUF);

MAIL$T_RD_RAB[RAB$L_KBF] = FOLDERBUF;
MAIL$T_RD_RAB[RAB$B_KSZ] = MFR_S_FILEKEY;
MAIL$T_RD_RAB[RAB$B_KRF] = 1;
MAIL$T_RD_RAB[RAB$B_RAC] = RAB$C_KEY;
MAIL$T_RD_RAB[RAB$L_ROP] = RAB$M_LOC OR RAB$M_NLK;
MAIL$T_RD_RAB[RAB$V_KGE] = (IF NOT NULLPARAMETER(2)
				THEN .SEARCH_MODE
				ELSE FALSE);
MAIL$T_RD_RAB[RAB$V_KGT] = NOT .MAIL$T_RD_RAB[RAB$V_KGE];
MAIL$T_RD_RAB[RAB$L_CTX] = MAIL$_READERR;

IF (STATUS = $GET(RAB=MAIL$T_RD_RAB))
THEN BEGIN
    BIND
	HDREC = .MAIL$T_RD_RAB[RAB$L_RBF] : $BBLOCK;

    NAME_DESC[0] = .HDREC[MFR_B_FILKEYLEN];
    NAME_DESC[1] = HDREC[MFR_T_FILEKEY];
    END
ELSE IF .STATUS NEQ RMS$_RNF
    THEN UTIL$REPORT_IO_ERROR(MAIL$T_RD_RAB);

RETURN .STATUS
END;

GLOBAL ROUTINE MAIL$ISAM_INIT =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Read in mail file info records and set up data for later use
!--
BEGIN

LOCAL
    DESC : VECTOR[2,LONG],
    RECDESC : VECTOR[2,LONG];

!
! Get the wastebasket folder name
!
DESC[0] = %CHARCOUNT ('WASTEBASKET');
DESC[1] = UPLIT(%ASCII 'WASTEBASKET');
IF MAIL$READ_INFO_REC(MAIL$T_RD_RAB,MFR_C_WASTENAME,0,RECDESC)
THEN BEGIN
    BIND
	WASTENAME = .RECDESC[1] + $BYTEOFFSET(MFR_T_DATA) : VECTOR[,BYTE];

    IF .WASTENAME[0] NEQ 0
    THEN BEGIN
	DESC[0] = .WASTENAME[0];
	DESC[1] = WASTENAME[1];
	END;
    END;
STR$COPY_DX(MAIL$Q_WASTEDESC,DESC);
RETURN TRUE
END;

ROUTINE DESELECT_IF_WASTEBASKET : NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Deselect current messages if current folder is wastebasket folder
!
!--
BEGIN
IF CH$EQL(.MAIL$Q_CURFOLDER[DSC$W_LENGTH],.MAIL$Q_CURFOLDER[DSC$A_POINTER],
	.MAIL$Q_WASTEDESC[DSC$W_LENGTH],.MAIL$Q_WASTEDESC[DSC$A_POINTER],0)
    THEN MAIL$DESELECT_MSGS();
RETURN;
END;

GLOBAL ROUTINE MAIL$MOVE_WASTEBASKET (DEST_DESC) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Move the contents of the wastebasket folder to folder DEST_DESC
!--
BEGIN

MAP
    DEST_DESC : REF $BBLOCK;

LOCAL
    WASTENAMEBUF : $BBLOCK[MFR_S_FILEKEY],
    RECBUF : REF $BBLOCK;

DESELECT_IF_WASTEBASKET();
CH$COPY(.MAIL$Q_WASTEDESC[DSC$W_LENGTH],.MAIL$Q_WASTEDESC[DSC$A_POINTER],
		0,MFR_S_FILEKEY,WASTENAMEBUF);
MAIL$T_RD_RAB[RAB$L_ROP] = 0;
MAIL$T_RD_RAB[RAB$L_KBF] = WASTENAMEBUF;
MAIL$T_RD_RAB[RAB$B_KSZ] = MFR_S_FILEKEY;
MAIL$T_RD_RAB[RAB$B_KRF] = 1;
MAIL$T_RD_RAB[RAB$B_RAC] = RAB$C_KEY;
MAIL$T_RD_RAB[RAB$L_CTX] = MAIL$_WRITEERR;

WHILE $GET(RAB=MAIL$T_RD_RAB)
DO BEGIN
    RECBUF = .MAIL$T_RD_RAB[RAB$L_RBF];
    RECBUF[MFR_B_FILKEYLEN] = .DEST_DESC[DSC$W_LENGTH];
    CH$COPY(.DEST_DESC[DSC$W_LENGTH],.DEST_DESC[DSC$A_POINTER],0,
		MFR_S_FILEKEY,RECBUF[MFR_T_FILEKEY]);
    $UPDATE(RAB=MAIL$T_RD_RAB,ERR=UTIL$REPORT_IO_ERROR);
    END;

RETURN TRUE
END;

ROUTINE UPDATE_DELCOUNT (MSGCOUNT) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Update the count of deleted msg bytes in the fileinfo record
!
!--
BEGIN
LOCAL
    RECDESC : VECTOR[2,LONG],
    RECPTR : REF $BBLOCK,
    RECRFA : VECTOR[2,LONG],
    TREC : $BBLOCK[$BYTEOFFSET(MFR_T_DATA)+4];

IF .MSGCOUNT EQL 0
    THEN RETURN TRUE;

IF MAIL$READ_INFO_REC(MAIL$T_RD_RAB,MFR_C_FILEINFO,1,RECDESC,RECRFA)
THEN BEGIN
    RECPTR = .RECDESC[1];
    (RECPTR[MFR_T_DATA])<0,32,0> = .(RECPTR[MFR_T_DATA])<0,32,0> + .MSGCOUNT;
    MAIL$L_DELMSGCNT = .(RECPTR[MFR_T_DATA])<0,32,0>;
    MAIL$UPDATE_INFO_REC(MAIL$T_RD_RAB,RECDESC,RECRFA);
    END
ELSE BEGIN
    (TREC[MFR_Q_DATIM])<0,32,0> = MFR_C_FILEINFO;
    (TREC[MFR_Q_DATIM]+4) = 0;
    CH$FILL(0,MFR_S_FILEKEY+1,TREC[MFR_B_FILKEYLEN]);
    (TREC[MFR_T_DATA])<0,32,0> = .MSGCOUNT;
    MAIL$L_DELMSGCNT = .MSGCOUNT;
    RECDESC[0] = $BYTEOFFSET(MFR_T_DATA) + 4;
    RECDESC[1] = TREC;
    MAIL$UPDATE_INFO_REC(MAIL$T_RD_RAB,RECDESC)
    END;
!
! Check the threshold to determine if CONVERT/RECLAIM needs to be done
!
IF NOT .MAIL$GL_FLAGS[MAIF_V_RECL]
    AND .MAIL$L_DELMSGCNT GTRU .MAIL$L_RECL_THRESHOLD
THEN BEGIN
    SIGNAL(MAIL$_RECLPLSWAIT);
    MAIL$RECLAIM(0);
    END;
RETURN TRUE
END;

ROUTINE DELETE_EXTMSG(DATIM) : NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Delete an external message file
!
!--
BEGIN

LOCAL
    TMPFAB : $FAB_DECL,
    TMPNAM : $NAM_DECL,
    TMPXAB : $XABPRO_DECL,
    NAMBUF : $BBLOCK[NAM$C_MAXRSS],
    DESC : VECTOR[2,LONG];

DESC[0] = NAM$C_MAXRSS;
DESC[1] = NAMBUF;
MAIL$FORM_EXTFILE(.DATIM,DESC);
$FAB_INIT(FAB=TMPFAB,
	FNS=.DESC[0],
	FNA=.DESC[1],
	FAC=(GET,PUT),			!Need write access to file to fix prot
	CTX=MAIL$_FILNOTDEL,
	XAB=TMPXAB,
	NAM=TMPNAM);

$NAM_INIT(NAM=TMPNAM,
	ESS=NAM$C_MAXRSS,
	ESA=NAMBUF,
	RSS=NAM$C_MAXRSS,
	RSA=NAMBUF);

$XABPRO_INIT(XAB=TMPXAB,
	NXT=0);

IF_ERR($OPEN(FAB=TMPFAB);,
	RETURN);

IF .TMPXAB[XAB$L_UIC] NEQ .MAIL$L_MYUIC
THEN BEGIN
    $CLOSE(FAB=TMPFAB);
    TMPFAB[FAB$L_STS] = RMS$_PRV;
    TMPFAB[FAB$L_STV] = SS$_NOPRIV;
    TMPFAB[FAB$L_CTX] = MAIL$_CLOSEDEL;
    UTIL$REPORT_IO_ERROR(TMPFAB);
    RETURN;
    END;
!
! Close the file, changing the protection to allow delete access.  Then
! $ERASE the file.
!
TMPXAB[XAB$L_UIC] = 0;			!Don't need to change uic
TMPXAB[XAB$W_PRO] = DELETE_PRO;
$CLOSE(FAB=TMPFAB,ERR=UTIL$REPORT_IO_ERROR);
TMPFAB[FAB$V_NAM] = 1;
$ERASE(FAB=TMPFAB,ERR=UTIL$REPORT_IO_ERROR);
RETURN;
END;

GLOBAL ROUTINE MAIL$EMPTY_WASTEBASKET =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine empties the wastebasket folder by deleting all the
!	messages it contains
!
!--
BEGIN

LOCAL
    PTR : REF $BBLOCK,
    WASTENAMEBUF : $BBLOCK[MFR_S_FILEKEY],
    KEYBUFFER : VECTOR[8,BYTE],
    HDRFA : VECTOR[2,LONG],
    MMH : REF $BBLOCK,
    DELSPACE,
    MSGCOUNT,
    STATUS;

DESELECT_IF_WASTEBASKET();
MSGCOUNT = 0;
DELSPACE = 0;
CH$COPY(.MAIL$Q_WASTEDESC[DSC$W_LENGTH],.MAIL$Q_WASTEDESC[DSC$A_POINTER],0,
		MFR_S_FILEKEY,WASTENAMEBUF);

WHILE (
	MAIL$T_RD_RAB[RAB$L_ROP] = 0;
	MAIL$T_RD_RAB[RAB$L_KBF] = WASTENAMEBUF;
	MAIL$T_RD_RAB[RAB$B_KSZ] = MFR_S_FILEKEY;
	MAIL$T_RD_RAB[RAB$B_KRF] = 1;
	MAIL$T_RD_RAB[RAB$B_RAC] = RAB$C_KEY;
	$FIND(RAB=MAIL$T_RD_RAB)
	)
DO BEGIN
    MAIL$T_RD_RAB[RAB$B_RAC] = RAB$C_RFA;
    MAIL$T_RD_RAB[RAB$L_KBF] = .MAIL$T_RD_RAB[RAB$L_RBF];
    MAIL$T_RD_RAB[RAB$B_KSZ] = 8;
    MAIL$T_RD_RAB[RAB$B_KRF] = 0;
    !
    ! Read the message header record
    !
    MAIL$T_RD_RAB[RAB$L_CTX] = MAIL$_READERR;
    IF_ERR($GET(RAB=MAIL$T_RD_RAB,ERR=UTIL$REPORT_IO_ERROR);,
		UPDATE_DELCOUNT(.DELSPACE);
		RETURN .MSGCOUNT);
    HDRFA[0] = .MAIL$T_RD_RAB[RAB$L_RFA0];
    HDRFA[1] = .MAIL$T_RD_RAB[RAB$W_RFA4];
    PTR = .MAIL$T_RD_RAB[RAB$L_RBF] + $BYTEOFFSET(MFR_T_DATA);
    CH$MOVE(8,PTR[MMH_Q_DATID],KEYBUFFER);
    MAIL$T_RD_RAB[RAB$L_KBF] = KEYBUFFER;
    IF .PTR[MMH_V_EXTMSG]
	THEN DELETE_EXTMSG(KEYBUFFER);
    MAIL$T_RD_RAB[RAB$B_RAC] = RAB$C_KEY;
    IF $FIND(RAB=MAIL$T_RD_RAB)
    THEN BEGIN
	MAIL$T_RD_RAB[RAB$L_ROP] = RAB$M_LIM;
	!
	! Read sequentially on the data records of the msg and delete them
	!
	MAIL$T_RD_RAB[RAB$B_RAC] = RAB$C_SEQ;
	WHILE (STATUS = $GET(RAB=MAIL$T_RD_RAB))
	    AND (.STATUS NEQ RMS$_OK_LIM)
	DO BEGIN
	    DELSPACE = .DELSPACE + .MAIL$T_RD_RAB[RAB$W_RSZ];
	    MAIL$T_RD_RAB[RAB$L_CTX] = MAIL$_WRITEERR;
	    $DELETE(RAB=MAIL$T_RD_RAB,ERR=UTIL$REPORT_IO_ERROR);
	    END;
	END;
    !
    ! Delete the message header record
    !
    MAIL$T_RD_RAB[RAB$L_RFA0] = .HDRFA[0];
    MAIL$T_RD_RAB[RAB$W_RFA4] = .HDRFA[1];
    MAIL$T_RD_RAB[RAB$B_RAC] = RAB$C_RFA;
    MAIL$T_RD_RAB[RAB$L_CTX] = MAIL$_READERR;
    IF_ERR($GET(RAB=MAIL$T_RD_RAB,ERR=UTIL$REPORT_IO_ERROR);,
		UPDATE_DELCOUNT(.DELSPACE);
		RETURN .MSGCOUNT);
    DELSPACE = .DELSPACE + .MAIL$T_RD_RAB[RAB$W_RSZ];
    MMH = .MAIL$T_RD_RAB[RAB$L_RBF] + $BYTEOFFSET(MFR_T_DATA);
    IF .MMH[MMH_V_NEWMSG]
    THEN BEGIN
	MMH[MMH_V_NEWMSG] = 0;
	MAIL$DECR_NEWMAIL(MAIL$Q_USERNAME);
	END;
    MAIL$T_RD_RAB[RAB$L_CTX] = MAIL$_WRITEERR;
    $DELETE(RAB=MAIL$T_RD_RAB,ERR=UTIL$REPORT_IO_ERROR);
    MSGCOUNT = .MSGCOUNT + 1;
    IF .MAIL$GL_FLAGS[MAIF_V_CTRLCFL]
	THEN EXITLOOP;
    END;
UPDATE_DELCOUNT(.DELSPACE);
RETURN .MSGCOUNT
END;

GLOBAL ROUTINE MAIL$CHECK_DATE(RAB,DATETIME,DEVDIRDESC) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Check to see if the date/time specified is already used in the
!	file open on RAB.  If so, bump DATETIME 512 times looking for
!	a free date/time.  If none found, return error
!
!	DEVDIRDESC is an optional argument.  If present, the external
!	file check is also made.
!--
BEGIN

MAP
    RAB : REF $BBLOCK,
    DATETIME : REF VECTOR[,LONG];

BUILTIN
    NULLPARAMETER;

LOCAL
    FFLAG,
    TMPFAB : $FAB_DECL,
    TMPDESC : VECTOR[2,LONG],
    TMPBUF : $BBLOCK[NAM$C_MAXRSS];

FFLAG = NOT NULLPARAMETER(3);
TMPDESC[1] = TMPBUF;
RAB[RAB$B_RAC] = RAB$C_KEY;
RAB[RAB$L_ROP] = RAB$M_LOC OR RAB$M_NLK;
RAB[RAB$B_KRF] = 0;
RAB[RAB$B_KSZ] = 8;
RAB[RAB$L_KBF] = .DATETIME;
INCRU I FROM 0 TO 512
DO BEGIN
    IF NOT $FIND(RAB=.RAB)
    THEN BEGIN
	IF NOT .FFLAG
	    THEN RETURN TRUE;
	TMPDESC[0] = NAM$C_MAXRSS;
	SYS$FAO(MAIL$SD_EXTMSGNAM,TMPDESC,TMPDESC,.DEVDIRDESC,
			.DATETIME[1],.DATETIME[0]);
	$FAB_INIT(FAB=TMPFAB,
		FNS=.TMPDESC[0],
		FNA=.TMPDESC[1]);

	IF NOT $OPEN(FAB=TMPFAB)
	    THEN RETURN TRUE;
	$CLOSE(FAB=TMPFAB);
	END;
    DATETIME[0] = .DATETIME[0] + 1;
    IF .DATETIME[0] EQL 0
	THEN DATETIME[1] = .DATETIME[1] + 1;
    END;

RETURN FALSE
END;

ROUTINE COPY_GETREC (OUTDESC) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Get next record of message
!--
BEGIN

MAP
    OUTDESC : REF VECTOR[,LONG];

LOCAL
    MORE_FLAG,
    STATUS;

IF .MAIL$GL_FLAGS[MAIF_V_ISAM]
THEN BEGIN
    STATUS = MAIL$GET_I_MSG(.OUTDESC,MORE_FLAG);
    IF NOT .STATUS
	THEN STATUS = RMS$_EOF;
    END
ELSE BEGIN
    IF (STATUS = .MAIL$L_MSG_STS)
	THEN (OUTDESC[0] = .MAIL$W_MSG_RSIZ;
		OUTDESC[1] = .MAIL$L_MSG_RADR;
		MAIL$GET_MSG())
	ELSE STATUS = RMS$_EOF;
    END;
RETURN .STATUS
END;

ROUTINE COPY_MSG (FOLDER_DESC,OUTRAB)=
!++
! FUNCTIONAL DESCRIPTION:
!
!	Copy one ISAM message to the message file
!
!--
BEGIN

MAP
    OUTRAB : REF $BBLOCK;

OWN
!
! FLINK through MSGBLKS are the start of a CNCT block which is passed to
! MAIL$WRITE_MSG.  Note that MAIL$WRITE_MSG doesn't refer to anything else
! in the CNCT block so this is a short one.
!
    FLINK : VECTOR[2,LONG],		!Note that this must parallel CNCTDEF
    SENDER_DESC : DYN_DESC_DECL,
    TO_DESC : DYN_DESC_DECL,
    SUBJ_DESC : DYN_DESC_DECL,
    CC_DESC : DYN_DESC_DECL,			!Always null string
    DUMMY_ADRLST : VECTOR[2,LONG],
    DUMMY_LNKLST : VECTOR[2,LONG],
    DUMMY_NADDRS,
    MSGBLKS,
    DATE_DESC : DYN_DESC_DECL;

LOCAL
    MSGFLAGS : $BBLOCK[4],
    DATEBUF : $BBLOCK[32],
    DATE_DESC2 : VECTOR[2,LONG],
    DATETIME : VECTOR[2,LONG];

DATE_DESC2[0] = DATE_DESC2[1] = 0;
MSGFLAGS = MCR_M_USE_DATIM OR MCR_M_TELL_NEW;
IF .MAIL$GL_FLAGS[MAIF_V_ISAM]
THEN BEGIN
    IF_ERR(MAIL$REWIND_I_MSG();,
	RETURN .STATUS);
    MAIL$B_MSGTRAN = MMB_C_TEXT;
    MAIL$INFO_I_MSG(0,SUBJ_DESC,0,0,SENDER_DESC,0,TO_DESC);
    MSGBLKS = .MAIL$L_CURMSG[MMB_L_NBLKS];
    CH$MOVE(8,MAIL$L_CURMSG[MMB_T_HDREC],DATETIME);
    END
ELSE BEGIN
    IF_ERR(MAIL$INFO_MSG(SENDER_DESC,SUBJ_DESC,DATE_DESC,TO_DESC,MSGBLKS);,
		RETURN .STATUS);
    MSGBLKS = (.MSGBLKS + 511)/512;		!Convert bytes to blocks
    IF_ERR(MAIL$REWIND_MSG();,
		RETURN .STATUS);
    IF MAIL$TEST_SEQ_NEW()
	THEN MSGFLAGS[MCR_V_SND_NEWMSG] = TRUE;
    INCRU I FROM 0 TO (IF MAIL$TEST_SUBJ() THEN 3 ELSE 2)
	DO IF NOT MAIL$GET_MSG() THEN EXITLOOP;
    DATE_DESC2[0] = 32;
    DATE_DESC2[1] = DATEBUF;
    !
    ! Fill out date/time so that current defaults are not used
    !
    $FAO($DESCRIPTOR('!17AS:00.00'),DATE_DESC2,DATE_DESC2,DATE_DESC);
    $BINTIM(TIMBUF=DATE_DESC2,TIMADR=DATETIME);
    END;
IF NOT MAIL$CHECK_DATE(.OUTRAB,DATETIME)
THEN BEGIN
    CH$MOVE(DSC$C_S_BLN,UTIL$GETFILENAME(.OUTRAB[RAB$L_FAB]),DATE_DESC2);
    SIGNAL(MAIL$_DATIMUSED,2,DATETIME,DATE_DESC2);
    RETURN MAIL$_DATIMUSED
    END;
RETURN MAIL$WRITE_MSG(COPY_GETREC,FLINK,.FOLDER_DESC,
				.MSGFLAGS,.OUTRAB,DATETIME)

END;

GLOBAL ROUTINE MAIL$COPY_MSGS(FILE_DESC,FOLDER_DESC,COPY_FLAG,SIGNAL_RTN) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine copies either messages from sequential file into
!	an ISAM file or from one ISAM message file to another
!
!	ALL_FLAG = 
!		   MAIL$V_ALL if to copy all current messages
!		   MAIL$V_NIL if exclusive access needed
!		   MAIL$V_DELMSG if message should be deleted after copying
!		   MAIL$V_CONFNEW if confirmation of new folder creation
!--
BEGIN

MAP
    FILE_DESC : REF $BBLOCK,
    FOLDER_DESC : REF $BBLOCK,
    COPY_FLAG : $BBLOCK;

BUILTIN
    NULLPARAMETER;

LOCAL
    IFAB : $FAB_DECL,
    IRAB : $RAB_DECL,
    INAM : $NAM_DECL,
    RABPTR : REF $BBLOCK,
    DESC : VECTOR[2,LONG],
    NAMESS : $BBLOCK[NAM$C_MAXRSS],
    FOLDERBUF : $BBLOCK[MFR_S_FILEKEY],
    DELETE_FLAG,
    SAVE_MSGNUM,
    OPENIT,
    EXCLUSIVE_ACCESS,
    NEW_FILE,
    STATUS;

RABPTR = IRAB;
$NAM_INIT(NAM=INAM,
	RSS=NAM$C_MAXRSS,
	RSA=NAMESS,
	ESS=NAM$C_MAXRSS,
	ESA=NAMESS);

IF .FOLDER_DESC[DSC$W_LENGTH] EQL 0
    THEN STR$COPY_DX(.FOLDER_DESC,$DESCRIPTOR('MAIL'));
!
! See if file specified.  If not, and sequential file, set up default
!
NEW_FILE = 0;
OPENIT = 1;
IF .FILE_DESC[DSC$W_LENGTH] EQL 0
THEN BEGIN
    IF NOT .MAIL$GL_FLAGS[MAIF_V_ISAM]
    THEN BEGIN
	STR$COPY_DX(.FILE_DESC,$DESCRIPTOR('MAIL'));
	END
    ELSE BEGIN
	RABPTR = MAIL$T_RD_RAB;
	OPENIT = 0;
	END;
    END;
!
! Try to open existing file by specifying CIF
!
IF .OPENIT
THEN BEGIN
    IFAB[FAB$L_CTX] = MAIL$_OPENOUT;
    EXCLUSIVE_ACCESS = .COPY_FLAG[MCR_V_NIL];
    STATUS = MAIL$CREATE_ISAM(IFAB,.RABPTR,INAM,.FILE_DESC,0,
			(.EXCLUSIVE_ACCESS OR MCR_M_CIF));
    IF NOT .STATUS
    THEN BEGIN
	IF .STATUS NEQ RMS$_SHR
	    THEN RETURN UTIL$REPORT_IO_ERROR(IFAB);
	STATUS = MAIL$CREATE_ISAM(IFAB,.RABPTR,INAM,.FILE_DESC,0,
						.EXCLUSIVE_ACCESS);
	IF NOT .STATUS
	    THEN RETURN UTIL$REPORT_IO_ERROR(IFAB);
	NEW_FILE = 1;
	END;
    CH$MOVE(DSC$C_S_BLN,UTIL$GETFILENAME(IFAB),DESC);
    IF ((.IFAB[FAB$L_STS] EQL RMS$_CREATED)
	    OR .NEW_FILE)
	AND NOT NULLPARAMETER(4)
	THEN (.SIGNAL_RTN)(DESC);
    END;
!
! File the messages
!
DELETE_FLAG = .COPY_FLAG[MCR_V_DELMSG];
!
! If new folder confirmation requested, then see if the folder exists.
!
IF .COPY_FLAG[MCR_V_CONFNEW]
THEN BEGIN
    CH$COPY(.FOLDER_DESC[DSC$W_LENGTH],.FOLDER_DESC[DSC$A_POINTER],
		0,MFR_S_FILEKEY,FOLDERBUF);
    RABPTR[RAB$B_RAC] = RAB$C_KEY;
    RABPTR[RAB$L_ROP] = RAB$M_LOC OR RAB$M_NLK;
    RABPTR[RAB$B_KRF] = 1;
    RABPTR[RAB$B_KSZ] = MFR_S_FILEKEY;
    RABPTR[RAB$L_KBF] = FOLDERBUF;
    IF NOT $FIND(RAB=.RABPTR)
	THEN IF NOT MAIL$CONFIRM(YN_DESC,
			MAIL$FAO_GETMSG(MAIL$_CRENEWFOLD,.FOLDER_DESC))
	    THEN RETURN TRUE;
    END;
IF .MAIL$GL_FLAGS[MAIF_V_ISAM]
THEN BEGIN
    IF NOT .COPY_FLAG[MCR_V_ALL]
    THEN (IF COPY_MSG(.FOLDER_DESC,.RABPTR)
		AND .DELETE_FLAG
		THEN MAIL$DELETE_I_MSG())
    ELSE BEGIN
	SAVE_MSGNUM = .MAIL$L_MSG_NUM;
	INCRU I FROM 1 TO .MAIL$L_NMSG
	DO BEGIN
	    MAIL$L_MSG_NUM = .I;
	    IF (MAIL$L_CURMSG = .MAIL$L_MSGTBL[.I-1]) NEQ 0 THEN
	    IF COPY_MSG(.FOLDER_DESC,.RABPTR)
		AND .DELETE_FLAG
		THEN MAIL$DELETE_I_MSG();
	    END;
	MAIL$L_MSG_NUM = .SAVE_MSGNUM;
	IF .SAVE_MSGNUM GTRU 0
	    THEN MAIL$L_CURMSG = .MAIL$L_MSGTBL[.SAVE_MSGNUM-1];
	END
    END
ELSE BEGIN
    IF NOT .COPY_FLAG[MCR_V_ALL]
    THEN COPY_MSG(.FOLDER_DESC,.RABPTR)
    ELSE BEGIN
	IF NOT MAIL$FIND_MSG(1)
	    THEN (SIGNAL(.MAIL$L_MSG_STS);
		 IF .OPENIT
		    THEN $CLOSE(FAB=IFAB);
		 RETURN .MAIL$L_MSG_STS);
	DO COPY_MSG(.FOLDER_DESC,.RABPTR)
	    UNTIL NOT MAIL$FIND_MSG(0);
	END
    END;

IF .OPENIT
    THEN $CLOSE(FAB=IFAB);

RETURN TRUE
END;

END
ELUDOM
