	.TITLE	SYSDELPRC - DELETE PROCESS SYSTEM SERVICE
	.IDENT	'V04-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
; FACILITY: EXECUTIVE, SYSTEM SERVICES
;
; ABSTRACT:	SYSDELPRC IMPLEMENTS THE DELETE PROCESS SYSTEM SERVICE
;	WHICH CAUSES A PROCESS TO BE DELETED FROM THE SYSTEM AFTER
;	RELEASING ALL OF ITS RESOURCES.
;
; ENVIRONMENT:
;	MODE=KERNEL
;
; AUTHOR:	R. I. HUSTVEDT, CREATION DATE: 30-DEC-76
;
; MODIFIED BY:
;
;	V03-019	TMK0002		Todd M. Katz		18-Apr-1983
;		Delete the job-wide logical name table and all names contained
;		therein after dismounting all mounted volumes ( the table is
;		actually deleted after decrementing the interactive and batch 
;		job counts as appropriate ). We were deleting the job table 
;		before dismounting all privately mounted volumes. This was 
;		causing random paged-pool corruption whenever a logical name had
;		been specified during the mounting of the private volume. This 
;		logical name is now placed into the job table, instead of into 
;		the process logical name table. Therefore, it was being deleted 
;		twice - once as a result of the cleanup of the job table prior 
;		to its deletion, and once as a result of the dismount of the
;		privately mounted disk.
;
;	V03-018	HH0011		Hai Huang		4-Apr-1984
;		Lock I/O database when flushing the job-wide mount list.
;	
;	V03-017 HH0002		Hai Huang		1-Feb-1984
;		Add job-wide mount support, i.e. do not issue ioc$dismount
;		if the process is a sub-process.
;
;	V03-016	CDS0002		Christian D. Saether	14-Dec-1983
;		Modify the bugcheck that looks for assigned channels
;		to ignore the special xqp channel.
;
;	V03-015	LJK0254		Lawrence J. Kenah	7-Dec-1983
;		Add two consistency checks.
;
;	V03-014	TMK0001		Todd M. Katz		12-Oct-1983
;		If the process being deleted is not a sub-process, then
;		delete the job-wide logical name table after the deletion
;		of all subprocesses has completed.
;
;	V03-013	LJK0248		Lawrence J. Kenah	30-Aug-1983
;		Reorder EXE$DELPRC procedure so that setting of DELPEN bit
;		and queuing of DELETE AST occur while remaining at SYNCH.
;
;	V03-012	WMC0002		Wayne Cardoza		15-JUL-1983
;		Batch count.	
;
;	V03-011	WMC0011		Wayne Cardoza		15-Jun-1983
;		Decrement interactive user count when appropriate.
;
;	V03-010	RSH0032		R. Scott Hanna		26-May-1983
;		Fix linker truncation error.
;
;	V03-009	ACG0335		Andrew C. Goldstein,	10-May-1983  19:20
;		Deallocate extended rights list when present
;
;	V03-008	LJK0202		Lawrence J. Kenah	19-Apr-1983
;		Fix several broken word displacements
;
;	V03-007	CWH1002		CW Hobbs		24-Feb-1983
;		Modified to support extended pids.  Use SCH$C_SWPPIX to locate
;		the swapper pid.
;
;	V03-006	DMW4025		DMWalp			 7-Jan-1983
;		Fixed broken branch
;
;	V03-005	CDS0001		C Saether		22-Oct-1982
;		Add process deletion defer mechanism.  Initial user F11BXQP.
;
;	V03-004	ACG0301		Andrew C. Goldstein,	21-Oct-1982  13:41
;		Restore FILCNTNONZ bugcheck
;
;	V03-003	WMC0001		Wayne Cardoza		26-Aug-1982
;		Reset privileged library vectors after rundown.
;
;	V03-002	LJK0169		LAWRENCE J. KENAH	2-Jun-1982
;		Correct incorrect register bug when returning unused CPU
;		time. Make extremely rare error path perform in a way
;		that makes sense.
;
;	V03-001	ACG0178		Andrew C. Goldstein,	1-Apr-1982  11:21
;		Remove FILECNTNONZ bugcheck
;
;--
	.PAGE
	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;

	$ACBDEF				; DEFINE AST CONTROL BLOCK OFFSETS
	$ACCDEF				; DEFINE TERMINATION MESSAGE OFFSETS
	$ACMDEF				; DEFINE ACCOUNTING MESSAGE OFFSETS
	$ARBDEF				; DEFINE ACCESS RIGHTS BLOCK
	$CCBDEF				; DEFINE CHANNEL CONTROL BLOCK
	$IODEF				; DEFINE I/O FUNCTION CODES
	$IPLDEF				; DEFINE INTERRUPT PRIORITY LEVELS
	$JIBDEF				; DEFINE JOB INFORMATION BLOCK OFFSETS
	$MSGDEF				; DEFINE SYSTEM MESSAGE TYPE CODES
	$PCBDEF				; DEFINE PCB OFFSETS
	$PFNDEF				; DEFINE PFN CONSTANTS
	$PHDDEF				; DEFINE PROCESS HEADER OFFSETS
	$PRDEF				; DEFINE PROCESSOR REGISTER NAMES
	$PRIDEF				; DEFINE PRIORITY INCREMENTS
	$PTEDEF				; DEFINE PTE FIELDS
	$PSLDEF				; DEFINE PSL FIELDS AND VALUES
	$RSNDEF				; DEFINE RESOURCE NUMBERS
	$SECDEF				; DEFINE SECTION TABLE ENTRY
	$SSDEF				; DEFINE SYSTEM SERVICE STATUS CODES
	$UCBDEF				; DEFINE UNIT CONTROL BLOCK OFFSETS

;
; MACROS:
;

;
; EQUATED SYMBOLS:
;

ACB_L_CPULIM = ACB$L_KAST + 4
ACB_L_CPUTIM = ACB_L_CPULIM + 4
JOB_STRING_LEN = 16

;
; OWN STORAGE:
;

	.PSECT	Y$EXEPAGED

LNM_SYSTEM_DIRECTORY_DESC:		; Descriptor of System Directory Table
	.ASCID	/LNM$SYSTEM_DIRECTORY/

JOB_FAO:				; $FAO control string descriptor for 
	.ASCID	/LNM$JOB_!XL/		; construction of job-wide table name

	.PSECT	AEXENONPAGED
	.PAGE
	.SBTTL	EXE$DELPRC - DELETE PROCESS SYSTEM SERVICE
;++
; FUNCTIONAL DESCRIPTION:
;	EXE$DELPRC IMPLEMENTS THE DELETE PROCESS SYSTEM SERVICE WHICH CAUSES
;	A PROCESS TO BE DELETED FROM THE SYSTEM.  IF THE SPECIFIED
;	PROCESS EXISTS, A KERNEL AST IS QUEUED FOR IT TO
;	PERFORM THE DELETION PROCESSING IN THE CONTEXT OF THE TARGET
;	PROCESS.  A PROCESS THEREFORE DELETES ITSELF.
;
; CALLING SEQUENCE:
;	CALLG	ARGLIST,EXE$DELPRC
;
; INPUT PARAMETERS:
;	PIDADR(AP)  - ADDRESS OF THE PROCESS IDENTIFICATION OF THE
;		      PROCESS TO BE DELETED.
;	PRCNAM(AP) - ADDRESS OF STRING DESCRIPTOR FOR PROCESS LOGICAL NAME 
;		      STRING.
;	R4 - PCB ADDRESS OF CURRENT PROCESS
;
; IMPLICIT INPUTS:
;	CURRENT PROCESS PCB AND PHD
;	PCB OF TARGET PROCESS
;
; OUTPUT PARAMETERS:
;	R0 - COMPLETION STATUS CODE
;	@PIDADR(AP) - PROCESS IDENTIFICATION OF DELETED PROCESS
;
; IMPLICIT OUTPUTS:
;	NONE
;
; COMPLETION CODES:
;	SS$_NORMAL   -   SUCCESSFUL COMPLETION 
;	SS$_NONEXPR  -   NONEXISTENT PROCESS
;	SS$_NOPRIV   -   NO PRIVILEGE, TARGET PROCESS IS NOT A SUBPROCESS
;			 AND ISSUING PROCESS DOES NOT HAVE PROCESS CONTROL
;			 PRIVILEGE FOR GROUP OR WORLD.
;	SS$_INSFMEM  -	 INSUFFICIENT DYNAMIC MEMORY AVAILABLE FOR SERVICE
;			 AND RESOURCE WAIT MODE DISABLED.
;
; SIDE EFFECTS:
;	A KERNEL AST WILL BE ENQUEUED FOR THE PROCESS TO BE
;	DELETED WHICH MAY CAUSE RESCHEDULING TO OCCUR.
;
;--

	.ENTRY	EXE$DELPRC,^M<R2,R3,R4,R5,R6,R7>	; Save R2 through R7
	BSBW	EXE$ALLOCIRP		; Allocate AST control block
	BLBC	R0,10$			; Return error if none
	MOVL	R2,R5			; Set address for SCH$QAST
	BSBW	EXE$NAMPID		; Convert name/PID to PCB address
	BLBC	R0,30$			; Exit if error
	CMPW	R1,S^#SCH$C_SWPPIX	; Do not allow SWAPPER or NULL
	BLEQU	20$			; Exit with error if either of those

; If the target process is already marked for delete, the system service
; simply returns a success code to the caller after deallocating the ACB.
; Note that SS$_NORMAL was loaded into R0 by the success path of EXE$NAMPID. 

	BBSS	#PCB$V_DELPEN,PCB$L_STS(R4),30$

; The following three instructions are the guts of the $RESUME system service.
; That same functionality must be reproduced here while remaining at IPL
; SYNCH so the system service cannot be used.

	ASSUME PCB$V_RESPEN LE 7

	BISB	#<1@PCB$V_RESPEN>,PCB$L_STS(R4)	; Set resume pending bit
	MOVZBL	#PRI$_RESAVL,R2		; Set priority increment class
	RPTEVT	RESUME			; Report RESUME event to scheduler

	MOVAB	L^DELETE,ACB$L_AST(R5)	; Set address for delete action
	CLRB	ACB$B_RMOD(R5)		; Mark as normal kernel mode AST
	MOVL	PCB$L_PID(R4),ACB$L_PID(R5)	; Set PID of target

; R2 has already been loaded with the correct priority increment class
; and R2 is preserved by SCH$RSE (called from within the RPTEVT macro)
; so that a
;
;	MOVZBL	#PRI$_RESAVL,R2		; Set priority increment
;
; is not necessary here.

	BSBW	SCH$QAST		; And queue ast for process
	MOVZWL	#SS$_NORMAL,R0		; Set normal status
10$:	SETIPL	#0			; Enable rescheduling
	RET				; ... and return

; The following error paths must deallocate the unused ACB before returning.

20$:	MOVZWL	#SS$_NONEXPR,R0		; NULL and SWAPPER cannot be deleted
30$:	PUSHL	R0			; Save error status
	MOVL	R5,R0			; Get address of ACB
	BSBW	EXE$DEANONPAGED		; Deallocate packet back to pool
	POPL	R0			; Retrieve saved error status
	BRB	10$			; Join common exit code	

; The rest of the code in this module can exist in a pageable part of the exec

	.PSECT	Y$EXEPAGED
	.PAGE
	.SBTTL	DELETE - PERFORM DELETE ACTIONS IN CONTEXT OF PROCESS
;++
; FUNCTIONAL DESCRIPTION: DELETE EXECUTES AS THE RESULT OF A KERNEL
;	AST INITIATED BY THE DELETE PROCESS SYSTEM SERVICE.  IT PERFORMS
;	THE ACTIONS NECESSARY TO DELETE A PROCESS AND RETURN ITS RESOURCES.
;	TERMINATION MESSAGES ARE SENT TO THE TERMINATION MAILBOX UNIT
;	SPECIFIED WHEN THE PROCESS WAS CREATED AND TO THE SYMBIONT
;	MANAGER IF ACCOUNTING IS NOT DISABLED FOR THIS PROCESS.
;
; CALLING SEQUENCE:
;	(SAME EFFECT AS) DCLAST ASTADR=DELETE MODE=KERNEL
;
; INPUT PARAMETERS:
;	NONE
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT INPUTS:
;	PCB OF CURRENT PROCESS (LOCATED VIA SCH$GL_CURPCB)
;	PHD OF CURRENT PROCESS
;
; IMPLICIT OUTPUTS:
;	NONE
;
; SIDE EFFECTS:
;	NONE
;--

DELETE:					; PERFORM DELETE OPERATIONS
	.WORD	0			; ENTRY MASK
	MOVL	G^SCH$GL_CURPCB, R4	; GET PCB ADDRESS
	BICB2	#1, PCB$B_ASTACT(R4)	; CLEAR KERNEL AST ACTIVE
	JSB	L^SCH$NEWLVL		; COMPUTE NEW AST LEVEL
4$:	SETIPL	8$			; RAISE TO SYNCH FOR DPC CHECK
	TSTB	PCB$B_DPC(R4)		; IS DPC NON-ZERO?
	BEQL	7$			; EQL THEN DELETION IS ALLOWED
	PUSHL	#0			; KERNEL MODE, IPL 0 PSL FOR RWAIT
	MOVL	#RSN$_ASTWAIT, R0	; NOTE AST RESOURCE
	JSB	L^SCH$RWAIT		; WAIT FOR AST
	BRB	4$			; MAKE THE TEST AGAIN
7$:	SETIPL	#0			; AND DROP IPL
	BBCC	#PCB$V_SSRWAIT,PCB$L_STS(R4),10$	; ENABLE RESOURCE WAIT
	BRB	10$
8$:	.LONG	IPL$_SYNCH		; MAKE SURE CODE DOESN'T PAGE AT SYNCH
	ASSUME	.-4$ LE 512		; IF NOT TRUE, IPL PAGE FAULT HACK NG
10$:					;
;-------------------------------------------------------------
;
;	INVOKE THE USER RUNDOWN SERVICE(S)
;
;	The user service is invoked in KERNEL mode with a JSB and must
;	exit with a RSB.
;
;	R4 - Pointer to current PCB
;	R7 - Acess mode of call to rundown routine (always 0)
;	ACMODE(AP) - always 0
;
;	The above parameters are the same as in the call from SYSRUNDWN.
;
;-------------------------------------------------------------

	CLRL	R7			; KERNEL MODE RUNDOWN
	PUSHL	AP
	CLRL	-(SP)			; ANOTHER KERNEL MODE ACCESS PARAMETER
	PUSHL	#1
	MOVL	SP,AP
	MOVL	@#CTL$GL_USRUNDWN, R5	; GET PER-PROCESS USER RUNDOWN VECTOR
	BEQL	15$			; NOT PRESENT, SKIP ON
	JSB	(R5)			; CALL THRU THE VECTOR(S)
15$:	MOVL	G^EXE$GL_USRUNDWN, R5	; GET SYSTEM-WIDE USER RUNDOWN VECTOR
	BEQL	18$			; NOT PRESENT, SKIP ON
	JSB	(R5)			; CALL THRU THE VECTOR(S)
18$:	ADDL	#8,SP			; CLEAN UP
	MOVL	(SP)+,AP
	JSB	L^EXE$RESETVEC		; RESET THE PRIVILEGED LIBRARY VECTORS

;--------------------------------------------------------------
;
;	RMS RUNDOWN
;
;--------------------------------------------------------------

	MOVAB	-136(SP),SP		; ALLOCATE STRING BUFFER
20$:	MOVZBL	#128,(SP)		; SET COUNT FOR STRING BUFFER
	MOVAL	8(SP),4(SP)		; FORM ADDRESS PART OF DESCRIPTOR
	PUSHL	#2			; LAST CHANCE RMS CLEANUP
	PUSHAB	4(SP)			; SET ADDRESS OF STRING BUFFER	
	CALLS	#2,@#SYS$RMSRUNDWN	; DEFAULT CLOSE OF OPEN RMS FILES
	BLBC	R0,20$			; REPEAT IF MORE TO CLOSE

;--------------------------------------------------------------------
;
;	FIND AND DELETE ALL SUB-PROCESSES
;
;--------------------------------------------------------------------

SUBDELETE:				; DELETE SUB-PROCESSES
	TSTW	PCB$W_PRCCNT(R4)	; ANY SUB-PROCESSES?
	BEQL	50$			; NO, CONTINUE
	MOVZWL	SCH$GL_MAXPIX,R6	; INITIALIZE INDEX FOR PROCESS SCAN
10$:	MOVL	@L^SCH$GL_PCBVEC[R6],R3	; GET A PCB ADDRESS
	CMPL	PCB$L_PID(R4),PCB$L_OWNER(R3)	; DO WE OWN IT
	BNEQ	20$			; NO, TRY ANOTHER
	$DELPRC_S	PCB$L_EPID(R3)	; MARK IT FOR DELETE USING THE EXTENDED PID
20$:	SOBGTR	R6,10$			; CONTINUE
30$:	MOVPSL	-(SP)			; SAVE PSL
	DSBINT	W^SUBWIPL,R6		; BLOCK SYSTEM EVENTS, SAVE IPL IN R6
	TSTW	PCB$W_PRCCNT(R4)	; CHECK COUNT OF SUB-PROCESSES STILL RUNNING
	BEQL	40$			; DONE
	MOVZWL	#RSN$_ASTWAIT,R0	; SET RESOURCE NUMBER
	JSB	L^SCH$RWAIT		; AND WAIT FOR AN AST
	BRB	30$			; CHECK AGAIN WHEN AWAKENED
40$:	SETIPL	R6			; RESTORE IPL
50$:					; DONE, ALL SUB-PROCESSES DELETED
	BRB	RUNDWN			; CONTINUE WITH RUNDOWN
SUBWIPL:				;
	.LONG	IPL$_SYNCH		; MARKER FOR END OF TEMP NON-PAGED

;---------------------------------------------------------------------
;
;	RUNDOWN PROCESS ACTIVITY
;
;---------------------------------------------------------------------

RUNDWN:					; RUNDOWN PROCESS ACTIVITY
	PUSHL	#0			; SET MODE FOR RUNDOWN
	CALLS	#1,SYS$RUNDWN		; RUNDOWN AT KERNEL MODE
	MOVL	@#CTL$GL_PHD,R5		; GET PROCESS HEADER ADDRESS
	ADDL3	PHD$L_PSTBASOFF(R5),R5,R2 ; GET ADDRESS OF SECTION TABLE
	CLRL	-(SP)			; ASSUME NO PAGES WILL BE DELETED
	SUBL	#16,SP			; SAVE ROOM FOR INRANGE AND RETRANGE
	MOVL	SP,R3			; REMEMBER SCRATCH AREA ADDRESS
	CVTWL	PHD$W_PSTLAST(R5),R6	; GET INDEX TO LAST SEC TBL ENTRY USED
	BRB	8$			; JOIN COMMON LOOP
4$:	TSTL	SEC$L_REFCNT(R2)[R6]	; ANY PAGES MAPPED?
	BLSS	6$			; BR IF NOTHING MAPPED TO THIS SECTION
;
; DO A $DELTVA FOR THIS SECTION.
;
	MOVAL	(R2)[R6],R7		; ADDRESS OF SECTION TABLE ENTRY
	EXTZV	#SEC$V_VPX,#SEC$S_VPX,SEC$L_VPXPFC(R7),4(R3) ; GET START VPN
	CMPZV	#PHD$V_P0LR,#PHD$S_P0LR,PHD$L_P0LRASTL(R5),4(R3) ; IS VA IN P0?
	BGTRU	5$			; BR IF IT IS IN P0 SPACE
	ROTL	#7,SGN$GL_PTPAGCNT,R0	; GET LONGWD OFFSET FROM BEGIN OF PAGTBL
	SUBL	R0,4(R3)		; GET VPN IN P1 SPACE
	EXTZV	#SEC$V_VPX,#SEC$S_VPX,4(R3),4(R3) ; MASK OFF SIGN BITS
5$:	ASHL	#9,4(R3),4(R3)		; GET VA OF FIRST PAGE MAPPED
	ASHL	#9,SEC$L_PAGCNT(R7),(R3) ; GET # OF BYTES IN SECTION
	ADDL2	4(R3),(R3)		; GET VA OF LAST PAGE MAPPED
	DECL	(R3)			; GET ADR OF LAST BYTE MAPPED
	$DELTVA_S	(R3),8(R3)	; DELETE PAGES FOR THIS SECTION
	CMPL	#-1,8(R3)		; WERE ANY PAGES DELETED?
	BEQL	6$			; BR IF NONE DELETED
	MOVL	#1,16(R3)		; INDICATE SECOND RUNDWN REQUIRED
6$:	ADDL2	#SEC$C_LENGTH@-2,R6	; GET OFFSET TO NEXT SECTION TABLE ENTRY
8$:	BLSS	4$			; GO CHECK NEXT SECTION
	ADDL	#16,SP			; CLEAN INRANGE AND RETRANGE OFF STACK
	TSTL	(SP)+			; WERE ANY PAGES DELETED?
	BEQL	55$			; NO, THEN DON'T BOTHER WITH 2ND RUNDWN
	PUSHL	#0			; SET MODE FOR RUNDOWN
	CALLS	#1,SYS$RUNDWN		; RUNDOWN AT KERNEL MODE

;********************************************************************
;
; SCAN THE CHANNEL TABLE AND LOOK FOR ASSIGNED
; CHANNELS. THERE SHOULD BE NONE.
;
;********************************************************************

10$:	MOVZWL	@#CTL$GW_CHINDX,R5	; GET MAXIMUM INDEX + 16
	BEQL	55$			; NO CHANNEL TABLE
	MNEGL	R5,R5			; CONVERT TO NEGATIVE OFFSET
	ADDL3	#CCB$B_AMOD, -
		@#CTL$GL_CCBBASE,R3	; COMPUTE ADDRESS OF HIGHEST CHANNEL
40$:	TSTB	(R3)[R5]		; IS THIS CHANNEL STILL ASSIGNED?
	BLEQ	50$			; BRANCH IF NOT.

;
; A NEGATIVE ACCESS MODE IN THE CCB IS USED TO RESERVE THE CHANNEL
; FOR USE BY THE F11BXQP TO PERFORM LOGICAL I/O ON BEHALF OF VIRTUAL
; I/O FUNCTIONS THAT IT PROCESSES (THE XQP MODIFIES THE CCB$L_UCB AND
; CCB$B_AMOD FIELDS PRIOR TO ACTUALLY USING IT).  THE CHANNEL DOES NOT
; HAVE TO BE DEASSIGNED BECAUSE NO DEVICE REFERENCE COUNTS REFLECT ITS
; EXISTENCE.
;

	BUG_CHECK FILCNTNONZ,FATAL	; IT REALLY SHOULD HAVE WORKED

50$:	ADDL2	#CCB$C_LENGTH,R5	; NEXT CHANNEL
	BLSS	40$			; LOOP THRU
55$:

;********************************************************************
; END OF BUG TRAP
;********************************************************************
;
;	DISMOUNT ALL MOUNTED VOLUMES
;
	TSTL	PCB$L_OWNER(R4)		; IS THIS A SUB-PROCESS ?
	BNEQ	20$			; IF NEQ YES, SKIP IOC$DISMOUNT
	MOVL	PCB$L_JIB(R4),R6	; GET JIB ADDRESS
	JSB	L^SCH$IOLOCKW		; LOCK I/O DATABASE
	REMQUE	@JIB$L_MTLFL(R6),R6	; GET A VOLUME TO BE DISMOUNTED
	BVS	15$			; NONE, FINISHED WITH DISMOUNT LIST
	JSB	L^SCH$IOUNLOCK		; UNLOCK I/O DATABASE
	SETIPL	#0			; DROP IPL
	CLRL	R3			; UNLOAD UPON DISMOUNT
	BSBW	IOC$DISMOUNT		; DISMOUNT IT
	BRB	10$			; AND TRY FOR ANOTHER
15$:					; REF LABEL
	JSB	L^SCH$IOUNLOCK		; UNLOCK I/O DATABASE
	SETIPL	#0			; DROP IPL
20$:					;
	$DALLOC_S	ACMODE=#0	; DEALLOCATE ALL
	CMPW	PCB$W_DIOCNT(R4),PCB$W_DIOLM(R4) ; WAIT FOR DIRECT I/O COMPLETION
	BNEQ	20$			;
30$:	CMPW	PCB$W_BIOCNT(R4),PCB$W_BIOLM(R4) ; AND BUFFERED I/O
	BNEQ	30$			;

;____________________________________________________________________
;
;	DECREMENT INTERACTIVE AND BATCH JOB COUNT WHEN APPROPRIATE
;
;--------------------------------------------------------------------

	TSTL	PCB$L_OWNER(R4)
	BNEQ	RELQUOTA		; WE DON'T DO IT FOR A SUBPROCESS
	BBC	#PCB$V_INTER,PCB$L_STS(R4),59$ ; NOT INTERACTIVE
	DECW	SYS$GW_IJOBCNT		; ONE LESS INTERACTIVE JOB
	BRB	DELETE_JT
59$:	BBC	#PCB$V_BATCH,-		; NOT BATCH JOB
		PCB$L_STS(R4),DELETE_JT
	DECW	SYS$GW_BJOBCNT		; ONE LESS BATCH JOB

;---------------------------------------------------------------------
;
;	DELETE THE JOB-WIDE LOGICAL NAME TABLE IF THE PROCESS 
;	IS NOT A SUB-PROCESS
;
;---------------------------------------------------------------------

DELETE_JT:				; DELETE THE JOB-WIDE LOGICAL NAME TABLE
	MOVAB	-JOB_STRING_LEN(SP),SP	; MAKE ROOM ON STACK FOR TABLE NAME 
	PUSHAB	(SP)			; CONSTRUCT A DESCRIPTOR OF THE BUFFER
	PUSHL	#JOB_STRING_LEN		; WHICH IS TO CONTAIN THE TABLE NAME
	MOVL	SP,R3			; SAVE THE ADDRESS OF THE DESCRIPTOR

	$FAO_S	-			; CONSTRUCT THE JOB-WIDE TABLE NAME
		CTRSTR  = JOB_FAO, -
		OUTBUF  = (R3), -
		P1	= PCB$L_JIB(R4)

	$DELLNM_S	-		; DELETE THE JOB-WIDE LOGICAL NAME TABLE
		LOGNAM	= (R3), -
		TABNAM	= LNM_SYSTEM_DIRECTORY_DESC
	ADDL2	#JOB_STRING_LEN+8,SP	; RESTORE THE STACK

;--------------------------------------------------------------------
;
;	SEND REMAINING QUOTAS TO OWNER IF SUB-PROCESS
;
;--------------------------------------------------------------------
RELQUOTA:				; RELEASE QUOTAS
	CLRB	PCB$T_LNAME(R4)		; REMOVE PROCESS NAME
	MOVL	PCB$L_OWNER(R4),R6	; GET PID OF OWNER
	BEQL	MESSAGES		; IF EQL, NOT A SUBPROCESS
	PUSHL	R4			; SAVE PCB ADDRESS
	MOVZWL	R6,R6			; EXTRACT PIX FROM OWNER PID
	MOVL	@L^SCH$GL_PCBVEC[R6],R4	; AND GET PCB
	JSB	L^EXE$ALLOCIRP		; ALLOCATE AST CONTROL BLOCK
	BLBC	R0,20$			; SKIP QUOTA RETURN IF ERROR
	MOVL	R2,R5			; SET ADDRESS OF QUOTA AST BLOCK
	MOVAB	W^RETQUOTA,ACB$L_KAST(R5)	; SET AST ADDRESS FOR SPECIAL
					; KERNEL AST TO RETURN QUOTAS
	MOVB	#<1@ACB$V_KAST>,ACB$B_RMOD(R5)	; FLAG AS SPECIAL KERNEL AST
	MOVL	PCB$L_PID(R4),ACB$L_PID(R5)	; SET TARGET PID FOR AST
	MOVL	(SP),R2			; GET PCB ADDRESS FOR PROCESS BEING DELETED
	MOVL	@#CTL$GL_PHD,R1		; GET PROCESS HEADER ADDRESS
	SUBL3	PHD$L_EXTRACPU(R1),PHD$L_CPULIM(R1),ACB_L_CPULIM(R5)
					; SAVE CPULIMIT LESS BONUS
	MOVL	PHD$L_CPUTIM(R1),ACB_L_CPUTIM(R5)
					;  AND ACCUMULATED CPU TIME
	MOVZWL	#PRI$_RESAVL,R2		; SET PRIORITY INCREMENT CLASS
	JSB	L^SCH$QAST		; QUEUE AST FOR CREATOR
20$:	POPR	#^M<R4>			; RESTORE PCB ADDRESS
	SETIPL	#0			; DROP IPL TO ISSUE SYSTEM SERVICE REQUESTS

;--------------------------------------------------------------------
;
;	TERMINATION MESSAGES
;
;--------------------------------------------------------------------
MESSAGES:				; SEND TERMINATION MESSAGES
	TSTW	PCB$W_TMBU(R4)		; TERMINATION MAILBOX SPECIFIED ?
	BEQL	10$			; IF EQL, NO
	BSBW	TERMMSG			; SEND MESSAGE TO TERMINATION MAILBOX
10$:					; SEND MESSAGE TO JOB CONTROLLER
	BBC	#PCB$V_BATCH,PCB$L_STS(R4),20$	; IF BC, NOT A BATCH JOB
	BBCC	#PCB$V_SSRWAIT,PCB$L_STS(R4),20$; ENABLE RESOURCE WAIT MODE
20$:	
	CLRL	R5			; NOT A SPECIAL KERNEL AST ROUTINE
	JSB	EXE$PRCDELMSG		; SEND PROCESS DELETE MESSAGE

;---------------------------------------------------------------------
;
;	DESTROY PROCESS
;
;---------------------------------------------------------------------

	.ENABLE	LSB

DESTROY:				;
	SETIPL	#IPL$_ASTDEL		; NO MORE ASTS AFTER THIS POINT
	SUBL	#16,SP			; 4 LONGWORDS OF STORAGE
	MOVL	SP,R2			; SAVE BASE
	MOVL	#<1@30>,(R2)		; SET STARTVA
	MOVL	#<<1@31>-1>,4(R2)	; END AT VECTOR PAGE
; WE CAN'T USE THE MACRO SINCE THE P1 VECTORS WILL DISAPPEAR
;	$DELTVA_S	(R2),8(R2)	; DELETE FROM KERNEL STACK TO VECTORS
	PUSHL	#0
	PUSHAQ	8(R2)
	PUSHAQ	(R2)
	CALLS	#3,SYS$DELTVA-P1SYSVECTORS+^X80000000 ; DELETE KSTK TO VECTORS
					; ENTER & EXIT DELTVA AT IPL(ASTDEL)
	SETIPL	W^DESTROY_SYNCH		; BLOCK SYSTEM EVENTS
					; AND LOCK PAGABLE CODE
	SVPCTX				; SAVE PROCESS CONTEXT
					; AND GO TO INTERRUPT STACK
	MOVL	PCB$L_PHD(R4),R5	; GET PROCESS HEADER ADDRESS
	MOVZWL	PHD$W_PHVINDEX(R5),R10	; GET BALANCE SLOT INDEX
	MOVAB	L^SCH$GL_NULLPCB,R3	; GET POINT TO NULL PROCESS PCB
	MOVL	R3,L^SCH$GL_CURPCB	; SET AS CURRENT PCB
	MOVZWL	@L^PHV$GL_PIXBAS[R10],R1 ; GET PROCESS INDEX
	MOVL	R3,@L^SCH$GL_PCBVEC[R1]	; RELEASE PROCESS INDEX SLOT
	MOVZWL	PHD$W_WSLOCK(R5),R9	; POINT TO FIRST NON PERM PAGE
	CLRL	(R5)[R9]		; MARK WITH A ZERO
	MOVZWL	PHD$W_WSLIST(R5),R8	; LONGWORD INDEX TO START OF WORKING SET LIST
	MOVAL	(R5)[R8],R8		; FORM BYTE ADDRESS OF START OF WSLIST
40$:	MOVL	(R8)+,R2		; GET VA OF PERM PAGE
	BEQL	60$			; DONE, NONE LEFT
	BLBC	R2,40$			; IGNORE IF NOT VALID
	BLSS	40$			; OR IF HEADER PAGES (SYSTEM ADDRESS)
	BSBW	DELPAGE			; DELETE PAGE
	BRB	40$			; CONTINUE

60$:	REMQUE	@PCB$L_ASTQFL(R4),R0	; REMOVE PENDING AST CONTROL BLOCKS
	BVS	70$			; NONE LEFT
	BBS	#ACB$V_NODELETE,-	; BR. IF NODELETE BIT IS SET.  THIS
		ACB$B_RMOD(R0),60$	; SHOULD NOT HAPPEN BUT IF IT DOES MAY
					; RESULT IN LOSING POOL (WHICH IS 
					; PREFERABLE OVER A DOUBLE DEALLOCATE).
	BSBB	DEANONPAGED		; DEALLOCATE SPACE FOR ACB
	BRB	60$			; AND CONTINUE

DEANONPAGED:				;
	JMP	L^EXE$DEANONPAGED	; JUMP TO REACH REAL DEANONPAGED

70$:	MOVL	PCB$L_WSSWP(R4),R0	; GET VBN OF AREA TO FREE IN SWAPFILE
	BEQL	80$			; NONE, CONTINUE
	MOVZWL	PHD$W_SWAPSIZE(R5),R1	; SIZE OF AREA TO FREE
	EXTZV	#24,#8,R0,R3		; SET SWAP FILE NUMBER
	EXTZV	#0,#24,R0,R0		; GET VBN OF AREA
	MOVL	@L^MMG$GL_PAGSWPVC[R3],R3 ; GET ADDRESS OF PFL CONTROL BLOCK
	JSB	L^MMG$DEALLOCPAGFIL	; DEALLOCATE AREA
80$:	MOVL	PCB$Q_PRIV+ARB$L_RIGHTSLIST+8(R4),R0 ; GET EXTENDED RIGHTS LIST
	BEQL	85$			; BRANCH IF NONE
	BSBB	DEANONPAGED		; DEALLOCATE IT
85$:	MOVL	PCB$L_JIB(R4),R0	; GET ADDRESS OF JIB FOR RELEASE
	BEQL	90$			; BR IF NONE
	DECW	JIB$W_PRCCNT(R0)	; ONE LESS PROCESS IN THIS TREE
	CMPL	PCB$L_PID(R4),JIB$L_MPID(R0) ; IS THIS THE MASTER PROCESS?
	BNEQ	90$			; BR IF NOT
	BSBB	DEANONPAGED		; DEALLOCATE JIB
90$:	MOVZWL	PCB$L_OWNER(R4),R0	; GET PIX FROM OWNER UIC
	BEQL	100$			; BR IF NOT A SUB-PROCESS
	MOVL	@L^SCH$GL_PCBVEC[R0],R0	; GET ADDRESS OF OWNER PCB
	DECW	PCB$W_PRCCNT(R0)	; DECREMENT COUNT OF SUB-PROCESSES
	MOVL	#RSN$_ASTWAIT,R0	; NOTIFY PARENT PROCESS THAT ITS
	JSB	L^SCH$RAVAIL		;  SUBPROCESS COUNT HAS BEEN DECREMENTED
100$:	MOVL	R4,R0			; SET ADDRESS OF PCB FOR RELEASE
	BSBB	DEANONPAGED		; AND DELETE IT
	DECW	L^SWP$GW_BALCNT		; DECREASE COUNT IN BALANCE SET
	JSB	L^SCH$SWPWAKE		; WAKE SWAPPER
	MCOMW	#0,@L^PHV$GL_PIXBAS[R10] ; INDICATE PROCESS HEADER TO BE DELETED
	INCW	L^SCH$GW_DELPHDCT	; FLAG SWAPPER'S ATTENTION
	DECW	L^SCH$GW_PROCCNT	; ONE LESS PROCESS NOW
	JMP	L^SCH$SCHED		; AND SCHEDULE FOR ANOTHER PROCESS

	.DISABLE LSB
	.PAGE
	.SBTTL	DELPAGE - DELETE PAGE
;++
; FUNCTIONAL DESCRIPTION:
;	DELPAGE DELETES THE CONTENTS OF THE SPECIFIED PAGE AND PLACES
;	 THE PFN ON THE FREE PAGE LIST.
;
; CALLING SEQUENCE:
;	BSB	DELPAGE
;
; INPUT PARAMETERS:
;	R2 - VIRTUAL ADDRESS OF PAGE TO RELEASE
;	R4 - PCB ADDRESS OF PROCESS OWNING PAGE
;	R5 - PROCESS HEADER ADDRESS OF PROCESS OWNING PAGE
;
; OUTPUT PARAMETERS:
; 	NONE
;
;--

DELPAGE:				; DELETE PAGE
	JSB	MMG$SVAPTECHK		; GET SVA OF PTE FOR PAGE
	BBCC	#PTE$V_VALID,(R3),50$	; EXIT IF NOT VALID
	BBCC	#PTE$V_MODIFY,(R3),10$	; CLEAR MODIFY INDICATOR
10$:	EXTZV	#0,#PTE$S_PFN,(R3),R0	; GET PFN FROM PTE
	DECREF	,,,L^,,JSB		; DROP REFERENCE COUNT ON PAGE
	BGTR	50$			; BR IF CANT RELEASE YET
	BICB	#PFN$M_MODIFY,@L^PFN$AB_STATE[R0] ; MAKE SURE NO MODIFY BIT
20$:	JSB	MMG$DELCONPFN		; DELETE CONTENT OF PFN
	ASSUME	PFN$C_FREPAGLST EQ 0	;
	CLRL	R2			; INDICATE FREE LIST
	JSB	MMG$INSPFNH		; INSERT AT HEAD OF FREE LIST
50$:	RSB				;

DESTROY_SYNCH:				; END OF NONPAGABLE AREA
	.LONG	IPL$_SYNCH		; SYNCHRONIZATION IPL TO BLOCK SYSTEM EVENTS
	.PAGE
	.SBTTL	TERMMBX - SEND MESSAGE TO TERMINATION MAILBOX

;---------------------------------------------------------------------
;
;	BUILD PROCESS TERMINATION MESSAGE AND SEND TO TERMINATION 
;	MAILBOX UNIT.
;
;---------------------------------------------------------------------

TERMMSG:				; SEND TERMINATION MESSAGES
	MOVL	SP,R10			; SAVE STACK STATE
	PUSHL	PCB$L_EOWNER(R4)	; SEND EXTENDED PID OF SUBPROCESS OWNER (0 => NONE)
	MOVL	@#CTL$GL_PHD,R5		; GET PROCESS HEADER ADDRESS
	MOVQ	@#CTL$GQ_LOGIN,-(SP)	; LOGIN TIME
	ASSUME	ACC$L_OWNER EQ ACC$Q_LOGIN+8
	PUSHL	@#CTL$GL_VOLUMES	; COUNT OF MOUNTED VOLUMES
	ASSUME	ACC$Q_LOGIN EQ ACC$L_VOLUMES+4
	PUSHL	PHD$L_DIOCNT(R5)	; DIRECT I/O COUNT
	ASSUME	ACC$L_VOLUMES EQ ACC$L_DIOCNT+4
	PUSHL	PHD$L_BIOCNT(R5)	; BUFFERED I/O COUNT
	ASSUME	ACC$L_DIOCNT EQ ACC$L_BIOCNT+4
	PUSHL	@#CTL$GL_WSPEAK		; PEAK WORKING SET SIZE
	ASSUME	ACC$L_BIOCNT EQ ACC$L_WSPEAK+4
	PUSHL	#0			; PEAK PAGING FILE USAGE
	ASSUME	ACC$L_WSPEAK EQ ACC$L_PGFLPEAK+4
	PUSHL	PHD$L_PAGEFLTS(R5)	; TOTAL PROCESS PAGE FAULTS
	ASSUME	ACC$L_PGFLPEAK EQ ACC$L_PAGEFLTS+4
	PUSHL	PHD$L_CPUTIM(R5)	; SAVE ACCUMULATED CPU TIME FOR PROCESS
	ASSUME	ACC$L_PAGEFLTS EQ ACC$L_CPUTIM+4
	MOVAB	@#CTL$T_USERNAME+12,R0	; GET BASE ADDRESS
	MOVQ	-(R0),-(SP)		; LAST HALF OF USER NAME
	PUSHL	-(R0)			; FIRST LONGWORD OF USER NAME
	MOVAB	W^<CTL$T_ACCOUNT-CTL$T_USERNAME>(R0),R0 ; POINT PAST ACCOUNT
	ASSUME	ACC$L_CPUTIM EQ ACC$T_USERNAME+12
	MOVQ	(R0),-(SP)		; SET ACCOUNT INTO RECORD
	ASSUME	ACC$T_USERNAME EQ ACC$T_ACCOUNT+8
	MOVQ	EXE$GQ_SYSTIME,-(SP)	; LOGOUT TIME
	ASSUME	ACC$T_ACCOUNT EQ ACC$Q_TERMTIME+8
	PUSHL	#0			; JOBID
	ASSUME	ACC$Q_TERMTIME EQ ACC$L_JOBID+4
	PUSHL	PCB$L_EPID(R4)		; EXTENDED PROCESS ID
	ASSUME	ACC$L_JOBID EQ ACC$L_PID+4	
	PUSHL	@#CTL$GL_FINALSTS	; FINAL STATUS OF PROCESS
	ASSUME	ACC$L_PID EQ ACC$L_FINALSTS+4
	PUSHL	#MSG$_DELPROC		; MESSAGE TYPE
	ASSUME	ACC$L_FINALSTS EQ ACC$W_MSGTYP+4
	MOVL	SP,R7			; MESSAGE ADDRESS
	MOVZWL	PCB$W_TMBU(R4),R0	; TERMINATION MAILBOX UNIT
	MOVQ	#^A/MB00000:/,-(SP)	; SKELETON FOR DEVICE STRING
	CLRL	R1			; INIT FOR EDIV
	MOVAB	7(SP),R3		; POINTER TO LSD OF DEVICE NAME
10$:	EDIV	#10,R0,R0,R2		; CONVERT A DECIMAL DIGIT
	ADDB	R2,-(R3)		; SET DIGIT INTO NAME STRING IN ASCII
	TSTL	R0			; CHECK FOR END
	BNEQ	10$			; NOT YET, CONVERT ANOTHER DIGIT
	PUSHL	SP			; BUILD STRING DESCRIPTOR FOR 
	PUSHL	#8			; MAILBOX NAME
	MOVL	SP,R8			; AND SAVE POINTER TO NAME DESCRIPTOR
	MOVAL	-(SP),R9		; RESERVE SPACE FOR CHANNEL
;
; CHECK FOR PRESENCE OF CHANNEL TABLE, IF NON-EXISTENT (I.E. PROCESS DELETED
; BEFORE THE CREATION OF IT) USE A PAGE OF SUPERVISOR STACK FOR IT.
;
	TSTW	@#CTL$GW_NMIOCH		; IS THERE A VALID CHANNEL TABLE?
	BNEQ	20$			; YES, SKIP TO ASSIGN
	PUSHL	R4			; SAVE PCB ADDRESS
	MOVL	@#CTL$AL_STACK+<4*PSL$C_SUPER>,R3	; PICK UP SUPER SP
	MOVAB	-CCB$C_LENGTH(R3),-
		@#CTL$GL_CCBBASE	; MAKE IT TABLE BASE
	MOVC5	#0,(SP),#0,#512,-512(R3); CLEAR IT OUT
	POPL	R4			; RESTORE PCB ADDRESS
	MOVZWL	#<512/CCB$C_LENGTH>-1,-	; SET NUMBER OF CHANNELS
		@#CTL$GW_NMIOCH
;
; ASSIGN CHANNEL TO MAILBOX AND WRITE THE MESSAGE
;
20$:
	$ASSIGN_S	DEVNAM=(R8),-	; ATTEMPT TO ASSIGN CHANNEL TO
			CHAN=(R9)	; MAILBOX
	BLBC	R0,30$			; UNABLE TO ASSIGN, IGNORE
	$QIO_S		CHAN=(R9),-	; SEND TERMINATION MESSAGE
			FUNC=#<IO$_WRITEVBLK!IO$M_NOW>,-
			P1=(R7),-	; MESSAGE ADDRESS
			P2=#ACC$C_TERMLEN; MESSAGE SIZE
30$:
	$DASSGN_S	CHAN=(R9)	; DEASSIGN CHANNEL
	MOVL	R10,SP			; RESTORE STACK STATE
	RSB

	.PAGE
	.SUBTITLE	Return Unused CPU Time Limit to Parent

;+
; Functional Description:
;
;	RETQUOTA is entered via a special kernel AST directed to the
;	creator of a subprocess.  The AST control block contains the
;	unused CPU time limit to be returned to the creator.
;
;	The CPU limit of the parent has any unused CPU time from the 
;	subprocess added to it. 
;
; Input Parameters:
;
;	R4 	PCB Address of Current (Parent) Process
;	R5 	Pointer to AST Control Block
;
;	ACB_L_CPULIM(R5)	Original CPU Limit of Subprocess
;	ACB_L_CPUTIM(R5)	CPU Time Used by Subprocess	
;
; Output Parameter:
;
;	PHD$L_CPULIM(R1)	The CPU limit of the parent is adjusted
;				according to the following rules.
;
;	If the subprocess has unused CPU time limit (a credit) , 
;	that credit is added to the parent's CPU limit.
;
;	If the subprocess exceeded its CPU time allotment, an attempt
;	is made to pass the deficit to the parent. 
;
;		If the deficit is smaller than the parent's CPU limit, the
;		deficit is simply subtracted from CPU limit. 
;
;		If the deficit is larger than the parent's CPU limit, the
;		parent is forced into the CPU time expiration path by
;		loading its CPUTIM into its CPULIM field, indicating
;		that its CPU time limit has expired. (Note that loading CPULIM 
;		into CPUTIM has the same effect but causes double accounting 
;		for the CPU time already charged to the subprocess.)
;
; Side Effects:
;
;	The AST control block is released to nonpaged pool.
;
; Environment:
;
;	IPL$_ASTDEL while carrying pointer to AST control block.
;-

RETQUOTA:
	MOVL	@#CTL$GL_PHD,R1		; Get safe pointer to process header
	TSTL	PHD$L_CPULIM(R1)	; Check for no quota
	BEQL	20$			; Skip return if no quota
	SUBL3	ACB_L_CPUTIM(R5),ACB_L_CPULIM(R5),R0 ; Get difference
	BGEQU	10$			; Excess or deficit (Branch if excess)
	MNEGL	R0,-(SP)		; Handle deficit very carefully
	CMPL	(SP)+,PHD$L_CPULIM(R1)	; Can creator accommodate deficit?
	BLSSU	10$			; Branch if yes
	MOVL	PHD$L_CPUTIM(R1),PHD$L_CPULIM(R1) ; Otherwise, force CPU time 
					;  expiration by setting limit to time
	BRB	20$			; Deallocate AST control block

10$:	ADDL2	R0,PHD$L_CPULIM(R1)	; Give back excess 
20$:	MOVL	R5,R0			; Get address for release
	JMP	G^EXE$DEANONPAGED	; Return via EXE$DEANONPAGED

	.END
