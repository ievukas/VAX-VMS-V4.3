MODULE shodevprt (IDENT = 'V04-000',
		  ADDRESSING_MODE (EXTERNAL = GENERAL)) =

BEGIN
!
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
!
!++
!
! FACILITY:  SHOW utility
!
! ABSTRACT:
!	This module contains the display routines for the SHOW commands which
!	deal with devices, i.e. SHOW DEVICES, SHOW MAGTAPE,
!	and SHOW PRINTER.  
!
! ENVIRONMENT:
!	VAX native, user mode.
!
! AUTHOR:  Gerry Smith		 CREATION DATE:  28-Jul-1982
!
! MODIFIED BY:
!
!	V03-023	CWH3023		CW Hobbs		8-Aug-1984
!		If extent caches are disabled, display zeroes in all three
!		fields, rather than displaying max blocks as the number it
!		would be if caches were enabled.
!
!	V03-022	CWH3022		CW Hobbs		24-Jul-1984
!		Add ACL support, a few more fields, expand bit explanations
!		to be more sentence-like.  Change ADD_TO_LIST to use a
!		routine which performs better breaking.
!
!	V03-021	CWH3021		CW Hobbs		14-Apr-1984
!		Add a couple of display items for printers.
!
!	V03-020	CWH3020		CW Hobbs		14-Apr-1984
!		Finish up the cluster display, and rework all full displays
!		to improve their appearance and readability (thanks to
!		Greg Robert for the suggestion for new style).
!
!	V03-019	CWH3019		CW Hobbs		13-Mar-1984
!		When displaying status, look at the MNTVERIP before
!		looking at the VALID bit.  The VALID bit can be in
!		either state during mount verification.  Add feature
!		to scan cluster lock database (INCOMPLETE!).
!
!	V03-018 CWH3018		CW Hobbs		3-Mar-1984
!		Some changes to print allocation class device names.
!		Also simplified brief display by removing two-thirds
!		of the FAO control strings.
!
!	V03-017 CWH3017		CW Hobbs		28-FEB-1984
!		Add more info to dual-path displays, and reduce the
!		amount of noise in the brief display.  Add device
!		types for uVAX disks and other new devices.
!
!	V03-016 EMD0049		Ellen M. Dusseault	27-FEB-1984
!		Add ability to display fallback characteristic of
!		a printer in routine, display_printer.		
!
!	V03-015	JLV0330		Jake VanNoy		27-FEB-1984
!		Add 'disconnected' to virtual terminal display.
!
! 	V03-014 GJA0060 	Greg Awdziewicz, 	4-Jan-1984  8:24 
! 		- Add journal specific flags to the full journal device 
! 		display. 
! 		- Add the DeaDmo (Deallocate upon dismount) bit to both the 
! 		full and the brief journal device displays. 
! 
!	V03-013	LMP0165		L. Mark Pilant,		11-Oct-1983  9:00
!		Make the brief dual port display more readable (and less
!		confusing).
!
!	V03-012	LMP0162		L. Mark Pilant,		6-Oct-1983  15:18
!		Add support for displaying dual ported device names.
!
!	V03-011	GAS0186		Gerry Smith		17-Sep-1983
!		Fix /FULL display of journal name, by extending the
!		length to ucb$s_jnl_nam.
! 
!	V03-010	LMP0140		L. Mark Pilant,		24-Aug-1983  0:35
!		Add support for alphanumeric UICs.
!
!	V03-009	GAS0167		Gerry Smith		22-Aug-1983
!		Fix the processing of the journal devices for journals.
!		
!	V03-008	GAS0149		Gerry Smith		28-Jun-1983
!		Use IOC$CVT_DEVNAM for the device name.
!
!	V03-007	GAS0133		Gerry Smith		16-May-1983
!		Add default extend quantity and file protection, as well
!		as retention periods, for disks.
!
!	V03-006	GAS0120		Gerry Smith		14-Apr-1983
!		Modify the displays slightly for a more tabular format.
!
!	V03-005 GAS0114		Gerry Smith		 1-Apr-1983
!		Fix display to handle long device names.
!
!	V03-004	CWH1002		CW Hobbs		1-Mar-1983
!		Display the extended pid for the owner.
!
!	V03-003	GAS0110		Gerry Smith		28-Feb-1983
!		Add support for cluster devices.
!
!	V03-002	GAS0107		Gerry Smith		11-Feb-1983
!		Add support for journals.
!
!	V03-001	GAS0105		Gerry Smith		21-Jan-1983
!		Fix the length of the device name field.  Remove the
!		quotation remarks from volume labels.
!
!--

!
! Include files
!
LIBRARY 'SYS$LIBRARY:LIB';		! VAX/VMS system definitions
REQUIRE 'SRC$:SHOWDEF';			! SHOW common definitions
REQUIRE	'SRC$:SHODEVDEF';		! SHOW DEVICES common definitions

!
! Define a shared message code for the read error
!
$SHR_MSGDEF	(SHOW, 120, LOCAL,   (READERR, SEVERE) );

!
! Macro to setup a table of keys and counted ascii strings
!
MACRO
    table_keys  [tag,string] = tag%,

    table_entries  [tag,string] = cstring(%STRING(string))%,

    make_table (name) = 
	LITERAL %NAME(%STRING(name,'_number')) = (%LENGTH-1)/2;
	OWN
	    %NAME(%STRING(name),'_type') : VECTOR[%NAME(name, '_number'),BYTE]
	    INITIAL (BYTE(table_keys(%REMAINING))),
	    %NAME(%STRING(name),'_label') : VECTOR[%NAME(name, '_number')]
	    INITIAL (table_entries(%REMAINING));%;

MACRO
    unknown = cstring('unknown')%;

!
! A macro to add successive ASCII items to a string buffer, and update the 
! descriptor for the string.  Saves lots of typing of %ASCIDs.
!
MACRO
    add_to_list (ptr, string, length) = 	add_to_list_rtn ((ptr), %ASCID string, (length))  %;

!
! Set up tables of specific device types, and the counted ascii string
! describing each type.
!

make_table (printer,
	    dt$_lp11,		LP11,
	    dt$_la11,		LA11,
	    dt$_la180,		LA180);

make_table (tape,
	    dt$_te16,		TE16,		dt$_tu45,		TU45,
	    dt$_tu77,		TU77,		dt$_ts11,		TS11,
	    dt$_tu78,		TU78,		dt$_ta78,		TA78,
	    dt$_tu80,		TU80,		dt$_tu81,		TU81,
	    dt$_ta81,		TA81,		dt$_tk50,		TK50);

make_table (format,
	    mt$k_normal11,	'Normal-11',
	    mt$k_cordmp11,	'Coredump-11',
	    mt$k_normal15,	'Normal-15');

make_table (disk,
	    dt$_rk06,		RK06,		dt$_rk07,		RK07,
	    dt$_rp04,		RP04,		dt$_rp05,		RP05,
	    dt$_rp06,		RP06,		dt$_rm03,		RM03,
	    dt$_rp07,		RP07,		dt$_rp07ht,		RP07,
	    dt$_rl01,		RL01,		dt$_rl02,		RL02,
	    dt$_rx02,		RX02,		dt$_rx04,		RX04,
	    dt$_rm80,		RM80,		dt$_tu58,		TU58,
	    dt$_rm05,		RM05,		dt$_rx01,		RX01,
	    dt$_ml11,		ML11,		dt$_rb02,		RB02,
	    dt$_rb80,		RB80,		dt$_ra80,		RA80,
	    dt$_ra81,		RA81,		dt$_rc25,		'RC25 Removable',
	    dt$_ra60,		RA60,		dt$_rcf25,		'RC25 Fixed',
	    dt$_rd51,		RD51,		dt$_rc26,		'RC26 Removable',
	    dt$_rx50,		RX50,		dt$_rcf26,		'RC26 Fixed',
	    dt$_rd52,		RD52,		dt$_rd53,		RD53,
	    dt$_rd26,		RD26,		dt$_ra82,		RA82,
	    dt$_crx50,		'Console RX50',	dt$_cdr50,		CDR50);

make_table (terminal,
	    tt$_vt05,		vt05,		tt$_ft1,		ft1,
	    tt$_ft2,		ft2,		tt$_ft3,		ft3,
	    tt$_ft4,		ft4,		tt$_ft5,		ft5,
	    tt$_ft6,		ft6,		tt$_ft7,		ft7,
	    tt$_ft8,		ft8,		tt$_lax,		'LAx',
	    tt$_la36,		la36,		tt$_la120,		la120,
	    tt$_vt5x,		'VT5x',		tt$_vt52,		vt52,
	    tt$_vt55,		vt55,		tt$_vt100,		vt100,
	    tt$_vk100,		vk100,		tt$_vt173,		vt173,
	    tt$_la34,		la34,		tt$_la38,		la38,
	    tt$_la12,		la12,		tt$_la24,		la24,
	    tt$_la100,		la100,		tt$_lqp02,		lqp02,
	    tt$_vt101,		vt101,		tt$_vt102,		vt102,
	    tt$_vt105,		vt105,		tt$_vt125,		vt125,
	    tt$_vt131,		vt131,		tt$_vt132,		vt132,
	    tt$_vt200_series,	'VT200 Series',	tt$_pro_series,		'PRO_series',
	    tt$_tq_bts,		bts,		tt$_tek401x,		'TEK401x',
	    tt$_la84,		la84);

make_table (journal,
	    dt$_rujnl,		'recovery-unit journal',
	    dt$_bijnl,		'before-image journal',
	    dt$_aijnl,		'after-image journal',
	    dt$_atjnl,		'audit-trail journal',
	    dt$_cljnl,		'control journal',
	    dt$_unknjnl,	'unknown journal');

!
! Make a table of access modes
!
OWN
    change_acl_addr : INITIAL (0),		! Address of change_acl routine for call by name
    format_acl_addr : INITIAL (0),		! Address of format_acl routine for call by name
    leading_blanks : INITIAL (0),		! Leading blanks for continuation lines
    mode_table : VECTOR[4]
    	INITIAL(cstring('Kernel'),
		cstring('Exec'),
    		cstring('Super'),
		cstring('User'));

BIND
    ascid_null = %ASCID '',
    ascid_secureshr = %ASCID 'SECURESHR';

!
! Table of contents
!
FORWARD ROUTINE
    add_to_list_rtn	: NOVALUE,
    check_mnt_all,
    cluster_nodes	: NOVALUE,
    show_device_acl	: NOVALUE,
    sys$change_acl,			! Jacket routines for call-by-name
    sys$format_acl,
    display_brief	: NOVALUE,
    display_disk	: NOVALUE,
    display_terminal	: NOVALUE,
    display_journal	: NOVALUE,
    display_printer	: NOVALUE,
    display_magtape	: NOVALUE,
    display_general	: NOVALUE,
    common_display	: NOVALUE;

EXTERNAL ROUTINE
    expand_prot		: NOVALUE,
    lib$find_image_symbol,
    scan_cluster_locks	: NOVALUE,
    show$write_line	: NOVALUE;













!---
!
!            ***********************************************
!	     **						  **
!            **     A couple of words about formats:      **
!            **     The current format for /FULL          **
!            **     displays is that there are 4          **
!            **     spaces, followed by 32 characters,    **
!	     **     followed by 4 blanks, followed by     **
!	     **     39 characters of text.  Please        **
!	     **     don't f#ck this up, unless you're     **
!	     **     willing to fix ALL the displays       **
!	     **						  **
!	     ***********************************************
!
!+++

GLOBAL ROUTINE add_to_list_rtn (ptr, string : REF $BBLOCK, length) : NOVALUE =
BEGIN

!---
!
! Add a string to the string buffer.  If the string would exceed the length
! desired, then break the string and form a new string.  To find the place to
! break, scan from the back of the string looking for spaces.  If a space is
! found, attempt to split at the space.
!
! Inputs
!	ptr	- the address of a pointer to an array of string descriptors
!	string	- pointer to a string descriptor for the input string
!	length	- a maximum length for a fragment
!
! Outputs
!	ptr	- might be adjusted to point to a new descriptor
!	  ptr[0] - length of output fragment
!	  ptr[1] - pointer to start of current output fragment
!
!---

REGISTER
    dptr : REF VECTOR,
    slen,
    sptr : REF VECTOR [, BYTE];

!
! Load some registers with a few common values
!
slen = .string[dsc$w_length];			! Grab the length into a register
sptr = .string[dsc$a_pointer];			! Grab the pointer into a register
dptr = ..ptr;					! Look at the first descriptor itself
!
! If the new string fits, append the new string to the buffer and adjust the length
!
IF .dptr[0] + .slen LEQ .length
THEN
    BEGIN
    CH$MOVE(.slen,				! Add the string to the buffer
	    .sptr,
	    .dptr[1] + .dptr[0]);
    dptr[0] = .dptr[0] + .slen;			! Adjust the length for the appended segment
    RETURN;					! All done, go back
    END
!
! The new string would make the output string too long, if we can stick part of the
! new string on then do so.  Move to a new descriptor and move the rest to the new
! output string.
!
ELSE
    BEGIN
    !
    ! Scan the segment, looking for a word break (a space).
    !
    DECR si FROM .slen-1 TO 1			! Scan backwards through the new segment
    DO
	BEGIN
	IF .sptr[.si] EQL %C' '			! If we find a space
	  AND					!  and
	   .dptr[0] + .si LEQ .length		!   the string before the space fits
	THEN
	    BEGIN
	    CH$MOVE(.si,			! Add the string before ' ' to the old buffer
		    .sptr,
		    .dptr[1] + .dptr[0]);
	    dptr[0] = .dptr[0] + .si;		! Adjust the length for the appended segment
	    slen = .slen - .si;			! Remove the first piece from the segment,
	    sptr = .sptr + .si;			!  leaving a leading space
	    EXITLOOP;				! And finally, leave the loop
	    END;
	END;
    !
    ! Another place to break the line would be at a hyphenated word, look for one
    ! of those.
    !
    DECR si FROM .slen-1 TO 1			! Scan backwards through the new segment
    DO
	BEGIN
	IF .sptr[.si] EQL %C'-'			! If we find a hyphen
	  AND					!  and
	   .dptr[0] + .si LSS .length		!   the string including the hyphen fits
	THEN
	    BEGIN
	    CH$MOVE(.si + 1,			! Add the string with the '-' to the old buffer
		    .sptr,
		    .dptr[1] + .dptr[0]);
	    dptr[0] = .dptr[0] + .si + 1;	! Adjust the length for the appended segment
	    slen = .slen - .si;			! Remove the first piece from the segment,
	    sptr = .sptr + .si;			!  leaving a leading hyphen (stripped shortly)
	    EXITLOOP;				! And finally, leave the loop
	    END;
	END;
    dptr[3] = .dptr[1] + .dptr[0];		! Point the next descriptor at the buffer
    dptr = dptr[2];				! Move to the next descriptor
    .ptr = .dptr;				! Shuffle the passed pointer also
    slen = .slen - 1;				! Adjust the length and pointer,
    sptr = .sptr + 1;				!  in order to strip the leading space (or hyphen)
    CH$FILL(%C' ', .leading_blanks, .dptr[1]);	! Add any leading blanks which are desired
    CH$MOVE(.slen,				! Copy the string to the buffer,
	    .sptr,				!  but remove the leading space (or hyphen)
	    .dptr[1] + .leading_blanks);	! Place after the leading blanks, if any
    dptr[0] = .slen + .leading_blanks;		! Save the new length
    RETURN;					! All done, go back
    END;

END;

GLOBAL ROUTINE check_mnt_all (scratch, flags) =
BEGIN

!---
!
! This checks to see that we pass any SHOW DEVICE /ALLOCATED or /MOUNTED
! restrictions.  Note that we must wait until after we check clusterness
! before we can decide whether a device is really mounted or not.
!
! Inputs
!	SCRATCH - contains data about the device
!	FLAGS   - contains info on what to print
!
! Outputs
!	FLAGS[DEVI$V_DISPLAYED] set if we passed
!	Status - true if we pass, false if we didn't
!
!---

MAP
    scratch : REF $BBLOCK,
    flags : REF $BBLOCK;

!
! Make a check to see if /ALLOCATED or /MOUNTED was specified.  If so,
! then check to see if the device is mounted/allocated.  If not, then
! don't display information on the device.
!
IF .flags[devi$v_mounted]
THEN IF NOT .$BBLOCK[scratch[d_l_devchar], dev$v_mnt]
THEN RETURN false;

IF .flags[devi$v_allocated]
THEN IF NOT .$BBLOCK[scratch[d_l_devchar], dev$v_all]
THEN RETURN false;

!
! Set the bit and return true
!
flags[devi$v_displayed] = 1;

RETURN true;
END;

GLOBAL ROUTINE cluster_nodes (scratch, clubuf) : NOVALUE =
BEGIN

!---
!
! This routine displays a line telling which remote nodes have
! talons embedded in the device.
!
! Inputs
!	SCRATCH - contains data about the device
!	CLUBUF  - longword vector, first longword is CSID count,
!		  followed by that many CSIDs
!
! Outputs
!	None
!
!---

MAP
    scratch : REF $BBLOCK,
    clubuf : REF VECTOR [, LONG];

LOCAL
    arglist : VECTOR[4, LONG],
    desc : VECTOR[2, LONG],
    head : REF $BBLOCK,
    buffer : VECTOR[84, BYTE],
    nodename : VECTOR[16, BYTE];

!
! Return if nothing to note
!
IF 0 EQL (.scratch[d_w_bits] AND (1^$BITPOSITION(d_v_remote_mounts) OR 1^$BITPOSITION(d_v_remote_all)))
THEN RETURN;

!
! If the extra files-11 line hasn't been printed, then add a null line
!
IF .scratch[d_b_aqbtype] NEQ aqb$k_f11v2
THEN
    show$write_line (ascid_null, arglist);

!
! Determine the appropriate label for the line and initialize the output buffer and descriptor
!
IF .scratch[d_v_local_mount]
THEN
    head = %ASCID '  Volume is also mounted on '
ELSE IF .scratch[d_v_remote_mounts]
THEN
    head = %ASCID '  Volume is mounted on '
ELSE IF .scratch[d_v_remote_all]
THEN
    head = %ASCID '  Device is allocated on node ';
desc[0] = .head[dsc$w_length];
desc[1] = buffer;
CH$MOVE(.desc[0], .head[dsc$a_pointer], buffer);

!
! Add the system names to the buffer, wrapping if we hit 80 characters
!
INCR idx FROM 1 TO .clubuf[0]
DO
    BEGIN
    arglist[0] = (syi$_nodename^16 OR 16);
    arglist[1] = nodename;
    arglist[2] = arglist[3];		! Returned length word goes here
    arglist[3] = 0;			! Note: this clears the high word of the length
    IF $getsyi (csidadr=clubuf[.idx], itmlst=arglist)
    THEN
	BEGIN
	IF (.desc[0] + .arglist[3] + 1) GTR 80	! Will this one make us wrap?
	THEN
	    BEGIN
	    desc[0] = .desc[0] - 1;		! Remove the extra " "
	    show$write_line(desc,arglist);
	    CH$FILL(' ', 10, buffer);
	    desc[0] = 10;
	    END;
	CH$MOVE (.arglist[3], nodename, buffer[.desc[0]]);
	desc[0] = .desc[0] + .arglist[3];
	(buffer[.desc[0]])<0,16,0> = ', ';
	desc[0] = .desc[0] + 2;
	END;
    END;

!
! Write the remainder of the buffer if we have modified it (it is possible that
! a node will have crashed since we found the CSID, and we might not have anything
! to say).
!
IF .desc[0] NEQ .head[dsc$w_length]
THEN
    BEGIN
    desc[0] = .desc[0] - 1;			! Remove the extra " "
    buffer[.desc[0]-1] = '.';			! Change the final "," to a "."
    show$write_line(desc,desc);
    END;

RETURN;
END;

GLOBAL ROUTINE show_device_acl (scratch : REF $BBLOCK) : NOVALUE =
BEGIN

!---
!
! This routine displays the access control list if it exists.  Thanks to
! Mark Pilant for [CLIUTL.SRC]SHOWACL.B32, from which it was lifted.
!
! Inputs
!	SCRATCH - contains data about the device
!
!--

LOCAL
    acl_lockid		: $BBLOCK [acl$s_rlock_acl],		! Lock-id for ACL lock
    object_chan,						! Channel for object
    object_name		: VECTOR [2, LONG],			! Descriptor for device name
    object_type,						! Object's type code
    display_width,						! Output device width
    ace_bin_desc	: VECTOR [2, LONG],			! Binary ACE descr
    ace_storage		: $BBLOCK [acl$s_readace] VOLATILE,	! Binary ACE storage
    ace_txt_desc	: VECTOR [2, LONG],			! Text ACE descr
    ace_text		: VECTOR [512, BYTE],			! Text ACE storage
    atr_arglist		: BLOCKVECTOR [2, itm$s_item, BYTE],	! $CHANGE_ACL item list
    acl_context,						! $CHANGE_ACL context
    arglist		: VECTOR [4, LONG],			! Output line storage
    status;							! Routine return status

EXTERNAL LITERAL
	show$_objlocked;					! object locked error message

!
! If we don't need to do this, then exit now, before wasting time initing variables
! which we won't use.
!
IF NOT .scratch[d_v_acl_present]
THEN
    RETURN;

!
! Initialize all necessary storage.
!
CH$FILL (0, 2*itm$s_item, atr_arglist);
ace_bin_desc[1] = ace_storage;
ace_txt_desc[1] = ace_text;
ace_txt_desc[0] = 512;
arglist[0] = 0;
arglist[1] = ace_text;
object_chan = 0;
object_name[0] = .scratch[d_b_devlen];
object_name[1] = scratch[d_t_device];
object_type = acl$c_device;
display_width = 80;
acl_context = 0;

!
! Print the heading
!
show$write_line (ascid_null, arglist);
show$write_line (%ASCID '  Device access control list:', arglist);

!
! If this is the first time, then map the acl routines from SECURESHR.  This
! avoids extra image-activation time for mapping SECURESHR, something not
! frequently needed.
!
IF .format_acl_addr EQL 0
THEN
    BEGIN
    status = lib$find_image_symbol (ascid_secureshr, %ASCID 'SYS$FORMAT_ACL', format_acl_addr);
    IF NOT .status
    THEN
	BEGIN
	SIGNAL (.status);
	RETURN;
	END;
    status = lib$find_image_symbol (ascid_secureshr, %ASCID 'SYS$CHANGE_ACL', change_acl_addr);
    IF NOT .status
    THEN 
	BEGIN
	SIGNAL (.status);
	RETURN;
	END;
    END;

!
! Attempt to obtain a read lock for the object.
!
atr_arglist[0, itm$w_itmcod] = acl$c_rlock_acl;
atr_arglist[0, itm$w_bufsiz] = acl$s_rlock_acl;
atr_arglist[0, itm$l_bufadr] = acl_lockid;
status = $CHANGE_ACL (CHAN = .object_chan,
		      OBJTYP = object_type,
		      OBJNAM = object_name,
		      ITMLST = atr_arglist);
IF NOT .status
THEN
    BEGIN
    IF .status EQL ss$_notqueued THEN status = show$_objlocked;
    SIGNAL (.status);
    RETURN;
    END;

! Read, format, and display all the ACEs in the object's ACL until the end
! of the ACL is seen.  Or until an error occurs.

WHILE 1
DO
    BEGIN
    atr_arglist[0, itm$w_itmcod] = acl$c_readace;
    atr_arglist[0, itm$w_bufsiz] = acl$s_readace;
    atr_arglist[0, itm$l_bufadr] = ace_storage;
    status = $CHANGE_ACL (CHAN = .object_chan,
			  OBJTYP = object_type,
			  OBJNAM = object_name,
			  ITMLST = atr_arglist,
			  CONTXT = acl_context);
    IF NOT .status
    THEN
	BEGIN
	IF .status EQL ss$_aclempty OR .status EQL ss$_nomoreace THEN EXITLOOP;
	SIGNAL (show$_readerr, 1, object_name, .status);
	RETURN;
	END;
    !
    ! If the ACE is tagged as being hidden, don't display it.
    !
    IF NOT .ace_storage[ace$v_hidden]
    THEN
	BEGIN
	!
	! Format and display the ACE.
	!
	ace_bin_desc[0] = .ace_storage[ace$b_size];
	status = $FORMAT_ACL (ACLENT = ace_bin_desc,
			      ACLLEN = arglist[0],
			      ACLSTR = ace_txt_desc,
			      WIDTH = display_width,
			      TRMDSC = $DESCRIPTOR (%CHAR (13), %CHAR (10)),
			      INDENT = %REF (4));
	IF NOT .status
	THEN
	    BEGIN
	    SIGNAL (.status);
	    RETURN;
	    END;
	!
	! Show the entry
	!
	show$write_line (%ASCID '!AD', arglist);

	END;
    END;

RETURN;
END;

GLOBAL ROUTINE sys$change_acl =
BEGIN

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This is a dummy routine to satisfy the global reference of
!	the $CHANGE_ACL macro.  It simply calls the real service,
!	after dynamically loading the routine.
!
! CALLING SEQUENCE:
!	via $CHANGE_ACL macro
!
! ROUTINE VALUE:
!	status returned from sys$change_acl service
!
!--

BUILTIN
    CALLG,AP;

LOCAL
    status;

RETURN CALLG (.AP, .change_acl_addr);
END;

GLOBAL ROUTINE sys$format_acl =
BEGIN

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This is a dummy routine to satisfy the global reference of
!	the $FORMAT_ACL macro.  It simply calls the real service,
!	after dynamically loading the routine.
!
! CALLING SEQUENCE:
!	via $FORMAT_ACL macro
!
! ROUTINE VALUE:
!	status returned from sys$format_acl service
!
!--

BUILTIN
    CALLG,AP;

LOCAL
    status;

RETURN CALLG (.AP, .format_acl_addr);
END;

GLOBAL ROUTINE display_brief (scratch, flags) : NOVALUE =
BEGIN

!---
!
! This is the brief display routine for all devices
!
! Inputs
!	SCRATCH - contains data about the device
!	FLAGS   - contains info on what to print
!
! Outputs
!	None
!
!---

MAP
    scratch : REF $BBLOCK,
    flags : REF $BBLOCK;

LOCAL
    show_mnt,					! Show the string "mnt" in the status line
    ptr : REF VECTOR,				! Pointer to char. descriptor
    desc_vector : VECTOR[16]			! and the descriptors themselvses
    		  INITIAL(REP 16 OF (0)),
    desc : VECTOR[2],				! Characteristics descriptor
    buffer : VECTOR[80, BYTE],			! Characteristics buffer
    nambuf : VECTOR[64, BYTE],			! Buffer for device name
    clubuf : VECTOR[1024, BYTE],		! Buffer for lock information
    arglist : VECTOR[15];			! SHOW$WRITE_LINE argument list

!
! First thing, fix up the scratch area with any available clusterwide info.  Note
! that we might set the dev$v_mnt or dev$v_all bits in this routine
!
IF .$BBLOCK[scratch[d_l_devchar2], dev$v_clu]	! If available clusterwide
THEN
    scan_cluster_locks (.scratch, clubuf);

!
! Make a check to see if /ALLOCATED or /MOUNTED was specified.  If so,
! then check to see if the device is mounted/allocated.  If not, then
! don't display information on the device.
!
IF NOT check_mnt_all(.scratch, .flags)
THEN RETURN;

!
! Write a header if it hasn't been done already.
!
IF .flags[devi$v_header]
THEN
    BEGIN
    IF .scratch[d_b_devclass] EQLU dc$_disk
    OR .scratch[d_b_devclass] EQLU dc$_tape
    THEN show$write_line(ascid_null, arglist[0],
			 %ASCID 'Device                  Device           Error    Volume         Free  Trans Mnt', 
			 arglist[0],
			 %ASCID ' Name                   Status           Count     Label        Blocks Count Cnt',
			 arglist[0])
    ELSE IF .scratch[d_b_devclass] EQLU dc$_journal
    THEN show$write_line(ascid_null, arglist[0],
			 %ASCID 'Device                  Device              Journal        Buff  Cur. Sequence',
			 arglist[0],
			 %ASCID ' Name                   Status               Name          Size      Number',
			 arglist[0])
    ELSE show$write_line(ascid_null, arglist[0],
			 %ASCID 'Device                  Device           Error',
		    	 arglist[0],
			 %ASCID ' Name                   Status           Count', 
			 arglist[0]);
    flags[devi$v_header] = false;
    END;

!
! Get the device name.  The actual string is of the form "_DDCU", so shuffle
! to get rid of the underscore.
!
arglist[0] = .scratch[d_b_devlen] - 1;
arglist[1] = scratch[d_t_device] + 1;

!
! If there is an allocation class device name, put the name of the host in
! parentheses after the device name, right justified.  For example, we want to see
!	$255$DUA17:  (PRIDE)
!	$255$DUA19:   (LUST)
!
IF .$BBLOCK[scratch[d_l_devchar], dev$v_fod]
 AND
   .scratch[d_l_allocls] NEQ 0
THEN
    BEGIN
    LOCAL
	blen,					! Length of beginning, devname plus blanks to fill
	hlen,					! Length of host name
	tlen;					! Temporary len
    hlen = .scratch[d_t_host_name];		! Get the host name length into a temporary
    tlen = .arglist[0] + .hlen + 2;		! Device name + host name + parentheses
    blen = MAX (1, 22 - .tlen) + .arglist[0];	! Count of blanks between device and host (at least one), + device
    tlen = .blen + .hlen + 2;			! Total length
    CH$COPY (.arglist[0], .arglist[1], %C' ',	! Move the device name to the scratch buffer
	     .blen, nambuf);			!  adding spaces for right justification
    nambuf[.blen] = %C'(';			! Add the left parens
    CH$MOVE (.hlen, scratch[d_t_host_name]+1,	! Move the primary (or only) host name
	     nambuf[.blen+1]);			!  after the left parens
    nambuf[.tlen-1] = %C')';			! Add the right parens
    arglist[0] = .tlen;				! Pass the new length
    arglist[1] = nambuf;			! And the buffer
    IF .tlen GTR 23				! If it is too big for our area
    THEN
	BEGIN
	show$write_line(%ASCID '!AF', arglist);	! Print the names on their own line
	arglist[0] = 0;				! Zero the length so that it will not print again
	END;
    END;

!
! Fill in the status and characteristics buffer
!
ptr = desc_vector[0];				! Initialize the descriptor pointer
desc_vector[1] = buffer;			!  and the first descriptor and
leading_blanks = 0;				!  and say no leading blanks
arglist[2] = desc_vector;			! Put descriptor in arg list
show_mnt = .$BBLOCK[scratch[d_l_devchar], dev$v_mnt];	! Make a temp for the "mnt" bit
!
! If the device is online, see if we can expand a more meaningful string
!
IF .$BBLOCK[scratch[d_l_sts], 0, $BITPOSITION(ucb$v_online), 1, 0]
THEN
    BEGIN
    !
    ! If the primary host is not AVAIL, then call it "HostUnavailable"
    !
    IF NOT .scratch[d_v_host_avail]
    THEN add_to_list(ptr, 'HostUnavailable', 16)
    !
    ! Disconnected terminals should say so, rather than "Online det"
    !
    ELSE IF .$BBLOCK[scratch[d_l_devchar2], dev$v_det]	! detached from physical
    THEN add_to_list(ptr, 'Disconnected', 16)
    !
    ! If SET DEVICE /NOAVAIL was done, then call it "Unavailable"
    !
    ELSE IF NOT .$BBLOCK[scratch[d_l_devchar], dev$v_avl]
    THEN add_to_list(ptr, 'Unavailable  ', 16)
    !
    ! If mount verification found the wrong volume, mark it "WrongVolume"
    !
    ELSE IF .$BBLOCK[scratch[d_l_sts], 0, $BITPOSITION(ucb$v_wrongvol), 1, 0]
    THEN add_to_list(ptr, 'WrongVolume  ', 16)
    !
    ! If the volume is undergoing mount verification, mark it "MntVerify"
    !
    ELSE IF .$BBLOCK[scratch[d_l_sts], 0, $BITPOSITION(ucb$v_mntverip), 1, 0]
    THEN add_to_list(ptr, 'MountVerify  ', 16)
    !
    ! If the volume is not valid AND mounted, then it has failed mount
    ! verification and it should be marked "MntVerfyTimeout"
    !
    ELSE IF ((NOT .$BBLOCK[scratch[d_l_sts], 0, $BITPOSITION(ucb$v_valid), 1, 0])
	   AND .$BBLOCK[scratch[d_l_devchar], dev$v_mnt])	! Mounted
	   AND ((.scratch[d_b_aqbtype] EQL aqb$k_f11v1)
	        OR
		(.scratch[d_b_aqbtype] EQL aqb$k_f11v2))
    THEN add_to_list(ptr, 'MntVerifyTimeout', 16)
    !
    ! If the volume is mounted, then call it "Mounted" instead of "Online mnt".
    !
    ELSE IF .$BBLOCK[scratch[d_l_devchar], dev$v_mnt]
    THEN
	BEGIN
	show_mnt = false;			! Don't show the mnt bit again
	add_to_list(ptr, 'Mounted', 16)
	END
    !
    ! Otherwise just call it "Online"
    !
    ELSE add_to_list(ptr, 'Online', 16)		! Say whether online or
    END
!
! Nothing else matched, call it offline
!
ELSE
    add_to_list(ptr, 'Offline', 16);		! offline.
!
! Now that the major status is set, explode any other interesting bits
!
IF .$BBLOCK[scratch[d_l_devchar], dev$v_spl]	! Spooled
THEN add_to_list(ptr, ' spooled', 16);
IF .show_mnt					! Mounted
THEN add_to_list(ptr, ' mounted', 16);
IF .$BBLOCK[scratch[d_l_devchar], dev$v_dmt]	! Marked for dismount
THEN add_to_list(ptr, ' dismount', 16);
IF .$BBLOCK[scratch[d_l_devchar], dev$v_all]	! Allocated explicitly
THEN add_to_list(ptr, ' alloc', 16);
IF .$BBLOCK[scratch[d_l_devchar], dev$v_for]	! Foreign
THEN add_to_list(ptr, ' foreign', 16);
IF .$BBLOCK[scratch[d_l_devchar], dev$v_swl]	! Software-writelocked
THEN add_to_list(ptr, ' wrtlck', 16);
IF .scratch[d_b_devclass] EQLU dc$_journal
THEN
    BEGIN
    IF .$BBLOCK[scratch[d_l_sts], 0, $BITPOSITION(ucb$v_deadmo), 1, 0] 
    THEN add_to_list(ptr, ' del', 16);  ! Delete pending (for RU journals). 
    IF .$BBLOCK[scratch[d_w_devsts], 0, $BITPOSITION(ucb$v_jnl_cls), 1, 0]
    THEN add_to_list(ptr, ' cls', 16);
    IF .$BBLOCK[scratch[d_w_devsts], 0, $BITPOSITION(ucb$v_jnl_slv), 1, 0]
    THEN add_to_list(ptr, ' slv', 16);
    IF .$BBLOCK[scratch[d_w_devsts], 0, $BITPOSITION(ucb$v_known_jnl), 1, 0]
    THEN add_to_list(ptr, ' knw', 16)
    ELSE
	BEGIN
	IF .$BBLOCK[scratch[d_l_jnl_char], 0, $BITPOSITION(vcb$v_jnl_tmpfi), 1, 0]
	THEN add_to_list(ptr, ' tf', 16)
	ELSE add_to_list(ptr, ' pf', 16);
	END;
    IF .$BBLOCK[scratch[d_w_devsts], 0, $BITPOSITION(ucb$v_perm_jnl), 1, 0]
    THEN add_to_list(ptr, ' pj', 16)
    ELSE add_to_list(ptr, ' tj', 16);
    END;

!
! Miscellaneous data
!
arglist[3] = .scratch[d_w_errcnt];			! Error count

!
! Check to see if a long (not FULL) display
!
IF ((.scratch[d_b_devclass] EQLU dc$_disk		! If mounted disk,
OR .scratch[d_b_devclass] EQLU dc$_tape)		! tape,
AND .$BBLOCK[scratch[d_l_devchar], dev$v_mnt])
OR .scratch[d_b_devclass] EQLU dc$_journal		! journal, or ...
THEN
    BEGIN

!
! Print out the volume label and other crud.
!
    arglist[5] = scratch[d_t_volnam];
    IF .scratch[d_b_devclass] EQLU dc$_disk
    OR .scratch[d_b_devclass] EQLU dc$_tape
    THEN							! Put in disk/tape data
	BEGIN
	arglist[6] = .scratch[d_l_free];			! Free blocks on volume
	arglist[7] = .scratch[d_w_trans];			! Transaction count
	arglist[8] = .scratch[d_w_mcount];			! Mount count
	END
    ELSE							! Put in journal stuff
	BEGIN
	arglist[6] = .scratch[d_w_devbufsiz]/512;		! Buffer size in blocks
	arglist[7] = .scratch[d_l_jnl_seqno];
	END;

!
! For disk and journal, the volume label is 12 characters long, while magtapes have
! volume names that are only 6 bytes long.  Oh well...
!
    IF .scratch[d_b_devclass] EQLU dc$_disk
    THEN
	BEGIN
	IF .scratch[d_b_cont] OR .scratch[d_v_remote_mounts]
	THEN arglist[4] = vcb$s_volname				! Volume label
	ELSE arglist[4] = 0;
	show$write_line(%ASCID '!23<!AF!> !16AS !5UW  !12AF !9UL!6UW!4UW', arglist);
	END
    ELSE IF .scratch[d_b_devclass] EQLU dc$_journal
    THEN
	BEGIN
	IF .scratch[d_b_cont]
	THEN
	    BEGIN
	    arglist[4] = ucb$s_jnl_nam;				! Journal name
	    show$write_line(%ASCID '!23<!AF!> !16AS!+ !18AF !4UL     !10UL', arglist);
	    END
	ELSE show$write_line(%ASCID '!23<!AF!> !16AS', arglist);
	END
    ELSE
	BEGIN
	IF .scratch[d_b_cont]
	THEN arglist[4] = mvl$s_vollbl					! Volume label
	ELSE arglist[4] = 0;
	show$write_line(%ASCID '!23<!AF!> !16AS !5UW     !6AF    !9UL!6UW!4UW',arglist);
	END;
    END
ELSE
    show$write_line(%ASCID '!23<!AF!> !16AS !5UW', arglist);

!
! Print out any additional information required.
!
INCR i FROM 1 TO 7 DO
    BEGIN
    BIND string = desc_vector[2*.i] : VECTOR;
    IF .string[0] NEQ 0
    THEN show$write_line(%ASCID '!23< !> !16AS', %REF(string))
    ELSE EXITLOOP
    END;

RETURN;
END;

GLOBAL ROUTINE display_disk (scratch, flags) : NOVALUE =
BEGIN

!---
!
! This is the display routine for disks
!
! Inputs
!	SCRATCH - contains data about the disk
!	FLAGS   - contains info on what to print
!
! Outputs
!	None
!
!---

BUILTIN
    emul,ediv,cmpm;

MAP
    scratch : REF $BBLOCK,
    flags : REF $BBLOCK;

LOCAL
    desc_vector : VECTOR[9]
    		  INITIAL(REP 9 OF (0)),
    ptr : REF VECTOR,
    fao_ctr : REF $BBLOCK,
    buffer : VECTOR[160],	!8 80 byte lines
    prot_addr : VECTOR[4],
    prot_desc : VECTOR[2],
    prot_buff : VECTOR[20],
    clubuf : VECTOR[256, LONG],		! Buffer for lock information
    arglist : VECTOR[20];

!
! First thing, fix up the scratch area with any available clusterwide info
!
IF .$BBLOCK[scratch[d_l_devchar2], dev$v_clu]	! If available clusterwide
THEN
    scan_cluster_locks (.scratch, clubuf);

!
! Make a check to see if /ALLOCATED or /MOUNTED was specified.  If so,
! then check to see if the device is mounted/allocated.  If not, then
! don't display information on the device.
!
IF NOT check_mnt_all(.scratch, .flags)
THEN RETURN;

arglist[0] = cstring('Disk ');

!
! Determine which type of disk it is.  If not in the list, then 
! simply say that it is unknown.
!
arglist[6] = unknown;			! Assume unknown
INCR i FROM 0 TO disk_number - 1 DO 	! Loop thru known disk types
    (IF .scratch[d_b_devtype] EQLU .disk_type[.i]
    THEN (arglist[6] = .disk_label[.i]; EXITLOOP));

common_display(arglist, .scratch);		! Display stuff common to all devices

!
! Display some geometry items
!
IF (arglist[0] = .scratch[d_l_maxblock]) NEQ 0
THEN
    BEGIN
    arglist[1] = .scratch[d_b_sectors];
    arglist[2] = .scratch[d_w_cylinders];
    arglist[3] = .scratch[d_b_tracks];
    show$write_line(%ASCID '    Total blocks!20UL    Sectors per track!22UW',
		    arglist[0],
		    %ASCID '    Total cylinders!17UW    Tracks per cylinder!20UW',
		    arglist[2]);
    END;

!
! If remote or dual-pathed, then print some more info
!
IF .scratch[d_v_remote_device] OR .$BBLOCK[scratch[d_l_devchar2], dev$v_2p]
THEN
    BEGIN
    BIND
	t_yes = UPLIT BYTE ('yes'),
	t_no  = UPLIT BYTE (' no');
    arglist[0] = 15 - .scratch[d_t_host_name];
    arglist[1] = .scratch[d_t_host_name];
    arglist[2] = scratch[d_t_host_name] + 1;
    arglist[3] = 4;
    arglist[4] = scratch[d_l_host_type];
    arglist[5] = 3;
    arglist[6] = (IF .scratch[d_v_host_avail]
		  THEN t_yes
		  ELSE t_no);
    show$write_line(%ASCID '    Host name      !#< !>"!AF"    Host type, available          !AF, !AF',
						arglist[0]);
    IF .$BBLOCK[scratch[d_l_devchar2], dev$v_2p]
    THEN
	BEGIN
	arglist[0] = 8 - .scratch[d_t_host2_name];
	arglist[1] = .scratch[d_t_host2_name];
	arglist[2] = scratch[d_t_host2_name] + 1;
	arglist[3] = 4;
	arglist[4] = scratch[d_l_host2_type];
	arglist[5] = 3;
	arglist[6] = (IF .scratch[d_v_host2_avail]
		      THEN t_yes
		      ELSE t_no);
	show$write_line(%ASCID '    Alternate host name   !#< !>"!AF"    Alternate host type, avail    !AF, !AF',
						arglist[0]);
	END;
    END;

!
! If an allocation class is present, display it
!
IF .scratch[d_l_allocls] NEQ 0
THEN
    show$write_line(%ASCID '    Allocation class!16UL', scratch[d_l_allocls]);

!
! Now for the ACP-dependent things
!
IF .scratch[d_b_cont]
THEN
    BEGIN
    arglist[1] = vcb$s_volname;				! Start with full volume name
    DECR idx FROM vcb$s_volname-1 TO 0			! Reduce length
    DO (IF .(scratch[d_t_volnam]+.idx)<0,8,0> EQL %C' '	! by the number of
	THEN arglist[1] = .arglist[1]-1			! trailing spaces
	ELSE exitloop);
    arglist[0] = 6+vcb$s_volname-.arglist[1];		! Adjust field width
    arglist[2] = scratch[d_t_volnam];			! Address of volume name
    arglist[3] = .scratch[d_w_rvn];			! Relative volume number
    arglist[4] = .scratch[d_w_cluster];			! Cluster factor
    arglist[5] = .scratch[d_w_trans];			! Transaction count
    arglist[6] = .scratch[d_l_free];			! Free blocks on volume
    arglist[7] = .scratch[d_l_maxfiles];		! Max number of files
    arglist[8] = .scratch[d_w_extend];			! Default extend quantity
    arglist[9] = .scratch[d_w_mcount];			! Count of sharers

    !
    ! Is it mounted /GROUP or /SYSTEM ?
    !
    IF .$BBLOCK[scratch[d_b_status], 0,$BITPOSITION(vcb$v_group),1,0]
    THEN arglist[11] = cstring('Group')
    ELSE IF .$BBLOCK[scratch[d_b_status], 0,$BITPOSITION(vcb$v_system),1,0]
    THEN arglist[11] = cstring('System')
    ELSE arglist[11] = cstring('Process');
    arglist[10] = 20 - .(.arglist[11])<0,8>;
    IF .scratch[d_v_cachename]
    THEN
	BEGIN
	fao_ctr = %ASCID '    Mount status!#< !>!AC    Cache name!#< !>"!AF"';
	arglist[12] = 27 - .scratch[d_t_acpnam];
	END
    ELSE
	BEGIN
	fao_ctr = %ASCID '    Mount status!#< !>!AC    ACP process name!#< !>"!AF"';
	arglist[12] = 21 - .scratch[d_t_acpnam];
	END;
    arglist[13] = .scratch[d_t_acpnam];		! Process name of the ACP, or XQP cache name
    arglist[14] = scratch[d_t_acpnam] + 1;

    show$write_line(ascid_null, arglist[0],
		    %ASCID '    Volume label!#< !>"!AF"    Relative volume number!17UW',
		    arglist[0],
		    %ASCID '    Cluster size!20UW    Transaction count!22UW',
		    arglist[4],
		    %ASCID '    Free blocks!21UL    Maximum files allowed!18UL',
		    arglist[6],
		    %ASCID '    Extend quantity!17UW    Mount count!28UW',
		    arglist[8],
		    .fao_ctr,
		    arglist[10]);
		
    !
    ! Now for special bits.
    !
    ptr = desc_vector[0];
    desc_vector[1] = buffer;
    leading_blanks = 6;
    add_to_list(ptr, '  Volume status: ', 80);	!Note - string length is checked later
    IF .$BBLOCK[scratch[d_b_status2], 0,$BITPOSITION(vcb$v_mountver),1,0]
    THEN add_to_list(ptr, ' subject to mount verification,', 80);
    IF .$BBLOCK[scratch[d_b_status], 0,$BITPOSITION(vcb$v_homblkbad),1,0]
    THEN add_to_list(ptr, ' primary home block is bad,', 80);
    IF .$BBLOCK[scratch[d_b_status], 0,$BITPOSITION(vcb$v_idxhdrbad),1,0]
    THEN add_to_list(ptr, ' primary index file header is bad,', 80);
    IF .$BBLOCK[scratch[d_b_status], 0,$BITPOSITION(vcb$v_noalloc),1,0]
    THEN add_to_list(ptr, ' allocation inhibited because of error on bitmap,', 80);
    IF NOT .$BBLOCK[scratch[d_l_sts], 0,$BITPOSITION(ucb$v_unload),1,0]
    THEN add_to_list(ptr, ' do not unload on dismount,', 80);
    IF .scratch[d_b_aqbtype] EQL aqb$k_f11v2		! If ODS-2, find some more
    THEN
	BEGIN
	!
	! Get ODS-2 specific information: caching, mount verification, and 
	! expiration dates, erasing, high-water
	!
	IF .$BBLOCK[scratch[d_b_status2], 0,$BITPOSITION(vcb$v_erase),1,0]
	THEN add_to_list(ptr, ' erase on delete,', 80);
	IF NOT .$BBLOCK[scratch[d_b_status2], 0,$BITPOSITION(vcb$v_nohighwater),1,0]
	THEN add_to_list(ptr, ' file high-water marking,', 80);
	IF .$BBLOCK[scratch[d_b_status2], 0,$BITPOSITION(vcb$v_nocache),1,0]
	THEN add_to_list(ptr, ' caching is disabled,', 80)
	ELSE
	    BEGIN
	    LOCAL
		temp : VECTOR [2, LONG], dummy, limit;
	    IF (arglist[0] = .scratch[d_w_extsize]) EQL 0	! Extent cache size
	    THEN
		arglist[1] = arglist[3] = 0			! No extent cache, zero for all fields
	    ELSE
		BEGIN
		arglist[1] = .scratch[d_w_extlimit];		! Extend to longword (limit in percent_free/10)
		EMUL (arglist[1], scratch[d_l_free], %REF(0), temp);
		EDIV (%REF(1000), temp, arglist[1], dummy);	! Store limit in arglist
		arglist[3] = .scratch[d_l_exttotal];		! Blocks currently in extent cache
		END;
	    arglist[2] = .scratch[d_w_fidsize];		! File ID cache size
	    arglist[4] = .scratch[d_w_quosize];		! Quota cache size
	    arglist[5] = .scratch[d_w_bfrcnt];		! Cache buffer count

	    show$write_line(%ASCID '    Extent cache size!15UW    Maximum blocks in extent cache!9UL',
			    arglist[0],
			    %ASCID '    File ID cache size!14UW    Blocks currently in extent cache!7UL',
			    arglist[2],
			    %ASCID '    Quota cache size!16UW    Maximum buffers in FCP cache!11UW',
			    arglist[4]);
	    IF .$BBLOCK[scratch[d_b_status2], 0,$BITPOSITION(vcb$v_writethru),1,0]
	    THEN add_to_list(ptr, ' write-through caching enabled,', 80)
	    ELSE add_to_list(ptr, ' write-back caching enabled,', 80);
	    END;

	!
	! If a retention min/max are specified, then output them.
	!
	IF CMPM(2, scratch[d_q_retainmin], UPLIT(0,0)) NEQ 0
	THEN
	    BEGIN
	    LOCAL
		min_tim : VECTOR[7,WORD],
		max_tim : VECTOR[7,WORD];
	    $NUMTIM(TIMBUF = min_tim,
		    TIMADR = scratch[d_q_retainmin]);
	    $NUMTIM(TIMBUF = max_tim,
		    TIMADR = scratch[d_q_retainmax]);
	    arglist[0] = .min_tim[2];
	    arglist[1] = .max_tim[2];
	    show$write_line(%ASCID '   Min ret. period (days)!10UW    Max ret. period (days)!17UW',
			    arglist[0]);
	    END;
	END;

    !
    ! Separate the special and node information by a blank line
    !
    show$write_line(ascid_null, arglist[0]);

    !
    ! Output the special bits, if there are any.
    !
    IF .desc_vector[0] NEQ %CHARCOUNT('  Volume status: ')
    THEN INCR i FROM 0 TO 3 DO
	BEGIN
	IF .desc_vector[2*(.i+1)] EQL 0		! On the last string change the final
	THEN					!  comma to a period.
	    BEGIN
	    BIND
		str = .desc_vector[(2*.i)+1],
		dot = (str+.desc_vector[2*.i]-1) : BYTE;
	    dot = '.';
	    END;
	arglist[0] = desc_vector[2*.i];
	show$write_line(%ASCID '!AS', arglist);
	IF .desc_vector[2*(.i+1)] EQL 0
	THEN EXITLOOP;
	END;
    END;

!
! Let them know if it is accessed elsewhere
!
cluster_nodes (.scratch, clubuf);

!
! Show any access control list which might be present
!
show_device_acl (.scratch);

RETURN;
END;

GLOBAL ROUTINE display_magtape (scratch, flags) : NOVALUE =
BEGIN

!---
!
! This is the display routine for magtapes.
!
! Inputs
!	SCRATCH - contains data about the magtape.
!	FLAGS   - contains info on what to print
!
! Outputs
!	None
!
!---

MAP
    scratch : REF $BBLOCK,
    flags : REF $BBLOCK;

LOCAL
    clubuf : VECTOR[1024, BYTE],		! Buffer for lock information
    arglist : VECTOR[20];

!
! First thing, fix up the scratch area with any available clusterwide info
!
IF .$BBLOCK[scratch[d_l_devchar2], dev$v_clu]	! If available clusterwide
THEN
    scan_cluster_locks (.scratch, clubuf);

!
! Make a check to see if /ALLOCATED or /MOUNTED was specified.  If so,
! then check to see if the device is mounted/allocated.  If not, then
! don't display information on the device.
!
IF NOT check_mnt_all(.scratch, .flags)
THEN RETURN;

arglist[0] = cstring('Magtape ');

!
! Determine which type of tape drive it is.  If not in the list, then 
! simply say that it is unknown.
!
arglist[6] = unknown;			! Assume unknown
INCR i FROM 0 TO tape_number - 1 DO 	! Loop thru known magtape types
    (IF .scratch[d_b_devtype] EQLU .tape_type[.i]
    THEN (arglist[6] = .tape_label[.i]; EXITLOOP));

common_display(arglist, .scratch);	! Display stuff common to all devices

!
! Display other data
!
IF .scratch[d_b_cont]
THEN
    BEGIN
    arglist[0] = mvl$s_vollbl;
    arglist[1] = scratch[d_t_volnam];			! Volume label
    arglist[2] = .scratch[d_w_rvn];			! Relative volume number
    arglist[3] = .scratch[d_w_recordsz];		! size in bytes
    arglist[4] = .scratch[d_w_trans];			! Transaction count
    IF .$BBLOCK[scratch[d_b_status], 0,$BITPOSITION(vcb$v_group),1,0]
    THEN arglist[6] = cstring('Group')
    ELSE IF .$BBLOCK[scratch[d_b_status], 0,$BITPOSITION(vcb$v_system),1,0]
    THEN arglist[6] = cstring('System')
    ELSE arglist[6] = cstring('Process');
    arglist[5] = 20 - .(.arglist[6])<0,8>;
    arglist[7] = .scratch[d_w_mcount];			! Count of sharers
    arglist[8] = 14 - .scratch[d_t_acpnam];
    arglist[9] = .scratch[d_t_acpnam];
    arglist[10] = scratch[d_t_acpnam] + 1;
    END;
!
! Check for the specific tape characteristics
!
arglist[12] = (IF .$BBLOCK[scratch[d_l_devdepend], mt$v_density] EQL 0
	      OR .$BBLOCK[scratch[d_l_devdepend], mt$v_density] EQLU mt$k_normal11
	      THEN cstring('Normal-11')
	      ELSE IF .$BBLOCK[scratch[d_l_devdepend], mt$v_density] EQLU mt$k_nrzi_800
	      THEN cstring('800')
	      ELSE IF .$BBLOCK[scratch[d_l_devdepend], mt$v_density] EQLU mt$k_pe_1600
	      THEN cstring('1600')
	      ELSE IF .$BBLOCK[scratch[d_l_devdepend], mt$v_density] EQLU mt$k_gcr_6250
	      THEN cstring('6250')
	      ELSE unknown);
arglist[11] = 25 - .(.arglist[12])<0,8>;
IF .$BBLOCK[scratch[d_l_devdepend], mt$v_format] EQL 0
THEN arglist[14] = .format_label[0]
ELSE
    BEGIN
    arglist[14] = unknown;
    INCR i FROM 0 TO format_number - 1
    DO (IF .$BBLOCK[scratch[d_l_devdepend], mt$v_format] EQLU .format_type[.i]
    THEN (arglist[14] = .format_label[.i]; EXITLOOP));
    END;
arglist[13] = 33 - .(.arglist[14])<0,8>;

IF .scratch[d_b_cont]
THEN show$write_line(ascid_null, arglist[0],
		     %ASCID '    Volume label            "!AF"    Relative volume no.!20UW',
		     arglist[0],
		     %ASCID '    Record size!21UW    Transaction count!22UW',
		     arglist[3],
		     %ASCID '    Mount status!#< !>!AC    Mount count!28UW',
		     arglist[5],
		     %ASCID '    ACP process name!#< !>"!AF"',
		     arglist[8]);

show$write_line(%ASCID '    Density!#< !>!AC    Format!#< !>!AC',
		arglist[11]);

arglist[0] = (IF .$BBLOCK[scratch[d_l_sts], 0, $BITPOSITION(ucb$v_unload), 1, 0] 
	      THEN UPLIT BYTE(0) 
	      ELSE cstring('no-unload on dismount, ')); 

arglist[1] = (IF .$BBLOCK[scratch[d_l_devdepend], mt$v_bot]
	      THEN cstring('beginning-of-tape, ')
	      ELSE UPLIT BYTE(0));

arglist[2] = (IF .$BBLOCK[scratch[d_l_devdepend], mt$v_eof]
	      THEN cstring('end-of-file, ')
	      ELSE UPLIT BYTE(0));

arglist[3] = (IF .$BBLOCK[scratch[d_l_devdepend], mt$v_eot]
	      THEN cstring('end-of-tape, ')
	      ELSE UPLIT BYTE(0));

arglist[4] = (IF .$BBLOCK[scratch[d_l_devdepend], mt$v_hwl]
	      THEN cstring('write-locked, ')
	      ELSE UPLIT BYTE(0));

arglist[5] = (IF .$BBLOCK[scratch[d_l_devdepend], mt$v_lost]
	      THEN cstring('position lost, ')
	      ELSE UPLIT BYTE(0));

arglist[6] = (IF .$BBLOCK[scratch[d_l_devdepend], mt$v_parity]
	      THEN cstring('even')
	      ELSE cstring('odd'));


!
! Format the data for output and print it.
!
show$write_line(ascid_null, arglist);
show$write_line(%ASCID '  Volume status:  !AC!AC!AC!AC!AC!AC!AC parity.', arglist);

!
! Let them know if it is accessed elsewhere
!
cluster_nodes (.scratch, clubuf);

!
! Show any access control list which might be present
!
show_device_acl (.scratch);

RETURN;
END;

GLOBAL ROUTINE display_journal (scratch, flags) : NOVALUE =
BEGIN

!---
!
! This is the display routine for journals
!
! Inputs
!	SCRATCH - contains data about the journal
!	FLAGS   - contains info on what to print
!
! Outputs
!	None
!
!---

MAP
    scratch : REF $BBLOCK,
    flags : REF $BBLOCK;

LOCAL
    arglist : VECTOR[20];

!
! Make a check to see if /ALLOCATED or /MOUNTED was specified.  If so,
! then check to see if the device is mounted/allocated.  If not, then
! don't display information on the device.
!
IF NOT check_mnt_all(.scratch, .flags)
THEN RETURN;

arglist[0] = cstring('Journal ');

!
! Determine which type of journal it is.  If not in the list, then 
! simply say that it is unknown.
!
arglist[6] = unknown;			! Assume unknown
INCR i FROM 0 TO journal_number - 1 DO 	! Loop thru known journal types
    (IF .scratch[d_b_devtype] EQLU .journal_type[.i]
    THEN (arglist[6] = .journal_label[.i]; EXITLOOP));

scratch[d_w_devbufsiz] = .scratch[d_w_devbufsiz]/512;	! Fiddle buffer size
common_display(arglist, .scratch);	! Display stuff common to all devices


!
! If there's more (i.e., not a control journal), continue
!
IF .scratch[d_b_cont]
THEN
    BEGIN
    arglist[0] = ucb$s_jnl_nam;				! The volume label may
    arglist[1] = scratch[d_t_volnam];
    arglist[2] = 21 - .scratch[d_t_acpnam];
    arglist[3] = .scratch[d_t_acpnam];			! Process name of the ACP
    arglist[4] = scratch[d_t_acpnam] + 1;
    arglist[6] = .mode_table[.scratch[d_b_amod]];		! Access mode
    arglist[5] = 21 - .(.arglist[6])<0,8>;
    arglist[7] = .scratch[d_w_trans];			! Transaction count
    arglist[8] = .scratch[d_w_jnl_cop];			! Number of existing jnl copies
    arglist[9] = .scratch[d_b_jnl_avl];			! Number of avail. jnl copies
    arglist[10] = .scratch[d_l_jnl_seqno];			! Current sequence number
    arglist[11] = .scratch[d_l_jnl_asid];			! How many assigns so far


    show$write_line(%ASCID '    Journal name!2< !>"!AF"    ACP process name!#< !>"!AF"',
		    arglist[0],
		    %ASCID '    Access mode!#< !>!AC    Transaction count!22UW',
		    arglist[5],
		    %ASCID '    Existing jnl copies!13UW    Available jnl copies!19UB',
		    arglist[8],
		    %ASCID '    Current sequence no.!12UL    Assign seq. no.!24UL',
		    arglist[10]);

    !
    ! If this is a disk journal, display the size.
    !
    IF .$BBLOCK[scratch[d_l_jnl_char], 0, $BITPOSITION(vcb$v_jnl_disk), 1, 0]
    THEN show$write_line(%ASCID '    Journal size!20UL',
			 %REF(.scratch[d_l_fil_mxvbn]))
    !
    ! If tape, display tape-specific stuff
    !
    ELSE
	BEGIN
	arglist[0] = .scratch[d_w_jnl_id];
	arglist[2] = scratch[d_t_grpnam];
	arglist[1] = 27 - .(.arglist[2])<0,8>;
	show$write_line(%ASCID '    Journal quota!19UL    Shadow group!#< !>!AC',
			 arglist);
	END;

    !
    ! If this is an AT journal, display the journal mask
    !
    IF .scratch[d_b_devtype] EQLU dt$_atjnl
    THEN show$write_line(%ASCID '    Journal mask!12< !>!8XL',
			 %REF(.scratch[d_l_jnl_mask]));

    !
    ! If an RU journal, display the quota
    !
    IF .scratch[d_b_devtype] EQLU dt$_rujnl
    THEN show$write_line(%ASCID '    Journal quota!19UL',
			 %REF(.scratch[d_l_jnl_quot]));

    !
    ! Display the physical devices
    !
    BEGIN
    LOCAL
	desc : VECTOR[2],
	buffer : VECTOR[25,BYTE],
	pointer : REF VECTOR[,BYTE];
    pointer = .scratch + d_k_length;
    IF .pointer[0] NEQ 0
    THEN
	BEGIN
	show$write_line(%ASCID '    Physical device(s): !AC',
			pointer);
	pointer = pointer[0] + .pointer[0] +1;
	END;
    WHILE .pointer[0] NEQ 0 DO
	BEGIN
	show$write_line(%ASCID '!24< !>!AC',
			pointer);
	pointer = pointer[0] + .pointer[0] + 1;
	END;
    END;


    arglist[0] = (IF .$BBLOCK[scratch[d_l_sts], 0, $BITPOSITION(ucb$v_deadmo), 1, 0]  
		  THEN cstring('delete pending, ')
		  ELSE UPLIT BYTE(0));

    arglist[1] = (IF .$BBLOCK[scratch[d_w_devsts], 0, $BITPOSITION(ucb$v_jnl_cls), 1, 0] 
		  THEN cstring('cluster journal, ')
		  ELSE UPLIT BYTE(0));

    arglist[2] = (IF .$BBLOCK[scratch[d_w_devsts], 0, $BITPOSITION(ucb$v_jnl_slv), 1, 0] 
		  THEN cstring('slave journal, ')
		  ELSE UPLIT BYTE(0));

    arglist[3] = (IF .$BBLOCK[scratch[d_w_devsts], 0, $BITPOSITION(ucb$v_known_jnl), 1, 0] 
		  THEN cstring('known journal, ')
		  ELSE IF .$BBLOCK[scratch[d_l_jnl_char], 0, $BITPOSITION(vcb$v_jnl_tmpfi), 1, 0] 
		  THEN cstring('temporary file, ')
		  ELSE cstring('permanent file, ')); 

    arglist[4] = (IF .$BBLOCK[scratch[d_w_devsts], 0, $BITPOSITION(ucb$v_perm_jnl), 1, 0] 
		  THEN cstring('permanent journal.')
		  ELSE cstring('temporary journal.')); 

    !
    ! Format the data for output and print it.
    !
    show$write_line(ascid_null, arglist);
    show$write_line(%ASCID '  Attributes:  !AC!AC!AC!AC!AC', arglist);
    END;

!
! Show any access control list which might be present
!
show_device_acl (.scratch);

RETURN;
END;

GLOBAL ROUTINE display_printer (scratch, flags) : NOVALUE =
BEGIN

!---
!
! This is the display routine for printers.
!
! Inputs
!	SCRATCH - contains data about the printer device
!	FLAGS   - contains info on what to print
!
! Outputs
!	None
!
!---

MAP
    scratch : REF $BBLOCK,
    flags : REF $BBLOCK;

LOCAL
    arglist : VECTOR[20];

!
! Make a check to see if /ALLOCATED or /MOUNTED was specified.  If so,
! then check to see if the device is mounted/allocated.  If not, then
! don't display information on the device.
!
IF NOT check_mnt_all(.scratch, .flags)
THEN RETURN;

!
! Set up the argument list for output.
!
arglist[0] = cstring('Printer ');

!
! Determine which type of line printer it is.  If not in the list, then 
! simply say that it is unknown.
!
arglist[6] = unknown;
INCR i FROM 0 TO printer_number - 1
DO (IF .scratch[d_b_devtype] EQLU .printer_type[.i]
    THEN (arglist[6] = .printer_label[.i]; EXITLOOP));

common_display(arglist, .scratch);		! Print the common heading

!
! Insert the page width and length
!
arglist[0] = .scratch[d_w_devbufsiz];				! Page width
arglist[1] = .$BBLOCK[scratch[d_l_devdepend], lp$v_page_l];	! Page length

!
! Check for the specific printer characteristics
!
arglist[2] = (IF .$BBLOCK[scratch[d_l_devdepend], lp$v_cr]
	      THEN UPLIT BYTE (0)
	      ELSE cstring('No '));
arglist[3] = cstring('Carriage_return');

arglist[4] = (IF .$BBLOCK[scratch[d_l_devdepend], lp$v_mechform]
	      THEN UPLIT BYTE (0)
	      ELSE cstring('No '));
arglist[5] = cstring('Formfeed');

arglist[6] = (IF .$BBLOCK[scratch[d_l_devdepend], lp$v_lower]
	      THEN cstring('Lowercase')
	      ELSE cstring('Uppercase'));

arglist[7] = (IF .$BBLOCK[scratch[d_l_devdepend], lp$v_passall]
	      THEN UPLIT BYTE (0)
	      ELSE cstring('No '));
arglist[8] = cstring('Passall');

arglist[9] = (IF .$BBLOCK[scratch[d_l_devdepend], lp$v_wrap]
	       THEN UPLIT BYTE (0)
	       ELSE cstring ('No '));
arglist[10] = cstring('Wrap');

arglist[11] = (IF .$BBLOCK[scratch[d_l_devdepend], lp$v_printall]
	       THEN UPLIT BYTE (0)
	       ELSE cstring('No '));
arglist[12] = cstring('Printall');

arglist[13] = (IF .$BBLOCK[scratch[d_l_devdepend], lp$v_fallback]
    	       THEN UPLIT BYTE (0)
    	       ELSE cstring('No '));
arglist[14] = cstring('Fallback');

arglist[15] = (IF .$BBLOCK[scratch[d_l_devdepend], lp$v_tab]
    	       THEN UPLIT BYTE (0)
    	       ELSE cstring('No '));
arglist[16] = cstring('Tab');

arglist[17] = (IF .$BBLOCK[scratch[d_l_devdepend], lp$v_truncate]
    	       THEN UPLIT BYTE (0)
    	       ELSE cstring('No '));
arglist[18] = cstring('Truncate');

!
! Format the data for output and print it.
!
show$write_line(%ASCID '    Page width!22UW    Page Length!28UB',
		arglist[0],
		%ASCID '    !AC!AC!_!AC!AC!_!AC',
		arglist[2],
		%ASCID '    !AC!AC!_!_!AC!AC!_!_!AC!AC',
		arglist[7],
		%ASCID '    !AC!AC!_!_!AC!AC!_!_!AC!AC',
		arglist[13]);

!
! If the device is spooled, say so.
!
IF .$BBLOCK[scratch[d_l_devchar], dev$v_spl]
THEN
    BEGIN
    arglist[0] = .scratch[d_l_intlen] - 1;
    arglist[1] = scratch[d_t_intdev] + 1;
    arglist[2] = scratch[d_t_qname];
    show$write_line(%ASCID '    Intermediate device: !AF', arglist,
    		    %ASCID '    Associated queue:    !AC', arglist[2]);
    END;

!
! Show any access control list which might be present
!
show_device_acl (.scratch);

RETURN;
END;

GLOBAL ROUTINE display_terminal (scratch, flags) : NOVALUE =
BEGIN

!---
!
! This is the display routine for terminals
!
! Inputs
!	SCRATCH - contains data about the terminal
!	FLAGS   - contains info on what to print
!
! Outputs
!	None
!
!---

MAP
    scratch : REF $BBLOCK,
    flags : REF $BBLOCK;

LOCAL
    arglist : VECTOR[20];

!
! Make a check to see if /ALLOCATED or /MOUNTED was specified.  If so,
! then check to see if the device is mounted/allocated.  If not, then
! don't display information on the device.
!
IF NOT check_mnt_all(.scratch, .flags)
THEN RETURN;

!
! Set up the argument list for output.
!
arglist[0] = cstring('Terminal ');

!
! Determine which type of terminal it is.  If not in the list, then 
! simply say that it is unknown.
!
arglist[6] = unknown;
INCR i FROM 0 TO terminal_number - 1
DO (IF .scratch[d_b_devtype] EQLU .terminal_type[.i]
    THEN (arglist[6] = .terminal_label[.i]; EXITLOOP));

common_display(arglist, .scratch);		! Print the common heading

!
! Show any access control list which might be present
!
show_device_acl (.scratch);

RETURN;
END;

GLOBAL ROUTINE display_general (scratch, flags) : NOVALUE =
BEGIN

!---
!
! This is the general display routine for devices
!
! Inputs
!	SCRATCH - contains data about the device
!	FLAGS   - contains info on what to print
!
! Outputs
!	None
!
!---

MAP
    scratch : REF $BBLOCK,
    flags : REF $BBLOCK;

LOCAL
    arglist : VECTOR[20];

!
! Make a check to see if /ALLOCATED or /MOUNTED was specified.  If so,
! then check to see if the device is mounted/allocated.  If not, then
! don't display information on the device.
!
IF NOT check_mnt_all(.scratch, .flags)
THEN RETURN;

!
! Set up the argument list for output.
!
arglist[0] = cstring('Device ');
arglist[6] = 0;

common_display(arglist, .scratch);		! Print the common heading

!
! Show any access control list which might be present
!
show_device_acl (.scratch);

RETURN;
END;

ROUTINE common_display (arglist, scratch) : NOVALUE =
BEGIN

!---
!
! This routine displays the common heading for all devices
!
! Inputs
!	ARGLIST - partial argument list, containing
!		  ARGLST[0] = device class	(ASCIC)
!		  ARGLST[6] = device type	(ASCIC)
!	SCRATCH - address of area that contains info on the device
!
! Outputs
!	None
!
!---

MAP
    arglist : REF VECTOR,
    scratch : REF $BBLOCK;

LOCAL
    index,					! Pointer
    count_pointer,				! Pointer to count cell
    ptr : REF VECTOR,				! Descriptor pointer
    desc_vector : VECTOR[10]			! Array of descriptors
    		  INITIAL(REP 10 OF (0)),
    fao_buff : VECTOR[200];			! Place to store stuff (10 lines by 80 chars)

BIND
    fao_desc = desc_vector[0] : VECTOR[2],	! Descriptor of formatted UIC
    prot_desc = desc_vector[2] : VECTOR[2];	! Descriptor for protection



!
! Get the device and alias names.  The actual string is of the form "_DDCU",
! so shuffle to get rid of the underscore.
!
arglist[1] = .scratch[d_b_devlen] - 1;
arglist[2] = scratch[d_t_device] + 1;

arglist[3] = .scratch[d_t_host_name];
arglist[4] = scratch[d_t_host_name]+1;

!
! Set up a buffer to hold the device name and characteristics
!
desc_vector[0] = 80;
desc_vector[1] = fao_buff;
ptr = desc_vector;
leading_blanks = 4;
$FAOL(OUTBUF = desc_vector,
      OUTLEN = desc_vector,
      PRMLST = .arglist,
      CTRSTR = (IF .$BBLOCK[scratch[d_l_devchar], dev$v_fod]
		 AND
		   .scratch[d_l_allocls] NEQ 0
		THEN 
		    BEGIN
		    IF .arglist[6] NEQ 0
    		    THEN %ASCID '!AC!AF (!AF), device type !+!AC, is '
    		    ELSE %ASCID '!AC!AF (!AF) is '
		    END
		ELSE
		    BEGIN
		    IF .arglist[6] NEQ 0
    		    THEN %ASCID '!AC!AF!+!+, device type !+!AC, is '
    		    ELSE %ASCID '!AC!AF is '
		    END));

!
! Get particular characteristics of interest
!
IF .$BBLOCK[scratch[d_l_sts], 0, $BITPOSITION(ucb$v_online), 1, 0]
THEN add_to_list(ptr, 'online,', 80)
ELSE add_to_list(ptr, 'offline,', 80);

IF .$BBLOCK[scratch[d_l_sts], 0, $BITPOSITION(ucb$v_timout), 1, 0]
THEN add_to_list(ptr, ' unit timed out,', 80);

IF NOT .scratch[d_v_host_avail]
THEN add_to_list(ptr, ' host not available,', 80);

IF NOT .$BBLOCK[scratch[d_l_devchar], dev$v_avl]
THEN add_to_list(ptr, ' device set /NOAVAILABLE,', 80);

IF .$BBLOCK[scratch[d_l_devchar], dev$v_all]
THEN add_to_list(ptr, ' allocated,', 80);

IF .$BBLOCK[scratch[d_l_sts], 0,$BITPOSITION(ucb$v_deadmo),1,0]
  AND
   .$BBLOCK[scratch[d_l_devchar], dev$v_all]
THEN add_to_list(ptr, ' deallocate on dismount,', 80);

IF .$BBLOCK[scratch[d_l_devchar], dev$v_mnt]
THEN
    BEGIN
    IF .$BBLOCK[scratch[d_l_devchar], dev$v_for]	! Foreign
    THEN add_to_list(ptr, ' mounted foreign,', 80)
    ELSE add_to_list(ptr, ' mounted,', 80);
    IF .$BBLOCK[scratch[d_l_devchar], dev$v_swl]	! Software-writelocked
    THEN add_to_list(ptr, ' software write-locked,', 80);
    !
    ! If mount verification has timed out, display that, otherwise if it is active show that.  Do not
    ! show both timed out and active.
    !
    SELECTONE true OF
    SET
	[ .$BBLOCK[scratch[d_l_sts], 0, $BITPOSITION(ucb$v_mntverip), 1, 0] ]

			  : add_to_list(ptr, ' mount verification in progress,', 80);

	[ (NOT .$BBLOCK[scratch[d_l_sts], 0, $BITPOSITION(ucb$v_valid), 1, 0])
	     AND
	  ((.scratch[d_b_aqbtype] EQL aqb$k_f11v1) OR (.scratch[d_b_aqbtype] EQL aqb$k_f11v2)) ]

			  : add_to_list(ptr, ' mount verification timed out,', 80);
    TES;
    IF .$BBLOCK[scratch[d_l_sts], 0, $BITPOSITION(ucb$v_wrongvol), 1, 0]
    THEN add_to_list(ptr, ' mount verification found wrong volume,', 80);
    END;

IF .$BBLOCK[scratch[d_l_devchar], dev$v_dmt]
THEN add_to_list(ptr, ' volume is marked for dismount,', 80);

IF .$BBLOCK[scratch[d_l_devchar], dev$v_opr]
THEN add_to_list(ptr, ' enabled as operator terminal,', 80);

IF .$BBLOCK[scratch[d_l_devchar], dev$v_dua]
THEN add_to_list(ptr, ' device is set /DUAL_PORT,', 80);

IF .$BBLOCK[scratch[d_l_devchar], dev$v_rck]
THEN add_to_list(ptr, ' data check on reads,', 80);

IF .$BBLOCK[scratch[d_l_devchar], dev$v_wck]
THEN add_to_list(ptr, ' data check on writes,', 80);

IF .$BBLOCK[scratch[d_l_devchar], dev$v_rec]
THEN add_to_list(ptr, ' record-oriented device,', 80);

IF .$BBLOCK[scratch[d_l_devchar], dev$v_ccl]
THEN add_to_list(ptr, ' carriage control,', 80);

IF .$BBLOCK[scratch[d_l_devchar], dev$v_net]
THEN add_to_list(ptr, ' network device,', 80);

IF .$BBLOCK[scratch[d_l_devchar], dev$v_fod]
THEN add_to_list(ptr, ' file-oriented device,', 80);

IF .$BBLOCK[scratch[d_l_devchar], dev$v_shr]
THEN add_to_list(ptr, ' shareable,', 80);

IF .$BBLOCK[scratch[d_l_devchar], dev$v_rtm]
THEN add_to_list(ptr, ' real time device,', 80);

IF .$BBLOCK[scratch[d_l_devchar2], dev$v_clu]		! If available show so, but
 AND (NOT .$BBLOCK[scratch[d_l_devchar2], dev$v_srv])	!  not if we served it (it's obvious then)
THEN add_to_list(ptr, ' available to cluster,', 80);

IF .$BBLOCK[scratch[d_l_devchar2], dev$v_red]
THEN add_to_list(ptr, ' device is a physical terminal accessed through a virtual terminal,', 80);

IF .$BBLOCK[scratch[d_l_devchar2], dev$v_ssm]
THEN add_to_list(ptr, ' member of a shadow set,', 80);

IF .scratch[d_v_shadow_master]
THEN add_to_list(ptr, ' master of a shadow set,', 80);

IF .$BBLOCK[scratch[d_l_devchar2], dev$v_srv]
THEN add_to_list(ptr, ' served to cluster via MSCP Server,', 80);

IF .$BBLOCK[scratch[d_l_devchar], dev$v_spl]
THEN add_to_list(ptr, ' device is spooled through an intermediate device,', 80);

IF .$BBLOCK[scratch[d_l_devchar], dev$v_elg]
THEN add_to_list(ptr, ' error logging is enabled,', 80);

IF .$BBLOCK[scratch[d_l_devchar2], dev$v_det]	! detached from physical
THEN add_to_list(ptr, ' virtual device is disconnected from physical device,', 80);

IF .$BBLOCK[scratch[d_l_devchar], dev$v_gen]
THEN add_to_list(ptr, ' generic device,', 80);

IF .$BBLOCK[scratch[d_l_devchar], dev$v_mbx]
THEN add_to_list(ptr, ' mailbox device,', 80);

IF .$BBLOCK[scratch[d_l_sts], 0, $BITPOSITION(ucb$v_erlogip), 1, 0]
THEN add_to_list(ptr, ' error currently being logged,', 80);

IF .$BBLOCK[scratch[d_b_orb_flags], 0, $BITPOSITION(orb$v_noacl), 1, 0]
THEN add_to_list(ptr, ' access control list not supported on this type of device,', 80);

IF .$BBLOCK[scratch[d_l_sts], 0, $BITPOSITION(ucb$v_cancel), 1, 0]
THEN add_to_list(ptr, ' operations being canceled,', 80);

IF .$BBLOCK[scratch[d_l_sts], 0, $BITPOSITION(ucb$v_power), 1, 0]
THEN add_to_list(ptr, ' power failure has been recorded,', 80);

IF .$BBLOCK[scratch[d_l_sts], 0, $BITPOSITION(ucb$v_bsy), 1, 0]
THEN add_to_list(ptr, ' device is busy,', 80);

IF .$BBLOCK[scratch[d_l_sts], 0, $BITPOSITION(ucb$v_mounting), 1, 0]
THEN add_to_list(ptr, ' mount operation in progress,', 80);

IF .$BBLOCK[scratch[d_l_sts], 0, $BITPOSITION(ucb$v_template), 1, 0]
THEN add_to_list(ptr, ' device is a template only,', 80);

!
! Now print out a blank line followed by the information
!
show$write_line(ascid_null, arglist[0]);
INCR i FROM 0 TO 2 DO
    BEGIN
    IF .desc_vector[2*(.i+1)] EQL 0		! On the last string change the final
    THEN					!  comma to a period.
	BEGIN
	BIND
	    str = .desc_vector[(2*.i)+1],
	    dot = (str+.desc_vector[2*.i]-1) : BYTE;
	dot = '.';
	END;
    arglist[0] = desc_vector[2*.i];
    show$write_line(%ASCID '!AS', arglist[0]);
    IF .desc_vector[2*(.i+1)] EQL 0
    THEN EXITLOOP
    END;

!
! Display statistics common to all devices.
!
arglist[0] = .scratch[d_w_errcnt];
arglist[1] = .scratch[d_l_opcnt];
arglist[2] = 15 - .scratch[d_t_prcnam];
arglist[3] = .scratch[d_t_prcnam];
arglist[4] = scratch[d_t_prcnam] + 1;
fao_desc[0] = 80;
fao_desc[1] = fao_buff;
$FAOL(CTRSTR = %ASCID '!%I',
      OUTBUF = fao_desc,
      OUTLEN = fao_desc,
      PRMLST = %REF(.scratch[d_l_ownuic]));
arglist[5] = (IF .FAO_DESC[0] GEQ 30
	      THEN 1 ELSE 30 - .FAO_DESC[0]);
arglist[6] = fao_desc;
arglist[7] =   (BEGIN		! convert to the extended pid format
		LINKAGE
		    cvt_lnk = JSB (REGISTER=0) : PRESERVE (1,2,3,4,5) NOTUSED (6,7,8,9,10,11);
		EXTERNAL ROUTINE
		    EXE$IPID_TO_EPID : cvt_lnk ADDRESSING_MODE (GENERAL);
		EXE$IPID_TO_EPID (.scratch[d_l_pid])
		END);
arglist[9] = prot_desc;
IF .$BBLOCK[scratch[d_l_devchar], dev$v_net]
THEN (arglist[8] = 1; prot_desc[0] = 0)
ELSE
    BEGIN
    LOCAL
    	key,
	prot_addr : VECTOR[4];
    IF .$BBLOCK[scratch[d_l_devchar], dev$v_fod]
    THEN key = 0
    ELSE key = 1;
    expand_prot(prot_addr, .scratch[d_w_vprot], .key);
    prot_desc[0] = 80;
    prot_desc[1] = fao_buff + 80;
    $FAOL(CTRSTR = %ASCID 'S:!AS,O:!AS,G:!AS,W:!AS',
    	  OUTLEN = prot_desc,
    	  OUTBUF = prot_desc,
    	  PRMLST = prot_addr);
    END;
arglist[8] = 31 - .prot_desc[0];
arglist[10] = .scratch[d_w_refc];
arglist[11] = .scratch[d_w_devbufsiz];

show$write_line(ascid_null, arglist[0],
		%ASCID '    Error count!21UW    Operations completed!19UL',
		arglist[0],
		%ASCID '    Owner process  !#< !>"!AF"    Owner UIC!#< !>!AS',
		arglist[2],
		%ASCID '    Owner process ID!16XL    Dev Prot!#< !>!AS',
		arglist[7],
		%ASCID '    Reference count!17UL    Default buffer size!20UW',
		arglist[10]);

RETURN;
END;

END
ELUDOM
