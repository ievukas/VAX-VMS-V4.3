	.TITLE	SYSBOOT - VMS Secondary Bootstrap Routine
	.IDENT	'V04-000'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;++
;
; Facility:  System bootstrapping and initialization
;
; Abstract: 
;
;
; Environment:
;	Mode=Kernel ,  Memory Management OFF
;	IS=1 ,  IPL=31
;
; Author:  RICHARD I. HUSTVEDT, Creation date:  28-APR-1978
;
; MODIFIED BY:
;
;	V03-062	KPL0102		P Lieberwirth		24-Aug-1984
;		Fix bug in GETCONLOC_790 that enabled the logical console
;		imcorrectly.
;
;	V03-061	WHM0008		Bill Matthews		25-Jul-1984
;		Initialize the keyboard translation table address for QVSS
;		console terminal support.
;
;	V03-060	TCM0019		Trudy C. Matthews	24-Jul-1984
;		Check to see if the version of VMB has support for the
;		RPB$B_CTRLLTR field.
;
;	V03-059	WHM0007		Bill Matthews		16-Jul-1984
;		Add support for QVSS as a console terminal.
;
;	V03-058	WMC0058		Wayne Cardoza		05-Jul-1984
;		Don't second guess LRPMIN.
;
;	V03-057	WMC0057		Wayne Cardoza		28-Jun-1984
;		Survive very fragmented dump file.
;
;	V03-056	WHM0006		Bill Matthews		14-May-1984
;		Fix to not copy SYSBOOT's copy of EXE$GL_TODR over the copy
;		from SYS.EXE
;
;	V03-055	KDM0101		Kathleen D. Morse	02-May-1984
;		Change minimum cpu microcode rev level check from 5 to 4
;		for MicroVAX I.
;
;	V03-054	WHM0005		Bill Matthews		02-May-1984
;		Always use VAXVMSSYS.PAR. Don't read the SYSGEN parameter area
;		twice.
;
;	V03-053	KDM0098		Kathleen D. Morse	24-Apr-1984
;		Add minimum cpu microcode rev level check for MicroVAX I.
;
;	V03-052	WHM0004		Bill Matthews		16-Apr-1984
;		Don't use a separate parameter file if USESYSPARAMS is set to
;		0 in SYS.EXE. (Needed for standalone backup environment)
;
;	V03-051	KPL0101		Peter Lieberwirth	11-Apr-1984
;		Zero the high byte of RPB$W_BOOTNDT if VMB version is
;		high enough to have set up RPB$B_BOOTNDT, but not high
;		enough so as to have properly initialized the high byte
;		(version 12).
;
;	V03-050	WHM0003		Bill Matthews		04-Apr-1984
;		Added support to read in the SYSGEN parameters from the
;		the default system parameter file.
;		Added support to use file to handle ascii sysgen parameters
;		that are longer than 4 bytes.
;
;	V03-049	WMC0004		Wayne Cardoza		28-Mar-1984
;		Save the highest useable PFN.
;
;	V03-048	CWH3048		CW Hobbs		15-Mar-1984
;		Require a "Y" response rather than a carriage return when
;		switching console volumes.  Also rewind the old volume before
;		asking for the switch so that VAX-11/750 processors do not
;		timeout waiting for the TU58 to rewind.
;
;	V03-047	WHM0002		Bill Matthews	08-Mar-1984
;		Modification made to VMB so interface change made in WHM0001
;		can be backed out.
;
;	V03-046	KPL0001		Peter Lieberwirth	 8-Mar-1984
;		Zero fill RPB$W_BOOTNDT from RPB$B_CONFREG for old versions
;		of VMB.
;
;	V03-045	WHM0001		Bill Matthews	05-Mar-1984
;		Add support for booting from a set of common system files.
;
;	V03-044	MMD0248		Meg Dumont,	27-Feb-1984  10:48
;		Add support for $MTACCESS installation specific accessibility 
;		routine
;
;	V03-043	LY00B6		Larry Yetto		10-FEB-1984 15:30
;		Fix truncation errors.
;
;	V03-042	TMK0001		Todd M. Katz		31-Jan-1984
;		Fix a whole host of truncation errors by changing word 
;		to long offsets
;
;	V03-041	WMC0003		Wayne Cardoza		21-Dec-1983
;		Prevent PHYSICAL_PAGES parameter from confusing PFN bit map.
;		Make PFN link word size converge.
;
;	V03-040	TCM0018		Trudy C. Matthews	08-Dec-1983
;		Initialize EXE$GB_CPUDATA twice: once before the first
;		CPUDISP and again after SYSBOOT reads the system parameters
;		off the disk (which wipes out the first initialization).
;		Also, set "enable mask write" bit when enabling venus'
;		logical console line in GETCONLOC_790.
;		Only make interrupts through SCB vector 0 harmless on a 780
;		(and not on venus).
;
;	V03-039	DWT0149		David W. Thiel		14-Nov-1983
;		Condition loading of SCSLOA and CLUSTRLOA on the
;		now 3-valued SYSGEN parameter VAXCLUSTER.
;
;	V03-038	ACG0372		Andrew C. Goldstein,	11-Nov-1983  10:00
;		Tighten page protection on various system structures
;
;	V03-037	TCM0017		Trudy C. Matthews	27-Oct-1983
;		Initialize EXE$GB_CPUTYPE cell before initial breakpoint;
;		XDELTA expects that field to be set up.
;
;	V03-036	KDM0087		Kathleen D. Morse	20-Oct-1983
;		Load SCB emulation vectors from the boot-strap emulator
;		linked into SYSBOOT, not from what VMB left in them.
;
;	V03-035	KDM0084		Kathleen D. Morse	23-Sep-1983
;		Add MicroVAX I to CPUDISP.  Add a patch area for SYSBOOT.
;
;	V03-034	CWH3034		CW Hobbs		28-Aug-1983
;		Make it possible for SYS.EXE to cross volume boundaries
;		when booting from the console.  Means that no files can
;		be kept open across calls to read SYS.EXE.
;
;	V03-033	TCM0016		Trudy C. Matthews	2-Aug-1983
;		Store SID in CPUDATA field before executing any CPUDISP
;		macros.  Add 11/785-specific path to CPUDISP macro that
;		checks hardware/microcode revs.
;
;	V03-032	KDM0061		Kathleen D. Morse	15-Jul-1983
;		Change code to use cpu-specific definition for IPR ACCS,
;		PR780$_ACCS, instead of cpu-independent PR$_ACCS.
;
;	V03-031	TCM0015		Trudy C. Matthews	27-Jul-1983
;		Add support for the 11/785's different PCS/WCS version numbers.
;
;	V03-030	MSH0001		Maryann Hinden		13-Jul-1983
;		BOO$GETPARAM no longer takes an argument.
;
;	V03-029	KTA3061		Kerbey T. Altmann	26-Jun-1983
;		Fixed truncation error.
;
;	V03-028	ADE0001		Alan D. Eldridge	23-Jun-1983
;		Change "64" to CXB$C_OVERHEAD when calculating LRP size.
;
;	V03-027	KTA3059		Kerbey T. Altmann	21-Jun-1983
;		Add support for boot device name from VMB.
;
;	V03-026	TCM0014		Trudy C. Matthews	15-Jun-1983
;		Fix console protocol bug in GETCONLOC_790.
;
;	V03-025	KDM0045		Kathleen D. Morse	31-May-1983
;		Change word displacements to longword.
;
;	V03-024	KDM0044		Kathleen D. Morse	02-May-1983
;		Load floating point emulator, if necessary, and set
;		appropriate indicators in EXE$GL_ARCHFLAG.
;
;	V03-023	KTA3048		Kerbey T. Altmann	14-Apr-1983
;		Grab G&H status from console for 11/780.  Ascertain
;		FPA status.
;
;	V03-022	TCM0013		Trudy C. Matthews	23-Feb-1983
;		Check VMB version for version which passes number of bad
;		pages found during bootstrap memory scan in RPB$L_BADPGS.
;
;	V03-021	KTA3038		Kerbey T. Altmann	11-Feb-1983
;		Add copying of possible boot node name.
;
;	V03-020	DWT0073		David W. Thiel		28-Jan-1983
;		Load cluster code based on SGN$V_LOADCLUSTR instead
;		of VMS5.
;
;	V03-019	TCM0012		Trudy C. Matthews	21-Jan-1983
;		Add routine label SYSL$CLRSBIA for linking with XDELTA.
;
;	V03-018	STJ3056		Steven T. Jeffreys	21-Jan-1983
;		Added code to laod $ERAPAT and $CHKPRT loadable code
;		into pool, if necessary.
;
;	V03-017	SRB0059		Steve Beckhardt		6-Jan-1983
;		Added code to load cluster loadable code into pool,
;		if necessary.
;
;	V03-016	WMC0002		Wayne Cardoza		30-Dec-1982
;		Exclude system service vectors from PFN database.
;
;	V03-015	TCM0011		Trudy C. Matthews	15-Dec-1982
;		Correct protocol error in GETCONLOC_790.
;
;	V03-014	TCM0010		Trudy C. Matthews	10-Dec-1982
;		Use CPUDATA cell to store 11/790 microcode rev level.
;
;	V03-013	JWH0126		Jeffrey W. Horn		11-Nov-1982
;		Fix bug in computation of SWP$GB_SHLP1PT which occurs
;		when SWP$C_SHLFPTE is greater than 127.
;
;	V03-012	KTA3018		Kerbey T. Altmann	08-Nov-1982
;		Remove loading of INILOA.
;
;	V03-011	TCM0009		Trudy C. Matthews	26-Oct-1982
;		Add 11/790-specific paths through CPU-dependent code.
;
;	V03-010	LJK0168		Lawrence J. Kenah	2-Jun-1982
;		Move code that maps pageable exec so that pages containing
;		it are not included in PFN data base when system paging
;		is turned off (SYSPAGING = 0).
;
;--

;
; Include files:
;
	$ARCDEF				; Define architectural flag bits
	$BOODEF				; Define Boot Control Block Offsets
	$BQODEF				; Define Boot qio offsets
	$BTDDEF				; Define Boot devices
	$CXBDEF				; Define Complex Chained Buffer
	$DPTDEF				; Define Driver Prologue Definitions
	$DYNDEF				; Define dynamic pool codes
	$FH2DEF				; Define level 2 file header offsets
	$IHDDEF				; Define Image Header offsets
	$IO750DEF			; Define 11/750 I/O space
	$IODEF				; Define I/O function code values
	$IRPDEF				; Define I/O request packet offsets
	$NDTDEF				; Define nexus device type codes
	$PHDDEF				; Define process header offsets
	$PRDEF				; Define process register numbers
	$PRMDEF				; Define SYSGEN parameter offsets
	$PR780DEF			; Define 11/780 processor registers
	$PSLDEF				; Define program status longword fields
	$PTEDEF				; Define page table entry fields
	$RPBDEF				; Define restart parameter block offsets
	$SECDEF				; Define process section block
	$TPADEF				; Define TPARSE offsets
	$VADEF				; Define fields in virtual address
	$VMBARGDEF			; Define VMB argument list offsets
	$WCBDEF				; Define Window Control Block offsets
	$WSLDEF				; Define Working Set lis entry
					;***
DEBUG=1					;***
					;***

;
; Macros:
;
	.MACRO	ERROR,STR		; 
	BSBW	ERROUT			; Output error string
	.ASCIZ	\'STR'\			;
	.ENDM	ERROR			;

	.MACRO	MSG,STR			;
	BSBW	BOO$FACMSG		; Output message
	.ASCIZ	\'STR'\			;
	.ENDM	MSG			;

;
; Equated Symbols:
;
;
	R2_R11 = ^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>	; Mask for R2 to R11
	IOSIZE = 127			; Do I/O in very large chunks
	MAXPGS = 16384			; Allow for 8Mb of memory
	DEBUG  = 1			; Assemble DEBUG code
	CR     = 13			; Character code for carriage return
	LF     = 10			; Character code for line feed
	BELL   = 7			; ASCII bell

	RP_DT  = 24			; Offset to drive type register for massbus
	RTRV_PAG_CNT = 3		; Retrieval pointer page count
					; 1 for SYS.EXE
					; 1 for SYSDUMP.DMP
					; 1 for the other small files

;
; 11/780 microcode revision levels.
;	
	FPLA_VLOC_780 = ^O155		; Offset to FPLA version number location
	FPLA_780 = ^X0C			; FPLA version number
	PCS_VLOC_780  = ^O152		; Offset to PCS version number location
	PCS_780 = ^X01			; PCS version number
	WCSP_VLOC_780 = ^O153		; Offset to WCS primary version location
	WCSP_780 = ^X0C			; WCS primary version number
	WCSS_VLOC_780 = ^O154		; Offset to WCS secondary version location
	WCSS_780 = ^X12			; WCS secondary version
	GHOPT_VLOC    = ^O144		; GH opt flag location

;
; 11/785 microcode revision levels.
;
	SID_785 = 23			; SID bit that differentiates an 11/785
					; from an 11/780.

	PCS_VLOC_785  = ^O152		; Offset to PCS version number
	PCS_785 = ^X04			; PCS version number
	MTCH_VLOC_785 = ^O153		; Offset to PCS/WCS match version number.
	MTCH_785 = ^X04			; PCS/WCS match version number.
	WCSP_VLOC_785 = ^O154		; Offset to WCS primary version number.
	WCSP_785 = ^X01			; WCS primary version number.
	WCSS_VLOC_785 = ^O155		; Offset to WCS secondary version number.
	WCSS_785 = ^X00			; WCS secondary version number.

;
; 11/750 revision levels.
;

	HWREV_750=0			; Minimum req'd hardware ECO level
	MICREV_750=62			; Minimum req'd microcode rev level

;
; 11/730 revision levels.
;
	HWREV_730=0			; Minimum req'd hardware ECO level
	MICREV_730=51			; Minimum req'd microcode rev level

;
; 11/790 revision levels.
;
	MICREV_REQ_790 = ^X12		; Code to request ucode rev level
	MICREV_790=0			; Minimum req'd microcode rev level

;
; MicroVAX I revision levels.
;
	MICREV_UV1 = ^X04		; Minimum req'd microcode rev level
					; Note:  REV 5 is required to use
					; the 19" QVSS as console terminal.

;
; Offsets into Statistics Blocks kept for each file that is looked up
;
	$OFFSET	0,POSITIVE,<-
	STAT_L_VBN,-			; Starting VBN (after header)
	STAT_L_BYTECNT,-		; Size in bytes of image
	STAT_L_SYSVA,-			; Base relative adr of pool adr
	STAT_L_NAME,-			; Base relative adr of ASCIC file name
	STAT_L_MAP,-			; Address of virtual to logical map
	STAT_L_VBN2ADR,-		; Buf Adr containing VBN 2
	<STAT_C_SIZE,0> -		; Size of STAT block
	>
;
; Own Storage:
;
	.PSECT	__Z99BOOT,PAGE
BOOTHIGH:				;
	.PSECT	$$$$00BOOT,LONG		;
	.PAGE
	.SBTTL	Secondary Bootstrap Main Routine
;++
;
; Functional Description:
;
; Calling Sequence:
;	JMP	EXE$SYSBOOT
;
; Input Parameters:
;	R10 - Base address of secondary bootstrap
;	R11 - Pointer to Restart Parameter Block
;	AP  - Argument list from VMB (Version 5 or later)
;	SP  - Stack pointer
;	PR$_SCBB - System Control Block Base (SCB)
;
;	Memory layout at start of secondary bootstrap:
;
;	+-----------------------------------------+ :BASE
;	!					  !
;	!	Restart Parameter Block (RPB)	  !
;	!					  !
;	+-----------------------------------------+ :BASE+^X200
;	!					  !
;	!	  Primary Bootstrap Code	  !
;	!	(up to the end of drivers only)	  !
;	!					  !
;	+-----------------------------------------+ :PR$_SCBB
;	!					  !
;	!	   System Control Block		  !
;	!					  !
;	+-----------------------------------------+ :PFNMAP
;	!					  !
;	!	    Small PFN Bitmap		  !
;	!					  !
;	+-----------------------------------------+ :PFNMAP+X (X=^X200/400/600
;	!					  !	or 800 as determ by VMB)
;	!	     Bootstrap Stack		  !
;	!		(3 pages)		  !
;	+-----------------------------------------+ :(SP)
;	!					  !
;	!	 Secondary Bootstrap Code	  !
;	!					  !
;	+-----------------------------------------+
;
;	The PFN bitmap passed in by VMB describes all the memory that
; has been tested and proven usable.  Some of that memory is actively in
; use and must not be allocated and overwritten by this SYSBOOT code.
; For example the portion of memory in which this code is currently
; running has not been marked as "in use."  Allocation of memory
; is done from high PFN to low.  It is expected that we will not get
; to the pages we are running in, and thus having them appear usable
; means that they don't have to be set usable before transferring 
; control to INIT.
;	There are 3 other regions of memory that have the same attribute.
; The first is the FIL$OPENFILE cache.  If memory allocation overlaps
; this cache, it will automatically be disabled.  The second region
; is the combination CI microcode and page table.  If memory allocation
; overlaps this area, a fatal error halt is taken, as the infomation
; contained therein is essential to system operation. The third region
; is the large PFN bitmap.  This region is only created for memories
; in excess of 8mb, and it is positioned at 2mb.  It is assumed that
; none of the allocation logic will get down to this point for such
; a large memory, and thus this is not a problem.
;	There are 3 points at which SYSBOOT is interested in regions
; which are in use, but marked allocatable.  The first point
; is when SYSBOOT artificially limits the size of memory to the
; physical page count SYSGEN parameter (near label HAVEPRM).
;	The second place is when SYSBOOT is trying to allocate a
; contiguous run of pages for the SPT (near label ALLOCSPT).
;	The final place is in the routine ALLOCPFN which allocates
; a PFN.
;
; Output Parameters:
;
;--

EXE$SYSBOOT::				; Secondary bootstrap start address
	MOVL	R11,W^BOO$GL_RPBBASE	; Save base of RPB
;
; Get pointer to SCB used by primary bootstrap and fill with pointers to
; exception handlers for secondary bootstrap.
;
	MFPR	#PR$_SCBB,R8		; Address of VMB's SCB
	MOVAL	^X200(R8),R8		; Fill SCB back to front
	MOVAL	W^BOOT_FAULT+1,R6	; Unexpected fault handler vector
10$:	MOVL	R6,-(R8)		; Store a vector
	BITW	#^X1FF,R8		; Check for page boundary
	BNEQ	10$			; Need another vector
	MOVAB	VAX$EMULATE,^XC8(R8)	; Set emulation vector contents
	MOVAB	VAX$EMULATE_FPD,^XCC(R8) ; Set FPD emulation vector contents
	MOVAB	W^UNEXP_MCHK,4(R8)	; Machine checks are not expected
;
; Get CPU type and check if valid.
;

CHK_CPU_TYPE:				; Get and check CPU type
	MFPR	#PR$_SID,R0		; Read SID
	MOVL	R0,W^EXE$GB_CPUDATA	; Store SID in SYSPARAM data field
	ASHL	#-PR$V_SID_TYPE,R0,R0	; Right justify type
	BEQL	10$			; Branch if type=0 (illegal)
	CMPB	R0,#PR$_SID_TYPMAX	; Type exceeds maximum?
	BLEQU	20$			; Branch if not (legal)
;***
;***The following 4 instructions are present to allow
;***11/780's with uninitialized sid's to run.
;***
	CMPB	R0,#-1			; CPU type=-1?
	BNEQ	10$			; branch if not
	MNEGB	R0,R0			; if so, set CPU type to 11/780
	BRB	20$			;  and continue
;***
10$:	MSG	<-F-Unknown processor>
	HALT				; *****Fatal Error*****
20$:	MOVB	R0,W^EXE$GB_CPUTYPE	; Save CPU TYPE in SYSPARAM
	MOVB	R0,W^CPUTYPE		; Save it in a safe place too

;
; Check for alternate console terminal and if necessary fix up displacements
; for CON$GETCHAR and CON$PUTCHAR in CONIO.
;
	CPUDISP	<<780,40$>,-		; *Dispatch on CPU type*
		 <750,40$>,-		; 
		 <730,40$>,-
		 <790,40$>,-
		 <UV1,30$>,-
		 <785,40$>>,-
		ENVIRON=VMB

30$:	BBS	#6,RPB$L_BOOTR1(R11),40$;branch if QVSS is NOT the console terminal
	MOVW	#<QVSS$INPUT-CON$GETCHAR-3>,-;calculate displacment
		CON$GETCHAR+1		;Fix up the BRW instruction in CON$GETCHAR
	MOVW	#<QVSS$OUTPUT-CON$PUTCHAR-3>,-;calculate displacment
		CON$PUTCHAR+1		;Fix up the BRW instruction in CON$PUTCHAR
	MOVW	#^A/WS/,W^MODEL_UV1	; Use SYSLOAWS1.EXE
	MOVAL	QVSS$KEY-112,QVSS$KEYTABLE; INITIALIZE THE KEYBOARD TRANSLATION TABLE

40$:
;
; If debug code is included, connect debugger to BPT and TBIT exception
; vectors, then execute a BPT instruction to give control to the debugger.
;
	.IF	DF,DEBUG		;
	MOVAB	XDELBPT,^X2C(R8)	; Set BPT exception vector to debugger
	MOVAB	XDELTBIT,^X28(R8)	;  and TBIT vector also
	MOVAB	B^INI$BRK,XDELIBRK	; Make correct break address in brk table
	BBC	#RPB$V_BOOBPT,RPB$L_BOOTR5(R11),NOBRK	; Check for bootstrap BPT
INI$BRK::				;
	BPT				; Breakpoint initially, changed to NOP
NOBRK:					; No bootstrap break point
	.ENDC				;

	MOVAL	L^BOOTHIGH,W^BOO$GL_FREEMEM ; Save pointer to free memory
	MOVL	R10,W^SYSBOOT_BASE	; Save base address of this code
	ASHL	#3,RPB$Q_PFNMAP(R11),W^MEM_HI_PFN ; Record highest PFN
					; if VMB didn't pass it in.
	MOVQ	RPB$Q_PFNMAP(R11),W^SMALL_PFNMAP ; Save descriptor for backward
					; compatible (max 8mb) PFN bitmap
;
; Save VMB version number so that various code paths can check it
; A zero in VMB_VERSION means that we were started by the release 1 VMB
;
	MOVL	RPB$L_IOVEC(R11),R0	; Address of I/O vectors
	XORW3	BQO$W_VERSION(R0),-
		BQO$W_VERCHECK(R0),R1	; If we have a version #, the
	INCW	R1			; version and its complement are there
	BNEQ	BOOTNDT_TST		; Branch if release 1 VMB
	MOVZWL	BQO$W_VERSION(R0),-
		W^VMB_VERSION		; Save the VMB version number
;
; Determine if VMB has already set up RPB$B_BOOTNDT field.
;
BOOTNDT_TST:
	CMPL	W^VMB_VERSION,#6	; Did VMB set up the BOOTNDT field?
	BGEQ	10$			; Version 6 or later -- yes.
	MOVL	RPB$L_BOOTR1(R11),R1	; Get index to boot adapter.
	MOVZBW	RPB$B_CONFREG(R11)[R1],-; Get boot adapter's nexus device
		RPB$W_BOOTNDT(R11)	; type from RPB$B_CONFREG array.
	BRB	END_BOOTNDT_TST		;
10$:	CMPL	W^VMB_VERSION,#12	; Did VMB init the high byte of
	BGEQ	END_BOOTNDT_TST		;  W_BOOTNDT properly? br if yes.
	CLRB	RPB$W_BOOTNDT+1(R11)	;  Zero the high byte.
END_BOOTNDT_TST:
;
; Determine if VMB has passed in an argument list in AP
;
	CMPL	W^VMB_VERSION,#5	; Is there an argument list in AP?
	BGEQ	1$			; Yes, process it
	BRW	ADD_CACHE		; Branch if not
;
; The argument count field of the argument list describes what
; is present in the argument list.
;
1$:	MOVQ	VMB$Q_FILECACHE(AP),- 	; No additional test
		W^FIL$GQ_CACHE		;  is needed for file cache
	CMPW	#VMB$Q_PFNMAP/4,(AP)	; Are the PFNMAP, LO and HI
					; PFN arguments present?
	BGTR	5$			; Branch if not
	MOVQ	VMB$Q_PFNMAP(AP),-	; Yes, update RPB
		RPB$Q_PFNMAP(R11)	;  descriptor for PFN bitmap
	ASSUME	VMB$L_HI_PFN EQ VMB$L_LO_PFN+4
	MOVQ	VMB$L_LO_PFN(AP),-
		W^MEM_LO_PFN		; Record the low and hi PFN's
	CMPW	#VMB$L_FLAGS/4,(AP)	; Are the UCODE thru FLAGS args present?
	BGTR	5$			; Branch if not
	MOVQ	VMB$Q_UCODE(AP),-	; Yes, move the descriptor
		W^UCODE_LEN
	MOVL	VMB$B_SYSTEMID(AP),-	;  and the system id
		BOO$GB_SYSTEMID
	MOVW	VMB$B_SYSTEMID+4(AP),-
		BOO$GB_SYSTEMID+4
	MOVL	VMB$L_FLAGS(AP),-
		W^VMB_FLAGS 		;  and the flags
	CMPB	#VMB$L_CI_HIPFN/4,(AP)	; Is the CI_HIPFN arg present?
	BGTR	5$			; Branch if not
	MOVL	VMB$L_CI_HIPFN(AP),-
		W^CI_HI_PFN		; Yes, copy it
	CMPB	#VMB$Q_NODENAME/4,(AP)	; Is the NODENAME arg present?
	BGTR	5$			; Branch if not
	TSTL	VMB$Q_NODENAME(AP)	; But is it null?
	BEQL	5$			; Yes, don't copy
	MOVQ	VMB$Q_NODENAME(AP),-
		BOO$GB_NODENAME	; No, copy it
5$:
;
; Get the top level system directory name (if present) out of the name
; of the secondary bootstrap stored by VMB in the RPB.
;
	MOVAB	RPB$T_FILE(R11),R7	; Address of bootstrap name
	MOVZBL	(R7)+,R6		; R6 = size, R7 = adr of string
	LOCC	#^A/]/,R6,(R7)		; Find the directory portion
	BNEQ	10$			; of the name string
	LOCC	#^A/>/,R6,(R7)		; Alternate syntax?
	BEQL	END_LOOKUP		; Branch if no directory present
10$:	INCL	R7			; Step over the open bracket
	SUBL	R7,R1			; Count in directory string
	LOCC	#^A/./,R1,(R7)		; Any top level directory?
	BEQL	END_LOOKUP		; Branch if not
	SUBL	R7,R1			; Size of top level dir name
	CMPL	R1,#9			; Size of name ok?
	BGTR	END_LOOKUP		; Branch if not
	MOVAB	W^FIL$GT_TOPSYS,R3	; Location to store ASCIC string
	MOVB	R1,(R3)+		; Store string size
	MOVC3	R1,(R7),(R3)		; And store the directory name
	BRB	END_LOOKUP
;
; VMB version does not have the FIL$OPENFILE cache
;
ADD_CACHE:
	BSBW	BOO$CACHE_INIT		; Otherwise init our own cache
END_LOOKUP:
	MOVQ	RPB$Q_PFNMAP(R11),R0	; Get descriptor for PFN bitmap
	CMPL	R1,SP			; Is this the small bitmap?
	BLSS	10$			; Branch if yes
	MOVAB	-(R1)[R0],R0		; Address of last byte inclusive
	ASHL	#-9,R0,W^PFNMAP_HI_PFN	; Save highest PFN
10$:
;
; With the latest version of VMB, essentially all the code is already
; gone.  This secondary bootstrap was read in over nearly all the VMB
; code.  So the following code, which used to lay some data over VMB's
; code, now simply places it at the end of SYSBOOT.  Even with old
; versions of VMB this still works since the sum of the 2 bootstraps
; and their data still does not exceed 64kb.
;
OVERLAY_VMB:
	ASSUME	BOO$C_LENGTH&3 EQ 0	; Integral number of long words
	ROTL	#9,#RTRV_PAG_CNT+<<BOO$C_LENGTH-64+511>@-9>,R2
					; If front of Boot Control Block is
					; larger than 64 bytes add a page
	MOVL	W^BOO$GL_FREEMEM,R3	; Place BOOTCB and retrieval pointers
					; at the end of SYSBOOT
	ADDL3	R2,R3,R6		; Note where next free page is
	MOVL	R3,W^BOOTCB		; Address of boot control block
	MOVAL	BOO$C_LENGTH(R3),R3	; First address in rtrv buffer
	MOVAB	-BOO$C_LENGTH(R2),R2	; Size of rtrv buffer
	MOVQ	R2,W^RTRV_BUF_DSC	; Set retrieval buffer descriptor
;
; Allocate space to keep the first block beyond the image header for
; each of the drivers and loadable code.  They must be read in to find
; the size of the driver.  This avoids reading them a second time.
;
	ROTL	#9,S^#<LOAD_IMAGE_CNT+1>,R5 ; No. of bytes needed
	MOVQ	R5,W^VBN2_BUF_DSC	; Save descriptor of buffer space
	ADDL3	R5,R6,W^BOO$GL_FREEMEM	; Note where next free page is

;****************************************************************************
;*	DEALLOCATE ANY PAGES SPECIFIED BY BAD PAGE FILE
;*
;****************************************************************************

CHKVERSION:				; Check for minimum FPLA/WCS/PCS version
	.ENABL	LSB
					;
	CPUDISP	<<780,CHKVERS_780>,-	; *Dispatch on CPU type*
		 <750,CHKVERS_750>,-	; 
		 <730,CHKVERS_730>,-
		 <790,CHKVERS_790>,-
		 <UV1,CHKVERS_UV1>,-
		 <785,CHKVERS_785>>,-
		ENVIRON=VMB

CHKVERS_750:				; For 11/750, check SID
	MOVZBL	#HWREV_750, R2		; R2 <- hardware ECO level
	MOVZBL	#MICREV_750, R3		; R3 <- microcode version
	BRB	CHECK_SID

CHKVERS_730:				; For 11/730, check SID
	MOVZBL	#HWREV_730,R2		; R2 <- hardware ECO level
	MOVZBL	#MICREV_730,R3		; R3 <- microcode version
CHECK_SID:
	MFPR	#PR$_SID,R1		; Get SID
	CMPB	R1, R2			; Current ECO level high enough?
	BLSSU	10$			; Branch if not
CHKVERS_UCODE:
	ASHL	#-8,R1,R1		; Position microcode version
	CMPB	R1, R3			; Current microcode version high enough?
	BLSSU	10$			; Branch if not
	BRW	CHKVERS_END		; Else versions ok
10$:	MSG	<-W-ECO or microcode version less than minimum required for VMS.>
	BRW	BOO_HALT1		; Allow continue command to override
	.DSABL	LSB
					;
CHKVERS_790:				; For 11/790:
	MOVL	#MICREV_REQ_790,R1	; Request microcode revision level
	MOVL	#2,R2			; Number of bytes of data = 2
	MOVAB	W^CPUDATA,R3		; Address of buffer to receive data.
	BSBW	GETCONLOC_790		; Read version from console memory.
	CMPW	W^CPUDATA,#MICREV_790	; Current microcode version ok?
	BLSSU	10$			; Branch if not
	BRW	CHKVERS_END		; Else version ok.
10$:	MSG	<-W-Microcode version less than minimum required for VMS>
	BRW	BOO_HALT1		; Branch to halt.

CHKVERS_UV1:
	MFPR	#PR$_SID,R1		; Get SID
	MOVZBL	#MICREV_UV1,R3		; R3 <- microcode version
	BRW	CHKVERS_UCODE		; Join common code.

CHKVERS_785:
	MOVAB	W^VERSVECT_785,R5	; Get address of 785 version vector.
	PUSHAL	W^VERSNUM_785+4		; Save addr of required 785 values
	BRB	CHK_780_785		; Join common code.

CHKVERS_780:				; For 11/780, continue with check
	MOVAB	W^VERSVECT_780,R5	; Get address of 780 version vector
	PUSHAL	W^VERSNUM_780+4		; Save addr of required 780 values
CHK_780_785:
	MOVAB	W^CPUDATA,R6		; Pointer to extra data
10$:	MOVZBL	(R5)+,R1		; Get offset to version code
	BEQL	30$			; Zero if end of list
20$:	BSBW	GETCONLOC_780		; Ask console for value
	MOVB	R0,(R6)+		; Store it away
	BRB	10$			; Loop

30$:	MOVL	(SP)+,R5		; Retrieve addr of end of required
					; microcode rev levels
	CMPW	-(R6),-(R5)		; Check all microcode versions against
	BLSSU	40$			; minimum required
	CMPB	-(R6),-(R5)
	BLSSU	40$
	CMPB	-(R6),-(R5)
	BLSSU	40$			; Failure
;
; Now pick up FPA status, WCS size, and G&H option flags
;
	MFPR	#PR780$_ACCS,R0		; Pick up FPA status
	ROTL	#-14,R0,R0		; Get bit in right position
	BISB3	#2,R0,W^CPUDATA+4	; Set the flag
	MOVZBL	#GHOPT_VLOC,R1		; Get offset to GH options flags
	BSBW	GETCONLOC_780		; Ask console for value
	BISB3	#1,R0,R0		; Get the flag
	BISB	R0,W^CPUDATA+4		; Set the flag	
	MFPR	#PR$_WCSD,R0		; Get WCS size
	MOVB	R0,W^CPUDATA+5		; Transfer to storage
	BRB	CHKVERS_END		; All okay

40$:	MSG	<-W-FPLA,PCS or WCS version less than minimum required for VMS.>
BOO_HALT1:				;
;
;		Halt removed to leave warning message only.
;
CHKVERS_END:				; *End of CPU-dependent code*
					;
GETCURRENT:				; Read current parameter values
	MOVAB	W^SYS_STAT,R2		; Address of SYSTEM statistics block
5$:	BSBW	IMAGE_OPEN		; Locate SYS.EXE
	BLBS	R0,15$			; Branch if successful
;
; If we were looking for SYS.EXE in SYS0.DIR, then try to boot from
; SYSEXE.DIR in the MFD for compatibility with Release 2 format system disks
;
	TSTB	W^FIL$GT_TOPSYS		; Try this second lookup once only
	BEQL	10$			; Branch if no TOPSYS in use
	CLRB	W^FIL$GT_TOPSYS		; Disable TOPSYS
	CMPB	#^A/0/,W^FIL$GT_TOPSYS+4 ; Trying to boot from [SYS0.SYSEXE]?
	BEQL	5$			; Yes, try again from [SYSEXE]
10$:	MSG	<-F-Unable to locate SYS.EXE>
	HALT				; ***** Fatal Error *****
15$:	MOVL	#1,R3			; Virtual block 1 is image header
	MOVL	W^SYS_STAT+STAT_L_MAP,R4 ; Virtual to logical block map
	MOVL	W^BOO$GL_FREEMEM,R6	; Set buffer address
	ROTL	#9,#1,R9		; Read only header
	BSBW	READ_VIRTUAL		; Read image header
	BLBS	R0,50$			; Branch if successful
	BRW	READ_SYS_ERR		; Error reading SYS.EXE - fatal
50$:	MOVL	R6,R3			; Set base address
	ROTL	#<32-9>,W^SYS_STAT+STAT_L_BYTECNT,R2 ; No. of pages in file
	BSBW	BOO$IMAGE_ATT		; Get image attributes
;
; R1 = count of image header blocks
; R2 = last VBN in image - excluding symbol table and patch text
; R4 = preserved = virtual to logical map
;
	ADDL3	#1,R1,R3		; Starting VBN of image beyond hdr
	MOVL	R3,W^SYS_STAT+STAT_L_VBN ; Save in stat block
	SUBL	R1,R2			; Blocks in image excluding image header
					; symbol table, and patch text
	ASHL	#9,R2,W^SYS_STAT+STAT_L_BYTECNT ; Save byte count of image file
	MOVL	W^BOOTCB,R10		; Address of boot control block
	SUBL3	R10,R4,BOO$L_SYS_MAP(R10) ; Save virtual to logical map
	MOVL	R3,BOO$L_SYS_VBN(R10)	; Save starting VBN of SYS
	MOVL	R2,BOO$L_SYS_SIZE(R10)	; and its size from that VBN
					; to the end of executable image
;
; Add enough space to map for SYS.EXE to convert it into a Window Control Block in
; INIT.  If booting from the console, allow for a couple of extra pointers in case
; we read from another volume(s).
;
	MOVQ	W^RTRV_BUF_DSC,R6	; R6 = size, R7 = address of
					; retrieval buffer
	ASHL	#-3,(R4),R0		; Number of retrieval pointers
	CMPB	RPB$B_DEVTYP(R11),#BTD$K_CONSOLE ; Booting from the console?
	BNEQ	55$			; No
	ADDL2	#3,R0			; Allow a couple of extra pointers for a
					;  segmented read during standalone operation
	SUBL3	#1,R0,W^CONEOF_MAX_PTR	; Store this count, adjusted for the dummy
					;  rtrv pointer needed for each segment
55$:	MULL	#6,R0			; 6 bytes each for WCB
;
; Note that SYS.EXE is smaller than 65K blocks and thus each retrieval
; pointer must be less than 65K blocks.  So 1 retrieval pointer cannot
; result in more than one window control block pointer.
;
	ADDL	#WCB$W_P1_COUNT,R0	; Size required for WCB
	ADDL3	#4,(R4),R1		; Size taken up by map right now
	SUBL	R1,R0			; Additional bytes needed to
					; convert into a Window Control Block
	BLEQ	60$			; Branch if already big enough
	ADDL	#3,R0			; Round up to long word boundary
	BICL	#3,R0			;
	SUBL	R0,R6			; Reserve the additional space
	ADDL	R0,R7			;
60$:
;
; Make separate virtual to logical maps for SYSPARAM and for the
; non-resident portion of BUGCHECK.  This reduces the amount of
; code needed in the system to deal with these portions of SYS.EXE
; that are no longer required to be contiguous.
;
	ADDL	#<MMG$A_SYSPARAM-^X80000000>@-9,R3 ; VBN of SYSPARAM
	MOVL	S^#<<BOO$C_SYSPARSZ+511>@-9>,R5 ; Number of blocks in SYSPARAM
	SUBL3	R10,R7,BOO$L_PARAM_MAP(R10) ; Offset to map for SYSPARAM
	BSBW	BOO$SETMAP		; Set virtual to logical map for
					; SYSPARAM portion of SYS.EXE
	MOVL	W^SYS_STAT+STAT_L_MAP,R4 ; Get map for SYS again
	MOVZWL	#<BUG$A_PAGED-^X80000000>@-9,R3 ; Starting VBN of paged
	ADDL	W^SYS_STAT+STAT_L_VBN,R3 ; BUGCHECK code
	MOVL	S^#<BUG$A_PAGEDEND-BUG$A_PAGED+511>@-9,R5
					; Blocks of paged BUGCHECK code
	SUBL3	R10,R7,BOO$L_BUG_MAP(R10) ; Offset to map for BUGCHECK code
	BSBW	BOO$SETMAP		; Set virtual to logical map for
					; BUGCHECK portion of SYS.EXE
	MOVQ	R6,W^RTRV_BUF_DSC	; Record space used in rtrv ptr buf
;
; Read the sysgen parameters from VAXVMSSYS.PAR
;
	CALLS	#0,BOO$USECUR		; Read the .PAR file
;
; If this is a conversational bootstrap, then prompt terminal for command
; input to specify a starting set of parameters and any modifications 
; desired.  In the event that a conversational boot was not selected and
; there is no current parameter set, the defaults will be used anyway.
;
	BBC	#RPB$V_CONV,RPB$L_BOOTR5(R11),NOCONVER
					; Branch if not conversational
	CALLS	#0,W^BOO$GETPARAM	; Prompt for parameters
;
; Restore fields that could have been destroyed by a USE DEFAULT command.
;
	MOVB	W^CPUTYPE,W^EXE$GB_CPUTYPE ; Restore CPU type to sys params
	MFPR	#PR$_SID,W^EXE$GB_CPUDATA  ; Restore SID to sys params
NOCONVER:
;
; Set paged code boundary in SYSPARAM area with value assembled into SYSBOOT
	MOVL	BOO$GL_PGDCOD,W^MMG$GL_PGDCOD;

;
; Now open SYSDUMP.DMP and record its retrieval pointers in the
; boot control block.
;
	MOVL	#1,BOO$L_DMP_VBN(R10)	; Set dump file starting VBN

	ASSUME	BOO$L_DMP_MAP EQ BOO$L_DMP_SIZE+4
	CLRQ	BOO$L_DMP_SIZE(R10)	; Zero size and map in case no dump file
	MOVAB	W^SYSDUMP_STAT,R2	; Adr of SYSDUMP stat block
	CLRL	W^EXE$GW_PGFL_FID	; No file id for page file
	CLRW	W^EXE$GW_PGFL_FID+4	;
	BBCC	S^#EXE$V_PAGFILDMP,W^EXE$GL_DEFFLAGS,10$ ; Assume dump is
					; not going to be in the page file
10$:	MOVQ	W^RTRV_BUF_DSC,R4	; Save old descriptor for size check
	MOVAL	@#BOO$GT_SYSDUMP,STAT_L_NAME(R2) ; Look up SYSDUMP.DMP
	BSBW	IMAGE_OPEN		; Locate SYSDUMP.DMP
	BLBC	R0,15$			; Branch if not found
	SUBL3	W^RTRV_BUF_DSC,R4,R6	; Bytes used for dump file
	CMPL	R6,-			; See if we used less than half
		#<<RTRV_PAG_CNT*512>-BOO$C_LENGTH>/2
	BLSS	20$			; No problem
	MOVQ	R4,W^RTRV_BUF_DSC	; Forget about dump
	MSG	<-W-DMPFRG SYSDUMP.DMP is too fragmented to be used>
	BRB	60$
15$:	MOVAB	@#BOO$GT_PAGEFILE,STAT_L_NAME(R2) ; Didn't find SYSDUMP.DMP
	BSBW	IMAGE_OPEN		; Lookup PAGEFILE.SYS instead
	BLBC	R0,60$			; Branch if this failed too
	MOVL	FH2$W_FID_NUM(R1),W^EXE$GW_PGFL_FID ; Save the file id
	MOVW	FH2$W_FID_RVN(R1),W^EXE$GW_PGFL_FID+4 ; for the page file
	BBSS	S^#EXE$V_PAGFILDMP,W^EXE$GL_DEFFLAGS,20$ ; Note dump file
					; is at the front of the page file
20$:	ROTL	#<32-9>,STAT_L_BYTECNT(R2),- ; Record size of file
		BOO$L_DMP_SIZE(R10)	; in blocks
	SUBL3	R10,STAT_L_MAP(R2),BOO$L_DMP_MAP(R10) ; Offset to SYSDUMP map

;
; Now calculate the size of nonpaged pool needed for the bootstrap
; system disk driver.  This includes the BOOTCB (boot control block)
; and any possible ucode file needed.
;
60$:	MOVQ	W^RTRV_BUF_DSC,R6	; Get size and adr of what remains
					; of the retrieval pointer buffer
					; R7 = end of BOOTCB
	SUBL3	R10,R7,R0		; BOOTCB size
	MOVW	R0,BOO$W_SIZE(R10)	; Save size in BOOTCB
	MOVZWL	R0,BOO$L_CHECKSUM(R10)	; Save size to checksum for INIT
	MOVW	#<DYN$C_BOOTCB@8!DYN$C_INIT>,-
		BOO$B_TYPE(R10)		; Set type and subtype
	ADDL2	W^UCODE_LEN,R0		; Add in any possible ucode file size
	ADDL3	RPB$L_IOVECSZ(R11),R0,-	; Save size with Boot Driver added
		W^BOODRV_STAT+STAT_L_BYTECNT
					; in Boot Driver statistics block
	CLRQ	(R7)+			; Since allocation will be rounded
	CLRQ	(R7)+			; up to 16 byte boundary, clean out
					; any left over garbage
	SUBL	#16,R6			; and allocate an additional 16 bytes
	MOVQ	R6,W^RTRV_BUF_DSC	; of retrieval buffer space
;
; The boot device driver file will be opened and read to obtain
; the driver size.  This will be passed to the EXEC initialization.
; Determining the name of the boot driver file is done differently,
; depending on the version of VMB being used.
;
LOOKUPDRIVER:
	TSTL	W^VMB_VERSION		; Release 2 or later VMB?
	BEQL	2$			; Branch if not
	MOVL	RPB$L_IOVEC(R11),R0	; Get address of I/O vectors
	MOVAB	@BQO$L_DRIVRNAME(R0)[R0],R4 ; Yes, get addr. of driver name list
	CMPL	W^VMB_VERSION,#10	; Is it version 10?
	BLSS	19$			; No, skip this
	MOVAB	@BQO$L_DEVNAME(R0)[R0],R1 ; Yes, transfer boot device name
	MOVZWL	(R1),L^BOO$GL_DEVNAME	;  to BOOPARAM block
19$:	BRW	20$

;
; The type of boot device will be determined and the proper driver file 
; will be looked up and read to obtain the proper driver size. This will
; be passed to the exec initialization.  If the type of boot
; device does not correspond to one of the standard disk devices, then
; the driver name will be set to UNKDRIVER.EXE and a fatal error message
; given if the driver file is not found.
;
2$:
	MOVL	RPB$L_ADPPHY(R11),R5	; Get physical address of bus adapter
	CMPB	RPB$B_DEVTYP(R11),-	; Booting from console block
		#BTD$K_CONSOLE		; storage device?
	BNEQ	5$			; No
	MOVAB	W^DDNAME,R4		; Yes, assume TU58
	CPUDISP	<<780,4$>,-		; 11/780 floppy
		 <750,20$>,-		; 11/750 TU58
		 <730,20$>,-		; 11/730 TU58
		 <UV1,20$>,-		; MicroVAX I should never get here
		>,-			;
		ENVIRON=VMB
					; This code path can't be executed on 11/790

4$:	MOVAB	W^DXNAME,R4		; Console RX01 driver name
	BRB	20$

5$:	CASE	RPB$B_DEVTYP(R11),<-	; Case on boot device type
		10$,-			; MASSBUS device
		9$,-			; RK06/7
		8$,-			; RL02
		>,LIMIT=#BTD$K_MB,TYPE=B
	BRB	12$			; Unknown device

8$:	MOVAB	W^DLNAME,R4		; RL02 driver name
	BRB	20$
9$:	MOVAB	W^DMNAME,R4		; RK06/7 driver name
	BRB	20$			;
10$:	MOVAB	^X400(R5),R5		; Compute address of device registers
	INSV	RPB$W_UNIT(R11),#7,#3,R5; For boot device
	MOVL	RP_DT(R5),R0		; Read device type number
	MOVAB	W^DBNAME,R4		; Assume RP04/RP05/RP06 (DBDRIVER)
	CMPB	R0,#^X12		; Is drive type = RP04/5/6
	BLEQ	20$			; Branch if yes
	CMPB	#^X14,R0		; Is device RM03?
	BEQL	15$			; Yes
	CMPB	#^X16,R0		; IS DEVICE = RM80?
	BEQL	15$			; IF EQL, YES
	CMPB	#^X17,R0		; IS DEVICE = RM05?
	BEQL	15$			; IF EQL, YES
	CMPB	#^X22,R0		; IS DEVICE = RP07?
	BEQL	15$			; Yes
12$:	MOVAB	W^UNKNAME,R4		; Use driver for unknown devices
	BRB	20$			;
15$:	MOVAB	W^DRNAME,R4		; Use DRDRIVER for RM03/RP07
20$:	CMPL	W^VMB_VERSION,#3	; Did this VMB set up the MEMDSC in RPB?
	BGEQ	25$			; Branch if it did
	BSBW	ADD_RPB_MEMDSC		; PUT MEMDSC IN RPB
25$:	SUBL3	W^SYSBOOT_BASE,R4,-	; Save base relative address
		W^DSKDRV_STAT+STAT_L_NAME ;  of driver name
	CMPL	W^VMB_VERSION,#7	; Version 7 or greater?
	BLSS	30$			; No, leave now
	MOVL	RPB$L_IOVEC(R11),R0	; Get address of I/O vectors
	MOVL	BQO$L_AUXDRNAME(R0),R4	; Get addr. of aux driver name list
	BEQL	27$			; None, leave
	ADDL2	R0,R4			; Get absolute address
	SUBL3	W^SYSBOOT_BASE,R4,-	; Save base relative address
		W^PRTDRV_STAT+STAT_L_NAME ;  of driver name
27$:
	CMPL	W^VMB_VERSION,#9	; Did VMB set up RPB BADPGS field?
	BGEQ	30$			; Yes, leave now
	CLRL	RPB$L_BADPGS(R11)	; Zero number of bad pages found in
					; bootstrap memory scan.
30$:
	CMPL	W^VMB_VERSION,#13	; Did VMB set up RPB CTRLLTR field?
	BGEQ	40$			; Yes, leave now.
	CLRB	RPB$B_CTRLLTR(R11)	; Zero controller letter field.
40$:
;
; Derive the name of the image containing  loadabe CPU-dependent
; code.  Image names supported thus far:
;
;	SYSLOA780.EXE	if CPU_TYPE has PR$_SID_TYP780.
;	SYSLOA750.EXE	if CPU_TYPE has PR$_SID_TYP750.
;	SYSLOA730.EXE	if CPU_TYPE has PR$_SID_TYP730.
;	SYSLOA790.EXE	if CPU_TYPE has PR$_SID_TYP790.
;	SYSLOAUV1.EXE	if CPU_TYPE has PR$_SID_TYPUV1.
;	SYSLOAWS1.EXE	if CPU_TYPE has PR$_SID_TYPUV1 and bit 6 in boot r1 is set.
;
;
	MOVZBL	W^EXE$GB_CPUTYPE,R0	; Get CPU type code
	MOVAL	W^MODEL_TABLE-4[R0],R6	; Get addr of model list
	MOVC3	#3,(R6),W^NAME_XXX	; Copy model name into XXX
					;  field of SYSLOAXXX.EXE
	
;
; Conditionally look up loadable $ERAPAT code (ERAPATLOA.EXE).
;
LOOKUP_LOADABLE_CODE:
	BBS	S^#SGN$V_LOADERAPAT,-	; Is $ERAPAT load flag set?
		W^SGN$GL_LOADFLAGS,20$	;  if so, branch around the CLRL
	CLRL	W^ERAPATLOA_STAT+STAT_L_NAME ; Set for no lookup

;
; Conditionally look up loadable $CHKPRT code (CHKPRTLOA.EXE).
;
20$:	BBS	S^#SGN$V_LOADCHKPRT,-	; Is $CHKPRT load flag set?
		W^SGN$GL_LOADFLAGS,25$	;  if so, branch around the CLRL
	CLRL	W^CHKPRTLOA_STAT+STAT_L_NAME ; Set for no lookup

; Conditionally look up loadable $MTACCESS code (MTACCESS.EXE).

25$:	BBS	S^#SGN$V_LOADMTACCESS,W^SGN$GL_LOADFLAGS,30$ ; If SET branch around
	CLRL	W^MTACCESSLOA_STAT+STAT_L_NAME ; Set for no look up
;
; Conditionally look up loadable SCS code (SCSLOA.EXE).
; Conditionally lookup loadable cluster code (CLUSTRLOA.EXE).
;
30$:	CMPB	W^CLU$GB_VAXCLUSTER,#1	; Test VAXCLUSTER parameter
	BGTRU	40$			; Load SCSLOA and CLUSTRLOA
	BEQLU	32$			; Branch if VAXCLUSTER = 1
	CLRL	W^CLSLOA_STAT+STAT_L_NAME ; Set for no CLUSTRLOA lookup
32$:
	ASSUME	VMB$V_LOAD_SCS EQ 0
	BLBS	W^VMB_FLAGS,40$		; Look it up
	CLRL	W^SCSLOA_STAT+STAT_L_NAME ; Set for no SCSLOA lookup
	CLRL	W^CLSLOA_STAT+STAT_L_NAME ; Set for no CLUSTRLOA lookup
40$:
;
; Check for the presence of the TBCHK processor register.
;
	BBCC	S^#EXE$V_TBCHK,-	; Clear it out befor we check
		W^EXE$GL_DEFFLAGS,43$
43$:	MFPR	#PR$_SCBB,R8		; Pick up address of SCCB
	PUSHL	^X18(R8)		; Save RESERVED OPERAND slot
	MOVL	SP,R7			; Save stack
	MOVAB	B^44$,^X18(R8)		; Put in new handler
	MTPR	R0,#PR$_TBCHK		; Try to write it
	BBSS	S^#EXE$V_TBCHK,-
		W^EXE$GL_DEFFLAGS,44$	; It worked so set the bit
	BRB	44$
	.ALIGN	LONG			; Vectors must be on longword boundary
44$:	MOVL	R7,SP			; Restore stack
	POPL	^X18(R8)		; Restore RESERVED OPERAND
	.ENABL	LSB
;
; Check for the presence of each category of instructions that might
; have to be emulated:  character string, decimal, EDITPC, CRC and the 
; floating point data types.  Set an indicator for any that must be 
; emulated by software.
;
; WARNING:  This code cannot be debugged with XDELTA, if string instructions
; 	    are being emulated because this testing replaces the emulation
;	    handlers temporarily!
;

	ASSUME ARC$V_DCML_EMUL EQ <ARC$V_CHAR_EMUL + 1>
	ASSUME ARC$V_EDPC_EMUL EQ <ARC$V_DCML_EMUL + 1>
	ASSUME ARC$V_CRC_EMUL EQ <ARC$V_EDPC_EMUL + 1>
	ASSUME ARC$V_DFLT_EMUL EQ <ARC$V_CRC_EMUL + 1>
	ASSUME ARC$V_FFLT_EMUL EQ <ARC$V_DFLT_EMUL + 1>
	ASSUME ARC$V_GFLT_EMUL EQ <ARC$V_FFLT_EMUL + 1>
	ASSUME ARC$V_HFLT_EMUL EQ <ARC$V_GFLT_EMUL + 1>

	PUSHL	^X10(R8)		; Remember OPCDEC vector contents
	PUSHL	^XC8(R8)		; Remember emulation vector contents
	PUSHL	^XCC(R8)		; Remember FPD emulation vector contents
	PUSHR	#^M<R0,R1,R2,R3,R4,R5,R6,R7> ; Save volatile registers
	CLRL	W^EXE$GL_ARCHFLAG	; Clear all indicators initially
	MOVAB	W^45$,^X10(R8)		; Put in new OPCDEC handler
	MOVAB	W^46$,^XC8(R8)		; Put in new emulation handler
	MOVAB	W^45$,^XCC(R8)		; Put in new FPD emulation handler
	MOVZBL	#ARC$V_CHAR_EMUL,R6	; Bit indicator for character string ins
;
; MATCHC was chosen as the sample string instruction to be executed
; because it is the least likely character instruction to be implemented.
;
	.MDELETE MATCHC
	MOVZBL	#MATCHC_INS_SZ,R7	; Remember size of MATCHC instruction
MATCHC_INS:
	MATCHC	#1,W^STRING,#1,W^STRING	; Execute a character string ins
MATCHC_INS_SZ = . - MATCHC_INS

;
; DIVP was chose as the sample decimal instruction to be executed
; because it is the least likely decimal instruction to be implemented.
;
	INCL	R6			; Bit indicator for decimal instruction
	.MDELETE DIVP
	MOVZBL	#DIVP_INS_SZ,R7		; Remember size of DIVP instruction
DIVP_INS:
	DIVP	#1,W^DENOMINATOR,-	; Execute a decimal instruction
		#1,W^NUMERATOR,-
		#1,W^QUOTIENT
DIVP_INS_SZ = . - DIVP_INS

;
; This EDITPC instruction does nothing but test if software emulation is
; needed for this instruction.
;
	INCL	R6			; Bit indicator for EDITPC instruction
	.MDELETE EDITPC
	MOVZBL	#EDITPC_INS_SZ,R7	; Remember size of EDITPC instruction
EDITPC_INS:
	EDITPC	#1,W^NUMERATOR,W^PATTERN,W^QUOTIENT ; Execute an EDITPC instruction
EDITPC_INS_SZ = . - EDITPC_INS

;
; This CRC produces a garbage result but it tests if software emulation is
; needed for this instruction.
;
TBL:	INCL	R6			; Bit indicator for CRC instruction
	.MDELETE CRC
	CLRL	R0			; Set inicrc to zero
	MOVZBL	#CRC_INS_SZ,R7		; Remember size of CRC instruction
CRC_INS:
	CRC	TBL,-			; Choose useless address for tbl address
		R0,#1,W^STRING		; Use same string as in MATCHC test
CRC_INS_SZ = . - CRC_INS

;
; This is a sample D floating point instruction.  It was chosen because
; it is one of the simplest D instructions.
;
	INCL	R6			; Bit indicator for D floating point
	.MDELETE MOVD
	MOVZBL	#MOVD_INS_SZ,R7		; Remember size of MOVD instruction
MOVD_INS:
	MOVD	S^#00,R0		; Execute an D floating point instruction
MOVD_INS_SZ = . - MOVD_INS

;
; This is a sample F floating point instruction.  It was chosen because
; it is one of the simplest F instructions.
;
	INCL	R6			; Bit indicator for F floating point
	.MDELETE MOVF
	MOVZBL	#MOVF_INS_SZ,R7		; Remember size of MOVF instruction
MOVF_INS:
	MOVF	S^#00,R0		; Execute an F floating point instruction
MOVF_INS_SZ = . - MOVF_INS

;
; This is a sample G floating point instruction.  It was chosen because
; it is one of the simplest G instructions.
;
	INCL	R6			; Bit indicator for G floating point
	.MDELETE MOVG
	MOVZBL	#MOVG_INS_SZ,R7		; Remember size of MOVG instruction
MOVG_INS:
	MOVG	S^#00,R0		; Execute an G floating point instruction
MOVG_INS_SZ = . - MOVG_INS

;
; This is a sample H floating point instruction.  It was chosen because
; it is one of the simplest H instructions.
;
	INCL	R6			; Bit indicator for H floating point
	.MDELETE MOVH
	MOVZBL	#MOVH_INS_SZ,R7		; Remember size of MOVH instruction
MOVH_INS:
	MOVH	S^#00,R0		; Execute an H floating point instruction
MOVH_INS_SZ = . - MOVH_INS

	BRB	47$			; All done, go restore OPCDEC handler

;
; Temporary OPCDEC and FPD emulation exception handlers
;
	.ALIGN	LONG
45$:	BBSS	R6,W^EXE$GL_ARCHFLAG,145$ ; Indicate data type must be emulated
145$:	ADDL	R7,(SP)			; Point past instruction causing fault
	BICL	#PSL$M_TBIT,4(SP)	; Clear T-bit for use with XDELTA
	REI

;
; Temporary emulation exception handler
;
	.ALIGN	LONG
46$:	BBSS	R6,W^EXE$GL_ARCHFLAG,146$ ; Indicate data type must be emulated
146$:	ADDL	#40,SP			; Clean off emulation parameters
	BICL	#PSL$M_TBIT,4(SP)	; Clear T-bit for use with XDELTA
	REI

;
; The following data areas are used to execute sample instructions
; from all the classes that may have to be emulated via software.
;
STRING:	.ASCII	"A"
NUMERATOR:
	.PACKED	3			; Simple dividend
DENOMINATOR:
	.PACKED	3			; Nonzero divisor
QUOTIENT:
	.BLKL	1			; This cell must be writable

PATTERN:
	EO$MOVE	1
	EO$END

;
; Now check to see what software emulation images must be loaded.
;
47$:					;
	BITL	#<ARC$M_CHAR_EMUL!ARC$M_DCML_EMUL!ARC$M_CRC_EMUL!ARC$M_EDPC_EMUL>,-
		W^EXE$GL_ARCHFLAG	; Any char/dcml/editpc/crc emul needed?
	BNEQ	48$			; Br if emulation needed
	CLRL	W^VAXEMUL_STAT+STAT_L_NAME ; Set for no lookup of image
48$:
	BITL	#<ARC$M_DFLT_EMUL!ARC$M_FFLT_EMUL!ARC$M_GFLT_EMUL!ARC$M_HFLT_EMUL>,-
		W^EXE$GL_ARCHFLAG	; Any floating emulation needed?
	BNEQ	49$			; Br if emulation needed
	CLRL	W^FPEMUL_STAT+STAT_L_NAME ; Set for no lookup of image
49$:
	POPR	#^M<R0,R1,R2,R3,R4,R5,R6,R7> ; Restore volatile registers
	POPL	^XCC(R8)		; Restore FPD emualtion vector contents
	POPL	^XC8(R8)		; Restore emulation vector contents
	POPL	^X10(R8)		; Restore OPCDEC vector contents
	.DSABL	LSB
	MOVW	W^TTY$GW_CLASSNAM,TTNAME+1 ; Set ttdriver 2 letter prefix
;
; Look up the various images that need to be loaded. If there is a name,
; then open the image, derive and store the VBN of the first VBN past
; the image header and size (bytes) of the image excluding the image header.
;
	MOVAB	W^DSKDRV_STAT,R2	; Get adr of first stat block
	MOVL	S^#LOAD_IMAGE_CNT,R5	; Number of them to do
50$:	TSTL	STAT_L_NAME(R2)		; Is there a name?
	BEQL	60$			; No, do not do anything
	BSBW	IMAGE_INIT		; Open image, read 1st block beyond hdr
	MOVZWL	DPT$W_SIZE(R6),-
		STAT_L_BYTECNT(R2)	; Number of bytes in load image.
60$:	ADDL	#STAT_C_SIZE,R2		; Step to next driver
	SOBGTR	R5,50$			; Do them all
;
; All lookups are now complete, truncate the FIL$OPENFILE cache
;
LOOKUP_ALL_DONE:
	CALLS	#0,FIL$CACHE_TRUNC	; Truncate the FIL$OPENFILE cache
	MOVQ	W^FIL$GQ_CACHE,R0	; Get size and address
	MOVAB	-(R1)[R0],R0		; Form last byte inclusive
	ASHL	#-9,R0,W^CACHE_HI_PFN	; Save last PFN in FIL$OPENFILE cache
HAVEPRM:				; All parameter values have been acquired
;
; Acquire some useful information about the hardware/WCS we are running on.
;
	MOVQ	W^CPUDATA,W^EXE$GB_CPUDATA+4	; First longword contains SID.
;
;	Use only specified number of physical pages to permit the testing
;	of small memory configurations without actually reconfiguring hardware.
;
	.ENABL	LSB
	MOVQ	RPB$Q_PFNMAP(R11),R0	; Get descriptor for PFN bitmap
	MULL	#8,R0			; Scale byte count to bit count
	SUBL3	#1,R0,W^MMG$GL_MAXMEM	; Assume all of memory is useable
	MOVL	W^MMG$GL_PHYPGCNT,R2	; Get count of pages to use
	CLRQ	R3			; Initialize bit pointer
					; R4 = 0, have not discarded
					; an otherwise usable PFN yet
10$:	BBC	R3,(R1),20$		; Skip over empty pages
	DECL	R2			; Count a present page
	BGEQ	20$			; Continue if count not exhausted
	BBSS	#0,R4,17$		; Branch if not first discarded PFN
	SUBL3	#1,R3,W^MMG$GL_MAXMEM	; Save highest useable PFN
	TSTL	W^PFNMAP_HI_PFN		; Are we already safe
	BEQL	12$			; Yes
	BSBW	MOVE_BITMAP		; Try to move the bitmap to a safer place
	CMPL	R3,W^PFNMAP_HI_PFN	; Discarding bitmap pages?
	BLEQ	PHYP_ER
12$:	CMPL	R3,W^CACHE_HI_PFN	; Discarding FIL$OPENFILE cache?
	BGTR	15$			; Branch if not
	CLRQ	W^FIL$GQ_CACHE		; Yes, disable it
	CLRL	W^CACHE_HI_PFN
15$:	CMPL	R3,W^CI_HI_PFN		; Bumped into the CI micro code?
	BLEQ	21$			; Branch if so
17$:	BBCC	R3,(R1),20$		; Remove all pages once count exhausted
20$:	AOBLSS	R0,R3,10$		; Scan entire bitmap
	BRB	SHELLSIZE

21$:	BRW	BUMP_CI			; Give error message
;
PHYP_ER:
	MSG	<-F-PFN bit map conflict - Physical page count set too low>
	HALT
	.DSABL	LSB

;
;	COMPUTE VALUES FOR SHELL PROCESS FROM SYSGEN PARAMETERS
;
SHELLSIZE:				;
	ASHL	#2,W^SGN$GL_MAXVPGCT,R2	; 4*VIRTUALPAGE COUNT=BYTES OF PGTBL
	MOVAB	511(R2),R2		; ROUND UP TO PAGE BOUNDARY	
	ASHL	#-9,R2,R2		; DIVIDE BY 512 TO GET COUNT OF PAGES
	MOVL	R2,W^SGN$GL_PTPAGCNT	; SAVE COUNT OF PAGE TABLES
;
;	COMPUTE SIZE OF WSL PART OF PHD
;
	MULL3	#WSL$C_LENGTH,W^SGN$GL_MAXWSCNT,R3; SIZE OF WSLIST
	MULL3	#WSL$C_LENGTH,W^PQL$GDWSDEFAULT,R1; SIZE OF DEFAULT WSLIST
	SUBL3	R1,R3,R1			; FIND EMPTY BYTE COUNT
	MOVAB	<PHD$C_LENGTH+511>(R3),R3	; ADD FIXED SIZE AND ROUNDING
	MULW3	#SEC$C_LENGTH,W^SGN$GW_MAXPSTCT,R0; GUARANTEED SECTION SPACE
	MOVZWL	R0,R0			; ZERO EXTEND TO LONGWORD
	ADDL	R0,R3			; ADD TO FIXED AND WSL
	ASHL	#-9,R3,R3		; GET PAGE COUNT
	ASHL	#-9,R1,R1		; AND EMPTY PAGE COUNT
	SUBW3	R1,R3,W^SWP$GW_WSLPTE	; COUNT OF FIXED +WSL PAGES
	MOVW	R1,W^SWP$GW_EMPTPTE	; COUNT OF EMPTY PTE
	MOVL	R3,R0			; COUNT OF ALL WSL+FIXED PAGES
	ASHL	#9,R3,R3		; BACK TO BYTE COUNT
	MOVAB	511(R3),R3		; ADD PAGE ROUNDING FACTOR
	ADDL	R2,R0			; GET TOTAL HEADER PAGE COUNT
	MULL	#8,R0			; WSLX+BAK+LCK+VAL = 2+4+1+1
10$:	ADDL	R0,R3			; HEADER BYTE COUNT
	ASHL	#-9,R0,R0		; CONVERT ADDED BYTES TO PAGES
	MULL	#8,R0			; ADDED PAGES BACK TO ADDED BYTES
	BNEQ	10$			; REPEAT IF SIGNIFICANT
	ASHL	#-9,R3,R3		; GET TOTAL PAGE COUNT
	MOVL	R3,W^SGN$GL_PHDPAGCT	; SAVE TOTAL
	ASHL	#9,R3,R0		; GET BYTE COUNT FOR PHD
	SUBL3	R0,-			;
		#<^X80000000-<<<128*<SWP$C_DBGPTCNT+SWP$C_SHLP1PT>>-
		-SWP$C_SHLFPTE>@9>>,-	;
		W^MMG$GL_CTLBASVA	; SET CONTROL REGION BASE VA
	MOVL	W^MMG$GL_CTLBASVA,W^SWP$GL_PHDBASVA; AND SWAPPER VERSION
	SUBL3	R1,R3,W^SGN$GL_PHDAPCNT	; TOTAL ALLOCATED PAGES FOR SHELL PHD
	MOVW	R3,W^SWP$GW_BAKPTE	; SET AS TOTAL BAK PTE
	SUBW	W^SWP$GW_WSLPTE,W^SWP$GW_BAKPTE	;
	SUBW	R1,W^SWP$GW_BAKPTE	; SUBTRACT WSL AND EMPTY  TO GET BAK
	ASHL	#7,R3,W^SGN$GL_PHDLWCNT	; COUNT OF LONGWORDS IN PHD
	ADDL3	R2,R3,R0		; TOTAL PAGES
	ASHL	#7,R0,W^SGN$GL_P1LWCNT	; LW COUNT TO P1PT END
	CLRL	R4			; ASSUME NO EXTENTION PAGES
	ADDL3	#<127-SWP$C_SHLFPTE>,W^SGN$GL_PHDPAGCT,R0 ; COMPUTE TOTAL
	BLEQ	15$			; BRANCH IF NO EXTENTION PAGES NEEDED
	ASHL	#-7,R0,R4		; COUNT OF EXTENSION PAGES
15$:	ADDL	S^#SWP$C_SHLP1PT,R4	; TOTAL SHELL P1 PAGE TABLES
	MOVL	R4,W^SWP$GB_SHLP1PT	; SAVE RESULT
	ADDL	S^#SWP$C_KSTACK,R4	; ADD STACK
	ADDL	W^SGN$GL_PHDAPCNT,R4	; ADD ACTUAL PHD PAGE COUNT
	ADDL	S^#SWP$C_NDYN+1,R4	; VECTOR PAGE + DYNAMIC PAGES
	MOVL	R4,W^SWP$GL_SHELLSIZ	; SAVE SHELL SIZE TOTAL
;
;	Check  maximum and default process working set values to ensure
;	that they are at least large enough to contain the process header
;	plus the specified fluid working set.
;
	MOVZBL	W^SWP$GB_SHLP1PT,-(SP)	; GET COUNT OF MANDATORY PAGE TABLES
	MOVZWL	W^SGN$GW_MINWSCNT,R0	; GET MINIMUM FLUID WORKING SET
	ADDL	R0,R0			; DOUBLE FLUID REQUIREMENT
	ADDL	W^SGN$GL_PHDPAGCT,R0	; ADD MIN PROCESS HEADER SIZE
	ADDL	(SP)+,R0		; ADD COUNT OF NECESSARY PAGE TABLES
	ADDL	S^#SWP$C_KSTACK+1,R0	; ADD KERNEL STACK AND VECTOR PAGE
	CMPL	R0,W^SGN$GL_MAXWSCNT	; MUST BE LESS THAN THE TOTAL WORKING SET
	BLEQ	20$			; CONTINUE IF SO
	MOVL	R0,W^SGN$GL_MAXWSCNT	; FORCE TO  AT LEAST MINIMUM VALUE
	MSG	<-W-Maximum WS raised to PHD+MINWSCNT>
	BRW	HAVEPRM			; RECYCLE TO RECOMPUTE SIZES
20$:	CMPL	R0,PQL$GDWSDEFAULT	; MUST ALSO HAVE LARGE ENOUGH DEFAULT
	BLEQ	30$			; CONTINUE IF SO
	MOVL	R0,W^PQL$GDWSDEFAULT	; FORCE DEFAULT TO PROPER VALUE
	MOVL	R0,W^PQL$GMWSDEFAULT	; ALSO MINIMUM DEFAULT
	MOVL	R0,W^PQL$GDWSQUOTA	; AND WS QUOTA
	MOVL	R0,W^PQL$GMWSQUOTA	; AND MINIMUM QUOTA
	MSG	<-W-WS default and quota raised to PHD+MINWSCNT>
	BRW	HAVEPRM			; REPEAT CALCULATION
30$:					;
	MOVL	W^SGN$GL_MAXWSCNT,R0	; GET MAXIMUM SIZE OF WS
	CMPL	R0,W^PQL$GDWSQUOTA	; DEFAULT MUST BE LESS THAN MAX
	BGEQ	40$			; YES, CONTINUE
	MOVL	R0,W^PQL$GDWSQUOTA	; LIMIT DEFAULT TO MAXIMUM
	BRW	HAVEPRM			; RECYCLE THROUGH CALCULATIONS
40$:	CMPL	R0,W^PQL$GMWSQUOTA	; SAME FOR MINIMUM DEFAULT WS
	BGEQ	50$			; OK, CONTINUE
	MOVL	R0,W^PQL$GMWSQUOTA	; LIMIT TO MAXIMUM
	BRW	HAVEPRM			; RECYCLE THROUGH CALCULATIONS
50$:	CMPL	W^PQL$GDWSQUOTA,W^PQL$GDWSDEFAULT ; DEFAULT MUST BE LEQ QUOTA
	BGEQ	60$			; YES, CONTINUE
	MOVL	W^PQL$GDWSQUOTA,W^PQL$GDWSDEFAULT; LIMIT DEFAULT TO QUOTA
	BRW	HAVEPRM			; RECYCLE THROUG CALCULATIONS
60$:	CMPL	W^PQL$GMWSQUOTA,W^PQL$GMWSDEFAULT; SAME FOR MINIMUMS
	BGEQ	70$			; OK, CONTINUE
	MOVL	W^PQL$GMWSQUOTA,W^PQL$GMWSDEFAULT; LIMIT TO QUOTA
	BRW	HAVEPRM			; RECYCLE THROUGH CALCULATIONS
70$:					;
	ADDL3	W^SGN$GL_PHDPAGCT,W^SGN$GL_PTPAGCNT,R4	; GET TOTAL BALANCE SLOT PAGES
	MOVL	R4,W^SWP$GL_BSLOTSZ	; SAVE SIZE OF BALANCE SLOT IN PAGES
	MULL	W^SGN$GL_BALSETCT,R4	; TOTAL PAGE REQ FOR BALANCE SLOTS
NPAGE_SPT:
	BICL	#^X1FF,W^SGN$GL_NPAGEDYN	; ROUND DOWN TO PAGE BOUND
	BICL	#^X1FF,W^SGN$GL_NPAGEVIR	; ROUND DOWN TO PAGE BOUND
	CMPL	W^SGN$GL_NPAGEVIR,W^SGN$GL_NPAGEDYN ; MAXIMIZE WITH DYN VALUE
	BGEQ	10$			; BR IF VIR SUFFICIENT
	MOVL	W^SGN$GL_NPAGEDYN,W^SGN$GL_NPAGEVIR ; USE LARGER VALUE
10$:	BICL	#^X1FF,W^SGN$GL_PAGEDYN	; ROUND DOWN TO PAGE BOUND
	ADDL3	W^SGN$GL_PAGEDYN,W^SGN$GL_NPAGEVIR,R0 ; TOTAL POOL BYTES
	ASHL	#-9,R0,R0		; CONVERT TO PAGE COUNT
	ADDL	R0,R4			; TOTAL DYNAMIC SPT SO FAR
IRP_SPT:
	CMPL	W^SGN$GL_IRPCNTV,W^SGN$GL_IRPCNT ; CHECK I/O PACKET COUNT
	BGEQ	10$			; MAXIMIZE WITH IRPCNT
	MOVL	W^SGN$GL_IRPCNT,W^SGN$GL_IRPCNTV ; USE COUNT
10$:	MULL3	#<IRP$C_LENGTH+^XF>&<^C<^XF>>,-
		W^SGN$GL_IRPCNTV,R1	 ; CALCULATE TOTAL BYTES
	MOVAB	511(R1),R1		; ROUND TO PAGE BOUND
	ASHL	#-9,R1,R1		; CONVERT TO PAGE COUNT
	ADDL	R1,R4			; ADD TO SPT TOTAL

;
; NOW ESTABLISH THE SPT REQUIRED FOR THE LRP LIST
;
LRP_SPT:
	CMPL	#<<IRP$C_LENGTH+^XF>&<^C<^XF>>>,-
		W^SGN$GL_LRPSIZE	; IS PACKET SIZE TOO SMALL ?
	BLEQ	30$			; IF LEQ, NO

	ASSUME	IRP$C_LENGTH LE <^XF0>
	MOVZBL	#<<IRP$C_LENGTH+^XF>&<^C<^XF>>>,-
		W^SGN$GL_LRPSIZE 	; FORCE SIZE TO MINIMUM
30$:	ADDL3	#CXB$C_OVERHEAD+^XF,-	; COMPUTE NEW LRP SIZE AND PREPARE
		W^SGN$GL_LRPSIZE,R1	; FOR ROUNDING
	BICL3	#^XF,R1,L^BOO$GL_LRPSIZE; ROUND SIZE TO MULTIPLE OF 16
	CMPL	W^SGN$GL_LRPCNTV,W^SGN$GL_LRPCNT ; CHECK I/O PACKET COUNT
	BGEQ	40$			; MAXIMIZE WITH LRPCNT
	MOVL	W^SGN$GL_LRPCNT,W^SGN$GL_LRPCNTV ; USE COUNT
40$:	MULL3	L^BOO$GL_LRPSIZE,W^SGN$GL_LRPCNTV,R1	; CALCULATE TOTAL BYTES
	MOVAB	511(R1),R1		; ROUND TO PAGE BOUND
	ASHL	#-9,R1,R1		; CONVERT TO PAGE COUNT
	ADDL	R1,R4			; ADD TO SPT TOTAL
;
; ALLOCATE SPT FOR THE SMALL PACKET LIST
;
SRP_SPR:ADDL	#^XF,W^SGN$GL_SRPSIZE	; ROUND UP TO 16 BYTE BOUNDARY
	BICL	#^XF,W^SGN$GL_SRPSIZE	; 
	CMPL	W^SGN$GL_SRPCNTV,W^SGN$GL_SRPCNT ; CHECK I/O PACKET COUNT
	BGEQ	40$			; MAXIMIZE WITH SRPCNT
	MOVL	W^SGN$GL_SRPCNT,W^SGN$GL_SRPCNTV ; USE COUNT
40$:	MULL3	W^SGN$GL_SRPSIZE,W^SGN$GL_SRPCNTV,R1	; CALCULATE TOTAL BYTES
	MOVAB	511(R1),R1		; ROUND TO PAGE BOUND
	ASHL	#-9,R1,R1		; CONVERT TO PAGE COUNT
	ADDL	R1,R4			; ADD TO SPT TOTAL
PFN_SPT:
	SUBL3	W^MEM_LO_PFN,W^MEM_HI_PFN,R1 ; PAGES MAPPED BY PFN DATABASE
	TSTW	W^MEM_HI_PFN+2		; MORE THAN 32 MBYTES PRESENT?
	BNEQ	80$			; BRANCH IF YES
	MULL	#PFN$C_WORD_LEN,R1	; BYTES FOR PFN DATA BASE
	BRB	90$			; JOIN COMMON CODE
80$:	MULL	#PFN$C_LONG_LEN,R1	; BYTES FOR PFN DATA BASE
90$:	MOVAB	511(R1),R1		; ROUND TO PAGE BOUND
	ASHL	#-9,R1,R1		; CONVERT TO PAGE COUNT
	ADDL	R1,R4			; ADD TO TOTAL SPT SIZE
	ADDL	W^SGN$GL_SPTREQ,R4	; ADD REQUESTED EXTRA PAGES
	ADDL	W^EXE$GL_RTIMESPT,R4	; Add SPTs requested for use by
					; realtime processes using
					; connect to interrupt.
	ADDL	#MMG$C_SPTSKEL,R4	; ADD SIZE OF SPT SKELETON
	MOVZWL	W^SGN$GW_SYSDWSCT,R0	; GET SIZE OF SYSTEM WORKING SET
	MULL	#WSL$C_LENGTH,R0 	; BYTE SIZE OF WORKING SET
	MOVAB	<PHD$C_LENGTH+511>(R0),R0 ; SYSPHD WITH WORKING SET LIST
	MULW3	#SEC$C_LENGTH,W^SGN$GW_GBLSECNT,R1; BYTES FOR GLOBAL SECTIONS
	MOVZWL	R1,R1			; ZERO EXTEND WORD
	ADDL	R1,R0			; TOTAL SYSTEM HEADER BYTES
	ASHL	#-9,R0,R0		; CONVERT TO PAGES
	MOVL	R0,W^BOO$GL_SYSPHDPG	; SAVE SYSPHD PAGE COUNT
	ADDL	R0,R4			; ADD TO SPT REQUIREMENT
	MOVZWL	W^SGN$GW_ISPPGCT,R0	; PAGES OF INTERRUPT STACK
	ADDL	R0,R4			; ADD TO SPT REQUIREMENT
	ASHL	#2,W^SGN$GL_MAXGPGCT,R1	; REQUESTED NUMBER OF GLOBAL PAGES
					; TO SIZE OF GLOBAL PAGE TABLE
	MOVAB	511(R1),R1		; ROUND TO PAGE BOUNDARY
	ASHL	#-9,R1,R1		; CONVERT TO PAGE COUNT
	MOVL	R1,W^BOO$GL_GPTPGCT	; SAVE COUNT OF GLOBAL PAGE TABLES
	ADDL	R1,R4			; ADD TO SPT TOTAL
SIZ_SCB:				; COMPUTE # PAGES FOR SCB
	MOVZBL	#1,R0			; ASSUME 1 PAGE SCB
					;
	CPUDISP	<<780,SIZ_SCB_780>,-	; *DISPATCH ON CPU TYPE*
		 <750,SIZ_SCB_750>,-	;
		 <730,SIZ_SCB_730>,-
		 <790,SIZ_SCB_790>,-
		 <UV1,SIZ_SCB_UV1>,-
		>,-
		ENVIRON=VMB

SIZ_SCB_790:				; 11/790:
	MOVL	#4,R0			; ALWAYS ALLOCATE MAXIMUM SCB SIZE
	BRB	SIZ_SCB_END

SIZ_SCB_730:
SIZ_SCB_UV1:
	INCL	R0			; SCB ALWAYS 2 PAGES (1 UNIBUS)
	BRB	SIZ_SCB_END
					;
SIZ_SCB_750:				; 11/750:
	INCL	R0			; ASSUME 2 PAGE SCB (1 UNIBUS)
	TSTB	RPB$B_CONFREG+IO750$C_SL_UB1(R11) ; SECOND UNIBUS CONFIGURED?
	BEQL	SIZ_SCB_END		; BRANCH IF NOT
	INCL	R0			; ELSE 3 PAGE SCB
					;
SIZ_SCB_780:				; (FOR 11/780, PAGE COUNT=1)
					;
SIZ_SCB_END:				; *END OF CPU-DEPENDENT CODE*
					;
	MOVL	R0,W^SCBPAGCT		; SAVE SCB SIZE IN PAGES
	ADDL	R0,R4			; ADD SCB PAGES TO SPT TOTAL
	ASHL	#9,R0,W^SCBBYTCT	; SAVE SCB SIZE IN BYTES
	MOVAB	127(R4),R4		; ROUND TO PAGE BOUND
	ASHL	#-7,R4,R1		; CONVERT TO PAGES
	ADDL	R1,R4			; ADD PAGES OF SPT TO MAP
	ASHL	#-7,R4,R4		; PAGE COUNT FOR SPT ALLOCATION
	MOVL	R4,W^BOO$GL_SPTPAGCT	; SAVE COUNT OF PAGES
ALLOCSPT:				; ALLOCATE SPACE FOR SYSPHD AND SPT
	.ENABLE LSB
	ADDL3	R4,W^BOO$GL_SYSPHDPG,R8	; TOTAL SIZE OF PHD+SPT
	ADDL	W^SCBPAGCT,R8		;  PLUS SCB
	MOVL	RPB$Q_PFNMAP+4(R11),R7	; GET ADDRESS FOR PFNMAP
	MOVL	W^MEM_HI_PFN,R6		; GET HIGHEST PFN+1 IN MEMORY
10$:	DECL	R6			; POINT TO NEXT/HIGHEST PAGE
	BGTR	20$			; CONTINUE IF PAGES AVAILABLE
15$:	MSG	<-F-Unable to allocate SPT+PHD+SCB.>
	HALT				; *** FATAL ERROR ***

20$:	BBC	R6,(R7),10$		; FIND HIGHEST PAGE NUMBER
	TSTL	W^BOO$GL_NEXTPFN	; HAVE WE MARKED IT?
	BNEQ	25$			; YES
	MOVL	R6,W^BOO$GL_NEXTPFN	; SAVE HIGH WATER MARK
25$:	CLRL	R0			; INIT COUNT OF CONTIGUOUS PAGES
	BRB	35$			;
30$:	DECL	R6			; NEXT PAGE (LOWER)
	BBC	R6,(R7),10$		; SKIP IF NO FIT
35$:	INCL	R0			; BUMP COUNT OF PAGES
	CMPL	R0,R8			; CHECK FOR FIT
	BLSS	30$			; NOT YET
	SUBL	R0,RPB$L_PFNCNT(R11)	; ACCOUNT FOR PAGES REMOVED
	MOVL	R6,R1			; COPY LOWEST PAGE NUMBER
40$:	BBCC	R1,(R7),50$		; MARK PAGE ALLOCATED
	INCL	R1			; NEXT PAGE
50$:	SOBGTR	R0,40$			; ALLOCATE THEM ALL
;
;	R6 - PFN FOR START OF SCB
;	R7 - BASE OF PFNMAP
;	R8 - SIZE OF SYSPHD+SPT+SCB IN PAGES
;	R4 - SPT SIZE IN PAGES
;
	ASHL	#9,R6,R9		; COMPUTE PHYSICAL ADDRESS OF SCB
	CMPL	R9,W^BOO$GL_FREEMEM	; CHECK FOR OVERLAP WITH SYSBOOT
	BLSS	15$			; CONTINUE IF OK
	CMPL	R6,W^PFNMAP_HI_PFN	; RAN INTO PFN BITMAP?
	BLEQ	15$			; BRANCH IF YES
	CMPL	R6,W^CACHE_HI_PFN	; RAN INTO FIL$OPENFILE CACHE?
	BGTR	55$			; BRANCH IF NOT
	CLRQ	W^FIL$GQ_CACHE		; YES, DISABLE IT
	CLRL	W^CACHE_HI_PFN
55$:	CMPL	R6,W^CI_HI_PFN		; RAN INTO CI MICROCODE?
	BGTR	57$			; BRANCH IF NOT
BUMP_CI:MSG	<-F-PFN allocation overwrites CI ucode.>
	HALT

57$:	MOVL	R9,R0			; GET A WORKING COPY OF ADDRESS
	ASHL	#5,R8,R1		; GET COUNT OF DOUBLE QUADWORDS
60$:	CLRQ	(R0)+			; CLEAR A
	CLRQ	(R0)+			;  DOUBLE QUADWORD
	SOBGTR	R1,60$			; CLEAR THEM ALL
	.DISABLE LSB
INIT_SCB:				; INITIALIZE SYSTEM SCB
	MOVL	R9,W^SCBPHADDR		; SAVE PHYSICAL ADDR OF SCB
	MOVC3	#512,W^SCB$AL_BASE,(R9)	; COPY ARCHITECTURAL PART
					;  OF SCB (1 PG) FROM TEMPLATE
					;  TO SYSTEM COPY. (RETURNS
					;  SCB ADDR+512 IN R3.)
	SUBL3	#512,W^SCBBYTCT,R0	; GET # BYTES REMAINING IN SCB
	BLEQ	20$			; BRANCH IF NONE
	ASHL	#-2,R0,R0		; CONVERT # BYTES TO LONGWDS
10$:	MOVL	#ERL$UNEXP+1,(R3)+	; SET NEXT VECTOR TO UNEXPECTED INT
	SOBGTR	R0,10$			; BRANCH IF MORE VECTORS
;
; CPU specific code for 11/780.  Point SCB vector 0 interrupts and NEXUS
; vector 0 interrupts to separate routine in module ERRORLOG.
;

20$:	CPUDISP	<<780,SCB_VEC_780>,-	; Dispatch on CPU type
		 <750,SCB_VEC_750>,-
		 <730,SCB_VEC_730>,-
		 <790,SCB_VEC_790>,-
		 <UV1,SCB_VEC_UV1>,-
		>,-
		ENVIRON=VMB

SCB_VEC_790:
	MOVL	#4,R1			; 4 pages of SCB vectors
	BRB	FILL_NEXUS0		; Set address in nexus 0 vectors

SCB_VEC_780:
	MOVL	#1,R1			; 1 page of SCB vectors
	MOVAL	@#ERL$VEC_RETURN,(R9)	; Dispatches through SCB location 0
					; should be harmless on a 780.
FILL_NEXUS0:
	MOVL	R9,R0			; Copy pointer to SCB
10$:	MOVAL	@#ERL$VEC_RETURN+1,^X100(R0) ; Unibus passive releases can cause
	MOVL	^X100(R0),^X140(R0) 	; interrupts for "TR #0"; make them
	MOVL	^X100(R0),^X180(R0)	; harmless (at all 4 IPLs).
	MOVL	^X100(R0),^X1C0(R0)
	ADDL	#^X200,R0		; Step to next page of SCB
	SOBGTR	R1,10$			; Fill in vectors in next SCB page

SCB_VEC_750:
SCB_VEC_730:				; Do nothing for 11/750 and 11/730
SCB_VEC_UV1:

; End of CPU dependent code

INIT_SYSPHD:				; INITIALIZE SYSTEM PHD
	ADDL	W^SCBBYTCT,R9		; STEP PAST SCB TO PHD
	MOVC3	#PHD$C_LENGTH,W^BOO$A_SYSPHD,(R9)	; COPY PHD TO REAL PLACE
	MOVW	W^SGN$GW_SYSDWSCT,R0	; GET SIZE OF SYSTEM WORKING SET
	MOVW	R0,PHD$W_WSSIZE(R9)	; SET SYSTEM WORKING SET SIZE
	ADDW	PHD$W_WSNEXT(R9),R0	; GET POINTER TO WORKING SET
	MOVW	R0,PHD$W_WSLAST(R9)	; SET END OF SYSTEM WORKING SET LIST
	MOVW	R0,PHD$W_WSQUOTA(R9)	; SET QUOTA VALUES
	MOVW	R0,PHD$W_WSAUTH(R9)	; FOR CONSISTENCY
	MOVW	R0,PHD$W_DFWSCNT(R9)	; SAKE
	MOVW	R0,PHD$W_WSEXTENT(R9)	; ...
	MOVW	R0,PHD$W_WSAUTHEXT(R9)	; ...
	MOVW	W^SGN$GL_BALSETCT,PHD$W_PHVINDEX(R9)	; SET HEADER NUMBER
	ADDB3	#1,W^SGN$GW_SWPFILES,PHD$B_PAGFIL(R9) ; SET SYSTEM PAGING FILE
	ASHL	#7,W^BOO$GL_SPTPAGCT,PHD$L_P0LRASTL(R9)	; SET SPT LENGTH	
	MOVL	PHD$L_P0LRASTL(R9),W^MMG$GL_SPTLEN	; AND SAVE FOR REFERENCE
	ASHL	#9,W^BOO$GL_SYSPHDPG,R1	; BYTE OFFSET TO SPT
	ADDL3	R1,R9,W^MMG$GL_SBR	; SAVE PHYSICAL ADDRESS OF SPT
	ASHL	#9,W^BOO$GL_SYSPHDPG,PHD$L_PSTBASOFF(R9); SAVE AS BYTE OFFSET
	ASHL	#9,PHD$L_P0LRASTL(R9),R0; COMPUTE MAX SYSTEM ADDRESS+1
	ASHL	#VA$V_SYSTEM,#1,R2	; SYSTEM MASK
	BISL3	R2,R0,PHD$L_FREP0VA(R9)	; SAVE AS MAX ADDRESS
	BISL3	R2,R0,W^MMG$GL_FRESVA	;
	BISL3	R2,R0,W^MMG$GL_MAXSYSVA	;
	BISL3	R2,R0,W^MMG$GL_MAXGPTE	;
	MOVL	R9,W^BOO$GL_SYSPHD	; SAVE PHYSICAL PHD ADDRESS
	SUBL3	W^BOO$GL_GPTPGCT,PHD$L_P0LRASTL(R9),R1	; VPN OF GPT
	ASHL	#9,R1,R0		; CONVERT TO BYTE ADDRESS
	BISL3	R2,R0,W^MMG$GL_GPTE	; BASE OF GLOBAL PAGE TABLE ENTRIES
	SUBL	W^BOO$GL_SPTPAGCT,R1	; VPN OF SPT
	ASHL	#9,R1,R0		; BYTE ADDRESS
	BISL3	R2,R0,W^MMG$GL_GPTBASE	; SAVE AS GPT BASE
	BISL3	R2,R0,W^MMG$GL_SPTBASE	; AND SPT BASE
	BISL3	R2,R0,PHD$L_P0BR(R9)	; AND VIRTUAL SBR
	SUBL	W^BOO$GL_SYSPHDPG,R1	; VPN OF SYSPHD
	ASHL	#9,R1,R0		; BYTE ADDRESS
	BISL3	R2,R0,W^MMG$GL_SYSPHD	; SAVE VIRTUAL POINTER TO PHD
	ASHL	#9,W^BOO$GL_SYSPHDPG,W^MMG$GL_SYSPHDLN	; BYTES IN SYSTEM PHD
	MULL3	W^SWP$GL_BSLOTSZ,W^SGN$GL_BALSETCT,R0	; BALANCE SET MAP SIZE
	SUBL3	R0,R1,R0		; VPN OF BAL BASE
	MOVAL	@W^MMG$GL_SPTBASE[R0],W^SWP$GL_BALSPT	; SET BASE OF BALANCE MAP
	ASHL	#9,R0,R0		; CONVERT VPN TO VA
	BISL3	R2,R0,W^SWP$GL_BALBASE	; SAVE VA BASE OF BALANCE SLOTS
	SUBL	W^SCBBYTCT,R0		; COMPUTE VA OF SCB
	BISL3	R2,R0,EXE$GL_SCB	; SAVE SYSTEM SPACE VA OF SCB
	MOVAB	-512(R0),R0		; SKIP ONE PAGE FOR ERROR DETECTION
	BISL3	R2,R0,W^EXE$GL_INTSTK	; SET BASE OF INTERRUPT STACK
	MOVAL	@W^MMG$GL_SBR[R1],R3	; POINTER TO SPTE
	SUBL3	W^SCBPAGCT,R8,R0	; GET # PAGES IN PHD+SPT ONLY
	ADDL	W^SCBPAGCT,R6		; GET PFN OF START OF SYS PHD
10$:	BISL3	#<PTE$C_ERKW!PTE$M_VALID!PTE$C_KOWN>,R6,(R3)+	; MAP A PAGE
	INCL	R6			; NEXT PFN
	SOBGTR	R0,10$			; MAP ENTIRE SYSPHD+SPT
	MOVL	W^BOO$GL_GPTPGCT,R0	; COUNT OF GLOBAL PAGE TABLE PAGES
20$:	MOVL	#PTE$C_URKW,(R3)+	; FILL THEM AS DEMAND ZERO
	SOBGTR	R0,20$			;
MAPSCB:					; MAP SCB
	EXTZV	#VA$V_VPN,#VA$S_VPN,-	; GET VPN OF
		W^EXE$GL_SCB,R1		; SCB
	MOVAL	@W^MMG$GL_SBR[R1],R3	; GET ADDR OF SPTE TO FILL
	MOVL	W^SCBPAGCT,R1		; GET # PAGES OF SCB
	ASHL	#-9,W^SCBPHADDR,R0	; GET PFN OF START OF SCB
10$:	BISL3	#<PTE$C_ERKW!PTE$M_VALID!PTE$C_KOWN>,- ; MAP NEXT SPTE
		R0,(R3)+
	INCL	R0			; STEP TO NEXT PFN
	SOBGTR	R1,10$			; MAP WHOLE SCB
MAPISTK:				; MAP INTERRUPT STACK
	EXTZV	#VA$V_VPN,#VA$S_VPN,W^EXE$GL_INTSTK,R1	; GET VPN FOR INT STK
	MOVAL	@W^MMG$GL_SBR[R1],R3	; SVASPT + 4
	MOVZWL	W^SGN$GW_ISPPGCT,R1	; GET PAGE COUNT FOR INTERRUPT STACK
10$:	BSBW	ALLOCPFN		; ALLOCATE A PAGE
	BISL3	#<PTE$C_ERKW!PTE$M_VALID!PTE$C_KOWN>,R0,-(R3); FILL VALID MAP ENTRY
	SOBGTR	R1,10$			; MAP ENTIRE INTERRUPT STACK
	MOVZWL	W^SGN$GW_ISPPGCT,R1	; GET SIZE OF INTERRUPT STACK
	INCL	R1			; SKIP ONE PAGE FOR ERROR DETECTION
	TSTL	-(R3)			; ALSO BUMP SPT POINTER DOWN
	ASHL	#9,R1,R1		; CONVERT TO BYTES
	SUBL3	R1,W^EXE$GL_INTSTK,R1	; FORM ADDRESS OF BASE
;
; NOW ESTABLISH THE SIZE AND BASE ADDRESS OF THE SMALL REQUEST PACKET
; LOOK ASIDE LIST
;
ALLOC_SRP:
	MOVL	W^SGN$GL_SRPCNT,L^BOO$GL_SRPCNT	; COUNT OF SRP'S TO INITIALIZE
	MULL3	W^SGN$GL_SRPSIZE,W^SGN$GL_SRPCNT,R2 ; CALCULATE TOTAL BYTES
	MOVAB	511(R2),R2		; ROUND TO PAGE
	BICL	#^X1FF,R2		; BOUNDARY
	MULL3	W^SGN$GL_SRPSIZE,W^SGN$GL_SRPCNTV,R0; CALCULATE VIRTUAL BYTES
	MOVAB	511(R0),R0		; AND ROUND TO PAGE BOUNDARY
	BICL	#^X1FF,R0		;
	SUBL3	R0,R1,-
		L^BOO$GL_SRPSPLIT	; LOOKASIDE LIST SPLIT ADDRESS
	ADDL3	R2,L^BOO$GL_SRPSPLIT,-
		W^MMG$GL_SRPNEXT	; NEXT PAGE TO ALLOCATE FOR SRP AREA
	SUBL	R2,R0			; COMPUTE SIZE OF GAP
	ASHL	#-7,R0,R0		; CONVERT TO 4*PAGES
	SUBL	R0,R3			; SKIP SPT ENTRIES FOR GAP
	ASHL	#-9,R2,R1		; COMPUTE PAGE COUNT TO ALLOCATE
	BEQL	20$			; BR IF NONE
10$:	BSBW	ALLOCPFN		; ALLOCATE A PAGE
	BISL3	#<PTE$C_ERKW!PTE$M_VALID!PTE$C_KOWN>,R0,-(R3); FILL VALID MAP ENTRY
	SOBGTR	R1,10$			; MAP ACTIVE SRP AREA
20$:
ALLOC_IRP:
	MOVL	W^SGN$GL_IRPCNT,R2	; USE COUNT
	MOVL	R2,L^BOO$GL_IRPCNT	; COUNT OF IRP'S TO INITIALIZE
	MULL	#<IRP$C_LENGTH+^XF>&<^C<^XF>>,R2 ; CALCULATE TOTAL BYTES
	MOVAB	511(R2),R2		; ROUND TO PAGE BOUNDARY
	BICL	#^X1FF,R2		; SIZE OF ALLOCATED IRP AREA
	MULL3	#<IRP$C_LENGTH+^XF>&<^C<^XF>>,-
		W^SGN$GL_IRPCNTV,R0	; CALCULATE TOTAL BYTES
	MOVAB	511(R0),R0		; ROUND TO PAGE BOUNDARY
	BICL	#^X1FF,R0		; VIRTUAL SIZE OF IRP AREA

	SUBL3	R0,L^BOO$GL_SRPSPLIT,R1	; BASE ADDRESS OF IRP AREA
	MOVL	R1,L^BOO$GL_SPLITADR	; LOOKASIDE LIST SPLIT ADDRESS
	ADDL3	R1,R2,W^MMG$GL_IRPNEXT	; SET ADDRESS FOR NEXT ALLOCATION
	SUBL	R2,R0			; COMPUTE SIZE OF GAP
	ASHL	#-7,R0,R0		; CONVERT TO PAGES*4
	SUBL	R0,R3			; SKIP SPT ENTRIES FOR GAP
	ASHL	#-9,R2,R1		; CONVERT ACTIVE ARE TO PAGE COUNT
	BEQL	20$			; BR IF NONE
10$:	BSBW	ALLOCPFN		; ALLOCATE A PAGE
	BISL3	#<PTE$C_ERKW!PTE$M_VALID!PTE$C_KOWN>,R0,-(R3); FILL VALID MAP ENTRY
	SOBGTR	R1,10$			; MAP ACTIVE IRP AREA
20$:					;
;
; NOW ESTABLISH THE SIZE AND BASE ADDRESS OF THE LARGE REQUEST PACKET
; LOOK ASIDE LIST
;
ALLOC_LRP:
	BICL3	#^XF,W^SGN$GL_LRPMIN,L^BOO$GL_LRPMIN ; ROUND THE MINIMUM SIZE
	MOVL	W^SGN$GL_LRPCNT,L^BOO$GL_LRPCNT	; COUNT OF LRP'S TO INITIALIZE
	MULL3	L^BOO$GL_LRPSIZE,W^SGN$GL_LRPCNT,R2 ; CALCULATE TOTAL BYTES
	MOVAB	511(R2),R2		; ROUND TO PAGE
	BICL	#^X1FF,R2		; BOUNDARY
	MULL3	L^BOO$GL_LRPSIZE,W^SGN$GL_LRPCNTV,R0; CALCULATE VIRTUAL BYTES
	MOVAB	511(R0),R0		; AND ROUND TO PAGE BOUNDARY
	BICL	#^X1FF,R0		;
	SUBL3	R0,L^BOO$GL_SPLITADR,-
		L^BOO$GL_LRPSPLIT	; LOOKASIDE LIST SPLIT ADDRESS
	ADDL3	R2,L^BOO$GL_LRPSPLIT,-
		W^MMG$GL_LRPNEXT	; NEXT PAGE TO ALLOCATE FOR LRP AREA
	SUBL	R2,R0			; COMPUTE SIZE OF GAP
	ASHL	#-7,R0,R0		; CONVERT TO 4*PAGES
	SUBL	R0,R3			; SKIP SPT ENTRIES FOR GAP
	ASHL	#-9,R2,R1		; COMPUTE PAGE COUNT TO ALLOCATE
	BEQL	20$			; BR IF NONE
10$:	BSBW	ALLOCPFN		; ALLOCATE A PAGE
	BISL3	#<PTE$C_ERKW!PTE$M_VALID!PTE$C_KOWN>,R0,-(R3); FILL VALID MAP ENTRY
	SOBGTR	R1,10$			; MAP ACTIVE LRP AREA
20$:					;
MAPNPAGDYN:				; MAP NON-PAGED DYNAMIC POOL
	MOVL	L^BOO$GL_LRPSPLIT,R1	; GET ADDRESS OF PREVIOUS AREA
	SUBL3	W^SGN$GL_NPAGEVIR,W^SGN$GL_NPAGEDYN,R0 ; GET NEG SIZE OF GAP
	SUBL	W^SGN$GL_NPAGEVIR,R1	; AND COMPUTE BASE OF POOL
	MOVL	R1,W^MMG$GL_NPAGEDYN	; SAVE VA OF BASE
	ADDL3	R1,W^SGN$GL_NPAGEDYN,W^MMG$GL_NPAGNEXT	; SET VA OF NEXT PAGE
	SUBL3	W^SGN$GL_PAGEDYN,R1,W^MMG$GL_PAGEDYN	; COMPUTE BASE OF PAGED POOL
	ASHL	#-9,R0,R0		; CONVERT GAP TO PAGE COUNT
	MOVAL	(R3)[R0],R3		; ADVANCE SPT POINTER PAST GAP
	MOVL	W^SGN$GL_NPAGEDYN,R1	; GET BYTES OF POOL
	ASHL	#-9,R1,R1		; AND CONVERT TO PAGE COUNT
10$:	BSBW	ALLOCPFN		; ALLOCATE A PAGE
	BISL3	#<PTE$C_ERKW!PTE$M_VALID!PTE$C_KOWN>,R0,-(R3); FILL A VALID MAP ENTRY
	SOBGTR	R1,10$			; MAP ALL POOL PAGES
;
; PREALLOCATE THE TOP OF POOL AND PLACE THE FIL$OPENFILE CACHE UP THERE
; START BY ESTBALISHING THE SIZE AND BASE ADDRESS OF THE IRP LOOKASIDE LIST
;
	MOVAL	L^BOO$GL_NPAGEDYN,R0	; ADDRESS OF POOL SIZE WITH
	MOVL	W^SGN$GL_NPAGEDYN,(R0)	; INIT TO SIZE OF NON-PAGED POOL
					; PREALLOCATED PIECES TAKEN OUT
;
; Now allocate pool for:
;	Boot Driver for System Disk
;	 and any ucode needed for it
;	System Disk Driver
;	Port Driver (if any)
;	Terminal Driver - TTDRIVER.EXE
;	CPU dependent code - SYSLOA.EXE
;	SCS loadable code - SCSLOA.EXE
;
ALLOC_DRIVERS:
	MOVAL	W^BOODRV_STAT,R2	; STAT BLOCK FOR BOOT DRIVER
	MOVL	S^#ALLOC_POOL_CNT,R4	; NO. OF DRIVERS TO ALLOCATE SPACE FOR
10$:	BSBW	ALLOC_POOL
	ADDL	#STAT_C_SIZE,R2		; POINT TO NEXT STAT BLOCK
	SOBGTR	R4,10$			; ALLOCATE SPACE FOR NEXT DRIVER
;
; The following code calculates the amount of space needed to map the
; FIL$OPENFILE cache.  The cache will be released sometime later by SYSINIT.
;
ALLOC_FILCACHE:
	MOVL	W^FIL$GQ_CACHE,R3	; GET SIZE IN R3
	BEQL	80$			; BRANCH IF DISABLED
	ADDL	#^XF,R3			; ROUND TO QUAD WORD
	BICL	#^XF,R3			; FOR POOL ALLOCATION
;
; IF THE FIL$OPENFILE CACHE IS LARGE WITH RESPECT TO THE AMOUNT OF
; SPACE THAT IS LEFT IN THE POOL, THEN SIMPLY DISABLE IT.
;
	MOVL	(R0),R5 		; SPACE IN POOL
	DIVL	#2,R5			; 50% OF THE SPACE LEFT
	CMPL	R3,R5			; CACHE TOO BIG?
	BLEQ	70$			; BRANCH IF NOT
50$:	CLRL	R3			; DISABLE THE FILE CACHE
70$:	TSTL	R3			; IS THE CACHE ENABLED?
	BEQL	80$			; BRANCH IF NOT
	SUBL	R3,(R0)			; ALLOCATE FIL$OPENFILE CACHE
	ADDL3	(R0),W^MMG$GL_NPAGEDYN,R4 ; ADDRESS OF FILE CACHE IN POOL
	MOVQ	R3,L^BOO$GQ_FILCACHE	; SET SIZE AND ADDRESS OF FILE CACHE
80$:
;
;	There are two separate dependencies on the FIL$OPENFILE cache
; being allocated as the next higher address after INILOA.  First the
; initial pool fragmentation is eliminated by the orderly deallocation
; of these 2 pieces, INILOA by INIT and the FIL$OPENFILE cache by SYSINIT.
; Second, the code at MOVEFILECACHE below depends on being able to
; disable the FIL$OPENFILE cache by clearing the descriptor and adding
; its size to the length of INILOA for deallocation by the INIT code.
;
; At this point non-paged pool look like this:
;
;	+-----------------------------------------+
;	!                                         !  :MMG$GL_NPAGEDYN
;	!                                         !
;	!	       Available Pool		  !
;	!                                         !
;	!                                         !
;	+-----------------------------------------+
;	!                                         !
;	!           FIL$OPENFILE Cache            !  :BOO$GQ_CACHE
;	!                                         !   (deallocated by SYSINIT)
;	+-----------------------------------------+
;	!					  !
;	!	      MTACCESS.EXE 		  !  :BOO$GL_MTACCESSLOA
;	!	       (if loaded)		  !
;	!					  !
;	+-----------------------------------------+
;	!					  !
;	!	      VAXEMUL.EXE 		  !  :BOO$GL_VAXEMUL
;	!					  !
;	+-----------------------------------------+
;	!					  !
;	!	      FPEMUL.EXE 		  !  :BOO$GL_FPEMUL
;	!					  !
;	+-----------------------------------------+
;	!					  !
;	!	      CHKPRTLOA.EXE 		  !  :BOO$GL_CHKPRTLOA
;	!	       (if loaded)		  !
;	!					  !
;	+-----------------------------------------+
;	!					  !
;	!	      ERAPATLOA.EXE 		  !  :BOO$GL_ERAPATLOA
;	!	       (if loaded)		  !
;	!					  !
;	+-----------------------------------------+
;	!					  !
;	!	      CLUSTRLOA.EXE 		  !  :BOO$GL_CLSLOA
;	!	       (if loaded)		  !
;	!					  !
;	+-----------------------------------------+
;	!                                         !
;	!             SYSLOAxxx.EXE               !  :BOO$GL_SYSLOA
;	!                                         !
;	+-----------------------------------------+
;	!					  !
;	!		SCSLOA.EXE		  !  :BOO$GL_SCSLOA
;	!		(if loaded)		  !
;	!					  !
;	+-----------------------------------------+
;	!                                         !
;	!              TTDRIVER.EXE               !  :BOO$GL_TRMDRV 
;	!                                         !
;	+-----------------------------------------+
;	!                                         !
;	!              PxDRIVER.EXE               !  :BOO$GL_PRTDRV
;	!		(if loaded)		  !
;	!                                         !
;	+-----------------------------------------+
;	!                                         !
;	!            System Disk Driver           !  :BOO$GL_DSKDRV
;	!                                         !
;	+-----------------------------------------+
;	!                                         !
;	!                 BOOTCB                  !  :BOO$GL_BOOTCB
;	!          Bootstrap Disk Driver          !  :RPB$L_IOVEC(RPB_ADR)
;	!	       Microcode file		  !  :BOO$GL_UCODE
;	!                                         !
;	+-----------------------------------------+
;	!                                         !
;	!           LRP Look-aside List           !  :BOO$GL_LRPSPLIT
;	!                                         !
;	+-----------------------------------------+
;	!                                         !
;	!           IRP Look-aside List           !  :BOO$GL_SPLITADR
;	!                                         !
;	+-----------------------------------------+
;	!                                         !
;	!           SRP Look-aside List           !  :BOO$GL_SRPSPLIT
;	!                                         !
;	+-----------------------------------------+
;
;	MOVE SKELETON SPT TO ACTUAL LOCATION
;
	MOVC3	#<MMG$C_SPTSKEL@2>,-	;
		W^MMG$AL_SYSPAGTB,-	;
		@W^MMG$GL_SBR		;
MAPRESEXEC:				; MAP RESIDENT EXEC
	BBC	S^#EXE$V_SYSPAGING,W^EXE$GL_DEFFLAGS,10$ ; BRANCH IF NOT PAGING
	EXTZV	#VA$V_VPN,#VA$S_VPN,W^MMG$GL_PGDCOD,R1	; GET START OF PAGED EXEC
	BRB	20$			; JOIN COMMON CODE
10$:	MOVZWL	#<<MMG$AL_PGDCODEN-^X80000000>@-9>,R1	; GET END OF PAGED EXEC
20$:	MOVAL	@W^MMG$GL_SBR[R1],R3	; GET SVASPT
30$:	BSBW	ALLOCPFN		; ALLOCATE A PAGE
	BICL	#PTE$M_PFN,-(R3)	; CLEAR PFN FIELD
	BISL	R0,(R3)			; ATTEMPT SIMPLE MERGE OF PAGE
	BLSS	40$			; SUCCESS
	BISL3	#<PTE$C_URKW!PTE$M_VALID!PTE$C_KOWN>,R0,(R3); MAP A VALID PAGE
40$:	SOBGTR	R1,30$			; MAP ALL RESIDENT EXEC
MAPPFNDAT:				; MAP PFN DATA BASE
	CLRW	MMG$GW_BIGPFN		; ASSUME WORK LINKS IN PFN DATABASE
	MOVL	W^MEM_LO_PFN,W^MMG$GL_MINPFN	; INITIALIZE SMALLEST PFN
	clrl	w^mmg$gl_minpfn		; *************** TEMP ***************
	ADDL3	#2,W^BOO$GL_NEXTPFN,R3	; START WITH CURRENT TOP PFN + FUDGE
	MNEGL	W^MMG$GL_MINPFN,R4	; R4 CONTAINS NEGATIVE OF BASE PFN NUMBER
	ADDL2	R4,R3			; R3 NOW CONTAINS PFN COUNT
	MULL3	#PFN$C_WORD_LEN,R3,R5	; PFN DATA BASE SIZE (ASSUME SHORT FORM)
	ASHL	#-9,R5,R5		; PFN DATA BASE PAGES - 1
	SUBL3	R5,W^BOO$GL_NEXTPFN,R5	; PAGES AFTER ALLOCATING PFN DATA BASE
	ASHL	#-16,R5,R5		; IS IT BIGGER THAN 65 K PAGES
	BEQL	1$			; NO
	INCW	MMG$GW_BIGPFN		; CONDITION FOR IF MACROS
1$:	PFN_DISP_IF_BIGPFN_THEN		END_BIGPFN_CODE=3$
		MOVB	#PFN$C_LONG_LEN,W^PFN$GB_LENGTH
	PFN_DISP_ELSE			ELSE_CODE=3$,COMMON_CODE=6$
		MOVB	#PFN$C_WORD_LEN,W^PFN$GB_LENGTH
	PFN_DISP_ENDIF			COMMON_CODE=6$
	MOVZBL	W^PFN$GB_LENGTH,R5	; R5 CONTAINS NUMBER OF BYTES PER PAGE
	MULL3	R5,R3,R2		; COMPUTE BYTES OF PFN DATA BASE NEEDED
	MOVAB	511(R2),R2		; ROUND UP TO PAGE BOUND
	ASHL	#-9,R2,R0		; AND CONVERT TO PAGES
10$:	MULL	R5,R0			; GET BYTES OF PFN DATA
	SUBL	R0,R2			; REMOVE FROM REQUIREMENT
	ASHL	#-9,R0,R0		; GET PAGES REMOVED
	BNEQ	10$			; BR IF WHOLE PAGES REMOVED
	ASHL	#-9,R2,R2		; CONVERT TO PAGE COUNT
	SUBL	R2,R3			; SUBTRACT PAGES OF PFN DATA
	MULL	R5,R3			; COMPUTE BYTE OF PFN DATA
	MOVAB	511(R3),R2		; ROUND TO NEXT PAGE
	ASHL	#-9,R2,R1		; COMPUTE PAGES OF PFN DATA BASE
	ASHL	#9,R1,R2		; BACK TO BYTES
	DIVL3	R5,R2,R3		; COMPUTE NUMBER OF ENTRIES
	SUBL3	R2,W^MMG$GL_PAGEDYN,R2	; SUBTRACT FROM PAGEDYN TO GET PFN BASE
	MOVL	R2,W^PFN$AL_PTE		; SAVE AS BASE OF FIRST W^PFN ARRAY
	MOVAL	@W^PFN$AL_PTE[R3],W^PFN$AL_BAK	; ADD SIZE * PAGE COUNT
	MOVAL	@W^PFN$AL_BAK[R3],W^PFN$AW_REFCNT	; FOR EACH OF THE W^PFN ARRAYS
	MOVAW	@W^PFN$AW_REFCNT[R3],W^PFN$Ax_FLINK;
	PFN_DISP_IF_BIGPFN_THEN		END_BIGPFN_CODE=20$
		MOVAL	@W^PFN$Ax_FLINK[R3],W^PFN$Ax_BLINK	; TO GET ADDRESS OF NEXT
		MOVAL	@W^PFN$Ax_BLINK[R3],W^PFN$AW_SWPVBN; ARRAY BASE
	PFN_DISP_ELSE			ELSE_CODE=20$,COMMON_CODE=25$
		MOVAW	@W^PFN$Ax_FLINK[R3],W^PFN$Ax_BLINK	; TO GET ADDRESS OF NEXT
		MOVAW	@W^PFN$Ax_BLINK[R3],W^PFN$AW_SWPVBN; ARRAY BASE
	PFN_DISP_ENDIF			COMMON_CODE=25$
	MOVAW	@W^PFN$AW_SWPVBN[R3],W^PFN$AB_STATE;
	MOVAB	@W^PFN$AB_STATE[R3],W^PFN$AB_TYPE	;
;
; RESET BASE OF EACH ARRAY TO ACCOUNT FOR NONZERO MINPFN.
; R4 CONTAINS THE NEGATIVE OF THE SMALLEST PFN IN THE PFN DATA BASE.
;
	MOVAL	@W^PFN$AL_PTE[R4],W^PFN$AL_PTE
	MOVAL	@W^PFN$AL_BAK[R4],W^PFN$AL_BAK
	MOVAW	@W^PFN$AW_REFCNT[R4],W^PFN$AW_REFCNT
	PFN_DISP_IF_BIGPFN_THEN		END_BIGPFN_CODE=30$
		MOVAL	@W^PFN$Ax_FLINK[R4],W^PFN$Ax_FLINK
		MOVAL	@W^PFN$Ax_BLINK[R4],W^PFN$Ax_BLINK
	PFN_DISP_ELSE			ELSE_CODE=30$,COMMON_CODE=35$
		MOVAW	@W^PFN$Ax_FLINK[R4],W^PFN$Ax_FLINK
		MOVAW	@W^PFN$Ax_BLINK[R4],W^PFN$Ax_BLINK
	PFN_DISP_ENDIF			COMMON_CODE=35$
	MOVAW	@W^PFN$AW_SWPVBN[R4],W^PFN$AW_SWPVBN
	MOVAB	@W^PFN$AB_STATE[R4],W^PFN$AB_STATE
	MOVAB	@W^PFN$AB_TYPE[R4],W^PFN$AB_TYPE
	PUSHL	R2			; SAVE PFN DATA AREA BASE ADDRESS
	EXTZV	#VA$V_VPN,#VA$S_VPN,R2,R2	; COMPUTE STARTING PAGE NUMBER
	MOVAL	@W^MMG$GL_SBR[R2],R3	; AND CONVERT TO SVAPTE
	MOVAL	(R3)[R1],R3		; POINTING TO HIGH VPN+1
40$:	BSBW	ALLOCPFN		; ALLOCATE A PAGE
	BISL3	#<PTE$C_ERKW!PTE$M_VALID!PTE$C_KOWN>,R0,-(R3); MAP A VALID ENTRY
	ASHL	#9,R0,R0		; CONVERT TO PHYSICAL ADDRESS
	MOVZWL	#512/8,R2		; SET COUNT TO CLEAR
45$:	CLRQ	(R0)+			; CLEAR A QUAD
	SOBGTR	R2,45$			; CLEAR ENTIRE PAGE
	SOBGTR	R1,40$			; DO ALL OF THE PFN DATA BASE PAGES
	POPR	#^M<R2>			; RESTORE BASE ADDRESS
MAPRPB:					;
	EXTZV	#VA$V_VPN,#VA$S_VPN,R2,R2 ; FREE HIGH VPN+1
	DECL	R2			; VPN FOR RPB
	ASHL	#-9,R11,R0		; PFN FOR FPB
	BBCC	R0,@RPB$Q_PFNMAP+4(R11),10$	; MARK RPB ALLOCATED
10$:	BISL3	#<PTE$C_URKW!PTE$M_VALID!PTE$C_KOWN>,R0,@MMG$GL_SBR[R2]	; MAP PAGE
	DECL	RPB$L_PFNCNT(R11)	; ONE LESS AVAILABLE PAGE
	ASHL	#9,R2,R0		; CONVERT VPN TO VA
	BISL3	#^X80000000,R0,W^EXE$GL_RPB	; SAVE VA OF RPB
	MOVAB	-(R2),W^BOO$GL_SPTFREH	; SAVE FOR SUBSEQUENT USE
	MOVZWL	#MMG$C_SPTSKEL,W^BOO$GL_SPTFREL	; SAVE LOW VPN ALSO
	MOVL	W^BOO$GL_NEXTPFN,W^MMG$GL_MAXPFN ; SAVE MAX PFN VALUE

MAP_XDELTA_INIT:			; MAP XDELTA AND INIT
	MOVL	#<<MMG$A_SYS_END-^X80000000>@-9>,R3	; VPN+1 OF END OF EXEC
	MOVZWL	#<<MMG$A_SYS_END-MMG$AL_PGDCODEN>@-9>,R1; COUNT OF XDELTA+INIT
	MOVAL	@W^MMG$GL_SBR[R3],R3	; SVAPTE+4
10$:	BSBW	ALLOCPFN		; ALLOCATE A PHYSICAL PAGE
	BISL3	#<PTE$C_URKW!PTE$M_VALID!PTE$C_KOWN>,R0,-(R3); MAP A VALID PAGE
	SOBGTR	R1,10$			; MAP ALL POTENTIALLY PAGED EXEC

;
;
;	SET MAP INFORMATION FOR BOOT DRIVER
;
INITBOOTDRV:				;
	MOVZWL	#<<MMG$A_SYS_END-^X80000000>@-9>,R9	; SET NUMBER OF PAGES
	MOVL	R9,BOO$GL_SPTFREL	; SAVE NEXT FREE SPT ENTRY
	MOVL	RPB$L_IOVEC(R11),R4	; GET POINTER TO I/O VECTOR
	PUSHL	R11			; ADDRESS OF RPB
	PUSHAL	@#MMG$A_SYS_END		; VA FOR I/O WINDOW
	PUSHL	W^MMG$GL_SBR		; PHYSICAL ADDRESS OF SPT
	CALLS	#3,@BQO$L_MAP(R4)[R4]	; CALL BOO$MAP
;
; Mapping information has now been provided to permit the bootstrap
; I/O driver to read the EXEC into non-contiguous physical pages.
;
;
; Read the drivers and other loadable pieces of code into their
; allocated slots in non-paged pool.
;
	MOVAL	W^DSKDRV_STAT,R2	; SYSTEM DISK DRIVER STAT BLOCK
	MOVL	S^#LOAD_IMAGE_CNT,R5	; NO. OF LOAD IMAGES TO READ
10$:	BSBW	LOAD_CODE		; LOAD THIS IMAGE INTO POOL
	ADDL	#STAT_C_SIZE,R2		; ADDRESS OF NEXT STAT BLOCK
	SOBGTR	R5,10$			; LOAD NEXT IMAGE
;
; Assuming system paging is enabled (SYSPAGING = 1), the EXEC is read
; in two pieces.  The first contains all the resident code, the second
; contains XDELTA, INIT, and the BUGCHECK code.  The pages of BUGCHECK
; messages are not read in any longer, though they were in release 2.
; When SYSPAGING = 0, the entire system is read in (including the paged
; code) and in this case too, the read stops short of bringing in the
; BUGCHECK messages.  The BUGCHECK code is still required because the
; salutation put out by INIT uses the CONSOLIO code in BUGCHECK.  There
; may or may not be other needs for this code.
;
; If we are operating Standalone (i.e. boot device is console device) allow
; for a volume switch at this point.
;
; If a volume switch occurs:
; 	- All "open" files will be closed by zeroing the STAT_L_VBN, STAT_L_BYTECNT
; 	  and STAT_L_MAP fields.  The file cache will be deallocated.  All file
;	  mapping information in the BOOTCB will be zeroed.
; 	- The SYS_STAT block will contain a dummy retrieval pointer which maps those
; 	  blocks on the previous volume(s).
; 	- The flag RPB$V_NOSYSDISK in RPB$B_FLAGS will be set so that any code with
;	  access to the RPB will be able to tell if a volume switch has occurred.
;
	MOVL	#1,W^CONEOF_ENABLE	; SET A FLAG THAT VOLUME SWITCH IS ALLOWED
	MOVL	#<<<BUG$T_MESSAGES+511>&^C511>-^X80000000>,R9
					; NUMBER OF BYTES OF SYS TO READ
	MOVL	W^SYS_STAT+STAT_L_MAP,R4 ; VIRTUAL TO LOGICAL MAP
	MOVL	W^SYS_STAT+STAT_L_VBN,R3 ; STARTING VBN IN IMAGE
	ASHL	#VA$V_SYSTEM,#1,R6	; SET ADDRESS OF "BUFFER"
	BBC	S^#EXE$V_SYSPAGING,W^EXE$GL_DEFFLAGS,20$ ; SINGLE READ IF NOT PAGING
	SUBL3	#^X80000000,W^MMG$GL_PGDCOD,R9	; SET NUMBER OF BYTES
	BSBW	READ_VIRTUAL		; READ NONPAGED EXEC CODE
	BLBC	R0,READ_SYS_ERR		; BRANCH IF ERROR
	MOVAL	@#MMG$AL_PGDCODEN,R6	; SET NEW BUFFER ADDRESS
	MOVL	#<<<BUG$T_MESSAGES+511>&^C511>-MMG$AL_PGDCODEN>,R9
					; SET SIZE OF INIT
	ADDL3	W^SYS_STAT+STAT_L_VBN,-	; COMPUTE VBN FOR INIT
		#<<MMG$AL_PGDCODEN-^X80000000>@-9>,R3
20$:					;
	BSBW	READ_VIRTUAL		; READ EXEC IMAGE
	CLRL	W^CONEOF_ENABLE		; CLOSE WINDOW ON VOLUME SWITCHES
	BLBS	R0,MOVSYSPARAM		; BRANCH IF SUCCESSFULLY READ
;
; Error reading SYS.EXE - fatal
;
READ_SYS_ERR:
	MOVAL	W^BOO$GT_SYS,R1		; APPEND "SYS.EXE"
	BSBW	BOO$TYPE_ASCIC		; TO THE READ ERROR MESSAGE
	HALT				; ***** FATAL ERROR *****
;
; EXEC image has now been read. The correct copy of SYSPARAM
; information will now be moved into the system image.
;
MOVSYSPARAM:
;
; Assume the first 12 bytes of the SYSGEN parameter area is EXE$GQ_TODCBASE and
; EXE$GL_TODR and is not to be overwritten.
;
	MOVL	#BOO$C_SYSPARSZ-12,R6	; Size of SYSPARAM in bytes
	MOVL	#MMG$A_SYSPARAM+12,R7	; Get System VA of SYSPARAM
	MOVAL	W^EXE$A_SYSPARAM+12,R1	; Address of SYSBOOT copy
	BSBW	MOVEMAPPED		; Move SYSBOOT copy into sys copy.
;
; Move the FIL$OPENFILE cache into its allocated place in non-paged pool.
; If this cache was allocated space in pool, but before it could be
; safely moved into pool, its pages were allocated and potentially
; written into, then we must disable the cache here.  To do that
; we clear the desriptor for the FIL$OPENFILE cache and
; tack on its size to the INILOA piece.  This is assumed to be allocated
; just before the FIL$OPENFILE cache and the size field of the INILOA 
; descriptor is only used for deallocating the INILOA piece after INIT
; has executed that portion of the initialization code.
;
MOVFILECACHE:
	MOVQ	W^BOO$GQ_FILCACHE,R6	; R6 = size, R7 = pool address
	BEQL	5$			; Branch if no cache enabled
	CMPL	W^BOO$GL_NEXTPFN,W^CACHE_HI_PFN ; Alloc over FIL$OPENFILE cache?
	BGEQ	2$			; Branch if not
	CLRQ	W^BOO$GQ_FILCACHE	; No FIL$OPENFILE cache
	ADDL	R6,W^BOO$GQ_INILOA+4	; Deallocate this with INILOA
	BRB	5$
2$:	CMPL	W^BOO$GL_NEXTPFN,-	; Alloc over the CI ucode?
		W^CI_HI_PFN
	BGEQ	3$			; Branch if not
	BRW	BUMP_CI			; Yes, fatal error

3$:	MOVL	W^FIL$GQ_CACHE+4,R1	; Physical location of cache
	BSBW	MOVEMAPPED		; Move the cache
;
; If a top level system directory is in use, move its name for INIT
;
5$:	TSTB	W^FIL$GT_TOPSYS		; Is there a TOPSYS directory?
	BEQL	10$			; Branch if not
	MOVC3	#10,W^FIL$GT_TOPSYS,W^BOO$GT_TOPSYS ; Yes, make a copy for INIT
10$:
;
; Move the Boot Control Block to its place in non-paged pool.  Finish
; initializing it and the system disk boot driver for use in INIT. 
; This boot control block contains retrieval pointer virtual to logical
; maps for SYS.EXE and SYSDUMP.DMP.  After moving the boot control block,
; the boot driver, and its associated microcode file - if any - , are
; moved adjacent to it.  The space allocated for the boot control block
; includes the space for the boot driver and the microcode.  This code
; moves the 3 pieces into one area of pool.  BOO$W_SIZE of the Boot
; Control Block contains the size without the boot driver.  BOODRV_STAT
; + STAT_L_BYTECNT contains the size with the boot driver and microcode.
;
MOVBOODRIVER:
	MOVL	W^BOOTCB,R1		; Physical adr of boot control block
	MOVL	W^BOO$GL_BOOTCB,R7	; Pool adr to put boot control block
	BBC	#RPB$V_NOSYSDISK, -	; If we have removed the system disk,
		   RPB$B_FLAGS(R11),10$	;  make a single invalid map ptr for sys
	ADDL3	R1,BOO$L_SYS_MAP(R1),R0	; R0 -> list of rtrv pointers
	MOVL	#8,(R0)			; One pointer, eight bytes long
	CLRL	4(R0)			; Zero blocks in the window
	MNEGL	#1,8(R0)		; Window starts at LBN -1
10$:	ADDL	R7,BOO$L_SYS_MAP(R1)	; Relocate adr of virtual to logical
	TSTL	BOO$L_DMP_SIZE(R1)	; If dump file is empty
	BEQL	20$			;  then leave map address 0
	ADDL	R7,BOO$L_DMP_MAP(R1)	; maps for SYS and SYSDUMP
20$:	BBS	#RPB$V_NOSYSDISK, -	; If we have removed the system disk,
		   RPB$B_FLAGS(R11),30$	;  skip adjustments of param and bug maps
	ADDL	R7,BOO$L_PARAM_MAP(R1)	; and for SYSPARAM
	ADDL	R7,BOO$L_BUG_MAP(R1)	; and for non-resident BUGCHECK
30$:	MOVZWL	BOO$W_SIZE(R1),R6	; Size of BOOTCB not including boot driver
	MOVQ	W^UCODE_LEN,-(SP)	; Save room for ucode file
	PUSHAB	(R7)[R6]		; Save SYS virtual adr to put boot driver
	MOVL	W^BOODRV_STAT+STAT_L_BYTECNT,R0 ; Size of BOOTCB + boot driver
	MOVW	R0,BOO$W_SIZE(R1)	; Set size of BOOTCB+driver+ucode
	SUBL2	W^UCODE_LEN,R0		; Size of driver+BOOTCB
	SUBL3	R6,R0,-(SP)		; Save size of boot driver to move
	ADDL3	(SP),4(SP),12(SP)	; Set sys virtual adr of ucode
	BSBW	MOVEMAPPED		; Move BOOTCB to pool
	MOVQ	(SP)+,R6		; R6 = Size of boot driver to move
					; R7 = SYS virtual adr to put it
	MOVL	RPB$L_IOVEC(R11),R1	; Physical address of boot driver
	MOVL	R7,RPB$L_IOVEC(R11)	; Set new SYS virtual adr of boot driver
	MOVL	R7,R8			; Save it away for later
	BSBW	MOVEMAPPED		; Move the boot driver adjacent to BOOTCB
	MOVL	W^MMG$GL_SPTBASE,-	; Set SPT virtual address as
		RPB$L_SVASPT(R11)	;  adr of SYS page table for BOOTDRIVR
	MOVQ	(SP)+,R6		; R6 = Size of ucode to move
					; R7 = SYS virtual adr to put it
	MOVL	W^UCODE_ADR,R1		; Physical address of ucode
	BEQL	40$			; There isn't any
	MOVL	R7,W^BOO$GL_UCODE	; Stuff the virtual adr away
	BSBW	MOVEMAPPED		; Move the ucode adjacent to boot driver
	CMPW	W^VMB_VERSION,#8	; If the version is >= 8
	BLSSU	40$			;  then update the cell
	MOVAL	W^BOO$GL_UCODE,R1	; Pick up physical addr of cell w/VA
	MOVL	#4,R6			; 4 bytes to move
	MOVAL	BQO$L_UCODE(R8),R7	; VA of where to stick it
	BSBW	MOVEMAPPED		; Move the VA
40$:
;
; Move the copy of BOOPARAM that SYSBOOT has filled with data 
; into INIT's copy of BOOPARAM.
;
MOVBOOPARAM:
	MOVL	#BOO$C_BOOPARSZ,R6	; Size of BOOPARAM in bytes
	MOVL	#EXE$A_BOOPARAM,R7	; Get System VA of BOOPARAM
	MOVAL	W^BOO$A_BOOPARAM,R1	; Address of SYSBOOT copy
	BSBW	MOVEMAPPED		; Move SYSBOOT copy into SYS copy.
;
; Now locate INIT and transfer control to it
;
	MOVL	#<<EXE$INIT-^X80000000>@-9>,R3	; VPN OF INIT
	MOVL	@W^MMG$GL_SBR[R3],R0	; GET PHYSICAL PAGE NUMBER
	EXTZV	#PTE$V_PFN,#PTE$S_PFN,R0,R3 ; ISOLATE PFN AND SAVE IN R3
	ASHL	#9,R3,R0		; CONVERT TO PHYS ADDRESS
	MOVL	#EXE$INIT,R1		; VIRTUAL ADDRESS OF INIT
	INSV	R1,#0,#9,R0		; INSERT BYTE OFFSET TO GET PHYSICAL
	MTPR	W^MMG$GL_SBR,#PR$_SBR	; SET SYSTEM BASE REGISTER
	MTPR	W^MMG$GL_SPTLEN,#PR$_SLR; AND LENGTH REGISTER
	ADDL	#2,R3			; P0 LENGTH=PFN+1+1
	MTPR	R3,#PR$_P0LR		; SET P0 LENGTH TO PFN OF EXE$INIT
	SUBL3	R0,#<EXE$INIT-^X80000000>,R2	; DELTA PFN-VPN
	ASHL	#-9,R2,R2		; CONVERT TO PAGE COUNT
	MOVAL	@W^MMG$GL_SPTBASE[R2],R1; COMPUTE BASE FOR P0 PT
	MTPR	R1,#PR$_P0BR		; AND SET AS BASE REGISTER
	INVALID				; INVALIDATE TRANSLATION BUFFER
	JMP	(R0)			; TRANSFER TO INIT
;
;	R0 = PHYSICAL ADDRESS OF EXE$INIT
;	R1 = ** UNDEFINED **
;	R2 = ** UNDEFINED **
;	R3 = ** UNDEFINED **
;	R4 = ** UNDEFINED **
;	R5 = ** UNDEFINED **
;	R6 = ** UNDEFINED **
;	R7 = ** UNDEFINED **
;	R8 = ** UNDEFINED **
;	R9 = ** UNDEFINED **
;	R10 = ** UNDEFINED **
;	R11 = PHYSICAL ADDRESS OF RESTART PARAMETER BLOCK (RPB)
;	AP = ** UNDEFINED **
;	FP = ** UNDEFINED **
;	SP = PHYSICAL ADDRESS OF A 3 PAGE STACK
;	PR$_SBR/PR$_SLR - SET TO DESCRIBE SPT
;	PR$_P0BR/PR$_P0LR - SET TO MAP EXE$INIT VIRTUAL = REAL
;

	.SBTTL	ADD MEMORY DESCRIPTORS TO RPB
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS EXECUTED OR NOT DEPENDING UPON WHAT VERSION OF
;	VMB BUILT THE RESTART PARAMETER BLOCK.  VERSION 1 AND 2 OF VMB
;	DO NOT INCLUDE THE PAGE COUNT, TR NUMBER, AND BASE PFN TO DESCRIBE
;	EACH MEMORY ON THE SYSTEM.  VERSION 3 AND SUBSEQUENT VERSIONS INCLUDE
;	THIS INFORMATION.  THIS INFORMATION IS USED BY BUG CHECK IN DUMPING
;	MEMORY TO THE SYSTEM DUMP FILE.  THIS ROUTINE ADDS A MEMORY
;	DESCRIPTOR TO THE RPB.  THIS DESCRIPTOR IS BUILT USING THE
;	ASSUMPTIONS THAT PRE-RELEASE 2.0 BUG CHECKS USED, I.E., THAT
;	MEMORY STARTS AT PFN 0 AND IS BOUNDED AT THE OTHER END BY THE
;	SYSTEM PAGE TABLE.
;
; CALLING SEQUENCE:
;
;	BSBW	ADD_RPB_MEMDSC
;
; INPUT PARAMETERS:
;
;	R11 - ADR OF REBOOT PARAMETER BLOCK
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT INPUTS:
;
;	PR$_SBR AND PR$SLR ARE USED TO DETERMINE THE SIZE OF MEMORY.
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	A MEMORY DESCRIPTOR IS ADDED TO THE RPB IF ONE IS NOT INCLUDED.
;--

ADD_RPB_MEMDSC:
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	; SAVE REGISTERS
	MOVAB	RPB$L_MEMDSC(R11),R4	; GET ADR OF FIRST MEMORY DESCRIPTOR
	MFPR	#PR$_SBR,R3		; GET PHYSICAL ADR OF SYS PAGE TBL
	MFPR	#PR$_SLR,R2		; GET LENGTH OF SPT IN BYTES
	MOVAL	(R3)[R2],R2		; GET # OF BYTES OF MEMORY TOTAL
	ASHL	#-9,R2,(R4)+		; SET # OF PAGES (NO TR #) INTO MEMDSC
	MOVC5	#0,(R11),#0, -		; SET THE BASE PFN TO 0 AND FILL THE
		#<<RPB$C_LENGTH-RPB$L_MEMDSC>-4>,(R4) ; OTHER MEMDSC'S WITH 0'S
	POPR	#^M<R0,R1,R2,R3,R4,R5>	; RESTORE REGISTERS
	RSB				;
	.PAGE
	.SBTTL	IMAGE_OPEN - Look up image file
;
; Input parameters:
;	R2		= Statistics block for file to open
;	STAT_L_NAME(R2)	= base relative adr of ASCIC file name
;
; Output parameters:
;	R0 = Status
;	R1 = Address of file header buffer
;	R7,R8,R9 altered
;	R2-R5 preserved
;	STAT_L_MAP(R2)	   = Data to map virtual block to logical block
;	STAT_L_BYTECNT(R2) = Size of file in bytes
;
IMAGE_OPEN:
	ADDL3	W^SYSBOOT_BASE,STAT_L_NAME(R2),R1 ; Address of ASCIC name string
	MOVZBL	(R1)+,R0		; R0 = size, R1 = address
	MOVQ	R0,-(SP)		; Save file name descriptor
	MOVL	SP,R7			; Address of file name descriptor
	MOVAL	W^RTRV_BUF_DSC,R9	; Address of rtrv ptr buffer descriptor
	MOVQ	(R9),R0			; R0 = size, R1 = address of buffer
	CMPL	R0,#3*4			; At least 3 long words required
					; to express a contiguous file
	BLSS	110$			; Branch if out of space, fatal
	MOVAL	(R1)+,R8		; R8 = loc to store byte count returned
					; R1 = R1 + 4
	MNEGL	#4,(R8)			; Init count returned for error path
	SUBL	#4,R0			; Account for byte count long word
	MOVQ	R0,(R9)			; Size and address of buffer
					; to store retrieval pointers in
	BSBW	FILOPEN			; Call FIL$OPENFILE
	ADDL	#8,SP			; Clean off name descriptor
	SUBL	(R8),(R9)+		; Allocate retrieval pointers used
	BLSS	110$			; Branch if not enough space
	ADDL	(R8),(R9)		; Update next available address
	BLBC	R0,20$			; Leave bytecnt 0 if error
	ASHL	#9,W^BOO$GQ_STATBLK+4,STAT_L_BYTECNT(R2) ; Size of file in bytes
	MOVL	R8,STAT_L_MAP(R2)	; Save adr of virtual to logical map
20$:	RSB				; Otherwise return with status in R0
;
; Not enough space for retrieval pointers, the boot time files were
; far more fragmented than was planned for.  Only SYS.EXE is big
; enough to cause such a problem.  All the drivers are so small that
; a few pointers each is adequate.
;
110$:	MSG	<-F-Boot time files have too many non-contiguous pieces>
	HALT				; ***** Fatal error *****
	.PAGE
	.SBTTL	IMAGE_INIT - Look up and start read of image file
;
; Input parameters:
;	R2		= Statistics block for file to open
;	STAT_L_NAME(R2)	= base relative adr of ASCIC file name
;
; Output parameters:
;	Returns to caller only if successful.
;	On error, prints diagnostic and halts
;	R0,R1,R3,R4,R7,R8,R9 altered
;	R2,R5 preserved
;	R6		= Adr of first block read in past image header
;	STAT_L_MAP(R2)	= Data to map virtual block to logical block
;	STAT_L_VBN(R2)	= Starting VBN in image after image header block(s)
;	STAT_L_VBN2ADR(R2) = Address of 1st block after image header block(s)
;
IMAGE_INIT:
	BSBW	IMAGE_OPEN		; Open the file
	BLBC	R0,90$			; Branch if failed to find file
;
; Read 2 blocks on the assumption that the image header will only take
; up the first block.  This is essentially always correct.
;
	ADDL3	W^VBN2_BUF_DSC,W^VBN2_BUF_DSC+4,R6 ; Adr of last+1 byte of
					; block buffer for reading and saving
					; the 1st block after image header
	MOVAB	-1024(R6),R6		; Back off 2 pages, first is image
					; header, 2nd is first block after
	SUBL	#512,W^VBN2_BUF_DSC	; Record another page used
	ROTL	#9,#2,R9		; Set to read 2 VBN's
	MOVL	#1,R3			; Starting with VBN 1
	MOVL	STAT_L_MAP(R2),R4	; Adr of virtual to logical map
	BSBW	READ_VIRTUAL		; Read the desired VBN's
	BLBC	R0,100$			; Branch if read error
	MOVZBL	IHD$B_HDRBLKCNT(R6),R3	; Get # header blks
	INCL	R3			; Starting VBN of image
	MOVL	R3,STAT_L_VBN(R2)	; Save for reading image later
	MOVAB	512(R6),R6		; Address of VBN 2
	CMPL	R3,#2			; One image header block?
	BEQL	20$			; Branch if yes, the norm
;
; Lost a good bet, now read one block after the image header blocks
;
	ROTL	#9,#1,R9		; Set up to read one block
	BSBW	READ_VIRTUAL		; Read the desired VBN
	BLBC	R0,100$			; Branch if read error
20$:	MOVL	R6,STAT_L_VBN2ADR(R2)	; Note where VBN2 was read
	RSB
;
; Failed to open file
;
90$:	MSG	<-E-Unable to locate file >
;
; Error opening or reading the file, error message already given,
; add on the file name to complete the diagnostic
;
100$:	ADDL3	W^SYSBOOT_BASE,STAT_L_NAME(R2),R1 ; Address of ASCIC file name
	BSBW	BOO$TYPE_ASCIC		; Type the name
	HALT				; ***** Fatal Error *****
	.PAGE
	.SBTTL	BOO$FILOPEN - Lookup a specified file
;
; Input Parameters:
;	R7 - Address of file name descriptor
;
; Output Parameters:
;	R0 - Status, if error, message (without file name) already typed
;	R8 - Starting LBN of file
;	R9 - Size of file in blocks
;
BOO$FILOPEN::				; File open Routine
	CLRQ	R8			; No retrieval pointer info needed
	BSBB	FILOPEN			; Call FIL$OPENFILE
	BLBS	R0,10$			; Branch if successful
	MSG	<-E-Unable to locate file > ; Report the failure
	BRB	20$
10$:	MOVQ	W^BOO$GQ_STATBLK,R8	; Get file statistics, LBN/Size in blocks
	TSTL	R8			; Check for contiguous
	BNEQ	30$			; Yes, continue
	MSG	<-E-File not contiguous > ; Give error
20$:	CLRL	R0			; Indicate error
30$:	RSB				; Return to caller
;
; Inputs:
;	R7 - Address of file name descriptor
;	R8 - Address to return byte of retrieval pointer data stored
;	     0 if not used
;	R9 - Address of descriptor of retrieval pointer buffer
;	     0 if not used
;
; Outputs:
;	R0 - Status
;	R1 - Address of file header buffer
;	All other registers preserved
;	BOO$GQ_STATBLK     = Starting LBN if contiguous, 0 if not
;	BOO$GQ_STATBLK + 4 = Size of file in blocks
;
FILOPEN:
	MOVAL	-(SP),R0		; Save pointer to phony channel
	MOVQ	R8,-(SP)		; Push adr of rtrv buf descriptor
					; Push adr to return byte count stored
	PUSHAQ	W^BOO$GQ_STATBLK	; Address of file statistics block
	PUSHL	W^BOO$GL_FREEMEM	; file header buffer
	ADDL3	#512,(SP),-(SP)		; Index file header buffer
	PUSHAL	(R7)			; Address of file name descriptor
	PUSHAL	(R0)			; Address of phony channel
	CALLS	#7,W^FIL$OPENFILE	; Call FILEREAD to locate file
	MOVL	W^BOO$GL_FREEMEM,R1	; Return address of file header
	ADDL2	#4,SP			; Clean off phony channel
	RSB				;  and return
	.PAGE
	.SBTTL	ALLOCPFN - Allocate physical page
;
; Output parameters:
;	R0 - PFN of allocated page
;
ALLOCPFN:				;
	MOVL	W^BOO$GL_NEXTPFN,R0	; Get PFN to start scan
	BNEQ	20$			; Branch if not null
10$:	ASHL	#3,RPB$Q_PFNMAP(R11),R0	; Else start at end of map
15$:	DECL	R0			; Next/first PFN
	BLEQ	30$			; Branch if none left
20$:	BBCC	R0,@RPB$Q_PFNMAP+4(R11),15$	; Allocate it if possible
	SUBL3	#1,R0,W^BOO$GL_NEXTPFN	; Save pointer for next time
	DECL	RPB$L_PFNCNT(R11)	; Account for page removed
	CMPL	R0,W^PFNMAP_HI_PFN	; Ran into PFN bitmap?
	BGTRU	22$
	BRW	PHYP_ER			; Branch if yes
22$:	CMPL	R0,W^CACHE_HI_PFN	; Ran into FIL$OPENFILE cache?
	BGTR	25$			; Branch if not
	CLRQ	W^FIL$GQ_CACHE		; Yes, disable it
	CLRL	W^CACHE_HI_PFN
25$:	CMPL	R0,W^CI_HI_PFN		; Ran into CI microcode?
	BLEQU	40$			; Yes
	RSB				;  and return
30$:	MSG	<-F-Unable to allocate physical memory>
	HALT				; **** FATAL ERROR ****
40$:	BRW	BUMP_CI
;
; Functional Description:
;	DALLOCPFN marks the specified page available in the PFN bitmap
;	but does not reposition the scan pointer.
;
; Calling Sequence:
;	BSBW	DALLOCPFN
; Input Parameters:
;	R0 - PFN
;
DALLOCPFN:				; Deallocate pfn
	BBSS	R0,@RPB$Q_PFNMAP+4(R11),10$	; Mark it available
10$:	RSB				; And return

	.PAGE
	.SBTTL	MOVE_BITMAP - move the PFN bit map if PHYSICAL PAGES reduced

;++
; Functional Description:
;	An attempt is made to either move the PFN bitmap to the preallocated
;	small bit map or if that fails, to unused physical memory.
;
; Inputs:
;	R0 - Highest page represented in current bitmap
;	R1 - Base of current bitmap
;	R3 - Required size of new bit map (bits)
;
; Outputs:
;	R0 -> highest page for new bitmap
;	R1 -> New base of bitmap
;	all otherregisters preserved
;
;--

MOVE_BITMAP:
	PUSHR	#^M<R2,R3,R4,R5,R6> 	; Get some scratch registers
	ASHL	#-3,R3,R6		; Full bytes to copy from current bitmap
	INCL	R6			; One more for last byte
	CMPL	R6,W^SMALL_PFNMAP	; Can it hold everything we intend to use
	BGTRU	10$			; No
	MOVC5	R6,@RPB$Q_PFNMAP+4(R11),- ; Copy the bitmap
		#0,W^SMALL_PFNMAP,@W^SMALL_PFNMAP+4
	MOVQ	W^SMALL_PFNMAP,RPB$Q_PFNMAP(R11) ; Use the small bitmap
	BRB	50$
;
10$:	ADDL3	#4096,R3,R5		; Round up the bit map pages needed
	ASHL	#-12,R5,R5		; Make it pages
20$:	CLRL	R4			; Count of contiguous pages found
	MOVL	R3,R2			; Save base page
30$:	CMPL	R3,R0			; Time to give up?
	BGEQU	60$			; Yes - not enough contiguous pages
	INCL	R3			; Next page
	BBC	R3,(R1),20$		; Is page good - no - start again
	INCL	R4			; One more
	CMPL	R4,R5			; Found enough?
	BLSS	30$			; No - try for more
	ASHL	#9,R2,R2		; Base of new bitmap
	MOVL	R2,RPB$Q_PFNMAP+4(R11)
	MOVL	R6,RPB$Q_PFNMAP(R11)	; New size of bitmap
	MOVC3	R6,(R1),(R2)		; Copy the bitmap
;
50$:	CLRL	W^PFNMAP_HI_PFN		; No longer need to check for conflicts
60$:	POPR	#^M<R2,R3,R4,R5,R6>
	MOVL	R3,W^MEM_HI_PFN		; Forget about discarded pages
	MOVQ	RPB$Q_PFNMAP(R11),R0	; New base and limit
	MULL	#8,R0
	RSB

	.PAGE
	.SBTTL	LOAD_CODE - load the code from the specified file

;++
; Functional Description:
;	Given a statistics block for a file, load the file into pool
;	The first block after the image header was previously read
;	in to determine the size of the image.  This buffer was
;	saved to avoid reading it again.  Move this page and
;	read the rest.
;
; Inputs:
;	STAT_L_VBN2ADR(R2) = Address of 1st block after image header
;			     It was already read in, just move this page
;	STAT_L_VBN(R2)	   = Starting virtual block number to read
;	STAT_L_BYTECNT(R2) = Number of bytes in image
;	STAT_L_MAP(R2)	   = Mapping information to map VBN to LBN
;	STAT_L_SYSVA(R2)   = Base relative address of pool address
;	STAT_L_NAME(R2)	   = Base relative address of name for error msg
;
; Outputs:
;	Returns in line only if successful
;	Types diagnostic and halts if error
;	R0,R1,R3,R4,R6,R9 altered
;	All other registers preserved
;--

LOAD_CODE:
	PUSHL	R7
	MOVL	STAT_L_VBN2ADR(R2),R1	; Adr of 1st block after image hdr
	ADDL3	W^SYSBOOT_BASE,STAT_L_SYSVA(R2),R7 ; Adr of pool adr for image
	MOVL	(R7),R7			; Adr in pool to move 1st page of image
	PUSHAB	512(R7)			; Adr in pool to read into
	ROTL	#9,#1,R6		; Move 1 page or less
	CMPL	R6,STAT_L_BYTECNT(R2)	; Image less than a page?
	BLEQ	10$			; Branch if not
	MOVL	STAT_L_BYTECNT(R2),R6	; Yes, use the image size
10$:	SUBL3	R6,STAT_L_BYTECNT(R2),R9 ; Byte count left to be read
	PUSHR	#^M<R2,R4,R5>
	BSBW	MOVEMAPPED		; Move the 1st image block after the
					; image hdr, avoid reading it again
	POPR	#^M<R2,R4,R5,R6,R7>	; R6 = Adr to read into
	ADDL3	#1,STAT_L_VBN(R2),R3	; Starting VBN to read
	TSTL	R9			; Anything left to read?
	BGTR	20$			; Branch if yes
	RSB				; Move was all that was needed
20$:	MOVL	STAT_L_MAP(R2),R4	; Adr of virtual to logical map
	BSBB	READ_VIRTUAL		; Read the specified VBN's
	BLBC	R0,30$			; Branch if failed to read them
	RSB
30$:	ADDL3	W^SYSBOOT_BASE,STAT_L_NAME(R2),R1 ; Adr of ASCIC file name
	BSBW	BOO$TYPE_ASCIC		; Append the file name to error msg
	HALT				; ***** Fatal Error *****
	.PAGE
	.SBTTL	BOO$SETMAP - Set up Virtual to Logical Map
;++
; Functional Description:
;	This routine produces a virtual to logical map for a specified
;	virtual segment of a file.  Give a desired virtual block and
;	block count and a map of the file, it produces a new map for 
;	just that segment.
;
; Calling Sequence:
;	BSBW	BOO$SETMAP
;
; Inputs:
;	R3 = Desired VBN
;	R4 = Virtual to logical map
;	R5 = Desired number of blocks to map
;	R6 = Size in bytes of region to store the map being created
;	R7 = Address of region to store the map being created
;
; Outputs:
;	R0,R1,R2,R3,R5 altered
;	R4 preserved
;	R6,R7 updated to reflect space used
;	others preserved
;--
BOO$SETMAP:
	PUSHL	R4			; Save input map
	PUSHAL	(R7)+			; Save Adr of output byte count
					; R7 points to first rtrv ptr to store
	BSBB	BOO$MAPVBN		; Find starting LBN
	TSTL	R0			; If EOF, then done
	BEQL	60$
20$:	CMPL	R0,R5			; More block mapped than needed?
	BLEQ	40$			; Branch if not
	MOVL	R5,R0			; Yes, just use what is needed
40$:	MOVQ	R0,(R7)+		; Store this retrieval pointer
	SUBL	R0,R5			; Count blocks mapped
	BLEQ	60$			; Branch if all done
	MOVQ	(R4)+,R0		; Get next retrieval pointer
	SOBGTR	R2,20$			; If there are any more
60$:	POPR	#^M<R2,R4>		; R2 = Adr of byte count field
					; R4 = saved input map
	SUBL3	R2,R7,R0		; No. of bytes used
	SUBL	R0,R6			; Adjust size of buffer remaining
	SUBL3	#4,R0,(R2)		; No. of bytes of retrieval pointers
	RSB
	.PAGE
	.SBTTL	BOO$MAPVBN - Map Virtual to Logical Block
;++
; Functional Description:
;	Map the specified virtual block to its associated logical block
;
; Calling Sequence:
;	BSBW	BOO$MAPVBN
;
; Inputs:
;	R3 = Virtual Block Number
;	R4 = Address of virtual to logical map
;		# of bytes of retrieval pointers following
;		count of LBN's in first rtrv ptr
;		starting LBN in first rtrv ptr
;		count of LBN's in second rtrv ptr
;		starting LBN in second rtrv ptr
;
;		...
;
;		count of LBN's in last rtrv ptr
;		starting LBN in last rtrv ptr
;
; Outputs:
;	R0 = Number of contiguous blocks starting at LBN in R1
;	R1 = Starting LBN for the specified VBN
;	R2 = number of retrieval pointers (quad words) not yet used in the map
;	R3 = VBN preserved
;	R4 = pointer to first retrieval pointer not yet used in map
;	all other registers preserved
;--
BOO$MAPVBN:
	PUSHL	R3			; Save desired VBN
	ASHL	#-3,(R4)+,R2		; Get count of quad words
					; Point at first retrieval pointer
10$:	MOVQ	(R4)+,R0		; R0 = block count, R1 = LBN
	CMPL	R3,R0			; Desired VBN in this rtrv ptr?
	BLEQ	20$			; Branch if yes
	SUBL	R0,R3			; Pass over that many VBN's
	SOBGTR	R2,10$			; Try the next retrieval pointer
	CLRQ	R0			; EOF, no blocks mapped
	BRB	30$
20$:	DECL	R3			; Make VBN base 0
	SUBL	R3,R0			; No. of blocks left
	ADDL	R3,R1			; Starting LBN for desired VBN
30$:	POPR	#^M<R3>			; Recover desired VBN
	RSB
	.PAGE
	.SBTTL	BOO$READFILE - Routine to read specified piece of file
;++
; Functional Description:
;	BOO$READFILE reads the specified piece of the file
;
; Calling Sequence:
;	BSBW	BOO$READFILE
;
; Inputs:
;	R6 - Buffer address (updated)
;	R8 - Logical block number (updated)
;	R9 - Blocks in file (updated)
;
; Outputs:
;	R0 - Status, diagnostic issued (without file name) if error
;	R1,R6-R9 altered
;	R2-R5 preserved
;--
BOO$READFILE::				;
	MOVQ	R10,-(SP)		; Save additional registers
	MOVZWL	#IO$_READLBLK,R10	; Read function
	MOVL	W^BOO$GL_RPBBASE,R11	; RPB address
	ASHL	#9,R9,R9		; Form byte count to transfer
	BSBW	QIO_RWLB		; Read the specified blocks
	ASHL	#-9,R9,R9		; Pages not transferred
	MOVQ	(SP)+,R10		; Restore additional registers
	BRB	READ_COMPLETE		; Use common exit path
	.PAGE
	.SBTTL	READ_VIRTUAL - Read specified virtual blocks of a file
;++
; Functional Description:
;	This routine maps the specified virtual blocks to logical blocks
;	and reads the desired number of bytes into the specified location
;	in memory.
;
; Inputs:
;	R3 = Virtual Block Number
;	R4 = Mapping info for virtual to logical mapping:
;		# of bytes of retrieval pointers following
;		count of LBN's in first rtrv ptr
;		starting LBN in first rtrv ptr
;		count of LBN's in second rtrv ptr
;		starting LBN in second rtrv ptr
;
;		...
;
;		count of LBN's in last rtrv ptr
;		starting LBN in last rtrv ptr
;	R6 = Buffer Address to read into
;	     if system bit is set, then the system map is used
;	R9 = Byte count to read (quad word aligned)
;
; Outputs:
;	R0 = Status, diagnostic issued if error (without file name)
;	R1 altered
;	All other registers preserved
;
;--

READ_VIRTUAL:
	PUSHR	#^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	MOVL	W^BOO$GL_RPBBASE,R11	; Address of RPB
	MOVZWL	#IO$_READLBLK,R10	; Read logical block function
	BSBB	BOO$MAPVBN		; Convert starting VBN to LBN
	TSTL	R0			; End of file?
	BNEQ	40$			; Branch if not
	BRB	60$			; Yes, report the error
30$:	MOVQ	(R4)+,R0		; Get the next rtrv ptr
;
; R0 = number of blocks that can be read in this portion
; R1 = starting LBN to read from
;
40$:	PUSHL	R9			; Save desired byte count
	ASHL	#9,R0,R0		; # of bytes that can be read
	CMPL	R9,R0			; If fewer are needed
	BLEQ	50$			; Then read the smaller number
	MOVL	R0,R9			; Otherwise read all we can
50$:	SUBL	R9,(SP)			; Note how much is left to be read
	MOVL	R1,R8			; Starting LBN of read request
	BSBW	QIO_RWLB		; Read or write the file
	MOVL	(SP)+,R9		; Recover byte left to be read
	BLEQ	90$			; Branch if all done
	BLBC	R0,90$			; Branch if read error
	SOBGTR	R2,30$			; Get the next retrieval pointer
60$:	MOVZWL	#SS$_ENDOFFILE,R0	; Indicate EOF error
	BSBB	CONEOF_CHECK		; Check EOF to see if booting from console
	TSTL	R0			; R0 will be cleared if read should continue
	BEQL	30$
90$:	POPR	#^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
;
; R0 = status from read
;
READ_COMPLETE:
	BLBS	R0,30$			; Branch if read successful
	CMPW	#SS$_ENDOFFILE,R0	; If it is an EOF error
	BNEQ	10$
	MSG	<-E-End of file error reading > ; Report EOF error
	BRB	20$
10$:	MSG	<-E-I/O error reading file > ; Otherwise catchall error
20$:	CLRL	R0			; Indicate error occurred
30$:	RSB
	.PAGE
	.SBTTL	CONEOF_CHECK
;++
; Functional Description:
;	This routine checks for a specific end-of-file situation.  If we get an EOF
;	while reading SYS.EXE from the console device, then we will prompt for the
;	next volume to be mounted in the console drive.  After the next volume is
;	loaded, we will open the next piece of SYS.EXE.  We will add a dummy retrieval
;	pointer which will map the previous piece(s) of SYS.EXE to an invalid VBN.
;	Finally, we will modify the registers so that READ_VIRTUAL can continue to
;	read in the next piece of SYS.EXE.
;
; Calling Sequence:
;	BSBx	CONEOF_CHECK
;
; Inputs:
;	R0  = SS$_ENDOFFILE
;	R1  = (trash)
;	R2  = count of rtrv ptr remaining (should be zero since we are in EOF)
;	R3  = VBN
;	R4  = pointer to next rtrv ptr (during eof points past end)
;	R5  = (trash)
;	R6  = buffer address to read to
;	R7  = (trash)
;	R8  = highest lbn in previous read 
;	R9  = Byte count left to read
;	R10 = #IO$_READLBLK
;	R11 = Address of RPB
;
; Outputs:
;	R0  = 0 if read should be continued, unchanged if EOF error should stand.
;	If R0 = 0, then
;		R1 = (altered)
;		R2 = Count of valid retrieval pointers in the new section
;		R4 = Points to first valid pointer
;	All other registers preserved
;--
CONEOF_CHECK:
	CMPB	RPB$B_DEVTYP(R11),-	; Booting from the console block
		#BTD$K_CONSOLE		;  storage device?
	BNEQ	10$			; Not booting from console, let EOF stand
	TSTL	W^CONEOF_ENABLE		; Have console EOF's been enabled?
	BNEQ	20$			; Looks like a valid EOF, prepare for switch
10$:	RSB				; Let the EOF error stand
20$:					; Commit to either switch volumes or halt
;
; Perform a couple of sanity checks.  Make sure that syspaging is off and that we
; are reading SYS.EXE.  If we are reading SYS, then the next map pointer should
; be at the end of the map pointer described by SYS_STAT.
;
	BBC	S^#EXE$V_SYSPAGING,W^EXE$GL_DEFFLAGS,30$
	MSG	<-F-Console volume switch attempted with SYSPAGING=1, must be 0>
	HALT
30$:	MOVL	W^SYS_STAT+STAT_L_MAP,R0	; Get address of map for SYS.EXE
	ADDL2	(R0),R0				; Add length of map to address
	ADDL2	#4,R0				; Adjust for length longword
	CMPL	R4, R0				; Is it the same?
	BEQL	40$				; If same, this is SYS.EXE
	MSG	<-F-Console EOF on wrong file, supported for SYS.EXE only>
	HALT
40$:	TSTL	R2				; R2 (ptr cnt) should be zero
	BEQL	50$
	MSG	<-F-Console EOF before end of map, internal error>
	HALT
50$:
;
; Now we are convinced that we really want to try to do this.  First, disable all
; open files by clearing several fields in the stat blocks.  We do not zero the
; entire block in case we need to reopen the file later.  We also disable and
; deallocate the file open cache.
;
	MOVAL	W^CONEOF_DISABLE_STAT,R0	; First stat block to disable
	MOVL	S^#CONEOF_DISABLE_CNT,R1	; Number of blocks to disable
60$:	CLRL	STAT_L_MAP(R0)			; Clear rtrv pointer address
	ADDL	#STAT_C_SIZE,R0			; Point to next stat block
	SOBGTR	R1,60$				; Do all of them
	MOVQ	W^BOO$GQ_FILCACHE,R0		; R0 = size, R1 = pool address
	BEQL	70$				; Branch if no cache enabled
	CLRQ	W^BOO$GQ_FILCACHE		; No FIL$OPENFILE cache
	ADDL	R0,W^BOO$GQ_INILOA+4		; Deallocate this with INILOA
70$:	CLRQ	W^FIL$GQ_CACHE			; Blast the other file cache too
;
; Zero mapping information in the boot control block so that references to these
; files will be trapped.  We do not zero the BOO$L_SYS_MAP, since INIT will turn
; it into a WCB for the system.  Note that we also have to check these fields
; near the label MOVBOODRIVER, where the addresses are adjusted.
;
	MOVL	W^BOOTCB,R0			; Address of boot control block
	CLRL	BOO$L_PARAM_MAP(R0)		; Clear the parameter area map
	CLRL	BOO$L_DMP_VBN(R0)		; Clear dump file info
	CLRL	BOO$L_DMP_SIZE(R0)
	CLRL	BOO$L_DMP_MAP(R0)
	CLRL	BOO$L_BUG_MAP(R0)		; Clear the bugcheck area map
;
; Now, ask the human to switch console volumes.  Tell him to remove the old volume (and
; rewind the volume at the same time).  Wait for a "Y" that says that he is ready, and
; tell him that we are resuming on the new volume.
;
	PUSHAB	W^CONEOF_REMOVE2		; Second part of remove message
	PUSHAB	W^CONEOF_REMOVE1		; First part of remove message
	CALLS	#2,W^CONEOF_MESSAGE		; Print the message that we are going again
75$:	PUSHAL	W^CONEOF_BUFFER			; We must have a buffer
	PUSHL	#4				; Even if only one longword
	PUSHAB	W^CONEOF_PROMPT			; And the prompt
	CALLS	#3,W^BOO$READPROMPT		; Type the string
	BICB	#32,W^CONEOF_BUFFER+1		; Force to upper case (ASCIC string returned)
	CMPB	W^CONEOF_BUFFER+1,#^A"Y"	; He has to say Yes
	BNEQ	75$				; Loop until we see the Yes
	PUSHAB	W^CONEOF_RESUME2		; Second part of resume message
	PUSHAB	W^CONEOF_RESUME1		; First part of resume message
	CALLS	#2,W^CONEOF_MESSAGE		; Print the message that we are going again
;
; Reopen SYS.EXE on the next volume.  First save the current stat block and rtrv buf
; on the stack, so that we can adjust things so that it conceals the fact
; that SYS.EXE is in two pieces.
;
	PUSHR	#R2_R11				; Save registers
	SUBL2	#STAT_C_SIZE+8,SP		; Allocate the space
	MOVC3	#STAT_C_SIZE,W^SYS_STAT,(SP)	; Move the stat block to the stack
	MOVQ	W^RTRV_BUF_DSC,(R3)		; Save the current retrieval buffer
;
; Everything has been saved, now try to open the next piece of SYS.EXE
;
	MOVAB	W^SYS_STAT,R2			; Get address of stat block
	BSBW	IMAGE_OPEN			; Attempt to open the image
	BLBS	R0,80$
	MSG	<-F-Unable to open SYS.EXE on the new volume>
	HALT
80$:
;
; File is now open, fix up the stat block and retrieval pointers
;
	MOVL	W^SYS_STAT+STAT_L_MAP,R8	; R8 -> the new map
	MOVC3	#STAT_C_SIZE,(SP),W^SYS_STAT	; Restore the original stat block
	MOVL	W^SYS_STAT+STAT_L_MAP,R7	; R7 -> the original map
	MOVQ	(R3)+,W^RTRV_BUF_DSC		; Restore the original retrieval buffer
;
; R7 -> the original stat block, R8 -> the new block.  We need to create a dummy rtrv
; pointer which maps all of the blocks of the previous mapping list.  We then append
; our new pointers to the list.  The modified new list is stored over the original
; list.  Space for several additional map pointers was allocated with the original,
; make sure that the next piece isn't too fragmented.
;
	ASHL	#-3,(R8),R0			; Count of new pointers
	CMPL	R0,W^CONEOF_MAX_PTR		; How many have we allocated?
	BLEQ	90$				; Enough room
	MSG	<-F-Continuation of SYS.EXE is too fragmented>
	HALT
90$:
;
; First, get number of blocks mapped by previous map
;
	ASHL	#-3,(R7),R0			; Count of quadword pointers
	MOVAL	4(R7),R1			; R1 -> first map pointer
	CLRL	R2				; R2 will accumulate blocks
100$:	MOVQ	(R1)+,R4			; R4 is count, R5 vbn
	ADDL2	R4,R2				; Add this count to total
	SOBGTR	R0,100$				; Do every old map pointer
;
; Now create the modified mapping list
;
	ADDL3	#8,(R8),(R7)+			; Use new length plus dummy ptr
	MOVL	R2,(R7)+			; Move block count of dummy
	MNEGL	#1,(R7)+			; Set an invalid LBN
	MOVC3	(R8),4(R8),(R7)			; Append the new pointers

	ADDL2	#STAT_C_SIZE+8,SP		; Deallocate stack storage
	POPR	#R2_R11				; Restore everything
;
; Almost done, all we have to do is set up the registers so that READ_VIRTUAL can
; continue with the read.
;
	MOVL	W^SYS_STAT+STAT_L_MAP,R4	; Get the new, modified map address
	ASHL	#-3,(R4),R2			; Map byte count to quadword ptr cnt
	DECL	R2				; Ignore the dummy retrieval pointer
	ADDL2	#12,R4				; Move over len and dummy to good ptr
;
; All done with the switch, set a flag in the RPB so that anybody can check at any
; later time whether the system disk is still there.
;
	BBSS	#RPB$V_NOSYSDISK,RPB$B_FLAGS(R11),110$	; Set flag in RPB
110$:	CLRL	R0				; Tell READ_VIRTUAL to resume
	RSB

;+
; Print a two piece message including the volume label.
; Inputs:	4(AP)	Address of first part of string
;		8(AP)	Address of second part
;-
CONEOF_MESSAGE:
	.WORD	R2_R11				; Save all registers
	MOVL	W^BOO$GL_FREEMEM,R6		; Get a buffer for volume header
	MOVL	R6,R5				; Save a second copy
	MOVL	#1,R8				; Read lbn 1
	MOVZWL	#512,R9				; Read a single block
	MOVZWL	#IO$_READLBLK,R10		; Move the read function code
	BSBB	QIO_RWLB			; Read the block
	BLBS	R0,10$				; Branch if successful
	MSG	<-F-Unable to read continuation volume>
	HALT
10$:	CLRQ	-(SP)				; Null buffer is print only
	PUSHL	4(AP)				; Pass address of first string
	CALLS	#3,W^BOO$READPROMPT		; Type the first string
	MOVAB	472(R5),R5			; Point R5 at the volume label
	MOVL	#12,R0				; Length of volume label
	MOVAB	(R5)[R0],R1			; Point R1 one past the end
20$:	MOVB	-(R1),R2			; R2 contains the byte
	BEQL	30$				; Byte is null, skip it
	CMPB	#^A" ",R2			; Is it a space
	BNEQ	40$				; End of name found, print it
30$:	SOBGTR	R0,20$				; Do the whole string
	BRB	50$				; No name, don't bother not printing it

40$:	CLRB	1(R1)				; Put a null after the string
	CLRQ	-(SP)				; Null buffer is print only
	PUSHL	R5				; R5 -> front of volume label
	CALLS	#3,W^BOO$READPROMPT		; Type the first string
50$:	CLRQ	-(SP)				; Null buffer is print only
	PUSHL	8(AP)				; Finish the message
	CALLS	#3,W^BOO$READPROMPT		; Type the second string
	RET
	.PAGE
	.SBTTL	QIO_RWLB - Read or Write Logical Block
;++
; Functional Description:
;	This routine reads/writes the specified logical block numbers
;	from/to the boot disk.
;
; Calling Sequence:
;	BSBW	QIO_RWLB
;
; Inputs:
;	R6  = Buffer address (updated)
;	R8  = Logical block number (updated)
;	R9  = Byte count to transfer (up to 31 bits)
;	R10 = #IO$_READLBLK or #IO$_WRITELBLK
;	R11 = RPB address
; Outputs:
;	R0 = Status
;	R1,R6-R9 altered
;	All other registers preserved
;--
QIO_RWLB:
10$:	MOVZWL	#IOSIZE*512,R7		; Assume maximum transfer
	CMPL	R7,R9			; Minimize with file size
	BLEQ	20$			; Smaller than remaining file size
	MOVL	R9,R7			; Set to remaining file size
20$:	PUSHL	R11			; Base of RPB
	EXTZV	#VA$V_SYSTEM,#1,R6,-(SP) ; Set mode to virtual if system space
	PUSHR	#^M<R6,R7,R8,R10>	; R/W, LBN, size in bytes, buffer adr
	MOVL	RPB$L_IOVEC(R11),R0	; GET POINTER TO I/O VECTOR
	CALLS	#6,@BQO$L_QIO(R0)[R0]	; Perform read
;
; R0 = status of transfer, if successful, see if there is any more to do.
;
	BLBC	R0,30$			; Branch if error
	ASHL	#-9,R7,R1		; Block count
	ADDL	R1,R8			; Starting LBN for next piece
	ADDL	R7,R6			; Starting Buf Adr for next piece
	SUBL	R7,R9			; Count bytes tranferred
	BGTR	10$			; Branch if another transfer to do
30$:	RSB
	.PAGE
	.SBTTL	BOO$USEFILE - Use parameter file
;++
; Functional description:
;	BOO$USEFILE reads the specified file in response to the USE
;	command and merges all of the values specified in that file into
;	the working copy of the parameter values.  This is accomplished
;	by looking up each value specified and merging the associated 
;	value.
;
; Calling sequence:
;	CALLG	arglist,BOO$USEFILE
;
; Input Parameters:
;	TPA$L_TOKENCNT(AP) - Length of file name string
;	TPA$L_TOKENPTR(AP) - Address fo file name string
; Output Parameters:
;	R0 - Completion status code
;
;--
BOO$USEFILE::				;
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9>	; Entry mask

	BBSS	#EXE$V_WRITESYSPARAMS,-	; Use a file => write current needed
		G^EXE$GL_DYNAMIC_FLAGS,1$;
1$:
	MOVAB	TPA$L_TOKENCNT(AP),R7	; Set address of file name descriptor
	BSBW	BOO$FILOPEN		; Open specified file
	BLBS	R0,20$			; Continue if success
10$:	MOVZWL	#1,R0			; Force success
	RET				;
20$:	MOVL	W^BOO$GL_FREEMEM,R6	; Set address of parameter buffer
	BSBW	BOO$READFILE		; Read file content into parameter buffer
	BLBC	R0,10$			; Exit if error
	ADDL3	#32,W^BOO$GL_FREEMEM,R8	; Init pointer to parameter buffer
	MOVC3	#32,@W^BOO$GL_FREEMEM,EXE$GT_STARTUP	; Set name of startup file
	CLRL	W^VALID_PAR_FILE	; Initialize valid parameter file flag
30$:	TSTL	(R8)			; Check for end of list
	BEQL	DONE			; Branch if yes
	MOVZBL	(R8),TPA$L_TOKENCNT(AP)	; Set token count for search
	MOVAB	1(R8),TPA$L_TOKENPTR(AP); And address of string
	ADDL	#16,R8			; Advance to value
	MOVL	(R8)+,TPA$L_NUMBER(AP)	; Set number 
	CALLG	(AP),W^BOO$SEARCH	; Search for parameter
	BLBC	R0,30$			; Next parameter if not found
	MOVL	#1,W^VALID_PAR_FILE	; Indicate valid parameter file
	MOVL	TPA$L_PARAM(AP),R4	; Get a pointer to the parameter descripttor
	BBC	#PRM$V_ASCII,PRM$L_FLAGS(R4),40$; Branch if not an ascii parameter
	MOVAL	-(R8),TPA$L_TOKENPTR(AP); Get a pointer to the parameter value
	MOVZBL	PRM$B_SIZE(R4),R0	; Get parameter size in bits
	ASHL	#-3,R0,R0		; Set parameter size
	MOVZBL	R0,TPA$L_TOKENCNT(AP)	;
	ADDL2	#3,R0			; Round size up to the next longword
	BICL2	#3,R0			;
	ADDL2	R0,R8			; Advance past value
	CALLG	(AP),W^BOO$SETASCII	; Set the value of the parameter
	BRW	30$			; Continue with the next parameter
40$:	CALLG	(AP),W^BOO$SETVALUE	; Set value of parameter
	BRW	30$			; Continue with next parameter
DONE:	BLBS	W^VALID_PAR_FILE,10$	; If LBS, valid parameter file
	MSG	<-E-Not a parameter file>
10$:	MOVZWL	#1,R0			; Return success
	RET				;

	.SBTTL	GETCONLOC_780 - Routine to read console information location
;++
; Functional Description:
;	GETCONLOC_780 is used to access the locations in 11/780 console
;	memory containing values such as WCS and FPLA version numbers.
;
; Input Parameters:
;	R1 - Location code
;
; Output Parameters:
;	R0 - Value contained in console cell
;--
GETCONLOC_780:
	MOVAB	^X300(R1),R1		; Set code to read console memory
10$:	MFPR	#PR$_TXCS,R0		; Get transmit status register
	BBC	#7,R0,10$		; Wait for done
	MTPR	R1,#PR$_TXDB		; Request data from console
20$:	MFPR	#PR$_TXCS,R0		; Read transmit status register
	BBC	#7,R0,20$		; Wait for done
30$:	MFPR	#PR$_RXCS,R0		; Get receiver status
	BBC	#7,R0,30$		; And wait for done
	MFPR	#PR$_RXDB,R0		; Now read data value
	CMPZV	#8,#4,R0,#3		; Is this a valid response?
;	BNEQ	10$			; No, try again
	NOP				;****** TEMP
	NOP				;****** TEMP
	MOVZBL	R0,R0			; Zero extend data
	RSB				;
;
; Table of microcode revision levels for the 11/780.
;
VERSVECT_780:				; Vector of version offsets
	.BYTE	FPLA_VLOC_780		; FPLA Version offset
	.BYTE	PCS_VLOC_780		; PCS Version offset
	.BYTE	WCSS_VLOC_780		; WCS Secondary version offset
	.BYTE	WCSP_VLOC_780		; WCS Primary version offset
VERSVEC780LEN=.-VERSVECT_780
	.BYTE	0			; End of list
VERSNUM_780:				; Vector of required version numbers
	.BYTE	FPLA_780		; FPLA minimum
	.BYTE	PCS_780			; PCS minimum
	.BYTE	WCSS_780		; WCS Secondary minimum
	.BYTE	WCSP_780		; WCS Primary minimum

;
; Table of microcode revision levels for the 11/785.
;
VERSVECT_785:				; Vector of version offsets
	.BYTE	PCS_VLOC_785		; PCS Version offset
	.BYTE	MTCH_VLOC_785		; PCS/WCS match version offset
	.BYTE	WCSS_VLOC_785		; WCS secondary version offset
	.BYTE	WCSP_VLOC_785		; WCS primary version offset
VERSVEC785LEN=.-VERSVECT_785
	.BYTE	0			; End of list
VERSNUM_785:				; Vector of required version numbers
	.BYTE	PCS_785			; PCS minimum
	.BYTE	MTCH_785		; PCS/WCS match
	.BYTE	WCSS_785		; WCS secondary minimum
	.BYTE	WCSP_785		; WCS primary minimum
;
; The code paragraph CHKVERS_780 assumes that both the 780 and the 785 have
; 4 console locations to check.
;
	ASSUME	VERSVEC780LEN EQ VERSVEC785LEN
	ASSUME	VERSVEC780LEN EQ 4


	.SBTTL	GETCONLOC_790
;++
; Functional Description:
;	GETCONLOC_790 is used to read data stored in console memory,
;	such as microcode revision levels.
;
; Inputs:
;	R1 = code for console data requested
;	R2 = # of bytes of data expected
;	R3 = address of buffer to store requested data in
;
; Outputs:
;	Data is stored in the buffer.
;	Input registers destroyed.
;--

GETCONLOC_790:
	CLRL	-(SP)			; Longword of temporary storage.
1$:	MTPR	#^X88000,#PR$_TXCS	; Disable console terminal transmits
					; and request logical console.
10$:	MFPR	#PR$_TXCS,(SP)		; Get transmit status.
	BBC	#7,(SP),10$		; Loop until ready bit is set.
	CMPB	1(SP),#3		; ID = logical console data?
	BNEQ	1$			; If not, try again.
	MTPR	R1,#PR$_TXDB		; Send request code to console.

20$:	MFPR	#PR$_RXCS,(SP)		; Get receiver status.
	BBC	#7,(SP),20$		; Loop until done bit is set.
	MFPR	#PR$_RXDB,(SP)		; Get received data.
	CMPB	1(SP),#3		; ID = logical console data?
	BNEQ	20$			; If not, throw data away and try again.
;	CMPB	(SP),R1			; Code = requested data returned?
;	BNEQ	CONSOLE_ERROR		; No recovery from protocol error.
	MOVB	(SP),(R3)+		; Put data byte in user's buffer.
	SOBGTR	R2,20$			; Branch back to get another byte.

	TSTL	(SP)+			; Get rid of temporary buffer.
	MTPR	#^X18000,#PR$_TXCS	; Disable logical console and
					; enable local terminal line.
	RSB

	.PAGE
	.SBTTL	MOVEMAPPED - MOVE FROM PHYSICAL TO MAPPED MEMORY
;++
; Functional Description:
;	MOVEMAPPED moves the specified number of bytes from the
;	given physical address to a specified system virtual address
;
;	R1 = physical address to move data from
;	R6 = number of bytes to move
;	R7 = system virtual address to move them to
;
; Output Parameters:
;	R0 - R7 altered
;
;--
MOVEMAPPED:
	MOVQ	R8,-(SP)
	EXTZV	#VA$V_BYTE,#VA$S_BYTE,R7,R8 ; STARTING BYTE OFFSET
	EXTZV	#VA$V_VPN,#VA$S_VPN,R7,R7 ; GET VIRTUAL PAGE NUMBER
	MOVAL	@MMG$GL_SBR[R7],R7	; GET SPT ENTRY ADDRESS
	CLRL	R0			; BACKGROUND THIS FOR INSV IN LOOP
					; MOVC WILL ZERO IT EACH TIME
	BRB	20$
10$:	CLRL	R8			; NO BYTE OFFSET
20$:	INSV	(R7)+,#VA$V_VPN,#PTE$S_PFN,R0 ; DESTINATION PAGE ADDRESS
	SUBL3	R8,#512,R9		; NO. OF BYTES TO MOVE
	CMPL	R9,R6			; DON'T MOVE MORE THAN IS LEFT
	BLEQ	30$			; BRANCH IF MORE TO DO
	MOVL	R6,R9			; OTHERWISE USE WHAT IS LEFT
30$:	MOVC3	R9,(R1),(R0)[R8]	; MOVE THE NEXT PIECE
	SUBL	R9,R6			; COUNT BYTES MOVED
	BGTR	10$			; BRANCH IF MORE TO MOVE
	MOVQ	(SP)+,R8		; RESTORE SAVED REGISTERS
	RSB				; OTHERWISE RETURN
	.PAGE
	.SBTTL	ALLOC_POOL - Allocate Pool From the top
;++
; Functional Description:
;	This routine allocates the requested amount of pool from
;	the current top of non-paged pool and returns its address
;
; Calling Sequence:
;	BSBW	ALLOC_POOL
;
; Inputs:
;	R0		   = Address of remaining size of pool
;	STAT_L_BYTECNT(R2) = Number of bytes to allocate
;	STAT_L_SYSVA(R2)   = Base relative address of location to 
;			     store allocated address
;	STAT_L_NAME(R2)    = Base relative adr of ASCIC name of file for error msg
;
; Outputs:
;	R0,R2 preserved
;	R1 = rounded up byte count allocated
;	STAT_L_BYTECNT(R2) = rounded up byte count allocated
;	Returns to caller only if pool is successfully allocated
;	If there is not enough room a diagnostic is issued
;	and a HALT is executed.
;--

ALLOC_POOL:
	ADDL3	#^XF,STAT_L_BYTECNT(R2),R1 ; Round desired size up
	BICL	#^XF,R1			; to quad boundary
	BEQL	10$			; None needed
	MOVL	R1,STAT_L_BYTECNT(R2)	; Save allocated size
	SUBL	R1,(R0)			; Allocate the pool
	BLSS	20$			; Branch if no pool left
	ADDL3	W^SYSBOOT_BASE,STAT_L_SYSVA(R2),-(SP) ; Adr to store pool adr
	ADDL3	(R0),W^MMG$GL_NPAGEDYN,@(SP)+ ; Set adr allocated
10$:	RSB

20$:	MSG	<-F-Not enough non-paged pool to map >
	ADDL3	W^SYSBOOT_BASE,STAT_L_NAME(R2),R1 ; Adr of file name (ASCIC)
	BSBW	BOO$TYPE_ASCIC		; Type the name
	HALT				; ***** Fatal Error *****
	.PAGE
	.SBTTL	BOO$FACMSG - Output facility error message
;++
; Functional Description:
;	BOO$FACMSG outputs an error message preceded by a new line
;	and facility name string.
;
; Calling Sequence:
;	BSBW	BOO$FACMSG
;	.ASCIZ	message-text
;++
BOO$FACMSG::				;
ERROUT:
	BSBW	BOO$MSGOUT		; Output prefix message
	.ASCII	<CR><LF>		; With a new line first
	.ASCIZ	/%SYSBOOT/		; Then facility name
	BRW	BOO$MSGOUT		; And finally the meat of the message

	.PAGE
	.SBTTL	BOO$TYPE_ASCIC - Type a counted ASCII string
;++
; Functional Description:
;	This routine accepts a string descriptor and types the message
;	on the console terminal
;
; Calling Sequence:
;	BSBW	BOO$TYPE_ASCIC
;
; Inputs:
;	R1 = Address of ASCIC string
;
; Outputs:
;	R0,R1 altered
;	All other registers preserved
;--

BOO$TYPE_ASCIC:
	MOVZBL	(R1)+,R0		; R0 = Size, R1 = Address of string
	PUSHR	#^M<R2,R3,R4,R5>	; Save registers
	MOVL	W^BOO$GL_FREEMEM,R3	; Address of scratch storage
	CLRQ	-(SP)			; No read for PROMPTREAD call
	PUSHL	R3			; Address of ASCIZ string
	MOVC3	R0,(R1),(R3)		; Move the string to scratch storage
	CLRB	(R3)+			; and make it ASCIZ
	CALLS	#3,W^BOO$READPROMPT	; Type the string
	POPR	#^M<R2,R3,R4,R5>	; Recover saved registers
	RSB
	.PAGE
	.SBTTL	Unexpected Machine Check Handler
;
;	Unexpected Machine Check Handler
;
	.ALIGN	LONG			; Exception handlers must be longword aligned
	.IF	DF,DEBUG		;
EXE$ACVIOLAT::				; Access violation vector 
EXE$BREAK::				; Breakpoint vector
EXE$ROPRAND::				; Reserved operand vector
EXE$TBIT::				; TBIT vector
MMG$PAGEFAULT::				; Pagefault exception vector
	.ENDC				;
BOOT_FAULT:				;
	MSG	<-F-Unexpected Exception>; Output error message

	.ALIGN	LONG			;
UNEXP_MCHK:				;
	MSG	<-F-Unexpected Machine Check>; Output error message

	.IF	DF,DEBUG		;
INI$RDONLY::				; Dummy change protection routines
INI$WRITABLE::				;
SYSL$CLRSBIA::				; Dummy routine to clear SBIA errors
	RSB				;
EXE$GL_FLAGS::				; Dummy
XDS$GT_WORD_PFN::
	.LONG	0			;
	.ENDC				;
;
; DUMMY SYS$FAO LINKAGE TO EXE$FAO
;
SYS$FAO::				;
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>	; ALL REGISTERS
	BRW	EXE$FAO+2		; ENTER FAO 

	.PAGE
	.SBTTL	BOO$GIVEHELP - Print Help information
;
; 	Print Help Information
;
BOO$GIVEHELP::	.WORD	^M<R2,R3,R4,R5>	;
	CLRQ	-(SP)			; Null input buffer
	PUSHAB	B^HELPMSG		; Set address of help message
	CALLS	#3,W^BOO$READPROMPT	; Write help message
	MOVL	#1,R0			; Return success
	RET				;


HELPMSG:				; ASCIZ Help message string
	.ASCII	/Major SYSBOOT Commands are:/<CR><LF><LF>
	.ASCII	/	CONTINUE - Continue with boot process/<CR><LF>
	.ASCII	/	EXIT	 - Continue with boot process/<CR><LF>
	.ASCII	/	SET	 - Set parameter value/<CR><LF>
	.ASCII	/	    SET parameter_name value/<CR><LF>
	.ASCII	\	    SET /STARTUP file_spec\<CR><LF>
	.ASCII	/	SHOW	 - Show parameter value(s)/<CR><LF>
	.ASCII	/	    SHOW parameter_name/<CR><LF>
	.ASCII	\		/ACP 	- Show ACP parameters\<CR><LF>
	.ASCII	\		/ALL 	- Show ALL parameters\<CR><LF>
	.ASCII	\		/GEN 	- Show generative parameters\<CR><LF>
	.ASCII	\		/MAJOR 	- Show MAJOR parameters\<CR><LF>
	.ASCII	\		/NAMES 	- Show parameter names\<CR><LF>
	.ASCII	\		/PQL 	- Show Process Quota List values\<CR><LF>
	.ASCII	\		/RMS 	- Show RMS parameters\<CR><LF>
	.ASCII	\		/SCS	- Show SCS parameters\<CR><LF>
	.ASCII	\		/STARTUP - Show Startup command file name\<CR><LF>
	.ASCII	\		/SYS 	- Show SYSTEM parameters\<CR><LF>
	.ASCII	\		/TTY 	- Show terminal parameters\<CR><LF>
	.ASCII	/	USE	 - Set parameter file name /<CR><LF>
	.ASCII	\	    USE file_spec.PAR \<CR><LF>
	.ASCII	/		Reserved filespecs are:/<CR><LF>
	.ASCII	/			DEFAULT - Use permanent defaults/<CR><LF>
	.ASCIZ	/			CURRENT - Use current values/<CR><LF>

	.SBTTL	Miscellaneous constants and temps
FIL$GQ_CACHE::
	.BLKQ	1			; FIL$OPENFILE cache descriptor
FIL$GT_TOPSYS::
	.ASCIC	/SYS0/			; Default top level system dir name
	.BLKB	10-<.-FIL$GT_TOPSYS>	; Fill to 10 bytes
BOO$GT_SYSDUMP:				;
	.ASCIC	/SYSDUMP.DMP/		; Name of dump file
BOO$GT_PAGEFILE:			;
	.ASCIC	/PAGEFILE.SYS/		; Name of page file

BOO$GT_SYS::				;
	.ASCIC	/SYS.EXE/		; Name of system image
BOO$GL_FREEMEM::			; Base of free memory after boot image
	.LONG	0			;
BOO$GT_PROMPT::				; Prompt string
	.ASCIZ	<CR><LF>%SYSBOOT>  %	;
BOO$GL_GPTPGCT::			; Count of global page table pages
	.LONG	0			;
BOO$GL_NEXTPFN::			; Starting index for PFN scan
	.LONG	0			;
BOO$GL_SPTPAGCT::			; Count of pages allocated for SPT
	.LONG	0			;
BOO$GQ_STATBLK::			; Statistics block for file open
	.LONG	0,0			;
BOO$GL_SYSPHD::				; Physical address of system header
	.LONG	0			;
BOO$GL_SYSPHDPG::			; Count of pages for system PHD
	.LONG	0			;
TTNAME:	.ASCIC	/TTDRIVER.EXE/		; NAME OF TERMINAL SERVICE CODE

DBNAME:	.ASCIC	/DBDRIVER.EXE/		; Name of RP06 Driver
DMNAME:	.ASCIC	/DMDRIVER.EXE/		; Name of RK07 Driver
DRNAME:	.ASCIC	/DRDRIVER.EXE/		; Name of RM03/RP07 Driver
DLNAME:	.ASCIC	/DLDRIVER.EXE/		; Name of RL01/RL02 driver
DXNAME:	.ASCIC	/DXDRIVER.EXE/		; Name of console RX01 driver
DDNAME:	.ASCIC	/DDDRIVER.EXE/		; Name of console TU58 driver
UNKNAME:.ASCIC	/UNKDRIVER.EXE/		; Name of Driver for unknown devices

CONEOF_PROMPT:	.ASCII	<CR><LF><BELL>/Insert the next standalone system volume /
		.ASCIZ	/and enter "YES" when ready: /

CONEOF_REMOVE1:	.ASCIZ	<CR><LF><BELL>/Please remove the volume "/<BELL>
CONEOF_REMOVE2:	.ASCIZ	/" from the console device./<BELL><CR><LF>

CONEOF_RESUME1:	.ASCIZ	<CR><LF>/Resuming load operation on volume "/
CONEOF_RESUME2:	.ASCIZ	/", please stand by . . ./<CR><LF><LF>

CONEOF_BUFFER:	.LONG	0
;
; DATA FOR LOADABLE CPU-DEPENDENT CODE:
;

NAME_SYSLOA:				; FILENAME OF LOADABLE
	.ASCIC	/SYSLOAXXX.EXE/		;  CPU-DEPENDENT IMAGE
NAME_XXX=NAME_SYSLOA+1+6		; ADDR OF XXX FIELD IN
					;  IMAGE FILENAME
MODEL_TABLE:				; TABLE OF LONGWDS:  EACH LONGWD
					;  HAS 3 CHAR MODEL NUMBER+ 1 SPACE
MODEL_780:				; VAX 11/780:
	.ASCII	/780 /
MODEL_750:				; VAX 11/750:
	.ASCII	/750 /
MODEL_730:				; VAX 11/730:
	.ASCII	/730 /
MODEL_790:				; VAX 11/790:
	.ASCII	/790 /
MODEL_5:				; cpu type = 5
	.ASCII	/555 /			;
MODEL_6:				; cpu type = 6
	.ASCII	/666 /			;
MODEL_UV1:				; MicroVAX I
	.ASCII	/UV1 /			;
MODEL_UV2:				; MicroVAX II
	.ASCII	/UV2 /			;
NAME_SCSLOA:				; Filename of loadable
	.ASCIC	/SCSLOA.EXE/		;  SCS code image
NAME_CLSLOA:				; Filename of loadable cluster
	.ASCIC	/CLUSTRLOA.EXE/		;  code image
NAME_ERAPATLOA:				; Filename of loadable $ERAPAT
	.ASCIC	/ERAPATLOA.EXE/		;  code image
NAME_CHKPRTLOA:				; Filename of loadable $CHKPRT
	.ASCIC	/CHKPRTLOA.EXE/		;  code image
NAME_VAXEMUL:				; Filename of loadable character and
	.ASCIC	/VAXEMUL.EXE/		;  decimal instruction emul code image
NAME_FPEMUL:				; Filename of loadable FP emulation
	.ASCIC	/FPEMUL.EXE/		;  code image
NAME_MTACCESSLOA:			; Filename of loadable $MTACCESS
	.ASCIC	/MTACCESS.EXE/		; code image
;
; MISC. LOCAL STORAGE:
;

	.ALIGN	LONG
SCBPAGCT:				; # pages for system SCB
	.LONG	0			;
SCBBYTCT:				; # bytes for system SCB
	.LONG	0			;
SCBPHADDR:				; Physical address of SCB
	.LONG	0			;
VALID_PAR_FILE:				; Valid parameter file flag
	.LONG	0
CONEOF_ENABLE:				; Request volume switch on console EOF
	.LONG	0			; Initially disabled, do not allow EOF
CONEOF_MAX_PTR:				; Reserved number of retrieval pointers
	.LONG	0			;  for SYS.EXE, less one for the dummy ptr
VMB_VERSION:
	.LONG	0			; VMB version number
SYSBOOT_BASE:
	.LONG	0			; Base address of SYSBOOT
BOO$GL_RPBBASE::
	.BLKL	1			; Base address of RPB
CPUTYPE:
	.LONG	0			; Copy of cpu type not in SYSPARAMS
ASSUME	VERSVEC780LEN LE 8		; The following space must be large
					;  enough to accomodate all of the
CPUDATA:				;  VERVECT info
	.LONG	0,0			; Copy of cpu data not in SYSPARAMS
RTRV_BUF_DSC:				; Size and address of buffer for
	.BLKQ	1			; retrieval pointer information
VBN2_BUF_DSC:				; Size and address of buffer for
	.BLKQ	1			; 2nd block of each driver
BOOTCB:
	.LONG	0			; Address of boot control block
					; Contains BOOTDRIVR, QIO_RWVB,
					; maps for SYS and SYSDUMP
MEM_LO_PFN:				; Lowest PFN found by VMB (inclusive)
	.BLKQ	1
	MEM_HI_PFN = MEM_LO_PFN+4	; Highest PFN found by VMB (exclusive)
CACHE_HI_PFN:
	.BLKL	1			; Highest PFN in FIL$OPENFILE cache
PFNMAP_HI_PFN:
	.BLKL	1			; Highest PFN in PFN bitmap pages
SMALL_PFNMAP::				; Saved descriptor for backwards
	.BLKQ	1			; compatible 8mb (max) PFN bitmap
UCODE_LEN:				; Length of loadable ucode
	.LONG	0
UCODE_ADR:				; Physical addr of it
	.LONG	0
;
; Following two cells must be contiguous!!
;
VMB_FLAGS:				; Flags passed from VMB
	.LONG	0
CI_HI_PFN:
	.LONG	0			; Highest PFN for CI support
;
; Statistics Blocks for various files that are placed in non-paged pool
; ***** Do Not Reorder or separate these Statistics Blocks *****
;
SYS_STAT:
	.BLKQ	1			; Starting VBN, size in bytes
	.LONG	1@20			; not used
	.LONG	BOO$GT_SYS		; Adr of ASCIC name of system image
	.BLKB	STAT_C_SIZE-16
;
; The following stat blocks will be disabled if the console volume has been
; switched during a boot from the console.
;
CONEOF_DISABLE_STAT:
SYSDUMP_STAT:
	.BLKQ	1			; Starting VBN, size in bytes
	.LONG	1@20			; not used
	.LONG	0			; Adr of ASCIC name of dump file
					; now filled in at run time
	.BLKB	STAT_C_SIZE-16
BOODRV_STAT:
	.BLKL	1			; VBN (not used)
	.BLKL	1			; Size in bytes of boot driver
	.LONG	BOO$GL_BOOTCB		; Adr to store adr of boot driver
	.LONG	BOODRV_MAP_ERR		; Adr of ASCIC string for alloc err msg
	.BLKB	STAT_C_SIZE-16
DSKDRV_STAT:
	.BLKQ	1			; VBN and size in bytes of disk driver
	.LONG	BOO$GL_DSKDRV		; Adr to store adr of disk driver
	.LONG	0			; Adr of ASCIC name of disk driver
	.BLKB	STAT_C_SIZE-16
PRTDRV_STAT:
	.BLKQ	1			; VBN and size in bytes of port driver
	.LONG	BOO$GL_PRTDRV		; Adr to store adr of port driver
	.LONG	0			; Adr of ASCIC name of port driver
	.BLKB	STAT_C_SIZE-16
TRMDRV_STAT:
	.BLKQ	1			; VBN and size in bytes of terminal driver
	.LONG	BOO$GL_TRMDRV		; Adr to store adr of terminal driver
	.LONG	TTNAME			; Adr of ASCIC name of terminal driver
	.BLKB	STAT_C_SIZE-16
SCSLOA_STAT:
	.BLKQ	1			; VBN and size in bytes of SCS code
	.LONG	BOO$GL_SCSLOA		; Adr to store adr of SCS code
	.LONG	NAME_SCSLOA		; Adr of ASCIC name of SCS code
	.BLKB	STAT_C_SIZE-16
SYSLOA_STAT:
	.BLKQ	1			; VBN and size in bytes of CPU dependent code
	.LONG	BOO$GL_SYSLOA		; Adr to store adr of CPU dependent code
	.LONG	NAME_SYSLOA		; Adr of ASCIC name of CPU dependent code
	.BLKB	STAT_C_SIZE-16
CLSLOA_STAT:
	.BLKQ	1			; VBN and size in bytes of cluster code
	.LONG	BOO$GL_CLSLOA		; Adr to store adr of cluster code
	.LONG	NAME_CLSLOA		; Adr of ASCIC name of cluster code
	.BLKB	STAT_C_SIZE-16
ERAPATLOA_STAT:
	.BLKQ	1			; VBN and size in bytes of $ERAPAT code
	.LONG	BOO$GL_ERAPATLOA	; Adr to store adr of $ERAPAT code
	.LONG	NAME_ERAPATLOA		; Adr of ASCIC name of $ERAPAT code
	.BLKB	STAT_C_SIZE-16
CHKPRTLOA_STAT:
	.BLKQ	1			; VBN and size in bytes of $CHKPRT code
	.LONG	BOO$GL_CHKPRTLOA	; Adr to store adr of $CHKPRT code
	.LONG	NAME_CHKPRTLOA		; Adr of ASCIC name of $CHKPRT code
	.BLKB	STAT_C_SIZE-16
VAXEMUL_STAT:
	.BLKQ	1			; VBN & size in bytes of char emul code
	.LONG	BOO$GL_VAXEMUL		; Adr of char/decimal emulation code
	.LONG	NAME_VAXEMUL		; Adr of ASCIC name of char emul code
	.BLKB	STAT_C_SIZE-16
FPEMUL_STAT:
	.BLKQ	1			; VBN and size in bytes of FP emul code
	.LONG	BOO$GL_FPEMUL		; Adr to store adr of FP emulation code
	.LONG	NAME_FPEMUL		; Adr of ASCIC name of FP emulation code
	.BLKB	STAT_C_SIZE-16
MTACCESSLOA_STAT:
	.BLKQ	1			; VBN and size in bytes of $MTACCESS code
	.LONG	BOO$GL_MTACCESSLOA	; Adr to store adr of $MTACCESS code
	.LONG	NAME_MTACCESSLOA	; Adr of ASCIC name of $MTACCESS code
	.BLKB	STAT_C_SIZE-16

CONEOF_DISABLE_CNT = <.-CONEOF_DISABLE_STAT>/STAT_C_SIZE	; Files to "close" on volume switch

ALLOC_POOL_CNT = <.-BOODRV_STAT>/STAT_C_SIZE	; Things to alloc real pool for

LOAD_IMAGE_CNT = <.-DSKDRV_STAT>/STAT_C_SIZE	; Images to load

BOODRV_MAP_ERR:
	.ASCIC	/BOOTDRIVR/

BOO$GL_PGDCOD:
	.LONG	PAT$A_NONPGD_CODE_END
;
; This is patch area for SYSBOOT.EXE .
;
PATCH_DESC::				; Patch area descriptor
	.LONG	100			;   size
	.LONG	PATCH_AREA		;   next free byte
PATCH_AREA:				; Patch area
	.BLKB	100			;   100 bytes

	.END				; 
