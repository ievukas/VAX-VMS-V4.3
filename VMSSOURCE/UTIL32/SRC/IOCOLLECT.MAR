	.TITLE	IOCOLLECT - I/O PERFORMANCE DATA COLLECTION
	.IDENT	'V04-000'
 
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
; FACILITY: Performance Monitoring
;
; ABSTRACT:
;	IOCOLLECT is responsible for controlling I/O performance
;	monitoring and logging data to a mag tape or disk file.
;
; ENVIRONMENT:
;	MODE = KERNEL, EXEC
;
; AUTHOR: S. S. AMWAY, CREATION DATE: 24-Oct-1983
; (ORIGINAL AUTHOR: D.N. CUTLER, CREATION DATE: 20-Nov-1977)
;
; MODIFIED BY:
;	V03-002	SSA0024		Stan Amway		10-Apr-1984
;		Moved disk geometry info in SRQ record to avoid
;		conflicting usage by newly defined field PIB$W_SRQ_ACON.
;
;	V03-001	SSA0008		Stan Amway		21-Feb-1984
;		Record node name to data file as part of 
;		the initialization record. This is done to aid in
;		the analysis of data recorded simultaneously on 
;		several nodes in a VAXcluster.
;
;		When allocating PDB, check for previous monitoring 
;		process abort which left a PDB allocated. This can
;		only happen if another process issues a $DELPRC
;		service or a user issues a DCL STOP PROCESS command.
;
;--
 

	.SBTTL	DECLARATIONS

;
; INCLUDE FILES:
;

	$DCDEF				;Define device classes & types
	$DDBDEF				;DEFINE DDB OFFSETS
	$DEVDEF				;DEFINE DEVCHAR/DEVCHAR2 bits
	$DYNDEF				;DEFINE DATA STRUCTURE CODES
	$IPLDEF				;DEFINE INTERRUPT PRIORITY LEVELS
	$IODEF				;DEFINE I/O FUNCTION CODES
	$PBHDEF				;DEFINE PBH OFFSETS
	$PCBDEF				;DEFINE PCB OFFSETS
	$PDBDEF				;DEFINE PDB OFFSETS
	$PIBDEF				;DEFINE PIB OFFSETS
	$PRDEF				;DEFINE PROCESSOR REGISTERS
	$SYIDEF				;Define GETSYI item codes
	$UCBDEF				;DEFINE UCB OFFSETS
 
;
; MACROS:
;

;
; GENERATE STRING DESCRIPTOR AND TEXT
;
 
	.MACRO	.DESCR STRING
		.PSECT	TEXT,LONG,RD,WRT,NOEXE
	$START$=.
		.ASCII	\STRING\
	$END$=.
		.PSECT	DATA,LONG,RD,WRT,NOEXE
		.LONG	$END$-$START$
		.LONG	$START$
	.ENDM	.DESCR
 
;
; EQUATED SYMBOLS:
;
 
DATBUFSIZ=512				;DATA COLLECTION BUFFER SIZE
NUMDATBUF=11				;NUMBER OF DATA COLLETION BUFFERS
OUTBUFSIZ=4096				;OUTPUT DATA BUFFER SIZE
FLUSHCOUNT=20				;BUFFER FLUSH CONTROL VALUE
 
;
; OWN STORAGE:
;
 
	.PSECT	DATA,LONG,RD,WRT,NOEXE
ANDMSK:	.BLKW	1			;PACKET SELECTION 'AND' MASK
BUFLEN:	.BLKW	1			;LENGTH OF OUTPUT MESSAGE
COPBUF:	.BLKB	DATBUFSIZ		;DATA COLLECTION COPY BUFFER
DCLASS:	.BLKB	1			;DEVICE CLASS MATCH BYTE
DELTAT:	.BLKQ	1			;DELTA TIME BEFORE TEST END
DVTYPE:	.BLKB	1			;DEVICE TYPE MATCH BYTE
FLAGS:	.BLKB	1			;FLAGS BYTES
FUNCTN:	.BLKQ	1			;PACKET SELECTION FUNCTION MASK
IOSTAT:	.BLKQ	1			;I/O STATUS QUADWORD
MSGLEN:	.BYTE	PIB$K_SRQ_SIZE		;SIZE OF START OF I/O REQUEST MESSAGE
	.BYTE	PIB$K_SIO_SIZE		;SIZE OF START OF I/O TRANSACTION MESSAGE
	.BYTE	PIB$K_EIO_SIZE		;SIZE OF END OF I/O TRANSACTION MESSAGE
	.BYTE	PIB$K_ERQ_SIZE		;SIZE OF END OF I/O REQUEST MESSAGE
	.BYTE	PIB$K_ARQ_SIZE		;SIZE OF ABORT I/O REQUEST MESSAGE
NUMBUF:	.BLKL	1			;NUMBER OF BUFFERS OF DATA TO COLLECT
OUTBUF:	.BLKB	OUTBUFSIZ		;DATA OUTPUT BUFFER
XORMSK:	.BLKW	1			;PACKET SELECTION 'XOR' MASK
SYI_LIST:				; Item list for GETSYI
	.WORD	8
	.WORD	SYI$_NODENAME
	.LONG	NODENAME
	.LONG	0
	.LONG	0
NODENAME:
	.QUAD	0

	.ALIGN	LONG
LOCK_RANGE:				; Address range to lock into working set
	.LONG	NON_PAGED_BEGIN
	.LONG	NON_PAGED_END

OUTFAB:	$FAB	FNM=<IOCOLLECT>,-
		DNM=<IOCOLLECT.DAT>,-
		ALQ=500,-
		DEQ=500,-
		FAC=<PUT,TRN>,-
		FOP=<CBT,MXV,TEF,SQO,NEF,RWO,RWC>,-
		MRS=OUTBUFSIZ,-
		BLS=OUTBUFSIZ,-
		ORG=SEQ,-
		RFM=FIX
OUTRAB:	$RAB	FAB=OUTFAB,-
		RAC=SEQ,-
		MBC=<OUTBUFSIZ/512>,-
		MBF=3,-
		ROP=<WBH>,-
		RBF=OUTBUF,-
		RSZ=OUTBUFSIZ

	.SBTTL	IOCOLLECT - I/O PERFORMANCE DATA COLLECTION CONTROL
;++
; FUNCTIONAL DESCRIPTION:
;	THIS IS THE MAIN ROUTINE RESPONSIBLE FOR 
;	CONTROLLING I/O	PERFORMANCE DATA COLLECTION

; CALLING SEQUENCE:
;	CALLS/CALLG IOCOLLECT
;
; INPUT PARAMETERS:
;
;	04(AP) = ADDRESS OF NUMBER OF BUFFERS OF DATA TO COLLECT.
;	08(AP) = ADDRESS OF NUMBER OF SECONDS TILL END OF DATA COLLECTION.
;	12(AP) = ADDRESS OF DEVICE CLASS.
;	16(AP) = ADDRESS OF DEVICE TYPE.
;	20(AP) = ADDRESS OF 'AND' MASK FOR PACKET STATUS WORD.
;	24(AP) = ADDRESS OF 'XOR' MASK FOR PACKET STATUS WORD.
;	28(AP) = ADDRESS OF QUADWORD FUNCTION MASK.
;
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	I/O DATA COLLECTED IN FILE
;
; COMPLETION CODES:
;	SS$_NORMAL
;	Numerous error codes from other facilities
;
; SIDE EFFECTS:
;	NONE
;
;--
 
	.PSECT	CODE,LONG,RD,NOWRT,EXE

	.ENTRY	IOCOLLECT,^M<>
 
	$CREATE	FAB=OUTFAB		;CREATE DATA FILE
	BLBC	R0,10$
	$CONNECT RAB=OUTRAB
	BLBS	R0,15$
10$:	BRW	30$
15$:

;
; INITIALIZE DATA COLLECTION PARAMETERS
;
 
	TSTL	(AP)+			;POINT TO ADDRESS OF FIRST ARGUMENT
	MOVL	@(AP)+,W^NUMBUF		;SET NUMBER OF BUFFERS OF DATA TO COLLECT
	EMUL	#1000*1000*10,@(AP)+,#0,R0 ;CALCULATE DELTA TIME IN 100 NANOSECONDS
	MNEGL	R1,W^DELTAT+4		;SET HIGH ORDER TIME
	MNEGL	R0,W^DELTAT		;SET LOW ORDER TIME
	SBWC	#0,W^DELTAT+4		;
	MOVB	@(AP)+,W^DCLASS		;SET DEVICE CLASS
	MOVB	@(AP)+,W^DVTYPE		;SET DEVICE TYPE
	MCOMW	@(AP)+,W^ANDMSK		;SET 'AND' MASK
	MOVW	@(AP)+,W^XORMSK		;SET 'XOR' MASK
	MOVQ	@(AP)+,W^FUNCTN		;SET FUNCTION MASK
	$LKWSET_S LOCK_RANGE		; Lock high IPL code into working set
	BLBS	R0,16$
	BRW	30$
16$:
;
; Collect UCB/device name mappings
;
	MOVC5	#0,(SP),#^C0,#OUTBUFSIZ,W^OUTBUF ; Init buffer
	PUSHAL	W^OUTBUF+4		; Address of device name counter
	MOVZBL	W^DVTYPE,-(SP)		; Device type mask
	MOVZBL	W^DCLASS,-(SP)		; Device class mask
	PUSHL	#<OUTBUFSIZ-8-12-12>	; Size of buffer
					; (Save room for time stamp & node ID)
	PUSHAB	W^OUTBUF+8		; Address of buffer
	PUSHL	#5			; Argument count
	$CMKRNL_S GET_DEVICE_INFO,(SP)	; Get UCB/device name mappings
	ADDL2	#<<5+1>*4>,SP		; Pop arguments
	BLBC	R0,30$
	MOVL	W^OUTBUF+4,R2		; Get device count
					; (Device entry =
					;  UCB addr + 16 char name +
					;  quadword DEVCHAR +
					;  byte DEVCLASS + byte DEVTYPE +
					;  word filler)
	MULL2	#<4+16+8+1+1+2>,R2	; Compute next available
	MOVAB	W^OUTBUF+8[R2],R2	; byte in buffer
	MNEGL	#2,(R2)+		; Insert record type
	MOVQ	G^EXE$GQ_SYSTIME,(R2)+	; Insert starting time stamp
	$GETSYIW_S ITMLST=SYI_LIST	; Get node identification
	BLBC	R0,30$
	MNEGL	#3,(R2)+		; Insert record type
	MOVQ	W^NODENAME,(R2)		; Move node name to buffer
	BNEQ	20$			; If no node name,
	MOVQ	#^A\        \,(R2)	; return blanks instead of 0
20$:
	$PUT	RAB=OUTRAB
	BLBC	R0,30$
	$FLUSH	RAB=OUTRAB
	BLBC	R0,30$

	$CMEXEC_S W^DATA_COLLECT	;COLLECT I/O PERFORMANCE DATA
;	BLBC	R0,30$			;IF LBC DATA COLLECTION FAILURE
30$:	PUSHL	R0			;SAVE FINAL COLLECTION STATUS
	$CLOSE	FAB=OUTFAB		; Close collection file
	POPL	R0			;RESTORE FINAL COLLECTION STATUS
	RET				;

	.SBTTL	DATA_COLLECT - COLLECT I/O PERFORMANCE DATA
;++
; FUNCTIONAL DESCRIPTION:
; 	THIS ROUTINE RUNS IN EXECUTIVE MODE AND COLLECTS DATA UNTIL EITHER A 
;	SPECIFIED NUMBER OF DATA BUFFERS HAVE BEEN COLLECTED OR UNTIL A 
;	SPECIFIED AMOUNT OF TIME HAS ELAPSED.
;
; INPUT PARAMETERS:
;	NONE
;
; IMPLICIT INPUTS:
;	PARAMETERS SUPPLIED TO/SAVED BY COLLECT
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	I/O DATA FILE
;
;--
 
DATA_COLLECT:
	.WORD	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10>
	$CMKRNL_S W^ALLOCATE		;ALLOCATE COLLECTION DATA STRUCTURE
	BLBS	R0,5$			;IF LBS SUCCESSFUL ALLOCATION
	RET				;
 
;
; RESIDENT COLLECTION DATA STRUCTURE ALLOCATED
;
 
5$:	PUSHR	#^M<R2,R3,R4,R5>	; Init buffer
	MOVC5	#0,(SP),#^C0,#OUTBUFSIZ,W^OUTBUF
	POPR	#^M<R2,R3,R4,R5>
	MOVAB	W^OUTBUF,R3		;GET ADDRESS OF OUTPUT BUFFER
	MOVAB	OUTBUFSIZ(R3),R9	;GET ENDING ADDRESS OF OUTPUT BUFFER
	MOVL	#FLUSHCOUNT,R10		;Set buffer flush control counter
	$SETIMR_S #2,W^DELTAT,TIMAST	;SET TIMER FOR DATA COLLECTION PERIOD
	BLBS	R0,10$			;IF LBS SUCCESSFUL
	BRW	80$			;
10$:	$HIBER_S			;HIBERNATE WHILE WAITING FOR BUFFER
	BBC	#1,W^FLAGS,20$		;IF CLR, SPECIFIED TIME NOT EXPIRED
	BRW	60$			;
20$:	$CMKRNL_S W^COPY_DATA		;COPY DATA TO INTERNAL BUFFER
	BBC	#0,W^FLAGS,25$		;IF CLR, NO DATA OVERRUN
	BRW	70$			;
25$:	BLBC	R0,10$			;IF LBS NO DATA TO COPY
	MOVAB	W^COPBUF,R8		;GET ADDRESS OF TEMPORARY BUFFER
	MOVAB	PBH$K_START(R8),R7	;GET ADDRESS OF START OF DATA
30$:	DECW	PBH$W_MSGCNT(R8)	;ANY MORE MESSAGES IN BUFFER?
	BLSS	20$			;IF LSS NO
40$:	MOVZBL	PIB$B_TYPE(R7),R0	;GET MESSAGE TYPE
	MOVZBL	W^MSGLEN[R0],R6		;GET LENGTH OF MESSAGE
	ADDL3	R6,R3,R1		;CALCULATE ADDRESS OF END OF MESSAGE
	CMPL	R1,R9			;BEYOND END OF BUFFER?
	BGTRU	50$			;IF GTRU YES
	CMPB	#PIB$K_SRQ,R0		;START I/O REQUEST?
	BNEQ	45$			;IF NEQ NO
	SUBB3	PIB$B_SRQ_PRI(R7),#31,PIB$B_SRQ_PRI(R7) ;CALCULATE REAL PRIORITY
	ASSUME	PIB$B_SRQ_ACCESS+2+2 EQ PIB$K_SRQ_SIZE
	CLRW	PIB$B_SRQ_ACCESS+2(R7)	; Preset for no disk geometry
	MOVL	PIB$L_SRQ_UCB(R7),R5	; R5 <= UCB address
	CMPB	#DC$_DISK,UCB$B_DEVCLASS(R5) ; Is device a disk ?
	BNEQ	45$			; BR if not
	MOVW	UCB$L_DEVDEPEND(R5),-	; Pass geometry for conversion
		PIB$B_SRQ_ACCESS+2(R7)
	BBC	#DEV$V_CLU,-		; Device available cluster-wide ?
		UCB$L_DEVCHAR2(R5),42$	; (i.e., DSA or MSCP emulated disk)
	BISB2	#^X40,PIB$B_SRQ_PRI(R7)	; Yes - flag as such for data reduction
42$:	BBC	#UCB$V_NOCNVRT,-	; Is media address in
		UCB$W_DEVSTS(R5),45$	; sector/track/cylinder format ?
	BISB2	#^X80,PIB$B_SRQ_PRI(R7)	; No - flag as such for data reduction
45$:	MOVC	R6,(R7),(R3)		;MOVE MESSAGE TO OUTPUT BUFFER
	ADDL	R6,R7			;UPDATE ADDRESS IN TEMPORARY BUFFER
	BRB	30$			;
50$:	MOVAB	W^OUTBUF,R2		;GET ADDRESS OF OUTPUT BUFFER
	$PUT	RAB=OUTRAB		; Output buffer to file
	BLBC	R0,80$
	SOBGTR	R10,55$
	$FLUSH	RAB=OUTRAB
	BLBC	R0,80$
	MOVL	#FLUSHCOUNT,R10		; Reset buffer flush control counter
55$:	PUSHR	#^M<R2,R3,R4,R5>	; Re-init buffer
	MOVC5	#0,(SP),#^C0,#OUTBUFSIZ,W^OUTBUF
	POPR	#^M<R2,R3,R4,R5>
	MOVL	R2,R3			;SET STARTING ADDRESS OF OUTPUT BUFFER
	SOBGTR	W^NUMBUF,90$		;ALL BUFFERS COLLECTED?
60$:	MOVZWL	S^#SS$_NORMAL,R0	;SET NORMAL COMPLETION STATUS
	BRB	80$			;
70$:	MOVZWL	#SS$_BUFFEROVF,R0	;SET BUFFER OVERFLOW STATUS
80$:	PUSHL	R0			;SAVE FINAL COMPLETION STATUS
	$CMKRNL_S W^DEALLOCATE		;DEALLOCATE DATA COLLECTION STRUCTURE
	$CANTIM_S			;CANCEL TIMER
	POPL	R0			;RETRIEVE FINAL COMPLETION STATUS
	RET				;
90$:	BRW	40$

;****************************
; BEGIN - Non-pageable code *
;****************************
NON_PAGED_BEGIN = .


	.SBTTL	ALLOCATE - ALLOCATE DATA COLLECTION STRUCTURE
;++
; FUNCTIONAL DESCRIPTION:
; 	THIS ROUTINE EXECUTES IN KERNEL MODE AND IS CALLED TO ESTABLISH THE
;	DATA STRUCTURES NECESSARY TO TURN ON I/O PEFORMANCE DATA COLLECTION.
;
; INPUT PARAMETERS:
;	NONE
;
; IMPLICIT INPUTS:
;	NUMBER OF BUFFERS TO ALLOCATE
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	RESIDENT DATA COLLECTION STRUCTURE ALLOCATED & INITIALIZED
;
;--

ALLOCATE:
	.WORD	^M<R2,R3,R4,R5,R6>
	BSBW	CLEANUP_ABORT		;CLEANUP FROM ANY PREVIOUS PROCESS ABORT
	MOVZBL	#NUMDATBUF,R6		;SET NUMBER OF DATA BUFFERS TO ALLOCATE
	MOVL	SCH$GL_CURPCB,R4	;GET CURRENT PROCESS PCB ADDRESS
	SETIPL	#IPL$_ASTDEL		;SET IPL TO AST DELIVERY LEVEL
	MOVZBL	#PDB$K_LENGTH,R1	;GET SIZE OF PERFORMANCE DATA BLOCK
	JSB	EXE$ALONONPAGED		;ALLOCATED NONPAGED MEMORY
	MOVL	R2,R5			;SAVE ADDRESS OF PERFORMANCE DATA BLOCK
	BLBC	R0,30$			;IF LBC ALLOCATION FAILURE
	MOVAB	PDB$L_FREEFL(R5),PDB$L_FREEFL(R5) ;INITIALIZE FREE BUFFER LISTHEAD
	MOVAB	PDB$L_FREEFL(R5),PDB$L_FREEBL(R5) ;
	MOVW	R1,PDB$W_SIZE(R5)	;SET SIZE OF DATA STRUCTURE
	MOVB	#DYN$C_PDB,PDB$B_TYPE(R5) ;SET DATA STRUCTURE TYPE
	CLRB	PDB$B_OVERRUN(R5)	;CLEAR OVERRUN INDICATOR
	MOVAB	PDB$L_FILLFL(R5),PDB$L_FILLFL(R5) ;INITIALIZE FILLED BUFFER LISTHEAD
	MOVAB	PDB$L_FILLFL(R5),PDB$L_FILLBL(R5) ;
	MOVL	PCB$L_PID(R4),PDB$L_PID(R5) ;SET DATA COLLECTION PROCESS PID
	CLRL	PDB$L_CURBUF(R5)	;CLEAR ADDRESS OF CURRENT BUFFER
	MOVB	W^DCLASS,PDB$B_DEVCLASS(R5) ;SET DEVICE CLASS MATCH
	MOVB	W^DVTYPE,PDB$B_DEVTYPE(R5) ;SET DEVICE TYPE MATCH
	MOVW	W^ANDMSK,PDB$W_ANDM(R5)	;SET 'AND' MASK
	MOVW	W^XORMSK,PDB$W_XORM(R5)	;SET 'XOR' MASK
	CLRW	PDB$W_BUFCNT(R5)	;CLEAR FILLED BUFFER COUNT
	MOVQ	W^FUNCTN,PDB$Q_FUNC(R5)	;SET SELECTION FUNCTION MASK
10$:	MOVZWL	#DATBUFSIZ,R1		;SET SIZE OF REQUIRED BUFFER
	JSB	EXE$ALONONPAGED		;ALLOCATE DATA COLLECTION BUFFER
	BLBC	R0,20$			;IF LBC ALLOCATION FAILURE
	MOVW	R1,PBH$W_SIZE(R2)	;SET SIZE OF DATA BUFFER
	MOVB	#DYN$C_PBH,PBH$B_TYPE(R2) ;SET DATA STRUCTURE TYPE
	CLRW	PBH$W_MSGCNT(R2)	;CLEAR COUNT OF COMPLETED MESSAGES
	INSQUE	(R2),@PDB$L_FREEBL(R5)	;INSERT BUFFER IN FREE BUFFER LIST
	SOBGTR	R6,10$			;ALL BUFFERS ALLOCATED?
	SETIPL	#IPL$_PERFMON		;DISABLE ALL SOFTWARE INTERRUPTS
	TSTL	PMS$GL_IOPFMPDB		;PERFORMANCE DATA BLOCK ADDRESS ESTABLISHED?
	BNEQ	20$			;IF NEQ YES
	MOVAB	(R5),PMS$GL_IOPFMPDB	;SET ADDRESS OF PERFORMANCE DATA BLOCK
	MOVZWL	S^#SS$_NORMAL,R0	;SET NORMAL COMPLETION STATUS
	BRB	40$			;
20$:	BSBW	DELETE			;DELETE ALLOCATED STRUCTURE
30$:	MOVZWL	#SS$_INSFMEM,R0		;SET INSUFFICIENT MEMORY STATUS
40$:	SETIPL	#0			;ALLOW ALL INTERRUPTS
	RET				;

					;Local subroutine to cleanup from
					;any previous process abort that
					;left the PDB allocated
CLEANUP_ABORT:
	SETIPL	#IPL$_PERFMON		;DISABLE ALL SOFTWARE INTERRUPTS
	MOVL	G^PMS$GL_IOPFMPDB,R5	;GET ADDRESS OF PERFORMANCE DATA BLOCK
	BEQL	10$			;IF EQL NONE
	CMPB	PDB$B_TYPE(R5),#DYN$C_PDB ;IS STRUCTURE A PDB ?
	BNEQ	10$			;BR IF NOT
	MOVL	PDB$L_PID(R5),R0	;GET PID OF OWNER
	JSB	G^EXE$IPID_TO_PCB	;DOES PROCESS EXIST ?
	BNEQ	10$			;BR IF YES - DON'T DELETE PDB !
	CLRL	G^PMS$GL_IOPFMPDB	;CLEAR ADDRESS OF PERFORMANCE DATA BLOCK
	BSBW	DELETE			;DELETE PERFORMANCE DATA STRUCTURE
10$:	SETIPL	#0			;ALLOW ALL INTERRUPTS
	RSB

	.SBTTL	COPY_DATA - COPY DATA TO TEMPORARY BUFFER
;++
; FUNCTIONAL DESCRIPTION:
;	THIS ROUTINE EXECUTES IN KERNEL MODE AND IS CALLED TO COPY THE NEXT 
;	BUFFER FROM THE FILLED BUFFER POOL INTO A TEMPORARY BUFFER.
;
; INPUT PARAMETERS:
;	NONE
;
; IMPLICIT INPUTS:
;	TEMPORARY BUFFER TO COPY DATA INTO.
;
; OUTPUT PARAMETERS:
;
;	R0 LOW BIT CLEAR INDICATES NO DATA AVAILABLE.
;
;	R0 LOW BIT SET INDICATES DATA HAS BEEN COPIED INTO TEMPORARY BUFFER.
;
; IMPLICIT OUTPUTS:
;	IF DATA IS AVAILABLE, TEMPORARY BUFFER CONTAINS DATA
;
;--
 
COPY_DATA:
	.WORD	^M<R2,R3,R4,R5,R6,R7>
	CLRL	R0			;ASSUME NO BUFFERS ARE FULL OF DATA
	MOVAB	W^COPBUF,R1		;GET ADDRESS OF TEMPORARY BUFFER
	SETIPL	#IPL$_ASTDEL		;RAISE PRIORITY TO AST DELIVERY LEVEL

	ASSUME	DATBUFSIZ LE 512

	TSTB	(R1)			;MAKE SURE TEMPORARY BUFFER IS IN MEMORY
	TSTB	DATBUFSIZ-1(R1)		;
	SETIPL	#IPL$_SYNCH		;RAISE IPL TO SYNCH
	MOVL	PMS$GL_IOPFMPDB,R6	;GET ADDRESS OF PERFORMANCE DATA BLOCK
	REMQUE	@PDB$L_FILLFL(R6),R7	;GET ADDRESS OF NEXT FILLED BUFFER
	BVS	10$			;IF VS NO FILLED BUFFER AVAILABLE
	MOVC	#DATBUFSIZ,(R7),(R1)	;COPY DATA TO TEMPORARY BUFFER
	CLRW	PBH$W_MSGCNT(R7)	;CLEAR COMPLETED MESSAGE COUNT
	INSQUE	(R7),@PDB$L_FREEBL(R6)	;INSERT BUFFER IN FREE LIST
	DECW	PDB$W_BUFCNT(R6)	;DECREASE NUMBER OF FILLED BUFFERS
	INCL	R0			;SET SUCCESS INDICATOR
10$:	SETIPL	#0			;ALLOW INTERRUPTS
	BISB	PDB$B_OVERRUN(R6),W^FLAGS ;MERGE OVERRUN STATUS IN FLAG BYTE
	RET				;

	.SBTTL	DEALLOCATE - DEALLOCATE DATA COLLECTION STRUCTURE
;++
; FUNCTIONAL DESCRIPTION:
;	THIS ROUTINE EXECUTES IN KERNEL MODE AND IS CALLED TO DEALLOCATE THE 
;	DATA STRUCTURE THAT WAS ESTABLISHED BY THE ALLOCATION ROUTINE.
;
; INPUT PARAMETERS:
;	NONE
;
; IMPLICIT INPUTS:
;	ADDRESS OF PERFORMANCE DATA BLOCK.
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	THE I/O PERFORMANCE DATA BLOCK AND THE CURRENT FREE AND FILLED BUFFERS
;	ARE DEALLOCATED. THE ADDRESS OF THE PERFORMANCE DATA BLOCK IS ZEROED.
;
;--
 
DEALLOCATE:
	.WORD	^M<R2,R3,R4,R5>
	SETIPL	#IPL$_PERFMON		;DISABLE ALL SOFTWARE INTERRUPTS
	MOVL	PMS$GL_IOPFMPDB,R5	;GET ADDRESS PF PERFORMANCE DATA BLOCK
	BEQL	10$			;IF EQL NONE
	CLRL	PMS$GL_IOPFMPDB		;CLEAR ADDRESS OF PERFORMANCE DATA BLOCK
	BSBB	DELETE			;DELETE PERFORMANCE DATA STRUCTURE
10$:	SETIPL	#0			;ALLOW ALL INTERRUPTS
	RET				;

	.SBTTL	DELETE - DELETE DATA COLLECTION STRUCTURE
;++
; FUNCTIONAL DESCRIPTION:
;	THIS ROUTINE EXECUTES IN KERNEL MODE AND IS CALLED TO ACCOMPLISH THE 
;	ACTUAL DELETION OF THE I/O PERFORMANCE DATA COLLECTION STRUCTURE.
;
; INPUT PARAMETERS:
;
;	R5 = ADDRESS OF PERFORMANCE DATA BLOCK.
;
;	INTERRUPT PRIORITY LEVEL AT IPL$_PERFMON
;
; IMPLICIT INPUTS:
;	NONE
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	THE I/O PERFORMANCE DATA STRUCTURE IS DELETED.
;
;--
 
DELETE:					;DELETE PERFORMANCE DATA STRUCTURE
	SETIPL	#IPL$_ASTDEL		;LOWER TO AST DELIVERY LEVEL
10$:	REMQUE	@PDB$L_FREEFL(R5),R0	;GET NEXT BUFFER FROM FREE LIST
	BVS	20$			;IF VS NONE
	BSBB	40$			;DEALLOCATE BUFFER
	BRB	10$			;
20$:	REMQUE	@PDB$L_FILLFL(R5),R0	;GET NEXT BUFFER FROM FILLED LIST
	BVS	30$			;IF VS NONE
	BSBB	40$			;DEALLOCATE BUFFER
	BRB	20$			;
30$:	MOVL	R5,R0			;SET ADDRESS OF LAST BLOCK
40$:	JSB	EXE$DEANONPAGED		;DEALLOCATE NONPAGED MEMORY
	RSB				;

;****************************
; END   - Non-pageable code *
;****************************
NON_PAGED_END = .


	.SBTTL	TIMAST - TIMER AST ROUTINE
;++
; FUNCTIONAL DESCRIPTION:
;	THIS ROUTINE IS ENTERED WHEN THE DATA COLLECTION PERIOD HAS ELAPSED.
;
; INPUT PARAMETERS:
;	NONE
;
; IMPLICIT INPUTS:
;	TIMER EXPIRED FLAG IN OWN STORAGE
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	THE TIMER EXPIRED FLAG IS SET AND A WAKE SYSTEM SERVICE IS EXECUTED
;	TO WAKE THE DATA COLLECTION PROCESS.
;
;--
 
TIMAST:
	.WORD	^M<>
	BISB	#2,W^FLAGS		;SET TIMER EXPIRED FLAG
	$WAKE_S				;WAKE UP CURRENT PROCESS
	RET				;
 
	.END
