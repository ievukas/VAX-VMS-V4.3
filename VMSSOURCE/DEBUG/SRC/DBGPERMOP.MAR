	.TITLE	DBGPERMOP
    	.IDENT	/V04-000/
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; WRITTEN BY
;	Ping Sager	Jun, 1982
;
; MODIFIED BY
;	Rich Title	Nov, 1982	Changed DBG$PERFORM_OPERATOR so
;					that it handles value descriptors
;					instead of VMS descriptors. This
;					is necessary for operations that
;					may use the TYPEID field, such
;					as the SIZEOF operator in C, where
;					it is necessary to look up the DST
;					information in order to determine
;					the result.
;	V. Holt		Mar, 1983	Added support for packed decimal.
;					Added support for PL/I bit-strings.
;
;	P. Sager	Jun, 1983       Fixed up PLI/I bit-string operations
;					and packed decimal comparisons.
;	P. Sager	Sep, 1983	Changed .LONG to .BLKL for operand
;					and work_octa.
;	K. Glossop	Oct, 1983	Fixed complex exponentiation.  (The
;					real and imaginary portions were being
;					pushed on the stack in reverse order.)
;					Also, a complex raised to a complex
;					power checks for (0,0) as the base
;					and signals the appropriate error rather
;					than causing an internal Debug coding
;					error.
;	B. Becker	Oct, 1983	Inserted calls to dbg$succ_enum and
;					dbg$pred_enum to implement those built-
;					in functions.
;	B. Becker	Dec, 1983	Inserted calls to fixed binary 
;					arithmetic routines.
;	B. Becker	Dec, 1983	Added routines DBG$CVT_TUQUADWORD_TO_VALUE
;					and DBG$CVT_TUOCTAWORD_TO_VALUE to convert
;					to Unsigned Quad & Octawords.  To fixed the
;					bug DEP/QUAD I = 8000000000000000 for example
;	B. Becker	Jan, 1984	Made the MOD operation work correctly.
;	K. Glossop	Jan, 1984	Fixed G-Float complex add.
;
; MODULE FUNCTION
;	This module contains DBG$PERFORM_OPERATOR, the routine that 
;	performs arithmetic operations.
;
; IMPORTANT NOTE
; 	This module contains many definitions of constants and
;	offsets that are duplicates of those in DBGLIB.
;	This includes:
;	Case labels (e.g., ADD_L_L, ADD_B_B, etc.) - the order of these
;			MUST be the same as the ORT$K_ADD_L_L etc. definitions
;			in DBGLIB, or else the CASE statement will not work.
;	Offsets to fields within Value Descriptors (e.g., DBG$A_VALUE_VMSDESC)
;			If the fields of a value descriptor change then these
;			offsets must change accordingly.
;	Literal constants - there are 4 of these: ORT$K_MIN_ROUT,
;			ORT$K_MAX_ROUT, DBG$K_BASIC, DBG$K_PLI_UBIT (defined
;			below). These values must correspond to the value
;			for the same constant in DBGLIB.
;	There are more than just these four needed. see below.
;


;
; External routines
    	.SBTTL	declarations
	.EXTRN	DBG$ABS_FIXED
	.EXTRN	DBG$ADD_FIXED_FIXED
    	.EXTRN	DBG$BLISS_INDIRECTION
    	.EXTRN  DBG$BLISS_BITSELECT
    	.EXTRN  DBG$C_ADDRESS_OF
    	.EXTRN	DBG$C_INDIRECTION
    	.EXTRN  DBG$C_SIZEOF
    	.EXTRN	DBG$C_ADD_TPTR_L
    	.EXTRN	DBG$C_SUB_TPTR_L
    	.EXTRN	DBG$C_SUB_TPTR_TPTR
	.EXTRN	DBG$DIV_FIXED_FIXED
	.EXTRN	DBG$EQL_FIXED_FIXED
	.EXTRN  DBG$GB_LANGUAGE
	.EXTRN	DBG$GEQ_FIXED_FIXED
	.EXTRN	DBG$GTR_FIXED_FIXED
	.EXTRN	DBG$LEQ_FIXED_FIXED
	.EXTRN	DBG$LSS_FIXED_FIXED
	.EXTRN	DBG$MUL_FIXED_FIXED
	.EXTRN	DBG$NEQ_FIXED_FIXED
	.EXTRN	DBG$PRED_ENUM
	.EXTRN	DBG$SUB_FIXED_FIXED
	.EXTRN	DBG$SUCC_ENUM
	.EXTRN	DBG$UNARY_MINUS_FIXED
	.EXTRN	DBG$UNARY_PLUS_FIXED
	.EXTRN	PLI$ANDBIT
	.EXTRN	PLI$CATBIT
	.EXTRN	PLI$CMPBIT
	.EXTRN	PLI$DIV_PK_LONG
	.EXTRN	PLI$NOTBIT
	.EXTRN	PLI$ORBIT


; Invoke data definitions
;
    	$SHRDEF			; Shared error messages
    	$SSDEF			; System error codes
    	$DSCDEF			; Data definitions
    	$STSDEF			; Status code fields
	$DBGDEF			; Debug definitions
    	$CHFDEF			; Signal argument definitions
    	$MTHDEF			; Math. Lib. definitions
    	$STRDEF			; String definitions


; Literal constants - these are the same as those in DBGLIB - see note above.
; (These used to be obtained from DBGCOMLIB.MLB, which was built from
; DBGLIB.REQ. However, I decided that the overhead of building DBGCOMLIB
; just for these four constants was not worth it. Since we already have
; several other things that must be kept consistent across DBGLIB.REQ and
; this module, I just duplicated the definitions here.)
;
; As you have noted, it turned out there are more things needed from
; DBGLIB, since you have taken it out, so someone else duplicated some
; more constants.  
;

    	dbg$k_basic = 4
    	dbg$k_pli_ubit = 12
    	dbg$k_pli_abit = 14
    	ort$k_min_rout = 1
    	ort$k_max_rout = 284
    	token$k_integer = 4
    	token$k_hex_integer = 5
    	token$k_bin_integer = 10
    	token$k_oct_integer = 11

    	.PSECT	DBG$PLIT,BYTE,PIC,SHR,NOWRT
errmsg:	
    	.ASCIC	/DBGPERMOP\DBG$PERFORM_OPERATOR unknown routine index/
errmsg1:
    	.ASCIC  /DBGPERMOP\DBG$CVT_TRFA_TO_VALUE foreign tokencode/
errmsg2:
    	.ASCIC  /DBGPERMOP\DBG$CVT_TQUADWORD_TO_VALUE foreign tokencode/
errmsg3:
    	.ASCIC  /DBGPERMOP\DBG$CVT_TUQUADWORD_TO_VALUE foreign tokencode/
errmsg4:
    	.ASCIC  /DBGPERMOP\DBG$CVT_TOCTAWORD_TO_VALUE foreign tokencode/
errmsg5:
    	.ASCIC  /DBGPERMOP\DBG$CVT_TUOCTAWORD_TO_VALUE foreign tokencode/

; Own Storage
;
    	.PSECT  DBG$OWN,NOEXE,LONG,PIC
save_operator_entry:
    	.LONG	0
save_result:
    	.LONG	0
dope1:
    	.LONG	0
dope2:
	.LONG	0
scratch1:
    	.BLKL	4
scratch2:
    	.BLKL	4
arg1_desc:
    	.LONG	0
arg1_valdesc:
    	.LONG	0
arg2_desc:
    	.LONG	0
arg2_valdesc:
    	.LONG	0
result_desc:
    	.LONG	0
result_valdesc:
    	.LONG	0
operand:
    	.BLKL	5
work_octa:
    	.BLKL	4

	.PSECT	DBG$CODE,NOWRT,BYTE,PIC,SHR

    	.SBTTL  dbg$perform_operator
;++
;GLOBAL ROUTINE DBG$PERFORM_OPERATOR(OPERATOR_ENTRY, ROUT_INDEX, 
;		LEFT_ARG, RIGHT_ARG, RESULT_ADDR): NOVALUE =
;
; FUNCTION
;	Perform the operation indicated by ROUT_INDEX, and leave the result
;	at RESULT_ADDR.
;
;	There are assumptions made in this routine:
;	  1.  Always check overflow conditions, and give informational message
;	  2.  The result will be the same type as the operand's type
;	  3.  Comparison result will be always a longword value
;	  4.  There is no mixed mode operation, ie., BU + B, or no B + L, etc.
;	      some sort of conversion will be done before the operation 
;         5.  Language rules always have precedence.  There will be a specical 
;	      routine to perform the operation for that language
;
; INPUTS
;	OPERATOR_ENTRY 	- A pointer to the Operator Lexical Token Entry for
;			  operator.
;
;	ROUT_INDEX	- A case index indicating which operation is to be
;			  performed.  The possible values for this index are
;			  defined in DBGLIB.
;
;	LEFT_ARG	- The address of the left operand (or, in the case of
;			  unary operators, the only operand). This is a
;			  pointer to a value descriptor.
;
;	RIGHT_ARG	- The address of the right operand (in the case of
;			  unary operators, this operand is not used and its
;			  value will be zero. This address is a pointer
;			  to a value descriptor.
;
;	RESULT_ADDR	- A pointer to a longword which contains a pointer
;			  to a Value Descriptor which should be filled in
;			  with the result of the operation. The reason for
;			  the extra level of indirection is that in some
;			  cases we may build a new descriptor instead
;			  of using the one that is passed to us. In this
;			  case, we update RESULT_ADDR to point to the
;			  new descriptor.
;
; OUTPUTS
;	The result of the operation is left in the result value descriptor.
;	No value is returned.
;++


; Parameter offsets
;
	bitpos		= 2
    	operator_entry	= 4
    	rout_index	= 8
    	left_arg	= 12
    	right_arg	= 16
    	result_addr	= 20
    	token_name	= 12


; Register usage
;	r2	VMS Address of the left operand in value descriptor
;	r3	VMS Address of the right operand in value descriptor
;	r4	VMS Address of the result in vlaue descriptor
;	r5	Temporary result
;	r6	Temporary result
;	If the operands are packed, then r6 = arg1 vms desc.
;					 r7 = arg2 vms desc.
;					 r8 = result vms desc.

; PSL
;	FU	Floating Underflow Trap enable
;	IV	Interger Overflow trap disable
;


.ENTRY	dbg$perform_operator,^M<DV,r2,r3,r4,r5,r6,r7,r8,r9,r10,r11>
    	MOVAL	trap_msg_handler,(FP)	; Enable trap exception handler
    	BISPSW	#^X40			; Enable Floating Underflow Traps
   	MOVL	operator_entry(AP),save_operator_entry
    					; Save operator entry pointer in static area

;NOTE:
; The block of code below uses absolute offsets such as 16 to get at fields
; inside of a Value Descriptor. This is because of difficulties of getting
; the symbolic definitions from DBGLIB into this module.
;
; So, until this is fixed, the block of code below has to be changed whenever
; the definition of a Value Descriptor changes. This just affects the
; code between the asterisks.
;**************************************************************************
    	MOVL	left_arg(AP),r2		; Get the address of the left argument
    	MOVL	r2,arg1_valdesc		; Save the value descriptor address
    	ADDL2	#20,r2			; Get pointer to VMS descriptor
    	MOVL	r2,arg1_desc		; Save the VMS descriptor address
    	MOVL	4(r2),r2		; Get the pointer to value
    	MOVL	right_arg(AP),r3	; Get the address of the right argument
    	TSTL	r3			; Test to see if there is a right argument
    	BEQL	get_result_addr$	; Get the result address
    	MOVL	r3,arg2_valdesc		; Save the value descriptor address
    	ADDL2	#20,r3			; Get pointer to VMS descriptor
    	MOVL	r3,arg2_desc		; Save the VMS descriptor address
    	MOVL	4(r3),r3		; Get the pointer to value
get_result_addr$:
    	MOVL	result_addr(AP),r4	; Get the address of the result
    	MOVL	(r4),r4			; Extra level of indirection for result
    	MOVL	r4,result_valdesc	; Save result value descriptor address
    	ADDL2	#20,r4
    	MOVL	r4,result_desc		; Save the VMS descriptor address
    	MOVL	4(r4),r4		; Get the pointer to value
    	MOVL	r4,save_result		; Save the result pointer
;****************************************************************************

; Case on routine index to perform the actual operation
;
    	CASEW	rout_index(AP),#ort$k_min_rout,#ort$k_max_rout
bgn:	.WORD	ADD_B_B		- bgn
    	.WORD	ADD_BU_BU 	- bgn
    	.WORD	ADD_W_W		- bgn
    	.WORD	ADD_WU_WU 	- bgn
    	.WORD	ADD_L_L		- bgn
    	.WORD	ADD_LU_LU 	- bgn
    	.WORD	ADD_F_F		- bgn
    	.WORD	ADD_D_D		- bgn
    	.WORD	ADD_G_G		- bgn
    	.WORD	ADD_H_H		- bgn
    	.WORD	ADD_FC_FC	- bgn
    	.WORD	ADD_DC_DC	- bgn
    	.WORD	ADD_GC_GC 	- bgn
    	.WORD	ADD_HC_HC	- bgn
    	.WORD	SUB_B_B		- bgn
    	.WORD	SUB_BU_BU 	- bgn
    	.WORD	SUB_W_W		- bgn
    	.WORD	SUB_WU_WU 	- bgn
    	.WORD	SUB_L_L		- bgn
    	.WORD	SUB_LU_LU 	- bgn
    	.WORD	SUB_F_F		- bgn
    	.WORD	SUB_D_D		- bgn
    	.WORD	SUB_G_G		- bgn
    	.WORD	SUB_H_H		- bgn
    	.WORD	SUB_FC_FC	- bgn
    	.WORD	SUB_DC_DC	- bgn
    	.WORD	SUB_GC_GC 	- bgn
    	.WORD	SUB_HC_HC	- bgn
    	.WORD	DIV_B_B		- bgn
    	.WORD	DIV_BU_BU 	- bgn
    	.WORD	DIV_W_W		- bgn
    	.WORD	DIV_WU_WU 	- bgn
    	.WORD	DIV_L_L		- bgn
    	.WORD	DIV_LU_LU 	- bgn
    	.WORD	DIV_F_F		- bgn
    	.WORD	DIV_D_D		- bgn
    	.WORD	DIV_G_G		- bgn
    	.WORD	DIV_H_H		- bgn
    	.WORD	DIV_FC_FC	- bgn
    	.WORD	DIV_DC_DC	- bgn
    	.WORD	DIV_GC_GC 	- bgn
    	.WORD	DIV_HC_HC	- bgn
    	.WORD	MUL_B_B		- bgn
    	.WORD	MUL_BU_BU 	- bgn
    	.WORD	MUL_W_W		- bgn
    	.WORD	MUL_WU_WU	- bgn
    	.WORD	MUL_L_L		- bgn
    	.WORD	MUL_LU_LU 	- bgn
    	.WORD	MUL_F_F		- bgn
    	.WORD	MUL_D_D		- bgn
    	.WORD	MUL_G_G		- bgn
    	.WORD	MUL_H_H		- bgn
    	.WORD	MUL_FC_FC	- bgn
    	.WORD	MUL_DC_DC	- bgn
    	.WORD	MUL_GC_GC 	- bgn
    	.WORD	MUL_HC_HC	- bgn
    	.WORD	MOD_L_L		- bgn
    	.WORD	MOD_LU_LU	- bgn
    	.WORD	REM_L_L		- bgn
    	.WORD	REM_LU_LU	- bgn
    	.WORD	SHIFT_LEFT_L_L 	- bgn
    	.WORD	SHIFT_RT_L_L   	- bgn
    	.WORD	SHIFT_RT_LU_LU	- bgn
    	.WORD	POWER_W_W 	- bgn
    	.WORD	POWER_L_L 	- bgn
    	.WORD	POWER_F_L 	- bgn
    	.WORD	POWER_D_L 	- bgn
    	.WORD	POWER_G_L 	- bgn
    	.WORD	POWER_H_L 	- bgn
    	.WORD	POWER_FC_L	- bgn
    	.WORD	POWER_DC_L	- bgn
    	.WORD	POWER_GC_L	- bgn
    	.WORD	POWER_F_F	- bgn
    	.WORD	POWER_D_F	- bgn
    	.WORD	POWER_F_D 	- bgn
    	.WORD	POWER_D_D 	- bgn
    	.WORD	POWER_G_G 	- bgn
    	.WORD	POWER_H_H 	- bgn
    	.WORD	POWER_FC_FC 	- bgn
    	.WORD	POWER_DC_DC	- bgn
    	.WORD	POWER_GC_GC	- bgn
    	.WORD	CONCAT_T_T 	- bgn
    	.WORD	EQL_VT_VT	- bgn
    	.WORD	EQL_T_T 	- bgn
    	.WORD	GEQ_VT_VT	- bgn
    	.WORD	GEQ_T_T		- bgn
    	.WORD	GTR_VT_VT	- bgn 
    	.WORD	GTR_T_T 	- bgn
    	.WORD	LEQ_VT_VT	- bgn
    	.WORD	LEQ_T_T   	- bgn
    	.WORD	LSS_VT_VT	- bgn
    	.WORD	LSS_T_T  	- bgn
    	.WORD	NEQ_VT_VT	- bgn 
    	.WORD	NEQ_T_T   	- bgn
    	.WORD	EQL_B_B		- bgn
    	.WORD	EQL_W_W		- bgn
    	.WORD	EQL_L_L		- bgn
    	.WORD	EQL_F_F		- bgn
    	.WORD	EQL_D_D		- bgn
    	.WORD	EQL_G_G		- bgn
    	.WORD	EQL_H_H		- bgn
    	.WORD	EQL_FC_FC 	- bgn
    	.WORD	EQL_DC_DC 	- bgn
    	.WORD	EQL_GC_GC 	- bgn
    	.WORD	EQL_HC_HC	- bgn
    	.WORD	NEQ_B_B		- bgn
    	.WORD	NEQ_W_W		- bgn
    	.WORD	NEQ_L_L		- bgn
    	.WORD	NEQ_F_F		- bgn
    	.WORD	NEQ_D_D		- bgn
    	.WORD	NEQ_G_G		- bgn
    	.WORD	NEQ_H_H		- bgn
    	.WORD	NEQ_FC_FC	- bgn
    	.WORD	NEQ_DC_DC	- bgn
    	.WORD	NEQ_GC_GC 	- bgn
    	.WORD	NEQ_HC_HC	- bgn 
    	.WORD	GEQ_B_B		- bgn 
    	.WORD	GEQ_W_W		- bgn 
    	.WORD	GEQ_L_L		- bgn 
    	.WORD	GEQ_LU_LU	- bgn 
    	.WORD	GEQ_F_F		- bgn 
    	.WORD	GEQ_D_D		- bgn 
    	.WORD	GEQ_G_G		- bgn 
    	.WORD	GEQ_H_H		- bgn 
    	.WORD	GTR_B_B		- bgn
    	.WORD	GTR_W_W		- bgn
    	.WORD	GTR_L_L		- bgn
    	.WORD	GTR_LU_LU	- bgn
    	.WORD	GTR_F_F		- bgn
    	.WORD	GTR_D_D		- bgn
    	.WORD	GTR_G_G		- bgn
    	.WORD	GTR_H_H		- bgn
    	.WORD	LEQ_B_B		- bgn
    	.WORD	LEQ_W_W		- bgn
    	.WORD	LEQ_L_L		- bgn
    	.WORD	LEQ_LU_LU	- bgn 
    	.WORD	LEQ_F_F		- bgn 
    	.WORD	LEQ_D_D		- bgn 
    	.WORD	LEQ_G_G		- bgn 
    	.WORD	LEQ_H_H		- bgn 
    	.WORD	LSS_B_B		- bgn 
    	.WORD	LSS_W_W		- bgn 
    	.WORD	LSS_L_L		- bgn 
    	.WORD	LSS_LU_LU	- bgn 
    	.WORD	LSS_F_F		- bgn 
    	.WORD	LSS_D_D		- bgn 
    	.WORD	LSS_G_G		- bgn 
    	.WORD	LSS_H_H		- bgn 
    	.WORD	BIT_AND_B_B	- bgn 
    	.WORD	BIT_AND_W_W	- bgn 
    	.WORD	BIT_AND_L_L	- bgn 	
    	.WORD	BIT_EQV_B_B	- bgn 
    	.WORD	BIT_EQV_W_W	- bgn 
    	.WORD	BIT_EQV_L_L	- bgn 
    	.WORD	BIT_NOT_B	- bgn 
    	.WORD	BIT_NOT_W	- bgn 
    	.WORD	BIT_NOT_L	- bgn 
    	.WORD	BIT_OR_B_B 	- bgn 
    	.WORD	BIT_OR_W_W 	- bgn 	
    	.WORD	BIT_OR_L_L 	- bgn 
    	.WORD	BIT_XOR_B_B	- bgn 
    	.WORD	BIT_XOR_W_W	- bgn 
    	.WORD	BIT_XOR_L_L	- bgn 
    	.WORD	AND_B_B		- bgn 
    	.WORD	AND_W_W		- bgn 
    	.WORD	AND_L_L		- bgn 
    	.WORD	AND_D_D		- bgn 
    	.WORD	NOT_B		- bgn
    	.WORD	NOT_W		- bgn
    	.WORD	NOT_L		- bgn
     	.WORD	NOT_D		- bgn
    	.WORD	OR_B_B		- bgn 
    	.WORD	OR_W_W		- bgn 
    	.WORD	OR_L_L		- bgn 
     	.WORD	OR_D_D		- bgn 
    	.WORD	XOR_L_L		- bgn
    	.WORD	UNARY_MINUS_B	- bgn 
    	.WORD	UNARY_MINUS_W	- bgn 
    	.WORD	UNARY_MINUS_L	- bgn 
    	.WORD	UNARY_MINUS_LU	- bgn 
    	.WORD	UNARY_MINUS_F	- bgn 
    	.WORD	UNARY_MINUS_D	- bgn 
    	.WORD	UNARY_MINUS_G	- bgn 
    	.WORD	UNARY_MINUS_H	- bgn 
    	.WORD	UNARY_MINUS_FC	- bgn 
    	.WORD	UNARY_MINUS_DC	- bgn 
    	.WORD	UNARY_MINUS_GC 	- bgn 
    	.WORD	UNARY_MINUS_HC	- bgn 
    	.WORD	UNARY_PLUS_B	- bgn 
    	.WORD	UNARY_PLUS_W	- bgn 
    	.WORD	UNARY_PLUS_L	- bgn 
    	.WORD	UNARY_PLUS_F	- bgn 
    	.WORD	UNARY_PLUS_D	- bgn 
    	.WORD	UNARY_PLUS_G	- bgn 
    	.WORD	UNARY_PLUS_H	- bgn 
    	.WORD	UNARY_PLUS_FC	- bgn 
    	.WORD	UNARY_PLUS_DC	- bgn 
    	.WORD	UNARY_PLUS_GC 	- bgn 
    	.WORD	UNARY_PLUS_HC	- bgn 
    	.WORD	ABS_B		- bgn
    	.WORD	ABS_W		- bgn
    	.WORD	ABS_L		- bgn
    	.WORD	ABS_F		- bgn
    	.WORD	ABS_D		- bgn
    	.WORD	ABS_G		- bgn
    	.WORD	ABS_H		- bgn
    	.WORD	INDIRECT_LU	- bgn 
    	.WORD	INDIRECT_TPTR	- bgn 
    	.WORD	BITSELECT	- bgn
    	.WORD	DIFFERENCE_SET_SET - bgn
    	.WORD	EQL_SET_SET	- bgn
    	.WORD	GEQ_SET_SET	- bgn
    	.WORD	IN_SET_SET	- bgn
    	.WORD	INTERSECT_SET_SET  - bgn
    	.WORD	LEQ_SET_SET	- bgn
    	.WORD	NEQ_SET_SET	- bgn
    	.WORD	UNION_SET_SET	- bgn
    	.WORD	ADDRESS_L	- bgn
    	.WORD	SIZEOF_L	- bgn
    	.WORD   ADD_TPTR_L	- bgn
    	.WORD	SUB_TPTR_L	- bgn
    	.WORD	SUB_TPTR_TPTR	- bgn
	.WORD	BIT_IMP_B_B	- bgn
	.WORD	BIT_IMP_W_W	- bgn
	.WORD	BIT_IMP_L_L	- bgn
    	.WORD	PRE_INCR_L	- bgn
    	.WORD	PRE_INCR_LU	- bgn
    	.WORD	PRE_INCR_D	- bgn
    	.WORD	PRE_INCR_TPTR	- bgn
    	.WORD	POST_INCR_L	- bgn
    	.WORD	POST_INCR_LU	- bgn
    	.WORD	POST_INCR_D	- bgn
    	.WORD	POST_INCR_TPTR	- bgn
    	.WORD	PRE_DECR_L	- bgn
    	.WORD	PRE_DECR_LU	- bgn
    	.WORD	PRE_DECR_D	- bgn
    	.WORD	PRE_DECR_TPTR	- bgn
    	.WORD	POST_DECR_L	- bgn
    	.WORD	POST_DECR_LU	- bgn
    	.WORD	POST_DECR_D	- bgn
    	.WORD	POST_DECR_TPTR	- bgn
	.WORD  	ADD_P_P		- bgn
	.WORD	SUB_P_P		- bgn
	.WORD	MUL_P_P		- bgn
	.WORD	DIV_P_P		- bgn
	.WORD	UNARY_PLUS_P	- bgn
	.WORD	UNARY_MINUS_P	- bgn
	.WORD	EQL_P_P		- bgn
	.WORD	NEQ_P_P		- bgn
	.WORD	GTR_P_P		- bgn
	.WORD	GEQ_P_P		- bgn
	.WORD	LSS_P_P		- bgn
	.WORD	LEQ_P_P		- bgn
	.WORD	CONCAT_TF_TF	- bgn
	.WORD	EQL_TF_TF	- bgn
	.WORD	NEQ_TF_TF	- bgn
	.WORD	GTR_TF_TF	- bgn
	.WORD	GEQ_TF_TF	- bgn
	.WORD	LSS_TF_TF	- bgn
	.WORD	LEQ_TF_TF	- bgn
	.WORD	BIT_NOT_TF_TF	- bgn
	.WORD	BIT_AND_TF_TF	- bgn
	.WORD	BIT_OR_TF_TF	- bgn
    	.WORD	EQL_RFA_RFA	- bgn
    	.WORD	NEQ_RFA_RFA	- bgn
    	.WORD   UNARY_PLUS_Q    - bgn
    	.WORD   UNARY_MINUS_Q   - bgn
    	.WORD   UNARY_PLUS_O    - bgn
    	.WORD   UNARY_MINUS_O   - bgn
	.WORD	SUCC_ENUM	- bgn					;BB001
	.WORD	PRED_ENUM	- bgn					;BB001
    	.WORD	UNARY_PLUS_FIXED- bgn
    	.WORD	UNARY_MINUS_FIXED-bgn
    	.WORD	ABS_FIXED	- bgn
    	.WORD	ADD_FIXED_FIXED	- bgn
    	.WORD	SUB_FIXED_FIXED	- bgn
    	.WORD	MUL_FIXED_FIXED	- bgn
    	.WORD	DIV_FIXED_FIXED	- bgn
    	.WORD	EQL_FIXED_FIXED	- bgn
    	.WORD	NEQ_FIXED_FIXED - bgn
    	.WORD	LSS_FIXED_FIXED	- bgn
    	.WORD	GTR_FIXED_FIXED	- bgn
    	.WORD	LEQ_FIXED_FIXED	- bgn
    	.WORD	GEQ_FIXED_FIXED	- bgn
    	BRW	unknown_rout_index
    
int_overflow:
    	MOVL	save_operator_entry,r2
    	MOVAL	token_name(r2),r2
    	PUSHL	r2
    	PUSHL	#1
    	PUSHL	#dbg$_iintovf
    	CALLS	#3,G^LIB$SIGNAL
    	RET

div_by_zero:
    	PUSHL	#dbg$_divbyzero
    	CALLS	#1,G^LIB$SIGNAL
    	RET

shift_count_negative:
    	PUSHL	#dbg$_sfcntneg
    	CALLS	#1,G^LIB$SIGNAL
    	RET

string_truncate:
    	MOVL	save_operator_entry,r2
    	MOVAL	token_name(r2),r2
    	PUSHL	r2
    	PUSHL	#1
    	PUSHL	#dbg$_istrtru
    	CALLS	#3,G^LIB$SIGNAL

branch_ret:
	CMPB	DBG$GB_LANGUAGE, #DBG$K_BASIC
	BEQL	basic$
	RET
basic$:
	MNEGL	(r4), (r4)
    	RET


;******************************************************************************
;
;	A  D  D    and    S  U  B  T  R  A  C  T
;
;******************************************************************************


; Additive Operators - Addition
;
add_b_b:
    	ADDB3	(r2),(r3),(r4)
    	BVS	add_b$			; Branch on V bit set
    	RET
add_b$:
    	BRW	int_overflow

add_bu_bu:
    	ADDB3	(r2),(r3),(r4)
    	BCS	add_bu$			; Branch on C bit set
    	RET
add_bu$:
    	BRW	int_overflow

add_w_w:
    	ADDW3	(r2),(r3),(r4)
    	BVS	add_w$
    	RET
add_w$:
    	BRW	int_overflow

add_wu_wu:
    	ADDW3	(r2),(r3),(r4)
    	BCS	add_wu$
    	RET
add_wu$:
    	BRW	int_overflow

add_l_l:
    	ADDL3	(r2),(r3),(r4)
    	BVS	add_l$
    	RET
add_l$:
    	BRW	int_overflow

add_lu_lu:
    	ADDL3	(r2),(r3),(r4)
    	BCS	add_lu$
    	RET
add_lu$:
    	BRW	int_overflow

add_f_f:
    	ADDF3	(r2),(r3),(r4)
    	RET
add_d_d:
    	ADDD3	(r2),(r3),(r4)
    	RET
add_g_g:
    	ADDG3	(r2),(r3),(r4)
    	RET
add_h_h:
    	ADDH3	(r2),(r3),(r4)
    	RET

add_fc_fc:
    	ADDF3	(r2),(r3),(r4)		; Add Real Part
    	ADDF3	4(r2),4(r3),4(r4)	; Add Imaginary Part
    	RET
add_dc_dc:
    	ADDD3	(r2),(r3),(r4)
    	ADDD3	8(r2),8(r3),8(r4)
    	RET
add_gc_gc:
    	ADDG3	(r2),(r3),(r4)
    	ADDG3	8(r2),8(r3),8(r4)
    	RET
add_hc_hc:
    	ADDH3	(r2),(r3),(r4)
    	ADDH3	16(r2),16(r3),16(r4)
    	RET


; Additive Operators - Subtraction
;
sub_b_b:
    	SUBB3	(r3),(r2),(r4)
    	BVS	sub_b$
    	RET
sub_b$:
    	BRW	int_overflow

sub_bu_bu:
    	SUBB3	(r3),(r2),(r4)
    	BCS	sub_bu$
    	RET
sub_bu$:
    	BRW	int_overflow

sub_w_w:
    	SUBW3	(r3),(r2),(r4)
    	BVS	sub_w$
    	RET
sub_w$:
    	BRW	int_overflow

sub_wu_wu:
    	SUBW3	(r3),(r2),(r4)
    	BCS	sub_wu$
    	RET
sub_wu$:
    	BRW	int_overflow

sub_l_l:
    	SUBL3	(r3),(r2),(r4)
    	BVS	sub_l$
    	RET
sub_l$:
    	BRW	int_overflow

sub_lu_lu:
    	SUBL3	(r3),(r2),(r4)
    	BCS	sub_lu$
    	RET
sub_lu$:
    	BRW	int_overflow

sub_f_f:
    	SUBF3	(r3),(r2),(r4)
    	RET
sub_d_d:
    	SUBD3	(r3),(r2),(r4)
    	RET
sub_g_g:
    	SUBG3	(r3),(r2),(r4)
    	RET
sub_h_h:
    	SUBH3	(r3),(r2),(r4)
    	RET

sub_fc_fc:
    	SUBF3	(r3),(r2),(r4)
    	SUBF3	4(r3),4(r2),4(r4)
    	RET
sub_dc_dc:
    	SUBD3	(r3),(r2),(r4)
    	SUBD3	8(r3),8(r2),8(r4)
    	RET
sub_gc_gc:
    	SUBG3	(r3),(r2),(r4)
    	SUBG3	8(r3),8(r2),8(r4)
    	RET
sub_hc_hc:
    	SUBH3	(r3),(r2),(r4)
    	SUBH3	16(r3),16(r2),16(r4)
    	RET


;******************************************************************************
;
;	D  I  V  I  D  E    and    M  U  L  T  I  P  L  Y
;
;******************************************************************************


; Multiplicative - Division
;
div_b_b:
    	DIVB3	(r3),(r2),(r4)
    	BVS	div_b$
    	RET
div_b$:
    	BRW	int_overflow

div_bu_bu:
    	MOVZBL	(r2),r2			; Zero-extend Dividend
    	MOVZBL	(r3),r3			; Zero-extend Divisor
    	BEQL	div_bu$			; Test divisor is not zero
    	DIVL3	r3,r2,r5
    	MOVB	r5,(r4)
    	RET
div_bu$:
    	BRW	div_by_zero

div_w_w:
    	DIVW3	(r3),(r2),(r4)
    	BVS	div_w$
    	RET
div_w$:
    	BRW	int_overflow

div_wu_wu:
    	MOVZWL	(r2),r2
    	MOVZWL	(r3),r3
    	BEQL	div_wu$
    	DIVL3	(r3),(r2),r5
    	MOVW	r5,(r4)
    	RET
div_wu$:
    	BRW	div_by_zero

div_l_l:
    	DIVL3	(r3),(r2),(r4)
    	BVS	div_l$
    	RET
div_l$:
    	BRW	int_overflow

div_lu_lu:				; 
    	TSTL	(r3)			; Check for divide by 0
    	BEQL	div_lu1$		; Branch on divide by 0
    	BGTR	ext_prec_div		; Branch on +Divisor
    	CLRL	r5			; Assume zero result
    	CMPL	(r3),(r2)		; Compare Divident and -Divisor
    					; -- (divided by large number)
    	BGTRU	set_quotient		; Result is 0, set it
    	INCL	r5			; Result is 1
    	BRB	set_quotient		; Set it
ext_prec_div:
    	MOVL	(r2),r5			; Divident is quarward
    	CLRL	r6
    	EDIV	(r3),r5,(r4),r2		; Perform the DIV
    	BCS	div_lu2$	    	
    	RET
div_lu1$:
    	BRW	div_by_zero
div_lu2$:
    	BRW	int_overflow

set_quotient:
    	MOVL	r5,(r4)			; Set result
    	RET

div_f_f:
    	DIVF3	(r3),(r2),(r4)
    	RET

div_d_d:
    	DIVD3	(r3),(r2),(r4)
    	RET

div_g_g:
    	DIVG3	(r3),(r2),(r4)
    	RET

div_h_h:
    	DIVH3	(r3),(r2),(r4)
    	RET

div_fc_fc:
    	MULF3	(r3),(r3),r5		; X = B<1>*B<1> + B<2>*B<2>
    	MULF3	4(r3),4(r3),r6
    	ADDF3	r5,r6,r1
    	TSTF	r1
    	BEQL	div_fc$
    	MULF3	(r3),(r2),r5		; Real Part Division
    	MULF3	4(r3),4(r2),r6		; C<1> = (A<1>*B<1> + A<2>*B<2>) / X
    	ADDF2	r5,r6
    	DIVF3	r1,r6,(r4)
    	MULF3	(r3),4(r2),r5		; Imaginary Part Division
    	MULF3	4(r3),(r2),r6		; C<2> = (A<2>*B<1> - A<1>*B<2>) / X
    	SUBF2	r6,r5
    	DIVF3	r1,r5,4(r4)
    	RET
div_fc$:
    	BRW	div_by_zero

div_dc_dc:
    	MULD3	(r3),(r3),scratch1	; X = B<1>*B<1> + B<2>*B<2>
    	MULD3	8(r3),8(r3),scratch2
    	ADDD3	scratch1,scratch2,r5
    	TSTD	r5
    	BEQL	div_dc$
    	MULD3	(r3),(r2),scratch1	; Real Part Division
    	MULD3	8(r3),8(r2),scratch2	; C<1> = (A<1>*B<1> + A<2>*B<2>) / X
    	ADDD2	scratch1,scratch2
    	DIVD3	r5,scratch2,(r4)
    	MULD3	(r3),8(r2),scratch1	; Imaginary Part Division
    	MULD3	8(r3),(r2),scratch2	; C<2> = (A<2>*B<1> - A<1>*B<2>) / X
    	SUBD2	scratch2,scratch1
    	DIVD3	r5,scratch1,8(r4)
    	RET
div_dc$:
    	BRW	div_by_zero

div_gc_gc:
    	MULG3	(r3),(r3),scratch1	; X = B<1>*B<1> + B<2>*B<2>
    	MULG3	8(r3),8(r3),scratch2
    	ADDG3	scratch1,scratch2,r5
    	TSTG	div_gc$
    	MULG3	(r3),(r2),scratch1	; Real Part Division
    	MULG3	8(r3),8(r2),scratch2	; C<1> = (A<1>*B<1> + A<2>*B<2>) / X
    	ADDG2	scratch1,scratch2
    	DIVG3	r5,scratch2,(r4)
    	MULG3	(r3),8(r2),scratch1	; Imaginary Part Division
    	MULG3	8(r3),(r2),scratch2	; C<2> = (A<2>*B<1> - A<1>*B<2>) / X
    	SUBG2	scratch2,scratch1
    	DIVG3	r5,scratch1,8(r4)
    	RET
div_gc$:
    	BRW	div_by_zero

div_hc_hc:
    	MULH3	(r3),(r3),scratch1	; X = B<1>*B<1> + B<2>*B<2>
    	MULH3	16(r3),16(r3),scratch2
    	ADDH3	scratch1,scratch2,r5
    	TSTH	div_hc$
    	MULH3	(r3),(r2),scratch1	; Real Part Division
    	MULH3	16(r3),16(r2),scratch2	; C<1> = (A<1>*B<1> + A<2>*B<2>) / X
    	ADDH2	scratch1,scratch2
    	DIVH3	r5,scratch2,(r4)
    	MULH3	(r3),16(r2),scratch1	; Imaginary Part Division
    	MULH3	16(r3),(r2),scratch2	; C<2> = (A<2>*B<1> - A<1>*B<2>) / X
    	SUBH2	scratch2,scratch1
    	DIVH3	r5,scratch1,16(r4)
    	RET
div_hc$:
    	BRW	div_by_zero


; Multiplicative Operators - Multiply
;
mul_b_b:
    	MULB3	(r3),(r2),(r4)
    	BVS	mul_b$
    	RET
mul_b$:
    	BRW	int_overflow

mul_bu_bu:
    	MOVZBL	(r2),r5			; Move to a larger quantity so overflow
    	MOVZBL	(r3),r6			; condition can be detected
    	MULL2	r6,r5
    	CMPL	r5,#^XFF
    	BGTRU	mul_bu$
    	MOVB	r5,(r4)
    	RET
mul_bu$:
    	BRW	int_overflow

mul_w_w:
    	MULW3	(r3),(r2),(r4)
    	BVS	mul_w$
    	RET
mul_w$:
    	BRW	int_overflow

mul_wu_wu:
    	MOVZWL	(r2),r5
    	MOVZWL	(r3),r6
    	MULL2	r6,r5
    	CMPL	r5,#^XFFFF
    	BGTRU	mul_wu$
    	MOVW	r5,(r4)
    	RET
mul_wu$:
    	BRW	int_overflow

mul_l_l:
    	MULL3	(r3),(r2),(r4)
    	BVS	mul_l$
    	RET
mul_l$:
    	BRW	int_overflow

; (note: in C, the code generated for this operation is much simplified - 
;        MULL3.  The reason to do so in here is to detect overflow condition.
;
mul_lu_lu:				;  
    	EMUL	(r3),(r2),#0,r5		; Perform extended-precision multiplication
    	TSTL	(r3)			; Test muptiplier
    	BGEQ	positive_mulr		; Multiplier >= 0
    	ADDL2	(r2),r6			; Fudge, so overflow can be detected
positive_mulr:
    	TSTL	(r2)			; Test multiplicand
    	BGEQ	positive_muld		; Multiplicand >= 0
    	ADDL2	(r3),r6			; Fudge, so overflow can be detected
positive_muld:
    	TSTL	r6			; Test Result[low]
    	BNEQ	mul_lu$			; Result[low] not= zero, overflow
    	MOVL	r5,(r4)			; Get Result[high] as the result
    	RET
mul_lu$:
    	BRW	int_overflow

mul_f_f:
    	MULF3	(r3),(r2),(r4)
    	RET
mul_d_d:
    	MULD3	(r3),(r2),(r4)
    	RET
mul_g_g:
    	MULG3	(r3),(r2),(r4)
    	RET
mul_h_h:
    	MULH3	(r3),(r2),(r4)
    	RET

mul_fc_fc:
    	MULF3	(r3),(r2),r5		; Real Part Multiply:
    	MULF3	4(r3),4(r2),r6		; C<1> = A<1>*B<1> - A<2>*B<2>
    	SUBF3	r6,r5,(r4)		; Real part result
    	MULF3	4(r3),(r2),r5		; Imaginary Part Multiply:
    	MULF3	(r3),4(r2),r6		; C<2> = A<1>*B<2> + A<2>*B<1>
    	ADDF3	r5,r6,4(r4)		; Imaginary part result
    	RET
mul_dc_dc:
    	MULD3	(r3),(r2),scratch1	; Real Part Multiply:
    	MULD3	8(r3),8(r2),scratch2	; C<1> = A<1>*B<1> - A<2>*B<2>
    	SUBD3	scratch2,scratch1,(r4)	; Real part result
    	MULD3	8(r3),(r2),scratch1	; Imaginary Part Multiply:
    	MULD3	(r3),8(r2),scratch2	; C<2> = A<1>*B<2> + A<2>*B<1>
    	ADDD3	scratch1,scratch2,8(r4)	; Imaginary part result
    	RET
mul_gc_gc:
    	MULG3	(r3),(r2),scratch1	; Real Part Multiply:
    	MULG3	8(r3),8(r2),scratch2	; C<1> = A<1>*B<1> - A<2>*B<2>
    	SUBG3	scratch2,scratch1,(r4)	; Real part result
    	MULG3	8(r3),(r2),scratch1	; Imaginary Part Multiply:
    	MULG3	(r3),8(r2),scratch2	; C<2> = A<1>*B<2> + A<2>*B<1>
    	ADDG3	scratch1,scratch2,8(r4)	; Imaginary part result
    	RET
mul_hc_hc:
    	MULH3	(r3),(r2),scratch1	; Real Part Multiply:
    	MULH3	16(r3),16(r2),scratch2	; C<1> = A<1>*B<1> - A<2>*B<2>
    	SUBH3	scratch2,scratch1,(r4)	; Real part result
    	MULH3	16(r3),(r2),scratch1	; Imaginary Part Multiply:
    	MULH3	(r3),16(r2),scratch2	; C<2> = A<1>*B<2> + A<2>*B<1>
    	ADDH3	scratch1,scratch2,16(r4); Imaginary part result
    	RET


;******************************************************************************
;
;	M  O  D  U  L  U  S    and    R  E  M  A  I  N  D  E  R
;
;******************************************************************************


; Multiplicative - MOD operation
;
mod_l_l:
    	EMUL	#0,#0,(r2),(r4)
    	EDIV	(r3),(r4),(r4),(r4)
    	TSTL	(r4)
    	BEQL	mod_l_ret$
	XORL3	(r3),(r2),r5
	TSTL	r5
	BGEQ	mod_l_ret$
    	ADDL2	(r3),(r4)
mod_l_ret$:
    	RET

mod_lu_lu:
    	TSTL	(r3)
    	BGEQ	mod_lu$
    	SUBL3	(r3),(r2),(r4)
    	BGEQU	mod_lu_ret$
    	MOVL	(r2),(r4)
    	BRB	mod_lu_ret$
mod_lu$:
    	MOVL	(r2),(r4)
    	EDIV	(r3),(r4),(r4),(r4)
mod_lu_ret$:
    	RET


; Remainder Operators
;
rem_l_l:
    	EMUL	#0,#0,(r2),r5
    	EDIV	(r3),r5,r5,(r4)
    	RET

rem_lu_lu:
    	TSTL	(r3)
    	BGEQ	rem_lu$
    	SUBL3	(r3),(r2),(r4)
    	BGEQU	rem_lu_ret$
    	MOVL	(r2),(r4)
    	BRB	rem_lu_ret$
rem_lu$:
    	MOVL	(r2),(r4)
    	EDIV	(r3),(r4),(r4),(r4)
rem_lu_ret$:
    	RET


;******************************************************************************
;
;	S  H  I  F  T
;
;******************************************************************************


; Shift Operators
;
shift_left_l_l:				; same as shift_left_lu_lu
    	ASHL	(r3),(r2),(r4)
    	RET
shift_left_l$:
    	BRW	shift_count_negative

shift_rt_l_l:
    	TSTL	(r3)
    	BLSS	shift_rt_l$
    	MNEGL	(r3),r3
    	ASHL	r3,(r2),(r4)
    	RET
shift_rt_l$:
    	BRW	shift_count_negative

shift_rt_lu_lu:
    	TSTL	(r3)
    	BLSS	shift_rt_lu$
    	MNEGL	(r3),r3
    	TSTL	r3
    	BEQL	set_shift_result
    	MOVL	r3,r5
    	INCL	r5
    	ASHL	r5,#80000000,r6
    	ASHL	r3,(r2),r5
    	BICL3	r6,r5,(r4)
    	RET
set_shift_result:
    	MOVL	(r2),(r4)
    	RET
shift_rt_lu$:
    	BRW	shift_count_negative


;******************************************************************************
;
;	P  O  W  E  R
;
;******************************************************************************


; Power of Operators
;
power_w_w:
    	MOVZWL	(r3),-(SP)
    	MOVZWL	(r2),-(SP)
    	CALLS	#2,G^OTS$POWII
    	MOVW	r0,(r4)
    	RET

power_l_l:
    	PUSHL	(r3)
    	PUSHL	(r2)
    	CALLS	#2,G^OTS$POWJJ
    	MOVL	r0,(r4)
    	RET

power_f_l:
    	MOVL	(r3),-(SP)
    	MOVF	(r2),-(SP)
    	CALLS	#2,G^OTS$POWRJ
    	MOVF	r0,(r4)
    	RET

power_d_l:
    	MOVL	(r3),-(SP)
    	MOVD	(r2),-(SP)
    	CALLS	#3,G^OTS$POWDJ
    	MOVD	r0,(r4)
    	RET

power_g_l:
    	MOVL	(r3),-(SP)
    	MOVG	(r2),-(SP)
    	CALLS	#3,G^OTS$POWGJ
    	MOVG	r0,(r4)
    	RET

power_h_l:
    	MOVL	(r3),-(SP)
    	MOVH	(r2),-(SP)
    	CALLS	#5,G^OTS$POWHJ_R3
    	MOVH	r0,(r4)
    	RET

; Note that any time a library routine is called, the imaginary portion	;KG001
; of the real number must be pushed on the stack before the real part.	;KG001

power_fc_l:
    	MOVL	(r3),-(SP)
    	MOVF	4(r2),-(SP)						;KG001
    	MOVF	(r2),-(SP)						;KG001
    	CALLS	#3,G^OTS$POWCJ
    	MOVF	r0,(r4)
    	MOVF	r1,4(r4)
    	RET

power_dc_l:
    	MOVL	(r3),-(SP)
    	MOVD	8(r2),-(SP)						;KG001
    	MOVD	(r2),-(SP)						;KG001
    	CALLS	#5,G^OTS$POWCDJ_R3
    	MOVD	r0,(r4)
    	MOVD	r2,8(r4)
    	RET

power_gc_l:
    	MOVL	(r3),-(SP)
    	MOVG	8(r2),-(SP)						;KG001
    	MOVG	(r2),-(SP)						;KG001
    	CALLS	#5,G^OTS$POWCGJ_R3
    	MOVG	r0,(r4)
    	MOVG	r2,8(r4)
    	RET

power_f_f:
    	MOVF	(r3),-(SP)
    	MOVF	(r2),-(SP)
    	CALLS	#2,G^OTS$POWRR
    	MOVF	r0,(r4)
    	RET

power_d_f:
    	MOVF	(r3),-(SP)
    	MOVD	(r2),-(SP)
    	CALLS	#3,G^OTS$POWDR
    	MOVD	r0,(r4)
    	RET

power_f_d:
    	MOVD	(r3),-(SP)
    	MOVF	(r2),-(SP)
    	CALLS	#3,G^OTS$POWRD
    	MOVD	r0,(r4)
    	RET

power_d_d:
    	MOVD	(r3),-(SP)
    	MOVD	(r2),-(SP)
    	CALLS	#4,G^OTS$POWDD
    	MOVD	r0,(r4)
    	RET

power_g_g:
    	MOVG	(r3),-(SP)
    	MOVG	(r2),-(SP)
    	CALLS	#4,G^OTS$POWGG
    	MOVG	r0,(r4)
    	RET

power_h_h:
    	MOVH	(r3),-(SP)
    	MOVH	(r2),-(SP)
    	CALLS	#8,G^OTS$POWHH_R3
    	MOVH	r0,(r4)
    	RET

power_fc_fc:
    	MOVF	4(r3),-(SP)
	MOVF	(r3),-(SP)
	MOVF	4(r2),-(SP)
	BEQL	1$			; Check if the first operand=0	;KG001
    	MOVF	(r2),-(SP)
2$:    	CALLS	#4,G^OTS$POWCC						;KG001
    	MOVF	r0,(r4)
    	MOVF	r1,4(r4)
    	RET

1$:	MOVF	(r2),-(SP)		; Check the second		;KG001
	BNEQ	2$			; Are both = 0?			;KG001
	MOVAF	8(SP),SP		; Yes, get rid of args.		;KG001
	PUSHL	#dbg$_undexpn		; Signal Undefined Exp.		;KG001
	CALLS	#1,G^LIB$SIGNAL		; Signal it			;KG001
	RET				; And exit			;KG001

power_dc_dc:
    	MOVD	8(r3),-(SP)		; Push imaginary part first	;KG001
	MOVD	(r3),-(SP)		; Push the real part last	;KG001
    	MOVD	8(r2),-(SP)						;KG001
	BEQL	1$			; Check if first op=0		;KG001
    	MOVD	(r2),-(SP)						;KG001
2$:    	CALLS	#8,G^OTS$POWCDCD_R3					;KG001
    	MOVD	r0,(r4)
    	MOVD	r2,8(r4)
    	RET

1$:	MOVD	(r2),-(SP)		; Same as F, almost		;KG001
	BNEQ	2$							;KG001
	MOVAD	8(SP),SP						;KG001
	PUSHL	#dbg$_undexpn						;KG001
	CALLS	#1,G^LIB$SIGNAL						;KG001
	RET								;KG001

power_gc_gc:
    	MOVG	8(r3),-(SP)		; See comments for FC&DC	;KG001
    	MOVG	(r3),-(SP)						;KG001
	MOVG	8(r2),-(SP)						;KG001
	BEQL	1$							;KG001
    	MOVG	(r2),-(SP)						;KG001
2$:    	CALLS	#8,G^OTS$POWCGCG_R3					;KG001
    	MOVG	r0,(r4)
    	MOVG	r2,8(r4)
    	RET

1$:	MOVG	(r2),-(SP)						;KG001
	BNEQ	2$							;KG001
	MOVAG	8(SP),SP						;KG001
	PUSHL	#dbg$_undexpn						;KG001
	CALLS	#1,G^LIB$SIGNAL						;KG001
	RET								;KG001


;******************************************************************************
;
;	C  H  A  R    AND    B  I  T    S  T  R  I  N  G
;
;******************************************************************************


; Concatenation
;
concat_t_t:
    	PUSHL	arg2_desc
    	PUSHL	arg1_desc
    	PUSHL	result_desc
    	CALLS	#3,G^STR$CONCAT
  	CMPL	r0,#ss$_normal
    	BNEQ	concat_t$
  	RET
concat_t$:
    	MOVZWL  @arg1_desc,r1
    	MOVZWL  @arg2_desc,r2
    	MOVZWL  @result_desc,r3
    	ADDL2	r1,r2
    	CMPL	r2,r3
    	BLEQ    concat_ok$
    	BRW     string_truncate
concat_ok$:
    	RET

eql_vt_vt:
    	CMPW	(r2),(r3)
    	BEQL	eql_t_t
    	PUSHL	#dbg$_strngpad
    	CALLS	#1,G^LIB$SIGNAL
eql_t_t:
    	MOVL	#1,(r4)
    	PUSHL	arg2_desc
    	PUSHL	arg1_desc
    	CALLS	#2,G^STR$COMPARE
    	TSTL	r0
    	BEQL	eql_t$
    	CLRL	(r4)
eql_t$:
	BRW	branch_ret


geq_vt_vt:
    	CMPW	(r2),(r3)
    	BEQL	geq_t_t
    	PUSHL	#dbg$_strngpad
    	CALLS	#1,G^LIB$SIGNAL
geq_t_t:
    	MOVL	#1,(r4)
    	PUSHL	arg2_desc
    	PUSHL	arg1_desc
    	CALLS	#2,G^STR$COMPARE
    	TSTL	r0
    	BGEQ	geq_t$
    	CLRL	(r4)
geq_t$:
	BRW	branch_ret

gtr_vt_vt:
    	CMPW	(r2),(r3)
    	BEQL	gtr_t_t
    	PUSHL	#dbg$_strngpad
    	CALLS	#1,G^LIB$SIGNAL
gtr_t_t:
    	MOVL	#1,(r4)
    	PUSHL	arg2_desc
    	PUSHL	arg1_desc
    	CALLS	#2,G^STR$COMPARE
    	TSTL	r0
    	BGTR	gtr_t$
    	CLRL	(r4)
gtr_t$:
	BRW	branch_ret


leq_vt_vt:
    	CMPW	(r2),(r3)
    	BEQL	leq_t_t
    	PUSHL	#dbg$_strngpad
    	CALLS	#1,G^LIB$SIGNAL
leq_t_t:
    	MOVL	#1,(r4)
    	PUSHL	arg2_desc
    	PUSHL	arg1_desc
    	CALLS	#2,G^STR$COMPARE
    	TSTL	r0
    	BLEQ	leq_t$
    	CLRL	(r4)
leq_t$:
	BRW	branch_ret


lss_vt_vt:
    	CMPW	(r2),(r3)
    	BEQL	lss_t_t
    	PUSHL	#dbg$_strngpad
    	CALLS	#1,G^LIB$SIGNAL
lss_t_t:
    	MOVL	#1,(r4)
    	PUSHL	arg2_desc
    	PUSHL	arg1_desc
    	CALLS	#2,G^STR$COMPARE
    	TSTL	r0
    	BLSS	lss_t$
    	CLRL	(r4)
lss_t$:
	BRW	branch_ret


neq_vt_vt:
    	CMPW	(r2),(r3)
    	BEQL	neq_t_t
    	PUSHL	#dbg$_strngpad
    	CALLS	#1,G^LIB$SIGNAL
neq_t_t:
    	CLRL	(r4)
    	PUSHL	arg2_desc
    	PUSHL	arg1_desc
    	CALLS	#2,G^STR$COMPARE
    	TSTL	r0
    	BEQL	neq_t$
    	MOVL	#1,(r4)
neq_t$:
	BRW	branch_ret


;******************************************************************************
;
;	E  Q  L    and    N  E  Q
;
;******************************************************************************


; Equality Operators
;
eql_b_b:
    	CLRL	(r4)
    	CMPB	(r2),(r3)
    	BNEQ	eql_b$
    	MOVL	#1,(r4)
eql_b$:
    	BRW	branch_ret

eql_w_w:
    	CLRL	(r4)
    	CMPW	(r2),(r3)
    	BNEQ	eql_w$
    	MOVL	#1,(r4)
eql_w$:
    	BRW	branch_ret

eql_l_l:
    	CLRL	(r4)
    	CMPL	(r2),(r3)
    	BNEQ	eql_l$
    	MOVL	#1,(r4)
eql_l$:
    	BRW	branch_ret

eql_f_f:
    	CLRL	(r4)
    	CMPF	(r2),(r3)
    	BNEQ	eql_f$
    	MOVL	#1,(r4)
eql_f$:
    	BRW	branch_ret

eql_d_d:
    	CLRL	(r4)
    	CMPD	(r2),(r3)
    	BNEQ	eql_d$
    	MOVL	#1,(r4)
eql_d$:
    	BRW	branch_ret

eql_g_g:
    	CLRL	(r4)
    	CMPG	(r2),(r3)
    	BNEQ	eql_g$
    	MOVL	#1,(r4)
eql_g$:
    	BRW	branch_ret

eql_h_h:
    	CLRL	(r4)
    	CMPH	(r2),(r3)
    	BNEQ	eql_h$
    	MOVL	#1,(r4)
eql_h$:
    	BRW	branch_ret

eql_fc_fc:
    	CLRL	(r4)
    	CMPF	(r2),(r3)
    	BNEQ	eql_fc$	
    	CMPF	4(r2),4(r3)
    	BNEQ	eql_fc$
    	MOVL	#1,(r4)
eql_fc$:
    	BRW	branch_ret

eql_dc_dc:
    	CLRL	(r4)
    	CMPD	(r2),(r3)
    	BNEQ	eql_dc$	
    	CMPD	8(r2),8(r3)
    	BNEQ	eql_dc$
    	MOVL	#1,(r4)
eql_dc$:
    	BRW	branch_ret

eql_gc_gc:
    	CLRL	(r4)
    	CMPG	(r2),(r3)
    	BNEQ	eql_gc$	
    	CMPG	8(r2),8(r3)
    	BNEQ	eql_gc$
    	MOVL	#1,(r4)
eql_gc$:
    	BRW	branch_ret

eql_hc_hc:
    	CLRL	(r4)
    	CMPH	(r2),(r3)
    	BNEQ	eql_hc$	
    	CMPH	16(r2),16(r3)
    	BNEQ	eql_hc$
    	MOVL	#1,(r4)
eql_hc$:
    	BRW	branch_ret


neq_b_b:
    	CLRL	(r4)
    	CMPB	(r2),(r3)
    	BEQL	neq_b$
    	MOVL	#1,(r4)
neq_b$:
    	BRW	branch_ret

neq_w_w:
    	CLRL	(r4)
    	CMPW	(r2),(r3)
    	BEQL	neq_w$
    	MOVL	#1,(r4)
neq_w$:
    	BRW	branch_ret

neq_l_l:
    	CLRL	(r4)
    	CMPL	(r2),(r3)
    	BEQL	neq_l$
    	MOVL	#1,(r4)
neq_l$:
    	BRW	branch_ret

neq_f_f:
    	CLRL	(r4)
    	CMPF	(r2),(r3)
    	BEQL	neq_f$
    	MOVL	#1,(r4)
neq_f$:
    	BRW	branch_ret

neq_d_d:
    	CLRL	(r4)
    	CMPD	(r2),(r3)
    	BEQL	neq_d$
    	MOVL	#1,(r4)
neq_d$:
    	BRW	branch_ret

neq_g_g:
    	CLRL	(r4)
    	CMPG	(r2),(r3)
    	BEQL	neq_g$
    	MOVL	#1,(r4)
neq_g$:
    	BRW	branch_ret

neq_h_h:
    	CLRL	(r4)
    	CMPH	(r2),(r3)
    	BEQL	neq_h$
    	MOVL	#1,(r4)
neq_h$:
    	BRW	branch_ret

neq_fc_fc:
    	CMPF	(r2),(r3)
    	BNEQ	test_imaginaryf
    	CLRL	(r4)
test_imaginaryf:	
    	CMPF	4(r2),4(r3)
    	BEQL	neq_fc$
    	MOVL	#1,(r4)
neq_fc$:
    	BRW	branch_ret

neq_dc_dc:
    	CMPD	(r2),(r3)
    	BNEQ	test_imaginaryd
    	CLRL	(r4)
test_imaginaryd:	
    	CMPD	8(r2),8(r3)
    	BEQL	neq_dc$
    	MOVL	#1,(r4)
neq_dc$:
    	BRW	branch_ret

neq_gc_gc:
    	CMPG	(r2),(r3)
    	BNEQ	test_imaginaryg	
    	CLRL	(r4)
test_imaginaryg:
    	CMPG	8(r2),8(r3)
    	BEQL	neq_gc$
    	MOVL	#1,(r4)
neq_gc$:
    	BRW	branch_ret

neq_hc_hc:
    	CMPH	(r2),(r3)
    	BNEQ	test_imaginaryh
    	CLRL	(r4)
test_imaginaryh:	
    	CMPH	16(r2),16(r3)
    	BEQL	neq_hc$
    	MOVL	#1,(r4)
neq_hc$:
    	BRW	branch_ret


;******************************************************************************
;
;	G  E  Q    and    G  T  R    and    L  E  Q    and     L  S  S
;
;******************************************************************************


; Relational Operators
;
geq_b_b:
    	MOVL	#1,(r4)
    	CMPB	(r2),(r3)
    	BGEQ	geq_b$
    	CLRL	(r4)
geq_b$:
    	BRW	branch_ret

geq_w_w:
    	MOVL	#1,(r4)
    	CMPW	(r2),(r3)
    	BGEQ	geq_w$
    	CLRL	(r4)
geq_w$:
    	BRW	branch_ret

geq_l_l:
    	MOVL	#1,(r4)
    	CMPL	(r2),(r3)
    	BGEQ	geq_l$
    	CLRL	(r4)
geq_l$:
    	BRW	branch_ret

geq_lu_lu:
    	MOVL	#1,(r4)
    	CMPL	(r2),(r3)
    	BGEQU	geq_lu$
    	CLRL	(r4)
geq_lu$:
    	BRW	branch_ret

geq_f_f:
    	MOVL	#1,(r4)
    	CMPF	(r2),(r3)
    	BGEQ	geq_f$
    	CLRL	(r4)
geq_f$:
    	BRW	branch_ret

geq_d_d:
    	MOVL	#1,(r4)
    	CMPD	(r2),(r3)
    	BGEQ	geq_d$
    	CLRL	(r4)
geq_d$:
    	BRW	branch_ret

geq_g_g:
    	MOVL	#1,(r4)
    	CMPG	(r2),(r3)
    	BGEQ	geq_g$
    	CLRL	(r4)
geq_g$:
    	BRW	branch_ret

geq_h_h:
    	MOVL	#1,(r4)
    	CMPH	(r2),(r3)
    	BGEQ	geq_h$
    	CLRL	(r4)
geq_h$:
    	BRW	branch_ret


gtr_b_b:
    	MOVL	#1,(r4)
    	CMPB	(r2),(r3)
    	BGTR	gtr_b$
    	CLRL	(r4)
gtr_b$:
    	BRW	branch_ret

gtr_w_w:
    	MOVL	#1,(r4)
    	CMPW	(r2),(r3)
    	BGTR	gtr_w$
    	CLRL	(r4)
gtr_w$:
    	BRW	branch_ret

gtr_l_l:
    	MOVL	#1,(r4)
    	CMPL	(r2),(r3)
    	BGTR	gtr_l$
    	CLRL	(r4)
gtr_l$:
    	BRW	branch_ret

gtr_lu_lu:
    	MOVL	#1,(r4)
    	CMPL	(r2),(r3)
    	BGTRU	gtr_lu$
    	CLRL	(r4)
gtr_lu$:
    	BRW	branch_ret

gtr_f_f:
    	MOVL	#1,(r4)
    	CMPF	(r2),(r3)
    	BGTR	gtr_f$
    	CLRL	(r4)
gtr_f$:
    	BRW	branch_ret

gtr_d_d:
    	MOVL	#1,(r4)
    	CMPD	(r2),(r3)
    	BGTR	gtr_d$
    	CLRL	(r4)
gtr_d$:
    	BRW	branch_ret

gtr_g_g:
    	MOVL	#1,(r4)
    	CMPG	(r2),(r3)
    	BGTR	gtr_g$
    	CLRL	(r4)
gtr_g$:
    	BRW	branch_ret

gtr_h_h:
    	MOVL	#1,(r4)
    	CMPH	(r2),(r3)
    	BGTR	gtr_h$
    	CLRL	(r4)
gtr_h$:
    	BRW	branch_ret


leq_b_b:
    	MOVL	#1,(r4)
    	CMPB	(r2),(r3)
    	BLEQ	leq_b$
    	CLRL	(r4)
leq_b$:
    	BRW	branch_ret

leq_w_w:
    	MOVL	#1,(r4)
    	CMPW	(r2),(r3)
    	BLEQ	leq_w$
    	CLRL	(r4)
leq_w$:
    	BRW	branch_ret

leq_l_l:
    	MOVL	#1,(r4)
    	CMPL	(r2),(r3)
    	BLEQ	leq_l$
    	CLRL	(r4)
leq_l$:
    	BRW	branch_ret

leq_lu_lu:
    	MOVL	#1,(r4)
    	CMPL	(r2),(r3)
    	BLEQU	leq_lu$
    	CLRL	(r4)
leq_lu$:
    	BRW	branch_ret

leq_f_f:
    	MOVL	#1,(r4)
    	CMPF	(r2),(r3)
    	BLEQ	leq_f$
    	CLRL	(r4)
leq_f$:
    	BRW	branch_ret

leq_d_d:
    	MOVL	#1,(r4)
    	CMPD	(r2),(r3)
    	BLEQ	leq_d$
    	CLRL	(r4)
leq_d$:
    	BRW	branch_ret

leq_g_g:
    	MOVL	#1,(r4)
    	CMPG	(r2),(r3)
    	BLEQ	leq_g$
    	CLRL	(r4)
leq_g$:
    	BRW	branch_ret

leq_h_h:
    	MOVL	#1,(r4)
    	CMPH	(r2),(r3)
    	BLEQ	leq_h$
    	CLRL	(r4)
leq_h$:
    	BRW	branch_ret


lss_b_b:
    	MOVL	#1,(r4)
    	CMPB	(r2),(r3)
    	BLSS	lss_b$
    	CLRL	(r4)
lss_b$:
    	BRW	branch_ret

lss_w_w:
    	MOVL	#1,(r4)
    	CMPW	(r2),(r3)
    	BLSS	lss_w$
    	CLRL	(r4)
lss_w$:
    	BRW	branch_ret

lss_l_l:
    	MOVL	#1,(r4)
    	CMPL	(r2),(r3)
    	BLSS	lss_l$
    	CLRL	(r4)
lss_l$:
    	BRW	branch_ret

lss_lu_lu:
    	MOVL	#1,(r4)
    	CMPL	(r2),(r3)
    	BLSSU	lss_lu$
    	CLRL	(r4)
lss_lu$:
    	BRW	branch_ret

lss_f_f:
    	MOVL	#1,(r4)
    	CMPF	(r2),(r3)
    	BLSS	lss_f$
    	CLRL	(r4)
lss_f$:
    	BRW	branch_ret

lss_d_d:
    	MOVL	#1,(r4)
    	CMPD	(r2),(r3)
    	BLSS	lss_d$
    	CLRL	(r4)
lss_d$:
    	BRW	branch_ret

lss_g_g:
    	MOVL	#1,(r4)
    	CMPG	(r2),(r3)
    	BLSS	lss_g$
    	CLRL	(r4)
lss_g$:
    	BRW	branch_ret

lss_h_h:
    	MOVL	#1,(r4)
    	CMPH	(r2),(r3)
    	BLSS	lss_h$
    	CLRL	(r4)
lss_h$:
    	BRW	branch_ret

    	

;******************************************************************************
;
;	B  I  T  W  I  S  E     A  N  D    and     E  Q  V   and    N  O  T
;                               O  R       and     X  O  R   and    I  M  P
;
;******************************************************************************


; Bitwise Operators
;
bit_and_b_b:
    	MCOMB	(r3),r3			; AND
    	BICB3	r3,(r2),(r4)
    	RET
bit_and_w_w:
    	MCOMW	(r3),r3
    	BICB3	r3,(r2),(r4)
    	RET
bit_and_l_l:
    	MCOML	(r3),r3
    	BICL3	r3,(r2),(r4)
    	RET

bit_eqv_b_b:
    	MCOMB	(r3),r3			; EQV
    	XORB3	r3,(r2),(r4)
    	RET

bit_eqv_w_w:
    	MCOMW	(r3),r3
    	XORW3	r3,(r2),(r4)
    	RET

bit_eqv_l_l:
    	MCOML	(r3),r3
    	XORL3	r3,(r2),(r4)
    	RET

bit_not_b:
    	MCOMB	(r2),(r4)
    	RET
bit_not_w:
    	MCOMW	(r2),(r4)
    	RET
bit_not_l:				
    	MCOML	(r2),(r4)		; ~E in C
    	RET

bit_or_b_b:
    	BISB3	(r3),(r2),(r4)		; OR
    	RET
bit_or_w_w:
    	BISW3	(r3),(r2),(r4)
    	RET
bit_or_l_l:
    	BISL3	(r3),(r2),(r4)
    	RET

bit_xor_b_b:
    	XORB3	(r3),(r2),(r4)		; XOR, NEQV
    	RET
bit_xor_w_w:
    	XORW3	(r3),(r2),(r4)
    	RET
bit_xor_l_l:
    	XORL3	(r3),(r2),(r4)
    	RET
bit_imp_b_b:
	MCOMB	(r2), r2
	BISB3	r2, (r3), (r4)
	RET
bit_imp_w_w:
	MCOMW	(r2), r2
	BISW3	r2, (r3), (r4)
	RET
bit_imp_l_l:
	MCOML	(r2), r2
	BISL3 	r2, (r3), (r4)
	RET


;******************************************************************************
;
;	L  O  G  I  C  A  L    A  N  D    and    N  O  T    and    O  R
;
;******************************************************************************


; Logical Operators
;
and_b_b:
    	TSTB	(r2)			; AND
    	BEQL	set_and_result
    	TSTB	(r3)
    	BEQL	set_and_result
    	MOVL	#1,(r4)
    	RET
and_w_w:
    	TSTW	(r2)
    	BEQL	set_and_result
    	TSTW	(r3)
    	BEQL	set_and_result
    	MOVL	#1,(r4)
    	RET
and_l_l:
    	TSTL	(r2)
    	BEQL	set_and_result
    	TSTL	(r3)
    	BEQL	set_and_result
    	MOVL	#1,(r4)
    	RET
and_d_d:
    	TSTD	(r2)
    	BEQL	set_and_result
    	TSTD	(r3)
    	BEQL	set_and_result
    	MOVL	#1,(r4)
    	RET
set_and_result:
    	CLRL	(r4)
    	RET


not_b:
    	TSTB	(r2)
    	BEQL	set_not_result
    	CLRL	(r4)
    	RET
not_w:
    	TSTW	(r2)
    	BEQL	set_not_result
    	CLRL	(r4)
    	RET
not_l:
    	TSTL	(r2)
    	BEQL	set_not_result
    	CLRL	(r4)
    	RET
not_d:
    	TSTD	(r2)
    	BEQL	set_not_result
    	CLRL	(r4)
    	RET
set_not_result:
    	MOVL	#1,(r4)
    	RET

or_b_b:
    	TSTB	(r2)			; OR
    	BNEQ	set_or_result
    	TSTB	(r3)
    	BNEQ	set_or_result
    	CLRL	(r4)
    	RET
or_w_w:
    	TSTW	(r2)
    	BNEQ	set_or_result
    	TSTW	(r3)
    	BNEQ	set_or_result
    	CLRL	(r4)
    	RET
or_l_l:
    	TSTL	(r2)
    	BNEQ	set_or_result
    	TSTL	(r3)
    	BNEQ	set_or_result
    	CLRL	(r4)
    	RET

or_d_d:
    	TSTD	(r2)
    	BNEQ	set_or_result
    	TSTD	(r3)
    	BNEQ	set_or_result
    	CLRL	(r4)
    	RET

set_or_result:
    	MOVL	#1,(r4)
    	RET

xor_l_l:
    	TSTL	(r2)
    	BEQL	xor_l_l_1$
    	TSTL	(r3)
    	BEQL	set_xor_result
    	CLRL	(r4)
    	RET
xor_l_l_1$:
    	TSTL	(R3)
    	BNEQ	set_xor_result
    	CLRL	(r4)
    	RET
set_xor_result:
    	MOVL	#1,(r4)
    	RET	    	

;******************************************************************************
;
;	U  N  A  R  Y    M  I  N  U  S    and    P  L  U  S
;
;******************************************************************************


; Negating Arithmetic
;
unary_minus_b:
    	MNEGB	(r2),(r4)
    	BVS	umb$
    	RET
umb$:
    	BRW	int_overflow

unary_minus_w:
    	MNEGW	(r2),(r4)
    	BVS	umw$
    	RET
umw$:
    	BRW	int_overflow

unary_minus_l:
    	MNEGL	(r2),(r4)
    	BVS	uml$
    	RET
uml$:
    	BRW	int_overflow
 
unary_minus_lu:
    	SUBL3	(r2),#^XFFFF,(r4)	; The negative of an unsigned quantity
    	RET				; is computed by subtracting its value
    					; from 2**32 in C.
unary_minus_f:
    	MNEGF	(r2),(r4)
    	RET
unary_minus_d:
    	MNEGD	(r2),(r4)
    	RET
unary_minus_g:
    	MNEGG	(r2),(r4)
    	RET
unary_minus_h:
    	MNEGH	(r2),(r4)
    	RET

unary_minus_fc:
    	MNEGF	(r2),(r4)
    	MNEGF	4(r2),4(r4)
    	RET
unary_minus_dc:
    	MNEGD	(r2),(r4)
    	MNEGD	8(r2),8(r4)
    	RET
unary_minus_gc:
    	MNEGG	(r2),(r4)
    	MNEGG	8(r2),8(r4)
    	RET
unary_minus_hc:
    	MNEGH	(r2),(r4)
    	MNEGH	16(r2),16(r4)
    	RET


; Move a scalar quantity
;
unary_plus_b:
    	MOVB	(r2),(r4)
    	RET
unary_plus_w:
    	MOVW	(r2),(r4)
    	RET
unary_plus_l:
    	MOVL	(r2),(r4)
    	RET

unary_plus_f:
    	MOVF	(r2),(r4)
    	RET
unary_plus_d:
    	MOVD	(r2),(r4)
    	RET
unary_plus_g:
    	MOVG	(r2),(r4)
    	RET
unary_plus_h:
    	MOVH	(r2),(r4)
    	RET

unary_plus_fc:
    	MOVF	(r2),(r4)
    	MOVF	4(r2),4(r4)
    	RET
unary_plus_dc:
    	MOVD	(r2),(r4)
    	MOVD	8(r2),8(r4)
    	RET
unary_plus_gc:
    	MOVG	(r2),(r4)
    	MOVG	8(r2),8(r4)
    	RET
unary_plus_hc:
    	MOVH	(r2),(r4)
    	MOVH	16(r2),16(r4)
    	RET


;****************************************************************************
;
; A B S O L U T E   V A L U E
;
;****************************************************************************

abs_b:
    	TSTB	(r2)
    	BLSS	abs_b_negate
    	MOVB	(r2),(r4)
    	RET
abs_b_negate:
    	MNEGB	(r2),(r4)
    	RET

abs_w:
    	TSTW	(r2)
    	BLSS	abs_w_negate
    	MOVW	(r2),(r4)
    	RET
abs_w_negate:
    	MNEGW	(r2),(r4)
    	RET

abs_l:
    	TSTL	(r2)
    	BLSS	abs_l_negate
    	MOVL	(r2),(r4)
    	RET
abs_l_negate:
    	MNEGL	(r2),(r4)
    	RET

abs_f:
    	TSTF	(r2)
    	BLSS	abs_f_negate
    	MOVF	(r2),(r4)
    	RET
abs_f_negate:
    	MNEGF	(r2),(r4)
    	RET

abs_d:
    	TSTD	(r2)
    	BLSS	abs_d_negate
    	MOVD	(r2),(r4)
    	RET
abs_d_negate:
    	MNEGD	(r2),(r4)
    	RET

abs_g:
    	TSTG	(r2)
    	BLSS	abs_g_negate
    	MOVG	(r2),(r4)
    	RET
abs_g_negate:
    	MNEGG	(r2),(r4)
    	RET

abs_h:
    	TSTH	(r2)
    	BLSS	abs_b_negate
    	MOVH	(r2),(r4)
    	RET
abs_h_negate:
    	MNEGH	(r2),(r4)
    	RET




;******************************************************************************
;
;	D  E  R  E  F  E  R  E  N  C  I  N  G
;
;******************************************************************************


; Dereferencing Pointers
;
indirect_lu:
    	PUSHL	arg1_desc
    	CALLS	#1,dbg$bliss_indirection
    	MOVL	r0,(r4)
    	RET

; Indirection of a pointer in language C.
; We pass in the entire value descriptor (because the indirection
; needs to look at the typeid). The routine returns a new descriptor
; that represents the result of the indirection. We put a pointer
; to this new descriptor back into the RESULT_ADDR output parameter.
;
indirect_tptr:
    	PUSHL	arg1_valdesc
    	CALLS	#1,dbg$c_indirection
    	MOVL	r0,@result_addr(AP)
    	RET


;******************************************************************************
;
;	B  I  T    S  E  L  E  C  T  I  O  N
;
;******************************************************************************


; BLISS bit-select operator (X<p,s,e>)
;
bitselect:
    	PUSHL 	result_desc
    	PUSHL	arg1_desc
    	PUSHL	operator_entry(AP)
    	CALLS	#3,dbg$bliss_bitselect
    	RET


;******************************************************************************
;
;	S  E  T    
;
;******************************************************************************


; Difference of Two Sets
;
difference_set_set:
    	CLRL	r5
    	CLRL	r6
    	MOVW	@arg1_desc,r5
    	MOVW	@arg2_desc,r6
    	MOVW	@arg1_desc,@result_desc
    	MOVL	r4,r0
difference_set1$:
    	BICB3	(r3)+,(r2)+,(r0)+
    	DECL	r5
    	DECL	r6
    	TSTL	r5
    	BNEQ	difference_set2$
    	TSTL	r6
    	BNEQ	difference_set4$
    	BRB	difference_set_ret$
difference_set2$:
    	TSTL	r6
    	BNEQ	difference_set1$    	
difference_set3$:
    	BICB3	#^XFF,(r2)+,(r0)+
    	SOBGTR	r5,difference_set3$
    	BRB	difference_set_ret$
difference_set4$:
    	BICB3	(r3)+,#^XFF,(r0)+
    	SOBGTR	r6,difference_set4$
    	MOVW	@arg2_desc,@result_desc
difference_set_ret$:
    	RET


; Set Equal
;
eql_set_set:
    	CLRL	(r4)
    	CLRL	r5
    	CLRL	r6
    	MOVW	@arg1_desc,r5
    	MOVW	@arg2_desc,r6
eql_set1$:
    	CMPB	(r3)+,(r2)+
    	BNEQ	eql_set_ret$
    	DECL	r5
    	DECL	r6
    	TSTL	r5
    	BNEQ	eql_set2$
    	TSTL	r6
    	BNEQ	eql_set4$
    	MOVL	#1,(r4)
    	BRB	eql_set_ret$
eql_set2$:
    	TSTL	r6
    	BNEQ	eql_set1$
eql_set3$:
    	CMPB	#^X00,(r2)+
    	BNEQ	eql_set_ret$
    	SOBGTR	r5,eql_set3$
    	MOVL	#1,(r4)
    	BRB	eql_set_ret$
eql_set4$:
    	CMPB	(r3)+,#^X00
    	BNEQ	eql_set_ret$
    	SOBGTR	r6,eql_set4$
    	MOVL	#1,(r4)
eql_set_ret$:
    	RET


; Set B is a subset of Set A
;
geq_set_set:
    	CLRL	(r4)
    	CLRL	r5
    	CLRL	r6
    	MOVW	@arg1_desc,r6
    	MOVW	@arg2_desc,r5
    	MOVL	r2,r0
    	MOVL	r3,r2
    	MOVL	r0,r3
    	BRB	leq_set1$


; IN, C is an element of Set B
;
in_set_set:
    	EXTZV	(r2),#1,(r3),(r4)
    	BEQL	in_set$
    	MOVL	#1,(r4)
in_set$:
    	RET


; Intersection of Two Sets
;
intersect_set_set:
    	CLRL	r5
    	CLRL	r6
    	MOVW	@arg1_desc,r5
    	MOVW	@arg2_desc,r6
    	MOVW	@arg1_desc,@result_desc
    	MOVL	r4,r0
intersect_set1$:
    	MCOMB	(r3)+,r1
    	BICB3	r1,(r2)+,(r0)+
    	DECL	r5
    	DECL	r6
    	TSTL	r5
    	BNEQ	intersect_set2$
    	TSTL	r6
    	BNEQ	intersect_set4$
    	BRB	intersect_set_ret$
intersect_set2$:
    	TSTL	r6
    	BNEQ	intersect_set1$    	
intersect_set3$:
    	BICB3	#^X00,(r2)+,(r0)+
    	SOBGTR	r5,intersect_set3$
    	BRB	intersect_set_ret$
intersect_set4$:
    	BICB3	(r3)+,#^X00,(r0)+
    	SOBGTR	r6,intersect_set4$
    	MOVW	@arg2_desc,@result_desc
intersect_set_ret$:
    	RET


; Set A is a subset of Set B
;
leq_set_set:
    	CLRL	(r4)
    	CLRL	r5
    	CLRL	r6
    	MOVW	@arg1_desc,r5
    	MOVW	@arg2_desc,r6
leq_set1$:
    	BICB3	(r3)+,(r2)+,r0
    	TSTB    r0
    	BNEQ    leq_set_ret$
    	DECL	r5
    	DECL	r6
    	TSTL	r5
    	BNEQ	leq_set2$
    	TSTL	r6
    	BNEQ	leq_set4$
    	MOVL	#1,(r4)
    	BRB	leq_set_ret$
leq_set2$:
    	TSTL	r6
    	BNEQ	leq_set1$    	
leq_set3$:
    	BICB3	#^XFF,(r2)+,r0
    	TSTB	r0
    	BNEQ	leq_set_ret$
    	SOBGTR	r5,leq_set3$
    	MOVL	#1,(r4)
    	BRB	leq_set_ret$
leq_set4$:
    	BICB3	(r3)+,#^XFF,r0
    	SOBGTR	r6,leq_set4$
    	MOVL	#1,(r4)
leq_set_ret$:
    	RET


; Set Not Equal
;
neq_set_set:
    	CLRL	(r4)
    	CLRL	r5
    	CLRL	r6
    	MOVW	@arg1_desc,r5
    	MOVW	@arg2_desc,r6
    	CLRL	r0
    	CLRL	r1
    	MOVL	r5,r0
    	CMPL	r5,r6
    	BGEQ	neq_set1$
    	MOVL	r6,r0
neq_set1$:
    	CMPB	(r3)+,(r2)+
    	BNEQ	neq_set1_1$
    	INCL	r1
neq_set1_1$:
    	DECL	r5
    	DECL	r6
    	TSTL	r5
    	BNEQ	neq_set2$
    	TSTL	r6
    	BNEQ	neq_set4$
    	BRB	neq_set$
neq_set2$:
    	TSTL	r6
    	BNEQ	neq_set1$
neq_set3$:
    	CMPB	#^X00,(r2)+
    	BNEQ	neq_set3_1$
    	INCL	r1
neq_set3_1$:
    	SOBGTR	r5,neq_set3$
    	BRB	neq_set$
neq_set4$:
    	CMPB	(r3)+,#^X00
    	BNEQ	neq_set4_1$
    	INCL	r1
neq_set4_1$:
    	SOBGTR	r6,neq_set4$
neq_set$:
    	CMPL	r0,r1
    	BEQL	neq_set_ret$
    	MOVL	#1,(r4)
neq_set_ret$:
    	RET


; Union of Two Sets
;
union_set_set:
    	CLRL	r5
    	CLRL	r6
    	MOVW	@arg1_desc,r5
    	MOVW	@arg2_desc,r6
    	MOVW	@arg1_desc,@result_desc
    	MOVL	r4,r0
union_set1$:
    	BISB3	(r3)+,(r2)+,(r0)+
    	DECL	r5
    	DECL	r6
    	TSTL	r5
    	BNEQ	union_set2$
    	TSTL	r6
    	BNEQ	union_set4$
    	BRB	union_set_ret$
union_set2$:
    	TSTL	r6
    	BNEQ	union_set1$    	
union_set3$:
    	MOVB	(r2)+,(r0)+
    	SOBGTR	r5,union_set3$
    	BRB	union_set_ret$
union_set4$:
    	MOVB	(r3)+,(r0)+
    	SOBGTR	r6,union_set4$
    	MOVW	@arg2_desc,@result_desc
union_set_ret$:
    	RET

; C address-of operator.
; We pass in the entire value descriptor to the C_ADDRESS_OF routine,
; because it will need to look at the typeid. We also pass in a 
; pointer to the result value descriptor. This routine will fill
; in the result value descriptor.
;
address_l:
    	PUSHL	result_valdesc
    	PUSHL	arg1_valdesc
    	CALLS	#2,dbg$c_address_of
    	RET
    	

; C SIZEOF operator
; Pass in the entire value descriptor to the C_SIZEOF routine. (It will
; have to look at the typeid.) This routine will return the size in R0.
;
sizeof_l:
    	PUSHL	arg1_valdesc
    	CALLS	#1,dbg$c_sizeof
    	MOVL	r0,(r4)
    	RET

; Addition of typed pointer and integer in C.
;
add_tptr_l:
    	PUSHL	result_valdesc
    	PUSHL	arg2_valdesc
    	PUSHL	arg1_valdesc
    	CALLS	#3,dbg$c_add_tptr_l
    	RET

; Subtraction of typed pointer and integer in C.
;
sub_tptr_l:
    	PUSHL	result_valdesc
    	PUSHL	arg2_valdesc
    	PUSHL	arg1_valdesc
    	CALLS	#3,dbg$c_sub_tptr_l
    	RET

; Subtraction of two typed pointers in C.
;
sub_tptr_tptr:
    	PUSHL	result_valdesc
    	PUSHL	arg2_valdesc
    	PUSHL	arg1_valdesc
    	CALLS	#3,dbg$c_sub_tptr_tptr
    	RET 

; increment and decrement in C (++X  X++  --X  X--)
;
pre_incr_l:
pre_incr_lu:
    	PUSHL	#dbg$_cpreincr
    	CALLS	#1,G^lib$signal
    	MOVL	(r2),(r4)
    	INCL	(r4)
    	RET	

pre_incr_d:
    	PUSHL	#dbg$_cpreincr
    	CALLS	#1,G^lib$signal
    	MOVD	(r2),(r4)
    	ADDD2	#1.,(r4)
    	RET

pre_incr_tptr:
    	PUSHL	#dbg$_cpreincr
    	CALLS	#1,G^lib$signal
    	PUSHL	arg1_valdesc
    	CALLS	#1,dbg$c_pre_incr_tptr
    	MOVL	r0,(r4)
    	RET 

post_incr_l:
post_incr_lu:
post_incr_tptr:
    	PUSHL	#dbg$_cpostincr
    	CALLS	#1,G^lib$signal
    	MOVL	(r2),(r4)
    	RET

post_incr_d:
    	PUSHL	#dbg$_cpostincr
    	CALLS	#1,G^lib$signal
    	MOVD	(r2),(r4)
    	RET

pre_decr_l:
pre_decr_lu:
    	PUSHL	#dbg$_cpredecr
    	CALLS	#1,G^lib$signal
    	MOVL	(r2),(r4)
    	DECL	(r4)
    	RET

pre_decr_d:
    	PUSHL	#dbg$_cpredecr
    	CALLS	#1,G^lib$signal
    	MOVD	(r2),(r4)
    	SUBD2	#1.,(r4)
    	RET

pre_decr_tptr:
    	PUSHL	#dbg$_cpredecr
    	CALLS	#1,G^lib$signal
    	PUSHL	arg1_valdesc
    	CALLS	#1,dbg$c_pre_decr_tptr
    	MOVL	r0,(r4)
    	RET 

post_decr_l:
post_decr_lu:
post_decr_tptr:
    	PUSHL	#dbg$_cpostdecr
    	CALLS	#1,G^lib$signal
    	MOVL	(r2),(r4)
    	RET

post_decr_d:
    	PUSHL	#dbg$_cpostdecr
    	CALLS	#1,G^lib$signal
    	MOVD	(r2),(r4)
    	RET

;******************************************************************************
;
;	P  A  C  K  E  D      D  E  C  I  M  A  L    
;
;******************************************************************************


; Subtraction
;
sub_p_p:
	MOVL	arg1_desc, r6				; Get left desc.
	MOVL	arg2_desc, r7				; Get right desc.
	MOVL	result_desc, r8				; Get result desc.
	MOVZWL	dsc$w_length(r7), r0
	ASHL	#-1, r0, r0				; Get position of sign.
	XORB2	#1, @dsc$a_pointer(r7)[r0]		; Change sign and add.
	BRB	addp$

; Addition.
;
add_p_p:
	MOVL	arg1_desc, r6				; Get left desc.
	MOVL	arg2_desc, r7				; Get right desc.
	MOVL	result_desc, r8				; Get result desc.
addp$:	MOVAB	-72(sp), sp				; Workspace.
	PUSHL	r6					; Strip leading/trailing
	CALLS	#1, dbg$strip_zeroes			; zeroes.
	PUSHL	r7					; Same again.
	CALLS	#1, dbg$strip_zeroes
	SUBB3	dsc$b_scale(r7), dsc$b_scale(r6), r5	; Get change of scale.
	BGEQ	1$					; OK if shorter fraction.
	MNEGB	r5, r5					; Else, reverse operands.
	XORL2	r6, r7
	XORL2	r7, r6
	XORL2	r6, r7
1$:	ADDB3	r5, dsc$w_length(r6), r0		; Get total # digits.
	SUBB3	r0, #30, r1				; Is length in range?
	BGEQ	2$
	ADDB2	r1, r5					; Too long.
	SUBB2	r1, dsc$b_scale(r7)			; Adjust scale.
	ASHP	r1, dsc$w_length(r7), @dsc$a_pointer(r7), #0, dsc$w_length(r7), (sp)
	MOVP	dsc$w_length(r7), (sp), @dsc$a_pointer(r7)
2$:	ASHP	r5, dsc$w_length(r6), @dsc$a_pointer(r6), #0, #31, (sp)
	ADDP6	dsc$w_length(r7), @dsc$a_pointer(r7), -
		#31, (sp), dsc$w_length(r8), @dsc$a_pointer(r8)
	MOVB	dsc$b_scale(r7), dsc$b_scale(r8)	; Copy scale.
	MOVB	#31, dsc$b_digits(r8)
	RET

; Multiplication.
;
mul_p_p:
	SUBL	#16, sp							; Work space.
	MOVL	arg1_desc, r6						; Get descriptors.
	MOVL	arg2_desc, r7
	MOVL	result_desc, r8
	PUSHL	r6							; Strip zeroes and adjust
	CALLS	#1, dbg$strip_zeroes					; length.
	PUSHL	r7
	CALLS	#1, dbg$strip_zeroes
	CLRL	r9
	CLRL	r10
	ADDW3	dsc$w_length(r6), dsc$w_length(r7), r9			; Estimate length of product.
	SUBW2	#31, r9							; Will product be > 31?
	BLEQ	mul_p$							; No.
	SUBW3	dsc$w_length(r7), dsc$w_length(r6), r10			; Yes.  Will have to truncate.
	BGEQ	1$							; Want longer operand in r6.
	MNEGW	r10, r10						; Switch operands.
	MOVL	r6, r1							
	MOVL	r7, r6
	MOVL	r1, r7
1$:	CMPW	r9, r10							; Algorithm employed:
	BLEQ	5$							;   (1) r9  = number of digits that need to be truncated
	SUBW2	r10, r9							;   (2) r10 = len(longer_operand) - len(other operand)
	INCW	r9							;   If r9 <= r10 then
	ASHL	#-1, r9, r9						;	(1) Shift longer operand -r9
	CVTWL	dsc$w_length(r7), r11					;	(2) Adjust length and scale
	SUBW2	r9, dsc$w_length(r7)					;	(3) MULP
	ADDB2	r9, dsc$b_scale(r7)					;   If r9 > r10 then
	MNEGW	r9, r2							;	(1) r9 <-- (r9-r10+1)/2
	ASHP	r2, r11, @dsc$a_pointer(r7), #0, dsc$w_length(r7), (sp) ;	(2) Shift longer operand -(r9+r10)
	MOVP	dsc$w_length(r7), (sp), @dsc$a_pointer(r7)		;	(3) Shift other operand -r9
	ADDW2	r10, r9							; 	(4) Adjust length and scale of both operands
5$:	CVTWL	dsc$w_length(r6), r11					;	(5) MULP
	SUBW2	r9, dsc$w_length(r6)					
	ADDB2	r9, dsc$b_scale(r6)					
	MNEGW	r9, r9
	ASHP	r9, r11, @dsc$a_pointer(r6), #0, dsc$w_length(r6), (sp)
	MOVP	dsc$w_length(r6), (sp), @dsc$a_pointer(r6)
mul_p$:
	ADDB3	dsc$b_scale(r6), dsc$b_scale(r7), dsc$b_scale(r8)	; Get final scale for result.
	MOVB	#31, dsc$b_digits(r8)					; Number of digits in result.
	CVTBW	dsc$b_digits(r8), dsc$w_length(r8)			; Fill in number of digits.
	MULP	dsc$w_length(r6), @dsc$a_pointer(r6), -			; Multiply and return.
		dsc$w_length(r7), @dsc$a_pointer(r7), -
		#31, @dsc$a_pointer(r8)
	RET

; Division.
;
div_p_p:
	SUBL	#16, sp							; Workspace.
	MOVL	arg1_desc, r6						; Get descriptors; strip
	MOVL	arg2_desc, r7						;    zeroes and adjust length and scale.
	MOVL	result_desc, r8
	PUSHL	r6
	CALLS	#1, dbg$strip_zeroes
	PUSHL	r7
	CALLS	#1, dbg$strip_zeroes
	SUBW3	dsc$w_length(r6), #31, r10				; Dividend must have length of 31.
	SUBB2	r10, dsc$b_scale(r6)					;    Adjust scale.
	ASHP	r10, dsc$w_length(r6), @dsc$a_pointer(r6), #0, #31, (sp);    Shift to make length 31.
	MOVP	#31, (sp), @dsc$a_pointer(r6)
	MOVW 	#31, dsc$w_length(r6)					;    Length is now 31.
	MOVW	#31, dsc$w_length(r8)					; Quotient precision = 31
	CVTWB 	dsc$w_length(r8), dsc$b_scale(r8)			; Number of digits in result.
	SUBB3	dsc$b_scale(r7), dsc$b_scale(r6), dsc$b_scale(r8)	; Estimate quotient scale.
	MOVZWL	dsc$w_length(r7), -(sp)					; Push all info onto the stack.
	PUSHL	#0
	MOVZWL	dsc$w_length(r8), -(sp)
	PUSHL	dsc$a_pointer(r8)
	MOVZWL	dsc$w_length(r7), -(sp)
	PUSHL	dsc$a_pointer(r7)
	PUSHL	dsc$a_pointer(r6)
	CALLS	#7, G^PLI$DIV_PK_LONG					; Do the division.
	RET


; Unary minus.
;
unary_minus_p:
	MOVL	arg1_desc, r6						; Get descriptors.
	MOVL	result_desc, r8
	MOVZWL	dsc$w_length(r6), r0
	ASHL	#-1, r0, r0						; Determine position of sign.
	XORB2	#1, @dsc$a_pointer(r6)[r0]				; Change sign and move to result
	BRB	unary_p$						;   descriptor.

; Unary plus.
;
unary_plus_p:
	MOVL	arg1_desc, r6						; Get descriptors.
	MOVL	result_desc, r8
unary_p$:
	PUSHL	r6							; Strip leading/trailing zeroes.
	CALLS	#1, dbg$strip_zeroes					
	MOVP	dsc$w_length(r6), @dsc$a_pointer(r6), @dsc$a_pointer(r8); Move to result descriptor.
	MOVW	dsc$w_length(r6), dsc$w_length(r8)			; Adjust length, scale, and #digits.
	MOVB	dsc$b_scale(r6), dsc$b_scale(r8)
	CVTWB	dsc$w_length(r8), dsc$b_digits(r8)
	RET

; EQL, NEQ, GTR, GEQ, LSS, and LEQ.
;
eql_p_p:
	MOVL	arg1_desc, r6						; Get descriptors.
	MOVL	arg2_desc, r7
	PUSHL	r6							; Strip leading/trailing
	CALLS	#1, dbg$strip_zeroes					; zeroes.
	PUSHL	r7							; Same again.
	CALLS	#1, dbg$strip_zeroes
	CLRL	(r4)							; Assume NEQ.
	CMPP4	dsc$w_length(r6), @dsc$a_pointer(r6), -			; Do the compare.  If successful,
		dsc$w_length(r7), @dsc$a_pointer(r7)			;   be sure to compare the scales also.
	BNEQ	eql_p$
	CMPB	dsc$b_scale(r6), dsc$b_scale(r7)
	BNEQ	eql_p$
	MOVL	#1, (r4)						; Success.
eql_p$:
	BRW	branch_ret

neq_p_p:
	MOVL	arg1_desc, r6						; Get descriptors.
	MOVL	arg2_desc, r7
	PUSHL	r6							; Strip leading/trailing
	CALLS	#1, dbg$strip_zeroes					; zeroes.
	PUSHL	r7							; Same again.
	CALLS	#1, dbg$strip_zeroes
	MOVL	#1, (r4)						; Assume NEQ.
	CMPP4	dsc$w_length(r6), @dsc$a_pointer(r6), -			; Do the compare; if successful, be
		dsc$w_length(r7), @dsc$a_pointer(r7)			;   sure to compare the scales.
	BNEQ	neq_p$
	CMPB	dsc$b_scale(r6), dsc$b_scale(r7)
	BNEQ	neq_p$
	CLRL	(r4)							; Failure.
neq_p$:
	BRW	branch_ret

gtr_p_p:
    	BSBW	setup_packed_numbers$
	MOVL	#1, (r4)						; Assume GTR.
	CMPP4	dsc$w_length(r6), @dsc$a_pointer(r6), -			; Scales were equal; compare actual strings.
		dsc$w_length(r7), @dsc$a_pointer(r7)
	BGTR	gtr_p$
	CLRL	(r4)							; Failure.
gtr_p$:
	BRW	branch_ret

geq_p_p:
    	BSBW	setup_packed_numbers$
	MOVL	#1, (r4)						; Assume GEQ.
	CMPP4	dsc$w_length(r6), @dsc$a_pointer(r6), -			; Scales were equal; compare actual strings.
		dsc$w_length(r7), @dsc$a_pointer(r7)
	BGEQ	geq_p$
	CLRL	(r4)							; Failure.
geq_p$:
	BRW	branch_ret

lss_p_p:
    	BSBW	setup_packed_numbers$
    	MOVL	#1, (r4)						; 
	CMPP4	dsc$w_length(r6), @dsc$a_pointer(r6), -			; Scales were equal; compare actual strings.
		dsc$w_length(r7), @dsc$a_pointer(r7)
	BLSS	lss_p$
	CLRL	(r4)							; Failure.
lss_p$:
	BRW	branch_ret

leq_p_p:
    	BSBW	setup_packed_numbers$
	MOVL	#1, (r4)						; Assume LEQ.
	CMPP4	dsc$w_length(r6), @dsc$a_pointer(r6), -			; Scales were equal; compare actual strings.
		dsc$w_length(r7), @dsc$a_pointer(r7)
	BLEQ	leq_p$
	CLRL	(r4)							; Failure.
leq_p$:
	BRW	branch_ret

setup_packed_numbers$:
    	CLRL	r8				; Use as a adjustment scale
    	CLRL	r9				; Use as a adjustment digits
	MOVL	arg1_desc, r6			; Get descriptors
	MOVL	arg2_desc, r7
	PUSHL	r6				; Strip leading/trailing
	CALLS	#1, dbg$strip_zeroes		;  zeroes
	PUSHL	r7				; Same again
	CALLS	#1, dbg$strip_zeroes
    	SUBB3	dsc$b_scale(r6),dsc$b_scale(r7),r8; See if they are scaled 
    						;   the same
    	TSTB	r8
    	BEQL	setup_packed_rsb$		; They are, simply return
    	BGTR	scale_arg2$			; Adjust the second operand
    						;  (first has larger scaling)
    	MNEGB	r8, r8				
    	BRB	scale_arg1$			; Adjust the first operand
    						;  (second has larger scaling)
scale_arg2$:
    	MOVL	arg2_desc, r6			; Use r6 to point to the 
    						;  operand needs adjustment
    						;  (the one has smaller scaling)
    	MOVL	arg1_desc, r7			; r7 points to the operand
    						;  has larger scaling
scale_arg1$:
    	ADDB3	dsc$b_digits(r6), r8, r9	; Update the total number of
    						;  digits
    	CMPB	r9, #31				; Check to see if this causes
    						;  overflow
    	BGTR	truncate_the_other$		; If we try to adjust the
    						;  smaller scale will cause
    						;  overflow, so We truncate the 
    						;  other scale instead
    	ASHP	r8, dsc$w_length(r6), @dsc$a_pointer(r6), -
    		#0, r9, operand
    	ASHP    #0, r9, operand, #0, r9, @dsc$a_pointer(r6)
    	MOVW	r9, dsc$w_length(r6)
    	MOVB	r9, dsc$b_digits(r6)
    	SUBB2	r8, dsc$b_scale(r6)
    	BRB	setup_packed_rsb$
truncate_the_other$:
    	DECB	r8				; Shift count
    	MOVZWL	dsc$w_length(r7), r10		; Get the length
    	DECW	r10				; Length
    	ASHP	#-1, dsc$w_length(r7), @dsc$a_pointer(r7), -
    		#0, r10, operand
    	ASHP    #0, r10, operand, #0, r10, @dsc$a_pointer(r7)
    	DECB	dsc$b_scale(r7)
    	TSTW	r10				; If we got done to zero
    						;  digit, then we are all done
    	BEQL	setup_packed_rsb$
    	MOVW	r10, dsc$w_length(r7)
    	MOVB	r10, dsc$b_digits(r7)
    	TSTB	r8
    	BNEQ	scale_arg1$	
setup_packed_rsb$:
    	MOVL	arg1_desc, r6
    	MOVL	arg2_desc, r7
    	RSB
    	

; PLI bit-string operations.
;
concat_tf_tf:
	BSBW	setup_pli_intrface$
    	MOVL    r4, r1    	
	PUSHAL	dope2
	PUSHL	r3
	PUSHAL	dope1
	PUSHL	r2
	CALLS	#4, G^PLI$CATBIT
	RET

eql_tf_tf:
	BSBW	setup_pli_intrface$
    	MOVL    #1, (r4)
	PUSHAL	dope2
	PUSHL	r3
	PUSHAL	dope1
	PUSHL	r2
	CALLS	#4, G^PLI$CMPBIT
    	TSTL	r0
    	BEQL    eql_tf$
    	CLRL    (r4)
eql_tf$:	
	BRW	branch_ret	

geq_tf_tf:
	BSBW	setup_pli_intrface$
    	MOVL	#1,(r4)
	PUSHAL	dope2
	PUSHL	r3
	PUSHAL	dope1
	PUSHL	r2
	CALLS	#4, G^PLI$CMPBIT
	TSTL	r0
	BEQL	geq_tf$
    	CMPL	r0, #^XFFFFFFFF
    	BNEQ	geq_tf$
	CLRL	(r4)
geq_tf$:
	BRW	branch_ret	

gtr_tf_tf:
	BSBW	setup_pli_intrface$
    	MOVL	#1,(r4)
	PUSHAL	dope2
	PUSHL	r3
	PUSHAL	dope1
	PUSHL	r2
	CALLS	#4, G^PLI$CMPBIT
    	TSTL	r0
    	BEQL    not_gtr$
	CMPL	r0, #^XFFFFFFFF
	BEQL	not_gtr$
    	BRB	gtr_tf$
not_gtr$:
	CLRL	(r4)
gtr_tf$:
	BRW	branch_ret	

leq_tf_tf:
	BSBW	setup_pli_intrface$
    	MOVL	#1,(r4)
	PUSHAL	dope2
	PUSHL	r3
	PUSHAL	dope1
	PUSHL	r2
	CALLS	#4, G^PLI$CMPBIT
	TSTL	r0
	BEQL	leq_tf$
    	CMPL	r0, #^XFFFFFFFF
    	BEQL	leq_tf$
	CLRL	(r4)
leq_tf$:
	BRW	branch_ret	

lss_tf_tf:
	BSBW	setup_pli_intrface$
    	MOVL	#1,(r4)
	PUSHAL	dope2
	PUSHL	r3
	PUSHAL	dope1
	PUSHL	r2
	CALLS	#4, G^PLI$CMPBIT
    	TSTL	r0
    	BEQL    not_lss$
	CMPL	r0, #^XFFFFFFFF
	BNEQ	not_lss$
    	BRB	lss_tf$
not_lss$:
	CLRL	(r4)
lss_tf$:
	BRW	branch_ret	

neq_tf_tf:
	BSBW	setup_pli_intrface$
    	MOVL	#1,(r4)
	PUSHAL	dope2
	PUSHL	r3
	PUSHAL	dope1
	PUSHL	r2
	CALLS	#4, G^PLI$CMPBIT
	TSTL	r0
	BNEQ	neq_tf$
	CLRL	(r4)
neq_tf$:
	BRW	branch_ret	

bit_not_tf_tf:
    	BSBW    setup_pli_intrface$
    	MOVL    r4, r1
	PUSHAL	dope1
	PUSHL	r2
	CALLS	#2, G^PLI$NOTBIT
	RET
	
bit_and_tf_tf:
	BSBW	setup_pli_intrface$
    	MOVL	r4, r1
	PUSHAL	dope2
	PUSHL	r3
	PUSHAL	dope1
	PUSHL	r2
	CALLS	#4, G^PLI$ANDBIT
	RET

bit_or_tf_tf:
	BSBW	setup_pli_intrface$
    	MOVL    r4, r1
	PUSHAL	dope2
	PUSHL	r3
	PUSHAL	dope1
	PUSHL	r2
	CALLS	#4, G^PLI$ORBIT
	RET


; This subroutine sets up the call interface required for the PL/I RTL 
; bit-string routines.  Those routines require the following for both
; operands:
;
;	    A dope vector of the form:
;
;	    +----------+---------------+
;	    |	Length | PLI data type |
;	    +----------+---------------+
;
;           DSC$K_DTYPE_V maps into DBG$K_PLI_ABIT,
;           DSC$K_DTYPE_VU maps into DBG$K_PLI_UBIT.
;
;	    Length is in bits.
;
setup_pli_intrface$:
        MOVL    arg1_desc, r2		; r2 points left vms descriptor
    	MOVW    dsc$w_length(r2), dope1+2; get length
    	CMPB    dsc$b_dtype(r2), #dsc$k_dtype_v
    	BEQL    setup_pli_abit1$
    	MOVW    #dbg$k_pli_ubit, dope1  ; map into pli data type
    	MOVAL	4(r2), r2		; Get the address of the 2nd longword
    					;  of the vms descriptor
        BRB     setup_pli_cont1$
setup_pli_abit1$:
        MOVW    #dbg$k_pli_abit, dope1  ; map into pli data type
    	MOVL	4(r2), r2		; Get the address of the left value
setup_pli_cont1$:
    	MOVL    right_arg(AP), r3       ; Get the address of the right arg
    	TSTL    r3                      ; Test to see if it is present
        BEQL    setup_pli_result$	; There is no right arg
    	MOVL    arg2_desc, r3		; r3 points right vms descriptor
    	MOVW    dsc$w_length(r3), dope2+2; get length
    	CMPB    dsc$b_dtype(r3), #dsc$k_dtype_v
    	BEQL    setup_pli_abit2$
    	MOVW    #dbg$k_pli_ubit, dope2  ; map into pli data type
    	MOVAL	4(r3), r3		; Get the address of the 2nd longword
    					;  of the vms descriptor
        BRB     setup_pli_result$
setup_pli_abit2$:
        MOVW    #dbg$k_pli_abit, dope2  ; map into pli data type
    	MOVL	4(r3), r3		; Get the address of the right value
setup_pli_result$:
        MOVL    result_desc, r4         ; r4 points to result vms descriptor
    	MOVL	4(r4), r4		; r4 points to the address of the result
setup_rsb$:
	RSB


; Record File Address data type, 6 bytes long.
;
eql_rfa_rfa:
    	CLRL	(r4)
    	CMPL	(r2),(r3)
    	BNEQ	eql_rfa$
    	CMPW	4(r2),4(r3)
    	BNEQ	eql_rfa$
    	MOVL	#1,(r4)
eql_rfa$:
    	BRW	branch_ret

neq_rfa_rfa:
    	CLRL	(r4)
    	CMPL	(r2),(r3)
    	BEQL	neq_rfa$
    	CMPW	4(r2),4(r3)
    	BEQL	neq_rfa$
    	MOVL	#1,(r4)
neq_rfa$:
    	BRW	branch_ret

unary_plus_q:
    	MOVQ	(r2),(r4)
    	BRW	branch_ret

unary_minus_q:
    	MCOML   (r2),(r4)
    	MCOML   4(r2),4(r4)
    	ADDL2   #1,(r4)
    	ADWC    #0,4(r4)
    	BRW     branch_ret

unary_plus_o:
    	MOVQ	(r2),(r4)
    	MOVQ    8(r2),8(r4)
    	BRW	branch_ret

unary_minus_o:
    	MCOML   (r2),(r4)
    	MCOML   4(r2),4(r4)
    	MCOML   8(r2),8(r4)
    	MCOML   12(r2),12(r4)
    	ADDL2   #1,(r4)
    	ADWC    #0,4(r4)
    	ADWC    #0,8(r4)
    	ADWC    #0,12(r4)
    	BRW     branch_ret

succ_enum:								;BB001
	PUSHL	result_valdesc						;BB001
	PUSHL	arg1_valdesc						;BB001
	CALLS	#2, dbg$succ_enum					;BB001
	RET								;BB001

pred_enum:								;BB001
	PUSHL	result_valdesc						;BB001
	PUSHL	arg1_valdesc						;BB001
	CALLS	#2, dbg$pred_enum					;BB001
	RET								;BB001

; The following handle operations on fixed binary.
;

unary_plus_fixed:
	PUSHL	result_valdesc
	PUSHL	arg1_valdesc
	CALLS	#2, dbg$unary_plus_fixed
    	RET

unary_minus_fixed:
	PUSHL	result_valdesc
	PUSHL	arg1_valdesc
	CALLS	#2, dbg$unary_minus_fixed
    	RET

abs_fixed:
	PUSHL	result_valdesc
	PUSHL	arg1_valdesc
	CALLS	#2, dbg$abs_fixed
    	RET

add_fixed_fixed:
	PUSHL	result_valdesc
	PUSHL	arg2_valdesc
	PUSHL	arg1_valdesc
	CALLS	#3, dbg$add_fixed_fixed
    	RET

sub_fixed_fixed:
	PUSHL	result_valdesc
	PUSHL	arg2_valdesc
	PUSHL	arg1_valdesc
	CALLS	#3, dbg$sub_fixed_fixed
    	RET

mul_fixed_fixed:
	PUSHL	result_valdesc
	PUSHL	arg2_valdesc
	PUSHL	arg1_valdesc
	CALLS	#3, dbg$mul_fixed_fixed
    	RET

div_fixed_fixed:
	PUSHL	result_valdesc
	PUSHL	arg2_valdesc
	PUSHL	arg1_valdesc
	CALLS	#3, dbg$div_fixed_fixed
    	RET

eql_fixed_fixed:
	PUSHL	result_valdesc
	PUSHL	arg2_valdesc
	PUSHL	arg1_valdesc
	CALLS	#3, dbg$eql_fixed_fixed
    	RET

neq_fixed_fixed:
	PUSHL	result_valdesc
	PUSHL	arg2_valdesc
	PUSHL	arg1_valdesc
	CALLS	#3, dbg$neq_fixed_fixed
    	RET

lss_fixed_fixed:
	PUSHL	result_valdesc
	PUSHL	arg2_valdesc
	PUSHL	arg1_valdesc
	CALLS	#3, dbg$lss_fixed_fixed
    	RET

gtr_fixed_fixed:
	PUSHL	result_valdesc
	PUSHL	arg2_valdesc
	PUSHL	arg1_valdesc
	CALLS	#3, dbg$gtr_fixed_fixed
    	RET

leq_fixed_fixed:
	PUSHL	result_valdesc
	PUSHL	arg2_valdesc
	PUSHL	arg1_valdesc
	CALLS	#3, dbg$leq_fixed_fixed
    	RET

geq_fixed_fixed:
	PUSHL	result_valdesc
	PUSHL	arg2_valdesc
	PUSHL	arg1_valdesc
	CALLS	#3, dbg$geq_fixed_fixed
    	RET

; No corresponding routine index to perform the given operation, signal
; debug internal coding error.
;
unknown_rout_index:
    	PUSHAL	errmsg
    	PUSHL	#1
    	PUSHL	#dbg$_interr
    	CALLS	#3,G^LIB$SIGNAL
    	RET

    	.SBTTL	dbg$strip_zeroes

;++
;GLOBAL ROUTINE dbg$strip_zeroes (VMS_DESC) =
;
; FUNCTION
;	This routine strips leading and trailing zeroes from a packed
;	decimal string.
;
; INPUTS
;	VMS_DESC - A pointer to a VMS descriptor.
;
; OUTPUTS
;	VMS_DESC is returned.
;++

; Register usage:
;
;	r0,r1   temporaries
;	r6	pointer to VMS descriptor
;	r7	number of decimal digits
;	r8	pointer to digit string
;	r9	index

.ENTRY	dbg$strip_zeroes, ^M<R2,R3,R4,R5,R6,R7,R8,R9>

	SUBL	#16,SP				; Local storage space
	MOVL	4(AP),R6			; Address of descriptor
	CVTWL	dsc$w_length(R6),R7		; Number of decimal digits
	MOVL	dsc$a_pointer(R6),R8		; Address of digit string
1$:	MOVP	R7,(R8),(SP)			; Copy decimal value to stack
	BEQL	5$				; Special check for zero
2$:	ASHL	#-1,R7,R9			; Get offset to sign byte
	BEQL	6$				; Leave at least one digit
	BITB	#^XF0,(SP)[R9]			; Test high nibble of sign byte
	BNEQ	3$				; Branch if no trailing zeros
	MOVL	R7,R0				; Get original number of digits
	DECL	R7				; Count length down by one
	INCB	dsc$b_scale(R6)			; Remember scaling has changed
	ASHP	#-1,R0,(SP),#0,R7,(R8)		; Scale number by one digit
	BRB	1$				; Go repeat test for zeros
3$:	ADDL3	#1,R9,R0			; Get number of bytes written
	SKPC	#0,R0,(SP)			; Find first non-zero byte
	DECL	R0				; Get <# of bytes> minus 1
	ASHL	#1,R0,R7			; Convert bytes to nibbles
	BITB	#^XF0,(R1)			; Check high nibble of byte
	BEQL	4$				; Ignore high nibble if zero
	INCL	R7				; Otherwise increase length
4$:	MOVP	R7,(R1),(R8)			; Copy over trailing digits
	BRB	6$
5$:	MOVL	#1,R7				; Special handling if result
	CLRB	dsc$b_scale(R6)			;  is zero - scale factor is
	MOVL	#^X0C,(R8)			;  zero and sign is positive
6$:	CVTLW	R7,dsc$w_length(R6)		; Set length in descriptor
	CVTLB	R7,dsc$b_digits(R6)		; Insure digit count is set up
    	MOVL	R6,R0
	RET					; All normalized - return

    	.SBTTL	trap_msg_handler
;++
;ROUTINE TRAP_MSG_HANDLER(SIGARG, MECHARG, ENBLARG): NOVALUE =
;
; FUNCTION
;	This is the handler routine for DBG$PERFORM_OPERATOR routine.  It traps
;	overflow (V), decimal overflow (DV), floating underflow (FU), and
;	give an informational message to the user program.  It also traps
;	the error condition such as divided by zero, or illegal operand type.
;
; INPUTS
;	SIGARG	- The signal argument vector.
;
;	MECHARG	- The mechanism argument vector.
;
;	ENBLARG	- The enable argument vector.
;
; OUTPUTS
;	None.
;++


; Register usage
;
;    	r2	Pointer to operator token entry
;	r3	Temporary

.ENTRY	trap_msg_handler,^M<r2,r3>

    	MOVL	chf$l_sigarglst(AP),r0	; Pointer to Signal Arguments
    	MOVL	chf$l_mcharglst(AP),r1	; Pointer to Mechanism Arguments
    	MOVL	save_operator_entry,r2	; Get the pointer to operator token 
    					;   entry from saved area
    	MOVAL	token_name(r2),r2	; Pointer to counted ascii string

1$:    	CMPL	chf$l_sig_name(r0),#ss$_fltovf
    	BNEQ	2$
    	PUSHL	r2
    	PUSHL	#1
    	PUSHL	#dbg$_fltovf
    	CALLS	#3,G^LIB$SIGNAL

2$:	CMPL	chf$l_sig_name(r0),#ss$_fltund
    	BNEQ	3$
    	MOVL	save_result,r3
    	CLRL	(r3)
    	PUSHL	r2
    	PUSHL	#1
    	PUSHL	#dbg$_ifltund
    	BRW	give_info

3$:	CMPL	chf$l_sig_name(r0),#dbg$_iintovf
    	BNEQ	4$
    	PUSHL	r2
    	PUSHL	#1
    	PUSHL	#dbg$_iintovf
    	BRW	give_info

4$:	CMPL	chf$l_sig_name(r0),#dbg$_divbyzero
    	BNEQ	5$
    	PUSHL	#dbg$_divbyzero
    	CALLS	#1,G^LIB$SIGNAL
    	
5$:	CMPL	chf$l_sig_name(r0),#dbg$_sfcntneg
    	BNEQ	6$
    	PUSHL	#dbg$_sfcntneg
    	CALLS	#1,G^LIB$SIGNAL

6$:	CMPL	chf$l_sig_name(r0),#ss$_decovf
    	BNEQ	7$
    	PUSHL	r2
    	PUSHL	#1
    	PUSHL	#dbg$_decovf
    	CALLS	#3,G^LIB$SIGNAL

7$:	CMPL	chf$l_sig_name(r0),#ss$_fltdiv_f
    	BNEQ	8$
    	PUSHL	#dbg$_divbyzero
    	CALLS	#1,G^LIB$SIGNAL

8$:	CMPL	chf$l_sig_name(r0),#ss$_fltovf_f
    	BNEQ	9$
    	PUSHL	r2
    	PUSHL	#1
    	PUSHL	#dbg$_fltovf
    	CALLS	#3,G^LIB$SIGNAL

9$:	CMPL	chf$l_sig_name(r0),#ss$_fltund_f
    	BNEQ	10$
    	MOVL	save_result,r3
    	CLRL	(r3)
    	PUSHL	r2
    	PUSHL	#1
    	PUSHL	#dbg$_ifltund
    	BRW	give_info

10$:	CMPL	chf$l_sig_name(r0),#ss$_intdiv
    	BNEQ	11$
    	PUSHL	#dbg$_divbyzero
    	CALLS	#1,G^LIB$SIGNAL

11$:
    	CMPL	chf$l_sig_name(r0),#ss$_fltdiv
    	BNEQ	12$
    	PUSHL	#dbg$_divbyzero
    	CALLS	#1,G^LIB$SIGNAL

12$:
    	CMPL	chf$l_sig_name(r0),#mth$_floovemat
    	BNEQ	13$
    	PUSHL	r2
    	PUSHL	#1
    	PUSHL	#dbg$_fltovf
    	CALLS	#3,G^LIB$SIGNAL

13$:
    	CMPL	chf$l_sig_name(r0),#mth$_floundmat
    	BNEQ	14$
    	MOVL	save_result,r3
    	CLRL	(r3)
    	PUSHL	r2
    	PUSHL	#1
    	PUSHL	#dbg$_ifltund
    	BRW	give_info

14$:
    	CMPL	chf$l_sig_name(r0),#mth$_undexp
    	BNEQ	15$
    	PUSHL	r2
    	PUSHL	#1
    	PUSHL	#dbg$_undexpn
    	BRW	give_info

15$:
    	CMPL	chf$l_sig_name(r0),#ss$_roprand
    	BNEQ	16$
    	PUSHL	r2
    	PUSHL	#1
    	PUSHL	dbg$_roprandf
    	CALLS	#3,G^LIB$SIGNAL

16$:
    	CMPL	chf$l_sig_name(r0),#dbg$_istrtru
    	BNEQ	17$
    	PUSHL	r2
    	PUSHL	#1
    	PUSHL	#dbg$_istrtru
    	BRW	give_info

17$:
    	CMPL	chf$l_sig_name(r0),#ss$_opcdec
    	BNEQ	18$
    	PUSHL	r2
    	PUSHL	#1
    	PUSHL	#dbg$_opcdec
    	CALLS	#3,G^LIB$SIGNAL

18$:
    	CMPL	chf$l_sig_name(r0),#ss$_intovf
    	BNEQ	19$
    	PUSHL	r2
    	PUSHL	#1
    	PUSHL	#dbg$_intovf
    	CALLS	#3,G^LIB$SIGNAL

19$:
    	CMPL	chf$l_sig_name(r0),#dbg$_cvtneguns
    	BNEQ	20$
    	PUSHL	r2
    	PUSHL	#1
    	PUSHL	#dbg$_cvtneguns
    	BRW	give_info

20$:
    	CMPL	chf$l_sig_name(r0),#dbg$_undexpn
    	BNEQ	unknown_signal
    	PUSHL	r2
    	PUSHL	#1
    	PUSHL	#dbg$_undexpn
    	BRW	give_info

unknown_signal:
    	MOVL	#ss$_resignal,r0
    	RET

give_info:
    	CALLS	#3,G^LIB$SIGNAL
    	$UNWIND_S
    	RET


    	.SBTTL  dbg$cvt_trfa_to_value
;++
;GLOBAL ROUTINE DBG$CVT_TRFA_TO_VALUE(DST_ARG, SRC_ARG, TOKENCODE): =
;
; FUNCTION
;	This routine accumulates the value in DST_ARG from SRC_ARG
;	depending on given radix.
;
;       This routine is called from the caller one byte at a time, ie.,
;	RFA value initialized to zero.
;       DO i FROM 1 to number of characters
;          RFA value = RFA value * radix + converted character value(i)
;
; INPUTS
;	DST_ARG	- The address of the destination value (6 bytes).
;
;	SRC_ARG	- The address of the source value (6 bytes).
;
;	TOKENCODE-Token code can be one of TOKEN$K_INTEGER,
;		TOKEN$K_HEX_INTEGER, TOKEN$K_BIN_INTEGER,
;		TOKEN$K_OCT_INTEGER.
;
; OUTPUTS
;	The result of the conversion is left in the destination value 
;	address.  Overflow status is returned.
;++

; Parameter Offsets
;
    dst_arg = 4
    src_arg = 8
    tokencode = 12

; Register usuage
;	r2	Address of the dst_arg
;	r3	Address of the src_arg
;	r4,r5	quadword tempory result
;	r6,r7	quadword tempory result
;

.ENTRY	dbg$cvt_trfa_to_value,^M<r2,r3,r4,r5,r6,r7>
    	MOVL	dst_arg(AP),r2		; destination address of 6 bytes
    	MOVL	src_arg(AP),r3		; source address of 6 bytes
    	MOVL	(r2),r4			; move the destination value
    	MOVZWL	4(r2),r5		;	into quadword (in r4,r5)

    	CMPL	tokencode(AP),#token$k_integer
    	BEQL	shift_decimal$
    	CMPL	tokencode(AP),#token$k_hex_integer
    	BEQL	shift_hexdecimal$
    	CMPL	tokencode(AP),#token$k_bin_integer
    	BEQL	shift_binary$
    	CMPL	tokencode(AP),#token$k_oct_integer
    	BEQL	shift_octal$
    	BRW	report_error$

shift_decimal$:					; Multiply the value by 10
    	ASHQ	#1,r4,r6			;   multiply r4 by 2
    	ASHQ	#3,r4,r4			;   multiply r4 by 8
    	ADDL2	r6,r4				;   add result (= * 10)
    	ADWC	r7,r5				; Cannot be a overflow of 8 
    						;   bytes, it'll overflow 6
    						;   bytes.
    	BRW	set_result$

shift_hexdecimal$:				; Multiply the value by 16
    	ASHQ	#4,r4,r4
    	BRW	set_result$

shift_binary$:					; Multiply the value by 2
    	ASHQ	#1,r4,r4
    	BRW	set_result$

shift_octal$:					; Multiply the value by 8
    	ASHQ	#3,r4,r4
    	BRW	set_result$

set_result$:
    	MOVL	r4,(r2)				; Move it into destination
    	MOVW	r5,4(r2)			;   (RFA)
    	BICL	#^XFFFF,r5			; Test the high 2 bytes for
    	BNEQ	rfa_overflow$			;   overflow
    	ADDW	(r3),(r2)			; Add the character value
    	ADWC	2(r3),2(r2)			;   into RFA (6 bytes addition)
    	BCS	rfa_overflow$			; Check for overflow
    	MOVL	#1,r0
    	RET

report_error$:
    	PUSHAL	errmsg1
    	PUSHL	#1
    	PUSHL	#dbg$_interr
    	CALLS	#3,G^LIB$SIGNAL
    	RET

rfa_overflow$:
    	CLRL	r0
    	RET


    	.SBTTL  dbg$cvt_tquadword_to_value
;++
;GLOBAL ROUTINE DBG$CVT_TQUADWORD_TO_VALUE(DST_ARG, SRC_ARG, TOKENCODE): =
;
; FUNCTION
;	This routine accumulates the value in DST_ARG from SRC_ARG
;	depending on given radix.
;
;       This routine is called from the caller one byte at a time, ie.,
;	QUADWORD value initialized to zero.
;       DO i FROM 1 to number of characters
;          QUADWORD value = QUADWORD value * radix + converted character value(i)
;
;	NOTE: This routine assuming the dtype is Q, not QU, if dtype is QU,
;	then DBG$CVT_TUQUADWORD_TO_VALUE should be called instead.
;
; INPUTS
;	DST_ARG	- The address of the destination value (8 bytes).
;
;	SRC_ARG	- The address of the source value (8 bytes).
;
;	TOKENCODE-Token code can be one of TOKEN$K_INTEGER,
;		TOKEN$K_HEX_INTEGER, TOKEN$K_BIN_INTEGER,
;		TOKEN$K_OCT_INTEGER.
;
; OUTPUTS
;	The result of the conversion is left in the destination value 
;	address.  Overflow status is returned.
;++

; Parameter Offsets
;
    dst_arg = 4
    src_arg = 8
    tokencode = 12

; Register usuage
;	r2	Address of the dst_arg
;	r3	Address of the src_arg
;	r4,r5	quadword tempory result
;	r6,r7	quadword tempory result
;

.ENTRY	dbg$cvt_tquadword_to_value,^M<r2,r3,r4,r5,r6,r7>
    	MOVL	dst_arg(AP),r2		; destination address of 8 bytes
    	MOVL	src_arg(AP),r3		; source address of 8 bytes
    	MOVQ	(r2),r4			; move the destination value
    					;	into quadword (in r4,r5)

    	CMPL	tokencode(AP),#token$k_integer
    	BEQL	shift_decimal1$
    	CMPL	tokencode(AP),#token$k_hex_integer
    	BEQL	shift_hexdecimal1$
    	CMPL	tokencode(AP),#token$k_bin_integer
    	BEQL	shift_binary1$
    	CMPL	tokencode(AP),#token$k_oct_integer
    	BEQL	shift_octal1$
    	BRW	report_error1$

shift_decimal1$:				; Multiply the value by 10
    	ASHQ	#1,r4,r6			;   multiply r4 by 2
    	BVS     quad_overflow$
    	ASHQ	#3,r4,r4			;   multiply r4 by 8
    	BVS	quad_overflow$
    	ADDL2	r6,r4				;   add result (= * 10)
    	ADWC	r7,r5				; Add with carry
        BVS	quad_overflow$			; Branch on signed overflow set
    	BRW	set_result1$

shift_hexdecimal1$:				; Multiply the value by 16
    	ASHQ	#4,r4,r4
    	BVS     quad_overflow$
    	BRW	set_result1$

shift_binary1$:					; Multiply the value by 2
    	ASHQ	#1,r4,r4
    	BVS     quad_overflow$
    	BRW	set_result1$

shift_octal1$:					; Multiply the value by 8
    	ASHQ	#3,r4,r4
    	BVS     quad_overflow$
    	BRW	set_result1$

set_result1$:
    	MOVQ	r4,(r2)				; Move it into destination
    						;   (QUADWORD)
    	ADDL2	(r3),(r2)			; Add the character value
    	ADWC	4(r3),4(r2)			;   into QUADWORD (8 bytes addition)
    	BVS	quad_overflow$			; Check for overflow
    	MOVL	#1,r0
    	RET

report_error1$:
    	PUSHAL	errmsg2
    	PUSHL	#1
    	PUSHL	#dbg$_interr
    	CALLS	#3,G^LIB$SIGNAL
    	RET

quad_overflow$:
    	CLRL	r0
    	RET

    	.SBTTL  dbg$cvt_tuquadword_to_value
;++
;GLOBAL ROUTINE DBG$CVT_TUQUADWORD_TO_VALUE(DST_ARG, SRC_ARG, TOKENCODE): =
;
; FUNCTION
;	This routine accumulates the value in DST_ARG from SRC_ARG
;	depending on given radix.
;
;       This routine is called from the caller one byte at a time, ie.,
;	QUADWORD value initialized to zero.
;       DO i FROM 1 to number of characters
;          QUADWORD value = QUADWORD value * radix + converted character value(i)
;
;	NOTE: This routine assuming the dtype is QU, not Q, if dtype is Q,
;	then DBG$CVT_TQUADWORD_TO_VALUE should be called instead.
;
; INPUTS
;	DST_ARG	- The address of the destination value (8 bytes).
;
;	SRC_ARG	- The address of the source value (8 bytes).
;
;	TOKENCODE-Token code can be one of TOKEN$K_INTEGER,
;		TOKEN$K_HEX_INTEGER, TOKEN$K_BIN_INTEGER,
;		TOKEN$K_OCT_INTEGER.
;
; OUTPUTS
;	The result of the conversion is left in the destination value 
;	address.  Overflow status is returned.
;++

; Parameter Offsets
;
    dst_arg = 4
    src_arg = 8
    tokencode = 12

; Register usuage
;	r2	Address of the dst_arg
;	r3	Address of the src_arg
;	r4,r5	quadword tempory result
;	r6,r7	quadword tempory result
;

.ENTRY	dbg$cvt_tuquadword_to_value,^M<r2,r3,r4,r5,r6,r7>
    	MOVL	dst_arg(AP),r2		; destination address of 8 bytes
    	MOVL	src_arg(AP),r3		; source address of 8 bytes
    	MOVQ	(r2),r4			; move the destination value
    					;	into quadword (in r4,r5)

    	CMPL	tokencode(AP),#token$k_integer
    	BEQL	shift_decimalu1$
    	CMPL	tokencode(AP),#token$k_hex_integer
    	BEQL	shift_hexdecimalu1$
    	CMPL	tokencode(AP),#token$k_bin_integer
    	BEQL	shift_binaryu1$
    	CMPL	tokencode(AP),#token$k_oct_integer
    	BEQL	shift_octalu1$
    	BRW	report_erroru1$

shift_decimalu1$:				; Multiply the value by 10
    	ASHQ	#1,r4,r6			;   multiply r4 by 2
    	ASHQ	#3,r4,r4			;   multiply r4 by 8
    	ADDL2	r6,r4				;   add result (= * 10)
    	ADWC	r7,r5				; Add with carry
        BCS	uquad_overflow$			; Branch on unsigned overflow set
    	BRW	set_resultu1$

shift_hexdecimalu1$:				; Multiply the value by 16
    	ASHQ	#4,r4,r4
    	BRW	set_resultu1$

shift_binaryu1$:				; Multiply the value by 2
    	ASHQ	#1,r4,r4
    	BRW	set_resultu1$

shift_octalu1$:					; Multiply the value by 8
    	ASHQ	#3,r4,r4
    	BRW	set_resultu1$

set_resultu1$:
    	MOVQ	r4,(r2)				; Move it into destination
    						;   (QUADWORD)
    	ADDL2	(r3),(r2)			; Add the character value
    	ADWC	4(r3),4(r2)			;   into QUADWORD (8 bytes addition)
    	BCS	uquad_overflow$			; Check for overflow
    	MOVL	#1,r0
    	RET

report_erroru1$:
    	PUSHAL	errmsg3
    	PUSHL	#1
    	PUSHL	#dbg$_interr
    	CALLS	#3,G^LIB$SIGNAL
    	RET

uquad_overflow$:
    	CLRL	r0
    	RET

    	.SBTTL  dbg$cvt_toctaword_to_value
;++
;GLOBAL ROUTINE DBG$CVT_TOCTAWORD_TO_VALUE(DST_ARG, SRC_ARG, TOKENCODE): =
;
; FUNCTION
;	This routine accumulates the value in DST_ARG from SRC_ARG
;	depending on given radix.
;
;       This routine is called from the caller one byte at a time, ie.,
;	OCTAWORD value initialized to zero.
;       DO i FROM 1 to number of characters
;          OCTAWORD value = OCTAWORD value * radix + converted character value(i)
;
;	This routine is used for signed octaword.
;
; INPUTS
;	DST_ARG	- The address of the destination value (16 bytes).
;
;	SRC_ARG	- The address of the source value (16 bytes).
;
;	TOKENCODE-Token code can be one of TOKEN$K_INTEGER,
;		TOKEN$K_HEX_INTEGER, TOKEN$K_BIN_INTEGER,
;		TOKEN$K_OCT_INTEGER.
;
; OUTPUTS
;	The result of the conversion is left in the destination value 
;	address.  Overflow status is returned.
;++

; Parameter Offsets
;
    dst_arg = 4
    src_arg = 8
    tokencode = 12

; Register usuage
;	r2	Address of the dst_arg
;	r3	Address of the src_arg
;

.ENTRY	dbg$cvt_toctaword_to_value,^M<r2,r3,r4,r5,r6,r7,r8,r9,r10,r11>
    	MOVL	dst_arg(AP),r2		; destination address of 16 bytes
    	MOVL	src_arg(AP),r3		; source address of 16 bytes
    	MOVQ	(r2),work_octa		; move the destination value
    					;	into work_octa
    	MOVQ    8(r2),work_octa+8
    	CLRO    r4
    	CLRO    r8
    	CMPL	tokencode(AP),#token$k_integer
    	BEQL	decimal$
    	CMPL	tokencode(AP),#token$k_hex_integer
    	BEQL	hexdecimal$
    	CMPL	tokencode(AP),#token$k_bin_integer
    	BEQL	binary$
    	CMPL	tokencode(AP),#token$k_oct_integer
    	BEQL	octal$
    	BRW	report_error2$
decimal$:
    	BRW     shift_decimal2$
hexdecimal$:
    	BRW     shift_hexdecimal2$
binary$:
    	BRW     shift_binary2$
octal$:
    	BRW     shift_octal2$

shift_decimal2$:				; Multiply the value by 10
    	
    	INSV	work_octa,#1,#31,r4		;   multiply work_octa by 2
    						; Move integer to bit-field
    						;   move from work_octa into
    						;   pos 1, length 31 of r4
    						;   r4 is zero out first,
    						;   so bit 0 of r4 is zero.
    	EXTZV	#31,#32,work_octa,r5		; Move bit-field into integer
    						;   move from work_octa
    						;   pos 31, length 32 to r5
    	EXTZV   #63,#32,work_octa,r6		; Move next 32 bits into r6
    	EXTZV   #95,#32,work_octa,r7		; Move next 32 bits into r7
    	EXTZV   #127,#1,work_octa,r0		; Check to see if the leftover
    	BNEQ    decimal_ov$			;   bits are zero, if not,
    						;   we have overflow.
    	INSV    work_octa,#3,#29,r8		;   multiply work_octa by 8
    	EXTZV   #29,#32,work_octa,r9
    	EXTZV   #61,#32,work_octa,r10
    	EXTZV   #93,#32,work_octa,r11
    	EXTZV   #125,#3,work_octa,r0
    	BNEQ    decimal_ov$
    	ADDL2	r4,r8				; Add two *2 + *8 = *10
    	ADWC	r5,r9
    	ADWC	r6,r10
    	ADWC	r7,r11				; Add with carry
        BVS	decimal_ov$			; Branch on signed overflow set
    	BRW	set_result2$
decimal_ov$:
    	BRW     octa_overflow$

shift_hexdecimal2$:				; Multiply the value by 16
    	INSV    work_octa,#4,#28,r8		;   
    	EXTZV   #28,#32,work_octa,r9
    	EXTZV   #60,#32,work_octa,r10
    	EXTZV   #92,#32,work_octa,r11
    	EXTZV   #124,#4,work_octa,r0
    	BNEQ    hexdecimal_ov$
    	BRW	set_result2$
hexdecimal_ov$:
    	BRW	octa_overflow$

shift_binary2$:					; Multiply the value by 2
    	INSV	work_octa,#1,#31,r8		;   
    	EXTZV	#31,#32,work_octa,r9
    	EXTZV   #63,#32,work_octa,r10
    	EXTZV   #95,#32,work_octa,r11
    	EXTZV   #127,#1,work_octa,r0
    	BNEQ    binary_ov$
    	BRW	set_result2$
binary_ov$:
    	BRW	octa_overflow$

shift_octal2$:					; Multiply the value by 8
    	INSV    work_octa,#3,#29,r8		;   
    	EXTZV   #29,#32,work_octa,r9
    	EXTZV   #61,#32,work_octa,r10
    	EXTZV   #93,#32,work_octa,r11
    	EXTZV   #125,#3,work_octa,r0
    	BNEQ    octal_ov$
    	BRW	set_result2$
octal_ov$:
    	BRW     octa_overflow$

set_result2$:
    	MOVQ	r8,(r2)				; Move it into destination
    						;   (OCTAWORD)
    	MOVQ    r10,8(r2)
    	ADDL2	(r3),(r2)			; Add the character value
    	ADWC	4(r3),4(r2)			;   into OCTAWORD (16 bytes addition)
    	ADWC    8(r3),8(r2)
    	ADWC    12(r3),12(r2)
    	BVS	octa_overflow$			; Check for overflow
    	MOVL	#1,r0
    	RET

report_error2$:
    	PUSHAL	errmsg4
    	PUSHL	#1
    	PUSHL	#dbg$_interr
    	CALLS	#3,G^LIB$SIGNAL
    	RET

octa_overflow$:
    	CLRL	r0
    	RET

    	.END
