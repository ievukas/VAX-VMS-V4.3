MODULE DBGSYMBOL (IDENT = 'V04-000') =

BEGIN

!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
! WRITTEN BY
!	Ping Sager	March, 1982
!
! MODULE FUNCTION
!	This module contains all routines connected with finding out
!	more information about DEBUG's symbols.  It thus implements the
!	SHOW SYMBOL, SYMBOLIZE commands.  SHOW SYMBOL command lists all
!	symbols in DEBUG's Run-Time Symbol Table (the RST) which have a 
!	given single symbol name (%LABEL n is a symbol name), or a symbol 
!	name which includes wildcard character (the allowed wildcard
!	character is "*", which matches zero or more characters) in a 
!	specified scope (a module, a routine, or a lexical block).  
!	Qualifiers on the SHOW SYMBOL command which specify the additional 
!	information is to be shown.  SYMBOLIZE command 	shows all feasible 
!	symbolic representation of a given address.
!

REQUIRE 'SRC$:DBGPROLOG.REQ';

FORWARD ROUTINE
    DBG$STA_ADDRSPEC,			! Interpret a DST value spec
    DBG$STA_SHOWSYMBOL,			! Handle the SHOW SYMBOL command
    DBG$STA_SYMADDR,			! Get a symbol's value or address
    					!	representation
    DBG$TRANSALATE_DESCR: NOVALUE,	! Given pointer to VAX Standard 
    					!	Descriptor, transalate its
    					!	information into user readable 
    					!	form
    DBG$TRANSALATE_KIND,		! Transalate RST's kind field into 
    					!	user readable form
    DBG$TRANSALATE_TYPECODE: NOVALUE,	! Transalate Data Type Code into user
    					!	readable form
    DBG$TRANSALATE_REG: NOVALUE,	! Transalate number into register name
    DBG$DUMP_HEX: NOVALUE,		! Given the address, dump the specified
    					!	number of bytes in hex
    BLD_SCOPE_SEARCH_LIST: NOVALUE,	! Allocate memory block for scope search
    					!	list or expand this list and
    					!	enter the scope to the list
    GET_BLISS_SPECIAL_CASES: NOVALUE,	! Get information for the Bliss Special
    					!	Case DST Record
    GET_VARIANT: NOVALUE,		! Get information for a variant from
    					!	RST entry
    SHOW_SYMBOL: NOVALUE,		! Show the information about a given
    					!	symbol
    SHOW_SYMBOL_ADDRESS: NOVALUE,	! Show symbol's address info for /ADDRESS
    SHOW_SYMBOL_TYPE: NOVALUE,		! Show symbol's type info for /TYPE
    SHOW_SYMBOL_TYPE_HANDLER,		! Handles the abnormal conditions occur
    					! 	during the DST Value Spec
    					!	evaluation
    WILDCARD_CANDIDATES,		! Handle symbol name has wildcard format
    WILDCARD_NAME_SETUP,		! Set up wildcard symbol name for string
    					!	match processing
    WILDCARD_SUB_STRING;		! Break wildcard symbol name into sub-
    					!	strings

EXTERNAL ROUTINE
    DBG$GET_DST_NAME,			! Get the ASCII name from a DST record
    DBG$GET_MEMORY,			! Get a memory block from memory pool
    DBG$GET_TEMPMEM,			! Get a tempory memory block from memory
    					!	pool
    DBG$HASH_FIND,			! Find a name in the RST hash table
    DBG$HASH_FIND_SETUP: NOVALUE,	! Set up calls on HASH_FIND routine
    DBG$LANGUAGE,			! Produce name of given language
    DBG$MAKE_INTEGER_DESC,		! Create value descriptor for integer
    DBG$NEWLINE: NOVALUE,		! Output the current print buffer and
    					!	initialize a new print line
    DBG$NPATHDESC_TO_CS: NOVALUE,	! Generate pathname ASCII string from
    					!	a pathname descriptor
    DBG$POP_TEMPMEM: NOVALUE,		! Pop the pointer to temporary memory
    					!	blocks off the Temporary Memory
    					!	Pool Stack
    DBG$PRINT: NOVALUE,			! Output text to the print buffer using
    					!	FAO formatting
    DBG$PRINT_CONTROL,			! Control the print identation levels
    DBG$PUSH_TEMPMEM,			! Push the pointer to temporary memory
    					!	blocks onto the Temporary Memory
    					! 	Pool Stack
    DBG$REL_MEMORY: NOVALUE,		! Release a memory block to memory pool
    DBG$RST_BLDSCOPE_LIST,		! Set up the set scope search list
    DBG$RST_DST_PTR,			! Get the 'real' DST pointer
    DBG$RST_TEMP_RELEASE: NOVALUE,	! Release all temproary RST entryies
    					!	which are not locked
    DBG$SAVE_VAL: NOVALUE,		! Save "\"
    DBG$STA_NUMBERED_SCOPE: NOVALUE,	! Convert numbered scope to module
    					!	RST and scope RST pointers
    DBG$STA_SETCONTEXT: NOVALUE,	! Set up context for value evaluation
    DBG$STA_SYMKIND: NOVALUE,		! Get a symbol's kind
    DBG$STA_SYMPATHNAME: NOVALUE,	! Get a symbol's full pathname
    DBG$STA_SYMTYPE: NOVALUE,		! Return a symbol's TYPEID and FCODE
    DBG$STA_TYP_AREA: NOVALUE,		! Return info for a PL/I area type
    DBG$STA_TYP_ARRAY: NOVALUE,		! Return info for an array type
    DBG$STA_TYP_ATOMIC:	NOVALUE,	! Return type code for an atomic type
    DBG$STA_TYP_DESCR: NOVALUE,		! Return descriptor for descriptor type
    DBG$STA_TYP_ENUM: NOVALUE,		! Return info for an enumeration type
    DBG$STA_TYP_FILE: NOVALUE,		! Return info for a file type
    DBG$STA_TYP_OFFSET:	NOVALUE,	! Return info for a PL/I offset type
    DBG$STA_TYP_PICT: NOVALUE,		! Return info for a picture type
    DBG$STA_TYP_TYPEDPTR: NOVALUE,	! Return info for a typed pointer type
    DBG$STA_TYP_RECORD:	NOVALUE,	! Return info for a record type
    DBG$STA_TYP_SET: NOVALUE,		! Return info for a set type
    DBG$STA_TYP_SUBRNG:	NOVALUE,	! Return info for a subrange type
    DBG$STA_TYP_VARIANT: NOVALUE,	! Return info for a variant type
    DBG$STA_TYP_VARIANT_COMP: NOVALUE,	! XXX
    OTS$CVT_L_TZ,			! Converts a string to ASCII hex 
    					!	format
    STR$CONCAT,				! Concatenate two strings
    STR$DUPL_CHAR,			! Generates a string containing n
    					!	duplicates of the input character
    STR$FREE1_DX;			! Free a dynamic string


EXTERNAL
    DST$BEGIN_ADDR,			! Virtual address of where the DST
    					!	begins
    RST$START_ADDR: REF RST$ENTRY;	! Pointer to first Module RST Entry


LITERAL
    DBG$K_ADDRKIND_LITERAL = 0,		! Indicate the content is a constant
    DBG$K_ADDRKIND_ADDR = 1,		! Indicate the content is a address
    					!	representation
    DBG$K_ADDRKIND_DESC = 2,		! Indicate the content is a descriptor
    					!	address representation
    DBG$K_ADDRKIND_REG = 3,		! Indicate the content is a register
    DBG$K_ADDRKIND_ABS = 4,		! Indicate the content is a absolute
    					!	address value
    DBG$K_ADDRKIND_BITOFF = 5,		! Indicate the address is a bit offsets
    DBG$K_ADDRKIND_BLIFLD = 6,
    DBG$K_ADDRKIND_COMPLEX = 7,		! Indicate the address is too complex
    					!	to calculate
    DBG$K_ADDRKIND_INVALID = 8;		! Indicate the address is invalid


LITERAL
    SYMBOL_TYPE = 1,			! SHOW SYMBOL command qualifier /TYPE
    SYMBOL_ADDRESS = 2,			! SHOW SYMBOL command qualifier /ADDRESS
    SYMBOL_DIRECT = 3,			! SHOW SYMBOL command qualifier /DIRECT
    SYMBOL_RST = 4,			! SHOW SYMBOL command qualifier /RST
    SYMBOL_DST = 5;			! SHOW SYMBOL command qualifier /DST


OWN
    DBG$_PRINT_FLAG,			! Used to control print routine
    					!	in SHOW_SYMBOL_TYPE
    DBG$_QUALIFIER: BITVECTOR[32]	! Bitvector for command qualifiers
    		INITIAL (0),
    DBG$_SCOPELST: REF VECTOR[,LONG];	! Pointer to the scope search list
    					!	for SHOW SYMBOL command


FIELD WILDCARD$_FLDS_DEF =		! A linked list used to contain the
    					!	sub-strings broken up from 
    					!	wildcard symbol name with no 
    					!	"*" character
    	SET
    	WILDCARD$L_LINK = [0, L_],	! Pointer to next node
    	WILDCARD$L_STRPTR = [1, L_]	! Pointer to Counted ASCII Sub-String
    	TES;

LITERAL
    	WILDCARD$K_SIZE = 2;		! Size of link node in longword 

MACRO
    	WILDCARD$_FLDS = BLOCK[WILDCARD$K_SIZE] FIELD(WILDCARD$_FLDS_DEF) %;


MACRO
    	INIT_DESCRIPTOR(DESCR) =
    	    DESCR[DSC$W_LENGTH] = 0;
    	    DESCR[DSC$B_DTYPE] = DSC$K_DTYPE_T;
    	    DESCR[DSC$B_CLASS] = DSC$K_CLASS_D;
    	    DESCR[DSC$A_POINTER] = 0;%,

    	DISCARD_DESCRIPTOR(DESCR) =
    	    BEGIN
    	    LOCAL
    		FREE_STATUS;

    	    FREE_STATUS = STR$FREE1_DX(DESCR);
    	    END%;


MACRO
    	DTYPE_LENGTH(LENGTH) =
    	    IF .LENGTH NEQ 0
    	    THEN
    		BEGIN
    		DBG$PRINT(UPLIT BYTE(%ASCIC ', size:'), 0);
    	        IF .DTYPE EQL DSC$K_DTYPE_V
    	        THEN
    		    DBG$PRINT(UPLIT BYTE(%ASCIC' !UL bits'), .LENGTH)
    	        ELSE
    	            IF .DTYPE EQL DSC$K_DTYPE_P
    	            THEN
    		        DBG$PRINT(UPLIT BYTE(%ASCIC' !UL digits'), .LENGTH)
    		    ELSE
    		        DBG$PRINT(UPLIT BYTE(%ASCIC' !UL bytes'), .LENGTH);
    		END;%,

    	DTYPE_DIGITS(DIGITS) =	   
    	    IF .VAX_DESCR[DSC$B_DIGITS] NEQ 0
    	    THEN
    		DBG$PRINT(UPLIT BYTE(%ASCIC' with !UL digits'), .DIGITS);%,

    	DTYPE_SCALE(SCALE) =
    	    IF .VAX_DESCR[DSC$B_SCALE] NEQ 0 
    	    THEN
    		DBG$PRINT(UPLIT BYTE(%ASCIC ' scaled !SL'), .SCALE)%;


MACRO
    	BLIUNIT(UNIT_SIZE) =
	    SELECTONE .UNIT_SIZE OF
		SET
		[1]:
		    DBG$PRINT(UPLIT BYTE(%ASCIC'byte'), 0);
		[2]:
		    DBG$PRINT(UPLIT BYTE(%ASCIC'word'), 0);
		[4]:
		    DBG$PRINT(UPLIT BYTE(%ASCIC'long'), 0);
		[OTHERWISE]:
		    DBG$PRINT(UPLIT BYTE(%ASCIC'!SL'), .UNIT_SIZE);
		TES%;

MACRO
    	ITEM_SIZE(BITSIZE) =
	    IF .BITSIZE NEQ 0
    	    THEN
    		BEGIN
    		LOCAL
    		    BITS,
    		    BYTES;

    		BYTES = .BITSIZE/8;
    		BITS = .BITSIZE AND 7;
    		DBG$PRINT(UPLIT BYTE(%ASCIC ', size: '), 0);
    		IF (.BITS NEQ 0) AND (.BITSIZE LEQ 32) 
    		THEN
    		    DBG$PRINT(UPLIT BYTE(%ASCIC '!UL bits'), .BITSIZE)
    		ELSE
    		    BEGIN
    		    IF .BYTES NEQ 0 
    		    THEN 
    			DBG$PRINT(UPLIT BYTE(%ASCIC '!UL bytes'), .BYTES);
    		    IF .BITS NEQ 0
    		    THEN
    			DBG$PRINT(UPLIT BYTE(%ASCIC ' !UL bits'), .BITS);
    		    END;

    		END%;

GLOBAL ROUTINE DBG$STA_ADDRSPEC(DSTPTR, ADDRPTR, ADDRKIND): =
!
! FUNCTION
!	This routine interprets the given DST Value Spec and produces the
!	corresponding address representation for that data symbol.
!
! INPUTS
!	DSTPTR - Pointer to DST record.
!
!	ADDRPTR - The address of a 2-longword vector to receive the address
!		  specification of the symbol.
!
!	ADDRKIND - The address of a longword location to receive the address
!		   kind.
!
! OUTPUTS
!	ADDRPTR - A pointer to the desired address representation is returned
!		  to ADDRPTR.
!
!	ADDRKIND - The kind of the address representation.
!
!	Return a pointer to VALSPEC of ADDRESS or DESCRIPTOR to the caller
!	to continue the unfinished address interpretation.
!

    BEGIN

    MAP
     	ADDRKIND: REF VECTOR[,LONG],	! Address kind
    	ADDRPTR: REF VECTOR[2],		! Address vector
    	DSTPTR: REF DST$RECORD;		! Pointer to DST record

    LOCAL
    	BLITRLR: REF DST$BLI_TRAILER1,	! Pointer to Bliss DST record trailer
    	BLIVALSPEC: BLOCK[8,BYTE]	! Value Spec buffer for Bliss Special
    		FIELD(DST$VS_HDR_FIELDS),!	cases DST record
    	VALSPEC: REF DST$VAL_SPEC;	! Pointer to DST Value Spec


    ! Get to the Value Specification.  Bliss Special Cases DST is a special
    ! case, so handle it differently.
    !
    IF .DSTPTR[DST$B_TYPE] EQL DST$K_BLI
    THEN
    	BEGIN
    	BLIVALSPEC[DST$B_VS_VFLAGS] = .DSTPTR[DST$B_BLI_VFLAGS];
    	BLITRLR = DSTPTR[DST$A_BLI_TRLR1] + .DSTPTR[DST$B_BLI_LNG];
    	BLIVALSPEC[DST$L_VS_VALUE] = .BLITRLR[DST$L_BLI_VALUE];
    	VALSPEC = BLIVALSPEC[DST$B_VS_VFLAGS];
    	END

    ELSE
    	VALSPEC = DSTPTR[DST$B_VFLAGS];


    ! If the value is given by a trailing Value Spec, we get to that Value
    ! Spec.  We loop in case the indirection is repeated.
    !
    WHILE .VALSPEC[DST$B_VS_VFLAGS] EQL DST$K_VFLAGS_TVS DO
	VALSPEC = VALSPEC[DST$A_VS_TVS_BASE] + .VALSPEC[DST$L_VS_TVS_OFFSET];


    ! If the Value Spec gives the offset to a descriptor (in the DST), return
    ! the address of that descriptor to the caller.
    !
    IF .VALSPEC[DST$B_VS_VFLAGS] EQL DST$K_VFLAGS_DSC
    THEN
	BEGIN
	ADDRPTR[0] = VALSPEC[DST$A_VS_DSC_BASE] + .VALSPEC[DST$L_VS_DSC_OFFS];
	ADDRPTR[1] = 0;
	ADDRKIND[0] = DBG$K_ADDRKIND_DESC;
	RETURN .VALSPEC;
	END;


    ! If this is a Bit Offset Value Spec, return that bit offset as a byte
    ! address plus bit offset to the caller.
    !
    IF .VALSPEC[DST$B_VS_VFLAGS] EQL DST$K_VFLAGS_BITOFFS
    THEN
	BEGIN
	ADDRPTR[0] = .VALSPEC[DST$L_VS_VALUE]/8;
	ADDRPTR[1] = .VALSPEC[DST$L_VS_VALUE] AND 7;
	ADDRKIND[0] = DBG$K_ADDRKIND_BITOFF;
	RETURN .VALSPEC;
	END;


    ! If this is a Value-Spec-Follows value spec, a more complex value spec
    ! follows the VFLAGS field.  Here we handle those kinds of value specs.
    !
    IF .VALSPEC[DST$B_VS_VFLAGS] EQL DST$K_VS_FOLLOWS
    THEN
	BEGIN


	! Sort out which particular kind of complex value specification follows.
	!
	CASE .VALSPEC[DST$B_VS_ALLOC] FROM DST$K_VS_ALLOC_STAT TO DST$K_VS_ALLOC_DYN OF
	    SET


	    ! Handle statically or dynamically allocated objects without Binding
	    ! Specs.  Here we just indicate this is too complex to compute, for
    	    ! if we do evaluate the Materialization Spec will cause the side
    	    ! effects.
	    !
	    [DST$K_VS_ALLOC_STAT,
	     DST$K_VS_ALLOC_DYN]:
		BEGIN
    		ADDRPTR[0] = 0;
    		ADDRPTR[1] = 0;
    		ADDRKIND[0] = DBG$K_ADDRKIND_COMPLEX;
		END;


	    ! Any other value in the DST$B_VS_ALLOC field is an error.
	    !
	    [INRANGE, OUTRANGE]:
		SIGNAL(DBG$_INVDSTREC);

	    TES;


	! We are done with the complex value spec.  Return to the caller.
	!
	RETURN .VALSPEC;
	END;


    ! This is an ordinary garden variety Value Spec with a normal VFLAGS field
    ! and a normal VALUE field.  If this is a literal, return the address of the
    ! literal to the caller.
    !
    IF .VALSPEC[DST$V_VS_VALKIND] EQL DST$K_VALKIND_LITERAL
    THEN
	BEGIN
	ADDRPTR[0] = VALSPEC[DST$L_VS_VALUE];
	ADDRPTR[1] = 0;
	ADDRKIND[0] = DBG$K_ADDRKIND_LITERAL;
	RETURN .VALSPEC;
	END;


    ! If this is a register number, return the register number.
    !
    IF .VALSPEC[DST$V_VS_VALKIND] EQL DST$K_VALKIND_REG
    THEN
	BEGIN
	ADDRPTR[0] = .VALSPEC[DST$L_VS_VALUE];
	ADDRPTR[1] = 0;
	ADDRKIND[0] = DBG$K_ADDRKIND_REG;
	RETURN .VALSPEC;
	END;


    ! This value spec requires the value to be computed.  The resulting value 
    ! is either the address of some object or the address of a descriptor.
    ! Return to the caller to do some more interpretation about the address of
    ! this value, used -1 to indicate unfinished status, return its kind: 
    ! address or descriptor address.
    !
    ADDRPTR[0] = -1;
    ADDRPTR[1] = -1;
    IF .VALSPEC[DST$V_VS_VALKIND] EQL DST$K_VALKIND_DESC
    THEN
	ADDRKIND[0] = DBG$K_ADDRKIND_DESC

    ELSE
	ADDRKIND[0] = DBG$K_ADDRKIND_ADDR;

    RETURN .VALSPEC;

    END;

GLOBAL ROUTINE DBG$STA_SHOWSYMBOL(VERB_NODE) =
!
! FUNCTION
!
!	SHOW SYMBOL[/qualifier...] namespec [IN scopespec[,scopespec...]]
!
!	This routine performs the semantic action associated with the
!	SHOW SYMBOL command.  First step sets up a scope search list for
!	the specified symbol name (wildcard scheme is allowed).  If
!	scopespec is specified, DBG$RST_BLDSCOPE_LIST is called to construct
!	the set scope list, and converts all the numbered scopes to module
!	RST and scope RST pointers by calling DBG$STA_NUMBERED_SCOPE, then
!	constructs a list of search scopes from set scope search list.
!	If scopespec is omitted, all set modules and the GST are set up
!	in the scope search list.  Second step generates the candidate symbols,
!	a "candidate symbol" is a symbol whose name matches namespec,
!	but which may not be in any of the scopespec scopes.  Third
!	step selects candidates in the scope search list.  Finally,
!	the information to be showed could include the symbol name,
!	type information, address information, and (for DEBUG developers)
!	the symbol RST and DST entries in hexadecimal.
!
! INPUTS
!	VERB_NODE  - A pointer to the Verb Node in the command execution
!		   tree which was constructed after parsing the SHOW SYMBOL 
!		   command.
!
! OUTPUTS
!	Return value is TRUE if any matches were found; false otherwise.
!

    BEGIN

    MAP
	VERB_NODE: REF DBG$VERB_NODE;	! Pointer to the Verb Node in the
    					! 	command execution tree

    
    LOCAL
    	ADVERB_NODE: REF DBG$ADVERB_NODE,! Pointer to the Adverb Node in the
    					! 	command execution tree
    	BAD_SCOPE,			! Pointer to a counted string
    					!	representing the translation
    					!	of the contents of the
    					!	pathname descriptor
    	CNT1,				! Tempory count variable
    	CNT2,				! Tempory count variable
    	DATA_LIST: REF VECTOR[,LONG],	! A link list of data symbols
    	ERRINDEX,			! Indicate the bad scope pathname is 
    					!	found
    	IN_SCOPE,			! Flag set if candidate symbol is in
    					!	the given scope
    	INVOCNUM,			! Invocation number for numeric scope
    					!	(only needed for parameter passing)
    	MODRSTPTR,			! Pointer to module RST entry in scope
    					!	search list
    	NAMESPEC: REF VECTOR[,BYTE],	! Pointer to a counted string of 
    					!	namespec field in SHOW SYMBOL
    					!	command
    	NAME: REF VECTOR[,BYTE],	! Pointer to a counted string
        NCANDS,				! Number of scope entries or later on
    					!	used as Number of displayed symbols
    	NEXTSETMOD: REF RST$ENTRY,	! Pointer to the next set module after
    					!	this one
    	NEXTRSTPTR: REF RST$ENTRY,	! Pointer to the next RST entry belong
    					!	to the same module as this one
    	NOUN_NODE: REF DBG$NOUN_NODE,	! Pointer to the Noun Node in the
    					!	command execution tree
    	RSTPTR: REF RST$ENTRY,		! Pointer to candidate RST entry
    	SCOPE: REF RST$ENTRY,		! Pointer to scope RST entry in set 
    					!	scope search list
    	SCOPEPTR: REF SCOPE$ENTRY,	! Pointer to the set scope search list
    	SCOPESPEC: REF VECTOR[,LONG],	! Pointer to the pathname descriptor
    					!	vector of scopespec field in
    					!	SHOW SYMBOL command
    	STATUS,				!
    	SYMSCOPE: REF RST$ENTRY,	! Pointer to symbol scope RST entry
    	SYM_SCOPE$LIST: REF SCOPE$ENTRY,! Pointer to the set scope search list
    	UTILITY_FLAG,			! Flag set to indicate some condition
    					!	is encounted
    	WILDCARD: REF VECTOR[,BYTE],	! Pointer to '*' character in a string
    	WILDCARD_NAME: REF VECTOR[,BYTE],! String contains '*', with appended
    					!	begin and end characters
    	WILDCARD_PTR: REF WILDCARD$_FLDS;! Pointer to Sub-Strings


    ! Set print controls for DBG$PRINT.  
    !
    DBG$PRINT_CONTROL(DBG$K_PRTSET_CONTINUE, 2, DBG$K_PRTBRK_ON_BLANKS);


    ! Initialize the scope search list pointer, set scope search list pointer,
    ! and command qualifiers bitvector.
    !
    DBG$_SCOPELST = 0;
    SYM_SCOPE$LIST = 0;
    DBG$_QUALIFIER = 0;


    ! Recover the Noun Node for namespace and scopespec, and Adverb Node
    ! for command qualifiers from SHOW SYMBOL command execution tree Verb Node.
    !
    NOUN_NODE = .VERB_NODE[DBG$L_VERB_OBJECT_PTR];
    ADVERB_NODE = .VERB_NODE[DBG$L_VERB_ADVERB_PTR];


    ! Set up command qualifiers from Adverb_node.
    !
    IF .ADVERB_NODE NEQ 0
    THEN
    	BEGIN


    	! There are qualifiers specified on the command.
    	!
    	WHILE TRUE DO
    	    BEGIN


    	    ! Check to see if there are more qualifiers.
    	    !
    	    IF .ADVERB_NODE EQL 0 THEN EXITLOOP;


    	    ! Set up command qualifier bitvector accordingly.
    	    !
    	    CASE .ADVERB_NODE[DBG$B_ADVERB_LITERAL]  FROM 
    		 SYMBOL_TYPE TO SYMBOL_DST OF
    	    SET


    	    ! /TYPE
    	    [SYMBOL_TYPE]:
    		DBG$_QUALIFIER[SYMBOL_TYPE] = TRUE;


    	    ! /ADDRESS
    	    [SYMBOL_ADDRESS]:
    		DBG$_QUALIFIER[SYMBOL_ADDRESS] = TRUE;


    	    ! /DIRECT
    	    [SYMBOL_DIRECT]:
    		DBG$_QUALIFIER[SYMBOL_DIRECT] = TRUE;


    	    ! /RST
    	    [SYMBOL_RST]:
    		DBG$_QUALIFIER[SYMBOL_RST] = TRUE;


    	    ! /DST
    	    [SYMBOL_DST]:
    		DBG$_QUALIFIER[SYMBOL_DST] = TRUE;

    	    TES;


    	    ! Get next command qualifier.
    	    !
    	    ADVERB_NODE = .ADVERB_NODE[DBG$L_ADVERB_LINK];

    	    END;			! End of walking through Adverb Node.

    	END;				! End of setting up command qualifiers.


    ! Pick up scopespec field in the noun node which specifies the
    ! pathname descriptor vector for the set scope search list.
    ! If there is a set scope search list specified in the command, call
    ! build scope list routine to construct the set scope search list. 
    !
    SCOPESPEC = .NOUN_NODE[DBG$L_NOUN_VALUE2];
    IF .SCOPESPEC NEQ 0
    THEN
    	BEGIN


    	! Scopespec is specified in the command.  Build the set scope search
    	! list.
    	!
    	SYM_SCOPE$LIST = DBG$RST_BLDSCOPE_LIST(.SCOPESPEC, ERRINDEX, 
    						FALSE, FALSE);


    	! Check for bad scope name entry.
    	!
    	IF .ERRINDEX NEQ 0
    	THEN
    	    BEGIN


    	    ! Transalate the bad scope to a counted string.  Signal an
    	    ! error.
    	    !
    	    DBG$NPATHDESC_TO_CS(.SCOPESPEC[.ERRINDEX], BAD_SCOPE);
    	    SIGNAL(DBG$_NOSUCHSCOPE, 1, .BAD_SCOPE);
    	    END;
    	
    	END;				! End of building set scope search list.


    ! Build a list of scopes for the symbols to be searched.  Count the number
    ! of scopes in the scope search list.
    !
    NCANDS = 0;


    ! If we have scopespec specified in the command.  Convert all the numbered
    ! scopes to module RST and scope RST pointers.  If there is one translation
    ! can not be done (returned module RST pointer is zero), an informational 
    ! message is signaled.  If there are no translations can be done at all, 
    ! release memory block, return to the caller.  Enter the good scope to
    ! the scope search list.
    !
    IF .SCOPESPEC NEQ 0
    THEN
    	BEGIN
    	CNT1 = 0;
    	CNT2 = 0;


    	! Set SCOPEPTR points to the set scope search list.
    	!
    	SCOPEPTR = .SYM_SCOPE$LIST;
    	WHILE .SCOPEPTR NEQ 0 DO
    	    BEGIN


    	    ! Assume we have a good scope.  Count the number of scopes in
    	    ! the set scope search list we have encounted.  Get the scope
    	    ! RST from set scope search list.
    	    !
    	    UTILITY_FLAG = TRUE;
    	    CNT1 = .CNT1 + 1;
    	    SCOPE = .SCOPEPTR[SCOPE$L_RSTPTR];


    	    ! Check to see if this is a numbered scope.  If it is, turn it
    	    ! into normal scope.
    	    !
    	    IF .SCOPEPTR[SCOPE$L_STATE] EQL SCOPE$K_NUMBERED
    	    THEN
    		BEGIN
    		DBG$STA_NUMBERED_SCOPE(.SCOPEPTR[SCOPE$L_MODPTR], MODRSTPTR,
    				       SCOPE, INVOCNUM);


    		! Check to see if we can convert this numbered scope.  If we
    		! cannot, give an informational message.  Count the number of
    		! bad scopes.  Set the flag to indicate bad status has encounted.
    		!
    		IF .MODRSTPTR EQL 0
    		THEN
    		    BEGIN
    		    SIGNAL(DBG$_NONUMSCOPE, 1, .SCOPEPTR[SCOPE$L_MODPTR]);
    		    CNT2 = .CNT2 + 1;
    		    UTILITY_FLAG = FALSE;
    		    END;

    		END;			! End of converting numbered scope.


    	    ! Check to see if this is a global scope.  If it is then sets up
    	    ! scope to be "ANONYMOUS" module containing all unclaimed global
    	    ! symbols.
    	    !
    	    IF .SCOPEPTR[SCOPE$L_STATE] EQL SCOPE$K_GLOBAL
    	    THEN
    		SCOPE = .RST$START_ADDR;


    	    ! Enter the good scope to scope search list.
    	    !
    	    IF .UTILITY_FLAG THEN BLD_SCOPE_SEARCH_LIST(NCANDS, .SCOPE);


    	    ! Get next item on set scope search list.
    	    !
    	    SCOPEPTR = .SCOPEPTR[SCOPE$L_FLINK];

       	    END;			! End of WHILE walking through set 
    					!	scope search list.


    	! Check to see if all transalations from numeric scope to module scope
    	! failed.  If it is, release the set scope search list memroy block,
    	! return to the caller.
    	!
    	IF .CNT1 EQL .CNT2 
    	THEN
    	    BEGIN
    	    DBG$REL_MEMORY(.SYM_SCOPE$LIST);
    	    RETURN FALSE;
    	    END;

    	END				! End of if there is a scopespec
    					!	specified.


    ! If scopespec is omitted.  All set modules' RST entries and GST are
    ! set up in the scope search list.
    !
    ELSE				
        BEGIN


        ! Make NEXTSETMOD point to the first set module.
    	!
    	NEXTSETMOD = .RST$START_ADDR;
        

    	! Find the next set module in the module chain.  Enter the module
    	! RST on scope search list.
    	!
    	WHILE .NEXTSETMOD NEQ 0 DO
    	    BEGIN


    	    ! If the module is set then enter the module RST on scope search 
    	    ! list.
    	    !
    	    IF .NEXTSETMOD[RST$V_MODSET]
    	    THEN
    		BLD_SCOPE_SEARCH_LIST(NCANDS, .NEXTSETMOD);


    	    ! Go on to next module in the chain.
    	    !
    	    NEXTSETMOD = .NEXTSETMOD[RST$L_NXTMODPTR];
    	    END;			! End of setting up all set modules.


    	! Set up Global Symbol Table.
    	!
    	BLD_SCOPE_SEARCH_LIST(NCANDS, .RST$START_ADDR);

    	END;				! End of if scopepsec is omitted.


    ! Check to see if we have successfully build scope search list.
    ! If not, really something is wrong.  If it is ok, enter the scope count
    ! to the 1st longword in the scope search list.
    !
    IF .DBG$_SCOPELST EQL 0
    THEN
    	BEGIN
    	IF .SYM_SCOPE$LIST NEQ 0 THEN DBG$REL_MEMORY(.SYM_SCOPE$LIST);
    	$DBG_ERROR('DBGSYMBOL\DBG$STA_SHOWSYMBOL, err. 10');
    	END
    ELSE
    	DBG$_SCOPELST[0] = .NCANDS;
    

    ! Pick up the namespec field which consists of a single symbol name,
    ! or a symbol name includes wildcard characters.  Set up the flag
    ! accordingly.
    !
    NCANDS = 0;
    DATA_LIST = .NOUN_NODE[DBG$L_NOUN_VALUE];
    WHILE TRUE DO
    	BEGIN
    	IF .DATA_LIST EQL 0 THEN EXITLOOP;
     	NAMESPEC = .DATA_LIST[1];
    	WILDCARD = CH$FIND_CH(.NAMESPEC[0], NAMESPEC[1], %C'*');


    	! This symbol name contains wildcard characters.  Set the flag to indicate
    	! we have a wildcard symbol name.
    	!
    	IF .WILDCARD NEQ 0
    	THEN
    	    BEGIN
    	    UTILITY_FLAG = TRUE;


    	    ! Append null character before begin character and after end character
    	    ! in the string, if the begin and end characters are not "*".  Adjust
    	    ! the count too.
    	    !
    	    WILDCARD_NAME = WILDCARD_NAME_SETUP(.NAMESPEC);


    	    ! Break the wildcard symbol name into sub-strings.  ie, A*B*C breaks
    	    ! into A, B, C.
    	    !
    	    WILDCARD_PTR = WILDCARD_SUB_STRING(.WILDCARD_NAME);


    	    ! Since we have a wildcard symbol name, we have to go through all set
    	    ! modules following symbol chain pointer for each module, and all 
    	    ! global symbols, check to see if each RST name matches the wildcard 
    	    ! symbol name pattern, and select those declared in the scope.  Start 
    	    ! from first Module RST Entry, find the first set module, set the 
    	    ! symbol chain pointer to this as well.
    	    !
    	    NEXTSETMOD = .RST$START_ADDR;
    	    WHILE .NEXTSETMOD NEQ 0 DO
    	        BEGIN
    	        IF .NEXTSETMOD[RST$V_MODSET] THEN EXITLOOP;
    	        NEXTSETMOD = .NEXTSETMOD[RST$L_NXTMODPTR];
    	        END;


    	    ! If we have all the module been canceled, set up the pointer to
    	    ! search global symbol only.
    	    !
    	    IF .NEXTSETMOD EQL 0
    	    THEN
    	        NEXTRSTPTR = .RST$START_ADDR[RST$L_SYMCHNPTR] 
    	    ELSE
    	        NEXTRSTPTR = .NEXTSETMOD;

    	    END				! End of setting up wildcard symbol name.


        ! This is a normal symbol name.  Set up the name via RST hash table.
        ELSE
    	    BEGIN
    	    UTILITY_FLAG = FALSE;
    	    DBG$HASH_FIND_SETUP(.NAMESPEC);
    	    END;


        ! Now that we have a scope search list to search.  Go through candidate
        ! symbols to see if the candidate is in the given scope.  A "candidate
        ! symbol" is a symbol whose name matches namespec, but which may not be
        ! in any of the scopespec scopes.
        !
        WHILE TRUE DO
            BEGIN


    	    ! Get next candidate.  If the flag is set --> this symbol contains
    	    ! wildcard, call WILDCARD routine to handle it.  
    	    !
    	    IF .UTILITY_FLAG
    	    THEN
    	        RSTPTR = WILDCARD_CANDIDATES(.WILDCARD_PTR, NEXTSETMOD, NEXTRSTPTR)


    	    ! This symbol is normal symbol --> does not have wildcard, call
    	    ! hash routine to handle it.
    	    !
    	    ELSE
    	        RSTPTR = DBG$HASH_FIND(.NAMESPEC);


    	    ! Check to see if we have run through all the candidates.  If we
    	    ! do then we are all done.
    	    !
    	    IF .RSTPTR EQL 0 THEN EXITLOOP;


    	    ! Loop through the scope search list to see if this candidate symbol 
    	    ! is in scope.  Assume we have not found a scope yet.
    	    !
    	    IN_SCOPE = FALSE;
            INCR I FROM 1 TO .DBG$_SCOPELST[0] DO
    	        BEGIN


    	        ! Select Candidates.  Select candidate by following the upscope
    	        ! chain from each candidate RST entry, compare to scope RST pointer
    	        ! in the scope search list to see if the candidate symbol is in
    	        ! the scope.  If /DIRECT is specified, select only those candidate
    	        ! symbols which are declared directly in the scope, but not those
    	        ! declared nested within the scope.  CNT1 is used to keep track
    	        ! of the number of upscopes.
    	        !
       	        SYMSCOPE = .RSTPTR;
    	        CNT1 = 0;
    	        WHILE TRUE DO
    		    BEGIN


    		    ! Compare to see if this candadite symbol is in scope.  If it
    		    ! is, set the flag to indicate the case.
    		    ! 
    		    IF .SYMSCOPE EQL .DBG$_SCOPELST[.I]
    		    THEN 
    		        BEGIN
    		        IN_SCOPE = TRUE;
    		        EXITLOOP;
    		        END;


    		    ! Check to see if we are at the module level.  If we are,
    		    ! exit.
    		    !
    		    IF .SYMSCOPE[RST$B_KIND] EQL RST$K_MODULE THEN EXITLOOP;


    		    ! If this is a type component, go up-scope once more to its
    		    ! type.
    		    !
    		    IF .SYMSCOPE[RST$B_KIND] EQL RST$K_TYPCOMP
    		    THEN
    		        SYMSCOPE = .SYMSCOPE[RST$L_UPSCOPEPTR];


    		    ! If the /DIRECT qualifier switch is on, we only need to go
    		    ! up-scope once.  Check to see if we have, if so, exit.
    		    !
    		    IF .DBG$_QUALIFIER[SYMBOL_DIRECT] AND (.CNT1 EQL 1)
    		    THEN
    		        EXITLOOP;

    		    SYMSCOPE = .SYMSCOPE[RST$L_UPSCOPEPTR];


    		    ! Increment the upscope counter.
    		    !
    		    CNT1  = .CNT1 + 1;
    		    END;		! End of WHILE checking candidate
    					! 	symbol in scope.

    	        ! Check to see if we have selected the candidate, if so, exit.
    	        ! Otherwise, check the next scope in the scope search list.
    	        !
    	        IF .IN_SCOPE THEN EXITLOOP;

    	        END;			! End of INCR checking candidate symbol
    					!	in the scope search list.


    	    ! We have found this symbol is in the scope.  Before interface to 
    	    ! output routine to show the information about this symbol according
    	    ! to the given qualifier, do a check to make sure this symbol has
    	    ! a name, if this symbol does not have a name, we simply ignore it.
    	    ! And also ignore the TYPE RST entry.  Only if /TYPE is specified,
    	    ! then the TYPE RST entry will be taken care of.
    	    !
    	    IF .IN_SCOPE 
    	    THEN 
    	        BEGIN
    	        NAME = DBG$GET_DST_NAME(.RSTPTR[RST$L_DSTPTR]);
    	        IF .NAME[0] NEQ 0 AND .RSTPTR[RST$B_KIND] NEQ RST$K_TYPE
    	        THEN 
    		    BEGIN
    		    SHOW_SYMBOL(.RSTPTR, NCANDS);
    		    DATA_LIST[2] = .NCANDS;
    		    END;
    	        END;
    	
    	    END;			! End of WHILE selecting all candidate
    					!	symbols.

    	IF .UTILITY_FLAG THEN DBG$REL_MEMORY(.WILDCARD_NAME);
    	DATA_LIST = .DATA_LIST[0];
    	END;				! End of WHILE data symbol list.


    ! All done.  Release the memory blocks.
    !
    IF .SYM_SCOPE$LIST NEQ 0 THEN DBG$REL_MEMORY(.SYM_SCOPE$LIST);
    DBG$REL_MEMORY(.DBG$_SCOPELST);


    ! If we have found any candidates then return TRUE.
    !
    RETURN .NCANDS GTR 0;
    END;

GLOBAL ROUTINE DBG$STA_SYMADDR(SYMID, ADDRPTR, ADDRKIND): =
!
! FUNCTION
!	This routine takes a SYMID and gets the address information associated
!	with the input SYMID.   NOTE: This piece of code is taken from
!	DBG$STA_SYMVALUE with some modifications, so any changes made in there 
!	that impact the logic should be made in here as well.
!
! INPUTS
!	SYMID	 - Symid ID for the symbol.
!
!	ADDRPTR  - The address of a two-longword vector to receive the address
!		   specification of the symbol.
!
!	ADDRKIND - The address of a longword location to receive the address
!		   kind.
!
! OUTPUTS
!	ADDRPTR  - A pointer to the desired address is returned to ADDRPTR.
!
! 	ADDRKIND - The kind of the address is returned to ADDRKIND.  
!
!	Return 0 or a pointer to VALSPEC for a data symbol to the caller to
!	continue unfinished address interpretation.
!

    BEGIN

    MAP
    	ADDRKIND: REF VECTOR[1],	! Address kind
    	ADDRPTR: REF VECTOR[2],		! Address vector
    	SYMID: REF RST$ENTRY;		! Pointer to symbol's RST entry

    LOCAL
    	DSTPTR: REF DST$RECORD,		! Pointer to Symbol's DST record
	PSECT_TRAILER: REF DST$PSECT_TRAILER,
    	STKFMPTR: REF VECTOR[,LONG],	! Stack frame pointer from Stack Machine
    					!	(needed for passing parameters)
    	VALPTR: REF DST$VAL_SPEC;	! Pointer to VALSPEC


    VALPTR = 0;
    CASE .SYMID[RST$B_KIND] FROM RST$K_KIND_MINIMUM TO RST$K_KIND_MAXIMUM OF
    	SET


    	! For instruction addresses, return the start address in the RST entry
    	! in ADDRPTR[0].  If it is a lexical entity, return the end address in
    	! RST entry in ADDRPTR[1].
    	!
    	[RST$K_ROUTINE, RST$K_BLOCK,
    	 RST$K_LINE]:
    	    BEGIN
    	    ADDRPTR[0] = .SYMID[RST$L_STARTADDR];
    	    ADDRPTR[1] = .SYMID[RST$L_ENDADDR];
    	    ADDRKIND[0] = DBG$K_ADDRKIND_ABS;
    	    END;


    	! For instruction addresses, return the start address in the RST entry
    	! in ADDRPTR[0], and 0 in ADDRPTR[1].
    	!
    	[RST$K_ENTRY, RST$K_LABEL]:
    	    BEGIN


    	    ! Handle the PSECT DST record.  Here we pick the PSECT start
    	    ! address directly from the DST record.
    	    !
    	    DSTPTR = .SYMID[RST$L_DSTPTR];
    	    IF .DSTPTR[DST$B_TYPE] EQL DST$K_PSECT
    	    THEN
    		BEGIN
    		PSECT_TRAILER = DSTPTR[DST$A_PSECT_TRLR_BASE] + 
    			.DSTPTR[DST$B_PSECT_TRLR_OFFS];
    		ADDRPTR[0] = .DSTPTR[DST$L_PSECT_VALUE];


    		! Get to the PSECT trailing record to pick up the size.
    		!
    		ADDRPTR[1] = .ADDRPTR[0] + .PSECT_TRAILER[DST$L_PSECT_SIZE] - 1;
    		END

    	    ELSE
    		BEGIN
    	        ADDRPTR[0] = .SYMID[RST$L_STARTADDR];
    	        ADDRPTR[1] = 0;
    		END;

    	    ADDRKIND[0] = DBG$K_ADDRKIND_ABS;
    	    END;


    	! For Data and Type Components, we determine the address from DST
    	! value specification.
    	!
    	[RST$K_DATA, RST$K_TYPCOMP]:
    	    BEGIN
    	    DSTPTR = .SYMID[RST$L_DSTPTR];
    	    CASE .DSTPTR[DST$B_TYPE] FROM 0 TO 255 OF
    		SET


    		! Handle all normal DST records, i.e., those of the standard
    		! format.  Find the Value Spec and pass it to DBG$STA_VALADDR
    		! for address computation.
    		!
    		[DSC$K_DTYPE_LOWEST TO DSC$K_DTYPE_HIGHEST,
    		 DST$K_BOOL, DST$K_SEPTYP, DST$K_LBLORLIT,
    		 DST$K_ENTRY, DST$K_RTNBEG, DST$K_BLKBEG,
    		 DST$K_RECBEG, DST$K_ENUMELT]:
    		    BEGIN
    		    VALPTR = DBG$STA_ADDRSPEC(.DSTPTR, .ADDRPTR, .ADDRKIND);
    		    END;


    		! Handle the Label DST record.  Here we get the label address
    		! directly from the DST$L_VALUE field -- the DST$B_VFLAGS is
    		! not provided.
    		!
    		[DST$K_LABEL]:
    		    BEGIN
    		    ADDRPTR[0] = .DSTPTR[DST$L_VALUE];
    		    ADDRPTR[1] = 0;
    		    ADDRKIND[0] = DBG$K_ADDRKIND_ABS;
    		    END;


    		! Handle the Bliss special Cases DST record.
    		!
    		[DST$K_BLI]:
    		    BEGIN
    		    VALPTR = DBG$STA_ADDRSPEC(.DSTPTR, .ADDRPTR, .ADDRKIND);
    		    END;


    		! Handle the Bliss Field DST record.
    		!
    		[DST$K_BLIFLD]:
    		    BEGIN
    		    ADDRPTR[0] = 0;
    		    ADDRPTR[1] = 0;
    		    ADDRKIND[0] = DBG$K_ADDRKIND_BLIFLD;
    		    END;


    		! Handle  the COBOL Hack DST Record.  Here we just indicate
    		! this is too complex to compute.
    		!
    		[DST$K_COB_HACK]:
    		    BEGIN
    		    ADDRPTR[0] = 0;
    		    ADDRPTR[1] = 0;
    		    ADDRKIND[0] = DBG$K_ADDRKIND_COMPLEX;
    		    END;
    		    

    		! Any other DST record treated as invalid address.
    		!
    		[INRANGE, OUTRANGE]:
    		    BEGIN
    		    ADDRPTR[0] = 0;
    		    ADDRPTR[1] = 0;
    		    ADDRKIND[0] = DBG$K_ADDRKIND_INVALID;
    		    END;

    		TES;

    	    END;


    	! Any other RST entry treated as invalid address.
    	!
    	[INRANGE, OUTRANGE]:
    	    BEGIN
    	    ADDRPTR[0] = 0;
    	    ADDRPTR[1] = 0;
    	    ADDRKIND[0] = DBG$K_ADDRKIND_INVALID;
    	    END;

    	TES;

    RETURN .VALPTR;

    END;

GLOBAL ROUTINE DBG$TRANSALATE_DESCR(VAX_DESCR): NOVALUE =
!
! FUNCTION
!	Given pointer to VAX Standard Descriptor, transalate its information
!	into readable format.
!
! INPUT
!	VAX_DESCR - Pointer to VAX Standard Descriptor.
!
! OUTPUT
!	None.
!

    BEGIN

    MAP
    	VAX_DESCR: REF BLOCK[,BYTE];

    LOCAL
    	BOUNDS_PTR: REF VECTOR,		! Pointer to Bounds for Array Descriptor
    	DTYPE,				! Atomic data types
    	LENGTH;				! Length of the object


    DTYPE = .VAX_DESCR[DSC$B_DTYPE];
    LENGTH = .VAX_DESCR[DSC$W_LENGTH];
    CASE .VAX_DESCR[DSC$B_CLASS] FROM DSC$K_CLASS_S TO DSC$K_CLASS_UBA OF
    	SET


    	! Scalar, String Descriptor, is used for scalar data and fixed-length
    	! strings.  Any VAX data type can be used with this descriptor, except 
    	! bit unaligned. (DTYPE 34).
    	!
    	[DSC$K_CLASS_S]:
    	    BEGIN
    	    IF ((.DTYPE GEQ DSC$K_DTYPE_T) AND (.DTYPE LEQ DSC$K_DTYPE_P)) OR
    	       (.DTYPE EQL DSC$K_DTYPE_V) OR
    	       (.DTYPE EQL DSC$K_DTYPE_VU)
    	    THEN
    		DBG$PRINT(UPLIT BYTE(%ASCIC'string descriptor type,'), 0)
    	    ELSE
    		DBG$PRINT(UPLIT BYTE(%ASCIC'scalar descriptor type,'), 0);

    	    DBG$TRANSALATE_TYPECODE(.DTYPE);
    	    DTYPE_LENGTH(LENGTH);    	    
    	    END;


    	! Dynamic String Descriptor, is used for dynamically allocated strings.
    	!
    	[DSC$K_CLASS_D]:
    	    BEGIN
    	    DBG$PRINT(UPLIT BYTE(%ASCIC'dynamic string descriptor type,'), 0);
    	    DBG$TRANSALATE_TYPECODE(.DTYPE);
    	    DTYPE_LENGTH(LENGTH);
    	    END;


    	! Array Descriptor.
    	!
        [DSC$K_CLASS_A, DSC$K_CLASS_NCA, DSC$K_CLASS_UBA]:
    	    BEGIN
    	    SELECTONE .VAX_DESCR[DSC$B_CLASS] OF
    		SET


       		! Array Descriptor, is used to describe contiguous arrays of atomic
    		! data type or contiguous arrays of fixed length strings.
    		!
    		[DSC$K_CLASS_A]:
    	    	    DBG$PRINT(UPLIT BYTE(%ASCIC'array descriptor type,'), 0);


    		! Noncontiguous Array Descriptor describes an array where the storage
    		! of the array elements may be allocated with a fixed, nonzero number
    		! of bytes separating logically adjacent elements.
    		! 
    		[DSC$K_CLASS_NCA]:
    	    	    DBG$PRINT(UPLIT BYTE(%ASCIC 'noncontiguous array descriptor type,'), 0);


    		! Unaligned Bit Array Descriptor, is used to specified an array of
    		! unaligned bit strings.
    		!
    		[DSC$K_CLASS_UBA]:
    	    	    DBG$PRINT(UPLIT BYTE(%ASCIC 'unaligned bit array descriptor type,'), 0);
    		TES;

    	    DBG$PRINT(UPLIT BYTE(%ASCIC ' !UL dimensions,'), .VAX_DESCR[DSC$B_DIMCT]);


    	    ! Point to the lower and upper bounds of the array.
    	    !
    	    DBG$PRINT(UPLIT BYTE(%ASCIC ' bounds: ['), 0);
	    BOUNDS_PTR = VAX_DESCR[DSC$L_M1];
	    BOUNDS_PTR = BOUNDS_PTR[.VAX_DESCR[DSC$B_DIMCT]];
	    INCR BOUND_NO FROM 1 TO .VAX_DESCR[DSC$B_DIMCT] DO
		BEGIN
		IF (.BOUND_NO EQL .VAX_DESCR[DSC$B_DIMCT])
		THEN
    		    DBG$PRINT(UPLIT BYTE(%ASCIC '!SL:!SL]'),
    			.BOUNDS_PTR[((.BOUND_NO - 1) * 2)],
    			.BOUNDS_PTR[((.BOUND_NO - 1) * 2) + 1])
		ELSE
    		    DBG$PRINT(UPLIT BYTE(%ASCIC '!SL:!SL,'),
    			.BOUNDS_PTR[((.BOUND_NO - 1) * 2)],
    			.BOUNDS_PTR[((.BOUND_NO - 1) * 2) + 1]);
		END;

    	    END;


    	! Procedure Descriptor, is used to specifies its entry address and
    	! function value data type, if any.
    	!
    	[DSC$K_CLASS_P]:
    	    BEGIN
    	    DBG$PRINT(UPLIT BYTE(%ASCIC'procedure descriptor type,'), 0);
    	    DBG$TRANSALATE_TYPECODE(.DTYPE);
    	    IF .LENGTH EQL 0
    	    THEN
    		DBG$PRINT(UPLIT BYTE(%ASCIC', no function value is returned'), 0)
    	    ELSE
    		DBG$PRINT(UPLIT BYTE(%ASCIC', function value size: !UL'),
    			.LENGTH);

    	    END;


    	! Reserved for use by the VAX Debugger.
    	!
    	[DSC$K_CLASS_J]:
    	    BEGIN
    	    DBG$PRINT(UPLIT BYTE(%ASCIC'label descriptor type'), 0);
    	    END;


    	! Decimal Scalar String Descriptor, is used to describe decimal size 
    	! and scaling information for scalar data and simple strings.
    	!
    	[DSC$K_CLASS_SD]:
    	    BEGIN
            IF .VAX_DESCR[DSC$V_FL_BINSCALE]
            THEN
                DBG$PRINT(UPLIT BYTE(%ASCIC'binary scalar string descriptor type,'), 0)
            ELSE
                DBG$PRINT(UPLIT BYTE(%ASCIC'decimal scalar string descriptor type,'), 0);
    	    DBG$TRANSALATE_TYPECODE(.DTYPE);
    	    DTYPE_LENGTH(LENGTH);
    	    IF NOT ((.LENGTH EQL .VAX_DESCR[DSC$B_DIGITS]) AND 
    	            (.VAX_DESCR[DSC$B_DTYPE] EQL DSC$K_DTYPE_P))
    	    THEN
    		DTYPE_DIGITS(VAX_DESCR[DSC$B_DIGITS]);
    	    DTYPE_SCALE(VAX_DESCR[DSC$B_SCALE]);    	    
    	    END;


    	! Varying String Descriptor, is used for varying strings.
    	!
    	[DSC$K_CLASS_VS]:
    	    BEGIN
    	    DBG$PRINT(UPLIT BYTE(%ASCIC'varying string descriptor type,'), 0);
    	    DBG$TRANSALATE_TYPECODE(.DTYPE);
    	    DBG$PRINT(UPLIT BYTE(%ASCIC', size: !UL bytes'), .VAX_DESCR[DSC$W_MAXSTRLEN]);
    	    END;


    	! Varying String Array Descriptor, is used to specified an array
    	! of varying strings.
    	!
    	[DSC$K_CLASS_VSA]:
    	    BEGIN
    	    DBG$PRINT(UPLIT BYTE(%ASCIC 'varying string array descriptor type,'), 0);
    	    DBG$TRANSALATE_TYPECODE(.DTYPE);
    	    DBG$PRINT(UPLIT BYTE(%ASCIC ', size: !UL bytes'), .VAX_DESCR[DSC$W_MAXSTRLEN]);
    	    END;


    	! Unaligned Bit String Descriptor, is used to pass an unaligned bit
    	! string.
    	!
    	[DSC$K_CLASS_UBS]:
    	    BEGIN
    	    DBG$PRINT(UPLIT BYTE(%ASCIC 'unaligned bit string descriptor type,'), 0);
    	    DBG$TRANSALATE_TYPECODE(.DTYPE);
    	    DBG$PRINT(UPLIT BYTE(%ASCIC ', size: !UL bits'), .VAX_DESCR[DSC$W_LENGTH]);
    	    END;


    	[INRANGE, OUTRANGE]:
    	    BEGIN
    	    DBG$PRINT(UPLIT BYTE(%ASCIC 'undefined descriptor type'), 0);
    	    END;

    	TES;

    RETURN 0;
    END;

GLOBAL ROUTINE DBG$TRANSALATE_KIND(RSTPTR): =
!
! FUNCTION
!	Given RST kind field, transalte it into readable format, also
!	return the length of the RST entry.
!
! INPUT
!	KIND - Symbol's RST kind field.
!
! OUTPUTS
!	The length of the RST entry is returned.
!	
    BEGIN

    MAP
    	RSTPTR: REF RST$ENTRY;		! Pointer to Symbol's RST entry

    LOCAL
    	LENGTH;				! The length of the RST entry


    CASE .RSTPTR[RST$B_KIND] FROM RST$K_KIND_MINIMUM TO RST$K_KIND_MAXIMUM OF
    	SET

    	[RST$K_MODULE]:
    	    BEGIN
    	    DBG$PRINT(UPLIT BYTE(%ASCIC 'module'), 0);
    	    LENGTH = RST$K_MODENTSIZ;
    	    END;

    	[RST$K_ROUTINE]:
    	    BEGIN
    	    DBG$PRINT(UPLIT BYTE(%ASCIC 'routine'), 0);
    	    LENGTH = RST$K_ROUTENTSIZ;
    	    END;

    	[RST$K_BLOCK]:
    	    BEGIN
    	    DBG$PRINT(UPLIT BYTE(%ASCIC 'block'), 0);
    	    LENGTH = RST$K_LEXENTSIZ;
    	    END;

    	[RST$K_ENTRY]:
    	    BEGIN
    	    DBG$PRINT(UPLIT BYTE(%ASCIC 'entry'), 0);
    	    LENGTH = RST$K_EPTENTSIZ;
    	    END;

    	[RST$K_LABEL]:
    	    BEGIN
    	    DBG$PRINT(UPLIT BYTE(%ASCIC 'label'), 0);
    	    LENGTH = RST$K_LBLENTSIZ;
    	    END;

    	[RST$K_LINE]:
    	    BEGIN
    	    DBG$PRINT(UPLIT BYTE(%ASCIC 'line'), 0);
    	    LENGTH = RST$K_LINENTSIZ;
    	    END;

    	[RST$K_DATA]:
    	    BEGIN
    	    DBG$PRINT(UPLIT BYTE(%ASCIC 'data'), 0);
    	    LENGTH = RST$K_DATENTSIZ;
    	    END;

    	[RST$K_TYPCOMP]:
    	    BEGIN
    	    DBG$PRINT(UPLIT BYTE(%ASCIC 'record component'), 0);
    	    LENGTH = RST$K_DATENTSIZ;
    	    END;


    	! You really should not get this kind.
    	!
    	[RST$K_TYPE]:
    	    BEGIN
    	    DBG$PRINT(UPLIT BYTE(%ASCIC 'type'), 0);
    	    LENGTH = RST$K_TYPENTSIZ + .RSTPTR[RST$L_TYPCOMPCNT];
    	    END;


    	! You can get this kind only if /TYPE is specified.  Routine 
    	! GET_VARIANT is called.
    	!
    	[RST$K_VARIANT]:
    	    BEGIN
    	    DBG$PRINT(UPLIT BYTE(%ASCIC 'record variants'), 0);
    	    LENGTH = RST$K_VARENTSIZ + .RSTPTR[RST$L_VARSETCNT];
    	    END;


    	! You really should not get this kind.
    	!
    	[RST$K_INVOCNUM]:
    	    BEGIN
    	    DBG$PRINT(UPLIT BYTE(%ASCIC 'invocnum'), 0);
    	    LENGTH = RST$K_INVENTSIZ;
    	    END;


    	! You really should not get this kind.
    	!
    	[RST$K_OVERLOAD]:
    	    BEGIN
    	    DBG$PRINT(UPLIT BYTE(%ASCIC 'overloaded symbol'), 0);
    	    LENGTH = RST$K_OLENTSIZ;
    	    END;


	! Any other kind is invalid.
	!
    	[INRANGE, OUTRANGE]:
    	    BEGIN
    	    DBG$PRINT(UPLIT BYTE(%ASCIC 'invalid kind'), 0);
    	    LENGTH = 0;
    	    END;

    	TES;

    RETURN .LENGTH;

    END;

GLOBAL ROUTINE DBG$TRANSALATE_TYPECODE(TYPECODE): NOVALUE =
!
! FUNCTION
!	Transalate Data Type Code into user readable form.
!
! INPUTS
!	TYPECODE - Data Type Code.
!
! OUTPUTS
!	None.
!

    BEGIN

    CASE .TYPECODE FROM DSC$K_DTYPE_LOWEST TO DSC$K_DTYPE_HIGHEST OF
    	SET

    	[DSC$K_DTYPE_V]:
    	    DBG$PRINT(UPLIT BYTE(%ASCIC ' bit field'), 0);

    	[DSC$K_DTYPE_BU]:
    	    DBG$PRINT(UPLIT BYTE(%ASCIC ' byte logical'), 0);

    	[DSC$K_DTYPE_WU]:
    	    DBG$PRINT(UPLIT BYTE(%ASCIC ' word logical'), 0);

    	[DSC$K_DTYPE_LU]:
    	    DBG$PRINT(UPLIT BYTE(%ASCIC ' longword logical'), 0);

    	[DSC$K_DTYPE_QU]:
    	    DBG$PRINT(UPLIT BYTE(%ASCIC ' quadword logical'), 0);

    	[DSC$K_DTYPE_B]:
    	    DBG$PRINT(UPLIT BYTE(%ASCIC ' byte integer'), 0);

    	[DSC$K_DTYPE_W]:
    	    DBG$PRINT(UPLIT BYTE(%ASCIC ' word integer'), 0);

    	[DSC$K_DTYPE_L]:
    	    DBG$PRINT(UPLIT BYTE(%ASCIC ' longword integer'), 0);

    	[DSC$K_DTYPE_Q]:
    	    DBG$PRINT(UPLIT BYTE(%ASCIC ' quadword integer'), 0);

    	[DSC$K_DTYPE_F]:
    	    DBG$PRINT(UPLIT BYTE(%ASCIC ' F_floating'), 0);

    	[DSC$K_DTYPE_D]:
    	    DBG$PRINT(UPLIT BYTE(%ASCIC ' D_floating'), 0);

    	[DSC$K_DTYPE_FC]:
    	    DBG$PRINT(UPLIT BYTE(%ASCIC ' F_floating complex'), 0);

    	[DSC$K_DTYPE_DC]:
    	    DBG$PRINT(UPLIT BYTE(%ASCIC ' D_complex'), 0);

    	[DSC$K_DTYPE_T]:
    	    DBG$PRINT(UPLIT BYTE(%ASCIC ' character-coded text'), 0);

    	[DSC$K_DTYPE_NU]:
    	    DBG$PRINT(UPLIT BYTE(%ASCIC ' numeric string, unsigned'), 0);

    	[DSC$K_DTYPE_NL]:
    	    DBG$PRINT(UPLIT BYTE(%ASCIC ' numeric string, left separate sign'), 0);

    	[DSC$K_DTYPE_NLO]:
    	    DBG$PRINT(UPLIT BYTE(%ASCIC ' numeric string, left overpunched sign'), 0);

    	[DSC$K_DTYPE_NR]:
    	    DBG$PRINT(UPLIT BYTE(%ASCIC ' numeric string, right separate sign'), 0);

    	[DSC$K_DTYPE_NRO]:
    	    DBG$PRINT(UPLIT BYTE(%ASCIC ' numeric string, right overpunched sign'), 0);

    	[DSC$K_DTYPE_NZ]:
    	    DBG$PRINT(UPLIT BYTE(%ASCIC ' numeric string, zoned sign'), 0);

    	[DSC$K_DTYPE_P]:
    	    DBG$PRINT(UPLIT BYTE(%ASCIC ' packed decimal string'), 0);

    	[DSC$K_DTYPE_ZI]:
    	    DBG$PRINT(UPLIT BYTE(%ASCIC ' sequence of instructions'), 0);

    	[DSC$K_DTYPE_ZEM]:
    	    DBG$PRINT(UPLIT BYTE(%ASCIC ' procedure entry mask'), 0);

    	[DSC$K_DTYPE_DSC]:
    	    DBG$PRINT(UPLIT BYTE(%ASCIC ' descriptor'), 0);

    	[DSC$K_DTYPE_OU]:
    	    DBG$PRINT(UPLIT BYTE(%ASCIC ' octaword logical'), 0);

    	[DSC$K_DTYPE_O]:
    	    DBG$PRINT(UPLIT BYTE(%ASCIC ' octaword integer'), 0);

    	[DSC$K_DTYPE_G]:
    	    DBG$PRINT(UPLIT BYTE(%ASCIC ' G_floating'), 0);

    	[DSC$K_DTYPE_H]:
    	    DBG$PRINT(UPLIT BYTE(%ASCIC ' H_floating'), 0);

    	[DSC$K_DTYPE_GC]:
    	    DBG$PRINT(UPLIT BYTE(%ASCIC ' G_floating complex'), 0);

    	[DSC$K_DTYPE_HC]:
    	    DBG$PRINT(UPLIT BYTE(%ASCIC ' H_floating complex'), 0);

    	[DSC$K_DTYPE_CIT]:
    	    DBG$PRINT(UPLIT BYTE(%ASCIC ' COBOL intermediate temporary'), 0);

    	[DSC$K_DTYPE_BPV]:
    	    DBG$PRINT(UPLIT BYTE(%ASCIC ' bound procedure value'), 0);

    	[DSC$K_DTYPE_BLV]:
    	    DBG$PRINT(UPLIT BYTE(%ASCIC ' bound label value'), 0);

    	[DSC$K_DTYPE_VU]:
    	    DBG$PRINT(UPLIT BYTE(%ASCIC ' bit unaligned'), 0);

    	[DSC$K_DTYPE_VT]:
    	    DBG$PRINT(UPLIT BYTE(%ASCIC ' varying text'), 0);

    	[INRANGE, OUTRANGE]:
    	    BEGIN


    	    ! This is the only one which is not VAX Standard Data Type.
    	    !
    	    IF .TYPECODE EQL DST$K_BOOL
    	    THEN
    	        DBG$PRINT(UPLIT BYTE(%ASCIC ' boolean'), 0)
    	    ELSE
    	        DBG$PRINT(UPLIT BYTE(%ASCIC ' undefined type'), 0);

    	    END;

    	TES;

    RETURN 0;

    END;

GLOBAL ROUTINE DBG$TRANSALATE_REG(REG_NUM): NOVALUE =
!
! FUNCTION
!	This routine transalate register number into register name.
!
! INPUTS
!	REG_NUM - register number (from 0 to 15).
!
! OUTPUTS
!	None.
!

    BEGIN

    IF (.REG_NUM GEQ 0) AND (.REG_NUM LEQ 11)
    THEN
    	DBG$PRINT(UPLIT BYTE(%ASCIC '%R!UL'), .REG_NUM)
    ELSE
    	BEGIN
    	CASE .REG_NUM FROM 12 TO 15 OF
    	    SET
    	    [12]: DBG$PRINT(UPLIT BYTE(%ASCIC '%AP'), 0);
    	    [13]: DBG$PRINT(UPLIT BYTE(%ASCIC '%FP'), 0);
    	    [14]: DBG$PRINT(UPLIT BYTE(%ASCIC '%SP'), 0);
    	    [15]: DBG$PRINT(UPLIT BYTE(%ASCIC '%PC'), 0);
    	    TES;
    	END;

    RETURN 0;
    END;

GLOBAL ROUTINE DBG$DUMP_HEX(ADDRESS,LENGTH,RELADDR,HEADER_STRING): NOVALUE =
!
! FUNCTION
!	This routine is taken from TOOL$:DBGDMPDST.B32, and is modified some.
!
!	This routine dumps the specified number of bytes, starting at the
!     	specified address, in hex. The output is formatted as four longwords
!     	to a line followed by the start address of the four longword unit. A
!     	header, if supplied, is output at the begining of the first line of text.
!     	The output text is right justified to 78 columns.
!
! INPUTS
!     ADDRESS        - The start address of the block to be dumped.
!
!     LENGTH         - The size of the block to be dumped in bytes.
!
!     RELADDR        - The start address relative to the DST. This is the value
!                      printed at the end of an output line of text, as
!                      mentioned above.
!
!     HEADER_STRING  - Start address of the header name in counted ASCII. This
!                      string is printed at the begining of the first line
!                      of text.
!     
!
! OUTPUTS
!     None
!
					
    BEGIN

    MAP
        HEADER_STRING : REF VECTOR[,BYTE]; ! Location of ASCIC header name.

    LOCAL
        BYTE_LENGTH,                    ! Remaining size of input block in bytes.
        OUTBLOCK : VECTOR[79,BYTE],     ! Output buffer for storing the ASCII
                                        !   	hex characters.
        OUTBLOCK_INDEX,                 ! Variable to index OUTBLOCK.
        REL_ADDRESS,                    ! Address relative to start of DST.
        START_ADDRESS,                  ! Start address of block to be dumped.
        VAL_SIZE,                       ! Size in bytes of the value to be
                                        ! converted to ASCII hex.
        STRNG_DESC : BLOCK[8,BYTE];     ! String descriptor passed as argument
                                        !   	to external routines.



    ! The locally used variables are equated to the formal parameters.
    !
    START_ADDRESS = .ADDRESS;
    BYTE_LENGTH  = .LENGTH;
    REL_ADDRESS = .RELADDR;


    ! The index into OUTBLOCK is initialized for the fill-in.
    !
    OUTBLOCK_INDEX = 60;
    VAL_SIZE = 4;


    ! The fixed parts of the string descriptor are set up.
    !
    STRNG_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
    STRNG_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
    STRNG_DESC [DSC$W_LENGTH] = 8;


    ! The output buffer is cleared & the header string shifted into
    ! the first part of the buffer. 
    !
    CH$FILL(' ',79,OUTBLOCK[0]);
    CH$MOVE(.HEADER_STRING[0],HEADER_STRING[1],OUTBLOCK[1]); 
 

    ! The input buffer is looped through, converting one longword (or trailing
    ! bytes) at a time to hex, till byte count is exhausted.
    !
    WHILE .BYTE_LENGTH GTR 0 DO
        BEGIN
       

        ! The minimum number of digits to dump is adjusted if there is less
        ! than a longword remaining. The conversion to hex is made & the buffer
        ! pointers updated.
        !
        IF .BYTE_LENGTH LSS 4 THEN VAL_SIZE = .BYTE_LENGTH;
        STRNG_DESC [DSC$A_POINTER] = OUTBLOCK[.OUTBLOCK_INDEX];
        OTS$CVT_L_TZ(.START_ADDRESS,STRNG_DESC,(2*.VAL_SIZE),.VAL_SIZE);
        BYTE_LENGTH = .BYTE_LENGTH - 4;
        START_ADDRESS = .START_ADDRESS + 4;
        OUTBLOCK_INDEX = .OUTBLOCK_INDEX - 10;
      

        ! If the buffer is full or the byte count is exhausted, a text line 
        ! is output.
        !
        IF (.OUTBLOCK_INDEX LSS 30) OR (.BYTE_LENGTH LEQ 0) 
        THEN
            BEGIN           


            ! The string descriptor is set up to receive the converted address.
            ! The rel address is converted, stored, updated for the next pass &
            ! the colon separating the address from text is entered.
            !
            IF .REL_ADDRESS GEQ %X'10000'
            THEN
                STRNG_DESC [DSC$W_LENGTH] = 8

            ELSE
                STRNG_DESC [DSC$W_LENGTH] = 4;

            STRNG_DESC [DSC$A_POINTER] = OUTBLOCK[71];
            OTS$CVT_L_TZ(REL_ADDRESS,STRNG_DESC,.STRNG_DESC[DSC$W_LENGTH],4);
            REL_ADDRESS = .REL_ADDRESS + 16;
            OUTBLOCK[70] = ':';


            ! The filled buffer is output as a line of text.
            !
            STRNG_DESC [DSC$W_LENGTH] = 78;
            STRNG_DESC [DSC$A_POINTER] = OUTBLOCK[1];
    	    OUTBLOCK[0] = 78;
	    DBG$PRINT(UPLIT BYTE(%ASCIC '!AC'), OUTBLOCK);
    	    DBG$NEWLINE();


            ! OUTBLOCK is cleared for more input and loop parameters reset.
            !
            STRNG_DESC [DSC$W_LENGTH] = 8;
    	    CH$FILL(' ',79,OUTBLOCK[0]);
            OUTBLOCK_INDEX = 60;
            END;

        END;
    

    ! After all bytes have been successfully dumped, control is returned to
    ! the calling routine.
    !
    RETURN 0;
    END;        
       

ROUTINE BLD_SCOPE_SEARCH_LIST(NCANDS, SCOPE): NOVALUE =
!
! FUNCTION
!	This routine builds a list of scopes for the candidate symbols
!	to be searched.  If this list has not been built, this routine
!	will create a memory block for this list.  If this list is too
!	small, this routine will expand the list by getting more memory
!	blocks.  Then the search scope is entered to the list.  Each time
!	this routine is called, the scope count is up by 1.
!
! INPUTS
!	NCANDS	- Keep track the number of scopes on the scope search list.
!	SCOPE	- The desired search scope for the candidate symbol.
!
! OUTPUTS
!	None.
!

    BEGIN

    MAP
    	NCANDS: REF VECTOR[1];		! Keep track of the number of scopes

    LOCAL
    	OLDLST: REF VECTOR[,LONG],	! Pointer to scope search list about
    					!	to be copied to a larger
    					!	memory block
    	SCOPE_CNT;			! Scope count


    ! Update the scope count.
    !
    SCOPE_CNT = .NCANDS[0];
    SCOPE_CNT = .SCOPE_CNT + 1;


    ! If we do not yet have a scope search list memory block, get one and
    ! initialize its first element to give the list size that will fit in
    ! the block.
    !
    IF .DBG$_SCOPELST EQL 0
    THEN
    	BEGIN
    	DBG$_SCOPELST = DBG$GET_MEMORY(11);
    	DBG$_SCOPELST[0] = 10;
    	END;


    ! Note that we have to expand the scope search list memory block if it
    ! is too small.
    !
    IF .SCOPE_CNT GTR .DBG$_SCOPELST[0]
    THEN
    	BEGIN
    	OLDLST = .DBG$_SCOPELST;
    	DBG$_SCOPELST = DBG$GET_MEMORY(.OLDLST[0] + 11);
    	CH$MOVE(4*(.OLDLST[0]+1), .OLDLST, .DBG$_SCOPELST);
    	DBG$_SCOPELST[0] = .DBG$_SCOPELST[0] + 10;
    	DBG$REL_MEMORY(.OLDLST);
    	END;
    

    ! Now enter the scope to this list, and set the count.
    !
    DBG$_SCOPELST[.SCOPE_CNT] = .SCOPE;
    NCANDS[0] = .SCOPE_CNT;
    RETURN 0;

    END;

ROUTINE GET_BLISS_SPECIAL_CASES(DSTPTR): NOVALUE =
!
! FUNCTION
!	This routine handles the data type information for BLISS SPECIAL CASES
!	DST Record.  Its DST type is DST$K_BLI, RST kind is RST$K_DATA, and
!	RST Fcode is RST$K_TYPE_BLIDATA.
!
! 	The text printed will be of the form:
!
!           +--                         --+           
!   	ref | vector [UNITS,BWL[,signed]] | ,[formal] 
!           | bitvector [UNITS]           |           
!           | block [UNITS,BWL]           |           
!           | blockvector [N,BS,BWL]      |
!           +--                         --+
!
!  	UNITS -- the number of units.
!	BWL   -- BYTE, WORD or LONG.
!	N, BS -- the size values for BLOCKVECTOR as defined in the 
!	    	 BLISS-32 Language manual.  
!
! INPUT
!	DSTPTR - Pointer to DST$RECORD, fields can be (DST$BLI_FIELDS,
!		 DST$BLI_VEC_FIELDS, DST$BLI_BITVEC_FIELDS,
!		 DST$BLI_BLOCK_FIELDS, DST$BLI_BLKVEC_FIELDS).
!
! OUTPUT
!	None.
!

    BEGIN

    MAP
	DSTPTR: REF DST$RECORD;

    LOCAL
	TRAIL1: REF DST$BLI_TRAILER1,	! Pointer to trailer 1
	TRAIL2: REF DST$BLI_TRAILER2;	! Pointer to trailer 2


    ! Set up pointers to the trailing fields.
    !
    TRAIL1 = DSTPTR[DST$A_BLI_TRLR1] + .DSTPTR[DST$B_BLI_LNG];
    TRAIL2 = TRAIL1[DST$A_BLI_TRLR2] + .TRAIL1[DST$B_BLI_NAME];
    IF .DSTPTR[DST$V_BLI_REF] 
    THEN 
    	DBG$PRINT(UPLIT BYTE(%ASCIC', ref'), 0)
    ELSE
    	DBG$PRINT(UPLIT BYTE(%ASCIC','), 0);


    ! Get the structure information of this symbol.
    !
    CASE .DSTPTR[DST$V_BLI_STRUC] FROM DST$K_BLI_NOSTRUC TO DST$K_BLI_BLKVEC OF
	SET


    	! No structure information.
    	!
	[DST$K_BLI_NOSTRUC]:
	    BEGIN
    	    DBG$PRINT(UPLIT BYTE(%ASCIC ' no field structure'), 0);
	    END;


    	! Vector.
    	!
	[DST$K_BLI_VEC]:
	    BEGIN
    	    DBG$PRINT(UPLIT BYTE(%ASCIC' vector[!UL,'), .DSTPTR[DST$L_BLI_VEC_UNITS]);
    	    BLIUNIT(DSTPTR[DST$V_BLI_VEC_UNIT_SIZE]);
	    IF .DSTPTR[DST$V_BLI_VEC_SIGN_EXT]
	    THEN
		DBG$PRINT(UPLIT BYTE(%ASCIC',signed]'), 0)
	    ELSE
		DBG$PRINT(UPLIT BYTE(%ASCIC']'), 0);

	    END;


    	! Bitvector.
    	!
	[DST$K_BLI_BITVEC]:
	    BEGIN
    	    DBG$PRINT(UPLIT BYTE(%ASCIC ' bitvector[!UL]'), .DSTPTR[DST$L_BLI_BITVEC_SIZE]);
	    END;


    	! Block.
    	!
	[DST$K_BLI_BLOCK]:
	    BEGIN
    	    DBG$PRINT(UPLIT BYTE
    		(%ASCIC ' block[!UL,'), .DSTPTR[DST$L_BLI_BLOCK_UNITS]);
    	    BLIUNIT(DSTPTR[DST$V_BLI_BLOCK_UNIT_SIZE]);
    	    DBG$PRINT(UPLIT BYTE(%ASCIC ']'), 0);
	    END;


    	! Blockvector.
    	!
	[DST$K_BLI_BLKVEC]:
	    BEGIN
    	    DBG$PRINT(UPLIT BYTE(%ASCIC ' blockvector[!UL,!UL,'), 
    		.DSTPTR[DST$L_BLI_BLKVEC_BLOCKS],
    		.DSTPTR[DST$L_BLI_BLKVEC_UNITS]);
	    BLIUNIT(DSTPTR[DST$B_BLI_BLKVEC_UNIT_SIZE]);
    	    DBG$PRINT(UPLIT BYTE(%ASCIC ']'), 0);
	    END;

    	[INRANGE, OUTRANGE]:
    	    BEGIN
    	    DBG$PRINT(UPLIT BYTE(%ASCIC ' invalid structure'), 0);
    	    END;

	TES;

    IF .DSTPTR[DST$B_BLI_FORMAL] EQL 1
    THEN
	DBG$PRINT(UPLIT BYTE(%ASCIC', formal'), 0);

    IF .TRAIL2[DST$L_BLI_SIZE] NEQ 0 
    THEN 
    	DBG$PRINT(UPLIT BYTE(%ASCIC', size: !UL bytes'), .TRAIL2[DST$L_BLI_SIZE]);

    RETURN 0;

    END;

ROUTINE GET_VARIANT(VARIANT_SYMID): NOVALUE =
!
! FUNCTION
!	Get information from the RST for a variant.
!
! INPUTS
!	VARIANT_SYMID - One of the Record Component RST entries in RST Entry
!			for Data Type.
!
! OUTPUTS
!	None.
!

    BEGIN

    MAP
    	VARIANT_SYMID: REF RST$ENTRY;	! Pointer to RST entry for variant

    LOCAL
    	BITSIZE,			! The size in bits of the given item
    	COMPVECPTR: REF VECTOR[,LONG],	! Pointer to a vector of variant
    					!	component SYMIDs and tag values
    	DSTPTR: REF DST$RECORD,		! Pointer to DST entry
    	ELTVECPTR,			! Pointer to a vector of field SYMIDs
    	LENGTH,				! Length of RST entry
    	LIST_ID: REF RST$VAR_ENTRY,	! Pointer to variant component RST entry
    	NAME: REF VECTOR[,BYTE],	! Pointer to counted ASCII string
    	NCOMPS,				! The number of variant components
    	NELTS,				! The number of fields
    	NTAGS,				! The number of tag blocks
    	SIZE,				! The size in bits of this variant
    	TAG: REF RST$ENTRY,				! SYMID of the variant tag field
    	TAGVECPTR: REF VECTOR[,LONG];	! Pointer to a vector of tag value ranges



    DBG$NEWLINE();
    DBG$STA_TYP_VARIANT(.VARIANT_SYMID, NCOMPS, COMPVECPTR, TAG, BITSIZE);
    DBG$PRINT_CONTROL(DBG$K_PRTSET_RLMARGIN, +2);
    DBG$PRINT(UPLIT BYTE(%ASCIC 'with !UL '), .NCOMPS);
    LENGTH = DBG$TRANSALATE_KIND(.VARIANT_SYMID);    
    NAME = DBG$GET_DST_NAME(.TAG[RST$L_DSTPTR]);
    IF .NAME[0] NEQ 0
    THEN
        DBG$PRINT(UPLIT BYTE(%ASCIC ', tag: !AC'), .NAME)
    ELSE
        DBG$PRINT(UPLIT BYTE(%ASCIC ', tag: anonymous'), 0);

    ITEM_SIZE(BITSIZE);
    DBG$NEWLINE();
    INCR I FROM 0 TO .NCOMPS - 1 DO
    	BEGIN
    	LIST_ID = .COMPVECPTR[.I];
    	DBG$STA_TYP_VARIANT_COMP(.LIST_ID, NELTS, ELTVECPTR, NTAGS, 
    		TAGVECPTR, SIZE);
        DBG$PRINT(UPLIT BYTE(%ASCIC 'variant !UL:'), .I + 1);
        DBG$PRINT(UPLIT BYTE(%ASCIC ' !UL fields'), .NELTS);
    	ITEM_SIZE(SIZE);
    	DBG$NEWLINE();
    	END;

    DBG$_PRINT_FLAG = FALSE;
    IF .DBG$_QUALIFIER[SYMBOL_RST]
    THEN
    	DBG$DUMP_HEX(.VARIANT_SYMID, .LENGTH * 4, .VARIANT_SYMID,
    		     UPLIT BYTE(%ASCIC '        variant RST '));

    DSTPTR = .VARIANT_SYMID[RST$L_DSTPTR];
    IF .DBG$_QUALIFIER[SYMBOL_DST]
    THEN
    	DBG$DUMP_HEX(.DSTPTR, .DSTPTR[DST$B_LENGTH] + 1, .DSTPTR,
    		     UPLIT BYTE(%ASCIC '        variant DST '));

    DBG$PRINT_CONTROL(DBG$K_PRTSET_RLMARGIN, -2);
    RETURN 0;

    END;

ROUTINE SHOW_SYMBOL(RSTPTR, NCANDS): NOVALUE =
!
! FUNCTION
! 	This routine shows the kind of the symbol and the name of the symbol
!	in full pathname format.  Additional information, such as data types
!	or address specifications, or RST, or DST is also shown if the
!	qualifiers are given.
!
! INPUTS
!	RSTPTR	- Symbol's RST entry
!	NCANDS	- Keep track of the number of symbols is shown
!
! OUTPUTS
!	None.
!

    BEGIN

    MAP
    	NCANDS: REF VECTOR[1],		! Keep track of outputted symbols
    	RSTPTR: REF RST$ENTRY;		! Selected candidate symbol RST entry

    LOCAL
	DSTPTR: REF DST$RECORD,		! Pointer to DST entry
    	LANGUAGE: REF VECTOR[,BYTE],	! Pointer to counted ASCII string
    	LENGTH,				! Length for RST entry
    	KIND,				! Symbol's kind field
	OL_TRAILER: 			! Overloaded symbol's DST trailer
		REF DST$OVERLOAD_TRLR,	!
	OL_VECTOR: REF VECTOR[,LONG],	! Vector of DST pointers for overloaded
					!      symbols
    	PATHNAME,			! Pointer to returned pathname vector
    	POOLID,				! Temporary Memory Pool Stack ID
    	SIZE,				! Length for TYPE RST entry
    	SYMBOL_CNT,			! Symbol outputted count
    	SYMNAME,			! Pointer to a counted string
    	TYPEID: REF RST$ENTRY;		! Pointer to TYPE RST entry



    ! Abort this operation now if the Control-Y DEBUG flag is set.
    !
    $ABORT_ON_CONTROL_Y;


    ! Everytime this routine is called, increment the count up by 1.
    !
    SYMBOL_CNT = .NCANDS[0];
    SYMBOL_CNT = .SYMBOL_CNT + 1;


    ! Initialization.  Assume symbol does not have any type and the length
    ! of the TYPE RST entry is zero.
    !
    TYPEID = 0;
    SIZE = 0;


    ! Get symbol's kind field, and transalate it into user readable form.
    !
    DBG$STA_SYMKIND(.RSTPTR, KIND);
    LENGTH = DBG$TRANSALATE_KIND(.RSTPTR);


    ! Push the tempory memory pointer.
    !
    POOLID = DBG$PUSH_TEMPMEM();


    ! Get the symbol's fully qualified pathname descriptor, and then call
    ! DBG$NPATHDESC_TO_CS to translate the contents of the pathname descriptor
    ! into a printable form.
    !
    DBG$STA_SYMPATHNAME(.RSTPTR, PATHNAME);
    DBG$NPATHDESC_TO_CS(.PATHNAME, SYMNAME);
    DBG$PRINT(UPLIT BYTE(%ASCIC ' !AC'), .SYMNAME);


    ! Print out the Language used for module.
    !
    IF .KIND EQL RST$K_MODULE
    THEN
        BEGIN
    	DSTPTR = .RSTPTR[RST$L_DSTPTR];
    	LANGUAGE = DBG$LANGUAGE(.DSTPTR[DST$L_MODBEG_LANGUAGE]);
    	DBG$PRINT(UPLIT BYTE(%ASCIC ', language !AC'), .LANGUAGE);
    	END;

    	
    ! Check to see if this symbol is global symbol.  Mark it if so.
    !
    IF .RSTPTR[RST$V_GLOBAL]
    THEN
    	DBG$PRINT(UPLIT BYTE(%ASCIC ' (global)'), 0);


    ! Ouput symbol kind and name, or (global).
    !
    DBG$NEWLINE();


    ! Print the instances for an Overloaded symbol.
    !
    IF .KIND EQL RST$K_OVERLOAD
    THEN
	BEGIN
	DBG$STA_SYMPATHNAME( .RSTPTR[ RST$L_UPSCOPEPTR ], PATHNAME );
	DBG$NPATHDESC_TO_CS(.PATHNAME, SYMNAME);
	DSTPTR = .RSTPTR[ RST$L_DSTPTR ];
	OL_TRAILER = DSTPTR[ DST$A_OL_TRAILER ] + .DSTPTR[ DST$B_OL_NAME ];
	OL_VECTOR = OL_TRAILER[ DST$A_OL_VECTOR ];
	INCR I FROM 0 TO .OL_TRAILER[ DST$W_OL_COUNT ] -1 DO
	    BEGIN
	    DBG$PRINT(UPLIT BYTE(%ASCIC '  overloaded instance !AC'), .SYMNAME);
	    DBG$PRINT(UPLIT BYTE ( %ASCIC'\!AC' ), 
			DBG$GET_DST_NAME(DBG$RST_DST_PTR(.OL_VECTOR[.I] +
			.DST$BEGIN_ADDR)));
	    DBG$NEWLINE();
	    END;

	END;


    ! Pop the temporary memory pointer.
    !
    DBG$POP_TEMPMEM(.POOLID);


    ! Output additional information according to the given command qualifier.
    ! /ADDRESS -- Print the address specification for each selected symbol.
    !
    IF .DBG$_QUALIFIER[SYMBOL_ADDRESS] AND .KIND NEQ RST$K_MODULE
    THEN
    	BEGIN
    	DBG$PRINT_CONTROL(DBG$K_PRTSET_LMARGIN, 4);
    	SHOW_SYMBOL_ADDRESS(.RSTPTR);
        DBG$PRINT_CONTROL(DBG$K_PRTSET_LMARGIN, 0);
    	END;


    ! /TYPE -- Print data or record component type inforamtion for each 
    ! selected symbol.  Set the context needed for subsequent DST value
    ! spec evaluation.
    !
    IF .DBG$_QUALIFIER[SYMBOL_TYPE] AND
       NOT .RSTPTR[RST$V_GLOBAL] AND
       (.KIND EQL RST$K_DATA OR .KIND EQL RST$K_TYPCOMP)
    THEN 
    	BEGIN
    	DBG$STA_SETCONTEXT(.RSTPTR);
    	DBG$_PRINT_FLAG = TRUE;
    	DBG$PRINT_CONTROL(DBG$K_PRTSET_RLMARGIN, +4);
    	SHOW_SYMBOL_TYPE(.RSTPTR);
    	DBG$PRINT_CONTROL(DBG$K_PRTSET_RLMARGIN, -4);
    	END;


    ! If data or record component symbol has TYPE field, get a bit more
    ! TYPE RST information about this symbol for /RST and /DST.
    !
    IF .KIND EQL RST$K_DATA OR
       .KIND EQL RST$K_TYPCOMP
    THEN
    	IF .RSTPTR[RST$L_TYPEPTR] NEQ 0
    	THEN 
    	    BEGIN
    	    TYPEID = .RSTPTR[RST$L_TYPEPTR];
    	    SIZE = RST$K_TYPENTSIZ + .TYPEID[RST$L_TYPCOMPCNT];
    	    END;


    ! /RST -- Print each selected symbol's RST entry in hexadecimal.
    ! (for developers only.)
    !
    IF .DBG$_QUALIFIER[SYMBOL_RST]
    THEN
    	BEGIN
    	DBG$DUMP_HEX(.RSTPTR, .LENGTH * 4, .RSTPTR, 
    		     UPLIT BYTE(%ASCIC '    RST entry dump  '));


    	! If the symbol has TYPE RST entry, dump it as well.
    	!
    	IF .TYPEID NEQ 0 THEN DBG$DUMP_HEX(.TYPEID, .SIZE * 4, .TYPEID,
		     UPLIT BYTE(%ASCIC '    TYPE RST entry  '));
    	END;


    ! /DST -- Print each selected symbol's DST entry in hexadecimal.
    ! (for developers only.)
    !
    IF .DBG$_QUALIFIER[SYMBOL_DST]
    THEN
    	BEGIN
    	DSTPTR = .RSTPTR[RST$L_DSTPTR];
    	DBG$DUMP_HEX(.DSTPTR, .DSTPTR[DST$B_LENGTH] + 1, .DSTPTR,
    		     UPLIT BYTE(%ASCIC '    DST entry dump  '));

    	! Save the value of DSTPTR as "\". This is useful for poking
    	! the DST in tests. It doesn't affect behavior that the user
    	! sees since /DST is under the control of developer 0.
    	!
    	DBG$SAVE_VAL(DBG$MAKE_INTEGER_DESC(.DSTPTR));

    	! If the symbol has TYPE RST DST entry, dump it as well.
    	!
    	IF .TYPEID NEQ 0
    	THEN
    	    BEGIN
    	    DSTPTR = .TYPEID[RST$L_DSTPTR];
    	    DBG$DUMP_HEX(.DSTPTR, .DSTPTR[DST$B_LENGTH] + 1, .DSTPTR,
    		     UPLIT BYTE(%ASCIC '    TYPE DST entry  '));
    	    END;

    	END;


    ! Update the count.
    !
    NCANDS[0] = .SYMBOL_CNT;
    RETURN 0;

    END;

ROUTINE SHOW_SYMBOL_ADDRESS(SYMID): NOVALUE =
! 
! FUNCTION
!	This routine takes a SYMID and shows the address information associated
!	with the input SYMID.
!
! INPUTS
!	SYMID - The SYMID for the symbol.
!
! OUTPUTS
!	None.
!

    BEGIN

    MAP
    	SYMID: REF RST$ENTRY;		! Pointer to input symbol's RST entry

    LOCAL
    	ADDRKIND,			! Symbol's address kind
    	ADDRPTR: VECTOR[2],		! Symbol's address vector
    	BLITRLR: REF DST$BLI_TRAILER1,	! Pointer to Bliss DST record trailer
    	BLIVALSPEC: BLOCK[8,BYTE]	! Value Spec buffer for Bliss Special
    		FIELD(DST$VS_HDR_FIELDS),!	cases DST record
    	DSTPTR: REF DST$RECORD,		! Pointer to DST Record
    	VALSPEC: REF DST$VAL_SPEC;	! Pointer to DST record's value spec


    VALSPEC = DBG$STA_SYMADDR(.SYMID, ADDRPTR, ADDRKIND);
    CASE .ADDRKIND FROM DBG$K_ADDRKIND_LITERAL TO DBG$K_ADDRKIND_INVALID OF
        SET


    	! This is a literal value.
    	!
    	[DBG$K_ADDRKIND_LITERAL]:
    	    BEGIN
    	    DBG$PRINT(UPLIT BYTE(%ASCIC 'constant: !SL'), ..ADDRPTR[0]);
    	    END;


    	! This is an address or descriptor representation.
    	!
    	[DBG$K_ADDRKIND_ADDR, DBG$K_ADDRKIND_DESC]:
    	    BEGIN
    	    IF .ADDRKIND EQL DBG$K_ADDRKIND_ADDR
    	    THEN
    	        DBG$PRINT(UPLIT BYTE(%ASCIC 'address: '), 0)
    	    ELSE
    	        DBG$PRINT(UPLIT BYTE(%ASCIC 'descriptor address: '), 0);


    	    ! For Bliss Data Items, if the address interprestation is not
    	    ! complete, there are some extra work has to be done in order
    	    ! to get the contents of the Val Spec.  (This excersize is done
    	    ! in DBG$STA_ADDRSPEC, unfortunately, the value needed is local to
    	    ! that routine, so this piece of code is reproduce that value
    	    ! from the DST)
    	    !
    	    DSTPTR = .SYMID[RST$L_DSTPTR];
    	    IF (.ADDRPTR[0] LSS 0) AND (.DSTPTR[DST$B_TYPE] EQL DST$K_BLI)
    	    THEN
    		BEGIN
    		BLIVALSPEC[DST$B_VS_VFLAGS] = .DSTPTR[DST$B_BLI_VFLAGS];
    		BLITRLR = DSTPTR[DST$A_BLI_TRLR1] + .DSTPTR[DST$B_BLI_LNG];
    		BLIVALSPEC[DST$L_VS_VALUE] = .BLITRLR[DST$L_BLI_VALUE];
    		VALSPEC = BLIVALSPEC[DST$B_VS_VFLAGS];
    		WHILE .VALSPEC[DST$B_VS_VFLAGS] EQL DST$K_VFLAGS_TVS DO
    		    VALSPEC = VALSPEC[DST$A_VS_TVS_BASE] + .VALSPEC[DST$L_VS_TVS_OFFSET];
    		END;

    		
    	    ! Check to see if the address interpretation is complete or not.
    	    ! If it is incomplete (indicated by -1) then we have some more
    	    ! work to do.
    	    !
    	    IF .ADDRPTR[0] LSS 0
    	    THEN
    		BEGIN
    		IF .VALSPEC[DST$V_VS_INDIRECT]
    		THEN
    		    DBG$PRINT(UPLIT BYTE(%ASCIC '.('), 0);

    		IF .VALSPEC[DST$V_VS_DISP]
    		THEN
    		    BEGIN
    		    LOCAL
    			REG_NUM;

    		    DBG$PRINT(UPLIT BYTE(%ASCIC '.'), 0);
    		    REG_NUM = .VALSPEC[DST$V_VS_REGNUM];
    		    DBG$TRANSALATE_REG(.REG_NUM);
    		    IF .VALSPEC[DST$L_VS_VALUE] LSS 0 
    		    THEN 
    			DBG$PRINT(UPLIT BYTE(%ASCIC '!SL'), .VALSPEC[DST$L_VS_VALUE]);

    		    IF .VALSPEC[DST$L_VS_VALUE] GTR 0
    		    THEN
			DBG$PRINT(UPLIT BYTE(%ASCIC '+!UL'), .VALSPEC[DST$L_VS_VALUE]);

    		    END

    		ELSE
	    	    DBG$PRINT(UPLIT BYTE(%ASCIC '!XL'), .VALSPEC[DST$L_VS_VALUE]);

    		IF .VALSPEC[DST$V_VS_INDIRECT]
    		THEN
    		    DBG$PRINT(UPLIT BYTE(%ASCIC ')'), 0);

    		END

    	    ELSE
    		DBG$PRINT(UPLIT BYTE(%ASCIC '!XL'), .ADDRPTR[0]);

    	    END;


    	! This a register.
    	!
    	[DBG$K_ADDRKIND_REG]:
    	    BEGIN
    	    DBG$PRINT(UPLIT BYTE(%ASCIC 'address: '), 0);
    	    DBG$TRANSALATE_REG(.ADDRPTR[0]);    	    
    	    END;


    	! This is an absolute address.
    	!
    	[DBG$K_ADDRKIND_ABS]:
    	    BEGIN
    	    DBG$PRINT(UPLIT BYTE(%ASCIC 'address: !XL'), .ADDRPTR[0]);


    	    ! The second longword may have contain the end address of the
    	    ! lexcial entity.  But, for global routine, start address is
    	    ! the same as end address in RST entry.  And also for Entry point,
    	    ! or Label, there is no end address.
    	    !
    	    IF (.ADDRPTR[1] NEQ 0) AND (.ADDRPTR[0] NEQ .ADDRPTR[1])
    	    THEN
    	        DBG$PRINT(UPLIT BYTE(%ASCIC ', size: !UL bytes'), 
    			  .ADDRPTR[1] - .ADDRPTR[0] + 1);
    	    END;


    	! This address is a bit offsets.
    	!
    	[DBG$K_ADDRKIND_BITOFF]:
    	    BEGIN
    	    DBG$PRINT(UPLIT BYTE
    		(%ASCIC 'address: offset !UL bytes'), .ADDRPTR[0]);
    	    IF .ADDRPTR[1] NEQ 0
    	    THEN
    		DBG$PRINT(UPLIT BYTE(%ASCIC ' !UL bits'), .ADDRPTR[1]);

    	    DBG$PRINT(UPLIT BYTE(%ASCIC ' from beginning of record'), 0);
    	    END;


    	! This is Bliss Field data.
    	!
    	[DBG$K_ADDRKIND_BLIFLD]:
    	    BEGIN
    	    LOCAL
    		FLDCOMP_PTR: REF VECTOR;

    	    DBG$PRINT(UPLIT BYTE(%ASCIC 'bliss field:'), 0);
    	    DSTPTR = .SYMID[RST$L_DSTPTR];
    	    FLDCOMP_PTR 
    		= DSTPTR[DST$B_BLIFLD_NAME] + .DSTPTR[DST$B_BLIFLD_NAME] + 1;
    	    DBG$PRINT(UPLIT BYTE(%ASCIC ' ['), 0);
    	    INCR FLDCOMP_NO FROM 1 TO .DSTPTR[DST$L_BLIFLD_COMPS] DO
    		BEGIN
    		IF (.FLDCOMP_NO EQL .DSTPTR[DST$L_BLIFLD_COMPS])
    		THEN
    		    DBG$PRINT(UPLIT BYTE(%ASCIC '!SL]'), .FLDCOMP_PTR[.FLDCOMP_NO - 1])
    		ELSE
    		    DBG$PRINT(UPLIT BYTE(%ASCIC '!SL,'), .FLDCOMP_PTR[.FLDCOMP_NO - 1]);
    	    	END;

    	    END;


    	! This address is too complex to calculate.
    	!
    	[DBG$K_ADDRKIND_COMPLEX]:
    	    BEGIN
    	    DBG$PRINT(UPLIT BYTE(%ASCIC 'address: complex address computation'), 0);
    	    END;


    	! Invalid address representation.
    	!
    	[DBG$K_ADDRKIND_INVALID]:
    	    BEGIN
    	    DBG$PRINT(UPLIT BYTE(%ASCIC 'address: invalid address'), 0);
    	    END;

    	TES;

    DBG$NEWLINE();
    RETURN 0;

    END;

ROUTINE SHOW_SYMBOL_TYPE(SYMID): NOVALUE =
!
! FUNCTION
!	This routine takes a SYMID and shows the type information associated
!	with the input SYMID.  This is a recursive routine.
!
! INPUTS
!	SYMID - The SYMID for the symbol.
!
! OUTPUTS
!	None.
!

    BEGIN
 
    MAP
    	SYMID: REF RST$ENTRY;		! Pointer to input symbol's RST entry

    ENABLE
    	SHOW_SYMBOL_TYPE_HANDLER;	! Set up error handler for this routine

    LOCAL
	AREA_ADDR,			! Byte address of the Area associated
    					!	with the given offset
    	AREA_LEN,			! Byte length of the Area associated
    					!	with the given offset
	BITSIZE,			! The size in bits of an item of the
    					!	given type
    	CELLTYPE: REF RST$ENTRY,	! The Type ID of the individual array
    					!	element's data type
	DSCADDR: REF BLOCK[,BYTE],	! VAX Standard Descriptor
    	DSTPTR: REF DST$RECORD,		! Pointer to symbol's DST record
    	ELTVECPTR: REF VECTOR[,LONG],	! Pointer to a vector of SYMIDs for the
    					! 	enumeration type elements, or
					!	record components, or
    					!	variant components, or
    					!	a subscript vector contains
    					!	  subscript Type ID, one longword
    					!	  per dimension
    	FCODE,				! Symbol's FCODE field
    	KIND,				! Symbol's KIND field
	HIGHPTR,			! Upper bound value of the subrange
    	LANGCODE,			! Language Code
    	LANGUAGE: REF VECTOR[,BYTE],	! Pointer to counted ASCII string
    	LOWPTR,				! Lower bound value of the subrange
	NAME: REF VECTOR[,BYTE],	! Counted ASCII String
    	NELTS,				! The number of enumeration type elements
    					!	or record components,
    					!	or variant components,
    					!	or array dimensions
    	PARENT_TYPE: REF RST$ENTRY,	! The Type ID of the set's parent type
	PICT_DESC : BLOCK [8,BYTE],     ! VAX Standard Descriptor
	PICT_LENGTH,			! The length of the picture representation
    	PICT_LENPTR: REF VECTOR[,BYTE], ! Pointer to the picture representation
	PICTPTR: REF VECTOR[,BYTE],	! Pointer to the picture representation
    	PICTVAL,			! Pointer to the language-specific
    					!	encoding
    	POOLID,				! Index to Temporary Memory Pool Stack
    	PSCALE,				! Scale factor and digit count for the
    					!	picture item
    	REFTYPID: REF RST$ENTRY,	! Type ID for target type
	TYPECODE,			! Type code
    	TYPEID: REF RST$ENTRY;		! Symbol's TYPE RST entry

    
    POOLID = DBG$PUSH_TEMPMEM();
    DBG$STA_SYMTYPE(.SYMID, FCODE, TYPEID);
    CASE .FCODE FROM RST$K_TYPE_MINIMUM TO RST$K_TYPE_MAXIMUM OF
    	SET

    	[RST$K_TYPE_ARRAY]:
    	    BEGIN
    	    DBG$STA_TYP_ARRAY(.TYPEID, DSCADDR, CELLTYPE, NELTS, ELTVECPTR, BITSIZE);
    	    DBG$TRANSALATE_DESCR(.DSCADDR);
    	    ITEM_SIZE(BITSIZE);
    	    DBG$NEWLINE();
    	    DBG$PRINT_CONTROL(DBG$K_PRTSET_RLMARGIN, +4);
    	    DBG$PRINT(UPLIT BYTE(%ASCIC 'cell type: '), 0);
    	    DBG$_PRINT_FLAG = TRUE;
    	    SHOW_SYMBOL_TYPE(.CELLTYPE);
    	    DBG$PRINT_CONTROL(DBG$K_PRTSET_RLMARGIN, -4);
    	    END;

    	[RST$K_TYPE_ATOMIC]:
    	    BEGIN
	    DBG$PRINT(UPLIT BYTE(%ASCIC 'atomic type,'), 0);
    	    DBG$STA_TYP_ATOMIC(.TYPEID, TYPECODE, BITSIZE);
    	    DBG$TRANSALATE_TYPECODE(.TYPECODE);
    	    ITEM_SIZE(BITSIZE);
    	    END;

    	[RST$K_TYPE_DESCR]:
    	    BEGIN
    	    DBG$STA_TYP_DESCR(.TYPEID, DSCADDR);
    	    DBG$TRANSALATE_DESCR(.DSCADDR);
    	    END;

    	[RST$K_TYPE_ENUM]:
    	    BEGIN
    	    DBG$PRINT(UPLIT BYTE(%ASCIC 'enumeration type'), 0);
    	    DBG$STA_TYP_ENUM(.TYPEID, NELTS, ELTVECPTR, BITSIZE);
    	    NAME = DBG$GET_DST_NAME(.TYPEID[RST$L_DSTPTR]);
    	    IF .NAME[0] NEQ 0
    	    THEN
    		DBG$PRINT(UPLIT BYTE(%ASCIC ' (!AC,'), .NAME)
    	    ELSE
    	        DBG$PRINT(UPLIT BYTE(%ASCIC ' (anonymous,'), 0);

	    DBG$PRINT(UPLIT BYTE(%ASCIC ' !UL elements)'), .NELTS);
    	    ITEM_SIZE(BITSIZE);
    	    END;

    	[RST$K_TYPE_PICT]:
    	    BEGIN
    	    DBG$PRINT(UPLIT BYTE(%ASCIC 'picture type,'), 0);
    	    DBG$STA_TYP_PICT(.TYPEID, LANGCODE, PICTPTR, PICTVAL, PSCALE);
    	    LANGUAGE = DBG$LANGUAGE(.LANGCODE);
    	    DBG$PRINT(UPLIT BYTE(%ASCIC ' !AC'), .LANGUAGE);
    	    IF .PICTPTR[0] NEQ 0 
    	    THEN 
    		BEGIN
	        INIT_DESCRIPTOR(PICT_DESC);
    	    	PICT_LENPTR = .PICTPTR - 1;
	    	PICT_LENGTH = .PICT_LENPTR[0];
	    	INCR PICT_INDEX FROM 1 TO (.PICT_LENGTH/2) DO
		    BEGIN
		    LOCAL
		        DUPL_STATUS,
		        CAT_STATUS,
		        DUPL_DESC : BLOCK [8, BYTE];

    		    INIT_DESCRIPTOR(DUPL_DESC);
		    DUPL_STATUS = STR$DUPL_CHAR(DUPL_DESC, 
    				%REF(.PICTPTR[((.PICT_INDEX - 1)*2) + 1]),
		    		%REF(.PICTPTR[((.PICT_INDEX - 1)*2) + 0]));
		    CAT_STATUS = STR$CONCAT(PICT_DESC, PICT_DESC, DUPL_DESC);
    		    DISCARD_DESCRIPTOR(DUPL_DESC);
		    END;

    		DBG$PRINT(UPLIT BYTE(%ASCIC ' pic: !AS'), PICT_DESC);
    		DISCARD_DESCRIPTOR(PICT_DESC);
    		END;

    	    END;

    	[RST$K_TYPE_TPTR]:
    	    BEGIN
    	    DBG$PRINT(UPLIT BYTE(%ASCIC 'typed pointer type'), 0);
    	    DBG$NEWLINE();
    	    DBG$STA_TYP_TYPEDPTR(.TYPEID, REFTYPID);
    	    DBG$PRINT_CONTROL(DBG$K_PRTSET_RLMARGIN, +4);
    	    DBG$PRINT(UPLIT BYTE(%ASCIC 'target type: '), 0);
    	    DBG$_PRINT_FLAG = TRUE;
    	    SHOW_SYMBOL_TYPE(.REFTYPID);
    	    DBG$PRINT_CONTROL(DBG$K_PRTSET_RLMARGIN, -4);
    	    END;

    	[RST$K_TYPE_RECORD]:
    	    BEGIN
    	    DBG$PRINT(UPLIT BYTE(%ASCIC 'record type'), 0);


    	    ! If the flag indicates that no value is specified, i.e., the
    	    ! object being described is a type.  Check to see if this type
    	    ! has a name.
    	    !
    	    DSTPTR = .TYPEID[RST$L_DSTPTR];
    	    IF .DSTPTR[DST$B_VFLAGS] EQL DST$K_VFLAGS_NOVAL
    	    THEN
    		BEGIN
    	    	NAME = DBG$GET_DST_NAME(.TYPEID[RST$L_DSTPTR]);
    	        IF .NAME[0] NEQ 0
    	    	THEN
    		    DBG$PRINT(UPLIT BYTE(%ASCIC ' (!AC,'), .NAME)
    	    	ELSE
    	            DBG$PRINT(UPLIT BYTE(%ASCIC ' (anonymous,'), 0);

    		END

    	    ELSE
    		DBG$PRINT(UPLIT BYTE(%ASCIC ' (anonymous,'), 0);

    	    DBG$STA_TYP_RECORD(.TYPEID, NELTS, ELTVECPTR, BITSIZE);
	    DBG$PRINT(UPLIT BYTE(%ASCIC ' !UL components)'), .NELTS);
    	    ITEM_SIZE(BITSIZE);
    	    INCR I FROM 0 TO .NELTS - 1 DO
    		BEGIN
    		DBG$STA_SYMKIND(.ELTVECPTR[.I], KIND);
    		IF .KIND EQL RST$K_VARIANT THEN GET_VARIANT(.ELTVECPTR[.I]);
    		END;

    	    END;

    	[RST$K_TYPE_SET]:
    	    BEGIN
    	    DBG$PRINT(UPLIT BYTE(%ASCIC 'set type'), 0);
    	    DBG$STA_TYP_SET(.TYPEID, PARENT_TYPE, BITSIZE);
    	    ITEM_SIZE(BITSIZE);
    	    DBG$NEWLINE();
    	    DBG$PRINT_CONTROL(DBG$K_PRTSET_RLMARGIN, +4);
    	    DBG$PRINT(UPLIT BYTE(%ASCIC 'parent type: '), 0);
    	    DBG$_PRINT_FLAG = TRUE;
    	    SHOW_SYMBOL_TYPE(.PARENT_TYPE);
    	    DBG$PRINT_CONTROL(DBG$K_PRTSET_RLMARGIN, -4);
    	    END;

    	[RST$K_TYPE_SUBRNG]:
    	    BEGIN
    	    DBG$PRINT(UPLIT BYTE(%ASCIC 'subrange type'), 0);
    	    DBG$STA_TYP_SUBRNG(.TYPEID, PARENT_TYPE, LOWPTR, HIGHPTR, BITSIZE);
    	    ITEM_SIZE(BITSIZE);
    	    DBG$PRINT(UPLIT BYTE(%ASCIC ', range:'), 0);
    	    DBG$PRINT(UPLIT BYTE(%ASCIC ' !SL.'), ..LOWPTR);
    	    DBG$PRINT(UPLIT BYTE(%ASCIC '.!SL'), ..HIGHPTR);
    	    DBG$NEWLINE();
    	    DBG$PRINT_CONTROL(DBG$K_PRTSET_RLMARGIN, +4);
    	    DBG$PRINT(UPLIT BYTE(%ASCIC 'parent type: '), 0);
    	    DBG$_PRINT_FLAG = TRUE;
    	    SHOW_SYMBOL_TYPE(.PARENT_TYPE);
    	    DBG$PRINT_CONTROL(DBG$K_PRTSET_RLMARGIN, -4);
    	    END;

    	[RST$K_TYPE_COBHACK]:
    	    BEGIN
    	    DBG$PRINT(UPLIT BYTE(%ASCIC ' cobol formal parameter type'), 0);
    	    END;

    	[RST$K_TYPE_BLIDATA]:
    	    BEGIN
    	    DBG$PRINT(UPLIT BYTE(%ASCIC 'bliss data item type'), 0);
    	    DSTPTR = .SYMID[RST$L_DSTPTR];
    	    GET_BLISS_SPECIAL_CASES(.DSTPTR);
    	    END;

    	[RST$K_TYPE_BLIFLD]:
    	    BEGIN
    	    DBG$PRINT(UPLIT BYTE(%ASCIC 'bliss field type'), 0);
    	    END;

    	[RST$K_TYPE_FILE]:
    	    BEGIN
    	    DBG$PRINT(UPLIT BYTE(%ASCIC 'file data type,'), 0);
    	    DBG$STA_TYP_FILE(.TYPEID, LANGCODE, REFTYPID);
    	    LANGUAGE = DBG$LANGUAGE(.LANGCODE);
    	    DBG$PRINT(UPLIT BYTE(%ASCIC ' !AC'), .LANGUAGE);
    	    IF .REFTYPID NEQ 0
    	    THEN
    		BEGIN
    	    	DBG$NEWLINE();
    		DBG$PRINT_CONTROL(DBG$K_PRTSET_RLMARGIN, +4);
    	    	DBG$PRINT(UPLIT BYTE(%ASCIC 'target type: '), 0);
    		DBG$_PRINT_FLAG = TRUE;
    	    	SHOW_SYMBOL_TYPE(.REFTYPID);
    		DBG$PRINT_CONTROL(DBG$K_PRTSET_RLMARGIN, -4);
    		END;

    	    END;

    	[RST$K_TYPE_PTR]:
    	    BEGIN
    	    DBG$PRINT(UPLIT BYTE(%ASCIC 'untyped pointer type'), 0);
    	    END;

    	[RST$K_TYPE_RFA]:
    	    BEGIN
    	    DBG$PRINT(UPLIT BYTE(%ASCIC 'record file address'), 0);
    	    END;

    	[RST$K_TYPE_SELF_REL_LAB]:
    	    BEGIN
    	    DBG$PRINT(UPLIT BYTE(%ASCIC 'self relative label'), 0);
    	    END;

    	[RST$K_TYPE_AREA]:
    	    BEGIN
    	    DBG$PRINT(UPLIT BYTE(%ASCIC 'area type,'), 0);
    	    DBG$STA_TYP_AREA(.TYPEID, AREA_LEN);
    	    DBG$PRINT(UPLIT BYTE(%ASCIC ' size: !UL bytes'), .AREA_LEN);
    	    END;

    	[RST$K_TYPE_OFFSET]:
    	    BEGIN
    	    DBG$PRINT(UPLIT BYTE(%ASCIC 'offset type,'), 0);
    	    DBG$STA_TYP_OFFSET(.TYPEID, AREA_ADDR, AREA_LEN);
    	    DBG$PRINT(UPLIT BYTE(%ASCIC ' byte address: !XL,'), .AREA_ADDR);
    	    DBG$PRINT(UPLIT BYTE(%ASCIC ' size: !UL bytes'), .AREA_LEN);
    	    END;

    	[INRANGE, OUTRANGE]:
    	    BEGIN
    	    DBG$PRINT(UPLIT BYTE(%ASCIC 'invalid type'), 0);
    	    END;

    	TES;

    IF .DBG$_PRINT_FLAG
    THEN
    	BEGIN
    	DBG$NEWLINE();
    	DBG$_PRINT_FLAG = FALSE;
    	END;


    ! Release the TYPEID RST entry for this SYMID.
    !
    DBG$RST_TEMP_RELEASE();
    DBG$POP_TEMPMEM(.POOLID);
    RETURN 0;

    END;

ROUTINE SHOW_SYMBOL_TYPE_HANDLER(SIGARG, MECHARG, ENBLARG) =
!
! FUNCTION
!	This routine is the error handler for the SHOW_SYMBOL_TYPE routine.
!	It catches the Access Violations which occur during the evaluation 
!	of DST Value Specs in DBG$STA_VALSPEC routine.  It also catches the
!	"Symbol not in active scope" message during DST Value Spec evaluation
!	in DBG$STA_VALSPEC if a register is referenced which is not available 
!	in the current context.
!
! INPUTS
!	SIGARG	- The signal argument vector.
!
!	MECHARG	- The mechanism argument vector.
!
!	ENBLARG	- The enable argument vector (not used here).
!
! OUTPUT
!	For DBG$_ACCADDCOM or DBG$_SYMNOTACT error, we'll call DBG$PRINT 
!	routine to print out message.  For all other errors, this routine
!	just resignals.
!

    BEGIN

    MAP
    	SIGARG: REF VECTOR[,LONG];	! Pointer to the signal argument vector

    IF .SIGARG[1] NEQ DBG$_ACCADDCOM AND
       .SIGARG[1] NEQ DBG$_SYMNOTACT
    THEN
    	RETURN SS$_RESIGNAL;

    DBG$PRINT(UPLIT BYTE(%ASCIC ' (type/address information is not available)'), 0);
    DBG$NEWLINE();
    SETUNWIND();
    RETURN 0;
    
    END;

ROUTINE WILDCARD_CANDIDATES(SYMBOL_PTR, MODRSTPTR, RSTPTR): =
!
! FUNCTION
!	This routine follows the symbol chain pointer in all set modules, and
!	all global symbols pointed by RST$START_ADDR's symbol chain pointer.
!	For each symbol's RST entry, this routine gets the name of the
!	symbol and trys to match this name with the wildcard string pattern.
!	If the result matches, return RST entry pointer of this symbol.
!	This routine also updates the module RST pointer to point to the next
!	set module, and the symbol RST pointer to point to the next symbol
!	in the chain for the same module.  0 is returned when reached to
!	the end of the chain of all set modules.
!	
! INPUTS
!	SYMBOL_PTR - Pointer points to the wildcard name string after the
!		   modification.  Such as, pointer value is 0 if the wildcard 
!		   name string is "*", or pointer points to Sub-Strings, ie.
!		   A*B*C -> ^0A^B^C0, *AB -> ^A^B0, AB* -> ^0A^B, etc.
!
!	MODRSTPTR  - Pointer points to next set module RST entry
!
!	RSTPTR 	   - Pointer points to next symbol RST entry belong to
!		   the same module
!
! OUTPUTS
!	This routine returns candidate symbol's RST entry, when we have
!	found the match, or 0 when reaches to end.
!
    BEGIN

    MAP
    	SYMBOL_PTR: REF WILDCARD$_FLDS,	! Pointer to Wildcard Sub-String or 0
    	MODRSTPTR: REF VECTOR[1],	! Pointer to next set module's RST entry
    	RSTPTR: REF VECTOR[1];		! Pointer to next symbol in symbol chain
    					!	belong to the same module

    LOCAL
    	FND,				! Flag set to indicate we have found 
    					!	the desired candidate symbol
    	FNDPTR: REF VECTOR[,BYTE],	! Pointer points to the matched Sub-
    					!	String in candidate symbol name
    	CAND_RSTPTR: REF RST$ENTRY,	! Pointer points to candidate symbol
    					!	RST entry
    	LENGTH,				! The remaining search length of the 
    					!	candidate symbol name string
    	MATCH_NAME: REF VECTOR[,BYTE],	! Candidate symbol name appended with
    					!	begin and end characters
    	NAME: REF VECTOR[,BYTE],	! Candidate symbol name
    	NEXTSETMOD: REF RST$ENTRY,	! Pointer points to next set module
    	SUBSTR: REF VECTOR[,BYTE],	! Pointer to sub-string in wildcard
    					!	sub-string link list
    	WILDCARD_PTR: REF WILDCARD$_FLDS;! Pointer to wildcard sub-string link
    					!	list


    MATCH_NAME = 0;


    ! Adjust the pointers to start matching point in symbol chain of set
    ! module.  Assume we have not found the candidate.
    !
    NEXTSETMOD = .MODRSTPTR[0];
    CAND_RSTPTR = .RSTPTR[0];
    FND = FALSE;


    ! Walk through the symbol chain in all set modules and try to match
    ! the candidate symbol name with the desired wildcard string pattern.
    !
    WHILE TRUE DO
    	BEGIN


    	! Check to see if we have reached to the end of the global symbol
    	! chain, if we have, then we all done.
    	!
    	IF .CAND_RSTPTR EQL 0 AND .NEXTSETMOD EQL 0 
    	THEN 
    	    BEGIN
    	    IF .MATCH_NAME NEQ 0 THEN DBG$REL_MEMORY(.MATCH_NAME);
    	    RETURN .CAND_RSTPTR;
    	    END;


    	! Check to see if we have reached to the end of the symbol chain
    	! belong to the same module.  If we have, set the module RST
    	! entry pointer to next set module.  If we have gone through all
    	! the set modules, return 0 to indicate the case.
    	!
    	IF .CAND_RSTPTR EQL 0 AND .NEXTSETMOD NEQ 0
    	THEN
    	    BEGIN


    	    ! Set the module pointer to next set module.
    	    !
    	    WHILE .NEXTSETMOD NEQ 0 DO
    	        BEGIN


    		! Set the pointer to next module in module chain.
    		!
    	        NEXTSETMOD = .NEXTSETMOD[RST$L_NXTMODPTR];


    		! Check to see if we have reached to the end of all set modules.
    		! If we have, exit this loop.
    		!
    	        IF .NEXTSETMOD EQL 0 THEN EXITLOOP;


    		! Check to see if this module is set.  If it is, exit, then
    		! walk through its symbol chain.
    		!
    	        IF .NEXTSETMOD[RST$V_MODSET] THEN EXITLOOP;
    	        END;			! End of WHILE setting module pointer.


    	    ! Set the candidate symbol chain pointer to start point.
    	    ! If we have reached to the end of all set modules, set the pointer
    	    ! to search global symbols.
    	    !
    	    IF .NEXTSETMOD NEQ 0
    	    THEN
    	    	CAND_RSTPTR = .NEXTSETMOD
    	    ELSE
    		CAND_RSTPTR = .RST$START_ADDR[RST$L_SYMCHNPTR];

    	    END;


    	! If the value of SYMBOL_PTR is zero implies we want to show every
    	! symbol in the DEBUG Run-Time Symbol.  So simply updates symbol
    	! RST pointer to next symbol in the chain, and updates the module
    	! RST pointer to next set module at the end of the symbol chain,
    	! then return.  For the other case, we have a wildcard string pattern 
    	! to match.
    	!
    	IF .SYMBOL_PTR NEQ 0 
    	THEN
    	    BEGIN


    	    ! Pick up candidate symbol's name.
    	    !
    	    NAME = DBG$GET_DST_NAME(.CAND_RSTPTR[RST$L_DSTPTR]);


    	    ! Append begin and end characters to this candidate symbol's name.
    	    ! 
    	    MATCH_NAME = WILDCARD_NAME_SETUP(.NAME);


    	    ! Match every Sub-String in wildcard sub-string linked list with
    	    ! the candidate symbol name orderly.  If we can match all Sub-String
    	    ! patterns in candidate symbol name then we have found the desired
    	    ! candidate.
    	    !
    	    FNDPTR = MATCH_NAME[1];
    	    LENGTH = .MATCH_NAME[0];
    	    WILDCARD_PTR = .SYMBOL_PTR;
    	    WHILE TRUE DO
    	        BEGIN


    		! Check to see if we have reached to the end of the linked
    		! list.  If we have, at this point we have successfully found
    		! the candidate.
    		!
    		IF .WILDCARD_PTR EQL 0
    		THEN
    		    BEGIN
    		    FND = TRUE;
    		    EXITLOOP;
    		    END;
    		

    		! Locate the Sub-String in the candidate symbol name string.
    		!
    		SUBSTR = .WILDCARD_PTR[WILDCARD$L_STRPTR];
    		FNDPTR = CH$FIND_SUB(.LENGTH, .FNDPTR, .SUBSTR[0], SUBSTR[1]);


    		! If we failed to locate the Sub-String, no point to go on.
    		!
    		IF .FNDPTR EQL 0 THEN EXITLOOP;


    		! Pick up next Sub-String in the wildcard sub-string linked
    		! list.
    		!
    		WILDCARD_PTR = .WILDCARD_PTR[WILDCARD$L_LINK];


    		! Set the pointer and length to the remaining candidate symbol
    		! name string.
    		!
    		FNDPTR = .FNDPTR + .SUBSTR[0];
    		LENGTH = .LENGTH - .SUBSTR[0];
    	        END;

    	    END


    	! Every symbol in RST is a candidate.  Set the flag to indicate we
    	! have a candidate.
    	!
    	ELSE
    	    FND = TRUE;


    	! Check to see if we have found the desired candidate symbol.  If
    	! we have, exit from walking RST entries.
    	!
    	IF .FND THEN EXITLOOP;


    	! We have not found the candidate symbol yet, continue to next
    	! candidate symbol in RST entries.
    	!
    	CAND_RSTPTR = .CAND_RSTPTR[RST$L_SYMCHNPTR];
    	IF .MATCH_NAME NEQ 0 
    	THEN 
    	    BEGIN
    	    DBG$REL_MEMORY(.MATCH_NAME);
    	    MATCH_NAME = 0;
    	    END;
 
    	END;				! End of WHILE walking the RST entries.


    ! Update the Module RST pointer and Symbol RST pointer.  Returned selected
    ! candidate symbol.
    !
    MODRSTPTR[0] = .NEXTSETMOD;
    RSTPTR[0] = .CAND_RSTPTR[RST$L_SYMCHNPTR];
    IF .MATCH_NAME NEQ 0 THEN DBG$REL_MEMORY(.MATCH_NAME);
    RETURN .CAND_RSTPTR;

    END;


ROUTINE WILDCARD_NAME_SETUP(SYMBOL_NAME): =
!
! FUNCTION
!	In order to make the matching wildcard format correctly and simply,
!	this routine appends null characters at the begin and end string if
!	the begin and end characters are not "*".
!
! INPUTS
!	SYMBOL_NAME - Counted ASCII name string
!
! OUTPUTS
!	Return Counted ASCII name string appended with null characters or
!	Counted ASCII name string itself.
!

    BEGIN

    MAP
    	SYMBOL_NAME: REF VECTOR[,BYTE];	! Counted ASCII name string

    LOCAL
    	IDX,				! Indexed into ith byte in the string
    	LEFT_FLAG,			! Flag set to indicate we need to pad
    					!	null character at the begin
    					!	string
    	LENGTH,				! Length of the counted ASCII string
    	RIGHT_FLAG,			! Flag set to indicate we need to pad
    					!	null character at the end string
    	STRING: REF VECTOR[,BYTE];	! Counted ASCII string after modification


    ! Assume we do not need the paddings.
    !
    LEFT_FLAG = FALSE;
    RIGHT_FLAG = FALSE;
    LENGTH = .SYMBOL_NAME[0];


    ! Check begin character.
    !
    IF .SYMBOL_NAME[1] NEQ %C'*' 
    THEN 
    	BEGIN
    	LENGTH = .LENGTH + 1;
    	LEFT_FLAG = TRUE;
    	END;


    ! Check end character.
    !
    IF .SYMBOL_NAME[.SYMBOL_NAME[0]] NEQ %C'*' 
    THEN 
    	BEGIN
    	LENGTH = .LENGTH + 1;
    	RIGHT_FLAG = TRUE;
    	END;


    ! Get some memory for modified string.
    !
    STRING = DBG$GET_MEMORY(.LENGTH/4 + 1);


    ! Pad null character if the flag is set.
    !
    IDX = 1;
    IF .LEFT_FLAG
    THEN 
    	BEGIN
    	STRING[1] = 0;
    	IDX = .IDX + 1;
    	END;


    ! Copy the string itself.
    !
    CH$MOVE(.SYMBOL_NAME[0], SYMBOL_NAME[1], STRING[.IDX]);


    ! Pad null character if the flag is set.
    !
    IF .RIGHT_FLAG THEN STRING[.LENGTH] = 0;


    ! Adjust the length of the string and return the modified string.
    !
    STRING[0] = .LENGTH;
    RETURN .STRING;

    END;

ROUTINE WILDCARD_SUB_STRING(SYMBOL_NAME): =
!
! FUNCTION
!	This routine breaks wildcard name string into Sub-Strings.
!
! INPUTS
!	SYMBOL_NAME - Counted ASCII string contains wildcard characters.
!
! OUTPUTS
!	Return a linked list contains Sub-Strings, or zero if "*" is the
! 	wildcard name string.
!
    BEGIN

    MAP
    	SYMBOL_NAME: REF VECTOR[,BYTE];	! Counted ASCII wildcard name string

    LOCAL
    	LENGTH,				! Remaining length of the wildcard
    					!	name string
    	NAMEPTR: REF VECTOR[,BYTE],	! Pointer to Sub-String
    	START: REF VECTOR[,BYTE],	! Pointer to counted ASCII wildcard 
    					!	name string
    	SUB_STRING: REF WILDCARD$_FLDS,	! Pointer to linked list
    	SYMBOL_PTR: REF WILDCARD$_FLDS,	! Pointer to linked list
    	WILDCARD_PTR: REF VECTOR[,BYTE];! Pointer to "*" in the wildcard name
    					!	string


    SYMBOL_PTR = 0;


    ! Wildcard name string is "*", no need to break it into Sub-Strings.
    !
    IF .SYMBOL_NAME[0] EQL 1 THEN RETURN .SYMBOL_PTR;


    ! Creat linked list node.
    !
    SYMBOL_PTR = DBG$GET_TEMPMEM(WILDCARD$K_SIZE);
    SUB_STRING = .SYMBOL_PTR;
    LENGTH = .SYMBOL_NAME[0];
    START = SYMBOL_NAME[1];


    ! Locate the "*" in the wildcard name string, extract the Sub-String
    ! without the "*", insert it onto the linked list.
    !
    WHILE TRUE DO
    	BEGIN
    	WILDCARD_PTR = CH$FIND_CH(.LENGTH, .START, %C'*');


    	! Check for end case.  If WILDCARD_PTR is zero, this implies no more
    	! "*" can be found in the wildcard name string.  Set WILDCARD_PTR 
    	! points to the end of wildcard name string.
    	!
    	IF .WILDCARD_PTR EQL 0 THEN WILDCARD_PTR = SYMBOL_NAME[1] + .SYMBOL_NAME[0];


    	! Get some tempory memory for Sub-String.
    	!
    	NAMEPTR = DBG$GET_TEMPMEM((.WILDCARD_PTR - .START)/ 4 + 1);
    	NAMEPTR[0] = .WILDCARD_PTR - .START;


    	! Extract the Sub-String from wildcard name string.  Install Sub-string
    	! pointer onto linked list.
    	!
    	CH$MOVE(.NAMEPTR[0], .START, NAMEPTR[1]);
    	SUB_STRING[WILDCARD$L_STRPTR] = .NAMEPTR;


    	! Check to see if we have reached to the end of the string.  If we
    	! have, then we are all done.
    	!
    	IF .WILDCARD_PTR GEQ (SYMBOL_NAME[1] + .SYMBOL_NAME[0] - 1) THEN EXITLOOP;


    	! More Sub-String to break, get more tempory memory for next node.
    	!
    	SUB_STRING[WILDCARD$L_LINK] = DBG$GET_TEMPMEM(WILDCARD$K_SIZE);
    	SUB_STRING = .SUB_STRING[WILDCARD$L_LINK];


    	! Adjust the pointer and remaining length.
    	!
    	START = .WILDCARD_PTR + 1;
    	LENGTH = SYMBOL_NAME[1] + .SYMBOL_NAME[0] - .START;
    	END;    


    ! End of the linked list.  Return linked list pointer.
    !
    SUB_STRING[WILDCARD$L_LINK] = 0;
    RETURN .SYMBOL_PTR;
    END;

END ELUDOM
