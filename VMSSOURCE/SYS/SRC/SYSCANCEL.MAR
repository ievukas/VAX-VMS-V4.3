	.TITLE	SYSCANCEL - SYSTEM SERVICE CANCEL I/O ON CHANNEL
	.IDENT	'V04-000'
 
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; D. N. CUTLER 4-AUG-77
;
; SYSTEM SERVICE CANCEL I/O ON CHANNEL
;
; MODIFIED BY:
;
;	V03-005	CDS0001		Christian D. Saether	20-July-1984
;		Don't do the acpcontrol function for disk devices.
;
;	V03-004	LMP0251		L. Mark Pilant,		9-May-1984  12:48
;		Correct a bug in WMC0001 so that the correct base register
;		is used to lock down the CCB.
;
;	V03-003	WMC0001		Wayne Cardoza		16-Apr-1984
;		Don't touch CCB above IPL 2.
;
;	V03-002	ROW0136		Ralph O. Weber		25-OCT-1982
;		Change event flag number in hand crafted IO$_ACPCONTROL IRP 
;		from #31 to #EXE$C_SYSEFN, it symbolic equivalent.
;
;	V03-001	KDM0002		Kathleen D. Morse	28-Jun-1982
;		Added $SSDEF.
;
;**
;
; MACRO LIBRARY CALLS
;
 
	$CADEF				;DEFINE CONDITIONAL ASSEMBLY PARAMETERS
	$CANDEF				;DEFINE CANCEL REASON CODES
	$CCBDEF				;DEFINE CCB OFFSETS
	$DCDEF				;DEFINE DEVICE CLASS CONSTANTS
	$DDBDEF				;DEFINE DDB OFFSETS
	$DDTDEF				;DEFINE DDT OFFSETS
	$DEVDEF				;DEFINE DEVICE CHARACTERISTIC BITS
	$DYNDEF				;DEFINE DATA STRUCTURE TYPE CODES
	$IODEF				;DEFINE I/O FUNCTION CODES
	$IPLDEF				;DEFINE INTERRUPT PRIORITY LEVELS
	$IRPDEF				;DEFINE IRP OFFSETS
	$PCBDEF				;DEFINE PCB OFFSETS
	$PRDEF				;DEFINE PROCESSOR REGISTERS
	$RSNDEF				;DEFINE RESOURCE WAIT NUMBERS
	$SSDEF				;DEFINE SYSTEM STATUS CODES
	$UCBDEF				;DEFINE UCB OFFSETS
	$VCBDEF				;DEFINE VCB OFFSETS
	$WCBDEF				;DEFINE WCB OFFSETS
 
;
; LOCAL SYMBOLS
;
; ARGUMENT LIST OFFSET DEFINITIONS
;
 
NARG=0					;NUMBER OF ARGUMENTS PASSED
CHAN=4					;I/O CHANNEL NUMBER
CODE=8					;SPECIAL CANCEL CODE
	.PAGE
	.SBTTL	CANCEL I/O ON CHANNEL
;+
; EXE$CANCEL - CANCEL I/O ON CHANNEL
; EXE$CANCELN - CANCEL I/O ON CHANNEL WITH REASON CODE
;
; THIS SERVICE CANCELS ALL I/O ISSUED TO A DEVICE FROM THE SPECIFIED CHANNEL.
;
; INPUTS:
;
;	CODE(AP) = REASON CODE FOR CANCEL CALL (EXE$CANCELN ONLY).
;	CHAN(AP) = NUMBER OF THE I/O CHANNEL TO CANCEL I/O FOR.
;	NARG(AP) = NUMBER OF ARGUMENTS PASSED (EXE$CANCELN ONLY).
;
;	R4 = CURRENT PROCESS PCB ADDRESS.
;
; OUTPUTS:
;
;	R0 LOW BIT CLEAR INDICATES FAILURE TO CANCEL I/O.
;
;		SS$_EXQUOTA - DIRECT I/O QUOTA EXCEEDED WHILE TRYING TO
;			CANCEL FILE I/O.
;
;		SS$_INSFMEM - INSUFFICIENT MEMORY AVAILABLE TO ALLOCATE I/O
;			PACKET.
;
;		SS$_IVCHAN - INVALID CHANNEL NUMBER SPECIFIED.
;
;		SS$_NOPRIV - SPECIFIED CHANNEL IS NOT ASSIGNED TO A DEVICE
;			OR THE CALLER DOES NOT HAVE SUFFICIENT PRIVILEGE TO
;			ACCESS THE CHANNEL.
;
;	R0 LOW BIT SET INDICATES SUCCESSFUL COMPLETION.
;
;		SS$_NORMAL - NORMAL COMPLETION.
;-
 
	.ENABL	LSB

	.ENTRY	EXE$CANCELN,^M<R2,R3,R4,R5,R6,R7,R8>
	ASSUME	CAN$C_CANCEL EQ 0
	CLRL	R8			;ASSUME NO REASON CODE
;
; We do not check access to argument list here - since this is a
; VMS internal entry point.
;
	CMPB	S^#2,NARG(AP)		;REASON CODE GIVEN?
	BNEQ	5$			;IF NEQ - NO REASON CODE
	MOVL	CODE(AP),R8		;ELSE, GET REASON CODE
	BRB	5$			;JOIN COMMON CODE
 
	.ENTRY	EXE$CANCEL,^M<R2,R3,R4,R5,R6,R7,R8>
	ASSUME	CAN$C_CANCEL EQ 0
	CLRL	R8			;NEVER A REASON CODE FOR OLD CANCEL
5$:	MOVZWL	CHAN(AP),R0		;GET I/O CHANNEL NUMBER
	JSB	IOC$VERIFYCHAN		;VERIFY I/O CHANNEL NUMBER
	BLBC	R0,50$			;IF LBC INVALID CHANNEL
	MOVL	R2,R7			;SAVE CHANNEL INDEX
	MOVL	R1,R6			;SAVE ADDRESS OF CCB
	MOVL	CCB$L_UCB(R6),R5	;GET ASSIGNED DEVICE UCB ADDRESS
10$:	MOVPSL	-(SP)			;SAVE CURRENT PROCESSOR STATUS
	SETIPL	#IPL$_ASTDEL		;RAISE TO AST DELIVERY LEVEL
	ASSUME	CCB$K_LENGTH EQ 16	;MAKE SURE CCB IS PAGE ALIGNED
	MOVW	CCB$W_IOC(R6),-(SP)	;WE NEED A SPOT FOR IPL - SAFE AT IPL 2
	MOVB	UCB$B_FIPL(R5),CCB$W_IOC(R6) ;THE SETIPL WILL LOCK THE CCB
	SETIPL	CCB$W_IOC(R6)		;RAISE TO DRIVER FORK IPL
	MOVW	(SP)+,CCB$W_IOC(R6)	;ANY I/O OUTSTANDING? - RESTORE CCB
	BEQL	70$			;IF EQL NO
	MOVAB	UCB$L_IOQFL(R5),R3	;GET ADDRESS OF I/O QUEUE LISTHEAD
	MOVL	R3,R2			;COPY ADDRESS OF I/O QUEUE LISTHEAD
20$:	MOVL	IRP$L_IOQFL(R2),R2	;GET ADDRESS OF NEXT I/O PACKET IN QUEUE
	CMPL	R2,R3			;END OF QUEUE?
	BEQL	70$			;IF EQL YES
	BBS	#IRP$V_VIRTUAL,IRP$W_STS(R2),20$ ;IF SET, VIRTUAL I/O REQUEST
	CMPL	IRP$L_PID(R2),PCB$L_PID(R4) ;PROCESS ID MATCH?
	BNEQ	20$			;IF NEQ NO
	CMPW	R7,IRP$W_CHAN(R2)	;I/O CHANNEL NUMBER MATCH?
	BNEQ	20$			;IF NEQ NO
	MOVL	IRP$L_IOQBL(R2),R2	;GET BACKWARD LINK OF CURRENT ENTRY
	REMQUE	@IRP$L_IOQFL(R2),R1	;REMOVE I/O PACKET FROM QUEUE
	BBC	#IRP$V_BUFIO,IRP$W_STS(R1),30$ ;IF CLR, DIRECT I/O REQUEST
	BICW	#IRP$M_FUNC,IRP$W_STS(R1) ;CLEAR BUFFERED READ
30$:	MOVZWL	#SS$_CANCEL,IRP$L_MEDIA(R1) ;SET COMPLETION STATUS
	INSQUE	IRP$L_IOQFL(R1),@W^IOC$GL_PSBL ;INSERT PACKET IN POST PROCESS QUEUE
	SOFTINT	#IPL$_IOPOST		;INITIATE SOFTWARE INTERRUPT
	BRB	20$			;

40$:	MOVZWL	S^#SS$_NORMAL,R0	;SET NORMAL COMPLETION STATUS
50$:	SETIPL	#0			;ALLOW INTERRUPTS
	RET				;

70$:	MOVL	UCB$L_DDT(R5),R0	;GET ADDRESS OF DDT
	MOVL	UCB$L_IRP(R5),R3	;GET CURRENT I/O PACKET ADDRESS
	MOVL	R7,R2			;SET CHANNEL INDEX
;
; WARNING - Some drivers do a RET from the driver CANCEL I/O ROUTINE, in error
;	    cases.
;
	JSB	@DDT$L_CANCEL(R0)	;CALL CANCEL I/O ROUTINE
	CMPB	UCB$B_DEVCLASS(R5), #DC$_DISK ;IS THIS A DISK?
	BEQL	40$			;ALL DONE IF SO
	MOVZWL	CCB$W_IOC(R6),R0	;GET OUTSTANDING I/O COUNT
	BISL	CCB$L_WIND(R6),R0	;OUTSTANDING I/O OR FILE ACTIVITY?
	BEQL	40$			;IF EQL NO
	BBC	#DEV$V_MNT,UCB$L_DEVCHAR(R5),40$ ;IF CLR, DEVICE DISMOUNTED
	BBS	#DEV$V_FOR,UCB$L_DEVCHAR(R5),40$ ;IF SET, MOUNTED FOREIGN
	BICL3	#1,CCB$L_WIND(R6),R0	;FILE ACCESSED OR PROCESS SECTION?
	BGTR	40$			;IF GTR PROCESS SECTION
	BEQL	80$			;IF EQL NO FILE ACCESSED
	BBS	#WCB$V_NOTFCP,WCB$B_ACCESS(R0),40$ ;IF SET, NOT ACP ACCESS
80$:	MOVZWL	#SS$_EXQUOTA,R1		;SET EXCEEDED QUOTA STATUS
	MOVZWL	#RSN$_ASTWAIT,R0	;SET AST WAIT RESOURCE WAIT NUMBER
	TSTW	PCB$W_BIOCNT(R4)	;BUFFERED I/O QUOTA EXCEEDED?
	BEQL	90$			;IF EQL YES
	MOVZBL	#IRP$C_LENGTH,R1	;SET LENGTH OF I/O PACKET
	BSBW	EXE$ALONONPAGED		;ALLOCATE I/O PACKET
	BLBS	R0,100$			;IF LBS SUCCESSFUL ALLOCATION
	MOVZWL	#SS$_INSFMEM,R1		;SET INSUFFICIENT MEMORY STATUS
	MOVZWL	#RSN$_NPDYNMEM,R0	;SET NONPAGED DYNAMIC MEMORY RESOURCE NUMBER
90$:	BBS	#PCB$V_SSRWAIT,PCB$L_STS(R4),95$ ;IF SET, NO WAIT
	BSBW	SCH$RWAIT		;WAIT FOR RESOURCE
	BRW	10$			;TRY AGAIN
95$:	SETIPL	#0			;ALLOW INTERRUPTS
	MOVL	R1,R0			;SET COMPLETION STATUS
	RET				;
100$:	DECW	PCB$W_BIOCNT(R4)	;UPDATE BUFFERED I/O COUNT
	INCW	CCB$W_IOC(R6)		;INCREMENT I/O COUNT
	MOVL	R2,R3			;COPY ADDRESS OF I/O PACKET
	ADDL	#IRP$W_SIZE,R2		;CALCULATE ADDRESS OF PACKET SIZE
	MOVZBW	#IRP$C_LENGTH,(R2)+	;INSERT SIZE OF I/O REQUEST PACKET
	MOVZBW	#DYN$C_IRP,(R2)+	;INSERT DATA STRUCTURE TYPE AND ZERO MODE
	MOVL	PCB$L_PID(R4),(R2)+	;INSERT CURRENT PROCESS ID
	CLRQ	(R2)+			;CLEAR AST ADDRESS AND PARAMETER
	MOVL	CCB$L_WIND(R6),(R2)+	;INSERT ADDRESS OF WINDOW
	MOVL	R5,(R2)+		;INSERT DEVICE UCB ADDRESS
	MOVW	#IO$_ACPCONTROL,(R2)+	;INSERT I/O FUNCTION CODE
	MOVB	#EXE$C_SYSEFN,(R2)+	;SET EVENT FLAG NUMBER
	MOVB	PCB$B_PRIB(R4),(R2)+	;INSERT PROCESS BASE PRIORITY
	CLRL	(R2)+			;CLEAR I/O STATUS BLOCK ADDRESS
	MOVW	R7,(R2)+		;INSERT CHANNEL NUMBER
	MOVW	#IRP$M_BUFIO,(R2)+	;INSERT PACKET STATUS
	CLRQ	(R2)+			;CLEAR BUFFER PARAMETERS
	MOVL	PCB$L_ARB(R4),IRP$L_ARB(R3) ;GET ACCESS RIGHTS BLOCK ADDRESS
	MOVL	UCB$L_VCB(R5),R0	;GET ADDRESS OF VCB
	INCW	VCB$W_TRANS(R0)		;UPDATE TRANSACTION COUNT
 
	.IF DF	CA$_MEASURE_IOT
 
	MOVL	R3,R2			;SET ADDRESS OF I/O REQUEST PACKET
	BSBW	PMS$START_RQ		;INSERT START OF I/O REQUEST MESSAGE
 
	.ENDC
 
	BRW	EXE$QIOACPPKT		;QUEUE ACP PACKET
 
	.DSABL	LSB

	.END
