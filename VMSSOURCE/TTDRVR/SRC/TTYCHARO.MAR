	.TITLE	TTYCHARO - Terminal driver character output routine
	.IDENT	'V04-000'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
;++
; Facility:
;
;	VAX/VMS TERMINAL DRIVER
;
; ABSTRACT:
;
;	THIS MODULE CONTAINS ROUTINES USED FOR THE OUTPUT OF CHARACTERS.
;
;	***** This module never destroys the contents of R0 *****
;
; AUTHOR:
;
;	R.HEINEN 11-AUG-1976
;
; Revision history:
;
;	V03-046 MIR01424	Michael I. Rosenblum		16-Jun-1984
;		Fix bug with read with 0 timeout that creates the typeahead
;		buffer, reported in qar 1424.
;
;	V03-045	MIR0450		Michael I. Rosenblum		27-JUN-1984
;		Make the port bit pc_nocrlf set the state skiplf
;		Fix bug in escape introducer code that caused it not to
;		recognize csi.
;
;	V03-044	MIR0400		Michael I. Rosenblum		10-Apr-1984
;		Filter null characters from escape sequences.
;
;	V03-043	MIR0390		Michael I. Rosenblum		04-Apr-1984
;		Make the exit string echo thru the tables vector.
;
;	V03-042 MIR0370		Michael I. Rosenblum		20-Mar-1984
;		Fix problems with tabs to the left of the curent position,
;		Lines that wrap in either the prompt or initial string.
;		Add port control word modifier to stop free linefeeds
;		After typed <CR>.
;
;	V03-042	MIR0310		Michael I. Rosenblum		07-Feb-1984
;		Fix bugs.
;		Noformat reads shouldn't wrap.
;		Ignore SKIPCRLF and EDITREAD if we are wrapping.
;		Don't change esc to $ if EDITREAD is set.
;		Move to beginning of line should rewrite the whole line
;		  if the origional cursor position was non-zero.
;		Read nofltr should obey uppercase rules.
;		Passall should not imply termnoecho.
;		Fix delete in left justified read verify noecho fields
;		  to not echo.
;
;	V03-041	MIR0300		Michael I. Rosenblum		30-Jan-1984
;		Make the uparrow key be command recall.
;
;	V03-040	MIR0100		Michael I. Rosenblum		24-Oct-1983
;		Fix bug that would cause characters to be echoed in no-echo
;		mode.
;
;	V03-039	MIR0084		Michael I. Rosenblum		25-Aug-1983
;		Fix problem with terminating a right justified numeric
;		auto-tab field in read verify.
;
;	V03-038	MIR0082		Michael I. Rosenblum		02-Aug-1983
;		Fix bug in recall logic that did not force a return before
;		the recall was done.  Fix bug in delete after wrap logic.
;
;	V03-037	MIR0081		Michael I. Rosenblum		01-Aug-1983
;		Remove $brddef call (obsoleted).
;
;	V03-036	MIR0080		Michael I. Rosenblum		28-Jul-1983
;		Reposition code in the module.
;
;	V03-035	MIR0070		Michael I. Rosenblum		13-Jul-1983
;		Fix bug that would cause an escape sequence at the beginning
;		of the line to return invalid data if deleted.
;		Make check in MOVEREADATA for buffer full condition at
;		the top of the loop to make sure that the users buffer
;		can not be overfilled if the initial string fills the 
;		data buffer.
;
;	V03-034	MIR0053		Michael I. Rosenblum		27-Jun-1983
;		Fix bug in ESCAPE_TAB where it would pass the address
;		into the ESCINIT routine rather than the character
;
;	V03-033	MIR0051		Michael I. Rosenblum		23-Jun-1983
;		Fix bug caused when escape sequences are UNUSED.
;		Cause simceol to exit to movecursor on hard-copy terminals.
;		Make routines that checked CSI and ESC call a common routine.
;		Fix bug that would cause writes on non-hardcopy terminals
;		To use the single character code path following the wrap point.
;
;	V03-032	MIR0053		Michael I. Rosenblum		10-May-1983
;		Fix bug in clear to end of line emulation.
;
;	V03-031	MIR0052		Michael I. Rosenblum		27-May-1983
;		Add delete character to read verify, make read verify
;		accept fill characters in the initial string and as
;		data and display the clear character.
;		Add software emulation of clear to end of line for non-
;		ansi terminals.
;
;	V03-030	MIR0050		Michael I. Rosenblum		11-May-1983
;		Remove code that specail cased broadcasts.
;
;	V03-029	MIR0049		Michael I. Rosenblum		06-May-1983
;		Add code to handle wrapping correctly.
;
;	V03-028	MIR0041		Michael I. Rosenblum		29-Apr-1983
;		Fix bug in the new passall code path
;
;	V03-027	MIR0030		Michael I. Rosenblum		30-Mar-1983
;		Integrate TTRDVFY with the terminal driver, code included
;		in this module
;
;	V03-026	MIR0029		Michael I. Rosenblum		22-Mar-1983
;		Add code for insert/overstrike mode.
;
;	V03-025	RKS0025		RICK SPITZ			19-MAR-1983
;		Change references of UCB$L_TT_DEVDP1 TO UCB$L_DEVDEPND2
;
;	V03-024	MIR6026		Michael I. Rosenblum		11-Mar-1983
;		Change recall to not terminate a small read when a recall
;		is done from a long recall buffer.
;
;	V03-023	MIR2026		Michael I. Rosenblum		07-Mar-1983
;		Fix bug in EDITREAD prompt echoing when there is no prompt
;		to echo.
;
;	V03-022	MIR1026		Michael I. Rosenblum		1-Mar-1983
;		Add $TRMDEF to the list of required symbol definitions
;
;	V03-021	MIR0026		Michael I. Rosenblum		10-Feb-1983
;		Add code to impliment input line editing.
;
;	V03-020	MIR0025		Michael I. Rosenblum		18-Feb-1983
;		Fix bug in carriage control logic that caused a carriage return
;		in a prompted read to get a free linefeed.
;		
;	V03-019	MIR0024		Michael I. Rosenblum		28-Jan-1983
;		Change code to reflect redefinition of the read packet.
;
;	V03-018	MIR0017		Michael I. Rosenblum		05-Jan-1983
;		Add powerfail bit to the unit state vector table to remove
;		powerfail check for each character.  Restructure powerfail
;		code to fall into a common code path in TTYSUB.  Change
;		return status of TTY$GETNEXTCHAR to include a byte value
;		in the UCB, this will move the information from the condition
;		code bits.
;
;	V03-017	MIR0016		Michael I. Rosenblum		29-Dec-1982
;		Replace time calculation code with TIMSET macro call
;		This change will allow us to change the time calculation
;		algorhythm globaly if necessary, and will also allow
;		us to globaly turn on and off the time calculations.
;
;	V03-016	MIR0015		Michael I. Rosenblum		22-Dec-1982
;		Change all calls to the terminal port drivers to refer
;		to the class jacket routines. Remove DMA code from the
;		class driver.
;
;	V03-015 MIR0013		Michael I. Rosenblum		16-Dec-1982
;		Fix up refferences to new ucb structure
;
;	V03-014	MIR0011		Michael I. Rosenblum		18-Nov-1982
;		Change MULTIECHO to take a count in UCB$W_TT_MULTILEN and
;		an address in UCB$L_TT_MULTI, illiminate the code for
;		zero terminated multiecho strings.
;		Change STRTMULTI to take a counted string and convert
;		it into a length and address.
;		Add STRTMULTI_1 to take the place of STRTMULTI.
;		Add code to make Control-R and Control-U look prety on
;		ANSI crt terminals.
;		Change CONTROLR to EDITREAD also change the internals of
;		CONTROLR to use MULTIECHO.
;		Change the meaning of the CTRLR bit to indicate that the
;		prompt and data string from a read buffer are being clocked
;		out by multiecho, this is the only use for CTRLR.
;		Add SKIPCRLF to indicate that a linefeed following a <CR>
;		in the beginning of the prompt string is to be skiped.
;		Remove HOLDSCREEN code.
;
;	V03-013	MIR0012		Michael I. Rosenblum	19-Nov-1982
;		Fix bug that caused exception when a read was posted
;		that caused a create of the typeahead buffer.
;
;	V03-012	MIR0010		Michael I. Rosenblum	09-Nov-1982
;		Move the address of the terminator mask, and the length
;		of the prompt string from the IRP into the terminal read
;		packet.  Also move the count of the characters in the 
;		buffer from the UCB into the terminal typeahead buffer packet.
;		Make backspace look like delete (without beeing delete)
;
;	V03-011	RKS0011		RICK SPITZ		19-OCT-1982
;		INSURE THAT R5 IS PRESERVED WHEN DMA FORK TAKEN
;
;	V03-009 RKS0010		RICK SPITZ		23-SEP-1982
;
;		CHANGE LOGIC IN FORMAT TO INSURE THAT HARDCOPY TERMINALS
;		SET TO NO WRAP DO NOT OUTPUT DATA BEYOND LINE WIDTH
;
;		CORRECT PROBLEM WITH XON LOGIC TO INSURE THAT OVERFLOW
;		ERRORS ARE ALWAYS REPORTED
;
;	V03-008	MIR0003		Michael I. Rosenblum	12-Aug-1982
;		Fix bug where multi escape sequences in a TTRDVFY prompt
;		Would not work.
;
;	V03-007	KDM0002		Kathleen D. Morse	28-Jun-1982
;		Added $SSDEF.
;--

	.SBTTL	Declarations

;
; EXTERNAL SYMBOLS
;

	$CRBDEF				; DEFINE CRB
	$IODEF				; DEFINE I/O FUNCTION CODES
	$IPLDEF				; DEFINE IPL'S
	$IRPDEF				; DEFINE IRP
	$PRDEF				; DEFINE PROCESSOR REGISTERS
	$PRIDEF				; DEFINE PRIORITY CLASSES
	$RSNDEF				; DEFINE RESOURCE NUMBERS
	$SSDEF				; DEFINE SYSTEM STATUS CODES
	$UBADEF				; DEFINE UBA OFFSETS
	$UCBDEF				; DEFINE UCB
	$TRMDEF				; TERMINAL ITEMLIST BIT DEFINITIONS
	$TTYDEF				; DEFINE TERMINAL DRIVER SYMBOLS
	$TTDEF				; DEFINE TERMINAL CHARACTERISTICS
	$TT2DEF				; DEFINE EXTENDED TERMINAL CHARS
	$VECDEF				; DEFINE CRB VECTOR
	$TTYMACS			; DEFINE TERMINAL MACROS
	$TTYDEFS			; DEFINE TERMINAL DEFINITIONS

	.PSECT	$$$115_DRIVER,LONG	; DEFINE NON-PAGED PSECT


	.SBTTL	TTY$GETNEXTCHAR - GET NEXT CHARACTER(S)
;++
; TTY$GETNEXTCHAR - GET NEXT CHARACTER(S)
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE RETURNS WITH THE NEXT CHARACTER(S) TO BE OUTPUT ON THE UNIT.
;
; INPUTS:
;
;	R5 = UCB ADDRESS
; 
; OUTPUTS:
;
;	R0 = ALWAYS PRESERVED!!
;
;	R3 = 	0 	AND CC = ZERO - NO CHARACTER TO OUTPUT
;		CHAR	AND CC = PLUS - SINGLE CHARACTER TO OUTPUT
;		ADDRESS	AND CC = NEG  - BURST (R2 = LENGTH)
;				 (ADDRESS AND LENGTH ALSO IN UCB)
;
;	R5 = UCB ADDRESS
;	UCB$B_TT_OUTYPE = -1 BIRST
;				ADDRESS IN R3 AND UCB$L_TT_OUTADR
;				LENGTH IN R2  AND UCB$W_TT_OUTLEN
;			   0 NO CHARACTER TO OUTPUT
;			   1 SINGLE CHARACTER TO OUTPUT IN R3
;--

TTY$GETNEXTCHAR::
	MOVAB	UCB$Q_TT_STATE(R5),R2	; ADDRESS STATE OF UNIT
;
; GET CURRENT STATE OF THE OUTPUT
;
GETNEXTCHAR:				; INTERNAL ENTRY
	CMPL	#TTY$M_ST_WRITE,(R2)	; TRY WRITING GENERAL CASE FIRST
	BEQL	WRITING			; IF EQL THEN GO
	CMPL	#TTY$M_ST_READ,(R2)	; TRY READING GENERAL CASE NEXT
	BNEQ	10$			; NO, GO TO 10$
	BRW	MOVEREADATA		; IF EQL THEN GO
10$:
	FFS	#0,#TTY$V_ST_READ+1,(R2),R4; GET THE NEXT MOST IMPORTANT OUTPUT STATE
	CASE	R4,TYPE=B,<-		; ENTER THAT STATE'S ROUTINE
	POWERREST,-			; go to the power fail code
	INTEXIT,-			; CONTROL S
	FILLING,-			; FILL IN PROGESS
	CURSOROVRFLOW,-			; CURSOR OVERFLOW
	SENDLINEFEED,-			; LINE FEED TO BE INSERTED
	BACKSPACING,-			; BACKING UP IN PROGRESS
	MULTIECHOING,-			; MULTI ECHO IS PROGRESS
	WRITING,-			; WRITE IN PROGRESS
	EOLSEEN,-			; EOL SEEN
	EDITREAD,-			; READ EDITING OUTPUT STATE
	RDVERIFY,-			; GO TO READ VERIFICATION
	RECALLING,-			; RECALLING THE LAST COMMAND
	MOVEREADATA>			; READ IN PROGRESS
;
; EXIT INTERRUPT
;
INTEXIT:				; EXIT INTERRUPT
	CLRB	UCB$B_TT_OUTYPE(R5)	; SET NO RETURN CHARACTER
	RSB				; RETURN
;
; POWERFAIL DETECTED
;
POWERREST:
	BSBW	RESTART			; CALL THE POWERFAIL RESTART CODE THEN
	BRW	GETNEXTCHAR		; CONTINUE AGAIN


INTEXIT1:				; EXIT AND RESTORE UCB ADDRESS
	POPL	R5
	BRB	INTEXIT

	.SBTTL	WRITING - WRITE state action routine

;++
; WRITING - CONTINUE WRITE I/O OUTPUT
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS ENTERED WHEN ALL EXTRA OUTPUT IS COMPLETE
; AND A WRITE OPERATION IS IN PROGRESS.
;
; THE NEXT AVAILABLE CHARACTER IS EXTRACTED FROM THE USER BUFFER
; AND GIVEN TO THE ECHO FORMAT ROUTINES TO OUTPUT CORRECTLY.
;
; IF CONTROL O HAS STOPPED THE OUTPUT THE OPERATION IS COMPLETED.
;
; INPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R5 = UCB ADDRESS
;
; Implicit inputs:
;
;	UCB$L_TT_WRTBUF	- address of write buffer
;
; OUTPUTS:
;
;	R2 = ADDRESS OF THE TERMINAL STATE VECTOR
;	R3 = CHARACTER TO OUTPUT IF ANY
;	R5 = UCB ADDRESS
;--

	.ENABLE	LSB
WRITING:
	MOVL	UCB$L_TT_WRTBUF(R5),R4	; Get address of buffer block.
	IF_STATE CTRLO,60$		; COMPLETE I/O OF CONTROL O
	MOVL	TTY$L_WB_NEXT(R4),R3	; GET ADDRESS OF NEXT CHARACTER
	CMPL	R3,TTY$L_WB_END(R4)	; DONE?
	BGEQU	50$			; IF GEQU THEN YES
	IF_STATE <PASALL,WRTALL>,BURST
	BRW	FORMAT			; FORMAT FOR OUTPUT

;
; WRITE I/O DONE
;

50$:					; Normal return.
	IF_NOT_STATE	<PASALL,WRTALL>,55$
	CLRW	UCB$W_TT_CURSOR(R5)	; AT CONCLUSION OF PASSALL/WRITALL
	CLRB	UCB$B_TT_LASTC(R5)	; STATE IS UNKNOWN
55$:
	MOVW	#SS$_NORMAL,-		; Load success status code into
		TTY$W_WB_STATUS(R4)	; buffer header.
	BRB	70$			; CONTINUE

;
; CONTROL O TYPED OR CONTROL Y OR C
;

60$:					; Control-O.
	MOVW	#SS$_CONTROLO,-		; Load control-O status code
		TTY$W_WB_STATUS(R4)	; into buffer header.

70$:					; Complete transfer.
	SUBL3	TTY$L_WB_NEXT(R4),-	; Calculate number of characters
		TTY$L_WB_END(R4),R3	; not output to terminal.
	SUBW	R3,TTY$W_WB_BCNT(R4)	; Adjust transfer count.
	BSBW	TTY$WRITEDONE		; Do I/O done.
	BRW	TTY$GETNEXTCHAR		; Get the next character.


WRITE_END:
	IF_STATE CTRLO,60$		; CONTROL O
	BRB	70$			; COMPLETE WITH CURRENT STATUS

	.DISABLE	LSB
	

	.SBTTL BURST/STRING - SET UP OUTPUT FOR BURST MODE
;++
; BURST/STRING -- SET UP OUTPUT FOR BURST MODE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE RETURNS THE ADDRESS AND LENGTH OF THE CURRENT 
; OUTPUT TO THE CALLER. DUETIM IS COMPUTED BASED ON THE LENGTH OF THE
; OUTPUT. THE CURRENT WRITE POINTERS ARE UPDATED TO REFLECT THE
; NUMBER OF CHARACTERS INCLUDED IN THE BURST.
;
; INPUTS:
;	R3 = ADDRESS OF NEXT CHARACTER
;	R4 = TWP ADDRESS
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R3 = ADDRESS OF NEXT CHARACTER
;	R5 = UCB ADDRESS
;	UCB$L_TT_OUTADR = ADDRESS OF START OF BURST
;	UCB$L_TT_OUTLEN = LENGHT OF BURST
;--
BURST:
	SUBL3	R3,TTY$L_WB_END(R4),R2		; COMPUTE LENGTH OF RECORD

STR_EXIT:
	MOVZWL	R2,R2				; CONVERT TO WORD VALUE
	ADDL	R2,TTY$L_WB_NEXT(R4)		; UPDATE NEXT CHARACTER ADDRESS
	MOVW	R2,UCB$W_TT_OUTLEN(R5)		; SET OUTPUT SIZE
	MOVL	R3,UCB$L_TT_OUTADR(R5)		; SET OUTPUT ADDRESS

STR_TIMESET:
	TIMSET	R2,R1,LOCKOUTPUT		; COMPUTE THE TIME PER CHARACTER
						; AND SETUP INTERUPTS
	MNEGB	#1,UCB$B_TT_OUTYPE(R5)		; SET NEGATIVE CC TO SIGNAL 
						; STRING OUTPUT
	RSB



	.SBTTL FORMAT - FORMAT STRING FOR OUTPUT
;++
; FORMAT -- FORMAT STRING FOR OUTPUT
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE RETURNS THE ADDRESS AND LENGTH OF A PORTION OF THE
; CURRENT FORMATTED OUTPUT STRING TO THE CALLER.
; IF NO SIGNIFICANT PORTION OF THE STRING CAN BE FOUND, IT
; DEFAULTS TO SINGLE CHARACTER FORMAT MODE.
; DUETIM IS COMPUTED BASED ON THE LENGTH OF THE
; OUTPUT. THE CURRENT WRITE POINTERS ARE UPDATED TO REFLECT THE
; NUMBER OF CHARACTERS INCLUDED IN THE BURST.
; 
;
; INPUTS:
;	R2 = ADDRESS OF UNIT STATE VECTOR
;	R3 = ADDRESS OF NEXT CHARACTER
;	R4 = TWP ADDRESS
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R2 = ADDRESS OF UNIT STATE VECTOR
;	R3 = ADDRESS OF NEXT CHARACTER
;	R5 = UCB ADDRESS
;	UCB$L_TT_OUTADR = ADDRESS OF START OF BURST
;	UCB$L_TT_OUTLEN = LENGHT OF BURST
;
;		 OR
;	R3 = NEXT CHARACTER TO OUTPUT
;--
FORMAT:
	PUSHL	R0				; CSR MUST ALWAYS BE PRESERVED
	IF_STATE <ESC_O>,FORMAT_X		; IF ESCAPE IN PROGRESS, SPECIAL
	SUBL3	R3,TTY$L_WB_END(R4),R0		; CALCULATE LENGTH OF STRING
	BBS	#TT$V_WRAP,UCB$L_DEVDEPEND(R5),3$; IF WE ARE A NO-WRAP
	BBS	#TT$V_SCOPE,UCB$L_DEVDEPEND(R5),5$; SCOPE THEN OUTPUT THE MAXIMUM
						; THAT WE CAN.
3$:	SUBW3	#1,UCB$W_DEVBUFSIZ(R5),-	; COMPUTE EOL-1
		R1
	SUBW2	UCB$W_TT_CURSOR(R5),R1		; COMPUTE ROOM TILL EOL-1
	BLEQU	FORMAT_X			; EOL REACHED

	CVTWL	R1,R1				;
	CMPL	R1,R0				; OUTPUT SIZE IS LESS OF TWO
	BLEQ	10$
5$:	MOVL	R0,R1				; ACTUAL IS LESS

10$:
	MOVZBL	(R3),R0				; TEST FIRST CHARACTER
	BITB	#<TTY$M_CH_CTRL!TTY$M_CH_SPEC!TTY$M_CH_CTRL2!TTY$M_CH_CTRL3>,-
		W^TTY$A_TYPE[R0]
	BNEQ	FORMAT_X

	PUSHR	#^M<R1,R2,R3>			; SAVE LENGTH, ADDRESS
	SCANC	R1,(R3),W^TTY$A_TYPE,-		; SKIP ALL NON SPECIALS 
	#<TTY$M_CH_CTRL!TTY$M_CH_SPEC!TTY$M_CH_CTRL2!TTY$M_CH_CTRL3>
						; TO ALLOW SINGLE BURST OUTPUT
20$:
	POPR	#^M<R1,R2,R3>			; RESTORE LENGTH , ADDRESS
	SUBL	R0,R1				; COMPUTE NUMBER CHARS FOUND
	BEQL	FORMAT_X			; YES
	ADDW	R1,UCB$W_TT_CURSOR(R5)		; UPDATE FINAL CURSOR
						; THIS ASSUMES ALL CHARS
						; < SPACE ARE SPECIALS
	CLR_STATE <NL,SKIPLF,WRAP>		; 
	MOVL	R1,R2				; LENGTH OF STRING TO OUTPUT
	POPL	R0				; RESTORE
	SUBL3	#1,R2,R1			; CALC N-1
	MOVB	(R3)[R1],UCB$B_TT_LASTC(R5)	; LASTC IS FINAL CHARACTER OUTPUT
	BRW	STR_EXIT			; TAKE COMMON STRING EXIT

FORMAT_X:
	POPL	R0				; RESTORE
	MOVZBL	(R3),R3				; GET CHARACTER
	INCL	TTY$L_WB_NEXT(R4)		; BUMP NEXT POINTER
	BRW	FORMAT_CHAR			; HANDLE AS SINGLE

	.SBTTL	OUTPUTANDWAIT - OUTPUT CHARACTER AND WAIT FOR INTERRUPT
;++
; OUTPUTANDWAIT - OUTPUT A CHARACTER AND WAIT INTERRUPT
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS USED BY THE OUTPUT INTERRUPT ROUTINES TO RETURN
; TO THE DEVICE DEPENDENT CODE TO OUTPUT A CHARACTER. THEIR RETURN
; CAUSES THE UNIT TO ENTER A WAIT FOR INTERRUPT STATE.
;
; INPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R3 = CHARACTER TO OUTPUT
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	THE UNIT IS PLACED IN A WAIT FOR INTERRUPT STATE
;	AND THE CONDITION CODES ARE SET TO PLUS INDICATING
;	SINGLE CHARACTER IN R3.
;
;	R5 = UCB ADDRESS
;--
OUTPUTANDWAIT:				; OUTPUT CHARACTER AND WAIT ENTRY
	MOVB	R3,UCB$B_TT_LASTC(R5)	; SAVE LAST CHARACTER OUTPUT
OUTPUTANDWAIT1:
	TIMSET	1,,LOCKOUTPUT		; ENABLE THE TIMER WITH A MINIMUM
					; OF 1 SECOND AND INTERLOCK THE
					; OUTPUT STREAM
	MOVB	#1,UCB$B_TT_OUTYPE(R5)	; SET THE KIND OF OUTPUT
	RSB				; AND RETURN WITH CHARACTER


	.SBTTL	FORMAT_CHAR - FORMAT CHARACTER FOR OUTPUT
 
	.ENABL	LSB
;++
; FORMAT_CHAR - FIND PROPER OUTPUT FOR SPECIFIED CHARACTER
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE TRANSLATES THE SPECIFIED CHARACTER FOR OUTPUT
; ON THE TARGET UNIT. THE OUTPUT OF THE SEQUENCE IS EITHER
; THE ORIGIONAL CHARACTER OR A STARTUP OF THE PROPER MULTIECHO
; STRING. CURSOR ADJUSTMENT IS ALSO DONE HERE FOR PRINTING
; CHARACTERS AND FORM CHARACTERS. IT IS POSSIBLE FOR THE RESULT TO BE NO OUTPUT.
;
; SEE EACH SPECIAL CHARACTER ROUTINE FOR MORE DETAILS ON ECHOING.
;
; INPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R3 = CHARACTER TO TRANSLATE
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R3 = CHARACTER TO OUTPUT NEXT IF ANY
;	R5 = UCB ADDRESS
;--
5$:	IF_NOT_STATE <ESC_O>,OUTPUTANDWAIT; BR IF NOT OUTPUT ESC
	BSBW	ESCSYNTAX_O		; CHECK CHAR AGAINST ESC SYNTAX
	BGTR	OUTPUTANDWAIT		; SYNTAX OK, OUTPUT CHARACTER
	IF_NOT_STATE <MULTI>,8$		; IF MULTIECHOING AND EDITING
	IF_STATE <EDITING>,10$		; DON'T ZERO CURSOR
8$:	CLRW	UCB$W_TT_CURSOR(R5)	; ZERO CURSOR (COLUMN) POSITION
10$:	BBSC	#TTY$V_ST_ESC_O,4(R2),-	; SEQUENCE ENDED CORRECTLY
		GOOUT			; CLEAR STATE AND BRANCH ALWAYS
FORMAT_CHAR:
	IF_STATE <PASALL,ESC_O,WRTALL>,5$	; BR IF FORMAT NOT NEEDED
	CASE	W^TTY$A_TYPE[R3],LIMIT=#1@TTY$V_CH_SPEC,TYPE=B,<-		
			BSPACE,-
			TAB,-
			LINEFEED,-
			VTAB,-
			FORM,-
			CARRIAGE,-
			CTRLZ>

	PUSHAB	OUTPUTANDWAIT		; SET RETURN PC FOR ADJUST_CURSOR
					; AND FLOW INTO ADJUST_CURSOR

	.DSABL	LSB


	.SBTTL	ADJUST_CURSOR - Increment cursor and set wrap if needed

ADJUST_CURSOR:				; ADJUST CURSOR 

	BITB	#<TTY$M_CH_CTRL!TTY$M_CH_SPEC!TTY$M_CH_CTRL2!TTY$M_CH_CTRL3>,-
	W^TTY$A_TYPE[R3]		; TEST FOR SPECIAL
	BNEQ	30$			; NON SPACING CHARACTER
	INCW	UCB$W_TT_CURSOR(R5)	; ADJUST CURSOR
	CMPW	UCB$W_TT_CURSOR(R5),UCB$W_DEVBUFSIZ(R5) ; OVERRUN?
	BGEQU	5$			; YES

25$:	CLR_STATE -			; Set not at newline,
		<NL,SKIPLF,WRAP>	; clear SKIPLF and WRAP.
26$:	RSB

5$:
	BBS	#TT$V_WRAP,UCB$L_DEVDEPEND(R5),10$; BR IF WRAP ENABLED
	BEQL	25$			; IF EQL THEN AT END OF LINE AND OK
	BBS	#TT$V_SCOPE, -		; IF SCREEN TERMINAL,CONTINUE
		UCB$L_DEVDEPEND(R5),25$	;
	TSTL	(SP)+			; DO NOT RETURN TO BSB TO DROP 
	BRW	DROP			; IF HARDCOPY,DROP CHARACTER
10$:	SET_STATE	CURSOR		; SET CURSOR OVERFLOWED
	BRB	25$

30$:	CMPB	#TTY$K_ET_ESCAPE,TTY$A_CCLIST[R3]; IS THIS AN ESCAPE OR CSI
	BNEQ	26$			; NO THEN DON'T COUNT IT
	TSTL	(SP)+			; DO NOT RETURN TO BSB TO DROP 
 	BRW	ESCAPE			; *** FALL INTO THE ESCAPE CODE	

	.SBTTL	FORMAT_LOCAL - FORMAT CHARACTER FOR OUTPUT
 
;++
; FORMAT_LOCAL - FIND PROPER OUTPUT FOR SPECIFIED CHARACTER
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE TRANSLATES THE SPECIFIED CHARACTER FOR OUTPUT
; ON THE TARGET UNIT FOR A NOECHO TERMINAL. THE OUTPUT OF THE 
; SEQUENCE MAY BE THE STARTUP OF THE PROPER MULTIECHO
; STRING. OTHERWISE, CURSOR ADJUSTMENT IS ALSO DONE HERE FOR PRINTING
; CHARACTERS AND FORM CHARACTERS. 
; IT IS POSSIBLE FOR THE RESULT TO BE NO OUTPUT.
;
; SEE EACH SPECIAL CHARACTER ROUTINE FOR MORE DETAILS ON ECHOING.
;
; INPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R3 = CHARACTER TO TRANSLATE
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R3 = CHARACTER TO OUTPUT NEXT IF ANY
;	R5 = UCB ADDRESS
;--

FORMAT_LOCAL:
	CASE	W^TTY$A_TYPE[R3],LIMIT=#1@TTY$V_CH_SPEC,TYPE=B,<-
			BSPACE,-
			TAB_LOCAL,-
			LINEFEED,-
			VTAB,-
			FORM,-
			CARRIAGE,-
			CTRLZ>
;
; SPECIAL FORMATTING WAS NOT NEEDED - SIMPLY INCREMENT CURSOR
; FOR THE LOCALLY-ECHOED CHARACTER AND CONTINUE.
;
	BSBB	ADJUST_CURSOR		; ADJUST CURSOR
	BRW	GETNEXTCHAR		; GET ANOTHER CHARACTER
GOOUT:	BRW	OUTPUTANDWAIT

	.SBTTL	CHARACTER OUTPUT FORMAT ACTION ROUTINES
	.SBTTL	BACKSPACE - output a backspace

;++
; BACKSPACE - OUTPUT A BACKSPACE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE OUTPUTS A BACKSPACE ON  A TERMINAL.
;
; INPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R3 = TTY$C_BS
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R3 = TTY$C_BS
;	R4 = ADDRESS OF THE BS/SPACE/BS STRING IF APPROP.
;	R5 = UCB ADDRESS
;--
BSPACE:					; BACKSPACE
	DECW	UCB$W_TT_CURSOR(R5)	; ADJUST HORIZON
	BRW	OUTPUTANDWAIT		; OUTPUT THE CHARACTER

	.SBTTL	CARRIAGE - format a carriage return

;++
; CARRIAGE - FORMAT FOR CARRIAGE RETURN
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE SETS UP THE PROPER FILL FOR A CARRIAGE RETURN ON
; THE TARGET UNIT.
;
; INPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R3 = TTY$C_CR
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R3 = TTY$C_CR
;	R5 = UCB ADDRESS
;--
CARRIAGE:				;
	CLR_STATE <NL>			; SET NOT AT NEW LINE.
CROUTPUT:
	IF_STATE -			; If in a write state, branch
		WRITE,115$		; forward.
	IF_NOT_STATE -			; If not in a read state, also
		READ,115$		; branch forward.
	IF_STATE <MULTI,EDITREAD>,130$	; not a character echo or wrap
	MOVL	UCB$L_SVAPTE(R5),R1	; GET THE PACKET ADDRESS
	MOVZWL	TTY$W_RB_LINOFF(R1),R4	; GET THE OFFSET TO THIS CHARACTER
	MOVAB	@TTY$L_RB_LIN(R1)[R4],TTY$L_RB_LIN(R1); AND MAKE THIS THE NEW
	CLRW	TTY$W_RB_LINOFF(R1)	; LINE BEGININNG
	CLRW	TTY$W_RB_LINREST(R1)	; JUST MAKE SURE WE ARE AT THE END
	BBC	#TTY$V_PC_NOCRLF,UCB$W_TT_PRTCTL(R5),110$;SO JUST ECHO THE CHARACTER NOW(WITH LINEFEED)
	SET_STATE SKIPLF		; NO FREE LINEFEED
	BRB	115$			; ELSE DON'T DO THE LINEFEED

130$:	IF_NOT_STATE CTRLR,110$		; 
;
; THE FOLLOWING CODE WILL INSERT A LINEFEED AFTER ANY CARRIAGE RETURN
; THAT IS THE LAST CHARACTER IN THE READ PROMPT STRING OR IN THE READ BUFFER
; ITSELF.  ANY <CR> CHARACTERS IN THE PROMPT STRING PRIOR TO THE LAST CHARACTER
; ARE NOT TOUCHED.
;
	MOVL	UCB$L_SVAPTE(R5),R1	; GET THE READ PACKET ADDRESS
	MOVZWL	TTY$W_RB_PRMLEN(R1),R4	; GET THE PROMPT LENGTH
	MOVAB	TTY$A_RB_PRM(R1)[R4],R4	; AND THIS IS THE ADDRESS
	CMPL	UCB$L_TT_MULTI(R5),R4	; IS THIS CR PAST END OF PROMPT?
	BGEQU	112$			; YES THEN FORCE LINEFEED
; In the case where we are sending a clear to end of line sequence (signaled
; by SKIPCRLF being set) then
; we don't want the linefeed to show up if there is one after a leading
; <CR>.  The case where there is a leading linefeed is handled by 
; setting SKIPLF in the EDITREAD routine.
;
	IF_NOT_STATE SKIPCRLF,115$	; IF NO LINEFEEDS WANTED THEN
	CLR_STATE <SKIPCRLF>		; CLEAR NO LINEFEED
	ADDL3	#TTY$L_RB_DATA+1,UCB$L_SVAPTE(R5),R4; GET THE ADDRESS OF THE
	CMPL	UCB$L_TT_MULTI(R5),R4	; FIRST CHARACTER AND SEE IF THIS IS IT
	BNEQU	115$			; NO THEN HANDLE NORMALY
	SET_STATE <SKIPLF>		; OTHERWISE SKIP THE LINEFEED
	BRB	115$			; AND HANDLE NORMALY.

110$:
	IF_STATE <SKIPCRLF>,115$
112$:	SET_STATE <SENDLF,SKIPLF>	; SET STATE TO FORCE LF AND SKIP NEXT REAL ONE
115$:
	CLRW	UCB$W_TT_CURSOR(R5)	; RESET HORIZON
	CMPB	UCB$B_TT_LASTC(R5), -	; OPTIMIZATION: WAS LAST CHAR
		#TTY$C_CR		; A CARRIAGE RETURN?
	BEQL	DROP			; YES, DON'T OUTPUT ANOTHER
	MOVB	UCB$B_TT_CRFILL(R5),UCB$B_TT_FILL(R5); SET UP FILL
	BEQL	120$			; IF EQL THEN OUTPUT
	SET_STATE FILL			; OTHERWISE OUTPUT
120$:	BRW	OUTPUTANDWAIT
DROP:	BRW	GETNEXTCHAR		; CONTINUE IN NEXT LOGICAL STATE

	.SBTTL	CTRLZ - output control-Z

;++
; CTRLZ - OUTPUT A CONTROL Z BASED ON THE OPERATION
;
; FUNCTIONAL DESCRIPTION:
;
; IF THE CURRENT OPERATION IS A READ AND THE ^Z IS A TERMINATOR THE ECHO ^Z.
;
; INPUTS:
;
; 	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R3 = CONTROL Z
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R3 = CONTROL Z
;	R4 = ADDRESS OF THE MULTIECHO STRING FOR CONTROL Z IF APPROP.
;	R5 = UCB ADDRESS
;--
CTRLZ:					; CONTROL Z
	IF_STATE WRITE,300$		; IF THERE IS A WRITE ACTIVE THEN
					; ECHO NORMALY
	IF_NOT_STATE READ,300$		; OUTPUT 26(8) IF NOT READ
	IF_NOT_STATE EOL,300$		; ^Z IF TERMINATOR
	MOVL	TTY$A_EXITECHO,R4	; ADDRESS MULTIECHO STRING
	BBC	#TT2$V_DECCRT,UCB$L_DEVDEPND2(R5),299$
	SET_STATE NINTMULTI		; DON'T ALLOW THIS TO BE INTERUPTED
	MOVAL	4(R4),R4		; OUTPUT THE DECCRT CONTROL-Z
299$:	MOVL	(R4),R4			; GET THE ACTUAL STRING ADDRESS
	BRW	STRTMULTI		; START OUTPUT
300$:	BRW	OUTPUTANDWAIT

	.SBTTL	ESCAPE - format an escape character

;++
; ESCAPE - FORMAT A ESCAPE BASED ON OPERATION AND TARGET UNIT
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE FORMATS ESCAPES.
;
; READ OPERATION:
;
;	A "$" IS ECHOED IF THE ESCAPE IS A TERMINATOR.
;
; WRITE OPERATION:
;
;	THE ESCAPE IS OUTPUT. ON TERMINALS WITH THE CHARACTERISTIC TT$M_ESCAPE,
;	THE REMAINDER OF THE SEQUENCE IS CHECKED FOR SYNTACTIC CORRECTNESS.
;
; INPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R3 = ESCAPE
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R3 = ESCAPE OR "$"
;	R5 = UCB ADDRESS
;--
ESCAPE:					; OUTPUT ESCAPE STRING
	IF_NOT_STATE EOL,250$		; ALSO IF NOT TERMINATOR
	IF_STATE <MULTI,WRITE,EDITREAD>,250$; MULTIECHO THEN ASSUME SEQUENCE
	MOVZBL	#TTY$C_DOLLAR,R3	; OTHERWISE ECHO DOLLAR SIGN
	BSBW	ADJUST_CURSOR		; ADJUST CURSOR 
	BRW	OUTPUTANDWAIT		; AND OUTPUT
;
; OUTPUT ESCAPE ON WRITE OR CONTROL R
;
250$:
	BBS	#TT2$V_ANSICRT,UCB$L_DEVDEPND2(R5),255$ ; BR IF ANSI TERMINAL
	IF_STATE <ESCAPE>,255$		; IS THIS ESCAPE MODE
	CMPB	#TT$_VT5X,UCB$B_DEVTYPE(R5) ;VT5X OR VT100 TERMINAL?
	BLEQU	252$			; If LEQU, then maybe.
	BRB	260$			; Otherwise, no.

252$:
	CMPB	#TT$_VT100+32,UCB$B_DEVTYPE(R5);
	BGTRU	255$			; If GTRU, then yes.
	BRB	260$			; Otherwise, no.

255$:
	SET_STATE <ESC_O>		; OUTPUTTING AN ESCAPE SEQUENCE
	PUSHL	R1			; SAVE R1
	BSBW	ESCINIT			; INIT THE ESCAPE SEQUENCE RULES
	MOVB	R1,UCB$B_TT_ESC_O(R5)	; ...
	POPL	R1			; RESTORE R1

	IF_NOT_STATE <MULTI>,260$	; MULTIECHOING AND EDITING
	IF_STATE <EDITING>,270$		; DON'T ZERO CURSOR
260$:
	CLRW	UCB$W_TT_CURSOR(R5)	; ZERO CURSOR (COLUMN) POSITION
270$:	BRW	OUTPUTANDWAIT		; FALL INTO OUTPUT AND WAIT

	.SBTTL	LINEFEED - format a line feed

;++
; LINEFEED - FORMAT LINE FEED FOR TARGET UNIT
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE SETS UP THE PROPER FILL FOR A LINE FEED ON THE TARGET
; UNIT AND ADJUSTS THE CURSOR AND VERTICAL LINE COUNT.
;
; INPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R3 = TTY$C_LF
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R3 = TTY$C_LF
;	R5 = UCB ADDRESS
;--
	.ENABLE LSB
LINEFEED:
	BBSC	#TTY$V_ST_SKIPLF,4(R2),227$; SKIP AND SET OFF SKIP CONDITION
;
; NOTE THAT BECAUSE OF ACBB'S SIGNED BRANCH IT IS NOT APPROPRIATE HERE.
;
LFOUTPUT:
	TSTW	UCB$W_TT_CURSOR(R5)	; LINE FEED AT CURSOR 0 IS NEWLINE
	BNEQ	210$			; IF NEQ THEN NO NL POSSIBLE
	SET_STATE NL			; SET NEW LINE
210$:	INCB	UCB$B_TT_LINE(R5)	; ADJUST VERTICAL COUNT
	CMPB	UCB$B_TT_LINE(R5),UCB$L_DEVDEPEND+3(R5);
	BLSSU	215$			; IF LSSU THEN NO PAGE CROSS
	CLRB	UCB$B_TT_LINE(R5)	; RESET VERTICAL POSITION
215$:	IF_NOT_STATE WRITE,220$		; BR IF NOT WRITE
	MOVL	UCB$L_TT_WRTBUF(R5),R4	; Address current write buffer.
	MOVL	TTY$L_WB_IRP(R4),R4	; Get associated IRP address.
	BEQL	220$			; Branch if no IRP.
	INCW	IRP$L_MEDIA(R4)		; COUNT LINE
220$:	MOVB	UCB$B_TT_LFFILL(R5),UCB$B_TT_FILL(R5); INSERT TO CAUSE FILL
	BEQL	225$			; OUTPUT IF NO FILL NEEDED
	SET_STATE FILL			; OUTPUT FILL CHARACTERS
225$:	BRW	OUTPUTANDWAIT
227$:	BRW	DROP
	.DISABLE LSB

	.SBTTL	TAB - Output a tab.

;++
; TAB - OUTPUT A TAB ON THE TARGET TERMINAL BASED ON CURSOR POSITION
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS ENTERED TO OUTPUT A TAB ON THE TARGET UNIT.
; IF THE TERMINAL HAS MECHANICAL TAB THEN THE TAB GOES DIRECT.
; OTHERWISE, THE CURSOR POSITION IS USED TO CALC. HOW MANY BLANKS
; TO OUTPUT TO MOVE THE CURSOR TO THE NEXT TAB STOP.
;
; INPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R3 = TTY$C_TAB
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R3 = TTY$C_TAB
;	R4 = ADDRESS OF TAB MULTIECHO STRING IF APPROP.
;	R5 = UCB ADDRESS
;--
TAB:	EXTZV	#0,#3,UCB$W_TT_CURSOR(R5),R4; GET HORIZON POINTER
	IF_STATE TABEXPAND,525$		; EXPAND THE TABS
	BBS	#TT$V_MECHTAB,UCB$L_DEVDEPEND(R5),530$; OUTPUT IF MECHANICAL HELP
525$:	SUBW3	R4,#8,R1		;SETUP THE LENGTH OF THE TAB
	MOVAB	W^TTY$A_TAB+1,R4	; ADDRESS STRING TO OUTPUT
	BRW	STRTMULTI_1		; START MULTIPLE OUTPUT
;
; MECHANICAL TAB TERMINAL
;
; THIS ROUTINE ASSUMES THAT THE TABS ARE SET ON 8'S
;
530$:	CMPB	#TT$_VT5X,UCB$B_DEVTYPE(R5); IN RANGE FOR SPECIAL CASE VT5X
	BGTRU	535$			; IF GTR THEN NO
	CMPB	#TT$_VT100+32,UCB$B_DEVTYPE(R5); 
	BLEQU	535$			; 
	SUBW3	UCB$W_TT_CURSOR(R5),UCB$W_DEVBUFSIZ(R5),R3; DISTANCE FROM RIGHT
	BLEQU	534$			; IF LEQU THEN SKIP TEST
	CMPW	#8,R3			; IN LAST TAB SPACE?
	BGEQU	525$			; IF TRUE THEN SKIP MECH TAB
534$:	MOVZBL	#TTY$C_TAB,R3		;
535$:	BICW	R4,UCB$W_TT_CURSOR(R5)	; SETUP CURSOR STOP ON 8
	ADDW	#8,UCB$W_TT_CURSOR(R5)	;
	CLR_STATE -			; No longer at newline; haven't
		<NL,WRAP>		; just wrapped.
	BRW	OUTPUTANDWAIT		;
;
; FOR LOCAL TABS, TRACK POSITION, BUT DON'T ECHO
;

TAB_LOCAL:
	EXTZV	#0,#3,UCB$W_TT_CURSOR(R5),R4; GET HORIZON POINTER
	BICW	R4,UCB$W_TT_CURSOR(R5)	; SETUP CURSOR STOP ON 8
	ADDW	#8,UCB$W_TT_CURSOR(R5)	;
	CLR_STATE -	
		<NL,WRAP>
	BRW	GETNEXTCHAR		; GET NEXT OUTPUT CHARACTER

	.SBTTL	VTAB, FORM - output a vertical tab, or form feed

;++
; VTAB - OUTPUT A VERTICAL TAB
; FORM - OUTPUT A FORM FEED
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE SETS UP THE PROPER OUTPUT STRING FOR A VTAB OF FORM FEED
; ON THE TARGET UNIT.  VTAB TRANSLATES TO 4 LINE FEEDS. AND FORM FEED
; TO MULTIPLE LINE FEEDS BASED ON THE PRESENCE OF MECHANICAL HELP
; AND THE CURRENT VERTICAL LINE POSITION. TO AVOID THE NECESSITY
; FOR A LARGE NUMBER OF LF DATA BYTES THE FORM FEED CAUSES A MULTI
; ECHO STRING OF 4 LINE FEEDS FOLLOWED BY ANOTHER FORM FEED TO BE
; OUTPUT UNTIL A PAGE CROSS TAKES PLACE.
;
; INPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R3 = C_VTAB OR C_FF
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R5 = UCB ADDRESS
;--
VTAB:	MOVAB	W^TTY$A_VTAB,R4		; SET UP OUTPUT
	BRW	STRTMULTI		; START MULTIPLE OUTPUT
;
; FORM FEED
;
FORM:	BBC	#TT$V_MECHFORM, -	; BRANCH IF TERMINAL DOES NOT
		UCB$L_DEVDEPEND(R5), -	; SUPPORT MECHNICAL FORM FEEDS
		505$			;
	CLRB	UCB$B_TT_LINE(R5)	; RESET LINE POSITION
	BRW	OUTPUTANDWAIT		;
505$:	CLRL	R4			; SEND MULTIPLE LINE FEEDS
	SUBB3	UCB$B_TT_LINE(R5),UCB$L_DEVDEPEND+3(R5),R4; GET NUMBER TO END OF PAGE
	CMPB	R4,#4			; OUTPUT THE LF'S IN GROUPS OF 8
	BGTRU	520$			; IF GTRU THEN MORE THAN 4 TO OUTPUT
510$:	ADDW3	#1,R4,R1		; GET THE NUMBER OF LINEFEEDS
	MOVAB	W^TTY$A_FORM+1,R4	; GET THE ADDRESS OF THE STRING
	BRW	STRTMULTI_1		; START OUTPUT
520$:	MOVAB	W^TTY$A_LONGFORM,R4	; GET ADDRESS TO STRING
	BRW	STRTMULTI		;

	.SBTTL	DISPATCHER SERVICE ROUTINES

	.SBTTL	BACKSPACING - OUTPUT N BACKSPACES
;++
; BACKSPACING:
;
; DESCRIPTION:
;	SEND A GIVEN NUMBER OF BACKSPACES TO THE TERMINAL
;
; INPUTS:
;	R2 = UNIT STATE VECTOR ADDRESS
;	R5 = UCB ADDRESS
;	UCB$W_TT_MULTILEN = NUMBER OF BACKSPACES TO OUTPUT
;--
BACKSPACING:
	DECW	UCB$W_TT_BSPLEN(R5)	; SUBTRACT ONE AND OUTPUT THE BACKSPACE
	BLSS	10$			; NO MORE THEN FINISH UP
	MOVZBL	#TTY$C_BS,R3		; SETUP BACKSPACE
	BRW	FORMAT_CHAR		; AND FORMAT THE CHARACTER
10$:	CLR_STATE BACKSPACE		; CLEAR THE STATE WHEN DONE
	BRW	GETNEXTCHAR		; AND GET THE NEXT CHARACTER


	.SBTTL	CURSOROVRFLOW - insert newline to handle end of line
;++
; CURSOROVRFLOW - INSERT A NEWLINE IN THE OUTPUT STREAM
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS ENTERED TO INJECT A CR/LF IN THE OUTPUT
; STREAM REGARDLESS OF THE CURRENT STATE.
;
; INPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R3 = TTY$C_CR
;	R4 = READ PACKET ADDRESS
;	R5 = UCB ADDRESS
;--
CURSOROVRFLOW:				;
	CLR_STATE CURSOR		; CLEAR THE CONDITION
	SET_STATE WRAP			; Signal WRAPping.
	IF_NOT_STATE READ,99$		; IF WE ARE NOT READING THEN HANDLE NORMALY
	IF_STATE RDVERIFY,98$		; NO CURSOR ORERFLOW ON READ VERIFY'S
	MOVL	UCB$L_SVAPTE(R5),R4	; OTHERWISE GET THE PACKED ADDRESS
	IF_NOT_STATE CTRLR,97$		; IF WE ARE CONTROL-RING HANDLE NORMALY
	CMPL	UCB$L_TT_MULTI(R5),TTY$L_RB_LIN(R4); IF WE AREN'T ON THE LAST LINE
	BLEQU	99$			; THEN DON'T WORRIE ABOUT LINREST
97$:	TSTW	TTY$W_RB_LINREST(R4)	; ARE WE IN THE MIDDLE OF A LINE
	BNEQ	98$			; YES THEN LEAVE THE STATUS QUOE
99$:	MOVZBL	#TTY$C_CR,R3		; SET FIRST CHARACTER IS CARRIAGE RETURN
	SET_STATE <SENDLF,SKIPLF>	; FORCE A FREE LINEFEED
	BRW	CROUTPUT		; CONTINUE WITH CARRIAGE RETURN CODE
98$:	BRW	DROP

	.SBTTL	EOLSEEN - handle end of line condition

;++
; EOLSEEN - END OF LINE SEEN
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS ENTERED AFTER AN END OF LINE CHARACTER HAS
; TERMINATED A READ RECORD AND THE ECHO OF THAT CHARACTER IS COMPLETE.
;
; THE ACTION IS TO COMPLETE THE READ OPERATION AND IF NECESSARY,
; SEND AN XOFF.
;
; INPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R5 = UCB ADDRESS
;--
EOLSEEN:				; END READ OPERATION
;
; IN ORDER FOR THE FINAL CHARACTERS OF A READ VERIFY READ TO ECHO
; PROPERLY EDIT READ MUST BE ALLOWED TO COMPLETE, THIS CAN BE DONE
; IN TWO WAYS, FIRST CHANGING THE STATE DISPATCHER TO ALLOW EDIT READ
; TO HAVE HIGHER PRIORITY THEN EOL.  THIS FIXES EOL IN THE STATE TABLE
; FOR NOW AND FOREVER.  BY PUTTING THIS CODE HERE IT ALLOWS EOL TO 
; MOVE TO ANY PLACE IN THE STATE DISPATCHER.
;
	IF_NOT_STATE RDVERIFY,5$	; LET EDIT READ COMPLETE UNDER
	IF_NOT_STATE EDITREAD,5$	; READ VERIFY
	BRW	EDITREAD		;...

5$:	MOVZBW	#SS$_NORMAL,UCB$W_BOFF(R5); SET STATUS
	BSBW	TTY$READONE		; COMPLETE THE I/O
	BRW	TTY$GETNEXTCHAR		; CONTINUE

	.SBTTL	FILLING - continue outputting fill characters

;++
; FILLING - CONTINUE FILL OUTPUT
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS ENTERED WHILE THE TRM$V_FILL STATE IS ON.
; THE FILL COUNT IS DECREMENTED AND IF NON 0 A FILL IS OUTPUT
; IF THE COUNT GOES TO 0 THEN THE FILL STATE IS CLEARED.
;
; INPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R3 = 0
;	R5 = UCB ADDRESS
;--
FILLING:				; OUTPUT CONTINUING FILLS
	DECB	UCB$B_TT_FILL(R5)	; ADJUST FILL COUNT
	BNEQ	25$			; IF NEQ THEN NOT DONE YET
	CLR_STATE FILL			; SET CONDITION OFF
25$:	CLRL	R3			; SET FILL CHARACTER
	BRW	OUTPUTANDWAIT1		; OUTPUT THE CHARACTER

	.SBTTL	MULTIECHOING - Continue outputting multiecho sequence

;++
; MULTIECHOING - CONTINUE MULTIECHO STRING OUTPUT
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS ENTERED WHEN TTY$V_ST_MULTI IS SET. THE NEXT
; CHARACTER IN THE STRING ADDRESSED BY UCB$L_TT_MULTI IS OUTPUT.
; IF THE NEXT CHARACTER IS ZERO THEN THE STRING OUTPUT IS COMPLETE
; AND THE MULTIECHO CONDITION IS RESET FOLLOWED BY A RETURN TO
; THE OUTPUT STATE ANALYSIS ROUTINE IN GETNEXTCHAR.
; IF A LENGTH IS SPECIFIED IN UCB$W_TT_MULTILEN, THEN IT IS USED TO DETECT
; THE END OF STRING.
;
; INPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R5 = UCB ADDRESS
;
;	UCB$W_TT_MULTILEN = ALTERNATE LENGTH
;
; OUTPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R3 = CHARACTER TO OUTPUT ( FALL THROUGH TO ECHOFORMAT )
;	R5 = UCB ADDRESS
;--
MULTIECHOING:				; CONTINUE STRING MULTI ECHO
	DECW	UCB$W_TT_MULTILEN(R5)	; DECREMENT THE COUNT
	BGEQ	20$			; CONTINUE IF MORE LEFT
	MOVL	UCB$L_TT_SMLT(R5),UCB$L_TT_MULTI(R5); RESTORE SAVED ADDRESS
	MOVW	UCB$W_TT_SMLTLEN(R5),UCB$W_TT_MULTILEN(R5);AND LENGTH
	BGTR	10$
	CLR_STATE <MULTI,NINTMULTI>	; NO MORE THEN RESET THE STATE
	BRW	GETNEXTCHAR		; AND GET THE NEXT CHARACTER
10$:	CLRW	UCB$W_TT_SMLTLEN(R5)	; CLEAR THE SAVED LENGTH
	DECW	UCB$W_TT_MULTILEN(R5)	; SUBTRACT OUT THIS CHARACTER
20$:	MOVZBL	@UCB$L_TT_MULTI(R5),R3	; GET NEXT MULTI ECHO CHARACTER
	INCL	UCB$L_TT_MULTI(R5)	; ADJUST POINTER
	BRW	FORMAT_CHAR		;

	.SBTTL	SENDLINEFEED - output a line feed

;++
; SENDLINEFEED - INSERT LINE FEED IN OUTPUT STREAM
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS USED TO INSERT A LINE FEED IN THE OUTPUT STREAM.
;
; INPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R3 = TTY$C_LF
;	R5 = UCB ADDRESS
;--
SENDLINEFEED:				; SEND OUT A LINE FEED
	CLR_STATE SENDLF		; CLEAR CONDITION
	MOVZBL	#TTY$C_LF,R3		; SET TO OUTPUT LINE FEED
	BRW	LFOUTPUT		; CONTINUE IN LINE FEED CODE

	.SBTTL	ESCAPE SEQUENCE PARSING SERVICES
;++
;
; ESCINIT - INIT ESCAPE SEQUENCE RULES
;
; INPUTS:
;	R3 = CHARACTER THAT IS INTRODUCER
;
; OUTPUTS:
;	R1 = RULE TO START AT (BYTE)
;
ESCINIT::
	CLRL	R1			; USE THE NORMAL RULES 
	CMPB	R3,#^X80			; IF NOT AN 8 BIT CHARACTER
	BLSSU	10$			; ...
	MOVB	TTY$A_ESCINIT-^X80[R3],R1; ELSE MOVE THRU THE TABLE
10$:	RSB

	.SBTTL	ESCSYNTAX -- CHECK ESCAPE SEQUENCE SYNTAX

;++
; FUNCTIONAL DESCRIPTION:
;	This routine checks the syntax of escape sequences, one
;	character at a time.
;
; INPUTS:
;	R3 contains the next character to be checked for correct syntax
;	UCB$B_TT_ESC(R5) contains a offset to the next syntax
;		rule in the TTY$A_ESCAPE syntax table for input data.
;	UCB$B_TT_ESC_O(R5) contains the offset for output data.
;	Assume R4 is available
;
; OUTPUTS:
;	Condition codes are set:
;	CC = POSITIVE means the character is syntactically correct
;	CC = EQUAL means syntactic correctness and sequence is complete
;	CC = NEGATIVE means error in parsing sequence
;
;	If CC = POSITIVE the UCB$B_TT_ESC (ESC_O) offset is updated.
;--
;
; INPUT ESCAPE SEQUENCES
;

ESCSYNTAX:
	PUSHL	R4			; SAVE R4
	MOVZBL	UCB$B_TT_ESC(R5),R4	; GET CURRENT STATE
	BSBB	E_SYNTAX
	MOVB	R4,UCB$B_TT_ESC(R5)	; SAVE STATE
	POPL	R4			; AND RESTORE R4
	TSTB	UCB$B_TT_ESC(R5)	; SET THE CONDITION CODES
	RSB

;
; OUPUT ESCAPE SEQUENCES
;

ESCSYNTAX_O:
	MOVZBL	UCB$B_TT_ESC_O(R5),R4	; GET CURRENT STATE
	BSBB	E_SYNTAX
	MOVB	R4,UCB$B_TT_ESC_O(R5)	; SAVE CURRENT STATE
	RSB


;
; GENERAL SEQUENCE HANDLER
;

E_SYNTAX::

10$:	CMPB	R3, W^TTY$A_ESCAPE[R4]	; check range of character
	BLSSU	20$			; branch if not this rule
	CMPB	R3, W^TTY$A_ESCAPE+1[R4]; lower than high limit?
	BGTRU	20$			; look to next rule

	MOVZBL	W^TTY$A_ESCAPE+2[R4],-	; character is valid
		R4			; save offset to next rule

	RSB				; offset=POS => next rule exists
					; offset=0 => end of sequence

;
; Continue looking for correct sequence rule
;
20$:	TSTB	W^TTY$A_ESCAPE+2[R4]	; any next rule?
	BEQL	30$			; no; bad syntax
	ADDL	#3, R4			; offset to next rule
	BRB	10$			; continue syntax check
30$:	
	MNEGL	#1, R4			; error in sequence
	RSB

	.SBTTL MOVEREADATA - MOVE CHARACTER FROM TYPEAHEAD TO READ BUFFER
;++
; MOVEREADATA -- MOVE CHARACTER FROM TYPEAHEAD BUFFER TO READ BUFFER
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE MOVES A CHARACTER FROM THE TYPEAHEAD BUFFER AND STARTS
; THE ECHO. 
;
; NON-IMMEDIATE ACTION CONTROL SEQUENCES ARE HANDLED HERE.
;
; BEFORE RETURNING A CHARACTER FOR ECHO IT IS CONVERTED TO ITS
; MULTIPLE ECHO STRING IF APPROPRIATE. IN THIS CASE THE CHARACTER
; RETURNED IS THE FIRST OF THE MULTIPLE ECHO CHARACTERS.
;
; INPUTS:
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R3 = CHARACTER IF ANY (CC = EQL )
;	R5 = UCB ADDRESS
;--
;
; GOTO TABLE
;
TAB_NOTA:	BRW	NOTA
TAB_EOLSEEN:	MOVL	UCB$L_IRP(R5),R1
		CLRW	IRP$L_MEDIA(R1)
		BRW	EOLSEEN
TAB_DISMISS:	BRW	DISMISS
TAB_BUFEMPTY:	BRW	BUFEMPTY
TAB_INDELST:	BRW	INDELST
TAB_PASSALL:	BRW	PASSALL
TAB_GETNEXT:	BRW	GETNEXTCHAR
TAB_QUOTE:	BRW	QUOTE
TAB_EDITINGCHAR:BRW	EDITINGCHAR
TAB_ESCINPROG:	TSTB	R3		; NO NULLS IN ESCAPE SEQUENCES
		BEQL	TAB_DISMISS
		BRW	ESCINPROG
TAB_CVTLOW:	BRW	CVTLOW
TAB_OPEN:	BRW	OPEN
;
; MAIN LINE MOVE OUT OF BUFFER CODE
MOVEREADATA:				;
	.ENABLE LSB
	MOVL	UCB$L_SVAPTE(R5),R4	; SETUP R4 TO CONTAIN THE ADDRESS OF THE
	CLRL	TTY$L_RB_ECHSTR(R4)	; CLEAN OUT ANY UNUSED ECHO STRINGS
	CMPW	TTY$W_RB_TXTOFF(R4),TTY$W_RB_TXTSIZ(R4); TEST BUFFER FULL
	BGEQU	TAB_EOLSEEN		; BUFFER FULL THEN END
;
; MOVE CHARACTER OUT OF TYPEAHEAD BUFFER
;
	MOVL	UCB$L_TT_TYPAHD(R5),R4	; ADDRESS TYPEAHEAD BUFFER
	BEQL	TAB_NOTA		; NO BUFFER THEN THERE IS A FORK
					; PROCESS WAITING SO LET IT GO.
	DECW	TTY$W_TA_INAHD(R4)	; take the character out of typeahead
	BLSS	TAB_BUFEMPTY		; IF EQL THEN NO
	MOVZBL	@TTY$L_TA_GET(R4),R3	; GET THE CHARACTER
	IF_STATE DEL,TAB_INDELST	; ARE WE IN DELETE STATE
;
; ACTUALLY REMOVE CHARACTER FROM BUFFER
;
;
; CHECK FOR BUFFER WRAP AROUND
;
40$:	AOBLSS	TTY$L_TA_END(R4),TTY$L_TA_GET(R4),60$; POINTER PAST END?
	MOVAB	TTY$L_TA_DATA(R4),TTY$L_TA_GET(R4); RESET POINTER
;
; SKIP TESTS FOR SECOND CONTROL SEQUENCE SET IF PASSALL
;

60$:	MOVL	UCB$L_SVAPTE(R5),R4	; SETUP R4 TO CONTAIN THE ADDRESS OF THE
	IF_STATE <PASALL,NOFLTR>,TAB_PASSALL; IN PASSALL THEN PASS ALL
	IF_STATE QUOTING,TAB_QUOTE	; ARE WE QUOTING
67$:	MOVZBL	TTY$A_CCLIST[R3],R1	; GET THE TOKEN
	BNEQ	TAB_EDITINGCHAR		; SPECAIL ACTION THEN HANDLE SPECAILY
;
; INSERT THE CHARACTER
;
151$:	IF_STATE <ESC>,TAB_ESCINPROG; IF IN AN ESCAPE SEQUENCE THEN HANDLE AS SUCH
INSERT_CHAR:
152$:	MOVL	UCB$L_IRP(R5),R1	; GET THE IRP ADDRESS
	BBS	#IO$V_CVTLOW,IRP$W_FUNC(R1),TAB_CVTLOW; BR IF CONVERT LOWER TO UPPER
155$:	BBS	R3,@TTY$L_RB_TERM(R4),TERMFOUND; IS THIS CHARACTER A TERMINATOR
	MOVZWL	TTY$W_RB_LINOFF(R4),R1	; GET THE OFFSET INTO THE BUFFER
	TSTW	TTY$W_RB_LINREST(R4)	; DO WE HAVE TO OPEN THE BUFFER
	BNEQ	TAB_OPEN		; NO THEN HANDLE NORMALLY
159$:	MOVB	R3,@TTY$L_RB_LIN(R4)[R1]; INSERT CHARACTER
	INCW	TTY$W_RB_TXTOFF(R4)	; ADJUST POINTER
	INCW	TTY$W_RB_LINOFF(R4)	; ADD TO COUNT
;
; CHECK FOR FULL BUFFER
;
CHECK_BUFFER:
210$:	CMPW	TTY$W_RB_TXTOFF(R4),TTY$W_RB_TXTSIZ(R4); TEST BUFFER FULL
	BGEQU	212$			; BUFFER FULL THEN END
;
; ECHO THE CHARACTER IF NECESSARY
;
230$:	IF_STATE	<NOECHO,ESC,EDITREAD>,250$; IF NOECHO OR ESC THEN BRANCH
	BRW	FORMAT_CHAR		;
240$:	BRW	GETNEXTCHAR		; VECTOR TO TRANSFER MORE CHARACTERS
;
; BUFFER OVERFLOWED THEN TERMINATE
;
212$:	MOVL	UCB$L_IRP(R5),R1	; GET THE IRP ADDRESS
	CLRW	IRP$L_MEDIA(R1)		; SET NO TERMINATOR
	BICW	#IO$M_TRMNOECHO,IRP$W_FUNC(R1); FORCE POSSIBLE ECHO
	BRB	221$			; AND CONTINUE
;
; TERMINATOR FOUND BUT BUFFER NOT FULL
;
TERMFOUND:
	MOVL	UCB$L_IRP(R5),R1	; GET THE IRP ADDRESS
	MOVW	R3,IRP$L_MEDIA(R1)	; SAVE LAST CHARACTER FOR STATUS
	INCW	IRP$L_MEDIA+2(R1)	; SET TERMINATOR SIZE
	MOVZWL	TTY$W_RB_TXTOFF(R4),R1	; GET THE OFFSET TO THE LAST CHARACTER
	MOVB	R3,@TTY$L_RB_TXT(R4)[R1]; PUT THE LAST CHARACTER AWAY
	MOVL	UCB$L_IRP(R5),R1	; GET THE IRP ADDRESS BACK
221$:	SET_STATE <EOL>			; SET END OF LINE SEEN
225$:	BBS	#IO$V_TRMNOECHO,IRP$W_FUNC(R1),240$; BR IF NOT TERM NOECHO
	BRW	230$
;
; TEST FOR ECHO NEEDS
;
250$:	IF_STATE <EDITREAD,ESC>,240$	; CONTINUE IF ESCAPE
	BBC	#TT2$V_LOCALECHO,-
		UCB$L_DEVDEPND2(R5),240$ ; NO FORMATTING IF NOT LOCAL ECHO
	MOVL	UCB$L_IRP(R5),R1	; GET THE IRP ADDRESS
	BBS	#IO$V_NOECHO, -
		IRP$W_FUNC(R1),240$	; OR READ NOECHO
	BRW	FORMAT_LOCAL		; OTHERWISE, LOCAL ECHO TERMINAL, FORMAT

	.SBTTL	MOVEREADATA SERVICE ROUTINES
;
; TYPEAHEAD BUFFER EXHAUSTED
;
25$:	IF_NOT_STATE NOECHO,21$		; NO ECHO READ NECESSARY TO OPTOMIZE
	SET_STATE PRE			; SET THE BYPASS TYPEAHED BUFFER STATE
	BRB	21$			; CONTINUE IN THE NORMAL CODE PATH
;
20$:	BRW	XON			; CONTINUE
BUFEMPTY:
	CLRW	TTY$W_TA_INAHD(R4)	; FIX THE COUNT TO REFLECT 0
	IF_STATE <PASALL,NOFLTR>,25$	;
21$:	IF_STATE <TYPFUL>,20$		; BR IF TYPEAHEAD FULL
NOTA:
;
; THE TYPEAHEAD BUFFER HAS NOW BEEN EMPTIED INTO THE SYSTEM BUFFER.
; IF PROCESSING A READ WITH ZERO SECOND TIMEOUT, RETURN THE DATA
; TO THE USER IMMEDIATELY.
;
	BBC	#UCB$V_TT_TIMO,UCB$W_DEVSTS(R5),DISMISS; BR IF NOT READ WITH TIMEOUT.
	CMPL	TTY$A_MAXTIME,UCB$L_TT_RDUE(R5); ZERO SECOND TIMEOUT?
	BNEQ	DISMISS			; BR IF NOT.
	MOVW	#SS$_TIMEOUT,UCB$W_BOFF(R5); SET TIMEOUT COMPLETION STATUS.
	BSBW	TTY$READONE		; COMPLETE REQUEST.


;++
; XON - SEND XON
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS USED TO SEND AN XON 
;
; INPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R3 = XON 
;	R5 = UCB ADDRESS
;--
XON:					; SEND AN XON
	CLR_STATE <TYPFUL>
	IF_NOT_STATE <OVRFLO>,10$	; SKIP IF NO OVERFLOW ERROR

	CLR_STATE <OVRFLO>		; RESET CONDITION
	MOVW	#SS$_DATAOVERUN,UCB$W_BOFF(R5); COMPLETE READ IN ERROR
	BSBW	TTY$READONE

10$:	BSBW	TTY$XON
	BRW	GETNEXTCHAR


;
; CONVERT CHARACTER TO UPPER CASE
;
CVTLOW:	BBC	#TTY$V_CH_LOWER,W^TTY$A_TYPE[R3],154$; BR IF NOT LOWER CHARACTER
	BICW	#^X020,R3		; CONVERT TO UPPER CASE
154$:	BRW	155$

;
; DISMISS INTERRUPT
;
DISMISS:
	CLRB	UCB$B_TT_OUTYPE(R5)	; SET NO RETURN CHARACTER.
	RSB				; and dismiss the interupt

;
; ESCAPE SEQUENCE IN PROGRESS - CHECK SYNTAX
;
ESCINPROG:
	TSTB	R3			; NO NULLS IN ESCAPE SEQUENCES
	BEQL	961$			; SO DROP IT	
	MOVZWL	TTY$W_RB_TXTOFF(R4),R1	; GET THE PLACE TO STORE THE ESCAPE
	MOVB	R3,@TTY$L_RB_TXT(R4)[R1]; AND PLACE THE CHARACTER IN THE RIGHT PLACE
	INCW	TTY$W_RB_TXTOFF(R4)	; AND INCREMENT THE WORLD
	MOVL	UCB$L_IRP(R5),R1	; GET THE IRP ADDRESS
	INCW	IRP$L_MEDIA+2(R1)	; ADJUST SIZE OF ESCAPE SEQUENCE
	BSBW	ESCSYNTAX		; CHECK CHAR AGAINST SYNTAX
	BGTR	960$			; VALID CHAR, CONTINUE INPUT
	BEQL	197$			; VALID CHAR, SEQUENCE COMPLETE
;
; ESCAPE SYNTAX ERROR
;
195$:	SET_STATE BADESC		; SET BAD ESCAPE
197$:	CLR_STATE ESC			; SET SEQUENCE DONE
	SUBW	IRP$L_MEDIA+2(R1),TTY$W_RB_TXTOFF(R4); ADJUST TRANSFER SIZE
	IF_STATE <NOFLTR,BADESC>,199$	; BAD SEQUENCE THEN HANDLE NORMALY OR
					; NOFILTER READ
	CMPB	#^A/~/,R3		; IS THIS A FUNCTION KEY
	BNEQ	910$			; NO THEN HANDLE APROPRIATELY
	CMPW	#21,TTY$W_RB_ESCTKN(R4)	; IS THIS THE EXIT KEY
	BNEQ	920$			; NO THEN TRY NORMAL KEY
	MOVZBL	#TTY$C_CTRLZ,R3		; SETUP A CONTROL-Z 
	CLRL	IRP$L_MEDIA(R1)		; CLEAN THE ESCAPE SEQUENCE UP
	BRW	162$			;AND GO OFF TO DISPATCH

960$:	BRW	198$

199$:
	SET_STATE EOL			; SET UP END OF LINE
961$:	BRW	GETNEXTCHAR		; THEN GET THE NEXT CHARACTER

;
; FUNCTION KEY DETECTED CHANGE FUNCTION KEY TO TOKEN
; BUT ONLY IF WE ARE EDITING
;
920$:	IF_NOT_STATE <EDITING>,199$	; NO EDITING THE GO AND RETURN THE SEQUENDE
	CMPW	TTY$W_RB_ESCTKN(R4),#TTY$K_MAXESCTKN; IS IT OUT OF RANGE
	BGTRU	190$			; YES THEN RETURN IT
	MOVZWL	TTY$W_RB_ESCTKN(R4),R1	; GET THE OFFSET
	MOVZBL	TTY$A_FCNTKN[R1],R1	; AND MAKE THAT INTO A TOKEN
930$:
	TSTB	R1			; IS THIS VALID
	BEQL	190$			; NO THEN RETURN THE SEQUENCE
191$:	MOVL	UCB$L_IRP(R5),R3	; GET THE IRP ADDRESS
	CLRL	IRP$L_MEDIA(R3)		; CLEAR THE ESCAPE SEQUENCE OUT
	CMPB	R1,#TTY$K_ET_UNUSED	; IS THIS AN UNUSED ESCAPE SEQUENCE
	BEQL	970$			; YES THEN IGNORE IT...
	CMPB	R1,#TTY$K_ET_RECALL	; IS THIS A RECALL COMMAND
	BNEQ	192$			; NO THEN CONTINUE NORMALY
	MOVZBL	#TTY$C_CTRLB,R3		; YES THEN MAKE IT A CONTROL-B AND CONTINUE
192$:	BRW	70$

910$:	IF_NOT_STATE <EDITING>,199$	; AND WE ARE NOT EDITING DO THE SAME
	CMPW	IRP$L_MEDIA+2(R1),#3	; IS THE SEQUENCE LONGER THAN 3 CHARACTERS
	BGTR	190$			; YES THEN DO A MATCH ON IT
	MOVZBL	#TTY$K_ET_BACK_CHAR,R1	; SETUP FOR BACK CHARCTER
	CMPB	#^A/D/,R3		; IS IT A BACK CHARACTER
	BEQL	930$			; YES THEN DISPATCH
	MOVZBL	#TTY$K_ET_FORWARD_CHAR,R1; GO FOWARD A CHARACTER
	CMPB	#^A/C/,R3		; IS IT A FORWARD
	BEQL	930$			; HANDLE IT
	MOVZBL	#TTY$K_ET_RECALL,R1	; RECALL A COMMAND
	CMPB	#^A/A/,R3		; IS THIS RECALL?
	BEQL	930$
	BBS	#TRM$V_TM_NORECALL,TTY$L_RB_MOD(R4),190$; CHECK NORECALL
	CMPB	#^A/B/,R3		; IS THIS A DOWN ARROW?
	BEQL	930$			; YES THEN DROP IT
;
; DON'T TERMINATE ON THIS SEQUENCE UNLESS HE REALY WANTS IT
; (THE MODE OF THE READ IS ESCAPE
;
190$:	IF_STATE ESCAPE,199$		; IF THIS IS AN ESCAPE SEQUENCE READ THEN
970$:					; TERMINATE ON ESCAPE SEQUENCES.
	MOVL	UCB$L_IRP(R5),R1	; MAKE SURE WE HAVE THE IRP ADDRESS
	CLRL	IRP$L_MEDIA(R1)		; NO THEN CLEAN THE SEQUENCE OFF THE TERMINATOR LIST
	BRW	GETNEXTCHAR		; AND GET THE NEXT CHARACTER
;
; NORMAL ESCAPE SEQUENCE TERMINATION
;

198$:	CMPB	#^A/0/,R3		; IS THIS A NUMBER
	BGTR	900$			; NO THEN EXIT
	CMPB	#^A/9/,R3		; ...
	BLSS	900$			; 
	MULW	#10,TTY$W_RB_ESCTKN(R4)	; SHIFT THE NUMBER OVER
	SUBW	#^A/0/,R3		; SUBTRACT OUT 0
	ADDW	R3,TTY$W_RB_ESCTKN(R4)	;ADD IT IN
900$:	BRW	210$

;
; SEE IF DELETE SEQUENCE SHOULD BE TERMINATED
;
INDELST:CMPB	R3,#TTY$C_DELETE	; IS THIS CHARACTER A DELETE?
	BEQL	50$			; IF YES THEN GO ON
	INCW	TTY$W_TA_INAHD(R4)	; NO THEN PUT THE CHARACTER BACK
	CLR_STATE DEL			; TERMINATE DELETE SEQUENCE
;
; TERMINATE DELETE SEQUENCE IF NOT IN NO-ECHO
;
	MOVZBL	#^A/\/,R3		; SET OUTPUT CHARACTER
	BRW	FORMAT_CHAR		; FORMAT THE CHARACTER

50$:	BRW	40$


;
; OPEN THE BUFFER
; OR JUST OVERSTRIKE
;
OPEN:
;
; SPREAD THE BUFFER TO PUT THIS CHARCTER IN PLACE
;
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	; SAVE THE REGISTERS OVER THE MOVE
	CLRL	R1			; SET FORWARD MODE
	BSBW	CHAR_SIZE		; GET THE CHARACTER SIZE
;
; IF NOT AT THE END OF LINE THEN DON'T LET THE USER WRAP THE LINE
;
	IF_STATE <WRAP,TABRIGHT>,194$		; ...
169$:	ADDW3	R3,UCB$W_TT_CURSOR(R5),TTY$W_RB_CPZCUR(R4); AND ADD IT INTO THE CURRENT CURSOR
	MOVZWL	TTY$W_RB_LINOFF(R4),R1	; GET THE LOCATION OF THE LAST CHARACTER
	MOVAB	@TTY$L_RB_LIN(R4)[R1],TTY$L_RB_ECHSTR(R4); GET THE ADDRESS
	MOVW	#TTY$K_ER_CLRECHO,TTY$W_RB_MODE(R4); AND SETUP THE ECHO MODE
	IF_STATE NOECHO,193$		; DON'T ECHO IF NOT ECHOING...
	SET_STATE EDITREAD		; AND SET THE EDIT READ STATE
193$:	IF_NOT_STATE OVERSTRIKE,158$	; NOT IN OVERSTRIKE THEN HANDLE NORMALY
	CMPB	12(SP),#TTY$C_TAB	; WAS THIS CHARACTER A TAB?
	BEQL	158$			; YES THEN INSERT IT.

	DECW	TTY$W_RB_LINREST(R4)	; IN OVERSTRIKE WE DELETE WHILE TYPING
	DECW	TTY$W_RB_TXTOFF(R4)	; FAKE OUT THE REST OF THE LOGIC

	CMPL	R3,#1			; IS THIS A SHORT ECHOING CHARACTER
	BNEQ	168$			; NO THEN OUTPUT THE WHOLE THING
	CMPB	@TTY$L_RB_ECHSTR(R4),#TTY$C_TAB; ARE WE ON TOP OF A TAB?
	BEQL	157$			; YES THEN HANDLE SPECAILLY
	CLRW	TTY$W_RB_MODE(R4)	; CLEAN OUT THE MODE FOR LATER
	CLRL	TTY$L_RB_ECHSTR(R4)	; MAKE SURE THE STRING IS ZERO
	CLR_STATE EDITREAD		; AND DON'T DO THE EDITREAD ECHO (ONLY
					; ONE CHARACTER NO NEED)
	BRB	168$			; AND DON'T BOTHER WITH THE MOVC
157$:	EXTZV	#0,#3,TTY$W_RB_CPZCUR(R4),R3; GET THE LENGTH OF THE TAB
	TSTL	R3			; DELETE THE TAB WHEN IT EXPANDS TO ZERO
	BEQL	171$			; MAKE IT DISAPPEAR
	INCW	TTY$W_RB_LINREST(R4)	; ELSE JUST INSERT THE CHARACTER
	INCW	TTY$W_RB_TXTOFF(R4)
158$:	INCL	R1			; INCREMENT THE REGISTER BY 1 TO GET THE
					; NEW POSITION
	MOVC3	TTY$W_RB_LINREST(R4),-	; AND MOVE THE CHARACTERS OVER
		@TTY$L_RB_ECHSTR(R4),@TTY$L_RB_LIN(R4)[R1]
168$:	POPR	#^M<R0,R1,R2,R3,R4,R5>	; RESTORE THE REGISTERS
	ADDB3	TTY$W_RB_LINREST(R4),#1,TTY$B_RB_ECHLEN(R4);AND LENGTH OF STRING TO OUTPUT
	BRW	159$			; AND INSERT THE CHARACTER
171$:	INCW	TTY$W_RB_LINOFF(R4)	; LOOK FROM THIS CHARACTER ON
	BSBW	TABRIGHT		; MAKE SURE THE TAB AFTER THIS POSITION
					; FLAG IS SET CORRECTLY.
	DECW	TTY$W_RB_LINOFF(R4)	; KEEP LINOFF THE SAME AS WE STARTED WITH
	BRB	168$			; JOIN THE FLOW
;
; ONCE WRAP IS DETERMINED THEN CHECK SPECIFICALLY IF THIS CHARACTER IS VALID
;
194$:	IF_NOT_STATE OVERSTRIKE,234$	; DON'T EVER INSERT AFTER THE WRAP
	CMPW	R3,#1			; IS THIS A SINGLE CHARACTER EXPANSION
	BNEQ	234$			; NO THEN DON'T INSERT IT
	CMPB	12(SP),#TTY$C_TAB	; WAS THIS CHARACTER A TAB?
	BNEQ	235$			; NO THEN OVERSTRIKE IT
234$:	POPR	#^M<R0,R1,R2,R3,R4,R5>	; RESTORE THE REGISTERS
	BRW	GETNEXTCHAR		; AND GET THE NEXT CHARACTER
235$:	BRW	169$

;
; QUOTING  CHARACTER DETECTED	
;
QUOTE:	BBSC	#TTY$V_ST_EDITING,4(R2),65$; IF EDITING IS SET THEN CLEAR IT
	IF_STATE	ESC,65$		; IF ESCAPE THEN DON'T TURN OFF EDITING YET
	SET_STATE EDITING		; IF IT NOT EDITING THEN SET EDITING
	CLR_STATE QUOTING		; AND CLEAR QUOTING
65$:	BRW	67$			; RETURN TO THE NORMAL PLACE

	.SBTTL	Specail input character dispatcher
;++
;
; SERVICE ROUTINES TO MOVE READATA
;
; SPECAIL EDITING CHARACTER HANDELING
;
EDITINGCHAR:
	IF_STATE <EDITING>,70$		; EDITING THEN NO RANGE CHECK NECESSARY
	CMPL	R1,#TTY$K_EDITNORMAL	; NOT EDITING THEN ANYTHING ADVANCED
	BGTR	162$			; IS BAD
70$:	CASE	R1,TYPE=L,<-
		151$,-			; IS NORMAL CHARACTER (SHOULD NEVER BE USED)
		CTRLU,-			; IS CONTROL-U
		CTRLR,-			; INDICATES CONTROL-R
		DELCHAR,-		; INDICATES DELETE CHARCTER
		ESCAPE_CHAR,-		; INDICATES ESCAPE CHARCTER
		BACK_CHAR,-		; MOVE BACK ONE CHARACTER
		FORWARD_CHAR,-		; MOVE FOWARD ONE CHARACTER
		MOVE_EOL,-		; MOVE TO THE END OF LINE
		MOVE_BOL,-		; MOVE TO THE BEGINNING OF LINE
		DELETE_WORD,-		; DELETE WORD TO THE LEFT
		QUOTING,-		; QUOTE CHARACTER
		RECALL,-		; RECALL THE LAST COMMAND
		TOGGELINSOV-		; TOGGEL INSERT/OVERSTRIKE MODE
		>
	IF_STATE TERMNORM,162$		; TERMINATE ON USUAL
					; CHARACTERS
	CMPL	R1,#TTY$K_ET_TERMINATE	; WAS THIS A REAL TERMINATOR CHARACTER
	BNEQ	165$			; NO THEN DON'T LET IT THRU
162$:	IF_STATE	<ESC>,166$	; IF IN AN ESCAPE SEQUENCE THEN LET IT THRU
	BBS	R3,@TTY$L_RB_TERM(R4),164$; IS THIS CHARACTER A TERMINATOR
	CMPB	R3,#TTY$C_CR		; WE ARE PREPARED TO HANDLE <CR>
	BEQL	800$			; SO LET IT THRU ANYWAY
	IF_STATE <QUOTING,EDITING>,165$	; NO THEN DROP IT IF WE ARE EDITING
167$:	BRW	151$
164$:	BRW	TERMFOUND		; TERMINATOR DETECTED
166$:	BRW	ESCINPROG		; ESCAPE SEQUENCE INPROGRESS
165$:	BRW	GETNEXTCHAR		; GET THE NEXT CHAR
800$:	TSTW	TTY$W_RB_LINREST(R4)	; ARE WE AT THE END OF THE LINE
	BEQL	167$			; YES THEN CR IS LEGAL
	BRW	GETNEXTCHAR

	.disable lsb


;++
; RECALLING
;
; DESCRIPTION:
;	THIS STATE IS USED WHEN THE LAST COMMAND TYPED IS REQUESTED.
; THIS ROUTINE WILL REMOVE CHARACTERS FROM THE RECALL BUFFER THEN
; ALLOW THE NORMAL INSERT CHARACTER LOGIC TAKE AFFECT.  THE CHARACTERS
; IN THE RECALL BUFFER ARE PROCESSED AS IF THEY WERE NO FORMAT.
;
; INPUTS:
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;	SEE MOVEREADATA
;--
RECALLING:
	MOVL	UCB$L_TT_TYPAHD(R5),R1	; GET THE ADDRESS OF THE TYPEAHEAD BUFFER
	BEQL	20$			; NONE THEN LET MOVEREADATA HANDLE IT
	MOVL	UCB$L_SVAPTE(R5),R4	; SETUP THE READ PACKET ADDRESS
	MOVZWL	TTY$W_TA_RCLOFF(R1),R3	; GET THE ADDRESS OF THE NEXT CARACTER
	MOVZBL	TTY$A_TA_RCL(R1)[R3],R3	; GET THE CHARACTER
	INCW	TTY$W_TA_RCLOFF(R1)	; MOVE ON TO THE NEXT CHARACTER
	CMPW	TTY$W_TA_RCLOFF(R1),TTY$W_TA_RCLSIZ(R1); ARE WE FINISHED
	BGEQ	5$			; YES THEN TURN OFF RECALL AND CONTINUE
	CMPW	TTY$W_TA_RCLOFF(R1),TTY$W_RB_TXTSIZ(R4); ARE WE GOING TO OVERFLOW
	BLSS	10$			; THE USERS BUFFER
5$:	CLR_STATE RECALL		; YES THEN MAKE THIS THE LAST TIME
10$:	BRW	INSERT_CHAR		; AND INSERT THE CHARACTER
20$:	BRW	MOVEREADATA		; ABORT EXIT

	.SBTTL	Post typeahead character action routines

;++
; BACK_CHAR
;	Move backward a single character.
;--
BACK_CHAR:
	TSTW	TTY$W_RB_CPZORG(R4)	; START AT ZERO?
	BEQL	10$			; YES THEN NO SPECAIL ACTION
	BSBW	ZERO_CPZORG		; NO THEN MAKE SURE WE DO
10$:	DECW	TTY$W_RB_LINOFF(R4)	; BACKUP A CHARACTER
	BLSS	50$			; AT THE END THEN DON'T ALLOW IT
	INCW	TTY$W_RB_LINREST(R4)	; UPDATE THE REST POINTER
	MOVZWL	TTY$W_RB_LINOFF(R4),R1	; GET THE OFFSET TO THE CHARACTER
	MOVZBL	@TTY$L_RB_LIN(R4)[R1],R3; GET THE CHARCTER
	CMPB	#TTY$C_TAB,R3		; IS THIS A TAB
	BNEQ	20$			; NO THEN CONTINUE
	SET_STATE TABRIGHT		; ELSE MARK THIS INFORMATION
20$:	MNEGL	#1,R1			; GOING BACKWARDS TO
	BSBW	CHAR_SIZE		; CHECK THE SIZE OF THE CHARACTER
	SUBW3	R3,UCB$W_TT_CURSOR(R5),TTY$W_RB_CPZCUR(R4); UPDATE THE CURSOR POSITION
	IF_STATE NOECHO,60$
	BRW	UPDATE_CURSOR		; SET THE CURSOR TO IT'S NEW LOCATION

50$:	CLRW	TTY$W_RB_LINOFF(R4)	; RESET THE POINTER
60$:	BRW	DROP			; AND DROP THE CHARACTER

	.enable lsb
;
; CONTROL R PROCESSING
;
CTRLR:	IF_STATE <ESC>,150$		; NO ACTION IF ESCAPE OR NO ECHO
	IF_NOT_STATE NOECHO,100$	; BRANCH IF ECHO
	BBC	#TT2$V_LOCALECHO,-
		UCB$L_DEVDEPND2(R5),150$; BRANCH IF NOT LOCAL ECHO

100$:	MOVAB	W^TTY$A_CTRLR,R4	; ADDRESS MULTIECHO STRING
110$:	BBC	#TT2$V_EDITING,-
		UCB$L_DEVDEPND2(R5),130$	; NO THEN USE NORMAL ECHO STRING
	BBC	#TT$V_SCOPE,UCB$L_DEVDEPEND(R5),130$; DON'T SKIP STUFF
					; ON A HARD COPY TERMINAL
	MOVL	UCB$L_SVAPTE(R5),R1	; GET THE PACKET ADDRESS
	TSTW	TTY$W_RB_CPZORG(R1)	; WERE WE AT THE FIRST COLUMN WHEN
	BNEQ	120$			; WE STARTED THE READ
	SET_STATE <SKIPCRLF>		; NO LINEFEEDS AFTER <CR>
120$:	BBC	#TT2$V_ANSICRT,-	; IS IT AN ANSI CRT
		UCB$L_DEVDEPND2(R5),130$; NO THEN USE NORMAL ECHO STRING
	MOVAB	W^TTY$A_ANSI_DEOL,R4	; YES THEN WE CAN USE CRT MODE
130$:
	SET_STATE	<EDITREAD>	; SET CONTROL R STATE
	BRW	STRTMULTI		; START MULTIPLE OUTPUT SEQUENCE

150$:	BRW	MOVEREADATA

;
; CONTROL U PROCESSING
;
10$:	BSBW	DELESCAPE		; DELETE THE ESCAPE SEQUENCE
CTRLU:	IF_STATE ESC,10$		; IF IN ESCAPE SEQUENCE THEN DELETE ESCAPE
	TSTW	TTY$W_RB_LINOFF(R4)	; ANY DATA TO CONTROL-U?
	BEQL	50$			; NO THEN DON'T DO THE WORK
	SUBW	TTY$W_RB_LINOFF(R4),TTY$W_RB_TXTOFF(R4)	; CLEAN OUT THE TEXT OFFSETON THIS LINE
	CLRB	TTY$B_RB_ECHLEN(R4)	; CLEAN THE EXTRA
	CLRW	TTY$W_RB_CPZCUR(R4)	; MOVE TO THE BEGINNING OF THE LINE
	TSTW	TTY$W_RB_CPZORG(R4)	; WAS THIS AT THE RIGHT
	BNEQ	12$			; NO THEN USE THE OLD METHOD
	MOVZBW	#TTY$K_ER_CLRREST,TTY$W_RB_MODE(R4); EXIT WHEN NOT DOING ANYTHING ELSE
12$:	TSTW	TTY$W_RB_LINREST(R4)	; IS THERE A REST OF THE LINE
	BEQL	13$			; NO THEN HANDLE NORMALLY
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	; SAVE THE REGISTERS
	MOVZWL	TTY$W_RB_LINOFF(R4),R1	; GET THE NUMBER OF CHARACTERS
	MOVC3	TTY$W_RB_LINREST(R4),@TTY$L_RB_LIN(R4)[R1],@TTY$L_RB_LIN(R4);
	POPR	#^M<R0,R1,R2,R3,R4,R5>	; AND RESTORE THE REGISTERS
	TSTW	TTY$W_RB_CPZORG(R4)	; WAS THIS AT THE RIGHT
	BNEQ	14$			; NO THEN USE THE OLD METHOD
	MOVZBW	#TTY$K_ER_CLRECHO,TTY$W_RB_MODE(R4); SETUP THE NEW ECHO MODE
	MOVL	TTY$L_RB_LIN(R4),TTY$L_RB_ECHSTR(R4); THE LOCATION OF THE FIRST CHARACTER TO ECHO
	MOVB	TTY$W_RB_LINREST(R4),TTY$B_RB_ECHLEN(R4); AND THE LENGTH
	CLRW	TTY$W_RB_CPZCUR(R4)	; AND GO ALL THE WAY TO THE BEGINNING
13$:	CMPL	TTY$L_RB_LIN(R4),TTY$L_RB_TXT(R4); ARE WE ON THE FIRST LINE
	BNEQU	14$			;NO THEN CONTINUE AS USUAL
	MOVZBW	#TTY$K_ER_PRMECHO,TTY$W_RB_MODE(R4); ECHO THE PROMPT TOO
14$:	CLRW	TTY$W_RB_LINOFF(R4)	; NOW ZERO THE LINE OFFFSET

	IF_STATE NOECHO,15$		; BRANCH IF ECHO
	MOVAB	W^TTY$A_CTRLU,R4	; ADDRESS MULTIECHO STRING
	BRW	110$			; CONTINUE

15$:	BRW	MOVEREADATA		;
55$:	CLR_STATE <WRAP,CURSOR>
	BRW	CTRLU
57$:	BRW	CTRLR
;
; NO DATA TO CONTROL-U
;
50$:	TSTW	TTY$W_RB_LINREST(R4)	; ANY DATA AFTER THIS POINT
	BNEQ	15$			; YES THEN JUST RETURN
	TSTW	TTY$W_RB_TXTOFF(R4)	; IS THERE ANY REASON TO DO THIS
	BEQL	15$			; NO THEN DON'T BOTHER
	DECW	TTY$W_RB_TXTOFF(R4)	; REMOVE THE LAST CHARACTER
	BSBW	FIND_BOL		; THEN FIND THE BEGINNING
					; OF THE PREVIOUS LINE
	TSTW	TTY$W_RB_TXTOFF(R4)	; IS THERE ANY MORE DATA LEFT
	BEQL	57$			; NO THEN JUST MAKE SURE THE PROMPT
					; ECHO'S
	BBC	#TT2$V_ANSICRT,UCB$L_DEVDEPND2(R5),55$; REECHO ON NON ANSI TERMINALS
	TSTW	TTY$W_RB_CPZORG(R4)	; WAS THIS AT THE RIGHT
	BNEQ	55$			; NO THEN USE THE OLD METHOD
	SUBW	TTY$W_RB_LINOFF(R4),TTY$W_RB_TXTOFF(R4); DELETE THE LINE
	CLRW	TTY$W_RB_LINOFF(R4)	; ...
	CMPL	TTY$L_RB_LIN(R4),TTY$L_RB_TXT(R4); DOES A PROMPT NEED TO BE ECHOED
	BNEQ	60$			; NO THEN DON'T ECHO A PROMPT
	MOVZBW	#TTY$K_ER_PRMECHO,TTY$W_RB_MODE(R4); SET UP TO ECHO THE PROMPT
	CLRB	TTY$B_RB_ECHLEN(R4)	; NO STRING TO OUTPUT
	SET_STATE EDITREAD		; TELL THE REST OF THE SYSTEM ABOUT THE PROMPT

60$:	CLRW	TTY$W_RB_CPZCUR(R4)	; CLEAR THE CURSOR POSITION
	SET_STATE SKIPCRLF		; SKIP THE FREE LINEFEED
	MOVAB	TTY$A_ANSI_UPCEL,R4	; GET THE STRING ADDRESS
	BRW	STRTMULTI		; AND DELETE THIS LINE
	.disable lsb


;++
; DELCHAR - DELETE CHARACTER ROUTINE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE DELETES THE LAST TYPED CHARACTER FROM THE READ BUFFER.
; THEN IT SETS UP THE PROPER ECHO SEQUENCE FOR THE DELETED CHARACTER.
;
; INPUTS:
;
;	R2 = ADDRESS OF TTY STATE VECTOR
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R2 = ADDRESS OF TTY STATE VECTOR
;	R5 = UCB ADDRESS
;--
DELCHAR:				;
	MOVL	UCB$L_SVAPTE(R5),R4	; ADDRESS READ BUFFER BLOCK
;
; IF ESCAPE SEQUENCE IN PROGRESS THEN DELETE ENTIRE STRING
;
	IF_STATE ESC,25$		; DELETE ESCAPE SEQUENCE
	DECW	TTY$W_RB_LINOFF(R4)	; ANY DATA
	BLSS	28$			; IF EQL THEN NO
	MOVZWL	TTY$W_RB_LINOFF(R4),R1	; GET THE POINTER
	MOVZBL	@TTY$L_RB_LIN(R4)[R1],R3; GET THE CHARACTER
	CMPB	#TTY$C_CR,R3		; IS THIS CHARACTER A RETURN
	BEQL	28$			; YES THEN ADJUST THE LINE
	DECW	TTY$W_RB_TXTOFF(R4)	; ADJUST POINTER
	IF_NOT_STATE NOECHO,5$		; BRANCH IF ECHO
	BBC	#TT2$V_LOCALECHO,-
		UCB$L_DEVDEPND2(R5),30$	; BRANCH IF NOT LOCAL ECHO

;
; TEST FOR SPECIAL DELETES
;
5$:	CMPB	R3,#TTY$C_TAB		; TAB?
	BEQL	8$			; IF NEQ THEN OUTPUT JUST THE CHARACTER
	BRW	55$
8$:	BBS	#TT$V_SCOPE,UCB$L_DEVDEPEND(R5),40$; BR IF SCOPE
	BRW	75$			; BR IF NOT SCOPE

25$:	BSBW	DELESCAPE		; DELETE ESCAPE SEQUENCE
	BRW	MOVEREADATA		; AND GO BACK TO WORK

28$:	CLRW	TTY$W_RB_LINOFF(R4)	; MAKE THE COUNT ZERO
	TSTW	TTY$W_RB_LINREST(R4)	; is there nothing left?
	BNEQ	30$			; NO THEN JUST RETURN
	TSTW	TTY$W_RB_TXTOFF(R4)	; NO LINE WAS WRAPPED
	BEQL	30$			; IF THIS COUNT IS ZERO
	DECW	TTY$W_RB_TXTOFF(R4)	; REMOVE THE LAST CHARACTER
	BSBW	FIND_BOL		; YES THEN CALCULATE THE NEW BEGINNING
					; OF LINE
	BBC	#TT2$V_ANSICRT,UCB$L_DEVDEPND2(R5),120$; REECHO ON NON ANSI TERMINALS
	TSTW	TTY$W_RB_CPZORG(R4)	; WAS THIS AT THE RIGHT
	BNEQ	120$			; NO THEN USE THE OLD METHOD
	MOVZBW	#TTY$K_ER_CLRECHO,TTY$W_RB_MODE(R4); ECHO THE DATA
	MOVB	TTY$W_RB_LINOFF(R4),TTY$B_RB_ECHLEN(R4); AND THE STRING TO OUTPUT
	MOVL	TTY$L_RB_LIN(R4),TTY$L_RB_ECHSTR(R4); AND THE ADDRESS
	CMPL	TTY$L_RB_LIN(R4),TTY$L_RB_TXT(R4); DOES A PROMPT NEED TO BE ECHOED
	BNEQ	110$			; NO THEN DON'T ECHO A PROMPT
	MOVZBW	#TTY$K_ER_PRMECHO,TTY$W_RB_MODE(R4); SET UP TO ECHO THE PROMPT

110$:	SET_STATE <SKIPCRLF,EDITREAD>	; SKIP THE FREE LINEFEED
	MNEGW	#2,TTY$W_RB_CPZCUR(R4)	; DON'T RESET CURSOR
	MOVAB	TTY$A_ANSI_UPCEL,R4	; GET THE STRING ADDRESS
	BRW	STRTMULTI		; AND DELETE THIS LINE

120$:	SET_STATE <EDITREAD>		; RESTORE THE LINE TO IT'S FULL VIGOR
	MOVAB	TTY$A_CTRLR,R4		; GET A NEW LINE
	BRW	STRTMULTI		; and return to the main loop

30$:	BRW	MOVEREADATA		; VECTOR TO CONTINUE

;
; DELETE A TAB ON A SCOPE
;
40$:	TSTW	UCB$W_TT_CURSOR(R5)	; Have we wrapped?
	BEQL	60$			; Branch to simulate CTRL-R, if yes.
	BSBW	BACK_TAB		; GET THE TAB LENGTH
	CMPW	UCB$W_TT_CURSOR(R5), UCB$W_DEVBUFSIZ(R5) ; At extreme right?
	BLSSU	45$			; Branch if within screen bounds.
	BGTRU	47$			; Branch if beyond right edge.
	INCL	R3			; Adjust number of backspaces for
	BICL	#^C7, R3		; right-hand edge effects.
	BEQL	66$			; If no backspace, just delete at edge.
	DECW	UCB$W_TT_CURSOR(R5)	; Adjust cursor value for one less BS.
45$:	SUBW3	R3,#7,UCB$W_TT_MULTILEN(R5); GET THE LENGTH CORRECTLY
	MOVAB	W^TTY$A_DELCRTTAB+1,R4; Get address backspaces string.
	BRB	70$			; Go output them.

47$:	SUBW	#7, R3			; Adjust off-the-screen cursor
	ADDW	R3, UCB$W_TT_CURSOR(R5)	; position for deleted tab.
	BRB	66$			; Go do delete-at-edge.

;
; NORMAL CHARACTER DELETE
;
55$:	
	BITB	#<TTY$M_CH_CTRL!TTY$M_CH_SPEC!TTY$M_CH_CTRL2!TTY$M_CH_CTRL3>,-
	W^TTY$A_TYPE[R3]		; TEST FOR SPECIAL
	BNEQ	62$			; NON PRINTING CHARACTER

	BBC	#TT$V_SCOPE,UCB$L_DEVDEPEND(R5),75$; BR IF NOT SCOPE
;
; IF THE CURSOR IS AT THE LEFT MARGIN AND DATA IS PRESENT,
; FORCE A CONTROL R IN STEAD OF A BACKSPACE.
;
59$:	TSTW	UCB$W_TT_CURSOR(R5)	; CURSOR AT LEFT MARGIN?
	BNEQ	66$			; BR IF NORMAL BACKSPACE NEEDED
;
; FORCE CONTROL R FOR RUBOUT RESPONSE
;
60$:	
	MOVL	UCB$L_SVAPTE(R5),R4	; GET READ PACKET ADDRESS
	TSTW	TTY$W_RB_TXTOFF(R4)	; DATA PRESENT?
	BNEQ	63$			; IF DATA PRESENT, ECHO IT IN NORMAL FASSION
62$:	BRW	MOVEREADATA		; IF NO DATA THEN NO RESPONSE
63$:	BRW	120$			; DATA TO ECHO THEN ECHO
65$:	BRW	EDITREAD		; START THE OUTPUT
;
; NORMAL BACKSPACE RUBOUT RESPONSE
;
66$:	MOVZBL	#TTY$C_BLANK,R3		; ASSUME SPACE IS FIRST CHARACTER
	CMPW	UCB$W_TT_CURSOR(R5),UCB$W_DEVBUFSIZ(R5); AND EXTREME RIGHT?
	BGEQU	100$			; IF YES THEN ONLY OUTPUT SPACE
;
; DELETE IS IN MID SCREEN
;
	MOVAB	W^TTY$A_SPACEBACK,R4	; ADDRESS BACKSPACE STRING
	MOVZBW	(R4)+,UCB$W_TT_MULTILEN(R5);AND THEN IT'S LENGTH
70$:	MOVZBL	#TTY$C_BS,R3		; START STRING WITH BACKSPACE
	BRB	90$			; START OUTPUT
75$:	BBSS	#TTY$V_ST_DEL,4(R2),95$	; IF NOT FIRST TIME THEN OUTPUT CHARACTER
	MOVAB	UCB$W_BUFQUO(R5),R4	; ADDRESS STRING SPACE
	MOVW	#1,UCB$W_TT_MULTILEN(R5)	; SETUP THE LENGTH OF THE MULTIECHO STRING
	MOVZBW	R3,(R4)			; AND PUT THE CHARACTERS THERE
;
; OUTPUT "\" TO START OR END DELETE SEQUENCE
;
80$:	MOVZBL	#^A@\@,R3		; FOR FIRST TIME OUTPUT "\"
90$:	MOVL	R4,UCB$L_TT_MULTI(R5)	; ADDRESS STRING
	SET_STATE MULTI			;
	MOVL	UCB$L_SVAPTE(R5),R4	; RESTORE THE READ PACKET ADDRESS
	TSTW	TTY$W_RB_LINREST(R4)	; ANY CHARACTERS TO THE RIGHT
	BEQL	95$			; NO THEN HANDLE NORMALY

	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	; SAVE NECESSARY STATE
	IF_STATE NOECHO,92$
	SET_STATE <EDITREAD>		; SET THE EDIT ECHOING STATE
92$:	MOVZWL	TTY$W_RB_LINOFF(R4),R1	; GET THE OFFSET TO THIS CHARACTER
	MOVAB	@TTY$L_RB_LIN(R4)[R1],TTY$L_RB_ECHSTR(R4); SETUP THE ADDRESS TO START AT
	MOVZBL	@TTY$L_RB_ECHSTR(R4),R3	; GET THE CHARACTER BACK
	MOVZBW	#TTY$K_ER_CLRECHO,TTY$W_RB_MODE(R4); CLEAR TO THE END OF LINE THEN ECHO THE STRING
	MOVB	TTY$W_RB_LINREST(R4),TTY$B_RB_ECHLEN(R4); AND THE LENGTH
	MNEGL	#1,R1			; setup to find backward size
	BSBW	CHAR_SIZE		; FIND THE SIZE OF THIS CHARACTER
	SUBW3	R3,UCB$W_TT_CURSOR(R5),TTY$W_RB_CPZCUR(R4)	; SUBTRACT OUT THE LENGTH OF THIS CHARACTER
	MOVZBL	#1,R2			; SETUP R2 AS 1 CHARACTER
	MOVC3	TTY$W_RB_LINREST(R4),-
		@TTY$L_RB_ECHSTR(R4)[R2],@TTY$L_RB_ECHSTR(R4); COMPRESS THE STRING
	POPR	#^M<R0,R1,R2,R3,R4,R5>	; SAVE NECESSARY STATE

95$:	BRW	FORMAT_CHAR		; START UP OUTPUT
100$:
	DECW	UCB$W_TT_CURSOR(R5)	; ADJUST CURSOR
	BRW	OUTPUTANDWAIT		; VECTOR FOR SPACE ONLY RESPONSE


;++
; DELETE AN ESCAPE SEQUENCE IN PROGRESS
;
; THIS ROUTINE IS USED BY THE CONTROL U AND DELETE LOGIC TO RESET
; AND DELETE THE ESCAPE SEQUENCE IN PROGRESS
;
DELESCAPE:				; DELETE CURRENT ESCAPE SEQUENCE
	MOVL	UCB$L_IRP(R5),R1	; GET ADDRESS OF PACKET.
	SUBW	IRP$L_MEDIA+2(R1),TTY$W_RB_TXTOFF(R4); ADJUST TRANSFER SIZE FOR SEQUENCE
	CLRL	IRP$L_MEDIA(R1)		; ESCAPE LENGTH
	CLR_STATE <ESC,BADESC>		; CLEAR ESCAPE
10$:	RSB				; RETURN

;++
; DELETE_WORD
;
; DESCRIPTION:
;	DELETE WORD TO THE LEFT OF THE CURSOR
;--
GODEL:	BRW	DELCHAR			; ACT AS IF A DELETE WAS TYPED
DROP_CHAR:BRW	DROP			; DROP THE CHARACTER
DELETE_WORD:
	MOVZWL	TTY$W_RB_LINOFF(R4),R3	; GET THE OFFSET
	DECL	R3			; SUBTRACT 1
	BLSS	DROP_CHAR		; no characters then handle suchly
	MOVZBL	@TTY$L_RB_LIN(R4)[R3],R3; GET THE CHARACTER AT THIS POINT
	BBS	R3,TTY$A_PREFIX,GODEL; IF THIS CHARACTER
					; IS A PREFIX THEN DELETE ONLY IT
	PUSHR	#^M<R0,R1,R2,R4,R5>
	MOVZWL	TTY$W_RB_LINOFF(R4),R0	; GET THE CURRENT POSITION
	PUSHL	R0			; SAVE THE OFFSET
	MNEGL	#1,R1			; WE ARE MOVING BACKWARDS
	CLRL	R2			; CLEAN OUT THE CHARACTER POSITION COUNTER
10$:	DECL	R0			; MOVE ONE CHARACTER TO THE LEFT
	BLSS	30$			; WHEN DONE SAY SO
	MOVZBL	@TTY$L_RB_LIN(R4)[R0],R3; GET A CHARACTER
	BBC	R3,TTY$A_WORDTERM,20$	; SKIP OVER TERMINATORS
	MOVW	R0,TTY$W_RB_LINOFF(R4)	; UPDATE LINOFF TO MAKE TAB DELETION WORK
	BSBW	CHAR_SIZE		; GET THE LENGTH OF THIS CHARACTER
	ADDL	R3,R2			; UPDATE CURSOR POSITION
	BRB	10$			; AND CONTINUE

20$:	MOVW	R0,TTY$W_RB_LINOFF(R4)	; UPDATE LINOFF TO MAKE TAB DELETION WORK
	BSBW	CHAR_SIZE		; GET THE LENGTH OF THIS CHARACTER
	ADDL	R3,R2			; UPDATE THE POSITION
	DECL	R0			; KEEP MOVING
	BLSS	30$			; UNTILL THE END
	MOVZBL	@TTY$L_RB_LIN(R4)[R0],R3; GET ANOTHER CHARCTER
	BBC	R3,TTY$A_WORDTERM,20$	; KEEP MOVING UNTILL NOT A TERMINATOR

30$:	INCL	R0			; GO FOWARD A CHARACTER
	MOVW	R2,UCB$W_TT_BSPLEN(R5)	; ECHO THE RIGHT NUMBER OF BACKSPACES
	SUBW3	R2,UCB$W_TT_CURSOR(R5),TTY$W_RB_CPZCUR(R4); SETUP THE CURSOR POSITION
	POPL	R1			; GET THE CURRENT POSITION
	SUBW3	R0,R1,R2		; GET THE NUMBER OF CHARACTERS DELETED
	SUBW	R2,TTY$W_RB_TXTOFF(R4)	; AND REMOVE THESE CHARACTERS FROM THE COUNT
	MOVAB	@TTY$L_RB_LIN(R4)[R0],TTY$L_RB_ECHSTR(R4); GET THE ADDRESS FOR UPDATING
	MOVC3	TTY$W_RB_LINREST(R4),-	; DELETE THE WORD
		@TTY$L_RB_LIN(R4)[R1],@TTY$L_RB_ECHSTR(R4);
	POPR	#^M<R0,R1,R2,R4,R5>	; RESTORE THE STATE
	IF_STATE NOECHO,40$
	SET_STATE <BACKSPACE,EDITREAD>	; BACKSPACE OVER THE WORD THEN ECHO EVERYTHING
	MOVZBW	#TTY$K_ER_CLRECHO,TTY$W_RB_MODE(R4); SETUP THE MODE FOR EDITECHOING
	MOVB	TTY$W_RB_LINREST(R4),TTY$B_RB_ECHLEN(R4); AND THE LENGTH TO ECHO
40$:	BRW	GETNEXTCHAR		; GET THE NEXT CHARACTER


;++
; Escape_Char
;
; 	Possible escape character found, could be an altmode for
; lower case terminals or could be a CSI for new eight bit terminals.
; All cases must be handled apropriately.
;--
ESCAPE_CHAR:
	CMPB	#TTY$C_LOWESC1,R3	; ALT MODE?
	BEQL	47$			; YES
	CMPB	#TTY$C_LOWESC2,R3	; ALT MODE?
	BNEQ	52$			; YES
47$:	BBS	#TT$V_LOWER,UCB$L_DEVDEPEND(R5),51$; LOWER CASE TERMINAL CONTINUE
	MOVZBL	#TTY$C_ESCAPE,R3	; CHANGE CHARACTER TO ESCAPE
52$:
;
; PROCESS ESCAPE SEQUENCES AND ESCAPES
;
	IF_NOT_STATE <ESCAPE,EDITING>,55$; NOT AN ESCAPE TERMINAL THEN EXIT
	BSBW	ESCINIT			; HANDLE THE ESCAPE PREFIXES
	MOVB	R1,UCB$B_TT_ESC(R5)
	CLRW	TTY$W_RB_ESCTKN(R4)
	MOVL	UCB$L_IRP(R5),R1	; GET THE IRP ADDRESS
	MOVW	R3,IRP$L_MEDIA(R1)	; SET TERMINATOR CHARACTER
	INCW	IRP$L_MEDIA+2(R1)	; START TERMINATOR SIZE
	MOVZWL	TTY$W_RB_TXTOFF(R4),R1	; GET THE PLACE TO STORE THE ESCAPE
	MOVB	#TTY$C_ESCAPE,@TTY$L_RB_TXT(R4)[R1]; AND PLACE THE CHARACTER IN THE RIGHT PLACE
	INCW	TTY$W_RB_TXTOFF(R4)	; AND INCREMENT THE WORLD
	IF_STATE ESC,60$
	SET_STATE ESC			; BEGIN ESCAPE SEQUENCE
	BRW	CHECK_BUFFER		; INSERT THE ESCAPE AT THE END OF THE BUFFER

51$:
	IF_NOT_STATE ESC,55$
	BRW	ESCINPROG		; ESCAPE IN PROGGRSS THEN CONTINUE
55$:
	BRW	INSERT_CHAR		; ELSE INSERT THE CHARACTER
;
; ALREADY IN ESCAPE MODE THEN MAKE THIS BAD
;
60$:	SET_STATE <BADESC,EOL>		; 
	BRW	GETNEXTCHAR


;++
; FORWARD_CHAR
;	MOVE THE CURSOR FORWARD 1 CHARACTER POSITION.
;--
FORWARD_CHAR:
	MOVZWL	TTY$W_RB_LINOFF(R4),R1	; GET THE OFFSET TO THE CHARACTER
	MOVZBL	@TTY$L_RB_LIN(R4)[R1],R3; GET THE CHARCTER
	DECW	TTY$W_RB_LINREST(R4)	; FORWARD A CHARACTER
	BLSS	50$			; AT THE END THEN DON'T ALLOW IT
	CLRL	R1			; GOING FORWARD
	BSBW	CHAR_SIZE		; CHECK THE SIZE OF THE CHARACTER
	ADDW3	R3,UCB$W_TT_CURSOR(R5),TTY$W_RB_CPZCUR(R4); UPDATE THE CURSOR POSITION
	MOVZWL	TTY$W_RB_LINOFF(R4),R1	; GET THE OFFSET TO THE CHARACTER
	MOVZBL	@TTY$L_RB_LIN(R4)[R1],R3; GET THE CHARCTER
	INCW	TTY$W_RB_LINOFF(R4)	; UPDATE THE REST POINTER
	CMPB	#TTY$C_TAB,R3		; ARE WE FORWARDING OVER A TAB?
	BNEQ	10$			; NO THEN CONTINUE
	BSBW	TABRIGHT		; YES THEN CHECK FOR A TAB TO THE RIGHT
10$:	IF_STATE NOECHO,GODROP
	BRW	FORMAT_CHAR		; THEN OUPUT THE CHARACTER TO GO FOWARD

50$:	CLRW	TTY$W_RB_LINREST(R4)	; RESET THE POINTER
GODROP:	BRW	DROP			; AND DROP THE CHARACTER

;++
; MOVE_BOL
;
; DESCRIPTION:
;	GO TO THE BEGINNING OF THE LINE.
;--
MOVE_BOL:
	TSTW	TTY$W_RB_CPZORG(R4)	; START AT ZERO?
	BEQL	10$			; YES THEN NO SPECAIL ACTION
	BSBW	ZERO_CPZORG		; ZERO ORG CURSOR IF WE HAVE WRAPPED
10$:	ADDW	TTY$W_RB_LINOFF(R4),TTY$W_RB_LINREST(R4); MOVE THE CHARACTER COUNTS AROUND
	CLRW	TTY$W_RB_LINOFF(R4)	; AND CLEAR THE NUMBER OF CHARACTERS WE HAVE
	BSBW	TABRIGHT		; CHECK FOR TABS TO THE RIGHT 
	CMPL	TTY$L_RB_LIN(R4),TTY$L_RB_TXT(R4); ARE WE ON THE FIRST LINE
	BNEQ	20$			; NO  THEN JUST DROP IT
	MNEGB	#1,TTY$B_RB_ECHLEN(R4)	; CLEAN OUT THE STRING TO ECHO
	MOVZBW	#TTY$K_ER_PRMECHO,TTY$W_RB_MODE(R4); SETUP THE MODE
	SET_STATE <EDITREAD>
20$:	TSTW	TTY$W_RB_CPZORG(R4)	; START AT ZERO?
	BNEQ	50$			; YES THEN NO SPECAIL ACTION
	MOVAB	TTY$A_ANSI_DEOL+1,UCB$L_TT_MULTI(R5); GET THE ADDRESS OF A <CR>
	MOVL	#1,UCB$W_TT_MULTILEN(R5); AND ONLY OUTPUT THE <CR>
	SET_STATE <MULTI,SKIPLF,SKIPCRLF>; SETUP TO DO A MULTIECHO
	CLRW	TTY$W_RB_CPZCUR(R4)	; MOVE TO THE BEGINNING WHEN DONE
	BRB	GODROP			; THEN DISPATCH
;
; IF THE ORIGION IS NON-ZERO THEN MOVE THE CURSOR TO THE ORIGIONAL POSITION
; 
50$:	MOVW	TTY$W_RB_CPZORG(R4),TTY$W_RB_CPZCUR(R4); SETUP TO MOVE BACK
	BRW	UPDATE_CURSOR

;++
; MOVE_EOL
;
; DESCRIPTION:
;	MOVE TO THE END OF THE LINE.
;--
MOVE_EOL:
	MOVB	TTY$W_RB_LINREST(R4),TTY$B_RB_ECHLEN(R4); GET THE LENGTH TO ECHO
	MOVZWL	TTY$W_RB_LINOFF(R4),R1	; GET THE OFFSET OF THIS CHARACTER
	MOVAB	@TTY$L_RB_LIN(R4)[R1],TTY$L_RB_ECHSTR(R4); SETUP THE ADDRESS ALSO
	MOVZBW	#TTY$K_ER_ECHLINE,TTY$W_RB_MODE(R4); AND SETUP THE MODE
	CLR_STATE TABRIGHT		; NO MORE CHARACTERS TO THE RIGHT SO
					; NO TABS EITHER
	IF_STATE NOECHO,10$		; NO ECHO THEN DON'T ECHO
	SET_STATE EDITREAD		; THEN THE STATE
10$:	ADDW	TTY$W_RB_LINREST(R4),TTY$W_RB_LINOFF(R4); FIX THE COUNTS
	CLRW	TTY$W_RB_LINREST(R4)	;...
	BRW	GETNEXTCHAR		; GET THE NEXT CHARACTER

;++
; QUOTING
;
; DESCRIPTION:
;	INITIATE QUOTING SEQUENCE
;--
QUOTING:
	SET_STATE QUOTING		;SET THE STATE QUOTE
	BRW	GETNEXTCHAR		; AND CONTINUE ON

;++
; RECALL
;
; DESCRIPTION:
;	SETUP THE NECESSARY STATE TO RECALL THE LAST COMMAND.
;--
RECALL:
	BBS	#TRM$V_TM_NORECALL,TTY$L_RB_MOD(R4),20$
	MOVL	UCB$L_TT_TYPAHD(R5),R4	;GET THE ADDRESS OF THE TYPEAHEA BUFFER
	TSTW	TTY$W_TA_RCLSIZ(R4)	; CHECK THE SIZE OF THE BUFFER
	BEQL	10$			; DON'T DO ANYTHING IF NO CHARACTERS
	CLRW	TTY$W_TA_RCLOFF(R4)	;CLEAN OUT THE OFFSET TO THE STRING
	SET_STATE <RECALL,EDITREAD>	;TELL THE DISPATCHER THAT WE ARE RECALLING
	MOVL	UCB$L_SVAPTE(R5),R4	; GET THE PACKET ADDRESS
	CLRW	TTY$W_RB_TXTOFF(R4)	; NO MORE TEXT
	CLRW	TTY$W_RB_LINOFF(R4)	; CLEAR THE LINE
	CLRW	TTY$W_RB_LINREST(R4)	; EVERYTHING ELSE
	MOVL	TTY$L_RB_TXT(R4),TTY$L_RB_LIN(R4)
	BRW	CTRLR			; THEN CONTROL-R THE READ
10$:	BRW	GETNEXTCHAR
20$:	BRW	INSERT_CHAR

;++
; TOGGELINSOV
;
; Description
;	Toggel the insert/overstrike mode flag
;--
TOGGELINSOV:
	BBSC	#TTY$V_ST_OVERSTRIKE,4(R2),10$; TOGGEL THE OVERSTRIKE BIT
	SET_STATE OVERSTRIKE
10$:	BRW	GETNEXTCHAR


	.SBTTL	EDITREAD - READ EDITING STATE

;++
; EDITREAD - STATE TO ALLOW A READ EDITING SEQUENCE
;
; FUNCTIONAL DESCRIPTION:
;
;	WHEN ECHOING PARTS OF READS IT IS NECESSARY TO ECHO SEVERAL
; STRINGS, THIS ROUTINE FILLS THAT NEED
;
; INPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R4 = ADDRESS OF THE READ PACKET
;	R5 = UCB ADDRESS
;
;--
EDITREAD:				; READ EDITING
	MOVL	UCB$L_SVAPTE(R5),R4	; GET THE READ PACKET ADDRESS
	CASE	TTY$W_RB_MODE(R4),TYPE=W,<-
		NORMAL,-
		CLRECHO,-		; ECHO WITH CLEAR BIT SET
		ECHLINE,-		; JUST ECHO WHAT IS SPECIFYED
		UPDCURSOR,-		; UPDATE THE CURSOR POSITION
		EXITING,-		; SETUP TO EXIT.
		MOVECURSOR,-		; ALLOW CURSOR TO BE UPDATED
		CLRREST,-		; CLEAR THE REST OF THE LINE
		PRMECHO,-		; ECHO PROMPT THEN CONTINUE
		PRMECHO1,-		; CONTINUING STATE FOR PROMPTING
		AESECHO,-		; ECHO AES STRING AND NOSTRING
		RVECHO,-		; echo in the readverify way
		SIMCEOL>		; SIMULATE CLEAR TO END OF LINE
NORMAL:

	IF_STATE <CTRLR,RDVERIFY>,120$		; HAVE WE COMPLETED THE CONTROL-R
	TSTW	TTY$W_RB_CPZORG(R4)	; START AT ZERO?
	BEQL	25$			; YES THEN NO SPECAIL ACTION
	TSTW	UCB$W_TT_CURSOR(R5)	; AND WE ARE NOW AT ZERO
	BNEQ	25$			; YES THEN WE SHOULD FIXUP THE LINE
	CLRW	TTY$W_RB_CPZORG(R4)	; DO THE FIXING
	BSBW	FIND_BOL		; FIND THE BEGINNING OF THE LAST LINE
	CLRW	UCB$W_TT_CURSOR(R5)	; FIX THE CURSOR (CHANGED DURING FIND_BOL)
25$:	IF_NOT_STATE SKIPCRLF,119$	; NO THEN ARE WE DOING A CR <CEL>
	SET_STATE <SKIPLF>		; YES THEN SKIP A LEADING LINEFEED AND CONTINUE
	MOVZBW	#TTY$K_ER_CLRREST,TTY$W_RB_MODE(R4); THEN CLEAR THE REST
	TSTW	TTY$W_RB_LINREST(R4)	; CURSOR VALID?
	BNEQ	119$			; YES THEN USE IT
	MNEGW	#1,TTY$W_RB_CPZCUR(R4)	; ELSE USE THE END POSITION
119$:	SET_STATE <CTRLR,EDITREAD>	; INDICATE THAT WE ARE OUTPUTTING THE
	ADDW3	TTY$W_RB_TXTOFF(R4),TTY$W_RB_PRMLEN(R4),-
		R1			; GET THE NUMBER OF CHARACTERS TO OUTPUT
	BEQL	120$			; IF NONE THEN DON'T BOTHER.
	MOVAB	TTY$A_RB_PRM(R4),R4	; GET THE ADDRESS TO START AT
	BRW	STRTMULTI_1		; AND START THE STRING ECHOING.
;
; END OF CONTROL R
;
120$:	MOVL	TTY$L_RB_ECHSTR(R4),R1	; CHECK FOR A CALLBACK
	BNEQ	CALLBACK
MOVIFNEC:
	TSTW	TTY$W_RB_LINREST(R4)	; ANY MORE CHARACTERS ON THE LINE
	BEQLU	EXITING			; NO THEN EXIT
	BRW	MOVECURSOR		; YES THEN MOVE THE CURSOR
EXITING:CLRW	TTY$W_RB_MODE(R4)	; CLEAN OUT THE EDITING MODE
	CLRL	TTY$L_RB_ECHSTR(R4)
	CLR_STATE <EDITREAD,CTRLR,CTRLO,SKIPCRLF,TABEXPAND>
	BRW	GETNEXTCHAR
;
; IT MAY BE NECESSARY TO CALL THE EDITING CODE BACK TO DO SOME WORK OPERATION
; THAT REQUIRED A ZERO ORIGIONAL CURSOR POSITION
;
CALLBACK:CLRW	TTY$W_RB_MODE(R4)	; CLEAN OUT THE EDITING MODE
	CLRL	TTY$L_RB_ECHSTR(R4)
	CLR_STATE <EDITREAD,CTRLR,CTRLO,SKIPCRLF,TABEXPAND>
	TSTW	TTY$W_RB_CPZORG(R4)	; MAKE SURE WE WON'T LOOP
	BNEQ	EXITING			; IF NOT SUCCESSFULL IN CLEARING
					; THE ORIGION THEN DROP THE CHARACTER
	JMP	(R1)

;
; ALTERNATE ECHO STRING.
;
AESECHO: MOVW	#TTY$K_ER_EXITING,TTY$W_RB_MODE(R4); SETUP TO EXIT
	MOVZWL	TTY$W_RB_AESLEN(R4),R1	; THE LENGTH OF THE STRING TO ECHO
	MOVL	TTY$L_RB_AES(R4),R4	; AND THE ADDRESS
	BRW	STRTMULTI_1		; NOW MULTIECHO

;
; Echo and clear to end of the line
;
CLRECHO:
	SET_STATE <TABEXPAND>		; SET TO EXPAND TABS
	MOVZBW	#TTY$K_ER_CLRREST,TTY$W_RB_MODE(R4); THEN MOVE THE CURSOR
COMECHO:MOVZBL	TTY$B_RB_ECHLEN(R4),R1	; SETUP THE NUNMBER OF CHARACTERS
	MOVL	TTY$L_RB_ECHSTR(R4),R4	; SETUP FOR MULTIECHO
	BRW	STRTMULTI_1		; AND START THE MULTIECHOING

;
; Clear to the end of the line
;
CLRREST:
	MOVZBW	#TTY$K_ER_MOVECURSOR,TTY$W_RB_MODE(R4);
	TSTW	TTY$W_RB_CPZCUR(R4)	; NEGITIVE CUR MEANS DON'T UPDATE
	BGEQ	20$			; 
	MOVW	UCB$W_TT_CURSOR(R5),TTY$W_RB_CPZCUR(R4); UPDATE THE CURRENT
20$:	CMPW	UCB$W_TT_CURSOR(R5),UCB$W_DEVBUFSIZ(R5); ANYTHING TO CLEAR
	BEQL	MOVECURSOR		; NOTHING TO CLEAR THEN JUST MOVE THE
					; CURSOR
	BBC	#TT2$V_ANSICRT,UCB$L_DEVDEPND2(R5),30$; IS IT AN ANSI CRT
	MOVAB	TTY$A_ANSICEL,R4	; GET A CLEAR TO END OF LINE SEQUENCE
	BRW	STRTMULTI		; AND MULTIECHO IT OUT
; for non-ansi terminals
30$:	MOVZBW	#TTY$K_ER_SIMCEOL,TTY$W_RB_MODE(R4); TELL IT TO COME BACK AND SIMULATE
	BRW	SIMCEOL

;
; echo the given data then exit
;
ECHLINE:MOVZBW	#TTY$K_ER_EXITING,TTY$W_RB_MODE(R4); EXIT AFTER ECHOING
	BRB	COMECHO			; AND GO TO THE COMMON CODE

;
; cause the cursor to be moved to it's origional position
;
MOVECURSOR:
	MOVZBW	#TTY$K_ER_EXITING,TTY$W_RB_MODE(R4); SETUP TO EXIT
	BRW	UPDATE_CURSOR		; AND UPDATE THE CURSOR

;
; Echo a prompt and a given amount of data then move the cursor to 
; the specifyed position.  This handles the no prompt case correctly.
;
PRMECHO:
	MOVW	TTY$W_RB_PRMLEN(R4),R1	; GET THE LENGTH OF THE PROMPT	
	BEQL	40$			; NO PROMPT THEN JUST ECHO SPECIFYED STRING
	MOVZBW	#TTY$K_ER_PRMECHO1,TTY$W_RB_MODE(R4); SET THE NEXT STATE
	MOVAB	TTY$A_RB_PRM(R4),R4	; GET THE PROMPT'S ADDRESS
	SET_STATE <SKIPCRLF,SKIPLF>	; SKIP THE FREE LINEFEEDS
	BRW	STRTMULTI_1		; AND MULTIECHO THE PROMPT OUT
;
; SETUP THE CORRECT CURSOR POSITION FOR THE NO PROMPT CASE
;
40$:	MOVW	TTY$W_RB_CPZORG(R4),UCB$W_TT_CURSOR(R5)

;
; second part of prompt echoing if necessary.
;
PRMECHO1:
	TSTW	TTY$W_RB_CPZCUR(R4)	; SHOULD WE UPDATE THIS CURSOR
	BGTR	50$			; NO IF NOT ZERO
	INCW	TTY$W_RB_CPZCUR(R4)	; WAS THIS -1?
	BLSS	50$			; NO THEN DON'T RESET THE CURSOR
	MOVW	UCB$W_TT_CURSOR(R5),TTY$W_RB_CPZCUR(R4); RESET CURSOR POSITION
50$:	CLR_STATE <SKIPCRLF,SKIPLF>	; CLEAN THE SKIP STATE UP
	TSTB	TTY$B_RB_ECHLEN(R4)	; DO WE HAVE ANYTHING TO ECHO
	BGTR	70$			; YES THEN ECHO THE SPECIFYED STRING
	BLSS	60$			; LESS THAN 0 EXIT
	BRW	CLRREST			; ELSE THEN CLEAR THE REST OF THE LINE
60$:	CLRB	TTY$B_RB_ECHLEN(R4)	; CLEAN OUT THEE OFFSET JUST IN CASE
	BRW	EXITING
70$:	BRW	CLRECHO

;
; read verify echoing (echo's a string replacing fill characters with clear characters)
;
RVECHO:	DECB	TTY$B_RB_ECHLEN(R4)	; TAKE THIS CHARACTER OUT
	BLSS	20$			; NO MORE THEN MOVE THE CURSOR
	MOVZBL	@TTY$L_RB_ECHSTR(R4),R3	; GET A CHARACTER
	CMPL	TTY$L_RB_ECHSTR(R4),TTY$L_RB_TXT(R4); IS THIS PAST THE PROMPT
	BLSS	10$			; NO THEN DON'T CHANGE CHARACTERS
	CMPB	TTY$B_RB_RVFFIL(R4),R3	; IS THIS A FILL CHARACTER
	BNEQ	10$			; NO THEN  CONTINUE
	MOVZBL	TTY$B_RB_RVFCLR(R4),R3	; OTHERWISE ECHO THE CLEAR CHARACTER
10$:	INCL	TTY$L_RB_ECHSTR(R4)	; UPDATE THE COUNT
	BRW	FORMAT_CHAR		; ELSE FORMAT THE CHARACTER
20$:	BRW	MOVIFNEC		; MOVE IF NECESSARY


;
; NON-ANSI CRT THEN SIMULATE CLEAR TO END OF LINE
;
SIMCEOL:
	BBC	#TT$V_SCOPE,-		; CLEAR TO END OF LINE IS MEANINGLESS
		UCB$L_DEVDEPEND(R5),MOVECURSOR; ON HARD COPY TERMINALS
	SUBW3	UCB$W_TT_CURSOR(R5),UCB$W_DEVBUFSIZ(R5),R3
	CMPW	R3,#8			; OUTPUT IN GROUPS OF 8
	BLEQ	10$			;...
	MOVAB	TTY$A_TAB,R4		; SETUP TO ECHO 8
	BRW	STRTMULTI

10$:	MOVZBW	#TTY$K_ER_MOVECURSOR,TTY$W_RB_MODE(R4); NEXT MOVE THE CURSOR
	SUBL3	#1,R3,R1		; SUBTRACT 1 FROM THE COUNT
	MOVAB	TTY$A_TAB+1,R4		;.
	BRW	STRTMULTI_1		; AND ECHO IT

;
; set the current cursor position
;
UPDCURSOR:
	MOVW	TTY$W_RB_CPZCUR(R4),UCB$W_TT_CURSOR(R5); UPDATE THE CURSOR POSITION
	BRW	EXITING			; THEN EXIT

	.SBTTL	Read service routines
;++
; BACK_TAB
;
;	Calculates the cursor postion of the beginning of a tab while
; at the end of the tab.
;
; Implicit inputs:
;
;	R5	UCB address
;	TTY$W_RB_LINOFF the current location off of LIN
;	TTY$L_RB_LIN the address of the beginning of this line
;	TTY$L_RB_TXT the address of the beginning of the data buffer
;	TTY$A_RB_PRM offset from svapte to the beginning of the prompt
;	TTY$W_RB_CPZORG cursor postion when the read started
;
; Outputs:
;	R3	Mod 8 of the cursor position
;--
BACK_TAB:
	PUSHL	R4			; SAVE R4
	MOVL	UCB$L_SVAPTE(R5),R4	; GET THE ADDRESS OF THE READ BUFFER
	MOVZWL	TTY$W_RB_LINOFF(R4),R3	; GET THE CURRENT LOCATION
	MOVAB	@TTY$L_RB_LIN(R4)[R3],R3; POINT TO END OF DATA
	CLRL	-(SP)			; SET UP CURSOR COUNTER
	CMPL	TTY$L_RB_LIN(R4),TTY$L_RB_TXT(R4); ARE WE ON THE FIRST LINE?
	BEQL	10$			; YES THEN CONTINUE
	MOVL	TTY$L_RB_LIN(R4),R4	; ELSE JUST USE THE BEGINNING OF THIS ONE
	BRB	20$			; AND CONTINUE ON
10$:	MOVAB	TTY$L_RB_DATA(R4),R4	; POINT TO DATA START
20$:	CMPL	R3,R4			; BUFFER START?
	BEQL	40$			; THEN REFERENCE POINT FOUND
	CMPB	-(R3),#TTY$C_CR		; CARRIAGE RETURN?
	BEQL	50$			; IF EQL THEN REFERENCE POINT FOUND
	CMPB	(R3),#TTY$C_TAB		; TAB?
	BEQL	50$			; IF EQL THEN REFERENCE POINT FOUND
	CMPB	(R3),#TTY$C_ESCAPE	; IS THIS AN ESCAPE
	BEQL	30$			; YES THEN REMOVE THE ESCAPE SEQUENCE
	CMPB	(R3),#TTY$C_CSI		; CSI'S COUNT ALSO
	BEQL	30$
	CMPB	(R3),#TTY$C_BLANK	; CURSOR CHANGE CHARACTER?
	BLSSU	20$			; IF LSSU THEN NO
	INCL	(SP)			; ADJUST FAKE CURSOR
	BRB	20$			; CONTINUE
;
; ESCAPE INTRODUCER FOUND
;
30$:	BSBW	ESCAPE_TAB		; REMOVE THE ESCAPE SEQUENCE
	BRB	20$			; THEN CONTINUE
;
; RAN OUT OF BUFFER WITHOUT FINDING A REFERENCE POINT
;
40$:	MOVL	UCB$L_SVAPTE(R5),R3	; GET THE ADDRESS OF THE READ BUFFER
	CMPL	TTY$L_RB_TXT(R3),TTY$L_RB_LIN(R3); THIS IS NOT THE FIRST LINE
	BNEQ	50$			; USE ZERO BASED ORIGION.
	ADDW	TTY$W_RB_CPZORG(R3),(SP); ELSE USE ORITIONAL ORIGION
;
; FOUND THE REFERENCE POINT THEN CONTINUE
;
50$:	BICL3	#^X0FFFFFFF8,(SP)+,R3	; GET MOD 8 OF CURSOR
	POPL	R4			; RESTORE R4
	RSB


;++
; CHAR_SIZE
;
; DESCRIPTION:
;
;	GIVEN A CHARACTER IN R3 THIS ROUTINE WILL DETERMINE THE NUMBER
; OF CURSOR POSITIONS THE CHARACTER WILL TAKE UP.
;
; INPUTS:
;	R1 = 0 FOR FOWARD CHARACTER SIZE -1 FOR BACKWARD CHARACTER SIZE
;	R3 = CHARACTER
;	R5 = ADDRESS OF THE UCB
;
; OUTPUTS:
;
;	R3 = THE LENGTH IN CURSOR POSITIONS OF THIS CHARACTER
;	R5 = UCB ADDRESS
;
;--

CHAR_SIZE:
	CASE	W^TTY$A_TYPE[R3],LIMIT=#1@TTY$V_CH_SPEC,TYPE=B,<-
			10$,-			; back space
			20$,-			; tab
			5$,-			; linefeed (no action)
			5$,-			; Vtab (no action)
			5$,-			; form (no action)
			60$>			; <CR>
	BITB	#<TTY$M_CH_CTRL!TTY$M_CH_SPEC!TTY$M_CH_CTRL2!TTY$M_CH_CTRL3>,-
	W^TTY$A_TYPE[R3]		; TEST FOR SPECIAL
	BNEQ	5$			; NON SPACING CHARACTER
	MOVZBL	#1,R3			; OTHERWISE ONLY 1 CHARACTER POSITION
	RSB

5$:	CLRL	R3			; CLEAR R3 OUT
	RSB				; AND RETURN

10$:	MNEGL	#1,R3			; BACKSPACE THEN BACKUP
	RSB

20$:					; TAB
	EXTZV	#0,#3,UCB$W_TT_CURSOR(R5),R3; GET HORIZONTAL POINTER
	TSTL	R1			; IS THIS A BACKWARD CALCULATION
	BGEQ	23$			; NO THEN SUBTRACT
	BSBW	BACK_TAB		; CALCULATE THE MOD 8 OF THE CURSOR
23$:	SUBL3	R3,#8,R3		; NORMALIZE THE RESULT
	RSB				; AND RETURN

60$:	MOVZWL	UCB$W_TT_CURSOR(R5),R3	; CARRIAGE RETURN SHOULD ZERO CURSOR
	RSB				; POSITION

;++
; ESCAPE_TAB
;
;	Handle the removal of escape sequencses from a prompt
; when deleting tabs.
;
; Implicit inputs:
;
;	R3 the address of the escape character
;	R5 THE UCB ADDRESS
;	4(SP) the internal count
;
; Implicit outputs:
;
;	4(SP) updated internal count
;
; All registers are saved
;--
ESCAPE_TAB:
	PUSHL	R1		; SAVE A SCRATCH REGISTER
	MOVL	8(SP),R1	; RESTORE THE INTERNAL COUNT
	PUSHR	#^M<R3,R4>	; SAVE THE REST OF THE REGISTERS
	MOVL	R3,R4		; MOVE THE CURRENT POSITION TO R4
	MOVZBL	(R4)+,R3	; GET THE CHARACTER THAT INTRODUCES THE SEQUENCE
	PUSHL	R1			; SAVE R1
	BSBW	ESCINIT			; INIT THE ESCAPE SEQUENCE RULES
	MOVB	R1,UCB$B_TT_ESC(R5)	; ...
	POPL	R1			; RESTORE R1

20$:	DECL	R1		; DECREMENT THE COUNT
	MOVZBL	(R4)+,R3	; GET THE CHARACTER AND MOVE TO THE NEXT
	BSBW	ESCSYNTAX	; CHECK THE SYNTAX
	BGTR	20$		; CONTINUE IF NECESSARY
	POPR	#^M<R3,R4>	; SEQUENCE COMPLETE THEN RESTORE THE REGISTERS
	MOVL	R1,8(SP)	; PUT THE COUNT BACK
	POPL	R1		; RESTORE THE LAST REGISTER
	RSB			; AND NOW RETURN

;++
; FIND_BOL - FIND THE BEGINNING OF THIS LINE
;
; Description:
;
;	Given a string this routine will find the offset to the character
; that will end up in the first character position of the bottom line
; of the screen
;	
;
; IMPLICIT INPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R4 = ADDRESS OF THE READ BUFFER
;	R5 = ADDRESS OF THE UCB
;	TTY$L_RB_TXT
;	TTY$L_RB_LIN
;	TTY$L_RB_PRMLEN
;	TTY$L_RB_TXTOFF assumed non-zero
;	TTY$A_RB_PRM
;	TTY$W_RB_LINOFF
;	TTY$W_RB_LINREST assumed zero
;
; IMPLICIT OUTPUTS:
;
;	TTY$L_RB_LIN address of the first character in this line of data
;	TTY$L_RB_LINOFF offset from LIN to the end of the line
;	R3 is destroyed.
;--
FIND_BOL:
	CLRW	UCB$W_TT_CURSOR(R5)	; CLEAN THE CURSOR POSITION
FIND_BOL_NOCLEAR::
	CLRL	R1			; CLEAN R1
	MOVL	TTY$L_RB_TXT(R4),TTY$L_RB_LIN(R4); START WITH THE BEGINNING
	PUSHR	#^M<R6,R7>		; GET A FEW SCRATCH REGISTERS
	CLRL	R6			; CLEAR R6, THE BEGINNING OFFSET
	ADDW3	TTY$W_RB_PRMLEN(R4),TTY$W_RB_TXTOFF(R4),R7; GET THE ENDING OFFSET
	BBCC	#TTY$V_RS_WRAP,TTY$W_RB_RDSTATE(R4),210$; CLEAR THE WRAP STATE
210$:	CMPW	R6,R7			; ARE WE DONE?
	BGEQ	240$			; YES THEN EXIT
	MOVZBL	TTY$A_RB_PRM(R4)[R6],R3	; GET THE CHARACTER
	INCL	R6			; MOVE TO THE NEXT CHARACTER
	CMPB	#TTY$K_ET_ESCAPE,TTY$A_CCLIST[R3]
	BEQL	250$			; HANDLE ESCAPE SEQUENCES
	CMPB	#TTY$C_CR,R3		; A CR ZEROS CURSOR
	BEQL	230$			; SO DO SO
	BSBW	CHAR_SIZE		; OTHER WISE GET THECURSOR POSITION
	ADDW	R3,UCB$W_TT_CURSOR(R5)	; ADD IN THE POSITION
	CMPW	UCB$W_TT_CURSOR(R5),UCB$W_DEVBUFSIZ(R5); IS THIS A WRAP
	BLSS	210$			; NO THEN GO ON
	SUBW	UCB$W_DEVBUFSIZ(R5),UCB$W_TT_CURSOR(R5); SUBTRACT OUT THE
					; LINE LENGTH
	MOVAB	TTY$A_RB_PRM(R4)[R6],R3	; GET THE ADDRESS OF THE WRAP
220$:	BBSS	#TTY$V_RS_WRAP,TTY$W_RB_RDSTATE(R4),225$; SET UP THE WRAP CHARACTERISTIC
225$:	CMPL	R3,TTY$L_RB_TXT(R4)	; ARE WE PAST THE PROMPT?
	BLSS	210$			; YES THEN CONTINUE
	MOVL	R3,TTY$L_RB_LIN(R4)	; AND THIS IS THE LINE
	BRB	210$			; THEN CONTINUE

230$:	MOVAB	TTY$A_RB_PRM(R4)[R6],R3	; GET THE ADDRESS OF THE WRAP
	CLRW	UCB$W_TT_CURSOR(R5)	; CLEAR CURSOR ON A <CR>
	BRB	220$			; NOW CONTINUE

;
; ESCAPE SEQUENCE INTRODUCER
;
250$:	PUSHL	R1			; SAVE R1
	BSBW	ESCINIT			; INIT THE SYNTAX RULES
	MOVB	R1,UCB$B_TT_ESC(R5)	; ...
	POPL	R1			; RESTORE THE REGISTER
260$:
	CMPW	R6,R7			; ARE WE FINISHED
	BGEQ	240$			; YES THEN EXIT
	MOVB	TTY$A_RB_PRM(R4)[R6],R3 ; GET THE NXT CHARACTER
	INCL	R6			; MOVE TO THE NEXT CHARACTER
	BSBW	ESCSYNTAX		; AND CHECK THE SYNTAX
	BGTR	260$			; MORE THEN CONTINUE
	BRW	210$			; NO MORE THEN GO BACK

240$:	MOVAB	TTY$A_RB_PRM(R4)[R6],R3; GET THE ADDRESS OF THIS CHARACTER
	SUBL	TTY$L_RB_LIN(R4),R3	; GET THE OFFSET TO THE LAST CHARACTER
	MOVW	R3,TTY$W_RB_LINOFF(R4)	; AND LEAVE IT there
	POPR	#^M<R6,R7>		; RESTORE THE REGISTERS
	RSB

;++
; STRTMULTI - START A MULTIECHO STRING GIVEN THE ADDRESS OF AN ASCIC STRING
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE STARTS THE SPECIFIED MULTIECHO STRING ON A UNIT.
; THE COUNT OF THE STRING IS PLACED IN UCB$W_TT_MULTILEN, AND THE
; ADDRESS OF THE FIRST CHARACTER IN THE STRING IS PLACED IN UCB$L_TT_MULTI.
; THEN STATE MULTI IS SET AND MULTIECHO IS CALLED.
;
; STRTMULTI_1 - starts a multiecho string given the address and a length 
;		of a string (address in R4, length in R1)
;
; INPUTS
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R4 = ADDRESS OF A COUNTED MULTIECHO STRING (ASCIC)
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R3 = FIRST CHARACTER
;	R5 = UCB ADDRESS
;	R4 DESTROYED
;--
STRTMULTI::
	MOVW	UCB$W_TT_MULTILEN(R5),UCB$W_TT_SMLTLEN(R5); SAVE LENGTH
	MOVZBW	(R4)+,UCB$W_TT_MULTILEN(R5)	;GET THE LENGTH INTO ALTLENA
	BRB	LOADADR
STRTMULTI_1::
	MOVW	UCB$W_TT_MULTILEN(R5),UCB$W_TT_SMLTLEN(R5); SAVE LENGTH
	MOVW	R1,UCB$W_TT_MULTILEN(R5)	; MOVE IN THE NEW LENGTH
LOADADR:
	MOVL	UCB$L_TT_MULTI(R5),UCB$L_TT_SMLT(R5); SAVE THE ADDRESS
	MOVL	R4,UCB$L_TT_MULTI(R5)		;THEN THE ADDRESS INTO MULTI
	SET_STATE <MULTI>			;NEXT SET MULTIECHO STATE
	brw	multiechoing

;++
; TABRIGHT - CHECK FOR A TAB TO THE RIGHT OF THE CURSOR POSITION
;
; DESCRIPTION:
;
;	This routine will detect a tab character to the right of the cursor
; position and set a flag indicating that insert mode is illegal.  This
; prevents having to recalculate tab and wrap position for each character.
;
; Inputs:
;	R4 - Read packet address
;
; Outputs:
;
;	TABRIGHT state bit set if a tab is to the right of the cursor
;		 reset if not.
;	All registers preserved.
;--
TABRIGHT:
	PUSHR	#^M<R0,R1>		; SAVE SOME WORKING REGISTERS
	CLR_STATE TABRIGHT		; CLEAR THS STATE
	MOVZWL	TTY$W_RB_LINOFF(R4),R1	; GET THE OFFSET INTO THE STRING
	LOCC	#TTY$C_TAB,TTY$W_RB_LINREST(R4),@TTY$L_RB_LIN(R4)[R1];
					; TRY TO FIND A TAB
	BEQL	10$			; DID WE FIND A TAB?
	SET_STATE TABRIGHT		; YES THEN SET THE STATE
10$:	POPR	#^M<R0,R1>		; RESTORE THE REGISTERS
	RSB				; AND RETURN


;++
; UPDATE_CURSOR
;
; DESCRIPTION:
;
;	WILL SETUP THE NECESSARY SEQUENCE OF EVENTS TO HAVE
; THE CURSOR MVOVED TO THE PLACE SPECIFYED BY TTY$W_RB_CPZCUR
;
; INPUTS:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R5 = UCB ADDRESS
; 	TTY$W_RB_CPZCUR = THE FINAL CURSOR POSITION
;	UCB$W_TT_CURSOR = THE CURRENT POSITION.
;
; OUTPUT:
;
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R4 = ADDRESS OF THE READ PACKET
;	R5 = UCB ADDRESS
; R3 DESTROYED
;--
UPDATE_CURSOR:
	MOVL	UCB$L_SVAPTE(R5),R4		; GET THE READ PACKET ADDRESS
	SUBW3	TTY$W_RB_CPZCUR(R4),-		; SUBTRACT THE FINAL CURSOR POSITION
		UCB$W_TT_CURSOR(R5),-		; FROM THE CURRENT CURSOR POSITION
		UCB$W_TT_BSPLEN(R5)		; AND ECHO THAT MANY BACKSPACES
	CMPW	UCB$W_TT_CURSOR(R5),-
		UCB$W_DEVBUFSIZ(R5)		; ARE WE AT THE END OF THE LINE
	BLSSU	5$				; NO THEN CONTINUE
	DECW	UCB$W_TT_CURSOR(R5)		; KEEP THE POSITION CORRECT
	DECW	UCB$W_TT_BSPLEN(R5)		; ELSE THE TERMINAL DOES A BACKSPACE FOR YOU
	BEQL	40$				; NO BACKSPACES THEN EXIT
5$:
	BBC	#TT2$V_ANSICRT,UCB$L_DEVDEPND2(R5),30$; NOT AN ANSI TERMINAL THEN BRUTE FORCE IT
	CMPW	#8,UCB$W_TT_BSPLEN(R5)		; CAN WE OPTOMIZE ON AN ANSI TERMINAL
	BGTR	30$				; NO THEN OUTPUT BACKSPACES
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>		; SAVE THE REGISTERS
	MOVZBL	TTY$A_ANSIBACKUP,R1		; GET THE LENGTH OF THE STRING
	INCL	R1				; ADD IN THE COUNT TOO.
	MOVC3	R1,TTY$A_ANSIBACKUP,TTY$Q_RB_ECHOAREA(R4); MOVE THE CHARACTER
						; STRING IN TO PLACE
	POPR	#^M<R0,R1,R2,R3,R4,R5>		; RESTORE THE REGISTERS
	CLRL	-(SP)				; GET ENOUGH ROOM FOR THE DIVIDEND
	MOVZWL	UCB$W_TT_BSPLEN(R5),-(SP)	;  AND PUT IT THE DIVISOR
	MOVAB	TTY$Q_RB_ECHOAREA+6(R4),R1	; GET THE ADDRESS OF THE FISRST BYTE OF THE NUMBER FIELD
10$:	EDIV	#10,(SP),(SP),R3		; GET THE FIRST DIGIT
	ADDB	R3,-(R1)			; PUT IT IN PLACE
	TSTL	(SP)				; DO WE HAVE ANY MORE TO DO
	BNEQ	10$				; YES THEN DO SO
	TSTL	(SP)+				; CLEAN THE STACK
	TSTL	(SP)+				; ...
	MOVW	TTY$W_RB_CPZCUR(R4),UCB$W_TT_CURSOR(R5); UPDATE THE CURSOR POSITION
;	MOVZBW	#TTY$K_ER_UPDCURSOR,TTY$W_RB_MODE(R4); SETUP THE EDITREAD STATE
;	SET_STATE EDITREAD			; And setup the edit read state
	MOVAB	TTY$Q_RB_ECHOAREA(R4),R4	; GET THE ECHO AREA ADDRESS
	BRW	STRTMULTI			; and start the multiechoing

30$:	SET_STATE <BACKSPACE>			; AND START MULTIECHOING BACKSPACES
40$:	BRW	GETNEXTCHAR			; GET THE NEXT CHARACTER

;++
;ZERO_CPZORG - HANDLE CASE WHERE WE NEED A FRESH LINE
;
; DESCRIPTION:
;
;	This routine will check and make sure that the origional cursor
; position becomes zero.  This will then callback the routine that called it
; and re-run the operation.
;
; Inputs:
;
;	R4 - READ BUFFER ADDRESS
;	R5 - UCB ADDRESS
;	(SP) - ADDRESS OF A ROUTINE TO CONTINUE WITH
;--
ZERO_CPZORG:
	BBS	#TTY$V_RS_WRAP,TTY$W_RB_RDSTATE(R4),50$; IF WE WRAPPED THEN
					; WE MUST FIX UP THE IO
	CMPL	TTY$L_RB_TXT(R4),TTY$L_RB_LIN(R4); DID WE WRAP?
	BEQL	60$			; NO THEN NO SPECAIL ACTION
50$:	MOVL	(SP)+,TTY$L_RB_ECHSTR(R4); SETUP A CALLBACK
	BRW	CTRLR			; AND REFRESH THE IO
60$:	RSB

	.sbttl	Read passall
;++
;
; PASS ALL  AND NO FILTER HANDELER
;
; INPUTS:
;	R2 = ADDRESS OF THE UNIT STATE VECTOR
;	R3 = CHARACTER TO INSERT
;	R4 = READ PACKET ADDRESS
;	R5 = UCB ADDRESS
;
;--
PASSALL::

	MOVZWL	TTY$W_RB_TXTOFF(R4),R1	; GET THE PLACE TO PUT THIS CHARACTER
	MOVB	R3,@TTY$L_RB_TXT(R4)[R1]; PUT THE CHARACTER AWAY
	IF_STATE ESC,1800$		; ESCAPE THE EXIT
	IF_NOT_STATE PASALL,1900$	; NOFORMAT THEN UPPER CASING MAY BE NECESSARY
1005$:	IF_STATE ESCAPE,1045$		; IF ESCAPE MODE THEN EXIT
1040$:	BBS	R3,@TTY$L_RB_TERM(R4),1500$; IS THIS A TERMINATOR
	INCW	TTY$W_RB_TXTOFF(R4)	; INCREMENT THE COUNT
1010$:	CMPW	TTY$W_RB_TXTOFF(R4),TTY$W_RB_TXTSIZ(R4); ARE WE FINSIHED
	BGEQU	1600$			; YES THEN FINISH

1030$:	IF_STATE <ESC>,1000$		; IS THIS THIS ESCAPE
	IF_NOT_STATE PRE,1025$		; IF PRETYPEAHEAD THEN RETURN
1020$:	RSB
1025$:	IF_NOT_STATE NOECHO,1027$
	BBC	#TT2$V_LOCALECHO,-	; LOCAL ECHO?
		UCB$L_DEVDEPND2(R5),1026$; NO THEN MUST BE NOECHO
	BBS	#TRM$V_TM_NOECHO,-	; NOECHO SPECIFYED
		TTY$L_RB_MOD(R4),1026$	; ON THE READ
	BRW	FORMAT_LOCAL		; ELSE LOCAL ECHO IT
1027$:	BRW	FORMAT_CHAR		; FORMAT THE CHARACTER
1000$:	IF_NOT_STATE PRE,1026$
	RSB
1026$:	BRW	GETNEXTCHAR

1045$:	BRW	1400$
; CONVERT LOWER TO UPPER IF NOFORMAT
;
1900$:	MOVL	UCB$L_IRP(R5),R1	; GET THE IRP ADDRESS
	BBC	#IO$V_CVTLOW,IRP$W_FUNC(R1),1005$; BR IF CONVERT LOWER TO UPPER
	BBC	#TTY$V_CH_LOWER,W^TTY$A_TYPE[R3],1005$; BR IF NOT LOWER CHARACTER
	BICW	#^X020,R3		; CONVERT TO UPPER CASE
	MOVZWL	TTY$W_RB_TXTOFF(R4),R1	; GET THE PLACE TO PUT THIS CHARACTER
	MOVB	R3,@TTY$L_RB_TXT(R4)[R1]; PUT THE CHARACTER AWAY
	BRB	1005$

1600$:	MOVL	UCB$L_IRP(R5),R1	; GET THE IRP ADDRESS
	CLRW	IRP$L_MEDIA(R1)		; SET NO TERMINATOR
	SET_STATE EOL			; SIGNIFY END OF LINE
	BBSC	#TTY$V_ST_PRE,4(R2),1020$; CLEAR PRE IF NECESSARY AND EXIT
	BRB	1030$


1500$:	MOVW	TTY$W_RB_TXTOFF(R4),TTY$W_RB_LINOFF(R4); SETUP LINOFF
	SET_STATE EOL			; SIGNIFY END OF LINE
	BRB	1440$
;
; ESCAPE IN PROGRESS
;
1800$:	MOVL	UCB$L_IRP(R5),R1	; GET THE IRP ADDRESS
	INCW	IRP$L_MEDIA+2(R1)	; ADD 1 TO THE SIZE
	INCW	TTY$W_RB_TXTOFF(R4)	; UP THE OFFSET BECAUSE WE PUT 1 CHAR IN THE BUFFER
	BSBW	ESCSYNTAX		; CHECK THE SYNTAX OF THIS CHAR
	BGTR	1830$			; OK THEN CONTINUE ON
	BEQL	1810$			; VALID SEQUENCE CONTINUE

	SET_STATE BADESC		; A BAD ESCAPE SEQUENCE THEN SAY SO
1810$:	CLR_STATE ESC			; CLEAR THE ESCAPE STATE
	SUBW	IRP$L_MEDIA+2(R1),TTY$W_RB_TXTOFF(R4); SUBTRACT OUT THE SEQUENCE
	SET_STATE <EOL,NOECHO>		; LENGTH AND SET END OF LINE

1830$:	BRW	1450$			; THEN EXIT 

1400$:	CMPB	TTY$A_CCLIST[R3],#TTY$K_ET_ESCAPE; CHECK FOR ESCAPE INTR
	BNEQ	1470$			;ESCAPE SEQUENCE INTRODUCER
	CMPB	#TTY$C_LOWESC1,R3	;IS THIS AN ALTMODE
	BEQL	1410$			; YES THEN HANDLE SPECAILLY
	CMPB	#TTY$C_LOWESC2,R3	; LOWER ALSO
	BNEQ	1420$			; NO THEN MUST BE AN ESC OR CSI
1410$:	BBS	#TT$V_LOWER,UCB$L_DEVDEPEND(R5),1470$; LOWER CASE TERMINAL
	MOVZWL	TTY$W_RB_TXTOFF(R4),R1	; GET THE LOCATION OF THIS CHARACTER
	MOVB	#TTY$C_ESCAPE,@TTY$L_RB_TXT(R4)[R1]; AND FORCE THE ESCAPE
	MOVZBl	#TTY$C_ESCAPE,R3	; AND PUT THE ESCAPE IN R3	
1420$:	INCW	TTY$W_RB_TXTOFF(R4)	; ESCAPE INTRO THEN SAY SO.
	PUSHL	R1			; SAVE
	BSBW	ESCINIT
	MOVB	R1,UCB$B_TT_ESC(R5)
	POPL	R1
	SET_STATE ESC			; SETUP ESCAPE STATE
1440$:	MOVL	UCB$L_IRP(R5),R1	; GET THE IRP ADDRESS
	MOVW	R3,IRP$L_MEDIA(R1)	; SETUP THE TERMINATING CHARACTER
	INCW	IRP$L_MEDIA+2(R1)	; AND THE LENGTH
1450$:	CMPW	TTY$W_RB_TXTOFF(R4),TTY$W_RB_TXTSIZ(R4); ARE WE FINSIHED
	BGEQU	1460$			; YES THEN FINISH
	IF_NOT_STATE EOL,1480$		; IF NOT END OF LINE THEN RETURN
	BBSC	#TTY$V_ST_PRE,4(R2),1490$
	IF_STATE NOECHO,1480$
	BBS	#TRM$V_TM_TRMNOECHO,-
		TTY$L_RB_MOD(R4),1495$	; IF NOT ECHOING TERMINATER THEN EXIT
1480$:	BRW	1030$
1460$:	BRW	1600$
1470$:	BRW	1040$
1490$:	BRW	1020$
1495$:	BRW	1026$

	.SBTTL	READ WITH VERIFICATION
;++
; RDVERIFY
;
; Description:
;	Read verify allows programs that wish to do character validataion
; to issue one IO rather than a QIO per character as was previously the case.
;
; Inputs:
;
;	R2 - Unit state vector
;	R5 - address of the ucb
;
; Implicit inputs:
;
;	UCB$L_SVAPTE	- The address of the read buffer.
;	TTY$L_RB_TXT	- The address of the first character of the initial string
;	TTY$W_RB_TXTOFF - Offset to the last character in the initial string
;	TTY$W_RB_TXTSIZ	- Length of the data buffer.
;	TTY$W_RB_LINOFF - Offset to the end of the field, initial offset.
;	TTY$L_RB_PIC	- The address of the picture string.
;--
RDVERIFY::
	MOVL	UCB$L_TT_TYPAHD(R5),R4	; ADDRESS TYPEAHEAD BUFFER
	BEQL	40$			; NO BUFFER THEN THERE IS A FORK
					; PROCESS WAITING SO LET IT GO.
	TSTW	TTY$W_TA_INAHD(R4)	; ANY TYPEAHEAD DATA?
	BNEQ	50$			; yes then take it out and continue
;
; TYPEAHEAD BUFFER EXHAUSTED
;
	IF_NOT_STATE <TYPFUL>,35$	; BR IF TYPEAHEAD IS NOT FULL

20$:	BRW	XON			; CONTINUE
35$:
;
; THE TYPEAHEAD BUFFER HAS NOW BEEN EMPTIED INTO THE SYSTEM BUFFER.
; IF PROCESSING A READ WITH ZERO SECOND TIMEOUT, RETURN THE DATA
; TO THE USER IMMEDIATELY.
;
	BBC	#UCB$V_TT_TIMO,UCB$W_DEVSTS(R5),40$; BR IF NOT READ WITH TIMEOUT.
	CMPL	TTY$A_MAXTIME,UCB$L_TT_RDUE(R5); ZERO SECOND TIMEOUT?
	BNEQ	40$			; BR IF NOT.
	MOVW	#SS$_TIMEOUT,UCB$W_BOFF(R5); SET TIMEOUT COMPLETION STATUS.
	BSBW	TTY$READONE		; COMPLETE REQUEST.
;
; DISMISS INTERRUPT
;
40$:	CLRB	UCB$B_TT_OUTYPE(R5)	; SET NO RETURN CHARACTER.
	RSB				; and dismiss the interupt
;
; ACTUALLY REMOVE CHARACTER FROM BUFFER
;
50$:	MOVZBL	@TTY$L_TA_GET(R4),R3	; GET THE CHARACTER
	BBCC	#TTY$V_ST_ECHAES,4(R2),55$; IS THIS THE FIRST CHARACTER
	MOVL	UCB$L_SVAPTE(R5),R4	; GET THE READ PACKET ADDRESS
	MOVZBW	#TTY$K_ER_AESECHO,TTY$W_RB_MODE(R4); YES THEN ECHO THE AES STRING
	SET_STATE EDITREAD		; NOW DO EDITING
	BRW	EDITREAD		; AND ECHO THE STRING
55$:
	DECW	TTY$W_TA_INAHD(R4)	; ADJUST NUMBER OF TYPEAHEAD CHARACTERS
;
; CHECK FOR BUFFER WRAP AROUND
;
	AOBLSS	TTY$L_TA_END(R4),TTY$L_TA_GET(R4),60$; POINTER PAST END?
	MOVAB	TTY$L_TA_DATA(R4),TTY$L_TA_GET(R4); RESET POINTER

60$:	PUSHL	R0			; charo can not destroy R0
	MOVL	UCB$L_SVAPTE(R5),R4		; GET READ BUFFER
	IF_STATE ESC,10$		; IF ESCAPE SEQUENCE IN PROGRESS THEN HANDLE
	BBC	#TRM$V_TM_R_JUST,TTY$L_RB_MOD(R4),-; BRANCH IF LEFT JUSTIFY MODE
		LEFT_JUSTIFY
	BRW	RIGHT_JUSTIFY
10$:	BRW	ESCAPE_TERM

;
; THIS ROUTINE HANDLES LEFT JUSTIFIED FIELDS
;

LEFT_JUSTIFY:

	MOVZWL	TTY$W_RB_LINOFF(R4),R1		; GET CURRENT OFFSET INTO FIELD
;
;	TERMINATE IF ALREADY FIELD FULL - THIS CAN OCCUR ON A NON AUTOTAB
;	FIELD WHERE WE DEFER "FULL FIELD" COMPLETION UNTIL ONE MORE	
;	CHARACTER IS TYPED. CHAR TYPED IS TERMINATOR.			
;									
	CMPW	R1,TTY$W_RB_TXTOFF(R4)		; FIELD FULL?		
	BLSS	5$				; IF LSS, NOT YET	
	BRW	TERM				; YES - INPUT CHAR IS TERM 
5$:									

; Check to see if this character is valid in this position

	MOVZBL	@TTY$L_RB_PIC(R4)[R1],R0	; ADDRESS CORRESPONDING PIC VALUE
	BITB	R0,VERIFY_ARRAY[R3]		; CHAR VALID ?
	BNEQ	10$				; YES, 
	BRW	TERM				; ELSE TERMINATOR
10$:									
;									
;	UPCASE IF REQUESTED. 						
;									
	BBC	#TRM$V_TM_CVTLOW,TTY$L_RB_MOD(R4),13$; NO CONVERT THEN DON'T
	BBC	#TTY$V_CH_LOWER,W^TTY$A_TYPE[R3],13$; is this lower case?
	BICB	#^X20,R3			; yes MAKE LOWERCASE UPPER
13$:									
	MOVB	R3,@TTY$L_RB_TXT(R4)[R1]	; STORE INTO READ BUFFER
20$:
	INCW	R1				; POINT TO NEXT POSITION
	CMPW	R1,TTY$W_RB_TXTOFF(R4)		; FIELD FULL?
	BGEQ	FULL_1				; YES, WITH SINGLE CHARACTER

; Check for trailing marker characters to be skipped

	TSTB	@TTY$L_RB_PIC(R4)[R1]		; NEXT POSITION MARKER?
	BNEQ	OUTPUT_1			; NO, OUTPUT 1 CHARACTER

	DECL	R1				; POINT TO PREVIOUS POSITION
	MOVAB	@TTY$L_RB_TXT(R4)[R1],-		; SAVE ADDRESS OF STRING TO OUTPUT
		TTY$L_RB_ECHSTR(R4)
	MOVZBL	#1,R0				; INIT COUNT OF CHARACTERS IN STRING
30$:
	INCL	R1				; POINT TO NEXT POSITION
	CMPW	R1,TTY$W_RB_TXTOFF(R4)		; FIELD FULL
	BLSS	35$				; NO
	BRW	FULL_1				; YES, SO DON'T OUTPUT
						; TRAILING MARKERS
35$:
	TSTB	@TTY$L_RB_PIC(R4)[R1]		; NEXT SLOT A MARKER
	BNEQ	45$				; NO
	INCW	R0				; COUNT MARKERS
	BRB	30$				; CONTINUE LOOKING
45$:
	MOVB	R0,TTY$B_RB_ECHLEN(R4)		; SAVE STRING LENGTH
;	BRW	OUTPUT_S			; OUTPUT STRING

OUTPUT_S:					; OUTPUT A STRING
	MOVW	R1,TTY$W_RB_LINOFF(R4)		; SAVE NEW OFFSET
	IF_STATE NOECHO,DONE			; NOECHO THEN DON'T ECHO
	CLRW	TTY$W_RB_LINREST(R4)		; DON'T CHANGE CURSOR POSITION
	MOVZBW	#TTY$K_ER_RVECHO,TTY$W_RB_MODE(R4); SETUP TO ECHO
	SET_STATE EDITREAD			;...
	BRB	DONE				; THEN ALLOW THE CODE TO FLOW

OUTPUT_1:					; OUTPUT CHARACTER IN R3
	MOVW	R1,TTY$W_RB_LINOFF(R4)		; SAVE NEW OFFSET
	CMPB	R3,TTY$B_RB_RVFFIL(R4)		; USER TYPE FILLCHAR
	BNEQ	EXIT				; NO
	MOVB	TTY$B_RB_RVFCLR(R4),R3		; YES - REP W/CLR CHAR
	
EXIT:
	IF_STATE NOECHO,DONE			; NO EDCHO THEN DON'T ECHO
	POPL	R0
	BRW	FORMAT_CHAR			; FORMAT THE CHARACTER ELSEWISE

DONE:
	POPL	R0				; RESTORE R0
	BRW	TTY$GETNEXTCHAR			; AND GET THE NEXT CHARACTER
FULL_1:						; FIELD FULL, OUTPUT SINGLE CHARACTER
;									
;	IF NOT AUTOTAB, DONT END NOW - LET HIM HIT A CHAR		
;									
	BBC	#TRM$V_TM_AUTO_TAB,-					
		TTY$L_RB_MOD(R4),-					
		OUTPUT_1			; ECHO LAST CHAR	

	MOVW	R1,TTY$W_RB_LINOFF(R4)		; SAVE NEW OFFSET
	SET_STATE EOL				; TELL THEM WE ARE DONE
	MOVL	UCB$L_IRP(R5),R4		; GET IRP ADDRESS
	CLRL	IRP$L_MEDIA(R4)			; SIGNAL NO TERMINATOR
	BRB	EXIT

TERM:
	MOVW	R1,TTY$W_RB_LINOFF(R4)		; SAVE ENDING OFFSET
	IF_STATE NOFLTR,3$			; SKIP EDITING IF NOFLTR
	CMPB	#TTY$K_ET_DELEFT,TTY$A_CCLIST[R3]; IS THIS A DELETE CHARACTER
	BEQL	DELEFT_JUST			; YES THEN DELETE
3$:	IF_NOT_STATE ESCAPE,4$			; ESCAPE PROCESSING THEN
	CMPB	#TTY$K_ET_ESCAPE,TTY$A_CCLIST[R3]; ESCAPE ?
	BEQL	10$				; YES
4$:	SET_STATE EOL				; SET END OF LINE
5$:	MOVL	UCB$L_IRP(R5),R0
	MOVZBW	R3,IRP$L_MEDIA(R0)		; TERMINATOR
	MOVB	#1,IRP$L_MEDIA+2(R0)		; TERM LENGTH
	MOVB	R1,IRP$L_MEDIA+3(R0)		; OFFSET TO INVALID CHAR
	MOVZWL	TTY$W_RB_TXTOFF(R4),R1		; GET THE OFFSET TO THE END
						; OF THE BUFFER
	MOVAB	@TTY$L_RB_TXT(R4)[R1],TTY$L_RB_PIC(R4);SETUP THE END OF THE BUFFER
	MOVB	R3,@TTY$L_RB_PIC(R4)		; STORE IN BUFFER
	BRB	DONE
;
; SIGNAL ESCAPE SEQUENCE ACTIVE
;
10$:
	SET_STATE ESC
	PUSHL	R1			; SAVE R1
	BSBW	ESCINIT			; INIT THE ESCAPE SEQUENCE RULES
	MOVB	R1,UCB$B_TT_ESC(R5)	; ...
	POPL	R1			; RESTORE R1

	BRB	5$				; SKIP SETTING END
;
; DELETE ONE CHARACTER TO THE LEFT
;
;	R1 = offset into the line
;
DELEFT_JUST:
	CLRL	R0				; A COUNTER
	DECL	R1				; move left 1 character
	BLSS	100$				; NO CHARACTER TO DELETE THEN DON'T
10$:	INCL	R0				; MOVE BACK 1 CHARACTER
	TSTB	@TTY$L_RB_PIC(R4)[R1]		; IS THIS A MARKER?
	BNEQ	20$				; NO THEN SHIFT
	DECL	R1				; ELSE MOVE OVER IT
	BGEQ	10$				; NO NON-MARKER THEN IGNORE THE DEL
100$:	BRW	DONE				; ...

20$:	CMPW	TTY$W_RB_LINOFF(R4),TTY$W_RB_TXTOFF(R4); WERE WE ABOUT TO TERMINATE
	BNEQ	25$				; NO THEN PROCESS NORMALY
	MOVL	#1,R0				; ELSE ONLY GO BACK 1 PLACE
						; DUE TO SPECAIL EOF CONDITIONS
25$:	MOVW	R1,TTY$W_RB_LINOFF(R4)		; UPDATE THE OFFSET
	IF_STATE NOECHO,50$
	SUBW3	R0,UCB$W_TT_CURSOR(R5),TTY$W_RB_CPZCUR(R4); SET THE FINAL CURSOR
	MOVW	R0,UCB$W_TT_BSPLEN(R5)		; AND TELL HOW MANY CHARACTERS TO
						; BACKSPACE OVER
	SET_STATE <BACKSPACE,EDITREAD>		; THEN OUTPUT OTHER STUFF AND RETURN
	MOVAB	@TTY$L_RB_TXT(R4)[R1],TTY$L_RB_ECHSTR(R4); GET THE ADDRESS OF WHERE TO START OUTPUTTING
	MOVB 	#1,TTY$B_RB_ECHLEN(R4)		; THE LENGTH OF THE STRING TO OUTPUT
	MOVZBW	#TTY$K_ER_RVECHO,TTY$W_RB_MODE(R4); SET THE MODE OF THE EDITING
	MOVL	#1,TTY$W_RB_LINREST(R4)		; TELL THE MOVE TO RESTORE THE POSITION

50$:	MOVB	TTY$B_RB_RVFFIL(R4),@TTY$L_RB_TXT(R4)[R1]; AND FILL THE BLANK
						; WITH THE FILL CHARACTER
	BRW	DONE

RIGHT_JUSTIFY:

	CVTWL	TTY$W_RB_LINOFF(R4),R1		; GET CURRENT OFFSET
	BGEQ	3$				; IF WE ARE BEOND THE
						; BOUNDARY THEN TERMINATE
	BRW	RIGHT_TERM
3$:
	MOVZBL	@TTY$L_RB_PIC(R4)[R1],R0	; GET PICTURE VALUE
	BNEQ	5$				; NOT A MARKER
	DECL	R1				; CHECK FOR END
	BGEQ	3$				; NOT YET
	CLRL	R1					
	MOVW	R1,TTY$W_RB_LINOFF(R4)		; SAVE CURRENT OFFSET
	BRW	FIELD_FULL			; FULL OF MARKERS
5$:
	BITB	R0,VERIFY_ARRAY[R3]		; IS THIS CHARACTER VALID HERE
	BNEQ	10$				; OK
	BRW	RIGHT_TERM		
;
; SHIFT DATA IN INPUT FIELD
;
10$:
	MOVW	R1,TTY$W_RB_LINOFF(R4)		; SAVE CURRENT OFFSET

	CLRL	R1				; INIT DESTINATION POINTER

; FIND FIRST VALID DESTINATION

20$:
	TSTB	@TTY$L_RB_PIC(R4)[R1]		; MARKER?
	BNEQ	30$				; NO, POSITION IS OK
	INCL	R1				; LOOK FOR NEW DESTINATION
	CMPW	R1,TTY$W_RB_TXTOFF(R4)		; PAST END?
	BLSSU	20$				; NO, IT IS STILL OK
	BRW	FIELD_FULL
30$:
;									
; IF NONCLR CHAR IN LEFTMOST DATA POSITION, FIELD IS ALREADY FULL, MUST
;	BE NON-AUTOTAB. TERMINATE WITH OVERFLOWING CHAR			
;									
	CMPB	@TTY$L_RB_TXT(R4)[R1],TTY$B_RB_RVFFIL(R4);THIS A CLR CHAR?
	BEQL	35$ 				;YES - NOT FULL YET 	
	MOVW	TTY$W_RB_TXTOFF(R4),- 		;SHOW OVERFLOW OFFSET	
		TTY$W_RB_LINOFF(R4)		;IF FIELD FULL		
	BRB	RIGHT_TERM			; AND QUIT		
35$:
	PUSHL	R1				;SAVE OFFSET TO LEFT BYTE

	MOVL	R1,R0				; INIT SOURCE POINTER

; FIND NEW SOURCE

40$:
	INCL	R0
	CMPW	R0,TTY$W_RB_LINOFF(R4)		; PAST END?
	BGTRU	100$				; YES THEN SHIFT COMPLETE
	TSTB	@TTY$L_RB_PIC(R4)[R0]		; MARKER?
	BEQL	40$				; YES, LOOK AGAIN
	MOVB	@TTY$L_RB_TXT(R4)[R0],@TTY$L_RB_TXT(R4)[R1]; SHIFT THE DATA
	MOVL	R0,R1				; OLD SOURCE IS NEW DESTINATION
	BRB	40$

; SHIFT COMPLETE

100$:
;									
;	UPCASE IF REQUESTED. 						
;									
	BBC	#TRM$V_TM_CVTLOW,-		; SKIP IF UPCASE NOT	
		TTY$L_RB_MOD(R4),105$ 		;	REQUESTED	
	BBC	#TTY$V_CH_LOWER,W^TTY$A_TYPE[R3],105$; is this lower case?
	BICB	#^X20,R3			; yes MAKE LOWERCASE UPPER
105$:

	MOVB	R3,@TTY$L_RB_TXT(R4)[R1]	; STORE NEW CHARACTER INTO
						; END POSITION
	POPL	R1				; GET START POSITION
	CMPB	@TTY$L_RB_TXT(R4)[R1],TTY$B_RB_RVFCLR(R4);START WITH CLR CHAR?
	BEQL	RIGHT_ECHO			;YES - FLD NOT FULL
	BBC	#TRM$V_TM_AUTO_TAB,-		;FLD FULL - NONAUTOTAB
		TTY$L_RB_MOD(R4),RIGHT_ECHO	; JUST ECHO
						;FLD FULL - AUTOTAB
						; FALL THROUGH


FIELD_FULL:
	SET_STATE EOL
10$:
	MOVL	UCB$L_IRP(R5),R1		; GET IRP ADDRESS
	CLRL	IRP$L_MEDIA(R1)			; SIGNAL NO TERMINATOR

RIGHT_ECHO:
	CLRW	UCB$W_TT_CURSOR(R5)
	IF_STATE NOECHO,GODONE			; NO ECHO THEN DON'T ECHO
	POPL	R0
	CLRW	TTY$W_RB_LINREST(R4)
	MOVZBW	#TTY$K_ER_RVECHO,TTY$W_RB_MODE(R4); ECHO THE LINE
	MOVAB	TTY$A_RB_PRM(R4),TTY$L_RB_ECHSTR(R4); THE ADDRESS OF THE STRING
	ADDB3	TTY$W_RB_PRMLEN(R4),TTY$W_RB_LINOFF(R4),-; GET THE LENGTH TO ECHO
		TTY$B_RB_ECHLEN(R4)		;...
	INCB	TTY$B_RB_ECHLEN(R4)		; ACCOUNT FOR ZERO BASE
	SET_STATE EDITREAD
	BRW	EDITREAD

.ENABLE	LSB

RIGHT_TERM:
	IF_STATE NOFLTR,3$			; SKIP EDITING IF NOFLTR
	CMPB	#TTY$K_ET_DELEFT,TTY$A_CCLIST[R3]; IS THIS A DELETE CHARACTER
	BEQL	DELRIGHT_JUST			; YES THEN DELETE
3$:	IF_NOT_STATE ESCAPE,4$			; ESCAPE PROCESSING THEN
	CMPB	#TTY$K_ET_ESCAPE,TTY$A_CCLIST[R3]; ESCAPE ?
	BEQL	10$				; YES
4$:	MOVW	TTY$W_RB_TXTOFF(R4),UCB$W_BCNT(R5); FILL REQUIRED FIELD
	SET_STATE <EOL>				; SET END OF LINE
5$:	
	MOVL	UCB$L_IRP(R5),R1		; GET IRP ADDRESS
	MOVZBW	R3,IRP$L_MEDIA(R1)		; TERMINATOR
	MOVB	#1,IRP$L_MEDIA+2(R1)		; TERM LENGTH
	MOVB	TTY$W_RB_LINOFF(R4),-
		IRP$L_MEDIA+3(R1)		; OFFSET TO INVALID CHAR
	MOVZWL	TTY$W_RB_TXTOFF(R4),R1		; GET THE ADDRESS OF THE END
	MOVAB	@TTY$L_RB_TXT(R4)[R1],TTY$L_RB_PIC(R4);OF THE INITIAL STRING
	MOVB	R3,@TTY$L_RB_PIC(R4)		; AND STORE THE CHARACTER THERE
GODONE:	BRW	DONE				; THEN EXIT
;
; SIGNAL ESCAPE SEQUENCE ACTIVE
;
10$:
	SET_STATE ESC				; ANNOUNCE ESCAPE STATE
	PUSHL	R1			; SAVE R1
	BSBW	ESCINIT			; INIT THE ESCAPE SEQUENCE RULES
	MOVB	R1,UCB$B_TT_ESC(R5)	; ...
	POPL	R1			; RESTORE R1

	BRB	5$				; SKIP SETTING END

	.DISABLE LSB
;
; DELETE RIGHT JUSTIFYED
;
DELRIGHT_JUST:
	MOVL	R1,R0			; GET THE CURRENT LOCATION
10$:	DECL	R0			; MOVE RIGHT 1 CHARACTER
	BLSS	20$			; ECHO THE LINE
	TSTB	@TTY$L_RB_PIC(R4)[R0]	; IS THIS A MARKER?
	BEQL	10$			; YES THEN SKIP IT
	MOVB	@TTY$L_RB_TXT(R4)[R0],-	; MOVE THE CHARACTER
		@TTY$L_RB_TXT(R4)[R1]
	MOVL	R0,R1
	BRB	10$

20$:	MOVB	TTY$B_RB_RVFFIL(R4),-	; MOVE A FILL CHARACTER FROM THE LEFT
		@TTY$L_RB_TXT(R4)[R1]
	BRW	RIGHT_ECHO		; NOW ECHO THE CHARACTER

	.SBTTL	READ VERIFY ESCAPE TERMINATOR ROUTINE
;++
; DESCRIPTION:
;	CALLED ON ALL THE CHARACTERS FOLLOWING THE ESCAPE
;
; INPUTS:
;
;	R2 - UNIT STATE VECTOR
;	R4 - ADDRESS OF THE READ BUFFER
;	R5 - UCB ADDRESS
;
; IMPLICIT INPUTS:
;
;	IRP$L_MEDIA+2 - CURRENT OFFSET TO IN THE BUFFER (ACCESSED AS A BYTE)
;	TTY$L_RB_PIC  - THE ADDRESS OF THE ESCAPE CHARACTER IN THE BUFFER
;	TTY$W_RB_TXTSIZ - LENGTH OF THE USERS BUFFER
;--
ESCAPE_TERM:
	MOVL	UCB$L_IRP(R5),R0		; GET IRP ADDRESS
	MOVZBL	IRP$L_MEDIA+2(R0),R1		; GET CURRENT OFFSET

	CMPW	R1,TTY$W_RB_TXTSIZ(R4)		; DO WE HAVE ROOM FOR THIS
	BGEQU	30$				;NO THEN TELL THEM ABOUT IT
	MOVB	R3,@TTY$L_RB_PIC(R4)[R1]	; STORE THE DATA
	INCB	IRP$L_MEDIA+2(R0)		; BUMP TERM LENGTH

	BSBW	ESCSYNTAX			; PARSE ESCAPE SEQUENCE
	BGTR	10$				; SEQUENCE OK, CONTINUE
	BLSS	20$				; SEQUENCE ERROR

; SEQUENCE COMPLETED NORMALLY
	CLR_STATE ESC				; CLEAR THE ESCAPE STATE THEN
	
30$:	SET_STATE EOL				; SET END OF LINE
10$:
	BRW	DONE

20$:						; ESCAPE SEQ ERROR
	SET_STATE BADESC			; TELL THE WORLD
	BRB	30$

	.SBTTL	End of module
TT_END:
	.END
