%TITLE 'NDXVMS -- DSRINDEX/INDEX Command line interface'
MODULE NDXVMS	(IDENT = 'V04-000', LANGUAGE (BLISS32),
		ADDRESSING_MODE (EXTERNAL    = LONG_RELATIVE, 
				 NONEXTERNAL = LONG_RELATIVE)
		) =

BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY:
!   DSR (Digital Standard RUNOFF) /DSRPLUS DSRINDEX/INDEX Utility
!
! ABSTRACT:
!
!	This module is the INDEX command line interface module.
!
!	Much of the code to parse and validate qualifier
!	values may be removed when the VMS CLI interface routines
!	implement value validation.
!
! ENVIRONMENT:	 VAX/VMS User Mode
!
! AUTHOR:	 JPK
!
! CREATION DATE: February-1982
!
! MODIFIED BY:
!
!	012	JPK00023	20-May-1983
!		Modified INDEX, NDXT20 and NDXVMS to check status of
!		$XPO_PARSE_SPEC to avoid error messages from XPORT.
!
!	011	JPK00022	30-Mar-1983
!		Modified NDXVMS, NDXFMT, NDXPAG, NDXVMSMSG and NDXVMSREQ 
!		to generate TEX output. Added module NDXTEX.
!
!	010	JPK00019	14-MAR-1983
!		Modified NDXVMS to conditionalize /PAGE_NUMBERS=[NO]MERGE
!		and /PAGE_NUMBERS=STANDARD for DSRPLUS only.
!
!	009	JPK00016	23-Feb-1983
!		Modified NDXVMS to change the default number of lines per page 
!		when /TELLTALE is specified but /LINES is not.
!
!	008	JPK00015	04-Feb-1983
!		Cleaned up module names, modified revision history to
!		conform with established standards. Updated copyright dates.
!
!	007	JPK00013	31-Jan-1983
!		Changed default subindex level value from 6 to 99 in NDXVMS
!		and NDXCLIDMP. This value is the subindexing level. 
!		It is NOT A HEADER LEVEL.
!
!	006	JPK00012	24-Jan-1983
!		Modified NDXVMSMSG.MSG to define error messages for both
!		DSRINDEX and INDEX.
!		Added require of NDXVMSREQ.R32 to NDXOUT, NDXFMT, NDXDAT,
!		INDEX, NDXMSG, NDXXTN, NDXTMS, NDXVMS and NDXPAG for BLISS32. 
!		Since this file defines the error message literals, 
!		the EXTERNAL REFERENCEs for the error message literals 
!		have been removed.
!
!	005	JPK00011	24-Jan-1983
!		Changed CMDBLK [NDX$G_LEVEL] to CMDBLK [NDX$H_LEVEL]
!		Changed CMDBLK [NDX$H_FORMAT] to CMDBLK [NDX$H_LAYOUT]
!		Changed CMDBLK [NDX$V_TMS11] and CMDBLK [NDX$V_TEX] to CMDBLK [NDX$H_FORMAT]
!		Changed comparisons of (.CHRSIZ EQLA CHRSZA) to 
!		(.CMDBLK [NDX$H_FORMAT] EQL TMS11_A).
!		Definitions were changed in NDXCLI and references to the
!		effected fields were changed in NDXPAG, NDXFMT, INDEX, NDXVMS
!		and NDXCLIDMP.
!
!	004	RER00002	20-Jan-1983
!		Modified VMS command line interface module NDXVMS:
!		  - changed /FORMAT qualifier to /LAYOUT.
!		  - changed use of /RESERVE and /REQUIRE for DSRPLUS.
!		  - added code for new DSRPLUS qualifiers /FORMAT and
!		    /TELLTALE_HEADINGS. 
!		Added fields to NDXCLI for new qualifiers: NDX$V_TELLTALE 
!		and NDX$V_TEX.
!		Conditionalized output of NDX$V_PAGE_MERGE in NDXCLIDMP to 
!		account for different DSR and DSRPLUS default values.
!
!	003	RER00001	17-Dec-1982
!		Modified VMS command line interface module NDXVMS:
!		  - Added code to treat keyword NORUNNING in same way as
!		    keyword STANDARD.
!		  - Added code for new DSR qualifiers /RESERVE and /REQUIRE.
!		  - Changed header level default value from 99 to 6.
!		  - Conditionalized code to compile for DSRPLUS if BLISS
!		    /VARIANT = 8192 is used; otherwise, to compile for DSR.
!		  - Deleted foreign-command code; INDEX is now called
!		    as a subcommand of DSR.
!
!	002	JPK00001	13-Aug-1982
!		Removed reference to CLI$END_PARSE in NDXVMS. It is no longer 
!		supported by VMS.
!
!--

!
! INCLUDE FILES:
!
LIBRARY 'SYS$LIBRARY:STARLET.L32';	! System macro library

LIBRARY 'SYS$LIBRARY:TPAMAC.L32';	! TPARSE macros

LIBRARY 'SYS$LIBRARY:XPORT';		! Transportable BLISS library

SWITCHES LIST (REQUIRE);		! Print require files

REQUIRE 'REQ:NDXCLI';			! Command line information block

REQUIRE 'REQ:NDXVMSREQ';			! Error message definitions

SWITCHES LIST (NOREQUIRE);

!
! TABLE OF CONTENTS:
!

FORWARD ROUTINE
    NDXCLI,			! Command line interface
    CONDITION_HANDLER,		! Main program condition handler - sets return status
    CALL_TPARSE,		! Invoke TPARSE to parse qualifier values
    ENTER_PAGE,			! Action routine - enter page number type 
    OPEN_ERROR;			! Report file open errors

%IF DSRPLUS
%THEN

FORWARD ROUTINE
    ENTER_MERGE,		! Action routine - enter page range merge
    ENTER_LAYOUT,		! Action routine - enter /LAYOUT value
    ENTER_FORMAT,		! Action routine - enter /FORMAT value
    ENTER_SORT,			! Action routine - enter sort type
    ENTER_ALPHA,		! Action routine - enter nonalpha sort 
    OPTIONS_FILE : NOVALUE,	! Process options file
    PARSE_BOOK   : NOVALUE,	! Process /BOOK_IDENTIFIER qualifier
    PROCESS_TEX_FILE : NOVALUE,	! Process TEX character size file
    STORE_TEX,			! Action routine - store TEX character size
    READ_TEX;			! Action routine - read a line from TEX char file

%FI

!
! EQUATED SYMBOLS:
!

LITERAL
    TRUE  = 1,
    FALSE = 0;

!
! OWN STORAGE:
!

OWN
    VALUE_STR	: $STR_DESCRIPTOR (CLASS = DYNAMIC, STRING = (0, 0)),
    OPTIONS_STR	: $STR_DESCRIPTOR (CLASS = DYNAMIC, STRING = (0, 0)),
    QUALIFIER_VALUE,
    TERMINATION_STATUS : INITIAL (STS$K_SUCCESS);

%IF DSRPLUS
%THEN

OWN
    TEX_FILE_NAME : $STR_DESCRIPTOR (CLASS = DYNAMIC, STRING = (0, 0)),
    TEX_CHAR_SIZES : VECTOR [256],		! Where character sizes are stroed
    TEX_CHAR_INDEX,				! Index into TEX_CHAR_SIZES
    TEX_FILE_LINE_NO,				! Line number of file
    TEX_LINE : $STR_DESCRIPTOR (),		! Descriptor of input line
    TEX_IN_BUF : BLOCK [512, BYTE],		! Input buffer
    TEX_ES : BLOCK [NAM$C_MAXRSS, BYTE],	! Expanded filename string
    TEX_RS : BLOCK [NAM$C_MAXRSS, BYTE],	! Resultant filename string
    TEX_NAM : $NAM (ESA = TEX_ES, ESS = NAM$C_MAXRSS, RSA = TEX_RS, RSS = NAM$C_MAXRSS),
    TEX_FAB : $FAB (NAM = TEX_NAM, DNM = '.FSZ'),
    TEX_RAB : $RAB (FAB = TEX_FAB, UBF = TEX_IN_BUF, USZ = 512);

%FI

!
! EXTERNAL REFERENCES:
!

EXTERNAL LITERAL
    TAB : UNSIGNED (8),		! TAB character
    TMSCOL,			! Default TMS column width
    MAXLIN;			! Maximum number of lines per page

EXTERNAL LITERAL		! Values returned from CLI interface
    CLI$_CONCAT,		! Value concatenated to next
    CLI$_PRESENT,		! Value explicitly given
    CLI$_NEGATED,		! Value explicitly negated (/NO)
    CLI$_DEFAULTED,		! Value defaulted present
    CLI$_ABSENT;		! Value not present

EXTERNAL
    CMDBLK : $NDXCMD,		! Command line information block
    CHRSIZ : REF VECTOR,	! TMS character size vector pointer
    CHRSZA : VECTOR,		! Character size vector for /TMS11 = A
    CHRSZE : VECTOR,		! Character size vector for /TMS11 = E
    NDXVRL,			! Length of version number string
    NDXVRP;			! CH$PTR to version number string

EXTERNAL ROUTINE
    NDXINI          : NOVALUE,				! Once only initialization
    NDXINP          : NOVALUE,				! Process input file
    MAKNDX          : NOVALUE,				! Generate index
    CLI$PRESENT     : ADDRESSING_MODE (GENERAL),	! Check for qualifier
    CLI$GET_VALUE   : ADDRESSING_MODE (GENERAL),	! Get value of qualifier
    LIB$TPARSE      : ADDRESSING_MODE (GENERAL);	! Table driven parser

%IF DSRPLUS
%THEN

EXTERNAL
    NDXOPTION;			! Options file parse tables address

EXTERNAL ROUTINE
    CLI$DCL_PARSE   : ADDRESSING_MODE (GENERAL);	! Initiate new parse

%FI

!+
!   TPARSE state tables
!-

!
! Tables to parse an arbitrary number
!
$INIT_STATE (NUMBER_STATE, NUMBER_KEY);
$STATE (,
    (TPA$_DECIMAL, ,           ,             , QUALIFIER_VALUE),
    (TPA$_EOS,     TPA$_EXIT)
    );
$STATE (,
    (TPA$_EOS,     TPA$_EXIT)
    );

!
! Tables to parse /PAGE_NUMBERS values
!
$INIT_STATE (PAGE_STATE, PAGE_KEY);
$STATE (, 

%IF DSRPLUS
%THEN

    ('MERGE',      ,           ENTER_MERGE,  , ,                TRUE),
    ('NOMERGE',    ,           ENTER_MERGE,  , ,                FALSE),
    ('STANDARD',   ,           ENTER_PAGE,   , ,                TRUE),

%FI

    ('RUNNING',    ,           ENTER_PAGE,   , ,                FALSE),
    ('NORUNNING',  ,           ENTER_PAGE,   , ,                TRUE)
    );
$STATE (,
    (TPA$_EOS,     TPA$_EXIT)
    );

%IF DSRPLUS
%THEN

!
! Tables to parse /FORMAT values
!
$INIT_STATE (FORMAT_STATE, FORMAT_KEY);
$STATE (,
    ('DSR',        FORMAT_END, ENTER_FORMAT, , ,                DSR),
    ('TEX',        TEX_STATE),
    ('TMS',        TMS_STATE)
    );
$STATE (TEX_STATE,
    ('=',          TPA$_EXIT,  ENTER_FORMAT, , ,                TEX),
    (':',          TPA$_EXIT,  ENTER_FORMAT, , ,                TEX)
    );
$STATE (TMS_STATE,
    ('='),
    (':'),
    (TPA$_EOS,     TPA$_EXIT,  ENTER_FORMAT, , ,                TMS11_A)
    );
$STATE (,
    ('A',          FORMAT_END, ENTER_FORMAT, , ,                TMS11_A),
    ('E',          FORMAT_END, ENTER_FORMAT, , ,                TMS11_E)
    );
$STATE (FORMAT_END,
    (TPA$_EOS,     TPA$_EXIT)
    );

!
! Tables to parse /LAYOUT values
!
$INIT_STATE (LAYOUT_STATE, LAYOUT_KEY);
$STATE (,
    ('TWO_COLUMN', LAYOUT_END, ENTER_LAYOUT, , ,                TWO_COLUMN),
    ('2',          LAYOUT_END, ENTER_LAYOUT, , ,                TWO_COLUMN),
    ('ONE_COLUMN', LAYOUT_END, ENTER_LAYOUT, , ,                ONE_COLUMN),
    ('1',          LAYOUT_END, ENTER_LAYOUT, , ,                ONE_COLUMN),
    ('GALLEY',     LAYOUT_END, ENTER_LAYOUT, , ,                GALLEY),
    ('SEPARATE',   ,           ENTER_LAYOUT, , ,                SEPARATE)
    );
$STATE (,
    ('='),
    (':'),
    (TPA$_EOS,     TPA$_EXIT)
    );
$STATE (,
    (TPA$_DECIMAL, LAYOUT_END, ,             , QUALIFIER_VALUE)
    );
$STATE (LAYOUT_END,
    (TPA$_EOS,     TPA$_EXIT)
    );

!
! Tables to parse /SORT values
!
$INIT_STATE (SORT_STATE, SORT_KEY);
$STATE (,
    ('WORD',       SORT_END,   ENTER_SORT,   , ,                TRUE),
    ('LETTER',     SORT_END,   ENTER_SORT,   , ,                FALSE),
    ('NONALPHA')
    );
$STATE (,
    ('='),
    (':')
    );
$STATE (,
    ('IGNORE',     SORT_END,   ENTER_ALPHA,  , ,                IGNORE),
    ('BEFORE',     SORT_END,   ENTER_ALPHA,  , ,                BEFORE),
    ('AFTER',      SORT_END,   ENTER_ALPHA,  , ,                AFTER)
    );
$STATE (SORT_END,
    (TPA$_EOS,     TPA$_EXIT)
    );

!
! Tables to parse TEX character size file
!
$INIT_STATE (TEX_FILE_STATE, TEX_FILE_KEY);
$STATE (TEX_1,
    ('!',          TEX_1,      READ_TEX),
    (TPA$_EOS,     TEX_1,      READ_TEX),
    (TPA$_DECIMAL, TEX_2,      STORE_TEX)
    );
$STATE (TEX_2,
    (',',          TEX_1),
    ('!',          TEX_2,      READ_TEX),
    (TPA$_EOS,     TEX_2,      READ_TEX)
    );

%FI

%SBTTL 'NDXCLI -- Main program - command line interface'
GLOBAL ROUTINE NDXCLI =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine uses the VMS DCL CLE to obtain command
!	line information which is in turn passed to the INDEX
!	application in a transportable manner.
!
! FORMAL PARAMETERS:
!
!	None
!
! IMPLICIT INPUTS:
!
!	None
!
! IMPLICIT OUTPUTS:
!
!	CMDBLK - The command line information block is filled in
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	TERMINATION_STATUS	- Set by CONDITION_HANDLER ()
!
! SIDE EFFECTS:
!
!	None
!
!--

    BEGIN

    ENABLE
	CONDITION_HANDLER;

    LOCAL
	STATUS;

    NDXINI ();			! Do once-only initialization

    !
    ! Get copy of whole command line
    !
    CLI$GET_VALUE (%ASCID'$LINE', CMDBLK [NDX$T_COMMAND_LINE]);

    !
    ! /[NO]MASTER
    !
    !			* W A R N I N G *
    !
    !		This must be parsed before other qualifiers.
    !		Other qualifiers depend on the value of this qualifier.
    !
    !			* W A R N I N G *
    !
    CMDBLK [NDX$V_MASTER] = FALSE;

%IF DSRPLUS
%THEN

    IF  CLI$PRESENT (%ASCID'MASTER')
    THEN
	CMDBLK [NDX$V_MASTER] = TRUE;
%FI

    !
    ! /FORMAT = { DSR | TEX : filename | TMS11 [ = { A | E }] }
    !
    !			* W A R N I N G *
    !
    !		This must be parsed before other qualifiers.
    !		Other qualifiers depend on the value of this qualifier.
    !
    !			* W A R N I N G *
    !
    CMDBLK [NDX$H_FORMAT] = DSR;	! Assume output for RUNOFF
    CHRSIZ                = CHRSZA;	! Assume TMS11 type 'A' characters

%IF DSRPLUS
%THEN

    IF  CLI$PRESENT (%ASCID'FORMAT')
    THEN
	BEGIN
	CLI$GET_VALUE (%ASCID'FORMAT', VALUE_STR);

	IF  NOT CALL_TPARSE (VALUE_STR, FORMAT_STATE, FORMAT_KEY)
	THEN
	    SIGNAL_STOP (INDEX$_BADVALUE, 1, VALUE_STR);

	IF .CMDBLK [NDX$H_FORMAT] EQL TEX THEN PROCESS_TEX_FILE ();
	END;

%FI

    !
    ! /COLUMN_WIDTH = n
    !
    !			* W A R N I N G *
    !
    !		This must be parsed after /FORMAT and before any other
    !		qualifier. It depends on the value of /FORMAT and other
    !		qualifiers depend on the value of this qualifier.
    !
    !			* W A R N I N G *
    !
    CMDBLK [NDX$G_COLUMN_WID] = 34;		! Default column width is 34

%IF DSRPLUS
%THEN

    IF  CLI$PRESENT (%ASCID'COLUMN_WIDTH')
    THEN
	BEGIN
	QUALIFIER_VALUE = 0;
	CLI$GET_VALUE (%ASCID'COLUMN_WIDTH', VALUE_STR);

	IF  NOT CALL_TPARSE (VALUE_STR, NUMBER_STATE, NUMBER_KEY)
	THEN
	    SIGNAL_STOP (INDEX$_BADVALUE, 1, VALUE_STR);

	CMDBLK [NDX$G_COLUMN_WID] = .QUALIFIER_VALUE;

	IF  .CMDBLK [NDX$G_COLUMN_WID] LSS 5
	THEN
	    SIGNAL_STOP (INDEX$_BADVALUE, 1, VALUE_STR, INDEX$_VALERR);

	END
    ELSE
	BEGIN

	IF .CMDBLK [NDX$H_FORMAT] NEQ DSR
	THEN
	    !
	    ! Typeset column width default is defined by the literal TMSCOL
	    !
	    CMDBLK [NDX$G_COLUMN_WID] = TMSCOL;

	END;

%FI

    !
    ! /LAYOUT = { TWO_COLUMN | ONE_COLUMN | GALLEY | SEPARATE [= n] }
    !
    !			* W A R N I N G *
    !
    !		This must be parsed after /COLUMN_WIDTH and before any other
    !		qualifier. It depends on the value of /COLUMN_WIDTH and other
    !		qualifiers depend on the value of this qualifier.
    !
    !			* W A R N I N G *
    !
    CMDBLK [NDX$H_LAYOUT]         = TWO_COLUMN;	! Default index layout
    CMDBLK [NDX$G_SEPARATE_WIDTH] = .CMDBLK [NDX$G_COLUMN_WID];

%IF DSRPLUS
%THEN

    IF  CLI$PRESENT (%ASCID'LAYOUT')
    THEN
	BEGIN
	QUALIFIER_VALUE = -1;
	CLI$GET_VALUE (%ASCID'LAYOUT', VALUE_STR);

	IF  NOT CALL_TPARSE (VALUE_STR, LAYOUT_STATE, LAYOUT_KEY)
	THEN
	    SIGNAL_STOP (INDEX$_BADVALUE, 1, VALUE_STR);

	IF  .QUALIFIER_VALUE NEQ -1
	THEN
	    BEGIN
	    !
	    ! Doing SEPARATE index and user specified reference column width.
	    ! Validate against minimum column width.
	    !

	    IF  .QUALIFIER_VALUE LSS 5
	    THEN
		SIGNAL_STOP (INDEX$_BADVALUE, 1, VALUE_STR, INDEX$_VALERR);

	    CMDBLK [NDX$G_SEPARATE_WIDTH] = .QUALIFIER_VALUE;
	    END;

	END;

    IF  (.CMDBLK [NDX$H_FORMAT] EQL TEX)
    AND (.CMDBLK [NDX$H_LAYOUT] NEQ TWO_COLUMN)
    THEN
	BEGIN

	LOCAL
	    FORMAT_PTR;

	FORMAT_PTR = (
	    SELECTONE .CMDBLK [NDX$H_LAYOUT] OF
		SET

		[ONE_COLUMN]:	%ASCID 'ONE_COLUMN';
		[GALLEY]:	%ASCID 'GALLEY';
		[SEPARATE]:	%ASCID 'SEPARATE';

		TES
	    );

	SIGNAL_STOP (INDEX$_BADVALUE, 1, .FORMAT_PTR, INDEX$_CONFQUAL);
	END;

%FI

    !
    ! /[NO]TELLTALE_HEADINGS
    !
    !			* W A R N I N G *
    !
    !		This must be parsed after /LAYOUT and before /LINES_PER_PAGE
    !		It depends on the value of /LAYOUT and /LINES_PER_PAGE
    !		depends on the value of this qualifier.
    !
    !			* W A R N I N G *
    !
    CMDBLK [NDX$V_TELLTALE] = FALSE;

%IF DSRPLUS
%THEN

    IF  CLI$PRESENT (%ASCID'TELLTALE_HEADINGS')
    THEN
	BEGIN

	IF  .CMDBLK [NDX$H_LAYOUT] EQL GALLEY
	THEN
	    !
	    ! Doing TMS11 galley output.
	    ! Telltale headings are not allowed
	    !
	    SIGNAL (INDEX$_IGNORED, 1, %ASCID'TELLTALE_HEADINGS', INDEX$_CONFQUAL)
	ELSE
	    CMDBLK [NDX$V_TELLTALE] = TRUE;

	END;

%FI

    !
    ! /LINES_PER_PAGE = n
    !
    !			* W A R N I N G *
    !
    !		This must be parsed after /FORMAT, /LAYOUT and 
    !		/TELLTALE_HEADINGS. It depends on the value of these qualifiers
    !
    !			* W A R N I N G *
    !
    IF .CMDBLK [NDX$H_FORMAT] EQL DSR
    THEN
	BEGIN					! Formatting for RUNOFF

	IF .CMDBLK [NDX$V_TELLTALE]
	THEN
	    CMDBLK [NDX$G_LINES_PAGE] = 52	! 52 lines with /TELLTALE
	ELSE
	    CMDBLK [NDX$G_LINES_PAGE] = 55;	! 55 lines per page otherwise

	END
    ELSE
	CMDBLK [NDX$G_LINES_PAGE] = 54;		! 54 lines per page for Typeset

    IF  CLI$PRESENT (%ASCID'LINES_PER_PAGE')
    THEN
	BEGIN
	!
	! User specified a value
	!

	IF  .CMDBLK [NDX$H_LAYOUT] EQL GALLEY
	THEN
	    !
	    ! Galley output - ignore lines-per-page
	    !
	    SIGNAL (INDEX$_IGNORED, 1, %ASCID'LINES_PER_PAGE', INDEX$_CONFQUAL)
	ELSE
	    BEGIN
	    QUALIFIER_VALUE = 0;
	    CLI$GET_VALUE (%ASCID'LINES_PER_PAGE', VALUE_STR);

	    IF  NOT CALL_TPARSE (VALUE_STR, NUMBER_STATE, NUMBER_KEY)
	    THEN
		SIGNAL_STOP (INDEX$_BADVALUE, 1, VALUE_STR);

	    CMDBLK [NDX$G_LINES_PAGE] = .QUALIFIER_VALUE;

	    IF  (
		(.CMDBLK [NDX$G_LINES_PAGE] LSS 15) 
		AND (.CMDBLK [NDX$H_FORMAT] EQL DSR)
		)
	    OR  (
		(.CMDBLK [NDX$G_LINES_PAGE] LSS 25)
		AND (.CMDBLK [NDX$H_FORMAT] NEQ DSR)
		)
	    OR  (.CMDBLK [NDX$G_LINES_PAGE] GTR MAXLIN)
	    THEN
		SIGNAL_STOP (INDEX$_BADVALUE, 1, VALUE_STR, INDEX$_VALERR);

	    END;

	END;

    !
    ! /GUTTER_WIDTH = n
    !
    !			* W A R N I N G *
    !
    !		This qualifier depends on the value of /LAYOUT
    !
    !			* W A R N I N G *
    !
    CMDBLK [NDX$G_GUTTER_WID] = 2;

%IF DSRPLUS
%THEN

    IF  (.CMDBLK [NDX$H_LAYOUT] EQL ONE_COLUMN) OR
	(.CMDBLK [NDX$H_LAYOUT] EQL GALLEY)
    THEN
	BEGIN
	!
	! ONE_COLUMN output which is not a separate master index
	! or GALLEY output
	!
	CMDBLK [NDX$G_GUTTER_WID] = 0;		! Gutter width is meaningless

	IF  CLI$PRESENT (%ASCID'GUTTER_WIDTH')
	THEN
	    SIGNAL (INDEX$_IGNORED, 1, %ASCID'GUTTER_WIDTH', INDEX$_CONFQUAL);

	END
    ELSE
	BEGIN
	!
	! For all other page layouts
	!
	QUALIFIER_VALUE = 2;			! Default value

	IF  CLI$PRESENT (%ASCID'GUTTER_WIDTH')
	THEN
	    BEGIN
	    CLI$GET_VALUE (%ASCID'GUTTER_WIDTH', VALUE_STR);

	    IF  NOT CALL_TPARSE (VALUE_STR, NUMBER_STATE, NUMBER_KEY)
	    THEN
		SIGNAL_STOP (INDEX$_BADVALUE, 1, VALUE_STR);

	    END;

	CMDBLK [NDX$G_GUTTER_WID] = .QUALIFIER_VALUE;
	END;

%FI

    !
    ! Validate the combinations of column width, gutter width, and 
    ! right column width for master indexes.
    !
    !			* W A R N I N G *
    !
    !		This code depends on the value of /LAYOUT, /COLUMN_WIDTH
    !		and /GUTTER_WIDTH
    !
    !			* W A R N I N G *
    !
    SELECTONE .CMDBLK [NDX$H_LAYOUT] OF
    SET

    [TWO_COLUMN]:

	IF  (2 * .CMDBLK [NDX$G_COLUMN_WID]) + 
	    .CMDBLK [NDX$G_GUTTER_WID] GTR 120
	THEN
	    SIGNAL_STOP (INDEX$_LINELENG);

    [SEPARATE]:

	IF  .CMDBLK [NDX$G_COLUMN_WID] +
	    .CMDBLK [NDX$G_GUTTER_WID] +
	    .CMDBLK [NDX$G_SEPARATE_WIDTH] GTR 120
	THEN
	    SIGNAL_STOP (INDEX$_LINELENG);

    [OTHERWISE]:

	IF  .CMDBLK [NDX$G_COLUMN_WID] GTR 120
	THEN
	    SIGNAL_STOP (INDEX$_LINELENG);

    TES;

    !
    ! /[NO]CONTINUATION_HEADINGS
    !
    !			* W A R N I N G *
    !
    !		This qualifier depends on the value of /LAYOUT
    !
    !			* W A R N I N G *
    !
    CMDBLK [NDX$V_CONTINUATION] = FALSE;

%IF DSRPLUS
%THEN

    IF  CLI$PRESENT (%ASCID'CONTINUATION_HEADINGS')
    THEN
	BEGIN

	IF  .CMDBLK [NDX$H_LAYOUT] EQL GALLEY
	THEN
	    !
	    ! Doing TMS11 galley output.
	    ! Continuation headings are not allowed
	    !
	    SIGNAL (INDEX$_IGNORED, 1, %ASCID'CONTINUATION_HEADINGS', INDEX$_CONFQUAL)
	ELSE
	    CMDBLK [NDX$V_CONTINUATION] = TRUE;

	END;

%FI

    !
    ! /NORESERVE
    ! /RESERVE = n
    !
    !			* W A R N I N G *
    !
    !		This qualifier depends on the value of /LINES_PER_PAGE
    !
    !			* W A R N I N G *
    !
    CMDBLK [NDX$G_RESERVE_LINES] = 0;

    IF  CLI$PRESENT (%ASCID'RESERVE')
    THEN
	BEGIN
	QUALIFIER_VALUE = 0;
	CLI$GET_VALUE (%ASCID'RESERVE', VALUE_STR);

	IF  NOT CALL_TPARSE (VALUE_STR, NUMBER_STATE, NUMBER_KEY)
	THEN
	    SIGNAL_STOP (INDEX$_BADVALUE, 1, VALUE_STR);

	IF  .QUALIFIER_VALUE GTR .CMDBLK [NDX$G_LINES_PAGE]
	THEN
	    SIGNAL_STOP (INDEX$_BADVALUE, 1, VALUE_STR, INDEX$_VALERR);

	CMDBLK [NDX$G_RESERVE_LINES] = .QUALIFIER_VALUE;
	END;

    !
    ! /LEVEL = n
    !
    !			* W A R N I N G *
    !
    !		This qualifier depends on the value of /MASTER
    !
    !			* W A R N I N G *
    !
    CMDBLK [NDX$H_LEVEL] = 99;			! All levels 

%IF DSRPLUS
%THEN

    IF  CLI$PRESENT (%ASCID'LEVEL')
    THEN
	BEGIN
	CLI$GET_VALUE (%ASCID'LEVEL', VALUE_STR);

	IF  NOT CALL_TPARSE (VALUE_STR, NUMBER_STATE, NUMBER_KEY)
	THEN
	    SIGNAL_STOP (INDEX$_BADVALUE, 1, VALUE_STR);

	IF  .QUALIFIER_VALUE LEQ 0
	THEN
	    SIGNAL_STOP (INDEX$_BADVALUE, 1, VALUE_STR, INDEX$_VALERR);

	CMDBLK [NDX$H_LEVEL] = .QUALIFIER_VALUE - 1;
	END
    ELSE
	BEGIN

	IF  .CMDBLK [NDX$V_MASTER]
	THEN
	    CMDBLK [NDX$H_LEVEL] = 1;		! Levels 0 and 1 for /MASTER

	END;

%FI

    !
    ! /[NO]GUIDE_HEADINGS
    !
    CMDBLK [NDX$V_GUIDE] = FALSE;

%IF DSRPLUS
%THEN

    IF  CLI$PRESENT (%ASCID'GUIDE_HEADINGS')
    THEN
	CMDBLK [NDX$V_GUIDE] = TRUE;

%FI

    !
    ! /[NO]IDENTIFICATION
    !

    IF  CLI$PRESENT (%ASCID'IDENTIFICATION')
    THEN
	SIGNAL (INDEX$_IDENT, 2, .NDXVRL, .NDXVRP);

    !
    ! /[NO]LOG
    !

    IF  CLI$PRESENT (%ASCID'LOG')
    THEN
	CMDBLK [NDX$V_LOG] = TRUE
    ELSE
	CMDBLK [NDX$V_LOG] = FALSE;

    !
    ! /NOOUTPUT
    ! /OUTPUT = filespec
    !

    IF CLI$PRESENT (%ASCID'OUTPUT')
    THEN
	BEGIN
	CMDBLK [NDX$V_OUTPUT] = TRUE;

	CLI$GET_VALUE (%ASCID'OUTPUT', CMDBLK [NDX$T_OUTPUT_FILE]);
	END
    ELSE
	CMDBLK [NDX$V_OUTPUT] = FALSE;

    !
    ! /[NO]OVERRIDE
    !
    CMDBLK [NDX$V_OVERRIDE] = FALSE;

%IF DSRPLUS
%THEN

    IF  CLI$PRESENT (%ASCID'OVERRIDE_MASTER')
    THEN
	CMDBLK [NDX$V_OVERRIDE] = TRUE;

%FI

    !
    ! /NOPAGE_NUMBERS
    ! /PAGE_NUMBERS = ([[NO]RUNNING], [[NO]MERGE])
    !
    ! NORUNNING is the same as STANDARD.
    !
    CMDBLK [NDX$V_STANDARD_PAGE] = TRUE;	! Generate standard page numbers
    CMDBLK [NDX$V_PAGES]         = TRUE;	! Generate page numbers

%IF NOT DSRPLUS
%THEN

    CMDBLK [NDX$V_PAGE_MERGE]    = TRUE;	! Merge page numbers for DSR

%ELSE

    CMDBLK [NDX$V_PAGE_MERGE]    = FALSE;	! Page ranges formed by .XPLUS (BEGIN - END)

%FI

    SELECTONE CLI$PRESENT (%ASCID'PAGE_NUMBERS') OF
	SET

	[CLI$_NEGATED]:
	    !
	    ! Qualifier explicitly negated (/NOPAGE_NUMBERS).
	    !
	    CMDBLK [NDX$V_PAGES] = FALSE;

	[CLI$_PRESENT]:
	    BEGIN
	    !
	    ! Qualifier was given explicitly on command line.
	    !
	    WHILE CLI$GET_VALUE (%ASCID'PAGE_NUMBERS', VALUE_STR) DO

		IF  NOT CALL_TPARSE (VALUE_STR, PAGE_STATE, PAGE_KEY)
		THEN
		    SIGNAL_STOP (INDEX$_BADVALUE, 1, VALUE_STR);

	    END;

	[OTHERWISE]:
	    !
	    ! CLI$_ABSENT, CLI$_DEFAULTED.
	    ! Qualifier is present by default.
	    !
	    ;

	TES;

    !
    ! /NOREQUIRE
    ! /REQUIRE = filespec
    !
    CMDBLK [NDX$V_REQUIRE] = FALSE;

    IF  CLI$PRESENT (%ASCID'REQUIRE')
    THEN
	BEGIN
	CMDBLK [NDX$V_REQUIRE] = TRUE;
	CLI$GET_VALUE (%ASCID'REQUIRE', CMDBLK [NDX$T_REQUIRE_FILE]);
	END;

    !
    ! /SORT = ([{ WORD | LETTER }], [NONALPHA = { IGNORE | BEFORE | AFTER }])
    !
    CMDBLK [NDX$V_WORD_SORT] = TRUE;		! Word by word sort is default
    CMDBLK [NDX$H_NONALPHA]  = IGNORE;		! Ignore leading nonalphas

%IF DSRPLUS
%THEN

    IF  CLI$PRESENT (%ASCID'SORT')
    THEN

	WHILE CLI$GET_VALUE (%ASCID'SORT', VALUE_STR) DO

	    IF  NOT CALL_TPARSE (VALUE_STR, SORT_STATE, SORT_KEY)
	    THEN
		SIGNAL_STOP (INDEX$_BADVALUE, 1, VALUE_STR);

%FI

    !
    ! Process all input files and local qualifiers
    !
    CMDBLK [NDX$V_INPUT_CONCAT] = FALSE;

    WHILE (STATUS = CLI$GET_VALUE (%ASCID'INPUT', CMDBLK [NDX$T_INPUT_FILE])) DO
	BEGIN

%IF DSRPLUS
%THEN

	!
	! /OPTIONS - input file is an options file
	!
	IF  CLI$PRESENT (%ASCID'OPTIONS')
	THEN
	    BEGIN
	    !
	    ! Make sure /BOOK_IDENTIFIER was not also specified.
	    ! Make sure options file is last in concatenated list.
	    !

	    IF  CLI$PRESENT (%ASCID'BOOK_IDENTIFIER') 
	    THEN 
		SIGNAL (INDEX$_IGNORED, 1, %ASCID'BOOK_IDENTIFIER', INDEX$_CONFQUAL);

	    IF .STATUS EQL CLI$_CONCAT
	    THEN 
		BEGIN
		!
		! Current input file concatenated to next - error.
		!
		CLI$GET_VALUE (%ASCID'INPUT', VALUE_STR);
		SIGNAL (INDEX$_IGNORED, 1, VALUE_STR, INDEX$_NOLIST);
		END;

	    !
	    ! Process options file and exit loop
	    !
	    OPTIONS_FILE ();
	    EXITLOOP;
	    END;
	    
	!
	! Process /BOOK_IDENTIFIER qualifier if present
	!

	PARSE_BOOK ();

%FI

	!
	! Process this input file.
	!
	! NDXINP () will call MAKNDX to generate an output index
	! if this input file is not concatenated to the previous one.
	!
	NDXINP ();

	CMDBLK [NDX$V_INPUT_CONCAT] = (.STATUS EQL CLI$_CONCAT);
	END;

    !
    ! Generate last output index and clean up
    !
    MAKNDX ();

    RETURN (.TERMINATION_STATUS OR STS$M_INHIB_MSG);
    END;

%SBTTL 'CONDITION_HANDLER - Main program condition handler - sets termination status'
ROUTINE CONDITION_HANDLER (SIG : REF BLOCK [, BYTE], MCH : REF BLOCK [, BYTE]) =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine is enabled by NDXCLI as a condition handler.
!	Whenever a signal is generated, the signal severity is examined.
!	If the condition is more severe than any previous condition,
!	(success, warning, error, severe error) the severity is recorded
!	in termination_status which is the condition severity. NDXCLI
!	returns the value of TERMINATION_STATUS as the program status
!	which will set the value of the DCL $STATUS variable. 
!
! FORMAL PARAMETERS:
!
!	SIG			- address of signal array
!	MCH			- address of mechanism array
!
! IMPLICIT INPUTS:
!
!	TERMINATION_STATUS	- current termination severity
!
! IMPLICIT OUTPUTS:
!
!	TERMINATION_STATUS	- may be set to the severity level in the 
!				  signalled condition if it is more severe
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	SS$_RESIGNAL
!
! SIDE EFFECTS:
!
!	None
!--
    BEGIN

    BIND
	SIGNALLED_CONDITION = SIG [CHF$L_SIG_NAME] : BLOCK [, BYTE];

    SELECTONE .SIGNALLED_CONDITION [STS$V_SEVERITY] OF
	SET

	[STS$K_WARNING]:
	    IF .TERMINATION_STATUS EQL STS$K_SUCCESS
	    THEN
		!
		! A warning changes the termination status only if it was
		! 'success' previously.
		!
		TERMINATION_STATUS = STS$K_WARNING;

	[STS$K_ERROR]:
	    IF .TERMINATION_STATUS LSS STS$K_ERROR
	    THEN
		!
		! An error status changes the termination status only if it
		! was 'success' or 'warning' previously.
		!
		TERMINATION_STATUS = STS$K_ERROR;

	[STS$K_SEVERE]:				! Severe error
	    TERMINATION_STATUS = STS$K_SEVERE;	! set the termination status

	[OTHERWISE]:				! Success or Informational
	    ;					! Do nothing

	TES;

    RETURN SS$_RESIGNAL;			! Continue processing condition
    END;

%SBTTL 'CALL_TPARSE -- Invoke TPARSE to process qualifier values'
ROUTINE CALL_TPARSE (STRING : REF $STR_DESCRIPTOR (), STATE_TAB, KEY_TAB) =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine calls TPARSE to parse the given string with
!	the given state and key tables.
!
! FORMAL PARAMETERS:
!
!	STRING    - Address of a string descriptor of string to parse
!	STATE_TAB - Address of TPARSE state tables
!	KEY_TAB   - Address of TPARSE key tables
!
! IMPLICIT INPUTS:
!
!	None.
!
! IMPLICIT OUTPUTS:
!
!	None.
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	Returns completion code of LIB$TPARSE
!
! SIDE EFFECTS:
!
!	None.
!--

    BEGIN

    LOCAL
	TPARSE_BLOCK : BLOCK [TPA$K_LENGTH0, BYTE];

    !
    ! Initialize the TPARSE parameter block
    !
    TPARSE_BLOCK [TPA$L_COUNT]     = TPA$K_COUNT0;
    TPARSE_BLOCK [TPA$L_OPTIONS]   = TPA$M_ABBREV;
    TPARSE_BLOCK [TPA$L_STRINGCNT] = .STRING [STR$H_LENGTH];
    TPARSE_BLOCK [TPA$L_STRINGPTR] = .STRING [STR$A_POINTER];
    TPARSE_BLOCK [TPA$L_TOKENCNT]  = 0;
    TPARSE_BLOCK [TPA$L_TOKENPTR]  = 0;
    TPARSE_BLOCK [TPA$L_NUMBER]    = 0;
    TPARSE_BLOCK [TPA$L_PARAM]     = 0;

    !
    ! Parse the string and return parse status
    !
    RETURN LIB$TPARSE (TPARSE_BLOCK, .STATE_TAB, .KEY_TAB);
    END;

%SBTTL 'ENTER_PAGE -- Action routine - enter value for /PAGE_NUMBERS'
ROUTINE ENTER_PAGE =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine is called as an action routine by TPARSE.
!
!	It save the parameter value passed by TPARSE
!
! FORMAL PARAMETERS:
!
!	AP [TPA$L_PARAM] - TRUE if STANDARD page numbers, FALSE otherwise
!
! IMPLICIT INPUTS:
!
!	None
!
! IMPLICIT OUTPUTS:
!
!	CMDBLK [NDX$V_STANDARD_PAGE] - is set to parameter value
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	TRUE
!
! SIDE EFFECTS:
!
!	None
!
!--

    BEGIN

    BUILTIN
	AP;

    MAP
	AP : REF BLOCK [, BYTE];

    CMDBLK [NDX$V_STANDARD_PAGE] = .AP [TPA$L_PARAM];
    RETURN TRUE;
    END;

%SBTTL 'OPEN_ERROR - Handle File Open Errors'
GLOBAL ROUTINE OPEN_ERROR (FUNCTION_CODE, PRIMARY_CODE, SECONDARY_CODE, IOB : REF $XPO_IOB ()) =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine is called as an Action Routine to report file open errors
!
! FORMAL PARAMETERS:
!
!	FUNCTION_CODE	- XPORT failure action routine function code
!	PRIMARY_CODE	- primary failure completion code
!	SECONDARY_CODE	- secondary failure completion code
!	IOB		- Address of file IOB
!
! IMPLICIT INPUTS:
!
!	None
!
! IMPLICIT OUTPUTS:
!
!	None
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	Returns the value of PRIMARY_CODE if success is indicated.
!
! SIDE EFFECTS:
!
!	Signals a fatal error terminating program execution if failure
!	is indicated by PRIMARY_CODE.
!--

    BEGIN

    BIND
	FILE_SPEC = .IOB [IOB$A_FILE_SPEC] : $STR_DESCRIPTOR (),
	RESULTANT =  IOB [IOB$T_RESULTANT] : $STR_DESCRIPTOR ();

    LOCAL
	FILE_NAME : REF $STR_DESCRIPTOR ();

    !
    ! Point to best file name
    !
    FILE_NAME = (IF   .RESULTANT [STR$H_LENGTH] NEQ 0
		 THEN RESULTANT
		 ELSE FILE_SPEC);

    IF  NOT .PRIMARY_CODE
    THEN
	BEGIN
	!
	! File was not opened
	!

	IF  .IOB [IOB$V_INPUT]
	THEN
	    SIGNAL_STOP (INDEX$_OPENIN, 1, .FILE_NAME,
			 .IOB [IOB$G_COMP_CODE], 1, .IOB [IOB$G_2ND_CODE])
	ELSE
	    SIGNAL_STOP (INDEX$_OPENOUT, 1, .FILE_NAME,
			 .IOB [IOB$G_COMP_CODE], 1, .IOB [IOB$G_2ND_CODE]);

	END;

    RETURN .PRIMARY_CODE;
    END;

%IF DSRPLUS
%THEN

%SBTTL 'ENTER_MERGE -- Action routine - enter page merging parameter'
ROUTINE ENTER_MERGE =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine is called as an action routine by TPARSE.
!
!	It saves the parameter passed by TPARSE.
!
! FORMAL PARAMETERS:
!
!	AP [TPA$L_PARAM] - TRUE if MERGE adjacent pages, FALSE otherwise
!
! IMPLICIT INPUTS:
!
!	None
!
! IMPLICIT OUTPUTS:
!
!	CMDBLK [NDX$V_PAGE_MERGE] - value is stored here
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	TRUE
!
! SIDE EFFECTS:
!
!	None
!
!--

    BEGIN

    BUILTIN
	AP;

    MAP
	AP : REF BLOCK [, BYTE];

    CMDBLK [NDX$V_PAGE_MERGE] = .AP [TPA$L_PARAM];
    RETURN TRUE;
    END;

%FI

%IF DSRPLUS
%THEN

%SBTTL 'ENTER_LAYOUT -- Action routine - save value of /LAYOUT qualifier'
ROUTINE ENTER_LAYOUT =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine is called as an action routine by TPARSE.
!
!	It stores the parameter passed by TPARSE in the command
!	line information block.
!
! FORMAL PARAMETERS:
!
!	AP [TPA$L_PARAM] - Layout value
!
! IMPLICIT INPUTS:
!
!	None
!
! IMPLICIT OUTPUTS:
!
!	CMDBLK [NDX$H_LAYOUT] - Value is stored here
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	TRUE
!
! SIDE EFFECTS:
!
!	None
!
!--

    BEGIN

    BUILTIN
	AP;

    MAP
	AP : REF BLOCK [, BYTE];

    CMDBLK [NDX$H_LAYOUT] = .AP [TPA$L_PARAM];
    RETURN TRUE;
    END;

%FI

%IF DSRPLUS
%THEN

%SBTTL 'ENTER_FORMAT -- Action routine - save value of /FORMAT qualifier'
ROUTINE ENTER_FORMAT =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine is called as an action routine by TPARSE.
!
!	It stores the parameter passed by TPARSE in the command line 
!	information block. 
!
!	If the format is TMS=E, it sets up the correct character size
!	vector in CHRSIZ.
!
!	If the format is TEX=filename, it copies filename to TEX_FILE_NAME
!
! FORMAL PARAMETERS:
!
!	AP [TPA$L_PARAM]	- Format type value
!	AP [TPA$L_STRINGCNT]	- Length of filename for TEX=filename
!	AP [TPA$L_STRINGPTR]	- Pointer to filename for TEX=filename
!
! IMPLICIT INPUTS:
!
!	CHRSZE			- Address of TMS 'E' character size vector
!
! IMPLICIT OUTPUTS:
!
!	CMDBLK [NDX$H_FORMAT]	- Value stored here
!	CHRSIZ			- Points to TMS 'E' character size vector
!				  for TMS=E, points to TEX character size
!				  vector for TEX=filename.
!	TEX_FILE_NAME		- String descriptor of TEX filename.
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	TRUE
!
! SIDE EFFECTS:
!
!	None
!--
    BEGIN

    BUILTIN
	AP;

    MAP
	AP : REF BLOCK [, BYTE];

    CMDBLK [NDX$H_FORMAT] = .AP [TPA$L_PARAM];

    SELECTONE .CMDBLK [NDX$H_FORMAT] OF
	SET

	[TMS11_E]:
	    CHRSIZ = CHRSZE;			! TMS 'E' character set

	[TEX]:
	    BEGIN
	    CHRSIZ = TEX_CHAR_SIZES;		! TEX character sizes

	    $STR_COPY (TARGET = TEX_FILE_NAME,
		STRING = (.AP [TPA$L_STRINGCNT], .AP [TPA$L_STRINGPTR]));

	    END;

	[OTHERWISE]:				! Do nothing for DSR or TMS=A
	    ;

	TES;

    RETURN TRUE;
    END;

%FI

%IF DSRPLUS
%THEN

%SBTTL 'ENTER_SORT -- Action routine - enter sort type'
ROUTINE ENTER_SORT =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine is called as an action routine by TPARSE.
!
!	The parameter passed by TPARSE is stored in the sort type variable.
!
! FORMAL PARAMETERS:
!
!	AP [TPA$L_PARAM] - Sort type value (TRUE or FALSE)
!
! IMPLICIT INPUTS:
!
!	None
!
! IMPLICIT OUTPUTS:
!
!	CMDBLK [NDX$V_WORD_SORT] - value stored here
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	TRUE
!
! SIDE EFFECTS:
!
!	None
!
!--

    BEGIN

    BUILTIN
	AP;

    MAP
	AP : REF BLOCK [, BYTE];

    CMDBLK [NDX$V_WORD_SORT] = .AP [TPA$L_PARAM];
    RETURN TRUE;
    END;

%FI

%IF DSRPLUS
%THEN

%SBTTL 'ENTER_ALPHA -- Action routine - enter nonalpha sort value'
ROUTINE ENTER_ALPHA =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine is called as an action routine by TPARSE.
!
!	The parameter passed by TPARSE is stored as the nonalpha sort value.
!
! FORMAL PARAMETERS:
!
!	AP [TPA$L_PARAM] - nonalpha sort value
!
! IMPLICIT INPUTS:
!
!	None
!
! IMPLICIT OUTPUTS:
!
!	CMDBLK [NDX$H_NONALPHA] - value is stored here
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	TRUE
!
! SIDE EFFECTS:
!
!	None
!
!--

    BEGIN

    BUILTIN
	AP;

    MAP
	AP : REF BLOCK [, BYTE];

    CMDBLK [NDX$H_NONALPHA] = .AP [TPA$L_PARAM];
    RETURN TRUE;
    END;

%FI

%IF DSRPLUS
%THEN

%SBTTL 'OPTIONS_FILE -- Process options file'
ROUTINE OPTIONS_FILE : NOVALUE =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Parse lines of an options file
!
! FORMAL PARAMETERS:
!
!	None
!
! IMPLICIT INPUTS:
!
!	CMDBLK [NDX$T_INPUT_FILE] - Options file name
!	NDXOPTION		  - Address of options file parse tables
!
! IMPLICIT OUTPUTS:
!
!	CMDBLK [NDX$T_INPUT_FILE] - Input file name
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	None
!
! SIDE EFFECTS:
!
!	None
!
!--

    BEGIN

    LOCAL
	OPTIOB : $XPO_IOB ();

    $XPO_IOB_INIT (IOB = OPTIOB);
    $XPO_OPEN (IOB = OPTIOB, FILE_SPEC = CMDBLK [NDX$T_INPUT_FILE],
	DEFAULT = '.OPT', FAILURE = OPEN_ERROR);

    WHILE $XPO_GET (IOB = OPTIOB) EQL XPO$_NORMAL DO
	BEGIN

	LOCAL
	    CH,
	    LEN,
	    PTR;

	!
	! Strip comments from input line
	!
	PTR = CH$FIND_CH (.OPTIOB [IOB$H_STRING], CH$PTR (.OPTIOB [IOB$A_STRING]), %C'!');

	IF  NOT CH$FAIL (.PTR)
	THEN
	    !
	    ! Remove '!' and everything after it
	    !
	    LEN = CH$DIFF (.PTR, CH$PTR (.OPTIOB [IOB$A_STRING]))
	ELSE
	    LEN = .OPTIOB [IOB$H_STRING];

	!
	! Remove trailing whitespace
	!
	PTR = CH$PLUS (CH$PTR (.OPTIOB [IOB$A_STRING]), .LEN - 1);

	DECR I FROM .LEN - 1 TO 0 DO
	    BEGIN
	    CH = CH$RCHAR (.PTR);
	    PTR = CH$PLUS (.PTR, -1);

	    IF  (.CH NEQ %C' ') AND (.CH NEQ TAB)
	    THEN
		EXITLOOP;

	    LEN = .I;
	    END;

	IF  .LEN GTR 0
	THEN
	    BEGIN
	    !
	    ! We have something to parse
	    !
	    $STR_COPY (TARGET = OPTIONS_STR,
		STRING = $STR_CONCAT ('OPTIONS ', (.LEN, .OPTIOB [IOB$A_STRING])));

	    IF  NOT CLI$DCL_PARSE (OPTIONS_STR, NDXOPTION)
	    THEN
		!
		! Error parsing input line
		!
		SIGNAL_STOP (INDEX$_SYNTAX, 1, OPTIOB [IOB$T_STRING]);

	    !
	    ! Get input file name
	    !
	    CLI$GET_VALUE (%ASCID 'INPUT', CMDBLK [NDX$T_INPUT_FILE]);

	    IF  CLI$GET_VALUE (%ASCID'INPUT', VALUE_STR)
	    THEN
		!
		! More than one input file specified.
		!
		SIGNAL (INDEX$_IGNORED, 1, VALUE_STR, INDEX$_NOLIST, 0,
			INDEX$_TEXT, 1, OPTIOB [IOB$T_STRING]);

	    !
	    ! Process /BOOK_IDENTIFIER
	    !
	    PARSE_BOOK ();

	    !
	    ! Finally, process the input file
	    !
	    NDXINP ();

	    CMDBLK [NDX$V_INPUT_CONCAT] = TRUE;		! Next file concatenated to this one
	    END;

	END;

    $XPO_CLOSE (IOB = OPTIOB);
    END;

%FI

%IF DSRPLUS
%THEN

%SBTTL 'PARSE_BOOK -- Parse /BOOK_IDENTIFIER qualifier'
ROUTINE PARSE_BOOK : NOVALUE =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine is called to process the /BOOK_IDENTIFIER qualifier
!
! FORMAL PARAMETERS:
!
!	None
!
! IMPLICIT INPUTS:
!
!	CMDBLK	- Command line information block
!
! IMPLICIT OUTPUTS:
!
!	CMDBLK [NDX$T_MASTER_BOOK] - Set to book name if doing a master index
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	None
!
! SIDE EFFECTS:
!
!	None
!
!--

    BEGIN

    IF  .CMDBLK [NDX$V_MASTER]
    THEN
	BEGIN
	!
	! Doing a master index
	!

	IF  CLI$PRESENT (%ASCID'BOOK_IDENTIFIER')
	THEN
	    !
	    ! User specified a book name
	    !
	    CLI$GET_VALUE (%ASCID'BOOK_IDENTIFIER', CMDBLK [NDX$T_MASTER_BOOK])
	ELSE
	    BEGIN
	    !
	    ! Doing a master index and no book identifier specified.
	    ! Use input file name.
	    !
	    LOCAL
		PARSE_SPEC_BLOCK : $XPO_SPEC_BLOCK;

	    IF $XPO_PARSE_SPEC (FILE_SPEC = CMDBLK [NDX$T_INPUT_FILE], 
		    SPEC_BLOCK = PARSE_SPEC_BLOCK, FAILURE = 0)
	    THEN
		!
		! Filename parse succeeded. Use filename as book name.
		!
		$STR_COPY (STRING = PARSE_SPEC_BLOCK [XPO$T_FILE_NAME],
		       TARGET = CMDBLK [NDX$T_MASTER_BOOK])
	    ELSE
		!
		! Filename parse failed. Use NULL book name.
		!
		$STR_COPY (STRING = '', TARGET = CMDBLK [NDX$T_MASTER_BOOK]);

	    END;
	END
    ELSE
	!
	! Not doing a master index
	!

	IF  CLI$PRESENT (%ASCID'BOOK_IDENTIFIER')
	THEN
	    SIGNAL (INDEX$_IGNORED, 1, %ASCID'BOOK_IDENTIFIER', INDEX$_CONFQUAL);

    END;

%FI

%IF DSRPLUS
%THEN

%SBTTL 'PROCESS_TEX_FILE - Process TEX character size file'
ROUTINE PROCESS_TEX_FILE : NOVALUE =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine is called to process the TEX character size file.
!
! FORMAL PARAMETERS:
!
!	None
!
! IMPLICIT INPUTS:
!
!	TEX_FILE_NAME	- String descriptor of TEX character size file name
!
! IMPLICIT OUTPUTS:
!
!	TEX_FILE_NAME	- Replaced with best file name during file processing.
!	TEX_CHAR_INDEX	- Initialized to zero
!	TEX_CHAR_SIZES	- Initialized to zero
!	TEX_FILE_LINE_NO- Initialized to one
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	None
!
! SIDE EFFECTS:
!
!	None
!--
    BEGIN
    TEX_FILE_LINE_NO = 1;

    TEX_CHAR_INDEX = 0;
    INCR I FROM 0 TO 255 DO TEX_CHAR_SIZES [.I] =0;

    !
    ! Set filename and open the file
    !
    TEX_FAB [FAB$B_FNS] = .TEX_FILE_NAME [STR$H_LENGTH];
    TEX_FAB [FAB$L_FNA] = .TEX_FILE_NAME [STR$A_POINTER];
    $OPEN (FAB = TEX_FAB);
    !
    ! Get the best file name
    !
    IF .TEX_NAM [NAM$B_RSL] NEQ 0
    THEN					! Use resultant name
	$STR_COPY (TARGET = TEX_FILE_NAME,
	    STRING = (.TEX_NAM [NAM$B_RSL], .TEX_NAM [NAM$L_RSA]))
    ELSE					! No resultant name
	BEGIN

	IF .TEX_NAM [NAM$B_ESL] NEQ 0
	THEN					! Use expanded name
	    $STR_COPY (TARGET = TEX_FILE_NAME,
		STRING = (.TEX_NAM [NAM$B_ESL], .TEX_NAM [NAM$L_ESA]));

	END;

    IF NOT .TEX_FAB [FAB$L_STS]
    THEN					! File not open
	SIGNAL_STOP (INDEX$_OPENIN, 1, TEX_FILE_NAME, 
	    .TEX_FAB [FAB$L_STS], .TEX_FAB [FAB$L_STV]);

    IF NOT $CONNECT (RAB = TEX_RAB)		! Connect record stream
    THEN					!  - error
	SIGNAL_STOP (INDEX$_OPENIN, 1, TEX_FILE_NAME, 
	    .TEX_RAB [RAB$L_STS], .TEX_RAB [RAB$L_STV]);

    $GET (RAB = TEX_RAB);			! Get first line in file
    $STR_DESC_INIT (DESCRIPTOR = TEX_LINE,
	STRING = (.TEX_RAB [RAB$W_RSZ], .TEX_RAB [RAB$L_RBF]));

    IF .TEX_RAB [RAB$L_STS]
    THEN
	BEGIN
	!
	! Process TEX character size file
	!
	IF RMS$_EOF NEQ CALL_TPARSE (TEX_LINE, TEX_FILE_STATE, TEX_FILE_KEY)
	THEN
	    SIGNAL_STOP (INDEX$_TEXFILE, 2, .TEX_FILE_LINE_NO, TEX_FILE_NAME, 
		INDEX$_SYNTAX, 1, TEX_LINE);

	END;

    IF .TEX_CHAR_INDEX LSS 128
    THEN					! Not enough values supplied
	SIGNAL (INDEX$_TEXFILE, 2, .TEX_FILE_LINE_NO, TEX_FILE_NAME, INDEX$_TOOFEW);

    $CLOSE (FAB = TEX_FAB);
    END;

%FI

%IF DSRPLUS
%THEN

%SBTTL 'STORE_TEX - Action routine - Store TEX character size'
ROUTINE STORE_TEX =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine is called as an action routine by LIB$TPARSE to 
!	store a TEX character size.
!
! FORMAL PARAMETERS:
!
!	AP [TPA$L_NUMBER]	- Value to be stored
!
! IMPLICIT INPUTS:
!
!	TEX_CHAR_INDEX		- Index into TEX_CHAR_SIZES where next value
!				  is to be stored
!
! IMPLICIT OUTPUTS:
!
!	TEX_CHAR_SIZES [.TEX_CHAR_INDEX]- Contains value
!	TEX_CHAR_INDEX			- Is incremented
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	TRUE
!
! SIDE EFFECTS:
!
!	Signals a fatal error if TEX_CHAR_INDEX exceeds 255
!--
    BEGIN

    BUILTIN
	AP;

    MAP
	AP : REF BLOCK [, BYTE];

    IF .TEX_CHAR_INDEX EQL 256
    THEN
	SIGNAL_STOP (INDEX$_TEXFILE, 2, .TEX_FILE_LINE_NO, TEX_FILE_NAME, INDEX$_TOOMANY);

    TEX_CHAR_SIZES [.TEX_CHAR_INDEX] = .AP [TPA$L_NUMBER];
    TEX_CHAR_INDEX = .TEX_CHAR_INDEX + 1;
    RETURN TRUE;
    END;

%FI

%IF DSRPLUS
%THEN

%SBTTL 'READ_TEX -- Action routine - Read a record from TEX char size file'
ROUTINE READ_TEX =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine is called as an action routine by TPARSE.
!
!	It reads a line from the input file.
!
! FORMAL PARAMETERS:
!
!	None
!
! IMPLICIT INPUTS:
!
!	TEX_RAB			- RMS RAB to read 
!
! IMPLICIT OUTPUTS:
!
!	TEX_IN_BUF		- Contains text of new line
!	TEX_LINE		- Is a string descriptor of new line
!	TEX_FILE_LINE_NO	- Is incremented
!	AP [TPA$L_STRINGCNT]	- Is length of new line
!	AP [TPA$L_STRINGPTR]	- Points to new line
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	Returns TRUE if successful
!	Returns RMS$_EOF if end of file encountered
!	Returns FALSE otherwise
!
! SIDE EFFECTS:
!
!	None
!--
    BEGIN
    BUILTIN
	AP;

    MAP
	AP : REF BLOCK [, BYTE];

    IF NOT $GET (RAB = TEX_RAB)
    THEN
	RETURN (IF .TEX_RAB [RAB$L_STS] EQL RMS$_EOF THEN RMS$_EOF ELSE FALSE);

    TEX_FILE_LINE_NO = .TEX_FILE_LINE_NO + 1;
    $STR_DESC_INIT (DESCRIPTOR = TEX_LINE,
	STRING = (.TEX_RAB [RAB$W_RSZ], .TEX_RAB [RAB$L_RBF]));

    AP [TPA$L_STRINGCNT] = .TEX_LINE [STR$H_LENGTH];
    AP [TPA$L_STRINGPTR] = .TEX_LINE [STR$A_POINTER];
    RETURN TRUE;
    END;

%FI

END			! End of module
ELUDOM
