MODULE SNDJBC	(%TITLE	'$SNDACC, $SNDSMB, and $SNDJBC services'
		IDENT = 'V04-000'
		) =
BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY:
!	Job controller.
!
! ABSTRACT:
!	This module contains the routines that implement the $SNDACC, $SNDSMB
!	and $SNDJBC services.
!
! ENVIRONMENT:
!	VAX/VMS user and kernel mode.
!--
!
! AUTHOR: M. Jack, CREATION DATE: 16-Feb-1982
!
! MODIFIED BY:
!
!	V03-015	JAK0229		J A Krycka	24-Aug-1984
!		Collect additional diagnostic information.
!
!	V03-014	KPL0002		P Lieberwirth,	23-Jul-1984
!		Protect routine SJC_CLOSE_JOB against possible SJH queue_link
!		corruption.
!
!	V03-013	JAK0220		J A Krycka	18-Jul-1984
!		Add support for SJC$_PAGINATE and SJC$_NOPAGINATE item codes
!		for queue level operations.
!
!	V03-012	JAK0219		J A Krycka	17-Jul-1984
!		Add support for SJC$_BUFFER_COUNT and SJC$_EXTEND_QUANTITY
!		item codes for the SJC$_START_QUEUE_MANAGER function. Also,
!		add SJC$_RESERVED_xxx codes.
!
!	V03-011	JAK0216		J A Krycka	19-Jun-1984
!		Continuation of V03-010.
!
!	V03-010	JAK0203		J A Krycka	17-Apr-1984
!		Add support for SJC$ACCOUNT_NAME, SJC$_UIC, and SJC$_USERNAME
!		item codes for the $SNDJBC system service.
!
!	V03-009	GRR0003		Gregory R. Robert	16-Sep-1983
!		Make SJC$_DELETE_FILE and invalid option for SJC$_ALTER_JOB
!		because delete_permission is now checked only when file is
!		initially submitted.
!
!	V03-008	MLJ0118		Martin L. Jack,	23-Aug-1983
!		Change field names, remove temporary 'access allowed' code.
!
!	V03-007	MLJ0115		Martin L. Jack,	30-Jul-1983
!		Changes for job controller baselevel.
!
!	V03-006	MLJ0114		Martin L. Jack,	23-Jun-1983
!		Changes for job controller baselevel and rename from SERVICES.
!
!	V03-005	MLJ0113		Martin L. Jack,	26-May-1983
!		Changes for job controller baselevel.
!
!	V03-004	MLJ0112		Martin L. Jack,	29-Apr-1983
!		Changes for job controller baselevel.
!
!	V03-003	MLJ0111		Martin L. Jack,	20-Apr-1983
!		Correct problem in remote resume.
!
!	V03-002	MLJ0110		Martin L. Jack,	18-Apr-1983
!		Change STOP_QUEUE_MANAGER to abort or requeue executing jobs.
!
!	V03-001	MLJ0109		Martin L. Jack,	14-Apr-1983
!		Changes for job controller baselevel.
!
!**

REQUIRE 'SRC$:JOBCTLDEF';


FORWARD ROUTINE
	SJC_ABORT_JOB,
	SJC_ADD_FILE,
	SJC_ALTER_JOB,
	SJC_ALTER_QUEUE,
	SJC_ASSIGN_QUEUE,
	SJC_BATCH_CHECKPOINT,
	SJC_CLOSE_DELETE,
	SJC_CLOSE_JOB,
	SJC_CREATE_JOB,
	SJC_CREATE_QUEUE,
	SJC_DEASSIGN_QUEUE,
	SJC_DEFINE_CHARACTERISTIC,
	SJC_DEFINE_FORM,
	SJC_DELETE_CHARACTERISTIC,
	SJC_DELETE_FORM,
	SJC_DELETE_JOB,
	SJC_DELETE_QUEUE,
	SJC_ENTER_FILE,
	SJC_MERGE_QUEUE,
	SJC_PAUSE_QUEUE,
	SJC_RESERVED_FUNC_1,
	SJC_RESERVED_FUNC_2,
	SJC_RESET_QUEUE,
	SET_ACCOUNTING_FLAGS,
	SJC_START_ACCOUNTING,
	SJC_START_QUEUE,
	SJC_START_QUEUE_MANAGER,
	CLEAR_ACCOUNTING_FLAGS,
	SJC_STOP_ACCOUNTING,
	SJC_STOP_QUEUE,
	SJC_STOP_QUEUE_MANAGER,
	SJC_SYNCHRONIZE_JOB,
	SJC_WRITE_ACCOUNTING,
	PROCESS_ONE_OPTION,
	SNDACC_SERVICE,
	PROCESS_SNDSMB_OPTIONS,
	SNDSMB_SERVICE,
	PROCESS_SNDJBC_ITEM_LIST,
	SNDJBC_SERVICE;


EXTERNAL ROUTINE
	ABORT_EXECUTOR_JOB,
	ALLOCATE_RECORD:		L_OUTPUT_2,
	APPLY_SFM_OPTIONS,
	APPLY_SJH_OPTIONS,
	APPLY_SMQ_OPTIONS,
	APPLY_SQR_OPTIONS,
	CHECK_R_ACCESS,
	CHECK_W_ACCESS,
	CHECK_E_ACCESS,
	CHECK_D_ACCESS,
	CLOSE_ACCOUNTING_FILE:		NOVALUE,
	COMPLETE_JOB:			NOVALUE,
	COMPLETE_SRB_OUTPUT_ITEM:	NOVALUE,
	CREATE_SRB:			NOVALUE,
	CREATE_SFM_RECORD:		L_OUTPUT_2,
	CREATE_SJH_RECORD:		L_OUTPUT_2,
	CREATE_SMQ_RECORD:		L_OUTPUT_2,
	CREATE_SQR_RECORD:		L_OUTPUT_2,
	CREATE_SRQ_RECORD,
	DEALLOCATE_RECORD:		NOVALUE,
	DELETE_SFM_RECORD:		NOVALUE,
	DELETE_SJH_RECORD:		NOVALUE,
	DELETE_SMQ_RECORD:		NOVALUE,
	DELETE_SQR_RECORD:		NOVALUE,
	DEQUEUE_OPEN_JOB:		L_OUTPUT_1,
	ENQUEUE_JOB:			L_OUTPUT_2 NOVALUE,
	ENTER_PROCESS_DATA:		NOVALUE,
	FIND_CHARACTERISTIC:		L_OUTPUT_1,
	FIND_FORM_NAME:			L_OUTPUT_2,
	FIND_FORM_NUMBER:		L_OUTPUT_2,
	FIND_FORM_REFERENCES,
	FIND_PENDING_JOBS:		NOVALUE,
	FIND_PROCESS_DATA:		L_OUTPUT_3,
	FIND_QUEUE:			L_OUTPUT_4,
	FIND_QUEUE_REFERENCES,
	INITIALIZE_QUEUE_FILE,
	JOB_STATUS_MESSAGE,
	LOCATE_SRB_OUTPUT_ITEM,
	LOCK_QUEUE_FILE:		NOVALUE,
	OPEN_ACCOUNTING_FILE:		NOVALUE,
	PAUSE_EXECUTION,
	READ_RECORD,
	RELEASE_RECORD:			NOVALUE,
	REQUEUE_STARTING_JOBS:		NOVALUE,
	RESET_EXECUTOR_QUEUE:		NOVALUE,
	RESUME_EXECUTION,
	REWRITE_RECORD:			NOVALUE,
	SCAN_INCOMPLETE_SERVICES:	NOVALUE,
	SEARCH_QUEUES:			L_OUTPUT_4,
	SEND_SERVICE_RESPONSE_MESSAGE:	NOVALUE,
	SJC_BATCH_SERVICE,
	START_SYMBIONT_STREAM,
	STOP_SYMBIONT_STREAM:		NOVALUE,
	UNLOCK_QUEUE_FILE:		NOVALUE,
	UPDATE_GETQUI_DATA:		NOVALUE,
	UPDATE_SFX_ENTRY:		NOVALUE,
	UPDATE_SQX_ENTRY:		NOVALUE,
	VALIDATE_OBJECT_NAME,
	WRITE_USER_ACCOUNTING_RECORD:	NOVALUE;


EXTERNAL
	EXE$GL_ACMFLAGS:		BBLOCK ADDRESSING_MODE(GENERAL),
	SCS$GB_NODENAME:		VECTOR[,BYTE] ADDRESSING_MODE(GENERAL),
	SYS$GB_MAXQUEPRI:		BYTE ADDRESSING_MODE(GENERAL);


BUILTIN
	MOVC3,
	SUBM,
	TESTBITCS,
	TESTBITSC;

ROUTINE SJC_ABORT_JOB(SQX_N,SQE,SMQ_N,SMQ)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine processes the SJC$_ABORT_JOB (SMR$K_ABORT) request.
!
! INPUT PARAMETERS:
!	SQX_N		- Record number of SQX.
!	SQE		- Pointer to SQX entry.
!	SMQ_N		- Record number of SMQ.
!	SMQ		- Pointer to SMQ.
!
! IMPLICIT INPUTS:
!	MBX		- Pointer to buffered mailbox message.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Completion status to be returned to requestor.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	SQE:		REF BBLOCK,	! Pointer to SQX entry
	SMQ:		REF BBLOCK;	! Pointer to SMQ
LOCAL
	DSMQ_N,				! Record number of destination SMQ
	DSMQ:		REF BBLOCK,	! Pointer to destination SMQ
	ESMQ_N,				! Record number of executor SMQ
	ESMQ:		REF BBLOCK,	! Pointer to executor SMQ
	SJH_N,				! Record number of SJH
	SJH:		REF BBLOCK,	! Pointer to SJH
	STATUS_1,			! Status return
	STATUS_2;			! Status return


! For a batch queue, ensure that the entry number is specified.
!
IF .SMQ[SMQ$V_BATCH] AND NOT .ITEM_PRESENT[SJC$_ENTRY_NUMBER]
THEN
    RETURN JBC$_MISREQPAR;


! If a requeue was specified, ensure that the requestor has W access to the
! queue and that the type of the new queue is compatible.
!
IF .ITEM_PRESENT[SJC$_DESTINATION_QUEUE]
THEN
    BEGIN
    DSMQ_N = .VALUE_DESTINATION_QUEUE[0];
    DSMQ = .VALUE_DESTINATION_QUEUE[1];

    IF NOT CHECK_W_ACCESS(.DSMQ)
    THEN
	RETURN JBC$_NOPRIV;

    IF .SMQ[SMQ$V_BATCH] NEQ .DSMQ[SMQ$V_BATCH]
    THEN
	RETURN JBC$_INCDSTQUE;
    END;


! Find the specified current job.
!
STATUS_1 = SEARCH_QUEUES(
    QSM_M_CURRENT,
    .SMQ_N, .SMQ,
    (IF .ITEM_PRESENT[SJC$_ENTRY_NUMBER] THEN VALUE_ENTRY_NUMBER ELSE 0), 0,
    CHECK_D_ACCESS,
    QSM_K_REMOVE_INACTIVE;
    SJH_N, SJH, ESMQ_N, ESMQ);
IF NOT .STATUS_1 THEN RETURN .STATUS_1;


! If the job is executing, request the executor to abort it.
!
IF .SJH[SJH$V_EXECUTING]
THEN
    BEGIN

    ! If a previous abort is in progress, refuse this request.
    !
    IF .SJH[SJH$V_ABORTING]
    OR .SJH[SJH$V_ABORTED]
    THEN
	RETURN JBC$_INCOMPLETE;


    IF .ITEM_PRESENT[SJC$_REQUEUE]
    THEN
	BEGIN

	! If a requeue was specified, ensure that the job is allowed to restart.
	!
	IF NOT .SJH[SJH$V_RESTART]
	THEN
	    RETURN JBC$_NORESTART;


	! Process the subsidiary parameters.
	!
	SJH[SJH$V_REQUEUE] = TRUE;
	SJH[SJH$V_REQUEUE_HOLD] = FALSE;
	SJH[SJH$B_REQUEUE_PRIORITY] = .SJH[SJH$B_PRIORITY];
	SJH[SJH$L_REQUEUE_QUEUE_LINK] = 0;


	IF .ITEM_PRESENT[SJC$_DESTINATION_QUEUE]
	THEN
	    SJH[SJH$L_REQUEUE_QUEUE_LINK] = .DSMQ_N;


	IF .ITEM_PRESENT[SJC$_HOLD]
	THEN
	    SJH[SJH$V_REQUEUE_HOLD] = TRUE;


	IF .ITEM_PRESENT[SJC$_PRIORITY]
	THEN
	    SJH[SJH$B_REQUEUE_PRIORITY] = .VALUE_PRIORITY;
	END;


    ! Execute the actual abort.
    !
    STATUS_2 = ABORT_EXECUTOR_JOB(.ESMQ_N, .ESMQ, .SJH_N, .SJH);


    REWRITE_RECORD(.SMQ_N);
    REWRITE_RECORD(.SJH_N);
    RETURN .STATUS_2;
    END;


! The job is not executing.  Process the request immediately.
!
ESMQ[SMQ$B_CURRENT_JOB_COUNT] = .ESMQ[SMQ$B_CURRENT_JOB_COUNT] - 1;
FIND_PENDING_JOBS(.ESMQ_N, .ESMQ);
REWRITE_RECORD(.ESMQ_N);


IF .ITEM_PRESENT[SJC$_REQUEUE]
THEN
    BEGIN
    APPLY_SJH_OPTIONS(.SJH);
    ENQUEUE_JOB(.SJH_N, .SJH);
    REWRITE_RECORD(.SJH_N);
    END
ELSE
    BEGIN
    SJH[SJH$V_DELETED] = TRUE;
    COMPLETE_JOB(.SJH_N, .SJH, .SMQ, 0);
    END;


REWRITE_RECORD(.SMQ_N);
SS$_NORMAL
END;

ROUTINE SJC_ADD_FILE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine processes the SJC$_ADD_FILE (SMR$K_ADDFIL) request.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	MBX		- Pointer to buffered mailbox message.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Completion status to be returned to requestor.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	SJH_N,				! Record number of SJH
	SJH:		REF BBLOCK,	! Pointer to SJH
	SQR_N,				! Record number of SQR
	SQR:		REF BBLOCK,	! Pointer to SQR
	SQR_N2,				! Record number of last SQR for job
	SQR_2:		REF BBLOCK,	! Pointer to last SQR
	STATUS_1,			! Status return
	STATUS_2;			! Status return


! Find an open job owned by this process, but do not dequeue it.
!
IF NOT FIND_PROCESS_DATA(PDE_K_OPEN_JOB, .MBX[ACM$L_PID], FALSE; , SJH_N)
THEN
    RETURN JBC$_NOOPENJOB;


! Read the job record.
!
SJH = READ_RECORD(.SJH_N);


! Allocate the file record.
!
STATUS_1 = CREATE_SQR_RECORD(.SJH; SQR_N, SQR);
IF NOT .STATUS_1 THEN RETURN .STATUS_1;


! Apply options to the file record.
!
STATUS_2 = APPLY_SQR_OPTIONS(.SJH, .SQR);
IF NOT .STATUS_2
THEN
    BEGIN
    SQR[SQR$V_DELETE_FILE] = FALSE;
    DELETE_SQR_RECORD(.SQR_N, .SQR);
    RETURN .STATUS_2;
    END;


! Enqueue the file record to the end of the file queue on the job header.
!
IF .SJH[SJH$L_FILE_LIST] EQL 0
THEN
    BEGIN
    SQR[SYM$W_SEQUENCE] = 1;
    SJH[SJH$L_FILE_LIST] = .SQR_N;
    END
ELSE
    BEGIN
    SQR_2 = READ_RECORD(SQR_N2 = .SJH[SJH$L_FILE_LIST_END]);
    SQR[SYM$W_SEQUENCE] = .SQR_2[SYM$W_SEQUENCE] + 1;
    SQR_2[SYM$L_LINK] = .SQR_N;
    REWRITE_RECORD(.SQR_N2);
    END;
SJH[SJH$L_FILE_LIST_END] = .SQR_N;
REWRITE_RECORD(.SQR_N);
REWRITE_RECORD(.SJH_N);


SS$_NORMAL
END;

ROUTINE SJC_ALTER_JOB(SQX_N,SQE,SMQ_N,SMQ)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine processes the SJC$_ALTER_JOB (SMR$K_ALTER) request.
!
! INPUT PARAMETERS:
!	SQX_N		- Record number of SQX.
!	SQE		- Pointer to SQX entry.
!	SMQ_N		- Record number of SMQ.
!	SMQ		- Pointer to SMQ.
!
! IMPLICIT INPUTS:
!	MBX		- Pointer to buffered mailbox message.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Completion status to be returned to requestor.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	SQE:		REF BBLOCK,	! Pointer to SQX entry
	SMQ:		REF BBLOCK;	! Pointer to SMQ
LOCAL
	SQH:		REF BBLOCK,	! Pointer to SQH
	DSMQ:		REF BBLOCK,	! Pointer to destination SMQ
	ESMQ_N,				! Record number of executor SMQ
	ESMQ:		REF BBLOCK,	! Pointer to executor SMQ
	SJH_N,				! Record number of SJH
	SJH:		REF BBLOCK,	! Pointer to SJH
	SQR_N,				! Record number of SQR
	SQR_NS,				! Record number of successor of SQR
	SQR:		REF BBLOCK,	! Pointer to SQR
	STATUS_1,			! Status return
	STATUS_2;			! Status return


! Ensure that the requestor has W access to the log queue if specified.
!
IF .ITEM_PRESENT[SJC$_LOG_QUEUE]
THEN
    IF NOT CHECK_W_ACCESS(.VALUE_LOG_QUEUE[1])
    THEN
	RETURN JBC$_NOPRIV;


! If a requeue was specified, ensure that the requestor has W access to the
! queue and that the type of the new queue is compatible.
!
IF .ITEM_PRESENT[SJC$_DESTINATION_QUEUE]
THEN
    BEGIN
    DSMQ = .VALUE_DESTINATION_QUEUE[1];

    IF NOT CHECK_W_ACCESS(.DSMQ)
    THEN
	RETURN JBC$_NOPRIV;

    IF .SMQ[SMQ$V_BATCH] NEQ .DSMQ[SMQ$V_BATCH]
    THEN
	RETURN JBC$_INCDSTQUE;
    END;


! Search for the specified job.
!
STATUS_1 = SEARCH_QUEUES(
    QSM_M_OPEN OR QSM_M_TIMER OR QSM_M_PENDING OR QSM_M_HOLD OR QSM_M_CURRENT,
    .SMQ_N, .SMQ,
    VALUE_ENTRY_NUMBER, 0,
    CHECK_D_ACCESS,
    QSM_K_REMOVE_INACTIVE;
    SJH_N, SJH, ESMQ_N, ESMQ);
IF NOT .STATUS_1 THEN RETURN .STATUS_1;


IF .SJH[SJH$V_EXECUTING]
THEN
    BEGIN
    RETURN JBC$_EXECUTING;
    END;


IF .SJH[SJH$V_STARTING]
THEN
    BEGIN
    ESMQ[SMQ$B_CURRENT_JOB_COUNT] = .ESMQ[SMQ$B_CURRENT_JOB_COUNT] - 1;
    FIND_PENDING_JOBS(.ESMQ_N, .ESMQ);
    REWRITE_RECORD(.ESMQ_N);
    END;


STATUS_2 = APPLY_SJH_OPTIONS(.SJH);
IF .STATUS_2
THEN
    BEGIN
    SJH[SJH$L_JOB_SIZE] = 0;
    SQR_N = .SJH[SJH$L_FILE_LIST];
    WHILE .SQR_N NEQ 0 DO
	BEGIN
	LOCAL
	    STATUS_3;

	SQR = READ_RECORD(.SQR_N);
	STATUS_3 = APPLY_SQR_OPTIONS(.SJH, .SQR);
	IF .STATUS_2 AND NOT .STATUS_3 THEN STATUS_2 = .STATUS_3;
	SQR_NS = .SQR[SYM$L_LINK];
	REWRITE_RECORD(.SQR_N);
	SQR_N = .SQR_NS;
	END;
    END;


IF .SJH[SJH$V_OPEN]
THEN
    BEGIN
    SQH = READ_RECORD(SQH$K_RECNO);
    SJH[SYM$L_LINK] = .SQH[SQH$L_OPEN_LIST];
    SQH[SQH$L_OPEN_LIST] = .SJH_N;
    IF .SJH[SYM$L_LINK] EQL 0 THEN SQH[SQH$L_OPEN_LIST_END] = .SJH_N;
    ESMQ = READ_RECORD(ESMQ_N = .SJH[SJH$L_QUEUE_LINK]);
    ESMQ[SMQ$W_OPEN_JOB_COUNT] = .ESMQ[SMQ$W_OPEN_JOB_COUNT] + 1;
    REWRITE_RECORD(.SJH_N);
    REWRITE_RECORD(.ESMQ_N);
    REWRITE_RECORD(SQH$K_RECNO);
    END
ELSE
    BEGIN
    ENQUEUE_JOB(.SJH_N, .SJH);
    REWRITE_RECORD(.SJH_N);
    END;
.STATUS_2
END;

ROUTINE SJC_ALTER_QUEUE(SQX_N,SQE,SMQ_N,SMQ)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine processes the SJC$_ALTER_QUEUE request.
!
! INPUT PARAMETERS:
!	SQX_N		- Record number of SQX.
!	SQE		- Pointer to SQX entry.
!	SMQ_N		- Record number of SMQ.
!	SMQ		- Pointer to SMQ.
!
! IMPLICIT INPUTS:
!	MBX		- Pointer to buffered mailbox message.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Completion status to be returned to requestor.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	SQE:		REF BBLOCK,	! Pointer to SQX entry
	SMQ:		REF BBLOCK;	! Pointer to SMQ
LOCAL
	STATUS;				! Status return


! Ensure that the requestor has E access to the queue.
!
IF NOT CHECK_E_ACCESS(.SMQ)
THEN
    RETURN JBC$_NOPRIV;


! Apply the specified queue parameter changes.
!
STATUS = APPLY_SMQ_OPTIONS(.SMQ);
IF NOT .STATUS THEN RETURN .STATUS;
UPDATE_SQX_ENTRY(.SQE, .SMQ_N, .SMQ);


! Try to schedule jobs that may have been enabled by the changes.
!
FIND_PENDING_JOBS(.SMQ_N, .SMQ);


REWRITE_RECORD(.SQX_N);
REWRITE_RECORD(.SMQ_N);
SS$_NORMAL
END;

ROUTINE SJC_ASSIGN_QUEUE(SQX_N,SQE,SMQ_N,SMQ)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine processes the SJC$_ASSIGN_QUEUE (SMR$K_REDIRECT) request.
!
! INPUT PARAMETERS:
!	SQX_N		- Record number of SQX.
!	SQE		- Pointer to SQX entry.
!	SMQ_N		- Record number of SMQ.
!	SMQ		- Pointer to SMQ.
!
! IMPLICIT INPUTS:
!	MBX		- Pointer to buffered mailbox message.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Completion status to be returned to requestor.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	SQE:		REF BBLOCK,	! Pointer to logical SQX entry
	SMQ:		REF BBLOCK;	! Pointer to logical SMQ
LOCAL
	DSMQ_N,				! Record number of execution SMQ
	DSMQ:		REF BBLOCK;	! Pointer to execution SMQ


! Pick up a pointer to the destination queue.
!
DSMQ_N = .VALUE_DESTINATION_QUEUE[0];
DSMQ = .VALUE_DESTINATION_QUEUE[1];


! Ensure that the requestor has E access to both queues.
!
IF NOT CHECK_E_ACCESS(.SMQ)
OR NOT CHECK_E_ACCESS(.DSMQ)
THEN
    RETURN JBC$_NOPRIV;


! Ensure that the logical queue is not the same as the execution queue, and
! that both are symbiont queues, and that the execution queue is one.
!
IF .SMQ_N EQL .DSMQ_N
OR .SMQ[SMQ$V_BATCH]
OR .DSMQ[SMQ$V_BATCH]
OR .DSMQ[SMQ$V_GENERIC_QUEUE]
OR .DSMQ[SMQ$L_ASSIGNED_QUEUE_LINK] NEQ 0
THEN
    RETURN JBC$_INCQUETYP;


! Ensure that the logical queue is not running.
!
IF .SMQ[SMQ$L_STREAM_SCT] NEQ 0
THEN
    RETURN JBC$_STARTED;


! Finally, make the data structure modification.
!
SMQ[SMQ$L_ASSIGNED_QUEUE_LINK] = .DSMQ_N;
UPDATE_SQX_ENTRY(.SQE, .SMQ_N, .SMQ);
REWRITE_RECORD(.SQX_N);
REWRITE_RECORD(.SMQ_N);


SS$_NORMAL
END;

ROUTINE SJC_BATCH_CHECKPOINT=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine processes the SJC$_BATCH_CHECKPOINT request.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	MBX		- Pointer to buffered mailbox message.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Completion status to be returned to requestor.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	SJH_N,				! Record number of SJH
	SJH:		REF BBLOCK,	! Pointer to SJH
	STATUS;				! Status return


! If the requesting process is a batch process, find the job record and store
! the checkpoint information.
!
IF .QUEUE_FAB[FAB$W_IFI] NEQ 0
THEN
    BEGIN
    IF FIND_PROCESS_DATA(
	PDE_K_BATCH, .MBX[ACM$L_PID], FALSE;
	, , SJH_N)
    THEN
	BEGIN
	SJH = READ_RECORD(.SJH_N);
	STATUS = APPLY_SJH_OPTIONS(.SJH);
	IF NOT .STATUS THEN RETURN .STATUS;
	REWRITE_RECORD(.SJH_N);
	END;
    END;


SS$_NORMAL
END;

ROUTINE SJC_CLOSE_DELETE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine processes the SJC$_CLOSE_DELETE request.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	MBX		- Pointer to buffered mailbox message.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Completion status to be returned to requestor.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	SJH_N,				! Record number of SJH
	SJH:		REF BBLOCK;	! Pointer to SJH


! Find an open job owned by this process, and dequeue it.
!
IF
    BEGIN
    IF FIND_PROCESS_DATA(PDE_K_OPEN_JOB, .MBX[ACM$L_PID], TRUE; , SJH_N)
    THEN
	NOT DEQUEUE_OPEN_JOB(.SJH_N; SJH)
    ELSE
	TRUE
    END
THEN
    RETURN JBC$_NOOPENJOB;


! Delete the job.
!
DELETE_SJH_RECORD(.SJH_N, .SJH);


SS$_NORMAL
END;

ROUTINE SJC_CLOSE_JOB=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine processes the SJC$_CLOSE_JOB (SMR$K_CLSJOB) request.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	MBX		- Pointer to buffered mailbox message.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Completion status to be returned to requestor.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	SMQ:		REF BBLOCK,	! Pointer to job's SMQ
	SMQ_N,				! Record number of SMQ
	SJH_N,				! Record number of SJH
	SJH:		REF BBLOCK,	! Pointer to SJH
	SRB:		BBLOCK[512],	! Local service response block
	RESULT,				! Result of enqueue
	ESMQ:		REF BBLOCK;	! Pointer to executor SMQ


! Find an open job owned by this process, and dequeue it.
!
IF
    BEGIN
    IF FIND_PROCESS_DATA(PDE_K_OPEN_JOB, .MBX[ACM$L_PID], TRUE; , SJH_N)
    THEN
	NOT DEQUEUE_OPEN_JOB(.SJH_N; SJH)
    ELSE
	TRUE
    END
THEN
    RETURN JBC$_NOOPENJOB;


! If the job is empty, delete it and return an error.
!
IF .SJH[SJH$L_FILE_LIST] EQL 0
THEN
    BEGIN
    DELETE_SJH_RECORD(.SJH_N, .SJH);
    RETURN JBC$_EMPTYJOB;
    END;


! Enqueue the job on an appropriate queue.
!
SMQ_N = .SJH[SJH$L_QUEUE_LINK];
IF .SMQ_N NEQ 0
THEN
    BEGIN
    SMQ = READ_RECORD(.SMQ_N);
    ENQUEUE_JOB(.SJH_N, .SJH; RESULT, ESMQ);
    END
ELSE
    ! Queue_link is corrupt, we know that the job was previously deleted,
    ! so return no such job.
    !
    RETURN JBC$_NOSUCHJOB;

! Return status including required output items.
!
CREATE_SRB(SRB);
IF .ITEM_PRESENT[SJC$_JOB_STATUS_OUTPUT]
THEN
    BEGIN
    COMPLETE_SRB_OUTPUT_ITEM(
	SRB,
	JOB_STATUS_MESSAGE(
	    .RESULT,
	    LOCATE_SRB_OUTPUT_ITEM(
		SRB,
		SJC$_JOB_STATUS_OUTPUT, VALUE_JOB_STATUS_OUTPUT),
	    .SMQ,
	    .SJH,
	    .ESMQ));
    END;
SEND_SERVICE_RESPONSE_MESSAGE(SRB, JBC$_NORMAL);


REWRITE_RECORD(.SJH_N);
0
END;

ROUTINE SJC_CREATE_JOB(SQX_N,SQE,SMQ_N,SMQ)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine processes the SJC$_CREATE_JOB (SMR$K_CREJOB) request.
!
! INPUT PARAMETERS:
!	SQX_N		- Record number of SQX.
!	SQE		- Pointer to SQX entry.
!	SMQ_N		- Record number of SMQ.
!	SMQ		- Pointer to SMQ.
!
! IMPLICIT INPUTS:
!	MBX		- Pointer to buffered mailbox message.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Completion status to be returned to requestor.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	SQE:		REF BBLOCK,	! Pointer to SQX entry
	SMQ:		REF BBLOCK;	! Pointer to SMQ
LOCAL
	SQH:		REF BBLOCK,	! Pointer to SQH
	SJH_N,				! Record number of SJH
	SJH:		REF BBLOCK,	! Pointer to SJH
	SRB:		BBLOCK[512],	! Local service response block
	STATUS_1,			! Status return
	STATUS_2;			! Status return


! Ensure that the requestor has W access to the queue.
!
IF NOT CHECK_W_ACCESS(.SMQ)
THEN
    RETURN JBC$_NOPRIV;


! Ensure that the requestor has W access to the log queue if specified.
!
IF .ITEM_PRESENT[SJC$_LOG_QUEUE]
THEN
    IF NOT CHECK_W_ACCESS(.VALUE_LOG_QUEUE[1])
    THEN
	RETURN JBC$_NOPRIV;


! If this process already has an open job, delete it.
!
IF
    BEGIN
    IF FIND_PROCESS_DATA(PDE_K_OPEN_JOB, .MBX[ACM$L_PID], TRUE; , SJH_N)
    THEN
	DEQUEUE_OPEN_JOB(.SJH_N; SJH)
    ELSE
	FALSE
    END
THEN
    DELETE_SJH_RECORD(.SJH_N, .SJH);


! Allocate the job record.
!
STATUS_1 = CREATE_SJH_RECORD(.SMQ_N, .SMQ; SJH_N, SJH);
IF NOT .STATUS_1 THEN RETURN .STATUS_1;


! Apply options to the job record.
!
STATUS_2 = APPLY_SJH_OPTIONS(.SJH);
IF NOT .STATUS_2
THEN
    BEGIN
    DELETE_SJH_RECORD(.SJH_N, .SJH);
    RETURN .STATUS_2;
    END;


! Default the form if necessary.
!
IF NOT .SMQ[SMQ$V_BATCH] AND .SJH[SJH$L_FORM_LINK] EQL 0
THEN
    BEGIN
    LOCAL
	SFM_N;				! Record number of SFM

    IF NOT FIND_FORM_NUMBER(0; SFM_N)
    THEN
	BEGIN
	DELETE_SJH_RECORD(.SJH_N, .SJH);
	RETURN JBC$_NOSUCHFORM;
	END;
    SJH[SJH$L_FORM_LINK] = .SFM_N;
    END;


! Return the job identification.
!
RSP[RSP_W_ENTRY_NUMBER] = .SJH[SYM$L_ENTRY_NUMBER];


! Record the open job in the process data base for ready access.
!
ENTER_PROCESS_DATA(PDE_K_OPEN_JOB, .MBX[ACM$L_PID], .SJH_N);


! Enqueue the job on the open job queue.
!
SQH = READ_RECORD(SQH$K_RECNO);
SJH[SYM$L_LINK] = .SQH[SQH$L_OPEN_LIST];
SQH[SQH$L_OPEN_LIST] = .SJH_N;
IF .SJH[SYM$L_LINK] EQL 0 THEN SQH[SQH$L_OPEN_LIST_END] = .SJH_N;
SMQ[SMQ$W_OPEN_JOB_COUNT] = .SMQ[SMQ$W_OPEN_JOB_COUNT] + 1;


! Return status including required output items.
!
CREATE_SRB(SRB);
IF .ITEM_PRESENT[SJC$_ENTRY_NUMBER_OUTPUT]
THEN
    BEGIN
    LOCAL
	P:		REF VECTOR[,WORD];

    P = LOCATE_SRB_OUTPUT_ITEM(
	SRB,
	SJC$_ENTRY_NUMBER_OUTPUT, VALUE_ENTRY_NUMBER_OUTPUT);
    P[0] = .SJH[SYM$L_ENTRY_NUMBER];
    COMPLETE_SRB_OUTPUT_ITEM(SRB, 2);
    END;
SEND_SERVICE_RESPONSE_MESSAGE(SRB, JBC$_NORMAL);


REWRITE_RECORD(.SJH_N);
REWRITE_RECORD(.SMQ_N);
REWRITE_RECORD(SQH$K_RECNO);
0
END;

ROUTINE SJC_CREATE_QUEUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine processes the SJC$_CREATE_QUEUE (SMR$K_INITIAL) request.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	MBX		- Pointer to buffered mailbox message.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Completion status to be returned to requestor.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	SQX_P:		REF BBLOCK,	! Pointer to predecessor of SQX
	SQX_NP,				! Record number of predecessor of SQX
	SQX:		REF BBLOCK,	! Pointer to SQX
	SQX_N,				! Record number of SQX
	SQE:		REF BBLOCK,	! Pointer to SQX entry
	SMQ_N,				! Record number of SMQ
	SMQ:		REF BBLOCK,	! Pointer to SMQ
	STATUS_1,			! Status return
	STATUS_2,			! Status return
	STATUS_3,			! Status return
	STATUS_4;			! Status return


! Ensure that the requestor has OPER privilege.
!
IF NOT .BBLOCK[MBX[ACM$Q_PRVMSK], PRV$V_OPER]
THEN
    RETURN JBC$_NOOPER;


! Read the queue header.
!
SQX_P = READ_RECORD(SQX_NP = SQH$K_RECNO);


! Create the queue record.
!
STATUS_1 = CREATE_SMQ_RECORD( ; SMQ_N, SMQ);
IF NOT .STATUS_1 THEN RETURN .STATUS_1;


! Apply options to the queue record.
!
STATUS_2 = APPLY_SMQ_OPTIONS(.SMQ);
IF NOT .STATUS_2
THEN
    BEGIN
    DELETE_SMQ_RECORD(.SMQ_N, .SMQ);
    RETURN .STATUS_2;
    END;


! Default the form if necessary.
!
IF NOT .SMQ[SMQ$V_BATCH] AND .SMQ[SMQ$L_FORM_LINK] EQL 0
THEN
    BEGIN
    LOCAL
	SFM_N;				! Record number of SFM

    IF NOT FIND_FORM_NUMBER(0; SFM_N)
    THEN
	BEGIN
	DELETE_SMQ_RECORD(.SMQ_N, .SMQ);
	RETURN JBC$_NOSUCHFORM;
	END;
    SMQ[SMQ$L_FORM_LINK] = .SFM_N;
    END;


SQX_N = .SQX_P[SQH$L_QUEUE_INDEX_LIST];
WHILE .SQX_N NEQ 0 DO
    BEGIN
    SQX = READ_RECORD(.SQX_N);
    SQE = SQX[SYM$T_DATA];
    INCR SQE_N FROM 0 TO SQX$K_ENTRIES-1 DO
	BEGIN
	IF CH$RCHAR(SQE[SQX$T_NAME]) EQL 0
	THEN
	    BEGIN
	    UPDATE_SQX_ENTRY(.SQE, .SMQ_N, .SMQ);
	    IF .ITEM_PRESENT[SJC$_CREATE_START]
	    THEN
		RETURN SJC_START_QUEUE(.SQX_N, .SQE, .SMQ_N, .SMQ)
	    ELSE
		BEGIN
		REWRITE_RECORD(.SQX_N);
		REWRITE_RECORD(.SMQ_N);
		RETURN SS$_NORMAL;
		END;
	    END
	ELSE
	    BEGIN
	    CASE CH$COMPARE(
		CH$RCHAR(SMQ[SMQ$T_NAME]), SMQ[SMQ$T_NAME]+1,
		CH$RCHAR(SQE[SQX$T_NAME]), SQE[SQX$T_NAME]+1,
		%C' ')
	    FROM -1 TO 1 OF
		SET


		[-1]:
		    BEGIN
		    LOCAL
			SQX_S:		REF BBLOCK,
			SQX_NS,
			SQX_NT,
			SQX_T:		REF BBLOCK,
			T1:		BBLOCK[SQX$S_SQX],
			T2:		BBLOCK[SQX$S_SQX],
			STATUS;


		    STATUS = ALLOCATE_RECORD( ; SQX_NT, SQX_T);
		    IF NOT .STATUS
		    THEN
			BEGIN
			DELETE_SMQ_RECORD(.SMQ_N, .SMQ);
			RETURN .STATUS;
			END;


		    UPDATE_SQX_ENTRY(T1, .SMQ_N, .SMQ);


		    WHILE TRUE DO
			BEGIN
			CH$MOVE(
			    SQX$S_SQX,
			    SQX[SYM$T_DATA] +
				(SQX$K_ENTRIES - 1) * SQX$S_SQX,
			    T2);
			CH$MOVE(
			    .SQX + SYM$S_SYM - .SQE - SQX$S_SQX,
			    .SQE,
			    .SQE + SQX$S_SQX);
			CH$MOVE(
			    SQX$S_SQX,
			    T1,
			    .SQE);
			CH$MOVE(
			    SQX$S_SQX,
			    T2,
			    T1);
			IF CH$RCHAR(T1[SQX$T_NAME]) EQL 0
			THEN
			    BEGIN
			    DEALLOCATE_RECORD(.SQX_NT);
			    EXITLOOP;
			    END;
			IF .SQX[SYM$L_LINK] EQL 0
			THEN
			    BEGIN
			    SQX[SYM$L_LINK] = .SQX_NT;
			    SQX_T[SYM$B_TYPE] = SYM$K_SQX;
			    CH$MOVE(
				SQX$S_SQX,
				T1,
				SQX_T[SYM$T_DATA]);
			    REWRITE_RECORD(.SQX_NT);
			    EXITLOOP;
			    END;
			SQX_S = READ_RECORD(SQX_NS = .SQX[SYM$L_LINK]);
			REWRITE_RECORD(.SQX_N);
			SQX_N = .SQX_NS;
			SQX = .SQX_S;
			SQE = SQX[SYM$T_DATA];
			END;


		    IF .ITEM_PRESENT[SJC$_CREATE_START]
		    THEN
			RETURN SJC_START_QUEUE(.SQX_N, .SQE, .SMQ_N, .SMQ)
		    ELSE
			BEGIN
			REWRITE_RECORD(.SQX_N);
			REWRITE_RECORD(.SMQ_N);
			RETURN SS$_NORMAL;
			END;
		    END;


		[0]:
		    BEGIN
		    LOCAL
			STATUS;


		    DELETE_SMQ_RECORD(.SMQ_N, .SMQ);


		    SMQ = READ_RECORD(SMQ_N = .SQE[SQX$L_QUEUE_LINK]);
		    IF .SMQ[SMQ$V_STOPPED] AND .SMQ[SMQ$L_STREAM_SCT] EQL 0
		    THEN
			BEGIN
			STATUS = APPLY_SMQ_OPTIONS(.SMQ);
			IF NOT .STATUS THEN RETURN .STATUS;
			UPDATE_SQX_ENTRY(.SQE, .SMQ_N, .SMQ);
			END;


		    IF .ITEM_PRESENT[SJC$_CREATE_START]
		    THEN
			RETURN SJC_START_QUEUE(.SQX_N, .SQE, .SMQ_N, .SMQ)
		    ELSE
			BEGIN
			REWRITE_RECORD(.SQX_N);
			REWRITE_RECORD(.SMQ_N);
			RETURN SS$_NORMAL;
			END;
		    END;


		[1]:
		    SQE = .SQE + SQX$S_SQX;


		TES;
	    END;
	END;


    RELEASE_RECORD(.SQX_NP);
    SQX_NP = .SQX_N;
    SQX_P = .SQX;
    SQX_N = .SQX[SYM$L_LINK];
    END;


STATUS_4 = ALLOCATE_RECORD( ; SQX_N, SQX);
IF NOT .STATUS_4
THEN
    BEGIN
    DELETE_SMQ_RECORD(.SMQ_N, .SMQ);
    RETURN .STATUS_4;
    END;


SQX[SYM$B_TYPE] = SYM$K_SQX;
SQE = SQX[SYM$T_DATA];
UPDATE_SQX_ENTRY(.SQE, .SMQ_N, .SMQ);
IF .SQX_NP EQL SQH$K_RECNO
    THEN SQX_P[SQH$L_QUEUE_INDEX_LIST] = .SQX_N
    ELSE SQX_P[SYM$L_LINK] = .SQX_N;


REWRITE_RECORD(.SQX_NP);
IF .ITEM_PRESENT[SJC$_CREATE_START]
THEN
    SJC_START_QUEUE(.SQX_N, .SQE, .SMQ_N, .SMQ)
ELSE
    BEGIN
    REWRITE_RECORD(.SQX_N);
    REWRITE_RECORD(.SMQ_N);
    SS$_NORMAL
    END
END;

ROUTINE SJC_DEASSIGN_QUEUE(SQX_N,SQE,SMQ_N,SMQ)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine processes the SJC$_DEASSIGN_QUEUE (SMR$K_REDIRECT to null)
!	request.
!
! INPUT PARAMETERS:
!	SQX_N		- Record number of SQX.
!	SQE		- Pointer to SQX entry.
!	SMQ_N		- Record number of SMQ.
!	SMQ		- Pointer to SMQ.
!
! IMPLICIT INPUTS:
!	MBX		- Pointer to buffered mailbox message.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Completion status to be returned to requestor.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	SQE:		REF BBLOCK,	! Pointer to logical SQX entry
	SMQ:		REF BBLOCK;	! Pointer to SMQ
LOCAL
	AUX_N,				! Record number of auxiliary record
	AUX:		REF BBLOCK;	! Pointer to auxiliary record


! Ensure that the requestor has E access to the queue.
!
IF NOT CHECK_E_ACCESS(.SMQ)
THEN
    RETURN JBC$_NOPRIV;


! Ensure that the queue is assigned.
!
IF .SMQ[SMQ$L_ASSIGNED_QUEUE_LINK] EQL 0
THEN
    RETURN JBC$_NOTASSIGN;


! Revoke the assignment.
!
SMQ[SMQ$L_ASSIGNED_QUEUE_LINK] = 0;
SMQ[SMQ$V_STOPPED] = TRUE;
UPDATE_SQX_ENTRY(.SQE, .SMQ_N, .SMQ);
REWRITE_RECORD(.SQX_N);
REWRITE_RECORD(.SMQ_N);


SS$_NORMAL
END;

ROUTINE SJC_DEFINE_CHARACTERISTIC=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine processes the SJC$_DEFINE_CHARACTERISTIC request.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	MBX		- Pointer to buffered mailbox message.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Completion status to be returned to requestor.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	SCX_P:		REF BBLOCK,	! Pointer to predecessor of SCX
	SCX_NP,				! Record number of predecessor of SCX
	SCX:		REF BBLOCK,	! Pointer to SCX
	SCX_N,				! Record number of SCX
	SCE:		REF BBLOCK,	! Pointer to SCX entry
	STATUS_1;			! Status return


! Ensure that the requestor has OPER privilege.
!
IF NOT .BBLOCK[MBX[ACM$Q_PRVMSK], PRV$V_OPER]
THEN
    RETURN JBC$_NOOPER;


! Read the queue header.
!
SCX_P = READ_RECORD(SCX_NP = SQH$K_RECNO);


SCX_N = .SCX_P[SQH$L_CHARACTERISTIC_LIST];
WHILE .SCX_N NEQ 0 DO
    BEGIN
    SCX = READ_RECORD(.SCX_N);
    SCE = SCX[SYM$T_DATA];
    INCR SCE_N FROM 0 TO SCX$K_ENTRIES-1 DO
	BEGIN
	IF CH$RCHAR(SCE[SCX$T_NAME]) EQL 0
	THEN
	    BEGIN
	    CH$WCHAR(
		.VALUE_CHARACTERISTIC_NAME[SDSC_W_LENGTH],
		SCE[SCX$T_NAME]);
	    CH$MOVE(
		.VALUE_CHARACTERISTIC_NAME[SDSC_W_LENGTH],
		.VALUE_CHARACTERISTIC_NAME[SDSC_A_POINTER],
		SCE[SCX$T_NAME] + 1);
	    SCE[SCX$B_NUMBER] = .VALUE_CHARACTERISTIC_NUMBER;
	    REWRITE_RECORD(.SCX_N);
	    RETURN SS$_NORMAL;
	    END
	ELSE
	    BEGIN
	    CASE CH$COMPARE(
		.VALUE_CHARACTERISTIC_NAME[SDSC_W_LENGTH],
		.VALUE_CHARACTERISTIC_NAME[SDSC_A_POINTER],
		CH$RCHAR(SCE[SCX$T_NAME]), SCE[SCX$T_NAME]+1,
		%C' ')
	    FROM -1 TO 1 OF
		SET


		[-1]:
		    BEGIN
		    LOCAL
			SCX_S:		REF BBLOCK,
			SCX_NS,
			SCX_NT,
			SCX_T:		REF BBLOCK,
			T1:		BBLOCK[SCX$S_SCX],
			T2:		BBLOCK[SCX$S_SCX],
			STATUS;


		    STATUS = ALLOCATE_RECORD( ; SCX_NT, SCX_T);
		    IF NOT .STATUS THEN RETURN .STATUS;


		    CH$FILL(0, SCX$S_SCX, T1);
		    CH$WCHAR(
			.VALUE_CHARACTERISTIC_NAME[SDSC_W_LENGTH],
			T1[SCX$T_NAME]);
		    CH$MOVE(
			.VALUE_CHARACTERISTIC_NAME[SDSC_W_LENGTH],
			.VALUE_CHARACTERISTIC_NAME[SDSC_A_POINTER],
			T1[SCX$T_NAME] + 1);
		    T1[SCX$B_NUMBER] = .VALUE_CHARACTERISTIC_NUMBER;


		    WHILE TRUE DO
			BEGIN
			CH$MOVE(
			    SCX$S_SCX,
			    SCX[SYM$T_DATA] +
				(SCX$K_ENTRIES - 1) * SCX$S_SCX,
			    T2);
			CH$MOVE(
			    .SCX + SYM$S_SYM - .SCE - SCX$S_SCX,
			    .SCE,
			    .SCE + SCX$S_SCX);
			CH$MOVE(
			    SCX$S_SCX,
			    T1,
			    .SCE);
			CH$MOVE(
			    SCX$S_SCX,
			    T2,
			    T1);
			IF CH$RCHAR(T1[SCX$T_NAME]) EQL 0
			THEN
			    BEGIN
			    REWRITE_RECORD(.SCX_N);
			    DEALLOCATE_RECORD(.SCX_NT);
			    EXITLOOP;
			    END;
			IF .SCX[SYM$L_LINK] EQL 0
			THEN
			    BEGIN
			    SCX[SYM$L_LINK] = .SCX_NT;
			    SCX_T[SYM$B_TYPE] = SYM$K_SCX;
			    CH$MOVE(
				SCX$S_SCX,
				T1,
				SCX_T[SYM$T_DATA]);
			    REWRITE_RECORD(.SCX_NT);
			    REWRITE_RECORD(.SCX_N);
			    EXITLOOP;
			    END;
			SCX_S = READ_RECORD(SCX_NS = .SCX[SYM$L_LINK]);
			REWRITE_RECORD(.SCX_N);
			SCX_N = .SCX_NS;
			SCX = .SCX_S;
			SCE = SCX[SYM$T_DATA];
			END;


		    RETURN SS$_NORMAL;
		    END;


		[0]:
		    BEGIN
		    SCE[SCX$B_NUMBER] = .VALUE_CHARACTERISTIC_NUMBER;
		    REWRITE_RECORD(.SCX_N);
		    RETURN SS$_NORMAL;
		    END;


		[1]:
		    SCE = .SCE + SCX$S_SCX;


		TES;
	    END;
	END;


    RELEASE_RECORD(.SCX_NP);
    SCX_NP = .SCX_N;
    SCX_P = .SCX;
    SCX_N = .SCX[SYM$L_LINK];
    END;


STATUS_1 = ALLOCATE_RECORD( ; SCX_N, SCX);
IF NOT .STATUS_1 THEN RETURN .STATUS_1;


SCX[SYM$B_TYPE] = SYM$K_SCX;
SCE = SCX[SYM$T_DATA];
CH$WCHAR(
    .VALUE_CHARACTERISTIC_NAME[SDSC_W_LENGTH],
    SCE[SCX$T_NAME]);
CH$MOVE(
    .VALUE_CHARACTERISTIC_NAME[SDSC_W_LENGTH],
    .VALUE_CHARACTERISTIC_NAME[SDSC_A_POINTER],
    SCE[SCX$T_NAME] + 1);
SCE[SCX$B_NUMBER] = .VALUE_CHARACTERISTIC_NUMBER;
IF .SCX_NP EQL SQH$K_RECNO
    THEN SCX_P[SQH$L_CHARACTERISTIC_LIST] = .SCX_N
    ELSE SCX_P[SYM$L_LINK] = .SCX_N;


REWRITE_RECORD(.SCX_N);
REWRITE_RECORD(.SCX_NP);
SS$_NORMAL
END;

ROUTINE SJC_DEFINE_FORM=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine processes the SJC$_DEFINE_FORM request.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	MBX		- Pointer to buffered mailbox message.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Completion status to be returned to requestor.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	SFX_P:		REF BBLOCK,	! Pointer to predecessor of SFX
	SFX_NP,				! Record number of predecessor of SFX
	SFX:		REF BBLOCK,	! Pointer to SFX
	SFX_N,				! Record number of SFX
	SFE:		REF BBLOCK,	! Pointer to SFX entry
	SFM_N,				! Record number of SFM
	SFM:		REF BBLOCK,	! Pointer to SFM
	STATUS_1,			! Status return
	STATUS_2,			! Status return
	STATUS_3,			! Status return
	STATUS_4;			! Status return


! Ensure that the requestor has OPER privilege.
!
IF NOT .BBLOCK[MBX[ACM$Q_PRVMSK], PRV$V_OPER]
THEN
    RETURN JBC$_NOOPER;


! Read the queue header.
!
SFX_P = READ_RECORD(SFX_NP = SQH$K_RECNO);


! Ensure that the form number is not duplicated.  If it is, and the name is the
! same, it is a redefinition of an existing form; process it immediately.
!
IF FIND_FORM_NUMBER(.VALUE_FORM_NUMBER; SFM_N, SFM)
THEN
    BEGIN
    IF CH$EQL(
	.VALUE_FORM_NAME[SDSC_W_LENGTH], .VALUE_FORM_NAME[SDSC_A_POINTER],
	CH$RCHAR(SFM[SFM$T_NAME]), SFM[SFM$T_NAME]+1,
	%C' ')
    THEN
	BEGIN
	LOCAL
	    STATUS;

	STATUS = APPLY_SFM_OPTIONS(.SFM);
	IF NOT .STATUS THEN RETURN .STATUS;
	REWRITE_RECORD(.SFM_N);
	RETURN SS$_NORMAL;
	END
    ELSE
	RETURN JBC$_DUPFORM;
    END;


! Create the form definition record.
!
STATUS_1 = CREATE_SFM_RECORD( ; SFM_N, SFM);
IF NOT .STATUS_1 THEN RETURN .STATUS_1;


! Apply options to the form definition record.
!
STATUS_2 = APPLY_SFM_OPTIONS(.SFM);
IF NOT .STATUS_2
THEN
    BEGIN
    DELETE_SFM_RECORD(.SFM_N, .SFM);
    RETURN .STATUS_2;
    END;


SFX_N = .SFX_P[SQH$L_FORM_INDEX_LIST];
WHILE .SFX_N NEQ 0 DO
    BEGIN
    SFX = READ_RECORD(.SFX_N);
    SFE = SFX[SYM$T_DATA];
    INCR SFE_N FROM 0 TO SFX$K_ENTRIES-1 DO
	BEGIN
	IF CH$RCHAR(SFE[SFX$T_NAME]) EQL 0
	THEN
	    BEGIN
	    UPDATE_SFX_ENTRY(.SFE, .SFM_N, .SFM);
	    REWRITE_RECORD(.SFM_N);
	    REWRITE_RECORD(.SFX_N);
	    RETURN SS$_NORMAL;
	    END
	ELSE
	    BEGIN
	    CASE CH$COMPARE(
		CH$RCHAR(SFM[SFM$T_NAME]), SFM[SFM$T_NAME]+1,
		CH$RCHAR(SFE[SFX$T_NAME]), SFE[SFX$T_NAME]+1,
		%C' ')
	    FROM -1 TO 1 OF
		SET


		[-1]:
		    BEGIN
		    LOCAL
			SFX_S:		REF BBLOCK,
			SFX_NS,
			SFX_NT,
			SFX_T:		REF BBLOCK,
			T1:		BBLOCK[SFX$S_SFX],
			T2:		BBLOCK[SFX$S_SFX],
			STATUS;


		    STATUS = ALLOCATE_RECORD( ; SFX_NT, SFX_T);
		    IF NOT .STATUS
		    THEN
			BEGIN
			DELETE_SFM_RECORD(.SFM_N, .SFM);
			RETURN .STATUS;
			END;


		    UPDATE_SFX_ENTRY(T1, .SFM_N, .SFM);


		    WHILE TRUE DO
			BEGIN
			CH$MOVE(
			    SFX$S_SFX,
			    SFX[SYM$T_DATA] +
				(SFX$K_ENTRIES - 1) * SFX$S_SFX,
			    T2);
			CH$MOVE(
			    .SFX + SYM$S_SYM - .SFE - SFX$S_SFX,
			    .SFE,
			    .SFE + SFX$S_SFX);
			CH$MOVE(
			    SFX$S_SFX,
			    T1,
			    .SFE);
			CH$MOVE(
			    SFX$S_SFX,
			    T2,
			    T1);
			IF CH$RCHAR(T1[SFX$T_NAME]) EQL 0
			THEN
			    BEGIN
			    REWRITE_RECORD(.SFX_N);
			    DEALLOCATE_RECORD(.SFX_NT);
			    EXITLOOP;
			    END;
			IF .SFX[SYM$L_LINK] EQL 0
			THEN
			    BEGIN
			    SFX[SYM$L_LINK] = .SFX_NT;
			    SFX_T[SYM$B_TYPE] = SYM$K_SFX;
			    CH$MOVE(
				SFX$S_SFX,
				T1,
				SFX_T[SYM$T_DATA]);
			    REWRITE_RECORD(.SFX_NT);
			    REWRITE_RECORD(.SFX_N);
			    EXITLOOP;
			    END;
			SFX_S = READ_RECORD(SFX_NS = .SFX[SYM$L_LINK]);
			REWRITE_RECORD(.SFX_N);
			SFX_N = .SFX_NS;
			SFX = .SFX_S;
			SFE = SFX[SYM$T_DATA];
			END;


		    REWRITE_RECORD(.SFM_N);
		    RETURN SS$_NORMAL;
		    END;


		[0]:
		    BEGIN
		    LOCAL
			STATUS;


		    DELETE_SFM_RECORD(.SFM_N, .SFM);
		    SFM = READ_RECORD(SFM_N = .SFE[SFX$L_FORM_LINK]);
		    STATUS = APPLY_SFM_OPTIONS(.SFM);
		    IF NOT .STATUS THEN RETURN .STATUS;
		    UPDATE_SFX_ENTRY(.SFE, .SFM_N, .SFM);
		    REWRITE_RECORD(.SFX_N);
		    REWRITE_RECORD(.SFM_N);
		    RETURN SS$_NORMAL;
		    END;


		[1]:
		    SFE = .SFE + SFX$S_SFX;


		TES;
	    END;
	END;


    RELEASE_RECORD(.SFX_NP);
    SFX_NP = .SFX_N;
    SFX_P = .SFX;
    SFX_N = .SFX[SYM$L_LINK];
    END;


STATUS_4 = ALLOCATE_RECORD( ; SFX_N, SFX);
IF NOT .STATUS_4
THEN
    BEGIN
    DELETE_SFM_RECORD(.SFM_N, .SFM);
    RETURN .STATUS_4;
    END;


SFX[SYM$B_TYPE] = SYM$K_SFX;
UPDATE_SFX_ENTRY(SFX[SYM$T_DATA], .SFM_N, .SFM);
IF .SFX_NP EQL SQH$K_RECNO
    THEN SFX_P[SQH$L_FORM_INDEX_LIST] = .SFX_N
    ELSE SFX_P[SYM$L_LINK] = .SFX_N;


REWRITE_RECORD(.SFM_N);
REWRITE_RECORD(.SFX_N);
REWRITE_RECORD(.SFX_NP);
SS$_NORMAL
END;

ROUTINE SJC_DELETE_CHARACTERISTIC=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine processes the SJC$_DELETE_CHARACTERISTIC request.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	MBX		- Pointer to buffered mailbox message.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Completion status to be returned to requestor.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	SCX_P:		REF BBLOCK,	! Pointer to predecessor of SCX
	SCX_NP,				! Record number of predecessor of SCX
	SCX:		REF BBLOCK,	! Pointer to SCX
	SCX_N,				! Record number of SCX
	SCE:		REF BBLOCK;	! Pointer to SCX entry


! Ensure that the requestor has OPER privilege.
!
IF NOT .BBLOCK[MBX[ACM$Q_PRVMSK], PRV$V_OPER]
THEN
    RETURN JBC$_NOOPER;


SCX_P = READ_RECORD(SCX_NP = SQH$K_RECNO);
SCX_N = .SCX_P[SQH$L_CHARACTERISTIC_LIST];
WHILE .SCX_N NEQ 0 DO
    BEGIN
    SCX = READ_RECORD(.SCX_N);
    SCE = SCX[SYM$T_DATA];
    INCR SCE_N FROM 0 TO SCX$K_ENTRIES-1 DO
	BEGIN
	IF CH$RCHAR(SCE[SCX$T_NAME]) EQL 0
	THEN
	    EXITLOOP
	ELSE
	    BEGIN
	    CASE CH$COMPARE(
		.VALUE_CHARACTERISTIC_NAME[SDSC_W_LENGTH],
		.VALUE_CHARACTERISTIC_NAME[SDSC_A_POINTER],
		CH$RCHAR(SCE[SCX$T_NAME]), SCE[SCX$T_NAME]+1,
		%C' ')
	    FROM -1 TO 1 OF
		SET


		[-1]:
		    RETURN JBC$_NOSUCHCHAR;


		[0]:
		    BEGIN
		    UPDATE_GETQUI_DATA(.SCX_N, .SCE);
		    WHILE TRUE DO
			BEGIN

			! Remove the entry pointed to by SCE.
			!
			CH$COPY(
			    .SCX + SYM$S_SYM - .SCE - SCX$S_SCX,
			    .SCE + SCX$S_SCX,
			    0,
			    .SCX + SYM$S_SYM - .SCE,
			    .SCE);


			! If the new entry pointed to by SCE is the first in
			! the block and is empty, then we removed the only
			! entry in the (last) block and it should be
			! deallocated.
			!
			IF .SCE_N EQL 0 AND CH$RCHAR(SCE[SCX$T_NAME]) EQL 0
			THEN
			    BEGIN
			    IF .SCX_NP EQL SQH$K_RECNO
				THEN SCX_P[SQH$L_CHARACTERISTIC_LIST] = 0
				ELSE SCX_P[SYM$L_LINK] = 0;
			    REWRITE_RECORD(.SCX_NP);
			    DEALLOCATE_RECORD(.SCX_N);
			    EXITLOOP;
			    END;


			! The predecessor record is now correct -- rewrite it
			! and make the current record the predecessor.
			!
			REWRITE_RECORD(.SCX_NP);
			SCX_NP = .SCX_N;
			SCX_P = .SCX;
			SCX_N = .SCX[SYM$L_LINK];


			! If there are no more blocks, then we are finished.
			!
			IF .SCX_N EQL 0
			THEN
			    BEGIN
			    REWRITE_RECORD(.SCX_NP);
			    EXITLOOP;
			    END;


			! Otherwise, we must continue shuffling.  Read the next
			! record.
			!
			SCX = READ_RECORD(.SCX_N);
			SCE = SCX[SYM$T_DATA];
			SCE_N = 0;
			CH$MOVE(
			    SCX$S_SCX,
			    .SCE,
			    SCX_P[SYM$T_DATA] +
				(SCX$K_ENTRIES - 1) * SCX$S_SCX);
			END;


		    RETURN SS$_NORMAL;
		    END;


		[1]:
		    SCE = .SCE + SCX$S_SCX;


		TES;
	    END;
	END;


    RELEASE_RECORD(.SCX_NP);
    SCX_NP = .SCX_N;
    SCX_P = .SCX;
    SCX_N = .SCX[SYM$L_LINK];
    END;


JBC$_NOSUCHCHAR
END;

ROUTINE SJC_DELETE_FORM=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine processes the SJC$_DELETE_FORM request.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	MBX		- Pointer to buffered mailbox message.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Completion status to be returned to requestor.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	SFX_P:		REF BBLOCK,	! Pointer to predecessor of SFX
	SFX_NP,				! Record number of predecessor of SFX
	SFX:		REF BBLOCK,	! Pointer to SFX
	SFX_N,				! Record number of SFX
	SFE:		REF BBLOCK;	! Pointer to SFX entry


! Ensure that the requestor has OPER privilege.
!
IF NOT .BBLOCK[MBX[ACM$Q_PRVMSK], PRV$V_OPER]
THEN
    RETURN JBC$_NOOPER;


SFX_P = READ_RECORD(SFX_NP = SQH$K_RECNO);
SFX_N = .SFX_P[SQH$L_FORM_INDEX_LIST];
WHILE .SFX_N NEQ 0 DO
    BEGIN
    SFX = READ_RECORD(.SFX_N);
    SFE = SFX[SYM$T_DATA];
    INCR SFE_N FROM 0 TO SFX$K_ENTRIES-1 DO
	BEGIN
	IF CH$RCHAR(SFE[SFX$T_NAME]) EQL 0
	THEN
	    EXITLOOP
	ELSE
	    BEGIN
	    CASE CH$COMPARE(
		.VALUE_FORM_NAME[SDSC_W_LENGTH], .VALUE_FORM_NAME[SDSC_A_POINTER],
		CH$RCHAR(SFE[SFX$T_NAME]), SFE[SFX$T_NAME]+1,
		%C' ')
	    FROM -1 TO 1 OF
		SET


		[-1]:
		    RETURN JBC$_NOSUCHFORM;


		[0]:
		    BEGIN
		    LOCAL
			SFM:		REF BBLOCK,	! Pointer to SFM
			SFM_N,				! Record number of SFM
			CTX:		BBLOCK[QSM_K_CTXSIZE],
			SJH_N,				! Record number of SJH
			SJH:		REF BBLOCK;	! Pointer to SJH


		    ! Read the form definition.
		    !
		    SFM = READ_RECORD(SFM_N = .SFE[SFX$L_FORM_LINK]);


		    ! Ensure that the form has no outstanding references.
		    !
		    IF FIND_FORM_REFERENCES(.SFM_N)
		    THEN
			RETURN JBC$_REFERENCED;


		    ! Delete the form definition.
		    !
		    DELETE_SFM_RECORD(.SFM_N, .SFM);


		    ! Remove the form index entry.
		    !
		    UPDATE_GETQUI_DATA(.SFX_N, .SFE);
		    WHILE TRUE DO
			BEGIN

			! Remove the entry pointed to by SFE.
			!
			CH$COPY(
			    .SFX + SYM$S_SYM - .SFE - SFX$S_SFX,
			    .SFE + SFX$S_SFX,
			    0,
			    .SFX + SYM$S_SYM - .SFE,
			    .SFE);


			! If the new entry pointed to by SFE is the first in
			! the block and is empty, then we removed the only
			! entry in the (last) block and it should be
			! deallocated.
			!
			IF .SFE_N EQL 0 AND CH$RCHAR(SFE[SFX$T_NAME]) EQL 0
			THEN
			    BEGIN
			    IF .SFX_NP EQL SQH$K_RECNO
				THEN SFX_P[SQH$L_FORM_INDEX_LIST] = 0
				ELSE SFX_P[SYM$L_LINK] = 0;
			    REWRITE_RECORD(.SFX_NP);
			    DEALLOCATE_RECORD(.SFX_N);
			    EXITLOOP;
			    END;


			! The predecessor record is now correct -- rewrite it
			! and make the current record the predecessor.
			!
			REWRITE_RECORD(.SFX_NP);
			SFX_NP = .SFX_N;
			SFX_P = .SFX;
			SFX_N = .SFX[SYM$L_LINK];


			! If there are no more blocks, then we are finished.
			!
			IF .SFX_N EQL 0
			THEN
			    BEGIN
			    REWRITE_RECORD(.SFX_NP);
			    EXITLOOP;
			    END;


			! Otherwise, we must continue shuffling.  Read the next
			! record.
			!
			SFX = READ_RECORD(.SFX_N);
			SFE = SFX[SYM$T_DATA];
			SFE_N = 0;
			CH$MOVE(
			    SFX$S_SFX,
			    .SFE,
			    SFX_P[SYM$T_DATA] +
				(SFX$K_ENTRIES - 1) * SFX$S_SFX);
			END;


		    RETURN SS$_NORMAL;
		    END;


		[1]:
		    SFE = .SFE + SFX$S_SFX;


		TES;
	    END;
	END;


    RELEASE_RECORD(.SFX_NP);
    SFX_NP = .SFX_N;
    SFX_P = .SFX;
    SFX_N = .SFX[SYM$L_LINK];
    END;


JBC$_NOSUCHFORM
END;

ROUTINE SJC_DELETE_JOB(SQX_N,SQE,SMQ_N,SMQ)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine processes the SJC$_DELETE_JOB (SMR$K_RMVJOB) request.
!
! INPUT PARAMETERS:
!	SMQ		- Pointer to SMQ.
!
! IMPLICIT INPUTS:
!	MBX		- Pointer to buffered mailbox message.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Completion status to be returned to requestor.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	SQE:		REF BBLOCK,	! Pointer to SQX entry
	SMQ:		REF BBLOCK;	! Pointer to SMQ
LOCAL
	SJH_N,				! Record number of SJH
	SJH:		REF BBLOCK,	! Pointer to SJH
	ESMQ_N,				! Record number of executor SMQ
	ESMQ:		REF BBLOCK,	! Pointer to executor SMQ
	STATUS_1,			! Status return
	STATUS_2;			! Status return


! Find the specified job.
!
STATUS_1 = SEARCH_QUEUES(
    QSM_M_OPEN OR QSM_M_TIMER OR QSM_M_PENDING OR QSM_M_HOLD OR QSM_M_CURRENT,
    .SMQ_N, .SMQ,
    VALUE_ENTRY_NUMBER, 0,
    CHECK_D_ACCESS,
    QSM_K_REMOVE_INACTIVE;
    SJH_N, SJH, ESMQ_N, ESMQ);
IF NOT .STATUS_1 THEN RETURN .STATUS_1;


! If the job is executing, request the executor to abort it.
!
IF .SJH[SJH$V_EXECUTING]
THEN
    BEGIN

    ! If a previous abort is in progress, refuse this request.
    !
    IF .SJH[SJH$V_ABORTING]
    OR .SJH[SJH$V_ABORTED]
    THEN
	RETURN JBC$_INCOMPLETE;


    ! Execute the actual abort.
    !
    STATUS_2 = ABORT_EXECUTOR_JOB(.ESMQ_N, .ESMQ, .SJH_N, .SJH);
    REWRITE_RECORD(.SJH_N);
    RETURN .STATUS_2;
    END;


! If the job is not executing, process the request in place.
!
IF .SJH[SJH$V_STARTING]
THEN
    BEGIN
    ESMQ[SMQ$B_CURRENT_JOB_COUNT] = .ESMQ[SMQ$B_CURRENT_JOB_COUNT] - 1;
    FIND_PENDING_JOBS(.ESMQ_N, .ESMQ);
    REWRITE_RECORD(.ESMQ_N);
    END;


SJH[SJH$V_DELETED] = TRUE;
COMPLETE_JOB(.SJH_N, .SJH, .SMQ, 0);


SS$_NORMAL
END;

ROUTINE SJC_DELETE_QUEUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine processes the SJC$_DELETE_QUEUE (SMR$K_DELETE) request.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	MBX		- Pointer to buffered mailbox message.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Completion status to be returned to requestor.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	SQX_P:		REF BBLOCK,	! Pointer to predecessor of SQX
	SQX_NP,				! Record number of predecessor of SQX
	SQX:		REF BBLOCK,	! Pointer to SQX
	SQX_N,				! Record number of SQX
	SQE:		REF BBLOCK;	! Pointer to SQX entry


! Ensure that the requestor has OPER privilege.
!
IF NOT .BBLOCK[MBX[ACM$Q_PRVMSK], PRV$V_OPER]
THEN
    RETURN JBC$_NOOPER;


SQX_P = READ_RECORD(SQX_NP = SQH$K_RECNO);
SQX_N = .SQX_P[SQH$L_QUEUE_INDEX_LIST];
WHILE .SQX_N NEQ 0 DO
    BEGIN
    SQX = READ_RECORD(.SQX_N);
    SQE = SQX[SYM$T_DATA];
    INCR SQE_N FROM 0 TO SQX$K_ENTRIES-1 DO
	BEGIN
	IF CH$RCHAR(SQE[SQX$T_NAME]) EQL 0
	THEN
	    EXITLOOP
	ELSE
	    BEGIN
	    CASE CH$COMPARE(
		.VALUE_QUEUE[SDSC_W_LENGTH], .VALUE_QUEUE[SDSC_A_POINTER],
		CH$RCHAR(SQE[SQX$T_NAME]), SQE[SQX$T_NAME]+1,
		%C' ')
	    FROM -1 TO 1 OF
		SET


		[-1]:
		    RETURN JBC$_NOSUCHQUE;


		[0]:
		    BEGIN
		    LOCAL
			SMQ:		REF BBLOCK,	! Pointer to SMQ
			SMQ_N,				! Record number of SMQ
			CTX:		BBLOCK[QSM_K_CTXSIZE],
			SJH_N,				! Record number of SJH
			SJH:		REF BBLOCK;	! Pointer to SJH


		    ! Read the queue header.
		    !
		    SMQ = READ_RECORD(SMQ_N = .SQE[SQX$L_QUEUE_LINK]);


		    ! Ensure the queue is stopped and there is no current job.
		    !
		    IF .SMQ[SMQ$B_CURRENT_JOB_COUNT] NEQ 0
		    OR NOT .SMQ[SMQ$V_STOPPED]
		    OR .SMQ[SMQ$L_STREAM_SCT] NEQ 0
		    THEN
			RETURN JBC$_REFERENCED;


		    ! Delete all jobs in queue.
		    !
		    CH$FILL(0, QSM_K_CTXSIZE, CTX);
		    WHILE SEARCH_QUEUES(
			QSM_M_OPEN OR QSM_M_TIMER OR QSM_M_PENDING OR QSM_M_HOLD,
			.SMQ_N, .SMQ,
			0, 0,
			0,
			QSM_K_REMOVE_INACTIVE,
			CTX;
			SJH_N, SJH)
		    DO
			BEGIN
			IF .SJH[SJH$V_EXECUTING] THEN RETURN JBC$_EXECUTING;
			SJH[SJH$V_DELETED] = TRUE;
			COMPLETE_JOB(.SJH_N, .SJH, .SMQ, 0);
			END;


		    ! Ensure that there are no outstanding references to the
		    ! queue.
		    !
		    IF FIND_QUEUE_REFERENCES(.SMQ_N)
		    THEN
			RETURN JBC$_REFERENCED;


		    ! Delete the queue header.
		    !
		    DELETE_SMQ_RECORD(.SMQ_N, .SMQ);


		    ! Remove the queue index entry.
		    !
		    UPDATE_GETQUI_DATA(.SQX_N, .SQE);
		    WHILE TRUE DO
			BEGIN

			! Remove the entry pointed to by SQE.
			!
			CH$COPY(
			    .SQX + SYM$S_SYM - .SQE - SQX$S_SQX,
			    .SQE + SQX$S_SQX,
			    0,
			    .SQX + SYM$S_SYM - .SQE,
			    .SQE);


			! If the new entry pointed to by SQE is the first in
			! the block and is empty, then we removed the only
			! entry in the (last) block and it should be
			! deallocated.
			!
			IF .SQE_N EQL 0 AND CH$RCHAR(SQE[SQX$T_NAME]) EQL 0
			THEN
			    BEGIN
			    IF .SQX_NP EQL SQH$K_RECNO
				THEN SQX_P[SQH$L_QUEUE_INDEX_LIST] = 0
				ELSE SQX_P[SYM$L_LINK] = 0;
			    REWRITE_RECORD(.SQX_NP);
			    DEALLOCATE_RECORD(.SQX_N);
			    EXITLOOP;
			    END;


			! The predecessor record is now correct -- rewrite it
			! and make the current record the predecessor.
			!
			REWRITE_RECORD(.SQX_NP);
			SQX_NP = .SQX_N;
			SQX_P = .SQX;
			SQX_N = .SQX[SYM$L_LINK];


			! If there are no more blocks, then we are finished.
			!
			IF .SQX_N EQL 0
			THEN
			    BEGIN
			    REWRITE_RECORD(.SQX_NP);
			    EXITLOOP;
			    END;


			! Otherwise, we must continue shuffling.  Read the next
			! record.
			!
			SQX = READ_RECORD(.SQX_N);
			SQE = SQX[SYM$T_DATA];
			SQE_N = 0;
			CH$MOVE(
			    SQX$S_SQX,
			    .SQE,
			    SQX_P[SYM$T_DATA] +
				(SQX$K_ENTRIES - 1) * SQX$S_SQX);
			END;


		    RETURN SS$_NORMAL;
		    END;


		[1]:
		    SQE = .SQE + SQX$S_SQX;


		TES;
	    END;
	END;


    RELEASE_RECORD(.SQX_NP);
    SQX_NP = .SQX_N;
    SQX_P = .SQX;
    SQX_N = .SQX[SYM$L_LINK];
    END;


JBC$_NOSUCHQUE
END;

ROUTINE SJC_ENTER_FILE(SQX_N,SQE,SMQ_N,SMQ)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine processes the SJC$_ENTER_FILE (SMR$K_ENTER) request.
!
! INPUT PARAMETERS:
!	SQX_N		- Record number of SQX.
!	SQE		- Pointer to SQX entry.
!	SMQ_N		- Record number of SMQ.
!	SMQ		- Pointer to SMQ.
!
! IMPLICIT INPUTS:
!	MBX		- Pointer to buffered mailbox message.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Completion status to be returned to requestor.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	SQE:		REF BBLOCK,	! Pointer to SQX entry
	SMQ:		REF BBLOCK;	! Pointer to SMQ
LOCAL
	SJH_N,				! Record number of SJH
	SJH:		REF BBLOCK,	! Pointer to SJH
	SQR_N,				! Record number of SQR
	SQR:		REF BBLOCK,	! Pointer to SQR
	SRB:		BBLOCK[512],	! Local service response block
	RESULT,				! Result of enqueue
	ESMQ:		REF BBLOCK,	! Pointer to executor SMQ
	STATUS_1,			! Status return
	STATUS_2,			! Status return
	STATUS_3,			! Status return
	STATUS_4;			! Status return


! Ensure that the requestor has W access to the queue.
!
IF NOT CHECK_W_ACCESS(.SMQ)
THEN
    RETURN JBC$_NOPRIV;


! Ensure that the requestor has W access to the log queue if specified.
!
IF .ITEM_PRESENT[SJC$_LOG_QUEUE]
THEN
    IF NOT CHECK_W_ACCESS(.VALUE_LOG_QUEUE[1])
    THEN
	RETURN JBC$_NOPRIV;


! Allocate the job record.
!
STATUS_1 = CREATE_SJH_RECORD(.SMQ_N, .SMQ; SJH_N, SJH);
IF NOT .STATUS_1 THEN RETURN .STATUS_1;


! Apply options to the job record.
!
STATUS_2 = APPLY_SJH_OPTIONS(.SJH);
IF NOT .STATUS_2
THEN
    BEGIN
    DELETE_SJH_RECORD(.SJH_N, .SJH);
    RETURN .STATUS_2;
    END;


! Default the form if necessary.
!
IF NOT .SMQ[SMQ$V_BATCH] AND .SJH[SJH$L_FORM_LINK] EQL 0
THEN
    BEGIN
    LOCAL
	SFM_N;				! Record number of SFM

    IF NOT FIND_FORM_NUMBER(0; SFM_N)
    THEN
	BEGIN
	DELETE_SJH_RECORD(.SJH_N, .SJH);
	RETURN JBC$_NOSUCHFORM;
	END;
    SJH[SJH$L_FORM_LINK] = .SFM_N;
    END;


! Create the file record.
!
STATUS_3 = CREATE_SQR_RECORD(.SJH; SQR_N, SQR);
IF NOT .STATUS_3
THEN
    BEGIN
    DELETE_SJH_RECORD(.SJH_N, .SJH);
    RETURN .STATUS_3;
    END;


! Apply options to the file record.
!
STATUS_4 = APPLY_SQR_OPTIONS(.SJH, .SQR);
IF NOT .STATUS_4
THEN
    BEGIN
    SQR[SQR$V_DELETE_FILE] = FALSE;
    DELETE_SJH_RECORD(.SJH_N, .SJH);
    DELETE_SQR_RECORD(.SQR_N, .SQR);
    RETURN .STATUS_4;
    END;


! Enqueue the single job file record to the job header record.
!
SQR[SYM$W_SEQUENCE] = 1;
SJH[SJH$L_FILE_LIST] = SJH[SJH$L_FILE_LIST_END] = .SQR_N;
REWRITE_RECORD(.SQR_N);


! Return the job identification.
!
RSP[RSP_W_ENTRY_NUMBER] = .SJH[SYM$L_ENTRY_NUMBER];


! Enqueue the job on the appropriate queue.
!
ENQUEUE_JOB(.SJH_N, .SJH; RESULT, ESMQ);


! Return status including required output items.
!
CREATE_SRB(SRB);
IF .ITEM_PRESENT[SJC$_ENTRY_NUMBER_OUTPUT]
THEN
    BEGIN
    LOCAL
	P:		REF VECTOR[,WORD];

    P = LOCATE_SRB_OUTPUT_ITEM(
	SRB,
	SJC$_ENTRY_NUMBER_OUTPUT, VALUE_ENTRY_NUMBER_OUTPUT);
    P[0] = .SJH[SYM$L_ENTRY_NUMBER];
    COMPLETE_SRB_OUTPUT_ITEM(SRB, 2);
    END;
IF .ITEM_PRESENT[SJC$_JOB_STATUS_OUTPUT]
THEN
    BEGIN
    COMPLETE_SRB_OUTPUT_ITEM(
	SRB,
	JOB_STATUS_MESSAGE(
	    .RESULT,
	    LOCATE_SRB_OUTPUT_ITEM(
		SRB,
		SJC$_JOB_STATUS_OUTPUT, VALUE_JOB_STATUS_OUTPUT),
	    .SMQ,
	    .SJH,
	    .ESMQ));
    END;
SEND_SERVICE_RESPONSE_MESSAGE(SRB, JBC$_NORMAL);


REWRITE_RECORD(.SJH_N);
REWRITE_RECORD(.SMQ_N);
0
END;

ROUTINE SJC_MERGE_QUEUE(SQX_N,SQE,SMQ_N,SMQ)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine processes the SJC$_MERGE_QUEUE (SMR$K_MERGE) request.
!
! INPUT PARAMETERS:
!	SQX_N		- Record number of SQX.
!	SQE		- Pointer to SQX entry.
!	SMQ_N		- Record number of SMQ.
!	SMQ		- Pointer to SMQ.
!
! IMPLICIT INPUTS:
!	MBX		- Pointer to buffered mailbox message.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Completion status to be returned to requestor.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	SQE:		REF BBLOCK,	! Pointer to SQX entry
	SMQ:		REF BBLOCK;	! Pointer to SMQ
LOCAL
	DSMQ_N,				! Record number of destination SMQ
	DSMQ:		REF BBLOCK,	! Pointer to destination SMQ
	SJH_N,				! Record number of SJH
	SJH:		REF BBLOCK,	! Pointer to SJH
	CTX:		BBLOCK[QSM_K_CTXSIZE];


! Pick up a pointer to the destination queue.
!
DSMQ_N = .VALUE_DESTINATION_QUEUE[0];
DSMQ = .VALUE_DESTINATION_QUEUE[1];


! Ensure that the requestor has E access to both queues.
!
IF NOT CHECK_E_ACCESS(.SMQ)
OR NOT CHECK_E_ACCESS(.DSMQ)
THEN
    RETURN JBC$_NOPRIV;


! Ensure that the source queue is not the same as the destination queue,
! and that the queue types are compatible.
!
IF .SMQ_N EQL .DSMQ_N
OR .SMQ[SMQ$V_BATCH] NEQ .DSMQ[SMQ$V_BATCH]
THEN
    RETURN JBC$_INCDSTQUE;


! Dequeue all jobs from the source queue and requeue them to the target queue.
!
CH$FILL(0, QSM_K_CTXSIZE, CTX);
WHILE SEARCH_QUEUES(
    QSM_M_OPEN OR QSM_M_TIMER OR QSM_M_PENDING OR QSM_M_HOLD,
    .SMQ_N, .SMQ,
    0, 0,
    0,
    QSM_K_REMOVE,
    CTX;
    SJH_N, SJH)
DO
    BEGIN
    SJH[SJH$L_QUEUE_LINK] = .DSMQ_N;
    ENQUEUE_JOB(.SJH_N, .SJH);
    REWRITE_RECORD(.SJH_N);
    END;


REWRITE_RECORD(.SMQ_N);


SS$_NORMAL
END;

ROUTINE SJC_PAUSE_QUEUE(SQX_N,SQE,SMQ_N,SMQ)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine processes the SJC$_PAUSE_QUEUE (SMR$K_PAUSE) request.
!
! INPUT PARAMETERS:
!	SQX_N		- Record number of SQX.
!	SQE		- Pointer to SQX entry.
!	SMQ_N		- Record number of SMQ.
!	SMQ		- Pointer to SMQ.
!
! IMPLICIT INPUTS:
!	MBX		- Pointer to buffered mailbox message.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Completion status to be returned to requestor.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	SQE:		REF BBLOCK,	! Pointer to SQX entry
	SMQ:		REF BBLOCK;	! Pointer to SMQ
LOCAL
	STATUS;				! Status return


! Ensure that the requestor has E access to the queue.
!
IF NOT CHECK_E_ACCESS(.SMQ)
THEN
    RETURN JBC$_NOPRIV;


! If a previous service is in progress, refuse this request.
!
IF .SMQ[SMQ$V_PAUSING]
OR .SMQ[SMQ$V_RESETTING]
OR .SMQ[SMQ$V_RESUMING]
OR .SMQ[SMQ$V_STARTING]
OR .SMQ[SMQ$V_STOPPING]
THEN
    RETURN JBC$_INCOMPLETE;


! If this is a generic or logical queue, mark the queue stopped.
!
IF .SMQ[SMQ$V_GENERIC_QUEUE]
OR .SMQ[SMQ$L_ASSIGNED_QUEUE_LINK] NEQ 0
THEN
    SMQ[SMQ$V_STOPPED] = TRUE


ELSE IF TESTBITCS(SMQ[SMQ$V_PAUSED])
THEN
    BEGIN

    ! If there are starting jobs in the queue, remove these.
    !
    REQUEUE_STARTING_JOBS(.SMQ_N, .SMQ);


    ! If there are executing jobs, pause them.
    !
    IF .SMQ[SMQ$B_CURRENT_JOB_COUNT] NEQ 0
    THEN
	BEGIN

	! If this is a remote queue, enter a remote request.  Otherwise, issue
	! the pause.
	!
	SMQ[SMQ$V_PAUSED] = FALSE;
	IF SYSID_NEQ(THIS_SYSID, SMQ[SMQ$T_SYSID])
	THEN
	    STATUS = CREATE_SRQ_RECORD(SRQ$K_PAUSE_QUEUE, .SMQ_N, .SMQ)
	ELSE
	    STATUS = PAUSE_EXECUTION(.SMQ_N, .SMQ);


	! If the pause failed, allow the queue to restart.
	!
	IF NOT .STATUS AND .STATUS NEQ 0
	THEN
	    FIND_PENDING_JOBS(.SMQ_N, .SMQ);


	REWRITE_RECORD(.SMQ_N);
	RETURN .STATUS;
	END;
    END;


REWRITE_RECORD(.SMQ_N);
SS$_NORMAL
END;

ROUTINE SJC_RESERVED_FUNC_1=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine processes the SJC$_RESERVED_FUNC_1 request.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Completion status to be returned to requestor.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN


! Ensure that the requestor has OPER privilege.
!
IF NOT .BBLOCK[MBX[ACM$Q_PRVMSK], PRV$V_OPER]
THEN
    RETURN JBC$_NOOPER;


SS$_NORMAL
END;

ROUTINE SJC_RESERVED_FUNC_2=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine processes the SJC$_RESERVED_FUNC_2 request.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Completion status to be returned to requestor.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN


! Ensure that the requestor has OPER privilege.
!
IF NOT .BBLOCK[MBX[ACM$Q_PRVMSK], PRV$V_OPER]
THEN
    RETURN JBC$_NOOPER;


SS$_NORMAL
END;

ROUTINE SJC_RESET_QUEUE(SQX_N,SQE,SMQ_N,SMQ)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine processes the SJC$_RESET_QUEUE request.
!
! INPUT PARAMETERS:
!	SQX_N		- Record number of SQX.
!	SQE		- Pointer to SQX entry.
!	SMQ_N		- Record number of SMQ.
!	SMQ		- Pointer to SMQ.
!
! IMPLICIT INPUTS:
!	MBX		- Pointer to buffered mailbox message.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Completion status to be returned to requestor.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	SQE:		REF BBLOCK,	! Pointer to SQX entry
	SMQ:		REF BBLOCK;	! Pointer to SMQ
LOCAL
	STATUS;				! Status return


! Ensure that the requestor has E access to the queue.
!
IF NOT CHECK_E_ACCESS(.SMQ)
THEN
    RETURN JBC$_NOPRIV;


! If a previous service is in progress, cancel it.
!
IF .SMQ[SMQ$V_PAUSING]
OR .SMQ[SMQ$V_RESETTING]
OR .SMQ[SMQ$V_RESUMING]
OR .SMQ[SMQ$V_STARTING]
OR .SMQ[SMQ$V_STOPPING]
THEN
    BEGIN
    SCAN_INCOMPLETE_SERVICES(ISRV_K_PURGE_SMQ, .SMQ_N);
    SMQ[SMQ$V_PAUSING] = FALSE;
    SMQ[SMQ$V_RESETTING] = FALSE;
    SMQ[SMQ$V_RESUMING] = FALSE;
    SMQ[SMQ$V_STARTING] = FALSE;
    SMQ[SMQ$V_STOPPING] = FALSE;
    END;


! If there are starting jobs in the queue, remove these.
!
SMQ[SMQ$V_STOPPED] = TRUE;
REQUEUE_STARTING_JOBS(.SMQ_N, .SMQ);


! Execute the reset.  If the queue has a symbiont or there are executing jobs,
! the reset must be done by the executor node.
!
IF SYSID_NEQ(THIS_SYSID, SMQ[SMQ$T_SYSID])
AND (.SMQ[SMQ$B_CURRENT_JOB_COUNT] NEQ 0 OR .SMQ[SMQ$L_STREAM_SCT] NEQ 0)
THEN
    BEGIN
    SMQ[SMQ$V_STOPPED] = FALSE;
    STATUS = CREATE_SRQ_RECORD(SRQ$K_RESET_QUEUE, .SMQ_N, .SMQ);
    IF .STATUS NEQ 0 THEN FIND_PENDING_JOBS(.SMQ_N, .SMQ);
    REWRITE_RECORD(.SMQ_N);
    RETURN .STATUS;
    END
ELSE
    RESET_EXECUTOR_QUEUE(.SMQ_N, .SMQ);


REWRITE_RECORD(.SMQ_N);
SS$_NORMAL
END;

ROUTINE SET_ACCOUNTING_FLAGS=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine sets bits in the accounting control flag longword.  It
!	executes in kernel mode.
!
! INPUT PARAMETERS:
!	AP contains a mask of bits to be set in the accounting flags.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	EXE$GL_ACMFLAGS updated.
!
! ROUTINE VALUE:
!	SS$_NORMAL
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
BUILTIN
	AP;


! Set the requested bits in EXE$GL_ACMFLAGS.
!
EXE$GL_ACMFLAGS = .EXE$GL_ACMFLAGS OR .AP;
SS$_NORMAL
END;

ROUTINE SJC_START_ACCOUNTING=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine processes the SJC$_START_ACCOUNTING (ACC$K_ENABACC,
!	ACC$K_ENABSEL, and ACC$K_NEWFILE) request.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	MBX		- Pointer to buffered mailbox message.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Completion status to be returned to requestor.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN

! Ensure that the requestor has OPER privilege.
!
IF NOT .BBLOCK[MBX[ACM$Q_PRVMSK], PRV$V_OPER]
THEN
    RETURN JBC$_NOOPER;


IF .ITEM_PRESENT[SJC$_ACCOUNTING_TYPES]
THEN
    $CMKRNL(ROUTIN=SET_ACCOUNTING_FLAGS, ARGLST=.VALUE_ACCOUNTING_TYPES)
ELSE
    BEGIN
    LOCAL
	FAB:		REF BBLOCK;	! Pointer to accounting FAB


    FAB = .ACCOUNTING_FABS[0];
    IF .FAB[FAB$W_IFI] EQL 0 THEN OPEN_ACCOUNTING_FILE(FALSE);
    IF .ITEM_PRESENT[SJC$_NEW_VERSION] THEN OPEN_ACCOUNTING_FILE(FALSE);
    END;


SS$_NORMAL
END;

ROUTINE SJC_START_QUEUE(SQX_N,SQE,SMQ_N,SMQ)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine processes the SJC$_START_QUEUE (SMR$K_START) request.
!
! INPUT PARAMETERS:
!	SQX_N		- Record number of SQX.
!	SQE		- Pointer to SQX entry.
!	SMQ_N		- Record number of SMQ.
!	SMQ		- Pointer to SMQ.
!
! IMPLICIT INPUTS:
!	MBX		- Pointer to buffered mailbox message.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Completion status to be returned to requestor.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	SQE:		REF BBLOCK,	! Pointer to SQX entry
	SMQ:		REF BBLOCK;	! Pointer to SMQ
LOCAL
	STATUS_1,			! Status return
	STATUS_2,			! Status return
	STATUS_3,			! Status return
	STATUS_4;			! Status return


! Ensure that the requestor has E access to the queue.
!
IF NOT CHECK_E_ACCESS(.SMQ)
THEN
    RETURN JBC$_NOPRIV;


! If a previous service is in progress, refuse this request.
!
IF .SMQ[SMQ$V_PAUSING]
OR .SMQ[SMQ$V_RESETTING]
OR .SMQ[SMQ$V_RESUMING]
OR .SMQ[SMQ$V_STARTING]
OR .SMQ[SMQ$V_STOPPING]
THEN
    RETURN JBC$_INCOMPLETE;


IF .SMQ[SMQ$V_PAUSED] AND .SMQ[SMQ$B_CURRENT_JOB_COUNT] NEQ 0
THEN
    BEGIN
    LOCAL
	FLAGS:		BBLOCK[4];	! Resume control flags


    IF NOT .SMQ[SMQ$V_BATCH]
    THEN
	IF .ITEM_PRESENT[SJC$_NEXT_JOB]
	THEN
	    BEGIN
	    SMQ[SMQ$V_PAUSED] = FALSE;
	    RETURN SJC_ABORT_JOB(.SQX_N, .SQE, .SMQ_N, .SMQ);
	    END;


    ! Compute the resume control flags.
    !
    FLAGS = 0;
    IF .ITEM_PRESENT[SJC$_ALIGNMENT_MASK]
	THEN FLAGS[ISRV_V_ALIGNMENT_MASK] = TRUE;
    IF .ITEM_PRESENT[SJC$_TOP_OF_FILE]
	THEN FLAGS[ISRV_V_TOP_OF_FILE] = TRUE;


    ! If this is a remote queue, enter a remote request.  Otherwise, issue
    ! the resume.
    !
    IF SYSID_NEQ(THIS_SYSID, SMQ[SMQ$T_SYSID])
    THEN
	STATUS_1 = CREATE_SRQ_RECORD(
	    SRQ$K_RESUME_QUEUE,
	    .SMQ_N, .SMQ,
	    .FLAGS, .VALUE_ALIGNMENT_PAGES, .VALUE_RELATIVE_PAGE,
	    .VALUE_SEARCH_STRING[SDSC_W_LENGTH],
	    .VALUE_SEARCH_STRING[SDSC_A_POINTER])
    ELSE
	STATUS_1 = RESUME_EXECUTION(
	    .SMQ_N, .SMQ,
	    .FLAGS, .VALUE_ALIGNMENT_PAGES, .VALUE_RELATIVE_PAGE,
	    .VALUE_SEARCH_STRING[SDSC_W_LENGTH],
	    .VALUE_SEARCH_STRING[SDSC_A_POINTER]);


    REWRITE_RECORD(.SMQ_N);
    RETURN .STATUS_1;
    END;


IF .SMQ[SMQ$V_STOPPED] OR .SMQ[SMQ$V_PAUSED]
THEN
    BEGIN
    IF NOT .ITEM_PRESENT[SJC$_CREATE_START]
    THEN
	BEGIN
	STATUS_2 = APPLY_SMQ_OPTIONS(.SMQ);
	IF NOT .STATUS_2 THEN RETURN .STATUS_2;
	UPDATE_SQX_ENTRY(.SQE, .SMQ_N, .SMQ);
	END;


    ! If the queue has never been started and no SYSID has been specified,
    ! default it to the current SYSID.
    !
    IF CH$RCHAR(SMQ[SMQ$T_SYSID]) EQL 0
    THEN
	COPY_SYSID(THIS_SYSID, SMQ[SMQ$T_SYSID]);


    IF .SMQ[SMQ$L_ASSIGNED_QUEUE_LINK] NEQ 0
    OR .SMQ[SMQ$V_GENERIC_QUEUE]
    OR .SMQ[SMQ$V_BATCH]
    OR .SMQ[SMQ$L_STREAM_SCT] NEQ 0
    THEN
	BEGIN
	SMQ[SMQ$V_STOPPED] = SMQ[SMQ$V_PAUSED] = FALSE;
	FIND_PENDING_JOBS(.SMQ_N, .SMQ);
	REWRITE_RECORD(.SQX_N);
	REWRITE_RECORD(.SMQ_N);
	RETURN SS$_NORMAL;
	END;


    SMQ[SMQ$V_LOWERCASE] = FALSE;
    SMQ[SMQ$V_REMOTE] = FALSE;
    SMQ[SMQ$V_SERVER] = FALSE;
    SMQ[SMQ$V_STALLED] = FALSE;
    SMQ[SMQ$V_TERMINAL] = FALSE;
    SMQ[SMQ$V_UNAVAILABLE] = FALSE;
    IF SYSID_NEQ(THIS_SYSID, SMQ[SMQ$T_SYSID])
    THEN
	STATUS_3 = CREATE_SRQ_RECORD(SRQ$K_START_QUEUE, .SMQ_N, .SMQ)
    ELSE
	BEGIN
	STATUS_3 = CREATE_SRQ_RECORD(SRQ$K_START_SYMBIONT, .SMQ_N, .SMQ);
	IF .STATUS_3 EQL 0
	THEN
	    BEGIN
	    STATUS_4 = START_SYMBIONT_STREAM(.SMQ_N, .SMQ);
	    IF NOT .STATUS_4
	    THEN
		SCAN_INCOMPLETE_SERVICES(
		    ISRV_K_SYMBIONT,
		    .SMQ_N, .SMQ,
		    SRQ$K_START_SYMBIONT,
		    .STATUS_4);
	    END;
	END;
    REWRITE_RECORD(.SQX_N);
    REWRITE_RECORD(.SMQ_N);
    RETURN .STATUS_3;
    END;


REWRITE_RECORD(.SQX_N);
REWRITE_RECORD(.SMQ_N);


IF NOT .ITEM_PRESENT[SJC$_CREATE_START] THEN RETURN JBC$_STARTED;
SS$_NORMAL
END;

ROUTINE SJC_START_QUEUE_MANAGER=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine processes the SJC$_START_QUEUE_MANAGER request.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	MBX		- Pointer to buffered mailbox message.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Completion status to be returned to requestor.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	INIT_LKSB:	VECTOR[4,WORD],	! Initialization lock status block
	STATUS_1,			! Status return
	STATUS_2;			! Status return


! Ensure that the requestor has OPER privilege.
!
IF NOT .BBLOCK[MBX[ACM$Q_PRVMSK], PRV$V_OPER]
THEN
    RETURN JBC$_NOOPER;


! Ensure that the requestor has SYSNAM privilege.
!
IF NOT .BBLOCK[MBX[ACM$Q_PRVMSK], PRV$V_SYSNAM]
THEN
    RETURN JBC$_NOSYSNAM;


! Ensure that the queue file is not already open.
!
IF .QUEUE_FAB[FAB$W_IFI] NEQ 0
THEN
    RETURN JBC$_JOBQUEENA;

CH$FILL(0, DIAG_STORAGE_END - DIAG_STORAGE_BASE, DIAG_STORAGE_BASE);


! Take out the job controller initialization lock, which interlocks the
! queue file open and reconstruction processing.
!
STATUS_1 = $ENQW(
    EFN=JBC$K_SYNC_EFN,
    LKMODE=LCK$K_EXMODE,
    LKSB=INIT_LKSB,
    RESNAM=$DESCRIPTOR('JBC$INITIALIZE'));
IF .STATUS_1 THEN STATUS_1 = .INIT_LKSB[0];
IF NOT .STATUS_1 THEN RETURN .STATUS_1;


! Get the system ID.
!
COPY_SYSID(SCS$GB_NODENAME, THIS_SYSID);


! Do the actual initialization.
!
STATUS_2 = INITIALIZE_QUEUE_FILE();


! Release the initialization lock.
!
$DEQ(LKID=.(INIT_LKSB[2]));


! Return status.
!
.STATUS_2
END;

ROUTINE CLEAR_ACCOUNTING_FLAGS=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine clears bits in the accounting control flag longword.  It
!	executes in kernel mode.
!
! INPUT PARAMETERS:
!	AP contains a mask of bits to be cleared in the accounting flags.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	EXE$GL_ACMFLAGS updated.
!
! ROUTINE VALUE:
!	SS$_NORMAL
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
BUILTIN
	AP;


! Clear the requested bits in EXE$GL_ACMFLAGS.
!
EXE$GL_ACMFLAGS = .EXE$GL_ACMFLAGS AND NOT .AP;
SS$_NORMAL
END;

ROUTINE SJC_STOP_ACCOUNTING=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine processes the SJC$_STOP_ACCOUNTING (ACC$K_DISAACC and
!	ACC$K_DISASEL) request.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	MBX		- Pointer to buffered mailbox message.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Completion status to be returned to requestor.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN

! Ensure that the requestor has OPER privilege.
!
IF NOT .BBLOCK[MBX[ACM$Q_PRVMSK], PRV$V_OPER]
THEN
    RETURN JBC$_NOOPER;


IF .ITEM_PRESENT[SJC$_ACCOUNTING_TYPES]
THEN
    $CMKRNL(ROUTIN=CLEAR_ACCOUNTING_FLAGS, ARGLST=.VALUE_ACCOUNTING_TYPES)
ELSE
    CLOSE_ACCOUNTING_FILE();


SS$_NORMAL
END;

ROUTINE SJC_STOP_QUEUE(SQX_N,SQE,SMQ_N,SMQ)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine processes the SJC$_STOP_QUEUE (SMR$K_STOP) request.
!
! INPUT PARAMETERS:
!	SQX_N		- Record number of SQX.
!	SQE		- Pointer to SQX entry.
!	SMQ_N		- Record number of SMQ.
!	SMQ		- Pointer to SMQ.
!
! IMPLICIT INPUTS:
!	MBX		- Pointer to buffered mailbox message.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Completion status to be returned to requestor.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	SQE:		REF BBLOCK,	! Pointer to SQX entry
	SMQ:		REF BBLOCK;	! Pointer to SMQ
LOCAL
	STATUS;				! Status return


! Ensure that the requestor has E access to the queue.
!
IF NOT CHECK_E_ACCESS(.SMQ)
THEN
    RETURN JBC$_NOPRIV;


! If a previous service is in progress, refuse this request.
!
IF .SMQ[SMQ$V_PAUSING]
OR .SMQ[SMQ$V_RESETTING]
OR .SMQ[SMQ$V_RESUMING]
OR .SMQ[SMQ$V_STARTING]
OR .SMQ[SMQ$V_STOPPING]
THEN
    RETURN JBC$_INCOMPLETE;


! If the queue is not already stopped, mark it stopped.
!
IF TESTBITCS(SMQ[SMQ$V_STOPPED])
THEN
    BEGIN

    ! If there are starting jobs in the queue, remove these.
    !
    REQUEUE_STARTING_JOBS(.SMQ_N, .SMQ);


    ! If there is a symbiont, and there are no executing jobs, stop it.
    !
    IF .SMQ[SMQ$L_STREAM_SCT] NEQ 0
    AND .SMQ[SMQ$B_CURRENT_JOB_COUNT] EQL 0
    THEN
	BEGIN

	! If this is a remote queue, enter a remote request.  Otherwise, issue
	! the stop.
	!
	SMQ[SMQ$V_STOPPED] = FALSE;
	IF SYSID_NEQ(THIS_SYSID, SMQ[SMQ$T_SYSID])
	THEN
	    BEGIN
	    STATUS = CREATE_SRQ_RECORD(SRQ$K_STOP_QUEUE, .SMQ_N, .SMQ);
	    IF .STATUS NEQ 0 THEN FIND_PENDING_JOBS(.SMQ_N, .SMQ);
	    REWRITE_RECORD(.SMQ_N);
	    RETURN .STATUS;
	    END
	ELSE
	    STOP_SYMBIONT_STREAM(.SMQ_N, .SMQ);
	END;
    END;


REWRITE_RECORD(.SMQ_N);
SS$_NORMAL
END;

ROUTINE SJC_STOP_QUEUE_MANAGER=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine processes the SJC$_STOP_QUEUE_MANAGER request.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	MBX		- Pointer to buffered mailbox message.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Completion status to be returned to requestor.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	SQX:		REF BBLOCK,	! Pointer to SQX
	SQX_N,				! Record number of SQX
	SQX_NS,				! Record number of successor of SQX
	SQE:		REF BBLOCK,	! Pointer to SQX entry
	SMQ_N,				! Record number of SMQ
	SMQ:		REF BBLOCK;	! Pointer to SMQ


! Ensure that the requestor has OPER privilege.
!
IF NOT .BBLOCK[MBX[ACM$Q_PRVMSK], PRV$V_OPER]
THEN
    RETURN JBC$_NOOPER;


! Ensure that the requestor has SYSNAM privilege.
!
IF NOT .BBLOCK[MBX[ACM$Q_PRVMSK], PRV$V_SYSNAM]
THEN
    RETURN JBC$_NOSYSNAM;


IF .QUEUE_FAB[FAB$W_IFI] NEQ 0
THEN
    BEGIN

    ! Scan the queue index.
    !
    SQX = READ_RECORD(SQH$K_RECNO);
    SQX_N = .SQX[SQH$L_QUEUE_INDEX_LIST];
    RELEASE_RECORD(SQH$K_RECNO);
    WHILE .SQX_N NEQ 0 DO
	BEGIN

	! Read the queue index record.
	!
	SQX = READ_RECORD(.SQX_N);


	! Scan the queue index record.
	!
	SQE = SQX[SYM$T_DATA];
	INCR SQE_N FROM 0 TO SQX$K_ENTRIES-1 DO
	    BEGIN
	    IF CH$RCHAR(SQE[SQX$T_NAME]) EQL 0
	    THEN
		EXITLOOP
	    ELSE
		BEGIN
		IF .SQE[SQX$V_EXECUTOR]
		THEN
		    BEGIN
		    SMQ = READ_RECORD(SMQ_N = .SQE[SQX$L_QUEUE_LINK]);
		    IF SYSID_EQL(THIS_SYSID, SMQ[SMQ$T_SYSID])
		    THEN
			BEGIN
			LOCAL
			    SJH_N,			! Record number of SJH
			    SJH_NS,			! Record number of successor
			    SJH:	REF BBLOCK;	! Pointer to SJH


			! Take an extra lock on the queue header and execute
			! a STOP/NEXT.
			!
			READ_RECORD(.SMQ_N);
			SJC_STOP_QUEUE(.SQX_N, .SQE, .SMQ_N, .SMQ);
			SMQ[SMQ$V_STOPPED] = TRUE;


			! Execute a STOP/REQUEUE on each restartable job, and a
			! STOP/ABORT on each nonrestartable job.
			!
			SJH_N = .SMQ[SMQ$L_CURRENT_LIST];
			WHILE .SJH_N NEQ 0 DO
			    BEGIN
			    SJH = READ_RECORD(.SJH_N);
			    SJH_NS = .SJH[SYM$L_LINK];
			    IF NOT .SJH[SJH$V_ABORTING]
			    AND NOT .SJH[SJH$V_ABORTED]
			    THEN
				BEGIN
				IF .SJH[SJH$V_RESTART]
				THEN
				    BEGIN
				    SJH[SJH$V_REQUEUE] = TRUE;
				    SJH[SJH$V_REQUEUE_HOLD] = FALSE;
				    SJH[SJH$B_REQUEUE_PRIORITY] = .SJH[SJH$B_PRIORITY];
				    SJH[SJH$L_REQUEUE_QUEUE_LINK] = 0;
				    END;
				ABORT_EXECUTOR_JOB(.SMQ_N, .SMQ, .SJH_N, .SJH);
				END;
			    REWRITE_RECORD(.SJH_N);
			    SJH_N = .SJH_NS;
			    END;
			REWRITE_RECORD(.SMQ_N);
			END
		    ELSE
			RELEASE_RECORD(.SMQ_N);
		    END;
		END;


	    SQE = .SQE + SQX$S_SQX;
	    END;


	! Advance to the next index block.
	!
	SQX_NS = .SQX[SYM$L_LINK];
	RELEASE_RECORD(.SQX_N);
	SQX_N = .SQX_NS;
	END;


    QUEUE_REFERENCE_COUNT = .QUEUE_REFERENCE_COUNT - 1;
    END;


SS$_NORMAL
END;

ROUTINE SJC_SYNCHRONIZE_JOB(SQX_N,SQE,SMQ_N,SMQ)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine processes the SJC$_SYNCHRONIZE_JOB (SMR$K_SYNCJOB) request.
!
! INPUT PARAMETERS:
!	SQX_N		- Record number of SQX.
!	SQE		- Pointer to SQX entry.
!	SMQ_N		- Record number of SMQ.
!	SMQ		- Pointer to SMQ.
!
! IMPLICIT INPUTS:
!	MBX		- Pointer to buffered mailbox message.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Completion status to be returned to requestor.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	SQE:		REF BBLOCK,	! Pointer to SQX entry
	SMQ:		REF BBLOCK;	! Pointer to SMQ
LOCAL
	SJH_N,				! Record number of SJH
	SJH:		REF BBLOCK,	! Pointer to SJH
	STATUS_1,			! Status return
	STATUS_2;			! Status return


! Ensure that one of the job ID or the job name is specified.
!
IF NOT .ITEM_PRESENT[SJC$_ENTRY_NUMBER] AND NOT .ITEM_PRESENT[SJC$_JOB_NAME]
THEN
    RETURN JBC$_MISREQPAR;


! Locate the job to be synchronized on.
!
STATUS_1 = SEARCH_QUEUES(
    QSM_M_TIMER OR QSM_M_PENDING OR QSM_M_HOLD OR QSM_M_CURRENT,
    .SMQ_N, .SMQ,
    (IF .ITEM_PRESENT[SJC$_ENTRY_NUMBER] THEN VALUE_ENTRY_NUMBER ELSE 0),
    VALUE_JOB_NAME,
    CHECK_R_ACCESS,
    QSM_K_NO_REMOVE;
    SJH_N, SJH);
IF NOT .STATUS_1 THEN RETURN .STATUS_1;


! Enqueue the SYNCHRONIZE request.
!
STATUS_2 = CREATE_SRQ_RECORD(SRQ$K_SYNCHRONIZE_JOB, .SJH_N, .SJH);
REWRITE_RECORD(.SJH_N);


.STATUS_2
END;

ROUTINE SJC_WRITE_ACCOUNTING=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine processes the SJC$_WRITE_ACCOUNTING (ACC$K_INSMESG)
!	request.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	MBX		- Pointer to buffered mailbox message.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Completion status to be returned to requestor.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	SJH_N,				! Record number of SJH
	SMQ_N,				! Record number of SMQ
	LENGTH;				! Length of message


IF
    BEGIN
    IF .BITVECTOR[MBX[ACM$L_STS], $BITPOSITION(PCB$V_BATCH)]
    THEN
	FIND_PROCESS_DATA(
	    PDE_K_BATCH, .MBX[ACM$L_PID], FALSE;
	    , SMQ_N, SJH_N)
    ELSE
	FALSE
    END
THEN
    BEGIN
    LOCK_QUEUE_FILE();
    WRITE_USER_ACCOUNTING_RECORD(
	.MBX,
	READ_RECORD(.SJH_N), READ_RECORD(.SMQ_N),
	.VALUE_ACCOUNTING_MESSAGE[SDSC_W_LENGTH],
	.VALUE_ACCOUNTING_MESSAGE[SDSC_A_POINTER]);
    UNLOCK_QUEUE_FILE();
    END
ELSE
    BEGIN
    WRITE_USER_ACCOUNTING_RECORD(
	.MBX,
	0, 0,
	.VALUE_ACCOUNTING_MESSAGE[SDSC_W_LENGTH],
	.VALUE_ACCOUNTING_MESSAGE[SDSC_A_POINTER]);
    END;


SS$_NORMAL
END;

ROUTINE PROCESS_ONE_OPTION(CODE,VALUE_SIZE,VALUE_ADDRESS)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine validates and stores one parameter value for the $SNDSMB
!	and $SNDJBC services.
!
! INPUT PARAMETERS:
!	CODE		- $SNDJBC item code.
!	VALUE_SIZE	- Length of item value.
!	VALUE_ADDRESS	- Address of item value.
!
! IMPLICIT INPUTS:
!	MBX		- Pointer to buffered mailbox message.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	Values in the item list in internal storage.
!
! ROUTINE VALUE:
!	Completion status.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	VALUE_ADDRESS:	REF BBLOCK;	! Pointer to parameter value


MACRO
	VALUE_OFFSET_(A)=
	    A - VALUE_STORAGE_BASE %;


OWN
	REQUIRED_VALUE_SIZE:
	    VECTOR[MAX_SNDJBC_ITEM+1,WORD,SIGNED] PSECT(CODE) PRESET(
		[SJC$_ACCOUNTING_MESSAGE]=	-255,
		[SJC$_ACCOUNTING_TYPES]=	4,
		[SJC$_ACCOUNT_NAME]=		-(ACM$S_ACCOUNT),
		[SJC$_AFTER_TIME]=		SJH$S_TIME,
		[SJC$_ALIGNMENT_PAGES]=		4,
		[SJC$_BASE_PRIORITY]=		4,
		[SJC$_BATCH_INPUT]=		0,
		[SJC$_BATCH_OUTPUT]=		0,
		[SJC$_BUFFER_COUNT]=		4,
		[SJC$_CHARACTERISTIC_NAME]=	0,
		[SJC$_CHARACTERISTIC_NUMBER]=	4,
		[SJC$_CHECKPOINT_DATA]=		-255,
		[SJC$_CLI]=			-(SJH$S_CLI-1),
		[SJC$_CPU_DEFAULT]=		4,
		[SJC$_CPU_LIMIT]=		4,
		[SJC$_DESTINATION_QUEUE]=	0,
		[SJC$_DEVICE_NAME]=		-(SMQ$S_DEVICE_NAME-1),
		[SJC$_EXTEND_QUANTITY]=		4,
		[SJC$_ENTRY_NUMBER]=		4,
		[SJC$_ENTRY_NUMBER_OUTPUT]=	4,
		[SJC$_FILE_COPIES]=		4,
		[SJC$_FILE_IDENTIFICATION]=	0,
		[SJC$_FILE_SETUP_MODULES]=	0,
		[SJC$_FILE_SPECIFICATION]=	-(SQR$S_FILE_SPECIFICATION-1),
		[SJC$_FIRST_PAGE]=		4,
		[SJC$_FORM_DESCRIPTION]=	-(SFM$S_DESCRIPTION-1),
		[SJC$_FORM_LENGTH]=		4,
		[SJC$_FORM_MARGIN_BOTTOM]=	4,
		[SJC$_FORM_MARGIN_LEFT]=	4,
		[SJC$_FORM_MARGIN_RIGHT]=	4,
		[SJC$_FORM_MARGIN_TOP]=		4,
		[SJC$_FORM_NAME]=		0,
		[SJC$_FORM_NUMBER]=		4,
		[SJC$_FORM_SETUP_MODULES]=	0,
		[SJC$_FORM_STOCK]=		0,
		[SJC$_FORM_WIDTH]=		4,
		[SJC$_GENERIC_TARGET]=		0,
		[SJC$_JOB_COPIES]=		4,
		[SJC$_JOB_LIMIT]=		4,
		[SJC$_JOB_NAME]=		-(SJH$S_NAME-1),
		[SJC$_JOB_RESET_MODULES]=	0,
		[SJC$_JOB_SIZE_MAXIMUM]=	4,
		[SJC$_JOB_SIZE_MINIMUM]=	4,
		[SJC$_JOB_STATUS_OUTPUT]=	0,
		[SJC$_LAST_PAGE]=		4,
		[SJC$_LIBRARY_SPECIFICATION]=	-(SMQ$S_LIBRARY-1),
		[SJC$_LOG_QUEUE]=		0,
		[SJC$_LOG_SPECIFICATION]=	0,
		[SJC$_NOTE]=			0,
		[SJC$_OPERATOR_REQUEST]=	0,
		[SJC$_OWNER_UIC]=		4,
		[SJC$_PAGE_SETUP_MODULES]=	0,
		[SJC$_PARAMETER_1]=		-(JBC$K_MAXPARSIZ),
		[SJC$_PARAMETER_2]=		-(JBC$K_MAXPARSIZ),
		[SJC$_PARAMETER_3]=		-(JBC$K_MAXPARSIZ),
		[SJC$_PARAMETER_4]=		-(JBC$K_MAXPARSIZ),
		[SJC$_PARAMETER_5]=		-(JBC$K_MAXPARSIZ),
		[SJC$_PARAMETER_6]=		-(JBC$K_MAXPARSIZ),
		[SJC$_PARAMETER_7]=		-(JBC$K_MAXPARSIZ),
		[SJC$_PARAMETER_8]=		-(JBC$K_MAXPARSIZ),
		[SJC$_PRIORITY]=		4,
		[SJC$_PROCESSOR]=		-(SMQ$S_PROCESSOR-1),
		[SJC$_PROTECTION]=		4,
		[SJC$_QUEUE]=			0,
		[SJC$_QUEUE_FILE_SPECIFICATION]=-255,
		[SJC$_RELATIVE_PAGE]=		4,
		[SJC$_RESERVED_INPUT_1]=	4,
		[SJC$_RESERVED_INPUT_2]=	4,
		[SJC$_RESERVED_INPUT_3]=	4,
		[SJC$_RESERVED_INPUT_4]=	-255,
		[SJC$_RESERVED_OUTPUT_1]=	0,
		[SJC$_RESERVED_OUTPUT_2]=	0,
		[SJC$_SCSNODE_NAME]=		SMQ$S_SYSID,
		[SJC$_SEARCH_STRING]=		-(SRQ$S_P5-1),
		[SJC$_UIC]=			4,
		[SJC$_USERNAME]=		-(ACM$S_USERNAME),
		[SJC$_USER_IDENTIFICATION]=	$BYTEOFFSET(ACM$B_PROCPRI) + 1 - $BYTEOFFSET(ACM$L_UIC),
		[SJC$_WSDEFAULT]=		4,
		[SJC$_WSEXTENT]=		4,
		[SJC$_WSQUOTA]=			4);


LITERAL
	K_ACCOUNTING_TYPES=		0,
	K_ACCOUNT_NAME=			1,
	K_AFTER_TIME=			2,
	K_ALIGNMENT_PAGES=		3,
	K_BASE_PRIORITY=		4,
	K_BUFFER_COUNT=			5,
	K_CHARACTERISTIC_NAME=		6,
	K_CHARACTERISTIC_NUMBER=	7,
	K_DESTINATION_QUEUE_NAME=	8,
	K_FILE_IDENTIFICATION=		9,
	K_FORM_NAME=			10,
	K_FORM_NUMBER=			11,
	K_GENERIC_TARGET=		12,
	K_OUTPUT_ITEM=			13,
	K_OWNERSHIP=			14,
	K_PRIORITY=			15,
	K_QUEUE_NAME=			16,
	K_STRING=			17,
	K_UIC=				18,
	K_USERNAME=			19,
	K_USER_IDENTIFICATION=		20,
	K_VALUE=			21,
	K_VALUE_NOT_0=			22,
	K_VALUE_0_TO_255=		23,
	K_VALUE_1_TO_255=		24,
	K_VALUE_0_TO_65535=		25,
	K_VALUE_1_TO_65535=		26;

OWN
	VALUE_STORAGE_CASE:
	    VECTOR[MAX_SNDJBC_ITEM+1,BYTE] PSECT(CODE) PRESET(
		[SJC$_ACCOUNTING_MESSAGE]=	K_STRING,
		[SJC$_ACCOUNTING_TYPES]=	K_ACCOUNTING_TYPES,
		[SJC$_ACCOUNT_NAME]=		K_ACCOUNT_NAME,
		[SJC$_AFTER_TIME]=		K_AFTER_TIME,
		[SJC$_ALIGNMENT_PAGES]=		K_ALIGNMENT_PAGES,
		[SJC$_BASE_PRIORITY]=		K_BASE_PRIORITY,
		[SJC$_BATCH_INPUT]=		K_STRING,
		[SJC$_BATCH_OUTPUT]=		K_OUTPUT_ITEM,
		[SJC$_BUFFER_COUNT]=		K_BUFFER_COUNT,
		[SJC$_CHARACTERISTIC_NAME]=	K_CHARACTERISTIC_NAME,
		[SJC$_CHARACTERISTIC_NUMBER]=	K_CHARACTERISTIC_NUMBER,
		[SJC$_CHECKPOINT_DATA]=		K_STRING,
		[SJC$_CLI]=			K_STRING,
		[SJC$_CPU_DEFAULT]=		K_VALUE,
		[SJC$_CPU_LIMIT]=		K_VALUE,
		[SJC$_DESTINATION_QUEUE]=	K_DESTINATION_QUEUE_NAME,
		[SJC$_DEVICE_NAME]=		K_STRING,
		[SJC$_ENTRY_NUMBER]=		K_VALUE,
		[SJC$_ENTRY_NUMBER_OUTPUT]=	K_OUTPUT_ITEM,
		[SJC$_EXTEND_QUANTITY]=		K_VALUE_0_TO_65535,
		[SJC$_FILE_COPIES]=		K_VALUE_1_TO_255,
		[SJC$_FILE_IDENTIFICATION]=	K_FILE_IDENTIFICATION,
		[SJC$_FILE_SETUP_MODULES]=	K_STRING,
		[SJC$_FILE_SPECIFICATION]=	K_STRING,
		[SJC$_FIRST_PAGE]=		K_VALUE_NOT_0,
		[SJC$_FORM_DESCRIPTION]=	K_STRING,
		[SJC$_FORM_LENGTH]=		K_VALUE_1_TO_255,
		[SJC$_FORM_MARGIN_BOTTOM]=	K_VALUE_0_TO_255,
		[SJC$_FORM_MARGIN_LEFT]=	K_VALUE_0_TO_65535,
		[SJC$_FORM_MARGIN_RIGHT]=	K_VALUE_0_TO_255,
		[SJC$_FORM_MARGIN_TOP]=		K_VALUE_0_TO_65535,
		[SJC$_FORM_NAME]=		K_FORM_NAME,
		[SJC$_FORM_NUMBER]=		K_FORM_NUMBER,
		[SJC$_FORM_SETUP_MODULES]=	K_STRING,
		[SJC$_FORM_STOCK]=		K_FORM_NAME,
		[SJC$_FORM_WIDTH]=		K_VALUE_1_TO_65535,
		[SJC$_GENERIC_TARGET]=		K_GENERIC_TARGET,
		[SJC$_JOB_COPIES]=		K_VALUE_1_TO_255,
		[SJC$_JOB_LIMIT]=		K_VALUE_1_TO_255,
		[SJC$_JOB_NAME]=		K_STRING,
		[SJC$_JOB_RESET_MODULES]=	K_STRING,
		[SJC$_JOB_SIZE_MAXIMUM]=	K_VALUE_NOT_0,
		[SJC$_JOB_SIZE_MINIMUM]=	K_VALUE_NOT_0,
		[SJC$_JOB_STATUS_OUTPUT]=	K_OUTPUT_ITEM,
		[SJC$_LAST_PAGE]=		K_VALUE_NOT_0,
		[SJC$_LIBRARY_SPECIFICATION]=	K_STRING,
		[SJC$_LOG_QUEUE]=		K_DESTINATION_QUEUE_NAME,
		[SJC$_LOG_SPECIFICATION]=	K_STRING,
		[SJC$_NOTE]=			K_STRING,
		[SJC$_OPERATOR_REQUEST]=	K_STRING,
		[SJC$_OWNER_UIC]=		K_OWNERSHIP,
		[SJC$_PAGE_SETUP_MODULES]=	K_STRING,
		[SJC$_PARAMETER_1]=		K_STRING,
		[SJC$_PARAMETER_2]=		K_STRING,
		[SJC$_PARAMETER_3]=		K_STRING,
		[SJC$_PARAMETER_4]=		K_STRING,
		[SJC$_PARAMETER_5]=		K_STRING,
		[SJC$_PARAMETER_6]=		K_STRING,
		[SJC$_PARAMETER_7]=		K_STRING,
		[SJC$_PARAMETER_8]=		K_STRING,
		[SJC$_PRIORITY]=		K_PRIORITY,
		[SJC$_PROCESSOR]=		K_STRING,
		[SJC$_PROTECTION]=		K_OWNERSHIP,
		[SJC$_QUEUE]=			K_QUEUE_NAME,
		[SJC$_QUEUE_FILE_SPECIFICATION]=K_STRING,
		[SJC$_RELATIVE_PAGE]=		K_VALUE,
		[SJC$_RESERVED_INPUT_1]=	K_VALUE_0_TO_255,
		[SJC$_RESERVED_INPUT_2]=	K_VALUE_0_TO_65535,
		[SJC$_RESERVED_INPUT_3]=	K_VALUE,
		[SJC$_RESERVED_INPUT_4]=	K_STRING,
		[SJC$_RESERVED_OUTPUT_1]=	K_OUTPUT_ITEM,
		[SJC$_RESERVED_OUTPUT_2]=	K_OUTPUT_ITEM,
		[SJC$_SCSNODE_NAME]=		K_VALUE,
		[SJC$_SEARCH_STRING]=		K_STRING,
		[SJC$_UIC]=			K_UIC,
		[SJC$_USERNAME]=		K_USERNAME,
		[SJC$_USER_IDENTIFICATION]=	K_USER_IDENTIFICATION,
		[SJC$_WSDEFAULT]=		K_VALUE_1_TO_65535,
		[SJC$_WSEXTENT]=		K_VALUE_1_TO_65535,
		[SJC$_WSQUOTA]=			K_VALUE_1_TO_65535);


OWN
	VALUE_STORAGE_OFFSET:
	    VECTOR[MAX_SNDJBC_ITEM+1,WORD,SIGNED] PSECT(CODE) PRESET(
		[SJC$_ACCOUNTING_MESSAGE]=	VALUE_OFFSET_(VALUE_ACCOUNTING_MESSAGE),
		[SJC$_ACCOUNTING_TYPES]=	VALUE_OFFSET_(VALUE_ACCOUNTING_TYPES),
		[SJC$_AFTER_TIME]=		VALUE_OFFSET_(VALUE_AFTER_TIME),
		[SJC$_ALIGNMENT_PAGES]=		VALUE_OFFSET_(VALUE_ALIGNMENT_PAGES),
		[SJC$_BASE_PRIORITY]=		VALUE_OFFSET_(VALUE_BASE_PRIORITY),
		[SJC$_BATCH_INPUT]=		VALUE_OFFSET_(VALUE_BATCH_INPUT),
		[SJC$_BATCH_OUTPUT]=		VALUE_OFFSET_(VALUE_BATCH_OUTPUT),
		[SJC$_BUFFER_COUNT]=		VALUE_OFFSET_(VALUE_BUFFER_COUNT),
		[SJC$_CHARACTERISTIC_NAME]=	VALUE_OFFSET_(VALUE_CHARACTERISTIC_NAME),
		[SJC$_CHARACTERISTIC_NUMBER]=	VALUE_OFFSET_(VALUE_CHARACTERISTIC_NUMBER),
		[SJC$_CHECKPOINT_DATA]=		VALUE_OFFSET_(VALUE_CHECKPOINT_DATA),
		[SJC$_CLI]=			VALUE_OFFSET_(VALUE_CLI),
		[SJC$_CPU_DEFAULT]=		VALUE_OFFSET_(VALUE_CPU_DEFAULT),
		[SJC$_CPU_LIMIT]=		VALUE_OFFSET_(VALUE_CPU_LIMIT),
		[SJC$_DESTINATION_QUEUE]=	VALUE_OFFSET_(VALUE_DESTINATION_QUEUE),
		[SJC$_DEVICE_NAME]=		VALUE_OFFSET_(VALUE_DEVICE_NAME),
		[SJC$_ENTRY_NUMBER]=		VALUE_OFFSET_(VALUE_ENTRY_NUMBER),
		[SJC$_ENTRY_NUMBER_OUTPUT]=	VALUE_OFFSET_(VALUE_ENTRY_NUMBER_OUTPUT),
		[SJC$_EXTEND_QUANTITY]=		VALUE_OFFSET_(VALUE_EXTEND_QUANTITY),
		[SJC$_FILE_COPIES]=		VALUE_OFFSET_(VALUE_FILE_COPIES),
		[SJC$_FILE_IDENTIFICATION]=	VALUE_OFFSET_(VALUE_FILE_IDENTIFICATION),
		[SJC$_FILE_SETUP_MODULES]=	VALUE_OFFSET_(VALUE_FILE_SETUP_MODULES),
		[SJC$_FIRST_PAGE]=		VALUE_OFFSET_(VALUE_FIRST_PAGE),
		[SJC$_FORM_DESCRIPTION]=	VALUE_OFFSET_(VALUE_FORM_DESCRIPTION),
		[SJC$_FORM_LENGTH]=		VALUE_OFFSET_(VALUE_FORM_LENGTH),
		[SJC$_FORM_MARGIN_BOTTOM]=	VALUE_OFFSET_(VALUE_FORM_MARGIN_BOTTOM),
		[SJC$_FORM_MARGIN_LEFT]=	VALUE_OFFSET_(VALUE_FORM_MARGIN_LEFT),
		[SJC$_FORM_MARGIN_RIGHT]=	VALUE_OFFSET_(VALUE_FORM_MARGIN_RIGHT),
		[SJC$_FORM_MARGIN_TOP]=		VALUE_OFFSET_(VALUE_FORM_MARGIN_TOP),
		[SJC$_FORM_NAME]=		VALUE_OFFSET_(VALUE_FORM_NAME),
		[SJC$_FORM_NUMBER]=		VALUE_OFFSET_(VALUE_FORM_NUMBER),
		[SJC$_FORM_SETUP_MODULES]=	VALUE_OFFSET_(VALUE_FORM_SETUP_MODULES),
		[SJC$_FORM_STOCK]=		VALUE_OFFSET_(VALUE_FORM_STOCK),
		[SJC$_FORM_WIDTH]=		VALUE_OFFSET_(VALUE_FORM_WIDTH),
		[SJC$_GENERIC_TARGET]=		VALUE_OFFSET_(VALUE_GENERIC_TARGET),
		[SJC$_JOB_COPIES]=		VALUE_OFFSET_(VALUE_JOB_COPIES),
		[SJC$_JOB_LIMIT]=		VALUE_OFFSET_(VALUE_JOB_LIMIT),
		[SJC$_JOB_NAME]=		VALUE_OFFSET_(VALUE_JOB_NAME),
		[SJC$_JOB_RESET_MODULES]=	VALUE_OFFSET_(VALUE_JOB_RESET_MODULES),
		[SJC$_JOB_SIZE_MAXIMUM]=	VALUE_OFFSET_(VALUE_JOB_SIZE_MAXIMUM),
		[SJC$_JOB_SIZE_MINIMUM]=	VALUE_OFFSET_(VALUE_JOB_SIZE_MINIMUM),
		[SJC$_JOB_STATUS_OUTPUT]=	VALUE_OFFSET_(VALUE_JOB_STATUS_OUTPUT),
		[SJC$_LAST_PAGE]=		VALUE_OFFSET_(VALUE_LAST_PAGE),
		[SJC$_LIBRARY_SPECIFICATION]=	VALUE_OFFSET_(VALUE_LIBRARY_SPECIFICATION),
		[SJC$_LOG_QUEUE]=		VALUE_OFFSET_(VALUE_LOG_QUEUE),
		[SJC$_LOG_SPECIFICATION]=	VALUE_OFFSET_(VALUE_LOG_SPECIFICATION),
		[SJC$_NOTE]=			VALUE_OFFSET_(VALUE_NOTE),
		[SJC$_OPERATOR_REQUEST]=	VALUE_OFFSET_(VALUE_OPERATOR_REQUEST),
		[SJC$_OWNER_UIC]=		VALUE_OFFSET_(VALUE_OWNER_UIC),
		[SJC$_PAGE_SETUP_MODULES]=	VALUE_OFFSET_(VALUE_PAGE_SETUP_MODULES),
		[SJC$_PARAMETER_1]=		VALUE_OFFSET_(VALUE_PARAMETER_1),
		[SJC$_PARAMETER_2]=		VALUE_OFFSET_(VALUE_PARAMETER_2),
		[SJC$_PARAMETER_3]=		VALUE_OFFSET_(VALUE_PARAMETER_3),
		[SJC$_PARAMETER_4]=		VALUE_OFFSET_(VALUE_PARAMETER_4),
		[SJC$_PARAMETER_5]=		VALUE_OFFSET_(VALUE_PARAMETER_5),
		[SJC$_PARAMETER_6]=		VALUE_OFFSET_(VALUE_PARAMETER_6),
		[SJC$_PARAMETER_7]=		VALUE_OFFSET_(VALUE_PARAMETER_7),
		[SJC$_PARAMETER_8]=		VALUE_OFFSET_(VALUE_PARAMETER_8),
		[SJC$_PRIORITY]=		VALUE_OFFSET_(VALUE_PRIORITY),
		[SJC$_PROCESSOR]=		VALUE_OFFSET_(VALUE_PROCESSOR),
		[SJC$_PROTECTION]=		VALUE_OFFSET_(VALUE_PROTECTION),
		[SJC$_QUEUE]=			VALUE_OFFSET_(VALUE_QUEUE),
		[SJC$_QUEUE_FILE_SPECIFICATION]=VALUE_OFFSET_(VALUE_QUEUE_FILE_SPECIFICATION),
		[SJC$_RELATIVE_PAGE]=		VALUE_OFFSET_(VALUE_RELATIVE_PAGE),
		[SJC$_RESERVED_INPUT_1]=	VALUE_OFFSET_(VALUE_RESERVED_INPUT_1),
		[SJC$_RESERVED_INPUT_2]=	VALUE_OFFSET_(VALUE_RESERVED_INPUT_2),
		[SJC$_RESERVED_INPUT_3]=	VALUE_OFFSET_(VALUE_RESERVED_INPUT_3),
		[SJC$_RESERVED_INPUT_4]=	VALUE_OFFSET_(VALUE_RESERVED_INPUT_4),
		[SJC$_RESERVED_OUTPUT_1]=	VALUE_OFFSET_(VALUE_RESERVED_OUTPUT_1),
		[SJC$_RESERVED_OUTPUT_2]=	VALUE_OFFSET_(VALUE_RESERVED_OUTPUT_2),
		[SJC$_SCSNODE_NAME]=		VALUE_OFFSET_(VALUE_SCSNODE_NAME),
		[SJC$_SEARCH_STRING]=		VALUE_OFFSET_(VALUE_SEARCH_STRING),
		[SJC$_WSDEFAULT]=		VALUE_OFFSET_(VALUE_WSDEFAULT),
		[SJC$_WSEXTENT]=		VALUE_OFFSET_(VALUE_WSEXTENT),
		[SJC$_WSQUOTA]=			VALUE_OFFSET_(VALUE_WSQUOTA));


LOCAL
	VALUE_STORAGE:	REF BBLOCK;	! Pointer to internal storage area


IF
    BEGIN
    IF .REQUIRED_VALUE_SIZE[.CODE] EQL 0
    THEN
	FALSE
    ELSE IF .REQUIRED_VALUE_SIZE[.CODE] LSS 0
    THEN
	.VALUE_SIZE GTRU - .REQUIRED_VALUE_SIZE[.CODE]
    ELSE
	.VALUE_SIZE NEQ .REQUIRED_VALUE_SIZE[.CODE]
    END
THEN
    RETURN JBC$_INVPARLEN;


VALUE_STORAGE = VALUE_STORAGE_BASE + .VALUE_STORAGE_OFFSET[.CODE];


CASE .VALUE_STORAGE_CASE[.CODE] FROM K_ACCOUNTING_TYPES TO K_VALUE_1_TO_65535 OF
    SET


    [K_ACCOUNTING_TYPES]:
	BEGIN
	IF .VALUE_ADDRESS[SJC$V_ACCT_UNUSED] NEQ 0
	THEN
	    RETURN JBC$_INVPARVAL;

	VALUE_STORAGE[0,0,32,0] = .VALUE_ADDRESS[0,0,32,0];
	END;


    [K_ACCOUNT_NAME]:
	BEGIN
	IF NOT .BBLOCK[MBX[ACM$Q_PRVMSK], PRV$V_CMKRNL]
	THEN
	    RETURN JBC$_NOCMKRNL;

	CH$COPY(.VALUE_SIZE, .VALUE_ADDRESS, %C' ', ACM$S_ACCOUNT, MBX[ACM$T_ACCOUNT]);
	END;


    [K_AFTER_TIME]:
	BEGIN
	IF .VALUE_ADDRESS[4,31,1,0]
	THEN
	    SUBM(2, .VALUE_ADDRESS, CUR_TIME, .VALUE_STORAGE)
	ELSE
	    BEGIN
	    VALUE_STORAGE[0,0,32,0] = .VALUE_ADDRESS[0,0,32,0];
	    VALUE_STORAGE[4,0,32,0] = .VALUE_ADDRESS[4,0,32,0];
	    END;
	END;


    [K_ALIGNMENT_PAGES]:
	BEGIN
	IF .VALUE_ADDRESS[0,0,32,0] EQL 0
	OR .VALUE_ADDRESS[0,0,32,0] GTRU 20
	THEN
	    RETURN JBC$_INVPARVAL;

	VALUE_STORAGE[0,0,32,0] = .VALUE_ADDRESS[0,0,32,0];
	END;


    [K_BASE_PRIORITY]:
	BEGIN
	IF .VALUE_ADDRESS[0,0,32,0] GTRU 15
	THEN
	    RETURN JBC$_INVPARVAL;

	VALUE_STORAGE[0,0,8,0] = .VALUE_ADDRESS[0,0,8,0];

	IF .VALUE_ADDRESS[0,0,8,0] GTRU .MBX[ACM$B_PROCPRI]
	AND NOT .BBLOCK[MBX[ACM$Q_PRVMSK], PRV$V_ALTPRI]
	AND NOT .BBLOCK[MBX[ACM$Q_PRVMSK], PRV$V_OPER]
	THEN
	    VALUE_STORAGE[0,0,8,0] = .MBX[ACM$B_PROCPRI];
	END;


    [K_BUFFER_COUNT]:
	BEGIN
	IF .VALUE_ADDRESS[0,0,32,0] GTRU 127
	THEN
	    RETURN JBC$_INVPARVAL;

	VALUE_STORAGE[0,0,8,0] = .VALUE_ADDRESS[0,0,8,0];
	END;


    [K_CHARACTERISTIC_NAME]:
	BEGIN
	IF NOT VALIDATE_OBJECT_NAME(.VALUE_SIZE, .VALUE_ADDRESS, .VALUE_STORAGE)
	THEN
	    RETURN JBC$_INVCHANAM;

	IF .MBX[MSG_W_TYPE] NEQ MSG$_SNDJBC
	OR (.MBX[ACM$W_FUNC] NEQ SJC$_DEFINE_CHARACTERISTIC
	    AND .MBX[ACM$W_FUNC] NEQ SJC$_DELETE_CHARACTERISTIC)
	THEN
	    BEGIN
	    LOCAL
		VALUE;

	    IF NOT FIND_CHARACTERISTIC(.VALUE_STORAGE; VALUE)
	    THEN
		RETURN JBC$_NOSUCHCHAR;

	    VALUE_CHARACTERISTICS[.VALUE] = TRUE;
	    END;	    
	END;


    [K_CHARACTERISTIC_NUMBER]:
	BEGIN
	IF .VALUE_ADDRESS[0,0,32,0] GTRU 127
	THEN
	    RETURN JBC$_INVPARVAL;

	VALUE_STORAGE[0,0,8,0] = .VALUE_ADDRESS[0,0,8,0];
	VALUE_CHARACTERISTICS[.VALUE_ADDRESS[0,0,32,0]] = TRUE;
	END;


    [K_DESTINATION_QUEUE_NAME]:
	BEGIN
	LOCAL
	    SDSC:		BBLOCK[SDSC_K_LENGTH];

	IF NOT VALIDATE_OBJECT_NAME(.VALUE_SIZE, .VALUE_ADDRESS, SDSC)
	THEN
	    RETURN JBC$_INVDSTQUE;

	IF NOT FIND_QUEUE(SDSC; , ,
	    VALUE_STORAGE[0,0,32,0], VALUE_STORAGE[4,0,32,0])
	THEN
	    RETURN JBC$_NODSTQUE;
	END;


    [K_FILE_IDENTIFICATION]:
	BEGIN
	LOCAL
	    L;

	CH$MOVE(
	    %ALLOCATION(VALUE_FILE_IDENTIFICATION),
	    VALUE_ADDRESS[0,0,0,0],
	    VALUE_FILE_IDENTIFICATION);
	L = .VALUE_ADDRESS[36,0,16,0];
	IF .L GTRU SQR$S_FILE_SPECIFICATION-1 THEN L = SQR$S_FILE_SPECIFICATION-1;
	VALUE_FILE_SPECIFICATION[SDSC_W_LENGTH] = .L;
	VALUE_FILE_SPECIFICATION[SDSC_A_POINTER] = VALUE_ADDRESS[38,0,0,0];
	END;


    [K_FORM_NAME]:
	BEGIN
	IF NOT VALIDATE_OBJECT_NAME(.VALUE_SIZE, .VALUE_ADDRESS, .VALUE_STORAGE)
	THEN
	    RETURN JBC$_INVFORNAM;

	IF .MBX[MSG_W_TYPE] NEQ MSG$_SNDJBC
	OR (.MBX[ACM$W_FUNC] NEQ SJC$_DEFINE_FORM
	    AND .MBX[ACM$W_FUNC] NEQ SJC$_DELETE_FORM)
	THEN
	    IF NOT FIND_FORM_NAME(
		.VALUE_STORAGE;
		VALUE_FORM[0], VALUE_FORM[1])
	    THEN
		RETURN JBC$_NOSUCHFORM;
	END;


    [K_FORM_NUMBER]:
	BEGIN
	VALUE_STORAGE[0,0,32,0] = .VALUE_ADDRESS[0,0,32,0];

	IF .MBX[MSG_W_TYPE] NEQ MSG$_SNDJBC
	OR .MBX[ACM$W_FUNC] NEQ SJC$_DEFINE_FORM
	THEN
	    IF NOT FIND_FORM_NUMBER(
		.VALUE_STORAGE[0,0,32,0];
		VALUE_FORM[0], VALUE_FORM[1])
	    THEN
		RETURN JBC$_NOSUCHFORM;
	END;


    [K_GENERIC_TARGET]:
	BEGIN
	LOCAL
	    SDSC:		BBLOCK[SDSC_K_LENGTH];

	IF .VALUE_STORAGE[0,0,32,0] GEQU JBC$K_MAXGENTGT
	THEN
	    RETURN JBC$_INVPARLEN;

	IF NOT VALIDATE_OBJECT_NAME(.VALUE_SIZE, .VALUE_ADDRESS, SDSC)
	THEN
	    RETURN JBC$_INVDSTQUE;

	IF NOT FIND_QUEUE(SDSC; , ,
	    VALUE_STORAGE[4+8*.VALUE_STORAGE[0,0,32,0],0,32,0],
	    VALUE_STORAGE[8+8*.VALUE_STORAGE[0,0,32,0],0,32,0])
	THEN
	    RETURN JBC$_NODSTQUE;

	VALUE_STORAGE[0,0,32,0] = .VALUE_STORAGE[0,0,32,0] + 1;
	END;


    [K_OUTPUT_ITEM]:
	BEGIN
	VALUE_STORAGE[ODSC_W_LENGTH] = .VALUE_SIZE;
	VALUE_STORAGE[ODSC_A_POINTER] = .VALUE_ADDRESS[0,0,32,0];
	VALUE_STORAGE[ODSC_A_LENPOINTER] = .VALUE_ADDRESS[4,0,32,0];
	END;


    [K_OWNERSHIP]:
	BEGIN
	IF NOT .BBLOCK[MBX[ACM$Q_PRVMSK], PRV$V_OPER]
	THEN
	    RETURN JBC$_NOOPER;

	VALUE_STORAGE[0,0,32,0] = .VALUE_ADDRESS[0,0,32,0];
	END;


    [K_PRIORITY]:
	BEGIN
	LOCAL
	    MAXPRI;

	IF .VALUE_ADDRESS[1,0,24,0] NEQ 0
	THEN
	    RETURN JBC$_INVPARVAL;

	VALUE_STORAGE[0,0,8,0] = .VALUE_ADDRESS[0,0,8,0];

	MAXPRI = .SYS$GB_MAXQUEPRI;
	IF .MAXPRI EQL 0 THEN MAXPRI = .MBX[ACM$B_PROCPRI];
	IF .VALUE_ADDRESS[0,0,8,0] GTRU .MAXPRI
	AND NOT .BBLOCK[MBX[ACM$Q_PRVMSK], PRV$V_ALTPRI]
	AND NOT .BBLOCK[MBX[ACM$Q_PRVMSK], PRV$V_OPER]
	THEN
	    VALUE_STORAGE[0,0,8,0] = .MAXPRI;
	END;


    [K_QUEUE_NAME]:
	BEGIN
	IF NOT VALIDATE_OBJECT_NAME(.VALUE_SIZE, .VALUE_ADDRESS, .VALUE_STORAGE)
	THEN
	    RETURN JBC$_INVQUENAM;
	END;


    [K_STRING]:
	BEGIN
	VALUE_STORAGE[SDSC_W_LENGTH] = .VALUE_SIZE;
	VALUE_STORAGE[SDSC_A_POINTER] = .VALUE_ADDRESS;
	END;


    [K_UIC]:
	BEGIN
	IF NOT .BBLOCK[MBX[ACM$Q_PRVMSK], PRV$V_CMKRNL]
	THEN
	    RETURN JBC$_NOCMKRNL;

	CH$MOVE(.VALUE_SIZE, .VALUE_ADDRESS, MBX[ACM$L_UIC]);
	END;


    [K_USERNAME]:
	BEGIN
	IF NOT .BBLOCK[MBX[ACM$Q_PRVMSK], PRV$V_CMKRNL]
	THEN
	    RETURN JBC$_NOCMKRNL;

	CH$COPY(.VALUE_SIZE, .VALUE_ADDRESS, %C' ', ACM$S_USERNAME, MBX[ACM$T_USERNAME]);
	END;


    [K_USER_IDENTIFICATION]:
	BEGIN
	IF NOT .BBLOCK[MBX[ACM$Q_PRVMSK], PRV$V_CMKRNL]
	THEN
	    RETURN JBC$_NOCMKRNL;

	CH$MOVE(.VALUE_SIZE, .VALUE_ADDRESS, MBX[ACM$L_UIC]);
	END;


    [K_VALUE]:
	CH$MOVE(.VALUE_SIZE, .VALUE_ADDRESS, .VALUE_STORAGE);


    [K_VALUE_NOT_0]:
	BEGIN
	IF .VALUE_ADDRESS[0,0,32,0] EQL 0
	THEN
	    RETURN JBC$_INVPARVAL;

	VALUE_STORAGE[0,0,32,0] = .VALUE_ADDRESS[0,0,32,0];
	END;


    [K_VALUE_0_TO_255]:
	BEGIN
	IF .VALUE_ADDRESS[1,0,24,0] NEQ 0
	THEN
	    RETURN JBC$_INVPARVAL;

	VALUE_STORAGE[0,0,8,0] = .VALUE_ADDRESS[0,0,8,0];
	END;


    [K_VALUE_1_TO_255]:
	BEGIN
	IF .VALUE_ADDRESS[0,0,32,0] EQL 0
	OR .VALUE_ADDRESS[1,0,24,0] NEQ 0
	THEN
	    RETURN JBC$_INVPARVAL;

	VALUE_STORAGE[0,0,8,0] = .VALUE_ADDRESS[0,0,8,0];
	END;


    [K_VALUE_0_TO_65535]:
	BEGIN
	IF .VALUE_ADDRESS[2,0,16,0] NEQ 0
	THEN
	    RETURN JBC$_INVPARVAL;

	VALUE_STORAGE[0,0,16,0] = .VALUE_ADDRESS[0,0,16,0];
	END;


    [K_VALUE_1_TO_65535]:
	BEGIN
	IF .VALUE_ADDRESS[0,0,32,0] EQL 0
	OR .VALUE_ADDRESS[2,0,16,0] NEQ 0
	THEN
	    RETURN JBC$_INVPARVAL;

	VALUE_STORAGE[0,0,16,0] = .VALUE_ADDRESS[0,0,16,0];
	END;


    TES;


ITEM_PRESENT[.CODE] = TRUE;
SS$_NORMAL
END;

GLOBAL ROUTINE SNDACC_SERVICE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine processes the message type:
!		MSG$_SNDACC		send to accounting manager
!	by dispatching to a request-specific routine.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	MBX		- Pointer to buffered mailbox message.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Completion status to be returned to requestor.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
OWN
	PROCESSING_ROUTINE:		VECTOR[MAX_SNDACC_FUNC+1]
	    PSECT(CODE) PRESET(
		[ACC$K_DISAACC]=	SJC_STOP_ACCOUNTING,
		[ACC$K_DISASEL]=	SJC_STOP_ACCOUNTING,
		[ACC$K_ENABACC]=	SJC_START_ACCOUNTING,
		[ACC$K_ENABSEL]=	SJC_START_ACCOUNTING,
		[ACC$K_INSMESG]=	SJC_WRITE_ACCOUNTING,
		[ACC$K_NEWFILE]=	SJC_START_ACCOUNTING);
LOCAL
	PROC_ROUTINE;


! Ensure that the message contains the request type.
!
IF .MBX[ACM$W_MSGLEN] LSSU $BYTEOFFSET(ACM$W_USERREQ) + 2
THEN
    RETURN JBC$_INVMSGBUF;


! Validate the request type.
!
DIAG_TRACE[1] = .MBX[ACM$W_USERREQ];	! ***** diagnostic info *****
IF .MBX[ACM$W_USERREQ] LSSU MIN_SNDACC_FUNC
OR .MBX[ACM$W_USERREQ] GTRU MAX_SNDACC_FUNC
THEN
    RETURN JBC$_INVFUNCOD;

SNDACC_COUNT[.MBX[ACM$W_USERREQ]] = SNDACC_COUNT[.MBX[ACM$W_USERREQ]] + 1;


! Set up for parameter preprocessing.
!
CH$FILL(0, VALUE_STORAGE_END - VALUE_STORAGE_BASE, VALUE_STORAGE_BASE);
PROC_ROUTINE = .PROCESSING_ROUTINE[.MBX[ACM$W_USERREQ]];


! Preprocess the remaining parameters into static storage.
!
CASE .MBX[ACM$W_USERREQ] FROM MIN_SNDACC_FUNC TO MAX_SNDACC_FUNC OF
    SET


    [OUTRANGE]:
	RETURN JBC$_INVFUNCOD;


    [ACC$K_INSMESG]:
	BEGIN
	LOCAL
	    STATUS;

	STATUS = PROCESS_ONE_OPTION(
	    SJC$_ACCOUNTING_MESSAGE,
	    .MBX[ACM$W_MSGLEN] - $BYTEOFFSET(ACM$T_DATA),
	    MBX[ACM$T_DATA]);
	IF NOT .STATUS THEN RETURN .STATUS;
	END;


    [ACC$K_NEWFILE]:
	BEGIN
	ITEM_PRESENT[SJC$_NEW_VERSION] = TRUE;
	END;


    [ACC$K_ENABACC, ACC$K_DISAACC]:
	0;


    [ACC$K_ENABSEL, ACC$K_DISASEL]:
	BEGIN
	LOCAL
	    MASK:		BBLOCK[4],		! Bit mask
	    CURSOR:		REF VECTOR[,BYTE];	! Parameter cursor


	! Initialize.
	!
	MASK = 0;
	CURSOR = MBX[ACM$T_DATA];


	! Process the user's parameter list to generate the bit mask.
	!
	WHILE .CURSOR LSSA .MBX_END DO
	    BEGIN
	    CASE .CURSOR[0] FROM 0 TO ACC$K_INSMSG OF
		SET
		[INRANGE, OUTRANGE]:	RETURN JBC$_INVITMCOD;
		[0]:			EXITLOOP;
		[ACC$K_PRCTRM]:		MASK[SJC$V_ACCT_PROCESS] = TRUE;
		[ACC$K_BATTRM]:		MASK[SJC$V_ACCT_BATCH] = TRUE;
		[ACC$K_INTTRM]:		MASK[SJC$V_ACCT_INTERACTIVE] = TRUE;
		[ACC$K_LOGTRM]:		MASK[SJC$V_ACCT_LOGIN_FAILURE] = TRUE;
		[ACC$K_IMGTRM]:		MASK[SJC$V_ACCT_IMAGE] = TRUE;
		[ACC$K_SUBTRM]:		MASK[SJC$V_ACCT_SUBPROCESS] = TRUE;
		[ACC$K_DETTRM]:		MASK[SJC$V_ACCT_DETACHED] = TRUE;
		[ACC$K_NETTRM]:		MASK[SJC$V_ACCT_NETWORK] = TRUE;
		[ACC$K_PRTJOB]:		MASK[SJC$V_ACCT_PRINT] = TRUE;
		[ACC$K_INSMSG]:		MASK[SJC$V_ACCT_MESSAGE] = TRUE;
		TES;
	    CURSOR = .CURSOR + 1;
	    END;	    


	VALUE_ACCOUNTING_TYPES = .MASK;
	ITEM_PRESENT[SJC$_ACCOUNTING_TYPES] = TRUE;
	END;


    TES;


! Dispatch to execute the request.
!
(.PROC_ROUTINE)()
END;

ROUTINE PROCESS_SNDSMB_OPTIONS(OPT,MIN,MAX)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine processes the options of a $SNDSMB service into internal
!	data structures.
!
! INPUT PARAMETERS:
!	OPT		- Pointer to options.
!	MIN		- Minimum valid option code.
!	MAX		- Maximum valid option code.
!
! IMPLICIT INPUTS:
!	MBX		- Pointer to buffered mailbox message.
!	MBX_END		- Pointer beyond mailbox message.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	Converted options stored in appropriate structures.
!
! ROUTINE VALUE:
!	Completion status.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LITERAL
	K_ASCIC=	1,
	K_CHAR=		2,
	K_FILESIZ=	3,
	K_PARAMETERS=	4,
	K_SPCCNT=	5;


MACRO
	PRESET_TABLE(A,B,C) =
	    OWN A: VECTOR[C+1-B,BYTE,SIGNED] ALIGN(0) PSECT(CODE) PRESET(PRESET_(B, %REMAINING)) %,

	PRESET_(A)[B,C] = [B - A] = C %;


PRESET_TABLE(CODE_TABLE_1, SMO$K_DELETE, SMO$K_DESTQUE,
	SMO$K_DELETE,		SJC$_DELETE_FILE,
	SMO$K_BRSTPAG,		SJC$_FILE_BURST,
	SMO$K_NOBRSTPAG,	SJC$_NO_FILE_BURST,
	SMO$K_FLAGPAG,		SJC$_FILE_FLAG,
	SMO$K_NOFLAGPAG,	SJC$_NO_FILE_FLAG,
	SMO$K_PAGHDR,		SJC$_PAGE_HEADER,
	SMO$K_DOUBLE,		SJC$_DOUBLE_SPACE,
	SMO$K_NOFEED,		SJC$_NO_PAGINATE,
	SMO$K_PAGCNT,		SJC$_LAST_PAGE,
	SMO$K_COPIES,		SJC$_FILE_COPIES,
	SMO$K_FILESIZ,		0,
	SMO$K_DESTQUE,		SJC$_DESTINATION_QUEUE);

PRESET_TABLE(SIZE_TABLE_1, SMO$K_DELETE, SMO$K_DESTQUE,
	SMO$K_PAGCNT,		2,
	SMO$K_COPIES,		1,
	SMO$K_FILESIZ,		- K_FILESIZ,
	SMO$K_DESTQUE,		- K_ASCIC);


PRESET_TABLE(CODE_TABLE_2, SMO$K_RLSTIM, SMO$K_NOWSEXTNT,
	SMO$K_RLSTIM,		SJC$_AFTER_TIME,
	SMO$K_HOLD,		SJC$_HOLD,
	SMO$K_JOBPRI,		SJC$_PRIORITY,
	SMO$K_JOBCOPY,		SJC$_JOB_COPIES,
	SMO$K_FORMTYPE,		SJC$_FORM_NUMBER,
	SMO$K_LOWER,		SJC$_LOWERCASE,
	SMO$K_PARAMS,		SJC$_PARAMETER_1,
	SMO$K_JOBNAME,		SJC$_JOB_NAME,
	SMO$K_NOLOWER,		SJC$_NO_LOWERCASE,
	SMO$K_CPULIM,		SJC$_CPU_LIMIT,
	SMO$K_NOCPULM,		SJC$_NO_CPU_LIMIT,
	SMO$K_WSQUOTA,		SJC$_WSQUOTA,
	SMO$K_NOWSQUO,		SJC$_NO_WSQUOTA,
	SMO$K_WSDEFLT,		SJC$_WSDEFAULT,
	SMO$K_NOWSDFT,		SJC$_NO_WSDEFAULT,
	SMO$K_DQCHAR,		SJC$_CHARACTERISTIC_NUMBER,
	SMO$K_LOGFNAM,		SJC$_LOG_SPECIFICATION,
	SMO$K_LOGQNAM,		SJC$_LOG_QUEUE,
	SMO$K_KEEPLOG,		SJC$_NO_LOG_DELETE,
	SMO$K_NOSPOOL,		SJC$_NO_LOG_SPOOL,
	SMO$K_NOKEEPLOG,	SJC$_LOG_DELETE,
	SMO$K_NOLOG,		SJC$_NO_LOG_SPECIFICATION,
	SMO$K_NOTIFY,		SJC$_NOTIFY,
	SMO$K_NONOTFY,		SJC$_NO_NOTIFY,
	SMO$K_WSEXTNT,		SJC$_WSEXTENT,
	SMO$K_NOWSEXTNT,	SJC$_NO_WSEXTENT);

PRESET_TABLE(SIZE_TABLE_2, SMO$K_RLSTIM, SMO$K_NOWSEXTNT,
	SMO$K_RLSTIM,		8,
	SMO$K_JOBPRI,		1,
	SMO$K_JOBCOPY,		1,
	SMO$K_FORMTYPE,		1,
	SMO$K_PARAMS,		- K_PARAMETERS,
	SMO$K_JOBNAME,		- K_ASCIC,
	SMO$K_CPULIM,		4,
	SMO$K_WSQUOTA,		2,
	SMO$K_WSDEFLT,		2,
	SMO$K_DQCHAR,		- K_CHAR,
	SMO$K_LOGFNAM,		- K_ASCIC,
	SMO$K_LOGQNAM,		- K_ASCIC,
	SMO$K_WSEXTNT,		2);


PRESET_TABLE(CODE_TABLE_3, SMO$K_CURFORM, SMO$K_NODISWAP,
	SMO$K_CURFORM,		SJC$_FORM_NUMBER,
	SMO$K_GENPRT,		SJC$_GENERIC_SELECTION,
	SMO$K_NOGENPRT,		SJC$_NO_GENERIC_SELECTION,
	SMO$K_DETJOB,		SJC$_BATCH,
	SMO$K_GENDEV,		SJC$_GENERIC_QUEUE,
	SMO$K_NOGENDEV,		SJC$_NO_GENERIC_QUEUE,
	SMO$K_DEFBRST,		SJC$_FILE_BURST,
	SMO$K_NODEFBRST,	SJC$_NO_FILE_BURST,
	SMO$K_DEFFLAG,		SJC$_FILE_FLAG,
	SMO$K_NODEFFLAG,	SJC$_NO_FILE_FLAG,
	SMO$K_TRMDEV,		SJC$_TERMINAL,
	SMO$K_NOTRMDEV,		SJC$_NO_TERMINAL,
	SMO$K_JOBLIM,		SJC$_JOB_LIMIT,
	SMO$K_INIPRI,		SJC$_BASE_PRIORITY,
	SMO$K_DISWAP,		SJC$_NO_SWAP,
	SMO$K_MCPULM,		SJC$_CPU_LIMIT,
	SMO$K_NOMCPULM,		SJC$_NO_CPU_LIMIT,
	SMO$K_DCPULM,		SJC$_CPU_DEFAULT,
	SMO$K_NODCPULM,		SJC$_NO_CPU_DEFAULT,
	SMO$K_WSQUTA,		SJC$_WSQUOTA,
	SMO$K_NOWSQUTA,		SJC$_NO_WSQUOTA,
	SMO$K_WSDFLT,		SJC$_WSDEFAULT,
	SMO$K_NOWSDFLT,		SJC$_NO_WSDEFAULT,
	SMO$K_CURDQCHAR,	SJC$_CHARACTERISTIC_NUMBER,
	SMO$K_SMBNAME,		SJC$_PROCESSOR,
	SMO$K_WSXTANT,		SJC$_WSEXTENT,
	SMO$K_NOWSXTNT,		SJC$_NO_WSEXTENT,
	SMO$K_NODISWAP,		SJC$_SWAP);

PRESET_TABLE(SIZE_TABLE_3, SMO$K_CURFORM, SMO$K_NODISWAP,
	SMO$K_CURFORM,		1,
	SMO$K_JOBLIM,		1,
	SMO$K_INIPRI,		1,
	SMO$K_MCPULM,		4,
	SMO$K_DCPULM,		4,
	SMO$K_WSQUTA,		2,
	SMO$K_WSDFLT,		2,
	SMO$K_CURDQCHAR,	- K_CHAR,
	SMO$K_SMBNAME,		- K_ASCIC,
	SMO$K_WSXTANT,		2);


PRESET_TABLE(CODE_TABLE_4, SMO$K_NEXTJOB, SMO$K_SPCCNT,
	SMO$K_NEXTJOB,		SJC$_NEXT_JOB,
	SMO$K_TOPOFILE,		SJC$_TOP_OF_FILE,
	SMO$K_SPCCNT,		SJC$_RELATIVE_PAGE);

PRESET_TABLE(SIZE_TABLE_4, SMO$K_NEXTJOB, SMO$K_SPCCNT,
	SMO$K_SPCCNT,		- K_SPCCNT);


PRESET_TABLE(CODE_TABLE_5, SMO$K_REQUEUE, SMO$K_REQPRIO,
	SMO$K_REQUEUE,		SJC$_REQUEUE,
	SMO$K_REQDEST,		SJC$_DESTINATION_QUEUE,
	SMO$K_REQPRIO,		SJC$_PRIORITY);

PRESET_TABLE(SIZE_TABLE_5, SMO$K_REQUEUE, SMO$K_REQPRIO,
	SMO$K_REQDEST,		- K_ASCIC,
	SMO$K_REQPRIO,		1);


LOCAL
	P:		REF BBLOCK;	! Cursor to options


P = .OPT;
WHILE .P LSSA .MBX_END DO
    BEGIN
    BIND
	OPTION_LOWER = UPLIT BYTE (
		SMO$K_DELETE,
		SMO$K_RLSTIM,
		SMO$K_CURFORM,
		SMO$K_NEXTJOB,
		SMO$K_REQUEUE):
	VECTOR[,BYTE],

	OPTION_UPPER = UPLIT BYTE (
		SMO$K_DESTQUE,
		SMO$K_NOWSEXTNT,
		SMO$K_NODISWAP,
		SMO$K_SPCCNT,
		SMO$K_REQPRIO):
	VECTOR[,BYTE],

	OPTION_CODE_TABLE = UPLIT (
		CODE_TABLE_1,
		CODE_TABLE_2,
		CODE_TABLE_3,
		CODE_TABLE_4,
		CODE_TABLE_5):
	VECTOR,

	OPTION_SIZE_TABLE = UPLIT (
		SIZE_TABLE_1,
		SIZE_TABLE_2,
		SIZE_TABLE_3,
		SIZE_TABLE_4,
		SIZE_TABLE_5):
	VECTOR;


    LOCAL
	O:			BYTE,
	CODE_TABLE:		REF VECTOR[,BYTE],
	SIZE_TABLE:		REF VECTOR[,BYTE,SIGNED],
	CODE,
	VALUE_SIZE,
	VALUE_ADDRESS:		REF BBLOCK,
	VALUE_TEMPORARY:	BBLOCK[8],
	STATUS;


    O = .P[0,0,8,0];
    P = .P + 1;
    IF .O EQL 0 THEN EXITLOOP;
    IF .O LSSU .MIN OR .O GTRU .MAX THEN RETURN JBC$_INVITMCOD;


    DECR N FROM 4 TO 0 DO
	BEGIN
	IF .O GTRU .OPTION_UPPER[.N] THEN RETURN JBC$_INVITMCOD;
	IF .O GEQU .OPTION_LOWER[.N]
	THEN
	    BEGIN
	    CODE_TABLE = .OPTION_CODE_TABLE[.N];
	    SIZE_TABLE = .OPTION_SIZE_TABLE[.N];
	    O = .O - .OPTION_LOWER[.N];
	    EXITLOOP;
	    END;
	END;


    CODE = .CODE_TABLE[.O];
    ITEM_PRESENT[.CODE] = TRUE;


    VALUE_SIZE = .SIZE_TABLE[.O];
    VALUE_ADDRESS = .P;
    VALUE_TEMPORARY[0,0,32,0] = VALUE_TEMPORARY[4,0,32,0] = 0;
    IF .VALUE_SIZE NEQ 0
    THEN
	BEGIN
	IF .VALUE_SIZE LSS 0
	THEN
	    BEGIN
	    CASE - .VALUE_SIZE FROM K_ASCIC TO K_SPCCNT OF
		SET


		[K_ASCIC]:
		    BEGIN
		    IF .P EQLA .MBX_END THEN RETURN JBC$_INVMSGBUF;
		    VALUE_SIZE = .P[0,0,8,0];
		    P = .P + 1;
		    IF .P + .VALUE_SIZE GTRA .MBX_END THEN RETURN JBC$_INVMSGBUF;
		    VALUE_ADDRESS = .P;
		    P = .P + .VALUE_SIZE;		
		    END;


		[K_CHAR]:
		    BEGIN
		    IF .P GTRA .MBX_END - 16 THEN RETURN JBC$_INVMSGBUF;
		    MOVC3(%REF(16), .P, VALUE_CHARACTERISTICS; , P);
		    VALUE_SIZE = 0;
		    END;


		[K_FILESIZ]:
		    BEGIN
		    IF .P GTRA .MBX_END - 4 THEN RETURN JBC$_INVMSGBUF;
		    P = .P + .VALUE_SIZE;
		    VALUE_SIZE = 0;
		    END;


		[K_PARAMETERS]:
		    BEGIN
		    LOCAL
			STATUS;		! Status return

		    WHILE TRUE DO
			BEGIN
			IF .P GEQA .MBX_END THEN RETURN JBC$_INVMSGBUF;
			VALUE_SIZE = .P[0,0,8,0];
			P = .P + 1;
			IF .VALUE_SIZE EQL 0 THEN EXITLOOP;
			IF .CODE GTRU SJC$_PARAMETER_8 THEN RETURN JBC$_INVPARVAL;
			ITEM_PRESENT[.CODE] = TRUE;
			IF .VALUE_SIZE NEQ 1 OR CH$RCHAR(.P) NEQ %X'FF'
			THEN
			    BEGIN
			    STATUS = PROCESS_ONE_OPTION(
				.CODE, .VALUE_SIZE, .P);
			    IF NOT .STATUS THEN RETURN .STATUS;
			    END;
			CODE = .CODE + 1;
			P = .P + .VALUE_SIZE;
			END;
		    END;


		[K_SPCCNT]:
		    BEGIN
		    IF .P GTRA .MBX_END - 2 THEN RETURN JBC$_INVMSGBUF;
		    VALUE_TEMPORARY = .VALUE_ADDRESS[0,0,16,1];
		    P = .P + 2;
		    VALUE_SIZE = 4;
		    VALUE_ADDRESS = VALUE_TEMPORARY;
		    END;


		TES;
	    END
	ELSE
	    BEGIN
	    IF .P GTRA .MBX_END - .VALUE_SIZE THEN RETURN JBC$_INVMSGBUF;
	    P = .P + .VALUE_SIZE;
	    IF .VALUE_SIZE LSS 4
	    THEN
		BEGIN
		VALUE_TEMPORARY = .VALUE_ADDRESS[0, 0, .VALUE_SIZE*8, 0];
		VALUE_SIZE = 4;
		VALUE_ADDRESS = VALUE_TEMPORARY;
		END;
	    END;
	END;


    IF .VALUE_SIZE NEQ 0
    THEN
	BEGIN
	STATUS = PROCESS_ONE_OPTION(.CODE, .VALUE_SIZE, .VALUE_ADDRESS);
	IF NOT .STATUS THEN RETURN .STATUS;
	END;
    END;	    
SS$_NORMAL
END;

GLOBAL ROUTINE SNDSMB_SERVICE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine processes the message type:
!		MSG$_SNDSMB		send to symbiont manager
!	by dispatching to a request-specific routine.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	MBX		- Pointer to buffered mailbox message.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Completion status to be returned to requestor.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
OWN
	SEARCH_REQUIRED:	BITVECTOR[MAX_SNDSMB_FUNC+1]
	    PSECT(CODE) PRESET(
		[SMR$K_ABORT]=		TRUE,
		[SMR$K_ALTER]=		TRUE,
		[SMR$K_CREJOB]=		TRUE,
		[SMR$K_ENTER]=		TRUE,
		[SMR$K_PAUSE]=		TRUE,
		[SMR$K_RELEASE]=	TRUE,
		[SMR$K_RMVJOB]=		TRUE,
		[SMR$K_START]=		TRUE,
		[SMR$K_STOP]=		TRUE,
		[SMR$K_SYNCJOB]=	TRUE),

	QUEUE_PRESENT:	BITVECTOR[MAX_SNDSMB_FUNC+1]
	    PSECT(CODE) PRESET(
		[SMR$K_ABORT]=		TRUE,
		[SMR$K_ALTER]=		TRUE,
		[SMR$K_CREJOB]=		TRUE,
		[SMR$K_DELETE]=		TRUE,
		[SMR$K_ENTER]=		TRUE,
		[SMR$K_INITIAL]=	TRUE,
		[SMR$K_PAUSE]=		TRUE,
		[SMR$K_RELEASE]=	TRUE,
		[SMR$K_RMVJOB]=		TRUE,
		[SMR$K_START]=		TRUE,
		[SMR$K_STOP]=		TRUE,
		[SMR$K_SYNCJOB]=	TRUE),

	MINIMUM_LENGTH:		VECTOR[MAX_SNDSMB_FUNC+1,BYTE]
	    PSECT(CODE) PRESET(
		[SMR$K_ABORT]=		$BYTEOFFSET(ACM$W_USERREQ) + 2 + 16,
		[SMR$K_ADDFIL]=		$BYTEOFFSET(ACM$W_USERREQ) + 2 + 16 + 6 + 6 + 20,
		[SMR$K_ALTER]=		$BYTEOFFSET(ACM$W_USERREQ) + 2 + 16 + 2,
		[SMR$K_CLSJOB]=		$BYTEOFFSET(ACM$W_USERREQ) + 2,
		[SMR$K_CREJOB]=		$BYTEOFFSET(ACM$W_USERREQ) + 2 + 16,
		[SMR$K_DELETE]=		$BYTEOFFSET(ACM$W_USERREQ) + 2 + 16,
		[SMR$K_ENTER]=		$BYTEOFFSET(ACM$W_USERREQ) + 2 + 16 + 16 + 6 + 6 + 20,
		[SMR$K_INITIAL]=	$BYTEOFFSET(ACM$W_USERREQ) + 2 + 16,
		[SMR$K_MERGE]=		$BYTEOFFSET(ACM$W_USERREQ) + 2 + 16 + 16,
		[SMR$K_PAUSE]=		$BYTEOFFSET(ACM$W_USERREQ) + 2 + 16,
		[SMR$K_REDIRECT]=	$BYTEOFFSET(ACM$W_USERREQ) + 2 + 16 + 16,
		[SMR$K_RELEASE]=	$BYTEOFFSET(ACM$W_USERREQ) + 2 + 16 + 2,
		[SMR$K_RMVJOB]=		$BYTEOFFSET(ACM$W_USERREQ) + 2 + 16 + 2,
		[SMR$K_START]=		$BYTEOFFSET(ACM$W_USERREQ) + 2 + 16,
		[SMR$K_STOP]=		$BYTEOFFSET(ACM$W_USERREQ) + 2 + 16,
		[SMR$K_SYNCJOB]=	$BYTEOFFSET(ACM$W_USERREQ) + 2 + 16 + 2 + 10),

	PROCESSING_ROUTINE:		VECTOR[MAX_SNDSMB_FUNC+1]
	    PSECT(CODE) PRESET(
		[SMR$K_ABORT]=		SJC_ABORT_JOB,
		[SMR$K_ADDFIL]=		SJC_ADD_FILE,
		[SMR$K_ALTER]=		SJC_ALTER_JOB,
		[SMR$K_CLSJOB]=		SJC_CLOSE_JOB,
		[SMR$K_CREJOB]=		SJC_CREATE_JOB,
		[SMR$K_DELETE]=		SJC_DELETE_QUEUE,
		[SMR$K_ENTER]=		SJC_ENTER_FILE,
		[SMR$K_INITIAL]=	SJC_CREATE_QUEUE,
		[SMR$K_MERGE]=		SJC_MERGE_QUEUE,
		[SMR$K_PAUSE]=		SJC_PAUSE_QUEUE,
		[SMR$K_REDIRECT]=	SJC_ASSIGN_QUEUE,
		[SMR$K_RELEASE]=	SJC_ALTER_JOB,
		[SMR$K_RMVJOB]=		SJC_DELETE_JOB,
		[SMR$K_START]=		SJC_START_QUEUE,
		[SMR$K_STOP]=		SJC_STOP_QUEUE,
		[SMR$K_SYNCJOB]=	SJC_SYNCHRONIZE_JOB);

LOCAL
	SQX_N,				! Record number of SQX
	SQE:		REF BBLOCK,	! Pointer to SQX entry
	SMQ_N,				! Record number of SMQ
	SMQ:		REF BBLOCK,	! Pointer to SMQ
	PROC_ROUTINE;			! Processing routine


! Ensure that the message contains the request type.
!
IF .MBX[ACM$W_MSGLEN] LSSU $BYTEOFFSET(ACM$W_USERREQ) + 2
THEN
    RETURN JBC$_INVMSGBUF;


! Validate the request code.
!
DIAG_TRACE[1] = .MBX[ACM$W_USERREQ];	! ***** diagnostic info *****
IF
    BEGIN
    IF .MBX[ACM$W_USERREQ] LSSU MIN_SNDSMB_FUNC
    OR .MBX[ACM$W_USERREQ] GTRU MAX_SNDSMB_FUNC
    THEN
	TRUE
    ELSE
	.PROCESSING_ROUTINE[.MBX[ACM$W_USERREQ]] EQL 0
    END
THEN
    RETURN JBC$_INVFUNCOD;


! Ensure that the message contains all required fields.
!
IF .MBX[ACM$W_MSGLEN] LSSU .MINIMUM_LENGTH[.MBX[ACM$W_USERREQ]]
THEN
    RETURN JBC$_INVMSGBUF;

SNDSMB_COUNT[.MBX[ACM$W_USERREQ]] = .SNDSMB_COUNT[.MBX[ACM$W_USERREQ]] + 1;


! Ensure that the queue file is open, and lock it.
!
IF .QUEUE_FAB[FAB$W_IFI] EQL 0 THEN RETURN JBC$_JOBQUEDIS;
LOCK_QUEUE_FILE();


! Set up for parameter preprocessing.
!
CH$FILL(0, VALUE_STORAGE_END - VALUE_STORAGE_BASE, VALUE_STORAGE_BASE);
PROC_ROUTINE = .PROCESSING_ROUTINE[.MBX[ACM$W_USERREQ]];


! If the request has a queue name, preprocess it into static storage.
!
IF .QUEUE_PRESENT[.MBX[ACM$W_USERREQ]]
THEN
    BEGIN
    LOCAL
	STATUS;

    STATUS = PROCESS_ONE_OPTION(
	SJC$_QUEUE,
	CH$RCHAR(MBX[ACM$T_QUEUE_1]),
	MBX[ACM$T_QUEUE_1]+1);
    IF NOT .STATUS THEN RETURN .STATUS;
    END;


! If the request requires a queue search, search for the queue.
!
IF .SEARCH_REQUIRED[.MBX[ACM$W_USERREQ]]
THEN
    IF NOT FIND_QUEUE(VALUE_QUEUE; SQX_N, SQE, SMQ_N, SMQ)
    THEN
	RETURN JBC$_NOSUCHQUE;


! Preprocess the remaining parameters into static storage.
!
CASE .MBX[ACM$W_USERREQ] FROM MIN_SNDSMB_FUNC TO MAX_SNDSMB_FUNC OF
    SET


    [SMR$K_ABORT]:
	BEGIN
	IF .SMQ[SMQ$V_BATCH]
	THEN
	    BEGIN
	    VALUE_ENTRY_NUMBER = .MBX[ACM$W_ENTRY_NUMBER];
	    ITEM_PRESENT[SJC$_ENTRY_NUMBER] = TRUE;
	    END
	ELSE
	    BEGIN
	    LOCAL
		STATUS;

	    STATUS = PROCESS_SNDSMB_OPTIONS(
		MBX[ACM$T_QUE_OPT],
		SMO$K_REQUEUE, SMO$K_REQPRIO);
	    IF NOT .STATUS THEN RETURN .STATUS;
	    END;
	END;


    [SMR$K_ADDFIL]:
	BEGIN
	LOCAL
	    STATUS_1;

	CH$MOVE(
	    %ALLOCATION(VALUE_FILE_IDENTIFICATION),
	    MBX_END[ACM$T_INT_FID],
	    VALUE_FILE_IDENTIFICATION);
	VALUE_FILE_SPECIFICATION[SDSC_W_LENGTH] =
	    .MBX_END[ACM$W_INT_RSL];
	VALUE_FILE_SPECIFICATION[SDSC_A_POINTER] =
	    MBX_END[ACM$W_INT_RSL] - .MBX_END[ACM$W_INT_RSL];
	STATUS_1 = PROCESS_SNDSMB_OPTIONS(
	    MBX[ACM$T_ADF_OPT],
	    SMO$K_DELETE, SMO$K_FILESIZ);
	IF NOT .STATUS_1 THEN RETURN .STATUS_1;
	END;


    [SMR$K_ALTER]:
	BEGIN
	LOCAL
	    STATUS;

	VALUE_ENTRY_NUMBER = .MBX[ACM$W_ENTRY_NUMBER];
	STATUS = PROCESS_SNDSMB_OPTIONS(
	    MBX[ACM$T_QJB_OPT],
	    SMO$K_DESTQUE, SMO$K_NOWSEXTNT);
	IF NOT .STATUS THEN RETURN .STATUS;
	ITEM_PRESENT[SJC$_ENTRY_NUMBER] = TRUE;
	END;


    [SMR$K_CREJOB]:
	BEGIN
	LOCAL
	    STATUS;

	STATUS = PROCESS_SNDSMB_OPTIONS(
	    MBX[ACM$T_QUE_OPT],
	    SMO$K_RLSTIM, SMO$K_NOWSEXTNT);
	IF NOT .STATUS THEN RETURN .STATUS;
	END;


    [SMR$K_ENTER]:
	BEGIN
	LOCAL
	    STATUS_1;

	CH$MOVE(
	    %ALLOCATION(VALUE_FILE_IDENTIFICATION),
	    MBX_END[ACM$T_INT_FID],
	    VALUE_FILE_IDENTIFICATION);
	VALUE_FILE_SPECIFICATION[SDSC_W_LENGTH] =
	    .MBX_END[ACM$W_INT_RSL];
	VALUE_FILE_SPECIFICATION[SDSC_A_POINTER] =
	    MBX_END[ACM$W_INT_RSL] - .MBX_END[ACM$W_INT_RSL];
	STATUS_1 = PROCESS_SNDSMB_OPTIONS(
	    MBX[ACM$T_ENT_OPT],
	    SMO$K_DELETE, SMO$K_NOWSEXTNT);
	IF NOT .STATUS_1 THEN RETURN .STATUS_1;
	END;


    [SMR$K_INITIAL]:
	BEGIN
	LOCAL
	    STATUS;

	STATUS = PROCESS_SNDSMB_OPTIONS(
	    MBX[ACM$T_QUE_OPT],
	    SMO$K_CURFORM, SMO$K_NODISWAP);
	IF NOT .STATUS THEN RETURN .STATUS;
	END;


    [SMR$K_MERGE]:
	BEGIN
	LOCAL
	    STATUS_1,
	    STATUS_2;

	STATUS_1 = PROCESS_ONE_OPTION(
	    SJC$_DESTINATION_QUEUE,
	    CH$RCHAR(MBX[ACM$T_QUEUE_1]),
	    MBX[ACM$T_QUEUE_1]+1);
	IF NOT .STATUS_1 THEN RETURN .STATUS_1;
	STATUS_2 = PROCESS_ONE_OPTION(
	    SJC$_QUEUE,
	    CH$RCHAR(MBX[ACM$T_QUEUE_2]),
	    MBX[ACM$T_QUEUE_2]+1);
	IF NOT .STATUS_2 THEN RETURN .STATUS_2;
	IF NOT FIND_QUEUE(VALUE_QUEUE; SQX_N, SQE, SMQ_N, SMQ)
	    THEN RETURN JBC$_NOSUCHQUE;
	END;


    [SMR$K_REDIRECT]:
	BEGIN
	IF CH$RCHAR(MBX[ACM$T_QUEUE_2]) EQL 0
	THEN
	    BEGIN
	    LOCAL
		STATUS;

	    STATUS = PROCESS_ONE_OPTION(
		SJC$_QUEUE,
		CH$RCHAR(MBX[ACM$T_QUEUE_1]),
		MBX[ACM$T_QUEUE_1]+1);
	    IF NOT .STATUS THEN RETURN .STATUS;
	    IF NOT FIND_QUEUE(VALUE_QUEUE; SQX_N, SQE, SMQ_N, SMQ)
		THEN RETURN JBC$_NOSUCHQUE;
	    PROC_ROUTINE = SJC_DEASSIGN_QUEUE;
	    END
	ELSE
	    BEGIN
	    LOCAL
		STATUS_1,
		STATUS_2;

	    STATUS_1 = PROCESS_ONE_OPTION(
		SJC$_DESTINATION_QUEUE,
		CH$RCHAR(MBX[ACM$T_QUEUE_1]),
		MBX[ACM$T_QUEUE_1]+1);
	    IF NOT .STATUS_1 THEN RETURN .STATUS_1;
	    STATUS_2 = PROCESS_ONE_OPTION(
		SJC$_QUEUE,
		CH$RCHAR(MBX[ACM$T_QUEUE_2]),
		MBX[ACM$T_QUEUE_2]+1);
	    IF NOT .STATUS_2 THEN RETURN .STATUS_2;
	    IF NOT FIND_QUEUE(VALUE_QUEUE; SQX_N, SQE, SMQ_N, SMQ)
		THEN RETURN JBC$_NOSUCHQUE;
	    END;
	END;


    [SMR$K_RELEASE]:
	BEGIN
	VALUE_ENTRY_NUMBER = .MBX[ACM$W_ENTRY_NUMBER];
	ITEM_PRESENT[SJC$_ENTRY_NUMBER] = TRUE;
	ITEM_PRESENT[SJC$_NO_HOLD] = TRUE;
	END;


    [SMR$K_RMVJOB]:
	BEGIN
	VALUE_ENTRY_NUMBER = .MBX[ACM$W_ENTRY_NUMBER];
	ITEM_PRESENT[SJC$_ENTRY_NUMBER] = TRUE;
	END;


    [SMR$K_START]:
	BEGIN
	IF .SMQ[SMQ$V_PAUSED] AND .SMQ[SMQ$B_CURRENT_JOB_COUNT] NEQ 0
	THEN
	    BEGIN
	    LOCAL
		STATUS;

	    STATUS = PROCESS_SNDSMB_OPTIONS(
		MBX[ACM$T_QUE_OPT],
		SMO$K_NEXTJOB, SMO$K_SPCCNT);
	    IF NOT .STATUS THEN RETURN .STATUS;
	    END
	ELSE
	    BEGIN
	    LOCAL
		STATUS;

	    STATUS = PROCESS_SNDSMB_OPTIONS(
		MBX[ACM$T_QUE_OPT],
		SMO$K_CURFORM, SMO$K_NODISWAP);
	    IF NOT .STATUS THEN RETURN .STATUS;
	    END;
	END;


    [SMR$K_SYNCJOB]:
	BEGIN
	IF .MBX[ACM$W_ENTRY_NUMBER] NEQ 0
	THEN
	    BEGIN
	    VALUE_ENTRY_NUMBER = .MBX[ACM$W_ENTRY_NUMBER];
	    ITEM_PRESENT[SJC$_ENTRY_NUMBER] = TRUE;
	    END;

	IF CH$RCHAR(MBX[ACM$T_JOBNAME]) NEQ 0
	THEN
	    BEGIN
	    LOCAL
		STATUS;

	    STATUS = PROCESS_ONE_OPTION(
		SJC$_JOB_NAME,
		CH$RCHAR(MBX[ACM$T_JOBNAME]),
		MBX[ACM$T_JOBNAME]+1);
	    IF NOT .STATUS THEN RETURN .STATUS;
	    END;
	END;


    [INRANGE]:
	0;


    TES;


! Dispatch to execute the request.
!
(.PROC_ROUTINE)(.SQX_N, .SQE, .SMQ_N, .SMQ)
END;

ROUTINE PROCESS_SNDJBC_ITEM_LIST=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine processes the item list of a $SNDJBC service into internal
!	data structures.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	MBX		- Pointer to buffered mailbox message.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	Values in the item list in internal storage.
!
! ROUTINE VALUE:
!	Completion status.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
LOCAL
	VALUE_CURSOR:	REF BBLOCK,	! Cursor over item list
	VALID_ITEMS:	REF BITVECTOR;	! Pointer to mask of valid item codes


MACRO
	BOOLEAN_VECTOR[]=
	    BITVECTOR[MAX_SNDJBC_ITEM+1] PSECT(CODE) ALIGN(0)
	    PRESET(BOOLEAN_VECTOR_1(%REMAINING)) %,

	BOOLEAN_VECTOR_1[A]=
	    [A] = TRUE %;


OWN
	NO_BITS:
	    BITVECTOR[MAX_SNDJBC_ITEM+1] PSECT(CODE) ALIGN(0) INITIAL(0),

	QUEUE_BIT:
	    BOOLEAN_VECTOR(
		SJC$_QUEUE),

	QUEUE_DEST_QUEUE_BITS:
	    BOOLEAN_VECTOR(
		SJC$_QUEUE,
		SJC$_DESTINATION_QUEUE),

	QUEUE_ENTRY_NUMBER_BITS:
	    BOOLEAN_VECTOR(
		SJC$_QUEUE,
		SJC$_ENTRY_NUMBER),

	ABORT_JOB_OPTIONS:
	    BOOLEAN_VECTOR(
		SJC$_QUEUE,
		SJC$_DESTINATION_QUEUE,
		SJC$_ENTRY_NUMBER,
		SJC$_HOLD,			SJC$_NO_HOLD,
		SJC$_PRIORITY,
		SJC$_REQUEUE),

	ADD_FILE_OPTIONS:
	    BOOLEAN_VECTOR(
		SJC$_FILE_IDENTIFICATION,
		SJC$_DELETE_FILE,		SJC$_NO_DELETE_FILE,
		SJC$_DOUBLE_SPACE,		SJC$_NO_DOUBLE_SPACE,
		SJC$_FILE_BURST,		SJC$_NO_FILE_BURST,
		SJC$_FILE_COPIES,
		SJC$_FILE_FLAG,			SJC$_NO_FILE_FLAG,
		SJC$_FILE_SETUP_MODULES,	SJC$_NO_FILE_SETUP_MODULES,
		SJC$_FILE_TRAILER,		SJC$_NO_FILE_TRAILER,
		SJC$_FIRST_PAGE,		SJC$_NO_FIRST_PAGE,
		SJC$_LAST_PAGE,			SJC$_NO_LAST_PAGE,
		SJC$_PAGE_HEADER,		SJC$_NO_PAGE_HEADER,
		SJC$_PAGINATE,			SJC$_NO_PAGINATE,
		SJC$_PASSALL,			SJC$_NO_PASSALL),

	ALTER_JOB_OPTIONS:
	    BOOLEAN_VECTOR(
		SJC$_QUEUE,
		SJC$_ENTRY_NUMBER,
		SJC$_AFTER_TIME,		SJC$_NO_AFTER_TIME,
		SJC$_CHARACTERISTIC_NAME,	SJC$_NO_CHARACTERISTICS,
		SJC$_CHARACTERISTIC_NUMBER,
						SJC$_NO_CHECKPOINT_DATA,
		SJC$_CLI,			SJC$_NO_CLI,
		SJC$_CPU_LIMIT,			SJC$_NO_CPU_LIMIT,
						SJC$_NO_DELETE_FILE,
		SJC$_DESTINATION_QUEUE,
		SJC$_DOUBLE_SPACE,		SJC$_NO_DOUBLE_SPACE,
		SJC$_FILE_BURST,		SJC$_NO_FILE_BURST,
		SJC$_FILE_COPIES,
		SJC$_FILE_FLAG,			SJC$_NO_FILE_FLAG,
		SJC$_FILE_SETUP_MODULES,	SJC$_NO_FILE_SETUP_MODULES,
		SJC$_FILE_TRAILER,		SJC$_NO_FILE_TRAILER,
		SJC$_FIRST_PAGE,		SJC$_NO_FIRST_PAGE,
		SJC$_FORM_NAME,
		SJC$_FORM_NUMBER,
		SJC$_HOLD,			SJC$_NO_HOLD,
		SJC$_JOB_COPIES,
		SJC$_JOB_NAME,
		SJC$_LAST_PAGE,			SJC$_NO_LAST_PAGE,
		SJC$_LOG_DELETE,		SJC$_NO_LOG_DELETE,
		SJC$_LOG_QUEUE,
		SJC$_LOG_SPECIFICATION,		SJC$_NO_LOG_SPECIFICATION,
		SJC$_LOG_SPOOL,			SJC$_NO_LOG_SPOOL,
		SJC$_LOWERCASE,			SJC$_NO_LOWERCASE,
		SJC$_NOTE,			SJC$_NO_NOTE,
		SJC$_NOTIFY,			SJC$_NO_NOTIFY,
		SJC$_OPERATOR_REQUEST,		SJC$_NO_OPERATOR_REQUEST,
		SJC$_PAGE_HEADER,		SJC$_NO_PAGE_HEADER,
		SJC$_PAGINATE,			SJC$_NO_PAGINATE,
		SJC$_PARAMETER_1,		SJC$_NO_PARAMETERS,
		SJC$_PARAMETER_2,
		SJC$_PARAMETER_3,
		SJC$_PARAMETER_4,
		SJC$_PARAMETER_5,
		SJC$_PARAMETER_6,
		SJC$_PARAMETER_7,
		SJC$_PARAMETER_8,
		SJC$_PASSALL,			SJC$_NO_PASSALL,
		SJC$_PRIORITY,
		SJC$_RESTART,			SJC$_NO_RESTART,
		SJC$_WSDEFAULT,			SJC$_NO_WSDEFAULT,
		SJC$_WSEXTENT,			SJC$_NO_WSEXTENT,
		SJC$_WSQUOTA,			SJC$_NO_WSQUOTA),

	ALTER_QUEUE_OPTIONS:
	    BOOLEAN_VECTOR(
		SJC$_QUEUE,
		SJC$_BASE_PRIORITY,
		SJC$_CHARACTERISTIC_NAME,	SJC$_NO_CHARACTERISTICS,
		SJC$_CHARACTERISTIC_NUMBER,
		SJC$_CPU_DEFAULT,		SJC$_NO_CPU_DEFAULT,
		SJC$_CPU_LIMIT,			SJC$_NO_CPU_LIMIT,
		SJC$_FILE_BURST,		SJC$_NO_FILE_BURST,
		SJC$_FILE_BURST_ONE,
		SJC$_FILE_FLAG,			SJC$_NO_FILE_FLAG,
		SJC$_FILE_FLAG_ONE,
		SJC$_FILE_TRAILER,		SJC$_NO_FILE_TRAILER,
		SJC$_FILE_TRAILER_ONE,
		SJC$_FORM_NAME,
		SJC$_FORM_NUMBER,
		SJC$_GENERIC_SELECTION,		SJC$_NO_GENERIC_SELECTION,
		SJC$_JOB_BURST,			SJC$_NO_JOB_BURST,
		SJC$_JOB_FLAG,			SJC$_NO_JOB_FLAG,
		SJC$_JOB_LIMIT,
		SJC$_JOB_RESET_MODULES,		SJC$_NO_JOB_RESET_MODULES,
		SJC$_JOB_SIZE_MAXIMUM,		SJC$_NO_JOB_SIZE_MAXIMUM,
		SJC$_JOB_SIZE_MINIMUM,		SJC$_NO_JOB_SIZE_MINIMUM,
		SJC$_JOB_SIZE_SCHEDULING,	SJC$_NO_JOB_SIZE_SCHEDULING,
		SJC$_JOB_TRAILER,		SJC$_NO_JOB_TRAILER,
		SJC$_OWNER_UIC,
		SJC$_PAGINATE,			SJC$_NO_PAGINATE,
		SJC$_PROTECTION,
		SJC$_RETAIN_ALL_JOBS,		SJC$_NO_RETAIN_JOBS,
		SJC$_RETAIN_ERROR_JOBS,
		SJC$_SWAP,			SJC$_NO_SWAP,
		SJC$_WSDEFAULT,			SJC$_NO_WSDEFAULT,
		SJC$_WSEXTENT,			SJC$_NO_WSEXTENT,
		SJC$_WSQUOTA,			SJC$_NO_WSQUOTA),

	BATCH_CHECKPOINT_OPTIONS:
	    BOOLEAN_VECTOR(
		SJC$_CHECKPOINT_DATA),

	BATCH_SERVICE_OPTIONS:
	    BOOLEAN_VECTOR(
		SJC$_BATCH_INPUT,
		SJC$_BATCH_OUTPUT),

	CLOSE_JOB_OPTIONS:
	    BOOLEAN_VECTOR(
		SJC$_JOB_STATUS_OUTPUT),

	CREATE_JOB_OPTIONS:
	    BOOLEAN_VECTOR(
		SJC$_QUEUE,
		SJC$_ENTRY_NUMBER_OUTPUT,
		SJC$_ACCOUNT_NAME,
		SJC$_AFTER_TIME,		SJC$_NO_AFTER_TIME,
		SJC$_CHARACTERISTIC_NAME,	SJC$_NO_CHARACTERISTICS,
		SJC$_CHARACTERISTIC_NUMBER,
		SJC$_CLI,			SJC$_NO_CLI,
		SJC$_CPU_LIMIT,			SJC$_NO_CPU_LIMIT,
		SJC$_FILE_BURST,		SJC$_NO_FILE_BURST,
		SJC$_FILE_BURST_ONE,
		SJC$_FILE_FLAG,			SJC$_NO_FILE_FLAG,
		SJC$_FILE_FLAG_ONE,
		SJC$_FILE_TRAILER,		SJC$_NO_FILE_TRAILER,
		SJC$_FILE_TRAILER_ONE,
		SJC$_FORM_NAME,
		SJC$_FORM_NUMBER,
		SJC$_HOLD,			SJC$_NO_HOLD,
		SJC$_JOB_COPIES,
		SJC$_JOB_NAME,
		SJC$_LOG_DELETE,		SJC$_NO_LOG_DELETE,
		SJC$_LOG_QUEUE,
		SJC$_LOG_SPECIFICATION,		SJC$_NO_LOG_SPECIFICATION,
		SJC$_LOG_SPOOL,			SJC$_NO_LOG_SPOOL,
		SJC$_LOWERCASE,			SJC$_NO_LOWERCASE,
		SJC$_NOTE,			SJC$_NO_NOTE,
		SJC$_NOTIFY,			SJC$_NO_NOTIFY,
		SJC$_OPERATOR_REQUEST,		SJC$_NO_OPERATOR_REQUEST,
		SJC$_PARAMETER_1,		SJC$_NO_PARAMETERS,
		SJC$_PARAMETER_2,
		SJC$_PARAMETER_3,
		SJC$_PARAMETER_4,
		SJC$_PARAMETER_5,
		SJC$_PARAMETER_6,
		SJC$_PARAMETER_7,
		SJC$_PARAMETER_8,
		SJC$_PRIORITY,
		SJC$_RESTART,			SJC$_NO_RESTART,
		SJC$_UIC,
		SJC$_USERNAME,
		SJC$_USER_IDENTIFICATION,
		SJC$_WSDEFAULT,			SJC$_NO_WSDEFAULT,
		SJC$_WSEXTENT,			SJC$_NO_WSEXTENT,
		SJC$_WSQUOTA,			SJC$_NO_WSQUOTA),

	CREATE_QUEUE_OPTIONS:
	    BOOLEAN_VECTOR(
		SJC$_QUEUE,
		SJC$_BASE_PRIORITY,
		SJC$_BATCH,			SJC$_NO_BATCH,
		SJC$_CHARACTERISTIC_NAME,	SJC$_NO_CHARACTERISTICS,
		SJC$_CHARACTERISTIC_NUMBER,
		SJC$_CPU_DEFAULT,		SJC$_NO_CPU_DEFAULT,
		SJC$_CPU_LIMIT,			SJC$_NO_CPU_LIMIT,
		SJC$_CREATE_START,
		SJC$_DEVICE_NAME,
		SJC$_FILE_BURST,		SJC$_NO_FILE_BURST,
		SJC$_FILE_BURST_ONE,
		SJC$_FILE_FLAG,			SJC$_NO_FILE_FLAG,
		SJC$_FILE_FLAG_ONE,
		SJC$_FILE_TRAILER,		SJC$_NO_FILE_TRAILER,
		SJC$_FILE_TRAILER_ONE,
		SJC$_FORM_NAME,
		SJC$_FORM_NUMBER,
		SJC$_GENERIC_QUEUE,		SJC$_NO_GENERIC_QUEUE,
		SJC$_GENERIC_SELECTION,		SJC$_NO_GENERIC_SELECTION,
		SJC$_GENERIC_TARGET,
		SJC$_JOB_BURST,			SJC$_NO_JOB_BURST,
		SJC$_JOB_FLAG,			SJC$_NO_JOB_FLAG,
		SJC$_JOB_LIMIT,
		SJC$_JOB_RESET_MODULES,		SJC$_NO_JOB_RESET_MODULES,
		SJC$_JOB_SIZE_MAXIMUM,		SJC$_NO_JOB_SIZE_MAXIMUM,
		SJC$_JOB_SIZE_MINIMUM,		SJC$_NO_JOB_SIZE_MINIMUM,
		SJC$_JOB_SIZE_SCHEDULING,	SJC$_NO_JOB_SIZE_SCHEDULING,
		SJC$_JOB_TRAILER,		SJC$_NO_JOB_TRAILER,
		SJC$_LIBRARY_SPECIFICATION,	SJC$_NO_LIBRARY_SPECIFICATION,
		SJC$_OWNER_UIC,
		SJC$_PAGINATE,			SJC$_NO_PAGINATE,
		SJC$_PROCESSOR,			SJC$_NO_PROCESSOR,
		SJC$_PROTECTION,
		SJC$_RETAIN_ALL_JOBS,		SJC$_NO_RETAIN_JOBS,
		SJC$_RETAIN_ERROR_JOBS,
		SJC$_SCSNODE_NAME,
		SJC$_SWAP,			SJC$_NO_SWAP,
		SJC$_TERMINAL,			SJC$_NO_TERMINAL,
		SJC$_WSDEFAULT,			SJC$_NO_WSDEFAULT,
		SJC$_WSEXTENT,			SJC$_NO_WSEXTENT,
		SJC$_WSQUOTA,			SJC$_NO_WSQUOTA),

	DEFINE_CHARACTERISTIC_OPTIONS:
	    BOOLEAN_VECTOR(
		SJC$_CHARACTERISTIC_NAME,
		SJC$_CHARACTERISTIC_NUMBER),

	DEFINE_FORM_OPTIONS:
	    BOOLEAN_VECTOR(
		SJC$_FORM_NAME,
		SJC$_FORM_NUMBER,
		SJC$_FORM_DESCRIPTION,
		SJC$_FORM_LENGTH,
		SJC$_FORM_MARGIN_BOTTOM,
		SJC$_FORM_MARGIN_LEFT,
		SJC$_FORM_MARGIN_RIGHT,
		SJC$_FORM_MARGIN_TOP,
		SJC$_FORM_SETUP_MODULES,	SJC$_NO_FORM_SETUP_MODULES,
		SJC$_FORM_SHEET_FEED,		SJC$_NO_FORM_SHEET_FEED,
		SJC$_FORM_STOCK,
		SJC$_FORM_TRUNCATE,		SJC$_NO_FORM_TRUNCATE,
		SJC$_FORM_WIDTH,
		SJC$_FORM_WRAP,			SJC$_NO_FORM_WRAP,
		SJC$_PAGE_SETUP_MODULES,	SJC$_NO_PAGE_SETUP_MODULES),

	DEFINE_FORM_REQUIRED:
	    BOOLEAN_VECTOR(
		SJC$_FORM_NAME,
		SJC$_FORM_NUMBER),

	DELETE_CHARACTERISTIC_OPTIONS:
	    BOOLEAN_VECTOR(
		SJC$_CHARACTERISTIC_NAME),

	DELETE_FORM_OPTIONS:
	    BOOLEAN_VECTOR(
		SJC$_FORM_NAME),

	ENTER_FILE_OPTIONS:
	    BOOLEAN_VECTOR(
		SJC$_QUEUE,
		SJC$_FILE_IDENTIFICATION,
		SJC$_ENTRY_NUMBER_OUTPUT,
		SJC$_JOB_STATUS_OUTPUT,
		SJC$_ACCOUNT_NAME,
		SJC$_AFTER_TIME,		SJC$_NO_AFTER_TIME,
		SJC$_BATCH_INPUT,
		SJC$_CHARACTERISTIC_NAME,	SJC$_NO_CHARACTERISTICS,
		SJC$_CHARACTERISTIC_NUMBER,
		SJC$_CLI,			SJC$_NO_CLI,
		SJC$_CPU_LIMIT,			SJC$_NO_CPU_LIMIT,
		SJC$_DELETE_FILE,		SJC$_NO_DELETE_FILE,
		SJC$_DOUBLE_SPACE,		SJC$_NO_DOUBLE_SPACE,
		SJC$_FILE_BURST,		SJC$_NO_FILE_BURST,
		SJC$_FILE_COPIES,
		SJC$_FILE_FLAG,			SJC$_NO_FILE_FLAG,
		SJC$_FILE_SETUP_MODULES,	SJC$_NO_FILE_SETUP_MODULES,
		SJC$_FILE_TRAILER,		SJC$_NO_FILE_TRAILER,
		SJC$_FIRST_PAGE,		SJC$_NO_FIRST_PAGE,
		SJC$_FORM_NAME,
		SJC$_FORM_NUMBER,
		SJC$_HOLD,			SJC$_NO_HOLD,
		SJC$_JOB_COPIES,
		SJC$_JOB_NAME,
		SJC$_LAST_PAGE,			SJC$_NO_LAST_PAGE,
		SJC$_LOG_DELETE,		SJC$_NO_LOG_DELETE,
		SJC$_LOG_QUEUE,
		SJC$_LOG_SPECIFICATION,		SJC$_NO_LOG_SPECIFICATION,
		SJC$_LOG_SPOOL,			SJC$_NO_LOG_SPOOL,
		SJC$_LOWERCASE,			SJC$_NO_LOWERCASE,
		SJC$_NOTE,			SJC$_NO_NOTE,
		SJC$_NOTIFY,			SJC$_NO_NOTIFY,
		SJC$_OPERATOR_REQUEST,		SJC$_NO_OPERATOR_REQUEST,
		SJC$_PAGE_HEADER,		SJC$_NO_PAGE_HEADER,
		SJC$_PAGINATE,			SJC$_NO_PAGINATE,
		SJC$_PARAMETER_1,		SJC$_NO_PARAMETERS,
		SJC$_PARAMETER_2,
		SJC$_PARAMETER_3,
		SJC$_PARAMETER_4,
		SJC$_PARAMETER_5,
		SJC$_PARAMETER_6,
		SJC$_PARAMETER_7,
		SJC$_PARAMETER_8,
		SJC$_PASSALL,			SJC$_NO_PASSALL,
		SJC$_PRIORITY,
		SJC$_RESTART,			SJC$_NO_RESTART,
		SJC$_UIC,
		SJC$_USERNAME,
		SJC$_USER_IDENTIFICATION,
		SJC$_WSDEFAULT,			SJC$_NO_WSDEFAULT,
		SJC$_WSEXTENT,			SJC$_NO_WSEXTENT,
		SJC$_WSQUOTA,			SJC$_NO_WSQUOTA),

	RESERVED_FUNC_OPTIONS:
	    BOOLEAN_VECTOR(
		SJC$_RESERVED_BOOLEAN_1,	SJC$_RESERVED_BOOLEAN_2,
		SJC$_RESERVED_BOOLEAN_3,	SJC$_RESERVED_BOOLEAN_4,
		SJC$_RESERVED_INPUT_1,		SJC$_RESERVED_INPUT_2,
		SJC$_RESERVED_INPUT_3,		SJC$_RESERVED_INPUT_4,
		SJC$_RESERVED_OUTPUT_1,		SJC$_RESERVED_OUTPUT_2),

	START_ACCOUNTING_OPTIONS:
	    BOOLEAN_VECTOR(
		SJC$_ACCOUNTING_TYPES,
		SJC$_NEW_VERSION),

	START_QUEUE_OPTIONS:
	    BOOLEAN_VECTOR(
		SJC$_QUEUE,
		SJC$_ALIGNMENT_MASK,
		SJC$_ALIGNMENT_PAGES,
		SJC$_BASE_PRIORITY,
		SJC$_BATCH,			SJC$_NO_BATCH,
		SJC$_CHARACTERISTIC_NAME,	SJC$_NO_CHARACTERISTICS,
		SJC$_CHARACTERISTIC_NUMBER,
		SJC$_CPU_DEFAULT,		SJC$_NO_CPU_DEFAULT,
		SJC$_CPU_LIMIT,			SJC$_NO_CPU_LIMIT,
		SJC$_DEVICE_NAME,
		SJC$_FILE_BURST,		SJC$_NO_FILE_BURST,
		SJC$_FILE_BURST_ONE,
		SJC$_FILE_FLAG,			SJC$_NO_FILE_FLAG,
		SJC$_FILE_FLAG_ONE,
		SJC$_FILE_TRAILER,		SJC$_NO_FILE_TRAILER,
		SJC$_FILE_TRAILER_ONE,
		SJC$_FORM_NAME,
		SJC$_FORM_NUMBER,
		SJC$_GENERIC_QUEUE,		SJC$_NO_GENERIC_QUEUE,
		SJC$_GENERIC_SELECTION,		SJC$_NO_GENERIC_SELECTION,
		SJC$_GENERIC_TARGET,
		SJC$_JOB_BURST,			SJC$_NO_JOB_BURST,
		SJC$_JOB_FLAG,			SJC$_NO_JOB_FLAG,
		SJC$_JOB_LIMIT,
		SJC$_JOB_RESET_MODULES,		SJC$_NO_JOB_RESET_MODULES,
		SJC$_JOB_SIZE_MAXIMUM,		SJC$_NO_JOB_SIZE_MAXIMUM,
		SJC$_JOB_SIZE_MINIMUM,		SJC$_NO_JOB_SIZE_MINIMUM,
		SJC$_JOB_SIZE_SCHEDULING,	SJC$_NO_JOB_SIZE_SCHEDULING,
		SJC$_JOB_TRAILER,		SJC$_NO_JOB_TRAILER,
		SJC$_LIBRARY_SPECIFICATION,	SJC$_NO_LIBRARY_SPECIFICATION,
		SJC$_NEXT_JOB,
		SJC$_OWNER_UIC,
		SJC$_PAGINATE,			SJC$_NO_PAGINATE,
		SJC$_PROCESSOR,			SJC$_NO_PROCESSOR,
		SJC$_PROTECTION,
		SJC$_RETAIN_ALL_JOBS,		SJC$_NO_RETAIN_JOBS,
		SJC$_RETAIN_ERROR_JOBS,
		SJC$_RELATIVE_PAGE,
		SJC$_SCSNODE_NAME,
		SJC$_SEARCH_STRING,
		SJC$_SWAP,			SJC$_NO_SWAP,
		SJC$_TERMINAL,			SJC$_NO_TERMINAL,
		SJC$_TOP_OF_FILE,
		SJC$_WSDEFAULT,			SJC$_NO_WSDEFAULT,
		SJC$_WSEXTENT,			SJC$_NO_WSEXTENT,
		SJC$_WSQUOTA,			SJC$_NO_WSQUOTA),

	START_QUEUE_MANAGER_OPTIONS:
	    BOOLEAN_VECTOR(
		SJC$_BUFFER_COUNT,
		SJC$_EXTEND_QUANTITY,
		SJC$_NEW_VERSION,
		SJC$_QUEUE_FILE_SPECIFICATION),

	STOP_ACCOUNTING_OPTIONS:
	    BOOLEAN_VECTOR(
		SJC$_ACCOUNTING_TYPES),

	SYNCHRONIZE_OPTIONS:
	    BOOLEAN_VECTOR(
		SJC$_QUEUE,
		SJC$_ENTRY_NUMBER,
		SJC$_JOB_NAME),

	WRITE_ACCOUNTING_OPTIONS:
	    BOOLEAN_VECTOR(
		SJC$_ACCOUNTING_MESSAGE),

	VALID_ITEM_TABLE:	VECTOR[MAX_SNDJBC_FUNC+1] PSECT(CODE) PRESET(
		[SJC$_ABORT_JOB]=		ABORT_JOB_OPTIONS,
		[SJC$_ADD_FILE]=		ADD_FILE_OPTIONS,
		[SJC$_ALTER_JOB]=		ALTER_JOB_OPTIONS,
		[SJC$_ALTER_QUEUE]=		ALTER_QUEUE_OPTIONS,
		[SJC$_ASSIGN_QUEUE]=		QUEUE_DEST_QUEUE_BITS,
		[SJC$_BATCH_CHECKPOINT]=	BATCH_CHECKPOINT_OPTIONS,
		[SJC$_BATCH_SERVICE]=		BATCH_SERVICE_OPTIONS,
		[SJC$_CLOSE_DELETE]=		NO_BITS,
		[SJC$_CLOSE_JOB]=		CLOSE_JOB_OPTIONS,
		[SJC$_CREATE_JOB]=		CREATE_JOB_OPTIONS,
		[SJC$_CREATE_QUEUE]=		CREATE_QUEUE_OPTIONS,
		[SJC$_DEASSIGN_QUEUE]=		QUEUE_BIT,
		[SJC$_DEFINE_CHARACTERISTIC]=	DEFINE_CHARACTERISTIC_OPTIONS,
		[SJC$_DEFINE_FORM]=		DEFINE_FORM_OPTIONS,
		[SJC$_DELETE_CHARACTERISTIC]=	DELETE_CHARACTERISTIC_OPTIONS,
		[SJC$_DELETE_FORM]=		DELETE_FORM_OPTIONS,
		[SJC$_DELETE_JOB]=		QUEUE_ENTRY_NUMBER_BITS,
		[SJC$_DELETE_QUEUE]=		QUEUE_BIT,
		[SJC$_ENTER_FILE]=		ENTER_FILE_OPTIONS,
		[SJC$_MERGE_QUEUE]=		QUEUE_DEST_QUEUE_BITS,
		[SJC$_PAUSE_QUEUE]=		QUEUE_BIT,
		[SJC$_RESERVED_FUNC_1]=		RESERVED_FUNC_OPTIONS,
		[SJC$_RESERVED_FUNC_2]=		RESERVED_FUNC_OPTIONS,
		[SJC$_RESET_QUEUE]=		QUEUE_BIT,
		[SJC$_START_ACCOUNTING]=	START_ACCOUNTING_OPTIONS,
		[SJC$_START_QUEUE]=		START_QUEUE_OPTIONS,
		[SJC$_START_QUEUE_MANAGER]=	START_QUEUE_MANAGER_OPTIONS,
		[SJC$_STOP_ACCOUNTING]=		STOP_ACCOUNTING_OPTIONS,
		[SJC$_STOP_QUEUE]=		QUEUE_BIT,
		[SJC$_STOP_QUEUE_MANAGER]=	NO_BITS,
		[SJC$_SYNCHRONIZE_JOB]=		SYNCHRONIZE_OPTIONS,
		[SJC$_WRITE_ACCOUNTING]=	WRITE_ACCOUNTING_OPTIONS),

	REQUIRED_ITEM_TABLE:	VECTOR[MAX_SNDJBC_FUNC+1] PSECT(CODE) PRESET(
		[SJC$_ABORT_JOB]=		QUEUE_BIT,
		[SJC$_ADD_FILE]=		NO_BITS,
		[SJC$_ALTER_JOB]=		QUEUE_ENTRY_NUMBER_BITS,
		[SJC$_ALTER_QUEUE]=		QUEUE_BIT,
		[SJC$_ASSIGN_QUEUE]=		QUEUE_DEST_QUEUE_BITS,
		[SJC$_BATCH_CHECKPOINT]=	BATCH_CHECKPOINT_OPTIONS,
		[SJC$_BATCH_SERVICE]=		NO_BITS,
		[SJC$_CLOSE_DELETE]=		NO_BITS,
		[SJC$_CLOSE_JOB]=		NO_BITS,
		[SJC$_CREATE_JOB]=		QUEUE_BIT,
		[SJC$_CREATE_QUEUE]=		QUEUE_BIT,
		[SJC$_DEASSIGN_QUEUE]=		QUEUE_BIT,
		[SJC$_DEFINE_CHARACTERISTIC]=	DEFINE_CHARACTERISTIC_OPTIONS,
		[SJC$_DEFINE_FORM]=		DEFINE_FORM_REQUIRED,
		[SJC$_DELETE_CHARACTERISTIC]=	DELETE_CHARACTERISTIC_OPTIONS,
		[SJC$_DELETE_FORM]=		DELETE_FORM_OPTIONS,
		[SJC$_DELETE_JOB]=		QUEUE_ENTRY_NUMBER_BITS,
		[SJC$_DELETE_QUEUE]=		QUEUE_BIT,
		[SJC$_ENTER_FILE]=		QUEUE_BIT,
		[SJC$_MERGE_QUEUE]=		QUEUE_DEST_QUEUE_BITS,
		[SJC$_PAUSE_QUEUE]=		QUEUE_BIT,
		[SJC$_RESERVED_FUNC_1]=		NO_BITS,
		[SJC$_RESERVED_FUNC_2]=		NO_BITS,
		[SJC$_RESET_QUEUE]=		QUEUE_BIT,
		[SJC$_START_ACCOUNTING]=	NO_BITS,
		[SJC$_START_QUEUE]=		QUEUE_BIT,
		[SJC$_START_QUEUE_MANAGER]=	NO_BITS,
		[SJC$_STOP_ACCOUNTING]=		NO_BITS,
		[SJC$_STOP_QUEUE]=		QUEUE_BIT,
		[SJC$_STOP_QUEUE_MANAGER]=	NO_BITS,
		[SJC$_SYNCHRONIZE_JOB]=		QUEUE_BIT,
		[SJC$_WRITE_ACCOUNTING]=	WRITE_ACCOUNTING_OPTIONS),

	BOOLEAN_ITEM:
	    BOOLEAN_VECTOR(
						SJC$_NO_AFTER_TIME,
		SJC$_ALIGNMENT_MASK,
		SJC$_BATCH,			SJC$_NO_BATCH,
						SJC$_NO_CHARACTERISTICS,
						SJC$_NO_CHECKPOINT_DATA,
						SJC$_NO_CLI,
						SJC$_NO_CPU_DEFAULT,
						SJC$_NO_CPU_LIMIT,
		SJC$_CREATE_START,
		SJC$_DELETE_FILE,		SJC$_NO_DELETE_FILE,
		SJC$_DOUBLE_SPACE,		SJC$_NO_DOUBLE_SPACE,
		SJC$_FILE_BURST,		SJC$_NO_FILE_BURST,
		SJC$_FILE_BURST_ONE,
		SJC$_FILE_FLAG,			SJC$_NO_FILE_FLAG,
		SJC$_FILE_FLAG_ONE,
						SJC$_NO_FILE_SETUP_MODULES,
		SJC$_FILE_TRAILER,		SJC$_NO_FILE_TRAILER,
		SJC$_FILE_TRAILER_ONE,
						SJC$_NO_FIRST_PAGE,
						SJC$_NO_FORM_SETUP_MODULES,
		SJC$_FORM_SHEET_FEED,		SJC$_NO_FORM_SHEET_FEED,
		SJC$_FORM_TRUNCATE,		SJC$_NO_FORM_TRUNCATE,
		SJC$_FORM_WRAP,			SJC$_NO_FORM_WRAP,
		SJC$_GENERIC_QUEUE,		SJC$_NO_GENERIC_QUEUE,
		SJC$_GENERIC_SELECTION,		SJC$_NO_GENERIC_SELECTION,
		SJC$_HOLD,			SJC$_NO_HOLD,
		SJC$_JOB_BURST,			SJC$_NO_JOB_BURST,
		SJC$_JOB_FLAG,			SJC$_NO_JOB_FLAG,
						SJC$_NO_JOB_RESET_MODULES,
						SJC$_NO_JOB_SIZE_MAXIMUM,
						SJC$_NO_JOB_SIZE_MINIMUM,
		SJC$_JOB_SIZE_SCHEDULING,	SJC$_NO_JOB_SIZE_SCHEDULING,
		SJC$_JOB_TRAILER,		SJC$_NO_JOB_TRAILER,
						SJC$_NO_LAST_PAGE,
						SJC$_NO_LIBRARY_SPECIFICATION,
		SJC$_LOG_DELETE,		SJC$_NO_LOG_DELETE,
						SJC$_NO_LOG_SPECIFICATION,
		SJC$_LOG_SPOOL,			SJC$_NO_LOG_SPOOL,
		SJC$_LOWERCASE,			SJC$_NO_LOWERCASE,
		SJC$_NEW_VERSION,
		SJC$_NEXT_JOB,
						SJC$_NO_NOTE,
		SJC$_NOTIFY,			SJC$_NO_NOTIFY,
						SJC$_NO_OPERATOR_REQUEST,
		SJC$_PAGE_HEADER,		SJC$_NO_PAGE_HEADER,
						SJC$_NO_PAGE_SETUP_MODULES,
		SJC$_PAGINATE,			SJC$_NO_PAGINATE,
						SJC$_NO_PARAMETERS,
		SJC$_PASSALL,			SJC$_NO_PASSALL,
						SJC$_NO_PROCESSOR,
		SJC$_REQUEUE,
		SJC$_RESERVED_BOOLEAN_1,	SJC$_RESERVED_BOOLEAN_2,
		SJC$_RESERVED_BOOLEAN_3,	SJC$_RESERVED_BOOLEAN_4,
		SJC$_RESTART,			SJC$_NO_RESTART,
		SJC$_RETAIN_ALL_JOBS,		SJC$_NO_RETAIN_JOBS,
		SJC$_RETAIN_ERROR_JOBS,
		SJC$_SWAP,			SJC$_NO_SWAP,
		SJC$_TERMINAL,			SJC$_NO_TERMINAL,
		SJC$_TOP_OF_FILE,
						SJC$_NO_WSDEFAULT,
						SJC$_NO_WSEXTENT,
						SJC$_NO_WSQUOTA),

	OUTPUT_ITEM:
	    BOOLEAN_VECTOR(
		SJC$_BATCH_OUTPUT,
		SJC$_ENTRY_NUMBER_OUTPUT,
		SJC$_JOB_STATUS_OUTPUT,
		SJC$_RESERVED_OUTPUT_1,
		SJC$_RESERVED_OUTPUT_2);


! Initialize to scan the item list.
!
CH$FILL(0, VALUE_STORAGE_END - VALUE_STORAGE_BASE, VALUE_STORAGE_BASE);
VALUE_CURSOR = MBX[ACM$T_ITMLST];
VALID_ITEMS = .VALID_ITEM_TABLE[.MBX[ACM$W_FUNC]];


! Loop over all elements of the item list.
!
WHILE .VALUE_CURSOR LSSA .MBX_END DO
    BEGIN
    LOCAL
	CODE;			! Item code


    ! Fetch and validate the item code.
    !
    CODE = .VALUE_CURSOR[0,0,16,0];
    VALUE_CURSOR = .VALUE_CURSOR + 2;
    IF .CODE LSSU MIN_SNDJBC_ITEM OR .CODE GTRU MAX_SNDJBC_ITEM
	THEN RETURN JBC$_INVITMCOD;
    IF NOT .VALID_ITEMS[.CODE]
	THEN RETURN JBC$_INVITMCOD;
    ITEM_PRESENT[.CODE] = TRUE;


    ! If the item has a parameter value, fetch and validate it.
    !
    IF NOT .BOOLEAN_ITEM[.CODE]
    THEN
	BEGIN
	LOCAL
	    VALUE_SIZE,
	    STATUS;


	VALUE_SIZE = .VALUE_CURSOR[0,0,16,0];
	VALUE_CURSOR = .VALUE_CURSOR + 2;
	STATUS = PROCESS_ONE_OPTION(.CODE, .VALUE_SIZE, .VALUE_CURSOR);
	IF NOT .STATUS THEN RETURN .STATUS;
	IF .OUTPUT_ITEM[.CODE]
	    THEN VALUE_CURSOR = .VALUE_CURSOR + 8
	    ELSE VALUE_CURSOR = .VALUE_CURSOR + .VALUE_SIZE;
	END;
    END;


! Ensure that all required items are specified.
!
INCR I FROM 0 TO %SIZE(BITVECTOR[MAX_SNDJBC_ITEM+1])-1 DO
    BEGIN
    IF (.VECTOR[.REQUIRED_ITEM_TABLE[.MBX[ACM$W_FUNC]], .I; ,BYTE] AND
	.VECTOR[ITEM_PRESENT, .I; ,BYTE]) NEQ
	.VECTOR[.REQUIRED_ITEM_TABLE[.MBX[ACM$W_FUNC]], .I; ,BYTE]
    THEN
	RETURN JBC$_MISREQPAR;
    END;


SS$_NORMAL
END;

GLOBAL ROUTINE SNDJBC_SERVICE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine processes the message type:
!		MSG$_SNDJBC		send to job controller
!	by dispatching to a request-specific routine.
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	MBX		- Pointer to buffered mailbox message.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Completion status to be returned to requestor.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
OWN
	SEARCH_REQUIRED:	BITVECTOR[MAX_SNDJBC_FUNC+1]
	    PSECT(CODE) PRESET(
		[SJC$_ABORT_JOB]=		TRUE,
		[SJC$_ALTER_JOB]=		TRUE,
		[SJC$_ALTER_QUEUE]=		TRUE,
		[SJC$_ASSIGN_QUEUE]=		TRUE,
		[SJC$_CREATE_JOB]=		TRUE,
		[SJC$_DEASSIGN_QUEUE]=		TRUE,
		[SJC$_DELETE_JOB]=		TRUE,
		[SJC$_ENTER_FILE]=		TRUE,
		[SJC$_MERGE_QUEUE]=		TRUE,
		[SJC$_PAUSE_QUEUE]=		TRUE,
		[SJC$_RESET_QUEUE]=		TRUE,
		[SJC$_START_QUEUE]=		TRUE,
		[SJC$_STOP_QUEUE]=		TRUE,
		[SJC$_SYNCHRONIZE_JOB]=		TRUE),

	QUEUE_FILE_REQUIRED:	BITVECTOR[MAX_SNDJBC_FUNC+1]
	    PSECT(CODE) PRESET(
		[SJC$_ABORT_JOB]=		TRUE,
		[SJC$_ADD_FILE]=		TRUE,
		[SJC$_ALTER_JOB]=		TRUE,
		[SJC$_ALTER_QUEUE]=		TRUE,
		[SJC$_ASSIGN_QUEUE]=		TRUE,
		[SJC$_BATCH_SERVICE]=		TRUE,
		[SJC$_CLOSE_DELETE]=		TRUE,
		[SJC$_CLOSE_JOB]=		TRUE,
		[SJC$_CREATE_JOB]=		TRUE,
		[SJC$_CREATE_QUEUE]=		TRUE,
		[SJC$_DEASSIGN_QUEUE]=		TRUE,
		[SJC$_DEFINE_CHARACTERISTIC]=	TRUE,
		[SJC$_DEFINE_FORM]=		TRUE,
		[SJC$_DELETE_CHARACTERISTIC]=	TRUE,
		[SJC$_DELETE_FORM]=		TRUE,
		[SJC$_DELETE_JOB]=		TRUE,
		[SJC$_DELETE_QUEUE]=		TRUE,
		[SJC$_ENTER_FILE]=		TRUE,
		[SJC$_MERGE_QUEUE]=		TRUE,
		[SJC$_PAUSE_QUEUE]=		TRUE,
		[SJC$_RESET_QUEUE]=		TRUE,
		[SJC$_START_QUEUE]=		TRUE,
		[SJC$_STOP_QUEUE]=		TRUE,
		[SJC$_SYNCHRONIZE_JOB]=		TRUE),

	PROCESSING_ROUTINE:		VECTOR[MAX_SNDJBC_FUNC+1]
	    PSECT(CODE) PRESET(
		[SJC$_ABORT_JOB]=		SJC_ABORT_JOB,
		[SJC$_ADD_FILE]=		SJC_ADD_FILE,
		[SJC$_ALTER_JOB]=		SJC_ALTER_JOB,
		[SJC$_ALTER_QUEUE]=		SJC_ALTER_QUEUE,
		[SJC$_ASSIGN_QUEUE]=		SJC_ASSIGN_QUEUE,
		[SJC$_BATCH_CHECKPOINT]=	SJC_BATCH_CHECKPOINT,
		[SJC$_BATCH_SERVICE]=		SJC_BATCH_SERVICE,
		[SJC$_CLOSE_DELETE]=		SJC_CLOSE_DELETE,
		[SJC$_CLOSE_JOB]=		SJC_CLOSE_JOB,
		[SJC$_CREATE_JOB]=		SJC_CREATE_JOB,
		[SJC$_CREATE_QUEUE]=		SJC_CREATE_QUEUE,
		[SJC$_DEASSIGN_QUEUE]=		SJC_DEASSIGN_QUEUE,
		[SJC$_DEFINE_CHARACTERISTIC]=	SJC_DEFINE_CHARACTERISTIC,
		[SJC$_DEFINE_FORM]=		SJC_DEFINE_FORM,
		[SJC$_DELETE_CHARACTERISTIC]=	SJC_DELETE_CHARACTERISTIC,
		[SJC$_DELETE_FORM]=		SJC_DELETE_FORM,
		[SJC$_DELETE_JOB]=		SJC_DELETE_JOB,
		[SJC$_DELETE_QUEUE]=		SJC_DELETE_QUEUE,
		[SJC$_ENTER_FILE]=		SJC_ENTER_FILE,
		[SJC$_MERGE_QUEUE]=		SJC_MERGE_QUEUE,
		[SJC$_PAUSE_QUEUE]=		SJC_PAUSE_QUEUE,
		[SJC$_RESET_QUEUE]=		SJC_RESET_QUEUE,
		[SJC$_START_ACCOUNTING]=	SJC_START_ACCOUNTING,
		[SJC$_START_QUEUE]=		SJC_START_QUEUE,
		[SJC$_START_QUEUE_MANAGER]=	SJC_START_QUEUE_MANAGER,
		[SJC$_STOP_ACCOUNTING]=		SJC_STOP_ACCOUNTING,
		[SJC$_STOP_QUEUE]=		SJC_STOP_QUEUE,
		[SJC$_STOP_QUEUE_MANAGER]=	SJC_STOP_QUEUE_MANAGER,
		[SJC$_SYNCHRONIZE_JOB]=		SJC_SYNCHRONIZE_JOB,
		[SJC$_WRITE_ACCOUNTING]=	SJC_WRITE_ACCOUNTING);


LOCAL
	SQX_N,				! Record number of SQX
	SQE:		REF BBLOCK,	! Pointer to SQX entry
	SMQ_N,				! Record number of SMQ
	SMQ:		REF BBLOCK,	! Pointer to SMQ
	STATUS;


! Ensure that the function code is in range.
!
DIAG_TRACE[1] = .MBX[ACM$W_FUNC];	! ***** diagnostic info *****
IF .MBX[ACM$W_FUNC] LSSU MIN_SNDJBC_FUNC
OR .MBX[ACM$W_FUNC] GTRU MAX_SNDJBC_FUNC
THEN
    RETURN JBC$_INVFUNCOD;

SNDJBC_COUNT[.MBX[ACM$W_FUNC]] = .SNDJBC_COUNT[.MBX[ACM$W_FUNC]] + 1;


! Ensure that the queue file is open, and lock it.
!
IF .QUEUE_FILE_REQUIRED[.MBX[ACM$W_FUNC]]
THEN
    BEGIN
    IF .QUEUE_FAB[FAB$W_IFI] EQL 0 THEN RETURN JBC$_JOBQUEDIS;
    LOCK_QUEUE_FILE();
    END;


! Process the item list.
!
STATUS = PROCESS_SNDJBC_ITEM_LIST();
IF NOT .STATUS THEN RETURN .STATUS;


! If the request requires a queue search, search for the queue.
!
IF .SEARCH_REQUIRED[.MBX[ACM$W_FUNC]]
THEN
    IF NOT FIND_QUEUE(VALUE_QUEUE; SQX_N, SQE, SMQ_N, SMQ)
    THEN
	RETURN JBC$_NOSUCHQUE;


! Dispatch to execute the request.
!
(.PROCESSING_ROUTINE[.MBX[ACM$W_FUNC]])(.SQX_N, .SQE, .SMQ_N, .SMQ)
END;

END
ELUDOM
