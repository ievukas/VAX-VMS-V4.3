	.TITLE	XQDRIVER - VAX/VMS QNA driver
	.IDENT	'V04-000'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;++
; FACILITY:
;
;	VAX/VMS DEQNA QUEUE I/O DRIVER
;
; ABSTRACT:
;
;	This module contains the DEQNA driver FDT routines,
;	interrupt dispatcher, interrupt service and fork routines.
;
; AUTHOR:
;
;	Rod Gamache	26-Jul-1983
;
;
; MODIFICATION HISTORY:
;
;	V03-013	RNG0013		Rod Gamache		23-Jul-1984
;		Fix mode setup and shutdown.
;		Change default on ORB$B_FLAGS to not set ACL queue present bit.
;
;	V03-012	RNG0012		Rod Gamache		6-Jul-1984
;		Fix ALLOC_CDB to intialize the address of UCB unit 0.
;		Fix problems with re-starting FFI users and deleting
;		transmits on error.
;		Fix bug when disabling PROMiscuous mode in hardware.
;		Fix MOP read counters request.
;
;	V03-011	RNG0011		Rod Gamache		17-May-1984
;		Account for 4 bytes of CRC on received messages, when
;		returning byte count from assemble_pkt.
;		Change the way the "set default" modifier for the
;		Physical address is processed.
;
;	V03-010	RNG0010		Rod Gamache		11-May-1984
;		Fix the setup of the multicast address list for all
;		users after the first.
;
;	V03-009	RNG0009		Rod Gamache		 4-May-1984
;		Add DEV$M_NET flag to device characteristics.
;
;	V03-008	RNG0008		Rod Gamache		19-Apr-1984
;		Fix call to EXE$ALOPHYCNTG to be absolute addressing.
;
;	V03-007	RNG0007		Rod Gamache		12-Apr-1984
;		Fix problem with incorrect useage of the FFI interface.
;		Also, return the Hardware Ethernet Address.
;
;	V03-006	KPL0001		Peter Lieberwirth	 9-Apr-1984
;		Use EXE$ALOPHYCNTG to allocate physically-contiguous IO buffer
;		required by u-VAX I on the QNA.
;
;	V03-005	LMP0221		L. Mark Pilant,		27-Mar-1984  12:02
;		Change UCB$L_OWNUIC to ORB$L_OWNER and UCB$W_VPROT to
;		ORB$W_PROT.
;
;	V03-004	RNG0004		Rod N. Gamache		 6-Feb-1984
;		Set the XQ unit to RUN state when the QNA is initialized.
;		Make the SETMODE descriptor use a word for the length, rather
;		than a longword.
;
;	V03-003	TMK0002		Todd M. Katz		03-Feb-1984
;		When the DEQNA times out because of QBUS or device controller
;		power failure, then call back all protocols which are using the 
;		FFI interface and have defined an FFI$L_ERROR asynchronous 
;		error routine. What this involves is noticing within the 
;		routine SHUTDOWN by means of the UCB$V_POWER status bit that a 
;		power failure has occurred. In such a circumstance the port 
;		driver wants to call the asynchronous error routine of the 
;		protocol before doing anything else provided the protocol has 
;		initialized the FFI interface, defined an asynchronous error 
;		routine, and the UCB for the protocol is both on-line and 
;		initialized.
;
;	V03-002	TMK0001		Todd M. Katz		03-Feb-1984
;		Make the following changes to the driver:
;
;		1. I have created a NI device dependent UCB extension within
;		   $UCBDEF. This extension contains definitions for 
;		   UCB$L_NI_HWAPTR and UCB$L_NI_MLTPTR, two new locations
;		   to be contained within the UCBs of all NI datalink drivers.
;		   I have therefore modified the XQDRIVER's UCB definition 
;		   so that the DEQNA specific UCB fields begin immediately
;		   following the NI device dependent UCB extension.
;
;		   UCB$L_NI_HWAPTR is initialized when the CDB is first 
;		   allocated to contain the address of CDB_G_HWA, the CDB
;		   location which contains the NI device's unique hardware 
;		   address. UCB$L_NI_MLTPTR is initialized within the unit 
;		   unitialization routine to contain the address of the table 
;		   of multicast addresses defined for this protocol type.
;		   Both of these values must be accessible to the NI-SCS port
;		   driver. The NI-SCS port driver has access to the UCBs of the
;		   NI devices participating in SCS clusters, but it doesn't have
;		   initimate knowledge of how the UCBs and CDBs are layed out 
;		   for each NI device. This UCB extension provides a means for 
;		   the NI-SCS port driver to locate these values without knowing
;		   the exact layout of each of the NI device's UCB and CDB.
;
;		2. Whenever a protocol is to be started up on a DEQNA allow the 
;		   initiator of the SETMODE+STARTUP to specify 0 receive 
;		   buffers instead of the former minimum of 1. The effect on 
;		   this protocol is that it must have a READ outstanding at all 
;		   times in order to guarentee that it will receive all 
;		   datagrams specifying its protocol. If a datagram was 
;		   received for this protocol, and there wasn't a read 
;		   outstanding, then because 0 receive buffers can be queued
;		   (or saved) for this protocol, the receive buffer would be 
;		   deallocated to pool, and the message it contained lost.
;
;		   This change is extremely useful for those users who are
;		   making use of the FFI interface provided by this port driver.
;		   Between the time the user issues a SETMODE+STARTUP, and the
;		   time the user initializes the FFI interface by calling 
;		   FFI_INIT, it would be possible for the port driver to have
;		   received messages with this user's protocol, and to have
;		   queued them up to the appropriate UCB. Now, if the user
;		   never makes use of the QIO or ALTSTART interfaces, but just
;		   uses the FFI interfaces for communication, these messages,
;		   which are probably stale by this time, will never be 
;		   received, and the buffers that contain them will effectively
;		   be lost forever. With this change, a user who wishes to do
;		   all his/her communication via the FFI interface can guarentee
;		   that a situation such as this can never arise, and buffers
;		   such as these can never be "lost".
;
;		4. Add the capability of requesting that the physical address 
;		   of the DEQNA device be set to the default DECnet address, 
;		   when the device is first initialized. This new capability 
;		   is requested by means of the NMA$C_LNMCN_SDF mode value 
;		   specified within the modifier field of the NMA$C_PCLI_PHA 
;		   parameter.
;
;	V03-001	RNG0001		Rod Gamache		08-Dec-1983
;		Add new QNA "hand-shake" to prevent driver from reading
;		incorrect status from hardware.
;			
;--

;
; EXTERNAL SYMBOLS
;
	$ABDDEF				; Define ABDs
	$ACBDEF				; Define AST control block
	$CANDEF				; Define CANCEL reason codes
	$CCBDEF				; Define CCB offsets
	$CRBDEF				; Define CRB
	$CXBDEF				; Define CXB
	$DCDEF				; Define device classes and types
	$DDBDEF				; Define DDB
	$DEVDEF				; Define device characteristics
	$DPTDEF				; Define DPT
	$DYNDEF				; Define dynamic data structures
	$FFIDEF				; Fast Interface definitions
	$FKBDEF				; Fork block definitions
	$IDBDEF				; Define IDB
	$IODEF				; Define I/O function codes
	$IPLDEF				; Define IPLs
	$IRPDEF				; Define IRP
	$JIBDEF				; Define JIB
	$MSGDEF				; Define SYSTEM MESSAGES
	$NMADEF				; Define Network Management Codes
	$ORBDEF				; OBJECT'S RIGHTS BLOCK OFFSETS
	$PCBDEF				; Define PCB
	$PRDEF				; Processor register definitions
	$PRVDEF				; Privilege bit definitons
	$PTEDEF				; Define system PTEs
	$SSDEF				; Define System Status Codes
	$TQEDEF				; Define TQE offsets
	$UBADEF				; Define UBA symbols
	$UCBDEF				; Define UCB
	$VADEF				; Define Virtual Address bits
	$VECDEF				; Define CRB VECTOR
	$XMDEF				; Define DECnet datalink characteristics
;
; Local symbol definitions
;
 
;
; Define the following symbol to enable use of point-to-point mode
;
	POINT = 1			; Enable use of point-to-point mode

;
; Argument list offsets for QIO 
;
P1	= 0				; Parameter 1
P2	= 4				; Parameter 2
P3	= 8				; Parameter 3
P4	= 12				; Parameter 4
P5	= 16				; Destination/Source address

;
; Constants
;
$EQU	BRDCST1		<^XFFFFFFFF>	; Broadcast address
$EQU	BRDCST2		<^XFFFF>	;	...
$EQU	MAX_C_MLT	12		; Maximum number of multicast addresses
$EQU	MAX_C_XMT	4		; Maximum number of entries in XMT ring
$EQU	MAX_C_RCV	8		; Maximum number of entries in RCV ring
$EQU	MAX_C_XMTUV1	1		; Maximum number of XMTs on micro-VAX I
$EQU	MAX_C_RCVUV1	5		; Maximum number of RCVs on micro-VAX I
$EQU	MAX_PKT_SIZE	1500		; Size of maximum Ethernet user data
$EQU	XQ_C_HEADER	14		; Size of Ethernet header
$EQU	XQ_C_CRC	4		; Size of Ethernet CRC
$EQU	XQ_C_CNTSIZ	2		; Size of packet count field
$EQU	MAX_BUFSIZ_UV1	MAX_PKT_SIZE+XQ_C_HEADER
$EQU	UV1_BUFFER_AREA	<<MAX_C_XMTUV1+MAX_C_RCVUV1>*MAX_BUFSIZ_UV1>
$EQU	MAX_C_CHAIN	1		; Maximum number of extra segments in
					;  a receive buffer chain

$EQU	NI_CTR_PROTYP	<^X0260>	; Ethernet read counters protocol 60-02
$EQU	NI_CTR_READ	9		; Read counters request function
$EQU	NI_CTR_REPLY	11		; Read counters reply function

$EQU	INIT_C_QUOTA	6*1500		; Allow for 6 of the largest buffers
$EQU	INIT_C_AQUOTA	2		; Allow for 2 additional buffers
$EQU	INIT_C_BUFSIZE	128		; Size of init (setup mode) buffer
$EQU	DSC$A_POINTER	4		; Pointer to data in buffer descriptor
$EQU	MIN_PKT_SIZE	46		; Size of user data in a runt packet
$EQU	TQE_C_DELTA	2		; 2 second timer interval
$EQU	TQE_DELTA	TQE_C_DELTA*10000*1000 ; Delta interval (in 100 nsec)
$EQU	RESTART_DELTA	3*10000*1000	; RESTART interval - 3 Seconds
$EQU	XMT_C_TIM	8		; XMITS must take less than 8 seconds
$EQU	XMT_TIM		<<XMT_C_TIM+2>/2>
$EQU	DNI_C_TIM	10		; DNI settings must take less than 10s.
$EQU	DNI_TIM		<<DNI_C_TIM+2>/2>
$EQU	XQ_C_ADDRCV	64		; Size to add to received packets
$EQU	XQ_C_STPRO	<^X0660>	;% PT-TO-PT Starting protocol type 60-06
$EQU	IPL$_XQ_FIPL	8		; Fork IPL
$EQU	IPL$_XQ_DIPL	21		; Device IPL

;
; Local macros
;
.MACRO	SETBIT	VAL,FLAG
	.NTYPE	_$$_	VAL
	.IF EQ	<_$$_-^X0EF>
	.IF NDF	VAL
	BBSS	S^#VAL,FLAG,.+1
	.IFF
	.IF LT <VAL-8>
	BISB	#<1@VAL>,FLAG
	.IFF
	BBSS	#VAL,FLAG,.+1
	.ENDC
	.ENDC
	.IFF
	BBSS	VAL,FLAG,.+1
	.ENDC
.ENDM	SETBIT
;
; =======================
;
.MACRO	CLRBIT	VAL,FLAG
	.NTYPE	_$$_	VAL
	.IF EQ	<_$$_-^X0EF>
	.IF NDF	VAL
	BBCC	S^#VAL,FLAG,.+1
	.IFF
	.IF LT <VAL-8>
	BICB	#<1@VAL>,FLAG
	.IFF
	BBCC	#VAL,FLAG,.+1
	.ENDC
	.ENDC
	.IFF
	BBCC	VAL,FLAG,.+1
	.ENDC
.ENDM	CLRBIT
;
; =======================
;
.MACRO	INCC	COUNTER,CONTEXT=L,?L	; Increment counter
	INC'CONTEXT	COUNTER		; Do Increment
	BCC	l			; Br if no carry set
	DEC'CONTEXT	COUNTER		; Leave at maximum value
l:
.ENDM	INCC
;
; =======================
;
.MACRO	CNTR	CURCNT,COUNTER,CONTEXT=L,?L  ; Accumlate counter
	ADD'CONTEXT	CURCNT,COUNTER	; Do addition
	BCC	l			; Br if no carry set
	MNEG'CONTEXT	#1,COUNTER	; Leave at maximum value
l:
.ENDM	CNTR
;
; =======================
;
.MACRO	PUSHQ	ARG			; Push a quadword
	MOVQ	ARG,-(SP)		; Save argument on stack
.ENDM	PUSHQ
;
; =======================
;
.MACRO	POPQ	ARG			; Pop a quadword
	MOVQ	(SP)+,ARG		; Restore argument
.ENDM	POPQ
;
; =======================
;
.MACRO	PARAM	TYPE,OFFSET,WIDTH,MIN,MAX,INVALID,BASE=UCB,STRING,-
			SIZE,CHECK=YES
;
;	Macro to generate the parameter tables
;
; Inputs:
;
;	TYPE = Parameter type
;	OFFSET = Offset in UCB/CDB to current value
;	WIDTH = Width of field in UCB/CDB (B,W,L)
;	MIN = Minimum value parameter is allowed to take
;	MAX = Maximum value parameter is allowed to take
;	INVALID = Invalid flags in status word
;	BASE = Data base (CDB,UCB)
;	STRING = Parameter is a string value
;	SIZE = Maximum size of string parameter in bytes
;	CHECK = Comparison is needed (YES,NO)
;
	.IF BLANK type
	 .WORD	0
	.IF_FALSE	; BLANK type
	 $$$typ = type & prm_typ_m_code		; Isolate type code

	 $$$flg = 0
	 .IIF NOT_BLANK	<invalid>, $$$flg = $$$flg!prm_flg_m_invalid
	 .IIF IDN <check><YES>, $$$flg = $$$flg!prm_flg_m_check
	 .IIF IDN <base><CDB>, $$$flg = $$$flg!prm_flg_m_cdb

	 .IF BLANK string

		.WORD	$$$typ
	  .IIF NOT_BLANK	<min>, $$$flg = $$$flg!prm_flg_m_min
	  .IIF NOT_BLANK	<max>, $$$flg = $$$flg!prm_flg_m_max
		.BYTE	$$$flg
	  $$$off = offset & prm_off_m_value	; Isolate offset only
	  $$$wid = 0				; Set null width
	  .IIF IDN <width><B>, $$$wid = <1@prm_off_v_width>
	  .IIF IDN <width><W>, $$$wid = <2@prm_off_v_width>
	  .IIF IDN <width><L>, $$$wid = <3@prm_off_v_width>
		.WORD	$$$off!$$$wid
	  .IIF NOT_BLANK	<min>, .WORD	min
	  .IIF NOT_BLANK	<max>, .WORD	max
	  line_prm_bufsiz = line_prm_bufsiz + 6

	 .IF_FALSE	; BLANK STRING

		.WORD	$$$typ!prm_typ_m_string	; Indicate a string parameter
		.BYTE	$$$flg
	   $$$off = offset & prm_off_m_value	; Isolate offset only
	   $$$wid = <size @ prm_off_v_width> & prm_off_m_width ; Get max allowed
	   $$$siz = <$$$wid @ -prm_off_v_width>
		.WORD	$$$off!$$$wid
	   line_prm_bufsiz = line_prm_bufsiz + 4 + $$$siz

	 .ENDC		; BLANK STRING

	 .IIF NOT_BLANK	<invalid>, .WORD    invalid

	.ENDC		; BLANK TYPE
.ENDM	PARAM
;
; =======================
;
.MACRO	OFSET	SIZE,OFFSET,BASE
	.IF IDN <base><LINE>
	.WORD	cdb_'size'_'offset'
	.IFF
	.WORD	ucb$'size'_XQ_'offset'
	.ENDC
.ENDM	OFSET
;
; =======================
;
.MACRO	COUNTER	TYPE,WIDTH=16,OFFSET=0,BASE=LINE,BITMAP
	.IIF NDF 'base'_ctr_size, 'base'_ctr_size = 0
	.IIF NDF 'base'_ctr_bufsiz, 'base'_ctr_bufsiz = 0
	.IF IDN <base><LINE>
	$$$typ = nma$c_ctlin_'type' & nma$m_cnt_typ
	.IFF
	$$$typ = nma$c_ctcir_'type' & nma$m_cnt_typ
	.ENDC
	$$$wid = 0			; Set reserved mask width
	.IIF IDN <width><8>, $$$wid = <1@nma$v_cnt_wid>
	.IIF IDN <width><16>, $$$wid = <2@nma$v_cnt_wid>
	.IIF IDN <width><32>, $$$wid = <3@nma$v_cnt_wid>
	.IIF EQ $$$wid, .ERROR		; Invalid bit width value
	$$$map = 0
	.IIF IDN <bitmap><MAP>, $$$map = nma$m_cnt_map
	.WORD	nma$m_cnt_cou!$$$wid!$$$typ!$$$map
	.IIF IDN <width><8>, OFSET B,'offset,'base
	.IIF IDN <width><16>, OFSET W,'offset,'base
	.IIF IDN <width><32>, OFSET L,'offset,'base
	'base'_ctr_size = 'base'_ctr_size + 1	; Tally one more entry
	'base'_ctr_bufsiz = 'base'_ctr_bufsiz + 2 + <width/8>
	.IIF IDN <bitmap><MAP>, 'base'_ctr_bufsiz = 'base'_ctr_bufsiz + 2
.ENDM	COUNTER
;
; =======================
;
.MACRO	MOPCTR	WIDTH=16,OFFSET,BITMAP
	.IIF NDF mop_ctr_size, mop_ctr_size = 0
	$$$map = 0
	$$$wid = width/8
	.IIF IDN <bitmap><MAP>, $$$map = 1@7
	.IF NOT_BLANK	<offset>
	    .IIF IDN <width><8>, OFSET B,'offset,LINE
	    .IIF IDN <width><16>, OFSET W,'offset,LINE
	    .IIF IDN <width><32>, OFSET L,'offset,LINE
	    .BYTE	$$$map!$$$wid	; Counter width in bytes + BITMAP FLAG
	    mop_ctr_size = mop_ctr_size + $$$wid
	    .IIF IDN <bitmap><MAP>, mop_ctr_size = mop_ctr_size + 2
	.IFF ; NOT_BLANK
	    .WORD	0		; End of table
	.ENDC ; NOT_BLANK
.ENDM	MOPCTR
;
; =======================
;
.MACRO	SKIP	BIT,LOC,REG,CONTEXT=W,?L	; SKIP FIELD
	BBC	#BIT,LOC,l		; Br if field not present
	TST'CONTEXT	(REG)+		; Skip next field
l:
.ENDM	SKIP
;
; =======================
;
.MACRO	$DISPATCH,	INDX,VECTOR,TYPE=W,NMODE=S^#,?MN,?MX,?S,?SS,?ZZ
SS:

	.MACRO	$DSP1,$DSP1_1
		.IRP	$DSP1_2,$DSP1_1
			$DSP2	$DSP1_2
		.ENDR
	.ENDM	$DSP1

	.MACRO	$DSP2,$DSP2_1,$DSP2_2
		.=<$DSP2_1-MN>*2 + S
		.WORD	$DSP2_2-S
	.ENDM	$DSP2


	.MACRO	$BND1,$BND1_1,$BND1_2,$BND1_3
		$BND2	$BND1_1,$BND1_2
	.ENDM	$BND1

	.MACRO	$BND2,$BND2_1,$BND2_2
		.IIF	$BND2_1,$BND2_2-.,	.=$BND2_2
	.ENDM	$BND2

	.MACRO	$BND	$BND_1,$BND_2
		.IRP	$BND_3,<$BND_2>
			$BND1	$BND_1,$BND_3
		.ENDR
	.ENDM	$BND

	.=0
ZZ:
	$BND	GT,<VECTOR>
MX:
	$BND	LT,<VECTOR>
MN:
	.=SS

CASE'TYPE	INDX,#<MN-ZZ>,NMODE'<MX-MN>
S:
	.REPT	MX-MN+1
	.WORD	<MX-MN>*2 + 2
	.ENDR

	.=S

	$DSP1	<<VECTOR>>

	.=<MX-MN>*2 + S + 2

.ENDM	$DISPATCH


;
; Overlays of IRP
;
	$DEFINI	IRP	GLOBAL
 
. = IRP$W_FUNC+1
$DEF	IRP$B_XQ_FUNC	.BLKB	1	; QNA driver internal function code
 
. = IRP$L_MEDIA
$DEF	IRP$W_XQ_RID			; RCV/XMT request ID
$DEF	IRP$B_XQ_SLOT	.BLKB	1	; RCV/XMT mapping slot number
$DEF	IRP$B_XQ_RING	.BLKB	1	; RCV/XMT ring entry number

. = IRP$Q_STATION+6
$DEF	IRP$B_XQ_DATAP	.BLKB	1	; XMT buffered data path number

. = IRP$L_MEDIA+4
$DEF	IRP$L_XQ_SYSBUF	.BLKL	1	; XMT system buffer address

. = IRP$L_MEDIA+4
$DEF	IRP$L_XQ_DATBUF	.BLKL	1	; User RCV data buffer address

. = IRP$L_MEDIA
$DEF	IRP$W_XQ_USERSIZ .BLKW	1	; User P2 buffer size on sensemode

. = IRP$L_MEDIA+2
$DEF	IRP$W_XQ_STATUS	.BLKW	1	; Completion status

. = IRP$L_MEDIA+4
$DEF	IRP$L_XQ_USERBUF .BLKL	1	; User P1 buffer address on sensemode

. = IRP$Q_STATION
$DEF	IRP$L_XQ_P2BUF	.BLKL	1	; User P2 buffer address on sensemode

. = IRP$Q_STATION+4
$DEF	IRP$W_XQ_P2SIZ	.BLKW	1	; P2 return buffer size on sensemode

. = IRP$Q_STATION
$DEF	IRP$W_XQ_CODE	.BLKW	1	; Bad parameter code on startup request

. = IRP$L_MEDIA+4
$DEF	IRP$L_XQ_MAP	.BLKL	1	; Diagnostics buffer mapping info

. = IRP$Q_STATION
$DEF	IRP$L_XQ_DGUNI	.BLKL	1	; Diagnostics buffer UNIBUS address
$DEF	IRP$L_XQ_UPADR	.BLKW	1	; Micro-process internal address

. = IRP$L_RBUFH_AD
$DEF	IRP$L_XQ_SETUP	.BLKL	1	; Setup transmit buffer

. = IRP$L_MEDIA+2
$DEF	IRP$W_XQ_PROTYP	.BLKW	1	; Protocol type for user

. = IRP$L_LBOFF
$DEF	IRP$L_XQ_SHR	.BLKL	1	; Address of SHR structure for user

. = IRP$L_FQFL
$DEF	IRP$C_XQ_STD	.BLKL	1	; End of "standard" IRP

;
; Define driver internal function codes stored in IRP$B_XQ_FUNC of IRP.
; NOTE: These are not really used as bit offsets - but as values.
;
	_VIELD	XQ_FC,0,<-		; Internal function codes
		<INIT>,-		; Initialize QNA
		<XMIT>,-		; Transmit request
		<RECV>,-		; Receive request
		<STOP>,-		; Stop protocol
		<CANCEL>,-		; Cancel request
		<RESTART>,-		; Restart PROTOCOL
		<CHMODE>,-		; Change the setup mode
		>			;

	$DEFEND	IRP			; End of IRP overlays

;
; Overlays of CXB
;
	$DEFINI	CXB	GLOBAL
 
. = CXB$L_SPARE1
$DEF	CXB$B_XQ_FUNC	.BLKB	1	; QNA driver internal function code
			.BLKB	1	; SPARE
$DEF	CXB$W_XQ_RID			; RCV/XMT request ID
$DEF	CXB$B_XQ_SLOT	.BLKB	1	; RCV/XMT mapping slot number
$DEF	CXB$B_XQ_RING	.BLKB	1	; RCV/XMT ring entry number
 
;
; The following overlays are for transmits only
;
. = CXB$L_SPARE0
	;
	;  NOTE: The following two fields area overlayed. So if the Low
	;  Bit is set, then the address is that of a UCB, else it's an IRP.
	;
$DEF	CXB$L_T_IRP			; Associated IRP address
$DEF	CXB$L_T_UCB	.BLKL	1	; Associated UCB address

. = CXB$C_HEADER-<XQ_C_HEADER>
$DEF	CXB$T_T_DATA	.BLKB	XQ_C_HEADER ; Standard Ethernet header

;
; The following overlays are for receives only
;
. = CXB$B_CODE
$DEF	CXB$B_R_FLAGS	.BLKB	1	; Receive message flags

. = CXB$L_END_ACTION
$DEF	CXB$W_R_NCHAIN	.BLKW	1	; Number of buffers in chain

. = CXB$L_IRP
$DEF	CXB$W_R_STS	.BLKW	1	; Receive status

. = CXB$C_HEADER - <XQ_C_HEADER+XQ_C_CNTSIZ>
$DEF	CXB$T_R_DATA			; Start of receive data
$DEF	CXB$G_R_DEST	.BLKW	3	; Destination node address
$DEF	CXB$G_R_SRC	.BLKW	3	; Source node address
$DEF	CXB$W_R_PTYPE	.BLKW	1	; Protocol Type
$DEF	CXB$T_R_USERDAT			; Start of user data
$DEF	CXB$W_R_SIZE	.BLKW	1	; Size of received message (if padded).

;
; NOTE: The CXB functions are the same as for an IRP (IRP$B_XQ_FUNC)
;

	$DEFEND	CXB			; End of CXB overlays

;
; Definitions that follow the standard UCB fields
;

	$DEFINI	UCB	GLOBAL		; Start of UCB definitions

. = UCB$C_NI_LENGTH			; Position at end of UCB NI extension

$DEF	UCB$Q_XQ_QUEUES			; Message and I/O request queue heads
$DEF	UCB$Q_XQ_SHARE	.BLKQ	1	; List of shared users
$DEF	UCB$Q_XQ_IOQS			; Start of the I/O queues
$DEF	UCB$Q_XQ_RCVMSG	.BLKQ	1	; Receive messages completed
$DEF	UCB$Q_XQ_RCVREQ	.BLKQ	1	; Receive IRP waiting for messages
$DEF	UCB$Q_XQ_XMTREQ	.BLKQ	1	;% Xmit IRP wait queue (PT-TO-PT)
UCB$C_XQ_QUEUES = <.-UCB$Q_XQ_QUEUES>/8	; Number of queue heads
 
$DEF	UCB$L_XQ_PID	.BLKL	1	; Starter's PID
$DEF	UCB$L_XQ_CPID	.BLKL	1	; Creator's PID
$DEF	UCB$L_XQ_AST	.BLKL	1	; Attention AST list
$DEF	UCB$L_XQ_DEFUSR	.BLKL	1	; Default shared user (shared use only)
$DEF	UCB$W_XQ_QUOTA	.BLKW	1	; Receive buffer quota
$DEF	UCB$W_XQ_PROTYP	.BLKW	1	; Ethernet protocol type

$DEF	UCB$B_XQ_SETPRM			; Start of parameter section
$DEF	UCB$G_XQ_DES	.BLKW	3	; Destination address for shared user
$DEF	UCB$W_XQ_HBQ	.BLKW	1	; Hardware buffer quota
$DEF	UCB$B_XQ_ACC	.BLKB	1	; Protocol access mode
$DEF	UCB$B_XQ_BFN	.BLKB	1	; Number of receive buffers

$DEF	UCB$B_XQ_SHRPRM			; Start of "shared user" validated prms
$DEF	UCB$W_XQ_BSZ	.BLKW	1	; Device buffer size
$DEF	UCB$B_XQ_PRO	.BLKB	1	; Protocol selection
$DEF	UCB$B_XQ_PAD	.BLKB	1	; Padding mode
$DEF	UCB$B_XQ_PRM	.BLKB	1	; Promiscuous mode
$DEF	UCB$B_XQ_MLT	.BLKB	1	; Multicast (all) address state
$DEF	UCB$B_XQ_DCH	.BLKB	1	; Data chaining on receives

$DEF	UCB$B_XQ_CDBPRM			; Start of settable parameters for CDB
$DEF	UCB$B_XQ_CON	.BLKB	1	; Controller mode
UCB$C_XQ_CDBPRM = .-UCB$B_XQ_CDBPRM
UCB$C_XQ_SHRPRM = .-UCB$B_XQ_SHRPRM

$DEF	UCB$G_XQ_PHA	.BLKW	3	; User defined physical address
UCB$C_XQ_SETPRM = .-UCB$B_XQ_CDBPRM

$DEF	UCB$B_XQ_MST	.BLKB	1	; Maintenance state
$DEF	UCB$B_XQ_MULTI	.BLKB	1	; Number of entries in MULTI
$DEF	UCB$B_XQ_MLTTBL	.BLKB	1	; Number of entries in MLTTBL
$DEF	UCB$G_XQ_MULTI	.BLKW	3*MAX_C_MLT ; Multicast address list
$DEF	UCB$G_XQ_MLTTBL	.BLKW	3*MAX_C_MLT ; Multicast generation list

$DEF	UCB$W_XQ_CTR			; Start of counter section
$DEF	UCB$W_XQ_MNECTR	.BLKW	1	; Multicast address not enabled
$DEF	UCB$W_XQ_UBUCTR	.BLKW	1	; No buffer available counter
$DEF	UCB$L_XQ_SBLCTR	.BLKL	1	; Number of blocks sent
$DEF	UCB$L_XQ_SBYCTR	.BLKL	1	; Number of bytes sent
$DEF	UCB$L_XQ_RBLCTR	.BLKL	1	; Number of blocks received
$DEF	UCB$L_XQ_RBYCTR	.BLKL	1	; Number of bytes received
					; Unused/unneeded fields
$DEF	UCB$W_XQ_TOTQUO	.BLKW	1	; Total quota for shared UCB
$DEF	UCB$L_XQ_FFI	.BLKL	1	; Fast interface BLOCK address
$DEF	UCB$L_XQ_STIRP	.BLKL	1	;% Address of PT-TO-PT Startup IRP

$DEF	UCB$C_XQ_LENGTH			; Size of XQDRIVER UCB
 
;
; Define device status bits
;
	$VIELD	UCB,0,<-		; XQDRIVER UCB$W_DEVSTS bits
		<XQ_INITED,,M>,-	; Device is initialized
		<,1>,-			; RESERVED
		<XQ_PROTYP,,M>,-	; Protocol type specified
		<XQ_SHARE,,M>,-		; Shared protocol type
		<XQ_RUN,,M>,-		; Unit is in RUN mode
		<XQ_START,,M>,-		;% Unit is in PT-TO-PT startup state
		<XQ_STACK,,M>,-		;% Unit is in PT-TO-PT stack state
		<,7>,-			; Reserved
		<XQ_INTERLOCK,,M>,-	; RESTART bit is interlocked
		<XQ_RESTART,,M>,-	; Automatic RESTART on PROTOCOL
		>			;  requested

	$DEFEND	UCB			; End of UCB definitions

;
; Device register offsets and bit definitions
;
	$DEFINI	XQ	GLOBAL		; Start of port CSR definitions
 
$DEF	PHYADD0	.BLKW	1		; Physical address (R/O) - low byte
$DEF	PHYADD1	.BLKW	1		;   more physical address (R/O)
$DEF	PHYADD2				;   and still more (R/O)
$DEF	RCVLIST	.BLKW	1		; Receive descriptor list (W/O)
$DEF	RCVLST1				;   high order receive list (W/O)
$DEF	PHYADD3	.BLKW	1		;   more physical address (R/O)
$DEF	PHYADD4				;   more physical address (R/O)
$DEF	XMTLIST	.BLKW	1		; Transmit descriptor list (W/O)
$DEF	XMTLST1				;   high order receive list (W/O)
$DEF	PHYADD5	.BLKW	1		;   more physical address (R/O)
$DEF	VECTOR	.BLKW	1		; Vector addrss (R/W)
$DEF	CSR	.BLKW	1		; Port CSR
 
	_VIELD	XQ_CSR,0,<-		; CSR bit definitions
		<RCVENA,,M>,-		; Receive Enable
		<RESET,,M>,-		; Reset
		<NXM,,M>,-		; Non-existent memory
		<RROM,,M>,-		; Read BOOT/DIAGNOSTICS ROM
		<XMTINV,,M>,-		; Transmit list is invalid
		<RCVINV,,M>,-		; Receive list is invalid
		<INTENA,,M>,-		; Interrupt enable
		<RCVINT,,M>,-		; Receive interrupt
		<ILOOP,,M>,-		; Internal loopback (0=ENABLE,1=DISABLE)
		<ELOOP,,M>,-		; External loopback
		<SANITY,,M>,-		; Sanity timer
		<,1>,-			; RESERVED
		<XCAB,,M>,-		; Transceiver cable okay
		<CAR,,M>,-		; Carrier sense
		<ERR,,M>,-		; Fatal error flag (software set)
		<XMTINT,,M>,-		; Transmit interrupt
		>

	_VIELD	XQ_SOFT,0,<-		; Software error flag bit definitions
		<TIMEOUT,,M>,-		; Timeout
		<POWER,,M>,-		; Powerfail
		>

	$DEFEND	XQ			; End of device register definitions

 
;
; Define the Transmit Ring Entry
;
	$DEFINI	XMT	GLOBAL		; Start of Transmit Ring Entry format
 
$DEF	XMT_W_FLAG	.BLKW	1	; Flags word
$DEF	XMT_W_ADDRHI	.BLKW	1	; Buffer address (high) and descriptor
$DEF	XMT_W_ADDR	.BLKW	1	; Buffer address (low 16 bits)
$DEF	XMT_W_LEN	.BLKW	1	; 2's complement WORD size
$DEF	XMT_W_STS	.BLKW	1	; XMIT Status word
$DEF	XMT_W_TDR	.BLKW	1	; Time Domain Reflectometry word
$DEF	XMT_C_LENGTH			; Size of transmit buffer ring entry
XMT_K_LENGTH = XMT_C_LENGTH * <MAX_C_XMT+1> ; Size of xmit ring (1 for chain)
 
	_VIELD	XMT_FLG,0,<-		; Define flag bits
		<,14>,-			; RESERVED
		<ERR,,M>,-		; Transmit error
		<LAST,,M>,-		; LAST packet/NOT used indicator
				       -;  The driver only queues one seqment
				       -;  transmit buffers, so this is
				       -;  essentially an OWN flag.
		>
 
	_VIELD	XMT_DSC,0,<-		; Define bits for descriptor word
		<,6>,-			; RESERVED for high order address
		<BEGODD,1,M>,-		; Buffer begins on a ODD address
		<ENDODD,1,M>,-		; Buffer ends on an ODD address
		<,4>,-			; RESERVED
		<SETUP,1,M>,-		; Setup operation
		<EOM,1,M>,-		; End of message.
		<CHAIN,1,M>,-		; Chain operation
		<VALID,1,M>,-		; Valid buffer address
		>

	_VIELD	XMT_STS,0,<-		; Define bits for status word
		<,4>,-			; RESERVED
		<COL,4,M>,-		; Number of collisions
		<FAIL,,>,-		; Collision check failure
		<ABORT,,>,-		; Transmission was aborted due to
				       -;  excessive collisions
		<,1>,-			; RESERVED
		<NOCAR,,M>,-		; No carrier ever present
		<LCAR,,M>,-		; Loss of carrier
		<,1>,-			; RESERVED
		<ERR,,M>,-		; Error on transmit
		<LAST,,M>,-		; LAST packet/NOT used indicator
				       -;  The driver only queues one seqment
				       -;  transmit buffers, so this is
				       -;  essentially an OWN flag.
		>

	_VIELD	XMT_TDR,0,<-		; Define bits for TDR WORD
		<TDR,14,M>,-		; Time Domain Reflectometry
		<,2>,-			; RESERVED
		>

	$DEFEND	XMT			; End of Transmit Ring Entry
;
; Define the Receive List Entry
;
	$DEFINI	RCV	GLOBAL		; Start of Receive List Entry format
 
$DEF	RCV_W_FLAG	.BLKW	1	; Flags word
$DEF	RCV_W_ADDRHI	.BLKW	1	; Buffer address (high) and descriptor
$DEF	RCV_W_ADDR	.BLKW	1	; Buffer address (low 16 bits)
$DEF	RCV_W_LEN	.BLKW	1	; 2's complement WORD size
$DEF	RCV_W_STS	.BLKW	1	; Status word
$DEF	RCV_W_LENB	.BLKW	1	; Receive length byte <7:0>
$DEF	RCV_C_LENGTH			; Size of transmit buffer ring entry
RCV_K_LENGTH = RCV_C_LENGTH * <MAX_C_RCV+1> ; Size of receive ring (1 for chain)
 
	_VIELD	RCV_FLG,0,<-		; Define flag bits
		<,14>,-			; RESERVED
		<ERR,,M>,-		; Receive error
		<LAST,,M>,-		; LAST packet/NOT used indicator
		>

	_VIELD	RCV_DSC,0,<-		; Define bits for descriptor word
		<,14>,-			; RESERVED for high order address
		<CHAIN,1,M>,-		; Chain operation
		<VALID,1,M>,-		; Valid buffer address
		>

	_VIELD	RCV_STS,0,<-		; Define status word
		<OVF,,M>,-		; DEQNA receive overflow
		<CRCERR,,M>,-		; CRC error
		<FRAME,,M>,-		; Framing error
		<SHORT,,M>,-		; Short on Ethernet Cable
		<,4>,-			; RESERVED
		<RLEN,3,M>,-		; Receive length bits <10:8>
		<RUNT,,M>,-		; RUNT packet
		<DISCARD,,M>,-		; DISCARD packet (VALIDATES OVF & CRCERR)
		<ESETUP,,M>,-		; End of setup
		<ERR,,M>,-		; Error/USED indicator
		<LAST,,M>,-		; LAST packet/NOT used indicator
		>

	$DEFEND	RCV			; End of Receive Ring Entry
 
;
; Transmit Buffer Header Format
;
	$DEFINI	XBUF			; Define transmit buffer header
 
$DEF	XBUF_G_DEST	.BLKW	3	; Destination address
$DEF	XBUF_G_SRC	.BLKW	3	; Source address (overlays UCB)
$DEF	XBUF_W_TYPE	.BLKW	1	; Protocol type
$DEF	XBUF_T_DATA			; Start of xmit data
$DEF	XBUF_C_HEADER			; Size of buffer header

$DEF	XBUF_W_SIZE	.BLKW	1	; Size of buffer (only if padding)

	$DEFEND	XBUF			; End of transmit buffer header
 
;
; Block header for non-DECnet xmit buffers
;
	$DEFINI	BLK			; Define a standard block header

$DEF	BLK_L_LINK	.BLKL	2	; Forward and backward queue links
$DEF	BLK_W_SIZE	.BLKW	1	; Block size
$DEF	BLK_B_TYPE	.BLKB	1	; Block type
$DEF	BLK_B_SPARE	.BLKB	1	; SPARE byte
$DEF	BLK_T_DATA			; Start of data
$DEF	BLK_C_HEADER			; Size of buffer header

	$DEFEND	BLK

;
; Define the DEQNA Controller Data Block (CDB) fields
;

	$DEFINI	CDB	GLOBAL		; Start of CDB definitions

$DEF	CDB_L_FQFL	.BLKL	1	; Fork queue forward link
$DEF	CDB_L_FQBL	.BLKL	1	; Fork queue backward link
$DEF	CDB_W_SIZE	.BLKW	1	; Size of CDB
$DEF	CDB_B_TYPE	.BLKB	1	; Type of structure
$DEF	CDB_B_FIPL	.BLKB	1	; Fork IPL
$DEF	CDB_L_FPC	.BLKL	1	; Fork PC
$DEF	CDB_L_CSR			; Port CSR contents
$DEF	CDB_L_FR3	.BLKL	1	; Fork R3
$DEF	CDB_L_FR4	.BLKL	1	; Fork R4
$DEF	CDB_B_NEXTXMT	.BLKB	1	; Next entry in XMT ring
$DEF	CDB_B_NEXTRCV	.BLKB	1	; Next entry in RCV ring
ASSUME	MAX_C_XMT LE 8
ASSUME	MAX_C_RCV LE 8
$DEF	CDB_B_RCVMAP	.BLKB	1	; RCV map slot in use flags
$DEF	CDB_B_XMTMAP	.BLKB	1	; XMT map slot in use flags
$DEF	CDB_L_RCVMAP	.BLKL	MAX_C_RCV-1 ; RCV mapping vector
$DEF	CDB_L_XMTMAP	.BLKL	MAX_C_XMT-1 ; XMT mapping vector
$DEF	CDB_L_RRINGPA	.BLKL	MAX_C_RCV+1 ; RCV Ring entry PHYSICAL address
$DEF	CDB_L_XRINGPA	.BLKL	MAX_C_XMT+1 ; XMT Ring entry PHYSICAL address
$DEF	CDB_L_RRINGVA	.BLKL	MAX_C_RCV ; RCV Ring entry VIRTUAL address
$DEF	CDB_L_XRINGVA	.BLKL	MAX_C_XMT ; XMT Ring entry VIRTUAL address
$DEF	CDB_L_RCV_PA	.BLKL	MAX_C_RCVUV1 ; Receive contiguous buffer
					;  physical address
$DEF	CDB_L_XMT_PA	.BLKL	MAX_C_XMTUV1 ; Transmit contiguous buffer
					;  physical address
$DEF	CDB_L_RCV_VA	.BLKL	MAX_C_RCVUV1 ; Receive contiguous buffer
					;  virtual address
$DEF	CDB_L_XMT_VA	.BLKL	MAX_C_XMTUV1 ; Transmit contiguous buffer
					;  virtual address
$DEF	CDB_Q_QUEUES			; Start of CDB queues
$DEF	CDB_Q_XMTREQ	.BLKQ	1	; Transmit request queue
CDB_C_ABORTS = <.-CDB_Q_QUEUES>/8	; Number of Queues to abort requests
$DEF	CDB_Q_INPUT	.BLKQ	1	; Input process queue
$DEF	CDB_Q_XMTPND	.BLKQ	1	; Transmit pending queue
$DEF	CDB_Q_RCVBUF	.BLKQ	1	; Receive buffer queue
$DEF	CDB_Q_RCVPND	.BLKQ	1	; Receive pending queue
$DEF	CDB_Q_POST	.BLKQ	1	; Post process queue
CDB_C_QUEUES = <.-CDB_Q_QUEUES>/8	; Number of Queue Heads
 
$DEF	CDB_B_LASTRCV	.BLKB	1	; Last entry done in RCV ring
$DEF	CDB_B_LASTXMT	.BLKB	1	; Last entry done in XMT ring
$DEF	CDB_B_RCVCNT	.BLKB	1	; Count of receives given to QNA
$DEF	CDB_B_XMTCNT	.BLKB	1	; Count of xmits given to QNA
$DEF	CDB_W_BSZ	.BLKW	1	; Device buffer size
$DEF	CDB_W_QUOTA	.BLKW	1	; SYSTEM buffer quota

$DEF	CDB_L_DEVDEPEND	.BLKL	1	; Device dependent longword
$DEF	CDB_L_UCB0	.BLKL	1	; Address of UCB #0
$DEF	CDB_B_SPARE	.BLKB	1	; SPARE BYTE
$DEF	CDB_B_DIAG1	.BLKB	1	; Diagnostic info byte
$DEF	CDB_W_DIAG2	.BLKW	1	; Second word of diagnostic info

$DEF	CDB_G_COUNTER			; Start of counters
$DEF	CDB_W_ZERO	.BLKW	1	; Seconds since last zeroed
$DEF	CDB_L_DBRCTR	.BLKL	1	; Messages received
$DEF	CDB_L_MBLCTR	.BLKL	1	; Multicast messages received
$DEF	CDB_W_RFLMAP	.BLKW	1	; Messages received in error - bitmap
$DEF	CDB_W_RFLCTR	.BLKW	1	; Messages received in error
	ASSUME	CDB_W_RFLCTR EQ CDB_W_RFLMAP+2
$DEF	CDB_L_BRCCTR	.BLKL	1	; Bytes received
$DEF	CDB_L_MBYCTR	.BLKL	1	; Multicast bytes received
$DEF	CDB_W_OVRCTR	.BLKW	1	; Packets lost due to hardware buffers
$DEF	CDB_W_LBECTR	.BLKW	1	; Packets lost due to system buffer error
$DEF	CDB_L_DBSCTR	.BLKL	1	; Messages sent
$DEF	CDB_L_MBSCTR	.BLKL	1	; Multicast messages sent
$DEF	CDB_L_BSMCTR	.BLKL	1	; Messages sent - several errors
$DEF	CDB_L_BS1CTR	.BLKL	1	; Messages sent - 1 error
$DEF	CDB_L_BIDCTR	.BLKL	1	; Messages sent - initially deferred
$DEF	CDB_L_BSNCTR	.BLKL	1	; Bytes sent
$DEF	CDB_L_MSNCTR	.BLKL	1	; Multicast bytes sent
$DEF	CDB_W_SFLMAP	.BLKW	1	; Send failures - bitmap
$DEF	CDB_W_SFLCTR	.BLKW	1	; Send failures
	ASSUME	CDB_W_SFLCTR EQ CDB_W_SFLMAP+2
$DEF	CDB_W_CDCCTR	.BLKW	1	; Transmit collision check failure

$DEF	CDB_W_UFDCTR	.BLKW	1	; No protocol type counter on receive
$DEF	CDB_W_SBUCTR	.BLKW	1	; System buffer unavailable
$DEF	CDB_W_UBUCTR	.BLKW	1	; No buffer available on all PTs

$DEF	CDB_L_RINGMAP	.BLKL	1	; Mapping information for RINGs
;
; Define the UNIBUS mapped portion of the CDB (QNA data structures)
;
$DEF	CDB_G_MAPPED			; Start of UNIBUS mapped portion of CDB
$DEF	CDB_G_RRING	.BLKB	RCV_K_LENGTH	; Recv ring buffer
$DEF	CDB_G_XRING	.BLKB	XMT_K_LENGTH	; Xmit ring buffer
CDB_C_MAPPED = .-CDB_G_MAPPED		; Size of UNIBUS mapped portion of CDB
$DEF	CDB_C_ZERO			; Size of CDB to zero (everything from
					;  the beginning to this point).
$DEF	CDB_B_TIM_XMT	.BLKB	1	; Transmit timer cell
$DEF	CDB_B_UNTCNT	.BLKB	1	; Number of active units (UCBs)
$DEF	CDB_L_UV1BUF	.BLKL	1	; u-VAX I buffer area address
$DEF	CDB_L_PRMUSER	.BLKL	1	; Promiscuous user's UCB address
$DEF	CDB_L_TQE	.BLKB	TQE$C_LENGTH ; Timer queue element
$DEF	CDB_W_MODE	.BLKW	1	; QNA hardware mode
$DEF	CDB_B_STS	.BLKB	1	; Controller status
$DEF	CDB_B_PRM	.BLKB	1	; Promiscuous mode
$DEF	CDB_B_MLT	.BLKB	1	; Multicast (all) address state

$DEF	CDB_B_SETPRM			; Start of settable parameters
$DEF	CDB_B_CON	.BLKB	1	; Controller mode
CDB_C_SETPRM = .-CDB_B_SETPRM		; Size of settable parameter list

$DEF	CDB_G_PHA	.BLKW	3	; User defined physical address
$DEF	CDB_G_HWA	.BLKW	3	; Hardware physical address
$DEF	CDB_G_PHYADR	.BLKW	3	; The current hardware address
$DEF	CDB_B_MULTI	.BLKB	1	; Number of entries in Multicast list
$DEF	CDB_B_MLTTBL	.BLKB	1	; Number of entries in MLTTBL
$DEF	CDB_G_MULTI	.BLKW	3*MAX_C_MLT ; Multicast address table
$DEF	CDB_G_MLTTBL	.BLKW	3*MAX_C_MLT ; Multicast address generation table
$DEF	CDB_B_AQUOTA	.BLKB	1	; Additional QUOTA available
$DEF	CDB_B_MQUOTA	.BLKB	1	; Maximum extra QUOTA allowed

$DEF	CDB_C_LENGTH			; Size of QNA CDB
 
	_VIELD	CDB_STS,0,<-		; CDB status bit for CDB_B_STS
		<INITED,,M>,-		; Inited
		<RUN,,M>,-		; Device is running
		<FORK_PEND,,M>,-	; Fork process is pending
		<TIMER,,M>,-		; Timer is active
		<ERR,,M>,-		; Fatal error has occurred
		<SETUP,,M>,-		; Device is in SETUP mode
		>

	_VIELD	CDB_MOD,0,<-		; Bits for mode definition CDB_W_MODE
		<MULTI,,M>,-		; All multicasts enabled
		<PROM,,M>,-		; Promiscuous mode enabled
		>

	$DEFEND	CDB			; End of QNA CDB definitions

;
; P2 buffer header definition
;
	$DEFINI	P2B

$DEF	P2B_L_POINTER	.BLKL	1	; Pointer to start of data
$DEF	P2B_L_BUFFER	.BLKL	1	; Address of user's data buffer
$DEF	P2B_W_SIZE	.BLKW	1	; Size of P2 buffer
$DEF	P2B_B_TYPE	.BLKB	1	; Type of structure
$DEF	P2B_B_SPARE	.BLKB	1	; Spare byte
$DEF	P2B_C_LENGTH			; Size of P2 buffer header
$DEF	P2B_T_DATA			; Start of data
 
	$DEFEND	P2B
;
; Diagnostics buffer definition
;
	$DEFINI	DIAG
;
; Driver independent portion of diagnostics buffer
;
$DEF	DIAG_L_DATA	.BLKL	1	; Pointer to start of data
$DEF	DIAG_L_BUFFER	.BLKL	1	; User buffer address
$DEF	DIAG_W_SIZE	.BLKW	1	; Size of structure
$DEF	DIAG_B_TYPE	.BLKB	1	; Type of structure
$DEF	DIAG_B_SPARE	.BLKB	1	; Spare byte
$DEF	DIAG_T_DATA			; Start of data
$DEF	DIAG_Q_START	.BLKQ	1	; Start time for QIO
$DEF	DIAG_Q_FINISH	.BLKQ	1	; Finish time for QIO
$DEF	DIAG_L_ERRS	.BLKL	1	; Number of device errors
$DEF	DIAG_L_EXTRA	.BLKL	1	; Number of longwords that follow
;
; Driver dependent portion of diagnostics buffer
;
$DEF	DIAG_L_DEPEND
$DEF	DIAG_W_CSR	.BLKW	1	; Last port CSR contents
$DEF	DIAG_W_ERR	.BLKW	1	; Ring entry error summary
$DEF	DIAG_W_ERR2	.BLKW	1	; Extra ring entry error info
$DEF	DIAG_G_HWA	.BLKW	3	; Hardware physical address
;
; The following is valid only on read (receive) QIOs
;
$DEF	DIAG_T_RDATA			; Start of receive data
$DEF	DIAG_G_DEST	.BLKW	3	; Destination address
$DEF	DIAG_G_SRC	.BLKW	3	; Source address
$DEF	DIAG_W_TYPE	.BLKW	1	; Protocol type
$DEF	DIAG_C_LENGTH			; Start of data
DIAG_C_EXTRA = .-DIAG_L_DEPEND/4
 
	$DEFEND	DIAG
;
; Receive buffer header definition
;
	$DEFINI	RHDR

$DEF	RHDR_L_DATA	.BLKL	1	; Pointer to start of data
$DEF	RHDR_L_BUFFER	.BLKL	1	; User buffer address
$DEF	RHDR_W_SIZE	.BLKW	1	; Size of structure
$DEF	RHDR_B_TYPE	.BLKB	1	; Type of structure
$DEF	RHDR_B_SPARE	.BLKB	1	; Spare byte
$DEF	RHDR_T_DATA			; Start of data
$DEF	RHDR_G_DEST	.BLKW	3	; Destination address
$DEF	RHDR_G_SRC	.BLKW	3	; Source address
$DEF	RHDR_W_TYPE	.BLKW	1	; Protocol type
$DEF	RHDR_C_LENGTH			; Start of data
RHDR_C_DATA = .-RHDR_T_DATA
 
	$DEFEND	RHDR

;
; Shareable protocol type data structure
;
	$DEFINI	SHR	GLOBAL
$DEF	SHR_L_QFL	.BLKL	1	; Forward link pointer
$DEF	SHR_L_QBL	.BLKL	1	; Backward link pointer
$DEF	SHR_W_SIZE	.BLKW	1	; Size of structure
$DEF	SHR_B_TYPE	.BLKB	1	; Type of structure
$DEF	SHR_B_STS	.BLKB	1	; SHR status
$DEF	SHR_L_PID	.BLKL	1	; User's PID
$DEF	SHR_W_CHAN	.BLKW	1	; User's channel
$DEF	SHR_G_DEST	.BLKW	3	; Destination address
$DEF	SHR_Q_QUEUES			; Start of queues
$DEF	SHR_Q_RCVMSG	.BLKQ	1	; Received messages waiting for IRPs
$DEF	SHR_Q_RCVREQ	.BLKQ	1	; Receive IRPs waiting for messages
SHR_C_QUEUES = <.-SHR_Q_QUEUES>/8	; Number of queues
$DEF	SHR_W_QUOTA	.BLKW	1	; User's shared quota
$DEF	SHR_C_LENGTH			; Size of data structure

	_VIELD	SHR_STS,0,<-		; SHR status bits
		<INITED,,M>,-		; Protocol type is inited
		>

	$DEFEND	SHR

	.SBTTL	Standard tables
;
; Driver prologue table
;
	DPTAB	-			;
		END=XQ_END,-		; END OF DRIVER
		ADAPTER=UBA,-		; ADAPTER TYPE
		UCBSIZE=UCB$C_XQ_LENGTH,- ; SIZE OF UCB
		NAME=XQDRIVER		; DRIVER NAME
 
	DPT_STORE INIT			; START OF CONTROLLER INIT
	DPT_STORE UCB,UCB$B_FIPL,B,IPL$_XQ_FIPL	; FORK IPL
	DPT_STORE UCB,UCB$B_DIPL,B,IPL$_XQ_DIPL	; DEVICE IPL
	DPT_STORE ORB,ORB$B_FLAGS,B,-		; Protection block flags
			   <ORB$M_PROT_16>	; SOGW protection word
	DPT_STORE ORB,ORB$W_PROT,W,0		; default protection
	DPT_STORE ORB,ORB$L_OWNER,L,0		; no owner as yet
	DPT_STORE UCB,UCB$L_DEVCHAR,L,-	; DEVICE CHARACTERISTICS
			<DEV$M_SHR!-
			 DEV$M_NET!-
			 DEV$M_AVL!-
			 DEV$M_IDV!-
			 DEV$M_ODV>

	DPT_STORE UCB,UCB$B_DEVCLASS,B,DC$_SCOM ; Device class
	DPT_STORE UCB,UCB$B_DEVTYPE,B,DT$_DEQNA	; Device type
	DPT_STORE UCB,UCB$W_DEVBUFSIZ,W,512	; Default buffer size
	DPT_STORE UCB,UCB$W_STS,W,<UCB$M_ONLINE!UCB$M_TEMPLATE>
	DPT_STORE UCB,UCB$G_XQ_PHA,L,-1		; No default physical address
	DPT_STORE UCB,UCB$G_XQ_PHA+4,W,-1	;	...
;
; Store defaults for all parameters
;
	DPT_STORE UCB,UCB$W_XQ_BSZ,W,1500	; Default device buffer size
	DPT_STORE UCB,UCB$B_XQ_BFN,B,1		; Default user buffer number
	DPT_STORE UCB,UCB$W_XQ_HBQ,W,INIT_C_QUOTA ; Hardware Buffer Quota
	DPT_STORE UCB,UCB$B_XQ_PRO,B,NMA$C_LINPR_NI ; "NI" is the protocol mode
	DPT_STORE UCB,UCB$B_XQ_PRM,B,NMA$C_STATE_OFF ; Promiscuous mode is OFF
	DPT_STORE UCB,UCB$B_XQ_MLT,B,NMA$C_STATE_OFF ; All multicasts is OFF
	DPT_STORE UCB,UCB$B_XQ_DCH,B,NMA$C_STATE_ON ; Data chaining is ON
	DPT_STORE UCB,UCB$B_XQ_PAD,B,NMA$C_STATE_ON ; Padding is ON
	DPT_STORE UCB,UCB$B_XQ_CON,B,NMA$C_LINCN_NOR ; Controler mode is NORMAL
	DPT_STORE UCB,UCB$B_XQ_ACC,B,NMA$C_ACC_EXC ; Exclusive mode is default
 
	DPT_STORE REINIT
 
	DPT_STORE DDB,DDB$L_DDT,D,XQ$DDT	; DDT ADDRESS
	DPT_STORE CRB,CRB$L_INTD+4,D,QNA_INTR	; QNA interrupt service routine
	DPT_STORE CRB,CRB$L_INTD+VEC$L_INITIAL,D,CONTROL_INIT; CONTROLLER INIT ADDRESS
	DPT_STORE CRB,CRB$L_INTD+VEC$L_UNITINIT,D,UNIT_INIT; UNIT INIT
	DPT_STORE CRB,CRB$L_INTD+VEC$L_START,D,FFI_INIT ; FFI INIT
	DPT_STORE END
	
	.PSECT	$$$115_DRIVER,LONG
;
; LOCAL STORAGE
;
; Driver dispatch table
;
	DDTAB	DEVNAM=XQ,-		; DRIVER DISPATCH TABLE
		START=STARTIO,-		; Start I/O operation
		FUNCTB=XQ_FUNCTABLE,-	; Function decision table address
		CANCEL=CANCEL,-		; CANCEL I/O entry point
		REGDMP=REG_DUMP,-	; Register dump entry point
		DIAGBF=<DIAG_C_LENGTH>,- ; Diagnostic buffer size
		CLONEDUCB=CLONED_UCB,-	; Cloned UCB initialization
		ALTSTART=ALT_START	; Alternate start I/O entry point
;
; Function decision table
;
XQ_FUNCTABLE:				;
	FUNCTAB	,-			; Legal Functions
	<WRITEVBLK,WRITELBLK,WRITEPBLK,READVBLK,READLBLK,-
	READPBLK,SENSEMODE,SENSECHAR,SETMODE,SETCHAR>
	FUNCTAB	,-			; Buffered Functions
	<WRITEVBLK,WRITELBLK,WRITEPBLK,READVBLK,READLBLK,-
	READPBLK,SENSEMODE,SENSECHAR,SETMODE,SETCHAR>
	FUNCTAB	XMT_FDT,<WRITELBLK,WRITEPBLK,WRITEVBLK> ;
	FUNCTAB	RCV_FDT,<READLBLK,READPBLK,READVBLK> ;
	FUNCTAB	SETMODE_FDT,<SETMODE,SETCHAR> ;
	FUNCTAB	SENSEMODE_FDT,<SENSEMODE,SENSECHAR> ;


	.SBTTL	Local driver storage
;
; P2 Buffer verification tables
;
 
	$DEFINI	PARAM
 
$DEF	PRM_W_TYPE	.BLKW	1	; Parameter type

	_VIELD	PRM_TYP,0,<-		; Parameter type field
		<CODE,12,M>,-		; Parameter type code
		<STRING,1,M>,-		; Parameter is a string
		>

$DEF	PRM_B_FLAG	.BLKB	1	; Parameter flags

	_VIELD	PRM_FLG,0,<-		; Parameter flag bits
		<MIN,1,M>,-		; Parameter minimum value present
		<MAX,1,M>,-		; Parameter maximum value present
		<INVALID,1,M>,-		; Parameter invalid value is present
		<CDB,1,M>,-		; Offset is in CDB data base
		<CHECK,1,M>,-		; Check values with current
		>
 
$DEF	PRM_W_OFF	.BLKW	1	; Parameter offset in structure

	_VIELD	PRM_OFF,0,<-		; Offset word fields
		<VALUE,10,M>,-		; Offset value
		<WIDTH,6,M>,-		; Size of field in structure
		>
 
	$DEFEND	PARAM
 
;
; Define Line parameters
;
LINE_PRM_BUFSIZ=0			; Line parameter buffer size
LINE_PARAM_WO:				; "Write-Only" line parameters

	PARAM	NMA$C_PCLI_HBQ,-	; Hardware Buffer Quota
		OFFSET=UCB$W_XQ_HBQ,-
		WIDTH=W,MAX=16384,-
		INVALID=UCB$M_XQ_INITED

LINE_PARAM:				; Start of line parameters
 
	PARAM	NMA$C_PCLI_ACC,-	; Access mode for protocol type
		OFFSET=UCB$B_XQ_ACC,-
		WIDTH=B,-
		MIN=NMA$C_ACC_SHR,-
		MAX=NMA$C_ACC_EXC

	PARAM	NMA$C_PCLI_PRO,-	; Protocol selection mode
		OFFSET=UCB$B_XQ_PRO,-
		WIDTH=B,-
		MIN=NMA$C_LINPR_POI,-	;% Accept either point or NI
		MAX=NMA$C_LINPR_NI

	PARAM	NMA$C_PCLI_BUS,-	; Buffer size
		OFFSET=UCB$W_DEVBUFSIZ,-
		WIDTH=W,-
		MIN=MIN_PKT_SIZE,-	; User buffer LIMITS
		MAX=MAX_PKT_SIZE,- 
		INVALID=UCB$M_XQ_INITED
 
	PARAM	NMA$C_PCLI_BFN,-	; Buffer number
		OFFSET=UCB$B_XQ_BFN,-
		WIDTH=B,-
		MIN=0,MAX=255,-
		INVALID=UCB$M_XQ_INITED
 
	PARAM	NMA$C_PCLI_PHA,-	; Physical NI address
		OFFSET=UCB$G_XQ_PHA,-
		STRING=YES,-
		SIZE=<2+6>,-
		INVALID=UCB$M_XQ_INITED
 
	PARAM	NMA$C_PCLI_DCH,-	; Data chaining on receives
		OFFSET=UCB$B_XQ_DCH,-
		WIDTH=B,-
		MAX=NMA$C_STATE_OFF

	PARAM	NMA$C_PCLI_PAD,-	; Padding mode
		OFFSET=UCB$B_XQ_PAD,-
		WIDTH=B,-
		MAX=NMA$C_STATE_OFF

	PARAM	NMA$C_PCLI_PRM,-	; Promiscuous mode state
		OFFSET=UCB$B_XQ_PRM,-
		WIDTH=B,-
		MAX=NMA$C_STATE_OFF,-
		INVALID=UCB$M_XQ_INITED
 
	PARAM	NMA$C_PCLI_MLT,-	; Accept all multicast addresses
		OFFSET=UCB$B_XQ_MLT,-
		WIDTH=B,-
		MAX=NMA$C_STATE_OFF,-
		INVALID=UCB$M_XQ_INITED
 
	PARAM	NMA$C_PCLI_CON,-	; Controller mode
		OFFSET=UCB$B_XQ_CON,-
		WIDTH=B,-
		MAX=NMA$C_LINCN_LOO,-
		INVALID=UCB$M_XQ_INITED

	PARAM	NMA$C_PCLI_PTY,-	; Protocol type
		OFFSET=UCB$W_XQ_PROTYP,-
		WIDTH=W,-
		INVALID=UCB$M_XQ_INITED
 
	PARAM	NMA$C_PCLI_MCA,-	; Multicast address list
		OFFSET=UCB$G_XQ_MULTI,-
		STRING=YES,-
		SIZE=2+<6*MAX_C_MLT>	; Maximum size of list

	PARAM	NMA$C_PCLI_BSZ,-	; Device buffer size
		OFFSET=UCB$W_XQ_BSZ,-
		WIDTH=W,-
		MIN=MIN_PKT_SIZE,-
		MAX=MAX_PKT_SIZE,-
		INVALID=UCB$M_XQ_INITED

	PARAM	NMA$C_PCLI_DES,-	; Destination Address for shared
		OFFSET=UCB$G_XQ_DES,-	;  Protocol Type
		STRING=YES,-
		SIZE=<2+6>

;****
; THE FOLLOWING CAN BE ELIMINATED
;****
	PARAM	NMA$C_PCLI_CRC,-	; CRC enabled
		OFFSET=UCB$B_XQ_MST,-	;  garbage
		WIDTH=B,-		;
		MAX=NMA$C_STATE_OFF

	PARAM				; End of table
 
CIRCUIT_PARAM:				; Start of circuit parameter table

	PARAM	NMA$C_PCCI_MST,-	; Maintenance state
		OFFSET=UCB$B_XQ_MST,-
		WIDTH=B,-
		MIN=NMA$C_STATE_ON,-
		MAX=NMA$C_STATE_OFF

	PARAM				; End of table

;
; Line/circuit counters
;
LINE_CTR:				; Start of LINE counters
	COUNTER		ZER, 16, ZERO	; Seconds since last zeroed
	COUNTER		DBR, 32, DBRCTR	; Packets received
	COUNTER		MBL, 32, MBLCTR	; Multicast packets received
	COUNTER		RFL, 16, RFLMAP,, MAP ; Packets received in error
	COUNTER		BRC, 32, BRCCTR	; Bytes received
	COUNTER		MBY, 32, MBYCTR	; Multicast bytes received
	COUNTER		OVR, 16, OVRCTR	; Receives lost - Internal buffer error
	COUNTER		LBE, 16, LBECTR	; Receives lost - Local buffer error
	COUNTER		DBS, 32, DBSCTR	; Packets transmitted
	COUNTER		MBS, 32, MBSCTR	; Multicast packets transmitted
	COUNTER		BSM, 32, BSMCTR	; Packets transmitted - several errors
	COUNTER		BS1, 32, BS1CTR	; Packets transmitted - 1 error
	COUNTER		BID, 32, BIDCTR	; Packets transmitted - deferred
	COUNTER		BSN, 32, BSNCTR	; Bytes transmitted
	COUNTER		MSN, 32, MSNCTR	; Multicast bytes transmitted
	COUNTER		SFL, 16, SFLMAP,, MAP ; Transmit packets aborted
	COUNTER		CDC, 16, CDCCTR	; Transmit collision check failure
	COUNTER		UFD, 16, UFDCTR	; Unrecognized frame destination
	COUNTER		SBU, 16, SBUCTR ; System buffer unavailable
	COUNTER		UBU, 16, UBUCTR ; User buffer unavailable

CIRC_CTR:				; Start of CIRCUIT counters
	COUNTER		DBS, 32, SBLCTR, CIRC ; Blocks sent
	COUNTER		BSN, 32, SBYCTR, CIRC ; Bytes sent
	COUNTER		DBR, 32, RBLCTR, CIRC ; Blocks received
	COUNTER		BRC, 32, RBYCTR, CIRC ; Bytes received
	COUNTER		MNE, 16, MNECTR, CIRC ; Multicast address not enabled
	COUNTER		UBU, 16, UBUCTR, CIRC ; User buffer unavailable

;
; MOP read counters return table (in order of COUNTERs returned)
;
MOPCTRTAB:				; Start of MOP counters
	MOPCTR		16, ZERO	; Seconds since last zeroed
	MOPCTR		32, BRCCTR	; Bytes received
	MOPCTR		32, BSNCTR	; Bytes transmitted
	MOPCTR		32, DBRCTR	; Packets received
	MOPCTR		32, DBSCTR	; Packets transmitted
	MOPCTR		32, MBYCTR	; Multicast bytes received
	MOPCTR		32, MBLCTR	; Multicast packets received
	MOPCTR		32, BIDCTR	; Packets transmitted - deferred
	MOPCTR		32, BS1CTR	; Packets transmitted - 1 error
	MOPCTR		32, BSMCTR	; Packets transmitted - several errors
	MOPCTR		16, SFLCTR, MAP	; Transmit packets aborted
	MOPCTR		16, RFLCTR, MAP	; Packets received in error
	MOPCTR		16, UFDCTR	; Unrecognized frame destination
	MOPCTR		16, OVRCTR	; Receives lost - Internal buffer error
	MOPCTR		16, LBECTR	; Receives lost - Local buffer error
	MOPCTR		16, UBUCTR	; User buffer unavailable
	MOPCTR		16, CDCCTR	; Transmit collision check failure
	MOPCTR				; End of table
;
; Calculate total size of MOP counter return data buffer
;
	MOP_CTR_SIZE = MOP_CTR_SIZE + 1 + 2 + 8 ; Size of counters + MOP header
	MOP_CTR_SIZE = MOP_CTR_SIZE + XBUF_C_HEADER ; Size of buffer + NI header

;
; BAD PARAMETER RETURN TABLE
;
; First part is validation of Unit against controller. The second part is
; for validation of shared protocol types.
;
; Note that the table is in the REVERSE order from that of the UCB.
;
	ASSUME	UCB$B_XQ_CON EQ UCB$B_XQ_CDBPRM
BAD_PARAM_TBL:
	.WORD	NMA$C_PCLI_CON

	ASSUME	UCB$W_XQ_BSZ EQ UCB$B_XQ_SHRPRM
	ASSUME	UCB$B_XQ_PRO EQ UCB$W_XQ_BSZ+2
	ASSUME	UCB$B_XQ_PAD EQ UCB$B_XQ_PRO+1
	ASSUME	UCB$B_XQ_PRM EQ UCB$B_XQ_PAD+1
	ASSUME	UCB$B_XQ_MLT EQ UCB$B_XQ_PRM+1
	ASSUME	UCB$B_XQ_DCH EQ UCB$B_XQ_MLT+1
	ASSUME	UCB$B_XQ_CDBPRM EQ UCB$B_XQ_DCH+1
	.WORD	NMA$C_PCLI_DCH
	.WORD	NMA$C_PCLI_MLT
	.WORD	NMA$C_PCLI_PRM
	.WORD	NMA$C_PCLI_PAD
	.WORD	NMA$C_PCLI_PRO
	.WORD	NMA$C_PCLI_BSZ
	.WORD	NMA$C_PCLI_BSZ		; This parameter is a word (not byte)

	.SBTTL	CONTROL_INIT - INITIALIZE DEQNA DEVICE
;++
; CONTROL_INIT - INITIALIZE DEQNA DEVICE
;
; Functional description:
;
; This routine is entered when driver is loaded, system is booted, or
; during powerfail recovery.
;
; Inputs:
;
;	R4 = Address of the device CSR
;	R5 = Address of the device IDB
;	R6 = Address of the device DDB
;	R8 = Address of the device CRB
;
;	IPL = FIPL
;
; Outputs:
;
;	R4,R5,R8 are preserved
;--
 
CONTROL_INIT::				; Initialize the DEQNA 
	RSB				; Return to caller

	.SBTTL	CLONED_UCB - INITIALIZE THE CLONED UCB
;++
; CLONED_UCB - INITIALIZE THE CLONED UCB
;
; Functional description:
;
; This routine is called by the $ASSIGN system service to allow the driver
; to initialize the cloned UCB. The driver is called with process context.
;
; Inputs:
;
;	R0 = SS$_NORMAL
;	R2 = UCB address of cloned UCB
;	R3 = DDT address
;	R4 = PCB address
;	R5 = UCB address of template UCB
;
;	IPL = ASTDEL
;
; Outputs:
;
;	R0 = SS$_NORMAL
;	R5 = UCB address of cloned UCB
;	All other registers and IPL are preserved.
;--
 
CLONED_UCB::				; Cloned UCB initialization
	MOVL	R2,R5			; Copy UCB address
					; Continue in unit_initialization

	.SBTTL	UNIT_INIT - INITIALIZE THE DEQNA UNIT
;++
; UNIT_INIT - INITIALIZE THE DEQNA UNIT
;
; Functional description:
;
; This routine is called at system startup, during driver loading and
; during powerfail recovery to initialize the DEQNA unit and its UCB.
; The UCB is initialized and if power has failed, the device is forced
; to shutdown.
;
; Inputs:
;
;	R4 = CSR address
;	R5 = UCB address
;
;	IPL = FIPL
;
; Outputs:
;
;	None.
;--
 
UNIT_INIT::				; Initialize a DEQNA unit
;;&&	JSB	G^INI$BRK	;*** TEMP ***

	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	; Save all regs
	BBS	#UCB$V_POWER,UCB$W_STS(R5),15$ ; Br if powerfail

;
; Initialize UCB queue listheads, and the pointer (within the NI device 
; dependent UCB extension, UCB$L_NI_MLTPTR) to the multicast address table for 
; this protocol type.
;

	MOVAB	UCB$G_XQ_MULTI(R5),-	; Initialize the pointer to this 
		UCB$L_NI_MLTPTR(R5)	; protocol's multicast address table

	MOVL	#UCB$C_XQ_QUEUES,R0	; Get number of queue listheads in UCB
	MOVAB	UCB$Q_XQ_QUEUES(R5),R1	; Get address of queue listheads
10$:	MOVAL	(R1),(R1)+		; Set forward link pointer
	MOVL	-4(R1),(R1)+		; Set backward link pointer
	SOBGTR	R0,10$			; Loop if more listheads

15$:	TSTW	UCB$W_UNIT(R5)		; Is this unit 0?
	BEQL	17$			; Br if yes - leave TEMPLATE bit on
	CLRW	UCB$W_ERRCNT(R5)	; Only unit #0 may list errors
;
; We must find the address of unit 0, so we can check if the QNA is ONLINE.
; If the QNA is OFFLINE, then we mark each UCB as being OFFLINE.
;
	MOVL	UCB$L_DDB(R5),R0	; Get address of QNA DDB
	MOVL	DDB$L_UCB(R0),R0	; Get address of UNIT 0 UCB
	BBS	#UCB$V_ONLINE,-		; Br if QNA is ONLINE
		UCB$W_STS(R0),17$	;
	BICW	#UCB$M_ONLINE,-		; Else, mark new unit as OFFLINE
		UCB$W_STS(R5)		;
17$:	;
	; For u-VAX I, we will have to allocate a physically contiguous buffer
	; area for perfoming I/O on the QNA.
	;
	CPUDISP	<<790,60$>,-
		 <780,60$>,-
		 <750,60$>,-
		 <730,60$>,-
		 <UV1,20$>>		; For u-VAX I, allocate buffer area
					; For all others, skip buffer area

20$:	MOVL	UCB$L_CRB(R5),R1	; Get CRB address
	MOVL	CRB$L_AUXSTRUC(R1),R4	; Get CDB address
	BNEQ	23$			; Br if present
	BSBW	ALLOC_CDB		; Else, try to allocate a CDB
	BLBC	R0,60$			; Br if error
	MOVL	CRB$L_AUXSTRUC(R1),R4	; Get CDB address
23$:	TSTL	CDB_L_UV1BUF(R4)	; Is the buffer area allocated?
	BNEQ	60$			; Br if yes, continue

UV1_BUFFER_LENGTH = <UV1_BUFFER_AREA + 511> & <^C511>	; Round to a page
UV1_BUFFER_PAGES  = UV1_BUFFER_LENGTH / 512		; Number of pages

	MOVZWL	#UV1_BUFFER_PAGES,R1	; Number of pages to allocate
	JSB	G^EXE$ALOPHYCNTG	; Allocate physically-contiguous memory
	BLBC	R0,60$			; Skip ahead on error
	MOVL	UCB$L_CRB(R5),R4	; Get CRB address
	MOVL	CRB$L_AUXSTRUC(R4),R4	; Get CDB address
	MOVL	R2,CDB_L_UV1BUF(R4)	; Save buffer area address

60$:	MOVZBL	#3*MAX_C_MLT,R0		; Get size of multicast list in words
	MOVAB	UCB$G_XQ_MULTI(R5),R1	; Get address of multicast list
70$:	CLRW	(R1)+			; Init multicast table
	SOBGTR	R0,70$			; Loop if more
	MOVL	UCB$L_CRB(R5),R4	; Get CRB address
	MOVL	CRB$L_AUXSTRUC(R4),R4	; Get CDB address
	BNEQ	80$			; Br if present
	BSBW	ALLOC_CDB		; Else, try to allocate a CDB
	BLBC	R0,90$			; Br if no error
80$:	BBC	#UCB$V_POWER,UCB$W_STS(R5),90$ ; Br if not powerfail
	MOVL	#<XQ_SOFT_M_POWER@16>!- ; Indicate cause of error
		XQ_CSR_M_ERR,R3
	BSBW	SCHED_FORK		; Schedule fork process
90$:	POPR	#^M<R0,R1,R2,R3,R4,R5>	; Restore regs
	RSB				; Done

	.SBTTL	FFI_INIT - FFI INTERFACE INITIALIZATION ROUTINE
;++
; FFI_INIT - FFI INTERFACE INITIALIZATION ROUTINE
;
; Functional description:
;
; This routine initializes the FFI interface. Currently the UCB must
; have been initialized prior to calling this routine, in the future
; this routine may have to initialize the UCB and DEQNA. Therefore,
; there may be a fork involved in the call to this routine.
;
; Inputs:
;
;	R3 = Address of quadword descriptor for parameter buffer
;	R4 = FFI block address
;
;	IPL = SYNCH
;
; Outputs:
;
;	R0 = Status of request
;	All other registers are preserved.
;
;--
	ASSUME	IPL$_SYNCH EQ IPL$_XQ_FIPL
FFI_INIT::
	PUSHR	#^M<R1,R2,R3,R4,R5>	; Save registers
	CLRL	R0			; Assume failure
	MOVL	FFI$L_DL_UCB(R4),R5	; Get UCB address
	BBC	#UCB$V_XQ_RUN,-		; Br if device not ready
		UCB$W_DEVSTS(R5),90$
	MOVAB	W^XMT_FFI_START,-	; Return address of XMIT routine
		FFI$L_XMIT(R4)
	MOVL	R4,UCB$L_XQ_FFI(R5)	; Save FFI address
	MOVZBL	#1,R0			; Return success
90$:	POPR	#^M<R1,R2,R3,R4,R5>	; Restore registers
	RSB				; Return to caller


	.SBTTL	XMT_FDT - TRANSMIT I/O OPERATION FDT ROUTINE
;++
; XMT_FDT - TRANSMIT I/O OPERATION FDT ROUTINE
;
; Functional description:
;
; This routine sets up the internal function code for transmit and
; transfers control to the exec buffered I/O write FDT routine.
;
; The QIO parameters for WRITES are:
;
;	P1 = Address of the data buffer
;	P2 = Size of the data buffer
;	P5 = Address of buffer containing the destination address
;
;  ** The driver can never do direct I/O on XMIT requests, because  **
; *** the QNA buffer address cannot begin on an odd byte boundary.  ***
;  **    Also, the FAST interface cannot operate on DIRECT I/O.     **
;
;
; Inputs:
;
;	R3 = IRP address
;	R4 = PCB address
;	R5 = UCB address
;	R6 = CCB address
;	R7 = FUNCTION CODE
;
;	IPL = ASTDEL
;
; Outputs:
;
;	R0-R2,R8,R9 are destroyed.
;
;--
ABORTIO_BR:				; Long branch to ABORTIO
	BRW	ABORTIO			; Abort the I/O request
						
XMT_FDT::				; Transmit FDT routine
	CLRQ	IRP$Q_STATION(R3)	; Zero the destination address
	MOVW	UCB$W_XQ_PROTYP(R5),-	; Assume we are a non-promiscuous user
		IRP$W_XQ_PROTYP(R3)	;
	MOVL	P5(AP),R1		; Get address of destination address
	BNEQ	10$			; Br if given
;
; If the user is in shared mode, then he does not have to supply a destination
; address with each transmit operation. The destination address will be gotten
; from the SHR data structure.
;
	BBS	#UCB$V_XQ_SHARE,-	; Br if shared user
		 UCB$W_DEVSTS(R5),20$	;
10$:	MOVZBL	S^#SS$_ACCVIO,R0	; Assume access violation
	IFNORD	#6,(R1),ABORTIO_BR	; Check access to buffer
	MOVL	(R1),IRP$Q_STATION(R3)	; Save destination address
	MOVW	4(R1),IRP$Q_STATION+4(R3) ;	...

	ASSUME	NMA$C_STATE_ON EQ 0
	ASSUME	NMA$C_STATE_OFF EQ 1

20$:	BLBS	UCB$B_XQ_PRM(R5),30$	; Br if user is not promiscuous
	ADDL	#6,R1			; Point to protocol type
	IFNORD	#2,(R1),ABORTIO_BR	; Check access to buffer
	MOVW	(R1),IRP$W_XQ_PROTYP(R3) ; Get protocol type from user P5 buffer
30$:	MOVZBL	S^#SS$_BADPARAM,R0	; Assume bad parameters
	MOVL	P1(AP),R8		; Get starting address of user buffer
	MOVZWL	P2(AP),R9		; Get length of user buffer
	BEQL	ABORTIO			; Br if zero length buffer
	MOVQ	R8,R0			; Retrieve buffer parameters
	JSB	G^EXE$WRITECHK		; Check accessibility of user buffer
					; (No return on NO ACCESS)
					; Returns IRP$W_BCNT
	CMPW	R1,#MIN_PKT_SIZE	; Is buffer at least minimum?
	BGEQU	50$			; Br if yes, okay
	MOVZWL	#MIN_PKT_SIZE,R1	; Else, allocate minimum sized packet
50$:	ADDL2	#CXB$C_HEADER,R1 	; Calculate length of buffer needed
	PUSHR	#^M<R3,R4,R5>		; Save registers
	JSB	G^EXE$BUFFRQUOTA	; Check if process has sufficient quota
	BLBC	R0,90$			; Br if quota check failure
	JSB	G^EXE$ALLOCBUF		; Allocate CXB buffer for output
	BLBC	R0,90$			; If LBC allocation failure
	MOVL	(SP),R3			; Retrieve address of IRP
	MOVL	PCB$L_JIB(R4),R0	; Get JIB address
	SUBL	R1,JIB$L_BYTCNT(R0)	; Adjust buffered I/O quota
	MOVW	R1,IRP$W_BOFF(R3)	; Set number of bytes charged to quota
	MOVL	R2,IRP$L_SVAPTE(R3)	; Save CXB address in IRP
	PUSHL	R2			; Save pointer to CXB

	ASSUME	CXB$L_FL EQ 0
	ASSUME	CXB$L_BL EQ CXB$L_FL+4
	CLRQ	(R2)+			; Clear link cells

	ASSUME	CXB$W_SIZE EQ CXB$L_BL+4
	MOVW	R1,(R2)+		; Set size of structure

	ASSUME	CXB$B_TYPE EQ CXB$W_SIZE+2
	ASSUME	CXB$B_CODE EQ CXB$B_TYPE+1
	MOVZBW	#DYN$C_CXB,(R2)+	; Set structure type

	MOVL	(SP),R2			; Get back CXB address

	ASSUME	CXB$C_HEADER EQ CXB$T_T_DATA+XQ_C_HEADER
	MOVW	#CXB$T_T_DATA,CXB$W_BOFF(R2) ; Setup offset to start of data
	MOVAB	CXB$C_HEADER(R2),R2	; Get address of data portion of buffer

	MOVC3	R9,(R8),(R2)		; Move data to system buffer
	POPR	#^M<R2,R3,R4,R5>	; Restore registers
	SETIPL	UCB$B_FIPL(R5)		; Sync access to UCB
	PUSHL	R3			; Save IRP address
	BSBB	XMT_START		; Do common processing
	POPL	R3			; Restore IRP address
	BLBC	R0,ABORTIO		; Br if error in processing request
	JMP	G^EXE$QIORETURN		; Exit QIO service to await completion

90$:	POPR	#^M<R3,R4,R5>		; Restore registers
ABORTIO:JMP	G^EXE$ABORTIO		; Abort the I/O request

	.SBTTL	XMT_FFI_START - START FAST INTERFACE TRANSMIT OPERATION
;++
; XMT_FFI_START - START FAST INTERFACE TRANSMIT OPERATION
;
; Functional description:
;
; This routine is called to start a transmit operation. If the QNA is running
; then the request is given to the xmit wait queue for the QNA. If there is
; a free entry in the transmit ring and there are sufficient map registers to
; map the buffer then the request is given to the QNA immediately, else the
; request is left on the xmit wait queue until another request completes.
;
;
; Inputs:
;
;	R3 = CXB address
;	R4 = FFI address
;
;	IPL = SYNCH (same as FIPL)
;
; Outputs:
;
;	R0,R3 are destroyed.
;	All other registers are preserved.
;
;	If the request cannot be queued, then the FFI$L_XMIT_DONE entry is
;	called immediately with the following:
;
;		R0 = Status of transmit request
;		R3 = CXB address
;		R4 = FFI address
;
;--
	ASSUME	IPL$_SYNCH EQ IPL$_XQ_FIPL
XMT_FFI_START::				; Start FAST interface transmit request
	PUSHR	#^M<R1,R2,R4,R5>	; Save registers
	MOVL	FFI$L_DL_UCB(R4),R5	; Get UCB address
	;
	;  For the FFI Interface, we will save the UCB address
	;
	MOVL	R5,CXB$L_T_UCB(R3)	; Save UCB address
	ASSUME	CXB$L_T_UCB  EQ  CXB$L_T_IRP
	BISB	#1,CXB$L_T_UCB(R3)	; ...indicate this is a UCB address

	SUBW	#XQ_C_HEADER,CXB$W_BOFF(R3) ; Back up offset for Ethernet header

	ASSUME	NMA$C_STATE_ON EQ 0
	ASSUME	NMA$C_STATE_OFF EQ 1
	BLBS	UCB$B_XQ_PAD(R5),20$	; Br if padding is disabled
	SUBW	#XQ_C_CNTSIZ,CXB$W_BOFF(R3) ; Else, skip length field of buffer
20$:	MOVZWL	CXB$W_BOFF(R3),R1	; Get offset to start of data
	ADDL3	R1,R3,R2		; Set R2 to start of header

	ASSUME	XBUF_G_SRC EQ XBUF_G_DEST+6
	MOVQ	CXB$Q_STATION(R3),-	; Store destination address
		 XBUF_G_DEST(R2)
	ASSUME	XBUF_W_TYPE EQ XBUF_G_SRC+6
	MOVQ	UCB$G_XQ_PHA(R5),-	; Store our source address
		 XBUF_G_SRC(R2)
	MOVW	UCB$W_XQ_PROTYP(R5),-	; Set PROTOCOL TYPE
		 XBUF_W_TYPE(R2)
	BSBB	XMT_INITIATE		; Try to start transmit
	BLBS	R0,50$			; Br if success
	MOVL	UCB$L_XQ_FFI(R5),R4	; Else, get back FFI address
	JSB	@FFI$L_XMIT_DONE(R4)	; Complete request in error
50$:	POPR	#^M<R1,R2,R4,R5>	; Restore registers
	RSB				; Return to caller

	.SBTTL	XMT_START - START TRANSMIT OPERATION
;++
; XMT_START - START TRANSMIT OPERATION
;
; Functional description:
;
; This routine is called to start a transmit operation. If the QNA is running
; then the request is given to the xmit wait queue for the QNA. If there is
; a free entry in the transmit ring and there are sufficient map registers to
; map the buffer then the request is given to the QNA immediately, else the
; request is left on the xmit wait queue until another request completes.
;
;
;  ** The driver can never do direct I/O on XMIT requests, because  **
; *** the QNA buffer address cannot begin on an odd byte boundary.  ***
;  **    Also, the FAST interface cannot operate on DIRECT I/O.     **
;
;
; Inputs:
;
;	R2 = CXB address
;	R3 = IRP address
;	R5 = UCB address
;
;	IPL = FIPL
;
; Outputs:
;
;	R0 = Status of transmit request
;	R1,R2,R4 are destroyed.
;
;--
	.ENABL	LSB
XMT_START::				; Start transmit operation
	BBS	#UCB$V_XQ_RUN,-		; Br if unit is in RUN mode
		UCB$W_DEVSTS(R5),30$

10$:	MOVZWL	#SS$_DEVINACT,R0	; Assume unit not started yet
	BBC	#UCB$V_XQ_INTERLOCK,-	; Br if unit is not re-starting
		UCB$W_DEVSTS(R5),20$	;  on it's own.
	MOVZWL	#SS$_OPINCOMPL,R0	; Else, return different error code
20$:	RSB				; Okay to leave now

30$:	MOVL	R3,CXB$L_T_IRP(R2)	; Save IRP address
	CLRL	IRP$L_XQ_SETUP(R3)	; Indicate no SETUP buffer present
	MOVW	IRP$W_BCNT(R3),CXB$W_BCNT(R2) ; Set BCNT in CXB
	MOVL	R3,R4			; Copy IRP address
	MOVL	R2,R3			; Copy CXB address

	ASSUME	NMA$C_STATE_ON EQ 0
	ASSUME	NMA$C_STATE_OFF EQ 1
	BLBS	UCB$B_XQ_PAD(R5),40$	; Br if padding is disabled
	SUBW	#XQ_C_CNTSIZ,CXB$W_BOFF(R3) ; Else, skip length field of buffer
40$:	MOVZWL	CXB$W_BOFF(R3),R1	; Get offset to start of data
	ADDL3	R1,R3,R2		; Set R2 to start of header
	ASSUME	XBUF_G_SRC EQ XBUF_G_DEST+6
	MOVQ	IRP$Q_STATION(R4),-	; Store destination address
		 XBUF_G_DEST(R2)
	ASSUME	XBUF_W_TYPE EQ XBUF_G_SRC+6
	MOVQ	UCB$G_XQ_PHA(R5),-	; Store our source address
		 XBUF_G_SRC(R2)
	MOVW	IRP$W_XQ_PROTYP(R4),-	; Store PROTOCOL TYPE
		 XBUF_W_TYPE(R2)

XMT_INITIATE::				; FAST Interface entry point (FFI)
	;
	; Inputs:
	;	R5 = UCB address
	;	R3 = CXB address
	;	R2 = Start address for Ethernet header
	;
	MOVB	#XQ_FC_V_XMIT,CXB$B_XQ_FUNC(R3) ; Set function request in CXB

	ASSUME	NMA$C_STATE_ON EQ 0
	ASSUME	NMA$C_STATE_OFF EQ 1
	BLBS	UCB$B_XQ_PAD(R5),60$	; Br if padding is disabled
;
;  PADDING IS ENABLED:
;	Adjust byte count to include size field and store count field.
;
	MOVW	CXB$W_BCNT(R3),-	; Else, store size of data-only
		XBUF_W_SIZE(R2)		;  portion of buffer in message
	ADDW	#XQ_C_CNTSIZ,CXB$W_BCNT(R3) ; And account for count field
;
; Allow buffer size up to Ethernet max buffer size for transmit operations.
;
60$:	CMPW	CXB$W_BCNT(R3),#MAX_PKT_SIZE ; Is buffer size bigger than
					;  largest Ethernet buffer allowed?
	BLEQU	90$			; Br if no
80$:	MOVZWL	#SS$_IVBUFLEN,R0	; Assume bad buffer length
	RSB				; ELSE, leave now

90$:	MOVL	UCB$L_CRB(R5),R4	; Get CRB address
	MOVL	CRB$L_AUXSTRUC(R4),R4	; Get CDB address
	BBC	#CDB_STS_V_RUN,-	; Br if QNA not running
		CDB_B_STS(R4),100$	;
	ADDW	#XQ_C_HEADER,-		; Adjust byte count
		 CXB$W_BCNT(R3)		;  for header info
;
; If running in the SHARED-LIMITED mode, then we must use the destination
; address from the SHR_ data structure. Unless the given destination address
; is a multicast address. For the SHARED-DEFAULT user, we must make sure that
; destination address given is unique!
;
	BBC	#UCB$V_XQ_SHARE,-	; Br if NOT a shared user
		 UCB$W_DEVSTS(R5),NO_SHR ;
;
; Try to find a match on PID/CHAN. Returns pointer in R1
;
	ASSUME	CXB$L_T_IRP  EQ  CXB$L_T_UCB
	BLBS	CXB$L_T_IRP(R3),100$	; Br if FFI user, return failure
	PUSHL	R3			; Else, save CXB address
	MOVL	CXB$L_T_IRP(R3),R3	; Get IRP address
	BSBW	MATCH_SHR		; Try to find the SHR data structure
	BEQL	110$			; Br if match
	POPL	R3			; Restore CXB address
100$:	BRW	10$			; Else, error

110$:	POPL	R3			; Restore CXB address
	CMPL	UCB$L_XQ_DEFUSR(R5),R1	; Is this the default user?
	BEQL	SHR_DEF			; Br if yes
;
; This is a SHARED-LIMITED user.
;
	BLBS	XBUF_G_DEST(R2),NO_SHR	; Br if multicast address
	MOVL	SHR_G_DEST(R1),-	; Else, get destination from SHR struct.
		 XBUF_G_DEST(R2)	;	...
	MOVW	SHR_G_DEST+4(R1),-	;	...
		 XBUF_G_DEST+4(R2)	;	...
	BRB	NO_SHR			; Continue in common code
	.DSABL	LSB
;
; This is a SHARED-DEFAULT user.
;
SHR_DEF:MOVAB	UCB$Q_XQ_SHARE(R5),R0	; Get address of SHR listhead
	MOVL	R0,R1			; Save address of start of listhead
10$:	MOVL	SHR_L_QFL(R1),R1	; Get address of next in list
	CMPL	R0,R1			; Back at start of list?
	BEQL	NO_SHR			; Br if yes, destination is unique
	CMPL	XBUF_G_DEST(R2),-	; Address match?
		 SHR_G_DEST(R1)		;	...
	BNEQ	10$			; Br if no - check next in list
	CMPW	XBUF_G_DEST+4(R2),-	; Hi order of address match?
		 SHR_G_DEST+4(R1)	;	...
	BNEQ	10$			; Br if not - check next in list
	MOVZWL	#SS$_BADPARAM,R0	; Else, bad parameter code
	RSB				; Return to caller

NO_SHR:
	;
	; Do accounting for MULTICAST here. NOTE: this should really
	; be done upon completion of request, but it is done here to
	; save extra work to check for multicast in the completion
	; section.
	;
	BLBC	XBUF_G_DEST(R2),20$	; Br if NOT multicast address
	INCC	CDB_L_MBSCTR(R4)	; Count multicast blocks sent
	MOVZWL	CXB$W_BCNT(R3),R0	; Get BCNT
	CNTR	R0,CDB_L_MSNCTR(R4),L	; Count multicast bytes sent
20$:
;
; If we are running in point-to-point mode, then queue xmit on wait queue
; if we are waiting for run!
;
	CMPB	#NMA$C_LINPR_POI,-	;% Are we in PT-TO-PT mode?
		UCB$B_XQ_PRO(R5)	;%
	BNEQ	40$			;% Br if not
	BBC	#UCB$V_XQ_STACK,-	;% Br if not in stack wait state
		UCB$W_DEVSTS(R5),40$	;%
	INSQUE	(R3),@UCB$Q_XQ_XMTREQ+4(R5);% Else, insert request on wait queue
	MOVZBL	#1,R0			;% Return success
	RSB				;% Return to caller
;
; Insert request on CDB transmit request queue and check if transmit
; can proceed.
;
40$:	INSQUE	(R3),@CDB_Q_XMTREQ+4(R4) ; Insert at end of xmit queue

	.ENABL	LSB
XMT_ALT_START::				; Alternate start for xmit
	PUSHQ	R6			; Save R6,R7
	MOVL	UCB$L_CRB(R5),R6	; Get CRB address
	MOVL	CRB$L_AUXSTRUC(R6),R4	; Get CDB address
;
; Skip MAP register useage if u-VAX I. Also use different number of slots.
;
	CPUDISP	<<790,10$>,-
		 <780,10$>,-
		 <750,10$>,-
		 <730,10$>,-
		 <UV1,XMT_UV1>>

10$:	ASSUME	MAX_C_XMT LE 8
	FFC	#0,#MAX_C_XMT-1,CDB_B_XMTMAP(R4),R7 ; Find a free transmit slot
	BEQL	20$			; Br if none free
;
; Move CXB info into UCB
;
	REMQUE	@CDB_Q_XMTREQ(R4),R3	; Get oldest xmit request
	BVS	20$			; Br if none
	MOVW	CXB$W_BCNT(R3),UCB$W_BCNT(R5) ; Set byte count
	MOVZWL	CXB$W_BOFF(R3),R2	; Get offset to start of data
	ADDL	R3,R2			; Compute buffer virtual address
	BICW3	#^C<VA$M_BYTE>,-	; Get buffer offset
		R2,UCB$W_BOFF(R5)	;
;
; Convert virtual address to physical PTE address
;
	EXTZV	S^#VA$V_VPN,-		; Get virtual page number
		S^#VA$S_VPN,R2,R2	;
	MOVL	G^MMG$GL_SPTBASE,R0	; Get the base address of the SPT
	MOVAL	(R0)[R2],UCB$L_SVAPTE(R5) ; Set address of the SPT entry
;
; The following instruction also sets the data path number to the Direct
; Data Path.
;
	ASSUME	VEC$W_MAPREG+2 EQ VEC$B_NUMREG
	ASSUME	VEC$B_NUMREG+1 EQ VEC$B_DATAPATH
	MOVL	CDB_L_XMTMAP(R4),-	; Assume we use preallocated map
		CRB$L_INTD+VEC$W_MAPREG(R6) ; register.
	TSTL	R7			; Is mapping slot the preallocated one?
	BEQL	50$			; Br if yes - all set
					; Else, allocate the map registers
;
; Allocate UNIBUS map registers
;
;;&&	CLRB	CRB$L_INTD+VEC$B_DATAPATH(R6) ; Reset data path usage
	JSB	G^IOC$ALOUBAMAP		; Allocate UNIBUS map registers
	BLBS	R0,40$			; Br if one available
	INSQUE	(R3),CDB_Q_XMTREQ(R4)	; Re-insert CXB on request queue
20$:	POPQ	R6			; Restore R6,R7
	MOVZBL	S^#SS$_NORMAL,R0	; Good return
30$:	RSB				; Return to caller
;
; Save the map information and map the buffer.
;
40$:	ASSUME	VEC$W_MAPREG+2 EQ VEC$B_NUMREG
	ASSUME	VEC$B_NUMREG+1 EQ VEC$B_DATAPATH
	MOVL	CRB$L_INTD+VEC$W_MAPREG(R6),- ; Save mapping info
		CDB_L_XMTMAP(R4)[R7]	; in CDB
50$:	SETBIT	R7,CDB_B_XMTMAP(R4)	; Set mapping slot in use flag
	MOVB	R7,CXB$B_XQ_SLOT(R3)	; Save mapping slot number used
	JSB	G^IOC$LOADUBAMAPA	; Load map registers
;
; Find next ring entry and insert data
;
	MOVZBL	CDB_B_NEXTXMT(R4),R2	; Get next ring entry
	INCB	CDB_B_NEXTXMT(R4)	; Bump ring pointer
	BICB	#^C<MAX_C_XMT-1>,-	; Modulo xmit ring size
		CDB_B_NEXTXMT(R4)	;
	MOVB	R2,CXB$B_XQ_RING(R3)	; Save ring entry number
	MOVL	CDB_L_XRINGVA(R4)[R2],R2; Get ring entry virtual address
	CLRW	XMT_W_FLAG(R2)		; Zero the FLAG word
	MOVW	#XMT_STS_M_LAST,-	; Init STATUS word
		XMT_W_STS(R2)		;
	MOVZWL	CXB$W_BCNT(R3),R0	; Get BYTE count
	CMPW	R0,#64			; Is packet at least minimum size?
	BGEQU	60$			; Br if yes, okay
	MOVL	#64,R0			; Else set to minimum
60$:	INCL	R0			; Round up by one
	ASHL	#-1,R0,R0		; Convert to WORD count
	MNEGW	R0,XMT_W_LEN(R2)	; Store message length (2's complement)
	MOVW	UCB$W_BOFF(R5),XMT_W_ADDR(R2) ; Move byte offset - BA0-BA8
	INSV	CRB$L_INTD+VEC$W_MAPREG(R6),- ; Insert BA9-BA15
		#9,#7,XMT_W_ADDR(R2)	;&
	EXTZV	#7,#6,CRB$L_INTD+VEC$W_MAPREG(R6),R0 ; Get BA16-BA21
	MOVW	R0,XMT_W_ADDRHI(R2)	; Insert BA16-BA21 & zero descriptor bits
	MOVL	R2,R6			; Save xmit ring entry address
	;
	; Descriptor bit settings are calculated as follows: (Even, Odd)
	;
	;	BEG	LEN	END
	;	---	---	---
	;	 E	 E	 E
	;	 E	 O	 O
	;	 O	 E	 O
	;	 O	 O	 E
	;
	MOVW	#XMT_DSC_M_VALID!-	; Build descriptor flag
		 XMT_DSC_M_EOM,R0
	BLBC	UCB$W_BOFF(R5),70$	; Br if even byte boundary at BEGinning
	;
	; Beginning buffer address is Odd
	;
	SETBIT	#XMT_DSC_V_BEGODD,R0	; Else, beginning is Odd
	BLBS	CXB$W_BCNT(R3),80$	; Br if odd LENgth, end is even
	SETBIT	#XMT_DSC_V_ENDODD,R0	; Else, ending is Odd
	DECW	XMT_W_LEN(R6)		; Increase length by 1 (complemented)
	BRB	80$			; Continue
	;
	; Beginning buffer address is Even
	;
70$:	BLBC	CXB$W_BCNT(R3),80$	; Br if even LENgth
	SETBIT	#XMT_DSC_V_ENDODD,R0	; Else, ending is Odd
80$:	CMPB	#XQ_FC_V_XMIT,-		; Is this a normal XMIT?
		CXB$B_XQ_FUNC(R3)	;
	BEQL	85$			; Br if yes
	SETBIT	#XMT_DSC_V_SETUP,R0	; Else, indicate SETUP function
85$:	CLRW	XMT_W_TDR(R6)		; Clear the TDR cell
	BISW	R0,XMT_W_ADDRHI(R6)	; Set descriptor bits
	INCB	CDB_B_XMTCNT(R4)	; Tally one more xmit in progress
;
; Request and load the port
;
	POPQ	R6			; Restore R6,R7
	DSBINT	UCB$B_DIPL(R5)		; Sync access to device
	INSQUE	(R3),@CDB_Q_INPUT+4(R4)	; Insert at end of input queue
	BNEQ	90$			; Br if not first entry on queue
	BSBW	LOAD_PORT		; Load port
90$:	ENBINT				; Restore IPL
	BRW	XMT_ALT_START		; Try for more requests

XMT_UV1:				; Transmit operation on u-VAX I
	ASSUME	MAX_C_XMTUV1 LE 8
	ASSUME	MAX_C_XMTUV1 LT MAX_C_XMT ; Must not use all rings
	FFC	#0,#MAX_C_XMTUV1,CDB_B_XMTMAP(R4),R7 ; Find a free transmit slot
	BEQL	120$			; Br if none free
;
; Move CXB data to contiguous buffer.
;
	REMQUE	@CDB_Q_XMTREQ(R4),R3	; Get oldest xmit request
	BVS	120$			; Br if none
	MOVZWL	CXB$W_BOFF(R3),R2	; Get offset to start of data
	ADDL	R3,R2			; Compute system buffer virtual address
	MOVL	CDB_L_XMT_VA(R4)[R7],R1	; Get contiguous buffer's VA
	PUSHR	#^M<R3,R4,R5>		; Save registers
	MOVC3	CXB$W_BCNT(R3),(R2),(R1) ; Copy the data
	POPR	#^M<R3,R4,R5>		; Restore registers
;
; Find next ring entry and insert data
;
	MOVZBL	CDB_B_NEXTXMT(R4),R2	; Get next ring entry
	INCB	CDB_B_NEXTXMT(R4)	; Bump ring pointer
	BICB	#^C<MAX_C_XMT-1>,-	; Modulo xmit ring size
		CDB_B_NEXTXMT(R4)	;
	MOVB	R2,CXB$B_XQ_RING(R3)	; Save ring entry number
	MOVB	R7,CXB$B_XQ_SLOT(R3)	; Save mapping slot number used
	SETBIT	R7,CDB_B_XMTMAP(R4)	; Set mapping slot in use flag
	MOVL	CDB_L_XRINGVA(R4)[R2],R2; Get ring entry virtual address
	CLRW	XMT_W_FLAG(R2)		; Zero the FLAG word
	MOVW	#XMT_STS_M_LAST,-	; Init STATUS word
		XMT_W_STS(R2)		;
	MOVZWL	CXB$W_BCNT(R3),R0	; Get BYTE count
	CMPW	R0,#64			; Is packet at least minimum size?
	BGEQU	110$			; Br if yes, okay
	MOVL	#64,R0			; Else set to minimum
110$:	INCL	R0			; Round up by one
	ASHL	#-1,R0,R0		; Convert to WORD count
	MNEGW	R0,XMT_W_LEN(R2)	; Store message length (2's complement)
	MOVL	CDB_L_XMT_PA(R4)[R7],R0	; Get contiguous buffer's PA
	MOVW	R0,XMT_W_ADDR(R2)	; Move buffer address - BA00-BA08
	ASHL	#-16,R0,R0		; Shift down hi order address lines
	MOVW	R0,XMT_W_ADDRHI(R2)	; Insert BA16-BA21 & zero descriptor bits
	MOVL	R2,R6			; Save xmit ring entry address
	;
	; Descriptor bit settings are calculated as follows: (Even, Odd)
	;
	;	BEG	LEN	END
	;	---	---	---
	;	 E	 E	 E
	;	 E	 O	 O
	;	 O	 E	 O
	;	 O	 O	 E
	;
	MOVW	#XMT_DSC_M_VALID!-	; Build descriptor flag
		 XMT_DSC_M_EOM,R0
	BRW	70$			; Continue - always even start buffers!

120$:	POPQ	R6			; Restore R6,R7
	MOVZBL	S^#SS$_NORMAL,R0	; Good return
	RSB				; Return to caller

	.DSABL	LSB
	

	.SBTTL	RCV_FDT - RECEIVE I/O OPERATION FDT ROUTINE
;++
; RCV_FDT - RECEIVE I/O OPERATION FDT ROUTINE
;
; Functional description:
;
; The specified buffer is checked for accessibility. The buffer address and count
; are saved in the packet. Then IPL is set to device fork IPL and if a message is
; available the operation is completed; otherwise, the packet is queued onto
; the waiting receive list.
;
; The QIO parameters for WRITES are:
;	P1 = Address of the data buffer
;	P2 = Size of the data buffer
;	P5 = Optional address of the buffer to receive the source address
;
; Inputs:
;
;	R3 = IRP address
;	R4 = PCB address
;	R5 = UCB address
;	R6 = CCB address
;	R7 = Function code
;	AP = Address of the first operation specific qio parameter
;
;	IPL = ASTDEL
;
; Outputs:
;
;	R0 = Status of the receive qio operation
;	R3 = IRP address
;	R5 = UCB ADDRESS
;
;	R1,R2 are destroyed.
;--

RCV_FDT::				; Read operation FDT
;
;  Check the request params
;
	CLRW	IRP$W_BOFF(R3)		; Set no quota to here
	MOVZBL	S^#SS$_ACCVIO,R0	; Assume access violation
	MOVL	P5(AP),R7		; Get address for source address
	BEQL	10$			; Br if none
	IFNOWRT	#RHDR_C_DATA,(R7),20$	; Check for write access to buffer
	BBS	#IRP$V_DIAGBUF,-	; Br if diagnostic buffer given
		IRP$W_STS(R3),10$	;	...
	MOVZBL	#RHDR_C_LENGTH,R1	; Get size of header buffer
	PUSHL	R3			; Save IRP address
	JSB	G^EXE$ALLOCBUF		; Allocate header buffer
	POPL	R3			; Restore IRP address
	BLBC	R0,20$			; Br if allocation failure
	MOVL	R2,IRP$L_DIAGBUF(R3)	; Save buffer address
	BISW	#IRP$M_DIAGBUF,IRP$W_STS(R3) ; Indicate diag buffer present
	ASSUME	RHDR_L_DATA EQ 0
	MOVAB	RHDR_T_DATA(R2),(R2)+	; Set address of start of data
	ASSUME	RHDR_L_BUFFER EQ RHDR_L_DATA+4
	MOVL	R7,(R2)+		; Set user buffer address
	ASSUME	RHDR_W_SIZE EQ RHDR_L_BUFFER+4
	MOVW	R1,(R2)+		; Save size of allocation
	ASSUME	RHDR_B_TYPE EQ RHDR_W_SIZE+2
	MOVB	#DYN$C_BUFIO,(R2)+	; Set structure type
10$:	MOVZBL	S^#SS$_BADPARAM,R0	; Assume illegal size
	MOVZWL	P2(AP),R1		; Get size



	BEQL	20$			; Br if zero - illegal
	MOVL	P1(AP),R0		; Get user buffer address
	MOVL	R0,IRP$L_XQ_DATBUF(R3)	; Save user VA for completion
	JSB	G^EXE$READCHK		; Check the buffer
					; (No return on NO ACCESS)
	BISW	#IRP$M_CHAINED,IRP$W_STS(R3) ; Allow data chaining
	SETIPL	UCB$B_FIPL(R5)		; Raise IPL to lock data base
	BSBB	RCV_START		; Process the request
	BLBC	R0,20$			; Br if error
	JMP	G^EXE$QIORETURN		; Else, take normal return

20$:	BRW	ABORTIO			; Abort the request

	.SBTTL	RCV_START - START RECEIVE I/O OPERATION
;++
; RCV_START - START RECEIVE I/O OPERATION
;
; Functional description:
;
;  Check for device active.  Receives cannot be queued to the UCB receive
;  queue unless the UCB has been initialized via routine START.   They
;  cannot be put in the IRP queue since this could result in non-sequential
;  receive processing due to the existence of the separate receive queue.
;
; Inputs:
;
;	R3 = IRP address
;	R5 = UCB address
;
;	IPL = FIPL
;
; Outputs:
;
;	R0 = Status of receive request
;	R4 = CDB address
;
;	R1,R2 are destroyed.
;
;--
INACT_ERROR:
	MOVZWL	#SS$_DEVINACT,R0	; Setup return status
	RSB				; Return to caller

	.ENABL	LSB
RCV_START::				; Start receive I/O operation
	BBC	#UCB$V_XQ_RUN,-		; Br if UCB is not in RUN mode
		UCB$W_DEVSTS(R5),INACT_ERROR
		
	MOVL	UCB$L_CRB(R5),R4	; Get CRB address
	MOVL	CRB$L_AUXSTRUC(R4),R4	; Get CDB address
	BEQL	40$			; Br if none
	BBC	#CDB_STS_V_RUN,-	; Br if QNA not running
		CDB_B_STS(R4),INACT_ERROR
	MOVAB	UCB$Q_XQ_RCVMSG(R5),R1	; Get address of UCB received messages
;
; If running in SHARED mode, then use the listheads in the SHR_
; data structure.
;
	BBC	#UCB$V_XQ_SHARE,-	; Br if UCB is NOT SHARED
		 UCB$W_DEVSTS(R5),5$	;
;
; Try to find a match on PID/CHAN
;
	BSBW	MATCH_SHR		; Try to find shared user
	BNEQ	INACT_ERROR		; Br if none - inactive user
	MOVAB	SHR_Q_RCVMSG(R1),R1	; Get address of received messages
;
; Check to see if message is available
;
5$:	REMQUE	@(R1)+,R2		; Dequeue a received message
					; ..bump pointer to end of list pointer
	BVS	10$			; Br if none
;
; Complete receive with available message
;
	BSBW	FINISH_RCV_IO		; Complete the receive
	BRB	30$			; And exit
;
; Queue IRP for future message arivial unless IO$M_NOW specified
;
10$:	BBC	#IO$V_NOW,IRP$W_FUNC(R3),20$ ; Br if not READ NOW
	MOVZWL	#SS$_ENDOFFILE,R0	; Set no message status
	BSBW	IO_DONE			; Complete the I/O
	BRB	30$			; And exit
;
; Queue the IRP to UCB receive wait queue
;
	ASSUME	UCB$Q_XQ_RCVREQ EQ UCB$Q_XQ_RCVMSG+8
	ASSUME	SHR_Q_RCVREQ EQ SHR_Q_RCVMSG+8
20$:	INSQUE	(R3),@8(R1)		; Put packet on waiting list
30$:	MOVZBL	S^#SS$_NORMAL,R0	; Set QIO status return
40$:	RSB				; Return to caller
	.DSABL	LSB

	.SBTTL	 SUBROUTINES TO FIND SHR DATA STRUCTURE
;+
; Subroutine to find SHR data structure for user
;
; Inputs:
;	R3 = Address of IRP
;	R5 = UCB address
;
; Outputs:
;	R1 = Address if SHR data structure if match
;	R0 is destroyed.
;	Z-Bit set then match.
;	Z-Bit clear then no match.
;-

MATCH_SHR:				; Try to find shared user
	MOVL	UCB$L_XQ_DEFUSR(R5),R1	; Get address of default user
	BEQL	10$			; Br if no default user
	BSBB	CHECK_SHR		; Check for match
	BEQL	40$			; Br if match
10$:	MOVAB	UCB$Q_XQ_SHARE(R5),R0	; Save address of listhead
	MOVL	R0,R1			; Copy listhead address
	ASSUME	SHR_L_QFL EQ 0
20$:	MOVL	(R1),R1			; Get next in list
	CMPL	R1,R0			; Back to start of list?
	BEQL	30$			; Br if yes - no pid/chan match
	BSBB	CHECK_SHR		; Check for match
	BNEQ	20$			; Br if none
	BRB	40$			; Return in success
30$:	MOVL	R0,R0			; Return match failure
40$:	RSB

;+
; Subroutine to check if PID and SHR data base match up
;
; Inputs:
;	R1 = Address of SHR
;	R3 = Address of IRP
;
; Outputs:
;	Z-Bit set then match.
;	Z-Bit clear then no match.
;-

CHECK_SHR:				; Check for match with SHR data base
	TSTL	IRP$L_PID(R3)		; Is this an Internal IRP user?
	BLSS	10$			; Br if yes, only one allowed per UCB
;
; Normal QIO user
;
	CMPL	IRP$L_PID(R3),SHR_L_PID(R1) ; PIDs match?
	BNEQ	30$			; Br if no - try for next
	BRB	20$			; Else, continue checks
;
; Internal IRP user
;
10$:	CMPL	UCB$L_XQ_PID(R5),SHR_L_PID(R1) ; Is this the Internal user?
	BNEQ	30$			; Br if not
20$:	CMPW	IRP$W_CHAN(R3),SHR_W_CHAN(R1) ; Channels match?
30$:	RSB				; Return to caller


	.SBTTL 	ALT_START - ALTERNATE START I/O ROUTINE
;++
; ALT_START - ALTERNATE STARTIO I/O ROUTINE
;
; Functional description:
;
; This routine is called by the Executive to pass an "internal" IRP
; to the driver.  "Internal" IRP's are those not built via QIO.
; These IRPs are used by higher level software used to request I/O and
; should not be confused with the IRPs built and passed by the
; Transport layer to NSP.  The action here is to setup the IRP fields
; as if the packet had been processed by the FDT routines.
;
; Inputs:
;
;	R3 = IRP address
;	R5 = UCB address
;
;	All pertinent fields of the IRP are assumed to be valid.
;
;	IPL = FIPL
;
; Implicit inputs:
;
;	IRP$L_SVAPTE(R3) = System VIRTUAL address (not physical PTE address)
;
; Outputs:
;
;	R0-R5 may be garbage	  
;--

ALT_START::				; Accept an "internal" IRP
	BBS	#IRP$V_FUNC,-		; If BS then read function
		IRP$W_STS(R3),10$
	MOVW	UCB$W_XQ_PROTYP(R5),-	; MUST be a non-promiscous user
		IRP$W_XQ_PROTYP(R3)	;
	MOVL	IRP$L_SVAPTE(R3),R2	; Get address of start of data
	SUBL3	#XQ_C_HEADER,(R2),R1	; Get the xmit buffer address
	SUBL	R2,R1			; Form offset to start of data
	MOVW	R1,CXB$W_BOFF(R2)	; Store offset in CXB
	MOVB	#DYN$C_CXB,CXB$B_TYPE(R2) ; Set structure type to CXB
	CMPB	UCB$B_XQ_PRO(R5),-	;% Point-to-point mode?
		#NMA$C_LINPR_POI
	BNEQ	5$			;% If so,
	CLRQ	IRP$Q_STATION(R3)	;% Pick up destination from SHR block
5$:	PUSHL	R3			; Save IRP address
	BSBW	XMT_START		; Start transmit operation
	POPL	R3			; Restore IRP address
	BRB	30$			; Continue

10$:	MOVL	IRP$L_SVAPTE(R3),R2	; Get address of input buffer
	BEQL	20$			; Br if none
	MOVL	UCB$L_CRB(R5),R4	; Get CRB address
	MOVL	CRB$L_AUXSTRUC(R4),R4	; Get CDB address
	CLRL	IRP$L_SVAPTE(R3)	; Make sure SVAPTE is cleared
;
; The driver must be prepared to process chained buffers returned from
; the higher levels.
;
;&&15$:	PUSHL	CXB$L_LINK(R2)		; Save address of next in link
;&&	CLRL	CXB$L_LINK(R2)		; Clear the link cell
	BSBW	ADDRCVLIST		; Else, add it to the receive list
;&&	POPL	R2			; Get back address of next in chain
;&&	BNEQ	15$			; Br if more to return

20$:	BSBW	RCV_START		; Start receive operation
30$:	BLBC	R0,40$			; Br if error
	RSB				; Return to caller

40$:	BRW	IO_DONE			; Post the I/O request in error

	.SBTTL	SETMODE_FDT - SET MODE I/O OPERATION FDT DISPATCH ROUTINE
;++
; SETMODE_FDT - SET MODE FDT PROCESSING
;
; Functional description:
;
; This is the fdt routine for setmode functions.
; There are three functions based on subfunction modifier bit.
;
; NOTE: That there is no difference on a request to shutdown a line or
;       a circuit. However, a request to startup a circuit is ignored
;	completely.
;
; The QIO parameters for SETMODE are:
;
;	P2 = Optional address of buffer descriptor for extended characteristics
;
;
; The Subfunction modifiers are as follows:
;
; 1)	CHANGE MODE -- NO MODIFIER BIT.
;	This function is done in the STARTIO routine. Control is passed to
;	EXE$SETMODE to validate the new mode buffer and queue the packet.
;
; 2)	INITIALIZE THE UNIT -- IO$M_STARTUP SET.
;	This function is done partially here and the remainder in STARTIO.
;	The action here is to pick up the user buffered I/O quota.  The quota
;	taken from the user is in IRP$W_BOFF. This value will be the IOSB+2 value
;	at I/O done. The mailbox is enabled and a receive is started.
;
; 3)	SHUTDOWN UNIT -- IO$M_SHUTDOWN SET.
;	This function shuts down the unit and optionally resets the mode.
;	A CANCEL I/O is performed, all outstanding I/O is completed, the
;	message blocks are all returned and the unit is left in an idle
;	state. This function cannot be done here and the FDT processing is
;	that of all SETMODE operations.
;
; 4)	ATTENTION AST -- IO$M_ATTNAST SET.
;	This function sets up an AST to be delivered when a change of
;	status occurs on the QNA.
;
;
; Inputs:
;
;	R3 = IRP ADDESS
;	R4 = PCB ADDRESS
;	R5 = UCB ADDRESS
;	R6 = CCB ADDRESS
;	R7 = FUNCTION CODE
;	AP = ADDRESS OF THE FIRST QIO PARAMETER
;
;	IPL = ASTDEL
;
; Outputs:
;
;	R3 = IRP ADDRESS
;	R4 = PCB ADDRESS
;	R5 = UCB ADDRESS
;
;	R0-R2,R6 are destroyed.
;
;--

SETMODE_FDT::				; SET MODE FDT processing
	CLRL	IRP$L_SVAPTE(R3)	; Set no buffered packet
	CLRQ	IRP$L_MEDIA(R3)		; Reset mode data area
	CLRL	IRP$L_XQ_SETUP(R3)	; Indicate no SETUP buffer yet
	MOVZWL	#SS$_DEVOFFLINE,R0	; Assume unit if offline
	BBS	#UCB$V_ONLINE,-		; Br if unit online
		UCB$W_STS(R5),5$	;
	BRW	ABORTIO			; Else, abort the I/O request

5$:	MOVW	IRP$W_FUNC(R3),R7	; Get entire function code
	BBC	#IO$V_ATTNAST,R7,30$	; Br if not attention AST
;
; User is requesting an attention AST
;
	MOVAL	UCB$L_XQ_AST(R5),R7	; Get address of AST list
	JSB	G^COM$SETATTNAST	; Set up attention AST

	ASSUME	UCB$V_XQ_INITED  EQ  0
	BLBC	UCB$W_DEVSTS(R5),10$	; Br if protocol not active

	MOVAB	UCB$Q_XQ_RCVMSG(R5),R1	; Check for empty receive list
	CMPL	R1,(R1)			; Empty?
	BEQL	10$			; Br if YES, no need to inform user
	PUSHL	R3			; Save IRP address
	BSBW	POKE_USER		; Inform user
	POPL	R3			; Restore IRP address
10$:	MOVZBL	S^#SS$_NORMAL,R0	; Set success
	MOVL	UCB$L_DEVDEPEND(R5),R1	; Get device dependent information
20$:	JMP	G^EXE$FINISHIO		; Complete the I/O
;
; On a circuit request,
;	If this is a shutdown then perform a $CANCEL and clear the RUN flag.
;	If this is a startup then set the RUN flag.
;
25$:	BBC	#IO$V_SHUTDOWN,R7,27$	; Br if not a shutdown request
	SETIPL	UCB$B_FIPL(R5)		; Sync acces to UCB & CDB
	CLRBIT	#UCB$V_XQ_RUN,-		; Clear the RUN flag
		UCB$W_DEVSTS(R5)
	MOVZWL	IRP$W_CHAN(R3),R2	; Get channel number
	ASSUME	CAN$C_CANCEL EQ 0
	CLRL	R8			; Set $CANCEL function
	BSBW	CANCEL			; Perform a CANCEL
	BRB	10$			; Complete the request

27$:	BBC	#IO$V_STARTUP,R7,10$	; Br if not a startup request
	CLRBIT	#XM$V_ERR_START,UCB$L_DEVDEPEND(R5) ;% Clear start error flag
	BISW	#UCB$M_XQ_START!UCB$M_XQ_STACK,- ;% Set start and stack states
		UCB$W_DEVSTS(R5)	;%
	SETBIT	#UCB$V_XQ_RUN,-		; Set the RUN flag
		UCB$W_DEVSTS(R5)
	BRB	10$			; Complete the request
;
; For everthing except Attention ASTs we must make sure CDB is present
; and we must verify the P2 buffer.
;
30$:	MOVL	UCB$L_CRB(R5),R1	; Get CRB address
	TSTL	CRB$L_AUXSTRUC(R1)	; Is CDB there?
	BNEQ	35$			; Br if yes
	BSBW	ALLOC_CDB		; Else, allocate CDB
	BLBS	R0,35$			; Br if successful
	MOVZWL	#SS$_INSFMEM,R0		; Set error return
33$:	BRW	ABORTIO			; Return error

35$:	BSBW	GET_CHAR_BUF		; Get P2 characteristics
	BLBC	R0,33$			; Br if error - Abort I/O
	MOVAB	LINE_PARAM_WO,R2	; Assume the line parameters
	BBS	#IO$V_CTRL,R7,36$	; Br if line request
	MOVAB	CIRCUIT_PARAM,R2	; Else, use the circuit parameters
36$:	BSBW	VALIDATE_P2		; Validate the P2 parameters
	BLBC	R0,20$			; Br if error
	BBC	#IO$V_CTRL,R7,25$	; Br if not a LINE request
	SETIPL	UCB$B_FIPL(R5)		; Sync access to UCB's
	BSBW	SAV_MULTI		; Save the multicast address list
	CLRL	IRP$L_XQ_SHR(R3)		; Assume exclusive user
	BBC	#UCB$V_XQ_SHARE,-	; Br if not a SHARED user
		UCB$W_DEVSTS(R5),40$	;
;
;	Allow the shared user to change the destination node with which
;	it is communicating.
;
	BSBW	MATCH_SHR		; Else, try to find shared user
	BNEQ	40$			; Br if none found, skip it
	MOVL	R1,IRP$L_XQ_SHR(R3)	; Save the SHR data structure address
	MOVL	SHR_G_DEST(R1),-	; Save the current destination user
		UCB$G_XQ_DES(R5)	;  address in the UCB
	MOVW	SHR_G_DEST+4(R1),-	;	...
		UCB$G_XQ_DES+4(R5)	;	...
;
;	Now we will set the parameters given in the setmode request. But,
;	first if the DEQNA controller is inited we will use the current
;	hardware settings for the defaults.
;
40$:	MOVL	UCB$L_CRB(R5),R1	; Get CRB address
	MOVL	CRB$L_AUXSTRUC(R1),R1	; Get CDB address
	ASSUME	CDB_STS_V_INITED EQ 0
	BLBC	CDB_B_STS(R1),45$	; Br if controller not enabled, use
					;  the fixed defaults
	MOVAB	CDB_B_SETPRM(R1),R1	; Get address of setable parameters
	MOVAB	UCB$B_XQ_CDBPRM(R5),R2	; Get address of UCB parameters
	MOVZBL	#UCB$C_XQ_CDBPRM,R0	; Get size of parameters to move
42$:	MOVB	(R1)+,(R2)+		; Store CDB parameters into UCB
	SOBGTR	R0,42$			; Loop if more
45$:	MOVAB	LINE_PARAM_WO,R2	; Get address of verification table
	BSBW	CHANGE_PARAM		; Change the parameters
	MOVL	IRP$L_XQ_SHR(R3),R1	; Get the SHR structure address
	BEQL	50$			; Br if not present, skip it
	MOVL	UCB$G_XQ_DES(R5),-	; Else, reset the destination user
		SHR_G_DEST(R1)		;  address into the SHR structure
	MOVW	UCB$G_XQ_DES+4(R5),-	;	...
		SHR_G_DEST+4(R1)	;	...

50$:	BBC	#IO$V_SHUTDOWN,R7,60$	; Br if not shutdown request
;
; Shutdown protocol request
;
	ASSUME	UCB$V_XQ_INITED  EQ  0
	BLBS	UCB$W_DEVSTS(R5),55$	; Br if still inited
	BRW	10$			; Else, complete I/O request now
55$:	MOVB	S^#XQ_FC_V_STOP,IRP$B_XQ_FUNC(R3) ; Set internal function code
	BRW	QUEPKT			; Queue request to QNA

60$:	BBS	#IO$V_STARTUP,R7,80$	; Br if startup function
70$:	BRW	180$			; Else, must be change mode
;
; Startup protocol request
;
80$:	MOVB	#XQ_FC_V_INIT,IRP$B_XQ_FUNC(R3) ; Insert internal function code
;
;	If the UCB is already initialized for SHARED use, then we will
;	check to make sure that the SHR struture exists. If it does then
;	the share structure must be active, by definition.
;
	TSTL	IRP$L_XQ_SHR(R3)		; Was the SHR structure present
	BNEQ	70$			; Br if yes, already started
	BBS	#UCB$V_XQ_SHARE,-	; Br if SHARED UCB, ingore status
		UCB$W_DEVSTS(R5),125$	; ..make user a shared user
	ASSUME	UCB$V_XQ_INITED  EQ  0
	BLBS	UCB$W_DEVSTS(R5),70$	; Br if already started
					; ..check multicast address list
	BBC	#UCB$V_XQ_PROTYP,-	; Br if no protocol specified
		UCB$W_DEVSTS(R5),100$	; ..error
;
; Check if protocol type is to be shared
;
	CMPB	#NMA$C_ACC_EXC,-	; Is this PROTOCOL TYPE for exclusive
		 UCB$B_XQ_ACC(R5)	;  use?
	BNEQ	125$			; Br if not
;
; Check protocol type for uniqueness
;
	MOVZWL	UCB$W_XQ_PROTYP(R5),R1	; Get protocol type
;
; For a user wishing to run in promiscuous mode, the requirement is that
; there be no other promiscuous users running. For a non-promiscuous user,
; there must be no other users running with the same protocol type.
;
	MOVAB	MATCH_PROTYP,R0		; Get address of Action routine
					;  assume non-PROMISCUOUS user

	ASSUME	NMA$C_STATE_ON EQ 0
	ASSUME	NMA$C_STATE_OFF EQ 1

	BLBS	UCB$B_XQ_PRM(R5),90$	; Br if NOT a PROMISCUOUS user
;
; The promiscuous user must have PHY_IO privilege
;
	MOVAB	MATCH_PROMTYP,R0	; Get address of Action routine
	IFPRIV	PHY_IO,90$		; If user has privilege, then okay
	BSBW	RES_MULTI		; Else, Restore original multicast list
	MOVZWL	#SS$_NOPRIV,R0		; Return error - NOPRIV
	MOVZWL	#NMA$C_PCLI_PRM,R1	; Return the bad parameter
	BRW	20$			; Finish the I/O request
90$:	PUSHQ	R4			; Save PCB, UCB addresses
	MOVL	UCB$L_CRB(R5),R4	; Get CRB address
	MOVL	CRB$L_AUXSTRUC(R4),R4	; Get CDB address
	JSB	(R0)			; Try to find exact match
	POPQ	R4			; Restore PCB, UCB addresses
	BLBC	R0,130$			; Br if none found - okay
;
;	Bad protocol type
;
100$:	MOVZWL	#NMA$C_PCLI_PTY,R1	; Return bad parameter code
	BRB	120$			; Finish error reporting
;
;	Bad quota calculated
;
110$:	MOVZWL	#NMA$C_PCLI_BFN,R1	; Return bad parameter code
120$:	MOVZBL	S^#SS$_BADPARAM,R0	; Set error return
123$:	BSBW	RES_MULTI		; Restore original multicast list
	BRW	20$			; Finish the I/O request
;
; Shared protocol type - look for same protocol type in other UCB.
;
125$:	BSBW	SHR_UCB			; Find other UCB in user or make this
					;  UCB shareable
	BLBC	R0,123$			; Br on error
;
; We must now check if UCB is already inited.
;
	ASSUME	UCB$V_XQ_INITED  EQ  0
	BLBC	UCB$W_DEVSTS(R5),135$	; Br if this UCB is NOT inited
					; skip quota taking, already done
	BRW	185$			; Else, compute multicast list

130$:	SETIPL	#IPL$_ASTDEL		; Reset IPL to ASTDEL
;
; Take quota needed
;
	BSBW	TAKE_QUOTA		; Take quota from user
	BLBC	R0,110$			; Br if error
	MOVW	R7,UCB$W_XQ_QUOTA(R5)	; Save quota in UCB
135$:	SETBIT	#UCB$V_XQ_INITED,-	; Indicate unit is initialized
		UCB$W_DEVSTS(R5)	;	...
	SETIPL	UCB$B_FIPL(R5)		; Sync access to UCB and CDB
	BLBS	UCB$B_XQ_PRM(R5),140$	; Br if NOT a PROMISCUOUS user
	MOVL	UCB$L_CRB(R5),R4	; Get CRB address
	MOVL	CRB$L_AUXSTRUC(R4),R4	; Get CDB address
	MOVL	R5,CDB_L_PRMUSER(R4)	; Store promiscuous user's address
;
; Pre-allocate all needed receive buffers, if the CDB is not initialized yet!
; The buffers are immediately deallocated, but this pre-allocation will allow
; the pool to grow if necessary! This must be done here, before we run on the
; interrupt stack.
;
140$:	PUSHQ	R3			; Save R3, R4
	MOVZWL	UCB$W_XQ_BSZ(R5),R1	; Get size of receive buffer	
	MOVZWL	UCB$W_XQ_HBQ(R5),R4	; Get device buffer quota
	DIVL	R1,R4			; Compute number of buffers to allocate
	INCL	R4			; Plus one extra
	CLRL	-(SP)			; End of list marker
145$:	JSB	G^EXE$ALONONPAGED	; Allocate the memory
	BLBC	R0,150$			; Br on error
	MOVW	R1,IRP$W_SIZE(R2)	; Save size of buffer
	MOVB	#DYN$C_CXB,IRP$B_TYPE(R2) ; Set structure type
	MOVL	R2,-(SP)		; Save buffer address
	SOBGTR	R4,145$			; Loop if more to allocate

150$:	MOVL	(SP)+,R0		; Get buffer address
	BEQL	155$			; Br if end of list
	JSB	G^EXE$DEANONPAGED	; Deallocate the block
	BRB	150$			; Try for more
155$:	POPQ	R3			; Restore R3, R4

	BSBW	ADD_MULTI		; Compile a new multicast address list
	BLBS	R0,190$			; Br if all okay

	ASSUME	NMA$C_STATE_ON EQ 0
	ASSUME	NMA$C_STATE_OFF EQ 1

	BLBS	UCB$B_XQ_PRM(R5),160$	; Br if NOT a PROMISCUOUS user
	CLRL	CDB_L_PRMUSER(R4)	; Else, clear the PROMISCUOUS user addr
160$:	CLRBIT	#UCB$V_XQ_INITED,-	; Indicate unit is not initialized
		UCB$W_DEVSTS(R5)	;	...
	ADDL	R7,JIB$L_BYTCNT(R6)	; Restore quota
	ADDL	R7,JIB$L_BYTLM(R6)	; ..and byte limit
170$:	MOVZWL	#NMA$C_PCLI_MCA,R1	; Indicate bad multicast address
	BRW	120$			; Return in error
;
; Change mode request - might have to reset multicast address list
;
180$:	ASSUME	UCB$V_XQ_INITED  EQ  0
	BLBS	UCB$W_DEVSTS(R5),185$	; Br if unit inited
	BRW	10$			; Else, success

185$:	SETIPL	UCB$B_FIPL(R5)		; Sync access to UCB and CDB
	BSBW	ADD_MULTI		; Compile global multicast address list
	BLBC	R0,170$			; Br if error
	MOVB	#XQ_FC_V_CHMODE,IRP$B_XQ_FUNC(R3) ; Set function request
190$:	BRW	QUEPKT			; Queue packet to driver

;+
; Take quota subroutine
;
;	Calculate buffer quota and check against user's quota
;
; Inputs:	R7 = Scratch
;		R6 = Scratch
;		R5 = UCB address
;		R4 = PCB address
;
;
; Outputs:	R7 = Quota taken
;		R6 = JIB address
;		R5 = UCB address
;		R4 = PCB address
;		R0 = Status
;
;	R1,R2 are destroyed.
;
; Implicit outputs:
;
;	BR to ABORTIO if quota is exceeded.
;
;-
TAKE_QUOTA:
	CLRL	R0			; Assume failure
	INCW	UCB$W_XQ_BSZ(R5)	; Round buffer size to even value
	BICW	#1,UCB$W_XQ_BSZ(R5)	;	...
	MOVZBL	UCB$B_XQ_BFN(R5),R1	; Get number of receive buffers
	MOVZWL	UCB$W_DEVBUFSIZ(R5),R2	; Get buffer size
	MULL	R2,R1			; Get needed quota
	MOVZWL	R1,R7			; Copy quota
	CMPL	R1,R7			; Overflow?
	BNEQ	110$			; Br if yes - error
	MOVL	PCB$L_STS(R4),-(SP)	; Save current PCB status
	SETBIT	#PCB$V_SSRWAIT,-	; Do not go into a resource wait
		PCB$L_STS(R4)		;   just to check the quota
	PUSHL	R3			; Save R3
	JSB	G^EXE$BUFQUOPRC		; Check quota
	POPL	R3			; Restore R3
	MOVL	(SP)+,PCB$L_STS(R4)	; Restore previous PCB status
	BLBS	R0,50$			; Br if success
	BRB	80$			; Else, return error

50$:	MOVL	PCB$L_JIB(R4),R6	; Get JIB address
	SUBL	R7,JIB$L_BYTCNT(R6)	; Adjust quota
	SUBL	R7,JIB$L_BYTLM(R6)	; ..and byte limit
	MOVZBL	#1,R0			; Indicate success
80$:	CLRL	R1			; No error return
90$:	RSB

110$:	MOVZBL	#SS$_BADPARAM,R0	; Setup error code
	MOVZWL	#NMA$C_PCLI_BFN,R1	; Assume BAD BFN
	BRB	90$			; Return error

;+
; CHECK_QUOTA - check SHARED unit's quota
;
; Inputs:	R9 = Scratch
;		R7 = Original UCB address
;		R5 = UCB address
;		R4 = PCB address
;
;
; Outputs:	R9 = Quota taken
;		R7 = Original UCB address
;		R5 = UCB address
;		R4 = PCB address
;		R0 = Status
;
;	R1,R2 are destroyed.
;
;-
CHECK_QUOTA:
	PUSHQ	R6			; Save R6, R7
	PUSHL	R5			; Save UCB address
	MOVL	R7,R5			; Copy original UCB address
	BSBB	TAKE_QUOTA		; Charge quota to user
	POPL	R5			; Restore UCB address
	BLBC	R0,90$			; Br if error
	MOVL	R7,R9			; Copy quota taken
	MOVZWL	UCB$W_XQ_TOTQUO(R5),R1	; Get total quota
	ADDL	R9,R1			; Compute new total
	MOVZWL	R1,R0			; Copy quota
	CMPL	R1,R0			; Overflow?
	BNEQ	110$			; Br if yes, error
	MOVZBL	#1,R0			; Else, return success
90$:	POPQ	R6			; Retore R6, R7
	RSB				; Return to caller

110$:	ADDL	R9,JIB$L_BYTCNT(R6)	; Restore quota
	ADDL	R9,JIB$L_BYTLM(R6)	; ..and byte limit
	MOVZWL	#SS$_EXQUOTA,R0		; Return bad quota
	CLRL	R1			; No parameter return
	BRB	90$			; Exit with error


	.SBTTL	SHR_UCB - CREATE SHARED UCB
;++
; SHR_UCB - CREATE SHARED UCB
;
; Functional description:
;
; This subroutine creates a shared UCB if this is the first SHARED user of the
; particular protocol type.  Else, the already created SHARED UCB is found and
; a shared data structure is added to the list of shared users of that protocol
; type.
;
; Inputs:
;
;	R3 = IRP address
;	R4 = PCB address
;	R5 = UCB address
;	R6 = CCB address
;	R7 = Function code
;	AP = Address of first function-dependent QIO parameter
;
;	IPL = FIPL
;
; Outputs:
;
;	R0 = Status return for request
;	R1 = Bad parameter code (if bad parameter error code)
;	R2,R7 are destroyed.
;	All other registers are preserved.
;
;	IPL = ASTDEL
;
;--

SHR_UCB::				; Setup shared protocol UCB
	PUSHR	#^M<R8,R9>		; Save registers
	JSB	G^SCH$IOLOCKW		; Lock I/O data base for write access
	MOVL	R5,R7			; Save UCB address
	MOVZWL	#SS$_DUPUNIT,R0		; Assume 2 channels assigned to UCB
	CMPW	#1,UCB$W_REFC(R5)	; Is there only one reference to UCB?
	BNEQ	23$			; Br if not, error (more than 1 channel)
	MOVZBL	UCB$B_XQ_ACC(R5),R8	; Save access mode
	BBS	#UCB$V_XQ_SHARE,-	; Br if we are already the SHARED UCB
		 UCB$W_DEVSTS(R5),10$	;
	PUSHL	R4			; Save PCB address
	MOVL	UCB$L_CRB(R5),R4	; Get CRB address
	MOVL	CRB$L_AUXSTRUC(R4),R4	; Get CDB address
	MOVW	UCB$W_XQ_PROTYP(R5),R1	; Get protocol type
	BSBW	MATCH_PROTYP		; Try to match protocol type
	POPL	R4			; Restore PCB address
	BLBS	R0,10$			; Br if found
	MOVL	R7,R5			; Else, get back old UCB address
	CLRL	UCB$L_PID(R5)		; Make this UCB shareable
	MOVL	UCB$L_ORB(R5),R0	; Get the ORB address
	CLRL	ORB$L_OWNER(R0)		;  clear owner UIC as well
	CLRL	UCB$L_XQ_DEFUSR(R5)	; Clear default user
	BISW	#UCB$M_XQ_SHARE,-	; Indicate that UCB is in SHARED mode
		 UCB$W_DEVSTS(R5)	;
;
; Allocate a share data structure and link it in
;
10$:	CMPB	#NMA$C_ACC_LIM,R8	; Is the new user a limited user?
	BEQL	20$			; Br if yes - okay
	MOVZWL	#SS$_DEVALLOC,R0	; Assume protocol already allocated
	TSTL	UCB$L_XQ_DEFUSR(R5)	; Is there already a default user?
	BNEQ	23$			; Br if YES - error
20$:	BSBW	CHECK_PARAM		; Check out all parameters
	BLBC	R0,25$			; Br on error
	BSBW	CHECK_QUOTA		; Check our quota
	BLBC	R0,25$			; Br if error
	MOVZBL	#SHR_C_LENGTH,R1	; Get size of structure to allocate
	PUSHL	R3			; Save IRP address
	JSB	G^EXE$ALLOCBUF		; Allocate buffer, reset IPL to ASTDEL
	POPL	R3			; Restore IRP address
	BLBS	R0,30$			; Br if success
	MOVZWL	#SS$_INSFMEM,R0		; Else, return error reason
	MOVL	PCB$L_JIB(R4),R1	; Get JIB address
	ADDL	R9,JIB$L_BYTCNT(R1)	; Restore quota
	ADDL	R9,JIB$L_BYTLM(R1)	; ..and byte limit
23$:	CLRL	R1			; No bad parameter code
25$:	MOVL	R7,R5			; Get back the OLD UCB address
	BRW	80$			; Exit with error
;
; Initialize shared (SHR) data structure
;
30$:	ASSUME	SHR_L_QFL EQ 0
	ASSUME	SHR_L_QBL EQ SHR_L_QFL+4
	CLRQ	(R2)+			; Zero LINK pointers
	ASSUME	SHR_W_SIZE EQ SHR_L_QBL+4
	MOVW	R1,(R2)+		; Save size
	ASSUME	SHR_B_TYPE EQ SHR_W_SIZE+2
	INCL	R2			; Filled by EXE$ALLOCBUF routine
	ASSUME	SHR_B_STS EQ SHR_B_TYPE+1
	MOVB	#SHR_STS_M_INITED,(R2)+	; Initialize SHR status
	ASSUME	SHR_L_PID EQ SHR_B_STS+1
	MOVL	IRP$L_PID(R3),(R2)+	; Save users PID and CHAN for
	ASSUME	SHR_W_CHAN EQ SHR_L_PID+4
	MOVW	IRP$W_CHAN(R3),(R2)+	;  for future lookups
	ASSUME	SHR_G_DEST EQ SHR_W_CHAN+2
	MOVL	UCB$G_XQ_DES(R7),(R2)+	; Save destination address
	MOVW	UCB$G_XQ_DES+4(R7),(R2)+ ;
	ASSUME	SHR_Q_QUEUES EQ SHR_G_DEST+6
	MOVZBL	#SHR_C_QUEUES,R1	; Get number of queues in structure
40$:	MOVAL	(R2),(R2)+		; Set forward link pointer
	MOVL	-4(R2),(R2)+		; Set backward link pointer
	SOBGTR	R1,40$			; Loop if more listheads
	ASSUME	SHR_W_QUOTA EQ SHR_Q_QUEUES+<8*SHR_C_QUEUES>
	MOVW	R9,(R2)+		; Initialize quota

	ASSUME	UCB$V_XQ_INITED EQ 0
	BLBC	UCB$W_DEVSTS(R5),50$	; Br if UCB not initialized
	ADDW	R9,UCB$W_XQ_QUOTA(R5)	; Add to the current quota
	ADDW	R9,UCB$W_XQ_TOTQUO(R5)	;  and the total quota
	BRB	55$			; Continue
50$:	MOVW	R9,UCB$W_XQ_QUOTA(R5)	; Set current quota
	MOVW	R9,UCB$W_XQ_TOTQUO(R5)	;  and total quota
55$:	SUBL	#SHR_C_LENGTH,R2	; Backup to beginning of structure
	CMPB	#NMA$C_ACC_LIM,R8	; Is this for limited use?
	BEQL	60$			; Br if YES
	MOVL	R2,UCB$L_XQ_DEFUSR(R5)	; Else, save default user address
	BRB	65$			; Skip linking onto list
60$:	INSQUE	(R2),@UCB$Q_XQ_SHARE+4(R5) ; Link user into shared user list
65$:	INCW	UCB$W_REFC(R5)		; Increment the ref count on the
					;   UCB to be used
	CMPL	R5,R7			; Was this the original UCB?
	BEQL	70$			; Br if YES - no more work to do
	INCW	UCB$W_REFC(R5)		; Else, increment REFC (for $DASSGN)
	MOVL	R5,IRP$L_UCB(R3)	; Return new UCB address
	MOVL	R5,CCB$L_UCB(R6)	;  in CCB also.
	PUSHR	#^M<R3,R5>		; Save IRP, real UCB address
	MOVL	R7,R5			; Copy old UCB address
	DECW	UCB$W_REFC(R5)		; Decrement the reference count
	JSB	G^IOC$CREDIT_UCB	; Restore UCB quota to JIB
	JSB	G^IOC$DELETE_UCB	; Delete the old UCB
	POPR	#^M<R3,R5>		; Restore IRP, UCB address
70$:	MOVZBL	S^#SS$_NORMAL,R0	; Return success
80$:	POPR	#^M<R8,R9>		; Restore registers, R4 is PCB address
	PUSHR	#^M<R0,R1,R3>		; Save IRP address, status return
	JSB	G^SCH$IOUNLOCK		; Unlock I/O data base
	POPR	#^M<R0,R1,R3>		; Restore IRP address, status return
	RSB				; Return to caller

	.SBTTL	CHECK_PARAM - CHECK SHARED USERS PARAMETERS
;++
; CHECK_PARAM - CHECK SHARED USERS PARAMETERS
;
; Functional description:
;
; Validate all parameters between the requesting SHARED user and the old
; existing SHARED user to make sure that are the same.
;
; Inputs:
;	R5 = UCB address of existing shared user
;	R7 = UCB address of new shared user
;	R8 = Protocol access mode
;
; Outputs:
;	R0 = Status of request
;	R1 = Bad parameter code if validation failed
;
;--

CHECK_PARAM:				; Check user parameters
	PUSHL	R6			; Save registers
	MOVAB	UCB$B_XQ_SHRPRM(R5),R0	; Get address of current parameters
	MOVAB	UCB$B_XQ_SHRPRM(R7),R6	; Get address of new parameters
	MOVZBL	#UCB$C_XQ_SHRPRM,R2	; Set size of parameter list
;
; Validate all user settable parameters except for Physical address
;
10$:	CMPB	(R0),(R6)		; Match?
	BNEQ	70$			; Br if no
	MOVB	(R0)+,(R6)+		; Store current value in UCB
	SOBGTR	R2,10$			; Loop if more to check
;
; NOW, check if user has given a hardware physical address.
;
;	R0 = Address of parameters in UCB
;	R6 = Address of parameters in CDB
;
	ASSUME	CDB_G_PHA EQ CDB_B_CON+1
	ASSUME	UCB$G_XQ_PHA EQ UCB$B_XQ_CON+1
	CMPL	#-1,(R6)		; Is user physical address defined?
	BNEQ	20$			; Br if yes
	CMPW	#-1,4(R6)		; Is user physical address defined?
	BEQL	30$			; Br if not
20$:	MOVZWL	#NMA$C_PCLI_PHA,R1	; Assume bad physical address
	CMPL	(R0)+,(R6)+		; Physical address match??
	BNEQ	80$			; Br if no
	CMPW	(R0)+,(R6)+		; Still match??
	BNEQ	80$			; Br if no
;
; If this is the shared default user, then set the multicast address list.
;
30$:	BSBW	SET_MULTIN		; Set new multicast address list
	BRB	100$			; Exit
;
; Error on parameter validation
;
70$:	MOVZWL	BAD_PARAM_TBL-2[R2],R1	; Return parameter code
80$:	MOVZBL	S^#SS$_BADPARAM,R0	; Return bad parameter error
100$:	POPL	R6			; Restore registers
	RSB

	.SBTTL	SET_MULTIN - SET NEW MULTICAST ADDRESS LIST IN UCB
;++
; SET_MULTIN - SET NEW MULTICAST ADDRESS LIST IN UCB
;
; Functional description:
;
; Copy the multicast address list from the old UCB to the new UCB.
; This operation is only done for the SHARED DEFAULT user of the PROTOCOL.
;
; Inputs:
;	R5 = UCB address of existing shared user
;	R7 = UCB address of new shared user
;	R8 = Protocol access mode
;
; Outputs:
;	R0 = Always success
;	All other are preserved.
;
;--

SET_MULTIN:				; Set new multicast list
	CMPB	#NMA$C_ACC_SHR,R8	; Is this the shared default user?
	BNEQ	50$			; Br if not
	PUSHR	#^M<R1,R2,R3,R4,R5>	; Save registers
	MOVC3	#6*MAX_C_MLT,UCB$G_XQ_MULTI(R7), - ; Copy multicast list
		UCB$G_XQ_MULTI(R5)	;
	POPR	#^M<R1,R2,R3,R4,R5>	; Restore registers
	MOVB	UCB$B_XQ_MULTI(R7),-	; Copy the number of valid addresses
		UCB$B_XQ_MULTI(R5)	;
50$:	MOVZBL	#SS$_NORMAL,R0		; Return success
	RSB				; Return to caller

	.SBTTL	SENSEMODE_FDT - SENSEMODE I/O FDT PROCESSING
;++
; SENSEMODE_FDT - SENSEMODE I/O FDT PROCESSING
;
; Functional description:
;
; Process read status and read counters requests.
;
; The QIO parameters for SENSEMODE are:
;
;	P1 = Optional address of quadword buffer
;	P2 = Optional address of buffer descriptor for extended characteristics
;
; The SUBFUNCTION modifiers are as follows:
;
; 1)	READ PARAMETERS -- NO MODIFIER.
;	This function reads the QNA parameters and returns them to the user.
;
; 2)	READ COUNTERS -- IO$M_RD_COUNT SET.
;	This function reads the QNA counters and returns them to the user.
;
;	CLEAR COUNTERS -- IO$M_CLR_COUNT SET.
;	This modifier must be used with the read counters modifier to clear
;	the counters as they are read.
;
;
; Inputs:
;
;	R3 = IRP address
;	R4 = PCB address
;	R5 = UCB address
;	R6 = CCB address
;	R7 = Function code
;	AP = Address of first function-dependent QIO parameter
;
;	IPL = ASTDEL
;
; Outputs:
;
;	R0 = Status return of SENSEMODE request
;
;	R1,R2,R6,R7 are destroyed.
;
;--

SENSEMODE_FDT::				; SENSE MODE I/O FDT processing
	MOVZWL	#SS$_DEVOFFLINE,R0	; Assume unit if offline
	BBC	#UCB$V_ONLINE,-		; Br if unit not online
		UCB$W_STS(R5),15$	;
	MOVW	IRP$W_FUNC(R3),R7	; Get entire function code
	BBS	#IO$V_CTRL,R7,10$	; Br if line request
;
; Check if read circuit counters
;
	BBC	#IO$V_RD_COUNT,R7,5$	; Br if not read circuit counters
	BRW	READ_CIRC_CTR		; Else, get the circuit counters
5$:	MOVZBL	S^#SS$_NORMAL,R0	; Return success
	MOVL	UCB$L_DEVDEPEND(R5),R1	; Get device dependent information
	JMP	G^EXE$FINISHIO		; Complete the I/O request

10$:	BBC	#IO$V_RD_COUNT,R7,20$	; Br if not read counters
;
; Read counters - modifier RD_COUNT
;
	BRW	READ_LINE_CTR		; Get the line counters

15$:	BRW	ABORTIO			; Abort the I/O request
;
; Read parameters - no modifier
;
20$:	CLRW	IRP$W_XQ_P2SIZ(R3)	; No return data
	MOVL	UCB$L_CRB(R5),R4	; Get CRB address
	MOVL	CRB$L_AUXSTRUC(R4),R4	; Get CDB address
	MOVZWL	S^#8,R1			; Size of P1 buffer if present
	BSBW	CHECK_BUFS		; Check P1 and P2 buffers
	MOVZBL	S^#SS$_NORMAL,R0	; Assume success
	MOVW	R0,IRP$W_XQ_STATUS(R3)	;	...
	MOVW	R1,IRP$W_XQ_USERSIZ(R3)	; Save user P2 buffer length
	BEQL	40$			; Br if no P2 buffer present

	MOVL	R2,IRP$L_XQ_P2BUF(R3)	; Save user P2 buffer address
	BSBW	RETURN_P2		; Return the P2 parameters
	MOVW	R0,IRP$W_XQ_P2SIZ(R3)	; Set size of return data
	TSTL	R4			; Is CDB present?
	BEQL	30$			; Br if no - okay to return now
	ADDL3	S^#10,R0,R1		; Check if default physical
					;  address can fit
	CMPW	R1,IRP$W_XQ_USERSIZ(R3) 	; Is buffer big enough for
					; default physical address?
	BGTRU	25$			; Br if no
	ADDW	#10,IRP$W_XQ_P2SIZ(R3)	; Add DPA to return buffer size
	ADDL3	R0,IRP$L_XQ_P2BUF(R3),R2	; Get buffer address
					; past end of return data
	MOVL	#<6@16>+NMA$C_PCLI_HWA!-; Store parameter code + size
		PRM_TYP_M_STRING,(R2)+ 	;  and indicate this is a string
	MOVL	CDB_G_HWA(R4),(R2)+	; Store Default Physical Address
	MOVW	CDB_G_HWA+4(R4),(R2)+	; 
	BRB	30$			; All is okay
25$:	MOVW	#SS$_BUFFEROVF,IRP$W_XQ_STATUS(R3) ; Return partial success
30$:	MOVZWL	IRP$W_XQ_P2SIZ(R3),R0	; Get size of user return data
	ASHL	#16,R0,R0		; Shift size of buffer return
	MOVW	IRP$W_XQ_STATUS(R3),R0	; Get status
 
40$:	TSTL	R4			; Is there a CDB?
	BEQL	50$			; Br if no CDB yet!
	MOVL	IRP$L_XQ_USERBUF(R3),R2	; Retrieve P1 buffer address
	BEQL	50$			; Br if none
	MOVQ	UCB$B_DEVCLASS(R5),(R2)	; Else, return characteristics
	BISL	CDB_L_DEVDEPEND(R4),4(R2) ;	...
	MOVL	CDB_L_DEVDEPEND(R4),R1	; Get device dependent info
50$:	BISL	UCB$L_DEVDEPEND(R5),R1	; ..from UCB also
	JMP	G^EXE$FINISHIO		; Complete the I/O request

;
; Queue I/O request to driver
;
QUEPKT:					; Queue packet to driver
	SETIPL	UCB$B_FIPL(R5)		; Raise IPL to fork IPL
	JSB	G^IOC$INITIATE		; Intiate the I/O request
	JMP	G^EXE$QIORETURN		; Lower IPL, and RET

	.SBTTL	READ_LINE_CTR - READ THE LINE COUNTERS
	.SBTTL	READ_CIRC_CTR - READ THE CIRCUIT COUNTERS
;++
; READ_LINE_CTR - READ THE LINE COUNTERS
; READ_CIRC_CTR - READ THE CIRCUIT COUNTERS
;
; Functional description:
;
; Process read circuit counters request.
;
; The QIO parameters for SENSEMODE are:
;
;	P2 = Address of buffer descriptor for counters
;
;
; Inputs:
;
;	R3 = IRP address
;	R4 = PCB address
;	R5 = UCB address
;	R6 = CCB address
;	R7 = Function code and modifier bits
;	AP = Address of first function-dependent QIO parameter
;
; Outputs:
;
;	R0 = Status return of SENSEMODE request
;
;	R1,R2,R6,R7 are destroyed.
;
;--
	.ENABL	LSB
ABORT_IRP:
	POPR	#^M<R8,R9,R10>		; Restore  registers
	BRW	ABORTIO			; Abort the I/O request

READ_LINE_CTR:				; Read the line counters
	PUSHR	#^M<R8,R9,R10>		; Save registers
	MOVAB	LINE_CTR,R8		; Get address of counter format table
	MOVZWL	#LINE_CTR_SIZE,R9	; Get number of entries in table
	MOVZWL	#LINE_CTR_BUFSIZ,R6	; Get size of system P2 buffer
	MOVL	UCB$L_CRB(R5),R10	; Get CRB address
	MOVZWL	#SS$_INSFMEM,R0		; Assume no CDB
	MOVL	CRB$L_AUXSTRUC(R10),R10	; Get CDB address
	BEQL	ABORT_IRP		; Br if none, abort the I/O
	BRB	10$			; Else, Continue in common code

READ_CIRC_CTR:				; Read the circuit counters
	PUSHR	#^M<R8,R9,R10>		; Save registers
	MOVAB	CIRC_CTR,R8		; Get address of counter format table
	MOVZWL	#CIRC_CTR_SIZE,R9	; Get number of entries in table
	MOVZWL	#CIRC_CTR_BUFSIZ,R6	; Get size of system P2 buffer
	MOVL	R5,R10			; Use UCB for counters

10$:	BSBW	CHECK_P2		; Check the P2 buffer
	MOVZBL	S^#SS$_BADPARAM,R0	; Assume zero length buffer
	MOVW	R1,IRP$W_XQ_USERSIZ(R3)	; Save size of user P2 buffer
	BEQL	ABORT_IRP		; Br if no buffer
	MOVL	R6,R1			; Get size of system P2 buffer
	BSBW	ALLOC_P2BUF		; Allocate the buffer
	BLBC	R0,ABORT_IRP		; Br if error
	MOVL	IRP$L_SVAPTE(R3),R1	; Get system P2 buffer address
	MOVL	R2,P2B_L_BUFFER(R1)	; Save user P2 buffer address
	MOVL	P2B_L_POINTER(R1),R2	; Get address of data portion of buffer
;
; Get the counters kept by the driver
;
20$:	MOVZWL	(R8)+,R0		; Get counter code
	MOVW	R0,(R2)+		; Return counter type code
	MOVZWL	(R8)+,R1		; Get offset word
	ADDL	R10,R1			; Point to counter in UCB
	EXTZV	#NMA$V_CNT_MAP,#3,R0,R0	; Get width + bit map indicator
	CASE	R0,TYPE=B,LIMIT=#2,<-	; Dispatch on width and bit map
		30$,-			; 8 bit counter
		30$,-			; 8 bit counter + bit map
		40$,-			; 16 bit counter
		35$,-			; 16 bit counter + bit map
		35$>			; 32 bit counter

30$:	BUG_CHECK NOBUFPCKT,FATAL

;
; 32 BIT counter/ 16 BIT counter + bitmap
;
35$:	MOVW	(R1)+,(R2)+		; Store counter in buffer
	BBC	#IO$V_CLR_COUNT,R7,40$	; Br if not clear counter operation
	CLRW	-2(R1)			; Else, clear the counter as well
;
; 16 BIT counter
;
40$:	MOVW	(R1),(R2)+		; Store counter in buffer
	BBC	#IO$V_CLR_COUNT,R7,50$	; Br if not clear counter operation
	CLRW	(R1)			; Else, clear the counter as well
50$:	SOBGTR	R9,20$			; Loop if more
	MOVZBL	S^#SS$_NORMAL,R1	; Assume success
	CMPW	IRP$W_XQ_USERSIZ(R3),-	; Is user's buffer big enough?
		IRP$W_BCNT(R3)		;
	BGEQU	60$			; Br if yes
	MOVW	IRP$W_XQ_USERSIZ(R3),-	; Else, set size to minimum
		IRP$W_BCNT(R3)		; Of both
	MOVW	#SS$_BUFFEROVF,R1	; Set partial success
60$:	MOVL	IRP$W_BCNT-2(R3),R0	; Get size of buffer returned in
					; ..high word of R0
	MOVW	R1,R0			; Get status return
	MOVL	UCB$L_DEVDEPEND(R5),R1	; Get device dependent info
	POPR	#^M<R8,R9,R10>		; Restore registers
	JMP	G^EXE$FINISHIO		; Complete the I/O request

	.DSABL	LSB


	.SBTTL	GET_CHAR_BUF - GET P2 CHARACTERISTICS BUFFER
;++
; GET_CHAR_BUF - GET P2 CHARACTERISTICS BUFFER
;
; Functional description:
;
; This routine saves the P2 buffer for later use by the driver.
; The P2 buffer is saved by allocating the appropriate amount of memory from
; non-paged pool.   The user's quota is checked before the allocation is made.
; And the non-paged pool buffer is charged against the user's quota. The P2
; system buffer address is passed in IRP$L_SVAPTE of the IRP.
;
;
; Inputs:
;
;	R3 = IRP address
;	R4 = PCB address
;	R5 = UCB address
;
; Outputs:
;
;	R0 = status of buffers
;
;	R3-R5 are preserved.
;
;--
 
GET_CHAR_BUF:					; Get characteristics buffer
;
; Check access to P2 buffer and check process's buffer quota
;
10$:	MOVL	P2(AP),R1			; Get address P2 char buf desc
	BEQL	40$				; Br if no P2 buffer
	PUSHL	R3				; Save R3
	JSB	G^EXE$PROBER_DSC		; Check access to buffer
	BLBC	R0,15$				; Br if error
	MOVZWL	R1,R1				; Get the length as a word
	PUSHL	R2				; Save R2
	JSB	G^EXE$BUFQUOPRC			; Check for buffered quota
	POPL	R2				; Restore R2
15$:	POPL	R3				; Restore R3
	BLBS	R0,30$				; Branch if quota ok
20$:	RSB					; Return
 
;
; Quota OKAY, allocate buffer and copy info.
;
30$:	BSBW	ALLOC_P2BUF			; Allocate buffer
	BLBC	R0,50$				; Br if error
	MOVL	IRP$L_SVAPTE(R3),R0		; Get P2 buffer address
	PUSHR	#^M<R3,R4,R5>			; Save sacred registers
	MOVC3	R1,(R2),P2B_T_DATA(R0)		; Save P2 char buffer
	POPR	#^M<R3,R4,R5>			; Restore registers
40$:	MOVZBL	S^#SS$_NORMAL,R0		; Set success
50$:	RSB					; Return

	.SBTTL	CHECK_BUFS - CHECK P1 AND P2 BUFFERS FOR WRITE ACCESS
;++
; CHECK_BUFS - CHECK P1 AND P2 BUFFERS FOR WRITE ACCESS
;
; Functional description:
;
; This routines checks the P1 and P2 buffers for write access if supplied.
;
; Inputs:
;
;	R1 = Size of P1 buffer needed for write access
;	R3 = IRP address
;	R4 = PCB address
;	R5 = UCB address
;	R7 = Function code
;
; Outputs:
;
;	R0 is destroyed.
;	R1 = Length of P2 buffer (zero if no P2 buffer)
;	R2 = Address of P2 buffer in user's process space
;
;
;	No RETURN on NO ACCESS
;
; Implicit Outputs:
;
;	IRP$V_FUNC bit set in IRP$W_STS by EXE$READCHK subroutine.
;
;--
 
CHECK_BUFS:
	BSBB	CHECK_P1			; Check P1 buffer
CHECK_P2:
	CLRL	R1				; Assume no P2 buffer desc
	MOVL	P2(AP),R2			; Get address of P2 desc
	BEQL	10$				; Br if no P2
	IFNORD	#8,(R2),ACCESS			; Br if no access
	MOVZWL	(R2),R1				; Get length of buffer
	BEQL	10$				; Br if zero
	MOVL	DSC$A_POINTER(R2),R0		; Get buffer address
	JSB	G^EXE$READCHK			; Check write access to buffer
						; (no return no access)
						; Also sets IRP$V_FUNC in IRP
	MOVL	R0,R2				; Copy buffer address
10$:	RSB					; Return to caller
 
ACCESS:	MOVZBL	S^#SS$_ACCVIO,R0		; Return access violation
	BRW	ABORTIO				; Abort the I/O request

	.SBTTL	CHECK_P1 - CHECK P1 BUFFER ADDRESS FOR WRITE ACCESS
;++
; CHECK_P1 - CHECK P1 BUFFER ADDRESS FOR WRITE ACCESS
;
; Functional description:
;
; This routine checks the P1 buffer and if okay, the buffer address
; is saved in IRP$L_MEDIA of the IRP.
;
; Inputs:
;
;	R1 = Size of buffer for write access
;	R3 = IRP address
;	R4 = PCB address
;	R5 = UCB address
;	R7 = Function code
;
; Outputs:
;
;	R0 is destroyed.
;
;	No RETURN on NO ACCESS.
;
; Implicit Outputs:
;
;	IRP$L_MEDIA(R3) = User P1 buffer address.
;	IRP$V_FUNC bit set in IRP$W_STS by EXE$READCHK subroutine.
;
;--

CHECK_P1:
	CLRL	IRP$L_MEDIA(R3)			; Assume no P1 buffer
	MOVL	P1(AP),R0			; Get address of user buffer
	BEQL	10$				; Br if none
	JSB	G^EXE$READCHK			; Check access to buffer
						; (No return - no access)
10$:	MOVL	R0,IRP$L_XQ_USERBUF(R3)		; Save P1 buffer address in IRP
	RSB					; Return to caller

	.SBTTL	ALLOC_P2BUF - ALLOCATE A P2 BUFFER AND CHARGE USER'S QUOTA
;++
; ALLOC_P2BUF - ALLOCATE A P2 BUFFER AND CHARGE USER'S QUOTA
;
; Functional description:
;
; This routine allocates a system buffer and returns the address in the IRP at
; IRP$L_SVAPTE.  The size of the allocation, including buffer header must
; be at least 24 bytes in length.
;
; Inputs:
;
;	R1 = Size of allocation desired
;	R3 = IRP address
;
; Outputs:
;
;	R0 = status of request
;
;	R1-R5 are preserved.
;
; Implicit Outputs:
;
;	IRP$L_SVAPTE(R3) = address of system buffer
;	IRP$W_BOFF(R3) = byte count charged to user's process
;	IRP$W_BCNT(R3) = original byte count requested
;
;	All parts of the P2 buffer header are initialized, except for the
;	user's P2 buffer address.
;
;--
 
ALLOC_P2BUF:					; Allocate a non-paged buffer
	TSTL	R1				; Zero length buffer?
	BEQL	30$				; Br if yes
	PUSHR	#^M<R1,R2,R3>			; Save registers
	MOVW	R1,IRP$W_BCNT(R3)		; Save original byte count
	CMPL	R1,S^#24-P2B_C_LENGTH		; Is buffer big enough?
	BGTRU	5$				; Br if yes
	MOVL	S^#24-P2B_C_LENGTH,R1		; Else, set size to minimum
5$:	ADDL2	S^#P2B_C_LENGTH,R1		; Add in size of header
	JSB	G^EXE$BUFQUOPRC			; Check for buffered quota
	BLBC	R0,10$				; Branch if quota bad
;
; Quota OKAY, allocate buffer and copy info.
;
	PUSHL	R1				; Save size to charge user
	JSB	G^EXE$ALLOCBUF			; Go allocate a buffer
	BLBS	R0,20$				; Br if success
	ADDL	#4,SP				; Pop saved size
10$:	POPR	#^M<R1,R2,R3>			; Restore registers
	RSB					; Return with error code in R0
;
; System buffer allocated decrement user's quota
;
20$:	POPL	R3				; Restore user quota charge
	MOVAB	P2B_T_DATA(R2),P2B_L_POINTER(R2) ; Set address to start of data
	MOVW	R3,P2B_W_SIZE(R2)		; Save buffer size in buffer
	MOVL	R2,R0				; Save P2 char buf addr
	MOVL	PCB$L_JIB(R4),R2		; Get JIB address
	SUBL	R3,JIB$L_BYTCNT(R2)		; Decrement user's quota
	POPR	#^M<R1,R2,R3>			; Restore registers
	MOVL	R0,IRP$L_SVAPTE(R3)		; Save P2 buffer address in IRP
	MOVW	P2B_W_SIZE(R0),IRP$W_BOFF(R3)	; Return buffer size in IRP
30$:	MOVZBL	S^#SS$_NORMAL,R0		; Set success
	RSB					; Return to caller

	.SBTTL	STARTIO - START I/O OPERATION
;++
; STARTIO - START I/O OPERATION
;
; Functional description:
;
; This routine is called when an IRP is ready to be processed by the driver.
; The request is dispatched to the appropriate routine base on the internal
; function code in the IRP.
;
; Inputs:
;
;	R3 = IRP address
;	R5 = UCB address
;
;	IPL = FIPL
;
; Outputs:
;
;	R0-R2,R4 are destroyed.
;--

STARTIO::				; Process an I/O packet
	MOVL	UCB$L_CRB(R5),R4	; Get CRB address
	MOVL	CRB$L_AUXSTRUC(R4),R4	; Get CDB address
	MOVZBL	IRP$B_XQ_FUNC(R3),R1	; Get the internal function code
10$:	$DISPATCH	R1,TYPE=B,-
	<-	;function	action

		<XQ_FC_V_INIT	STARTUP>,-	; Startup request
		<XQ_FC_V_STOP	SHUT>,-		; Shutdown request
		<XQ_FC_V_CHMODE	CHMODE>,-	; Set new multicast list
	>
;
; Other request type
;
	BUG_CHECK NOBUFPCKT,FATAL	; Fatal error

;
; Startup unit's protocol
;
STARTUP:				; Startup unit's protocol
	BSBB	START			; Start protocol
	BLBC	R0,10$			; Br if error on startup
	RSB				; Else, return to caller

10$:	PUSHL	R0			; Save error return
	BSBB	STOP			; Shutdown unit
	POPL	R0			; Restore error return
	BRW	IO_DONE			; Complete the I/O request

;
; Shutdown UNIT's protocol
;
SHUT:					; Shutdown protocol
	CMPL	R5,CDB_L_PRMUSER(R4)	; Are we the PROMISCUOUS user?
	BNEQ	10$			; Br if not
	CLRL	CDB_L_PRMUSER(R4)	; Else, clear the PROMISCUOUS user
	MOVB	#NMA$C_STATE_OFF,-	; Don't forget about the CDB
		CDB_B_PRM(R4)		;  parameter
	BSBW	SETUP_MODE		; Get setup buffer
	BLBC	R0,90$			; Br if error
	MOVB	#XQ_FC_V_STOP,-		; Set function request
		CXB$B_XQ_FUNC(R2)	;
	RSB				; Return to complete function

10$:	BSBB	STOP			; Shutdown unit
	MOVZBL	S^#SS$_NORMAL,R0	; Return success
	BRW	IO_DONE			; Complete I/O request

90$:	RSB				; Return to caller
;
; STOP the unit
;
STOP:					; Stop the protocol
	MOVL	UCB$L_CRB(R5),R4	; Get CRB address
	MOVL	CRB$L_AUXSTRUC(R4),R4	; Get CDB address
	BRW	SHUTDOWN_PROTYP		; Shutdown the unit
;
; CHMODE - set new multicast list
;
CHMODE:
	BSBW	SETUP_MODE		; Get XMIT setup buffer
	BLBC	R0,10$			; Exit if error
	MOVB	#XQ_FC_V_CHMODE,-	; Set function request
		CXB$B_XQ_FUNC(R2)	;
	JMP	@(SP)+			; Call back caller and return

10$:	BRW	IO_DONE			; Complete I/O request

	.SBTTL	START - START UNIT'S PROTOCOL
;++
; START - START UNIT'S PROTOCOL
;
; Functional description:
;
; This routine initiates the protocol on the unit. The QNA is reset if first
; unit online.  The free list is filled and the first receive started.
; If a failure occurs the unit shutdown sequence is entered.
;
; Inputs:
;
;	R3 = IRP address
;	R5 = UCB address
;
;	IPL = FIPL
;
; Implicit inputs:
;
;	IRP$L_MEDIA contains a copy of the mode buffer specified by the user.
;	IRP$W_BOFF contains the quota taken from the user for the unit.
;
; Outputs:
;
;	R0 = Status return for startup request.
;	R1,R2,R4 are destroyed.
;	R3,R5 are preserved.
;
;--

START::					; Start protocol operation
	CMPB	#NMA$C_LINPR_POI,-	;% Are we in PT-TO-PT mode?
		UCB$B_XQ_PRO(R5)	;%
	BNEQ	3$			;% Br if not
	MOVZWL	#IRP$C_LENGTH,R1	;% Set size of an IRP
	PUSHL	R3			;% Save R3
	JSB	G^EXE$ALONONPAGED	;% Allocate the IRP
	POPL	R3			;% Restore R3
	BLBS	R0,1$			;% Br if success
	MOVZWL	#SS$_INSFMEM,R0		;% Set error return
	RSB				;% Return to caller

1$:	MOVL	R2,UCB$L_XQ_STIRP(R5)	;% Save startup IRP
	BISW	#UCB$M_XQ_START!UCB$M_XQ_STACK,- ;% We are now in the startup
		UCB$W_DEVSTS(R5)	;%   and stack wait state

3$:	TSTL	UCB$L_XQ_CPID(R5)	; Creator PID saved already?
	BNEQ	5$			; Br if yes
	MOVL	UCB$L_CPID(R5),UCB$L_XQ_CPID(R5) ; Else, save creator PID
;
; Set up idle UCB
;
5$:	MOVZWL	#XM$M_STS_ACTIVE,-
		UCB$L_DEVDEPEND(R5)	; Reset status and error summary
	CMPB	#XQ_FC_V_RESTART,IRP$B_XQ_FUNC(R3) ; Is this a re-start operation?
	BEQL	8$			; Br if yes - don't reset the PID
	MOVL	IRP$L_PID(R3),UCB$L_XQ_PID(R5) ; Save starter's PID
;
; Check for CDB
;
8$:	MOVL	UCB$L_CRB(R5),R4	; Get CRB address
	MOVL	CRB$L_AUXSTRUC(R4),R2	; Get CDB address, crash if not present
	INCB	CDB_B_UNTCNT(R2)	; One more unit on this controller
	BBS	#CDB_STS_V_INITED,-	; Br if already inited
		CDB_B_STS(R2),10$	;
	BRW	20$			; Else, init CDB

10$:	MOVL	R2,R4			; Copy CDB address
	MOVAB	UCB$B_XQ_CDBPRM(R5),R0	; Get UCB parameter address
	MOVAB	CDB_B_SETPRM(R4),R1	; Get CDB parameter address
	MOVZBL	#UCB$C_XQ_CDBPRM,R2	; Set size of parameter list

;
; Check order of UCB parameters
;
	ASSUME	UCB$B_XQ_CON EQ UCB$B_XQ_CDBPRM
;
; Check order of CDB parameters
;
	ASSUME	CDB_B_CON EQ CDB_B_SETPRM

	ASSUME	NMA$C_STATE_ON NE -1
	ASSUME	NMA$C_STATE_OFF NE -1
13$:	CMPB	(R0),(R1)		; Match?
	BNEQ	18$			; Br if no
	MOVB	(R1)+,(R0)+		; Store CDB value in UCB
	SOBGTR	R2,13$			; Loop if more to check
;
; NOW, check if user has given a hardware physical address.
;
;	R0 = Address of parameters in UCB
;	R1 = Address of parameters in CDB
;
	ASSUME	CDB_G_PHA EQ CDB_B_CON+1
	ASSUME	UCB$G_XQ_PHA EQ UCB$B_XQ_CON+1
	CMPL	#-1,(R0)		; Is user physical address defined?
	BNEQ	15$			; Br if yes
	CMPW	#-1,4(R0)		; Is user physical address defined?
	BEQL	16$			; Br if not
15$:	MOVW	#NMA$C_PCLI_PHA,IRP$W_XQ_CODE(R3) ; Assume bad physical address
	CMPL	(R0)+,(R1)+		; Physical address match??
	BNEQ	19$			; Br if no
	CMPW	(R0)+,(R1)+		; Still match??
	BNEQ	19$			; Br if no
16$:	MOVL	CDB_G_PHA(R4),-		; Return hardware set address
		 UCB$G_XQ_PHA(R5)	;  just in case we defaulted
	MOVW	CDB_G_PHA+4(R4),-	;	...
		 UCB$G_XQ_PHA+4(R5)	;	...
;
; Check users buffer size - must not be more than twice the hardware buffer
; size. (Already has been checked against max message size).
;
	MOVW	#NMA$C_PCLI_BUS,IRP$W_XQ_CODE(R3) ; Assume bad buffer size
	MOVZWL	CDB_W_BSZ(R4),R1	; Get device buffer size
	BLBS	UCB$B_XQ_DCH(R5),17$	; Br if user can't do data chaining
					; && Maybe this is an Internal IRP user
	ADDW	CDB_W_BSZ(R4),R1	; Compute twice the normal buffer size
17$:	CMPW	UCB$W_DEVBUFSIZ(R5),R1	; Is buffer size okay?
	BGTRU	19$			; Br if too large
	CLRW	IRP$W_XQ_CODE(R3)	; No bad parameters
	BISW	#UCB$M_XQ_RUN,-		; Indicate we have entered RUN mode
		UCB$W_DEVSTS(R5)	;
	BSBW	MOVE_MULTI		; Copy multicast address list
	ASSUME	NMA$C_STATE_ON EQ 0
	ASSUME	NMA$C_STATE_OFF EQ 1
	BLBS	UCB$B_XQ_PRM(R5),173$	; Br if not promiscuous
	MOVB	UCB$B_XQ_PRM(R5),-	; Else, enable promiscuous mode
		CDB_B_PRM(R4)
173$:	BSBW	SETUP_MODE		; Allocate setup mode buffer
	BLBC	R0,175$			; Exit if error
	MOVB	#XQ_FC_V_CHMODE,-	; Set function request
		CXB$B_XQ_FUNC(R2)	;
	JSB	@(SP)+			; Complete request
175$:	RSB				; Return to caller
;
; Error on parameter validation
;
18$:	MOVW	BAD_PARAM_TBL-2[R2],IRP$W_XQ_CODE(R3) ; Return parameter code
19$:	MOVZBL	S^#SS$_BADPARAM,R0	; Return bad parameter error
	RSB				; Return to caller
;
; Initialize CDB
;
20$:	MOVZWL	#CDB_C_ZERO,R1		; Get portion of CDB to init with zero
	PUSHR	#^M<R1,R2,R3,R4,R5>	; Save registers
	MOVC5	#0,(R2),#0,R1,(R2)	; Zero the structure
	POPR	#^M<R1,R2,R3,R4,R5>	; Restore registers
	ASSUME	CDB_L_FQFL EQ 0
	ASSUME	CDB_L_FQBL EQ CDB_L_FQFL+4
	MOVAQ	(R2)+,R4		; Skip link pointers, copy CDB address
	ASSUME	CDB_W_SIZE EQ CDB_L_FQBL+4
	MOVW	R1,(R2)+		; Store size of structure
	ASSUME	CDB_B_TYPE EQ CDB_W_SIZE+2
	ASSUME	CDB_B_FIPL EQ CDB_B_TYPE+1
	MOVW	#<IPL$_XQ_FIPL@8>!DYN$C_CDB,(R2)+ ; Set structure type and FIPL
	ASSUME	CDB_L_FPC EQ CDB_B_FIPL+1
	MOVAB	FORK_PROC,(R2)+		; Set fork process address
	ASSUME	CDB_L_FR3 EQ CDB_L_FPC+4
	ASSUME	CDB_L_FR4 EQ CDB_L_FR3+4
	CLRQ	(R2)+			; Clear fork R3 and R4
	ASSUME	CDB_B_NEXTXMT EQ CDB_L_FR4+4
	ASSUME	CDB_B_NEXTRCV EQ CDB_B_NEXTXMT+1
	ASSUME	CDB_B_RCVMAP EQ CDB_B_NEXTRCV+1
	ASSUME	CDB_B_XMTMAP EQ CDB_B_RCVMAP+1
	CLRL	(R2)+			; Clear slot in use flags
	ASSUME	CDB_L_RCVMAP EQ CDB_B_XMTMAP+1
	ASSUME	CDB_L_XMTMAP EQ CDB_L_RCVMAP+<4*<MAX_C_RCV-1>>
	MOVZBL	#<MAX_C_XMT-1>+<MAX_C_RCV-1>,R1 ; Set number of mapping vectors
30$:	MNEGL	#1,(R2)+		; Indicate no mapping info
	SOBGTR	R1,30$			; Loop if more
	ASSUME	CDB_L_RRINGPA EQ CDB_L_XMTMAP+<4*<MAX_C_XMT-1>>
	ADDL	#CDB_Q_QUEUES-CDB_L_RRINGPA,R2	; Skip ring entry pointers
	MOVZBL	#CDB_C_QUEUES,R1	; Set number of queue listheads
40$:	MOVAL	(R2),(R2)+		; Set forward link
	MOVL	-4(R2),(R2)+		; Set backward link
	SOBGTR	R1,40$			; Loop if more listheads
	SETBIT	#CDB_STS_V_INITED,CDB_B_STS(R4)	; Set initial status bits
;
; Initialize CDB defaults
;
	MOVW	UCB$W_XQ_BSZ(R5),-	; Init CDB buffer size
		CDB_W_BSZ(R4)		;
	MOVW	UCB$W_XQ_HBQ(R5),CDB_W_QUOTA(R4) ; Set initial quota

	ASSUME	INIT_C_AQUOTA LE 255
	ASSUME	CDB_B_MQUOTA EQ CDB_B_AQUOTA+1
	MOVW	#<INIT_C_AQUOTA@8>,-	; Initialize Maximum QUOTA
		 CDB_B_AQUOTA(R4)	; and zero Additional QUOTA
	ASSUME	UCB$B_XQ_MLT EQ UCB$B_XQ_PRM+1
	ASSUME	CDB_B_MLT EQ CDB_B_PRM+1
	MOVW	UCB$B_XQ_PRM(R5),CDB_B_PRM(R4) ; Set the promiscuous mode
					;  and the all multicast enable
	MOVAB	UCB$B_XQ_CDBPRM(R5),R0	; Get address of UCB parameters
	MOVAB	CDB_B_SETPRM(R4),R1	; Get address of CDB parameters
	MOVZBL	#UCB$C_XQ_SETPRM,R2	; Set size of parameter list
45$:	MOVB	(R0)+,(R1)+		; Store parameters
	SOBGTR	R2,45$			; Loop if more
	BSBW	MOVE_MULTI		; Copy multicast address list
	MOVW	CDB_W_BSZ(R4),-		; Set buffer size
		UCB$W_BCNT(R5)
	PUSHQ	R6			; Save R6,R7
	MOVL	R4,R6			; Save CDB address
	MOVL	UCB$L_CRB(R5),R4	; Get CRB address
	MOVL	UCB$L_DDB(R5),R7	; Get DDB address
	MOVL	DDB$L_UCB(R7),CDB_L_UCB0(R6) ; Set UCB #0 address

	CPUDISP	<<790,50$>,-
		 <780,50$>,-
		 <750,50$>,-
		 <730,50$>,-
		 <UV1,70$>>
50$:	;
	; Allocate map registers for receive buffers and one transmit buffer.
	;
	MOVW	#511,UCB$W_BOFF(R5)	; Set worst case byte offset
	ASSUME	VEC$W_MAPREG+2 EQ VEC$B_NUMREG
	ASSUME	VEC$B_NUMREG+1 EQ VEC$B_DATAPATH
	CLRL	CRB$L_INTD+VEC$W_MAPREG(R4) ; Clear map register + datapath
	MOVAL	CDB_L_RCVMAP(R6),R6	; Get mapping slot address
	MOVZBL	#MAX_C_RCV-1,R7		; Get number of receive slots
55$:	JSB	G^IOC$ALOUBAMAP		; Allocate a set of map registers
	BLBC	R0,60$			; Br if unavailable
	MOVL	CRB$L_INTD+VEC$W_MAPREG(R4),(R6)+ ; Save map info
	SOBGTR	R7,55$			; Continue

	MOVZWL	#MAX_PKT_SIZE+18,-	; Set transmit buffer size to max
		UCB$W_BCNT(R5)		;  Ethernet packet size + header
	JSB	G^IOC$ALOUBAMAP		; Allocate a set of transmit registers
	BLBC	R0,60$			; Br if unavailable
	ASSUME	CDB_L_XMTMAP EQ CDB_L_RCVMAP+<4*<MAX_C_RCV-1>>
	MOVL	CRB$L_INTD+VEC$W_MAPREG(R4),(R6) ; Save transmit map info
	;
	; Allocate mapping for QNA RING structures.
	;
	MOVL	CRB$L_AUXSTRUC(R4),R6	; Get CDB address

 	ASSUME	CDB_G_MAPPED EQ CDB_G_RRING
	ASSUME	CDB_G_XRING EQ CDB_G_RRING+RCV_K_LENGTH
	MOVAB	CDB_G_MAPPED(R6),R7	; Get starting ring address
	BICW3	#^C<VA$M_BYTE>,-	; Get PCBB byte offset
		R7,UCB$W_BOFF(R5)
	MOVW	#CDB_C_MAPPED,UCB$W_BCNT(R5) ; Set Block size
	JSB	G^IOC$ALOUBAMAP		; Allocate map registers
	BLBS	R0,65$			; Br if allocated
60$:	POPQ	R6			; Restore R6, R7
	MOVZWL	#SS$_INSFMAPREG,R0	; Set insufficient map registers
	RSB				; Return with error

	ASSUME	VEC$W_MAPREG+2 EQ VEC$B_NUMREG
	ASSUME	VEC$B_NUMREG+1 EQ VEC$B_DATAPATH
65$:	MOVL	CRB$L_INTD+VEC$W_MAPREG(R4),- ; Save RING mapping info
		CDB_L_RINGMAP(R6)	;
	;
	; Convert the virtual RING address to a UNIBUS mapped address
	;
	EXTZV	S^#VA$V_VPN,-		; Get RING page number
		S^#VA$S_VPN,R7,R1	;
	MOVL	G^MMG$GL_SPTBASE,R0	; Get SPT address
	MOVAL	(R0)[R1],UCB$L_SVAPTE(R5) ; Set PTE address
	JSB	G^IOC$LOADUBAMAP	; Load the PCBB map registers
	EXTZV	#7,#2,-			; Get BA16-BA17
		CRB$L_INTD+VEC$W_MAPREG(R4),R1 ;
	ASHL	#16,R1,R1		; Move to high word
	MOVW	UCB$W_BOFF(R5),R1	; Set BA0-BA8
	INSV	CRB$L_INTD+VEC$W_MAPREG(R4),- ; Set BA9-BA15
		#9,#7,R1		;
	BRB	80$			; Continue

70$:	;
	; Compute physical address t0 start of rings for u-VAX I.
	;
	ASSUME	CDB_G_MAPPED EQ CDB_G_RRING
	ASSUME	CDB_G_XRING EQ CDB_G_RRING+RCV_K_LENGTH
	MOVAB	CDB_G_MAPPED(R6),R7	; Get starting ring address
	EXTZV	#VA$V_VPN,#VA$S_VPN,R7,R1 ; Get virtual page number
	MOVL	G^MMG$GL_SPTBASE,R0	; Get base address of SPTs
	MOVL	(R0)[R1],R0		; Get the PTE contents
	BICL3	#^C<VA$M_BYTE>,R7,R1	; Get buffer offset (BA00-BA08)
	ASSUME	PTE$S_PFN GE 13
	INSV	R0,#9,#13,R1		; Copy BA09-BA21

80$:	;
	; Now calculate the physical/virtual address of each of the ring buffer
	; entries, saving the addresses in the PHYSICAL ADDRESS/VIRTUAL
	; ADDRESS VECTOR
	;
	MOVAB	CDB_G_RRING(R6),R0	; Get first ring entry
	CLRL	R7			; Use R7 as ring index
90$:	MOVL	R1,CDB_L_RRINGPA(R6)[R7]; Save RING physical address
	ADDL	#RCV_C_LENGTH,R1	; Skip to next
	MOVL	R0,CDB_L_RRINGVA(R6)[R7]; Save RING entry virtual address
	ADDL	#RCV_C_LENGTH,R0	; Skip to next
	AOBLSS	#MAX_C_RCV,R7,90$	; Loop if more

	ASSUME	CDB_G_XRING EQ CDB_G_RRING+<<MAX_C_RCV+1>*RCV_C_LENGTH>
	MOVL	R1,CDB_L_RRINGPA(R6)[R7]; Save RING physical address
	ADDL	#RCV_C_LENGTH,R1	; Skip over chained entry
	ADDL	#RCV_C_LENGTH,R0	; Skip over chained entry

	CLRL	R7
100$:	MOVL	R1,CDB_L_XRINGPA(R6)[R7]; Save RING physical address
	ADDL	#XMT_C_LENGTH,R1	; Skip to next
	MOVL	R0,CDB_L_XRINGVA(R6)[R7]; Save RING entry virtual address
	ADDL	#XMT_C_LENGTH,R0	; Skip to next
	AOBLSS	#MAX_C_XMT,R7,100$	; Loop if more
	MOVL	R1,CDB_L_XRINGPA(R6)[R7]; Save last RING physical address
	;
	; Initialize receive ring buffer entries
	;
	MOVZBL	#MAX_C_RCV,R7		; Set number of entries in ring
	MOVAB	CDB_G_RRING(R6),R1	; Get address of RING buffer
110$:	MOVW	#RCV_FLG_M_LAST,-	; Init flags
		RCV_W_FLAG(R1)		;
	CLRW	RCV_W_STS(R1)		; Zero status
	ADDL	#RCV_C_LENGTH,R1	; Skip to next entry
	SOBGTR	R7,110$			; Loop if more
	;
	; The last entry "chains" back to the first
	;
	MOVW	#RCV_FLG_M_LAST,-	; Init flags
		RCV_W_FLAG(R1)		;
	MOVW	CDB_L_RRINGPA(R6),-	; Set the chain address
		RCV_W_ADDR(R1)		;
	MOVZBW	CDB_L_RRINGPA+2(R6),-	; Set high part of chain address
		RCV_W_ADDRHI(R1)	;
	BISW	#RCV_DSC_M_CHAIN!-	; Indicate chain operation
		 RCV_DSC_M_VALID,-	;   and valid address
		 RCV_W_ADDRHI(R1)	; 
	;
	; Initialize transmit ring buffer entries
	;
	MOVZBL	#MAX_C_XMT,R7		; Set number of XMIT entries
	MOVAB	CDB_G_XRING(R6),R1	; Get address of RING buffer
120$:	MOVW	#XMT_FLG_M_LAST,-	; Init flags
		XMT_W_FLAG(R1)		;
	CLRW	XMT_W_STS(R1)		; Zero status
	ADDL	#XMT_C_LENGTH,R1	; Skip to next entry
	SOBGTR	R7,120$			; Loop if more
	;
	; The last entry "chains" back to the first
	;
	MOVW	#XMT_FLG_M_LAST,-	; Init flags
		XMT_W_FLAG(R1)		;
	MOVW	CDB_L_XRINGPA(R6),-	; Set the chain address
		XMT_W_ADDR(R1)		;
	MOVZBW	CDB_L_XRINGPA+2(R6),-	; Set high part of chain address
		XMT_W_ADDRHI(R1)	;
	BISW	#XMT_DSC_M_CHAIN!-	; Indicate chain operation
		 XMT_DSC_M_VALID,-	;   and valid address
		 XMT_W_ADDRHI(R1)	;
;
; Initialize contiguous buffer area for u-VAX I.
;
	CPUDISP	<<790,140$>,-
		 <780,140$>,-
		 <750,140$>,-
		 <730,140$>,-
		 <UV1,122$>>		; Initialize buffer area for UV1

122$:					; Init u-VAX I buffer area
	MOVL	CDB_L_UV1BUF(R6),R2	; Get buffer area address
	BNEQ	123$			; Br if present
	POPQ	R6			; Restore R6, R7
	MOVZWL	#SS$_INSFMEM,R0		; Else, return error
	RSB

123$:	;
	; Compute physical/virtual address of buffers in buffer area
	MOVAB	12(R2),R2		; Get start of buffer area
	EXTZV	#VA$V_VPN,#VA$S_VPN,R2,R0 ; Get virtual page number
	MOVL	G^MMG$GL_SPTBASE,R1	; Get base address of SPTs
	MOVL	(R1)[R0],R0		; Get the PTE contents
	BICL3	#^C<VA$M_BYTE>,R2,R1	; Get buffer offset (BA00-BA08)
	ASSUME	PTE$S_PFN GE 13
	INSV	R0,#9,#13,R1		; Copy BA09-BA21
	CLRL	R0			; Use R0 as receive buffer index
124$:	MOVL	R1,CDB_L_RCV_PA(R6)[R0]	; Save receive physical address
	MOVL	R2,CDB_L_RCV_VA(R6)[R0]	; Save receive virtual adress
	ADDL	#MAX_BUFSIZ_UV1,R1	; Skip to next buffer
	ADDL	#MAX_BUFSIZ_UV1,R2	;	...
	AOBLSS	#MAX_C_RCVUV1,R0,124$	; Loop if more
	CLRL	R0			; Use R0 as transmit buffer index
125$:	MOVL	R1,CDB_L_XMT_PA(R6)[R0]	; Save transmit physical address
	MOVL	R2,CDB_L_XMT_VA(R6)[R0]	; Save transmit virtual address
	ADDL	#MAX_BUFSIZ_UV1,R1	; Skip to next buffer
	ADDL	#MAX_BUFSIZ_UV1,R2	;	...
	AOBLSS	#MAX_C_XMTUV1,R0,125$	; Loop if more

140$:	MOVL	R6,R4			; Set R4 to CDB address
	POPQ	R6			; Restore R6, R7
;
; Setup fork process to start CDB timer
;
	PUSHR	#^M<R3,R4,R5>		; Save registers
	BBSS	#CDB_STS_V_TIMER,-	; Br if timer already going
		CDB_B_STS(R4),150$	;
	BISB	#DPT$M_NOUNLOAD,-	; Do not allow driver to be unloaded
		DPT$TAB+DPT$B_FLAGS	;  while the TQE is active
	MOVAL	CDB_L_TQE(R4),R5	; Get the TQE address
	MOVQ	#TQE_DELTA,TQE$Q_DELTA(R5) ; Set the delta time
	MOVAB	W^TQE_TIMER,R3		; Set address of timer wakeup routine
	MOVB	#TQE$C_SSREPT,TQE$L_RQPID(R5) ; Set the TQE request type
	BSBW	FORK_TIMER		; Create fork process for TQE
;
; Get hardware CSR address
;
150$:	POPR	#^M<R3,R4,R5>		; Restore registers
	MOVL	UCB$L_CRB(R5),R2	; Get CRB adddress
	MOVL	@CRB$L_INTD+VEC$L_IDB(R2),R2 ; Get CSR address
;
; Master reset device
;
	DSBINT	UCB$B_DIPL(R5)		; Sync access to UCB
	MOVW	#XQ_CSR_M_RESET,CSR(R2) ; Master Reset device
;
; The master reset will take some time to complete ...
; so we will delay to give the QNA some time.
;
	TIMEWAIT #1,#XQ_CSR_M_ERR,CSR(R2),W ; Wait for 10 usec, bit should not set
	MOVW	#^O120,VECTOR(R2)	; Set vector address
;
; Copy the Ethernet Hardware Address
;
	MOVB	PHYADD0(R2),CDB_G_HWA(R4) ; Save Hardware address
	MOVB	PHYADD1(R2),CDB_G_HWA+1(R4) ;	...
	MOVB	PHYADD2(R2),CDB_G_HWA+2(R4) ;	...
	MOVB	PHYADD3(R2),CDB_G_HWA+3(R4) ;	...
	MOVB	PHYADD4(R2),CDB_G_HWA+4(R4) ;	...
	MOVB	PHYADD5(R2),CDB_G_HWA+5(R4) ;	...
;
; Set CSR mode and enable receiver
;
	BICW	#XQ_CSR_M_RESET,CSR(R2)	; Clear the master reset

	ASSUME	NMA$C_LINCN_NOR EQ 0
	ASSUME	NMA$C_LINCN_LOO EQ 1
	BLBS	CDB_B_CON(R4),160$	; Br if LOOPBACK is enabled
	BISW	#XQ_CSR_M_ILOOP,CSR(R2)	; Else, DISABLE LOOPBACK
160$:	BISW	#XQ_CSR_M_INTENA,CSR(R2); Enable transmit interrupts
	MOVW	CDB_L_RRINGPA(R4),-	; Set address of receive list entry
		RCVLIST(R2)		;
	MOVB	CDB_L_RRINGPA+2(R4),-	;  and high order part
		RCVLST1(R2)
	MOVW	CDB_L_XRINGPA(R4),-	; Set address of transmit list entry
		XMTLIST(R2)		;
	MOVB	CDB_L_XRINGPA+2(R4),-	;  and high order part
		XMTLST1(R2)
	ENBINT				; Re-enable interrupts
;
; Initialize QNA mode.
;
	BSBW	SETUP_MODE		; Setup the QNA mode
	BLBC	R0,180$			; Exit if error
	MOVB	#XQ_FC_V_INIT,-		; Set function request
		CXB$B_XQ_FUNC(R2)	;
	JSB	@(SP)+			; Complete function request
	SETBIT	#CDB_STS_V_RUN,-	; Indicate QNA is running
		CDB_B_STS(R4)		;
	SETBIT	#UCB$V_XQ_RUN,-		; Indicate UNIT is running
		UCB$W_DEVSTS(R5)	;
	MOVL	UCB$L_CRB(R5),R0	; Get CRB adddress
	MOVL	@CRB$L_INTD+VEC$L_IDB(R0),R0 ; Get CSR address
	BISW	#XQ_CSR_M_RCVENA,CSR(R0); Enable receive interrupts
	BSBW	FILLRCVLIST		; Start the receives
	MOVZBL	S^#SS$_NORMAL,R0	; Return success
180$:	RSB				; Return to caller

;++
; FORK_TIMER - Routine to create a fork process to start a timer
;
; This routine starts up a FORK process which is used to start a timer.
;
; Inputs:
;
;	R3 = Address of system routine to handle the timer expiration.
;	R5 = Address of TQE block
;
;	IPL = Greater than Queueast IPL
;
; Outputs:
;
;	Fork process is started.
;	R3, R4 are destroyed by EXE$FORK
;
;--
FORK_TIMER:				; Create fork process to start timer
	MOVB	#DYN$C_TQE,FKB$B_TYPE(R5) ; Set structure type
	MOVB	#IPL$_QUEUEAST,FKB$B_FIPL(R5) ; Set IPL of fork process
	PUSHAB	B^START_TIMER		; Push address of fork process
	JMP	G^EXE$FORK		; Create fork process to start timer

;++
; START_TIMER - Fork process to start the CDB timer
;
; This routine starts up the CDB which is used to monitor the QNA controller
; for proper operation.
;
; Inputs:
;
;	R5 = Address of TQE block
;
;	IPL = Queueast IPL
;
; Implicit inputs:
;
;	TQE$Q_DELTA(R5) = Delta time interval
;	TQE$L_RQPID(R5) = TQE request type (SSSNGL or SSREPT)
;
; Outputs:
;
;	R0-R3 are destroyed.
;	TQE element added to timer queue
;
;--
START_TIMER:
	DSBINT	#IPL$_TIMER		; Raise IPL
	MOVL	FKB$L_FR3(R5),TQE$L_FPC(R5) ; Set address of timer wakeup
	MOVB	TQE$L_RQPID(R5),-	; Set TQE request type
		TQE$B_RQTYPE(R5)	;
	MOVQ	TQE$Q_DELTA(R5),R0	; Get delta time
	ADDL	G^EXE$GQ_SYSTIME,R0	; Add in current time
	ADWC	G^EXE$GQ_SYSTIME+4,R1	;	...
	JSB	G^EXE$INSTIMQ		; Insert element on timer queue
	ENBINT				; Restore IPL
	RSB

	.SBTTL	SETUP_MODE - SETUP THE TRANSMIT BUFFER TO INIT QNA
;++
; SETUP_MODE - SETUP THE TRANSMIT BUFFER TO INIT QNA
;
; Functional description:
;
; This routine initializes the TRANSMIT buffer the sets up the QNA operating
; mode.
;
; Inputs:
;
;	R3 = IRP address
;	R4 = CDB address
;	R5 = UCB address
;
;	IPL = FIPL
;
; Outputs:
;
;	R0 = status of request
;
;	R1,R2 are destroyed
;--
SETUP_ERR:				; Setup error
	MOVZWL	#SS$_INSFMEM,R0		; Set error return
	RSB				; Return to caller

SETUP_MODE:
	PUSHL	R3			; Save R3
	MOVZWL	#CXB$C_HEADER+INIT_C_BUFSIZE,R1 ; Size of init buffer
	JSB	G^EXE$ALONONPAGED	; Allocate the SETUP Transmit buffer
	POPL	R3			; Restore R3
	BLBC	R0,SETUP_ERR		; Exit if error
	PUSHR	#^M<R2,R3,R4,R5>	; Save registers
	MOVC5	#0,(R2),#-1,R1,(R2)	; Fill structure with BROADCAST!
	POPR	#^M<R2,R3,R4,R5>	; Restore registers
	;
	; Initialize buffer to look like a CXB
	;
	MOVL	R2,IRP$L_XQ_SETUP(R3)	; Save address of setup buffer
	ASSUME	CXB$B_TYPE EQ CXB$W_SIZE+2
	ASSUME	CXB$B_CODE EQ CXB$B_TYPE+1
	MOVL	#<DYN$C_CXB@16>!-	; Set size and type of structure
		CXB$C_HEADER+INIT_C_BUFSIZE,-
		CXB$W_SIZE(R2)
	MOVW	#INIT_C_BUFSIZE,CXB$W_BCNT(R2) ; Set size of transfer
	;
	; Initialize QNA mode word
	;
	ASSUME	NMA$C_STATE_ON EQ 0
	ASSUME	NMA$C_STATE_OFF EQ 1
	CLRW	CDB_W_MODE(R4)		; Init mode word
	BLBS	CDB_B_PRM(R4),10$	; Br if promiscuous state is OFF
	BISW	#CDB_MOD_M_PROM,-	; Else, enable promiscuous mode
		CDB_W_MODE(R4)		;
10$:	BLBS	CDB_B_MLT(R4),20$	; Br if multicast state is OFF
	BISW	#CDB_MOD_M_MULTI,-	; Else, enable all MULTICASTS
		CDB_W_MODE(R4)		;
20$:	BISW	CDB_W_MODE(R4),CXB$W_BCNT(R2) ; Set mode bits
	MOVW	#CXB$T_T_DATA,CXB$W_BOFF(R2) ; Set offset to start of data
	MOVL	R3,CXB$L_T_IRP(R2)	; Save IRP address in CXB
	;
	; Initialize physical address
	;
	MOVAB	CDB_G_PHA(R4),R0	; Point to Physical Address
	MOVAB	CXB$T_T_DATA+1(R2),R1	; Point to setup buffer (skip 1st col)
	MOVB	(R0)+,(R1)		; Stuff the physical address
	MOVB	(R0)+,8(R1)		;	...
	MOVB	(R0)+,16(R1)		;	...
	MOVB	(R0)+,24(R1)		;	...
	MOVB	(R0)+,32(R1)		;	...
	MOVB	(R0)+,40(R1)		;	...
	;
	; Initialize multicast addresses
	;
	PUSHQ	R2			; Save setup buffer, IRP address
	MOVZBL	CDB_B_MULTI(R4),R2	; Get number of multicast addresses
	BEQL	80$			; Br if none
	CMPB	#12,R2			; Is count okay?
	BGEQU	30$			; Br if yes
	BUG_CHECK NOBUFPCKT,FATAL	; Else, error

30$:	MOVZBL	#6,R3			; Only 6 slots left in first half of
					;  setup buffer
	MOVAB	CDB_G_MULTI(R4),R0	; Point to multicast address list
	BRB	50$			; Start with first half
	;
	; Check if first half of setup buffer is full
	;
40$:	SOBGTR	R3,50$			; Br if first half of buffer still open
	ADDL	#64-7,R1		; Skip to second half of buffer
	MOVZBL	#6,R3			; Reset count for second half
					; Leave last address as BROADCAST
	;
	; Store multicast addresses
	;
50$:	INCL	R1			; Skip to next column
	MOVB	(R0)+,(R1)		; Store multicast address
	MOVB	(R0)+,8(R1)		;	...
	MOVB	(R0)+,16(R1)		;	...
	MOVB	(R0)+,24(R1)		;	...
	MOVB	(R0)+,32(R1)		;	...
	MOVB	(R0)+,40(R1)		;	...
	SOBGTR	R2,40$			; Br if more

80$:	POPQ	R2			; Restore setup buffer, IRP address
	MOVZBL	#SS$_NORMAL,R0		; Return success
	JSB	@(SP)+			; Call back caller as co-routine
	INSQUE	(R2),@CDB_Q_XMTREQ+4(R4); Insert request on xmit queue
	SETBIT	#CDB_STS_V_SETUP,-	; Indicate that SETUP is in progress
		CDB_B_STS(R4)		;
	BRW	XMT_ALT_START		; Startup the XMIT process


	.SBTTL	FILLRCVLIST - FILL RECEIVE BUFFER LIST
;++
; FILLRCVLIST - FILL RECEIVE BUFFER LIST
;
; Functional description:
;
; This routine fills the receive buffer list up to the quota allocated
; at unit initialization.  It also gives any receive buffers allocated
; to the receiver.
;
; Inputs:
;
;	R2 = Buffer Address (ADDRCVLIST ONLY)
;	R4 = CDB address
; 
;	IPL = FIPL
;
; Outputs:
;
;	R0-R2 is destroyed.
;	All other registers are preserved.
;
;--
	.ENABL	LSB
FILLRCVLIST::				; Fill receive buffer list
	CLRL	R2			; No buffer here

ADDRCVLIST::				; Add a buffer to the receive list
	PUSHR	#^M<R3,R4,R5>		; Save registers
	MOVL	CDB_L_UCB0(R4),R5	; Get UCB address of unit #0
	BBC	#CDB_STS_V_RUN,-	; If BC device not running
		CDB_B_STS(R4),40$
10$:	CMPW	CDB_W_BSZ(R4),-		; Can new block be allocated ?
		CDB_W_QUOTA(R4)
	BGTRU	35$			; If GTRU then no, stop loop
	CLRL	R1			; Zero size 
	ADDW3	#CXB$C_HEADER+-		; Determine block size needed
		CXB$C_TRAILER,-		;
		CDB_W_BSZ(R4),R1	;
	TSTL	R2			; Buffer already allocated?
	BNEQ	20$			; Br if so
	JSB	G^EXE$ALONONPAGED	; Allocate the memory
	BLBC	R0,30$			; If failure then done
20$:	SUBW	CDB_W_BSZ(R4),-		; Subtract from quota
		CDB_W_QUOTA(R4)		;
	MOVW	R1,CXB$W_SIZE(R2)	; Insert size
25$:	MOVB	S^#DYN$C_CXB,-		; Insert type
		CXB$B_TYPE(R2)		;
	MOVB	#XQ_FC_V_RECV,CXB$B_XQ_FUNC(R2) ; Set function request
	INSQUE	(R2),CDB_Q_RCVBUF(R4)	; Insert block on list
	CLRL	R2			; No more buffers given
	BRB	10$			; Continue
;
; Buffer allocation failure
;
30$:	SETBIT	#XM$V_STS_BUFFAIL,-	; Set buffer alloc failure
		CDB_L_DEVDEPEND(R4)	;
	BRB	50$			; And give any receives to device

35$:	CLRBIT	#XM$V_STS_BUFFAIL,-	; Clear buffer alloc failure
		CDB_L_DEVDEPEND(R4)	;
	TSTL	R2			; Any buffer?
	BEQL	50$			; Br if not
	CMPB	CDB_B_AQUOTA(R4),-	; Can we use the additional quota?
		CDB_B_MQUOTA(R4)	;
	BGEQU	40$			; Br if not
	INCB	CDB_B_AQUOTA(R4)	; Else, increment the additional
	BRB	25$			; Use buffer, but don't let
					;  QUOTA go negative

40$:	MOVL	R2,R0			; Get address of buffer
	BEQL	50$			; Br if none
	JSB	G^COM$DRVDEALMEM	; Deallocate buffer

50$:	BSBB	START_RECEIVE		; Start the receives
	POPR	#^M<R3,R4,R5>		; Restore registers
	RSB
	.DSABL	LSB

	.SBTTL	START_RECEIVE - START ANY RECEIVE REQUESTS PENDING
;++
; START_RECEIVE - START ANY RECEIVE REQUESTS
;
; Functional description:
;
; This routine attemptes to start any receives that may be pending.  This
; involves dequeueing a free receive buffer, mapping it, and loading it's
; address and size into the device.
;
; Inputs:
;
;	R4 = CDB address
;	R5 = UCB address of unit # 0
;
;	IPL = FIPL
;
; Outputs:
;
;	R0-R3 are destroyed.
;	All other registers are preserved.
;
;--
 
START_RECEIVE::				; Start receive operation
	PUSHQ	R6			; Save R6, R7
	BBC	#CDB_STS_V_RUN,-	; Br if device is not running
		CDB_B_STS(R4),10$	;
	;
	; For u-VAX I, we will not use map registers.
	;
	CPUDISP	<<790,5$>,-
		 <780,5$>,-
		 <750,5$>,-
		 <730,5$>,-
		 <UV1,40$>>		; For u-VAX I, use alternate path

5$:	FFC	#0,#MAX_C_RCV-1,CDB_B_RCVMAP(R4),R7 ; Get a free mapping slot
	BEQL	10$			; Br if none - just exit
	REMQUE	@CDB_Q_RCVBUF(R4),R3	; Get a free buffer
	BVC	20$			; Br if buffer found
10$:	POPQ	R6			; Restore R6, R7
	RSB				; Return to caller
;
; Mark slot in use and create buffer address/character count image
; in receive buffer and load UNIBUS adapter map registers.
;
20$:	SETBIT	R7,CDB_B_RCVMAP(R4)	; Mark slot in use
	MOVB	R7,CXB$B_XQ_SLOT(R3)	; Save mapping slot index
	MOVL	UCB$L_CRB(R5),R2	; Get CRB address
;
; Find next ring entry and insert data
;
	MOVZBL	CDB_B_NEXTRCV(R4),R6	; Get next ring entry
	INCB	CDB_B_NEXTRCV(R4)	; Bump ring pointer
	BICB	#^C<MAX_C_RCV-1>,-	; Modulo rcv ring size
		 CDB_B_NEXTRCV(R4)	;
	MOVB	R6,CXB$B_XQ_RING(R3)	; Save ring entry number
	MOVL	CDB_L_RRINGVA(R4)[R6],R6; Get virtual address of ring entry
	CLRW	RCV_W_FLAG(R6)		; Zero the FLAG word
	MOVW	#RCV_STS_M_LAST,-	; Init the STATUS word
		RCV_W_STS(R6)		;
	PUSHQ	R3			; Save IRP, CDB address
;
; The QNA's receive buffer size must be a multiple of 2
;
	ASSUME	<XQ_C_HEADER+XQ_C_CNTSIZ & 1 > EQ 0
	ADDW3	#XQ_C_HEADER+XQ_C_CNTSIZ,- ; Calculate message length
		CDB_W_BSZ(R4),R0	;	...
	ASHL	#-1,R0,R0		; Convert byte count to WORD count
	MNEGW	R0,RCV_W_LEN(R6)	; Store length (2's complement)
	MOVAB	CXB$T_R_DATA(R3),R1	; Get receive buffer data addr
	MOVW	R1,RCV_W_ADDR(R6)	; Set BA0-BA8
	MOVAL	CDB_L_RCVMAP(R4)[R7],R7	; Get mapping info slot address
	INSV	(R7),#9,#7,RCV_W_ADDR(R6) ; Set BA9-BA15 from map reg
	EXTZV	#7,#6,(R7),R0		; Get BA16-BA21 also
	MOVW	R0,RCV_W_ADDRHI(R6)	; Set BA16-BA21 & zero descriptor bits
	MOVW	#1,RCV_W_LENB(R6)	; Set low byte not equal to high byte
	CLRL	R4			; Use direct data path for rcvs
	ASSUME	VEC$B_NUMREG EQ VEC$W_MAPREG+2
	MOVZBL	2(R7),R2		; Set number of map registers
	MOVZWL	(R7),R3			; Set first map register number
	JSB	G^IOC$LOADUBAMAPN	; Load the map registers
	POPQ	R3			; Restore IRP, CDB address
;
; Disable interrupts and queue request to input queue
;
	DSBINT	UCB$B_DIPL(R5)		; Disable interrupts
	BISW	#RCV_DSC_M_VALID,-	; Set descriptor bits
		 XMT_W_ADDRHI(R6)	;  "VALID" buffer address
	INCB	CDB_B_RCVCNT(R4)	; Tally one more receive in progress
	INSQUE	(R3),@CDB_Q_INPUT+4(R4)	; Insert receive buffer on
					;   input queue
	BNEQ	30$			; Br if not first entry on queue
	BSBW	LOAD_PORT		; Request port and give request to QNA
30$:	ENBINT				; Re-enable interrupts
	BRW	5$			; Let's try it again


40$:	;*******************
	; For u-VAX I, only.
	;*******************

	ASSUME	MAX_C_RCV LE 8
	ASSUME	MAX_C_RCVUV1 LT MAX_C_RCV
	FFC	#0,#MAX_C_RCVUV1,CDB_B_RCVMAP(R4),R7 ; Get a free mapping slot
	BEQL	50$			; Br if none - just exit
	REMQUE	@CDB_Q_RCVBUF(R4),R3	; Get a free buffer
	BVC	60$			; Br if buffer found
50$:	POPQ	R6			; Restore R6, R7
	RSB				; Return to caller
;
; Mark slot in use and create buffer address/character count image
; in receive buffer and load UNIBUS adapter map registers.
;
60$:	SETBIT	R7,CDB_B_RCVMAP(R4)	; Mark slot in use
	MOVB	R7,CXB$B_XQ_SLOT(R3)	; Save mapping slot index
;
; Find next ring entry and insert data
;
	MOVZBL	CDB_B_NEXTRCV(R4),R6	; Get next ring entry
	INCB	CDB_B_NEXTRCV(R4)	; Bump ring pointer
	BICB	#^C<MAX_C_RCV-1>,-	; Modulo rcv ring size
		 CDB_B_NEXTRCV(R4)	;
	MOVB	R6,CXB$B_XQ_RING(R3)	; Save ring entry number
	MOVL	CDB_L_RRINGVA(R4)[R6],R6; Get virtual address of ring entry
	CLRW	RCV_W_FLAG(R6)		; Zero the FLAG word
	MOVW	#RCV_STS_M_LAST,-	; Init the STATUS word
		RCV_W_STS(R6)		;
;
; The QNA's receive buffer size must be a multiple of 2
;
	ASSUME	<XQ_C_HEADER+XQ_C_CNTSIZ & 1 > EQ 0
	ADDW3	#XQ_C_HEADER+XQ_C_CNTSIZ,- ; Calculate message length
		CDB_W_BSZ(R4),R0	;	...
	ASHL	#-1,R0,R0		; Convert byte count to WORD count
	MNEGW	R0,RCV_W_LEN(R6)	; Store length (2's complement)
	MOVL	CDB_L_RCV_PA(R4)[R7],R0	; Get receive buffer physical address
	MOVW	R0,RCV_W_ADDR(R6)	; Set BA00-BA15
	ASHL	#-16,R0,R0		; Shift down high byte of address
	MOVW	R0,RCV_W_ADDRHI(R6)	; Set BA16-BA21 & zero descriptor bits
	MOVW	#1,RCV_W_LENB(R6)	; Set low byte not equal to high byte
;
; Disable interrupts and queue request to input queue
;
	DSBINT	UCB$B_DIPL(R5)		; Disable interrupts
	BISW	#RCV_DSC_M_VALID,-	; Set descriptor bits
		 XMT_W_ADDRHI(R6)	;  "VALID" buffer address
	INCB	CDB_B_RCVCNT(R4)	; Tally one more receive in progress
	INSQUE	(R3),@CDB_Q_INPUT+4(R4)	; Insert receive buffer on
					;   input queue
	BNEQ	90$			; Br if not first entry on queue
	BSBB	LOAD_PORT		; Request port and give request to QNA
90$:	ENBINT				; Re-enable interrupts
	BRW	40$			; Let's try it again

	.SBTTL	LOAD_PORT - LOAD CSR'S WITH COMMAND REQUEST
;++
; LOAD_PORT - LOAD CSR'S WITH COMMAND REQUEST
;
; Functional description:
;
; This routine loads the CSR's and PCBB with a command to process.
;
; Inputs:
;
;	R4 = CDB address
;	R5 = UCB address
;
;	IPL = DIPL
;
; Outputs:
;
;	R4,R5 are preserved.
;
;	R0-R3 may be destroyed.
;
;--
LOAD_PORT::				; Load port command
	MOVL	UCB$L_CRB(R5),R2	; Get CRB address
	ASSUME	IDB$L_CSR EQ 0
	MOVL	@CRB$L_INTD+VEC$L_IDB(R2),R2 ; Get CSR address
	REMQUE	@CDB_Q_INPUT(R4),R3	; Get next CXB
	BVC	20$			; Br if got one
10$:	RSB				; Return to caller

20$:	CMPB	CXB$B_TYPE(R3),#DYN$C_CXB ; Is this a CXB?
	BEQL	30$			; Br if yes
	BUG_CHECK NOBUFPCKT,FATAL	; Fatal error - what is it???
;
; Dispatch of CXB request
;
30$:	$DISPATCH	CXB$B_XQ_FUNC(R3),TYPE=B,- ; Dispatch on function request
	<-	;function	action
		<XQ_FC_V_XMIT	40$>,-	; XMIT requested
		<XQ_FC_V_INIT	40$>,-	; INIT QNA requested
		<XQ_FC_V_STOP	40$>,-	; STOP QNA requested
		<XQ_FC_V_CHMODE	40$>,-	; Change mode requested
		<XQ_FC_V_RECV	60$>,-	; RECV requested
	>

	BUG_CHECK NOBUFPCKT,FATAL	; Fatal error - not a valid IRP

;
; XMIT request
;
;   If the QNA has invalidated the TRANSMIT RING, then we must reset the
;   starting address of the ring list to point to the current entry.
;
40$:	BITW	#XQ_CSR_M_XMTINV,CSR(R2); Is the transmit ring still valid?
	BEQL	50$			; Br if yes, all done
	MOVZBL	CXB$B_XQ_RING(R3),R1	; Else, get ring entry number
	MOVL	CDB_L_XRINGPA(R4)[R1],R1; Get the buffer mapping value
	MOVW	R1,XMTLIST(R2)		; Set address of transmit list entry
	ASHL	#-16,R1,R1		; Shift down high order address bits
	MOVB	R1,XMTLST1(R2)		; 	...
50$:	INSQUE	(R3),@CDB_Q_XMTPND+4(R4) ; Insert CXB on WAITING queue
;;&&	BITW	#XQ_CSR_M_CAR,CSR(R2)	; Is carrier present?
;;&&	BEQL	55$			; Br if not, okay - else
;;&&	INCC	CDB_L_BIDCTR(R4)	; Count blocks sent - initially deferred
55$:	MOVB	#XMT_TIM,CDB_B_TIM_XMT(R4) ; Start xmit timer
	RSB				; Return to caller
;
; RECV request
;
;   If the QNA has invalidated the RECEIVE RING, then we must reset the
;   starting address of the ring list to point to the current entry.
;
60$:	BITW	#XQ_CSR_M_RCVINV,CSR(R2); Is the receive ring still valid?
	BEQL	70$			; Br if yes, all done
	MOVZBL	CXB$B_XQ_RING(R3),R1	; Else, get ring entry number
	MOVL	CDB_L_RRINGPA(R4)[R1],R1; Get the buffer mapping value
	MOVW	R1,RCVLIST(R2)		; Set address of receive list entry
	ASHL	#-16,R1,R1		; Shift down high order address bits
	MOVB	R1,RCVLST1(R2)		; 	...
70$:	INSQUE	(R3),@CDB_Q_RCVPND+4(R4) ; Insert CXB on WAITING queue
	RSB				; Return to caller


	.SBTTL	QNA_INTR - QNA INTERRUPT SERVICE ROUTINE
;++
; QNA_INTR - QNA INTERRUPT SERVICE ROUTINE
;
; Functional description:
;
; This routine services the interrupts generated by the QNA for completion
; of requests.
;
; Inputs:
;
;	00(SP) = ADDRESS OF UNIT IDB ADDRESS
;
;	R0,R1,R2,R3,R4,R5 ARE AT 04(SP) TO 1C(SP)
;
;
;	IPL = DIPL
;
; Outputs:
;
;	THE INTERRUPT IS DISMISSED
;
; IMPLICIT OUTPUTS:
;
;	A Fork process is started to check ring entries.
;--
QNA_INTR::				; DEQNA done interrupt
	MOVL	@(SP)+,R4		; Get IDB address
	MOVL	IDB$L_UCBLST(R4),R5	; Get first UCB address
	ASSUME	IDB$L_CSR EQ 0
	MOVL	(R4),R2			; Get CSR address
	MOVL	UCB$L_CRB(R5),R4	; Get CRB address
	MOVL	CRB$L_AUXSTRUC(R4),R4	; Get CDB address
	BEQL	INTEXIT			; Br if CDB not allocated
	BBC	#CDB_STS_V_INITED,-	; Br if NOT inited
		CDB_B_STS(R4),INTEXIT	;
	BBS	#CDB_STS_V_ERR,- 	; Br if there was an error
		CDB_B_STS(R4),INTEXIT	;
	MOVZWL	CSR(R2),R3		; Fetch the CSR contents
;
; The interrupt bits can only be cleared by writing one's into them, therefore
; we will write one's into all bits which already have one's.
;
	MOVW	R3,CSR(R2)		; Release interrupt interlocks
	BITW	#XQ_CSR_M_XMTINT!-	; Is this a valid interrupt?
		 XQ_CSR_M_RCVINT,R3	;
	BEQL	20$			; Br if no, indicate error
;
; We will now check for any errors.
;
10$:	BBC	#XQ_CSR_V_NXM,R3,30$	; Br if no errors
20$:	SETBIT	#XQ_CSR_V_ERR,R3	; Set fatal error indicator
	SETBIT	#CDB_STS_V_ERR,-	; Ignore futher interrupts
		CDB_B_STS(R4)		;
30$:	BSBB	SCHED_FORK		; Schedule a fork process
	
INTEXIT:				; Exit interrupt
	MOVQ	(SP)+,R0		; Restore Regs
	MOVQ	(SP)+,R2
	MOVQ	(SP)+,R4
	REI				; Dismiss the interrupt

	.SBTTL	SCHED_FORK - SCHEDULE THE FORK PROCESS
	.SBTTL	SCHED_FORKC - SCHEDULE THE FORK PROCESS WITH R3 CLEAR
;++
; SCHED_FORK - Schedule the fork process
; SCHED_FORKC - Schedule the fork process with R3 clear
;
; Functional description:
;
; This routine is called to schedule the error and I/O completion fork process.
; The last controller CSR values are saved for examination.  If the
; fork process is already pending, only the last CSR values are saved if there
; was an error.
;
; Inputs:
;
;	R3 = Last CSR value
;	R4 = CDB address
;
;	IPL = DIPL or higher
;
; Outputs:
;
;	R3 is cleared if SCHED_FORKC entry.
;	R4 is destroyed.
;	R5 = CDB address
;
; If XQ_CSR_V_ERR is set in CSR, then the following is returned:
;
;	CDB_L_CSR(R4) = new CSR value
;
;--
 
SCHED_FORKC::				; Schedule fork process, clr R3
	CLRL	R3			; No device error
SCHED_FORK::				; Schedule fork process
	BBSS	#CDB_STS_V_FORK_PEND,CDB_B_STS(R4),10$ ; Br if fork pending
	ASSUME	CDB_L_FQFL EQ 0
	MOVL	R4,R5			; Get CDB fork block address
	PUSHAB	B^FORK_PROC		; Else, set address of fork process
	JMP	G^EXE$FORK		; Schedule the fork and return
 
10$:	BBC	#XQ_CSR_V_ERR,R3,20$ ; Br if not error
	MOVL	R3,CDB_L_CSR(R4)	; Save last CSR value
20$:	RSB				; Return to caller

	.SBTTL	FORK_PROC - Error and completion fork process handling
;++
; FORK_PROC - Error and completion fork processing
;
; Functional description:
;
; This routine is called as a fork process to handle errors and all completions
; pending.
;
; Inputs:
;
;	R3 = Last CSR value
;	R4 = CDB address
;	R5 = CDB address
;
;	IPL = FIPL
;
; Outputs:
;
;	R0-R5 are destroyed.
;
;--
	.WORD	TIMEOUT-.		; Offset to timeout routine
FORK_PROC::				; Error/completion fork process
	CLRBIT	#CDB_STS_V_FORK_PEND,CDB_B_STS(R4) ; Clear fork process flag
	BBC	#XQ_CSR_V_ERR,R3,10$	; Br if not an error
	SETBIT	#XM$V_ERR_FATAL,CDB_L_DEVDEPEND(R4) ; Indicate fatal error
	MOVB	R3,CDB_L_DEVDEPEND+3(R4) ; Save low byte of CSR
	MOVL	CDB_L_UCB0(R4),R5	; Get UCB #0 address
	INCW	UCB$W_ERRCNT(R5)	; Bump error counter
	BRW	SHUTDOWN_QNA		; Shutdown the QNA device

3$:	;
	; Process receive errors
	;
	BSBW	RCV_ERROR		; Process receive error
	BRW	25$			; Abort messages

7$:	BRW	60$			; Complete transmits
;
; Complete any TRANSMITS or RECEIVES
;
10$:	PUSHQ	R6			; Save R6, R7

15$:	BSBW	ASSEM_PKTS		; Assemble receive packets
	BLBC	R0,7$			; Br on error or none
	INCC	CDB_L_DBRCTR(R4)	; Count blocks received
	MOVZWL	CXB$W_BCNT(R2),R0	; Get byte count
	CNTR	R0,CDB_L_BRCCTR(R4),L	; Count bytes received
	BLBC	CXB$G_R_DEST(R2),17$	; Br if not multicast
	INCC	CDB_L_MBLCTR(R4)	; Count multicast blocks received
	CNTR	R0,CDB_L_MBYCTR(R4),L	; Count multicast bytes received
17$:	BBS	#RCV_STS_V_ERR,-	; Br if FATAL receive error
		 CXB$W_R_STS(R2),3$	;
	BBC	#RCV_STS_V_ESETUP,-	; Br if NOT an ESETUP receive
		 CXB$W_R_STS(R2),20$	;
	BBSC	#CDB_STS_V_SETUP,-	; Br if SETUP in progress and clear it
		 CDB_B_STS(R4),25$	;
20$:	MOVZWL	CXB$W_R_PTYPE(R2),R1	; Pick up protocol type from buffer
	
	.IF DF	POINT
	CMPW	R1,#XQ_C_STPRO		;% Is this the startup protocol?
	BNEQ	21$			;% Br if not
	BSBW	FIND_POINT_UCB		;% Find the point to point user!
	BLBC	R0,22$			;% Br if failure, assume regular user
	BRB	25$			;% Else done with MSG block
	.ENDC

21$:	CMPW	R1,#NI_CTR_PROTYP	; Is this the Remote Console protocol?
	BNEQ	22$			; Br if not
	CMPB	#NI_CTR_READ,-		; Is this a read counters request?
		CXB$T_R_USERDAT(R2)	;
	BNEQ	22$			; Br if not
	BSBW	MOP_CTR_REQUEST		; Else, process the request for counters
	BRB	15$
22$:	BSBW	MATCH_PROTYP		; Try to match protocol type
	BLBS	R0,27$			; Br if success
23$:	MOVL	CDB_L_PRMUSER(R4),R5	; Try to get the PROMISCUOUS user
	BNEQ	34$			; Br if one found
	INCC	CDB_W_UFDCTR(R4),W	; Else, no such protocol type
25$:	PUSHL	CXB$L_LINK(R2)		; Save next in chain
	BSBW	ADDRCVLIST		; Add buffer to receive list
	POPL	R2			; Restore next buffer
	BNEQ	25$			; Loop if more
	BRW	15$			; Look for next completed buffer
;
; If there is a promiscuous user, then copy the packet for the promiscuous
; user. There is a chance that the data received is not for the protocol
; type user just found, we will have to re-verify that the destination
; address is for our physical address. This is because if we are running
; promiscuous mode, then we will receive all packets, including those not
; intended for the protocol user.
;
27$:	ASSUME	NMA$C_STATE_ON EQ 0
	ASSUME	NMA$C_STATE_OFF EQ 1
	BLBS	CDB_B_PRM(R4),32$	; Br if hardware is NOT in promiscuous mode
	BLBS	CXB$G_R_DEST(R2),30$	; Br if multicast address, this
					;  will be checked later.
	CMPL	CXB$G_R_DEST(R2),-	; Is this packet for this protocol
		CDB_G_PHYADR(R4)	;  user?
	BNEQ	23$			; Br if not, don't copy packet
	CMPW	CXB$G_R_DEST+4(R2),-	; Are we sure?
		CDB_G_PHYADR+4(R4)	;
	BNEQ	23$			; Br if no, dont't copy packet
;
;	Copy the packet for the promiscuous user
;
30$:	PUSHL	R5			; Save user's UCB address
	MOVL	CDB_L_PRMUSER(R4),R5	; Get PROMISCUOUS user's UCB address
	BEQL	31$			; Br if none
	BSBW	COPY_RCV		; Give buffer to promiscous user
31$:	POPL	R5			; Restore user's UCB address
;
; If multicast address is the destination, then make sure that multicast
; address is in multicast address list for this unit.
;
32$:	BLBC	CXB$G_R_DEST(R2),34$	; Br if physical address
	BSBW	MATCH_MULTI		; Try to match multicast address
	BLBS	R0,34$			; Br if success
33$:	INCC	UCB$W_XQ_MNECTR(R5),W	; Else, multicast not enabled
	INCC	CDB_W_UFDCTR(R4),W	; Also added in unrecognized frame dest
	BRB	25$			; Release buffer
;
; If the user did not request data chaining, then check to make sure he gets
; no chained buffers... may be user of Internal IRPs!
;
34$:	TSTL	CXB$L_LINK(R2)		; Is this a chained message?
	BEQL	36$			; Br if not
	ASSUME	NMA$C_STATE_ON EQ 0
	ASSUME	NMA$C_STATE_OFF EQ 1
	BLBS	UCB$B_XQ_DCH(R5),45$	; Br if chaining not allowed
;
; If there is a pending receive I/O request, complete it.
; Otherwise, queue the buffer and, if enabled, deliver attention AST.
;
36$:	MOVZWL	UCB$W_DEVBUFSIZ(R5),R0	; Get size of user's max buffer
	;&&
	;&& the following code could cause problems for an altstart user,
	;&& if the altstart user happens to receive a buffer which is 1 or 2
	;&& bytes longer than they are capable of handling. Only if the
	;&& protocol is not "padded", because the size check allows for
	;&& 2 bytes of count to be subtracted from the message size.
	;&&
;
; Check the size of the received buffer against what the user protocol can
; handle.
;
	SUBW3	#XQ_C_CNTSIZ,-		; Get the size of the receive buffer
		CXB$W_BCNT(R2),R1	;  minus the count word
	CMPW	R1,R0			; Is the received size larger than
					;  what the user can handle?
	BGTRU	45$			; Br if yes, error
	TSTL	UCB$L_XQ_FFI(R5)	; FAST Interface supported?
	BEQL	37$			; Br if not, standard interface
	BSBW	FINISH_RCV_FFI		; Else, complete FAST receive
	BRW	15$			; Look for more completions

37$:	MOVAB	UCB$Q_XQ_RCVREQ(R5),R1	; Assume that we are running in
					;  exclusive mode
	BBC	#UCB$V_XQ_SHARE,-	; Br if UCB is NOT in SHARED mode
		 UCB$W_DEVSTS(R5),38$	;
;
; If running in SHARED mode, then we must use the listheads in the SHR
; data structure. We will use the source address from the received message
; to match against the SHR structure destination address.
;
	BSBW	MATCH_SRC		; Check for a match on source address
	BNEQ	33$			; Br if no shared user found
;
;	SHARED user found, use listheads in SHR data structure.
;
	MOVAB	SHR_Q_RCVREQ(R1),R1	; Get address of waiting IRPs
38$:	REMQUE	@(R1),R3		; Remove waiting IRP
	BVS	40$			; Br if none - queue for later
	SUBW	R0,UCB$W_XQ_QUOTA(R5)	; Else, lessen quota so it can be
					;..increased on completion
	BSBW	FINISH_RCV_IO		; And finish the I/O
	BRW	15$			; Look for next completion
;
; Check buffer quota and queue if quota okay.
;
40$:	SUBW	R0,UCB$W_XQ_QUOTA(R5)	; Decrement the quota
	BGEQU	50$			; Br if we can buffer request
	ADDW	R0,UCB$W_XQ_QUOTA(R5)	; Replace quota
45$:	INCC	UCB$W_XQ_UBUCTR(R5),W	; Else, no buffer available
	INCC	CDB_W_UBUCTR(R4),W	; ...don't forget CDB counter
	BRW	25$			; Return buffer

50$:	ASSUME	UCB$Q_XQ_RCVREQ EQ UCB$Q_XQ_RCVMSG+8
	ASSUME	SHR_Q_RCVREQ EQ SHR_Q_RCVMSG+8
	SUBL	#4,R1			; Backup to backward link pointer
					;  of the message queue
	INSQUE	(R2),@(R1)		; Queue received msg for later
	BSBW	FILLRCVLIST		; Try to fill the receive list
	BSBW	POKE_USER		; Deliver ASTs
	BRW	15$			; Look for more completions
;
; NOW - scan the xmit ring entries
;
60$:	TSTB	CDB_B_XMTCNT(R4)	; Any xmits in progress?
	BNEQ	70$			; Br if yes - look for any completed
65$:	BRW	190$			; Else, all done

70$:	MOVZBL	CDB_B_LASTXMT(R4),R6	; Get last ring entry completed
	MOVL	CDB_L_XRINGVA(R4)[R6],R6; Get address of last ring entry
	BBC	#XMT_STS_V_LAST,-	; Br if done
		 XMT_W_STS(R6),75$	;
	BBS	#XMT_STS_V_ERR,-	; Br if not done
		 XMT_W_STS(R6),65$	;  ..leave
75$:	TSTW	XMT_W_TDR(R6)		; Are we really done?
	BEQL	65$			; Br if not!
	REMQUE	@CDB_Q_XMTPND(R4),R3	; Get next XMIT CXB
	BVS	65$			; Br if none there (yet)
	BNEQ	77$			; Br if more entries on queue
	CLRB	CDB_B_TIM_XMT(R4)	; Stop the xmit timer
77$:	DECB	CDB_B_XMTCNT(R4)	; One less transmit pending
	INCB	CDB_B_LASTXMT(R4)	; Bump ring pointer
	BICB	#^C<MAX_C_XMT-1>,-	; Modulo receive ring entry size
		CDB_B_LASTXMT(R4)	;	...
;
; Transmit complete
;
	CLRBIT	XMT_DSC_V_VALID,-	; Indicate that buffer is not valid
		 XMT_W_ADDRHI(R6)	;
	MOVB	XMT_W_FLAG+1(R6),-	; Save diagnostic return info
		 CDB_B_DIAG1(R4)	;
	MOVW	XMT_W_STS(R6),-		; Save diagnostic return info
		 CDB_W_DIAG2(R4)	;
	MOVL	CXB$L_T_UCB(R3),R5	; Get (presumed) UCB address
	ASSUME	CXB$L_T_UCB  EQ  CXB$L_T_IRP
	BBSC	#0,R5,80$		; Fix up address & BR if UCB address
	MOVL	IRP$L_UCB(R5),R5	; Else, get real UCB address

80$:	MOVZBL	CXB$B_XQ_SLOT(R3),R2	; Get mapping slot number used
	CLRBIT	R2,CDB_B_XMTMAP(R4)	; Clear in use flag

	CPUDISP	<<790,90$>,-
		 <780,90$>,-
		 <750,90$>,-
		 <730,90$>,-
		 <UV1,100$>>		; Skip map registers if u-VAX I

90$:	MOVL	UCB$L_CRB(R5),R1	; Get CRB address
	ASSUME	VEC$B_NUMREG EQ VEC$W_MAPREG+2
	ASSUME	VEC$B_DATAPATH EQ VEC$B_NUMREG+1
	MOVL	CDB_L_XMTMAP(R4)[R2],-	; Setup map register data
		 CRB$L_INTD+VEC$W_MAPREG(R1) ;	and data path number
	TSTB	R2			; Was it the pre-allocated one?
	BEQL	95$			; Br if yes - clear data path number
	MNEGL	#1,CDB_L_XMTMAP(R4)[R2]	; Indicate map register not allocated
	RELMPR				; Release the map registers
	BRB	100$			; Complete the request

95$:	ASSUME	VEC$B_DATAPATH EQ VEC$W_MAPREG+3
	CLRB	CDB_L_XMTMAP+3(R4)	; Clear data path number used
100$:	MOVZWL	CXB$W_BCNT(R3),R0	; Get byte count of message
	MOVL	R0,R1			; Copy length for accounting
	;
	; Perform accounting for the QNA
	;
	INCC	CDB_L_DBSCTR(R4)	; Count blocks sent
	CNTR	R1,CDB_L_BSNCTR(R4),L	; Count bytes sent
	ASHL	#16,R0,R0		; Move to high word
	MOVW	S^#SS$_NORMAL,R0	; Set completion status
	BBSC	#XMT_DSC_V_SETUP,-	; Br if SETUP operation
		XMT_W_ADDRHI(R6),120$	;
	BBC	#XMT_STS_V_ERR,XMT_W_STS(R6),110$ ; Br if not a FATAL error
	BSBW	XMT_ERROR		; Process XMIT error
	BRB	120$			; Skip the accounting
;
; Perform accounting on a per protocol type basis and on unit.
;
110$:	CNTR	R1,UCB$L_XQ_SBYCTR(R5),L ; Bump the bytes sent counter
	INCC	UCB$L_XQ_SBLCTR(R5),L	; Bump the blocks sent counter
	EXTZV	#XMT_STS_V_COL,-	; Get number of collisions
		#XMT_STS_S_COL,XMT_W_STS(R6),R1
	BEQL	120$			; Br if none
	DECB	R1			; More than one?
	BEQL	115$			; Br if only one
	INCC	CDB_L_BSMCTR(R4)	; Count blocks sent with multiple errors
	BRB	120$			; Continue
115$:	INCC	CDB_L_BS1CTR(R4)	; Count blocks sent with 1 error

120$:	BLBS	CXB$L_T_IRP(R3),130$	; BR if FAST interface CXB
	MOVL	CXB$L_T_IRP(R3),R3	; Else, get IRP address
	PUSHL	R0			; Save status return
	MOVL	IRP$L_XQ_SETUP(R3),R0	; Is there a SETUP mode buffer
	BEQL	125$			; Br if none
	JSB	G^COM$DRVDEALMEM	; Deallocate the buffer
125$:	POPL	R0			; Restore status return
	BSBW	IO_DONE			; Finish the I/O request
	BRB	170$			; Continue in common code
130$:	BSBW	FINISH_XMT_FFI		; Else, complete FFI XMIT
170$:	BSBW	XMT_ALT_START		; Start up any other transmits
	BRW	60$			; Look for next completion
	
190$:	POPQ	R6			; Restore R6, R7
	RSB


	.SBTTL	RCV_ERROR - Process receive errors
	.SBTTL	XMT_ERROR - Process transmit errors
;++
; RCV_ERROR - Process receive errors
;
; Functional description:
;
; This routine adjusts all appropriate counters and checks all errors.
;
; Inputs:
;	R2 = CXB address
;	R4 = CDB address
;
; Outputs:
;	none.
;
;--

RCV_ERROR:
	INCC	CDB_W_RFLCTR(R4),W	; Count receive failures
	BBC	#RCV_STS_V_CRCERR,-	; Br if not a CRC error
		CXB$W_R_STS(R2),20$	;
	SETBIT	#0,CDB_W_RFLMAP(R4)	; Indicate CRC error
20$:	BBC	#RCV_STS_V_FRAME,-	; Br if not a framing error
		CXB$W_R_STS(R2),40$	;
	SETBIT	#1,CDB_W_RFLMAP(R4)	; Indicate FRAME error
40$:	BBC	#RCV_STS_V_RUNT,-	; Br if not a RUNT packet
		CXB$W_R_STS(R2),90$	;
	SETBIT	#2,CDB_W_RFLMAP(R4)	; Indicate FRAME error
90$:	RSB


;++
; XMT_ERROR - Process transmit errors
;
; Functional description:
;
; This routine adjusts all appropriate counters and checks all errors.
;
; Inputs:
;	R4 = CDB address
;	R6 = Transmit ring entry address
;
; Outputs:
;	R0 = error code
;
;--

XMT_ERROR:
	INCC	CDB_W_SFLCTR(R4),W	; Count send failures
	MOVW	#SS$_COMMHARD,R0	; Assume No Carrier failure
	BBC	#XMT_STS_V_ABORT,-	; Br if NOT 16 retries failed
		XMT_W_STS(R6),20$ 
	MOVW	#SS$_DEVREQERR,R0	; Else, DEVREQERR error
	SETBIT	#0,CDB_W_SFLMAP(R4)	; Set bitmap
20$:	BBC	#XMT_STS_V_LCAR,-	; Br if NOT Loss of Carrier
		XMT_W_STS(R6),40$
	MOVW	#SS$_DISCONNECT,R0	; Else, DISCONNECT error
	SETBIT	#1,CDB_W_SFLMAP(R4)	; Set bitmap
40$:	BBC	#XMT_STS_V_FAIL,-	; Br if NOT Collision check failure
		XMT_W_STS(R6),60$
	MOVW	#SS$_DATACHECK,R0	; Else, DATACHECK error
	INCC	CDB_W_CDCCTR(R4),W	; Count separate counter
60$:	BBC	#XMT_STS_V_NOCAR,-	; Br if NOT Carrier failure
		XMT_W_STS(R6),90$	;
	SETBIT	#2,CDB_W_SFLMAP(R4)	; Set bitmap
90$:	RSB

	.SBTTL	 SUBROUTINES TO FIND SHR MATCH ON SOURCE ADDRESS
;++
; Functional description:
;
; Subroutine to find SHR data structure for user
;
; Inputs:
;	R2 = Receive CXB address
;	R5 = UCB address
;
; Outputs:
;	R1 = Address if SHR data structure if match
;	All other registers preserved.
;	Z-Bit set then match.
;	Z-Bit clear then no match.
;--

MATCH_SRC:				; Try to find shared user
	PUSHR	#^M<R0,R2>		; Save registers
;
; Try to find match among limited shared users of protocol type
;
	MOVAB	UCB$Q_XQ_SHARE(R5),R0	; Save address of listhead
	MOVL	R0,R1			; Copy listhead address
	ASSUME	SHR_L_QFL EQ 0
20$:	MOVL	(R1),R1			; Get next in list
	CMPL	R1,R0			; Back to start of list?
	BEQL	30$			; Br if yes - no source match
	BSBB	CHECK_SRC		; Check for match
	BNEQ	20$			; Br if none
	BRB	50$			; Return in success (Z-bit is set)
;
; No match on limited users - try to use default user
;
30$:	MOVL	UCB$L_XQ_DEFUSR(R5),R1	; Get address of default user
	BEQL	40$			; Br if no default user
	CLRL	R0			; Return success
40$:	MOVL	R0,R0			; Return success/failure indicator
50$:	POPR	#^M<R0,R2>		; Restore registers, don't reset Z-BIT
	RSB

;++
; Functional description:
;
; Subroutine to check if source address in message matches SHR address
;
; Inputs:
;	R1 = Address of SHR
;	R2 = Address of MSG buffer
;
; Outputs:
;	Z-Bit set then match.
;	Z-Bit clear then no match.
;--

CHECK_SRC:				; Check for match with SHR data base
	CMPL	CXB$G_R_SRC(R2),SHR_G_DEST(R1) ; Source address match?
	BNEQ	10$			; Br if no - try for next
	CMPW	CXB$G_R_SRC+4(R2),-	; Really match?
		 SHR_G_DEST+4(R1)	;	...
10$:	RSB				; Return to caller

	.SBTTL	COPY_RCV - Copy a receive buffer for the PROMISCUOUS user
;++
; COPY_RCV - Copy a receive buffer for the PROMISCUOUS user
;
; Functional description:
;
; This routine allocates a receive buffer in which to copy the a receive
; buffer for the PROMISCUOUS user.
;
;  Inputs:
;
;	R2 = Receive CXB address
;	R4 = CDB address
;	R5 = UCB address of PROMISCUOUS user
;	R6 = Address of receive ring entry
;
;	IPL = FIPL
;
;  Outputs:
;
;	R0,R1,R3 are destroyed.
;	All other registers are preserved.
;--
COPY_RCV:				; Copy the xmit buffer to rcv buffer
	PUSHL	R2			; Save address of original buffer
	CMPW	#1,CXB$W_R_NCHAIN(R2)	; Is there more than 1 in chain?
	BNEQ	80$			; Br if yes - we can only handle 1
	MOVZWL	CXB$W_BCNT(R2),R1	; Get size of buffer
	ADDL	#CXB$C_HEADER,R1	; Compute size of needed buffer
	JSB	G^EXE$ALONONPAGED	; Allocate a receive buffer
	BLBC	R0,80$			; Br if failure
	MOVL	(SP),R3			; Get address of original buffer
	PUSHR	#^M<R1,R2,R4,R5>	; Save registers
	MOVC3	R1,(R3),(R2)		; Copy everything to new buffer
	POPR	#^M<R1,R2,R4,R5>	; Save registers
	MOVW	R1,CXB$W_SIZE(R2)	; Reset size field
;
; If there is a pending receive I/O request, complete it.
; Otherwise, queue the buffer and, if enabled, deliver attention AST.
;
	MOVZWL	UCB$W_DEVBUFSIZ(R5),R1	; Get the user's buffer size
	REMQUE	@UCB$Q_XQ_RCVREQ(R5),R3	; Remove waiting IRP
	BVS	40$			; Br if none - queue for later
	SUBW	R1,UCB$W_XQ_QUOTA(R5)	; Else, lessen quota so it can be
					;..increased on completion
	BSBW	FINISH_RCV_IO		; And finish the I/O
	BRB	80$			; Look for next completion
;
; Return buffer to pool if user buffer failure
;
30$:	PUSHL	CXB$L_LINK(R2)		; Save next in chain
	MOVL	R2,R0			; Copy the buffer address
	JSB	G^COM$DRVDEALMEM	; DEALLOCATE the buffer
	POPL	R2			; Restore next buffer
	BNEQ	30$			; Loop if more
	BRB	80$			; Else, leave
;
; Check buffer quota and queue if quota okay.
;
40$:	SUBW	R1,UCB$W_XQ_QUOTA(R5)	; Decrement the quota
	BGEQU	50$			; Br if we can buffer request
	ADDW	R1,UCB$W_XQ_QUOTA(R5)	; Replace quota
	INCC	UCB$W_XQ_UBUCTR(R5),W	; Else, no buffer available
	INCC	CDB_W_UBUCTR(R4),W	; ...don't forget CDB counter
	BRB	30$			; Return buffer

50$:	INSQUE	(R2),@UCB$Q_XQ_RCVMSG+4(R5) ; Queue received msg for later
	BSBW	FILLRCVLIST		; Try to fill the receive list
	BSBW	POKE_USER		; Deliver ASTs
80$:	POPL	R2			; Restore R2
	RSB				; Return to caller

	.SBTTL	FINISH_XMT_FFI - Finish FAST interface transmit processing
;++
; FINISH_XMT_FFI - Finish FAST interface transmit processing
;
; Functional description:
;
; This routine completes a transmit CXB for a particular user of the fast
; interface.
;
;  Inputs:
;
;	R0 = Status of transmit request
;	R3 = transmit CXB address
;	R4 = CDB address
;	R5 = UCB address
;
;	IPL = FIPL
;
;  Outputs:
;
;	R0-R3 are destroyed.
;	All other registers are preserved.
;
;--
	ASSUME	IPL$_SYNCH EQ IPL$_XQ_FIPL
FINISH_XMT_FFI::			; Finish FAST interface transmit request
	PUSHL	R4			; Save R4
	MOVL	UCB$L_XQ_FFI(R5),R4	; Get FFI block address
	JSB	@FFI$L_XMIT_DONE(R4)	; Call back the user with CXB
	POPL	R4			; Restore R4
	RSB

	.SBTTL	FINISH_RCV_FFI - Finish FAST receive processing
;++
; FINISH_RCV_FFI - Finish FAST receive processing
;
; Functional description:
;
; This routine completes a receive CXB for a particular user of the fast
; interface.
;
;  Inputs:
;
;	R2 = receive CXB address
;	R4 = CDB address
;	R5 = UCB address
;
;	IPL = FIPL
;
;  Outputs:
;
;	R0-R3 are destroyed.
;	All other registers are preserved.
;
;--
	ASSUME	IPL$_SYNCH EQ IPL$_XQ_FIPL
FINISH_RCV_FFI::			; Finish FAST recieve request
	PUSHL	R4			; Save R4
	MOVL	R2,R3			; Copy CXB address
	MOVQ	CXB$G_R_SRC(R3),-	; Copy source address
		CXB$Q_STATION(R3)	;	...
	MOVW	#CXB$T_R_USERDAT,CXB$W_BOFF(R3) ; Set offset to received data
	ASSUME	NMA$C_STATE_ON EQ 0
	ASSUME	NMA$C_STATE_OFF EQ 1
	BLBS	UCB$B_XQ_PAD(R5),30$	; Br if padding is disabled
	MOVW	CXB$W_R_SIZE(R3),-	; Else, set real size of buffer
		CXB$W_BCNT(R3)
	ADDW	#XQ_C_CNTSIZ,CXB$W_BOFF(R3) ; Adjust offset
30$:	MOVL	CDB_L_DEVDEPEND(R4),R0	; Set controller bits
	BISL	UCB$L_DEVDEPEND(R5),R0	; Set status flags
	MOVL	UCB$L_XQ_FFI(R5),R4	; Get FFI block address
	JSB	@FFI$L_RECV_DONE(R4)	; Call back the user with CXB
	POPL	R4			; Restore R4
	MOVL	R3,R2			; Was buffer consumed?
	BEQL	90$			; Br if YES
	BSBW	ADDRCVLIST		; Else, add buffer to receive list
90$:	RSB

	.SBTTL	FINISH_RCV_IO - Finish receive I/O processing
;++
; FINISH_RCV_IO - Finish receive I/O processing
;
; Functional description:
;
; This routine completes a receive operation that has been matched with a
; message block. After the receive has been completed the message free list
; is filled and a receive is started if needed.
;
;  Inputs:
;
;	R2 = receive CXB address
;	R3 = I/O packet address
;	R4 = CDB address
;	R5 = UCB address
;
;	IPL = FIPL
;
;  Outputs:
;
;	R5 is reset to UCB address from IRP
;
;	The request is completed via I/O post.
;--

FINISH_RCV_IO::				; Finish recieve I/O request
	MOVL	R2,IRP$L_SVAPTE(R3)	; Save block address
	MOVQ	CXB$G_R_SRC(R2),-	; Copy source address for DECnet
		IRP$Q_STATION(R3)	;	...
	BBC	#IRP$V_DIAGBUF,-	; Br if no diagnotic buffer
		IRP$W_STS(R3),10$	;
	MOVL	IRP$L_DIAGBUF(R3),R1	; Get diagnostic buffer
	MOVAB	RHDR_T_DATA(R1),R0	; Assume this is just a read header
	CMPW	#RHDR_C_LENGTH,DIAG_W_SIZE(R1) ; Is this just a header buffer?
	BEQL	5$			; Br if yes
	MOVAB	DIAG_T_RDATA(R1),R0	; Else, must be a diagnostic buffer
	MOVB	CXB$B_R_FLAGS(R2),-	; Save diagnostic return info
		 CDB_B_DIAG1(R4)	;	...
	MOVW	CXB$W_R_STS(R2),-	;	...
		 CDB_W_DIAG2(R4)	;	...
5$:	PUSHR	#^M<R2,R3,R4,R5>	; Save registers
	MOVC3	#RHDR_C_DATA,CXB$T_R_DATA(R2),(R0) ; Move header info
	POPR	#^M<R2,R3,R4,R5>	; Restore registers
10$:	MOVAB	CXB$T_R_USERDAT(R2),(R2); Set address of received data
	MOVL	IRP$L_XQ_DATBUF(R3),4(R2); Set address of user buffer
	ADDW	UCB$W_DEVBUFSIZ(R5),-	; Adjust receive buffer quota
		UCB$W_XQ_QUOTA(R5)	;
	MOVZWL	CXB$W_BCNT(R2),R1	; Find length of received message
;
; Perform accounting on a per protocol type basis.
;
	CNTR	R1,UCB$L_XQ_RBYCTR(R5),L ; Bump the bytes received counter
	INCC	UCB$L_XQ_RBLCTR(R5),L	; Bump the blocks received counter
;
; If padding is enabled, then the size of the data is contained in the
; message as the first word of data.
;
	ASSUME	NMA$C_STATE_ON EQ 0
	ASSUME	NMA$C_STATE_OFF EQ 1
	BLBS	UCB$B_XQ_PAD(R5),15$	; Br if padding is disabled
	MOVZWL	CXB$W_R_SIZE(R2),R0 	; Else, pick up real size of
					;  MSG from the message itself
	ADDL	#XQ_C_CNTSIZ,(R2)	; Move pointer past the count field
;
; Verify that the 1st word of data at least makes some sense. The byte
; count for the message must be less than the size of the entire received
; message.
;
	CMPW	R0,R1			; Is size field larger than buffer?
	BGEQU	45$			; Br if yes -
					;  must be strictly Less Than, because
					;  the size field is 2 extra bytes.
	MOVZWL	R0,R1			; Else, copy the real buffer size

15$:	MOVZBW	S^#SS$_NORMAL,IRP$W_XQ_STATUS(R3) ; Assume success
	CMPW	R1,IRP$W_BCNT(R3)	; Request larger than user buffer size?
	BLEQU	20$			; Br if no - okay
	MOVZWL	IRP$W_BCNT(R3),R1	; Else, set size to minimum of two
	MOVW	#SS$_DATAOVERUN,IRP$W_XQ_STATUS(R3) ; Set return status
;
; If chained buffers, then setup IRP$W_STS and don't reset the USER BUFFER
; SIZE (IRP$W_BCNT), because chained buffers need to have the USER BUFFER
; SIZE in IRP$W_BCNT.
;
20$:	TSTL	CXB$L_LINK(R2)		; Is this a complex chained buffer?
	BEQL	30$			; Br if no - set transfer size
	BBC	#IRP$V_CHAINED,-	; Br if user cannot accept complex
		 IRP$W_STS(R3),45$	;  chained buffers
	BISW	#IRP$M_COMPLX,- 	; Else indicate complex
		 IRP$W_STS(R3)		;    chained buffers
	BRB	40$			; And don't change user buffer size
30$:	MOVW	R1,IRP$W_BCNT(R3)	; Set size of transfer
40$:	ASHL	#16,R1,R0		; Set buffer size in status
	BNEQ	50$			; Br if success
45$:	MOVW	#SS$_CTRLERR,-		; Set data transfer error
		IRP$W_XQ_STATUS(R3)	;
 
50$:	MOVW	IRP$W_XQ_STATUS(R3),R0	; Get status
60$:	BSBB	IO_DONE			; Post the I/O request
	BRW	FILLRCVLIST		; Fill up the receive buffers
;
; Complete an I/O request packet
;
ABORT_PKT:				; Abort the I/O request
	MOVZBL	S^#SS$_ABORT,R0		; Return aborted status
IO_DONE3:				; Complete the I/O request, check for
					;    timeout
	MOVL	IRP$L_UCB(R3),R5	; Get UCB address
	MOVL	UCB$L_CRB(R5),R1	; Get CRB address
	MOVL	CRB$L_AUXSTRUC(R1),R1	; Get CDB address
	BBC	#XM$V_STS_TIMO,CDB_L_DEVDEPEND(R1),IO_DONE ; Br if not a timeout
	MOVZWL	#SS$_TIMEOUT,R0		; Else, return real error code
IO_DONE:				; Complete an I/O request
	MOVL	R0,IRP$L_IOST1(R3)	; Set status return and size
IO_DONE1:				; Alternate entry point
	MOVL	IRP$L_UCB(R3),R5	; Get UCB address
	MOVL	UCB$L_DEVDEPEND(R5),IRP$L_IOST2(R3) ; Set other info
	MOVL	UCB$L_CRB(R5),R1	; Get CRB address
	MOVL	CRB$L_AUXSTRUC(R1),R1	; Get CDB address
	BEQL	IO_DONE2		; Br if no CDB
	BISL	CDB_L_DEVDEPEND(R1),IRP$L_IOST2(R3) ; Set controller bits
IO_DONE2:				; P1 IOST2 already setup
	PUSHL	R4			; Save R4
	MOVL	UCB$L_CRB(R5),R4	; Get CRB address
	MOVL	CRB$L_AUXSTRUC(R4),R4	; Get CDB address
	BBC	#IRP$V_DIAGBUF,-	; Br if no diagnotic buffer
		IRP$W_STS(R3),20$	;
	MOVL	IRP$L_DIAGBUF(R3),R0	; Get diagnostic buffer address
	CMPW	#RHDR_C_LENGTH,DIAG_W_SIZE(R0) ; Is this a real diag buffer?
	BEQL	20$			; Br if not - no diagnostic info
	ADDL3	#8,(R0),R0		; Address buffer past start time
	MOVQ	G^EXE$GQ_SYSTIME,(R0)+	; Insert stop time
	MOVL	CDB_L_UCB0(R4),R1	; Get address of UCB #0
	MOVZWL	UCB$W_ERRCNT(R1),(R0)+	; Insert error counter
	BSBW	REG_DUMP		; Dump registers
20$:	POPL	R4			; Restore R4
	JMP	G^COM$POST		; Post the I/O and return

	.SBTTL	ASSEM_PKTS - Assemble receive packets
;++
; ASSEM_PKTS - Assemble receive packets
;
; Functional description:
;
; This routine assembles all receive packets into one chain of complex
; buffers.
;
;  Inputs:
;
;	R4 = CDB address
;	R7 = Receive ring address
;
;	IPL = FIPL
;
;  Outputs:
;
;	R0 = Status for request
;	R2 = Address of first receive buffer in chain
;	R6 = Address of last buffer in receive ring
;	R1,R3 are destroyed.
;	All other registers are preserved.
;
;  Implicit Outputs:
;
;	IRP$V_CHAIN and IRP$V_COMPLX bits set in IRP$W_STS if the receive
;	buffer is comprised of complex chained buffers.
;--
	.ENABL	LSB
ASSEM_PKTS::				; Assemble receive packets
	BSBW	NEXTMSG			; Get first message
	BLBS	R0,5$			; Br if we got one
	RSB				; Return in error
;
; Save number of messages  in chain in CXB$W_R_NCHAIN and total size of
; all messages in CXB$W_BCNT
;
5$:	MOVW	S^#1,CXB$W_R_NCHAIN(R2)	; Compute total number of buffers
	CLRW	CXB$W_BCNT(R2)		; Init total size of buffers so far
	MOVW	CXB$W_LENGTH(R2),R0	; Get size of message
	BBC	#RCV_STS_V_LAST,-	; Br if end of packet
		 CXB$W_R_STS(R2),40$	; ..all done with this loop
	PUSHL	R2			; Save first receive buffer address
	MOVZBL	#MAX_C_CHAIN,R3		; Allow n messages in chain
10$:	MOVW	RCV_W_LEN(R6),-		; Set size of buffer to maximum per rcv
		 CXB$W_LENGTH(R2)	;
	PUSHL	R2			; Save address of current bufr in chain
	BSBW	NEXTMSG			; Try for next message
	POPL	R1			; Get address of last buffer in chain
	BLBC	R0,20$			; Toss all messages on error
	MOVL	(SP),R0			; Get address of first in chain
	MOVL	R2,CXB$L_LINK(R1)	; Store address in chain
	ADDW	CXB$W_LENGTH(R1),-	; Compute total size of all buffers
		 CXB$W_BCNT(R0)		;  in chain - so far
	INCW	CXB$W_R_NCHAIN(R0)	; Compute number of msgs in chain
	BBC	#RCV_STS_V_LAST,-	; Br if end of packet
		 CXB$W_R_STS(R2),30$	;
	SOBGTR	R3,10$			; Loop if more than two in chain
;
; Done with loop and LAST bit still not set - toss all messages
;
	INCC	CDB_W_OVRCTR(R4),W	; Count as hardware error
;
; Error exit
;
20$:	BRB	TOSAMSG			; Toss all messages

30$:	MOVL	R2,R1			; Save address of last message
	POPL	R2			; Return first message address in R2
	MOVB	CXB$B_R_FLAGS(R1),-	; Save only last message buffer info
		 CXB$B_R_FLAGS(R2)	;  in first message of chain
	MOVW	CXB$W_R_STS(R1),-	; DITTO
		 CXB$W_R_STS(R2)	;
	MOVW	CXB$W_LENGTH(R1),R0	; Save size of entire message
	SUBW	CXB$W_BCNT(R2),-	; Compute size of last message
		 CXB$W_LENGTH(R1)	;  and store in CXB format
40$:	MOVW	R0,CXB$W_BCNT(R2)	; Return size of complete message
50$:	MOVZBL	S^#SS$_NORMAL,R0	; Return success!
100$:	RSB
;
; Toss bad messages
;
TOSAMSG:POPL	R2			; Restore R2
TOSSMSG:INCC	CDB_W_LBECTR(R4),W	; Up the counter
110$:	PUSHL	CXB$L_LINK(R2)		; Save address of next in chain
	BSBW	ADDRCVLIST		; Add buffer to receive list
	POPL	R2			; Restore address of next in chain
	BNEQ	110$			; Br if more in chain
120$:	CLRL	R0			; Assume failure
	BBS	#RCV_STS_V_LAST,-	; Br if NOT end of chain
		 RCV_W_STS(R6),130$	;  get rest of message
	BRW	ASSEM_PKTS		; Else, try for next valid message
130$:	BSBB	NEXTMSG			; Get next message
	BLBC	R0,100$			; Br if none
	BRB	120$			; Check if more possible
	.DSABL	LSB
;
; Find next message and check ownership
;
NEXTMSG:CLRL	R0			; Assume failure
	TSTB	CDB_B_RCVCNT(R4)	; Any more receives in progress?
	BNEQ	5$			; Br if yes
1$:	RSB				; Else, return

5$:	MOVZBL	CDB_B_LASTRCV(R4),R6	; Get last ring entry completed inx
	MOVL	CDB_L_RRINGVA(R4)[R6],R6; Get last ring entry address
	BBC	#RCV_STS_V_LAST,RCV_W_STS(R6),10$ ; Br if done
	BBC	#RCV_STS_V_ERR,RCV_W_STS(R6),1$ ; Br if not done
10$:	CMPB	RCV_W_LENB(R6),RCV_W_LENB+1(R6) ; Are we really done?
	BNEQ	90$			; Br if not, leave now
	REMQUE	@CDB_Q_RCVPND(R4),R2	; Get next receive
	BVS	90$			; Br if none available (yet)
	CLRL	CXB$L_LINK(R2)		; Assume not a chained buffer
	DECB	CDB_B_RCVCNT(R4)	; One less receive pending
	INCB	CDB_B_LASTRCV(R4)	; Bump ring pointer
	BICB	#^C<MAX_C_RCV-1>,-	; Modulo receive ring entry size
		 CDB_B_LASTRCV(R4)	;	...
	CLRBIT	#RCV_DSC_V_VALID,-	; Indicate that buffer is not valid
		 RCV_W_ADDRHI(R6)	;
;
; Compute buffer size
;
	BICW3	#^C<RCV_STS_M_RLEN>,-	; Store length <10:8>
		 RCV_W_STS(R6),-	;
		 CXB$W_LENGTH(R2)	;
	MOVB	RCV_W_LENB(R6),-	; Store length in CXB <7:0>
		 CXB$W_LENGTH(R2)	;
	ADDW	#XQ_C_ADDRCV-<XQ_C_HEADER+XQ_C_CRC>,- ; Add in missed count
		 CXB$W_LENGTH(R2)	;    ..minus header and CRC
	MOVW	RCV_W_STS(R6),-		; Save status flags in CXB
		 CXB$W_R_STS(R2)
	MOVB	RCV_W_FLAG+1(R6),-	; Save flags byte (high word)
		 CXB$B_R_FLAGS(R2)	;
;
; Adjust quota and release mapping slot
;
	TSTB	CDB_B_AQUOTA(R4)	; Are running on extra QUOTA?
	BNEQ	30$			; Br if not
	DECB	CDB_B_AQUOTA(R4)	; Else, decrement extra QUOTA
	BRB	40$			; Continue

30$:	ADDW	CDB_W_BSZ(R4),-		; Replenish CDB quota
		 CDB_W_QUOTA(R4)	;
40$:	MOVZBL	CXB$B_XQ_SLOT(R2),R1	; Get mapping slot number used
	CLRBIT	R1,CDB_B_RCVMAP(R4)	; Clear in use flag
	CPUDISP	<<790,80$>,-
		 <780,80$>,-
		 <750,80$>,-
		 <730,80$>,-
		 <UV1,100$>>		; Copy data on u-VAX I
80$:	MOVZBL	S^#SS$_NORMAL,R0	; Return success!
90$:	RSB

100$:	;*******************
	; For u-VAX I, ONLY.
	;*******************
	BITW	#RCV_STS_M_ESETUP!-	; Is this a setup packet or error?
		 RCV_STS_M_ERR,-
		 CXB$W_R_STS(R2)
	BNEQ	80$			; Br if yes, skip it
	MOVL	CDB_L_RCV_VA(R4)[R1],R0	; Get address of contiguous buffer
	CMPW	CXB$W_LENGTH(R2),CDB_W_BSZ(R4)	; Check size of received data
	BLEQU	110$			; Br if okay
	SETBIT	#RCV_STS_V_ERR,-	; Else, indicate error
		 CXB$W_R_STS(R2)	;  and let it get tossed
	BRB	80$			; Continue

110$:	ADDW3	#XQ_C_HEADER,-		; Add back in the header
		 CXB$W_LENGTH(R2),R3	;
	PUSHR	#^M<R2,R4,R5>		; Save registers
	MOVC3	R3,(R0),CXB$T_R_DATA(R2) ; Move the data
	POPR	#^M<R2,R4,R5>		; Restore registers
	BRB	80$			; Continue

	.SBTTL	MOP_CTR_REQUEST - PROCESS MOP READ COUNTERS REQUEST
;++
; MOP_CTR_REQUEST - PROCESS MOP READ COUNTERS REQUEST
;
; FUNCTIONAL DESCRIPTION:
;
; This routine is called to process a remote request to read the LINE counters.
;
; Inputs:
;
;	R2 = Address of the received message
;	R4 = CDB address
;
; Outputs:
;
;	R0,R1,R2,R3,R5 are destroyed
;	R4 is preserved
;--

MOP_CTR_REQUEST::			; Process a read counters request
	TSTL	CXB$L_LINK(R2)		; Is this a chained message?
	BNEQ	80$			; Br if yes, return packets
	CMPW	#IRP$C_LENGTH-		; Is a receive buffer large enough?
		+CXB$C_HEADER+3-
		+MOP_CTR_SIZE+8,-
		CXB$W_SIZE(R2)
	BGTRU	80$			; Br if no, ignore message
	MOVL	CDB_L_UCB0(R4),R5	; Get address of UCB #0
	MOVQ	CXB$G_R_SRC(R2),R0	; Save source node address
	MOVW	CXB$T_R_USERDAT+1(R2),-; Copy the request ID
		IRP$C_LENGTH+CXB$C_HEADER+1(R2) ;  to the Message block
	BSBW	BLD_IRP			; Turn the message block into an IRP
	MOVQ	R0,IRP$Q_STATION(R3)	; Set the return node address
	MOVL	R4,IRP$L_ASTPRM(R3)	; Save the CDB address
	BRB	MOP_CTR_BUILD		; Build the response message
;
; Error - returns packets to receive queue
;
80$:	PUSHL	CXB$L_LINK(R2)		; Save next in chain
	BSBW	ADDRCVLIST		; Add buffer to receive list
	POPL	R2			; Restore next buffer
	BNEQ	80$			; Loop if more
	RSB				; Return to caller


	.SBTTL	MOP_CTR_BUILD - BUILD THE MOP COUNTER RETURN MESSAGE
;++
; MOP_CTR_BUILD - BUILD THE MOP COUNTER RETURN MESSAGE
;
; FUNCTIONAL DESCRIPTION:
;
; This routine is called to build the return message in response to a
; MOP read counters request.
;
; Inputs:
;
;	R3 = IRP address
;	R4 = CDB address
;	R5 = UCB address of UNIT 0
;
; Outputs:
;
;	R4 = CDB address
;	R5 = UCB address of UNIT 0
;
;	R0,R1 are destroyed
;--

MOP_CTR_BUILD:				; Build the MOP counter return msg

	PUSHR	#^M<R3,R4,R5,R6,R7,R8>	; Save registers
	MOVL	R4,R6			; Copy CDB address
	MOVAB	IRP$C_LENGTH+-		; Point to start of message
		CXB$C_HEADER(R3),R3 	;    block
	MOVB	#NI_CTR_REPLY,(R3)+	; Set function to reply
	TSTW	(R3)+			; Skip request ID (filled in earlier)
	MOVAB	MOPCTRTAB,R7		; Get address of MOP counters
20$:	MOVZWL	(R7)+,R8		; Get the offset to the counter desired
	BEQL	30$			; Br if end of table
	ADDL	R6,R8			; Compute address of the counter
	EXTZV	#0,#7,(R7),R2		; Get the width field without bitmap
	MOVC3	R2,(R8),(R3)		; Copy the counter
	MOVZBL	(R7)+,R1		; Get the width field again
	BBC	#7,R1,20$		; Br if no BITMAP to return
	MOVW	-2(R8),(R3)+		; Else, store the BITMAP
	BRB	20$			; Loop for next counter

30$:	POPR	#^M<R3,R4,R5,R6,R7,R8>	; Restore registers

	MOVAB	W^DELETE_BLOCK,IRP$L_PID(R3) ; Set the return address
	MOVAB	IRP$C_LENGTH(R3),R2	; Get address of CXB
	MOVB	#DYN$C_CXB,CXB$B_TYPE(R2) ; Make it look like a CXB
	MOVW	#MOP_CTR_SIZE+8+3,-	; Set size of transfer
		CXB$W_BCNT(R2)		;
	ASSUME	CXB$C_HEADER  EQ  CXB$T_T_DATA+XQ_C_HEADER
	MOVW	#CXB$T_T_DATA,-		; Set offset to start of data
		CXB$W_BOFF(R2)
	MOVL	R3,CXB$L_T_IRP(R2)	; Save IRP address in CXB
	MOVQ	IRP$Q_STATION(R3),-	; Set STATION in CXB
		CXB$Q_STATION(R2)
	MOVB	#XQ_FC_V_XMIT,-		; Set function request in CXB
		CXB$B_XQ_FUNC(R2)
	MOVL	IRP$L_UCB(R3),R5	; Get the UCB address
	MOVAB	CXB$T_T_DATA(R2),R2	; Set R2 to start of data
	MOVQ	IRP$Q_STATION(R3),-	; Set th destination address
		XBUF_G_DEST(R2)
	MOVW	#NI_CTR_PROTYP,-	; Store the protocol type
		XBUF_W_TYPE(R2)
	INSQUE	IRP$C_LENGTH(R3),-	; Insert request on request queue
		@CDB_Q_XMTREQ+4(R4)
	BRW	XMT_ALT_START		; Startup the reply
	

	.SBTTL	REG_DUMP - DEQNA ERROR LOG AND DIAGNOSTICS REGISTER DUMP
;++
; REG_DUMP - DIAGNOSTICS REGISTER DUMP ROUTINE
;
; FUNCTIONAL DESCRIPTION:
;
; This routine is used to return the DEQNA error log and diagnostics
; buffer on error or diagnostic QIO function.
;
; Inputs:
;
;	R0 = Address of the buffer @ DIAG_L_EXTRA
;	R4 = CDB address
;	R5 = UCB address of the unit
;
; Outputs:
;
;	R0,R1 are destroyed
;	R4,R5 are preserved
;--
REG_DUMP::
	ASSUME	DIAG_L_DEPEND EQ DIAG_L_EXTRA+4
	ASSUME	DIAG_W_CSR EQ DIAG_L_DEPEND
	ASSUME	DIAG_W_ERR EQ DIAG_W_CSR+2
	ASSUME	DIAG_W_ERR2 EQ DIAG_W_ERR+2
	ASSUME	DIAG_G_HWA EQ DIAG_W_ERR2+2
	MOVZBL	#DIAG_C_EXTRA,(R0)+	; Insert number of returned long words
	MOVW	CDB_L_CSR(R4),(R0)+	; Insert last CSR contents
	MOVZBW	CDB_B_DIAG1(R4),(R0)+	; Return error flags info
	MOVW	CDB_W_DIAG2(R4),(R0)+	; Return extra error info
	MOVL	CDB_G_HWA(R4),(R0)+	; Return hardware physical address
	MOVW	CDB_G_HWA+4(R4),(R0)+	;	...
	RSB

	.SBTTL	RESTART_ROUT - PROCESS EXPIRATION OF RESTART TIMER
;++
; RESTART_ROUT - PROCESS EXPIRATION OF RESTART TIMER
;
; Functional description:
;
; This routine is entered when the RESTART delta time has expired. The action
; is to check if the specified unit has been restarted, if so, then it is
; automatically restarted.
;
; Inputs:
;
;	R4 = CDB address
;	R5 = TQE address (but must be at least as long as an IRP)
;
;	IPL = IPL$_TIMER
;
; Implicit inputs:
;
;	IRP$L_RBOFF(R5) = UCB address for UNIT
;
; Outputs:
;
;	R0-R3 are destroyed.
;--
	.ENABL	LSB
RESTART_ROUT::				; Process expiration of restart timer
	PUSHL	R5			; Save R5
	ASSUME	IRP$L_RBOFF GT TQE$C_LENGTH
	MOVAB	TQE$C_LENGTH(R5),R2	; Point to IRP portion of TQE
	MOVL	IRP$L_RBOFF(R2),R5	; Reset R5 to UCB address
;
; Turn TQE into an IRP
;
	MOVAQ	(R2)+,R3		; Copy IRP address, skip to size field
	ASSUME	IRP$W_SIZE EQ 8
	ASSUME	IRP$B_TYPE EQ IRP$W_SIZE+2
	ASSUME	IRP$B_RMOD EQ IRP$B_TYPE+1
	ADDL	#2,R2			; Skip size field
	MOVW	#DYN$C_IRP,(R2)+	; Set type to IRP
	ASSUME	IRP$L_PID EQ IRP$B_RMOD+1
	MOVAB	W^RETURN_IRP,(R2)+	; Set return address form IOPOST
	ASSUME	IRP$L_AST EQ IRP$L_PID+4
	ASSUME	IRP$L_ASTPRM EQ IRP$L_AST+4
	CLRQ	(R2)+			; Clear AST, ASTPRM
	ASSUME	IRP$L_WIND EQ IRP$L_ASTPRM+4
	ASSUME	IRP$L_UCB EQ IRP$L_WIND+4
	CLRL	(R2)+			; Clear WIND
	MOVL	R5,(R2)+		; Set UCB address
	ASSUME	IRP$W_FUNC EQ IRP$L_UCB+4
	ASSUME	IRP$B_XQ_FUNC EQ IRP$W_FUNC+1
	ASSUME	IRP$B_EFN EQ IRP$W_FUNC+2
	ASSUME	IRP$B_PRI EQ IRP$B_EFN+1
	ASSUME	IRP$L_IOSB EQ IRP$B_PRI+1
	MOVW	#<XQ_FC_V_RESTART@8>,(R2)+ ; Set function request
	CLRW	(R2)+			; Clear EFN, PRI
	CLRL	(R2)+			; Clear IOSB
	ASSUME	IRP$W_CHAN EQ IRP$L_IOSB+4
	ASSUME	IRP$W_STS EQ IRP$W_CHAN+2
	ASSUME	IRP$L_SVAPTE EQ IRP$W_STS+2
	CLRQ	(R2)+			; Clear CHAN, STS, SVAPTE
	ASSUME	IRP$W_BOFF EQ IRP$L_SVAPTE+4
	ASSUME	IRP$W_BCNT EQ IRP$W_BOFF+2
	ASSUME	IRP$W_BCNT EQ IRP$L_BCNT
	ASSUME	IRP$L_MEDIA EQ IRP$W_BCNT+6
	CLRQ	(R2)+			; Clear BOFF, BCNT
	MOVZWL	#<XQ_FC_V_INIT@8>,(R2)+	; Set MEDIA
	CLRL	(R2)+			; Clear MEDIA+4
;
; RESTART the UNIT
;
	DSBINT	UCB$B_FIPL(R5)		; Raise IPL
	BICW	#UCB$M_XQ_INTERLOCK,-	; Clear the RESTART interlock
		UCB$W_DEVSTS(R5)	;
	BBSS	#UCB$V_XQ_INITED,-	; Br if unit already inited
		UCB$W_DEVSTS(R5),10$	;
	BSBW	START			; Start protocol
	BLBS	R0,30$			; Br if success

	BSBW	STOP			; Shutdown unit
10$:	MOVL	R3,R5			; Point R5 to IRP
	BSBB	RETURN_IRP		; Return the IRP
30$:	ENBINT				; Re-enable interrupts
	POPL	R5			; Restore R5
	RSB				; Return to caller

RETURN_IRP:
	MOVAB	-TQE$C_LENGTH(R5),R0	; Get address of start of structure
	JMP	G^COM$DRVDEALMEM	; Deallocate the IRP

	.SBTTL	TQE_TIMER - PROCESS EXPIRATION OF TQE TIMER
;++
; TQE_TIMER - PROCESS EXPIRATION OF TQE TIMER
;
; Functional description:
;
; This routine is entered when the TQE delta time has expired. The action is to
; check all timer cells and shut down the controller if any have expired.
;
; Inputs:
;
;	R4 = CDB address
;	R5 = TQE address
;
;	IPL = IPL$_TIMER
;
; Outputs:
;
;	R0-R3 are destroyed.
;	R4,R5 are preserved
;--
	.ENABL	LSB
TQE_TIMER::				; Process expiration of TQE timer
	MOVL	CDB_L_UCB0(R4),R0	; Get first UCB address
	DSBINT	UCB$B_DIPL(R0)		; Sync access to UCB and CDB
	BBC	#CDB_STS_V_INITED,-	; Br if NOT inited
		CDB_B_STS(R4),STOP_TQE
	TSTB	CDB_B_TIM_XMT(R4)	; Is the xmit timer going?
	BEQL	10$			; Br if not
	DECB	CDB_B_TIM_XMT(R4)	; Timer expired?
	BEQL	TIMOUT			; Br if yes
10$:	BBC	#XM$V_STS_BUFFAIL,-	; Br if NO buffer allocation failures
		CDB_L_DEVDEPEND(R4),30$	;
	SETIPL	CDB_B_FIPL(R4)		; Else, sync access to UCB & CDB
	BSBW	FILLRCVLIST		; And try to replenish receive buffers
30$:	ENBINT				; Restore IPL

	.IF DF	POINT
	PUSHQ	R4			;% Save R4, R5
	MOVL	CDB_L_UCB0(R4),R5	;% Get UCB address of unit 0
	DSBINT	UCB$B_FIPL(R5)		;% Sync access to UCB
50$:	MOVL	UCB$L_LINK(R5),R5	;% Travel down UCBs
	BEQL	70$			;% Br if end of list
	ASSUME	UCB$V_XQ_INITED EQ 0
	BLBC	UCB$W_DEVSTS(R5),50$	;% Br if not inited
	BBC	#UCB$V_XQ_RUN,-		;% Br if not running yet
		UCB$W_DEVSTS(R5),50$	;%
	CMPB	#NMA$C_LINPR_POI,-	;% Are we in point to point mode?
		UCB$B_XQ_PRO(R5)	;%
	BNEQ	50$			;% Br if not
	BITW	#UCB$M_XQ_START!-	;% Br if not in startup or
		 UCB$M_XQ_STACK,-	;%  stack wait states
		UCB$W_DEVSTS(R5)	;%
	BEQL	50$			;%
	MOVL	UCB$L_XQ_STIRP(R5),R2	;% Get startup IRP addresss
	BSBW	BLD_STRT_IRP		;% Build the startup IRP
	BRB	50$			;% Look for more
70$:	ENBINT				;% Re-enable interrupts
	POPQ	R4			;% Restore R4, R5
	.ENDC

	RSB				; Return to caller

TIMOUT:	PUSHQ	R4			; Save R4, R5
	MOVL	R0,R5			; Copy address of UCB0
	BSBB	DEV_TIMEOUT		; Else, timeout has occurred
	POPQ	R4			; Restore R4, R5

STOP_TQE:				; Stop the TQE
	BICB	#TQE$M_REPEAT,TQE$B_RQTYPE(R5) ; Stop the timer
	BICB	#CDB_STS_M_TIMER,-	; Indicate that timer is stopped
		CDB_B_STS(R4)		;
	BICB	#DPT$M_NOUNLOAD,-	; OKAY to unload the driver now
		DPT$TAB+DPT$B_FLAGS	;
	BRB	30$			; Leave
	.DSABL	LSB

	.SBTTL	TIMEOUT - TIMEOUT SERVICE ROUTINE
;++
; TIMEOUT - TIMEOUT SERVICE ROUTINE
;
; Functional description:
;
; This routine is entered on device timeout. The action is to
; shut the unit down.
;
; Inputs:
;
;	R5 = UCB ADDRESS
;
;	IPL = DIPL
;
; Outputs:
;
;	R3,R4 are destroyed.
;	R5 is preserved
;--
	.ENABL	LSB
TIMEOUT::				; Timeout or powerfail
	BICW	#UCB$M_TIM!UCB$M_INT,UCB$W_STS(R5) ; Disable timer

	ASSUME	UCB$V_XQ_INITED  EQ  0
	BLBC	UCB$W_DEVSTS(R5),20$	; Br if not inited
	ASHL	#XQ_SOFT_V_POWER+16,#1,R3 ; Assume powerfail
	BBS	#UCB$V_POWER,UCB$W_STS(R5),10$ ; Br if powerfail
DEV_TIMEOUT::				; Hardware device timeout
	MOVL	UCB$L_CRB(R5),R4	; Get CRB address
	ASSUME	IDB$L_CSR EQ 0
	MOVL	@CRB$L_INTD+VEC$L_IDB(R4),R3 ; Get CSR address
	MOVW	#XQ_CSR_M_RESET,CSR(R3) ; Stop the device
	MOVL	CRB$L_AUXSTRUC(R4),R4	; Get CDB address
	BEQL	20$			; Br if no CDB
	ASHL	#XQ_SOFT_V_TIMEOUT+16,#1,R3 ; Indicate timeout
	SETBIT	#XM$V_STS_TIMO,CDB_L_DEVDEPEND(R4) ; Set error status
10$:	MOVW	#XQ_CSR_M_ERR,R3	; Indicate fatal error
	PUSHL	R5			; Save UCB address
	BSBW	SCHED_FORK		; Schedule a fork process
	POPL	R5			; Restore UCB address
20$:	RSB				; Return to caller
	.DSABL	LSB

	.SBTTL	ALLOC_CDB - ALLOCATE THE CDB
;++
; ALLOC_CDB - ALLOCATE THE CDB
;
; Functional description:
;
; This routine allocates and initializes the CDB.
;
; Inputs:
;
;	R5 = UCB address
;
; Outputs:
;
;	R0 = Status return for request
;
;	All other registers are preserved.
;
;--

ALLOC_CDB:				; Allocate a CDB
	PUSHR	#^M<R1,R2,R3,R4,R5>	; Save registers
	MOVZWL	#CDB_C_LENGTH,R1	; Get size of CDB allocation
	JSB	G^EXE$ALONONPAGED	; Try to allocate CDB
	BLBC	R0,90$			; Br if error

	MOVL	UCB$L_CRB(R5),R4	; Get CRB address
	MOVL	R2,CRB$L_AUXSTRUC(R4)	; Store CDB address
	MOVL	UCB$L_DDB(R5),R4	; Get DDB address
	MOVL	DDB$L_UCB(R4),R4	; Get UCB0 address
	MOVL	R4,R3			; Save UCB0 address
10$:	MOVAB	CDB_G_HWA(R2),-		; Store address of NI device's
		UCB$L_NI_HWAPTR(R4)	; unique hardware address
	MOVL	UCB$L_LINK(R4),R4	; Position to next UCB
	BNEQ	10$			; Continue if more UCBs

;
; Initialize CDB
;
;   The PADDING MODE and the ECHO MODE of the QNA will default to
;   the enabled (ON) state.
;
	ASSUME	NMA$C_STATE_ON EQ 0

	PUSHQ	R2			; Save CDB, UCB0 address
	MOVC5	#0,(R2),#0,R1,(R2)	; Zero the structure
	POPQ	R2			; Restore CDB, UCB0 address

	MOVL	R3,CDB_L_UCB0(R2)	; Save address of UCB0
;
;  Init CDB fork block.
;
	ASSUME	CDB_L_FQFL EQ 0
	ASSUME	CDB_L_FQBL EQ CDB_L_FQFL+4
	CLRQ	(R2)+			; Skip link pointers
	ASSUME	CDB_W_SIZE EQ CDB_L_FQBL+4
	ASSUME	CDB_B_TYPE EQ CDB_W_SIZE+2
	ASSUME	CDB_B_FIPL EQ CDB_B_TYPE+1
	MOVL	#<<<IPL$_XQ_FIPL@8>!DYN$C_CDB>@16>!- ; Set structure type and FIPL
		CDB_C_LENGTH,(R2)+	;  and size
	ASSUME	CDB_L_FPC EQ CDB_B_FIPL+1
	MOVAB	FORK_PROC,(R2)+		; Set fork process address
	MOVZBL	S^#SS$_NORMAL,R0	; Return success
90$:	POPR	#^M<R1,R2,R3,R4,R5>	; Restore registers
	RSB				; Return to caller

	.SBTTL	SHUTDOWN_QNA - SHUTDOWN QNA AND ALL UNITS
;++
; SHUTDOWN_QNA - SHUTDOWN QNA AND ALL UNITS
;
; Inputs:
;
;	R4 = CDB address
;	R5 = UCB address of unit #0
;
;
;	IPL = FIPL
;
; Outputs:
;
;	R3-R5 are preserved.
;
;	R0-R2 are destroyed.
;--

SHUTDOWN_QNA::				; Shutdown QNA
	BBS	#CDB_STS_V_INITED,-	; Br if QNA inited
		CDB_B_STS(R4),10$	;
	RSB				; Else, return

10$:	PUSHR	#^M<R3,R5,R6,R7>	; Save registers
;
; Shutdown QNA and reset controller status
;
	MOVL	UCB$L_CRB(R5),R2	; Get CRB address
	ASSUME	IDB$L_CSR EQ 0
	MOVL	@CRB$L_INTD+VEC$L_IDB(R2),R2 ; Get CSR address
	DSBINT	UCB$B_DIPL(R5)		; Raise IPL for master clear
	BISW	#XQ_CSR_M_RESET,CSR(R2)	; Disable device
	BICB	#^C<CDB_STS_M_FORK_PEND!- ; Reset all but needed bits
		CDB_STS_M_TIMER>,CDB_B_STS(R4) ;
	ENBINT				; Return to fork level
;
; Release the receive and transmit buffer map registers
;
	CLRL	R7			; Init slot number
	ASSUME	CDB_L_RCVMAP+<4*<MAX_C_RCV-1>> EQ CDB_L_XMTMAP
	MOVAB	CDB_L_RCVMAP(R4),R6	; Get address of mappig slots
20$:	MOVL	UCB$L_CRB(R5),R3	; Get CRB address
	ASSUME	VEC$W_MAPREG+2 EQ VEC$B_NUMREG
	ASSUME	VEC$B_NUMREG+1 EQ VEC$B_DATAPATH
	MOVL	(R6)+,CRB$L_INTD+VEC$W_MAPREG(R3) ; Set mapping information
	BLSS	30$			; Br if none allocated
	TSTB	CRB$L_INTD+VEC$B_DATAPATH(R3) ; Is there a datapath?
	BEQL	25$			; Br if not - don't do purge or release
	PURDPR				; Purge the data path
	RELDPR				; Release the data path
25$:	RELMPR				; Release the map register
	MNEGL	#1,-4(R6)		; Reset mapping info
	ASSUME	MAX_C_RCV EQ 8
30$:	CLRBIT	R7,CDB_B_RCVMAP(R4)	; Clear mapping slot flag
	AOBLSS	#MAX_C_RCV+MAX_C_XMT,R7,20$ ; Loop if more map registers
;
; Release the PCBB map registers
;
	MOVL	UCB$L_CRB(R5),R3	; Get CRB address
	ASSUME	VEC$W_MAPREG+2 EQ VEC$B_NUMREG
	ASSUME	VEC$B_NUMREG+1 EQ VEC$B_DATAPATH
	MOVL	CDB_L_RINGMAP(R4),-	; Setup map info in CRB
		 CRB$L_INTD+VEC$W_MAPREG(R3) ;
	BEQL	50$			; Br if none
	CLRL	CDB_L_RINGMAP(R4)	; No more mapping info
	RELMPR				; Release the map register
50$:	;
	; Deallocate all receive buffers and complete all I/O request packets
	;
	MOVAB	CDB_Q_QUEUES(R4),R6	; Get address of first queue listhead
	MOVZWL	#CDB_C_QUEUES,R7	; Get number of queues
60$:	REMQUE	@(R6),R3		; Get next IRP/BUFFER
	BVS	150$			; Br if none
	CMPB	IRP$B_TYPE(R3),S^#DYN$C_IRP ; Is this an IRP?
	BEQL	70$			; Br if yes
	CMPB	IRP$B_TYPE(R3),S^#DYN$C_CXB ; Is this a CXB?
	BEQL	80$			; Br if yes
	BUG_CHECK NOBUFPCKT,FATAL	; Else, fatal error
;
; IRP
;
70$:	BSBW	ABORT_PKT		; Abort the IRP
	BRB	60$			; Try for more
;
; CXB
;
80$:	$DISPATCH	CXB$B_XQ_FUNC(R3),TYPE=B,-
	<-	;function	action

		<XQ_FC_V_XMIT	100$>,-	; XMIT request
		<XQ_FC_V_RECV	140$>,-	; RECV request
		<XQ_FC_V_INIT	100$>,-	; INIT request
		<XQ_FC_V_STOP	100$>,-	; STOP request
		<XQ_FC_V_CHMODE	100$>,-	; Change mode request
	>

	BUG_CHECK NOBUFPCKT,FATAL	; Fatal error - not a valid IRP

;
; CXB - XMIT request
;
100$:	ASSUME	CXB$L_T_IRP  EQ  CXB$L_T_UCB
	BLBS	CXB$L_T_IRP(R3),120$	; Br if not IRP address => FFI user
	MOVL	CXB$L_T_IRP(R3),R3	; Else, get IRP address
	MOVL	IRP$L_XQ_SETUP(R3),R0	; Get SETUP mode buffer
	BEQL	110$			; Br if not present
	JSB	G^COM$DRVDEALMEM	; Else, deallocate buffer
110$:	BSBW	ABORT_PKT		; Abort the IRP
	BRB	60$			; Try for more

120$:	;
	;  This is an FFI user, return CXB buffer
	;
	MOVZWL	CXB$W_BOFF(R3),R1	; Get offset to start of data
	ADDL	R3,R1			; Compute start of Ethernet header
	MOVZWL	XBUF_W_TYPE(R1),R1	; Get protocol type
	BSBW	MATCH_PROTYP		; Find the protocol user
	BLBC	R0,140$			; Br if no UCB, drop buffer
	PUSHL	R4			; Save R4
	MOVL	UCB$L_XQ_FFI(R5),R4	; Get FFI block address
	BEQL	130$			; Br if not there, drop buffer
	MOVZWL	#SS$_ABORT,R0		; Set return status
	JSB	@FFI$L_XMIT_DONE(R4)	; Complete the XMIT
	POPL	R4			; Restore R4
	BRB	60$			; Try for more
130$:	;
	;  No more FFI for CXB to complete
	;
	POPL	R4			; Restore CDB address

;
; CXB - RECV request
;	

140$:	MOVL	R3,R0			; Copy CXB buffer address
	JSB	G^COM$DRVDEALMEM	; Deallocate the buffer
1060$:	BRB	60$			; Try for more
	;
	; Loop to next queue
	;
150$:	ADDL	#8,R6			; Skip to next queue listhead
	SOBGTR	R7,1060$		; Loop if more queues
	;
	; Cleanup all I/O on all UNITS
	;
	MOVL	CDB_L_UCB0(R4),R5	; Get UNIT #0 UCB address
	BEQL	190$			; Br if none, yet
170$:	MOVL	UCB$L_LINK(R5),R5	; Get next unit's address
	BEQL	190$			; Br if none
	BSBW	SHUTDOWN		; Shutdown the UNIT
	BRB	170$			; Check if more UNIT's
190$:	POPR	#^M<R3,R5,R6,R7>	; Restore registers
	RSB				; Return to caller

	.SBTTL SHUTDOWN - SHUT DOWN UNIT 
	.SBTTL SHUTDOWN_PROTYP - SHUT DOWN PROTOCOL TYPE
;++
; SHUTDOWN - SHUT DOWN UNIT
; SHUTDOWN_PROTYP - SHUT DOWN PROTOCOL TYPE
;
; Functional description:
;
; This routine is used to shut down the XQ unit as a result of a 
; SETMODE and SHUTDOWN. The action is to abort all I/O for the unit
; and then to clean up the unit data base.
;
; Inputs:
;
;	R3 = IRP address (SHUTDOWN_PROTYP entry only)
;	R4 = CDB address
;	R5 = UCB address
;
;	IPL = FIPL
;
; Outputs:
;
;	R3-R5 are preserved
;
;	R0-R2 are destroyed.
;--
SHUTDOWN_PROTYP::			; Shut down protocol type
	BBC	#UCB$V_ONLINE,-		; Br if not online
		 UCB$W_STS(R5),10$	;
	ASSUME	UCB$V_XQ_INITED  EQ  0
	BLBC	UCB$W_DEVSTS(R5),10$	; Br if not inited
	BBC	#UCB$V_XQ_SHARE,-	; Br if not a shared UCB
		 UCB$W_DEVSTS(R5),SHUTDOWN ; shutdown entire unit
;
; Try to find SHR data structure
;
	BSBW	MATCH_SHR		; Check PID and CHAN
	BNEQ	10$			; Br if NO MATCH, skip it
;
; Match found - clear inited bit and clean up all I/O on SHR data structure
;
	PUSHL	R6			; Save R6
	MOVL	R1,R6			; Copy SHR address
	BSBW	CLEANUP_SHR		; Cleanup the SHR data structure
	POPL	R6			; Restore R6
10$:	RSB				; Return to caller

SHUTDOWN::				; Shut down unit
	BBC	#UCB$V_ONLINE,-
		UCB$W_STS(R5),5$	; If BC not online

	ASSUME	UCB$V_XQ_INITED  EQ  0
	BLBS	UCB$W_DEVSTS(R5),10$	; Br if UCB is inited
5$:	RSB				; It's not time to shut down, yet

;
; If a power failure occurred, and the protocol has both initialized the FFI
; interface and supplied an asynchronous error routine, then call back
; the protocol at this routine address with a status value indicating that
; a power failure had taken place.
;

10$:	BBC	#UCB$V_POWER,-		; Skip notification if power failure
		UCB$W_STS(R5),20$	; did not occur
	PUSHL	R4			; Save CDB address
	MOVL	UCB$L_XQ_FFI(R5),R4	; Retrieve FFI address
	BEQL	15$			; Nothing to do if there isn't one
	MOVL	FFI$L_ERROR(R4),R2	; Retrieve asynch error routine address
	BEQL	15$			; Nothing to do if there isn't one
	MOVZWL	#SS$_POWERFAIL,R0	; Indicate that a powerfailure occurred
	JSB	(R2)			; Call back the asynch error routine 
15$:	POPL	R4			; Restore CDB address
	
;
; Start a 3-second timer to restart any UNIT needing automatic restart.
; This restart timer only runs if the device was halted due to a fatal error.
;
; Note, that the UCB multicast address list is purged, which will nullify
; any restart operation that may be performed by the QNA driver itself (only
; if the user has specified any multicast addresses).
;

20$:	PUSHR	#^M<R3,R6,R7>		; Save registers
	BBC	#UCB$V_XQ_RESTART,-	; Br if this UNIT does not need
		UCB$W_DEVSTS(R5),22$	;  automatic restart
	ASSUME	IRP$C_LENGTH GE TQE$C_LENGTH
	MOVZBL	#IRP$C_LENGTH+TQE$C_LENGTH,R1 ; Get size of IRP/TQE
	JSB	G^EXE$ALONONPAGED	; Try to allocate a IRP/TQE
	BLBC	R0,22$			; Br if failure - too bad
	ASSUME	IRP$Q_STATION GT TQE$C_LENGTH
	BISW	#UCB$M_XQ_INTERLOCK,-	; Interlock the RESTART bit
		UCB$W_DEVSTS(R5)	;

	ASSUME	TQE$B_TYPE EQ TQE$W_SIZE+2
	ASSUME	TQE$B_RQTYPE EQ TQE$B_TYPE+1
	MOVL	#<<DYN$C_TQE@16>!<IRP$C_LENGTH+TQE$C_LENGTH>>,- ; Set STRUCTURE
		TQE$W_SIZE(R2)		;  TYPE and SIZE
	MOVL	R5,TQE$C_LENGTH+IRP$L_RBOFF(R2)	; Save UCB address in IRP
	PUSHQ	R4			; Save R4, R5
	MOVL	R2,R5			; Copy TQE address
	MOVQ	#RESTART_DELTA,-	; Set the delta time
		TQE$Q_DELTA(R5)		;
	MOVAB	W^RESTART_ROUT,R3	; Get address of RESTART routine
	MOVB	#TQE$C_SSSNGL,-		; Set the request type
		TQE$L_RQPID(R5)		;
	BSBW	FORK_TIMER		; FORK to startup the timer
	POPQ	R4			; Restore R4, R5
	BRB	23$			; Contine

22$:	CLRBIT	#UCB$V_XQ_RESTART,-	; Restart is not possible!
		 UCB$W_DEVSTS(R5)
23$:	MOVW	#INIT_C_QUOTA,UCB$W_XQ_HBQ(R5) ; Reset hardware buffer quota
	BICW	#UCB$M_INT!UCB$M_POWER!-
		UCB$M_TIM,UCB$W_STS(R5)	; Reset device status
	BICW	#UCB$M_XQ_INITED!-	; No longer inited
		 UCB$M_XQ_RUN,UCB$W_DEVSTS(R5) ; ..or  running
	CLRBIT	#XM$V_STS_ACTIVE,UCB$L_DEVDEPEND(R5) ; Clear active bit
	BBC	#XM$V_ERR_FATAL,CDB_L_DEVDEPEND(R4),25$ ; Br if not FATAL
	SETBIT	#XM$V_ERR_FATAL,UCB$L_DEVDEPEND(R5) ; Else, indicate FATAL
;
; Reset UCB multicast address list
;
25$:	CMPL	R5,CDB_L_PRMUSER(R4)	; Is this unit the PROMISCUOUS user?
	BNEQ	27$			; Br if not
	CLRL	CDB_L_PRMUSER(R4)	; Else, clear the PROMISCUOUS user addr
	MOVB	#NMA$C_STATE_OFF,-	; Don't forget about the CDB
		CDB_B_PRM(R4)		;  parameter
	BSBW	BLD_STOP_IRP		; Build an IRP to RESET hardware mode
27$:	BBS	#UCB$V_XQ_RESTART,-	; Br if this UNIT is restarting
		UCB$W_DEVSTS(R5),28$	;  don't clear multicast list
	PUSHQ	R4			; Save R4, R5
	CLRB	UCB$B_XQ_MULTI(R5)	; No more multicast addresses
	MOVC5	#0,UCB$G_XQ_MULTI(R5),#0,- ; Zero the structure
		#6*MAX_C_MLT,UCB$G_XQ_MULTI(R5) ;
	POPQ	R4			; Restore R4, R5
;
; Reset CDB multicast address list, Flush all attention ASTs.
;
28$:	BSBW	ADD_MULTI		; Re-calculate multicast address list
	PUSHL	R4			; Save CDB address
30$:	MOVAB	UCB$L_XQ_AST(R5),R7	; Get address of AST listhead
	MOVL	(R7),R0			; Anything in list?
	BEQL	40$			; Br if not
	MOVZWL	ACB$L_KAST+10(R0),R6	; Force channel match
	MOVZWL	ACB$L_KAST+12(R0),R2	; Get process index
	MOVL	G^SCH$GL_PCBVEC,R4	; Get PCB address vector address
	MOVL	(R4)[R2],R4		; Get PCB address
	JSB	G^COM$FLUSHATTNS	; Flush AST
	BRB	30$
40$:	POPL	R4			; Restore CDB address
;
; Complete all RCV IRPs for this unit
;
	ASSUME	UCB$C_XQ_QUEUES-1 EQ 3	; One queue for shared users
45$:	REMQUE	@UCB$Q_XQ_RCVREQ(R5),R3	; Get IRP
	BVS	50$			; Br if none
	BSBW	ABORT_PKT		; Abort the I/O request
	BRB	45$			; Get next IRP
;
; Complete all XMIT CXBs for this unit
;
50$:	REMQUE	@UCB$Q_XQ_XMTREQ(R5),R3	; Get CXB
	BVS	55$			; Br if none
	ASSUME	CXB$L_T_IRP  EQ  CXB$L_T_UCB
	BLBC	CXB$L_T_IRP(R3),53$	; Br if IRP address
	PUSHL	R4			; Save CDB address
	MOVL	UCB$L_XQ_FFI(R5),R4	; Get FFI block address
	MOVZWL	#SS$_ABORT,R0		; Set status return
	JSB	@FFI$L_XMIT_DONE(R4)	; Complete CXB
	POPL	R4			; Restore CDB address
	BRB	50$			; Get next CXB

53$:	MOVL	CXB$L_T_IRP(R3),R3	; Get IRP address
	MOVL	IRP$L_XQ_SETUP(R3),R0	; Get SETUP mode buffer
	BEQL	54$			; Br if none
	JSB	G^COM$DRVDEALMEM	; Else, deallocate the buffer
54$:	BSBW	ABORT_PKT		; Abort the I/O request
	BRB	50$			; Get next CXB
;
; Deallocate all receive CXBs
;
55$:	REMQUE	@UCB$Q_XQ_RCVMSG(R5),R2 ; Get message buffer
	BVS	70$			; Br if none
	ADDW	UCB$W_DEVBUFSIZ(R5),-	; Restore quota
		UCB$W_XQ_QUOTA(R5)	;
;
;	The buffer may be smaller than the normal message size, if this
;	is a cloned buffer for the promiscuous user. Therefore, we must
;	check to make sure the buffer is large enough to be returned
;	the the device's receive buffer pool.
;
	ADDW3	#CXB$C_HEADER+-		; Calculate size of "normal"
		CXB$C_TRAILER,- 	;  receive buffer
		CDB_W_BSZ(R4),R0	;
	CMPW	R0,CXB$W_SIZE(R2)	; Can buffer be returned?
	BNEQ	60$			; Br if not, delete buffer instead
	BSBW	ADDRCVLIST		; Try to add to receiver list
	BRB	50$			; Loop for more

60$:	MOVL	R2,R0			; Copy buffer address for deallocation
	JSB	G^COM$DRVDEALMEM	; Deallocate the buffer
	BRB	50$			; Loop for more
;
; Cleanup all SHR structures if fatal error
;
70$:	BBC	#UCB$V_XQ_SHARE,-	; Br if not a SHARED UCB
		UCB$W_DEVSTS(R5),100$	;
	MOVL	UCB$L_XQ_DEFUSR(R5),R6	; Get default SHR structure address
	BEQL	90$			; Br if none
	BSBW	CLEANUP_SHR		; Else, cleanup the structure
	BBC	#XM$V_ERR_FATAL,-	; Br if not a fatal error
		UCB$L_DEVDEPEND(R5),90$
	BSBW	DELETE_SHR		; And delete the structure
90$:	MOVL	UCB$Q_XQ_SHARE(R5),R6	; Get address of next LIMITED user
	CMPL	R6,UCB$Q_XQ_SHARE(R5)	; End of list?
	BEQL	120$			; Br if yes, don't restore quota (yet)
	BSBW	CLEANUP_SHR		; Cleanup the I/O
	BBC	#XM$V_ERR_FATAL,-	; Br if not a fatal error
		UCB$L_DEVDEPEND(R5),90$
	BBS	#UCB$V_XQ_RESTART,-	; Br if this UNIT is re-starting
		UCB$W_DEVSTS(R5),90$
	BSBW	DELETE_SHR		; Else, delete the structure
	BRB	90$			; Look for more
;
; Restore quota
;
100$:	BBS	#UCB$V_XQ_RESTART,-	; Br if this UNIT is re-starting
		UCB$W_DEVSTS(R5),140$
	MOVZWL	UCB$L_XQ_PID(R5),R0	; Get PID of last starter
	MOVL	G^SCH$GL_PCBVEC,R1	; Address PCB vector
	MOVL	(R1)[R0],R0		; Get PCB of owner
	CMPL	PCB$L_PID(R0),-
		UCB$L_XQ_PID(R5)	; Still there?
	BNEQ	120$			; If NEQ no
	MOVL	PCB$L_JIB(R0),R0	; Get JIB address
	MOVZWL	UCB$W_XQ_QUOTA(R5),R1	; Convert to longword
	ADDL	R1,JIB$L_BYTCNT(R0)	; Return byte count quota
	ADDL	R1,JIB$L_BYTLM(R0)	; ..and byte limit quota
	CLRW	UCB$W_XQ_QUOTA(R5)	; Prevent this from being
					; returned again
;
; Delete the STARTUP IRP for point-to-point mode
;
120$:	MOVL	UCB$L_XQ_STIRP(R5),R0	;% Get the startup IRP address
	BEQL	130$			;% Br if none
	CLRL	UCB$L_XQ_STIRP(R5)	;% All done
	JSB	G^COM$DRVDEALMEM	;% Deallocate the IRP
;
; If there is an FFI block and the SHUT_DONE routine is set, then
; notify the FFI user that shutdown is now complete.
;
130$:	MOVL	UCB$L_XQ_FFI(R5),R0	; Get FFI block address
	BEQL	140$			; Br if none
	CLRL	UCB$L_XQ_FFI(R5)	; Cleanup FFI interface
	MOVL	FFI$L_SHUT_DONE(R0),R1	; Get address of routine
	BEQL	140$			; Br if none
	PUSHL	R4			; Save CDB address
	MOVL	R0,R4			; Copy FFI block address
	JSB	(R1)			; Call back FFI user
	POPL	R4			; Restore CDB address
;
; Decrement UNIT count on CDB and cleanup CDB if last unit
;
140$:	DECB	CDB_B_UNTCNT(R4)	; One less unit on CDB
	BNEQ	150$			; Br if more
	BSBW	SHUTDOWN_QNA		; Else, shutdown entire QNA
150$:	POPR	#^M<R3,R6,R7>		; Restore registers
	RSB				; Return to caller


	.SBTTL	BLD_STOP_IRP - Build an IRP to reset promiscuous mode
;++
; BLD_STOP_IRP - Build an IRP to reset the promiscuous mode
;
; Functional description:
;
; This routine will allocate and build an IRP to reset the hardware mode
; from promiscous.
;
; Inputs:
;	R4 = CDB address
;	R5 = UCB address
;
; Outputs:
;	R0,R1,R2,R3 are destroyed.
;--
	.ENABL	LSB
BLD_STOP_IRP:				; Build an IRP to reset hardware mode
;
; NOTE - we must use EXE$ALONONPAGED to allocate the IRP because the other
;	routines reset the IPL to ASTDEL.
;
	BBS	#XM$V_ERR_FATAL,-	; Br if fatal error,
		CDB_L_DEVDEPEND(R4),10$ ;  ignore reset of mode
	MOVZWL	#IRP$C_LENGTH,R1	; Set length of IRP
	JSB	G^EXE$ALONONPAGED	; Try to allocate an IRP
	BLBS	R0,20$			; Okay if buffer allocated
10$:	RSB				; Else, too bad if we can't do it

20$:	MOVW	R1,IRP$W_SIZE(R2)	; Fill in the size field
	BSBB	BLD_IRP			; Build a template IRP
	MOVAB	B^DELETE_BLOCK,IRP$L_PID(R3) ; Store return address from IOPOST
	BSBW	SETUP_MODE		; Allocate setup mode buffer
	BLBC	R0,70$			; Leave on error
	MOVB	#XQ_FC_V_STOP,-		; Set function request,
		CXB$B_XQ_FUNC(R2)	;  looks like a STOP
	RSB				; Return to queue request to DEQNA

70$:	MOVL	R3,R0			; Copy IRP address
	BRB	90$			; Deallocate IRP

DELETE_BLOCK:				; Deallocate a data structure
	MOVL	R5,R0			; Get address of structure
90$:	JMP	G^COM$DRVDEALMEM	; Deallocate the structure

	.DSABL	LSB

	.SBTTL	BLD_STRT_IRP - Build a point-to-point startup IRP
;++
; BLD_STRT_IRP - Build a point-to-point startup IRP
;
; Functional description:
;
; This routine will build an IRP to perform a datalink startup with a
; remote system.
;
; Inputs:
;	R2 = IRP address
;	R4 = CDB address
;	R5 = UCB address
;
; Outputs:
;	R0,R1,R2,R3 are destroyed.
;--
BLD_STRT_IRP:				;% Build a startup IRP
;
; We will use the back part of the IRP to build the data message. The
; data message only contains the standard header plus one byte of ^XAA.
;
	ASSUME	IRP$C_XQ_STD+17 LE IRP$C_LENGTH ;% 14 bytes of header +
					;%    2 bytes of count + msg type.
	BSBB	BLD_IRP			;% Build the IRP
	MOVAB	IRP$C_XQ_STD(R3),R2	;% Point to data portion of IRP
	MOVQ	UCB$G_XQ_DES(R5),-	;% Store destination address
		XBUF_G_DEST(R2)		;%
	MOVW	#XQ_C_STPRO,XBUF_W_TYPE(R2) ;% Store protocol type
	MOVW	#1,XBUF_W_SIZE(R2)	;% Store message size
	MOVB	#^XAA,XBUF_W_SIZE+2(R2)	;% Transmit one start byte of data
	BBS	#UCB$V_XQ_START,UCB$W_DEVSTS(R5),50$ ;% Br if start
	MOVB	#^XAB,XBUF_W_SIZE+2(R2)	;% Transmit one stack byte of data
50$:	MOVAB	B^90$,IRP$L_PID(R3)	;% Store return address
	MOVB	#XQ_FC_V_XMIT,IRP$B_XQ_FUNC(R3) ;% Set function request
	ASSUME	XBUF_C_HEADER EQ XBUF_W_SIZE
	MOVW	#XBUF_C_HEADER+3,-	;% Set data size
		IRP$W_BCNT(R3)		;%
	MOVL	R2,IRP$L_XQ_SYSBUF(R3)	;% Set buffer address
	INSQUE	(R3),@CDB_Q_XMTREQ+4(R4);% Insert transmit request
	BSBW	XMT_ALT_START		;% Startup transmit process
90$:	RSB				;% Return to caller


	.SBTTL	BLD_IRP - Build an IRP routine
;++
; BLD_IRP - Build an IRP routine
;
; Functional description:
;
; This routine will build a simple IRP and allow the caller to fill in the
; function requested and then queue it to the DEQNA.
;
; Inputs:
;	R2 = IRP address
;	R5 = UCB address
;
; Outputs:
;	R3 = IRP address
;	R0-R2 are destroyed.
;	R4,R5 are preserved.
;--
BLD_IRP:				; Build an IRP
	MOVAQ	(R2)+,R3		; Save IRP address, skip to size field
	ASSUME	IRP$W_SIZE EQ 8
	ASSUME	IRP$B_TYPE EQ IRP$W_SIZE+2
	ASSUME	IRP$B_RMOD EQ IRP$B_TYPE+1
	TSTW	(R2)+			; Skip SIZE
	MOVW	#DYN$C_IRP,(R2)+	; Make it look like an IRP
	ASSUME	IRP$L_PID EQ IRP$B_RMOD+1
	ASSUME	IRP$L_AST EQ IRP$L_PID+4
	CLRQ	(R2)+			; Clear PID, AST
	ASSUME	IRP$L_ASTPRM EQ IRP$L_AST+4
	ASSUME	IRP$L_WIND EQ IRP$L_ASTPRM+4
	CLRQ	(R2)+			; Clear ASTPRM, WIND
	ASSUME	IRP$L_UCB EQ IRP$L_WIND+4
	MOVL	R5,(R2)+		; Store UCB address
	ASSUME	IRP$W_FUNC EQ IRP$L_UCB+4
	ASSUME	IRP$B_EFN EQ IRP$W_FUNC+2
	ASSUME	IRP$B_PRI EQ IRP$B_EFN+1
	ASSUME	IRP$L_IOSB EQ IRP$B_PRI+1
	CLRQ	(R2)+			; Clear FUNC, EFN, PRI, IOSB
	ASSUME	IRP$W_CHAN EQ IRP$L_IOSB+4
	ASSUME	IRP$W_STS EQ IRP$W_CHAN+2
	ASSUME	IRP$L_SVAPTE EQ IRP$W_STS+2
	CLRQ	(R2)+			; Clear CHAN, STS, SVAPTE
	ASSUME	IRP$W_BOFF EQ IRP$L_SVAPTE+4
	ASSUME	IRP$W_BCNT EQ IRP$W_BOFF+2
	ASSUME	IRP$L_BCNT EQ IRP$W_BCNT
	CLRQ	(R2)+			; Clear BOFF, BCNT
	RSB				; Return to caller


	.SBTTL	CLEANUP_SHR - CLEANUP ALL I/O ON SHARE DATA STRUCTURE
	.SBTTL	DELETE_SHR - DELETE SHR DATA STRUCTURE
;++
; CLEANUP_SHR - CLEANUP ALL I/O ON SHARE DATA STRUCTURE
;
; This routine aborts all read request in progress and return all message
; buffers back to the CDB structure for re-use.
;
; Inputs:
;
;	R4 = CDB address
;	R5 = UCB address
;	R6 = SHR address
;
;	IPL = FIPL
;
; Outputs:
;
;	R0-R2 are destroyed.
;	All other registers are preserved.
;--
CLEANUP_SHR::				; Cleanup all I/O on SHR structure
	PUSHL	R3			; Save R3

	.IF DF	POINT
	PUSHL	R7			;% Save R7
;
; Complete all waiting transmit IRPs
;
1$:	MOVAB	UCB$Q_XQ_XMTREQ(R5),R7	;% Get address of XMIT wait queue
	MOVL	(R7),R3			;% Travel queue
2$:	CMPL	R3,R7			;% At end of queue?
	BEQL	9$			;% Br if yes
	MOVL	CXB$L_T_IRP(R3),R0	;% Get (presumed) IRP address
	ASSUME	CXB$L_T_IRP  EQ  CXB$L_T_UCB
	BLBS	R0,4$			;% Br if not IRP address, only one chan
	CMPW	IRP$W_CHAN(R0),SHR_W_CHAN(R6) ;% Same as SHR chan?
	BNEQ	8$			;% Br if not, else
4$:	REMQUE	(R3),R3			;% Remove CXB from list
	BLBS	R0,6$			;% Br if FAST interface
	MOVL	R0,R3			;% Else, copy IRP address
	MOVL	IRP$L_XQ_SETUP(R3),R0	;% Get SETUP mode buffer
	BEQL	5$			;% Br if none
	JSB	G^COM$DRVDEALMEM	;% Else, deallocate the buffer
5$:	BSBW	ABORT_PKT		;% Abort the I/O request
	BRB	1$			;% Look for more
6$:	PUSHL	R4			;% Save R4
	MOVZWL	#SS$_ABORT,R0		;% Setup error return
	MOVL	UCB$L_XQ_FFI(R5),R4	;% Get FFI block address
	JSB	@FFI$L_XMIT_DONE(R4)	;% Complete the XMIT CXB
	POPL	R4			;% Restore R4
	BRB	1$			;% Look for more
8$:	MOVL	(R3),R3			;% Travel link
	BRB	5$			;% Check for end of queue
9$:	POPL	R7			;% Restore R7
	.ENDC

	ASSUME	SHR_C_QUEUES EQ 2
;
; Complete all IRPs for this structure
;
10$:	REMQUE	@SHR_Q_RCVREQ(R6),R3	; Get IRP
	BVS	20$			; Br if none
	BSBW	ABORT_PKT		; Abort the I/O request
	BRB	10$			; Get next IRP
;
; Deallocate all message blocks
;
20$:	REMQUE	@SHR_Q_RCVMSG(R6),R2	; Get message buffer
	BVS	30$			; Br if none
	ADDW	UCB$W_DEVBUFSIZ(R5),-	; Restore quota
		 UCB$W_XQ_QUOTA(R5)	;
	BSBW	ADDRCVLIST		; Try to add to receiver list
	BRB	20$			; Loop
30$:	POPL	R3			; Restore R3
	RSB				; Return to caller

;++
; DELETE_SHR - DELETE SHARE DATA STRUCTURE
;
; This routine deallocates the SHR data structure to system pool.
;
; Inputs:
;
;	R5 = UCB address
;	R6 = SHR address
;
;	IPL = FIPL
;
; Outputs:
;
;	R0-R1 are destroyed.
;	All other registers are preserved.
;--
DELETE_SHR::				; Delete SHR data structure
	DECW	UCB$W_REFC(R5)		; One less user of the unit
	CMPL	R6,UCB$L_XQ_DEFUSR(R5)	; Is this the default user?
	BEQL	30$			; Br if yes
	MOVAB	UCB$Q_XQ_SHARE(R5),R1	; Get address of SHARE queue
	MOVL	(R1),R0			; Get address of next in queue
10$:	CMPL	R0,R1			; Back to front of list?
	BEQL	90$			; Br if none found
	CMPL	R6,R0			; Is this the one?
	BEQL	20$			; Br if yes
	MOVL	(R0),R0			; Else, get next in queue
	BRB	10$			; And try for match
20$:	REMQUE	(R0),R0			; Remove structure from list
	BRB	40$			; And delete the structure
30$:	CLRL	UCB$L_XQ_DEFUSR(R5)	; No more default user
40$:	MOVZWL	SHR_L_PID(R6),R0	; Get PID SHR structure
	MOVL	G^SCH$GL_PCBVEC,R1	; Address PCB vector
	MOVL	(R1)[R0],R0		; Get PCB of owner
	CMPL	PCB$L_PID(R0),-
		SHR_L_PID(R6)		; Still there?
	BNEQ	60$			; If NEQ no
	MOVL	PCB$L_JIB(R0),R0	; Get JIB address
	MOVZWL	SHR_W_QUOTA(R6),R1	; Convert to longword
	ADDL	R1,JIB$L_BYTCNT(R0)	; Return byte count quota
	ADDL	R1,JIB$L_BYTLM(R0)	; ..and byte limit quota
	SUBW	R1,UCB$W_XQ_QUOTA(R5)	; Decrease the current quota
	SUBW	R1,UCB$W_XQ_TOTQUO(R5)	;  and the total quota
60$:	MOVL	R6,R0			; Copy SHR structure address
	JMP	G^COM$DRVDEALMEM	; Deallocate the structure

;
; Bug check on error
;
90$:	BUG_CHECK NOBUFPCKT,FATAL

	.SBTTL	CANCEL - CANCEL I/O ON UNIT
;++
; CANCEL - CANCEL I/O ON UNIT
;
; Functional description:
;
; This routine is used to cancel specific or all I/O pending on an XQ unit.
;
; Inputs:
;
;	R2 = Channel index number
;	R4 = PCB address (or zero)
;	R5 = UCB address
;	R8 = Cancel reason code (CAN$C_DASSGN or CAN$C_CANCEL)
;
;
;	IPL = FIPL
;
; Outputs:
;
;	R3-R5 are preserved.
;	R0-R2 are destroyed.
;
;--

CANCEL::				; Cancel I/O
	PUSHR	#^M<R3,R4,R6,R7>	; Save registers
	BBC	#UCB$V_XQ_SHARE,-	; Br if not a shared UCB
		 UCB$W_DEVSTS(R5),2$	;  perform regular $CANCEL
;
; Try to find SHR data structure
;
	BSBW	FIND_SHR		; Check PID and CHAN
	BNEQ	2$			; Br if NO MATCH, maybe last $DASSGN
;
;	Match found - clear inited bit and clean up all I/O on SHR data
;	structure.
;
;	We will Delete the SHR structure if this is a $DASSGN function
;	request. We will get this function when called from SYS$DASSGN
;	system service and so we will have to delete the SHR structure
;	and decrement the reference count. Note that the reference count
;	can never reach zero. Therefore, SYS$DASSGN will decrement the
;	reference count on exit and we will be called again. This time
;	there will be no match on the PID/CHAN and so the UCB will be
;	cleaned up and deleted.
;
	MOVL	R1,R6			; Copy SHR address
	MOVL	UCB$L_CRB(R5),R4	; Get CRB address
	MOVL	CRB$L_AUXSTRUC(R4),R4	; Get CDB address
	BSBW	CLEANUP_SHR		; Cleanup the SHR data structure

	ASSUME	CAN$C_DASSGN EQ 1
	DECL	R8			; Deassign request?
	BNEQ	10$			; Br if no - all done
	BSBW	DELETE_SHR		; Else, delete the SHR data stucture
					; And NOW perform like a NON-SHARED
					; unit.
;
; Non-shared unit - perform $CANCEL function.
;
2$:	TSTW	UCB$W_REFC(R5)		; Last reference?
	BNEQ	20$			; Br if no - do selective cancel
3$:	MOVL	UCB$L_CRB(R5),R4	; Get CRB address
	MOVL	CRB$L_AUXSTRUC(R4),R4	; Get CDB address
	BSBW	SHUTDOWN		; Shutdown entire unit
	BBS	#CDB_STS_V_INITED,-	; Br if QNA is still inited
		CDB_B_STS(R4),5$	;
	MNEGL	#1,CDB_G_PHA(R4)	; Reset physical address
	MNEGW	#1,CDB_G_PHA+4(R4)	;	...
;
; When this is the last reference to the unit, reset the CPID of the UCB.
;
5$:	BISW	S^#UCB$M_ONLINE,-	; Set the UNIT to ONLINE
		UCB$W_STS(R5)		;
	TSTL	UCB$L_XQ_CPID(R5)	; Did we save the Creator PID?
	BEQL	10$			; Br if not
	MOVL	UCB$L_XQ_CPID(R5),UCB$L_CPID(R5) ; Else, restore Creator PID
	CLRL	UCB$L_XQ_CPID(R5)	; Never again!!
10$:	POPR	#^M<R3,R4,R6,R7>	; Restore registers
	RSB
;
; Abort all associated receive packets on UCB queue
;
20$:	BBC	#UCB$V_ONLINE,-		; Br if not online
		 UCB$W_STS(R5),10$	;

	ASSUME	UCB$V_XQ_INITED  EQ  0
	BLBC	UCB$W_DEVSTS(R5),10$	; Br if not inited
	MOVAB	UCB$Q_XQ_RCVREQ(R5),R6	; Get address of receive queue
	BSBB	CHECKER			; Check packets on queue
;
; Abort all xmit requests on CDB queue
;
	MOVL	UCB$L_CRB(R5),R7	; Get CRB address
	MOVL	CRB$L_AUXSTRUC(R7),R7	; Get CDB address
	BBC	#CDB_STS_V_INITED,-	; Br if not inited
		CDB_B_STS(R7),10$	;
	DSBINT	UCB$B_DIPL(R5)		; Sync access to CDB
	MOVAB	CDB_Q_QUEUES(R7),R7	; Get start of queues
	MOVZBL	S^#CDB_C_ABORTS,R8	; Get number of queues we can abort on
30$:	MOVL	R7,R6			; Set address of next queue
	BSBB	CXB_CHECKER		; Check CXBs on this queue
	ADDL	#8,R7			; Skip to next queue
	SOBGTR	R8,30$			; Loop thru queues
	ENBINT				; Enable interrupts
	BRB	10$			; Exit from cancel
;
; Subroutine to scan queue for match on all packets
;
CHECKER:
	MOVL	(R6),R3			; Get next entry
10$:	CMPL	R3,R6			; End of list?
	BEQL	30$			; Br if yes
	BSBB	CHECKPKT		; Cancel if appropriate match
	BNEQ	20$			; Br if no match
	REMQUE	(R3),R3			; Remove from list
	BSBW	ABORT_PKT		; Complete the I/O request
	BRB	CHECKER			; Look for more
20$:	MOVL	(R3),R3			; Travel link
	BRB	10$			; Look for more			
30$:	RSB				; Return to caller
;
; Subroutine to check for specific cancel
;
CHECKPKT:
	TSTL	IRP$L_PID(R3)		; Is this an Internal IRP?
	BLSS	30$			; Br if yes
	BNEQ	10$			; Br if valid PID

	TSTL	R4			; Valid PCB?
	BNEQ	50$			; Br if yes, no match
	BRB	40$			; Else, test CHAN

10$:	CMPL	PCB$L_PID(R4),IRP$L_PID(R3) ; PID match?
	BNEQ	50$			; Br if no
	BRB	40$			; Try CHAN match

30$:	CMPL	PCB$L_PID(R4),UCB$L_XQ_PID(R5) ; IS this the starter's PID?
	BNEQ	50$			; Br if no
40$:	CMPW	R2,IRP$W_CHAN(R3)	; Channel match?
50$:	RSB				; Return to caller

CXB_CHECKER:
	MOVL	(R6),R3			; Get next entry
10$:	CMPL	R3,R6			; End of list?
	BEQL	30$			; Br if yes
	BSBB	CXB_CHECKPKT		; Cancel if appropriate match
	BNEQ	20$			; Br if no match
	REMQUE	(R3),R3			; Remove from CXB list
	ASSUME	CXB$L_T_IRP  EQ  CXB$L_T_UCB
	BLBS	CXB$L_T_IRP(R3),16$	; Br if not IRP address -> FAST interface
	MOVL	CXB$L_T_IRP(R3),R3	; Else, get IRP address
	MOVL	IRP$L_XQ_SETUP(R3),R0	; Get address of SETUP mode buffer
	BEQL	13$			; Br if none
	JSB	G^COM$DRVDEALMEM	; Else, deallocate the buffer
13$:	BSBW	ABORT_PKT		; Complete the I/O request
	BRB	CXB_CHECKER		; Look for more
16$:	PUSHL	R4			; Save R4
	MOVL	UCB$L_XQ_FFI(R5),R4	; Get FFI block address
	MOVZWL	#SS$_ABORT,R0		; Set status return
	JSB	@FFI$L_XMIT_DONE(R4)	; Complete the XMIT CXB
	POPL	R4			; Restore R4
	BRB	CXB_CHECKER		; Look for more
20$:	MOVL	(R3),R3			; Travel link
	BRB	10$			; Look for more			
30$:	RSB				; Return to caller
;
; Subroutine to check for specific cancel
;
CXB_CHECKPKT:
	MOVL	CXB$L_T_IRP(R3),R0	; Get (presumed) IRP address
	ASSUME	CXB$L_T_IRP  EQ  CXB$L_T_UCB
	BLBS	R0,80$			; Br if not an IRP address
	TSTL	IRP$L_PID(R0)		; Is this an Internal IRP?
	BLSS	30$			; Br if yes
	BNEQ	10$			; Br if valid PID

	TSTL	R4			; Valid PCB?
	BNEQ	50$			; Br if yes, no match
	BRB	40$			; Else, test CHAN

10$:	CMPL	PCB$L_PID(R4),IRP$L_PID(R0) ; PID match?
	BNEQ	50$			; Br if no
	BRB	40$			; Try CHAN match

30$:	CMPL	PCB$L_PID(R4),UCB$L_XQ_PID(R5) ; IS this the starter's PID?
	BNEQ	50$			; Br if no
40$:	CMPW	R2,IRP$W_CHAN(R0)	; Channel match?
50$:	RSB				; Return to caller

	; No IRP with CXB - FFI user

80$:	TSTL	R4			; No PCB?
	BEQL	50$			; Br if true - abort I/O
	MOVL	R3,R3			; Else, return Z-BIT clear
	RSB				; Return to caller


	.SBTTL	 SUBROUTINES TO FIND SHR DATA STRUCTURE GIVEN PCB AND CHAN
;+
; Subroutine to find SHR data structure for user
;
; Inputs:
;	R2 = Channel number
;	R4 = PCB address (or zero)
;	R5 = UCB address
;
; Outputs:
;	R1 = Address if SHR data structure if match
;	R0 is destroyed.
;	Z-Bit set then match.
;	Z-Bit clear then no match.
;-

FIND_SHR:				; Try to find shared user
	MOVL	UCB$L_XQ_DEFUSR(R5),R1	; Get address of default user
	BEQL	10$			; Br if no default user
	BSBB	90$			; Check for match
	BEQL	40$			; Br if match
10$:	MOVAB	UCB$Q_XQ_SHARE(R5),R0	; Save address of listhead
	MOVL	R0,R1			; Copy listhead address
	ASSUME	SHR_L_QFL EQ 0
20$:	MOVL	(R1),R1			; Get next in list
	CMPL	R1,R0			; Back to start of list?
	BEQL	30$			; Br if yes - no pid/chan match
	BSBB	90$			; Check for match
	BNEQ	20$			; Br if none
	BRB	40$			; Return in success
30$:	MOVL	R0,R0			; Return match failure
40$:	RSB

;+
; Subroutine to check if PID and SHR data base match up
;
; Inputs:
;	R1 = SHR address
;	R2 = Channel number
;	R4 = PCB address (or zero)
;
; Outputs:
;	Z-Bit set then match.
;	Z-Bit clear then no match.
;-

90$:					; Check for match with SHR data base
	TSTL	R4			; Valid PCB address?
	BNEQ	100$			; Br if yes
	TSTL	SHR_L_PID(R1)		; Zero PID?
	BNEQ	140$			; Br if not
	BRB	110$			; Try for CHAN
100$:	CMPL	PCB$L_PID(R4),SHR_L_PID(R1) ; PIDs match?
	BNEQ	140$			; Br if no - try for next
110$:	CMPW	R2,SHR_W_CHAN(R1)	; Channels match?
140$:	RSB				; Return to caller

	.SBTTL	FIND_POINT_UCB  - Find the point to point UCB
;++
; FIND_POINT_UCB - Find the point-to-point UCB
;
; Functional description:
;
; This routine is called to find the point-to-point UCB for some received
; message. This is only needed when the protocol is in the startup state.
;
; Inputs:
;
;	R1 = Protocol type (startup)
;	R2 = MSG buffer address
;	R4 = CDB address
;
;
;	IPL = FIPL
;
; Outputs:
;
;	R0 = Status return for request
;	All other registers are preserved
;--

FIND_POINT_UCB:					;% Find the point-to-point UCB
	PUSHR	#^M<R1,R2,R3,R5,R6>		;% Save registers
	CLRL	R0				;% Assume failure
	CMPW	#1,CXB$W_R_SIZE(R2)		;% Is buffer the right size?
	BNEQ	99$				;% Br if not!
	CMPB	#^XAA,CXB$W_R_SIZE+2(R2)	;% Is first byte start byte?
	BEQL	10$				;% Br if yes
	CMPB	#^XAB,CXB$W_R_SIZE+2(R2)	;% Is first byte stack byte?
	BNEQ	90$				;% Br if not
10$:	MOVL	CDB_L_UCB0(R4),R5		;% Get UCB address of unit 0
20$:	MOVL	UCB$L_LINK(R5),R5		;% Get address of next UCB
	BEQL	90$				;% Br if end of list
	ASSUME	UCB$V_XQ_INITED EQ 0
	BLBC	UCB$W_DEVSTS(R5),20$		;% Br if not inited
	CMPB	#NMA$C_LINPR_POI,-		;% Is this a point-to-point user?
		UCB$B_XQ_PRO(R5)		;%
	BNEQ	20$				;% Br if not
	CMPL	UCB$G_XQ_DES(R5),-		;% Does the destination match?
		CXB$G_R_SRC(R2)			;%
	BNEQ	20$				;% Br if not
	CMPW	UCB$G_XQ_DES+4(R5),-		;% Still match?
		CXB$G_R_SRC+4(R2)		;%
	BNEQ	20$				;% Br if not
	CMPB	#^XAB,CXB$W_R_SIZE+2(R2)	;% Is first byte stack byte?
	BNEQ	40$				;% Br if no
	BBSC	#UCB$V_XQ_START,UCB$W_DEVSTS(R5),30$ ;% Clear Start state
	BBCC	#UCB$V_XQ_STACK,UCB$W_DEVSTS(R5),60$ ;% We were in RUN, ignore
30$:	MOVL	UCB$L_XQ_STIRP(R5),R2		;% Get start IRP
	BSBW	BLD_STRT_IRP			;% Send stack!
	BRB	60$				;% Then send data
40$:	CMPB	#^XAA,CXB$W_R_SIZE+2(R2)	;% Is first byte start byte?
99$:	BNEQ	90$				;% Br if not, ignore it
	BITW	#UCB$M_XQ_START!UCB$M_XQ_STACK,- ;% Are we in startup states?
		UCB$W_DEVSTS(R5)
	BEQL	120$				;% Br if not, start recvd in RUN
	CLRBIT	#UCB$V_XQ_START,UCB$W_DEVSTS(R5);% Clear starting bit
	MOVL	UCB$L_XQ_STIRP(R5),R2		;% Get start IRP
	BSBW	BLD_STRT_IRP			;% Send stack!
	BRB	80$				;% Wait for stack
60$:	REMQUE	@UCB$Q_XQ_XMTREQ(R5),R3		;% Get transmit IRPs
	BVS	70$				;% Br if no more
	INSQUE	(R3),@CDB_Q_XMTREQ+4(R4)	;% Insert IRPs onto xmit queue
	BRB	60$				;% Look for more
70$:	BSBW	XMT_ALT_START			;% Startup the xmit process
80$:	MOVZBL	#1,R0				;% Return success

90$:	POPR	#^M<R1,R2,R3,R5,R6>		;% Restore registers
	RSB					;% Return to caller

;
; Start received in run mode
;
120$:	CMPL	UCB$Q_XQ_SHARE(R5),-		;% Is limited queue empty?
		@UCB$Q_XQ_SHARE(R5)		;%
	BEQL	90$				;% Br if yes, no IRPs
	CLRBIT	#XM$V_STS_ACTIVE,UCB$L_DEVDEPEND(R5) ;% Clear active bit
	SETBIT	#XM$V_ERR_START,UCB$L_DEVDEPEND(R5) ;% Indicate cause of error
	BICW	#UCB$M_XQ_START!UCB$M_XQ_STACK,-;% Clear start and stack flags
		UCB$W_DEVSTS(R5)		;%
	CLRBIT	#UCB$V_XQ_RUN,UCB$W_DEVSTS(R5)	;% Clear the RUN flag
	MOVL	UCB$Q_XQ_SHARE(R5),R6		;% Get address of share structure
	BSBW	CLEANUP_SHR			;% Cleanup all pending I/O
	BRB	90$				;% Exit
	

	.SBTTL	ADD_MULTI - ADD UP ALL THE MULTICAST ADDRESSES
;++
; ADD_MULTI - ADD UP ALL THE MULTICAST ADDRESSES
;
; Functional description:
;
; This routine is called to combine all the per protocol type multicast
; addresses into a single list in the CDB. If the sum of all multicast
; addresses is greater than the QNA can manage, then an error is returned.
;
; Inputs:
;
;	R5 = UCB address
;
;
;	IPL = FIPL
;
; Outputs:
;
;	R0 = Status return for request
;	R1,R2 are destroyed
;	R3-R5 are preserved
;
; Implicit outputs:
;
;	CDB_B_MLTTBL = Number of multicast addresses in CDB_G_MLTTBL
;	CDB_G_MLTTBL = New multicast address list
;--

ADD_MULTI:				; Add up all the multicast addresses
	PUSHR	#^M<R3,R4,R6,R7>	; Save registers
	MOVL	UCB$L_CRB(R5),R4	; Get CRB address
	MOVL	CRB$L_AUXSTRUC(R4),R4	; Get CDB address
	CLRB	CDB_B_MLTTBL(R4)	; Reset number of entries
	PUSHQ	R4			; Save CDB and UCB addresses
	MOVC5	#0,CDB_G_MLTTBL(R4),#0,- ; Zero the structure
		#6*MAX_C_MLT,CDB_G_MLTTBL(R4) ;
	POPQ	R4			; Restore CDB and UCB addresses
	MOVZBL	#MAX_C_MLT+1,R3		; Error if 1 more multicast address
					;  than we can handle
	MNEGL	#1,R0			; Assume success
	MOVAB	CDB_G_MLTTBL(R4),R6	; Get address of Multicast table
	MOVL	UCB$L_DDB(R5),R7	; Get DDB address
	MOVL	DDB$L_UCB(R7),R7	; Get 1st UCB address
10$:	MOVL	UCB$L_LINK(R7),R7	; Get next UCB in list
	BEQL	50$			; Br if no more UCB's

	ASSUME	UCB$V_XQ_INITED  EQ  0
	BLBC	UCB$W_DEVSTS(R5),10$	; Br if not inited
	MOVAB	UCB$G_XQ_MULTI(R7),R2	; Get address of Multicast list
	MOVZBL	UCB$B_XQ_MULTI(R7),R1	; Set number addresses for UCB
20$:	TSTL	(R2)			; Is this field unused?
	BNEQ	25$			; Br if no
	TSTW	4(R2)			; Really?
	BEQL	30$			; Yes - skip it
25$:	DECB	R3			; One less available slot in CDB
	BEQL	40$			; Br if none left - error
	MOVL	(R2),(R6)+		; Else, insert next address
	MOVW	4(R2),(R6)+		;	...
	INCB	CDB_B_MLTTBL(R4)	; Count one more in list
	CMPB	CDB_B_MLTTBL(R4),-	; Is there enough room?
		 #MAX_C_MLT		;	...
	BGTRU	40$			; Br if no - error
30$:	ADDL	#6,R2			; Skip to next entry
	SOBGTR	R1,20$			; Br if more
	BRB	10$			; Else, skip to next UCB

40$:	CLRL	R0			; Return failure
50$:	POPR	#^M<R3,R4,R6,R7>	; Restore registers
	RSB

	.SBTTL	MOVE_MULTI - COPY THE MULTICAST ADDRESS LIST
;++
; MOVE_MULTI - COPY THE MULTICAST ADDRESS LIST
;
; Functional description:
;
; This routine is called to copy the multicast address list from the
; generation table to the actual list.
;
; Inputs:
;
;	R4 = CDB address
;
; Outputs:
;
;	All registers are preserved.
;
; Implicit outputs:
;
;	CDB_B_MULTI = Number of multicast addresses in CDB_G_MULTI
;	CDB_G_MULTI = New multicast address list
;--

MOVE_MULTI:				; Move the multicast address list
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	; Save registers
	MOVC3	#MAX_C_MLT*6,CDB_G_MLTTBL(R4),CDB_G_MULTI(R4) ; Copy list
	POPR	#^M<R0,R1,R2,R3,R4,R5>	; Restore registers
	MOVB	CDB_B_MLTTBL(R4),CDB_B_MULTI(R4) ; Set number of entries
	RSB

	.SBTTL	ROUTINES TO SAVE/RESTORE UCB'S MULTICAST ADDRESS LIST
;++
; ROUTINES TO SAVE/RESTORE UCB'S MULTICAST ADDRESS LIST
;
; Functional description:
;
; These routines are called to save or restore the multicast address list
; in the UCB.
;
; Inputs:
;
;	R5 = UCB address
;
; Outputs:
;
;	All registers are preserved.
;--

SAV_MULTI:				; Save multicast address list
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	; Save registers
	MOVC3	#6*MAX_C_MLT,UCB$G_XQ_MULTI(R5),- ; Save multicast addresses
		UCB$G_XQ_MLTTBL(R5)	;	...
	POPR	#^M<R0,R1,R2,R3,R4,R5>	; Restore registers
	MOVB	UCB$B_XQ_MULTI(R5),-	; Save count of multicast addresses
		UCB$B_XQ_MLTTBL(R5)	;	...
	RSB				; Return to caller

RES_MULTI:				; Restore multicast address list
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	; Save registers
	MOVC3	#6*MAX_C_MLT,UCB$G_XQ_MLTTBL(R5),- ; Restore multicast addresses
		UCB$G_XQ_MULTI(R5)	;	...
	POPR	#^M<R0,R1,R2,R3,R4,R5>	; Restore registers
	MOVB	UCB$B_XQ_MLTTBL(R5),-	; Restore count of multicast addresses
		UCB$B_XQ_MULTI(R5)	;	...
	RSB				; Return to caller

	.SBTTL	VALIDATE_P2 - VALIDATE P2 BUFFER PARAMETERS
 
;++
; VALIDATE_P2 - Validate P2 buffer parameters
;
; This routine is called to validate the P2 buffer parameters. The parameters
; are checked against a parameter table which verifies that the minimum value
; and maximum value is not violated, and that invalid status flags are not set.
; If the parameter is a string, then the string must not exceed the maximum
; string count for this parameter.
;
; Inputs:
;
;	R2 = Address of verification table
;	R3 = IRP address
;	R5 = UCB address
;
;
; Outputs:
;
;	R0 = Status return for request
;
; If no error:
;	R1 = Address of parameter verification table
; If error:
;	R1 = Bad parameter value
;
;	All other registers are preserved.
;
;--
 
VALIDATE_P2::				; Validate P2 buffer parameters
	PUSHR	#^M<R2,R3,R4,R6,R7,R8,R9> ; Save registers
	MOVL	IRP$L_SVAPTE(R3),R6	; Get system P2 buffer address
	BNEQ	20$			; Br if a system buffer
10$:	BRW	150$			; Else, leave

20$:	MOVL	UCB$L_CRB(R5),R4	; Get CRB address
	MOVL	CRB$L_AUXSTRUC(R4),R4	; Get CDB address
	MOVL	P2B_L_POINTER(R6),R6	; Point to start of P2 data
	MOVZWL	IRP$W_BCNT(R3),R8	; Get size of P2 buffer
;
; Loop to check next parameter in P2 buffer
;
30$:	SUBL	#2,R8			; Can we get another parameter?
	BLSS	10$			; Br if no - all done
	MOVZWL	(R6)+,R1		; Get parameter type from P2
;
; *** NOTE - R2 MUST be the very first item on the top of the stack
;
	MOVL	(SP),R7			; Get verification table address
;
; Loop to check P2 buffer parameter to Line parameter table
;
	ASSUME	PRM_W_TYPE EQ 0
40$:	MOVW	(R7)+,R0		; Get parameter type code
	BNEQ	45$			; Br if NOT end of verify table
43$:	BRW	170$			; Else exit in error

45$:	ASSUME	PRM_B_FLAG EQ PRM_W_TYPE+2
	MOVZBL	(R7)+,R9		; Get flags byte
	BICW	#^C<PRM_TYP_M_CODE>,R0	; Clear all but type code
	CMPW	R1,R0			; Parameters match?
	BEQL	50$			; Br if yes
	ADDL	#2,R7			; Skip offset word
	SKIP	PRM_FLG_V_MIN,R9,R7	; Skip minimum value
	SKIP	PRM_FLG_V_MAX,R9,R7	; Skip maximum value
	SKIP	PRM_FLG_V_INVALID,R9,R7	; Skip invalid flags
	BRB	40$			; Try next parameter
;
; Match found - nullify if same value & check min,max,valid,invalid
;
50$:	MOVW	(R7)+,R0		; Get offset + width
	EXTZV	#PRM_OFF_V_WIDTH,-	; Get width only
		#PRM_OFF_S_WIDTH,R0,R2	;	...
	EXTZV	#PRM_OFF_V_VALUE,-	; Get offset only
		#PRM_OFF_S_VALUE,R0,R0	;	...
	BBS	#PRM_FLG_V_CDB,R9,55$	; Br if CDB datum
	ADDL	R5,R0			; Compute offset in UCB
	BRB	57$			; Continue
55$:	ADDL	R4,R0			; Compute offset in CDB
57$:	ASSUME	PRM_B_FLAG EQ PRM_W_TYPE+2
	BBS	#PRM_TYP_V_STRING,-5(R7),95$ ; Br if string parameter
	SUBL	#4,R8			; Must be longword value
	BLSS	43$			; Br if error
	MOVL	(R6)+,R3		; Get parameter value
	CASE	R2,TYPE=B,LIMIT=#1,<-	; Br to handler
		60$,-			;   Byte value
		70$,-			;   Word value
		80$>			;   Longword value
;
; Byte value in structure
;
60$:	CMPB	R3,(R0)			; Is this the same?
	BRB	90$			; Check result
;
; Word value
;
70$:	CMPW	R3,(R0)			; Is this the same?
	BRB	90$			; Check result
;
; Longword value
;
80$:	CMPL	R3,(R0)			; Is this the same?
90$:	BNEQ	100$			; Br if no - continue checks
	CMPW	R1,#NMA$C_PCLI_PTY	; Is this the protocol type?
	BEQL	91$			; Br if yes - always store this
	CLRW	-6(R6)			; Nullify the parameter code
91$:	BRW	140$			; Try next parameter - skip checks
93$:	BRW	170$			; LONNGGG Branch to 170$
;
; String value
;
95$:	SUBL	#2,R8			; Can we fetch string length?
	BLSS	93$			; Br if no - error
	MOVZWL	(R6)+,R3		; Get string length
	SUBL	R3,R8			; Is there room for string?
	BLSS	93$			; Br if no - error
	CMPW	R3,R2			; Is the string too long?
	BGTRU	93$			; Br if yes - error
	ADDL	R3,R6			; Skip past string
	CMPW	#NMA$C_PCLI_DES,R1	; Is this the destination address?
	BEQL	96$			; Br if yes
	CMPW	#NMA$C_PCLI_PHA,R1	; Is this the physical address?
	BNEQ	97$			; Br if not
96$:	BSBW	VALID_PHYAD		; Validate the physical address
	BLBC	R0,170$			; Br if error in physical address
	BRB	140$			; Else, continue checking
97$:	CMPW	#NMA$C_PCLI_MCA,R1	; Is this the multicast address list?
	BNEQ	130$			; Br if no - okay
	BSBW	VALID_MULTI		; Validate the multicast address list
	BLBC	R0,170$			; Br if error
	DSBINT	UCB$B_FIPL(R5)		; Sync access to UCB
	BSBW	SAV_MULTI		; Save the multicast addresses
	PUSHR	#^M<R6,R9>		; Save registers
	SUBL	R3,R6			; Backup pointer to start of list
	MOVL	R3,R9			; Setup string count in R9
	BSBW	SET_MULTI		; See if we can set new addresses
					; R0 = return status
	POPR	#^M<R6,R9>		; Restore registers
	BSBW	RES_MULTI		; Restore the multicast list
	ENBINT				; Restore IPL
	BLBC	R0,170$			; Br if error
	BRB	130$			; Check if state okay

100$:	BBC	#PRM_FLG_V_MIN,R9,110$	; Br if no minimum value
	CMPW	R3,(R7)+		; Is the value too small?
	BLSSU	170$			; Br if yes - error
110$:	BBC	#PRM_FLG_V_MAX,R9,130$	; Br if no maximum value
	CMPW	R3,(R7)+		; Is the value too big?
	BGTRU	170$			; Br if yes - error
130$:	BBC	#PRM_FLG_V_INVALID,R9,140$ ; Br if no invalid flags
	MOVW	(R7)+,R2		; Get invalid flags
	BBS	#PRM_FLG_V_CDB,R9,135$	; Br if CDB datum
	BITW	R2,UCB$W_DEVSTS(R5)	; Check UCB invalid bits
	BRB	137$			; Continue
135$:	TSTL	R4			; Is CDB present?
	BEQL	140$			; Br if no - okay
	BITB	R2,CDB_B_STS(R4)	; Check CDB invalid bits
137$:	BNEQ	170$			; Br on error
140$:	BRW	30$			; Loop if more parameters
 
150$:	MOVZBL	S^#SS$_NORMAL,R0	; Set success return
	BRB	180$			; And return
 
170$:	MOVZBL	S^#SS$_BADPARAM,R0	; Set error return
180$:	POPR	#^M<R2,R3,R4,R6,R7,R8,R9> ; Restore registers
	RSB				; Return to caller

	.SBTTL	CHANGE_PARAM - UPDATE UCB/CDB BASED ON P2 BUFFER PARAMETERS
 
;++
; CHANGE_PARAM - Update UCB/CDB with P2 buffer parameters
;
; This routine is called to update the UCB/CDB with the P2 buffer parameters.
; The parameters are stored in the appropriate cells of the UCB/CDB.
; This routine can only modify the LINE PARAMETERS.
;
; Inputs:
;
;	R2 = Address of verification table
;	R3 = IRP address
;	R5 = UCB address
;
;	IPL = FIPL
;
; Outputs:
;
;	R0 = destroyed.
;	All other registers are preserved.
;
;--
 
CHANGE_PARAM:				; Change the UCB/CDB parameters
	PUSHR	#^M<R1,R2,R3,R4,R6,R7,R8,R9,R10> ; Save registers
	MOVL	R2,R10			; Save table address
	MOVL	IRP$L_SVAPTE(R3),R6	; Get system P2 buffer address
	BNEQ	5$			; Br if system buffer
3$:	BRW	120$			; Else, return

5$:	MOVL	UCB$L_CRB(R5),R4	; Get CRB address
	MOVL	CRB$L_AUXSTRUC(R4),R4	; Get CDB address
	MOVL	P2B_L_POINTER(R6),R6	; Point to start of data
	MOVZWL	IRP$W_BCNT(R3),R8	; Get size of P2 buffer
;
; Loop to get next parameter from P2 buffer
;
10$:	SUBL	#2,R8			; Try to get next parameter
	BLSS	3$			; Br if not there
	MOVZWL	(R6)+,R0		; Get parameter type from P2
	BEQL	90$			; Br if null value parameter
	MOVL	R10,R7			; Get verification table address
	CMPW	R0,#NMA$C_PCLI_PTY	; Is this the protocol type?
	BNEQ	20$			; Br if not
	BISW	#UCB$M_XQ_PROTYP,-	; Indicate that protocol type specified
		UCB$W_DEVSTS(R5)	;
;
; Loop to store buffer parameter in UCB/CDB
;
	ASSUME	PRM_W_TYPE EQ 0
20$:	MOVZWL	(R7)+,R1		; Get parameter type code
	BEQL	90$			; Br if end of verify table
	BICW	#^C<PRM_TYP_M_CODE>,R1	; Clear all but type code
	ASSUME	PRM_B_FLAG EQ PRM_W_TYPE+2
	MOVZBL	(R7)+,R9		; Get flags byte
	CMPW	R0,R1			; Parameters match?
	BEQL	30$			; Br if yes
	ADDL	#2,R7			; Skip offset word
	SKIP	PRM_FLG_V_MIN,R9,R7	; Skip minimum value
	SKIP	PRM_FLG_V_MAX,R9,R7	; Skip maximum value
	SKIP	PRM_FLG_V_INVALID,R9,R7	; Skip invalid flags
	BRB	20$			; Try next parameter
;
; Match found - nullify if same value & check min,max,valid,invalid
;
30$:	MOVW	(R7)+,R1		; Get offset + width
	EXTZV	#PRM_OFF_V_WIDTH,-	; Get width only
		#PRM_OFF_S_WIDTH,R1,R2	;	...
	EXTZV	#PRM_OFF_V_VALUE,-	; Get offset only
		#PRM_OFF_S_VALUE,R1,R1	;	...
	BBS	#PRM_FLG_V_CDB,R9,40$	; Br if CDB datum
	ADDL	R5,R1			; Compute offset in UCB
	BRB	50$			; Continue
40$:	ADDL	R4,R1			; Compute offset in CDB
50$:	ASSUME	PRM_B_FLAG EQ PRM_W_TYPE+2
	BBS	#PRM_TYP_V_STRING,-5(R7),100$ ; Br if string data
	SUBL	#4,R8			; Can we get value?
	BLSS	120$			; Br if no - exit
	MOVL	(R6)+,R3		; Get parameter value
	CASE	R2,TYPE=B,LIMIT=#1,<-	; Br to handler
		60$,-			;   Byte value
		70$,-			;   Word value
		80$>			;   Longword value
;
; Byte, word, longword value in structure
;
60$:	MOVB	R3,(R1)			; Store byte value
65$:	BRW	10$			; Check remainder
70$:	MOVW	R3,(R1)			; Store word value
	BRW	10$			; Check remainder
80$:	MOVL	R5,(R1)			; Store longword value
	BRW	10$			; See if more left in P2 buffer
;
; Unknown or invalidated parameter
;
90$:	ADDL	#4,R6			; Skip value parameter
	SUBL	#4,R8			; Assume a value parameter
	BGTR	65$			; Br if more
	BRB	120$			; Else, all done
;
; String parameter in structure
;
100$:	SUBL	#2,R8			; Can we get string?
	BLSS	120$			; Br if no - exit
	MOVZWL	(R6)+,R9		; Get string length
	SUBL	R9,R8			; Can we read entire string?
	BLSS	120$			; Br if no - exit
	CMPW	#NMA$C_PCLI_DES,R0	; Is this the destination address?
	BNEQ	101$			; Br if no
	BSBW	SET_DESAD		; Else, set new destination address
	BRB	110$			; Continue
101$:	CMPW	#NMA$C_PCLI_PHA,R0	; Is this the physical address?
	BNEQ	103$			; Br if no
	BSBW	SET_PHYAD		; Else set new physical address
	BRB	110$			; Continue
103$:	CMPW	#NMA$C_PCLI_MCA,R0	; Is this the multicast address list?
	BNEQ	105$			; Br if no
	BSBW	SET_MULTI		; Else, set up new UCB multicast list
	BRB	110$			; Continue
105$:	PUSHR	#^M<R1,R2,R3,R4,R5>	; Save registers
	MOVC3	R9,(R6),(R1)		; Store string
	POPR	#^M<R1,R2,R3,R4,R5>	; Restore registers
110$:	ADDL	R9,R6			; Point past the string in P2 buffer
	BRW	10$			; Try for more in P2 buffer

120$:	POPR	#^M<R1,R2,R3,R4,R6,R7,R8,R9,R10> ; Restore registers
	RSB				; Return to caller

	.SBTTL	RETURN_P2,  Return UCB/CDB buffer parameters
 
;++
; RETURN_P2 - Return P2 buffer parameters
;
; This routine is called to return the UCB/CDB buffer parameters.
;
; Inputs:
;
;	R3 = IRP address
;	R5 = UCB address
;
; Implicit inputs:
;
;	IRP$L_XQ_P2BUF(R3) = User P2 buffer address
;	IRP$W_XQ_USERSIZ(R3) = User P2 buffer size
;
; Outputs:
;
;	R0 = Size of buffer returned
;	All other registers are preserved.
;
;--
 
RETURN_P2::				; Return P2 buffer parameters
	PUSHR	#^M<R1,R2,R3,R4,R6,R7,R8,R9> ; Save registers
	CLRL	R0			; Assume no P2 buffer given
	MOVL	IRP$L_XQ_P2BUF(R3),R6	; Get user P2 buffer address
	BNEQ	5$			; Br if given
	BRW	70$			; Else, return

5$:	MOVL	UCB$L_CRB(R5),R4	; Get CRB address
	MOVL	CRB$L_AUXSTRUC(R4),R4	; Get CDB address
	MOVZWL	IRP$W_XQ_USERSIZ(R3),R8	; Get size of user buffer
	PUSHL	R6			; Save start of data address
	PUSHL	R3			; Save IRP address
	MOVAB	LINE_PARAM,R1		; Get address of verification talbe
;
; Loop to return next parameter
;
	ASSUME	PRM_W_TYPE EQ 0
10$:	MOVW	(R1)+,R7		; Get parameter type code
	BNEQ	11$			; Br if end of verify table
	BRW	65$			; ...

11$:	BICW3	#^C<PRM_TYP_M_CODE>,R7,R9 ; Get only the type code
	MOVZBL	(R1)+,R3		; Get flags byte
	MOVW	(R1)+,R0		; Get offset + width
;
; We will only return NMA$C_PCLI_DES to the SHARED-LIMITED users.
;
	CMPW	#NMA$C_PCLI_DES,R9	; Is this a point-to-point parameter?
	BNEQ	13$			; Br if not
	CMPB	#NMA$C_ACC_LIM,UCB$B_XQ_ACC(R5) ; Is this a SHARED-LIMITED user?
	BNEQ	50$			; Br if not, else return parameter
13$:	EXTZV	#PRM_OFF_V_WIDTH,-	; Get width only
		#PRM_OFF_S_WIDTH,R0,R2	;	...
	EXTZV	#PRM_OFF_V_VALUE,-	; Get offset only
		#PRM_OFF_S_VALUE,R0,R0	;	...
	BBS	#PRM_FLG_V_CDB,R3,15$	; Br if CDB datum
	ADDL	R5,R0			; Compute offset in UCB
	BRB	17$			; Continue
15$:	TSTL	R4			; Is CDB given?
	BEQL	50$			; Br if no
	ADDL	R4,R0			; Compute offset in CDB
17$:	SUBL	#2,R8			; Any room left in buffer?
	BLSS	60$			; Br if no - all done
	MOVW	R7,(R6)+		; Return parameter
	BBS	#PRM_TYP_V_STRING,-5(R1),55$ ; Br if string parameter
	SUBL	#4,R8			; Any room left?
	BLSS	60$			; Br if no - all done
	CASE	R2,TYPE=B,LIMIT=#1,<-	; Br to handler
		20$,-			;   Byte value
		30$,-			;   Word value
		40$>			;   Longword value
;
; Byte, word, longword value in structure
;
20$:	MOVZBL	(R0),(R6)+		; Store byte value
	BRB	50$			; 
30$:	MOVZWL	(R0),(R6)+		; Store word value
	BRB	50$			;
40$:	MOVL	(R0),(R6)+		; Store longword value
50$:	SKIP	PRM_FLG_V_MIN,R3,R1	; Skip minimum value
	SKIP	PRM_FLG_V_MAX,R3,R1	; Skip maximum value
	SKIP	PRM_FLG_V_INVALID,R3,R1	; Skip invalid flags
	BRB	10$			; Try for more parameters
;
; String value in structure
;
55$:	CMPW	#NMA$C_PCLI_MCA,R9	; Is this the multicast address list?
	BNEQ	57$			; Br if no
	BSBW	RETURN_MULTI		; Else, return multicast address list
	BRB	50$			; Try for more parameters
57$:	SUBL	#8,R8			; Any room left?
	BLSS	60$			; Br if no - all done
	MOVZBW	#6,(R6)+		; Store string size
	MOVL	(R0)+,(R6)+		; Move data
	MOVW	(R0)+,(R6)+		;	...
	BRB	50$			; Try for more parameters

60$:	MOVL	(SP),R3			; Get IRP address
	MOVW	#SS$_BUFFEROVF,IRP$W_XQ_STATUS(R3) ; Return error status
65$:	POPL	R3			; Pop stack
	SUBL3	(SP)+,R6,R0		; Return size of parameters
70$:	POPR	#^M<R1,R2,R3,R4,R6,R7,R8,R9> ; Restore registers
	RSB				; Return to caller

	.SBTTL	VALID_MULTI - VALIDATE THE MULTICAST ADDRESS LIST

;++
; VALID_MULTI - VALIDATE THE MULTICAST ADDRESS LIST
;
; Functional description:
;
; This routine checks all address in the multicast address list to make sure
; that the logical address bit (lsb) is on.
;
; Inputs:
;
;	R3 = Size of multicast string list
;	R4 = CDB address
;	R5 = UCB address
;	R6 = Address past multicast strings
;
; Outputs:
;
;	R0 = Low bit clear if invalid address in list
;	All other registers are preserved.
;
;--

VALID_MULTI:				; Validate the multicast address list
	PUSHR	#^M<R2,R3,R6>		; Save some registers
	MNEGL	#1,R0			; Assume success
	SUBL	R3,R6			; Point back at start of list
	SUBL	#2,R3			; Can we read modifier word?
	BLSS	20$			; Br if no - error
;
; Make sure modifier word is valid - non-zero and less than or equal to
; NMA$C_LINMC_CAL
;
	ASSUME	NMA$C_LINMC_SET EQ 1
	ASSUME	NMA$C_LINMC_CLR EQ 2
	ASSUME	NMA$C_LINMC_CAL EQ 3
	MOVW	(R6)+,R2		; Get modifier value
	BEQL	20$			; Br if zero - illegal
	CMPW	R2,#NMA$C_LINMC_CAL	; Is the modifier okay?
	BGTRU	20$			; Br if no - error
	BEQL	30$			; Br if "CLEAR ALL" - ignore strings
	DIVL	#6,R3			; Calculate number of strings
	BEQL	30$			; Br if none
10$:	BLBC	(R6),20$		; Br if not a logical address
	CMPL	(R6)+,R0		; Do low order 32 bits = -1?
	BNEQ	15$			; Br if no - okay
	CMPW	(R6),R0			; Do high order 16 bits = -1?
	BEQL	20$			; Br if yes - illegal
15$:	ADDL	#2,R6			; Point to next multicast address
	SOBGTR	R3,10$			; Loop if more
	BRB	30$			; Exit with success

20$:	CLRL	R0			; Return error
30$:	POPR	#^M<R2,R3,R6>		; Restore registers
	RSB

	.SBTTL	VALID_PHYAD - VALIDATE THE PHYSICAL ADDRESS

;++
; VALID_PHYAD - VALIDATE THE PHYSICAL ADDRESS
;
; Functional description:
;
; This routine checks the physical address to make sure the LSB is clear and
; that the modifier word is valid.
;
; Inputs:
;
;	R1 = Parameter type code
;	R3 = Size of string
;	R4 = CDB address
;	R5 = UCB address
;	R6 = Address past physical address string
;
; Outputs:
;
;	R0 = Low bit clear if invalid address in list
;	All other registers are preserved.
;
;--

VALID_PHYAD:				; Validate the physical address
	PUSHR	#^M<R2,R3,R6>		; Save some registers
	MNEGL	#1,R0			; Assume success
	SUBL	R3,R6			; Point back at start of list
	SUBL	#2,R3			; Can we read modifier word?
	BLSS	30$			; Br if no - error

;
; Make sure modifier word is valid.
;

	ASSUME	NMA$C_LINMC_SET EQ 1
	ASSUME	NMA$C_LINMC_CLR EQ 2
	ASSUME	NMA$C_LINMC_CAL EQ 3
	ASSUME	NMA$C_LINMC_SDF EQ 4
	MOVZWL	(R6)+,R2		; Get modifier value
	$DISPATCH	R2,TYPE=B,-	; Dispatch on modifier value
		<-
	    	<NMA$C_LINMC_SET 20$>,-	; Set the address
	    	<NMA$C_LINMC_CLR 40$>,-	; Clear the address
	    	<NMA$C_LINMC_CAL 30$>,-	; 3 - invalid value
	    	<NMA$C_LINMC_SDF 10$>,-	; 4 - check it out more
		>
	BRB	30$			; Any other values are invalid
	
10$:	CMPW	#NMA$C_PCLI_PHA,R1	; Set to def physical addr requested?
	BNEQ	30$			; Return failure if not
	BRB	40$			; Else, success

20$:	CMPL	#6,R3			; Is string size okay?
	BNEQ	30$			; Br if not
	BLBC	(R6),40$		; Br if a physical address

30$:	CLRL	R0			; Return error
40$:	POPR	#^M<R2,R3,R6>		; Restore registers
	RSB

	.SBTTL	SET_MULTI - SET THE UCB MULTICAST ADDRESS LIST

;++
; SET_MULTI - SET THE UCB MULTICAST ADDRESS LIST
;
; Functional description:
;
; This routine sets up the multicast addresses in the UCB.
;
; Inputs:
;
;	R4 = CDB address
;	R5 = UCB address
;	R6 = Address of multicast addresses to be set or cleared
;	R9 = Size of multicast list
;
;	IPL = FIPL
;
; Outputs:
;
;	R0 = Status return for request
;	All registers are preserved.
;
;--

SET_MULTI:				; Set up the UCB multicast address list
	PUSHR	#^M<R1,R2,R3,R6,R9>	; Save registers
	SUBL	#2,R9			; Can we read the modifier word?
	BLSS	90$			; Br if no - exit
	DIVL	#6,R9			; Calculate number of addresses
	MOVZWL	(R6)+,R1		; Get the modifier
	ASSUME	NMA$C_LINMC_SET EQ 1
	ASSUME	NMA$C_LINMC_CLR EQ 2
	ASSUME	NMA$C_LINMC_CAL EQ 3
	CASE	R1,TYPE=B,LIMIT=#1,<-	; Dispatch on modifier
		10$,-			; Set the address(es)
		40$,-			; Clear the address(es)
		70$>			; Clear ALL addresses
;
; Set address from list
;
10$:	TSTL	R9			; Any addresses present?
	BEQL	90$			; Br if no - exit
20$:	MOVL	(R6)+,R1		; Get multicast address
	MOVW	(R6)+,R2		;	...
	BSBW	MATCH_ADDRESS		; Try to find address in table
	BLBS	R0,30$			; Br if present - skip it
	BSBB	FIND_MLTENTRY		; Find entry in UCB multicast table
	BLBC	R0,100$			; Br if none - leave in error
	MOVL	R1,(R3)+		; Insert new address
	MOVW	R2,(R3)+		;	...
	INCB	UCB$B_XQ_MULTI(R5)	; Count one more address
30$:	SOBGTR	R9,20$			; Br if more
	BRB	90$			; All done
;
; Clear address from list
;
40$:	TSTL	R9			; Any addresses present?
	BEQL	90$			; Br if no - exit
50$:	MOVL	(R6)+,R1		; Get multicast address
	MOVW	(R6)+,R2		;	...
	BSBW	MATCH_ADDRESS		; Try to find address in table
	BLBC	R0,60$			; Br if not present - skip it
	CLRL	(R3)+			; Mark slot as not in use
	CLRW	(R3)+			;	...
	DECB	UCB$B_XQ_MULTI(R5)	; Count one less address
	BSBW	SQUEEZ_MULTI		; Squeeze up the multicast list
60$:	SOBGTR	R9,50$			; Br if more
	BRB	90$			; All done
;
; Clear all multicast addresses
;
70$:	CLRB	UCB$B_XQ_MULTI(R5)	; Reset number of multicast addresses
	MOVZBL	#MAX_C_MLT*3,R1		; Get number of words in multicast list
	MOVAB	UCB$G_XQ_MULTI(R5),R2	; Get address of multicast addresses
80$:	CLRW	(R2)+			; Init multicast address list
	SOBGTR	R1,80$			; Loop if more

90$:	MOVZBL	S^#SS$_NORMAL,R0	; Return success
100$:	POPR	#^M<R1,R2,R3,R6,R9>	; Restore registers
	RSB				; Return to caller

;+
; FIND_MLTENTRY - FIND EMPTY SLOT IN UCB MULTICAST ADDRESS LIST
;
; Inputs:
;
;	R5 = UCB address
;
; Outputs:
;
;	R0 = Status return for request
;	R3 = Address of available slot if successful
;-
FIND_MLTENTRY:
	PUSHL	R1			; Save R1
	MNEGL	#1,R0			; Assume success
	MOVAB	UCB$G_XQ_MULTI(R5),R3	; Get address of multicast list
	MOVZBL	#MAX_C_MLT,R1		; Get maximum number of addresses
10$:	TSTL	(R3)+			; Empty slot?
	BNEQ	20$			; Br if no - skip to next entry
	TSTW	(R3)			; Really?
	BEQL	30$			; Br if yes - success
20$:	ADDL	#2,R3			; Skip to next address
	SOBGTR	R1,10$			; Br if more to try

	CLRL	R0			; Return failure
30$:	SUBL	#4,R3			; Back up pointer
	POPL	R1			; Restore registers
	RSB

;+
; SQUEEZ_MULTI - SQUEEZE UP THE MULTICAST ADDRESS LIST
;
; Functional description:
;
; The first empty slot is searched for in the multicast address list and
; the list is squeezed from that point down.
;
; Inputs:
;
;	R5 = UCB address
;
; Ouputs:
;
;	None
;
;--
SQUEEZ_MULTI:				; Squeeze down the multicast address list
	PUSHQ	R3			; Save R3, R4
	MOVZBL	UCB$B_XQ_MULTI(R5),R4	; Get number of entries in list
	BEQL	40$			; Br if none
	MOVAB	UCB$G_XQ_MULTI(R5),R3	; Get address of multicast list
;
; Search for empty slot in list
;
10$:	TSTL	(R3)			; Is this the empty slot
	BNEQ	20$			; Br if no
	TSTW	4(R3)			; Really?
	BEQL	30$			; Br if yes
20$:	ADDL	#6,R3			; Skip to next entry in list
	SOBGTR	R4,10$			; Loop if more possiblities
	BRB	40$			; Else, exit
;
; Empty slot found - put the squeeze on.
;
30$:	MOVL	6(R3),(R3)+		; Squeeze the list
	MOVW	6(R3),(R3)+		;	...
	SOBGTR	R4,30$			; Loop if more to go
	CLRL	(R3)+			; Zero the last entry
	CLRW	(R3)+			;	...
40$:	POPQ	R3			; Restore R3, R4
	RSB				; Return to caller

	.SBTTL	SET_PHYAD - SET THE PHYSICAL ADDRESS
	.SBTTL	SET_DESAD - SET THE DESTINATION ADDRESS
;++
; SET_PHYAD - SET THE PHYSICAL ADDRESS
; SET_DESAD - SET THE DESTINATION ADDRESS
;
; Functional description:
;
; This routine sets up the physical address in the CDB.
;
; Inputs:
;
;	R4 = CDB address
;	R5 = UCB address
;	R6 = Address of physical address to be set or cleared
;	R9 = Size of the string
;
;	IPL = FIPL
;
; Outputs:
;
;	R0 = destroyed.
;	All other registers are preserved.
;
;--
	.ENABL	LSB
SET_PHYAD:				; Set up the CDB physical address
	PUSHR	#^M<R1,R6,R7,R9>	; Save registers
	MOVAB	UCB$G_XQ_PHA(R5),R7	; Get address of UCB cell
	BRB	10$			; Join common code
SET_DESAD:
	PUSHR	#^M<R1,R6,R7,R9>	; Save registers
	MOVAB	UCB$G_XQ_DES(R5),R7	; Get address of UCB cell
10$:	SUBL	#2,R9			; Can we read the modifier word?
	BLSS	50$			; Br if no - exit
	DIVL	#6,R9			; Calculate number of addresses
	MOVZWL	(R6)+,R1		; Get the modifier

	ASSUME	NMA$C_LINMC_SET EQ 1
	ASSUME	NMA$C_LINMC_CLR EQ 2
	ASSUME	NMA$C_LINMC_CAL EQ 3
	ASSUME	NMA$C_LINMC_SDF EQ 4
	$DISPATCH	R1,TYPE=B,-	; Dispatch on modifier value
		<-
	    	<NMA$C_LINMC_SET 20$>,-	; Set the address
	    	<NMA$C_LINMC_CLR 30$>,-	; Clear the address
	    	<NMA$C_LINMC_CAL 50$>,-	; 3 - invalid value
	    	<NMA$C_LINMC_SDF 40$>,-	; Set physical as DECnet default address
		>
	BRB	50$			; Any other values are invalid

;
; Set physical address
;
20$:	TSTL	R9			; Any addresses present?
	BEQL	50$			; Br if no - exit
	MOVL	(R6)+,(R7)+		; Set new address
	MOVW	(R6)+,(R7)		;	...
	BRB	50$			; All done
;
; Clear address from list
;
30$:	MNEGL	#1,(R7)+		; Reset address
	MNEGW	#1,(R7)			;	...
	BRB	50$			; All done

;
; Set the physical address (Assume entered from SET_PHYAD) to the DECNET
; default address. The PHA address has been pre-set with -1, which implies
; using the HWA.
;
40$:	BBS	#CDB_STS_V_INITED,-	; Br if XQ device is already inited
		CDB_B_STS(R4),50$	;    use HWA
	MOVW	G^SCS$GB_SYSTEMID,R1	; Else, get SCSSYSTEMID parameter
	BEQL	50$			; Br if none, use HWA
	MOVL	#^X000400AA,(R7)+	; Set common low longword of addr
	MOVW	R1,(R7)			; Set unique high word of address

50$:	POPR	#^M<R1,R6,R7,R9>	; Restore registers
	RSB				; Return to caller
	.DSABL	LSB

	.SBTTL	RETURN_MULTI - RETURN THE MULTICAST ADDRESS LIST

;++
; RETURN_MULTI - RETURN THE MULTICAST ADDRESS LIST
;
; Functional description:
;
; This routine returns all the multicast addresses in the UCB list.
;
; Inputs:
;
;	R4 = CDB address
;	R5 = UCB address
;	R6 = Address where to store multicast address list
;	R8 = Size left in output buffer
;
; Outputs:
;
;	R6 = Address past stored multicast address list
;	All other registers are preserved.
;
;--

RETURN_MULTI:				; Return the multicast address list
	PUSHQ	R1			; Save R1, R2
	MOVZBL	UCB$B_XQ_MULTI(R5),R2	; Set number of multicast addresses
	MOVAB	UCB$G_XQ_MULTI(R5),R1	; Point to start of multicast lists
	SUBL	#2,R8			; Can string size fit?
	BLSS	40$			; Br if no - return
	ADDL	#2,R6			; Skip size field of return data
	PUSHL	R6			; Save start address of string
10$:	SUBL	#6,R8			; Room left in buffer?
	BLSS	30$			; Br if no .. exit now
	MOVL	(R1)+,(R6)+		; Return address
	MOVW	(R1)+,(R6)+		;	...
	SOBGTR	R2,10$			; Br if more possibles

30$:	POPL	R1			; Restore string address
	SUBL3	R1,R6,R2		; Get string size
	MOVW	R2,-2(R1)		; Return string size
40$:	POPQ	R1			; Restore R1, R2
	RSB				; Return to caller

	.SBTTL	MATCH_MULTI - CHECK MULTICAST ADDRESS

;++
; MATCH_MULTI - CHECK MULTICAST ADDRESS
;
; Functional description:
;
; This routine returns success if the unit is in promiscous mode, or the
; recognizes all multicast address or the multicast address in the buffer
; matches a multicast address in the unit's multicast address list.
;
; Inputs:
;
;	R2 = Receive buffer
;	R4 = CDB address
;	R5 = UCB address
;
; Outputs:
;
;	R0 = Status return for request
;	R1 = Destroyed
;	All other registers are preserved.
;
;--

MATCH_MULTI:				; Find multicast addres in UCB
	PUSHQ	R2			; Save R2, R3
	CLRL	R0			; Assume failure

	ASSUME	UCB$V_XQ_INITED  EQ  0
	BLBC	UCB$W_DEVSTS(R5),10$	; Br if PROTOCOL TYPE is not valid
	INCL	R0			; Assume success
	ASSUME	NMA$C_STATE_ON EQ 0
	ASSUME	NMA$C_STATE_OFF EQ 1
	BLBC	UCB$B_XQ_PRM(R5),10$	; Br if promiscuous mode - OKAY
	BLBC	UCB$B_XQ_MLT(R5),10$	; Br if all multicasts are enabled
	MOVQ	CXB$G_R_DEST(R2),R1	; Get multicast address
	CMPL	#BRDCST1,R1		; Is this the broadcast address?
	BNEQ	5$			; Br if no
	CMPW	#BRDCST2,R2		; Really?
	BEQL	10$			; Br if yes - everybody get this one
5$:	BSBB	MATCH_ADDRESS		; Else, find exact match
10$:	POPQ	R2			; Restore R2, R3
	RSB				; Return to caller

	.SBTTL	MATCH_ADDRESS - FIND A MATCH ON A MULTICAST ADDRESS

;++
; MATCH_ADDRESS - FIND A MATCH ON A MULTICAST ADDRESS
;
; Functional description:
;
; This routine searches the UCB multicast address list for a match on a
; multicast address.
;
; Inputs:
;
;	R1 = Low 32 bits of 48 bit multicast address to match
;	R2 = High 16 bits of 48 bit multicast address to match
;	R4 = CDB address
;	R5 = UCB address
;
; Outputs:
;
;	R0 = Status return for request
;	R3 = Address of slot in multicast address list
;	All other registers are preserved.
;
;--

MATCH_ADDRESS:				; Find multicast address in UCB
	PUSHL	R4			; Save R4
	MOVZBL	S^#SS$_NORMAL,R0	; Assume success
	MOVZBL	UCB$B_XQ_MULTI(R5),R4	; Set number of multicast addresses
	MOVAB	UCB$G_XQ_MULTI(R5),R3	; Point to start of multicast lists
10$:	CMPL	(R3)+,R1		; Is this a match?
	BNEQ	20$			; Br if no - skip to next
	CMPW	(R3),R2			; Is it really?
	BEQL	30$			; Br if yes - all done
20$:	ADDL	#2,R3			; Skip to next entry
	SOBGTR	R4,10$			; Br if more in list

	CLRL	R0			; Return failure
30$:	SUBL	#4,R3			; Backup pointer
	POPL	R4			; Restore R4
	RSB				; Return to caller

	.SBTTL	POKE_USER - DELIVER ATTENTION ASTS

;++
; POKE_USER - Deliver attention AST
;
; Functional description:
;
; This routine is used to deliver an attention AST if one has been
; requested.
;
; Inputs:
;
;	R5 = UCB address
;
; Outputs:
;
;	R0 = Low bit clear only if user is not notified
;	R1-R3 are destroyed.
;
;--

POKE_USER:				; Poke user process
	DSBINT	UCB$B_FIPL(R5)		; Sync access to UCB
	CLRL	-(SP)			; Assume failure
	MOVAB	UCB$L_XQ_AST(R5),R1	; Get AST listhead
	TSTL	(R1)			; Empty?
	BEQL	30$			; Branch if yes
	INCL	(SP)			; Indicate success
	PUSHL	R4			; Save R4
	MOVL	R1,R4			; Copy listhead address
10$:	MOVL	(R1),R1			; Address a block
	BEQL	20$			; Branch if done
	MOVL	UCB$L_DEVDEPEND(R5),-	; Change parameter
		ACB$L_KAST+4(R1)	;    return status
	BRB	10$			; Continue thru AST blocks
20$:	JSB	G^COM$DELATTNAST	; Deliver the AST's
	POPL	R4			; Restore R4
 
30$:	POPL	R0			; Return success indicator
	ENBINT				; Restore IPL
	RSB				; Return to caller

	.SBTTL	MATCH_PROTYP - Match protocol type
	.SBTTL	MATCH_PROMTYP - Find the promiscuous user

;++
; MATCH_PROTYP - Match protocol type
; MATCH_PROMTYP - Find the promiscuous user
;
; This routine checks for a match of a protocol type against that in
; existing UCB's.
;
; Inputs:
;
;	R1 = word of protocol type
;	R4 = CDB address
;
; Outputs:
;
;	R0 = LBS=> match; LBC=> no match
;	R5 = UCB address on success
;
;-

MATCH_PROTYP:				; Match protocol type
	CLRL	R0			; Assume failure
	MOVL	CDB_L_UCB0(R4),R5	; Get first UCB address
	BEQL	20$			; Br if not inited - yet
10$:	MOVL	UCB$L_LINK(R5),R5	; Get next UCB address
	BEQL	20$			; If EQL no match
	ASSUME	UCB$V_XQ_INITED  EQ  0
	BLBC	UCB$W_DEVSTS(R5),10$	; Br if PROTOCOL TYPE is not valid

	ASSUME	NMA$C_STATE_ON EQ 0
	ASSUME	NMA$C_STATE_OFF EQ 1

	BLBC	UCB$B_XQ_PRM(R5),10$ 	; Skip if PROMISCUOUS user
	CMPW	R1,UCB$W_XQ_PROTYP(R5)	; Match?
	BNEQ	10$			; If NEQ no - loop
15$:	INCL	R0			; Return success
20$:	RSB				; Done

MATCH_PROMTYP:
	MOVZBL	#1,R0			; Assume success
	MOVL	CDB_L_PRMUSER(R4),R5	; Get PROMISCUOUS user's UCB address
	BNEQ	10$			; Br if present
	CLRL	R0			; Else, return error
10$:	RSB				; Return to caller


XQ_END::
	.END
