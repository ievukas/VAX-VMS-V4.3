	.TITLE	SYSOUTPUT - ROUTINES FOR MANIPULATING SYS$OUTPUT
	.IDENT	'V04-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; Peter George  08-Jan-1983
;
; ROUTINES FOR MANIPULATING SYS$OUTPUT
;
; MODIFIED BY:
;
;	V03-004	PCG0004		Peter George		21-Aug-1983
;		Manage concealed and terminal attributes using new
;		logical name services.
;
;	V03-003	PCG0003		Peter George		27-Jul-1983
;		Fix data manipulation bugs.
;
;	V03-002	PCG0002		Peter George		27-May-1983
;		Add support for image verification.
;
;	V03-001	PCG0001		Peter George		13-Apr-1983
;		Clear FAB$B_SHR before opening SYS$OUTPUT.
;---

;
; MACRO LIBRARY CALLS
;
 
	PRCDEF				;DEFINE PROCESS WORK AREA
	IDFDEF				;DEFINE INDIRECT FRAME OFFSETS
	PRDDEF				;PROCESS RMS DATA
	OUTDEF				;SYS$OUTPUT DEFINITIONS
	$CLIMSGDEF			;DEFINE ERROR/STATUS VALUES
	$FABDEF				;DEFINE FAB OFFSETS
	$RABDEF				;DEFINE RAB OFFSETS
	$LNMDEF				;DEFINE LNM OFFSET
	$NAMDEF				;DEFINE NAM OFFSETS
	$PSLDEF				;DEFINE PSL FIELDS
 
;
; LOCAL DATA
;
 
	.PSECT	DCL$ZCODE,BYTE,RD,NOWRT
INPUTNAM:				;'INPUT' LOGICAL NAME TEXT
	.ASCII	<9>/SYS$INPUT/		;
OUTFILE:				;OUTPUT FILE DEFAULT NAME STRING
	.ASCII	/.LIS/			;
OUTPUTNAM:				;'OUTPUT' LOGICAL NAME TEXT
	.ASCII	<10>/SYS$OUTPUT/	;
LNM$PROCESS:				;PROCESS LOGICAL NAME TABLE
	.ASCIC	/LNM$PROCESS/		;

	.SBTTL	OPEN NEW SYS$OUTPUT FILE
;+
; DCL$OPEN_OUTPUT - OPEN NEW SYS$OUTPUT FILE
;
; THIS ROUTINE IS CALLED TO OPEN A NEW SYS$OUTPUT FILE AND TO INITIALIZE
; THE APPROPRIATE DATA STRUCTURES.
;
; INPUTS:
;
;	R1/R2 = DESCRIPTOR OF SYS$OUTPUT EQUIVALENCE NAME
;	R6 = ADDRESS OF DEFAULT IDF FRAME
;	R11 = ADDRESS OF PROCESS WORK AREA
;
; OUTPUTS:
;
;	R0 = STATUS (NOT SIGNALED)
;-

DCL$OPEN_OUTPUT::
	PUSHR	#^M<R1,R2,R6,R7,R8,R9>

	MOVL	PRC_L_IDFLNK(R11),R8		;GET ADDRESS OF CURRENT IDF FRAME
	TSTL	R1				;OUTPUT FILE SPECIFIED?
	BNEQ	10$				;BRANCH IF SO

;
; No output filespec is specified, propagate the default output stream 
; to the indirect frame.  Leave PRC_L_INDOUTRAB as is.
;
	ASSUME	IDF_W_OUTISI EQ IDF_W_OUTIFI+2
	MOVL	IDF_W_OUTIFI(R6),-		;SAVE PREVIOUS INTERNAL FILE INDEX
		IDF_W_OUTIFI(R8) 		;
	MOVL	IDF_L_OUTRABCTX(R6),-		;SAME FOR RAB CONTEXT
		IDF_L_OUTRABCTX(R8) 		;
	MOVC	#16,IDF_T_OUTDVI(R6),-		;SAVE PREVIOUS DEVICE NAME
		IDF_T_OUTDVI(R8) 		;
	CLRBIT	IDF_V_OUTCCL,IDF_B_OUTFLAGS(R8)	;CLEAR CONCEALED BIT
	BBC	#NAM$V_CNCL_DEV,-		;IS DEVICE CONCEALED?
		NAM$L_FNB(R7),5$		;
	SETBIT	IDF_V_OUTCCL,IDF_B_OUTFLAGS(R8)	;SET CONCEALED BIT IN IDF
5$:	BRW	30$				;SKIP PAST FILE CREATION

;
; Output filespec is specified, create new output file.  fill in IDF frame
; fields and PRC_L_INDOUTRAB.
;
; Set up fields in the indirect FAB for the $CREATE.
;
10$:	MOVL	PRC_L_INDFAB(R11),R9		;GET ADDRESS OF INDIRECT FAB
	MOVAB	OUTFILE,FAB$L_DNA(R9)		;SET ADDRESS OF DEF NAME STRING (.LIS)
	MOVB	#FAB$M_PUT,FAB$B_FAC(R9)	;SET FILE ACCESS TYPE
	MOVB	R1,FAB$B_FNS(R9)		;SET SIZE OF FILENAME STRING
	MOVL	R2,FAB$L_FNA(R9)		;SET ADDRESS OF FILE NAME STRING
	MOVL	#FAB$M_PPF!FAB$M_SQO,-		;SET FILE OPEN OPTIONS
		FAB$L_FOP(R9) 			;
	MOVB	#FAB$C_SEQ,FAB$B_ORG(R9) 	;SET FILE ORGANIZATION TYPE
	MOVB	#FAB$M_PRN,FAB$B_RAT(R9) 	;SET RECORD ATTRIBUTE TYPE TO PRINT
	MOVB	#FAB$C_VFC,FAB$B_RFM(R9) 	;SET RECORD FORMAT TYPE-FIXED CONTROL
	CLRB	FAB$B_SHR(R9)			;CLEAR FILE SHARING OPTIONS
	CLRW	FAB$W_IFI(R9) 			;CLEAR INTERNAL FILE INDEX
	MOVL	R9,R0				;ADDRESS OF FAB
	MOVL	#1,R1				;ASSUME CREATE WITH ERROR REPORTING
	BSBW	DCL$OPEN_CREATE			;CREATE NEW OUTPUT FILE
	BLBC	R0,50$				;IF LBC CREATION FAILURE

;
; The $CREATE was successful, now set up the RAB fields and try a $CONNECT.
; be careful to restore IDF_W_OUTIFI and IDF_L_OUTRABCTX if anything goes wrong.
;
	MOVAB	PRD_G_ALTOUTRAB(R9),R2		;GET ALTERNATE OUTPUT RAB ADDRESS
	CLRW	RAB$W_ISI(R2) 			;CLEAR INTERNAL STREAM INDEX
	MOVL	R9,RAB$L_FAB(R2)		;LINK FAB TO RAB
	$CONNECT RAB=(R2)			;CONNECT TO OUTPUT
	BLBC	R0,50$				;IF LBS CONNECT FAILURE

;
; Both the $CREATE and $CONNECT succeeded.  Fill in the IDF and RAB fields.
; Set PRC_L_INDOUTRAB.
;
	MOVAB	(R2),PRC_L_INDOUTRAB(R11) 	;SET ADDRESS OF OUTPUT RAB
	MOVW	FAB$W_IFI(R9),IDF_W_OUTIFI(R8) 	;SAVE OUTPUT FILE INTERNAL INDEX
	MOVL	FAB$L_DEV(R9),RAB$L_CTX(R2)	;SAVE DEVICE CHARACTERISTICS
	MOVL	RAB$L_CTX(R2),-			;  IN RAB AND IDF
		IDF_L_OUTRABCTX(R8) 		;
	INSV	#FAB$M_CR,#RAB$V_PPF_RAT,-	;SET TO USE IMPLIED
		#RAB$S_PPF_RAT,RAB$W_ISI(R2)	;  CR/LF FOR OUTPUT
	MOVW	RAB$W_ISI(R2),IDF_W_OUTISI(R8)	;COPY OUTPUT ISI TO IDF

;
; Get the device name.  Propagate concealed attribute.
;
	MOVL	FAB$L_NAM(R9),R7		;GET ADDRESS OF INDIRECT NAM
	CLRBIT	IDF_V_OUTCCL,IDF_B_OUTFLAGS(R8)	;CLEAR CONCEALED BIT IN IDF
	BBC	#NAM$V_CNCL_DEV,-		;IS DEVICE CONCEALED?
		NAM$L_FNB(R7),20$		;
	SETBIT	IDF_V_OUTCCL,IDF_B_OUTFLAGS(R8)	;SET CONCEALED BIT IN IDF
20$:	MOVC	#16,NAM$T_DVI(R7),-		;SAVE DEVICE NAME
		IDF_T_OUTDVI(R8) 		;

;
; Redirect image verification if appropriate.
;
30$:	MOVL	PRC_L_INDFAB(R11),R1		;GET ADDRESS OF INDIRECT FAB
	MOVW	IDF_W_INPIFI(R8),FAB$W_IFI(R1)	;GET INPUT IFI
	BSBW	DCL$VERIFY_IMAGE		;

;
; Cleanup and exit.
;
	STATUS	NORMAL				;
40$:	POPR	#^M<R1,R2,R6,R7,R8,R9>		;RESTORE REGISTERS
	RSB

;
; Restore corrupted FAB and RAB fields.
;
50$:	MOVL	PRC_L_INDFAB(R11),R9		;GET ADDRESS OF INDIRECT FAB
	MOVW	IDF_W_OUTIFI(R8),FAB$W_IFI(R9) 	;CLEAR INTERNAL FILE INDEX
	MOVAB	PRD_G_ALTOUTRAB(R9),R2		;GET ALTERNATE OUTPUT RAB ADDRESS
	MOVW	IDF_W_OUTISI(R8),RAB$W_ISI(R2) 	;CLEAR INTERNAL STREAM INDEX
	BRB 	40$				;

	.SBTTL	RESTORE OLD SYS$OUTPUT FILE
;+
; DCL$RESTORE_OUTPUT - RESTORE OLD SYS$OUTPUT FILE
;
; THIS ROUTINE IS CALLED TO CLOSE THE CURRENT SYS$OUTPUT FILE AND TO RESET
; THE APPROPRIATE DATA STRUCTURES SO THAT THEY POINT TO THE OLD SYS$OUTPUT
; FILE.
;
; INPUTS:
;
;	R2 = ADDRESS OF OUTPUT FILE DATA
;	R8 = ADDRESS OF CURRENT IDF FRAME
;	R11 = ADDRESS OF PROCESS WORK AREA
;
; OUTPUTS:
;
;	R0-R1 ARE TRASHED
;-
 
DCL$RESTORE_OUTPUT::				;RESTORE SYS$OUTPUT
	PUSHL	R9				;SAVE R9
	MOVL	PRC_L_INDFAB(R11),R9		;GET ADDRESS OF SCRATCH FAB

;
; Close current output file if the current output file is different from
; the previous level and different from the process permanent output file.
;
	TSTL	IDF_L_LNK(R8)			;DOES PREVIOUS LEVEL EXIST?
	BEQL	5$				;NO, THEN SKIP NEXT TEST
	CMPW	IDF_W_OUTIFI(R8),-		;OUTPUT FILE CHANGED FROM
		IDF_W_OUTIFI+IDF_K_LENGTH(R8) 	;  PREVIOUS COMMAND LEVEL?
	BEQL	10$				;BR IF NO
5$:	CMPW	IDF_W_OUTIFI(R8),-		;OUTPUT FILE DIFFERENT FROM
		PRC_W_OUTIFI(R11) 		;  PERMANENT PROCESS DEFINITION?
	BEQL	10$				;BR IF NO
	MOVW	IDF_W_OUTIFI(R8),FAB$W_IFI(R9)	;RESTORE INTERNAL FILE INDEX
	$CLOSE	FAB=(R9)			;CLOSE INDIRECT OUTPUT FILE

;
; Restore the IDF and the RAB.  Use either PRC or some other IDF, as specified
; by the address in R2.
;
10$:	MOVL	PRC_L_INDOUTRAB(R11),R0		;GET POINTER TO INDIRECT OUTPUT RAB
	MOVW	OUT_W_OUTISI(R2),RAB$W_ISI(R0)	;SAVE ISI
	MOVL	OUT_L_OUTRABCTX(R2),-		;SAVE CTX
		RAB$L_CTX(R0)			;
	ASSUME	OUT_W_OUTISI EQ OUT_W_OUTIFI+2
	ASSUME	OUT_L_OUTRABCTX EQ OUT_W_OUTIFI+4
	MOVQ	OUT_W_OUTIFI(R2),IDF_W_OUTIFI(R8) ;SAVE IFI,ISI,RABCTX
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>		;SAVE VOLATILE REGISTERS
	MOVC	#16,OUT_T_OUTDVI(R2),-		;SAVE DEVICE NAME
		IDF_T_OUTDVI(R8) 		;
	POPR	#^M<R0,R1,R2,R3,R4,R5>		;RESTORE VOLATILE REGISTERS
	CLRBIT	IDF_V_OUTCCL,IDF_B_OUTFLAGS(R8)	;CLEAR CONCEALED BIT IN IDF
	BBC	#OUT_V_OUTCCL,-			;IS DEVICE CONCEALED?
		OUT_B_OUTFLAGS(R2),20$		;
	SETBIT	IDF_V_OUTCCL,IDF_B_OUTFLAGS(R8)	;SET CONCEALED BIT IN IDF

;
; Redirect image verification if appropriate.
;
20$:	MOVL	R9,R1				;GET ADDRESS OF FAB
	MOVW	IDF_W_INPIFI(R8),FAB$W_IFI(R1)	;GET INPUT IFI
	BSBW	DCL$VERIFY_IMAGE		;

	POPL	R9				;RESTORE R9
	RSB					;


	.SBTTL	CREATE LOGICAL NAMES FOR 'INPUT' AND 'OUTPUT'
;---
;
; DCL$CREATE_IO - CREATE LOGICAL NAMES FOR 'INPUT' AND 'OUTPUT'
; DCL$CREATE_OUTPUT - CREATE LOGICAL NAME FOR 'OUTPUT'
;
; THESE ROUTINES ARE CALLED TO CREATE LOGICAL NAMES FOR 'INPUT' AND 'OUTPUT'
; BASE ON THE CURRENT INDIRECT FILE DEPTH.
;
; INPUTS:
;
;	R8 = ADDRESS OF CURRENT INDIRECT FRAME
;	R11 = ADDRESS OF PROCESS WORK AREA
;
; OUTPUTS:
;
;	R0-R6 DESTROYED.
;---
 
DCL$CREATE_IO::
	MOVAB	IDF_T_INPDVI(R8),R2		;GET ADDRESS OF INPUT DEVICE IDENTIFICATION
	BICW3	#FAB$M_PPF_IND,-		;GET INTERNAL FILE ID FOR INPUT -
		IDF_W_INPIFI(R8),R3		;ALWAYS CLEAR INDIRECT BIT IF SET
	MOVAB	INPUTNAM,R5			;GET ADDRESS OF INPUT LOGICAL NAME
	TSTL	PRC_L_INDEPTH(R11)		;ARE WE AT LEVEL 0?
	BNEQ	10$				;NO, THEN SKIP
	BSBW	DELETE				;DELETE 'INPUT' LOGICAL NAME
	BRB	DCL$CREATE_OUTPUT		;CREATE 'OUTPUT' LOGICAL NAME

10$:	MOVL	#LNM$M_TERMINAL,R6		;ASSUME NOT CONCEALED DEVICE
	BBC	#IDF_V_INPCCL,-			;SKIP IF NOT CONCEALED DEVICE
		IDF_B_OUTFLAGS(R8),20$		;
	SETBIT	LNM$V_CONCEALED,R6		;SET ATTRIBUTES
20$:	BSBB	CREATE				;CREATE 'INPUT' LOGICAL NAME

DCL$CREATE_OUTPUT::
	MOVAB	IDF_T_OUTDVI(R8),R2		;GET ADDRESS OF OUTPUT DEVICE IDENTIFICATION
	BICW3	#FAB$M_PPF_IND,-		;GET INTERNAL FILE ID FOR OUTPUT FILE -
		IDF_W_OUTIFI(R8),R3		;ALWAYS CLEAR INDIRECT BIT IF SET
	MOVAB	OUTPUTNAM,R5			;GET ADDRESS OF OUTPUT LOGICAL NAME
	MOVL	#LNM$M_TERMINAL,R6		;ASSUME NOT CONCEALED DEVICE
	BBC	#IDF_V_OUTCCL,-			;SKIP IF NOT CONCEALED DEVICE
		IDF_B_OUTFLAGS(R8),CREATE	;
	SETBIT	LNM$V_CONCEALED,R6		;SET ATTRIBUTES

;
; R2 = ADDRESS OF ASCIC DEVICE NAME
; R3 = IFI CORRESPONDING TO FILE
; R5 = ADDRESS OF ASCIC LOGICAL NAME
; R6 = EQUIVALENCE NAME ATTRIBUTES
;
; CREATE EQUIVALENCE NAME STRING ON THE STACK.
; FORMAT IS <ESC-BYTE><00-BYTE><IFI-WORD><DEVICE-STRING><:-BYTE>.
;
CREATE:	SUBL	#16,SP				;ALLOCATE SPACE TO STORE DEVICE NAME
	MOVZBL	(R2)+,R0			;GET LENGTH OF DEVICE NAME
	PUSHR	#^M<R0,R3,R5>			;SAVE REGISTERS
	MOVC	R0,(R2),12(SP)			;COPY DEVICE IDENTIFICATION
	MOVB	#^A/:/,(R3)			;APPEND THE :
	POPR	#^M<R0,R3,R5>			;RESTORE REGISTERS
	MOVZBL	#27,-(SP)			;INSERT ESCAPE AND TYPE ZERO
	MOVW	R3,2(SP)			;INSERT INTERNAL FILE INDEX

;
; BUILD ITEM LIST CONTAINING EQUIVALENCE NAME AND ATTRIBUTES.
;
	PUSHL	R6				;SET THE ATTRIBUTES
	CLRQ	-(SP)				;TERMINATE THE ITEM LIST
	PUSHAB	12(SP)				;SET ADDRESS OF EQUIV NAME
	PUSHAB	5(R0)				;SET LENGTH OF EQUIV NAME
	MOVW	#LNM$_STRING,2(SP)		;SET ITEM CODE
	CLRL	-(SP)				;TERMINATE ATTRIBUTES ITEM
	PUSHAB	20(SP)				;SET ATTRIBUTES
	PUSHL	#LNM$_ATTRIBUTES@16+4		;SET ITEM CODE AND LENGTH

;
; PUSH NAME ATTRIBUTES AND ACCESS MODE, AND CREATE LOGICAL NAME AND TABLE 
; NAME DESCRIPTORS.
;
	PUSHL	#LNM$M_CONFINE			;PUSH NAME ATTRIBUTES
	PUSHL	#PSL$C_SUPER			;PUSH ACCESS MODE
	MOVZBL	(R5)+,R4			;BUILD LOGICAL NAME DESCRIPTOR
	MOVQ	R4,-(SP)			;
	MOVAB	LNM$PROCESS,R5			;BUILD TABLE NAME DESCRIPTOR
	MOVZBL	(R5)+,R4			;
	MOVQ	R4,-(SP)			;
	MOVL	SP,R1				;SAVE ADDRESS OF DESCRIPTORS

;
; PERFORM $CRELNM.
;
	$CRELNM_S  TABNAM=(R1),-		;CREATE THE LOGICAL NAME
		LOGNAM=8(R1),-			;
		ACMODE=16(R1),-			;
		ATTR=20(R1),-			;
		ITMLST=24(R1)			;
	ADDL	#<4*14>+20,SP			;CLEAN STACK
	RSB					;

;
; R5 = ADDRESS OF ASCIC LOGICAL NAME
;
; DELETE INPUT LOGICAL NAME.
;
DELETE:	PUSHL	#PSL$C_SUPER			;PUSH ACCESS MODE
	MOVZBL	(R5)+,R4			;BUILD LOGICAL NAME DESCRIPTOR
	MOVQ	R4,-(SP)			;
	MOVAB	LNM$PROCESS,R5			;BUILD TABLE NAME DESCRIPTOR
	MOVZBL	(R5)+,R4			;
	MOVQ	R4,-(SP)			;
	MOVL	SP,R1				;SAVE ADDRESS OF DESCRIPTORS
	$DELLNM_S  TABNAM=(R1),-		;DELETE THE LOGICAL NAME
		LOGNAM=8(R1),-			;
		ACMODE=16(R1)			;
	ADDL	#4*5,SP				;CLEAN STACK
	RSB					;
 
	.END
