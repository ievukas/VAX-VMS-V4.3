	.TITLE	SYSSETPRI SET PRIORITY SYSTEM SERVICE
	.IDENT	'V04-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
; FACILITY: EXECUTIVE, SYSTEM SERVICES
;
; ABSTRACT:
;	SYSSETPRI IMPLEMENTS THE SET PRIORITY SYSTEM SERVICE WHICH
;	ENABLES A PROCESS TO ALTER THE PRIORITY OF ITSELF OR ANOTHER
;	PROCESS.  
;
; ENVIRONMENT:
;	MODE=KERNEL, RESIDENT
;
;--
;
;	.PAGE
	.SBTTL	HISTORY			; DETAILED
;
; AUTHOR:	R. HUSTVEDT	 CREATION DATE: 6-OCT-76
;
; MODIFIED BY:
;
;	V03-002	LJK0288		Lawrence J. Kenah	9-Aug-1984
;		Use PRIB and AUTHPRI of target process rather than those of
;		caller as limit on new priority specified by nonprivileged
;		process (one lacking ALTPRI privilege).
;
;	V03-001	LJK0196		Lawrence J. Kenah	25-Mar-1983
;		Make rescheduling check if lowering priority of current process.
;-
	.PAGE
	.SBTTL	DECLARATIONS

;
; INCLUDE FILES:
;

	$IPLDEF				; DEFINE INTERRUPT PRIORIYT LEVELS
	$PCBDEF				; DEFINE PCB OFFSETS
	$PHDDEF				; DEFINE PROCESS HEADER OFFSETS
	$PRDEF				; DEFINE PROCESSOR REGISTERS
	$PRIDEF				; DEFINE PRIORITY INCREMENTS
	$PRVDEF				; DEFINE PRIVILEGES
	$SSDEF				; DEFINE STATUS CODES
	$STATEDEF			; DEFINE SCHEDULER STATE NUMBERS
;
; EQUATED SYMBOLS:
;

PIDADR=4				; PID ADDRESS ARGUMENT OFFSET
LOGNAM=8				; LOGICAL NAME OFFSET
PRI=12					; NEW PRIORITY
PRVPRI=16				; PREVIOUS PRIORITY SAVE ADDRESS
;
; OWN STORAGE:
;

	.PAGE
	.SBTTL	EXE$SETPRI - SET PRIORITY SYSTEM SERVICE ROUTINE

;++
; FUNCTIONAL DESCRIPTION:
;
; CALLING SEQUENCE:
;	CALLG	ARGLIST,EXE$SETPRI
;
; INPUT PARAMETERS:
;	PIDADR(AP) - ADDRESS OF PID FOR TARGET PROCESS (OPTIONAL)
;	LOGNAM(AP) - ADDRESS OF PROCESS LOGICAL NAME   (OPTIONAL)
;	PRI(AP) - BITS 0:4 CONTAIN DESIRED PRIORITY
;	PRVPRI(AP) - ADDRESS OF LONGWORD TO RECEIVE PREVIOUS PRIORITY
;	R4 - PCB ADDRESS OF CURRENT PROCESS
;
; IMPLICIT INPUTS:
;	CURRENT PCB
;
; OUTPUT PARAMETERS:
;	R0 - COMPLETION STATUS
;	@PIDADR(AP) - PID OF PROCESS FOR WHICH PRIORITY WAS CHANGED
;
; IMPLICIT OUTPUTS:
;	NONE
;
; COMPLETION CODES:
;	SS$_NORMAL   -   SUCCESSFUL COMPLETION
;	SS$_NOPRIV   -   INSUFFICIENT PRIVILEGE FOR REQUESTED OPERATION
;	SS$_NONEXPR  -   NON-EXISTENT PROCESS SPECIFIED
;
; SIDE EFFECTS:
;	A RESCHEDULING INTERRUPT MAY BE REQUESTED IF THE TARGET PROCESS
;	IS RAISED TO A PRIORITY GREATER THAN THAT OF THE CURRENT PROCESS.
;
;--

; Put error exit paths before entry mask so that byte displacements reach

ACCVIO:	MOVZWL	#SS$_ACCVIO,R0		; SET ACCESS VIOLATION
EXITN:	SETIPL	#0			; ENABLE INTERRUPTS
	RET				; AND RETURN TO CALLER

	.ENTRY	EXE$SETPRI,^M<R2,R3,R4,R5>	; SET PRIORITY SYSTEM SERVICE
	MOVL	PRVPRI(AP),R5		; SAVE PREVIOUS PRIORITY
	BEQL	10$			; NONE SUPPLIED
	IFNOWRT	#4,(R5),ACCVIO		; ACCESS VIOLATION IF NO WRT
10$:	EXTZV	#0,#5,PRI(AP),-(SP)	; SAVE DESIRED PRIORITY
	BSBW	EXE$NAMPID		; LOOK UP PID/PNAME
	BLBC	R0,EXITN		; EXIT IF ERROR (RET WILL CLEAN STACK)
	SUBL3	(SP)+,#31,R3		; CONVERT DESIRED PRIORITY TO INTERNAL FORM
	MOVZBL	PCB$B_PRIBSAV(R4),-(SP)	; SAVE CURRENT PRIORITY
	MOVL	W^SCH$GL_CURPCB,R2	; GET POINTER TO CURRENT PCB
	IFPRIV	SETPRI,20$,R2		; GENERAL SETPRI PRIVILEGE?
	MOVZBL	PCB$B_AUTHPRI(R4),R1	; GET AUTHORIZED PRIORITY OF TARGET
	CMPB	PCB$B_PRIB(R4),R1	; COMPARE WITH BASE PRIORITY
	BGEQU	15$			;  AND CHOOSE "LARGER" FOR NEXT STEP
	MOVZBL	PCB$B_PRIB(R4),R1	; BASE PRIORITY IS "LARGER"
15$:	CMPB	R1,R3			; COMPARE DESIRED VALUE WITH TARGET
	BLEQ	20$			; WITHIN RANGE, ALLOW AS IS
	MOVZBL	R1,R3			; MINIMIZE WITH BASE OF TARGET

; R2 - PCB address of $SETPRI caller
; R3 - New priority of target process
; R4 - PCB address of target process

20$:	MOVB	R3,PCB$B_PRISAV(R4)	; SET SAVED CURRENT PRIORITY
	MOVB	R3,PCB$B_PRIBSAV(R4)	; SET SAVED BASE PRIORITY
	TSTW	PCB$W_MTXCNT(R4)	; DOES THIS PROCESS HOLD A MUTEX?
	BNEQ	40$			; YES
	MOVB	R3,PCB$B_PRIB(R4)	; SET BASE PRIORITY

; Note that the following test must be based on process state to allow for
; multiple current processes on multiprocessor systems.

	CMPW	#SCH$C_CUR,PCB$W_STATE(R4) ; TARGET PROCESS CURRENTLY EXECUTING?
	BNEQ	30$			; BR IF NOT
	MOVB	R3,PCB$B_PRI(R4)	; SET CURRENT PRIORITY

; If the caller of $SETPRI is lowering its own priority, a check must be made
; to insure that the caller is still the highest priority computable process. If
; some other COM process has a higher priority, a rescheduling request is made.

	CMPL	R4,R2			; TARGET PROCESS SAME AS CALLER?
	BNEQ	30$			; SKIP RESCHEDULE CHECK IF NOT
	MOVB	R3,W^SCH$GB_PRI		; RECORD NEW "TOP" PRIORITY
	FFS	#0,#32,W^SCH$GL_COMQS,R2; FIND PRIORITY OF NEXT COMPUTABLE PROCESS
	CMPB	R3,R2			; CHECK FOR DELAYED PREMPTION
	BLEQU	30$			; NO, CONTINUE
	SOFTINT	#IPL$_SCHED		; ELSE RESCHEDULE WHEN IPL DROPS
30$:	MOVZBL	#PRI$_IOCOM,R2		; GIVE BENEFIT OF DOUBT
	RPTEVT	SETPRI			; REPORT EVENT
40$:	MOVZWL	#SS$_NORMAL,R0		; SET SUCCESS CODE
	SETIPL	#0			; DROP IPL
	TSTL	R5			; RETURN PREVIOUS PRIORITY?
	BEQL	50$			; NO,
	SUBL3	(SP)+,#31,(R5)		; STORE PREVIOUS PRIORITY IN EXTERNAL FORM
50$:	RET				; AND RETURN

	.END
