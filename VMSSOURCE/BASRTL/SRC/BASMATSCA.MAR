	.TITLE	BAS$MAT_SCA_MUL		; Matrix multiply by a scalar
	.IDENT	/1-025/			; File: BASMATSCA.MAR	Edit: DG1025

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY: BASIC code support
;
; ABSTRACT:
;
;	This module multiplies each element of an input array by a scalar.
;
; ENVIRONMENT: User Mode, AST Reentrant
;
; AUTHOR: R. Will, CREATION DATE: 25-Jun-79
;
; MODIFIED BY:
;++
; 1-001	- Original 
; 1-002 - Use correct entry point to FLOOR.  RW  24-JUN-79
; 1-003	- Change MTH$DFLOOR_R1 to MTH$DFLOOR_R3.  JBS 25-JUL-1979
; 1-004 - Fix bug with mixed data types.  RW  17-Sept-79
; 1-005 - Redo scaling.  RW  13-Dec-1979
; 1-006	- Change MTH$DFLOOR_R3 to MTH$DINT_R4.  JBS 19-DEC-1979
; 1-007 - Fixed the bug about multiply a double floating by a matrix with scale>0.
;	  FM 4-FEB-81.
; 1-008 - Add support for byte, g and h floating.  PLL 18-Sep-81               
; 1-009 - More modifications for new data types.  PLL 24-Sep-81
; 1-010 - Change shared external references to G^ RNH 25-Sep-81
; 1-011 - Substitute a macro for the calls to the array fetch and store 
;	  routines.  This should speed things up.  PLL 9-Nov-81
; 1-012 - STORE macro must handle g & h floating.  PLL 11-Nov-81
; 1-013 - If the scalar is hfloat, the stack will be initialized correctly
;	  now.  PLL 17-Nov-81
; 1-014 - Correct a run-time expression in the FETCH and STORE macros.
;	  PLL 20-Jan-82
; 1-015 - Correct bug in BAS$MAT_SC_MUL macro.  (The scalar was not being
;	  stored if reals and integers were mixed.)  PLL 15-Feb-82
; 1-016 - Correct FETCH, STORE again.  PLL 23-Feb-82
; 1-017 - Don't list macro expansions.  PLL 16-Mar-82
; 1-018 - Correct STORE_HFLOAT (index off of R4 before changing it). PLL 8-Apr-82
; 1-019 - Remove FETCH and STORE macros; they are now located in macro
;	  library MATRIXMAC.OLB.  LB 19-May-82
; 1-020 - Change own storage to stack storage.  LB 9-Jul-1982
; 1-021 - DEST_x_TO_D's which call MTH$DINT_R4 must save and restore R4.
;	  (x will be floating data types)  PLL 19-Aug-82
; 1-022 - added in some pound signs where they were missing and causing
;	  memory management violations (notably in CMPB's where we were
;	  comparing against DSC$K_DTYPE_G and H).  MDL 6-Oct-1982
;	  Also allow gfloat results to be stored in a double destination,
;	  and vice versa.  PLL 7-Oct-1982
; 1-023 - Use G^ for ALL externals.  SBL 16-Nov-1982
; 1-024 - Redefine stack offsets for the call to the STORE macro (the
; 	  BSBW adds 4 to the stack).  DG 11-Jan-1984
; 1-025 - Redefine stack offset for 'save_scalar' - the correct offsets
;	  from 1-024 are causing scale to be written over by save_scalar
;	  in the cases of grand and huge.  DG 9-Apr-1984
;--

	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;

	$DSCDEF
	$SFDEF

;
; EXTERNAL DECLARATIONS:
;

	.DSABL	GBL				; Prevent undeclared
						;  symbols from being
						;  automatically global.
	.EXTRN	BAS$K_ARGDONMAT			; signalled if all 3 blocks
						;  not present in array desc
						;  or dimct = 0
	.EXTRN	BAS$K_DATTYPERR			; signalled if dtype of array
						; isn't word long float double
	.EXTRN	BAS$STO_FA_B_R8			; array element store for byte
	.EXTRN	BAS$STO_FA_W_R8			; array element store for word
	.EXTRN	BAS$STO_FA_L_R8			; array element store for long
	.EXTRN	BAS$STO_FA_F_R8			; array element store - float
	.EXTRN	BAS$STO_FA_D_R8			; array element store - double
	.EXTRN	BAS$STO_FA_G_R8			; array element store - gfloat
	.EXTRN	BAS$STO_FA_H_R8			; array element store - hfloat
	.EXTRN	BAS$FET_FA_B_R8			; array element fetch - byte
	.EXTRN	BAS$FET_FA_W_R8			; array element fetch - word
	.EXTRN	BAS$FET_FA_L_R8			; array element fetch - long
	.EXTRN	BAS$FET_FA_F_R8			; array element fetch - float
	.EXTRN	BAS$FET_FA_D_R8			; array element fetch - double
	.EXTRN	BAS$FET_FA_G_R8			; array element fetch - gfloat
	.EXTRN	BAS$FET_FA_H_R8			; array element fetch - hfloat
	.EXTRN	BAS$MAT_REDIM			; check if redimensioning of
						;  dest array is necessary, if
						;  so, do it
	.EXTRN	BAS$$SCALE_R1			; scale of the double precision
	.EXTRN	BAS$$STOP			; signal fatal errors
	.EXTRN	MTH$DINT_R4			; routine to integerize
	.EXTRN	BAS$FETCH_BFA
	.EXTRN	BAS$STORE_BFA

;
; MACROS:
;

;	$BAS$MAT_SC_MUL	see below, defines entire scalar multiply algorithm
;	FETCH		fetch an element from an array (found in macro
;			library MATRIXMAC.OLB)
;	STORE		store an element into an array (found in macro
;			library MATRIXMAC.OLB)

;
; EQUATED SYMBOLS:
;

	lower_bnd2 = 0				; stack offset for temp
	lower_bnd1 = 4				; stack offset for temp
	upper_bnd1 = 8				; stack offset for temp
	save_scalar = 12			; stack offset for scalar
	scale = 28				; offset from R4 for scale
	value_desc = 40				; output descriptor
	str_len = 40				; length field within desc
	dtype = 42				; data type field in desc
	class = 43				; class field within desc
	pointer = 44				; pointer to data in desc
	data = 48				; data
	dsc$l_l1_1 = 24				; desc offset if 1 sub
	dsc$l_u1_1 = 28				; desc offset if 1 sub
	dsc$l_l1_2 = 28				; desc offset if 2 sub
	dsc$l_u1_2 = 32				; desc offset if 2 sub
	dsc$l_l2_2 = 36				; desc offset if 2 sub
	dsc$l_u2_2 = 40				; desc offset if 2 sub

;
; OWN STORAGE:
;


;
; PSECT DECLARATIONS:
;
	.PSECT _BAS$CODE PIC, USR, CON, REL, LCL, SHR, -
			EXE, RD, NOWRT, LONG


;+
; This macro contains the looping mechanism for accessing all elements of
; an array.  It also contains all the logic for all the combinations of data
; types and scaling.  A macro is used to make it easy to maintain the parallel
; code for all the different combinations of data types.
;-
	.MACRO	$BAS$MAT_SC_MUL src_dtype, scalar_dtype ; scalar mult algorithm

;+
; Decide what mode the multiplication must be done in and store the scalar
; in that data type.  If the data types of the source array and the scalar
; are the same, store the scalar as is.  Else convert the scalar to a common
; type and store.
;-

	.IF	IDN	scalar_dtype, src_dtype	; src array and scalar are
						;  same data type
	MOV'src_dtype'	@scalar(AP), save_scalar(SP) ; save the scalar as is
	.IFF					; src arrays different dtype
	.IF	IDN	src_dtype, H		; source is hfloat
	CVT'scalar_dtype'H	@scalar(AP), save_scalar(SP) ; cvt scalar to
						;  hfloat & save
	.IFF
	.IF	IDN	scalar_dtype, H		; scalar is hfloat
	MOVH	@scalar(AP), save_scalar(SP)	; save the scalar
	.IFF
	.IF	IDN	src_dtype, G		; source is gfloat
	.IF	DIF	scalar_dtype, D		; don't mix gfloat & dbl
	CVT'scalar_dtype'G	@scalar(AP), save_scalar(SP) ; cvt scalar to
						;  gfloat & save
	.IFF
	CVT'scalar_dtype'H 	@scalar(AP), save_scalar(SP) ; promote to hfloat
						;  if gfloat & dbl
	.ENDC
	.IFF
	.IF	IDN	scalar_dtype, G		; scalar is gfloat
	.IF	DIF	src_dtype, D		; don't mix gfloat & dbl
	MOVG	@scalar(AP), save_scalar(SP)	; save the scalar
	.IFF	
	CVTGH	@scalar(AP), save_scalar(SP)	; promote to hfloat if
						;  gfloat & dbl
	.ENDC
	.IFF
	.IF	IDN	src_dtype, D		; source is double
	CVT'scalar_dtype'D	@scalar(AP), save_scalar(SP) ; cvt scalar to
						;  double & save
	.IFF					; 1st array not double
	.IF	IDN	scalar_dtype, D		; if scalar double
	MOVD	@scalar(AP), save_scalar(SP)	; save the scalar
	.IFF					; no double operands try float
	.IF	IDN	src_dtype, F		; is src array float
	CVT'scalar_dtype'F	@scalar(AP), save_scalar(SP) ; make scalar float
	.IFF					; 1st array not float
	.IF	IDN	scalar_dtype, F		; is scalar float
	MOVF	@scalar(AP), save_scalar(SP)	; yes-store scalar as is
	.IFF					; no double or float, try long
	.IF	IDN	src_dtype, L		; is src array long
	CVT'scalar_dtype'L	@scalar(AP), save_scalar(SP) ; make scalar long
	.IFF
	.IF	IDN	scalar_dtype, L		; scalar is long
	MOVL	@scalar(AP), save_scalar(SP)	; save scalar as is
	.IFF
	.IF	IDN	src_dtype, W		; source is word
	CVT'scalar_dtype'W	@scalar(AP), save_scalar(SP) ; make scalar word
	.IFF
	.IF	IDN	scalar_dtype, W		; scalar is word
	MOVW	@scalar(AP), save_scalar(SP)	; save scalar as is
	.IFF
	.IF	IDN	src_dtype, B		; source is byte
	CVT'scalar_dtype'B	@scalar(AP), save_scalar(SP) ; make scalar byte
	.IFF
	.IF	IDN	scalar_dtype, B		; scalar is byte
	MOVB	@scalar(AP), save_scalar(SP)	; save scalar as is
	.IFF					; none of the above - unsupported
	BRW	ERR_DATTYPERR
	.ENDC
	.ENDC
	.ENDC
	.ENDC
	.ENDC
	.ENDC
	.ENDC
	.ENDC
	.ENDC
	.ENDC
	.ENDC
	.ENDC
	.ENDC
	.ENDC
	.ENDC

;+
; Loop through all the rows.  Row and column upper and lower bounds have been
; initialized on the stack.
;-

LOOP_1ST_SUB'scalar_dtype'src_dtype':
	MOVL	lower_bnd2(SP), R11		; R11 has 2nd lower bound

;+
; Loop through all the elements (columns) of the current row.  Column lower
; bound is initialized in R11.  Column upper bound is on the stack.
; Distinguish array by data type so that the correct fetch routine can 
; retrieve the data, the correct conversion can be done and the correct
; store routine can be called.
;-

LOOP_2ND_SUB'scalar_dtype'src_dtype':

;+
; Get the data from source array
;-

	MOVL	src_matrix(AP), R0		; pointer to array dest
	MOVL	lower_bnd1(SP), R1		; current row
	MOVL	R11, R2				; current col
	FETCH	'src_dtype'			; fetch data from src array

;+
; Multiply the source by the scalar.
; If the data types of source array and scalar are the same, do the arithmetic
; in that data type.  Else convert the src data to the type that scalar was
; stored in above, and multiply.
; Scaling is needed if the scalar or the src array or both is
; double.
;-

	MOVL	SP, R4				; point to stack temps for
						;  JSB to storage routine
	.IF	IDN	scalar_dtype, src_dtype	; src and scalar are same dtype
	MUL'src_dtype'2	save_scalar(SP), R0	; multiply by the scalar
	.IF	IDN	scalar_dtype, D		; if both are double
	DIVD2	scale(SP), R0			;  get rid of extra scale
	CMPD	scale(SP), #1			; if scale factor is 0
	BEQL	1$				;  don't integerize
	JSB	G^MTH$DINT_R4			; else, integerize
	MOVL	SP, R4				; We modified R4 in the above
						; JSB, so reload R4.
	.ENDC
1$:	BSBW	DEST_CASE_'src_dtype'		; store in the destination
	.IFF					; src & scalar different dtype
	.IF	IDN	src_dtype, H 		; source is hfloat
	MULH2	save_scalar(SP), R0		; scalar was saved hfloat
	BSBW	DEST_CASE_H			; cvt to dest type
	.IFF
	.IF	IDN	scalar_dtype, H		; scalar is hfloat
	CVT'src_dtype'H	R0, R0			; make src hfloat
	MULH2	save_scalar(SP), R0		; compute product
	BSBW	DEST_CASE_H			; cvt to dest type
	.IFF
	.IF	IDN	src_dtype, G		; source is gfloat
	.IF	DIF	scalar_dtype, D		; don't mix gfloat & dbl
	MULG2	save_scalar(SP), R0		; mult, scalar is gfloat
	BSBW	DEST_CASE_G			; cvt to dest type
	.IFF					; scalar dtype is dbl
						;  scalar was promoted to hfloat
	CVTGH	R0, R0				; promote src to hfloat
	MULH2	save_scalar(SP), R0		; compute product
	BSBW	DEST_CASE_H			; cvt to dest type
	.ENDC
	.IFF
	.IF	IDN	scalar_dtype, G		; scalar is gfloat
	.IF	DIF	src_dtype, D		; don't mix gfloat & dbl
	CVT'src_dtype'G	R0, R0			; make src gfloat
	MULG2	save_scalar(SP), R0		; compute product
	BSBW	DEST_CASE_G			; cvt to dest type
	.IFF					; src dtype is dbl
						;  scalar was promoted to hfloat
	CVTDH	R0, R0				; cvt src to hfloat
	MULH2	save_scalar(SP), R0		; compute product
	BSBW	DEST_CASE_H			; cvt to dest type
	.ENDC
	.IFF
	.IF	IDN	src_dtype, D		; source is double =>
						;  scalar has been saved double
	MULD2	save_scalar(SP), R0		; multiply, don't need to descale
						;  because scalar wasn't scaled
						;  don't need to integerize
						;  becausue scalar was W or L
	BSBW	DEST_CASE_D			; cvrt double product to dest type
	.IFF					; 1st array not double
	.IF	IDN	scalar_dtype, D		; is scalar double
	CVT'src_dtype'D	R0, R0			; yes, make src double, is L or W
						;  so don't need integerize, don;t
						;  scale so don't need to descale
	MULD2	save_scalar(SP), R0		; compute the product
	BSBW	DEST_CASE_D			; cvrt double product to dest type
	.IFF					; no double operands try float
	.IF	IDN	src_dtype, F		; src element float =>
						;  scalar has been stored float
	MULF2	save_scalar(SP), R0		; multiply
	BSBW	DEST_CASE_F			; cvrt float product to dest type
	.IFF					; 1st array not float
	.IF	IDN	scalar_dtype, F		; is scalar float
	CVT'src_dtype'F	R0, R0			; yes-make src float
	MULF2	save_scalar(SP), R0		; multiply
	BSBW	DEST_CASE_F			; cvrt float product to dest type
	.IFF					; no double or float, try long
	.IF	IDN	src_dtype, L		; src array long => scalar long
	MULL2	save_scalar(SP), R0		; multiply
	BSBW	DEST_CASE_L			; convrt long product to dest type
	.IFF					
	.IF	IDN	scalar_dtype, L		; scalar is long
	CVT'src_dtype'L	R0, R0			; cvt src to long
	MULL2	save_scalar(SP), R0		; multiply
	BSBW	DEST_CASE_L			; convrt long product to dest type
	.IFF
	.IF	IDN	src_dtype, W		; source is word
	MULW2	save_scalar(SP), R0		; mult, scalar is word
	BSBW	DEST_CASE_W			; cvt to dest type
	.IFF
	.IF	IDN	scalar_dtype, W		; scalar is word
	CVT'src_dtype'W	R0, R0			; cvt src to word
	MULW2	save_scalar(SP), R0		; compute product
	BSBW	DEST_CASE_W			; cvt to dest type
	.IFF
	.IF	IDN	src_dtype, B		; scalar is byte
	MULB2	save_scalar(SP), R0		; mult, src is byte
	BSBW	DEST_CASE_B			; cvt to dest type
	.IFF
	CVT'src_dtype'B	R0, R0			; only case left
	MULB2	save_scalar(SP), R0		; compute product
	BSBW	DEST_CASE_B
	.ENDC
	.ENDC
	.ENDC
	.ENDC
	.ENDC
	.ENDC
	.ENDC
	.ENDC
	.ENDC
	.ENDC
	.ENDC
	.ENDC
	.ENDC
	.ENDC

;+
; Product has now been stored in the destination array.  Continue looping
;-

	INCL	R11				; get next column
	CMPL	R11, R9				; see if last column done
	BGTR	3$
	BRW	LOOP_2ND_SUB'scalar_dtype'src_dtype' ; no, continue inner loop

;+
; Have completed entire row.  See if it was the last row.  If not,
; continue with next row.
;-

3$:	INCL	lower_bnd1(SP)			; get next row
	CMPL	lower_bnd1(SP), upper_bnd1(SP)	; see if last row done
	BGTR	5$
	BRW	LOOP_1ST_SUB'scalar_dtype'src_dtype' ; no, continue outer loop

5$:	RET					; yes, finished

	.ENDM

	.SBTTL	BAS$MAT_SCA_MUL  - Multiply each element of an array by scalar
;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine multiplies each element of an input matrix by a scalar,
;	and stores it in the output matrix.  The algorithm is the same for all
;	supported BASIC data types.  In order to keep the code for all
;	data type combinations the same and to simplify the reading, the code
;	has been done as a macro, which all the data types use varying only
;	the letter (B, W, L, F, D, G, H) in multiplying by the scalar, converting from
;	source to dest type, and calling the array store routines.
;	The scalar must be the same datatype as the source matrix.
;
; CALLING SEQUENCE:
;
;	CALL BAS$MAT_SCA_MUL (scalar.rz.r, scalar_dtype.rlu.v,
;				srcmatrix.rx.da, destmatrix.wx.da)
;
; INPUT PARAMETERS:
;
	scalar = 4	; pointer to scalar of type specified in next parameter
	scalar_dtype = 8 ; VAX standard dtype code for data type of scalar
	src_matrix = 12	; pointer to descriptor for source matrix
;
; IMPLICIT INPUTS:
;
;	scale from callers BASIC frame if data type of either matrix is double
;
; OUTPUT PARAMETERS:
;
	dest_matrix = 16	; pointer to descriptor for destination matrix
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; FUNCTION VALUE:
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	This routine calls the BASIC matrix fetch, store, and redimensioning
;	routines, and may cause any of their errors to be signalled.  It also
;	may signal any of the errors listed in the externals area.
;	It may also cause the destination array to have different dimensions.
;
;--

	.ENTRY BAS$MAT_SCA_MUL, ^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11,IV>

;+
;	REGISTER USAGE
;	R0 - R8 destroyed by store routines
;	R9	upper bound for 2nd subscript
;	R10	pointer to destination array descriptor
;	R11	current value of 2nd subscript
;-

;+
; Put routine arguments into registers for ease of use.
; If block 2 of array descriptor (multipliers) is not present then error.
;-

	MOVL	src_matrix(AP), R2		; ptr to array descr in R2
	BBC	#DSC$V_FL_BOUNDS, DSC$B_AFLAGS(R2), ERR_ARGDONMAT
						; exit if block 3 not
						; present in descriptor
	MOVL	dest_matrix(AP), R10		; ptr to dest array descriptor
	MOVL	SF$L_SAVE_FP(FP), R0		; pass FP to get scale
	JSB	G^BAS$$SCALE_R1			; get scale in R0 & R1
						; call a BLISS routine because
						; the frame offsets are only
						; defined for BLISS
	CLRQ	-(SP)				; save space for VALUE_DESC
	CLRQ	-(SP)				; 	AND
	CLRQ	-(SP)				; DATA
	MOVD	R0, -(SP)			; save the scale
	CLRQ	-(SP)				; save place for scalar on stack
	CLRQ	-(SP)				;  scalar may be hfloat
;+
; Set up limits for looping through all elements
;-

	CMPB	DSC$B_DIMCT(R2), #1		; determine # of subscripts
	BEQLU	INIT_ONE_SUB			; 1 sub, go init
	BGTRU	INIT_TWO_SUBS			; >=2 subs, go init
						; 0 subs, fall into error proc

ERR_ARGDONMAT:
	PUSHL	#BAS$K_ARGDONMAT		; signal error, 0 for dimct
	CALLS	#1, G^BAS$$STOP			; or block 2 or 3 absent

;+
; There is only 1 subscript.  Redimension the destination array.
; Make both upper and lower bound for 2nd
; subscript a 1.  A second subscript will be passed to and ignored by the
; store routine.  Put bounds for 1st subscript on stack.
;-

INIT_ONE_SUB:
	PUSHL	dsc$l_u1_1(R2)			; get bound for redim
	PUSHL	R10				; pointer to dest array desc
	CALLS	#2, G^BAS$MAT_REDIM		; redimension the dest
	PUSHL	dsc$l_u1_1(R2)			; 1st upper bound
	PUSHL	dsc$l_l1_1(R2)			; 1st lower bound
	BGTR	1$				; not 0 or neg, do 2nd sub
	MOVL	#1, (SP)			; don't alter col 0
1$:	PUSHL	#1				; dummy 2nd upper bound
	MOVL	#1, R9				; dummy 2nd lower bound
	BRB	SEPARATE_DTYPES			; go loop

;+
; There are 2 subscripts.  Check and redimension the destination array if
; necessary.  Put the upper bound for both subscripts on the
; stack and make sure that the lower bound for both subscripts will start
; at 1 (do not alter row or col 0)
;-

INIT_TWO_SUBS:
	PUSHL	dsc$l_u2_2(R2)			; 2nd upper bound
	PUSHL	dsc$l_u1_2(R2)			; 1st upper bound
	PUSHL	R10				; dest array pointer
	CALLS	#3, G^BAS$MAT_REDIM		; redimension destination
	PUSHL	dsc$l_u1_2(R2)			; 1st upper bound
	PUSHL	dsc$l_l1_2(R2)			; 1st lower bound
	BGTR	1$				; not row 0 or neg, do cols
	MOVL	#1, (SP)			; start with row 1
1$:	MOVL	dsc$l_u2_2(R2), R9		; 2nd upper bound
	PUSHL	dsc$l_l2_2(R2)			; 2nd lower bound
	BGTR	SEPARATE_DTYPES			; not col 0 or neg, go loop
	MOVL	#1, (SP)			; start with col 1

;+
; Algorithm now differs according to source array data types
;-

SEPARATE_DTYPES:
	CASEB	DSC$B_DTYPE(R2), #DSC$K_DTYPE_B, #<DSC$K_DTYPE_D - DSC$K_DTYPE_B>
2$:	.WORD	BYTE-2$				; code for byte dtype
	.WORD	WORD-2$				; code for word dtype
	.WORD	LONG-2$				; code for long dtype
	.WORD	ERR_DATTYPERR-2$		; quad not supported
	.WORD	FLOAT-2$			; code for float dtype
	.WORD	DOUBLE-2$			; code for double dtype

;+
; G and H floating fall outside the range of the CASEB statement.
;-

	CMPB	DSC$B_DTYPE(R2), #DSC$K_DTYPE_G
	BNEQ	3$
	BRW	GFLOAT

3$:	CMPB	DSC$B_DTYPE(R2), #DSC$K_DTYPE_H
	BNEQ	4$
	BRW	HFLOAT

4$:	CMPB	DSC$B_DTYPE(R2), #DSC$K_DTYPE_DSC
	BNEQ	ERR_DATTYPERR
	MOVL	4(R2), R2			; R2 <-- addr of descriptor
	BRB	SEPARATE_DTYPES			; CASE again for dtype in desc

ERR_DATTYPERR:
	PUSHL	#BAS$K_DATTYPERR		; Signal error, unsupported
	CALLS	#1, G^BAS$$STOP			; dtype in array desc

	.PAGE
;+
; Source array is a byte array.  Now differentiate on the scalar type.
;-

BYTE:	MOVL	AP, R5
5$:	CASEB	scalar_dtype(R5), #DSC$K_DTYPE_B, #<DSC$K_DTYPE_D - DSC$K_DTYPE_B>
1$:	.WORD	BYTE_TO_BYTE-1$			; code for byte dtype
	.WORD	BYTE_TO_WORD-1$			; code for word dtype
	.WORD	BYTE_TO_LONG-1$			; code for long dtype
	.WORD	ERR_DATTYPERR-1$		; quad not supported
	.WORD	BYTE_TO_FLOAT-1$		; code for float dtype
	.WORD	BYTE_TO_DOUBLE-1$		; code for double dtype

;+
; Check for g and h floating separately, since they fall outside the range
; of the CASEB.
;-

	CMPB	scalar_dtype(R5), #DSC$K_DTYPE_G
	BNEQ	2$
	BRW	BYTE_TO_GFLOAT

2$:	CMPB	scalar_dtype(R5), #DSC$K_DTYPE_H
	BNEQ	3$
	BRW	BYTE_TO_HFLOAT

3$:	CMPB	scalar_dtype(R5), #DSC$K_DTYPE_DSC
	BNEQ	4$
	MOVL	SRC_MATRIX(R5), R5
	BRB	5$

4$:	BRW	ERR_DATTYPERR			; unsupported dtype
;+
; Now type of source array and scalar are known.  Use the macro to
; generate the code for each case
;-

	.PAGE
BYTE_TO_BYTE:	$BAS$MAT_SC_MUL	B, B

	.PAGE
BYTE_TO_WORD:	$BAS$MAT_SC_MUL	B, W

	.PAGE
BYTE_TO_LONG:	$BAS$MAT_SC_MUL	B, L

	.PAGE
BYTE_TO_FLOAT:	$BAS$MAT_SC_MUL	B, F

	.PAGE
BYTE_TO_DOUBLE:	$BAS$MAT_SC_MUL	B, D

	.PAGE
BYTE_TO_GFLOAT: $BAS$MAT_SC_MUL	B, G

	.PAGE
BYTE_TO_HFLOAT: $BAS$MAT_SC_MUL	B, H
	.PAGE
;+
; Source array is a word array.  Now differentiate on the scalar type.
;-

WORD:	MOVL	AP, R5
5$:	CASEB	scalar_dtype(R5), #DSC$K_DTYPE_B, #<DSC$K_DTYPE_D - DSC$K_DTYPE_B>
1$:	.WORD	WORD_TO_BYTE-1$			; code for byte dtype
	.WORD	WORD_TO_WORD-1$			; code for word dtype
	.WORD	WORD_TO_LONG-1$			; code for long dtype
	.WORD	ERR_DATTYPERR-1$		; quad not supported
	.WORD	WORD_TO_FLOAT-1$		; code for float dtype
	.WORD	WORD_TO_DOUBLE-1$		; code for double dtype

;+
; Check for g and h floating separately, since they fall outside the range
; of the CASEB statement.
;-

	CMPB	scalar_dtype(R5), #DSC$K_DTYPE_G
	BNEQ	2$
	BRW	WORD_TO_GFLOAT

2$:	CMPB	scalar_dtype(R5), #DSC$K_DTYPE_H
	BNEQ	3$
	BRW	WORD_TO_HFLOAT

3$:	CMPB	scalar_dtype(R5), #DSC$K_DTYPE_DSC
	BNEQ	4$
	MOVL	SRC_MATRIX(R5), R5
	BRB	5$

4$:	BRW	ERR_DATTYPERR			; unsupported dtype

;+
; Now type of source array and scalar are known.  Use the macro to
; generate the code for each case
;-

	.PAGE
WORD_TO_BYTE: 	$BAS$MAT_SC_MUL W, B

	.PAGE
WORD_TO_WORD:	$BAS$MAT_SC_MUL	W, W

	.PAGE
WORD_TO_LONG:	$BAS$MAT_SC_MUL	W, L

	.PAGE
WORD_TO_FLOAT:	$BAS$MAT_SC_MUL	W, F

	.PAGE
WORD_TO_DOUBLE:	$BAS$MAT_SC_MUL	W, D

	.PAGE
WORD_TO_GFLOAT: $BAS$MAT_SC_MUL W, G

	.PAGE
WORD_TO_HFLOAT: $BAS$MAT_SC_MUL	W, H

	.PAGE
;+
; Source array is a longword array.  Now differentiate on the scalar type
;-

LONG:	MOVL	AP, R5
5$:	CASEB	scalar_dtype(R5), #DSC$K_DTYPE_B, #<DSC$K_DTYPE_D - DSC$K_DTYPE_B>
1$:	.WORD	LONG_TO_BYTE-1$			; code for byte dtype
	.WORD	LONG_TO_WORD-1$			; code for word dtype
	.WORD	LONG_TO_LONG-1$			; code for long dtype
	.WORD	ERR_DATTYPERR-1$		; quad not supported
	.WORD	LONG_TO_FLOAT-1$		; code for float dtype
	.WORD	LONG_TO_DOUBLE-1$		; code for double dtype

;+
; Check for g and h floating separately, since they fall outside the range
; of the CASEB statement.
;-

	CMPB	scalar_dtype(R5), #DSC$K_DTYPE_G
	BNEQ	2$
	BRW	LONG_TO_GFLOAT

2$:	CMPB	scalar_dtype(R5), #DSC$K_DTYPE_H
	BNEQ	3$
	BRW	LONG_TO_HFLOAT

3$:	CMPB	scalar_dtype(R5), #DSC$K_DTYPE_DSC
	BNEQ	4$
	MOVL	SRC_MATRIX(R5), R5
	BRB	5$

4$:	BRW	ERR_DATTYPERR			; unsupported dtype


;+
; Now type of source array and scalar are known.  Use the macro to
; generate the code for each case
;-

	.PAGE
LONG_TO_BYTE:	$BAS$MAT_SC_MUL	L, B

	.PAGE
LONG_TO_WORD:	$BAS$MAT_SC_MUL	L, W

	.PAGE
LONG_TO_LONG:	$BAS$MAT_SC_MUL	L, L

	.PAGE
LONG_TO_FLOAT:	$BAS$MAT_SC_MUL	L, F

	.PAGE
LONG_TO_DOUBLE:	$BAS$MAT_SC_MUL	L, D

	.PAGE
LONG_TO_GFLOAT: $BAS$MAT_SC_MUL L, G	

	.PAGE
LONG_TO_HFLOAT: $BAS$MAT_SC_MUL L, H

	.PAGE
;+
; Source array is a floating array.  Now differentiate on the scalar type
;-

FLOAT:	MOVL	AP, R5
5$:	CASEB	scalar_dtype(R5), #DSC$K_DTYPE_B, #<DSC$K_DTYPE_D - DSC$K_DTYPE_B>
1$:	.WORD	FLOAT_TO_BYTE-1$		; code for byte dtype
	.WORD	FLOAT_TO_WORD-1$		; code for word dtype
	.WORD	FLOAT_TO_LONG-1$		; code for long dtype
	.WORD	ERR_DATTYPERR-1$		; quad not supported
	.WORD	FLOAT_TO_FLOAT-1$		; code for float dtype
	.WORD	FLOAT_TO_DOUBL-1$		; code for double dtype

;+
; Check for g and h floating separately, since they fall outside the range
; of the CASEB statement.
;-

	CMPB	scalar_dtype(R5), #DSC$K_DTYPE_G
	BNEQ	2$
	BRW	FLOAT_TO_GFLOA

2$:	CMPB	scalar_dtype(R5), #DSC$K_DTYPE_H
	BNEQ	3$
	BRW	FLOAT_TO_HFLOA

3$:	CMPB	scalar_dtype(R5), #DSC$K_DTYPE_DSC
	BNEQ	4$
	MOVL	SRC_MATRIX(R5), R5
	BRB	5$

4$:	BRW	ERR_DATTYPERR			; unsupported dtype

;+
; Now type of source array and scalar are known.  Use the macro to
; generate the code for each case
;-

	.PAGE
FLOAT_TO_BYTE:  $BAS$MAT_SC_MUL	F, B

	.PAGE
FLOAT_TO_WORD:	$BAS$MAT_SC_MUL	F, W

	.PAGE
FLOAT_TO_LONG:	$BAS$MAT_SC_MUL	F, L

	.PAGE
FLOAT_TO_FLOAT:	$BAS$MAT_SC_MUL	F, F

	.PAGE
FLOAT_TO_DOUBL:	$BAS$MAT_SC_MUL	F, D

	.PAGE
FLOAT_TO_GFLOA: $BAS$MAT_SC_MUL	F, G

	.PAGE
FLOAT_TO_HFLOA: $BAS$MAT_SC_MUL F, H
	.PAGE
;+
; Source array is a double array.  Now differentiate on the scalartype.
;-

DOUBLE:	MOVL	AP, R5
5$:	CASEB	scalar_dtype(R5), #DSC$K_DTYPE_B, #<DSC$K_DTYPE_D - DSC$K_DTYPE_B>
1$:	.WORD	DOUBLE_TO_BYTE-1$		; code for byte dtype
	.WORD	DOUBLE_TO_WORD-1$		; code for word dtype
	.WORD	DOUBLE_TO_LONG-1$		; code for long dtype
	.WORD	ERR_DATTYPERR-1$		; quad not supported
	.WORD	DOUBLE_TO_FLOA-1$		; code for float dtype
	.WORD	DOUBLE_TO_DOUBL-1$		; code for double dtype

;+
; Check for g and h floating separately, since they fall outside the range
; of the CASEB statement.
;-

	CMPB	scalar_dtype(R5), #DSC$K_DTYPE_G
	BNEQ	2$
	BRW	DOUBLE_TO_GFLOA

2$:	CMPB	scalar_dtype(R5), #DSC$K_DTYPE_H
	BNEQ	3$
	BRW	DOUBLE_TO_HFLOA

3$:	CMPB	scalar_dtype(R5), #DSC$K_DTYPE_DSC
	BNEQ	4$
	MOVL	SRC_MATRIX(R5), R5
	BRB	5$

4$:	BRW	ERR_DATTYPERR			; unsupported dtype

;+
; Now type of source array and scalar are known.  Use the macro to
; generate the code for each case
;-

	.PAGE
DOUBLE_TO_BYTE:	$BAS$MAT_SC_MUL	D, B

	.PAGE
DOUBLE_TO_WORD:	$BAS$MAT_SC_MUL	D, W

	.PAGE
DOUBLE_TO_LONG:	$BAS$MAT_SC_MUL	D, L

	.PAGE
DOUBLE_TO_FLOA: $BAS$MAT_SC_MUL	D, F

	.PAGE
DOUBLE_TO_DOUBL: $BAS$MAT_SC_MUL D, D

	.PAGE
DOUBLE_TO_GFLOA: $BAS$MAT_SC_MUL D, G

	.PAGE
DOUBLE_TO_HFLOA: $BAS$MAT_SC_MUL D, H

	.PAGE
;+
; Source array is a gfloat array.  Now differentiate on the scalartype.
;-

GFLOAT:	MOVL	AP, R5
5$:	CASEB	scalar_dtype(R5), #DSC$K_DTYPE_B, #<DSC$K_DTYPE_D - DSC$K_DTYPE_B>
1$:	.WORD	GFLOAT_TO_BYTE-1$		; code for byte dtype
	.WORD	GFLOAT_TO_WORD-1$		; code for word dtype
	.WORD	GFLOAT_TO_LONG-1$		; code for long dtype
	.WORD	ERR_DATTYPERR-1$		; quad not supported
	.WORD	GFLOAT_TO_FLOA-1$		; code for float dtype
	.WORD	GFLOAT_TO_DOUBL-1$		; code for double dtype

;+
; Check for g and h floating separately, since they fall outside the range
; of the CASEB statement.
;-

	CMPB	scalar_dtype(R5), #DSC$K_DTYPE_G
	BNEQ	2$
	BRW	GFLOAT_TO_GFLOA

2$:	CMPB	scalar_dtype(R5), #DSC$K_DTYPE_H
	BNEQ	3$
	BRW	GFLOAT_TO_HFLOA

3$:	CMPB	scalar_dtype(R5), #DSC$K_DTYPE_DSC
	BNEQ	4$
	MOVL	SRC_MATRIX(R5), R5
	BRB	5$

4$:	BRW	ERR_DATTYPERR			; unsupported dtype

;+
; Now type of source array and scalar are known.  Use the macro to
; generate the code for each case
;-

	.PAGE
GFLOAT_TO_BYTE:	$BAS$MAT_SC_MUL	G, B

	.PAGE
GFLOAT_TO_WORD:	$BAS$MAT_SC_MUL	G, W

	.PAGE
GFLOAT_TO_LONG:	$BAS$MAT_SC_MUL	G, L

	.PAGE
GFLOAT_TO_FLOA: $BAS$MAT_SC_MUL G, F

	.PAGE
GFLOAT_TO_DOUBL: $BAS$MAT_SC_MUL G, D

	.PAGE
GFLOAT_TO_GFLOA: $BAS$MAT_SC_MUL G, G

	.PAGE
GFLOAT_TO_HFLOA: $BAS$MAT_SC_MUL G, H

	.PAGE
;+
; Source array is an hfloat array.  Now differentiate on the scalartype.
;-

HFLOAT:	MOVL	AP, R5
5$:	CASEB	scalar_dtype(R5), #DSC$K_DTYPE_B, #<DSC$K_DTYPE_D - DSC$K_DTYPE_B>
1$:	.WORD	HFLOAT_TO_BYTE-1$		; code for byte dtype
	.WORD	HFLOAT_TO_WORD-1$		; code for word dtype
	.WORD	HFLOAT_TO_LONG-1$		; code for long dtype
	.WORD	ERR_DATTYPERR-1$		; quad not supported
	.WORD	HFLOAT_TO_FLOA-1$		; code for float dtype
	.WORD	HFLOAT_TO_DOUBL-1$		; code for double dtype

;+
; Check for g and h floating separately, since they fall outside the range
; of the CASEB statement.
;-

	CMPB	scalar_dtype(R5), #DSC$K_DTYPE_G
	BNEQ	2$
	BRW	HFLOAT_TO_GFLOA

2$:	CMPB	scalar_dtype(R5), #DSC$K_DTYPE_H
	BNEQ	3$
	BRW	HFLOAT_TO_HFLOA

3$:	CMPB	scalar_dtype(R5), #DSC$K_DTYPE_DSC
	BNEQ	4$
	MOVL	SRC_MATRIX(R5), R5
	BRB	5$

4$:	BRW	ERR_DATTYPERR			; unsupported dtype

;+
; Now type of source array and scalar are known.  Use the macro to
; generate the code for each case
;-

	.PAGE
HFLOAT_TO_BYTE:	$BAS$MAT_SC_MUL	H, B

	.PAGE
HFLOAT_TO_WORD:	$BAS$MAT_SC_MUL	H, W

	.PAGE
HFLOAT_TO_LONG:	$BAS$MAT_SC_MUL	H, L

	.PAGE
HFLOAT_TO_FLOA: $BAS$MAT_SC_MUL	H, F

	.PAGE
HFLOAT_TO_DOUBL: $BAS$MAT_SC_MUL H, D

	.PAGE
HFLOAT_TO_GFLOA: $BAS$MAT_SC_MUL H, G

	.PAGE
HFLOAT_TO_HFLOA: $BAS$MAT_SC_MUL H, H



;+
; Multiply has been in byte.  Determine destination type to convert to dest.
;-

DEST_CASE_B:
	MOVL	R10, R6				; save original pointer
31$:	CASEB	DSC$B_DTYPE(R6), #DSC$K_DTYPE_B, #<DSC$K_DTYPE_D - DSC$K_DTYPE_B>
1$:	.WORD	STORE_BYTE-1$			; no conversion needed
	.WORD	DEST_B_TO_W-1$			; code for word dtype
	.WORD	DEST_B_TO_L-1$			; code for long dtype
	.WORD	ERR_DATTYPERR-1$		; quad not supported
	.WORD	DEST_B_TO_F-1$			; code for float dtype
	.WORD	DEST_B_TO_D-1$			; code for double dtype

;+
; Check for g and h floating separately, since they fall outside the range
; of the CASEB statement.
;-

	CMPB	DSC$B_DTYPE(R6), #DSC$K_DTYPE_G
	BNEQ	2$
	BRW	DEST_B_TO_G

2$:	CMPB	DSC$B_DTYPE(R6), #DSC$K_DTYPE_H
	BNEQ	3$
	BRW	DEST_B_TO_H

3$:	CMPB	DSC$B_DTYPE(R6), #DSC$K_DTYPE_DSC
	BNEQ	4$
	MOVL	4(R6), R6
	BRB	31$

4$:	BRW	ERR_DATTYPERR			; unsupported dtype

;+
; Multiply has been in word.  Determine destination type to convert to dest.
;-

DEST_CASE_W:
	MOVL	R10, R6
33$:	CASEB	DSC$B_DTYPE(R6), #DSC$K_DTYPE_B, #<DSC$K_DTYPE_D - DSC$K_DTYPE_B>
1$:	.WORD	DEST_W_TO_B-1$			; code for byte dtype
	.WORD	STORE_WORD-1$			; no conversion needed
	.WORD	DEST_W_TO_L-1$			; code for long dtype
	.WORD	ERR_DATTYPERR-1$		; quad not supported
	.WORD	DEST_W_TO_F-1$			; code for float dtype
	.WORD	DEST_W_TO_D-1$			; code for double dtype

;+
; Check for g and h floating separately, since they fall outside the range
; of the CASEB statement.
;-

	CMPB	DSC$B_DTYPE(R6), #DSC$K_DTYPE_G
	BNEQ	2$
	BRW	DEST_W_TO_G

2$:	CMPB	DSC$B_DTYPE(R6), #DSC$K_DTYPE_H
	BNEQ	3$
	BRW	DEST_W_TO_H

3$:	CMPB	DSC$B_DTYPE(R6), #DSC$K_DTYPE_DSC
	BNEQ	4$
	MOVL	4(R6), R6
	BRB	33$

4$:	BRW	ERR_DATTYPERR			; unsupported dtype

;+
; Multiply has been in long.  Determine destination type to convert to dest.
;-

DEST_CASE_L:
	MOVL	R10, R6
35$:	CASEB	DSC$B_DTYPE(R6), #DSC$K_DTYPE_B, #<DSC$K_DTYPE_D - DSC$K_DTYPE_B>
1$:	.WORD	DEST_L_TO_B-1$			; code for byte dtype
	.WORD	DEST_L_TO_W-1$			; code for word dtype
	.WORD	STORE_LONG-1$			; no conversion needed
	.WORD	ERR_DATTYPERR-1$		; quad not supported
	.WORD	DEST_L_TO_F-1$			; code for float dtype
	.WORD	DEST_L_TO_D-1$			; code for double dtype

;+
; Check for g and h floating separately, since they fall outside the range
; of the CASEB statement.
;-

	CMPB	DSC$B_DTYPE(R6), #DSC$K_DTYPE_G
	BNEQ	2$
	BRW	DEST_L_TO_G

2$:	CMPB	DSC$B_DTYPE(R6), #DSC$K_DTYPE_H
	BNEQ	3$
	BRW	DEST_L_TO_H

3$:	CMPB	DSC$B_DTYPE(R6), #DSC$K_DTYPE_DSC
	BNEQ	4$
	MOVL	4(R6), R6
	BRB	35$

4$:	BRW	ERR_DATTYPERR			; unsupported dtype

;+
; Multiply has been in float.  Determine destination type to convert to dest.
;-

DEST_CASE_F:
	MOVL	R10, R6
37$:	CASEB	DSC$B_DTYPE(R6), #DSC$K_DTYPE_B, #<DSC$K_DTYPE_D - DSC$K_DTYPE_B>
1$:	.WORD	DEST_F_TO_B-1$			; code for byte dtype
	.WORD	DEST_F_TO_W-1$			; code for word dtype
	.WORD	DEST_F_TO_L-1$			; code for long dtype
	.WORD	ERR_DATTYPERR-1$		; quad not supported
	.WORD	STORE_FLOAT-1$			; no conversion needed
	.WORD	DEST_F_TO_D-1$			; code for double dtype

;+
; Check for g and h floating separately, since they fall outside the range
; of the CASEB statement.
;-

	CMPB	DSC$B_DTYPE(R6), #DSC$K_DTYPE_G
	BNEQ	2$
	BRW	DEST_F_TO_G

2$:	CMPB	DSC$B_DTYPE(R6), #DSC$K_DTYPE_H
	BNEQ	3$
	BRW	DEST_F_TO_H

3$:	CMPB	DSC$B_DTYPE(R6), #DSC$K_DTYPE_DSC
	BNEQ	4$
	MOVL	4(R6), R6
	BRB	37$

4$:	BRW	ERR_DATTYPERR			; unsupported dtype

;+
; Multiply has been in double.
; Determine destination type to convert to dest.
;-

DEST_CASE_D:
	MOVL	R10, R6
39$:	CASEB	DSC$B_DTYPE(R6), #DSC$K_DTYPE_B, #<DSC$K_DTYPE_D - DSC$K_DTYPE_B>
1$:	.WORD	DEST_D_TO_B-1$			; code for byte dtype
	.WORD	DEST_D_TO_W-1$			; code for word dtype
	.WORD	DEST_D_TO_L-1$			; code for long dtype
	.WORD	ERR_DATTYPERR-1$		; quad not supported
	.WORD	DEST_D_TO_F-1$			; code for float dtype
	.WORD	STORE_DOUBLE-1$			; store it as is

;+
; Check for g and h floating separately, since they fall outside the range
; of the CASEB statement.
;-

	CMPB	DSC$B_DTYPE(R6), #DSC$K_DTYPE_G
	BNEQ	2$
	BRW	DEST_D_TO_G

2$:	CMPB	DSC$B_DTYPE(R6), #DSC$K_DTYPE_H
	BNEQ	3$
	BRW	DEST_D_TO_H

3$:	CMPB	DSC$B_DTYPE(R6), #DSC$K_DTYPE_DSC
	BNEQ	4$
	MOVL	4(R6), R6
	BRB	39$

4$:	BRW	ERR_DATTYPERR			; unsupported dtype

;+
; Multiply has been in gfloat.  Determine destination type to convert to dest.
;-

DEST_CASE_G:
	MOVL	R10, R6
41$:	CASEB	DSC$B_DTYPE(R6), #DSC$K_DTYPE_B, #<DSC$K_DTYPE_D - DSC$K_DTYPE_B>
1$:	.WORD	DEST_G_TO_B-1$			; code for byte dtype
	.WORD	DEST_G_TO_W-1$			; code for word dtype
	.WORD	DEST_G_TO_L-1$			; code for long dtype
	.WORD	ERR_DATTYPERR-1$		; quad not supported
	.WORD	DEST_G_TO_F-1$			; code for float dtype
	.WORD	DEST_G_TO_D-1$			; code for double dtype

;+
; Check for g and h floating separately, since they fall outside the range
; of the CASEB statement.
;-

	CMPB	DSC$B_DTYPE(R6), #DSC$K_DTYPE_G
	BNEQ	2$
	BRW	STORE_GFLOAT

2$:	CMPB	DSC$B_DTYPE(R6), #DSC$K_DTYPE_H
	BNEQ	3$
	BRW	DEST_G_TO_H

3$:	CMPB	DSC$B_DTYPE(R6), #DSC$K_DTYPE_DSC
	BNEQ	4$
	MOVL	4(R6), R6
	BRB	41$

4$:	BRW	ERR_DATTYPERR			; unsupported dtype

;+
; Multiply has been in hfloat.  Determine destination type to convert to dest.
;-

DEST_CASE_H:
	MOVL	R10, R6
43$:	CASEB	DSC$B_DTYPE(R6), #DSC$K_DTYPE_B, #<DSC$K_DTYPE_D - DSC$K_DTYPE_B>
1$:	.WORD	DEST_H_TO_B-1$			; code for byte dtype
	.WORD	DEST_H_TO_W-1$			; code for word dtype
	.WORD	DEST_H_TO_L-1$			; code for long dtype
	.WORD	ERR_DATTYPERR-1$		; quad not supported
	.WORD	DEST_H_TO_F-1$			; code for float dtype
	.WORD	DEST_H_TO_D-1$			; code for double dtype

;+
; Check for g and h floating separately, since they fall outside the range
; of the CASEB statement.
;-

	CMPB	DSC$B_DTYPE(R6), #DSC$K_DTYPE_G
	BNEQ	2$
	BRW	DEST_H_TO_G

2$:	CMPB	DSC$B_DTYPE(R6), #DSC$K_DTYPE_H
	BNEQ	3$
	BRW	STORE_HFLOAT

3$:	CMPB	DSC$B_DTYPE(R6), #DSC$K_DTYPE_DSC
	BNEQ	4$
	MOVL	4(R6), R6
	BRB	43$

4$:	BRW	ERR_DATTYPERR			; unsupported dtype

DEST_W_TO_B:
	CVTWB	R0, R0				; convert
	BRB	STORE_BYTE			; go store

DEST_L_TO_B:
	CVTLB	R0, R0				; convert
	BRB	STORE_BYTE			; go store

DEST_F_TO_B:
	CVTFB	R0, R0				; convert
	BRB	STORE_BYTE			; go store

DEST_D_TO_B:
	DIVD2	scale(R4), R0			; descale the double
	CVTDB	R0, R0				; convert
	BRB	STORE_BYTE			; go store

DEST_G_TO_B:
	CVTGB	R0, R0				; convert
	BRB	STORE_BYTE			; go store

DEST_H_TO_B:
	CVTHB	R0, R0				; convert
						; fall into store

STORE_BYTE:
	MOVL	R10, R1				; pointer to dest descriptor
	MOVL	lower_bnd1(R4), R2		; current row
	MOVL	R11, R3				; current column
;+
; Redefine the following offsets for the call to the STORE macro.  The
; BSBW to here added 4 to the stack.
;-

value_desc = 44
str_len = 44
dtype = 46
class = 47
pointer = 48
data = 52

	MOVB	R0, data(SP)
	STORE	B				; store
;+
; Restore the following offsets.
;-

value_desc = 40
str_len = 40
dtype = 42
class = 43
pointer = 44
data = 48

	RSB					; go continue loop

DEST_B_TO_W:
	CVTBW	R0, R0				; convert
	BRB	STORE_WORD			; go store

DEST_L_TO_W:
	CVTLW	R0, R0				; convert
	BRB	STORE_WORD			; go store

DEST_F_TO_W:
	CVTFW	R0, R0				; convert
	BRB	STORE_WORD			; go store

DEST_D_TO_W:
	DIVD2	scale(R4), R0			; descale the double
	CVTDW	R0, R0				; convert to word
	BRB	STORE_WORD			; go store

DEST_G_TO_W:
	CVTGW	R0, R0				; convert
	BRB	STORE_WORD			; go store

DEST_H_TO_W:
	CVTHW	R0, R0				; convert
						; fall into store		

STORE_WORD:
	MOVL	R10, R1				; pointer to dest descriptor
	MOVL	lower_bnd1(R4), R2		; current row
	MOVL	R11, R3				; current column
;+
; Redefine the following offsets for the call to the STORE macro.  The
; BSBW to here added 4 to the stack.
;-

value_desc = 44
str_len = 44
dtype = 46
class = 47
pointer = 48
data = 52

	MOVW	R0, data(SP)
	STORE	W				; store
;+
; Restore the following offsets.
;-

value_desc = 40
str_len = 40
dtype = 42
class = 43
pointer = 44
data = 48
	RSB					; go continue loop

DEST_B_TO_L:	
	CVTBL	R0, R0				; convert
	BRB	STORE_LONG			; go store

DEST_W_TO_L:
	CVTWL	R0, R0				; convert
	BRB	STORE_LONG			; go store

DEST_F_TO_L:
	CVTFL	R0, R0				; convert
	BRB	STORE_LONG			; go store

DEST_D_TO_L:
	DIVD2	scale(R4), R0			; descale the double
	CVTDL	R0, R0				; convert
	BRB	STORE_LONG			; go store

DEST_G_TO_L:
	CVTGL	R0, R0				; convert
	BRB	STORE_LONG			; go store

DEST_H_TO_L:
	CVTHL	R0, R0				; convert
						; fall into store		

STORE_LONG:
	MOVL	R10, R1				; pointer to dest descriptor
	MOVL	lower_bnd1(R4), R2		; current row
	MOVL	R11, R3				; current column
;+
; Redefine the following offsets for the call to the STORE macro.  The
; BSBW to here added 4 to the stack.
;-

value_desc = 44
str_len = 44
dtype = 46
class = 47
pointer = 48
data = 52

	MOVL	R0, data(SP)
	STORE	L				; store
;+
; Restore the following offsets.
;-

value_desc = 40
str_len = 40
dtype = 42
class = 43
pointer = 44
data = 48
	RSB					; go continue loop

DEST_B_TO_F:
	CVTBF	R0, R0				; convert
	BRB	STORE_FLOAT			; go store

DEST_W_TO_F:
	CVTWF	R0, R0				; convert
	BRB	STORE_FLOAT			; go store

DEST_L_TO_F:
	CVTLF	R0, R0				; convert
	BRB	STORE_FLOAT			; go store

DEST_D_TO_F:
	DIVD2	scale(R4), R0			; descale the double
	CVTDF	R0, R0				; convert
	BRB	STORE_FLOAT			; go store

DEST_G_TO_F:
	CVTGF	R0, R0				; convert
	BRB	STORE_FLOAT			; go store

DEST_H_TO_F:
	CVTHF	R0, R0				; convert
						; fall into store		

STORE_FLOAT:
	MOVL	R10, R1				; pointer to dest descriptor
	MOVL	lower_bnd1(R4), R2		; current row
	MOVL	R11, R3				; current column
;+
; Redefine the following offsets for the call to the STORE macro.  The
; BSBW to here added 4 to the stack.
;-

value_desc = 44
str_len = 44
dtype = 46
class = 47
pointer = 48
data = 52

	MOVF	R0, data(SP)
	STORE	F				; store
;+
; Restore the following offsets.
;-

value_desc = 40
str_len = 40
dtype = 42
class = 43
pointer = 44
data = 48
	RSB					; go continue loop
						; fall into store float
DEST_B_TO_D:
	CVTBD	R0, R0				; get double
	MULD2	scale(R4), R0			; scale the double			
						;  NOTE: no need for integerize
	BRB	STORE_DOUBLE			; go store

DEST_W_TO_D:
	CVTWD	R0, R0				; get double
	MULD2	scale(R4), R0			; scale the double
						;  NOTE: no need for integerize
	BRB	STORE_DOUBLE			; go store

DEST_L_TO_D:
	CVTLD	R0, R0				; get double
	MULD2	scale(R4), R0			; scale for dest
						;  NOTE: no need for integerize
	BRB	STORE_DOUBLE			;  go store

DEST_F_TO_D:
	CVTFD	R0, R0				; get double
	MULD2	scale(R4), R0			; scale for dest
	CMPD	scale(R4), #1			; scale 0?
	BEQL	1$				; yes, don't integerize
	MOVL	R4, -(SP)			; save R4
	JSB	G^MTH$DINT_R4			; integerize
	MOVL	(SP)+, R4			; restore R4
1$:	BRB	STORE_DOUBLE			; go store

DEST_G_TO_D:
	;+
	; Note the intermediate conversion to hfloat.
	;-
	MOVL	R2, -(SP)			; save regs which CVTGH
	MOVL	R3, -(SP)			;  will destroy
	CVTGH	R0, R0				; cvt gfloat to hfloat
	CVTHD 	R0, R0				; cvt to desired double
	MOVL	(SP)+, R3			; restore regs
	MOVL	(SP)+, R2	
	MULD2	scale(R4), R0			; scale for dest
	CMPD	scale(R4), #1			; scale 0?
	BEQL	STORE_DOUBLE			; yes, don't integerize
	MOVL	R4, -(SP)			; save R4
	JSB	G^MTH$DINT_R4			; integerize
	MOVL	(SP)+, R4			; restore R4
	BRW 	STORE_DOUBLE

DEST_H_TO_D:
	CVTHD	R0, R0				; get double
	MULD2	scale(R4), R0			; scale for dest
	CMPD	scale(R4), #1			; scale 0?
	BEQL	STORE_DOUBLE			; yes, don't integerize
	MOVL	R4, -(SP)			; save R4
	JSB	G^MTH$DINT_R4			; integerize
	MOVL	(SP)+, R4			; restore R4
						; fall into store

STORE_DOUBLE:
	MOVL	R10, R2				; pointer to dest descriptor
	MOVL	lower_bnd1(R4), R3		; current row
	MOVL	R11, R4				; current column
;+
; Redefine the following offsets for the call to the STORE macro.  The
; BSBW to here added 4 to the stack.
;-

value_desc = 44
str_len = 44
dtype = 46
class = 47
pointer = 48
data = 52

	MOVD	R0, data(SP)
	STORE	D				; store
;+
; Restore the following offsets.
;-

value_desc = 40
str_len = 40
dtype = 42
class = 43
pointer = 44
data = 48
	RSB					; go continue loop

DEST_B_TO_G:
	CVTBG	R0, R0				; convert
	BRB	STORE_GFLOAT			; go store

DEST_W_TO_G:
	CVTWG	R0, R0				; convert
	BRB	STORE_GFLOAT			; go store

DEST_L_TO_G:
	CVTLG	R0, R0				; convert
	BRB	STORE_GFLOAT			; go store

DEST_F_TO_G:
	CVTFG	R0, R0				; convert
	BRB	STORE_GFLOAT			; go store

DEST_D_TO_G:
	;+
	; Note the intermediate conversion to hfloat.
	;-
	MOVL	R2, -(SP)			; save regs which CVTDH
	MOVL	R3, -(SP)			;  will destroy
	CVTDH	R0, R0				; cvt dbl to hfloat
	CVTHG 	R0, R0				; cvt to desired gfloat
	MOVL	(SP)+, R3			; restore regs
	MOVL	(SP)+, R2	
	BRW 	STORE_GFLOAT

DEST_H_TO_G:
	CVTHG	R0, R0				; convert
						; fall into store

STORE_GFLOAT:
	MOVL	R10, R2				; pointer to dest descriptor
	MOVL	lower_bnd1(R4), R3		; current row
	MOVL	R11, R4				; current column
;+
; Redefine the following offsets for the call to the STORE macro.  The
; BSBW to here added 4 to the stack.
;-

value_desc = 44
str_len = 44
dtype = 46
class = 47
pointer = 48
data = 52

	MOVG	R0, data(SP)
	STORE	G				; store
;+
; Restore the following offsets.
;-

value_desc = 40
str_len = 40
dtype = 42
class = 43
pointer = 44
data = 48
	RSB					; go continue loop

DEST_B_TO_H:
	CVTBH	R0, R0				; convert
	BRB	STORE_HFLOAT			; go store

DEST_W_TO_H:
	CVTWH	R0, R0				; convert
	BRB	STORE_HFLOAT			; go store

DEST_L_TO_H:
	CVTLH	R0, R0				; convert
	BRB	STORE_HFLOAT			; go store

DEST_F_TO_H:
	CVTFH	R0, R0				; convert
	BRB	STORE_HFLOAT			; go store

DEST_D_TO_H:
	DIVD2	scale(R4), R0			; descale the double
	CVTDH	R0, R0				; convert
	BRB	STORE_HFLOAT			; go store

DEST_G_TO_H:
	CVTGH	R0, R0				; convert
						; fall into store

STORE_HFLOAT:
	MOVL	lower_bnd1(R4), R5		; current row
	MOVL	R10, R4				; pointer to dest descriptor
	MOVL	R11, R6				; current column
;+
; Redefine the following offsets for the call to the STORE macro.  The
; BSBW to here added 4 to the stack.
;-

value_desc = 44
str_len = 44
dtype = 46
class = 47
pointer = 48
data = 52

	MOVH	R0, data(SP)
	STORE	H				; store
;+
; Restore the following offsets.
;-

value_desc = 40
str_len = 40
dtype = 42
class = 43
pointer = 44
data = 48
	RSB					; go continue loop


	.END					; end of BAS$MAT_SCA_MUL
