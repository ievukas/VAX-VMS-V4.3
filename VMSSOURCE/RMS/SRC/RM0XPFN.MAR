	$BEGIN	RM0XPFN,000,RM$RMSFILENAME,<EXPAND FILENAME STRING>

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
;
; Facility: RMS
;
; Abstract:
;
;	This module expands the user supplied primary, default, and related
;	file name strings by the translation of logical names and the
;	application of defaults to form a fully qualified file specification.
;
; Environment: VAX/VMS, executive mode
;
; Author:	Keith B. Thompson,	Recreation Date: 7-Mar-1983
;
; Modified By:
;
;	V03-050	DGB0080		Donald G. Blair		21-Aug-1984
;		Fix bug in UPCASE_COMPRESS so that it doesn't write
;		past end of buffer when a quote is the last character
;		in a filename string.
;
;	V03-049	DGB0074		Donald G. Blair		02-Aug-1984
;		Fix node parsing so it remembers that the 2nd word
;		of a node descriptor may have flag bits set, i.e.
;		the length field is not a longword.
;
;	V03-048	DGB0073		Donald G. Blair		31-Jul-1984
;		Fix rooted directories so they are propagated correctly
;		from the related name block.  
;
;	V03-047	RAS0321		Ron Schaefer		 9-Jul-1984
;		Eliminate access mode itemlist checking for PPF after
;		translating logical names.   The check is not really
;		sufficient and just takes needless CPU cycles.
;
;	V03-046	DGB0059		Donald G. Blair		27-Jun-1984
;		Disallow concealed device names of the form 
;		"[dir-spec.]", i.e. those which are missing the 
;		device name.
;
;	V03-045	RAS0302		Ron Schaefer		30-Apr-1984
;		Return RMS$_NOD if a node name logical translates to
;		'node::xxxxx', this used to be accepted and 'xxxxx' was
;		ignored.   Fix instruction datatype used.
;
;	V03-044	JEJ0029		J E Johnson		19-Apr-1984
;		Make quoted network file specs check for other specification
;		parts than filename, such as directory, device, type, or
;		version.  This is illegal as the legal quoted spec is:
;		node"access control string::"filename".
;
;	V03-043	JEJ0028		J E Johnson		11-Apr-1984
;		Minor equate file cleanup.
;
;	V03-042	RAS0283		Ron Schaefer		28-Mar-1984
;		Change the loop counter for RAS0266 to be 32767. (!)
;		Only translate SYS$DISK if there in NOT a device name present
;		already.  This is the same as V3 but causes the searchlist
;		properties of SYS$DISK to be ignored if you have a device.
;		Try to improve the performance of this beast a tad.
;		Make explicit related-file rooted directories be ignored
;		if duplicate.
;
;	V03-041	RAS0266		Ron Schaefer		12-Mar-1984
;		Count the related NAM blocks that we parse. After processing
;		255 of them, give up and return RMS$_RLF.  This is far more
;		elegant than an infinite loop caused by invalid programs.
;
;	V03-040	RAS0261 	Ron Schaefer		 5-Mar-1984
;		Fix a couple of small bugs and help performance in RM$XPFN.
;		 1. Make related file node,dev and dir only be ignored if an
;		    explicit nodename (null or otherwise) was seen.
;		 2. Make FWA$V_NAM_DVI stay set so that concealed DVI devices
;		    stay that way.
;		 3. Make sure related sticky "..." directoriesare copied.
;		 4. Remove quoted string internal parsing from this module
;		    and put it into the network access code.
;
;	V03-039	RAS0253		Ron Schaefer		15-Feb-1984
;		Convert node logical name translation to use $TRNLNM.
;		Node logicals can not contain searchlists.
;		Convert the upcase algorithm to use EXE$UPCASE_DAT.
;		Ignore related node, device and dir fields when a 
;		node or null node is present.
;		Eliminate leading "_" manipulations, fix error return
;		for node-name logical RMS$_LNE errors.
;
;	V03-038	RAS0258		Ron Schaefer		24-Feb-1984
;		Fix RAS0256 and RAS0257 to only ignore related file PPFs.
;
;	V03-037	RAS0257		Ron Schaefer		23-Feb-1984
;		Fix RAS0256 so that concealed devices work correctly.
;
;	V03-036	RAS0256		Ron Schaefer		21-Feb-1984
;		Ignore PPFs that are from the DNA, RLFi or SET DEFAULT strings.
;
;	V03-035	RAS0248		Ron Schaefer		 4-Feb-1984
;		Ignore nul fields for input related filespecs.
;
;	V03-034	RAS0234		Ron Schaefer		11-Jan-1984
;		Add support for SLBHs, revise filename string storage
;		in order to implement multi-line input sticky searchlists.
;		Revise searchlist processing rules to incorporate
;		arbitrary many searchlist sources: FN, DN, RNi, and SD.
;		Any compatibility of filename parsing between V3 and V4
;		is purely coincidental after all this!
;
;	V03-033	RAS0238		Ron Schaefer		18-Jan-1984
;		Fix bad R11 value for allocating space to store the
;		filename strings.  (Fix to RAS0219).
;
;	V03-032	RAS0231		Ron Schaefer		 9-Jan-1984
;		Add support for NAM$V_SYNCHK (part 1); copy the NAM$V_SYNCHK
;		bit into FWA$V_SYNTAX_CHK for later use both here
;		and in $PARSE.
;
;	V03-031	RAS0219		Ron Schaefer		 8-Dec-1983
;		Revamp FWA structures for better memory use;
;		make translation buffers be dynamic.
;
;	V03-030	RAS0208		Ron Schaefer		 3-Nov-1983
;		Make sticky directories work for UIC-format directories.
;		The STICKY_DIR and MOVE_RELATED subroutines were
;		incompletely integrated.
;
;	V03-029	RAS0203		Ron Schaefer		18-Oct-1983
;		Fix network node parsing to not set the ACS flag
;		in all cases, but only when it is actually present.
;
;	V03-028	RAS0202		Ron Schaefer		17-Oct-1983
;		Clear translation attribute when processing the next
;		element of the searchlist.
;
;	V03-027	RAS0191		Ron Schaefer		12-Sep-1983
;		Fix bugcheck caused by bogus searchlist structures
;		created when "node::searchlist_devnam:" is encountered.
;		The correction involves eliminating a real obscure hack
;		in network filespec processing that allowed user-mode
;		process table device names to be translated.
;
;	V03-026	RAS0184		Ron Schaefer		 2-Sep-1983
;		Fix KBT0573 to be a NOP for now until the $TRNLOG is
;		converted to $TRNLNM for logical node names.
;
;	V03-025	KBT0581		Keith B. Thompson	11-Aug-1983
;		Change size of file name on magtape and fix a (yes
;		there was one) search list bug!
;
;	V03-024	KBT0573		Keith B. Thompson	3-Aug-1983
;		Remove last ref. to FAB$B_DSBMSK
;
;	V03-023	KBT0555		Keith B. Thompson	20-Jul-1983
;		Probe the input strings
;
;	V03-022	KBT0551		Keith B. Thompson	23-Jun-1983
;		FWA$B_LNFLG changed it's name
;
;	V03-021	KBT0545		Keith B. Thompson	22-Jun-1983
;		Fix an out of phase symbol
;
;	V03-020	KBT0535		Keith B. Thompson	25-May-1983
;		Use new logical name services and turn on search list
;
;	V03-019	KBT0514		Keith B. Thompson	23-May-1983
;		Put this monster in a remote psect
;
;	V03-018	KBT0505		Keith B. Thompson	3-May-1983
;		Add search list support
;
;	V03-017	RAS0150		Ron Schaefer		29-Apr-1983
;		Fix incorrect recursion error return path for
;		parsing the default directory.
;
;	V03-016	RAS0149		Ron Schaefer		28-Apr-1983
;		Fix wrong register usage for 'node::[]' and
;		get correct address for '[a.b...]'.
;
;	V03-015	KBT0500		Keith B. Thompson	7-Mar-1983
;		Rewrite PARSE_STRING, CHECK_FIELD, STICKY_DIR, MOVE_RELATED,
;		remove NEXT_FIELD etc...
;
;	V03-014	TMK0001		Todd M. Katz		28-Feb-1983
;		Change a BLSS to a BLSSU within the routine MOVE_RELATED.
;		When the maximum size of a directory specification went above
;		a hexadecimal 7F, this branch was always being taken. As a 
;		result, sticky directories broke.
;
;	V03-013	LJA0063		Laurie J. Anderson	23-Feb-1983
;		Move a couple routines involved with the NAM block to
;		RM0NAMSTR.MAR where they belong.  They include RM$CHKNAMBLK
;		and RM$CHKNAM.
;
;	V03-012	KBT0493		Keith B. Thompson	11-Feb-1983
;		Add support for null node spec.
;
;	V03-011	KBT0443		Keith B. Thompson	3-Jan-1983
;		Fix support for "$" and "_" in directory names.
;
;	V03-010	SHZ0001		Stephen H. Zalewski,	5-Nov-1982  16:05
;		Support '$' and '_' in both filenames and filetypes.  Also
;		allow filenames and filetypes to be a max of 39 characters
;		each.
;
;	V03-009	KBT0219		Keith B. Thompson	23-Aug-1982
;		Reorganize psects
;
;	V03-008	KRM0057		K Malik			10-Aug-1982
;		Change ASSUME statement in logical nodename translation
;		section to refer to new FWA$T_NODEBUF & FWA$B_UNDER_NOD
;		symbols.
;
;	V03-007	DMW4002		DMWalp			 1-Aug-1982
;		Correct problem where if input string > 63 alpha-num
;		characters without any punctuation then string was
;		dropped on the floor without an error because $TRNLOG
;		only copies the input to the output string on NOTRANS
;		error.
;
;	V03-006	KBT0100		Keith B. Thompson	13-Jul-1982
;		Clean up psects
;
;	V03-005	KRM0015		K R Malik		22-Apr-1982
;		For a network filespec, stop resolving leading hyphens in the
;		directory string (at the local node), because the hyphen has
;		meaning only in the context of the default directory at the
;		remote node. For example, in a directory string of the form
;		[-.A.B], the hyphen should be passed to FAL.
;
;	V03-004	JAK0076		J A Krycka		20-Apr-1982
;		Scan foreign filespec within a quoted string for wildcard
;		characters, and set the NAM$V_WILDCARD bit if any found.
;
;	V03-003	JAK0073		J A Krycka		12-Apr-1982
;		Eliminate the practice of prefixing a <del> character to a
;		resultant name string to indicate that the password has been
;		masked out of the nodespec. If the resultant name string is
;		then used as a related name string this flag character was
;		used to tell RMS to translate the nodespec string to obtain
;		the original nodespec with the real password. Now NXTFLD will
;		examine the access control string for a substring of 'pasword'
;		(setting V_PWD if found) to signal that the nodespec string
;		should be translated.
;
;	V03-002	KEK0029		K. E. Kinnear 		24-Mar-1982
;		Return FNM error when we first get a quoted string (which
;		we think is ANSI) and THEN get a node spec later.  Always
;		used to give an FNM error before the advent of ANSI strings.
;
;	V03-001	RAS0079		Ron Schaefer		17-Mar-1982
;		Add support for translation table mask (FAB$B_DSBMSK).
;		All three $TRNLOG services are affected.
;
;--

	.SBTTL	DECLARATIONS

;
; Include Files:
;

	$FABDEF
	$FSCBDEF
	$FWADEF
	$IFBDEF
	$LNMDEF
	$LOGDEF
	$NAMDEF
	$NWADEF
	$RMSDEF
	$SLBDEF
	$SLBHDEF
	$SSDEF
	$TRNLOGDEF

;
; Macros:
;

;
; Equated Symbols:
;

	FOP		= FAB$L_FOP * 8			; Bit offset to FOP
	WC		= FWA$B_WILDFLGS * 8		; Bit offset to wild card flags
	WCNTV_MASK	= <1@<FWA$V_WC_NAME-WC>>!-
			  <1@<FWA$V_WC_TYPE-WC>>!-
			  <1@<FWA$V_WC_VER-WC>>		; Wild name, type,
							;  or ver mask

;
; Other definitions:
;

	ESCAPE		= ^X1B		; ASCII escape character
	HOR_TAB		= ^X09		; ASCII value for horizontal tab

;
; Own Storage:
;


	.SBTTL	RM$XPFN, Filename Expansion Control Routine

;++
;
; RM$XPFN - four major routines are included here:
;
;	1.  RM$XPFN	-	high-level control routine to select
;				and verify the various strings to
;				be used to expand the filename.
;	2.  PARSE_STRING -	medium-level routine to parse an
;				individual string into its
;				constituent parts, translating
;				logical names, and merging the
;				results into the expanded string.
;	3.  CHECK_FIELD	-	low-level subroutine that
;				performs checks and other
;				functions as directed by PARSE_STRING.
;
; The high-level control routine, RM$XPFN performs the following functions:
;
;	1.  probes the filename string and calls PARSE_STRING to parse it.
;
;	2.  if not all filename fields (device, directory, file-name,
;	    file-type, and file-version) are present applies defaults
;	    in the order:
;
;		- default filename string (if any)
;		- related file (if any) for filename and/or filetype only
;		- default device by applying the logical name 'SYS$DISK:'
;		  (only if node not specified)
;		- default file directory as currently established
;		  (by login or the set default command) (only if
;		  node not specified)
;
;	3.  if a NAM block is specified and it includes an expanded
;	    string buffer, the expanded string will be copied to
;	    the buffer.
;
; Calling Sequence:
;
;	BSBW	RM$XPFN
;
; Input Parameters:
;
;	R8	FAB address
;	R9	IFAB address
;
; Implicit Inputs:
;
;	The contents of the FAB and related NAM block if any,
;	in particular the fields FNA, FNS, DNA, DNS, RLF, and NAM.
;		- if RLF specified, NAM in the related FAB and
;		  RSA and RSL in the NAM block
;		- if NAM, ESA and ESS
;
;	Also, the contents of the various logical name tables,
;	Especially with respect to the various system-defined names.
;
;	Also, the current default directory string.
;
;	FWA and NWA inputs:
;
;	FWA$Q_NODE	- descriptor of 127-char buffer in FWA
;	FWA$Q_DEVICE	- descriptor of  15-char buffer in FWA
;	FWA$Q_DIR1	- descriptor of   9-char buffer in FWA
;	FWA$Q_DIR2	- descriptor of   9-char buffer in FWA
;	FWA$Q_DIR2+8	- "
;	FWA$Q_DIR2+16	- "
;	FWA$Q_DIR2+24	- "
;	FWA$Q_DIR2+32	- "
;	FWA$Q_DIR2+40	- "
;	FWA$Q_DIR2+48	- "
;	FWA$Q_NAME	- descriptor of  10-char buffer in FWA
;	FWA$Q_TYPE	- descriptor of   4-char buffer in FWA
;	FWA$Q_VERSION	- descriptor of   6-char buffer in FWA
;	FWA$Q_QUOTED	- descriptor of 127-char buffer in FWA
;	FWA$Q_NODE1	- descriptor using shared node buffer in NWA
;	FWA$Q_NODE1+8	- "
;	FWA$Q_NODE1+16	- "
;	FWA$Q_NODE1+24	- "
;	FWA$Q_NODE1+32	- "
;	FWA$Q_NODE1+40	- "
;	FWA$Q_NODE1+48	- "
;	FWA$Q_NODE1+56	- "
;
;	Notes:
;		1.  the name, type, and version buffers must be
;		    adjacent and ascending in memory
;
;		2.  all other FWA fields should be zero
;
; Output Parameters:
;
;	R0	Status code
;	R1-R7	Destroyed
;	R10	FWA address
;	AP	Destroyed
;
; Implicit Outputs:
;
;	NAM block (if specified):
;		-if ESA specified buffer filled in with
;		 expanded filename string + ESL set to its
;		 length in bytes.
;
;	FWA:	-various flags set as per the parse
;		-FWA$B_DIRTERM set to directory terminating bracket (']' or '>')
;		-FWA$L_ESCSTRING set to escape string if seen
;		-the descriptors for the parsed filename elements
;		 are set with the sizes of the various elements
;		 of the filename string, the elements themselves
;		 having been copied to the buffers. The filetype
;		 and version are appended to the file name.
;
; Completion Codes:
;
;	Standard RMS completion codes, including:
;		SUC, FNA, DNA, RLF, SYN, NOD, DEV, DIR, FNM, TYP, VER, LNE,
;		QUO, NAM, ESA, ESS
;
; Side Effects:
;
;	None
;
;--

	ASSUME	2*<LNM$C_NAMLENGTH+1> LE 512	; 2 xlt buffers per page
	ASSUME	NAM$C_MAXRSS LE 256		; room for 1 copy of name

XPFN_SPACE = < 	<2*<LNM$C_NAMLENGTH+1>>+ -	; space for 2 xlt buffs
		<2*<FSCB$K_BLN>>+ -		; space for 2 FSCBs
		256  >				; space for name string

RM$XPFN::
	$TSTPT	XPFN
	JSB	RM$FWASET			; get a FWA
	BLBC	R0,10$				; branch on failure

	MOVZWL	#XPFN_SPACE,R2			; size of all the scratch space
	JSB	RM$GETPAG			; get scratch space 
	BLBC	R0,10$				; room?

	MOVAB	(R3),FWA$L_XLTBUFF1(R10)	; 1st buffer
	MOVAB	<1+LNM$C_NAMLENGTH>(R3),FWA$L_XLTBUFF2(R10) ; 2nd buffer
	MOVAB	<2*<LNM$C_NAMLENGTH+1>>(R3),-	; space for 2 xlt buffs
		FWA$L_BUF_PTR(R10)		; save scratch buffer address

	MOVL	R11,FWA$L_IMPURE_AREA(R10)	; save impure address
	MOVAB	<256+<2*<LNM$C_NAMLENGTH+1>>>(R3),-
		R11				; point to 1st FSCB
	BSBW	EXPAND_NAME			; do bulk of work
	MOVL	FWA$L_IMPURE_AREA(R10),R11	; restore impure address
	PUSHL	R0				; save status

	MOVZWL	#XPFN_SPACE,R5			; size of all the scratch space
	MOVL	FWA$L_XLTBUFF1(R10),R4		; addr of space
	JSB	RM$RETPAG			; return it all
	POPL	R0				; restore status
	BLBS	R0,20$
10$:	RSB					; exit with error

;
; Expand_name was successful!
;
; Check to see if there the first user directory is the MFD and flags it
; as such.  NOTE: We define '000000' as being a reserve word meaning
; the MFD which can be the real '000000.DIR' or the rooted directory.
;

20$:	MOVQ	FWA$Q_DIR1(R10),R6		; get first directory name
	CMPW	#6,R6				; is it the correct size
	BNEQ	40$				; can't be if not 6
	CMPL	#^A/0000/,(R7)+			; is it the form of
	BNEQ	40$				;  '000000'
	CMPW	#^A/00/,(R7)			; check the last two bytes
	BNEQ	40$				; no continue
	SSB	#FSCB$V_MFD,FWA$Q_DIR1(R10)	; we have one, set the flag

;
; We have all the parts described separately.
; Append file type and version to the filename.
;

40$:	BBC	#FWA$V_QUOTED,(R10),50$		; check if network quoted
	BBC	#FWA$V_NODE,(R10),44$		;  string found

;
; Network quoted string -- check for only filename and node specified.
; note that version and type were checked during the $filescan.
;

	BITL	#FWA$M_EXP_TYPE!FWA$M_EXP_VER!-
		 FWA$M_EXP_DIR!FWA$M_EXP_DEV!-
		 FWA$M_DIR!FWA$M_DEVICE,(R10)	; test for all other spec parts
	BEQL	70$				; Branch if a legal spec
	RMSERR	QUO
	RSB					; Return with an error.

;
; Upcase quoted string in place -- can't use UPCASE_COMPRESS because:
; we don't want to compress the string
;

44$:	MOVQ	FWA$Q_NAME(R10),R0		; set up descriptors in R0,R1
	BRB	46$				; enter loop in progress

45$:	MOVZBL	(R1),R2				; get char
	MOVB	G^EXE$UPCASE_DAT[R2],-
		(R1)+				; Upcase it
46$:	SOBGEQ	R0,45$				; count down characters

50$:	MOVAQ	FWA$Q_NAME(R10),R6		; get name descriptor
	ADDL3	(R6)+,(R6)+,R3			; get address past name

	ASSUME	FWA$Q_TYPE	EQ	<FWA$Q_NAME+8>
	ASSUME	FWA$Q_VERSION	EQ	<FWA$Q_TYPE+8>
;	ASSUME	FWA$T_TYPEBUF	EQ	<FWA$T_NAMEBUF+FWA$S_NAMEBUF>
;	ASSUME	FWA$T_VERBUF	EQ	<FWA$T_TYPEBUF+FWA$S_TYPEBUF>

	MOVB	#^A/./,(R3)+			; append '.' to delimit type
	BSBB	MOVNXT				; append type
	BBC	#FAB$V_OFP+FOP,(R8),60$		; branch if not output file parse
	BBC	#FWA$V_WC_VER,(R10),60$		; branch if not wildcard version
	DECW	FWA$Q_VERSION(R10)		; get rid of '*' version
60$:	MOVB	#^A/;/,(R3)+			; append ';'
	BSBB	MOVNXT				; and version
	SUBL3	FWA$Q_NAME+4(R10),R3,-		; adjust length
		FWA$Q_NAME(R10)

;
; Modify node descriptors to include leading underscore where
; Appropriate. Note that this code is skipped for process permanent files.
;

70$:;;;	bbc	#fwa$v_node,(r10),80$		; branch if node name not seen
;;;	incw	fwa$q_node(r10)			; modify node descriptor to
;;;	decl	fwa$q_node+4(r10)		;  include leading underscore
;;;	incw	fwa$q_node1(r10)		; modify node1 descriptor
;;;	decl	fwa$q_node1+4(r10)
;;;80$:	bbc	#fwa$v_dev_under,-		; branch if device name was not
;;;		(r10),90$			;  prefixed by an underscore
;;;	incw	fwa$q_device(r10)		; modify device descriptor to
;;;	decl	fwa$q_device+4(r10)		;  include leading underscore

;
; If user has specified a NAM block and an expanded string buffer within it,
; give him the expanded name.
;

90$:	RMSSUC					; declare success so far
	MOVL	FAB$L_NAM(R8),R7		; is there a NAM block
	BNEQ	SETNAM				; branch if yes
	RSB					; exit success if not

;+
;
; Subroutine to append file type and version to the file name.
;
; Inputs:
;
;	R3	Destination address
;	R6	Descriptor of field to append
;
; Outputs:
;
;	R0-R5	Destroyed
;	R3	Address past last byte moved
;	R6	= R6 + 8 (The descriptor referenced by R6 is updated to point
;			 point to the moved string.)
;
;-

MOVNXT:	MOVL	(R6)+,R0		; get length
	MOVL	(R6),R1			; get address of string
	MOVL	R3,(R6)+		; save destination address in desc
	MOVC3	R0,(R1),(R3)		; move field
	RSB

	.SBTTL	SETNAM, Fill in NAM block fields
;
; Fill in the expanded filename string and FNB status bits.
;

SETNAM:	BSBW	CHKNAMBLK		; check access to name block
	BBC	#FAB$V_NAM+FOP,(R8),15$	; branch if not doing open by NAM block
	TSTL	NAM$W_DID(R7)		; was directory ID an input?
	BNEQ	XITNAM			; branch if yes (don't output anything)
	TSTL	NAM$W_FID(R7)		; do we have a file ID?
	BNEQ	XITNAM			; branch if yes
	BBS	#NAM$V_NODE,-		; branch if network access
		NAM$L_FNB(R7),XITNAM

;
; Return expanded name string to user's buffer.
;

15$:	MOVAB	B^EXPARGL,AP		; Address of RM$EXPSTRING argument list
	JSB	RM$EXPSTRING		; Return expanded name string
	BLBC	R0,XITNAM		; Quit on error

;
; Fill in the filename status bits.
;

20$:	CLRL	NAM$L_FNB(R7)		; Clear the FNB
	INSV	FWA$B_WILDFLGS(R10),-	; Set low 9 bits
		#0,#9,NAM$L_FNB(R7)	;
	TSTB	FWA$B_ESCFLG(R10)	; PPF flag set?
	BEQL	30$			; Branch if not
	SSB	#NAM$V_PPF,NAM$L_FNB(R7); Yes, set flag
30$:	EXTZV	#FWA$V_NODE,#7,(R10),R1	; Get next 7 bits
	INSV	R1,#NAM$V_NODE,#7,-	;  and set them
		NAM$L_FNB(R7)		;

	ASSUME	NAM$V_WILD_UFD	EQ	24

	MOVB	FWA$B_DIRWCFLGS(R10),-	; Set directory wildcard flags
		NAM$L_FNB+3(R7)		;
	BBC	#FWA$V_SLPRESENT,(R10),40$	; search list present?
	SSB	#NAM$V_SEARCH_LIST,NAM$L_FNB(R7); flag it in name block 
40$:	BBC	#FWA$V_CONCEAL_DEV,(R10),50$	; concealed device present?
	SSB	#NAM$V_CNCL_DEV,NAM$L_FNB(R7)	;  flag it in name block
50$:	BBC	#FWA$V_ROOT_DIR,(R10),XITNAM	; root directory present?
	SSB	#NAM$V_ROOT_DIR,NAM$L_FNB(R7)	;  flag it in name block

XITNAM:	RSB				; Return to caller of RM$XPFN

EXPARGL:				;
	.BYTE	NAM$L_ESA		; Argument list for RM$EXPSTRING
	RMSERR_WORD	ESA		;
	RMSERR_WORD	ESS		;


	.SBTTL	UPDATE_SLB, Search List Update Routine

;++
;
; UPDATE_SLB -
;
;	This routine updates the last search list block (SLB) in the
;	specified SLB list.  If there are no SLBs return failure.
;	If the last SLB cannot be updated it removes the SLB and tries
;	to update a previous SLB until all SLB are exausted.
;
; Input:
;
;	R6 - pointer to the SLBH list to update
;
; Output:
;
;	z-bit : clear - update success
;		set   - update failed
;
;--

UPDATE_SLB:
	MOVL	SLBH$L_SLB_QUE(R6),R4		; get first SLB
	BEQL	30$				; there is none (z-bit set)
	MOVL	SLB$L_BLINK(R4),R4		; get last SLB in list
	CMPL	SLB$L_INDEX(R4),-		; have we gone past last
		SLB$L_MAX_INDEX(R4)		;  name in the search list
	BLSS	20$				; no

;
; The SLB we updated is no longer usefull, need to delete it and try to
; update the previous one
;

	REMQUE	(R4),R4				; remove this SLB
	BVC	10$				; was que empty
	CLRL	SLBH$L_SLB_QUE(R6)		; yes, clear the list pointer
10$:	PUSHL	R11				; save FSCB
	MOVL	FWA$L_IMPURE_AREA(R10),R11	; restore impure address
	JSB	RM$RETBLK1			; deallocate the space
	POPL	R11				; restore FSCB
	BRB	UPDATE_SLB			; try again

20$:	CLRL	SLB$L_ATTR(R4)			; clear attributes for next element
	INCL	SLB$L_INDEX(R4)			; update index for next element
						;  (z-bit clear)
30$:	RSB					; return


	.SBTTL	EXPAND_NAME, Apply File Name Strings

;++
;
; EXPAND_NAME - controls the parsing of the primary, default, and related
;	filename strings and the application of the various defaults.
;
;	It performs these functions by selecting the next string for parsing,
;	verifying its readability, and calling PARSE_STRING to include it.
;
;	Same inputs as for RM$XPFN.
;
;	Same outputs except that the expanded name string is not built up from
;	the parts.
;
;--

EXPAND_NAME:
	BBC	#FWA$V_SL_PASS,(R10),10$	; branch if this is not
						;  a search list pass

;
; If this is a search list operation then try to update the search list
; blocks in the following order: FN, DN, RNi and SD.  If no update succedes
; then return error - 'no more strings'
;

	ASSUME	SLBH$L_FLINK	EQ	0

	MOVAL	FWA$L_SLBH_FLINK(R10),R7; start of que addr for end test
	MOVL	(R7),R6			; start at file name list head
1$:	CMPL	R6,R7			; back to beginning?
	BEQL	2$			; no search lists left
	BSBB	UPDATE_SLB		; update or delete this list
	BNEQ	5$			; if done, procede
	MOVL	(R6),R6			; advance to next
	BRB	1$

2$:	CLRL	R0			; return error 'no more list'
	RSB				; exit

5$:	BRW	PARSE_SPECS		; continue by parsing the strings

	ASSUME	FWA$L_SLBH_PTR+4 EQ FWA$L_SLB_PTR

10$:	CLRQ	FWA$L_SLBH_PTR(R10)	; clear the 'current' SLB[H] ptrs

;
; Check for open by name block
;

	MOVL	FAB$L_NAM(R8),R7	; get NAM block address
	BEQL	40$			; don't have one, need to parse normally
	BSBB	CHKNAMBLK		; check out the name block
	BBC	#NAM$V_SYNCHK,-		; remember the syntax-only check flag
		NAM$B_NOP(R7),20$	; for more convenient questioning
	SSB	#FWA$V_SYNTAX_CHK,(R10) ; set corresponding FWA bit

;
; It's a open by name block and there is a name block, so check for non-zero
; device ID in the name block and if found use it to provide a device name.
;

20$:	BBC	#FAB$V_NAM+FOP,(R8),30$	; branch if not open by name block
	MOVAB	NAM$T_DVI(R7),R5	; get device ID string address
	MOVZBL	(R5)+,R6		; get string length
	BEQL	50$			; branch if zero
	CMPL	R6,#15			; device ID > 15 chars?
	BGTRU	ERRDVI			; branch if so
	MOVL	FWA$L_BUF_PTR(R10),R7	; get address of scratch buffer for DVI
	MOVC3	R6,(R5),(R7)		; move the string
	MOVB	#^A/:/,(R3)		; append colon to device name
	INCL	R6			;  and count it
	BSBW	PARSE_STRING		; parse device name string
	BISB2	#FWA$M_NAM_DVI,(R10)	; flag device came from NAM block
	MOVL	FAB$L_NAM(R8),R7	; get NAM block address again
	BSBB	CHKNAMBLK		; check out the name block
	TSTL	NAM$W_FID(R7)		; is file ID non-zero?
	BEQL	40$			; continue parse if not
	BBC	#IFB$V_CREATE,(R9),60$	; all done unless create
30$:	CLRL	NAM$W_FID(R7)		; zero the file ID for create
	CLRB	NAM$B_ESL(R7)		; zero returned strings
	CLRB	NAM$B_RSL(R7)		; 
	CLRL	NAM$L_FNB(R7)		; and status bits in case of error
40$:	BRW	STUFF_NAME		; continue parse

;
; Don't allow DID or FID to be used since DVI is bad.
;

50$:	CLRL	NAM$W_DID(R7)		; zero the directory ID
	BBC	#NAM$V_NODE,-		; branch if not network access
		NAM$L_FNB(R7),30$
	CLRL	NAM$W_FID(R7)		; zero the file ID

;
; Open by Name Block is not supported over the network, but it can be simulated
; by using the resultant name string returned from a previous $SEARCH, $OPEN,
; etc. This facilitates network wildcard support as many utilities open by
; Name Block after finding the next file via a $SEARCH operation.
;

	MOVZBL	NAM$B_RSL(R7),R6	; get resultant string length
	BEQL	30$			;  and branch if zero (i.e., ignore)
	MOVL	NAM$L_RSA(R7),R7	; get resultant string address
	BEQL	30$			;  and branch if zero (i.e., ignore)
	PROBER	IFB$B_MODE(R9),R6,(R7)	; probe readability
	BEQL	ERRRST			; branch if inaccessible
	MOVL	FWA$L_BUF_PTR(R10),R5	; get address of scratch buffer
	BSBW	UPCASE_COMPRESS		; perform upcasing and string
					;  compression while copying string
	BSBW	PARSE_STRING		; parse the string
60$:	BRW	ENDPRS			; all done even if all file name
					;  parts are not present

;
; Check the nam block, if there is an error pop the pc and return
;

CHKNAMBLK:
	JSB	RM$CHKNAM			; check the name block
	BLBS	R0,10$				; was there an error
	POPL	R1				; yes pop return pc
10$:	RSB					; exit

;
; Handle errors
;

ERRDVI:	RMSERR	DVI			; Invalid device ID field
	RSB

ERRRST:	RMSERR	RST			; Can't access resultant name
	RSB

ERRFNA:	RMSERR	FNA			; Can't access filename string
	RSB

ERRDNA:	RMSERR	DNA			; Can't access default filename string
	RSB

; subroutine to get space for storing filename input strings,
; upcase/compress the string into the buffer and return updated size.
;
; inputs:
;	R6 - input size
;	R7 - input addr
; outputs:
;	R0 - status
;	R1 - ptr to space
;	R6 - output size
;	R7 - output addr
;
;	R2, R3, R4, R5 - scratch
;

GETSPC:	
	ADDL3	#SLBH$C_BLN,R6,R2		; get space to store it
	PUSHL	R11				; save FSCB
	MOVL	FWA$L_IMPURE_AREA(R10),R11	; restore impure address
	JSB	RM$GETSPC1			;
	POPL	R11				; restore FSCB
	BLBC	R0,10$
	MOVB	#SLBH$C_BID,SLBH$B_BID(R1)	; identify structure
	MOVB	R6,SLBH$B_BLN(R1)		; size of string allocation
	MOVAL	SLBH$T_STRING(R1),R5		; buffer data ptr
	BSBW	UPCASE_COMPRESS			; copy the name
	MOVB	R6,SLBH$B_STR_LEN(R1)		; stuff the size of string
	INSQUE	(R1),@FWA$L_SLBH_BLINK(R10)	; insert at tail of list
	RMSSUC
10$:	RSB

	.SBTTL	STUFF_NAME, Allocate and set up SLBHs
;
; Stuff the fwa buffers with the file name, default name and related name
; strings from the FAB and related name blocks if any
;

STUFF_NAME:

;
; Get the FNA string
;

	MOVZBL	FAB$B_FNS(R8),R6		; get size of input string
	BEQL	10$				; skip if zero
	MOVL	FAB$L_FNA(R8),R7		; get input addr
	BEQL	10$				; skip if zero
	PROBER	IFB$B_MODE(R9),R6,(R7)		; prober buffer
	BEQL	ERRFNA				; bad
	BSBB	GETSPC				; get space
	BLBC	R0,60$				; if room
	MOVB	#FWA$M_FNA_PASS,SLBH$B_PASSFLGS(R1) ; FWA$B_PASSFLGS value

;
; Get the DNA string
;

10$:	MOVZBL	FAB$B_DNS(R8),R6		; get size of input string
	BEQL	20$				; skip if zero
	MOVL	FAB$L_DNA(R8),R7		; get input addr
	BEQL	20$				; skip if zero
	PROBER	IFB$B_MODE(R9),R6,(R7)		; prober buffer
	BEQL	ERRDNA				; bad
	BSBB	GETSPC				; get space
	BLBC	R0,60$				; if room
	MOVB	#FWA$M_DUPOK,SLBH$B_PASSFLGS(R1) ; FWA$B_PASSFLGS value

;
; Get the RLF strings
;

20$:	MOVL	FAB$L_NAM(R8),R7		; get name block
	BEQL	110$				; skip if none
	BSBW	CHKNAMBLK			; check it (no return on error)
	MOVZWL	#32767,-(SP)			; RLF counter
30$:	MOVL	NAM$L_RLF(R7),R7		; get related nam block
	BEQL	100$				; none
	JSB	RM$CHKNAM			; check it
	BLBC	R0,40$				; bad
	MOVZBL	NAM$B_RSL(R7),R6		; get size of input string
	BEQL	100$				; skip if zero
	MOVL	NAM$L_RSA(R7),R5		; get input addr
	BEQL	100$				; skip if zero
	PROBER	IFB$B_MODE(R9),R6,(R5)		; prober buffer
	BEQL	40$				; bad
	PUSHL	R7				; save NAM blk addr
	MOVL	R5,R7				; put string in right reg
	BSBW	GETSPC				; get space
	POPL	R7				; retrieve NAM blk addr
	BLBC	R0,50$				; if room
	MOVB	#<FWA$M_DUPOK!FWA$M_RLF_PASS>,-
		SLBH$B_PASSFLGS(R1)		; FWA$B_PASSFLGS value
	MOVL	NAM$L_FNB(R7),SLBH$L_NAM_FNB(R1); save FNB bits
	SOBGTR	(SP),30$			; get next RLF

40$:	RMSERR	RLF			; Can't access related file name
50$:	POPL	R1			; Discard RLF counter
60$:	RSB

;
; Setup the $SET DEFAULT string
;

70$:	.ASCII	/SYS$DISK:/		; Default device string
SYSDISKLEN = .-70$

100$:	POPL	R1			; Discard RLF counter
110$:	MOVAB	B^70$,R7		; addr of string
	MOVZBL	#SYSDISKLEN,R6		; size of string
	BSBW	GETSPC			; set up SLBH for it
	BLBC	R0,60$			; quit on error
	MOVB	#FWA$M_DUPOK,SLBH$B_PASSFLGS(R1) ; FWA$B_PASSFLGS value

	.SBTTL	PARSE_SPECS, Parse the filename specs
;
; Process the filename specifications in the order:
;	FNA,  DNA,  RLFi, SETDEFAULT
;

PARSE_SPECS:

	ASSUME	SLBH$L_FLINK	EQ	0
	ASSUME	FWA$L_SLBH_FLINK+4 EQ FWA$L_SLBH_BLINK
	ASSUME	FWA$L_SLBH_FLINK-4 EQ FWA$L_SLB_PTR
	ASSUME	FWA$L_SLBH_FLINK-8 EQ FWA$L_SLBH_PTR

SLBH_PTR=-8					; offset from R1 to slbh_ptr
SLB_PTR=-4					; offset from R1 to slb_ptr
SLBH_FLINK=0					; offset from R1 to flink
SLBH_BLINK=4					; offset from R1 to blink

	MOVL	FWA$L_SLBH_FLINK(R10),-
		FWA$L_SLBH_PTR(R10) 		; init the 'current' SLBH

PRS_LOOP:
	MOVAL	FWA$L_SLBH_FLINK(R10),R1	; get que header addr
	MOVL	SLBH_PTR(R1),R0			; get next entry
	CMPL	R0,R1				; back to header?
	BEQL	CHKDIR				; done all list elements
	MOVZBL	SLBH$B_STR_LEN(R0),R6		; length of string
	MOVAL	SLBH$T_STRING(R0),R7		; addr of string
	BICB2	#FWA$C_ALLPASS,-
		FWA$B_PASSFLGS(R10)		; clear per pass flags
	BISB2	SLBH$B_PASSFLGS(R0),-
		FWA$B_PASSFLGS(R10)		; set current per pass flags
	MOVL	SLBH$L_SLB_QUE(R0),SLB_PTR(R1)	; set 'current' SLB

;
; Apply system defaults unless node name was specified.
; Check is based on the fact that the SET DEFAULT string is ALWAYS
; the last entry in the SLBH queue.
;
	CMPL	R0,SLBH_BLINK(R1)		; is this the set default SLBH?
	BNEQ	5$				; nope, continue
	BBS	#FWA$V_NODE,(R10),ENDPRS	; all set if node present
	BBS	#FWA$V_DEVICE,(R10),CHKDIR	; branch if device present

;
; If this is the related filename specification,
; first check to see if the parse of the related file could supply
; any of the missing filename elements, and if not, avoid this step.
;

5$:	BBC	#FWA$V_RLF_PASS,(R10),30$	; branch if not rlf pass
	BBC	#FAB$V_OFP+FOP,(R8),10$		; branch if input file parse

	ASSUME	FWA$V_NAME	EQ	FWA$V_TYPE+1

	CMPZV	#FWA$V_TYPE,#2,(R10),#3		; either name or type missing?
	BNEQ	15$				; branch if yes (RLF can provide)
	BITB	#WCNTV_MASK,FWA$B_WILDFLGS(R10)	; wild name, type or ver?
	BNEQ	15$				; branch if yes (RLF can provide)
	BBS	#FWA$V_WILD_DIR,(R10),15$	; any wild directories ?
	BRB	40$				; don't both with RLF pass - no
						;  additional fields can be filled in
;
; This is an input file parse.
;

10$:	BBC	#FWA$V_NODE,(R10),15$		; branch if node name missing

	ASSUME	FWA$V_NAME	EQ	FWA$V_TYPE+1
	ASSUME	FWA$V_DIR	EQ	FWA$V_NAME+1
	ASSUME	FWA$V_DEVICE	EQ	FWA$V_DIR+1

	CMPZV	#FWA$V_TYPE,#4,(R10),#15	; dev, dir, name or type missing?
	BEQL	40$				; branch if not (RLF can't help)

;
; At last we have a related file name string; parse it; but, before we
; do the related-file parse, make sure if the parse is of an output-file,
; that the filename and file type, if they are wild, are in the legal
; format (i.e. * and * only).
;

15$:	BBC	#FAB$V_OFP+FOP,(R8),30$		; skip checks if input-file
	BBC	#FWA$V_WC_NAME,(R10),20$	; skip check if not wild
	MOVZWL	#FWA$Q_NAME,R4			; load offset to name descriptor
	BSBW	CHECK_WLD_FIELD			; if filename is of a legal wild
	BNEQ	WLDFNM				;  format, continue

20$:	BBC	#FWA$V_WC_TYPE,(R10),30$	; skip check if type not wild
	MOVZWL	#FWA$Q_TYPE,R4			; load offset to file type desc
	BSBW	CHECK_WLD_FIELD			; if file type is of a legal
	BNEQ	WLDTYP				;  wild format continue

30$:	MOVC5	#0,(SP),#0,#SLB$C_BLN,FWA$T_SLB(R10) ; clear fake SLB
	BSBW	PARSE_STRING			; parse the string

;
; Since PARSE_STRING returned, the filename is not fully qualified.
; Therefore, defaults must be applied.
;

40$:	MOVL	@FWA$L_SLBH_PTR(R10),FWA$L_SLBH_PTR(R10) ; advance to next
	BRW	PRS_LOOP			; and loop

;
; The filename string still is not fully qualified.
; Our last hope is to apply the default directory.
;
; Note:	It is not necessary to upcase and compress the default directory string
;	because RMS$SETDD calls RM$XPFN to parse a new string prior to storing
;	it in PIO$GT_DDSTRING, thereby assuring that the default directory
;	string has been upcased and compressed.
;

CHKDIR:	BBS	#FWA$V_DIR,(R10),ENDPRS		; branch if directory present
	BISL2	#FWA$M_DUPOK,(R10)		; allow duplicates
	MOVAB	@#PIO$GT_DDSTRING,R7		; get address and size of default
	MOVZBL	(R7)+,R6			;  directory string
	BSBB	PARSE_STRING			; parse default directory string

;
; End of parse - not necessarily all elements present,
; but at least problem free
;

ENDPRS:	RMSSUC					; exit with success
	RSB

;
; No partial wildcards allowed.
;

WLDFNM:	RMSERR	FNM				; return the filename error
	RSB					;

WLDTYP:	RMSERR	TYP				; return the filetype error
	RSB


	.SBTTL	PARSE_STRING, Parse Individual Filename String

;++
;
; PARSE_STRING - is the intermediate level filename string parser.
;
;	It accepts the particular string to be parsed as input from
;	EXPAND_NAME and breaks it up into its constituent filename
;	elements and either saves these (by moving them to the
;	appropriate element buffer) or discards them if they are
;	permissable duplicates.
;
;	If a node spec is seen, an immediate attempt is made to translate the
;	nodename portion of the string. If this succeeds and the equivalence
;	string consists of one or more concatenated node specs, then the
;	left-most node spec is isolated and the process is repeated until
;	logical node name translation fails. Then, the primary node spec is
;	moved to the node name element buffer and all secondary node specs are
;	are appended to it. Also, there are rules for defaulting access control
;	information with respect to the recursive logical node name translation
;	procedure.
;
;	If a logical/device name is seen, it is handled as follows:
;	Initially it is not moved; instead a descriptor is set-up to point
;	to it. After parsing all remaining elements of the string, an attempt
;	is made to translate the logical/device name as a logical name. If
;	this succeeds, the equivalence string is then in turn parsed and its
;	elements merged in or discarded as for the original string. If the
;	translation fails, the equivalence string (which is identical to the
;	logical/device name string minus a leading underscore, if any) is taken
;	as a physical device name and processed accordingly.
;
;	A logical/filename is treated similarly, with the following differences:
;	It is the only string element hence there is no need to continue
;	parsing the remainder of the input string. Moreover, if the translation
;	does not succeed the equivalence string is treated as a filename.
;
;	The general flow of control of this routine is as follows:
;
;
;		  XPFN
;		    |       ^		^
;		    |	    |error	|
;		    |	    |success	|
;		EXPAND_NAME--		|
;		    |	    ^		|
;		    |	    |		|error
;		    |	    |success	|parse done
;		PARSE_STRING-------------
;		    |	    ^		^	  NOTE: Some work routines called
;		    |	    |error	|		by parse_string pop the
;		    |	    |success	|		stack so they can operate
;		work_routine-		|		at the level of parse_string
;		    |	    ^		|
;		    |	    |		|
;		    |	    |success	|error
;		CHECK_FIELD--------------
;
; Calling Sequence:
;
;	BSBW	PARSE_STRING
;
; Input Parameters:
;
;	R6	Filename string length
;	R7	Filename string address
;	R10	FWA address
;	R11	FSCB address (there are two)
;
; Implicit Inputs:
;
;	The current contents of the FWA.
;	The contents of the filename string input.
;	The contents of the logical name tables
;
; Outputs:
;
;	R0-R7	Destroyed
;	AP	Destroyed
;
; Implicit Outputs:
;
;	The FWA is updated as per the filename element seen
;
; Completion Codes:
;
;	PARSE_STRING returns to the caller only if there were no errors
;	encountered and there remain one or more missing filename elements
;	(node excluded). If either or these occur the return PC is popped
;	from the stack and, if an error, an RSB is performed with the status
;	code in R0 (standard RMS), else a branch to ENDPRS is taken.
;
; Side Effects:
;
;	None
;
;--

PARSE_STRING:
	PUSHL	R6				; save lehgth
	BSBW	RM$SCAN_STRING			; scan string for elements
	POPL	R6				; restore length
	CMPW	R6,FSCB$Q_FILESPEC(R11)		; the lengths must match
	BEQL	30$				; they do	
	RMSERR	SYN				; syntax error
20$:	BRW	PRS_ERROR			; exit with error

	ASSUME	FSCB$B_FLDFLAGS	EQ	0

30$:	CMPB	#FSCB$M_NAME,(R11)		; do we have only a name
	BNEQ	40$
	MOVQ	FSCB$Q_NAME(R11),R6		; get the descriptor
	BRW	FILE_OR_LOGNAME			; could be name or logname

40$:	BBC	#FSCB$V_NODE,(R11),50$		; is there a node spec
	MOVQ	FSCB$Q_NODE1(R11),R6
	BSBW	CHECK_NODE
	BLBS	R0,50$
	RMSERR	NOD
	BRB	20$
	
50$:	BBC	#FSCB$V_DEVICE,(R11),60$	; is there a device name
	MOVQ	FSCB$Q_DEVICE(R11),R6
	DECW	R6				; remove trailing ':'
	BSBW	CHECK_DEVICE
	BLBS	R0,60$
	RMSERR	DEV
	BRB	20$

60$:	BBC	#FSCB$V_DIRECTORY,(R11),65$	; is there a directory spec
	MOVQ	FSCB$Q_DIRECTORY(R11),R6
	BSBW	PARSE_DIR			; go parse directory spec
	BLBS	R0,65$
	RMSERR	DIR
	BRB	20$

65$:	BBC	#FSCB$V_ROOT,(R11),70$		; is there a root directory spec
	SSB	#FWA$V_EXP_ROOT,(R10)		; flag that it was explicit
	BSBW	CHECK_ROOT			; go parse root directory spec
	BLBS	R0,70$
	RMSERR	DIR
	BRB	99$

70$:	BBC	#FSCB$V_NAME,(R11),80$		; is there a file name
	MOVQ	FSCB$Q_NAME(R11),R6
	BSBW	CHECK_NAME
	BLBS	R0,80$
	RMSERR	FNM
	BRB	99$

80$:	BBC	#FSCB$V_TYPE,(R11),90$		; is there a file type
	MOVQ	FSCB$Q_TYPE(R11),R6
	BSBB	CHECK_TYPE
	BLBS	R0,90$
	RMSERR	TYP
	BRB	99$

90$:	BBC	#FSCB$V_VERSION,(R11),100$	; is there a version number
	MOVQ	FSCB$Q_VERSION(R11),R6
	BSBB	CHECK_VERSION
	BLBS	R0,100$
	RMSERR	VER
99$:	BRW	PRS_ERROR			; an error

100$:	BRW	FINISH_PARSE			; go finish up

;
; File type
;

CHECK_TYPE:
	BBC	#FWA$V_FNA_PASS,(R10),10$; branch if not FNA pass
	SSB	#FWA$V_EXP_TYPE,(R10)	; set explicit version flag
10$:	DECW	R6			; remove the leading terminator
	INCL	R7			;
	MOVZBL	#FWA$V_TYPE,R0		; flag field
	MOVZBL	#FWA$C_MAXTYPE+1,R1	; check the length
	MOVAQ	FWA$Q_TYPE(R10),R5	; get output descriptor
	BSBW	CHECK_FIELD		; process field
	RMSSUC
	RSB

;
; File version
;

CHECK_VERSION:
	BBC	#FWA$V_FNA_PASS,(R10),10$; branch if not FNA pass
	SSB	#FWA$V_EXP_VER,(R10)	; set explicit version flag
10$:	DECW	R6			; remove the leading terminator
	INCL	R7			;
	MOVZBL	#FWA$V_VERSION,R0	; flag field
	MOVZBL	#FWA$C_MAXVER+1,R1	; length
	MOVAQ	FWA$Q_VERSION(R10),R5	; get output descriptor
	BSBW	CHECK_FIELD		; process field
	RMSSUC
	RSB

;;;
;;; We have both a logical name and a device;
;;; ignore the logical name unless no duplicates allowed.
;;;
;;;
;;;devdup:	bbs	#fwa$v_dupok,(r10),prs_exit
;;;	rmserr	dev

;
; The filename string has been parsed into its basic parts.
; Check to see if we got a logical name, and if so go attempt
; to translate it.
;

FINISH_PARSE:
	BBCC	#FWA$V_LOGNAME,(R10),PRS_EXIT	; Branch if no logical name
	MOVQ	FWA$Q_LOGNAM(R10),R6		; Get descriptor of name
	BBS	#FWA$V_NODE,(R10),15$		; Branch if node spec -
						; don't translate device names
;
; In order for searchlists to be completely evaluated, it is necessary
; that they be translated, even if a device-name is already present.
; Only if they don't translate and try to actually get used as a device
; name are they actually not-used.   The CHECK_FIELD subroutine
; properly knows how to handle this, in particular, allowing the translation
; of the FNA string to yield a duplicate device if the NAM_DVI device
; was used.
;
;;; This is a change from pre-V4 where logical devices names were ignored
;;; if a device name already existed.  This is viewed as a "bug" in the
;;; original implementation but it's consequences aren't yet fully understood.
;;; If all goes well with making this change, then these 2 lines may be deleted.
;;; Other wise they must be restored and the 2nd "10$" replaced by "DEVDUP".
;;; See also the code at DEVDUP and FILE_OR_LOGNAME.
;;; 
;;;
;;;	bbs	#fwa$v_nam_dvi,(r10),10$	; Branch if device came from NAM block
;;;						;  (i.e., do the translation)
;;;	bbs	#fwa$v_device,(r10),10$		; Branch if device already seen

;
; Go attempt to translate the name.
; If no translation return here and treat as device name.
;

10$:	BSBW	TRANSLATE

;
; It appears as if it was a device name after all.  Allow the name even if
; not in standard device name format - if truly invalid it will be caught when
; attempting to assign the channel.  This allows flexibility for different
; device/controller/unit naming schemes as well as remote node logical names.
;

;
; In order to call check_field (which would return one level up to EXPAND_NAME
; on an error) we must make this code run at work routine level.  This can only
; return on and error from check_field
;

15$:	BSBB	20$
	RMSERR	DEV
	BRW	PRS_ERROR

20$:	MOVZBL	#FWA$V_DEVICE,R0		; flag which field
	MOVZBL	#FWA$S_DEVICEBUF,R1		; length
	MOVAQ	FWA$Q_DEVICE(R10),R5		; output descriptor
	BSBW	CHECK_FIELD
;;;	blbc	r0,30$				; only if we used this spec.
;;;	cmpb	@fwa$q_lognam+4(r10),#^a/_/	; is 1st char an underscore?
;;;	bneq	30$				; branch if not
;;;	ssb	#fwa$v_dev_under,(r10)		; flag leading underscore
30$:	POPL	R0				; pop return pc and exit

;
; PRS_EXIT ...
;
; The parse of this string is complete.
;
; If this was the parse of the primary name string (FNA), handle explicit
; flags. In particular, use the explicit type and version flags to
; set the type and version seen flags (i.e., explicit null type and
; version cause no defaults to be taken for these fields).  Also,
; copy the current device and directory seen flags to the explicit
; device and directory.
;

PRS_EXIT:
	BBC	#FWA$V_FNA_PASS,(R10),20$	; branch if not FNA pass

	ASSUME	FWA$V_EXP_VER	EQ	<FWA$B_WILDFLGS*8>
	ASSUME	FWA$V_EXP_TYPE	EQ	FWA$V_EXP_VER+1
	ASSUME	FWA$V_TYPE	EQ	FWA$V_VERSION+1

;
; If EXP_TYPE is not set but TYPE is set, then its ok, don't unconditionally
; overwrite TYPE.
;

	INSV	FWA$B_WILDFLGS(R10),-		; set version from
		#FWA$V_VERSION,#1,(R10)		;  'explicit' flag
	BBC	#FWA$V_EXP_TYPE,(R10),10$	; if EXP_TYPE not set,
						;  then ignore TYPE
	INSV	FWA$B_WILDFLGS(R10),-		; set version and type from
		#FWA$V_VERSION,#2,(R10)		;  'explicit' flags

	ASSUME	FWA$V_EXP_DIR	EQ	FWA$V_EXP_DEV-1
	ASSUME	FWA$V_DIR	EQ	FWA$V_DEVICE-1

10$:	EXTZV	#FWA$V_DIR,#2,(R10),R0		; get dev and dir
	INSV	R0,#FWA$V_EXP_DIR,#2,(R10)	; and set explicit dev & dir
	BBC	#FWA$V_NODE,(R10),30$		; if not network parse,
	SSB	#FWA$V_EXP_NODE,(R10)		; mark explicit node

;
; If we have a node name and quoted string, then stop the parse in its tracks
; and don't go looking for trouble
;

20$:	BBC	#FWA$V_NODE,(R10),30$		; if not network parse,
						;  then skip it
	BBS	#FWA$V_QUOTED,(R10),PRS_EXIT1	; if quoted then stop parsing

;
; Check for a fully qualified file name string.
; If any fields are missing, return to caller to apply defaults.
;

30$:	CMPB	FWA$B_FLDFLGS(R10),#FWA$C_ALL	; all of dev,dir,nam,typ,ver
	BNEQ	PRS_EXIT2			; branch if not
	BBC	#FAB$V_OFP+FOP,(R8),PRS_EXIT1	; branch if input file parse
	BITB	#WCNTV_MASK,FWA$B_WILDFLGS(R10)	; wild name, type, or ver?
	BNEQ	PRS_EXIT2			; if yes, go apply defaults
	BBS	#FWA$V_WILD_DIR,(R10),-		; if any wild directories
		PRS_EXIT2			;  go apply defaults

;
; return to stop parsing
;

PRS_EXIT1:
	POPR	#^M<R0>				; pop return PC

;
; return to apply defaults
;

PRS_EXIT2:
	RMSSUC					; exit from parse successfully
	RSB

;
; An error condition has been encountered.
; Error code is in R0 - pop the extra PC from the stack and return
;

PRS_ERROR:
	POPL	R1
	RSB


;
; We have a single field with no punctuation; it is either a
; logical name or a file name. In order for it to be a logical name
; the following must be true:
;
;	1.  there must be no other filename elements.
;	2.  it must translate.
;
; Previous to V4, as described at FINISH_PARSE, once a device name was
; seen then all device/logical names were ignored and a file/logical name
; was forced to be treated as a filename.   With the advent of search lists,
; this is no longer true, and a file/logical name is ALWAYS attempted to
; be translated.  The commented-out code may be removed at the same time
; as the FINISH_PARSE code.
;

FILE_OR_LOGNAME:
;;;	tstb	fwa$b_fldflgs(r10)	; any flags set?
;;;	beql	10$
;;;
;;;	ASSUME	FWA$V_DEVICE	GE	8
;;;
;;;	cmpb	fwa$b_fldflgs(r10),-	; only device seen
;;;		#<fwa$m_device@-8>
;;;	bneq	30$
;;;	bbc	#fwa$v_nam_dvi,(r10),30$; branch, testing this as a filename
;;;					;  unless device came from NAM block
10$:	BBS	#FWA$V_NODE,(R10),30$	; branch if node seen
	MOVQ	FSCB$Q_NAME(R11),-	; store the name to translate
		FWA$Q_LOGNAM(R10)

;
; Try to translate the name, if it is a logical name then translate does not
; return but continues parsing the new logical name.  If it is NOT a logical
; name -or- the translation is not to be used then it exits with R0
; indicating which it was.
;

	BSBW	TRANSLATE		; attempt translation, if translate 
					;  returns failure, its a filename
	BLBC	R0,30$			; was this a hidden device
	BSBB	CHECK_DEVICE		; yes, treat as a device name
	BLBS	R0,40$			; was there an error
	RMSERR	DEV			; call it a device error
	BRB	PRS_ERROR		; exit

;
; Say result name is really the filename
;

30$:	BSBW	CHECK_NAME		; process it that way
	BLBS	R0,40$			; was there an error
	RMSERR	FNM			; call it a file name error
	BRB	PRS_ERROR		; exit

40$:	BRW	FINISH_PARSE		; finish up parsing

;
; Process logical/device name
;

CHECK_DEVICE:
	MOVZBL	#FWA$V_LOGNAME,R0	; flag field
	MOVZBL	#LNM$C_NAMLENGTH,R1	; length
	MOVAQ	FWA$Q_LOGNAM(R10),R5	; get output descriptor
	BSBW	CHECK_FIELD		; process field
	RMSSUC
20$:	RSB


	.SBTTL	CHECK_NODE, Check Node Specification
;
; We have a primary node spec...
;
; A file specification string may begin with a list of concatenated
; node spec strings (i.e., node1::node2::node3::dev:[dir]file.typ;ver).
; Further, the first non-null node spec is a candidate for iterative
; logical node name translation, where each equivalence string may yield one
; or more concatenated node spec strings!
;

CHECK_NODE:

;
; Since the first node spec can only be null we can check here
;

	BBC	#FSCB$V_NULL,R6,10$	; branch if not null
	SSB	#FWA$V_EXP_NODE,(R10)	; set flag to disable stickness
	RMSSUC
5$:	RSB				; continue with next field

;
; Allocate space for the Network Work Area (NWA) unless it has already
; been allocated via previous pass thru this code.
;

10$:	TSTL	IFB$L_NWA_PTR(R9)	; if nwa there?
	BNEQ	20$			; branch if yes
	PUSHL	R11			; save FSCB address
	MOVL	FWA$L_IMPURE_AREA(R10),-; restore impure area pointer
		R11
	JSB	NT$NWA_INIT		; allocate and initialize NWA
	POPL	R11			; restore FSCB
	BLBC	R0,5$			; branch for error exit


;
; Logical node name translation...
;
; Attempt to translate the node name string of the (left-most) node spec.
; For the translation to succeed, the equivalence string must represent
; one or more concatenated node specs, i.e., each field must be delimited
; by a double colon.
;
; Note:	If node name is prefixed by underscore, no translation occurs
;	but the underscore is removed.
;
; Note:	If node name contains an access control string with the password masked
;	out, then an attempt is made to translate the string consisting of
;	<node name + access control string> as a special logical node name.
;

	ASSUME	FWA$T_NODEBUF	EQ	<FWA$B_UNDER_NOD+1>

20$:	PUSHL	R9			; save ifb addr
	MOVL	IFB$L_NWA_PTR(R9),R9	; get address of NWA
	CLRL	NWA$Q_ACS(R9)		; zero ACS size/flag
	CLRL	NWA$Q_INODE(R9)		; initialize intermediate node spec desc
	MOVAB	NWA$T_INODEBUF+NWA$C_INODESIZ(R9),-
		NWA$Q_INODE+4(R9)	; strings will be added 
					;  from right to left
TRANSLATE_LOOP:
	BBC	#FSCB$V_PWD,R6,10$	; branch if password is not masked out
	SUBW2	#2,R6			;  of access control string of node spec
	CMPB	#^A/_/,(R7)		; remove leading underscore character
	BNEQ	20$			;  (if present) before attempting
	DECL	R6			;  translation of special logical node
	INCL	R7			;  name string with password masked out
	BRB	20$			; translate

10$:	BSBW	PSEUDO_CHKFLD		; validate node spec syntax
	SUBW2	#2,R6			; remove trailing '::'
	BBC	#FSCB$V_ACS,R6,20$	; branch if there is no embedded access
					;  control string in node spec string
	LOCC	#^A/"/,R6,(R7)		; find start of access control string
					;  on return <R0,R1> => ACS
	SUBW2	R0,R6			; compute size of node name string
	TSTL	NWA$Q_ACS(R9)		; ignore this access control string if
	BNEQ	20$			;  there is a default one in ACS buffer
	MOVL	R0,NWA$Q_ACS(R9)	; store size of ACS
	MOVC3	R0,(R1),@NWA$Q_ACS+4(R9); make this current default ACS string
20$:	MOVQ	R6,NWA$Q_LOGNAME(R9)	; store descriptor of node name string
					;  to translate

	BBS	#LNM$V_TERMINAL,-	; Marked terminal?
		NWA$L_XLTATTR(R9),47$	; Branch if so

	ASSUME	NWA$L_XLTBUFFLG	EQ	NWA$L_XLTCNT+4

	MOVAL	NWA$L_XLTCNT(R9),R1	; Get ptr to xlt count
	AOBLEQ	#LNM$C_MAXDEPTH,-
		(R1)+,40$		; Branch if < 10 translations done
30$:	POPL	R9
	POPL	R1			; Discard CHECK_NODE return pc
	BRW	ERRLNE			; Declare error in logical name

;
; Attempt logical node name translation.
;

40$:	MOVAL	NWA$T_XLTBUF1(R9),R5	; addr of buffer for translation
	MCOML	(R1),(R1)+		; check if this buffer is free
	BNEQ	45$			; branch if ok
	MOVAL	NWA$T_XLTBUF2(R9),R5	; swap buffers
45$:	MOVL	R5,NWA$T_ITM_STRING+4(R9); set address of buffer selected
	PUSHAB	W^TABNAM		; make descriptor of table name
	PUSHL	S^#TABNAM_SIZE
	MOVL	SP,R1			; remember where it is
	$TSTPT	NTXLATLOG		;
	$TRNLNM_S	-		; Translate the name
		LOGNAM=NWA$Q_LOGNAME(R9),-
		TABNAM=(R1),-
		ATTR=W^LNM_ATTR,-
		ITMLST=NWA$T_ITM_LST(R9),-
		ACMODE=FWA$B_XLTMODE(R10)
	ADDL2	#8,SP			; discard table name descriptor
	BLBS	R0,50$			; Was translation successful?
	CMPW	R0,#SS$_NOLOGNAM	; no such translation?
	BNEQ	30$			; quit on odd error
47$:	MOVQ	NWA$Q_LOGNAME(R9),R4	; get back source string descriptor
	BRW	TRANSLATE_FAIL		; proceed with source
	
50$:	TSTL	NWA$L_XLTMAXINDX(R9)	; check for searchlists
	BLSS	47$			; no good ones, assume no tran
	BGTR	ERRNOD			; no searchlists allowed
	BBC	#LNM$V_EXISTS,-		; must be a translation 0
		NWA$L_XLTATTR(R9),ERRNOD
	MOVZWL	NWA$L_XLTSIZ(R9),R4	; Store equivalence string size
					;  NOTE: <R4,R5> => equivalence string

;
; Process the equivalence string.
;

	MOVQ	R4,R6			; Copy descriptor to required registers
	BSBW	UPCASE_COMPRESS		; Perform upcasing and string
					;  compression in place
	MOVAB	FSCB$K_BLN(R11),R11	; use secondary FSCB
	PUSHL	R6			; Save length of input
	BSBW	RM$SCAN_STRING
	POPL	R6			; Retrieve length of input
	CMPW	R6,FSCB$Q_FILESPEC(R11)	; Did we use all of it?
	BNEQ	ERRNOD			; nope, then return error

	ASSUME	FSCB$B_FLDFLAGS	EQ	0

	CMPB	#FSCB$M_NODE,(R11)	; there better be just nodes
	BNEQ	ERRNOD
	
;
; Are thier intermediate node names?
;
	MOVZBL	FSCB$B_NODES(R11),R0	; get number of nodes
	DECL	R0			; remove the first and if not
	BEQL	60$			;  more than one node spec string skip
	BSBB	INTERMED_NODE		; process extra node names
60$:	MOVQ	FSCB$Q_NODE1(R11),R6	; get next node for translation
	MOVAB	-FSCB$K_BLN(R11),R11	; restore primary FSCB
	BRW	TRANSLATE_LOOP		; try another translation

;
; Handle node name errors.
;

ERRNOD1:POPL	R0			; discard return pc
ERRNOD:	RMSERR	NOD			; declare error in node name
	POPL	R9			; restore ifb
	RSB				; exit with completion code in R0

;
; Process 2nd to nth node specs found in the equivalence string.
; Node names in these node specs are not candidates for logical name
; translation. Also, any access control string supplied with the above
; logical name is the default (and overrides any) access control string
; for the last node spec of the equivalence string.
;
; Input:
;
;	R0	- Index of last node spec
;

INTERMED_NODE:

;
; Handle defaulting of access control string and append 2nd to nth node specs
; to an intermediate node spec buffer.
;

	MOVL	FSCB$Q_NODE2+4(R11),R7	; get address of rest of string
	SUBW3	FSCB$Q_NODE1(R11),-	; get size of string minus the
		FSCB$Q_NODE(R11),R6	; first node spec
	TSTL	NWA$Q_ACS(R9)		; branch if there is no defualt
	BEQL	30$			;  access control string to apply
	MOVQ	FSCB$Q_NODE1(R11)[R0],R4	; desc of last node
	SUBW2	#2,R4

;
; Apply default access control string to nth node spec overriding the one
; (if any) associated with it.
;
; Note:	<R4,R5> => last (nth) node spec (not including double colon delimiter)
;	<R6,R7> => 2nd to nth node spec string (including '::'s)
;

	MOVZWL	R4,R1
	ADDL2	R5,R1				; R1 => end of last node
	BBC	#FSCB$V_ACS,R4,20$		; branch if there is no access
						;  control string to override
	LOCC	#^A/"/,R4,(R5)			; <R0,R1> => ACS
	SUBL2	R0,R6				; Reduce size of string by size
						;  of ACS being removed
20$:	ADDW2	NWA$Q_ACS(R9),R6		; increase size of string by
						;  size of ACS to be added
	MOVC3	NWA$Q_ACS(R9),-			; insert default access control
		@NWA$Q_ACS+4(R9),(R1)		;  string into last node spec
	MOVW	#^A/::/,(R3)			; add delimiter to string
	CLRL	NWA$Q_ACS(R9)			; zero ACS size/flag so we
						;  don't do it again
30$:	MOVZWL	R6,R6				; clear and flags
	ADDL2	R6,NWA$Q_INODE(R9)		; update intermediate node spec
	SUBL2	R6,NWA$Q_INODE+4(R9)		;  descriptor
	CMPW	NWA$Q_INODE(R9),#NWA$C_INODESIZ	; make sure that this node spec
						;  will not overflow buffer
	BGTRU	ERRNOD1				; branch on error
	MOVC3	R6,(R7),@NWA$Q_INODE+4(R9)	; prefix node spec to the others
	RSB					; try another translation

;
; The last attempted logical node name translation failed--we have a real
; node name. Construct the primary node spec from this node name and any
; default access control string that may be in effect. Finally, update the
; node name element buffer with the primary and any intermediate node specs
; found so far.
;
; Note: <R4,R5> describes a node spec without '::', but possibly including a
; leading noise "_" character.
;

TRANSLATE_FAIL:
	CMPW	R4,#FWA$C_MAXNODNAM+1	; check node name string size
	BGTRU	ERRNOD			; branch on error
	MOVL	R5,R7			; store address of string
	MOVZWL	R4,R3			; get address past string
	MOVC3	NWA$Q_ACS(R9),-		; append access control string (if any)
		@NWA$Q_ACS+4(R9),(R5)[R3]	;  and double colon to construct
	MOVW	#^A/::/,(R3)+		;  primary node spec string
	SUBL3	R7,R3,R0		; get new length (saving R6 flags)
	MOVW	R0,R6			; now <R6,R7> => node spec string

;
; Validate and copy the primary (left-most) node spec to the node name element
; buffer. If node name has been seen during a previous pass (FNA or DNA), then
; this node spec will not be copied.
;

	MOVZBL	#FWA$V_NODE,R0
	MOVZWL	#<FWA$C_MAXNODNAM+NWA$C_MAXACS+2>,R1
	MOVAQ	FWA$Q_NODE(R10),R5
	BSBW	CHECK_FIELD

;
; If no copy occurred, mark this to signify that intermediate and secondary
; node specs also should be ignored for this pass (DNA or RLF).
;

	BLBS	R0,10$			; branch if primary node spec
					;  was copied to element buffer
	SSB	#FWA$V_NOCOPY,(R10)	; flag that the primary node spec
	BRB	50$			;  was not copied to element buffer
10$:	MOVQ	FWA$Q_NODE(R10),-	; save descriptor of primary
		FWA$Q_NODE1(R10)	;  node spec string
	CLRW	R6			; clear size field
	BISL2	R6,FWA$Q_NODE1(R10)	; set flags in the descriptor

;
; Append intermediate node specs (if any) that were generated from logical
; node name translation to the node name element buffer.
;
; First call scan_string to reparse the nodes, no need to check fo syntax
; and what ever since we built the names ourselves
;

	MOVZWL	NWA$Q_INODE(R9),R6	; get descriptor of intermediate
	BEQL	50$			;  node spec list, if null then exit
	MOVL	NWA$Q_INODE+4(R9),R7	; get address <R6,R7>
	MOVAB	FSCB$C_BLN(R11),R11	; use secondary FSCB
	BSBW	RM$SCAN_STRING		; rescan the string to isolate
					;  intermediate node specs
	CLRL	AP			; start loop
30$:	CMPB	AP,FSCB$B_NODES(R11)	; are we done
	BGEQU	40$			; yes
	MOVQ	FSCB$Q_NODE1(R11)[AP],R6	; get next node
	BSBW	APPEND_NODESPEC		; append next intermediate node spec
					;  to node name element buffer
	INCL	AP			; index to the next nodespec
	BRB	30$			; loop
40$:	MOVAB	-FSCB$C_BLN(R11),R11	; restore FSCB

;
; Logical node name translation performed on the left-most node spec of
; the user supplied file specification string is complete. Now process any
; other node specs and/or a quoted string that may follow.
;

50$:	CLRL	AP			; index of node to use in
					;  secondary_node

;
; Check to see if the user specified any secondary node specs
;

SECONDARY_NODE:
	INCL	AP				; get next node
	CMPB	AP,FSCB$B_NODES(R11)		; any nodes left?
	BLSSU	10$				; branch if yes
	POPL	R9				; restore ifb
	RMSSUC					; exit wit success
	RSB

;
; The user has supplied a secondary node spec string. Append it to the
; node name element buffer, but do not perform logical node name translation
; unless the node spec string has its password masked out.
;

10$:	MOVQ	FSCB$Q_NODE1(R11)[AP],R6	; get descriptor of new node
	BBC	#FSCB$V_PWD,R6,30$	; branch if password is not masked out
					;  of access control string of node spec
	CMPB	#^A/_/,(R7)		; remove leading underscore character
	BNEQ	20$			;  (if present) before attempting
	DECW	R6			;  translation of special logical node
	INCL	R7			;  name string with password masked out

;
; Attempt one level of logical node name translation to obtain the original
; access control string because the current node spec string has its password
; masked out.
; Use of $TRNLOG here is okay as no extended logical name features are needed.
;

	ASSUME	TRNLOG$_ACMODE	EQ	<TRNLOG$_DSBMSK-4>
	ASSUME	TRNLOG$_TABLE	EQ	<TRNLOG$_ACMODE-4>
	ASSUME	TRNLOG$_RSLBUF	EQ	<TRNLOG$_TABLE-4>
	ASSUME	TRNLOG$_RSLLEN	EQ	<TRNLOG$_RSLBUF-4>
	ASSUME	TRNLOG$_LOGNAM	EQ	<TRNLOG$_RSLLEN-4>
	ASSUME	TRNLOG$_NARGS	EQ	6

20$:	SUBW2	#2,R6			; remove trailing '::'
	MOVQ	R6,NWA$Q_LOGNAME(R9)	; store descriptor of node spec string
					;  to translate
	PUSHL	#3			; only look in process table
	PUSHL	#0			; do not return mode of equiv string
	PUSHL	#0			; do not return table of equiv string
	PUSHAQ	NWA$Q_XLTBUF1(R9)	; specify address of descriptor of
					;  buffer to receive equivalence string
	PUSHAL	NWA$L_XLTSIZ(R9)	; specify address of word to receive
					;  equivalence string size
	PUSHAQ	NWA$Q_LOGNAME(R9)	; specify address of descriptor pointing
					;  to logical name candidate
	$TSTPT	NTXLATLOG		;
	CALLS	#6,@#SYS$TRNLOG		; Translate the logical name
	CMPW	R0,S^#SS$_NORMAL	; Was translation successful?
	BNEQ	ERRNOD2			; Branch if not

	MOVZWL	NWA$L_XLTSIZ(R9),R6	; descriptor of equivalence
	MOVL	NWA$Q_XLTBUF1+4(R9),R7	;  string in <R6,R7>

;
; Process the equivalence string.
;
; Note that a call to UPCASE_COMPRESS is not required.
;

	MOVAB	FSCB$K_BLN(R11),R11	; use temporary FSCB
	PUSHL	R6			; save string length
	BSBW	RM$SCAN_STRING		; parse eq. string
	POPL	R6			; restore input length
	CMPW	FSCB$Q_FILESPEC(R11),R6	; was the full spec parsed ok
	BNEQ	ERRNOD2			; no, exit

	ASSUME	FSCB$B_FLDFLAGS	EQ	0

	CMPB	#FSCB$M_NODE,(R11)	; better be just nodes
	BNEQ	ERRNOD2			; no, exit
	MOVQ	FSCB$Q_NODE(R11),R6	; get descriptor of node spec
	MOVAB	-FSCB$K_BLN(R11),R11	; restore FSCB

;
; Validate and append secondary node spec to node name element buffer.
;

30$:	BSBB	PSEUDO_CHKFLD		; validate node spec syntax
	BSBB	APPEND_NODESPEC		; append next secondary node spec
					;  to node name element buffer
	BRW	SECONDARY_NODE		; examine next field

;
; NOTE: We cannot return directly up to parse_string level because R9 was
;	pushed onto the stack in check_node so remove return pc 
;	at errnod3 which will set the error code and return to parse_string
;

ERRNOD3:				;
	POPL	R0			; remove return PC
ERRNOD2:				;
	BRW	ERRNOD			; Branch aid

;
; This routine determines whether a field is a possible node spec string
; that may contain a logical node name and an access control string.
;
; Inputs:
;
;	<R6,R7>	Descriptor of field
;
; Outputs:
;
;	R0-R2	Destroyed
;

PSEUDO_CHKFLD:
	SUBW3	#2,R6,R2		; get string size w/o '::'
	BBC	#FSCB$V_ACS,R6,10$	; branch if no ACS present
	LOCC	#^A\"\,R2,(R7)		; on return <R0,R1> => ACS
	CMPW	R0,#NWA$C_MAXACS	; check size of ACS
	BGTRU	20$			; branch if too big
	SUBW2	R0,R2			; compute size of logical node name
10$:	CMPW	R2,#FWA$C_MAXLNDNAM	; check size of logical node name
	BGTRU	ERRNOD3			; branch if too big
	RSB				; exit

;
; NOTE: We cannot return directly up to parse_string level because R9 was
;	pushed onto the stack in check_node so remove return pc, restore R9, 
;	set the error code and exit
;

20$:	POPL	R0			; remove return PC
	POPL	R9			; restore ifb ptr
	RMSERR	ACS			; declare error in access cntrl string
	BRW	PRS_ERROR		; and get out


;
; This routine appends the string described by <R6,R7> to the node name element
; buffer described by FWA$Q_NODE, i.e., an intermediate or secondary node spec
; is appended to the node specs already in the node name element buffer.
; Also, a descriptor pointing to the appended string is saved in FWA.
;
; Inputs:
;
;	<R6,R7>	Descriptor of field
;
; Outputs:
;
;	R0-R5 are destroyed.
;

APPEND_NODESPEC:
	BICL2	#^XFFFF0000,R6		; clr flags in 2nd word of descriptor
	BBS	#FWA$V_NOCOPY,(R10),10$	; if primary node spec was discarded
					;  this pass, then discard this one too
	INCB	FWA$B_SUBNODCNT(R10)	; increment secondary node spec counter
	MOVZBL	FWA$B_SUBNODCNT(R10),R0	; copy the counter
	CMPL	R0,#FWA$C_MAXSUBNOD	; branch if there are too many
	BGTRU	ERRNOD3			;  secondary node specs
	MOVAB	FWA$Q_NODE(R10),R2	; get address of node descriptor
	ADDL3	(R2)+,(R2),R3		; compute address of next available
					;  byte of node name buffer
	MOVAQ	FWA$Q_NODE1(R10)[R0],R1	; get address of next node spec desc
	MOVL	R6,(R1)+		; save descriptor of node spec
	MOVL	R3,(R1)			;  being appended
	ADDL2	R6,-(R2)		; adjust size in node name descriptor
	CMPW	(R2),#FWA$C_MAXNODLST	; make sure intermediate node spec
					;  string will fit in node name buffer
	BGTRU	ERRNOD3			; branch on error
	MOVC3	R6,(R7),(R3)		; append next node spec string
					;  to node name element buffer
10$:	RSB				; exit


;
; We have a file name
;

CHECK_NAME:

;
; Check to see if it is a quoted string
;

	ASSUME	FWA$C_MAXQUOTED GE FWA$C_MAXNAME

	BBC	#FSCB$V_QUOTED,R6,10$	; is it a quoted name string?

	MOVZBL	#FWA$C_MAXQUOTED,R1	; for quoted strings use the max quoted size
	BRB	20$			;

10$:	MOVZBL	#FWA$C_MAXNAME,R1	; check non-quoted length
20$:	MOVZBL	#FWA$V_NAME,R0		; set code for check_field
	MOVAQ	FWA$Q_NAME(R10),R5	; output descriptor
	BSBW	CHECK_FIELD		; copy string
	BBC	#FWA$V_FNA_PASS,(R10),50$; branch if not FNA pass
	BBC	#FWA$V_NAME,(R10),50$	; branch if name not seen
	SSB	#FWA$V_EXP_NAME,(R10)	; set explicit name flag
50$:	BLBC	R0,90$			; if we didn't use this string, go on
	BBC	#FSCB$V_QUOTED,R6,90$	; if string not quoted, continue

;
; We just used a quoted string for a name string - it now resides in
; FWA$Q_NAME, quotes and all.
;

	SSB	#FWA$V_QUOTED,(R10)	; flag quoted name in use

;
; We now will flag that we've seen a type, since having a quoted
; string "implies" a type (that's why TYPE and not EXP_TYPE is set).
; This keeps the type from showing up later by defaulting and relating
; and such.  Unfortunately, we can't use the current status of the 
; FWA$V_TYPE bit to tell us whether we've already seen a type, as at the
; end of the FNA scan EXP_TYPE if set is used to set TYPE.  EXP_TYPE is
; set even if there was only a . with no "real" type characters (to
; allow null types of course, otherwise they would fill in from the 
; defaults...).  So we have to check at this point for the length
; of the FWA$Q_TYPE descriptor.
;

	SSB	#FWA$V_TYPE,(R10)
	TSTL	FWA$Q_TYPE(R10)		; is there any type?
	BNEQ	FNMERR			; if neq yes, oops, error

90$:	RMSSUC
	RSB

;
; return file name error here quick and easy
;

FNMERR:	CLRL	R0
	RSB



	.SBTTL	PARSE_DIR, Parse a Directory String
;
; We have a left bracket (square or angle) indicating a directory spec.
;
; It may be of the [grp,mbr] format, [directory-name] format,
; [directory-name.directory-name2...] format, or [.directory-name...]
; format.
;
; Determine the format and copy the various parts to the directory buffers.
;

	ASSUME	FWA$C_MAXDIRLEN	EQ	255	; for overflow checking

PARSE_DIR:
	BBS	#FSCB$V_CONCEAL,-		; cant be concealed directory
		FSCB$Q_DIRECTORY(R11),ERRDIR1	;  type
	CMPB	FSCB$B_DIRS(R11),#FSCB$C_MAXDIR	; are thier to many directories?
	BGTRU	ERRDIR1				; yes, bad!
	ADDB3	#2,@FSCB$Q_DIRECTORY+4(R11),-	; determine whether to use ']'
		FWA$B_DIRTERM(R10)		;  or '>' as teminator, taking
						;  advantage of the fact that
						;  the ASCII code for each of
						;  the right brackets is 2 more
						;  than the code for the
						;  correspoinding left bracket

;
;   If this is the related file pass and we are doing an output file parse
;   then if the directory in the current expanded filename is a
;   wildcard - replace it with the first wild field in the directory
;   of the related filename (i.e. sticky directories)
;

	BBC	#FWA$V_RLF_PASS,(R10),-	; If this isn't a related file pass
		10$			;  don't make directories sticky
	BBC	#FAB$V_OFP+FOP,(R8),-	; If this isn't output file parse
		10$			;  don't make directories sticky
	BSBW	STICKY_DIR		; go check for sticky directories
	BLBC	R0,ERRDIR1		; if any errors, go report them
	CMPB	R3,FWA$B_DIRTERM(R10)	; have we passed the whole directory ?
	BNEQU	SKPDIR			; no - go eat the rest
	BRB	DIRXIT1			; only use sticky fields

10$:	BBS	#FWA$V_DIR,(R10),SKPDIR	; Branch if directory already seen
	MOVQ	FSCB$Q_DIRECTORY1(R11),R6; get the first spec
	BBS	#FSCB$V_GRPMBR,R6,-	; is it [group,member] format?
		GRPMBR			;  or normal
	BRB	NAMED_DIR

ERRDIR1:
	BRW	ERRDIR			; Error in directory format


;
; We have a '[group,member]' directory format
;

GRPMBR:

;
; check to make sure they are correct specs.
;
;  1.  3 characters or less
;  2.  less then or equal to 377 octal
;

	CMPW	R6,#3			; 3 characters?
	BNEQ	10$			; no need to check unless 3
	CMPB	(R7),#^A/3/		; is first char > 3?
	BGTRU	ERRDIR1			; if so it's an error
10$:	MOVZBL	#FWA$V_DIR1,R0
	MOVZBL	#3,R1
	MOVAQ	FWA$Q_DIR1(R10),R5
	BSBW	CHECK_FIELD

;
; First part ok - check second part.
;

	MOVQ	FSCB$Q_DIRECTORY2(R11),R6
	CMPW	R6,#3			; 3 characters?
	BNEQ	20$			; no need to check unless 3
	CMPB	(R7),#^A/3/		; is first char > 3?
	BGTRU	ERRDIR1			; if so it's an error
20$:	MOVZBL	#FWA$V_DIR2,R0
	MOVZBL	#3,R1
	MOVAQ	FWA$Q_DIR2(R10),R5
	BSBW	CHECK_FIELD

	SSB	#FWA$V_GRPMBR,(R10)	; flag group member format in fwa
	SSB	#FSCB$V_GRPMBR,-		;  and descriptor
		FWA$Q_DIR1(R10)
	ADDB3	FWA$Q_DIR1(R10),-	; compute the directory length of the
		FWA$Q_DIR2(R10),-	;  UIC format directory by adding the
		FWA$B_DIRLEN(R10)	;  lengths of the two separate parts
					;  together
	BCS	ERRDIR1			; if overflow the byte
	SSB	#FWA$V_DIR_LVLS,(R10)	; treat UIC dirs as having 2 levels

DIRXIT1:
	BRW	DIRXIT			; All set

;
; We must skip over directory spec.
;

	ASSUME	FWA$V_DUPOK	EQ	0

SKPDIR:	BLBS	(R10),DIRXIT1		; branch if duplicates allowed
	BRB	ERRDIR

;
;	We have a normal format directory name.
;	Check for '[]' or '[.name]' or '[-.name]'
;	indicating explicit default directory.
;

NAMED_DIR:
	MNEGL	#1,R4				; set up for normal case
	BBS	#FSCB$V_MINUS,R6,10$		; relative if leading minus
	BBC	#FSCB$V_NULL,R6,30$		; branch if not null
10$:	BSBW	DEFAULT_DIR			; get default directory
	BLBS	R0,20$				; ok, continue
	RSB

20$:	EXTZV	#FWA$V_DIR_LVLS,-		; get the # of directory levels
		#FWA$S_DIR_LVLS,(R10),R4	;  could be <>0 from default_dir
30$:	CLRL	AP				; AP = dirs used from FSCB

;
; Subtract any minus signs from the directory levels
;

LOOP:	BBC	#FSCB$V_MINUS,R6,COPY_DIR	; are there any minus signs?

;
; The length of the directory string (R6) is the number of minus
; signs present. NOTE: You cannot go past MFD but can go past UFD
;

	MOVZWL	R6,R1				; get number of '-'s
5$:	TSTL	R4				; can we subtract a directory
	BGTR	10$				; ok, if >0
	BLSS	ERRDIR				; can't go negative

;
; R4 = 0, we are at the top, check for MFD
;

	CMPW	FWA$Q_DIR1(R10),#6		; MFD is six characters
	BNEQ	10$				; if not right then ok
	MOVL	FWA$Q_DIR1+4(R10),R0		; get address of name
	CMPL	(R0)+,B^MFD_ASCII		; check if it's MFD
	BNEQ	10$				; neq, then it can't be
	CMPW	(R0),B^MFD_ASCII		; last part
	BEQL	ERRDIR				; can't do that
10$:	ADDL3	#FWA$V_DIR1,R4,R0		; get the flag offset
	CSB	R0,(R10)			; clear the flag
	MOVAQ	FWA$Q_DIR1(R10)[R4],R0		; get addr of descriptor
	CLRL	(R0)				;  and clear it
	DECL	R4				; remove this directory
	SOBGTR	R1,5$				; are there any more?
	BRB	GET_NEXT			; no, get next directory

;
; Handle directory error
;

ERRDIR:	RMSERR	DIR			; show error
	RSB				;  and get out

;
; ASCII name for the MFD and some trailing blanks 
;
MFD_ASCII:
	.ASCII	^000000  ^

;
; Set up directory for check_field
;

COPY_DIR:
	CMPL	R4,#FWA$C_MAXSUBDIR		; check to see if we are ok
	BEQL	ERRDIR				; opps
	BBS	#FSCB$V_NULL,R6,GET_NEXT		; null directory spec?
	INCL	R4				; ready to process it
	ADDL3	#FWA$V_DIR1,R4,R0		; find the flag offset
	MOVZBL	#FWA$C_MAXNAME,R1		; length
	MOVAQ	FWA$Q_DIR1(R10)[R4],R5		; descriptor for this directory
	BSBW	CHECK_FIELD			; copy the directory
	ADDB2	R6,FWA$B_DIRLEN(R10)		; accumulate directory spec length
	BCS	ERRDIR				; if overflow the byte
	INCB	FWA$B_DIRLEN(R10)		; count the terminator too
	BCS	ERRDIR				; if overflow the byte

;
; Set up for next directory field
;

GET_NEXT:
	BBC	#FSCB$V_ELIPS,R6,10$		; was there an elips?
	TSTL	R4				; < 0 if past UFD
	BGEQ	5$				; ok, skip
	BSBB	INSERT_MFD			; insert mfd in directories
5$:	MOVAQ	FWA$Q_DIR1(R10)[R4],R0		; get addr of descriptor
	SSB	#FSCB$V_ELIPS,(R0)		; set flag in high word
	SSB	#FWA$V_WILDCARD,(R10)		; set over all wild card
	SSB	#FWA$V_WILD_DIR,(R10)		; set directory wild card
10$:	INCL	AP				; inc. use count
	CMPB	AP,FSCB$B_DIRS(R11)		; used them all?
	BEQL	20$				; yes, finish up
	MOVQ	FSCB$Q_DIRECTORY1(R11)[AP],R6	; get next directory
	BRW	LOOP				; go process it

;
; Directory parse completed - if directory specification contains no
; levels (as a result of minus signs), then insert 000000 as directory name
;

20$:	TSTL	R4				; < 0 if past UFD
	BGEQ	30$				; ok, skip
	BSBB	INSERT_MFD			; insert mfd
30$:	INSV	R4,#FWA$V_DIR_LVLS,-		; stuff the final result
		#FWA$S_DIR_LVLS,(R10)

;
; Directory processed ok, go process next field
;

DIRXIT:	RMSSUC
	RSB


;
; Insert the name "000000" into the directory spec.
;

INSERT_MFD:
	SSB	#FWA$V_DFLT_MFD,(R10)		; flag MFD was inserted
	MOVW	#6,FWA$Q_DIR1(R10)		; insert length of "000000"
						;  NOTE: Do not disturb flags
	MOVQ	B^MFD_ASCII,-			; move the string "000000"
		@FWA$Q_DIR1+4(R10)
	CLRL	R4				; say just one level
	RSB

;
; We have a directory spec of the form [] or [.name], or [-.name]
; implying a sub-directory of the current default directory.
; It is valid only if default directory is not of the [group,member] format.
; Call PARSE_STRING recursively to apply default directory.
;
;

DEFAULT_DIR:

;
; If this is a network filespec, then the directory string should be sent
; to the remote FAL as entered, that is, without resolving hyphens or a
; null root directory. So if a node name is present, say UFD seen and
; make the corresponding FWA descriptor point to a null root directory
; string or one consisting of one or more hyphens.
;

	BBC	#FWA$V_NODE,(R10),10$	; branch if node not seen
	MOVL	R6,FWA$Q_DIR1(R10)	; store string size in DIR1 descriptor
	MOVC	R6,(R7),-		; copy the string
		@FWA$Q_DIR1+4(R10)
	CSB	#FSCB$V_MINUS,R6	; clear minus bit in mask to avoid
					;  having it resolved in this routine
	BBCS	#FWA$V_DIR1,(R10),20$	; say UFD seen and branch

;
; And its context (logname flag and directory terminator).
;

10$:	PUSHR	#^M<R2,R3,R4,R5,R6,R7>	; save current registers
	MOVB	FWA$B_LNFLGS(R10),-(SP)	;
	MOVB	FWA$B_DIRTERM(R10),-(SP);
	CLRB	FWA$B_LNFLGS(R10)	; say no logical name seen
	CSB	#FWA$V_DIR,(R10)	; clear directory seen flag

;
; Call PARSE_DIR recursively
;

	ASSUME	FSCB$B_FLDFLAGS	EQ	0

	MOVAB	FSCB$K_BLN(R11),R11	; use temporary FSCB
	CLRB	(R11)			; clear flags
	MOVAB	@#PIO$GT_DDSTRING,R7	; make descriptor of default directory
	MOVZBL	(R7)+,R6		;  string (stored as counted string)
	PUSHL	R6			; save input length
	BSBW	RM$SCAN_STRING		; parse default directory
	POPL	R6			; restore input length
	CLRL	R0			; assume failure
	CMPW	FSCB$Q_FILESPEC(R11),R6	; was the full spec parsed ok
	BNEQ	15$			; no, exit
	CMPB	#FSCB$M_DIRECTORY,(R11)	; should only have a directory 
	BNEQ	15$			; incorrect default string if so.
	MOVQ	FSCB$Q_DIRECTORY(R11),R6	; get string
	BSBW	PARSE_DIR		; parse it

;
; Restore previous context.
;

15$:	MOVAB	-FSCB$K_BLN(R11),R11	; restore old FSCB
	MOVB	(SP)+,FWA$B_DIRTERM(R10);
	MOVB	(SP)+,FWA$B_LNFLGS(R10)	;
	POPR	#^M<R2,R3,R4,R5,R6,R7>	; restore registers
	BLBC	R0,90$			; branch on failure

;
; If done with directory spec, then exit immediately else check for
; compatible directory formats.
;

20$:	BBS	#FSCB$V_MINUS,R6,30$	; If leading minus,
	CMPB	#1,FSCB$B_DIRS(R11)	;  or if not done
	BEQL	40$			;  then handle relative filespec

;
; Do not allow concatenation of uic format directories.
;

30$:	BBS	#FWA$V_GRPMBR,(R10),50$	; format ok?
40$:	MOVZBL	#1,R0			; success
	RSB

50$:	BRW	ERRDIR			; no, get error then exit

;
; The default directory string is messed up. This should
; never happen, but it's not too serious. Try to continue.
;

90$:	RMSERR	BUG_DDI			; return error
	RSB

	.SBTTL TRANSLATE, Translate Logical Name

;
; Logical name translation ...
;
; This subroutine attempts to translate the string described by the last
; FWA$Q_LOGNAM string.  If this is NOT a search list logical name the current
; SLB, R6, will be the 'fake' SLB in the fwa itself.  If it is a known search
; list logical name use the index (which could have been updated) in the
; appropiate SLB.
;
; If we are successful, check for an 'escape' equivalence string indicating a
; process-permanent file in which case the escape string is stored in the
; FWA and the parse is terminated.
;
; If not an escape string, the original string is returned to the user
; and a success return is made.
;
; If not an escape string or underline, the equivalence string replaces the
; parse input string and a branch is made to PARSE_STRING to merge in the
; filename elements of the equivalence string. If the translate was
; unsuccessful, a failure return is made to the caller with the equivalence
; string (identical to the input name minus the initial underscore if any)
; described by <R6,R7>.
;
; This returns only if the string was not used either the translation failed
; or we did not want to use it.  Errors are returned one level up.  If the
; name was translated and used we branch to parse_string and act like we are
; continuing to parse the same string (same FSCB).
;
; If it returns:
;
;	If R0 = 1 then	<R6,R7> => orginal input string (Concealed device)
;
;	If R0 = 0 then	<R6,R7> => orginal input string without leading
;				   underscore, if any (No translation)
;


LNM_ATTR:
	.LONG	LNM$M_CASE_BLIND	; Caseless LNM translation
TABNAM:	.ASCII	/LNM$FILE_DEV/		; RMS logical table name string
TABNAM_SIZE = .-TABNAM

;
; Try to translate logical name
;

TRANSLATE:
	POPL	AP	; remove (save) return PC, we are now at the PARSE_STRING
			; level, so PRS_EXIT and PRS_ERROR are legal branches

;
; Search the SLBs (if any) to see if one matches the level of recursion
; we are at, if so use the index from it.  If non found use the fake one.
;

	MOVL	FWA$L_SLB_PTR(R10),R6		; get the current slb
	BEQL	10$				; branch if none
	MOVL	R6,R0				; save for end test

;
; Check to see if we are at a level where search list are present, if so
; then use the SLB for this level.  If not continue if with the fake SLB.
;

5$:	CMPB	SLB$B_LEVEL(R6),FWA$B_LEVEL(R10); check the level
	BEQL	15$				; if same then use it
	BGTR	10$				; if past this level stop
	MOVL	SLB$L_FLINK(R6),R6		; get the next one
	CMPL	R0,R6				; at the end
	BNEQ	5$				; no, continue
10$:	MOVAL	FWA$T_SLB(R10),R6		; use the fake one

;
; Check to see if we have done the max number of translations
;

15$:	ADDB3	#1,SLB$B_LEVEL(R6),-		; bump the count and move it
		FWA$B_LEVEL(R10)		;  into the fwa
	CMPB	FWA$B_LEVEL(R10),#LNM$C_MAXDEPTH ; max trans it 10
	BGTR	ERRLNE				; were ok, continue

;
; R6 - SLB with index to translate
;

TRAN:	BBC	#LNM$V_TERMINAL,SLB$L_ATTR(R6),-; is this name a terminal?
		10$				; if not continue
	BRW	NOTRAN				; else don't bother to translate

;	
; Create a item list to pass to $trnlnm,
;

10$:	MOVAL	SLB$L_INDEX(R6),-		; get the index buffer addr
		FWA$T_ITM_INDEX+4(R10)
	MOVAL	SLB$L_ATTR(R6),-		; get the attr buffer addr
		FWA$T_ITM_ATTR+4(R10)

	ASSUME	FWA$L_XLTBUFF2	EQ	FWA$L_XLTBUFF1+4

	CVTBL	FWA$B_BUFFLG(R10),R0		; which buffer should we use?
						; 0 => buff2; -1 => buff1
	MCOMB	R0,FWA$B_BUFFLG(R10)		; switch buffers for next time
	MOVL	FWA$L_XLTBUFF2(R10)[R0],R5	; get output buffer addr
	MOVL	R5,FWA$T_ITM_STRING+4(R10)	;
	MOVAL	SLB$L_MAX_INDEX(R6),-		; get the max_index buffer addr
		FWA$T_ITM_MAX_INDEX+4(R10)	;
	PUSHAB	TABNAM				; make descriptor of tablename
	PUSHL	#TABNAM_SIZE
	MOVL	SP,R1

	$TSTPT	XLATLOG

TRNLNM:	$TRNLNM_S -
		TABNAM=(R1),-
		ATTR=W^LNM_ATTR,-
		LOGNAM=FWA$Q_LOGNAM(R10),-
		ITMLST=FWA$T_ITMLST(R10),-
		ACMODE=FWA$B_XLTMODE(R10)

	ADDL2	#8,SP				; discard tablename descriptor
	MOVZWL	FWA$W_XLTSIZ(R10),R4		; <R4,R5> => translation if any
	BLBS	R0,NORMAL
	CMPW	R0,#SS$_NOLOGNAM
	BEQL	NOLOGNAM

;
; Either the system service failed or the maximum number of translations
; has been exceeded or the logical name translation yielded an escape
; string that was either the wrong length, of the wrong mode, or not
; the only field.
;

ERRLNE:	RMSERR	LNE			; show error
	BRW	PRS_ERROR		; and get out

;
; Something worked.  Lets see if it really did anything usefull
;

NORMAL:	TSTL	SLB$L_MAX_INDEX(R6)		; was there really a translation
	BLSS	NOLOGNAM			; no
	BBS	#LNM$V_EXISTS,SLB$L_ATTR(R6),-	; was there a translation for
		HAVEONE				;  this index?
	INCL	SLB$L_INDEX(R6)			; bump index
	CMPL	SLB$L_INDEX(R6),-		; have we gone past the max
		SLB$L_MAX_INDEX(R6)		;  index for this name?
	BLEQ	TRNLNM				; no, try again, NOTE: the item
						;  list is still valid

;
; We did not get a translation of any kind, remove the current SLB (if any)
; and continue on
;

NOLOGNAM:
	CLRL	SLB$L_INDEX(R6)			; clear the index
	DECB	SLB$B_LEVEL(R6)			; and lower the level (in fwa)
	BBC	#SLB$V_REALSLB,SLB$B_FLAGS(R6),-; do we realy need to deallocate
		20$

;
; Deallocate SLB
;

	REMQUE	(R6),R4				; remove the SLB from the list
	BVC	10$				; last one?
	MOVL	FWA$L_SLBH_PTR(R10),R0		; get SLBH address 
	CLRL	SLBH$L_SLB_QUE(R0)		; clear the pointer to the list
10$:	PUSHL	R11				; save FSCB
	MOVL	FWA$L_IMPURE_AREA(R10),R11	; restore impure address
	JSB	RM$RETBLK1			; deallocate the space
	POPL	R11				; restore FSCB
20$:	BRW	NOTRAN				; return failure

;
; We translated a logical name.  Check to see if the name we translated was
; a search list.
;

HAVEONE:
	TSTL	SLB$L_MAX_INDEX(R6)		; was this a search list
	BLEQ	20$				; no

;
; We have incountered a search list logical name, it could be one we already
; know about or a new one
;

	SSB	#FWA$V_SLPRESENT,(R10)		; flag that we have one
	BBS	#SLB$V_REALSLB,SLB$B_FLAGS(R6),-; did we already know that?
		20$

;
; Allocate a SLB place it in the queue and copy the logical name form
; the fake SLB to it, R6 will point to the new SLB
;

	BSBW	ALLOCATE_SLB			; get an SLB
	BLBC	R0,60$				; if there is one

;
; Check to see if we got an escape string indicating a process permanent file.
;

20$:	CMPB	(R5),#ESCAPE			; do we have a PPF?
	BEQL	PPERMFILE			; yes, process it

;
; If the equivalence string has a concealed device then ignore the
; translation and preserve the logical name as the device name.
;

30$:	BBS	#LNM$V_CONCEALED,SLB$L_ATTR(R6),-; concealed device?
		PARSE_CONCEAL

;
; Parse the equivalence string as the filename string.
;

	MOVQ	R4,R6				; get into right registers
	BSBW	UPCASE_COMPRESS			; perform upcasing and string
						;  compression in place
	BBC	#FWA$V_FNA_PASS,(R10),50$	; leave dupok if not fna pass
	BICB2	#FWA$M_DUPOK,(R10)		; logical names must provide
						;  no duplicate fields
50$:	BRW	PARSE_STRING			; continue processing

60$:	BRW	PRS_ERROR			; quit if no room

;
; Ppermfile ...
;
; The equivalence string starts with an escape.
; It looks like we have a process permanent file.
;
; Check that the equivalence string has at least 4 bytes.
; Don't use it if it is an RLFi string.
;

PPERMFILE:
	BBS	#FWA$V_RLF_PASS,(R10),30$	; ignore if processing RLFi
	CMPL	R4,#4				; is escape string 4 bytes long?
	BLSSU	20$				; no - uninterpretable
	MOVL	(R5),FWA$L_ESCSTRING(R10)	; store the escape string

;
; Use CHECK_FIELD to copy the process permanent logical name
; to the device name field.
;

	MOVQ	FWA$Q_LOGNAM(R10),R6		; get descriptor
	MOVZBL	#FWA$V_DEVICE,R0
	MOVZBL	#FWA$S_DEVICEBUF,R1
	MOVAQ	FWA$Q_DEVICE(R10),R5
	BSBW	CHECK_FIELD
	BBC	#FWA$V_FNA_PASS,(R10),10$	; branch if not processing FNA
	SSB	#FWA$V_EXP_DEV,(R10)		; set explicit device flag
10$:	BRW	PRS_EXIT1			; all done, exit parse_string

20$:	BRW	ERRLNE				; error in translation

30$:	BRW	PRS_EXIT			; all done, ignore this string

;
; No translation occurred
;

NOTRAN:	CLRL	R0			; show no translation
;;;; strip leading underscore if there is one
;;;	movq	fwa$q_lognam(r10),r6	; restore input string
;;;	cmpb	(r7),#^a/_/		; leading underscore?
;;;	bneq	extran			; no, exit
;;;	decw	r6			; cut it off
;;;	incl	r7			;
	BRB	EXTRAN			; exit

;
; The translation is not to be used (Concealed device/directory)
;

DONTUSE:
	MOVZBL	#1,R0			; translation valid, but not to be used
	MCOMB	FWA$B_BUFFLG(R10),-	; flip the buffer flag back
		FWA$B_BUFFLG(R10) 

EXTRAN:	MOVQ	FWA$Q_LOGNAM(R10),R6	; restore input logical name
	JMP	(AP)			; effective RSB to caller


	.SBTTL	PARSE_CONCEAL, Parse Concealed Logical Name

;
; PARSE_CONCEAL
;
;	Parse the concealed device string and rooted directory string, if any
;

PARSE_CONCEAL:
	BBS	#FWA$V_DEVICE,(R10),80$		; Branch if device already seen
	BBSS	#FWA$V_CONCEAL_DEV,(R10),80$	; have we seen one before?
	MOVQ	R4,R6				; save input string
	BSBW	UPCASE_COMPRESS			; copy and compress string
	MOVAB	FSCB$K_BLN(R11),R11		; use temporary FSCB
	PUSHL	R6				; save size
	BSBW	RM$SCAN_STRING			; parse the parts
	POPL	R6				; restore input length
	CMPW	FSCB$Q_FILESPEC(R11),R6		; was the full spec parsed ok
	BNEQ	90$				; no, exit

	ASSUME	FSCB$B_FLDFLAGS	EQ	0

;
; Make sure the concealed device name is of the form "DEVICE:" or
; "DEVICE:[ROOTED-DIR.]" -- nothing more, nothing less.
;

	BICB3	#<FSCB$M_DEVICE!FSCB$M_ROOT>,-	; check for illegal fields
		(R11),R0			;
	BNEQ	90$				; br -- caught one!
	BBC	#FSCB$V_DEVICE,(R11),90$	; make sure it includes dev nam

;
; Copy the device descriptor and directory descriptor if any into the fwa
;

	ASSUME	FSCB$Q_ROOT8	EQ	FSCB$Q_ROOT1+56
	ASSUME	FWA$Q_CDIR8	EQ	FWA$Q_CDIR1+56

	SUBW3	#1,FSCB$Q_DEVICE(R11),-		; get device length and
		FWA$Q_CONCEAL_DEV(R10)		; remove trailing ':'
	MOVC3	FWA$Q_CONCEAL_DEV(R10),-	; copy string
		@FSCB$Q_DEVICE+4(R11),-
		@FWA$Q_CONCEAL_DEV+4(R10)
	BBC	#FSCB$V_ROOT,(R11),10$		; is there a root directory
	BSBB	CHECK_ROOT			; copy the roots
	BLBC	R0,90$				; signal error
10$:	MOVAB	-FSCB$K_BLN(R11),R11		; restore first FSCB
80$:	BRB	DONTUSE				;  and ignore the translation

90$:	RMSERR	DEV				; say it's a device error
	BRW	PRS_ERROR


;
; This routine copies the rooted directories from the FSCB into the FWA.
;

CHECK_ROOT:
	PUSHL	R6				; save r6

;
; We must follow special rules if this is the filename from a related
; file block.  We want to include the rooted dir (e.g. [SOPHIE.CHOICE.])
; in basically the same instances that we would include a device.  
;

	BBC	#FWA$V_RLF_PASS,(R10),5$	; br if not related filename
	BITW	#FWA$M_DEVICE!FWA$M_EXP_NODE,(R10) ;device or node seen already?
	BNEQ	20$				; br to ignore root if so
	BBS	#FAB$V_OFP+FOP,(R8),20$		; ignore rootdir on output parse

5$:	BBSS	#FWA$V_ROOT_DIR,(R10),40$	; say root dir present
	MOVZBL	FSCB$B_ROOTS(R11),R6		; add number of concealed dirs
	CMPB	R6,#8				; better not be more then 8 dirs
	BGTR	50$				; if not error
	MOVAB	@FSCB$Q_ROOT1+4(R11),R3		; get addr of start of string
	ADDB3	#2,-1(R3),FWA$B_ROOTERM(R10)	; stuff the terminator

;
; Can't be wild, have elips or minus signs
; Count needs to be adjusted for zero-origin as well.
;

10$:	MOVAQ	FSCB$Q_ROOT1-8(R11)[R6],R1	; get addr of FSCB descriptors
	MOVAQ	FWA$Q_CDIR1-8(R10)[R6],R2	; get addr of fwa descriptors
	BITL	#<FSCB$M_WILD!FSCB$M_ELIPS!FSCB$M_MINUS>,(R1)
	BNEQ	50$				; if so error!
	MOVW	(R1),(R2)			; copy length
	MOVC3	(R1),@4(R1),@4(R2)		; copy string
	SOBGTR	R6,10$				; loop for all descriptors
20$:	RMSSUC					; ok
30$:	POPL	R6				; and r6
	RSB					; exit

	ASSUME	FWA$V_DUPOK	EQ	0

40$:	BLBS	(R10),20$			; ok/ignore if duplicate
50$:	CLRL	R0				; error
	BRB	30$				; exit



	.SBTTL	ALLOCATE_SLB, Allocate Search List Block

;++
; ALLOCATE_SLB
;
;	Allocate a SLB to be put on the xx_SLB list.  The information
;	in the SLB is to be copied from the 'FAKE' SLB in the FWA
;	pointed to by R6.
;
;	On exit R6 will point to the new SLB.
; 
;	Things to set set:
;
;		SLB$L_FLINK	= linked into slb list
;		SLB$L_BLINK	=	"
;		SLB$B_BLN	= SLB$C_BLN
;		SLB$B_FLAGS	= SLB$V_REALSLB
;		
;
;	Things to be copied from 'fake' SLB:
;
;		SLB$B_LEVEL	= fake$b_level - 1
;		SLB$L_INDEX
;		SLB$L_MAX_INDEX
;		SLB$L_ATTR
;--

;
; Allocate a SLB
;

ALLOCATE_SLB:
	MOVQ	R4,-(SP)			; save R4,R5
	MOVZBL	#<SLB$C_BLN/4>,R2		; get # of longwords
	PUSHL	R11				; save FSCB
	MOVL	FWA$L_IMPURE_AREA(R10),R11	; restore impure address
	JSB	RM$GETBLK1			; get the space
	POPL	R11				; restore FSCB
	BLBC	R0,90$				; exit on error

;
; We have a new SLB pointed to by R1, format it and add it to the END of
; the search list queue for this pass.
;

	ASSUME	SLB$L_FLINK	EQ	0
	ASSUME	SLB$L_BLINK	EQ	SLB$L_FLINK+4
	ASSUME	SLB$B_BID	EQ	SLB$L_BLINK+4
	ASSUME	SLB$B_BLN	EQ	SLB$B_BID+1
	ASSUME	SLB$B_FLAGS	EQ	SLB$B_BLN+1
	ASSUME	SLB$B_LEVEL	EQ	SLB$B_FLAGS+1
	ASSUME	SLB$L_INDEX	EQ	SLB$B_LEVEL+1
	ASSUME	SLB$L_MAX_INDEX	EQ	SLB$L_INDEX+4
	ASSUME	SLB$L_ATTR	EQ	SLB$L_MAX_INDEX+4

	MOVL	R1,R6				; copy addr
	MOVL	R6,(R1)+			; set up forward and
	MOVL	R6,(R1)+			;  backward pointers

	MOVL	FWA$L_SLBH_PTR(R10),R2		; get SLBH addr
	MOVL	SLBH$L_SLB_QUE(R2),R0		; get first SLB
	BEQL	10$				; there is none
	INSQUE	(R6),@SLB$L_BLINK(R0)		; insert at tail
	BRB	20$				; continue
10$:	MOVL	R6,SLBH$L_SLB_QUE(R2)		; add only element

20$:	MOVB	#SLB$C_BID,(R1)+		; set block id
	INCL	R1				; skip BLN
	MOVB	#SLB$M_REALSLB,(R1)+		; set flag

	ASSUME	SLB$B_LEVEL	EQ	<FWA$B_LEVEL-FWA$T_SLB>

	MOVAL	FWA$B_LEVEL(R10),R0		; get 'fake' SLB addr at INDEX
	SUBB3	#1,(R0)+,(R1)+			; copy level - 1
	MOVQ	(R0)+,(R1)+			; copy index and max_index
	MOVL	(R0)+,(R1)+			; copy attr
	RMSSUC
90$:	MOVQ	(SP)+,R4			; restore R4,R5
	RSB

	.SBTTL	UPCASE_COMPRESS	Upcase and compress user strings
;++
;
; Entry point for UPCASE_COMPRESS.
;
; This routine copies the source string to the destination buffer while
; upcasing lowercase characters and removing space, horizontal tab, and null
; characters, except that characters enclosed in quotes are moved unaltered.
;
; Inputs:
;
;	R5	Destination buffer descriptor
;	<R6,R7>	Source string descriptor
;
; Outputs:
;
;	R5	Destroyed
;	<R6,R7>	Destination string descriptor
;
;--

;
;  Bit mask of escape characters when upcasing and compressing
;  Chars are quote (22), blank (20), tab (9) and null (0).
;

ESCAPE_CHAR:	.LONG	^B00000000000000000000001000000001  ; null and tab
		.LONG	^B00000000000000000000000000000101  ; space and quote
		.LONG	^B00000000000000000000000000000000
		.LONG	^B00000000000000000000000000000000
		.LONG	^B00000000000000000000000000000000
		.LONG	^B00000000000000000000000000000000
		.LONG	^B00000000000000000000000000000000
		.LONG	^B00000000000000000000000000000000


UPCASE_COMPRESS:			;
	TSTL	R6			; Branch if source string length is
	BEQL	50$			;  zero
	MOVQ	R4,-(SP)		; Save destination buffer address
					;  and free register

;
; Examine each character in the source string.
; Take advantage of the fact that the ASCII values for space, horizontal tab,
; null, and quote are less than the ASCII values for lowercase characters.
;

10$:	MOVZBL	(R7)+,R4		; Get char
	BBS	R4,B^ESCAPE_CHAR,60$	; A special one?
20$:	MOVB	G^EXE$UPCASE_DAT[R4],-	; Upcase it
		(R5)+			; and append to destination
30$:	SOBGTR	R6,10$			; Check for end of source string

;
; The source string is exhausted.
;

40$:	POPL	R4			; Restore saved register
	POPL	R7			; Restore destination address
	SUBL3	R7,R5,R6		; Compute length of destination string
50$:	RSB				; Exit with <R6,R7> describing
					;  upcased and compressed string

;
; A punctuation mark was found, check for which one
; A space, tab, or null character has been found, simply discard it.
;

60$:	CMPB	R4,#^A/"/		; Check for quote
	BNEQ	30$			; Discard character

;
; A leading quote character has been found.
; Copy all characters unaltered until the matching quote is found, unless
; the leading quote was preceeded by two  colons which indicates that this is
; the start of a network quoted string (as opposed to an access control string)
;

70$:	SUBL3	4(SP),R5,-(SP)		; Which char pos is this in?
	MOVB	R4,(R5)+		; Store the quote
	DECL	R6			; and count it
	BGTR	80$			; branch if not at end of string
	MOVAL	4(SP),SP		; pop top element from stack
	BRB	40$			; and branch to exit
80$:	DECL	(SP)+			; Branch if first or second character
	BLEQ	90$			;  of string
	CMPW	-2(R5),#^A\::\		; Branch if previous two non-compressed
	BEQL	100$			;  character were both colons

;
; This is where we skip all characters between quoted, and do not upcase or
; compress them.  This works for access control strings because they don't 
; have imbedded quotes, and it works for ANSI-"a" filespecs (which may have
; imbedded quotes) because the imbedded quotes are doubled.  That causes them
; to look like lots of short quoted strings as far as this routine is concerned
; but nevertheless, this routine will still not bother the internal characters.
;
; Note that ANSI-"a" filespecs do want to be upcased -- this is done at the
; end of processing -- when we actually append the type and version fields
;

90$:	MOVZBL	(R7)+,R4		; Get next char
	CMPB	R4,#^A\"\		; Is character the matching quote?
	BEQL	20$			; Branch if yes to resume normal scan
	MOVB	R4,(R5)+		; Append character to destination string
	SOBGTR	R6,90$			; End of source string?
	BRB	40$			; Branch if yes

;
; This is the start of a network quoted string. It may have embedded quote 
; characters and it must be the last element of a file specification string.
; Therefore, copy all characters unaltered until end of string is reached, 
; then work backwards to remove trailing spaces, tabs, and nulls.
;

100$:	MOVB	(R7)+,(R5)+		; Append the rest of the source string
	SOBGTR	R6,100$			;  to the destination string

;
; The source string has been exhausted. Truncate string after last non
; space, tab, or null character.
;

110$:	CMPB	-(R5),#^A/ /		; Discard space
	BEQL	110$			;
	CMPB	(R5),#HOR_TAB		; Discard horizontal tab
	BEQL	110$			;
	TSTB	(R5)			; Discard null
	BEQL	110$			;
	INCL	R5			; Position pointer past new end of
	BRB	40$			;  destination string

	.SBTTL	CHECK_FIELD - Check for Valid Field and Copy Routine

;++
;
; Functional Description:
;
; This routine checks the field described by input descriptor for
; validity based upon the field flags the high word of the descriptor and
; and the desired checks specified by R0.
;
; Checks and operations performed:
;
;	1.  if the field is null, return.
;	1a. check the size
;	2.  if FWA$V_RLF_PASS set and the field is not
;	    selected by the type of parse (input or output, based
;	    upon the FOP bit OFP), return, thus ignoring the field.
;	3.  if the filename element specified has already been seen, then
;	    return unless FWA$V_DUPOK is clear (duplicates
;	    not allowed) in which case generate an error.
;	4.  flag the filename element present.
;	5.  if the field is a wild card, flag that too,
;	    both for specific field and overall.
;	6.  if this is a logical name save the descriptor only,
;	    otherwise copy the field to the element buffer setting the
;	    length in the descriptor.
;       7.  return
;       8.  set V_NOT_COPIED if duplicate field was ignored
;	    (i.e., not copied to element buffer).
;
; Calling Sequence:
;
; 	BSBW	CHECK_FIELD
;
; Input Parameters:
;
;	R0	Flags
;	R1	Maximun field size
;	R6,R7	Descriptor of input field
;	R5	Address of descriptor of output field
;	R8	FAB address
;	R10	FWA address
;
; Implicit Inputs:
;
;	The current state of the FWA, including
;	FWA$B_FLDFLGS, FWA$V_RLF_PASS,  FWA$V_DUPOK, FWA$V_LOGNAME
;
; Outputs:
;
;	R0 -	1	- Ok, copied
;		0	- Ok, not copied
;
;	R1-R3,R5	Destroyed
;
; Implicit Outputs:
;
;	-FWA$B_FLDFLGS or FWA$V_LOGNAME or FWA$V_NODE set if field copied
;	-FWA$B_WILDFLGS and FWA$V_WILD set if field is wild
;	-FWA$B_DIRFLGS set if directory field (also FWA$B_DIRWCFLGS)
;	-the indicated FWA element buffer and its descriptor are
;	 updated if field copied
;
; Completion Codes:
;
;	R0
;
; Side Effects:
;
;	None
;
;--

CHECK_FIELD:
	CMPW	R6,R1				; is the field size ok?
	BGTRU	10$				; nope
	BBC	#FWA$V_RLF_PASS,(R10),40$	; Branch if not parse of
						;  RLF string

;
; This is the parse of the related file string.
; Look at the OFP FOP bit to determine whether this field is
; to be utilized or not.
;
; The rules are:
;
;	If this is a parse of an input file all fields except version are sticky.
;	including logicalnames	unless the field is null or
;	unless a node (real or null) has been specified,
;	then the node, device and directory fields are ignored.
;
;	If this is a parse of an output file spec, only the filename and type
;	are sticky. (Sticky means they will be defaulted from the related file
;	resultant filename string.)
;
;	Additionally, if the name, type, directory or
;	version of an output file string contains a wild card, this implies
;	an explicit default from the related filename string.
;

;
; This is an output file parse.
; Ignore node, device and logname fields.
; For name and type fields, check for wild card and if so use the RLF field,
; else just use if not already seen.
; For dir and version fields, check for wild card and if so use the RLF field,
; else ignore.
;

	ASSUME	FWA$V_WC_NAME	EQ	<FWA$V_NAME+8>
	ASSUME	FWA$V_WC_TYPE	EQ	<FWA$V_TYPE+8>
	ASSUME	FWA$V_WC_VER	EQ	<FWA$V_VERSION+8>

	BBC	#FAB$V_OFP+FOP,(R8),20$	; if not output file parse
	CMPB	R0,#FWA$V_NODE		; Is this the node?
	BEQL	CHKRTN			; ignore if so
	CMPB	R0,#FWA$V_DEVICE	; Is this the device?
	BEQL	CHKRTN			; ignore if so
	BBSC	R0,1(R10),80$		; Use if wild and make non-wild
	CMPB	R0,#FWA$V_NAME		; is this a name?
	BEQL	50$			; Go default the field if not seen
	CMPB	R0,#FWA$V_TYPE		; is this a type?
	BEQL	50$			; Go default the field if not seen
	BRB	CHKRTN			; Ignore version and dir if not wild

10$:	BRB	CHKERR			; no, signal error

;
; This is an input file parse:
; Ignore version field.
; Use name, type and logname fields if not null.
; Use node, device and directory fields if not null and node not specified.
;

20$:	CMPB	R0,#FWA$V_VERSION	; Is this the version?
	BEQL	CHKRTN			; ignore if so
	CMPB	R0,#FWA$V_LOGNAME	; is this a logical name?
	BEQL	40$			; yep
	CMPB	R0,#FWA$V_NAME		; is this a name?
	BEQL	40$			; yep
	CMPB	R0,#FWA$V_TYPE		; is this a type?
	BEQL	40$			; yep
	BBS	#FWA$V_EXP_NODE,(R10),CHKRTN	; Ignore if node specified
					; Use field if not null

;
; The field is acceptable for use.   Use if not null and not duplicate.
;

40$:	BBS	#FSCB$V_NULL,R6,CHKRTN		; branch if null field
50$:	BBSS	R0,(R10),CHKDUP			; branch if duplicate
						; Else show we have it now ...
;
; Check for directory field and set the overall directory flag if so
;
	TSTB	FWA$B_DIRFLGS(R10)	; Any directory bits set,
	BEQL	60$			;  No - go away
	SSB	#FWA$V_DIR,(R10)	;  Yes - set the dir summary bit


;
; Check for wild card.
;

60$:	BBC	#FSCB$V_WILD,R6,80$	; Branch if field not a wild card
	SSB	#FWA$V_WILDCARD,(R10)	; Set overall flag

	ASSUME	FWA$V_WC_VER	EQ	<FWA$V_VERSION+8>
	ASSUME	FWA$V_WILD_UFD	EQ	<FWA$V_DIR1+8>

	SSB	R0,1(R10)		; Set specific wild card
					; At same bit position in next byte
	TSTB	FWA$B_DIRWCFLGS(R10)	; Any directory wild card bits set,
	BEQL	80$			;  No - go away
	SSB	#FWA$V_WILD_DIR,(R10)	;  Yes - set the wild dir summary bit

;
; If this is a logical name don't copy the string.
;

80$:	CMPB	R0,#FWA$V_LOGNAME	; if this is a logical name then
	BEQL	CPYDSC			;  branch
	PUSHL	R4

	MOVZWL	R6,(R5)+		; store length
	MOVC3	R6,(R7),@(R5)		;  and copy the string

	POPL	R4
CHKSUC:	MOVZBL	#1,R0			; exit to caller with success
	RSB

;
; Don't copy of string since it's a logical name, just save descriptor.
;

CPYDSC:	MOVQ	R6,(R5)			; save descriptor

;
; Return success and string_not_copied
;

CHKRTN:	CLRL	R0			; flag field not copied
	RSB				; return

;
; This field has already been set.
; Ignore it as long as FWA$V_DUPOK is set.
;

	ASSUME	FWA$V_DUPOK	EQ	0

CHKDUP:	BLBS	(R10),CHKRTN

;
; If this is duplicate device because of NAM block input, ignore
; the duplicate.
;

	CMPB	R0,#FWA$V_DEVICE	; Is this a device?
	BNEQ	CHKERR			; Branch if not - solid error
	BBS	#FWA$V_NAM_DVI,(R10),-	; Branch if device came from DVI
		CHKRTN			;  in NAM block, ignoring duplicate
;
; An error has been encountered.
;

CHKERR:	POPL	R0			; pop return pc
	CLRL	R0			; flag error
	RSB				; exit on level up


	.SBTTL	STICKY_DIR, Process Sticky Directories
;++
;
; Functional Description:
;
;	This routine substitutes subdirectories from the RLF name block
;	for wild subdirectories in the expanded directory string.
;	The algorithm is:
;
;		if the output-file directory is in UIC format
;		    replace wild group part with related-file group part
;		    replace wild member part with related-file member part
;
;		if the output-file directory is wild (ie- [*] or [*...] ONLY)
;		    move the entire related-file directory specification
;		    if the related-file directory is in UIC format
;			mark the output-file directory as in UIC format
;
;		if the output-file directory has a trailing ellipsis ("...")
;		    move the entire related-file subdirectory tree starting 
;			from the first wild related-file (sub)directory
;		    if there is no wild related-file (sub)directory, just 
;			remove the ellipsis
;
;		if the output-file directory contains trailing asterisks ("*")
;		    substitute for the trailing asterisks, related-file
;			(sub)directories, starting with the first wild
;			related-file (sub)directory
;
;	Additional Syntax Rules:
;
;	1. No substitution occurs when the output-file directory specification
;	   is in UFD format and partially wild, but there were no wild 
;	   (sub)directories in the related-file directory specification.
;
;	2. Legal wildcards ("*" and "...") can only trail and are mutually 
;	   exclusive.
;
;	3. The format of partially wild output-file directory specifications 
;	   and their related-file directory specifications must be the SAME 
;	   (UFD and UFD or UIC and UIC).
;
; MOVE_RELATED substitutes subdirectories from the related file name
; block for subdirectories in the expanded file name string. The 
; algorithm is as follows:
;
;	1. Get 1st related directory we're supposed to move
;	2. Move it
;	3. While there are related directories move them
;
; Calling Sequence:
;	
;	BSBW	STICKY_DIR
;
; Input Parameters:
;	none
;
; Implicit Input:
;
;	R6 - descriptor of RLF string
;	R7 - descriptor of RLF string
;
;	R8 - fab
;	R10 - fwa
;	R11 - FSCB
;
; Output:
;
;	R0 - STATUS
;
; Implicit Output:
;
;	Wild directory descriptors may be changed to actual values
;	FWA$V_DIR_LVLS is appropriately updated
;	FWA$B_DIRLEN is appropriately updated
;
;	Directory descriptor is replaced with either a related subdirectory
;	descriptor or a series of subdirectory descriptors
;
;	FWA$V_DIR_LVLS is updated to contain the number of directories
;	now in the output-file.
;
;--

	ASSUME	FWA$V_WILD_UFD	EQ	<FWA$V_DIR1+8>
	ASSUME	FWA$B_DIRWCFLGS	EQ	<FWA$B_DIRFLGS+1>

STICKY_DIR:
	PUSHL	R9			; save ifb ptr
	BBC	#FWA$V_WILD_DIR,(R10),- ; If there are no wild directories
		38$			; there is nothing to do so go
					; exit with success

;
;   initialize some variables and obtain the RLF NAM FNB bits
;

10$:	CLRL	R9			; R9 <- index of first wild dir in FWA
	MOVZWL	#FWA$Q_DIR1,R4		; R4 <- disp to directory descriptors
	MOVL	FWA$L_SLBH_PTR(R10),R1	; point to current SLBH

;
; implement the syntax rules restricting partially wild UFD output-file
; directory specifications to UFD formatted related-file directory 
; specifications and partially/totally wild UIC output-file directory
; specifications to UIC formatted related-file directory specifications.
; also, if the output-file directory is totally wild ([*] or [*...]) and the
; related-file directory specification is in UIC format, mark the output-file
; directory specification as being in UIC format.
;

	BBC	#FWA$V_GRPMBR,(R10),20$	; if the output-file is in UIC format
	BBC	#NAM$V_GRP_MBR,-	; but the related-file is not, then
		SLBH$L_NAM_FNB(R1),35$	; go exit with an error
	BRW	80$			; both are in UIC format

20$:	BBC	#NAM$V_GRP_MBR,-	; if the related-file is in UIC format
		SLBH$L_NAM_FNB(R1),30$	;  but the output-file is not, the 
	BBC	#FWA$V_WILD_UFD,(R10),35$; latter must be completely wild
	SSB	#FWA$V_GRPMBR,(R10)	; indicate output-file in UIC format

;
; if the first output-file directory is wild and is the correct type (ie - "*")
; but subdirectories follow, return an error
;

30$:	BBC	#FWA$V_WILD_UFD,(R10),40$; if the first directory is wild,
	BSBW	CHECK_WLD_FIELD		;  it must be of the correct type
	BNEQ	35$			;  and must not be followed by any 
	BBS	#FWA$V_DIR2,(R10),35$	;  directory or it is an error

;
; if the output-file directory is totally wild and of the correct syntax
; (ie [*] or [*...]), setup to substitute and go substitute in the entire
; directory specification of the related-file. if however, the related-file
; directory specification is [] then there are no related (sub)directories
; to transfer, so immediately return success.
;

	BBS	#FSCB$V_NULL,-		; if the related-file is null
		FSCB$Q_DIRECTORY(R11),38$

	CLRB	FWA$B_DIRLEN(R10)	; zero the directory length
	CLRL	AP			; start with the first related subdir
	BRB	55$			; go do it

35$:	BRW	S_ERR

38$:	BRW	S_SUC

;
; The first directory in the output-file is not wild
;
; Find the first wild (sub)directory in the related-file then prepare to
; find the number of trailing asterisks or the position of the trailing
; ellipsis in the output-file directory specification.
;

40$:	FFS	#NAM$V_WILD_UFD,-	; find the offset in the filename bit
		#FWA$C_MAXSUBDIR+1,-	;  field to the first related-file wild 
		SLBH$L_NAM_FNB(R1),R0	;  directory
	SUBL3	#NAM$V_WILD_UFD,R0,AP	; compute index of the RLF wild dir
					; NOTE: AP = MAXSUBDIR+1 if none found
	CLRL	R1			; init wild output directory counter

;
; When an ellipsis is encountered in the scan of the output-file directory
; specification, if legal wildcards had already been encountered ( R1 <> 0)
; or if any subdirectory follows, an error is returned.
; Otherwise, move the related-file directory subtree starting with the first
; wild (sub)directory in the related-file directory specification to the
; output-file directory specification starting at the position of the trailing
; ellipsis.
;

50$:	BBCC	#FSCB$V_ELIPS,(R10)[R4],-
		60$			; look at next dir if no ellipsis
					;  and clear the flags if there is
	TSTL	R1			; error if any wild directories
	BNEQ	35$			; had already been encountered
	INCL	R9			; correct R9 for ellipsis position
	BBS	R9,FWA$B_DIRFLGS(R10),35$	; error if any directory follows
					;  the ellipsis in the output-file

	CMPB	#FWA$C_MAXSUBDIR+1,AP	; if there are no wild related-file
	BEQL	75$			;  (sub)directories, then return success

55$:	MOVZBL	#FWA$C_MAXSUBDIR+1,R4	; transfer as many dirs as required
	BRW	MOVE_RELATED		; go do it


;
; if we have completely scanned the output-file directory specification, we
; go determine how many trailing asterisk were encountered, if any. otherwise,
; we test the next subdirectory to see if its wild. if it is, we go check its
; legality. if it is not, but a wild subdirectory preceeded it, return an 
; error. finally, if the next directory is not wild and no wild subdirectory
; preceeded it, go check whether an ellipsis follows.
;

60$:	INCL	R9			; Offset for next wild dir bit
	ADDL	#8,R4			; Disp for next descriptor

	CMPB	R9,#FWA$C_MAXSUBDIR+1	; if looked at all directories
	BEQL	70$			; then go decide what must be done
	TSTB	(R10)[R4]		; Is descriptor null ?
	BEQL	70$			; Yes - done with out dir

	BBS	R9,FWA$B_DIRWCFLGS(R10),65$ ; if subdir is wild, check its legality
	TSTL	R1			; if subdirectory is nonwild but the
	BEQL	50$			;  preceeding directory was, go return 
63$:	BRW	S_ERR			; an error, else go test for an ...

;
; when a wild subdirectory is encountered its legality is checked. if it is
; of the correct type (ie "*") we continue the scan of the output-file
; directory specification by checking whether an ellipsis follows. otherwise, 
; an error is returned.
;

65$:	BSBW	CHECK_WLD_FIELD		; Is wild dir the legal type ?
	BNEQ	63$			; No  - exit with error
	INCL	R1			; yes - incr wild dir count
	DECB	FWA$B_DIRLEN(R10)	; Decrement the total directory length
	BRB	50$			; continue looking at directories

;
; the entire output-file directory specification has been scanned with
; no trailing ellipis found
;
; if no trailing asterisks were encountered, go return success,
; otherwise, compute the wild directory bit and directory descriptor
; displacements for the first asterisk encountered, and go move the
; required number of related-file directories.
;

70$:	TSTL	R1			; if no trailing wild dirs found
	BEQL	S_SUC			; then return success

;
; if there arn't any wild related-file (sub)directories, then return
;

	CMPB	#FWA$C_MAXSUBDIR+1,AP	; if there are no wild related-file
75$:	BEQL	S_SUC			; then return success

	EXTZV	#FWA$V_DIR_LVLS,-	; extract the number of subdirectory
		#FWA$S_DIR_LVLS,(R10),R9;  levels in the output-file
	SUBL2	R1,R9			; subtract the trailing asterisks
	INCL	R9			; need to add one to get to the subdir
	BRB	110$			; go perform the substitution


;
; for UIC formatted output-file directories, preset the number of the 
; related-file directory to be first to be moved to 0 (the group), the number
; of directories to be moved to 1 (just the group part), and predecrement the
; total directory count appropriately.
;

80$:	CLRL	AP			; preset wild related-file dir # to 0
	MOVL	#1,R1			; preset number of dirs to move to 1
	DECB	FWA$B_DIRLEN(R10)	; decrement total directory length

;
; if the group part of the UIC formatted output-file directory is wild, make 
; sure its of a valid type, and then set the number of subdirectory levels kept
; within the FWA to 0 so that the first directory to be replaced will be the 
; group part of the output-file.
;

	BBC	#FWA$V_WILD_GRP,-	; if group of UIC format output-file 
		(R10),90$		; dir is not wild, go check member part
	BSBW	CHECK_WLD_FIELD		; if wild group part of dir is not
	BNEQ	S_ERR			; valid then return an error

;
; if both the group and member parts of the UIC formatted output-file directory
; specification are wild (ie [*,*]), then make sure both are of the correct 
; type, increment the number of directories to be moved and decrement the 
; directory length appropriately, and then go substitute in both and member 
; parts from the UIC formatted related-file. if just the group part is wild, go
; substitute just the group part from the related-file.
;

	BBC	#FWA$V_WILD_MBR,-	; if output-file dir is not [*,*]
		(R10),110$		; then go setup transfer as is
	ADDL2	#8,R4			; increment dir descriptor displacement
	BSBW	CHECK_WLD_FIELD		; if wild member part of dir is not
	BNEQ	S_ERR			;  restoring saved displacement values
	SUBL2	#8,R4			; restore dir descriptor displacement
	INCL	R1			; increment count of wild directories
	DECB	FWA$B_DIRLEN(R10)	; decrease total directory length
	BRB	110$			; go transfer both group and member


;
; if just the member part of the UIC formatted output-file directory 
; specification is wild, make sure its of the correct type, and that the member
; part of the output-file directory is to be replaced by the member part of the
; the related-file directory specification before going and performing the 
; substitution.
;

90$:	INCL	AP			; related-file member to be transfered
	INCL	R9			; incrm wild bit disp to wild member
	ADDL2	#8,R4			; incrm descriptor to UIC member slot
	BSBB	CHECK_WLD_FIELD		; if wild group part of dir is not
	BNEQ	S_ERR			; valid then return an error

;
; when either UIC formatted output-file directory specifications or partially
; wild directory specifications in UFD formatted are involved, setup to move
; the required number of related-file directories (or directory parts in the
; case of a UIC formatted output-file directory), and go move them. return
; success when the substitution is completed.
;

110$:	MOVL	R1,R4			; number of directories to move
120$:	BRB	MOVE_RELATED		; go do it
	
;
; exit with the appropriate status
;

S_ERR:	RMSERR	DIR			; error
	BRB	S_EXIT

S_SUC:	RMSSUC				; success
S_EXIT:	POPL	R9			; restore ifab
	RSB				; exit

; Working Registers for MOVE_RELATED:
;
;	R4	- number of related subdirectories to move
;	R9	- index of the output subdirectory to start with
;	AP	- index of the related subdirectory to start with
;

MOVE_RELATED:
	CMPB	AP,FSCB$B_DIRS(R11)
	BGEQU	40$

;
; Get the related directory we're supposed to move
;

10$:	CMPB	R9,#FWA$C_MAXSUBDIR		; too many subdirs ?
	BGTRU	S_ERR				; yes - error
	MOVQ	FSCB$Q_DIRECTORY1(R11)[AP],R6	; get the first rlf directory
	ADDB2	R6,FWA$B_DIRLEN(R10)		; accumulate the total length
	BCS	S_ERR				; if overflow the byte

;
; We have to make this a subroutine call since CHECK_FIELD returns
; one level up if there is an error, which is bad news since we
; have pushed registers on the stack in this routine
;

	BSBB	MOVE_REL_FIELD		; copy this field using CHECK_FIELD
	BLBC	R0,S_ERR		; quit on error

	DECL	R4			; decrm # of dirs to move
	BEQL	50$			; exit if no more to be moved

	INCL	AP			; get the next rlf directory index
	CMPB	AP,FSCB$B_DIRS(R11)	; have we moved the last one ?
	BEQL	40$			; yes, exit
	INCL	R9			; get the next output directory
	BRB	10$			;  and continue
	
;
; There may be more related-file subdirectories to move because R9 > 0
; but no related-file subdirectories to move.
;
; This situation can arise because STICKY_DIR requests 8 directories to be
; moved when it encounters a trailing ellipsis, or the output-file directory
; specification consists of [*] or [*...], and because there may be more
; trailing asterisks in the output-file directory specification then there
; are related-file directories to substitute. When the latter case is
; encountered, adjust the number of subdirectories so that FWA$V_DIR_LVLS
; is set correctly remaining asterisks.
;

40$:	ADDL3	#FWA$V_DIR2,R9,R1	; check to see whether there are any
	BBC	R1,(R10),50$		;  trailing output-file directories
	ADDL2	R4,R9			; add what is left from what was
					;  required to be copied

;
; exit with success
;

50$:	BBC	#FWA$V_GRPMBR,(R10),60$	; how do we set lvls?
	SSB	#FSCB$V_GRPMBR,FWA$Q_DIR1(R10)	; reset UIC format flag
	MOVL	#1,R9			; UIC treated as having 2 levels

60$:	INSV	R9,#FWA$V_DIR_LVLS,-	; normal number of subdirs
		#FWA$S_DIR_LVLS,(R10)
	BRB	S_SUC

;
; We have to make this a subroutine call since CHECK_FIELD returns
; one level up if there is an error, which is bad news since we
; have pushed registers on the stack in this routine
;

MOVE_REL_FIELD:
	SSB	R9,FWA$B_DIRWCFLGS(R10)	; set wild dir bit
	ADDL3	#FWA$V_DIR1,R9,R0	; subdirectory field
	MOVZBL	#FWA$C_MAXNAME,R1	; maximum directory size
	MOVAQ	FWA$Q_DIR1(R10)[R9],R5	; directory descriptor
	BSBW	CHECK_FIELD		; move this directory
	MOVZBL	#1,R0			; returning here is ok
	RSB


;
; CHECK_WLD_FIELD
;
; This subroutine checks a wild field in the FWA (directory, subdirectory,
; subdirectory part in the case of UIC formatted directories, filename, or
; type) to make sure that it is in legal format. Legal format is "*" and 
; only "*".
;
; Input Parameters:
;
;	R4	- offset to field descriptor, the contents of which
;		  are to be checked for wild validity
;	R10	- fwa
;
; Output:
;
;	V bit	- SET	if descriptor contains a legally formatted wild field
;		  CLEAR	otherwise
;
;	R0	- destroyed
;

CHECK_WLD_FIELD:
	ADDL3	R4,R10,R0		; address of descriptor
	CMPW	#1,(R0)			; check size
	BNEQ	10$			; bad
	CMPB	#^A/*/,@4(R0)		; right character
10$:	RSB				;

	.END				; End of module
