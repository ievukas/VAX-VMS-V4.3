	.TITLE	LNMSUB - LOGICAL NAME RELATED SUBROUTINES
	.IDENT	'V04-000'
 
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; LOGICAL NAME RELATED SUBROUTINES ( REPLACES LOGNAMSUB MODULE )
;
; David W. Thiel    29-Oct-1982
;
; MODIFIED BY:
;
;	V03-031	RAS0330		Ron Schaefer		31-Jul-1984
;		Fix basic name lookup algorithm so that case blind
;		lookups can find lower case names.
;
;	V03-030	ACG0440		Andrew C. Goldstein,	24-Jul-1984  10:36
;		Add ref count field to ORB
;
;	V03-029	LMP0275		L. Mark Pilant,		12-Jul-1984  20:03
;		Initialize the ACL info in the ORB to be a null descriptor
;		list rather than an empty queue.  This avoids the overhead
;		of locking and unlocking the ACL mutex, only to find out
;		that the ACL was empty.
;
;	V03-028	RAS0319		Ron Schaefer			29-Jun-1984
;		Add a simple logical name table name translation cache
;		to the recursive table name lookup algorithm in order to
;		(hopefully) improve the performance of logical name processing.
;		The methodology is as follows:
;
;		In per-process space, there exists a small queue of fixed-len
;		entries that contain a table name LNMB addr, a process and
;		system directory incarnation sequence number and upto
;		LNMC$K_NUM_ENTRIES worth of table header (LNMTH) addresses
;		that are the recursive tables identified by that table name.
;		When doing a table lookup; 
;		We lookup the table name
;		normally.  We then check the cache for a matching LNMB.
;		If there is a cache entry and the directory incarnation numbers
;		are still valid, then we use the vector of LNMTH entries
;		rather than looking them up by name.	
;		If no valid cache entry is found, we take the LRU cache
;		entry, initialize it for this name and use the normal
;		table lookup procedures, except that as a table header is
;		found, we store it's address in the cache entry for future
;		reference.
;		If we use up all cache entries before finding the correct
;		table, the cache entries will run out.  In that case, we
;		reset the cache index to start building a new cache entry
;		table from the beginning since it is impossible to relate
;		a given cache entry back to the corresponding name.
;		If the number of table entries, exceeds the cache table size
;		then we give up and do things the slow way.
;
;	V03-027	RAS0316		Ron Schaefer			25-Jun-1984
;		Add new LNM$DELETE_HASH routine to delete all logical names
;		within a given hash table and having a given or outer
;		access mode.  This is ECO 4 in the FT2 update.
;
;	V03-026	RAS0312		Ron Schaefer			18-Jun-1984
;		Prevent accvio in searching tables if no process logical
;		name table/hash table/directory has been created.
;		Fix alignment of ORB block in table.
;
;	V03-025	TMK0018		Todd M. Katz			24-Apr-1984
;		Change the name of the logical name mutex from LOG$AL_MUTEX
;		to LNM$AL_MUTEX.
;
;	V03-024	TMK0017		Todd M. Katz			21-Apr-1984
;		I have changed the interface to the routine LNM$DELETE_LNMB.
;		This routine is now called with the logical name block it is
;		to delete together with all of the outer access mode aliases
;		of the logical name represented by the logical name block. 
;		Previously the interface to this routine consisted of it being
;		called with a logical name descriptor, containing table header
;		address, and the access mode of the innermost logical name
;		to be deleted, despite the fact that the calling routine always
;		had the logical name block for the innermost access mode logical
;		name to be deleted.
;
;		Make LNM$DELETE a local routine. This routine is only called by
;		the routines within this module.
;
;		The performance measurement cell used to monitor the rate of 
;		logical name translations is currently located within the 
;		internal logical name routine LNM$SEARCHLOG. Unfortunately,
;		because of its current placement, any attempts to delete 
;		specific logical names will also increment this counter. This
;		is because the system service $DELLNM will call the routine 
;		LNM$SEARCHLOG in such a situation. Therefore, in order to be
;		able to make a more accurate measurement of the overall rate
;		of logical name translations, I have decided to move this 
;		performance measurement cell from its current single location
;		to several more appropriate locations. One of these new 
;		locations is within the internal routine LNM$SEARCH_ONE just 
;		before the call to LNM$SEARCHLOG.
;
;	V03-023	CWH3023		CW Hobbs			14-Apr-1984
;		Fix a broken branch.
;
;	V03-022	TMK0016		Todd M. Katz			11-Apr-1984
;		Make a change to DELETE_LNMB such that when this routine is 
;		called to delete a shareable logical name table and its 
;		associated Object Rights Block, it cleanups up the ORB first 
;		before deleting the logical name block and ORB. 
;
;	V03-021	TMK0015		Todd M. Katz			10-Apr-1984
;		Change LNM$SEARCH_ONE to position past all translation blocks
;		with negative indexes (ie - those reserved for system use) to 
;		the first translation block with a non-negative index or to the 
;		last translation block, whichever comes first. If the 
;		translation block positioned to is not the last one and has an
;		index of 0, then return success together with the contents of
;		the entire translation block in the user supplied buffer. 
;		Otherwise, return an error of SS$_NOLOGNAM.
;
;	V03-020	TMK0014		Todd M. Katz			02-Apr-1984
;		I have made the following optimizations and bug fixes to the
;		routines within this module.
;
;		1. I have changed how LNMBs are ordered within a hash bucket
;		   both to increase performance and to fix a problem in hash
;		   bucket searching. The new ordering is first by name string
;		   length, then my name string, then by containing table header
;		   address, and finally by access mode. Previously, the LNMBs 
;		   were ordered by access mode before containing table header
;		   address. 
;
;		   What this new ordering gains is the ability to use the
;		   containing table header address in determining when searches,
;		   such as those directed by LNM$SEARCHLOG, should terminate for
;		   a current containing table header address. With the old 
;		   ordering, containing table header addresses could not be used
;		   to terminate a search. Even if the target LNMB was not found
;		   among the user mode LNMBs, the search would still have to 
;		   continue with the supervisor, executive, and kernel mode 
;		   LNMBs. Basically, this meant ignoring the ordering of LNMBs 
;		   by containing table header addresses. Unfortunately, this 
;		   "ignoring" was not being done, and this resulted in the 
;		   inability to find certain logical names even though they were
;		   present. When I changed the ordering of LNMBs within the hash
;		   bucket, not only did I gain the ability to use the ordering 
;		   of LNMBs by containing table header addresses to terminate a
;		   search, and thus increase performance,  but at the same time 
;		   I eliminated this particular problem which was causing 
;		   certain $TRNLNMs to fail when they should have succeeded.
;
;		2. The routine LNM$CONTSEARCH makes the assumption that when
;		   it is directly called, NT_L_THREAD contains the address
;		   of the previous LNMB block, and the search is to continue
;		   with the LNMB which follows it. If there is no possibility
;		   that the contents of the hash bucket could have changed since
;		   the last search was done, then the name string of the first 
;		   LNMB this routine looks at, the one pointed at by the LNMB 
;		   whose address is contained within NL$L_THREAD, is guarenteed 
;		   to match the target name string. Therefore, there is no need 
;		   to make the string comparison which is normally done because 
;		   the outcome is already known, and in fact, an increase in 
;		   performance can be realized if the execution of this CMPC3
;		   is eliminated.
;
;		   What I have done is define a bit NT_V_MODIFY within the
;		   NT_B_FLAGS field of the translation block. This bit is
;		   set as part of the initialization of a name translation
;		   block whenever the possibility exists that LNM$CONTSEARCH 
;		   maybe called after modifying the sequence of LNMBs residing 
;		   within a hash bucket. At the present two routines, 
;		   LNM$INSLOGTAB and LNM$DELETE_LNMB, set this bit as part of
;		   the process of allocating and initializing their name
;		   translation blocks. When LNM$CONTSEARCH notices that this bit
;		   is clear it skips the initial CMPC3 assuming that the name
;		   strings are equivalent. Only this initial CMPC3 can be 
;		   skipped - all remaining string comparisons are required and
;		   are performed as is found to be necesary.
;
;		3. I have also made numerous micro-optimizations to the routine
;		   within this module.
;
;		4. I have changed this module to use the symbol LNM$C_MAXDEPTH 
;		   to define the maximum logical name recursion depth instead
;		   of the local symbol RT_C_MAXDEP.
;
;		5. I have made two changes to LNM$SEARCH_ONE. Before calling 
;		   LNM$LOCKR to lock the logical name mutex for reading, this 
;		   routine saves the current IPL on the stack, and then restores
;		   IPL to this value after unlocking the logical name mutex by 
;		   calling LNM$UNLOCK. This change is required because LNM$LOCKR
;		   exits with IPL set to IPL$_AST, and therefore, IPL may have
;		   to be set back to its inital value before LNM$SEARCH_ONE 
;		   exits. The reason why IPL is not lowered until after 
;		   LNM$UNLOCK returns is that the mutex locking and unlocking 
;		   routines make the assumption that IPL does not fall below
;		   IPL$_AST while the current process has the mutex locked.
;
;		   The second change I have made is a bug fix. LNM$SEARCH_ONE
;		   was checking access to process-private logical name tables
;		   when the logical name found was contained within one of them.
;		   Such a check is un-necessary, and in fact must not be done.
;		   Such tables do not have an Object Rights Block associated 
;		   with them, and LNM$CHECK_PROT will accvio if it is called 
;		   with a table header that does not have an associated ORB.
;
;		6. I have fixed a day-one implementation problem in LNM$HASH
;		   that was making the hashing routine sensitive to the 
;		   alignment of the address of the string this routine is
;		   supposed to hash (and why this was ever working I'll never
;		   know). What LNM$HASH should have been doing, and does now is:
;
;		   1.) Save the number of bytes in the string.
;		   2.) Divide the number of bytes in the string by 4.
;		   3.) Process the string, four bytes at a time, to compute the 
;		       hash code.
;		   4.) Retrieve the string size, and use the low-order two bits,
;		       in effect the remainder from the integer division in 1.),
;		       to determine how many bytes of the string have not yet
;		       participated in the computation of the hash code, and to
;		       direct their participation.
;		   5.) Complete computation of the hash code.
;
;		   In step 1.), instead of saving the number of bytes in the 
;		   string, LNM$HASH was saving the string address. This made
;		   the computation of the hash code sensitive to the alignment
;		   of the string address passed to it. Inotherwards, if the
;		   name string FOO was presented to LNM$HASH as being at address
;		   500 at one time, and as being at address 601 a second time, 
;		   the two hash code values determined for FOO would be 
;		   different - an extremely serious problem. A given name must
;		   always hash to a constant value.
;
;	V03-019	TMK0013		Todd M. Katz			30-Mar-1984
;		Modify the logical name system services to make use of the 
;		updated internal protection checking mechanisms. What this
;		requires is modification to the routine LNM$INIT_PROT, so that
;		it initializes a quad-word aligned Object Rights Block for 
;		shareable logical name tables in place of an un-aligned CHIP 
;		protection template, and a modification to the routine
;		LNM$CHECK_PROT, so that it makes use of the new internal 
;		check protection system service interface.
;
;	V03-018	TMK0012		Todd M. Katz			22-Mar-1984
;		Fix a bug in logical name table processing. When a translation
;		has the attribute TERMINAL, the translation string must be the
;		the name of a logical name table, and LNM$TABLE remembers this
;		for the next level of recursion by setting the bit RT_V_TERM
;		within the RT_B_FLAGS field of the table recursion control 
;		block. If the translation string is the name of a logical name
;		table then LNM$TABLE makes a successful exit with this bit
;		still set within the recursion control block. Then if for
;		some reason LNM$TABLE is called once more to continue the
;		recursion and find the next table, because RT_V_TERM has not
;		been cleared, LNM$TABLE will immediately and incorrectly exit 
;		with an error of SS$_IVLOGTAB. The fix to this problem is to 
;		unconditionally clear this bit on entry to LNM$TABLE. 
;
;	V03-017	TMK0011		Todd M. Katz			21-Mar-1984
;		Make LNM$PRESEARCH, LNM$CONTSEARCH, LNM$SETUP, and LNM$TABLE
;		global, so that they maybe used by SHOW LOGICAL.
;
;	V03-016	TMK0010		Todd M. Katz			07-Mar-1984
;		Logical name table name processing is recursive. A table
;		name is provided, and the corresponding logical name block is 
;		located, if one exists, by hashing the name and looking for the
;		logical name block within the indicated hash buckets (first 
;		searching the process-private name space and then searching the 
;		system name space). If the logical name block exists, and it is 
;		for a logical name table, then table processing terminates. 
;		Otherwise, this procedure is repeated, in turn, for each of the 
;		logical name's translations and for each of the translation's 
;		translations, etc... until the first logical name table is 
;		located, or until all possible translation paths have been 
;		exhausted.
;
;		I have added an optimization to this recursive logical name 
;		table name processing. This optimization consists of storing 
;		the hash code value of each equivalence string within the 
;		corresponding translation block. Because the very first step in 
;		each recursive logical name block lookup is the hashing of the 
;		target block's name string in order to provide the hash buckets 
;		in which to concentrate the search, already having the 
;		appropriate hash code means that this step of a logical name 
;		block lookup maybe by-passed. 
;
;		There are two exceptions to this optimization which will require
;		the target block's name to be hashed during a recursive logical 
;		name block lookup. First, the target block's name will have to 
;		be hashed during the very first recursive logical name block 
;		lookup. This is because the hash value of this name string isn't
;		available. Secondly, because there is no way to distinquish 
;		between a valid hash code of 0, and the total absence of a hash 
;		code, this means that whenever one of these stored hash code 
;		values is 0, the equivalence string within the corresponding 
;		translation block will end up being hashed anyway during the
;		lookup of the target logical name block.
;
;		The modifications which are required in order to implement this
;		feature are as follows:
;
;		1. Increase the size of the fixed portion of each translation
;		   block by a word in both logical names and logical name
;		   tables. This word may potentially contain the translation
;		   string's hash code value.
;
;		2. Initialize this new field of each translation block with the
;		   hash code value of the corresponding equivalence string 
;		   provided the translation block is part of a logical name
;		   (and not a logical name table) contained within a directory
;		   table. It is these names, and only these names, which are
;		   utilized in logical name table name processing, and thus,
;		   only these names have to have the hash code values of their
;		   equivalence strings computed and stored appropriately. 
;
;		   The routine LNM$INSLOGTAB has been modified to perform this 
;		   initialization whenever it determines that the logical name 
;		   block it is inserting is for a logical name contained within
;		   the process or system directory logical name table.
;
;		3. The routine LNM$LOOKUP has been modified, so that it takes 
;		   as additional input the hash code value of name string of the
;		   target logical name block this routine is to look up. This 
;		   hash code value is placed into the hash function field of a 
;		   name translation control block. This will result in the 
;		   by-passing of the determination of the hash code value of the
;		   name string whenever the inputed hash code value is non-zero.
;
;		4. The routine LNM$TABLE has been modified, so that the hash 
;		   code value of the name string of the next target logical name
;		   block is extracted from the translation block containing the 
;		   name string. This hash code value, together with the name 
;		   string, is then passed to LNM$LOOKUP forcing by-passing of  
;		   the determination of the hash code value of the name string 
;		   of the next target logical name block during its lookup.
;
;		5. Finally, a modification has been made to LNM$SETUP, the 
;		   routine responsible for setting up and initialization the
;		   recursive logical name table name processing. Because the
;		   hash code of the name string of the initial target logical
;		   name block is not available, this routine must zero out the
;		   register in which LNM$LOOKUP expects to find the hash code 
;		   of the logical name block it is to lookup. This will force
;		   the hash code value of this name string to be determined,
;		   which is proper since LNM$SETUP doesn't have it anyway.
;
;	V03-015	RAS0255		Ron Schaefer			17-Feb-1984
;		Make LNM$M_CASE_BLIND work for DEC multinational characters.
;
;	V03-014	TMK0009		Todd M. Katz			03-Feb-1984
;		If LNM$FIRSTTAB is unable to find an existing logical name 
;		table within the input list of logical name tables names, 
;		return an error of SS$_NOLOGTAB instead of an error of 
;		SS$_NOLOGNAM.
;
;	V03-013	TMK0008		Todd M. Katz			29-Dec-1983
;		Add the global routine LNM$DELETE_LNMB which takes as input
;		the address of a table header, a descriptor of the name of a
;		logical name table entry, and an access mode and deletes all
;		instances of the logical name table entry within the specified
;		logical name table at all access modes outer and equal to that
;		of the specified access mode.
;
;		Add the global routine LNM$SEARCH_ONE which takes as input:
;
;		1. A descriptor of a logical name table name.
;		2. A descriptor of a logical name.
;		3. A descriptor of an output buffer.
;		4. The PCB address. 
;		5. An access mode.
;
;		This routine simulates a $TRNLNM returning a copy of the LNMX 
;		translation block for translation index 0 in the specified 
;		output buffer provided a logical name is found, and the found
;		logical name has a translation with an index of 0. This routine 
;		does NOT do any type of arguement verification.
;
;		Make a small modification to DELETE_NAMES and LNM$DELETE
;		so that the directories, process and system, can never be
;		either explicitely or implicitely deleted. Also, return an
;		error from within LNM$INSLOGTAB if the caller attempted to 
;		create a logical name table entry within one of the directories 
;		with the same name and access mode as the directory itself.
;		This is done by never allowing a LNMB which has the 
;		LNMB$V_NODELETE bit set within its LNMB$B_FLAGS field from being
;		deleted, and as the directory tables are the only tables that
;		are created with this attribute, this protects the directory 
;		tables, and only the directory tables, from being deleted.
;
;		Make the global routines LNM$PRESEARCH, LNM$CONTSEARCH, 
;		LNM$LOOKUP, LNM$SETUP, AND LNM$TABLE local routines.
;
;	V03-012	TMK0007		Todd M. Katz			27-Dec-1983
;		LNM$INIT_PROT was clearing the member field of the CHIP template
;		UIC if the logical name table whose CHIP template was being 
;		inited was a group table. This is no longer necessary because 
;		group tables are now handcrafted, and can not be created by 
;		means of the $CRELNT system service.
;
;	V03-011	TMK0006		Todd M. Katz			14-Dec-1983
;		Make a change to recursive table lookup processing implemented
;		within the routine LNM$TABLE. Currently when the lookup of a 
;		name fails it also terminates the recursive search for a logical
;		name table. The change is to not have a name lookup failure 
;		automatically terminate a table lookup. Instead when the lookup
;		of a translation string fails, processing continues with the
;		next translation and an attempt is made to lookup its string. 
;		Conceptually what this means is that non-existant logical name
;		tables in a list of logical name table names are "skipped over"
;		during the search for valid logical name tables. Currently, what
;		would happen is that such a search for valid tables will
;		immediately terminate with an error when the first non-existant
;		table was encountered in the list of logical name table names.
;
;		Also, change some PUSHRs into PUSHLs (or MOVQs) and POPRs into
;		POPLs (or MOVQs) where appropriate for performance reasons.
;
;	V03-010	TMK0005		Todd M. Katz			26-Oct-1983
;		Quota handling when logical name tables are being created or
;		deleted is presently incorrect. Currently, when a logical name 
;		table is created, quota consisting of the size of the new 
;		logical name table plus any quota explicitely allocated to the 
;		new table is subtracted from the quota holder of the parent 
;		logical name. When a logical name table is deleted, the reverse 
;		of this quota deduction takes place. This deduction scheme is 
;		consistant but incorrect, and I have changed it by modifying 
;		DELETE_LNMB and LNM$INSLOGTAB as follows:
;
;		When a logical name table is created, any quota explictely 
;		allocated to the new table is deducted from the parent table's 
;		quota holder as was previously being done; however, the size
;		of the new table itself is deducted from the quota holder of the
;		table that contains it (either the system or process directory
;		table). This is consistent with how logical names are handled,
;		and the philosophy that logical name tables are just logical
;		names with a special translation. When a logical name table is
;		deleted, the reverse of these two deductions takes place.
;
;		I have also removed the code for LNM$INSLOGN, LNM$TRANSLOGNAME,
;		and LNM$TRANSLATE. These routines are never called, and have 
;		been commented out for months.
;
;	V03-009	ACG0354		Andrew C. Goldstein,	12-Sep-1983  21:55
;		Change RWACCESS field in CHIP$ block to FLAGS field
;
;	V03-008	TMK0004		Todd M. Katz			31-Aug-1983
;		At the present time logical name blocks in each hash bucket are 
;		ordered first by logical name size, then by access mode, then 
;		alphabetically, by logical name, and finally by containing 
;		table. The ordering of logical name blocks by access mode 
;		before alphabetically meant that a supervisor mode "d" logical
;		name block would be found in the same hash bucket before an 
;		executive mode "c" logical name block, and the explicit search
;		for "c" with the starting access mode specified as user or 
;		supervisor would stop when the "d" logical name block was 
;		encountered before the "c" was seen. Thus, "c" would never be
;		located unless an explicit search for an executive mode "c"
;		was initiated. This represented an error and is basically due
;		to the fact that searches for an explicit logical name are 
;		performed for names at the given and inner access modes, while
;		the search process itself will stop as soon as a logical name
;		is encountered that collates higher than the logical name being
;		searched for, regardless if the name being searched for exists
;		at an inner access mode then the logical name block that
;		terminates the search. To fix this problem I have changed how
;		logical name blocks are ordered within a hash bucket. Logical
;		name blocks are now ordered first by the size of the logical 
;		name, then alphabetically by logical name, then by access mode 
;		of the logical name, and finally by the containing table's 
;		table header address.
;
;	V03-007	TMK0003		Todd M. Katz			09-Aug-1983
;		If LNM$INIT_PROT has been called to initialize the CHIP
;		protection template for a group logical name table (as
;		signalled by the setting of the bit LNMTH$V_GROUP), then zero
;		the member portion of the owner UIC field of the CHIP template
;		so that the group table does not have an owner.
;
;		Modify the routine LNM$CHECK_PROT so that it will grant access
;		to a logical name table, even when the caller would otherwise be
;		refused access based upon SOGW access protection, in two special
;		circumstances. First, if the logical name table is a group
;		logical name table (LNMTH$V_GROUP is set), the caller has the
;		GRPNAM privilege, the group logical name table is the caller's
;		group logical name table, and the caller has requested R or W
;		access to the table only, then return success granting access
;		to the table. Second if the logical name table is the system
;		logical name table (LNMTH$V_SYSTEM is set), the caller has the
;		SYSNAM privilege, and the caller has requested R or W access to 
;		the table only, then return success granting access to the 
;		table. These changes are required for compatibility reasons so
;		that access to the system and group tables is governed by the
;		same privileges across releases.
;
;		Comment out the unused routine LNM$INSLOGN.
;
;	V03-006	RAS0165		Ron Schaefer		 5-Jul-1983
;		Correct RAS0158 and RAS0160 to ignore the caller's
;		access mode in the CHIP protection checking since the
;		logical name code uses a non-standard interpretation of
;		access mode.
;
;	V03-005	LMP0125		L. Mark Pilant,		26-Jun-1983  21:54
;		Change all referneces of CHIP$B_ACCESSOR_MODE to be
;		CHIP$L_ACCESSOR_MODE.
;
;	V03-004	RAS0160		Ron Schaefer			16-Jun-1983
;		Add access mode of table to CHIP block and move
;		performance measurement cell to LNM$SEARCHLOG.
;
;	V03-003	RAS0158		Ron Schaefer			25-May-1983
;		Add protection checking support subroutines LNM$INIT_PROT
;		to initialize the CHIP block for a table and LNM$CHECK_PROT
;		to check references to a table.
;
;	V03-002	TMK0002		Todd M. Katz			25-Apr-1983
;		Fix several more bugs in these subroutines. The most 
;		significant fix is one to LNM$SEARCHLOG. As this routine
;		locates the logical name tables in the list of such tables,
;		it searches for the presence of the given logical name within
;		them until a match is found. If the current logical name table
;		in the list of tables is shareable, only the shareable name
;		space is looked at for a match; likewise, if the current logical
;		name table is process-private, only the process-private name 
;		space is referenced. The code that was making the distinction
;		between these two cases was incorrect, the result being that
;		the process-private name space was always being searched.
;		Furthermore, the code was incorrect in that processing of the
;		current table should be skipped if there is no name in the
;		same name space as the table itself. This was not being done
;		and allowed the possibility for access violations to occur. 
;
;		In addition, fix the quota check in LNM$INSLOGN. The branch
;		following this check was signed, and it should have been
;		unsigned.
;
;		Also, increase the maximum recursion depth from 8 to 10.
;
;	V03-001	TMK0001		Todd M. Katz			25-Mar-1983
;		Fix several bugs in these subroutines:
;
;		1. The PCB is only required on calls to LNM$TRNSLOGNAME, 
;		   LNM$TRANSLATE, LNM$LOCKR, LNM$LOCKW, and LNM$UNLOCK. 
;	 	   Therefore, remove the requirement that it be present in R4
;		   from all routines except for the above mentioned five.
;
;		2. When allocating and filling in the Recursive Table Name
;		   Control Block within LNM$FIRSTTAB and within LNM$SEARCHLOG, 
;		   use a MOVZWL instead of a MOVZBL to fill in the access mode 
;		   and set the case control bit because the latter occupies 
;		   the first bit of the second byte of the source operand.
;
;		3. The table header of the process or system directory table is
;		   supposed to go in the TABID Field of the Name Translation
;		   Block when a table name is to be looked up by calling 
;		   LNM$LOOKUP. This routine was placing the address of the table
;		   instead of the address of the table header in this field.
;
;		4. I have restructured the routine LNM$TABLE as follows: This
;		   routine now saves the address of the translation block it is
;		   working on in the Recursive Table Control Block before it
;		   looks up the translation string in the hash tables. The
;		   one exception is the original table name which is looked
;		   up without being saved. This allows continuation down the
;		   translation blocks of eight logical name blocks until a
;		   table is found as long as the names being looked up are in 
;		   fact found. Previously, this information saving was being
;		   done incorrectly, and at the wrong time. This meant that
;		   the routine could not pick up and continue with the next
;		   translation block after the current translation thread
;		   dead ended.
;
;		5. I have restructured the routine LNM$CONTSEARCH as follows.
;		   As this routine is processing the LNMB Blocks within the 
;		   current hash bucket it keeps the address of the previous
;		   LNMB within the THREAD cell of the Name Translation Control
;		   Block while the address of the LNMB it is working on is 
;		   always in R1. Then whenever this routine exits, regardless
;		   of the status it exits with, R1 will always contain the 
;		   address of the LNMB Block that stopped the search (or 0 if
;		   the list was exhausted) and NT_L_THREAD contains the address
;		   of the previous LNMB block. This provided sufficient 
;		   information to allow new LNMB blocks to be inserted in the 
;		   correct place regardless of where that place is.
;
;		   In addition this routine was performing a CMPC3, and then
;		   checking the state of a bit within a field pointed at by R3
;		   to determine whether the comparison is to be made case 
;		   sensitive or blind. Of course, the CMPC3 changes R3, so this
;		   check must be made using the original contents of R3 which 
;		   have been stored on the stack.
;
;		6. I have re-written LNM$INSLOGTAB. There were many problems
;		   with the old routine including the inability to correctly
;		   find the table header of the new table entry, an inability 
;		   to just map a new entry to an existing entry when CREATE_IF 
;		   had been specified, and the way in which new entries were 
;		   linked into the exisiting list of entries within a hash 
;		   hash bucket was completely incorrect.
;
;		7. I have have re-written the routine DELLNMB as DELETE_LNMB,
;		   the routine DELTAB as DELETE_NAMES, the routine LNM$DELETE,
;		   and the routine LNM$DELTAB as LNM$DELETE_TAB. I have changed
;		   the name of DEL1 to DELETE_ENTRY, added the routine 
;		   DELETE_TABLE, and eliminated the routine LNM$DELHASH.
;
;		9. The status SS$_EXLNMQUOTA is returned instead of SS$_EXQUOTA.
;
;	       10. Put the names of the routines on the subtitles.
;
;	       11. The routine LNM$SEARCHLOG was incorrectly searching for a 
;		   logical name. This routine first ascertains that the logical
;		   name exists at all, and then searches among the possible 
;		   logical name tables one-by-one until it finds the first 
;		   table that contains such a logical name. The first time this
;		   routine encountered a process-private table, it would 
;		   return success even if the table did not contain the logical
;		   name. This was due to a slight mistake in the ordering of 
;		   some of the instructions which has been corrected.
;
;	       12. Re-write LNM$INSLOGN.
;--


	.SBTTL	DATA DEFINITIONS

;
; MACRO LIBRARY CALLS:
;
 
	$ARMDEF				;DEFINE ACCESS RIGHTS MASK
	$CADEF				;DEFINE CONDITIONAL ASSEMBLY SWITCHES
	$CHPCTLDEF			;DEFINE CHIP PROTECTION CONTROL BLOCK OFFSETS
	$DYNDEF				;DEFINE STRUCTURE TYPE AND SUBTYPE CODES
	$LNMDEF				;DEFINE LOGICAL NAME ATTRIBUTES
	$LNMSTRDEF			;DEFINE LOGICAL NAME BLOCKS OFFSETS
	$ORBDEF				;DEFINE ORBJECT RIGHTS BLOCK OFFSETS
	$PCBDEF				;DEFINE PCB OFFSETS
	$PRVDEF				;DEFINE PRIVILEGE MASK OFFSETS
	$PSLDEF				;DEFINE PROCESSOR STATUS FIELDS
	$SSDEF				;DEFINE SYSTEM STATUS VALUES

;
; ASSUMPTIONS ABOUT THE STRUCTURE AN OBJECT RIGHTS BLOCK AND A CHPCTL:
;

	ASSUME	ORB$L_OWNER,	   EQ,	0
	ASSUME	ORB$L_OWNER+4,	   EQ,	ORB$L_ACL_MUTEX
	ASSUME	ORB$L_ACL_MUTEX+4, EQ,	ORB$W_SIZE
	ASSUME	ORB$W_SIZE+2,	   EQ,	ORB$B_TYPE
	ASSUME	ORB$B_TYPE+1,	   EQ,	ORB$B_FLAGS
	ASSUME	ORB$B_FLAGS+3,	   EQ,	ORB$W_REFCOUNT
	ASSUME	ORB$W_REFCOUNT+2,  EQ,	ORB$Q_MODE_PROT
	ASSUME	ORB$Q_MODE_PROT+8, EQ,  ORB$L_SYS_PROT
	ASSUME	ORB$L_SYS_PROT+4,  EQ,	ORB$L_OWN_PROT
	ASSUME	ORB$L_OWN_PROT+4,  EQ,	ORB$L_GRP_PROT
	ASSUME	ORB$L_GRP_PROT+4,  EQ,	ORB$L_WOR_PROT
	ASSUME	ORB$L_WOR_PROT+4,  EQ,	ORB$L_ACL_COUNT
	ASSUME	ORB$L_ACL_COUNT+4, EQ,	ORB$L_ACL_DESC
	ASSUME	ORB$L_ACL_DESC+4,  EQ,	ORB$R_MIN_CLASS
	ASSUME	ORB$R_MIN_CLASS+ORB$S_MIN_CLASS,-
				   EQ,	ORB$R_MAX_CLASS
	ASSUME	ORB$R_MAX_CLASS+ORB$S_MAX_CLASS,-
				   EQ,	ORB$K_LENGTH

	ASSUME	CHPCTL$L_ACCESS,    EQ,	0
	ASSUME	CHPCTL$L_ACCESS+4,  EQ,	CHPCTL$L_FLAGS
	ASSUME	CHPCTL$L_FLAGS+4,   EQ, CHPCTL$B_MODE
	ASSUME	CHPCTL$B_MODE+4,    EQ, CHPCTL$C_LENGTH
;	.PAGE

;*******************************************************************************
;
; THIS CONTROL BLOCK IS ALSO LOCALLY DEFINED IN THE SHOW LOGICAL UTILITY
; ANY CHANGES TO THIS DATA STRUCTURE MUST BE REFLECTED IN SHOW LOGICAL AS WELL.
;
;*******************************************************************************

;
; BLOCK TO CONTROL RECURSIVE TABLE NAME TRANSLATION
;
;	 31           25 24           16 	     9 8 7             0
;	+---------------+---------------+---------------+---------------+
; R5 -> | TRIES		| DEPTH		|	     T C| ACCESS MODE	|
;	+---------------+---------------+---------------+---------------+
;	|		ADDRESS OF NAME BLOCK				|
;	+---------------+---------------+---------------+---------------+
;	|								|
;	|	LNM$C_MAXDEPTH LONGWORDS TO SERVE AS STACK		|
;	|								|
;	|								|
;	+---------------+---------------+---------------+---------------+
;
;	F IS SET TO INHIBIT FURTHER RECURSION
;
RT_W_R5=	0
RT_B_ACMODE=	0
RT_B_FLAGS=	1
RT_V_CASE=	8			;CASELESS FLAG
RT_M_CASE=	^X1			;CASELESS MASK
RT_V_TERM=	9			;INHIBIT RECURSION FLAG
RT_M_TERM=	^X2			;INHIBIT RECURSION MASK
; BIT NUMBER 10 IS RESERVED.

RT_B_DEPTH=	2			;RECURSION DEPTH
RT_B_TRIES=	3			;RECURSION TRIES
RT_C_MAXTRIES=	255			;MAXIMUM NUMBER OF TRIES
RT_L_CACHEPTR=	4			;POINTER TO CACHE ENTRY
RT_L_STACK=	8
RT_K_LENGTH=	RT_L_STACK+<4*LNM$C_MAXDEPTH>	;BLOCK LENGTH

;	.PAGE

;*******************************************************************************
;
; THIS CONTROL BLOCK IS ALSO LOCALLY DEFINED IN THE SHOW LOGICAL UTILITY
; ANY CHANGES TO THIS DATA STRUCTURE MUST BE REFLECTED IN SHOW LOGICAL AS WELL.
;
;*******************************************************************************

;
; BLOCK TO CONTROL NAME TRANSLATION
;
;	 31           25 24           16 15        A   8 7             0
;	+---------------+---------------+---------------+---------------+
; R3 -> | HASH FUNCTION VALUE OR 0	| 	   M   C| ACCESS MODE	|
;	+---------------+---------------+---------------+---------------+
;	| 			LENGTH OF NAME				|
;	+---------------+---------------+---------------+---------------+
;	|			ADDRESS OF NAME				|
;	+---------------+---------------+---------------+---------------+
;	|		TABLE HEADER ADDRESS OR 0			|
;	+---------------+---------------+---------------+---------------+
;	|		NAME BLOCK ADDRESS OR 0				|
;	+---------------+---------------+---------------+---------------+
;
;

NT_W_R5=	0
NT_B_ACMODE=	0
NT_B_FLAGS=	1
NT_M_CASE=	1			;CASELESS MASK
NT_V_CASE=	8			;CASELESS FLAG
; BIT NUMBER 9 IS RESERVED.
NT_M_MODIFY=	4			;HASH BUCKET SUSCEPTIBLE TO CHANGE MASK
NT_V_MODIFY=	10			;HASH BUCKET SUSCEPTIBLE TO CHANGE FLAG

NT_W_HASH=	2			;HASH FUNCTION OR 0
NT_L_NAMLEN=	4			;LENGTH OF NAME
NT_L_NAMADR=	8			;ADDRESS OF NAME
NT_L_TABID=	12			;TABLE HEADER ADDRESS OR 0
NT_L_THREAD=	16			;LNMB POINTER
NT_K_LENGTH=	20			;BLOCK LENGTH

;	.PAGE

	.SBTTL	DELETE_ENTRY	- DELETE ONE LOGICAL NAME TABLE ENTRY
;+
; DELETE_ENTRY - DELETE ONE LOGICAL NAME TABLE ENTRY
;
; THIS ROUTINE IS CALLED TO DELETE ONE LOGICAL NAME TABLE ENTRY.
; IF THE ENTRY IS A TABLE HEADER, IT IS LINKED TO R5.
; OTHERWISE, THE LOGICAL NAME BLOCK IS DELETED.
; IN EITHER CASE, ALL SPECIAL INFORMATION (OTHER THAN THE TABLE
; HEADER) IS HANDLED.
;
; INPUTS:
;
;	R1 = ADDRESS OF ENTRY TO BE DELETED.
;	R5 = ADDRESS OF LIST OF LOGICAL NAME BLOCKS CONTAINING
;	     TABLE HEADERS
;
;	IT IS ASSUMED THAT THE LOGICAL NAME MUTEX IS LOCKED FOR WRITE ACCESS,
;	AND THAT THE CALLER HAS THE PRIVILEGE OF DELETING THE LOGICAL NAME
;	TABLE ENTRY.
;
; OUTPUTS:
;
;	THE ENTRY IS REMOVED FROM ITS RESPECTIVE LOGICAL NAME TABLE AND THE
;	STORAGE IS RETURNED TO THE APPROPRIATE ALLOCATION REGION.
;
;	ADDITIONAL LOGICAL NAME BLOCKS CONTAINING TABLE HEADERS MAY BE
;	LINKED TO R5.
;	R0, R1, R2, AND R3 ARE MODIFIED.
;-

	.PSECT	YF$$LNM
DELETE_ENTRY:				;DELETE LOGICAL NAME TABLE ENTRY
	MOVQ	LNMB$L_FLINK(R1),R2	;PICK BOTH LINKS
	MOVAL	(R2)+,LNMB$L_FLINK(R3)	;STORE NEXT PTR IN PREVIOUS BLOCK
	BEQL	5$			;THIS IS THE END OF THE LINE
	MOVL	R3,LNMB$L_BLINK-4(R2)	;STORE PREVIOUS PTR IN NEXT BLOCK
5$:	MOVAB	LNMB$T_NAME(R1),R3	;POINT TO COUNTED NAME STRING
10$:	MOVZBL	(R3)+,R0		;LENGTH OF NAME
	ADDL2	R0,R3			;ADDRESS OF TRANSLATION
	BBS	#LNMX$V_XEND, -		;END OF TRANSLATIONS
		LNMX$B_FLAGS(R3),20$
	BBS	#7,LNMX$B_INDEX(R3),70$	;BRANCH IF SPECIAL TRANSLATION
20$:	CMPL	R5,R1			;BLOCK LINKED ON TABLE LIST?
	BNEQ	DELETE_LNMB		;BRANCH IF NOT TO LINKED TO
	RSB				;DELETE THE NAME BLOCK AND RETURN

50$:	MOVAL	LNMX$T_XLATION+1(R3),R0	;TRANSLATION STRING ADDRESS
	TSTL	(R0)			;IS ADDRESS PRESENT?
	BEQL	60$			;NO ADDRESS SPECIFIED
	CLRL	@(R0)+			;CLEAR POINTER TO NAME
	CLRL	-(R0)			;CLEAR BACK POINTER
60$:	ADDL	#LNMX$T_XLATION,R3	;ADDRESS OF COUNTED TRANSLATION STRING
	BRB	10$			;PROCESS NEXT TRANSLATION

70$:	CMPB	LNMX$B_INDEX(R3),#LNMX$C_BACKPTR ;LOOK FOR BACK POINTER
	BEQL	50$			;PROCESS REFERENCE POINTER
	CMPB	LNMX$B_INDEX(R3),#LNMX$C_TABLE	;LOOK FOR TABLE HEADER
	BNEQ	60$			;CONTINUE SCANNING TRANSLATIONS
	ASSUME	LNMB$L_FLINK,EQ,0
	MOVL	R5,(R1)+		;LINK ONTO R5 LIST
	MOVAB	LNMX$T_XLATION+1(R3), -	;STORE TABLE IDENTIFIER IN A HANDY PLACE
		LNMB$L_BLINK-4(R1)
	MOVAL	-(R1),R5
	BRB	60$			;CONTINUE SCAN OF TRANSLATIONS

;	.PAGE

	.SBTTL	DELETE_LNMB	- DELETE LOGICAL NAME BLOCK
;+
; DELETE_LNMB - DELETE LOGICAL NAME BLOCK
;
; THIS ROUTINE IS CALLED TO DELETE A LOGICAL NAME BLOCK.  STORAGE IS
; RETURNED TO THE APPROPRIATE ALLOCATION REGION AND QUOTA IS RETURNED
; TO THE APPROPRIATE TABLE HEADER(S).  IF THE LOGICAL NAME BLOCK IS FOR A
; SHAREABLE LOGICAL NAME TABLE, THEN THE OBJECT RIGHTS BLOCK ASSOCIATED WITH 
; THE TABLE IS CLEANED UP BEFORE IT, TOGETHER WITH THE LNMB, ARE DELETED.
;
; INPUTS:
;
;	R1 = ADDRESS OF ENTRY TO BE DELETED.
;
;	IF THE ENTRY IS FOR A LOGICAL NAME TABLE, IT IS ASSUMED THAT THE ADDRESS
;	OF ITS TABLE HEADER IS STORED IN LNMB$L_BLINK.
;
;	IT IS ASSUMED THAT THE LOGICAL NAME MUTEX IS LOCKED FOR WRITE ACCESS,
;	AND THAT THE CALLER HAS THE PRIVILEGE OF DELETING THE LOGICAL NAME 
;	BLOCK.
;
; OUTPUTS:
;
;	STORAGE IS RETURNED TO THE APPROPRIATE ALLOCATION REGION.
;	THE ORB ASSOCIATED WITH THE LNMB, IF THERE IS ONE, IS CLEANED UP.
;	QUOTA IS RETURNED TO THE APPROPRIATE TABLE HEADER(S).
;
;	R0, R1, R2, AND R3 ARE MODIFIED.
;-
 
DELETE_LNMB:				;DELETE LOGICAL NAME BLOCK
	MOVL	R1,R0			;ADDRESS OF LOGICAL NAME BLOCK
	BBC	#LNMB$V_TABLE,-		;LOGICAL NAME TABLE?
		LNMB$B_FLAGS(R0),40$	;NO - GO RETURN QUOTA FOR THE ENTRY

;
; THE LOGICAL NAME BLOCK BEING DEALLOCATED IS FOR A LOGICAL NAME TABLE.  TAKE
; THE FOLLOWING ACTIONS BEFORE DELETING THE LOGICAL NAME BLOCK:
;
; 1. REMOVE THE LOGICAL NAME TABLE ENTRY BEING DELETED FROM THE HIERARCHY OF 
;    LOGICAL NAME TABLES BY MODIFYING THE CHILD POINTER OF THE LOGICAL NAME 
;    TABLE'S PARENT TABLE, AND THE SIBLING POINTERS OF THE LOGICAL NAME TABLE'S 
;    SIBLINGS AS REQUIRED.
;
; 2. RETURN TO THE PARENT LOGICAL NAME TABLE'S QUOTA HOLDER (WHICH MAY IN FACT 
;    BE THE PARENT TABLE) ANY QUOTA EXPLICTELY ALLOCATED TO THE TABLE.
;
; 3. IF THE LOGICAL NAME TABLE IS SHAREABLE, CLEANUP THE OBJECT RIGHTS BLOCK
;    ASSOCIATED WITH THE TABLE. THE ORB ITSELF WAS ALLOCATED CONTIGIOUSLY WITH
;    THE LOGICAL NAME BLOCK AND WILL BE DELETED WHEN THE LOGICAL NAME BLOCK IS
;    ITSELF DELETED.
;

	MOVL	LNMB$L_BLINK(R0),R3	;ADDRESS OF TABLE HEADER
	MOVL	LNMTH$L_PARENT(R3),R2	;ADDRESS OF PARENT'S TABLE HEADER
	CMPL	R3,LNMTH$L_CHILD(R2)	;IS BLOCK THE IMMEDIATE CHILD OF PARENT?
	BNEQ	10$			;NO  - GO FIND PRECEEDING SIBLING
	MOVL	LNMTH$L_SIBLING(R3),-	;YES - BLOCK'S IMMEDIATE SIBLING BECOMES
		LNMTH$L_CHILD(R2)	;      PARENT'S IMMEDIATE CHILD
	BRB	30$			;GO RETURN DEDUCTED QUOTA 

10$:	MOVL	LNMTH$L_CHILD(R2),R1	;ADDRESS OF PARENT'S IMMEDIATE CHILD
15$:	CMPL	R3,LNMTH$L_SIBLING(R1)	;DOES THE SIBLING PRECEED THE BLOCK?
	BEQL	20$			;YES - GO UNHOOK IT FROM LIST
	MOVL	LNMTH$L_SIBLING(R1),R1	;NO  - RETRIEVE ADDRESS OF NEXT SIBLING
	BRB	15$			;      AND CONTINUE SEARCH

20$:	MOVL	LNMTH$L_SIBLING(R3),-	;UNHOOK LOGIAL NAME BLOCK FROM THE LIST
		LNMTH$L_SIBLING(R1)	;OF SIBLINGS
		
30$:	MOVL	LNMTH$L_QTABLE(R2),R2	;RETRIEVE PARENT'S QUOTA HOLDER
	ADDL2	LNMTH$L_BYTESLM(R3),-	;RETURN ANY DEDUCTED QUOTA TO PARENT'S
		LNMTH$L_BYTES(R2)	;QUOTA HOLDER

	MOVL	LNMTH$L_ORB(R3),R1	;RETRIEVE TABLE'S OBJECT RIGHTS BLOCK
	BEQL	40$			;SKIP ORB CLEANUP IF THERE ISN'T ONE
	PUSHL	R0			;SAVE LNMB ADDRESS
	JSB	EXE$CLEANUP_ORB		;CLEANUP THE ORB
	POPL	R0			;RESTORE LNMB ADDRESS

;
; FINALLY, RETURN THE SIZE OF THE LOGICAL NAME (OR LOGICAL NAME TABLE) TO THE
; QUOTA HOLDER OF THE CONTAINING TABLE, AND THEN PERFORM THE DELETION OF THE 
; ACTUAL BLOCK.
;

40$:	MOVZWL	LNMB$W_SIZE(R0),R1	;SIZE OF LOGICAL NAME BLOCK TO RETURN
	MOVL	LNMB$L_TABLE(R0),R2	;ADDRESS OF CONTAINING TABLE'S HEADER

;
; BUMP THE APPROPRIATE DIRECTORY SEQUENCE NUMBER IF THE CONTAINING TABLE
; IS ONE OF THE DIRECTORY TABLES.
;

	BBC	#LNMTH$V_DIRECTORY,-	;DIRECTORY TABLE?
		LNMTH$B_FLAGS(R2),60$	;OKAY IF NOT
	BBS	#31,R2,50$		;BRANCH IF SYSTEM DIRECTORY
	INCL	@#CTL$GL_LNMDIRSEQ	;BUMP PROCESS DIRECTORY COUNTER
	BRB	60$
50$:	INCL	@#LNM$GL_SYSDIRSEQ	;BUMP SYSTEM DIRECTORY COUNTER

60$:	MOVL	LNMTH$L_QTABLE(R2),R2	;ADDRESS OF QUOTA HOLDER OF TABLE
	ADDL2	R1,LNMTH$L_BYTES(R2)	;RETURN SIZE OF LOGICAL NAME
	BRW	LNM$DELBLK		;DELETE LOGICAL NAME BLOCK AND RETURN

;	.PAGE

	.SBTTL	DELETE_NAMES	- SCAN HASH TABLE AND DELETE NAMES
;+
; DELETE_NAMES - SCAN HASH TABLE AND DELETE NAMES
;
; THIS ROUTINE SCANS A HASH TABLE AND DELETES ALL OF THE NAMES IN A SPECIFIED 
; TABLE WITH AN ACCESS MODE GREATER THAN OR EQUAL TO THE SPECIFIED ACCESS MODE.
;
; THIS ROUTINE IS SET UP SO THAT IT WILL NEVER DELETE A DIRECTORY.
;
; INPUTS:
;
;	R1 = ADDRESS OF TABLE HEADER OR 0 FOR ALL TABLES.
;	R2 = ACCESS MODE.
;	R3 = ADDRESS OF HASH TABLE TO BE SCANNED.
;
;	IT IS ASSUMED THAT THE LOGICAL NAME MUTEX IS LOCKED FOR WRITE ACCESS,
;	AND THAT THE CALLER HAS THE PRIVILEGE OF DELETING THE LOGICAL NAME
;	TABLE ENTRIES WITHIN THE SPECIFIED TABLE.
;
; OUTPUTS:
;
;	ENTRIES ARE REMOVED FROM THEIR RESPECTIVE LOGICAL NAME TABLES AND THE
;	STORAGE IS RETURNED TO THE APPROPRIATE ALLOCATION REGION.
;
;	R1, R2, R3, R4, and R5 ARE MODIFIED.
;-

DELETE_NAMES:
	CLRL	R5			;ZERO LINKED LIST OF TABLE HEADERS
	MOVL	R1,R4			;ADDRESS OF TABLE HEADER
	MNEGL	LNMHSH$L_MASK(R3),R0	;MAXIMUM BUCKET NUMBER
	MOVAL	LNMHSH$K_BUCKET(R3),R3	;BUCKET ADDRESS
10$:	MOVL	(R3)+,R1		;BEGINNING OF HASH CHAIN
	BEQL	40$			;EMPTY CHAIN
20$:	TSTL	R4			;SPECIFIC TABLE
	BEQL	25$			;NOPE
	CMPL	R4,LNMB$L_TABLE(R1)	;RIGHT TABLE?
	BNEQ	30$			;BRANCH IF TABLES DON'T MATCH
25$:	CMPB	R2,LNMB$B_ACMODE(R1)	;ACCESS MODE COMPATIBLE?
	BGTRU	30$			;BRANCH IF NOT
	BBS	#LNMB$V_NODELETE,-	;DIRECTORY (NODELETE WILL BE SET)?
		LNMB$B_FLAGS(R1),30$	;BRANCH IF DIRECTORY, NEVER DELETE ONE
	PUSHR	#^M<R0,R1,R2,R3,R4>	;SAVE SOME REGISTERS
	MOVL	LNMB$L_BLINK(R1),4(SP)	;SAVE ADDRESS OF PREVIOUS BLOCK
	BSBW	DELETE_ENTRY		;DELETE LOGICAL NAME BLOCK
	BSBB	DELETE_TABLE		;DELETE TABLE IF CURRENT LNMB IS ONE
	POPR	#^M<R0,R1,R2,R3,R4>	;RESTORE REGISTERS
30$:	MOVL	LNMB$L_FLINK(R1),R1	;MOVE TO NEXT LNMB IN HASH BUCKET
	BNEQ	20$			;BRANCH IF IT EXISTS
40$:	SOBGTR	R0,10$			;BUMP TO NEXT HASH BUCKET
	RSB

;	.PAGE

	.SBTTL	DELETE_TABLE	- DELETE A LOGICAL NAME TABLE
;+
; DELETE_TABLE - DELETE A LOGICAL NAME TABLE
;
; THIS ROUTINE TAKES A TABLE HEADER AND DELETES IT. TO DELETE A TABLE HEADER,
; FIRST ALL OF THE CHILDREN OF THE TABLE ARE DELETED BY RECURSIVELY CALLING
; THIS ROUTINE, THEN ALL OF THEN NAMES DEFINED WITHIN THE TABLE ARE DELETED, 
; AND FINALLY THE LOGICAL NAME BLOCK CONTAINING THE TABLE HEADER ITSELF IS 
; DELETED.
;
; INPUTS:
;
;	R5 = ADDRESS OF LIST OF LOGICAL NAME BLOCK CONTAINING TABLE HEADERS TO
;	     BE DELETED.
;
;	IT IS ASSUMED THAT THE ADDRESS OF THE TABLE HEADER IS STORED WITHIN
;	LNMB$L_BLINK(R5).
;
;	IT IS ASSUMED THAT THE LOGICAL NAME MUTEX IS LOCKED FOR WRITE ACCESS,
;	AND THAT THE CALLER HAS THE PRIVILEGE OF DELETING THE LOGICAL NAME
;	TABLE.
;
; OUTPUTS:
;
;	ALL OF THE NAMES DEFINED WITHIN THE TABLE HEADER ARE DELETED.
;	ALL OF THE CHILDREN OF THE TABLE HEADER ARE DELETED (THIS INVOLVES
;	DELETING ALL OF THEIR CHILDREN, AND ALL OF THE NAMES DEFINED WITHIN
;	THEM ETC...).
;	STORAGE AND QUOTA IS RETURNED.
;
;	R1, R2, R3, R4, and R5 ARE MODIFIED.
;-

DELETE_TABLE:
	MOVL	R5,R0			;ADDRESS OF CURRENT TABLE HEADER'S LNMB
	BNEQ	10$			;BRANCH IF ONE PRESENT
	MOVL	#SS$_NORMAL,R0		;RETURN SUCCESS WHEN ALL DONE
	RSB

;
; DELETE ALL OF THE CHILDREN OF THE CURRENT TABLE HEADER.
;

10$:	MOVL	LNMB$L_BLINK(R0),R1	;ADDRESS OF TABLE HEADER
	MOVL	LNMTH$L_CHILD(R1),R2	;ADDRESS OF CHILD TABLE
	BEQL	20$			;BRANCH IF NO CHILD
	MOVL	LNMTH$L_NAME(R2),R1	;ADDRESS OF NAME BLOCK OF CHILD
	BSBW	DELETE_ENTRY		;DELETE THE CHILD (PUT IT ON THE LIST)
	BRB	DELETE_TABLE		;CONTINUE THE DELETION PROCESS

;
; DELETE ALL OF THE NAMES DEFINED WITHIN THE CURRENT TABLE HEADER.
;

20$:	PUSHL	LNMB$L_FLINK(R0)	;UPDATE AND SAVE LIST POINTER
	PUSHL	R0			;SAVE CURRENT LOGICAL NAME BLOCK ADDRESS
	MOVL	LNMTH$L_HASH(R1),R3	;HASH TABLE ADDRESS
	CLRL	R2			;ALL ACCESS MODES
	BSBW	DELETE_NAMES		;DELETE NAMES IN THIS TABLE
	POPR	#^M<R1,R5>		;RESTORE NAME BLOCK ADDRESS AND LIST PTR
	BSBW	DELETE_LNMB		;DELETE THE CURRENT LOGICAL NAME BLOCK
	BRB	DELETE_TABLE		;ITERATE UNTIL LIST IS EMPTY

;	.PAGE

	.SBTTL	LNM$CHECK_PROT	- CHECK ACCESS TO A LOGICAL NAME TABLE
;+
; LNM$CHECK_PROT - CHECK ACCESS TO A LOGICAL NAME TABLE
;
; THIS ROUTINE IS CALLED TO CHECK ACCESS TO A LOGICAL NAME TABLE, USING ITS
; OBJECT RIGHTS BLOCK.
;
; ASSUMPTION: THE LOGICAL NAME TABLE HAS AN ASSOCIATED OBJECT RIGHTS BLOCK
;	      IE - LNMTH$L_CHP(R1) ~= 0!
;
; CURRENTLY, ONLY SOGW PROTECTION IS ACTUALLY CHECKED.   ACCESS MODE
; CHECKING IS HANDLED BY THE CALLING ROUTINE AND ALL OTHER SECURITY
; CHECKS ARE NYI.
;
; INORDER TO PROVIDE COMPATIBLE ACCESS TO THE GROUP AND SYSTEM LOGICAL NAME
; TABLES ACROSS RELEASES, THE FOLLOWING ALGORITHM (WHICH WILL ALLOW ACCESS 
; UNDER SPECIAL SETS OF CIRCUMSTANCES TO THESE TABLES EVEN IF ACCESS IS DENIED
; BY SOGW PROTECTION) IS IMPLEMENTED:
;
; IF SOGW PROTECTION
; THEN
;     RETURN SUCCESS
; ELSE
;     IF OTHER THAN R OR W ACCESS IS REQUESTED
;     THEN
;	  RETURN FAILURE
;     ELSE 
;	  IF GROUP LOGICAL NAME TABLE
;	  THEN
;	      IF GRPNAM AND TABLE IS GROUP TABLE FOR THE CALLER
;	      THEN
;		  RETURN SUCCESS
;	      ELSE
;		  RETURN FAILURE
;	  ELSE
;	      IF SYSTEM LOGICAL NAME TABLE AND SYSNAM
;	      THEN
;		  RETURN SUCCESS
;	      ELSE
;		  RETURN FAILURE
;
; INPUTS:
;
;	R1 = ADDRESS OF LOGICAL NAME TABLE HEADER.
;	R2 = ACCESS MASK TO USE FOR THE CHECK.
;	R4 = CURRENT PCB ADDR
;
; OUTPUTS:
;
;	R0 = RETURN STATUS FROM THE EXE$CHKPRO SUBROUTINE.
;	     (SUCCESS IN TWO SPECIAL CASES - SEE ABOVE)
;	R2 IS DESTROYED. ALL OTHER REGISTERS PRESERVED.
;-

LNM$CHECK_PROT::			;CHECK ACCESS TO A LOGICAL NAME TABLE
	PUSHL	R3			;SAVE REGISTERS 
	MOVQ	R1,-(SP)
	MOVL	PCB$L_ARB(R4),R0	;RETRIEVE AGENT RIGHTS BLOCK
	MOVL	LNMTH$L_ORB(R1),R1	;RETRIEVE OBJECT RIGHTS BLOCK

	CLRL	-(SP)			;CLEAR ACCESS MODE FIELD OF CHPCTL
	PUSHL	#<CHPCTL$M_READ!-	;SET READ AND USEREADALL BITS IN
		CHPCTL$M_USEREADALL>	;CHPCTL FLAGS FIELD
	BITB	#^C<ARM$M_READ>,R2	;OTHER THAN READ ACCESS CHECK REQUESTED?
	BEQL	5$			;BRANCH IF NOT
	XORB2	#<CHPCTL$M_WRITE!-	;OTHERWISE SET WRITE AND CLEAR 
		CHPCTL$M_USEREADALL>,(SP);USEREADLL BITS IN CHPCTL FLAGS FIELD
5$:	PUSHL	R2			;SET ACCESS REQUESTED IN CHPCTL

	MOVL	SP,R2			;MOVE CHPCTL ADDRESS INTO PROPER REG
	CLRL	R3			;NO CHPRET ACCESS BLOCK REQUIRED
	JSB	G^EXE$CHKPRO_INT	;CHECK THE PROTECTION
	MOVAB	CHPCTL$C_LENGTH(R2),SP	;REMOVE CHPCTL BLOCK FROM THE STACK
	MOVQ	(SP)+,R1		;RESTORE REGISTERS 
	POPL	R3
	BLBS	R0,30$			;RETURN IF OK TO ACCESS

	BITB	#^C<ARM$M_READ!-	;OTHER THAN R OR W ACCESS REQUESTED?
		ARM$M_WRITE>,R2		
	BNEQ	30$			;IF SO THEN RETURN FAILURE

	BBC	#LNMTH$V_GROUP,-	;IS THIS A GROUP LOGICAL NAME TABLE?
		LNMTH$B_FLAGS(R1),10$	;BRANCH IF IT ISN'T ONE
	IFNPRIV	GRPNAM,30$		;RETURN FAILURE IF CALLER LACKS GRPNAM
	MOVL	LNMTH$L_ORB(R1),R2	;RETRIEVE ADDRESS OF OBJECT RIGHTS BLOCK
	CMPW	PCB$L_UIC+2(R4),-	;IS THIS THE CALLER'S GROUP LOGICAL 
		ORB$L_OWNER+2(R2)	;NAME TABLE?
	BEQL	20$			;RETURN SUCCESS IF IT 
	BRB	30$			;RETURN FAILURE IF IT ISN'T

10$:	BBC	#LNMTH$V_SYSTEM,-	;IS THIS THE SYSTEM LOGICAL NAME TABLE
		LNMTH$B_FLAGS(R1),30$	;RETURN FAILURE IF IT ISN'T
	IFNPRIV	SYSNAM,30$		;RETURN FAILURE IF CALLER LACKS SYSNAM

20$:	MOVL	#SS$_NORMAL,R0		;CHANGE STATUS OF ROUTINE TO SUCCESS
30$:	RSB				;RETURN STATUS

;	.PAGE

	.SBTTL	LNM$DELBLK	- DELETE P1 OR S0 PAGED BLOCK
;+
; LNM$DELBLK - DELETE P1 OR S0 PAGED BLOCK
;
; THIS ROUTINE IS CALLED TO DELETE A CHUNK OF P1 OR S0 PAGED MEMORY.
;
; INPUTS:
;
;	R0 = ADDRESS OF ENTRY TO BE DELETED.
;
; OUTPUTS:
;
;	NONE
;
;	STORAGE IS RETURNED TO THE APPROPRIATE ALLOCATION REGION.
;
;	R0, R1, R2, AND R3 ARE MODIFIED.
;-
 
LNM$DELBLK::				;DELETE PAGED BLOCK
	MOVZWL	LNMB$W_SIZE(R0),R1	;SIZE OF BLOCK
	BBS	#31,R0,10$		;IF SET, SYSTEM SPACE TABLE
	JMP	@#EXE$DEAP1		;DEALLOCATE PROCESS DYNAMIC MEMORY
10$:	JMP	@#EXE$DEAPAGED		;DEALLOCATE SYSTEM PAGED MEMORY

;	.PAGE

	.SBTTL	LNM$DELETE	- DELETE LOGICAL NAME TABLE ENTRY
;+
; LNM$DELETE - DELETE LOGICAL NAME TABLE ENTRY
;
; THIS ROUTINE IS CALLED TO DELETE A LOGICAL NAME TABLE ENTRY, RETURN ITS
; STORAGE TO THE APPROPRIATE ALLOCATION REGION, AND RETURN ITS QUOTA.
; IF THE NAME IS A TABLE HEADER, THEN ALL NAMES IN THE TABLE ARE ALSO
; DELETED AND ANY TABLES OF WHICH THIS TABLE IS THE PARENT ARE DELETED.
;
; A PRIVILEGE ERROR WILL ALWAYS BE RETURNED IF AN ATTEMPT IS MADE TO DELETE
; A DIRECTORY.
;
; INPUTS:
;
;	R1 = ADDRESS OF ENTRY TO BE DELETED.
;
;	IT IS ASSUMED THAT THE LOGICAL NAME MUTEX IS LOCKED FOR WRITE ACCESS,
;	AND THAT THE CALLER HAS THE PRIVILEGE OF DELETING THE LOGICAL NAME
;	BLOCK.
;
; OUTPUTS:
;
;	R0 = SS$_NOPRIV IF THE LOGICAL NAME TABLE ENTRY IS A DIRECTORY.
;
;	R0 = SS$_SUCCESS
;
;	THE ENTRY IS REMOVED FROM ITS RESPECTIVE LOGICAL NAME TABLE AND THE
;	STORAGE IS RETURNED TO THE APPROPRIATE ALLOCATION REGION. IF THE ENTRY
;	HAS AN ASSOCIATED MAILBOX UCB ADDRESS, THEN THE LINKAGE FROM THE UCB
;	TO THE LOGICAL NAME ENTRY IS CLEARED.
;
;	R1, R2, AND R3 ARE MODIFIED.
;-
 

LNM$DELETE:				;DELETE LOGICAL NAME TABLE ENTRY
	BBC	#LNMB$V_NODELETE,-	;DIRECTORY (NODELETE WILL BE SET)?
		LNMB$B_FLAGS(R1),10$	;IF NOT THEN GO DELETE THE ENTRY
	MOVZWL	#SS$_NOPRIV,R0		;OTHERWISE RETURN A PRIVILEGE VIOLATION
	BRB	20$

10$:	MOVQ	R4,-(SP)		;SAVE REGISTERS R4 AND R5
	CLRL	R5			;CLEAR LINKED LIST OF TABLE HEADERS
	BSBW	DELETE_ENTRY		;DELETE THE LOGICAL NAME TABLE ENTRY
	BSBW	DELETE_TABLE		;DELETE THE TABLE HEADER IF IT IS ONE
	MOVQ	(SP)+,R4		;RESTORE REGISTERS R4 AND R5
20$:	RSB				;RETURN STATUS

;	.PAGE

	.SBTTL	LNM$DELETE_LNMB	- DELETE LOGICAL NAME TABLE ENTRY PLUS ALIASES
;+
; LNM$DELETE_LNMB - DELETE LOGICAL NAME TABLE ENTRY PLUS ALIASES
;
; THIS ROUTINE IS CALLED TO DELETE A LOGICAL NAME TABLE ENTRY TOGETHER WITH ALL 
; OF ITS OUTER ACCESS MODE ALIASES. STORAGE FOR THE DELETED ENTRIES IS RETURNED 
; TO THE APPROPRIATE ALLOCATION REGION, AND QUOTA IS RETURNED AS WELL. IF ANY 
; OF THE ENTRIES DELETED ARE LOGICAL NAME TABLES, THEN ALL NAMES WITHIN THE 
; TABLE ARE ALSO DELETED AS WELL AS ANY TABLES OF WHICH THIS TABLE IS THE 
; PARENT OF.
;
; INPUTS:
;
;	R1 = ADDRESS OF LOGICAL NAME TABLE ENTRY
;
;	IT IS ASSUMED THAT THE LOGICAL NAME MUTEX IS LOCKED FOR WRITE ACCESS,
;	AND THAT THE CALLER HAS THE PRIVILEGE OF DELETING THE LOGICAL NAME
;	TABLE ENTRY.
;
; OUTPUTS:
;
;	R0 = SS$_NOPRIV IF THE LOGICAL NAME TABLE ENTRY IS A DIRECTORY.
;
;	     SS$_SUCCESS.
;
;	     SS$_NOLOGNAM IF THERE ARE NO SUCH LOGICAL NAMES.
;
;	THE ENTRIES ARE REMOVED FROM THEIR LOGICAL NAME TABLE AND THE STORAGE
;	IS RETURNED TO THE APPROPRIATE ALLOCATION REGION. IF ANY OF THE ENTRIES
;	HAS AN ASSOCIATED MAILBOX UCB OR VOLUME UCB ADDRESS, THEN THE LINKAGE 
;	FROM THE UCB TO THE LOGICAL NAME TABLE ENTRY IS CLEARED BY THIS 
;	ROUTINE'S CALLER.
;
;	R1, R2, AND R3 ARE MODIFIED.
;-
 
LNM$DELETE_LNMB::			;DELETE TABLE ENTRY AND ALL ALIASES
	CLRL	-(SP)			;INITIALIZE THREAD TO ZERO
	PUSHL	LNMB$L_TABLE(R1)	;ADDRESS OF TABLE HEADER
	PUSHAB	LNMB$T_NAME+1(R1)	;DESCRIPTOR OF LOGICAL NAME
	MOVZBL	LNMB$T_NAME(R1),-(SP)
	PUSHL	#<NT_M_MODIFY @ 8+-	;HASH BUCKET MIGHT BE MODIFIED
		PSL$C_USER>		;SEARCH ACCESS MODE
	PUSHL	R1			;SAVE ADDRESS OF INNERMOST LNMB

	CMPB	#PSL$C_USER,-		;IS INNERMOST LOGICAL NAME TABLE ENTRY
		LNMB$B_ACMODE(R1)	;AN USER ACCESS MODE NAME?
	BEQL	10$			;IF SO, THEN IT IS ONLY ENTRY TO DELETE
	MOVAL	4(SP),R3		;ELSE SETUP TO FIND OUTERMOST MODE ENTRY
	BSBW	LNM$PRESEARCH		;AND GO FIND IT

10$:	PUSHL	R1			;SAVE ADDRESS OF CURRENT TABLE ENTRY
	BSBB	LNM$DELETE		;DELETE CURRENT TABLE ENTRY
	POPL	R1			;RESTORE ADDRESS OF DELETED ENTRY
	BLBC	R0,30$			;RETURN ANY ERROR ON DELETION

	CMPL	R1,(SP)			;WAS INNERMOST ENTRY JUST DELETED?
	BEQL	20$			;IF SO THEN GO RETURN SUCCESS
	MOVAL	4(SP),R3		;ELSE PREPARE TO SEARCH FOR NEXT ENTRY
	BSBW	LNM$CONTSEARCH		;SEARCH FOR NEXT ENTRY TO DELETE
	BRB	10$			;ELSE GO SEE IF ENTRY CAN BE DELETED

20$:	MOVL	#SS$_NORMAL,R0		;SUCCESS
30$:	ADDL2	#NT_K_LENGTH+4,SP	;REMOVE STORAGE FROM STACK
	RSB				;RETURN STATUS

;	.PAGE

	.SBTTL	LNM$DELETE_HASH	- DELETE ALL ENTRIES IN A HASH TABLE
;+
; LNM$DELETE_HASH - DELETE ALL ENTRIES IN A HASH TABLE
;
; THIS ROUTINE IS CALLED TO DELETE ALL NAMES WITH A SPECIFIED OR GREATER
; ACCESS MODE FROM A SPECIFIED HASH TABLE.
;
; INPUTS:
;
;	R2 = ACCESS MODE.
;	R3 = ADDRESS OF HASH TABLE.
;	R4 = PCB ADDRESS.
;
;	THE LOGICAL NAME MUTEX WILL BE LOCKED FOR WRITE ACCESS,
;	AND THE CALLER IS ASSUMED TO HAVE THE PRIVILEGE OF DELETING
;	THE LOGICAL NAME TABLE ENTRIES WITHIN THE SPECIFIED TABLE.
;
; OUTPUTS:
;
;	THE APPROPRIATE HASH TABLE IS SCANNED AND ALL NAMES 
;	WITH AN ACCESS MODE GREATER THAN OR EQUAL TO
;	THE SPECIFIED ACCESS MODE ARE DELETED.  QUOTA IS RETURNED.
;
;	R1, R2, AND R3 ARE MODIFIED.
;-
 
LNM$DELETE_HASH::
	SAVIPL				;SAVE CURRENT IPL ON STACK
	MOVQ	R4,-(SP)		;SAVE REGISTERS 
	BSBW	LNM$LOCKW		;LOCK LOGICAL NAME MUTEX FOR WRITING
	CLRL	R1			;NO SPECIFIC TABLE HEADER
	BSBW	DELETE_NAMES		;DELETE THE NAMES WITHIN THE TABLE
	MOVQ	(SP)+,R4		;RESTORE REGISTERS 
	BSBW	LNM$UNLOCK		;UNLOCK THE LOGICAL NAME MUTEX
	ENBINT				;RESTORE IPL TO ITS VALUE ON ENTRY
	MOVZWL	#SS$_NORMAL,R0		;SUCCESS ALWAYS
	RSB				;RETURN STATUS

;	.PAGE

	.SBTTL	LNM$DELETE_TAB	- DELETE ALL ENTRIES IN A LOGICAL NAME TABLE
;+
; LNM$DELETE_TAB - DELETE ALL ENTRIES IN A LOGICAL NAME TABLE
;
; THIS ROUTINE IS CALLED TO DELETE ALL NAMES WITH A SPECIFIED OR GREATER
; ACCESS MODE FROM A SPECIFIED LOGICAL NAME TABLE.
;
; INPUTS:
;
;	R1 = ADDRESS OF TABLE HEADER.
;	R2 = ACCESS MODE.
;
;	IT IS ASSUMED THAT THE LOGICAL NAME MUTEX IS LOCKED FOR WRITE ACCESS,
;	AND THAT THE CALLER HAS THE PRIVILEGE OF DELETING THE LOGICAL NAME
;	TABLE ENTRIES WITHIN THE SPECIFIED TABLE.
;
; OUTPUTS:
;
;	THE APPROPRIATE HASH TABLE IS SCANNED AND ALL NAMES CONTAINED IN
;	THE SPECIFIED TABLE WITH AN ACCESS MODE GREATER THAN OR EQUAL TO
;	THE SPECIFIED ACCESS MODE ARE DELETED.  QUOTA IS RETURNED.
;
;	R1, R2, AND R3 ARE MODIFIED.
;-
 
LNM$DELETE_TAB::			;DELETE LOGICAL NAME TABLE ENTRY
	MOVQ	R4,-(SP)		;SAVE REGISTERS 
	MOVL	LNMTH$L_HASH(R1),R3	;ADDRESS OF HASH TABLE
	BSBW	DELETE_NAMES		;DELETE THE NAMES WITHIN THE TABLE
	MOVQ	(SP)+,R4		;RESTORE REGISTERS 
	MOVZWL	#SS$_NORMAL,R0		;SUCCESS ALWAYS
	RSB				;RETURN STATUS

;	.PAGE

	.SBTTL	LNM$INIT_PROT	- INIT A LOGICAL NAME TABLE'S OBJECT RIGHTS BLOCK 
;+
; LNM$INIT_PROT - INIT A LOGICAL NAME TABLE'S OBJECT RIGHTS BLOCK 
;
; THIS ROUTINE IS CALLED TO INITIALIZE THE OBJECT RIGHTS BLOCK FOR A SHAREABLE
; LOGICAL NAME TABLE. IT IS ASSUMED THAT THIS ROUTINE IS NEVER CALLED FOR A 
; PROCESS-PRIVATE LOGICAL NAME TABLE. CURRENTLY, ONLY SOGW PROTECTION AND UIC 
; ARE ACTUALLY USED.   ACCESS MODE CHECKING IS HANDLED BY THE CALLING ROUTINE 
; AND ALL OTHER SECURITY CHECKS ARE NYI.
;
; INPUTS:
;
;	R0 = ADDRESS OF STORAGE TO USE FOR ORB.
;	R1 = ADDRESS OF PARENT LOGICAL NAME TABLE LNMTH.
;	R2 = ADDRESS OF LOGICAL NAME TABLE LNMTH.
;	R4 = ADDRESS OF LOGICAL NAME TABLE LNMB.
;	R6 = ACCESS MASK TO ASSIGN TO THE TABLE.
;	4(SP) = CURRENT PCB ADDRESS.
;
; OUTPUTS:
;
;	R0, R3 DESTROYED.
;	ALL OTHER REGISTERS PRESERVED.
;-
 

LNM$INIT_PROT::				;INIT ORB FOR A LOGICAL NAME TABLE
	ADDL2	#^X07,R0		;ALGIN ORB ON A QUADWORD BOUNDRY
	BICL2	#^X07,R0
	MOVAL	(R0),LNMTH$L_ORB(R2)	;SAVE ADDRESS OF ORB IN TABLE HEADER
	MOVL	4(SP),R3		;RETRIEVE PCB ADDRESS
	MOVL	PCB$L_UIC(R3),(R0)+	;SET OWNER UIC
	MOVZWL	#^XFFFF,(R0)+		;INITIALIZE ACL MUTEX
	MOVL	#<DYN$C_ORB @ 16+-	;SET STRUCTURE TYPE IN FLAGS FIELD
		ORB$C_LENGTH>,(R0)+	;SET STRUCTURE SIZE
	CLRL	(R0)+			;SPARE WORD AND REF COUNT NOT USED
	CLRQ	(R0)+			;NO ACCESS MODE CHECKS ARE MADE
	EXTZV	#0, #4,R6,(R0)+		;SET SYSTEM PROTECTION FIELD
	EXTZV	#4, #4,R6,(R0)+		;SET OWNER PROTECTION FIELD
	EXTZV	#8, #4,R6,(R0)+		;SET GROUP PROTECTION FIELD
	EXTZV	#12,#4,R6,(R0)+		;SET WORLD PROTECTION FIELD
	CLRQ	(R0)+			;NOTE NO ACL AS YET
	PUSHR	#^M<R2,R4,R5>		;SAVE REGISTERS (R1 PRESERVED BY MOVC)
	MOVC5	#0,(R1),#0,-		;INITIALIZE MINIMUM AND MAXIMUM
		#<ORB$S_MIN_CLASS+-	;CLASSIFICATION MASKS TO 0
		ORB$S_MAX_CLASS>,(R0)
	POPR	#^M<R2,R4,R5>		;RESTORE REGISTERS 
	RSB				;RETURN

;	.PAGE

	.SBTTL	LNM$INSLOGTAB	- INSERT IN LOGICAL NAME TABLE BY ADDRESS
;+
; LNM$INSLOGTAB - INSERT IN LOGICAL NAME TABLE BY ADDRESS
;
; THIS ROUTINE IS CALLED TO INSERT A NEW ENTRY INTO THE LOGICAL NAME TABLE 
; SPECIFIED BY TABLE HEADER ADDRESS. INSERTION IN THE CASE OF AN ENTRY FOR A
; NEW LOGICAL NAME TABLE INCLUDES THE LINKING OF THE NEW TABLE ENTRY TO PARENT 
; AND SIBLINGS AND ANY REQUIRED QUOTA DEDUCTIONS.
;
; IF AN ENTRY (OR ENTRIES) ALREADY EXISTS AT AN OUTER ACCESS MODE AND THE NEW 
; NAME IS UNALIASABLE, THE EXISTING NAME(S) IS (ARE) DELETED.  
;
; IF AN UNALIASABLE ENTRY ALREADY EXISTS IN AN INNER ACCESS MODE, AN ERROR IS 
; RETURNED.  
;
; IF AN EQUIVALENT ENTRY ALREADY EXISTS, IT IS DELETED UNLESS CREATE_IF IS 
; SPECIFIED IN WHICH CASE THE NEW ENTRY WILL BE JUST BE MAPPED TO THE EXISTING 
; ENTRY, AND NO NAMES ARE SUPERSEDED.
;
; IF THE NEW ENTRY IS FOR A LOGICAL NAME TO BE CONTAINED WITHIN EITHER THE
; PROCESS OR SYSTEM DIRECTORY LOGICAL NAME TABLE, THEN THE HASH CODE VALUE OF 
; EACH OF THE LOGICAL NAME'S EQUIVALENCE STRINGS IS COMPUTED AND STORED WITHIN
; THE CORRESPONDING TRANSLATION BLOCK.
;
; INPUTS:
;
;	R1 = ADDRESS OF LOGICAL NAME BLOCK.
;	     (ADDRESS OF TABLE IS IN THE BLOCK).
;	R2 = ATTRIBUTES AFFECTING TABLE ENTRY CREATION.
;	     (IT IS ASSUMED THAT THE HIGH ORDER BIT IS UNUSED AND 0).
;
;	IT IS ASSUMED THAT THERE IS SUFFICIENT QUOTA IN THE CONTAINING TABLE
;	(AND THE PARENT'S QUOTA HOLDER IN THE CASE OF A LOGICAL NAME TABLE 
;	ENTRY) FOR THE INSERTION OF THE NEW ENTRY AND THE DEDUCTION OF ITS 
;	SEPARATE QUOTA WHEN APPROPRIATE.
;
;	IT IS ASSUMED THAT THE LOGICAL NAME MUTEX IS LOCKED FOR WRITE ACCESS.
;
; OUTPUTS:
;
;	R0 CONTAINS A SUCCESS STATUS.
;
;		THE LOGICAL NAME IS INSERTED IN THE SPECIFIED TABLE.
;		QUOTA IS DEDUCTED WHEN APPROPRIATE.
;
;		R0 = SS$_LNMCREATED - NEW TABLE WAS INSERTED.
;		R0 = SS$_NORMAL     - NEW TABLE WAS MAPPED TO EXISTING TABLE OR
; 				      NEW LOGICAL NAME WAS INSERTED.
;		R0 = SS$_SUPERSEDE  - LOGICAL NAME SUPERCEDED EXISTING NAME.
;
;	R1 CONTAINS ADDRESS OF LNMB MAPPED TO IF CREATE-IF SET AND NEW LOGICAL 
;		NAME TABLE ENTRY IS MAPPED TO EXISTING ENTRY.
;
;	R0 CONTAINS AN ERROR STATUS.
;
;		R0 = SS$_DUPLNAME   - NON-ALIASABLE DUPLICATE EXISTS.
;		R0 = SS$_PARENT_DEL - DELETEION OF PARENT WOULD HAVE OCCURRED.
;
;
;	R1, R2, R3, AND R5 ARE MODIFIED
;
;-

LNM$INSLOGTAB::				;INSERT IN LOGICAL NAME TABLE ENTRY
	MOVL	R1,R5			;ADDRESS OF NAME BLOCK

;
; BUILD A NAME TRANSLATION CONTROL BLOCK FOR THE NEW TABLE ENTRY ON THE STACK.
;

	CLRL	-(SP)			;ZERO NT_L_THREAD
	PUSHL	LNMB$L_TABLE(R5)	;ADDRESS OF CONTAINING TABLE HEADER 
	PUSHAB	LNMB$T_NAME+1(R5)	;ADDRESS OF NAME
	MOVZBL	LNMB$T_NAME(R5),-(SP)	;LENGTH OF NAME
	PUSHL	#<NT_M_MODIFY @ 8+-	;HASH BUCKET MIGHT BE MODIFIED		
		PSL$C_USER>		;SPECIFY ACCESS MODE AS USER
	BBS	#LNMB$V_NO_ALIAS, -	;BRANCH IF NOT ALIASABLE AND ALL ACCESS
		LNMB$B_FLAGS(R5),10$	;MODES WILL BE CONSIDERED
	MOVB	LNMB$B_ACMODE(R5),(SP)	;SKIP CONSIDERATION OF OUTER ACCESS MODE
10$:	MOVL	SP,R3			;ADDRESS OF TRANSLATION BLOCK

;
; SEARCH FOR AN EXISTING LOGICAL NAME TABLE ENTRY WITH A NAME MATCHING THE NAME 
; OF THE NEW TABLE ENTRY. THERE CAN BE TEN OUTCOMES OF SUCH A SEARCH AND THEY
; ARE LISTED BELOW:
;
; 1. AN EXISTING LOGICAL NAME TABLE ENTRY WAS NOT FOUND AT THE ACCESS MODE
;    SEARCHED. 
;
;    A. THE CREATE_IF BIT IS SET:
;	IF IDENTICAL NAMES AT OUTER ACCESS MODE HAD BEEN SEEN, THEN THESE 
;	LOGICAL NAME TABLE ENTRIES MUST BE DELETED BEFORE THE NEW ENTRY CAN BE
;	INSERTED. THIS IS DONE BY RE-STARTING FROM THE BEGINNING THE SEARCH FOR 
;	AN EXISTING LOGICAL NAME TABLE ENTRY WITH A NAME MATCHING THE NAME OF 
;	THE NEW TABLE ENTRY AFTER CLEARING THE CREATE_IF BIT.
;
;    B. THE CREATE_IF BIT IS NOT SET:
;	THE NEW LOGICAL NAME TABLE ENTRY IS INSERTED.
;
; 2. AN EXISTING LOGICAL NAME TABLE ENTRY IS FOUND BUT IT IS AT AN INNER ACCESS 
;    MODE. 
;
;    A. THE EXISTING LOGICAL NAME TABLE ENTRY DOES NOT ALLOW ALLIASES:
;	AN ERROR IS RETURNED.
;
;    B. THE CREATE_IF BIT IS SET AND THE EXISTING NAME ALLOWS ALLIASES:
;	IF IDENTICAL NAMES AT OUTER ACCESS MODE HAD BEEN SEEN, THEN THESE 
;	LOGICAL NAME TABLE ENTRIES MUST BE DELETED BEFORE THE NEW ENTRY CAN BE
;	INSERTED. THIS IS DONE BY RE-STARTING FROM THE BEGINNING THE SEARCH FOR 
;	AN EXISTING LOGICAL NAME TABLE ENTRY WITH A NAME MATCHING THE NAME OF 
;	THE NEW TABLE AFTER CLEARING THE CREATE_IF BIT.
;
;    C. THE CREATE_IF BIT IS NOT SET AND THE EXISTING NAME ALLOWS ALLIASES:
;	THE NEW LOGICAL NAME TABLE ENTRY IS INSERTED.
;
; 3. AN EXISTING LOGICAL NAME TABLE ENTRY IS FOUND BUT IT IS AT AN OUTER ACCESS
;    MODE. 
;
;    A. THE CREATE_IF BIT IS SET:
;	A RECORD IS KEPT THAT A LOGICAL NAME TABLE ENTRY WITH THE SAME NAME AS
;	THE NEW TABLE ENTRY WAS SEEN, AND THE SEARCH CONTINUES.
;
;    B. THE CREATE_IF BIT IS NOT SET:
;	THE EXISTING LOGICAL NAME TABLE ENTRY IS DELETED, AND THE SEARCH 
;	CONTINUES.
;
; 4. AN EXISTING LOGICAL NAME TABLE ENTRY IS FOUND AT THE SAME ACCESS MODE. 
;
;    A. THE CREATE_IF BIT IS SET:
;	THE NEW ENTRY IS MAPPED TO THE EXISTING ENTRY WITH THE SAME NAME AND
;	ACCESS MODE.
;
;    B. THE CREATE_IF BIT IS NOT SET BUT THE NODELETE BIT IS:
;	AN ERROR IS RETURNED INFORMING THAT THE CALLER ATTEMPTED TO DELETE
;	THE PARENT TABLE SPECIFIED (EITHER DIRECTLY OR INDIRECTLY THROUGH THE 
;	DELETION OF A GRANDPARENT).
;
;    C. NEITHER THE CREATE_IF BIT NOR THE NODELETE BIT IS SET:
;	THE EXISTING ENTRY IS DELETED, AND THE SEARCH CONTINUES.
;	
;

	PUSHL	R2			;SAVE THE ATTRIBUTES 
	PUSHL	#SS$_NORMAL		;ASSUME SUCCESS
20$:	BSBW	LNM$PRESEARCH		;SEARCH FOR NAME IN TABLE

25$:	BLBC	R0,50$			;NOTHING FOUND
	CMPB	LNMB$B_ACMODE(R1), -	;COMPARE ACCESS MODES
		LNMB$B_ACMODE(R5) 
	BLSSU	40$			;BRANCH IF OWNED BY AN INNER MODE
	BGTRU	30$			;BRANCH IF OWNED BY AN OUTER MODE

;
; AN EXISTING LOGICAL NAME TABLE ENTRY AT THE SAME ACCESS MODE WAS FOUND TO
; HAVE THE SAME NAME AS THAT OF THE NEW TABLE ENTRY. EITHER MAP THE NEW ENTRY
; TO THE EXISTING ENTRY, OR DELETE THE EXISTING ENTRY DEPENDING UPON THE 
; SETTING OF CREATE_IF.
;

	BBC	#LNM$V_CREATE_IF,4(SP),27$ ;GO RETURN IF MAPPING NEW TABLE ENTRY
	BRW	90$			;ONTO EXISTING TABLE ENTRY
27$:	BBC	#LNMB$V_NODELETE,-	;IF TABLE ENTRY IS A (GRAND)PARENT TO
		LNMB$B_FLAGS(R1),30$	;THE NEW TABLE ENTRY THEN RETURN ERROR
	BRW	110$
	
;
; AN EXISTING LOGICAL NAME TABLE ENTRY AT AN OUTER ACCESS MODE WAS FOUND TO 
; HAVE THE SAME NAME AS THAT OF THE NEW TABLE ENTRY. EITHER REMEMBER THAT SUCH
; A LOGICAL NAME TABLE ENTRY HAS BEEN ENCOUNTERED, OR DELETE IT DEPENDING UPON 
; THE SETTING OF CREATE_IF.
;

30$:	BBC	#LNM$V_CREATE_IF,4(SP),35$ ;BRANCH IF CREATE_IF NOT SET
	BBSS	#31,4(SP),31$		;MARK OUTER ACCESS NAMES SEEN
31$:	MOVAB	(R1),NT_L_THREAD(R3)	;SETUP TO CONTINUE WITH NEXT BLOCK
	BRB	37$			;AND GO CONTINUE SEARCH
	
35$:	MOVZWL	#SS$_SUPERSEDE,(SP)	;UPDATE STATUS RETURN
	PUSHL	R3			;SAVE REGISTERS OVER DELETE
	BSBW	LNM$DELETE		;DELETE A LOGICAL NAME BLOCK
	POPL	R3			;RESTORE THINGS
	BLBS	R0,37$			;CONTINUE IF DELETION SUCCESSFUL
	MOVL	R0,(SP)			;OTHERWISE SAVE ERROR AND TERMINATE
	BRW	90$			;TABLE ENTRY INSERTION ATTEMPT

37$:	BSBW	LNM$CONTSEARCH		;CONTINUE SEARCHING FOR MORE MODES
	BRB	25$			;LOOP OVER ALL ALIASING NAMES

;
; AN EXISTING LOGICAL NAME TABLE ENTRY AT AN INNER ACCESS MODE WAS FOUND TO
; HAVE THE SAME NAME AS THAT OF THE NEW TABLE ENTRY. IF THIS LOGICAL NAME TABLE
; ENTRY DOES NOT ALLOW ALLIASES THEN RETURN AN ERROR. OTHERWISE, EITHER INSERT
; THE NEW TABLE ENTRY, OR RE-START THE SEARCH FROM THE BEGINNING DEPENDING UPON
; WHETHER CREATE_IF IS SET, AND IF IT IS, WHETHER ANY IDENTICAL NAMES WERE 
; FOUND TO EXIST AT OUTER ACCESS MODES.
;

40$:	BBC	#LNMB$V_NO_ALIAS, -	;CONTINUE IF ALIASABLE
		LNMB$B_FLAGS(R1),50$
	BRW	100$			;BRANCH IF NOT ALIASABLE

;
; AN EXISTING LOGICAL NAME TABLE ENTRY WAS NOT FOUND TO HAVE THE SAME SAME NAME 
; AS THAT OF THE NEW TABLE ENTRY AT THE ACCESS MODE SEARCHED. EITHER INSERT THE
; NEW TABLE ENTRY, OR RE-START THE SEARCH FROM THE BEGINNING DEPENDING UPON
; WHETHER CREATE_IF IS SET, AND IF IT IS, WHETHER ANY IDENTICAL NAMES WERE 
; FOUND TO EXIST AT OUTER ACCESS MODES.
;

50$:	BBCC	#LNM$V_CREATE_IF,4(SP),55$;INSERT NEW ENTRY IF CREATE_IF NOT SET
	BBCC	#31,4(SP),55$		;OR IF OUTER ACCESS MODE NAMES NOT SEEN
	CLRL	NT_L_THREAD(R3)		;GET SET TO RE-START SEARCH
	BRB	20$			;GO RE-START SEARCH
	
55$:	MOVL	NT_L_THREAD(R3),R2	;ADDRESS OF PREVIOUS LNMB BLOCK
	MOVL	R2,LNMB$L_BLINK(R5)	;SET NEW LNMB BLOCKS BACKPOINTER
	MOVL	R5,LNMB$L_FLINK(R2)	;RESET PREVIOUS LNMB BLOCKS FRONTPOINTER
	MOVL	R1,LNMB$L_FLINK(R5)	;SET NEW LNMB BLOCKS FRONTPOINTER
	BEQL	60$			;BRANCH IF NEW LNMB BLOCK IS AT LIST END
	MOVL	R5,LNMB$L_BLINK(R1)	;RESET NEXT LNMB BLOCKS BACKPOINTER

;
; IF THE NEW ENTRY IS A LOGICAL NAME TABLE THEN THE FOLLOWING ACTIONS ARE
; TAKEN:
;
; 1. THE LOGICAL NAME BLOCK IS LINKED IN AS THE IMMEDIATE CHILD OF ITS PARENT
;    TABLE, AND THUS, AS THE FIRST SIBLING IN THE LIST OF SIBLINGS.
;
; 2. THE STATUS OF THE INSERTION IS CHANGED TO SS$_LNMCREATED IF NO LOGICAL NAME
;    TABLE ENTRIES HAD BEEN DELETED.
;
; 3. QUOTA CONSISTING OF ANY QUOTA SPECIFICALLY ALLOCATED TO THE NEW TABLE IS
;    DEDUCTED FROM THE QUOTA HOLDER OF THE PARENT LOGICAL NAME TABLE.
;

60$:	BBC	#LNMB$V_TABLE,-		;BRANCH IF THE NAME BLOCK IS NOT FOR
		LNMB$B_FLAGS(R5),80$	;A NEW LOGICAL NAME TABLE

70$:	MOVZBL	LNMB$T_NAME(R5),R0	;SIZE OF NAME STRING
	MOVAB	LNMB$T_NAME+1(R5)[R0],R2;ADDRESS OF TRANSLATION BLOCK
	MOVAB	LNMX$T_XLATION+1(R2),R2	;ADDRESS OF BLOCKS TABLE HEADER

	MOVL	LNMTH$L_PARENT(R2),R1	;ADDRESS OF PARENT'S TABLE HEADER
	MOVL	LNMTH$L_CHILD(R1),-	;LINK IN NEW TABLE ENTRY AS THE 
		LNMTH$L_SIBLING(R2)	;IMMEDIATE CHILD OF THE PARENT AND
	MOVAB	(R2),LNMTH$L_CHILD(R1)	;AS THE FIRST SIBLING IN THE LIST

	CMPW	#SS$_SUPERSEDE,(SP)	;WAS A LOGIGAL NAME SUPERSEDED?
	BEQL	75$			;BRANCH IF YES
	MOVZWL	#SS$_LNMCREATED,(SP)	;CHANGE STATUS IF NO
	
75$:	MOVL	LNMTH$L_QTABLE(R1),R1	;RETRIEVE PARENT'S QUOTA HOLDER
	SUBL2	LNMTH$L_BYTESLM(R2),-	;SUBTRACT QUOTA TO BE SPECIFICALLY
		LNMTH$L_BYTES(R1)	;ALLOCATED TO THE NEW TABLE

;
; DEDUCT THE SIZE OF THE NEW LOGICAL NAME ENTRY FROM THE QUOTA HOLDER OF THE
; CONTAINING LOGICAL NAME TABLE.
;

80$:	MOVZWL	LNMB$W_SIZE(R5),R3	;RETRIEVE SIZE OF NEW LOGICAL NAME ENTRY
	MOVL	LNMB$L_TABLE(R5),R1	;RETRIEVE CONTAINING TABLE HEADER ADDR
	MOVL	LNMTH$L_QTABLE(R1),R2	;RETRIEVE QUOTA HOLDER'S ADDRESS
	SUBL2	R3,LNMTH$L_BYTES(R2)	;SUBTRACT SIZE OF NEW TABLE ENTRY

;
; BUMP THE APPROPRIATE DIRECTORY SEQUENCE NUMBER IF THE CONTAINING TABLE
; IS ONE OF THE DIRECTORY TABLES.
;

	BBC	#LNMTH$V_DIRECTORY,-	;DIRECTORY TABLE?
		LNMTH$B_FLAGS(R1),90$	;OKAY IF NOT
	BBS	#31,R1,82$		;BRANCH IF SYSTEM DIRECTORY
	INCL	@#CTL$GL_LNMDIRSEQ	;BUMP PROCESS DIRECTORY COUNTER
	BRB	83$
82$:	INCL	@#LNM$GL_SYSDIRSEQ	;BUMP SYSTEM DIRECTORY COUNTER

;
; IF THE NEW ENTRY IS FOR A LOGICAL NAME TO BE CONTAINED WITHIN EITHER THE
; PROCESS OR SYSTEM DIRECTORY LOGICAL NAME TABLE, THEN THE HASH CODE VALUE OF 
; EACH OF THE LOGICAL NAME'S EQUIVALENCE STRINGS IS COMPUTED AND STORED WITHIN
; THE CORRESPONDING TRANSLATION BLOCK.
;

83$:	BBS	#LNMB$V_TABLE,-		;SKIP COMPUTATION AND STORAGE OF HASH
		LNMB$B_FLAGS(R5),90$	;CODES IF THIS IS A LOGICAL NAME TABLE

	MOVAB	LNMB$T_NAME(R5),R5	;RETRIEVE ADDRESS AND SIZE OF LOGICAL
	MOVZBL	(R5)+,R0		;NAME'S NAME
	ADDL2	R0,R5			;POSITION TO FIRST TRANSLATION BLOCK

85$:	BBS	#LNMX$V_XEND,-		;GO RETURN IF LAST TRANSLATION BLOCK
		LNMX$B_FLAGS(R5),90$
	MOVAB	LNMX$T_XLATION(R5),R1	;RETRIEVE ADDRESS AND SIZE OF CURRENT
	MOVZBL	(R1)+,R0		;TRANSLATION BLOCK'S EQUIVALENCE STRING
	MOVQ	R0,-(SP)		;SAVE ADDRESS AND SIZE ON STACK
	BSBW	LNM$HASH		;DETERMINE AND STORE THE CURRENT 
	MOVW	R0,LNMX$W_HASH(R5)	;EQUIVALENCE STRING'S HASH CODE VALUE
	MOVQ	(SP)+,R0		;RESTORE ADDRESS AND SIZE OF STRING
	ADDL3	R0,R1,R5		;POSITION TO NEXT TRANSLATION BLOCK
	BRB	85$			;AND CONTINUE

;
; RETRIEVE THE STATUS TO BE RETURNED, CLEAN THE NAME TRANSLATION CONTROL BLOCK
; FROM THE STACK AND RETURN.
;

90$:	POPL	R0			;FETCH STATUS
	ADDL	#NT_K_LENGTH+4,SP	;CLEAN BLOCK FROM STACK
	RSB				;EXIT
100$:	MOVZWL	#SS$_DUPLNAM,(SP)	;TRIED TO SUPERCEDE UNALIASABLE NAME
	BRB	90$			;JOIN MAIN EXIT
110$:	MOVZWL	#SS$_PARENT_DEL,(SP)	;TRIED TO DELETE (GRAND)PARENT
	BRB	90$			;JOIN MAIN EXIT

;	.PAGE

	.SBTTL	LNM$SEARCHLOG	- SEARCH FOR LOGICAL NAME
;+
; LNM$SEARCHLOG - SEARCH FOR LOGICAL NAME
;
; THIS ROUTINE IS CALLED TO SEARCH FOR A LOGICAL NAME MATCH IN A LIST OF
; LOGICAL NAME TABLES.
;
; INPUTS:
;
;	R0 = LENGTH OF LOGICAL NAME STRING.
;	R1 = ADDRESS OF LOGICAL NAME STRING.
;	R2 = LENGTH OF TABLE NAME STRING.
;	R3 = ADDRESS OF TABLE NAME STRING.
;	R5 = SEARCH ACCESS MODE IN LOW BYTE, 
;	     CASELESS FLAG IN BIT 8, 
;	     HIGH ORDER WORD 0.
;
;	IT IS ASSUMED THAT THE LOGICAL NAME MUTEX IS LOCKED FOR READ ACCESS.
;
; OUTPUTS:
;
;	R0 LOW BIT CLEAR INDICATES SEARCH FAILURE.
;
;		R0 = SS$_NOLOGNAM - NO LOGICAL NAME MATCH FOUND.
;		R1 = ADDRESS OF LOGICAL NAME BLOCK ON WHICH SEARCH FAILED.
;
;	R0 LOW BIT SET INDICATES SUCCESS WITH:
;
;		R1 = ADDRESS OF LOGICAL NAME BLOCK THAT CONTAINS MATCH.
;
; 	ALL OTHER REGISTERS ARE PRESERVED.
;-
 
LNM$SEARCHLOG::				;SEARCH FOR LOGICAL NAME
	PUSHL	R5			;SAVE REGISTERS
	MOVQ	R2,-(SP)

;
; PERFORM A PRE-SEARCH TO SEE IF THE TARGET LOGICAL NAME EXISTS AT ALL 
; INDEPENDANT OF EITHER CONTAINING TABLE HEADER ADDRESS OR ACCESS MODE. IF
; THE NAME EXISTS WITHIN THE PROCESS-PRIVATE NAME SPACE WE WILL ALSO BE
; PRE-POSITIONED TO THE FIRST LNMB IN THE LINKED LIST OF PROCES-PRIVATE LNMBs 
; WITH THIS TARGET NAME. LIKEWISE, IF THE NAME EXISTS WITHIN THE SHAREABLE NAME 
; SPACE WE WILL ALSO BE PRE-POSITIONED TO THE FIRST SHAREABLE LNMB IN THE LINKED
; LIST OF LNMBS WITH THIS TARGET NAME.
;

	CLRQ	-(SP)			;NAME BLOCK ADDRESS AND TABLE ID
	MOVQ	R0,-(SP)		;TABLE NAME AND ADDRESS
	PUSHL	R5			;ACCESS MODE AND CASE FLAG
	MOVL	SP,R3			;ADDRESS OF NAME TRANSLATION BLOCK
	MOVAL	L^LNM$AL_HASHTBL,R5	;ADDRESS OF TABLE ADDRESS POINTERS
	BBS	#31,SP,10$		;BRANCH IF SMALL PROCESS
	MOVL	@4(R5),R1		;ADDRESS OF PROCESS HASH TABLE
	BEQL	10$			;SKIP IF NO TABLE DEFINED

	BSBW	LNM$PRESEARCH		;FIND HEAD OF POSSIBLE TRANSLATIONS
	BLBS	R0,10$			;BRANCH IF NO POSSIBLE TRANSLATION
	CLRL	NT_L_THREAD(R3)		;CLEAR NAME BLOCK ADDRESS

10$:	CLRQ	-(SP)			;MAKE ANOTHER NAME TRANSLATION BLOCK
	MOVQ	NT_L_NAMLEN(R3),-(SP)	;TABLE NAME AND ADDRESS
	PUSHL	(R3)			;CONTROL LONGWORD
	MOVL	SP,R3			;ADDRESS OF SYSTEM NAME TRANSLATION BLOCK
	MOVL	@(R5)+,R1		;ADDRESS OF SYSTEM HASH TABLE

	BSBW	LNM$PRESEARCH		;FIND HEAD OF POSSIBLE TRANSLATIONS
	BLBS	R0,20$			;BRANCH IF TRANSLATION MAY EXIST
	CLRL	NT_L_THREAD(R3)		;NO POSSIBLE TRANSLATION

;
; IF THE SPECIFIED LOGICAL NAME DOES NOT EXIST IN EITHER THE PROCESS-PRIVATE OR
; SHAREABLE NAME SPACES, REGARDLESS OF CONTAINING TABLE HEADER ADDRESS OR ACCESS
; MODE, THEN IT IS POINTLESS TO CONTINUE THE SEARCH, SO RETURN AN ERROR. 
; OTHERWISE, POSITION TO THE FIRST TARGET LOGICAL NAME TABLE IN WHICH TO SEARCH
; FOR THE SPECIFIED LOGICAL NAME.
;

	TSTL	NT_K_LENGTH+NT_L_THREAD(R3)	;ANY POSSIBLE TRANSLATION?
	BEQL	90$			;BRANCH IF NO TRANSLATION POSSIBLE
20$:
	SUBL	#RT_K_LENGTH-4,SP	;ALLOCATE RECURSIVE TABLE NAME CONTROL BLOCK
	PUSHL	NT_B_ACMODE(R3)		;ACMODE, CASE FLAG
	MOVL	SP,R5			;ADDRESS OF BLOCK
	MOVQ	2*NT_K_LENGTH(R3),R2	;GET LOGICAL NAME TABLE DESCRIPTOR

	BSBW	LNM$SETUP		;SETUP TABLE PROCESSING
	BLBC	R0,70$			;NO TABLE FOUND

;
; SEARCH FOR THE SPECIFIED LOGICAL NAME WITHIN THE CURRENT LOGICAL NAME TABLE.
; ONLY ONE NAME SPACE WILL HAVE TO BE SEARCHED FOR THE LOGICAL NAME, AND THAT
; IS THE NAME SPACE THAT CORRESPONDS TO THE NAME SPACE THE CURRENT TABLE RESIDES
; IN.
;

40$:	MOVAB	RT_K_LENGTH(R5),R3	;SYSTEM TABLE CONTROL BLOCK
	BBS	#31,R1,50$		;BRANCH IF SYSTEM SPACE TABLE
	ADDL	#NT_K_LENGTH,R3		;ADVANCE TO PROCESS TABLE CONTROL BLOCK
50$:	TSTL	NT_L_THREAD(R3)		;ANY NAMES TO BE LOOKED AT?
	BEQL	60$			;NO  - GO GET NEXT TABLE TO PROCESS
	MOVL	R1,NT_L_TABID(R3)	;TABLE HEADER ADDRESS

	PUSHL	NT_L_THREAD(R3)		;SAVE SEARCH CONTEXT
	BSBW	LNM$CONTSEARCH		;RESUME SEARCH FOR NAME
	MOVL	(SP)+,NT_L_THREAD(R3)	;RESTORE ORIGINAL SEARCH CONTEXT
	BLBS	R0,70$			;BRANCH IF NAME FOUND

;
; THE SPECIFIED LOGICAL NAME WAS NOT FOUND WITHIN THE CURRENT LOGICAL NAME 
; TABLE. POSITION TO THE NEXT TABLE IN THE SEARCH LIST OF LOGICAL NAME TABLES.
; IF THERE IS A NEXT TABLE, SEARCH FOR THE LOGICAL NAME WITHIN IT; OTHERWISE,
; THE SEARCH FOR THE SPECIFIED LOGICAL NAME IS TERMINATED WITH AN ERROR.
;

60$:	BSBW	LNM$TABLE		;CONTINUE TABLE PROCESSING
	BLBS	R0,40$			;BRANCH TO PROCESS ANOTHER TABLE

70$:	MOVAB	<2*NT_K_LENGTH>+RT_K_LENGTH(SP),SP	;REMOVE TABLE SEARCH CONTROL BLOCK
80$:	MOVQ	(SP)+,R2		;RESTORE REGISTERS
	POPL	R5
	RSB
90$:	MOVZWL	#SS$_NOLOGNAM,R0	;NO TRANSLATION FOR NAME
	ADDL2	#2*NT_K_LENGTH,SP	;REMOVE NAME SEARCH CONTROL BLOCK
	BRB	80$			;JOIN MAIN EXIT
;	.PAGE

	.SBTTL	LNM$SEARCH_ONE	- SEARCH FOR LOGICAL NAME AND RETURN TRANSLATION
;+
; LNM$SEARCH_ONE - SEARCH FOR LOGICAL NAME AND RETURN INDEX 0 TRANSLATION
;
; THIS ROUTINE IS CALLED TO SEARCH FOR A LOGICAL NAME MATCH IN A LIST OF
; LOGICAL NAME TABLES. IF IT FINDS ONE, AND IF THAT LOGICAL NAME HAS A
; TRANSLATION WITH INDEX 0, THEN A COPY OF THE LNMX TRANSLATION BLOCK IS
; RETURNED IN THE SPECIFIED OUTPUT BUFFER.
;
; THIS ROUTINE DOES NOT PERFORM ANY ARGUEMENT VERIFICATION. HOWEVER, THIS 
; ROUTINE DOES PERFORM ALL REQUIRED MUTEX LOCKING AND PROTECTION CHECKING.
;
; INPUTS:
;
;	R0 = LENGTH OF LOGICAL NAME STRING.
;	R1 = ADDRESS OF LOGICAL NAME STRING.
;	R2 = LENGTH OF TABLE NAME STRING.
;	R3 = ADDRESS OF TABLE NAME STRING.
;	R4 = PCB ADDRESS
;	R5 = SEARCH ACCESS MODE IN LOW BYTE, CASELESS FLAG IN BIT 8.
;	R6 = ADDRESS OF OUTPUT BUFFER 
;	     (MUST BE LNM$C_NAMLENGTH + LNMX$T_XLATION BYTES IN SIZE).
;
;
; OUTPUTS:
;
;	R0 LOW BIT CLEAR INDICATES SEARCH FAILURE.
;
;		R0 = SS$_NOLOGNAM - NO LOGICAL NAME MATCH FOUND.
;				  - LOGICAL NAME FOUND BUT TRANSLATION WITH
;				    INDEX 0 DOES NOT EXIST.
;
;		R0 = SS$_NOPRIV	  - LOGICAL NAME WAS FOUND BUT CALLER DOES NOT
;				    HAVE ACCESS TO THE SPECIFIED TABLE.
;
;	R0 LOW BIT SET INDICATES SUCCESS WITH:
;
;		A COPY OF THE LNMX FOR TRANSLATION INDEX 0 IN THE OUTPUT BUFFER.
;
; 	REGISTERS R1 - R3 AND R5 ARE DESTROYED.
;-
 
LNM$SEARCH_ONE::			;SEARCH FOR LOGICAL NAME AND RETURN LNMX
	PUSHL	#SS$_NORMAL		;ASSUME SUCCESS
	SAVIPL				;SAVE CURRENT IPL ON STACK
	PUSHL	R0			;SAVE LOGNAM STRING LENGTH
	BSBW	LNM$LOCKR		;LOCK LOGICAL NAME MUTEX FOR WRITING
	POPL	R0			;RESTORE LOGNAM STRING LENGTH

	.IF NE CA$_MEASURE		;CHECK FOR MEASUREMENT ENABLED
	INCL	L^PMS$GL_LOGNAM		;IF YES COUNT CURRENT TRANSLATION
	.ENDC

	BSBW	LNM$SEARCHLOG		;SEARCH FOR THE LOGICAL NAME
	BLBC	R0,40$			;EXIT ON ANY ERROR

	BBC	#31,R1,1$		;ONLY CHECK ACCESS TO SHAREABLE TABLES
	PUSHL	R1			;SAVE LNMB ADDRESS
	MOVL	LNMB$L_TABLE(R1),R1	;RETRIEVE TABLE HEADER ADDRESS
	MOVL	#ARM$M_READ,R2		;READ ACCESS
	BSBW	LNM$CHECK_PROT		;PERFORM PROTECTION CHECK
	POPL	R1			;RESTORE LNMB ADDRESS
	BLBC	R0,40$			;EXIT ON ANY ERROR

1$:	MOVAB	LNMB$T_NAME(R1),R1	;ADDRESS OF NAME STRING
	MOVZBL	(R1)+,R0		;RETRIEVE SIZE OF NAME STRING
	ADDL2	R0,R1			;POSITION TO FIRST LNMX

5$:	BBS	#LNMX$V_XEND,-		;IS THIS THE LAST TRANSLATION?
		LNMX$B_FLAGS(R1),10$	;IF SO, NO INDEX 0 LNMX SO RETURN ERROR
	TSTB	LNMX$B_INDEX(R1)	;IS THE INDEX 0 LNMX?
	BEQL	20$			;IF SO, GO RETURN LNMX
	BGTR	10$			;IF POSITIVE INDEX THEN GO RETURN ERROR
	MOVZBL	LNMX$T_XLATION(R1),R0	;ELSE RETRIEVE SIZE OF TRANSLATION
	MOVAB	LNMX$T_XLATION+1(R1)[R0],R1 ;POSITION TO NEXT LNMX
	BRB	5$			;GO SEE IF ITS INDEX IS 0

10$:	MOVZWL	#SS$_NOLOGNAM,4(SP)	;ELSE, RETURN THE APPROPRIATE ERROR 
	BRB	30$			;STATUS

20$:	MOVZBL	LNMX$T_XLATION(R1),R0	;RETRIEVE SIZE OF TRANSLATION STRING
	ADDL2	#LNMX$T_XLATION+1,R0	;ADD SIZE OF LNMX OVERHEAD + COUNT FIELD
	PUSHL	R4			;SAVE PCB ADDRESS
	MOVC3	R0,(R1),(R6)		;MOVE ENTIRE LNMX FOR INDEX 0
	POPL	R4			;RESTORE PCB ADDRESS

30$:	BSBW	LNM$UNLOCK		;UNLOCK THE LOGICAL NAME MUTEX
	ENBINT				;RESTORE IPL TO ITS VALUE ON ENTRY
	POPL	R0			;RESTORE STATUS
	RSB				;RETURN
40$:	MOVL	R0,4(SP)		;CHANGE RETURN STATUS TO AN ERROR STATUS
	BRB	30$			;GO RETURN
;	.PAGE

	.SBTTL	LNM$FIRSTTAB	- SEARCH FOR FIRST TABLE NAME
;+
; LNM$FIRSTTAB - SEARCH FOR FIRST TABLE NAME
;
; THIS ROUTINE IS CALLED TO LOOKUP A LOGICAL NAME TABLE NAME.  THE FIRST MATCH
; FOUND IS RETURNED.
; ACCESS TO THE TABLE IS NOT CHECKED.
;
; INPUTS:
;
;	R1 = SEARCH ACCESS MODE IN LOW BYTE, 
;	     CASELESS FLAG IN BIT 8,
;	     HIGH ORDER WORD 0.
;	R2 = LENGTH OF TABLE NAME STRING.
;	R3 = ADDRESS OF TABLE NAME STRING.
;
;	IT IS ASSUMED THAT THE LOGICAL NAME MUTEX IS LOCKED FOR AT LEAST READ 
;	ACCESS.
;
; OUTPUTS:
;
;	R0 LOW BIT CLEAR INDICATES SEARCH FAILURE.
;
;		R0 = SS$_NOLOGTAB - NO LOGICAL NAME TABLE NAME MATCH FOUND.
;		R1 = JUNK.
;
;	R0 LOW BIT SET INDICATES SUCCESS WITH:
;
;		R1 = ADDRESS OF LOGICAL NAME TABLE HEADER.
;
; 	REGISTERS R2 AND R3 ARE MODIFIED.
;	REGISTERS R4 AND R5 ARE PRESERVED.
;-
 
LNM$FIRSTTAB::				;SEARCH FOR LOGICAL NAME TABLE
	PUSHL	R5			;SAVE REGISTER
	SUBL	#RT_K_LENGTH-4,SP	;ALLOCATE RECURSIVE TABLE NAME CONTROL BLOCK
	PUSHL	R1			;ACMODE, CASE FLAG
	MOVL	SP,R5			;ADDRESS OF BLOCK
	BSBW	LNM$SETUP		;SETUP TABLE PROCESSING
	ADDL2	#RT_K_LENGTH,SP		;REMOVE TABLE SEARCH CONTROL BLOCK
	POPL	R5			;RESTORE REGISTER
	BLBS	R0,10$			;RETURN IF SUCCESSFUL
	MOVZWL	#SS$_NOLOGTAB,R0	;ELSE SETUP TO RETURN APPROPRIATE ERROR
10$:	RSB				;RETURN, STATUS IN R0

;	.PAGE

	.SBTTL	LNM$PRESEARCH	- FIND FIRST CANDIDATE NAME
;+
; LNM$PRESEARCH - FIND FIRST CANDIDATE LOGICAL NAME
;
; THIS ROUTINE IS CALLED TO SEARCH A LOGICAL NAME HASH TABLE FOR THE FIRST
; CANDIDATE LOGICAL NAME MATCH.  IF A LOGICAL NAME TABLE IS SPECIFIED, THE
; SEARCH CONTINUES TO A SPECIFIC NAME.
;
; INPUTS:
;
;	R1 = HASH TABLE ADDRESS (IF TABLE HEADER ADDRESS IS MISSING)
;	R3 = ADDRESS OF NAME TRANSLATION (NT) BLOCK
;
;	NAME TABLE BLOCK REQUIREMENTS:
;
;		NT_W_RT		: MUST BE INITIALIZED
;		NT_W_HASH	: MAY BE INITIALIZED OR 0
;		NT_L_NAMLEN	: MUST BE INITIALIZED
;		NT_L_NAMADR	: MUST BE INITIALIZED
;		NT_L_TABID	: MAY BE INITIALIZED OR 0
;		NT_L_THREAD	: UNINITIALIZED
;
;	IT IS ASSUMED THAT THE LOGICAL NAME MUTEX IS LOCKED FOR AT LEAST READ 
;	ACCESS.
;
; OUTPUTS:
;
;	R0 LOW BIT CLEAR INDICATES SEARCH FAILURE.
;
;		R0 = SS$_NOLOGNAM - NO LOGICAL NAME MATCH FOUND.
;		R1 = ADDRESS OF LOGICAL NAME BLOCK ON WHICH SEARCH FAILED.
;
;		NAME TABLE BLOCK REQUIREMENTS:
;
;			NT_W_RT		: UNCHANGED
;			NT_W_HASH	: VALID
;			NT_L_NAMLEN	: UNCHANGED
;			NT_L_NAMADR	: UNCHANGED
;			NT_L_TABID	: UNCHANGED
;			NT_L_THREAD	: ADDRESS OF LOGICAL NAME BLOCK 
;					  PRECEEDING THE BLOCK ON WHICH THE
;					  SEARCH FAILED.
;
;	R0 LOW BIT SET INDICATES SUCCESS WITH:
;
;		R1 = ADDRESS OF LOGICAL NAME BLOCK THAT CONTAINS MATCH.
;
;		NAME TABLE BLOCK REQUIREMENTS:
;
;			NT_W_RT		: UNCHANGED
;			NT_W_HASH	: VALID
;			NT_L_NAMLEN	: UNCHANGED
;			NT_L_NAMADR	: UNCHANGED
;			NT_L_TABID	: UNCHANGED
;			NT_L_THREAD	: ADDRESS OF LOGICAL NAME BLOCK 
;					  PRECEEDING THE BLOCK ON WHICH THE
;					  SEARCH SUCCEEDED.
;
;	R3,R4,R5 PRESERVED.
;-
 	.ENABLE	LSB

LNM$PRESEARCH::				;SEARCH FOR LOGICAL NAME
	MOVL	NT_L_TABID(R3),R0	;ADDRESS OF TABLE HEADER
	BEQL	10$			;BRANCH IF NOT SPECIFIED
	MOVL	LNMTH$L_HASH(R0),R1	;HASH TABLE ADDRESS
10$:	MOVZWL	NT_W_HASH(R3),R0	;HASH FUNCTION AVAILABLE?
	BNEQ	20$			;BRANCH IF YES
	PUSHL	R1			;SAVE HASH TABLE ADDRESS
	MOVQ	NT_L_NAMLEN(R3),R0	;NAME DESCRIPTOR
	BSBW	LNM$HASH		;COMPUTE HASH FUNCTION
	MOVW	R0,NT_W_HASH(R3)	;SAVE HASH FUNCTION
	POPL	R1			;RESTORE HASH TABLE ADDRESS
20$:	BICL2	LNMHSH$L_MASK(R1),R0	;MASK OFF UNWANTED BITS OF HASH FUNCTION
	MOVAL	LNMHSH$K_BUCKET(R1)[R0],-;COMPUTE ADDRESS OF HASH BUCKET AND 
		R1			;STORE ITS ADDRESS AS ADDRESS OF 
	ASSUME	LNMB$L_FLINK,EQ,0	;PREVIOUS LNMB IN NT_L_THREAD
	BRB	30$			;RUN DOWN HASH CHAIN AND RETURN
	
;	.PAGE

	.SBTTL	LNM$CONTSEARCH	- FIND NEXT CANDIDATE NAME
;+
; LNM$CONTSEARCH - FIND NEXT CANDIDATE LOGICAL NAME
;
; THIS ROUTINE IS CALLED TO SEARCH A LOGICAL NAME HASH BUCKET FOR THE NEXT
; CANDIDATE LOGICAL NAME MATCH.
;
; INPUTS:
;
;	R3 = ADDRESS NAME TABLE BLOCK.
;
;	NAME TABLE BLOCK REQUIREMENTS:
;
;		NT_W_R5		: MUST BE INITIALIZED
;		NT_W_HASH	: MUST BE INITIALIZED
;		NT_L_NAMLEN	: MUST BE INITIALIZED
;		NT_L_NAMADR	: MUST BE INITIALIZED
;		NT_L_TABID	: MUST BE INITIALIZED
;		NT_L_THREAD	: MUST BE INITIALIZED
;			ADDRESS OF PREVIOUS LNMB$ BLOCK - 
;			SEARCH CONTINUES WITH THE FOLLOWING ENTRY.
;
;	IT IS ASSUMED THAT THE LOGICAL NAME MUTEX IS LOCKED FOR AT LEAST READ 
;	ACCESS.
;
; OUTPUTS:
;
;	R0 LOW BIT CLEAR INDICATES SEARCH FAILURE.
;
;		R0 = SS$_NOLOGNAM - NO LOGICAL NAME MATCH FOUND.
;		R1 = ADDRESS OF LOGICAL NAME BLOCK ON WHICH SEARCH FAILED.
;
;		NT_L_THREAD CONTAINS ADDRESS OF PREVIOUS LNMB BLOCK
;
;	R0 LOW BIT SET INDICATES SUCCESS WITH:
;
;		R1 = ADDRESS OF LOGICAL NAME BLOCK THAT CONTAINS MATCH.
;
;		NT_L_THREAD CONTAINS ADDRESS OF PREVIOUS LNMB BLOCK
;
;	R3,R4,R5 ARE PRESERVED.
;-
 
LNM$CONTSEARCH::			;SEARCH FOR LOGICAL NAME
	ASSUME	LNMB$L_FLINK,EQ,0
	MOVL	NT_L_THREAD(R3),R1	;ADDRESS OF PREVIOUS LOGICAL NAME BLOCK
	BBS	#NT_V_MODIFY,(R3),35$	;CAN HASH BUCKET CHANGE?
	MOVL	LNMB$L_FLINK(R1),R1	;IF NOT THEN RETRIEVE ADDRESS  NEXT LNMB
	BRB	55$			;AND SKIP FIRST CMPC3

30$:	MOVL	R1,NT_L_THREAD(R3)	;SAVE ADDRESS OF PREVIOUS BLOCK
35$:	MOVL	LNMB$L_FLINK(R1),R1	;GET ADDRESS OF NEXT LOGICAL NAME BLOCK
	BEQL	70$			;BRANCH IF NO NEXT BLOCK
	CMPB	NT_L_NAMLEN(R3), -	;LENGTH'S MATCH?
		LNMB$T_NAME(R1)
	BGTRU	30$			;KEEP LOOKING DOWN CHAIN
	BLSSU	70$			;NO MATCH
	PUSHL	R3			;SAVE SEARCH PARAMETERS
	PUSHL	R1
	CMPC3	NT_L_NAMLEN(R3), -	;LOGICAL NAME STRINGS MATCH?
		@NT_L_NAMADR(R3), -
		LNMB$T_NAME+1(R1) 
	BBC	#NT_V_CASE,@4(SP),50$	;BRANCH IF CASED SEARCH
40$:	BEQL	50$			;BRANCH ON MATCH
	MOVZBL	(R1)+,R0		;GET CASELESS CHARACTER
	MOVB	G^EXE$UPCASE_DAT[R0],-(SP)
	MOVZBL	(R3)+,R0		;GET CASELESS CHARACTER
	CMPB	(SP)+,G^EXE$UPCASE_DAT[R0]
	BNEQ	50$			;BRANCH IF DIFFERENT IN MORE THAN CASE
	DECL	R2			;PASS OVER THESE CHARACTERS
	CMPC3	R2,(R1),(R3)		;RESUME COMPARISON
	BRB	40$			;CONTINUE CASELESS COMPARISON
50$:	POPR	#^M<R1,R3>		;RETRIEVE SEARCH PARAMETERS
	BEQLU	55$			;IF EQL FOUND IT
	BGTRU	30$			;IF GTR KEEP SEARCHING
	BBS	#NT_V_CASE,(R3),30$	;BRANCH TO CONTINUE IF CASED SEARCH
70$:	MOVZWL	#SS$_NOLOGNAM,R0	;SET NO LOGICAL NAME MATCH
	RSB				;EXIT

55$:	MOVL	NT_L_TABID(R3),R0	;RETRIEVE TARGET TABLE HEADER ADDRESS
	BEQL	60$			;DONE IF IGNORING TABLE
	CMPL	R0,LNMB$L_TABLE(R1)	;COMPARE TABLE
	BGTRU	30$			;CONT IF NOT YET REACHED TARGET TABLE
	BLSSU	70$			;DONE IF PASSED TARGET TABLE
	CMPB	NT_B_ACMODE(R3), -	;COMPARE ACCESS MODES
		LNMB$B_ACMODE(R1)
	BLSSU	30$			;CONT IF NOT YET REACHED ACCESS MODE

60$:	MOVL	#SS$_NORMAL,R0		;MATCH FOUND
	RSB				;EXIT

	.DISABLE 	LSB
;	.PAGE

	.SBTTL	LNM$HASH	- HASHING ALGORITHM
;+
; LNM$HASH - THE HASH FUNCTION
;
; INPUTS:
;	R0 = LENGTH OF NAME.
;	R1 = ADDRESS OF NAME.
;
; OUTPUTS:
;	R0 = RETURN HASH FUNCTION.
;	R1, R2 SCRATCHED.
;	R3,R4,R5 PRESERVED.
;-

LNM$HASH::
	PUSHL	R3			;SAVE REGISTERS
	PUSHL	R0
	ASHL	#-2,R0,R3		;DIVIDE BY FOUR
	BEQL	20$			;NOT EVEN THAT LONG
10$:	BICL3	#^A/AAAA/\^A/aaaa/,-	;FETCH CASELESS CHARACTERS
		(R1)+,R2
	XORL	R2,R0			;XOR IN THE CHARACTERS
	ROTL	#9,R0,R0		;SCRAMBLE A BIT
	SOBGTR	R3,10$			;LOOP UNTIL DONE
20$:	BICL3	#-4,(SP)+,R3		;SAVE REMAINDER OF DIVIDE BY FOUR
	BRB	40$
30$:	BICB3	#^A/A/\^A/a/,(R1)+,R2	;FETCH A CASELESS CHARACTER
	XORB	R2,R0			;XOR IN A CHARACTER
	ROTL	#13,R0,R0		;SCRAMBLE
40$:	SOBGEQ	R3,30$			;LOOP UNTIL DONE
	MULL	#^X71279461,R0		;MULT BY A FUNNY NUMBER
	ROTL	#32-13,R0,R0		;GET SIGNIFICANT BITS
	POPL	R3			;RESTORE REGISTERS
	RSB
;	.PAGE

	.SBTTL	LNM$LOOKUP	- LOOKUP TABLE NAME
;+
; LNM$LOOKUP - LOOKUP TABLE NAME
;
; THIS ROUTINE IS CALLED TO LOOKUP A LOGICAL NAME TABLE NAME.
;
; INPUTS:
;
;	R0 = HASH CODE VALUE OF LOGICAL NAME TABLE STRING (OR 0 IF NOT KNOWN)
;	R2 = LENGTH OF LOGICAL NAME TABLE STRING.
;	R3 = ADDRESS OF LOGICAL NAME TABLE STRING.
;	R5 = ADDRESS OF RECURSION TABLE SEARCH CONTROL BLOCK
;
;	IT IS ASSUMED THAT THE LOGICAL NAME MUTEX IS LOCKED FOR AT LEAST READ 
;	ACCESS.
;
; OUTPUTS:
;
;	R1 POINTS TO THE NAME BLOCK.
;
; R2 AND R3 ARE MODIFIED.
;-

LNM$LOOKUP:
	PUSHL	R5			;SAVE REGISTER
	CLRQ	-(SP)			;NO NAME BLOCK ADDRESS
					;SPACE FOR DIRECTORY TABLE ADDRESS
	MOVQ	R2,-(SP)		;ADDRESS AND LENGTH OF NAME
	MOVW	R0,-(SP)		;HASH CODE VALUE OF TABLE NAME STRING
	MOVW	RT_W_R5(R5),-(SP)	;CASE FLAG AND ACCESS MODE
	MOVL	SP,R3			;ADDRESS OF BLOCK
	MOVAL	L^LNM$AL_DIRTBL,R5	;ADDR OF SYSTEM DIRECTORY TABLE ADDRESS
	BBS	#31,SP,10$		;BRANCH IF SMALL PROCESS
	MOVL	@4(R5),R0		;ADDRESS OF PROCESS DIRECTORY TABLE 
	BEQL	10$			;SKIP IF NO TABLE DEFINED
	MOVL	LNMB$L_TABLE(R0),-	;ADDRESS OF TABLE HEADER OF PROCESS 
		NT_L_TABID(R3)		;DIRECTORY TABLE
	BSBW	LNM$PRESEARCH		;SEARCH PROCESS DIRECTORY
	BLBS	R0,20$			;BRANCH IF NAME FOUND IN PROCESS SPACE
10$:	MOVL	@(R5)+,R0		;ADDRESS OF SYSTEM DIRECTORY TABLE
	MOVL	LNMB$L_TABLE(R0),-	;ADDRESS OF TABLE HEADER OF SYSTEM
		NT_L_TABID(R3)		;DIRECTORY TABLE
	BSBW	LNM$PRESEARCH		;SEARCH SYSTEM DIRECTORY AND RETURN
20$:	ADDL	#NT_K_LENGTH,SP		;FLUSH TRANSLATION BLOCK
	POPL	R5			;RESTORE REGISTER
LRSB:	RSB

;	.PAGE

	.SBTTL	LNM$SETUP	- SETUP TO PROCESS TABLE NAME
;+
; LNM$SETUP - SETUP TO PROCESS LOGICAL NAME TABLE NAME
;
; THIS ROUTINE IS CALLED TO SETUP TO PROCESS A LOGICAL NAME TABLE NAME.
; TABLE SEARCHING IS INITIALIZED.
;
; INPUTS:
;
;	R2 = LENGTH OF LOGICAL NAME TABLE STRING.
;	R3 = ADDRESS OF LOGICAL NAME TABLE STRING.
;	R5 = ADDRESS OF RECURSIVE TABLE NAME TRANSLATION BLOCK
;		WITH RT_W_R5 FIELDS INITIALIZED
;
;	IT IS ASSUMED THAT THE LOGICAL NAME MUTEX IS LOCKED FOR AT LEAST READ 
;	ACCESS.
;
; OUTPUTS:
;
;	R0 CONTAINS ERROR STATUS FROM SEARCHING.
;		R0 = SS$_NOLOGNAM - NO LOGICAL NAME MATCH FOUND.
;		R2,R3,R5 ARE MODIFIED.
;		R4 IS PRESERVED.
;
;	R0 LOW BIT SET INDICATES SUCCESS WITH:
;		R1 = ADDRESS OF LOGICAL NAME TABLE HEADER.
;		R2 = LENGTH OF ACTUAL LOGICAL NAME TABLE STRING
;		R3 = ADDRESS OF ACTUAL LOGICAL NAME TABLE STRING
;		R5 = ADDRESS OF CONTROL BLOCK.
;-

LNM$SETUP::
	BICB2	#RT_M_TERM,-		;CLEAR LAST TRANSLATION BIT
		RT_B_FLAGS(R5)
	CLRB	RT_B_DEPTH(R5)		;INITIALIZE RECURSION DEPTH TO 0
	MOVB	#RT_C_MAXTRIES,-	;INITIALIZE MAXIMUM NUMBER OF TRIES
		RT_B_TRIES(R5)
	CLRL	R0			;HASH CODE VALUE OF INITIAL TABLE NAME
					;STRING IS NOT KNOWN
	BSBW	LNM$LOOKUP		;LOOKUP THE INITIAL NAME
	BLBC	R0,LRSB			;NO SUCH NAME
	ADDL3	#LNMB$T_NAME,R1,-	;SAVE INITIAL LNMB IN RECURSION TABLE
		RT_L_STACK(R5)		; AS THE STARTING POINT OF TRANSLATIONS
	BSBW	LNM$TBL_CACHE		;CHECK THE TABLE TRANSLATION CACHE
	MOVL	R0,RT_L_CACHEPTR(R5)	;SAVE CACHE POINTER
	BEQL	LNM$TABLE_SRCH		;USE LONG WAY IF NO CACHE ENTRY
	MNEGB	#1,LNMC$B_CACHEINDX(R0)	;START WITH INITIAL ENTRY
;	BRB	LNM$TABLE		; AND DROP INTO LNM$TABLE	

;	.PAGE

	.SBTTL	LNM$TABLE	- PROCESS LOGICAL NAME TABLE
;+
; LNM$TABLE - PROCESS LOGICAL NAME TABLE NAME
;
; THIS ROUTINE IS CALLED TO PROCESS A LOGICAL NAME TABLE NAME.
; THE TABLE NAME TRANSLATION CACHE IS USED IF POSSIBLE, ELSE
; THE NAME IS RECURSIVELY TRANSLATED.  A CALLBACK IS PERFORMED
; FOR EVERY TABLE THAT IS FOUND.
;
; A BASIC ASSUMPTION THAT THIS ROUTINE MAKES IS THAT IT IS CALLED FIRST
; THROUGH LNM$SETUP TO INITIALIZE THE RECURSION TABLE BEFORE BEING CALLED
; DIRECTLY SUBSEQUENT TIMES.
;
; INPUTS:
;
;	R5 = ADDRESS OF TABLE NAME TRANSLATION BLOCK
;		ALL FIELDS OF THE BLOCK MUST BE INITIALIZED.
;
;	IT IS ASSUMED THAT THE LOGICAL NAME MUTEX IS LOCKED FOR AT LEAST READ 
;	ACCESS.
;
; OUTPUTS:
;
;	R0 CONTAINS ERROR STATUS FROM SEARCHING.
;		R0 = SS$_NOLOGNAM - NO LOGICAL NAME MATCH FOUND.
;		R2,R3,R5 ARE MODIFIED.
;		R4 IS PRESERVED.
;
;	R0 LOW BIT SET INDICATES SUCCESS WITH:
;		R1 = ADDRESS OF LOGICAL NAME TABLE HEADER.
;		R2 = LENGTH OF ACTUAL LOGICAL NAME TABLE STRING
;		R3 = ADDRESS OF ACTUAL LOGICAL NAME TABLE STRING
;		R5 = ADDRESS OF CONTROL BLOCK.
;
;-

LNM$TABLE::
	MOVL	RT_L_CACHEPTR(R5),R2	;GET CACHE POINTER
	BEQL	LNM$TABLE_SRCH		;USE RECURSIVE METHOD IF NO CACHE
	INCB	LNMC$B_CACHEINDX(R2)	;GO TO NEXT ENTRY
	MOVZBL	LNMC$B_CACHEINDX(R2),R3	;EXTRACT INDEX NUMBER
	CMPB	R3,#LNMC$K_NUM_ENTRIES	;OFF THE END?
	BGEQU	40$			;NOPE, SO USE THIS ENTRY
	MOVL	LNMC$L_ENTRY(R2)[R3],R1	;GET ENTRY
	BEQL	20$			;IS THERE ONE?

	ADDL3	#1,R1,R0		;WAS THIS THE END FLAG?
	BEQL	10$			;THEN WE GOT ONE
	MOVZWL	#SS$_NORMAL,R0		;SUCCESS!
	RSB

10$:	MOVZWL	#SS$_NOLOGNAM,R0	;RETURN TABLES ALL DONE
	RSB	

;
; NO ENTRY - TWO POSSIBLE CASES:
;  1.	WE JUST RAN OFF THE END OF THE VALID ONES AND
;	NEED TO GO BACK TO THE BEGINNING AND REBUILD IT ALL.
;	IN THIS CASE THE RECURSION TABLE IS STILL IN THE INITIALIZED STATE
;	AND THE RECURSION DEPTH IS ZERO.
;
;  2.	WE ARE BUILDING THEM AS WE GO.
;	IN THIS CASE THE RECURSION TABLE IS CURRENT AND THE CACHE INDEX
;	IS CORRECT.
;

20$:	TSTB	RT_B_DEPTH(R5)		;RECURSION DEPTH 0?
	BNEQ	30$			;NOPE
	ADDL3	LNMC$L_TBLADDR(R2),-	;GET POINTER TO TABLE NAME
		#LNMB$T_NAME,R1
	CMPL	R1,RT_L_STACK(R5)	;INITIAL STATE?
	BNEQ	30$			;NO, SO PROCEED
	CLRB	LNMC$B_CACHEINDX(R2)	;GO BACK TO START
30$:	BSBB	LNM$TABLE_SRCH		;FIND NEXT (OR FIRST)
	MOVL	RT_L_CACHEPTR(R5),R2	;GET CACHE POINTER
	MOVZBL	LNMC$B_CACHEINDX(R2),R3	;EXTRACT INDEX NUMBER
	MOVL	R1,LNMC$L_ENTRY(R2)[R3]	;STORE TABLE HEADER ADDR
	CLRL	LNMC$L_ENTRY+4(R2)[R3]	;CLEAR NEXT
	RSB				;RETURN

40$:	CLRL	RT_L_CACHEPTR(R5)	;GIVE UP ON THE CACHE
;	BRB	LNM$TABLE_SRCH		;AND USE THE LONG METHOD

;	.PAGE

	.SBTTL	LNM$TABLE_SRCH	- PROCESS LOGICAL NAME TABLE
;+
; LNM$TABLE_SRCH - PROCESS LOGICAL NAME TABLE NAME
;
; THIS ROUTINE IS CALLED TO PROCESS A LOGICAL NAME TABLE NAME.
; THE NAME IS RECURSIVELY TRANSLATED.  A CALLBACK IS PERFORMED
; FOR EVERY TABLE THAT IS FOUND.
;
; A BASIC ASSUMPTION THAT THIS ROUTINE MAKES IS THAT IT IS CALLED FIRST
; THROUGH LNM$SETUP TO INITIALIZE THE RECURSION TABLE BEFORE BEING CALLED
; DIRECTLY SUBSEQUENT TIMES.
;
; INPUTS:
;
;	R5 = ADDRESS OF TABLE NAME TRANSLATION BLOCK
;		ALL FIELDS OF THE BLOCK MUST BE INITIALIZED.
;
;	IT IS ASSUMED THAT THE LOGICAL NAME MUTEX IS LOCKED FOR AT LEAST READ 
;	ACCESS.
;
; OUTPUTS:
;
;	R0 CONTAINS ERROR STATUS FROM SEARCHING.
;		R0 = SS$_NOLOGNAM - NO LOGICAL NAME MATCH FOUND.
;		R2,R3,R5 ARE MODIFIED.
;		R4 IS PRESERVED.
;
;	R0 LOW BIT SET INDICATES SUCCESS WITH:
;		R1 = ADDRESS OF LOGICAL NAME TABLE HEADER.
;		R2 = LENGTH OF ACTUAL LOGICAL NAME TABLE STRING
;		R3 = ADDRESS OF ACTUAL LOGICAL NAME TABLE STRING
;		R5 = ADDRESS OF CONTROL BLOCK.
;
;-

LNM$TABLE_SRCH:
10$:	BICB2	#RT_M_TERM,RT_B_FLAGS(R5) ;CLEAR TERMINAL SEEN BIT
	CVTBL	RT_B_DEPTH(R5),R0	;RECURSION DEPTH
	BLSS	60$			;BRANCH IF NOTHING LEFT TO SCAN
	MOVL	RT_L_STACK(R5)[R0],R1	;ADDRESS OF PREVIOUS TRANSLATION STRING

20$:	DECB	RT_B_TRIES(R5)		;DECREMENT NUMBER OF TRIES LEFT
	BEQL	70$			;DONE IF TRIES REACHES ZERO

	MOVZBL	(R1)+,R0		;LENGTH OF PREVIOUS TRANSLATION STRING
	ADDL2	R0,R1			;POSITION PAST PREVIOUS TRANSLATION

	BBS	#LNMX$V_XEND,-		;LAST TRANSLATION?
		LNMX$B_FLAGS(R1),50$	;YES - GO DECREMENT DEPTH AND CONTINUE
	CVTBL	LNMX$B_INDEX(R1),R2	;GET TRANSLATION INDEX
	BLSS	40$			;BRANCH IF SPECIAL VALUE
	BBS	#RT_V_TERM,(R5),80$	;ERROR IF EXPECTING TABLE HEADER

	CMPB	#LNM$C_MAXDEPTH,-	;RECURSED TOO DEEPLY?
		RT_B_DEPTH(R5)		;ERROR OF OVERLY DEEP
	BLEQ	70$

	CVTBL	RT_B_DEPTH(R5),R0	;RECURSION DEPTH
	MOVAB	LNMX$T_XLATION(R1),R3	;TRANSLATION COUNTED STRING ADDRESS
	MOVL	R3,RT_L_STACK(R5)[R0]	;SAVE RECURSION INFO BEFORE LOOKUP
	INCB	RT_B_DEPTH(R5)		;INCREMENT RECURSION DEPTH FOR NEXT TIME
	MOVZBL	(R3)+,R2		;TRANSLATION STRING LENGTH AND ADDRESS
	MOVZWL	LNMX$W_HASH(R1),R0	;RETRIEVE TRANSLATION'S HASH CODE VALUE

	BBC	#LNMX$V_TERMINAL,-	;IS THIS TRANSLATION MARKED TERMINAL?
		LNMX$B_FLAGS(R1),30$	;NO  - GO DO LOOKUP
	BISB2	#RT_M_TERM,-		;YES - ALLOW ONE AND ONLY ONE MORE
		RT_B_FLAGS(R5)		;      TRANSLATION

30$:	BSBW	LNM$LOOKUP		;LOOKUP LOGICAL NAME TABLE NAME
	BLBC	R0,50$			;GO DECR DEPTH AND CONTINUE IF NOT FOUND
	ADDL2	#LNMB$T_NAME,R1		;POINT TO COUNTED NAME STRING
	BRB	20$			;CONTINUE WITH FIRST TRANSLATION

40$:	ADDL2	#LNMX$T_XLATION,R1	;ADDRESS OF COUNTED TRANSLATION STRING
	CMPB	R2,#LNMX$C_TABLE	;TABLE NAME?
	BNEQ	20$			;IGNORE THIS TRANSLATION
	INCL	R1			;POSITION TO TABLE HEADER
	DECB	RT_B_DEPTH(R5)		;DECREMENT RECURSION DEPTH
	MOVL	#SS$_NORMAL,R0		;NORMAL STATUS
	RSB				;RETURN WITH R1 = TABLE HEADER ADDRESS

50$:	DECB	RT_B_DEPTH(R5)		;DECREMENT RECURSION DEPTH
	BGEQ	10$			;RESUME

60$:	MNEGL	#1,R1			;FLAG LAST TABLE
	MOVZWL	#SS$_NOLOGNAM,R0	;HAVE SCANNED ALL TABLE
	RSB
70$:	MOVZWL	#SS$_TOOMANYLNAM,R0	;RECURSION TOO DEEP
	BRB	90$			;RETURN
80$:	MOVZWL	#SS$_IVLOGTAB,R0	;INVALID TABLE NAME
90$:	CLRL	R1
	RSB

;	.PAGE

	.SBTTL	LNM$TBL_CACHE	- SEARCH LOGICAL NAME TABLE TRANSLATION CACHE
;+
; LNM$TBL_CACHE	- SEARCH LOGICAL NAME TABLE TRANSLATION CACHE
;
; THIS ROUTINE IS CALLED TO SEARCH THE LOGICAL NAME TABLE NAME
; TRANSLATION CACHE.  IF A CACHE ENTRY EXISTS FOR THIS LOGICAL NAME,
; THEN THE ENTRY IS VALIDATED AND RETURNED.   IF INVALID OR NO ENTRY,
; A NEW ENTRY IS SELECTED, INITIALIZED AND RETURNED.
;
; INPUTS:
;
;	R1 = ADDRESS OF TABLE NAME LOGICAL NAME BLOCK
;
;	IT IS ASSUMED THAT THE LOGICAL NAME MUTEX IS LOCKED FOR AT LEAST READ 
;	ACCESS.
;
; OUTPUTS:
;
;	R0 CONTAINS ADDRESS OF CACHE ENTRY TO USE OR 0
;	   CACHE ENTRY MAY OR MAY NOT BE VALID
;
;-

LNM$TBL_CACHE:
	BBS	#31,SP,100$		;NO CACHE IF NO P1 SPACE

	MOVAB	@#CTL$GQ_LNMTBLCACHE,R2	;GET QUEUE HEADER ADDR
	MOVL	R2,R0			;POINT TO FIRST ENTRY
10$:	MOVL	LNMC$L_FLINK(R0),R0	;GET NEXT ENTRY
	CMPL	R2,R0			;BACK TO QUEUE HEADER?
	BEQL	80$			;YES, THEN MAKE A NEW ONE
	CMPL	R1,LNMC$L_TBLADDR(R0)	;IS THIS THE ONE?
	BNEQ	10$			;TRY NEXT

	REMQUE	(R0),R0			;REMOVE ENTRY
	CMPL	LNMC$L_PROCDIRSEQ(R0),-	;IS PROCESS DIRECTORY VALID?
		@#CTL$GL_LNMDIRSEQ
	BNEQ	40$			;NOPE, MUST RE-INIT ENTRY
	CMPL	LNMC$L_SYSDIRSEQ(R0),-	;IS SYSTEM DIRECTORY VALID?
		@#LNM$GL_SYSDIRSEQ
	BEQL	50$			;A CACHE HIT!
40$:	MOVL	R1,LNMC$L_TBLADDR(R0)	;SET TABLE NAME ADDR
	MOVL	@#CTL$GL_LNMDIRSEQ,-	;SET NEW PROCESS DIRECTORY SEQ NUM.
		LNMC$L_PROCDIRSEQ(R0)
	MOVL	@#LNM$GL_SYSDIRSEQ,-	;SET NEW SYSTEM DIRECTORY SEQ NUM.
		LNMC$L_SYSDIRSEQ(R0)
	CLRQ	LNMC$L_ENTRY(R0)	;CLEAR FIRST ENTRIES
50$:	INSQUE	(R0),(R2)		;INSERT AT HEAD OF QUEUE
	RSB

80$:	REMQUE	@LNMC$L_BLINK(R2),R0	;TAKE OLDEST ENTRY
	BVC	40$			;IF THERE ARE ANY
100$:	CLRL	R0			;NO ENTRY
	RSB

;	.PAGE

	.SBTTL	LNM$PROBER	- PROBE LOGICAL NAME DESCRIPTOR FOR READ ACCESS
;+
; LNM$PROBER - PROBE LOGICAL NAME DESCRIPTOR FOR READ ACCESS
;
; THIS ROUTINE IS CALLED TO PROBE A DESCRIPTOR FOR A LOGICAL NAME FOR READ
; ACCESS.  IF CHECK THE LENGTH OF THE DESCRIPTOR FOR VALIDITY AS WELL
; AS CHECKING ACCESS TO THE DESCRIBED BUFFER.
; ACCESS TO THE DESCRIPTOR IS NOT CHECKED.
;
; INPUTS:
;
;	R0 = ADDRESS OF LOGICAL NAME STRING DESCRIPTOR
;
; OUTPUTS:
;
;	R0 LOW BIT CLEAR INDICATES FAILURE TO TRANSLATE.
;
;		R0 = SS$_ACCVIO - ACCESS VIOLATION.
;		R0 = SS$_IVLOGNAM - INVALID LOGICAL NAME.
;			R1 AND R2 ARE MODIFIED.
;
;	R0 LOW BIT SET INDICATES SUCCESS.
;
;		R0 = SS$_NORMAL - DESCRIPTOR IS VALID
;			R1 = LENGTH OF BUFFER IN BYTES.
;			R2 = ADDRESS OF BUFFER.
;-
LNM$PROBER::
	MOVQ	(R0),R1			;FETCH DESCRIPTOR
	MOVZWL	R1,R1			;GET LENGTH OF LOGICAL NAME STRING
	BEQL	10$			;IF EQL INVALID LOGICAL NAME
	ASSUME  LNM$C_NAMLENGTH LE 512
	CMPW	R1,#LNM$C_NAMLENGTH	;LEGAL NAME STRING LENGTH?
	BGTRU	10$			;IF LEQU YES
	IFNORD	R1,(R2),20$		;CAN LOGICAL NAME STRING BE READ?
	MOVL	#SS$_NORMAL,R0		;SUCCESS STATUS
	RSB
10$:	MOVZWL	#SS$_IVLOGNAM,R0	;SET INVALID LOGICAL NAME
	RSB
20$:	MOVZWL	#SS$_ACCVIO,R0		;SET ACCESS VIOLATION
	RSB

;	.PAGE

	.SBTTL	LNM$LOCKR	- LOCK LOGICAL NAME TABLE FOR READ ACCESS
	.SBTTL	LNM$LOCKW	- LOCK LOGICAL NAME TABLE FOR WRITE ACCESS
;+
; LNM$LOCKR - LOCK LOGICAL NAME TABLE FOR READ ACCESS
; LNM$LOCKW - LOCK LOGICAL NAME TABLE FOR WRITE ACCESS
;
; THESE ROUTINES ARE CALLED TO SYNCHRONIZE ACCESS TO LOGICAL NAME TABLES.
;
; INPUTS:
;
;	R4 = CURRENT PROCESS PCB ADDRESS.
;
; OUTPUTS:
;
;	REGISTER R0 IS MODIFIED.
;	REGISTERS R1, R2, AND R3 ARE PRESERVED ACROSS CALL.
;-
 
	.ENABL	LSB
LNM$LOCKR::				;LOCK LOGICAL NAME TABLE FOR READ ACCESS
	PUSHAB	L^SCH$LOCKR		;SET ADDRESS OF LOCK ROUTINE
	BRB	10$			;
LNM$LOCKW::				;LOCK LOGICAL NAME TABLE FOR WRITE ACCESS
	PUSHAB	L^SCH$LOCKW		;SET ADDRESS OF LOCK ROUTINE
	BRB	10$			;
;	.PAGE

	.SBTTL	LNM$UNLOCK	- UNLOCK LOGICAL NAME TABLE
;+
; LNM$UNLOCK - UNLOCK NAME TABLE
;
; THIS ROUTINE IS CALLED TO UNLOCK LOGICAL NAME TABLES AND ALLOW ACCESS BY
; OTHER PROCESSES.
;
; INPUTS:
;
;	R4 = CURRENT PROCESS PCB ADDRESS.
;
; OUTPUTS:
;
;	R0, R1, R2, AND R3 ARE MODIFIED.
;
;-
 
LNM$UNLOCK::				;UNLOCK NAME TABLE
	PUSHAB	L^SCH$UNLOCK		;SET ADDRESS OF LOCK ROUTINE
10$:	MOVAL	L^LNM$AL_MUTEX,R0	;GET ADDRESS OF LOGICAL NAME TABLE MUTEX
	RSB				;PERFORM SYNCHRONIZATION OPERATION
	.DSABL	LSB
 
	.END
