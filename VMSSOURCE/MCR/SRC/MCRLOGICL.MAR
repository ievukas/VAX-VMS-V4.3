	.TITLE	MCRLOGICL - LOGICAL NAME MCR COMMAND EXECUTION
	.IDENT	'V04-000'
 
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; W. H. BROWN 4-JAN-1978
;
; Modified:
;
;	V03003	MAJ0005		Melanie Johnson	07-Mar-1983
;		Eliminate the use of the macro, $CLIDEFQUALDEAL.  Resolve
;		those symbols at link time instead.
;
;	V03002	MAJ0004		Melanie Johnson	14-Jan-1983
;		Only write passback structure when in a subprocess.
;
;	V03001	MAJ0003		Melanie Johnson	16-Nov-1982
;		If this is a subprocess fill in the passback structure
;		for ALLOCATE,DEALLOC, and ASN;  for the ALLOC and DEALLOC
;		commands, defer actual allocation/deallocation to the parent
;		process.
;
;	V002	MAJ0002		Melanie Johnson 22-Feb-82
;		Check token length rather than PTR_V_EQUAL (equal sign
;		seen bit) to determine when to deassign.
;
;	V001	MAJ0001		Melanie Johnson	04-Jan-82
;		Reference PTR_V_EQUAL as a bit in PTR_L_DESCR(R10). It is no
;		longer bit 0.
;
; LOGICAL NAME MCR COMMAND EXECUTION
;
;	ALLOCATE DEVICE
;	ASSIGN/DEASSIGN LOGICAL NAME
;	DEALLOCATE DEVICE
;	DEFINE LOGICAL NAME
;
; MACRO LIBRARY CALLS
;
 
	DEFCMDWRK			; DEFINE WORK AREA OFFSETS
	DEFERRCOD			; DEFINE ERROR/STATUS VALUES
	DEFPTRDSC			; DEFINE RESULT PARSE DESCRIPTOR FORMAT
	$LOGDEF				; DEFINE LOG OFFSETS
	$PSLDEF				; DEFINE PROCESSOR STATUS FIELDS
	$SSDEF				; DEFINE SYSTEM STATUS VALUES
	$PBKDEF				; DEFINE PASSBACK STRUCTURE
	CLI$K_ASN_TERM==3
	CLI$K_ASN_GROU==2
	CLI$K_ASN_GBL ==1
 
;
; LOCAL DATA
;
 
	.PSECT	MCR$ZCODE,BYTE,RD,NOWRT
ALLOCATE:				; ALLOCATE TEXT
	.ASCII	/ ALLOCATED/		; 
A:					; 
SUPERSEDE:				; LOGICAL NAME SUPERSEDED MESSAGE
	.ASCII	/  PREVIOUS LOGICAL NAME ASSIGNMENT REPLACED/ ; 
B:					; 
	.PAGE
	.SBTTL	ALLOCATE DEVICE
;+
; MCR$ALLOCATE - ALLOCATE DEVICE
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO EXECUTE THE ALLOCATE MCR
; COMMAND.
;
; INPUTS:
;
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R10 = RESULT PARSE DESCRIPTOR TABLE POINTER.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;	FP = BASE ADDRESS OF COMMAND WORK AREA.
;
; OUTPUTS:
;
;	THE SPECIFIED DEVICE IS ALLOCATED AND ASSIGNED THE SPECIFIED LOGICAL
;	NAME. IF THE LOGICAL NAME WAS PREVIOUSLY ASSIGNED, THEN A MESSAGE TO
;	THAT EFFECT IS WRITTEN TO THE OUTPUT STREAM.
;-
 
	.ENABL	LSB
MCR$ALLOCATE::				; ALLOCATE DEVICE
;
; IF THIS IS A SUBPROCESS, WRITE THE PASSBACK STRUCTURE
;
	TSTL	PRC_L_OWNRPID(R11)	; IS THIS A SUBPROCESS?
	BEQL	5$			; IF EQL, NO
	MOVL	PRC_L_PBKPTR(R11),R6	; GET PASSBACK STRUCTURE POINTER
	SETBIT	PBK$V_PASSBACK,PBK$W_FLAGS(R6) ; SET PASSBACK FLAG
	MOVZBL	#PBK$C_ALLOC,PBK$L_COMMANDS(R6) ; THIS IS THE ALLOCATE COMMAND
	MOVAL	PBK$A_INFO(R6),R6	; GET ADDRESS OF PASSBACK INFO BUFFER
5$:	BSBW	GETDEV			; GET DEVICE NAME TO ALLOCATE
	$ALLOC_S (R9),(R8),(R8)		; ALLOCATE DEVICE
	BLBS	R0,10$			; IF LBS, OK
	BRW	50$			; ALLOCATION FAILURE
10$:	MOVQ	(R8),-(R9)		; SAVE DEVICE NAME DESCRIPTOR
	ADDL3	(R8)+,(R8),R0		; CALCULATE ADDRESS TO APPEND TEXT
	MOVC	#A-ALLOCATE,ALLOCATE,(R0) ; APPEND TEXT TO DEVICE NAME
	MOVL	(R8),R2			; GET STARTING ADDRESS OF DEVICE NAME
	MOVW	#^A/  /,-(R2)		; INSERT 2 LEADING SPACES
	SUBL3	R2,R3,R1		; CALCULATE LENGTH OF MESSAGE
	MSGOUT				; OUTPUT ALLOCATION MESSAGE
	BSBW	GETDEV			; GET LOGICAL NAME
	BLBC	R0,40$			; BR IF NAME IS HERE
	MOVZBL	#LOG$C_PROCESS,R7	; SET TABLE NUMBER
	BRB	30$			; ELSE EXIT
	.PAGE
	.SBTTL	ASSIGN LOGICAL NAME TO EQUIVALENCE STRING
;+
; MCR$ASSIGN - ASSIGN LOGICAL NAME TO EQUIVALENCE STRING
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO EXECUTE THE ASSIGN MCR
; COMMAND.
;
; INPUTS:
;
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R10 = RESULT PARSE DESCRIPTOR TABLE POINTER.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;	FP = BASE ADDRESS OF COMMAND WORK AREA.
;
; OUTPUTS:
;
;	THE SPECIFIED LOGICAL NAME IS ASSIGNED TO THE SPECIFIED EQUIVALENCE
;	STRING. IF A PREVIOUS LOGICAL ASSIGNMENT IS SUPERSEDED, THEN A
;	MESSAGE TO THAT EFFECT IS WRITTEN TO THE OUTPUT STREAM.
;-
 
MCR$ASSIGN::				; ASSIGN LOGICAL NAME TO EQUIVALENCE STRING
;
; IF THIS IS A SUBPROCESS, WRITE PART OF THE PASSBACK STRUCTURE
;
	TSTL	PRC_L_OWNRPID(R11)	; IS THIS A SUBPROCESS?
	BEQL	20$			; IF EQL, NO
	MOVL	PRC_L_PBKPTR(R11),R6	; GET PASSBACK STRUCTURE POINTER
	SETBIT	PBK$V_PASSBACK,PBK$W_FLAGS(R6) ; SET PASSBACK FLAG
	MOVZBL	#PBK$C_ASN,PBK$L_COMMANDS(R6) ; THIS IS THE ASN COMMAND
	MOVAL	PBK$A_INFO(R6),R6	; GET ADDRESS OF PASSBACK INFO BUFFER
20$:	MOVZBL	#LOG$C_PROCESS,R7	; SET TABLE NUMBER
	BSBW	100$			; SET TABLE NUMBER
	CMPB	R5,#PTR_K_PARAMETR	; IS NEXT DESCRIPTOR FOR A PARAMETER?
	BLEQ	22$			; BR IF NOT EOL NEXT
	BRW	62$			; BR IF EOL
22$:	TSTB	R1			; CHECK RETURNED TOKEN LENGTH
	BEQL	60$			; BR TO DEASSIGN IF EQUIV. NAME IS NULL (EQL)
	COMPSTRING			; REMOVE QUOTES
	MOVQ	R1,-(R9)		; SAVE DESCRIPTOR FOR NAME
;
; IF THIS IS A SUBPROCESS, WRITE PART OF THE PASSBACK STRUCTURE
;
	TSTL	PRC_L_OWNRPID(R11)	; IS THIS A SUBPROCESS?
	BEQL	25$			; IF EQL, NO
	MOVW	R1,(R6)+		; PUT LENGTH OF EQUIV. NAME IN PASSBACK
	MOVC	R1,(R2),(R6)		; COPY EQUIV. NAME INTO PASSBACK
	MOVL	R3,R6			; GET POINTER TO NEXT FREE LOC. IN PASSBACK
25$:	BSBW	100$			; CHECK FOR QUALIFIERS
	STATUS	INSFPRM			; ASSUME INSUFFICIENT PARAMETERS
	CMPB	R5,#PTR_K_PARAMETR	; CHECK FOR REQUIRED PARAMETER
	BNEQ	55$			; BR IF SYNTAX ERROR
	BSBW	SETNAM			; SET LOGICAL NAME
	BSBW	100$			; CHECK FOR QUALIFIERS
	BSBW	CHECK_TAB		; CHECK LOG. NAME TABLE-ONLY PASSBACK FOR PROCESS
30$:	$CRELOG_S R7,(R9),8(R9),#PSL$C_SUPER ; CREATE LOGICAL NAME IN SPECIFIED TABLE
	CMPW	#SS$_SUPERSEDE,R0	; PREVIOUS ASSIGNMENT SUPERSEDED?
	BNEQ	50$			; IF NEQ NO
	MOVZBL	#B-SUPERSEDE,R1		; GET LENGTH OF SUPERSEDE MESSAGE
	MOVAB	SUPERSEDE,R2		; GET ADDRESS OF SUPERSEDE MESSAGE
	MSGOUT				; OUTPUT MESSAGE
40$:	STATUS	NORMAL			; SET NORMAL COMPLETION
50$:	TSTL	PRC_L_OWNRPID(R11)	; IS THIS A SUBPROCESS?
	BEQL	55$			; IF EQL, NO
	MOVL	PRC_L_PBKPTR(R11),R6	; GET PASSBACK STRUCTURE POINTER
	CMPB	#PBK$C_ALLOC,PBK$L_COMMANDS(R6) ; IS THIS THE ALLOCATE COMMAND?
	BNEQ	55$			; IF NEQ, NO
	PUSHL	R0			; PRESERVE EXIT STATUS
	$DALLOC_S 8(R9)			; DEALLOC-LET PARENT ALLOCATE IT
	POPL	R0			; RESTORE EXIT STATUS
55$:	RSB				; 
60$:	TSTL	PRC_L_OWNRPID(R11)	; IS THIS A SUBPROCESS?
	BEQL	61$			; IF EQL, NO
	CLRW	(R6)+			; INDICATE EQUIV. NAME IS NULL
61$:	BSBW	100$			; GET LOGICAL NAME TO DELETE
	CMPB	R5,#PTR_K_PARAMETR	; IS THE NEXT TOKEN A PARAMETER?
62$:	BGTR	65$			; BR IF EOL (DELETE ALL)
	TSTB	R1			; CHECK FOR EXPLICIT NULL LOGICAL NAME
	BEQL	65$			; BR IF EQL TO TREAT AS REQUEST TO DELETE ALL
	BSBW	SETNAM			; SET LOGICAL NAME TO DELETE
	BSBB	100$			; CHECK FOR QUALIFERS
	BSBB	CHECK_TAB		; CHECK LOG. NAME TABLE-ONLY PASSBACK FOR PROCESS
	$DELLOG_S R7,(R9),#PSL$C_SUPER	; DELETE LOGICAL NAMES
	BRB	70$			;
65$:	BBC	#WRK_V_EQUAL,WRK_W_FLAGS(FP),80$ ; BR IF NO "=" SEEN
	CLRL	R9			; NO PARAMETERS - DELETE ALL
	TSTL	PRC_L_OWNRPID(R11)	; IS THIS A SUBPROCESS?
	BEQL	68$			; IF EQL, NO
	CLRL	(R6)+			; INDICATE NO EQUIV., NO LOG. NAME - DELETE ALL
	BSBB	CHECK_TAB		; CHECK LOG. NAME TABLE-ONLY PASSBACK FOR PROCESS
68$:	$DELLOG_S R7,,#PSL$C_SUPER	; DELETE ALL LOGICAL NAMES ENTERED BY USER
70$:	RSB				;
 
;
; COMMAND HAS INVALID SYNTAX
;
 
80$:	STATUS	INSFPRM			; TELL ERROR
	RSB				;
100$:	GETDVAL				; TAKE RESULT DESCRIPTOR APART
	CMPL	R5,#PTR_K_PARMQUAL	; IS THIS FOR A QUALIFIER
	BGTR	110$			; BR IF NO
	MOVAB	LOG$C_SYSTEM-1(R1),R7	; GET THE TABLE NUMBER
	BRB	100$			; LOOK FOR MORE
110$:	RSB

	.DSABL	LSB

;
; IF THIS IS A SUBPROCESS, THIS ROUTINE CHECKS THE LOGICAL NAME TABLE
; BEING REFERENCED, AND TURNS OFF PASSBACK FOR GROUP AND SYSTEM TABLE CHANGES.
;
CHECK_TAB:
	TSTL	PRC_L_OWNRPID(R11)	; IS THIS A SUBPROCESS?
	BEQL	10$			; IF EQL, NO
	CMPB	R7,#LOG$C_PROCESS	; ENTER/DELETE A PROCESS LOG. NAME?
	BEQL	10$			; IF SO, WE NEED TO PASSBACK
	MOVL	PRC_L_PBKPTR(R11),R5	; GET PASSBACK STRUCTURE POINTER
	CLRBIT	PBK$V_PASSBACK,PBK$W_FLAGS(R5) ; NO PASSBACKS FOR GROUP OR SYSTEM
10$:	RSB

	.PAGE
	.SBTTL	DEALLOCATE DEVICE
;+
; MCR$DEALLOCATE - DEALLOCATE DEVICE
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO EXECUTE THE DEALLOCATE
; MCR COMMAND.
;
; INPUTS:
;
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R10 = RESULT PARSE DESCRIPTOR TABLE POINTER.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;	FP = BASE ADDRESS OF COMMAND WORK AREA.
;
; OUTPUTS:
;
;	THE SPECIFIED DEVICE IS DEALLOCATED OR ALL DEVICES ARE DEALLOCATED.
;-
 
MCR$DEALLOCAT::				; DEALLOCATE DEVICE
	TSTL	PRC_L_OWNRPID(R11)	; IS THIS A SUBPROCESS?
	BEQL	5$			; IF EQL, NO
	MOVL	PRC_L_PBKPTR(R11),R6	; GET PASSBACK STRUCTURE POINTER
	SETBIT	PBK$V_PASSBACK,PBK$W_FLAGS(R6) ; SET PASSBACK FLAG
	MOVZBL	#PBK$C_DEALL,PBK$L_COMMANDS(R6) ; THIS IS THE DEALLOCATE COMMAND
	MOVAL	PBK$A_INFO(R6),R6	; GET ADDRESS OF PASSBACK INFO BUFFER
5$:	BSBB	GETDEV			; GET DEVICE NAME TO DEALLOCATE
	BLBS	R0,10$			; BR IF DEVICE NAME HERE
	CLRL	R9			; DEALLOCATE ALL
	TSTL	PRC_L_OWNRPID(R11)	; IS THIS A SUBPROCESS?
	BEQL	10$			; IF EQL, NO
	CLRL	(R6)			; INDICATE IN PASSBACK THAT ALL SHOULD BE DELETED
	BRB	20$			; DON'T DEALLOCATE HERE
10$:	TSTL	PRC_L_OWNRPID(R11)	; IS THIS A SUBPROCESS?
	BNEQ	20$			; IF SO, DON'T DEALLOCATE HERE-DEFER TO PARENT PROCESS
	$DALLOC_S (R9)			; DEALLOCATE DEVICE
20$:	RSB				; 
 
;+
; GETDEV - GET DEVICE NAME
;
; COMMON ROUTINE TO GET A DEVICE NAME AND REMOVE COLON IF PRESENT
;
; INPUTS:	SAME AS DEASSIGN AND DEALLOCATE
;-
 
GETDEV:	GETDVAL				; GET NEXT DESCRIPTOR VALUES
	CLRL	R0			; ASSUME NOT A PARAMETER
	CMPB	R5,#PTR_K_PARAMETR	; ITEM TYPE PARAMETER?
	BNEQ	20$			; BR IF NO
	BSBB	SETNAM			; SET THE NAME
	STATUS	NORMAL			; SET GOOD STATUS
20$:	RSB				;
 
;
; LOCAL ROUTINE TO SET THE DEVICE NAME DESCRIPTOR
;
; INPUTS:
;
;	R6 = ADDRESS OF CURRENT LOCATION IN PASSBACK INFORMATION BUFFER
;	     IF THIS IS A SUBPROCESS
; 
SETNAM:	COMPSTRING			; REMOVE QUOTES
	CMPB	-(R1)[R2],#^A/:/	; NAME END WITH COLON
	BEQL	10$			; BR IF YES
	INCL	R1			; NO - PUT IT BACK
10$:	MOVQ	R1,-(R9)		; SAVE DEVICE NAME DESCRIPTOR
	TSTL	PRC_L_OWNRPID(R11)	; IS THIS A SUBPROCESS?
	BEQL	20$			; IF EQL, NO
	MOVW	R1,(R6)+		; PUT LENGTH OF DEVICE INTO PASSBACK
	MOVC3	R1,(R2),(R6)		; COPY DEVICE STRING INTO PASSBACK
	MOVL	R3,R6			; UPDATE PASSBACK BUFFER POINTER
20$:	RSB
 
	.END
