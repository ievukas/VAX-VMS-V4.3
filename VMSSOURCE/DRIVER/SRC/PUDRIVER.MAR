	.TITLE	PUDRIVER
	.IDENT	'V04-000'

;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
;++
;
; FACILITY:
;
;	VAX/VMS EXECUTIVE, I/O DRIVERS
;
; ABSTRACT:  This module contains the UDA port driver.
;
; AUTHORS:  Richard I. Hustvedt,  July 1981
;	    Robert Rappaport
;	
; MODIFIED BY:
;
;	V03-159	RLRSTEP4	Robert L. Rappaport	16-Jul-1984
;		Expand CNTRLTYP field in Port Step 4 from 4 bits to 7 bits.
;		Also add in Scorpio-BUA support and hooks for BDA support.
;
;	V03-158	RLRQDA		Robert L. Rappaport	19-Jun-1984
;		Add recognition of QDA.
;
;	V03-157	RLRTRACE	Robert L. Rappaport	01-Jun-1984
;		Add support to be able to dynamically configure tracing.
;
;	V03-156	RLRMAYA		Robert L. Rappaport	22-May-1984
;		Add in MAYA tape support.  Also add in ability to just
;		trace "PT" ports.
;
;	V03-155	RLRMVER		Robert L. Rappaport	26-Apr-1984
;		Add code to send operator message to complain about ucode
;		out of date on RDRX controller.
;
;	V03-154	RLRPDTADP	Robert L. Rappaport	 9-Apr-1984
;		1) Init PDT$L_ADP.  2) Initialize PDT$L_WAITQFL list head
;		in INIT_PU_PDT. 3) Clear connection active bit in
;		PDT$B_CONBITMAP on calls to disconnect.
;
;	V03-153	ROW0334		Ralph O. Weber		 3-APR-1984
;		Add setup of PDT$L_MAXBCNT to BUILD_PDT.  Give PDT$L_MAXBCNT a 
;		value of 127*512 (i.e. 127 blocks).
;
;	V03-152	RLRPHYPGS	Robert L. Rappaport	21-Mar-1984
;		Make use of new system routine to allocate physically
;		contiguous pages.  Also add null routine FPC$STOP_VCS.
;
;	V03-151	PRD0070		Paul R. DeStefano	25-Feb-1984
;		Clear SB$L_CSB (link to newest CSB) when system block
;		is created.
;
;	V03-150	RLRDELPQ	Robert L. Rappaport	25-Jan-1984
;		Eliminate separate conditionalized PQDRIVER and rather
;		use CPUDISP to accomodate differences.  In general,
;		differences are in initialization code or in main line code.
;		For initialization code merely use CPUDISP.  For main line
;		code (MAPIRP and UNMAP), have two sets of entry points,
;		one for all CPU's except uVAX I, and one set for uVAX I.
;		Then at initialization time, in BUILD_PDT, build PDT
;		dispatch table to dispatch to proper entry point for the
;		processor we are running on.
;
;		Also fix bug in uVAX I BUILD_PDT that manifested itself when
;		we have more than one port; namely we tried to map the
;		map registers in the 2nd PDT into the System Addresses
;		pointed at by @ADP$L_CSR+^x800 of the common ADP, where we
;		had already mapped the map registers from the first PDT.
;		Solution is to only go thru map code once.  A new flag,
;		MAP$V_MAPREGS, in PU$L_DRIVER_STS, if set, means that the code
;		has already been executed.
;
;	V03-149	ROW0268		Ralph O. Weber		28-DEC-1983
;		Change instructions used to set aside space for NULL_CDT so 
;		that space allocated is always large enough to accomidate a 
;		complete CDT.  (I.E. base the space allocation on CDT$K_LENGTH.)
;
;	V03-148	RLREXEALLOC	Robert L. Rappaport	22-Dec-1983
;		Correct subtle bug introduced in previous fix.  Namely
;		the call to EXE$ALONONPAGED was restored and the call to
;		EXE$ALLOCATE was removed.  To deal with the problem of
;		deallocating fragments that might be in LRP space,
;		the deallocation of the PDT fragment (in PQDRIVER BUILD_PDT)
;		was eliminated and it was decided to forget about that small
;		bit of space.
;
;	V03-147	RLRMCRED	Robert L. Rappaport	18-Nov-1983
;		Bring driver into conformance with latest UQPORT spec.
;			1. Ignore credits field (in envelope) for Maintenance
;			   type messages.
;			2. Wait for at least 100 uSecs after initialization
;			   interrupts before reading SA to look for step bit.
;			3. Test for controller tolerance of odd addresses before
;			   segmenting a transfer and using the aligned buffer.
;
;	V03-146	RLRPQ02		Robert L. Rappaport	14-Nov-1983
;		Clear up problems in non-aligned transfers.  In
;		particular, make it so that we copy WRITE data to
;		the aligned page BEFORE the I/O and we copy READ
;		data from the aligned page AFTER the I/O operation.
;		We accomplish this by adding two subroutines,
;		SETUP_COPY_SEG1 and SETUP_COPY_SEG2, that perform
;		the necessary setup operations to prepare for a copy
;		in either direction.
;
;	V03-145	KDM0104		Kathleen D. Morse	20-Oct-1983
;		Fix reference to MMG$GL_SPTBASE to be PIC.
;
;	V03-144	KDM0103		Kathleen D. Morse	01-Oct-1983
;		Invalidate virtual address after changing the system
;		page table entry to do unaligned transfers.  Allocate
;		a system page table entry in the initialization routine
;		for the Qbus.
;
;	V03-143	NPK3050		N. Kronenberg		30-Sep-1983
;		For PQ allocate PDT so that PDT$L_PQ_MAP within
;		the PDT is page aligned.
;
;	V03-142	KDM0102		Kathleen D. Morse	29-Sep-1983
;		Change Qbus code to compute physical address of
;		ring buffer during initialization.
;
;	V03-141	KDM0101		Kathleen D. Morse	29-Sep-1983
;		Fix indexing through page table entries for Qbus.
;
;	V03-140	KDM0100		Kathleen D. Morse	29-Sep-1983
;		Change the way the ADP points to the map registers
;		for the MicroVAX I.  Fix virtual to physical translation.
;		Add MicroVAX I to CPUDISP macros.
;
;	V03-139	CWH3139		CW Hobbs		17-Sep-1983
;		Change DT$_RC25 symbol for Aztec port to DT$_LESI so
;		that DT$_RC25 can refer to the removable pack on the
;		Aztec.
;
;	V03-138	RLRNEWPB	Robert L. Rappaport	28-Jul-1983
;		Incorporate new PBDEF changes.
;
;	V03-137	RLRQIOCHNLa	Robert L. Rappaport	15-Jul-1983
;		Must refresh R4 => PDT after REQPCHAN.
;
;	V03-136	RLRQIOCHNL	Robert L. Rappaport	6-Jul-1983
;		Correct subtle error in QIO routine.  After REQCOM,
;		PU channel was released.  Next interrupt crashed
;		system.  Fix is to have STARTIO, BSBW to REQCOM, so
;		as to retain control after REQCOM.  In this way we
;		can REQPCHAN again.
;
;	V03-135	RLRSAPOLL	Robert L. Rappaport	5-Jul-1983
;		Implement periodic polling of the SA register.  Also
;		cleanup some miscellaneous bugs:
;			1. In HARDWARE_INIT, insert BRB 190$ at the
;			   end of the logic following label TESTUDA_780.
;			   This corrects a bug that was permanently
;			   wasting a buffered datapath on 780's.
;			2. Add a FUNCTAB +EXE$ZEROPARM for the
;			   STOP and INITIALIZE qio functions that we now
;			   support.
;			3. In INIT_UDA_BUFFERS, save values placed into
;			   UCB$W_BOFF, UCB$W_BCNT, and UCB$L_SVAPTE in
;			   new UCB fields.  Then in HARDWARE_INIT, restore
;			   these values immediately prior to the LOADUBA
;			   invocation.  This corrects the problem that
;			   the QIO functions cause the these fields to
;			   be cleared.
;
;	V03-134	RLRSRVCN1	Robert L. Rappaport	3-Jun-1983
;		Corect two bugs introduced in previous edit.
;
;	V03-133	RLRSRVCON	Robert L. Rappaport	1-Jun-1983
;		1. Prevent logging redundant Initialization Log entries.
;		2. Correct infinte loop typo in Maintenance Type messages.
;		3. Connect changes:
;			a) Add PDT$B_SERVERS, bit map that lists servers
;				supported at this port.
;			b) Have CONNECT return SS$_FAILRSP if caller is
;				trying to Connect to a server not supported
;				on this port.
;			c) Have CONNECT return R2=>Connect data.
;
;	V03-132	RLRCPUDISP	Robert L. Rappaport	25-May-1983
;		Use new form of CPUDISP macro.
;
;	V03-131	RLRPCHAR	Robert L. Rappaport	20-May-1983
;		Set PDT$M_SNGLHOST bit in PDT$W_PORTCHAR field.
;
;	V03-130	RLRPUR780	Robert L. Rappaport	26-Apr-1983
;		Prevent losing context of which datapath to purge.
;		Do this by saving and then restoring the contents
;		of CRB$L_INTD+VEC$B_DATAPATH when doing a UDA
;		requested purge at device interrupt level.
;
;	V03-029	RLRUDAREV	Robert L. Rappaport	11-Apr-1983
;		Test for out of rev UDA50's and UDA50A's on 780 systems.
;
;	V03-028	RLRSAVCRED	Robert L. Rappaport	8-Apr-1983
;		On Disconnect, save available credits in PDT$W_PU_CREDx,
;		where x (ID) is index of disconnecting connection.
;
;	V03-027	RLRPQ01a	Robert L. Rappaport	31-Mar-1983
;		Fix branch out of range brought about by previous addition
;		which also included setting UCB$B_DEVTYPE according to
;		UQPORT type.
;
;	V03-026	RLRPQ01		Robert L. Rappaport	17-Mar-1983
;		Add conditionally assembled support for Q-BUS port.
;
;	V03-025	TCM0001		Trudy C. Matthews	28-Feb-1983
;		Update occurrences of CPUDISP macro so that the function
;		correctly on an 11/790.  In both cases, we just take the
;		same code path as the 11/780.
;
;	V03-024	RLRPBSB		Robert L. Rappaport	11-Feb-1983
;		Cleanup minor phasing problem in Path Block and System
;		Block initialization by adding new subroutine, UPDATE_PB_SB.
;
;	V03-023	RLRMSGTYP	Robert L. Rappaport	3-Feb-1983
;		Add ability to handle simple credit type messages and
;		maintenance messages.
;
;	V03-022	RLRDUP1		Robert L. Rappaport	31-Jan-1983
;		Fix typo in original RLRDUP fix that used R5 instead of R0.
;
;	V03-021	RLRUSECNT	Robert L. Rappaport	25-Jan-1983
;		Modify logic that permanently allocates Buffered Data
;		Path on VAX-11/750.  From now on we will only permanently
;		allocate a BDP if the controller is a UDA.  Other UQPORT
;		controllers "semi_permanently" allocate a BDP for the
;		duration of a burst.  This is implemented via adding
;		a new cell, PDT$B_BDPUSECNT, which counts the number of
;		transfers in a burst that are currently using the
;		"semi-permanent" BDP.  When this count goes to zero, the
;		BDP is deallocated.  For the UDA, the usecount is biased
;		by one, so that it never goes to zero and therefore
;		never get deallocated.
;
;	V03-020	RLRPPFORK	Robert L. Rappaport	7-Jan-1983
;		Eliminate Bugcheck in POST_POWER_FORK, that was
;		activated when it found the UCB fork block busy.
;		We do this by defining a new UCB$W_DEVSTS flag,
;		UCB$M_PU_MRESET, that if set causes PUDRIVER to
;		reset itself upon awakening from the busy UCB.
;
;	V03-019	RLRDUP		Robert L. Rappaport	5-Jan-1983
;		Add support for two QIO functions that (1) effectively
;		shut off Class Drivers from the port and only let
;		DUP connections thru, and then (2) reopen the port.
;		The Shutoff QIO function is IO$_STOP and the reopen
;		function is IO$_INITIALIZE.
;
;	V03-018	RLRCREDITa	Robert L. Rappaport	20-Dec-1982
;		Additional correction to take care of bug introduced
;		by original fix.  Must add space to NULL_CDT to
;		accomodate CDT$L_CRWAITQFL and CDT$L_CRWAITQBL, and
;		also code to initialize this header.
;
;	V03-017	RLRCREDIT	Robert L. Rappaport	3-Dec-1982
;		Corrected bug brought out in TU81 testing where the
;		credit that was received on the End Packet of a
;		GET COMMAND STATUS (i.e. the "immediate" credit)
;		was assigned to a waiter on the credit resource
;		wait queue.  Then the time out mechanism had no
;		credits to allocate.  The fix is to add in the
;		received credits upon receipt of the message,
;		then call the Input Dispatcher and only then
;		after return try to resume waiters for credits.
;
;	V03-016	RLRTRBUG	Robert L. Rappaport	8-Oct-1982
;		Correct in trace when we have more than 1 UDA.
;
;	V03-015	RLRPATHB	Robert L. Rappaport	6-Oct-1982
;		Put proper port name into path block. Also fill in
;		SB$Q_SWINCARN with value in EXE$GQ_SYSTIME.
;
;	V03-014	RLRUDASA	Robert L. Rappaport	12-Aug-1982
;		Read UDASA after IOFORK in HARDWARE_INIT so that TU81
;		has enough time to update UDASA after interrupting.
;
;	V03-013	KDM0002		Kathleen D. Morse	28-Jun-1982
;		Added $DYNDEF, $PRDEF, $SSDEF, and $VADEF.
;
;	V03-012	RLRECO03	Robert L. Rappaport	4-June-1982
;		Add separate REQDATAP_750 and REQDATAP_730 to replace
;		REQDATAP_750730.  New routine for 750 will only use
;		pre-allocated buffered datapath if the transfer is
;		longword aligned.  Otherwise it will use direct datapath.
;
;	V03-011	RLRECO02	Robert L. Rappaport	7-May-1982
;		INSQUE Path Block onto System Block.
;
;	V03-010	RLRECO01	Robert L. Rappaport	7-May-1982
;		Add purging of UNIBUS Buffered Data Path in UNMAP.
;		This tracks patch made to V3.0 before release.
;
;
;--

	.SBTTL	DEFINITIONS
;
; System definitions (LIB.MLB):
;

	$ADPDEF				;Adapter Control Block offsets
	$CDRPDEF			;Class Driver Request Packet offsets
	$CDTDEF				;Connection Descriptor offsets
	$CRBDEF				;Channel Request Block offsets
	$DCDEF				;Device type codes
	$DDBDEF				;Device Data Block offsets
	$DPTDEF				;Driver Prologue Table offsets
	$DYNDEF				;Dynamic data structure types
	$EMBDEF				;Error log definitions
	$EMBLTDEF			;Log message type codes
	$IDBDEF				;IDB offsets
	$IODEF				;IO function definitions
	$IPLDEF				;IPL symbolic definitions
	$IRPDEF				;IRP offsets
	$MSGDEF				;Opcom message code definitions
	$PBDEF				;Path Block offsets
	$PDTDEF				;Port Descriptor Table offsets
	$PRDEF				;Processor register numbers
	$PTEDEF				;Page Table Entry definitions
	$RDDEF				;Response Descriptor offsets
	$SBDEF				;System Block offsets
	$SCSCMGDEF			;SCS Connection Management format
	$SDIRDEF			;SCS Directory Entry offsets
	$SSDEF				;System status codes
	$UBADEF				;Unibus Adapter registers
	$UBMDDEF			;Unibus Mapping Descriptor format
	$UCBDEF				;Unit Control Block offsets
	$VADEF				;Virtual address fields
	$VECDEF				;CRB transfer vector blk offsets

	.PAGE
	.SBTTL	+	UDA Command Packet Layout

;+
;	Each UDA command packet has the following structure where the
;		individual fields are described below the diagram.
;
;	31				0
;	 _______________________________
;	!				!
;	!	UDAB$L_FLINK		! Forward link longword
;	!_______________________________!
;	!				!
;	!	UDAB$L_BLINK		! Backward link longword
;	!_______________________________!
;	!\\\\\\\! Buffer!  Ring	! Ring	!
;	!\\\\\\\! Number! Number! Index	!
;	!_______!_______!_______!_______!
;	!				!
;	!	UDAB$L_DESCRIP		! UNIBUS virtual address of this buffer
;	!_______________________________!
;	! CONID	!Msg!Cre!   Message	!
;	!	!typ!dit!    length	! Controller message envelope
;	!_______!___!___!_______________!
;	!				! UDAB$T_TEXT
;	!				!
;	!  Contents of an MSCP Packet	!
;	!				!
;	!				!
;	!				!
;	!				!
;	!_______________________________!
;
;
; $UDABDEF -- Define UDA packet buffer structure.  Structure includes
;	port driver header, controller header and text body.  The port
;	driver header contains:
;
;		1. A FLINK and a BLINK for queueing the buffer on the
;			free queue and also on the SEND Q.
;
;		2. $B_RINGINX which contains the index into a ring on
;			which this buffer has been placed (valid only
;			if the buffer is NOT on the free queue).
;
;		3. $B_RINGNO which contains the number (0 => command ring
;			and 1 => response ring) of the ring on which the
;			buffer is currently residing.
;
;		4. $B_BUFFNO which contains the number of this buffer.
;			This value serves as an index into the
;			PDT$L_BDTABLE, whose elements point to these
;			buffers.
;
;		5. $L_DESCRIP which contains the UNIBUS virtual address
;			of the text portion of this buffer in the low order
;			30 bytes of this longword, and which also has the
;			two high order bits (ownership and full bits) set.
;			This is the precise value that must be placed in
;			a ring longword so as to present the buffer to the
;			controller.
;
;		6. The controller header which contains a word of length
;			(of the following text portion only), a byte
;			containing two four bit fields encoding the credit
;			field and the message type field, and a byte of
;			Connection ID.
;
;		7. The message text portion.
;-


	$DEFINI	UDAB

$DEF	UDAB$L_FLINK		.BLKL	1	; Queue FLINK.

$DEF	UDAB$L_BLINK		.BLKL	1	; Queue BLINK.

$DEF	UDAB$B_RINGINX		.BLKB	1	; Index into ring.

$DEF	UDAB$B_RINGNO		.BLKB	1	; Ring number.

$DEF	UDAB$B_BUFFNO		.BLKB	1	; Index of this buffer.
				.BLKB	1	; Reserved.

$DEF	UDAB$L_DESCRIP		.BLKL	1	; UNIBUS virtual address of buff.

$DEF	UDAB$L_CTRLHDR				; Alternate name for following
						;  longword of fields.
$DEF	UDAB$W_MSG_LEN		.BLKW	1	; Length of text portion.

$DEF	UDAB$B_CREDTYPE		.BLKB	1	; Encoded CREDIT and MESSAGE TYPE.

	$VIELD	UDAB,0,<-
			<CREDITS,4>,-		; Credit bit field.
			<MSGTYPE,4>,-		; Message type bit field.
			>

$DEF	UDAB$B_CONID		.BLKB	1	; Connection ID.

$DEF	UDAB$T_TEXT		.BLKB	60	; Space for minimal maximum.

UDAB$C_LENGTH = .

	$DEFEND	UDAB
	.PAGE

; Define Device I/O Page Registers

	$DEFINI UDA
$DEF	UDAIP	.BLKW	1	; Initialization and Polling Register
$DEF	UDASA	.BLKW	1	; Status, Address, & VAX Purge ACK Register
	$DEFEND UDA


; ++
; Local symbol definitions
;--

LOOP_LIMIT	= ^X<FAB>	; Step 1 maximum wait time for response
INTR_VEC	= ^O<270>	; Primary Interupt vector

UDA$K_SEQMSGTYP = 0			; Sequential Message Type
UDA$K_DGTYPE = 1			; Datagram type
UDA$K_CREDTYPE = 2			; Credit type
UDA$K_MAINTTYPE = 15			; Maintenance type
UDA$K_RINGEXP = 4			; Log base 2 of desired ring size
UDA$K_RINGSIZE = 1@UDA$K_RINGEXP	; Number of Ring & Packet entries

; Command and Message Ring Control Flags

UDA_V_FLAG = 30				; Buffer control bit number
UDA_M_FLAG = 1 @ UDA_V_FLAG		; Buffer control flag mask
UDA_V_OWN  = 31				; Own flag bit number
UDA_M_OWN  = 1 @ UDA_V_OWN		; Own flag mask

UQPORT_M_MAPPED=1@31			; Transfer Mapped by port.

STEP1_LIMIT=10				; Number of seconds for STEP 1 timeout
STEP2_LIMIT=10				; Number of seconds for STEP 2 timeout
STEP3_LIMIT=10				; Number of seconds for STEP 3 timeout

NUMUBAVEC=128				; Number of slots in UBA vector

NO_CONSEC_INITS=5			; Number of consecutive times to retry
					;  hardware init without waiting for awhile.
INIT_DELTA=10				; Number of seconds to wait when we wait
					;  for a while.

ALLOC_DELTA=1				; Number of seconds to wait before
					;  retrying allocation request.

REGSAVE=2+2+4+4+16			; Size of data saved in PU_REGDUMP.
					;  Includes space for ATTNCODE(2),
					;   NUMBINITS(2), MAPREG(4),
					;   UDASA(4-MOVZWL), HOST-PORT(16).
INIT_ATTNCODE=1				; Attention code for INIT record.
FAIL_ATTNCODE=2				; Attention code for failing INIT record.
UDASA_ATTNCODE=3			; Attention code for record after error.
PURGE_ATTNCODE=4			; Attention code for Purge error record.
UCODE_ATTNCODE=5			; Attention code for uCODE out of rev.

UDA50_CNTRLTYP=0			; UDA50 controller type code.
LESI_CNTRLTYP=1				; LESI (RC25) controller type code.
TU81_CNTRLTYP=5				; TU81 controller type code.
UDA50A_CNTRLTYP=6			; UDA50A controller type code.
RDRX_CNTRLTYP=7				; RD/RX
MAYA_CNTRLTYP=3				; MAYA
QDA50_CNTRLTYP=13			; QDA50

DISK_CONID=0				; Disk Server Connection ID
TAPE_CONID=1				; Tape Server Connection ID
DUP_CONID=2				; DUP  Server Connection ID

SA_POLL_INTVAL=15			; SA register polling interval.
NO_PHYCONTIGPGS=1			; # of physically contiguous pages
					;  allocate for non-aligned transfers
					;  on QBUS.
NO_PHYCONTIGBYT=NO_PHYCONTIGPGS*512	; # of physically contiguous bytes.
	.PAGE
	.SBTTL	+	Define PU Port specific PDT extension

;+
; PUPDT -- Define PU port specific extension to the PDT
;	(Must appear after the definition of UDA$K_RINGEXP and 
;	 UDA$K_RINGSIZE)
;-

	$DEFINI	PUPDT

.=.+PDT$C_LENGTH			; Position to end of port-
					;  independent portion of PDT
$DEF	PDT$L_PU_CDTARY			; Array of pointers to CDT's.
$DEF	PDT$L_PU_VC0	.BLKL	1	;  Connection block address for
					;  virtual circuit 0 Disk MSCP

$DEF	PDT$L_PU_VC1	.BLKL	1	; Connection block address for 
					;  virtual circuit 1 Tape MSCP

$DEF	PDT$L_PU_VC2	.BLKL	1	; Connection block address for 
					;  virtual circuit 2 DUP

$DEF	PDT$L_PU_VC255	.BLKL	1	; Connection block address for 
					;  virtual circuit 255 (-1)
					;  Maintenance protocol

$DEF	PDT$W_PU_CRDARY			; Array of initial credits.
$DEF	PDT$W_PU_CRED0	.BLKW	1	; Credits to assign on next
					;  CONNECT to VC0.
$DEF	PDT$W_PU_CRED1	.BLKW	1	; Credits to assign on next
					;  CONNECT to VC1.
$DEF	PDT$W_PU_CRED2	.BLKW	1	; Credits to assign on next
					;  CONNECT to VC2.
$DEF	PDT$W_PU_CRD255	.BLKW	1	; Credits to assign on next
					;  CONNECT to VC255.

$DEF	PDT$L_PU_SB	.BLKL	1	; Address of our System Block.

$DEF	PDT$L_PU_CSR	.BLKL	1	; Pointer to controller CSR.

$DEF	PDT$L_PU_FQPTR	.BLKL	1	; Pointer to Free Q. Used to
					;  test for emptiness of Free Q.
$DEF	PDT$L_PU_FQFL	.BLKL	1	; Free Q forward pointer.
$DEF	PDT$L_PU_FQBL	.BLKL	1	; Free Q backward pointer.

$DEF	PDT$L_PU_SNDQFL	.BLKL	1	; Send Q forward  pointer.
$DEF	PDT$L_PU_SNDQBL	.BLKL	1	; Send Q backward pointer.

$DEF	PDT$L_PU_BUFQFL	.BLKL	1	; Buffer wait Q forward pointer.
$DEF	PDT$L_PU_BUFQBL	.BLKL	1	; Buffer wait Q backward pointer.

$DEF	PDT$B_CRINGINX	.BLKB	1	; Index of next available slot
					;  in command ring.
$DEF	PDT$B_CPOLLINX	.BLKB	1	; Index of next slot to be polled
					;  by host, to see if released.
$DEF	PDT$B_CRINGCNT	.BLKB	1	; Count of number of command
					;  ring slots in use. Also
					;  absolute difference between
					;  previous two fields.

$DEF	PDT$B_RRINGINX	.BLKB	1	; Index of next available slot
					;  in response ring.
$DEF	PDT$B_RPOLLINX	.BLKB	1	; Index of next slot to poll by
					;  host, to see if filled in.
$DEF	PDT$B_RRINGCNT	.BLKB	1	; Count of not yet filled in
					;  buffers on response ring.
					;  Absolute difference between
					;  previous two fields.

$DEF	PDT$B_NOCURCON	.BLKB	1	; # of current connections.
$DEF	PDT$B_CONBITMAP	.BLKB	1	; Current Connection bit map. Corresponding
					;  bit set for each open connection.
$DEF	PDT$B_SERVERS	.BLKB	1	; Servers Supported at this Port. Bit
					;  set for each supported Server.

$DEF	PDT$B_DATAPATH	.BLKB	1	; Permanently (or semi-permanently)
					;  allocated datapath. For VAX11-750
					;  only. Else zero.
$DEF	PDT$B_BDPUSECNT	.BLKB	1	; Count of # commands using above BDP.
			.BLKB	1	; Reserved

$DEF	PDT$B_CRCONTENT	.BLKB	UDA$K_RINGSIZE	; Array of bytes (one per each
						;  command ring slot) which
						;  maintain index of buffer
						;  currently filling this slot.

$DEF	PDT$B_RRCONTENT	.BLKB	UDA$K_RINGSIZE	; Array of bytes (one per each
						;  response ring slot) which
						;  maintain index of buffer
						;  currently filling this slot.

$DEF	PDT$L_BDTABLE	.BLKL	2*UDA$K_RINGSIZE; Array of longwords (one per
						;  buffer) which point to the
						;  respective buffers.

; For uVAX I the communications area must not straddle a 64KB boundary.
; So the following .ALIGN starts the communications area on a new page
; and since it is less than 512 bytes long, it cannot straddle pages.
; Note, for uVAX I the PDT is allocated in contiguous memory on a page
; boundary and therefore the .ALIGN really is relevant to a page.

.=<.+511>&<^c511>	; Equivalent of .ALIGN	PAGE

$DEF	PDT$L_COMAREA				; UDA communication area base
			.BLKW	1		; Reserved word
			.BLKB	1		; Reserved byte
$DEF	PDT$B_PURGEDP	.BLKB	1		; Purge data path number

$DEF	PDT$W_CMDINT	.BLKW	1		; Command ring transition flag

$DEF	PDT$W_RSPINT	.BLKW	1		; Response ring transition flag

$DEF	PDT$L_RINGBASE
$DEF	PDT$L_RSPRING	.BLKL	UDA$K_RINGSIZE	; Response ring

$DEF	PDT$L_CMDRING	.BLKL	UDA$K_RINGSIZE	; Command ring
PDT$C_COMAREALN = .-PDT$L_COMAREA		; Length of Comarea

$DEF	PDT$L_PU_BUFARY				; Buffer array.

	.REPT	2*UDA$K_RINGSIZE		; Allocate packets for response
						; and command rings

			.BLKB	UDAB$C_LENGTH	; Length of a buffer.

	.ENDR
PDT$C_RINGLEN = .-PDT$L_COMAREA			; Length of area to map

$DEF	PDT$L_TRTABLE	.BLKL	1	; Pointer to base of usable (beyond
					;  header) portion of trace table
$DEF	PDT$L_TRTBLPTR	.BLKL	1	; Pointer to next area in trace table
					;  to use.
$DEF	PDT$L_TRTBLEND	.BLKL	1	; Pointer beyond end of trace table.


PDT$C_PULENGTH = .			; Total size of a 
					;  PDT for the UDA port

; The following PDT extension is only needed when running on uVAX I.

$DEF	PDT$L_PQ_MAP	.BLKL	1	; Vitrual pointer to 496 pseudo map
					;  "registers".

$DEF	PDT$L_PQ_PGQFL	.BLKL	1	; Queue Header for CDRP's waiting to
$DEF	PDT$L_PQ_PGQBL	.BLKL	1	;  allocate the aligned Page that follows.
$DEF	PDT$L_PQ_POWNER	.BLKL	1	; CDRP that currently owns the Page.
$DEF	PDT$L_PQ_PGPHAD	.BLKL	1	; Physical address of the Page.
$DEF	PDT$L_PQ_UBFSVA	.BLKL	1	; Virtual address of the page mapped by
					;  UCB$L_SVPN.  This page is used to map
					;  one page of the user's buffer in order
					;  to be able to copy it to the aligned
					;  Page.
$DEF	PDT$L_PQ_SVPPTE	.BLKL	1	; Pointer to the PTE of the UCB$L_SVPN.
$DEF	PDT$L_PQ_USRPTE	.BLKL	1	; Pointer into user page table that
					;  points to current user SVAPTE.

$DEF	PDT$L_PQ_ALGNPG	.BLKB	NO_PHYCONTIGBYT	; A word aligned string of
						;  physically contiguous pages.

PDT$C_CONTIGLEN = .-PDT$L_COMAREA	; Length of area needed to be Physically
					;  contiguous.
PDT$C_UV1LENGTH = .			; Length of PDT needed for uVAX I.
	$DEFEND PUPDT
	.PAGE
	.SBTTL	+	Define PU specific UCB extension

;+
; $PUUCBDEF -- Defined UDA extension to UCB.
;	(Must appear after the definition of UDA$K_RINGEXP and 
;	 UDA$K_RINGSIZE)
;-

	$DEFINI	UCB

.=UCB$L_DPC+4					; Position to end of 
						;  standard UCB for
						;  error logging devices

$DEF	UCB$L_PU_ALLOC	.BLKL	1	; Space to save size of alloc. request.

$DEF	UCB$B_UDAFLAGS	.BLKB	1	; Internal control flags
	$VIELD	UDA,0,<-		; Internal flag definitions
		<ONLINE,,V>,-		; UDA is On Line
		<STOPPED,,M>,-		; Port only open for DUP CONNECTIONS.
	 >

$DEF	UCB$B_INITCNT	.BLKB	1	; Count of # of times left to retry
					;  hardware init consecutively.
$DEF	UCB$W_NUMBINITS	.BLKW	1	; Number of times UDA50 has been Inited.

$DEF	UCB$W_ATTNCODE	.BLKW	1	; Attention code for PU_REGDUMP.

$DEF	UCB$W_UDASA	.BLKW	1	; Contents of SA saved at last interrupt

$DEF	UCB$W_PORTSTEP1	.BLKW	1	; Contents of SA at start of STEP1.
	_VIELD	PS1,0,<-		; Fields in STEP1
		<,6>,-			;  Reserved
		<MP,,M>,-		;  If set port supports address mapping
		<OD,,M>,-		;  If set port supports odd addresses
		<DI,,M>,-		;  If set port implements enhanced diagnostics
		<QB,,M>,-		;  If set port supports 22-bit bus addr
		<NV,,M>,-		;  If set no host settable vector addr
		<S1,,M>,-		;  Must be set in step 1
		<S2,,M>,-		;  Must be clear in step 1
		<S3,,M>,-		;  Must be clear in step 1
		<S4,,M>,-		;  Must be clear in step 1
		<ER,,M>,-		;  If set then we had an error
	>

$DEF	UCB$W_HOSTSTEP1	.BLKW	1	; What host writes to SA in STEP1.
	_VIELD	HS1,0,<-		; Fields in Host STEP1
		<INTVEC,7,M>,-		;  Interrupt vector address/4
		<IE,,M>,-		;  Interrupt enable during STEPS 1-3
		<RRNGLEN,3,M>,-		;  Response ring length (exponent)
		<CRNGLEN,3,M>,-		;  Command ring length (exponent)
		<WR,,M>,-		;  If set port enters diagnostic wrap mode
		<BIT15,,M>,-		;  High bit always set
	>

$DEF	UCB$W_PORTSTEP2	.BLKW	1	; What port responds at start of STEP2.
	_VIELD	PS2,0,<-		; Fields in Port STEP2
		<RRNGLEN,3,M>,-		;  Echoed response ring length (exponent)
		<CRNGLEN,3,M>,-		;  Echoed command ring length (exponent)
		<WR,,M>,-		;  Echoed diagnostic wrap bit
		<,1>,-			;  Echoed BIT15 always set
		<PORTTYPE,3,M>,-	;  Type of this port
		<S1,,M>,-		;  Must be clear in STEP2
		<S2,,M>,-		;  Must be set in STEP2
		<S3,,M>,-		;  Must be clear in STEP2
		<S4,,M>,-		;  Must be clear in STEP2
		<ER,,M>,-		;  If set then error in STEP1
	>

$DEF	UCB$W_HOSTSTEP2	.BLKW	1	; What host writes to SA during STEP2.
	_VIELD	HS2,0,<-		; Fields in Host STEP2
		<PI,,M>,-		;  Host requests adapter purge interrupts
		<RINGBASEL,15,M>,-	;  Lo order of address of communication
	>				;   area (in UNIBUS virtual space)

$DEF	UCB$W_PORTSTEP3	.BLKW	1	; What port responds at start of STEP3.
	_VIELD	PS3,0,<-		; Fields in Port STEP3
		<INTVEC,7,M>,-		;  Echoed interrupt address/4
		<IE,,M>,-		;  Echoed interrupt enable
		<,3>,-			;  Reserved
		<S1,,M>,-		;  Must be clear in STEP3
		<S2,,M>,-		;  Must be clear in STEP3
		<S3,,M>,-		;  Must be set in STEP3
		<S4,,M>,-		;  Must be clear in STEP3
		<ER,,M>,-		;  If set we had error in STEP2
	>

$DEF	UCB$W_HOSTSTEP3	.BLKW	1	; What host writes to SA during STEP3.
	_VIELD	HS3,0,<-		; Fields in Host STEP3
		<RINGBASEH,15,M>,-	;  Hi order of address of comm. area
		<PP,,M>,-		;  If set host requests execution of
	>				;   purge and poll tests

$DEF	UCB$W_PORTSTEP4	.BLKW	1	; What port responds at start of STEP4.
	_VIELD	PS4,0,<-		; Fields in Port STEP4
		<UCODEVER,4,M>,-	;  Microcode version number
		<CNTRLTYP,7,M>,-	;  Controller type
		<S1,,M>,-		;  Must be clear in STEP4
		<S2,,M>,-		;  Must be clear in STEP4
		<S3,,M>,-		;  Must be clear in STEP4
		<S4,,M>,-		;  Must be set in STEP4
		<ER,,M>,-		;  If set we had an error in STEP3
	>

$DEF	UCB$W_HOSTSTEP4	.BLKW	1	; What host writes to SA during STEP4.
	_VIELD	HS4,0,<-		; Fields in Host STEP4
		<GO,,M>,-		;  If set controller begins immediately
		<LF,,M>,-		;  If set host wants Last Fail response
		<BURST,6,M>,-		;  Maximum lonwords(-1) / NPR transfer
		<,8>,-			;  Reserved
	>


$DEF	UCB$L_PU_SVAPTE	.BLKL	1	; Place to save UCB$L_SVAPTE.
$DEF	UCB$W_PU_BOFF	.BLKW	1	; Place to save UCB$W_BOFF.
$DEF	UCB$W_PU_BCNT	.BLKW	1	; Place to save UCB$W_BCNT.

	$VIELD	UCB,0,<-			; Define bits for UCB$W_DEVSTS
	<,1>,-					;  Unused
	<PU_FRKBSY,,M>,-			;  Fork block interlock bit
	<PU_HRDINI,,M>,-			;  Hardware init in progress
	<PU_PWINIT,,M>,-			;  POWER init in progress
	<PU_MRESET,,M>,-			;  Goto POST_POWER_FORK after fork.
	<PU_BDPATH,,M>,-			;  BDP already allocated (or not).
	<PU_INILOG,,M>,-			;  Init Log in progress
	>					;

UCB$C_PUSIZE = .

	$DEFEND	UCB
	.PAGE
	.SBTTL	DRIVER STRUCTURES
	.SBTTL	+	Driver Prologue Table

	DPTAB	END=PU$END,-		;End of driver label
		ADAPTER=UBA,-		;Adapter type
		FLAGS=DPT$M_SCS!DPT$M_SVP!DPT$M_NOUNLOAD,-
-					;Driver requires SCS to be loaded
-					; uVAX I needs System Virtual Page
		UCBSIZE=UCB$C_PUSIZE,-	;UCB size
		NAME=PUDRIVER		;Driver name

	DPT_STORE INIT

	DPT_STORE	UCB,UCB$B_FIPL,B,8	;Fork IPL

	DPT_STORE	UCB,UCB$L_DEVCHAR,L,<-	;Device characteristics:
			DEV$M_SHR!-		; Sharable
			DEV$M_AVL!-		; Available
			DEV$M_ELG!-		; Error logging device
			DEV$M_IDV!-		; Input device
			DEV$M_ODV>		; Output device

	DPT_STORE	UCB,UCB$B_DIPL,B,21	;Device interrupt IPL

	DPT_STORE REINIT

	DPT_STORE	DDB,DDB$L_DDT,D,PU$DDT	;DDT address
	DPT_STORE	CRB,CRB$L_INTD+4,-	;Interrupt routine addr
			D,PU$INT		;
	DPT_STORE	CRB,CRB$L_INTD+VEC$L_INITIAL,-
			D,PU$CTLINIT		;Controller init addr
	DPT_STORE	CRB,CRB$L_INTD+VEC$L_UNITINIT,-
			D,PU$UNITINIT		;Unit init addr
	DPT_STORE	END			;
	.PAGE
	.SBTTL	+	Driver Dispatch Table

	DDTAB	DEVNAM=PU,-			;
		START=PU$STARTIO,-		;QIO's are illegal temporarily
		FUNCTB=PU$FUNCTABLE,-		;Function decision table
		UNITINIT=PU$UNITINIT,-		;Unit init routine addr
		ERLGBF=REGSAVE+4+EMB$L_DV_REGSAV,-
		REGDMP=PU_REGDUMP

;
; We only support two functions; IO$_STOP and IO$_INITIALIZE.  The first
;	effectively closes the Port to all connections except those to
;	the DUP SERVER.  The second function reopens the Port and initializes
;	it.
;
; Inputs:
;	R3 => IRP
;	R5 => UCB of Port
;

PU$STARTIO:

	EXTZV	#IRP$V_FCODE,-		; Extract function code.
		#IRP$S_FCODE,-
		IRP$W_FUNC(R3),R0
	CMPB	#IO$_STOP,R0		; See if IO$_STOP request.
	BEQL	START_STOP		; EQL means yes it was.
	CMPB	#IO$_INITIALIZE,R0	; See if IO$_INITIALIZE requested.
	BNEQ	ILLIOFUNC		; NEQ means not one of supported functions.

	PUSHL	R5			; Save R5 => UCB.
	BSBB	SUCCESS			; Complete QIO request but get control
					;  after REQCOM so as to continue.
	POPL	R5			; Restore R5 => UCB.
	REQPCHAN			; Re-allocate channel after REQCOM.
	MOVL	UCB$L_PDT(R5),R4	; R4 => PDT.
	BSBW	FPC$MRESET		; Do initialize.
	BICB	#UDA$M_STOPPED,-	; Open up port.
		UCB$B_UDAFLAGS(R5)
	RSB				; Kill this thread.
START_STOP:
	PUSHL	R5			; Save R5 => UCB.
	BSBB	SUCCESS			; Complete QIO request but get control
					;  after REQCOM so as to continue.
	POPL	R5			; Restore R5 => UCB.
	REQPCHAN			; Re-allocate channel after REQCOM.
	MOVL	UCB$L_PDT(R5),R4	; R4 => PDT.
	BISB	#UDA$M_STOPPED,-	; Close port.
		UCB$B_UDAFLAGS(R5)
	RSB				; Kill this thread.
SUCCESS:
	MOVL	#SS$_NORMAL,R0		; Return success code.
	BRB	COMPLETE_IO		; And branch around.
ILLIOFUNC:
	MOVZWL	#SS$_ILLIOFUNC,R0		; We do not support other QIO's
COMPLETE_IO:
	CLRL	R1
	REQCOM
	.PAGE
	.SBTTL	+	"Register" Dump routine

;+ PU_REGDUMP
;
; Inputs:
;	R0 => Buffer to fill
;	R5 => UCB
;
; Outputs:
;	R1 modified
;

PU_REGDUMP:

	MOVL	#REGSAVE,(R0)+		; Save number of bytes following.
	MOVW	UCB$W_ATTNCODE(R5),(R0)+; Save Attention code (record type).
	MOVW	UCB$W_NUMBINITS(R5),(R0)+; Number times port init'ed.
	MOVL	UCB$L_CRB(R5),R1	; R1 => CRB.

	ASSUME	VEC$B_NUMREG	EQ	VEC$W_MAPREG+2
	ASSUME	VEC$B_DATAPATH	EQ	VEC$B_NUMREG+1
	MOVL	CRB$L_INTD+VEC$W_MAPREG(R1),(R0)+	; Save dedicated map registers.

	MOVZWL	UCB$W_UDASA(R5),(R0)+	; Save contents of SA register.

	ASSUME	UCB$W_HOSTSTEP1	EQ	UCB$W_PORTSTEP1+2
	ASSUME	UCB$W_PORTSTEP2	EQ	UCB$W_HOSTSTEP1+2
	ASSUME	UCB$W_HOSTSTEP2	EQ	UCB$W_PORTSTEP2+2
	MOVQ	UCB$W_PORTSTEP1(R5),(R0)+	; Save Host-Port dialogue.

	ASSUME	UCB$W_HOSTSTEP3	EQ	UCB$W_PORTSTEP3+2
	ASSUME	UCB$W_PORTSTEP4	EQ	UCB$W_HOSTSTEP3+2
	ASSUME	UCB$W_HOSTSTEP4	EQ	UCB$W_PORTSTEP4+2
	MOVQ	UCB$W_PORTSTEP3(R5),(R0)+	; Save Host-Port dialogue.

	RSB				; Return to caller.
	.PAGE
	.SBTTL	+	Function Decision Table

PU$FUNCTABLE:

	FUNCTAB	,-			;Valid functions:
		<STOP,-			; Stop port.
		 INITIALIZE>		; Reopen Port and Initialize.

	FUNCTAB	,-			;Buffered functions:
		<STOP,-			; Stop port.
		 INITIALIZE>		; Reopen Port and Initialize.
	FUNCTAB	+EXE$ZEROPARM,-		;ZERO PARAMETER FUNCTIONS
		<STOP,-			; Stop port.
		 INITIALIZE>		; Reopen Port and Initialize.
	.PAGE
	.SBTTL	+	Static Storage

; Static driver storage

	.ALIGN	LONG,0
PU$L_DRIVER_STS:	.LONG	0	; Status flag longword.
MAP$V_MAPREGS=0				; Bit meaning that the pseudo map
					;  registers have been mapped into
					;  system space at ^x800 in the Q-bus
					;  "CSR" area pointed at by ADP.
MAP$M_MAPREGS=1				; Mask of above bit.
PU$L_MPHYAD:		.LONG	0	; Physical address of "map registers".
PU$L_TRACE_VARIABLE:	.LONG	0	; Variable describing what kinds (if
					;  any) of trace have been enabled.
					; 0 implies no port tracing.
					; 1 implies we try to allocate resources
					;  to trace for ports that support Tapes
					; 2 implies that we try to allocate
					;  resources to trace all ports
	.PAGE
	.SBTTL	+	NULL MESSAGE AND DATAGRAM INPUT ROUTINES
	.SBTTL	+	NULL CDT

;+
; NULL CDT and NULL message input and datagram input routines.
;
; Inputs:		(for routines)
;
;	R1				-Length of message
;	R2				-Addr of message
;	R4				-Addr of PDT
;-

	.enabl	lsb

NULL_MSG_INPUT:				; Sequential messages for null connections
					;  are to be ignored.
	PUSHL	R3			; Save R3.
	BRB	10$			; Branch around to deallocate buffer.

NULL_DG_INPUT:				; Datagrams for null connections are to
					;  be logged.
	PUSHL	R3			; Save R3.
	MOVL	PDT$L_UCB0(R4),R3	; R3 => UCB. (input to ERL$LOGMESSAGE)
	MOVL	#EMB$C_UM,R0		; Log message type.
	JSB	G^ERL$LOGMESSAGE	; Call to log message.
10$:
	SUBL	#UDAB$T_TEXT,R2		; R2 => buffer header.
	BSBW	Q_DEALLOC_BUF		; Call internal entry to deallocate buffer.
	POPL	R3			; Restore R3.
NULL_ROUTINE:				; Label of an RSB instruction.
NULL_ERR_ROUT:
	RSB				; Return to our caller.

	.ALIGN	LONG,0
NULL_CDT:
	.BLKB	CDT$K_LENGTH		; Allocate space for the NULL CDT.
	.dsabl	lsb
	.PAGE
	.SBTTL	Request and Release DATAPATH transfer vectors

;+

	.ALIGN	LONG,0

REQDATAPATH_TV:				; Transfer vector to routine to request
					;  a UNIBUS datapath.
	.LONG	IOC$REQDATAPUDA		; Routine to call (for VAX-11/780).
					;  For other processors, this pointer
					;  will be overlaid with the address of
					;  REQDATAP_750 or REQDATAP_730, below.

RELDATAPATH_TV:				; Transfer vector to routine to release
					;  a UNIBUS datapath.
	.LONG	IOC$RELDATAPUDA		; Routine to call when running on
					;  VAX-11/780.  For other processors,
					;  this address is overlaid with the
					;  RELDATAP_750 or RELDATAP_730, below.

;
; REQDATAP_750 assigns the "semi-permanently" allocated datapath, currently
;	in use by the current burst, bumping the useage count by one,
;	or if no burst is in progress, allocates a buffered datapath and
;	then increments the useage count by one.
;
; The following paragraph applies only until the Buffered Datapath bug is
; fixed on VAX-11/750's.
;	If the current transfer is NOT longword aligned or if it is NOT
;	an integral number of longwords in length, we do NOT use the Buffered
;	Datapath but instead use the direct datapath.  We implicitly assign
;	direct datapath (i.e. datapath zero) by simply
;	RSB'ing to our caller, depending on the fact that our caller cleared
;	CDRP$L_UBARSRCE before calling us.  Note that in this case we do NOT
;	increment any useage count.
;
; REQDATAP_730 implicitly assigns the direct datapath to the current transfer
;	since the 730 has no buffered datapaths (i.e. datapath zero).  This is
;	accomplished by simply RSB'ing to our caller, depending on the fact
;	that our caller cleared CDRP$L_UBARSRCE before calling us.
;
;
; Inputs:
;	R4				-Addr of PDT
;	R5				-Addr of CDRP
;
; Outputs:(for REQDATAP_750 and REQDATAP_730)
;	CDRP$L_UBARSRCE+UBMD$B_DATAPATH set from PDT$B_DATAPATH.
;

REQDATAP_750:

	BISB3	CDRP$L_BCNT(R5),-		; R0 has "OR" of low
		CDRP$W_BOFF(R5),R0		;  bits of BOFF and BCNT,
	BITB	#3,R0				; Test for longword alignment
						;  and integral # longwords.
	BNEQ	REQDATAP_730			; NEQ means not aligned or
						;  possibly odd # of words
						;  being transferred.
						; Else fall thru to use pre-
						;  allocated datapath.
REQDATAP_8SS:					; UQport on a BUA.
	TSTB	PDT$B_BDPUSECNT(R4)		; Do we have semi-perm BDP?
	BNEQ	10$				; NEQ implies yes. Goto use it.
	JSB	G^IOC$REQDATAPUDA		; Call to allocate a BDP.
	MOVB	CDRP$L_UBARSRCE+UBMD$B_DATAPATH(R5),-	; Record new semi-perm
		PDT$B_DATAPATH(R4)			;  BDP in PDT.
10$:
	MOVB	PDT$B_DATAPATH(R4),-			; Assign semi-perm data-
		CDRP$L_UBARSRCE+UBMD$B_DATAPATH(R5)	;  path to transfer.
	INCB	PDT$B_BDPUSECNT(R4)			; Inc useage count.
	RSB					; Return to caller.

RELDATAP_750:

	BISB3	CDRP$L_BCNT(R5),-		; R0 has "OR" of low
		CDRP$W_BOFF(R5),R0		;  bits of BOFF and BCNT,
	BITB	#3,R0				; Test for longword alignment
						;  and integral # longwords.
	BNEQ	REQDATAP_730			; NEQ means not aligned or
						;  possibly odd # of words
						;  being transferred.
						; Else fall thru to use pre-
						;  allocated datapath.
RELDATAP_8SS:					; UQport on a BUA.
	DECB	PDT$B_BDPUSECNT(R4)		; DECR useage count.
	BNEQ	REQDATAP_730			; NEQ means not end of burst.
	JSB	G^IOC$RELDATAPUDA		; Release BDP after burst.

REQDATAP_730:				; Return to caller implicitly assigning
					;  direct datapath (i.e. datapath zero)
RELDATAP_730:				; Return to caller implicitly de-assigning
					;  direct datapath (i.e. datapath zero)

	RSB						; Return to caller.
	.PAGE
	.SBTTL	INITIALIZATION
;+
; The following table gives word offsets for fork process SCS calls.
; Offsets are relative to the address of the controller initialization
; routine, PU$CTLINIT.
;-

;
; Macro to generate the table and ASSUME statements about PDT format:
;

	.MACRO	SCS_OFFSET_TAB	ENTRY_LIST

	 $$$ENTRYNUM=0				; No entries in table yet
	 .IRP	ENTRY ENTRY_LIST		; For each entry in the list...
	 .WORD	<FPC$'ENTRY'-PU$CTLINIT>	;  insert offset from ctl init,
	 .IF	NE $$$ENTRYNUM			;  and for entries after the 1st
	 ASSUME	$$$PREV+4 EQ PDT$L_'ENTRY'	;  specify assumed PDT adjacency
	 .ENDC					;
	 $$$PREV=PDT$L_'ENTRY'			; Set previous entry as this entry
	 $$$ENTRYNUM=$$$ENTRYNUM+1		; Step entry count
	 .ENDR					;

	 ASSUME	$$$PREV+4 EQ PDT$C_SCSEND	; Final PDT assumption
	 .WORD	0				; Offset table terminator
	
	.ENDM	SCS_OFFSET_TAB			;

;
; Table itself:
;

PU$SCSOFFSET::

	SCS_OFFSET_TAB	<-			; Invoke macro to define offsets
		ACCEPT,-		
		ALLOCDG,-
		ALLOCMSG,-
		CONNECT,-
		DEALLOCDG,-
		DEALLOMSG,-
		DEALRGMSG,-
		DCONNECT,-
		MAP,-
		MAPBYPASS,-
		MAPIRP,-
		MAPIRPBYP,-
		QUEUEDG,-
		QUEUEMDGS,-
		RCHMSGBUF,-
		RCLMSGBUF,-
		REJECT,-
		REQDATA,-
		SENDDATA,-
		SENDDG,-
		SENDMSG,-
		SNDCNTMSG,-
		UNMAP,-
		READCOUNT,-
		RLSCOUNT,-
		MRESET,-
		MSTART,-
		MAINTFCN,-
		SENDRGDG,-
		STOP_VCS,-
		>

	.SBTTL	+	UNIT_INIT

;+
; TBS
;
; Inputs:
;	
;	R3			-Address of PA configuration reg
;	R4			-Same as R3
;	R5			-Addr of UCB
;
; Outputs:
;
;	R0				-Status code
;					(SS$_NORMAL,SS$_INSFMEM, or 0 if no SVPN)
;	R1-R4				-Destroyed
;	Other registers		-Preserved
;-

	.ENABL	LSB

PU$UNITINIT::

;	MOVB	#DT$_UDA50,UCB$B_DEVTYPE  ; Set the device type to UDA50
	TSTW	UCB$W_UNIT(R5)		; Is this unit 0?
	BEQL	INIT_CTLR		; If YES, go to init controller first.

	BISW	#UCB$M_ONLINE,-		; Else merely set unit on line
		UCB$W_STS(R5)		;  and
	RSB				; Return
	.DSABL	LSB
	.PAGE
	.SBTTL	+	CONTROLLER INIT

;+
; The controller initialization entry as seen by the system, PU$CTLINIT,
; is a noop since initialization can't begin without the unit 0 UCB.
; Actual controller init is called from unit 0 unit initialization with
; the same inputs as unit init.
;
;
; Inputs:
;
;	R3			-Addr of PU CSR
;	R4			-Same as R3
;	R5			-Addr of UCB for unit 0
;
; Outputs:
;
;	R0-R3			-Destroyed
;	Other registers 	-Preserved
;-

PU$CTLINIT::				; Controller init called by system

	RSB				; Return
	.PAGE
;
; Controller initialization called from unit 0 init.
;
; Inputs:
;	R5				-UCB address
;
; Outputs:
;	R0				-Status code
;					(SS$_NORMAL,SS$_INSFMEM, or 0 if no SVPN)

BRW_OPCODE=^x31				; Opcode of BRW instruction, used in
					;  concocting PATCH below.

	.enabl	lsb

INIT_CTLR::

	BRB	0$			; Branch around breakpoint.
	JSB	G^INI$BRK		; Breakpoint for debugging.
0$:
	TSTL	UCB$L_PDT(R5)		; See if first time thru here.
	BNEQ	POWER_INIT		; NEQ implies this is POWER FAILURE.
	TSTL	PU$L_TRACE_VARIABLE	; See if any tracing requested.
	BEQL	5$			; EQL implies NO tracing.

; Here if tracing has been enabled.  There are two places in the inline code
; where we would like to trace; once in Send Sequence message, and once when
; receiving a message.  In order to accomplish this, we here dynamically
; patch a BRW instruction into the two appropriate locations.

	MOVL	#BRW_OPCODE!-		    ; If tracing enabled, patch code
		<ENABLE_COMMAND_OFFSET@8>,- ;  into Send Message Logic to trace
		W^ENABLE_COMMAND_START	    ;  outgoing message.
	MOVL	#BRW_OPCODE!-		    ; Here patch code into Receive Logic
		<ENABLE_RESPONSE_OFFSET@8>,-; to trace received message.
		W^ENABLE_RESPONSE_START
5$:
	BISW	#UCB$M_PU_FRKBSY,-	; Indicate the UCB fork block is in
		UCB$W_DEVSTS(R5)	;  use. Setting this bit defers processing
					;  powerfailure recovery until after
					;  initialization completes.
	IOFORK				; Lower IPL.

	REQPCHAN			; Permanently allocate channel.

	MOVB	#DC$_BUS,-		; Initialize constant UCB fields.
		UCB$B_DEVCLASS(R5)
	MOVB	#DT$_UQPORT,-		; Type of UQPORT will be determined
		UCB$B_DEVTYPE(R5)	;  later.

; Initialize CRB wakeup mechanism.

	MOVL	UCB$L_CRB(R5),R3	; R3 => CRB.
	MOVL	R5,CRB$L_AUXSTRUC(R3)	; CRB => UCB as auxillary structure.
	MNEGL	#1,CRB$L_DUETIME(R3)	; Set infinite time.
	MOVAB	NULL_ROUTINE,-
		CRB$L_TOUTROUT(R3)	; Inocuous routine for now.
	JSB	G^IOC$THREADCRB		; Put CRB on wakeup list.

	BSBW	BUILD_PDT		; Allocate and fill in PDT.
	BLBC	R0,15$			; Return error status to caller.
	BSBW	INIT_UDA_BUFFERS	; Map area in PDT containing buffers.
	BLBC	R0,15$			; Return error status to caller.
	BSBW	INIT_INIT_STEPS		; Initialize values in UCB to use
					;  in UDA hardware initialization.
	BLBC	R0,15$			; Return error status to caller.
	BSBW	BUILD_PB_SB		; Create and fill in system block and
					;  path block.
	BLBC	R0,15$			; Return error status to caller.
10$:
	MOVB	#NO_CONSEC_INITS,-	; Initialize UCB field that counts
		UCB$B_INITCNT(R5)	;  hardware init retries.

	BSBW	HARDWARE_INIT		; Init UDA hardware.
	BLBC	R0,15$			; LBC implies couldn't Init hardware.
	BSBW	UPDATE_PB_SB		; Update fields in the Path and System blocks.
	BISW	#UCB$M_ONLINE,-		; After hardware init, we are online.
		UCB$W_STS(R5)
	BSBW	POLL_RSPRING		; This call has the effect of clearing
					;  the UCB$M_PU_FRKBSY bit in
					;  UCB$W_DEVSTS and also of finding any
					;  responses that may have backed up
					;  due to the bit's having been set.
	MOVL	#SS$_NORMAL,R0		; Set return code.
15$:
	RSB

POWER_INIT:

	BBCS	#UCB$V_PU_FRKBSY,-	; Appropriate UCB fork block if free,
		UCB$W_DEVSTS(R5),20$	;  else continue and RSB.
	RSB				; If fork block busy, relie on
					;  Interrupt Service Routine to GOTO
					;  POST_POWER_FORK.
20$:
	IOFORK				; Lower IPL so as to continue with
					;  signaling SYSAPS that the VC fell.
	BRB	30$			; Branch around Fork block appropriation.
POST_POWER_FORK:

; Here we turn off CRB wakeup mechanism.

	MOVL	UCB$L_CRB(R5),R0	; R0 => CRB.
	MNEGL	#1,CRB$L_DUETIME(R0)	; Set infinite time.
	MOVAB	NULL_ROUTINE,-
		CRB$L_TOUTROUT(R0)	; Inocuous routine for now.

	BBCS	#UCB$V_PU_FRKBSY,-	; Appropriate the UCB fork block if NOT
		UCB$W_DEVSTS(R5),30$	;  busy and branch around.
	BISW	#UCB$M_PU_MRESET,-	; Indicate that whoever has fork block
		UCB$W_DEVSTS(R5)	;  busy, should reset upon wakeup.
	RSB				; Return to caller to kill thread.
30$:
	BICW	#UCB$M_PU_MRESET,-	; Clear bit possibly set above.
		UCB$W_DEVSTS(R5)
	BICW	#UCB$M_ONLINE!-		; If here we are not online,
		 UCB$M_POWER,-		;  and the power failure is being handled
		UCB$W_STS(R5)


; Here we call the CONNECTION error routine for each connection.

	MOVL	#3,R3			; R3 = highest possible connection index.
40$:
	MOVL	UCB$L_PDT(R5),R4		; R4 => PDT.
	PUSHL	R3				; Save connection index.
	PUSHL	R5				; Save R5 => UCB.
	MOVL	PDT$L_PU_CDTARY(R4)[R3],R3	; R3 => CDT.
	JSB	@CDT$L_ERRADDR(R3)		; Call connection error routine.
						; NOTE: that for closed connections,
						;  the error routine is the NULL
						;  one that is just an RSB.
	POPL	R5				; Restore R5 => UCB.
	POPL	R3				; Restore R3 = connection index.
	SOBGEQ	R3,40$				; Loop thru all possible indices.
	BRB	10$				; Branch back to re-init port.
	.dsabl	lsb
	.PAGE
	.SBTTL	+	Build PDT

;+
; BUILD_PDT - allocate and fill in non variable data in the UDA port PDT.
; This routine has processor dependent code to separate code streams for
; uVAX I ports, and for all other systems.  The uVAX I needs special
; treatment for various reasons.
;
;	1. First, for uVAX I, the communications area, the buffers, and the
;	   Pseudo Map Registers (these are not needed at all for other systems)
;	   must all be in physically contiguous memory pages.  To accomodate
;	   this, for uVAX I we allocate the entire PDT in physically
;	   contiguous memory.
;
;	2. Second, the base of the Pseudo Map Registers must be on a page
;	   boundary.  To accomodate this need, the first four pages of the
;	   contiguous region we allocate for the PDT is used for this purpose.
;	   A pointer to this region is left in PDT$L_PQ_MAP.
;
;	3. For uVAX I, the communications area must not straddle a 64KB
;	   boundary.  Currently, the communicatons area is much less
;	   than a page in length and if it can be shown that the communications
;	   area does not straddle a page boundary, this would be sufficient
;	   to show that it does not straddle a 64KB boundary.  Since the PDT
;	   is located on a page boundary, we determine the byte offset of the
;	   base of the communications area (symbol COMAREA_BOFF).

	   COMAREA_BOFF = PDT$L_COMAREA & 511

;	   This allows us to establish an ASSUME statement that proves
;	   that the communications area does not straddle a page boundary.

	   ASSUME	COMAREA_BOFF+PDT$C_COMAREALN	LE	512

;	   Future changes to the PDT might break this ASSUME, and a possible
;	   re-arrangement of the layout of the PDT would be called for at that
;	   time.
;
;	4. Finally, the routines that implement SCS functions "MAP_IRP" and
;	   "UNMAP" are different on uVAX I systems, so therefore the  PDT
;	   dispatch vectors for these functions are treated separately for
;	   uVAX I.
;
;
; Inputs:
;	R5				-Addr of UCB
;
; Outputs:
;	R0				-Status code (SS$_NORMAL,SS$_INSFMEM)
;

;
; PDT adjacency assumptions:
;

ASSUME	PDT$W_SIZE	EQ 8
ASSUME 	PDT$W_SIZE+2	EQ PDT$B_TYPE
ASSUME	PDT$B_TYPE+1	EQ PDT$B_SUBTYP
ASSUME	PDT$B_SUBTYP+1	EQ PDT$C_SCSBASE

		.enabl	lsb

BUILD_PDT:

	CPUDISP	<<780,ALLOC_PDT_NOTUV1>,-	; Dispatch to allocate a CPU dependent
		 <750,ALLOC_PDT_NOTUV1>,-	;  sized PDT.
		 <730,ALLOC_PDT_NOTUV1>,-
		 <790,ALLOC_PDT_NOTUV1>,-
		 <UV1,ALLOC_PDT_UV1>,-
		 <8SS,ALLOC_PDT_8SS>,-
		>


ALLOC_PDT_8SS:				; See if we are on a UNIBUS adapter
					;  or else on a BDA.
	MOVL	UCB$L_CRB(R5),R0		; R0 => CRB.
	MOVL	CRB$L_INTD+VEC$L_ADP(R0),R0	; R0 => ADP.
	CMPW	#AT$_UBA,ADP$W_ADPTYPE(R0)	; See if on UNIBUS adapter.
	BEQL	ALLOC_PDT_NOTUV1		; If yes, branch.
;
; Here we must be on a BDA. Appropriate code may one day be placed here.
; Till then,
	BUG_CHECK	UDAPORT,FATAL
	
ALLOC_PDT_NOTUV1:

	MOVZWL	#PDT$C_PULENGTH,R1	; R1 contains PDT size needed for other
					;  CPU's.
	BSBW	ALLOC_POOL		; Allocate R1 bytes from pool
	BLBS	R0,20$			; Branch if success to common code.
	BRW	100$			; Else goto return error

ALLOC_PDT_UV1:				; uVAX I needs physically contiguous
					;  memory long enough for the map
					;  registers (4 pages) and the PDT.

UV1_PDT_LENGTH = <PDT$C_UV1LENGTH + 511> & <^c511>
UV1_PDT_PAGES = UV1_PDT_LENGTH / 512	; Pages needed for uVAX I PDT.

	MOVL	#UV1_PDT_PAGES,R1	; R1 contains pages needed for uVAX I
					;  PDT.

	JSB	G^EXE$ALOPHYCNTG	; Allocate physically contiguous memory.
	BLBS	R0,10$			; LBS means successful allocation.
	BRW	100$			; Else goto error return.
10$:
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	; Save MOVC registers
	MOVC5	#0,(SP),#0,-		; Zero initialize structure
		#<UV1_PDT_PAGES>*512,-
		(R2)
	POPR	#^M<R0,R1,R2,R3,R4,R5>	; Restore MOVC registers

	MOVW	#UV1_PDT_LENGTH,R1	; Set size of uVAX I PDT into R1.
20$:
	MOVL	R2,UCB$L_PDT(R5)	; Save PDT addr
	MOVL	R5,PDT$L_UCB0(R2)	; PDT => UCB.
	MOVL	UCB$L_CRB(R5),R3	; Get CRB addr
	MOVL	R2,CRB$L_AUXSTRUC(R3)	;  and save PDT addr in CRB
	CLRQ	(R2)+			; Init PDT, unused longwds,
	MOVW	#PDT$M_SNGLHOST,-	; Indicate port to single host bus,(-8
		PDT$W_PORTCHAR-8(R2)	;  takes into account (R2)+ above).
	MOVB	#PDT$C_PU,-		; Indicate type of PDT created, (-8
		PDT$B_PDT_TYPE-8(R2)	;  takes into account (R2)+ above).

	ASSUME	PDT$W_SIZE	EQ	8
	MOVW	R1,(R2)+		;  PDT size,

	ASSUME	PDT$B_TYPE	EQ	10
	ASSUME	PDT$B_SUBTYP	EQ	11
	MOVW	#<DYN$C_SCS_PDT@8 + DYN$C_SCS>,(R2)+  ;  structure subtype and type

	MOVL	CRB$L_INTD+VEC$L_INITIAL(R3),R3  ; Get addr of controller
						 ;  init routine
	MOVAW	PU$SCSOFFSET,R1		; Get addr of table of offsets
					;  to SCS entries in PUDRIVER

30$:	CVTWL	(R1)+,R0		; Get offset to next SCS routine
	BEQL	40$			; Branch if no more
	ADDL3	R0,R3,(R2)+		; Add offset from controller init
					;  to addr of controller init
					;  and store in PDT
	BRB	30$			; Get next offset

40$:
	MOVL	UCB$L_PDT(R5),R1		; R1 => PDT.
	MOVL	UCB$L_CRB(R5),R0		; R0 => CRB.
	MOVL	CRB$L_INTD+VEC$L_ADP(R0),-	; Save ADP address in PDT.
		PDT$L_ADP(R1)
	ASSUME	IDB$L_CSR	EQ	0
	MOVL	@CRB$L_INTD+VEC$L_IDB(R0),-	; Save CSR addr in PDT.
		PDT$L_PU_CSR(R1)
	MOVZWL	#<127*512>, -		; Define maximum byte count supported
		PDT$L_MAXBCNT(R1)	; for block transfers as 127 blocks.


	CPUDISP	<<780,NO_OVERLAYMAP>,-	; Dispatch around overlaying of MAP
		 <750,NO_OVERLAYMAP>,-	;  and UNMAP pointers uVAX I.
		 <730,NO_OVERLAYMAP>,-
		 <790,NO_OVERLAYMAP>,-
		 <UV1,OVERLAYMAP>,-
		 <8SS,OVERLAYMAP_8SS>,-
		>

OVERLAYMAP_8SS:				; If on a UNIBUS adapter, goto
					;  NO_OVERLAYMAP.
	MOVL	PDT$L_ADP(R1),R0	; R0 => ADP.
	CMPW	#AT$_UBA,-		; See if on UNIBUS adapter.
		ADP$W_ADPTYPE(R0)
	BEQL	NO_OVERLAYMAP		; EQL implies UNIBUS adapter.

; For the BDA port the MAPIRP and UNMAPIRP functions are distinct.
;  Here we overlay the PDT dispatch vectors for these functions.

	MOVAB	w^FPC$MAPIRP_BDA,-	; Overlay PDT dispatch vector for MAPIRP
		PDT$L_MAPIRP(R1)	;  on BDA.
	MOVAB	w^FPC$UNMAP_BDA,-	; Overlay PDT dispatch vector for UNMAP
		PDT$L_UNMAP(R1)		;  on BDA.
	BRB	NO_OVERLAYMAP		; Branch around to join common code.

OVERLAYMAP:

; For the uVAX I Q-BUS port the MAPIRP and UNMAPIRP functions are distinct.
;  Here we overlay the PDT dispatch vectors for these functions.

	MOVAB	w^FPC$MAPIRP_UV1,-	; Overlay PDT dispatch vector for MAPIRP
		PDT$L_MAPIRP(R1)	;  on uVAX I.
	MOVAB	w^FPC$UNMAP_UV1,-	; Overlay PDT dispatch vector for UNMAP
		PDT$L_UNMAP(R1)		;  on uVAX I.

NO_OVERLAYMAP:

; Init NULL CDT with addresses of message and datagram input routines.

	MOVAB	NULL_MSG_INPUT,-		; Address of message input
		NULL_CDT+CDT$L_MSGINPUT		;  routine.
	MOVAB	NULL_DG_INPUT,-			; Address of datagram input
		NULL_CDT+CDT$L_DGINPUT		;  routine.
	MOVAB	NULL_ERR_ROUT,-			; Address of error routine.
		NULL_CDT+CDT$L_ERRADDR
	MOVAB	NULL_CDT+CDT$L_CRWAITQFL,-	; Init dummy list header.
		NULL_CDT+CDT$L_CRWAITQFL
	MOVAB	NULL_CDT+CDT$L_CRWAITQFL,-
		NULL_CDT+CDT$L_CRWAITQBL

; Init CDT pointers to all point to NULL CDT.

	MOVAB	NULL_CDT,R0			; R0 => NULL CDT.
	MOVL	R0,PDT$L_PU_VC0(R1)		; VC0 CDT pointer => NULL CDT.
	MOVL	R0,PDT$L_PU_VC1(R1)		; VC1 CDT pointer => NULL CDT.
	MOVL	R0,PDT$L_PU_VC2(R1)		; VC2 CDT pointer => NULL CDT.
	MOVL	R0,PDT$L_PU_VC255(R1)		; VC255 CDT pointer => NULL CDT.

	CMPL	PU$L_TRACE_VARIABLE,#1	; Determine what kind (if any) tracing
					;  is desired.  0 implies no tracing,
					;  1 implies only try to allocate
					;  resources for "PT" tracing, and
					;  2 implies always try to allocate.

	BLSS	90$			; LSS implies 0, so branch around since
					;  we want no tracing.
	BGTR	80$			; GTR implies 2, so branch around to try
					;  to allocate trace tables.

					; If here we only want "PT" tracing,
					;  then test for a "PT" port and
					;  if not there, branch around.

	MOVL	UCB$L_DDB(R5),R1	; R1 => DDB.  See if "PU" or "PT" device
	CMPB	#^A/T/,DDB$T_NAME+2(R1)	; Test for "T" in name.
	BNEQ	90$			; Since we want to trace "PT" only,
					;  if NOT "PT" then branch around.
80$:
	MOVL	#500*96+16,R1		; Allocate trace table for 500 entries.
	BSBW	ALLOC_POOL		; Call to allocate.
	BLBC	R0,90$			; LBC implies failure.

	MOVL	UCB$L_PDT(R5),R0	; R0 => PDT.
					;  check.
	CLRQ	(R2)+			; Initialize trace table header for SDA.
	MOVW	R1,(R2)+		; Save size.
	MOVW	#DYN$C_SCS,(R2)+	; Type.
	CLRL	(R2)+			; Round header upto 16 byte boundary.
	MOVL	R2,PDT$L_TRTABLE(R0)	; Save pointer to base of trace table.
	MOVL	R2,PDT$L_TRTBLPTR(R0)	; Pointer to next area to use.
	ADDL3	#500*96,R2,-		; Pointer to beyond end of trace
		PDT$L_TRTBLEND(R0)	;  table.
90$:
	MOVL	S^#SS$_NORMAL,R0	; Return success.
100$:
	RSB
	.dsabl	lsb
	.PAGE
	.SBTTL	+	TRACE_COMMAND and TRACE_RESPONSE

; Routines to record command and response buffer contents in the trace table.
;	Trace table entries are 96 bytes long so that they line up nicely in
;	a dump.
;

TRACE_COMMAND:				; INPUTS: R2 => Command buffer,
					;	  R4 => PDT.

	MOVQ	R0,-(SP)		; Save R0 and R1.
	MOVL	R2,R0			; R0 => buffer to trace.
	BRB	TRACE_COMMON		; Branch around to common code.

TRACE_RESPONSE:				; INPUTS: R3 => Response buffer,
					;	  R4 => PDT.

	MOVQ	R0,-(SP)		; Save R0 and R1.
	MOVL	R3,R0			; R0 => buffer to trace.

TRACE_COMMON:

	TSTL	PDT$L_TRTABLE(R4)	; Test for existence of trace table.
	BEQL	30$			; EQL implies unable to allocate table.

	DSBINT				; Prevent interrupts during allocation
					;  of trace table entry.
	MOVL	PDT$L_TRTBLPTR(R4),R1	; R1 => area in trace table to use.
	CMPL	PDT$L_TRTBLEND(R4),R1	; See if we should circle back to start
					;  of trace table.
	BGTR	20$			; GTR implies NO.
	MOVL	PDT$L_TRTABLE(R4),R1	; R1 => base of trace table.
20$:
	ADDL3	#96,R1,PDT$L_TRTBLPTR(R4); Point to next entry.
	ENBINT				; Undo DSBINT.
	MOVQ	(R0)+,(R1)+		; Twelve long words are 96 bytes.
	MOVQ	(R0)+,(R1)+
	MOVQ	(R0)+,(R1)+
	MOVQ	(R0)+,(R1)+
	MOVQ	(R0)+,(R1)+
	MOVQ	(R0)+,(R1)+
	MOVQ	(R0)+,(R1)+
	MOVQ	(R0)+,(R1)+
	MOVQ	(R0)+,(R1)+
	MOVQ	(R0)+,(R1)+
	MOVQ	(SP),(R1)+		; Trace saved R0, R1.
	MOVL	8(SP),(R1)+		; Also trace caller's return point.
	MOVL	PDT$L_UCB0(R4),R0	; R0 => UCB.
	SUBL	UCB$L_DDT(R0),-4(R1)	; Make traced return point relative.
	MNEGL	#1,(R1)+		; Flag marks end of trace entry.
30$:
	MOVQ	(SP)+,R0		; Restore R0 and R1.
	RSB
	.PAGE
	.SBTTL	+	INIT_UDA_BUFFERS

;+
; INIT_UDA_BUFFERS - accomplishes the following:
;
;	1. It fills in UCB$W_PU_BCNT, UCB$W_PU_BOFF and UCB$L_PU_SVAPTE and clears
;		CRB$L_INTD+VEC$W_MAPREG. It then copies them to UCB$W_BCNT,
;		UCB$W_BOFF and UCB$L_SVAPTE so that the standard UNIBUS
;		map register allocation routine will allocate enough
;		of these map registers to map the area located at
;		PDT$L_COMAREA which is PDT$C_RINGLEN long.
;		It then calls IOC$ALOUBMAPRM to permanently allocate
;		the map registers.  The value left in UCB$L_PU_SVAPTE, along
;		with the values left in CRB$L_INTD+VEC$W_MAPREG by
;		IOC$ALOUBMAPRM, allow the later loading of the allocated
;		map registers. (Note the map registers are loaded at
;		intialization time and after every reset of the port.)
;
;	2. It calculates the UNIBUS virtual address of the text portion
;		of each of the 2*UDA$K_RINGSIZE buffers and stores this
;		virtual address in the low order 18 bits of the buffer
;		header, at offset UDAB$L_DESCRIP.  The UDA_M_OWN and
;		UDA_M_FLAG bits are also set on in UDAB$L_DESCRIP so
;		that this value can now be moved directly into a ring
;		slot (be it command or response ring) to effect the transfer
;		of this buffer to the port.
;
; Inputs:
;	R5				-Addr of UCB
;
; Outputs:
;	R0				-Status code (SS$_NORMAL or 0 if no SVPN)
;	R1-R4				-Destroyed
;	R5				-Preserved
;-

	.enabl	lsb

INIT_UDA_BUFFERS:

	MOVL	UCB$L_PDT(R5),R4		; R4 => PDT.

	CPUDISP	<<780,COM_INIT_UDA_BUFS>,-	; Dispatch to allow special
		 <750,COM_INIT_UDA_BUFS>,-	;  casing of uVAX I.
		 <730,COM_INIT_UDA_BUFS>,-
		 <790,COM_INIT_UDA_BUFS>,-
		 <UV1,INIT_UDA_BUFS_UV1>,-
		 <8SS,INIT_UDA_BUFS_8SS>,-
		>

INIT_UDA_BUFS_8SS:
	MOVL	PDT$L_ADP(R4),R0	; R0 => ADP.
	CMPW	#AT$_UBA,-		; See if on UNIBUS adapter.
		ADP$W_ADPTYPE(R0)
	BEQL	COM_INIT_UDA_BUFS	; EQL implies UNIBUS adapter.
	BRW	INIT_BDA_BUFS		; Else branch to init BDA buffers.

COM_INIT_UDA_BUFS:

; Initialize fields in UCB so as to allow standard IOSUBNPAG routines
;	to allocate MAP registers.

	MOVW	#PDT$C_RINGLEN,-	; Length of area to map.
		UCB$W_PU_BCNT(R5)
	MOVAB	PDT$L_COMAREA(R4),R2	; R2 => area to map.
	BICW3	#^XFE00,R2,-
		UCB$W_PU_BOFF(R5)	; Get offset of area to map.
	EXTZV	S^#VA$V_VPN,-
		S^#VA$S_VPN,R2,R2	; R2 = virtual page # of area.
	MOVL	G^MMG$GL_SPTBASE,R0	; R0 => system page table.
	MOVAL	(R0)[R2],UCB$L_PU_SVAPTE(R5)
					;

	MOVL	UCB$L_CRB(R5),R3	; R3 => CRB.
	CLRL	CRB$L_INTD+VEC$W_MAPREG(R3)
					; Initialize to direct datapath (0).
	CPUDISP	<<780,DATAPATH_780>,-	; Label of VAX-11/780 specific code.
		 <750,DATAPATH_750>,-	; Label of VAX-11/750 specific code.
		 <730,DATAPATH_730>,-	; Label of VAX-11/730 specific code.
		 <790,DATAPATH_790>,-	; label of VAX-11/790 specific code.
		 <8SS,DATAPATH_8SS>,-	; label of VAX-11/8SS specific code.
		>
DATAPATH_8SS:
	MOVAB	REQDATAP_8SS,-		; Overlay transfer vector when running
		REQDATAPATH_TV		;  on a VAX-11/8SS.
	MOVAB	RELDATAP_8SS,-		; Overlay transfer vector when running
		RELDATAPATH_TV		;  on a VAX-11/8SS.
	BRB	DATAPATH_780		; And branch around.

DATAPATH_750:
	MOVAB	REQDATAP_750,-		; Overlay transfer vector when running
		REQDATAPATH_TV		;  on a VAX-11/750.
	MOVAB	RELDATAP_750,-		; Overlay transfer vector when running
		RELDATAPATH_TV		;  on a VAX-11/750.
	BRB	DATAPATH_780		; And branch around.

DATAPATH_730:
	MOVAB	REQDATAP_730,-		; Overlay transfer vector when running
		REQDATAPATH_TV		;  on a VAX-11/730.
	MOVAB	RELDATAP_730,-		; Overlay transfer vector when running
		RELDATAPATH_TV		;  on a VAX-11/730. Then fall thru.

DATAPATH_780:
DATAPATH_790:				; 11/790 mimics the 11/780.
	ASSUME	PDT$B_BDPUSECNT	EQ	PDT$B_DATAPATH+1
	CLRW	PDT$B_DATAPATH(R4)	; Clear # of semi-perm BDP and use count.

	CLRB	CRB$L_INTD+VEC$B_DATAPATH(R3)	; Clear CRB field.

	ASSUME	UCB$W_BOFF	EQ	UCB$L_SVAPTE+4
	ASSUME	UCB$W_BCNT	EQ	UCB$W_BOFF+2
	ASSUME	UCB$W_PU_BOFF	EQ	UCB$L_PU_SVAPTE+4
	ASSUME	UCB$W_PU_BCNT	EQ	UCB$W_PU_BOFF+2

	MOVQ	UCB$L_PU_SVAPTE(R5),-	; Copy parameters to standard
		UCB$L_SVAPTE(R5)	;  locations.
	JSB	G^IOC$ALOUBMAPRM	; Permanently allocate map registers.

; Here calculate the UNIBUS virtual address of each buffer.

	MOVZWL	UCB$W_PU_BOFF(R5),R0	; Byte offset of mapped area.
	MOVL	UCB$L_CRB(R5),R1	; R1 => CRB

	INSV	CRB$L_INTD+VEC$W_MAPREG(R1),#9,#9,R0	; R0 contains UNIBUS
							;  VA of base of area.

	PUSHL	R0			; Save on stack.

	CLRL	R0			; Initialize loop counter.

	MOVAB	PDT$L_PU_BUFARY+UDAB$T_TEXT(R4),R1	; R1 => text portion
							;  of first buffer.
5$:
;	ASSUME	UDAB$B_BUFFNO+1 	is 	Reserved byte.
	MOVZBW	R0,UDAB$B_BUFFNO-UDAB$T_TEXT(R1); Store index of this
						;  buffer in its header.
	MOVAB	-UDAB$T_TEXT(R1),-		; Point Buffer table array
		PDT$L_BDTABLE(R4)[R0]		;  element to this buffer.
	MOVAB	PDT$L_COMAREA(R4),R2		; R2 => base of mapped area.
	SUBL3	R2,R1,R2			; R2 = offset of this buffer
						;  from base of mapped area.
	ADDL3	(SP),R2,-			; Calculate UNIBUS VA of this
		UDAB$L_DESCRIP-UDAB$T_TEXT(R1)	;  buffer.

	BISL	#UDA_M_OWN!-			; Set port ownership and mark
		 UDA_M_FLAG,-			;  so port should interrupt on
		UDAB$L_DESCRIP-UDAB$T_TEXT(R1)	;  ring transitions.

	ADDL	#UDAB$C_LENGTH,R1	; R1 => text portion of next buffer.
	AOBLSS	#2*UDA$K_RINGSIZE,R0,5$	; Loop thru all buffers.

	TSTL	(SP)+			; Clear stack.
	MOVL	#SS$_NORMAL,R0		; Set status return.
	BRW	INIT_UDA_BUFS_RTN	; Branch around to return.

INIT_UDA_BUFS_UV1:

	MOVL	UCB$L_CRB(R5),R3	; R3 => CRB.
	CLRL	CRB$L_INTD+VEC$W_MAPREG(R3)
					; Initialize to direct datapath (0).

; To use the common allocate/deallocate map register routines, the ADP$L_CSR
; field in the Qbus adapter control block must be set to point to a base address
; such that the pseudo map registers existing in the PDT appear at the UBA$L_MAP
; offset from this base address.  Currently the SVAPTEs allocated at the time
; the adapter is initialized (INIADP) point to non-existant memory addresses.
; These must instead point to the 4 pages of map entries allocated as part
; of the PDT.

	BBSS	#MAP$V_MAPREGS,-	; Ensure that we use only one set of
		PU$L_DRIVER_STS,-	;  "map registers", gets mapped into
		15$			;  the virtual range pointed at by
					;  ADP$L_CSR.  This bit allows us to
					;  pass thru here just once, for the
					;  first UQPORT found on a UV1 system.

	MOVL	#4,R1			; R1 contains pages needed for uVAX I
					;  pseudo map registers.

	JSB	G^EXE$ALOPHYCNTG	; Allocate physically contiguous memory.
	BLBS	R0,8$			; LBS means successful allocation.
	BICL	#MAP$M_MAPREGS,-	; Undo setting of bit above since we
		PU$L_DRIVER_STS		;  have failed to create map registers.
	BRW	INIT_UDA_BUFS_RTN	; And goto error return.
8$:
	MOVL	R2,PDT$L_PQ_MAP(R4)	; Remember address of map registers.
	MOVL	R2,R1			; Setup for call to BSBW to convert
					;  virtual address of map registers
					;  to physical address.
	BSBW	VIRT_TO_PHYAD		; Convert R1 to physical address and
					;  leave result on top of stack.
	ASSUME	ADP$L_CSR	EQ	0
	MOVL	@CRB$L_INTD+VEC$L_ADP(R3),R0 ; Get address of Qbus adapter CSR.
	EXTZV	#VA$V_VPN,#VA$S_VPN,R0,R0 ; Convert from VA to VPN.
	MOVL	G^MMG$GL_SPTBASE,R1	; Get address of system page table.
	MOVAL	(R1)[R0],R0		; Get SVAPTE of Qbus adapter CSR.
	ADDL	#<4*4>,R0		; Point to SVAPTEs for map registers.
	ASHL	#-VA$V_VPN,(SP),R1	; Get PFN of pseudo map registers.
	MOVZBL	#4,-(SP)		; Count of pages of map registers.
10$:	INSV	R1,#PTE$V_PFN,#PTE$S_PFN,(R0) ; Set SPTE to map pseudo map reg.
	ADDL	#4,R0			; Get SVAPTE of next PTE.
	INCL	R1			; Point to next physical PFN.
	SOBGTR	(SP),10$		; Loop to map all four pages.
	ADDL	#4,SP			; Clean counter off stack.	

	POPL	PU$L_MPHYAD		; Pop physical address into static.
15$:
	ASSUME	PDT$B_BDPUSECNT	EQ	PDT$B_DATAPATH+1
	CLRW	PDT$B_DATAPATH(R4)	; Clear # of semi-perm BDP and use count.

	CLRL	R0			; Initialize loop counter.

	MOVAB	PDT$L_PU_BUFARY+UDAB$T_TEXT(R4),R1	; R1 => text portion
							;  of first buffer.
20$:
;	ASSUME	UDAB$B_BUFFNO+1 	is 	Reserved byte.
	MOVZBW	R0,UDAB$B_BUFFNO-UDAB$T_TEXT(R1); Store index of this
						;  buffer in its header.
	MOVAB	-UDAB$T_TEXT(R1),-		; Point Buffer table array
		PDT$L_BDTABLE(R4)[R0]		;  element to this buffer.

	BSBW	VIRT_TO_PHYAD		; Convert R1 to physical address and
					;  leave result on top of stack.
	BISL3	#UDA_M_OWN!-			; Set port ownership and mark
		 UDA_M_FLAG,(SP)+,-		;  so port should interrupt on
		UDAB$L_DESCRIP-UDAB$T_TEXT(R1)	;  ring transitions.

	ADDL	#UDAB$C_LENGTH,R1	; R1 => text portion of next buffer.
	AOBLSS	#2*UDA$K_RINGSIZE,R0,20$; Loop thru all buffers.

; Here initialize the Aligned Page and its accompanying items.  These are:
;
;	1. PDT$L_PQ_PGQFL and PDT$L_PQ_PGQBL - An allocation queue header
;		wherein we queue CDRP's waiting waiting for this resource.
;
;	2. PDT$L_PQ_POWNER - The CDRP of the current owner of the Aligned Page.
;
;	3. PDT$L_PQ_PGPHAD - The Physical address of PDT$L_PQ_ALGNPG.
;

	MOVAB	PDT$L_PQ_PGQFL(R4),-	; Set up Queue Header.
		PDT$L_PQ_PGQFL(R4)
	MOVAB	PDT$L_PQ_PGQFL(R4),-
		PDT$L_PQ_PGQBL(R4)

	CLRL	PDT$L_PQ_POWNER(R4)	; Initialize to NO owner.
	MOVAB	PDT$L_PQ_ALGNPG(R4),R1	; R1 => Aligned Page.
	BSBW	VIRT_TO_PHYAD		; Convert R1 to physical address and
					;  leave result on top of stack.
	POPL	PDT$L_PQ_PGPHAD(R4)	; Save Aligned Page physical address.

; Since the INIT logic only allocates a system virtual page for the class
; driver, we must allocate a page for the boot driver in its initialization
; routine.  We initialize the PDT fields associated with the System Virtual Page
; that we use to map the user's non-word aligned buffer so that we can copy
; it to the Aligned Page.  The fields are PDT$L_PQ_UBFSVA that we initialize
; to be the System Virtual Address of this page; and PDT$L_PQ_SVPPTE that
; we set to be the virtual address of the PTE that describes this page.

	MOVZBL	#1,R1			; Request one SVPN.
	JSB	G^IOC$ALLOSPT		; Allocate the system virtual page.
	BLBS	R0,30$			; Br if successful allocation.
	RSB				; Return error to caller.
30$:	MOVL	@#MMG$GL_SPTBASE,R1	; Get address of SPT (PIC)
	MOVL	#<PTE$C_KW!PTE$M_VALID!PTE$M_PFN>,- ; Set SPTE to valid,
		(R1)[R2]		;  writable, and non-existant PFN.
	MOVL	R2,UCB$L_SVPN(R5)	; Get Virtual Page Number of page.
	ASHL	#9,R2,R1		; Multipy by 512 to get relative address
	BISL3	#1@31,R1,-		;  in system space.  Then set high
		PDT$L_PQ_UBFSVA(R4)	;  order bit to make system address.
	MOVL	G^MMG$GL_SPTBASE,R3	; R3 => system page table.
	MOVAL	(R3)[R2],-		; Calcualte address of PTE slot that
		PDT$L_PQ_SVPPTE(R4)	;  describes this page.
	MOVL	#SS$_NORMAL,R0		; Set return code.
	BRW	INIT_UDA_BUFS_RTN	; Branch around to common return.

INIT_BDA_BUFS:
	BUG_CHECK	UDAPORT,FATAL	; For now only a place holder.

INIT_UDA_BUFS_RTN:			; Common return label.

	RSB				; Return to caller
	.dsabl	lsb
	.PAGE
	.SBTTL	+	VIRT_TO_PHYAD

;+
; VIRT_TO_PHYAD - routine to convert a System Virtual Address into a physical
;	address.
;
; Inputs:
;	R1 = System Virtual Address to convert
;
; Outputs:
;	Physical Address left on top of stack.
;	All registers preserved.
;

VIRT_TO_PHYAD:

	PUSHL	(SP)			; Create slot at top of stack for return
					;  value.
	PUSHR	#^M<R0,R1,R2,R3>	; Save registers.
	BICL3	#-512,R1,R0		; R0 = Boff of address.
	EXTZV	#VA$V_VPN,-		; Extract VPN
		#VA$S_VPN,R1,R2		;  and put it in R2.
	MOVL	G^MMG$GL_SPTBASE,R3	; R3 => system page table.
	MOVL	(R3)[R2],R3		; R3 => PTE.

	EXTZV	#PTE$V_PFN,-		; Get page frame number of buffer
		#PTE$S_PFN,R3,R3	;  page into R3.
	ASHL	#VA$V_VPN,R3,R3		; Shift into place for physical address.
	BISL3	R0,R3,20(SP)		; Put result into stack slot.
	POPR	#^M<R0,R1,R2,R3>	; Restore registers.
	RSB				; Return to caller.
	.PAGE
	.SBTTL	+	INIT_INIT_STEPS

;+
; INIT_INIT_STEPS - initialize the host responses for UDA hardware
;			initialization.
;
; Inputs:
;	R5				-Addr of UCB
;
; Outputs:
;	UCB$W_HOSTSTEPx fields all initialized
;
;	Registers R0-R2 destroyed
;-

	.enabl	lsb

INIT_INIT_STEPS:

; First calculate the vector for this UDA.  This is done by scanning the
;	UNIBUS adapter interrupt vector looking for a slot that points
;	into this CRB$L_INTD.

	MOVL	UCB$L_CRB(R5),R0		; R0 => CRB.
	PUSHAL	CRB$L_INTD(R0)			; Save interrupt dispatcher
						;  address on stack.
	MOVL	CRB$L_INTD+VEC$L_IDB(R0),R0	; R0 => IDB.
	MOVL	IDB$L_ADP(R0),R0		; R0 => ADP.
	MOVL	ADP$L_VECTOR(R0),R0		; R0 => UBA interrupt vectors.

	CLRL	R1			; Initialize counter.
10$:
	MOVL	(R0)+,R2		; R2 = contents of a vector.
	BICL	#3,R2			; Clear low order 2 bits to remove
					;  processor (780 vs 750) differences.
	CMPL	R2,(SP)			; Is this our vector?
	BEQL	20$			; EQL means yes.
	AOBLSS	#NUMUBAVEC,R1,10$	; Else loop back to try again.
	TSTL	(SP)+			; It had better be there
	CLRL	R0			;  or else we return with an error
	RSB				;  indication.
20$:
	TSTL	(SP)+			; Remove unneeded stack value.

	BISW3	R1,-				; Or in vector address/4
		#HS1_M_IE!-			;   (i.e. vector #) with
		<UDA$K_RINGEXP@HS1_V_RRNGLEN>!-	;  Interrupt Enable bit, and
		<UDA$K_RINGEXP@HS1_V_CRNGLEN>!-	;  the response and command ring
		 HS1_M_BIT15,-			;  lengths and the high bit on,
		UCB$W_HOSTSTEP1(R5)		;  and save it in the UCB.

; Here we calculate the UNIBUS virtual address of the ring base so as to be
;	able to communicate it to the controller.


	CPUDISP	<<780,RINGBASE_COM>,-
		 <750,RINGBASE_COM>,-
		 <730,RINGBASE_COM>,-
		 <790,RINGBASE_COM>,-
		 <UV1,RINGBASE_UV1>,-
		 <8SS,RINGBASE_8SS>,-
		>

RINGBASE_8SS:
	MOVL	PDT$L_ADP(R4),R0	; R0 => ADP.
	CMPW	#AT$_UBA,-		; See if on UNIBUS adapter.
		ADP$W_ADPTYPE(R0)
	BEQL	RINGBASE_COM		; EQL implies UNIBUS adapter.
	BUG_CHECK	UDAPORT,FATAL	; For now, if on BDA.

RINGBASE_COM:

	MOVZWL	UCB$W_PU_BOFF(R5),R0	; R0 contains byte offset of ringbase.
	MOVL	UCB$L_CRB(R5),R1	; R1 => CRB.

	INSV	CRB$L_INTD+VEC$W_MAPREG(R1),#9,#9,R0	; R0 contains the UBA
							;  virtual address of
							;  the communications
							;  area.
	ADDL	#PDT$L_RINGBASE-PDT$L_COMAREA,R0; Add in offset to ringbase.
	BRB	AFTER_RINGBASE			; Rejoin common code.

RINGBASE_UV1:

	MOVL	UCB$L_PDT(R5),R1	; Get the PDT address.
	ADDL	#PDT$L_RINGBASE,R1	; Point to the ring base.
	BSBW	VIRT_TO_PHYAD		; Convert VA to physical address.
	POPL	R0			; Get physical address of ring base.\

AFTER_RINGBASE:

	CPUDISP	<<780,PURGE_780>,-
		 <750,PURGE_750>,-
		 <730,PURGE_730>,-
		 <790,PURGE_790>,-
		 <UV1,PURGE_UV1>,-
		 <8SS,PURGE_8SS>,-
		>

PURGE_780:
PURGE_790:				; 11/790 acts same as 11/780.
	BISW	#HS2_M_PI,R0		; Ask for purge interrupts when
					;  running on a VAX-11/780.
PURGE_750:
PURGE_730:
PURGE_UV1:
PURGE_8SS:

	MOVW	R0,UCB$W_HOSTSTEP2(R5)	; Save communication area address and
					;  purge interrupt request bit in UCB.

	ASSUME	UCB$W_HOSTSTEP3	EQ	UCB$W_PORTSTEP3+2
	MOVL	R0,UCB$W_PORTSTEP3(R5)	; Trash UCB$W_PORTSTEP3 as we store the
					;  high word of R0 in UCB$W_HOSTSTEP3.

; Here we pickup the SYSGEN parameter UDABURSTRATE.

	MOVZBL	G^SCS$GB_UDABURST,R0	; R0 contains the burst rate setting.
	ASHL	#HS4_V_BURST,R0,R0	; Shift burst rate into position.
	BISW3	#HS4_M_GO!-		; Set GO bit and last fail packet bits,
		 HS4_M_LF,-		;  or in burst rate,
		R0,-			;  and save as HOST response to STEP 4.
		UCB$W_HOSTSTEP4(R5)

	MOVL	S^#SS$_NORMAL,R0	; Indicate success and
	RSB				;  return to caller.
	.dsabl	lsb
	.PAGE
	.SBTTL	+	Hardware Initialization

;+
; HARDWARE_INIT - internal subroutine
;
; Inputs:
;	R5				-Addr of UCB
;
; Outputs:
;
;-

CNTRLTYP_ARRAY:
	.WORD	UDA50_CNTRLTYP
	.WORD	LESI_CNTRLTYP
	.WORD	TU81_CNTRLTYP
	.WORD	UDA50A_CNTRLTYP
	.WORD	RDRX_CNTRLTYP
	.WORD	MAYA_CNTRLTYP
	.WORD	QDA50_CNTRLTYP
	.WORD	-1				; End of array fence.
	.WORD	-1,-1,-1,-1,-1			; Space for expansion.
DEVTYPE_ARRAY:
	.BYTE	DT$_UDA50
	.BYTE	DT$_LESI
	.BYTE	DT$_TU81P
	.BYTE	DT$_UDA50A
	.BYTE	DT$_RDRX
	.BYTE	DT$_TK50P
	.BYTE	DT$_QDA50
	.BYTE	0,0,0,0,0,0			; Space for expansion.
SERVERS_ARRAY:
	.BYTE	<1@DISK_CONID>!<1@DUP_CONID>	; UDA supports disks and DUP.
	.BYTE	<1@DISK_CONID>!<1@DUP_CONID>	; Aztec supports disks and DUP.
	.BYTE	<1@TAPE_CONID>!<1@DUP_CONID>	; TU81 supports tapes and DUP.
	.BYTE	<1@DISK_CONID>!<1@DUP_CONID>	; UDA50A supports disks and DUP.
	.BYTE	<1@DISK_CONID>!<1@DUP_CONID>	; RD/RX supports disks and DUP.
	.BYTE	<1@TAPE_CONID>!<1@DUP_CONID>	; MAYA supports tapes and DUP.
	.BYTE	<1@DISK_CONID>!<1@DUP_CONID>	; QDA50 supports disks and DUP.
	.BYTE	0,0,0,0,0,0			; Space for expansion.
UCODE_VER_ARRAY:				; Minimum ucode version levels
	.BYTE	0				; UDA50A (0 since special purpose
						;  code already checks).
	.BYTE	0				; RC25 (0 for now)
	.BYTE	0				; TU81 (0 for now)
	.BYTE	0				; UDA50A (0 since special purpose
						;  code already checks).
	.BYTE	9				; RDRX.
	.BYTE	0				; MAYA.
	.BYTE	0				; QDA.
	.BYTE	0,0,0,0,0,0			; Space for expansion.
OPC_MSG_ARRAY:
	.BYTE	MSG$_UDA50MVER			; UDA50 Opcom message number
	.BYTE	MSG$_RC25MVER			; RC25 Opcom message number
	.BYTE	MSG$_TU81MVER			; TU81 Opcom message number
	.BYTE	MSG$_UDA50MVER			; UDA50A Opcom message number
	.BYTE	MSG$_RDRXMVER			; RDRX Opcom message number
	.BYTE	MSG$_TU81MVER			; Use TU81 Opcom message number
						;  for MAYA for now.
	.BYTE	MSG$_UDA50MVER			; Use UDA50 Opcom message number
						;  for QDA for now.
	.BYTE	0,0,0,0,0,0			; Space for expansion.
	.enabl	lsb
HARDWARE_INIT:

	POPL	UCB$L_DPC(R5)		; Remember return
	DECB	UCB$B_INITCNT(R5)	; Count # of consecutive times thru here.
	BNEQ	8$			; NEQ means that we have not exhausted
					;  consecutive retries.
	MOVL	UCB$L_CRB(R5),R3	; R3 => CRB.
	MOVAB	B^4$,CRB$L_TOUTROUT(R3)	; Establish wakeup routine.
	ADDL3	#INIT_DELTA,-		; Establish a small delay.
		G^EXE$GL_ABSTIM,-
		CRB$L_DUETIME(R3)
	RSB				; Evaporate for awhile.
4$:
	SETIPL	#IPL$_SCS		; Lower IPL after wakeup.
	MOVL	CRB$L_AUXSTRUC(R3),R4	; R4 => PDT.
	MOVL	PDT$L_UCB0(R4),R5	; R5 => UCB.
	MOVAB	NULL_ROUTINE,-		; Restablish null wakeup routine.
		CRB$L_TOUTROUT(R3)
	MOVB	#NO_CONSEC_INITS,-	; Reinit count that went to zero.
		UCB$B_INITCNT(R5)
8$:
	BISW	#UCB$M_PU_HRDINI,-	; Set bit signalling
		UCB$W_DEVSTS(R5)	;  that we initing the port.
	MOVL	UCB$L_PDT(R5),R4	; R4 => PDT.
	MOVL	PDT$L_PU_CSR(R4),R3	; R3 => UDA CSR.
	CLRB	PDT$B_PURGEDP(R4)	; Prevent spurious purges.
10$:

	CLRW	UDAIP(R3)		; Start hard init.

; At least 100 micro seconds must pass between here

	ASSUME	UCB$W_BOFF	EQ	UCB$L_SVAPTE+4
	ASSUME	UCB$W_BCNT	EQ	UCB$W_BOFF+2
	ASSUME	UCB$W_PU_BOFF	EQ	UCB$L_PU_SVAPTE+4
	ASSUME	UCB$W_PU_BCNT	EQ	UCB$W_PU_BOFF+2


	CPUDISP	<<780,LOADUBA_COMMON>,-
		 <750,LOADUBA_COMMON>,-
		 <730,LOADUBA_COMMON>,-
		 <790,LOADUBA_COMMON>,-
		 <UV1,NOLOADUBA_UV1>,-
		 <8SS,LOADUBA_8SS>,-
		>

LOADUBA_8SS:
	MOVL	PDT$L_ADP(R4),R0	; R0 => ADP.
	CMPW	#AT$_UBA,-		; See if on UNIBUS adapter.
		ADP$W_ADPTYPE(R0)
	BEQL	LOADUBA_COMMON		; EQL implies UNIBUS adapter.
	BUG_CHECK	UDAPORT,FATAL	; For now, if on BDA.

LOADUBA_COMMON:

	MOVQ	UCB$L_PU_SVAPTE(R5),-	; Copy parameters that allow mapping
		UCB$L_SVAPTE(R5)	;  of communication area and buffers.
	LOADUBA				; Load UNIBUS map registers with values
					;  that map communication area and buffers.
NOLOADUBA_UV1:

	DSBINT
	WFIKPCH	15$,#2			; Cause timeout to waste time.
15$:
	SETIPL	UCB$B_FIPL(R5)		; Lower IPL after timeout.
	BSBW	INIT_PU_PDT		; Initialize variable PDT data.
	CLRW	UCB$W_PORTSTEP1(R5)	; Clear port responses so that
	CLRW	UCB$W_PORTSTEP2(R5)	;  the error log record we create
	CLRW	UCB$W_PORTSTEP3(R5)	;  will contain only the responses
	CLRW	UCB$W_PORTSTEP4(R5)	;  received in this INIT attempt.
	INCW	UCB$W_NUMBINITS(R5)	; Increment # of times we have attempted
					;  to init port.
; and here

	MOVW	UDASA(R3),-		; Read SA register.
		UCB$W_PORTSTEP1(R5)
	BBC	#PS1_V_ER,-		; Test for error condition
		UCB$W_PORTSTEP1(R5),30$	;  and branch around if clear.
20$:
	BRW	HARD_RETRY		; For now only.
30$:
	BBC	#PS1_V_S1,-		; Make sure we are in STEP1
		UCB$W_PORTSTEP1(R5),20$	;  or else go back.

; In Step 1.

	DSBINT				; Prepare to respond to STEP1.
	BBCC	#UCB$V_POWER,-		; Power failure negates what we have
		UCB$W_STS(R5),35$	;  done until now.
	BRW	HARDPOWER		; If power failure branch around.
35$:
	MOVW	UCB$W_HOSTSTEP1(R5),-	; Else move value to SA register.
		UDASA(R3)
	WFIKPCH	STEP1_TIMEOUT,#STEP1_LIMIT	; Wait for interrupt.

	IOFORK				; Lower IPL and continue.
	BSBW	WAIT100US		; Call to wait for at least 100 uSecs.
	MOVW	UDASA(R3),-		; For slow TU81, copy UDASA after fork-
		UCB$W_UDASA(R5)		;  ing so as to give it enough time.
	MOVW	UCB$W_UDASA(R5),-		; Save Port STEP2 start value
		UCB$W_PORTSTEP2(R5)

; In Step 2.

	BBS	#PS2_V_ER,UCB$W_PORTSTEP2(R5),37$	; For now!!!!

	BBS	#PS2_V_S2,-		; Make sure we are in STEP2.
		UCB$W_PORTSTEP2(R5),40$
37$:
	BRW	HARD_RETRY		; Else branch to retry.
40$:
	CMPB	UCB$W_PORTSTEP2(R5),-	; Test whether controller echoed
		UCB$W_HOSTSTEP1+1(R5)	;  fields correctly.
	BEQL	50$			; EQL implies yes.
	BRW	HARD_RETRY		; Else branch to retry.
50$:
	DSBINT				; Prepare to respond to STEP2.
	BBCC	#UCB$V_POWER,-		; Power failure negates what we have
		UCB$W_STS(R5),55$	;  done until now.
	BRW	HARDPOWER		; If power failure branch around.
55$:
	MOVW	UCB$W_HOSTSTEP2(R5),-	; Else move value to SA register.
		UDASA(R3)
	WFIKPCH	STEP2_TIMEOUT,#STEP2_LIMIT	; Wait for interrupt.

	IOFORK				; Lower IPL and continue.
	BSBW	WAIT100US		; Call to wait for at least 100 uSecs.
	MOVW	UDASA(R3),-		; For slow TU81, copy UDASA after fork-
		UCB$W_UDASA(R5)		;  ing so as to give it enough time.
	MOVW	UCB$W_UDASA(R5),-		; Save Port STEP3 start value
		UCB$W_PORTSTEP3(R5)

; In Step 3.

	BBS	#PS3_V_ER,UCB$W_PORTSTEP3(R5),57$	; For now!!!!

	BBS	#PS3_V_S3,-		; Make sure we are in STEP3.
		UCB$W_PORTSTEP3(R5),60$
57$:
	BRW	HARD_RETRY		; Else branch to retry.
60$:
	CMPB	UCB$W_PORTSTEP3(R5),-	; Test whether controller echoed
		UCB$W_HOSTSTEP1(R5)	;  fields correctly.
	BEQL	70$			; EQL implies yes.
	BRW	HARD_RETRY		; Else branch to retry.
70$:
	DSBINT				; Prepare to respond to STEP3.
	BBCC	#UCB$V_POWER,-		; Power failure negates what we have
		UCB$W_STS(R5),72$	;  done until now. No failure, continue.
	BRW	HARDPOWER		; So branch to HARDPOWER if failure.
72$:
	MOVW	UCB$W_HOSTSTEP3(R5),-	; Else move value to SA register.
		UDASA(R3)
	WFIKPCH	STEP3_TIMEOUT,#STEP3_LIMIT	; Wait for interrupt.

	IOFORK				; Lower IPL and continue.
	BSBW	WAIT100US		; Call to wait for at least 100 uSecs.
	MOVW	UDASA(R3),-		; For slow TU81, copy UDASA after fork-
		UCB$W_UDASA(R5)		;  ing so as to give it enough time.
	MOVW	UCB$W_UDASA(R5),-		; Save Port STEP4 start value
		UCB$W_PORTSTEP4(R5)

; In Step 4.

	BBS	#PS4_V_ER,UCB$W_PORTSTEP4(R5),77$	; For now!!!!

	BBS	#PS4_V_S4,-		; Make sure we are in STEP4.
		UCB$W_PORTSTEP4(R5),80$
77$:
	BRW	HARD_RETRY		; Else branch around to retry.
80$:
	CMPZV	#PS4_V_CNTRLTYP,-	; Here we assure that the controller
		#PS4_S_CNTRLTYP,-	;  microcode is upto rev level. First
		UCB$W_PORTSTEP4(R5),-	;  see if we have a UDA50.
		#UDA50_CNTRLTYP
	BNEQ	90$			; If NOT, branch around.
	MOVB	#DT$_UDA50,-		; Fill in UCB devtype field with value
		UCB$B_DEVTYPE(R5)	;  for UDA50.
	CMPZV	#PS4_V_UCODEVER,-	; If a UDA50, see if microcode
		#PS4_S_UCODEVER,-	;  upto rev by comparing against out of
		UCB$W_PORTSTEP4(R5),-	;  date microcode version #.
		#1			; Out of date version number.
	BNEQ	90$			; NEQ implies Ucode is OK.
	BRW	UDA_OUTOFREV		; EQL implies inoperative Ucode.

GOTO_HARDP:
	BRW	HARDPOWER		; Branch to faraway label.
90$:
	BSBW	STOCK_RSPRING		; Stock response ring after controller
					;  clears it.

	DSBINT				; Prepare to respond to STEP4.
	BBSC	#UCB$V_POWER,-		; Power failure negates what we have
		UCB$W_STS(R5),GOTO_HARDP;  done until now.
	MOVW	UCB$W_HOSTSTEP4(R5),-	; Else move value to SA register.
		UDASA(R3)
	ENBINT				; Lower IPL and
	BICW	#UCB$M_PU_HRDINI,-	; Reset bit signalling
		UCB$W_DEVSTS(R5)	;  that we initing the port.
	MOVW	#INIT_ATTNCODE,-	; Indicate what kind of error log record
		UCB$W_ATTNCODE(R5)	;  we are about to create.
	JSB	G^ERL$DEVICEATTN	; Call to create error log record of INIT.

; Here we have initialized the port.  If it is a UDA, permanently allocate
; a Buffered Datapath and bias the useage count so that it is never released.
; This is done only on the first time thru here.

	BBCS	#UCB$V_PU_BDPATH,-	; Make sure first time thru.
		UCB$W_DEVSTS(R5),140$
	BRW	190$			; If NOT first time, branch around.
140$:
	EXTZV	#PS4_V_CNTRLTYP,-	; Extract controller type and
		#PS4_S_CNTRLTYP,-	;  put it in on top of stack.
		UCB$W_PORTSTEP4(R5),-(SP)
	CLRL	R0			; Clear loop counter.
150$:
	CMPW	(SP),CNTRLTYP_ARRAY[R0]	; Look for UQPORT type.
	BEQL	160$			; EQL implies found.
	TSTW	CNTRLTYP_ARRAY[R0]	; See if at end of array.
	BLSS	170$			; LSS implies NOT found.
	INCL	R0			; Increment loop counter.
	BRB	150$			; And loop back.
160$:
	MOVB	DEVTYPE_ARRAY[R0],-	; Copy appropriate UQPORT type to
		UCB$B_DEVTYPE(R5)	;  UCB.
	MOVL	UCB$L_PDT(R5),R4	; R4 => PDT.
	MOVB	SERVERS_ARRAY[R0],-	; Copy list of servers supported
		PDT$B_SERVERS(R4)	;  to PDT field.
	MOVZBL	UCODE_VER_ARRAY[R0],R1	; Minimum acceptable ucode version
	CMPZV	#PS4_V_UCODEVER,-	; Compare our ucode version to
		#PS4_S_UCODEVER,-	;  minimum acceptable level.
		UCB$W_PORTSTEP4(R5),R1
	BGEQ	170$			; GEQ implies it IS acceptable.
	MOVZBL	OPC_MSG_ARRAY[R0],R1	; Opcom message number to R1.
	BSBW	SEND_OPC_MSG		; Subroutine to send message.
170$:
	POPL	R0			; Controller type to R0.

	CMPL	R0,#UDA50_CNTRLTYP	; Is it UDA50?
	BEQL	180$			; If YES, then go allocate.
	CMPL	R0,#UDA50A_CNTRLTYP	; Is it UDA50A?
	BNEQ	190$			; If neither of above, no allocate.

180$:

; Older UDA's on VAX-11/780 and VAX-11/790 systems have a purge problem
;  that corrupts data.

	CPUDISP	<<780,TESTUDA_780>,-
		 <750,UDA750>,-
		 <730,UDA730>,-
		 <790,TESTUDA_790>,-
		 <UV1,UDAUV1>,-
		 <8SS,UDA8SS>,-
		>
TESTUDA_780:
TESTUDA_790:
	CMPZV	#PS4_V_UCODEVER,-	; If UDA on 780, see if microcode
		#PS4_S_UCODEVER,-	;  upto rev by comparing against out of
		UCB$W_PORTSTEP4(R5),-	;  date microcode version #.
		#2			; Out of date version number.
	BLEQ	UDA_OUTOFREV		; LEQ implies inoperative Ucode.
	BRB	190$			; Branch around allocation of perm. BDP.
UDA750:
UDA8SS:
	JSB	G^IOC$REQDATAP		; Permanently allocate a datapath.
	MOVL	UCB$L_CRB(R5),R0	; R0 => CRB.
	MOVL	CRB$L_AUXSTRUC(R0),R4	; R4 => PDT.

	MOVB	CRB$L_INTD+VEC$B_DATAPATH(R0),-	; Remember datapath permanently
		PDT$B_DATAPATH(R4)		;  allocated in PDT.
	CLRB	CRB$L_INTD+VEC$B_DATAPATH(R0)	; Clear CRB field.

	INCB	PDT$B_BDPUSECNT(R4)	; Bias useage count to prevent dealloc.
UDA730:
UDAUV1:
190$:

; Here we setup the CRB wakeup mechanism to periodically poll the SA register
; to determine if the U/QPORT has had an uncorrectable error.

	MOVL	UCB$L_CRB(R5),R0	; R0 => CRB.
	ADDL3	#SA_POLL_INTVAL,-	; Establish SA polling interval.
		G^EXE$GL_ABSTIM,-
		CRB$L_DUETIME(R0)
	MOVAB	W^PU$SA_POLL,-		; Establish wakeup routine.
		CRB$L_TOUTROUT(R0)

	MOVL	S^#SS$_NORMAL,R0	; Return normal status.
200$:
	BICW	#UCB$M_PU_INILOG,-	; Indicate Init Error Log no longer
		UCB$W_DEVSTS(R5)	;  in progress (if it was).
	JMP	@UCB$L_DPC(R5)		;  return to caller.

HARDPOWER:				; We got a powerfailure while initing
					;  the UDA.  Simply start hardware init
					;  over.
	ENBINT				; Undo DSBINT.
HARD_RETRY:
	MOVL	UCB$L_PDT(R5),R4	; R4 => PDT.
	MOVL	PDT$L_PU_CSR(R4),R0	; R0 => UDA CSR.
	MOVW	UDASA(R0),UCB$W_UDASA(R5); Save error status in UCB for logging.
	MOVW	#FAIL_ATTNCODE,-	; Indicate what kind of error log record
		UCB$W_ATTNCODE(R5)	;  we are about to create.
	BBSS	#UCB$V_PU_INILOG,-	; Indicate Init Error Log in progress,
		UCB$W_DEVSTS(R5),210$	;  and if in progress already, branch.
	JSB	G^ERL$DEVICEATTN	; Call to create error log record of INIT.
210$:
	PUSHL	UCB$L_DPC(R5)		; Restore caller's return to stack.
	BRW	HARDWARE_INIT		; And branch back to restart hardware
					;  init of UDA.

STEP1_TIMEOUT:
STEP2_TIMEOUT:
STEP3_TIMEOUT:
	SETIPL	UCB$B_FIPL(R5)		; Lower IPL after timeout.
	BRB	HARD_RETRY		; Go to try again.

UDA_OUTOFREV:
	.IF	DF	UDA50_BYPASS
	BRB	90$			; Bypass rejection.
	.ENDC

	MOVW	#UCODE_ATTNCODE,-	; Indicate what kind of error log record
		UCB$W_ATTNCODE(R5)	;  we are about to create.
	JSB	G^ERL$DEVICEATTN	; Call to create error log record of INIT.

	MOVZBL	#MSG$_UDA50MVER,R1	; Message number to R1 for subroutine.
	BSBB	SEND_OPC_MSG		; Send message to OPCOM.

	CLRL	R0			; Indicate unable to init hardware.
	BRB	200$			; Branch back to return.

	.dsabl	lsb

WAIT100US:
	TIMEDWAIT	TIME=#15	; Wait for 150 uSecs.
	RSB

; R1 = MSG$_ message code.

SEND_OPC_MSG:

	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	; Save registers.
	MOVL	R1,R4			; Message number to R4.
	MOVAB	G^SYS$GL_OPRMBX,R3	; R3 => operator's mailbox.
	JSB	G^EXE$SNDEVMSG		; Call to send operator message.
	POPR	#^M<R0,R1,R2,R3,R4,R5>	; Restore registers.
	RSB				; Return to caller.
	.PAGE
	.SBTTL	+	INIT_PU_PDT	Fill in variable
	.SBTTL	+			PDT data

;+
; INIT_PU_PDT - internal subroutine to initialize (or re-initialize)
; variable PDT data.  This routine assumes that BUILD_PDT has been called
; prior to the activation of this routine.
;
; INIT_PU_PDT is called from HARDWARE_INIT, and initializes the Q headers
; in the PDT and also initializes the Ring structures by filling the response
; ring with available buffers and then placing all the rest of the buffers on
; the free Q.
;
; Inputs:
;
;	R4			-Addr of PDT
;
; Outputs:
;
;	R0-R2			-Destroyed
;	Other registers		-Preserved
;
;	Response ring filled
;	Free Q filled
;	PDT$L_PU_SNDQFL initialized
;	PDT$L_PU_BUFQFL initialized
;-

INIT_PU_PDT:

	ASSUME	PDT$W_CMDINT	EQ	PDT$L_COMAREA+4
	ASSUME	PDT$W_RSPINT	EQ	PDT$W_CMDINT+2
	CLRQ	PDT$L_COMAREA(R4)

	ASSUME	PDT$B_CPOLLINX	EQ	PDT$B_CRINGINX+1
	ASSUME	PDT$B_CRINGCNT	EQ	PDT$B_CPOLLINX+1
	ASSUME	PDT$B_RRINGINX	EQ	PDT$B_CRINGCNT+1
	ASSUME	PDT$B_RPOLLINX	EQ	PDT$B_RRINGINX+1
	ASSUME	PDT$B_RRINGCNT	EQ	PDT$B_RPOLLINX+1
	ASSUME	PDT$B_NOCURCON	EQ	PDT$B_RRINGCNT+1
	ASSUME	PDT$B_CONBITMAP	EQ	PDT$B_NOCURCON+1
	CLRQ	PDT$B_CRINGINX(R4)

	MOVL	#UDAB$T_TEXT,-		; Save UDA port SCS datagram header
		PDT$L_DGOVRHD(R4)	;  size in PDT.
	MOVL	#UDAB$T_TEXT,-		; Save UDA port SCS message header
		PDT$L_MSGHDRSZ(R4)	;  size in PDT.

; Initialize PDT Q headers.

	MOVAB	PDT$L_WAITQFL(R4),-	; Empty wait queue header
		PDT$L_WAITQFL(R4)	;
	MOVAB	PDT$L_WAITQFL(R4),-	; Empty wait queue header
		PDT$L_WAITQBL(R4)	;

	MOVAB	PDT$L_PU_FQFL(R4),-	; Free Q header.
		PDT$L_PU_FQFL(R4)
	MOVAB	PDT$L_PU_FQFL(R4),-	; Free Q header.
		PDT$L_PU_FQBL(R4)
	MOVAB	PDT$L_PU_FQFL(R4),-	; Point Free Q pointer to Free Q. This
		PDT$L_PU_FQPTR(R4)	;  pointer is used to test for
					;  emptiness of Free Q.

	MOVAB	PDT$L_PU_SNDQFL(R4),-	; Send Q header.
		PDT$L_PU_SNDQFL(R4)
	MOVAB	PDT$L_PU_SNDQFL(R4),-	; Send Q header.
		PDT$L_PU_SNDQBL(R4)

	MOVAB	PDT$L_PU_BUFQFL(R4),-	; Buffer wait Q header.
		PDT$L_PU_BUFQFL(R4)
	MOVAB	PDT$L_PU_BUFQFL(R4),-	; Buffer wait Q header.
		PDT$L_PU_BUFQBL(R4)

; Initialize initial credits for all possible connections.

	MOVW	#1,PDT$W_PU_CRED0(R4)	; Initial credit of 1.
	MOVW	#1,PDT$W_PU_CRED1(R4)	; Initial credit of 1.
	MOVW	#1,PDT$W_PU_CRED2(R4)	; Initial credit of 1.
	MOVW	#1,PDT$W_PU_CRD255(R4)	; Initial credit of 1.

; Following loop is for arrays that are RINGSIZE long.

	MOVL	#UDA$K_RINGSIZE-1,R0	; Initialize loop counter.
10$:
	MNEGB	#1,PDT$B_CRCONTENT(R4)[R0]	; Nothing in command slot.
	MNEGB	#1,PDT$B_RRCONTENT(R4)[R0]	; Nothing in response slot.
	CLRL	PDT$L_CMDRING(R4)[R0]		; Clear command ring slot.
	CLRL	PDT$L_RSPRING(R4)[R0]		; Clear response ring slot.
	SOBGEQ	R0,10$				; Loop thru all array elements.
	RSB				; Return to caller. Rest of PDT init
					;  called explicitly at label below.

STOCK_RSPRING:

; Loop thru all buffers (there are 2*RINGSIZE of them) and put them on the
;	response ring or the free Q.

	CLRL	R0			; Initialize loop variable.
10$:
	MOVL	PDT$L_BDTABLE(R4)[R0],R2; R2 => buffer[R0]
	PUSHL	R0			; Remember loop variable before call.
	BSBW	Q_DEALLOC_BUF		; Put buffer on response ring or free
					;  Q, whichever is appropriate.
	POPL	R0			; Restore loop variable.
	AOBLSS	#2*UDA$K_RINGSIZE,R0,10$; Loop thru all buffers.

	RSB				; And return to caller.
	.PAGE
	.SBTTL	+	BUILD_PB_SB Build System Block and Path Block

;+
; BUILD_PB_SB - Build and fill in the System Block and the Path Block.
;
; This portion of the UDA port driver is responsible for adding
; the UDA to the system-wide configuration database.  It is invoked
; as a one time initialization routine.
;
; The system wide configuration database consists of:
;
;
;	SCS$GQ_CONFIG
;	     |
;	     v
;	System Block ----> Path Block ----> Path Block ---->...
;	     |
;	     v
;	System Block ----> Path Block ---->...
;	     |
;	     v
;	    ...
;
; Only systems and paths with open port-port VC's are kept on the
; above list.
;
; For each UDA (AZTEC or TU81) we build a Path Block and a System Block,
; initialize them and link them into the systemwide configuration database.
;
; Inputs:
;
;	R4				-Addr of PDT
;	R5 				-Addr of UCB
;
;-

BUILD_PB_SB:

	MOVL	#PB$K_LENGTH,R1			; Get size of a pathblock
	BSBW	ALLOC_POOL			; Allocate one from pool
	BLBS	R0,10$				; Branch around if success.
	BRW	PB_ALLOC_FAIL			; Branch if no pool
10$:
	MOVL	R2,R3				; Set PB addr in stable register
	MOVL	R2,PB$L_FLINK(R2)		; This will be the only Path
						;  Block on this list.
	MOVL	R2,PB$L_BLINK(R2)		; FLINK and BLINK point here.

	MOVW	R1,PB$W_SIZE(R2)		; Set structure size

	ASSUME	PB$B_SUBTYP	EQ	PB$B_TYPE+1
	MOVW	#DYN$C_SCS+<DYN$C_SCS_PB@8>,-
		PB$B_TYPE(R2)	  		; Set struct type, subtype

	MOVW	#PB$C_OPEN,PB$W_STATE(R2)	; Always in OPEN state.

	MOVL	UCB$L_DDB(R5),R1		; R1 => DDB for port device.
	MOVL	DDB$T_NAME+1(R1),-		; Copy port name to port block.
		PB$T_LPORT_NAME(R2)
	MOVB	#^A/0/,PB$T_LPORT_NAME+3(R2)	; Unit is always 0.

	MOVL	R4,PB$L_PDT(R2)			; Save PDT pointer in Path Block.

	MOVAB	PB$L_WAITQFL(R2),-		; Initialize empty Q header.
		PB$L_WAITQFL(R2)
	MOVAB	PB$L_WAITQFL(R2),-
		PB$L_WAITQBL(R2)

; Now build System Block.

	MOVL	#SB$K_LENGTH,R1		; Get size of SB
	BSBW	ALLOC_POOL		; Allocate from nonpaged pool
	BLBC	R0,SB_ALLOC_FAIL	; Branch if no pool
	MOVL	R2,PB$L_SBLINK(R3)	; Save System Block address in PB.
	MOVL	R2,PDT$L_PU_SB(R4)	; Save System Block address in PDT.

	MOVW	R1,SB$W_SIZE(R2)	; Set struct size
	MOVW	#DYN$C_SCS+<DYN$C_SCS_SB@8>,-  ; Set structure type
		SB$B_TYPE(R2)		       ;  and subtype
	MOVAB	SB$L_PBFL(R2),SB$L_PBFL(R2)	; Establish Q head of path
	MOVAB	SB$L_PBFL(R2),SB$L_PBBL(R2)	;  blocks. And Q this path
	INSQUE	(R3),@SB$L_PBFL(R2)		;  block to head of that Q.
	MOVL	R3,SB$L_PBCONNX(R2)		; Let this path be Next path.

; Here we concoct the SYSTEMID of this controller.  It is made up of the
;	following pieces:
;
;	 4	       3 3
;	.7_____________2.1_____________________________0.
;	! !		!				!
;	!1!  TR number	!	UDA CSR address		!
;	!_!_____________!_______________________________!

	MOVL	UCB$L_CRB(R5),R0		; R0 => CRB.
	MOVL	CRB$L_INTD+VEC$L_IDB(R0),R0	; R0 => IDB.
	MOVL	IDB$L_CSR(R0),-			; Move CSR to low longword of
		SB$B_SYSTEMID(R2)		;  SYSTEMID.
	MOVL	IDB$L_ADP(R0),R0		; R0 => ADP.
	MOVW	ADP$W_TR(R0),-			; Move nexus number to high
		SB$B_SYSTEMID+4(R2)		;  word of SYSTEMID.
	BISB	#^X80,SB$B_SYSTEMID+5(R2)	; Set high bit on in SYSTEMID.

	MOVQ	G^EXE$GQ_SYSTIME,-	; Copy current time to boot time
		SB$Q_SWINCARN(R2)	;  of this port.
	CLRL	SB$L_CSB(R2)		; Clear link to newest CSB.

; Here link System Block onto system list.

	MOVAL	G^SCS$GQ_CONFIG,R0	; R0 => Systemwide list head of system
					;  blocks.
	INSQUE	(R2),@4(R0)		; Queue to tail of list.
	MOVL	S^#SS$_NORMAL,R0	; Indicate success and
	RSB				;  return to caller.

PB_ALLOC_FAIL:
SB_ALLOC_FAIL:
	CLRL	R0			; Indicate failure and
	RSB				;  return to caller.
	.PAGE
	.SBTTL	+		UPDATE_PB_SB

;+
; UPDATE_PB_SB - routine to update fields in the PB (and potentially the SB)
;	after the data has been obtained.
;
; Inputs:
;	R5 => UCB

UPDATE_PB_SB:

	MOVL	UCB$L_PDT(R5),R0	; R0 => PDT.
	MOVL	PDT$L_PU_SB(R0),R0	; R0 => SB.
	BEQL	10$			; EQL means we failed to alloc SB.
	MOVL	SB$L_PBCONNX(R0),R0	; R0 => PB.

	EXTZV	#PS2_V_PORTTYPE,-	; Extract Port Type returned by hardware
		#PS2_S_PORTTYPE,-	;  initialization of controller.
		UCB$W_PORTSTEP2(R5),-
		PB$L_RPORT_TYP(R0)

	EXTZV	#PS4_V_UCODEVER,-	; Extract ucode version returned by
		#PS4_S_UCODEVER+-	;  hardware init of controller.
		 PS4_S_CNTRLTYP,-
		UCB$W_PORTSTEP4(R5),-
		PB$L_RPORT_REV(R0)
10$:
	RSB				; Return to caller.
	.PAGE
	.SBTTL	+	ALLOC_POOL

;+
; This subroutine allocates and zeroes nonpaged pool.
;	It is assumed here that the call here is always made from a called
;	internal subroutine, implying that two return points must be popped
;	off the stack if the thread is suspended.
;
; Inputs:
;
;	R1			-# bytes of pool to allocate
;	R5			-Addr of UCB
;	
; Outputs:
;
;	R0			-0/1 for fail/success
;	R1			-# bytes actually allocated
;	R2			-Addr of buffer allocated
;-

ALLOC_POOL:				; Allocate and zero pool

	POPL	UCB$L_DPC(R5)		; Remember return
	PUSHL	R3			; Save R3.
	JSB	G^EXE$ALONONPAGED	; Allocate from nonpaged pool
	BLBC	R0,10$			; Skip clearing structure if failure
	PUSHR	#^M<R0,R1,R2,R4,R5>	; Save MOVC registers
	MOVC5	#0,(SP),#0,R1,(R2)	; Zero initialize structure
	POPR	#^M<R0,R1,R2,R4,R5>	; Restore MOVC registers
	POPL	R3			; Restore R3.
	JMP	@UCB$L_DPC(R5)		; Return to caller.
10$:					; Here we suffered an allocation failure.
					;  Prepare to wait awhile before trying
					;  again.
	MOVL	R1,UCB$L_PU_ALLOC(R5)	; Save size of block to allocate.
	POPL	UCB$L_FR3(R5)		; Pop given R3 into save area.
	MOVL	R4,UCB$L_FR4(R5)	; Save R4.
	POPL	UCB$L_FPC(R5)		; Save caller's caller's return.

	MOVL	UCB$L_CRB(R5),R3	; R3 => CRB.
	MOVAB	B^20$,CRB$L_TOUTROUT(R3); Establish wakeup routine.
	ADDL3	#ALLOC_DELTA,-		; Establish a small delay.
		G^EXE$GL_ABSTIM,-
		CRB$L_DUETIME(R3)
	RSB				; Evaporate for awhile.
20$:
	SETIPL	#IPL$_SCS		; Lower IPL after wakeup.
	MOVL	CRB$L_AUXSTRUC(R3),R5	; R5 => UCB or PDT.
	CMPB	#DYN$C_UCB,-		; Determine which, UCB or PDT.
		UCB$B_TYPE(R5)
	BEQL	30$			; EQL implies UCB.
	MOVL	PDT$L_UCB0(R5),R5	; If PDT, go one level deeper so that
30$:					;  here R5 => UCB.
	MOVAB	NULL_ROUTINE,-		; Restablish null wakeup routine.
		CRB$L_TOUTROUT(R3)
	MOVL	UCB$L_PU_ALLOC(R5),R1	; Restore R1 = size of block to alloc.
	MOVQ	UCB$L_FR3(R5),R3	; Restore R3 and R4.
	PUSHL	UCB$L_FPC(R5)		; Re-establish caller's caller's return point.
	PUSHL	UCB$L_DPC(R5)		; Re-establish caller's return point.
	BRB	ALLOC_POOL		; Go try again.

	.SBTTL	UNIMPLEMENTED FORK PROCESS CALLS
FPC$ACCEPT::
FPC$ALLOCDG::
FPC$DEALLOCDG::
FPC$MAP::
FPC$MAPBYPASS::
FPC$MAPIRPBYP::
FPC$QUEUEMDGS::
FPC$REJECT::
FPC$REQDATA::
FPC$SENDDATA::
FPC$SENDDG::
FPC$SENDMSG::

FPC$READCOUNT::
FPC$RLSCOUNT::
FPC$MAINTFCN::
FPC$SENDRGDG::
FPC$STOP_VCS::
	BUG_CHECK	UDAPORT,FATAL

	.SBTTL	MRESET and MSTART

;+
; FPC$MRESET - causes connection ERROR ROUTINE to be called for all open
;	connections and then does a HARDWARE INIT of the port.
; FPC$MSTART is a NOP.
;
; Inputs:
;	R4 => PDT
;
; Outputs:
;	All registers preserved, however caller is returned to before the
;		thread started by FPC$MRESET finishes.
;-

FPC$MRESET::

	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	; Save caller's registers.
	MOVL	PDT$L_UCB0(R4),R5	; R5 => UCB for port.
	BSBW	POST_POWER_FORK		; Start thread to call error routines
					;  and to do hardware init.
	POPR	#^M<R0,R1,R2,R3,R4,R5>	; Restore caller's registers.
FPC$MSTART::
	RSB				; Return to caller.
	.PAGE
	.SBTTL	CONNECTION MANAGEMENT CALLS
	.SBTTL	+	FPC$CONNECT,	COMPLETE PROCESSING A CONNECT

;+
; This routine is JMP'ed to from SCS$CONNECT with a CDT allocated
; (and in the closed state) and initialized with the SYSAP's
; connect parameters or 0's for fields not yet used.  FPC$CONNECT
; does port-specific processing.
;
; The UDA port driver only supports one connection at a time.  The first
; thing that FPC$CONNECT checks for is that there are no current connections
; on this port. Then if there are none we check that the target of the
; connection is one of the ones supported.  If so, then the initial credits
; allotted to this connection are granted, the connection ID is saved, the
; CDT address is stored and the CDT state is set to open.
;
; Inputs:
;
;	R3			-Addr of CDT
;	R4			-Addr of PDT
;
;	CDT initialized as follows:
;
;	CDT$L_LCONID		-Local conid
;	      MSGINPUT		-Addr to call in SYSAP for rec'd msgs
;	      DGINPUT		-Addr to call in SYSAP for rec'd dgs
;	      ERRADDR		-Addr to call in SYSAP for connection errors
;	      RSTATION		-Remote station addr
;	      PDT		-Addr of PDT
;	      MINSEND		-Minimum send credit req'd by SYSAP
;	      INITLREC		-Initial credit extended by SYSAP
;	      DGREC		-Initial # of dg's queued 
;	      STATE		-CLOSED
;	      PB		-Addr of selected PB to remote system
;	      WAITQFL/BL	-Set to show no entries
;	      RPROCNAM		-Addr of dest process name
;	      LPROCNAM		-Addr of local process name
;	      CONDAT		-Addr of connect data
;
;	other CDT fields	-0
;
;
;	(SP)			-Return PC in SYSAP
;
; Outputs:
;
;	R0			-Status:  SS$_NORMAL, SS$_FAILRSP,
;					  SS$_REJECT, SS$_INSFMEM
;	R1			-Reject reason or fail response reason
;				 if R0 = REJECT or FAILRSP
;	R2			-Addr of ACCEPT_REQ if R0 = success
;	other registers		-Preserved
;
;	CDT$L_RCONID - UDA virtual circuit number
;-

	.ENABL	LSB
VC0NAM:	.ASCII	/MSCP$DISK/		; Name for UDA VC 0
VC0NAMLEN = .-VC0NAM			;  name length
VC1NAM:	.ASCII	/MSCP$TAPE/		; Name for UDA VC 1
VC1NAMLEN = .-VC1NAM			;  name length
VC2NAM:	.ASCII	/DUP/			; Name for UDA VC 2
VC2NAMLEN = .-VC2NAM			;  name length

FPC$CONNECT::

	MOVL	PDT$L_UCB0(R4),R0	; R0 => UCB.
	BBC	#UCB$V_ONLINE,-		; Reject connect if offline.
		UCB$W_STS(R0),CON_NO_NODE

	$CHK_CDTSTATE -			; Verify that CDT state 
		CLOSED,-		;  is closed;  if not,
		ERROR=STATE_ERR		;  caller made error
;
; If the desired process name is MSCP$DISK, MSCP$TAPE or DUP, then the
; connection can be completed.
;
	PUSHL	R3			; Remember R3=>CDT.
	BBS	#UDA$V_STOPPED,-	; Only allow Connections to DUP if
		UCB$B_UDAFLAGS(R0),-	;  Port is closed.
		TSTVC2
	CMPC5	#VC0NAMLEN,VC0NAM,#^A/ /,-
		#16,@CDT$L_RPROCNAM(R3) ; Is the connection to MSCP$DISK?
	BEQL	CONVC0			; If yes make connection to VC0

	MOVL	(SP),R3			; Refresh R3 => CDT.
	CMPC5	#VC1NAMLEN,VC1NAM,#^A/ /,-
		#16,@CDT$L_RPROCNAM(R3) ; Is the connection to MSCP$TAPE?
	BEQL	CONVC1			; If yes make connection to VC1

	MOVL	(SP),R3			; Refresh R3 => CDT.
TSTVC2:
	CMPC5	#VC2NAMLEN,VC2NAM,#^A/ /,-
		#16,@CDT$L_RPROCNAM(R3) ; Is the connection to DUP?
	BEQL	CONVC2			; If yes make connection to VC2
	POPL	R3			; Remove R3 from stack.
CON_NO_NODE:
	JSB	G^SCS$DEALL_CDT		; Free R3 => CDT.
	MOVZWL	#SS$_NOSUCHNODE,R0	; Indicate No Such Node.
	RSB				;
CONREJ:
	JSB	G^SCS$DEALL_CDT		; Free R3 => CDT.
	MOVZWL	#SS$_REJECT,R0		; Otherwise reject connection
	RSB				;
CON_NO_LISTEN:
	JSB	G^SCS$DEALL_CDT		; Free R3 => CDT.
	MOVZWL	#SS$_NOLISTENER,R0	; Indicate No Such Listener.
	RSB				;
;
; Make a connection to MSCP$DISK which is virtual circuit 0 for a
; UDA.
;
CONVC2:
	MOVAB	PDT$L_PU_VC2(R4),R0	; Setup for common code.
	MOVAB	PDT$W_PU_CRED2(R4),R1	; Initial credits to assign.
	MOVL	#2,R2			; Remote connection ID.
	BRB	CON_COMMON		; Branch around.

CONVC1:
	MOVAB	PDT$L_PU_VC1(R4),R0	; Setup for common code.
	MOVAB	PDT$W_PU_CRED1(R4),R1	; Initial credits to assign.
	MOVL	#1,R2			; Remote connection ID.
	BRB	CON_COMMON		; Branch around.

CONVC0:
	MOVAB	PDT$L_PU_VC0(R4),R0	; Setup for common code.
	MOVAB	PDT$W_PU_CRED0(R4),R1	; Initial credits to assign.
	CLRL	R2			; Remote connection ID is zero.
CON_COMMON:
	POPL	R3			; Refresh R3 => CDT.
	BBC	R2,PDT$B_SERVERS(R4),-	; See if this Server supported at this
		CON_NO_LISTEN		;  port. If not, branch.
	BBSS	R2,PDT$B_CONBITMAP(R4),-; Mark corresponding bit in bit map
		CONREJ			;  as OPEN.  If already set, reject.
	MOVL	R3,(R0)			; Save address of CDT for VCx
	MOVL	R2,CDT$L_RCONID(R3)	; Set virtual circuit number into CDT
	INCB	PDT$B_NOCURCON(R4)	; Increment # of current connections.

	MOVW	(R1),CDT$W_SEND(R3)	; Put in initial send credits.

	MOVW	#CDT$C_OPEN,-		; Move CDT state to
		CDT$W_STATE(R3)		;  open

; Here we make room on the stack to create a Connect Message to return
; to the caller.  In order to get control after the caller is finished
; with the Connect data, we call him back as a co-routine.

	POPL	R1				; R1 has callers return point.
	MOVAB	-SCSCMG$S_SCSCMGDEF(SP),SP	; Create space on stack.
	MOVL	SP,R2				; R2=>Connect data area.

	PUSHR	#^M<R1,R2,R3,R4,R5>		; Save MOVC registers
	MOVC5	#0,(SP),#0,-			; Zero initialize structure
		#SCSCMG$S_SCSCMGDEF,(R2)
	POPR	#^M<R1,R2,R3,R4,R5>		; Restore MOVC registers

;	MOVB	SYSGEN_PARAMETER,-
;		SCSCMG$B_SNDATA+1(R2)		; Copy Allocation Class.

	MOVZWL	S^#SS$_NORMAL,R0		; Set normal completion
	JSB	(R1)				; Call back Caller as co-routine.
	MOVAB	SCSCMG$S_SCSCMGDEF(SP),SP	; Free up stack space.
	RSB					; and return

	.DSABL	LSB


	.SBTTL	+	FPC$DCONNECT, PROCESS A DISCONNECT CALL

;+
; FPC$DCONNECT is called by the SYSAP.  It may be called only from the
; open state.  The CDT is moved to the closed state.
;
; Inputs:
;
;	R0			-Disconnect reason
;	R3			-Addr of CDT being disconnected
;	R4			-Addr of PDT
;
; Outputs:
;
;	R0			-Status:  SS$_NORMAL, SS$_ILLCDTST
;	R1,R2			-Destroyed
;	other registers		-Preserved
;-


FPC$DCONNECT::

	MOVW	R0,CDT$W_REASON(R3)	; Save disconnect reason
	$CHK_CDTSTATE	-		; Assure that CONNECTION is open.
		OPEN,-
		ERROR=STATE_ERR

	MOVW	#CDT$C_CLOSED,-		; Move state to closed
		CDT$W_STATE(R3)		;
	DECB	PDT$B_NOCURCON(R4)	; Decrement # of current connections.

	EXTZV	#0,#2,CDT$L_RCONID(R3),R0; Get index of CDT pointer for connection.

	BBSC	R0,PDT$B_CONBITMAP(R4),10$ ; Clear the connection active bit
10$:

; The following two instructions save the available credits on the connection
;  that we are disconnecting so that we can later re-connect.  This is only
;  useful if dis-connecting and later re-connecting do not have an FPC$MRESET
;  done in between.  FPC$MRESET re-inits the credits for all possible
;  connections (in INIT_PU_PDT, called from HARDWARE_INIT).

	MOVAW	PDT$W_PU_CRED0(R4)[R0],R1; R1=> Repository of credits for this
					 ;  connection ID.
	MOVW	CDT$W_SEND(R3),(R1)	 ; Save current credits for later connect.
; End of code that saves available credits.

	MOVAB	NULL_CDT,-
		PDT$L_PU_CDTARY(R4)[R0]	; Reset ptr.
	JSB	G^SCS$DEALL_CDT		; Deallocate R3 => CDT.
	MOVZWL	S^#SS$_NORMAL,R0	; Normal return status.
	RSB				;
	.PAGE
	.SBTTL	SEQUENCED MESSAGE CALLS
	.SBTTL	+	FPC$ALLOCMSG,	ALLOCATE A MESSAGE BUFFER

;+
; FPC$ALLOCMSG is optimized for the case where all resources that are
; allocated are available.  FPC$ALLOCMSG  first checks the state of the
; CONNECTION to assure that it is OPEN.  Then it allocates a send credit
; and a buffer.  Finally it points R2 at the application (MSCP) portion
; of the buffer, stores R2 in CDRP$L_MSG_BUF and returns a success code.
;
; Exceptions to this flow are handled out of line.
;
; First, if the CONNECTION state is NOT open, we return the SS$_ILLCDTST
; status.
;
; If no send credits are available, the thread is suspended on the
; CDT$L_CRWAITQBL.
;
; Finally, if no buffers are available, we first try to scare some up by
; calling internal subroutine POLL_CMDRING, which polls the command ring
; to free up slots and buffers.  If upon return from this call, a buffer
; is available, we simply rejoin the mainline code.  If however, buffers
; are still NOT available, we return the previously allocated send credit
; and suspend the thread on PDT$L_BUFQBL.
;
; Upon resumption of threads from either of these wait Q's, we simply
; branch back to the start of the routine and try all over again.
;
; Inputs:
;
;	R4			-Addr of PDT
;	R5			-Addr of CDRP
;	CDRP$L_CDT		-Addr of CDT
;
; Outputs:
;
;	R0			-Status:  SS$_NORMAL, SS$_ILLCDTST
;	R1			-Destroyed
;	R2			-Addr of message buffer, if status=success
;	Other registers		-Preserved
;
;	CDRP$L_MSG_BUF		-Addr of message buffer, if status=success
;-


FPC$ALLOCMSG::

	MOVL	CDRP$L_CDT(R5),R2	; Get CDT addr
	$CHK_CDTSTATE	-		; Verify connection state
		OPEN,-			;  is open.
		ERROR=STATE_ERR,-	; Else report error to caller
		CDT=R2			;

	DECW	CDT$W_SEND(R2)		; Allocate the send credit.
	BLSS	20$			; LSS means no credits available.
	REMQUE	@PDT$L_PU_FQFL(R4),R0	; R0 => free buffer.
	BVS	30$			; VS implies NO buffers.
10$:
	MOVAB	UDAB$T_TEXT(R0),R2	; R2 => MSCP portion of buffer.
	MOVL	R2,CDRP$L_MSG_BUF(R5)	; Return to caller in CDRP as well.
	MOVZWL	S^#SS$_NORMAL,R0	; Success return.
	RSB				; And return.

20$:
	MOVL	CDT$L_CRWAITQBL(R2),R1	; R1 => where to INSQUE to await credits.
	BRB	40$			; Branch around to common suspend code.
30$:
	BSBW	POLL_CMDRING		; Reclaim released buffers from
					;  command ring.
	REMQUE	@PDT$L_PU_FQFL(R4),R0	; Again try for R0 => free buffer.
	BVC	10$			; VC implies buffers. Branch to mainline.
	MOVL	CDRP$L_CDT(R5),R2	; Refresh R2=>CDT after call to POLL_CMDRING.
	MOVL	PDT$L_PU_BUFQBL(R4),R1	; R1 => where to INSQUE to await buffers.
40$:
	INCW	CDT$W_SEND(R2)		; Return improper allocate.
	POPL	CDRP$L_SAVD_RTN(R5)	; Save high level return.
	$SUSP_SCS	(R1)		; Suspend on R1 => wait Q element.
	PUSHL	CDRP$L_SAVD_RTN(R5)	; Restore high level return.
	BRB	FPC$ALLOCMSG		; And go back to check on credits.
	.PAGE
	.SBTTL	+	FPC$DEALLOMSG,	DEALLOCATE A MESSAGE BUFFER

;+
; FPC$DEALLOMSG resets the message address specified by the caller to
; the top of the message buffer and clears CDRP$L_MSG_BUF.  It then
; decides whether to insert the free buffer onto the RESPONSE RING
; or onto the free Q of buffers, with the RESPONSE RING having priority,
; and being selected whenever it is not entirely full.  If the RESPONSE
; RING is full then the buffer is INSQUEd onto PDT$L_PU_FQBL.
;
; If this INSQUE represents the first buffer on the free Q, then we
; attempt to resume any threads waiting for buffers (PDT$L_PU_BUFQFL).
; While the free Q remains non-empty and there exist threads waiting
; for buffers, we continue to resume the threads until either we run
; out of buffers or we run out of threads to resume.
;
; Internal entrypoint Q_DEALLOC_BUF is called from POLL_CMDRING after
; R2 has been pointed at the buffer header.  Also internal entrypoint
; INSERT_IN_RRING is called from INIT_PU_PDT at CONNECT time in order to
; prime the RESPONSE RING.
; Inputs:
;
;	R4			-Addr of PDT
;	R5			-Addr of CDRP
;	CDRP$L_MSG_BUF		-Addr of message buffer
;
; Outputs:
;
;	R0-R2			-Destroyed
;	Other registers		-Preserved
;	CDRP$L_MSG_BUF		-Cleared
;-

FPC$DEALRGMSG::
	SUBL	#UDAB$T_TEXT,R2		; R2 => buffer header.
	BRB	Q_DEALLOC_BUF		;  and branch around to common code.
FPC$DEALLOMSG::

	SUBL3	#UDAB$T_TEXT,-
		CDRP$L_MSG_BUF(R5),R2	; R2 => buffer header.
	CLRL	CDRP$L_MSG_BUF(R5)	; Prevent spurious deallocates.

FPC$QUEUEDG::
Q_DEALLOC_BUF:				; Called here from POLL_CMDRING,
					;  with R2 => free buffer.
	CMPB	#UDA$K_RINGSIZE,-	; See if response ring is full up.
		PDT$B_RRINGCNT(R4)
	BLEQ	INSERT_IN_FREEQ		; LEQ implies full. Goto put on free Q.

INSERT_IN_RRING:			; Here R2 => buffer to insert.

	EXTZV	#0,#UDA$K_RINGEXP,-	; R0 = index of slot to use in response
		PDT$B_RRINGINX(R4),R0	;  ring.

	MOVB	UDAB$B_BUFFNO(R2),-	; Label new contents of this slot.
		PDT$B_RRCONTENT(R4)[R0]

	MOVB	R0,UDAB$B_RINGINX(R2)	; Remember where this buffer is for
	MOVB	#1,UDAB$B_RINGNO(R2)	;  debugging.

	ASSUME	UDAB$B_CREDTYPE	EQ	UDAB$W_MSG_LEN+2
	ASSUME	UDAB$B_CONID	EQ	UDAB$B_CREDTYPE+1
	MOVL	#UDAB$C_LENGTH-UDAB$T_TEXT,-	; Initialize response buffer
		UDAB$W_MSG_LEN(R2)		;  length and zero credits,
						;  type and conid.

	MOVL	UDAB$L_DESCRIP(R2),-	; Fill in command ring slot.
		PDT$L_RSPRING(R4)[R0]
	INCB	PDT$B_RRINGINX(R4)	; Next time use next slot in ring.
	INCB	PDT$B_RRINGCNT(R4)	; Increment # slots in use.

INSERT_RTN:
	RSB				; And return to caller or caller's caller.

INSERT_IN_FREEQ:

	INSQUE	UDAB$L_FLINK(R2),-	; Insert free buffer onto free Q.
		@PDT$L_PU_FQBL(R4)
	BNEQ	INSERT_RTN		; NEQ implies not first buffer on Q.
10$:
	$RESUME_FP	-		; Resume first thread awaiting buffers.
		@PDT$L_PU_BUFQFL(R4),-
		QEMPTY=INSERT_RTN	; Label to branch to if Q empty.

	CMPL	PDT$L_PU_FQPTR(R4),-	; Test for emptiness of free Q.
		PDT$L_PU_FQFL(R4)	;  If list points to itself, then empty.
	BNEQ	10$			; NEQ means NOT empty, so try to resume
	RSB				; Return to caller if empty.
	.PAGE
	.SBTTL	+	FPC$RCHMSGBUF,	RECYCLE MESSAGE BUFFER
	.SBTTL	+			AT HIGH PRIORITY
	.SBTTL	+	FPC$RCLMSGBUF,	RECYCLE MESSAGE BUFFER
	.SBTTL	+			AT LOW PRIORITY

;+
; FPC$RCxMSGBUF checks if there is at least one send credit.  If
; not, the SYSAP is suspended until there is.  FPC$RCxMSGBUF then
; decrements the send credit.  The wait, if required, places the 
; SYSAP CDRP at the end of the wait queue for low priority and at
; the head of the queue for high priority.  The address of the
; buffer being recycled is returned in R2.
;
; Inputs:
;
;	R4			-Addr of PDT
;	R5			-Addr of CDRP
;	CDRP$L_MSG_BUF		-Addr of message buffer
;	CDRP$L_CDT		-Addr of CDT
;
; Outputs:
;
;	R0			-Status:  SS$_NORMAL, SS$_ILLCDTST
;	R1			-Destroyed
;	R2			-Addr of message buffer
;	Other registers		-Preserved
;-


FPC$RCHMSGBUF::

	MOVL	CDRP$L_CDT(R5),R1	; R1 => CDT.
	$CHK_CDTSTATE	-		; Assure that connection open.
		OPEN,-
		ERROR=STATE_ERR,-
		CDT=R1
	DECW	CDT$W_SEND(R1)		; Test decrement a credit.
	BLSS	10$			; LSS implies there were none to give.
	MOVL	CDRP$L_MSG_BUF(R5),R2	; Return R2 => msg buffer.
	MOVZWL	S^#SS$_NORMAL,R0	; Return status for caller
	RSB				; And return.
10$:					; Here only if allocation failure.
	INCW	CDT$W_SEND(R1)		; Restore from above test decrement.
	POPL	CDRP$L_SAVD_RTN(R5)	; Save first level return address.
	$SUSP_SCS	-		; Suspend this thread at HEAD of 
		CDT$L_CRWAITQFL(R1)	;  allocation wait list.
	PUSHL	CDRP$L_SAVD_RTN(R5)	; Restore first level return to stack.
	BRB	FPC$RCHMSGBUF		; Go back and try to allocate.

FPC$RCLMSGBUF::

	MOVL	CDRP$L_CDT(R5),R1	; R1 => CDT.
	$CHK_CDTSTATE	-		; Assure that connection open.
		OPEN,-
		ERROR=STATE_ERR,-
		CDT=R1
	DECW	CDT$W_SEND(R1)		; Test decrement a credit.
	BLSS	10$			; LSS implies there were none to give.
	MOVL	CDRP$L_MSG_BUF(R5),R2	; Return R2 => msg buffer.
	MOVZWL	S^#SS$_NORMAL,R0	; Return status for caller
	RSB				; And return.
10$:					; Here only if allocation failure.
	INCW	CDT$W_SEND(R1)		; Restore from above test decrement.
	POPL	CDRP$L_SAVD_RTN(R5)	; Save first level return address.
	$SUSP_SCS	-		; Suspend this thread at TAIL of 
		@CDT$L_CRWAITQBL(R1)	;  allocation wait list.
	PUSHL	CDRP$L_SAVD_RTN(R5)	; Restore first level return to stack.
	BRB	FPC$RCLMSGBUF		; Go back and try to allocate.
	.PAGE
	.SBTTL	+	FPC$SNDCNTMSG,	SEND COUNTED SEQUENCED MESSAGE
; Inputs:
;
;	R1			-# bytes of application data
;	R4			-Addr of PDT
;	R5			-Addr of CDRP
;	CDRP$L_CDT(R5)		-Addr of CDT
;	CDRP$L_MSG_BUF(R5)	-Addr of message (user portion)
;	CDRP$L_RSPID(R5)	-RSPID (to set RETFLG)
;
; Outputs:
;
;	R0			-Status:  SS$_NORMAL, SS$_ILLCDTST
;	R1,R2			-Destroyed
;	Other registers		-Preserved
;-

FPC$SNDCNTMSG::

	MOVL	CDRP$L_CDT(R5),R0	; R0 => CDT
	$CHK_CDTSTATE	-		; Verify connection is
		OPEN,-			;  open
		ERROR=STATE_ERR,-	; Else report error to SYSAP
		CDT=R0

	SUBL3	#UDAB$T_TEXT,-		; Point to buffer header.
		CDRP$L_MSG_BUF(R5),R2	; R2 => buffer header.
	CLRL	CDRP$L_MSG_BUF(R5)	; Prevent spurious deallocates.

	ASSUME	UDAB$B_CREDTYPE		EQ	UDAB$W_MSG_LEN+2
	ASSUME	UDAB$B_CONID		EQ	UDAB$B_CREDTYPE+1
	MOVL	R1,UDAB$W_MSG_LEN(R2)	; Put message length in header.
	MOVB	CDT$L_RCONID(R0),-	; Put remote connection ID in message
		UDAB$B_CONID(R2)	;  header.

	MOVQ	R3,CDRP$L_FR3(R5)
	POPL	CDRP$L_FPC(R5)		; Save context in CDRP.

	CMPB	#UDA$K_RINGSIZE,-	; See if any slots available in command
		PDT$B_CRINGCNT(R4)	;  ring.
	BLEQ	CRING_FULL		; LEQ implies ring full.

INSERT_IN_CRING:			; Called from POLL_CMDRING with
					;  R2 => buffer.

	EXTZV	#0,#UDA$K_RINGEXP,-	; R0 = index of slot to use in command
		PDT$B_CRINGINX(R4),R0	;  ring.


	.IF	DF	UDA50_BYPASS
	MOVL	UDAB$L_DESCRIP(R2),R1	; Copy descriptor to R1.
	BICL	#UDA_M_OWN!-		; Clear port ownership and mark
		 UDA_M_FLAG,R1		;  so port should NOT interrupt yet.
	MOVL	R1,PDT$L_CMDRING(R4)[R0]; Copy into slot without hi order bits.
	.ENDC

	MOVB	UDAB$B_BUFFNO(R2),-	; Label new contents of this slot.
		PDT$B_CRCONTENT(R4)[R0]

	ASSUME	UDAB$B_RINGNO	EQ	UDAB$B_RINGINX+1
	MOVZBW	R0,UDAB$B_RINGINX(R2)	; Remember where this buffer is for
					;  debugging.

ENABLE_COMMAND_START:
	MOVL	UDAB$L_DESCRIP(R2),-	; Fill in command ring slot.
		PDT$L_CMDRING(R4)[R0]	; NOTE, this instruction copied below
					;  to allow for dynamic patching to
					;  enable tracing.
ENABLE_COMMAND_END:
	MOVL	PDT$L_PU_CSR(R4),R1	; R1 => UDA CSR.
	MOVW	UDAIP(R1),R0		; Jiggle controller register to force
					;  polling of command ring.
	INCB	PDT$B_CRINGINX(R4)	; Next time use next slot in ring.
	INCB	PDT$B_CRINGCNT(R4)	; Increment # slots in use.

	RSB				; And return to caller or caller's caller.

CRING_FULL:

; The following instructions (commented out) were useful in debugging only.
;	BEQL	10$			; EQL means ring full not overflowed.
;	BUG_CHECK	UDAPORT,FATAL	; Here we have overflowed command ring.
;10$:
	INSQUE	UDAB$L_FLINK(R2),-	; Insert onto tail of backed up buffers.
		@PDT$L_PU_SNDQBL(R4)
	BSBW	POLL_CMDRING		; Free up any possible slots in
					;  command ring and dequeue from SND Q.
	RSB				; Return to caller's caller.

ENABLE_COMMAND_CODE:			; If we enable tracing, the driver will
					;  dynamically patch location
					;  ENABLE_COMMAND_START to BRW here.
	BSBW	TRACE_COMMAND		; Copy command buffer to trace table.

	MOVL	UDAB$L_DESCRIP(R2),-	; Fill in command ring slot.
		PDT$L_CMDRING(R4)[R0]
	BRW	ENABLE_COMMAND_END	; Branch back to normal stream.

ENABLE_COMMAND_OFFSET=ENABLE_COMMAND_CODE-ENABLE_COMMAND_START-3
	.PAGE
	.SBTTL	+	FPC$MAPIRP,	Map a buffer

;+
; FPC$MAPIRP - map a user buffer given IRP (CDRP) values.
;
; Inputs:
;	R4 => PDT
;	R5 => CDRP
;	CDRP$L_LBUFH_AD => area to fill in with UNIBUS virtual address of
;				user buffer.
;
; Outputs:
;	CDRP$L_UBARSRCE	filled in with a) datapath assigned, b) # UBA map
;					registers assigned, c) 1st map register
;
;	@CDRP$L_LBUFH_AD filled in with UNIBUS virtual address of user buffer
;
;	R0-R2	destroyed
;	Other registers preserved.
;-

FPC$MAPIRP::
	CLRL	CDRP$L_UBARSRCE(R5)	; Initialize.
	POPL	CDRP$L_SAVD_RTN(R5)	; Save return for two level process.

	JSB	@REQDATAPATH_TV		; Allocate datapath, if any available.

	JSB	G^IOC$REQMAPUDA		; Allocate map registers.
	JSB	G^IOC$LUBAUDAMAP	; Load map registers for this transfer.

; Here we fill in the local buffer handle.  A description of the UBA mapping
;	resources assigned to this transfer are currently in CDRP$L_UBARSRCE.
;	We calculate the UNIBUS virtual address of the transfer and put this
;	value into the @CDRP$L_LBUFH_AD.

	MOVZWL	CDRP$W_BOFF(R5),R0	; Calculate UNIBUS virtual address of
					;  user buffer. First get byte offset.

	INSV	CDRP$L_UBARSRCE+UBMD$B_DATAPATH(R5),-
		#24,#8,R0		; Place datapath number in high byte.
	BICB	#1,R0			; Clear low bit in case of odd address.

	INSV	CDRP$L_UBARSRCE+UBMD$W_MAPREG(R5),-
		#9,#9,R0		; High order of UNIBUS virtual
					;  address is map register #.
	MOVL	CDRP$L_LBUFH_AD(R5),R1	; R1 => destination for buffer handle.

	MOVL	R0,(R1)+		; Write "UBA" buffer
	CLRQ	(R1)			;  handle and zero out rest.

	JMP	@CDRP$L_SAVD_RTN(R5)	; Return to top level caller.
	.PAGE
	.SBTTL	+	FPC$MAPIRP_UV1,	Map a buffer for uVAX I

;+
; FPC$MAPIRP_UV1 - map a user buffer given IRP (CDRP) values.
;
; Inputs:
;	R4 => PDT
;	R5 => CDRP
;	CDRP$L_LBUFH_AD => area to fill in with UNIBUS virtual address of
;				user buffer.
;
; Outputs:
;	CDRP$L_UBARSRCE	filled in with a) datapath assigned, b) # UBA map
;					registers assigned, c) 1st map register
;
;	@CDRP$L_LBUFH_AD filled in with UNIBUS virtual address of user buffer
;
;	R0-R2	destroyed
;	Other registers preserved.
;-

FPC$MAPIRP_UV1::
	CLRL	CDRP$L_UBARSRCE(R5)	; Initialize.
	BLBS	CDRP$W_BOFF(R5),-	; Branch around if Not word aligned.
		MAP_UNALIGN
MAP_ODD:				; Label to allow branch back.

	POPL	CDRP$L_SAVD_RTN(R5)	; Save return for two level process.

	JSB	G^IOC$REQMAPUDA		; Allocate map registers.
	JSB	G^IOC$LUBAUDAMAP	; Load map registers for this transfer.

; Here we fill in the local buffer handle.  A description of the UBA mapping
;	resources assigned to this transfer are currently in CDRP$L_UBARSRCE.
;	We calculate the UNIBUS virtual address of the transfer and put this
;	value into the @CDRP$L_LBUFH_AD.

	MOVZWL	CDRP$W_BOFF(R5),R0	; Calculate UNIBUS virtual address of
					;  user buffer. First get byte offset.

	INSV	CDRP$L_UBARSRCE+UBMD$W_MAPREG(R5),-
		#9,#9,R0		; High order of UNIBUS virtual
					;  address is map register #.
	MOVL	CDRP$L_LBUFH_AD(R5),R1	; R1 => destination for buffer handle.

	BISL3	#UQPORT_M_MAPPED,R0,(R1)+; Write BUS virtual address of buffer
	MOVL	PU$L_MPHYAD,(R1)+	 ;  and physical address of the pseudo
	CLRL	(R1)			 ;  map registers and zero out rest.

	JMP	@CDRP$L_SAVD_RTN(R5)	; Return to top level caller.
	.PAGE
	.SBTTL	+	MAP_UNALIGN	uVAX I Q-BUS Map Unaligned Buffer
;+
; MAP_UNALIGN - routine to allocate the Aligned Page (i.e. 512 physically
;  contiguous bytes) and to copy upto 512 bytes of user data to this
;  buffer. Things to keep in mind:
;
;  1. Allocation of the Aligned Page is governed by PDT$L_PQ_POWNER.  This
;	longword, if zero, indicates the Aligned Page is available.  Non-zero
;	implies it is allocated and the owner's CDRP is saved in the longword.
;
;  2. PDT$L_PQ_PGQFL, PDT$L_PQ_PGQBL are a queue header that lists CDRP's
;	waiting for the Aligned Page.
;
;  3. PDT$L_PQ_SVPPTE points to a PTE slot in the System Page table that
;	belongs to this Port.  PDT$L_PQ_UBFSVA contains the System Virtual
;	Address associated with this PTE.
;
; "Mapping" an unaligned user buffer means copying all, or the first 512 bytes,
;  whichever is less, of the user data to the Aligned Page.  This means that
;  CDRP$L_BCNT (if originally >512) is reduced to 512.  The copying uses
;  the PTE slot pointed at by PDT$L_PQ_SVPPTE, and the System Virtual Address
;  associated with it.  Essentially, the PTE that points to the first segment
;  (i.e. the user data in the first page of the user's buffer) is put into
;  our reserved PTE slot.  Then the user data in this segment is copied.  Then
;  the next user PTE is loaded into our reserved PTE slot and the second (if
;  any) segment is copied.
;
; Inputs:
;	R4 => PDT
;	R5 => CDRP
;
; Outputs:
;	Aligned Page allocated and user data copied.
;	Registers R0-R2 modified.
;-

MAP_UNALIGN:				; We come here for unaligned transfers.
	MOVL	PDT$L_UCB0(R4),R0	; R0 => port UCB.
	BBS	#PS1_V_OD,-		; If controller supports odd addresses,
		UCB$W_PORTSTEP1(R0),-	;  then branch back in line.
		MAP_ODD
	TSTL	PDT$L_PQ_POWNER(R4)	; Test if aligned page available.
	BEQL	10$			; EQL implies available.
	MOVQ	R3,CDRP$L_FR3(R5)	; Else save context.
	INCW	@CDRP$L_RWCPTR(R5)	; Bump UCB$L_RWAITCNT.
	POPL	CDRP$L_FPC(R5)		; Save return point.
	INSQUE	CDRP$L_FQFL(R5),-	; Queue this CDRP to resource wait Q.
		@PDT$L_PQ_PGQBL(R4)
	RSB				; Return to caller's caller.
10$:
	MOVL	R5,PDT$L_PQ_POWNER(R4)	; Allocate Aligned Page.
	CMPL	#NO_PHYCONTIGBYT,-	; Test for transfer shorter than length
		CDRP$L_BCNT(R5)		;  of aligned contiguous buffer.
	BGEQ	20$			; GEQ implies short transfer.
	MOVL	#NO_PHYCONTIGBYT,-	; Reduce transfer to total bytes in
		CDRP$L_BCNT(R5)		;  aligned contiguous buffer.
20$:

; Here after successfully allocating the aligned buffer, if the user operation
; is a WRITE, we copy the user's data to the aligned buffer.  If the user
; operation is a READ, we branch around the copy and merely fillin the
; CDRP$L_LBUFH_AD field.  The data from a READ is copied to the user
; buffer after the I/O is complete.

	BBS	#IRP$V_FUNC,-		; If a READ, branch around.
		CDRP$W_STS(R5),40$
	BSBB	SETUP_COPY_SEG1		; Call to setup copy of user data.
					;  This is a complex routine that
					;  returns: R0 = # bytes in first
					;  segment, R1 => user data,
					;  R2 => aligned page, (SP) = # bytes
					;  in second segment (or zero if none),
					;  4(SP) (valid only if (SP) non-zero)
					;  zero.
30$:
	MOVB	(R1)+,(R2)+		; Copy a byte.
	SOBGTR	R0,30$			; Loop thru entire segment.
	POPL	R0			; Get length of next segment (if any).
	BEQL	40$			; EQL implies no more.
	BSBB	SETUP_COPY_SEG2		; Call to setup copy of second segment.
	BRB	30$			; Branch back to loop.
40$:
	MOVL	CDRP$L_LBUFH_AD(R5),R1	 ; R1 => destination for buffer handle.
	MOVL	PDT$L_PQ_PGPHAD(R4),(R1)+; Copy physical address of Aligned Page
	CLRQ	(R1)			 ;  and zero out rest.
	RSB				 ; And return to caller.
	.PAGE
	.SBTTL	SETUP_COPY_SEG1 and SETUP_COPY_SEG2

;+
; SETUP_COPY_SEG1 - a routine to setup a copy from (to) the aligned
;		page to (from) the user's buffer.
;
; Inputs:
;	CDRP$L_SVAPTE   => System Virtual Address of the Page Table Entry that
;			   maps the first page of the user buffer into user
;			   space.
;	CDRP$W_BOFF     =  Offset in this page of user data.
;	PDT$L_PQ_SVPPTE => System Virtual Address of an available PTE in the
;			   System Page Table that we can use to map the user
;			   buffer into System space.
;	PDT$L_PQ_UBFSVA => System space address of the page associated with
;			   previous PTE.
;	PDT$L_PQ_ALGNPG => System space address of the aligned page.
;	CDRP$L_BCNT     =  Length of data to transfer. ( < or = 512)
;
; Outputs:
;	R0 = Number of bytes to copy in first segment.  The first segment is
;		defined by the data beginning at CDRP$W_BOFF in the first
;		page of the user buffer and continuing till the end of the page.
;	R1 => System space address of first byte in user buffer.
;	R2 => First byte of aligned page.
;	(SP)  = Either # bytes in the second segment or zero.
;	4(SP) = Valid only if (SP) is non-zero.  Then this is zero.
;
; Note:  CDRP$L_SAVD_RTN is modified.
;

SETUP_COPY_SEG1:

	POPL	CDRP$L_SAVD_RTN(R5)	 ; Clean stack so that we can return
					 ;  values to caller on it.
	MOVL	CDRP$L_SVAPTE(R5),-	 ; Save user SVAPTE in PDT.
		PDT$L_PQ_USRPTE(R4)
	EXTZV	#PTE$V_PFN,#PTE$S_PFN,-	 ; Construct a PTE with the proper PFN,
		@CDRP$L_SVAPTE(R5),-	 ;  protection=KW, and own=K.  Here we
		@PDT$L_PQ_SVPPTE(R4)	 ;  move the PFN.
	BISL	#PTE$M_VALID!-		 ; And here we set VALID, the protection
		 PTE$C_KW!-		 ;  and the ownership and thereby map
		 PTE$C_KOWN,-		 ;  the first page of the user buffer
		@PDT$L_PQ_SVPPTE(R4)	 ;  into System Space.
	MOVZWL	CDRP$W_BOFF(R5),R0	 ; R0 = BOFF.
	ADDL3	PDT$L_PQ_UBFSVA(R4),R0,R1; R1 = SVA of 1st byte of user data.
	INVALID	R1			 ; Invalidate virtual address.
	CLRL	-(SP)			 ; Place signal on top of stack.
	ADDL3	R0,CDRP$L_BCNT(R5),R2	 ; R2 = relative offset of end of buffer
	CMPL	#512,R2			 ; Does user buffer slop onto next pages
	BGEQ	20$			 ; GEQ implies no spill over.
	SUBL3	R0,#512,R0		 ; R0 = length of 1ST segment to copy.
	BICL3	#^C<^X1FF>,R2,-(SP)	 ; Push length of spill into last page
					 ;  of user buffer.
	BNEQ	5$			 ; NEQ implies there was such slop.
	TSTL	(SP)+			 ; If no such slop, clear top of stack.
5$:
	ASHL	#-9,R2,R2		 ; R2 now contains one more than the
					 ;  number of full (512 byte) pages
					 ;  in middle of user buffer that have
					 ;  not yet been accounted for. Note
					 ;  that the first page (possibly
					 ;  partially filled - CDRP$W_BOFF)
					 ;  is accounted for in R0, and any
					 ;  spill over into the last page is
					 ;  accounted for on the top of stack.
10$:
	DECL	R2			 ; Reduce # full pages by one.
	BLEQ	30$			 ; If zero, branch around.
	PUSHL	#512			 ; Indicate full 512 byte segment.
	BRB	10$			 ; Branch back.
20$:
	MOVL	CDRP$L_BCNT(R5),R0	 ; R0 = length of 1St and only segment.
30$:

; Here R0 has the length of the first segment to copy.  The lengths of the
; subsequent segments have all been pushed onto the stack in inverse order.
; The last item pushed onto the top of stack is a zero to indicate no more
; segments.  R1 is pointing to the first byte of user data.

	MOVAB	PDT$L_PQ_ALGNPG(R4),R2	; R2 => Aligned page.
	JMP	@CDRP$L_SAVD_RTN(R5)	; Return to caller leaving data on stack

;+
; SETUP_COPY_SEG2 - Routine to setup copy of the second segment of user data
;		from (to) the user buffer to (from) the aligned page.
;
; Inputs:
;	PDT$L_PQ_USRPTE = System address of PTE that describes previous page
;				of user buffer
;	PDT$L_PQ_SVPPTE = Slot in System Page Table to map user buffer
;	PDT$L_PQ_UBFSVA = System Space address that corresponds to this slot
;
; Outputs:
;	PDT$L_PQ_USRPTE = PDT$L_PQ_USRPTE + 4
;	R1 => Byte zero of page that corresponds to slot defined by
;		PDT$L_PQ_SVPPTE.
;
; Note: R2 must be preserved.
;-

SETUP_COPY_SEG2:

	ADDL	#4,PDT$L_PQ_USRPTE(R4)	; Point to next user PTE.
	EXTZV	#PTE$V_PFN,#PTE$S_PFN,-	; Construct a PTE with the proper PFN,
		@PDT$L_PQ_USRPTE(R4),-	;  protection=KW, and own=K.  Here we
		@PDT$L_PQ_SVPPTE(R4)	;  move the PFN.
	BISL	#PTE$M_VALID!-		; And here we set VALID, the protection
		 PTE$C_KW!-		;  and the ownership and thereby map
		 PTE$C_KOWN,-		;  the next page of the user buffer
		@PDT$L_PQ_SVPPTE(R4)	;  into System Space.
	MOVL	PDT$L_PQ_UBFSVA(R4),R1	; R1 => Rest of user data.
	INVALID	R1			; Invalidate virtual address.
	RSB				; Return to caller.
	.PAGE
	.SBTTL	+	FPC$MAPIRP_BDA,	Map a buffer for BDA

;+
; Place holder.
;-

FPC$MAPIRP_BDA::
	RSB
	.PAGE
	.SBTTL	+	FPC$UNMAP,	Release mapping resources

;+
; FPC$UNMAP
;
; Inputs:
;	R5 => CDRP
;	CDRP$L_UBARSRCE	contains accounting of allocated resources.
;	CDRP$L_LBUFH_AD => local buffer handle.
;
; Outputs:
;	Resources returned
;	CDRP$L_LBUFH_AD cleared
;	R0-R2 destroyed
;	Other registers preserved
;-

FPC$UNMAP::

	PUSHL	R3					; Save register.
	PUSHL	R5					; Save another.
	MOVB	CDRP$L_UBARSRCE+UBMD$B_DATAPATH(R5),R0	; R0 contains datapath
							;  used in transfer.
	MOVL	PDT$L_UCB0(R4),R5		; R5 => UCB.
	MOVL	UCB$L_CRB(R5),R3		; R3 => CRB.
	MOVB	R0,CRB$L_INTD+VEC$B_DATAPATH(R3); Set path number for purge.
	JSB	G^IOC$PURGDATAP			; Purge specified data path.
	CLRB	CRB$L_INTD+VEC$B_DATAPATH(R3)	; Clear datapath # from CRB.
	POPL	R5				; Restore register.
	POPL	R3				; Restore another.

	JSB	G^IOC$RELMAPUDA		; Return allocated map registers.

	JSB	@RELDATAPATH_TV		; And also the datapath.

	CLRL	CDRP$L_LBUFH_AD(R5)	; Prevent spurious deallocates.
	RSB				; Return to caller.

	.PAGE
	.SBTTL	+	FPC$UNMAP_UV1,	Release mapping resources

;+
; FPC$UNMAP_UV1
;
; Inputs:
;	R5 => CDRP
;	CDRP$L_UBARSRCE	contains accounting of allocated resources.
;	CDRP$L_LBUFH_AD => local buffer handle.
;
; Outputs:
;	Resources returned
;	CDRP$L_LBUFH_AD cleared
;	R0-R2 destroyed
;	Other registers preserved
;-

FPC$UNMAP_UV1::

	BLBS	CDRP$W_BOFF(R5),-	; Branch around if Not word aligned.
		UNMAP_UNALIGN
UNMAP_ODD:				; Label to allow branch back.

	JSB	G^IOC$RELMAPUDA		; Return allocated map registers.

	CLRL	CDRP$L_LBUFH_AD(R5)	; Prevent spurious deallocates.
	RSB				; Return to caller.

UNMAP_UNALIGN:

; Here after successfully using the aligned Page, if the user operation
; is a READ, we copy the user's data from the aligned page.  If the user
; operation is a WRITE, we branch around the copy and merely deallocate
; the aligned Page.  The data from a WRITE is copied from the user
; buffer to the aligned Page when the aligned page is allocated.

	MOVL	PDT$L_UCB0(R4),R0	; R0 => port UCB.
	BBS	#PS1_V_OD,-		; If controller supports odd addresses,
		UCB$W_PORTSTEP1(R0),-	;  then branch back in line.
		UNMAP_ODD
	BBC	#IRP$V_FUNC,-		; If a WRITE, branch around.
		CDRP$W_STS(R5),20$
	BSBW	SETUP_COPY_SEG1		; Call to setup copy of user data.
					;  This is a complex routine that
					;  returns: R0 = # bytes in first
					;  segment, R1 => user data,
					;  R2 => aligned page, (SP) = # bytes
					;  in second segment (or zero if none),
					;  4(SP) (valid only if (SP) non-zero)
					;  zero.
10$:
	MOVB	(R2)+,(R1)+		; Copy a byte.
	SOBGTR	R0,10$			; Loop thru entire segment.
	POPL	R0			; Get length of next segment (if any).
	BEQL	20$			; EQL implies no more.
	BSBW	SETUP_COPY_SEG2		; Call to setup copy of second segment.
	BRB	10$			; Branch back to loop.
20$:
	CLRL	PDT$L_PQ_POWNER(R4)	; Release Aligned Page.
	CLRL	CDRP$L_LBUFH_AD(R5)	; Prevent spurious deallocates.
	REMQUE	@PDT$L_PQ_PGQFL(R4),R0	; R0 => Waiting CDRP (if any).
	BVS	30$			; VS implies no waiters.
	MOVQ	R3,-(SP)		; Save registers before resuming waiter.
	PUSHL	R5

	MOVL	R0,R5			; R5 => Waiter's CDRP.
	MOVQ	CDRP$L_FR3(R5),R3	; Restore his registers.
	BSBW	MAP_UNALIGN		; Call to allocate and copy data.
					;  Note allocation MUST succeed.
	JSB	G^SCS$RESUMEWAITR	; Resume waiting thread and any backed
					;  up IRP's.

	POPL	R5			; Restore our original registers.
	MOVQ	(SP)+,R3
30$:
	RSB				; Return to caller.
	.PAGE
	.SBTTL	+	FPC$UNMAP_BDA,	Release mapping resources BDA

;+
; Place holder.
;-

FPC$UNMAP_BDA::
	RSB
	.PAGE
	.SBTTL	INTERNAL SUBROUTINES
	.SBTTL	+	POLL_CMDRING

;+
; POLL_CMDRING is called to poll the command ring and reclaim any slots (and
; the buffers pointed to by them) that have been released back to the host by
; the port.  POLL_CMDRING makes use of some PDT fields:
;
;	PDT$B_CRINGCNT - which maintains the count of how many as yet
;			unreclaimed slots the host has sent to the port.
;
;	PDT$B_CPOLLINX - whose low order UDA$K_RINGEXP bits contain the index
;			of the command ring slot which we should poll next.
;
;	PDT$B_CRCONTENT - an array of UDA$K_RINGSIZE bytes, each of which
;			maintains the index of the buffer currently pointed
;			at by the corresponding ring slot.
;
;	PDT$L_BDTABLE - an array of UDA$K_RINGSIZE longwords, each of which
;			point to the buffer corresponding to the index of the
;			longword.
;
; POLL_CMDRING polls ring slots to see if the port has released them until
; either of the following two conditions obtain: PDT$B_CRINGCNT goes to zero,
; indicating that all command ring slots sent to the port have been reclaimed;
; or upon polling a slot we come upon one that has NOT been released as yet.
; Since slots are released in sequence, this means that we should cease
; polling.
;
; POLL_CMDRING always polls the slot selected by PDT$B_CPOLLINX.  The low order
; bits of this field are extracted and used as an index into the two arrays
; mentioned above.
;
; A slot is polled by testing its high order bit. A zero bit indicates that
; the slot has been released to the host.  Upon finding a released slot,
; POLL_CMDRING reclaims it and the buffer pointed to it by:
;
;	1. The index of the buffer is obtained from the element of the
;		PDT$B_CRCONTENT array corresponding to the current ring slot.
;
;	2. A pointer to the buffer is obtained from the PDT$L_BDTABLE array.
;
;	3. PDT$B_CPOLLINX is incremented so that the next poll will use the
;		next slot in the command ring.
;
;	4. PDT$B_CRINGCNT is decremented to show one less unreclaimed slot.
;
;	5. If any buffers are queued waiting for available ring slots on
;		PDT$L_PU_SNDQFL, the first one is removed from the Q and
;		inserted into the command ring by calling internal subroutine
;		INSERT_IN_CRING.
;
;	6. The now free buffer is put onto the response ring or the free Q,
;		whichever is appropriate, by calling internal subroutine,
;		Q_DEALLOC_BUF.
;
;	7. Finally we branch back to the beginning of POLL_CMDRING to poll
;		again.
;
; Inputs:
;
;	R4			-Addr of PDT
;
; Outputs:
;
;	R0-R2			-destroyed
;	Other registers		-preserved
;-

POLL_CMDRING:

	TSTB	PDT$B_CRINGCNT(R4)	; See if any slots in use on command
	BEQL	20$			;  ring. EQL implies NO.

	EXTZV	#0,#UDA$K_RINGEXP,-	; Extract ring index of slot of
		PDT$B_CPOLLINX(R4),R2	;  where to begin polling.

	TSTL	PDT$L_CMDRING(R4)[R2]	; Has controller released this slot?
	BLSS	20$			; LSS implies NO.

	MOVZBL	PDT$B_CRCONTENT(R4)[R2],R2	; R2 = index of buffer pointed
						;  at by this slot.
	MOVL	PDT$L_BDTABLE(R4)[R2],R2	; R2 => buffer header.

	PUSHL	R2				; Remember R2 => free buffer.

	INCB	PDT$B_CPOLLINX(R4)	; Bump polling index.
	DECB	PDT$B_CRINGCNT(R4)	; One less used command ring slot.

	REMQUE	@PDT$L_PU_SNDQFL(R4),R2	; R2 => buffer (if any) to be inserted
	BVS	10$			;  in command ring. VS implies NONE.
	BSBW	INSERT_IN_CRING		; Call to insert R2 => buffer in ring.
10$:
	POPL	R2			; Restore R2 => free buffer.
	BSBW	Q_DEALLOC_BUF		; Call to put free buffer onto response
					;  ring or onto free Q, whichever is
					;  appropriate.
	BRB	POLL_CMDRING		; Branch back to reclaim more buffers.
20$:
	RSB				; Return to caller.
	.PAGE
	.SBTTL	-	STATE_ERR,	RETURN CDT STATE ERROR
	.SBTTL	-			TO SYSAP

;+
; Set error status code and return to caller.
;-

STATE_ERR:

	MOVZWL	#SS$_ILLCDTST,R0		; Status = illegal CDT state
	RSB				; Return to SYSAP


	.PAGE
	.SBTTL	INTERRUPT SERVICING
	.SBTTL	+	PU$INT - Interrupt service routine
;
; Inputs:
;	00(SP) - Pointer to IDB
; 	04(SP)	- SAVED R0
; 	08(SP)	- SAVED R1
; 	12(SP)	- SAVED R2
; 	16(SP)	- SAVED R3
; 	20(SP)	- SAVED R4
; 	24(SP)	- SAVED R5
; 	28(SP)	- PC AT THE TIME OF THE INTERRUPT
; 	32(SP)	- PSL AT THE TIME OF THE INTERRUPT
;

PU$INT::					;
	MOVL	@(SP)+,R3		; Get address of IDB
	MOVL	IDB$L_OWNER(R3),R5	; Get address of UCB
	MOVL	UCB$L_PDT(R5),R4	; Get address of PDT
	MOVL	IDB$L_CSR(R3),R3	; R3 => UDA CSR.
	MOVW	UDASA(R3),-
		UCB$W_UDASA(R5)		; Save error status in UCB.

	MOVB	PDT$B_PURGEDP(R4),R0		; Fetch Purge data path number
	BEQL	10$				; Br if none
	CLRB	PDT$B_PURGEDP(R4)		; Clear it
	MOVL	UCB$L_CRB(R5),R1		; R1 => CRB to setup for purge
	MOVZBL	CRB$L_INTD+VEC$B_DATAPATH(R1),R2; Save datapath #, in case we
						;  interrupted purge in UNMAP.
	MOVQ	R1,-(SP)			; Push R1=>CRB, R2=datapath #.
	MOVB	R0,CRB$L_INTD+VEC$B_DATAPATH(R1); Set path number for purge
	JSB	G^IOC$PURGDATAP			; Purge specified data path
	MOVL	PDT$L_PU_CSR(R4),R3		; Refresh R3=>CSR after purge
	CLRW	UDASA(R3)			; Acknowledge purge interrupt
	MOVQ	(SP)+,R1			; Pop R1=>CRB, R2=Datapath #.
	MOVB	R2,CRB$L_INTD+VEC$B_DATAPATH(R1); Restore old contents of
						;  datapath # to CRB.
10$:
	BBCC	#UCB$V_INT,-		; See if we are awaiting interrupt. If
		UCB$W_STS(R5),20$	;  so then we are in hardware init. If
					;  not, branch around.
	MOVQ	UCB$L_FR3(R5),R3	; Restore initialization thread
	JSB	@UCB$L_FPC(R5)		;  context.
	BRB	30$			; And branch around to dismiss interrupt.
20$:

	BBSS	#UCB$V_PU_FRKBSY,-	; Appropriate UCB fork block, or else
		UCB$W_DEVSTS(R5),30$	;  branch to dismiss interrupt
	BSBB	POLL_RSPRING		; If we were successful in appropriating
					;  the fork block, BSBB to poll the
					;  response ring.
30$:
	POPR	#^M<R0,R1,R2,R3,R4,R5>	; Restore registers.
	REI				; And dismiss interrupt.
	.PAGE
	.SBTTL	+	POLL_RSPRING

;+
; POLL_RSPRING is called from the interrupt service routine at device IPL and
; with the UCB fork allocated to this thread (i.e. UCB$M_PU_FRKBSY bit on in
; UCB$W_DEVSTS).  POLL_RSPRING first IOFORK's on the UCB so that the interrupt
; can be dismissed and then after resuming execution at fork IPL, it frees up
; the UCB fork block (i.e. clears UCB$M_PU_FRKBSY) and tests whether a power
; failure has occurred recently.  If so, then we merely branch out of the flow
; here to begin a thread at POST_POWER_FORK, that causes all CONNECTION's to
; resynchronize.
;
; If we remain here (normal case) we traverse the response ring looking for
; buffers that have been released to the host (us), and upon finding one
; we determine whether it is a SEQUENCED MESSAGE or a DATAGRAM and we call
; the appropriate entrypoint in the SYSAP for the CONNECTION over which the
; message was received.
;
; Inputs:
;
;	R4				-Addr of PDT
;	R5				-Addr of UCB
;
;	UCB fork block allocated to this thread
;
; Outputs:
;
;	Response ring polled and SYSAPs called
;-
	.enabl	lsb
POLL_RSPRING:

	IOFORK				; Lower IPL.
	BICW	#UCB$M_PU_FRKBSY,-
		UCB$W_DEVSTS(R5)	; Allow fork block to be re-used.
	TSTW	UCB$W_UDASA(R5)		; See if we got a fatal error.
	BLSS	5$			; LSS means fatal error.
	BBS	#UCB$V_PU_MRESET,-	; If set, then MRESET request received
		UCB$W_DEVSTS(R5),8$	;  while we were forked, so go to do it.
	BBC	#UCB$V_POWER,-		; See if POWERFAIL occurred while
		UCB$W_STS(R5),10$	;  UCB fork block was busy. Branch if not.
	BRB	8$			; Branch around if YES powerfail.
5$:
	MOVW	#UDASA_ATTNCODE,-	; Indicate what kind of error log record
		UCB$W_ATTNCODE(R5)	;  we are about to create.
	JSB	G^ERL$DEVICEATTN	; Call to create error log record of INIT.
8$:
	BRW	POST_POWER_FORK		; If POWERFAIL, get out of here.
10$:
	BBCC	#0,PDT$W_CMDINT(R4),20$	; Branch if command ring NOT UNfull.
	BSBW	POLL_CMDRING		; Reclaim free space in command ring.
20$:
	CLRW	PDT$W_RSPINT(R4)	; Always clear response interrupt
					;  indication since we always poll
					;  response ring on interrupt.
30$:
	TSTB	PDT$B_RRINGCNT(R4)	; See if response ring has anything to
	BNEQ	50$			;  poll.  NEQ implies YES.
40$:
	RSB				; If no more, kill this thread.
50$:
	EXTZV	#0,#UDA$K_RINGEXP,-	; Extract index mod sing size leaving
		PDT$B_RPOLLINX(R4),R0	;  R0 = index of slot to poll.
	TSTL	PDT$L_RSPRING(R4)[R0]	; See if slot released to host.
	BLSS	40$			; LSS => slot still owned by controller.

	INCB	PDT$B_RPOLLINX(R4)	  ; Bump response poll index.
	DECB	PDT$B_RRINGCNT(R4)	  ; Decr # slots passed to controller.
	MOVZBL	PDT$B_RRCONTENT(R4)[R0],R0; R0 = index of buffer with response.
	MOVL	PDT$L_BDTABLE(R4)[R0],R3  ; R3 => buffer with response.

ENABLE_RESPONSE_START:
	REMQUE	@PDT$L_PU_FQFL(R4),R2	; R2 => free buffer. NOTE this instruction
					;  is copied below in the flow that gets
					;  executed if tracing is enabled.  Any
					;  edit to this instruction should also
					;  done to its copy.
ENABLE_RESPONSE_END:
	BVC	55$			; VC implies R2 => buffer.
	BSBW	POLL_CMDRING		; If no buffers, reclaim some.
	CMPB	#UDA$K_RINGSIZE,-	; For debugging, assure that we indeed
		PDT$B_RRINGCNT(R4)	;  have a full response ring.
	BEQL	57$			; EQL implies full response ring.
	BUG_CHECK	UDAPORT,FATAL	; Else bug check for now.
55$:
	BSBW	INSERT_IN_RRING		; Else insert free buffer in response
					;  ring.

57$:	MOVL	R3,R0			; R0 => buffer with response.

;	MOVZBL	UDAB$B_CONID(R0),R3	 ; R3 = connection ID of message.
; Here we assume that VC0 is DISK MSCP, VC1 is TAPE MSCP, VC2 is DUP and
;	VC255 (low order bits both on) so that VC255 maps to VC3
	EXTZV	#0,#2,-			; Low order 2 bits select connection.
		UDAB$B_CONID(R0),R3	;  R3 = connection ID of message.
	MOVL	PDT$L_PU_CDTARY(R4)[R3],R3; R3 => CDT.

	EXTZV	#UDAB$V_CREDITS,-	; Extract credits returned by message.
		#UDAB$S_CREDITS,-
		UDAB$B_CREDTYPE(R0),R1
	ADDW	R1,CDT$W_SEND(R3)	; Add in new credits.

	MOVAB	UDAB$T_TEXT(R0),R2	; R2 => application area of message.
	MOVZWL	UDAB$W_MSG_LEN(R0),R1	; Pickup length of datagram or message.
	MOVQ	R3,-(SP)		; Save R3=>CDT and R4=>PDT before
					;  dispatching.
	EXTZV	#UDAB$V_MSGTYPE,-	; Extract type of message.
		#UDAB$S_MSGTYPE,-
		UDAB$B_CREDTYPE(R0),R5
	ASSUME	UDA$K_SEQMSGTYP	EQ	0
	BNEQ	90$			; NEQ means NOT sequenced message.
	JSB	@CDT$L_MSGINPUT(R3)	; Call sequenced message handler
					;  passing R2 => message text.
85$:
	MOVQ	(SP)+,R3		; Restore R3=>CDT and R4=>PDT after
					;  dispatching.
87$:
	TSTW	CDT$W_SEND(R3)		; See if we are positive here.
	BLEQ	89$			; LEQ means no more credits left.
	$RESUME_FP	-		; Resume anyone waiting for credits
		@CDT$L_CRWAITQFL(R3),-
		QEMPTY=89$		; Where to go if no waiters.
	BRB	87$			; Go back and try to resume more.
89$:
	BRW	30$			; Go back to test for more responses.
90$:
	CMPL	#UDA$K_DGTYPE,R5	; See if Datagram message.
	BNEQ	100$			; NEQ means test for something else.
	JSB	@CDT$L_DGINPUT(R3)	; Call datagram handler passing
					;  R2 => datagram, with R1 = length.
	BRB	85$			; Go back to test for more responses.
100$:
	CMPL	#UDA$K_CREDTYPE,R5	; See if CREDIT message.
	BNEQ	110$			; NEQ means test for something else.
	BSBW	NULL_MSG_INPUT		; Call Null Message handler to dispose
					;  of and recycle buffer.
	BRB	85$			; Go back to test for more responses.
110$:
	CMPL	#UDA$K_MAINTTYPE,R5	; See if MAINTENANCE message.
	BNEQ	120$			; NEQ means test for something else.
	EXTZV	#UDAB$V_CREDITS,-	; The Credit Field of Maintenance
		#UDAB$S_CREDITS,-	;  messages  is to be ignored. So we
		UDAB$B_CREDTYPE(R0),R0	;  again extract credits field and
	SUBW	R0,CDT$W_SEND(R3)	; Subtract out credits added in above.

	BSBW	NULL_DG_INPUT		; Call Null Datagram handler to log
					;  message and then recycle buffer.
	BRB	85$			; Go back to test for more responses.
120$:
	BUG_CHECK	UDAPORT,FATAL

ENABLE_RESPONSE_CODE:			; If we enable tracing, the driver will
					;  dynamically patch location
					;  ENABLE_RESPONSE_START to BRW here.
	BSBW	TRACE_RESPONSE		; Copy response buffer to trace table.

	REMQUE	@PDT$L_PU_FQFL(R4),R2	; R2 => free buffer.
	BRW	ENABLE_RESPONSE_END	; Branch back to normal stream.

ENABLE_RESPONSE_OFFSET=ENABLE_RESPONSE_CODE-ENABLE_RESPONSE_START-3
	.dsabl	lsb
	.PAGE
	.SBTTL	+	PU$SA_POLL

;+
; Routine periodically called by CRB wakeup mechanism to see if the SA register
; indicates that this port has had an uncorrectable error.  If so the port is
;  re-initialized in order to bring it back.
;
; Inputs:
;	R3 => CRB.
;
; Outputs:
;	All registers, R0-R5 are modified.

PU$SA_POLL:

	MOVL	CRB$L_AUXSTRUC(R3),R4	; R4 => PDT.
	MOVL	PDT$L_UCB0(R4),R5	; R5 => UCB.
	MOVL	PDT$L_PU_CSR(R4),R0	; R0 => Port CSR.
	MOVW	UDASA(R0),-		; Retrieve SA register
		UCB$W_UDASA(R5)		;  and check for error.
	BLSS	10$			; LSS means YES, error.

	ADDL3	#SA_POLL_INTVAL,-	; Here we had no error, so we simply
		G^EXE$GL_ABSTIM,-	;  re-establish SA polling interval.
		CRB$L_DUETIME(R3)
	MOVAB	PU$SA_POLL,-		; And re-establish wakeup routine.
		CRB$L_TOUTROUT(R3)
	RSB				; And simply return to caller.
10$:					; Here we had an SA error.
	SETIPL	#IPL$_SCS		; Lower IPL for processing.
	MOVW	#UDASA_ATTNCODE,-	; Indicate what kind of errorlog
		UCB$W_ATTNCODE(R5)	;  record we are about to create.
	JSB	G^ERL$DEVICEATTN	; Call to create error log record of SA
					;  error.
	CLRW	UCB$W_UDASA(R5)		; Clear so that we do not report error
					;  redundantly.
	BRW	POST_POWER_FORK		; Branch to begin re-init of port.

PU$END:
	.END
