MODULE DBGENCDEC (IDENT = 'V04-000') =
BEGIN

!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************

!++									       !					      A001
!									       !					      A001
!	Original Author:  John Francis					       !					      A001
!									       !					      A001
!	Modification history:						       !					      A001
!									       !					      A001
!	001	Walter Carrell III, 3-Jun-83
!		ASHP thought it had only 5 arguments. See the comment for
!		the MACRO Opcode_list for a more complete explination.
!
!	002	Walter Carrell III, 08-Jun-83
!		The outside world expects DBG$OPCODE_INDEX to return an index
!		into DBG$Opcode_Kind_Table.  Within DBGENCDEC DBG$OPCODE_INDEX
!		was expected to return an index into DBG$Opcode_Name_Table.
!		DBG$OPCODE_INDEX originally returned an index into
!		DBG$Opcode_Name_Table.  This edit changes that.  The place
!		where DBG$OPCODE_INDEX was called within DBGENCDEC have been
!		changed to call Opcode_Name_Index, a local routine which
!		is the original DBG$OPCODE_INDEX with some fixed to make
!		it work correctly.  A new DBG$OPCODE_INDEX was written to
!		return an index into DBG$Opcode_Kind_table.
!
!	003	Walter Carrell III, 09-Jun-83
!		1. CVTTP was out of order in the Mnemonic table.
!		2. Allow ^Y out of the printing of destinations of a CASE list.
!		3. The limit of CASE statements was always being read as a LONG
!		   instead of in the appropriate type.
!		4. XFC and BUGx had a bad table entrys.
!
!	004	Walter Carrell III, 13-Jun-83
!		All the 2 byte opcode instructions had FE instead of FD in the
!		table for the first byte of the opcode.
!
!	005	Walter Carrell III, 20-Jun-83
!		1. ^S and ^I were not allowed
!		2. Addr-exprs were not allowed in any context other that
!		    branch displacements
!		3. (Rn)[Rn] where Rn is the same for both was not caught
!		4. Choose displacement sizes instead of defaulting to Byte.
!		5. Allow SP in indexed mode, [SP]
!		6. Correct the CASE offset address calculation
!		7. Correct the context of ASHP
!		8. Make DEP/INSTR for I^# work
!
!	006	Walter Carrell III, 11-Jul-83
!		Fix Parse_Register so it doesn't use Parse_Expression
!		Parse_Expression cannot be used because a scope may
!		not be active the a DEP/INSTR is issued and therefore
!		Rn is thought to be a symbol outside the active scope.
!
!	007	Walter Carrell III, 08-Aug-83
!		Enhance error reporting of instruction Encoding
!
!	008	Walter Carrell III, 20-Sep-83
!		Fix instruction encoding to allow quad and octaword literals
!
!--									       !					      A001

REQUIRE 'SRC$:DBGPROLOG.REQ';

FORWARD ROUTINE
!
! Global Routines
!
    DBG$Ins_Decode,		    ! Decode Single Instruction
    DBG$Ins_Encode,		    ! Encode Single instruction
    DBG$Opcode_Index,		    ! Convert Mnemonic to kind table index     ! Changed to return Kind table index	      M002
									       !instead of name table index.
!
! Local Routines
!
    Opcode_Name_Index,		    ! Convert Mnemonic to name table index     !					      A002
    Fetch_Instruction	: NOVALUE,  ! Fetch bytes from instrction stream
    Fetch_Operand	: NOVALUE,  ! Fetch (and optionally print) an operand
    Print_Address	: NOVALUE,  ! Print operand address
    Print_Operand	: NOVALUE,  ! Print operand value
    Parse_Operand	: NOVALUE,  ! Parse one instruction operand
    Parse_Expression,		    ! Parse an operand (address or value)
    Parse_Register,		    ! Parse a register name
    Check_Register,		    ! See if address describes a register
    Store_Operand	: NOVALUE,  ! Store bytes in output stream
    Scan_Operand,		    ! Separate one operand string
    Skip_Leading_Blanks : NOVALUE;  ! Skip over leading spaces and/or tabs

EXTERNAL
    DBG$GB_RADIX: VECTOR[3, BYTE];	! Radix settings


EXTERNAL ROUTINE
    DBG$CONV_TEXT_VALUE,						       !					     A008
    DBG$COVER_DX_DX,							       !					     A005
    DBG$Print			: NOVALUE,
    DBG$Print_Value		: NOVALUE,
    DBG$Print_Identifier_PC	: NOVALUE,
    DBG$NewLine			: NOVALUE,
    DBG$Pop_Tempmem		: NOVALUE,
    DBG$Push_Tempmem,
    DBG$Is_It_Entry,
    DBG$Make_Val_Desc,
    DBG$Nparse_Address,
    DBG$Nparse_Expression,
    DBG$Prim_to_Val;

LITERAL
    simple_0_operand	= %X'00',
    simple_1_operand	= %X'01',
    simple_2_operand	= %X'02',
    simple_3_operand	= %X'03',
    branch_0_operand    = %X'04',
    branch_1_operand	= %X'05',
    branch_2_operand	= %X'06',
    branch_3_operand	= %X'07',
    convert_datatype	= %X'08',
    evaluate_address	= %X'08',
    simple_bit_field	= %X'08',
    routine_dispatch	= %X'08',
    locate_character	= %X'08',
    polynomial_value	= %X'08',
    probe_for_access	= %X'08',
    trailing_operand	= %X'09',
    string_3_operand	= %X'0A',
    string_4_operand	= %X'0B',
    string_5_operand	= %X'0C',
    string_6_operand	= %X'0D',

    complex_SHIFT	= %X'10',
    complex_CASE	= %X'11',
    complex_EDIV	= %X'12',
    complex_EMOD	= %X'13',
    complex_EMUL	= %X'14',
    complex_INDEX	= %X'15',
    complex_CRC		= %X'16',
    complex_ASHP	= %X'17',

    maximum_state	= %X'17',

    context_b		= %X'00',
    context_w		= %X'01',
    context_l		= %X'02',
    context_q		= %X'03',
    context_o		= %X'04',
    context_f		= %X'05',
    context_d		= %X'06',
    context_g		= %X'07',
    context_h		= %X'08',
    context_bu		= %X'09',
    context_wu		= %X'0A',
    context_t		= %X'0B',	! size.wu	base.b
    context_p		= %X'0C',	! size.wu	base.b
    context_m		= %X'0D',	!  pos.l	size.b		base.b
    context_v		= %X'0E';	!  pos.l	base.b

!++									       !					      A001
!	The following table is used to build 2 data structures:		       !					      A001
!									       !					      A001
!	DBG$Opcode_Name_Table - An alphabetical table of the Opcode names      !					      A001
!	DBG$Opcode_Kind_table - A back translation table to get from an	       !					      A001
!				Op code to the Name.			       !					      A001
!									       !					      A001
!	Opcode_entry is a macro the is defined twice to pass over 	       !					      A001
!	Opcode_List twice to buld the two tables.			       !					      A001
!									       !					      A001
!	The arguments have the following definition:			       !					      A001
!									       !					      A001
!	1. The first argument is a flag that indicates that the entry 	       !					      A001
!	   has a duplicate Opcode and that it should be ignored in	       !					      A001
!	   DBG$Opcode_Kind_Table.					       !					      A001
!	2. The second argument is the MNEMONIC.  It must be 6 characters.      !					      A001
!	3. The third argument is the Opcode.				       !					      A001
!	4. The fourth argument is the state to start with in the finite        !					      A001
!	   state machine						       !					      A001
!	5. The fifth and optional sixth arguments are context flags.  	       !					      A001
!	   Their nature is not fully understood.			       !					      A001
!									       !					      A001
!	Note that the table must be in alphabetical order by MNEMONIC.	       !					      A001
!	A binary search is used to find table entries. 			       !					      A001
!									       !					      A001
!	The editorial starts here.					       !					      A001
!									       !					      A001
!	The table is more complex than necessary for the simple matter	       !					      A001
!	of decoding for output and encoding instructions for deposit.	       !					      A001
!	The number of arguments would have been sufficient, instead of	       !					      A001
!	the last 3 arguments. The first byte of an argument tells you	       !					      A001
!	what you need to know about the rest of the argument. 		       !					      A001
!									       !					      A001
!	The intent was apparently to have enough information in the	       !					      A001
!	table to allow the decoding of the instructions for interperting       !					      A001
!	watch points in the stack and registers.  The information in the       !					      A001
!	table is not sufficient for that purpose.			       !					      A001
!									       !					      A001
!--									       !					      A001
MACRO Opcode_List =
	Opcode_Entry(1,'ACBB  ',%X'9D'  ,branch_3_operand,context_b,context_w),
	Opcode_Entry(1,'ACBD  ',%X'6F'  ,branch_3_operand,context_d,context_w),
	Opcode_Entry(1,'ACBF  ',%X'4F'  ,branch_3_operand,context_f,context_w),
	Opcode_Entry(1,'ACBG  ',%X'4FFD',branch_3_operand,context_g,context_w),!					      M004
	Opcode_Entry(1,'ACBH  ',%X'6FFD',branch_3_operand,context_h,context_w),!					      M004
	Opcode_Entry(1,'ACBL  ',%X'F1'  ,branch_3_operand,context_l,context_w),
	Opcode_Entry(1,'ACBW  ',%X'3D'  ,branch_3_operand,context_w,context_w),
	Opcode_Entry(1,'ADAWI ',%X'58'  ,simple_2_operand,context_w),
	Opcode_Entry(1,'ADDB2 ',%X'80'  ,simple_2_operand,context_b),
	Opcode_Entry(1,'ADDB3 ',%X'81'  ,simple_3_operand,context_b),
	Opcode_Entry(1,'ADDD2 ',%X'60'  ,simple_2_operand,context_d),
	Opcode_Entry(1,'ADDD3 ',%X'61'  ,simple_3_operand,context_d),
	Opcode_Entry(1,'ADDF2 ',%X'40'  ,simple_2_operand,context_f),
	Opcode_Entry(1,'ADDF3 ',%X'41'  ,simple_3_operand,context_f),
	Opcode_Entry(1,'ADDG2 ',%X'40FD',simple_2_operand,context_g),	       !					      M004
	Opcode_Entry(1,'ADDG3 ',%X'41FD',simple_3_operand,context_g),	       !					      M004
	Opcode_Entry(1,'ADDH2 ',%X'60FD',simple_2_operand,context_h),	       !					      M004
	Opcode_Entry(1,'ADDH3 ',%X'61FD',simple_3_operand,context_h),	       !					      M004
	Opcode_Entry(1,'ADDL2 ',%X'C0'  ,simple_2_operand,context_l),
	Opcode_Entry(1,'ADDL3 ',%X'C1'  ,simple_3_operand,context_l),
	Opcode_Entry(1,'ADDP4 ',%X'20'  ,simple_2_operand,context_p),
	Opcode_Entry(1,'ADDP6 ',%X'21'  ,simple_3_operand,context_p),
	Opcode_Entry(1,'ADDW2 ',%X'A0'  ,simple_2_operand,context_w),
	Opcode_Entry(1,'ADDW3 ',%X'A1'  ,simple_3_operand,context_w),
	Opcode_Entry(1,'ADWC  ',%X'D8'  ,simple_2_operand,context_l),
	Opcode_Entry(1,'AOBLEQ',%X'F3'  ,branch_2_operand,context_l,context_b),
	Opcode_Entry(1,'AOBLSS',%X'F2'  ,branch_2_operand,context_l,context_b),
	Opcode_Entry(1,'ASHL  ',%X'78'  ,complex_SHIFT   ,context_l),
	Opcode_Entry(1,'ASHP  ',%X'F8'  ,complex_ASHP,context_b,context_p),	! simple_3_operand to complex_ASHP	  M001 M005
	Opcode_Entry(1,'ASHQ  ',%X'79'  ,complex_SHIFT   ,context_q),
	Opcode_Entry(1,'BBC   ',%X'E1'  ,branch_1_operand,context_v,context_b),
	Opcode_Entry(1,'BBCC  ',%X'E5'  ,branch_1_operand,context_v,context_b),
	Opcode_Entry(1,'BBCCI ',%X'E7'  ,branch_1_operand,context_v,context_b),
	Opcode_Entry(1,'BBCS  ',%X'E3'  ,branch_1_operand,context_v,context_b),
	Opcode_Entry(1,'BBS   ',%X'E0'  ,branch_1_operand,context_v,context_b),
	Opcode_Entry(1,'BBSC  ',%X'E4'  ,branch_1_operand,context_v,context_b),
	Opcode_Entry(1,'BBSS  ',%X'E2'  ,branch_1_operand,context_v,context_b),
	Opcode_Entry(1,'BBSSI ',%X'E6'  ,branch_1_operand,context_v,context_b),
	Opcode_Entry(0,'BCC   ',%X'1E'  ,branch_0_operand,context_b),
	Opcode_Entry(0,'BCS   ',%X'1F'  ,branch_0_operand,context_b),
	Opcode_Entry(1,'BEQL  ',%X'13'  ,branch_0_operand,context_b),
	Opcode_Entry(0,'BEQLU ',%X'13'  ,branch_0_operand,context_b),
	Opcode_Entry(1,'BGEQ  ',%X'18'  ,branch_0_operand,context_b),
	Opcode_Entry(1,'BGEQU ',%X'1E'  ,branch_0_operand,context_b),
	Opcode_Entry(1,'BGTR  ',%X'14'  ,branch_0_operand,context_b),
	Opcode_Entry(1,'BGTRU ',%X'1A'  ,branch_0_operand,context_b),

	Opcode_Entry(1,'BICB2 ',%X'8A'  ,simple_2_operand,context_b),
	Opcode_Entry(1,'BICB3 ',%X'8B'  ,simple_3_operand,context_b),
	Opcode_Entry(1,'BICL2 ',%X'CA'  ,simple_2_operand,context_l),
	Opcode_Entry(1,'BICL3 ',%X'CB'  ,simple_3_operand,context_l),
	Opcode_Entry(1,'BICPSW',%X'B9'  ,simple_1_operand,context_w),
	Opcode_Entry(1,'BICW2 ',%X'AA'  ,simple_2_operand,context_w),
	Opcode_Entry(1,'BICW3 ',%X'AB'  ,simple_3_operand,context_w),
	Opcode_Entry(1,'BISB2 ',%X'88'  ,simple_2_operand,context_b),
	Opcode_Entry(1,'BISB3 ',%X'89'  ,simple_3_operand,context_b),
	Opcode_Entry(1,'BISL2 ',%X'C8'  ,simple_2_operand,context_l),
	Opcode_Entry(1,'BISL3 ',%X'C9'  ,simple_3_operand,context_l),
	Opcode_Entry(1,'BISPSW',%X'B8'  ,simple_1_operand,context_w),
	Opcode_Entry(1,'BISW2 ',%X'A8'  ,simple_2_operand,context_w),
	Opcode_Entry(1,'BISW3 ',%X'A9'  ,simple_3_operand,context_w),
	Opcode_Entry(1,'BITB  ',%X'93'  ,simple_2_operand,context_b),
	Opcode_Entry(1,'BITL  ',%X'D3'  ,simple_2_operand,context_l),
	Opcode_Entry(1,'BITW  ',%X'B3'  ,simple_2_operand,context_w),
	Opcode_Entry(1,'BLBC  ',%X'E9'  ,branch_1_operand,context_l,context_b),
	Opcode_Entry(1,'BLBS  ',%X'E8'  ,branch_1_operand,context_l,context_b),
	Opcode_Entry(1,'BLEQ  ',%X'15'  ,branch_0_operand,context_b),
	Opcode_Entry(1,'BLEQU ',%X'1B'  ,branch_0_operand,context_b),
	Opcode_Entry(1,'BLSS  ',%X'19'  ,branch_0_operand,context_b),
	Opcode_Entry(1,'BLSSU ',%X'1F'  ,branch_0_operand,context_b),
	Opcode_Entry(1,'BNEQ  ',%X'12'  ,branch_0_operand,context_b),
	Opcode_Entry(0,'BNEQU ',%X'12'  ,branch_0_operand,context_b),
	Opcode_Entry(1,'BPT   ',%X'03'  ,simple_0_operand),
	Opcode_Entry(1,'BRB   ',%X'11'  ,branch_0_operand,context_b),
	Opcode_Entry(1,'BRW   ',%X'31'  ,branch_0_operand,context_w),
	Opcode_Entry(1,'BSBB  ',%X'10'  ,branch_0_operand,context_b),
	Opcode_Entry(1,'BSBW  ',%X'30'  ,branch_0_operand,context_w),
	Opcode_Entry(1,'BUGL  ',%X'FDFF',simple_0_operand),
	Opcode_Entry(1,'BUGW  ',%X'FEFF',simple_0_operand),
	Opcode_Entry(1,'BVC   ',%X'1C'  ,branch_0_operand,context_b),
	Opcode_Entry(1,'BVS   ',%X'1D'  ,branch_0_operand,context_b),
	Opcode_Entry(1,'CALLG ',%X'FA'  ,routine_dispatch,context_b,context_b),
	Opcode_Entry(1,'CALLS ',%X'FB'  ,routine_dispatch,context_l,context_b),
	Opcode_Entry(1,'CASEB ',%X'8F'  ,complex_CASE    ,context_b),
	Opcode_Entry(1,'CASEL ',%X'CF'  ,complex_CASE    ,context_l),
	Opcode_Entry(1,'CASEW ',%X'AF'  ,complex_CASE    ,context_w),
	Opcode_Entry(1,'CHME  ',%X'BD'  ,simple_1_operand,context_w),
	Opcode_Entry(1,'CHMK  ',%X'BC'  ,simple_1_operand,context_w),
	Opcode_Entry(1,'CHMS  ',%X'BE'  ,simple_1_operand,context_w),
	Opcode_Entry(1,'CHMU  ',%X'BF'  ,simple_1_operand,context_w),
	Opcode_Entry(1,'CLRB  ',%X'94'  ,simple_1_operand,context_b),
	Opcode_Entry(0,'CLRD  ',%X'7C'  ,simple_1_operand,context_d),
	Opcode_Entry(0,'CLRF  ',%X'D4'  ,simple_1_operand,context_f),
	Opcode_Entry(0,'CLRG  ',%X'7C'  ,simple_1_operand,context_g),
	Opcode_Entry(0,'CLRH  ',%X'7CFD',simple_1_operand,context_h),	       !					      M004
	Opcode_Entry(1,'CLRL  ',%X'D4'  ,simple_1_operand,context_l),
	Opcode_Entry(1,'CLRO  ',%X'7CFD',simple_1_operand,context_o),	       !					      M004
	Opcode_Entry(1,'CLRQ  ',%X'7C'  ,simple_1_operand,context_q),
	Opcode_Entry(1,'CLRW  ',%X'B4'  ,simple_1_operand,context_w),

	Opcode_Entry(1,'CMPB  ',%X'91'  ,simple_2_operand,context_b),
	Opcode_Entry(1,'CMPC3 ',%X'29'  ,string_3_operand,context_t,context_b),
	Opcode_Entry(1,'CMPC5 ',%X'2D'  ,string_5_operand,context_t,context_t),
	Opcode_Entry(1,'CMPD  ',%X'71'  ,simple_2_operand,context_d),
	Opcode_Entry(1,'CMPF  ',%X'51'  ,simple_2_operand,context_f),
	Opcode_Entry(1,'CMPG  ',%X'51FD',simple_2_operand,context_g),	       !					      M004
	Opcode_Entry(1,'CMPH  ',%X'71FD',simple_2_operand,context_h),	       !					      M004
	Opcode_Entry(1,'CMPL  ',%X'D1'  ,simple_2_operand,context_l),
	Opcode_Entry(1,'CMPP3 ',%X'35'  ,string_3_operand,context_p,context_b),
	Opcode_Entry(1,'CMPP4 ',%X'37'  ,simple_2_operand,context_p),
	Opcode_Entry(1,'CMPV  ',%X'EC'  ,simple_bit_field,context_m,context_l),
	Opcode_Entry(1,'CMPW  ',%X'B1'  ,simple_2_operand,context_w),
	Opcode_Entry(1,'CMPZV ',%X'ED'  ,simple_bit_field,context_m,context_l),
	Opcode_Entry(1,'CRC   ',%X'0B'  ,complex_CRC),
	Opcode_Entry(1,'CVTBD ',%X'6C'  ,convert_datatype,context_b,context_d),
	Opcode_Entry(1,'CVTBF ',%X'4C'  ,convert_datatype,context_b,context_f),
	Opcode_Entry(1,'CVTBG ',%X'4CFD',convert_datatype,context_b,context_g),!					      M004
	Opcode_Entry(1,'CVTBH ',%X'6CFD',convert_datatype,context_b,context_h),!					      M004
	Opcode_Entry(1,'CVTBL ',%X'98'  ,convert_datatype,context_b,context_l),
	Opcode_Entry(1,'CVTBW ',%X'99'  ,convert_datatype,context_b,context_w),
	Opcode_Entry(1,'CVTDB ',%X'68'  ,convert_datatype,context_d,context_b),
	Opcode_Entry(1,'CVTDF ',%X'76'  ,convert_datatype,context_d,context_f),
	Opcode_Entry(1,'CVTDH ',%X'32FD',convert_datatype,context_d,context_h),!					      M004
	Opcode_Entry(1,'CVTDL ',%X'6A'  ,convert_datatype,context_d,context_l),
	Opcode_Entry(1,'CVTDW ',%X'69'  ,convert_datatype,context_d,context_w),
	Opcode_Entry(1,'CVTFB ',%X'48'  ,convert_datatype,context_f,context_b),
	Opcode_Entry(1,'CVTFD ',%X'56'  ,convert_datatype,context_f,context_d),
	Opcode_Entry(1,'CVTFG ',%X'99FD',convert_datatype,context_f,context_g),!					      M004
	Opcode_Entry(1,'CVTFH ',%X'98FD',convert_datatype,context_f,context_h),!					      M004
	Opcode_Entry(1,'CVTFL ',%X'4A'  ,convert_datatype,context_f,context_l),
	Opcode_Entry(1,'CVTFW ',%X'49'  ,convert_datatype,context_f,context_w),
	Opcode_Entry(1,'CVTGB ',%X'48FD',convert_datatype,context_g,context_b),!					      M004
	Opcode_Entry(1,'CVTGF ',%X'33FD',convert_datatype,context_g,context_f),!					      M004
	Opcode_Entry(1,'CVTGH ',%X'56FD',convert_datatype,context_g,context_h),!					      M004
	Opcode_Entry(1,'CVTGL ',%X'4AFD',convert_datatype,context_g,context_l),!					      M004
	Opcode_Entry(1,'CVTGW ',%X'49FD',convert_datatype,context_g,context_w),!					      M004
	Opcode_Entry(1,'CVTHB ',%X'68FD',convert_datatype,context_h,context_b),!					      M004
	Opcode_Entry(1,'CVTHD ',%X'F7FD',convert_datatype,context_h,context_d),!					      M004
	Opcode_Entry(1,'CVTHF ',%X'F6FD',convert_datatype,context_h,context_f),!					      M004
	Opcode_Entry(1,'CVTHG ',%X'76FD',convert_datatype,context_h,context_g),!					      M004
	Opcode_Entry(1,'CVTHL ',%X'6AFD',convert_datatype,context_h,context_l),!					      M004
	Opcode_Entry(1,'CVTHW ',%X'69FD',convert_datatype,context_h,context_w),!					      M004
	Opcode_Entry(1,'CVTLB ',%X'F6'  ,convert_datatype,context_l,context_b),
	Opcode_Entry(1,'CVTLD ',%X'6E'  ,convert_datatype,context_l,context_d),
	Opcode_Entry(1,'CVTLF ',%X'4E'  ,convert_datatype,context_l,context_f),
	Opcode_Entry(1,'CVTLG ',%X'4EFD',convert_datatype,context_l,context_g),!					      M004
	Opcode_Entry(1,'CVTLH ',%X'6EFD',convert_datatype,context_l,context_h),!					      M004
	Opcode_Entry(1,'CVTLP ',%X'F9'  ,convert_datatype,context_l,context_p),
	Opcode_Entry(1,'CVTLW ',%X'F7'  ,convert_datatype,context_l,context_w),

	Opcode_Entry(1,'CVTPL ',%X'36'  ,convert_datatype,context_p,context_l),
	Opcode_Entry(1,'CVTPS ',%X'08'  ,convert_datatype,context_p,context_t),
	Opcode_Entry(1,'CVTPT ',%X'24'  ,string_5_operand,context_p,context_t),
	Opcode_Entry(1,'CVTRDL',%X'6B'  ,convert_datatype,context_d,context_l),
	Opcode_Entry(1,'CVTRFL',%X'4B'  ,convert_datatype,context_f,context_l),
	Opcode_Entry(1,'CVTRGL',%X'4BFD',convert_datatype,context_g,context_l),!					      M004
	Opcode_Entry(1,'CVTRHL',%X'6BFD',convert_datatype,context_h,context_l),!					      M004
	Opcode_Entry(1,'CVTSP ',%X'09'  ,convert_datatype,context_t,context_p),
	Opcode_Entry(1,'CVTTP ',%X'26'  ,string_5_operand,context_t,context_p),!					      M003
	Opcode_Entry(1,'CVTWB ',%X'33'  ,convert_datatype,context_w,context_b),
	Opcode_Entry(1,'CVTWD ',%X'6D'  ,convert_datatype,context_w,context_d),
	Opcode_Entry(1,'CVTWF ',%X'4D'  ,convert_datatype,context_w,context_f),
	Opcode_Entry(1,'CVTWG ',%X'4DFD',convert_datatype,context_w,context_g),!					      M004
	Opcode_Entry(1,'CVTWH ',%X'6DFD',convert_datatype,context_w,context_h),!					      M004
	Opcode_Entry(1,'CVTWL ',%X'32'  ,convert_datatype,context_w,context_l),
	Opcode_Entry(1,'DECB  ',%X'97'  ,simple_1_operand,context_b),
	Opcode_Entry(1,'DECL  ',%X'D7'  ,simple_1_operand,context_l),
	Opcode_Entry(1,'DECW  ',%X'B7'  ,simple_1_operand,context_w),
	Opcode_Entry(1,'DIVB2 ',%X'86'  ,simple_2_operand,context_b),
	Opcode_Entry(1,'DIVB3 ',%X'87'  ,simple_3_operand,context_b),
	Opcode_Entry(1,'DIVD2 ',%X'66'  ,simple_2_operand,context_d),
	Opcode_Entry(1,'DIVD3 ',%X'67'  ,simple_3_operand,context_d),
	Opcode_Entry(1,'DIVF2 ',%X'46'  ,simple_2_operand,context_f),
	Opcode_Entry(1,'DIVF3 ',%X'47'  ,simple_3_operand,context_f),
	Opcode_Entry(1,'DIVG2 ',%X'46FD',simple_2_operand,context_g),	       !					      M004
	Opcode_Entry(1,'DIVG3 ',%X'47FD',simple_3_operand,context_g),	       !					      M004
	Opcode_Entry(1,'DIVH2 ',%X'66FD',simple_2_operand,context_h),	       !					      M004
	Opcode_Entry(1,'DIVH3 ',%X'67FD',simple_3_operand,context_h),	       !					      M004
	Opcode_Entry(1,'DIVL2 ',%X'C6'  ,simple_2_operand,context_l),
	Opcode_Entry(1,'DIVL3 ',%X'C7'  ,simple_3_operand,context_l),
	Opcode_Entry(1,'DIVP  ',%X'27'  ,simple_3_operand,context_p),
	Opcode_Entry(1,'DIVW2 ',%X'A6'  ,simple_2_operand,context_w),
	Opcode_Entry(1,'DIVW3 ',%X'A7'  ,simple_3_operand,context_w),
	Opcode_Entry(1,'EDITPC',%X'38'  ,string_4_operand,context_p,context_b),
	Opcode_Entry(1,'EDIV  ',%X'7B'  ,complex_EDIV),
	Opcode_Entry(1,'EMODD ',%X'74'  ,complex_EMOD   ,context_bu,context_d),
	Opcode_Entry(1,'EMODF ',%X'54'  ,complex_EMOD   ,context_bu,context_f),
	Opcode_Entry(1,'EMODG ',%X'54FD',complex_EMOD   ,context_wu,context_g),!					      M004
	Opcode_Entry(1,'EMODH ',%X'74FD',complex_EMOD   ,context_wu,context_h),!					      M004
	Opcode_Entry(1,'EMUL  ',%X'7A'  ,complex_EMUL),
	Opcode_Entry(1,'EXTV  ',%X'EE'  ,simple_bit_field,context_m,context_l),
	Opcode_Entry(1,'EXTZV ',%X'EF'  ,simple_bit_field,context_m,context_l),
	Opcode_Entry(1,'FFC   ',%X'EB'  ,simple_bit_field,context_m,context_l),
	Opcode_Entry(1,'FFS   ',%X'EA'  ,simple_bit_field,context_m,context_l),
	Opcode_Entry(1,'HALT  ',%X'00'  ,simple_0_operand),
	Opcode_Entry(1,'INCB  ',%X'96'  ,simple_1_operand,context_b),
	Opcode_Entry(1,'INCL  ',%X'D6'  ,simple_1_operand,context_l),
	Opcode_Entry(1,'INCW  ',%X'B6'  ,simple_1_operand,context_w),
	Opcode_Entry(1,'INDEX ',%X'0A'  ,complex_INDEX),

	Opcode_Entry(1,'INSQHI',%X'5C'  ,simple_2_operand,context_b),
	Opcode_Entry(1,'INSQTI',%X'5D'  ,simple_2_operand,context_b),
	Opcode_Entry(1,'INSQUE',%X'0E'  ,simple_2_operand,context_b),
	Opcode_Entry(1,'INSV  ',%X'F0'  ,simple_bit_field,context_l,context_m),
	Opcode_Entry(1,'JMP   ',%X'17'  ,simple_1_operand,context_b),
	Opcode_Entry(1,'JSB   ',%X'16'  ,simple_1_operand,context_b),
	Opcode_Entry(1,'LDPCTX',%X'06'  ,simple_0_operand),
	Opcode_Entry(1,'LOCC  ',%X'3A'  ,locate_character,context_b,context_t),
	Opcode_Entry(1,'MATCHC',%X'39'  ,simple_2_operand,context_t),
	Opcode_Entry(1,'MCOMB ',%X'92'  ,simple_2_operand,context_b),
	Opcode_Entry(1,'MCOML ',%X'D2'  ,simple_2_operand,context_l),
	Opcode_Entry(1,'MCOMW ',%X'B2'  ,simple_2_operand,context_w),
	Opcode_Entry(1,'MFPR  ',%X'DB'  ,simple_2_operand,context_l),
	Opcode_Entry(1,'MNEGB ',%X'8E'  ,simple_2_operand,context_b),
	Opcode_Entry(1,'MNEGD ',%X'72'  ,simple_2_operand,context_d),
	Opcode_Entry(1,'MNEGF ',%X'52'  ,simple_2_operand,context_f),
	Opcode_Entry(1,'MNEGG ',%X'52FD',simple_2_operand,context_g),	       !					      M004
	Opcode_Entry(1,'MNEGH ',%X'72FD',simple_2_operand,context_h),	       !					      M004
	Opcode_Entry(1,'MNEGL ',%X'CE'  ,simple_2_operand,context_l),
	Opcode_Entry(1,'MNEGW ',%X'AE'  ,simple_2_operand,context_w),
	Opcode_Entry(1,'MOVAB ',%X'9E'  ,evaluate_address,context_b,context_l),
	Opcode_Entry(0,'MOVAD ',%X'7E'  ,evaluate_address,context_d,context_l),
	Opcode_Entry(0,'MOVAF ',%X'DE'  ,evaluate_address,context_f,context_l),
	Opcode_Entry(0,'MOVAG ',%X'7E'  ,evaluate_address,context_g,context_l),
	Opcode_Entry(0,'MOVAH ',%X'7EFD',evaluate_address,context_h,context_l),!					      M004
	Opcode_Entry(1,'MOVAL ',%X'DE'  ,evaluate_address,context_l,context_l),
	Opcode_Entry(1,'MOVAO ',%X'7EFD',evaluate_address,context_o,context_l),!					      M004
	Opcode_Entry(1,'MOVAQ ',%X'7E'  ,evaluate_address,context_q,context_l),
	Opcode_Entry(1,'MOVAW ',%X'3E'  ,evaluate_address,context_w,context_l),
	Opcode_Entry(1,'MOVB  ',%X'90'  ,simple_2_operand,context_b),
	Opcode_Entry(1,'MOVC3 ',%X'28'  ,string_3_operand,context_t,context_b),
	Opcode_Entry(1,'MOVC5 ',%X'2C'  ,string_5_operand,context_t,context_t),
	Opcode_Entry(1,'MOVD  ',%X'70'  ,simple_2_operand,context_d),
	Opcode_Entry(1,'MOVF  ',%X'50'  ,simple_2_operand,context_f),
	Opcode_Entry(1,'MOVG  ',%X'50FD',simple_2_operand,context_g),	       !					      M004
	Opcode_Entry(1,'MOVH  ',%X'70FD',simple_2_operand,context_h),	       !					      M004
	Opcode_Entry(1,'MOVL  ',%X'D0'  ,simple_2_operand,context_l),
	Opcode_Entry(1,'MOVO  ',%X'7DFD',simple_2_operand,context_o),	       !					      M004
	Opcode_Entry(1,'MOVP  ',%X'34'  ,string_3_operand,context_p,context_b),
	Opcode_Entry(1,'MOVPSL',%X'DC'  ,simple_1_operand,context_l),
	Opcode_Entry(1,'MOVQ  ',%X'7D'  ,simple_2_operand,context_q),
	Opcode_Entry(1,'MOVTC ',%X'2E'  ,string_6_operand,context_t,context_t),
	Opcode_Entry(1,'MOVTUC',%X'2F'  ,string_6_operand,context_t,context_t),
	Opcode_Entry(1,'MOVW  ',%X'B0'  ,simple_2_operand,context_w),
	Opcode_Entry(1,'MOVZBL',%X'9A'  ,convert_datatype,context_b,context_l),
	Opcode_Entry(1,'MOVZBW',%X'9B'  ,convert_datatype,context_b,context_w),
	Opcode_Entry(1,'MOVZWL',%X'3C'  ,convert_datatype,context_w,context_l),
	Opcode_Entry(1,'MTPR  ',%X'DA'  ,simple_2_operand,context_l),

	Opcode_Entry(1,'MULB2 ',%X'84'  ,simple_2_operand,context_b),
	Opcode_Entry(1,'MULB3 ',%X'85'  ,simple_3_operand,context_b),
	Opcode_Entry(1,'MULD2 ',%X'64'  ,simple_2_operand,context_d),
	Opcode_Entry(1,'MULD3 ',%X'65'  ,simple_3_operand,context_d),
	Opcode_Entry(1,'MULF2 ',%X'44'  ,simple_2_operand,context_f),
	Opcode_Entry(1,'MULF3 ',%X'45'  ,simple_3_operand,context_f),
	Opcode_Entry(1,'MULG2 ',%X'44FD',simple_2_operand,context_g),	       !					      M004
	Opcode_Entry(1,'MULG3 ',%X'45FD',simple_3_operand,context_g),	       !					      M004
	Opcode_Entry(1,'MULH2 ',%X'64FD',simple_2_operand,context_h),	       !					      M004
	Opcode_Entry(1,'MULH3 ',%X'65FD',simple_3_operand,context_h),	       !					      M004
	Opcode_Entry(1,'MULL2 ',%X'C4'  ,simple_2_operand,context_l),
	Opcode_Entry(1,'MULL3 ',%X'C5'  ,simple_3_operand,context_l),
	Opcode_Entry(1,'MULP  ',%X'25'  ,simple_3_operand,context_p),
	Opcode_Entry(1,'MULW2 ',%X'A4'  ,simple_2_operand,context_w),
	Opcode_Entry(1,'MULW3 ',%X'A5'  ,simple_3_operand,context_w),
	Opcode_Entry(1,'NOP   ',%X'01'  ,simple_0_operand),
	Opcode_Entry(1,'POLYD ',%X'75'  ,polynomial_value,context_d,context_t),
	Opcode_Entry(1,'POLYF ',%X'55'  ,polynomial_value,context_f,context_t),
	Opcode_Entry(1,'POLYG ',%X'55FD',polynomial_value,context_g,context_t),!					      M004
	Opcode_Entry(1,'POLYH ',%X'75FD',polynomial_value,context_h,context_t),!					      M004
	Opcode_Entry(1,'POPR  ',%X'BA'  ,simple_1_operand,context_w),
	Opcode_Entry(1,'PROBER',%X'0C'  ,probe_for_access,context_b,context_t),
	Opcode_Entry(1,'PROBEW',%X'0D'  ,probe_for_access,context_b,context_t),
	Opcode_Entry(1,'PUSHAB',%X'9F'  ,simple_1_operand,context_b),
	Opcode_Entry(0,'PUSHAD',%X'7F'  ,simple_1_operand,context_d),
	Opcode_Entry(0,'PUSHAF',%X'DF'  ,simple_1_operand,context_f),
	Opcode_Entry(0,'PUSHAG',%X'7F'  ,simple_1_operand,context_g),
	Opcode_Entry(0,'PUSHAH',%X'7FFD',simple_1_operand,context_h),	       !					      M004
	Opcode_Entry(1,'PUSHAL',%X'DF'  ,simple_1_operand,context_l),
	Opcode_Entry(1,'PUSHAO',%X'7FFD',simple_1_operand,context_o),	       !					      M004
	Opcode_Entry(1,'PUSHAQ',%X'7F'  ,simple_1_operand,context_q),
	Opcode_Entry(1,'PUSHAW',%X'3F'  ,simple_1_operand,context_w),
	Opcode_Entry(1,'PUSHL ',%X'DD'  ,simple_1_operand,context_l),
	Opcode_Entry(1,'PUSHR ',%X'BB'  ,simple_1_operand,context_w),
	Opcode_Entry(1,'REI   ',%X'02'  ,simple_0_operand),
	Opcode_Entry(1,'REMQHI',%X'5E'  ,simple_2_operand,context_b),
	Opcode_Entry(1,'REMQTI',%X'5F'  ,simple_2_operand,context_b),
	Opcode_Entry(1,'REMQUE',%X'0F'  ,simple_2_operand,context_b),
	Opcode_Entry(1,'RET   ',%X'04'  ,simple_0_operand),
	Opcode_Entry(1,'ROTL  ',%X'9C'  ,complex_SHIFT   ,context_l),
	Opcode_Entry(1,'RSB   ',%X'05'  ,simple_0_operand),
	Opcode_Entry(1,'SBWC  ',%X'D9'  ,simple_2_operand,context_l),
	Opcode_Entry(1,'SCANC ',%X'2A'  ,string_4_operand,context_t,context_b),
	Opcode_Entry(1,'SKPC  ',%X'3B'  ,locate_character,context_b,context_t),
	Opcode_Entry(1,'SOBGEQ',%X'F4'  ,branch_1_operand,context_l,context_b),
	Opcode_Entry(1,'SOBGTR',%X'F5'  ,branch_1_operand,context_l,context_b),
	Opcode_Entry(1,'SPANC ',%X'2B'  ,string_4_operand,context_t,context_b),

	Opcode_Entry(1,'SUBB2 ',%X'82'  ,simple_2_operand,context_b),
	Opcode_Entry(1,'SUBB3 ',%X'83'  ,simple_3_operand,context_b),
	Opcode_Entry(1,'SUBD2 ',%X'62'  ,simple_2_operand,context_d),
	Opcode_Entry(1,'SUBD3 ',%X'63'  ,simple_3_operand,context_d),
	Opcode_Entry(1,'SUBF2 ',%X'42'  ,simple_2_operand,context_f),
	Opcode_Entry(1,'SUBF3 ',%X'43'  ,simple_3_operand,context_f),
	Opcode_Entry(1,'SUBG2 ',%X'42FD',simple_2_operand,context_g),	       !					      M004
	Opcode_Entry(1,'SUBG3 ',%X'43FD',simple_3_operand,context_g),	       !					      M004
	Opcode_Entry(1,'SUBH2 ',%X'62FD',simple_2_operand,context_h),	       !					      M004
	Opcode_Entry(1,'SUBH3 ',%X'63FD',simple_3_operand,context_h),	       !					      M004
	Opcode_Entry(1,'SUBL2 ',%X'C2'  ,simple_2_operand,context_l),
	Opcode_Entry(1,'SUBL3 ',%X'C3'  ,simple_3_operand,context_l),
	Opcode_Entry(1,'SUBP4 ',%X'22'  ,simple_2_operand,context_p),
	Opcode_Entry(1,'SUBP6 ',%X'23'  ,simple_3_operand,context_p),
	Opcode_Entry(1,'SUBW2 ',%X'A2'  ,simple_2_operand,context_w),
	Opcode_Entry(1,'SUBW3 ',%X'A3'  ,simple_3_operand,context_w),
	Opcode_Entry(1,'SVPCTX',%X'07'  ,simple_0_operand),
	Opcode_Entry(1,'TSTB  ',%X'95'  ,simple_1_operand,context_b),
	Opcode_Entry(1,'TSTD  ',%X'73'  ,simple_1_operand,context_d),
	Opcode_Entry(1,'TSTF  ',%X'53'  ,simple_1_operand,context_f),
	Opcode_Entry(1,'TSTG  ',%X'53FD',simple_1_operand,context_g),	       !					      M004
	Opcode_Entry(1,'TSTH  ',%X'73FD',simple_1_operand,context_h),	       !					      M004
	Opcode_Entry(1,'TSTL  ',%X'D5'  ,simple_1_operand,context_l),
	Opcode_Entry(1,'TSTW  ',%X'B5'  ,simple_1_operand,context_w),
	Opcode_Entry(1,'XFC   ',%X'FC'  ,simple_0_operand),		       !					      M003
	Opcode_Entry(1,'XORB2 ',%X'8C'  ,simple_2_operand,context_b),
	Opcode_Entry(1,'XORB3 ',%X'8D'  ,simple_3_operand,context_b),
	Opcode_Entry(1,'XORL2 ',%X'CC'  ,simple_2_operand,context_l),
	Opcode_Entry(1,'XORL3 ',%X'CD'  ,simple_3_operand,context_l),
	Opcode_Entry(1,'XORW2 ',%X'AC'  ,simple_2_operand,context_w),
	Opcode_Entry(1,'XORW3 ',%X'AD'  ,simple_3_operand,context_w)

%;		! ****   End of definition of MACRO Opcode_List

!++
!									       !					      A001
!	Used in the macro Opcode_List which is used in the following 	       !					      A001
!	GLOBAL BIND to define DBG$Opcode_Name_table			       !					      A001
!									       !					      A001
!--									       !					      A001
MACRO Opcode_Entry(Flag, Name, Code, Kind, Arg1, Arg2) =
	BYTE(%ASCII Name),
	WORD(%IF ((Code) GTRU %X'FF') %THEN (Code) %ELSE (Code)^8 %FI),
	BYTE(Kind),
	BYTE(%IF (%LENGTH LSS 5) %THEN 0 %ELSE
	     %IF (%LENGTH EQL 5) %THEN (Arg1) %ELSE (((Arg1)^4)+(Arg2))
	     %FI %FI) %;

GLOBAL BIND
    DBG$Opcode_Name_Table = 
	UPLIT WORD(BYTE(%ASCII '??????'),WORD(0,0),Opcode_List) : BLOCKVECTOR [,10,BYTE];

!++
!									       !					      A001
!	Undeclare Opcode_Entry so that another definition of the macro	       !					      A001
!	Opcode_Entry can be defined the to build the back translation	       !					      A001
!	table, DBG$Opcode_Kind_Table.					       !					      A001
!--									       !					      A001
UNDECLARE %QUOTE Opcode_Entry;

MACRO Opcode_Entry(Flag, Name, Code, Kind, Arg1, Arg2) =
%ASSIGN(Opcode_Index, Opcode_Index + 1)
%IF Flag
%THEN
  [IF (Code LSS %X'100') THEN (Code) ELSE (((Code)^-8)+%X'100')] = Opcode_Index
%ELSE
%ASSIGN(Ignore_Index, Ignore_Index + 1)
  [255 + Ignore_Index] = 0
%FI
 %;

COMPILETIME
    Opcode_Index = 0,
    Ignore_Index = 0;

GLOBAL
    DBG$Opcode_Kind_Table : PSECT(DBG$PLIT) VECTOR[512,WORD] PRESET(Opcode_List);

UNDECLARE %QUOTE Opcode_Entry;

LITERAL Opcode_Table_Size = Opcode_Index;

OWN
    Op_Buffer		: BLOCK [16,BYTE],
    Data_Size		: PSECT(DBG$PLIT) VECTOR[12,BYTE] PRESET(
	[context_b] =  1,		[context_w] =  2,
	[context_l] =  4,		[context_q] =  8,
	[context_o] = 16,
	[context_f] =  4,		[context_d] =  8,
	[context_g] =  8,		[context_h] = 16,
	[context_bu] = 1,		[context_wu] = 2),
    Data_Type		: PSECT(DBG$PLIT) VECTOR[12,BYTE] PRESET(
	[context_b] = dsc$k_dtype_b,	[context_w] = dsc$k_dtype_w,
	[context_l] = dsc$k_dtype_l,	[context_q] = dsc$k_dtype_q,
	[context_o] = dsc$k_dtype_o,
	[context_f] = dsc$k_dtype_f,	[context_d] = dsc$k_dtype_d,
	[context_g] = dsc$k_dtype_g,	[context_h] = dsc$k_dtype_h,
	[context_bu]= dsc$k_dtype_bu,	[context_wu]= dsc$k_dtype_wu);

BIND
    Operand_Value = Op_Buffer : LONG,
    Register_Name = UPLIT BYTE(
	2,'R','0', 0 ,    2,'R','1', 0 ,    2,'R','2', 0 ,    2,'R','3', 0 ,
	2,'R','4', 0 ,    2,'R','5', 0 ,    2,'R','6', 0 ,    2,'R','7', 0 ,
	2,'R','8', 0 ,    2,'R','9', 0 ,    3,'R','1','0',    3,'R','1','1',
	2,'A','P', 0 ,    2,'F','P', 0 ,    2,'S','P', 0 ,    2,'P','C', 0 ,
!
        2,'?','?', 0 ,    2,'?','?', 0 ,    2,'I','V', 0 ,    2,'D','V', 0 )
					 : VECTOR[,LONG],
    Format_AD = UPLIT BYTE(%ASCIC '!AD'),
    Format_AC = UPLIT BYTE(%ASCIC '!AC'),
    comma     = UPLIT BYTE(',');

MACRO
    offset = 0,0, 0,0 %,
    u_byte = 0,0, 8,0 %,
    u_word = 0,0,16,0 %,
    u_long = 0,0,32,0 %,
    s_byte = 0,0, 8,1 %,
    s_word = 0,0,16,1 %,
    s_long = 0,0,32,1 %;

FIELD Opcode_Entry_Fields =
    SET
    op_name	= [0,0,0,0],
    op_code	= [6,0,16,0],						       ! Whole opcode				      A002
    op_code_one	= [6,0,8,0],
    op_code_two	= [7,0,8,0],
    op_kind	= [8,0,8,0],
    op_type	= [9,0,8,0],
    op_type_one	= [9,0,4,0],
    op_type_two = [9,4,4,0]
    TES;

FIELD Encode_Fields =
    SET
    Enc_Input_Desc    = [ 0, 0, 0,0],
    Enc_Input_Length  = [ 0, 0,16,0],
    Enc_Input_Dtype   = [ 2, 0, 8,0],
    Enc_Input_Class   = [ 3, 0, 8,0],
    Enc_Input_Buffer  = [ 4, 0,32,0],
    Enc_Output_Length = [ 8, 0,32,0],
    Enc_Output_Buffer = [12, 0,32,0],
    Enc_Final_Address = [16, 0,32,0]
    TES;

GLOBAL ROUTINE DBG$Ins_Decode(Start_Address,Print_Flag,Entry_Flag) =
    BEGIN
    BUILTIN ACTUALCOUNT;
    LOCAL Pointer;
    LOCAL
	Signal_Flag	: VOLATILE,
	Error_Value	: VOLATILE;

    ROUTINE Decode_Handler(Sig_Args,Mech_Args,Enable_Args) =
	BEGIN
	MAP Sig_Args	: REF BLOCK[,BYTE],
	    Mech_Args	: REF BLOCK[,BYTE],
	    Enable_Args	: REF VECTOR[,LONG];
	EXTERNAL ROUTINE SYS$UNWIND : Addressing_Mode(General);

	IF .Sig_Args[chf$l_sig_name] EQL ss$_unwind THEN RETURN ss$_continue;
	IF .(.Enable_Args[1]) THEN RETURN ss$_resignal;

	Mech_Args[chf$l_mch_savr0] = .(.Enable_Args[2]);

	SYS$UNWIND(0,0);
	RETURN ss$_continue;
	END;

    ENABLE Decode_Handler(Signal_Flag,Error_Value);

    Signal_Flag = .Print_Flag;
    Error_Value = .Start_Address + 1;

    Pointer = .Start_Address;

    !++									       !					      A001
    ! Do we have an entry mask						       !					      A001
    !--									       !					      A001
    IF (IF ActualCount() GTR 2 THEN .Entry_Flag ELSE DBG$Is_It_Entry(.Start_Address))
    THEN
	BEGIN
	Error_Value = .Error_Value + 1;
	Fetch_Instruction(Pointer,context_wu);
	IF .Print_Flag THEN
	    BEGIN
	    LOCAL Delimiter,Mask_Bits;

	    Mask_Bits = .Operand_Value<0,12,0>+(.Operand_Value<12,4,0>)^16;

	    DBG$Print(UPLIT BYTE (%ASCIC 'entry mask ^M'));

	    Delimiter = %C'<';

	    IF .Mask_Bits EQL 0 THEN DBG$Print(Format_AD,1,Delimiter) ELSE
	      INCR Index FROM 0 TO 19 DO IF .Mask_Bits<.Index,1,0> THEN
		BEGIN
		DBG$Print(Format_AD,1,Delimiter);
		DBG$Print(Format_AC,Register_Name[.Index]);
		Delimiter = %C',';
		END;

	    DBG$Print(Format_AD,1,UPLIT BYTE('>'));

	    IF .Operand_Value<12,2,0> NEQ 0 THEN
		BEGIN
		DBG$Newline();
		SIGNAL(dbg$_entrymask);
		END;
	    END;
	END

    ELSE		! Not an entry mask - decode actual instruction
	BEGIN
	LOCAL
	    Opcode,
	    Opcode_Index,
	    Opcode_Entry : REF BLOCK[10,BYTE] FIELD(Opcode_Entry_Fields),
	    Delimiter,
	    State;

	Fetch_Instruction(Pointer,context_bu);
	Opcode = .Op_Buffer[u_byte];
	Opcode_Index = .DBG$Opcode_Kind_Table[.Opcode];
	IF (.Opcode_Index EQL 0) THEN
	    BEGIN
	    IF (.Opcode GEQU %X'FD') THEN
		BEGIN
		Fetch_Instruction(Pointer,context_bu);
		IF (((.Opcode EQLU %X'FD') AND (.Op_Buffer[u_byte]  LSSU %X'FD'))
		 OR ((.Opcode EQLU %X'FF') AND (.Op_Buffer[u_byte]  GEQU %X'FD')))
		  THEN
		    Opcode_Index = .DBG$Opcode_Kind_Table[.Op_Buffer[u_byte]+%X'100'];
		END;
	    IF (.Opcode_Index EQL 0) THEN SIGNAL(dbg$_noinstran,1,.Start_Address);
	    END;

	Opcode_Entry = DBG$Opcode_Name_Table[.Opcode_Index,offset];

	IF .Print_Flag THEN DBG$Print(Format_AD,6,Opcode_Entry[op_name]);
	Delimiter = %C'	';

	State = .Opcode_Entry[op_kind];

	WHILE (.State NEQ simple_0_operand) DO
	    BEGIN
	    IF .Print_Flag THEN DBG$Print(Format_AD,1,Delimiter);
	    Delimiter = %C',';

	    CASE .State FROM simple_1_operand TO maximum_state OF
		SET
		[simple_1_operand,
		 simple_2_operand,
		 simple_3_operand]:
		    BEGIN
		    Fetch_Operand(Pointer,.Opcode_Entry[op_type_one],.Print_Flag,0);
		    State = .State - 1;
		    END;

		[branch_0_operand]:
		    BEGIN
		    Fetch_Instruction(Pointer,.Opcode_Entry[op_type_one]);
		    IF .Print_Flag THEN
			Print_Address(.Operand_Value + .Pointer);
		    EXITLOOP;
		    END;

		[branch_1_operand,
		 branch_2_operand,
		 branch_3_operand]:
		    BEGIN
		    Fetch_Operand(Pointer,.Opcode_Entry[op_type_two],.Print_Flag,0);
		    State = .State - 1;
		    END;

		[convert_datatype,
! *****          evaluate_address,
! *****          simple_bit_field,
! *****          routine_dispatch,
! *****          polynomial_value,
! *****          probe_for_access,
		 string_3_operand]:
		    BEGIN
		    Fetch_Operand(Pointer,.Opcode_Entry[op_type_two],.Print_Flag,0);
		    State = Simple_1_Operand;
		    END;

		[string_4_operand]:
		    BEGIN
		    Fetch_Operand(Pointer,.Opcode_Entry[op_type_two],.Print_Flag,0);
		    State = Simple_2_Operand;
		    END;

		[string_5_operand,
		 string_6_operand]:
		    BEGIN
		    Fetch_Operand(Pointer,.Opcode_Entry[op_type_two],.Print_Flag,0);
		    DECR count FROM .State TO string_5_operand DO
			BEGIN
			IF .Print_Flag THEN DBG$Print(Format_AD,1,Delimiter);
			Fetch_Operand(Pointer,context_b,.Print_Flag,0);
			END;
		    State = Simple_1_Operand;
		    END;

		[trailing_operand]:
		    BEGIN
		    Fetch_Instruction(Pointer,.Opcode_Entry[op_type_one]);
		    IF .Print_Flag THEN Print_Operand(.Opcode_Entry[op_type_one]);
		    EXITLOOP;
		    END;

		[complex_SHIFT]:
		    BEGIN
		    Fetch_Operand(Pointer,context_b,.Print_Flag,0);
		    State = Simple_2_Operand;
		    END;

		[complex_EMOD]:
		    BEGIN
		    Fetch_Operand(Pointer,.Opcode_Entry[op_type_one],.Print_Flag,0);
		    IF .Print_Flag THEN DBG$Print(Format_AD,1,Delimiter);
		    Fetch_Operand(Pointer,.Opcode_Entry[op_type_two],.Print_Flag,0);
		    State = Simple_3_Operand;
		    END;

		[complex_CRC]:
		    BEGIN
		    Fetch_Operand(Pointer,context_b,.Print_Flag,0);
		    IF .Print_Flag THEN DBG$Print(Format_AD,1,Delimiter);
		    Fetch_Operand(Pointer,context_l,.Print_Flag,0);
		    IF .Print_Flag THEN DBG$Print(Format_AD,1,Delimiter);
		    Fetch_Operand(Pointer,context_t,.Print_Flag,0);
		    EXITLOOP;
		    END;

		[complex_EMUL]:
		    BEGIN
		    Fetch_Operand(Pointer,context_l,.Print_Flag,0);
		    IF .Print_Flag THEN DBG$Print(Format_AD,1,Delimiter);
		    Fetch_Operand(Pointer,context_l,.Print_Flag,0);
		    IF .Print_Flag THEN DBG$Print(Format_AD,1,Delimiter);
		    Fetch_Operand(Pointer,context_l,.Print_Flag,0);
		    IF .Print_Flag THEN DBG$Print(Format_AD,1,Delimiter);
		    Fetch_Operand(Pointer,context_q,.Print_Flag,0);
		    EXITLOOP;
		    END;

		[complex_EDIV]:
		    BEGIN
		    Fetch_Operand(Pointer,context_l,.Print_Flag,0);
		    IF .Print_Flag THEN DBG$Print(Format_AD,1,Delimiter);
		    Fetch_Operand(Pointer,context_q,.Print_Flag,0);
		    IF .Print_Flag THEN DBG$Print(Format_AD,1,Delimiter);
		    Fetch_Operand(Pointer,context_l,.Print_Flag,0);
		    IF .Print_Flag THEN DBG$Print(Format_AD,1,Delimiter);
		    Fetch_Operand(Pointer,context_l,.Print_Flag,0);
		    EXITLOOP;
		    END;

		[complex_INDEX]:
		    BEGIN
		    DECR count FROM 5 TO 0 DO
			BEGIN
			Fetch_Operand(Pointer,context_l,.Print_Flag,0);
			IF .Print_Flag AND (.count NEQ 0) THEN DBG$Print(Format_AD,1,Delimiter);
			END;
		    EXITLOOP;
		    END;

		[complex_CASE]:
		    BEGIN
		    LOCAL						       !					      A003
		    	Limit;						       ! The number of displacements		      A003
		    Fetch_Operand(Pointer,.Opcode_Entry[op_type_one],.Print_Flag,0);
		    IF .Print_Flag THEN DBG$Print(Format_AD,1,Delimiter);
		    Fetch_Operand(Pointer,.Opcode_Entry[op_type_one],.Print_Flag,0);
		    IF .Print_Flag THEN DBG$Print(Format_AD,1,Delimiter);

		    !++							       !					      A003
		    ! Fetch the limit					       !					      A003
		    !--							       !					      A003
		    Fetch_Operand(Pointer,.Opcode_Entry[op_type_one],.Print_Flag,0);

		    !++							       !					      A003
		    ! Get the limit in of the appropriate length	       !					      A003
		    !--							       !					      A003
		    Limit = (SELECTONE .Opcode_Entry[ Op_type_one ] OF	       ! What is the operand length?		      A003
		    	     SET					       !					      A003
			     [context_b]:	.Op_buffer[u_byte];	       ! Byte					      A003
			     [context_w]:	.Op_buffer[u_word];	       ! Word					      A003
			     [context_l]:	.Op_buffer[u_long];	       ! Long					      A003
			     TES);					       !					      A003

		    IF NOT .Print_Flag
		    THEN
			Pointer = .Pointer+2*(.Limit+1)			       !					      M003
		    ELSE
			BEGIN
			LOCAL start;
			start = .Pointer;
			DECR count FROM .Limit TO 0 DO
			    BEGIN
			    BIND					       !					      A005
				CASE_Offset = Op_buffer[u_word] : SIGNED;      ! Convert the word to signed		      A005
			    $ABORT_ON_CONTROL_Y;			       ! Its ok the ^Y out of the case list	      A003
			    Fetch_Instruction(Pointer,context_w);
			    DBG$NewLine();
			    DBG$Print(Format_AD,2,UPLIT BYTE('		'));
			    Print_Address(.CASE_Offset + .Start);	       ! Print the address			      M005
			    END;
			END;
		    EXITLOOP;
		    END;

		[complex_ASHP]:						       		! ASHP didn't fit any other pattern  A005
		    BEGIN						       		!				     A005
		    Fetch_Operand(Pointer,.Opcode_Entry[op_type_two],.Print_Flag,0);	!				     A005
		    IF .Print_Flag THEN DBG$Print(Format_AD,1,Delimiter);      		!				     A005
		    Fetch_Operand(Pointer,.Opcode_Entry[op_type_one],.Print_Flag,0);	!				     A005
		    IF .Print_Flag THEN DBG$Print(Format_AD,1,Delimiter);      		!				     A005
		    Fetch_Operand(Pointer,.Opcode_Entry[op_type_two],.Print_Flag,0);	!				     A005
		    IF .Print_Flag THEN DBG$Print(Format_AD,1,Delimiter);      		!				     A005
		    Fetch_Operand(Pointer,.Opcode_Entry[op_type_one],.Print_Flag,0);	!				     A005
		    EXITLOOP;						       		!				     A005
		    END;						       		!				     A005

		[INRANGE,OUTRANGE]:
		    $DBG_ERROR('DBG$Encode_Decode - bad opcode table entry');
		TES;
	    END;
	END;

    RETURN .Pointer;
    END;

GLOBAL ROUTINE DBG$Ins_Encode(Input_Buffer,Output_Buffer,Relocation) =
    BEGIN
    MAP Input_Buffer	: REF VECTOR [,BYTE],	! %ASCIC String
	Output_Buffer	: REF VECTOR [,BYTE];	! Encoded instruction
    LOCAL
	Operand_number	: INITIAL( 0 ),						! A007
	Encode		: BLOCK [20,BYTE] FIELD(Encode_Fields),
	Local_Buffer	: VECTOR[256,BYTE],
	Opcode_Entry	: REF BLOCK[10,BYTE] FIELD(Opcode_Entry_Fields),
	State;

    Encode[Enc_Input_Class]   =  dsc$k_class_s;
    Encode[Enc_Input_Dtype]   =  dsc$k_dtype_t;
    Encode[Enc_Input_Length]  = .Input_Buffer[0];
    Encode[Enc_Input_Buffer]  =  Local_Buffer[0];
    Encode[Enc_Output_Length] =  0;
    Encode[Enc_Output_Buffer] =  Output_Buffer[1];
    Encode[Enc_Final_Address] = .Relocation;

    ch$move(.Input_Buffer[0],Input_Buffer[1],Local_Buffer[0]);
    Opcode_Entry = Opcode_Name_Index(Encode[Enc_Input_Desc],%C' ');	       ! Changed to call Opcode_Name_Table	      M002
									       ! instead of DBG$OPCODE_INDEX
    Opcode_Entry = DBG$Opcode_Name_Table[.Opcode_Entry,offset];

    IF .Opcode_Entry[op_code_one] NEQ 0 THEN
    Store_Operand(Encode,Opcode_Entry[op_code_one],1);
    Store_Operand(Encode,Opcode_Entry[op_code_two],1);

    State = .Opcode_Entry[op_kind];

    WHILE (.State NEQ simple_0_operand) DO
	BEGIN
	CASE .State FROM simple_1_operand TO maximum_state OF
	    SET

	    [simple_1_operand,
	     simple_2_operand,
	     simple_3_operand]:
		BEGIN
		Parse_Operand(Encode,.Opcode_Entry[op_type_one],Operand_number);! M007
		State = .State - 1;
		END;

	    [branch_0_operand]:
		BEGIN
		LOCAL Address,Length;
		Operand_number = .Operand_number + 1;				! A007
		Length = Scan_Operand(Encode[Enc_Input_Desc],%C',');
		IF NOT Parse_Expression(-1,.Encode[Enc_Input_Buffer],
		 .Encode[Enc_Input_Length],Address) THEN SIGNAL(dbg$_INVEXPR,1,.Operand_number);	! M007
		IF (Check_Register(.Address) GEQ 0) THEN SIGNAL(dbg$_INVEXPR,1,.Operand_number);	! M007
		Encode[Enc_Input_Buffer] = .Encode[Enc_Input_Buffer] + .Length;
		Encode[Enc_Input_Length] = .Encode[Enc_Input_Length] - .Length;

		Length = .Data_Size[.Opcode_Entry[op_type_one]];

		Address = .Address - (.Length + .Encode[Enc_Final_Address]
					      + .Encode[Enc_Output_Length]);
		Store_Operand(Encode,Address,.Length);
		EXITLOOP;
		END;

	    [branch_1_operand,
	     branch_2_operand,
	     branch_3_operand]:
		BEGIN
		Parse_Operand(Encode,.Opcode_Entry[op_type_two],Operand_number);! M007
		State = .State - 1;
		END;

	    [convert_datatype,
! *****      evaluate_address,
! *****      simple_bit_field,
! *****      routine_dispatch,
! *****      polynomial_value,
! *****      probe_for_access,
	     string_3_operand]:
		BEGIN
		Parse_Operand(Encode,.Opcode_Entry[op_type_two],Operand_number);! M007
		State = Simple_1_Operand;
		END;

	    [string_4_operand]:
		BEGIN
		Parse_Operand(Encode,.Opcode_Entry[op_type_two],Operand_number);! M007
		State = Simple_2_Operand;
		END;

	    [string_5_operand,
	     string_6_operand]:
		BEGIN
		Parse_Operand(Encode,.Opcode_Entry[op_type_two],Operand_number);! M007
		DECR count FROM .State TO string_5_operand DO
		    Parse_Operand(Encode,context_b,Operand_number);		! M007
		State = Simple_1_Operand;
		END;

	    [trailing_operand]:
		BEGIN
!		Store_Operand(Encode,.Opcode_Entry[op_type_one]);
!		IF .Print_Flag THEN Print_Operand(.Opcode_Entry[op_type_one]);
		EXITLOOP;
		END;

	    [complex_SHIFT]:
		BEGIN
		Parse_Operand(Encode,context_b,Operand_number);		! M007
		State = Simple_2_Operand;
		END;

	    [complex_EMOD]:
		BEGIN
		Parse_Operand(Encode,.Opcode_Entry[op_type_one],Operand_number);! M007
		Parse_Operand(Encode,.Opcode_Entry[op_type_two],Operand_number);! M007
		State = Simple_3_Operand;
		END;

	    [complex_CRC]:
		BEGIN
		Parse_Operand(Encode,context_b,Operand_number);		! M007
		Parse_Operand(Encode,context_l,Operand_number);		! M007
		Parse_Operand(Encode,context_t,Operand_number);		! M007
		EXITLOOP;
		END;

	    [complex_EMUL]:
		BEGIN
		Parse_Operand(Encode,context_l,Operand_number);		! M007
		Parse_Operand(Encode,context_l,Operand_number);		! M007
		Parse_Operand(Encode,context_l,Operand_number);		! M007
		Parse_Operand(Encode,context_q,Operand_number);		! M007
		EXITLOOP;
		END;

	    [complex_EDIV]:
		BEGIN
		Parse_Operand(Encode,context_l,Operand_number);		! M007
		Parse_Operand(Encode,context_q,Operand_number);		! M007
		Parse_Operand(Encode,context_l,Operand_number);		! M007
		Parse_Operand(Encode,context_l,Operand_number);		! M007
		EXITLOOP;
		END;

	    [complex_INDEX]:
		BEGIN
		DECR count FROM 5 TO 0 DO Parse_Operand(Encode,context_l,Operand_number);! M007
		EXITLOOP;
		END;

	    [complex_CASE]:
		BEGIN
		Parse_Operand(Encode,.Opcode_Entry[op_type_one],Operand_number);! M007
		Parse_Operand(Encode,.Opcode_Entry[op_type_one],Operand_number);! M007
		Parse_Operand(Encode,.Opcode_Entry[op_type_one],Operand_number);! M007
		EXITLOOP;
		END;

	    [complex_ASHP]:						       !					    A005
		BEGIN							       !					    A005
		Parse_Operand(Encode,.Opcode_Entry[op_type_two],Operand_number);!				       M007 A005
		Parse_Operand(Encode,.Opcode_Entry[op_type_one],Operand_number);	       !		       M007 A005
		Parse_Operand(Encode,.Opcode_Entry[op_type_two],Operand_number);	       !		       M007 A005
		Parse_Operand(Encode,.Opcode_Entry[op_type_one],Operand_number);	       !		       M007 A005
		EXITLOOP;						       !					    A005
		END;							       !					    A005

	    [INRANGE,OUTRANGE]:
		$DBG_ERROR('DBG$Encode_Decode - bad opcode table entry');

	    TES;
	END;

    Output_Buffer[0] = .Encode[Enc_Output_Length];
    RETURN 1;
    END;

GLOBAL ROUTINE DBG$Opcode_Index(Input_Desc : REF dbg$stg_desc) =
!++									       !					      A001
!									       !					      A001
!	Return the index of DBG$Opcode_Name_Table of the opcode MNemonic       !					      A001
!	Passed in Input_Desc.						       !					      A001
!									       !					      A001
!	Input_desc is modified to point after the MNemonic.  That is the       !					      A001
!	MNemonic is consumed.  Input_desc must be the Mnemonic only if	       !					      A001
!	Delimiter is not passed.					       !					      A001
!									       !					      A001
!--									       !					      A001
    BEGIN
    LOCAL								       !					      A002
	Code,								       !					      A002
	Index;								       !					      A002
									       !					      A002
    Index = Opcode_Name_Index ( .Input_desc );				       ! Get the index into the name table	      A002
    Code = .DBG$Opcode_Name_Table[ .index, 7, 0, 8, 0];	      	 	       !					      A002
    !++									       !					      A002
    ! Return the index into the Kind_table				       !					      A002
    !--									       !					      A002
    RETURN (IF (.DBG$Opcode_Name_Table[ .index, 6, 0, 8, 0] LSS %X'FD')	       ! Test for 2 byte opcode!		  A002M004
	    THEN (.Code)						       ! 1 byte opcode index			      A002
	    ELSE ( .Code + %X'100' )					       ! 2 byte opcode index			      A002
	   );								       !					      A002
    END;

ROUTINE Opcode_Name_Index(Input_Desc : REF dbg$stg_desc,Delimiter) =	       !					      A002
!									       !					      A002
! FUNCTIONAL DESCRIPTION:						       !					      A002
!									       !					      A002
!   Opcode_Name_Index returns the index into DBG$OPCODE_NAME_TABLE	       !					      A002
!   given a mnemonic.							       !					      A002
!									       !					      A002
! FORMAL PARAMETERS:							       !					      A002
!									       !					      A002
!   Input_Desc - A string descriptor by reference, describing the	       !					      A002
!		 Mnemonic.						       !					      A002
!									       !					      A002
!   Delimiter  - An optional parameter, describing the character	       !					      A002
!		 with which to terminate the Mnemonic, passed		       !					      A002
!		 by value.						       !					      A002
!									       !					      A002
! IMPLICIT INPUTS:							       !					      A002
!									       !					      A002
!   DBG$Opcode_Name_table						       !					      A002
!									       !					      A002
! IMPLICIT OUTPUTS:							       !					      A002
!									       !					      A002
!   Input_desc is update to consume the Mnemonic.			       !					      A002
!									       !					      A002
!									       !					      A002
! ROUTINE VALUE:							       !					      A002
!									       !					      A002
!   The index into DBG$Opcode_Name_Table for the Mnemonic passed	       !					      A002
!									       !					      A002
!									       !					      A002
! SIDE EFFECTS:								       !					      A002
!									       !					      A002
!   None								       !					      A002
!									       !					      A002
    BEGIN
    BUILTIN ACTUALCOUNT;
    LOCAL
	index,
	length,
	limit_LSS,
	limit_GTR;


    IF Actualcount() GTR 1
    THEN
	length = Scan_Operand(.Input_Desc,.Delimiter)
    ELSE
	BEGIN

	LOCAL Temp_ptr;							       ! Current position in the input string	      A002

	Skip_Leading_Blanks(.Input_Desc);

	Temp_ptr = CH$PTR ( .Input_Desc[ dsc$a_pointer ] );		       ! Assign the start of the string		      A002

	!++
	! Consume the Mnemonic
	!--
	length = 0;
	WHILE .length LSS .Input_Desc[dsc$w_length] DO
	    BEGIN
	    LOCAL char : BYTE UNSIGNED;
	    char = CH$RCHAR_A( Temp_ptr );				       ! Read a character and incr the pointer	      A002
	    IF ((.char GEQU %C'A') AND (.char LEQU %C'Z'))
	    OR ((.char GEQU %C'0') AND (.char LEQU %C'9'))
	    THEN
		length = .length + 1
	    ELSE
		EXITLOOP;
	    END;
	END;

    limit_LSS = 0;
    limit_GTR = Opcode_Index + 1;
    !++									       !					      A001
    !	Binary search of DBG$Opcode_Name_Table for the Mnemonic		       !					      A001
    !--									       !					      A001
    WHILE ((index = (.limit_LSS + .limit_GTR)/2) NEQ .limit_LSS) DO
	BEGIN
	SELECTONE ch$compare(6,DBG$Opcode_Name_Table[.index,offset],
			    .length,.Input_Desc[dsc$a_pointer],%C' ') OF
	    SET
	    [-1]: limit_LSS = .index;
	    [+1]: limit_GTR = .index;
	    [ 0]:
		BEGIN
		Input_Desc[dsc$w_length]  = .Input_Desc[dsc$w_length] -.length;
		Input_Desc[dsc$a_pointer] = .Input_Desc[dsc$a_pointer]+.length;
		RETURN .Index
		END;
	    TES;
	END;
    SIGNAL(dbg$_badopCode,2,.length,.Input_Desc[dsc$a_pointer]);
    RETURN 0;
    END;

ROUTINE Fetch_Instruction(Pointer,Context) : NOVALUE =
    BEGIN
    BUILTIN PROBER,MOVC5;

    IF NOT PROBER(%REF(0),%REF(.Data_Size[.Context]),..Pointer) 
     THEN SIGNAL(dbg$_noaccessr,1,..Pointer);
    MOVC5(%REF(.Data_Size[.Context]),..Pointer,%REF(0),
	 %REF(16),Op_Buffer;,.Pointer);
    SELECTONE .Context OF
	SET
	[context_b]:	Op_Buffer[s_long] = .Op_Buffer[s_byte];
	[context_w]:	Op_Buffer[s_long] = .Op_Buffer[s_word];
	[OTHERWISE]:	0;
	TES;
    END;

ROUTINE Fetch_Operand(Pointer,Context,Print_Flag,Index_Flag) : NOVALUE =
    BEGIN
    LOCAL
	Mode_Specifier,
	Register_Field;


    SELECTONE .Context OF
	SET
	[context_p,context_t]:
	    BEGIN
	    Fetch_Operand(.Pointer,context_wu,.Print_Flag,.Index_Flag);
	    IF .Print_Flag THEN DBG$Print(Format_AD,1,comma);
	    Fetch_Operand(.Pointer,context_b,.Print_Flag,.Index_Flag);
	    END;
	[context_m,context_v]:
	    BEGIN
	    Fetch_Operand(.Pointer,context_l,.Print_Flag,.Index_Flag);
	    IF .Print_Flag THEN DBG$Print(Format_AD,1,comma);
	    Fetch_Operand(.Pointer,context_b,.Print_Flag,.Index_Flag);
	    IF .context EQL context_v THEN RETURN;
	    IF .Print_Flag THEN DBG$Print(Format_AD,1,comma);
	    Fetch_Operand(.Pointer,context_b,.Print_Flag,.Index_Flag);
	    END;
	[OTHERWISE]:
	    BEGIN
	    Fetch_Instruction(.Pointer,context_bu);
	    Mode_Specifier = .Op_Buffer[0,4,4,0];
	    Register_Field = .Op_Buffer[0,0,4,0];

	    IF (.Print_Flag AND .Index_Flag AND (.Mode_Specifier LEQ 5)) 
	     THEN SIGNAL(dbg$_addressmode);

	    CASE .Mode_Specifier FROM 0 TO 15 OF
		SET
		[0,1,2,3]:	! Literal
		  IF (.Print_Flag) THEN
		    BEGIN
		    DBG$Print(Format_AD,3,UPLIT BYTE('S^#'));
		    SELECTONE .Context OF
			SET
			[context_f,context_d,
			 context_g,context_h]:
			    BEGIN
			    Operand_Value = (.Operand_Value^4) OR %X'4000';
			    Print_Operand(context_f);
			    END;
			[OTHERWISE]:
			    BEGIN
			    Print_Operand(Context_b);
			    END;
			TES;
		    END;

		[4,5,6,7,8,9]:	! Various Register Modes
		    BEGIN
		    IF (.Mode_Specifier<3,1,0> AND (.Register_Field EQL 15))
		    THEN
			BEGIN
			IF NOT .Mode_Specifier
			THEN
			    BEGIN
			    Fetch_Instruction(.Pointer,.Context);
			    IF .Print_Flag THEN
				BEGIN
				DBG$Print(Format_AD,3,UPLIT BYTE('I^#'));
				Print_Operand(.Context);
				END;
			    END
			ELSE
			    BEGIN
			    Fetch_Instruction(.Pointer,context_l);
			    IF .Print_Flag THEN
				BEGIN
				DBG$Print(Format_AD,2,UPLIT BYTE('@#'));
				Print_Address(.Operand_Value);
				END;
			    END
			END
		    ELSE
			BEGIN
			IF .Mode_Specifier EQL 4 THEN
			    Fetch_Operand(.Pointer,.Context,.Print_Flag,1);
			IF .Print_Flag THEN
			    BEGIN
			    BIND Punctuation = UPLIT BYTE(
				 0 ,'[',']', 0 ,	! Mode 4
				 0 , 0 , 0 , 0 ,	! Mode 5
				 0 ,'(',')', 0 ,	! Mode 6
				'-','(',')', 0 ,	! Mode 7
				 0 ,'(',')','+',	! Mode 8
				'@','(',')','+')	! Mode 9
				- (4*4) : BLOCKVECTOR [10,4,BYTE];

			    IF .Punctuation[.Mode_Specifier,0,0,8,0] NEQ 0 THEN
				DBG$Print(Format_AD,1,Punctuation[.Mode_Specifier,0,0,0,0]);
			    IF .Punctuation[.Mode_Specifier,1,0,8,0] NEQ 0 THEN
				DBG$Print(Format_AD,1,Punctuation[.Mode_Specifier,1,0,0,0]);
			    DBG$Print(Format_AC,Register_Name[.Register_Field]);
			    IF .Punctuation[.Mode_Specifier,2,0,8,0] NEQ 0 THEN
				DBG$Print(Format_AD,1,Punctuation[.Mode_Specifier,2,0,0,0]);
			    IF .Punctuation[.Mode_Specifier,3,0,8,0] NEQ 0 THEN
				DBG$Print(Format_AD,1,Punctuation[.Mode_Specifier,3,0,0,0]);
			    END;
			END;
		    END;

		[10,11,12,13,14,15]:	! Displacement Modes
		    BEGIN
		    LOCAL Offset_Context;

		    Offset_Context = (.Mode_Specifier-10)/2;
		    Fetch_Instruction(.Pointer,.Offset_Context);
		    IF (.Print_Flag) THEN
			BEGIN
			BIND Mode_Char = UPLIT BYTE('BWL') : VECTOR[,BYTE];
			IF (.Mode_Specifier) THEN
			    DBG$Print(Format_AD,1,UPLIT BYTE('@'));
			DBG$Print(Format_AD,1,Mode_Char[.Offset_Context]);
			DBG$Print(Format_AD,1,UPLIT BYTE('^'));
			IF (.Register_Field EQL 15)
			THEN
			    Print_Address(.Operand_Value + ..Pointer)
			ELSE
			    BEGIN
			    Print_Operand(.Offset_Context);
			    DBG$Print(Format_AD,1,UPLIT BYTE('('));
			    DBG$Print(Format_AC,Register_Name[.Register_Field]);
			    DBG$Print(Format_AD,1,UPLIT BYTE(')'));
			    END;
			END;
		    END;
		TES;
	    END;
	TES;
    END;

ROUTINE Parse_Operand(EnCode,Context,Operand_number) : NOVALUE =		! M007
    BEGIN
    MAP EnCode	: REF BLOCK [20,BYTE] FIELD(EnCode_Fields);
    LABEL scan,trim,mode,Addr;
    LOCAL
	Regnum,R_Mode,	! Index register and addressing mode
	Indexed_Regnum,							       ! For saving the indexed register number	      A005
	Displacement_size_needed,					       ! Displacement sized needed flag		      A005
	Length,Parsed,	! Operand lengths (unparsed and total)
	Defer,Address,	! Operand Mode and Address
	Buffer		: REF VECTOR [,BYTE];

    MACRO Report_Error = (SIGNAL(dbg$_opsyntax,1,..Operand_number);RETURN)%; ! saves Code M007

    SELECTONE .Context OF
	SET
	[context_p,context_t]:
	    BEGIN
	    Parse_Operand(.EnCode,context_wu,.Operand_number);			! M007
	    Parse_Operand(.EnCode,context_b,.Operand_number);			! M007
	    RETURN;
	    END;
	[context_m,context_v]:
	    BEGIN
	    Parse_Operand(.EnCode,context_l,.Operand_number);			! M007
	    Parse_Operand(.EnCode,context_b,.Operand_number);			! M007
	    IF .context EQL context_m THEN Parse_Operand(.EnCode,context_b,.Operand_number);! M007
	    RETURN;
	    END;

	[OTHERWISE]:
	    BEGIN
	    .Operand_number = ..Operand_number + 1;					! A007
	    Length = Parsed = Scan_Operand(EnCode[Enc_Input_Desc],%C',');
	    Buffer = .EnCode[Enc_Input_Buffer];
	    WHILE (.Length GTR 0) AND (.Buffer[.Length-1] EQL %C' ') DO Length = .Length - 1;
	    IF .Length LEQ 0 THEN SIGNAL(DBG$_INCOMPOPR, 1, ..Operand_number);		! M007
	    END;
	TES;



scan:	BEGIN
!++
! Trim block takes the -(Rn)[Rn] off the operand 
! starting at the back and trimming toward the front
!--
trim:	    BEGIN
	    R_Mode = 0;
	    Indexed_Regnum = -1;					       ! No indexed register seen yet		      A005
	    Displacement_size_needed = 0;				       ! No displacement size needed yet	      A005
	    IF .Buffer[.Length-1] EQL %C']' THEN			       ! Index mode?
		BEGIN
		DECR Start FROM .Length-1 TO 1 DO			       ! Look for matching [
		  IF .Buffer[.Start-1] EQL %C'[' THEN
		    BEGIN
		    Regnum = Parse_Register(Buffer[.Start],.Length-1-.Start);  ! Get the register number
		    IF .Regnum LSS 0 					       ! Bad register, Assume addr-expr
		    THEN
			SIGNAL(DBG$_REGREQ, 1, ..Operand_number);	       !				M007
		    IF .Regnum GEQ 15					       ! Disallow PC			M007  M005
		    THEN
			SIGNAL(DBG$_PCNOTALL, 1, ..Operand_number);	       !				M007
		    IF (Length = .Start - 1) LEQ 0 			       ! Consume the [Rx]
		    THEN
			 SIGNAL(DBG$_INCOMPOPR, 1, ..Operand_number);	       ! make sure there is more		M007
		    Indexed_Regnum = .Regnum;				       ! Save the indexed register number	      A005
		    Regnum = .Regnum + %X'40';				       ! Construct the index mode byte
		    Store_Operand(.EnCode,Regnum,1);			       ! Store the index mode byte
		    R_Mode = -1;					       ! Flag that we've done index mode
		    EXITLOOP;						       
		    END;
		END;

	    IF .Buffer[.Length-1] EQL %C'+' THEN			       ! Autoincrement?
		BEGIN
		R_Mode = %X'80';					       ! Construct the mode field for later use
		IF (Length = .Length - 1) LEQ 0 			       ! Consume the "+" and
		THEN
		    SIGNAL(DBG$_INCOMPOPR, 1, ..Operand_number);	       !  make sure there is more		M007
		END;

	    IF .Buffer[.Length-1] EQL %C')' THEN			       ! (Rn)?
		BEGIN
		DECR Start FROM .Length-1 TO 1 DO			       ! Look for matching "("
		  IF .Buffer[.Start-1] EQL %C'(' THEN
		    BEGIN
		    Regnum = Parse_Register(Buffer[.Start],.Length-1-.Start);  ! Get the register number
		    IF (.Regnum EQL 15) 		       		       ! Dissallow the PC
		    THEN
			SIGNAL(DBG$_PCNOTALL, 1, ..Operand_number);	       !					M007
		    IF .R_Mode GTR 0 THEN				       ! Autoincrement from above?
			BEGIN						       ! Yes.  We must have a register
			IF .Regnum LSS 0 				       ! Bad register
			THEN
			    SIGNAL(DBG$_REGREQ, 1, ..Operand_number);	       !					M007
			IF (.Indexed_Regnum EQL .Regnum) AND		       ! The indexed and base registers cannot be the A005
			   (.R_Mode EQL %X'80') 			       ! same if the register is autoincrement	      A005
			THEN
			    SIGNAL(DBG$_INDBASEQL, 1, ..Operand_number);       !					M007
			Length = .Start - 1;				       ! Consume the (Rn)
			LEAVE trim;					       ! Done trimming
			END;
		    IF .Regnum LSS 0					       ! Bad register
		    THEN
			SIGNAL(DBG$_REGREQ, 1, ..Operand_number);	       !				M007
		    IF .Start EQL 1					       ! "(" is the start?
			THEN R_Mode = %X'60'				       ! Yes, Construct register deferred
		    ELSE IF (.Buffer[0] EQL %C'-') AND (.Start EQL 2)	       ! Test for autodecrement
			THEN R_Mode = %X'70';				       ! Construct autodecrement
		    IF .R_Mode GTR 0 THEN				       ! Do we have something?
			BEGIN						       ! Yes
			IF (.Indexed_Regnum EQL .Regnum) AND		       ! The indexed and base registers cannot be the A005
			   (.R_Mode EQL %X'70') 			       ! same if the register is autodecrement	      A005
			THEN
			    SIGNAL(DBG$_INDBASEQL, 1, ..Operand_number);        !					M007
			Regnum = .Regnum + .R_Mode;			       ! Construct the mode and register
			Store_Operand(.EnCode,Regnum,1);		       ! Store the byte
			LEAVE scan;					       ! Done scanning
			END;
		    Length = .Start - 1;				       ! Consume the (Rn)
		    R_Mode = %X'A0';	! Byte, Word, or Long handled later    ! Assume simple displacement
		    Displacement_size_needed = 1;			       ! We don't know the displacement size yet.     A005
		    LEAVE trim;						       ! Done trimming
		    END;
		END
	    ELSE IF .R_Mode GTR 0 THEN Report_Error;			       ! Autoincrement and no ")"
	    END;		! End of block 'trim'

	!+
	! We get here with Regnum and R_Mode indicating the current
	! state of the parse. Possible values are :-
	!
	!     R_Mode	     Regnum
	!	 0		*	no register operands seen
	!	-1		*	[Rn] has been generated
	!	80		n	(Rn)+ parsed (not generated)
	!	A0		n	(Rn) seen - displacement expected
	!				 (mode will be changed if needed)
	!-

	IF (.Length GTR 0) AND (.Buffer[0] EQL %C'@') THEN		       ! Leading "@"?
	    BEGIN							       ! Yes
	    Length = .Length - 1;					       ! Consume it.
	    Buffer = .Buffer + 1;
	    Defer  = %X'10';						       ! Set defered mode
	    END
	ELSE								       ! No
	    Defer  = 0;							       ! Clear defered mode

	IF .R_Mode EQL %X'80' THEN					       ! Autoincrement from above?
	    BEGIN							       ! Yes
	    IF .Length NEQ 0 THEN SIGNAL(DBG$_OPSYNTAX, 1, ..Operand_number);  ! More in front error			M007
	    Regnum = .Regnum + .R_Mode + .Defer;			       ! Construct
	    Store_Operand(.EnCode,Regnum,1);				       ! Store operand
	    LEAVE scan;							       ! Done
	    END;

	!++
	! By now (Rn), (Rn)+, -(Rn), @(Rn)+ are done
	!--
	IF (.Length LEQ 0) THEN SIGNAL(DBG$_INCOMPOPR, 1, ..Operand_number);   ! There must be more.			M007

Addr:	BEGIN								       ! Addr-expr got caught where Rn was parsed     A005
	IF (.Buffer[0] EQL %C'#') THEN					       ! Look for literals
	    BEGIN
	    Buffer = .Buffer + 1;					       ! Consume the "#"
	    Length = .Length - 1;
	    IF (.Length LEQ 0) OR (.R_Mode GTR 0) THEN Report_Error;	       ! There must be more and we can't have a register
	    IF (.Defer EQL 0) AND (.R_Mode LSS 0) THEN Report_Error;	       ! Indexed mode not allowed with literals
	    R_Mode = %X'80';						       ! Assume immediate mode
	    Regnum = %X'0F';
	    END
	ELSE								       ! Not a "#" in front
	    BEGIN
	    IF (.Length LSS 2) OR (.Buffer[1] NEQ %C'^') THEN		       ! Not ?^xxxxx
		BEGIN
		IF (.R_Mode NEQ 0) OR (.Defer NEQ 0)
		  OR (Parse_Register(.Buffer,.Length) LSS 0)
		    THEN 						       ! We have a Relative addr		      A005
			BEGIN						       !					      A005
			IF .R_Mode LEQ 0 				       ! Has a (Rn) been seen?			      A005
			THEN						       ! No					      A005
			    BEGIN					       !					      A005
			    Regnum = 15;				       ! Construct the register			      A005
			    R_Mode = %X'A0';				       ! Construct the mode			      A005
			    Displacement_size_needed = 1;		       ! The displacement size must be determined     A005
			    END;					       !					      A005
			LEAVE Addr;					       ! We must have an Addr-expr		      M005
			END;						       !					      A005
		Regnum = Parse_Register(.Buffer, .Length) + %X'50';	       ! Simple register mode
		Store_Operand(.EnCode,Regnum,1);			       ! Store it
		LEAVE scan;						       ! Done
		END
	    ELSE
Mode:		BEGIN							       ! We have ?^xxxx
		BIND Mode_Char = UPLIT BYTE('BWLGIS') : VECTOR[6,BYTE];	       ! The possible ?
		INCR Index FROM 0 TO 5 DO				       ! Scan down the list
		  IF (.Buffer[0] EQL .Mode_Char[.Index]) THEN		       ! Did we find one
		    BEGIN
		    Buffer = .Buffer + 2;				       ! Consume the ^?
		    Length = .Length - 2;
		    IF (.Length LEQ 0) 					       ! There must be more
		    THEN
			SIGNAL(DBG$_INCOMPOPR, 1, ..Operand_number);	       !					M007
		    IF .Index LEQ 3 THEN				       ! One of BWLG
			BEGIN
			IF (.Index EQL 3) AND				       ! If G^
			  ((.R_Mode GTR 0) OR (.Defer NEQ 0))		       ! must not have (Rn) on end or @ in front
			    THEN Report_Error;
			IF (.R_Mode LEQ 0) THEN				       ! When there was no (Rn)
			    BEGIN
			    R_Mode = %X'A0';				       ! Do the right thing for relative
			    Regnum = %X'0F';				       ! and relative defered
			    END;
			R_Mode = .R_Mode + (.Index*%X'20');		       ! Construct the mode
			Displacement_size_needed = 0;			       ! The displacement size has been given to us   A005
			END
		    ELSE
			BEGIN
			IF (.R_Mode GTR 0) OR (.Defer GTR 0)		       ! (Rn) and @ not allowed
			  OR (.Buffer[0] NEQ %C'#') THEN Report_Error;	       ! Must have #
			R_Mode = %X'80' + (.Mode_Char[.Index]^16);	       ! Construct the right mode
			Regnum = %X'0F';				       ! The right register
			Buffer = .Buffer + 1;				       ! Consume the #
			Length = .Length - 1;				       ! Wrong sign				      M005
			IF (.Length LEQ 0) 				       ! There must be a addr-expr left
			THEN
			    SIGNAL(DBG$_INCOMPOPR, 1, ..Operand_number);       !					M007
			END;
		    LEAVE Mode;						       ! Done
		    END;
		SIGNAL(DBG$_BWLGISMUS, 1, ..Operand_number);		       ! Wrong char in front of ^
		END;		! End of block 'mode'
	    END;

	IF (((.R_Mode + .Regnum + .Defer) AND %X'FF') EQL %X'8F') THEN
	    BEGIN
	    !+
	    ! We get here if there is an immediate-mode operand.
	    ! We now read the value using the EXPRESSION  syntax
	    ! of the current language and convert it to the type
	    ! required by this instruction.
	    ! Short literals are also handled here. These can be
	    ! differentiated  from other immediate-mode operands
	    ! by examining the high word of R_Mode (set to %C'S'
	    ! for short literals, and 0 or %C'I' otherwise).
	    !-
	    LOCAL								!				A008
		Val_desc_target : REF DBG$VALDESC,				!				A008
		Val_desc_source : REF DBG$VALDESC,				!				A008
		vms_desc_source : BLOCK[ 8, BYTE ],				!				A008
		vms_desc_target : BLOCK[ 8, BYTE ];				!				A008

	    IF .R_Mode<16,8,0> EQLU %C'S' THEN
	      SELECTONE .Context OF
		SET
		[context_f,context_d,
		 context_g,context_h]:
			context = context_f;
		[OTHERWISE]:
			context = context_l;
		TES;

	    !++
	    ! Set up the source
	    !--
	    vms_desc_source[dsc$b_class]   =  dsc$k_class_s;			! A008
	    vms_desc_source[dsc$b_dtype]   = DSC$K_DTYPE_T;			! A008
	    vms_desc_source[dsc$w_length]  = .Length;				! A008
	    vms_desc_source[dsc$a_pointer] = .Buffer;				! A008
	    
	    !++
	    ! Set up the target
	    !--
	    vms_desc_target[dsc$b_class]   =  dsc$k_class_s;			!	 				A008
	    vms_desc_target[dsc$b_dtype]   = .Data_Type[.context];		! 					A008
	    vms_desc_target[dsc$w_length]  = .Data_Size[.context];		! 					A008
	    vms_desc_target[dsc$a_pointer] =  Op_Buffer;			!					A008

	    Op_Buffer[0,0,32,0] = 0;	! Clear high operand bytes							A008
	    Op_Buffer[4,0,32,0] = 0;	! to extend to octaword value							A008
	    Op_Buffer[8,0,32,0] = 0;	! 										A008
	    Op_Buffer[12,0,32,0] = 0;	! 										A008

	    Val_desc_source = dbg$make_val_desc( vms_desc_source, dbg$k_v_value_desc );! Convert to a value descriptor  A008

	    !++
	    ! Test for negatives and fix things up
	    !
	    ! DBGCONV_TEXT_VALUE does not accept the negative sign
	    ! in the value, but it requires a flag in the value
	    ! descriptor.
	    !--
	    IF CH$RCHAR( .Val_desc_source[ DBG$L_VALUE_POINTER ] ) EQL %C'-'						! A008
	    THEN													! A008
		BEGIN													! A008
		Val_desc_source[ DBG$L_VALUE_POINTER ] = .Val_desc_source[ DBG$L_VALUE_POINTER ] + 1;			! A008
		Val_desc_source[ DBG$W_VALUE_LENGTH  ] = .Val_desc_source[ DBG$W_VALUE_LENGTH  ] - 1;			! A008
		Val_desc_source[ DBG$W_VALUE_SIGN_CODE ] = TOKEN$K_NEGCONST;						! A008
		END;													! A008

	    !++
	    ! Send in the right radix so it will do the right conversion
	    !--
	    Val_desc_source[ DBG$W_VALUE_TOKENCODE ] = 									! A008
		(SELECTONE .DBG$GB_RADIX[DBG$B_RADIX_INPUT] OF								! A008
		    SET													! A008
		    [DBG$K_BINARY]  : TOKEN$K_BIN_INTEGER;								! A008
		    [DBG$K_OCTAL]   : TOKEN$K_OCT_INTEGER;								! A008
		    [DBG$K_HEX]     : TOKEN$K_HEX_INTEGER;								! A008
		    [DBG$K_DECIMAL] : TOKEN$K_INTEGER;									! A008
		    [OTHERWISE]     : $DBG_ERROR( 'DBGENCDEC\PARSER_OPERAND unexpected radix');				! A008
		    TES);			     									! A008

	    !++
	    ! Make the target value descriptor
	    !--
	    Val_desc_target = dbg$make_val_desc( vms_desc_target, dbg$k_value_desc );

	    Val_desc_target = DBG$CONV_TEXT_VALUE( .Val_desc_source,		      ! Convert the number		A008 A005
						   .Val_desc_target,		      !					A008 A005
						   .vms_desc_target[dsc$b_dtype]);    !					A008 A005

	    !++
	    ! Move the converted value in 
	    ! normally it is already in  Op_buffer but in the case
	    ! of negative numbers the routines used change the
	    ! pointer rather than move the data.
	    !--
	    CH$MOVE( .Val_desc_target[ DBG$W_VALUE_LENGTH ],								! A008
		     CH$PTR( .Val_desc_target[ DBG$L_VALUE_POINTER ] ), 						! A008
		     CH$PTR( Op_buffer ) );										! A008

	    IF (.R_Mode<16,8,0> EQLU %C'S') OR  ((.R_Mode<16,8,0> EQL 0) AND
		(.Op_Buffer[0,0,32,0] LSSU %X'40') AND (.Op_Buffer[4,0,32,0] EQL 0) AND
		((.Context EQL context_b) OR (.Context EQL context_bu) OR
		 (.Context EQL context_w) OR (.Context EQL context_wu) OR
		 (.Context EQL context_l) OR (.Context EQL context_q))) THEN
		BEGIN
		BUILTIN ROT;
		IF (.Context EQL context_f) THEN
		    Operand_value = ROT((.Operand_Value XOR %X'4000'),-4);
		IF (.Operand_Value GTRU %X'3F') THEN Report_Error;
		Store_Operand(.EnCode,Operand_Value,1);
		END
	    ELSE
		BEGIN
		Store_Operand(.EnCode,UPLIT BYTE(%X'8F'),1);
		Store_Operand(.EnCode,Operand_Value,.Data_Size[.Context]);
		END;
	    LEAVE scan;
	    END;
	END;								       ! End Addr.				      A005

	!+
	! Here if we have an register/displacement operand,
	! or an absolute address (explicit or implicit).
	!
	IF NOT Parse_Expression(-1,.Buffer,.Length,Address) THEN SIGNAL(DBG$_INVEXPR, 1, ..Operand_number);	!	M007
	IF (Check_Register(.Address) GEQ 0) THEN SIGNAL(DBG$_INVEXPR, 1, ..Operand_number);			! 	M007

	IF (.R_Mode EQL %X'100') THEN R_Mode =			! G^<address>
	    (IF (.Address GEQU %X'40000000') THEN %X'90' ELSE %X'E0');

	IF .Displacement_size_needed THEN				       !A005 We need to chose a displacement size
	     R_Mode = (IF (.Regnum EQL 15)				       !A005 PC relative displacement?
		      THEN						       !A005 Yes
			(SELECTONE .Address - 				       !A005 Calculate the offset without the length of
				   (1 + .Encode[Enc_Final_Address] +	       !A005 the operand since we don't know it.
				   .EnCode[Enc_Output_Length]) OF	       !A005 
			SET						       !A005 
			[-127     TO 128]:	%X'A0';			       !A005 Byte  Note that the table has been adjusted to
			[-32766   TO 32769]:	%X'C0';			       !A005 Word  take the lack of length in the address
			[OTHERWISE]:		%X'E0';			       !A005 Long  calculation into account.
			TES)						       !A005
		      ELSE
			(SELECTONE .Address OF				       !A005 
			SET						       !A005
			[-128     TO 127]:		%X'A0';		       !A005 Byte
			[-32768   TO 32767]:		%X'C0';		       !A005 Word
			[OTHERWISE]:			%X'E0';		       !A005 Long
			TES));						       !A005

	Length = (IF ((.R_Mode EQL %X'90') OR (.R_Mode EQL %X'80')) 	       ! Long operand?				      M005
		  THEN 4
		  ELSE 1^((.R_Mode-%X'A0')/%X'20'));
	IF (.Regnum EQL 15) AND (.R_Mode NEQ %X'80') AND (.R_Mode NEQ %X'90')  ! Regnum of 15 means PC relative except 	      M005 
	THEN Address = .Address - (1 + .Length + .Encode[Enc_Final_Address] +  ! Absolute and immediate			     
						 .EnCode[Enc_Output_Length]);

	R_Mode = .R_Mode + .Defer + .Regnum;
	Store_Operand(.EnCode,R_Mode,1);
	Store_Operand(.EnCode,Address,.Length);
	END;			! End of block 'scan'

    EnCode[Enc_Input_Buffer] = .EnCode[Enc_Input_Buffer] + .Parsed;
    EnCode[Enc_Input_Length] = .EnCode[Enc_Input_Length] - .Parsed;
    IF .EnCode[Enc_Input_Length] GTR 0 THEN
	BEGIN
	EnCode[Enc_Input_Buffer] = .EnCode[Enc_Input_Buffer] + 1;
	EnCode[Enc_Input_Length] = .EnCode[Enc_Input_Length] - 1;
	END;
    END;

ROUTINE Parse_Expression(type,string,length,result) =
    BEGIN

    Routine Get_Result(Input_Desc,Result,Type) =
	BEGIN

	Routine Handler(sig_args,mch_args) =
	    BEGIN
	    MAP	mch_args : REF BLOCK[,BYTE];
	    EXTERNAL ROUTINE Sys$Unwind : Addressing_Mode(General);
	    mch_args[chf$l_mch_savr0] = 0;
	    Sys$Unwind(0,0);
	    RETURN ss$_continue;
	    END;		! End of routine 'handler'

	BUILTIN FP;
	LOCAL valdesc : REF dbg$valdesc;

	.FP = Handler;
	IF (.Type LSS 0) THEN
	    BEGIN
	    ! Type < 0 means we want an address expression

	    IF NOT DBG$Nparse_Address(.Input_Desc,valdesc,
		dbg$k_default,token$k_term_none,0) THEN RETURN False;

	    IF NOT DBG$Prim_To_Val(.valdesc,dbg$k_v_value_desc,valdesc)
		THEN RETURN False;

	    .Result = .valdesc[dbg$l_value_pointer];
	    END
	ELSE
	    BEGIN
	    EXTERNAL dbg$gl_deposit_token;
	    LOCAL vms_desc : BLOCK [8,BYTE];

	    ! Type > 0 means we want a value expression

	    IF NOT DBG$Nparse_Expression(.Input_Desc,dbg$k_default,
			valdesc,token$k_term_none,0) THEN RETURN False;

	    vms_desc[dsc$b_class]   =  dsc$k_class_s;
	    vms_desc[dsc$b_dtype]   = .Data_Type[.Type];
	    vms_desc[dsc$w_length]  = .Data_Size[.Type];
	    vms_desc[dsc$a_pointer] =  Op_Buffer;

	    Op_Buffer[0,0,32,0] = 0;	! Clear high operand bytes
	    Op_Buffer[4,0,32,0] = 0;	! to extend to quad value
	    DBG$COVER_DX_DX(.valdesc, 					       ! Convert the number			     A005
			    dbg$make_val_desc(vms_desc,dbg$k_v_value_desc),    !					     A005
			    false);					       !					     A005
!	    DBG$Eval_Lang_Operator(dbg$gl_deposit_token,.valdesc,	       ! Delete because if follows language rules    D005
!		dbg$make_val_desc(vms_desc,dbg$k_v_value_desc));	       !					     D005

	    END;
	RETURN True;
	END;			! End of routine 'get_Result'

    LOCAL
	Mark,Status,
	Term_Char	: BYTE UNSIGNED,
	Term_Addr	: REF VECTOR [1,BYTE],
	Local_Desc	: BLOCK [8,BYTE];

    Local_Desc[dsc$b_class]   = dsc$k_class_s;
    Local_Desc[dsc$b_dtype]   = dsc$k_dtype_t;
    Local_Desc[dsc$w_length]  = .length;
    Local_Desc[dsc$a_pointer] = .string;

    Mark = dbg$push_tempmem();
    Term_Addr = .string + .length;
    Term_Char = .Term_Addr[0];
    Term_Addr[0] = 13;
    Status = Get_Result(Local_Desc,.Result,.Type);
    Term_Addr[0] = .Term_Char;
    dbg$pop_tempmem(.Mark);
    RETURN .Status;
    END;

ROUTINE Parse_Register(string,length) =
    BEGIN
    BIND								       !				       A006
    	Two_char_register = .string + .length - 2 : BLOCKVECTOR [1,WORD],      ! The last 2 characters		       A006
    	Three_char_register = .string + .length - 3 : BLOCKVECTOR [1,3];       ! The last 3 characters		       A006
									       !				       A006
    IF .length LSS 2							       ! There must be at least 2 characters   A006
    THEN								       !				       A006
	RETURN -1;							       !				       A006
									       !				       A006
    SELECTONE .Two_char_register[ 0, 0, 0, 16, 0 ] OF			       ! First character		       A006
	SET								       !				       A006
	[ .UPLIT('R0') ]: 	RETURN 0;				       !				       A006
	[ .UPLIT('R1') ]: 	RETURN 1;				       !				       A006
	[ .UPLIT('R2') ]: 	RETURN 2;				       !				       A006
	[ .UPLIT('R3') ]: 	RETURN 3;				       !				       A006
	[ .UPLIT('R4') ]: 	RETURN 4;				       !				       A006
	[ .UPLIT('R5') ]: 	RETURN 5;				       !				       A006
	[ .UPLIT('R6') ]: 	RETURN 6;				       !				       A006
	[ .UPLIT('R7') ]: 	RETURN 7;				       !				       A006
	[ .UPLIT('R8') ]: 	RETURN 8;				       !				       A006
	[ .UPLIT('R9') ]: 	RETURN 9;				       !				       A006
	[ .UPLIT('AP') ]:	RETURN 12;				       !				       A006
	[ .UPLIT('FP') ]:	RETURN 13;				       !				       A006
	[ .UPLIT('SP') ]:	RETURN 14;				       !				       A006
	[ .UPLIT('PC') ]:	RETURN 15;				       !				       A006
	[ OTHERWISE ]:							       ! Might be a 3 character register       A006
	    BEGIN							       !				       A006
	    IF .length LSS 3						       ! There must be at least 3 characters   A006
	    THEN							       !				       A006
		RETURN -1;						       !				       A006
									       !				       A006
	    SELECTONE .Three_char_register[ 0, 0, 0, 24, 0 ] OF		       !				       A006
		SET							       !				       A006
		[ .UPLIT('R10') ]:		RETURN 10;		       !				       A006
		[ .UPLIT('R11') ]:		RETURN 11;		       !				       A006
		[ .UPLIT('R12') ]:		RETURN 12;		       !				       A006
		[ .UPLIT('R13') ]:		RETURN 13;		       !				       A006
		[ .UPLIT('R14') ]:		RETURN 14;		       !				       A006
		[ .UPLIT('R15') ]:		RETURN 15;		       !				       A006
		[ OTHERWISE ]:			RETURN -1;		       !				       A006
		TES;							       !				       A006
	    END;							       !				       A006
	TES;								       !				       A006
    END;





ROUTINE Check_Register(Address : UNSIGNED) =
    BEGIN
    EXTERNAL dbg$reg_values;
    Address = .Address - dbg$reg_values;	! ** NOTE NO "."
    IF (.Address GTRU 15*%UPVAL) THEN RETURN -1;
    IF ((.Address AND (%UPVAL-1)) NEQ 0) THEN RETURN -1;
    RETURN .Address/%UPVAL;
    END;

ROUTINE Store_Operand(EnCode,Operand,Length) : NOVALUE =
    BEGIN
    MAP
	EnCode	: REF BLOCK [20,BYTE] FIELD(EnCode_Fields),
	Operand	: REF VECTOR [ ,BYTE];

    ch$move(.Length, Operand[0],
	    .EnCode[Enc_Output_Length] + .EnCode[Enc_Output_Buffer]);

    EnCode[Enc_Output_Length] = .EnCode[Enc_Output_Length] + .Length;
    END;

ROUTINE Print_Address(Address) : NOVALUE =
    BEGIN
    LOCAL mark;
    mark = DBG$Push_Tempmem();
    DBG$Print_Identifier_PC(.Address);
    DBG$Pop_Tempmem(.mark);
    END;

ROUTINE Print_Operand(Context) : NOVALUE =
    BEGIN
    LOCAL
	mark,
	vms_desc	: dbg$stg_desc;

    mark = DBG$Push_Tempmem();
    vms_desc[dsc$b_class]   = dsc$k_class_s;
    vms_desc[dsc$b_dtype]   = .data_type[.context];
    vms_desc[dsc$w_length]  = .data_size[.context];
    vms_desc[dsc$a_pointer] = Op_Buffer;
    DBG$Print_Value(DBG$Make_Val_Desc(vms_desc,dbg$k_value_desc),dbg$k_default,False,False);
    DBG$Pop_Tempmem(.mark);
    END;

ROUTINE Scan_Operand(Input_Desc : REF dbg$stg_desc,Delimiter) =
    BEGIN
    BUILTIN ACTUALCOUNT,ACTUALPARAMETER;
    LOCAL
	Depth,
	Local_Desc  : dbg$stg_desc,
	char	    : BYTE UNSIGNED;

    Depth = (IF Actualcount() LSS 3 THEN 0 ELSE Actualparameter(3)+1);

    Skip_Leading_Blanks(.Input_Desc);

    ch$move(8,Input_Desc[0,0,0,0],Local_Desc[0,0,0,0]);

    WHILE .Local_Desc[dsc$w_length] GEQ 0 DO
	BEGIN
	LOCAL Target,Length;
	char = (IF .Local_Desc[dsc$w_length] EQL 0 THEN 0
		ELSE .(.Local_Desc[dsc$a_pointer])<0,8,0>);
	Target = 0;
	IF .char EQL %X'09' THEN (.Local_Desc[dsc$a_pointer])<0,8,0> = char = %C' ';
	IF .char EQL .Delimiter THEN
	  RETURN (.Local_Desc[dsc$a_pointer] - .Input_Desc[dsc$a_pointer])
	ELSE IF .char EQL  0  THEN EXITLOOP;
	IF .Delimiter NEQ %C'"' THEN
	    BEGIN
	    IF (.char GEQ %C'a') AND (.char LEQ %C'z')
	    THEN (.Local_Desc[dsc$a_pointer])<0,8,0> = .char - (%C'a'-%C'A')
	    ELSE IF .char EQL %C'"' THEN Target = %C'"'
	    ELSE IF .char EQL %C'(' THEN Target = %C')'
	    ELSE IF .char EQL %C'[' THEN Target = %C']';
	    END;
	Local_Desc[dsc$w_length]  = .Local_Desc[dsc$w_length]  - 1;
	Local_Desc[dsc$a_pointer] = .Local_Desc[dsc$a_pointer] + 1;
	IF .Target NEQ 0 THEN
	    BEGIN
	    Length = Scan_Operand(Local_Desc,.Target,.Depth) + 1;
	    Local_Desc[dsc$w_length]  = .Local_Desc[dsc$w_length] -.Length;
	    Local_Desc[dsc$a_pointer] = .Local_Desc[dsc$a_pointer]+.Length;
	    END;
	END;
    IF .Depth NEQ 0 THEN SIGNAL(dbg$_nodelimtr);
    RETURN .Input_Desc[dsc$w_length];
    END;

ROUTINE Skip_Leading_Blanks(Input_Desc : REF dbg$stg_desc) : NOVALUE =
    BEGIN
    WHILE .Input_Desc[dsc$w_length] GTR 0 DO
	BEGIN
	LOCAL char : BYTE UNSIGNED;
	char = .(.Input_Desc[dsc$a_pointer])<0,8,0>;
	IF (.char NEQ %X'20') AND (.char NEQ %X'09') THEN EXITLOOP;
	Input_Desc[dsc$w_length]  = .Input_Desc[dsc$w_length]  - 1;
	Input_Desc[dsc$a_pointer] = .Input_Desc[dsc$a_pointer] + 1;
	END;
    END;

END
ELUDOM
