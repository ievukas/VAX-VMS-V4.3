module uafmain (main = start,
		language (bliss32),
		ident = 'V04-000',
		addressing_mode (external=general, nonexternal=general)
		) =
begin

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************

!++
! FACILITY:	System Management Utility Program
!
! ABSTRACT:
!
!	This program allows the system manager to maintain the user
!	authorization file which contains usernames, passwords, quotas,
!	and defaults.  The following functions are provided:
!
!		ADD - add a new user record to the authorization file (UAF)
!     		COPY - copy a user record, give copied record a new name
!		DEFAULT - change a default value
!		EXIT - exit program and update file
!		HELP - ask for explanation
!		LIST - complete list of records to file
!		MODIFY - change one or more values for a user
!		REMOVE - remove a user record
!		RENAME - rename a user record (COPY; REMOVE)
!		SHOW - display the values from a user record
!
! ENVIRONMENT:
!
! AUTHOR:	Henry M. Levy, CREATION DATE: 1-June-1977
!
! MODIFIED BY:
!
!	V03-024	JRL0036		John R. Lawson, Jr.	07-Aug-1984 17:08
!		Hide UPGRADE, DOWNGRADE, TMPJNL, PRMJNL privileges.  This
!		is a temporary work-around; it is marked in the right-hand
!		margin with !** in routine PRINT_PRIV.
!
!	V03-023	JRL0027		John R. Lawson, Jr.	25-Jul-1984 11:01
!		Add MODIFY/SYSTEM_PASSWORD=xxxxx to modify the system
!		password.
!
!	V03-022	JRL0029		John R. Lawson, Jr.	25-Jul-1984 10:47
!		Find better names for UAF$_NEWMSG10 and UAF$_NEWMSG15
!
!	V03-021	JRL0020		John R. Lawson, Jr.	09-Jul-1984 15:51
!		Bark when a proxy name is changed with the RENAME command.
!
!	V03-020	JRL0017		John R. Lawson, Jr.	02-Jul-1984 22:13
!		Modify GET_UAF_RECORD so that it does not get the system
!		password record.
!
!	V03-029	JRL0013		John R. Lawson, Jr.	02-Jul-1984 12:28
!		Display privileges of users in groups less than .EXE$GL_SYSUIC
!		as "ALL".
!
!	V03-028	JRL0010		John R. Lawson, Jr.	25-Jun-1984 15:56
!		Changed 'X'/'-' to '#'/'-' in primary/secondary access
!		display.
!
!	V03-027	JRL0008		John R. Lawson, Jr.	21-Jun-1984 14:00
!		Add support for the /PWDEXPIRED qualifier (pre-expired
!		password).
!
!	V03-026	JRL0006		John R. Lawson, Jr.	20-Jun-1984 12:28
!		Obliterate operator's console messages
!
!	V03-025 JRL0002		John R. Lawson, Jr.	15-Jun-1984 09:55
!		Change all internal messages to calls to LIB$SIGNAL and
!		the message utility -- place all messages in UAFMSG.MSG
!
!	V03-024	LY0494		Larry Yetto		11-JUN-1984 12:59
!		Fix noise error message comming from ADD/ID/USER=* caused
!		by a flag not properly being set
!
!	V03-023	MHB0150		Mark Bramhall		 2-May-1984
!		Remove unused reference to TPARSE definitions.
!		Add DISRECONNECT flag.
!		Add security auditing for SYSUAF/NETUAF changes.
!
!	V03-022	LY0474		Larry Yetto		 9-APR-1984 08:32
!		Zero the login failure and last login fields
!		on a copy operation.
!
!	V03-021	LY0466		Larry Yetto		22-MAR-1984 13:52
!		Add support for the rights data base functions
!
!	V03-020	ACG0397		Andrew C. Goldstein,	24-Feb-1984  23:21
!		Clean up display formatting
!
!	V03-019	ACG0397		Andrew C. Goldstein,	6-Feb-1984  16:27
!		Add DISREPORT to flags, clean up record locking
!
!	V03-018	ACG0388		Andrew C. Goldstein,	12-Jan-1984  19:21
!		Add command input to handle new UAF features;
!		general code cleanup
!
!	V03-017	ACG0385		Andrew C. Goldstein,	6-Jan-1984  18:28
!		V4 UAF format change; remove read-only under installed
!		SYSPRV feature; misc. code cleanups
!
!	V03-016	TMK0001		Todd M. Katz		10-Oct-1983
!		Add JTQUOTA (job-wide logical name table creation quota)
!		qualifier.
!
!	V03-015	LMP0153		L. Mark Pilant,		13-Sep-1983  11:57
!		Add minimal support for alphanumeric UICs.
!
!	014	JWT0105		Jim Teague	30-Mar-1983
!		Small changes to CLITABLES implementation.
!
!	013	JWT0104		Jim Teague	29-Mar-1983
!		Add CLITABLES qualifier.
!
!	012	WMC0001		Wayne Cardoza	15-Mar-1983
!		Add MAXDETACH qualifier.
!
!	011	JWT0097		Jim Teague	23-Feb-1983
!		Fix RENAME problem with proxy entries.
!
!	010	JWT0096		Jim Teague	08-Feb-1983
!		Log NETUAF changes to console, too.
!
!	009	JWT0087		Jim Teague	11-Jan-1983
!		Change SYSWSQUOTA for created UAFs to 350
!
!	008	JWT0082		Jim Teague	05-Jan-1983
!		Fix problem with LIST/PROXY.
!
!	007	JWT0079		Jim Teague	15-Dec-1982
!		Enlarge output field for BYTLM; reset pending
!		mail count for COPY operations.
!
!	006	JWT0072		Jim Teague	03-Dec-1982
!		Add global longword which can be patched to
!		enable/disable console logging of SYSUAF mods.
!
!	005	JWT0069		Jim Teague	24-Nov-1982
!		Allow redefinition of sys$output.
!
!	004	JWT0057		Jim Teague	21-Sep-1982
!		Add a message to tell whether or not NETUAF was
!		modified.  
!
!	003 	JWT0042		Jim Teague	15-Jul-1982
!		Make SYSUAF.LIS and NETUAF.LIS world noread.
!
!	002	JWT0036		Jim Teague	08-Jun-1982
!		Add full wildcarding to show/proxy
!
!	001	JWT0022		Jim Teague	17-Mar-1982
!		Fix bug that caused failure to reparse command line for
!		wildcard modifications.  List default device on its own
!		line for show/full.
!
!--

!
! Require files
!
require
	'lib$:uafreq';

!
! INCLUDE FILES:
!
library 'SYS$LIBRARY:LIB.L32';

!
! TABLE OF CONTENTS:
!

forward routine
	start,				! controlling code
	setup		: novalue,	! open initial files
	add_uaf		: novalue,	! insert new user record
	add_proxy	: novalue,	! insert new proxy record
	remote_parse,			! parses "node: : remoteuser"
 	copy_uaf,			! copy user record
	create_proxy	: novalue,	! create NETUAF.DAT proxy file
	modify_uaf	: novalue,	! update user record(s)
	modify_rec,			! update a user record action routine
	remove_uaf	: novalue,	! remove username from file
	remove_proxy	: novalue,	! remove a proxy record
	rename_uaf	: novalue,	! rename user record
	adjust_proxy	: novalue,	! implicitly remove/update proxy record
	default_uaf	: novalue,	! change default record
	list_proxy	: novalue,	! list proxy entries in NETUAF.LIS
	list_uaf	: novalue,	! list file routine
	show_user_uaf	: novalue,	! display user record
	show_proxy 	: novalue,	! display proxy record at terminal
	locate_proxy,			! access given proxy record(s)
 	get_proxy_record,		! read single proxy record
	display_proxy   : novalue,	! format and output a proxy entry
	wild_user,			! user wild card routine
	display_brief,			! writes a brief user display
	classify_priv,			! classifies contents of priv vector
	display_full,			! writes the full user display
	display_hours	: novalue,	! display hourly restrictions
	convert_time	: novalue,	! convert time value to string
	print_priv	: novalue,	! print privilege bits
	build_ini_recs	: novalue,	! build initial file records for default
					! and system manager
	get_user_record,		! get username and lookup record
	locate_user,			! lookup user record in UAF
	get_uaf_record,			! routine to deal with record locking
	get_cmd_line,			! input user command line
	ask		: novalue,	! prompt terminal for input
	fmt_sys_msg	: novalue,	! output system message file message
	faoout,				! output formatted message
	help_uaf	: novalue,	! help routine
	exit_uaf	: novalue,	! normal exit routine
	SIGNAL_SYNTAX	: novalue,	! missing qualifier
	acc$exit	: novalue,	! exit and cleanup routine
	uaf$mod_sys_pwd	: novalue,	! modify the system password
	security_audit	: novalue;	! Perform a security audit

linkage
	fmg_match = jsb (register = 2, register = 3, register = 4,
			 register = 5) : notused (10, 11);

!
! EXTERNAL REFERENCES:
!

external literal
	cli$_bufovf,
	cli$_noclint;


external routine
	lbr$output_help,
	lib$get_foreign,
	lib$get_input,
	lib$put_output,
	fmg$match_name	: fmg_match,
	cli$dcl_parse,
	cli$dispatch,
	cli$present,
	cli$get_value,
	update_record,			! modify all specified fields
	parse_wild,			! parses a wildcarded user specification
	lgi$hpwd,			! hash password routine
	uaf$add_ident_recbuf,
	uaf$build_holder,
	uaf$find_uic ,
	uaf$remove_ident_recbuf,
	uaf$write_rights;

external
	EXE$GL_SYSUIC	: long ,
   	rdb_header_flag	: byte ,
	rdb_list_flag 	: byte ,
	attributes	: long ,
	holder		: $bblock[8] ,
	ident		: $bblock [4] ,
	authorize_commands,		! AUTHORIZE command parse tables
	prv$ab_names;			! address of privilege name table


!
! MACROS:
!
macro

    namelen (x, y) =
	begin
	builtin
	    locc;
	register
	    r0 = 0;
	locc (%ref(' '), %ref(x), y; r0);
	x - .r0
	end%,

    cstring[] = (uplit byte (%charcount (%string (%remaining)),
		%string (%remaining)))%,

    fatal[] = (fmt_sys_msg (%remaining); acc$exit ())%,
!
! Macros to check for success or failure from RMS
!
    rmsbad (string) = (not (rmserr = string)) %,
    rmsok (string) = (rmserr = string) %,
!
! Macros to set up and write an FAO string.
!
    faomac (faomsg)[] =
	begin
	faodsc[dsc$w_length] = . (faomsg)<0,8>;
	faodsc[dsc$a_pointer] = (faomsg) + 1;
	$fao (faodsc, rabptr[rab$w_rsz], disdsc $comma (%remaining)
			%remaining);
	$put (rab = .rabptr);
	end %,

    $comma[] =, %,

    output_null =
	begin
	rabptr[rab$w_rsz] = 0;
	$put (rab = .rabptr);
	end %,

!
! Macro to create string descriptor for command parameters and
!	qualifiers
!
    sd[a] =
	bind %name ('SD_',a) = $descriptor (a)%;

     sd (
      	'token1',	'token2',	'brief',	'full',
	'add_identifier',		'remove_identifier',
	'modify_identifier'
);

field
    descr_fields = 			! Define the fields for a DESCRIPTOR
	set
	length  = [dsc$w_length],
	dtype   = [dsc$b_dtype],
	class   = [dsc$b_class],
	pointer = [dsc$a_pointer]
	tes;

macro
    statdesc =
	$bblock [dsc$k_s_bln] field (descr_fields)
                  preset ( [length]  = 0,
	                   [dtype]   = dsc$k_dtype_t,
	                   [class]   = dsc$k_class_s,
	                   [pointer] = 0)%;

macro
    qualstr_desc (string) =
	$bblock [dsc$k_s_bln] field (descr_fields)
                  preset ( [length]  = (%charcount(string)),
                           [dtype]   = dsc$k_dtype_t,
                           [class]   = dsc$k_class_s,
                           [pointer] = (uplit byte (%string(string))))%;
own
    sd_attribresource	: qualstr_desc ('attributes.resource') ;

!
! EQUATED SYMBOLS:
!
literal
	cmdbufmax	= 508,		! maximum command length
	false		= 0,		! logical false
	true		= 1,		! logical true
	update_records	= 0,		! flag for proxy file adjustment
	remove_records	= 1,		!  "    "    "    "       "
	copy_flag	= 1,		! used in routine copy_uaf
	rename_flag	= 1,		! used in routine rename_uaf
	byte_length	= 8,		! bits per byte
	word_length	= 16,		! bits per word
	long_length	= 32,		! bits per longword
	retry_rlk	= 8,		! number of retries for a locked record
	sleep_rlk	= 500,		! ms to sleep before retrying
	cr		= 13,
	lf		= 10,
	zero		= 0,
	cmdbuflen	= 1024;		! size of user command buffer

global literal
	encrypt		= uaf$c_purdy_v, ! encryption algorithm to use
	disbuflen	= 132;		! size of display file output buffer

bind
	sysuaf_string	= uplit byte ('SYSUAF'),
	netuaf_string	= uplit byte ('NETUAF'),
	mod_act_dsc	= $descriptor ('modified'),
	add_act_dsc	= $descriptor ('added'),
	rem_act_dsc	= $descriptor ('removed'),
	fao_lin_dsc	= $descriptor ('PID=!XL !AS !AS !AS record !AS on !%D'),
	dbl_colon	= $descriptor ('::'),
!
! Define the system delta time to sleep before retrying to GET a locked record.
!
	wakedelta	= uplit long (-10*1000*sleep_rlk,-1),
!
! Default values for authorization file record.  These values are
! only used when a new authorization file is created.  If the file
! already exists, the default values are read from the first file
! record.
!
	defuser		= cstring ('DEFAULT'),	! default username
	defpass		= cstring ('USER'),	! default password
	defclitabl	= cstring ('DCLTABLES'), ! default CLI tables
	defact		= cstring (''),		! default account name
	defcli		= cstring ('DCL'),	! default command interpreter
	defowner	= cstring (''),		! owner's name
	deflgicmd	= cstring (''),		! default login command file
	defgrp		= %o'200',		! default group
	defmem		= %o'200',		! default member
	defdir		= cstring ('[USER]'),	! default directory name
	defdev		= cstring (''),		! default device name
	defbiolm	= 6,			! default buffered I/O limit
	defbytlm	= 4096,			! default buffered I/O buffer space
	defdiolm	= 6,			! default direct I/O limit
	deffillm	= 20,			! default open file limit
	defflags	= 0,			! default flag bits
	deftqcnt	= 10,			! default time queue entries
	defprccnt	= 2,			! default subprocess count
	defpri		= 4,			! default process priority
	defquepri	= 4,			! default queue priority
	defwsquota	= 200,			! default working set limit
	defdfwscnt	= 150,			! "default" working set default size
	defwsextent	= 500,			! default working set extent
	defcputim	= 0,			! default CPU time quota
	defastlm	= 10,			! default AST queue limit
	defpgflquota	= 10000,		! default paging file limit in pages
	defenqlm	= 10,			! default enqueue limit
	defpbytlm	= 0,			! default paged buffer I/O limit
	defshrfillm	= 0,			! default shared file limit
	defmaxjobs	= 0,			! default maximum concurrent jobs
	defmaxacctjobs	= 0,			! default maximum concurrent group jobs
	defmaxdetach	= 0,			! default maximum detached processes
	defjtquota	= 1024,			! default job-wide logical table quota
	defprimedays	= (			! Sat, Sun are default non-prime days
			  (1 ^ $bitposition (uaf$v_saturday)) or
			  (1 ^ $bitposition (uaf$v_sunday))
			  ), 
	defhours	= 0,			! default all hours to allow access
		defpriv	= uplit (		! default privilege vector
			  (
			  (1 ^ $bitposition (prv$v_netmbx)) or
			  (1 ^ $bitposition (prv$v_tmpmbx))
			  ), 0),
	defpwdlength	= 6,			! default min password length
	defpwdlife	= uplit (0,0),		! default password lifetime

!
! The following are the default values for the SYSTEM user.  When
! a new file is created, a system manager record is created.
!
	sysuser		= cstring ('SYSTEM'),
	syspass		= cstring ('MANAGER'),
	sysclitabl	= cstring ('DCLTABLES'),
	sysact		= cstring ('SYSTEM'),
	syscli		= cstring ('DCL'),
	sysowner	= cstring ('SYSTEM MANAGER'),
	syslgicmd	= cstring (''),
	sysgrp		= %o'1',
	sysmem		= %o'4',
	sysdir		= cstring ('[SYSMGR]'),
	sysdev		= cstring (''),
	sysbiolm	= 12,
	sysbytlm	= 20480,
	sysdiolm	= 12,
	sysfillm	= 20,
	sysflags	= 0,
	systqcnt	= 20,
	sysprccnt	= 10,
	syspri		= 4,
	sysquepri	= 4,
	syswsquota	= 350,
	syswsextent	= 1024,
	sysdfwscnt	= 150,
	syscputim	= 0,
	sysastlm	= 20,
	syspgflquota	= 10000,
	sysenqlm	= 20,
	syspbytlm	= 0,
	sysshrfillm	= 0,
	sysmaxjobs	= 0,
	sysmaxdetach	= 0,
	sysjtquota	= 1024,
	sysmaxacctjobs	= 0,
	sysprimedays	= (			! Sat, Sun are default non-prime days
			  (1 ^ $bitposition (uaf$v_saturday)) or
			  (1 ^ $bitposition (uaf$v_sunday))
			  ), 
	syshours	= 0,
	syspriv		= uplit (rep 2 of (%x'FFFFFFFF')),
	syspwdlength	= 8,			! default min password length
	syspwdlife	= uplit (0,0);		! default password lifetime

!
! GLOBAL STORAGE - must be before OWN for initialization purposes
!
global
	disbuf		: vector [disbuflen, byte], ! display buffer
	disdsc		: block [8, byte] initial (disbuflen, disbuf) ;

!
! OWN STORAGE:
!
own
	username_buf	: block [uaf$s_username, byte],
	pcb_sts		: bitvector [32],
	pid,
	username_dsc	: vector [2] initial (0, username_buf),
	recname_dsc 	: vector [2],
	file_dsc	: vector [2] initial (6),
	mod_default,			! DEFAULT record being modified by MODIFY command
	modify_flag	: long,		! SYSUAF modified
	netuaf_modified,		! NETUAF modified
	rename_ph2	: byte initial (false),
	olduserlen	: long,
	oldusername	: vector  [uaf$s_username,byte],
	newuserlen	: long,
	newusername	: vector  [uaf$s_username,byte],
	cmdbuf		: vector [cmdbuflen, byte], ! command buffer
	default_size	: word,
	default_record	: block [uaf$c_length, byte], ! default record held here
	pwddsc		: block [8, byte],	! password descriptor
	insize		: long,			! number of input chars
	brief_flag	: long,			! display option
	full_flag	: long,			! display option
	header_flag	: long,			! output header or not?


	infab	: $fab (		! FAB for terminal I/O
			fac = (get, put),
			rat = cr,
			fnm = 'SYS$INPUT'
			),

	inrab	: $rab (		! RAB for terminal I/O
			rac = seq,
			rop = pmt,
			fab = infab
			),

	outfab	: $fab (
			fac = (put),
			rat = cr,
			fnm = 'SYS$OUTPUT'
			),

	lstnam	: $nam (),		! needed for the DLT option

	lstpro	: $xabpro (
			pro = (rwd,rwd,rw)
			),

	lstfab	: $fab (		! FAB for UAF listing file
			fac = put,
			rat = cr,
			fnm = 'SYSUAF.LIS',
			shr = nil,
			org = seq,
			rfm = var,
			mrs = disbuflen,
			nam = lstnam,
			xab = lstpro
			),

	lstrab	: $rab (		! RAB for UAF listing file
			rac = seq,
			rbf = disbuf,
			fab = lstfab
			),

	nlstnam	: $nam (),

	nlstpro	: $xabpro (
			pro = (rwd,rwd,rw)
			),

	nlstfab	: $fab (		! FAB for NETUAF listing file
			fac = put,
			rat = cr,
			fnm = 'NETUAF.LIS',
			shr = nil,
			org = seq,
			rfm = var,
			mrs = disbuflen,
			nam = nlstnam,
			xab = nlstpro
			),

	nlstrab	: $rab (		! RAB for NETUAF listing file
			rac = seq,
			rbf = disbuf,
			fab = nlstfab
			),

	uafkey2	: $xabkey (		! XAB for User number key
			kref = 2,	! alternate key
			pos0 = $byteoffset (uaf$w_mem),
			siz0 = 2,
			dtp = bn2,
			flg = (chg,dup)
			),

	uafkey1	: $xabkey (		! XAB for Group number key
			kref = 1,	! alternate key
			pos0 = $byteoffset (uaf$l_uic),
			siz0 = 4,
			dtp = bn4,
			flg = (chg,dup),
			nxt = uafkey2
			),

	uafkey0	: $xabkey (		! XAB for USERNAME key
			kref = 0,	! primary key
			pos0 = $byteoffset (uaf$t_username),
			siz0 = uaf$s_username,
			nxt = uafkey1
			),

	uafpro	: $xabpro (		! XAB for file protection
			pro = (rwed, rwed), ! deny world access
			nxt = uafkey0
			),

	uaffab	: $fab (		! FAB for work file
			fop = cif,
			fac = (get, put, del, upd),
			fnm = 'SYSUAF',
			dnm = '.DAT',
			shr = (get, put, del, upd),
			org = idx,
			rfm = var,
			mrs = uaf$c_length,
			alq = 10,
			deq = 10,
			xab = uafpro
			),
!
! FAB for NETUAF Proxy Login File
!
!
	nafkey1	: $xabkey (
			kref = 1,
			pos0 = $byteoffset (naf$t_localuser),
			siz0 = naf$s_localuser,
			flg = (chg,dup)
			),

	nafkey0	: $xabkey (
			kref = 0,
			pos0 = $byteoffset (naf$t_remname),
			siz0 = naf$s_remname,
			nxt = nafkey1
			),

	nafpro	: $xabpro (
			pro = (rwed, rwed),
			nxt = nafkey0
			),

	naffab	: $fab (		! FAB for NETUAF
			fop = cif,
			fac = (get, put, del, upd),
			fnm = 'NETUAF',
			dnm = '.DAT',
			shr = (get, put, del, upd),
			org = idx,
			rfm = fix,
			mrs = naf$c_length,
			alq = 10,
			deq = 10,
			xab = nafpro
			);

!
! GLOBAL STORAGE:
!
global
	faodsc		: block [8, byte],	! gen'l purpose fao string desc
	rabptr		: ref block [rab$c_bln, byte], ! RAB for output
	uaf$gq_sysuaff	: block [nsa_s_sysuaff, byte], ! SYSUAF auditing flags
	uaf$gl_ctlmsk	: block [2],		! Control mask for AUTHORIZE
	by_account	: long initial (false),	! processing by account
	match_token	: vector [naf$s_remname+2, byte], ! Saved match token 
	match_tokenlen	: long,
	wild_netuser,				! wildcard access to proxy entries
	call_count	: long initial (0),	! counter for reprocessing cmd line
	tokendsc	: block  [8, byte] preset ( [dsc$b_class]=dsc$k_class_d),
	cmdlindsc	: block  [8, byte],
	netuaf_exists,				! A self-explanatory flag...
	rdb_exists	: long,
	rmserr		: long,			! save rms error codes here
	rightslist_modified : byte,		! RIGHTSLIST modified flag
!
! Record buffer for file I/O.  Records are generally read into RECBUF,
! modified, and output.
!
	recbuf		: block [uaf$c_length, byte],
	netbuf		: block [naf$c_length, byte],
!
! UAFRAB is global to allow UPDATE_RECORD to modify RAB$W_RSZ.
!
	uafrab	: $rab (! RAB for work file
			krf = 0,
			kbf = recbuf [uaf$t_username],
			ksz = uaf$s_username,
			usz = uaf$c_length,
			fab = uaffab
			),
!
! RAB for NETUAF Proxy Login File
!
	nafrab	: $rab (
			krf = 0,
			kbf = netbuf [naf$t_remname],
			ksz = naf$s_remname,
			usz = naf$c_length,
			rsz = naf$c_length,
			rac = key,
			fab = naffab
			),


	time_buf	: block [8,byte],		!  current system time
	pwd_flag	: long,			! Password default flag

	outrab	: $rab (
			rac = seq,
			rbf = disbuf,
			fab = outfab
			),

!
!	Flag signaling to WILD_USER that a match was found.  This flag
!	is set by the action routine called by WILD_USER.
!
	found_match,			! found at least one wildcard match

!
! Wildcard parsing flags set by PARSE_WILD for use in WILD_USER.
!
	uic_flag	: long,
	grp_wild	: long,
	mem_wild	: long,
	str_wild	: long;

global bind
	tokenlen	= tokendsc [dsc$w_length] : word,
	tokenptr	= tokendsc [dsc$a_pointer],
	rec_user_dsc	= uplit (uaf$s_username, recbuf [uaf$t_username]),
	rec_encrypt_dsc = uplit (uaf$s_pwd, recbuf [uaf$q_pwd]),
	symbol_str	= cstring ('ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789$_');
					! valid username characters

!
!	Prompt strings
!

bind

   accprmpt	= cstring (%char (lf),'UAF> '),
   accprmpt2	= cstring (%char (lf),'_ '),
   newmsg20	= cstring ('Do you want to create a new file? ');

!
!	External messages
!

external routine

   LIB$SIGNAL;

external literal

   UAF$_ADDERR,		UAF$_ADDMSG,		UAF$_BADNODFORM,
   UAF$_BADSPC,		UAF$_BADUSR,		UAF$_CLIWARNMSG,
   UAF$_CMDTOOLONG,	UAF$_CONERR,		UAF$_COPMSG,
   UAF$_CREERR,		UAF$_DEFERR,		UAF$_DEFPWD,
   UAF$_DONEMSG,	UAF$_GETERR,		UAF$_HELPERR,
   UAF$_INVCMD,		UAF$_INVRSP,		UAF$_INVUSERNAME,
   UAF$_KEYNOTFND,	UAF$_KEYNOTUNQ,		UAF$_LSTERR,
   UAF$_LSTMSG1,	UAF$_LSTMSG2,		UAF$_MDFYERR,
   UAF$_MDFYMSG,	UAF$_NAFADDERR,		UAF$_NAFADDMSG,
   UAF$_NAFAEX,		UAF$_NAFCONERR,		UAF$_NAFCREERR,
   UAF$_NAFDNE,		UAF$_NAFDONEMSG,	UAF$_NAFNOMODS,
   UAF$_NAFUAEERR,	UAF$_NAMETOOBIG,	UAF$_NETLSTMSG,
   UAF$_NAOFIL,		UAF$_NAONAF,		UAF$_NOARG,
   UAF$_NODEFPWD,	UAF$_NODTOOBIG,		UAF$_NOMODS,
   UAF$_NOTUNQ,		UAF$_NOUSERNAME,	UAF$_PREMMSG,
   UAF$_PUTERR,		UAF$_RDBDONEMSG,	UAF$_RDBMDFYERR,
   UAF$_RDBMDFYERRU,	UAF$_RDBMDFYMSG,	UAF$_RDBNOMODS,
   UAF$_REMDEF,		UAF$_REMERR,		UAF$_REMMSG,
   UAF$_REMSYS,		UAF$_RENDEF,		UAF$_RENMSG,
   UAF$_RENSYS,		UAF$_RONLY,		UAF$_SHOW_ERR,
   UAF$_SYSMSG1,	UAF$_SYSMSG2,		UAF$_UAEERR,
   UAF$_UICERR,		UAF$_ZISQUAL,		UAF$_ZZPRACREN;


%sbttl 'start - controlling code'
routine start =
begin

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Main procedure of AUTHORIZE.  Call SETUP to initialize
!	all needed files.  Prompt the user for the functions which
!	he/she wants, and call the proper function service routine.
!
! INPUTS:
!
!	none
!
! IMPLICIT INPUTS:
!
!	none
!
! OUTPUTS:
!
!	None
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	none
!
! SIDE EFFECTS:
!
!	none
!--

own
  	status;

map
	cmdlindsc	: vector;

bind
	foreign_cmdlindsc = uplit (cmdbuflen, cmdbuf);

rightslist_modified = false;
netuaf_modified = false;
modify_flag = false;					! note no modifications

!
! Set up terminal I/O
!

if rmsbad (status = $open (fab = infab))
then
    signal_stop (.status);

if rmsbad (status = $connect (rab = inrab)) 
then
    signal_stop (.status);

$create (fab = outfab);
$connect (rab = outrab);

setup ();

!
! Files have been initialized.  Prompt user for command line
! and perform requested function.
!

if lib$get_foreign (foreign_cmdlindsc, 0, cmdlindsc)  and  .cmdlindsc [0] neq 0
then
    !
    ! If defined foreign, and there are commands on the line...
    !
    begin
    cmdlindsc [1] = cmdbuf;

 	 if (status = cli$dcl_parse (cmdlindsc, authorize_commands))
	 then
	    begin
	    cli$dispatch ();
	    return true;
	    end
	else
	    !
	    ! See if no CLINT exists (Kludge City, USA  37916)
	    !	
	    if .status eql cli$_noclint
            then
 	        signal_stop (cli$_noclint)
	    else
		acc$exit ()
    end;

while true
do
    begin

    !
    ! Input the command line, taking care of continuations.  Pull off
    ! the first token, assuming it is the command name, and look it up
    ! in the table of commands.
    !

    if get_cmd_line () 
    then
        if (status = cli$dcl_parse (cmdlindsc, authorize_commands))
        then
	    begin
	    ch$fill (0, uaf$s_flags, uaf$gl_ctlmsk);
            cli$dispatch ();
	    end
	else
	    if .status eql cli$_noclint
	    then
		signal_stop (cli$_noclint)
    end;

return true;

end;

%sbttl 'setup - open initial files'
routine setup : novalue =
begin

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine does all of the initial file manipulation for the
!	program. It determines whether or not a previous SYSUAF.DAT exists.
!	If not, it creates one (if the user wishes to proceed).
!
! INPUTS:
!
!	none
!
! IMPLICIT INPUTS:
!
!	none
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	none
!
! SIDE EFFECTS:
!
!	none
!--

local
	status		: long,
	curpriv		: vector [2],
	procpriv	: vector [2],
	item_list	: block [64, byte],
	newfile;			! indicates new file must
					! be created.

item_list [0,0,16,0] = 4;
item_list [2,0,16,0] = jpi$_pid;
item_list [4,0,32,0] = pid;
item_list [8,0,32,0] = 0;
item_list [12,0,16,0] = 12;
item_list [14,0,16,0] = jpi$_username;
item_list [16,0,32,0] = username_buf;
item_list [20,0,32,0] = username_dsc[0];
item_list [24,0,16,0] = 8;
item_list [26,0,16,0] = jpi$_curpriv;
item_list [28,0,32,0] = curpriv;
item_list [32,0,32,0] = 0;
item_list [36,0,16,0] = 8;
item_list [38,0,16,0] = jpi$_procpriv;
item_list [40,0,32,0] = procpriv;
item_list [44,0,32,0] = 0;
item_list [48,0,16,0] = 4;
item_list [50,0,16,0] = jpi$_sts;
item_list [52,0,32,0] = pcb_sts;
item_list [56,0,32,0] = 0;
item_list [60,0,32,0] = 0;

$getjpi (itmlst = item_list); 		! Obtain pid, username and privs

username_dsc[0] = namelen (uaf$s_username, username_buf);

!************************************************************************
!
!                           Open SYSUAF.DAT
!
!************************************************************************

newfile = false;			! note no new file yet

if rmsbad ($open (fab = uaffab))
then
!
! sysuaf.dat doesn't exist
!
    begin
    LIB$SIGNAL(UAF$_NAOFIL, 0, .rmserr);
    if .rmserr eql rms$_fnf
    then
	begin
	while true
	do
!
! Ask if a new one is desired
!
	    begin
	    ask (newmsg20, cmdbuf[0], cmdbuflen);
	    if .cmdbuf [0] eql 'Y'
	    then exitloop newfile = true;
	    if .cmdbuf [0] eql 'N'
	    then acc$exit ();
	    LIB$SIGNAL(UAF$_INVRSP);
	    end;
	end
    else
	acc$exit ();
    end;


!
! The file will be created if it does not already exist.
! In any case connect the RAB.
!

if .newfile
then
!
! A new file is requested
!
    if rmsbad ($create (fab = uaffab))
    then 
!
! Quit regardless of error on a $CREATE: don't
! want to give read-only user ability to create a file
!
	LIB$SIGNAL(UAF$_CREERR, 0, .rmserr); 

if rmsbad ($connect (rab = uafrab))
then LIB$SIGNAL(UAF$_CONERR, 0, .rmserr);
uafrab[rab$b_rac] = rab$c_key;		! normal access is by key

!
! Check to see if there was no old file to use.  If so write a default and
! a system manager record.
!

if .newfile
then
    begin
    modify_flag = true;			! must rename when done
    build_ini_recs ();			! build default and system manager records
    uafrab[rab$w_rsz] = uaf$c_fixed;

    default_size = uaf$c_fixed;
    uafrab[rab$l_rbf] = default_record;	! insert default record address
    if rmsbad ($put (rab = uafrab))
    then LIB$SIGNAL(UAF$_PUTERR, 0, .rmserr);	! report error
    uafrab[rab$l_rbf] = recbuf;		! establish proper address (and
					! address of system record)
    if rmsbad ($put (rab = uafrab))	! output system record
    then LIB$SIGNAL(UAF$_PUTERR, 0, .rmserr);
    end
else
!
! Read in the default record.
!
    begin
    uafrab[rab$l_ubf] = default_record;
    if not locate_user (.defuser<0,8>, defuser+1, false)
    then LIB$SIGNAL(UAF$_DEFERR, 0, .rmserr);
    default_size = .uafrab[rab$w_rsz];
    end;

uafrab[rab$l_ubf] = recbuf;		! establish proper addresses
uafrab[rab$l_rbf] = recbuf;

!************************************************************************
!
!                           Open NETUAF.DAT
!
!************************************************************************

netuaf_exists = true;			! Assume NETUAF.DAT exists...

!
! Try to open NETUAF.DAT and see what happens...
!
if rmsbad ($open (fab = naffab))
then
!
! Couldn't open it
!
    if .rmserr eql rms$_fnf
    then
	netuaf_exists = false		! it doesn't exist
    else
	LIB$SIGNAL(UAF$_NAONAF, 0, .rmserr)	! open error for some other reason

else
!
! NETUAF.DAT opened without error
!
    if rmsbad ($connect (rab = nafrab))
    then LIB$SIGNAL(UAF$_NAFCONERR)		! connect error
!
! Everything opened and connected, establish proper NETUAF addresses
!
    else
	begin
	nafrab [rab$l_ubf] = netbuf;
	nafrab [rab$l_rbf] = netbuf;
 	end;

!
! Check to see if the rights data base exists.  Try to translate an ID
! and if we get a file not found error then it doesn't exist.
!
ident[uic$v_format] = uic$k_uic_format ;
ident[uic$v_group]  = 1 ;
ident[uic$v_member] = 4 ;
status = $idtoasc ( id = .ident ) ;
if .status eql rms$_fnf
    then rdb_exists = false
    else rdb_exists = true ;

end;

%sbttl 'add_uaf - insert new user record'
global routine add_uaf : novalue =
begin

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Routine to add new user to authorization file.
!
! INPUTS:
!
!	none
!
! IMPLICIT INPUTS:
!
!	none
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	none
!
! SIDE EFFECTS:
!
!	A record is added to SYSUAF.DAT
!--

map
	tokenptr	: ref vector [,byte];

local
	user_dsc	: vector [2];	! descriptor for username in record

!
! Make sure a username was specified.
!

if not cli$present (sd_token1)
or not cli$get_value (sd_token1,tokendsc)
or .tokenlen eql 0 
then return LIB$SIGNAL(UAF$_NOUSERNAME);

!
! ADD must check that the username supplied is not too long.
!
!***if .tokenlen gtr  uaf$s_username
if .tokenlen gtr 12
then return LIB$SIGNAL(UAF$_NAMETOOBIG);

!
! Make sure a legal username was entered, otherwise the account may not be
! accessible via LOGIN or the Input Symbiont.
!
incru i to .tokenlen - 1
do
    if ch$fail (ch$find_ch (.symbol_str<0,8>, 
                            symbol_str + 1,
                            .tokenptr [.i]))
    then return LIB$SIGNAL(UAF$_INVUSERNAME);
user_dsc[0] = .tokenlen;
user_dsc[1] = recbuf[uaf$t_username];

!
! Move the default record to the current record buffer, so that
! fields which are not entered will receive the default
! value.  Then insert the username just entered.
!

ch$move (.default_size, default_record, recbuf);
ch$copy (.tokenlen, .tokenptr, ' ', uaf$s_username, recbuf[uaf$t_username]);

!
! Call routine to fill in all supplied values.  Exit if any errors
! were found.
!

pwd_flag = true;			! plan to supply a password
uafrab[rab$w_rsz] = .default_size;
uaf$gl_ctlmsk[uaf$v_add] = true;
if not update_record () 
then
    begin
    uaf$gl_ctlmsk[uaf$v_add] = false;
    return;
    end;

uaf$gl_ctlmsk[uaf$v_add] = false;

if .pwd_flag				! if no explicit password
then
    begin
    pwddsc[dsc$w_length] = .defpass<0,8>;
    pwddsc[dsc$a_pointer] = defpass+1;
    $gettim (timadr = time_buf);
    recbuf[uaf$w_salt] = .time_buf<3*8,16>;
    recbuf[uaf$b_encrypt] = encrypt;
    lgi$hpwd (rec_encrypt_dsc, pwddsc, .recbuf[uaf$b_encrypt],
	      .recbuf[uaf$w_salt], user_dsc);
    end;

!
! Now output the new record.
!

if rmsbad ($put (rab = uafrab)) 
then
    if .rmserr eql rms$_dup
    then return LIB$SIGNAL(UAF$_UAEERR)
    else LIB$SIGNAL(UAF$_ADDERR, 0, .rmserr)
else
    begin

!
! Tell user that addition was successful.  Note that file was changed.
!
    LIB$SIGNAL(UAF$_ADDMSG);
    if (.uaf$gl_ctlmsk[uaf$v_cli]
    and (not .uaf$gl_ctlmsk[uaf$v_clitables])) 
    then LIB$SIGNAL(UAF$_CLIWARNMSG);
    security_audit (nsa$k_recid_sysuaf_add);
    modify_flag = true;
    if (cli$present ( sd_add_identifier ) and
        .rdb_exists )
    then
	begin
	!
	! Add the appropriate identifiers.
	! Set the resource attribute if /ATTRIB=RESOURCE was specified
	! and then add the appropriate identifiers to the rights data base
	!
	if cli$present (sd_attribresource)
	    then attributes = kgb$m_resource
	    else attributes = 0 ;
	uaf$add_ident_recbuf () ;
	end ;
    end;
end;

%sbttl 'add_proxy - insert new proxy record'
global routine add_proxy : novalue =
begin

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine adds an entry to the NETUAF.DAT Proxy Login File
!
! INPUTS:
!
!	none
!
! OUTPUTS:
!
!	none
!
! IMPLICIT INPUTS:
!
!	TOKENLEN, TOKENPTR
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	none
!
! SIDE EFFECTS:
!
!	A record is added to NETUAF.DAT
!
!--

local
	node_len,
	node_ptr,
	remuser_len,
	remuser_ptr,
	locuser_len,
	locuser_ptr;

!
! Can't do anything if there is no NETUAF.DAT...
!
if not .netuaf_exists
then return LIB$SIGNAL(UAF$_NAFDNE);

!
! Clear NETUAF.DAT buffer
!
ch$fill (' ', naf$c_length, netbuf);

!
! Retrieve token from command line
!
cli$get_value (sd_token1, tokendsc);

!
! Make sure entry is in proper node::remoteuser format
!
if not remote_parse (node_ptr, node_len, remuser_ptr, remuser_len)
then return;
!
! Fill in NETBUF with new remotename field
!
ch$copy (.node_len, .node_ptr, ' ', naf$s_node, netbuf[naf$t_node]);
ch$copy (.remuser_len, .remuser_ptr, ' ', naf$s_remuser, netbuf[naf$t_remuser]);

!
! Now get second token, the local user name
!
cli$get_value (sd_token2, tokendsc);

locuser_len = .tokenlen;
locuser_ptr = .tokenptr;
!***if .locuser_len gtru naf$s_localuser
if .locuser_len gtru 12
then return LIB$SIGNAL(UAF$_NAMETOOBIG);

!
! If local name is *, then use same name as remote user
!
if .tokenlen eql 1  and  . (.tokenptr)<0,8> eql '*'
then
    begin
    locuser_len = .remuser_len;
    ch$move (naf$s_remuser, netbuf[naf$t_remuser], netbuf[naf$t_localuser]);
    end
!
! Otherwise just copy into localuser field in NETBUF
!
else
    ch$copy (.locuser_len, .locuser_ptr, ' ',
	     naf$s_localuser, netbuf[naf$t_localuser]);

!
! Make sure that the local user does indeed exist in SYSUAF.DAT
! (unless local user is *)
!
if not locate_user (.locuser_len, netbuf[naf$t_localuser], 0)
and not (.locuser_len eql 1 and . (netbuf[naf$t_localuser])<0,8> eql '*')
then return LIB$SIGNAL(UAF$_BADUSR, 2, .locuser_len, netbuf[naf$t_localuser]);

nafrab[rab$w_rsz] = naf$c_length;

!
! Add NETUAF.DAT record
!
if rmsbad ($put (rab = nafrab))
then
    begin
    if .rmserr eql rms$_dup
    then
	return LIB$SIGNAL(UAF$_NAFUAEERR)
    else
   	LIB$SIGNAL(UAF$_NAFADDERR, 0, .rmserr)
    end
else
    begin
    LIB$SIGNAL(UAF$_NAFADDMSG);
    security_audit (nsa$k_recid_netuaf_add);
    end;

netuaf_modified = true;
end;

%sbttl 'remote_parse - parses "node::remoteuser"'
routine remote_parse (node_ptr, node_len, remuser_ptr, remuser_len) =
begin

!++
!
! FUNCTIONAL DESCRIPTION:
!	
!	This routine parses a remote user specification in the form
!	   node::remuser, and returns the two components by lengths
!	   and pointers to the strings
!
! INPUTS:
!	
!	node_ptr - returned as pointer to nodename
!	node_len -    "     " length of nodename
!	remuser_ptr - returned as pointer to remote user name
!	remuser_len -     "    "    length of remote user name
!
! IMPLICIT INPUTS:
!
!	TOKENLEN and TOKENPTR - the remote user specification is assumed
!	   to have just been fetched from the command line
!
! OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	TRUE if parsed successfully
!	FALSE if error encountered in parsing
!
!--

map
	dbl_colon	: vector;

local
	dbl_colon_ptr;

!
! Better be able to find a double colon in the remotename...
!
dbl_colon_ptr = ch$find_sub (.tokenlen, .tokenptr, 2, .dbl_colon [1]);

if .dbl_colon_ptr eql 0				! no double colon found
or .dbl_colon_ptr eql .tokenptr			! no node found
or .dbl_colon_ptr eql (.tokenptr + .tokenlen - 2) ! no remote user found
then return LIB$SIGNAL(UAF$_BADNODFORM);

!
! Determine node length and pointer
!
.node_len = .dbl_colon_ptr - .tokenptr;
.node_ptr = .tokenptr;

!
! Make sure node name isn't too long
!
!***if . (.node_len) gtru naf$s_node
if . (.node_len) gtru 6
then return LIB$SIGNAL(UAF$_NODTOOBIG);

!
! Determine remote username length and pointer
!
.remuser_len = .tokenlen - .(.node_len) - 2;
.remuser_ptr = .dbl_colon_ptr + 2;

!
! And make sure name isn't too long
!
!***if . (.remuser_len) gtru naf$s_remuser
if . (.remuser_len) gtru 12
then return LIB$SIGNAL(UAF$_NAMETOOBIG);

return true;
end;

%sbttl 'copy_uaf - copy user record'
global routine copy_uaf  =
begin

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Routine to copy a user authorization record, giving the
!       new authorization record a different name.
!
! INPUTS:
!
!	none
!
! IMPLICIT INPUTS:
!
!	none
!
! OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	 false if the copy fails;
!        true  if the copy succeeds.
!
! SIDE EFFECTS:
!
!	A user record is added.
!
!
!--

local
	status,
	flag,
	lock_rec,
	def_sys,
	old_user_buffer	: vector [uaf$s_username, byte];

map
	tokenptr	: ref vector [,byte];

uaf$gl_ctlmsk[uaf$v_copy] = not .uaf$gl_ctlmsk[uaf$v_rename];
!
! If this is a COPY directly from the UAF> prompt, the authorization
! record need not be locked, and the default and system records may be
! copied.  HOWEVER, if this COPY is part of a RENAME operation, the record
! must be locked, and the default and system records may not be renamed.
! (The RENAME operation is similar to the COPY operation except that
! the original record is REMOVE'd.  COPY leaves both records.)
!
if not .uaf$gl_ctlmsk[uaf$v_rename]
then
    begin
    lock_rec = false;			! A COPY operation
    def_sys  = true;
    flag = false;
    end
else
    begin
    lock_rec = true;	  		! A RENAME operation
    def_sys  = false;
    flag = true;
    end;

!
!  Place record to be copied into RECBUF
!  (If the third argument is true, the call to GET_USER_RECORD
!  is part of a RENAME operation, and the first token should be saved.
!  If the third argument is false, the call is part of a COPY
!  operation, and the first token need not be saved.) 
!

if get_user_record (.lock_rec, .def_sys, .flag)
then                                ! Make sure a username was
    begin                           ! specified
    if not cli$present (sd_token2)
    or not cli$get_value (sd_token2, tokendsc)
    or .tokenlen eql 0
    then return LIB$SIGNAL(UAF$_NOUSERNAME);

!
!  Make sure that the new username isn't too long
!
!***    if .tokenlen  gtru uaf$s_username
    if .tokenlen  gtru 12
    then LIB$SIGNAL(UAF$_NAMETOOBIG);

!
! Make sure that the new username is legal
!
    incru i to .tokenlen - 1
    do
	if ch$fail (ch$find_ch (.symbol_str<0,8>,
                                 symbol_str + 1,
                                .tokenptr [.i]))
	then return LIB$SIGNAL(UAF$_INVUSERNAME);

!
! If this is a rename save the new user name
!
if .uaf$gl_ctlmsk[uaf$v_rename]
then
    begin
    ch$move (.tokenlen, .tokenptr, newusername);
    newuserlen = .tokenlen;
    end ;

!
! Place the new username in RECBUF, but save the old username first
!
    ch$move (uaf$s_username, recbuf[uaf$t_username], old_user_buffer);
    ch$copy (.tokenlen, .tokenptr, ' ',
	     uaf$s_username, recbuf[uaf$t_username]);
    pwd_flag = true;

    status = update_record ();
    if not .status
    then return false;

!
! If this is a copy operation then zero fill the last login info
!
if not .uaf$gl_ctlmsk[uaf$v_rename]
then
    begin
    recbuf[uaf$w_logfails] = 0 ;
    ch$fill ( 0, uaf$s_lastlogin_i, recbuf[uaf$q_lastlogin_i] ) ;
    ch$fill ( 0, uaf$s_lastlogin_n, recbuf[uaf$q_lastlogin_n] ) ;
    end ;

!
! Now output the new record
!
    if rmsbad ($put (rab = uafrab))
    then
	begin
	if .rmserr eql rms$_dup
	then
	    return LIB$SIGNAL(UAF$_UAEERR)	! username already exists
	else
	    begin
	    LIB$SIGNAL(UAF$_ADDERR, 0, .rmserr);
            return false;
      	    end
	end
    else
!
! The copy was successful -- tell the user and set modify flag
!
	begin
	modify_flag = true;
	security_audit ((if not .uaf$gl_ctlmsk[uaf$v_rename]
			 then nsa$k_recid_sysuaf_cop
			 else nsa$k_recid_sysuaf_ren),
			old_user_buffer);
	if not .uaf$gl_ctlmsk[uaf$v_rename]
	then
	    begin
	    LIB$SIGNAL(UAF$_COPMSG);
	    if (.uaf$gl_ctlmsk[uaf$v_cli]
	    and not .uaf$gl_ctlmsk[uaf$v_clitables])
	    and .uaf$gl_ctlmsk[uaf$v_clitab_pres]
	    then LIB$SIGNAL(UAF$_CLIWARNMSG);
	    !
	    ! Since passwords are folded in with the username, passwords for 
	    ! COPYed records will no longer work--warn the user
	    !
	    if .pwd_flag
	    then LIB$SIGNAL(UAF$_DEFPWD);
	    uaf$gl_ctlmsk[uaf$v_copy] = false;
	    if (cli$present ( sd_add_identifier ) and
	        .rdb_exists )
	    then
		begin
		!
		! Set the resource attribute if /ATTRIB=RESOURCE was specified
		! and then add the appropriate identifiers to the rights data base
		!
		if cli$present (sd_attribresource)
		    then attributes = kgb$m_resource
		    else attributes = 0 ;
		uaf$add_ident_recbuf () ;
		end;
	    end;
	end ;
    end

!
! The attempt to GET_USER_RECORD failed...
!
else return false;

!
! If we get here, everything succeeded -- return true
!
return true;

end;

%sbttl 'create_proxy - create NETUAF.DAT proxy file'
global routine create_proxy : novalue =
begin

!++
!
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine will create a DECnet Proxy Login File,
!	if and only if it does not already exist,
!	called NETUAF.DAT, in order to map remote users into
!	local accounts.  
!
! INPUTS:
!
!    none
!
! OUTPUTS:
!
!    none
!
! IMPLICIT INPUTS:
!
! 	none
!
! IMPLICIT OUTPUTS:
!
!	none
!
! SIDE EFFECTS:
!
!	NETUAF.DAT is created and initialized 	
!
!--

!
! NETUAF.DAT should not already exist
!
if .netuaf_exists
then
    begin
    LIB$SIGNAL(UAF$_NAFAEX);
    return;
    end;

!
! Should be able to create NETUAF.DAT with no problems
!
if rmsbad ($create (fab = naffab))
then LIB$SIGNAL(UAF$_NAFCREERR, 0, .rmserr);

!
! Should connect ok, too
!
if rmsbad ($connect (rab = nafrab))
then LIB$SIGNAL(UAF$_NAFCONERR, 0, .rmserr);

!
! Normal access is by key
!
nafrab [rab$b_rac] = rab$c_key;

!
! Establish proper addresses
!
nafrab [rab$l_ubf] = netbuf;
nafrab [rab$l_rbf] = netbuf;

!
! Set NETUAF.DAT existence flag
!
netuaf_exists = true;
netuaf_modified = true;

end;

%sbttl 'modify_uaf - update user record (s)'
global routine modify_uaf : novalue =
begin

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Routine to modify any of the fields in one or more user records.
!
! INPUTS:
!
!	none
!
! IMPLICIT INPUTS:
!
!	none
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	none
!
! SIDE EFFECTS:
!
!	none
!
! ROUTINE VALUE:
!
!	none
!--

local
	status;

!
! Obtain the user specification.  This sets wildcard flags and initializes
! the appropriate key in RECBUF.
!

if not parse_wild (sd_token1,false)		! Null string is disallowed
then return;

uafrab[rab$l_rop] = rab$m_rlk;		! Lock records for writing
rabptr = outrab;
found_match = false;

if rmsbad (status = wild_user (modify_rec))	! Modify each record
then
    begin
    if .rmserr eql rms$_rnf
    then
	LIB$SIGNAL(UAF$_BADSPC)
    else
	(if .rmserr neq 0
	 then
	     LIB$SIGNAL(UAF$_MDFYERR, 0, .rmserr))
    end
else
    begin
    if .status and .found_match
    then
	begin
	LIB$SIGNAL(UAF$_MDFYMSG); 
	if (.uaf$gl_ctlmsk[uaf$v_cli]
	and not .uaf$gl_ctlmsk[uaf$v_clitables])
	and .uaf$gl_ctlmsk[uaf$v_clitab_pres]
	then LIB$SIGNAL(UAF$_CLIWARNMSG);
	end;
    end;
end;

%sbttl 'modify_rec - update a user record action routine'
routine modify_rec = 
begin

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Modify an individual user record.
!
! INPUTS:
!
!	none
!
! IMPLICIT INPUTS:
!
!	RABPTR - RMS data structure for the file
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	none
!
! SIDE EFFECTS:
!
!	none
!
! ROUTINE VALUE:
!
!	If an error is encountered the appropriate status is returned
!	except if the error message has already been output in which
!	case 0 is returned.
!--

local
    old_uic	: $bblock[4],
    new_uic	: $bblock[4],
    oldaccname	: vector [uaf$s_account,byte],
    newaccname	: vector [uaf$s_account,byte],
    oldaccdesc	: statdesc ,
    newaccdesc	: statdesc ,
    status	: long ;

!
! User record has been read into RECBUF by caller.  Update values
! and modify the record.
!
! When accessing records by uic, this routine is called repeatedly
! from WILD_USER. UPDATE_RECORD is called to modify the appropriate
! record fields for each requested record, and therefore must 
! reparse the command line each time.  If call_count is greater
! than 0, the command line is reparsed.
!

!IF .by_account
!THEN
!    (IF NOT fmg$match_name (NAMELEN (UAF$S_ACCOUNT,UAF$T_ACCOUNT),
!				     RECBUF[UAF$T_ACCOUNT],
!				    .match_tokenlen, match_token)
!     THEN
!	RETURN TRUE)
!ELSE
if .str_wild
and not fmg$match_name (namelen (uaf$s_username,recbuf[uaf$t_username]),
			recbuf[uaf$t_username],
			.match_tokenlen,  match_token)
then return true;
found_match = true;

if ch$eql (.defuser<0,8>, defuser+1, .tokenlen, .tokenptr, ' ')
or ch$eql (.defuser<0,8>, defuser+1,
	   namelen (uaf$s_username, recbuf[uaf$t_username]), 
	   recbuf[uaf$t_username], ' ')
then
    begin
    mod_default = true;
    default_uaf ();
    call_count = .call_count + 1;
    return true;
    end;

!
! Save the old UIC and account name
!
old_uic[uic$v_format] = 0 ;
old_uic[uic$v_group ] = .recbuf [uaf$w_grp] ;
old_uic[uic$v_member] = .recbuf [uaf$w_mem] ;
ch$move ( uaf$s_account, recbuf[uaf$t_account], oldaccname ) ;
oldaccdesc [length]  = namelen ( uaf$s_account, recbuf[uaf$t_account]) ;
oldaccdesc [pointer] = oldaccname ;

if update_record ()
then
    begin
    !
    ! Save the new UIC and account name
    !
    new_uic[uic$v_format] = 0 ;
    new_uic[uic$v_group ] = .recbuf [uaf$w_grp] ;
    new_uic[uic$v_member] = .recbuf [uaf$w_mem] ;
    ch$move ( uaf$s_account, recbuf[uaf$t_account], newaccname ) ;
    newaccdesc [length]  = namelen ( uaf$s_account, recbuf[uaf$t_account]) ;
    newaccdesc [pointer] = newaccname ;

    !
    ! Update the UAF record
    !
    if rmsbad ($update (rab = uafrab))
    then
	begin
	LIB$SIGNAL(UAF$_MDFYERR, 0, .rmserr);
	return .rmserr
	end
    else
	begin
	modify_flag = true;
	security_audit (nsa$k_recid_sysuaf_mod);
	call_count = .call_count + 1;
	end;

    if (cli$present ( sd_modify_identifier ) and
        .rdb_exists )
    then
	begin
    
	!
	! If the UIC changed then modify the identifiers
	!
	if .old_uic neq .new_uic
	then
	    begin
	    local
		oldidname	: vector [kgb$s_name, byte],
		oldiddesc	: statdesc ;

	    oldiddesc[length]  = kgb$s_name ;
	    oldiddesc[pointer] = oldidname ;
	    status = $idtoasc ( id     = .old_uic,
	                        namlen = oldiddesc[length],
	                        nambuf = oldiddesc ) ;
    
	    if not .status
	    then LIB$SIGNAL(UAF$_RDBMDFYERRU, 2, 
			       .old_uic[uic$v_group],
			       .old_uic[uic$v_member], .status)
	    else if .status
		then
		    begin
		    status = $mod_ident ( id        = .old_uic,
					  new_value = .new_uic ) ;
		
		    if not .status
			then LIB$SIGNAL(UAF$_RDBMDFYERR, 1, oldiddesc, .status)
			else
			    begin
			    rightslist_modified = true ;
			    LIB$SIGNAL(UAF$_RDBMDFYMSG, 1, oldiddesc);
			    end ;
		    end ;    
	    end;
	end ;
    return true ;
    end
else
    begin
    $release (rab = uafrab);
    return false
    end
end;

%sbttl 'remove_uaf - remove username from file'
global routine remove_uaf : novalue =
begin

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Routine to delete a user record from the UAF file.
!
! INPUTS:
!
!	none
!
! OUTPUTS:
!
!	none
!
! IMPLICIT INPUTS:
!
!	rename: a logical flag which indicates whether this COPY is part
!		of a RENAME operation
!
! ROUTINE VALUE:
!
!	none
!
! SIDE EFFECTS:
!
!  This routine also deletes any NETUAF entries for the
!	local user which is to be removed (If NETUAF.DAT exists)
!
!--

!
! Look for the record specified by the user.  Make sure
! the DEFAULT and SYSTEM records are not removed.
!

if get_user_record (true, false)
then

!
! User record has been found and read into RECBUF
! Zero the username field and update the record in the file
!
    begin
    if rmsbad ($delete (rab=uafrab))
    then
	LIB$SIGNAL(UAF$_REMERR, 0, .rmserr) 
    else
	begin
	modify_flag = true;			! mark file as modified
	if not .uaf$gl_ctlmsk[uaf$v_rename]
	then
	    security_audit (nsa$k_recid_sysuaf_del);
	if not .uaf$gl_ctlmsk[uaf$v_rename]
	then
	    begin
	    !
	    ! If there is a proxy login file, delete entries for
	    ! the user just removed from SYSUAF.DAT
	    !
	    if .netuaf_exists
            then adjust_proxy (remove_records);
	    LIB$SIGNAL(UAF$_REMMSG);
	    !
	    ! Unless specifically requested not to
	    ! remove the corresponding identifier from the
	    ! rights data base.
	    !
	    if (cli$present ( sd_remove_identifier ) and
	        .rdb_exists )
	    then
		uaf$remove_ident_recbuf () ;
	    end;
	end;
    end;
end;

%sbttl 'remove_proxy - remove a proxy record'
global routine remove_proxy : novalue =
begin

!++
!
! FUNCTIONAL CHARACTERISTICS:
!
!	This routine removes proxy login entries from NETUAF.DAT
!
! INPUTS:
!
!	none
!
! OUTPUTS:
!
!	none
!
! IMPLICIT INPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
! 	none
!
! SIDE EFFECTS:
!
!	An entry is removed from NETUAF.DAT
!
!--

local
	node_len,
	node_ptr,
	remuser_len,
	remuser_ptr,
	counter,
	success;

!
! Make sure NETUAF.DAT exists
!
if not .netuaf_exists
then return LIB$SIGNAL(UAF$_NAFDNE);

!
! Retrieve remote name in node::remotename form
!
cli$get_value (sd_token1, tokendsc);

!
! Verify proper format
!
if not remote_parse (node_ptr, node_len, remuser_ptr, remuser_len)
then return;

!
! Copy into appropriate fields
!
ch$copy (.node_len, .node_ptr, ' ', naf$s_node, netbuf[naf$t_node]);
ch$copy (.remuser_len, .remuser_ptr, ' ', naf$s_remuser, netbuf[naf$t_remuser]);

nafrab[rab$l_rop] = rab$m_rlk;

success = get_proxy_record ();

!
! Delete the record
!
if .success
then
    begin
    if rmsbad ($delete (rab = nafrab))
    then
	LIB$SIGNAL(UAF$_REMERR, 0, .rmserr)
    else
	begin
	security_audit (nsa$k_recid_netuaf_del);
    	LIB$SIGNAL(UAF$_PREMMSG);
	end;
    end
else
    LIB$SIGNAL(UAF$_REMERR);

netuaf_modified = true;
end;

%sbttl 'rename_uaf - rename user record'
global routine rename_uaf : novalue =
begin

!++
!
! FUNCTIONAL DESCRIPTION:
!
!  	Effect a user authorization record rename, by 
!	performing a COPY and a REMOVE operation.
!
! INPUTS:
!
!	none
!
! IMPLICIT INPUTS:
!
!	none
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	none
!
! SIDE EFFECTS:
!
!	A user authorization record is copied with a newname; the
!	original record is then deleted.
!       This routine also causes updating of any NETUAF entries for the
!	local user which is to be renamed.
!
!--

uaf$gl_ctlmsk[uaf$v_rename] = true;
!
! Copy the new authorization record
!
if  (copy_uaf ())
then
    begin
!
! Remove the old authorization record
!
    remove_uaf ();
    LIB$SIGNAL(UAF$_RENMSG);
!
! Because passwords are folded in with the username, passwords for
! RENAMEd records will no longer work--warn the user
!
    if .pwd_flag
    then LIB$SIGNAL(UAF$_DEFPWD);

!
! Modify the rights data base if one exists
!
    if (cli$present ( sd_modify_identifier ) and
        .rdb_exists )
    then
	begin
	local
	    status		: long,
	    old_name_buff	: vector [kgb$s_name, byte],
	    old_name_desc	: statdesc ,
	    new_name_desc	: statdesc ;

	old_name_desc[length]  = kgb$s_name ;
	old_name_desc[pointer] = old_name_buff ;
	new_name_desc[length]  = .newuserlen ;
	new_name_desc[pointer] = newusername ;

	uaf$find_uic () ; 	!  Build Identifier from the recbuf
	    
	!
	! Find the ascii name
	!
	status = $idtoasc ( id     = .ident,
	                    namlen = old_name_desc[length],
	                    nambuf = old_name_desc ) ;
	if not .status
	then LIB$SIGNAL(UAF$_RDBMDFYERRU, 2, 
			   .ident[uic$v_group],
			   .ident[uic$v_member], .status)
	else 
	    begin
    
	    status = $mod_ident ( id       = .ident,
				  new_name = new_name_desc ) ;
	
	    if not .status
		then LIB$SIGNAL(UAF$_RDBMDFYERR, 1, old_name_desc, .status)
		else
		    begin
		    rightslist_modified = true ;
		    LIB$SIGNAL(UAF$_RDBMDFYMSG, 1, old_name_desc);
		    end ;
	    end ;
	end ;

    end;
!
! Reset flags
!
rename_ph2 = false;
uaf$gl_ctlmsk[uaf$v_rename] = false;

end;

%sbttl 'adjust_proxy - implicitly remove/update proxy record'
global routine adjust_proxy (remove) : novalue =
begin

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine performs the operations implicitly indicated by
!	REMOVE or RENAME operations on SYSUAF.DAT.  If a SYSUAF.DAT 
!	record is removed, then any corresponding NETUAF.DAT entries must
!	also be deleted.  If a SYSUAF.DAT record is renamed, then any
!	corresponding NETUAF.DAT entries must be updated.
!
! INPUTS:
!
!	remove - a flag which indicates that the NETUAF.DAT record
!		 should be removed.  If false, then the record 
!		 should be updated.
!
! OUTPUTS:
!
!	none
!
! IMPLICIT INPUTS:
!
!	olduserlen  - the old username length for a RENAME
!	oldusername - the old username string for a RENAME
!	TOKENPTR - the new username for RENAME, the removed username for REMOVE
!	TOKENLEN - "    "    "  length " ",  "    "      "  length "   "
!
! IMPLICIT OUTPUTS:
!
!	none
!
! SIDE EFFECTS:
!
!	 A  record is removed/updated in NETUAF.DAT
!
!--

local
	modified: initial(false),
	status;

!
! Set access to sequential because we need to check for 
! multiple entries
!
nafrab[rab$l_rop] = rab$m_rlk;		! Lock records for writing
nafrab[rab$b_rac] = rab$c_seq;
$rewind (rab = nafrab);

!
! Until EOF...
!
while status = get_proxy_record ()
do
    begin
    local
        locuser_len,
        blank_ptr;    

!
! Find end of user name...
!
!
! If not found in 12 characters, it must be the full 12 
! characters in length
!
    if ch$fail (blank_ptr = ch$find_ch (naf$s_localuser,
					netbuf[naf$t_localuser], ' '))
    then 
        locuser_len = naf$s_localuser
    else
   	locuser_len = .blank_ptr - netbuf[naf$t_localuser];

!
! If this is a record to be removed, delete it
!
    if .remove
    then
	begin
        if .tokenlen eql .locuser_len
        and  ch$eql (.tokenlen, .tokenptr, .locuser_len, netbuf[naf$t_localuser])
        then
	    begin
	    netuaf_modified = true;
            $delete (rab = nafrab);
	    security_audit (nsa$k_recid_netuaf_del);
	    end;
	end
!
! otherwise, change the localusername field to reflect the
! new username in SYSUAF.DAT
!
    else
	begin
	modified = true;
        if .olduserlen eql .locuser_len
	and  ch$eql (.olduserlen, oldusername,
		     .locuser_len, netbuf[naf$t_localuser])
        then
            begin
            ch$copy (uaf$s_username, recbuf[uaf$t_username],' ', 
		     naf$s_localuser,netbuf[naf$t_localuser]);
            $update (rab = nafrab);
	    netuaf_modified = true;
	    security_audit (nsa$k_recid_netuaf_mod, oldusername);
            end; 
	end;
    end;

if .modified then
   LIB$SIGNAL(UAF$_ZZPRACREN, 2, .olduserlen, oldusername);

!
! Return to keyed access
!
nafrab[rab$b_rac] = rab$c_key;
end;

%sbttl 'default_uaf - change default record'
global routine default_uaf : novalue =
begin

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Change a default value in the default record.
!
! INPUTS:
!
!	none
!
! IMPLICIT INPUTS:
!
!	none
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	none
!
! SIDE EFFECTS:
!
!	none
!--


!
! Locate default record and load it into RECBUF
! if not already there (via an indirect MODIFY DEFAULT)
!

if not .mod_default  
then
    begin
    if not locate_user (.defuser<0,8>, defuser+1, true)
    then
	begin
	LIB$SIGNAL(UAF$_DEFERR, 0, .rmserr);
	return;
	end;
    end;
!
! The encrypted password field of the DEFAULT record can not be propagated
! to another user, because the encryption algorithm takes the user name as
! an input.  The user is merely warned that this qualifier has no effect.
!

pwd_flag = true;

!
! Update values supplied and exit if errors.
!

if update_record ()
then
    begin
    if not .pwd_flag
    then LIB$SIGNAL(UAF$_NODEFPWD);

!
! Now write the modified record back into the DEFAULT_RECORD buffer.
!
    default_size = .uafrab[rab$w_rsz];
    ch$move (.default_size, recbuf, default_record);

!
! Update the default record in the file.  Note that file has changed.
!
    if not rmsok ($update (rab = uafrab))
    then
        LIB$SIGNAL(UAF$_MDFYERR, 0, .rmserr)
    else
	begin
	modify_flag = true;
	security_audit (nsa$k_recid_sysuaf_mod);
	if not .mod_default
	then
	    LIB$SIGNAL(UAF$_MDFYMSG) 
        else
            mod_default = false;
	end;
    end

else
    $release (rab = uafrab);			! unlock the record

end;

%sbttl 'list_proxy - list proxy entries in NETUAF.LIS'
global routine list_proxy : novalue =
begin

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine produces a listing of the entire NETUAF.DAT file
!	in NETUAF.LIS.
!
! INPUTS:
!
!	none
!
! OUTPUTS:
!
!	none
!
! SIDE EFFECTS:
!
!	A listing file is produced
!
!--

local
       action;

!
! Make sure NETUAF.DAT exists
!
if not .netuaf_exists
then return LIB$SIGNAL(UAF$_NAFDNE);

!
! Set up the listing file FAB and connect RAB
!
nlstfab[fab$v_dlt] = false;
if rmsbad ($create (fab = nlstfab))
then return LIB$SIGNAL(UAF$_LSTERR, 0, .rmserr);

if rmsbad ($connect (rab = nlstrab))
then return LIB$SIGNAL(UAF$_LSTERR, 0, .rmserr);

!
! Set action routine and rab pointer
!
wild_netuser = true;
match_tokenlen = 1;
match_token = %c'*';
rabptr = nlstrab;
action = display_proxy;
header_flag = true;
nafrab[rab$l_rop] = rab$m_rrl or rab$m_nlk;

LIB$SIGNAL(UAF$_LSTMSG1);

!
! LOCATE_PROXY will call the action routine for each proxy record
!
if rmsbad (locate_proxy (.action))
then
    begin
    if .rmserr eql rms$_rnf
    then
 	LIB$SIGNAL(UAF$_BADSPC)
    else
	LIB$SIGNAL(UAF$_LSTERR, 0, .rmserr);
    end
else
    LIB$SIGNAL(UAF$_NETLSTMSG);

!
! Disconnect RAB and close FAB
!
$disconnect (rab = nlstrab);
$close (fab = nlstfab);

end;

%sbttl 'list_uaf - list file routine'
global routine list_uaf : novalue =
begin

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Display the specified users in a file named 'SYSUAF.LIS'.
!
! INPUTS:
!
!	none
!
! IMPLICIT INPUTS:
!
!	none
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	none
!
! SIDE EFFECTS:
!
!	none
!--

local
	action;

!
! Obtain the user specification.  This sets wildcard flags and initializes
! the appropriate key in RECBUF.
!

if not parse_wild (sd_token1,true)		! Null string defaults to *
then return;

!
! Obtain qualifiers.  This determines which display should be used.
!
full_flag = false;
brief_flag = true;

if cli$present (sd_full) or (not cli$present (sd_brief))
then
    begin
    brief_flag = false;
    full_flag  = true;
    end;

!
! Create the listing file.
!

lstfab[fab$v_dlt] = false;		! initialize DLT bit
if rmsbad ($create (fab = lstfab))
then return LIB$SIGNAL(UAF$_LSTERR, 0, .rmserr);

if rmsbad ($connect (rab = lstrab))
then return LIB$SIGNAL(UAF$_LSTERR, 0, .rmserr);

!
! Request a header record for the file and aim RABPTR at our RAB.
!

header_flag = true;
rabptr = lstrab;
found_match = false;
uafrab[rab$l_rop] = rab$m_rrl or rab$m_nlk;
!
! Flag the list operation for the rights data base routines .
!
rdb_list_flag = true ;

!
! Choose the appropriate display.
!

action = display_brief;
if .full_flag
then action = display_full;

LIB$SIGNAL(UAF$_LSTMSG1);			! announce starting

if rmsbad (wild_user (.action))
then
    begin
    if .rmserr eql rms$_rnf
    then
	LIB$SIGNAL(UAF$_BADSPC)
    else
	LIB$SIGNAL(UAF$_LSTERR, 0, .rmserr);
    lstfab[fab$v_dlt] = true;		! press delete button
    end
else
    LIB$SIGNAL(UAF$_LSTMSG2);

$disconnect (rab = lstrab);
$close (fab = lstfab);
end;

%sbttl 'show_user_uaf - display user record'
global routine show_user_uaf : novalue =
begin

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Display the specified users on SYS$OUTPUT.
!
! INPUTS:
!
!	none
!
! IMPLICIT INPUTS:
!
!	none
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	none
!
! SIDE EFFECTS:
!
!	none
!--

local
	action;

!
! Obtain the user specification.  This sets wildcard flags and initializes
! the appropriate key in RECBUF.
!

if not parse_wild (sd_token1,false)		! Null string is disallowed.
then return;

!
! Obtain qualifiers.  This determines which display should be used.
!
full_flag = true;
brief_flag = false;

if cli$present (sd_brief) or (not cli$present (sd_full))
then
    begin
    brief_flag = true;
    full_flag  = false;
    end;

!
! Request a header record for the file and aim RABPTR at our RAB.
!

header_flag = true;
rabptr = outrab;
found_match = false;
uafrab[rab$l_rop] = rab$m_rrl or rab$m_nlk;

!
! Flag the show operation for the rights data base routines .
!
rdb_list_flag = false ;

!
! Choose the appropriate display.
!

action = display_full;
if .brief_flag
then action = display_brief;

if rmsbad (wild_user (.action))
then
    begin
    if .rmserr eql rms$_rnf
    then
	LIB$SIGNAL(UAF$_BADSPC)
    else
	LIB$SIGNAL(UAF$_SHOW_ERR, 0, .rmserr);
    end;
end;

%sbttl 'show_proxy - display proxy record at terminal'
global routine show_proxy : novalue =
begin

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine will display a specific proxy record or
!	will display all proxy entries to the user terminal.
!
! INPUTS:
!
!	none
!
! OUTPUTS:
!
!	none
!
! IMPLICIT INPUTS:
!
!	TOKENLEN, TOKENPTR
!
! IMPLICIT OUTPUTS:
!
!	none
!
! SIDE EFFECTS:
!
!	none
!
!--

local
	node_len,
	node_ptr,
	remuser_len,
	remuser_ptr,
	action,
	counter,
	success;

!
! Make sure that NETUAF.DAT exists
!
if not .netuaf_exists
then return LIB$SIGNAL(UAF$_NAFDNE);

!
! Retrieve token
!
cli$get_value (sd_token1, tokendsc);

header_flag = true;

!
! Wildcard spec?
!
if ch$find_ch (.tokenlen, .tokenptr, %c'%') neq 0
or ch$find_ch (.tokenlen, .tokenptr, %c'*') neq 0
then
    begin
    wild_netuser = true;
    match_tokenlen = .tokenlen;
    ch$move (.tokenlen, .tokenptr, match_token);
    end
!
! Otherwise, just display a single entry
!
else
    begin
    wild_netuser = false;
    if not remote_parse (node_ptr, node_len, remuser_ptr, remuser_len)
    then return;

    ch$copy (.node_len, .node_ptr, ' ', naf$s_node, netbuf[naf$t_node]);
    ch$copy (.remuser_len, .remuser_ptr, ' ',
	     naf$s_remuser, netbuf[naf$t_remuser]);
    end;

!
! Set up action routine and rab pointer
!
rabptr = outrab;
action = display_proxy;
found_match = false;
nafrab[rab$l_rop] = rab$m_rrl or rab$m_nlk;

!
! Make call (s) necessary to display the rquested entry or entries
!
if rmsbad (locate_proxy (.action))
then
    begin
    if .rmserr eql rms$_rnf
    then
	LIB$SIGNAL(UAF$_BADSPC)
    else
	LIB$SIGNAL(UAF$_SHOW_ERR, 0, .rmserr);
    end;
end;

%sbttl 'locate_proxy - access given proxy record (s)'
routine locate_proxy (action) =
begin

!++
!
! FUNCTIONAL DESCRIPTION:
!
! 	This routine will call a requested action routine a number of times.
!
! INPUTS:
!
!	ACTION - the action routine to call for each NEUAF record
!
! OUTPUTS:
!
!	none
!
! SIDE EFFECTS:
!
!	none
!
!--

local
	status;

!
! If wild user, set acces to sequential and fetch all records
!
if .wild_netuser
then
    begin
    nafrab[rab$b_rac] = rab$c_seq;
    $rewind (rab = nafrab);
    end;

status = get_proxy_record ();

!
! Fetch record and call action routine until EOF
!
if .status
then (.action) ();

if .wild_netuser
then
    begin
    while status = get_proxy_record ()
    do (.action) ();
    if .status eql rms$_eof
    then status = true;
    end;

!
! Restore keyed access
!
nafrab[rab$b_rac] = rab$c_key;

if .wild_netuser and not .found_match
then LIB$SIGNAL(UAF$_BADSPC);

.status
end;

%sbttl 'get_proxy_record - read single proxy record'
routine get_proxy_record =
begin

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine accesses a specific NETUAF.DAT record
!
! INPUTS:
!
!	none
!
! OUTPUTS:
!
!	none
!
! SIDE EFFECTS:
!
! 	none
!
!--

local
	counter,
	success;

counter = retry_rlk;

while ((success = $get (rab = nafrab)) eql rms$_rlk)
      and  ((counter = .counter - 1) geq 0)
do
   if $schdwk (daytim = wakedelta) then $hiber;

.success
end;

%sbttl 'display_proxy - format and output a proxy entry'
routine display_proxy : novalue =
begin

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine formats and outputs a line of a NETUAF.DAT entry
!
! INPUTS:
!
!	none
!
! OUTPUTS:
!
!	none
!
! SIDE EFFECTS:
!
!	none
!
!--

bind
	nafhdr		= cstring (' Node   Remote User     Local User'),
	shownaf		= cstring ('!6AD::!12AD    !12AD');


if .wild_netuser
and not
    begin
    local
	nodelen, usrlen, proxy_buf : vector[naf$s_remname+2,byte];
    map  
	dbl_colon : vector;

    nodelen = namelen (naf$s_node, netbuf[naf$t_node]);
    usrlen  = namelen (naf$s_remuser, netbuf[naf$t_remuser]);
    ch$move (.nodelen, netbuf[naf$t_node], proxy_buf [0]);
    ch$move (2, .dbl_colon[1], proxy_buf [.nodelen]);
    ch$move (.usrlen, netbuf [naf$t_remuser], proxy_buf [.nodelen+2]);

    usrlen = .nodelen + .usrlen + 2;
    fmg$match_name (.usrlen, proxy_buf, .match_tokenlen, match_token)
    end
then
    return;

found_match = true;

if .header_flag
then
    begin
    faomac (nafhdr);
    output_null;
    header_flag = false;
    end;

faomac (shownaf,
!***    naf$s_node,      netbuf[naf$t_node],
!***    naf$s_remuser,   netbuf[naf$t_remuser],
!***    naf$s_localuser, netbuf[naf$t_localuser]);
    6,  netbuf[naf$t_node],
    12, netbuf[naf$t_remuser],
    12, netbuf[naf$t_localuser]);

end;

%sbttl 'wild_user - user wild card routine'
global routine wild_user (action) =
begin

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Provide a general means of accessing the User Authorization File
!	records.  There are six methods:
!
!			UGMS
!			IRET
!			CPMR
!			\\\\
!			FWWW
!			LIII
!			ALLL
!	Syntax		GDDD	Interpretation
!	------			--------------
!	Username	FFFF	Exactly one user is to be located
!	*		FFFT	All users (alphabetically)
!	[Group,Member]	TFFF	All users with the specified UIC
!	[Group,*]	TFTF	All users in the specified group (by member)
!	[*,Member]	TTFF	A FIFO listing of the groups with this member
!	[*,*]		TTTF	All users by UIC
!
! INPUTS:
!
!	ACTION - Pointer to routine to call after each successful GET
!
! IMPLICIT INPUTS:
!
!	UIC_FLAG - UIC form (instead of username)
!	GRP_WILD - Group wild card (must imply UIC_FLAG)
!	MEM_WILD - Member wild card (must imply UIC_FLAG)
!	STR_WILD - all users alphabetically (must imply NOT UIC_FLAG)
!	UAFRAB - RMS data structure for SYSUAF.DAT
!	RECBUF - The current record
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	If an abnormal condition is encountered the appropriate status
!	is returned.
!
! SIDE EFFECTS:
!
!	none
!--

macro
	lmt_l_uic = 0,0,32,0%,		! User ID Code
	lmt_w_mem = 0,0,16,0%,		! Member subfield
	lmt_w_grp = 2,0,16,0%;		! Group subfield

local
	status,				! This routine's status
	lmtkey	: block[4,byte];	! Limiting key value for sequential loop

if .uic_flag
then
!
! Change the key of reference and the key buffer if a UIC form was
! specified.
!
    begin
    uafrab[rab$b_krf] = 1;
    uafrab[rab$l_kbf] = recbuf[uaf$l_uic];
    uafrab[rab$b_ksz] = 4;
    end;

if .mem_wild and not .grp_wild
then
!
! The UIC requested was of the form [Group,*]
!
    uafrab[rab$v_kge] = true;

!
! LMTKEY need be loaded only IF .UIC_FLAG AND NOT (.GRP_WILD AND .MEM_WILD)
! but it is simpler to always load it.
!

lmtkey[lmt_l_uic] = .recbuf[uaf$l_uic];

!
! Locate the first user meeting the specification.
!

if .str_wild or .grp_wild
then
    begin
!
! Every user in the file is to be accessed.
!
    uafrab[rab$b_rac] = rab$c_seq;
    $rewind (rab = uafrab);
    status = get_uaf_record ();
    end
else
    begin
    status = get_uaf_record ();
    if .uic_flag
    then
	begin
!
! Even an explicit UIC requires sequential reads to locate duplicates.
!
	uafrab[rab$b_rac] = rab$c_seq;
	if .mem_wild and not .grp_wild
	then
	    begin
!
! RAB$V_KGE is set on the initial access for specifications of the
! form [Group,*] so if the specified group has no members the record
! will be that of a user in another group.
!
	    uafrab[rab$v_kge] = false;
	    if .lmtkey[lmt_w_grp] nequ .recbuf[uaf$w_grp]
	    then
		status = rms$_rnf;
	    end;
	end;
    end;

if .status
then
    begin
!
! Feed the action routine the first record.  In the case of an explicit
! username specification this will be the only record.
!
    while .status
    do
	begin
	if (
	    if .grp_wild and not .mem_wild
	    then .recbuf[uaf$w_mem] eql .lmtkey[lmt_w_mem]
	    else true
)
	then status = (.action) ();
	if not .status then exitloop;
	if not (.str_wild or .uic_flag)
	then exitloop;
	status = get_uaf_record ();
	if not .status then exitloop;
	if .uic_flag
	then
	    begin
!
! The limiting key value is used in different ways depending
! on the form of the UIC specification.
!
	    if .mem_wild and not .grp_wild
	    then
!
! [Group,*]
!
		begin
		if .lmtkey[lmt_w_grp] nequ .recbuf[uaf$w_grp]
		then exitloop;
		end;
	    if not (.grp_wild or .mem_wild)
	    then
!
! [Group,Member]
!
		begin
		if .lmtkey[lmt_l_uic] nequ .recbuf[uaf$l_uic]
		then exitloop;
		end;
	    end;
	end;				! end of wild carding loop
    if .status eql rms$_eof
    then status = true;			! Hitting EOF is ok
    end;

if .str_wild and not .found_match
then LIB$SIGNAL(UAF$_BADSPC);

!
! The RAB must be returned to its former state before exiting.
!
uafrab[rab$b_rac] = rab$c_key;

if .uic_flag
then
    begin
    uafrab[rab$b_krf] = 0;
    uafrab[rab$l_kbf] = recbuf[uaf$t_username];
    uafrab[rab$b_ksz] = uaf$s_username;
    end;

!
! Reset parse count
!
call_count = 0;

.status
end;

%sbttl 'display_brief - writes a brief user display'
routine display_brief =
begin

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Provide an ASCII listing of the most important record information
!	(username, owner, etc.) for each record supplied.
!
! INPUTS:
!
!	none
!
! IMPLICIT INPUTS:
!
!	RABPTR - RMS data structure for the file
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	none
!
! SIDE EFFECTS:
!
!	none
!--

bind
lststr1 = cstring ('       Owner         Username           UIC       Account  Privs',
		   ' Pri Directory'),
lststr2 = cstring ('!20AC !12AD !15%U !8AF !6AC !2UL !AC!AC');

!
! Output a header if one was requested.
!
if .header_flag
then
    begin
    faomac (lststr1);
    output_null;
    header_flag = false;
    end;

if .str_wild and not fmg$match_name (namelen (uaf$s_username,recbuf[uaf$t_username]), 
				     recbuf[uaf$t_username],
		                     .match_tokenlen,  match_token)
then return true;

found_match = true;

!
! Output the record.
!

ch$fill (' ', disbuflen, disbuf);

faomac (lststr2,
    recbuf[uaf$t_owner],
!***    uaf$s_username, recbuf[uaf$t_username],
    12, recbuf[uaf$t_username],
    .recbuf[uaf$l_uic],
!***    uaf$s_account, recbuf[uaf$t_account],
    8, recbuf[uaf$t_account],
    classify_priv (recbuf[uaf$q_priv], .recbuf[uaf$l_uic]),
    .recbuf[uaf$b_pri],
    recbuf[uaf$t_defdev],
    recbuf[uaf$t_defdir]);

true
end;

%sbttl 'classify_priv - classifies contents of priv vector'
routine classify_priv (prvadr, uic) =
begin

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Classifies privilege bits and reports the highest class available
!	to the owner of the supplied vector.
!
! INPUTS:
!
!	PRVADR - Address of the privilege vector
!
! IMPLICIT INPUTS:
!
!	none
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	none
!
! SIDE EFFECTS:
!
!	none
!--

map
	prvadr	: ref block[8,byte];

bind
	lstprva = cstring ('All'),
	lstprvb = cstring ('Files'),
	lstprvc = cstring ('System'),
	lstprvd = cstring ('Devour'),
	lstprve = cstring ('Group'),
	lstprvf = cstring ('Normal'),
	lstprvg = cstring ('None');

if .prvadr[prv$v_cmkrnl]
or .prvadr[prv$v_cmexec]
or .prvadr[prv$v_sysnam]
or .prvadr[prv$v_detach]
or .prvadr[prv$v_log_io]
or .prvadr[prv$v_setprv]
or .prvadr[prv$v_phy_io]
or .prvadr[prv$v_pfnmap]
or .prvadr[prv$v_sysprv]
or .prvadr[prv$v_readall]
or .prvadr[prv$v_bypass]
or (.uic<16, 16> lequ .EXE$GL_SYSUIC)
then return lstprva;			! Universal Privilege

if .prvadr[prv$v_diagnose]
or .prvadr[prv$v_volpro]
or .prvadr[prv$v_upgrade]
or .prvadr[prv$v_downgrade]
or .prvadr[prv$v_security]
or .prvadr[prv$v_sysgbl]
then return lstprvb;			! Potentially Comprimises File Security

if .prvadr[prv$v_pswapm]
or .prvadr[prv$v_setpri]
or .prvadr[prv$v_world]
or .prvadr[prv$v_oper]
then return lstprvc;			! Can Interfere with System Operation

if .prvadr[prv$v_grpnam]
or .prvadr[prv$v_allspool]
or .prvadr[prv$v_noacnt]
or .prvadr[prv$v_prmceb]
or .prvadr[prv$v_prmmbx]
or .prvadr[prv$v_exquota]
or .prvadr[prv$v_bugchk]
or .prvadr[prv$v_prmgbl]
or .prvadr[prv$v_shmem]
then return lstprvd;			! Can Devour System Resources

if .prvadr[prv$v_group]
or .prvadr[prv$v_grpprv]
then return lstprve;			! Can Interfere with Group Members

if .prvadr[prv$v_tmpmbx]
or .prvadr[prv$v_netmbx]
or .prvadr[prv$v_mount]
then return lstprvf;			! Normal Privileges

lstprvg					! Not Privileged
end;

%sbttl 'display_full - writes the full user display'
routine display_full =
begin

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Display the fields of a UAF record.
!
! INPUTS:
!
!	RABPTR - RMS data structure for the file
!
! IMPLICIT INPUTS:
!
!	none
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	none
!
! SIDE EFFECTS:
!
!	none
!--

!
! Display strings.
!

local
    status	: long ;

bind
    username	= cstring ('Username: !32AF Owner:  !AC'),
    account	= cstring ('Account:  !32AF UIC:    !%U (!%I)'),
    cli_table	= cstring ('CLI:      !32AC Tables: !AC'),
    default	= cstring ('Default:  !AC!AC'),
    lgicmd	= cstring ('LGICMD:   !AC'),
    flags	= cstring ('Login Flags: !AD'),
    flag_pad	= cstring (%char (cr), %char (lf), '             '),
    primdays	= cstring ('Primary days:  !7(AC)'),
    secdays	= cstring ('Secondary days:!7(AC)'),
    norestrict	= cstring ('No access restrictions'),
    accesshdr1	= cstring (
'Primary   000000000011111111112222  Secondary 000000000011111111112222'),
    accesshdr2	= cstring (
'Day Hours 012345678901234567890123  Day Hours 012345678901234567890123'),
    netaccess	= cstring ('Network:  !AD            !AD'),
    bataccess	= cstring ('Batch:    !AD            !AD'),
    locaccess	= cstring ('Local:    !AD            !AD'),
    diaaccess	= cstring ('Dialup:   !AD            !AD'),
    remaccess	= cstring ('Remote:   !AD            !AD'),
    expiration	= cstring ('Expiration: !AD    Pwdminimum: !2UL   Login Fails: !5UL'),
    pwddata	= cstring ('Pwdlifetime:       !AD    Pwdchange:  !AD !AD'),
    lastlogin	= cstring ('Last Login: !AD (interactive), !AD (non-interactive)'),
    quota1	= cstring ('Maxjobs:     !5UL  Fillm:     !5UL  Bytlm:    !9UL'),
    quota2	= cstring ('Maxacctjobs: !5UL  Shrfillm:  !5UL  Pbytlm:   !9UL'),
    quota3	= cstring ('Maxdetach:   !5UL  BIOlm:     !5UL  JTquota:  !9UL'),
    quota4	= cstring ('Prclm:       !5UL  DIOlm:     !5UL  WSdef:    !9UL'),
    quota5	= cstring ('Prio:        !5UL  ASTlm:     !5UL  WSquo:    !9UL'),
    quota6	= cstring ('Queprio:     !5UL  TQElm:     !5UL  WSextent: !9UL'),
    quota7	= cstring ('CPU: !13AD  Enqlm:     !5UL  Pgflquo:  !9UL'),
    privs	= cstring ('Authorized Privileges: '),
    defprivs	= cstring ('Default Privileges: '),

    nullstr	= cstring (''),

    mon  	= cstring (' Mon'),
    tue  	= cstring (' Tue'),
    wed  	= cstring (' Wed'),
    thu  	= cstring (' Thu'),
    fri  	= cstring (' Fri'),
    sat  	= cstring (' Sat'),
    sun  	= cstring (' Sun'),
    noday	= cstring ('    '),

    cputime	= recbuf[uaf$l_cputim];	! CPU limit in hundredths of a second

own
    flags_vector : vector [32] preset (
    [$bitposition (uaf$v_audit)]	= cstring (' Audit'),
    [$bitposition (uaf$v_captive)]	= cstring (' Captive'),
    [$bitposition (uaf$v_defcli)]	= cstring (' Defcli'),
    [$bitposition (uaf$v_disctly)]	= cstring (' Disctly'),
    [$bitposition (uaf$v_nomail)]	= cstring (' Dismail'),
    [$bitposition (uaf$v_dismail)]	= cstring (' Disnewmail'),
    [$bitposition (uaf$v_disreconnect)]	= cstring (' Disreconnect'),
    [$bitposition (uaf$v_disreport)]	= cstring (' Disreport'),
    [$bitposition (uaf$v_disacnt)]	= cstring (' Disuser'),
    [$bitposition (uaf$v_diswelcom)]	= cstring (' Diswelcome'),
    [$bitposition (uaf$v_genpwd)]	= cstring (' Genpwd'),
    [$bitposition (uaf$v_lockpwd)]	= cstring (' Lockpwd'),
    [$bitposition (uaf$v_pwd_expired)]	= cstring (' Pwd_expired'),
    [$bitposition (uaf$v_pwd2_expired)]	= cstring (' Pwd2_expired')
    );

local
	count,					! count for string being built
	lcount,					! count of chars on current line
	string		: vector [160, byte],	! buffer to build display string
	flag_string	: ref vector [,byte],	! pointer to flag string
	delta_time	: vector [long, 2],	! Scratch area for system delta time
	PTR,					! Pointer into UAF$Q_PWD_DATE quadword
	time1		: vector [17, byte],	! buffer for time string
	time2		: vector [17, byte],	! buffer for time string
	time3		: vector [17, byte];	! buffer for time string

builtin
	emul;



if .str_wild and not fmg$match_name (namelen (uaf$s_username,recbuf[uaf$t_username]), 
				     recbuf[uaf$t_username],
		                     .match_tokenlen,  match_token)
then return true;

found_match = true;

output_null;

faomac (username,
    uaf$s_username, recbuf[uaf$t_username],
    recbuf[uaf$t_owner]);

faomac (account,
    uaf$s_account, recbuf[uaf$t_account],
    .recbuf[uaf$l_uic],
    .recbuf[uaf$l_uic]);

faomac (cli_table,
    recbuf[uaf$t_defcli],
    recbuf[uaf$t_clitables]);

faomac (default,
    recbuf[uaf$t_defdev],
    recbuf[uaf$t_defdir]);

faomac (lgicmd,
    recbuf[uaf$t_lgicmd]);

count = 0;
lcount = .flags<0,8>;
incr j from 0 to 31
do
    begin
    if .bitvector [recbuf[uaf$l_flags], .j]
    and (flag_string = .flags_vector [.j]) neq 0
    then
	begin
	if .lcount + .flag_string[0] gtru 80
	then
	    begin
	    ch$move (.flag_pad<0,8>, flag_pad+1, string[.count]);
	    count = .count + .flag_pad<0,8>;
	    lcount = .flag_pad<0,8> - 2;
	    end;
	ch$move (.flag_string[0], flag_string[1], string[.count]);
	count = .count + .flag_string[0];
	lcount = .lcount + .flag_string[0];
	end;
    end;

faomac (flags,
    .count, string);

faomac (primdays,
    if .recbuf[uaf$v_monday]      then noday   else mon,
    if .recbuf[uaf$v_tuesday]     then noday   else tue,
    if .recbuf[uaf$v_wednesday]   then noday   else wed,
    if .recbuf[uaf$v_thursday]    then noday   else thu,
    if .recbuf[uaf$v_friday]      then noday   else fri,
    if .recbuf[uaf$v_saturday]    then noday   else sat,
    if .recbuf[uaf$v_sunday]      then noday   else sun);

faomac (secdays,
    if .recbuf[uaf$v_monday]      then mon     else noday,
    if .recbuf[uaf$v_tuesday]     then tue     else noday,
    if .recbuf[uaf$v_wednesday]   then wed     else noday,
    if .recbuf[uaf$v_thursday]    then thu     else noday,
    if .recbuf[uaf$v_friday]      then fri     else noday,
    if .recbuf[uaf$v_saturday]    then sat     else noday,
    if .recbuf[uaf$v_sunday]      then sun     else noday);

if ch$fail (ch$find_not_ch (10*uaf$s_network_access_p, recbuf[uaf$b_network_access_p], 0))
then
    begin
    faomac (norestrict);
    end
else
    begin
    faomac (accesshdr1);
    faomac (accesshdr2);

    display_hours (netaccess, recbuf[uaf$b_network_access_p]);
    display_hours (bataccess, recbuf[uaf$b_batch_access_p]);
    display_hours (locaccess, recbuf[uaf$b_local_access_p]);
    display_hours (diaaccess, recbuf[uaf$b_dialup_access_p]);
    display_hours (remaccess, recbuf[uaf$b_remote_access_p]);
    end;

convert_time (recbuf[uaf$q_expiration], 17, time1);
faomac (expiration,
    17, time1,
    .recbuf[uaf$b_pwd_length],
    .recbuf[uaf$w_logfails]);

convert_time (recbuf[uaf$q_pwd_lifetime], 10, time1);
PTR = RECBUF[UAF$Q_PWD_DATE];	! Because quadwords have "no" width
if (..PTR eql -1) and (.(.PTR+%upval) eql -1) then
   ch$move(17, uplit(%ascii'    (pre-expired)'), TIME2)
else
   CONVERT_TIME(.PTR, 17, TIME2);
convert_time (recbuf[uaf$q_pwd2_date], 17, time3);
faomac (pwddata,
    10, time1,
    17, time2,
    (if (. (recbuf[uaf$q_pwd2_date]+0) or . (recbuf[uaf$q_pwd2_date]+4)) eql 0
     then 0
     else 17), time3);

convert_time (recbuf[uaf$q_lastlogin_i], 17, time1);
convert_time (recbuf[uaf$q_lastlogin_n], 17, time2);
faomac (lastlogin,
    17, time1,
    17, time2);

emul (%ref (-200000), %ref (.cputime<1,31>),
      %ref (if .cputime<0,1> then -100000 else 0), delta_time);
convert_time (delta_time, 13, time1);

faomac (quota1,
    .recbuf[uaf$w_maxjobs],
    .recbuf[uaf$w_fillm],
    .recbuf[uaf$l_bytlm]);

faomac (quota2,
    .recbuf[uaf$w_maxacctjobs],
    .recbuf[uaf$w_shrfillm],
    .recbuf[uaf$l_pbytlm]);

faomac (quota3,
    .recbuf[uaf$w_maxdetach],
    .recbuf[uaf$w_biolm],
    .recbuf[uaf$l_jtquota]);

faomac (quota4,
    .recbuf[uaf$w_prccnt],
    .recbuf[uaf$w_diolm],
    .recbuf[uaf$l_dfwscnt]);

faomac (quota5,
    .recbuf[uaf$b_pri],
    .recbuf[uaf$w_astlm],
    .recbuf[uaf$l_wsquota]);

faomac (quota6,
    .recbuf[uaf$b_quepri],
    .recbuf[uaf$w_tqcnt],
    .recbuf[uaf$l_wsextent]);

faomac (quota7,
    13, time1,
    .recbuf[uaf$w_enqlm],
    .recbuf[uaf$l_pgflquota]);

faomac (privs);
print_priv (recbuf[uaf$q_priv]);

faomac (defprivs);
print_priv (recbuf[uaf$q_def_priv]);

!
! Build a holder from the UAF record and display the rights
! granted to it.
!
if .rdb_exists
then
    begin
    uaf$build_holder ();
    rdb_header_flag = true ;
    status = uaf$write_rights ( holder ) ;
    end ;

return .status ;
end;

%sbttl 'display_hours - display hourly restrictions'
routine display_hours (format_string, hour_vector) : novalue =
begin

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Displays the hourly access for primary and secondary days
!	for one access type.
!
! INPUTS:
!
!	format_string: address of FAO string for display
!	hour_vector: address of UAF record hourly vector
!	RABPTR - RMS data structure for the file
!
! IMPLICIT INPUTS:
!
!	none
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	none
!
! SIDE EFFECTS:
!
!	none
!--

!
! Display strings.
!

map
    hour_vector : ref bitvector;

literal
	yeschar		= '#',
	nochar		= '-';

bind
	noaccess	= cstring ('-----  No access  ------'),
	fullaccess	= cstring ('##### Full access ######');

local
	pri_access	: vector [24, byte],	! Character string for primary access
	sec_access	: vector [24, byte];	! Character string for secondary access

if . (hour_vector[0])<0,24> eql 0
then ch$move (24, fullaccess+1, pri_access)
else if . (hour_vector[0])<0,24> eql %x'ffffff'
then ch$move (24, noaccess+1, pri_access)
else incr j from 0 to 23
do
    begin
    if .hour_vector[.j]
    then pri_access[.j] = nochar
    else pri_access[.j] = yeschar;
    end;

if . (hour_vector[0])<24,24> eql 0
then ch$move (24, fullaccess+1, sec_access)
else if . (hour_vector[0])<24,24> eql %x'ffffff'
then ch$move (24, noaccess+1, sec_access)
else incr j from 0 to 23
do
    begin
    if .hour_vector[.j+24]
    then sec_access[.j] = nochar
    else sec_access[.j] = yeschar;
    end;

faomac (.format_string,
	24, pri_access,
	24, sec_access
);
end;

%sbttl 'convert_time - convert time value to string'
routine convert_time (time, length, buffer) : novalue =
begin

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Converts the binary time value into a string, substituting
!	the string " (none)" if the value is zero.
!
! INPUTS:
!
!	time: address of quadword time
!	length: length of output string
!	buffer: address of output buffer
!
! IMPLICIT INPUTS:
!
!	none
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	none
!
! SIDE EFFECTS:
!
!	none
!--

map
	time		: ref vector;

local
	string_desc	: vector [2];	! descriptor for buffer

if (.time[0] or .time[1]) eql 0
then
    begin
    ch$fill (' ', .length-6, .buffer);
    ch$move (6, uplit byte ('(none)'), .buffer+.length-6);
    end

else
    begin
    string_desc[0] = .length;
    string_desc[1] = .buffer;
    $asctim (timadr = .time, timbuf = string_desc);
    end;
end;

%sbttl 'print_priv - print privilege bits'
routine print_priv (prvadr) : novalue =
begin

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Routine to output the names of the privilege bits set
!	in the privilege vector supplied.
!
! INPUTS:
!
!	PRVADR - Address of the privilege vector
!
! IMPLICIT INPUTS:
!
!	PRV$AB_NAMES - table of privilege names and bit numbers
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	none
!
! SIDE EFFECTS:
!
!	none
!
!--

local
	pointer,			! current location in PRV$AB_NAMES
	prvcnt,				! number of names in DISBUF
	symlen,				! length of bit name string
	symmin,				! minimum symbol length
	symval;				! value (bit number)

!
! Initialize the buffer.
!

disbuf = ' ';				! insert blank at start
prvcnt = 0;
rabptr[rab$w_rsz] = 1;
pointer = prv$ab_names;			! point to symbol name table

while (symmin = . (.pointer)<0,8>) neq 0 ! pick up min symbol size
do
    begin

!
! Pick up the next bit name and number.  If the bit is set, insert
! the bit name into the buffer.   When the buffer fills up output them
! to the user.
!

    pointer = .pointer + 1;
    symval = . (.pointer)<0,8>;		! get bit number
    pointer = .pointer + 1;
    symlen = . (.pointer)<0,8>;		! get name string length
    pointer = .pointer + 1;		! point to string
    if . (.prvadr)<.symval,1>
    AND CH$NEQ(.SYMLEN, .POINTER, 7, UPLIT('UPGRADE'))		!**
    AND CH$NEQ(.SYMLEN, .POINTER, 9, UPLIT('DOWNGRADE'))	!**
    AND CH$NEQ(.SYMLEN, .POINTER, 6, UPLIT('TMPJNL'))		!**
    AND CH$NEQ(.SYMLEN, .POINTER, 6, UPLIT('PRMJNL'))		!**
    then
	begin

!
! Bit is set.  See if there's room in the buffer and insert it if so,
! else output the buffer and start from scratch.
!

	if .rabptr[rab$w_rsz] + .symlen geq 64
	then
	    begin
	    $put (rab = .rabptr);
	    prvcnt = 0;
	    rabptr[rab$w_rsz] = 1;
	    end;

!
! Insert a blank and append symbol name.
!

	disbuf[.rabptr[rab$w_rsz]] = %char (' ');
	rabptr[rab$w_rsz] = .rabptr[rab$w_rsz] + 1;
	ch$move (.symlen, .pointer, disbuf[.rabptr[rab$w_rsz]]);
	rabptr[rab$w_rsz] = .rabptr[rab$w_rsz] + .symlen;
	prvcnt = .prvcnt + 1;		! one more name in buffer
	end;

    pointer = .pointer + .symlen;	! update table pointer over name
    end;

!
! Table used up.  If anything is in the buffer, print it.
!

if .prvcnt gtr 0
then $put (rab = .rabptr);

end;

%sbttl 'build_ini_recs - build system & default records'
routine build_ini_recs : novalue =
begin

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Build the initial records for the creation of a new UAF file.
!	The user default record is built in the DEFAULT_RECORD
!	buffer and the system manager record is built in RECBUF.
!
! INPUTS:
!
!	none
!
! IMPLICIT INPUTS:
!
!	none
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	default record is built in DEFAULT_RECORD
!	system record is built in RECBUF
!
! ROUTINE VALUE:
!
!	none
!
! SIDE EFFECTS:
!
!	none
!--

local
	user_desc	: $bblock [8];

ch$fill (0, uaf$c_fixed, default_record);
default_record[uaf$b_version] = uaf$c_version1;
default_record[uaf$b_rtype] = uaf$c_user_id;
!
! username is blank filled
!

ch$copy (.defuser<0,8>, defuser+1, %char (' '),
	 uaf$s_username, default_record[uaf$t_username]);

!
! account name is blank filled
!

ch$copy (.defact<0,8>, defact+1, %char (' '),
	 uaf$s_account, default_record[uaf$t_account]);

!
! quadword privilege mask
!

ch$move (8, defpriv, default_record[uaf$q_priv]);
ch$move (8, defpriv, default_record[uaf$q_def_priv]);

!
! directory name is counted string
!

ch$copy (.defdir<0,8> + 1, defdir, %char (' '),
	 uaf$s_defdir, default_record[uaf$t_defdir]);

!
! device name is counted string
!

ch$copy (.defdev<0,8> + 1, defdev, %char (' '),
	 uaf$s_defdev, default_record[uaf$t_defdev]);

!
! CLI name is counted string
!

ch$copy (.defcli<0,8> + 1, defcli, %char (' '),
	 uaf$s_defcli, default_record[uaf$t_defcli]);

!
! owner name is counted string
!

ch$copy (.defowner<0,8> + 1, defowner, %char (' '),
	 uaf$s_owner, default_record[uaf$t_owner]);

!
! login command file name is counted string
!

ch$copy (.deflgicmd<0,8> + 1, deflgicmd, %char (' '),
	 uaf$s_lgicmd, default_record[uaf$t_lgicmd]);

!
! fill in default CLI tables
!
ch$copy (.defclitabl<0,8> + 1, defclitabl, %char (' '),
	 uaf$s_clitables, default_record[uaf$t_clitables]);

ch$move (8, defpwdlife, default_record[uaf$q_pwd_lifetime]);
default_record[uaf$b_pwd_length] = defpwdlength;
default_record[uaf$w_grp] = defgrp;
default_record[uaf$w_mem] = defmem;
default_record[uaf$w_biolm] = defbiolm;
default_record[uaf$l_bytlm] = defbytlm;
default_record[uaf$w_diolm] = defdiolm;
default_record[uaf$w_fillm] = deffillm;
default_record[uaf$l_flags] = defflags;
default_record[uaf$w_tqcnt] = deftqcnt;
default_record[uaf$w_prccnt] = defprccnt;
default_record[uaf$l_wsquota] = defwsquota;
default_record[uaf$l_wsextent] = defwsextent;
default_record[uaf$l_dfwscnt] = defdfwscnt;
default_record[uaf$l_cputim] = defcputim;
default_record[uaf$w_astlm] = defastlm;
default_record[uaf$l_pgflquota] = defpgflquota;
default_record[uaf$w_enqlm] = defenqlm;
default_record[uaf$l_pbytlm] = defpbytlm;
default_record[uaf$w_shrfillm] = defshrfillm;
default_record[uaf$b_pri] = defpri;
default_record[uaf$b_quepri] = defquepri;
default_record[uaf$w_maxjobs] = defmaxjobs;
default_record[uaf$w_maxdetach] = defmaxdetach;
default_record[uaf$l_jtquota] = defjtquota;
default_record[uaf$w_maxacctjobs] = defmaxacctjobs;
default_record[uaf$b_primedays] = defprimedays;
default_record[uaf$b_network_access_p] = defhours;
default_record[uaf$b_network_access_s] = defhours;
default_record[uaf$b_batch_access_p] = defhours;
default_record[uaf$b_batch_access_s] = defhours;
default_record[uaf$b_local_access_p] = defhours;
default_record[uaf$b_local_access_s] = defhours;
default_record[uaf$b_dialup_access_p] = defhours;
default_record[uaf$b_dialup_access_s] = defhours;
default_record[uaf$b_remote_access_p] = defhours;
default_record[uaf$b_remote_access_s] = defhours;

ch$fill (0, uaf$c_fixed, recbuf);
recbuf[uaf$b_version] = uaf$c_version1;
recbuf[uaf$b_rtype] = uaf$c_user_id;
ch$copy (.sysuser<0,8>, sysuser+1, %char (' '),
	 uaf$s_username, recbuf[uaf$t_username]);
ch$copy (.sysact<0,8>, sysact+1, %char (' '),
	 uaf$s_account, recbuf[uaf$t_account]);
ch$move (8, syspriv, recbuf[uaf$q_priv]);
ch$move (8, syspriv, recbuf[uaf$q_def_priv]);
ch$copy (.sysdir<0,8> + 1, sysdir, %char (' '),
	 uaf$s_defdir, recbuf[uaf$t_defdir]);
ch$copy (.sysdev<0,8> + 1, sysdev, %char (' '),
	 uaf$s_defdev, recbuf[uaf$t_defdev]);
ch$copy (.syscli<0,8> + 1, syscli, %char (' '),
	 uaf$s_defcli, recbuf[uaf$t_defcli]);
ch$copy (.sysowner<0,8> + 1, sysowner, %char (' '),
	 uaf$s_owner, recbuf[uaf$t_owner]);
ch$copy (.syslgicmd<0,8> + 1, deflgicmd, %char (' '), 
	 uaf$s_lgicmd, recbuf[uaf$t_lgicmd]);
ch$copy (.sysclitabl<0,8> + 1, sysclitabl, %char (' '),
	 uaf$s_clitables, recbuf[uaf$t_clitables]);

pwddsc[dsc$w_length] = .syspass<0,8>;
pwddsc[dsc$a_pointer] = syspass+1;
user_desc[dsc$w_length] = .sysuser<0,8>;
user_desc[dsc$a_pointer] = sysuser+1;
$gettim (timadr = time_buf);			! Obtain a 16 bit salt
recbuf[uaf$w_salt] = .time_buf<3*8,16>;
recbuf[uaf$b_encrypt] = encrypt;
lgi$hpwd (rec_encrypt_dsc, pwddsc, .recbuf[uaf$b_encrypt],
	  .recbuf[uaf$w_salt], user_desc);

ch$move (8, syspwdlife, recbuf[uaf$q_pwd_lifetime]);
recbuf[uaf$b_pwd_length] = syspwdlength;
recbuf[uaf$w_grp] = sysgrp;
recbuf[uaf$w_mem] = sysmem;
recbuf[uaf$w_biolm] = sysbiolm;
recbuf[uaf$l_bytlm] = sysbytlm;
recbuf[uaf$w_diolm] = sysdiolm;
recbuf[uaf$w_fillm] = sysfillm;
recbuf[uaf$l_flags] = sysflags;
recbuf[uaf$w_tqcnt] = systqcnt;
recbuf[uaf$w_prccnt] = sysprccnt;
recbuf[uaf$l_wsquota] = syswsquota;
recbuf[uaf$l_wsextent] = syswsextent;
recbuf[uaf$l_dfwscnt] = sysdfwscnt;
recbuf[uaf$l_cputim] = syscputim;
recbuf[uaf$w_astlm] = sysastlm;
recbuf[uaf$l_pgflquota] = syspgflquota;
recbuf[uaf$w_enqlm] = sysenqlm;
recbuf[uaf$l_pbytlm] = syspbytlm;
recbuf[uaf$w_shrfillm] = sysshrfillm;
recbuf[uaf$b_pri] = syspri;
default_record[uaf$b_quepri] = sysquepri;
recbuf[uaf$w_maxdetach] = sysmaxdetach;
recbuf[uaf$l_jtquota] = sysjtquota;
recbuf[uaf$w_maxjobs] = sysmaxjobs;
recbuf[uaf$w_maxdetach] = sysmaxdetach;
recbuf[uaf$w_maxacctjobs] = sysmaxacctjobs;
recbuf[uaf$b_primedays] = sysprimedays;
recbuf[uaf$b_network_access_p] = defhours;
recbuf[uaf$b_network_access_s] = defhours;
recbuf[uaf$b_batch_access_p] = defhours;
recbuf[uaf$b_batch_access_s] = defhours;
recbuf[uaf$b_local_access_p] = defhours;
recbuf[uaf$b_local_access_s] = defhours;
recbuf[uaf$b_dialup_access_p] = defhours;
recbuf[uaf$b_dialup_access_s] = defhours;
recbuf[uaf$b_remote_access_p] = defhours;
recbuf[uaf$b_remote_access_s] = defhours;
end;

%sbttl 'get_user_record - get username and lookup record'
routine get_user_record (lock_record, permanent_ok) =
begin

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine pulls the next token out of the command
!	buffer, assuming it is the username, and looks up the
!	UAF record for that name.  If the record is found,
!	it is loaded into RECBUF (by routine LOCATE_USER) .
!
! INPUTS:
!
!	LOCK_RECORD - specifies that the GET shall lock the record
!	PERMANENT_OK - specifies that the DEFAULT and SYSTEM records are allowed
!
! IMPLICIT INPUTS:
!
!	TOKENPTR - address of delimiter following last token processed,
!		  which was the command name.
!	TOKENLEN - global variable to contain length of current token
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	true -> user record found
!	false -> user record not found
!
! SIDE EFFECTS:
!
!	none
!--

builtin
	nullparameter;

!
! Is this the second phase of a RENAME?
!
if .rename_ph2
then
    begin
    if .netuaf_exists
    then adjust_proxy (update_records);
    ch$move (.olduserlen, oldusername, .tokenptr); 
    tokenlen = .olduserlen;
    rename_ph2 = false;
    end
!
! Not the second phase of a RENAME.  Get first token, and if this
! is the first phase of a RENAME (COPY phase), save token for 
! the second phase (REMOVE phase).
!
else
    begin
!
! Get token
!
        if not cli$present (sd_token1)
	or not cli$get_value (sd_token1,tokendsc)
	or .tokenlen eql 0
        then return LIB$SIGNAL(UAF$_NOUSERNAME);
!
! If the third argument is present, this is the first phase of a 
! RENAME,  so save the token for the next call 
!    
	if not nullparameter (3)
	then
	    begin
	    ch$copy (.tokenlen, .tokenptr, ' ', uaf$s_username, oldusername);
	    olduserlen = .tokenlen;
	    rename_ph2 = true;
	    end;
	end;

if not .permanent_ok
then
    begin
    if ch$eql (.defuser<0,8>, defuser+1, .tokenlen, .tokenptr, ' ')
    then
	if nullparameter (3)
	then
	    return LIB$SIGNAL(UAF$_REMDEF)
	else
	    return LIB$SIGNAL(UAF$_RENDEF);

    if ch$eql (.sysuser<0,8>, sysuser+1, .tokenlen, .tokenptr, ' ')
    then
	begin
	if nullparameter (3)
	then
	    return LIB$SIGNAL(UAF$_REMSYS)
	else
	    return LIB$SIGNAL(UAF$_RENSYS);
	end;
    end;

if locate_user (.tokenlen, .tokenptr, .lock_record) 
then return true; 

if .rmserr eql rms$_rnf
then
    LIB$SIGNAL(UAF$_BADUSR, 2, .tokenlen, .tokenptr)
else
    LIB$SIGNAL(UAF$_GETERR, 0, .rmserr);
false
end;

%sbttl 'locate_user - lookup user record in UAF'
routine locate_user (size, buffer, lock_record) =
begin

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Routine to locate a user record in the UAF file.
!
! INPUTS:
!
!	SIZE - size of the username string
!	BUFFER - address of the username string
!	LOCK_RECORD - specifies that the GET shall lock the record
!
! IMPLICIT INPUTS:
!
!	UAFRAB - RMS data structure for SYSUAF.DAT
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	If record is found, RECBUF contains the located record.
!
! ROUTINE VALUE:
!
!	true -> record found
!	false -> record not found
!
! SIDE EFFECTS:
!
!	none
!--

local
	found;					! record found indicator

found = true;					! assume record was found

ch$copy (.size, .buffer, %char (' '),
	 uaf$s_username, recbuf[uaf$t_username]);

if .lock_record
then uafrab[rab$l_rop] = rab$m_rlk
else uafrab[rab$l_rop] = rab$m_rrl or rab$m_nlk;

if not (rmserr = get_uaf_record ())
then found = false;

return .found;					! return indicator
end;

%sbttl 'get_uaf_record - routine to deal with record locking'
routine get_uaf_record =
begin

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	A common routine to GET records from SYSUAF.DAT, deal with retries 
!	when the record is locked.
!
! INPUTS:
!
!	none
!
! IMPLICIT INPUTS:
!
!	UAFRAB - RMS data structure for SYSUAF.DAT
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	RECBUF - The user's record
!
! ROUTINE VALUE:
!
!	RMS status code
!
! SIDE EFFECTS:
!
!	none
!--

local
	counter,			! number of retries remaining
	success;

!
! If anybody's record is locked it shouldn't remain that way for long.
! Also, ignore the special system password record.
!

counter = retry_rlk;
while ( ((success = $get (rab = uafrab)) eql rms$_rlk)
        or ch$eql(UAF$S_USERNAME, RECBUF[UAF$T_USERNAME],
                17, uplit(%ascii'<System+Password>'), %c' ') )
      and ( (counter = .counter - 1) geq 0)
do
    if $schdwk (daytim = wakedelta) then $hiber;

.success
end;

%sbttl 'get_cmd_line - input user command line'
routine get_cmd_line =
begin

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine reads in the command line from the user, 
!	reading additional lines if continuation is specified by
!	a '-' as the last character on the input line.
!	A zero byte is inserted following the last input character read.
!
! INPUTS:
!
!	none
!
! IMPLICIT INPUTS:
!
!	CMDBUF - buffer to receive the user's command line
!	CMDBUFLEN - literal length of CMDBUF
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	CMDBUF is filled with command line
!
! ROUTINE VALUE:
!
!	none
!
! SIDE EFFECTS:
!
!	none
!--

map
	cmdlindsc: vector;

local
	ptr,				! index into CMDBUF
	buflen;				! remaining buffer length

!
! Prompt with normal prompt string until some input is supplied.
!

do
    ask (accprmpt, cmdbuf[0], cmdbuflen)
until
    .insize neq 0;

!
! Now that line has been read, continue reading until
! last character is not a '-'.
!

ptr = .insize - 1;				! index to last character read
buflen = cmdbuflen;				! initial buffer size

while
    .cmdbuf[.ptr] eql '-'
do
    begin

    !
    ! Read starting at the position of the '-'. Then adjust the
    ! index and remaining length to point to the last character
    ! of the next input.
    !

    buflen = .buflen - (.insize + 1);
    ask (accprmpt2, cmdbuf[.ptr], .buflen);
    if (.ptr + .insize)  lss  cmdbufmax
    then
	ptr = .ptr + .insize - 1 
    else
	begin
	LIB$SIGNAL(UAF$_CMDTOOLONG, 1, cmdbufmax);
	return false;
	end;
    end;


cmdlindsc [0] = .ptr + 1;
cmdlindsc [1] = cmdbuf;

return true;
 
end;

%sbttl 'ask - prompt terminal for input'
global routine ask (string, buffer, len) : novalue =
begin

!++
!
! FUNCTIONAL DESCTIPTION:
!
!	Routine to prompt user for input.  The input string is read
!	into the user specified buffer and the size read
!	is placed in the global INSIZE.
!
! INPUTS:
!
!	STRING - the address of a counted ascii prompt string
!	BUFFER - address of the input buffer
!	LEN - length of the input buffer
!
! IMPLICIT INPUTS:
!
!	none
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	INSIZE - size of the input string
!
! ROUTINE VALUE:
!
!	none
!
! SIDE EFFECTS:
!
!	none
!--

map
	buffer	: ref vector[,byte];

inrab[rab$l_pbf] = .string + 1;			! prompt string address
inrab[rab$b_psz] = . (.string)<0,8>;		! prompt size
inrab[rab$l_ubf] = .buffer;			! buffer address
inrab[rab$w_usz] = .len;			! buffer size

!
! If end of file encountered on get (either ^Z from terminal or
! end of file on indirect command file) then take exit path.
!

if $get (rab=inrab) eql rms$_eof
then exit_uaf ();

if (insize = .inrab[rab$w_rsz]) neq 0			! get input size
then
    begin
    incru i to .insize - 1				! Upcasing is done here because the CVT
    do							! option does not work under batch.
	begin
	if .buffer[.i] gequ 'a' and .buffer[.i] lequ 'z'
	then buffer[.i] = .buffer[.i] and not %o'040';
	end;
    end;
end;

%sbttl 'fmt_sys_msg - output system message file message'
global routine fmt_sys_msg (faostr, msgid, p1) : novalue =
begin

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine outputs an error message followed by
!	the text found in the system message file for the 
!	error condition.  If the message is not found, the message
!	ID itself is printed.
!
! INPUTS:
!
!	FAOSTR - address of counted ascii message to be printed
!	MSGID  - error number
!	P1     - the first of possibly several parameters to FAO
!
! IMPLICIT INPUTS:
!
!	None
!
! OUTPUTS:
!
!	None
!
! IMPLICIT OUTPUTS:
!
!	None
!
! ROUTINE VALUE:
!
!	None
!
! SIDE EFFECTS:
!
!	None
!--

local
	buffer	: vector [200, byte],		! buffer to receive message
	bufdsc	: vector [2, long],		! string descriptor
	code;					! save return code

bufdsc[0] = 200;				! construct string descriptor
bufdsc[1] = buffer;

code = $getmsg (msgid = .msgid, msglen = bufdsc[0], bufadr = bufdsc[0]);

!
! Output internal message.  Then output system error or error number.
!
faodsc[dsc$w_length] = . (.faostr)<0,8>;	! input string descriptor
faodsc[dsc$a_pointer] = .faostr+1;
$faol (ctrstr = faodsc,
       outlen = outrab[rab$w_rsz],
       outbuf = disdsc,
       prmlst = p1);

$put (rab = outrab);

if .code eql ss$_msgnotfnd
then LIB$SIGNAL(UAF$_SYSMSG2, 1, .msgid)
else LIB$SIGNAL(UAF$_SYSMSG1, 1, bufdsc[0]);
end;

%sbttl 'faoout - output formatted message'
global routine faoout (string, p1) =
begin

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Routine to output a formatted string.
!
! INPUTS:
!
!	STRING - address of a counted ASCII FAO control string.
!	P1 - the first of possibly several parameters to FAO
!
! IMPLICIT INPUTS:
!
!	none
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	FAOOUT always returns FALSE, as it is often used on the
!	return from an error condition.
!
! SIDE EFFECTS:
!
!	none
!--


faodsc[dsc$w_length] = . (.string)<0,8>;	! input string descriptor
faodsc[dsc$a_pointer] = .string+1;
$faol (ctrstr = faodsc,
       outlen = outrab[rab$w_rsz],
       outbuf = disdsc,
       prmlst = p1);

$put (rab = outrab);

false
end;

%sbttl 'help_uaf - help routine'
global routine help_uaf : novalue =
begin

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Print out the help message or messages.
!
! INPUTS:
!
!	none
!
! OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	none
!
! SIDE EFFECTS:
!
!	none
!--

map
	cmdlindsc: vector;

local
	line_dsc	: vector [2];

line_dsc[0] = .cmdlindsc[0];
line_dsc[1] = .cmdlindsc[1];

!
! The first thing to do is to remove 'help' from the command line
! and give the help routine the remainder of the command line.
! Find the beginning of the word 'help'.
!
if .(.line_dsc[1])<0,8> eql ' '
then
    begin
    line_dsc[1] = ch$find_not_ch (.line_dsc[0], .line_dsc[1], ' ');
    line_dsc[0] = .line_dsc[0] - (.line_dsc[1] - .cmdlindsc[1]);
    end;

!
! Now skip past the 'help' to the first blank (if there is one)
!
if ch$fail (line_dsc[1] = ch$find_ch (.line_dsc[0], .line_dsc[1], ' '))
then
    !
    ! No blank, set empty string
    !
    line_dsc[0] = 0
else
    !
    ! Found a blank, set pointer to it
    !
    line_dsc[0] = .cmdlindsc[0] - (.line_dsc[1] - .cmdlindsc[1]);

!
! Start an interactive HELP session
!

if not lbr$output_help (lib$put_output, 0, line_dsc,
			$descriptor ('uafhelp'), 0,
			lib$get_input)
then LIB$SIGNAL(UAF$_HELPERR);

end;

%sbttl 'exit_uaf - normal exit routine'
global routine exit_uaf : novalue =
begin

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Normal exit routine.
!
! INPUTS:
!
!	none
!
! OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	none
!
! SIDE EFFECTS:
!
!	image exits
!--

$close (fab = uaffab);

!
! Inform user of file modifications.
!

if .modify_flag
then
!
! File has been modified
!
    LIB$SIGNAL(UAF$_DONEMSG)		! tell user all is done
else
!
! Here, no modifications were made to file.
!
    LIB$SIGNAL(UAF$_NOMODS);

if .netuaf_exists 
then
    begin
    if not .netuaf_modified
    then
	LIB$SIGNAL(UAF$_NAFNOMODS)
    else
	LIB$SIGNAL(UAF$_NAFDONEMSG);
    end;

if .rdb_exists
then
    begin
    if .rightslist_modified
    then
    !
    ! File has been modified
    !
	LIB$SIGNAL(UAF$_RDBDONEMSG)		! tell user all is done
    else
    !
    ! Here, no modifications were made to file.
    !
	LIB$SIGNAL(UAF$_RDBNOMODS);
    end ;

$exit (code = true);
end;

%sbttl 'SIGNAL_SYNTAX - Report missing qualifier'
global routine SIGNAL_SYNTAX: novalue =
begin

   LIB$SIGNAL(UAF$_ZISQUAL);

end;

%sbttl 'acc$exit - exit and cleanup routine'
routine acc$exit : novalue =
begin

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Exit on error condition.
!
! INPUTS:
!
!	none
!
! OUTPUTS:
!
!	none
!--

$exit ();
end;

%sbttl 'UAF$MOD_SYS_PWD -- modify the system password'
global routine UAF$MOD_SYS_PWD: novalue =
begin

!++
!
! Functional Description:
!
!	Modify the system password record by doing a $PUT on the UAF
!	with the UIF bit set for the username "<System+Password>"
!
!--

local

   RBF,
   PWD: block[DSC$K_D_BLN, byte]
        preset([DSC$B_CLASS] = DSC$K_CLASS_D),
   ROP;

!
!	Save current settings
!

RBF = .UAFRAB[RAB$L_RBF];
ROP = .UAFRAB[RAB$L_ROP];

!
!	Get new password and encrypt it
!

CLI$GET_VALUE(%ascid'SYSTEM_PASSWORD', PWD);

if .PWD[DSC$W_LENGTH] neq 0 then
   LGI$HPWD(REC_ENCRYPT_DSC, PWD, UAF$C_PURDY_V, 0, %ASCID'<System+Password>')
else
   ch$fill(0, UAF$S_PWD, RECBUF[UAF$Q_PWD]);

!
!	Fill in fields of the UAF record
!

ch$copy(17, UPLIT('<System+Password>'), ' ', 
        UAF$S_USERNAME, RECBUF[UAF$T_USERNAME]);
RECBUF[UAF$W_SALT] = 0;

!
!	Modify the RAB for our needs
!

UAFRAB[RAB$V_UIF] = 1;
UAFRAB[RAB$W_RSZ] = UAF$C_LENGTH;
UAFRAB[RAB$L_RBF] = RECBUF;

!
!	Modify the system password
!

$PUT(RAB=UAFRAB);

!
!	Replace the settings
!

UAFRAB[RAB$L_RBF] = .RBF;
UAFRAB[RAB$L_ROP] = .ROP;

end;

%sbttl 'security_audit - perform a security audit'
routine security_audit (code, old_user) : novalue =
begin

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Perform a security audit, if needed.
!
! INPUTS:
!
!	CODE - Security audit record id
!	OLD_USER - Old username (optional depending on the record id)
!
! IMPLICIT INPUTS:
!
!	PCB_STS - This process's PCB status
!	UAF$GQ_SYSUAFF - SYSUAF fields modified
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	none
!
! SIDE EFFECTS:
!
!	none
!
!--

external routine
	nsa$event_audit;		! Kernel mode auditing routine

external
	nsa$gr_alarmvec	: block [,byte], ! Security audit alarm vector
	nsa$gr_journvec	: block [,byte]; ! Security audit journal vector

macro
	add_quad_packet(type, a_quad) =	! Add a quadword packet to list
	    begin
	    (.arglist_ptr)<0,16> = %name('nsa$k_pkttyp_', type);
	    arglist_ptr = .arglist_ptr + 2;
	    (.arglist_ptr)<0,16> = nsa$k_arg_mech_quad;
	    arglist_ptr = .arglist_ptr + 2;
	    (.arglist_ptr)<0,32> = .(a_quad)<0,32>;
	    arglist_ptr = .arglist_ptr + 4;
	    (.arglist_ptr)<0,32> = .(a_quad)<32,32>;
	    arglist_ptr = .arglist_ptr + 4;
	    arglist[nsa$b_arg_pktnum] = .arglist[nsa$b_arg_pktnum] + 1;
	    end%,
	add_descr_packet(type, len, ptr) = ! Add a descriptor packet to list
	    begin
	    (.arglist_ptr)<0,16> = %name('nsa$k_pkttyp_', type);
	    arglist_ptr = .arglist_ptr + 2;
	    (.arglist_ptr)<0,16> = nsa$k_arg_mech_descr;
	    arglist_ptr = .arglist_ptr + 2;
	    (.arglist_ptr)<0,32> = len;
	    arglist_ptr = .arglist_ptr + 4;
	    (.arglist_ptr)<0,32> = ptr;
	    arglist_ptr = .arglist_ptr + 4;
	    arglist[nsa$b_arg_pktnum] = .arglist[nsa$b_arg_pktnum] + 1;
	    end%;

local
	arglist		: block		! Argument list for NSA$EVENT_AUDIT
	    [nsa$k_arghdr_length + ((2 + 2 + 8) * 6), byte],
	arglist_ptr;			! Packet fill in pointer

ch$fill(0, %allocation(arglist), arglist); ! Clear out the argument list

if .nsa$gr_alarmvec[nsa$v_evt_uaf]	! If alarm auditing,
then arglist[nsa$v_arg_flag_alarm] = true; !  perform alarm audit

if .nsa$gr_journvec[nsa$v_evt_uaf]	! If journal auditing,
then arglist[nsa$v_arg_flag_journ] = true; !  perform journal audit

if .pcb_sts[$bitposition(pcb$v_secaudit)] ! If mandatory auditing,
then arglist[nsa$v_arg_flag_mandy] = true; !  perform mandatory audit

if .arglist[nsa$b_arg_flag] eql 0	! If no audit requested,
then return;				!  simply exit

arglist[nsa$l_arg_id] = .code;		! Set audit record type/subtype

arglist_ptr = arglist[nsa$t_arg_list];	! Address packet(s) in arg list

if .arglist[nsa$w_arg_type] eql nsa$k_rectyp_sysuaf
then					! For SYSUAF records...
    begin
    if .arglist[nsa$w_arg_subtype] neq nsa$k_rectyp_sysuaf_del
    then
	add_quad_packet(sysuaff, uaf$gq_sysuaff);
    add_descr_packet(usernam,
		     namelen(uaf$s_username, recbuf[uaf$t_username]),
		     recbuf[uaf$t_username]);
    if .arglist[nsa$w_arg_subtype] eql nsa$k_rectyp_sysuaf_cop
    or .arglist[nsa$w_arg_subtype] eql nsa$k_rectyp_sysuaf_ren
    then
	add_descr_packet(usernam,
			 namelen(uaf$s_username, .old_user),
			 .old_user);
    end
else					! For NETUAF records...
    begin
    add_descr_packet(nodenam,
		     namelen(naf$s_node, netbuf[naf$t_node]),
		     netbuf[naf$t_node]);
    add_descr_packet(usernam,
		     namelen(naf$s_remuser, netbuf[naf$t_remuser]),
		     netbuf[naf$t_remuser]);
    add_descr_packet(usernam,
		     namelen(naf$s_localuser, netbuf[naf$t_localuser]),
		     netbuf[naf$t_localuser]);
    if .arglist[nsa$w_arg_subtype] eql nsa$k_rectyp_netuaf_mod
    then
	begin
	add_descr_packet(nodenam,
			 namelen(naf$s_node, netbuf[naf$t_node]),
			 netbuf[naf$t_node]);
	add_descr_packet(usernam,
			 namelen(naf$s_remuser, netbuf[naf$t_remuser]),
			 netbuf[naf$t_remuser]);
	add_descr_packet(usernam,
			 namelen(uaf$s_username, .old_user),
			 .old_user);
	end;
    end;

arglist[nsa$l_arg_count] = (.arglist_ptr - (arglist + 4)) / 4; ! Set # args

$cmkrnl(routin = nsa$event_audit, arglst = arglist); ! Do the security audit

end;

end					! End of module
eludom
