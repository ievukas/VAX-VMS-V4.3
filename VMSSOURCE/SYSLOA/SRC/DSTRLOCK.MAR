	.TITLE	DSTRLOCK - Distributed Lock Manager Loadable Code
	.IDENT	'V04-001'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
;
; FACILITY:	Executive, system services and fork level code
;
; ABSTRACT:
;	This module contains routines used to implement distributed
;	lock manager functions.
;
; ENVIRONMENT:	Kernel mode, fork level, loadable code
;
;--
;
; AUTHOR: Steve Beckhardt,	 CREATION DATE:	11-Oct-1982
;
; MODIFIED BY:
;
;	V04-001	SRB0144		Steve Beckhardt			6-Sep-1984
;		Fixed race condition in conversion code that could
;		ultimately clobber value blocks.  Also fixed bug in
;		CVTRETRY_PROC code for locks in RETRY state that are
;		ultimately not queued.
;
;	V03-023	SRB0140		Steve Beckhardt			2-Aug-1984
;		Change SRB0136 was incomplete.  Fixed one more place
;		to bugcheck this system rather than returning an error.
;
;	V03-022	SRB0136		Steve Beckhardt			9-Jul-1984
;		Changed handling of insufficient resources during failover
;		to bugcheck the system with insufficient resources.
;
;	V03-021	SRB0134		Steve Beckhardt			26-Jun-1984
;		Simplified message build routine for rebuild lock message
;		to not handle transient SCS states (RSPxxx).  This is
;		a result of a corresponding change in the rebuild code
;		to put all those locks into RETRY state.
;
;	V03-020	SRB0132		Steve Beckhardt			25-May-1984
;		Fixed bug where cleanup path from building an LKB error
;		didn't decrement parent's sub-RSB reference count.
;
;	V03-019	SRB0120		Steve Beckhardt			20-Apr-1984
;		Fixed race conditions in LCK$RCV_RMVDIR code.
;		Fixed bug where locks in SCS states were rebuilt incorrectly.
;
;	V03-018	SRB0119		Steve Beckhardt			2-Apr-1984
;		Added support for waiting for pool.  Fixed several bugs.
;
;	V03-017	SRB0117		Steve Beckhardt			19-Mar-1984
;		Added support for distributed deadlock detection.
;
;	V03-016 SRB0115		Steve Beckhardt			23-Feb-1984
;		Added support for maintaining deadlock priority field in
;		master-copy locks.  Fixed bug in conversion code.
;
;	V03-015	SRB0110		Steve Beckhardt			27-Jan-1984
;		Added checking of MEMSEQ of incoming REBLDLOCK messages.
;		Added checking of rebuild state in message dispatching.
;
;	V03-014	SRB0108		Steve Beckhardt			11-Jan-1984
;		Added support for new failin/out design with hashed root
;		directory.  Added support for sending HASHVAL in lock 
;		messages.  Added support for maintaining EPID in locks.
;		Changed PMS counters.
;
;	V03-013	SRB0106		Steve Beckhardt			6-Dec-1983
;		Changed LKB$L_REFCNT,RSB$L_REFCNT, and RSB$L_BLKASTCNT
;		to word fields.
;
;	V03-012	SRB0104		Steve Beckhardt			17-Oct-1983
;		Fixed bug in LCK$SND_BLKING.
;
;	V03-011	SRB0100		Steve Beckhardt			18-Jul-1983
;		Fixed PMS counters.  Fixed handling of receiving a lock
;		granted message to handle canceled locks with blocking ASTs.
;
;	V03-010	SRB0097		Steve Beckhardt			23-Jun-1983
;		Added support for RECOVER bit.  Made several changes
;		to support multi-node failover.  Added support for
;		converting new locks to be system owned.
;
;	V03-009	SRB0093		Steve Beckhardt			31-May-1983
;		Simplified use of LKB state codes.
;
;	V03-008	SRB0090		Steve Beckhardt			18-May-1983
;		Added support for extending the lock id. table.  Added 
;		support for multi-node failover.  Added PMS counters.
;		Fixed bug involving system owned locks.  Added support
;		for stalling requests during failover.
;
;	V03-007	SRB0083		Steve Beckhardt			20-Apr-1983
;		Finished adding support for INVVALBLK and CANCEL flags.
;		Rewrote conversion code to send messages without RSPIDs
;		in some cases.
;
;	V03-006	SRB0077		Steve Beckhardt			14-Apr-1983
;		Removed use of LKB$M_PRCCPY bit.
;
;	V03-005	SRB0073		Steve Beckhardt			29-Mar-1983
;		Changed references to CSB to CSID in LKB and RSB.
;		Started adding support for $DEQ flags INVVALBLK and CANCEL.
;
;	V03-004	SRB0069		Steve Beckhardt			7-Mar-1983
;		Changed HALT instructions to BUG_CHECKs.  Changed handling
;		of value blocks on conversions to return value block on
;		conversions to same lock mode.
;
;	V03-003	SRB0063		Steve Beckhardt			21-Jan-1983
;		Made a number of bug fixes.
;
;	V03-002	SRB0062		Steve Beckhardt			11-Jan-1983
;		Changed BSBW to JSB.
;
;

	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;

;
; MACROS:
;

	$ACBDEF				; ACB offsets
	$CADEF				; Conditional assembly switches
	$CDRPDEF			; CDRP offsets
	$CLSMSGDEF			; Cluster message offsets
	$CLUBDEF			; CLUB offsets
	$CSBDEF				; CSB offsets
	$DYNDEF				; Data structure names
	$FKBDEF				; Fork block offsets
	$IPLDEF				; IPL definitions
	$LCKDEF				; LCK definitions
	$LKBDEF				; LKB offsets
	$PCBDEF				; PCB offsets
	$PRIDEF				; Priority definitions
	$PSLDEF				; PSL definitions
	$RSBDEF				; RSB offsets
	$RSNDEF				; Resource numbers

;
; EQUATED SYMBOLS:
;


;
; OWN STORAGE:
;

	.PSECT	$$$020

;***********************************************************************
;
; NOTE:	The following assumption is in effect for this entire module.
;
;************************************************************************

	ASSUME	IPL$_SYNCH  EQ  IPL$_SCS

;
;			CONVERSION RESPONSE TABLE
;
; This table indicates which conversions require a response message .
;
;				    TO
;
;	         |   NL  |   CR  |   CW  |   PR  |   PW  |   EX
;	         | NL/SW |  R/SW |  W/SW |  R/SR |  W/SR |  W/NL   
;	---------+-------+-------+-------+-------+-------+-------
;	NL NL/SW |  yes  |  yes  |  yes  |  yes  |  yes  |  yes
;	---------+-------+-------+-------+-------+-------+-------
;	CR  R/SW |   no  |  yes  |  yes  |  yes  |  yes  |   yes   
;	---------+-------+-------+-------+-------+-------+-------
;	CW  W/SW |   no  |   no  |   no  |  yes  |  yes  |  yes   
; FROM	---------+-------+-------+-------+-------+-------+-------
;	PR  R/SR |   no  |   no  |  yes  |   no  |  yes  |  yes   
;	---------+-------+-------+-------+-------+-------+-------
;	PW  W/SR |   no  |   no  |   no  |   no  |   no  |  yes   
;	---------+-------+-------+-------+-------+-------+-------
;	EX  W/NL |   no  |   no  |   no  |   no  |   no  |   no   


LCK$CVTRSP_TBL::

	.BYTE	^B 111111
	.BYTE	^B 111110
	.BYTE	^B 111000
	.BYTE	^B 110100
	.BYTE	^B 100000
	.BYTE	^B 000000

	.SBTTL	LCK$DISPATCH - Dispatch incoming lock message

;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine dispatches incoming lock manager messages to
;	the appropriate routine.  It also verifies that incoming messages
;	are stamped with a membership sequence number that is the same as 
;	the current one	on this system.  If not, the messages are either 
;	returned with a LKB$K_RETRY response (RSPID messages) or are ignored
;	(non-RSPID messages).
;
; CALLING SEQUENCE:
;
;	JSB	LCK$DISPATCH	(called from connection manager received
;				message routine)
;	IPL is at IPL$_SYNCH
;
; INPUT PARAMETERS:
;
;	R2	Address of message
;	R3	Address of CSB
;	R4	Address of PDT
;	R5	Address of CDRP (if this message needs a response)
;
; OUTPUT PARAMETERS:
;
;	None
;
; SIDE EFFECTS:
;
;	R0 - R5 destroyed
;--

LCK$DISPATCH::

	MOVL	CSB$L_CLUB(R3),R0	; Get address of CLUB
	SUBW3	CLUB$W_MEMSEQ(R0),-	; Compare sequence numbers
		LKMSG$W_MEMSEQ(R2),R0
	BLSS	50$			; Message is old, ignore or retry
	BGTR	20$			; MEMSEQ must be in error!
	MOVZBL	G^LCK$GB_REBLD_STATE,R0	; Are we in any phase of failover?
	BNEQ	30$			; Yes
	DISPATCH	CLSMSG$B_FUNC(R2),TYPE=B,PREFIX=LKMSG$K_,-
		<-
		<NEWLOCK,LCK$RCV_LOCKREQ>,-	; New lock request
		<GRANTED,LCK$RCV_GRANTED>,-	; Lock granted message
		<DEQ,LCK$RCV_DEQ>,-		; Dequeue request
		<RMVDIR,LCK$RCV_RMVDIR>,-	; Remove directory entry
		<BLKING,LCK$RCV_BLKING>,-	; Lock blocking message
		<CVTLCKM,LCK$RCV_CVTMSG>,-	; Convert lock message
		<CVTLCKR,LCK$RCV_CVTREQ>,-	; Convert lock req. (needs RSP)
		<TSRQST,LCK$RCV_TIMESTAMP_RQST>,- ; Time stamp request
		<SRCHDLCK,LCK$RCV_SRCHDLCK>,-	; Search for deadlock
		<DLCKFND,LCK$RCV_DLCKFND>,-	; Deadlock found
		<REDO_SRCH,LCK$RCV_REDO_SRCH>,-	; Redo deadlock search
		>

	BUG_CHECK	LOCKMGRERR,FATAL	; Illegal function code

20$:	BUG_CHECK	LOCKMGRERR,FATAL	; MEMSEQ error

30$:	; We are in the middle of a membership state change.  Dispatch
	; on phase of state change.

	DISPATCH	R0,TYPE=B,-
		<-
		<2,35$>,-
		<3,45$>,-
		>

	BUG_CHECK	LOCKMGRERR,FATAL	; Unrecognized state or
						; no messages allowed in
						; this state

35$:	DISPATCH	CLSMSG$B_FUNC(R2),TYPE=B,PREFIX=LKMSG$K_,-
		<-
		<REBLDLOCK,LCK$RCV_LOCKREQ>,-	; Rebuild lock (failover)
		>

	BUG_CHECK	LOCKMGRERR,FATAL	; Illegal function code

45$:	DISPATCH	CLSMSG$B_FUNC(R2),TYPE=B,PREFIX=LKMSG$K_,-
		<-
		<GRANTED,LCK$RCV_GRANTED>,-	; Lock granted message
		<BLKING,LCK$RCV_BLKING>,-	; Lock blocking message
		>

	BUG_CHECK	LOCKMGRERR,FATAL	; Illegal function code

50$:	; Message should either be ignored or returned with LKB$K_RETRY
	; response (the latter if a RSPID is provided).

	TSTL	CLSMSG$L_RSPID(R2)	; Is there a RSPID?
	BNEQ	70$			; Yes
	BRW	CNX$DEALL_MSG_BUF_CSB	; No, deallocate message bfr and return

70$:	; Send back LKB$K_RETRY response.

	MOVL	CSB$L_CSID(R3),R3	; Get CSID
	BSBW	CNX$INIT_CDRP		; Initialize CDRP
	MOVB	#LKB$K_RETRY,-		; Store retry response
		CDRP$L_VAL2+2(R5)
	MOVAB	W^BLD_RSPMSG,-		; Store address of message build routine
		CDRP$L_MSGBLD(R5)
	BSBW	CNX$SEND_MSG_RESP	; Send message response
	MOVL	R5,R0			; Address of CDRP
	JMP	G^EXE$DEANONPAGED	; Deallocate it and return

	.SBTTL	LCK$SND_CVTREQ - Send a conversion request to remote system

;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine handles conversion requests that must be forwarded
;	to the master system for this lock.  This system is the process 
;	system.
;
; CALLING SEQUENCE:
;
;	JMP	LCK$SND_CVTREQ (This routine does not return to its
;				caller.  Rather, it jumps to an
;				appropriate destination.)
;	IPL must be at IPL$_SYNCH
;
; INPUT PARAMETERS:
;
;	R1	Requested lock mode
;	R3	CSID of destination system
;	R6	Address of LKB
;	R7	Old status from LKB
;	R8	Address of RSB
;	R9	Flags
;	R11	Current granted mode
;
; OUTPUT PARAMETERS:
;
;	R0	Completion code (on some exit paths)
;
; SIDE EFFECTS:
;
;	The process will go into MWAIT until the response from the remote
;	system arrives.
;	R1 - R5 destroyed
;--

	.ENABL	LSB

LCK$SND_CVTREQ::

	.IF NE	CA$_MEASURE
	INCL	G^PMS$GL_ENQCVT_OUT
	.ENDC

	MOVL	G^SCH$GL_CURPCB,R4	; Get our PCB address
	MOVB	R1,LKB$B_RQMODE(R6)	; Store requested mode
	BBS	R1,LCK$CVTRSP_TBL[R11],20$ ; Branch if response needed

	; No response needed.  Allocate CDRP, store value block (if
	; specified), and send message.

	ASSUME	LCK$V_VALBLK  EQ  0

	BSBW	CNX$ALLOC_CDRP		; Alloc. a CDRP and convert CSID to CSB
	BLBC	R0,25$			; No CDRPs or CSID error
	BLBC	R9,10$			; No value block
	MOVQ	RSB$Q_VALBLK(R8),-	; Copy value block
		CDRP$L_VAL4(R5)
	MOVQ	RSB$Q_VALBLK+8(R8),-
		CDRP$L_VAL6(R5)
10$:	MOVL	PCB$L_PID(R4),-		; Store PID in CDRP
		CDRP$L_VAL8(R5)	
	MOVW	LKB$B_RQMODE(R6),-	; Store req. and granted mode in CDRP
		CDRP$L_VAL9(R5)
	CLRL	R0			; Initialize blocking AST flag
	TSTL	LKB$L_BLKASTADR(R6)	; Test for a blocking AST address
	BEQL	15$			; No blocking AST
	INCL	R0			; Set blocking AST flag
15$:	MOVB	R0,CDRP$L_VAL9+2(R5)	; Store blocking AST flag
	MOVL	R6,R0			; Move address of LKB
	BSBW	SENDCVTMSG		; Send message
	BRW	CGRNTD_PROC		; Join granted code

20$:	; Send a message and wait for response.  

	BSBW	CNX$ALLOC_WARMCDRP	; Alloc. a CDRP with RSPID and cvt CSID
25$:	BLBC	R0,60$			; No CDRPs or CSID error
	MOVL	R6,R0			; Move address of LKB
	MOVL	R4,CDRP$L_VAL8(R5)	; Store PCB address in CDRP
	BSBW	SENDCVTREQ		; Send convert request
	MOVL	CDRP$L_VAL8(R5),R4	; Restore address of PCB

CVT_SCS_WAIT:
	MOVL	#RSN$_SCS,R0		; Go into MWAIT for resource RSN$_SCS

CVT_WAIT:
	; Put the process into MWAIT until the response arrives or the
	; resource becomes available.  Resource number is in R0.  
	; PCB address is in R4.  If this is a system owned lock, 
	; then the process's PID is temporarily stored in 
	; the LKB.  This serves two purposes.  First, it allows the process 
	; to be made executable when the response arrives and secondly, it
	; prevents any other processes from manipulating this lock 
	; (VERIFYLOCKID will fail) while we wait for the response.
	; Note that the only two conversions that require a response message
	; yet will allow a system lock are a CR to CR conversion or a NL to
	; NL conversion and that these are always synchronously grantable.
	; This also occurs if we go into MWAIT for non-paged pool.

	MOVL	PCB$L_PID(R4),-		; Make sure PID is stored in case lock
		LKB$L_PID(R6)		; is system owned
	ASHL	#PSL$V_IPL,-		; Create a PSL on stack with IPL
		#IPL$_ASTDEL,-(SP)	; set to ASTDEL
	JSB	G^SCH$RWAIT		; Wait

	; Upon reawakening the LKB$B_STATE field tells us what action 
	; to perform.  But we first must determine if we are stalling requests.

	SETIPL	#IPL$_SYNCH		; Raise IPL
	TSTB	G^LCK$GB_STALLREQS	; Are we stalling?
	BNEQ	40$			; Yes
30$:	BBC	#LCK$V_CVTSYS,R9,33$	; Branch if not system owned
	CLRL	LKB$L_PID(R6)		; Clear PID of system owned lock

33$:	DISPATCH	LKB$B_STATE(R6),TYPE=B,PREFIX=LKB$K_,-
		<-
		<RSPGRANTD,CGRNTD_PROC>,-	; Granted
		<RSPQUEUED,CVTQED_PROC>,-	; Queued
		<RSPNOTQED,CNOTQD_PROC>,-	; Not queued
		<SCSWAIT,CVT_SCS_WAIT>,-	; Spurious wakeup
		<RETRY,CVTRETRY_PROC>,-		; Retry 
		>

	BUG_CHECK	LOCKMGRERR,FATAL	; Invalid lock state

40$:	; We are stalling some or all lock requests.  See which ones.

	BLSS	50$			; All requests are being stalled
	BBC	#LKB$V_PROTECT,-	; Only protected locks are being stalled
		LKB$W_STATUS(R6),30$	; Branch if this is not a protected lock
50$:	MOVL	#RSN$_CLUSTRAN,R0	; Resource to wait for
	BRB	CVT_WAIT		; Go into MWAIT for RSN$_CLUSTRAN

60$:	; Either no memory or CSID to CSB conversion failed with
	; SS$_NOSUCHNODE.  Note that if we wait, system owned locks
	; must have a non-zero PID.

	CMPW	R0,#SS$_INSFMEM		; Is it insuff. memory?
	BNEQ	70$			; No
	MOVB	#LKB$K_RETRY,-		; Store lock state
		LKB$B_STATE(R6)
	MOVL	#RSN$_NPDYNMEM,R0	; Resource to wait for
	BRB	CVT_WAIT		; Go into MWAIT for RSN$_NPDYNMEM

70$:	BUG_CHECK	LOCKMGRERR,FATAL; CSID conversion error

	.DSABL	LSB

;***************************************************************************
;
;	Process level routines for handling remote conversion requests
;
;***************************************************************************

CVTRETRY_PROC:
	; Retry this conversion due to the destination being removed
	; from the cluster or we were unable to allocate a CDRP.

	MOVZBL	LKB$B_RQMODE(R6),R1	; Get requested lock mode
	MOVL	RSB$L_CSID(R8),R3	; Get CSID of destination system
	BNEQ	10$			; Resend to destination
	MOVB	#LKB$K_GRANTED,-	; Store correct lock state
		LKB$B_STATE(R6)
	JMP	G^LCK$LOCAL_CVT		; Do it locally
10$:	BRW	LCK$SND_CVTREQ

CGRNTD_PROC:
	; Conversion request was granted

	BBC	#LKB$V_BLKASTQED,-	; Branch if a blocking AST 
		LKB$W_STATUS(R6),20$	; should not be queued
	BISW	#LKB$M_DBLKAST,-	; Set deliver blocking AST status
		LKB$W_STATUS(R6)
	BISB	#LKB$M_PKAST,-		; Set piggyback kernel AST bit
		LKB$B_RMOD(R6)
	MOVL	LKB$L_BLKASTADR(R6),-	; Store address of blocking AST routine
		LKB$L_AST(R6)
20$:	REMQUE	LKB$L_SQFL(R6),R0	; Remove lock from RSB's granted queue
	MOVB	LKB$B_RQMODE(R6),-	; Set granted mode
		LKB$B_GRMODE(R6)
	MOVL	S^#SS$_NORMAL,-		; Set status for lock status block
		LKB$L_LKST1(R6)
	TSTL	LKB$L_BLKASTADR(R6)	; Blocking AST specified?
	BEQL	40$			; No
	INCW	RSB$W_BLKASTCNT(R8)	; Yes, adjust count
40$:	JSB	G^LCK$GRANT_REM		; Finish granting the lock
	JMP	G^LCK$CVT_GRANTED	; Return value block and exit

CVTQED_PROC:
	; Conversion was queued

	REMQUE	LKB$L_SQFL(R6),R0	; Remove lock from granted queue
	JSB	G^LCK$QUEUECVT		; Queue it to conversion queue
	JMP	G^LCK$QUEUED_EXIT

CNOTQD_PROC:
	; Conversion was not queued.  However, we have to handle the case
	; where we receive a blocking AST message before we get here.

	BBC	#LKB$V_BLKASTQED,-	; Branch if we didn't get a blocking AST
		LKB$W_STATUS(R6),60$
	BISW	#LKB$M_DBLKAST,R7	; Set deliver BLKAST bit in old status
60$:	MOVB	#LKB$K_GRANTED,-	; Store correct lock state
		LKB$B_STATE(R6)
	JMP	G^LCK$CVTNOTQED

	.SBTTL	SENDCVTREQ - Send convert request to remote system

;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine takes care of building and sending the convert lock
;	request.  It also handles the fork level processing of the response.
;	We are the process system; the remote system is the master system.
;	SENDCVTREQ is called to send a convert request that requires a
;	response.  SENDCVTMSG is called to send a message that doesn't
;	require a response.
;
; CALLING SEQUENCE:
;
;	BSBW	SENDCVTREQ
;	BSBW	SENDCVTMSG
;	IPL must be at SCS fork IPL (8)
;	This routine operates as a fork process so it may return
;	to its caller before completing.
;
; INPUT PARAMETERS:
;
;	R0	LKB address
;	R3	CSB address of destination system
;	R5	CDRP address
;
; OUTPUT PARAMETERS:
;
;	NONE
;
; SIDE EFFECTS:
;
;	R0 - R4 destroyed
;
;--
	.ENABL	LSB

SENDCVTMSG:
	MOVL	LKB$L_REMLKID(R0),-	; Store master lockid in CDRP
		CDRP$L_VAL1(R5)
	MOVL	LKB$L_LKID(R0),-	; Store process lockid in CDRP
		CDRP$L_VAL2(R5)
	MOVW	LKB$W_FLAGS(R0),-	; Store flags in CDRP
		CDRP$L_VAL3+2(R5)
	MOVL	CSB$L_CLUB(R3),R1	; Get address of CLUB
	MOVW	CLUB$W_MEMSEQ(R1),-	; Store membership seq. number
		CDRP$L_VAL3(R5)
	MOVAB	W^BLD_CVTMSG,-		; Store address of message build routine
		CDRP$L_MSGBLD(R5)
	BSBW	CNX$SEND_MSG_CSB	; Send the message
	MOVL	R5,R0			; Address of CDRP
	JMP	G^EXE$DEANONPAGED	; Deallocate it

SENDCVTREQ:
	MOVL	R0,CDRP$L_VAL1(R5)	; Store LKB address
	MOVL	CSB$L_CLUB(R3),R1	; Get address of CLUB
	MOVW	CLUB$W_MEMSEQ(R1),-	; Store membership seq. number
		CDRP$L_VAL3(R5)
	MOVAB	W^BLD_CVTMSGR,-		; Store address of message build
		CDRP$L_MSGBLD(R5)	; routine
	MOVB	#LKB$K_SCSWAIT,-	; Store lock state
		LKB$B_STATE(R0)
	BSBW	CNX$SEND_MSG_CSB	; Send the message
	BLBC	R0,CVT_RETRY		; Dest. system is no longer in cluster

	; We are resumed here when the response message arrives.
	; Registers contain:
	;	R2	Address of message buffer
	;	R3	CSB address 
	;	R4	Address of PDT
	;	R5	Address of CDRP
	; First validate membership sequence number.  I.e. ignore response
	; and retry request if we did a membership state change while
	; this message was in transit.  Otherwise store response code
	; in LKB and then dispatch on it.

	MOVL	CSB$L_CLUB(R3),R0	; Get address of CLUB
	CMPW	CLUB$W_MEMSEQ(R0),-	; Compare sequence numbers
		LKMSG$W_MEMSEQ(R2)
	BEQL	20$			; They match
	MOVB	#LKB$K_RETRY,-		; No match - change state to RETRY
		LKMSG$B_STATE(R2)
20$:
	MOVL	CDRP$L_VAL1(R5),R0	; R0 = LKB address
	CMPB	LKB$B_STATE(R0),-	; Make sure LKB is in SCSWAIT state
		#LKB$K_SCSWAIT
	BNEQ	30$			; It's not
	MOVB	LKMSG$B_STATE(R2),-	; Store state
		LKB$B_STATE(R0)

	DISPATCH	LKB$B_STATE(R0),TYPE=B,PREFIX=LKB$K_,-
		<-
		<RETRY,DEALL_WARMCDRP>,-	; Retry request
		<RSPGRANTD,CGRNTD_FORK>,-	; Granted
		<RSPQUEUED,CVTQED_FORK>,-	; Queued
		<RSPNOTQED,CNOTQD_FORK>,-	; Not queued
		>

	BUG_CHECK	LOCKMGRERR,FATAL	; Invalid lock state

30$:	BUG_CHECK	LOCKMGRERR,FATAL	; LKB not in SCSWAIT state

CVT_RETRY:
	; Remote system is being removed from cluster

	MOVL	CDRP$L_VAL1(R5),R4	; Get LKB address
	MOVB	#LKB$K_RETRY,-		; Store retry state
		LKB$B_STATE(R4)
	MOVL	R5,R0			; Address of CDRP
	JSB	G^EXE$DEANONPAGED	; Deallocate CDRP
	BRW	WAKE_PROCESS		; Wake process

CNOTQD_FORK:
CGRNTD_FORK:
	; Conversion request was granted or not queued.  Store returned 
	; value block only if it's sequence number is later than the 
	; one in the RSB.  Then set BLKASTQED bit in LKB if necessary.

	MOVL	LKB$L_RSB(R0),R1	; Get RSB address
	SUBL3	RSB$L_VALSEQNUM(R1),-	; Compare sequence numbers
		LKMSG$L_VALSEQNUM(R2),R4
	BLEQ	40$			; We already have a newer one
	MOVQ	LKMSG$Q_VALBLK(R2),-	; Store value block
		RSB$Q_VALBLK(R1)
	MOVQ	LKMSG$Q_VALBLK+8(R2),-
		RSB$Q_VALBLK+8(R1)
	MOVL	LKMSG$L_VALSEQNUM(R2),-	; Store sequence number
		RSB$L_VALSEQNUM(R1)
	BICW	#RSB$M_VALINVLD,-	; Clear value block invalid flag
		RSB$W_STATUS(R1)
	BBC	#RSB$V_VALINVLD,-	; and conditionally set it
		LKMSG$W_RSBSTATUS(R2),40$
	BISW	#RSB$M_VALINVLD,-
		RSB$W_STATUS(R1)

40$:	BBC	#LKB$V_BLKASTQED,-	; Branch if a blocking AST wasn't queued
		LKMSG$W_LKBSTATUS(R2),50$
	BISW	#LKB$M_BLKASTQED,-	; Set BLKASTQED in LKB
		LKB$W_STATUS(R0)
50$:	BRW	DEALL_WARMCDRP		; Deallocate CDRP etc. and wake process

CVTQED_FORK:
	; Conversion request was queued

	MOVW	LKMSG$W_RQSEQNM(R2),-	; Store request sequence number
		LKB$W_RQSEQNM(R0)
	BRW	DEALL_WARMCDRP		; Deallocate CDRP etc. and wake process

	.DSABL	LSB

;************************************************************************
;
;		Build convert message action routines
;
;************************************************************************

	; Action routine to build the actual convert lock request message
	; Inputs are:
	;	R2	Address of message buffer
	;	R5	Address of CDRP
	; NOTE: CDRP$L_VAL contains a PID for BLD_CVTMSG and a PCB
	;	address for BLD_CVTMSGR.  This is because the PCB address
	;	must be revalidated for the former case as the process
	;	can get deleted before the message build routine is called.
	; All registers except R0 and R1 must be preserved

BLD_CVTMSG:
	; This entry point is for conversions that don't require a response

	ASSUME	CLSMSG$B_FUNC  EQ  CLSMSG$B_FACILITY+1
	ASSUME	LKMSG$L_PRCLKID  EQ  LKMSG$L_MSTLKID+4
	ASSUME	LKMSG$L_DLCKPRI_CVT  EQ  LKMSG$L_EPIDCVT+4

	MOVW	#LKMSG$K_CVTLCKM@8-	; Store function and facility codes
		!CLSMSG$K_FAC_LCK,CLSMSG$B_FACILITY(R2)
	MOVQ	CDRP$L_VAL1(R5),-	; Store master and process lockids
		LKMSG$L_MSTLKID(R2)	; in message
	MOVW	CDRP$L_VAL3(R5),-	; Store memseq in message
		LKMSG$W_MEMSEQ(R2)
	MOVW	CDRP$L_VAL3+2(R5),-	; Store flags in message
		LKMSG$W_FLAGS(R2)
	ASSUME	LCK$V_VALBLK  EQ  0
	BLBC	LKMSG$W_FLAGS(R2),10$	; Branch if no value block specified
	MOVQ	CDRP$L_VAL4(R5),-	; Store value block in message
		LKMSG$Q_VALBLK(R2)
	MOVQ	CDRP$L_VAL6(R5),-
		LKMSG$Q_VALBLK+8(R2)
10$:	MOVZBW	CDRP$L_VAL9(R5),-	; Store requested mode, and clear
		LKMSG$B_RQMODE(R2)	; granted mode
	MOVZBL	CDRP$L_VAL9+2(R5),-	; Store blocking AST flag
		LKMSG$L_BLKASTFLG(R2)
	MOVZWL	CDRP$L_VAL8(R5),R1	; Get PID index
	MOVL	G^SCH$GL_PCBVEC,R0	; Get address of PCB vector
	MOVL	(R0)[R1],R0		; Get address of PCB
	CMPL	CDRP$L_VAL8(R5),-	; Validate PCB
		PCB$L_PID(R0)
	BEQL	BLD_CVTCOM		; It's ok
	CLRQ	LKMSG$L_EPIDCVT(R2)	; Process was deleted; clear
	RSB				; EPID and deadlock priority fields

BLD_CVTMSGR:
	; This entry point is for conversions that require a response

	ASSUME	LKMSG$L_MSTLKID  EQ  LKMSG$W_MEMSEQ+4
	ASSUME	LKMSG$L_PRCLKID  EQ  LKMSG$L_MSTLKID+4
	ASSUME	LKMSG$W_FLAGS  EQ  LKMSG$L_PRCLKID+4
	ASSUME	LKMSG$B_RQMODE  EQ  LKMSG$W_FLAGS+2
	ASSUME	LKMSG$L_BLKASTFLG  EQ  LKMSG$B_RQMODE+2
	ASSUME	CLSMSG$B_FUNC  EQ  CLSMSG$B_FACILITY+1

	MOVW	#LKMSG$K_CVTLCKR@8-	; Store function and facility codes
		!CLSMSG$K_FAC_LCK,CLSMSG$B_FACILITY(R2)
	MOVL	CDRP$L_VAL1(R5),R0	; Get LKB address
	MOVAW	LKMSG$W_MEMSEQ(R2),R1	; Point into message buffer
	MOVZWL	CDRP$L_VAL3(R5),(R1)+	; Store seq. number
	MOVL	LKB$L_REMLKID(R0),(R1)+	; Store master lockid
	MOVL	LKB$L_LKID(R0),(R1)+	; Store process lockid
	MOVW	LKB$W_FLAGS(R0),(R1)+	; Store flags
	MOVZBW	LKB$B_RQMODE(R0),(R1)+	; Store req. mode and clear granted mode
	MOVL	LKB$L_BLKASTADR(R0),(R1)+ ; Store blocking AST flag
	MOVL	CDRP$L_VAL8(R5),R0	; Get PCB address

BLD_CVTCOM:
	MOVL	PCB$L_EPID(R0),-	; Store EPID
		LKMSG$L_EPIDCVT(R2)
	MOVL	PCB$L_DLCKPRI(R0),-	; Store deadlock priority
		LKMSG$L_DLCKPRI_CVT(R2)
	RSB

	.SBTTL	LKC$RCV_CVTREQ - Receive convert request

;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine receives conversion requests from the remote system.
;	The remote system is the process system and we are the master 
;	system for this lock.  The conversion request is performed and
;	a response message is returned if called at entry point
;	LCK$RCV_CVTREQ.
;
; CALLING SEQUENCE:
;
;	JSB	LCK$RCV_CVTREQ (called from SCS received message routine)
;	IPL must be at IPL$_SYNCH
;
; INPUT PARAMETERS:
;
;	R2	Address of message buffer
;	R3	Address of CSB
;	R5	Address of CDRP if a response is needed
;
; OUTPUT PARAMETERS:
;
;	None
;
; SIDE EFFECTS:
;
;	A message may be sent back as a response
;	R0 - R5 destroyed
;--

	ASSUME	LKMSG$L_PRCLKID  EQ  LKMSG$L_MSTLKID+4
	ASSUME	LKMSG$W_FLAGS  EQ  LKMSG$L_PRCLKID+4
	ASSUME	LKMSG$B_RQMODE  EQ  LKMSG$W_FLAGS+2
	ASSUME	LKMSG$L_BLKASTFLG  EQ  LKMSG$B_RQMODE+2
	ASSUME	LKMSG$Q_VALBLK  EQ  LKMSG$L_BLKASTFLG+4

CVT_INVLKID:
	BUG_CHECK	LOCKMGRERR,FATAL

LCK$RCV_CVTMSG::
	CLRL	R5			; Indicate no CDRP

LCK$RCV_CVTREQ::

	.IF NE	CA$_MEASURE
	INCL	G^PMS$GL_ENQCVT_IN
	.ENDC

	PUSHR	#^M<R2,R3,R6,R7,R8,R9,R10,R11>
	PUSHL	R5			; Save CDRP address or 0
	BEQL	5$			; No CDRP
	BSBW	CNX$INIT_CDRP		; Initialize CDRP
5$:	ADDL3	#LKMSG$L_MSTLKID,R2,R7	; Point R7 into message buffer
	MOVL	(R7)+,R1		; Get master lockid (id on this system)
	MOVL	(R7)+,R0		; Get process lockid (for verify)
	BSBW	VERIFYREMLKID		; Convert to LKB address
	BLBC	R0,CVT_INVLKID		; Invalid id

	; Have LKB address in R6, pointer into message in R7.  Set
	; up other registers as needed.

	MOVL	LKB$L_RSB(R6),R8	; Get RSB address
	MOVZWL	(R7)+,R9		; Get flags
	MOVW	R9,LKB$W_FLAGS(R6)	; Store them
	PUSHL	LKB$W_STATUS(R6)	; Save old status bits
	BICW	#LKB$M_DCPLAST-		; Clear relevant status bits
		!LKB$M_DBLKAST-		; The following bits retain their 
		!LKB$M_ASYNC-		; old state:
		!LKB$M_BLKASTQED-	;	MSTCPY
		!LKB$M_TIMOUTQ-		;	NOQUOTA (should not be set)
		!LKB$M_WASSYSOWN-	;	PROTECT
		!LKB$M_CVTTOSYS,-
		LKB$W_STATUS(R6)
	MOVZBL	(R7)+,R1		; Get requested mode, skip granted
	INCL	R7			; mode field 
	MOVZBL	LKB$B_GRMODE(R6),R11	; Get granted mode

	; Store EPID of owner of lock unless LCK$M_CVTSYS is set in
	; which case, store 0.  R7 points to BLKASTFLG field of message.
	; Also store deadlock priority in LKB if not system owned.

	CLRL	R0			; Assume system owned
	BBS	#LCK$V_CVTSYS,R9,8$	; Branch if it is system owned
	MOVL	LKMSG$L_EPIDCVT-LKMSG$L_BLKASTFLG(R7),R0  ; Get EPID
	MOVL	LKMSG$L_DLCKPRI_CVT-LKMSG$L_BLKASTFLG(R7),-
		LKB$L_DLCKPRI(R6)	; Store deadlock priority
8$:	MOVL	R0,LKB$L_EPID(R6)	; Store EPID or 0

	; Decrement blocking AST count if a blocking AST was specified
	; and then store new blocking AST flag.
	; NOTE: the store of the new flag MUST be done after the test
	; of the old flag and decrement of the count.

	MOVL	LKB$L_BLKASTADR(R6),-	; Save old blocking AST flag
		LKB$L_OLDBLKAST(R6)
	BEQL	10$			; No
	DECW	RSB$W_BLKASTCNT(R8)	; Yes, adjust count
10$:	MOVL	(R7)+,LKB$L_BLKASTADR(R6) ; Store new flag

	; If we are converting down (or same) from PW or EX then copy 
	; the caller's value block (if specified) into the RSB.
	; R7 points to value block in message.

	ASSUME	LCK$V_VALBLK  EQ  0

	BLBC	R9,20$			; Branch if no value block specified
	CMPB	R11,#LCK$K_PWMODE	; Is grmode mode PW or EX?
	BLSSU	20$			; No
	CMPB	R1,R11			; Is rqmode greater than grmode?
	BGTRU	20$			; Yes
	MOVQ	(R7)+,RSB$Q_VALBLK(R8)	; Copy caller's value block to RSB
	MOVQ	(R7),RSB$Q_VALBLK+8(R8)
	INCL	RSB$L_VALSEQNUM(R8)	; Increment value block seq. number
	BICW	#RSB$M_VALINVLD,-	; Clear invalid bit
		RSB$W_STATUS(R8)

20$:	; Remove this lock from the granted queue.  If it was the only one and
	; if the conversion queue is also empty, then the conversion request 
	; can be granted immediately.  This path is special cased because it
	; is the normal case.

	REMQUE	LKB$L_SQFL(R6),R0	; Remove lock from granted queue
	BNEQ	40$			; Not the only one
	MOVAL	RSB$L_CVTQFL(R8),R10	; It's the only granted lock
	CMPL	(R10),R10		; Is conversion queue empty?
	BNEQ	40$			; It's not - must check the longer way
	JSB	G^LCK$GRANT_LOCK_ALT	; It is - grant lock
	ADDL	#8,R10			; Point to wait queue
	CMPL	(R10),R10		; Is wait queue empty?
	BEQL	60$			; Yes, exit 
	JSB	G^LCK$GRANTWTRS		; Try granting waiting locks
	BRB	60$

40$:	; There was at least one other holder of the resource so we have
	; to check for compatibility the longer way.  The granted mode
	; of this lock is compared with the conversion grant mode.  If,
	; other than the head of the conversion queue, there are granted
	; locks with higher lock modes than this lock, then there
	; is no need to recompute the group grant mode or attempt to
	; grant waiting conversions.

	CMPB	R11,RSB$B_CGMODE(R8)	; Is granted mode = conv. grant mode?
	BEQL	45$			; Yes
	MOVZBL	RSB$B_GGMODE(R8),R5	; No, get group grant mode
	BBC	R1,G^LCK$COMPAT_TBL[R5],80$ ; Branch if not compatible
	JSB	G^LCK$GRANT_LOCK	; Grant the lock
	BRB	60$			; Exit with completion status in R0

45$:	JSB	G^LCK$COMP_GGMODE	; Compute new group grant mode in R5
	BBC	R1,G^LCK$COMPAT_TBL[R5],80$ ; Branch if not compatible 
	MOVB	R5,RSB$B_GGMODE(R8)	; Store group grant mode in RSB
	MOVB	R5,RSB$B_CGMODE(R8)	; Also store conversion grant mode
	JSB	G^LCK$GRANT_LOCK	; Grant lock
	JSB	G^LCK$GRANTCVTS		; Try granting conversions and waiters

60$:	; Set response state to be granted 

	ADDL	#4,SP			; Remove old status from stack
	BICW	#LKB$M_DBLKAST,-	; Got set spuriously by common code
		LKB$W_STATUS(R6)
	MOVB	#LKB$K_RSPGRANTD,R0	; Set state
	POPL	R5			; Get response CDRP or 0
	BNEQ	SEND_CVTRSP		; Have a CDRP - send response

70$:	; Since a response is not required, we have to deallocate the
	; message buffer.  However, it may be necessary to send a blocking
	; message.

	POPR	#^M<R2,R3>		; Get buffer and CSB addresses
	BSBW	CNX$DEALL_MSG_BUF_CSB	; Deallocate message buffer
	BBC	#LKB$V_BLKASTQED,-	; Branch if no blocking AST queued
		LKB$W_STATUS(R6),75$
	MOVL	LKB$L_CSID(R6),R3	; Get CSID of other system
	MOVL	R6,R4			; Move LKB address
	BSBW	SEND_BLOCKING		; Send blocking message
75$:	POPR	#^M<R6,R7,R8,R9,R10,R11>
	RSB

80$:	; The conversion cannot be granted.  Queue the request
	; unless the noqueue bit is set.  If the conversion queue is empty 
	; then R5 contains the new conversion grant mode.

	POPL	R7			; Restore old LKB status bits
	BBS	#LCK$V_NOQUEUE,R9,85$	; Branch if noqueue is set

	; Queue the conversion

	MOVB	R1,LKB$B_RQMODE(R6)	; Store requested mode
	MOVW	RSB$W_RQSEQNM(R8),-	; Store request sequence number
		LKB$W_RQSEQNM(R6)
	INCW	RSB$W_RQSEQNM(R8)	; Increment sequence number
	JSB	G^LCK$QUEUECVT		; Insert onto conversion queue, etc.
	MOVB	#LKB$K_RSPQUEUED,R0	; Set response state
	BRB	98$			; Send response

85$:	; The request is not to be queued.  Insert back onto the
	; granted queue.  

	.IF NE	CA$_MEASURE
	INCL	G^PMS$GL_ENQNOTQD
	.ENDC

	MOVW	R7,LKB$W_STATUS(R6)	; Put back old status bits
	INSQUE	LKB$L_SQFL(R6),-	; Put lock back on granted queue
		RSB$L_GRQFL(R8)
	MOVL	LKB$L_OLDBLKAST(R6),-	; Restore old blocking AST flag
		LKB$L_BLKASTADR(R6)
	BEQL	95$			; No
	INCW	RSB$W_BLKASTCNT(R8)	; Incr. blocking AST count
95$:	MOVB	#LKB$K_RSPNOTQED,R0	; Set response state
98$:	POPL	R5			; Restore CDRP address

SEND_CVTRSP:
	; Send response message.  CDRP address is in R5.

	MOVL	R6,CDRP$L_VAL1(R5)	; Store LKB address
	MOVB	R0,CDRP$L_VAL2+2(R5)	; Store response state
	MOVAB	B^BLD_CVTRSP,-		; Store address of message build
		CDRP$L_MSGBLD(R5)	; routine
	POPR	#^M<R2,R3,R6,R7,R8,R9,R10,R11>
	MOVL	CSB$L_CLUB(R3),R1	; Get address of CLUB
	MOVW	CLUB$W_MEMSEQ(R1),-	; Store membership seq. number
		CDRP$L_VAL3(R5)
	MOVL	CSB$L_CSID(R3),R3	; Get CSID out of CSB
	BSBW	CNX$SEND_MSG_RESP	; Send message response
	CMPW	R0,#SS$_NOSUCHNODE	; Is status SS$_NOSUCHNODE?
	BEQL	10$			; Yes, error
	MOVL	R5,R0			; No, SS$_NODELEAVE is okay
	JMP	G^EXE$DEANONPAGED	; Deallocate CDRP

10$:	BUG_CHECK	LOCKMGRERR,FATAL; CSID invalid

BLD_CVTRSP:
	; This routine builds a response message for conversion requests
	; Inputs:
	;	R2	Address of message buffer
	;	R3	Address of CSB
	;	R5	Address of CDRP
	; All registers except R0 and R1 must be preserved
	;
	; Note:  This message build routine uses pointers (to LKB and RSB)
	; that will not be valid if we started a state change.  Therefore,
	; it is necessary to validiate the membership sequence number
	; before using any pointers stored in the CDRP.

	ASSUME	CLSMSG$B_FUNC  EQ  CLSMSG$B_FACILITY+1

	MOVW	#LKMSG$K_CVTLCKR@8-	; Store function and facility codes
		!CLSMSG$M_RESPMSG-
		!CLSMSG$K_FAC_LCK,CLSMSG$B_FACILITY(R2)
	MOVW	CDRP$L_VAL3(R5),-	; Store membership seq. num.
		LKMSG$W_MEMSEQ(R2)
	MOVL	CSB$L_CLUB(R3),R1	; Get address of CLUB
	CMPW	CLUB$W_MEMSEQ(R1),-	; Have we done a state change?
		CDRP$L_VAL3(R5)
	BNEQ	20$			; Yes
	MOVL	CDRP$L_VAL1(R5),R0	; Get address of LKB
	MOVL	LKB$L_LKID(R0),-	; Store master lockid
		LKMSG$L_MSTLKID(R2)
	MOVL	LKB$L_REMLKID(R0),-	; Store process lockid
		LKMSG$L_PRCLKID(R2)
	MOVB	CDRP$L_VAL2+2(R5),-	; Store response state
		LKMSG$B_STATE(R2)
	CMPB	LKB$B_STATE(R0),-	; Is lock state = GRANTED
		#LKB$K_GRANTED
	BNEQ	10$			; No
	MOVW	LKB$W_STATUS(R0),-	; Yes, store LKB status
		LKMSG$W_LKBSTATUS(R2)
	MOVL	LKB$L_RSB(R0),R0	; Get RSB address
	MOVQ	RSB$Q_VALBLK(R0),-	; Store value block
		LKMSG$Q_VALBLK(R2)
	MOVQ	RSB$Q_VALBLK+8(R0),-
		LKMSG$Q_VALBLK+8(R2)
	MOVL	RSB$L_VALSEQNUM(R0),-	; Store value block seq. number
		LKMSG$L_VALSEQNUM(R2)
	MOVW	RSB$W_STATUS(R0),-	; Store RSB status
		LKMSG$W_RSBSTATUS(R2)
	RSB

10$:	MOVW	LKB$W_RQSEQNM(R0),-	; Store request sequence number
		LKMSG$W_RQSEQNM(R2)	; (not used if state = RSPCNOTQD)
	RSB

20$:	; We've done a membership state change between our SEND_MSG
	; and calling the message build routine.  Just send back a RETRY
	; status.

	MOVB	#LKB$K_RETRY,-		; Store RETRY status
		LKMSG$B_STATE(R2)
	RSB

	.SBTTL	LCK$SND_LOCKREQ - Send lock request to remote system

;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine handles lock requests that must be forwarded
;	to the master system for this lock.  This system is the process
;	system.  In the case of root locks, the master system has not
;	been determined yet so this request effectively functions as
;	a directory lookup.
;
; CALLING SEQUENCE:
;
;	JMP	LCK$SND_LOCKREQ	(This routine does not return to its
;				caller.  Instead it jumps to an
;				appropriate destination.)
;	IPL must be at IPL$_SYNCH
;
; INPUT PARAMETERS:
;
;	R3	CSID of destination system
;	R6	Address of LKB
;	R8	Address of RSB
;	R9	Flags
;
; OUTPUT PARAMETERS:
;
;	R0	Completion code (on some exit paths)
;
; SIDE EFFECTS:
;
;	The process will go into MWAIT state until the response from the
;	remote system arrives.
;
;	R0 - R5 destroyed
;--

	.ENABL	LSB

LCK$SND_LOCKREQ::

	; The LKB is inserted on the RSB's wait queue until the response
	; arrives.  Note:  Normally, the LKB state field should get stored
	; adjacent to the INSQUE.  Here, it gets stored shortly; either
	; in SENDLOCKREQ or in the code that waits for pool.

	INSQUE	LKB$L_SQFL(R6),-	; Insert LKB onto tail of RSB's 
		@RSB$L_WTQBL(R8)	; wait queue.  

RESEND:	; Allocate a CDRP and send the message

	MOVL	G^SCH$GL_CURPCB,R4	; Get our PCB address
	BSBW	CNX$ALLOC_WARMCDRP	; Alloc. a CDRP with RSPID and CVT CSID
	BLBC	R0,WAITFORMEM		; No CDRP or CSID error
	MOVL	R6,R0			; Move LKB address
	MOVL	R8,R1			; Move RSB address
	MOVL	R4,CDRP$L_VAL8(R5)	; Store PCB address in CDRP
	BSBW	SENDLOCKREQ		; Send the lock request
	MOVL	CDRP$L_VAL8(R5),R4	; Restore PCB address

LCK_SCS_WAIT:
	MOVL	#RSN$_SCS,R0		; Go into MWAIT for resource RSN$_SCS

LCK_WAIT:
	; Put the process into MWAIT until the response arrives or
	; the resource becomes available.  Resource number is in R0.
	; PCB address is in R4.

	MOVL	PCB$L_PID(R4),-		; Make sure PID is stored in case lock
		LKB$L_PID(R6)		; is system owned
	ASHL	#PSL$V_IPL,-		; Create a PSL on stack with IPL
		#IPL$_ASTDEL,-(SP)	; set to IPL$_ASTDEL
	JSB	G^SCH$RWAIT		; Wait

	; Upon reawakening the LKB$B_STATE field tells us what action 
	; to perform.  But first, we have to make sure that we're not
	; stalling lock requests.

	SETIPL	#IPL$_SYNCH		; Raise IPL
	TSTB	G^LCK$GB_STALLREQS	; Are we stalling?
	BNEQ	30$			; Yes
15$:	BBC	#LCK$V_CVTSYS,R9,20$	; Branch if not system owned
	CLRL	LKB$L_PID(R6)		; Clear PID of system owned lock

20$:	DISPATCH	LKB$B_STATE(R6),TYPE=B,PREFIX=LKB$K_,-
		<-
		<RSPDOLOCL,DOLOCL_PROC>,-	; Do locally	
		<RSPGRANTD,GRANTD_PROC>,-	; Granted
		<RSPQUEUED,WAITNG_PROC>,-	; Waiting
		<RSPNOTQED,NOTQED_PROC>,-	; Queued
		<SCSWAIT,LCK_SCS_WAIT>,-	; Spurious wakeup
		<RETRY,LCKRETRY_PROC>,-		; Retry lock 
		>

	BUG_CHECK	LOCKMGRERR,FATAL	; Invalid lock state

30$:	; We are stalling some or all lock requests.  See which ones.

	BLSS	40$			; All requests are being stalled
	BBC	#LKB$V_PROTECT,-	; Only protected locks are being stalled
		LKB$W_STATUS(R6),15$	; Branch if this is not a protected lock
40$:	MOVL	#RSN$_CLUSTRAN,R0	; Resource to wait for
	BRB	LCK_WAIT		; Go into MWAIT for RSN$_CLUSTRAN

RESEND_BRANCH:
	BRB	RESEND			; *** TEMPORARY ***

CSID_ERROR:				; CSID to CSB conversion error
	BUG_CHECK	LOCKMGRERR,FATAL

WAITFORMEM:
	; CSID conversion error or insufficient pool to allocate 
	; CDRP.  If not CSID error then wait for pool and try again.

	CMPW	R0,#SS$_INSFMEM		; Is it insuff. memory?
	BNEQ	CSID_ERROR		; No
	MOVB	#LKB$K_RETRY,-		; Store lock state
		LKB$B_STATE(R6)
	MOVL	#RSN$_NPDYNMEM,R0	; Resource to wait for
	BRB	LCK_WAIT		; Go into MWAIT for RSN$_NPDYNMEM

	.DSABL	LSB

;***************************************************************************
;
;	Process level routines for handling remote lock requests
;
;***************************************************************************

LCKRETRY_PROC:
	MOVL	RSB$L_CSID(R8),R3	; Get CSID of destination system
	BNEQ	RESEND_BRANCH		; Try again

	; This system became the manager of the resource while we 
	; were waiting.  Fall through to ...

DOLOCL_PROC:
	; Handle the request locally.

	REMQUE	LKB$L_SQFL(R6),R0	; Remove from wait queue
	JMP	G^LCK$LOCAL_LOCK

GRANTD_PROC:
	; Lock request was granted 

	BBC	#LKB$V_BLKASTQED,-	; Branch if blocking AST should
		LKB$W_STATUS(R6),10$	; not be queued
	BISW	#LKB$M_DBLKAST,-	; Set deliver blocking AST status
		LKB$W_STATUS(R6)
	BISB	#LKB$M_PKAST,-		; Set piggyback kernel AST bit
		LKB$B_RMOD(R6)
	MOVL	LKB$L_BLKASTADR(R6),-	; Store address of blocking AST routine
		LKB$L_AST(R6)	
10$:	REMQUE	LKB$L_SQFL(R6),R0	; Remove lock from RSB's wait queue
	MOVB	LKB$B_RQMODE(R6),-	; Set granted mode
		LKB$B_GRMODE(R6)
	MOVL	S^#SS$_NORMAL,-		; Set status for lock status block
		LKB$L_LKST1(R6)
	TSTL	LKB$L_BLKASTADR(R6)	; Blocking AST specified?
	BEQL	15$			; No
	INCW	RSB$W_BLKASTCNT(R8)	; Yes, adjust count
15$:	JSB	G^LCK$GRANT_REM		; Finish granting the lock
	JMP	G^LCK$SYNC_EXIT		; Exit the service

WAITNG_PROC:
	; Lock request had to wait.  PCB address is still in R4.

	JSB	G^LCK$QUEUE_REM		; Queue the lock request
	JMP	G^LCK$QUEUED_EXIT	; Exit the service

NOTQED_PROC:
	; Lock request was not queued due to an error.  Status code
	; returned by remote system is in LKB.  Typical values are
	;  SS$_NOTQUEUED or SS$_NOLOCKIDS.

	MOVZWL	LKB$L_LKST1(R6),R11	; Get status

CHECK_RSB:
	; LKB is to be deallocated.  Check if RSB should be deallocated too.
	; Status is in R11.

	REMQUE	LKB$L_SQFL(R6),R0	; Remove lock from RSB's wait queue
	JSB	G^LCK$CHECK_RSB		; Deallocate RSB if necessary
	JMP	G^LCK$NOT_QUEUED	; Cleanup and exit service


	.SBTTL	SENDLOCKREQ - Send a (new) lock request

;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine takes care of building and sending the new lock
;	request message to the remote system.  It also handles
;	fork level processing of the response.	We are the process system;
;	the remote system is the master system.
;
; CALLING SEQUENCE:
;
;	BSBW	SENDLOCKREQ
;	IPL must be at SCS fork IPL (8)
;	This routine operates as a fork process so it may return
;	to its caller before completing.
;
; INPUT PARAMETERS:
;
;	R0	LKB address
;	R1	RSB Address
;	R3	CSB address
;	R5	CDRP address
;
; IMPLICIT INPUTS:
;
;	CDRP$L_VAL8	Contains PCB address of process requesting lock
;
; OUTPUT PARAMETERS:
;
;	R0 - R4 destroyed
;
; SIDE EFFECTS:
;
;	NONE
;
;--
	.ENABL	LSB

SENDLOCKREQ:
	; Put everything we need to build the message into the CDRP.

	MOVQ	R0,CDRP$L_VAL1(R5)	; Store LKB and RSB addresses
	MOVL	CSB$L_CLUB(R3),R1	; Get address of CLUB
	MOVW	CLUB$W_MEMSEQ(R1),-	; Store membership seq. number
		CDRP$L_VAL3(R5)
	MOVAB	W^BLD_LOCKMSG,-		; Store address of routine that will
		CDRP$L_MSGBLD(R5)	; actually build message
	MOVB	#LKB$K_SCSWAIT,-	; Set LKB state to SCSWAIT
		LKB$B_STATE(R0)

	; Send the message

	BSBW	CNX$SEND_MSG_CSB
	BLBC	R0,LCK_SENDERR		; Destination system is being 
					; removed from cluster

	; We are resumed here when the response message arrives.
	; Registers contain:
	;	R2	Address of message buffer
	;	R3	Address of CSB
	;	R4	Address of PDT
	;	R5	Address of CDRP
	; First validate membership sequence number.  I.e. ignore response
	; and retry request if we did a membership state change while
	; this message was in transit.  Otherwise store response code
	; in LKB and then dispatch on it.

	MOVL	CSB$L_CLUB(R3),R0	; Get address of CLUB
	CMPW	CLUB$W_MEMSEQ(R0),-	; Compare sequence numbers
		LKMSG$W_MEMSEQ(R2)
	BEQL	20$			; They match
	MOVB	#LKB$K_RETRY,-		; No match - change state to RETRY
		LKMSG$B_STATE(R2)
20$:	MOVQ	CDRP$L_VAL1(R5),R0	; R0 = LKB address;  R1 = RSB address
	CMPB	LKB$B_STATE(R0),-	; Make sure LKB is in SCSWAIT state
		#LKB$K_SCSWAIT
	BNEQ	30$			; It's not
	MOVB	LKMSG$B_STATE(R2),-	; Store state
		LKB$B_STATE(R0)

	DISPATCH	LKB$B_STATE(R0),TYPE=B,PREFIX=LKB$K_,-
		<-
		<RETRY,DEALL_WARMCDRP>,-	; Retry this request
		<RSPRESEND,RESEND_FORK>,-	; Resend to specified node
		<RSPDOLOCL,DOLOCL_FORK>,-	; Do locally
		<RSPGRANTD,GRANTD_FORK>,-	; Granted
		<RSPQUEUED,WAITNG_FORK>,-	; Waiting
		<RSPNOTQED,NOTQED_FORK>,-	; Not queued
		>

	BUG_CHECK	LOCKMGRERR,FATAL	; Invalid lock state

30$:	BUG_CHECK	LOCKMGRERR,FATAL	; LKB not in SCSWAIT state
35$:	BUG_CHECK	LOCKMGRERR,FATAL	; Other system returned
						; invalid CSID
LCK_SENDERR:
	; Remote system is being removed from cluster

	MOVL	CDRP$L_VAL1(R5),R4	; Get LKB address
	MOVL	R5,R0			; Address of CDRP
	JSB	G^EXE$DEANONPAGED	; Deallocate CDRP
	BRB	LCK_RETRY		; Wake process and retry request

;***************************************************************************
;
;	Fork level routines for handling remote lock request responses
;
;***************************************************************************

RESEND_FORK:
	; Resend request to another system (specified by CSID).
	; New destination CSID is in message.  But before we use it we
	; have to make sure the CSID address in the RSB didn't change out from
	; underneath us by a different thread.  If it did, we have to use the
	; stored CSID address because if we were to change the stored one,
	; we could confuse the other thread.   Once we determine
	; the correct CSID we deallocate the old 
	; CDRP and message buffer and allocate a new ones.  The deallocate
	; and allocate are necessary since CRDPs and message buffers are
	; maintained on a per CSB basis.  Also, the CDRP will get
	; initialized when it's reallocated.  R3 still contains old
	; CSB address

	.IF NE	CA$_MEASURE
	INCL	G^PMS$GL_DIR_OUT
	.ENDC

	MOVL	LKMSG$L_CSID(R2),R4	; Get specified CSID
	CMPL	RSB$L_CSID(R1),-	; Has the CSID in the RSB changed?
		CSB$L_CSID(R3)
	BEQL	40$			; No
	MOVL	RSB$L_CSID(R1),R4	; Yes, get new CSID
	BEQL	50$			; It's now being done locally
40$:	MOVL	R4,RSB$L_CSID(R1)	; Store new CSID
	PUSHL	CDRP$L_VAL8(R5)		; Save PCB address
	MOVQ	R0,-(SP)		; Save LKB and RSB addresses
	BSBW	CNX$DEALL_WARMCDRP_CSB	; Deallocate old CDRP and message buffer
	MOVL	R4,R3			; Move new CSID 
	TSTB	G^LCK$GB_STALLREQS	; Are we stalling lock requests?
	BNEQ	47$			; Yes, wake process
	BSBW	CNX$ALLOC_WARMCDRP	; Alloc. a CDRP with RSPID and cvt CSID
	BLBC	R0,45$			; Allocation or CSID convert failure
	MOVQ	(SP)+,R0		; Restore LKB and RSB addresses
	POPL	CDRP$L_VAL8(R5)		; Restore PCB address into new CDRP
	BRW	SENDLOCKREQ		; Resend it

45$:	; Unable to allocate a CDRP or CSID returned by other system
	; was invalid.  If it's insufficient memory then let process 
	; do the allocate so that it can wait, if necessary.  If CSID 
	; returned by the other system is invalid, then bugcheck.

	CMPW	R0,#SS$_INSFMEM		; Is it insuff. memory?
	BNEQ	35$			; No, error
47$:	MOVQ	(SP)+,R4		; Restore LKB and RSB addresses
	ADDL	#4,SP			; Throw away PCB address

LCK_RETRY:
	; Set lock state to RETRY and wake process.  LKB address is in R4.

	MOVB	#LKB$K_RETRY,-		; Set RETRY state
		LKB$B_STATE(R4)
	BRB	WAKE_PROCESS	
	
50$:	MOVB	#LKB$K_RSPDOLOCL,-	; Change state to handle request
		LKB$B_STATE(R0)		; locally and fall through to ...

DOLOCL_FORK:
	; Handle request locally

	.IF NE	CA$_MEASURE
	INCL	G^PMS$GL_DIR_OUT
	.ENDC

	CLRL	RSB$L_CSID(R1)		; Indicate we will handle this resource
	BRB	DEALL_WARMCDRP		; Deallocate CDRP etc. and wake process

NOTQED_FORK:
	; Lock request was not queued due to error or incompatibility

	MOVW	LKMSG$W_STATUS(R2),-	; Move completion status to LKB
		LKB$L_LKST1(R0)
	BRB	70$			; Deallocate CDRP etc. and wake process

WAITNG_FORK:
	; Lock request has to wait

	MOVW	LKMSG$W_RQSEQNM(R2),-	; Store request sequence number
		LKB$W_RQSEQNM(R0)
	BRB	60$

GRANTD_FORK:
	; Set BLKASTQED bit in LKB if appropriate.  Then store value 
	; block from message unless one in RSB is newer.

	BBC	#LKB$V_DBLKAST,-	; Branch if blocking AST shouldn't
		LKMSG$W_LKBSTATUS(R2),55$ ; be queued
	BISW	#LKB$M_DBLKAST,-	; Set deliver blocking AST bit
		LKB$W_STATUS(R0)
55$:	SUBL3	RSB$L_VALSEQNUM(R1),-	; Compare sequence numbers
		LKMSG$L_VALSEQNUM(R2),R4
	BLEQ	60$			; We already have a newer one
	MOVQ	LKMSG$Q_VALBLK(R2),-	; Store value block
		RSB$Q_VALBLK(R1)
	MOVQ	LKMSG$Q_VALBLK+8(R2),-
		RSB$Q_VALBLK+8(R1)
	MOVL	LKMSG$L_VALSEQNUM(R2),-	; Store sequence number
		RSB$L_VALSEQNUM(R1)
	BICW	#RSB$M_VALINVLD,-	; Clear value block invalid flag
		RSB$W_STATUS(R1)
	BBC	#RSB$V_VALINVLD,-	; and conditionally set it
		LKMSG$W_RSBSTATUS(R2),60$
	BISW	#RSB$M_VALINVLD,-
		RSB$W_STATUS(R1)

60$:	MOVL	LKMSG$L_MSTLKID(R2),-	; Store remote lock id
		LKB$L_REMLKID(R0)

70$:	.IF NE	CA$_MEASURE
	INCL	G^PMS$GL_ENQNEW_OUT
	.ENDC

DEALL_WARMCDRP:
	; Deallocate CDRP (R5), message buffer (R2), and RSPID (in CDRP).
	; LKB address is in R0.  CSB address is in R3.

	MOVL	R0,R4			; Move LKB address
	BSBW	CNX$DEALL_WARMCDRP_CSB	; Deallocate the package

WAKE_PROCESS:
	; LKB address is in R4.

	MOVZWL	LKB$L_PID(R4),R1	; Get process index
	MOVL	G^SCH$GL_PCBVEC,R0	; Get address of PCB vector
	MOVL	(R0)[R1],R4		; Get address of PCB

	; Change process state to executable

	CLRL	R2			; No priority increment
	JSB	G^SCH$RSE		; Report event (RPTEVT not used
	.BYTE	EVT$_AST		; because we need to JSB G^)
	RSB

	.DSABL	LSB

;************************************************************************
;
;		Build message action routines for new lock requests
;		and rebuild lock during failin/out
;
;************************************************************************

BLD_LOCKMSG:
	; Action routine to build the actual lock request message
	; Inputs are:
	;	R2	Address of message buffer
	;	R5	Address of CDRP
	; All registers except R0 and R1 must be preserved

	ASSUME	LKMSG$W_HASHVAL  EQ  LKMSG$W_MEMSEQ+2
	ASSUME	LKMSG$L_EPIDNEW  EQ  LKMSG$W_HASHVAL+2
	ASSUME	LKMSG$L_PRCLKID  EQ  LKMSG$L_EPIDNEW+4
	ASSUME	LKMSG$W_FLAGS  EQ  LKMSG$L_PRCLKID+4
	ASSUME	LKMSG$B_RQMODE  EQ  LKMSG$W_FLAGS+2
	ASSUME	LKMSG$B_GRMODE  EQ  LKMSG$B_RQMODE+1
	ASSUME	LKMSG$L_BLKASTFLG  EQ  LKMSG$B_GRMODE+1
	ASSUME	LKMSG$L_PARPRCLKID  EQ  LKMSG$L_BLKASTFLG+4
	ASSUME	LKMSG$L_PARMSTLKID  EQ  LKMSG$L_PARPRCLKID+4
	ASSUME	LKMSG$W_GROUP  EQ  LKMSG$L_PARMSTLKID+4
	ASSUME  LKMSG$B_RMOD  EQ  LKMSG$W_GROUP+2
	ASSUME	LKMSG$B_RSNLEN  EQ  LKMSG$B_RMOD+1
	ASSUME	LKMSG$T_RESNAM  EQ  LKMSG$B_RSNLEN+1

	ASSUME	CLSMSG$B_FUNC  EQ  CLSMSG$B_FACILITY+1
	MOVW	#LKMSG$K_NEWLOCK@8-	; Store function and facility codes
		!CLSMSG$K_FAC_LCK,CLSMSG$B_FACILITY(R2)
BLD_LOCKCOM:
	PUSHR	#^M<R2,R3,R4,R5>	; Save registers
	MOVQ	CDRP$L_VAL1(R5),R0	; R0 = LKB address;  R1 = RSB address
	ADDL	#LKMSG$W_MEMSEQ,R2	; Point inside message
	MOVW	CDRP$L_VAL3(R5),(R2)+	; Store rebuild seq. number
	MOVW	RSB$W_HASHVAL(R1),(R2)+	; Store resource hash value
	MOVL	CDRP$L_VAL8(R5),R4	; Get PCB address
	BEQL	20$			; Branch if system owned (rebuild only)
	MOVL	PCB$L_EPID(R4),(R2)+	; Store EPID
	MOVL	PCB$L_DLCKPRI(R4),-	; Store deadlock priority
		LKMSG$L_DLCKPRI_NEW-LKMSG$L_PRCLKID(R2)
5$: 	MOVL	LKB$L_LKID(R0),(R2)+	; Store process lock id
	MOVW	LKB$W_FLAGS(R0),(R2)+	; Store input flags 
	MOVW	LKB$B_RQMODE(R0),(R2)+	; Store lock modes
	MOVL	LKB$L_BLKASTADR(R0),-	; Set blocking AST indicator.  Note:
		(R2)+			; address is not used - just zero or not
	CLRL	R3			; Assume no parent lock id
	MOVL	LKB$L_PARENT(R0),R4	; Get address of parent LKB
	BEQL	10$			; No parent
	MOVL	LKB$L_LKID(R4),R3	; Get parent's process lock id
	MOVL	LKB$L_REMLKID(R4),R4	; and master lock id
10$:	MOVQ	R3,(R2)+		; Store both parent lock ids
	MOVZBL	RSB$B_RSNLEN(R1),R0	; Get resource name length
	ADDL	#4,R0			; Account for adjacent fields
	MOVC3	R0,RSB$W_GROUP(R1),(R2)	; Move group number, access mode,
					; res. name length and resource name
	POPR	#^M<R2,R3,R4,R5>	; Restore registers 
	RSB

20$:	; Have a zero for PCB address.  This should only occur doing rebuild
	; for system owned locks.  Verify CVTSYS bit is set.

	ADDL	#4,R2			; Move past EPID field
	BBS	#LCK$V_CVTSYS,-		; Continue if CVTSYS is set
		LKB$W_FLAGS(R0),5$
	BUG_CHECK	LOCKMGRERR,FATAL; CVTSYS not set and PCB address = 0

LCK$BLD_REBLDLOCK::
	MOVW	#LKMSG$K_REBLDLOCK@8-	; Store function and facility codes
		!CLSMSG$K_FAC_LCK,CLSMSG$B_FACILITY(R2)
	BSBB	BLD_LOCKCOM		; Build normal portion of message
	MOVQ	CDRP$L_VAL1(R5),R0	; R0 = LKB address;  R1 = RSB address
	MOVW	LKB$W_RQSEQNM(R0),-	; Store request sequence number
		LKMSG$W_RQSEQALT(R2)
	MOVQ	RSB$Q_VALBLK(R1),-	; Store value block
		LKMSG$Q_VALBLKALT(R2)
	MOVQ	RSB$Q_VALBLK+8(R1),-
		LKMSG$Q_VALBLKALT+8(R2)
	MOVL	RSB$L_VALSEQNUM(R1),-	; Store value block sequence number
		LKMSG$L_VALSEQALT(R2)

	ASSUME	LKMSG$B_RSTATUS  EQ LKMSG$B_LSTATUS+1
	ASSUME	LKB$V_ASYNC  LE  7
	ASSUME	LKB$V_BLKASTQED  LE  7
	ASSUME	RSB$V_VALINVLD  LE  7

	CLRW	LKMSG$B_LSTATUS(R2)	; Clear LKB and RSB status fields in msg
	BICB3	#^C<LKB$M_BLKASTQED!-	; Set specified LKB status bits
		LKB$M_ASYNC>,LKB$W_STATUS(R0),LKMSG$B_LSTATUS(R2)
	BICB3	#^C<RSB$M_VALINVLD>,-	; Set specified RSB status bits
		RSB$W_STATUS(R1),LKMSG$B_RSTATUS(R2)
	MOVB	LKB$B_STATE(R0),R1	; Get lock state

	; Handle special-cased lock states

	DISPATCH	R1,TYPE=B,PREFIX=LKB$K_,-
		<-
		<GRANTED,50$>,-
		<CONVERT,50$>,-
		<WAITING,50$>,-
		<RETRY,20$>,-
		<SCSWAIT,20$>,-
		>

	BUG_CHECK	LOCKMGRERR,FATAL	; Illegal lock state

20$:	; Lock state is RETRY or SCSWAIT.  This must be a 
	; conversion request as new lock requests in this state aren't even 
	; rebuilt.  Store the old blocking AST address in the message because
	; that is what the master copy should hold at this point.  Then change
	; the lock state to GRANTED.

	MOVL	LKB$L_OLDBLKAST(R0),-	; Store old blocking AST address
		LKMSG$L_BLKASTFLG(R2)
	MOVB	#LKB$K_GRANTED,R1	; Set state to GRANTED

50$:	MOVB	R1,LKMSG$B_LCKSTATE(R2)	; Store lock state	
	RSB

	.SBTTL	LCK$RCV_LOCKREQ - Receive lock request

;++
;  FUNCTIONAL DESCRIPTION
;
;	This routine receives new lock requests from the remote
;	system.  The other system is the process system and this system is
;	the master system.  Root lock requests are special-cased in that
;	the root directory logic is involved (see below).
;
; CALLING SEQUENCE:
;
;	JSB	LCK$RCV_LOCKREQ	(called from SCS received message routine)
;	IPL must be at IPL$_SYNCH
;
; INPUT PARAMETERS:
;
;	R2	Address of message buffer
;	R3	Address of CSB
;	R5	Address of CDRP for response message
;
; OUTPUT PARAMETERS:
;
;	None
;
; SIDE EFFECTS:
;
;	A message may be sent back as a response
;
;
; DESCRIPTION OF DIRECTORY PROCESSING LOGIC:
;
;
;	If this is a sub-resource
;	    then
;		Get address of parent resource;
;	    else;
;	Search resource hash table for a matching resource;
;	If resource found
;	    then
;		If resource is managed locally (CSB address = 0)
;		    then
;			Handle lock request here;
;			Send response (granted, waiting, blocking, or notqueued);
;		    else
;			Bugcheck if this is a sub-resource
;			If system managing the resource is the same
;			system that sent us this request      [DIRECTORY LOOKUP]
;			    then
;				Send response (do locally);
;			    else
;				Send response (resend to specified 
;				system);
;	    else
;		If this is a root resource (PARENT = 0)
;		    then
;			If this is the directory node for this resource
;			    then
;				Create directory entry	    [ENTER IN DIRECTORY]
;				Send response (do locally);
;			    else
;				Send response (re-lookup in directory);
;								[DIRECTORY RACE]
;		    else
;			Bugcheck if parent is not managed here (CSID not 0)
;			Handle lock request here
;			Send response (granted, blocking, waiting or
;			not queued);
;				
;--

LCK$RCV_LOCKREQ::
	MOVL	R3,R1			; Move CSB address
	PUSHR	#^M<R1,R2,R6,R7,R8,R9,R10,R11>
	PUSHL	R5			; Save CDRP address
	PUSHL	CSB$L_CSID(R3)		; Convert CSB address to CSID and save
	MOVL	R2,R9			; Save input message address
	BSBW	CNX$INIT_CDRP		; Initialize CDRP

	; If this is not a root resource request then get address of parent
	; RSB (needed for hash table search) and verify that the resource
	; is managed on this system.

	CLRL	R7			; Assume no parent RSB
	MOVL	LKMSG$L_PARMSTLKID(R9),R6 ; Get parent lock id
	BEQL	20$			; No parent - this is a root resource
	MOVL	R6,R1			; Move parent id
	MOVL	LKMSG$L_PARPRCLKID(R9),R0 ; Get remote parent lock id for verify
	BSBW	VERIFYREMLKID		; Verify lockid and convert to LKB addr.
	BLBC	R0,80$			; Invalid lock id
	MOVL	LKB$L_RSB(R6),R7	; Get parent RSB address
20$:	MOVL	R7,LKMSG$L_PARMSTLKID(R9) ; Store in message for convenience

	; Search hash table for a matching resource.  The input message
	; is used as the template to match.

	ASSUME	LKMSG$W_GROUP  EQ  LKMSG$L_PARMSTLKID+4
	ASSUME	LKMSG$B_RMOD  EQ  LKMSG$W_GROUP+2
	ASSUME  LKMSG$B_RSNLEN  EQ  LKMSG$B_RMOD+1
	ASSUME	LKMSG$T_RESNAM  EQ  LKMSG$B_RSNLEN+1

	MOVAB	LKMSG$L_PARMSTLKID(R9),R4 ; Point to start of fields to match	
	MOVZBL	LKMSG$B_RSNLEN(R9),R10	; Get length of resource name
	ADDL	#8,R10			; Account for other fields to match
	MOVZWL	LKMSG$W_HASHVAL(R9),R1	; Get resource hash value
	JSB	G^LCK$SRCH_HSHTBL	; Search hash table
	BLBC	R0,EXISTING_RESOURCE
	BRW	NEW_RESOURCE

80$:	; Other system sent us an invalid lock id

	BUG_CHECK	INVLOCKID,FATAL

;**************************************************************************
;
;		Existing resource
;
;**************************************************************************

	.ENABL	LSB

5$:	; It looks like we should perform a directory lookup.  However,
	; if we are rebuilding a lock during failover, then additional
	; checking must be performed.

	CMPB	CLSMSG$B_FUNC(R9),-	; Is this a rebuild lock message
		#LKMSG$K_REBLDLOCK	; (only sent during failover)?
	BNEQ	10$			; No
	MOVL	(SP),R5			; Yes, get CSID of requesting system
	BSBW	LCK$CHECK_DIRENTRY	; Check if it's really a directory entry
	BLBC	R0,15$			; It's not - build the lock
10$:	BRW	DIR_LOOKUP		; Do a directory lookup

EXISTING_RESOURCE:
	; We've found a matching RSB.  If the resource is being
	; managed by another system (CSID non-zero) then treat
	; this request as a directory lookup.  Otherwise, handle it
	; in this system.  Registers contain:
	;
	;	R5	Address of matching RSB
	;	R6	Address of parent LKB (or 0)
	;	R7	Address of parent RSB (or 0)
	;	R9	Address of input message

	MOVL	R5,R8			; R8 will be used to point to RSB
	MOVL	RSB$L_CSID(R8),R4	; Get CSID
	BNEQ	5$			; Do a directory lookup

15$:	.IF NE	CA$_MEASURE
	INCL	G^PMS$GL_ENQNEW_IN
	.ENDC

	BSBW	BUILD_LKB		; Build the lock block
	BLBC	R0,19$			; Exit on any error
	MOVL	(SP),LKB$L_CSID(R6)	; Store CSID of requesting system
	CMPB	CLSMSG$B_FUNC(R9),-	; Is this a normal lock message?
		#LKMSG$K_NEWLOCK	; (as opposed to a failover message)
	BEQL	20$			; Yes
	CMPB	CLSMSG$B_FUNC(R9),-	; Is this a rebuild lock message?
		#LKMSG$K_REBLDLOCK
	BNEQ	18$			; No, must be a directory entry message
	BRW	REBLD_LOCK		; Yes, rebuild the lock
18$:	BUG_CHECK	LOCKMGRERR,FATAL; Disagreement regarding who's mastering
					; this lock tree
19$:	BRW	BLDLKB_ERROR2		; Branch extender

20$:	; Now see if the lock can be granted.  To be granted the conversion
	; and wait queues must be empty and the requested lock mode must be
	; compatible with the group grant mode of the resource.  (Actually,
	; any locks on the wait queue in states other than LKB$W_WAITING
	; are ignored).

	ASSUME	RSB$L_WTQFL  EQ  RSB$L_CVTQFL+8

	MOVAL	RSB$L_CVTQFL(R8),R0	; Get address of conversion queue
	CMPL	R0,(R0)			; Queue empty?
	BNEQ	50$			; No
	ADDL	#8,R0			; Get address of wait queue
	MOVL	R0,R1			; Save in R1
30$:	CMPL	(R0),R1			; Queue empty?
	BNEQ	40$			; No

35$:	; No waiting requests (or RECOVER bit is set); is the lock compatible?

	MOVZBL	LKB$B_RQMODE(R6),R1	; Get lock mode
	MOVZBL	RSB$B_GGMODE(R8),R5	; Get group grant mode
	BBC	R1,G^LCK$COMPAT_TBL[R5],52$ ; Branch if incompatible

	; Lock can be granted

	JSB	G^LCK$GRANT_LOCK		; Grant the lock
	BRW	LOCK_GRANTED

40$:	; Wait queue was not empty.  Skip over locks not in LKB$K_WAITING
	; state.  If we find even one lock in LKB$K_WAITING state, then
	; this lock is not grantable.

	MOVL	(R0),R0			; Get next lock on wait queue
	CMPB	#LKB$K_WAITING,-	; Is it in LKB$K_WAITING state?
		LKB$B_STATE-LKB$L_SQFL(R0)
	BNEQ	30$			; No, skip over it

50$:	; Lock cannot be granted now due to other locks in the waiting
	; or conversion queue.  However, if the RECOVER bit is set, then
	; ignore these locks and try granting it anyway

	BBS	#LCK$V_RECOVER,-	; Branch if recovering a lock
		LKB$W_FLAGS(R6),35$

52$:	; Lock cannot be granted now.  Queue it unless LCK$M_NOQUEUE
	; is set.

	BBS	#LCK$V_NOQUEUE,-	; Branch if the NOQUEUE bit is set
		LKB$W_FLAGS(R6),55$
	MOVW	RSB$W_RQSEQNM(R8),-	; Store request sequence number
		LKB$W_RQSEQNM(R6)
	INCW	RSB$W_RQSEQNM(R8)	; Increment sequence number
	JSB	G^LCK$QUEUEWAIT		; Queue it
	MOVB	#LKB$K_RSPQUEUED,R0	; Set response state
	BRW	LOCK_QUEUED

55$:	; Lock should not be queued.  Clean up and exit.

	.IF NE	CA$_MEASURE
	INCL	G^PMS$GL_ENQNOTQD
	.ENDC

	BSBW	LCK$DEALLOC_LKB		; Deallocate LKB, lockid, etc.
	MOVZWL	#SS$_NOTQUEUED,R0	; Return status
60$:	BRB	RESPOND_NOTQED

	.DSABL	LSB

;***********************************************************************
;
;		Directory handling and error routines
;
;***********************************************************************

	.ENABL	LSB

DIR_LOOKUP:
	; Treat this request as a directory lookup request by returning
	; the CSID of the system managing this resource.  If the
	; CSID matches that of the requestor then return a different
	; response state to indicate this.  R4 contains CSID of
	; system managing resource.  

	.IF NE	CA$_MEASURE
	INCL	G^PMS$GL_DIR_IN
	.ENDC

	TSTL	RSB$L_PARENT(R8)	; Directory entries must be roots
	BNEQ	40$			; Error

RESPOND_RESEND:
	POPL	R3			; Restore CSID of incoming message
	POPL	R5			; Restore CDRP address
	CMPL	R3,R4			; Is requestor managing resource?
	BEQL	RESPOND_DOLOCL		; Yes, do locally (on remote system)
	MOVL	R4,CDRP$L_VAL1(R5)	; No, return CSID of other system
	MOVB	#LKB$K_RSPRESEND,-	; Set response state
		CDRP$L_VAL2+2(R5)
	BRW	NOTQUEUED_EXIT

40$:	BUG_CHECK	LOCKMGRERR,FATAL

RELOOKUP:
	; Send a response telling requesting system to resend this
	; request to directory system (CSID in R4).  Note that it is
	; possible for the requesting system to be the directory system
	; for this resource in which case a "do locally" response is sent.
	; This situation is caused by the following race:
	;	o  This system masters the resource
	;	o  The other system (directory system) sends a request here
	;	o  This system removes the directory entry
	;	o  This system receives the request and returns "do locally"
	; The danger with this race is that the other system doesn't realize
	; it has a directory entry so doesn't set the DIRENTRY bit.  What
	; saves us is that it is already set and LCK$RCV_RMVDIR will not
	; delete the RSB.

	CLRL	RSB$L_HSHCHN(R11)	; Remove RSB from hash chain
	MOVL	R8,R0
	JSB	G^EXE$DEANONPAGED	; Deallocate RSB
	BRB	RESPOND_RESEND

DIR_ENTER:
	; If we are the directory system for this resource, then handle 
	; this request by making a directory entry.  Otherwise, tell requesting 
	; system to re-lookup the request in the directory as we've been 
	; bagged by a directory lookup race.

	MOVL	G^LCK$GL_DIRVEC,R3	; Get address of directory vector
	MOVZWL	RSB$W_HASHVAL(R8),R1	; Get hash value
	CLRL	R2			; Clear high order hash value
	EDIV	-12(R3),R1,R0,R1	; Compute hash index (in R1)
	MOVL	(R3)[R1],R4		; Get directory system
	BNEQ	RELOOKUP		; It's not us
	BISW	#RSB$M_DIRENTRY,-	; Set directory entry bit
		RSB$W_STATUS(R8)

	.IF NE	CA$_MEASURE
	INCL	G^PMS$GL_DIR_IN
	.ENDC

	POPL	R3			; Restore CSID
	POPL	R5			; Restore CDRP address
	MOVL	R3,RSB$L_CSID(R8)	; Store CSID in RSB to form dir. entry

RESPOND_DOLOCL:
	; Send a response that tells the requestor to handle the lock request
	; locally.

	MOVB	#LKB$K_RSPDOLOCL,-	; Store response state
		CDRP$L_VAL2+2(R5)
	BRB	NOTQUEUED_EXIT

RESPOND_NOTQED:
	; Lock was not queued due to an error.  Status is in R0
	;  (e.g. SS$_NOTQUEUED)

	POPL	R3			; Restore CSID
	POPL	R5			; Restore CDRP address
	MOVW	R0,CDRP$L_VAL2(R5)	; Store error status
	MOVB	#LKB$K_RSPNOTQED,-	; Store response state
		CDRP$L_VAL2+2(R5)	; and fall thru to ...

NOTQUEUED_EXIT:
	MOVAB	W^BLD_RSPMSG,-		; Store address of message build 
		CDRP$L_MSGBLD(R5)	; routine
QUEUED_EXIT:
	MOVL	G^CLU$GL_CLUB,R0	; Get address of CLUB
	MOVW	CLUB$W_MEMSEQ(R0),-	; Store membership seq. num.
		CDRP$L_VAL3(R5)
	POPR	#^M<R1,R2,R6,R7,R8,R9,R10,R11>
	BSBW	CNX$SEND_MSG_RESP	; Send message response
	CMPW	R0,#SS$_NOSUCHNODE	; Is status SS$_NOSUCHNODE?
	BEQL	60$			; Yes, error
	MOVL	R5,R0			; No, SS$_NODELEAVE is okay
	JMP	G^EXE$DEANONPAGED	; Deallocate CDRP

60$:	BUG_CHECK	LOCKMGRERR,FATAL; CSID invalid

	.DSABL	LSB

;****************************************************************************
;
;		New Resource
;
;****************************************************************************

	; Resource was not found so it must be created.  If it's a root
	; resource and we are the directory system, then a directory
	; entry will be made but the lock will be handled by the remote
	; system.  If it's a root resource but we are not the directory
	; system then the remote system will be told to re-lookup this
	; resource in the directory.  If it's not a root resource then the
	; lock request is handled here.  Registers contain:
	;
	;	R6	Address of parent LKB (or 0)
	;	R7	Address of parent RSB (or 0)
	;	R9	Address of input message
	;	R10	Length of resource name+8
	;	R11	Address of last RSB in resource hash chain

NEW_RESOURCE:
	MOVAB	RSB$K_LENGTH-8(R10),R1	; Compute size of RSB
	JSB	G^EXE$ALONONPAGED	; Allocate RSB
	BLBC	R0,40$			; Didn't get one
	MOVZWL	R1,RSB$W_SIZE(R2)	; Store size and zero depth
	MOVB	#DYN$C_RSB,RSB$B_TYPE(R2) ; Store type
	MOVL	R2,R8			; R8 points to RSB

	; Initialize various fields in RSB

	ASSUME	RSB$B_CGMODE  EQ  RSB$B_GGMODE+1
	ASSUME	RSB$W_STATUS  EQ  RSB$B_CGMODE+1
	ASSUME	RSB$W_REFCNT  EQ  RSB$L_VALSEQNUM+4
	ASSUME	RSB$W_BLKASTCNT  EQ RSB$W_REFCNT+2
	ASSUME	RSB$L_CVTQFL  EQ  RSB$L_GRQFL+8
	ASSUME	RSB$L_WTQFL  EQ  RSB$L_CVTQFL+8
	ASSUME	RSB$W_RQSEQNM  EQ  RSB$W_HASHVAL+2

	MOVL	R8,RSB$L_HSHCHN(R11)	; Make last RSB point to this one
	CLRL	RSB$L_HSHCHN(R8)	; This one ends the chain
	MOVL	R11,RSB$L_HSHCHNBK(R8)	; Point to previous one
	MOVAL	RSB$L_GRQFL(R8),R0	; Initialize all three queue headers
	MOVL	R0,R1
	MOVL	R0,(R1)+		; Granted queue
	MOVAQ	(R0)+,(R1)+
	MOVL	R0,(R1)+		; Conversion queue
	MOVAQ	(R0)+,(R1)+
	MOVL	R0,(R1)+		; Waiting queue
	MOVL	R0,(R1)
	CLRQ	RSB$Q_VALBLK(R8)	; Clear value block
	CLRQ	RSB$Q_VALBLK+8(R8)
	CLRQ	RSB$L_VALSEQNUM(R8)	; Clear value block seq. number,
					; ref. count and blocking AST cnt.
	CLRL	RSB$B_GGMODE(R8)	; Clear modes, status
	MOVZWL	LKMSG$W_HASHVAL(R9),-	; Store hash value, clear request
		RSB$W_HASHVAL(R8)	; sequence number
	MOVC3	R10,-			; Move parent RSB address, group number,
		LKMSG$L_PARMSTLKID(R9),-; access mode, res. name length and 
		RSB$L_PARENT(R8)	; resource name to RSB

	; If this is a root resource, then just create a directory entry
	; and don't build a LKB.

	TSTL	R7			; Is this a root resource?
	BNEQ	60$			; No
	BRW	DIR_ENTER		; Yes

40$:	BRW	BLDLKB_ERROR2		; Branch extender

50$:	; Received a lock request for a lock whose parent is not managed
	; by this system.

	BUG_CHECK	LOCKMGRERR,FATAL

60$:	ADDB3	#1,RSB$B_DEPTH(R7),-	; Set depth
		RSB$B_DEPTH(R8)
	INCW	RSB$W_REFCNT(R7)	; Incr. parent's reference count
65$:	MOVL	RSB$L_CSID(R7),-	; Clear CSID by copying parent's
		RSB$L_CSID(R8)		; and verifying it's zero
	BNEQ	50$			; Error

	; Build the LKB.

	.IF NE	CA$_MEASURE
	INCL	G^PMS$GL_ENQNEW_IN
	.ENDC

	BSBW	BUILD_LKB
	BLBC	R0,BLDLKB_ERROR		; Unable to build LKB.  Status in R0
	MOVL	(SP),LKB$L_CSID(R6)	; Store CSID or requesting system
	CMPB	CLSMSG$B_FUNC(R9),-	; Is this a rebuild lock message
		#LKMSG$K_REBLDLOCK	; (only sent during failover)?
	BEQL	REBLD_LOCK		; Yes

	; Grant the lock.

	MOVZBL	LKB$B_RQMODE(R6),R1	; Get requested mode
	JSB	G^LCK$GRANT_LOCK_ALT	; Grant the lock

LOCK_GRANTED:
	BICW	#LKB$M_DBLKAST,-	; Got set spuriously by common code
		LKB$W_STATUS(R6)
	MOVB	#LKB$K_RSPGRANTD,R0	; Set response state

LOCK_QUEUED:
	; Lock response state is in R0.  It is either RSPGRANTD or 
	; RSPQUEUED.  I.e. it is one of the states that actually
	; built and queued a LKB.  Send response message.

	POPL	R3			; Restore CSID
	POPL	R5			; Restore CDRP address
	MOVAB	W^BLD_LOCKRSP,-		; Store address of message build routine
		CDRP$L_MSGBLD(R5)
	MOVL	R6,CDRP$L_VAL1(R5)	; Store LKB address
	MOVB	R0,CDRP$L_VAL2+2(R5)	; Store response state
	BRW	QUEUED_EXIT

REBLD_LOCK:
	; Rebuild lock (only performed during failover)

	BSBW	LCK$REBLD_LOCK		; Rebuild the lock
	BRB	LOCK_GRANTED		; Send the response

BLDLKB_ERROR:
	; Error status in R0.  Parent RSB address in R7.
	; Address of previous RSB in hash chain in R11.  Deallocate RSB.

	PUSHL	R0			; Save R0
	DECW	RSB$W_REFCNT(R7)	; Decrement's parent's reference count
	CLRL	RSB$L_HSHCHN(R11)	; Remove from hash chain
	MOVL	R8,R0
	JSB	G^EXE$DEANONPAGED	; Deallocate RSB
	POPL	R0			; Restore R0

BLDLKB_ERROR2:
	; Error handling depends on whether this is a rebuild lock
	; (during failover) or a lock request during normal operation.
	; During normal operation, all errors other than SS$_INSFMEM 
	; are sent back to the other system.  SS$_INSFMEM is handled 
	; by breaking our connection as a form of waiting.
	; During failover, we bugcheck here with an appropriate
	; type of resource exhausted bugcheck.

	CMPB	CLSMSG$B_FUNC(R9),-	; Is this a rebuild lock message?
		#LKMSG$K_REBLDLOCK	
	BEQL	40$			; Yes
	CMPW	R0,#SS$_INSFMEM		; Is it insufficient memory?
	BEQL	30$			; Yes
	BRW	RESPOND_NOTQED		; No, send error back
30$:	POPL	R3			; Restore CSID
	POPL	R5			; Restore CDRP address
	MOVL	R5,R0
	JSB	G^EXE$DEANONPAGED	; Deallocate CDRP
	POPR	#^M<R1,R2,R6,R7,R8,R9,R10,R11>
	MOVL	R1,R3			; Move CSB address
	BSBW	CNX$RCV_REJECT		; Reject this message
	RSB

40$:	; Unable to rebuild a lock during failover.  Bugcheck
	; with a (hopefully) useful bugcheck message.

	CMPW	R0,#SS$_INSFMEM		; Is it insufficient non-paged pool?
	BNEQ	50$			; No
	BUG_CHECK	INSFPOOL,FATAL	; Yes
50$:	CMPW	R0,#SS$_NOLOCKID	; Is it no lockids?
	BNEQ	60$			; No
	BUG_CHECK	INSFLOCKID,FATAL; Yes
60$:	BUG_CHECK	LOCKMGRERR,FATAL; Unknown error (status in R0)


;****************************************************************************
;
;		Message Build Routines
;
;****************************************************************************

	; BLD_RSPMSG is a generic message building routine that simply
	; copies a fixed quadword from the CDRP into the message
	; buffer.  Since this is a response message, the RSPID sent
	; to us is returned.  Registers contain:
	;	R2	Address of message buffer
	;	R5	Address of CDRP

	ASSUME	LKMSG$B_STATE  EQ  LKMSG$L_CSID+6

BLD_RSPMSG:
	ASSUME	CLSMSG$B_FUNC  EQ  CLSMSG$B_FACILITY+1
	MOVW	#LKMSG$K_NEWLOCK@8-	; Store function and facility codes
		!CLSMSG$M_RESPMSG-
		!CLSMSG$K_FAC_LCK,CLSMSG$B_FACILITY(R2)
	MOVQ	CDRP$L_VAL1(R5),-	; Copy value into message buffer
		LKMSG$L_CSID(R2)
	MOVW	CDRP$L_VAL3(R5),-	; Store membership seq. num.
		LKMSG$W_MEMSEQ(R2)
	RSB


	; BLD_LOCKRSP builds a response message for lock requests.
	; This response message is only used if this system actually
	; created (and queued) a LKB.  In all other cases, (e.g.
	; directory lookups) a simple response is built by BLD_RSPMSG.
	; Registers contain:
	;	R2	Address of message buffer
	;	R3	Address of CSB
	;	R5	Address of CDRP
	; 	CDRP$L_VAL1 contains address of the LKB
	; All registers except R0 and R1 must be preserved
	;
	; Note:  This message build routine uses pointers (to LKB and RSB)
	; that will not be valid if we started a state change.  Therefore,
	; it is necessary to validiate the membership sequence number
	; before using any pointers stored in the CDRP.

BLD_LOCKRSP:
	ASSUME	CLSMSG$B_FUNC  EQ  CLSMSG$B_FACILITY+1
	MOVW	#LKMSG$K_NEWLOCK@8-	; Store function and facility codes
		!CLSMSG$M_RESPMSG-
		!CLSMSG$K_FAC_LCK,CLSMSG$B_FACILITY(R2)
	MOVW	CDRP$L_VAL3(R5),-	; Store membership seq. num.
		LKMSG$W_MEMSEQ(R2)
	MOVL	CSB$L_CLUB(R3),R1	; Get address of CLUB
	CMPW	CLUB$W_MEMSEQ(R1),-	; Have we done a state change?
		CDRP$L_VAL3(R5)
	BNEQ	20$			; Yes
	MOVL	CDRP$L_VAL1(R5),R0	; Get address of LKB
	MOVL	LKB$L_LKID(R0),-	; Store master lockid
		LKMSG$L_MSTLKID(R2)
	MOVL	LKB$L_REMLKID(R0),-	; Store process lockid
		LKMSG$L_PRCLKID(R2)
	MOVB	CDRP$L_VAL2+2(R5),-	; Store response state
		LKMSG$B_STATE(R2)
	MOVW	LKB$W_STATUS(R0),-	; Store LKB status
		LKMSG$W_LKBSTATUS(R2)
	ASSUME	LKB$K_GRANTED  GT  0
	ASSUME	LKB$K_WAITING  LT  0
	TSTB	LKB$B_STATE(R0)		; Is lock granted?
	BLEQ	10$			; No
	MOVL	LKB$L_RSB(R0),R1	; Get RSB address
	MOVQ	RSB$Q_VALBLK(R1),-	; Store value block
		LKMSG$Q_VALBLK(R2)
	MOVQ	RSB$Q_VALBLK+8(R1),-
		LKMSG$Q_VALBLK+8(R2)
	MOVL	RSB$L_VALSEQNUM(R1),-	; Store sequence number
		LKMSG$L_VALSEQNUM(R2)
	MOVW	RSB$W_STATUS(R1),-	; Store RSB status
		LKMSG$W_RSBSTATUS(R2)
	RSB

10$:	MOVW	LKB$W_RQSEQNM(R0),-	; Store request sequence number
		LKMSG$W_RQSEQNM(R2)
	RSB

20$:	; We've done a membership state change between our SEND_MSG
	; and calling the message build routine.  Just send back a RETRY
	; status.

	MOVB	#LKB$K_RETRY,-		; Store RETRY status
		LKMSG$B_STATE(R2)
	RSB

	.SBTTL	BUILD_LKB - Build lock block

;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine builds LKBs for received lock requests that are
; 	being handled by this system.
;
; CALLING SEQUENCE:
;
;	BSBW	BUILD_LKB
;
; INPUT PARAMETERS:
;
;	R6	Address of parent LKB (or 0)
;	R8	Address of RSB
;	R9	Address of input message
;
; IMPLICIT INPUTS:
;
;	Various fields in the input message are used
;
; OUTPUT PARAMETERS:
;
;	R0	Completion code
;	R6	Address of LKB
;
; COMPLETION CODES:
;
;	SS$_NORMAL	Successful completion
;	SS$_INSFMEM	Insufficent memory to allocate LKB
;	SS$_NOLOCKID	No lock ids
;
; SIDE EFFECTS:
;
;	R0 - R4 are destroyed
;--


NO_LOCKIDS:
	; No lock ids.  Deallocate LKB and try to extend table.

	MOVL	R2,R0			; Address of LKB
	JSB	G^EXE$DEANONPAGED	; Deallocate it
	JSB	G^LCK$EXTEND_IDTBL	; Extend table
	BLBS	R0,BUILD_LKB		; Success, repeat routine
BUILD_LKB_ERR:
	RSB

BUILD_LKB:
	MOVZWL	#LKB$K_LENGTH,R1	; Size of LKB
	JSB	G^EXE$ALONONPAGED	; Allocate it
	BLBC	R0,BUILD_LKB_ERR		; Unable to allocate it
	MOVL	#<DYN$C_LKB@16>!-	; Store size and type
		LKB$K_LENGTH,LKB$W_SIZE(R2)
	CLRL	LKB$L_PID(R2)		; Clear PID
	MOVL	G^LCK$GL_NXTID,R0	; Get next lock id
	BEQL	NO_LOCKIDS		; No more - return error
	MOVL	G^LCK$GL_IDTBL,R1	; Get address of lock id table.  *** May
					; combine with next instr. if no loading
	MOVW	R0,LKB$L_LKID(R2)	; Store lockid index
	MOVAL	(R1)[R0],R1		; Get address of lockid table entry
	MOVZWL	(R1),G^LCK$GL_NXTID	; Update ptr to next free id
	MOVW	2(R1),LKB$L_LKID+2(R2)	; Store lockid sequence number
	MOVL	R2,(R1)			; Store LKB address in table entry
	MOVL	R8,LKB$L_RSB(R2)	; Make LKB point to RSB
	MOVL	R6,LKB$L_PARENT(R2)	; Point to parent LKB
	BEQL	10$			; No parent
	INCW	LKB$W_REFCNT(R6)	; Incr. parent's reference count

10$:	; Build portion of LKB that comes from input message

	ASSUME	LKMSG$W_FLAGS  EQ  LKMSG$L_PRCLKID+4
	ASSUME	LKMSG$B_RQMODE  EQ  LKMSG$W_FLAGS+2
	ASSUME	LKMSG$B_GRMODE  EQ  LKMSG$B_RQMODE+1
	ASSUME	LKMSG$L_BLKASTFLG  EQ  LKMSG$B_GRMODE+1

	MOVL	R2,R6			; Use R6 for LKB from now on
	MOVAB	LKMSG$L_PRCLKID(R9),R3	; Point into message
	MOVL	(R3)+,LKB$L_REMLKID(R6)	; Store process lock id
	MOVW	(R3)+,LKB$W_FLAGS(R6)	; Store flags
	MOVW	(R3)+,LKB$B_RQMODE(R6)	; Store lock modes
	MOVL	(R3)+,LKB$L_BLKASTADR(R6) ; Store blocking AST flag

	; Store EPID of owner of lock unless LCK$M_CVTSYS is set in
	; which case, store 0.  Also store deadlock priority if not system
	; owned.

	CLRL	R0			; Assume system owned
	BBS	#LCK$V_CVTSYS,-		; Branch if it is system owned
		LKB$W_FLAGS(R6),20$
	MOVL	LKMSG$L_EPIDNEW(R9),R0  ; Get EPID
	MOVL	LKMSG$L_DLCKPRI_NEW(R9),-
		LKB$L_DLCKPRI(R6)	; Store deadlock priority
20$:	MOVL	R0,LKB$L_EPID(R6)	; Store EPID or 0

	; Finish remainder of LKB

	MOVW	#LKB$M_MSTCPY,-		; Store master copy flag
		LKB$W_STATUS(R6)
	BBC	#LCK$V_PROTECT,-	; Branch if this is not a protected lock
		LKB$W_FLAGS(R6),30$
	BISW	#LKB$M_PROTECT,-	; Set PROTECT status bit
		LKB$W_STATUS(R6)
30$:	CLRW	LKB$W_REFCNT(R6)	; Clear ref. count
	MOVL	S^#SS$_NORMAL,R0	; Store success status
	RSB

	.SBTTL	LCK$DEALLOC_LKB - Deallocate a LKB

;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine is used to deallocate a LKB and perform
;	additional cleanup such as deallocating the lock id. and
;	adjusting the parent's reference count.
;
; CALLING SEQUENCE:
;
;	BSBW	LCK$DEALLOC_LKB
;
; INPUT PARAMETERS:
;
;	R6	Address of LKB
;
; OUTPUT PARAMETERS:
;
;	None
;
; SIDE EFFECTS:
;
;	R0 - R3 destroyed
;--

LCK$DEALLOC_LKB::
	; Remove lock from timeout queue, if it's on it.

	BBCC	#LKB$V_TIMOUTQ,-	; Is lock on timeout queue?
		LKB$W_STATUS(R6),5$
	REMQUE	LKB$L_ASTQFL(R6),R0	; Yes, remove it

5$:	; Deallocate lock id.  

	MOVZWL	LKB$L_LKID(R6),R0	; Get lock id index
	MOVL	G^LCK$GL_IDTBL,R1	; *** Combine with next instr.
	MOVAL	(R1)[R0],R1		; Point to table entry
	MOVW	G^LCK$GL_NXTID,(R1)	; Store next id in this id's slot
	ADDW3	#1,LKB$L_LKID+2(R6),2(R1) ; Incr. and store sequence number
	BVC	20$			; Didn't overflow to a system address
	MOVW	#1,2(R1)		; Overflowed - restart seq. number at 1
20$:	MOVL	R0,G^LCK$GL_NXTID	; This id becomes the next one

	; Decrement parent LKB's reference count

	MOVL	LKB$L_PARENT(R6),R0	; Get address of parent
	BEQL	30$			; No parent
	DECW	LKB$W_REFCNT(R0)	; Decr. parent's reference count
	BLSS	80$			; Went negative

30$:	; Deallocate LKB

	MOVL	R6,R0
	JSB	G^EXE$DEANONPAGED	; Deallocate LKB
	RSB

80$:	BUG_CHECK	LKBREFNEG,FATAL

	.SBTTL	LCK$SND_GRANTED - Send a lock granted message

;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine sends a lock granted message to the process system.
;	We are the master system for this lock.
;
; CALLING SEQUENCE:
;
;	JSB	LCK$SND_GRANTED
;	IPL must be at IPL$_SYNCH
;
; INPUT PARAMETERS:
;
;	R6	Address of LKB
;	R8	Address of RSB
;
; OUTPUT PARAMETERS:
;
;	None
;
; SIDE EFFECTS:
;
;	R0 - R5 are not preserved.
;--

LCK$SND_GRANTED::
	BBCC	#LKB$V_TIMOUTQ,-	; Remove lock from timeout queue
		LKB$W_STATUS(R6),10$	; if it was on it
	REMQUE	LKB$L_ASTQFL(R6),R0
10$:	BICW	#LKB$M_DBLKAST,-	; Clear deliver blocking AST bit
		LKB$W_STATUS(R6)	; that was set spuriously
	MOVL	LKB$L_CSID(R6),R3	; Get CSID of remote system
	BSBW	CNX$ALLOC_CDRP		; Alloc. a CDRP and convert CSID to CSB
	BLBC	R0,80$			; Unable to allocate one or CSID error

	; Put lock ids. into CDRP and then send message.
	; Note:  It might seem preferable to put the LKB address into
	; the CDRP rather than the lock ids.  The problem with this approach 
	; is that the LKB could be deallocated while the thread to 
	; build and send the message was waiting for resources.
	; So instead, we use the lock ids. and re-validate the LKB.
	; If we find that the LKB has been deallocated, we no longer
	; need to send a message.  However, there is no way to stop
	; sending a message once we are inside the message build routine.
	; So instead, we send the message and depend on a lockid mismatch
	; at the remote end.

	MOVL	LKB$L_LKID(R6),-	; Store master lockid
		CDRP$L_VAL1(R5)
	MOVL	LKB$L_REMLKID(R6),-	; Store process lockid
		CDRP$L_VAL2(R5)
	MOVL	CSB$L_CLUB(R3),R0	; Get address of CLUB
	MOVW	CLUB$W_MEMSEQ(R0),-	; Store membership seq. num.
		CDRP$L_VAL3(R5)

	; Store address of message build routine and send message

	MOVAB	B^BLD_GRANTEDMSG,-	; Store address of message
		CDRP$L_MSGBLD(R5)	; build routine
	BSBW	CNX$SEND_MSG_CSB	; Send the message
	MOVL	R5,R0			; Address of CDRP
	JMP	G^EXE$DEANONPAGED	; Deallocate it

80$:	MOVL	R6,R4			; Move LKB address

INSERT_ON_TIMOUTQ:
	; CSID conversion error or no CDRPs.  Queue LKB to timeout queue
	; if insufficient memory.  LKB address is in R4.

	CMPW	R0,#SS$_INSFMEM		; Is it insufficient memory?
	BNEQ	90$			; No
	BISW	#LKB$M_TIMOUTQ,-	; Set timeout bit
		LKB$W_STATUS(R4)
	MOVL	G^EXE$GL_ABSTIM,-	; Store immediate timeout time
		LKB$L_DUETIME(R4)
	INSQUE	LKB$L_ASTQFL(R4),-	; Insert at head of timeout queue
		G^LCK$GL_TIMOUTQ
	RSB

90$:	BUG_CHECK	LOCKMGRERR,FATAL

	; Action routine to build the lock granted message.  Inputs are:
	;	R2	Address of message buffer
	;	R5	Address of CDRP

BLD_GRANTEDMSG:
	PUSHL	R4			; Save registers
	PUSHL	R6
	ASSUME	CLSMSG$B_FUNC  EQ  CLSMSG$B_FACILITY+1
	MOVW	#LKMSG$K_GRANTED@8-	; Store function and facility codes
		!CLSMSG$K_FAC_LCK,CLSMSG$B_FACILITY(R2)
	MOVW	CDRP$L_VAL3(R5),-	; Store membership seq. num.
		LKMSG$W_MEMSEQ(R2)
	MOVL	CDRP$L_VAL1(R5),R1	; Get master lockid
	MOVL	CDRP$L_VAL2(R5),R0	; Get process lockid
	MOVQ	CDRP$L_VAL1(R5),-	; Store lockids
		LKMSG$L_MSTLKID(R2)
	BSBW	VERIFYREMLKID
	BLBC	R0,60$			; Branch if LKB went away
	MOVL	LKB$L_RSB(R6),R0	; Get RSB address

	; Note we are only sending the low byte of the RSB status
	; as the high byte overlaps the LKMSG$B_GRMODE field.
	; We can get away with this because we only need to send
	; the RSB$V_VALINVLD bit.  However, this should be fixed.

	ASSUME	LKMSG$B_GRMODE  EQ  LKMSG$W_RSBSTATUS+1
	ASSUME	RSB$V_VALINVLD  LE  7

	MOVW	LKB$W_STATUS(R6),-	; Store LKB status
		LKMSG$W_LKBSTATUS(R2)
	MOVB	RSB$W_STATUS(R0),-	; Store low byte of RSB status
		LKMSG$W_RSBSTATUS(R2)
	MOVB	LKB$B_GRMODE(R6),-	; Store granted mode
		LKMSG$B_GRMODE(R2)
	MOVQ	RSB$Q_VALBLK(R0),-	; Store value block
		LKMSG$Q_VALBLK(R2)
	MOVQ	RSB$Q_VALBLK+8(R0),-
		LKMSG$Q_VALBLK+8(R2)
	MOVL	RSB$L_VALSEQNUM(R0),-	; Store value block sequence number
		LKMSG$L_VALSEQNUM(R2)
60$:	POPL	R6			; Restore registers
	POPL	R4
	RSB

	.SBTTL	LCK$RCV_GRANTED - Receive lock granted message

;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine handles the receiving of a lock granted message
;	sent by the master system.  This system is the process system for 
;	this lock.
;
; CALLING SEQUENCE:
;
;	JSB	LCK$RCV_GRANTED (called by SCS received message routine)
;	IPL must be at IPL$_SYNCH
;
; INPUT PARAMETERS:
;
;	R2	Address of message buffer
;	R3	Address of CSB
;
; OUTPUT PARAMETERS:
;
;	None
;
; SIDE EFFECTS:
;
;	R0 - R5 Destroyed
;--

LCK$RCV_GRANTED::
	PUSHR	#^M<R2,R3,R6,R7,R8,R9,R10,R11>
	ASSUME	LKMSG$L_PRCLKID  EQ  LKMSG$L_MSTLKID+4
	MOVQ	LKMSG$L_MSTLKID(R2),R0	; Get process and master lockids
	BSBW	VERIFYREMLKID		; Convert to LKB address
	BLBC	R0,40$			; Invalid lockid - ignore message
	MOVL	LKB$L_RSB(R6),R8	; Get RSB address

	; Store value block unless the one we already have is later.
	; Note we are only sending the low byte of the RSB status
	; as the high byte overlaps the LKMSG$B_GRMODE field.
	; We can get away with this because we only need to send
	; the RSB$V_VALINVLD bit.  However, this should be fixed.

	ASSUME	RSB$V_VALINVLD  LE  7

	SUBL3	RSB$L_VALSEQNUM(R8),-	; Compare sequence numbers
		LKMSG$L_VALSEQNUM(R2),R0
	BLEQ	10$			; We already have a newer one
	MOVQ	LKMSG$Q_VALBLK(R2),-	; Store value block
		RSB$Q_VALBLK(R8)
	MOVQ	LKMSG$Q_VALBLK+8(R2),-
		RSB$Q_VALBLK+8(R8)
	MOVL	LKMSG$L_VALSEQNUM(R2),-	; Store sequence number
		RSB$L_VALSEQNUM(R8)
	BICW	#RSB$M_VALINVLD,-	; Clear value block invalid flag
		RSB$W_STATUS(R8)
	BBC	#RSB$V_VALINVLD,-	; and conditionally set it
		LKMSG$W_RSBSTATUS(R2),10$
	BISW	#RSB$M_VALINVLD,-
		RSB$W_STATUS(R8)

10$:	; There are a number of race conditions that must be handled
	; correctly when this message is received.  These are:
	;	1)  We receive this message before the process has
	;	    been scheduled.  The LKB state is RSPQUEUED.  In this
	;	    case change the state to RSPGRANTD.
	;	2)  The lock was dequeued before this message arrived.
	;	    In this case we will get an invalid lock id above
	;	    and will ignore this message.
	;	3)  The lock was a conversion and it was canceled before
	;	    this message arrived.  The LKB state is GRANTED.  Ignore
	;	    this message unless the BLKASTQED bit is set.  In this
	;	    case handle this message as if it were a blocking AST 
	;	    message.
	;	4)  Case # 3 but another conversion has already been issued.
	;	    Lock state is SCSWAIT, RETRY, RSPQUEUED, or RSPGRANTD.
	;	    This condition is also determined by the granted
	;	    lock mode in the message not being equal to the requested
	;	    mode in the LKB.  Ignore this message.

	DISPATCH	LKB$B_STATE(R6),TYPE=B,PREFIX=LKB$K_,-
		<-
		<GRANTED,20$>,-		; Ignore unless BLKASTQED set
		<CONVERT,50$>,-		; Handle normally
		<WAITING,50$>,-		; Handle normally
		<RETRY,80$>,-		; Ignore message
		<SCSWAIT,80$>,-		; Ignore message
		<RSPQUEUED,30$>,-	; Change state to RSPGRANTD
		<RSPGRANTD,80$>,-	; Ignore message
		>
	BUG_CHECK	LOCKMGRERR,FATAL; Invalid state

20$:	; The lock state is granted.  This should only occur if the lock
	; request was canceled.  If the BLKASTQED bit is set then treat this
	; message as a blocking AST message.

	BBC	#LKB$V_BLKASTQED,-	; Branch if should not queue blocking
		LKMSG$W_LKBSTATUS(R2),80$ ; AST
	POPR	#^M<R2,R3,R6,R7,R8,R9,R10,R11> ; Restore registers
	BRW	LCK$RCV_BLKING		; Use common code

30$:	; The lock state is RSPQUEUED.  Change to RSPGRANTD and store
	; BLKASTQED bit.

	CMPB	LKMSG$B_GRMODE(R2),-	; Is granted mode (in message) equal
		LKB$B_RQMODE(R6)	; to requested mode (in lock)?
	BNEQ	80$			; No, ignore message
	MOVB	#LKB$K_RSPGRANTD,-	; Yes, store new state
		LKB$B_STATE(R6)
	BBC	#LKB$V_BLKASTQED,-	; Branch if should not queue blocking
		LKMSG$W_LKBSTATUS(R2),80$ ; AST
	BISW	#LKB$M_BLKASTQED,-	; Set BLKASTQED bit
		LKB$W_STATUS(R6)
40$:	BRB	80$

50$:	; The lock state is CONVERT or WAITING.  Now grant the lock.

	CMPB	LKMSG$B_GRMODE(R2),-	; Is granted mode (in message) equal
		LKB$B_RQMODE(R6)	; to requested mode (in lock)?
	BNEQ	80$			; No, ignore message
	MOVB	LKB$B_RQMODE(R6),-	; Yes, make granted mode equal
		LKB$B_GRMODE(R6)	; requested mode
	MOVZWL	S^#SS$_NORMAL,-		; Store status
		LKB$L_LKST1(R6)
	REMQUE	LKB$L_SQFL(R6),R0	; Remove from wait queue
	TSTL	LKB$L_BLKASTADR(R6)	; Blocking AST specified?
	BEQL	60$			; No
	INCW	RSB$W_BLKASTCNT(R8)	; Yes, incr. blocking AST count
	BBC	#LKB$V_BLKASTQED,-	; Branch if should not queue blocking
		LKMSG$W_LKBSTATUS(R2),60$ ; AST
	BISW	#LKB$M_BLKASTQED!-	; Set blocking AST queued and
		LKB$M_DBLKAST,LKB$W_STATUS(R6) ; deliver blocking AST status
	BISB	#LKB$M_PKAST,-		; Set piggyback kernel AST bit
		LKB$B_RMOD(R6)
	MOVL	LKB$L_BLKASTADR(R6),-	; Store address of blocking AST routine
		LKB$L_AST(R6)
60$:	JSB	G^LCK$GRANT_REM		; Finish granting it using common code

80$:	; Deallocate message buffer and exit

	POPR	#^M<R2,R3,R6,R7,R8,R9,R10,R11>
	BRW	CNX$DEALL_MSG_BUF_CSB	; Deallocate message buffer and return

	.SBTTL	LCK$SND_BLKING  - Send a blocking message

;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine sends a blocking message to the process system.
;	We are the master system for this lock.
;
; CALLING SEQUENCE:
;
;	JSB	LCK$SND_BLKING
;	IPL must be at IPL$_SYNCH
;
; INPUT PARAMETERS:
;
;	R5	Address of LKB blocking another lock
;	R6	Address of LKB being blocked
;
; OUTPUT PARAMETERS:
;
;	None
;
; SIDE EFFECTS:
;
;	R0 - R5 are not preserved
;--

	.ENABL	LSB

LCK$SND_BLKING::
	BISW	#LKB$M_BLKASTQED,-	; Set blocking AST queued bit
		LKB$W_STATUS(R5)

	; If the blocking LKB (in R5) is on the same system as the
	; LKB being blocked (in R6) then we don't send a message as
	; this case is handled locally on the other system.
	; Also note that the comment in LCK$SND_GRANTED about the LKB
	; being deallocated out from under us applies here also.  However,
	; in this case, copying the info. is not as bad since much less
	; is copied.

	MOVL	LKB$L_CSID(R5),R3	; Get CSID
	BBC	#LKB$V_MSTCPY,-		; Branch if blockee is local
		LKB$W_STATUS(R6),10$
	CMPL	R3,LKB$L_CSID(R6)	; Does CSID match other lock?
	BEQL	30$			; Yes
10$:	MOVL	R5,R4			; R4 will point to LKB

SEND_BLOCKING:
	; Allocate a CDRP and copy lockids into it.  R3 contains CSID
	; and R4 points to LKB.

	BSBW	CNX$ALLOC_CDRP		; Alloc. CDRP and convert CSID to CSB
	BLBS	R0,20$		
	BRW	INSERT_ON_TIMOUTQ	; None available or CSID error
20$:	MOVL	LKB$L_LKID(R4),-	; Copy master lockid
		CDRP$L_VAL1(R5)
	MOVL	LKB$L_REMLKID(R4),-	; Copy process lockid
		CDRP$L_VAL2(R5)
	MOVL	CSB$L_CLUB(R3),R0	; Get address of CLUB
	MOVW	CLUB$W_MEMSEQ(R0),-	; Store membership seq. num.
		CDRP$L_VAL3(R5)
	MOVB	LKB$B_GRMODE(R4),-	; Copy granted mode of lock
		CDRP$L_VAL3+2(R5)

	; Store address of message build routine and send message

	.IF NE	CA$_MEASURE
	INCL	G^PMS$GL_BLK_OUT
	.ENDC

	MOVAB	B^BLD_BLKINGMSG,-
		CDRP$L_MSGBLD(R5)
	BSBW	CNX$SEND_MSG_CSB	; Send the message
	MOVL	R5,R0			; Address of CDRP
	JMP	G^EXE$DEANONPAGED	; Deallocate it

30$:	RSB

	; Action routine to build the blocking message.  Inputs are:
	;	R2	Address of message buffer
	;	R5	Address of CDRP

BLD_BLKINGMSG:
	ASSUME	CLSMSG$B_FUNC  EQ  CLSMSG$B_FACILITY+1
	MOVW	#LKMSG$K_BLKING@8-	; Store function and facility codes
		!CLSMSG$K_FAC_LCK,CLSMSG$B_FACILITY(R2)
	MOVQ	CDRP$L_VAL1(R5),-	; Store master and process lockids
		LKMSG$L_MSTLKID(R2)
	MOVW	CDRP$L_VAL3(R5),-	; Store membership seq. num.
		LKMSG$W_MEMSEQ(R2)
	MOVB	CDRP$L_VAL3+2(R5),-	; Copy granted mode of lock
		LKMSG$B_GRMODE(R2)
	RSB

	.DSABL	LSB

	.SBTTL	LCK$RCV_BLKING - Receive a blocking message

;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine handles receiving a blocking AST message from
;	the master system.  This system is the process system.
;
; CALLING SEQUENCE:
;
;	JSB	LCK$RCV_BLKING (called by SCS received message routine)
;	IPL must be at IPL$_SYNCH
;
; INPUT PARAMETERS:
;
;	R2	Address of message buffer
;	R3	Address of CSB
;
; OUPUT PARAMETERS:
;
;	None
;
; SIDE EFFECTS:
;
;	R0 - R5 destroyed
;__

LCK$RCV_BLKING::

	.IF NE	CA$_MEASURE
	INCL	G^PMS$GL_BLK_IN
	.ENDC

	PUSHR	#^M<R2,R3,R6>
	ASSUME	LKMSG$L_PRCLKID  EQ  LKMSG$L_MSTLKID+4
	MOVQ	LKMSG$L_MSTLKID(R2),R0	; Get master and process lockids
	BSBW	VERIFYREMLKID		; Verify lockid and convert to LKB addr.
	BLBC	R0,80$			; Lock is gone - ignore message

	; Queue a blocking AST unless one has been queued before
	; (in which case we shouldn't have received the message; but
	; there are race conditions that will cause this to happen).
	; we will ignore that detail).  Also, state must be GRANTED
	; at the same lock mode to get a blocking AST.  It may not be 
	; if we are in the middle of a conversion, or have canceled a
	; conversion, for example.  Also, we have to handle the case
	; that this message came in before the process has been awakened to see
	; that the request was granted.

	DISPATCH	LKB$B_STATE(R6),TYPE=B,PREFIX=LKB$K_,-
		<-
		<GRANTED,50$>,-		; Handle normally
		<CONVERT,80$>,-		; Ignore message
		<WAITING,80$>,-		; Ignore message
		<RETRY,80$>,-		; Ignore message
		<SCSWAIT,80$>,-		; Ignore message
		<RSPQUEUED,80$>,-	; Ignore message
		<RSPNOTQED,30$>,-	; Set BLKASTQED bit
		<RSPGRANTD,40$>,-	; Set BLKASTQED bit
		>
	BUG_CHECK	LOCKMGRERR,FATAL; Invalid state

30$:	; Lock state is RSPNOTQED.

	CMPB	LKB$B_GRMODE(R6),-	; Verify granted modes are the same
		LKMSG$B_GRMODE(R2)
	BNEQ	80$			; They're not - ignore message
	BRB	45$

40$:	; Lock state is RSPGRANTD.

	CMPB	LKB$B_RQMODE(R6),-	; Verify requested mode (in lock)
		LKMSG$B_GRMODE(R2)	; is the same as granted mode (in msg)
	BNEQ	80$			; They're not - ignore message
45$:	BISW	#LKB$M_BLKASTQED,-	; Set BLKASTQED bit
		LKB$W_STATUS(R6)
	BRB	80$

50$:	; Lock state is GRANTED.

	CMPB	LKB$B_GRMODE(R6),-	; Verify granted modes are the same
		LKMSG$B_GRMODE(R2)
	BNEQ	80$			; They're not - ignore message
	BBS	#LKB$V_BLKASTQED,-	; Branch if a blocking ast has been 
		LKB$W_STATUS(R6),80$	; queued
	TSTL	LKB$L_BLKASTADR(R6)	; Verify there is a blocking AST routine
	BEQL	80$
	MOVL	R6,R5			; Move LKB address for subroutine call
	JSB	G^LCK$QUEUE_BLKAST	; Queue a blocking AST

80$:	; Deallocate message buffer and exit

	POPR	#^M<R2,R3,R6>
	BRW	CNX$DEALL_MSG_BUF_CSB	; Deallocate message buffer and return

	.SBTTL	LCK$SND_DEQ - Send dequeue message

;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine sends a dequeue lock message to a remote system.
;	This system is the process system and the remote system is the
;	master system.
;
; CALLING SEQUENCE:
;
;	JSB	LCK$SND_DEQGR	(Lock is in granted state)
;	JSB	LCK$SND_DEQCV	(Lock is in conversion wait state)
;	JSB	LCK$SND_DEQWT	(Lock is in waiting state)
;	IPL must be at IPL$_SYNCH
;
; INPUT PARAMETERS:
;
;	R3	Address of CSB (not CSID!)
;	R4	Dequeue flags
;	R5	Address of CDRP 
;	R6	Address of LKB
;	R7	Final completion status to store in LKB$L_LKST1 or 0
;		which indicates a default status should be used
;	R8	Address of RSB
;	R9	Address of value block (LCK$SND_DEQGR entry only)
;
; OUTPUT PARAMETERS:
;
;	None
;
; SIDE EFFECTS:
;
;	R0 - R5 destroyed
;--

	.ENABL	LSB

LCK$SND_DEQWT::
	; Lock is waiting

	BICW	#LCK$M_CANCEL-		; Clear cancel 
		!LCK$M_INVVALBLK,R4	; and invalidate valblk flags
	CLRL	R9			; Indicate no value block
	BRB	40$

LCK$SND_DEQCV::
	; The lock is on the conversion queue.

	BICW	#LCK$M_INVVALBLK,R4	; Clear invalidate valblk flag
	MOVB	LKB$B_GRMODE(R6),-	; Store granted mode in case
		CDRP$L_VAL3+3(R5)	; this is a CANCEL function
	CLRL	R9			; Indicate no value block
	BRB	40$

LCK$SND_DEQGR::
	; Lock is granted

	TSTL	R9			; Is there a value block?
	BEQL	40$			; No value block
	MOVQ	(R9)+,CDRP$L_VAL4(R5)	; Copy value block into CDRP
	MOVQ	(R9),CDRP$L_VAL6(R5)
	MOVL	#1,R9			; Set low byte non-zero

40$:	; Put additional information for message into CDRP.

	.IF NE	CA$_MEASURE
	INCL	G^PMS$GL_DEQ_OUT
	DECL	G^PMS$GL_DEQ_LOC	; Counter was incorrectly incremented
	.ENDC

	MOVB	R9,CDRP$L_VAL3+2(R5)	; Store value block flag
	MOVL	LKB$L_REMLKID(R6),-	; Store master lockid
		CDRP$L_VAL1(R5)
	MOVL	LKB$L_LKID(R6),-	; Store process lockid
		CDRP$L_VAL2(R5)
	MOVW	R4,CDRP$L_VAL3(R5)	; Store flags

	; Remove LKB from RSB and deallocate RSB, if necessary (don't
	; do this if we are only cancelling the lock).

	BBS	#LCK$V_CANCEL,R4,50$	; Branch if cancelling lock
	PUSHL	R5			; Save address of CDRP
	PUSHL	R3			; Save address of CSB
	REMQUE	LKB$L_SQFL(R6),R0	; Remove lock from RSB
	JSB	G^LCK$CHECK_RSB		; Check RSB and delete if necessary
	POPR	#^M<R3,R5>		; Restore registers

50$:	; Send the message

	MOVL	CSB$L_CLUB(R3),R0	; Get address of CLUB
	MOVW	CLUB$W_MEMSEQ(R0),-	; Store membership seq. num.
		CDRP$L_VAL8(R5)
	MOVAB	B^BLD_DEQMSG,-		; Address of message build routine
		CDRP$L_MSGBLD(R5)
	BSBW	CNX$SEND_MSG_CSB

	; Deallocate the CDRP.  This is done on success or failure
	; since the lock is gone from this system (or CANCELed back to it's
	; old mode) as far as failover is concerned.

	MOVL	R5,R0			; Address of CDRP
	JMP	G^EXE$DEANONPAGED

	.DSABL	LSB

BLD_DEQMSG:
	; Action routine to build the actual dequeue lock message
	; Inputs are:
	;	R2	Address of message buffer
	;	R5	Address of CDRP
	; All registers except R0 and R1 must be preserved

	ASSUME	LKMSG$L_PRCLKID  EQ  LKMSG$L_MSTLKID+4
	ASSUME	LKMSG$B_GRMODE  EQ  LKMSG$W_FLAGS+3
	ASSUME	CLSMSG$B_FUNC  EQ  CLSMSG$B_FACILITY+1

	MOVW	#LKMSG$K_DEQ@8-		; Store function and facility codes
		!CLSMSG$K_FAC_LCK,CLSMSG$B_FACILITY(R2)
	MOVW	CDRP$L_VAL8(R5),-	; Store membership seq. num.
		LKMSG$W_MEMSEQ(R2)
	MOVQ	CDRP$L_VAL1(R5),-	; Store process and master lockid
		LKMSG$L_MSTLKID(R2)
	MOVL	CDRP$L_VAL3(R5),-	; Store flags and granted mode
		LKMSG$W_FLAGS(R2)
	MOVZBL	CDRP$L_VAL3+2(R5),-	; Store value block flag
		LKMSG$L_VALBLKFLG(R2)
	BEQL	30$			; No value block
	MOVQ	CDRP$L_VAL4(R5),-	; Store value block
		LKMSG$Q_VALBLK(R2)
	MOVQ	CDRP$L_VAL6(R5),-
		LKMSG$Q_VALBLK+8(R2)
30$:	RSB

	.SBTTL	LCK$RCV_DEQ - Receive a dequeue lock message

;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine dequeues a lock on our system (the master) upon
;	receiving a message from the process system.
;
; CALLING SEQUENCE:
;
;	JSB	LCK$RCV_DEQ (called by the SCS received message routine)
;	IPL must be at IPL$_SYNCH
;
; INPUT PARAMETERS:
;	
;	R2	Address of message buffer
;	R3	Address of CSB
;
; OUTPUT PARAMETERS:
;
;	None
;
; SIDE EFFECTS:
;
;	R0 - R5 destroyed
;--

LCK$RCV_DEQ::
	.IF NE	CA$_MEASURE
	INCL	G^PMS$GL_DEQ_IN
	.ENDC

	PUSHR	#^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	MOVL	LKMSG$L_MSTLKID(R2),R1	; Get master lockid
	MOVL	LKMSG$L_PRCLKID(R2),R0	; Get process lockid (for verify)
	BSBW	VERIFYREMLKID		; Convert to LKB address
	BLBC	R0,80$			; Invalid lock id
	BBCC	#LKB$V_TIMOUTQ,-	; Is lock on timeout queue?
		LKB$W_STATUS(R6),5$
	REMQUE	LKB$L_ASTQFL(R6),R0	; Yes, remove it
5$:	MOVL	LKMSG$L_VALBLKFLG(R2),R9; Is there a value block?
	BEQL	10$			; No
	MOVAB	LKMSG$Q_VALBLK(R2),R9	; Yes, set address of value block
10$:	MOVZWL	LKMSG$W_FLAGS(R2),R4	; Get user flags
	JSB	G^LCK$DEQLOCK		; Dequeue the lock
	BLBC	R0,60$			; Error
20$:	POPR	#^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	BRW	CNX$DEALL_MSG_BUF_CSB	; Deallocate message buffer and return
	
60$:	; The dequeue failed.  The only failure allowed is SS$_CANCELGRANT
	; which can occur if the process copy was dequeued while in
	; the conversion queue while at the same time the master copied
	; was granted.  In this case we have to regrant the master copy
	; at the old mode to make it consistent with the process copy.

	CMPW	R0,#SS$_CANCELGRANT	; Is it this race condition?
	BNEQ	90$			; No - must be SS$_SUBLOCKS
	MOVL	LKB$L_RSB(R6),R8	; Get address of RSB
	REMQUE	LKB$L_SQFL(R6),R0	; Remove lock from granted queue
	TSTL	LKB$L_BLKASTADR(R6)	; Is there an old blocking AST flag?
	BEQL	65$			; No
	DECW	RSB$W_BLKASTCNT(R8)	; Yes, adjust count
65$:	MOVL	LKMSG$L_BLKASTFLG(R2),-	; Store new blocking AST flag
		LKB$L_BLKASTADR(R6)
	MOVZBL	LKMSG$B_GRMODE(R2),R1	; Get old granted mode 
	JSB	G^LCK$COMP_GGMODE	; Compute a new group grant mode in R5
	MOVB	R5,RSB$B_GGMODE(R8)	; Store it
	MOVB	R5,RSB$B_CGMODE(R8)
	JSB	G^LCK$GRANT_LOCK	; Grant the lock
	JSB	G^LCK$GRANTCVTS		; Grant any waiters
	BRB	20$


80$:	BUG_CHECK	INVLOCKID,FATAL	; Invalid lock id

90$:	BUG_CHECK	LOCKMGRERR,FATAL; Dequeue failed

	.SBTTL	LCK$SND_RMVDIR - Send remove directory entry message

;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine sends a message to the directory system specifying
;	that a root resource directory entry be removed.  This routine
;	is called when the last lock is dequeued from a root resource that
;	is being managed by this system and this system is not the 
;	directory system for this resource (RSB$M_DIRENTRY is clear)
;
; CALLING SEQUENCE:
;
;	JSB	LCK$SND_RMVDIR
;	IPL must be at IPL$_SYNCH
;
; INPUT PARAMETERS:
;
;	R8	Address of RSB
;
; OUTPUT PARAMETERS:
;
;	None
;
; SIDE EFFECTS:
;
;	R0 - R5 destroyed
;--

LCK$SND_RMVDIR::
	; Compute CSID of directory system

	MOVL	G^LCK$GL_DIRVEC,R3	; Get address of directory vector
	MOVZWL	RSB$W_HASHVAL(R8),R1	; Get hash value
	CLRL	R2			; Clear high order hash value
	EDIV	-12(R3),R1,R0,R1	; Compute hash index (in R1)
	MOVL	(R3)[R1],R3		; Get directory system
	BEQL	70$			; Error

	BSBW	CNX$ALLOC_CDRP		; Alloc. a CDRP and convert CSID to CSB
	BLBC	R0,80$			; No memory or CSID error
	MOVL	R8,CDRP$L_VAL1(R5)	; Store RSB address in CDRP
	MOVL	CSB$L_CLUB(R3),R0	; Get address of CLUB
	MOVW	CLUB$W_MEMSEQ(R0),-	; Store membership seq. num.
		CDRP$L_VAL3(R5)
	MOVAB	B^BLD_RMVDIRMSG,-	; Store address of message build routine
		CDRP$L_MSGBLD(R5)

	.IF NE	CA$_MEASURE
	INCL	G^PMS$GL_DIR_OUT
	.ENDC

	BSBW	CNX$SEND_MSG_CSB	; Send the message
	MOVL	CDRP$L_VAL1(R5),R0	; Get address of RSB
	JSB	G^EXE$DEANONPAGED	; Deallocate it
	MOVL	R5,R0			; Get address of CDRP
	JMP	G^EXE$DEANONPAGED	; Deallocate it

70$:	; We are the directory system for this resource, yet RSB$M_DIRENTRY
	; is not set.  See comment under RELOOKUP for a description of
	; a race condition that is similar to what may have caused this.

	BUG_CHECK	LOCKMGRERR,FATAL

80$:	; No CDRP to allocate or CSID conversion error.  If insufficient
	; memory, then place the RSB on the timeout queue.  Since we
	; normally place LKBs on the timeout queue, we need to verify
	; that the fields we use in the RSB are not needed.  Hence,
	; the following ASSUME statements.

	ASSUME	RSB$L_HSHCHN  EQ  LKB$L_ASTQFL
	ASSUME	RSB$L_CVTQFL  EQ  LKB$L_DUETIME
	ASSUME	RSB$Q_VALBLK+2  EQ  LKB$W_STATUS

	MOVL	R8,R4			; Move RSB address
	BRW	INSERT_ON_TIMOUTQ

	; Action routine to build the actual remove directory
	; entry message.
	; Inputs are:
	;	R2	Address of message buffer
	;	R5	Address of CDRP
	; All registers except R0 and R1 must be preserved

	ASSUME  LKMSG$B_RMOD  EQ  LKMSG$W_GROUP+2
	ASSUME	LKMSG$B_RSNLEN  EQ  LKMSG$B_RMOD+1
	ASSUME	LKMSG$T_RESNAM  EQ  LKMSG$B_RSNLEN+1
	ASSUME  RSB$B_RMOD  EQ  RSB$W_GROUP+2
	ASSUME	RSB$B_RSNLEN  EQ  RSB$B_RMOD+1
	ASSUME	RSB$T_RESNAM  EQ  RSB$B_RSNLEN+1

BLD_RMVDIRMSG:
	PUSHR	#^M<R2,R3,R4,R5>
	ASSUME	CLSMSG$B_FUNC  EQ  CLSMSG$B_FACILITY+1
	MOVW	#LKMSG$K_RMVDIR@8-	; Store function and facility codes
		!CLSMSG$K_FAC_LCK,CLSMSG$B_FACILITY(R2)
	MOVW	CDRP$L_VAL3(R5),-	; Store membership seq. num.
		LKMSG$W_MEMSEQ(R2)
	MOVL	CDRP$L_VAL1(R5),R1	; Get address of RSB
	MOVW	RSB$W_HASHVAL(R1),-	; Store hash value
		LKMSG$W_HASHVAL(R2)
	MOVZBL	RSB$B_RSNLEN(R1),R0	; Get length of resource name
	ADDL	#4,R0			; Account for group, access mode, etc.
	MOVC3	R0,RSB$W_GROUP(R1),-	; Move group no., resource name, etc.
		LKMSG$W_GROUP(R2)	; inot message buffer
	POPR	#^M<R2,R3,R4,R5>
	RSB

	.SBTTL	LCK$RCV_RMVDIR - Receive remove directory entry message

;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine handles receiving a remove directory entry message.
;	This system must be the directory system for this resource.
;	The specified root resource is located in the resource hash table
;	and if all of its queues are empty, then the resource is deallocated.
;	If the wait queue has locks on it, then these must represent
;	requests from this system being sent to the system that formerly
;	managed this resource (the system that sent us this message).  In
;	this case the resource is not deallocated.  Instead, the RSB$L_CSID
;	field is cleared and we master the resource.  Clearing the field
;	must be done now instead of when our lock messages are returned
;	with the response "do locally".  Otherwise there is a race if the
;	remote system follows the RMVDIR message with a directory lookup
;	lock request.  We will then erroneously tell the other system to
;	do it locally while the other system is telling us the same thing.
;	Another race condition occurs if this message is delayed on the
;	sending side dur to insufficient pool.  In that case, it is
;	possible for us to receive a do locally lock response before
;	receiving this message.  That is why we tolerate the RSB$L_CSID
;	field being zero if we it doesn't match the remote system's CSID.
;
; CALLING SEQUENCE:
;
;	JSB	LCK$RCV_RMVDIR (called by the SCS received message routine)
;	IPL must be at IPL$_SYNCH
;
; INPUT PARAMETERS:
;
;	R2	Address of message buffer
;	R3	Address of CSB
;
; OUTPUT PARAMETERS:
;
;	None
;
; SIDE EFFECTS:
;
;	R0 - R5 destroyed
;--

LCK$RCV_RMVDIR::
	.IF NE	CA$_MEASURE
	INCL	G^PMS$GL_DIR_IN
	.ENDC

	PUSHR	#^M<R2,R3,R8,R10,R11>
	MOVAB	LKMSG$L_PARMSTLKID(R2),R4 ; Set start of resource description
	CLRL	(R4)			; Clear parent lock id
	MOVZBL	LKMSG$B_RSNLEN(R2),R10	; Get length of resource name
	ADDL	#8,R10			; Account for extra fields to match
	MOVZWL	LKMSG$W_HASHVAL(R2),R1	; Get hash value
	JSB	G^LCK$SRCH_HSHTBL	; Search hash table for resource
	BLBS	R0,80$			; Resource not found

	; Resource was been located, R5 points to RSB.  Verify it is a
	; directory entry mastered by other system.  Then verify all queues
	; are empty.  If granted or conversion queues are not empty then
	; we are in serious trouble.   It's okay if wait queue is not empty, 
	; as this represents the race condition described above.

	ASSUME	RSB$L_CVTQFL  EQ  RSB$L_GRQFL+8
	ASSUME	RSB$L_WTQFL  EQ  RSB$L_CVTQFL+8
	ASSUME	RSB$M_DIRENTRY  EQ  1

	MOVL	R5,R8			; Move address of RSB
	BLBC	RSB$W_STATUS(R8),80$	; Verify directory entry bit is set
	MOVL	4(SP),R3		; Get address of CSB
	CMPL	CSB$L_CSID(R3),-	; Verify sending system is 
		RSB$L_CSID(R8)		; mastering resource
	BEQL	20$			; It is
	TSTL	RSB$L_CSID(R8)		; It's not, but it's ok if this system
	BEQL	40$			; is mastering the resource
	BNEQ	80$			; Error
20$:	MOVAL	RSB$L_GRQFL(R8),R0	; Get address of granted queue
	CMPL	(R0),R0			; Is granted queue empty?
	BNEQ	80$			; No
	ADDL	#8,R0			; Yes, get address of conversion queue
	CMPL	(R0),R0			; Is conversion queue empty?
	BNEQ	80$			; No
	ADDL	#8,R0			; Yes, get address of wait queue
	CMPL	(R0),R0			; Is wait queue empty?
	BEQL	30$			; Yes
	CLRL	RSB$L_CSID(R8)		; No, we master resource
	BRB	40$

30$:	; All queues are empty and checks verified.  Deallocate RSB

	CLRL	RSB$L_CSID(R8)		; Do this so that LCK$DEALLOC_RSB
					; really deallocates it
	JSB	G^LCK$DEALLOC_RSB	; Deallocate it

40$:	POPR	#^M<R2,R3,R8,R10,R11>
	BRW	CNX$DEALL_MSG_BUF_CSB	; Deallocate message buffer and return


80$:	; One of the following bugs:
	;	Resource not found (R5 = 0)
	;	Not marked as a directory entry (RSB$M_DIRENTRY not set)
	;	Not mastered by sending system (RSB$L_CSID not equal CSB$L_CSID 
	;	and also not zero)
	;	Conversion or granted queue not empty (check queues)

	BUG_CHECK	LOCKMGRERR,FATAL

	.SBTTL	VERIFYREMLKID - Verify remote lock id

;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine verifies a lock id sent by another system
;	and converts it into a LKB address.
;
; CALLING SEQUENCE:
;
;	BSBW	VERIFYREMLKID
;	IPL must be at IPL$_SYNCH
;
; INPUT PARAMETERS:
;
;	R0	Lock id on remote system
;	R1	Lock id on this system
;
; OUTPUT PARAMETERS:
;
;	R0	Completion code
;	R6	Address of LKB
;
; COMPLETION CODES:
;
;	SS$_NORMAL	Lock id was valid can converted to LKB address
;	SS$_IVLOCKID	Invalid lock id
;
; SIDE EFFECTS:
;
;	R4 is destroyed
;
; NOTE:
;
;	This routine does two consistency checks.  The first is that
;	it verifies the lock id is valid via the sequence number check.
;	If the lock id fails this check, then an error is returned to
;	the caller as this is allowed in some cases and is fatal in others.
;	However, if the lock id passes this check, then another check
;	is made that compares the remote lock id as sent by the remote
;	system with the remote lock id stored here in the LKB.  If this
;	check fails then it is immediately fatal as the first check should
;	catch all races that cause lock ids to not match across systems.
;	Also note that this second check is not perfect in that it should
;	also check CSB addresses.  This is considered unnecessary as the
;	additional protection that check offers is small.
;--

VERIFYREMLKID:
	MOVZWL	R1,R6			; Put lockid index in R6
	CMPL	R6,G^LCK$GL_MAXID	; Is the lock id too big?
	BGTRU	40$			; Yes
	MOVL	G^LCK$GL_IDTBL,R4	; *** May combine with next instr.
	MOVL	(R4)[R6],R6		; Get LKB address
	BGEQ	40$			; Unallocated id
	CMPL	R1,LKB$L_LKID(R6)	; Check sequence number
	BNEQ	40$			; Not valid
	CMPL	R0,LKB$L_REMLKID(R6)	; Check remote lock id
	BNEQ	50$			; Doesn't match
	MOVZWL	S^#SS$_NORMAL,R0	; Success
	RSB

40$:	MOVZWL	#SS$_IVLOCKID,R0	; Invalid lock id
	RSB

50$:	BUG_CHECK	INVLOCKID,FATAL; Invalid remote lockid




	.END

