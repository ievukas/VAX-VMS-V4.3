	.TITLE	OPDRIVER - VAX/VMS CONSOLE TERMINAL DRIVER
	.IDENT	'V04-000'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
;++
; FACILITY:
;
;	VAX/VMS I/O SUBSYSTEM
;
; ABSTRACT:
;
;
; AUTHOR: Trudy Matthews, Benn Schreiber
;
; MODIFIED BY:
;	V03-015	WHM0001		Bill Matthews		09-Jul-1984
;		Add routines CON$PUTCHAR and CON$GETCHAR to do non-interrupt
;		driven I/O to the console terminal.
;
;	V03-014	TCM0003		Trudy C. Matthews	22-Feb-1984
;		Add routine CON$RELEASECTY which is the complement of
;		CON$OWNCTY; it should be used to relinquish exclusive
;		use of the console terminal.
;
;	V03-013	TCM0002		Trudy C. Matthews	13-Dec-1983
;		Modify interface to CON$OWNCTY: it now returns the values
;		that should be restored to TXCS and RXCS when the caller
;		is done with "exclusive" use of the console terminal.
;
;	V03-012	MIR2070		Michael I. Rosenblum		04-Aug-1983
;		Make reference to OPA$VECTOR general addressing mode
;
;	V03-011	MIR1070		Michael I. Rosenblum		03-Aug-1983
;		Add definitions for $DPTDEF.
;
;	V03-010	MIR0070		Michael I. Rosenblum		13-Jul-1983
;		Remove code that was STOP2 related (the entry is obsolete)
;		Change code to use the CLASS_UNIT_INIT macro.
;
;	V03-009	TCM0004		Trudy C. Matthews		21-Feb-1983
;		Add CON$OWNCTY routine.
;
;	V03-008	MIR0027		Michael I. Rosenblum		11-Feb-1983
;		Fix bug in new power fail code.
;
;	V03-007	MIR0022		Michael I. Rosenblum		19-Jan-1982
;		Remove reverences to UCB$Q_TT_STATE and move them into
;		the class driver jacket routines, to iliminate redundency
;		in the port driver code.
;
;	V03-006	MIR0017		Michael I. Rosenblum		05-Jan-1982
;		Add to unit-init routine a call back to the class driver
;		on powerfail.  This will allow the termial driver to take
;		postive action on a powerfail.
;
;	V03-005	MIR0016			Michael I. Rosenblum	04-Jan-1982
;		Change code to reflect the new port driver interface.
;		See DZDRIVER for detailed description of changes.
;
;	V03-004	TCM0003			Trudy C. Matthews	30-Dec-1982
;		Fix bug in CON$SENDCONSCMD that didn't set the select field
;		properly before sending the command to the console.
;
;	V03-003	TCM0002			Trudy C. Matthews	16-Dec-1982
;		Document extra input registers to CON$SENDCONSCMD (currently
;		the extra inputs registers are only used in the 11/790
;		version of CON$SENDCONSCMD).
;
;	V03-002	TCM0001			Trudy C. Matthews	10-Nov-1982
;		Change CON$SENDCONSCMD to accept SRM-defined values as
;		function codes.
;
;	V03-001	KTA3018			Kerbey T. Altmann	30-Oct-1982
;		Change psect name
;
;-

;
; SYMBOL DEFINITIONS
;
 
	$CRBDEF				; DEFINE CRB
	$CONDEF				; DEFINE CONSOLE FUNCTION CODES
	$DCDEF				; DEFINE DEVICE CLASSES
	$DDBDEF				; DEFINE DDB
	$DEVDEF				; DEFINE DEVICE CHARACTERISTICS
	$DPTDEF				; DEFINE DPT
	$DYNDEF				; STRUCTURE TYPE CODE DEFINITIONS
	$IDBDEF				; DEFINE IDB
	$IPLDEF				; DEFINE IPL LEVELS
	$IRPDEF				; DEFINE IRP OFFSETS
	$PRDEF				; DEFINE PROCESSOR REGISTERS
	$TTDEF				; DEFINE TERMINAL CHARACTERISTICS
	$UCBDEF				; DEFINE UCB
	$TTYDEFS			; TTY UCB extension (must FOLLOW $UCBDEF)
	$TTYMACS			; TTY macro definitions
	$VECDEF				; DEFINE CRB VECTOR
	$WCBDEF				; Define WCB


;
; OUTPUT INTERRUPT QUEUE
;
 
	.PSECT	SYSLOA,LONG

CURR:	.BYTE	-1			;CURRENT UNIT EXPECTING OUTPUT DONE
NEXT:	.BYTE	-1			;NEXT UNIT TO OUTPUT
DATA:	.BLKW	1			;NEXT DATA TO OUTPUT

	.SBTTL	CONSOLE CONTROLLER INITIALIZATION
;++
; CON$INITIAL - INITIALIZE CONSOLE CONTROLLER
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS USED AT SYSTEM STARTUP TO INITIALIZE THE CONSOLE CONTROLLER.
;
; INPUTS:
;
;	R5 = UCB ADDRESS
;	R9 = CRB ADDRESS
;
; OUTPUTS:
;
;	ALL REGISTERS ARE PRESERVED.
;--
CON$INITIAL::				; INITIALIZE CONSOLE INTERFACE
	MTPR	#^X040,#PR$_RXCS	; ENABLE INPUT INTERRUPTS
	MTPR	#^X040,#PR$_TXCS	; ENABLE OUTPUT INTERRUPTS
	MNEGW	#1,CURR			; SET NO UNITS WAITING FOR OUTPUT
	RSB

	.SBTTL	CONSOLE UNIT INITIALIZATION
;++
; CON$INITIAL - INITIALIZE CONSOLE UNIT
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS USED AT SYSTEM STARTUP TO INITIALIZE THE CONSOLE UNITS.
;
; INPUTS:
;
;	R5 = UCB ADDRESS
;	R9 = CRB ADDRESS
;
; OUTPUTS:
;
;	ALL REGISTERS ARE PRESERVED.
;--
CON$INITLINE::
	BBC	#DEV$V_TRM,UCB$L_DEVCHAR(R5),CON$NULL; BR IF NOT TERMINAL
	PUSHL	R0			; SAVE R0
	MOVAL	G^OPA$VECTOR,R0		; GET THE VECTOR ADDRESS
	CLASS_UNIT_INIT			; AND INIT THIS UNIT
	MOVL	UCB$L_TT_CLASS(R5),R0	; ADDRESS OF CLASS VECTOR TABLE
	JSB	@CLASS_SETUP_UCB(R0)	; INITIALIZE THE UCB FOR CONSOLE TERMINAL
30$:	BBC	#UCB$V_POWER,UCB$W_STS(R5),40$; DID WE DETECT A POWER FAIL
	MOVL	UCB$L_TT_CLASS(R5),R0	; GET THE CLASS VECTOR TABLE ADDRESS
	JSB	@CLASS_POWERFAIL(R0)	; AND GOTO THE POWERFAIL CODE

40$:	POPL	R0			; RESTORE R0

CON$DISCONNECT::
CON$INIT_CTY::
CON$SET_LINE::
CON$DS_SET::
CON$SET_MODEM::
CON$NULL:: 				; NULL ENTRY FOR CONSOLE TERMINAL DISCONNECT
	RSB				;

	.SBTTL CONSOLE RECIEVER INTERRUPT DISPATCHER
;++
; CON$INTINP - CONSOLE INTERRUPT ON INPUT READY
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS ENTERED AS A RESULT OF A RECEIVER INTERRUPT ON THE
; CONSOLE INTERFACE. THE INTERRUPT CAN BE GENERATED BY THE CONSOLE
; TERMINAL OR FLOPPY DRIVE.
;
; CONSOLE TERMINAL:	ALL RECEIVED DATA CHARACTERS ARE CONSIDERED
;			UNSOLICITED AND RESULT IN AN ENTRY INTO THE
;			TERMINAL DRIVER COMMON CHARACTER BUFFERING
;			ROUTINE "@UCB$L_TT_PUTNXT(R5)".
;
; CONSOLE FLOPPY:	RECEIVER INTERRUPTS FROM THE CONSOLE FLOPPY
;			MUST BE EXPECTED (UCB$V_INT = 1). IF THE 
;			INTERRUPT IS EXPECTED THEN UCB$V_INTTYPE IS SET
;			IN UCB$W_STS TO SIGNAL A RECEIVER INTERRUPT.
;			THE DRIVER IS THEN ENTERED AT ITS WAIT FOR INTERRUPT
;			CONTEXT PC.
;
; INPUTS:
;
;	R0,R1,R2,R3,R4,R5 ARE SAVED ON THE INTERRUPT STACK.
;
;	00(SP) = ADDRESS OF THE IDB
;
; OUTPUTS:
;
;	THE SAVED REGISTERS ARE RESTORED BEFORE REI.
;--
CON$INTINP::
	MFPR	#PR$_RXDB,R3		; MOVE DATA FROM INTERFACE
;
; GET THE ASSOCIATED UCB
;
	MOVL	@(SP)+,R4		; GET IDB ADDRESS
	ASHL	#-8,R3,R2		; GET LINE NUMBER
	BICW	#^C<3>,R2		;
	CMPW	R2,IDB$W_UNITS(R4)	; LEGAL UNIT NUMBER?
	BGEQU	30$			; DISMISS INTERRUPT
5$:	MOVL	IDB$L_UCBLST(R4)[R2],R5	; GET THE UCB ADDRESS
	BEQL	30$			; NO UCB - DISMISS INTERRUPT
	BISW	#UCB$M_INTTYPE,UCB$W_STS(R5); SET RECEIVER INTERRUPT
	BBS	#DEV$V_TRM,-		; ENTER FLOPPY INTERRUPT CODE
		UCB$L_DEVCHAR(R5),10$
	BRW	FLOPINT			; IF NOT TERMINAL UCB
;
; CONSOLE TERMINAL INTERRUPT
;
10$:	MOVZBL	R3,R3			; ZERO TOP 3 BYTES
	JSB	@UCB$L_TT_PUTNXT(R5)	; BUFFER THE CHARACTER
	BEQL	30$			; IF EQL THEN NO CHARACTER TO OUTPUT
20$:	BSBB	CON$STARTIO		; OUTPUT THE CHARACTER
30$:	BRW	DISMIS			; GO

	.SBTTL	START I/O ON CONSOLE INTERFACE
;++
; CON$STARTIO - START I/O ON CONSOLE INTERFACE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS ENTERED TO OUTPUT A CHARACTER TO THE CONSOLE INTERFACE.
; IF THE INTERFACE IS READY THE DATA IS OUTPUT DIRECTLY. IF THE INTERFACE
; IS NOT READY THEN THE DATA IS QUEUED AND SUBSEQUENTLY OUTPUT ON THE
; NEXT READY INTERRUPT.
;
; IN EITHER CASE, A RETURN TO THE CALLER IS DONE TO ENTER A "WAIT FOR
; INTERRUPT" STATE.
;
; INPUTS:
;
;	R3 = DATA TO OUTPUT
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R3,R4,R5 ARE PRESERVED.
;--

.ENABLE LSB

CON$STARTIO::				;

	BBC	#DEV$V_TRM,UCB$L_DEVCHAR(R5),5$	; BRANCH IF FLOPPY
	BLSS	20$				; BRANCH IF BURST MODE
;
; INSERT UNIT NUMBER IN DATA WORD
;
5$:
CON$STARTIO1:
	MOVZBL	UCB$W_UNIT(R5),R2	; PICK UP UNIT NUMBER
	INSV	R2,#8,#2,R3		; INSERT UNIT NUMBER AND CLEAR OTHER BITS
;
; INITIATE I/O IF NO PREVIOUS UNIT WAITING
;
	TSTB	CURR			; OTHER UNIT WAITING?
	BLSS	10$			; IF LSS NO, OUTPUT DATA AND RETURN
	MOVB	R2,NEXT			; SAVE UNIT NUMBER
	MOVW	R3,DATA			; SAVE DATA
	RSB				; EXIT
10$:					;
	MOVB	R2,CURR			; SAVE UNIT NUMBER OF CURRENT SENDER
	MTPR	R3,#PR$_TXDB		; SEND DATA
	RSB

20$:	BISW	#TTY$M_TANK_BURST,-
		UCB$W_TT_HOLD(R5)	; SET BURST MODE
;
; TAKE CHARACTER OUT OF BURST BUFFER AND TRY TO OUTPUT IT IMMEDIATELY
;
	MOVZBL	@UCB$L_TT_OUTADR(R5),R3	; OUTPUT NEXT BYTE
	INCL	UCB$L_TT_OUTADR(R5)	; UPDATE POINTER
	DECW	UCB$W_TT_OUTLEN(R5)	; UPDATE COUNT
	BNEQ	5$			; NOT LAST CHARACTER
	BICW	#TTY$M_TANK_BURST,-	; RESET BURST ACTIVE
		UCB$W_TT_HOLD(R5)
	BRB	5$

.DISABLE	LSB


	.SBTTL	CONSOLE TRANSMITTER INTERRUPT SERVICE
;++
; CON$INTOUT - CONSOLE TRANSMITTER INTERRUPT SERVICE
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS ENTERED WHEN A CONSOLE UNIT READY INTERRUPT OCCURS.
;
; A SEARCH IS MADE OF THE COLD STORAGE BUFFER FOR DATA TO OUTPUT.
; IF ANY IS FOUND THEN IT IS OUTPUT. IF NO VALID DATA IS FOUND THEN
; THE INTERRUPT STATE OF THE UNIT IS CHECKED FOR EXPECTED INTERRUPT.
; IF NO INTERRUPT IS EXPECTED, THE INTERRUPT IS DISMISSED. IF AN INTERRUPT
; IS EXPECTED THEN THE DRIVER IS ENTERED. IN THE CASE OF THE CONSOLE TERMINAL,
; A SPECIFIC ROUTINE IS ENTERED TO GET THE NEXT CHARACTER AVAILABLE TO OUTPUT
; ON THE UNIT. IN THE CASE OF THE CONSOLE FLOPPY, THE WAIT FOR INTERRUPT
; CONTEXT IS TAKEN FROM THE UCB AND THE SPECIFIED ROUTINE IS ENTERED.
;
; INPUTS:
;
;	R0,R1,R2,R3,R4,R5 ARE SAVED ON THE INTERRUPT STACK.
;
;	00(SP) = ADDRESS OF THE IDB
;
; OUTPUTS:
;
;	THE SAVED REGISTERS ARE RESTORED BEFORE REI.
;--
CON$INTOUT::				;
	MOVL	@(SP)+,R4		; GET ADDRESS OF IDB
	CVTBL	NEXT,R2			; GET UNIT NUMBER OF NEXT SENDER
	BLSS	10$			; IF LSS NO SENDER WAITING
	MNEGB	#1,NEXT			; RESET SENDER-WAITNG
	MOVZWL	DATA,R3			; GET DATA TO SEND
	MTPR	R3,#PR$_TXDB		; TRANSMIT DATA
10$:					;
	MOVZBL	CURR,R3			; GET UNIT NUMBER OF CURRENT SENDER
	MOVB	R2,CURR			; SET UNIT NUMBER OF NEXT CURRENT
	TSTB	R3			; SPURIOUS INTERRUPT?
	BLSS	DISMIS			; IF LSS YES
	MOVL	IDB$L_UCBLST(R4)[R3],R5	; GET ADDRESS OF UCB
	BBCC	#UCB$V_INTTYPE,UCB$W_STS(R5),FLOPINT ; SET OUTPUT INTERRUPT
FLOPINT:				;
	BBS	#DEV$V_TRM,UCB$L_DEVCHAR(R5),20$ ; IF BIT CLEAR, UNIT = FLOPPY
	BBCC	#UCB$V_TIM,UCB$W_STS(R5),10$ 	 ; CLEAR TIMEOUT PENDING
10$:	BBCC	#UCB$V_INT,UCB$W_STS(R5),DISMIS  ; EXIT IF NOT WAITING FOR INTERRUPT
;
; DEVICE IS A FLOPPY
;
	MOVL	UCB$L_FR4(R5),R4	; RESTORE R4 CONTEXT
	JSB	@UCB$L_FPC(R5)		; ENTER FLOPPY INTERRUPT HANDLER
	BRB	DISMIS
;
; DEVICE IS A TERMINAL 
;
20$:	BSBB	TERMINALIO

DISMIS:					;
	MOVQ	(SP)+,R0		; RESTORE REGISTERS
	MOVQ	(SP)+,R2		;
	MOVQ	(SP)+,R4		;
	REI				;
.PAGE
TERMINALIO:
;
;	CHECK FOR BURST ACTIVE ON LINE
;
	CMPB	#TTY$M_TANK_BURST@-8,-	; ONLY BURST ACTIVE?
		UCB$W_TT_HOLD+1(R5)
	BEQL	BURST			; YES, CONTINUE BURST
;
;	LOOK FOR NEXT OUTPUT STATE IN TANK
;

	FFS	#0,#6,UCB$W_TT_HOLD+1(R5),R3
	CASE	R3,TYPE=B,<-		; DISPATCH
		PREMPT,-		; send prempt character
		STOP,-			; STOP OUTPUT
		BURST,-			; BURST IN PROGRESS
		>
;
; NO PENDING DATA - LOOK FOR NEXT CHARACTER
;
	BICB	#UCB$M_TIM!UCB$M_INT,UCB$W_STS(R5); CLEAR TIMEOUT AND EXPECTED
;
; CALL TERMINAL DRIVER ROUTINE
;
	JSB	@UCB$L_TT_GETNXT(R5)	; GET THE NEXT CHARACTER
	BLSS	START_BURST		; BURST SPECIFIED
	BEQL	EXIT			; NONE
	BSBW	CON$STARTIO1		; INITIATE I/O
	BRB	EXIT_INT		; EXIT WITH INTERRUPT EXPECTED

START_BURST:
	BISW	#TTY$M_TANK_BURST,-	; SIGNAL BURST ACTIVE
		UCB$W_TT_HOLD(R5)
BURST:
	MOVZBL	@UCB$L_TT_OUTADR(R5),R3	; SET NEXT OUTPUT CHARACTER
	INCL	UCB$L_TT_OUTADR(R5)	; UPDATE POINTER
	DECW	UCB$W_TT_OUTLEN(R5)	; UPDATE COUNT
	BNEQ	10$			; NOT LAST CHARACTER
	BICW	#TTY$M_TANK_BURST,-	; RESET BURST ACTIVE
		UCB$W_TT_HOLD(R5)

10$:	BSBW	CON$STARTIO1		; OUTPUT CHARACTER
	BRB	EXIT_INT		; EXIT WITH INTERRUPT EXPECTED

STOP:
	BICB	#UCB$M_INT!UCB$M_TIM,-
		UCB$W_STS(R5)		; RESET OUTPUT ACTIVE
	BRB	EXIT

	.ENABLE	LSB
PREMPT:
	BICW	#TTY$M_TANK_PREMPT,-	; RESET XOFF STATE
		UCB$W_TT_HOLD(R5)
	MOVZBL	UCB$B_TT_PREMPT(R5),R3	; SEND prempt character

	BSBW	CON$STARTIO1		; OUTPUT CHARACTER

EXIT_INT:
	BISB	#UCB$M_INT,UCB$W_STS(R5); SHOW OUTPUT ACTIVE
EXIT:
	RSB

	.DISABLE	LSB

.PAGE
.SBTTL	CONSOLE PORT ACTION ROUTINES
;++
; CON$XOFF -	SEND XOFF
; CON$XON -	SEND XON
; CON$STOP -	STOP OUTPUT
; CON$STOP2 -	ALTERNATE STOP
; CON$ABORT -	ABORT CURRENT OUTPUT
; CON$RESUME -	RESUME STOPPED OUTPUT
;
; FUNCTIONAL DESCRIPTION:
;
; THESE ROUTINES ARE USED BY THE THE TERMINAL CLASS DRIVER TO
; CONTROL OUTPUT ON THE PORT
;
; INPUTS:
;
;	R5 = UCB ADDRESS
;
; OUTPUTS:
;
;	R5 = UCB ADDRESS
;--
	.ENABLE	LSB

CON$XOFF::
CON$XON::
	BISW	#TTY$M_TANK_PREMPT,UCB$W_TT_HOLD(R5)	; SCHEDULE PREMPT
	MOVB	R3,UCB$B_TT_PREMPT(R5)			; SAVE PREMPT CHARCTER
	BBS	#UCB$V_INT,UCB$W_STS(R5),10$		; IF OUTPUT ACTIVE,

	PUSHR	#^M<R1,R2,R3,R4>			; SAVE REGISTERS
	BSBW	TERMINALIO				; START OUTPUT
	POPR	#^M<R1,R2,R3,R4>			; RESTORE REGISTERS
	BBSS	#UCB$V_INT,UCB$W_STS(R5),10$		; SHOW OUTPUT ACTIVE
10$:
	RSB
	.DISABLE	LSB

CON$STOP::
	BISW	#TTY$M_TANK_STOP,-			; SCHEDULE STOP
		UCB$W_TT_HOLD(R5)
	RSB

CON$ABORT::
	BBCC	#TTY$V_TANK_BURST,UCB$W_TT_HOLD(R5),-	; RESET BURST ACTIVE
		10$					; 
10$:
	TIMSET	1					; SETUP A TIMER
	RSB

CON$RESUME::
	PUSHL	R1					; SAVE A REGISTER
	BICW	#TTY$M_TANK_STOP-
		,UCB$W_TT_HOLD(R5)			; RESET STOP CONDITIONS
	BBC	#TTY$V_TANK_BURST,UCB$W_TT_HOLD(R5),40$	; BRANCH IF NO BURST IN PROGRESS

	MOVZWL	UCB$W_TT_OUTLEN(R5),R1			; NUMBER OF BURST CHARS
	TIMSET	R1,R1					; SET TIME OUT

30$:
	BBS	#UCB$V_INT,UCB$W_STS(R5),40$		; SKIP IF OUTPUT ON
	PUSHR	#^M<R1,R2,R3,R4>			; SAVE REGISTERS
	BSBW	TERMINALIO				; START I/O
	POPR	#^M<R1,R2,R3,R4>			; RESTORE REGISTERS
40$:
	POPL	R1
	RSB


	.SBTTL	SEND COMMAND TO CONSOLE

;++
; CON$SENDCONSCMD - SEND CPU-DEPENDENT COMMAND TO CONSOLE
;
; FUNCTIONAL DESCRIPTION:
;
;	INITIATE FUNCTION ON CONSOLE
;
; INPUTS:
;
;	R0 = CONSOLE FUNCTION TO PERFORM:
;		CON$C_BOOTCPU = SEND REBOOT SIGNAL TO CONSOLE AND THEN HALT
;		CON$C_CLRWARM = CLEAR CONSOLE WARMSTART FLAG
;		CON$C_CLRCOLD = CLEAR CONSOLE COLDSTART FLAG
;	R2 = NUMBER OF BYTES OF DATA TO BE RETURNED (= 0 IF NO DATA EXPECTED)
;		(CURRENTLY ONLY IMPLEMENTED IN 11/790 VERSION OF THIS ROUTINE)
;	R3 = ADDRESS OF BUFFER TO HOLD RETURNED DATA (ONLY IF R2 IS NON-ZERO)
;		(CURRENTLY IMPLEMENTED ONLY IN 11/790 VERSION OF THIS ROUTINE)
;
; OUTPUTS:
;
;	CONSOLE STATE MODIFIED
;	R1 DESTROYED
;--

CON$SENDCONSCMD::
	BISW	#^XF00,R0		; SELECT MISCELLANEOUS CONSOLE COMM.
10$:	MFPR	#PR$_TXCS,R1		; GET TRANSMITTER STATUS
	BBC	#7,R1,10$		; WAIT FOR CONSOLE READY
	CMPB	R0,#CON$C_BOOTCPU	; REBOOT CPU?
	BEQL	30$			; IF SO BRANCH TO HALT AFTER COMMAND
	MTPR	R0,#PR$_TXDB		; OTHERWISE ASSERT COMMAND
20$:	MFPR	#PR$_TXCS,R1		; GET TRANSMITTER STATUS
	BBC	#7,R1,20$		; WAIT FOR CONSOLE DONE
	RSB				; RETURN

30$:	MTPR	R0,#PR$_TXDB		; SEND REBOOT COMMAND TO CONSOLE
	HALT

	.SBTTL	"ALLOCATE" CONSOLE TERMINAL

;++
; CON$OWNCTY - "ALLOCATE" CONSOLE TERMINAL
;
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE SHOULD BE CALLED WHEN PERFORMING NON-INTERRUPT DRIVEN
;	I/O TO THE CONSOLE TERMINAL.  IT DISABLES INTERRUPTS AND DOES ANY
;	CPU-SPECIFIC INITIALIZATION OF THE CONSOLE TERMINAL REGISTERS.
;	CON$RELEASECTY SHOULD BE CALLED TO RESTORE THE STATE OF THE CONSOLE
;	TERMINAL INTERFACE REGISTERS.
;
; INPUTS:
;	NONE
;
; OUTPUTS:
;
;	R0:	VALUE TO BE RESTORED TO TXCS WHEN RELEASING CONSOLE TTY
;	R1:	VALUE TO BE RESTORED TO RXCS WHEN RELEASING CONSOLE TTY
;
;	PR$_RXCS AND PR$_TXCS ARE SET UP SO THAT NON-INTERRUPT I/O CAN BE
;	PERFORMED TO THE CONSOLE TERMINAL.
;
;	11/780, 11/750, AND 11/730:
;		CONSOLE INTERRUPTS ARE DISABLED
;
;	11/790:
;		CONSOLE TRANSMIT AND RECEIVE MASKS ARE SET UP SO THAT ONLY
;		I/O TO THE CONSOLE TERMINAL IS PERMITTED.  INTERRUPTS ARE
;		DISABLED.
;--
CON$OWNCTY::
	MFPR	#PR$_TXCS,R0		; GET VALUE TO BE RESTORED TO TXCS.
	MFPR	#PR$_RXCS,R1		; GET VALUE TO BE RESTORED TO RXCS.
	MTPR	#0,#PR$_RXCS		; DISABLE RECEIVE INTERRUPTS
	MTPR	#0,#PR$_TXCS		; DISABLE TRANSMIT INTERRUPTS
	RSB

	.SBTTL	RELEASE CONSOLE TERMINAL

;++
; CON$RELEASECTY - RELEASE CONSOLE TERMINAL
;
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE SHOULD BE CALLED TO RELINQUISH EXCLUSIVE USE OF THE
;	CONSOLE TERMINAL OBTAINED BY CALLING CON$OWNCTY.  IT RESTORES THE
;	STATE OF THE CONSOLE REGISTERS RXCS AND TXCS.
;
; INPUTS:
;	R0:	VALUE RETURNED BY CON$OWNCTY TO BE RESTORED TO TXCS
;	R1:	VALUE RETURNED BY CON$OWNCTY TO BE RESTORED TO RXCS
;
; OUTPUTS:
;	RXCS AND TXCS ARE RESTORED TO THEIR ORIGINAL STATE.
;
;--
CON$RELEASECTY::
	MTPR	R0,#PR$_TXCS		; RESTORE TXCS
	MTPR	R1,#PR$_RXCS		; RESTORE RXCS
	RSB
;++
; CON$GETCHAR - GET A CHARACTER FROM THE CONSOLE TERMINAL
;
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE SHOULD BE CALLED TO DO NON-INTERRUPT DRIVEN I/O
;	DIRECTLY TO THE CONSOLE TERMINAL
;
; INPUTS:
;	None
;
; OUTPUTS:
;	R0 contains the character.
;
;--
	control_s = 19			; control s (xoff)
	control_q = 17			; control q (xon)

CON$GETCHAR::
10$:	mfpr	#pr$_rxcs,r0		;receiver ready?
	bbc	#7,r0,10$		;if clr, receiver not ready
	mfpr	#pr$_rxdb,r0		;read input character
	rsb				;return
;++
; CON$PUTCHAR - PUT A CHARACTER TO THE CONSOLE TERMINAL
;
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE SHOULD BE CALLED TO DO NON-INTERRUPT DRIVEN I/O
;	DIRECTLY TO THE CONSOLE TERMINAL
;
; INPUTS:
;	R0 - Character to be output
;
; OUTPUTS:
;	Character written to the console terminal.
;
;--
CON$PUTCHAR::
	pushl	r1			;save a register
10$:	mfpr	#pr$_rxcs,r1		;receiver ready?
	bbc	#7,r1,30$		;if clr, receiver not ready
	mfpr	#pr$_rxdb,r1		;read input character.
	cmpzv	#0,#7,r1,#control_s	;control-s?
	bneq	30$			;if neq no
20$:	mfpr	#pr$_rxcs,r1		;receiver ready?
	bbc	#7,r1,20$		;if clr, receiver not ready
	mfpr	#pr$_rxdb,r1		;read input character
	cmpzv	#0,#7,r1,#control_q	;is it a control-q?
	bneq	20$			;no, wait for another character.
30$:	mfpr	#pr$_txcs,r1		;transmitter done?
	bbc	#7,r1,30$		;if clr, transmitter not done
	mtpr	r0,#pr$_txdb		;write output character
	popl	r1			;restore a register
	rsb				;return

CON_END:
	.END
