	.TITLE	TTYFDT - Terminal driver function decision routines
	.IDENT	'V04-001'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
;++
; FACILITY:
;
;	VAX/VMS TERMINAL DRIVER
;
; ABSTRACT: THIS MODULE CONTAINS THE FUNCTION DECISION ROUTINES FOR TERMINAL
; RELATED I/O FUNCTIONS.
;
;	NOTE:	THIS MODULE RUNS IN THE CONTEXT OF THE LOGICAL TERMINAL
;		UCB. IT MUST NOT REFERENCE ANY PHYSICAL FIELDS WITH OUT
;		USING AN INDIRECT REFERENCE THROUGH UCB$L_TL_PHYUCB. 
;		SEE THE GUIDELINES OUTLINED IN THIS MODULE.
;
; AUTHOR: R.HEINEN 23-SEPT-76 VERSION V06
;
; Revision history:
;
;	V04-001	MIR1100		Michael I. Rosenblum		06-Sep-1984
;		If read verify is specified and zero length picture string
;		was specified then the system would crash.
;
;	V03-029	MIR0450		Michael I. Rosenblum		05-Jun-1984
;		Fix problem with writes with lower clear and fallback set
;		Fix boundery problem with Readverify.
;		Fix bug in uppercase logic.
;
;	V03-028	MIR0700		Michael I. Rosenblum		25-May-1984
;		Fix bug where things would be verry screwed up if the
;		buffered i/o quota was exceded on a read.
;
;	V03-027	MIR0370		Michael I. Rosenblum		20-Mar-1984
;		Fix bug that caused pool to be corrupted if a read with
;		user specified terminator mask was issued when fallback
;		was set.  Clear out new read fields.
;
;	V03-026	MIR0310		Michael I. Rosenblum		09-Feb-1984
;		Don't give priority boosts to programs who do short I/O's
;
;	V03-025	MIR0300		Michael I. Rosenblum		30-jan-1984
;		Made the fallback characteristic overide writeall, pasall,
;		and pasthru.
;
;	V03-024	MIR0082		Michael I. Rosenblum		19-Aug-1983
;		Remove CMKRNL priv check in connect.
;
;	V03-023	MIR0080		Michael I. Rosenblum		28-Jul-1983
;		Move newline code to TTYSTRSTP
;		Reposition routines in this module
;
;	V03-022	MIR0053		Michael I. Rosenblum		27-Jun-1983
;		Fix bug in code that processed zero length initial strings
;		When uppercaseing.
;
;	V03-021	MIR0051		Michael I. Rosenblum		23-Jun-1983
;		Restructure MOVE_TRANSLATE to clean and optomize.
;		fix bug in prompt and initial string fallback presentation
;		dd code  to use the class relocation table for fallback
;
;	V03-020	RKS0020		RICK SPITZ			7-JUN-1983
;		ADD CONNECT/DISCONNECT FDT ACTION ROUTINES
;		MOVE UCB$V_TT_HANGUP INTO LUCB.
;
;	V03-019	RKS0019		RICK SPITZ			27-MAY-1983
;		INTERLOCK FDT FUNCTIONS THAT REFER TO PUCB FIELDS.
;		THIS IS NEEDED FOR CONNECT/DISCONNECT FUNCTIONALITY.
;		
;		INIT LINREST FIELD IN READ BUFFER
;
;	V03-018	MIR0049		Michael I. Rosenblum		06-May-1983
;		Add code to handle fallback presentation of eight bit 
;		characters.
;
;	V03-017	MIR0045		Michael I. Rosenblum		05-May-1983
;		Fix change in definition of TTY$C_FC_N_SET to
;		TTY$C_FC_HANGUP.
;
;	V03-016	MIR0030		Michael I. Rosenblum		30-Mar-1983
;		Integreate Read verify functionality with the normal
;		Terminal driver as an item list read function.
;
;	V03-015	MIR0029		Michael I. Rosenblum		22-Mar-1983
;		Add code to handle overstrike and insert modes.
;		Fix bug in initial offset code.
;
;	V03-014	RKS0014		RICK SPITZ			14-MAR-1983
;		ADD SUPPORT FOR LOGICAL UCB. NOTE THAT THIS A FUNDEMENTAL
;		CHANGE TO THE OPERATION OF THIS MODULE. WHEN RUNNING IN
;		FDT CONTEXT, IT IS VERY IMPORTANT TO ONLY REFERENCE FIELDS
;		IN THE LOGICAL UCB REGION. ALL REFERENCES TO PHYSICAL UCB
;		EXTENSIONS MUST BE DONE VIA THE PHYSICAL UCB POINTER.
;
;	V03-013	MIR8026		Michael I. Rosenblum		14-Mar-1983
;		Fix bug in initial string loading code.
;
;	V03-012	MIR7026		Michael I. Rosenblum		11-Mar-1983
;		Copy modifier bits into read buffer modify field.
;		Fix off by 1 error in initial offset code.
;
;	V03-011	MIR2026		Michael I. Rosenblum		07-Mar-1983
;		Set up modifier bits in the read buffer for normal
;		reads.
;
;	V03-010	MIR0026		Michael I. Rosenblum		01-Mar-1983
;		Add modifier bits to turn off recall and editing
;
;	V03-009	MIR0025		Michael I. Rosenblum		01-Feb-1983
;		Impliment alternate item list fdt routine to handle
;		the current functionality in the itemlist QIO form.
;
;	V03-008	MIR0024		Michael I. Rosenblum		28-Jan-1983
;		Impliment new terminal read buffer structure.
;
;	V03-007 MIR0013		Michael I. Rosenblum		16-Dec-1982
;		Fix up refferences to new ucb structure
;
;	V03-006	MIR0011		Michael I. Rosenblum		18-Nov-1982
;		Change CTRLR state to be EDITREAD state.
;
;	V03-005	MIR0010		Michael I. Rosenblum		09-Nov-1982
;		Move the address of the terminator mask, and the length
;		of the prompt string from the IRP into the terminal read
;		packet.  Also move the count of the characters in the 
;		buffer from the UCB into the terminal typeahead buffer packet.
;
;	V03-004	RKS0004		RICK SPITZ			23-SEP-1982
;		INSURE CONTROL Y AS IS POSTED PRIOR ATTEMPTING TO DELIVER
;		DEFERRED HANGUP AST. THIS CONDITION MAY OCCUR ON SLAVE 
;		TERMINALS.
;
;	V03-003	RKS0003		RICK SPITZ			05-APR-1982
;		ALLOW PASSALL DATA DURING UPCASE CONVERSION
;
;	V03-002	RKS0002		RICK SPITZ			31-MAR-1982
;		ADD SPECIAL CHARACTERISTIC BITS FOR DCL SPAWN
;		TRANSLATE LOWER CASE OUTPUT ON UPPERCASE DEVICES.
;		FIX SECURITY PROBLEM WITH AP AND TERMINATOR BITMAPS
;
;	V03-001	RKS0001		RICK SPITZ			23-MAR-1982
;		CORRECT ALTERNATE CLASS DRIVER DISPATCHING.
;		REPAIR SECURITY PROBLEM WITH USE OF AP.
;
;	V02-035	ROW0065		Ralph O. Weber			31-JAN-1982
;		Move test for IO$V_EXTEND in TTY$FDTREAD so as to eliminate 
;		executing duplicate code in both the regular class driver FDT 
;		and the alternate class driver FDT.  Add alternate class 
;		driver legal function test before dispatching to alternate 
;		class driver FDT.
;
;	V02-034	RKS034		RICK SPITZ			24-JAN-1982
;		IRP$W_TT_PRMPT+2 ENHANCED TO SPECIFY INITIAL READ FIELD OFFSET
;
;	V02-033	RKS033		RICK SPITZ			15-DEC-1981
;		ADD SUPPORT FOR ALTERNATE CLASS DRIVER.
;		REMOVE LOGIO REQUIREMENT FOR CONTROL Y ASTS.
;		REPAIR SET_MODEM MAINTENANCE FUNCTION.
;
;	V02-032	RKS032		RICK SPITZ			8-NOV-1981
;		ADD OUT OF BAND SUPPORT
;
;	V02-031	JLV0101		Jake VanNoy			27-Oct-1981
;		Changed TTYDEFS to $TTYDEFS.
;
;	V02-030	RKS030		RICK SPITZ			15-SEP-1981
;		REDEFINE DIAGNOSTIC MODEM BIT
;
;	V02-029	RKS029		RICK SPITZ			26-AUG-1981
;		ADD MAINT ENABLE BIT
;
;	V02-028	RKS028		RICK SPITZ			20-AUG-1981
;		ADD SUPPORT FOR ESCAPE MODIFIER ON READ
;
;	V02-027	RKS027		RICK SPITZ			30-APR-1981
;		THIS MODULE HAS BEEN ENHANCED TO SUPPORT QUADWORD STATE
;		AND DEVDEPEND STRUCTURES. ALSO ENHANCEMENTS WERE ADDED
;		TO SUPPORT CHANGES TO THE STRUCTURE OF THE UCB INCLUDING
;		SPLIT SPEED.
;		SUPPORT FOR DIAGNOSTIC MAINTENANCE FUNCTIONS HAS BEEN ADDED
;		AS WELL AS NEW FIELDS IN THE TWP. THIS ALLOWS FORKING 
;		ON THE TWP TO ALLOW ALLOCATION/DEALLOCATION OF MAP REGISTERS. 
;
;	V02-026	RKS026		RICK SPITZ			26-FEB-1981
;		DELETE V2.0 AUDIT TRAIL
;
;	V02-025	SPF0001		Steve Forgey			19-Dec-1980
;		Add RTE prompt support.
;
;
;--

	.SBTTL	Declarations

;
; EXTERNAL SYMBOLS:
;
	$ACBDEF				; DEFINE AST CONTROL BLOCK
	$ARBDEF				; DEFINE ACCESS RIGHTS BLOCK
;	$CADEF				; DEFINE CONDITIONAL ASSEMBLY PARAMETERS
	$DDTDEF				; DEFINE DDT OFFSETS
	$DYNDEF				; DEFINE DYNAMIC MEMORY BLOCK TYPES
	$IODEF				; DEFINE I/O FUNCTION CODES
	$IPLDEF				; DEFINE IPL CONSTANTS
	$IRPDEF				; DEFINE I/O PACKET OFFSETS
	$JIBDEF				; DEFINE JIB OFFSETS
	$PCBDEF				; DEFINE PCB OFFSETS
	$PRVDEF				; DEFINE PRIVILEGES
	$PSLDEF				; DEFINE PSL OFFSETS
	$SSDEF				; Define system status codes
	$UCBDEF				; DEFINE UCB
	$TRMDEF				; define bits for itemlist
	$TTYDEF				; DEFINE TERMINAL DRIVER SYMBOLS
	$TTDEF				; DEFINE TERMINAL CHARACTERISTICS
	$TT2DEF				; EXTENDED TERMINAL CHARACTERISTICS
	$TTYMACS			; TERMINAL MACROS
	$TTYDEFS			; DEFINE TERMINAL DEFINITIONS
;
; LOCAL DEFINITIONS
;
; QIO ARGUMENT LIST OFFSETS
;
P1 = 0
P2 = 4
P3 = 8
P4 = 12
P5 = 16
P6 = 20
;
; make sure that definitions of the terminal item list modifiers match
; system IO modifer definitions
;
ASSUME	TRM$V_TM_NOECHO EQ IO$V_NOECHO 				;NOECHO 
ASSUME	TRM$V_TM_TIMED EQ IO$V_TIMED 				;TIMED 
ASSUME	TRM$V_TM_CVTLOW EQ IO$V_CVTLOW 				;CONVERT LOWER CASE 
ASSUME	TRM$V_TM_NOFILTR EQ IO$V_NOFILTR 				;NO FILTER 
ASSUME	TRM$V_TM_DSABLMBX EQ IO$V_DSABLMBX 				;DISABLE MAILBOX 
ASSUME	TRM$V_TM_PURGE EQ IO$V_PURGE 				;PURGE TYPEAHEAD 
ASSUME	TRM$V_TM_TRMNOECHO EQ IO$V_TRMNOECHO 			;TERMINATORS ARE NOT ECHOED 
ASSUME	TRM$V_TM_REFRESH EQ IO$V_REFRESH 				;Control-R interrupted read n
ASSUME	TRM$V_TM_ESCAPE EQ IO$V_ESCAPE 				;TERMINATE READ ON ESCAPE SEQUENCE 

 
	.PAGE
	.PSECT	$$$115_DRIVER,LONG
	.SBTTL	TTY$FDTREAD - FUNCTION DECISION ROUTINE FOR TERMINAL READ FUNCTIONS
;++
; TTY$FDTREAD - FUNCTION DECISION ROUTINE FOR TERMINAL READ
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS THE FUNCTION DECISION ACTION ROUTINE FOR TERMINAL READS.
;
; THE TERMINAL READ QIO PARAMETERS ARE:
;
;	P1 = ADDRESS OF THE BUFFER TO RECEIVE THE DATA RECORD
;	P2 = SIZE OF THE P1 BUFFER
;	P3 = NUMBER OF SECONDS TO WAIT FOR CHARACTERS (IO$M_TIMED ONLY)
;	P4 = ADDRESS OF TERMINATOR CLASS BITMASK OR 0 IF STANDARD
;	P5 = ADDRESS OF PROMPT STRING FOR IO$_READPROMPT
;	P6 = SIZE OF PROMPT STRINT FOR IO$_READPROMPT
;
; THE FUNCTION PARAMETERS ARE VALIDATED AND IF CORRECT, THE PACKET IS
; QUEUED ON THE UNIT I/O QUEUE.
; THE PACKET CONTAINS THE FOLLOWING:
;
;	1. IRP$Q_TT_STATE IS SET UP TO BE THE NEW TERMINAL STATES AT THE
;	   TIME THE READ OPERATION IS STARTED.
;	2. IRP$L_SVAPTE CONTAINS THE ADDRESS OF THE READ BUFFER
;	   FORMATTED AS FOLLOWS.
;
;		.LONG	ADDRESS TO STORE DATA
;		.LONG	USER BUFFER VIRTUAL ADDRESS
;		.WORD	SIZE
;		.WORD	TYPE
;		.WORD	STORAGE FOR STARTING CURSOR POSITION
;		.WORD TIMEOUT COUNT	
;		PROMPT STRING
;		READ BUFFER
;		TERMINATOR MASK FOR NONSTANDARD CLASSES
;
;	3. IRP$L_TT_TERM ADDRESSES THE TERMINATOR BITMASK
;	4. IRP$W_FUNC<0:6> ARE SET FOR A FAST CASE ON FUNCTION TYPE
;	5. IRP$W_BOFF IS THE QUOTA FOR THE I/O
;	6. IRP$W_BCNT IS THE READ REQUEST SIZE
;
; STATE BIT USAGE.
;
;	FOR IO$_READPBLK, TTY$V_ST_PASSALL IS SET.
;	FOR IO$_READPROMPT, TTY$V_ST_PROMPT AND TTY$V_ST_EDITREAD ARE SET.
;		EDITREAD WILL FORCE THE PROMPT AND INITIAL STRING OUT.
;
;	FOR IO$M_NOECHO, TTY$V_ST_NOECHO IS SET.
;	FOR IO$M_NOFILTR, TTY$V_ST_NOFILTR IS SET.
;	For IO$M_REFRESH, TTY$V_ST_REFRSH is set.
;
; INPUTS:
;
;	R3 = ADDRESS OF THE PACKET FOR THIS REQUEST
;	R4 = CURRENT PCB
;	R5 = UCB ADDRESS
;	R6 = ASSIGNED CCB
;	R7 = FUNCTION CODE
;	AP = ADDRESS OF FIRST FUNCTION DEPENDENT QIO PARAMETER
;
; OUTPUTS:
;
;	THE I/O IF IN ERROR IS COMPLETED VIA "EXE$ABORTIO".
;	THE I/O IF VALID IS QUEUED TO THE DRIVER BY "EXE$QIODRVPKT".
;
; COMPLETION CODES:
;
;	SS$_ACCVIO - ACCESS VIOLATION ON BUFFER.
;	SS$_EXQUOTA - OVER QUOTA FOR BUFFERED I/O
;	SS$_INSFMEM - INSUFFICIENT MEMORY
;--
	.ENABLE LSB
TTY$FDTREAD::				;
	BBC	#IO$V_EXTEND,-
		IRP$W_FUNC(R3),2$
	BRW	TTY$FDTITEMREAD
2$:
	BBS	#TT$V_LOWER,-		; IS THIS LOWER CASE
		UCB$L_DEVDEPEND(R5),1$	; NO THEN CONTINUE ON
	BBSS	#IO$V_CVTLOW,-
		IRP$W_FUNC(R3),1$	; YES THEN SET LOWER IN FUNCTION
1$:	PUSHL	R3			; SAVE PACKET ADDRESS
;
; SET PROPER STATE BITS FOR READ FUNCTIONS FROM FUNCTION MODIFIERS
;
; NOTE THE CORRESPONDENCE OF THE VALUES
;
	ASHL	#TTY$V_ST_NOECHO-	; Move function code and its
		-IO$V_NOECHO,-		; modifiers into bits 9-25 of
		IRP$W_FUNC(R3),R8	; a register.
	BICL	#^C<TTY$M_ST_NOECHO!-	; Clear all bits except NOECHO
		TTY$M_ST_NOFLTR!-	; NOFLTR, and
		TTY$M_ST_ESCAPE!-	; ESCAPE
		TTY$M_ST_REFRSH>,R8	; REFRESH if specified.
	BBC	#TT2$V_EDITING,UCB$L_DEVDEPND2(R5),3$; IS THIS AN EDITING READ
	BISL	#TTY$M_ST_EDITING,R8	; YES THEN SET EDITING
	BISL	#TTY$M_ST_OVERSTRIKE,R8	; THEN MAKE OVERSTRIKE THE DEFAULT
	BBC	#TT2$V_INSERT,UCB$L_DEVDEPND2(R5),3$; IF HE WANTS INSERT THEN
	BICL	#TTY$M_ST_OVERSTRIKE,R8	; CLEAR INSERT
3$:	MOVZWL	#TTY$M_ST_READ,-
		IRP$Q_TT_STATE(R3)	; INIT AND ADD READ
;
; CHECK ACCESS TO READ BUFFER
;
	MOVL	P1(AP),R0		; GET BUFFER ADDRESS AND SIZE
	MOVZWL	P2(AP),R1		;
	BNEQ	5$			; IF NEQ THEN ACTUAL READ
	BBCS	#TTY$V_ST_EOL,-
		IRP$Q_TT_STATE(R3),10$	; SET EOL AND BRANCH
5$:	JSB	G^EXE$READCHK		; CHECK READ ACCESS FOR BUFFER
					; NO RETURN MEANS NO ACCESS
10$:	MOVQ	R0,R9			; COPY INPUT BUFFER PARAMS
	CLRL	R7			; ASSUME 0 BUFFER SIZE
	CMPZV	#IRP$V_FCODE,#IRP$S_FCODE,IRP$W_FUNC(R3),#IO$_READPBLK; PASSALL?
	BEQL	12$			; IF EQL THEN YES
	CMPZV	#IRP$V_FCODE,#IRP$S_FCODE,-	; TEMP READ PASSALL
		IRP$W_FUNC(R3),#IO$_TTYREADALL
	BNEQ	20$			; NO, BRANCH
12$:

	.IF DF CA$_MEASURE_IOT

	BLBC	G^PMS$GL_DOSTATS,15$	; IF FLAG OFF BYPASS NEXT INST.
	INCL	G^PMS$GL_PASSALL	; ELSE INCR PASSALL COUNTER

	.ENDC

15$:	BBCS	#TTY$V_ST_PASALL,R8,50$	; SET PASSALL MODE AND BR
;
; DO SPECIAL FUNCTION LOGIC FOR READ WITH PROMPT
;
20$:	CMPZV	#IRP$V_FCODE,#IRP$S_FCODE,-	; READPROMPT?
		IRP$W_FUNC(R3),#IO$_READPROMPT
	BEQL	22$			; YES, BRANCH
	CMPZV	#IRP$V_FCODE,#IRP$S_FCODE,-	; READ PASSALL W/PROMPT?
		IRP$W_FUNC(R3),#IO$_TTYREADPALL
	BNEQ	50$			; BRANCH IF NO
	BBCS	#TTY$V_ST_PASALL,R8,22$	; SET PASSALL BIT IN VECTOR
22$:
;
; SEE IF NO PROMPT IS SPECIFIED
;
	MOVZWL	P6(AP),R7		; GET SIZE OF PROMPT
	BEQL	50$			; IF EQL THEN MAKE THIS NORMAL READ
;
; READ WITH PROMPT
;

	.IF DF CA$_MEASURE_IOT

	BLBC	G^PMS$GL_DOSTATS,30$	; IF FLAG OFF, BYPASS NEXT INST
	INCL	G^PMS$GL_RWP		; INCR READ WITH PROMPT COUNTER
	CMPL	#12,R7			; \ISOLATE READ WITH PROMPTS
	BGTR	25$			; /GREATER THAN 12 CHARS
	INCL	G^PMS$GL_LRGRWP		; INCR CTR FOR PROMPTS > 12 CHARS
25$:	ADDL2	R7,G^PMS$GL_RWPSUM	; KEEP RUNNING SUM OF RWP SIZES

	.ENDC

30$:	BISL	#TTY$M_ST_PROMPT,R8	; INSERT BITS FOR PROMPT
	BISL	#TTY$M_ST_EDITREAD,IRP$Q_TT_STATE(R3); INSERT BITS FOR PROMPT
	MOVL	P5(AP),R0		; GET PROMPT BUFFER ADDRESS
;
; CHECK ACCESS TO PROMPT STRING
;
	MOVZWL	R7,R1			; GET SIZE PROMPT
	JSB	G^EXE$WRITECHK		; CHECK PROMPT BUFFER ACCESS
					; NO RETURN MEANS NO ACCESS
	CLRW	IRP$W_TT_PRMPT+2(R3)	; ZERO INITIAL READ OFFSET
	BBC	#TT2$V_FALLBACK,-
		UCB$L_DEVDEPND2(R5),35$	; ARE WE DOING FALLBACK?
	PUSHL	R9			; SAVE THIS SPECAIL
	PUSHR	#^M<R0,R1,R2,R3>	; SAVE A REGISTER
	MOVL	R0,R2			; REGISTERS NEED TO BE SWAPPED
	MOVL	R1,R0			;...
	MOVL	R2,R1			;
	BSBW	ADDFALL			; GET THE NUMBER OF CHARACTERS
	POPR	#^M<R0,R1,R2,R3>
	MOVW	R9,IRP$W_TT_PRMPT+2(R3)	; SAVE THE ADDITIONAL NUMBER OF CHARCTERS
	ADDL	R9,R1			; AND FIX UP R1
	POPL	R9			; RESTORE R9
35$:	MOVL	R0,R6			; COPY PROMPT STRING ADDRESS
	ADDL	R10,R1			; ADJUST PROMPT SIZE TO OVERALLOCATE
	MOVW	R10,IRP$W_BCNT(R3)	; SAVE ACTUAL READ SIZE
	BBSS	#IRP$V_FUNC,IRP$W_STS(R3),50$; RESET TRANSFER DIRECTION
50$:	MOVW	R7,IRP$W_TT_PRMPT(R3)	; keep the prompt size
	ADDL	#TTY$L_RB_DATA,R1	; ADJUST SIZE FOR BLOCK HEADER
	BBC	#TT$V_SCRIPT,UCB$L_DEVDEPEND(R5),55$; RTE TERMINAL LINE ?
	INCW	IRP$W_TT_PRMPT(R3)	; ADD RTE PROMPT SIZE
	INCL	R1			; ADD RTE PROMPT SIZE
	BISL2	#TTY$M_ST_PROMPT,R8	; ENSURE FUNCTION IS A RWP
	BISL2	#TTY$M_ST_EDITREAD,-
		IRP$Q_TT_STATE(R3)	; ENSURE FUNCTION IS A RWP
	BBSS	#IRP$V_FUNC,IRP$W_STS(R3),55$; ENSURE TRANFER DIRECTION RESET
55$:	MOVAB	TTY$A_STANDARD,IRP$L_TT_TERM(R3); ASSUME STANDARD TERMINATORS
	MOVL	P4(AP),IRP$L_MEDIA(R3)	; GET ADDRESS OF TERMINATOR BITMASK
	BEQL	65$			; IF EQL THEN STANDARD
	MOVL	IRP$L_MEDIA(R3),R2	; RETRIEVE ADDRESS
	MOVZWL	R1,IRP$L_TT_TERM(R3)	; SAVE OFFSET IN BUFFER BLOCK
	MOVZWL	#SS$_ACCVIO,R0		; ASSUME ACCESS VIOLATION
	IFNORD	#8,(R2),70$		; DESC. ACCESSIBLE?
	MOVL	4(R2),R11		; GET BITMAP ADDRESS
	MOVZWL	(R2),R10		; GET BITMAP SIZE
	BEQL	60$			; IF EQL THEN SHORT FORM
	CMPW	R10,#32			; CHECK FOR VALID LENGTH
	BLEQU	57$			; RANGE OK	
	MOVZWL	#32,R10			; USE MAXIMUM
57$:	IFNORD	R10,(R11),70$		; BITMAP ACCESSIBLE?
60$:	ADDL	#32,R1			; ASSUME EIGHTBIT CHARACTERS AND EXTEND
					; TERMINATOR MASK
;
; ALLOCATE HEADER + PROMPT + DATA + BITMASK
;
; CHECK FOR BUFFERED I/O QUOTA
;
65$:
	JSB	G^EXE$BUFFRQUOTA	; CHECK QUOTA
	BLBC	R0,70$			; SIGNAL ERROR IF LOW CLEAR
;
; ALLOCATE THE BUFFER
;
	JSB	G^EXE$ALLOCBUF		; ALLOCATE THE BUFFER
70$:	POPL	R3			; RESTORE PACKET
	BLBS	R0,72$			; CONTINUE IF NO ERROR
	BRW	100$			; IF ERROR, THEN ABORT I/O
;
; FALLBACK PRESENTATION FOR PROMPTS
;
72$:					;
	BBC	#TT$V_SCRIPT,UCB$L_DEVDEPEND(R5),74$; RTE SCRIPT LINE ?
	MOVAB	TTY$L_RB_DATA(R2),R0	; GET ADDRESS FOR RTE PROMPT CHARACTER
	ADDL2	R7,R0
	MOVB	@#PMS$GB_PROMPT,(R0)	; INSERT RTE PROMPT
74$:	MOVL	R2,IRP$L_SVAPTE(R3)	; SAVE ADDRESS OF BUFFERED I/O BLOCK
	MOVW	R1,IRP$W_BOFF(R3)	; SAVE BLOCK SIZE AS QUOTA
;
; ADJUST BUFFERED I/O QUOTA
;
	MOVL	PCB$L_JIB(R4),R4	; GET JIB ADDRESS
	MOVZWL	R1,R1			; CONVERT TO LONG WORD COUNT
	SUBL	R1,JIB$L_BYTCNT(R4)	; ADJUST QUOTA WORD
;
;	MARK PACKET AS TERMINAL I/O
;
	BISW	#IRP$M_TERMIO,IRP$W_STS(R3)	; SET FLAG FOR GREATER PRIORITY
					; INCREMENTS UPON COMPLETION
;
; SET UP BUFFERED I/O BLOCK
;
	MOVZWL	IRP$W_FUNC(R3),TTY$L_RB_MOD(R2); SETUP THE MODIFIER WORD
	INSV	#0,#IRP$V_FCODE,#IRP$S_FCODE,TTY$L_RB_MOD(R2); CLEAN
					; OUT THE FUNCTION CODE BITS
	MOVL	R9,TTY$L_RB_UVA(R2)	; INSERT USER VIRTUAL ADDRESS
	MOVAB	TTY$L_RB_DATA(R2),TTY$L_RB_TXT(R2); INSERT POINTER TO DATA AREA
	PUSHR	#^M<R2,R3,R5>		; SAVE REGISTERS
	MOVL	IRP$L_TT_TERM(R3),TTY$L_RB_TERM(R2); MOVE THIS DATA INTO THE READ BUFFER
	ADDW3	IRP$W_TT_PRMPT(R3),-
		IRP$W_TT_PRMPT+2(R3),-
		TTY$W_RB_PRMLEN(R2)	; GET THE PROMPT LENGTH
	MOVW	IRP$W_BCNT(R3),TTY$W_RB_TXTSIZ(R2); THE TEXT SIZE
	MOVZWL	TTY$W_RB_PRMLEN(R2),R5	;GET THE PROMPT LENGTH
	ADDL	R5,TTY$L_RB_TXT(R2)	; SETUP THE OFFSET'S RIGHT
	MOVL	TTY$L_RB_TXT(R2),TTY$L_RB_LIN(R2); SETUP THE LINE ADDRESS ALSO
	CLRW	TTY$W_RB_LINOFF(R2)	; START THE OFFSETS AT ZERO
	CLRW	TTY$W_RB_TXTOFF(R2)	; ...
	CLRW	TTY$W_RB_LINREST(R2)	; AND OTHER FIELDS TO BE ZERO
	CLRW	TTY$W_RB_RDSTATE(R2)
	CLRW	TTY$W_RB_MODE(R2)	; ZERO OUT THE MODE FIELD ALSO
	CLRW	TTY$W_RB_CPZCUR(R2)	; CLEAN THE CURSOR POSITION
	CLRL	TTY$L_RB_ECHSTR(R2)	; CLEAN THE ECHO STRING
	MNEGL	#1,IRP$L_TT_TERM(R3)	;***to be removed (just for insurance)
	MNEGW	#1,IRP$W_TT_PRMPT(R3)	;***to be removed (just for insurance)
	MOVL	IRP$L_MEDIA(R3),R4	; ADDRESS BITMAP ADDRESS
	BEQL	90$			; IF EQL THEN STANDARD

	.IF DF CA$_MEASURE_IOT

	BLBC	G^PMS$GL_DOSTATS,75$	; IF FLAG OFF, BYPASS NEXT INSTRUCTION
	INCL	G^PMS$GL_NOSTDTRM	; ELSE, INCR NON STD. TERMINATOR CTR
	TSTL	P6(AP)			; \CHECK IF PROMPT SIZE
	BEQL	75$			; /= 0
	INCL	G^PMS$GL_RWPNOSTD	; INCR CTR OF RWP WITH NON STD TERMS

	.ENDC

75$:	ADDL	R2,TTY$L_RB_TERM(R2)	; CALC ADDR OF BITMAP SPACE
	SUBW	TTY$W_RB_PRMLEN(R2),R1	; CALC BITMAP SIZE
	SUBW	TTY$W_RB_TXTSIZ(R2),R1	;
	SUBW	#TTY$L_RB_DATA,R1	; AND REMOVE THE LENGTH OF THE PACKET DATA
	TSTW	R10			; CHECK SIZE OF MAP
	BNEQ	80$			; IF NEQ THEN SPECIFIED
	MOVZBL	#4,R10			; SET SIZE OF SHORT FORM
	MOVAB	4(R4),R11		; ADDRESS SHORT FORM LONG WORD
80$:	MOVC5	R10,(R11),#0,R1,@TTY$L_RB_TERM(R2); COPY BITMAP
	BISL	#TTY$M_ST_TERMNORM,R8	; IF THE USER SPECIFIES THE
					; TERMINATOR MASK THEN LET HIM HAVE IT
90$:	MOVL	(SP)+,R2		; RETRIEVE BLOCK ADDRESS
	MOVL	(SP),R3			; RETRIEVE THE IRP ADDRESS ALSO
	MOVW	P3(AP),TTY$W_RB_TIMOS(R2); GET TIMEOUT COUNT
;
; READ WITH PROMPT?
;
	BBC	#TTY$V_ST_PROMPT,R8,95$	; BR IF NOT PROMPT READ
	MOVL	4(SP),R5		; GET UCB ADDRESS
	BBC	#TT$V_LOWER,-		; IS THIS LOWER CASE
		UCB$L_DEVDEPEND(R5),150$; NO THEN CONTINUE ON
	BBS	#TT2$V_FALLBACK,-
		UCB$L_DEVDEPND2(R5),150$; BRANCH IF FALLBACK
93$:
	MOVC3	R7,(R6),TTY$L_RB_DATA(R2); COPY PROMPT STRING TO BUFFERED BLOCK

95$:	POPR	#^M<R3,R5>		; RESTORE IRP ADDRESS
;
; QUEUE I/O PACKET TO UNIT
;
	MOVL	R8,IRP$Q_TT_STATE+4(R3)	; PUT STATE DATA IN PACKET
	INSV	#TTY$C_FC_READ,#IRP$V_FCODE,#IRP$S_FCODE,IRP$W_FUNC(R3)
	JMP	G^EXE$QIODRVPKT		; INSERT PACKET ON QUEUE
;
; ERROR IN PROCESSING
;
100$:	JMP	G^EXE$ABORTIO		; THE I/O IS DONE

; TRANSLATE TO UPPERCASE

150$:
	BBS	#TT2$V_FALLBACK,-
		UCB$L_DEVDEPND2(R5),160$; BRANCH IF FALLBACK
 	BBS	#TTY$V_ST_PASALL,R8,93$	; NO TRANSLATE IF PASSALL
	BBS	#TT$V_PASSALL,-
		UCB$L_DEVDEPEND(R5),93$	; CHECK FOR PASSALL OR PASTHRU
	BBS	#TT2$V_PASTHRU,-
		UCB$L_DEVDEPND2(R5),93$	; ...
160$:	PUSHL	R8			; SAVE R8
	CLRL	R8			; CLEAR FLAG
	BBS	#TT$V_LOWER,-		; IS THIS LOWER CASE
		UCB$L_DEVDEPEND(R5),165$; NO THEN CONTINUE ON
	MOVL	#1,R8			; SET DO LOWER CASE BIT
165$:	MOVZWL	IRP$W_TT_PRMPT+2(R3),R1	; GET ADDITIONAL LENGTH
	CLRW	IRP$W_TT_PRMPT+2(R3)	; CLEAN THE INITIAL OFFSET OUT
	ADDL3	R1,R7,R3		; AND ADD IN THE LENGTH
	MOVAB	TTY$L_RB_DATA(R2),R2	; GET DESTINATION ADDRESS
	BSBW	MOVE_TRANSLATE		; TRANSLATE DATA
	POPL	R8
	BRB	95$

	.PAGE
.DISABLE LSB
	.sbttl	TTY$FDTITEMREAD - ITEM LIST SPECIFYED ON THE READ.
;++
; TTY$FDTITEMREAD - FUNCTION DECISION ROUTINE FOR TERMINAL READS WITH
;	ITEM LISTS (EXTEND MODE).
;
; FUNCTIONAL DESCRIPTION:
;
;  THE TERMINAL READ QIO PARAMETERS ARE:
;
;	P1 = ADDRESS OF THE BUFFER TO RECIEVE THE DATA RECORD
;	P2 = SIZE OF P1 BUFFER
;	P3 = ACCESS MODE AT WHICH THE ITEM LIST IS TO BE PROBED(OPTIONAL)
;	P4 = MBZ
;	P5 = ADDRESS OF THE ITEM LIST BUFFER
;	P6 = LENGTH IN BYTES OF THE ITEM LIST BUFFER
;
; THE ITEM LIST BUFFER IS PROBED AND THEN EACH ITEM IS VALIDATED.
; IF ALL THE ITEMS ARE CORRECT THEN THE READ PACKET IS QUEUED TO THE
; I/O QUEUE.
;
; THE PACKET CONTAINS THE FOLLOWING:
;
;	1.  IRP$Q_TT_STATE - SETUP TO BE THE NEW TERMINAL STATES AT THE
;		TIME THE READ IS STARTED.
;
;	2.  IRP$L_SVAPTE - CONTAINS THE ADDRESS OF THE READ BUFFER FORMATTED
;		AS FOLLOWS:
;	+---------------------------------------------------------------+
;	|			TTY$L_RB_TXT				|
;	+---------------------------------------------------------------+
;	|		       TTY$L_RB_UVA				|
;	+---------------------------------------------------------------+
;	|TTY$B_RB_ECHLEN|    Spare     	|	TTY$W_RB_SIZE		|
;	+---------------------------------------------------------------+
;	|		     TTY$L_RB_ECHSTR				|
;	+---------------------------------------------------------------+
;	|		       TTY$L_RB_PIC				|
;	+---------------------------------------------------------------+
;	|		      TTY$L_RB_TERM				|
;	+---------------------------------------------------------------+
;	|		      TTY$L_RB_MOD				|
;	+---------------------------------------------------------------+
;	|		       TTY$L_RB_LIN				|
;	+---------------------------------------------------------------+
;	|	TTY$W_RB_LINREST     	|	TTY$W_RB_LINOFF		|
;	+---------------------------------------------------------------+
;	|	TTY$W_RB_TIMOS	     	|	TTY$W_RB_PRMLEN		|
;	+---------------------------------------------------------------+
;	|	TTY$W_RB_CPZORG	     	|	TTY$W_RB_CPZCUR		|
;	+---------------------------------------------------------------+
;	|	TTY$W_RB_PICLEN	     	|	TTY$W_RB_TXTOFF		|
;	+---------------------------------------------------------------+
;	|	TTY$W_RB_TXTECH		|	TTY$W_RB_TXTSIZ		|
;	+---------------------------------------------------------------+
;	|TTY$B_RB_RVFFIL!TTY$B_RB_RVFCLR|	TTY$W_RB_MODE		|
;	+---------------------------------------------------------------+
;	|	      TTY$A_RB_PRM or TTY$L_RB_DATA			|
;	+---------------------------------------------------------------+
;
;	4.  IRP$W_FUNC<0:6> ARE SET FOR A FAST CASE ON FUNCTION TYPE
;	5.  IRP$W_BOFF IS THE QUOTA FOR THE I/O
;	6.  IRP$W_BCNT IS THE READ REQUEST SIZE
;
; ITEM LIST TYPES AND PROCESSING:
;
;  TRM$_MODIFIERS:
;	32 BIT VALUE - SPECIFYES READ MODIFIERS CURRENT MODIFIERS ARE:
;		TRM$M_TM_CVTLOW
;		TRM$M_TM_DSABLMBX
;		TRM$M_TM_NOECHO SETS TTY$V_ST_NOECHO
;		TRM$M_TM_NOFILTR SETS TTY$V_ST_NOFILTR
;		TRM$M_TM_PURGE
;		TRM$M_TM_TIMED
;		TRM$M_TM_TRMNOECHO
;		TRM$M_TM_REFRESH SETS TTY$V_ST_REFRSH
;		TRM$M_TM_NOEDIT
;		TRM$M_TM_NORECALL
;	   ALL OTHER'S MUST BE ZERO
;  TRM$_EDITMODE
;	VALUE TO SPECIFY THE TYPE OF READ TO BE ISSUED
;	CURRENT MODES ARE:
;		TRM$K_EM_DEFAULT - NO SPECAIL FEATURES (DEFAULT)
;		TRM$K_EM_EXTEDIT - EXTENDED EDITING CAPABILITIES
;		TRM$K_EM_RDVERIFY - CHARACTER VALIDATING READ
;  TRM$_TIMEOUT
;	32 BIT VALUE SPECIFYING NUMBER OF SECONDS TO WAIT BETWEEN CHARACTERS.
;	SETS IO$M_TIMED IF SPECIFYED IN THE ITEM LIST.
;  TRM$_TERM
;	ADDRESS OF THE TERMINATOR BITMASK. A ZERO LENGTH INDICATES AN IMMEDIATE
;	SHORT FORM BITMASK.
;  TRM$_PROMPT
;	LENGTH AND ADDRESS OF PROMPT STRING. SETS TTY$V_ST_PROMPT AND
;	TTY$V_ST_EDITREAD.
;  TRM$_INISTRNG
;	LENGTH AND ADDRESS OF STRING TO LOAD INTO THE READ BUFFER AS IF
;	THE USER HAD TYPED IT.
;  TRM$_PICSTRNG
;	LENGTH AND ADDRESS OF THE PICTURE STRING (ONLY VALID WITH RDVERIFY
;	SET.
;  TRM$_FILLCHR
;	TWO BYTE VALUE OF THE FILL AND CLEAR CHARACTER FOR READ VERIFY
;  TRM$_INIOFFSET
;	16 BIT VALUE SPECIFYING HOWMANY CHARACTERS INTO THE INITIAL STRING
;	TO BEGIN ECHOING.  IF NON-ZERO THEN THE PROMPT STRING WILL NOT BE
;	ECHOED.  DEFAULT IS ZERO.
;
; INPUTS:
;
;	R3 = ADDRESS OF THE IRP FOR THIS REQUEST
;	R4 = CURRENT PCB
;	R5 = UCB ADDRESS
;	R6 = ASSIGNED CCB
;	R7 = FUNCTION CODE
;	AP = ADDRESS OF FIRST FUNCTION DEPENDENT QIO PARAMETER
;
; OUTPUTS:
;
;	THE I/O IF IN ERROR IS COMPLETED VIA EXE$ABORTIO
;	THE I/O IF VALID IS QUEUED TO THE DRIVER BY EXE$QIODRVPKT
;
; COMPLETION CODES:
;
;	SS$_ACCVIO - ACCESS VIOLATION ON BUFFER
;	SS$_EXQUOTA - OVER QUOTA FOR BUFFERED I/O
;	SS$_INSFMEM - INSUFFICIENT MEMORY
;	SS$_BADPARAM - ITEM LIST CONTAINED INVALID DATA.
;
;--
TTY$FDTITEMREAD:
	TSTL	P4(AP)			; P4 MUST BE ZERO
	BEQL	4$			; IT IS THEN CONTINUE
2$:	MOVZWL	#SS$_BADPARAM,R0	; SETUP R0 FOR ERROR
	JMP	G^EXE$ABORTIO		; AND ABORT THE I/O

4$:	BITW	#IO$M_CVTLOW!-		; CHECK ALL FUNCTION MODIFIERS
		IO$M_DSABLMBX!-
		IO$M_NOECHO!-
		IO$M_NOFILTR!-
		IO$M_PURGE!-
		IO$M_TIMED!-
		IO$M_TRMNOECHO!-
		IO$M_ESCAPE!-
		IO$M_REFRESH,-
		IRP$W_FUNC(R3)
	BNEQ	2$			; MAKE SURE ALL ARE OFF
	CLRL	R7			; CLEAN OUT THE BUFFER LENGTH
	CLRL	R8			; AND THE STATE BITS
	BBC	#TT2$V_EDITING,UCB$L_DEVDEPND2(R5),3$; IS THIS AN EDITING READ
	BISL	#TTY$M_ST_EDITING,R8	; YES THEN SET EDITING
	BISL	#TTY$M_ST_OVERSTRIKE,R8	; IN OVERSTRIKE THEN SAY SO.
	BBC	#TT2$V_INSERT,UCB$L_DEVDEPND2(R5),3$; IF HE WANTS INSERT THEN
	BICL	#TTY$M_ST_OVERSTRIKE,R8	; CLEAR INSERT
;
; CHECK ACCESS TO READ BUFFER
;
3$:	MOVL	P1(AP),R0		; GET BUFFER ADDRESS AND SIZE
	MOVZWL	P2(AP),R1		;
	BNEQ	5$			; IF NEQ THEN ACTUAL READ
	BBCS	#TTY$V_ST_EOL,-
		IRP$Q_TT_STATE(R3),10$	; SET EOL AND BRANCH
5$:	JSB	G^EXE$READCHK		; CHECK READ ACCESS FOR BUFFER
					; NO RETURN MEANS NO ACCESS
10$:	CMPZV	#IRP$V_FCODE,#IRP$S_FCODE,IRP$W_FUNC(R3),#IO$_READPBLK; PASSALL?
	BEQL	12$			; IF EQL THEN YES
	CMPZV	#IRP$V_FCODE,#IRP$S_FCODE,-	; TEMP READ PASSALL
		IRP$W_FUNC(R3),#IO$_TTYREADALL
	BEQL	12$			; NO, BRANCH
	CMPZV	#IRP$V_FCODE,#IRP$S_FCODE,-	; READ PASSALL W/PROMPT?
		IRP$W_FUNC(R3),#IO$_TTYREADPALL
	BNEQ	20$			; BRANCH IF NO

12$:

	.IF DF CA$_MEASURE_IOT

	BLBC	G^PMS$GL_DOSTATS,15$	; IF FLAG OFF BYPASS NEXT INST.
	INCL	G^PMS$GL_PASSALL	; ELSE INCR PASSALL COUNTER

	.ENDC

15$:	BBCS	#TTY$V_ST_PASALL,R8,20$	; SET PASSALL MODE AND BR
;
;	CHECK FOR ACCESS TO ITEM LIST.
;
20$:	MOVZWL	#TTY$M_ST_READ,-
		IRP$Q_TT_STATE(R3)	; INIT AND ADD READ TO THE STATE BITS
	SUBL	#TTY$K_IS_LENGTH,SP	; ALLOCATE THE STACK STRUCTURE
	MOVL	SP,R11			; MAKE R11 POINT TO THE STACK STRUCTURE
	MOVQ	R0,TTY$L_IS_BUF(R11)	; SAVE THE USER'S BUFFER ADDRESS AND LENGTH
ASSUME	TTY$L_IS_BUF+4 EQ TTY$L_IS_BUFLEN; STATE THE ASSUMPTION
	PUSHR	#^M<R3,R4,R5>		; SAVE THE REGISTERS FOR EVERYONE
	MOVL	R3,R10			; KEEP THE IRP ADDRESS
	EXTZV	#0,#2,P3(AP),R0		; GET THE ACCESS MODE
	JSB	G^EXE$MAXACMODE		; MAXIMIZE ACCESS MODE
	MOVL	R0,TTY$L_IS_ACMODE(R11)	; KEEP IT IN THE STACK FOR LATER USE
	MOVL	R0,R3			; GET THE ACCESS MODE INTO R3
	MOVL	P5(AP),R0		; GET THE ADDRESS OF THE ITEM LIST
	MOVZWL	P6(AP),R1		; AND IT'S LENGTH
	MOVQ	R0,TTY$L_IS_ITMLST(R11)	; SAVE THE ADDRESS AND LENGTH
ASSUME	TTY$L_IS_ITMLST+4 EQ TTY$L_IS_LASTITM; STATE OUR ASSUMPTION
	JSB	G^EXE$PROBER		; MAKE SURE WE CAN READ THE ITEM LIST
	BLBS	R0,30$			; YES THEN START TO PROCESS IT
	BRW	ITMREADERR		; ELSE RETURN HIM THE ERROR

;
; START TO PROCESS ITEM LIST
;
30$:	ADDL	TTY$L_IS_ITMLST(R11),TTY$L_IS_LASTITM(R11); MAKE THE LENGTH
					; A POINTER TO THE END OF THE ITEMLIST
;
; CLEAN OUT THE STACK STRUCTURE
;
	CLRQ	TTY$L_IS_PRM(R11)	; ZERO THE PROMPT ADDRESS AND LENGTH
	CLRQ	TTY$L_IS_INI(R11)	; THE INITIAL STRING ADDRESS AND LENGTH
	CLRQ	TTY$L_IS_TERM(R11)	; TERMINATOR MASK ADR AND LENGTH
	CLRL	TTY$L_IS_TIMEOUT(R11)	; THE TIMEOUT VALUE
	CLRL	TTY$L_IS_MODIFY(R11)	; THE MODIFIER LONG WORD
	CLRQ	TTY$L_IS_PIC(R11)	; THE PICTURE STRING ADDRESS AND LEGTH
	CLRW	TTY$W_IS_FILLCHR(R11)	; FILL AND CLEAR CHARACTER
	CLRW	TTY$W_IS_INIOFF(R11)	; AND THE INITIAL OFFSET
	CLRL	TTY$L_IS_EDITMODE(R11)	; DEFAULT THE EDIT MODE
	CLRL	TTY$L_IS_SPECIFYED(R11)	; ALSO THE ITEM SPECIFYED BIT MASK
ASSUME	TRM$_LASTITM LE 32		; MAKE SURE THAT THE ITEMS WILL
					; FIT IN THE BITMASK.
	BBS	#TT$V_LOWER,-		; IS THIS LOWER CASE
		UCB$L_DEVDEPEND(R5),ITEMLOOP; NO THEN CONTINUE ON
	BBSS	#IO$V_CVTLOW,-
		TTY$L_IS_MODIFY(R11),ITEMLOOP; YES THEN SET LOWER IN FUNCTION

;
; MAIN ITEM LIST PROCESSING LOOP
;
ITEMLOOP:
50$:	MOVL	TTY$L_IS_ITMLST(R11),R9	; GET THE ADDRESS OF THIS ITEM
	ADDL	#TTY$K_IL_LENGTH,TTY$L_IS_ITMLST(R11); UPDATE THE COUNTER
	CMPL	TTY$L_IS_ITMLST(R11),TTY$L_IS_LASTITM(R11); ARE WE DONE
	BLEQ	60$			; NO THEN GOTO THE DISPATCHER

	CMPL	R9,TTY$L_IS_LASTITM(R11); WAS THE ITEM LIST THE CORRECT LENGTH
	BNEQ	55$			; NO THEN BAD PARAMETER
	BRW	300$			; YES THEN ALLOCATE THE BUFFER AND BEGIN
55$:	BRW	BDPRMERR		; GIVE ERROR
57$:	BRW	ITMREADERR		; ERROR OUT
;
; ITEM LIST DISPATCHER
;
; INPUTS TO ROUTINES:
;
;	R4 = PCB ADDRESS
;	R5 = UCB ADDRESS
;	R7 = SIZE OF DATA AREA TO BE ADDED TO THE NORMAL READ DATA SECTION
;	R8 = SECOND LONG WORD OF THE UNIT STATE VECTOR
;	R9 = ADDRESS OF THIS ITEM BUFFER
;	R10 = IRP ADDRESS
;	R11 = STACK STRUCTURE ADDRESS
;
;	ALL OTHERS ARE SCRATCH
;
60$:	TSTL	TTY$L_IL_RETADR(R9)	; MAKE SURE THE RETURN ADDRESS IS ZERO
	BNEQ	55$			; ERROR IF NOT
	MOVZWL	TTY$W_IL_TYPE(R9),R1	; GET THE ITEM TYPE
	CMPL	R1,#TRM$_LASTITM	; IS THIS ITEM IN RANGE
	BGEQU	55$			; NO THEN ERROR
	BBSS	R1,TTY$L_IS_SPECIFYED(R11),55$; ONLY ALLOW ONE OF EACH ITEM
					; TYPE.
	CASE	R1,TYPE=W,<- ;DISPATCH ON THE ITEM CODE
		MODIFIERS,-
		EDITMODE,-
		TIMEOUT,-
		TERM,-
		PROMPT,-
		INISTRNG,-
		PICSTRNG,-
		FILLCHR,-
		INIOFFSET,-
		ALTECHSTR>
	BRB	55$

;
; ALLOCATE BUFFER AND DO FINAL VALIDATION
;
300$:
;
; VALIDATION BEFORE ALLOCATING BUFFERS
;
	DECW	TTY$W_IS_INIOFF(R11)	; MAKE INDEX AN OFFSET
	CMPW	TTY$W_IS_INIOFF(R11),TTY$L_IS_INILEN(R11); DOES THE INITIAL
				; STRING OFFSET STAY WITHIN THE INITIAL STRING
	BGTR	55$		; NO THEN ERROR OUT

;
; VALIDATION SPECIFIC TO READ VERIFY
;
	CMPL	#TRM$K_EM_RDVERIFY,TTY$L_IS_EDITMODE(R11); ARE WE A READ VERIFY
	BNEQ	305$			; NO THEN DON'T DO THE VALIDATION
	TSTL	TTY$L_IS_PICLEN(R11)	; ZERO LENGTH PICTURE STRING IS ILLEGAL
	BEQL	55$
	CMPL	TTY$L_IS_INILEN(R11),TTY$L_IS_PICLEN(R11); IS THE PICTURE STRING
	BNEQ	55$			; LONG ENOUGH? NO THEN ERROR OUT
	INCW	TTY$W_IS_INIOFF(R11)	; UP THE INITIAL OFFSET
305$:
	BBC	#TT$V_SCRIPT,UCB$L_DEVDEPEND(R5),310$; RTE TERMINAL LINE ?
	INCL	R7			; ADD RTE PROMPT SIZE
	BISL2	#TTY$M_ST_PROMPT,R8	; ENSURE FUNCTION IS A RWP
	BISL2	#TTY$M_ST_EDITREAD,-
		IRP$Q_TT_STATE(R10)	; ENSURE FUNCTION IS A RWP
	BBSS	#IRP$V_FUNC,IRP$W_STS(R10),310$; ENSURE TRANFER DIRECTION RESET
310$:
;
; ADD IN THE DATA REGION
; AND THE DATA BUFFER SIZE THEN ALLOCATE THE READ PACKET
;
	ADDL	#TTY$L_RB_DATA,R7	; ADD IN THE DATA REGION
	ADDL	TTY$L_IS_BUFLEN(R11),R7	; AND THE AREA FOR THE DATA
	MOVL	R7,R1			; SAVE THE LENGTH IN R1
	JSB	G^EXE$BUFFRQUOTA	; CHECK QUOTA
	BLBC	R0,315$			; ITEM READ ERROR? IF YES THEN HANDLE IT
	JSB	G^EXE$ALLOCBUF		; ALLOCATE THE BUFFER
	BLBS	R0,317$			; ERROR THEN HANDLE AS SUCH
315$:	BRW	ITMREADERR
;
; ADJUST BUFFERED I/O QUOTA
;
317$:	MOVL	PCB$L_JIB(R4),R0	; GET JIB ADDRESS
	MOVZWL	R1,R1			; CONVERT TO LONG WORD COUNT
	SUBL	R1,JIB$L_BYTCNT(R0)	; ADJUST QUOTA WORD
;
; SETUP REGISTERS AND ADDITIONAL CONSTANT FIELDS
;
	MOVL	R2,R7			; GET THE READ BUFER ADDRESS
	MOVL	R7,IRP$L_SVAPTE(R10)	; SAVE THE ADDRESS
	MOVW	R1,IRP$W_BOFF(R10)	; SAVE THE SIZE AS A QUOTA
	MOVW	R1,TTY$W_RB_SIZE(R7)	; SAVE THE SIZE FOR THE SYSTEM
	MOVAB	TTY$L_RB_DATA(R7),R9	; AND GET THE BEGINNING OF THE DATA AREA
;
; FILL IN NEWLY ALLOCATED READ BUFFER
;
; REGISTERS ARE AS FOLLOWS:
;
;	R4 = PCB ADDRESS
;	R5 = UCB ADDRESS
;	R7 = READ BUFFER ADDRESS
;	R9 = BEGINNING OF THE DATA AREA (USED AS POINTER TO THE NEXT FREE
;	     ADDRESSES IN THE READ BUFFER)
;	R10 = IRP ADDRESS
;	R11 = STACK BUFFER ADDRESS
;
;
; COPY IN PROMPT AND ASSOCIATED DATA
;
	MOVQ	TTY$L_IS_PRM(R11),R0	; GET THE ADDRESS AND LENGTH OF THE
	MOVW	R1,TTY$W_RB_PRMLEN(R7)	; COPY IN THE LENGTH
	BBC	#TTY$V_ST_PROMPT,R8,340$; DO WE HAVE A PROMPT
;
; HANDLE RTE MODE
;
	BBC	#TT$V_SCRIPT,UCB$L_DEVDEPEND(R5),320$; IS THIS RTE MODE
	MOVB	@#PMS$GB_PROMPT,(R9)[R1]; PUT THE CHARACTER IN PLACE
	INCW	TTY$W_RB_PRMLEN(R7)	; INCREMENT THE PROMPT LENGTH
	INCL	R9			; ADD 1 TO THE CURRENT ADDRESS
320$:	TSTL	R1			; ANY CHARACTERS TO MOVE
	BEQL	340$			; NO THEN GO AROUND
	ADDL	R1,R9			; UPDATE THE ENDING ADDRESS
;
; TRANSLATE FOR NON-LOWER CASE TERMINALS IF NECESSARY
;
	BBS	#TT2$V_FALLBACK,UCB$L_DEVDEPND2(R5),327$
	BBS	#TT$V_LOWER,-		; IS THIS LOWER CASE
		UCB$L_DEVDEPEND(R5),330$; NO THEN CONTINUE ON
325$:	BBS	#TTY$V_ST_PASALL,R8,330$	; NO TRANSLATE IF PASSALL
	BBS	#TT$V_PASSALL,-
		UCB$L_DEVDEPEND(R5),330$; CHECK FOR PASSALL OR PASTHRU
	BBS	#TT2$V_PASTHRU,-
		UCB$L_DEVDEPND2(R5),330$; ...
327$:
	PUSHR	#^M<R7,R8>			; NO - THEN SAVE R7 AND R8
	CLRL	R8			; ASSUME NO LOWER CASE
	BBS	#TT$V_LOWER,-		; IS THIS LOWER CASE
		UCB$L_DEVDEPEND(R5),329$; NO THEN CONTINUE ON
	MOVL	#1,R8			; LOW BIT SET MEANS TRANSLATE TO LOWER
329$:	MOVAB	TTY$A_RB_PRM(R7),R2	; WE MUST MOVE TRANSLATED SO GET DEST ADDRESS
	MOVL	TTY$L_IS_PRMBUF(R11),R7	; GET THE USERS BUFFER LENGTH (FOR FALLBACK
	MOVL	R0,R6			; GET THE ADDRESS OF THE STRING
	MOVL	R1,R3			; AND LENGTH TO MOVE.
	BSBW	MOVE_TRANSLATE		; THEN TRANSLATE UNTILL THE HART'S CONTENT
	POPR	#^M<R7,R8>		; RESTORE R7
	BRB	340$
	

330$:	MOVC3	R1,(R0),TTY$A_RB_PRM(R7)	; MOVE IN THE CHARACTERS IN THE PROMPT
340$:
;
; setup the data field
;
	MOVL	R9,TTY$L_RB_TXT(R7)	; SAVE THE ADDRESS OF THE BEGINNING
	MOVL	R9,TTY$L_RB_LIN(R7)	; THE DATA IN TXT AND LIN
	CLRW	TTY$W_RB_LINOFF(R7)	; ZERO OUT FIELDS IN THE READ BUFFER
	CLRW	TTY$W_RB_LINREST(R7)
	CLRW	TTY$W_RB_TXTOFF(R7)
	CLRW	TTY$W_RB_MODE(R7)	; CLEAN OUT THE REPROMPT MODES
	CLRW	TTY$W_RB_RDSTATE(R7)
	CLRL	TTY$L_RB_ECHSTR(R7)	; CLEAN THE ECHO STRING
	ADDL	TTY$L_IS_BUFLEN(R11),R9	; ADD IN THE BUFFER TO OUR COUNTS
	MOVW	TTY$L_IS_BUFLEN(R11),TTY$W_RB_TXTSIZ(R7); MOVE IN THE BUFFER LENGTH
	MOVL	TTY$L_IS_BUF(R11),TTY$L_RB_UVA(R7); AND SAVE THE USERS ADDRESS
;
; MOVE IN INITIAL STRING
;
	BBC	#TRM$_INISTRNG,TTY$L_IS_SPECIFYED(R11),350$; DO WE HAVE A STRING
	MOVQ	TTY$L_IS_INI(R11),R0	; GET THE ADDRESS AND LENGTH
	MOVW	R1,TTY$W_RB_TXTOFF(R7)	; PUT THE LENGTH IN THE RIGHT PLACE
	MOVW	R1,TTY$W_RB_LINOFF(R7)	; AND THE LINE COUNTER
	BEQL	350$			; NO INITIAL STRING THEN NO NEED TO
					; CHECK FOR UPPER CASE
;
; TRANSLATE INITIAL STRING FROM LOWER CASE TO UPPER CASE IF NECESSARY
;
	MOVL	8(SP),R5		; RESTORE THE UCB ADDRESS
	BBS	#TT2$V_FALLBACK,UCB$L_DEVDEPND2(R5),344$; FALLBACK THEN TRANSLATE
	BBC	#TRM$V_TM_CVTLOW,TTY$L_IS_MODIFY(R11),345$; ARE WE CONVERTING
342$:	BBS	#TTY$V_ST_PASALL,R8,345$	; NO TRANSLATE IF PASSALL
	BBS	#TT$V_PASSALL,-
		UCB$L_DEVDEPEND(R5),345$	; CHECK FOR PASSALL OR PASTHRU
	BBS	#TT2$V_PASTHRU,-
		UCB$L_DEVDEPND2(R5),345$	; ...
344$:
	PUSHR	#^M<R7,R8>			; NO - THEN SAVE R7 AND R8
	CLRL	R8			; ASSUME NO LOWER CASE
	BBC	#TRM$V_TM_CVTLOW,-
		TTY$L_IS_MODIFY(R11),347$; BRANCH IF UPPER CASE ONLY
	MOVL	#1,R8			; LOW BIT SET MEANS TRANSLATE TO LOWER
347$:	MOVL	TTY$L_RB_TXT(R7),R2	; WE MUST MOVE TRANSLATED SO GET DEST ADDRESS
	MOVL	TTY$L_IS_INIBUF(R11),R7	; GET THE USERS BUFFER LENGTH
	MOVL	R0,R6			; GET THE ADDRESS OF THE STRING
	MOVL	R1,R3			; AND LENGTH TO MOVE.
	BSBW	MOVE_TRANSLATE		; THEN TRANSLATE UNTILL THE HART'S CONTENT
	POPR	#^M<R7,R8>		; RESTORE R7
	BRB	350$
345$:	MOVC3	R1,(R0),@TTY$L_RB_TXT(R7)	; MOVE IN THE INITIAL STRING
350$:
;
; HANDLE INITIAL STRING OFFSET
;
	BBC	#TRM$_INIOFFSET,TTY$L_IS_SPECIFYED(R11),360$; NOT SPECIFYED
;
; CHECK FOR READ VERIFY
;
	CMPL	#TRM$K_EM_RDVERIFY,TTY$L_IS_EDITMODE(R11); ARE WE READ VERIFYING
	BNEQ	355$			; NO THEN HANDLE NORMALY
	MOVL	TTY$W_IS_INIOFF(R11),TTY$W_RB_LINOFF(R7); SAVE THE INITIAL OFFSET
	BRB	360$
;
; NORMAL INITIAL OFFSETS
;
355$:	TSTW	TTY$W_IS_INIOFF(R11)	; IS THERE REALY AN INITIAL OFFSET?
	BLSS	360$			; no then do nothing
	SUBB3	TTY$W_IS_INIOFF(R11),-	; GET THE LENGTH TO ECHO
		TTY$L_IS_INILEN(R11),TTY$B_RB_ECHLEN(R7)
	MOVZWL	TTY$W_IS_INIOFF(R11),R1	; GET THE INITIAL OFFSET INTO A LONG WORD
	ADDL3	R1,TTY$L_RB_TXT(R7),-	; GET THE LOCATION OF THE FIRST CHARACTER
		TTY$L_RB_ECHSTR(R7)
	MOVZBW	#TTY$K_ER_ECHLINE,TTY$W_RB_MODE(R7); AND SETUP THE ECHOING CORRECTLY
;	
; MOVE IN PICTURE STRING
;
360$:	BBC	#TRM$_PICSTRNG,TTY$L_IS_SPECIFYED(R11),370$
	MOVQ	TTY$L_IS_PIC(R11),R0	; GET THE ADDRESS AND LENGTH
	MOVW	R1,TTY$W_RB_PICLEN(R7)	; KEEP THE PICTURE STRING LENGTH
	MOVL	R9,TTY$L_RB_PIC(R7)	; AND THE ADDRESS OF IT IN THE BUFFER
	ADDL	R1,R9			; UPDATE THE POINTER
	MOVC3	R1,(R0),@TTY$L_RB_PIC(R7)	; MOVE IN THE PICTURE STRING
370$:
;
; MOVE TERMINATOR MASK INTO BUFFER
;
	MOVAB	TTY$A_STANDARD,TTY$L_RB_TERM(R7); SETUP DEFAULT TERMINATOR MASK
	BBC	#TRM$_TERM,TTY$L_IS_SPECIFYED(R11),390$; DID THE USER SPECIFY
	MOVQ	TTY$L_IS_TERM(R11),R0	; A TERMINATOR MASK, YES THEN GET IT
	MOVL	R9,TTY$L_RB_TERM(R7)	; TELL WHERE THE MASK WILL END UP
	MOVC5	R1,(R0),#0,#32,(R9)	; MOVE THE MASK IN ZEROING UNUSED BITS
	MOVL	R3,R9			; MOVE R9 TO THE END OF USED SPACE
390$:
	BBC	#TRM$_ALTECHSTR,TTY$L_IS_SPECIFYED(R11),400$
	MOVQ	TTY$L_IS_AES(R11),R0	; GET THE ALTERNATE ECHO LEN AND ADR
	MOVW	R1,TTY$W_RB_AESLEN(R7)	; MOVE IN THE LENGTH
	BEQL	400$			; NO LENGTH THEN DON'T BOTHER
	MOVL	R9,TTY$L_RB_AES(R7)	; ELSE GET THE ADDRESS
	MOVC3	R1,(R0),(R9)		; AND MOVE IN THE DATA
	MOVL	R3,R9			; UPDATE THE END ADDRESS
	BISL	#TTY$M_ST_ECHAES,R8	; SET THE FLAG INDICATING FIRST CHARACTER
400$:
;
; SETUP TIMEOUT
;
	MOVW	TTY$L_IS_TIMEOUT(R11),TTY$W_RB_TIMOS(R7); MOVE TIMEOUT IN
;
; MOVE FILL CHARACTERS INTO THEIR PLACE
;
	MOVW	TTY$W_IS_FILLCHR(R11),TTY$B_RB_RVFCLR(R7); MOVE THE FILL 
					; AND CLEAR CHARACTER INTO PLACE
ASSUME TTY$B_RB_RVFCLR+1 EQ TTY$B_RB_RVFFIL
;
; IF THIS IS A READ VERIFY THEN WE HAVE TO SKIP MARKERS
;
	CMPL	#TRM$K_EM_RDVERIFY,TTY$L_IS_EDITMODE(R11); MAKE SURE WE ARE IN READ VRIFY
	BNEQ	650$			; NO THEN SKIP THE WHOLE THING
	MOVZWL	TTY$W_RB_LINOFF(R7),R0	; GET THE INITIAL OFFSET
	DECW	TTY$W_RB_LINOFF(R7)	; MOVE BACK ONE CHARACTER TO MAKE OFFSET
					; AN INDEX ONLY AFFECTIVE FOR RIGHT FIELDS
	BBS	#TRM$V_TM_R_JUST,TTY$L_IS_MODIFY(R11),640$; LITTLE WORK FOR RIGHT JUSTIFYED FIELDS
600$:	TSTB	@TTY$L_RB_PIC(R7)[R0]	; IS THIS A MARKER CHARACTER
	BNEQ	610$			; NO THEN WE ARE DONE
	INCL	R0			; ELSE MOVE OVER 1 CHARACTER
	CMPW	R0,TTY$W_RB_TXTOFF(R7)	; ARE WE AT THE END OF THE FIELD
	BLSS	600$			; NO THEN CONTINUE
	MOVZWL	TTY$W_RB_LINOFF(R7),R0	; GET THE INITIAL OFFSET
	INCL	R0			; ACCOUNT FOR THE RIGHT JUSTIFY CHANGE 
610$:	MOVW	R0,TTY$W_RB_LINOFF(R7)	; UPDATE THE OFFSET
640$:	BBC	#TTY$V_ST_NOECHO,R8,645$; IS THIS A NOECHO FIELD
	CLRL	R0			; YES THEN DON'T ECHO ANY INITIAL STRING
645$:	MOVAB	TTY$A_RB_PRM(R7),TTY$L_RB_ECHSTR(R7); GET THE ADDRESS TO START
	ADDB3	TTY$W_RB_PRMLEN(R7),R0,TTY$B_RB_ECHLEN(R7); AND THE LENGTH TO ECHO
	CLRW	TTY$W_RB_LINREST(R7)	; INIT FIELD
	MOVZBW	#TTY$K_ER_RVECHO,TTY$W_RB_MODE(R7); SETUP THE ECHO MODE
650$:
;
; CLEANUP AND QUEUE THE PACKET
;
	POPR	#^M<R3,R4,R5>		; restore the registers
	MOVL	TTY$L_IS_MODIFY(R11),TTY$L_RB_MOD(R7); MOVE THE MODIFIERS
					; INTO PLACE

;
; TEMPORARYLY SETUP THE MODIFIER BITS IN THE FUNCTION CODE
;

	BICL	#^C<TRM$M_TM_CVTLOW!-	; CLEAR THE NEW MODIFIER BITS
		TRM$M_TM_DSABLMBX!-
		TRM$M_TM_NOECHO!-
		TRM$M_TM_NOFILTR!-
		TRM$M_TM_PURGE!-
		TRM$M_TM_TIMED!-
		TRM$M_TM_TRMNOECHO!-
		TRM$M_TM_ESCAPE!-
		TRM$M_TM_REFRESH>,-
		TTY$L_IS_MODIFY(R11)
		
	BISW	TTY$L_IS_MODIFY(R11),-	; GET THE MODIFIERS OUT OF OUR WORD
		IRP$W_FUNC(R3)		; AND PUT THEM IN THE FUNCTION CODE SLOT
; END TEMPORARY
	MOVL	R8,IRP$Q_TT_STATE+4(R3)	; SETUP STATE QUAD WORD
	INSV	#TTY$C_FC_READ,#IRP$V_FCODE,#IRP$S_FCODE,IRP$W_FUNC(R3)
	JMP	G^EXE$QIODRVPKT

;
; ERROR HANDLEING ROUTINES
;
BDPRMERR:
	MOVZWL	TTY$W_IL_TYPE(R9),R1	; RETURN THE BAD ITEM # IN R1
	MOVZWL	#SS$_BADPARAM,R0	; AND THE ERROR IN R0
ITMREADERR:
	POPR	#^M<R3,R4,R5>		; RESTORE STATE
	JMP	G^EXE$ABORTIO		; and abort the IO


;++
; ALTECHSTR
;
; DESCRIPTION:
;
;	STRING TO BE ECHOED UPON THE FIRST VALID CHARACTER
; THAT IS TYPED.
;--
ALTECHSTR:
	CMPL	TTY$L_IS_EDITMODE(R11),#TRM$K_EM_RDVERIFY; ARE WE A READ VERIFY READ
	BNEQ	BDPRMERR		; NO THEN ERROR OUT
	MOVL	TTY$L_IL_ADR(R9),R0	; GET THE ADDRESS OF THE PROMPT
	MOVZWL	TTY$W_IL_LEN(R9),R1	; AND THE LENGTH
	BEQL	20$			; NO PROMPT THEN DO NOTHING
	MOVQ	R0,TTY$L_IS_AES(R11)	; SAVE THE PROMPT LENGTH AND ADDRESS
ASSUME	TTY$L_IS_AES+4 EQ TTY$L_IS_AESLEN
	MOVL	TTY$L_IS_ACMODE(R11),R3	; SETUP OUR ACCESS MODE
	JSB	G^EXE$PROBER		; CHECK THE ACCESS ON THE BUFFER
	BLBS	R0,10$			; NO ERROR THEN CONTINUE
	BRW	ITMREADERR		; ELSE ERROR OUT
10$:	ADDL	TTY$L_IS_AESLEN(R11),R7	; ADD IN THE LENGTH
20$:	BRW	ITEMLOOP		; CONTINUE ON NORMALY




;++
; EDITMODE
;
; DESCRIPTION
;	VALIDATES ARGUMENTS AND SETS STATE BITS FOR THE DIFFERENT TYPE OF
; EDIT MODES.
;--
EDITMODE:
	TSTW	TTY$W_IL_LEN(R9)	; LENGTH MUST BE ZERO
	BNEQ	BDPRMERR
	TSTL	TTY$L_IL_RETADR(R9)	; ALSO THE SECOND ADDRESS
	BNEQ	BDPRMERR
	MOVL	TTY$L_IL_ADR(R9),R0	; GET THE MODE
	CMPL	#TRM$K_EM_RDVERIFY,R0	; AND CHECK IT FOR VALITITY
	BGTR	BDPRMERR		; NOT VALID THEN ERROR
	BNEQ	10$			; NOT READ VERIFY THEN SKIP
	BISL	#TTY$M_ST_RDVERIFY,IRP$Q_TT_STATE(R10); SETTING READVERIFY STATE
	BISL	#TTY$M_ST_EDITING,R8	; YES THEN SET EDITING
10$:	MOVL	R0,TTY$L_IS_EDITMODE(R11); SAVE THE MODE

	BRW	ITEMLOOP


;++
;FILLCHR
;
; DESCRIPTION:
;	MOVE THE FILL CHARACTERS INTO THE STACK STRUCTURE.
; FILL CHARACTERS ARE USED BY READ VERIFY.
;--
FILLCHR:
	CMPL	TTY$L_IS_EDITMODE(R11),#TRM$K_EM_RDVERIFY; ARE WE A READ VERIFY READ
	BNEQ	GOBAD			; NO THEN ERROR OUT
	TSTW	TTY$W_IL_LEN(R9)	; LENGTH MUST BE ZERO
	BNEQ	GOBAD
	TSTL	TTY$L_IL_RETADR(R9)	; ALSO THE SECOND ADDRESS
	BNEQ	GOBAD
	MOVW	TTY$L_IL_ADR(R9),TTY$W_IS_FILLCHR(R11); MMOVE IN THE FILL CHARACTERS
	BRW	ITEMLOOP		; THEN CONTINUE ON WITH THE LIST

;++
; INIOFFSET
;
; DESCRIPTION:
;	SAVE THE OFFSET INTO THE INITIAL STRING, RANGE CHECKING MUST BE
; DONE LATER TO ALLOW THE ITEMS TO APPEAR IN ANY ORDER.
INIOFFSET:
	TSTW	TTY$W_IL_LEN(R9)	; LENGTH MUST BE ZERO
	BNEQ	GOBAD
	TSTL	TTY$L_IL_RETADR(R9)	; ALSO THE SECOND ADDRESS
	BNEQ	GOBAD
	MOVW	TTY$L_IL_ADR(R9),TTY$W_IS_INIOFF(R11); MOVE IN THE OFFSET
	BLSS	GOBAD			; NO NEGITIVE NUMBERS ALLOWED
	BRW	ITEMLOOP		; THEN CONTINUE ON WITH THE LIST

;++
; INISTRNG
;
; DESCRIPTION:
;	CHECK ACCESS TO THE USERS INITIAL STRING.
;--
INISTRNG:
	MOVL	TTY$L_IL_ADR(R9),R0	; GET THE ADDRESS OF THE INITIAL STRING
	MOVZWL	TTY$W_IL_LEN(R9),R1	; AND THE LENGTH
	MOVQ	R0,TTY$L_IS_INI(R11)	; SAVE THE INITIAL STRING LENGTH AND ADDRESS
ASSUME	TTY$L_IS_INI+4 EQ TTY$L_IS_INILEN
	MOVL	R1,TTY$L_IS_INIBUF(R11)	; KEEP THE LENGTH
	BEQL	20$			; NO INITIAL STRING THEN DO NOTHING
	MOVL	TTY$L_IS_ACMODE(R11),R3	; SETUP OUR ACCESS MODE
	JSB	G^EXE$PROBER		; CHECK THE ACCESS ON THE BUFFER
	BLBC	R0,10$			; NO ERROR THEN CONTINUE
	BBS	#TT2$V_FALLBACK,UCB$L_DEVDEPND2(R5),30$
15$:	CMPL	TTY$L_IS_INILEN(R11),TTY$L_IS_BUFLEN(R11); DOES THIS STRING FIT INTO THE BUFFER
	BGTR	GOBAD			; NO THEN INFORM THE USER.
	BISL	#TTY$M_ST_EDITREAD,IRP$Q_TT_STATE(R10); MAKE SURE THE PROMPT IS ECHOED
20$:	BRW	ITEMLOOP		; CONTINUE ON NORMALY
10$:	BRW	ITMREADERR		; ELSE ERROR OUT
30$:	PUSHL	R9			; SAVE R9 OVER THE CALL
	MOVL	TTY$L_IS_INI(R11),R1	; RESTORE ADDRESS AND LENGTH
	MOVL	TTY$L_IS_INILEN(R11),R0	; AND THE LENGTH
	BSBW	ADDFALL			; CALCULATE THE ADDITIONAL
					; CHARACER COUNT OF FALLBACK
	ADDL	R9,TTY$L_IS_INILEN(R11)	;ADD IN THE COUNT
	POPL	R9			; RESTORE R9
	BRB	15$			;

GOBAD:	BRW	BDPRMERR

;++
; MODIFIERS
;
; DESCRIPTION
;	PROCESS MODIFIER ITEM LIST ENTRY.  VALIDATES ARGUMENTS AND
; ABORTS ON ERRORS.  SETS APPROPRIATE BITS IN THE UNIT STATE VECTOR
;--
MODIFIERS:
	TSTW	TTY$W_IL_LEN(R9)	; LENGTH MUST BE ZERO
	BNEQ	GOBAD
	TSTL	TTY$L_IL_RETADR(R9)	; ALSO THE SECOND ADDRESS
	BNEQ	GOBAD
	MOVL	TTY$L_IL_ADR(R9),R0	; GET THE MODIFIERS
	BISL	R0,TTY$L_IS_MODIFY(R11)	; SAVE THEM BUT DON'T DESTROY
					; WHAT IS ALREADY THERE
	BICL	#TRM$M_TM_CVTLOW!-	; CLEAR ALL VALID BITS
		TRM$M_TM_DSABLMBX!-
		TRM$M_TM_NOECHO!-
		TRM$M_TM_NOFILTR!-
		TRM$M_TM_PURGE!-
		TRM$M_TM_TIMED!-
		TRM$M_TM_TRMNOECHO!-
		TRM$M_TM_ESCAPE!-
		TRM$M_TM_REFRESH!-
		TRM$M_TM_NOEDIT!-
		TRM$M_TM_R_JUST!-
		TRM$M_TM_AUTO_TAB!-
		TRM$M_TM_NORECALL,-
		R0
	BNEQ	GOBAD			; MAKE SURE THAT THE MBZ BITS ARE Z
	ASHL	#TTY$V_ST_NOECHO-	; Move function code and its
		-IO$V_NOECHO,-		; modifiers into bits 9-25 of
		TTY$L_IS_MODIFY(R11),R0	; a register.
	BICL	#^C<TTY$M_ST_NOECHO!-	; Clear all bits except NOECHO
		TTY$M_ST_NOFLTR!-	; NOFLTR, and
		TTY$M_ST_ESCAPE!-	; ESCAPE
		TTY$M_ST_REFRSH>,R0	; REFRESH if specified.
	BISL	R0,R8			; SET THE NECESSARY BITS
	BBC	#TRM$V_TM_NOEDIT,TTY$L_IS_MODIFY(R11),10$; IF NOEDITING THEN MAKE IT NOEDITING
	BICL	#TTY$M_ST_EDITING,R8	; ...
10$:	BRW	ITEMLOOP		; AND GO BACK TO THE ITEM LIST LOOP

;++
;PICSTRNG
;
; DESCRIPTION:
;	VALIDATE THE LENGTH AND ADDRESS OF THE PICTURE STRING AND INCREASE
; THE BUFFER SIZE TO ACCOMIDATE IT.
;--
PICSTRNG:
	CMPL	TTY$L_IS_EDITMODE(R11),#TRM$K_EM_RDVERIFY; ARE WE A READ VERIFY READ
	BNEQ	GOBAD			; NO THEN ERROR OUT
	MOVL	TTY$L_IL_ADR(R9),R0	; GET THE ADDRESS OF THE PROMPT
	MOVZWL	TTY$W_IL_LEN(R9),R1	; AND THE LENGTH
	BEQL	20$			; NO PROMPT THEN DO NOTHING
	MOVQ	R0,TTY$L_IS_PIC(R11)	; SAVE THE PROMPT LENGTH AND ADDRESS
ASSUME	TTY$L_IS_PIC+4 EQ TTY$L_IS_PICLEN
	MOVL	TTY$L_IS_ACMODE(R11),R3	; SETUP OUR ACCESS MODE
	JSB	G^EXE$PROBER		; CHECK THE ACCESS ON THE BUFFER
	BLBS	R0,10$			; NO ERROR THEN CONTINUE
	BRW	ITMREADERR		; ELSE ERROR OUT
10$:	ADDL	TTY$L_IS_PICLEN(R11),R7	; ADD IN THE LENGTH
20$:	BRW	ITEMLOOP		; CONTINUE ON NORMALY

;++
;PROMPT
;
; DESCRIPTION:
;	VALIDATE THE PROMPT ADDRESS AND LENGTH THEN SETUP THE NECESSARY STATE
; TO OUTPUT THE PROMPT
;--
PROMPT:
	MOVL	TTY$L_IL_ADR(R9),R0	; GET THE ADDRESS OF THE PROMPT
	MOVZWL	TTY$W_IL_LEN(R9),R1	; AND THE LENGTH
	BEQL	20$			; NO PROMPT THEN DO NOTHING
	MOVQ	R0,TTY$L_IS_PRM(R11)	; SAVE THE PROMPT LENGTH AND ADDRESS
ASSUME	TTY$L_IS_PRM+4 EQ TTY$L_IS_PRMLEN
	MOVL	R1,TTY$L_IS_PRMBUF(R11)	; THE BUFFER'S LENGTH
	MOVL	TTY$L_IS_ACMODE(R11),R3	; SETUP OUR ACCESS MODE
	JSB	G^EXE$PROBER		; CHECK THE ACCESS ON THE BUFFER
	BLBS	R0,10$			; NO ERROR THEN CONTINUE
	BRW	ITMREADERR		; ELSE ERROR OUT
10$:	BISL	#TTY$M_ST_PROMPT,R8	; SET THE PROMPTED READ BIT
	BISL	#TTY$M_ST_EDITREAD,IRP$Q_TT_STATE(R10); MAKE SURE THE PROMPT IS ECHOED
	BBS	#TT2$V_FALLBACK,UCB$L_DEVDEPND2(R5),30$; HANDLE FALLBACK
15$:	ADDL	TTY$L_IS_PRMLEN(R11),R7	; ADD IN THE LENGTH
	BBSS	#IRP$V_FUNC,IRP$W_STS(R10),20$; RESET TRANSFER DIRECTION
20$:	BRW	ITEMLOOP		; CONTINUE ON NORMALY

30$:	PUSHL	R9			; SAVE R9 OVER THE CALL
	MOVL	TTY$L_IS_PRM(R11),R1	; RESTORE ADDRESS AND LENGTH
	MOVL	TTY$L_IS_PRMLEN(R11),R0	; AND THE LENGTH
	BSBW	ADDFALL			; CALCULATE THE ADDITIONAL
					; CHARACER COUNT OF FALLBACK
	ADDL	R9,TTY$L_IS_PRMLEN(R11)	;ADD IN THE COUNT
	POPL	R9			; RESTORE R9
	BRB	15$			;

;++
; TERM
;
; DESCRIPTION:
;	SETUP TERMINATOR MASK. AND VALIDATE IT.
; THE TERMINATOR MASK SHORT FORM IS SPECIFYED BY SETTING THE LENGTH
; TO ZERO AND THE BIT MASK GOES IN ADR.  THE LONG FORM LENGTH GOES
; IN LENGTH AND THE ADDRESS IS PLACED IN ADR.
;--
TERM:
	MOVL	TTY$L_IL_ADR(R9),R0	; GET THE TERMINATOR ADDRESS
	MOVZWL	TTY$W_IL_LEN(R9),R1	; AND THE LENGTH
	BNEQ	10$			; SHORT FORM NO THEN HANDLE LONG FORM
	MOVZBL	#4,TTY$L_IS_TERMLEN(R11); SHORT FORM LENGTH
	MOVAL	TTY$L_IL_ADR(R9),TTY$L_IS_TERM(R11); AND THE ADDRESS OF THE MASK
	BRB	20$

10$:	MOVQ	R0,TTY$L_IS_TERM(R11)	; SAVE THE TERMINATOR MASK AND LENGTH
ASSUME	TTY$L_IS_TERM+4 EQ TTY$L_IS_TERMLEN
	MOVL	TTY$L_IS_ACMODE(R11),R3	; GET THE ACCESS MODE
	JSB	G^EXE$PROBER		; AND PROBE THE TERMINATOR MASK
	BLBS	R0,20$
	BRW	ITMREADERR		; NO GOOD THENB TELL HIM SO

20$:	ADDL	#32,R7			; 16 BYTES FOR TERMINATOR MASK
	BISL	#TTY$M_ST_TERMNORM,R8	; NON-STANDARD TERMINATOR
					; MASK THEN LET THE TERMINATORS THRU
30$:	BRW	ITEMLOOP		; IF OK THEN GO ON TO THE NEXT ONE

;++
; TIMEOUT
;
; DESCRIPTION
;	VALIDATES ARGUMENTS, SAVES TIMEOUT VALUE AND SETS TIMED FUNCTION
; BITS.
;--
TIMEOUT:
	TSTW	TTY$W_IL_LEN(R9)	; LENGTH MUST BE ZERO
	BNEQ	20$
	TSTL	TTY$L_IL_RETADR(R9)	; ALSO THE SECOND ADDRESS
	BNEQ	20$
	MOVL	TTY$L_IL_ADR(R9),TTY$L_IS_TIMEOUT(R11); GET THE TIMEOUT VALUE
	BBSS	#TRM$V_TM_TIMED,TTY$L_IS_MODIFY(R11),10$; SET THE TIMEOUT MODIFIER
10$:	BRW	ITEMLOOP
20$:	BRW	BDPRMERR

	.SBTTL	TTY$FDTWRITE - Function decision routine for terminal writes

;++
; TTY$FDTWRITE - FUNCTION DECISION ROUTINE FOR TERMINAL WRITE FUNCTIONS
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS THE FUNCTION DECISION ROUTINE FOR TERMINAL WRITE FUNCTIONS.
;
; THE QIO PARAMETERS FOR TERMINAL WRITES ARE:
;
;	P1 = ADDRESS OF THE BUFFER
;	P2 = SIZE OF THE BUFFER
;	P3 = UNUSED
;	P4 = CARRIAGE CONTROL SPECIFIER (SEE EXE$CARRIAGE)
;
; THE FUNCTION PARAMETERS ARE VALIDATED AND IF CORRECT, a write packet
; that points to the IRP is sent to the terminal driver's write start
; I/O routine (ALTSTART in the DDT).
;
;
; 	IRP$W_BOFF CONTAINS THE QUOTA FOR THIS I/O
;	IRP$W_BCNT CONTAINS THE TRANSFER COUNT
;	IRP$W_FUNC IS SET FOR A FAST CASE ON FUNCTION TYPE
;
; FOR IO$_WRITEPBLK OR IO$M_NOFORMAT, TTY$V_ST_WRTALL IS SET TO PREVENT
; FORMATTING OF THE DATA.
;
;	If IO$_REFRESH is specified, this routine sets TTY$V_ST_REFRSH
;	to refresh a delayed read when the write completes.
;
; INPUTS:
;
;	R3 = I/O PACKET
;	R4 = PCB OF PROCESS
;	R5 = UCB
;	R6 = ASSIGNED CCB
;	R7 = FUNCTION CODE
;	AP = ADDRESS OF FIRST USER QIO PARAMETER
;
; OUTPUTS:
;
;	IF THE I/O IS IN ERROR THEN IT IS COMPLETED BY "EXE$ABORTIO".
;	If the I/O is valid, then the address of the buffered block is
;	loaded into R3, and the block queued to EXE$ALTQUEPKT.
;
; COMPLETION CODES:
;
;	SS$_ACCVIO - ACCESS VIOLATION ON BUFFER ( FROM "EXE$WRTCHK" )
;	SS$_INSFMEM - INSUFFICIENT MEMORY FOR REQUEST
;	SS$_EXQUOTA - BUFFERED I/O QUOTA EXCEEDED
;--

TTY$FDTWRITE::				;
	MOVL	P1(AP),R6		; GET USER BUFFER VIRTUAL ADDRESS
	CLRL	IRP$B_CARCON(R3)	; ASSUME NO CARRIAGE CONTROL SPECIFIER
	CMPZV	#IRP$V_FCODE,#IRP$S_FCODE,R7,#IO$_WRITEPBLK; WRITE PHYSICAL BLOCK?
	BEQL	10$			; IF EQL THEN YES
	MOVL	P4(AP),IRP$B_CARCON(R3)	; GET CARRIAGE CONTROL SPECIFIER
	JSB	G^EXE$CARRIAGE		; CONVERT THE CARRIAGE CONTROL
10$:	MOVZBL	IRP$B_CARCON(R3),R8	; CALC NUMBER OF EXTRA PLACES
	MOVZBL	IRP$B_CARCON+2(R3),R2	; NEEDED FOR CONTROL
	ADDL	R2,R8			;
	MOVL	R6,R0			; SET UP FOR WRITE CHECK CALL
	MOVZWL	P2(AP),R7		; GET TRANSFER SIZE
	MOVL	R7,R1			; COPY TRANSFER SIZE
	BEQL	12$			; SKIP CHECK IF ZERO
	JSB	G^EXE$WRITECHK		; CHECK BUFFER ACCESS
;
; INIT STATE FIELD
;					; NO RETURN MEANS NO ACCESS
12$:
	CLRQ	IRP$Q_TT_STATE(R3)	; INIT STATE REGION
	MOVZWL	#<TTY$M_ST_WRITE>,-
		IRP$Q_TT_STATE(R3)	; INIT WRITE FUNCTION

;
; SET WRITE PASSALL STATE FOR WRTPASSALL
;
	BBS	#IO$V_NOFORMAT,IRP$W_FUNC(R3),15$; BR IF NO FORMAT SPECIFIED
	CMPZV	#IRP$V_FCODE,#IRP$S_FCODE,IRP$W_FUNC(R3),#IO$_WRITEPBLK; PASSALL WRITE?
	BNEQ	25$			; No passall, branch forward.

15$:
	BBSS	#TTY$V_ST_WRTALL,-	; Set no format mode for
		IRP$Q_TT_STATE+4(R3),17$	; write.
17$:	BBS	#TT2$V_FALLBACK,UCB$L_DEVDEPND2(R5),25$; NOT DOING FALLBACK THEN DON'T WORRIE
 
20$:	PUSHR	#^M<R3,R4,R5>		; SAVE SOME REGISTERS
	MOVAB	TTY$L_WB_DATA+4(R8)[R1],R1; ADD HEADER TO REQUEST AND CARRIAGE CONTROL
;
; CHECK BUFFERED I/O QUOTA
;
	JSB	G^EXE$BUFFRQUOTA	; CHECK QUOTA
	BLBS	R0,30$			; Branch forward on success.
	BRW	105$			; Otherwise, branch to error.
25$:	BRW	200$			; jump to the fallback logic
;
; Allocate the buffer.
;

30$:
	JSB	G^EXE$ALLOCBUF		; Allocate buffered I/O block.
	BLBS	R0,40$			; Branch forward on success.
	BRW	105$			; Otherwise, branch to error

40$:
					; exit.
	MOVL	(SP),R3			; RESTORE PACKET ADDRESS
	MOVL	R2,IRP$L_SVAPTE(R3)	; SAVE BLOCK ADDRESS IN PACKET
	ADDW	R8,IRP$W_BCNT(R3)	; ADJUST TRANSFER SIZE FOR CARRIAGE CONTROL
;
; ADJUST QUOTA
;
	MOVL	PCB$L_JIB(R4),R8	; GET JIB ADDRESS
	MOVZWL	R1,R1			; CONVERT COUNT TO LONGWORD
	SUBL	R1,JIB$L_BYTCNT(R8)	; ADJUST BUFFERED I/O QUOTA
	MOVW	R1,IRP$W_BOFF(R3)	; SAVE BLOCK SIZE AS QUOTA

;
;	MARK PACKET AS TERMINAL I/O
;
	CMPL	#4,R7			; No priority boost for programs
	BGEQ	45$			; that do small io
	BISW	#IRP$M_TERMIO,IRP$W_STS(R3)	; SET FLAG FOR GREATER PRIORITY
45$:					; INCREMENTS UPON COMPLETION

;
; SET UP THE BLOCK
;
	MOVZBL	#DYN$C_TWP,-		; Insert block type.
		TTY$B_WB_TYPE(R2)
	MOVL	R3,TTY$L_WB_IRP(R2)	; Insert IRP address.
	MOVAB	TTY$L_WB_DATA(R2),-	; Insert start of data address
		TTY$L_WB_NEXT(R2)	; in "next character" field.
	ADDL	#TTY$L_WB_DATA,R2	; POINT TO DATA
;
; INSERT INITIAL CARRIAGE CONTROL
;
	MOVAB	IRP$B_CARCON(R3),R8	; INSERT THE CHARACTERS
	BSBB	110$			;
;
; CHECK FOR UPPERCASE  AND FALLBACK
; DON'T WORRIE ABOUT THEM IF WE ARE IN WRITEALL MODE
;
	BBS	#TT2$V_FALLBACK,-
		UCB$L_DEVDEPND2(R5),47$		; NOT DOING FALLBACK THEN DON'T WORRIEA
	BBS	#TTY$V_ST_WRTALL,-		; If no format mode 
		IRP$Q_TT_STATE+4(R3),50$	; no translate.
	BBS	#TT$V_PASSALL,-
		UCB$L_DEVDEPEND(R5),50$	; CHECK FOR PASSALL OR PASTHRU
	BBS	#TT2$V_PASTHRU,-
		UCB$L_DEVDEPND2(R5),50$	; ...
	BBS	#TT$V_LOWER,-		; CHECK IF LOWER CASE ALLOWED
		UCB$L_DEVDEPEND(R5),50$	
47$:	BRW	150$
;
; COPY USER DATA TO BUFFER
;
50$:	MOVC3	R7,(R6),(R2)		; MOVE THE DATA
	MOVL	R3,R2			; COPY CURRENT END OF DATA
;
; THE USER DATA IS COPIED -- ADD TRAILING CARRIAGE RETURN IF NECESS.
;
60$:	POPR	#^M<R3,R4,R5>		; RESTORE REGISTERS
	MOVAB	IRP$B_CARCON+2(R3),R8	;
	BSBB	110$			; INSERT CHARACTERS

;
; If the write function specified IO$_REFRESH, set the appropriate bit
; position for the UCB state bits.
;

95$:					; Check for REFRESH bit.
	BBC	#IO$V_REFRESH,-		; If REFRESH is not specified,
		IRP$W_FUNC(R3),100$	; just branch forward.
	BBSS	#TTY$V_ST_REFRSH,-	; Otherwise, set the refresh
		IRP$Q_TT_STATE+4(R3),100$	; bit for the state longword.

;
; COMPLETE THE WRITE OPERATION
;
100$:	MOVL	IRP$L_SVAPTE(R3),R1	; GET BLOCK ADDRESS
	MOVL	R2,TTY$L_WB_END(R1)	; INSERT ADDRESS OF DATA END
	INSV	#TTY$C_FC_WRITE,#IRP$V_FCODE,#IRP$S_FCODE,IRP$W_FUNC(R3);
	MOVW	IRP$W_BCNT(R3),-	; Move the character count
		TTY$W_WB_BCNT(R1)	; into the write packet.
	TSTL	UCB$L_TL_PHYUCB(R5)	; Test for disconnected LUCB
	BEQL	101$			; Always que 1/2 duplex if so
	BBC	#TT$V_HALFDUP, -	; branch if full duplex
		UCB$L_DEVDEPEND(R5), -	; if half duplex, call normal
		102$			; tty$startio entry point
101$:	JMP	G^EXE$QIODRVPKT		; R3/addr of write IRP
102$:
	MOVL	R1,R3			; Set up write block address.
	JSB	G^EXE$ALTQUEPKT		; Queue packet to driver's write
					; STARTIO routine.
	JMP	G^EXE$QIORETURN		; Return to requesting process.
;
; ERROR IN PROCESSING
;
105$:	POPR	#^M<R3,R4,R5>		; RESTORE REGISTERS
	JMP	G^EXE$ABORTIO		; ABORT THE I/O
;
; SUBROUTINE TO INSERT PRE/SUF CARRIAGE CONTROL
;
110$:	MOVZBL	(R8),R0			; GET NUMBER OF CHARACTERS
	BEQL	130$			; IF EQL THEN NONE
	MOVB	1(R8),(R2)+		; INSERT CHARACTER
	BNEQ	130$			; IF NEQ THEN DONE
	MOVB	#TTY$C_CR,-1(R2)	; INSERT CARRIAGE RETURN TO START
	INCW	IRP$W_BCNT(R3)		; INCREASE BYTE COUNT FOR CR
120$:	MOVB	#TTY$C_LF,(R2)+		; INSERT LINE FEEDS
	SOBGTR	R0,120$			; UNTIL DONE
130$:	RSB				;

;
; TRANSLATE TO UPPERCASE
;
150$:	CLRL	R8
	BBS	#TT$V_LOWER,-		; CHECK IF LOWER CASE ALLOWED
		UCB$L_DEVDEPEND(R5),155$	
	MOVL	#1,R8
155$:	ADDL3	R9,R7,R3		; CALCULATE THE NEW STRING LENGTH
	BSBW	MOVE_TRANSLATE
	BRW	60$
;
; Figure out how many characters will be added to this write
; for fallback presentation
;

200$:	BBC	#TT2$V_FALLBACK,UCB$L_DEVDEPND2(R5),215$; NOT DOING FALLBACK THEN DON'T WORRIE
	PUSHR	#^M<R0,R1,R2,R3>	; save the registers destroyed by the
					; scan
	MOVL	R7,R0			; SETUP THE LENGTH
	MOVL	R6,R1			; AND THE ADDRESS
	BSBW	ADDFALL			; ADD IN THE FALLBACK COUNT
	POPR	#^M<R0,R1,R2,R3>	; RESTORE THE REGISTERS
	ADDL	R9,R1			; AND GET THE EXTRA SPACE
215$:	BRW	20$



	.SBTTL	TTY$FDTSETM -- FUNCTION DECISION ROUTINE FOR TERMINAL SET MODE
;++
; TTY$FDTSETM - FUNCTION DECISION ROUTINE FOR TERMINAL SET MODE FUNCTIONS
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS THE FUNCTION DECISION ROUTINE FOR TERMINAL SET MODE FUNCTIONS.
; THERE ARE TWO BASIC FUNCTIONS -- SET UP FOR CONTROL C AND SET MODE.
;
; THE FUNCTION CODE IS SET FOR A FAST CASE ON TYPE
;
; INPUTS:
;
;	R3 = I/O PACKET ADDRESS
;	R4 = PCB ADDRESS OF CURRENT PROCESS
;	R5 = UCB ADDRESS
;	R6 = CCB ADDRESS FOR ASSIGNED UNIT
;	AP = ADDRESS OF ARGUMENT LIST AT USER PARAMETERS
;
; OUTPUTS:
;
;	THE FUNCTION IS COMPLETED HERE BY "EXE$FINISHIO".
;
; IMPLICIT OUTPUTS:
;
; 	R3,R5 ARE PRESERVED.
;--
TTY$FDTSETM::				;
	INSV	#TTY$C_FC_SETM,#IRP$V_FCODE,#IRP$S_FCODE,IRP$W_FUNC(R3);
	MOVL	UCB$L_DEVDEPND2(R5),IRP$Q_TT_STATE+4(R3)	;INIT DEFAULT
	BRB	SET_COMMON

	.SBTTL	TTY$FDTSETC - FUNCTION DECISION ROUTINE FOR TERMINAL SET CHARS
;++
; TTY$FDTSETC - FUNCTION DECISION ROUTINE FOR TERMINAL SET CHARACTERISTICS FUNCTIONS
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE IS THE FUNCTION DECISION ROUTINE FOR TERMINAL SET MODE FUNCTIONS.
; THERE ARE TWO BASIC FUNCTIONS -- SET UP FOR CONTROL Y AND SET MODE.
;
; INPUTS:
;
;	R3 = I/O PACKET ADDRESS
;	R4 = PCB ADDRESS OF CURRENT PROCESS
;	R5 = UCB ADDRESS
;	R6 = CCB ADDRESS FOR ASSIGNED UNIT
;	AP = ADDRESS OF ARGUMENT LIST AT USER PARAMETERS
;
; OUTPUTS:
;
;	THE FUNCTION IS COMPLETED HERE BY "EXE$FINISHIO".
;	OR BY QUEUING IT TO FOR FOLLOW ON PROCESSING 
;	BY TTYSTRSTP.
;
; IMPLICIT OUTPUTS:
;
; 	R3,R5 ARE PRESERVED.
;--
TTY$FDTSETC::				;
	INSV	#TTY$C_FC_SETC,#IRP$V_FCODE,#IRP$S_FCODE,IRP$W_FUNC(R3);

SET_COMMON:
	FFS	#IO$V_MAINT,#9,-
		IRP$W_FUNC(R3),R1	; GET PRIMARY MODIFIER BIT
	CASE	R1,TYPE=B,LIMIT=#6,<-	; AND VECTOR TO SERVICE ROUTINE
	SET_MAINT,-
	SET_CTRLY,-
	SET_CTRLC,-
	SET_HANGUP,-
	SET_OUTBAND,-
	SET_CONNECT,-
	SET_DISCONNECT,-
	SET_PID,-
	SET_BRDCST>	


;
; PROCESS SET MODE OR CHARACTERISTICS
;
SET:
	BSBW	GET_PARAMS		; GET USER PARAMETERS
	MOVAL	IRP$L_MEDIA(R3),R1	; GET ADDRESS OF STORED USER DATA
	TSTW	2(R1)			; PAGE WIDTH 0?
	BLEQ	BAD_SET			; 0 IS BAD WIDTH
	CMPW	#TTY$C_MAXPAGWID,2(R1)	; RESTRICT WIDTH
	BGEQ	GOOD_SET		; FALL THROUGH IF > MAX

BAD_SET:MOVZWL	#SS$_BADPARAM,R0	; SET ERROR
	JMP	G^EXE$ABORTIO		; RETURN ON ERROR

GOOD_SET:
	MOVW	P3(AP),IRP$W_TT_PRMPT(R3) ; GET THE SPEED PARAMETER
	MOVW	P4(AP),IRP$W_TT_PRMPT+2(R3); SAVE FILLS
	MOVL	P5(AP),IRP$L_VAL5(R3)	; SAVE PARITY
	BICL3	#^C<^X0F>,IRP$L_VAL5(R3),R1; GET THE FRAME SIZE
	BEQL	5$			; NOTHING THEN QUEUE THE PACKET
	SUBL	#5,R1			; IS THIS IN RANGE
	BLSS	BAD_SET			; NO THEN BAD PARAMETER
	CMPL	R1,#3			; MUST BE BETWEEN 8 AND 5
	BGTR	BAD_SET			; NOT THERE THEN EXIT
	BICL	#^X0F,IRP$L_VAL5(R3)	; CLEAN THE OLD BITS
	BISL	R1,IRP$L_VAL5(R3)	; AND SET IN THE NEW ONES
5$:
QPKT:	JMP	G^EXE$QIODRVPKT		; QUEUE PACKET TO DRIVER



; STORE BROADCAST MASK IN LOGICAL UCB

SET_BRDCST:
	BSBW	GET_PARAMS			; GET USER ARGUMENTS
	MOVQ	(R1),UCB$Q_TL_BRKTHRU(R5)	; SAVE SPECIFIED MASK
	BRW	SET_DONE			; AND EXIT NORMALY

;
; Fill in the ucb fields and whatever else is needed to initiate 
; a connect to a vertual terminal
;

SET_CONNECT:
	BSBW	GET_LUCB
	INSV	#TTY$C_FC_CONNECT,#IRP$V_FCODE,#IRP$S_FCODE,IRP$W_FUNC(R3);
	BRW	QPKT			; QUEUE PACKET FOR FOLLOW ON PROCESSING


;	LOOK UP LUCB NAME IN IO DATA BASE
;	AND VALIDATE ACCESS TO IT FROM COMMAND CHANNEL

GET_LUCB:
	PUSHL	R3				; SAVE IRP ADDRESS
	JSB	G^SCH$IOLOCKW			; INTERLOCK IO DATA BASE
	BSBW	GET_PARAMS			; PROBE BUFFER DESCRIPTOR
	JSB	G^IOC$SEARCHDEV			; GO FIND DEVICE UCB ADDRESS
						; IF SUCCESS R1= TARGET UCB
						; R2 = DDB OF TARGET UCB
	BLBS	R0,10$				; UCB FOUND?

	;ERROR EXIT
5$:
	PUSHL	R0				; SAVE ERROR STATUS
	JSB	G^SCH$IOUNLOCK			; INTERLOCK IO DATA BASE
	POPL	R0				; RESTORE ERROR STATUS
	POPL	R3				; RESTORE IRP
	JMP	G^EXE$ABORTIO			; ERROR
10$:
	MOVZWL	#SS$_IVDEVNAM,R0		; ASSUME INVALID DEVICE
	CMPL	R2,VT$DDB			; VERIFY TARGET LUCB ON DETACHED  DDB CHAIN
	BNEQ	5$				; NO, SO ABORT
	DSBINT	#IPL$_SYNCH			; INTERLOCK WITH DRIVER FORK
	MOVZWL	UCB$L_PID(R1),R2		; GET PID OF OWNER PROCESS OF LUCB
	MOVL	G^SCH$GL_PCBVEC,R0		; GET ADDRESS OF PCB ARRAY
	MOVL	(R0)[R2],R2			; GET PCB ADDRESS OF LUCB OWNER
	CMPL	PCB$L_UIC(R2),PCB$L_UIC(R4)	; UIC MATCH (TARGET LUCB : COMMAND CHANNEL)
	BNEQ	15$				; NO , PRIV ERROR	
12$:	MOVL	UCB$L_TL_PHYUCB(R5),R0		; GET ADDRESS OF PHYUCB OF COMMAND CHANNEL
	BEQL	17$				; ERROR, CURRENTLY DETACHED
	TSTL	UCB$L_TL_PHYUCB(R1)		; CHECK ADDRESS OF PHYUCB OF TARGET LUCB
	BNEQ	17$				; ERROR IF CURRENTLY CONNECTED
	MOVL	R1,UCB$L_PDT(R0)		; SAVE ADDRESS TARGET LUCB IN COMMAND PUCB
	MOVL	R0,UCB$L_PDT(R1)		; SHOW CONNECT PENDING ON TARGET LUCB
	ENBINT
	JSB	G^SCH$IOUNLOCK			; INTERLOCK IO DATA BASE
	POPL	R3
	RSB
15$:
	ENBINT
	MOVZWL	#SS$_NOPRIV,R0
	BRB	5$
17$:
	ENBINT
	MOVZWL	#SS$_DEVALLOC,R0
	BRB	5$


;	ENABLE CONTROL C/Y

SET_CTRLC:
	MOVAB	UCB$L_TL_CTRLC(R5),R7	; ASSUME CONTROL C
	BRB	CTRLAST
SET_CTRLY:
	MOVAB	UCB$L_TL_CTRLY(R5),R7	; ADDRESS LIST HEAD
CTRLAST:
	CLRL	R2			; NULL MASK
	JSB	G^COM$SETATTNAST	; ENTER SET UP CODE
	BBC	#IO$V_CTRLYAST, -	; BR IF NOT ENABLING CTRL-Y
		IRP$W_FUNC(R3),10$	; ASTS
	BBCC	#UCB$V_TT_HANGUP,-	; CHECK FOR LOST HANGUP NOTIFICATION
		UCB$W_DEVSTS(R5),10$
	MOVL	R7,R4			; DELIVER LOST HANGUP AST
	MOVL	(R4),R0			; GET AST BLOCK ADDRESS
	MOVZWL	#SS$_HANGUP,-		; SIGNAL SPECIAL HANGUP STATUS
		ACB$L_KAST+4(R0)
	JSB	G^COM$DELATTNAST	; AND FIRE THE AST
	MOVZWL	#SS$_NORMAL,R0

10$:
	JMP	G^EXE$FINISHIOC		


; PROCESS CONNECT/DISCONNECT FUNCTIONS

SET_DISCONNECT:
	CMPL	UCB$L_DDB(R5),VT$DDB	; IS THIS TERMINAL  VIRTUAL TERMINAL
	BNEQU	10$			; NO THEN DON'T LET THE USER LOGOUT
	INSV	#TTY$C_FC_DISCON,#IRP$V_FCODE,#IRP$S_FCODE,IRP$W_FUNC(R3);
	BRW	QPKT			; QUEUE PACKET FOR FOLLOW ON PROCESSING

10$:	MOVZWL	#SS$_IVDEVNAM,R0	; INVALID DEVICE NAME
	JMP	G^EXE$ABORTIO		; ABORT THE COMMAND

;
; Normal exit
;
SET_DONE:
	MOVL	#SS$_NORMAL,R0
	JMP	G^EXE$FINISHIOC


	; HANGUP FUNCTION

SET_HANGUP:
	INSV	#TTY$C_FC_HANGUP,#IRP$V_FCODE,#IRP$S_FCODE,IRP$W_FUNC(R3);
	BRW	QPKT			; HANGUP IGNORES P1-PN.


	; LOOPBACK/CONTROL  DIAGNOSTIC FUNCTIONS

SET_MAINT:
	BBC	#IO$V_SET_MODEM,-	; IF SET MODEM DIAGNOSTIC FUNCTION
		IRP$W_FUNC(R3),12$	; THEN OK
	BSBW	GET_PARAMS		; GET USER PARAMETERS
12$:	INSV	#TTY$C_FC_MAINT,#IRP$V_FCODE,#IRP$S_FCODE,IRP$W_FUNC(R3);
	BRW	QPKT			; DONE



; ENABLE OUT OF BAND MASK

SET_OUTBAND:
	MOVAB	UCB$L_TL_BANDQUE(R5),R7		; GET LIST HEAD ADDRESS
	MOVAL	UCB$L_TL_OUTBAND(R5),R2		; GET CURRENT MASK ADDRESS
	JSB	G^COM$SETCTRLAST		; ENABLE/DISABLE AST
	JMP	G^EXE$FINISHIOC			; DONE

	JMP	G^EXE$FINISHIOC			; DONE

; SET CONTROLLING PROCESS PID	(FOR ^C,^Y,OOB PURPOSES)

SET_PID:
	MOVL	PCB$L_PID(R4),UCB$L_TL_CTLPID(R5)
	BRB	SET_DONE


;
;	PROBE USER BUFFER AND GET PARAMETERS
;

GET_PARAMS:
	MOVL	P1(AP),R1		; GET ADDRESS OF BUFFER
	MOVZWL	#SS$_ACCVIO,R0		; ASSUME ACCESS VIOLATION
	IFNORD	#8,(R1),10$		; BR IF NO ACCESS TO QUADWORD BUFFER
	MOVL	(R1),IRP$L_MEDIA(R3)	; SAVE NEW DATA
	MOVL	4(R1),IRP$Q_TT_STATE(R3); SAVE 1ST DEVDEPEND WORD
	MOVW	#8,IRP$W_BCNT(R3)	; INDICATE DEFAULT SIZE
	CMPL	P2(AP),#12		; CHECK FOR SECOND DEVDEPEND ARGUMENT
	BLSSU	5$			; NONE
	IFNORD	#12,(R1),10$		; CHECK IF ADDRESSABLE
	MOVL	8(R1),IRP$Q_TT_STATE+4(R3)
					; GET 2ND DEVDEPEND WORD
	MOVW	#12,IRP$W_BCNT(R3)	; LENGTH OF ADDITIONAL DATA
5$:	RSB
10$:	JMP	G^EXE$ABORTIO		; RETURN ON ERROR


	.SBTTL	MODE OR CHARACTERISTICS
;++
; TTY$FDTSENSEM - SENSE MODE
; TTY$FDTSENSEC - SENSE CHARACTERISTICS
;
; FUNCTIONAL DESCRIPTION:
;
; THIS ROUTINE PASSES THE CURRENT CHARACTERISTICS FOR SENSEMODE AND
; THE PERMANENT CHARACTERISTICS FOR SETCHAR.
; THE BUFFER RETURNED IS A QUADWORD.
;
; INPUTS:
;
;	R3 = I/O PACKET ADDRESS
;	R4 = CURRENT PCB ADDRESS
;	R5 = UCB ADDRESS
;	R6 = CCB ADDRESS
;	R7 = FUNCTION CODE
;	AP = ARG LIST FROM QIO
;
; OUTPUTS:
;
;	CONTROL IS PASSED TO EXE$ABORTIO ON FAILURE
;	OR COMPLETED VIA EXE$FINISHIO
;
; STATUS RETURNS:
;
;	SS$_NORMAL - SUCCESSFULL
;	SS$_ACCVIO - BUFFER NOT ACCESSIBLE
;--
TTY$FDTSENSEM::				; SENSE MODE
	BSBW	VERIFY_SENSE		; VERIFY USER STORAGE
	BITW	#<IO$M_TYPEAHDCNT!-	; TEST FOR SPECIAL MODIFIERS
		IO$M_RD_MODEM!IO$M_BRDCST>,-	
		IRP$W_FUNC(R3)
	BEQL	10$			; SKIP IF NOT
	BRW	GET_SPECIAL		; DO THEM	

10$:	MOVL	UCB$B_DEVCLASS(R5),(R1)	; BUILD CLASS,TYPE, AND BUFFER SIZE
	MOVL	UCB$L_DEVDEPEND(R5),4(R1);RETURN 1ST CHARACTERISTICS LONGWORD
	CMPB	R0,#12			; SECOND CHARACTERISTICS REQUESTED?
	BLSS	20$
	BSBW	GET_DCL			; BUILD SPECIAL CHARACTERISTICS
	BISL3	R2,UCB$L_DEVDEPND2(R5),8(R1);AND 2ND LONGWORD (IF REQUESTED)
20$:	CLRL	R0			; INIT RETURN
	CLRL	R1
	DSBINT	UCB$B_FIPL(R5)		; INTERLOCK DISCONNECTS
	MOVL	UCB$L_TL_PHYUCB(R5),R9	; GET PUCB ADDRESS
	BEQL	30$			; DISCONNECTED FROM CHARS
	MOVL	UCB$W_TT_SPEED-2(R9),R0	; RETURN SPEED
	MOVL	UCB$B_TT_PARITY-2(R9),R1;RETURN PARITY INFO
	BICL	#^XFF000000,R1		; ZERO HIGH BYTE
	MOVW	UCB$B_TT_CRFILL(R9),R1	; AND CR/LF FILL
30$:	ENBINT
	BRW	GET_EXIT1		; EXIT RETURNING R1

;	THIS ROUTINE PROCESSES SENSE CHARACTERISTICS FUNCTIONS

TTY$FDTSENSEC::				; SENSE CHAR
	BSBW	VERIFY_SENSE		; VERIFY USER STORAGE
	BITW	#<IO$M_TYPEAHDCNT!-	; TEST FOR SPECIALS 
		IO$M_RD_MODEM!IO$M_BRDCST>,-	
		IRP$W_FUNC(R3)
	BEQL	10$			; SKIP IF NOT
	BRW	GET_SPECIAL		; DO THEM	

10$:
	BSBW	GET_DCL			; BUILD SPECIAL CHARACTERISTICS
	PUSHR	#^M<R6,R7,R8,R10,R11>
	DSBINT	UCB$B_FIPL(R5)		; INTERLOCK DISCONNECTS
	MOVL	UCB$L_TL_PHYUCB(R5),R9	; GET PUCB ADDRESS
	BEQL	30$			; DISCONNECTED FROM CHARS
	MOVL	UCB$B_TT_DETYPE-1(R9),R6; BUILD TYPE, AND BUFFER SIZE
	MOVB	#DC$_TERM,R6		; BUILD DEVICE CLASS
	MOVL	UCB$L_TT_DECHAR(R9),R7	;RETURN 1ST CHARACTERISTICS LONGWORD
	BISL3	R2,UCB$L_TT_DECHA1(R9),R8;AND 2ND LONGWORD (IF REQUESTED)
20$:
	MOVL	UCB$W_TT_DESPEE-2(R9),R10; RETURN SPEED
	MOVL	UCB$B_TT_DEPARI-2(R9),R11; RETURN PARITY INFO
	BICL	#^XFF000000,R11		; ZERO HIGH BYTE
	MOVW	UCB$B_TT_DECRF(R9),R11	; AND CR/LF FILL
	ENBINT				; RELEASE INTERLOCK
	MOVL	R6,(R1)			; RETURN USER DATA
	MOVL	R7,4(R1)
	CMPB	R0,#12			; DID HE ASK FOR 2ND ?
	BLSS	25$			; NO
	MOVL	R8,8(R1)
25$:	MOVL	R10,R0			; RETURN IOSB DATA
	MOVL	R11,R1
	POPR	#^M<R6,R7,R8,R10,R11>	; RESTORE SCRATCH REGISTERS
	BRW	GET_EXIT1		; EXIT RETURNING R0,R1	

30$:	ENBINT				; RELEASE INTERLOCK
	POPR	#^M<R6,R7,R8,R10,R11>	; RESTORE SCRATCH REGISTERS
	BRW	TTY$FDTSENSEM		; AND TREAT AS SENSE MODE

	.sbttl	SETMODE/CHAR service routines
GET_BRDCST:
	MOVQ	UCB$Q_TL_BRKTHRU(R5),(R1)	; RETURN BROADCAST MASK
	BRW	GET_EXIT

;	THIS ROUTINE BUILDS DCL PRIVATE CHARACTERISTICS

GET_DCL:
	CLRL	R2			; INIT RETRUN ARGUMENT
	TSTL	UCB$L_AMB(R5)		; ANY ASSOCIATED MAILBOX?
	BEQL	5$			; NO
	BISL	#TT2$M_DCL_MAILBX,R2	; YES, SO BUILD CHARACTERISTIC
5$:	RSB


GET_EXIT:
	MOVW	#SS$_NORMAL,R0
	JMP	G^EXE$FINISHIOC		; COMPLETE REQUEST IOSB WORD 0
GET_EXIT1:
	MOVW	#SS$_NORMAL,R0
	JMP	G^EXE$FINISHIO		; COMPLETE REQUEST IOSB WORD 0,1


;	THIS ROUTINE BUILDS CONTROLLER TYPE AND RECEIVE MODEM SIGNALS

GET_MODEM:
	MOVL	UCB$L_CRB(R9),R0	; GET CRB ADDRESS
	MOVB	CRB$B_TT_TYPE(R0),R6	; RETURN CRB TYPE
	MOVB	UCB$B_TT_DS_RCV(R9),R7	; RETURN CURRENT RECEIVE MODEM SIGNALS
	ENBINT				; RELEASE INTERLOCK
	MOVB	R6,(R1)			; RETURN USER DATA
	MOVB	R7,2(R1)
	POPR	#^M<R6,R7>		; RESTORE SCRATCH DATA
	BRW	GET_EXIT


;	THIS ROUTINE PROCESSES MODIFIERS 

GET_SPECIAL:
	BBS	#IO$V_BRDCST,-		; ONLY REQUIRES LUCB
		IRP$W_FUNC(R3),GET_BRDCST
	PUSHR	#^M<R6,R7>		; SAVE SCRATCH
	DSBINT	UCB$B_FIPL(R5)		; INTERLOCK DISCONNECTS TO PCUB
	MOVL	UCB$L_TL_PHYUCB(R5),R9	; GET PUCB ADDRESS
	BEQL	10$			; DISCONNECTED (RETURN ZERO)
	BBS	#IO$V_TYPEAHDCNT,IRP$W_FUNC(R3),GET_TYPEAHD
	BRW	GET_MODEM
10$:	ENBINT				; RELEASE INTERLOCK
	POPR	#^M<R6,R7>	
	BRW	GET_EXIT


;	THIS ROUTINE BUILDS THE NUMBER OF CHARACTERS IN TYPEAHD
;	AND RETURNS THE TOP CHARACTER IN THE BUFFER

GET_TYPEAHD:
	CLRQ	R6			; INIT RETURN VALUES (R6,R7)
	MOVL	UCB$L_TT_TYPAHD(R9),R0	; ADDRESS OF TYPEAHD BUFFER
	BEQL	10$			; SKIP IF DISCONNECTED
	MOVW	TTY$W_TA_INAHD(R0),R6   ; GET NUMBER CHARACTERS IN BUFFER
	MOVB	@TTY$L_TA_GET(R0),R7	; GET LOOKAHEAD CHARACETER
10$:	ENBINT				; RELEASE INTERLOCK
	MOVW	R6,(R1)			; RETURN USER DATA
	MOVB	R7,2(R1)
	POPR	#^M<R6,R7>		; RESTORE SCRATCH DATA
	BRW	GET_EXIT


;	THIS ROUTINE VERIFIES THAT THE USER BUFFER IS ACCESSABLE

VERIFY_SENSE:				;
	MOVL	P1(AP),R1		; ADDRESS USER BUFFER
	IFNOWRT	#8,(R1),30$		; BR IF NO ACCESS TO QUADWORD BUFFER
	MOVL	#8,R0			; INIT DEFAULT ARGUMENT SIZE
	CLRQ	(R1)			; INIT RETURN DATA
	MOVL	P2(AP),R2		; GET SIZE ARGUMENT
	CMPL	R2,#12			; ROOM FOR SECOND DEVDEPEND SPECIFIED?
	BLSSU	25$			; NO
	IFNOWRT	#12,(R1),30$		; CHECK IF WRITE ACCESS
	MOVW	#12,R0			; SAVE ARGUMENT SIZE
	CLRL	8(R1)			; INIT RETURN FIELD
25$:
	RSB
30$:
	MOVZWL	#SS$_ACCVIO,R0		; SET ERROR STATUS
	JMP	G^EXE$ABORTIO		; ABORT THE IO


	.PAGE
	.SBTTL	MOVE TRANSLATE - TRANSLATE TO UPPERCASE
;++
;
; MOVE_TRANSLATE
;
; THIS ROUTINE MOVES AND TRANSLATES LOWERCASE OUTPUT DATA FOR 
; UPPERCASE TERMINALS and TRANSLATES 8-BIT CHARACTERS TO 7-BIT FALLBACK
; PRESENTATION FOR TERMINALS THAT DO NOT UNDERSTAND THE 8 BIT REPRESENTATIONS.
; IT PARSES ESCAPE SEQUENCES FOR ANSI, VT100
; AND VT52 TERMINALS, AND REFRAINS FROM TRANSLATION OF ANY DATA
; IN ESCAPE OR CONTROL SEQUENCES.
;
; INPUTS:
;	R2 = DESTINATION ADDRESS
;	R3 = destination length
;	R5 = UCB ADDRESS
;	R6 = SOURCE ADDRESS
;	R7 = LENGTH
;	R8 = LOW BIT SET MEANS DO LOWERCASEING
;
; OUTPUTS:
;	R2 = END OF DESTINATION STRING +1
;	R5 = UCB ADDRESS
;
;	R0 - R4 DESTROYED

MOVE_TRANSLATE:

	TSTL	R7			; NULL STRING
	BEQL	30$			; YES
	BLBS	R8,5$			; ARE WE DOING LOWER?? YES THEN DO FALLBACK FIRST
	PUSHL	R5			; ELSE JUST DO FALLBACK
	BSBW	TTY$FALLBACK		; CALL FALLBACK
	POPL	R5			; AND RESTORE THE UCB ADDRESS
30$:	RSB

5$:	BBC	#TT2$V_FALLBACK,-
		UCB$L_DEVDEPND2(R5),TTY$UPPER; NO FALLBACK THEN ONLY UPPER CASE
	PUSHR	#^M<R2,R3,R5>		; SAVE THE DESTROYED REGISTERS
	BSBW	TTY$FALLBACK		; CALL FALLBACK
	POPR	#^M<R2,R3,R5>		; THEN RETURN THE DATA
	MOVL	R3,R7			; UPDATE THE LENGTH AND ADDRESS
	MOVL	R2,R6			; TO TRANSLATE TO UPPER

	.SBTTL	TTY$UPPER - Translate a string to upper case
;++
;TTY$UPPER - Upper case translation
;
; Description:
;
;	Given an input string it will take all of the lower case characters
; in it and change it to upper case (characters in escape sequences are not
; bothered).
;
; Inputs:
;	R2 = DESTINATION ADDRESS
;	R5 = UCB ADDRESS
;	R6 = SOURCE ADDRESS
;	R7 = LENGTH
; Outputs:
;
;	R2 = END OF DESTINATION STRING +1
;	R5 = UCB ADDRESS
;
;	R0 - R4 DESTROYED
;--
TTY$UPPER:
	MOVZBL	(R6)+,R3		; GET NEXT CHAR TO MOVE
	CMPB	W^TTY$A_CCLIST[R3],#TTY$K_ET_ESCAPE; CHECK OUT ESCAPE SEQUENCES
	BEQL	40$
	BBC	#TTY$V_CH_LOWER,-	; SKIP IF NOT LOWER CASE
		W^TTY$A_TYPE[R3],20$
	BICW	#^X20,R3		; CONVERT TO UPPER CASE
20$:
  	MOVB	R3,(R2)+
	SOBGTR	R7,TTY$UPPER			; CONTINUE UNTIL DONE
30$:
	RSB

40$:
	MOVB	R3,(R2)+		; COPY ESCAPE
	DECL	R7			; ADJUST COUNT
	BEQL	30$			; QUIT IF DONE
	BBS	#TT2$V_ANSICRT,-	; CHECK FOR DEVICES WITH ANSI SEQUENCES
		UCB$L_DEVDEPND2(R5),45$
	BBS	#TT$V_ESCAPE,-
		UCB$L_DEVDEPEND(R5),45$
	CMPB	#TT$_VT5X,UCB$B_DEVTYPE(R5)
	BGTRU	TTY$UPPER
;
45$:
	PUSHL	R1			; SAVE R1
	BSBW	ESCINIT			; INIT THE ESCAPE SEQUENCE RULES
	MOVZBL	R1,R4			;...
	POPL	R1			; RESTORE R1
50$:
	MOVZBL	(R6)+,R3		; GET NEXT SEQUENCE CHARACTER
	BSBW	E_SYNTAX		; CHECK ESCAPE SEQUENCE SYNTAX
	BLEQ	20$			; ENDED OK, OR FAILURE
	MOVB	R3,(R2)+
	SOBGTR	R7,50$			; CONTINUE TILL END
	RSB	

	.SBTTL	TTY$FALLBACK - ROUTINE TO TRANSLATE 8-BIT CHARACTERS TO 7-BIT
;++
; TTY$FALLBACK - SUBROUTINE THAT WILL MOVE A STRING AND INSERT FALLBACK REPRESENTATION
;
; DESCRIPTION:
;
;	This routine will take an input buffer of any length and take any
; eight bit characters in it and change them into their 7-bit fallback presentation
; This includes inserting characters for multi-character expansions.
;
; Inputs:
;	R2 - destination address
;	R3 - destination length
;	R5 - ucb address
;	R6 - Source address
;	R7 - Source length
;
; Outputs:
;	R2 - End of destination string
;	R0 - R5 Destroied
;
; MOVE FALLBACK TRANSLATED
;
TTY$FALLBACK:
	MOVL	R7,R0		; load up the necessary registers
	MOVL	R6,R1
	MOVL	R3,R4
	MOVL	R2,R5
310$:
	MOVTUC	R0,(R1),#255,@TTY$A_FALLTAB,R4,(R5); TRANSLATE WHAT WE CAN
	BVS	320$		; IF WE CAN'T TRANSLATE IT THEN IT MUST BE LONG
	MOVL	R5,R2		; GET THE CURRENT END OF DATA
	RSB			; RETURN

320$:
	MOVZBL	(R1)+,R3	; GET THE CHARACTER
	PUSHL	R4		; SAVE A REGISTER
	MOVL	TTY$A_EXPTAB,R4	; GET TEH TABLE ADDRESS
	MOVZBL	-150(R4)[R3],R3	; GET THE OFFSET TO THE STRING
	POPL	R4		; RESTORE OUR SCRATCH REGISTER
	MOVZBL	@TTY$A_EXPAN[R3],R2; GET THE LENGTH OF THE SEQUENCE
	INCL	R3		; MOVE BY THE COUNT
	DECL	R0		;...
330$:	MOVB	@TTY$A_EXPAN[R3],(R5)+; MOVE IN THIS CHARACTER
	DECL	R4		; TAKE OUT THE CHARACTER SLOT
	BEQL	310$
	INCL	R3		; MOVE OVER A CHARACTER
	SOBGTR	R2,330$
	BRW	310$
;
; CALCULATE THE NUMBER OF CHARACTERS
; THAT WILL BE OUTPUT IN FALLBACK
;
ADDFALL:
	CLRL	R9		; CLEAN OUT R9
210$:	SCANC	R0,(R1),@TTY$A_FALLTAB,#^X80; SCANN FOR FALLBACK CHARACTRS
	BNEQ	220$		; NOT DONE THEN COUNT THE EXPANSION
	RSB

220$:	PUSHL	R4		; SAVE A REGISTER
	MOVZBL	(R1)+,R3	; GET THE CHARACTER
	MOVL	TTY$A_EXPTAB,R4	; GET THE TABLE ADDRESS
	MOVZBL	-150(R4)[R3],R3	; GET THE OFFSET TO THE STRING
	POPL	R4		; RESTORE THE REGISTER
	MOVZBL	@TTY$A_EXPAN[R3],R2; GET THE LENGTH OF THE SEQUENCE
	DECL	R2		; SUBTRACT 1 FROM THE LENGTH
	DECL	R0		;UPDATE THE SCAN POINTER
	ADDL	R2,R9
	BRB	210$		; AND CONTINUE COUNTING
 

	.END

