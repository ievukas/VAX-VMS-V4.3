MODULE DBGLANVEC (IDENT = 'V04-000') =

BEGIN
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
!
! WRITTEN BY
!	Bruce Olsen	July, 1980
!
! REWRITTEN BY
!	Rich Title	July, 1983
!
! MODULE FUNCTION
!	This module contains several miscellaneous routines for 
!	manipulating descriptors. The name of the module is a holdover
!	from the days when each language had its own Primary and Value
!	Descriptors. At that time, this module had routines which
!	did a CASE on the language, and called the appropriate language
!	routine. Now that we have common Primary and Value descriptors
!	for all languages, this is no longer necessary. But the routines
!	for copying descriptors, deleting descriptors, and so on,
!	still reside in this module.
!

! MODIFIED BY
!	R. Title	Aug 1982	Put in code to check for implementationm
!					level = 3, so that we can test new support
!					for PASCAL, PLI, and COBOL.
!	R. Title	Aug 1982	Added comments to each routine so that
!					the description now says what the routine
!					does, instead of just saying "see the
!					language-specific routines".
!	R. Title	Mar 1983	Removed all of the "level 2" PASCAL,
!					PL/I and COBOL code.
!
REQUIRE 'SRC$:DBGPROLOG.REQ';

FORWARD ROUTINE
    DBG$NGET_LVAL,
    DBG$NGET_TYPE,
    DBG$NMAKE_VAL_DESC,
    DBG$NTYPE_CONV,
    DBG$NSYMBOLIZE,
    DBG$NGET_PAGES,
    DBG$NGET_LENGTH,
    DBG$NCOPY_DESC,
    COPY_DESC_HANDLER,
    DBG$NFREE_DESC,
    DBG$NGET_SYMID,
    DBG$NINITIALIZE: NOVALUE;

EXTERNAL ROUTINE
    DBG$DATA_LENGTH,			! Obtain length from VMS descriptor
    DBG$EVAL_LANG_OPERATOR,		! Evaluate operator expressions in
					!      current language
    DBG$GET_MEMORY,			! Allocate permanent memory
    DBG$GET_TEMPMEM,			! Allocate temporary memory
    DBG$MAKE_VMS_DESC,			! Convert Primary Descriptor to
					!      VMS descriptor
    DBG$PRIM_TO_VAL,			! Convert Primary Descriptor to
					!      Value Descriptor
    DBG$PRINT_AGGREGATE: NOVALUE,	! Output an aggregate object
    DBG$PRINT_IDENTIFIER,		! Replacement for DBG$NSYMBOLIZE -
					!      prints an identifier.
    DBG$PRINT_VALUE: NOVALUE,		! Print a value descriptor.
    DBG$REL_MEMORY: NOVALUE;		! Release memory

EXTERNAL
    DBG$GB_LANGUAGE : BYTE,		! Language code for current language
    DBG$GL_CONVERT_TOKEN,		! Pointer to CONVERT token
    DBG$GL_DEPOSIT_TOKEN;		! Pointer to DEPOSIT token

LITERAL
    MIN_LANGUAGE_CODE = MIN (DBG$K_PLI, DBG$K_PASCAL, DBG$K_COBOL),
    MAX_LANGUAGE_CODE = MAX (DBG$K_PLI, DBG$K_PASCAL, DBG$K_COBOL);

OWN
    	COPY_DESC_HEAD;		! Points to the header of a copied descriptor,
    				! if we are copying the descriptor into
    				! permanent memory. This is used by
    				! COPY_DESC_HANDLER.


GLOBAL ROUTINE DBG$NGET_LVAL (PRIM_DESC, PARAM2, PARAM3) =
!
! FUNCTIONAL DESCRIPTION:
!
! 	Obtains a symbol's lvalue using the primary descriptor for that
!	symbol. Note that most types of named constants do not have an
!	lvalue. The debugger gives special treatment to named constants
!	which have read only memory allocated to contain their value.
!
! 	This routine is still called from DBGEXC,
! 	in the process of displaying "old value", "new value" on watchpoints.
! 	This routine can thus go away when DBGEXC is replaced by DBGEVENT.
!
! FORMAL PARAMETERS:
!
!	prim_desc	- A longword which contains the address of a primary descriptor
!
!	param2		- The address of a quadword to contain the lvalue of the
!			  entity described by the primary descriptor and the bit
!			  offset, if any. The byte address will be contained in
!			  in the first longword, the bit offset in the second
!			  longword.
!
!	param3		- The address of a longword to contain the address of
!			  a message argument vector as described on page 4-119
!			  of the VAX/VMS system reference, volume 1A
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	An unsigned longword integer completion code
!
! COMPLETION CODES:
!
!	STS$K_SUCCESS (1) - Success. The object described by the input primary
!			    descriptor has an lvalue which is being returned.
!
!	STS$K_ERROR   (2) - Failure. Object does not have an lvalue. 
!
! SIDE EFFECTS:
!
!	NONE
!
!
    BEGIN

    MAP 
        PRIM_DESC : REF DBG$PRIMARY; 	! Points to a new style Primary

						! Descriptor.
    LOCAL
    	VMS_DESC: REF DBG$STG_DESC,
	VMS_DESC_AREA: DBG$STG_DESC;


    IF .PRIM_DESC [DBG$B_DHDR_TYPE] EQL DBG$K_PRIMARY_DESC
    THEN
    	BEGIN

	! Set up the VMS descriptor.
	!
	VMS_DESC = VMS_DESC_AREA;

	! Call the routine that fills in the VMS descriptor.
	!
	DBG$MAKE_VMS_DESC (.PRIM_DESC, .VMS_DESC);    	    
	END

    ! Value descriptor or volatile value descriptor - we already
    ! have a VMS descriptor.
    !
    ELSE IF .PRIM_DESC [DBG$B_DHDR_TYPE] EQL DBG$K_VALUE_DESC
    OR .PRIM_DESC [DBG$B_DHDR_TYPE] EQL DBG$K_V_VALUE_DESC
    THEN
    	VMS_DESC = PRIM_DESC [DBG$A_VALUE_VMSDESC]

    ! We do not expect any other kind of descriptor.
    !
    ELSE
    	$DBG_ERROR ('DBGLANVEC\DBG$NGET_LVAL unknown descriptor kind');
	
    ! Fill in the output parameter to point to the 
    ! (byte address, bit offset) quadword in the VMS descriptor.
    !
    .PARAM2     = .VMS_DESC[DSC$A_POINTER];
    .PARAM2 + 4 = .VMS_DESC[DSC$L_POS];
    RETURN STS$K_SUCCESS;
    END;

GLOBAL ROUTINE DBG$NGET_TYPE (PRIM_DESC, PARAM2, PARAM3) =
!
! FUNCTIONAL DESCRIPTION:
!
!	Uses a symbol's primary descriptor to return type information. The
!	types recognized are limited to three:
!
!	1)	- type named constant and instruction 
!		  (lexical entities, labels)
!
!	2)	- type named constant and
!		  noinstruction (symbolic literals)
!
!	3)	- type other
!
! 	This routine is still called from DBGEXC.
!	It can go away when we convert over to the new DBGEVENT.
!
! FORMAL PARAMETERS:
!
!	prim_desc	- A longword containing the address of a primary descriptor
!
!	param2		- The address of a longword to contain an unsigned integer
!			  encoding of the symbol's type as follows:
!
!		dbg$k_nc_instruction (125)	- named constant, instruction
!	
!		dbg$k_nc_other (126)		- named constant, noinstruction
!
!		dbg$k_other (127)		- other
!
!	param3		- The address of a longword to contain the address of
!			  a message argument vector as described on page 4-119
!			  of the VAX/VMS system reference, volume 1A
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	In case of a severe error return, a message argument vector is constructed
!	from dynamic storage and returned.
!
! ROUTINE VALUE:
!
!	An unsigned integer longword completion code
!
! COMPLETION CODES:
!
!	STS$K_SUCCESS (1) - Success. Type information recovered and returned.
!
!	STS$K_SEVERE  (4) - Failure. No type information recovered. Message
!			    argument vector constructed and returned.
!
! SIDE EFFECTS:
!
!	NONE
!
    BEGIN

    ! For now, always return "OTHER". This may not be completely
    ! correct - we will fix it up later.
    !
    .PARAM2 = DBG$K_OTHER;
    RETURN STS$K_SUCCESS;
    END;

GLOBAL ROUTINE DBG$NMAKE_VAL_DESC (PRIM_DESC, PARAM2, PARAM3, PARAM4) =
!
!++
! FUNCTIONAL DESCRIPTION:
!
!	Translates language specific primary descriptors to language specific
!	value descriptors. This routine should be able to use the symbol table
!	access routines and the information contained within the primary descriptor
!	to construct a descriptor which represents a 'value materialization' for
!	the object represented by the input primary descriptor.
!
!	Note that this routine must be able to use life-time, invocation, and
!	generation information to produce an accurate value descriptor of the
!	input object, or to decide when the value of an object cannot be
!	materialized (such as when the user's PC is not within the scope of
!	a dynamic variable).
!
!	Value descriptors produced by this routine must be marked (within the
!	type field of the language independent header block) as to whether
!	they are non-volatile (dsc$k_value_desc) or volatile (dsc$k_v_value_desc).
!	Volatile value descriptors will NOT be stored to represent '\', 'last value'.
!
!	Since value descriptors may be used as target descriptors ( as input to
!	dbg$npli_type_conv ), some provision must be made for incorporating
!	a value pointer field within the value descriptor. This type of value
!	descriptor is loosely defined as a volatile type.
!
!	This routine is still called from DBGEXC in the process of giving
!	watchpoint display. It can thus go away when DBGEXC is replaced
!	by DBGEVENT.
!
!	This routine call a language-specific routine based on the language
!	code in the descriptor header.
!
! FORMAL PARAMETERS:
!
!	prim_desc	- A longword containing the address of a primary descriptor
!
!	param2		- A longword containing boolean true or false. When true,
!			  the caller is requesting the construction of a value
!			  descriptor that can be used as a target descriptor for
!			  the type converter. The resulting value must therefore
!			  contain a pointer to the value of the entity described
!			  by the input primary descriptor. Presumably, such a
!			  value descriptor will be of volatile type.
!
!	param3		- The address of a longword to contain the address of the
!			  resulting value descriptor
!
!	param4		- The address of a longword to contain the address of a
!			  message argument vector as described on page 4-119 of
!			  the VAX/VMS system reference, volume 1A
!
! IMPLICIT INPUTS:
!
!	Depends on the language-specific routine.
!
! IMPLICIT OUTPUTS:
!
!	In case of a success return, the resulting value descriptor must be
!	constructed from dynamic storage and returned.
!
!	In case of a severe error return, a message argument vector must be
!	constructed from dynamic storage and returned.
!
! ROUTINE VALUE:
!
!	An unsigned integer longword completion code
!
! COMPLETION CODES:
!
!	STS$K_SUCCESS (1) - Success. Value descriptor constructed and returned.
!
!	STS$K_SEVERE  (4) - Failure. Value descriptor not constructed. Message
!			    argument vector constructed and returned.
!
! SIDE EFFECTS:
!
!	NONE
!
    BEGIN

    MAP
    	PRIM_DESC: REF DBG$PRIMARY;

    ! Don't convert to value desc if the primary is an aggregate.
    !
    IF .PRIM_DESC [DBG$V_DHDR_AGGR]
    THEN
    	.PARAM3 = .PRIM_DESC
    ELSE
    	IF NOT DBG$PRIM_TO_VAL (
		.PRIM_DESC,
		(IF .PARAM2 THEN DBG$K_V_VALUE_DESC ELSE DBG$K_VALUE_DESC),
		.PARAM3)
	THEN
	    $DBG_ERROR ('DBGLANVEC\DBG$NMAKE_VAL_DESC bad return code from PRIM_TO_VAL');
    RETURN STS$K_SUCCESS;
    END;

GLOBAL ROUTINE DBG$NTYPE_CONV (VALUE_DESC, PARAM2, PARAM3, PARAM4, PARAM5) =
!
! FUNCTIONAL DESCRIPTION:
!
!	Performs language specific and language independent type conversions.
!	These will be both internal-to-internal and internal-to-external in
!	nature. Target may be described by either language
!	specific value descriptor or a subset of VAX standard descriptors.
!	The latter category includes the following:
!
!	dsc$k_dtype_v
!
!	dsc$k_dtype_b, dsc$k_dtype_bu
!
!	dsc$k_dtype_w, dsc$k_dtype_wu
!
!	dsc$k_dtype_l, dsc$k_dtype_lu
!
!	dsc$k_dtype_q, dsc$k_dtype_qu
!
!	dsc$k_dtype_f, dsc$k_dtype_d
!
!	dsc$k_dtype_t
!
!	The source descriptor must be a language specific value descriptor.
!
!	Note that this routine will be used to obtain the 'printable' (external)
!	value of the source as the result of EXAMINE commands.
!
!	This routine is still called from a couple of places; one is to
!	convert the expression in an IF or a WHILE command to boolean;
!	another is to display the value of watchpoints in "old value",
!	"new value" displays. (This second use of this routine will go
!	away when DBGEVENT replaces DBGEXC.)
!
! FORMAL PARAMETERS:
!
!	value_desc	- A longword which contains the address of 
!			   a language specific value descriptor
!	
!	param2		- A longword containing an integer encoding of the radix
!			  to be used when converting to a 'printable' value:
!
!		dbg$k_default (1)	- source language default radix
!
!		dbg$k_binary (2)	- binary radix
!
!		dbg$k_octal (8)    	- octal radix
!
!		dbg$k_decimal (10)	- decimal radix
!
!		dbg$k_hex (16)		- hexadecimal radix
!
!			Note that this parameter is significant ONLY when the
!		   	object described by the source descriptor is to be
!			converted to external format. A request for a binary,
!			octal, or hex 'printable' value means to consider the
!			value of source as a bit pattern to be translated to
!			special characters. In this sense, the type of the source
!			value is not significant - only the length. Values will
!			therefore be displayed as unsigned integers within the
!			specified radix. Values will be left-extended to nibble
!			boundaries.
!	
!	param3		- A longword containing an unsigned integer encoding of the
!			  type of information contained within the target parameter:
!
!		dbg$k_vax_desc (130)	   - target contains the address of a
!					     VAX standard descriptor
!
!					     Note: The caller of dbg$nxxx_type_conv
!					     must assure that the dsc$a_pointer
!					     field of the descriptor contains the
!					     address of an appropriately large
!					     block of storage.
!
!		dbg$k_value_desc (122)     - target contains the address of a
!					     language specific value descriptor.
!					     The type convertor deposits the
!					     value of Source into the address of
!					     the value in Target.
!
!		dbg$k_external_desc (129)  - target contains the address of
!					     a VAX standard string descriptor.
!					     This is a request to convert to
!					     'printable' format. Conversion must
!					     include check for unprintable characters.
!
!	param4		- A longword which contains the address of either a VAX
!			  standard descriptor, or a language specific value descriptor
!
!	param5		- The address of a longword to contain the address of
!			  a message argument vector as described on page 4-119 of
!			  the VAX/VMS system reference, volume 1A
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	When this routine is called to obtain the 'printable' (external) value
!	of the source object, the target will contain the address of a VAX
!	standard string descriptor with length and pointer fields set to 0.
!	Dynamic storage must be obtained to contain the resulting ascii string.
!
!	In all other cases, this routine is not required to allocate storage to
!	contain the resulting value of a conversion request. Targets which are
!	described by VAX standard descriptors MUST contain the address of a
!	block of storage (the dsc$a_pointer field)
!	in which the resulting value of the conversion will be stored. 
!
!	Dynamic storage must be used to construct the message argument vector
!	upon a severe error return.
!
! ROUTINE VALUE:
!
!	unsigned integer longword completion code
!
! COMPLETION CODES:
!
!	STS$K_SUCCESS (1) - Success. Conversion performed.
!
!	STS$K_SEVERE  (4) - Failure. No conversion. Message argument vector
!			     constructed and returned.
!
! SIDE EFFECTS:
!
!	Informational messages such as string and number truncation may be 
!	issued during processing.
!

    BEGIN

    SELECTONE .PARAM3 OF 
    	SET

	! One place this routine is called is in the processing of the
	! IF, WHILE, and INCR commands, in order to convert the given
	! value to a type understood by the command. 
	! In these cases, the third parameter is DBG$K_VAX_DESC and
	! the fourth parameter is a pointer to a VAX standard descriptor.
	!
	[DBG$K_VAX_DESC] :
	    BEGIN
	    LOCAL
		V_VAL_DESC: REF DBG$VALDESC;

	    ! Build a volatile value descriptor around the given VAX 
	    ! standard descriptor.
	    !
	    V_VAL_DESC = DBG$GET_TEMPMEM (DBG$K_VALDESC_BASE_SIZE+4);
	    CH$MOVE (12, .VALUE_DESC, .V_VAL_DESC);
	    V_VAL_DESC[DBG$B_DHDR_TYPE] = DBG$K_V_VALUE_DESC;
	    V_VAL_DESC[DBG$W_DHDR_LENGTH] = 4 * (DBG$K_VALDESC_BASE_SIZE+4);
	    CH$MOVE (12, .PARAM4, V_VAL_DESC[DBG$A_VALUE_VMSDESC]);

	    ! Call the EVAL_LANG_OPERATOR routine to do the conversion.
	    !
	    DBG$EVAL_LANG_OPERATOR (
			DBG$GL_CONVERT_TOKEN,
			.VALUE_DESC,
			.V_VAL_DESC);
	    END;

	! Another case is during the output of watchpoints in
	! "old value", "new value".
	!
	[DBG$K_EXTERNAL_DESC] :
	    BEGIN
	    MAP
		VALUE_DESC: REF DBG$PRIMARY;

	    ! Check for aggregate.
	    !
	    IF .VALUE_DESC [DBG$V_DHDR_AGGR]
	    THEN
	 	DBG$PRINT_AGGREGATE (.VALUE_DESC, .PARAM2)

	    ELSE

	    	! Call the PRINT_VALUE routine
		!
		DBG$PRINT_VALUE (.VALUE_DESC, .PARAM2, FALSE, FALSE);
    
	    ! This is kind of a kludge. We fill in a -1 to PARAM5
	    ! and this indicates to the caller in DBGEXC that the
	    ! value has already been displayed.
	    !
	    .PARAM5 = -1;
	    END;
		
	! I don't think there are any other cases where this routine
	! is still used, so signal an internal DEBUG error.
	!
	[OTHERWISE] :
	    $DBG_ERROR ('DBGLANVEC\DBG$NTYPE_CONV');
		
	TES;
    RETURN STS$K_SUCCESS;
    END;

GLOBAL ROUTINE DBG$NSYMBOLIZE (PRIM_DESC, PARAM2, PARAM3) =
!
! FUNCTION
!	Prints the name given by the primary descriptor, in the
!	appropriate language format. This routine actually just
!	passes the descriptor along to the new routine
!	DBG$PRINT_IDENTIFIER.
!
! FORMAL PARAMETERS:
!
!	PRIM_DESC	- A longword containing the address of a language specific
!			  primary descriptor
!
!	PARAM2, PARAM3	- Unknown to this routine
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	Same as the invoked routine
!
! ROUTINE VALUE:
!
!	Same as the invoked routine
!
! COMPLETION CODES:
!
!	Same as the invoked routine
!
! SIDE EFFECTS:
!
!	Same as the invoked routine.
!
!	This routine will generate a SIGNAL upon detection of a foreign
!	language value within the primary descriptor.
!
    BEGIN
    DBG$PRINT_IDENTIFIER (.PRIM_DESC);
    RETURN STS$K_SUCCESS;
    END;

GLOBAL ROUTINE DBG$NGET_PAGES (PRIM_DESC, PARAM2, PARAM3) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Uses a symbol's primary descriptor to construct a linked list of page
!	numbers which reflect those pages of storage in which the symbol's
!	rvalue is contained. Note that the pages may be non-contiguous.
!
!	A page number is represented by the high order 23 bits of a virtual 
!	address, with the low order 9 bits set to 0:
!
!	page = (virtual__address AND B'11111111111111111111111000000000')
!
!	At implementation level 2,
!	This routine calls a language-specific routine depending on the language
!	code in the header of the descriptor.
!
!	At implementation level 3, the descriptors are the same so the
!	work is done right here. 
!
! FORMAL PARAMETERS:
!
!	prim_desc	- A longword containing the address of a primary descriptor
!
!	param2		- The address of a longword to contain the address of the
!			  head node in the page list. Nodes in the page list
!			  consist of blocks of two longwords each. The second
!			  longword of the node block contains a page number on
!			  which some portion of the symbol's rvalue resides. The
!			  first longword of the node block contains the address
!			  of the next node in the list. The last node in the list
!			  should contain a 0 in this link field.
!
!	param3		- The address of a longword to contain the address of
!			  a message argument vector as described on page 4-119
!			  of the VAX/VMS system reference, volume 1A
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	In case of a success return, the page list is constructed from dynamic
!	storage and returned.
!
!	In case of a severe error return, a message arguement vector is constructed
!	and returned.
!
! ROUTINE VALUE:
!
!	An unsigned integer longword completion code
!
! COMPLETION CODES:
!
!	STS$K_SUCCESS (1) - Success. Page list constructed and returned.
!
!	STS$K_SEVERE  (4) - Failure. Page list not constructed. Message argument
!			    vector constructed and returned.
!
! SIDE EFFECTS:
!
!	NONE
!
    BEGIN

    MAP
        PRIM_DESC: REF DBG$PRIMARY;

    LOCAL 
    	BIT_LENGTH,				! Length of data in bits
	CURRENT_BLOCK: REF DBG$LINK_NODE,	! Pointer to current page 
						!    number block
	CURRENT_PAGE_ADDRESS,			! A page address
	END_ADDRESS,				! Last page address
	NEXT_BLOCK: REF DBG$LINK_NODE,		! Pointer to the next page
						!    number block
    	POS,
	VMS_DESC: REF DBG$STG_DESC,
	VMS_DESC_AREA: DBG$STG_DESC;

    ! For volatile value descriptors we already have a vms desc.
    !
    IF .PRIM_DESC [DBG$B_DHDR_TYPE] EQL DBG$K_V_VALUE_DESC
    OR .PRIM_DESC [DBG$B_DHDR_TYPE] EQL DBG$K_VALUE_DESC
    THEN
    	VMS_DESC = PRIM_DESC [DBG$A_VALUE_VMSDESC]
    ELSE IF .PRIM_DESC [DBG$B_DHDR_TYPE] EQL DBG$K_PRIMARY_DESC
    THEN
    	BEGIN

	! Turn the primary descriptor into a VMS descriptor.
	!
	VMS_DESC = VMS_DESC_AREA;
	IF NOT DBG$MAKE_VMS_DESC (.PRIM_DESC, .VMS_DESC) 
	THEN
	    $DBG_ERROR ('DBGLANVEC\DBG$NGET_PAGES');
	END
    ELSE
    	$DBG_ERROR ('DBGLANVEC\DBG$NGET_PAGES');

    ! The first address is given in the VMS descriptor. The end address
    ! must be computed from the bit length and the bit offset.
    ! 
    CURRENT_PAGE_ADDRESS = .VMS_DESC[DSC$A_POINTER] AND %X'FFFFFE00';
    BIT_LENGTH = DBG$DATA_LENGTH (.VMS_DESC);
    IF .VMS_DESC[DSC$B_CLASS] EQL DSC$K_CLASS_UBS
    THEN
    	POS = .VMS_DESC[DSC$L_POS]
    ELSE
    	POS = 0;
    END_ADDRESS = .VMS_DESC[DSC$A_POINTER] + (.BIT_LENGTH + .POS - 1)/8;
	

    ! Loop through the pages.
    !
    CURRENT_BLOCK = 0;
    WHILE .CURRENT_PAGE_ADDRESS LEQ .END_ADDRESS DO
	BEGIN

	! Allocate space for a new node. Fill in the value field
	! and link it in to the list (the list is actually being
	! constructed backwards). Increment CURRENT_PAGE_ADDRESS to
	! the next page and loop.
	!
	NEXT_BLOCK = DBG$GET_TEMPMEM (DBG$K_LINK_NODE_SIZE);
	NEXT_BLOCK[DBG$L_LINK_NODE_LINK] = .CURRENT_BLOCK;
	NEXT_BLOCK[DBG$L_LINK_NODE_VALUE] = .CURRENT_PAGE_ADDRESS;
	CURRENT_BLOCK = .NEXT_BLOCK;
	CURRENT_PAGE_ADDRESS = .CURRENT_PAGE_ADDRESS + 512;
	END;
    
    ! Return the address of the last block.
    !
    .PARAM2 = .CURRENT_BLOCK;
    RETURN STS$K_SUCCESS;	
    END;

GLOBAL ROUTINE DBG$NGET_LENGTH (PRIM_DESC, PARAM2, PARAM3) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Uses a symbol's primary descriptor to obtain the length of the symbol's
!	rvalue. The length is to be given in bits. Lengths longer than 2 ** 32
!	must be truncated to this length.
!
!	The debugger assumes that rvalues refer to contiguous blocks of storage.
!	If this is not true for a given variable, this routine fails.
!
!	Length should reflect the maximum length for entities that may vary in
!	size, and include the length of a control word, if one is present.
!
!	If the value of the object can not be materialized by the Type Convertor
!	(DBG$NTYPE_CONV), this routine should return STS$K_INFO. This is
!	generally true for objects of aggregate type, e.g., PASCAL arrays and
!	record, PL/I structures.
!
!	This routine calls a language-specific routine based on the language
!	code in the descriptor header.
!
! FORMAL PARAMETERS:
!
!	prim_desc	- A longword containing the address of a primary descriptor
!
!	param2		- The address of a longword to contain an unsigned integer
!			  longword representing the symbol's rvalue length in bits
!
!	param3		- The address of a longword to contain the address of a
!			  message argument vector as described on page 4-119 of
!			  the VAX/VMS system reference, volume 1A
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	In case of a severe error return, a message argument vector is constructed
!	from dynamic storage and returned.
!
! ROUTINE VALUE:
!
!	An unsigned integer longword completion code
!
! COMPLETION CODES:
!
!	STS$K_SUCCESS (1) - Success. Length of symbol's rvalue returned.
!
!	STS$K_INFO    (3) - Success. Length of the symbol's rvalue returned but
!			    the symbol refers to a value that the Type Convertor
!			    cannot materialize.
!
!	STS$K_SEVERE  (4) - Failure. No length returned. Message argument vector
!			    constructed and returned.
!
! SIDE EFFECTS:
!
!	NONE
!
!
    BEGIN

    MAP 
    	PRIM_DESC: REF DBG$VALDESC;
    LOCAL
    	VMS_DESC,
	VMS_DESC_AREA: DBG$STG_DESC;

    ! Primary Descriptors.
    !
    IF .PRIM_DESC [DBG$B_DHDR_TYPE] EQL DBG$K_PRIMARY_DESC
    THEN
    	BEGIN

	! Call a routine to construct the VMS descriptor.
	!
	VMS_DESC = VMS_DESC_AREA;
	IF NOT DBG$MAKE_VMS_DESC (.PRIM_DESC, .VMS_DESC) 
	THEN
	    $DBG_ERROR ('DBGLANVEC\DBG$NGET_LENGTH');
	END

    ! Volatile Value Descriptors or Value Descriptors.
    !
    ELSE IF .PRIM_DESC [DBG$B_DHDR_TYPE] EQL DBG$K_V_VALUE_DESC
    OR .PRIM_DESC [DBG$B_DHDR_TYPE] EQL DBG$K_VALUE_DESC
    THEN

    	! In this case just get the VMS descriptor out of the
	! volatile value descriptor.
	!
	VMS_DESC = PRIM_DESC [DBG$A_VALUE_VMSDESC]

    ! We do not expect any other kind of descriptor.
    !
    ELSE
    	$DBG_ERROR ('DBGLANVEC\DBG$NGET_LENGTH unknown descriptor type');


    ! Call the routine in DBGVALUES that extracts a bit length from
    ! a VMS descriptor.
    ! 
    .PARAM2 = DBG$DATA_LENGTH (.VMS_DESC);
    RETURN STS$K_SUCCESS;
    END;

GLOBAL ROUTINE DBG$NCOPY_DESC (DESC, PARAM2, PARAM3, PARAM4) =
!
! FUNCTIONAL DESCRIPTION:
!
!	Accepts as input a language specific primary or value descriptor
!	(constructed from listed storage)
!	and makes a copy of the descriptor out of non-listed storage. This 
!	non-volatile copy will be stored in conjunction with x-points and
!	current location.
!
!	This routine may use DBG$NCOPY to copy each portion of the 
!	descriptor that has been created from listed dynamic storage.
!
! FORMAL PARAMETERS:
!
!	desc			- The address of a language specifc primary or
!				  value descriptor
!
!	param2			- The address of a longword to contain the address
!				  of the non-volatile copy of the descriptor
!
!	param3			- The address of a longword to contain the address
!				  of a message argument vector for errors
!
!	param4			- A flag saying whether to copy into permanent
!				  memory or temporary memory. Only used in
!				  implementation level 3.
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	On success, the non-volatile copy of a primary descriptor.
!
!	On failure, a message argument vector.
!
! ROUTINE VALUE:
!
!	An unsigned integer longword completion code
!
! COMPLETION CODES:
!
!	STS$K_SUCCESS	(1)	- Success. Copy constructed and returned.
!
!	STS$K_SEVERE    (4)	- Failure. Copy not produced. Message argument
!				  vector constructed and returned.
!
! SIDE EFFECTS:
!
!	NONE
!
    BEGIN

    MAP
    	DESC: REF DBG$VALDESC;

    BUILTIN 
	ACTUALCOUNT;		! Count of acual parameters.

    LOCAL
	LENGTH,			! Length in bytes of copy
	PERM_FLAG;		! Flag saying whether to copy into permanent
				!    or temporary memory.

    ! Enable a handler which will take care of NOFREE error messages.
    ! The reason for this is, if we run out of memory part way through
    ! copying the descriptor, then we want to release the memory we
    ! have allocated so far, so that it does not get lost forever.
    !
    ENABLE
    	COPY_DESC_HANDLER;

    ! Default the fourth parameter to TRUE.
    ! Also initialize the pointer to the new descriptor header.
    !
    IF ACTUALCOUNT() LSS 4
    THEN
	PERM_FLAG = TRUE
    ELSE
	PERM_FLAG = .PARAM4;
    COPY_DESC_HEAD = 0; 

    ! Compute the number of bytes to allocate. Always allocate
    ! at least 16 + base size of value descriptor.
    !
    LENGTH = .DESC[DBG$W_DHDR_LENGTH];
    IF .LENGTH LSS 16 + 4*DBG$K_VALDESC_BASE_SIZE
    THEN
    	LENGTH = 16 + 4*DBG$K_VALDESC_BASE_SIZE;
		
    CASE .DESC [DBG$B_DHDR_TYPE] FROM DBG$K_LITERAL TO DBG$K_V_VALUE_DESC OF
    	SET

	! Ordinary value descriptors. These have the actual value embedded
	! inside them. Copy the descriptor and fix up the pointer field
	! so it points to the right place.
	!
	[DBG$K_VALUE_DESC]:
	    BEGIN
	    MAP
		DESC: REF DBG$VALDESC;	! Pointer to a new style value
					!     descriptor (the original)
	    LOCAL
	   	DESC_COPY: REF DBG$VALDESC;	! Pointer to a new style value
						!     descriptor (the copy).

	    IF .PERM_FLAG
	    THEN
		DESC_COPY = DBG$GET_MEMORY ((3+.LENGTH)/4)
	    ELSE
		DESC_COPY = DBG$GET_TEMPMEM ((3+.LENGTH)/4);
	    CH$MOVE (.DESC[DBG$W_DHDR_LENGTH], .DESC, .DESC_COPY);
	    DESC_COPY [DBG$L_VALUE_POINTER] = DESC_COPY [DBG$A_VALUE_ADDRESS];
	    .PARAM2 = .DESC_COPY;
	    END;

	! Volatile value descriptors. These point to a region of user
	! memory containing the value. We do the same as above except 
	! that we do not fix up the pointer field.
	!
	[DBG$K_V_VALUE_DESC]:
	    BEGIN
	    MAP
		DESC: REF DBG$VALDESC;	! Pointer to a new style value
					!     descriptor (the original)
	    LOCAL
		DESC_COPY: REF DBG$VALDESC;	! Pointer to a new style value
						!     descriptor (the copy).

	    IF .PERM_FLAG
	    THEN
		DESC_COPY = DBG$GET_MEMORY ((3+.LENGTH)/4)
	    ELSE
		DESC_COPY = DBG$GET_TEMPMEM ((3+.LENGTH)/4);
	    CH$MOVE (.DESC[DBG$W_DHDR_LENGTH], .DESC, .DESC_COPY);
	    .PARAM2 = .DESC_COPY;
	    END;
		
	! New style Primary Descriptors. Here we have to copy the root
	! node and all sub-nodes. Note that we have to do this carefully,
    	! in such as way that at any time we call GET_MEMORY, we must
    	! have a valid (though partially constructed) Primary. This is
    	! in case GET_MEMORY signals a NOFREE error message - we want
    	! to be able to release the storage we have allocated up
    	! to the point of running out of memory.
	!
	[DBG$K_PRIMARY_DESC]:
	    BEGIN

	    MAP
		DESC: REF DBG$PRIMARY;			! Pointer to the Primary
							!     Descriptor to 
							!     be copied.
	    LOCAL
	  	DESC_COPY : REF DBG$PRIMARY,		! Pointer to the copy
							!     of the Primary
							!     Descriptor.
		DIMCNT,
		NEW_SUBNODE: REF DBG$PRIM_NODE, 	! Pointer to a copy of
							!    a subnode
		NUMBLKS,
		PREV_SUBNODE: REF DBG$PRIM_NODE,	! Pointer to a copy of
							!    a subnode
		SIZE,					! Size of a subnode
		SUBCNT,
		SUBNODE: REF DBG$PRIM_NODE;		! Pointer to the original
							!    subnode.

	    ! Allocate memory for a new root node and copy the
	    ! values into it. We will fix up forward and back
	    ! links later.
	    !
	    IF .PERM_FLAG
	    THEN
    		BEGIN
		DESC_COPY = DBG$GET_MEMORY (DBG$K_PRIMARY_SIZE);

    		! Put a pointer to the Primary in this own variable so
    		! COPY_DESC_HANDLER can later free up the storage.
    		!
    	        COPY_DESC_HEAD = .DESC_COPY;
    		END
	    ELSE
		DESC_COPY = DBG$GET_TEMPMEM (DBG$K_PRIMARY_SIZE);
	    CH$MOVE (4*DBG$K_PRIMARY_SIZE, .DESC, .DESC_COPY);

    	    ! Fix up the forward and back links so we have a valid partially
    	    ! constructed Primary - i.e., we do not want to leave them pointing
    	    ! to the original Primary.
    	    !
    	    DESC_COPY[DBG$L_PRIM_FLINK] = DESC_COPY[DBG$L_PRIM_FLINK];
    	    DESC_COPY[DBG$L_PRIM_BLINK] = DESC_COPY[DBG$L_PRIM_FLINK];

	    ! Loop through each of the subnodes.
	    !
	    SUBNODE = .DESC [DBG$L_PRIM_FLINK];
	    PREV_SUBNODE = 0;
	    WHILE .SUBNODE NEQ DESC[DBG$L_PRIM_FLINK] DO
		BEGIN

		! Allocate space for the new subnode.
		!
		IF .SUBNODE [DBG$B_PNODE_FCODE] EQL RST$K_TYPE_ARRAY
		THEN
		    BEGIN
		    ! Use larger of SUBCNT, DIMCNT.
		    SUBCNT = .SUBNODE[DBG$B_PNARR_SUBCNT];
		    DIMCNT = .SUBNODE[DBG$B_PNARR_DIMCNT];
		    IF .SUBCNT GTR .DIMCNT
		    THEN
			NUMBLKS = .SUBCNT
		    ELSE
			NUMBLKS = .DIMCNT;
		    SIZE = DBG$K_PRIM_SIZE_ARRAY + 
			       DBG$K_PRIM_SIZE_SUBS*.NUMBLKS;
		    END
		ELSE IF .SUBNODE [DBG$B_PNODE_FCODE] EQL RST$K_TYPE_RECORD
		THEN
		    SIZE = DBG$K_PRIM_SIZE_RECORD
		ELSE IF .SUBNODE [DBG$B_PNODE_FCODE] EQL RST$K_TYPE_VARIANT
		THEN
		    SIZE = DBG$K_PRIM_SIZE_VARIANT
		ELSE 
		    SIZE = DBG$K_PRIM_SIZE_NORMAL;
		IF .PERM_FLAG
		THEN
		    NEW_SUBNODE = DBG$GET_MEMORY(.SIZE)
		ELSE
		    NEW_SUBNODE = DBG$GET_TEMPMEM(.SIZE);

		! Copy the values.
		!
		CH$MOVE (4*.SIZE, .SUBNODE, .NEW_SUBNODE);

    		IF .PERM_FLAG AND (.SUBNODE [DBG$B_PNODE_FCODE] EQL RST$K_TYPE_VARIANT)
		THEN
		    NEW_SUBNODE[DBG$V_PNVAR_VALID] = FALSE;

		! Fill in the forward and back links.
	        !
		IF .PREV_SUBNODE EQL 0
		THEN
		    BEGIN
		    DESC_COPY [DBG$L_PRIM_FLINK] = .NEW_SUBNODE;
    		    DESC_COPY [DBG$L_PRIM_BLINK] = .NEW_SUBNODE;
    		    NEW_SUBNODE [DBG$L_PNODE_FLINK] = DESC_COPY [DBG$A_PRIM_FLINK];
		    NEW_SUBNODE [DBG$L_PNODE_BLINK] = DESC_COPY [DBG$A_PRIM_FLINK];
		    END
		ELSE
		    BEGIN
		    PREV_SUBNODE [DBG$L_PNODE_FLINK] = .NEW_SUBNODE;
    		    DESC_COPY [DBG$L_PRIM_BLINK] = .NEW_SUBNODE;
    		    NEW_SUBNODE [DBG$L_PNODE_FLINK] = DESC_COPY [DBG$A_PRIM_FLINK];
		    NEW_SUBNODE [DBG$L_PNODE_BLINK] = .PREV_SUBNODE;
		    END;
		PREV_SUBNODE = .NEW_SUBNODE;
		SUBNODE = .SUBNODE [DBG$L_PNODE_FLINK];
		END;

	    .PARAM2 = .DESC_COPY;
	     END;

	! At implementation level 3, we do not expect any other kind
	! of descriptor.
	!
	[INRANGE, OUTRANGE]:
	    $DBG_ERROR ('DBGLANVEC\DBG$NCOPY_DESC');

	TES;

    ! The copying has been done. Return success.
    !
    RETURN STS$K_SUCCESS;
    END;

ROUTINE COPY_DESC_HANDLER (SIG, MECH) =
!
! FUNCTION
!	This is the error hander for DBG$NCOPY_DESC. This routine is 
!	responsible for freeing up the memory we have allocated so
!	far, if we get a NOFREE error message while copying the descriptor.
!
! INPUTS
!	SIG	- Signal argument vector
!	MECH	- not used
!
! IMPLICIT INPUT
!	COPY_DESC_HEAD - An own variable that points to the head of
!			 the descriptor copy.
!
! OUTPUTS
!	This routine resignals the error.
!
    BEGIN
    MAP
    	SIG: REF VECTOR;

    ! Only do something if the error is "no free storage" and if the own
    ! variable COPY_DESC_HEAD is not zero (meaning that some storage has
    ! been allocated before the NOFREE).
    !
    IF .SIG[1] EQL DBG$_NOFREE
    THEN
        IF .COPY_DESC_HEAD NEQ 0
        THEN
    	    BEGIN
    	    DBG$NFREE_DESC(.COPY_DESC_HEAD);
    	    COPY_DESC_HEAD = 0;
    	    END;    

    ! Having freed the storage, resignal the error.
    !
    RETURN SS$_RESIGNAL;
    END;

GLOBAL ROUTINE DBG$NFREE_DESC (DESC, PARAM2, PARAM3) =
!
!++
! FUNCTIONAL DESCRIPTION:
!
!	Releases dynamic storage associated with a non-volatile copy of a 
!	language specific value or primary descriptor.
!	This routine accepts as input a copy of a primary or value
!	descriptor produced by DBG$NCOPY_DESC and calls the
!	routine DBG$REL_MEMORY to release each block of non-listed dynamic
!	storage contained within the descriptor.
!
!	This routine calls a language-specific routine based on the
!	language code in the descriptor header.
!
! FORMAL PARAMETERS:
!
!	desc			- The address of a non-volatile primary or
!				  value descriptor
!
!	param2			- The address of a longword to contain the address
!				  of a message argument vector for errors
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	On failure, a message argument vector.
!
! ROUTINE VALUE:
!
!	An unsigned integer longword completion code
!
! COMPLETION CODES:
!
!	STS$K_SUCCESS   (1)	- Success. Storage for  descriptor released.
!
!	STS$K_SEVERE    (4)	- Failure. Storage for descriptor not released. Message
!				  argument vector constructed and returned.
!
! SIDE EFFECTS:
!
!	Dynamic memory is returned to the free storage pool.
!
!--
    BEGIN
    MAP
    	DESC: REF DBG$VALDESC;

    ! Handle value descriptors separately from primary descriptors.
    !
    SELECTONE .DESC [DBG$B_DHDR_TYPE] OF
    	SET

	! Ordinary value descriptors. These are allocated in one contiguous
	! block so we can just release that block.
	!
	[DBG$K_VALUE_DESC, DBG$K_V_VALUE_DESC]:
	    BEGIN
	    DBG$REL_MEMORY (.DESC);
	    END;

	! New style Primary Descriptors. Here we have to release storage
	! for the root node and all the subnodes.
	!
	[DBG$K_PRIMARY_DESC]:
	    BEGIN
	    MAP
	   	DESC: REF DBG$PRIMARY;			! Pointer to the Primary
							!     Descriptor for which
							!     a symid list is to
							!     be constructed.
	    LOCAL
		NEW_SUBNODE,				! Pointer to the next
							!    subnode
		SAVED_PTR,				! Position in root node
							!    that is pointed to
							!    by the flink in the
							!    last subnode.
		SUBNODE: REF DBG$PRIM_NODE;		! Pointer to a subnode.

	    ! First save away a pointer to the subnode and a pointer
	    ! which will identify when we have looped through all the
	    ! subnodes. Then release the storage associated with the
	    ! root node.
	    !
	    SAVED_PTR = DESC [DBG$L_PRIM_FLINK];
	    SUBNODE = .DESC [DBG$L_PRIM_FLINK];
	    DBG$REL_MEMORY (.DESC);

	    ! Loop through the subnodes. After saving a pointer to the
	    ! next subnode, release the storage for the current subnode.
	    !
	    WHILE .SUBNODE NEQ .SAVED_PTR DO
		BEGIN
		NEW_SUBNODE = .SUBNODE [DBG$L_PNODE_FLINK];
		DBG$REL_MEMORY (.SUBNODE);
		SUBNODE = .NEW_SUBNODE;
		END;
	    END;

        ! At implementation level 3, we do not expect any other kind
	! of descriptor.
	!
	[OTHERWISE]:
	    $DBG_ERROR ('DBGLANVEC\DBG$NFREE_DESC');

	TES;

    ! The storage has been freed. Return success.
    !
    RETURN STS$K_SUCCESS;
    END;

GLOBAL ROUTINE DBG$NGET_SYMID (DESC, PARAM2, PARAM3) =
!
! FUNCTIONAL DESCRIPTION:
!	
!	Returns a list of symids contained within a language specific primary
!	or value descriptor.
!
!	This routine calls a language-specific routine based on the language
!	code in the descriptor header.
!
! FORMAL PARAMETERS:
!
!	desc		- A longword containing the address of a language specific
!			  primary or value descriptor.
!
!	param2		- The address of a longword to contain the address of 
!			  the first node in the symid list. Each node in the
!			  consists of a two longword block. The first longword
!			  is the link field and contains the address of the 
!			  next node in the list. This field is 0 for the last
!			  node in the list. The second longword contains the
!			  value of a symid. Each symid that appears in a 
!			  descriptor should appear once and only once in the
!			  symid list.
!
!	param3		- The address of a longword to contain the address of
!			  a message argument vector as described on page 4-119
!			  of the VAX/VMS system reference, volume 1A
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	In case of a severe error return, a message argument vector is constructed
!	from dynamic storage and returned.
!
! ROUTINE VALUE:
!
!	An unsigned integer longword completion code
!
! COMPLETION CODES:
!
!	STS$K_SUCCESS (1) - Success. Symid list constructed and returned.
!
!	STS$K_SEVERE  (4) - Failure. No symid list returned. Message argument
!			    vector constructed and returned.
!
! SIDE EFFECTS:
!
!	NONE
!
    BEGIN
    MAP
    	DESC: REF DBG$VALDESC;
    LOCAL
    	DIMCNT,
	NUMBLKS,
	SUBCNT,
	SYMID_LIST;				! Pointer to the head of
						!    the symid list.

    ! Implementation level 3 - all languages at this level have common
    ! descriptors so we construct the symid list here.
    !

	ROUTINE APPEND_TO_LIST (SYMID, SYMID_LIST) : NOVALUE =
	! 
	! FUNCTION
	! 	This subroutine is used below to append a new symid
	!	to the symid list under construction.
	!
	! INPUTS
	! 	SYMID -		The symid to be added to the list.
	!	SYMID_LIST -	Points to a longword containing a pointer
	!			to the head of the symid list.
	!
	! OUTPUTS
	!	If the symid list was empty, a one-node list will be
	!	created and the SYMID_LIST parameter will contain
	!	a pointer to this one-node list.
	! 	Otherwise, the SYMID_LIST parameter is left unchanged
	! 	but a node may be added to the list it points to.
	!
	    BEGIN
	    LOCAL
       		LINK_NODE: REF DBG$LINK_NODE,	! Pointer to a node in the
						!    symid list.
		PREV_NODE: REF DBG$LINK_NODE;	! Pointer to a node in the
						!    symid list.

	    ! If the symid is zero, do not add it to the list.
	    !
	    IF .SYMID EQL 0 THEN RETURN;

	    ! First check whether the given symid is on the list already.
	    !
	    LINK_NODE = ..SYMID_LIST;
	    PREV_NODE = .SYMID_LIST;
	    WHILE .LINK_NODE NEQ 0 DO
		BEGIN
		IF .LINK_NODE [DBG$L_LINK_NODE_VALUE] EQL .SYMID
		THEN
		    RETURN;
		PREV_NODE = .LINK_NODE;
		LINK_NODE = .LINK_NODE [DBG$L_LINK_NODE_LINK];
		END;


	    ! Allocate space for a new node and put it on the list.
	    !
       	    LINK_NODE = DBG$GET_TEMPMEM (DBG$K_LINK_NODE_SIZE);
	    PREV_NODE [DBG$L_LINK_NODE_LINK] = .LINK_NODE;
      	    LINK_NODE [DBG$L_LINK_NODE_VALUE] = .SYMID;
	    END;

    ! Initialize the pointer to the symid list.
    !
    SYMID_LIST = 0;

    ! Handle value descriptors separately from primary descriptors.
    !
    SELECTONE .DESC [DBG$B_DHDR_TYPE] OF
    	SET

	! Ordinary value descriptors.
	!
	[DBG$K_VALUE_DESC, DBG$K_V_VALUE_DESC]:
	    BEGIN
	    MAP
		DESC: REF DBG$VALDESC;	! Pointer to a new style value
						!     descriptor 
	    APPEND_TO_LIST (.DESC [DBG$L_DHDR_TYPEID], SYMID_LIST);
	    APPEND_TO_LIST (.DESC [DBG$L_DHDR_SYMID0], SYMID_LIST);
	    END;

	! New style Primary Descriptors. Here we have to get symids from 
	! the root node and all sub-nodes.
	!
	[DBG$K_PRIMARY_DESC]:
	    BEGIN

	    MAP
		DESC: REF DBG$PRIMARY;			! Pointer to the Primary
							!     Descriptor for which
							!     a symid list is to
							!     be constructed.

	    LOCAL
		SUBNODE: REF DBG$PRIM_NODE;		! Pointer to a subnode.

	    ! Append the typeid and the symid from the root node.
	    !
	    APPEND_TO_LIST (.DESC [DBG$L_DHDR_TYPEID], SYMID_LIST);
	    APPEND_TO_LIST (.DESC [DBG$L_DHDR_SYMID0], SYMID_LIST);

	    ! Loop through each of the subnodes.
	    !
	    SUBNODE = .DESC [DBG$L_PRIM_FLINK];
	    WHILE .SUBNODE NEQ DESC[DBG$L_PRIM_FLINK] DO
		BEGIN

		! All kinds of subnodes have typeids and symids
		! so we append these.
		!
		APPEND_TO_LIST (.SUBNODE [DBG$L_PNODE_TYPEID], SYMID_LIST);
		APPEND_TO_LIST (.SUBNODE [DBG$L_PNODE_SYMID], SYMID_LIST);

		! If the subnode is an array node then it also
		! has typeids in the subscript vector.
		!
		IF .SUBNODE [DBG$B_PNODE_FCODE] EQL RST$K_TYPE_ARRAY
		THEN
		    BEGIN
		    LOCAL 
			SUBVECTOR: REF DBG$PRIM_NODE_SUBS;
		    APPEND_TO_LIST (.SUBNODE [DBG$L_PNARR_CELLTYPE],SYMID_LIST);
		    SUBVECTOR = SUBNODE [DBG$A_PNARR_SVECTOR];
		    ! Use whichever is larger, subcnt or dimcnt.
		    SUBCNT = .SUBNODE[DBG$B_PNARR_SUBCNT];
		    DIMCNT = .SUBNODE[DBG$B_PNARR_DIMCNT];
		    IF .SUBCNT GTR .DIMCNT
		    THEN
			NUMBLKS = .SUBCNT
		    ELSE
			NUMBLKS = .DIMCNT;
		    INCR I FROM 0 TO .NUMBLKS-1 DO
			APPEND_TO_LIST (.SUBVECTOR[.I, DBG$L_PNSUB_TYPEID],
					SYMID_LIST);
		    END
		ELSE IF .SUBNODE [DBG$B_PNODE_FCODE] EQL RST$K_TYPE_VARIANT
		THEN
		    APPEND_TO_LIST(.SUBNODE[DBG$L_PNVAR_TAGID],SYMID_LIST);

		SUBNODE = .SUBNODE [DBG$L_PNODE_FLINK];
		END;
	    END;

	! At implementation level 3, we do not expect any other kind
	! of descriptor.
	!
	[OTHERWISE]:
	    $DBG_ERROR ('DBGLANVEC\DBG$NGET_SYMID');

	TES;

    ! The symid list has been constructed. Return success.	
    !
    .PARAM2 = .SYMID_LIST;
    RETURN STS$K_SUCCESS;
    END;

GLOBAL ROUTINE DBG$NINITIALIZE : NOVALUE =
!
! FUNCTION
!	This routine calls language specific initialization routines.  This is
!	done before each command is processed to garuantee the integrity of the
!	language specific machinery.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NOVALUE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
    BEGIN
    RETURN;
    END;
END ELUDOM
