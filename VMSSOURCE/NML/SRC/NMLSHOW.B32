%TITLE 'NML SHOW parameter module'
MODULE NML$SHOW (
		LANGUAGE (BLISS32),
		ADDRESSING_MODE (EXTERNAL=GENERAL),
		ADDRESSING_MODE (NONEXTERNAL=GENERAL),
		IDENT = 'V04-000'
		) =
BEGIN
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY:  DECnet-VAX Network Management Listener
!
! ABSTRACT:
!
!    These routines return volatile data base information in response to
!    an NCP SHOW command message.
!
! ENVIRONMENT:  VAX/VMS Operating System
!
! AUTHOR:  Distributed Systems Software Engineering
!
! CREATION DATE:  30-DEC-1979
!
! MODIFIED BY:
!
!	V03-015	MKP0019		Kathy Perko	4-Mar-1984
!		Fix area numbers when doing SHOW to Phase III nodes.
!
!	V03-014	MKP0018		Kathy Perko	9-Jan-1984
!		Add X25-Access Module entity.
!
!	V03-013	MKP0017		Kathy Perko	9-Nov-1983
!		Fix SHOW KNOWN NODE CIRCUIT <circ id> to simply return a
!		prompt if there aren't any.
!
!	V03-012	MKP0016		Kathy Perko	31-May-1983
!		Fix SHOW single CIRCUIT COUNTERS to return proper data.
!
!	V03-011	MKP0015		Kathy Perko	6-May-1983
!		Fix SHOW CIRCUIT to return circuit info once.  Also, fix
!		SHOW CIRCUIT to return service adjacency info (SDI database)
!		only for NI circuits.
!
!	V03-010	MKP0014		Kathy Perko	30-April-1983
!		Add Service Adjacencies to SHOW CIRCUIT.
!
!	V03-009	MKP0013		Kathy Perko	25-Jan-1983
!		Fix SHOW KNOWN and ACTIVE nodes if there's a circuit qualifier.
!
!	V03-008	MKP0012		Kathy Perko	14-Nov-1982
!		Allow CIRCUIT qualifier on SHOW NODE commands.
!
!	V03-007	MKP0011		Kathy Perko	12-Nov-1982
!		Fix SHOW CIRC nnn COU (which was broken when ADJACENT
!		NODE qualifier was added).
!
!	V03-006	MKP0010		Kathy Perko	29-Oct-1982
!		Add area entity.
!		Change SHOW CIRCUITS to return the first adjacencies
!		information in the same NICE message as the circuit's info.
!
!	V03-005	MKP0009		Kathy Perko	13-Oct-1982
!		Add SHOW ADJACENT NODES CIRCUIT <circuit id> and
!		SHOW KNOWN CIRCUITS ADJACENT NODE <node id>.
!
!	V03-004	MKP0008		Kathy Perko	4-Oct-1982
!		Add SHOW ADJACENT NODES and SHOW CIRCUIT(S) ADJACENT NODE(S).
!		Add X25-Tracepoints to NML$GET_ENTITY_IDS.
!
!	V03-003	MKP0007		Kathy Perko	19-Sept-1982
!		Redo SHOW KNOW NODES and LOOP NODES to use the multiple
!		capabilities of the new QIO interface with NETACP.
!
!	V03-002	MKP0006		Kathy Perko	1-July-1982
!		Add qualifiers to SHOW.  Rewrite a bunch of routines in the
!		process to take advantage of the enhanced QIO interface.
!		Add X29-Server entity.
!
!	V03-001	MKP0005		Kathy Perko	7-May-1982
!		Add double search keys to NETACP QIO interface.  Also, combine
!		the show active and show known node routines into one.
!
!	V02-004	MKP0004		Kathy Perko	2-Jan_1982
!		Fix SHOW LINKS WITH NODE so that, if the node
!		address is greater than 255, the show will work.
!
!	V02-003 MKP0003		Kathy Perko	21-Oct-1981
!		Make NML$GETDATA and NML$PROCESSDATA global
!		routines so compatibility module can use them.
!
!	V02-002	MKP0002		Kathy Perko	8-Sept-1981
!		Fix SHOW EXECUTOR COUNTER
!
!	V02-001	MKP0001		Kathy Perko	22-July-1981
!		Add circuit entity and multidrop lines.
!--


%SBTTL 'Declarations'

!
! TABLE OF CONTENTS:
!

FORWARD ROUTINE
    NML$SHOWENTITY,
    NML$SHOWMULTIPLE	: NOVALUE,
    NML_PROCESS_MULT_BUFFER: NOVALUE,
    NML$SHOW_CIRCUIT	: NOVALUE,
    NML_SHOW_ADJACENCIES,
    NML$SHOW_KNOWN_LOOP : NOVALUE,
    NML$SHOWNODEBYNAME	: NOVALUE,
    NML$SHOWEXECUTOR	: NOVALUE,
    NML$SHOW_MULTIPLE_NODES: NOVALUE,
    NML$GET_ENTITY_IDS,
    NML$BLDSHOWBUFS,
    NML$GETDATA,
    NML$PROCESSDATA	: NOVALUE,
    NML$GETIDSTRING;

!
! INCLUDE FILES:
!

LIBRARY 'LIB$:NMLLIB.L32';
LIBRARY 'SHRLIB$:NMALIBRY.L32';
LIBRARY 'SHRLIB$:NET.L32';
LIBRARY 'SYS$LIBRARY:STARLET.L32';

!
! OWN STORAGE:
!

OWN
    NML$T_LISTBUFFER : VECTOR [NML$K_QIOBFLEN, BYTE];
BIND
    NML$Q_LISTBFDSC  = UPLIT (NML$K_QIOBFLEN, NML$T_LISTBUFFER) : DESCRIPTOR;

OWN
    NML$T_P2BUFFER : VECTOR [NML$K_P2BUFLEN];
BIND
    NML$Q_P2BFDSC = UPLIT (NML$K_P2BUFLEN, NML$T_P2BUFFER) : DESCRIPTOR;

OWN
    NML$T_ENTBUFFER : VECTOR [32];
BIND
    NML$Q_ENTBFDSC = UPLIT (32, NML$T_ENTBUFFER) : DESCRIPTOR;

OWN
    NML$B_ADJACENCY_FOUND: BYTE;

!
! EXTERNAL REFERENCES:
!

$NML_EXTDEF;

EXTERNAL
    nml$gb_ncp_version,		! NICE version being spoken
    nml$gw_vol_exec_addr : BBLOCK [2];

EXTERNAL LITERAL
    CPT$GK_PCNO_DLI;

EXTERNAL ROUTINE
    NML$BLD_REPLY,
    NML$BLDP2,
    NML$ERROR_1,
    NML$ERROR_2,
    NML$GETEXEADR,
    NML$GETINFTABS,
    NML$GETNODADR,
    NML$GETNODNAM,
    NML$NETQIO,
    NML$SEND,
    NML$SHOWPARLIST;


%SBTTL 'NML$SHOWENTITY  Show volatile entity parameters'
GLOBAL ROUTINE NML$SHOWENTITY (ENTITY, INF, LEN, ADR) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine shows volatile entity parameters.
!
! FORMAL PARAMETERS:
!
!	ENTITY		Entity ID
!	INF		Information type code.
!	LEN		Length of entity id string.
!	ADR		Address of entity id string.
!
!--

BEGIN

LOCAL
    STATUS,
    P4_DATA_DSC : DESCRIPTOR,    	! QIO data descriptor
    P4_DATA_PTR,			! Pointer into P4 buffer
    NICE_MSG_DSC : DESCRIPTOR,		! Output message descriptor
    NFBDSC : REF DESCRIPTOR,		! NFB descriptor
    P2DSC  : DESCRIPTOR,		! P2 parameter descriptor
    TABDES : REF DESCRIPTOR;		! Information table descriptor

!
! Get NFB, table, and P2 buffer.
!
NML$GETINFTABS (.ENTITY, .INF, NFBDSC, TABDES, 0);
!
! X25 and X29 Server databases have only one entry.  So always do a
! wildcard zero of these databases.
!
IF .ENTITY EQL NML$C_X25_SERV OR
   .ENTITY EQL NML$C_X29_SERV OR
   .ENTITY EQL NML$C_TRACE THEN
    LEN = -1;
    
NML$BLDP2 (.LEN, .ADR, -1, 0, NML$Q_P2BFDSC, P2DSC);

STATUS = NML$GETDATA (.NFBDSC, P2DSC, NML$GQ_QIOBFDSC, P4_DATA_DSC);
IF .STATUS THEN
    BEGIN
    P4_DATA_PTR = .P4_DATA_DSC [DSC$A_POINTER];
    NML$PROCESSDATA (.ENTITY, .TABDES, P4_DATA_DSC, P4_DATA_PTR, NICE_MSG_DSC);
    END
ELSE
    BEGIN
    NML$BLD_REPLY (NML$AB_MSGBLOCK, NICE_MSG_DSC [DSC$W_LENGTH]);
    NICE_MSG_DSC [DSC$A_POINTER] = NML$AB_SNDBUFFER;
    END;

NML$SEND (.NICE_MSG_DSC [DSC$A_POINTER], .NICE_MSG_DSC [DSC$W_LENGTH]);
RETURN .STATUS;
END;				! End of NML$SHOWENTITY

%SBTTL 'NML$SHOWMULTIPLE  Show multiple entitys parameters'
GLOBAL ROUTINE NML$SHOWMULTIPLE (ENTITY, INF, FORMAT, ENTITY_ADR,
				QUAL_PST, QUAL_LEN, QUAL_ADR) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine reads the volatile data base entries for KNOWN or
!	ACTIVE entities of the specified type.
!
!	First the buffers are built which describe the entity type and
!	the information required for the SHOW request (STATUS, SUMMARY,
!	CHARACTERISTICS, or COUNTERS).  These buffers are then given to
!	the ACP in a QIO request.  The ACP returns the requested information
!	for as many entities as will fit in the P4 buffer.  The information
!	for each entity is formatted into a NICE message and returned to
!	NCP.  After each circuit is formatted, search the adjacency database
!	for all nodes adjacent to that circuit and return a NICE message
!	for each node containing it's adjacency information.
!
!	The QIO is repeated until all entities of the specified type have
!	been returned by the ACP.  
!
!
! FORMAL PARAMETERS:
!
!	ENTITY		Entity type code.
!	INF		Information type code.
!	FORMAT		NMA$C_ENT_KNO => Get KNOWN entities.
!			NMA$C_ENT_ACT => Get ACTIVE entities.
!			NMA$C_ENT_ADJ => Get ADJACENT nodes.
!			NMA$C_ENT_LOO => Get LOOP nodes.
!			>0 Length of entity ID (if there is a qualifier on the
!			SHOW command, it is essentially a multiple show).
!	ENTITY_ADR	Used only if there is a qualifier on the command
!			because the qualifier makes it essentially a multiple
!			SHOW command.
!	QUAL_PST	Address of qualifier's entry in the Parameter
!			Semantic Table (PST).
!	QUAL_LEN	Length of qualifier ID string.
!	QUAL_ADR	Address of qualifier ID string.
!
!--
BEGIN

LOCAL
    NFB		: REF BBLOCK,		! Pointer used to build NFB.
    NFBBUF	: BBLOCK [256],		! Buffer in which to build NFB.
    NFBDSC	: DESCRIPTOR,		! Pointer to NFB descriptor.
    P2BUF	: BBLOCK [NML$K_P2BUFLEN],! P2 buffer
    P2_BUFFER_DSC: DESCRIPTOR,		! Descriptor of empty P2 buffer.
    P2_DSC	: DESCRIPTOR,		! Descriptor of P2 contents.
    P4_BUF	: BBLOCK [NML$K_QIOBFLEN],! P4 buffer.
    P4_BUFFER_DSC: DESCRIPTOR,		! Descriptor of empty P4 buffer.
    TABDSC	: REF DESCRIPTOR,	! Pointer to Information Table desc.
    ENTITY_CNT,				! Count of entities returned by NETACP.
    P4_DATA_DSC	: DESCRIPTOR,		! Return P4 buffer descriptor.
    NICE_MSG_DSC : DESCRIPTOR,		! Output message descriptor
    STATUS;


!
! Get canned NFB and Information Table descriptors for single entity show.
! Then modify them to do a plural show.
!
NFBDSC [DSC$A_POINTER] = NFBBUF;
NML$GETINFTABS (.ENTITY, .INF, NFBDSC, TABDSC, 1);
P2_BUFFER_DSC [DSC$W_LENGTH] = NML$K_P2BUFLEN;
P2_BUFFER_DSC [DSC$A_POINTER] = P2BUF;
NML$BLDSHOWBUFS (.ENTITY, .FORMAT, .ENTITY_ADR,
		NFBBUF,				! Address of NFB.
	    	P2_BUFFER_DSC,			! Descriptor of buffer for P2.
		P2_DSC,				! Descriptor for completed P2.
	    	.QUAL_PST, .QUAL_LEN, .QUAL_ADR);! Qualifier info
P4_BUFFER_DSC [DSC$W_LENGTH] = NML$K_QIOBFLEN;
P4_BUFFER_DSC [DSC$A_POINTER] = P4_BUF;
STATUS = 1;
WHILE .STATUS DO
    BEGIN
    STATUS = NML$GETDATA (NFBDSC, P2_DSC, P4_BUFFER_DSC, P4_DATA_DSC);
    IF .STATUS THEN
	BEGIN
	NML$GL_PRS_FLGS [NML$V_PRS_ENTITY_FOUND] = TRUE;
	!
	! The first longword of the P2 buffer contains the number of
	! entities returned in the P4 buffer.  Then call
	! NML_PROCESS_MULT_BUFFER to return the data in the P4 buffer
	! to NCP.
	!
	ENTITY_CNT = .(.P2_DSC [DSC$A_POINTER]);
	NML_PROCESS_MULT_BUFFER (.ENTITY, .INF,
				.QUAL_PST, .QUAL_LEN, .QUAL_ADR,
				TABDSC, P4_DATA_DSC, .ENTITY_CNT);
	END;
    END;
!
! Return an error response message to NCP if:
!   An error other that end-of-file was returned by the ACP.
!   An end-of-file error was returned by the ACP and
!	The command had a qualifier and the qualifier wasn't in the volatile
!	    database.
!	The command was SHOW X-P GROUP yyyy and no such group was found.
!
IF NOT .STATUS THEN
    BEGIN
    IF (.STATUS NEQ NML$_STS_CMP)	! If the error wasn't end-of-file
		OR			!	or
	((.STATUS EQL NML$_STS_CMP AND	! The error was end-of-file and
	NOT .NML$GL_PRS_FLGS [NML$V_PRS_ENTITY_FOUND])
					! no matches were found in ACPs database
		AND
	((.NML$GL_PRS_FLGS [NML$V_PRS_QUALIFIER]) AND
        (.ENTITY EQL NML$C_PROT_GRP AND	! Entity = X25 group
        .FORMAT GTR 0)))		! Group name specified
    THEN
	BEGIN
	NML$BLD_REPLY (NML$AB_MSGBLOCK, NICE_MSG_DSC [DSC$W_LENGTH]);
	NICE_MSG_DSC [DSC$A_POINTER] = NML$AB_SNDBUFFER;
	NML$SEND (.NICE_MSG_DSC [DSC$A_POINTER],
			.NICE_MSG_DSC [DSC$W_LENGTH]);
	END;
    END;
END;		! of	NML$SHOWMULTIPLE	

%SBTTL 'NML_PROCESS_MULT_BUFFER  Show multiple entitys parameters'
ROUTINE NML_PROCESS_MULT_BUFFER (ENTITY, INF,
				QUAL_PST, QUAL_LEN, QUAL_ADR,
				TABDSC, P4_DATA_DSC, ENTITIES_IN_P4) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!	This routine is called only by NML$SHOWMULTIPLE after it has
!	a P4 buffer with the information for a number of entities to
!	be returned to NCP.  For each entity in the P4 buffer, the
!	routine builds a NICE message and sends it back to NCP.
!
! FORMAL PARAMETERS:
!
!	ENTITY		Entity ID
!	INF		Information type code.
!	QUAL_PST	Address of qualifier's entry in the Parameter
!			Semantic Table (PST).
!	QUAL_LEN	Length of qualifier ID string.
!	QUAL_ADR	Address of qualifier ID string.
!	TABDSC		Information table descriptor
!	P4_DATA_DSC	Descriptor of data in P4 buffer.
!	ENTITIES_IN_P4	Number of entities for which there is information
!			in the P4 buffer.
!--

BEGIN

MAP
    P4_DATA_DSC: REF DESCRIPTOR;

!
! NFB to show an entry in NETACPs adjacency database.
!
$NFBDSC (NML$Q_ADJ_NFB, SHOW,, AJI
		,ADD,		! Search key 1 = node address
		,CIR,		! Search key 2 = circuit name
		);

LOCAL
    NICE_MSG_DSC: DESCRIPTOR,	! NICE response message descriptor.
    P4_DATA_PTR,		! Pointer to data in P4 buffer.
    ENTITY_LEN,
    ENTITY_ADDR,
    STATUS,
    CIRCUIT_TYPE,
    !
    ! Following are fields used for issuing secondary QIOs to adjacency
    ! database.  Used for SHOW ADJACENT NODES CIRCUIT <circuit id>.
    !
    ADJ_P2_BUF: BBLOCK [NML$K_P2BUFLEN],
    ADJ_P2_BUF_DSC: DESCRIPTOR,	! Descriptor for empty P2 buffer.
    ADJ_P2_DSC: DESCRIPTOR;	! P2 buffer descriptor

P4_DATA_PTR = .P4_DATA_DSC [DSC$A_POINTER];
ADJ_P2_BUF_DSC [DSC$W_LENGTH] = NML$K_P2BUFLEN;
ADJ_P2_BUF_DSC [DSC$A_POINTER] = ADJ_P2_BUF;
WHILE (ENTITIES_IN_P4 = .ENTITIES_IN_P4 - 1) GEQ 0 DO
    !
    ! Format the entity's data into NICE response
    ! message.
    !
    BEGIN
    STATUS = TRUE;
    SELECTU .ENTITY OF
	SET
	!
	! Save the circuit type for the call to show the service adjacencies.
	! Save the circuit ID for the call to show the adjacencies.
	!
	[NML$C_CIRCUIT]:
	    BEGIN
	    CIRCUIT_TYPE = ..P4_DATA_PTR;
	    P4_DATA_PTR = .P4_DATA_PTR + 4;
	    ENTITY_LEN = .(.P4_DATA_PTR) <0,16>;
	    ENTITY_ADDR = .P4_DATA_PTR + 2;
	    END;
	!
	! The NICE command is SHOW ADJACENT NODES [CIRCUIT <circuit id>].
	!
	[NML$C_ADJACENT_NODE]:
	    BEGIN
	    !
	    ! If the NICE command is qualified (I.E. SHOW ADJACENT NODES
	    ! CIRCUIT <circuit id>) don't return the node's information
	    ! unless it's in the adjacency database for the specified circuit.
	    !
	    IF .NML$GL_PRS_FLGS [NML$V_PRS_QUALIFIER] THEN
		BEGIN
		STATUS = FALSE;
		ENTITY_LEN = 0;
		ENTITY_ADDR = ..P4_DATA_PTR;
		NML$BLDP2 (.ENTITY_LEN, .ENTITY_ADDR,	! Search 1 = node address
			   .QUAL_LEN, ..QUAL_ADR,	! Search 2 = circuit name
			   ADJ_P2_BUF_DSC,		! P2 buffer descriptor
			   ADJ_P2_DSC);			! Return P2 buffer desc.
		STATUS = NML$GETDATA (NML$Q_ADJ_NFB, ADJ_P2_DSC,
					0, 0);
		END;
	    END;

	[ALWAYS]:
	    !
	    ! Build the NICE response message and send it to NCP.
	    ! Status is false only if I am processing a
	    ! SHOW ADJACENT NODES CIRCUIT <circuit id> and the
	    ! node in the P4 buffer is not adjacent on the specified
	    ! circuit.
	    !
	    BEGIN
	    NML$PROCESSDATA (.ENTITY,
				..TABDSC,
				.P4_DATA_DSC,
				P4_DATA_PTR,
				NICE_MSG_DSC);
	    IF .STATUS THEN
		BEGIN
		!
		! Don't send the NICE message here for circuits.  The
		! adjacency information for the first adjacency must
		! still be added to the message.
		!
		IF .ENTITY NEQ NML$C_CIRCUIT THEN
		    NML$SEND (.NICE_MSG_DSC [DSC$A_POINTER],
		    		.NICE_MSG_DSC [DSC$W_LENGTH]);
		END;
	    END;

	[NML$C_CIRCUIT]:
	    !
	    ! For circuits, the first NICE message returned for each circuit
	    ! contains the circuit's information from the NETACPs CRI (circuit)
	    ! database plus the first adjacency information from NETACP's
	    ! AJI (adjacency) or SDI (service adjacency) database.  Then the
	    ! subsequent adjacencies are returned one to a NICE message
	    ! containing only the circuit ID and the adjacency information.
	    !
	    BEGIN
	    IF .INF NEQ NML$C_COUNTERS THEN
		BEGIN
		NML$B_ADJACENCY_FOUND = 0;
		STATUS = NML_SHOW_ADJACENCIES (NML$C_CIRCUIT_ADJACENT,
					.INF, .ENTITY_LEN, .ENTITY_ADDR,
					.QUAL_PST, .QUAL_LEN, .QUAL_ADR,
					NICE_MSG_DSC);
		!
		! The service adjacency database contains no node information
		! (hence no need to look if there's an adjacent node qualifier
		! on the command) and applies only to NI circuits.
		!
		IF (NOT .NML$GL_PRS_FLGS [NML$V_PRS_QUALIFIER]) AND
		   .CIRCUIT_TYPE EQL NMA$C_CIRTY_NI THEN
		    STATUS = NML_SHOW_ADJACENCIES (NML$C_CIRCUIT_ADJ_SRV,
					  .INF, .ENTITY_LEN, .ENTITY_ADDR,
					  .QUAL_PST, .QUAL_LEN, .QUAL_ADR,
					  NICE_MSG_DSC);
		!
		! If there is no adjacency information for the circuit in either
		! adjacency database and the NICE command isn't qualified by an
		! ADJACENT NODE (in which case the lack of adjacency information
		! means there's nothing to return), return just the circuit information
		!
		IF .NML$B_ADJACENCY_FOUND EQL 0 AND
		   (NOT .NML$GL_PRS_FLGS [NML$V_PRS_QUALIFIER]) AND
		   .STATUS EQL NML$_STS_CMP THEN
		    NML$SEND (.NICE_MSG_DSC [DSC$A_POINTER],
				.NICE_MSG_DSC [DSC$W_LENGTH]);
		END
	    ELSE
		NML$SEND (.NICE_MSG_DSC [DSC$A_POINTER],
		    	  .NICE_MSG_DSC [DSC$W_LENGTH]);
	    END;

	TES;
    END;
END;		! of	NML_PROCESS_MULT_BUFFER	

%SBTTL 'NML$SHOW_CIRCUIT   Show volatile circuit parameters'
GLOBAL ROUTINE NML$SHOW_CIRCUIT (ENTITY, INF, FORMAT, ENTITY_ADR,
				QUAL_PST, QUAL_LEN, QUAL_ADR) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!	This routine shows volatile circuit parameters.
!
! FORMAL PARAMETERS:
!
!	ENTITY		Entity ID
!	INF		Information type code.
!	FORMAT		Entity format or length of entity id string.
!	ENTITY_ADR	Address of entity id string.
!	QUAL_PST	Address of qualifier's entry in the Parameter
!			Semantic Table (PST).
!	QUAL_LEN	Length of qualifier ID string.
!	QUAL_ADR	Address of qualifier ID string.
!
!--

BEGIN
!
! First, return the information in the circuit database.
!
LOCAL
    STATUS,
    P4_DATA_DSC : DESCRIPTOR,    	! QIO data descriptor
    P4_DATA_PTR,			! Pointer into P4 buffer
    NICE_MSG_DSC : DESCRIPTOR,		! Output message descriptor
    NFBDSC : REF DESCRIPTOR,		! NFB descriptor
    P2DSC  : DESCRIPTOR,		! P2 parameter descriptor
    TABDES : REF DESCRIPTOR,		! Information table descriptor
    CIRCUIT_TYPE;

!
! Get NFB, table, and P2 buffer.
!
NML$GETINFTABS (.ENTITY, .INF, NFBDSC, TABDES, 0);
    
NML$BLDP2 (.FORMAT, .ENTITY_ADR, -1, 0, NML$Q_P2BFDSC, P2DSC);

STATUS = NML$GETDATA (.NFBDSC, P2DSC, NML$GQ_QIOBFDSC, P4_DATA_DSC);
IF .STATUS THEN
    BEGIN
    P4_DATA_PTR = .P4_DATA_DSC [DSC$A_POINTER];
    CIRCUIT_TYPE = ..P4_DATA_PTR;
    P4_DATA_PTR = .P4_DATA_PTR + 4;
    NML$PROCESSDATA (.ENTITY, .TABDES, P4_DATA_DSC, P4_DATA_PTR, NICE_MSG_DSC);
    !
    ! Now, return the information from NETACPs adjacency database (AJI) and
    ! service adjacency database (SDI).  If the SHOW command specifies a node,
    ! it is specified in the qualifier information, so only that adjacent
    ! node's information will be returned.  
    !
    IF .INF NEQ NML$C_COUNTERS THEN
	BEGIN
	NML$B_ADJACENCY_FOUND = 0;
	STATUS = NML_SHOW_ADJACENCIES (NML$C_CIRCUIT_ADJACENT,
				.INF, .FORMAT, .ENTITY_ADR,
				.QUAL_PST, .QUAL_LEN, .QUAL_ADR,
				NICE_MSG_DSC);
	!
	! The service adjacency database contains no node information
	! (hence no need to look if there's an adjacent node qualifier
	! on the command) and applies only to NI circuits.
	!
	IF (NOT .NML$GL_PRS_FLGS [NML$V_PRS_QUALIFIER]) AND
	   .CIRCUIT_TYPE EQL NMA$C_CIRTY_NI THEN
	    STATUS = NML_SHOW_ADJACENCIES (NML$C_CIRCUIT_ADJ_SRV,
				  .INF, .FORMAT, .ENTITY_ADR,
				  .QUAL_PST, .QUAL_LEN, .QUAL_ADR,
				  NICE_MSG_DSC);
	!
	! If there is no adjacency information for the circuit in either
	! adjacency database and the NICE command isn't qualified by an
	! ADJACENT NODE (in which case the lack of adjacency information
	! means there's nothing to return), return just the circuit information
	!
	IF .NML$B_ADJACENCY_FOUND EQL 0 AND
	   (NOT .NML$GL_PRS_FLGS [NML$V_PRS_QUALIFIER]) AND
	   .STATUS EQL NML$_STS_CMP THEN
	    NML$SEND (.NICE_MSG_DSC [DSC$A_POINTER],
			.NICE_MSG_DSC [DSC$W_LENGTH]);
	END
    ELSE
	NML$SEND (.NICE_MSG_DSC [DSC$A_POINTER], .NICE_MSG_DSC [DSC$W_LENGTH]);
    END
ELSE
    BEGIN
    NML$BLD_REPLY (NML$AB_MSGBLOCK, NICE_MSG_DSC [DSC$W_LENGTH]);
    NICE_MSG_DSC [DSC$A_POINTER] = NML$AB_SNDBUFFER;
    END;

RETURN .STATUS;
END;				! End of NML$SHOWCIRCUIT

%SBTTL 'NML_SHOW_ADJACENCIES   Show circuit node adjacencies'
ROUTINE NML_SHOW_ADJACENCIES (ENTITY, INF, ENTITY_LEN, ENTITY_ADDR,
				QUAL_PST, QUAL_LEN, QUAL_ADR,
				NICE_MSG_DSC) =

!++
! FUNCTIONAL DESCRIPTION:
!	This routine is called for SHOW CIRCUIT commands.  It is called after
!	the circuit's information has been retrieved from NETACP's CRI database
!	and formatted into a NICE message.  This routine gets buffers of
!	adjacency information for the circuit from NETACPs AJI database.
!	The first adjacency is added to the NICE message containing the circuit's
!	info from the CRI database.  The others are all returned in individual
!	NICE messages.
!	
!
! FORMAL PARAMETERS:
!
!	ENTITY		Entity ID
!	INF		Information type code.
!	ENTITY_LEN	Length of circuit ID
!	ENTITY_ADDR	Pointer to circuit ID string.
!	QUAL_PST	Address of qualifier's entry in the Parameter
!			Semantic Table (PST).
!	QUAL_LEN	Length of qualifier ID string.
!	QUAL_ADR	Address of qualifier ID string.
!	NICE_MSG_DSC	Address of descriptor of NICE message which contains
!			circuit info.  Add the first adjacency info to this
!			message.
!--

BEGIN

MAP
    NICE_MSG_DSC: REF DESCRIPTOR;

LOCAL
    P4_DATA_PTR,		! Pointer to data in P4 buffer.
    STATUS,
    ADJ_NFB_BUF: BBLOCK [256],	! Buffer for adjacency data base NFB.
    ADJ_NFBDSC: DESCRIPTOR,	! NFB descriptor
    ADJ_TABDSC: REF DESCRIPTOR,	! Information table descriptor
    ADJ_P2_BUF: BBLOCK [NML$K_P2BUFLEN],
    ADJ_P2_BUF_DSC: DESCRIPTOR,	! Descriptor for empty P2 buffer.
    ADJ_P2_DSC: DESCRIPTOR,	! P2 buffer descriptor
    ADJ_P4_BUF: BBLOCK [NML$K_QIOBFLEN],
    ADJ_P4_BUF_DSC: DESCRIPTOR,	! P4 buffer descriptor
    ADJ_P4_DATA_DSC: DESCRIPTOR,! P4 buffer data descriptor
    ADJ_P4_DATA_PTR,		! P4 buffer data pointer
    ADJACENCY_COUNT,		! Number of adjacency entities returned in P4.
    MSGSIZE;

ADJ_NFBDSC [DSC$A_POINTER] = ADJ_NFB_BUF;
ADJ_P2_BUF_DSC [DSC$W_LENGTH] = NML$K_P2BUFLEN;
ADJ_P2_BUF_DSC [DSC$A_POINTER] = ADJ_P2_BUF;
ADJ_P4_BUF_DSC [DSC$W_LENGTH] = NML$K_QIOBFLEN;
ADJ_P4_BUF_DSC [DSC$A_POINTER] = ADJ_P4_BUF;

NML$GETINFTABS (.ENTITY,
		.INF,
		ADJ_NFBDSC,
		ADJ_TABDSC, 1);
!
! Build the buffers (NFB, P2, and P4) to get the adjacency information
! for the circuit.  If there is a node qualifier, include that as the
! second search key.
!
NML$BLDSHOWBUFS (.ENTITY,
		.ENTITY_LEN,
		.ENTITY_ADDR,
		ADJ_NFB_BUF, ADJ_P2_BUF_DSC, ADJ_P2_DSC,
		.QUAL_PST, .QUAL_LEN, .QUAL_ADR);

MSGSIZE = .NICE_MSG_DSC [DSC$W_LENGTH];
STATUS = 1;
WHILE .STATUS DO
    BEGIN
    !
    ! Get a buffer full of adjacency information for the circuit.
    !
    STATUS = NML$GETDATA (ADJ_NFBDSC, ADJ_P2_DSC,
			  ADJ_P4_BUF_DSC,
			  ADJ_P4_DATA_DSC);
    IF .STATUS THEN
	BEGIN
	ADJACENCY_COUNT = .(.ADJ_P2_DSC [DSC$A_POINTER]);
	ADJ_P4_DATA_PTR = .ADJ_P4_DATA_DSC [DSC$A_POINTER];
	!
	! For each adjacency in the buffer, build a NICE message containing
	! the parameters returned in the buffer.  Then send the NICE message
	! to NCP.
	!
	WHILE (ADJACENCY_COUNT = .ADJACENCY_COUNT -1) GEQ 0 DO
	    BEGIN
	    !
	    ! If this is the first adjacency, include the adjacency info in
	    ! the circuit NICE message already started by the calling routine.
	    !
	    IF NOT .NML$B_ADJACENCY_FOUND THEN
		BEGIN
		NML$B_ADJACENCY_FOUND = 1;
		ADJ_P4_DATA_PTR = .(.ADJ_P4_DATA_PTR)<0,16> +  ! Skip the circuit ID.
						.ADJ_P4_DATA_PTR + 2;
		NML$SHOWPARLIST (NML$GQ_SNDBFDSC,
				MSGSIZE,
				.ADJ_TABDSC,
				ADJ_P4_DATA_DSC,
				ADJ_P4_DATA_PTR);
		NICE_MSG_DSC [DSC$W_LENGTH] = .MSGSIZE;
		END
	    ELSE
	    !
	    ! If the circuit info and the first adjacency info has already been
	    ! returned to NCP, format each of the rest of the adjacencies into a
	    ! NICE message of its own without repeating the circuit information
	    ! except for the circuit ID.
	    !
		BEGIN
		NML$PROCESSDATA (.ENTITY,
				.ADJ_TABDSC,
				ADJ_P4_DATA_DSC,
				ADJ_P4_DATA_PTR, 
				.NICE_MSG_DSC);
		END;

	    NML$SEND (.NICE_MSG_DSC [DSC$A_POINTER],
			.NICE_MSG_DSC [DSC$W_LENGTH]);
	    END;
	END;
    END;				
!
! If the QIO failed for any reason other than end-of-file (no adjacencies were
! found), return an error to NCP
!
IF NOT .STATUS AND
   .STATUS NEQ NML$_STS_CMP THEN
    BEGIN
    NML$BLD_REPLY (NML$AB_MSGBLOCK, NICE_MSG_DSC [DSC$W_LENGTH]);
    NICE_MSG_DSC [DSC$A_POINTER] = NML$AB_SNDBUFFER;
    NML$SEND (.NICE_MSG_DSC [DSC$A_POINTER],
		.NICE_MSG_DSC [DSC$W_LENGTH]);
    END;
RETURN .STATUS;
END;			! of NML_SHOW_ADJACENCIES

%SBTTL 'NML$SHOW_KNOWN_LOOP Show known loopnode parameters'
GLOBAL ROUTINE NML$SHOW_KNOWN_LOOP (ENT, INF, DUM1, DUM2) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine reads the volatile data base entries for all
!	loop nodes.
!
! FORMAL PARAMETERS:
!
!	ENT		Entity type code.
!	INF		Information type code.
!	DUM1		Not used.
!	DUM2		Not used.
!
!--

BEGIN

!
! Counters are not supported for loop nodes.
!
IF .INF EQLU NML$C_COUNTERS THEN
    RETURN;
NML$SHOWMULTIPLE (NML$C_LOOPNODE, .INF, NMA$C_ENT_LOO, 0,
			0, 0, 0);		! No qualifier

END;				! End of NML$SHOW_KNOWN_LOOP

%SBTTL 'NML$SHOWNODEBYNAME  Show volatile node parameters'
GLOBAL ROUTINE NML$SHOWNODEBYNAME (ENT, INF, LEN, ADR) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine returns volatile information about the single remote
!	node or loop node specified by name.
!
! FORMAL PARAMETERS:
!
!	ENT		Entity type code.
!	INF		Information type code (index).
!	LEN		Length of entity id string.
!	ADR		Address of entity id string.
!
!--

BEGIN

LOCAL
    STATUS,
    P4_DATA_DSC : DESCRIPTOR,		! QIO data descriptor
    P4_DATA_PTR,			! Pointer into P4 buffer
    ENTCODE,				! Internal entity code
    LOOFLAG,				! Loop node flag
    NICE_MSG_DSC : DESCRIPTOR,		! Output message descriptor
    NFBDSC : REF DESCRIPTOR,		! NFB descriptor
    P2DSC  : DESCRIPTOR,		! P2 parameter descriptor
    TABDES : REF DESCRIPTOR;		! Information table descriptor

NML$GETINFTABS (NML$C_NODEBYNAME, .INF, NFBDSC, TABDES, 0);
NML$BLDP2 (.LEN, .ADR, -1, 0, NML$Q_P2BFDSC, P2DSC);

STATUS = NML$GETDATA (.NFBDSC, P2DSC, NML$GQ_QIOBFDSC, P4_DATA_DSC);
IF .STATUS THEN
    BEGIN
    ENTCODE = NML$C_NODEBYNAME;
    P4_DATA_PTR = .P4_DATA_DSC [DSC$A_POINTER];
    !
    ! If this is a loop node then get different data from NETACP.
    ! The P2 buffer is rebuilt because NETACP returned a collating
    ! value in the P2 buffer from the first QIO - this collating
    ! value will cause NETACP to start looking AFTER the loop node
    ! just found, so it won't find it.
    !
    LOOFLAG = .(.P4_DATA_PTR)<0,32>;	! Get loop node flag
    IF .LOOFLAG NEQU 0 THEN
	BEGIN
	NML$GETINFTABS (NML$C_LOOPNODE, .INF, NFBDSC, TABDES, 0);
	NML$BLDP2 (.LEN, .ADR, -1, 0, NML$Q_P2BFDSC, P2DSC);
	STATUS = NML$GETDATA (.NFBDSC, P2DSC, NML$GQ_QIOBFDSC, P4_DATA_DSC);
	ENTCODE = NML$C_LOOPNODE;	! Set entity type to loop node
	END
    ELSE
	P4_DATA_PTR = .P4_DATA_PTR + 4;		! Skip over the loop node flag.
    END;
IF .STATUS THEN
    NML$PROCESSDATA (.ENTCODE, .TABDES, P4_DATA_DSC, P4_DATA_PTR, NICE_MSG_DSC)
ELSE
    BEGIN
    NML$BLD_REPLY (NML$AB_MSGBLOCK, NICE_MSG_DSC [DSC$W_LENGTH]);
    NICE_MSG_DSC [DSC$A_POINTER] = NML$AB_SNDBUFFER;
    END;
NML$SEND (.NICE_MSG_DSC [DSC$A_POINTER], .NICE_MSG_DSC [DSC$W_LENGTH]);
END;				! End of NML$SHOWNODEBYNAME

%SBTTL 'NML$SHOWEXECUTOR  Show volatile executor parameters'
GLOBAL ROUTINE NML$SHOWEXECUTOR (ENT, INF, DUM1, DUM2) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine returns volatile information about the executor node.
!
! FORMAL PARAMETERS:
!
!	ENT		Entity type code.
!	INF		Information type code (index).
!	DUM1		Not used.
!	DUM2		Not used.
!
!--

    BEGIN

    LOCAL
	P4_DATA_DSC : DESCRIPTOR,	! QIO data descriptor
	P4_DATA_PTR,			! Pointer into P4 buffer
	DUMDSC : REF DESCRIPTOR,	! Dummy descriptor
	NICE_MSG_DSC : DESCRIPTOR,		! Output message descriptor
	NFBDSC : REF DESCRIPTOR,	! NFB descriptor
	P2DSC  : DESCRIPTOR,		! P2 parameter descriptor
	TABDES : REF DESCRIPTOR;	! Information table descriptor


NML$GETINFTABS (NML$C_EXECUTOR, .INF, NFBDSC, TABDES, 0);
!
! NETACP returns all executor node counters from both the executor (LNI)
! or the remote (NDI) data bases.
!
IF .INF NEQ NML$C_COUNTERS THEN
    BEGIN
    NML$BLDP2 (-1, 0, -1, 0, NML$Q_P2BFDSC, P2DSC);

    IF NOT NML$GETDATA (.NFBDSC, P2DSC, NML$GQ_EXEBFDSC, NML$GQ_EXEDATDSC)
    THEN
	BEGIN

	NML$BLD_REPLY (NML$AB_MSGBLOCK, NICE_MSG_DSC [DSC$W_LENGTH]);
	NML$SEND (NML$AB_SNDBUFFER, .NICE_MSG_DSC [DSC$W_LENGTH]);
	RETURN

	END;

    NML$GL_EXEDATPTR = .NML$GQ_EXEDATDSC [DSC$A_POINTER];
    NML$GETINFTABS (NML$C_NODE, .INF, NFBDSC, DUMDSC, 0);
    END;

NML$BLDP2 (0, 0, -1, 0, NML$Q_P2BFDSC, P2DSC);

IF NML$GETDATA (.NFBDSC, P2DSC, NML$GQ_QIOBFDSC, P4_DATA_DSC)
THEN
    BEGIN

    P4_DATA_PTR = .P4_DATA_DSC [DSC$A_POINTER];
    NML$PROCESSDATA (NML$C_EXECUTOR, .TABDES, P4_DATA_DSC,
			P4_DATA_PTR, NICE_MSG_DSC);

    END
ELSE
    BEGIN

    NML$BLD_REPLY (NML$AB_MSGBLOCK, NICE_MSG_DSC [DSC$W_LENGTH]);
    NICE_MSG_DSC [DSC$A_POINTER] = NML$AB_SNDBUFFER;

    END;

NML$SEND (.NICE_MSG_DSC [DSC$A_POINTER], .NICE_MSG_DSC [DSC$W_LENGTH]);

END;				! End of NML$SHOWEXECUTOR

%SBTTL 'NML$SHOW_MULTIPLE_NODES  Show multiple node parameters'
GLOBAL ROUTINE NML$SHOW_MULTIPLE_NODES (ENTITY, INF, MULT_TYPE, DUM1,
				QUAL_PST, QUAL_LEN, QUAL_ADR) : NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine reads NETACPs volatile data base entries for known
!	or active nodes.
!
! FORMAL PARAMETERS:
!	ENTITY		Entity ID (Entity Table index)
!	INF		Information type code.
!	MULT_TYPE	NMA$C_ENT_KNO => Get KNOWN nodes.
!			NMA$C_ENT_ACT => Get ACTIVE nodes.
!	DUM1		Dummy parameter. Normally address of entity id string.
!	QUAL_PST	Address of qualifier's entry in the Parameter
!			Semantic Table (PST).
!	QUAL_LEN	Length of qualifier ID string.
!	QUAL_ADR	Address of qualifier ID string.
!
! SIDE EFFECTS:
!	Destroys contents of NML$T_LISTBUFFER.
!
!--

BEGIN
IF NOT .NML$GL_PRS_FLGS [NML$V_PRS_QUALIFIER] THEN
    !
    ! Show the executor node information.
    !
    NML$SHOWEXECUTOR (NML$C_EXECUTOR, .INF, 0, 0);

!
! Show remote node information.
!
NML$SHOWMULTIPLE (NML$C_NODE, .INF,
		  .MULT_TYPE, 0,
		  .QUAL_PST, .QUAL_LEN, .QUAL_ADR);

IF NOT .NML$GL_PRS_FLGS [NML$V_PRS_QUALIFIER] THEN
    !
    ! Show loop node information.
    !
    NML$SHOW_KNOWN_LOOP (NML$C_LOOPNODE, .INF, 0, 0);

END;				! End of NML$SHOW_MULTIPLE_NODES

%SBTTL 'NML$GET_ENTITY_IDS  Get multiple entities'
GLOBAL ROUTINE NML$GET_ENTITY_IDS  (ENTITY, ENTITY_LEN, ENTITY_ADR,
				SHOW_STARTED, LISDSC) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is called for doing SET commands to get the Entity
!	IDs to return in the NICE response messages for each entity updated.
!	On the first call (when SHOW_STARTED is false), this routine
!	sets up the QIO buffers to get the IDs of the entities
!	in the specified ACP database.   On all calls, this routine
!	issues the SHOW QIO to get a buffer of entity IDs.
!
! FORMAL PARAMETERS:
!
!	ENTITY		Internal entity type code.
!	ENTITY_LEN	NMA$C_ENT_KNO => Get KNOWN entries of entity.
!			>0 Get all entries of specified entity (which
!			is qualified and therefore has multiple entries).
!	ENTITY_ADR	Address of entity ID string.
!	SHOW_STARTED	FALSE=>start at beginning of ACPs database.
!	LISDSC		Address of longword to get list descriptor
!					address.
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	If the descriptor is found for the specified entity then success
!	(NML$_STS_SUC) is returned.  If the end of the data base has been
!	reached then an error is returned (NML$_STS_CMP).  If any other
!	error is encountered then a message is signalled.
!
! SIDE EFFECTS:
!
!	NONE
!
!--

BEGIN

!
!  Canned NFBs to get KNOWN entities.
!
$NFBDSC (KNO_CIR_NFBDSC, SHOW, NFB$M_MULT OR NFB$M_ERRUPD,
	CRI, 			! NML$C_CIRCUITS
	NFB$C_WILDCARD,,	! Search key 1 = wildcard, oper1 = eql
	NFB$C_WILDCARD,,	! Search key 2 = wildcard, oper2 = eql
	NAM);
$NFBDSC (KNO_LIN_NFBDSC, SHOW, NFB$M_MULT OR NFB$M_ERRUPD,
	PLI, 			! NML$C_LINE
	NFB$C_WILDCARD,,	! Search key 1 = wildcard, oper1 = eql
	NFB$C_WILDCARD,,	! Search key 2 = wildcard, oper2 = eql
	NAM);
$NFBDSC (KNO_SNK_NFBDSC, SHOW, NFB$M_MULT OR NFB$M_ERRUPD,
	ESI,			! NML$C_SINK
	NFB$C_WILDCARD,,	! Search key 1 = wildcard, oper1 = eql
	NFB$C_WILDCARD,,	! Search key 2 = wildcard, oper2 = eql
	SNK);
$NFBDSC (KNO_LOG_NFBDSC, SHOW, NFB$M_MULT OR NFB$M_ERRUPD,
	EFI,			! NML$C_LOGGING
	NFB$C_WILDCARD,,	! Search key 1 = wildcard, oper1 = eql
	NFB$C_WILDCARD,,	! Search key 2 = wildcard, oper2 = eql
	SIN);
$NFBDSC (KNO_OBJ_NFBDSC, SHOW, NFB$M_MULT OR NFB$M_ERRUPD,
	OBI,			! NML$C_OBJECT
	NFB$C_WILDCARD,,	! Search key 1 = wildcard, oper1 = eql
	NFB$C_WILDCARD,,	! Search key 2 = wildcard, oper2 = eql
	NAM);
$NFBDSC (KNO_LOO_NFBDSC, SHOW, NFB$M_MULT OR NFB$M_ERRUPD,
	NDI,			! NML$C_LOOPNODE
	LOO,,			! Search key 1 = loopnode, oper1 = eql
	NFB$C_WILDCARD,,	! Search key 2 = wildcard, oper2 = eql
	NNA);
$NFBDSC (KNO_NOD_NFBDSC, SHOW, NFB$M_MULT OR NFB$M_ERRUPD,
	NDI,			! NML$C_NODE
	NFB$C_WILDCARD,,	! Search key 1 = wildcard, oper1 = eql
	NFB$C_WILDCARD,,	! Search key 2 = wildcard, oper2 = eql
	LOO,ADD,NNA);
$NFBDSC (KNO_ACC_NET_NFBDSC, SHOW, NFB$M_MULT OR NFB$M_ERRUPD,
	XAI,			! NML$C_PROT_DTE
	NFB$C_WILDCARD,,	! Search key 1 = wildcard, oper1 = eql
	NFB$C_WILDCARD,,	! Search key 2 = wildcard, oper2 = eql
	NET);
$NFBDSC (KNO_DTE_NFBDSC, SHOW, NFB$M_MULT OR NFB$M_ERRUPD,
	XDI,			! NML$C_PROT_DTE
	NFB$C_WILDCARD,,	! Search key 1 = wildcard, oper1 = eql
	NFB$C_WILDCARD,,	! Search key 2 = wildcard, oper2 = eql
	DTE);
$NFBDSC (KNO_GRP_NFBDSC, SHOW, NFB$M_MULT OR NFB$M_ERRUPD,
	XGI,			! NML$C_PROT_GRP
	GRP,,			! Search key 1 = group name, oper1 = eql
	NFB$C_WILDCARD,,	! Search key 2 = wildcard, oper2 = eql
	GRP);
$NFBDSC (KNO_X25_DST_NFBDSC, SHOW, NFB$M_MULT OR NFB$M_ERRUPD,
	XD5,			! NML$C_X25_SERV_DEST
	NFB$C_WILDCARD,,	! Search key 1 = wildcard, oper1 = eql
	NFB$C_WILDCARD,,	! Search key 2 = wildcard, oper2 = eql
	DST);
$NFBDSC (KNO_X25_TRPNT_NFBDSC, SHOW, NFB$M_MULT OR NFB$M_ERRUPD,
	XTT,			! NML$C_TRACEPNT
	NFB$C_WILDCARD,,	! Search key 1 = wildcard, oper1 = eql
	NFB$C_WILDCARD,,	! Search key 2 = wildcard, oper2 = eql
	TPT);
$NFBDSC (KNO_X29_DST_NFBDSC, SHOW, NFB$M_MULT OR NFB$M_ERRUPD,
	XD9,			! NML$C_X29_SERV_DEST
	NFB$C_WILDCARD,,	! Search key 1 = wildcard, oper1 = eql
	NFB$C_WILDCARD,,	! Search key 2 = wildcard, oper2 = eql
	DST);


!
! NFBs to get ACTIVE entries (used only for logging database.  Other
! entities use NML$SHOWMULTIPLE.
!
$NFBDSC (ACT_SNK_NFBDSC, SHOW, NFB$M_MULT OR NFB$M_ERRUPD, ESI,
	NFB$C_WILDCARD,,	! Search key 1 = wildcard, oper1 = eql.
	NFB$C_WILDCARD,,	! Search key 2 = wildcard, oper2 = eql.
	SNK, STA);

$NFBDSC (ACT_LOG_NFBDSC, SHOW, NFB$M_MULT OR NFB$M_ERRUPD, EFI,
	NFB$C_WILDCARD,,	! Search key 1 = wildcard, oper1 = eql.
	NFB$C_WILDCARD,,	! Search key 2 = wildcard, oper2 = eql.
	SIN);


OWN
	NFBDSC	: REF DESCRIPTOR,
	P2_BUF	: VECTOR [NML$K_P2BUFLEN],
	P2DSC	: DESCRIPTOR;

BIND
	P2_BUF_DSC = UPLIT (NML$K_P2BUFLEN, P2_BUF) : DESCRIPTOR;

LOCAL
	MSGSIZE,
	RESLEN  : WORD,
	STATUS,
	SRCHLEN1,
	SRCHADR1,
	SRCHLEN2,
	SRCHADR2,
	NFB:	REF BBLOCK;

!
! To do the QIO, three buffers are needed:
!	The NFB which tells NETACP which database to access and what
!		parameters to return.
!	The P2 buffer which tells NETACP which entity to return the
!		data for.
!	The P4 buffer in which NETACP returns the requested data.
! If this is the first call on NML$GET_ENTITY_IDS for the operation,
! set up the start key, if there is one, and build the P2 buffer for the SHOW
! QIO.  The ACP writes a value into the P2 buffer so that, when the next SHOW
! QIO is issued, it knows how far in its database it got on the last call.
! This way a buffer full of entity IDs is returned on each call, and subsquent
! calls return the next batch of entity IDs.  Thus, the P2 buffer only needs
! to be built once for each operation, and is used for multiple
! calls until all entities in the database have been returned.
!
IF NOT .SHOW_STARTED THEN
    BEGIN
    SRCHLEN1 = -1;
    SRCHADR1 = 0;
    SRCHLEN2 = -1;
    SRCHADR2 = 0;

    IF .ENTITY_LEN EQL NMA$C_ENT_ACT THEN
	!
	! Set up to get ACTIVE entity entries.
	!
	BEGIN
	SELECTONEU .ENTITY OF
	    SET
	    [NML$C_SINK]: NFBDSC = ACT_SNK_NFBDSC;
	    [NML$C_LOGGING]: NFBDSC = ACT_LOG_NFBDSC;
	    TES
  	END
    ELSE
	BEGIN
	!
	! Use canned NFBs (above) and build a P2 buffer to get KNOWN entity entries.
	!
	SELECTONEU .ENTITY OF
	    SET
	    [NML$C_CIRCUIT]: 	NFBDSC  = KNO_CIR_NFBDSC;	! Circuits
	    [NML$C_LINE]:	NFBDSC  = KNO_LIN_NFBDSC;	! Lines
	    [NML$C_SINK]: 	NFBDSC  = KNO_SNK_NFBDSC;	! Logging (sinks)
	    [NML$C_LOGGING]: 	NFBDSC  = KNO_LOG_NFBDSC;	! Logging (filters)
	    [NML$C_LOOPNODE]:		! Loop nodes
		BEGIN
		NFBDSC  = KNO_LOO_NFBDSC;
		SRCHLEN1 = 0;
		SRCHADR1 = 1;		! Match loop nodes
		END;
	    [NML$C_OBJECT]: 	NFBDSC  = KNO_OBJ_NFBDSC;	! Objects
	    [NML$C_NODE]: 	NFBDSC  = KNO_NOD_NFBDSC;	! Remote nodes
	    [NML$C_X25_ACCESS]:
			NFBDSC  = KNO_ACC_NET_NFBDSC;		! X-25 Access Network
	    [NML$C_PROT_DTE]:	NFBDSC  = KNO_DTE_NFBDSC;	! X-25 Protocol DTE
	    [NML$C_PROT_GRP]:
		!
		! GROUPS have one database entry for each DTE in the group.
		! If working with a specific group, get all the entries for
		! the specified group.  Otherwise, get all entries for all
		! groups.
		!
		BEGIN
		NFBDSC = KNO_GRP_NFBDSC;
		NFB = .NFBDSC [DSC$A_POINTER];
		IF .ENTITY_LEN GTR 0 THEN
		    BEGIN
		    NFB [NFB$L_SRCH_KEY] = NFB$C_XGI_GRP;
		    SRCHLEN1 = .ENTITY_LEN;
		    SRCHADR1 = .ENTITY_ADR;
		    END
		ELSE
		    NFB [NFB$L_SRCH_KEY] = NFB$C_WILDCARD;
		END;
	    [NML$C_X25_SERV_DEST]:
		NFBDSC = KNO_X25_DST_NFBDSC;	! X-25 Server Destination
	    [NML$C_TRACEPNT]:
		NFBDSC = KNO_X25_TRPNT_NFBDSC;	! X-25 Tracepoint
	    [NML$C_X29_SERV_DEST]:
		NFBDSC = KNO_X29_DST_NFBDSC;	! X-29 Server Destination
	    [NML$C_LINKS]: ;		! Logical links don't use this.
	    [OTHERWISE]:
		RETURN NML$_STS_MPR;
	    TES;
	END;
	
    !
    ! Build the P2 QIO buffer.
    !
    NML$BLDP2 (	.SRCHLEN1, .SRCHADR1,
		.SRCHLEN2, .SRCHLEN2,
		P2_BUF_DSC, P2DSC);
    END;
!
! Get a bufferfull of entities.  Calling routine must reenter this routine
! to get subsequent bufferfulls.
!
STATUS = NML$GETDATA (.NFBDSC, P2DSC, NML$Q_LISTBFDSC, .LISDSC);
!
! If the error returned is NML$_STS_CMP then the end of the data base
! has been reached.  If any other error is returned then build the
! appropriate message and signal it.
!
IF NOT .STATUS AND (.STATUS NEQ NML$_STS_CMP)
THEN
	BEGIN
	NML$BLD_REPLY (NML$AB_MSGBLOCK, MSGSIZE);
	$SIGNAL_MSG (NML$AB_SNDBUFFER, .MSGSIZE);
	END;

RETURN .STATUS

END;				! End of NML$GET_ENTITY_IDS

%SBTTL 'NML$BLDSHOWBUFS  Build SHOW QIO buffers'
GLOBAL ROUTINE NML$BLDSHOWBUFS (ENTITY, ENT_FORMAT, ENTITY_ADR,
				NFB, P2_BUF_DSC, P2DSC,
				QUAL_PST, QUAL_LEN, QUAL_ADR) =

!++
! FUNCTIONAL DESCRIPTION:
!	This routine is called to finish the NFB buffer and build the P2 
!	buffer for various special purpose SHOW operations.  It is used
!	mostly when processing SHOW KNOWN or ACTIVE commands.
!
! FORMAL PARAMETERS:
!
!	ENTITY		Entity type code.
!	ENT_FORMAT	NMA$C_ENT_KNO => Get KNOWN entities.
!			NMA$C_ENT_ACT => Get ACTIVE entities.
!			NMA$C_ENT_LOO => Get loop nodes.
!			NMA$C_ENT_ADJ => Get adjacent nodes.
!			Length of entity ID (used for SHOW commands with
!			qualifiers.  The qualifier makes the SHOW essentially
!			a multiple SHOW.
!	ENTITY_ADR	Address of entity ID string.  Used only for SHOWs
!			with qualifiers.
!	NFB		Address of buffer with NFB to do single entity SHOW.
!			This buffer is modified to do SHOW KNOWN or ACTIVE.
!	P2_BUF_DSC	Address of descriptor of buffer in which to build
!			P2 info.
!	P2DSC		Address of descriptor of P2 info returned to caller.
!	QUAL_PST	Address of Qualifier's entry in the Parameter
!			Semantic Table (PST).
!	QUAL_LEN	Qualifier ID string length.
!	QUAL_ADR	Qualifier ID string address.
!
!--

BEGIN

MAP
    NFB:	REF BBLOCK,
    QUAL_PST:	REF BBLOCK;

LOCAL
    STATUS,
    SEARCH_VAL1,
    SEARCH_LEN1,
    SEARCH_VAL2,
    SEARCH_LEN2;    

!
! First fill in the NFB.  This block describes the QIO to the ACP.
!
! Set the MULTIPLE bit so the ACP returns multiple links in each buffer,
! and the ERROR UPDATE bit, so the ACP will update it's pointer into it's
! database even if an error is encountered in the search.
!
NFB [NFB$B_FLAGS] = NFB$M_MULT OR NFB$M_ERRUPD;
SELECTONEU .ENT_FORMAT OF
    SET
    !
    ! Set up the NFB to request SHOW KNOWN entities, SHOW ADJACENT NODES,
    ! or SHOW LOOP NODES.
    !
    [NMA$C_ENT_KNO, NMA$C_ENT_LOO, NMA$C_ENT_ADJ]:
	BEGIN
	NFB [NFB$L_SRCH_KEY] = .NML$AB_ENTITYDATA [.ENTITY, EIT$L_KNO_SRCH_ID1];
	NFB [NFB$B_OPER] = .NML$AB_ENTITYDATA [.ENTITY, EIT$B_KNO_OPER1];
	SEARCH_VAL1 = .NML$AB_ENTITYDATA [.ENTITY, EIT$L_KNO_SRCH_VAL1];
	SEARCH_LEN1 = .NML$AB_ENTITYDATA [.ENTITY, EIT$L_KNO_SRCH_LEN1];
	END;
    !
    ! Set up the NFB to request SHOW ACTIVE entities.
    !
    [NMA$C_ENT_ACT]:
	BEGIN
	NFB [NFB$L_SRCH_KEY] = .NML$AB_ENTITYDATA [.ENTITY, EIT$L_ACT_SRCH_ID1];
	NFB [NFB$B_OPER] = .NML$AB_ENTITYDATA [.ENTITY, EIT$B_ACT_OPER1];
	SEARCH_VAL1 = .NML$AB_ENTITYDATA [.ENTITY, EIT$L_ACT_SRCH_VAL1];
	SEARCH_LEN1 = .NML$AB_ENTITYDATA [.ENTITY, EIT$L_ACT_SRCH_LEN1];
	END;
    !
    ! This path is useful for single entity SHOWs or SHOW commands with
    ! qualifiers.  For example, since the X25 GROUP qualifier, DTE, repeats
    ! for a single GROUP, the SHOW command is essentially a multiple
    ! operation.
    !
    [1 TO 16]:
	BEGIN
	NFB [NFB$L_SRCH_KEY] = .NML$AB_ENTITYDATA [.ENTITY, EIT$L_SRCH_ID1];
	NFB [NFB$B_OPER] = NFB$C_OP_EQL;
	SEARCH_VAL1 = .ENTITY_ADR;
	SEARCH_LEN1 = .ENT_FORMAT;
	END;
    TES;

!
! If there's a qualifier on the NICE command, use it for the second search
! key.  Otherwise, default the second search key to a wildcard.
! Also, default the second search key to a wildcard if the entity id
! is for circuits or nodes because the qualifiers for them are, respectively,
! ADJACENT NODE and CIRCUIT, and are held in the adjacency database (AJI)
! rather than the node or circuit databases.
!
NFB [NFB$B_OPER2] = NFB$C_OP_EQL;
IF .NML$GL_PRS_FLGS [NML$V_PRS_QUALIFIER] AND
   .ENTITY NEQ NML$C_CIRCUIT AND
   .ENTITY NEQ NML$C_LOOPNODE AND
   .ENTITY NEQ NML$C_ADJACENT_NODE THEN
    BEGIN
    NFB [NFB$L_SRCH2_KEY] = .QUAL_PST [PST$L_NFBID];
    IF .QUAL_LEN EQL 0 THEN
	SEARCH_VAL2 = ...QUAL_ADR
    ELSE
	SEARCH_VAL2 = ..QUAL_ADR;
    SEARCH_LEN2 = .QUAL_LEN;
    END
ELSE
    BEGIN
    SELECTONEU .ENTITY OF
	SET
	[NML$C_NODE]:
	    !
	    ! For multiple node shows, don't return the executor or loopnodes.
	    ! They are done separately.  Note that using a second search key of
	    ! node address neq 0 filters out both the executor and loopnodes.
	    ! All loopnodes have an address of 0.
	    !
	    BEGIN
	    NFB [NFB$L_SRCH2_KEY] = NFB$C_NDI_ADD;
	    SEARCH_VAL2 = 0;
	    SEARCH_LEN2 = 0;
	    NFB [NFB$B_OPER2] = NFB$C_OP_NEQ;
	    END;

	[NML$C_CIRCUIT_ADJACENT]:
	    !
	    ! For showing the ADJACENT NODES of SHOW CIRC, skip over entries
	    ! for which the node isn't reachable.
	    !
	    BEGIN
	    NFB [NFB$L_SRCH2_KEY] = NFB$C_AJI_REA;
	    SEARCH_VAL2 = 1;
	    SEARCH_LEN2 = 0;
	    END;

	[OTHERWISE]:
	    BEGIN
	    NFB [NFB$L_SRCH2_KEY] = NFB$C_WILDCARD;
	    SEARCH_VAL2 = 0;
	    SEARCH_LEN2 = -1;
	    END;
	TES;
    END;
!
! Build the P2 QIO buffer.
!
STATUS = NML$BLDP2 (.SEARCH_LEN1, .SEARCH_VAL1,
		    .SEARCH_LEN2, .SEARCH_VAL2,
		    .P2_BUF_DSC, .P2DSC);
RETURN .STATUS;

END;		! End of NML$BLDSHOWBUFS

%SBTTL 'NML$GETDATA  Get volatile entity data'
GLOBAL ROUTINE NML$GETDATA (NFBDSC, P2DSC, QBFDSC, P4_DATA_DSC) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine reads volatile entity data for the specified NFB and
!	P2 parameters.
!
! FORMAL PARAMETERS:
!
!	NFBDSC		Address of NFB descriptor.
!	P2DSC		Address of P2 descriptor.
!	QBFDSC		Address of QIO buffer descriptor.
!	P4_DATA_DSC	Address of descriptor for data to be read.
!
!--

BEGIN

MAP
    NFBDSC : REF DESCRIPTOR,
    P2DSC  : REF DESCRIPTOR,
    QBFDSC : REF DESCRIPTOR,
    P4_DATA_DSC : REF DESCRIPTOR;

LOCAL
    STATUS;

IF .QBFDSC NEQ 0 THEN
    P4_DATA_DSC [DSC$A_POINTER] = .QBFDSC [DSC$A_POINTER];

STATUS = NML$NETQIO (.NFBDSC,
		     .P2DSC,
		     P4_DATA_DSC [DSC$W_LENGTH],
		     .QBFDSC);

RETURN .STATUS

END;				! End of NML$GETDATA

%SBTTL 'NML$PROCESSDATA   Add data to output message'
GLOBAL ROUTINE NML$PROCESSDATA (ENT, TABDES, P4_DATA_DSC,
					P4_DATA_PTR, NICE_MSG_DSC) :NOVALUE =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine adds data to the output message using the information
!	table and the input data buffer.
!
! FORMAL PARAMETERS:
!
!	ENT		Internal entity id code.
!	TABDES		Address of information table descriptor.
!	P4_DATA_DSC	Address of data buffer descriptor.
!	P4_DATA_PTR	Address of data buffer pointer.
!	NICE_MSG_DSC	Address of descriptor to describe output message.
!
!--

BEGIN

MAP
    tabdes : REF DESCRIPTOR,
    p4_data_dsc : REF DESCRIPTOR,
    nice_msg_dsc : REF DESCRIPTOR;

LOCAL
    msgsize,			! Output message length
    strdsc : DESCRIPTOR;	! Entity id string descriptor

nml$getidstring (.ent, .p4_data_ptr, strdsc);  ! Get entity id
nml$ab_msgblock [msb$l_flags] = msb$m_entd_fld;
nml$ab_msgblock [msb$b_code] = nma$c_sts_suc;
nml$ab_msgblock [msb$a_entity] = strdsc;

nml$bld_reply (nml$ab_msgblock, msgsize);

nml$showparlist (nml$gq_sndbfdsc,
		     msgsize,
		     .tabdes,
		     .p4_data_dsc,
		     .p4_data_ptr);

nice_msg_dsc [dsc$w_length] = .msgsize;
nice_msg_dsc [dsc$a_pointer] = .nml$gq_sndbfdsc [dsc$a_pointer];
END;				! End of NML$PROCESSDATA

%SBTTL 'NML$GETIDSTRING   Get entity id string'
GLOBAL ROUTINE NML$GETIDSTRING (ENT, P4_DATA_PTR, STRDSC) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine builds the entity id string and descriptor for the
!	NICE response message.  It gets the entity ID from the P4 buffer
!	returned by NETACP.
!
! FORMAL PARAMETERS:
!
!	ENT		Internal entity id code.
!	P4_DATA_PTR	Address of data buffer pointer.
!	STRDSC		Address of descriptor for output id string.
!
!--

BEGIN

MAP
	STRDSC : REF DESCRIPTOR;

LOCAL
	LEN,
	PTR;

STRDSC [DSC$A_POINTER] = .NML$Q_ENTBFDSC [DSC$A_POINTER];
PTR = .STRDSC [DSC$A_POINTER];

SELECTONEU .ENT OF
	SET

	[NML$C_CIRCUIT,
	NML$C_CIRCUIT_ADJACENT,
	NML$C_CIRCUIT_ADJ_SRV,
	NML$C_LINE,
	NML$C_OBJECT]:
	    BEGIN

	    LEN = CH$RCHAR_A (.P4_DATA_PTR);
	    CH$RCHAR_A (.P4_DATA_PTR);

	    CH$WCHAR_A (.LEN, PTR);
	    PTR = CH$MOVE (.LEN, ..P4_DATA_PTR, .PTR);

	    .P4_DATA_PTR = ..P4_DATA_PTR + .LEN;

	    END;

	[NML$C_LOGGING, NML$C_SINK]:
	    ;

	[NML$C_LOOPNODE]:
	    BEGIN

	    .P4_DATA_PTR = ..P4_DATA_PTR + 4;	! Skip address (always 0)

	    CH$WCHAR_A (0, PTR);	! Move 0 address
	    CH$WCHAR_A (0, PTR);

	    LEN = .(..P4_DATA_PTR)<0,16>;	! Move name
	    .P4_DATA_PTR = ..P4_DATA_PTR + 2;
	    CH$WCHAR_A (.LEN, PTR);
	    PTR = CH$MOVE (.LEN, ..P4_DATA_PTR, .PTR);

	    .P4_DATA_PTR = ..P4_DATA_PTR + .LEN;

	    END;

	[NML$C_LINKS]:
	    BEGIN
	    CH$WCHAR_A (0,PTR);
	    PTR = CH$MOVE (2, ..P4_DATA_PTR, .PTR);		! Move link number.
	    .P4_DATA_PTR = ..P4_DATA_PTR + 4;
	    END;

	[NML$C_X25_ACCESS]:
	    $MOVE_ASCIC ('X25-ACCESS', PTR);

	[NML$C_PROT_NET,
	NML$C_PROT_DTE,
	NML$C_PROT_GRP]:
	    $MOVE_ASCIC ('X25-PROTOCOL', PTR);

	[NML$C_X25_SERV,
	NML$C_X25_SERV_DEST]:
	    $MOVE_ASCIC ('X25-SERVER', PTR);

	[NML$C_TRACE,
	 NML$C_TRACEPNT]:
	    $MOVE_ASCIC ('X25-TRACE', PTR);

	[NML$C_X29_SERV,
	NML$C_X29_SERV_DEST]:
	    $MOVE_ASCIC ('X29-SERVER', PTR);

	[NML$C_AREA]:
	    BEGIN
	    CH$WCHAR_A (0, PTR);		    ! 0 means area address
						    !	follows.
	    CH$WCHAR_A (...P4_DATA_PTR, PTR);	    ! Move area address.
	    .P4_DATA_PTR = ..P4_DATA_PTR + 4;	    ! Increment P4 buffer pointer.
	    END;

	[OTHERWISE]:	! It's a remote node or the executor.
	    BEGIN
	    !
	    ! If I'm talking to a Phase III NCP, and the entity is a node
	    ! outside the executor's area, don't return the node to the NCP.
	    ! Phase III doesn't include areas.  If it's a Phase III NCP and
	    ! the node is in the executor's area, clear the area number from
	    ! the node number.
	    !
	    IF CH$RCHAR (nml$gb_ncp_version) LEQ 3 THEN
		BEGIN
		BIND node_addr = ..p4_data_ptr : BBLOCK;

		IF .node_addr [nma$v_area] EQL
			.nml$gw_vol_exec_addr [nma$v_area] THEN
		    node_addr [nma$v_area] = 0;
		END;
	    ptr = CH$MOVE (2, ..p4_data_ptr, .ptr); ! Move address
	    .p4_data_ptr = ..p4_data_ptr + 4;

	    len = .(..p4_data_ptr)<0,16>;	! Move name
	    .p4_data_ptr = ..p4_data_ptr + 2;
	    IF .ent EQL nml$c_executor THEN
		CH$WCHAR_A (.len OR nma$m_ent_exe, ptr)
	    ELSE
		CH$WCHAR_A (.len, ptr);
	    ptr = CH$MOVE (.len, ..p4_data_ptr, .ptr);

	    .p4_data_ptr = ..p4_data_ptr + .len;

	    END;

	TES;

strdsc [dsc$w_length] = .ptr - .strdsc [dsc$a_pointer];
RETURN nml$_sts_suc;
END;				! End of NML$GETIDSTRING

END					! End of module

ELUDOM
