module  lnk_getcmdinp 
		(ident='V04-000'
		,addressing_mode 
			(external    = general
			,nonexternal = long_relative
			)
		) =
begin
!
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
!
!
!
!
!++
!
! MODULE:	LNK_GETCMDINP
!
! FACILITY:	LINKER
!
! ABSTRACT:	Command Language Interface For The LINK Command
!
! HISTORY:
!
! VERSION: 	X01.00
!
! AUTHOR: 	T.J. PORTER 03-MAY-77
!
! MODIFIED BY:
!
!	V03-026	ADE0005		Alan D. Eldridge	24-Jul-1984
!		Save proper STV value on LIB$FIND_FILE error.
!
!	V03-025	ADE0004		Alan D. Eldridge	30-Jun-1984
!		Fix bug in /NOEXE.
!
!	V03-024	ADE0003		Alan D. Eldridge	22-Jun-1984
!		Add LNK$GB_LOCNOV_MAP, LNK$GB_LOCNOV_EXE, and LNK$GB_LOCNOV_SYM
!		for proper "Grammer Rule" support for constructing output file
!		names.  These are really flags which, when set, indicate that
!		appropriate switch had was used locally but had no value
!		associated with it
!
!	V03-023	ADE0002		Alan D. Eldridge	14-Apr-1984
!		More fixes to positional qualifier support.
!
!	V03-022	ADE0001		Alan D. Eldridge	 4-Apr-1984
!		Convert routine INPUTFILE to use LIB$FIND_FILE rather than
!		$SEARCH and $PARSE.
!
!		Add support for proper defualting when /EXE, /MAP, or /SYM
!		are used as local, rather than command, qualifiers.
!
!	V03-021	MCN0001		Maria del C. Nasr	20-Jul-1983
!		Determine if the options file is being read from
!		SYS$INPUT or not.  This is needed so that there is
!		no duplication of input line on output when SET
!		VERIFY is on.
!
!	V03-020	JWT0125		Jim Teague		21-Jun-1983
!		Allow UNIV=* when accompanied by /NOEXE.  It can thus
!		be used only for STB generation from shareable image
!		links.
!
!	V03-019	JWT0119		Jim Teague		11-May-1983
!		Tweak new CLI stuff again... adjust map qualifiers.
!
!	V03-018	JWT0117		Jim Teague		29-Apr-1983
!		/NOEXE is equivalent to /EXE=NL:
!
!	V03-017	JWT0113		Jim Teague		20-Apr-1983
!		Call $getjpi to get number of open files left.
!
!	V03-016 JWT0108		Jim Teague		13-Apr-1983
!		More adjustments to new CLI interface.
!
!	V03-015	JWT0107		Jim Teague		07-Apr-1983
!		Fix problems with /MAP qualifier defaults.
!
!	V03-014 JWT0099		Jim Teague		03-Mar-1983
!		New cli interface.
!
!	V03-013 JWT0059		Jim Teague		19-Oct-1982
!		Corrected problem with basing system images explicitly.
!
!	V03-012 JWT0054 	Jim Teague		15-Sep-1982
!		INPUTFILE is now able to more intelligently specify 
!		a file to close. 
!
!	V03-011 JWT0049		Jim Teague		06-Aug-1982
!		Call LNK$CLOSEFILE to close files, rather than $CLOSE.
!
!	V03-010 JWT0044		Jim Teague		30-Jul-1982
!		Open file performance boost.
!
!	V03-009	BLS0166		Benn Schreiber		29-Mar-1982
!		Set SQO when opening input files
!
!--

!
!++
!
! FUNCTIONAL DESCRIPTION:
!
!  This module contains all the routines and data structures to process the 
!  input command parameters and options.  There is a global routine:
!
!	LNK$GETCMD (arglist)
!
!  Where arglist is the address of the original argument list with which the 
!  linker was called.  This argument list is used to perform calls back to 
!  the CLI for result parsing.
!
!  This module also contains parameter request blocks which are passed with 
!  each call to the CLI, as well as parameter qualifier description blocks and
!  a set of action routines which are called by the CLI on the appropriate 
!  conditions.
!
!  A global routine  LNK$ALLOFDB  is also included in this module to allocate 
!  and initialize file descriptors and resultant file name string areas.  It is
!  described in detail below.
!
!--

forward routine
	lnk$srcpscdef,				! Look for psectname in psect def by opt list
	lnk$collectpsct	: novalue,		! Perform PSECT collection/definition
	setuserlib,				! Selectively set logical name tables to search
	clierror 	: novalue,		! called for all cli errors
	call_tparse,				! Call tparse to parse a value
	lnk$allocluster : novalue,		! Allocate a cluster descriptor
	lnk$allofdb 	: novalue,		! Allocate file descriptors and resultant string areas
	outputfile 	: novalue,		! Called for all output files
	inputfile 	: novalue,		! Called for each input file
	specialimage 	: novalue,		! Called for system and shareable images
	lnk$setlibrin 	: novalue,		! Called for library files
	lnk$insert_clu,				! Insert cluster into cluster tree
	optionfile 	: novalue,		! 
	get_image 	: novalue,		! Process image qualifiers
	get_map 	: novalue,		! Process map qualifiers
	get_sym		: novalue,		! Process /SYM
	get_input,				! Process input file name
	setup_inrelnam ;			! Setup related name for output files
!
lIBRARY
	'STARLETL32' ;				! System structure def'ns
require
	'PREFIX' ;				! Utility macros etc.
library
	'DATBAS' ;				! Internal data base definitions
library
	'CLIMACL32' ;				! Command language structures
library
	'TPAMACL32' ;				! Tparse macros
!
! Set up string descriptors for qualifers
!
    sd  ('BRIEF',	'CONTIGUOUS', 	'CROSS_REFERENCE',	'DEBUG',	'EXECUTABLE'
	,'FULL',	'HEADER',	'MAP',			'P0IMAGE',	'PROTECT'
	,'SHAREABLE',	'SYMBOL_TABLE',	'SYSLIB',		'SYSSHR',	'SYSTEM'
	,'TRACE',	'USERLIBRARY',	'INCLUDE',		'LIBRARY',	'OPTIONS'
	,'SELECTIVE_SEARCH',		'P1'
	) ;	

macro	copy_desc (src, dst) =
		begin
		dst [dsc$w_length]  = .src [dsc$w_length] ;
		dst [dsc$b_class]   = .src [dsc$b_class] ;
		dst [dsc$b_dtype]   = .src [dsc$b_dtype] ;
		dst [dsc$a_pointer] = .src [dsc$a_pointer] ;
		end 
	% ;
	
external literal
	cli$_negated,				! Qualifier explicitly negated
	cli$_locneg,				! Qualifier was locally negated
	cli$_defaulted,				! Qualifier was defaulted
	cli$_locpres,				! Qualifier was locally present
	cli$_present,				! Qualifier was present
	lin$_univstar,				! UNIVERSAL=* ignored unless /NOEXE
	lin$_closein,				! Close error
	lin$_cmdsyntax,				! Command syntax error
	lin$_firstmod,				! First module requires extraction since library
	lin$_illqualval,			! Illegal qualifier value
	lin$_linerr,				! Display segment in error
	lin$_nomods,				! No input modules specified
	lin$_openin,				! Error opening input file
	lin$_tracign ;				! Traceback supression overridden

external routine
	str$copy_r,
	lib$cvt_otb,
	lib$cvt_dtb,
	lib$cvt_htb,
	cli$present,
	cli$get_value,
	lib$find_file,				! Search list compatible related name processing
	lib$find_file_end,			! Cleanup after LIB$FIND_FILE
	lib$insert_tree, 			! Insert into balanced binary tree
	lib$lookup_tree, 			! Lookup entry in balanced binary tree
	lib$tparse,				! Table driven parser
	lnk$fndpscnam,				! Lookup/enter psect names
	lnk$alloblk 	: novalue, 		! Allocate dynamic memory
	lnk$dealblk 	: novalue, 		! Deallocate dynamic memory
	lnk$procoptns,				! Option file processor
	lnk$filnamdsc,				! Return string descriptor for file name
	lnk$insudfsym,				! Insert symbol descriptor in undefined symbol list
	lnk$insert,				! Symbol table insert routine
	lnk$closefile,				! Routine to close a file
	lnk$openlib,				! Routine to open a library
	lnk$search ;				! Symbol table search routine
!
external
	lnk$gl_inclst	: ref block [,byte],	! Include list descriptor
	lnk$gw_stack 	: word,			! Stack size
	lnk$gl_curfil 	: ref block [,byte],
	lnk$gl_ctlmsk 	: block [,byte],	! Control flags
	lnk$gl_lastclu 	: ref block [,byte],	! Pointer to last cluster in list
	lnk$gl_clulst 	: vector [2],		! Cluster descriptor listhead
	lnk$gl_defclu 	: block [,byte],	! Default cluster descriptor
	lnk$gl_curclu 	: ref block [,byte],	! Current cluster descriptor
	lnk$gl_clutree 	: ref block [,byte],	! Listhead for cluster tree
	lnk$gl_fvmlst 	: ref block [,byte],	! Free virtual memory listhead
	lnk$gl_imgfil 	: ref block [,byte],	! Pointer to image file descriptor slot
	lnk$gl_mapfil 	: ref block [,byte],	! Pointer to the map file descriptor
	lnk$gw_nclusters : word,		! Number of clusters allocated
	lnk$gw_nsymbols	: word,			! Number of symbols	
	lnk$gl_symfil 	: ref block [,byte],	! Pointer to symbol table output file
	lnk$gl_cclulst,				! List head (singly linked)
						! For clusters in collect option
	lnk$gl_pscdflst ;			! Singly linked listhead
						! For psects defined with psect option
!
Bind	firstcluster = lnk$gl_clulst [0]   : ref block [,byte],	! Pointer to first
	null_device  = $descriptor ('NL:') : block [,byte]  ;	! Null device for /NOEXE
!
global
	lnk$gl_filesleft,			! Number of files left to open
	lnk$gl_ulibmask,			! Mask of enabled name tables to search
	lnk$gl_inrelnam,			! Address of nam block of first input file
	lnk$gl_relnam_exe,			! Address of related nam block for .EXE
	lnk$gl_relnam_map,			! Address of related nam block for .MAP
	lnk$gl_relnam_sym,			! Address of related nam block for .STB
	lnk$gb_locnov_exe	: byte,		! Set if /EXE used locally with no specified value
	lnk$gb_locnov_map	: byte,		! Set if /MAP used locally with no specified value
	lnk$gb_locnov_sym	: byte,		! Set if /SYM used locally with no specified value
	lnk_gb_getcmd_sp1	: byte,		! Spare, used for alignment
	lnk$gl_sysinput_flag,			! Set when option file is sys$input
	lnk$gl_cliwork ;			! Pointer to work area for cli
!
global bind
	lnk$gt_jpilst 	= $itmlst_uplit ((itmcod = jpi$_filcnt, bufadr = lnk$gl_filesleft)),

	lnk$gt_imgsta	= cstring ('SYS$IMGSTA'),		! Name of debugger activator 
	libfiltype 	= uplit (byte ('.OLB')),		! Library file type
	defiletype 	= uplit (byte ('.OBJ')),		! Default file type
	shrfiltype 	= uplit (byte ('.EXE')) ;		! Shr img file type

map
	lnk$gl_ulibmask : bitvector [] ;			! Pretend its a bitvector
!
! OWN STORAGE
!
!
literal
	imgtabsiz	= 7,
	system_region	= %x'80000000',
	rsa_allosize	= nam$c_maxrss*3/2,			! Rsa allocation quantity
	typelen 	= 4 ;					! Length of file type string
!
own
	univstar_valid	: initial (false),			! UNIV=* valid only with /NOEXE
	local_qualifier	: initial (false),			! Set to TRUE when /MAP, /EXE, and
								! /SYM are parsed as local qualifiers
	listptr,						! Dynamic include list ptr
	dflt_name	: vector [nam$c_maxrss, byte],		! Default input related name text
	dflt_inrel	: block [nam$c_bln, byte],		! Default input related name nam$
	last_fnm_desc	: ref block [,byte] initial (0),	! Last input file descriptor
	rlf_context	: ref block [,byte] initial (0),	! Related filename context
	an_open_fdb	: initial (0),
	debug_desc	: dynamic_descriptor,
	module_desc	: dynamic_descriptor,
	share_desc	: dynamic_descriptor,			! /SHAREABLE descriptor name
	token_desc	: dynamic_descriptor,			! Dynamic desc for general usage
	systembase,						! Base specified in /SYSTEM=NUMBER
	basedflag,						! Set true if /SYSTEM=NUMBER
	outfile,						! Ptr to ptr for the current output file
	nextrsa,						! Ptr to slot for next resultant string on open
	typeadr 	: initial (ch$ptr (defiletype)),	! Address of the file type string
	infilflgs,						! Flags of each input file
	tpdata,							! Data from tparse
	rsaremsize 	: byte,					! Size remaining in rsa
	image_qual_table : vector  [ imgtabsiz, long ] 
			   initial
				(sd_trace,  sd_contiguous, sd_p0image, sd_protect
				,sd_syslib, sd_sysshr,     sd_header
				),
	bit_table 	: vector  [imgtabsiz, byte] 
			  initial
				(byte	($bitposition (lnk$v_trace),   $bitposition (lnk$v_contig)
				 	,$bitposition (lnk$v_p0image), $bitposition (lnk$v_protect)
				 	,$bitposition (lnk$v_syslib),  $bitposition (lnk$v_sysshr)
				 	,$bitposition (lnk$v_sysheadr)
				 )	) ;
  
!
! Tparse tables to parse /userlib qualifier values
!
$init_state (userlib_states,userlib_keys)  ;

$state (,	('SYSTEM', tpa$_exit,,1,lnk$gl_ulibmask),
		('GROUP',  tpa$_exit,,2,lnk$gl_ulibmask),
		('PROCESS',tpa$_exit,,4,lnk$gl_ulibmask),
		('ALL',    tpa$_exit,,7,lnk$gl_ulibmask),
		('NONE',   tpa$_exit,,%x'80000000',lnk$gl_ulibmask)
	) ;


global routine lnk$getcmd (arglist) : novalue =

!+
!
!  This routine initializes the CLI result parser then re-calls it for 
!  processing of each command parameter.  It first calls for the primary output
!  parameter (the image), then the secondary output parameter (the map), 
!  followed by the third output parameter (the symbol table file).  Next it 
!  loops, calling for input parameters (primary only) until there are no more.
!  the actions taken on presence or absence of any parameter and its qualifiers 
!  are taken in the other routines (below) which are called by CLI on the 
!  appropriate condition.
!
!
!  ARGLIST is the address of the argument list with which the linker was 
!	   originally called.
!
!-
begin
map
	arglist : ref block [,byte] ;				! Really a vector of longwords

lnk$gl_ctlmsk [lnk$v_verify] = .arglist [cli$v_verify] ;	! Copy verify context of process

rsaremsize  = rsa_allosize*3 ;					! Set up the resultant string area
lnk$alloblk (.rsaremsize,nextrsa) ;				! For the file opens (triple size at first)

!
!
!    Loop through qualifiers that do nothing but set a bit in  LNK$GL_CTLMSK...
!
!
incr i  to imgtabsiz - 1  
do   lnk$gl_ctlmsk [0,.bit_table [.i],1,0] = cli$present (.image_qual_table [.i]) ;

if   cli$present (sd_userlibrary)				! /USERLIBRARY
then setuserlib () ;

if  cli$present (sd_system)					! /SYSTEM
then begin
     lnk$gl_ctlmsk [lnk$v_sys]   = true ;			! Set/clear bits
     lnk$gl_ctlmsk [lnk$v_trace] = false ;			!  and call 
     lnk$gl_ctlmsk [lnk$v_exe]   = false ;			!  specialimage
     specialimage () ;
     end
else if   cli$present (sd_shareable)				! /SHAREABLE
     then begin
	  lnk$gl_ctlmsk [lnk$v_shr]   = true ;			! Set/clear bits
	  lnk$gl_ctlmsk [lnk$v_trace] = false ;			!  and call
	  lnk$gl_ctlmsk [lnk$v_exe]   = false ;			!  specialimage
	  specialimage () ;
	  end ;

if   cli$present (sd_debug)					! If /DEBUG present,
then begin							!   then attempt to grab a value for 
     cli$get_value (sd_debug, debug_desc) ;			!   the qualifier  (no value is ok)
     lnk$gl_ctlmsk [lnk$v_dbg] = true ;
     end ;

get_image () ;							! Go get image file name
get_map   () ;							! Go get map file name and qualifiers
get_sym   () ;							! Get symbol table file name

local_qualifier = true ;					! /MAP/EXE/SYM are now local qualifiers
while get_input () 						! Loop while more input files...
do  begin
    get_image () ;
    get_map   () ;
    get_sym   () ;
    end ;


lib$find_file_end (rlf_context) ;				! Cleanup after input processing

lnk$gl_ctlmsk [lnk$v_image] =	.lnk$gl_ctlmsk [lnk$v_sys]  or
				.lnk$gl_ctlmsk [lnk$v_shr]  or
				.lnk$gl_ctlmsk [lnk$v_exe] ;
!
!
!    If a MAP was requested, process MAP qualifiers.  This could be done 
!    sooner since /MAP is positional and the other map qualifiers are
!    global.
!
!
if  .lnk$gl_ctlmsk [lnk$v_map]
then begin
     if   cli$present (sd_full)		 			! Process map qualifiers
     then begin
	  lnk$gl_ctlmsk [lnk$v_long]   = true ;
	  lnk$gl_ctlmsk [lnk$v_supsys] = false ;
	  end ;

    if   cli$present (sd_brief)
    then lnk$gl_ctlmsk [lnk$v_brief] = true ;

    if   cli$present (sd_cross_reference)
    then lnk$gl_ctlmsk [lnk$v_cros] = true ;
    end ;

!
!
!    If /SYSTEM=number, then set the base now
!
!
if .basedflag
then 
    begin
    if  .lnk$gl_ctlmsk [lnk$v_sysheadr]
    then lnk$gl_defclu [clu$l_base] =  (.systembase + 511) and not 511	! Only round if /SYSTEM/HEADER
    else lnk$gl_defclu [clu$l_base] =   .systembase ;

    if		.lnk$gl_defclu [clu$l_base] gequ control_region		! Set correct allocation limits
    then if 	.lnk$gl_defclu [clu$l_base] gequ system_region
	then	 lnk$gl_fvmlst [fvm$l_address] = system_region
	else	 lnk$gl_fvmlst [fvm$l_address] = control_region
    else 	 lnk$gl_fvmlst [fvm$l_address] = 0 ;
    end ;
!
!
!    Check that there was at least one input module
!
!
If .firstcluster eql 0						! if no clusters allocated
    and 
   .lnk$gl_defclu [clu$l_fstfdb] eql 0				! And no files in default cluster
then 
    signal_stop (lin$_nomods) ;					! There were no input modules - fatal error

!
!
!    Now link the debugger into the input file list if DEBUG and/or TRACEBACK 
!    was requested.
!
!    However suppress it if this is a system image
!
!
if  .lnk$gl_ctlmsk [lnk$v_sys] or .lnk$gl_ctlmsk [lnk$v_shr]
then lnk$gl_ctlmsk [lnk$v_trace] = false ;

if .lnk$gl_ctlmsk [lnk$v_dbg] or .lnk$gl_ctlmsk [lnk$v_trace]	! If /DEBUG specified or /TRACE was 
then 								! present or implied
    begin
    if   not .lnk$gl_ctlmsk [lnk$v_trace]			! If only dbg then
    then signal (lin$_tracign) ;				! Report conflict as info.

    infilflgs = fdb$m_debuger ;					! Set the file flag
    if  .debug_desc [dsc$w_length] neq 0			! If /DEBUG=FILENAME
    then begin
	 inputfile (debug_desc) ;				! Then go do it
	 lib$find_file_end (rlf_context) ;
	 end
    else begin							! Else default debugger
	 local	symnam : ref block [,byte],			! Pointer to name part of symbol block
		symval : ref block [,byte] ;			! Pointer to value part of symbol block

	 lnk$search (lnk$gt_imgsta,symval,symnam) ;		! Look up the symbol
	 lnk$insert (lnk$gt_imgsta,symval,symnam) ;		! And insert it
	 lnk$insudfsym (.symval) ;				! Insert symbol in undefined list
	 lnk$gw_nsymbols = .lnk$gw_nsymbols + 1 ;		! Count the symbol
	 end ;
     end ;

lnk$gl_ctlmsk [lnk$v_verify] = false ;				! Turn off verify status

lnk$collectpsct () ;						! Perform psect collection and definition

if  .lnk$gl_defclu [clu$l_fstfdb] neq 0				! If default cluster has some files
then begin
     lnk$gl_lastclu [clu$l_nxtclu]      =  lnk$gl_defclu ;	! Link it on to end of
     if  (lnk$gl_defclu [clu$l_prevclu] = .lnk$gl_lastclu) eql 0! Cluster list
     then lnk$gl_defclu [clu$l_prevclu] =  lnk$gl_clulst ;
     lnk$gl_lastclu 		       =   lnk$gl_defclu ;	! And make it the last cluster then
     end ;

if  .lnk$gl_ctlmsk [lnk$v_alluniv]				! if univ=* requested, allow it only
then if not .univstar_valid					!   if /NOEXE specified for .STB
     then begin							!   generation
	  signal (lin$_univstar) ;
	  lnk$gl_ctlmsk [lnk$v_alluniv] = false ;		! otherwise disable it 
	  end ;
return ;
end ;


routine clierror (desc,errorcode) : novalue =

!+
!
!  This routine is called by result parser if it detects any error in this 
!  command. reqestdesc is the address of the current parameter descriptor and 
!  errorcode is the encoded reason for the error.
!
!-
begin
map
	desc : ref block [,byte] ;				! Pointer to a block

signal_stop (lin$_cmdsyntax, 0,lin$_linerr, 1,desc [dsc$w_length], .errorcode) ;

end ;


routine call_tparse (string,states,keys) =

!-
!
!  This routine calls TPARSE given the string, states and keys
!
!  Inputs:
!
!	STRING		address of string descriptor for string to parse
!	STATES		address of tparse states table
!	KEYS		address of tparse keys table
!
!-
begin
map
	string	: ref block [,byte] ;
local
	status,
	tpablock : block [tpa$k_length0,byte] ;

!
!  Initialize the tparse block
!
ch$fill (0, tpa$k_length0, tpablock) ;

tpablock [tpa$l_count]     =  tpa$k_count0 ;
tpablock [tpa$l_options]   =  tpa$m_abbrev ;
tpablock [tpa$l_stringcnt] = .string [dsc$w_length] ;
tpablock [tpa$l_stringptr] = .string [dsc$a_pointer] ;

!
! Initialize own storage used
!
tpdata = 0 ;

return lib$tparse (tpablock, .states, .keys)
end ;


routine specialimage : novalue =

!+
!
!  This routine is called by the CLI if the system or shareable image qualifier
!  is seen on the primary output parameter.
!
!  If a value is present on the qualifier, the CLI is re-called through CLIADDR 
!  to convert the value which then sets the base address of the default cluster
!  of the image being linked.  If no value is present the base address is set 
!  to the lower end of system or process space.  In both cases the stack size is
!  set to zero.  A system image will not but a shareable image will have a 
!  header.
!
!-
begin
local	
	symbolstring	: vector [sym$c_maxlng+1, byte],	! Base address symbol storeage
	nament		: ref block [,byte],			! Pointer to symbol name block
	symtabent	: ref block [,byte] ;			! Pointer to table entry for it


lnk$gw_stack = 0 ;						! Init stack

if .lnk$gl_ctlmsk [lnk$v_shr] 			  		! If a shareable image
then
    begin
    cli$get_value (sd_shareable, share_desc) ;			!   then get name now
    return ;							! All done with /SHAREABLE...
    end ;

if  .lnk$gl_ctlmsk [lnk$v_sys]					! If a system image
then lnk$gl_fvmlst [fvm$l_address] = system_space ;		! Set first available virtual memory

if not cli$get_value (sd_system, token_desc)			! If there was no qualifier value
then return ;							! Then all done

lnk$gl_defclu [clu$v_based]  = true ;				! Set the bit for fixed in address space
lnk$gl_ctlmsk [lnk$v_picimg] = false ;				! And image is not pic
basedflag 		     = true ;

if .(.token_desc [dsc$a_pointer])<0,8>  eql  %c'%'		! If value for the base was prefixed with
then								!   a %, then we definitely have a numeric
    begin							!   base -- find out the radix
    local	status ;

    selectone .(.token_desc [dsc$a_pointer]+1)<0,8> of		! Base specified as %?
	set
	 [%c'X'] : status = lib$cvt_htb (.token_desc [dsc$w_length] - 2		! Value is in hex
					,.token_desc [dsc$a_pointer] + 2
					, systembase 
					) ;
	 [%c'D'] : status = lib$cvt_dtb (.token_desc [dsc$w_length] - 2		! Value is in decimal
					,.token_desc [dsc$a_pointer] + 2
					, systembase
					) ;
	 [%c'O'] : status = lib$cvt_otb (.token_desc [dsc$w_length] - 2		! Value is in octal
					,.token_desc [dsc$a_pointer] + 2
					, systembase 
					) ;
	 [otherwise] : clierror (token_desc, lin$_illqualval) ;		! Anything else is illegal
	tes ;

    if   not .status						! If error occurred in value conversion,
    then clierror (token_desc, .status) ;			!  report it here
    end
else
    !
    !   Didn't explicitly specify a radix -- assume decimal
    !
    if not lib$cvt_dtb (.token_desc [dsc$w_length], .token_desc [dsc$a_pointer], systembase)
    then			
	begin							 ! However... if puked on conversion	,
	if (symbolstring [0] = minu (.token_desc [dsc$w_length]  !   attempt, then we must assume
				    ,sym$c_maxlng		 !   a symbolic base value
				    )
	    ) eql 0
	then 
	    return ;

	ch$move (.symbolstring [0]
		,.token_desc [dsc$a_pointer]			! Otherwise build a counted
		, symbolstring [1]				! Ascii string that long
	 	) ;
	lnk$search (symbolstring [0], symtabent, nament) ; 	! Then search for place to insert it
	lnk$insert (symbolstring [0], symtabent, nament) ;	! and do it
	lnk$insudfsym (.symtabent) ;				! Insert undefined symbol
	lnk$gw_nsymbols 	     = .lnk$gw_nsymbols + 1 ;	! Count as one more symbol
	lnk$gl_defclu [clu$l_base]   = .symtabent ;		! Save the symbol table adress
	lnk$gl_defclu [clu$v_symbas] = true ;			! Flag as symbolic
	end ;							! And all done till it is defined
return true
end ;


global routine lnk$setlibrin  (option_flag)  : novalue =

!+
!
!  This routine is called by the CLI if the LIBRARY input file qualifier is 
!  seen on an input parameter.
!
!-
begin
builtin 
	nullparameter ;
local
	called_by_option ;

called_by_option = not nullparameter (1) ;			! It is important to know
								!   whether or not we were called
if    not  .called_by_option					!   by lnk$procoptns in order to
then  if   cli$present (sd_include)				!   know who should do the
      then infilflgs = .infilflgs or fdb$m_libextr ;		!   parsing -- the cli or me

if	  .lnk$gl_clulst [0] eql 0				! If no preceding clusters
     and  .lnk$gl_curclu [clu$l_fstfdb] eql 0			! And no files in current cluster
     and (.infilflgs and fdb$m_libextr) eql 0			! And not explicit inclusion from the
then 
     signal_stop (lin$_firstmod) ;				! File give up with an error

typeadr = ch$ptr (libfiltype) ;					! Set address of default file type
return ;
end ;


routine optionfile  : novalue =

!+
!
!  Set the default file type for link time options
!
!-
begin
bind	optfiltype = uplit (byte ('.OPT')) ;

typeadr = ch$ptr (optfiltype) ;
return ;
end ;


global routine lnk$setshrblin  : novalue =

!+
!
!  Set the default file type for shareable images.
!
!-
begin
typeadr = ch$ptr (shrfiltype) ;				! Set default file type pointer

return ;
end ;


routine setuserlib  =

!+
!
!  This routine is called by the CLI for the /USERLIBRARY qualifier.
!  The default is /USERLIBRARY= (PROCESS, GROUP, SYSTEM).  If there
!  is a list of logical name tables, only those tables specified will
!  be searched.
!
!-
begin

lnk$gl_ctlmsk [lnk$v_usrlib] = true ;
while cli$get_value (sd_userlibrary, token_desc) 		! Loop for all specified
do  begin
    if .token_desc [dsc$w_length] neq 0				! If a string was there
    then
	if not call_tparse (token_desc [dsc$w_length], userlib_states, userlib_keys)
	then 
	    clierror (.token_desc, lin$_illqualval) ;		! No return from this
    end ;

if  .lnk$gl_ulibmask eql 0					! If nothing found
then lnk$gl_ulibmask = 7					! Then enable all logical name tables
else if  .lnk$gl_ulibmask lss 0					!  will be lss 0 if /USERLIB=NONE
     then lnk$gl_ulibmask = 0 ;

return true ;							!
end ;								! of setuserlib


global routine inputfile  (desc, option_flag) : novalue =

!+
!
!  This routine is called by the CLI for each file in the command input 
!  parameter list.
!
!  The routine allocates an internal file descriptor block and then, using the 
!  input file fab allocated in the command processing driver rouine attempts 
!  to open the specified file.
!
!  If this is successful, the auxiliary filename block part of our FDB is 
!  initialized by RMS.  Other useful fields of the FDB  (such as the file flags)
!  are initialized and then the FDB is added to the FDB list.  The file is then
!  closed, so that an open by file id may be performed 	on the file hereafter.
!
!  Failure to open the file at this point is fatal and 	the link aborts.
!
!
!	REQSTDESC 	is the address of the input parameter descriptor being 
!			used by the CLI.
!
!	INFILFLGS 	contains the settings of the input file control flags 
!			as determined by the CLI and qualifiers used.
!
!-
begin
    routine get_module  ( module_dsc ) =
    !
    !  This routine plucks the modules out of the include list passed here from
    !  LNK$PROCOPTNS and returns the individual module name descriptors to 
    !  inputfile
    !
    begin
    local	length,
		address,
		remaining_length ;

    map 	module_dsc   : ref block [,byte] ;

    bind	include_list = .lnk$gl_inclst :  block [,byte] ; 	! Here is the list...

    if .listptr lss .include_list [dsc$a_pointer] 		! If failure to find a module 
    then							!    zeroed the pointer, then
	return false ;						!    quit here

    address = .listptr ;					! Current module is already pointed to
    if ch$fail (listptr = ch$find_ch 				! If we fail to find a delimiter
				(remaining_length = 
					(.include_list [dsc$w_length] - 
					 (.listptr - .include_list [dsc$a_pointer])
				        ),
				 .listptr
				, ','
		)		)
    then length = .remaining_length				!  then the length is what was left
    else length = .listptr - .address  ;			!  otherwise the length is the difference 
								!    in the pointers
    if  .length lss 0						! Make sure module name length was > 0
    then length = 0 ;

    listptr = .listptr + 1 ;					! Move ptr 1 char past delimiter 
								! (tparse cleans out blanks and tabs)
    str$copy_r ( .module_dsc, length, .address) ; 		! Do this because inputfile expects a 
								! dynamic descriptor
    return true ;
    end ;


bind 
	sysinput_desc	= $descriptor ('SYS$INPUT') : $bblock,
	include_list	= .lnk$gl_inclst 	    :  block [,byte] ;
literal
	maxoptreclen 	= 132 ;					! Maximum length of option file records
map
	desc 		: ref block [,byte] ;			! Really a pointer
builtin
	nullparameter ;
local
	dnm_desc	: block [8, byte],			! Default filename descriptor
	enm_desc	: block [8, byte],			! LIB$FIND_FILE expanded file name
	fnm_desc 	: ref block [,byte],			! File name descriptor in fdb
	fildesblk	: ref block [,byte],			! Pointer to fdb
	auxfnb		: ref block [,byte],			! Auxiliary file name block pointer
	input_fab 	: block [fab$c_bln, byte],		! Fab for the file opens.
	optionrab 	: block [rab$c_bln, byte],		! Rab for option file input stream
	stvcode,						! Stv value for error output
	errorcode,						! Rms error code
	called_by_option ;					! Set if called by lnk$_procoptions

called_by_option = not nullparameter (2) ;

!
!
!    Allocate an FDB
!
!
lnk$allofdb  ( fildesblk ) ;					! Go allocate new file descriptor
auxfnb       = fildesblk [fdb$t_auxfnb] ;			! Point to filename block part
fnm_desc     = fildesblk [fdb$q_filename] ;			! Point to file name descriptor
copy_desc    (desc, fnm_desc) ;  				! Copy initial file name descriptor

fildesblk [fdb$b_filflgs] = .infilflgs and not fdb$m_newudf ;	! Copy the flags turning off bit 0

!
!
!    If this is a library witih explicit module extraction, build the FDB's module list.
!    Call  CLI$GET_VALUE or GET_MODULE, based on whether or not the file is in an options file.
!
!
if  (.infilflgs and fdb$m_libextr) neq 0			! If explicit module extraction
then 
    begin
    local	prevmodule : initial (0) ;			! Pointer to previous module name block

    if .called_by_option					! If called by LNK$PROCOPTNS, we must 
    then listptr = .include_list [dsc$a_pointer] ;		! set up listptr

    while  (if not .called_by_option  then cli$get_value (sd_include,module_desc) 
				      else get_module (module_desc) 
	    )  
    do	begin
	local	currentmodule	: ref block [,byte] ;		    !  Ptr to current module name block

	lnk$alloblk (.module_desc [dsc$w_length]+5,currentmodule) ; !  Allocate space to save name
	if .prevmodule eql 0					    ! If this is the first module,
	then  fildesblk [fdb$l_omdlst] = currentmodule [0,0,0,0]    ! then set the pointer in the fdb
	else .prevmodule               = currentmodule [0,0,0,0] ;  ! Otherwise, point prev to current

	prevmodule		       = currentmodule [0,0,0,0] ;  ! Reset for next pass
	currentmodule [0,0,32,0]       = 0 ;			    ! Zero forward pointer
	currentmodule [4,0, 8,0]       = .module_desc [dsc$w_length] ; ! Move in module length and name

	ch$move (.module_desc [dsc$w_length], .module_desc [dsc$a_pointer], currentmodule [5,0,8,0]) ;
	end ;
    end ;


!
!    Setup up buffer descriptors and call LIB$FIND_FILE to setup an expanded filename 
!    consistent with the stickiness rules for related file names and search lists.
!
!
infilflgs = 0 ;							! Reset file flags

dnm_desc [dsc$w_length]  =  typelen ;				! Setup default filename descriptor
dnm_desc [dsc$b_class]   =  dsc$k_class_z ;			! for call to LIB$FIND_FILE
dnm_desc [dsc$b_dtype]   =  dsc$k_dtype_z ;
dnm_desc [dsc$a_pointer] = .typeadr ;	

enm_desc [dsc$w_length]  =  0 ;					! Init result filename descriptor
enm_desc [dsc$b_class]   =  dsc$k_class_d ;			! for call to LIB$FIND_FILE
enm_desc [dsc$b_dtype]   =  dsc$k_dtype_t ;
enm_desc [dsc$a_pointer] =  0 ;

errorcode = lib$find_file (.desc, enm_desc 			! Determine resultant name
			  , rlf_context, dnm_desc
			  , 0, stvcode, %ref(3)
!			  , 0, input_fab [fab$l_stv], %ref(3)
			  ) ;
if .rlf_context neq 0
then
    begin
    local	rss	: initial (.auxfnb [nam$b_rss]),	! Original NAM$B_RSS
		rsa	: initial (.auxfnb [nam$l_rsa]),	! Original NAM$L_RSA
		ess	: initial (.auxfnb [nam$b_ess]),	! Original NAM$B_ESS
		esa	: initial (.auxfnb [nam$l_esa]) ;	! Original NAM$L_ESS

    ch$move (nam$c_bln, .rlf_context [fab$l_nam], .auxfnb) ;		  ! Copy NAM block
    ch$move (.enm_desc [dsc$w_length], .enm_desc [dsc$a_pointer], .esa) ; ! Copy the name

    auxfnb [nam$l_wcc] =  0 ;					! Init ptr's we won't use
    auxfnb [nam$l_rlf] =  0 ;
    auxfnb [nam$l_rsa] = .rsa ;					! Re-setup resultant name area
    auxfnb [nam$b_rss] = .rss ;
    auxfnb [nam$b_rsl] =  0 ;
    auxfnb [nam$l_esa] = .esa ;					! Re-setup expanded name area
    auxfnb [nam$b_ess] = .ess ;
    auxfnb [nam$b_esl] = .enm_desc [dsc$w_length] ;

    fildesblk [fdb$w_usrnamlen]	= .auxfnb [nam$b_esl] ;		! Copy the user's filename
    fildesblk [fdb$l_usrnamadr]	= .esa ;			! Into the fdb also
    copy_desc (enm_desc, fnm_desc) ;				! Get a better file name descriptor
								! for error message reporting
    $fab_init	(fab =  input_fab				! Intialize the fab 
		,fac =  get					! For input
		,fop =  sqo
		,dna = .typeadr
		,dns =  typelen
		,fna = .esa
		,fns = .auxfnb [nam$b_esl]
		,nam = .auxfnb
		,shr = (upi,get,put)
		) ;
    input_fab [fab$l_stv] = .stvcode ;				! Restore LIB$FIND_FILE stv value
    end ;

!
!
!    If the parse/setup was successful, open the file to obtain the resultant filename, 
!    the file i.d., etc.
!
!
if .errorcode 
then begin
     if .fildesblk [fdb$v_libr]					! Library file
     then begin							! Library open by name block
	  auxfnb [nam$b_rsl] = .auxfnb [nam$b_esl] ;		! Setup resultant name for map
	  auxfnb [nam$b_rss] = .auxfnb [nam$b_ess] ;		!  contents
	  auxfnb [nam$l_rsa] = .auxfnb [nam$l_esa] ;
	  lnk$gl_curfil = .fildesblk ;				! Set ptr to current fdb for the temporary 
	  errorcode     = lnk$openlib (.auxfnb, .an_open_fdb) ; ! benefit of LNK$OPENLIB
	  lnk$gl_curfil = 0 ;					! Must now clear it -- causes problems 
	  end							! later if non-zero
     else begin							! Not a library file
	  $getjpi (itmlst = lnk$gt_jpilst) ;			! Close a file if we're near the limit
	  if	.lnk$gl_filesleft leq 3
	  then	if    .an_open_fdb neq 0
		then   lnk$closefile (.an_open_fdb) ;

	  if .fildesblk [fdb$v_shr]				! If shareable image, gotta do:
	  then begin
	       input_fab [fab$v_sqo]    = false ;		! Not sequential only
	       input_fab [fab$v_bro]    = true ;		! Record and block operations
	       input_fab [fab$v_upi]    = true ;		! Shared access
	       input_fab [fab$v_shrget] = true ;		! Set for shared gets
	       input_fab [fab$v_shrput] = true ;		!  and puts  (linker doesn't write to 
	       end ;						!  it, but must set so we can read it 
								!  in case installed /write)
	  errorcode 	        = $open (fab=input_fab) ;	! Do regular $open
	  fildesblk [fdb$w_ifi] = .input_fab [fab$w_ifi] ;	! Remember IFI
	  end ;
     ch$move (dsc$c_s_bln, lnk$filnamdsc (input_fab), .fnm_desc) ; ! Copy better file name descriptor
     end ;
!
!
!    If ERRORCODE has its low bit set at this point then the 
!    file open was successful.
!
!
if not .errorcode 						! If either of the opens was a failure,
then stvcode = .input_fab [fab$l_stv]				! Then save status and flag 
else begin							! Setup input related name for output
     if  .lnk$gl_inrelnam eql 0					! files if not done yet
     then if setup_inrelnam (1,.fnm_desc, dflt_inrel, dflt_name)
	  then lnk$gl_inrelnam = dflt_inrel ;

     if  not .called_by_option
     then last_fnm_desc = .fnm_desc ;

     if  not .fildesblk [fdb$v_option]
     then begin
	  !
	  !
	  !    Not an OPTIONS file.  Simply stick the FDB at the end
	  !    of the current cluster FDB list.
	  !
	  ! 
	  local	lastfdb : ref block [,byte] initial (.lnk$gl_curclu [clu$l_lstfdb]) ;

	  lastfdb [fdb$l_nxtfdb]	= .fildesblk ;		! Put FDB at end of current cluster
	  lnk$gl_curclu [clu$l_lstfdb]	= .fildesblk ; 		! Remember end of list.
	  end
     else begin
	  !
	  !
	  !    OPTIONS file.  Connect to it and process the records inside it.  
	  !    The entire contents of the OPTIONS file begins a new context for 
	  !    related  filename processing - begining with 'SYS$DISK:[]'.
	  !
	  !
	  bind	namdvi = auxfnb [nam$t_dvi] : vector  [,byte] ;	! Addr of nam block dvi

	  lnk$gl_sysinput_flag = 				! Setup "sysinput" flag
	    begin
	    if  .bblock  [input_fab [fab$l_dev], dev$v_trm]	! Is device a terminal?
	    or (.auxfnb [nam$v_ppf]				! A process permanent file?
		  and 
		 ch$eql (.sysinput_desc [dsc$w_length]		! SYS$INPUT ?
			,.sysinput_desc [dsc$a_pointer]
			,.namdvi [0], namdvi [1], 0 
		)	)
	    then  1
	    else  0 
	    end ;

	  $rab_init	(rab = optionrab
			,fab = input_fab
			,usz = maxoptreclen
			,rac = seq
			,rop = loc
			) ;
	  if  not (errorcode = $connect (rab=optionrab))	! Connect the options file for reading
	  then stvcode       = .optionrab [rab$l_stv] 
	  else begin						! And if connected ok
	       local  save_context : initial (.rlf_context) ;	! Save current context

	       lnk$alloblk (maxoptreclen, optionrab [rab$l_ubf]) ; ! Allocate buffer for records 
								! crossing block boundaries
	       typeadr       =  ch$ptr (defiletype) ;		! Reset the default file type
	       rlf_context   =  0 ;				! Start new related name context
	       lnk$procoptns (.fnm_desc, infilflgs, optionrab) ;! Go process it
	       rlf_context   = .save_context ;			! Restore related name context
	       lnk$gl_curclu =  lnk$gl_defclu ;			! And reset default as current
	       lnk$dealblk (maxoptreclen, .optionrab [rab$l_ubf]) ; ! And deallocate
	       end ;
	  end ;
     end ;

if not .errorcode							! Report any errors
then  signal_stop (lin$_openin, 1, .fnm_desc, .errorcode, .stvcode) ;

!
!
!    For performance reasons, only close the file if we have to -- if its an Options file
!    or a shareable image
!
!
if .fildesblk [fdb$v_option]   or  .fildesblk [fdb$v_imglib]
then lnk$closefile (.fildesblk)
else an_open_fdb  = .fildesblk ; 

typeadr = ch$ptr (defiletype) ;					! Reset the default file type
return ;
end ;


global routine lnk$allofdb (fdbpointer) : novalue =

!+
!
!  This routine allocates some more dynmaic memory for file descriptor blocks 
!  and RMS resultant strings and inserts into an auxiliary file name block the 
!  length and address for resultant and expanded strings returned on opens on 
!  any call.  
!
!  If there is not sufficient resultant string area for the maximum, more is
!  allocated.  
!
!  The routine checks rsl of the previously allocated auxiliary file name block
!  and if non zero, reduces the remaining string area by that actually used. 
!  If still zero the area is reduced by the maximum size before the decision 
!  to allocate more is made.
!
!-
begin
own
	prevfnb 	: ref block [,byte] ;			! Previous auxiliary filename block

local
	fdblock 	: ref block [,byte],			! File descriptor block allocated
	rsareduction,						!
	temprsapointer ;					! For allocating resultant
								! String buffers
map
	fdbpointer 	: ref vector ;				! Passed an address at wich to store

if .prevfnb neq 0						! If one has been allocated
then 
    begin							! Previously, try to use the actual
    if  (rsareduction = .prevfnb [nam$b_rsl]) eql 0		! Amount consumed to reduce
    then rsareduction = .prevfnb [nam$b_rss] ;			! The available area but if none

    rsaremsize = .rsaremsize - .rsareduction ;			! Consumed, reduce by the total
    nextrsa    = .nextrsa + .rsareduction ;			! And update the address of next available
    end ;

if .rsaremsize lssu nam$c_maxrss				
then 								! Not enough space in resltant string
    begin							!  buffer for maximum one
    lnk$alloblk  (rsa_allosize, temprsapointer) ;		!  Go allocate some more
    if .temprsapointer eql .nextrsa + .rsaremsize		! If it was allocated continguously
    then							!  with previous one
	rsaremsize = .rsaremsize + rsa_allosize			!  then merge
    else 
	begin							! Else, use new block and forget
	rsaremsize = rsa_allosize ;				! previous area
	nextrsa    = .temprsapointer ;
	end ;			
    end ;			

lnk$alloblk (fdb$c_size+nam$c_bln, fdblock) ;			! Allocate file descriptor
fdbpointer [0] = .fdblock ;					! Return its address
prevfnb        =  fdblock [fdb$t_auxfnb] ;			! Get address of the file name block part
ch$fill (0,fdb$c_size+nam$c_bln, .fdblock) ;			! Zero the fdb

$nam_init (nam = .prevfnb					! Initialize the nam block
	  ,rsa = .nextrsa
	  ,rss = nam$c_maxrss
	  ,esa = .nextrsa
	  ,ess = nam$c_maxrss
	  ) ;
return ;							! And that's it
end ;


global routine lnk$clunamcmp  (keyname, node) =

!+
!
!  This routine compares an ascic keyname with the current entry
!
!-
begin
map
	keyname : ref vector [,byte],
	node 	: ref block [,byte] ;
local
	clu 	: ref block [,byte] ;

clu = .node [node$l_ptr] ;					! Point to cluster descriptor
return ch$compare (.keyname [0], keyname [1]
		  ,.clu [clu$b_namlng], clu [clu$t_name]
		  )
end ;


global routine lnk$compare_pdd  (keyname,pdd) =

!+
!
!  Routine to compare ascii psect name with current entry
!
!-
begin
map
	keyname	: ref vector [,byte],
	pdd	: ref block [,byte] ;

return ch$compare (.keyname [0], keyname [1] 
		  ,(.pdd [pdd$b_namlng] and not %x'80'), pdd [pdd$t_name]
		  )
end ;


global routine lnk$alloc_pdd  (keyname,retadr) =

!+
!
!  Allocate a new pdd block
!
!-
begin
map
	keyname	: ref vector [,byte],
	retadr	: ref vector [,long] ;
local
	pdd	: ref block [,byte] ;

lnk$alloblk (pdd$c_size+.keyname [0], pdd) ;			! Allocate the pdd

ch$fill (0, pdd$c_size, .pdd) ;					! Zero it

pdd [pdd$w_flags] = psc$m_optpsc ;				! Set defined by option flag
pdd [pdd$b_align] = -1 ;					! Set no alignment specified

ch$move (.keyname [0]+1, keyname [0], pdd [pdd$b_namlng]) ;	! Insert the name

retadr [0] = .pdd ;
return true
end ;


global routine lnk$collectpsct : novalue =

!+
!
!  This routine is called at the end of command processing to process the data 
!  base set up by the PSECT definition and collection options.  A pass is made 
!  over the list of PSECTS hanging off each cluster mentioned in a collect 
!  option.  For each PSECT in that list, define it.  
!
!-
begin
local
	curcluster	: ref block [,byte],			! Pointer to current cluster descriptor
	lstcluster	: ref block [,byte],			! Pointer to last cluster descriptor
	curpsct		: ref block [,byte],			! Pointer to current psect name block
	cludesc		: ref block [,byte],			! Pointer to cluster descriptor
	psctdesc	: ref block [,byte],			! Pointer to psect descriptor
	psctdef		: ref block [,byte] ;			! Pointer to psect definition block

curcluster = .lnk$gl_cclulst ;					! Point to first cluster name block
!
!  loop through all named clusters
!
while .curcluster neq 0 do
    begin
    if not lib$lookup_tree (lnk$gl_clutree			! Lookup up cluster
			   ,curcluster [ccd$b_namlng]
			   ,lnk$clunamcmp
			   ,cludesc
			   )
    then 
	begin							! And if not defined yet
	lnk$allocluster (cludesc) ;				! Then do it now
	ch$move (.curcluster [ccd$b_namlng]+1			! Copy in the name
		, curcluster [ccd$b_namlng]
		, cludesc [clu$b_namlng]
		) ;
	lnk$insert_clu (.cludesc) ;				! Insert into cluster tree
	if .curcluster [ccd$b_protect]				! If the cluster should be protected
	then 
	    cludesc [clu$v_protect] = true ; 			! Then flag it now
	lnk$gl_curclu = .cludesc ;				! Make it the current cluster
	end
    else 
	lnk$gl_curclu  = .cludesc [node$l_ptr] ;		! Found--make it the current cluster

    curpsct     = .curcluster [ccd$l_psclst] ;			! Point to first psect block
    lstcluster  = .curcluster ;					! Remember this one
    curcluster  = .curcluster [ccd$l_nxtclu] ;			! And point to next one
    lnk$dealblk (ccd$c_size, .lstcluster) ;			! Deallocate it
    !
    !  Now get all the psects collected into that cluster
    !
    while .curpsct neq 0
    do	begin
	local	defbyopt ;

	if  not  (defbyopt = lnk$srcpscdef (curpsct [cpd$b_namlng], psctdef))
	then
	    lib$insert_tree (lnk$gl_pscdflst				! Insert into defined by option list
			    ,curpsct [cpd$b_namlng]
			    ,%ref (0)
			    ,lnk$compare_pdd
			    ,lnk$alloc_pdd,psctdef
			    ) ;
	psctdef [pdd$w_flags] = .psctdef [pdd$w_flags] or gps$m_gbl ;	! Mark psect as global
	lnk$fndpscnam	(curpsct [cpd$b_namlng]				! Enter psect in current cluster
			,.psctdef [pdd$w_flags]
			,0 
			, psctdesc
			) ; 	
	if .defbyopt							! If defined by option
	then 								! then
	    begin
	    psctdef [pdd$b_namlng] = .psctdef [pdd$b_namlng] or %x'80' ; !  flag psect already defined
	    psctdesc [psc$w_flags] = .psctdef [pdd$w_flags] ; 		!   copy the defined flags
	    psctdesc [psc$b_align] = .psctdef [pdd$b_align] ;		!   and the alignment

	    if  .psctdef [pdd$b_align] eql %x'FF' 			!  if defaulted
	    then psctdesc [psc$b_align] = 0 ;				!  then use byte alignment
	    end ;

	curpsct = .curpsct [cpd$l_nxtpsc] ;				! Point to next name block
	end								! Curpsct neq 0
    end ;								! Curcluter neq 0

return ;
end ;


global routine lnk$srcpscdef (pscnam,psctdesc) =

!+
!
!  Look up PSECT name in the psects defined by option.
!
!-
begin
map
	pscnam		: ref vector [,byte],			! Ascic name
	psctdesc	: ref block [,byte] ;			! Pointer

return lib$lookup_tree (lnk$gl_pscdflst,.pscnam,lnk$compare_pdd, .psctdesc)

end ;


global routine lnk$allocluster (clusterdesc,dummyarg) : novalue =

!+
!
!  Allocate a cluster descriptor and link on end of the list and initialize 
!  some fields of it now.
!
!  If the second argument is present, the cluster descriptor is not linked 
!  into the list.
!
!-
begin
map
	clusterdesc	: ref vector [,long] ;
local
	newcluster	: ref block [,byte] ;
builtin
	nullparameter ;

lnk$alloblk (clu$c_size,clusterdesc [0]) ;			! Allocate the block
newcluster = .clusterdesc [0] ;					! Retrieve its address
ch$fill (0,clu$c_size,.newcluster) ;				! Zero the descriptor

newcluster [clu$l_lstfdb]  = newcluster [clu$l_fstfdb] ;	! So empty list
newcluster [clu$l_lstisd]  = newcluster [clu$l_fstisd] ;	!
newcluster [clu$l_lstadrl] = newcluster [clu$l_fstadrl] ;
lnk$gw_nclusters 	   = .lnk$gw_nclusters + 1 ;		! Count the cluster

if nullparameter (2)						! If second argument not supplied
then 
    begin							!  then link into end of cluster list
    lnk$gl_lastclu [clu$l_nxtclu] = .newcluster ;		! Set pointer
    newcluster [clu$l_prevclu]    = .lnk$gl_lastclu ;
    lnk$gl_lastclu = .newcluster ;				! For last in list
    end ;
return ;
end ;


global routine lnk$insert_clu  (cludesc) =

!+
!
!  This routine is called to insert a cluster descriptor into the balanced
!  binary tree of cluster descriptors.
!
!  Inputs:
!
!	CLUDESC		address of cluster descriptor
!
!
!-
begin
	routine clunodealloc  (keyname,retadr,cludesc) =
	begin
	!
	! routine to allocate node for new cluster
	!
	map
		keyname		: ref vector [,byte],
		retadr		: ref vector [,long],
		cludesc		: ref block [,byte] ;
	local
		nodeptr		: ref block [,byte] ;
	
	lnk$alloblk (node$c_long+.keyname [0],nodeptr) ;
	nodeptr [node$l_ptr] = .cludesc ;
	retadr [0]           = .nodeptr ;
	
	return true
	end ;
!
! Main body of lnk$insert_clu
!
map
	cludesc		: ref block [,byte] ;
local
	blockaddr ;

return lib$insert_tree (lnk$gl_clutree, cludesc [clu$b_namlng], %ref (0)
		       ,lnk$clunamcmp, clunodealloc, blockaddr, .cludesc
		       )
end ;

routine get_image : novalue =

!++
!
!  This routine processes the /EXE switch and determines the name and
!  the associated related name of the .EXE file.
!
!--
begin
local
	exe_desc	: dynamic_descriptor,				! Descriptor of .EXE file
	new_file	: initial (0),					! Set if new .EXE request is made
	status ;
own
	exe_name	: vector [nam$c_maxrss, byte],			! Related file for .EXE
	exe_inrel	: block [nam$c_bln, byte] ;			! Related NAM$ for .EXE

if  (status = cli$present (sd_executable))				! /EXECUTABLE
then begin
     if  .local_qualifier
     then begin
	  if  .status neq cli$_locpres
    	  then return
	  else begin
	       setup_inrelnam (0,.last_fnm_desc, exe_inrel, exe_name) ;	! Setup related name 
	       lnk$gl_relnam_exe = exe_inrel ;				! using last input file
	       end 
	  end
     else lnk$gl_relnam_exe = dflt_inrel ;				! Use default related name

     new_file	       = true ;						! Setup new .EXE file spec
     univstar_valid    = false ;					! Disallow UNIV=* for STB generation
     lnk$gb_locnov_exe = (if cli$get_value (sd_executable, exe_desc) 	! Get image name (no name is okay)
			  then  false					! and setup 'local no-value' flag
			  else .local_qualifier
			 ) ;
     if  .lnk$gl_ctlmsk [lnk$v_shr]			  		! If a shareable image
     then if  .exe_desc [dsc$w_length] eql 0				! and /EXE didn't specify a name
	  then copy_desc (share_desc, exe_desc) ;			! then use /SHAREABLE name
     end
else begin
     if ((not .local_qualifier) and (.status eql cli$_negated))		! But, if explicitly negated,
     or ((    .local_qualifier) and (.status eql cli$_locneg))		!
     then begin								!  disable image production
          new_file	 = true ;					! Setup new .EXE file spec
	  univstar_valid = true ;					! Will now allow UNIV=* for STB generation
	  copy_desc (null_device, exe_desc) ;
	  end ;
     end ;

if .new_file 
then begin
     outfile = lnk$gl_imgfil ;						! Point to the pointer
     outputfile (exe_desc) ;						! Set up image output file
     end ;
end ;

routine get_sym : novalue =

!++
!
!  This routine retrieves the symbol table file name and qualifiers
!
!--
begin
local
	sym_desc	: dynamic_descriptor,				! Descriptor of .SYM file
	status ;
own
	sym_name	: vector [nam$c_maxrss, byte],			! Related file for .SYM
	sym_inrel	: block [nam$c_bln, byte] ;			! Related NAM$ for .SYM

if  (status = cli$present (sd_symbol_table))				! /SYMBOL_TABLE
then begin
     if  .local_qualifier
     then begin
	  if  .status neq cli$_locpres
    	  then return
	  else begin
	       setup_inrelnam (0,.last_fnm_desc, sym_inrel, sym_name) ;	! Setup related name 
	       lnk$gl_relnam_sym = sym_inrel ;				! using last input file
	       end 
	  end
     else lnk$gl_relnam_sym  = dflt_inrel ;				! Use default related name

     lnk$gl_ctlmsk [lnk$v_symtbl] = true ;				! Ask for symbol table
     lnk$gb_locnov_sym = (if cli$get_value (sd_symbol_table, sym_desc) 	! Get .STB name (no name is okay)
			  then  false					! and setup 'local value' flag
			  else .local_qualifier
			 ) ;
     outfile   = lnk$gl_symfil ;					! Point to the pointer
     outputfile (sym_desc) ;						! And set up output file
     end
else begin
     if ((not .local_qualifier) and (.status eql cli$_negated))		! But, if explicitly negated,
     or ((    .local_qualifier) and (.status eql cli$_locneg))		!
     then lnk$gl_ctlmsk [lnk$v_symtbl] = false ;			!  disable production
     end ;
end ;


routine get_map : novalue =

!++
!
!  This routine retrieves the map file name and qualifiers
!
!--
begin
local
	map_desc	: dynamic_descriptor,				! Descriptor of .MAP file
	status ;
own
	map_name	: vector [nam$c_maxrss, byte],			! Related file for .MAP
	map_inrel	: block [nam$c_bln, byte] ;			! Related NAM$ for .MAP

if  (status = cli$present (sd_map))					! /MAP
then begin
     if  .local_qualifier
     then begin
	  if  .status neq cli$_locpres
     	  then return
	  else begin
	       setup_inrelnam (0,.last_fnm_desc, map_inrel, map_name) ;	! Setup related name 
	       lnk$gl_relnam_map = map_inrel ;				! using last input file
	       end 
	  end
     else lnk$gl_relnam_map = dflt_inrel ;				! Use default related name

     lnk$gl_ctlmsk [lnk$v_map] = true ;					! Ask for map
     lnk$gb_locnov_map = (if cli$get_value (sd_map, map_desc) 		! Get map name (no name is okay)
			  then  false					! and setup 'local value' flag
			  else .local_qualifier
			 ) ;
     outfile   = lnk$gl_mapfil ;					! Point to the pointer
     outputfile (map_desc) ;						! And set up output file
     end
else begin
     if ((not .local_qualifier) and (.status eql cli$_negated))		! But, if explicitly negated,
     or ((    .local_qualifier) and (.status eql cli$_locneg))		!
     then lnk$gl_ctlmsk [lnk$v_map] = false ;				!  disable production
     end ;
end ;


routine get_input  =

!++
!
!  This routine retrieves the input files
!
!--
begin
local	status ;

if status = cli$get_value (sd_p1, token_desc)			! Get input file
then 
    begin
    if   cli$present (sd_library)				! /LIBRARY
    then begin
	 infilflgs = .infilflgs or  (fdb$m_libr or fdb$m_libsrch) ;
	 lnk$setlibrin () ;
	 end ;

    if   cli$present (sd_selective_search)			! /SELECTIVE_SEARCH
    then infilflgs = .infilflgs or fdb$m_selser ;

    if  (.infilflgs and fdb$m_libextr) eql 0
    then if   cli$present (sd_include)				! /INCLUDE LIST
	 then begin
	      infilflgs = .infilflgs  or  (fdb$m_libextr or fdb$m_libr) ;
	      lnk$setlibrin () ;
	      end ;

    if   cli$present (sd_options)			 	! /OPTIONS FILE
    then begin
	 infilflgs = .infilflgs or fdb$m_option ;
	 optionfile () ;
	 end ;

    inputfile (token_desc) ;					! Set up input file FDB
    end ;

return .status ;
end ;


routine outputfile  
		(desc : ref block [,byte])	: novalue =
!+
!
!  This routine is called by cli if an output file is to be created. 
!
!  The variable "OUTFILE" points to the cell which is to receive the 
!  address of the file descriptor block for the particular output file.
!
!-
begin
bind	fdb = .outfile	: ref block [,byte] ;			! Point to the pointer

if .fdb eql 0							! If FDB not yet allocated,
then
    begin
    lnk$allofdb (fdb) ;						! Allocate one
    lnk$alloblk (nam$c_maxrss, fdb [fdb$l_usrnamadr]) ;		! Allocate space for filename
    end ;

if (fdb [fdb$w_usrnamlen] = .desc [dsc$w_length]) neq 0		! Update file descriptor
then
    ch$move (.desc [dsc$w_length], .desc [dsc$a_pointer], .fdb [fdb$l_usrnamadr]) ;  ! Copy name

return ;							!   and we are all done
end ;

routine setup_inrelnam 
		(ofp_flag
		,fnm_desc  : ref block [,byte]
		,nam	   : ref block [,byte]
		,file_name : ref vector [,byte]
		) : =

begin
local
	status,
	fab		: block [fab$c_bln, byte] ;	! Fab $PARSE

$fab_init	(fab =  fab				! Intialize the fab 
!		,dna = .typeadr
!		,dns =  typelen
		,fns = .fnm_desc [dsc$w_length]
		,fna = .fnm_desc [dsc$a_pointer]
		,nam = .nam
		) ;
fab [fab$v_ofp] = .ofp_flag ;				! Decide on 'output file parse' setting

$nam_init 	(nam = .nam				! Initialize the nam block
		,rsa = .file_name
		,rss =  nam$c_maxrss
		,esa = .file_name
		,ess =  nam$c_maxrss
		) ;

if (status = $parse (fab=fab))
then
    nam [nam$b_rsl] = .nam [nam$b_esl] ;

return .status ;
end ;

end 
eludom

