module lnk_imgout 
		(ident = 'V04-000'
		,addressing_mode
			(external    = general
			,nonexternal = long_relative
			)
		) =
begin
!
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
!
!
!
!
!++
!
! MODULE:	LNK_IMGOUT
!
! FACILITY:	LINKER
!
! ABSTRACT:	Control production of image file
!
! HISTORY:
!
!    VERSION:	 X01.00
!
!    AUTHOR:	T.J. PORTER 06-APR-77
!
!    MODIFIED BY:
!
!	V03-033	ADE0011		Alan D. Eldridge	 7-Aug-1984
!		Add support for LNK$GL_UNSUPPORTED.  When the low bit
!		is set and we're building a shareable image, then don't convert
!		demand zero pages to copy on reference.  This is done to get
!		around a bug in the image activator that does not know how
!		to deal with shareable demand zero sections.
!
!		Change number of useable bytes in all other blocks but the first
!		in the image-header to 508 (was 512).  This is done to avoid a
!		bug in the image-activator.
!
!		Exit LNK$WRTIMGBYTS immediately if the 'repeat-count' arguement
!		is zero.
!
!	V03-033	ADE0010		Alan D. Eldridge	30-Jul-1984
!		Use error returned by LNK$REQUESTMEM rather than assuming
!		LIN$_MEMFUL.
!
!		Change the number of useable bytes in the first block of the
!		image header to 508 (from 510).  The last word of the first
!		block has a special meaning, and the second to the last word
!		is unusable due to a bug in the image-activator.
!
!	V03-032	JWT0189		Jim Teague		25-Jul-1984
!		Re-implement demand zero pages in shareable images.
!
!	V03-031	ADE0009		Alan D. Eldridge	 5-Jul-1984
!		Add in fixup section page count when figuring the number of
!		blocks in the image portion of the image file.
!
!		Disallow demand zero pages in shareable images until side
!		effects (no symbol table at end of image) have been fixed.
!
!	V03-030	ADE0008		Alan D. Eldridge	22-Jun-1984
!		Adhere to Grammer Rules for output file spec's as defined
!		in the Command Language User's Guide.
!
!		Allow demand zero pages in shareable images.
!
!	V03-029	ADE0007		Alan D. Eldridge	19-May-1984
!		More fixes to V03-026.
!
!	V03-028	ADE0006		Alan D. Eldridge	18-May-1984
!		Don't initialize header if there is none -- fix to 
!		update V03-026.
!
!	V03-027	ADE0005		Alan D. Eldridge	16-May-1984
!		Allocate maximum sized block to store list of shared,
!		local, and based ISD's.
!
!	V03-026	ADE0004		Alan D. Eldridge	 8-May-1984
!		Fix image header construction when image header is longer
!		than one block.
!
!	V03-025	JWT0180		Jim Teague		26-Apr-1984
!		Fill in SHL$B_SHL_SIZE field in first shareable 
!		image list entry.
!
!	V03-024	ADE0003		Alan D. Eldridge	26-Mar-1984
!		Default .EXE device and directory based on whether the /EXE
!		in the command was a command or input parameter qualifier.
!
!	V03-023	ADE0002		Alan D. Eldridge	25-Mar-1984
!		Add 5th entry to transfer vector array for initializing shared
!		images.
!
!	V03-022	ADE0001		Alan D. Eldridge	 3-Mar-1984
!		Make default GSMATCH is created with high bit clear since
!		the high bit set now means to skip the date checks for
!		shareable images and the corresponding library entry.
!
!		Fix bug which limited shareable image name lengths
!		to 30 instead of 31 characters.
!
!	V03-021	JWT0153		Jim Teague		 8-Feb-1984
!		Remove restriction imposed by JWT0131.  Use expanded
!		image name field.  Now 40 bytes: 1 for count, 39 for
!		file name.
!
!	V03-020	JWT0131		Jim Teague		18-Aug-1983
!		FT1 restriction on 11-character shareable image
!		names.
!
!	V03-019	JWT0113		Jim Teague		20-Apr-1983
!		Do $getjpi calls to get number of open files left.
!
!	V03-018 JWT0088		Jim Teague		12-Jan-1983
!		Filter 0-length psects out of DMT.
!
!	V03-017	JWT0078		Jim Teague		15-Dec-1982
!		Change implementation of DMT.
!
!	V03-016	JWT0077		Jim Teague		13-Dec-1982
!		Slight ECO to JWT0074.
!
!	V03-015	JWT0074		Jim Teague		09-Dec-1982
!		Finalize Debugger DMT.
!
!	V03-014 JWT0055		Jim Teague		15-Sep-1982
!		Make uninitialized copy-on-ref image sections demand-zero
!		even if smaller than DZRO_MIN.
!
!	V03-013	JWT0050		Jim Teague		11-Aug-1982
!		Place cli image flag in final word of first image header
!		block if IMAGE_TYPE=CLI specified in options file.
!
!	V03-012 JWT0044		Jim Teague		30-Jul-1982
!		Open file performance boost.
!
!	V03-011	JWT0038		Jim Teague		23-Jun-1982
!		Clean up INFO#212 error.  Also change $EXPREG calls to
!		LNK$REQUESTMEM which will make the calls with better
!		error hanndling.
!
!--

!
!++
!
! FUNCTIONAL DESCRIPTION:
!
!  This module contains all routines associated with image output.
!  It contains the following externally called routines:
!
!	LNK$IMGINIT	No arguments
!
!	LNK$WRTIMGHDR	No arguments
!
!			Processes the singly linked list of image section 
!			descriptors, building the image header with all its
!			ISD'S.
!
!	LNK$WRTIMGBYTS (BYTECOUNT,BUFFRADR,REPTCOUNT)
!
!			Writes "BYTECOUNT" bytes from "BUFFRADR" "REPTCOUNT"
!			times and updates the linker's location counter by the
!			total number of bytes.  If REPTCOUNT or BYTECOUNT is 
!			zero, then exit immediately.
!
!			Attempts to write a byte stream, any part of which falls
!			outside the space allocated to the image produces an
!			error and the value false is returned.
!
!	LNK$FLUSHIMG    No arguments
!
!			Writes every block of image, ensuring that those not
!			touched heretofore are zero filled.
!
!	LNK$CLOSIMGFIL	No arguments
!
!			Closes the image file.
!
!	ANY OF THE ABOVE ERRORS TURNS OFF IMAGE PRODUCTION
!	(BIT LNK$S_IMAGE IN LNK$GL_CTLMSK).
!
!
!--
!
library
	'LIBL32';	 				! SYSTEM USER DATA STRUCTURES
require
	'PREFIX';
library
	'DATBAS';					! INTERNAL DATABASE
require
	'ISGENC';					! IMAGE SECTION FORMATS

forward routine
	lnk$closimgfil 	: novalue,			! CLOSE ROUTINE
	inchdrsize 	: novalue,			! ROUTINE THAT ACCUMULATES HEADER SIZE
	isdtoheader 	: novalue,			! COPY AN ISD INTO THE HEADER
	writeisects,					! WRITE ALL ISECTS TO IMAGE
	lnk$getfixsize,					! COMPUTE SIZE OF FIXUP SECTION
	storespcgfix,					! STORE SPECIAL G^ FIXUP DATA
	lnk$createfix,					! CREATE AND INIT FIXUP SECTION
	readsection 	: novalue,			! READ GLOBAL SECTIONS FROM SHAREABLE IMAGES
	writesection;					! WRITES A SECTION OF AN IMAGE

external routine
	lnk$closefile 	: novalue,			! CLOSE A FILE
	lnk$requestmem,					! MAKE A $EXPREG REQUEST
	lib$traverse_tree,				! TRAVERSE A BINARY TREE
	lnk$filnamdsc,					! GET FILE NAME FROM FAB
	lnk$alloblk	: novalue, 			! ALLOCATE DYNAMIC MEMORY
	lnk$dealblk	: novalue, 			! DEALLOCATE DYNAMIC MEMORY
	lnk$allovirmem,					! ALLOCATE VIRTUAL MEMORY
	lnk$crefixisd,					! CREATE FIXUP ISD
	lnk$sortisects 	: novalue,			! SORT IMAGE SECTION LIST
	lnk$search;					! SYMBOL TABLE SEARCH

external literal
	lin$_closein,					! ERROR CLOSING INPUT FILE
	lin$_closeout,					! ERROR CLOSING OUTPUT FILE
	lin$_confixmem,					! BASED IMAGE HAPPENED ON TOP OF FIXUP SECTION
	lin$_dbgtfr,					! NO DEBUGGER TRANSFER ADDRESS
	lin$_getptierr,					! ERROR RETURNED FROM SYS$GETPTI
	lin$_memful,					! FAILED TO MAP THE IMAGE
	lin$_noimgfil,					! NO IMAGE FILE CREATED
	lin$_openin,					! ERROR OPENING INPUT FILE
	lin$_openout,					! ERROR OPENING OUTPUT FILE
	lin$_outsimg,					! ATTEMPT TO STORE OUTSIDE IMAGE
	lin$_outsimgp,					! DITTO, BUT WITH A PSECT NAME
	lin$_readerr,					! READ FAILURE ON SHAREABLE IMAGE
	lin$_tfrsys,					! TRANSFER ADDRESS IN SYSTEM IMAGE
	lin$_usrtfr,					! NO USER TRANSFER ADDRESS IN EXE IMAGE
	lin$_writeerr,					! WRITE ERROR CODE
	lnk$k_max_filename_length ;			! MAXIMUM FILENAME LENGTH

external
	lnk$gl_unsupported	: bitvector [],		! Bit mask of requested "unsupported" options
	lnk$gl_filesleft,
	lnk$gt_jpilst,
	lnk$gl_dmtbuffer	: vector [2],		! BUFFER FOR DMT
	lnk$gl_dmtbytes,				! SIZE OF DMT IN BYTES
	lnk$gl_minva,					! LOWEST ADDRESS VA ALLOCATED BY VMCTRL
	lnk$gl_lastgadr,				! LAST SPECIAL G^ FIXUP VA
	lnk$gl_spcgfix,					! NUMBER OF SPECIAL G^ FIXUPS
	lnk$gl_spcgimgs,				! NUMBER OF SHR IMGS REFERENCED BY 
							! SPECIAL G^ FIXUPS
	lnk$gl_adrefs,					! NUMBER OF .ADDRESS FIXUP REFERENCES
	lnk$gl_shradr,					! NUMBER OF SHR IMAGES REF'D BY .ADDRESS
	lnk$gl_shrimgs,					! NUMBER OF PIC SHAREABLE IMAGES
	lnk$gl_shrsyms,					! NUMBER OF SYMBOLS IN THOSE IMAGEES
	lnk$gl_shlextra,				! SHL_EXTRA REQUEST
	lnk$gl_fixisd 		: ref block [,byte],	! ISD OF FIXUP SECTION
	lnk$gl_lowclu 		: ref block [,byte],	! ADDR OF LOWEST VA NON-SHR IMG CLUSTER
	lnk$aw_version 		: block [,byte],	! VERSION NUMBER
	lnk$gt_sysver 		: block [,byte],	! "SYS$K_VERSION" ASCIC STRING
	lnk$gl_curomd 		: ref block [,byte],	! POINTER TO CURRENT OBJ MODULE DESCRIPTOR
	lnk$gl_curfil 		: ref block [,byte],	! POINTER TO CURRENT FILE FDB
	lnk$gl_curpsc 		: ref block [,byte],	! POINTER TO CURRENT PSECT DESCRIPTOR
	lnk$gl_inrelnam,				! POINTER TO 1ST INPUT FILE NAM BLOCK
	lnk$gl_relnam_exe,				! POINTER TO .EXE RELATED NAME
	lnk$gb_locnov_exe	: byte,			! LOW BIT SET IF /EXE WAS 'LOCAL' WITH NO VALUE
	lnk$gb_pass 		: byte,			! PASS NUMBER
	lnk$gl_ctlmsk 		: block [,byte],	! CONTROL FLAGS
	lnk$gl_clulst,					! CLUSTER LISTHEADE
	lnk$gl_curclu 		: ref block [,byte],	! CURRENT CLUSTER
	lnk$gl_lstclstr 	: ref block [,byte],	! POINTER TO HIGHEST ADDRESSED CLUSTER
	lnk$gl_defclu 		: block [,byte],	! DEFAULT CLUSTER BLOCK
	lnk$gl_imgfil 		: ref block [,byte],	! POINTER TO IMAGE DESCRIPTOR BLOCK
	lnk$gl_dbgestim,				! ESTIMATE OF DST BYTES ON PASS 1
	lnk$gl_dbgtfps,					! P-SECT DESCRIPTOR FOR DEBUGGER
							! TRANSFER ADDRESS
	lnk$gl_dbgtfr,					! DEBUGGER TRANSFER ADDRESS
	lnk$gw_gstrecs 		: word,			! NUMBER RECORDS WRITTEN TO GST OF IMAGE
	lnk$gl_tfrpsc,					! USER TRANSFER ADDRESS P-SECT
	lnk$gl_tfradr,					! USER TRANSFER ADDRESS
	lnk$gq_alostim 		: vector,		! TIME OF MEMORY ALLOCATION
	lnk$gq_privs 		: vector [2,long],	! VECTOR OF IMAGE PRIVILEGES
	lnk$gt_imgnam 		: vector [,byte],	! IMAGE NAME AREA
	lnk$gt_imgid  		: vector [,byte],	! IMAGE IDENT AREA
	lnk$gw_chans 		: word,			! NUMBER OF I/O CHANNELS
	lnk$gw_dzromin 		: word,			! NUMBER OF PAGES REQUIRED IN I-SECT BEFORE 
							! COMPRESSION
	lnk$gw_ioseg 		: word,			! NUMBER OF PAGES OF IMAGE I/O SEGMENT
	lnk$gw_misects 		: word,			! MAXIMUM NUMBER OF IMAGE SECTIONS
	lnk$gw_nisects 		: word,			! ACTUAL NUMBER OF IMAGE SECTIONS
	lnk$gw_shriscts 	: word,			! NUMBER OF ISECTS FROM PIC SHAREABLE IMAGES
	lnk$gw_nsymbols 	: word,			! NUMBER OF GLOBAL SYMBOLS
	lnk$gw_lsymbols 	: word,			! NUMBER OF GLOBAL SYMBOLS IN THIS IMAGE 
							!   (NOT IN SHR IMAGE)
	lnk$gl_gsbufdsc 	: vector [3] ;		! DESCRIPTOR FOR COPYING GLOBAL SECTIONS

global
	lnk$al_imgrab 		: $rab (rac=seq),	! IMAGE FILE RECORD ACCESS BLOCK.
	lnk$gl_imghdr 		: ref block [,byte],	! POINTER TO IMAGE HEADER
	lnk$gl_curisd 		: ref block [,byte],	! CURRENT ISD ADDRESS
	lnk$gl_imgtop,					! MAPPED ADDRESS AT TOP + 1
	lnk$gl_locn,					! CURRENT LOCATION COUNTER
	lnk$gl_dstlocn,					! NEXT LOCATION IN DST
	lnk$gl_dstend,					! END OF DST WRITTEN
	lnk$gl_rprotisd,				! NUMBER OF SECTIONS TO REPROTECT
	lnk$gl_shrclstrs,				! NUMBER OF SHAREABLE IMAGE CLUSTERS 
							!   (PIC AND NON-PIC)
	lnk$gw_nclusters 	: word,			! NUMBER OF CLUSTERS CREATED
	lnk$gw_dstvbn 		: word,			! VBN AT WHICH DST BEGINS
	lnk$gw_hdrblks 		: word,			! BLOCKS IN IMAGE HEADER
	lnk$gw_imgblks 		: word,			! BLOCKS OF IMAGE
	lnk$gw_imgifi 		: word,			! IFI OF IMAGE FILE
	lnk$gw_dstblks 		: word,			! NUMBER OF BLOCKS OF DST
	lnk$gw_gstvbn 		: word,			! VBN OF GLOBAL SYMBOL TABLE
	lnk$gl_matchid,					! MATCH CONTROL ID FOR THIS SHAREABLE IMAGE
	lnk$gb_matchctl 	: byte initial (%x'FF') ; ! MATCH CONTROL FLAGS

own
	dmtblks,					! DMT SIZE IN PAGES
	dmtvbn,						! VBN OF DMT IMAGE SECTION
	shrimgrab 		: $rab (rac=seq),	! RAB FOR READING SECTIONS OF SHAREABLE IMAGES
	curvbn,						! CURRENT VBN FOR IMAGE SECTION
	shrimgclu 		: ref block [,byte],	! LAST OPEN SHAREABLE IMAGE TO CLUSTER DESC PTR
	dstvirtop,					! AND THE TOP
	dstbuffer 		: vector [2],		! BUFFER DESCRIPTOR FOR DST GENERATED
	header_desc 		: vector [2],		! DESCRIPTOR OF HEADER BUFFER
	header_ptr		: initial (0),		! RUNNING HEADER OUPUT POINTER
	header_size 		: initial 		! ACCUMULATOR FOR IMAGE HEADER - STARTS
				   (ihd$k_maxlength) ;	! INCLUDING FIXED PART, ACTIVATION PART
literal
	first_block_size	=  508,			! USEABLE BYTES IN FIRST BLOCK
							! (The last word has a special meaning and the second
							!  and the second to the last word can't be used due
							!  to a bug in the image-activator.)
	subseq_block_size	=  508,			! USEABLE BYTES IN ALL BUT FIRST BLOCK OF HEADER
							! (The last word can't be used due to a bug in the 
							! image-activator.)
	tfrlength 		= 5120 ;		! MAXIMUM TRANSFER BYTE COUNT

global routine lnk$imginit : novalue =
begin
!
!	THIS ROUTINE IS CALLED TO INITIALIZE THE IMAGE GENERATION
!
bind
    auxfnb = lnk$gl_imgfil [fdb$t_auxfnb] : block [nam$c_bln, byte] ; ! NAME THE NAM BLOCK
local
    status,
    imgfab : block [fab$c_bln, byte] ;

$fab_init	(fab = imgfab					! INITIALIZE THE FAB
		,fns = .lnk$gl_imgfil [fdb$w_usrnamlen]
		,fna = .lnk$gl_imgfil [fdb$l_usrnamadr]
		,dns = (if .lnk$gb_locnov_exe 
			then %charcount ('.EXE')
			else %charcount ('SYS$DISK:[].EXE')
		       )
		,dna = (if .lnk$gb_locnov_exe 
			then uplit (byte ('.EXE'))
			else uplit (byte ('SYS$DISK:[].EXE'))
		       )
		,nam = auxfnb
		) ;
								
if  .lnk$gb_locnov_exe 						! USE 'OUTPUT FILE PARSING' UNLESS
then imgfab [fab$v_ofp] = false					! /EXE WAS A LOCAL QUALIFIER
else imgfab [fab$v_ofp] = true ;				! WITHOUT A SPECIFED VALUE

auxfnb [nam$l_rlf] = .lnk$gl_relnam_exe ;			! SET RELATED FILE NAME ADDRESS

if $parse (fab = imgfab)					! PARSE THE FILENAME
then begin
     if  .lnk$gt_imgnam [0] eql 0				! NEED AN IMAGE NAME?
     then begin
	  lnk$gt_imgnam [0] = .auxfnb [nam$b_name] ;		! SET LENGTH OF FILENAME
	  ch$move (.lnk$gt_imgnam [0]				! AND MOVE IT IN
		  ,.auxfnb [nam$l_name]
		  , lnk$gt_imgnam [1]
		  ) ;
	  end ;
     if  .lnk$gt_imgid [0] eql 0				! NEED AN IDENT?
     then begin
	  lnk$gt_imgid [0] = .auxfnb [nam$b_type] ;		! FIGURE THE LENGTH
	  ch$move (.lnk$gt_imgid [0]				! AND MOVE IT IN
		  ,.auxfnb [nam$l_type]
		  , lnk$gt_imgid [1]
		  ) ;
	  end ;
     ch$move (dsc$c_s_bln, lnk$filnamdsc (imgfab), lnk$gl_imgfil [fdb$q_filename]) ;
     end ;

if not .lnk$gl_ctlmsk [lnk$v_sys]				! IF NOT A SYSTEM IMAGE,
then if .lnk$gl_ctlmsk [lnk$v_trace]				! AND TRACEBACK 
     or .lnk$gl_ctlmsk [lnk$v_dbg]				! OR DEBUGGING ENABLED, THEN
     then begin
	  lnk$gl_dstend  = 0 ;					! INITIALIZE END POINT AT START
	  dstvirtop      = (.lnk$gl_dbgestim or 511) + 1 ;	! AND ADD THE SIZE INTO VIRTUAL DESCRIPTOR
	  lnk$gl_dstlocn = 0 ;					! SET LOCATION COUNTER AT START
	  status = lnk$requestmem (.dstvirtop/512, dstbuffer) ;	! ALLOCATE A BUFFER FOR IT
	  if not .status					!
	  then	begin						! BUT IF IT FAILS
		lnk$gl_ctlmsk [lnk$v_image] = false ;		! DISABLE IMAGE PRODUCTION
		signal (.status, 0, lin$_noimgfil) ;		! REPORT THE ERROR
		return ;					! AND GIVE UP
		end ;
	  end ;

if (.lnk$gl_ctlmsk [lnk$v_sys] and .lnk$gl_ctlmsk [lnk$v_sysheadr])
then lnk$gw_misects = 0 ;					! DISABLE IMAGE COMPRESSION

if  .lnk$gl_gsbufdsc [0] neq 0					! IF ANY GLOBAL SECTIONS ARE TO BE COPIED
then if not (status = lnk$requestmem (.lnk$gl_gsbufdsc [0]	! THEN ALLOCATE A BUFFER EQUAL IN SIZE
				     , lnk$gl_gsbufdsc [1]	! TO THE LARGEST ONE SEEN
	    )			     )
     then begin							! BUT IF IT FAILS
	  lnk$gl_ctlmsk [lnk$v_image] = false ;			! DISABLE IMAGE PRODUCTION
	  signal (.status, 0, lin$_noimgfil) ;			! REPORT THE ERROR
	  return ;						! AND GIVE UP
	  end ;
return ;
end ;

global routine lnk$wrtimgbyts (bytecount, buffradr, reptcount, pos, siz) =
!
!  This routine is called to write "BYTECOUNT" bytes from "BUFFRADR" with
!  "REPTCOUNT" repetitions to the output image, starting at the current 
!  location, LNK$GL_LOCN.  The location counter is updated by 
!  BYTECOUNT*REPTCOUNT .
!
!  If "POS" AND "SIZ" are non-null parameters, the call is assumed to be 
!  a variable position and size bit store.
!
!  Any attempt to write outside the image causes an error.
!
begin
local
	status,
	storelolimit,						! LOWEST LEGAL OUTPUT ADDRESS
	storehilimit,						! HIGHEST LEGAL OUTPUT ADDRESS,
	storehiaddr,						! HIGHEST ADDRESS WE WILL OUTPUT TO
	bitstore,						! TRUE IF STORING VARIABLE POSITION AND SIZE
	partition,						! POINTER TO IMAGE PARTITION NAME (DS OR EXE)
	storeaddr ;						! OUTPUT ADDRESS

builtin
	ap ;

bind
	arglist = .ap : vector ;


if	.bytecount eql 0					! IF ZERO BYTE COUNT
or	.reptcount eql 0					! OR ZERO REPEAT COUNT
or not .lnk$gl_ctlmsk [lnk$v_image]				! OR NO IMAGE TO BE PRODUCED
then return true ;						! RETURN DONE

bitstore = .(arglist [0])<0,8> eql 5 ;				! DETERMINE IF VARIABLE BIT STORE

storehiaddr = .lnk$gl_locn + .bytecount*.reptcount ;		! FIGURE HIGHEST ADDRESS WE WANT TO STORE INTO
storelolimit = 0 ;						! LIMITS ARE INITIALLY 0
storehilimit = 0 ;						! 
partition    = cstring('image binary') ;

if .lnk$gl_ctlmsk [lnk$v_dbgrec]				! IF THIS IS DEBUGGER DATA
or .bitstore							! OR ITS A VARIABLE BIT STORE COMMAND
or  not ch$fail(ch$find_not_ch(.bytecount,.buffradr,0))		! OR THERE IS A NON ZERO CHARACTER
or (if .lnk$gl_curisd eql 0 					! IF NO ISECT SET UP
    then false
    else if .lnk$gl_curisd [isl$l_bufadr] eql 0			! OR IF NO BUFFER SET UP
	 then begin						! THEN WE ARE DONE
	      lnk$gl_locn = .storehiaddr ;			! SO SET THE LOCATION COUNTER
	      return true ;					! AND RETURN SUCCESS
	      end
	else true 						! NO NON-ZERO BYTES TO STORE
   )								! BUT OTHERWISE OK
then begin							! IT HAS BEEN TOUCHED BEFORE
     !
     !	THEN WE ARE GOING TO WRITE IT TO THE IMAGE SECTION
     !
     if not .lnk$gl_ctlmsk [lnk$v_dbgrec]			! IF NOT A DEBUG DATA BYTE STREAM
     then begin							! SET UP THE LO AND HI ADDRESS
	  if .lnk$gl_curisd neq 0				! IF A IMAGE SECTION HAS BEEN
	  then  begin						! SET UP
		bind hdrisd  = lnk$gl_curisd [isl$t_hdrisd]	! LABEL FOR PART GOING TO HEADER
						: block [,byte] ;	! 
		storelolimit = .hdrisd [isd$v_vpg] ^ 9 ;		! LOW LIMIT IS BASE OF ISECT
		storehilimit = .storelolimit  +				! AND HIGH LIMIT IS BYTE BEYOND
				.hdrisd [isd$w_pagcnt]*512 ;
		if  .storehiaddr gtru .storehilimit				! IF WE WILL EXCEED IMAGE SECTION
		and .lnk$gl_curpsc [psc$l_base]+.lnk$gl_curpsc [psc$l_length]	! AND PSECT EXCEEDS IMAGE SECTION
			gtru .storehilimit
		then begin							! THEN WE MUST STORE AS SECTIONS
		     local	bytes2write,					! BYTES LEFT TO WRITE
				curisd ;					! SAVED CURRENT ISD POINTER
		     curisd = .lnk$gl_curisd ;					! SAVE CURRENT ISECT DESCR. POINTER
		     if .lnk$gl_locn gtru .storelolimit				! IF ALREADY INTO ANOTHER ISECT
		     then begin							! THEN FIND STARTING ISECT
			  while (lnk$gl_curisd = .lnk$gl_curisd [isl$l_nxtisd]) ! WHILE THERE ARE MORE ISECT DESCRIPTORS
				neq 0
			  do begin
			     bind hdrisd  = lnk$gl_curisd [isl$t_hdrisd] : block [,byte] ; ! NAME PART FOR HEADER
			     storelolimit = .hdrisd [isd$v_vpg] ^ 9 ;			  ! COMPUTE LOW LIMIT
			     storehilimit = .storelolimit + .hdrisd [isd$w_pagcnt]*512 ;  ! AND HI LIMIT
			     if .storehiaddr lequ .storehilimit then exitloop ;
			     end ;

		   	  if .lnk$gl_curisd eql 0 then return false ;		! ERROR IF NO ISECT FOUND
			  end ;							! FINDING STARTING ISECT

		     bytes2write = .bytecount * .reptcount ;			! FIGURE BYTES TO WRITE
		     while .bytes2write neq 0					! WHILE THERE ARE MORE TO DO
		     do	begin
			local	roomleft,					! ROOM LEFT IN THE CURRENT IMAGE SECTION
				isdrept,					! REPEAT COUNT THIS ISD
				isdleft ;					! BYTES LEFT FROM NON-FULL REPEAT COUNT

			roomleft = .storehilimit - .lnk$gl_locn ;		! FIGURE ROOM LEFT IN IMAGE SECTION
			while .roomleft neq 0					! WHILE THERE IS ROOM IN THIS IMAGE SECTION
				and 
			      .bytes2write neq 0				! AND THERE ARE MORE BYTES TO WRITE
			do begin
		    	   isdrept     = minu (.roomleft/.bytecount,.reptcount) ; ! FIGURE NUMBER FULL REPEATS
			   bytes2write = .bytes2write - .bytecount*.isdrept ;	! ADJUST BYTE COUNT
			   isdleft     = .roomleft - .bytecount*.isdrept ;	! AND NUMBER OF BYTES LEFT AFTER FULL REPEATS

			   if .bytes2write eql 0 then isdleft = 0 ;		! NO PARTIAL BLOCK IF FINISHED ALL BYTES

			   if not lnk$wrtimgbyts (.bytecount,.buffradr,.isdrept) ! WRITE THE FULL REPEATS
			   then return false ;

			   if .isdleft neq 0					! IF THERE IS A PARTIAL WRITE
			   then if not lnk$wrtimgbyts (.isdleft,.buffradr,1)	! THEN WRITE IT OUT NOW
				then return false
				else bytes2write = .bytes2write - .isdleft ;	! ADJUST COUNT

		           roomleft = .roomleft - .bytecount*.isdrept - .isdleft ; ! ADJUST THE ROOM LEFT THIS ISECT
			   end ;						! WHILE ROOM AND BYTES TO WRITE

			lnk$gl_curisd = .lnk$gl_curisd [isl$l_nxtisd] ;		! LINK TO NEXT ISD

			    begin
		    	    bind hdrisd = lnk$gl_curisd [isl$t_hdrisd]		! NAME PART GOING TO HEADER
						: block [,byte] ;
			    if .isdleft neq 0					! IF WE WROTE A PARTIAL STRING
			    then if not lnk$wrtimgbyts	(.bytecount-.isdleft	! THEN WRITE THE REST OF THE STRING
							,.buffradr +.isdleft
							,1
							)
				 then return false ;

			    storelolimit = .hdrisd [isd$v_vpg] ^ 9 ;		! SET NEW LOW LIMIT
			    storehilimit = .storelolimit +			! AND NEW HIGH LIMIT
						.hdrisd [isd$w_pagcnt]*512 ;	!
			    end ;
			end ;							! BYTES2WRITE NEQ 0

		     lnk$gl_curisd = .curisd ;					! RESTORE CURISD
		     return true ;						! ALL DONE, RETURN SUCCESS
		     end ;							! EXCEEDING IMAGE SECTION
		end ;								! POSITION TO WRITE BYTE STREAM

	if .lnk$gl_curisd neq 0
	then begin
	     bind hdrisd = lnk$gl_curisd [isl$t_hdrisd] : block [,byte] ;

	     if  .lnk$gl_curisd [isl$l_bufadr] eql 0			! IF A BUFFER HAS NOT YET BEEN
	     and .hdrisd [isd$w_pagcnt] gtru 0				! AND ISECT IS NON-NULL
	     then if not (status = lnk$requestmem (.hdrisd [isd$w_pagcnt] ! ALLOCATED, EXPAND MY PROGRAM REGION
						  , lnk$gl_curisd [isl$l_bufadr]
			 )			  )
		  then 	begin						! BY SIZE OF I-SECT BEING WRITTEN
			signal (.status, 0, lin$_noimgfil) ;		! REPORT THE ERROR
			lnk$gl_ctlmsk [lnk$v_image] =  false ;		! SPACE AND TURN OFF ANY MORE
			return true ;					! ATTEMPTS
		        end ;
	     storeaddr = .lnk$gl_curisd [isl$l_bufadr] ;		! START STORE ADDRESS COMPUTATION
	     end
     end
else begin							! BUT IF IT IS THE DST BEING WRITTEN
     storelolimit = 0 ;						! THEN LIMITS ARE THE BASE AND TOP OF
     storehilimit = .dstvirtop ;				! THE DST AS IF IT WERE MAPPED INTO THE EXE
     partition    = cstring('Debugger Symbol Table') ;		! AT THE END
     storeaddr    = .dstbuffer [0] ;				! START COMPUTATION OF ACTUAL STORE ADDRESS
     end ;
end ;

if .lnk$gl_locn lssu .storelolimit				! IF LOCATION COUNTER
or .storehiaddr gtru .storehilimit				! BEYOND IMAGE
then begin							! ALLOCATION, ISSUE AN
     if .lnk$gl_curpsc eql 0					! IF PSECT NOT AVAILABLE
     then signal (lin$_outsimg,6,.lnk$gl_locn,			! ERROR AND GIVE UP
			.partition,.storelolimit,.storehilimit,
			lnk$gl_curomd [omd$b_namlng],
			lnk$gl_curfil [fdb$q_filename],lin$_noimgfil)
     else signal (lin$_outsimgp,7,.lnk$gl_locn,			! ERROR AND GIVE UP
			.partition,.storelolimit,.storehilimit,
			lnk$gl_curpsc [psc$b_namlng],
			lnk$gl_curomd [omd$b_namlng],
			lnk$gl_curfil [fdb$q_filename],lin$_noimgfil) ;
     lnk$gl_ctlmsk [lnk$v_image] = false ;			! TURNING OFF ANY
     return false ;						! MORE ATTEMPTS
     end ;

if  .bitstore							! IF VARIABLE BIT STORE
then begin
     bind imagebuf = .lnk$gl_curisd  [isl$l_bufadr] : block [,byte] ;
     map buffradr  : ref block [,byte] ;

     imagebuf [(.lnk$gl_locn-.storelolimit), .pos, .siz, 0] = .buffradr ; ! DO THE BIT STORE
     return true ;
     end ;

storeaddr = .storeaddr + .lnk$gl_locn - .storelolimit ;		! COMPUTE MAPPED

incr i from 1 to .reptcount 					! LOOP, MOVING THE REQUIRED BYTES,
do   storeaddr = ch$move(.bytecount,.buffradr,.storeaddr) ;	! UPDATING THE ADDRESS

lnk$gl_locn = .storehiaddr ;					! UPDATE LOCATION COUNTER

if   .lnk$gl_ctlmsk [lnk$v_dbgrec]					! IF THIS IS A DEBUG RECORD
and (.lnk$gl_locn-1) gtru .lnk$gl_dstend			! AND THIS IS NEW HIGH DST ADDRESS
then  lnk$gl_dstend = .lnk$gl_locn ;

return true ;							! AND ALL DONE
end ;


global routine lnk$flushimg : novalue =
begin
!
!++
!	THIS ROUTINE IS CALLED WITHOUT ANY ARGUMENTS TO FLUSH THE
!	BINARY THAT WAS GENERATED TO AN IMAGE FILE.
!	THE FIRST PHASE IS TO GO DOWN THE LIST OF IMAGE SECTION DESCRIPTORS
!	AND WITH THE USE OF THE MEMORY MANAGEMENT SYSTEM SERVICE
!	$GETPTI, COMPRESSING THE UNINITIALIZED PAGES FROM EACH IMAGE SECTION
!	THE COMPRESSION IS ACHIEVED BY GENERATING A DEMAND ZERO IMAGE
!	SECTION DESCRIPTOR FOR EACH REGION OF AN IMAGE SECTION THAT
!	HAS NOT BEEN TOUCHED DURING PASS 2.
!	THE SIZES OF THE IMAGE HEADER AND IMAGE BINARY ARE ACCUMULATED DURING THIS 
!	PHASE WHICH ENDS WITH CREATION OF THE FILE AND ALLOCATION OF A BUFFER FOR THE HEADER.
!	THE NEXT PHASE CONSISTS OF ANOTHER PASS DOWN THE LIST OF 
!	IMAGE SECTION DESCRIPTORS, CREATING THE ISD ENTRY IN THE 
!	HEADER (STILL IN MEMORY) AND WRITING TO THE IMAGE FILE THOSE
!	IMAGE SECTIONS THAT CONTAIN BINARY DATA.
!	FINALLY THE DEBUG SYMBOL TABLE, IF ANY IS WRITTEN TO THE FILE
!	AND THE SUMMARY PARAMETERS OF THE IMAGE HEADER ARE COMPUTED.
!	THE FILE IS LEFT OPEN FOR POSSIBLE APPENDING OF THE GLOBAL SYMBOL
!	TABLE FOLLOWED BY THE WRITING OF THE IMAGE HEADER.
!
!--
!
label
	procsisd ;
!
local
	based,						! 1 IF IMAGE IS BASED, ZERO OTHERWISE
	isdlist 	: ref vector [,long],		! POINTER TO TABLE IF ISD ADDRESSES
	isdnum,						! INDEX INTO ISECT LIST
	shrisdlist 	: ref vector [,long],		! PTR TO TABLE OF ISD ADDRESSES IN PIC SHR IMAGES
	shrisdnum,					! INDEX INTO SHRISDLIST
	shrclulst	: ref vector [,long],		! LIST OF CLUSTER DESCRIPTORS
	shrclunum,					! INDEX IN SHRCLULST
	adrclulst 	: ref vector [,long],		! LIST OF LOCAL CLUSTERS REFERENCED BY .ADDRESS
	adrclunum,					! INDEX INTO ADRCLULST
	errorcode,					! WRITE ERROR CODE RETURNED
	rmsstv,						! STV RETURNED FROM RMS
	emptydesc	: vector [2],			! DESCRIPTOR RETURNED FOR EMPTY PAGES
	fileblks,					! NUMBER OF BLOCKS IN FILE
	lastcluster,					! TRUE IF CLUSTER IS LAST CLUSTER
	imagefab	: block [fab$c_bln,byte],	! FILE ACCESS BLOCK - JUST FOR CREATE
	firstisd	: ref block [,byte],		! POINTER TO FIRST ISD IN CLUSTER
	previsd		: ref block [,byte] ;		! POINTER TO PREVIOUS ISD

bind
    auxfnb = lnk$gl_imgfil [fdb$t_auxfnb] : block [nam$c_bln,byte] ;	! AUXILIARY FILENAME BLOCK

if      .lnk$gl_ctlmsk [lnk$v_sys]					! IF A SYSTEM IMAGE
and not .lnk$gl_ctlmsk [lnk$v_sysheadr]					! AND NO HEADER REQUESTED
then begin								! THERE IS ONLY ONE ISD (BUT NO HEADER)
     bind sysisd    = lnk$gl_defclu [clu$l_fstisd] : ref block [,byte],	! GIVE IT A NAME
	  syshdrisd = sysisd [isl$t_hdrisd]        : block [,byte] ;	! AND FOR PART THAT WOULD BE HEADER

     header_size = 0 ;						! NO HEADER
     if .lnk$gl_defclu [clu$l_fstisd] neq 0			! IF THERE IS AN IMAGE SECTION
     then lnk$gw_imgblks = .syshdrisd [isd$w_pagcnt] ;		! GET THE BLOCK COUNT
     end
else begin							! ELSE, IF NO GSMATCH OPTION (IGNORED EXCEPT 
     if .lnk$gb_matchctl  eql %x'FF'				! FOR SHAREABLE IMAGES)
     then begin							! THEN FORCE A MATCH EQUAL
	  lnk$gb_matchctl = isd$k_matequ ;			! SINCE USER OPTED NOT TO SPECIFY
	  lnk$gl_matchid  = .lnk$gq_alostim <16,31,0> ;		! USE THE MIDDLE 31 BITS OF LINK TIME
	  end ;							! (default high bit must be zero)
      lnk$gl_curclu = lnk$gl_clulst ;				! START AT FIRST CLUSTER
      while(lnk$gl_curclu = .lnk$gl_curclu [clu$l_nxtclu]) neq 0 ! GO DOWN THE LIST
      do begin
	 lastcluster = (.lnk$gl_curclu eql .lnk$gl_lstclstr)	! SEE IF THIS IS THE LAST CLUSTER
			and not .lnk$gl_ctlmsk [lnk$v_shr] ;	!  BUT ONLY IN EXECUTABLE IMAGES
	 previsd = lnk$gl_curclu [clu$l_fstisd] ;
	 while (lnk$gl_curisd = .previsd [isl$l_nxtisd]) neq 0 	! WHILE THERE IS ANOTHER
	 do 
procsisd:   begin
	    bind curhdrisd = lnk$gl_curisd [isl$t_hdrisd] 	! NAME THE HEADER PART OF IT
						: block [,byte] ;
	    if .lnk$gl_curisd eql .lnk$gl_fixisd		! IF THIS IS THE FIXUP SECTION
	    then begin
		 lnk$gw_imgblks = .lnk$gw_imgblks + .curhdrisd [isd$w_pagcnt] ;	! ADD IN COUNT
		 previsd        = .lnk$gl_curisd ;				! MOVE TO NEXT
		 leave procsisd ;				! AND DON'T TOUCH THE FIXUP SECTION
		 end ;
	    if .curhdrisd [isd$w_pagcnt] eql 0			! IF ZERO LENGTH I-SECTION
	    then begin
		 lnk$gw_nisects = .lnk$gw_nisects  - 1 ;	! DISCOUNT 
		 previsd        = .lnk$gl_curisd ;		! MOVE TO NEXT
		 leave procsisd ;				! AND SKIP THIS ONE
		 end ;

	    if  .lnk$gl_ctlmsk [lnk$v_protect]			! IF IMAGE IS PROTECTED
	    or  .lnk$gl_curclu [clu$v_protect]			! OR IMAGE IS PROTECTED
	    or  .curhdrisd [isd$v_vector]			! OR ISECT IS A VECTOR ISECT
	    then curhdrisd [isd$v_protect] = true ;		!   THEN PROTECT THE IMAGE SECTION

	    if .lastcluster
	    then curhdrisd [isd$v_lastclu] = true ;

	    if  not .curhdrisd [isd$v_dzro]			! IF NOT ALREADY A DEMAND ZERO SECTION
	    and .lnk$gl_curisd [isl$l_bufadr] eql 0		! BUT NO BUFFER YET ALLOCATED
	    then if      .curhdrisd [isd$v_wrt]
		 and not .curhdrisd [isd$v_gbl]			! AND NOT GLOBAL
		 and not (.lnk$gl_ctlmsk [lnk$v_shr] 		! *** TEMP DUE TO IMAGE ACTIVATOR BUG ***
				and not				!   Use CRF instead of DZRO if we're building
			  .lnk$gl_unsupported [0]		!   a shareable image and the "unsupported"
			 )					!   DZRO option has not be selected
		 then begin
		      curhdrisd [isd$w_size] = isd$k_lendzro ;	! THEN CONVERT WHOLE SECTION
		      curhdrisd [isd$v_dzro] = true ;		! TO A DEMAND ZERO
		      curhdrisd [isd$v_crf]  = false ;		! DISABLING POSSIBLE COPY ON REFERENCE
		      end
		 else if  .curhdrisd [isd$v_gbl]		! OTHERWISE, IF IT IS GLOBAL
		      then begin
			   if      .lnk$gl_curclu [clu$v_copy]	! AND THE CLUSTER IS TO BE
			   and not .curhdrisd [isd$v_protect]	! COPIED INTO THIS IMAGE
			   then begin
				lnk$gl_curisd [isl$l_bufadr] = .lnk$gl_gsbufdsc [1] ; ! SET THE BUFFER
				lnk$gl_curisd [isl$l_bufend] = .lnk$gl_gsbufdsc [2] ; ! DESCRIPTOR
				end
			   else begin
				curhdrisd [isd$l_vbn]        = 0 ;		! SET NO VBN
				lnk$gl_curisd [isl$l_bufadr] = 0 ;		! AND NO BUFFER
				lnk$gl_curisd [isl$l_bufend] = 0 ;
				end ;
			   end
		      else begin
			   local status ;
			   status = lnk$requestmem (.curhdrisd [isd$w_pagcnt]    ! IF LOCAL SECTION, ALLOCATE
						   ,lnk$gl_curisd [isl$l_bufadr] ! A BUFFER OF ZEROES
					           ) ;
			    if not .status
			    then begin
				 signal (.status, 0, lin$_noimgfil) ;		! REPORT THE ERROR
				 lnk$gl_ctlmsk [lnk$v_image] = false ;		! DISABLE IMAGE PRODUCTION
				 return ;					! AND GIVE UP
				 end ;
			    end ;

	    if .lnk$gl_curisd [isl$l_bufadr] neq 0			! IF THERE IS NOW A BUFFER
	    and 							! AND SECTION IS TOO SMALL
		(        .curhdrisd [isd$w_pagcnt] lssu .lnk$gw_dzromin	! FOR COMPRESSION OR
	     	  or not .curhdrisd [isd$v_wrt]				! IS READ ONLY OR WE
		  or     .lnk$gw_nisects gequ .lnk$gw_misects		! HAVE EXCEEDED LIMIT ON ISD'S
		)							! THEN ADD THE SECTION
	    then lnk$gw_imgblks = .lnk$gw_imgblks + .curhdrisd [isd$w_pagcnt] ;	! SIZE TO IMAGE

	   if     .curhdrisd [isd$v_dzro]				! IF SECTION IS STILL DEMAND ZERO
	   or not .curhdrisd [isd$v_wrt]				! OR IS NOT WRITABLE
	   or     .curhdrisd [isd$v_gbl]				! OR THIS IS GLOBAL
	   or     .curhdrisd [isd$w_pagcnt] lssu .lnk$gw_dzromin	! OR THE SECTION IS TOO SMALL
	   or     .lnk$gw_nisects gequ .lnk$gw_misects			! OR WE HAVE ENOUGH OF THEM
	   or    (.lnk$gl_ctlmsk [lnk$v_shr] 				!** TEMP DUE TO IMAGE ACTIVATOR BUG **
			and not						!  Don't convert to DZRO if building
		  .lnk$gl_unsupported [0]				!  a shr image and the "unsupported"
		 )							!  DZRO option has not be selected
	   then previsd = .lnk$gl_curisd				! WE ARE DONE WITH IT - THIS IS NOW PREVIOUS
	   else begin
		do  begin						! LOOP FOR CALLS TO PTI SERVICE
		    bind curhdrisd = lnk$gl_curisd [isl$t_hdrisd]	! RENAME THE HEADER PART
						: block [,byte] ;	! FOR POSSIBLE CHANGE OF CURRENT ISD
		    if not (errorcode = $getpti
				(inadr  = lnk$gl_curisd [isl$l_bufadr]  ! CALL $GETPTI TO FIND UNTOUCHED PAGES
				,retadr = emptydesc [0]			! TWO -LONGWORD RETURN ARRAY
				,acmode = 0				! ACCESS MODE IS USER
				,mask   = 1				! PAGES WHICH ARE DEMAND ZERO
				,pagcnt =.lnk$gw_dzromin		! MUST BE AT LEAST THIS MANY PAGES
			    )   )
		    then begin						! BUT IF AN ERROR RETURNED
			 signal  (lin$_getptierr,4			! THEN TELL THE USER AND 
				,.lnk$gl_curisd [isl$l_bufadr]		! CONTINUE WITHOUT THE IMAGE
				,.lnk$gl_curisd [isl$l_bufend]
				,.curhdrisd [isd$v_vpg]
				,.curhdrisd [isd$w_pagcnt]
				,.errorcode, 0 ,lin$_noimgfil
				) ;
			 lnk$gl_ctlmsk [lnk$v_image] = false ;		! DISABLE ANY MORE IMAGE OUTPUT
			 return ;
			 end ;
		    if (emptydesc [1] = .emptydesc [1] + 1) eql 0	! IF WE DON'T HAVE ANOTHER EMPTY 
		    or .lnk$gw_nisects gequ .lnk$gw_misects		! REGION OR WE HAVE ENOUGH OF THEM
		    then begin	
			 previsd        = .lnk$gl_curisd ;		! THEN CURRENT BECOMES PREVIOUS
			 lnk$gw_imgblks = .lnk$gw_imgblks + .curhdrisd [isd$w_pagcnt] ; ! AND TO THE IMAGE
			 emptydesc [1]  =  0 ;				! ENSURE END OF LOOP
			 end
		    else begin						! IF WE DO HAVE ANOTHER ....
			 local	newisd    : ref block [,byte],		! POINTER FOR NEWLY ALLOCATED ISD
				newhdrisd : ref block [,byte] ;		! AND THE HEADER PART OF IT

			 lnk$alloblk (isd$c_size,newisd) ;		! ALLOCATE AN IMAGE SECTION DESCRIPTOR
			 newisd [isl$l_cludsc] = .lnk$gl_curclu ;	! SET CLUSTER DESCRIPTOR POINTER
			 newisd [isl$l_bufadr] = 0 ;			! ZERO THE BUFFER ADDRESS
			 newisd [isl$l_bufend] = 0 ;			! QUADWORD
			 newhdrisd = newisd [isl$t_hdrisd] ;		! SET POINTER TO HEADER PART
			 newhdrisd [isd$w_size] = isd$k_lendzro ;	! SET LENGTH OF DESCRIPTOR
			 newhdrisd [isd$w_pagcnt] = 			! SET SECTION SIZE IN PAGES
					(.emptydesc [1] - .emptydesc [0])/512 ;	
			 newhdrisd [isd$l_flags] = 			! COPY THE CURRENT SECTION FLAGS
					(.curhdrisd [isd$l_flags] or isd$m_dzro) ! AND SET DEMAND ZERO
					and not isd$m_crf ;		! CLEARING COPY ON REFERENCE
			 newhdrisd [isd$v_pfc] = 0 ;			! SET THE PAGE FAULT CLUSTER
			 if  .curhdrisd [isd$v_protect]			! IF ISECT SHOULD BE PROTECTED
			 then newhdrisd [isd$v_protect] = true ; 	! THEN DO SO

			 !
			 !	THE IMAGE SECTION DESCRIPTOR FOR THE NEW DEMAND ZERO
			 !	SECTION IS NOW SET UP. HOWEVER WE STILL HAVE TO DETERMINE
			 !	THE BASE VIRTUAL ADDRESS OF IT AND THE REMNANT OF THE ORIGINAL
			 !	IMAGE SECTION. IN ADDITION THE BUFFER ADDRESS OF THE BINARY
			 !	OF THE REMNANT MUST BE ADJUSTED.
			 !	AFTER THIS THE NEW ISD IS LINKED ONTO THE LIST OF ISD, IN
			 !	USER VIRTUAL ADDRESS ORDER.
			 !
			 if .emptydesc [0] eql .lnk$gl_curisd [isl$l_bufadr] ! IF THE EMPTY REGION IS AT
			 then 
			    begin					    ! BEGINNING OF THIS SECTION
			    previsd [isl$l_nxtisd] = .newisd ;		    ! PREVIOUS ISD POINTS TO NEW
			    newhdrisd [isd$v_vpg] = .curhdrisd [isd$v_vpg] ;! AND NEW I-SECT IS AT
			    curhdrisd [isd$w_pagcnt] =			    ! THIS ONES VIRTUAL ADDRESS
						.curhdrisd [isd$w_pagcnt] - ! REDUCE CURRENT I-SECT'S PAGE
						.newhdrisd [isd$w_pagcnt] ; ! BY NUMBER THAT ARE EMPTY
			    newisd [isl$l_nxtisd] = .lnk$gl_curisd ;	    ! ONLY PART OF SECTION
			    lnk$gl_curisd [isl$l_bufadr] = .emptydesc [1] ; ! SO NEW ISD POINTS TO
			    curhdrisd [isd$v_vpg] = 			    ! CURRENT AND THE BUFFER AND
						.curhdrisd [isd$v_vpg] +    ! VIRTUAL ADDRESSES OF 
						.newhdrisd [isd$w_pagcnt] ; ! CURRENT ARE THE PAGES
									    ! BEYOND EMPTY REGION'S
			    lnk$gw_nisects = .lnk$gw_nisects + 1 ;	    ! COUNT NEW IMAGE SECTION
			    previsd = .lnk$gl_curisd ;			    ! CURRENT ISD BECOMES PREVIOUS
			    end
			 else 
			    begin					    ! EMPTY REGION IS NOT AT FRONT
			    newisd [isl$l_nxtisd] = .lnk$gl_curisd [isl$l_nxtisd] ; ! CURRENT POINTS TO NEW
			    lnk$gl_curisd [isl$l_nxtisd] = .newisd ;	    ! THEN CURRENT I-SECT PAGE
			    curhdrisd [isd$w_pagcnt] = 			    ! COUNT BECOMES NO. BEFORE
					(.emptydesc [0] - .lnk$gl_curisd [isl$l_bufadr])/512 ;	
									    ! UNTOUCHED REGION
			    lnk$gw_imgblks = .lnk$gw_imgblks +		    ! ADD CURRENT I-SECTS
					     .curhdrisd [isd$w_pagcnt] ;    ! INTO IMAGE BINARY TOTAL
			    newhdrisd [isd$v_vpg] = .curhdrisd [isd$v_vpg]  ! VIRTUAL ADDRESS OF
					          + .curhdrisd [isd$w_pagcnt] ; ! BEYOND CURRENT
			    lnk$gw_nisects = .lnk$gw_nisects + 1 ;	    ! COUNT NEW IMAGE SECTION

			    if .emptydesc [1] gequ .lnk$gl_curisd [isl$l_bufend]   ! IF EMPTY REGION IS
			    then 						   ! ALL THAT REMAINS
				begin					           ! 
				lnk$gl_curisd [isl$l_bufend] = .emptydesc [0] -1 ; ! ADJUST END OF CURRENT
				previsd = .newisd ;				   ! BUFFER AND NEW 
				exitloop ;					   ! BECOMES PREVIOUS
				end
			    else 
				begin					! NOW GENERATE AN ISD FOR REMNANT
				previsd = .newisd ;			! SAVING NEW AS THE PREVIOUS
				lnk$alloblk(isd$c_size,newisd) ;	! ALLOCATE THE DESCRIPTOR
				newisd [isl$l_nxtisd] = .previsd [isl$l_nxtisd] ;	! TO POINT
				previsd [isl$l_nxtisd] = .newisd ;	! FORWARD AND POINTED TO
				lnk$gw_nisects = .lnk$gw_nisects + 1 ;	! COUNT NEW IMAGE SECTION
				newisd [isl$l_cludsc] = .lnk$gl_curclu ;! SET CLUSTER DESCRIPTOR POINTER
				newisd [isl$l_bufadr] = .emptydesc [1] ;! BUFFER IS BEYOND EMPTY
				newisd [isl$l_bufend] = 		! REGION TO END
					.lnk$gl_curisd [isl$l_bufend] ;	! OF REMNANT
				newhdrisd = newisd [isl$t_hdrisd] ;	! NAME THE HEADER PART
				ch$move (.curhdrisd [isd$w_size],	! COPY THE CURRENT ISD
						curhdrisd,.newhdrisd) ;	! TO THE NEW NE
				newhdrisd [isd$w_pagcnt] = 
						(.newisd [isl$l_bufend] ! PAGE COUNT IS AT
						-.newisd [isl$l_bufadr]	! MOST THE REMNANT
						+ 511)/512 ;		! BUFFER SIZE
				newhdrisd [isd$v_vpg] = 		! VIRTUAL ADDR IS PAGE BEYOND
						.curhdrisd [isd$v_vpg]	! THE EMPTY REGIONS
						+ (.newisd [isl$l_bufadr] 
						- .lnk$gl_curisd [isl$l_bufadr]
						  )/512 ;		
				lnk$gl_curisd [isl$l_bufend] = .emptydesc [0] - 1 ; ! CURRENT BUFFER BEFORE
				lnk$gl_curisd = .newisd ;		! AND CREATE A NEW CURRENT ISD
				if .curhdrisd [isd$v_protect]		! PROTECT THE ISECT?
				then newhdrisd [isd$v_protect] = true ; ! 
				end ;					! THE EMPTY REGION
			     end ;
		    	 end ;
		    end
		until  .emptydesc [1] eql 0 ;
		end ;
	    end ;
	end ;
     end ;
!
!	ALLOCATE A TABLE TO HOLD ISECT DESCRIPTOR ADDRESSES, AND FILL IT
!	IN.  THEN SORT THE LIST INTO ASCENDING VPN ORDER.
!
if .lnk$gl_shradr neq 0   and  .lnk$gl_fixisd eql 0		! CREATE FIXUP ISD IF NEEDED
then lnk$crefixisd () ;

if  .lnk$gw_nisects neq 0
then lnk$alloblk (.lnk$gw_nisects*4, isdlist)			! ALLOCATE SPACE FOR ISECT LIST
else isdlist = 0 ;						! (we won't fill-up this list if
								! shareable non-based image)
if  .lnk$gw_shriscts neq 0 
then lnk$alloblk (.lnk$gw_shriscts*4, shrisdlist)		! AND FOR THE SHAREABLE ISECT LIST
else shrisdlist = 0 ;

if  .lnk$gw_nclusters neq 0
then lnk$alloblk (.lnk$gw_nclusters*4, shrclulst)		! AND THE SHAREABLE CLUSTER LIST
else shrclulst = 0 ;

if  .lnk$gl_shradr neq 0
then lnk$alloblk (.lnk$gl_shradr*4, adrclulst)			! AND THE .ADDRESS CLUSTER REF LIST
else adrclulst = 0 ;

lnk$gl_curclu = lnk$gl_clulst ;
shrclunum     = shrisdnum = adrclunum = isdnum = 0 ;

while (lnk$gl_curclu = .lnk$gl_curclu [clu$l_nxtclu]) neq 0
do  begin	
    if .lnk$gl_curclu [clu$v_shrimg]				! IF CLUSTER IS A SHAREABLE IMAGE
    then begin
	 shrclulst [.shrclunum] = .lnk$gl_curclu ;		! SAVE CLUSTER ADDRESS IN LIST
	 shrclunum = .shrclunum + 1 ;
	 firstisd  = .lnk$gl_curclu [clu$l_fstisd] ;		! GET POINTER TO FIRST ISECT DESCRIPTOR
	 firstisd  = firstisd [isl$t_hdrisd] ;			! POINT TO PART BOUND FOR HEADER
	 end ;

    if not .lnk$gl_curclu [clu$v_shrimg]			! IF NOT SHAREABLE IMAGE CLUSTER
    and    .lnk$gl_curclu [clu$l_adrcnt] neq 0			!  AND IT HAS .ADDRESS REFERENCES TO IT
    then begin
	 adrclulst [.adrclunum] = .lnk$gl_curclu ;		! SET ADDRESS INTO LIST
	 adrclunum 	        = .adrclunum + 1 ;
	 end ;

    previsd = lnk$gl_curclu [clu$l_fstisd] ;			! POINT TO ISD LIST THIS CLUSTER
    while (previsd = .previsd [isl$l_nxtisd]) neq 0		! AND RUN THRU THEM ALL
    do  begin
	bind isdhdr = previsd [isl$t_hdrisd] : block [,byte] ;	! NAME PART BOUND FOR HEADER
	if  .isdhdr [isd$w_pagcnt] neq 0			! ONLY PUT ISECTS WITH MEMORY ALLOCATED
	then begin
	     if not (.lnk$gl_curclu [clu$v_shrimg]		! IF NOT A NON-BASED SHR IMG
		      and not 
		     .lnk$gl_curclu [clu$v_based]
		     )
	     then begin						! CLUSTER IS EITHER LOCAL OR BASED 
		  isdlist [.isdnum] = .previsd ;		! SHAREABLE IMAGE -- INSERT INTO THE 
		  isdnum 	    = .isdnum + 1 ;		! LIST
		  end
	     else begin						! IT IS A  NON-BASED SHAREABLE IMAGE
		  shrisdlist [.shrisdnum] = .previsd ;
		  shrisdnum 		  = .shrisdnum + 1 ;
		  if not .lnk$gl_curclu [clu$v_copy]		! UNLESS TAKING A PRIVATE COPY OF THIS 
		  then	begin					! IMAGE
			if      .isdhdr [isd$v_wrt]		! IF THIS IS A WRITEABLE NON-CRF SECTION
			and not .isdhdr [isd$v_crf]		!  (I.E. SHAREABLE WRITEABLE)
			then firstisd [isd$v_wrt] = true ;	!  THEN FLAG IN SECTION THAT WILL GO INTO 
			exitloop ;				! ALL DONE WITH ISECTS IN THIS 
			end ;					! PIC SHR IMG CLUSTER
		  end ;
	     end ;
	end ;
    end ;

if  .lnk$gl_shradr neq 0
or (.lnk$gl_fixisd neq 0 and not .lnk$gl_ctlmsk [lnk$v_sys])
then 
    lnk$createfix (.shrclunum,.shrclulst,.adrclunum,.adrclulst) ;! CREATE THE FIXUP SECTION IF NECESSARY

lnk$sortisects (.isdnum, .isdlist) ;				! SORT ISECTS FOR BASED AND LOCAL SECTIONS

if not .lnk$gl_ctlmsk [lnk$v_sys]				! IF  NOT A SYSTEM IMAGE
or     .lnk$gl_ctlmsk [lnk$v_sysheadr]				!  OR A SYSTEM IMAGE WITH A HEADER
then
    begin
    local status ;

    if .isdnum    neq 0 then inchdrsize (.isdnum, .isdlist) ;		! COUNT ISD'S INTO IMAGE HEADER
    if .shrisdnum neq 0 then inchdrsize (.shrisdnum, .shrisdlist) ; 	!  FOR SHAREABLE IMAGE ISD'S ALSO
    inchdrsize (1, %REF (0) );						! NULL ISD TERMINATES THE LIST
    if (status = lnk$requestmem (.lnk$gw_hdrblks+1, header_desc))	! GET SOME MEMORY FOR THE HEADER
    then								! (plus 1 for page aligning)
	begin
	header_desc [0] = (.header_desc [0] + 511) and not 511 ;		    ! PAGE ALIGN THE HEADER
	header_ptr      = ch$fill (0, ihd$k_maxlength, .header_desc [0]) ;	    ! ZERO FILL FIXED PORTION
	header_size     = ihd$k_maxlength ;					    ! RESET HEADER SIZE
	ch$fill (hdr$k_fillchr, (512*.lnk$gw_hdrblks - ihd$k_maxlength), .header_ptr) ;! FILL THE REMAINDER
	end 									    ! WITH FILL CHARACTER
    else
	begin							! BUT ON FAILURE
	signal (.status, 0, lin$_noimgfil) ;			! REPORT THE ERROR
	lnk$gl_ctlmsk [lnk$v_image] = false ;			! DISABLE IMAGE PRODUCTION
	return ;						! AND QUIT
        end ;

    lnk$gw_dstblks = (.lnk$gl_dstend + 511)/512 ;		! COMPUTE THE NUMBER OF BLOCKS
    end ;
!
! OPEN THE IMAGE FILE
!
if .lnk$gl_dmtbytes neq 0
then dmtblks = ((.lnk$gl_dmtbytes or 511) + 1 ) / 512  ;

fileblks = .lnk$gw_hdrblks + .lnk$gw_imgblks + 			! COMPUTE THE FILE SIZE
	   .lnk$gw_dstblks + .dmtblks ;

if  .lnk$gl_ctlmsk [lnk$v_dbg]					! IF A DEBUGGABLE EXECUTABLE IMAGE
or  .lnk$gl_ctlmsk [lnk$v_shr]					! OR A SHAREABLE IMAGE MAKE INITIAL 
then fileblks = .fileblks + (.lnk$gw_lsymbols + 39)/20 ;	! ALLOCATION  LARGER FOR THE SYMBOL TABLE

$fab_init	(fab = imagefab
		,fac = (bro,get)
		,mrs = 512
		,rfm = fix
		,alq = .fileblks
		,fns = .lnk$gl_imgfil [fdb$w_usrnamlen]
		,fna = .lnk$gl_imgfil [fdb$l_usrnamadr]
		,dns = (if .lnk$gb_locnov_exe 
			then %charcount ('.EXE')
			else %charcount ('SYS$DISK:[].EXE')
		       )
		,dna = (if .lnk$gb_locnov_exe 
			then uplit (byte ('.EXE'))
			else uplit (byte ('SYS$DISK:[].EXE'))
		       )
		,nam = auxfnb
		) ;

if  .lnk$gb_locnov_exe 						! USE 'OUTPUT FILE PARSING' UNLESS
then imagefab [fab$v_ofp] = false				! /EXE WAS A LOCAL QUALIFIER
else imagefab [fab$v_ofp] = true ;				! WITH A SPECIFED VALUE

if .lnk$gl_ctlmsk [lnk$v_contig]				! IF USER SAID CONTIGUOUS THEN
then imagefab [fab$v_ctg] = true				! ATTEMPT TO DO IT, OTHERWISE
else imagefab [fab$v_cbt] = true ;				! AS CONTIGUOUS A FILE AS POSSIBLE

lnk$al_imgrab [rab$l_fab] = imagefab ;				! AND POINT THE RAB AT THIS FAB

if not ($getjpi (itmlst=lnk$gt_jpilst) ;
	if .lnk$gl_filesleft leq 3
	then lnk$closefile () ;					!  THEN CLOSE  A FILE
	errorcode = $create (fab=imagefab) ;			!  AND TRY AGAIN
	rmsstv    = .imagefab [fab$l_stv] ;
	.errorcode
       )
or not (errorcode = $connect (rab=lnk$al_imgrab) ;		! CONNECT A STREAM
	rmsstv    = .lnk$al_imgrab [rab$l_stv] ;	
	.errorcode
       )
then begin							! AND IF THERE IS AN ERROR
     signal (lin$_openout,1, lnk$filnamdsc(imagefab)		! THEN REPORT IT
	    ,.errorcode,.rmsstv					! THEN THE RMS STATUS
	    ) ;	
     lnk$gl_ctlmsk [lnk$v_image] = false ;			! TURN OFF IMAGE PRODUCTION
     return ;							! THEN GIVE UP
     end ;

ch$move (dsc$c_s_bln, lnk$filnamdsc (imagefab)			! SET UP REAL FILE NAME DESCRIPTOR
	,lnk$gl_imgfil [fdb$q_filename]
	) ;
lnk$gw_imgifi = .imagefab [fab$w_ifi] ;				! SAVE THE INTERNAL ID FOR CLOSE LATER

curvbn        = 1 + .lnk$gw_hdrblks ;				! FIRST I-SECTION STARTS AFTER HEADER

writeisects (.isdnum, .isdlist) ;				! WRITE OUT LOCAL AND BASED ISECTS
writeisects (.shrisdnum, .shrisdlist) ;				! WRITE OUT PIC SHAREABLE ISECTS

if .lnk$gw_hdrblks neq 0					! IF IMAGE HAS A HEADER
then  isdtoheader (0) ;						! THEN ENTER TERMINATING ISD

if  .dstbuffer [0] neq 0					! IF A DST BUFFER IS ALLOCATED
and .lnk$gw_dstblks neq 0					! AND DST WAS WRITTEN
then begin
     lnk$gw_dstvbn = .curvbn ;					! RECORD THE VBN OF IT
     if not writesection (.lnk$gw_dstblks,.curvbn,.dstbuffer [0]) ! AND OUTPUT THE BLOCKS
     then return ;
     curvbn = .curvbn + .lnk$gw_dstblks ;			! SET NEXT VBN
     end ;

if  .lnk$gl_dmtbuffer [0] neq 0					! IF A DMT BUFFER IS ALLOCATED
and .dmtblks neq 0						!   AND DMT DATA WAS WRITTEN
then begin
     dmtvbn = .curvbn ;						! RECORD VBN 
     if not writesection (.dmtblks,.curvbn,.lnk$gl_dmtbuffer [0]) ! AND OUTPUT THE BLOCKS
     then return ;
     curvbn = .curvbn + .dmtblks ;				! UPDATE VBN
     end ;

! Now, if we are producing a shareable image that has no image data, then
!	we have to adjust the end-of-file to prepare for the correct
!	placement of the symbol table
!
if .lnk$gl_ctlmsk [lnk$v_shr]
	and
   .lnk$gw_imgblks eql 0
then
    if not writesection(.lnk$gw_hdrblks, 1, .header_desc [0])
    then 
	return;


if .lnk$gl_ctlmsk [lnk$v_shr]					! IF PRODUCING A SHAREABLE
or .lnk$gl_ctlmsk [lnk$v_dbg]					! OR DEBUGGABLE IMAGE
then begin	
     $disconnect (rab = lnk$al_imgrab) ;			! DISCONNECT THE RAB
     lnk$gw_gstvbn = .curvbn ;					! SET THE VBN OF THE GST
     end ;

								! AND WILL CLOSE IT AFTER SYMBOLS
return ;							! AND HEADER ARE WRITTEN
end ;

routine inchdrsize (numisds, isd_list) : novalue =
!
!	THIS ROUTINE RUNS THROUGH THE ISD'S IN THE LIST AND
!	ADDS THEIR HEADER SIZE CONTRIBUTION UP.  THIS ROUTINE
!	MUST BE CALLED AFTER THE ISD'S HAVE BEEN SORTED.
!
!	THIS ROUTINE IS CALLED WITH isdlist POINTING TO A
!	LONGWORD OF ZERO WITH numisds=1 TO TERMINATE THE 
!	ENTIRE SEQUENCE OF ISD's.
!
begin
map
	isd_list	: ref vector [,long];
own
	bytes_in_block	: initial (first_block_size) ;
local
	isd_size,
	isd		: ref block [,byte],
	hdrisd		: ref block [,byte];

incru i from 0 to .numisds-1				! PROCESS LIST OF ISD's
do begin
   isd    = .isd_list [.i];
   hdrisd =  isd [isl$t_hdrisd];

   isd_size = 	(if .isd eql 0 				! IF ZERO THEN TERMINATING ISD
		 then  hdr$k_minfill
		 else .hdrisd [isd$w_size]
		);
   if .bytes_in_block lssu (.header_size + .isd_size)	! IF THIS ISD WILL NOT FIT WITHIN
   then begin						! THE CURRENT HEADER BLOCK
	lnk$gw_hdrblks	= .lnk$gw_hdrblks + 1;		! INCREMENT THE BLOCK COUNT
	header_size	=  0;				! INITIALIZE HEADER_SIZE THIS BLOCK
	bytes_in_block  =  subseq_block_size;		! RESET USEABLE BYTES
	end;

   header_size = .header_size + .isd_size;		! ADD TO THE CURRENT BLOCK SIZE
   end;

if .isd_list [0] eql 0					! IF TERMINATING ISD, ACCOUNT FOR
then lnk$gw_hdrblks = .lnk$gw_hdrblks + 1 ;		! THIS, THE LAST, HEADER BLOCK

return;
end;

routine isdtoheader (isd) : novalue =
!
!	THIS ROUTINE COPIES IMAGE SECTION DESCRIPTORS TO THE
!	IMAGE HEADER AND ENSURES THAT THE UNUSED PART OF EACH
!	BLOCK IS -1 FILLED (I.E. VALUE OF HDR$K_FILLCHR). IF THE
!	ARGUMENT IS 0, IT IS ASSUMED THAT THIS IS THE END OF THE
!	ISD LIST FOR THE HEADER.
!
begin
map	
	isd : ref block [,byte];				! ARGUMENT IS A POINTER
own
	bytes_in_block	: initial (first_block_size) ;		! FIRST BLOCK HAS 2 BYTES RESERVED
local
	isd_size;

isd_size    =	(if .isd eql 0 					! IF TERMINATING (NULL) ISD
		 then  hdr$k_minfill				! USE FILL SIZE
		 else .isd [isd$w_size]				! ELSE USE ACTUAL SIZE
		);
if .bytes_in_block lssu (.header_size + .isd_size)		! IF THIS ISD WILL NOT FIT
then begin							! DESCRIPTOR IN THE CURRENT BLOCK
     header_ptr     =  (.header_ptr + 511) and not 511;		! THEN ADVANCE TO NEXT BLOCK
     header_size    =  0;					! RESET SIZE OF THIS BLOCK
     bytes_in_block =  subseq_block_size;			! RESET USEABLE BYTES
     end;

header_size = .header_size + .isd_size;				! UPDATE HEADER SIZE
header_ptr  = (	if  .isd neq 0					! IF THIS ISN'T THE END OF IT
		then ch$move (.isd_size, .isd, .header_ptr)	! JUST COPY IT IN
		else begin					! OTHERWIZE...
		     if .lnk$gl_ctlmsk [lnk$v_cli]		! IF IMAGE IS CLI, 
		     then (.header_desc [0] + 510)<0,16> = 3;	! THEN TELL IMAGE ACTIVATOR HERE
		     ch$fill (0, .isd_size, .header_ptr)	! INSERT MINIMUM ISD OF 0 (END OF LIST)
		     end
	      );
return;
end;

routine writeisects (numisects, isd_list) =
!
! THIS ROUTINE WRITES OUT THE SPECIFIED NUMBER OF IMAGE SECTIONS TO
! THE IMAGE FILE.  ISDLIST IS A LIST OF THE ADDRESSES OF THE ISD'S
! TO WRITE
!
begin
map
    isd_list : ref vector [,long];

if  .numisects neq 0
then incru isdnum from 0 to .numisects- 1			! LOOP THRU ALL IN LIST
do begin
   lnk$gl_curisd = .isd_list [.isdnum];				! POINT TO ISECT DESCRIPTOR
	begin
	bind curhdrisd = lnk$gl_curisd [isl$t_hdrisd] 		! NAME PART FOR HEADER
						: block [,byte];
	lnk$gl_curclu = .lnk$gl_curisd [isl$l_cludsc];		! SET CLUSTER DESCRIPTOR ADDRESS

	if  .curhdrisd [isd$v_gbl]				! IF A GLOBAL SECTION
	and .lnk$gl_curisd [isl$l_bufadr] neq 0			! WITH A BUFFER ALLOCATED
	then readsection ();					! GO READ IT FROM ITS FILE

	if not .curhdrisd [isd$v_dzro]				! IF NOT A DEMAND ZERO SECTION
	and    .lnk$gl_curisd [isl$l_bufadr] neq 0		! AND A BUFFER IS ALLOCATED
	then curhdrisd [isd$l_vbn] = .curvbn;			! INSERT THE VBN OF BINARY

	if  (if   .lnk$gl_ctlmsk [lnk$v_sys]			! IF A SYSTEM IMAGE WITH A HEADER
	     then .lnk$gl_ctlmsk [lnk$v_sysheadr]		! ...
	     else true						! OR A REGULAR IAMGE
	    )
!?	if  .lnk$gw_hdrblks neq 0				! IF IMAGE HAS A HEADER
	and .curhdrisd [isd$w_pagcnt] neq 0			! AND SECTION IS NON ZERO IN LENGTH
	then isdtoheader (curhdrisd);				! INSERT ISD IN HEADER

	if not .curhdrisd [isd$v_dzro]				! IF NOT A DEMAND ZERO SECTION
	and    .lnk$gl_curisd [isl$l_bufadr] neq 0		! AND A BUFFER IS ALLOCATED
	then begin
	     if not writesection (.curhdrisd [isd$w_pagcnt]	! THEN WRITE IT OUT
				 ,.curvbn
				 ,.lnk$gl_curisd [isl$l_bufadr]	! TO THE FILE
				 )
	     then return false;					! GIVING UP ON ERROR
	     curvbn = .curvbn + .curhdrisd [isd$w_pagcnt];	! UPDATE TO NEXT AVAILABLE VBN
	     end;
	end;
    end;
return true
end;

global routine lnk$getfixsize =
begin
!
! THIS ROOUTINE COMPUTES AND RETURNS AS A VALUE THE SIZE (IN PAGES)
! REQUIRED FOR THE FIXUP SECTION
!

return ((((.lnk$gl_shrimgs*2)+(.lnk$gl_shrsyms+1)		! NUMBER OF SHR IMGS REFERENCED 
		+.lnk$gl_spcgfix				! PLUS NUMBER OF SPECIAL G^ FIXUPS
		+(.lnk$gl_shradr*2)+(.lnk$gl_adrefs+1))*4)	! PLUS THE SIZE FOR THE .ADDR FIXUPS
		+(.lnk$gl_shrclstrs+1)*shl$c_length		! PLUS THE SIZE OF THE SHL LIST
		+(.lnk$gl_shlextra*shl$c_length)		! PLUS ANY EXTRA SHL'S REQUESTED
		+(.lnk$gl_rprotisd+1)*icp$c_length+4		! PLUS THE SIZE OF THE FIXUP INFO
		+iaf$c_length+511)/512				! PLUS THE FIXED PART, ALL ROUNDED UP TO NEXT PAGE BOUNDARY
end;

routine storespcgfix (node,travinfo) =
begin
!
! THIS ROUTINE IS CALLED BY THE TRAVERSE_TREE ROUTINE FOR EACH
! ELEMENT IN THE TREE.
!
! INPUTS:
!
!	NODE		ADDRESS OF CURRENT NODE
!	TRAVINFO	ADDRESS OF INFO SET UP BY LNK$CREATEFIX
!
map
    node : ref block[,byte],
    travinfo : ref vector[,long];

bind
    bufloc = .travinfo[0] + (.node[spcr$l_fixadr] - .travinfo[1]),
    storeaddr = bufloc : vector[,long];

storeaddr[0] = .node[spcr$l_offset];
return true
end;

routine lnk$createfix (shrclunum,clusterlist,adrclunum,adrclulst) =
!
! THIS ROUTINE ALLOCATES BUFFER SPACE AND FILLS IN THE
! FIXUP IMAGE SECTION FOR COMMUNICATION WITH THE IMAGE
! ACTIVATOR.
!
! INPUTS:
!
!	SHRCLUNUM	NUMBER OF ITEMS IN CLUSTERLIST
!	CLUSTERLIST	ADDRESS OF LIST OF CLUSTER DESCRIPTOR ADDRESSES OF SHAREABLE IMAGES
!	ADRCLUNUM	NUMBER OF ITEMS IN ADRCLULST
!	ADRCLULST	ADDRESS OF LIST OF CLUSTER DESCRIPTOR ADDRESSES OF NON-SHR IMAGE CLUSTERS 
!			 REFERENCED VIA .ADDRESS
!
begin
map
    clusterlist		: ref vector [,long],
    adrclulst 		: ref vector [,long] ;
local
    status,
    clusterindex,
    fixsize,
    fixbuf 		: ref block [,byte],
    symbolblock 	: ref block [,byte],
    adrblock 		: ref vector [,long],
    shrnamlist 		: ref block [,byte],
    shrimgindex,
    curisd 		: ref block [,byte],
    curhdrisd 		: ref block [,byte],
    spcgfixvec 		: ref vector [,long],
    travinfo 		: vector [2,long],			! INFO FOR ACTION ROUTINE OF TREE TRAVERSAL
    reprotvec 		: ref block [,byte],
    extadrvec 		: ref vector [,long],
    extindex,
    fixisdhdr 		: ref block [,byte],
    dotadrvec 		: ref vector [,long],
    dotadrindex	;

fixisdhdr = lnk$gl_fixisd [isl$t_hdrisd] ;			! POINT TO PART BOUND FOR IMAGE HEADER

if .lnk$gl_ctlmsk [lnk$v_protect]				! IF /PROTECT
then fixisdhdr [isd$v_protect] = true ;				! THEN PROTECT SECTION

fixisdhdr [isd$v_fixupvec] = true ;				! DECLARE ISD TO BE FIXUP VECTOR SECTION
fixsize 		   = lnk$getfixsize () ;		! GET SIZE OF FIXUP SECTION NEEDED
fixisdhdr [isd$w_pagcnt]   = .fixsize ;				! SET NUMBER OF PAGES INTO ISD
status = lnk$requestmem (.fixsize, lnk$gl_fixisd [isl$l_bufadr]); ! ALLOCATE SPACE FOR SECTION
if not .status
then begin							! BUT IF IT FAILS, ISSUE AN ERROR MESSAGE
     signal (.status, 0, lin$_noimgfil) ;
     lnk$gl_ctlmsk [lnk$v_image] = false ;
     return true
     end ;
!
! ALLOCATE VIRTUAL MEMORY FOR FIXUP SECTION.  THIS IS DONE TO ENSURE THAT
! WE DID NOT BASE THE WORLD DURING PASS 2 AND PUT A SHAREABLE IMAGE WHERE
! WE THOUGHT THE FIXUP SECTION WAS GOING TO GO
!
if not .lnk$gl_fixisd [isl$v_memalo]
then begin
     if not lnk$allovirmem (.fixisdhdr [isd$v_vpn]^9,.fixisdhdr [isd$w_pagcnt])
     then begin
	  signal (lin$_confixmem,1,lnk$gl_imgfil [fdb$q_filename],lin$_noimgfil) ;
	  lnk$gl_ctlmsk [lnk$v_image] = false ;
	  return true
	  end ;
     lnk$gl_fixisd [isl$v_memalo] = true ;
     end ;

fixbuf       = .lnk$gl_fixisd [isl$l_bufadr] ;
travinfo [0] = .fixbuf ;					! SET INFO FOR TREE TRAVERSAL
travinfo [1] = .fixisdhdr [isd$v_vpn] ^ 9 ;

fixbuf [iaf$l_iaflink]   =  0 ;					! ZERO IMAGE ACTIVATOR LINK
fixbuf [iaf$w_size]      =  iaf$c_length ;			! SET SIZE OF FIXED PART OF FIXUP ISD HEADER
fixbuf [iaf$v_shr]       = .lnk$gl_ctlmsk [lnk$v_shr] ;		! SET FLAGS
fixbuf [iaf$l_shlextra]  = .lnk$gl_shlextra ;			! SET COUNT OF EXTRA SHL SLOTS
fixbuf [iaf$l_shrimgcnt] = .lnk$gl_shrclstrs + 1 ;		! SET COUNT OF SHAREABLE IMAGES 
								!  (+1 FOR CURRENT IMAGE)

extadrvec  = .fixbuf + iaf$c_length ;				! SET ADDRESS OF START OF G^ VECTOR
spcgfixvec = .extadrvec + 					! SET ADDRESS OF SPECIAL G^ FIXUP VECTOR
	      ((.lnk$gl_shrimgs*2)+(.lnk$gl_shrsyms+1))*4 ;

if .lnk$gl_spcgfix neq 0					! IF THERE ARE SPECIAL G^ FIXUPS
then reprotvec = (.lnk$gl_lastgadr - .travinfo [1]) + .fixbuf	!  THEN SET REPROT VEC AFTER THAT
else reprotvec = .spcgfixvec ;					!  OTHERWISE RIGHT ON IT

shrnamlist = .reprotvec + (.lnk$gl_rprotisd+1)*icp$c_length + 4 ;  ! SET ADDRESS OF SHR IMG NAME LIST
dotadrvec  = .shrnamlist + 					   ! SET ADDRESS OF .ADDR VECTOR
	      (.lnk$gl_shrclstrs+1+.lnk$gl_shlextra)*shl$c_length ;

!
! SET OFFSETS TO THE SEGMENTS INTO THE FIXUP ISECT HEADER
!
fixbuf [iaf$l_chgprtoff] = .reprotvec - .fixbuf ;		! SET OFFSET TO CHANGE PROTECTION DATA

if .lnk$gl_shrsyms neq 0					! IF THERE ARE G^ FIXUPS
then fixbuf [iaf$l_g_fixoff] = .extadrvec - .fixbuf		! THEN CALCULATE OFFSET
else fixbuf [iaf$l_g_fixoff] = 0 ;				! OTHERWISE GUARANTEE A 0

if .lnk$gl_adrefs neq 0						! IF THERE ARE .ADDR FIXUPS
then fixbuf [iaf$l_dotadroff] = .dotadrvec - .fixbuf		! THEN CALCULATE OFFSET
else fixbuf [iaf$l_dotadroff] = 0 ;				! OTHERWISE GUARANTEE A 0

fixbuf [iaf$l_shlstoff] = .shrnamlist - .fixbuf ;		! CALCULATE OFFSET TO SHR IMG NAME LIST
dotadrindex = shrimgindex =  extindex = 0 ;			! INIT INDICES INTO THE VECTORS

!
! SET REPROTECTION DATA FOR FIXUP SECTION
!
.reprotvec = .lnk$gl_rprotisd + 1 ;
reprotvec  = .reprotvec + 4 ;
reprotvec [icp$l_baseva] = .fixisdhdr [isd$v_vpn]^9 - .lnk$gl_minva ;	! SET BASE ADDRESS
reprotvec [icp$w_npages] = .fixsize ;
reprotvec [icp$w_newprt] = prt$c_urew ;
reprotvec = .reprotvec + icp$c_length ;

!
! LOOP THROUGH THE LOCAL CLUSTERS AND DO THE IMAGE 0 .ADDRESS REFERENCES
!
if .adrclunum neq 0							! IF THERE ARE ANY .ADDR CLUSTER REFS
then begin
     dotadrvec [0] = 0 ;						! INITIALIZE THE FIXUP COUNT
     dotadrvec [1] = 0 ;						! THE IMAGE IS NUMBER 0
     dotadrindex   = 2 ;						! SKIP THE IMAGE NUMBER AND COUNT OF ITEMS
     incru clusterindex from 0 to .adrclunum-1				! LOOP THROUGH THE LIST
     do begin
	lnk$gl_curclu = .adrclulst [.clusterindex] ;			! PICK UP CURRENT CLUSTER
	dotadrvec [0] = .dotadrvec [0] + .lnk$gl_curclu [clu$l_adrcnt] ; ! INCREMENT COUNT OF REFERENCES
	adrblock      = lnk$gl_curclu [clu$l_fstadrl] ;			! GET THE LISTHEAD OF ADDRESS BLOCKS
	while (adrblock = .adrblock [0]) neq 0				! LOOP THROUGH ALL THE ADDRESS BLOCKS
	do  begin
	    bind adrcnt = (if .adrblock neq .lnk$gl_curclu [clu$l_lstadrl]	! COMPUTE COUNT OF 
			   then clu$c_adrblock - 1				! ELEMENTS IN THIS BLOCK
			   else clu$c_adrblock - .lnk$gl_curclu [clu$l_adrleft] - 1
			   ) ;
	    incru i from 1 to adrcnt						! LOOP THROUGH THIS BLOCK
	    do 	begin
		dotadrvec [.dotadrindex] = .adrblock [.i] - .lnk$gl_minva ;	! STORE PC IN NEXT LOCATION
		dotadrindex = .dotadrindex + 1 ;				! MOVE TO NEXT LOCATION
	        end
	    end ;
	end
     end ;

!
! FIND ALL ISECTS THAT NEED TO BE REPROTECTED IN THE LOCAL CLUSTERS.  IF THE
! CLUSTER IS A SHAREABLE IMAGE AND CONTAINS SPECIAL G^ FIXUPS, DO THOSE NOW.
!
lnk$gl_curclu = lnk$gl_clulst ;						! POINT TO START OF CLUSTER LIST
while (lnk$gl_curclu = .lnk$gl_curclu [clu$l_nxtclu]) neq 0		! LOOK AT ALL CLUSTERS
do  if not .lnk$gl_curclu [clu$v_shrimg]				!  BUT IGNORE SHAREABLE IMAGES
    then begin
	 curisd = lnk$gl_curclu [clu$l_fstisd] ;			! POINT TO LISTHEAD
	 while (curisd = .curisd [isl$l_nxtisd]) neq 0			! LOOP THROUGH ALL ISECTS THIS CLUSTER
	 do if .curisd [isl$v_reprot]					! IF THIS SECTION NEEDS TO BE REPROTECTED	
	    then begin
		 curhdrisd = curisd [isl$t_hdrisd] ;			! POINT TO HEADER PART
		 reprotvec [icp$l_baseva] = .curhdrisd [isd$v_vpn]^9	! SET BASE VA OF ISECT
					    - .lnk$gl_minva ;
		 reprotvec [icp$w_npages] = .curhdrisd [isd$w_pagcnt] ;	! AND NUMBER OF PAGES
		 reprotvec [icp$w_newprt] = .curisd [isl$b_newprt] ;	! COPY NEW PROTECTION
		 reprotvec = .reprotvec + icp$c_length ;		! POINT TO NEXT SLOT
		 end ;
	 end
    else if .lnk$gl_curclu [clu$l_spcrlst] neq 0			! SHR IMG--IF IT CONTAINS SPECIAL G^ FIXUPS
	 then lib$traverse_tree (lnk$gl_curclu [clu$l_spcrlst]
				,storespcgfix				!  THEN TRAVERSE THE TREE AND STORE THE INFO
				,travinfo
				) ;

!
! NOW LOOP THROUGH THE CLUSTERS AND STORE THE INFORMATION
!
shrnamlist [shl$b_shl_size] = shl$c_length;			! Fill in length of first SHL$ entry...
shrnamlist 		    = .shrnamlist + shl$c_length ;	! LEAVE ROOM FOR IMAGE 0 (CURRENT IMAGE)
if .shrclunum neq 0					
then incru clusterindex from 0 to .shrclunum-1			! FOR ALL SHAREABLE IMAGES
     do	begin
	lnk$gl_curclu = .clusterlist [.clusterindex] ;		! GET CLUSTER DESCRIPTOR ADDRESS
	ch$copy (.lnk$gl_curclu [clu$b_namlng]+1		! COPY THE SHAREABLE IMAGE NAME 
		,lnk$gl_curclu [clu$b_namlng],0			! INTO THE SHR IMG LIST
		,shl$c_maxnamlng+1
		,shrnamlist [shl$t_imgnam]
		) ;
	shrnamlist  = .shrnamlist + shl$c_length ;		! NEXT SHR IMAGE NAME SLOT
	shrimgindex = .shrimgindex + 1 ;			! NEXT IMAGE INDEX
	if .lnk$gl_curclu [clu$l_shrsyms] neq 0			! IF THERE ARE G^ SYMBOLS IN 
	then begin						! THIS CLUSTER
	     local	last_symbol : initial (0) ;		! POINTER TO LAST SYMBOL (for debbugging)

	     extadrvec [.extindex] = .lnk$gl_curclu [clu$l_shrsyms] ;	! SET NUMBER OF REFERENCES
	     extindex 		   = .extindex + 1 ;			! NEXT LOCATION
	     extadrvec [.extindex] = .shrimgindex ;			! SET SHR IMAGE INDEX INTO G^ VECTOR
	     extindex 		   = .extindex + 1 ;			! NEXT LOCATION
	     symbolblock 	   = .lnk$gl_curclu [clu$l_shrlst] ;	! GET LIST OF SHR IMG SYMBOLS THIS CLUSTER
	     while .symbolblock neq 0					! LOOP THROUGH THEM AND PUT THE 
	     do	begin							! OFFSETS INTO THE G^ VECTOR
		extadrvec [.extindex] = .symbolblock [sym$l_offset] ;	! STORE OFFSET FOR THIS SYMBOL
		extindex 	      = .extindex + 1 ;			! NEXT G^ VECTOR LOCATION
		last_symbol	      = .symbolblock ;			! REMEMBER LAST BLOCK (for debbugging)
		symbolblock	      = .symbolblock [sym$l_shrlnk] ;	! LINK TO NEXT SYMBOL
		end ;
	     end ;
	!
	! IF THIS CLUSTER HAS .ADDR REFERENCES THEN STORE THEM ALSO
	!
	if .lnk$gl_curclu [clu$l_adrcnt] neq 0
	then begin
	     dotadrvec [.dotadrindex]   = .lnk$gl_curclu [clu$l_adrcnt] ; ! STORE NUMBER OF SUCH REFERENCES
	     dotadrvec [.dotadrindex+1] = .shrimgindex ;		  ! SET SHR IMG INDEX INTO .ADDR VECTOR
	     dotadrindex		= .dotadrindex + 2 ;		  ! INCREMENT THE INDEX
	     adrblock			= lnk$gl_curclu [clu$l_fstadrl] ; ! GET FIRST .ADDR BLOCK FOR THIS CLUSTER
	     while (adrblock = .adrblock [0]) neq 0			  ! LOOP THROUGH ALL .ADDR BLOCKS IN 
	     do	begin							  ! THIS CLUSTER
		bind adrcnt =  (if .adrblock neq .lnk$gl_curclu [clu$l_lstadrl]		! COMPUTE NUMBER 
				then clu$c_adrblock - 1					! OF ENTRIES IN 
				else clu$c_adrblock - .lnk$gl_curclu [clu$l_adrleft] - 1  ! THIS BLOCK
				) ;
		!
		! STORE THE ADDRESSES IN THE .ADDR VECTOR
		!
		incru i from 1 to adrcnt
		do  begin
		    dotadrvec [.dotadrindex] = .adrblock [.i] - .lnk$gl_minva ;
		    dotadrindex = .dotadrindex + 1 ;
		    end ;
		end ;
	     end ;
	end ;

return true
end ;

routine readsection : novalue =
begin
!++
!		THIS ROUTINE COPIES GLOBAL SECTION FROM A SHAREABLE
!	IMAGE TO THE IMAGE BEING PRODUCED. IF THIS IS THE FIRST ENTRY FOR
!	A PARTICULAR CLUSTER THEN THE IMAGE FILE OPEN ON A PREVIUOS 
!	CLUSTER IS CLOSED AND THIS ONE IS OPENED. THE SECTION IS READ
!	INTO A BUFFER WHICH IS DESCRIBED BY THE DESCRIPTOR IN THE
!	IMAGE SECTION DESCRIPTOR.
!--
own
	shrimgifi,				! IFI OF THE SHAREABLE IMAGE FILE
	prevauxfnb : ref block[,byte];		! AUXILIARY FILE NAME BLOCK OF PREVIOUS FILE
!
local
	fablock : block[fab$c_bln,byte],	! FAB FOR OPENING AND CLOSING
	errorcode,				! RMS ERROR CODE
	stvcode,
	bytecount;
!
bind
	shrimgfdb = lnk$gl_curclu[clu$l_fstfdb] : ref block[,byte],
	shrimgauxfnb = shrimgfdb[fdb$t_auxfnb] : block[,byte],
	curhdrisd = lnk$gl_curisd[isl$t_hdrisd] : block[,byte];
!
if .shrimgifi neq 0				! IF A FILE IS POEN
and not .lnk$gl_curclu[clu$v_open]		! AND NOT THIS FILE
then begin
	$fab_init(fab=fablock);				! INITIALIZE THE FAB
	fablock[fab$w_ifi] = .shrimgifi;		! AND THE INTERNAL FILE IDENT
	if not (errorcode = $close(fab=fablock))	! ATTEMPT THE CLOSE
	then begin					! AND ON FAILURE
		signal(lin$_closein,1,shrimgfdb[fdb$q_filename],
				.errorcode,.fablock[fab$l_stv]);
	     end;
	shrimgclu[clu$v_open] = false;			! FLAG FILE NOT OPEN
	shrimgifi = 0;					! RESET THE IFI
     end;
if not .lnk$gl_curclu[clu$v_copy]				! IF THIS CLUSTER IS NOT TO BE COPIED
or (shrimgrab[rab$l_bkt] = .curhdrisd[isd$l_vbn]) eql 0		! IF THIS CLUSTER NOT TO BE COPIED
then begin
	lnk$gl_curisd[isl$l_bufadr] = 0;			! CLEAR THE BUFFER ADDRESS
	curhdrisd[isd$l_vbn] = 0;				! AND THE VBN
	return;						! AND THAT'S ALL
     end;
if not .lnk$gl_curclu[clu$v_open]			! IF THE FILE IS NOT OPEN
then begin
	$fab_init(fab=fablock,				! INITIALIZE THE FAB
		fac=(bio,get),
		fop=nam,
		nam=shrimgauxfnb);
	shrimgrab[rab$l_fab] = fablock;			! SET FAB ADDRESS IN RAB
	shrimgrab[rab$w_isi] = 0;			! RESET STREAM IDENTIFIER
	if not begin
		if not (errorcode = $open(fab=fablock))	! ATTEMPT TO OPEN
		then begin				! THE IMAGE FILE AND
			stvcode = .fablock[fab$l_stv];	! ON FAILURE SET STV
			false				! AND SKIP
		     end
		else true
	       end
	or not begin
		if not (errorcode = $connect(rab=shrimgrab))	! ATTEMPT TO CONNECT RAB
		then begin					! AND ON FAILURE
			stvcode = .shrimgrab[rab$l_stv];	! SET STV CODE
			false					! AND SKIP
		     end
		else true
	         end
	then begin
		signal((lin$_openin and not sts$m_severity) or sts$k_warning,1,shrimgfdb[fdb$q_filename],
				.errorcode,.stvcode);
		lnk$gl_curclu[clu$v_open] = false;			! RESET OPEN FLAG
		curhdrisd[isd$l_vbn] = 0;				! AND THE VBN
		return;
	     end;
	shrimgifi = .fablock[fab$w_ifi];				! SAVE THE IFI
	shrimgclu = .lnk$gl_curclu;					! SAVE CLUSTER DESCRIPTOR
	shrimgclu[clu$v_open] = true;					! FLAG IMAGE FILE OPEN
	prevauxfnb = shrimgauxfnb;					! THIS WILL BE PREVIOUS NEXT TIME
     end;

shrimgrab[rab$l_ubf] = .lnk$gl_curisd[isl$l_bufadr];		! SET BUFFER ADDRESS
bytecount = .curhdrisd[isd$w_pagcnt] * 512;			! AND BYTE COUNT
while .bytecount gtr 0					! BEGIN LOOP
do begin
	shrimgrab[rab$w_usz] = minu(.bytecount,tfrlength);	! SET BYTE COUNT
	if not (errorcode = $read(rab=shrimgrab))		! ATTEMPT NEXT READ
	then begin
		signal(lin$_readerr,1,
			shrimgfdb[fdb$q_filename],
			.errorcode,.shrimgrab[rab$l_stv]);
		lnk$gl_curisd[isl$l_bufadr] = 0;		! RESET BUFFER ADDRESS
		curhdrisd[isd$l_vbn] = 0;			! AND VBN
		return;
	      end;
	bytecount = .bytecount - tfrlength;			! REDUCE THE BYTECOUNT
	shrimgrab[rab$l_ubf] = .shrimgrab[rab$l_ubf] +		! ADJUST BUFFER
				.shrimgrab[rab$w_usz];		! FOR AMOUNT OF READ
	shrimgrab[rab$l_bkt] = 0;
     end;
return;
end;		! OF READSECTION ROUTINE

routine writesection(pages,vbn,buffer) =
begin
local
	bytecount,							! NUMBER OF BYTES OF IMAGE FILE
	errorcode;							! WRITE ERROR CODE RETURNED
!
bind auxfnb = lnk$gl_imgfil[fdb$t_auxfnb] : block[nam$c_bln,byte];	! AUXILIARY FILENAME BLOCK
!
bytecount = .pages * 512;
lnk$al_imgrab[rab$l_bkt] = .vbn;
lnk$al_imgrab[rab$l_rbf] = .buffer;
while .bytecount gtr 0							! LOOP TILL ALL DONE
do begin
	lnk$al_imgrab[rab$w_rsz] = min(.bytecount,tfrlength);		! SET BYTE COUNT FOR THIS WRITE
	if not (errorcode = $write(rab=lnk$al_imgrab))			! AND DO IT
	then begin							! BUT IF AN
		signal(lin$_writeerr,1,lnk$gl_imgfil[fdb$q_filename],	! AND REPORT THE ERROR
			.errorcode,.lnk$al_imgrab[rab$l_stv],lin$_noimgfil);
		lnk$gl_ctlmsk[lnk$v_image] = false;			! MESSAGE
		return false;						! THEN GIVE UP
	     end;
	bytecount = .bytecount - tfrlength;				! REDUCE THE BYTE COUNT
	lnk$al_imgrab[rab$l_rbf] = .lnk$al_imgrab[rab$l_rbf] +		! UPDATE BUFFER POINTER
					.lnk$al_imgrab[rab$w_rsz];	! TO THE NEXT PIECE
	lnk$al_imgrab[rab$l_bkt] = 0;					! FORCE RMS TO USE NEXT BLOCK POINTER
   end;									! AND GO AGAIN
return true;
end;

global routine lnk$wrtimghdr : novalue =
begin
!
! THIS ROUTINE IS CALLED TO WRITE THE IMAGE HEADER. IT FIRST WRITES
! THE HEADER FIXED RECORD INTO THE FIRST HEADER BUFFER BLOCK THEN
! OUTPUTS TO THE (OPEN) IMAGE FILE ALL BLOCKS OF THE IMAGE HEADER
! FINALLY THE IMAGE FILE IS CLOSED.
!
global
    lnk$gl_otsepdsc	: ref block [,byte] ;			! POINTER TO DESCRIPTOR OF OTS ENTRY POINT
!
local
    curtfr,							! ADDRESS IN HEADER FOR NEXT TRANSFER ADDRESS
    otsepnam 		: ref block [,byte],			! POINTER TO OTS EPT NAME BLOCK
    sysver 		: ref block [,byte],			! POINTER TO VALUE PART OF SYS$K_VERSION
    sysvernam 		: ref block [,byte],			! POINTER TO NAME PART OF SYS$K_VERSION
    ihdactiv 		: ref block [,byte] ;			! IMAGE ACTIVATION AREA OF HEADER
!
bind	
    otsentrysym = cstring ('LIB$INITIALIZE'),			! OTS ENTRY POINT NAME
    otsinishr   = cstring ('LIB$IMAGE_INISHR'),			! OTS ENTRY POINT FOR SHARED IMAGES
    imgidarea   = ihdactiv 		: ref block [,byte],	! USE SAME CELL TO POINT TO ID AREA
    symdbgdata  = ihdactiv 		: ref block [,byte],	! AND FOR SYMBOL TABLE AND DEBUG DATA
    imageheader = header_desc [0]	: ref block [,byte],	! POINT TO THE BUFFER
    imageprivs  = imageheader [ihd$q_privreqs]	: vector [2,long] ; 	! POINT TO PRIVILEGES
!
if (.lnk$gl_ctlmsk [lnk$v_sys]					! IF A SYSTEM IMAGE
	and not 
    .lnk$gl_ctlmsk [lnk$v_sysheadr]				!  WITHOUT A HEADER
   )
or  .lnk$gw_hdrblks eql 0					! OR THERE IS NO HEADER
then begin
     lnk$closimgfil () ;					! CLOSE THE IMAGE FILE
     return ;							! AND THAT'S ALL
     end ;

imageheader [ihd$b_hdrblkcnt] = .lnk$gw_hdrblks ;		! INSERT NUMBER OF BLOCKS OF HEADER IN HEADER
imageheader [ihd$w_size]      =  ihd$k_maxlength ;		! SIZE OF HEADER
imageheader [ihd$w_activoff]  =  ihd$k_activoff ;		! OFFSET TO ACTIVATION CONTROL
imageheader [ihd$w_symdbgoff] =  ihd$k_symdbgoff ;		! SYMBOL AND DEBUG DATA
imageheader [ihd$w_imgidoff]  =  ihd$k_imgidoff ;		! THE IDENTIFICATION AREA
imageheader [ihd$b_imgtype]   =  ihd$k_exe ;			! ASSUME EXECUTABLE IMAGE
imageheader [ihd$w_iochancnt] = .lnk$gw_chans ;			! SET NUMBER OF CHANNELS
imageheader [ihd$w_imgiocnt]  = .lnk$gw_ioseg ;			! AND SIZE OF I/O SEGMENT
imageheader [ihd$v_lnkdebug]  = .lnk$gl_ctlmsk [lnk$v_dbg] ;	! AND THE STATE OF DEBUG FLAG
imageheader [ihd$v_picimg]    = .lnk$gl_ctlmsk [lnk$v_picimg] ;	! EXTRACT POSITION DEPENDENCE FLAG
imageheader [ihd$v_nop0bufs]  = .lnk$gl_ctlmsk [lnk$v_nop0bufs] ;  ! AND STATE OF RMS P0 BUFFER INDICATOR
imageheader [ihd$v_matchctl]  = .lnk$gb_matchctl ;		! MATCH CONTROL FLAGS
imageheader [ihd$v_dbgdmt]    =  true ;				! DMT FIELDS ARE PRESENT
imageheader [ihd$l_ident]     = .lnk$gl_matchid ;		! AND THE ASSOCIATED IDENT

imageprivs [0] = .lnk$gq_privs [0] ;				! SET PRIVS INTO HEADER
imageprivs [1] = .lnk$gq_privs [1] ;				! ...


imageheader [ihd$l_sysver] = (if lnk$search (lnk$gt_sysver,sysver,sysvernam)	! LOOK UP SYS$K_VERSION
			      then  .sysver [sym$l_value]	! AND STORE THE VALUE
			      else 0 				! WE REALLY SHOULD ALWAYS FIND IT!
			     ) ;
imageheader [ihd$l_iafva]  = (if .lnk$gl_fixisd neq 0		! IF THERE IS A FIXUP SECTION
			      then begin
				   bind fixhdrisd = lnk$gl_fixisd [isl$t_hdrisd] : block [,byte] ; 
				   .fixhdrisd [isd$v_vpn]^9 		! SET VA OF FIXUP SECTION
				   end
			      else 0 					! ELSE USE 0
			     ) ;
imageheader [ihd$v_p0image] = .lnk$gl_ctlmsk [lnk$v_p0image] ;	! SET P0-ONLY STATUS
ihdactiv = .imageheader + .imageheader [ihd$w_activoff] ;	! POINT TO ACTIVATION AREA
curtfr   = ihdactiv [iha$l_tfradr1] ;				! START AT FIRST TRANSFER ADDRESS

if .lnk$gl_dbgtfps neq 0					!  IF A
then begin							! DEBUGGER TRANSFER
    .curtfr = .lnk$gl_dbgtfr ;					! ADDRESS WAS FOUND
     curtfr = ihdactiv [iha$l_tfradr2] ;			! THEN IT IS FIRST AND UPDATE TO NEXT
     end
else if .lnk$gl_ctlmsk [lnk$v_dbg]				! NO DEBUGGER TRANSFER ADDRESS SO
     then  signal (lin$_dbgtfr,1				! CHECK IF DEBUG WAS REQUESTED
		  ,lnk$gl_imgfil [fdb$q_filename]		! AND ISSUE ERROR IF SO
		  ) ;

ihdactiv [iha$l_inishr] = 0 ;					! ASSUME NO SHAREABLE IMAGE INITIALIZATION
if .lnk$gl_ctlmsk [lnk$v_shr]					! IF SHAREABLE IMAGE
then begin
     imageheader [ihd$b_imgtype] = ihd$k_shr ;			! SET TO SHAREABLE
     if lnk$search (otsinishr,lnk$gl_otsepdsc,otsepnam)		! IF "LIB$IMAGE_INISHR" SPECIFIED
     then begin
	  ihdactiv [iha$l_inishr] = .lnk$gl_otsepdsc [sym$l_value]  ; ! SETUP INIT ENTRY POINT
	  imageheader [ihd$v_inishr] = true ;			    ! MARK IT VALID
	  end ;
     end ;


if not .lnk$gl_ctlmsk [lnk$v_sys]				! FOR A NON SYSTEM IMAGE
then if lnk$search (otsentrysym,lnk$gl_otsepdsc,otsepnam)	! IF THE RESERVED EPT NAME FOR
     then begin							! THE OTS HAS BEEN DEFINED
	  .curtfr = .lnk$gl_otsepdsc [sym$l_value] ;		! THEN NEXT TRANSFER IS TO THE OTS
	 if  .curtfr eql ihdactiv [iha$l_tfradr2]		! AND UPDATE THE POINTER FOR THE
	 then curtfr = ihdactiv [iha$l_tfradr3]			! USER TRANSFER ADDRESS TO BE THE SECOND
	 else curtfr = ihdactiv [iha$l_tfradr2] ;		! OR THIRD DEPENDING ON PRESENCE OF DEBUGGER
	 end ;							! BEFORE THE OTS

imageheader [ihd$v_lnknotfr] = true ;				! ASSUME NO TRANSFER ADDRESS

if .lnk$gl_tfrpsc neq 0						! FINALLY IF THE USER HAD A
then begin							! A TRANSFER ADDRESS
     imageheader [ihd$v_lnknotfr] = false ;			! CLEAR NO TRANSFER ADDRESS FLAG
     if not  (.lnk$gl_ctlmsk [lnk$v_sys]			! IF NOT A SYSTEM IMAGE
              and not 
	     .lnk$gl_ctlmsk [lnk$v_sysheadr]
	    )							!    WITH NO HEADER
     then .curtfr = .lnk$gl_tfradr				! AND IF SO INSERT IT LAST
     else  signal (lin$_tfrsys,1				! REPORT IGNORED TRANSFER ADDRESS
		  ,lnk$gl_imgfil [fdb$q_filename]		! IN OTHER KINDS OF IMAGE
		  ) ;
     end
else if .lnk$gl_ctlmsk [lnk$v_exe]				! IF IT IS AN EXECUTABLE
     then signal (lin$_usrtfr,1					! IMAGE REPORT THE ERROR
		 ,lnk$gl_imgfil [fdb$q_filename]		! WHEN TRANSFER ADDRESS IS MISSING
		 ) ;

symdbgdata = .imageheader + .imageheader [ihd$w_symdbgoff] ;	! POINT TO STB AND DBG DATA AREA

if  (symdbgdata [ihs$w_dstblks] = .lnk$gw_dstblks) neq 0	! IF A DST WAS WRITTEN
then symdbgdata [ihs$l_dstvbn]  = .lnk$gw_dstvbn ;		! SET BLOCK COUNT AND ITS VBN

if  (symdbgdata [ihs$w_gstrecs] = .lnk$gw_gstrecs) neq 0	! IF A GST WAS WRITTEN
then symdbgdata [ihs$l_gstvbn]  = .lnk$gw_gstvbn ;		! THEN SET RECORD COUNT AND VBN IN HEADER

if  (symdbgdata [ihs$l_dmtbytes] = .lnk$gl_dmtbytes) neq 0
then symdbgdata [ihs$l_dmtvbn]   = .dmtvbn ;

!
! THE MAJOR AND MINOR IDENTS OF THE HEADER RECORD ARE USED
! BY IMAGE ACTIVATOR AS FOLLOWS:-
!			MAJOR ID - MATCH REQUIRED ALWAYS
!			MINOR ID - MORE RECENT (GREATER THAN
!			OR EQUAL) THAN IMAGE ACTIVATOR'S
!			VERSION ARE PERMITTED.
!
imageheader [ihd$w_majorid] = ihd$k_majorid ;					! MAJOR IDENT
imageheader [ihd$w_minorid] = ihd$k_minorid ;					! MINOR IDENT

imgidarea = .imageheader + .imageheader [ihd$w_imgidoff] ;			! POINT TO IMAGE ID AREA

lnk$gt_imgnam [0] = minu (lnk$k_max_filename_length,.lnk$gt_imgnam [0]) ;	! TRIM NAME LENGTH TO MAX 
lnk$gt_imgid [0]  = minu (sym$c_shortname,.lnk$gt_imgid [0]) ;			! ALLOWED IN HEADER

ch$move (.lnk$gt_imgnam [0]+1,lnk$gt_imgnam [0],imgidarea [ihi$t_imgnam]) ;	! MOVE IN THE IMAGE NAME
ch$move (.lnk$gt_imgid [0]+1, lnk$gt_imgid [0], imgidarea [ihi$t_imgid]) ;	! MOVE IN THE IMAGE I.D

(imgidarea [ihi$q_linktime])<0,32,0> = .lnk$gq_alostim [0] ;			! TIME OF LINK IS WHEN
imgidarea [ihi$q_linktime] + 4       = .lnk$gq_alostim [1] ;			! MEMORY ALLOCATION BEGAN
(imgidarea [ihi$t_linkid])<0,8,0>    =  lid$c_size + 1 ;			! INSERT LENGTH OF LINKER ID
imgidarea [ihi$t_linkid] + 1	     = .lnk$aw_version [lid$w_major] ;		! FOLLOWED BY THE MAJOR ID
imgidarea [ihi$t_linkid] + 3	     = %c'-' ;					! SEPARETED BY A HYPHEN
imgidarea [ihi$t_linkid] + 4 	     = .lnk$aw_version [lid$w_minor] ;		! FROM THE MINOR ID

!
! FINALLY WRITE OUT THE WHOLE HEADER.
!
if writesection (.lnk$gw_hdrblks, 1, .header_desc [0])		! IF SUCCESSFULLY WRITTEN TO VBN 1
then lnk$closimgfil () ;					! CLOSE THE FILE
return ;
end ;

global routine lnk$closimgfil : novalue =
begin
!
!	ROUTINE TO CLOSE THE IMAGE FILE
!
local	errorcode,
	imagefab : block [fab$c_bln, byte];

bind 
	auxfnb = lnk$gl_imgfil [fdb$t_auxfnb] : block [nam$c_bln, byte]; ! AUXILIARY FILENAME BLOCK

if .lnk$gw_imgifi eql 0						! IF NO IMAGE RETURN NOW
then return;

$fab_init (fab = imagefab					! SET UP FAB TO CLOSE FILE
	  ,nam = auxfnb						! SET POINTER TO NAM
	  ,fop = tef						! SET TO TRUNCATE TO END OF FILE
	  );
imagefab [fab$w_ifi] = .lnk$gw_imgifi;				! JAM THE SAVED IFI

if not .lnk$gl_ctlmsk [lnk$v_image]				! IF IMAGE DISABLED
then imagefab [fab$v_dlt] = true;				!  THEN DELETE THE FILE

if not (errorcode = $close (fab=imagefab))			! DO IT AND IF AN ERROR
then signal ( lin$_closeout, 1
	    , lnk$gl_imgfil [fdb$q_filename]
	    , .errorcode, imagefab [fab$l_stv]
	    );			
lnk$gw_imgifi = 0;						! CLEAR THE ID
	
return true							! AND ALL DONE
end;

end eludom
