	.TITLE	XEDRIVER - VAX/VMS DEUNA/DELUA Driver
	.IDENT	'V04-000'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;++
; FACILITY:
;
;	VAX/VMS DEUNA/DELUA QUEUE I/O DRIVER
;
; ABSTRACT:
;
;	This module contains the DEUNA/DELUA driver FDT routines,
;	interrupt dispatcher, interrupt service and fork routines.
;
; AUTHOR:
;
;	Rod Gamache	21-Oct-1981
;
;
; MODIFICATION HISTORY:
;
;	V03-034	RNG0034		Rod Gamache		30-Aug-1984
;		Do not mark template UCB OFFLINE, simply because the
;		device reports a hardware error, that may be cleared up.
;
;	V03-033	RNG0033		Rod Gamache		2-Aug-1984
;		Fix check for ready state on DELUA. Also increase done
;		completion interrupt expected time to 16 seconds.
;
;	V03-032	RNG0032		Rod Gamache		25-Jul-1984
;		Fix powerfail recovery code to clear the POWERFAIL indicator
;		bit and set the ONLINE bit.
;
;	V03-031	LMP0275		L. Mark Pilant,		12-Jul-1984  12:43
;		Initialize the ACL info in the ORB to be a null descriptor
;		list rather than an empty queue.  This avoids the overhead
;		of locking and unlocking the ACL mutex, only to find out
;		that the ACL was empty.
;
;	V03-030	RNG0030		Rod Gamache		27-Jun-1984
;		Change the way the set default modifier behaves on the
;		Physical address parameter.
;
;	V03-029	LMP0221		L. Mark Pilant,		27-Mar-1984  11:55
;		Change UCB$L_OWNUIC to ORB$L_OWNER and UCB$W_VPROT to
;		ORB$W_PROT.
;
;	V03-028	RNG0028		Rod N. Gamache		29-Feb-1984
;		Fix return from EXE$PROBE_DSC to setup R1 as a longword.
;		Fix ALLOC_CDB to initialize the address of UCB unit 0.
;		Fix error path to return transmit CXBs on FFI interface,
;		instead of deallocating them.
;
;	V03-027	TMK0007		Todd M. Katz		06-Feb-1984
;		Fix a bug in ALLOC_CDB. When scanning the list of UCBs within
;		ALLOC_CDB to setup UCB$L_NI_HWAPTR and UCB$L_CDB, make sure that
;		the scan is complete and that these locations are setup in 
;		every UCB, and not just the UCBs from UCB0 to the current UCB 
;		(the UCB the routine was called with) inclusive.
;
;	V03-026	RNG0026		Rod N. Gamache		03-Feb-1984
;		Add a delay to the startup sequence to give the DEUNA time
;		to set the hardware state to RUN. This will allow the driver
;		the oportunity to return this state to UETP. Also the driver
;		will have to clear BIT13 in PCSR1 for UETP so that VAX 11/725s
;		will pass UETP. Also fix problem where correct error return
;		was not getting returned when quota was exceeded.
;
;	V03-025	TMK0006		Todd M. Katz		01-Feb-1984
;		When the DEUNA/DELUA times out because of UNIBUS or device
;		controller power failure, then call back all protocols which
;		are using the FFI interface and have defined an FFI$L_ERROR
;		asynchronous error routine. What this involves is:
;
;		1. Not clearing the power failure bit, CDB_STS_V_POWER, within
;		   CDB_B_STS in the routine SHUTDOWN_UNA until all I/O has been
;		   cleaned up on all active units.
;
;		2. Noticing within the routine SHUTDOWN by means of the 
;		   CDB_STS_V_POWER status bit that a power failure has 
;		   occurred. In such a circumstance the port driver wants to
;		   call the asynchronous error routine of the protocol before
;		   doing anything else provided the protocol has initialized 
;		   the FFI interface, defined an asynchronous error routine, 
;		   and the UCB for the protocol is both on-line and initialized.
;
;	V03-024	TMK0005		Todd M. Katz		19-Jan-1984
;		Make the following changes to the driver:
;
;		1. I have created a NI device dependent UCB extension within
;		   $UCBDEF. This extension contains definitions for 
;		   UCB$L_NI_HWAPTR and UCB$L_NI_MLTPTR, two new locations
;		   to be contained within the UCBs of all NI datalink drivers.
;		   I have therefore modified the XEDRIVER's UCB definition 
;		   so that the DEUNA/DELUA specific UCB fields begin immediately
;		   following the NI device dependent UCB extension.
;
;		   UCB$L_NI_HWAPTR is initialized when the CDB is first 
;		   allocated to contain the address of CDB_G_HWA, the CDB
;		   location which contains the NI device's unique hardware 
;		   address. UCB$L_NI_MLTPTR is initialized within the unit 
;		   unitialization routine to contain the address of the table 
;		   of multicast addresses defined for this protocol type.
;		   Both of these values must be accessible to the NI-SCS port
;		   driver. The NI-SCS port driver has access to the UCBs of the
;		   NI devices participating in SCS clusters, but it doesn't have
;		   initimate knowledge of how the UCBs and CDBs are layed out 
;		   for each NI device. This UCB extension provides a means for 
;		   the NI-SCS port driver to locate these values without knowing
;		   the exact layout of each of the NI device's UCB and CDB.
;
;		2. Whenever a protocol is to be started up on a DEUNA/DELUA, 
;		   allow the initiator of the SETMODE+STARTUP to specify 0
;		   receive buffers instead of the former minimum of 1. The
;		   effect on this protocol is that it must have a READ 
;		   outstanding at all times in order to guarentee that it will
;		   receive all datagrams specifying its protocol. If a datagram
;		   was received for this protocol, and there wasn't a read 
;		   outstanding, then because 0 receive buffers can be queued
;		   (or saved) for this protocol, the receive buffer would be 
;		   deallocated to pool, and the message it contained lost.
;
;		   This change is extremely useful for those users who are
;		   making use of the FFI interface provided by this port driver.
;		   Between the time the user issues a SETMODE+STARTUP, and the
;		   time the user initializes the FFI interface by calling 
;		   FFI_INIT, it would be possible for the port driver to have
;		   received messages with this user's protocol, and to have
;		   queued them up to the appropriate UCB. Now, if the user
;		   never makes use of the QIO or ALTSTART interfaces, but just
;		   uses the FFI interfaces for communication, these messages,
;		   which are probably stale by this time, will never be 
;		   received, and the buffers that contain them will effectively
;		   be lost forever. With this change, a user who wishes to do
;		   all his/her communication via the FFI interface can guarentee
;		   that a situation such as this can never arise, and buffers
;		   such as these can never be "lost".
;
;		4. Add the capability of requesting that the physical address 
;		   of the DEUNA/DELUA device be set to the default DECnet 
;		   address, when the device is first initialized. This new 
;		   capability is requested by means of the NMA$C_LNMCN_SDF 
;		   mode value specified within the modifier field of the 
;		   NMA$C_PCLI_PHA parameter.
;
;	V03-023	TMK0004		Todd M. Katz		17-Dec-1983
;		Fix a bug introduced by TMK0003. When the controller is a DELUA
;		I was re-setting UCB$B_TYPE instead of UCB$B_DEVTYPE to 
;		DT$_DELUA. 
;
;		I have also added code to UNIT_INIT which during the 
;		initizalization of UCB0 determines the state of the DEUNA/DELUA.
;		If the device is in a state other than PRIMARY LOAD, READY, or
;		RUNNING, I now clear the on-line bit within the UCB, and skip
;		the determination of the device's identification because the
;		device ID field within PSCR1 is probably invalid.
;
;	V03-022	TMK0003		Todd M. Katz		10-Nov-1983
;		Add support for the DELUA. Support consists of the following
;		modifications to the DEUNA driver:
;
;		1. The addition of an Extensive Selftest Port Command. This
;		   command maybe invoked as a diagnositic function 
;		   (XE_C_DG_ESTEST) on the DELUA only.
;
;		2. The addition of a HALT Port Command. This command maybe 
;		   invoked as a diagnositic function (XE$C_DG_HALT) on the
;		   DELUA only. Also, add a definition for the the new port
;		   state, PORT HALTED, that only the DELUA can enter.
;
;		3. The addition of an internal loopback mode for the DELUA
;		   only. Internal loopback maybe requested by specifying the
;		   controller mode (Line parameter NMA$C_PCLI_CON) as
;		   NMA$C_LINCN_LOO and by specifying the new line parameter
;		   NMA$C_PCLI_ILP with a value of NMA$C_STATE_ON. Requesting
;		   internal loopback results in the setting of the new port
;		   control block mode definition bit INTL.
;
;		4. The addition of a new interrupt bit, FATL (Fatal Error
;		   Interrupt), as bit <09> in PCSR0. When a controller interrupt
;		   occurs, and the port driver notices that this bit has been
;		   set then the contents of PCSR1 are ignored during processing
;		   of the error by FORK_PROC. This is accomplished by zeroing
;		   the high order word of R3 before calling SCHED_FORK to 
;		   schedule a fork process to handle the error. The fork 
;		   process assumes, when it starts executing, that the high 
;		   order word of R3 contains the contents of PCSR1. 
;
;		5. Add to PCSR1 a three bit field DEVID (Device Identification)
;		   from bit <04> to bit <06>, and definitions for several
;		   possible bit settings. This device identification field
;		   is used to identify a DELUA from a DEUNA. At unit 
;		   initialization time for UCB0, the template UCB, this field
;		   is queried, and if the controller is a DELUA, the device
;		   type field of the UCB is changed from its default of 
;		   DT$_DEUNA to DT$_DELUA. This field is then subsequently 
;		   referenced whenever the port driver must distinguish between
;		   the two types of controllers. The addition of this new field
;		   requires removal of the bit definitions for POWER (bit <04> 
;		   Software Defined Power Fail) and for TIMOUT (bit <05> 
;		   Software Defined Timeout) as well as all code in the driver 
;		   that sets and references these bits. The latter bit is 
;		   redundant (and thus not needed) and the function of the 
;		   former is taken up be a new CDB status bit (described below).
;
;		6. The transmit ring descriptor entries for the DELUA define a
;		   new error bit, UFLO (bit <13> - Transmit Underflow). When 
;		   this bit is detected as being set in a completed transmit, 
;		   the transmit is concluded with an error status of 
;		   SS$_CNTRLERR - Fatal Controller Error.
;
;		7. The recieve ring descriptor entries for the DELUA define a
;		   new error bit, OVRN (bit <12> - Recieve Overrun). This
;		   error status is not treated any differently from any of the
;		   other recieve error statuses - the recieve buffer(s) are 
;		   returned to the free list (or to pool if the free list is 
;		   filled), and the scan for recieved messages continues.
;
;		8. The DELUA always operates in half-duplex mode (except for
;		   loopback); therefore, the port driver has been modified to
;		   not allow the echo-back line parameter (NMA$C_PCLI_EKO) to
;		   be specified when the controller is a DELUA, and to always
;		   made sure that the port control block mode half-duplex 
;		   definition bit (HDX) is clear.
;
;		Other changes made to support the DELUA and to clean up the
;		existing driver are as follows:
;
;		1. Change the name of bit <08> of PCSR0 from FATI to USCI
;		   (Unsolicitated State Change Interrupt).
;
;		2. Move the software defined illegal interrupt bit, ILLINT,
;		   from bit <06> of PCSR1 to bit <04> of PCSR0.
;
;		3. Eliminate the port commands TMRO (Sanity Timer On), TMRF
;		   (Sanity Timer Off), and RSTT (Reset Sanity Timer).
;
;		4. Increase the size of the STATE field of PCSR1 from 3 to 4
;		   bits. STATE now occupies from bit <00> to bit <03> of PCSR1.
;		   This change requires the removal of the bit definition for
;		   RMTC (Remote Console Reserved) bit <03> from PCSR1.
;
;		5. Fix power failure recovery which has not been working for
;		   some time. Power failure recovery has not been working
;		   because the CDB address was not being loaded into R4 before
;		   SCHED_FORK was being invoked from within TIMOUT to setup
;		   a fork process to handle the error. Since the fork process 
;		   assumes that on entry R4 contains the CDB address, and R4
;		   did not contain the CDB address in the case of power failures
;		   this explains the problems which have been seen. In addition,
;		   a CDB status bit, CDB_STS_V_POWER, has been defined. This bit
;		   is now set (for reference purposes only) whenever a power 
;		   failure occurrs.
;
;		6. Add comments to explicitely distinguish DEUNA parameters
;		   and operations from DELUA parameters and operations, and
;		   visa versa.
;
;		7. Change the DEUNA device type from DT$_UNA11 to DT$_DEUNA.
;
;		8. When the CDB address is retrieved for the first time during a
;		   transmit, terminate the operation with the appropriate error 
;		   if there is no CDB.
;
;		9. When COPY_RCV determines that the promiscious user does not
;		   have a waiting IRP and that the recieve can not be buffered
;		   because of insufficient quota it returns the buffer to the 
;		   pool. It makes the assumption when it goes to return such a
;		   buffer, that the buffer can be chained, even though such
;		   chained buffers are not supported. Therefore, this routine
;		   goes through some unnecessary gymnastics to deallocate such
;		   buffers, and this change cleans up this buffer deallocation 
;		   procedure.
;
;	       10. There currently is a bug in $DASSGNs on shared UCBs 
;		   (ie - the protocol is being shared) when the UCB is on-line
;		   and the reference count has not gone to zero. In this case
;		   a selective cancel I/O is done by the routine CANCEL. The
;		   problem is that for this selective cancel to be done, R4
;		   must contain the PCB address. Unfortunately it is possible
;		   for R4 to be over-written. Therefore, the fix is to make sure
;		   that R4 contains the PCB address, when it is expected to
;		   contain the PCB address.
;
;	V03-021	TMK0002		Todd M. Katz		10-Nov-1983
;		Performance enahcements to the transmit and recieve main code
;		paths are as follows:
;
;		1. I eliminated the check for runt packets that was being
;		   made within XMT_START if padding is not enabled. The
;		   assumption will be made that since padding is enabled by
;		   default, if the user turns it off then he/she should know
;		   enough to not attempt to transmit runt packets. In addition
;		   there was one place in XMT_START that was setting up the 
;		   address of the CDB in R0 even though it already had the CDB
;		   address in R4, and I removed the unnecessary instructions.
;
;		2. I modified ADDRCVLIST as follows. When this routine is called
;		   R2 contains the address of a CXB that is to be added to the 
;		   recieve buffer list if there is sufficient quota to do so.
;		   I have made the assumption, that the CXB$B_TYPE and 
;		   CXB$W_SIZE fields of the CXB have been appropriately 
;		   initialized, and there is no need to do so again. This
;		   serves to eliminate four instructions in the case when there
;		   is sufficient quota to add the recieve buffer to the list,
;		   and one instruction from the path when the port driver must 
;		   dip into the additional quota in order to add the recieve
;		   buffer to the list.
;
;		3. START_RECIEVE, as part of its job of mapping recieve buffers
;		   and handing them to the device, was computing the size of 
;		   each recieve buffer and stuffing it in to the ring
;		   descriptor that it was currently initiating. This is
;		   unnecessary because the size of all recieve buffers is fixed 
;		   at the time the CDB is first initiated and the controller is 
;		   started. Therefore, what I have done is to initialize the
;		   buffer length fields of all ring descriptor entries as part
;		   of STARTUP, and remove the individual recieve descriptor
;		   buffer length initializations within START_RECIEVE.
;
;		4. I have made a modification to LOAD_PORT which should result
;		   in increased performance. Currently when this routine is 
;		   called the assumption is made that the port will either be 
;		   busy or there will be nothing to load it with. Consequently, 
;		   the state bit indicating the status of the port, 
;		   CDB_STS_V_FUNC, is not cleared (indicating that the port is 
;		   active) unless the port was found to be free and there is a 
;		   command to load it with. I think a more appropriate 
;		   assumption is that when this routine is called, regardless 
;		   of the state of the port, there will be command to load it 
;		   with if the port is free. Therefore, what I have done is to 
;		   always clear CDB_STS_V_FUNC while checking it by means of a 
;		   BBCC. If the port is busy, then the clearing of this bit has 
;		   no effect because it is already 0. If the port is free and 
;		   there is a command to load it with, then the BICW currently 
;		   being done in this case becomes unnecessary, and can be 
;		   removed. Finally, if the port is free but there is no 
;		   command to load, which should be the least frequent case, 
;		   then CDB_STS_V_FUNC must be set before this routine exits 
;		   and I have added a BISW to do this.
;
;		   A second improvement is to not obtain the PCBB address until 
;		   after it is determined that the next function is not a CXB 
;		   function but an IRP function. This eliminates an unnecessary 
;		   instructions from the main transmit and recieve code paths. 
;		   
;		6. There are two consecutive MOVL within XMT_START that can
;		   be replaced with a single MOVQ.
;
;		7. One of the first things XMT_ALT_START does is to retrieve 
;		   the CDB address even though it already has the address of the
;		   CDB within R4. Eliminate the unnecessary MOVL.
;
;		8. The routine FINISH_RCV_FFI currently saves the CDB address
;		   in R1 before loading the FFI block address into R4 where the
;		   CDB address is normally kept. By delaying the retrieving of
;		   the FFI block address until just before the user is called
;		   back with the CXB, the MOVL that saves the CDB address in R1
;		   can be eliminated.
;
;		9. At the present time, the address of the CDB is retrieved via 
;		   a chain of pointers within the following data structures:
;
;					UCB -> CRB -> CDB
;
;		   By defining a location within the device-dependant portion
;		   of the UCB for the CDB address, and by setting up this
;		   location initially when the CDB is first allocated, a MOVL 
;		   instruction can be eliminated for each time the CDB address
;		   must be retrieved.
;
;	       10. Finally, the port driver assumes data chaining by default,
;		   and this mandates a complicated song and dance to construct
;		   recieve packets despite the fact that DECNET specifies the
;		   maximum recieve buffer possible and data chaining can never
;		   take place! I have changed this my turning off data chaining
;		   as the default, not allowing the controller to be enabled for
;		   data chaining unless the initializer of the controller has 
;		   explicitely specified data chaining and a buffer size less 
;		   than the maximum packet size, and setting up 2 assemble 
;		   packet routines - one that supports data chaining, 
;		   ASSPKT_DCH, and one that does not ASSPKT_NODCH. When the 
;		   controller is initialized as part of a STARTUP, a decision 
;		   is made whether or not it will be enabled for data chaining 
;		   and which of the two packet assembly routines will be used 
;		   when a packet is to be assembled. This change results in a 
;		   significant performance improvement whenever the controller 
;		   is not enabled for data chaining, which is most of the time. 
;		   This is because ASSPKT_NODCH, the routine which gets invoked 
;		   and assumes no data chaining, does not have to do all the 
;		   excess work that support for data chaining requires.
;
;	V03-020	TMK0001		Todd M. Katz		01-Nov-1983
;		Add a performance enhancement to recieves and transmits at
;		the cost of some additional space within the CDB. This
;		enhancement consists of picking up the address of a ring entry
;		(transmit or recieve) from the appropriate vector of such ring 
;		entry addresses instead of computing it. The additional space 
;		within the CDB consists of two vector tables - one of transmit 
;		ring entry addresses and the other of recieve ring entry 
;		addresses. These vector tables are initialized only once - when 
;		the CDB itself is initialized within START.
;
;	V03-019	RNG0019		Rod N. Gamache		15-Sep-1983
;		Fix bug in shutdown code to allow for the first UCB
;		address not to be set in the CDB (fixes bug_check).
;		Fix service operations that were broken by FFI interface.
;
;	V03-018	RNG0018		Rod N. Gamache		24-Aug-1983
;		Fix some bugs in the Fast Interface code.
;		Set the string indicator when returning NMA$C_PCLI_HWA.
;		Initialize CDB Fork Block when it is allocated.
;
;	V03-017	RNG0017		Rod N. Gamache		08-Jul-1983
;		Add new Fast Interface.
;
;	V03-016	RNG0016		Rod N. Gamache		06-Jul-1983
;		Stop using the MBX code to create/delete UCBs.
;
;	V03-015	RNG0015		Rod N. Gamache		23-Jun-1983
;		Remove internal definition of IRP$Q_STATION.
;
;	V03-014	RNG0014		Rod N. Gamache		02-May-1983
;		Fix the shared protocol quota to be initialized when unit
;		is inited.  Add a point-to-point startup mechanism.
;
;	V03-013	RNG0013		Rod N. Gamache		02-May-1983
;		Fix the SHUT code in STARTIO to setup R4.
;
;	V03-012	RNG0012		Rod N. Gamache		30-Apr-1983
;		Add code to support Point-to-Point mode.
;		Cleanup shared user code and add shared user's quota.
;
;	V03-011	RNG0011		Rod N. Gamache		15-Apr-1983
;		Make the NMA return codes self-describing (i.e. lonword
;		or strings).
;		Misc. cleanup.
;
;	V03-010	RNG0010		Rod N. Gamache		16-Mar-1983
;		Validate parameter settings for all users of a SHARED
;		UCB. Copy the multicast address list from the SHARED
;		default user's UCB to the primary UCB for the SHARED
;		protocol.
;		Process MOP requests for read counters.
;		Make Protocol Access a modifiable parameter.
;		Make CIRCUIT startup/shutdown enable/disable the protocol
;		type for I/O operations.
;
;	V03-009	RNG0009		Rod N. Gamache		7-Mar-1983
;		Wait 20 usec on successful startup, before reading the
;		port CSRs to give UNA time to set correct state.
;		Return different error codes for TIMEOUTs, and Transceiver
;		power cable disconnected. Also, return different error
;		code on XMIT operations when the device is re-starting.
;		Add code to accept NMA$C_PCLI_DES parameter, don't return
;		parameter unless user is running in LIMITED mode.
;		On SHUTDOWN of the promiscuous user, reset the hardware into
;		non-promiscuous mode.
;		Cleanup the SHARED-LIMITED user code.
;		Allocate sufficient receive buffers at FDT time to guarantee
;		buffers will be available at run-time.
;
;	V03-008	RNG0008		Rod N. Gamache		14-Feb-1983
;		Add protocol sharing to driver. Fix zeroing of driver
;		counters. Fix bug with attempting to fill receive buffer
;		queue when TQE timer expired.
;
;	V03-007	RNG0007		Rod N. Gamache		11-Feb-1983
;		Change device into promiscuous mode, when promiscuous user
;		starts up (even after device has already been initialized).
;		Change device to enable all multicasts, if the user requests
;		this.
;
;	V03-006	RNG0004		Rod N. Gamache		14-Jan-1983
;		Cleanup use of quotas. Read port status on error.
;		Fix counter return for driver counters. Fix even size
;		receive buffer problem. Set the DELMBX bit in the
;		UCB of units to be "deleted".
;
;--

;
; EXTERNAL SYMBOLS
;
	$ABDDEF				; Define ABDs
	$ACBDEF				; Define AST control block
	$CANDEF				; Define CANCEL reason codes
	$CCBDEF				; Define CCB offsets
	$CRBDEF				; Define CRB
	$CXBDEF				; Define CXB
	$DCDEF				; Define device classes and types
	$DDBDEF				; Define DDB
	$DEVDEF				; Define device characteristics
	$DPTDEF				; Define DPT
	$DYNDEF				; Define dynamic data structures
	$FFIDEF				; Fast Interface definitions
	$FKBDEF				; Fork block definitions
	$IDBDEF				; Define IDB
	$IODEF				; Define I/O function codes
	$IPLDEF				; Define IPLs
	$IRPDEF				; Define IRP
	$JIBDEF				; Define JIB
	$MSGDEF				; Define SYSTEM MESSAGES
	$NMADEF				; Define Network Management Codes
	$ORBDEF				; OBJECT'S RIGHTS BLOCK OFFSETS
	$PCBDEF				; Define PCB
	$PRDEF				; Processor register definitions
	$PRVDEF				; Privilege bit definitons
	$SSDEF				; Define System Status Codes
	$TQEDEF				; Define TQE offsets
	$UBADEF				; Define UBA symbols
	$UCBDEF				; Define UCB
	$VADEF				; Define Virtual Address bits
	$VECDEF				; Define CRB VECTOR
	$XMDEF				; Define DECnet datalink characteristics
;
; Local symbol definitions
;
 
;
; Define the following symbol to enable use of receive buffered data paths.
;	This feature cannot normally be used on systems which use UNIBUS
;	disks, since the disk drivers REQUIRE the buffered data paths.
;
;	RCV_DATAP = 1			; Enable use of recv buffered datapaths

;
; Define the following symbol to enable use of point-to-point mode
;
	POINT = 1			; Enable use of point-to-point mode

;
; Argument list offsets for QIO 
;
P1	= 0				; Parameter 1
P2	= 4				; Parameter 2
P3	= 8				; Parameter 3
P4	= 12				; Parameter 4
P5	= 16				; Destination/Source address

;
; Constants
;
$EQU	BRDCST1		<^XFFFFFFFF>	; Broadcast address
$EQU	BRDCST2		<^XFFFF>	;	...
$EQU	UDB_SID_C_LENGTH 60		; Size of SYSTEM ID UDBB
$EQU	MAX_C_MLT	10		; Maximum number of multicast addresses
$EQU	MAX_C_CTR	32		; Maximum size of counters (words)
$EQU	MAX_C_XMT	4		; Maximum number of entries in XMT ring
$EQU	MAX_C_RCV	8		; Maximum number of entries in RCV ring
$EQU	MAX_C_CHAIN	1		; Maximum number of extra segments in
					;  a receive buffer chain

$EQU	NI_CTR_PROTYP	<^X0260>	; Ethernet read counters protocol 60-02
$EQU	NI_CTR_READ	9		; Read counters request function
$EQU	NI_CTR_REPLY	11		; Read counters reply function

$EQU	INIT_C_QUOTA	9*1500		; Allow for 9 of the largest buffers
$EQU	INIT_C_AQUOTA	2		; Allow for 2 additional buffers
$EQU	DSC$A_POINTER	4		; Pointer to data in buffer descriptor
$EQU	MIN_PKT_SIZE	46		; Size of user data in a runt packet
$EQU	MAX_PKT_SIZE	1500		; Size of maximum Ethernet user data
$EQU	TQE_C_DELTA	2		; 2 second timer interval
$EQU	TQE_DELTA	TQE_C_DELTA*10000*1000 ; Delta interval (in 100 nsec)
$EQU	RESTART_DELTA	3*10000*1000	; RESTART interval - 3 Seconds
$EQU	XMT_C_TIM	8		; XMITS must take less than 8 seconds
$EQU	XMT_TIM		<<XMT_C_TIM+2>/2>
$EQU	DNI_C_TIM	12		; DNI settings must take less than 12sec
$EQU	DNI_TIM		<<DNI_C_TIM+2>/2>
$EQU	XE_C_HEADER	14		; Size of DEUNA/DELUA header
$EQU	XE_C_CNTSIZ	2		; Size of packet count field
$EQU	XE_C_CRC	4		; Size of DEUNA/DELUA CRC
	ASSUME	XE_C_CRC LE CXB$C_TRAILER
$EQU	XE_C_STPRO	<^X0660>	;% PT-TO-PT Starting protocol type
$EQU	IPL$_XE_FIPL	8		; Fork IPL
$EQU	IPL$_XE_DIPL	21		; Device IPL

;
; Local macros
;
.MACRO	SETBIT	VAL,FLAG
	.NTYPE	_$$_	VAL
	.IF EQ	<_$$_-^X0EF>
	.IF NDF	VAL
	BBSS	S^#VAL,FLAG,.+1
	.IFF
	.IF LT <VAL-8>
	BISB	#<1@VAL>,FLAG
	.IFF
	BBSS	#VAL,FLAG,.+1
	.ENDC
	.ENDC
	.IFF
	BBSS	VAL,FLAG,.+1
	.ENDC
.ENDM	SETBIT
;
; =======================
;
.MACRO	CLRBIT	VAL,FLAG
	.NTYPE	_$$_	VAL
	.IF EQ	<_$$_-^X0EF>
	.IF NDF	VAL
	BBCC	S^#VAL,FLAG,.+1
	.IFF
	.IF LT <VAL-8>
	BICB	#<1@VAL>,FLAG
	.IFF
	BBCC	#VAL,FLAG,.+1
	.ENDC
	.ENDC
	.IFF
	BBCC	VAL,FLAG,.+1
	.ENDC
.ENDM	CLRBIT
;
; =======================
;
.MACRO	INCC	COUNTER,CONTEXT=L,?L	; Increment counter
	INC'CONTEXT	COUNTER		; Do Increment
	BCC	l			; Br if no carry set
	DEC'CONTEXT	COUNTER		; Leave at maximum value
l:
.ENDM	INCC
;
; =======================
;
.MACRO	CNTR	CURCNT,COUNTER,CONTEXT=L,?L  ; Accumlate counter
	ADD'CONTEXT	CURCNT,COUNTER	; Do addition
	BCC	l			; Br if no carry set
	MNEGL	#1,COUNTER		; Leave at maximum value
l:
.ENDM	CNTR
;
; =======================
;
.MACRO	PUSHQ	ARG			; Push a quadword
	MOVQ	ARG,-(SP)		; Save argument on stack
.ENDM	PUSHQ
;
; =======================
;
.MACRO	POPQ	ARG			; Pop a quadword
	MOVQ	(SP)+,ARG		; Restore argument
.ENDM	POPQ
;
; =======================
;
.MACRO	PARAM	TYPE,OFFSET,WIDTH,MIN,MAX,INVALID,BASE=UCB,STRING,-
			SIZE,CHECK=YES
;
;	Macro to generate the parameter tables
;
; Inputs:
;
;	TYPE = Parameter type
;	OFFSET = Offset in UCB/CDB to current value
;	WIDTH = Width of field in UCB/CDB (B,W,L)
;	MIN = Minimum value parameter is allowed to take
;	MAX = Maximum value parameter is allowed to take
;	INVALID = Invalid flags in status word
;	BASE = Data base (CDB,UCB)
;	STRING = Parameter is a string value
;	SIZE = Maximum size of string parameter in bytes
;	CHECK = Comparison is needed (YES,NO)
;
	.IF BLANK type
	 .WORD	0
	.IF_FALSE	; BLANK type
	 $$$typ = type & prm_typ_m_code		; Isolate type code

	 $$$flg = 0
	 .IIF NOT_BLANK	<invalid>, $$$flg = $$$flg!prm_flg_m_invalid
	 .IIF IDN <check><YES>, $$$flg = $$$flg!prm_flg_m_check
	 .IIF IDN <base><CDB>, $$$flg = $$$flg!prm_flg_m_cdb

	 .IF BLANK string

		.WORD	$$$typ
	  .IIF NOT_BLANK	<min>, $$$flg = $$$flg!prm_flg_m_min
	  .IIF NOT_BLANK	<max>, $$$flg = $$$flg!prm_flg_m_max
		.BYTE	$$$flg
	  $$$off = offset & prm_off_m_value	; Isolate offset only
	  $$$wid = 0				; Set null width
	  .IIF IDN <width><B>, $$$wid = <1@prm_off_v_width>
	  .IIF IDN <width><W>, $$$wid = <2@prm_off_v_width>
	  .IIF IDN <width><L>, $$$wid = <3@prm_off_v_width>
		.WORD	$$$off!$$$wid
	  .IIF NOT_BLANK	<min>, .WORD	min
	  .IIF NOT_BLANK	<max>, .WORD	max
	  line_prm_bufsiz = line_prm_bufsiz + 6

	 .IF_FALSE	; BLANK STRING

		.WORD	$$$typ!prm_typ_m_string	; Indicate a string parameter
		.BYTE	$$$flg
	   $$$off = offset & prm_off_m_value	; Isolate offset only
	   $$$wid = <size @ prm_off_v_width> & prm_off_m_width ; Get max allowed
	   $$$siz = <$$$wid @ -prm_off_v_width>
		.WORD	$$$off!$$$wid
	   line_prm_bufsiz = line_prm_bufsiz + 4 + $$$siz

	 .ENDC		; BLANK STRING

	 .IIF NOT_BLANK	<invalid>, .WORD    invalid

	.ENDC		; BLANK TYPE
.ENDM	PARAM
;
; =======================
;
.MACRO	COUNTER	TYPE,WIDTH=16,OFFSET=0,BITMAP,BASE=LINE
	.IIF NDF 'base'_cnt_size, 'base'_cnt_size = 0
	.IIF NDF 'base'_cnt_bufsiz, 'base'_cnt_bufsiz = 0
	$$$typ = nma$c_ctlin_'type' & nma$m_cnt_typ
	.IIF IDN <bitmap><MAP>, $$$typ = $$$typ!<nma$m_cnt_map>
	$$$wid = 0			; Set reserved mask width
	.IIF IDN <width><8>, $$$wid = <1@nma$v_cnt_wid>
	.IIF IDN <width><16>, $$$wid = <2@nma$v_cnt_wid>
	.IIF IDN <width><32>, $$$wid = <3@nma$v_cnt_wid>
	.IIF EQ $$$wid, .ERROR		; Invalid bit width value
	.WORD	nma$m_cnt_cou!$$$wid!$$$typ
	$$$off = offset/<width/8>
	.WORD	$$$off
	'base'_cnt_size = 'base'_cnt_size + 1	; Tally one more entry
	'base'_cnt_bufsiz = 'base'_cnt_bufsiz + 2 + <width/8>
	.IIF IDN <bitmap><MAP>, 'base'_cnt_bufsiz = 'base'_cnt_bufsiz + 2
.ENDM	COUNTER
;
; =======================
;
.MACRO	OFSET	SIZE,OFFSET,BASE
	.IF IDN <base><LINE>
	.WORD	cdb_'size'_'offset'
	.IFF
	.WORD	ucb$'size'_xe_'offset'
	.ENDC
.ENDM	OFSET
;
; =======================
;
.MACRO	DRVRCTR	TYPE,WIDTH=16,OFFSET=0,BASE=LINE
	.IIF NDF 'base'_ctr_size, 'base'_ctr_size = 0
	.IIF NDF 'base'_ctr_bufsiz, 'base'_ctr_bufsiz = 0
	.IF IDN <base><LINE>
	$$$typ = nma$c_ctlin_'type' & nma$m_cnt_typ
	.IFF
	$$$typ = nma$c_ctcir_'type' & nma$m_cnt_typ
	.ENDC
	$$$wid = 0			; Set reserved mask width
	.IIF IDN <width><8>, $$$wid = <1@nma$v_cnt_wid>
	.IIF IDN <width><16>, $$$wid = <2@nma$v_cnt_wid>
	.IIF IDN <width><32>, $$$wid = <3@nma$v_cnt_wid>
	.IIF EQ $$$wid, .ERROR		; Invalid bit width value
	.WORD	nma$m_cnt_cou!$$$wid!$$$typ
	.IIF IDN <width><8>, OFSET B,'offset,'base
	.IIF IDN <width><16>, OFSET W,'offset,'base
	.IIF IDN <width><32>, OFSET L,'offset,'base
	'base'_ctr_size = 'base'_ctr_size + 1	; Tally one more entry
	'base'_ctr_bufsiz = 'base'_ctr_bufsiz + 2 + <width/8>
.ENDM	DRVRCTR
;
; =======================
;
.MACRO	MOPCTR	WIDTH=16,OFFSET,BITMAP
	.IIF NDF mop_ctr_size, mop_ctr_size = 0
	$$$map = 0
	$$$wid = width/8
	.IIF IDN <bitmap><MAP>, $$$map = 1@7
	.IF NOT_BLANK	<offset>
		.BYTE	offset		; Offset in couter table
		.BYTE	$$$map!$$$wid	; Counter width in bytes + BITMAP FLAG
		mop_ctr_size = mop_ctr_size + $$$wid
	.IFF ; NOT_BLANK
		.WORD	0		; End of table
	.ENDC ; NOT_BLANK
.ENDM	MOPCTR
;
; =======================
;
.MACRO	SKIP	BIT,LOC,REG,CONTEXT=W,?L	; SKIP FIELD
	BBC	#BIT,LOC,l		; Br if field not present
	TST'CONTEXT	(REG)+		; Skip next field
l:
.ENDM	SKIP
;
; =======================
;
.MACRO	$DISPATCH,	INDX,VECTOR,TYPE=W,NMODE=S^#,?MN,?MX,?S,?SS,?ZZ
SS:

	.MACRO	$DSP1,$DSP1_1
		.IRP	$DSP1_2,$DSP1_1
			$DSP2	$DSP1_2
		.ENDR
	.ENDM	$DSP1

	.MACRO	$DSP2,$DSP2_1,$DSP2_2
		.=<$DSP2_1-MN>*2 + S
		.WORD	$DSP2_2-S
	.ENDM	$DSP2


	.MACRO	$BND1,$BND1_1,$BND1_2,$BND1_3
		$BND2	$BND1_1,$BND1_2
	.ENDM	$BND1

	.MACRO	$BND2,$BND2_1,$BND2_2
		.IIF	$BND2_1,$BND2_2-.,	.=$BND2_2
	.ENDM	$BND2

	.MACRO	$BND	$BND_1,$BND_2
		.IRP	$BND_3,<$BND_2>
			$BND1	$BND_1,$BND_3
		.ENDR
	.ENDM	$BND

	.=0
ZZ:
	$BND	GT,<VECTOR>
MX:
	$BND	LT,<VECTOR>
MN:
	.=SS

CASE'TYPE	INDX,#<MN-ZZ>,NMODE'<MX-MN>
S:
	.REPT	MX-MN+1
	.WORD	<MX-MN>*2 + 2
	.ENDR

	.=S

	$DSP1	<<VECTOR>>

	.=<MX-MN>*2 + S + 2

.ENDM	$DISPATCH


;
; Overlays of IRP
;
	$DEFINI	IRP	GLOBAL
 
. = IRP$W_FUNC+1
$DEF	IRP$B_XE_FUNC	.BLKB	1	; DEUNA/DELUA driver internal function code
 
. = IRP$L_MEDIA
$DEF	IRP$W_XE_RID			; RCV/XMT request ID
$DEF	IRP$B_XE_SLOT	.BLKB	1	; RCV/XMT mapping slot number
$DEF	IRP$B_XE_RING	.BLKB	1	; RCV/XMT ring entry number

. = IRP$Q_STATION+6
$DEF	IRP$B_XE_DATAP	.BLKB	1	; XMT buffered data path number

. = IRP$L_MEDIA+4
$DEF	IRP$L_XE_SYSBUF	.BLKL	1	; XMT system buffer address

. = IRP$L_MEDIA+4
$DEF	IRP$L_XE_DATBUF	.BLKL	1	; User RCV data buffer address

. = IRP$L_MEDIA
$DEF	IRP$W_XE_USERSIZ .BLKW	1	; User P2 buffer size on sensemode

. = IRP$L_MEDIA+2
$DEF	IRP$W_XE_STATUS	.BLKW	1	; Completion status

. = IRP$L_MEDIA+4
$DEF	IRP$L_XE_USERBUF .BLKL	1	; User P1 buffer address on sensemode

. = IRP$Q_STATION
$DEF	IRP$L_XE_P2BUF	.BLKL	1	; User P2 buffer address on sensemode

. = IRP$Q_STATION+4
$DEF	IRP$W_XE_P2SIZ	.BLKW	1	; P2 return buffer size on sensemode

. = IRP$Q_STATION
$DEF	IRP$W_XE_CODE	.BLKW	1	; Bad parameter code on startup request

. = IRP$L_MEDIA+4
$DEF	IRP$L_XE_MAP	.BLKL	1	; Diagnostics buffer mapping info

. = IRP$Q_STATION
$DEF	IRP$L_XE_DGUNI	.BLKL	1	; Diagnostics buffer UNIBUS address
$DEF	IRP$L_XE_UPADR	.BLKW	1	; Micro-process internal address

. = IRP$L_RBUFH_AD
	ASSUME	IRP$L_RBOFF EQ .+4
$DEF	IRP$Q_XE_PCB	.BLKQ	1	; Snap shot of PCBB

. = IRP$L_MEDIA+2
$DEF	IRP$W_XE_PROTYP	.BLKW	1	; Protocol type for user

. = IRP$L_LBOFF
$DEF	IRP$L_XE_SHR	.BLKL	1	; Address of SHR structure for user

. = IRP$L_FQFL
$DEF	IRP$C_XE_STD	.BLKL	1	; End of "standard" IRP

;
; Define driver internal function codes stored in IRP$B_XE_FUNC of IRP.
; NOTE: These are not really used as bit offsets - but as values.
;
	_VIELD	XE_FC,0,<-		; Internal function codes
		<INIT>,-		; Initialize DEUNA/DELUA
		<TESTD>,-		; Perform startup self test
		<LDRING>,-		; Load ring descriptors
		<WTPHYAD>,-		; Write physical address
		<WTMULTI>,-		; Write multicast address list
		<WTMODE>,-		; Write mode
		<START>,-		; Start XMIT/RECV processes
		<XMIT>,-		; Transmit request
		<RECV>,-		; Receive request
		<STOP>,-		; Stop protocol
		<RDCNTS>,-		; Read counters
		<RCCNTS>,-		; Read and clear counters
		<MULTI>,-		; Write new multicast address list
		<LDMEM>,-		; Load memory
		<RDMEM>,-		; Read memory
		<UPST>,-		; Load and start micro-address
		<LDSID>,-		; Load system ID parameters
		<RDSID>,-		; Read system ID parameters
		<STOPPR>,-		; Stop xmit and receive process
		<STEST>,-		; Perform a self test
		<READST>,-		; Read port status
		<RDDPA>,-		; Read default physical address
		<CANCEL>,-		; Cancel request
		<RESTART>,-		; Restart PROTOCOL
		<CHMODE>,-		; Change the mode definition
		<MOPCTR>,-		; MOP read counters request
		<ESTEST>,-		; Extended Selt-test (DELUA Only)
		<HALT>,-		; Halt Port (DELUA Only)
		>			;

	$DEFEND	IRP			; End of IRP overlays

;
; Overlays of CXB
;
	$DEFINI	CXB	GLOBAL
 
. = CXB$L_SPARE1
$DEF	CXB$B_XE_FUNC	.BLKB	1	; DEUNA/DELUA driver internal function code
			.BLKB	1	; SPARE
$DEF	CXB$W_XE_RID			; RCV/XMT request ID
$DEF	CXB$B_XE_SLOT	.BLKB	1	; RCV/XMT mapping slot number
$DEF	CXB$B_XE_RING	.BLKB	1	; RCV/XMT ring entry number
 
;
; The following overlays are for transmits only
;
. = CXB$L_SPARE0
$DEF	CXB$L_T_IRP	.BLKL	1	; Associated IRP address (if any)

. = CXB$C_HEADER-<XE_C_HEADER>
$DEF	CXB$T_T_DATA	.BLKB	XE_C_HEADER ; Standard Ethernet header

;
; The following overlays are for receives only
;
. = CXB$B_CODE
$DEF	CXB$B_R_FLAGS	.BLKB	1	; Receive message flags

. = CXB$L_END_ACTION
$DEF	CXB$W_R_NCHAIN	.BLKW	1	; Number of buffers in chain

. = CXB$L_IRP
$DEF	CXB$W_R_LENERR	.BLKW	1	; Length and receive error status

. = CXB$C_HEADER - <XE_C_HEADER+XE_C_CNTSIZ>
$DEF	CXB$T_R_DATA			; Start of receive data
$DEF	CXB$G_R_DEST	.BLKW	3	; Destination node address
$DEF	CXB$G_R_SRC	.BLKW	3	; Source node address
$DEF	CXB$W_R_PTYPE	.BLKW	1	; Protocol Type
$DEF	CXB$T_R_USERDAT			; Start of user data
$DEF	CXB$W_R_SIZE	.BLKW	1	; Size of received message (if padded).

;
; NOTE: The CXB functions are the same as for an IRP (IRP$B_XE_FUNC)
;

	$DEFEND	CXB			; End of CXB overlays

;
; Definitions that follow the standard UCB fields
;

	$DEFINI	UCB	GLOBAL		; Start of UCB definitions

. = UCB$C_NI_LENGTH			; Position at end of UCB NI extension

$DEF	UCB$Q_XE_QUEUES			; Message and I/O request queue heads
$DEF	UCB$Q_XE_SHARE	.BLKQ	1	; List of shared users
$DEF	UCB$Q_XE_IOQS			; Start of the I/O queues
$DEF	UCB$Q_XE_RCVMSG	.BLKQ	1	; Receive messages completed
$DEF	UCB$Q_XE_RCVREQ	.BLKQ	1	; Receive IRP waiting for messages
$DEF	UCB$Q_XE_XMTREQ	.BLKQ	1	;% Xmit IRP wait queue (PT-TO-PT)
UCB$C_XE_QUEUES = <.-UCB$Q_XE_QUEUES>/8	; Number of queue heads
 
$DEF	UCB$L_XE_PID	.BLKL	1	; Starter's PID
$DEF	UCB$L_XE_CPID	.BLKL	1	; Creator's PID
$DEF	UCB$L_XE_AST	.BLKL	1	; Attention AST list
$DEF	UCB$L_XE_DEFUSR	.BLKL	1	; Default shared user (shared use only)
$DEF	UCB$W_XE_QUOTA	.BLKW	1	; Receive buffer quota
$DEF	UCB$W_XE_PROTYP	.BLKW	1	; Ethernet protocol type

$DEF	UCB$B_XE_SETPRM			; Start of parameter section
$DEF	UCB$G_XE_DES	.BLKW	3	; Destination address for shared user
$DEF	UCB$W_XE_HBQ	.BLKW	1	; Hardware buffer quota
$DEF	UCB$B_XE_ACC	.BLKB	1	; Protocol access mode
$DEF	UCB$B_XE_BFN	.BLKB	1	; Number of receive buffers

$DEF	UCB$B_XE_SHRPRM			; Start of "shared user" validated prms
$DEF	UCB$W_XE_BSZ	.BLKW	1	; Device buffer size
$DEF	UCB$B_XE_PRO	.BLKB	1	; Protocol selection
$DEF	UCB$B_XE_PAD	.BLKB	1	; Padding mode
$DEF	UCB$B_XE_DCH	.BLKB	1	; Data chaining
$DEF	UCB$B_XE_PRM	.BLKB	1	; Promiscuous mode
$DEF	UCB$B_XE_MLT	.BLKB	1	; Multicast (all) address state

$DEF	UCB$B_XE_CDBPRM			; Start of settable parameters for CDB
$DEF	UCB$B_XE_CRC	.BLKB	1	; CRC generation mode
$DEF	UCB$B_XE_CON	.BLKB	1	; Controller mode
$DEF	UCB$B_XE_EKO	.BLKB	1	; Echo mode (DEUNA Only)
$DEF	UCB$B_XE_ILP	.BLKB	1	; Internal Loopback mode (DELUA Only)
UCB$C_XE_CDBPRM = .-UCB$B_XE_CDBPRM
UCB$C_XE_SHRPRM = .-UCB$B_XE_SHRPRM

$DEF	UCB$G_XE_PHA	.BLKW	3	; User defined physical address
UCB$C_XE_SETPRM = .-UCB$B_XE_CDBPRM

$DEF	UCB$B_XE_MULTI	.BLKB	1	; Number of entries in MULTI
$DEF	UCB$B_XE_MLTTBL	.BLKB	1	; Number of entries in MLTTBL
$DEF	UCB$G_XE_MULTI	.BLKW	3*MAX_C_MLT ; Multicast address list
$DEF	UCB$G_XE_MLTTBL	.BLKW	3*MAX_C_MLT ; Multicast generation list

$DEF	UCB$W_XE_CTR			; Start of counter section
$DEF	UCB$W_XE_MNECTR	.BLKW	1	; Multicast address not enabled
$DEF	UCB$W_XE_UBUCTR	.BLKW	1	; No buffer available counter
$DEF	UCB$L_XE_SBLCTR	.BLKL	1	; Number of blocks sent
$DEF	UCB$L_XE_SBYCTR	.BLKL	1	; Number of bytes sent
$DEF	UCB$L_XE_RBLCTR	.BLKL	1	; Number of blocks received
$DEF	UCB$L_XE_RBYCTR	.BLKL	1	; Number of bytes received
					; Unused/unneeded fields
$DEF	UCB$W_XE_TOTQUO	.BLKW	1	; Total quota for shared UCB
$DEF	UCB$B_XE_MST	.BLKB	1	; Maintenance state
$DEF	UCB$L_XE_FFI	.BLKL	1	; Fast interface BLOCK address
$DEF	UCB$L_XE_STIRP	.BLKL	1	;% Address of PT-TO-PT Startup IRP
$DEF	UCB$L_XE_CDB	.BLKL	1	; Address of CDB

$DEF	UCB$C_XE_LENGTH			; Size of XEDRIVER UCB
 
;
; Define device status bits
;
	$VIELD	UCB,0,<-		; XEDRIVER UCB$W_DEVSTS bits
		<XE_INITED,,M>,-	; Device is initialized
		<,1>,-			; RESERVED
		<XE_PROTYP,,M>,-	; Protocol type specified
		<XE_SHARE,,M>,-		; Shared protocol type
		<XE_RUN,,M>,-		; Unit is in RUN mode
		<XE_START,,M>,-		;% Unit is in PT-TO-PT startup state
		<XE_STACK,,M>,-		;% Unit is in PT-TO-PT stack state
		<,7>,-			; Reserved
		<XE_INTERLOCK,,M>,-	; RESTART bit is interlocked
		<XE_RESTART,,M>,-	; Automatic RESTART on PROTOCOL
		>			;  requested

	$DEFEND	UCB			; End of UCB definitions

;
; Device register offsets and bit definitions
;
	$DEFINI	XE	GLOBAL		; Start of port CSR definitions
 
$DEF	PCSR0	.BLKW	1		; 1st word of port CSRs
 
	_VIELD	XE_PCSR0,0,<-		; PCSR0 bit definitions
		<COMAND,4,M>,-		; Port command
		<ILLINT,,M>,-		; Illegal Interrupt (SOFTWARE DEFINED)
		<RSET,,M>,-		; DEUNA/DELUA Reset
		<INTE,,M>,-		; Interrupt enable
		<INTR,,M>,-		; Interrupt summary
		<USCI,,M>,-		; Unsolicitated State Change interrupt
		<FATL,,M>,-		; Fatal Error interrupt (DELUA Only)
		<RCBI,,M>,-		; Receive buffer unavailable interrupt
		<DNI,,M>,-		; Done interrupt
		<TXI,,M>,-		; Transmit done interrupt
		<RXI,,M>,-		; Receive done interrupt
		<PCEI,,M>,-		; Port command error interupt
		<SERI,,M>,-		; Status Error interrupt
		>

	_VIELD	XE_CMD,0,<-		; Define port commands
		<NOOP>,-		; NO-OP
		<GETPCBB>,-		; Get Port Control Block Base (PCBB)
		<GETCMD>,-		; Get command from PCBB
		<STEST>,-		; Perform self test
		<START>,-		; Reset xmit and receive ring pointers
		<BOOT>,-		; Boot DEUNA/DELUA
		<,2>,-			; RESERVED
		<PDMD>,-		; Polling demand wake up
		<,2>,-			; RESERVED
		<ESTEST>,-		; Extended Self-test (DELUA Only)
		<,2>,-			; RESERVED
		<HALT>,-		; Halt Port (DELUA Only)
		<STOP>,-		; Suspend the DEUNA/DELUA
		>

$DEF	PCSR1	.BLKW	1		; 2nd word of port CSRs

	_VIELD	XE_PCSR1,0,<-		; PCSR1 bit definitions
		<STATE,4,M>,-		; State
		<DEVID,3,M>,-		; Device Identification
		<PCTO,1,M>,-		; Port command timed out
		<SELF_TEST,6,M>,-	; Selftest error code
		<ICAB,,M>,-		; Interconnect Cable BAD (DEUNA Only)
		<XPWR,,M>,-		; Transceiver Power BAD (DEUNA Only)
		>
		
	_VIELD	XE_STAT,0,<-		; Define port states
		<RESET>,-		; Reset
		<PRIMLD>,-		; Primary load
		<READY>,-		; Ready
		<RUN>,-			; Running
		<,1>,-			; RESERVED
		<UHALT>,-		; UNIBUS halted
		<NIHALT>,-		; NI halted
		<NIUHALT>,-		; NI and UNIBUS halted
		<PHALT>,-		; Port halted (DELUA Only)
		>

	_VIELD	XE_DEVID,0,<-		; Define device identification codes
		<DEUNA>,-		; DEUNA
		<DELUA>,-		; DELUA
		>

$DEF	PCSR2				; 3rd word of port CSRs
$DEF	PCBB0	.BLKW	1		; Low 16 bits of the Port Control Block
					;& base
 
$DEF	PCSR3				; 4th word of port CSRs
$DEF	PCBB2	.BLKW	1		; Hi 2 bits of the Port Control Block
					;& base

	$DEFEND	XE			; End of device register definitions

 
;
; Define the Port Control Block Base (PCBB) Offsets and Function codes
;
	$DEFINI	PBB	GLOBAL		; Define Port Control Block Base

$DEF	PBB_B_FUNC	.BLKB	1	; PCBB function code
$DEF	PBB_B_SUBFUNC	.BLKB	1	; PCBB sub function code
$DEF	PBB_W_PCBB2	.BLKW	1	; Command specific
$DEF	PBB_W_PCBB4	.BLKW	1	;&
$DEF	PBB_W_PCBB6	.BLKW	1	;&
$DEF	PBB_C_LENGTH			; Length of PBB
PBB_K_LENGTH = PBB_C_LENGTH		; Length of PBB
 
	_VIELD	PB_FC,0,<-		; Port Control Block function codes
		<NOOP>,-		; NO-OP
		<LSUADDR>,-		; Load and start microaddress
		<RDDEFAULT>,-		; Read default physical address
		<,1>,-			; RESERVED
		<RDPHYAD>,-		; Read physical address
		<WTPHYAD>,-		; Write physical address
		<RDMULTI>,-		; Read multicast address list
		<WTMULTI>,-		; Write multicast address list
		<RDRING>,-		; Read ring format
		<WTRING>,-		; Write ring format
		<RDCNTS>,-		; Read counters
		<RCCNTS>,-		; Read and clear counters
		<RDMODE>,-		; Read mode
		<WTMODE>,-		; Write mode
		<RDSTATUS>,-		; Read port status
		<RCSTATUS>,-		; Read and clear port status
		<DUMPMEM>,-		; Dump internal memory
		<LOADMEM>,-		; Load internal memory
		<RDSYSID>,-		; Read system ID parameters
		<WTSYSID>,-		; Write system ID paramteters
		<RDSERAD>,-		; Read load server address
		<WTSERAD>,-		; Write load server address
		>

	_VIELD	PB_MOD,0,<-		; Port control block mode definitions
		<HDX,,M>,-		; Half duplex mode (Echo mode - DEUNA)
		<,1>,-			; RESERVED
		<LOOP,,M>,-		; Enable internal Loopback
		<DTCR,,M>,-		; Disables CRC generation on transmit
		<,2>,-			; RESERVED
		<INTL,,M>,-		; Enable Internal Loopback (DELUA Only)
		<,2>,-			; RESERVED
		<DMNT,,M>,-		; Disable maintenance features
		<,1>,-			; RESERVED
		<ECT,,M>,-		; Enable H4000 (xcvr) collision test
		<TPAD,,M>,-		; Enables transmission of PAD characters
		<DRDC,,M>,-		; Disables DATA CHAINING on receives
		<ENAL,,M>,-		; Enables recognition of all MULTICASTS
		<PROM,,M>,-		; Enables promiscuous mode
		>
	
	$DEFEND	PBB			; End of PCBB definitions

;
; Define Unibus Data Block Base (UDBB) for ring buffers
;
	$DEFINI	UDB	GLOBAL
 
$DEF	UDB_BUF_W_TDRBL	.BLKW	1	; Transmit Desc Ring Base low 16 bits
$DEF	UDB_BUF_B_TDRBH	.BLKB	1	; Transmit Desc Ring Base high 2 bits
$DEF	UDB_BUF_B_TELEN	.BLKB	1	; Length of each transmit entry
$DEF	UDB_BUF_W_TRLEN	.BLKW	1	; Number of entries in the XMIT desc ring
$DEF	UDB_BUF_W_RDRBL	.BLKW	1	; Receive Desc Ring Base low 16 bits
$DEF	UDB_BUF_B_RDRBH	.BLKB	1	; Receive Desc Ring Base hi 2 bits
$DEF	UDB_BUF_B_RELEN	.BLKB	1	; Length of each receive entry
$DEF	UDB_BUF_W_RRLEN	.BLKW	1	; Number of entries in the RECV desc ring
$DEF	UDB_BUF_C_LENGTH		; Size of UDBB for ring buffers
UDB_BUF_K_LENGTH = UDB_BUF_C_LENGTH	; Size of UDBB for ring buffers
 
;
; Define the Unibus Data Block Base (UDBB) for getting counters
;
.=0
$DEF	UDB_CTR_L_ENTRY	.BLKW	1	; Each entry is one word
$DEF	UDB_CTR_C_LENGTH		; Size of each counter entry
UDB_CTR_K_LENGTH = UDB_CTR_C_LENGTH * MAX_C_CTR ; Size of counter area

;
; Define the Unibus Data Block Base (UDBB) for a Multicast address list
;
.=0
$DEF	UDB_MLT_G_ENTRY .BLKW	3	; Entry has a 48 bit logical address
$DEF	UDB_MLT_C_LENGTH		; Size of each logical address
UDB_MLT_K_LENGTH = UDB_MLT_C_LENGTH * MAX_C_MLT ; Size of multicast list
 
	$DEFEND	UDB			; End of UDBB block descriptors
;
; Define the Transmit Ring Entry
;
	$DEFINI	XMT	GLOBAL		; Start of Transmit Ring Entry format
 
$DEF	XMT_W_SLEN	.BLKW	1	; Segment length
$DEF	XMT_W_SEGBL	.BLKW	1	; Segment address (low 16 bits)
$DEF	XMT_B_SEGBH	.BLKB	1	; Segment address (hi 2 bits)
$DEF	XMT_B_FLAGS	.BLKB	1	; Transmit status flags
$DEF	XMT_W_TDRERR	.BLKW	1	; Time domain reflectometry value
					;& and transmit errors
$DEF	XMT_W_RID	.BLKW	1	; Request ID
$DEF	XMT_C_LENGTH			; Size of transmit buffer ring entry
XMT_K_LENGTH = XMT_C_LENGTH * MAX_C_XMT ; Size of xmit ring
 
	_VIELD	XMT_FLG,0,<-		; Define flag bits
		<ENP,,M>,-		; End of packet
		<STP,,M>,-		; Start of packet
		<DEF,,M>,-		; Transmit Deferred
		<ONE,,M>,-		; One collision encountered
		<MORE,,M>,-		; More than one retry required
		<MTCH,,M>,-		; Address Match on xmit request
		<ERRS,,M>,-		; Error summary
		<OWN,,M>,-		; If 0 then owned by driver
		>
 
	_VIELD	XMT_TERR,0,<-		; Define reflectometry and errors
		<TDR,10,M>,-		; Time domain reflectometry value
		<RTRY,,M>,-		; Failed after 16 retries
		<LCAR,,M>,-		; Loss of carrier
		<LCOL,,M>,-		; Late collision
		<UFLO,,M>,-		; Underflow error (DELUA Only)
		<UBTO,,M>,-		; UNIBUS timeout
		<BUFL,,M>,-		; Buffer length error
		>

	$DEFEND	XMT			; End of Transmit Ring Entry
;
; Define the Receive Ring Entry
;
	$DEFINI	RCV	GLOBAL		; Start of Receive Ring Entry format
 
$DEF	RCV_W_SLEN	.BLKW	1	; Segment length
$DEF	RCV_W_SEGBL	.BLKW	1	; Segment address (low 16 bits)
$DEF	RCV_B_SEGBH	.BLKB	1	; Segment address (hi 2 bits)
$DEF	RCV_B_FLAGS	.BLKB	1	; Receive status flags
$DEF	RCV_W_LENERR	.BLKW	1	; Message length and receive errors
$DEF	RCV_W_RID	.BLKW	1	; Request ID
$DEF	RCV_C_LENGTH			; Size of receive buffer ring entry
RCV_K_LENGTH = RCV_C_LENGTH * MAX_C_RCV ; Size of receive ring
 
	_VIELD	RCV_FLG,0,<-		; Define flag bits
		<ENP,,M>,-		; End of packet
		<STP,,M>,-		; Start of packet
		<,1>,-			; RESERVED
		<CRC,,M>,-		; CRC error
		<OFLO,,M>,-		; Message overflow
		<FRAM,,M>,-		; Framing error
		<ERRS,,M>,-		; Error summary
		<OWN,,M>,-		; If 0 then owned by driver
		>
 
	_VIELD	RCV_LERR,0,<-		; Define MSG length and error bits
		<MLEN,12,M>,-		; Message length
		<OVRN>,-		; Overrun error (DELUA only)
		<NCHN,,M>,-		; No Data Chaining
		<UBTO,,M>,-		; UNIBUS timeout
		<BUFL,,M>,-		; Buffer length error
		>

	$DEFEND	RCV			; End of Receive Ring Entry
 
;
; Transmit Buffer Header Format
;
	$DEFINI	XBUF			; Define transmit buffer header
 
$DEF	XBUF_G_DEST	.BLKW	3	; Destination address
$DEF	XBUF_G_SRC			; Source address (overlays UCB)
$DEF	XBUF_W_UNUSED	.BLKW	1	;   sometimes overwritten with DEST
$DEF	XBUF_L_UCB	.BLKL	1	; UCB address
$DEF	XBUF_W_TYPE	.BLKW	1	; Protocol type
$DEF	XBUF_T_DATA			; Start of xmit data
$DEF	XBUF_C_HEADER			; Size of buffer header

$DEF	XBUF_W_SIZE	.BLKW	1	; Size of buffer (only if padding)

	$DEFEND	XBUF			; End of transmit buffer header
 
;
; Block header for non-DECnet xmit buffers
;
	$DEFINI	BLK			; Define a standard block header

$DEF	BLK_L_LINK	.BLKL	2	; Forward and backward queue links
$DEF	BLK_W_SIZE	.BLKW	1	; Block size
$DEF	BLK_B_TYPE	.BLKB	1	; Block type
$DEF	BLK_B_SPARE	.BLKB	1	; SPARE byte
$DEF	BLK_T_DATA			; Start of data
$DEF	BLK_C_HEADER			; Size of buffer header

	$DEFEND	BLK

;
; Define the DEUNA/DELUA Controller Data Block (CDB) fields
;

	$DEFINI	CDB	GLOBAL		; Start of CDB definitions

$DEF	CDB_L_FQFL	.BLKL	1	; Fork queue forward link
$DEF	CDB_L_FQBL	.BLKL	1	; Fork queue backward link
$DEF	CDB_W_SIZE	.BLKW	1	; Size of CDB
$DEF	CDB_B_TYPE	.BLKB	1	; Type of structure
$DEF	CDB_B_FIPL	.BLKB	1	; Fork IPL
$DEF	CDB_L_FPC	.BLKL	1	; Fork PC
$DEF	CDB_L_PCSR0			; Port CSR0 and CSR1 contents
$DEF	CDB_L_FR3	.BLKL	1	; Fork R3
$DEF	CDB_L_FR4	.BLKL	1	; Fork R4
$DEF	CDB_B_NEXTXMT	.BLKB	1	; Next entry in XMT ring
$DEF	CDB_B_NEXTRCV	.BLKB	1	; Next entry in RCV ring
ASSUME	MAX_C_XMT LE 8
ASSUME	MAX_C_RCV LE 8
$DEF	CDB_B_RCVMAP	.BLKB	1	; RCV map slot in use flags
$DEF	CDB_B_XMTMAP	.BLKB	1	; XMT map slot in use flags
$DEF	CDB_L_RCVMAP	.BLKL	MAX_C_RCV ; RCV mapping vector
$DEF	CDB_L_XMTMAP	.BLKL	MAX_C_XMT ; XMT mapping vector
$DEF	CDB_L_XRADDR	.BLKL	MAX_C_XMT ; XMT ring entry address vector
$DEF	CDB_L_RRADDR	.BLKL	MAX_C_RCV ; RCV ring entry address vector
 
$DEF	CDB_Q_QUEUES			; Start of CDB queues
$DEF	CDB_Q_XMTREQ	.BLKQ	1	; Transmit request queue
CDB_C_ABORTS = <.-CDB_Q_QUEUES>/8	; Number of Queues to abort requests
$DEF	CDB_Q_INPUT	.BLKQ	1	; Input process queue
$DEF	CDB_Q_DONE	.BLKQ	1	; IRP waiting DNI to set
$DEF	CDB_Q_XMTPND	.BLKQ	1	; Transmit pending queue
$DEF	CDB_Q_RCVBUF	.BLKQ	1	; Receive buffer queue
$DEF	CDB_Q_RCVPND	.BLKQ	1	; Receive pending queue
$DEF	CDB_Q_POST	.BLKQ	1	; Post process queue
CDB_C_QUEUES = <.-CDB_Q_QUEUES>/8	; Number of Queue Heads
 
$DEF	CDB_B_LASTXMT	.BLKB	1	; Last entry done in XMT ring
$DEF	CDB_B_LASTRCV	.BLKB	1	; Last entry done in RCV ring
$DEF	CDB_B_RCVCNT	.BLKB	1	; Count of receives given to DEUNA/DELUA
$DEF	CDB_B_XMTCNT	.BLKB	1	; Count of xmits given to DEUNA/DELUA
$DEF	CDB_W_BSZ	.BLKW	1	; Device buffer size
$DEF	CDB_W_QUOTA	.BLKW	1	; SYSTEM buffer quota

$DEF	CDB_L_PCBBMAP	.BLKL	1	; PCBB UNIBUS map register number/count
$DEF	CDB_L_PCBBUA	.BLKL	1	; PCBB UNIBUS address
$DEF	CDB_L_DEVDEPEND	.BLKL	1	; Device dependent longword
$DEF	CDB_L_UCB0	.BLKL	1	; Address of UCB #0
$DEF	CDB_B_SPARE	.BLKB	1	; SPARE BYTE
$DEF	CDB_B_DIAG1	.BLKB	1	; Diagnostic info byte
$DEF	CDB_W_DIAG2	.BLKW	1	; Second word of diagnostic info

$DEF	CDB_W_UFDCTR	.BLKW	1	; No protocol type counter
$DEF	CDB_W_SBUCTR	.BLKW	1	; System buffer unavailable
$DEF	CDB_W_UBUCTR	.BLKW	1	; No buffer available on all PTs
;
; Define the UNIBUS mapped portion of the CDB (DEUNA/DELUA data structures)
;
$DEF	CDB_G_MAPPED			; Start of UNIBUS mapped portion of CDB
$DEF	CDB_G_PCBB	.BLKB	PBB_K_LENGTH	; PCBB
$DEF	CDB_G_XRUDB	.BLKB	UDB_BUF_K_LENGTH ; XMIT/RECV buffer descriptor
$DEF	CDB_G_CUDB	.BLKB	UDB_CTR_K_LENGTH ; Counter buffer
$DEF	CDB_G_MUDB	.BLKB	UDB_MLT_K_LENGTH ; Multicast address buffer
$DEF	CDB_G_SCRUDB	.BLKB	8	; SCRATCH UDBB 
$DEF	CDB_G_SIDUDB	.BLKB	UDB_SID_C_LENGTH ; System ID UDBB
$DEF	CDB_G_XRING	.BLKB	XMT_K_LENGTH	; Xmit ring buffer
$DEF	CDB_G_RRING	.BLKB	RCV_K_LENGTH	; Recv ring buffer
CDB_C_MAPPED = .-CDB_G_MAPPED		; Size of UNIBUS mapped portion of CDB
$DEF	CDB_C_ZERO			; Size of CDB to zero (everything from
					;  the beginning to this point).
$DEF	CDB_B_TIM_XMT	.BLKB	1	; Transmit timer cell
$DEF	CDB_B_TIM_DNI	.BLKB	1	; DNI timer cell
$DEF	CDB_L_PRMUSER	.BLKL	1	; Promiscuous user's UCB address
$DEF	CDB_L_TQE	.BLKB	TQE$C_LENGTH ; Timer queue element
$DEF	CDB_W_MODE	.BLKW	1	; DEUNA/DELUA hardware mode
$DEF	CDB_B_STS	.BLKB	1	; Controller status
$DEF	CDB_B_PAD	.BLKB	1	; Padding mode
$DEF	CDB_B_DCH	.BLKB	1	; Data chaining
$DEF	CDB_B_PRM	.BLKB	1	; Promiscuous mode
$DEF	CDB_B_MLT	.BLKB	1	; Multicast (all) address state

$DEF	CDB_B_SETPRM			; Start of settable parameters
$DEF	CDB_B_CRC	.BLKB	1	; CRC generation mode
$DEF	CDB_B_CON	.BLKB	1	; Controller mode
$DEF	CDB_B_EKO	.BLKB	1	; Echo mode (DEUNA Only)
$DEF	CDB_B_ILP	.BLKB	1	; Internal Loopback mode (DELUA Only)
CDB_C_SETPRM = .-CDB_B_SETPRM		; Size of settable parameter list

$DEF	CDB_G_PHA	.BLKW	3	; User defined physical address
$DEF	CDB_G_HWA	.BLKW	3	; Hardware physical address
$DEF	CDB_G_PHYADR	.BLKW	3	; The current hardware address
$DEF	CDB_B_UNTCNT	.BLKB	1	; Number of active units (UCBs)
$DEF	CDB_B_MULTI	.BLKB	1	; Number of entries in Multicast list
$DEF	CDB_B_MLTTBL	.BLKB	1	; Number of entries in MLTTBL
$DEF	CDB_G_MLTTBL	.BLKW	3*MAX_C_MLT ; Multicast address generation tbl
$DEF	CDB_L_ASSPKT	.BLKL	1	; Address of ASSPKT routine to be used
$DEF	CDB_B_AQUOTA	.BLKB	1	; Additional QUOTA available
$DEF	CDB_B_MQUOTA	.BLKB	1	; Maximum extra QUOTA allowed

$DEF	CDB_C_LENGTH			; Size of DEUNA/DELUA CDB
 
	_VIELD	CDB_STS,0,<-		; CDB status bit for CDB_B_STS
		<INITED,,M>,-		; Inited
		<RUN,,M>,-		; Device is running
		<FORK_PEND,,M>,-	; Fork process is pending
		<FUNC,,M>,-		; Command function is NOT pending
		<TIMER,,M>,-		; Timer is active
		<RCBI,,M>,-		; Receive buffer unavailable error
		<ERR,,M>,-		; Fatal error has occurred
		<POWER,,M>,-		; Power Failure has occurred
		>

	$DEFEND	CDB			; End of DEUNA/DELUA CDB definitions

;
; P2 buffer header definition
;
	$DEFINI	P2B

$DEF	P2B_L_POINTER	.BLKL	1	; Pointer to start of data
$DEF	P2B_L_BUFFER	.BLKL	1	; Address of user's data buffer
$DEF	P2B_W_SIZE	.BLKW	1	; Size of P2 buffer
$DEF	P2B_B_TYPE	.BLKB	1	; Type of structure
$DEF	P2B_B_SPARE	.BLKB	1	; Spare byte
$DEF	P2B_C_LENGTH			; Size of P2 buffer header
$DEF	P2B_T_DATA			; Start of data
 
	$DEFEND	P2B
;
; Diagnostics buffer definition
;
	$DEFINI	DIAG
;
; Driver independent portion of diagnostics buffer
;
$DEF	DIAG_L_DATA	.BLKL	1	; Pointer to start of data
$DEF	DIAG_L_BUFFER	.BLKL	1	; User buffer address
$DEF	DIAG_W_SIZE	.BLKW	1	; Size of structure
$DEF	DIAG_B_TYPE	.BLKB	1	; Type of structure
$DEF	DIAG_B_SPARE	.BLKB	1	; Spare byte
$DEF	DIAG_T_DATA			; Start of data
$DEF	DIAG_Q_START	.BLKQ	1	; Start time for QIO
$DEF	DIAG_Q_FINISH	.BLKQ	1	; Finish time for QIO
$DEF	DIAG_L_ERRS	.BLKL	1	; Number of device errors
$DEF	DIAG_L_EXTRA	.BLKL	1	; Number of longwords that follow
;
; Driver dependent portion of diagnostics buffer
;
$DEF	DIAG_L_DEPEND
$DEF	DIAG_Q_PCSR	.BLKQ	1	; Last port CSR contents
$DEF	DIAG_Q_PCBB	.BLKQ	1	; Last port command block contents
$DEF	DIAG_W_ERR	.BLKW	1	; Ring entry error summary
$DEF	DIAG_G_HWA	.BLKW	3	; Hardware physical address
$DEF	DIAG_W_ERR2	.BLKW	1	; Extra ring entry error info
;
; The following is valid only on read (receive) QIOs
;
$DEF	DIAG_T_RDATA			; Start of receive data
$DEF	DIAG_G_DEST	.BLKW	3	; Destination address
$DEF	DIAG_G_SRC	.BLKW	3	; Source address
$DEF	DIAG_W_TYPE	.BLKW	1	; Protocol type
$DEF	DIAG_C_LENGTH			; Start of data
DIAG_C_EXTRA = .-DIAG_L_DEPEND/4
 
	$DEFEND	DIAG
;
; Receive buffer header definition
;
	$DEFINI	RHDR

$DEF	RHDR_L_DATA	.BLKL	1	; Pointer to start of data
$DEF	RHDR_L_BUFFER	.BLKL	1	; User buffer address
$DEF	RHDR_W_SIZE	.BLKW	1	; Size of structure
$DEF	RHDR_B_TYPE	.BLKB	1	; Type of structure
$DEF	RHDR_B_SPARE	.BLKB	1	; Spare byte
$DEF	RHDR_T_DATA			; Start of data
$DEF	RHDR_G_DEST	.BLKW	3	; Destination address
$DEF	RHDR_G_SRC	.BLKW	3	; Source address
$DEF	RHDR_W_TYPE	.BLKW	1	; Protocol type
$DEF	RHDR_C_LENGTH			; Start of data
RHDR_C_DATA = .-RHDR_T_DATA
 
	$DEFEND	RHDR

;
; Shareable protocol type data structure
;
	$DEFINI	SHR	GLOBAL
$DEF	SHR_L_QFL	.BLKL	1	; Forward link pointer
$DEF	SHR_L_QBL	.BLKL	1	; Backward link pointer
$DEF	SHR_W_SIZE	.BLKW	1	; Size of structure
$DEF	SHR_B_TYPE	.BLKB	1	; Type of structure
$DEF	SHR_B_STS	.BLKB	1	; SHR status
$DEF	SHR_L_PID	.BLKL	1	; User's PID
$DEF	SHR_W_CHAN	.BLKW	1	; User's channel
$DEF	SHR_G_DEST	.BLKW	3	; Destination address
$DEF	SHR_Q_QUEUES			; Start of queues
$DEF	SHR_Q_RCVMSG	.BLKQ	1	; Received messages waiting for IRPs
$DEF	SHR_Q_RCVREQ	.BLKQ	1	; Receive IRPs waiting for messages
SHR_C_QUEUES = <.-SHR_Q_QUEUES>/8	; Number of queues
$DEF	SHR_W_QUOTA	.BLKW	1	; User's shared quota
$DEF	SHR_C_LENGTH			; Size of data structure

	_VIELD	SHR_STS,0,<-		; SHR status bits
		<INITED,,M>,-		; Protocol type is inited
		>

	$DEFEND	SHR

	.SBTTL	DEUNA/DELUA device driver diagnostic function codes

$EQU	XE$C_DG_LOADMEM		1	; Write DEUNA/DELUA memory
$EQU	XE$C_DG_READMEM		2	; Read DEUNA/DELUA memory
$EQU	XE$C_DG_UPADDR		3	; Load and start u-proc address
$EQU	XE$C_DG_WRITEID		4	; Write SYSTEM ID parameters
$EQU	XE$C_DG_READID		5	; Read SYSTEM ID parameters
$EQU	XE$C_DG_STOP		6	; Stop transmit and receive process
$EQU	XE$C_DG_STEST		7	; Perform a self test
$EQU	XE$C_DG_READST		8	; Read port status
$EQU	XE$C_DG_ESTEST		9	; Perform an extended self test (DELUA)
$EQU	XE$C_DG_HALT	       10	; Halt port (DELUA Only)

	.SBTTL	Standard tables
;
; Driver prologue table
;
	DPTAB	-			;
		END=XE_END,-		; END OF DRIVER
		ADAPTER=UBA,-		; ADAPTER TYPE
		UCBSIZE=UCB$C_XE_LENGTH,- ; SIZE OF UCB
		NAME=XEDRIVER		; DRIVER NAME
 
	DPT_STORE INIT			; START OF CONTROLLER INIT
	DPT_STORE UCB,UCB$B_FIPL,B,IPL$_XE_FIPL	; FORK IPL
	DPT_STORE UCB,UCB$B_DIPL,B,IPL$_XE_DIPL	; DEVICE IPL
	DPT_STORE ORB,ORB$B_FLAGS,B,-		; Protection block flags
			   <ORB$M_PROT_16>	; SOGW protection word
	DPT_STORE ORB,ORB$W_PROT,W,0		; default protection
	DPT_STORE ORB,ORB$L_OWNER,L,0		; no owner as yet
	DPT_STORE UCB,UCB$L_DEVCHAR,L,-	; DEVICE CHARACTERISTICS
			<DEV$M_SHR!-
			 DEV$M_AVL!-
			 DEV$M_NET!-
			 DEV$M_IDV!-
			 DEV$M_ODV>

	DPT_STORE UCB,UCB$B_DEVCLASS,B,DC$_SCOM ; Device class
	DPT_STORE UCB,UCB$B_DEVTYPE,B,DT$_DEUNA	; Device type
	DPT_STORE UCB,UCB$W_DEVBUFSIZ,W,512	; Default buffer size
	DPT_STORE UCB,UCB$W_STS,W,<UCB$M_ONLINE!UCB$M_TEMPLATE>
	DPT_STORE UCB,UCB$G_XE_PHA,L,-1		; No default physical address
	DPT_STORE UCB,UCB$G_XE_PHA+4,W,-1	;	...
;
; Store defaults for all parameters
;
	DPT_STORE UCB,UCB$W_XE_BSZ,W,1500	; Default device buffer size
	DPT_STORE UCB,UCB$B_XE_BFN,B,1		; Default user buffer number
	DPT_STORE UCB,UCB$W_XE_HBQ,W,INIT_C_QUOTA ; Hardware Buffer Quota
	DPT_STORE UCB,UCB$B_XE_PRO,B,NMA$C_LINPR_NI ; "NI" is the protocol mode
	DPT_STORE UCB,UCB$B_XE_PRM,B,NMA$C_STATE_OFF ; Promiscuous mode is OFF
	DPT_STORE UCB,UCB$B_XE_MLT,B,NMA$C_STATE_OFF ; All multicasts is OFF
	DPT_STORE UCB,UCB$B_XE_DCH,B,NMA$C_STATE_OFF ; Data chaining is OFF
	DPT_STORE UCB,UCB$B_XE_CRC,B,NMA$C_STATE_ON ; CRC generation is ON
	DPT_STORE UCB,UCB$B_XE_PAD,B,NMA$C_STATE_ON ; Padding is ON
	DPT_STORE UCB,UCB$B_XE_CON,B,NMA$C_LINCN_NOR ; Controler mode is NORMAL
	DPT_STORE UCB,UCB$B_XE_EKO,B,NMA$C_STATE_OFF ; No ECHO is default (DEUNA)
	DPT_STORE UCB,UCB$B_XE_ACC,B,NMA$C_ACC_EXC ; Exclusive mode is default
	DPT_STORE UCB,UCB$B_XE_ILP,B,NMA$C_STATE_OFF ; Internal Loopback is OFF (DELUA)
 
	DPT_STORE REINIT
 
	DPT_STORE DDB,DDB$L_DDT,D,XE$DDT	; DDT ADDRESS
	DPT_STORE CRB,CRB$L_INTD+4,D,DONE_INTR	; Completion interrupt
	DPT_STORE CRB,CRB$L_INTD+VEC$L_INITIAL,D,CONTROL_INIT; CONTROLLER INIT ADDRESS
	DPT_STORE CRB,CRB$L_INTD+VEC$L_UNITINIT,D,UNIT_INIT; UNIT INIT
	DPT_STORE CRB,CRB$L_INTD+VEC$L_START,D,FFI_INIT ; FFI INIT
	DPT_STORE END
	
	.PSECT	$$$115_DRIVER,LONG
;
; LOCAL STORAGE
;
; Driver dispatch table
;
	DDTAB	DEVNAM=XE,-		; DRIVER DISPATCH TABLE
		START=STARTIO,-		; Start I/O operation
		FUNCTB=XE_FUNCTABLE,-	; Function decision table address
		CANCEL=CANCEL,-		; CANCEL I/O entry point
		REGDMP=REG_DUMP,-	; Register dump entry point
		DIAGBF=<DIAG_C_LENGTH>,- ; Diagnostic buffer size
		CLONEDUCB=CLONED_UCB,-	; Cloned UCB initialization
		ALTSTART=ALT_START	; Alternate start I/O entry point
;
; Function decision table
;
XE_FUNCTABLE:				;
	FUNCTAB	,-			; Legal Functions
	<WRITEVBLK,WRITELBLK,WRITEPBLK,READVBLK,READLBLK,-
	READPBLK,SENSEMODE,SENSECHAR,SETMODE,SETCHAR,DIAGNOSE>
	FUNCTAB	,-			; Buffered Functions
	<WRITEVBLK,WRITELBLK,WRITEPBLK,READVBLK,READLBLK,-
	READPBLK,SENSEMODE,SENSECHAR,SETMODE,SETCHAR,DIAGNOSE>
	FUNCTAB	XMT_FDT,<WRITELBLK,WRITEPBLK,WRITEVBLK> ;
	FUNCTAB	RCV_FDT,<READLBLK,READPBLK,READVBLK> ;
	FUNCTAB	SETMODE_FDT,<SETMODE,SETCHAR> ;
	FUNCTAB	SENSEMODE_FDT,<SENSEMODE,SENSECHAR> ;
	FUNCTAB DIAGNOSE_FDT,<DIAGNOSE>	; Diagnostic functions


	.SBTTL	Local driver storage
;
; Initial setting for DEUNA/DELUA mode
;
DEF_MODE::	.WORD	PB_MOD_M_ECT!-	; Enable the H4000 collision checks
			PB_MOD_M_DRDC	; Disable Data Chaining

;
; P2 Buffer verification tables
;
 
	$DEFINI	PARAM
 
$DEF	PRM_W_TYPE	.BLKW	1	; Parameter type

	_VIELD	PRM_TYP,0,<-		; Parameter type field
		<CODE,12,M>,-		; Parameter type code
		<STRING,1,M>,-		; Parameter is a string
		>

$DEF	PRM_B_FLAG	.BLKB	1	; Parameter flags

	_VIELD	PRM_FLG,0,<-		; Parameter flag bits
		<MIN,1,M>,-		; Parameter minimum value present
		<MAX,1,M>,-		; Parameter maximum value present
		<INVALID,1,M>,-		; Parameter invalid value is present
		<CDB,1,M>,-		; Offset is in CDB data base
		<CHECK,1,M>,-		; Check values with current
		>
 
$DEF	PRM_W_OFF	.BLKW	1	; Parameter offset in structure

	_VIELD	PRM_OFF,0,<-		; Offset word fields
		<VALUE,10,M>,-		; Offset value
		<WIDTH,6,M>,-		; Size of field in structure
		>
 
	$DEFEND	PARAM
 
;
; Define Line parameters
;
LINE_PRM_BUFSIZ=0			; Line parameter buffer size
LINE_PARAM_WO:				; "Write-Only" line parameters

	PARAM	NMA$C_PCLI_HBQ,-	; Hardware Buffer Quota
		OFFSET=UCB$W_XE_HBQ,-
		WIDTH=W,MAX=16384,-
		INVALID=UCB$M_XE_INITED

LINE_PARAM:				; Start of line parameters
 
	PARAM	NMA$C_PCLI_ACC,-	; Access mode for protocol type
		OFFSET=UCB$B_XE_ACC,-
		WIDTH=B,-
		MIN=NMA$C_ACC_SHR,-
		MAX=NMA$C_ACC_EXC

	PARAM	NMA$C_PCLI_PRO,-	; Protocol selection mode
		OFFSET=UCB$B_XE_PRO,-
		WIDTH=B,-
		MIN=NMA$C_LINPR_POI,-	;% Accept either point or NI
		MAX=NMA$C_LINPR_NI

	PARAM	NMA$C_PCLI_BUS,-	; Buffer size
		OFFSET=UCB$W_DEVBUFSIZ,-
		WIDTH=W,-
		MIN=MIN_PKT_SIZE,-	; User buffer LIMITS
		MAX=MAX_PKT_SIZE,- 
		INVALID=UCB$M_XE_INITED
 
	PARAM	NMA$C_PCLI_BFN,-	; Buffer number
		OFFSET=UCB$B_XE_BFN,-
		WIDTH=B,-
		MIN=0,MAX=255,-
		INVALID=UCB$M_XE_INITED
 
	PARAM	NMA$C_PCLI_PHA,-	; Physical NI address
		OFFSET=UCB$G_XE_PHA,-
		STRING=YES,-
		SIZE=<2+6>,-
		INVALID=UCB$M_XE_INITED
 
	PARAM	NMA$C_PCLI_PRM,-	; Promiscuous mode state
		OFFSET=UCB$B_XE_PRM,-
		WIDTH=B,-
		MAX=NMA$C_STATE_OFF,-
		INVALID=UCB$M_XE_INITED
 
	PARAM	NMA$C_PCLI_MLT,-	; Accept all multicast addresses
		OFFSET=UCB$B_XE_MLT,-
		WIDTH=B,-
		MAX=NMA$C_STATE_OFF,-
		INVALID=UCB$M_XE_INITED
 
	PARAM	NMA$C_PCLI_PAD,-	; PAD on transmits
		OFFSET=UCB$B_XE_PAD,-
		WIDTH=B,-
		MAX=NMA$C_STATE_OFF
 
	PARAM	NMA$C_PCLI_DCH,-	; Data chain on receives
		OFFSET=UCB$B_XE_DCH,-
		WIDTH=B,-
		MAX=NMA$C_STATE_OFF,-
		INVALID=UCB$M_XE_INITED
 
	PARAM	NMA$C_PCLI_CRC,-	; Generate CRC on transmits
		OFFSET=UCB$B_XE_CRC,-
		WIDTH=B,-
		MAX=NMA$C_STATE_OFF
 
	PARAM	NMA$C_PCLI_CON,-	; Controller mode
		OFFSET=UCB$B_XE_CON,-
		WIDTH=B,-
		MAX=NMA$C_LINCN_LOO,-
		INVALID=UCB$M_XE_INITED

	PARAM	NMA$C_PCLI_PTY,-	; Protocol type
		OFFSET=UCB$W_XE_PROTYP,-
		WIDTH=W,-
		INVALID=UCB$M_XE_INITED
 
	PARAM	NMA$C_PCLI_MCA,-	; Multicast address list
		OFFSET=UCB$G_XE_MULTI,-
		STRING=YES,-
		SIZE=2+<6*MAX_C_MLT>	; Maximum size of list

	PARAM	NMA$C_PCLI_EKO,-	; Echo transmitted messages (DEUNA Only)
		OFFSET=UCB$B_XE_EKO,-
		WIDTH=B,-
		MAX=NMA$C_STATE_OFF

	PARAM	NMA$C_PCLI_BSZ,-	; Device buffer size
		OFFSET=UCB$W_XE_BSZ,-
		WIDTH=W,-
		MIN=MIN_PKT_SIZE,-
		MAX=MAX_PKT_SIZE,-
		INVALID=UCB$M_XE_INITED

	PARAM	NMA$C_PCLI_DES,-	; Destination Address for shared
		OFFSET=UCB$G_XE_DES,-	;  Protocol Type
		STRING=YES,-
		SIZE=<2+6>

	PARAM	NMA$C_PCLI_ILP,-	; Internal Loopback mode (DELUA Only)
		OFFSET=UCB$B_XE_ILP,-
		WIDTH=B,-
		MAX=NMA$C_STATE_OFF,-
		INVALID=UCB$M_XE_INITED

	PARAM				; End of table
 
CIRCUIT_PARAM:				; Start of circuit parameter table

	PARAM	NMA$C_PCCI_MST,-	; Maintenance state
		OFFSET=UCB$B_XE_MST,-
		WIDTH=B,-
		MIN=NMA$C_STATE_ON,-
		MAX=NMA$C_STATE_OFF

	PARAM				; End of table

;
; Line/circuit counters
;
CTRTAB:					; Start of counters
	COUNTER		ZER, 16, 2	; Seconds since last zeroed
	COUNTER		DBR, 32, 4	; Packets received
	COUNTER		MBL, 32, 8	; Multicast packets received
	COUNTER		RFL, 16, 12, MAP ; Packets received in error
	COUNTER		BRC, 32, 16	; Bytes received
	COUNTER		MBY, 32, 20	; Multicast bytes received
	COUNTER		OVR, 16, 24	; Receives lost - Internal buffer error
	COUNTER		LBE, 16, 26	; Receives lost - Local buffer error
	COUNTER		DBS, 32, 28	; Packets transmitted
	COUNTER		MBS, 32, 32	; Multicast packets transmitted
	COUNTER		BSM, 32, 36	; Packets transmitted - several errors
	COUNTER		BS1, 32, 40	; Packets transmitted - 1 error
	COUNTER		BID, 32, 44	; Packets transmitted - deferred
	COUNTER		BSN, 32, 48	; Bytes transmitted
	COUNTER		MSN, 32, 52	; Multicast bytes transmitted
	COUNTER		SFL, 16, 56, MAP ; Transmit packets aborted
	COUNTER		CDC, 16, 60	; Transmit collision check failure

LINE_CTR:
	DRVRCTR		UFD, 16, UFDCTR	; Unrecognized frame destination
	DRVRCTR		SBU, 16, SBUCTR ; System buffer unavailable
	DRVRCTR		UBU, 16, UBUCTR ; User buffer unavailable

CIRC_CTR:
	DRVRCTR		DBS, 32, SBLCTR, CIRC ; Blocks sent
	DRVRCTR		BSN, 32, SBYCTR, CIRC ; Bytes sent
	DRVRCTR		DBR, 32, RBLCTR, CIRC ; Blocks received
	DRVRCTR		BRC, 32, RBYCTR, CIRC ; Bytes received
	DRVRCTR		MNE, 16, MNECTR, CIRC ; Multicast address not enabled
	DRVRCTR		UBU, 16, UBUCTR, CIRC ; User buffer unavailable

;
; MOP read counters return table (in order of COUNTERs returned)
;
MOPCTRTAB:				; Start of MOP counters
	MOPCTR		16, 2		; Seconds since last zeroed
	MOPCTR		32, 16		; Bytes received
	MOPCTR		32, 48		; Bytes transmitted
	MOPCTR		32, 4		; Packets received
	MOPCTR		32, 28		; Packets transmitted
	MOPCTR		32, 20		; Multicast bytes received
	MOPCTR		32, 8		; Multicast packets received
	MOPCTR		32, 44		; Packets transmitted - deferred
	MOPCTR		32, 40		; Packets transmitted - 1 error
	MOPCTR		16, 36		;(32)Packets transmitted - several errors
	MOPCTR		16, 58, MAP 	; Transmit packets aborted
	MOPCTR		16, 14, MAP 	; Packets received in error
;;	MOPCTR		16, XX		; Unrecognized frame destination
;;	MOPCTR		16, 24		; Receives lost - Internal buffer error
;;	MOPCTR		16, 26		; Receives lost - Local buffer error
;;	MOPCTR		16, XX		; User buffer unavailable
;;&&	MOPCTR		16, 60		; Transmit collision check failure
	MOPCTR				; End of table
;
; Calculate total size of MOP counter return data buffer
;
	MOP_CTR_SIZE = MOP_CTR_SIZE + 1 + 2 + 8 ; Size of counters + MOP header
	MOP_CTR_SIZE = MOP_CTR_SIZE + XBUF_C_HEADER ; Size of buffer + NI header

;
; BAD PARAMETER RETURN TABLE
;
; Note that the table is in the REVERSE order from that of the UCB.
;
	ASSUME	UCB$B_XE_CRC EQ UCB$B_XE_CDBPRM
	ASSUME	UCB$B_XE_CON EQ UCB$B_XE_CRC+1
	ASSUME	UCB$B_XE_EKO EQ UCB$B_XE_CON+1
	ASSUME	UCB$B_XE_ILP EQ UCB$B_XE_EKO+1
BAD_PARAM_TBL:
	.WORD	NMA$C_PCLI_ILP
	.WORD	NMA$C_PCLI_EKO
	.WORD	NMA$C_PCLI_CON
	.WORD	NMA$C_PCLI_CRC

	ASSUME	UCB$W_XE_BSZ EQ UCB$B_XE_SHRPRM
	ASSUME	UCB$B_XE_PRO EQ UCB$W_XE_BSZ+2
	ASSUME	UCB$B_XE_PAD EQ UCB$B_XE_PRO+1
	ASSUME	UCB$B_XE_DCH EQ UCB$B_XE_PAD+1
	ASSUME	UCB$B_XE_PRM EQ UCB$B_XE_DCH+1
	ASSUME	UCB$B_XE_MLT EQ UCB$B_XE_PRM+1
	ASSUME	UCB$B_XE_CDBPRM EQ UCB$B_XE_MLT+1
	.WORD	NMA$C_PCLI_MLT
	.WORD	NMA$C_PCLI_PRM
	.WORD	NMA$C_PCLI_DCH
	.WORD	NMA$C_PCLI_PAD
	.WORD	NMA$C_PCLI_PRO
	.WORD	NMA$C_PCLI_BSZ
	.WORD	NMA$C_PCLI_BSZ		; This parameter is a word (not byte)
;
; CRC-32 generation table
;
CRCTABLE:
	.LONG	0
	.LONG	^X1DB71064
	.LONG	^X3B6E20C8
	.LONG	^X26D930AC
	.LONG	^X76DC4190
	.LONG	^X6B6B51F4
	.LONG	^X4DB26158
	.LONG	^X5005713C
	.LONG	^XEDB88320
	.LONG	^XF00F9344
	.LONG	^XD6D6A3E8
	.LONG	^XCB61B38C
	.LONG	^X9B64C2B0
	.LONG	^X86D3D2D4
	.LONG	^XA00AE278
	.LONG	^XBDBDF21C

	.SBTTL	CONTROL_INIT - INITIALIZE DEUNA/DELUA DEVICE
;++
; CONTROL_INIT - INITIALIZE DEUNA/DELUA DEVICE
;
; Functional description:
;
; This routine is entered when driver is loaded, system is booted, or
; during powerfail recovery.
;
; Inputs:
;
;	R4 = Address of the device CSR
;	R5 = Address of the device IDB
;	R6 = Address of the device DDB
;	R8 = Address of the device CRB
;
;	IPL = FIPL
;
; Outputs:
;
;	R4,R5,R8 are preserved
;--
 
CONTROL_INIT::				; Initialize the DEUNA/DELUA
	RSB				; Return to caller

	.SBTTL	CLONED_UCB - INITIALIZE THE CLONED UCB
;++
; CLONED_UCB - INITIALIZE THE CLONED UCB
;
; Functional description:
;
; This routine is called by the $ASSIGN system service to allow the driver
; to initialize the cloned UCB. The driver is called with process context.
;
; Inputs:
;
;	R0 = SS$_NORMAL
;	R2 = UCB address of cloned UCB
;	R3 = DDT address
;	R4 = PCB address
;	R5 = UCB address of template UCB
;
;	IPL = ASTDEL
;
; Outputs:
;
;	R0 = SS$_NORMAL
;	R5 = UCB address of cloned UCB
;	All other registers and IPL are preserved.
;--
 
CLONED_UCB::				; Cloned UCB initialization
	MOVL	R2,R5			; Copy UCB address
					; Continue in unit_initialization

	.SBTTL	UNIT_INIT - INITIALIZE THE DEUNA/DELUA UNIT
;++
; UNIT_INIT - INITIALIZE THE DEUNA/DELUA UNIT
;
; Functional description:
;
; This routine is called at system startup, during driver loading and
; during powerfail recovery to initialize the DEUNA/DELUA unit and its UCB.
; The UCB is initialized and if power has failed, the device is forced
; to shutdwon. 
;
; Inputs:
;
;	R4 = CSR address
;	R5 = UCB address
;
;	IPL = FIPL
;
; Outputs:
;
;	None.
;--
 
UNIT_INIT::				; Initialize a DEUNA/DELUA unit
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	; Save all regs
	BBS	#UCB$V_POWER,UCB$W_STS(R5),20$ ; Br if powerfail

;
; Initialize UCB queue listheads, and the pointer (within the NI device 
; dependent UCB extension, UCB$L_NI_MLTPTR) to the multicast address table for 
; this protocol type.
;

	MOVAB	UCB$G_XE_MULTI(R5),-	; Initialize the pointer to this 
		UCB$L_NI_MLTPTR(R5)	; protocol's multicast address table

	MOVL	#UCB$C_XE_QUEUES,R0	; Get number of queue listheads in UCB
	MOVAB	UCB$Q_XE_QUEUES(R5),R1	; Get address of queue listheads
10$:	MOVAL	(R1),(R1)+		; Set forward link pointer
	MOVL	-4(R1),(R1)+		; Set backward link pointer
	SOBGTR	R0,10$			; Loop if more listheads

;
; If the template UCB, UCB0 is being initialized, query the device ID field of
; PCSR1 and set the device type field of the UCB according to the type of NI 
; controller. The default NI controller is the DEUNA. The device type field
; may only be checked if the DEUNA/DELUA has passed the self-test on power-up
; and is in the proper state. If the device is not in the proper state then
; mark UCB0 as being OFFLINE.
;

20$:	TSTW	UCB$W_UNIT(R5)		; Is this unit 0?
	BNEQ	50$			; Branch if not and clear template bit
	BBC	#UCB$V_ONLINE,-		; Do not change the device type if UCB0
		UCB$W_STS(R5),60$	; is offline

	MOVW	PCSR1(R4),R1		; Copy the contents of PCSR1
	EXTZV	#XE_PCSR1_V_STATE,-	; Extract and zero extend the port state
		#XE_PCSR1_S_STATE,R1,R0	; field of PCSR1
	$DISPATCH	R0,TYPE=B,-	; Dispatch based upon the port state
	< -
		<XE_STAT_V_RESET   30$>,-; RESET 
		<XE_STAT_V_PRIMLD  35$>,-; PRIMARY LOAD
		<XE_STAT_V_READY   35$>,-; READY
		<XE_STAT_V_RUN     35$>,-; RUN
		<XE_STAT_V_UHALT   30$>,-; UNIBUS HALTED
		<XE_STAT_V_NIHALT  30$>,-; NI HALTED
		<XE_STAT_V_NIUHALT 30$>,-; NI AND UNIBUS HALTED
		<XE_STAT_V_PHALT   30$>,-; PORT HALTED (DELUA ONLY)
	>

30$:
35$:	EXTZV	#XE_PCSR1_V_DEVID,-	; Extract and zero extend the device ID 
		#XE_PCSR1_S_DEVID,R1,R0	; field of PCSR1
	$DISPATCH	R0,TYPE=B,-	; Dispatch based upon the device ID
	< -
		<XE_DEVID_V_DEUNA 60$>,-; DEUNA - no change to the type field
		<XE_DEVID_V_DELUA 40$>,-; DELUA - change the type field
	>
40$:	MOVB	#DT$_DELUA,-		; Change the type field to DT$_DELUA
		UCB$B_DEVTYPE(R5) 
	BRB	60$			; Branch so template bit is left on

;
; We must find the address of unit 0, so we can check if the DEUNA/DELUA is 
; ONLINE. If the DEUNA/DELUA is OFFLINE, then we mark each UCB as being OFFLINE.
;

50$:	CLRW	UCB$W_ERRCNT(R5)	; Only unit #0 may list errors
	MOVL	UCB$L_DDB(R5),R0	; Get address of DEUNA/DELUA DDB
	MOVL	DDB$L_UCB(R0),R0	; Get address of UNIT 0 UCB
	BBS	#UCB$V_ONLINE,-		; Br if DEUNA/DELUA is ONLINE
		UCB$W_STS(R0),60$	;
	BICW	#UCB$M_ONLINE,-		; Else, mark new unit as OFFLINE
		UCB$W_STS(R5)		;
	;
	;  Now check for powerfail! If power had failed, we will ASSUME
	;  the DEUNA/DELUA must now be marked ONLINE. This will not
	;  work very well if originally the DEUNA/DELUA was offline
	;  because it was configured at the wrong CSR (for example).
	;
60$:	BBC	#UCB$V_POWER,UCB$W_STS(R5),65$ ; Br if NOT powerfail recovery
	BISW	#UCB$M_ONLINE,-		; Else, mark UNIT as ONLINE
		UCB$W_STS(R5)
65$:	MOVZBL	#3*MAX_C_MLT,R0		; Get size of multicast list in words
	MOVAB	UCB$G_XE_MULTI(R5),R1	; Get address of multicast list
70$:	CLRW	(R1)+			; Init multicast table
	SOBGTR	R0,70$			; Loop if more

	MOVL	UCB$L_XE_CDB(R5),R4	; Get CDB address
	BNEQ	80$			; Br if present
	BSBW	ALLOC_CDB		; Else, try to allocate a CDB
	BLBC	R0,90$			; Br if no error

;
; If a power failure has occured, set the appropriate bit within the CDB
; and schedule a fork process to handle the fatal error.
;

80$:	BBC	#UCB$V_POWER,UCB$W_STS(R5),90$ ; Br if not powerfail
	BISB2	#CDB_STS_M_POWER,CDB_B_STS(R4) ; Set the CDB power failure bit
	MOVL	#XE_PCSR0_M_USCI,R3	; Indicate a fatal error 
	BSBW	SCHED_FORK		; Schedule a fork process

90$:	POPR	#^M<R0,R1,R2,R3,R4,R5>	; Restore regs
	BICW	#UCB$M_POWER,UCB$W_STS(R5) ; Clear the powerfail flag
	RSB				; Done

	.SBTTL	FFI_INIT - FFI INTERFACE INITIALIZATION ROUTINE
;++
; FFI_INIT - FFI INTERFACE INITIALIZATION ROUTINE
;
; Functional description:
;
; This routine initializes the FFI interface. Currently the UCB must
; have been initialized prior to calling this routine, in the future
; this routine may have to initialize the UCB and DEUNA/DELUA. Therefore,
; there may be a fork involved in the call to this routine.
;
; Inputs:
;
;	R3 = Address of quadword descriptor for parameter buffer
;	R4 = FFI block address
;
;	IPL = SYNCH
;
; Outputs:
;
;	R0 = Status of request
;	All other registers are preserved.
;
;--
	ASSUME	IPL$_SYNCH EQ IPL$_XE_FIPL
FFI_INIT::
	PUSHR	#^M<R1,R2,R3,R4,R5>	; Save registers
	CLRL	R0			; Assume failure
	MOVL	FFI$L_DL_UCB(R4),R5	; Get UCB address
	BBC	#UCB$V_XE_RUN,-		; Br if device not ready
		UCB$W_DEVSTS(R5),90$
	MOVAB	W^XMT_FFI_START,-	; Return address of XMIT routine
		FFI$L_XMIT(R4)
	MOVL	R4,UCB$L_XE_FFI(R5)	; Save FFI address
	MOVZBL	#1,R0			; Return success
90$:	POPR	#^M<R1,R2,R3,R4,R5>	; Restore registers
	RSB				; Return to caller


	.SBTTL	XMT_FDT - TRANSMIT I/O OPERATION FDT ROUTINE
;++
; XMT_FDT - TRANSMIT I/O OPERATION FDT ROUTINE
;
; Functional description:
;
; This routine sets up the internal function code for transmit and
; transfers control to the exec buffered I/O write FDT routine.
;
; The QIO parameters for WRITES are:
;
;	P1 = Address of the data buffer
;	P2 = Size of the data buffer
;	P5 = Address of buffer containing the destination address
;
; Inputs:
;
;	R3 = IRP address
;	R4 = PCB address
;	R5 = UCB address
;	R6 = CCB address
;	R7 = FUNCTION CODE
;
;	IPL = ASTDEL
;
; Outputs:
;
;	R0-R2,R8,R9 are destroyed.
;
;--
ABORTIO_BR:				; Long branch to ABORTIO
	BRW	ABORTIO			; Abort the I/O request
						
XMT_FDT::				; Transmit FDT routine
	CLRQ	IRP$Q_STATION(R3)	; Zero the destination address
	MOVW	UCB$W_XE_PROTYP(R5),-	; Assume we are a non-promiscuous user
		IRP$W_XE_PROTYP(R3)	;
	MOVL	P5(AP),R1		; Get address of destination address
	BNEQ	1$			; Br if given
;
; If the user is in shared mode, then he does not have to supply a destination
; address with each transmit operation. The destination address will be gotten
; from the SHR data structure.
;
	BBS	#UCB$V_XE_SHARE,-	; Br if shared user
		 UCB$W_DEVSTS(R5),2$	;
1$:	MOVZBL	S^#SS$_ACCVIO,R0	; Assume access violation
	IFNORD	#6,(R1),ABORTIO_BR	; Check access to buffer
	MOVL	(R1),IRP$Q_STATION(R3)	; Save destination address
	MOVW	4(R1),IRP$Q_STATION+4(R3) ;	...

	ASSUME	NMA$C_STATE_ON EQ 0
	ASSUME	NMA$C_STATE_OFF EQ 1

2$:	BLBS	UCB$B_XE_PRM(R5),3$	; Br if user is not promiscuous
	ADDL	#6,R1			; Point to protocol type
	IFNORD	#2,(R1),ABORTIO		; Check access to buffer
	MOVW	(R1),IRP$W_XE_PROTYP(R3)	; Get protocol type from user P5 buffer
3$:	MOVZBL	S^#SS$_BADPARAM,R0	; Assume bad parameters
	MOVL	P1(AP),R8		; Get starting address of user buffer
	MOVZWL	P2(AP),R9		; Get length of user buffer
	BEQL	ABORTIO			; Br if zero length buffer
	MOVQ	R8,R0			; Retrieve buffer parameters
	JSB	G^EXE$WRITECHK		; Check accessibility of user buffer
					; (No return on NO ACCESS)
					; Returns IRP$W_BCNT
	ADDL2	#CXB$C_HEADER+XE_C_CRC,R1 ; Calculate length of buffer needed
	PUSHR	#^M<R3,R4,R5>		; Save registers
	JSB	G^EXE$BUFFRQUOTA	; Check if process has sufficient quota
	BLBC	R0,10$			; Br if quota check failure
	JSB	G^EXE$ALLOCBUF		; Allocate CXB buffer for output
	BLBC	R0,10$			; If LBC allocation failure
	MOVL	(SP),R3			; Retrieve address of IRP
	MOVL	PCB$L_JIB(R4),R0	; Get JIB address
	SUBL	R1,JIB$L_BYTCNT(R0)	; Adjust buffered I/O quota
	MOVW	R1,IRP$W_BOFF(R3)	; Set number of bytes charged to quota
	MOVL	R2,IRP$L_SVAPTE(R3)	; Save CXB address in IRP
	PUSHL	R2			; Save pointer to CXB

	ASSUME	CXB$L_FL EQ 0
	ASSUME	CXB$L_BL EQ CXB$L_FL+4
	CLRQ	(R2)+			; Clear link cells

	ASSUME	CXB$W_SIZE EQ CXB$L_BL+4
	MOVW	R1,(R2)+		; Set size of structure

	ASSUME	CXB$B_TYPE EQ CXB$W_SIZE+2
	ASSUME	CXB$B_CODE EQ CXB$B_TYPE+1
	MOVZBW	#DYN$C_CXB,(R2)+	; Set structure type

	MOVL	(SP),R2			; Get back CXB address

	ASSUME	CXB$C_HEADER EQ CXB$T_T_DATA+XE_C_HEADER
	MOVW	#CXB$T_T_DATA,CXB$W_BOFF(R2) ; Setup offset to start of data
	MOVAB	CXB$C_HEADER(R2),R2	; Get address of data portion of buffer

	MOVC3	R9,(R8),(R2)		; Move data to system buffer
	POPR	#^M<R2,R3,R4,R5>	; Restore registers
	SETIPL	UCB$B_FIPL(R5)		; Sync access to UCB
	PUSHL	R3			; Save R3
	BSBB	XMT_START		; Do common processing
	POPL	R3			; Restore R3
	BLBC	R0,ABORTIO		; Br if error in processing request
	JMP	G^EXE$QIORETURN		; Exit QIO service to await completion

10$:	POPR	#^M<R3,R4,R5>		; Restore registers
ABORTIO:JMP	G^EXE$ABORTIO		; Abort the I/O request

	.SBTTL	XMT_FFI_START - START FAST INTERFACE TRANSMIT OPERATION
;++
; XMT_FFI_START - START FAST INTERFACE TRANSMIT OPERATION
;
; Functional description:
;
; This routine is called to start a transmit operation. If the DEUNA/DELUA is 
; running then the request is given to the xmit wait queue for the DEUNA/DELUA. 
; If there is a free entry in the transmit ring and there are sufficient map 
; registers to map the buffer then the request is given to the DEUNA/DELUA 
; immediately, else the request is left on the xmit wait queue until another 
; request completes.
;
;
;  ** The driver should never do direct I/O on XMIT requests, because  **
; *** the DEUNA/DELUA is very slow if the buffer address begins on an odd byte ***
;  ** boundary.	Also, the FAST interface cannot operate on DIRECT I/O. **
;
; Inputs:
;
;	R3 = CXB address
;	R4 = FFI address
;
;	IPL = SYNCH (same as FIPL)
;
; Outputs:
;
;	R0,R3 are destroyed.
;	All other registers are preserved.
;
;	If the request cannot be queued, then the FFI$L_XMIT_DONE entry is
;	called immediately with the following:
;
;		R0 = Status of transmit request
;		R3 = CXB address
;		R4 = FFI address
;
;--
	ASSUME	IPL$_SYNCH EQ IPL$_XE_FIPL
XMT_FFI_START::				; Start FAST interface transmit request
	PUSHR	#^M<R1,R2,R4,R5>	; Save registers
	MOVL	FFI$L_DL_UCB(R4),R5	; Get UCB address
	CLRL	CXB$L_T_IRP(R3)		; No IRP with CXB
	SUBW	#XE_C_HEADER,CXB$W_BOFF(R3) ; Back up offset for Ethernet header

	ASSUME	NMA$C_STATE_ON EQ 0
	ASSUME	NMA$C_STATE_OFF EQ 1
	BLBS	UCB$B_XE_PAD(R5),20$	; Br if padding is disabled
	SUBW	#XE_C_CNTSIZ,CXB$W_BOFF(R3) ; Else, skip length field of buffer
20$:	MOVZWL	CXB$W_BOFF(R3),R1	; Get offset to start of data
	ADDL3	R1,R3,R2		; Set R2 to start of header

	ASSUME	XBUF_W_UNUSED EQ XBUF_G_DEST+6
	MOVQ	CXB$Q_STATION(R3),-	; Store destination address
		 XBUF_G_DEST(R2)
	MOVW	UCB$W_XE_PROTYP(R5),-	; Set PROTOCOL TYPE
		 XBUF_W_TYPE(R2)
	BSBB	XMT_INITIATE		; Try to start transmit
	BLBS	R0,50$			; Br if success
	MOVL	UCB$L_XE_FFI(R5),R4	; Else, get back FFI address
	JSB	@FFI$L_XMIT_DONE(R4)	; Complete request in error
50$:	POPR	#^M<R1,R2,R4,R5>	; Restore registers
	RSB				; Return to caller

	.SBTTL	XMT_START - START TRANSMIT OPERATION
;++
; XMT_START - START TRANSMIT OPERATION
;
; Functional description:
;
; This routine is called to start a transmit operation. If the DEUNA/DELUA is 
; running then the request is given to the xmit wait queue for the DEUNA/DELUA. 
; If there is a free entry in the transmit ring and there are sufficient map 
; registers to map the buffer then the request is given to the DEUNA/DELUA 
; immediately, else the request is left on the xmit wait queue until another 
; request completes.
;
;
;  ** The driver should never do direct I/O on XMIT requests, because  **
; *** the DEUNA/DELUA is very slow if the buffer address begins on an odd byte ***
;  ** boundary.	Also, the FAST interface cannot operate on DIRECT I/O. **
;
; Inputs:
;
;	R2 = CXB address
;	R3 = IRP address
;	R5 = UCB address
;
;	IPL = FIPL
;
; Outputs:
;
;	R0 = Status of transmit request
;	R1,R2,R3,R4 are destroyed.
;
;--
	.ENABL	LSB
XMT_START::				; Start transmit operation
	BBS	#UCB$V_XE_RUN,-		; Br if unit is in RUN mode
		UCB$W_DEVSTS(R5),30$

10$:	MOVZWL	#SS$_DEVINACT,R0	; Assume unit not started yet
	BBC	#UCB$V_XE_INTERLOCK,-	; Br if unit is not re-starting
		UCB$W_DEVSTS(R5),20$	;  on it's own.
	MOVZWL	#SS$_OPINCOMPL,R0	; Else, return different error code
20$:	RSB				; Okay to leave now

30$:	MOVL	R3,CXB$L_T_IRP(R2)	; Save IRP address
	MOVW	IRP$W_BCNT(R3),CXB$W_BCNT(R2) ; Set BCNT in CXB
	MOVQ	R2,R3			; Copy CXB and IRP addresses

	ASSUME	NMA$C_STATE_ON EQ 0
	ASSUME	NMA$C_STATE_OFF EQ 1
	BLBS	UCB$B_XE_PAD(R5),35$	; Br if padding is disabled
	SUBW	#XE_C_CNTSIZ,CXB$W_BOFF(R3) ; Else, skip length field of buffer
35$:	MOVZWL	CXB$W_BOFF(R3),R1	; Get offset to start of data
	ADDL3	R1,R3,R2		; Set R2 to start of header
	MOVQ	IRP$Q_STATION(R4),-	; Store destination address
		 XBUF_G_DEST(R2)
	MOVW	IRP$W_XE_PROTYP(R4),-	; Store PROTOCOL TYPE
		 XBUF_W_TYPE(R2)

XMT_INITIATE::				; FAST Interface entry point (FFI)
	;
	; Inputs:
	;	R5 = UCB address
	;	R3 = CXB address
	;	R2 = Start address for Ethernet header
	;
	MOVB	#XE_FC_V_XMIT,CXB$B_XE_FUNC(R3) ; Set function request in CXB
	MOVL	R5,XBUF_L_UCB(R2)	; Save UCB address
	CLRL	R0			; Assume no CRC

	ASSUME	NMA$C_STATE_ON EQ 0
	ASSUME	NMA$C_STATE_OFF EQ 1
	BLBC	UCB$B_XE_CRC(R5),40$	; Br if CRC generation is ON
	MOVW	#XE_C_CRC,R0		; Else, allow user to xmit a CRC
	
40$:	ASSUME	NMA$C_STATE_ON EQ 0
	ASSUME	NMA$C_STATE_OFF EQ 1
	BLBS	UCB$B_XE_PAD(R5),60$	; Br if padding is disabled

;
;  PADDING IS ENABLED:
;	Adjust byte count to include size field and store count field.
;
	MOVW	CXB$W_BCNT(R3),-	; Else, store size of data-only
		XBUF_W_SIZE(R2)		;  portion of buffer in message
	ADDW	#XE_C_CNTSIZ,CXB$W_BCNT(R3) ; And account for count field

;
; Allow buffer size up to Ethernet max buffer size for transmit operations.
;
60$:	ADDW3	#MAX_PKT_SIZE,R0,R1	; Calculate size of largest packet
	CMPW	CXB$W_BCNT(R3),R1	; Is buffer size bigger than
					;  largest Ethernet buffer allowed?
	BLEQU	90$			; Br if no
80$:	MOVZWL	#SS$_IVBUFLEN,R0	; Assume bad buffer length
	RSB				; ELSE, leave now

90$:	MOVL	UCB$L_XE_CDB(R5),R4	; Get CDB address
	BEQL	100$			; Return error if no CDB
	BBC	#CDB_STS_V_RUN,-	; Br if DEUNA/DELUA not running
		CDB_B_STS(R4),100$	;
	ADDW	#XE_C_HEADER,-		; Adjust byte count
		 CXB$W_BCNT(R3)		;  for header info
;
; If running in the SHARED-LIMITED mode, then we must use the destination
; address from the SHR_ data structure. Unless the given destination address
; is a multicast address. For the SHARED-DEFAULT user, we must make sure that
; destination address given is unique!
;
	BBC	#UCB$V_XE_SHARE,-	; Br if NOT a shared user
		 UCB$W_DEVSTS(R5),NO_SHR ;
;
; Try to find a match on PID/CHAN. Returns pointer in R1
;
	PUSHL	R3			; Save CXB address
	MOVL	CXB$L_T_IRP(R3),R3	; Get IRP address
	BSBW	MATCH_SHR		; Try to find the SHR data structure
	BEQL	110$			; Br if match
	POPL	R3			; Else, restore CXB address
100$:	BRW	10$			; Return error

110$:	POPL	R3			; Restore CXB address
	CMPL	UCB$L_XE_DEFUSR(R5),R1	; Is this the default user?
	BEQL	SHR_DEF			; Br if yes
;
; This is a SHARED-LIMITED user.
;
	BLBS	XBUF_G_DEST(R2),NO_SHR	; Br if multicast address
	MOVL	SHR_G_DEST(R1),-	; Else, get destination from SHR struct.
		 XBUF_G_DEST(R2)	;	...
	MOVW	SHR_G_DEST+4(R1),-	;	...
		 XBUF_G_DEST+4(R2)	;	...
	BRB	NO_SHR			; Continue in common code
	.DSABL	LSB
;
; This is a SHARED-DEFAULT user.
;
SHR_DEF:MOVAB	UCB$Q_XE_SHARE(R5),R0	; Get address of SHR listhead
	MOVL	R0,R1			; Save address of start of listhead
10$:	MOVL	SHR_L_QFL(R1),R1	; Get address of next in list
	CMPL	R0,R1			; Back at start of list?
	BEQL	NO_SHR			; Br if yes, destination is unique
	CMPL	XBUF_G_DEST(R2),-	; Address match?
		 SHR_G_DEST(R1)		;	...
	BNEQ	10$			; Br if no - check next in list
	CMPW	XBUF_G_DEST+4(R2),-	; Hi order of address match?
		 SHR_G_DEST+4(R1)	;	...
	BNEQ	10$			; Br if not - check next in list
	MOVZWL	#SS$_BADPARAM,R0	; Else, bad parameter code
	RSB				; Return to caller

NO_SHR:
;
; If we are running in point-to-point mode, then queue xmit on wait queue
; if we are waiting for run!
;
	CMPB	#NMA$C_LINPR_POI,-	;% Are we in PT-TO-PT mode?
		UCB$B_XE_PRO(R5)	;%
	BNEQ	40$			;% Br if not
	BBC	#UCB$V_XE_STACK,-	;% Br if not in stack wait state
		UCB$W_DEVSTS(R5),40$	;%
	INSQUE	(R3),@UCB$Q_XE_XMTREQ+4(R5);% Else, insert request on wait queue
	MOVZBL	#1,R0			;% Return success
	RSB				;% Return to caller
;
; Insert request on CDB transmit request queue and check if transmit
; can proceed.
;
40$:	INSQUE	(R3),@CDB_Q_XMTREQ+4(R4) ; Insert at end of xmit queue

XMT_ALT_START::				; Alternate start for xmit
	;
	; Inputs:
	;	R5 = UCB
	;	R4 = CDB
	; 
	PUSHQ	R6			; Save R6,R7
	MOVL	UCB$L_CRB(R5),R6	; Get CRB address
	ASSUME	MAX_C_XMT LE 8
	FFC	#0,#MAX_C_XMT,CDB_B_XMTMAP(R4),R7 ; Find a free transmit slot
	BEQL	20$			; Br if none free
;
; Move CXB info into UCB
;
	REMQUE	@CDB_Q_XMTREQ(R4),R3	; Get oldest xmit request
	BVS	20$			; Br if none
	MOVW	CXB$W_BCNT(R3),UCB$W_BCNT(R5) ; Set byte count
	MOVZWL	CXB$W_BOFF(R3),R2	; Get offset to start of data
	ADDL	R3,R2			; Compute buffer virtual address
	BICW3	#^C<VA$M_BYTE>,-	; Get buffer offset
		R2,UCB$W_BOFF(R5)	;
;
; Convert virtual address to physical PTE address
;
	EXTZV	#VA$V_VPN,#VA$S_VPN,R2,R2 ; Get virtual page number
	MOVL	G^MMG$GL_SPTBASE,R0	; Get the base address of the SPT
	MOVAL	(R0)[R2],UCB$L_SVAPTE(R5) ; Set address of the SPT entry
;
; The following instruction also sets the data path number to the Direct
; Data Path.
;
	ASSUME	VEC$W_MAPREG+2 EQ VEC$B_NUMREG
	ASSUME	VEC$B_NUMREG+1 EQ VEC$B_DATAPATH
	MOVL	CDB_L_XMTMAP(R4),-	; Assume we use preallocated map
		CRB$L_INTD+VEC$W_MAPREG(R6) ; register.
	TSTL	R7			; Is mapping slot the preallocated one?
	BEQL	50$			; Br if yes - all set
					; Else, allocate the map registers
;
; Allocate UNIBUS map registers
;
	CLRB	CRB$L_INTD+VEC$B_DATAPATH(R6) ; Reset data path usage
	JSB	G^IOC$ALOUBAMAP		; Allocate UNIBUS map registers
	BLBS	R0,50$			; Br if one available
	INSQUE	(R3),CDB_Q_XMTREQ(R4)	; Re-insert CXB on request queue
20$:	POPQ	R6			; Restore R6,R7
	MOVZBL	S^#SS$_NORMAL,R0	; Good return
30$:	RSB				; Return to caller
;
; Try to allocate a buffered data path. If successful use it, else use the
; Direct Data Path.
;
; This driver does not pre-allocate any buffered data paths because it is
; not known how many DEUNAs/DELUAs will be installed on any one CPU. Neither is 
; it known how many other devices on that same CPU may also wish to use the
; buffered data paths, therefore no pre-allocation is done.
;
50$:	JSB	G^IOC$REQDATAPNW	; Request a buffered data path
;
; Save the map information and map the buffer.
;
	ASSUME	VEC$W_MAPREG+2 EQ VEC$B_NUMREG
	ASSUME	VEC$B_NUMREG+1 EQ VEC$B_DATAPATH
	MOVL	CRB$L_INTD+VEC$W_MAPREG(R6),- ; Save mapping info
		CDB_L_XMTMAP(R4)[R7]	; in CDB
	SETBIT	R7,CDB_B_XMTMAP(R4)	; Set mapping slot in use flag
	MOVB	R7,CXB$B_XE_SLOT(R3)	; Save mapping slot number used
;
; Find next ring entry and insert data
;
	MOVZBL	CDB_B_NEXTXMT(R4),R2	; Get next ring entry
	INCB	CDB_B_NEXTXMT(R4)	; Bump ring pointer
	BICB	#^C<MAX_C_XMT-1>,-	; Modulo xmit ring size
		CDB_B_NEXTXMT(R4)	;
	MOVB	R2,CXB$B_XE_RING(R3)	; Save ring entry number
	MOVL	CDB_L_XRADDR(R4)[R2],R2	; Retrieve next ring entry address
	MOVW	CXB$W_BCNT(R3),XMT_W_SLEN(R2) ; Store message length
	MOVW	CXB$W_XE_RID(R3),XMT_W_RID(R2) ; Store unique request ID
	MOVW	UCB$W_BOFF(R5),XMT_W_SEGBL(R2) ; Move byte offset - BA0-BA8
	INSV	CRB$L_INTD+VEC$W_MAPREG(R6),- ; Insert BA9-BA15
		#9,#7,XMT_W_SEGBL(R2)	;&
	EXTZV	#7,#2,CRB$L_INTD+VEC$W_MAPREG(R6),R0 ; Get BA16-BA17
	MOVB	R0,XMT_B_SEGBH(R2)	; Insert BA16-BA17
	MOVL	R2,R6			; Save xmit ring entry
	JSB	G^IOC$LOADUBAMAPA	; Load map registers
	MOVB	#XMT_FLG_M_STP!XMT_FLG_M_ENP!- ; Give buffer to DEUNA/DELUA
		XMT_FLG_M_OWN,XMT_B_FLAGS(R6) ;
	INCB	CDB_B_XMTCNT(R4)	; Tally one more xmit in progress
;
; Request and load the port
;
	POPQ	R6			; Restore R6,R7
	DSBINT	UCB$B_DIPL(R5)		; Sync access to device
	INSQUE	(R3),@CDB_Q_INPUT+4(R4)	; Insert at end of input queue
	BNEQ	60$			; Br if not first entry on queue
	BSBW	LOAD_PORT		; Load port
60$:	ENBINT				; Restore IPL
	BRW	XMT_ALT_START		; Try for more requests


	.SBTTL	RCV_FDT - RECEIVE I/O OPERATION FDT ROUTINE
;++
; RCV_FDT - RECEIVE I/O OPERATION FDT ROUTINE
;
; Functional description:
;
; The specified buffer is checked for accessibility. The buffer address and count
; are saved in the packet. Then IPL is set to device fork IPL and if a message is
; available the operation is completed; otherwise, the packet is queued onto
; the waiting receive list.
;
; The QIO parameters for WRITES are:
;	P1 = Address of the data buffer
;	P2 = Size of the data buffer
;	P5 = Optional address of the buffer to receive the source address
;
; Inputs:
;
;	R3 = IRP address
;	R4 = PCB address
;	R5 = UCB address
;	R6 = CCB address
;	R7 = Function code
;	AP = Address of the first operation specific qio parameter
;
;	IPL = ASTDEL
;
; Outputs:
;
;	R0 = Status of the receive qio operation
;	R3 = IRP address
;	R5 = UCB ADDRESS
;
;	R1,R2 are destroyed.
;--

RCV_FDT::				; Read operation FDT
;
;  Check the request params
;
	CLRW	IRP$W_BOFF(R3)		; Set no quota to here
	MOVZBL	S^#SS$_ACCVIO,R0	; Assume access violation
	MOVL	P5(AP),R7		; Get address for source address
	BEQL	10$			; Br if none
	IFNOWRT	#RHDR_C_DATA,(R7),20$	; Check for write access to buffer
	BBS	#IRP$V_DIAGBUF,-	; Br if diagnostic buffer given
		IRP$W_STS(R3),10$	;	...
	MOVZBL	#RHDR_C_LENGTH,R1	; Get size of header buffer
	PUSHL	R3			; Save IRP address
	JSB	G^EXE$ALLOCBUF		; Allocate header buffer
	POPL	R3			; Restore IRP address
	BLBC	R0,20$			; Br if allocation failure
	MOVL	R2,IRP$L_DIAGBUF(R3)	; Save buffer address
	BISW	#IRP$M_DIAGBUF,IRP$W_STS(R3) ; Indicate diag buffer present
	ASSUME	RHDR_L_DATA EQ 0
	MOVAB	RHDR_T_DATA(R2),(R2)+	; Set address of start of data
	ASSUME	RHDR_L_BUFFER EQ RHDR_L_DATA+4
	MOVL	R7,(R2)+		; Set user buffer address
	ASSUME	RHDR_W_SIZE EQ RHDR_L_BUFFER+4
	MOVW	R1,(R2)+		; Save size of allocation
	ASSUME	RHDR_B_TYPE EQ RHDR_W_SIZE+2
	MOVB	#DYN$C_BUFIO,(R2)+	; Set structure type
10$:	MOVZBL	S^#SS$_BADPARAM,R0	; Assume illegal size
	MOVZWL	P2(AP),R1		; Get size



	BEQL	20$			; Br if zero - illegal
	MOVL	P1(AP),R0		; Get user buffer address
	MOVL	R0,IRP$L_XE_DATBUF(R3)	; Save user VA for completion
	JSB	G^EXE$READCHK		; Check the buffer
					; (No return on NO ACCESS)
	BISW	#IRP$M_CHAINED,IRP$W_STS(R3) ; Allow data chaining
	SETIPL	UCB$B_FIPL(R5)		; Raise IPL to lock data base
	BSBB	RCV_START		; Process the request
	BLBC	R0,20$			; Br if error
	JMP	G^EXE$QIORETURN		; Else, take normal return

20$:	BRW	ABORTIO			; Abort the request

	.SBTTL	RCV_START - START RECEIVE I/O OPERATION
;++
; RCV_START - START RECEIVE I/O OPERATION
;
; Functional description:
;
;  Check for device active.  Receives cannot be queued to the UCB receive
;  queue unless the UCB has been initialized via routine START.   They
;  cannot be put in the IRP queue since this could result in non-sequential
;  receive processing due to the existence of the separate receive queue.
;
; Inputs:
;
;	R3 = IRP address
;	R5 = UCB address
;
;	IPL = FIPL
;
; Outputs:
;
;	R0 = Status of receive request
;	R4 = CDB address
;
;	R1,R2 are destroyed.
;
;--
INACT_ERROR:
	MOVZWL	#SS$_DEVINACT,R0	; Setup return status
	RSB				; Return to caller

	.ENABL	LSB
RCV_START::				; Start receive I/O operation
	BBC	#UCB$V_XE_RUN,-		; Br if UCB is not in RUN mode
		UCB$W_DEVSTS(R5),INACT_ERROR
		
	MOVL	UCB$L_XE_CDB(R5),R4	; Get CDB address
	BEQL	40$			; Br if none
	BBC	#CDB_STS_V_RUN,-	; Br if DEUNA/DELUA not running
		CDB_B_STS(R4),INACT_ERROR
	MOVAB	UCB$Q_XE_RCVMSG(R5),R1	; Get address of UCB received messages
;
; If running in SHARED mode, then use the listheads in the SHR_
; data structure.
;
	BBC	#UCB$V_XE_SHARE,-	; Br if UCB is NOT SHARED
		 UCB$W_DEVSTS(R5),5$	;
;
; Try to find a match on PID/CHAN
;
	BSBW	MATCH_SHR		; Try to find shared user
	BNEQ	INACT_ERROR		; Br if none - inactive user
	MOVAB	SHR_Q_RCVMSG(R1),R1	; Get address of received messages
;
; Check to see if message is available
;
5$:	REMQUE	@(R1)+,R2		; Dequeue a received message
					; ..bump pointer to end of list pointer
	BVS	10$			; Br if none
;
; Complete receive with available message
;
	BSBW	FINISH_RCV_IO		; Complete the receive
	BRB	30$			; And exit
;
; Queue IRP for future message arivial unless IO$M_NOW specified
;
10$:	BBC	#IO$V_NOW,IRP$W_FUNC(R3),20$ ; Br if not READ NOW
	MOVZWL	#SS$_ENDOFFILE,R0	; Set no message status
	BSBW	IO_DONE			; Complete the I/O
	BRB	30$			; And exit
;
; Queue the IRP to UCB receive wait queue
;
	ASSUME	UCB$Q_XE_RCVREQ EQ UCB$Q_XE_RCVMSG+8
	ASSUME	SHR_Q_RCVREQ EQ SHR_Q_RCVMSG+8
20$:	INSQUE	(R3),@8(R1)		; Put packet on waiting list
30$:	MOVZBL	S^#SS$_NORMAL,R0	; Set QIO status return
40$:	RSB				; Return to caller
	.DSABL	LSB

	.SBTTL	 SUBROUTINES TO FIND SHR DATA STRUCTURE
;+
; Subroutine to find SHR data structure for user
;
; Inputs:
;	R3 = Address of IRP
;	R5 = UCB address
;
; Outputs:
;	R1 = Address if SHR data structure if match
;	R0 is destroyed.
;	Z-Bit set then match.
;	Z-Bit clear then no match.
;-

MATCH_SHR:				; Try to find shared user
	MOVL	UCB$L_XE_DEFUSR(R5),R1	; Get address of default user
	BEQL	10$			; Br if no default user
	BSBB	CHECK_SHR		; Check for match
	BEQL	40$			; Br if match
10$:	MOVAB	UCB$Q_XE_SHARE(R5),R0	; Save address of listhead
	MOVL	R0,R1			; Copy listhead address
	ASSUME	SHR_L_QFL EQ 0
20$:	MOVL	(R1),R1			; Get next in list
	CMPL	R1,R0			; Back to start of list?
	BEQL	30$			; Br if yes - no pid/chan match
	BSBB	CHECK_SHR		; Check for match
	BNEQ	20$			; Br if none
	BRB	40$			; Return in success
30$:	MOVL	R0,R0			; Return match failure
40$:	RSB

;+
; Subroutine to check if PID and SHR data base match up
;
; Inputs:
;	R1 = Address of SHR
;	R3 = Address of IRP
;
; Outputs:
;	Z-Bit set then match.
;	Z-Bit clear then no match.
;-

CHECK_SHR:				; Check for match with SHR data base
	TSTL	IRP$L_PID(R3)		; Is this an Internal IRP user?
	BLSS	10$			; Br if yes, only one allowed per UCB
;
; Normal QIO user
;
	CMPL	IRP$L_PID(R3),SHR_L_PID(R1) ; PIDs match?
	BNEQ	30$			; Br if no - try for next
	BRB	20$			; Else, continue checks
;
; Internal IRP user
;
10$:	CMPL	UCB$L_XE_PID(R5),SHR_L_PID(R1) ; Is this the Internal user?
	BNEQ	30$			; Br if not
20$:	CMPW	IRP$W_CHAN(R3),SHR_W_CHAN(R1) ; Channels match?
30$:	RSB				; Return to caller


	.SBTTL 	ALT_START - ALTERNATE START I/O ROUTINE
;++
; ALT_START - ALTERNATE STARTIO I/O ROUTINE
;
; Functional description:
;
; This routine is called by the Executive to pass an "internal" IRP
; to the driver.  "Internal" IRP's are those not built via QIO.
; These IRPs are used by higher level software used to request I/O and
; should not be confused with the IRPs built and passed by the
; Transport layer to NSP.  The action here is to setup the IRP fields
; as if the packet had been processed by the FDT routines.
;
; Inputs:
;
;	R3 = IRP address
;	R5 = UCB address
;
;	All pertinent fields of the IRP are assumed to be valid.
;
;	IPL = FIPL
;
; Implicit inputs:
;
;	IRP$L_SVAPTE(R3) = System VIRTUAL address (not physical PTE address)
;
; Outputs:
;
;	R0-R5 may be garbage	  
;--

ALT_START::				; Accept an "internal" IRP
	BBS	#IRP$V_FUNC,-		; If BS then read function
		IRP$W_STS(R3),10$
	MOVW	UCB$W_XE_PROTYP(R5),-	; MUST be a non-promiscous user
		IRP$W_XE_PROTYP(R3)	;
	MOVL	IRP$L_SVAPTE(R3),R2	; Get address of start of data
	SUBL3	#XE_C_HEADER,(R2),R1	; Get the xmit buffer address
	SUBL	R2,R1			; Form offset to start of data
	MOVW	R1,CXB$W_BOFF(R2)	; Store offset in CXB
	MOVB	#DYN$C_CXB,CXB$B_TYPE(R2) ; Set structure type to CXB
	CMPB	UCB$B_XE_PRO(R5),-	;% Point-to-point mode?
		#NMA$C_LINPR_POI
	BNEQ	5$			;% If so,
	CLRQ	IRP$Q_STATION(R3)	;% Pick up destination from SHR block
5$:	PUSHL	R3			; Save IRP address
	BSBW	XMT_START		; Start transmit operation
	POPL	R3			; Restore IRP address
	BRB	30$			; Continue

10$:	MOVL	IRP$L_SVAPTE(R3),R2	; Get address of input buffer
	BEQL	20$			; Br if none
	MOVL	UCB$L_XE_CDB(R5),R4	; Get CDB address
	CLRL	IRP$L_SVAPTE(R3)	; Make sure SVAPTE is cleared
;
; The driver must be prepared to process chained buffers returned from
; the higher levels.
;
;&&15$:	PUSHL	CXB$L_LINK(R2)		; Save address of next in link
;&&	CLRL	CXB$L_LINK(R2)		; Clear the link cell
	BSBW	ADDRCVLIST		; Else, add it to the receive list
;&&	POPL	R2			; Get back address of next in chain
;&&	BNEQ	15$			; Br if more to return

20$:	BSBW	RCV_START		; Start receive operation
30$:	BLBC	R0,40$			; Br if error
	RSB				; Return to caller

40$:	BRW	IO_DONE			; Post the I/O request in error

	.SBTTL	SETMODE_FDT - SET MODE I/O OPERATION FDT DISPATCH ROUTINE
;++
; SETMODE_FDT - SET MODE FDT PROCESSING
;
; Functional description:
;
; This is the fdt routine for setmode functions.
; There are three functions based on subfunction modifier bit.
;
; NOTE: That there is no difference on a request to shutdown a line or
;       a circuit. However, a request to startup a circuit is ignored
;	completely.
;
; The QIO parameters for SETMODE are:
;
;	P2 = Optional address of buffer descriptor for extended characteristics
;
;
; The Subfunction modifiers are as follows:
;
; 1)	CHANGE MODE -- NO MODIFIER BIT.
;	This function is done in the STARTIO routine. Control is passed to
;	EXE$SETMODE to validate the new mode buffer and queue the packet.
;
; 2)	INITIALIZE THE UNIT -- IO$M_STARTUP SET.
;	This function is done partially here and the remainder in STARTIO.
;	The action here is to pick up the user buffered I/O quota.  The quota
;	taken from the user is in IRP$W_BOFF. This value will be the IOSB+2 value
;	at I/O done. The mailbox is enabled and a receive is started.
;
; 3)	SHUTDOWN UNIT -- IO$M_SHUTDOWN SET.
;	This function shuts down the unit and optionally resets the mode.
;	A CANCEL I/O is performed, all outstanding I/O is completed, the
;	message blocks are all returned and the unit is left in an idle
;	state. This function cannot be done here and the FDT processing is
;	that of all SETMODE operations.
;
; 4)	ATTENTION AST -- IO$M_ATTNAST SET.
;	This function sets up an AST to be delivered when a change of
;	status occurs on the DEUNA/DELUA.
;
;
; Inputs:
;
;	R3 = IRP ADDESS
;	R4 = PCB ADDRESS
;	R5 = UCB ADDRESS
;	R6 = CCB ADDRESS
;	R7 = FUNCTION CODE
;	AP = ADDRESS OF THE FIRST QIO PARAMETER
;
;	IPL = ASTDEL
;
; Outputs:
;
;	R3 = IRP ADDRESS
;	R4 = PCB ADDRESS
;	R5 = UCB ADDRESS
;
;	R0-R2,R6 are destroyed.
;
;--

SETMODE_FDT::				; SET MODE FDT processing
	CLRL	IRP$L_SVAPTE(R3)	; Set no buffered packet
	CLRQ	IRP$L_MEDIA(R3)		; Reset mode data area
	MOVZWL	#SS$_DEVOFFLINE,R0	; Assume unit if offline
	BBS	#UCB$V_ONLINE,-		; Br if unit online
		UCB$W_STS(R5),5$	;
	BRW	ABORTIO			; Else, abort the I/O request

5$:	MOVW	IRP$W_FUNC(R3),R7	; Get entire function code
	BBC	#IO$V_ATTNAST,R7,30$	; Br if not attention AST
;
; User is requesting an attention AST
;
	MOVAL	UCB$L_XE_AST(R5),R7	; Get address of AST list
	JSB	G^COM$SETATTNAST	; Set up attention AST

	ASSUME	UCB$V_XE_INITED  EQ  0
	BLBC	UCB$W_DEVSTS(R5),10$	; Br if protocol not active

	MOVAB	UCB$Q_XE_RCVMSG(R5),R1	; Check for empty receive list
	CMPL	R1,(R1)			; Empty?
	BEQL	10$			; Br if YES, no need to inform user
	PUSHL	R3			; Save IRP address
	BSBW	POKE_USER		; Inform user
	POPL	R3			; Restore IRP address
10$:	MOVZBL	S^#SS$_NORMAL,R0	; Set success
	MOVL	UCB$L_DEVDEPEND(R5),R1	; Get device dependent information
20$:	JMP	G^EXE$FINISHIO		; Complete the I/O
;
; On a circuit request,
;	If this is a shutdown then perform a $CANCEL and clear the RUN flag.
;	If this is a startup then set the RUN flag.
;
25$:	BBC	#IO$V_SHUTDOWN,R7,27$	; Br if not a shutdown request
	SETIPL	UCB$B_FIPL(R5)		; Sync acces to UCB & CDB
	CLRBIT	#UCB$V_XE_RUN,-		; Clear the RUN flag
		UCB$W_DEVSTS(R5)
	MOVZWL	IRP$W_CHAN(R3),R2	; Get channel number
	ASSUME	CAN$C_CANCEL EQ 0
	CLRL	R8			; Set $CANCEL function
	BSBW	CANCEL			; Perform a CANCEL
	BRB	10$			; Complete the request

27$:	BBC	#IO$V_STARTUP,R7,10$	; Br if not a startup request
	CLRBIT	#XM$V_ERR_START,UCB$L_DEVDEPEND(R5) ;% Clear start error flag
	BISW	#UCB$M_XE_START!UCB$M_XE_STACK,- ;% Set start and stack states
		UCB$W_DEVSTS(R5)	;%
	SETBIT	#UCB$V_XE_RUN,-		; Set the RUN flag
		UCB$W_DEVSTS(R5)
	BRB	10$			; Complete the request
;
; For everthing except Attention ASTs we must make sure CDB is present
; and we must verify the P2 buffer.
;
30$:	TSTL	UCB$L_XE_CDB(R5)	; Is CDB there?
	BNEQ	35$			; Br if yes
	BSBW	ALLOC_CDB		; Else, allocate CDB
	BLBS	R0,35$			; Br if successful
	MOVZWL	#SS$_INSFMEM,R0		; Set error return
33$:	BRW	ABORTIO			; Return error

35$:	BSBW	GET_CHAR_BUF		; Get P2 characteristics
	BLBC	R0,33$			; Br if error - Abort I/O
	MOVAB	LINE_PARAM_WO,R2	; Assume the line parameters
	BBS	#IO$V_CTRL,R7,36$	; Br if line request
	MOVAB	CIRCUIT_PARAM,R2	; Else, use the circuit parameters
36$:	BSBW	VALIDATE_P2		; Validate the P2 parameters
	BLBC	R0,20$			; Br if error
	BBC	#IO$V_CTRL,R7,25$	; Br if not a LINE request
	SETIPL	UCB$B_FIPL(R5)		; Sync access to UCB's
	BSBW	SAV_MULTI		; Save the multicast address list
	CLRL	IRP$L_XE_SHR(R3)		; Assume exclusive user
	BBC	#UCB$V_XE_SHARE,-	; Br if not a SHARED user
		UCB$W_DEVSTS(R5),40$	;
;
;	Allow the shared user to change the destination node with which
;	it is communicating.
;
	BSBW	MATCH_SHR		; Else, try to find shared user
	BNEQ	40$			; Br if none found, skip it
	MOVL	R1,IRP$L_XE_SHR(R3)	; Save the SHR data structure address
	MOVL	SHR_G_DEST(R1),-	; Save the current destination user
		UCB$G_XE_DES(R5)	;  address in the UCB
	MOVW	SHR_G_DEST+4(R1),-	;	...
		UCB$G_XE_DES+4(R5)	;	...
;
;	Now we will set the parameters given in the setmode request. But,
;	first if the DEUNA/DELUA controller is inited we will use the current
;	hardware settings for the defaults.
;
40$:	MOVL	UCB$L_XE_CDB(R5),R1	; Get CDB address
	ASSUME	CDB_STS_V_INITED EQ 0
	BLBC	CDB_B_STS(R1),45$	; Br if controller not enabled, use
					;  the fixed defaults
	MOVAB	CDB_B_SETPRM(R1),R1	; Get address of setable parameters
	MOVAB	UCB$B_XE_CDBPRM(R5),R2	; Get address of UCB parameters
	MOVZBL	#UCB$C_XE_CDBPRM,R0	; Get size of parameters to move
42$:	MOVB	(R1)+,(R2)+		; Store CDB parameters into UCB
	SOBGTR	R0,42$			; Loop if more
45$:	MOVAB	LINE_PARAM_WO,R2	; Get address of verification table
	BSBW	CHANGE_PARAM		; Change the parameters
	MOVL	IRP$L_XE_SHR(R3),R1	; Get the SHR structure address
	BEQL	50$			; Br if not present, skip it
	MOVL	UCB$G_XE_DES(R5),-	; Else, reset the destination user
		SHR_G_DEST(R1)		;  address into the SHR structure
	MOVW	UCB$G_XE_DES+4(R5),-	;	...
		SHR_G_DEST+4(R1)	;	...

50$:	BBC	#IO$V_SHUTDOWN,R7,60$	; Br if not shutdown request
;
; Shutdown protocol request
;
	ASSUME	UCB$V_XE_INITED  EQ  0
	BLBS	UCB$W_DEVSTS(R5),55$	; Br if still inited
	BRW	10$			; Else, complete I/O request now
55$:	MOVB	S^#XE_FC_V_STOP,IRP$B_XE_FUNC(R3) ; Set internal function code
	BRW	QUEPKT			; Queue request to DEUNA/DELUA

60$:	BBS	#IO$V_STARTUP,R7,80$	; Br if startup function
70$:	BRW	180$			; Else, must be change mode
;
; Startup protocol request
;
80$:	MOVB	#XE_FC_V_INIT,IRP$B_XE_FUNC(R3) ; Insert internal function code
;
;	If the UCB is already initialized for SHARED use, then we will
;	check to make sure that the SHR struture exists. If it does then
;	the share structure must be active, by definition.
;
	TSTL	IRP$L_XE_SHR(R3)		; Was the SHR structure present
	BNEQ	70$			; Br if yes, already started
	BBS	#UCB$V_XE_SHARE,-	; Br if SHARED UCB, ingore status
		UCB$W_DEVSTS(R5),125$	; ..make user a shared user
	ASSUME	UCB$V_XE_INITED  EQ  0
	BLBS	UCB$W_DEVSTS(R5),70$	; Br if already started
					; ..check multicast address list
	BBC	#UCB$V_XE_PROTYP,-	; Br if no protocol specified
		UCB$W_DEVSTS(R5),100$	; ..error
;
; Check if protocol type is to be shared
;
	CMPB	#NMA$C_ACC_EXC,-	; Is this PROTOCOL TYPE for exclusive
		 UCB$B_XE_ACC(R5)	;  use?
	BNEQ	125$			; Br if not
;
; Check protocol type for uniqueness
;
	MOVZWL	UCB$W_XE_PROTYP(R5),R1	; Get protocol type
;
; For a user wishing to run in promiscuous mode, the requirement is that
; there be no other promiscuous users running. For a non-promiscuous user,
; there must be no other users running with the same protocol type.
;
	MOVAB	MATCH_PROTYP,R0		; Get address of Action routine
					;  assume non-PROMISCUOUS user

	ASSUME	NMA$C_STATE_ON EQ 0
	ASSUME	NMA$C_STATE_OFF EQ 1

	BLBS	UCB$B_XE_PRM(R5),90$	; Br if NOT a PROMISCUOUS user
;
; The promiscuous user must have PHY_IO privilege
;
	MOVAB	MATCH_PROMTYP,R0	; Get address of Action routine
	IFPRIV	PHY_IO,90$		; If user has privilege, then okay
	BSBW	RES_MULTI		; Else, Restore original multicast list
	MOVZWL	#SS$_NOPRIV,R0		; Return error - NOPRIV
	MOVZWL	#NMA$C_PCLI_PRM,R1	; Return the bad parameter
	BRW	20$			; Finish the I/O request
90$:	PUSHQ	R4			; Save PCB, UCB addresses
	MOVL	UCB$L_XE_CDB(R5),R4	; Get CDB address
	JSB	(R0)			; Try to find exact match
	POPQ	R4			; Restore PCB, UCB addresses
	BLBC	R0,130$			; Br if none found - okay
;
;	Bad protocol type
;
100$:	MOVZWL	#NMA$C_PCLI_PTY,R1	; Return bad parameter code
	BRB	120$			; Finish error reporting
;
;	Bad quota calculated
;
110$:	MOVZWL	#NMA$C_PCLI_BFN,R1	; Return bad parameter code
120$:	MOVZBL	S^#SS$_BADPARAM,R0	; Set error return
123$:	BSBW	RES_MULTI		; Restore original multicast list
	BRW	20$			; Finish the I/O request
;
; Shared protocol type - look for same protocol type in other UCB.
;
125$:	BSBW	SHR_UCB			; Find other UCB in user or make this
					;  UCB shareable
	BLBC	R0,123$			; Br on error
;
; We must now check if UCB is already inited.
;
	ASSUME	UCB$V_XE_INITED  EQ  0
	BLBC	UCB$W_DEVSTS(R5),135$	; Br if this UCB is NOT inited
					; skip quota taking, already done
	BRW	185$			; Else, compute multicast list

130$:	SETIPL	#IPL$_ASTDEL		; Reset IPL to ASTDEL
;
; Take quota needed
;
	BSBW	TAKE_QUOTA		; Take quota from user
	BLBC	R0,123$			; Br if error
	MOVW	R7,UCB$W_XE_QUOTA(R5)	; Save quota in UCB
135$:	SETBIT	#UCB$V_XE_INITED,-	; Indicate unit is initialized
		UCB$W_DEVSTS(R5)	;	...
	SETIPL	UCB$B_FIPL(R5)		; Sync access to UCB and CDB
	BLBS	UCB$B_XE_PRM(R5),140$	; Br if NOT a PROMISCUOUS user
	MOVL	UCB$L_XE_CDB(R5),R4	; Get CDB address
	MOVL	R5,CDB_L_PRMUSER(R4)	; Store promiscuous user's address
;
; Pre-allocate all needed receive buffers, if the CDB is not initialized yet!
; The buffers are immediately deallocated, but this pre-allocation will allow
; the pool to grow if necessary! This must be done here, before we run on the
; interrupt stack.
;
140$:	PUSHQ	R3			; Save R3, R4
	MOVZWL	UCB$W_XE_BSZ(R5),R1	; Get size of receive buffer	
	MOVZWL	UCB$W_XE_HBQ(R5),R4	; Get device buffer quota
	DIVL	R1,R4			; Compute number of buffers to allocate
	INCL	R4			; Plus one extra
	CLRL	-(SP)			; End of list marker
145$:	JSB	G^EXE$ALONONPAGED	; Allocate the memory
	BLBC	R0,150$			; Br on error
	MOVW	R1,IRP$W_SIZE(R2)	; Save size of buffer
	MOVB	#DYN$C_CXB,IRP$B_TYPE(R2) ; Set structure type
	MOVL	R2,-(SP)		; Save buffer address
	SOBGTR	R4,145$			; Loop if more to allocate

150$:	MOVL	(SP)+,R0		; Get buffer address
	BEQL	155$			; Br if end of list
	JSB	G^EXE$DEANONPAGED	; Deallocate the block
	BRB	150$			; Try for more
155$:	POPQ	R3			; Restore R3, R4

	BSBW	ADD_MULTI		; Compile a new multicast address list
	BLBS	R0,190$			; Br if all okay

	ASSUME	NMA$C_STATE_ON EQ 0
	ASSUME	NMA$C_STATE_OFF EQ 1

	BLBS	UCB$B_XE_PRM(R5),160$	; Br if NOT a PROMISCUOUS user
	CLRL	CDB_L_PRMUSER(R4)	; Else, clear the PROMISCUOUS user addr
160$:	CLRBIT	#UCB$V_XE_INITED,-	; Indicate unit is not initialized
		UCB$W_DEVSTS(R5)	;	...
	ADDL	R7,JIB$L_BYTCNT(R6)	; Restore quota
	ADDL	R7,JIB$L_BYTLM(R6)	; ..and byte limit
170$:	MOVZWL	#NMA$C_PCLI_MCA,R1	; Indicate bad multicast address
	BRW	120$			; Return in error
;
; Change mode request - might have to reset multicast address list
;
180$:	ASSUME	UCB$V_XE_INITED  EQ  0
	BLBS	UCB$W_DEVSTS(R5),185$	; Br if unit inited
	BRW	10$			; Else, success

185$:	SETIPL	UCB$B_FIPL(R5)		; Sync access to UCB and CDB
	BSBW	ADD_MULTI		; Compile global multicast address list
	BLBC	R0,170$			; Br if error
	MOVB	#XE_FC_V_MULTI,IRP$B_XE_FUNC(R3) ; Set function request
190$:	BRW	QUEPKT			; Queue packet to driver

;+
; Take quota subroutine
;
;	Calculate buffer quota and check against user's quota
;
; Inputs:	R7 = Scratch
;		R6 = Scratch
;		R5 = UCB address
;		R4 = PCB address
;
;
; Outputs:	R7 = Quota taken
;		R6 = JIB address
;		R5 = UCB address
;		R4 = PCB address
;		R0 = Status
;
;	R1,R2 are destroyed.
;
; Implicit outputs:
;
;	BR to ABORTIO if quota is exceeded.
;
;-
TAKE_QUOTA:
	CLRL	R0			; Assume failure
	INCW	UCB$W_XE_BSZ(R5)	; Round buffer size to even value
	BICW	#1,UCB$W_XE_BSZ(R5)	;	...
	MOVZBL	UCB$B_XE_BFN(R5),R1	; Get number of receive buffers
	MOVZWL	UCB$W_DEVBUFSIZ(R5),R2	; Get buffer size
	MULL	R2,R1			; Get needed quota
	MOVZWL	R1,R7			; Copy quota
	CMPL	R1,R7			; Overflow?
	BNEQ	110$			; Br if yes - error
	MOVL	PCB$L_STS(R4),-(SP)	; Save current PCB status
	SETBIT	#PCB$V_SSRWAIT,-	; Do not go into a resource wait
		PCB$L_STS(R4)		;   just to check the quota
	PUSHL	R3			; Save R3
	JSB	G^EXE$BUFQUOPRC		; Check quota
	POPL	R3			; Restore R3
	MOVL	(SP)+,PCB$L_STS(R4)	; Restore previous PCB status
	BLBS	R0,50$			; Br if success
	BRB	80$			; Else, return error

50$:	MOVL	PCB$L_JIB(R4),R6	; Get JIB address
	SUBL	R7,JIB$L_BYTCNT(R6)	; Adjust quota
	SUBL	R7,JIB$L_BYTLM(R6)	; ..and byte limit
	MOVZBL	#1,R0			; Indicate success
80$:	CLRL	R1			; No error return
90$:	RSB

110$:	MOVZBL	#SS$_BADPARAM,R0	; Setup error code
	MOVZWL	#NMA$C_PCLI_BFN,R1	; Assume BAD BFN
	BRB	90$			; Return error

;+
; CHECK_QUOTA - check SHARED unit's quota
;
; Inputs:	R9 = Scratch
;		R7 = Original UCB address
;		R5 = UCB address
;		R4 = PCB address
;
;
; Outputs:	R9 = Quota taken
;		R7 = Original UCB address
;		R5 = UCB address
;		R4 = PCB address
;		R0 = Status
;
;	R1,R2 are destroyed.
;
;-
CHECK_QUOTA:
	PUSHQ	R6			; Save R6, R7
	PUSHL	R5			; Save UCB address
	MOVL	R7,R5			; Copy original UCB address
	BSBB	TAKE_QUOTA		; Charge quota to user
	POPL	R5			; Restore UCB address
	BLBC	R0,90$			; Br if error
	MOVL	R7,R9			; Copy quota taken
	MOVZWL	UCB$W_XE_TOTQUO(R5),R1	; Get total quota
	ADDL	R9,R1			; Compute new total
	MOVZWL	R1,R0			; Copy quota
	CMPL	R1,R0			; Overflow?
	BNEQ	110$			; Br if yes, error
	MOVZBL	#1,R0			; Else, return success
90$:	POPQ	R6			; Retore R6, R7
	RSB				; Return to caller

110$:	ADDL	R9,JIB$L_BYTCNT(R6)	; Restore quota
	ADDL	R9,JIB$L_BYTLM(R6)	; ..and byte limit
	MOVZWL	#SS$_EXQUOTA,R0		; Return bad quota
	CLRL	R1			; No parameter return
	BRB	90$			; Exit with error


	.SBTTL	SHR_UCB - CREATE SHARED UCB
;++
; SHR_UCB - CREATE SHARED UCB
;
; Functional description:
;
; This subroutine creates a shared UCB if this is the first SHARED user of the
; particular protocol type.  Else, the already created SHARED UCB is found and
; a shared data structure is added to the list of shared users of that protocol
; type.
;
; Inputs:
;
;	R3 = IRP address
;	R4 = PCB address
;	R5 = UCB address
;	R6 = CCB address
;	R7 = Function code
;	AP = Address of first function-dependent QIO parameter
;
;	IPL = FIPL
;
; Outputs:
;
;	R0 = Status return for request
;	R1 = Bad parameter code (if bad parameter error code)
;	R2,R7 are destroyed.
;	All other registers are preserved.
;
;	IPL = ASTDEL
;
;--

SHR_UCB::				; Setup shared protocol UCB
	PUSHR	#^M<R8,R9>		; Save registers
	JSB	G^SCH$IOLOCKW		; Lock I/O data base for write access
	MOVL	R5,R7			; Save UCB address
	MOVZWL	#SS$_DUPUNIT,R0		; Assume 2 channels assigned to UCB
	CMPW	#1,UCB$W_REFC(R5)	; Is there only one reference to UCB?
	BNEQ	23$			; Br if not, error (more than 1 channel)
	MOVZBL	UCB$B_XE_ACC(R5),R8	; Save access mode
	BBS	#UCB$V_XE_SHARE,-	; Br if we are already the SHARED UCB
		 UCB$W_DEVSTS(R5),10$	;
	PUSHL	R4			; Save PCB address
	MOVL	UCB$L_XE_CDB(R5),R4	; Get CDB address
	MOVW	UCB$W_XE_PROTYP(R5),R1	; Get protocol type
	BSBW	MATCH_PROTYP		; Try to match protocol type
	POPL	R4			; Restore PCB address
	BLBS	R0,10$			; Br if found
	MOVL	R7,R5			; Else, get back old UCB address
	CLRL	UCB$L_PID(R5)		; Make this UCB shareable
	MOVL	UCB$L_ORB(R5),R0	; Get the ORB address
	CLRL	ORB$L_OWNER(R0)		;  clear owner UIC as well
	CLRL	UCB$L_XE_DEFUSR(R5)	; Clear default user
	BISW	#UCB$M_XE_SHARE,-	; Indicate that UCB is in SHARED mode
		 UCB$W_DEVSTS(R5)	;
;
; Allocate a share data structure and link it in
;
10$:	CMPB	#NMA$C_ACC_LIM,R8	; Is the new user a limited user?
	BEQL	20$			; Br if yes - okay
	MOVZWL	#SS$_DEVALLOC,R0	; Assume protocol already allocated
	TSTL	UCB$L_XE_DEFUSR(R5)	; Is there already a default user?
	BNEQ	23$			; Br if YES - error
20$:	BSBW	CHECK_PARAM		; Check out all parameters
	BLBC	R0,25$			; Br on error
	BSBW	CHECK_QUOTA		; Check our quota
	BLBC	R0,25$			; Br if error
	MOVZBL	#SHR_C_LENGTH,R1	; Get size of structure to allocate
	PUSHL	R3			; Save IRP address
	JSB	G^EXE$ALLOCBUF		; Allocate buffer, reset IPL to ASTDEL
	POPL	R3			; Restore IRP address
	BLBS	R0,30$			; Br if success
	MOVZWL	#SS$_INSFMEM,R0		; Else, return error reason
	MOVL	PCB$L_JIB(R4),R1	; Get JIB address
	ADDL	R9,JIB$L_BYTCNT(R1)	; Restore quota
	ADDL	R9,JIB$L_BYTLM(R1)	; ..and byte limit
23$:	CLRL	R1			; No bad parameter code
25$:	MOVL	R7,R5			; Get back the OLD UCB address
	BRW	80$			; Exit with error
;
; Initialize shared (SHR) data structure
;
30$:	ASSUME	SHR_L_QFL EQ 0
	ASSUME	SHR_L_QBL EQ SHR_L_QFL+4
	CLRQ	(R2)+			; Zero LINK pointers
	ASSUME	SHR_W_SIZE EQ SHR_L_QBL+4
	MOVW	R1,(R2)+		; Save size
	ASSUME	SHR_B_TYPE EQ SHR_W_SIZE+2
	INCL	R2			; Filled by EXE$ALLOCBUF routine
	ASSUME	SHR_B_STS EQ SHR_B_TYPE+1
	MOVB	#SHR_STS_M_INITED,(R2)+	; Initialize SHR status
	ASSUME	SHR_L_PID EQ SHR_B_STS+1
	MOVL	IRP$L_PID(R3),(R2)+	; Save users PID and CHAN for
	ASSUME	SHR_W_CHAN EQ SHR_L_PID+4
	MOVW	IRP$W_CHAN(R3),(R2)+	;  for future lookups
	ASSUME	SHR_G_DEST EQ SHR_W_CHAN+2
	MOVL	UCB$G_XE_DES(R7),(R2)+	; Save destination address
	MOVW	UCB$G_XE_DES+4(R7),(R2)+ ;
	ASSUME	SHR_Q_QUEUES EQ SHR_G_DEST+6
	MOVZBL	#SHR_C_QUEUES,R1	; Get number of queues in structure
40$:	MOVAL	(R2),(R2)+		; Set forward link pointer
	MOVL	-4(R2),(R2)+		; Set backward link pointer
	SOBGTR	R1,40$			; Loop if more listheads
	ASSUME	SHR_W_QUOTA EQ SHR_Q_QUEUES+<8*SHR_C_QUEUES>
	MOVW	R9,(R2)+		; Initialize quota

	ASSUME	UCB$V_XE_INITED EQ 0
	BLBC	UCB$W_DEVSTS(R5),50$	; Br if UCB not initialized
	ADDW	R9,UCB$W_XE_QUOTA(R5)	; Add to the current quota
	ADDW	R9,UCB$W_XE_TOTQUO(R5)	;  and the total quota
	BRB	55$			; Continue
50$:	MOVW	R9,UCB$W_XE_QUOTA(R5)	; Set current quota
	MOVW	R9,UCB$W_XE_TOTQUO(R5)	;  and total quota
55$:	SUBL	#SHR_C_LENGTH,R2	; Backup to beginning of structure
	CMPB	#NMA$C_ACC_LIM,R8	; Is this for limited use?
	BEQL	60$			; Br if YES
	MOVL	R2,UCB$L_XE_DEFUSR(R5)	; Else, save default user address
	BRB	65$			; Skip linking onto list
60$:	INSQUE	(R2),@UCB$Q_XE_SHARE+4(R5) ; Link user into shared user list
65$:	INCW	UCB$W_REFC(R5)		; Increment the ref count on the
					;   UCB to be used
	CMPL	R5,R7			; Was this the original UCB?
	BEQL	70$			; Br if YES - no more work to do
	INCW	UCB$W_REFC(R5)		; Else, increment REFC (for $DASSGN)
	MOVL	R5,IRP$L_UCB(R3)	; Return new UCB address
	MOVL	R5,CCB$L_UCB(R6)	;  in CCB also.
	PUSHR	#^M<R3,R5>		; Save IRP, real UCB address
	MOVL	R7,R5			; Copy old UCB address
	DECW	UCB$W_REFC(R5)		; Decrement the reference count
	JSB	G^IOC$CREDIT_UCB	; Restore UCB quota to JIB
	JSB	G^IOC$DELETE_UCB	; Delete the old UCB
	POPR	#^M<R3,R5>		; Restore IRP, UCB address
70$:	MOVZBL	S^#SS$_NORMAL,R0	; Return success
80$:	POPR	#^M<R8,R9>		; Restore registers, R4 is PCB address
	PUSHR	#^M<R0,R1,R3>		; Save IRP address, status return
	JSB	G^SCH$IOUNLOCK		; Unlock I/O data base
	POPR	#^M<R0,R1,R3>		; Restore IRP address, status return
	RSB				; Return to caller

	.SBTTL	CHECK_PARAM - CHECK SHARED USERS PARAMETERS
;++
; CHECK_PARAM - CHECK SHARED USERS PARAMETERS
;
; Functional description:
;
; Validate all parameters between the requesting SHARED user and the old
; existing SHARED user to make sure that are the same.
;
; Inputs:
;	R5 = UCB address of existing shared user
;	R7 = UCB address of new shared user
;	R8 = Protocol access mode
;
; Outputs:
;	R0 = Status of request
;	R1 = Bad parameter code if validation failed
;
;--

CHECK_PARAM:				; Check user parameters
	PUSHL	R6			; Save registers
	MOVAB	UCB$B_XE_SHRPRM(R5),R0	; Get address of current parameters
	MOVAB	UCB$B_XE_SHRPRM(R7),R6	; Get address of new parameters
	MOVZBL	#UCB$C_XE_SHRPRM,R2	; Set size of parameter list
;
; Validate all user settable parameters except for Physical address
;
10$:	CMPB	(R0),(R6)		; Match?
	BNEQ	70$			; Br if no
	MOVB	(R0)+,(R6)+		; Store current value in UCB
	SOBGTR	R2,10$			; Loop if more to check
;
; NOW, check if user has given a hardware physical address.
;
;	R0 = Address of parameters in UCB
;	R6 = Address of parameters in CDB
;
	ASSUME	CDB_G_PHA EQ CDB_B_ILP+1
	ASSUME	UCB$G_XE_PHA EQ UCB$B_XE_ILP+1
	CMPL	#-1,(R6)		; Is user physical address defined?
	BNEQ	20$			; Br if yes
	CMPW	#-1,4(R6)		; Is user physical address defined?
	BEQL	30$			; Br if not
20$:	MOVZWL	#NMA$C_PCLI_PHA,R1	; Assume bad physical address
	CMPL	(R0)+,(R6)+		; Physical address match??
	BNEQ	80$			; Br if no
	CMPW	(R0)+,(R6)+		; Still match??
	BNEQ	80$			; Br if no
;
; If this is the shared default user, then set the multicast address list.
;
30$:	BSBW	SET_MULTIN		; Set new multicast address list
	BRB	100$			; Exit
;
; Error on parameter validation
;
70$:	MOVZWL	BAD_PARAM_TBL-2[R2],R1	; Return parameter code
80$:	MOVZBL	S^#SS$_BADPARAM,R0	; Return bad parameter error
100$:	POPL	R6			; Restore registers
	RSB

	.SBTTL	SET_MULTIN - SET NEW MULTICAST ADDRESS LIST IN UCB
;++
; SET_MULTIN - SET NEW MULTICAST ADDRESS LIST IN UCB
;
; Functional description:
;
; Copy the multicast address list from the old UCB to the new UCB.
; This operation is only done for the SHARED DEFAULT user of the PROTOCOL.
;
; Inputs:
;	R5 = UCB address of existing shared user
;	R7 = UCB address of new shared user
;	R8 = Protocol access mode
;
; Outputs:
;	R0 = Always success
;	All other are preserved.
;
;--

SET_MULTIN:				; Set new multicast list
	CMPB	#NMA$C_ACC_SHR,R8	; Is this the shared default user?
	BNEQ	50$			; Br if not
	PUSHR	#^M<R1,R2,R3,R4,R5>	; Save registers
	MOVC3	#6*MAX_C_MLT,UCB$G_XE_MULTI(R7), - ; Copy multicast list
		UCB$G_XE_MULTI(R5)	;
	POPR	#^M<R1,R2,R3,R4,R5>	; Restore registers
	MOVB	UCB$B_XE_MULTI(R7),-	; Copy the number of valid addresses
		UCB$B_XE_MULTI(R5)	;
50$:	MOVZBL	#SS$_NORMAL,R0		; Return success
	RSB				; Return to caller

	.SBTTL	SENSEMODE_FDT - SENSEMODE I/O FDT PROCESSING
;++
; SENSEMODE_FDT - SENSEMODE I/O FDT PROCESSING
;
; Functional description:
;
; Process read status and read counters requests.
;
; The QIO parameters for SENSEMODE are:
;
;	P1 = Optional address of quadword buffer
;	P2 = Optional address of buffer descriptor for extended characteristics
;
; The SUBFUNCTION modifiers are as follows:
;
; 1)	READ PARAMETERS -- NO MODIFIER.
;	This function reads the DEUNA/DELUA parameters and returns them to the 
;	user.
;
; 2)	READ COUNTERS -- IO$M_RD_COUNT SET.
;	This function reads the DEUNA/DELUA counters and returns them to the 
;	user.
;
;	CLEAR COUNTERS -- IO$M_CLR_COUNT SET.
;	This modifier must be used with the read counters modifier to clear
;	the counters as they are read.
;
;
; Inputs:
;
;	R3 = IRP address
;	R4 = PCB address
;	R5 = UCB address
;	R6 = CCB address
;	R7 = Function code
;	AP = Address of first function-dependent QIO parameter
;
;	IPL = ASTDEL
;
; Outputs:
;
;	R0 = Status return of SENSEMODE request
;
;	R1,R2,R6,R7 are destroyed.
;
;--

SENSEMODE_FDT::				; SENSE MODE I/O FDT processing
	MOVZWL	#SS$_DEVOFFLINE,R0	; Assume unit if offline
	BBC	#UCB$V_ONLINE,-		; Br if unit not online
		UCB$W_STS(R5),15$	;
	MOVW	IRP$W_FUNC(R3),R7	; Get entire function code
	BBS	#IO$V_CTRL,R7,5$	; Br if line request
;
; Check if read circuit counters
;
	BBC	#IO$V_RD_COUNT,R7,3$	; Br if not read circuit counters
	BRW	READ_CIRC_CTR		; Else, get the circuit counters
3$:	MOVZBL	S^#SS$_NORMAL,R0	; Return success
	MOVL	UCB$L_DEVDEPEND(R5),R1	; Get device dependent information
	JMP	G^EXE$FINISHIO		; Complete the I/O request

5$:	BBC	#IO$V_RD_COUNT,R7,20$	; Br if not read counters
;
; Read counters - modifier RD_COUNT
;
	BSBW	CHECK_P2		; Check P2 buffer
	MOVZBL	S^#SS$_BADPARAM,R0	; Assume zero length buffer
	MOVW	R1,IRP$W_XE_USERSIZ(R3)	; Save user size of P2 buffer
	BEQL	15$			; Br if none
	MOVZBL	#LINE_CNT_BUFSIZ-	; Get size of counter P2 buffer
		+LINE_CTR_BUFSIZ,R1	;
	BSBW	ALLOC_P2BUF		; Allocate a buffer
	BLBC	R0,15$			; Br if error
	MOVL	IRP$L_SVAPTE(R3),R1	; Get system P2 buffer addr
	MOVL	R2,P2B_L_BUFFER(R1)	; Save user's P2 buffer addr
	MOVW	S^#SS$_NORMAL,IRP$W_XE_STATUS(R3) ; Assume success
	MOVB	S^#XE_FC_V_RDCNTS,IRP$B_XE_FUNC(R3) ; Assume Read counts
	BBC	#IO$V_CLR_COUNT,R7,10$	; Br if not clear counts
	MOVB	S^#XE_FC_V_RCCNTS,IRP$B_XE_FUNC(R3) ; Else, Read and Clear
10$:	BRW	QUEPKT			; Queue packet to driver
15$:	BRW	ABORTIO			; Abort the I/O request
;
; Read parameters - no modifier
;
20$:	CLRW	IRP$W_XE_P2SIZ(R3)	; No return data
	MOVL	UCB$L_XE_CDB(R5),R4	; Get CDB address
	MOVZWL	S^#8,R1			; Size of P1 buffer if present
	BSBW	CHECK_BUFS		; Check P1 and P2 buffers
	MOVZBL	S^#SS$_NORMAL,R0	; Assume success
	MOVW	R0,IRP$W_XE_STATUS(R3)	;	...
	MOVW	R1,IRP$W_XE_USERSIZ(R3)	; Save user P2 buffer length
	BEQL	40$			; Br if no P2 buffer present

	MOVL	R2,IRP$L_XE_P2BUF(R3)	; Save user P2 buffer address
	BSBW	RETURN_P2		; Return the P2 parameters
	MOVW	R0,IRP$W_XE_P2SIZ(R3)	; Set size of return data
	TSTL	R4			; Is CDB present?
	BEQL	30$			; Br if no - okay to return now
	ADDL3	S^#10,R0,R1		; Check if default physical
					;  address can fit
	CMPW	R1,IRP$W_XE_USERSIZ(R3) 	; Is buffer big enough for
					; default physical address?
	BGTRU	25$			; Br if no
	ADDW	#10,IRP$W_XE_P2SIZ(R3)	; Add DPA to return buffer size
	ADDL3	R0,IRP$L_XE_P2BUF(R3),R2	; Get buffer address
					; past end of return data
	MOVL	#<6@16>+NMA$C_PCLI_HWA!-; Store parameter code + size
		PRM_TYP_M_STRING,(R2)+ 	;  ..indicate string parameter
	MOVL	CDB_G_HWA(R4),(R2)+	; Store Default Physical Address
	MOVW	CDB_G_HWA+4(R4),(R2)+	; 
	BRB	30$			; All is okay
25$:	MOVW	#SS$_BUFFEROVF,IRP$W_XE_STATUS(R3) ; Return partial success
30$:	MOVZWL	IRP$W_XE_P2SIZ(R3),R0	; Get size of user return data
	ASHL	#16,R0,R0		; Shift size of buffer return
	MOVW	IRP$W_XE_STATUS(R3),R0	; Get status
 
40$:	TSTL	R4			; Is there a CDB?
	BEQL	50$			; Br if no CDB yet!
	MOVL	IRP$L_XE_USERBUF(R3),R2	; Retrieve P1 buffer address
	BEQL	50$			; Br if none
	MOVQ	UCB$B_DEVCLASS(R5),(R2)	; Else, return characteristics
	BISL	CDB_L_DEVDEPEND(R4),4(R2) ;	...
	MOVL	CDB_L_DEVDEPEND(R4),R1	; Get device dependent info
50$:	BISL	UCB$L_DEVDEPEND(R5),R1	; ..from UCB also
	JMP	G^EXE$FINISHIO		; Complete the I/O request

;
; Queue I/O request to driver
;
QUEPKT:					; Queue packet to driver
	SETIPL	UCB$B_FIPL(R5)		; Raise IPL to fork IPL
	JSB	G^IOC$INITIATE		; Intiate the I/O request
	JMP	G^EXE$QIORETURN		; Lower IPL, and RET

	.SBTTL	READ_CIRC_CTR - READ THE CIRCUIT COUNTERS
;++
; READ_CIRC_CTR - READ THE CIRCUIT COUNTERS
;
; Functional description:
;
; Process read circuit counters request.
;
; The QIO parameters for SENSEMODE are:
;
;	P2 = Address of buffer descriptor for counters
;
;
; Inputs:
;
;	R3 = IRP address
;	R4 = PCB address
;	R5 = UCB address
;	R6 = CCB address
;	R7 = Function code and modifier bits
;	AP = Address of first function-dependent QIO parameter
;
; Outputs:
;
;	R0 = Status return of SENSEMODE request
;
;	R1,R2,R6,R7 are destroyed.
;
;--

ABORT_IRP:
	BRW	ABORTIO			; Abort the I/O request

READ_CIRC_CTR:				; Read the circuit counters
	BSBW	CHECK_P2		; Check the P2 buffer
	MOVZBL	S^#SS$_BADPARAM,R0	; Assume zero length buffer
	MOVW	R1,IRP$W_XE_USERSIZ(R3)	; Save size of user P2 buffer
	BEQL	ABORT_IRP		; Br if no buffer
	MOVZBL	#CIRC_CTR_BUFSIZ,R1	; Get size of system P2 buffer
	BSBW	ALLOC_P2BUF		; Allocate the buffer
	BLBC	R0,ABORT_IRP		; Br if error
	MOVL	IRP$L_SVAPTE(R3),R1	; Get system P2 buffer address
	MOVL	R2,P2B_L_BUFFER(R1)	; Save user P2 buffer address
	MOVL	P2B_L_POINTER(R1),R2	; Get address of data portion of buffer
	PUSHQ	R8			; Save R8, R9
;
; Get the counters kept by the driver
;
	MOVAB	CIRC_CTR,R8		; Get address of counter format table
	MOVZBL	#CIRC_CTR_SIZE,R1	; Get number of entries in table
20$:	MOVZWL	(R8)+,R0		; Get counter code
	MOVW	R0,(R2)+		; Return counter type code
	MOVZWL	(R8)+,R9		; Get offset word
	ADDL	R5,R9			; Point to counter in UCB
	EXTZV	#NMA$V_CNT_MAP,#3,R0,R0	; Get width + bit map indicator
	CASE	R0,TYPE=B,LIMIT=#2,<-	; Dispatch on width and bit map
		30$,-			; 8 bit counter
		30$,-			; 8 bit counter + bit map
		40$,-			; 16 bit counter
		30$,-			; 16 bit counter + bit map
		35$>			; 32 bit counter

30$:	BUG_CHECK NOBUFPCKT,FATAL	; All others, fatal error
;
; 32 BIT counter
;
35$:	MOVW	(R9)+,(R2)+		; Store counter in buffer
	BBC	#IO$V_CLR_COUNT,R7,40$	; Br if not clear counter operation
	CLRW	-2(R9)			; Else, clear the counter as well
;
; 16 BIT counter
;
40$:	MOVW	(R9),(R2)+		; Store counter in buffer
	BBC	#IO$V_CLR_COUNT,R7,50$	; Br if not clear counter operation
	CLRW	(R9)			; Else, clear the counter as well
50$:	SOBGTR	R1,20$			; Loop if more
	POPQ	R8			; Restore R8, R9
	MOVZBL	S^#SS$_NORMAL,R1	; Assume success
	CMPW	IRP$W_XE_USERSIZ(R3),-	; Is user's buffer big enough?
		IRP$W_BCNT(R3)		;
	BGEQU	60$			; Br if yes
	MOVW	IRP$W_XE_USERSIZ(R3),-	; Else, set size to minimum
		IRP$W_BCNT(R3)		; Of both
	MOVW	#SS$_BUFFEROVF,R1	; Set partial success
60$:	MOVL	IRP$W_BCNT-2(R3),R0	; Get size of buffer returned in
					; ..high word of R0
	MOVW	R1,R0			; Get status return
	MOVL	UCB$L_DEVDEPEND(R5),R1	; Get device dependent info
	JMP	G^EXE$FINISHIO		; Complete the I/O request

	.SBTTL	DIAGNOSE_FDT - DIAGNOSTIC OPERATION FDT DISPATCH ROUTINE
;++
; DIAGNOSE_FDT - DIAGNOSTIC FDT PROCESSING
;
; Functional description:
;
; This is the fdt routine for diagnostic functions.
; There are several functions based on function code passed in P3 of the
; parameter list.
;
; The QIO parameters for DIAGNODE are:
;
;	P1 = Optional address of a diagnostic buffer
;	P2 = Optional length of the diagnostic buffer
;	P3 = Diagnost function code
;	R4 = Optional address of DEUNA/DELUA micro-processor internal address
;
;
; Inputs:
;
;	R3 = IRP ADDRESS
;	R4 = PCB ADDRESS
;	R5 = UCB ADDRESS
;	R6 = CCB ADDRESS
;	R7 = FUNCTION CODE
;	AP = ADDRESS OF THE FIRST QIO PARAMETER
;
;	IPL = ASTDEL
;
; Outputs:
;
;	R3 = IRP ADDRESS
;	R4 = PCB ADDRESS
;	R5 = UCB ADDRESS
;
;	R0-R2,R6 are destroyed.
;
;--

DIAGNOSE_FDT::				; DIAGNOSE FDT processing
	CLRL	IRP$L_SVAPTE(R3)	; Set no buffered packet
	CLRQ	IRP$L_MEDIA(R3)		; Reset mode data area
	MOVZWL	#SS$_DEVOFFLINE,R0	; Assume unit is offline
	BBC	#UCB$V_ONLINE,-		; Br if unit not online
		UCB$W_STS(R5),DG_ERR	;
	MOVZBW	S^#SS$_NORMAL,IRP$W_XE_STATUS(R3) ; Assume success
	MOVZBL	P3(AP),R1		; Get Diagnostic function
	$DISPATCH	R1,TYPE=B,-	; Distpatch on function code
	<-	;function	action

		<XE$C_DG_LOADMEM LOADMEM>,- ; Load DEUNA/DELUA memory
		<XE$C_DG_READMEM READMEM>,- ; Read DEUNA/DELUA memory
		<XE$C_DG_UPADDR  UPADDR>,-  ; Load and start micro-processor
		<XE$C_DG_WRITEID WRITEID>,- ; Write SYSTEM ID parameters
		<XE$C_DG_READID  READID>,-  ; Read SYSTEM ID parameters
		<XE$C_DG_STOP	 STOPPR>,-  ; Stop xmit and receive process
		<XE$C_DG_STEST   STEST>,-   ; Perfore a self test
		<XE$C_DG_READST  READST>,-  ; Read port status
		<XE$C_DG_ESTEST	 ESTEST>,-  ; Perform a DELUA self test
		<XE$C_DG_HALT    HALT>,-    ; Halt port (DELUA only)
	>
;
; All other functions
;
DG_ERR1:
	MOVZBL	#SS$_BADPARAM,R0	; Bad parameter
DG_ERR:	BRW	ABORTIO			; Abort the I/O
;
; Load DEUNA/DELUA memory
;
;	P1 = Address of buffer to write micro-code into DEUNA/DELUA.
;	P2 = Length of P1 buffer
;	P4 = Internal DEUNA/DELUA address to start loading at
LOADMEM:
	BSBW	CHECK_DGBUFR		; Check buffer for read access
	MOVW	P4(AP),IRP$L_XE_UPADR(R3) ; Save micro-processor address
	BLBS	IRP$L_XE_UPADR(R3),DG_ERR1 ; Br if bad address
	MOVB	#XE_FC_V_LDMEM,IRP$B_XE_FUNC(R3) ; Set function request
	BRW	QUEPKT			; Queue request to driver
;
; Read DEUNA/DELUA memory
;
;	P1 = Address of buffer to read DEUNA/DELUA memory into
;	P2 = Length of P1 buffer
;	P4 = Internal DEUNA/DELUA address to start reading at
READMEM:
	BSBW	CHECK_DGBUFW		; Check buffer for write access
	MOVW	P4(AP),IRP$L_XE_UPADR(R3) ; Save micro-processor address
	BLBS	IRP$L_XE_UPADR(R3),DG_ERR1 ; Br if bad address
	MOVB	#XE_FC_V_RDMEM,IRP$B_XE_FUNC(R3) ; Set function request
	BRW	QUEPKT			; Queue request to driver
;
; Load and start at micro-processor address
;
;	P1 = unused
;	P2 = unused
;	P4 = Internal DEUNA/DELUA address to start at
UPADDR:
	MOVW	P4(AP),IRP$L_XE_UPADR(R3) ; Save micro-processor address
	BLBS	IRP$L_XE_UPADR(R3),DG_ERR1 ; Br if bad address
	MOVB	#XE_FC_V_UPST,IRP$B_XE_FUNC(R3) ; Set function request
	BRW	QUEPKT			; Queue request to driver
;
; Write SYSTEM ID parameters
;
;	P1 = Address of buffer containing new SYSTEM ID parameters
;	P2 = Length of P1 buffer
;	P4 = unused
WRITEID:
	BSBW	CHECK_DGBUFR		; Check buffer for read access
	MOVZBL	#SS$_BADPARAM,R0	; Assume bad parameter
	CMPW	#8,IRP$W_BCNT(R3)	; Is buffer size good?
	BLEQU	10$			; Br if yes
	BRW	ABORTIO			; Else, abort the I/O request
10$:	MOVB	#XE_FC_V_LDSID,IRP$B_XE_FUNC(R3) ; Set function request
	BRW	QUEPKT			; Queue request to driver
;
; Read SYSTEM ID parameters
;
;	P1 = Address of buffer for reading SYSTEM ID parameters
;	P2 = Length of P1 buffer
;	P4 = unused
READID:
	BSBW	CHECK_DGBUFW		; Check buffer for write access
	MOVB	#XE_FC_V_RDSID,IRP$B_XE_FUNC(R3) ; Set function request
	BRW	QUEPKT			; Queue request to driver
;
; Stop transmit and receive process
;
;	P1 = unused
;	P2 = unused
;	P4 = unused
STOPPR:
	MOVB	#XE_FC_V_STOPPR,IRP$B_XE_FUNC(R3) ; Set function request
	BRW	QUEPKT			; Queue request to driver
;
; Perform a DEUNA/DELUA self test
;
;	P1 = unused
;	P2 = unused
;	P4 = unused
STEST:
	MOVB	#XE_FC_V_STEST,IRP$B_XE_FUNC(R3) ; Set function request
	BRW	QUEPKT			; Queue request to driver
;
; Read port status
;
;	P1 = Address of buffer for reading the port status
;	P2 = unused
;	P4 = unused
READST:
	MOVZBL	#8,R1			; Set size of buffer
	BSBW	CHECK_DGBUFA		; Check buffer for write access
	MOVB	#XE_FC_V_READST,IRP$B_XE_FUNC(R3) ; Set function request
	BRW	QUEPKT			; Queue request to driver
;
; Perform a DELUA extended self test
;
;	P1 = unused
;	P2 = unused
;	P4 = unused
;
ESTEST:
	MOVZBL	UCB$B_TYPE(R5),R1
	$DISPATCH	R1,TYPE=B,-	; Dispatch based upon device type
	< -
		<DT$_DEUNA	10$>,-	; DEUNA - error
		<DT$_DELUA	20$>,-	; DELUA - ok to do the test
	>
10$:	BRW	DG_ERR1			; Go return bad parameter error

20$:	MOVB	#XE_FC_V_ESTEST,IRP$B_XE_FUNC(R3) ; Set function request
	BRW	QUEPKT			; Queue request to driver

;
; Halt the DELUA Port
;
;	P1 = unused
;	P2 = unused
;	P4 = unused
;
HALT:
	MOVB	UCB$B_TYPE(R5),R1
	$DISPATCH	R1,TYPE=B,-	; Dispatch based upon device type
	< -
		<DT$_DEUNA	10$>,-	; DEUNA - error
		<DT$_DELUA	20$>,-	; DELUA - ok to do the test
	>
10$:	BRW	DG_ERR1			; Go return bad parameter error

20$:	MOVZBL	#XE_FC_V_HALT,IRP$B_XE_FUNC(R3) ; Set function request
	BRW	QUEPKT			; Queue request to driver

	.SBTTL	GET_CHAR_BUF - GET P2 CHARACTERISTICS BUFFER
;++
; GET_CHAR_BUF - GET P2 CHARACTERISTICS BUFFER
;
; Functional description:
;
; This routine saves the P2 buffer for later use by the driver.
; The P2 buffer is saved by allocating the appropriate amount of memory from
; non-paged pool.   The user's quota is checked before the allocation is made.
; And the non-paged pool buffer is charged against the user's quota. The P2
; system buffer address is passed in IRP$L_SVAPTE of the IRP.
;
;
; Inputs:
;
;	R3 = IRP address
;	R4 = PCB address
;	R5 = UCB address
;
; Outputs:
;
;	R0 = status of buffers
;
;	R3-R5 are preserved.
;
;--
 
GET_CHAR_BUF:					; Get characteristics buffer
;
; Check access to P2 buffer and check process's buffer quota
;
10$:	MOVL	P2(AP),R1			; Get address P2 char buf desc
	BEQL	40$				; Br if no P2 buffer
	PUSHL	R3				; Save R3
	JSB	G^EXE$PROBER_DSC		; Check access to buffer
	BLBC	R0,15$				; Br if error
	MOVZWL	R1,R1				; Convert length to longword
	PUSHL	R2				; Save R2
	JSB	G^EXE$BUFQUOPRC			; Check for buffered quota
	POPL	R2				; Restore R2
15$:	POPL	R3				; Restore R3
	BLBS	R0,30$				; Branch if quota ok
20$:	RSB					; Return
 
;
; Quota OKAY, allocate buffer and copy info.
;
30$:	BSBW	ALLOC_P2BUF			; Allocate buffer
	BLBC	R0,50$				; Br if error
	MOVL	IRP$L_SVAPTE(R3),R0		; Get P2 buffer address
	PUSHR	#^M<R3,R4,R5>			; Save sacred registers
	MOVC3	R1,(R2),P2B_T_DATA(R0)		; Save P2 char buffer
	POPR	#^M<R3,R4,R5>			; Restore registers
40$:	MOVZBL	S^#SS$_NORMAL,R0		; Set success
50$:	RSB					; Return

	.SBTTL	CHECK_BUFS - CHECK P1 AND P2 BUFFERS FOR WRITE ACCESS
;++
; CHECK_BUFS - CHECK P1 AND P2 BUFFERS FOR WRITE ACCESS
;
; Functional description:
;
; This routines checks the P1 and P2 buffers for write access if supplied.
;
; Inputs:
;
;	R1 = Size of P1 buffer needed for write access
;	R3 = IRP address
;	R4 = PCB address
;	R5 = UCB address
;	R7 = Function code
;
; Outputs:
;
;	R0 is destroyed.
;	R1 = Length of P2 buffer (zero if no P2 buffer)
;	R2 = Address of P2 buffer in user's process space
;
;
;	No RETURN on NO ACCESS
;
; Implicit Outputs:
;
;	IRP$V_FUNC bit set in IRP$W_STS by EXE$READCHK subroutine.
;
;--
 
CHECK_BUFS:
	BSBB	CHECK_P1			; Check P1 buffer
CHECK_P2:
	CLRL	R1				; Assume no P2 buffer desc
	MOVL	P2(AP),R2			; Get address of P2 desc
	BEQL	10$				; Br if no P2
	IFNORD	#8,(R2),ACCESS			; Br if no access
	MOVZWL	(R2),R1				; Get length of buffer
	BEQL	10$				; Br if zero
	MOVL	DSC$A_POINTER(R2),R0		; Get buffer address
	JSB	G^EXE$READCHK			; Check write access to buffer
						; (no return no access)
						; Also sets IRP$V_FUNC in IRP
	MOVL	R0,R2				; Copy buffer address
10$:	RSB					; Return to caller
 
ACCESS:	MOVZBL	S^#SS$_ACCVIO,R0		; Return access violation
	BRW	ABORTIO				; Abort the I/O request

	.SBTTL	CHECK_P1 - CHECK P1 BUFFER ADDRESS FOR WRITE ACCESS
;++
; CHECK_P1 - CHECK P1 BUFFER ADDRESS FOR WRITE ACCESS
;
; Functional description:
;
; This routine checks the P1 buffer and if okay, the buffer address
; is saved in IRP$L_MEDIA of the IRP.
;
; Inputs:
;
;	R1 = Size of buffer for write access
;	R3 = IRP address
;	R4 = PCB address
;	R5 = UCB address
;	R7 = Function code
;
; Outputs:
;
;	R0 is destroyed.
;
;	No RETURN on NO ACCESS.
;
; Implicit Outputs:
;
;	IRP$L_MEDIA(R3) = User P1 buffer address.
;	IRP$V_FUNC bit set in IRP$W_STS by EXE$READCHK subroutine.
;
;--

CHECK_P1:
	CLRL	IRP$L_MEDIA(R3)			; Assume no P1 buffer
	MOVL	P1(AP),R0			; Get address of user buffer
	BEQL	10$				; Br if none
	JSB	G^EXE$READCHK			; Check access to buffer
						; (No return - no access)
10$:	MOVL	R0,IRP$L_XE_USERBUF(R3)		; Save P1 buffer address in IRP
	RSB					; Return to caller

	.SBTTL	ALLOC_P2BUF - ALLOCATE A P2 BUFFER AND CHARGE USER'S QUOTA
;++
; ALLOC_P2BUF - ALLOCATE A P2 BUFFER AND CHARGE USER'S QUOTA
;
; Functional description:
;
; This routine allocates a system buffer and returns the address in the IRP at
; IRP$L_SVAPTE.  The size of the allocation, including buffer header must
; be at least 24 bytes in length.
;
; Inputs:
;
;	R1 = Size of allocation desired
;	R3 = IRP address
;
; Outputs:
;
;	R0 = status of request
;
;	R1-R5 are preserved.
;
; Implicit Outputs:
;
;	IRP$L_SVAPTE(R3) = address of system buffer
;	IRP$W_BOFF(R3) = byte count charged to user's process
;	IRP$W_BCNT(R3) = original byte count requested
;
;	All parts of the P2 buffer header are initialized, except for the
;	user's P2 buffer address.
;
;--
 
ALLOC_P2BUF:					; Allocate a non-paged buffer
	TSTL	R1				; Zero length buffer?
	BEQL	30$				; Br if yes
	PUSHR	#^M<R1,R2,R3>			; Save registers
	MOVW	R1,IRP$W_BCNT(R3)		; Save original byte count
	CMPL	R1,S^#24-P2B_C_LENGTH		; Is buffer big enough?
	BGTRU	5$				; Br if yes
	MOVL	S^#24-P2B_C_LENGTH,R1		; Else, set size to minimum
5$:	ADDL2	S^#P2B_C_LENGTH,R1		; Add in size of header
	JSB	G^EXE$BUFQUOPRC			; Check for buffered quota
	BLBC	R0,10$				; Branch if quota bad
;
; Quota OKAY, allocate buffer and copy info.
;
	PUSHL	R1				; Save size to charge user
	JSB	G^EXE$ALLOCBUF			; Go allocate a buffer
	BLBS	R0,20$				; Br if success
	ADDL	#4,SP				; Pop saved size
10$:	POPR	#^M<R1,R2,R3>			; Restore registers
	RSB					; Return with error code in R0
;
; System buffer allocated decrement user's quota
;
20$:	POPL	R3				; Restore user quota charge
	MOVAB	P2B_T_DATA(R2),P2B_L_POINTER(R2) ; Set address to start of data
	MOVW	R3,P2B_W_SIZE(R2)		; Save buffer size in buffer
	MOVL	R2,R0				; Save P2 char buf addr
	MOVL	PCB$L_JIB(R4),R2		; Get JIB address
	SUBL	R3,JIB$L_BYTCNT(R2)		; Decrement user's quota
	POPR	#^M<R1,R2,R3>			; Restore registers
	MOVL	R0,IRP$L_SVAPTE(R3)		; Save P2 buffer address in IRP
	MOVW	P2B_W_SIZE(R0),IRP$W_BOFF(R3)	; Return buffer size in IRP
30$:	MOVZBL	S^#SS$_NORMAL,R0		; Set success
	RSB					; Return to caller

	.SBTTL	CHECK_DGBUFx - CHECK ACCESS TO DIAGNOSTIC BUFFER
;++
; CHECK_DGBUFx - CHECK ACCESS TO DIAGNOSTIC BUFFER
;
; Functional description:
;
; This routines checks access to a diagnostic buffer as part of a diagnostic
; function request.
;
; Inputs:
;
;	R1 = Length of buffer (CHECK_DGBUFA only)
;	R3 = IRP address
;	R4 = PCB address
;	R5 = UCB address
;
; Outputs:
;
;	R0,R1,R2 are destroyed.
;
;
;	No RETURN on NO ACCESS
;
; Implicit Outputs:
;
;	If CHECK_DGBUFW, then IRP$V_FUNC bit set in IRP$W_STS by EXE$READCHK
;	subroutine.
;
;--
	.ENABL	LSB
CHECK_DGBUFA:				; Check write buffer to diag buffer
					;  - Address check only
	MOVL	P1(AP),R0		; Get address of diagnostic buffer
	BEQL	BAD_PARAM		; Br if none
	PUSHAB	G^EXE$READCHK		; Set routine address for checking
	BRB	20$			; Join common code

CHECK_DGBUFR:				; Check read access to diag buffer
	PUSHAB	G^EXE$WRITECHK		; Set routine address to check buffer
	BRB	10$			; Continue

CHECK_DGBUFW:				; Check write access to diag buffer
	PUSHAB	G^EXE$READCHK		; Set routine to check write access to
					; buffer (no return no access)
					; Also sets IRP$V_FUNC in IRP
10$:	MOVL	P1(AP),R0		; Get address of diagnostic buffer
	BEQL	BAD_PARAM		; Br if none
	MOVZWL	P2(AP),R1		; Get size of buffer
	BEQL	BAD_PARAM		; Br if none
20$:	JSB	@(SP)+			; Call routine to perform checks
	MOVL	R0,R2			; Save address of user buffer
	BSBW	ALLOC_P2BUF		; Allocate a buffer
	BLBC	R0,ALLOC_FAIL		; Br if allocation failure
	MOVL	IRP$L_SVAPTE(R3),R0	; Get system P2 buffer addr
	MOVL	R2,P2B_L_BUFFER(R0)	; Save user's P2 buffer addr
	BBS	#IRP$V_FUNC,IRP$W_STS(R3),30$ ; Br if READ function
;
; Move buffer to system buffer, if WRITE function
;
	PUSHR	#^M<R3,R4,R5>		; Save sacred registers
	MOVC3	R1,(R2),P2B_T_DATA(R0)	; Save P2 char buffer
	POPR	#^M<R3,R4,R5>		; Restore registers
30$:	RSB				; Return to checker routine

BAD_PARAM:				; Bad parameter
	MOVZBL	#SS$_BADPARAM,R0	; Set failure code
	BRB	40$			;
ALLOC_FAIL:				; Allocation failure
	MOVZWL	#SS$_INSFMEM,R0		; Set failure code
40$:	BRW	ABORTIO			; Abort the I/O request
	.DSABL	LSB

	.SBTTL	STARTIO - START I/O OPERATION
;++
; STARTIO - START I/O OPERATION
;
; Functional description:
;
; This routine is called when an IRP is ready to be processed by the driver.
; The request is dispatched to the appropriate routine base on the internal
; function code in the IRP.
;
; Inputs:
;
;	R3 = IRP address
;	R5 = UCB address
;
;	IPL = FIPL
;
; Outputs:
;
;	R0-R2,R4 are destroyed.
;--

STARTIO::				; Process an I/O packet
	MOVZBL	IRP$B_XE_FUNC(R3),R1	; Get the internal function code
10$:	$DISPATCH	R1,TYPE=B,-
	<-	;function	action

		<XE_FC_V_INIT	STARTUP>,-	; Startup request
		<XE_FC_V_RDCNTS	INPUT>,-	; Read counters request
		<XE_FC_V_RCCNTS	INPUT>,-	; Read and clear counters
		<XE_FC_V_STOP	SHUT>,-		; Shutdown request
		<XE_FC_V_MULTI	INPUT>,-	; Set new multicast list
		<XE_FC_V_LDMEM	INPUT_BUFFER1>,-; Load DEUNA/DELUA memory
		<XE_FC_V_RDMEM	INPUT_BUFFER>,-	; Read DEUNA/DELUA memory
		<XE_FC_V_UPST	INPUT>,-	; Load and start Micro-address
		<XE_FC_V_LDSID	INPUT>,-	; Load system ID parameters
		<XE_FC_V_RDSID	INPUT>,-	; Read system ID parameters
		<XE_FC_V_STOPPR	INPUT>,-	; Stop xmit and receive process
		<XE_FC_V_STEST	INPUT>,-	; Perform DEUNA/DELUA self test
		<XE_FC_V_READST	INPUT>,-	; Read port status
		<XE_FC_V_ESTEST	INPUT>,-	; Perform DEULA extended self test
		<XE_FC_V_HALT	INPUT>,-	; Halt port (DELUA only)
	>
;
; Other request type
;
	BUG_CHECK NOBUFPCKT,FATAL	; Fatal error

;
; Startup unit's protocol
;
STARTUP:				; Startup unit's protocol
	BSBB	START			; Start protocol
	BLBC	R0,10$			; Br if error on startup
	RSB				; Else return to caller

10$:	PUSHL	R0			; Save error return
	BSBB	STOP			; Shutdown unit
	POPL	R0			; Restore error return
	;BRB	DRV_DONE		; Complete request in error

DRV_DONE:
	MOVW	R0,IRP$W_XE_STATUS(R3)	; Set completion status
	INSQUE	(R3),@CDB_Q_POST+4(R4)	; Insert IRP on posting queue
	BRW	SCHED_FORKC		; Schedule a fork process
;
; Shutdown UNIT's protocol
;
SHUT:					; Shutdown protocol
	MOVL	UCB$L_XE_CDB(R5),R4	; Get CDB address
	CMPL	R5,CDB_L_PRMUSER(R4)	; Are we the PROMISCUOUS user?
	BNEQ	10$			; Br if not
	CLRL	CDB_L_PRMUSER(R4)	; Else, clear the PROMISCUOUS user
	CLRBIT	#PB_MOD_V_PROM,-	; Reset the hardware mode
		CDB_W_MODE(R4)		;  out of promiscuous mode
	MOVB	#NMA$C_STATE_OFF,-	; Don't forget about the CDB
		CDB_B_PRM(R4)		;  parameter
	BRW	INPUT			; Insert request on Input queue

10$:	BSBB	STOP			; Shutdown unit
	MOVZBL	S^#SS$_NORMAL,R0	; Return success
	BRW	IO_DONE			; Complete I/O request
;
; STOP the unit
;
STOP:					; Stop the protocol
	MOVL	UCB$L_XE_CDB(R5),R4	; Get CDB address
	BRW	SHUTDOWN_PROTYP		; Shutdown the unit

	.SBTTL	START - START UNIT'S PROTOCOL
;++
; START - START UNIT'S PROTOCOL
;
; Functional description:
;
; This routine initiates the protocol on the unit. The DEUNA/DELUA is reset if 
; first unit online.  The free list is filled and the first receive started.
; If a failure occurs the unit shutdown sequence is entered.
;
; Inputs:
;
;	R3 = IRP address
;	R5 = UCB address
;
;	IPL = FIPL
;
; Implicit inputs:
;
;	IRP$L_MEDIA contains a copy of the mode buffer specified by the user.
;	IRP$W_BOFF contains the quota taken from the user for the unit.
;
; Outputs:
;
;	R0 = Status return for startup request.
;	R1,R2,R4 are destroyed.
;	R3,R5 are preserved.
;
;--

START::					; Start protocol operation
	CMPB	#NMA$C_LINPR_POI,-	;% Are we in PT-TO-PT mode?
		UCB$B_XE_PRO(R5)	;%
	BNEQ	3$			;% Br if not
	MOVZWL	#IRP$C_LENGTH,R1	;% Set size of an IRP
	PUSHL	R3			;% Save R3
	JSB	G^EXE$ALONONPAGED	;% Allocate the IRP
	POPL	R3			;% Restore R3
	BLBS	R0,1$			;% Br if success
	MOVZWL	#SS$_INSFMEM,R0		;% Set error return
	RSB				;% Return to caller

1$:	MOVL	R2,UCB$L_XE_STIRP(R5)	;% Save startup IRP
	BISW	#UCB$M_XE_START!UCB$M_XE_STACK,- ;% We are now in the startup
		UCB$W_DEVSTS(R5)	;%   and stack wait state

3$:	TSTL	UCB$L_XE_CPID(R5)	; Creator PID saved already?
	BNEQ	5$			; Br if yes
	MOVL	UCB$L_CPID(R5),UCB$L_XE_CPID(R5) ; Else, save creator PID
;
; Set up idle UCB
;
5$:	MOVZWL	#XM$M_STS_ACTIVE,-
		UCB$L_DEVDEPEND(R5)	; Reset status and error summary
	CMPB	#XE_FC_V_RESTART,IRP$B_XE_FUNC(R3) ; Is this a re-start operation?
	BEQL	8$			; Br if yes - don't reset the PID
	MOVL	IRP$L_PID(R3),UCB$L_XE_PID(R5) ; Save starter's PID
;
; Check for CDB
;
8$:	MOVL	UCB$L_XE_CDB(R5),R2	; Get CDB address, crash if not present
	INCB	CDB_B_UNTCNT(R2)	; One more unit on this controller
	BBS	#CDB_STS_V_INITED,-	; Br if already inited
		CDB_B_STS(R2),10$	;
	BRW	20$			; Else, init CDB

10$:	MOVL	R2,R4			; Copy CDB address
	MOVAB	UCB$B_XE_CDBPRM(R5),R0	; Get UCB parameter address
	MOVAB	CDB_B_SETPRM(R4),R1	; Get CDB parameter address
	MOVZBL	#UCB$C_XE_CDBPRM,R2	; Set size of parameter list

;
; Check order of UCB parameters
;
	ASSUME	UCB$B_XE_CRC EQ UCB$B_XE_CDBPRM
	ASSUME	UCB$B_XE_CON EQ UCB$B_XE_CRC+1
	ASSUME	UCB$B_XE_EKO EQ UCB$B_XE_CON+1
	ASSUME	UCB$B_XE_ILP EQ UCB$B_XE_EKO+1
;
; Check order of CDB parameters
;
	ASSUME	CDB_B_CRC EQ CDB_B_SETPRM
	ASSUME	CDB_B_CON EQ CDB_B_CRC+1
	ASSUME	CDB_B_EKO EQ CDB_B_CON+1
	ASSUME	CDB_B_ILP EQ CDB_B_EKO+1

	ASSUME	NMA$C_STATE_ON NE -1
	ASSUME	NMA$C_STATE_OFF NE -1
13$:	CMPB	(R0),(R1)		; Match?
	BNEQ	18$			; Br if no
	MOVB	(R1)+,(R0)+		; Store CDB value in UCB
	SOBGTR	R2,13$			; Loop if more to check
;
; NOW, check if user has given a hardware physical address.
;
;	R0 = Address of parameters in UCB
;	R1 = Address of parameters in CDB
;
	ASSUME	CDB_G_PHA EQ CDB_B_ILP+1
	ASSUME	UCB$G_XE_PHA EQ UCB$B_XE_ILP+1
	CMPL	#-1,(R0)		; Is user physical address defined?
	BNEQ	15$			; Br if yes
	CMPW	#-1,4(R0)		; Is user physical address defined?
	BEQL	16$			; Br if not
15$:	MOVW	#NMA$C_PCLI_PHA,IRP$W_XE_CODE(R3) ; Assume bad physical address
	CMPL	(R0)+,(R1)+		; Physical address match??
	BNEQ	19$			; Br if no
	CMPW	(R0)+,(R1)+		; Still match??
	BNEQ	19$			; Br if no
16$:	MOVL	CDB_G_PHA(R4),-		; Return hardware set address
		 UCB$G_XE_PHA(R5)	;  just in case we defaulted
	MOVW	CDB_G_PHA+4(R4),-	;	...
		 UCB$G_XE_PHA+4(R5)	;	...
;
; Check users buffer size - must not be more than twice the hardware buffer
; size. (Already has been checked against max message size).
;
	MOVW	#NMA$C_PCLI_BUS,IRP$W_XE_CODE(R3) ; Assume bad buffer size
	MOVZWL	CDB_W_BSZ(R4),R1	; Get device buffer size
	ASSUME	NMA$C_STATE_ON EQ 0
	ASSUME	NMA$C_STATE_OFF EQ 1
	BLBS	CDB_B_DCH(R4),17$	; Br if data chaining OFF on DEUNA/DELUA
	BLBS	UCB$B_XE_DCH(R5),17$	; Br if user can't do data chaining
					; && Maybe this is an Internal IRP user
	ADDW	CDB_W_BSZ(R4),R1	; Compute twice the normal buffer size
17$:	CMPW	UCB$W_DEVBUFSIZ(R5),R1	; Is buffer size okay?
	BGTRU	19$			; Br if too large
	CLRW	IRP$W_XE_CODE(R3)	; No bad parameters
	BISW	#UCB$M_XE_RUN,-		; Indicate we have entered RUN mode
		UCB$W_DEVSTS(R5)	;
	MOVB	#XE_FC_V_CHMODE,IRP$B_XE_FUNC(R3) ; Set new function code
	SETIPL	UCB$B_DIPL(R5)		; Sync access to UCB and CDB
	INSQUE	(R3),@CDB_Q_INPUT+4(R4)	; Insert at END of input queue
	BSBW	LOAD_PORT		; Load the DEUNA/DELUA port
	MOVZBL	#SS$_NORMAL,R0		; Return success
	RSB				; Return to caller
;
; Error on parameter validation
;
18$:	MOVW	BAD_PARAM_TBL-2[R2],IRP$W_XE_CODE(R3) ; Return parameter code
19$:	MOVZBL	S^#SS$_BADPARAM,R0	; Return bad parameter error
	RSB				; Return to caller
;
; Initialize CDB
;
20$:	MOVZWL	#CDB_C_ZERO,R1		; Get portion of CDB to init with zero
	PUSHR	#^M<R1,R2,R3,R4,R5>	; Save registers
	MOVC5	#0,(R2),#0,R1,(R2)	; Zero the structure
	POPR	#^M<R1,R2,R3,R4,R5>	; Restore registers
	ASSUME	CDB_L_FQFL EQ 0
	ASSUME	CDB_L_FQBL EQ CDB_L_FQFL+4
	MOVAQ	(R2)+,R4		; Skip link pointers, copy CDB address
	ASSUME	CDB_W_SIZE EQ CDB_L_FQBL+4
	MOVW	R1,(R2)+		; Store size of structure
	ASSUME	CDB_B_TYPE EQ CDB_W_SIZE+2
	ASSUME	CDB_B_FIPL EQ CDB_B_TYPE+1
	MOVW	#<IPL$_XE_FIPL@8>!DYN$C_CDB,(R2)+; Set structure type and FIPL
	ASSUME	CDB_L_FPC EQ CDB_B_FIPL+1
	MOVAB	FORK_PROC,(R2)+		; Set fork process address
	ASSUME	CDB_L_FR3 EQ CDB_L_FPC+4
	ASSUME	CDB_L_FR4 EQ CDB_L_FR3+4
	CLRQ	(R2)+			; Clear fork R3 and R4
	ASSUME	CDB_B_NEXTXMT EQ CDB_L_FR4+4
	ASSUME	CDB_B_NEXTRCV EQ CDB_B_NEXTXMT+1
	ASSUME	CDB_B_RCVMAP EQ CDB_B_NEXTRCV+1
	ASSUME	CDB_B_XMTMAP EQ CDB_B_RCVMAP+1
	CLRL	(R2)+			; Clear slot in use flags
	ASSUME	CDB_L_RCVMAP EQ CDB_B_XMTMAP+1
	MOVZBL	#MAX_C_XMT+MAX_C_RCV,R1	; Set number of mapping vectors
30$:	MNEGL	#1,(R2)+		; Indicate no mapping info
	SOBGTR	R1,30$			; Loop if more
	ASSUME	CDB_L_XRADDR EQ CDB_L_RCVMAP+<4*<MAX_C_XMT+MAX_C_RCV>>
	ASSUME	CDB_L_RRADDR EQ CDB_L_XRADDR+<4*MAX_C_XMT>
	ASSUME	CDB_G_RRING  EQ CDB_G_XRING+XMT_K_LENGTH
	ASSUME	RCV_C_LENGTH EQ XMT_C_LENGTH
	MOVZBL	#MAX_C_XMT+MAX_C_RCV,R1	; Set total number of ring entries
	MOVAB	CDB_G_XRING(R4),R0	; Set address of first ring entry
35$:	MOVL	R0,(R2)+		; Store ring entry address in table
	ADDL2	#RCV_C_LENGTH,R0	; Compute address of next ring entry
	SOBGTR	R1,35$			; Loop if more
	ASSUME	CDB_Q_QUEUES EQ CDB_L_XRADDR+<4*<MAX_C_XMT+MAX_C_RCV>>
	MOVZBL	#CDB_C_QUEUES,R1	; Set number of queue listheads
40$:	MOVAL	(R2),(R2)+		; Set forward link
	MOVL	-4(R2),(R2)+		; Set backward link
	SOBGTR	R1,40$			; Loop if more listheads
	SETBIT	#CDB_STS_V_INITED,CDB_B_STS(R4)	; Set initial status bits
	MNEGL	#1,CDB_L_PCBBMAP(R4)	; Set no mapping for PCBB yet

;
; Because the recieve buffer sizes are a constant, the buffer length fields of
; the ring descriptor entries can be setup only once. Note that the DEUNA/DELUA
; receive buffer size must be a multiple of 2
;

	ASSUME	<XE_C_HEADER+XE_C_CRC+XE_C_CNTSIZ & 1 > EQ 0
	MOVZBL	#MAX_C_RCV,R1		; Set total number of ring entries
	MOVAB	CDB_G_RRING(R4),R0	; Set address of first ring entry
	ADDW3	#XE_C_HEADER+XE_C_CRC-	; Calculate buffer length
		+XE_C_CNTSIZ,-		;	...
		UCB$W_XE_BSZ(R5),R2	;	...
43$:	MOVW	R2,RCV_W_SLEN(R0)	; Store buffer length in current entry
	ADDL2	#RCV_C_LENGTH,R0	; Compute address of next ring entry
	SOBGTR	R1,43$			; Loop if more

;
; Allocate map registers for receive buffers and one transmit buffer. The
; any datapath (buffered/unbuffered) can be used for all I/O's due to the
; fact that all data is buffered on the DEUNA/DELUA.
;
; We will allocate the buffered data paths, only as needed. No buffered
; data paths are pre-allocated. Also, we can only use the buffered data
; paths for transmit operations. This is because receives have no guaranteed
; completion time and we do not want to waste the buffered data paths!
;

	MOVW	UCB$W_XE_BSZ(R5),-	; Init CDB buffer size
		CDB_W_BSZ(R4)		;
	MOVW	UCB$W_XE_HBQ(R5),CDB_W_QUOTA(R4) ; Set initial quota

	ASSUME	INIT_C_AQUOTA LE 255
	ASSUME	CDB_B_MQUOTA EQ CDB_B_AQUOTA+1
	MOVW	#<INIT_C_AQUOTA@8>,-	; Initialize Maximum QUOTA
		 CDB_B_AQUOTA(R4)	; and zero Additional QUOTA
	ASSUME	UCB$B_XE_MLT EQ UCB$B_XE_PRM+1
	ASSUME	CDB_B_MLT EQ CDB_B_PRM+1
	MOVW	UCB$B_XE_PRM(R5),CDB_B_PRM(R4) ; Set the promiscuous mode
					;  and the all multicast enable
	MOVAB	UCB$B_XE_CDBPRM(R5),R0	; Get address of UCB parameters
	MOVAB	CDB_B_SETPRM(R4),R1	; Get address of CDB parameters
	MOVZBL	#UCB$C_XE_SETPRM,R2	; Set size of parameter list
45$:	MOVB	(R0)+,(R1)+		; Store parameters
	SOBGTR	R2,45$			; Loop if more
	BSBW	MOVE_MULTI		; Copy multicast address list
	MOVW	CDB_W_BSZ(R4),-		; Set buffer size
		UCB$W_BCNT(R5)
	MOVW	#511,UCB$W_BOFF(R5)	; Set worst case byte offset
	PUSHQ	R6			; Save R6,R7
	MOVL	R4,R6			; Save CDB address
	MOVL	UCB$L_CRB(R5),R4	; Get CRB address
	ASSUME	VEC$W_MAPREG+2 EQ VEC$B_NUMREG
	ASSUME	VEC$B_NUMREG+1 EQ VEC$B_DATAPATH
	CLRL	CRB$L_INTD+VEC$W_MAPREG(R4) ; Clear map register + datapath
	MOVAL	CDB_L_RCVMAP(R6),R6	; Get mapping slot address
	MOVZBL	#MAX_C_RCV,R7		; Get number of receive slots
50$:	JSB	G^IOC$ALOUBAMAP		; Allocate a set of map registers
	BLBC	R0,70$			; Br if unavailable
	MOVL	CRB$L_INTD+VEC$W_MAPREG(R4),(R6)+ ; Save map info
	SOBGTR	R7,50$			; Continue

	MOVZWL	#MAX_PKT_SIZE+18,-	; Set transmit buffer size to max
		UCB$W_BCNT(R5)		;  Ethernet packet size + header
60$:	JSB	G^IOC$ALOUBAMAP		; Allocate a set of transmit registers
	BLBC	R0,70$			; Br if unavailable
	ASSUME	CDB_L_XMTMAP EQ CDB_L_RCVMAP+<4*<MAX_C_RCV>>
	MOVL	CRB$L_INTD+VEC$W_MAPREG(R4),(R6) ; Save transmit map info
;
; Calculate UNIBUS mapping for PCBB and other DEUNA/DELUA structures.
;
	MOVL	CRB$L_AUXSTRUC(R4),R6	; Get CDB address
	MOVL	UCB$L_DDB(R5),R7	; Get DDB address
	MOVL	DDB$L_UCB(R7),CDB_L_UCB0(R6) ; Set UCB #0 address
	MOVAB	CDB_G_PCBB(R6),R7	; Get PCBB address
	BICW3	#^C<VA$M_BYTE>,-	; Get PCBB byte offset
		R7,UCB$W_BOFF(R5)
	MOVW	#CDB_C_MAPPED,UCB$W_BCNT(R5) ; Set Block size
	JSB	G^IOC$ALOUBAMAP		; Allocate map registers
	BLBS	R0,80$			; Br if allocated
70$:	POPQ	R6			; Restore R6, R7
	MOVZWL	#SS$_INSFMAPREG,R0	; Set insufficient map registers
	RSB				; Return with error

	ASSUME	VEC$W_MAPREG+2 EQ VEC$B_NUMREG
	ASSUME	VEC$B_NUMREG+1 EQ VEC$B_DATAPATH
80$:	MOVL	CRB$L_INTD+VEC$W_MAPREG(R4),- ; Save PCBB mapping info
		CDB_L_PCBBMAP(R6)	;
;
; Convert virtual PCB address to physical PTE address
;
	EXTZV	S^#VA$V_VPN,-		; Get PCBB page number
		S^#VA$S_VPN,R7,R1	;
	MOVL	G^MMG$GL_SPTBASE,R0	; Get SPT address
	MOVAL	(R0)[R1],UCB$L_SVAPTE(R5) ; Set PTE address
	JSB	G^IOC$LOADUBAMAP	; Load the PCBB map registers
	EXTZV	#7,#2,-			; Get BA16-BA17
		CRB$L_INTD+VEC$W_MAPREG(R4),R1 ;
	ASHL	#16,R1,R1		; Move to high word
	MOVW	UCB$W_BOFF(R5),R1	; Set BA0-BA8
	INSV	CRB$L_INTD+VEC$W_MAPREG(R4),- ; Set BA9-BA15
		#9,#7,R1		;
	MOVL	R1,CDB_L_PCBBUA(R6)	; Save PCBB UNIBUS address
;
; Initialize ring buffer descriptor
;
	ADDL	#CDB_G_XRING-CDB_G_PCBB,R1 ; Get address of XMIT RING
	ASSUME	UDB_BUF_W_TDRBL EQ 0
	MOVL	R1,CDB_G_XRUDB(R6)	; Store XMIT RING UNIBUS address
	MOVB	#<XMT_C_LENGTH/2>,-	; Store size of XMIT RING entry in words
		CDB_G_XRUDB+UDB_BUF_B_TELEN(R6) ;
	MOVZBW	#MAX_C_XMT,-		; Store number of ring entries
		CDB_G_XRUDB+UDB_BUF_W_TRLEN(R6) ;
	ADDL	#CDB_G_RRING-CDB_G_XRING,R1 ; Get address of RECV RING
	MOVL	R1,CDB_G_XRUDB+UDB_BUF_W_RDRBL(R6) ; Store RCV RING BUS address
	MOVB	#<RCV_C_LENGTH/2>,-	; Store size of RECV RING entry in words
		CDB_G_XRUDB+UDB_BUF_B_RELEN(R6) ;
	MOVZBW	#MAX_C_RCV,-		; Store number of ring entries
		CDB_G_XRUDB+UDB_BUF_W_RRLEN(R6) ;
;
; Initialize DEUNA/DELUA mode word
;
	ASSUME	NMA$C_STATE_ON EQ 0
	ASSUME	NMA$C_STATE_OFF EQ 1
	MOVW	DEF_MODE,CDB_W_MODE(R6)	; Reset mode to initial value
	BLBS	CDB_B_PRM(R6),90$	; Br if promiscuous state is OFF
	BISW	#PB_MOD_M_PROM,-	; Else, enable promiscuous mode
		CDB_W_MODE(R6)		;

90$:	BLBS	CDB_B_MLT(R6),100$	; Br if multicast state is OFF
	BISW	#PB_MOD_M_ENAL,-	; Else, enable all MULTICASTS
		CDB_W_MODE(R6)		;

100$:	MOVAB	ASSPKT_NODCH,-		; Assume data chaining is disabled
		CDB_L_ASSPKT(R6)
	BLBS	CDB_B_DCH(R6),110$	; Branch if data chaining is OFF
	CMPW	#MAX_PKT_SIZE,-		; Don't enable data chaining if the
		CDB_W_BSZ(R6)		; recieve buffer size is greater than
	BLEQU	110$			; or equal to the maximum packet size
	BICW2	#PB_MOD_M_DRDC,-	; Enable data chaining
		CDB_W_MODE(R6)
	MOVAB	ASSPKT_DCH,-		; Use data chaining ASSPKT routine
		CDB_L_ASSPKT(R6)

110$:	BLBS	CDB_B_PAD(R6),120$	; Br if padding is OFF
	BISW	#PB_MOD_M_TPAD,-	; Else, enable padding
		CDB_W_MODE(R6)		;

120$:	BLBC	CDB_B_CRC(R6),125$	; Br if CRC is to be generated
	BISW	#PB_MOD_M_DTCR,-	; Else, disable CRC generation
		CDB_W_MODE(R6)		;

125$:	BLBC	CDB_B_EKO(R6),130$	; Br if Echo mode is enabled (ON)
	MOVZBL	UCB$B_TYPE(R5),R1	; Retrieve device type
	$DISPATCH	R1,TYPE=B,-	; Dispatch based upon device type
	< -
		<DT$_DEUNA	127$>,-	; DEUNA - disable echo mode
		<DT$_DELUA	130$>,-	; DELUA - echo mode is always disabled
	>
127$:	BISW	#PB_MOD_M_HDX,-		; Else, disable Echo mode - set to HDX
		CDB_W_MODE(R6)		;

130$:	ASSUME	NMA$C_LINCN_NOR EQ 0
	ASSUME	NMA$C_LINCN_LOO EQ 1
	BLBC	CDB_B_CON(R6),140$	; Br if LOOPBACK is not enabled
	BISW	#PB_MOD_M_LOOP,-	; Else, enable loopback
		CDB_W_MODE(R6)		; 
	BICW	#PB_MOD_M_HDX,-		; Must set ourselves to FDX
		CDB_W_MODE(R6)		;  ... what a KLUGE

	BLBS	CDB_B_ILP(R6),140$	;
	BISW	#PB_MOD_M_INTL,-	; Else, enable internal loopback (DELUA)
		CDB_W_MODE(R6)		; 

140$:	MOVL	R6,R4			; Set R4 to CDB address
	POPQ	R6			; Restore R6, R7
;
; Setup fork process to start CDB timer
;
	PUSHR	#^M<R3,R4,R5>		; Save registers
	BBSS	#CDB_STS_V_TIMER,-	; Br if timer already going
		CDB_B_STS(R4),150$	;
	BISB	#DPT$M_NOUNLOAD,-	; Do not allow driver to be unloaded
		DPT$TAB+DPT$B_FLAGS	;  while the TQE is active
	MOVAL	CDB_L_TQE(R4),R5	; Get the TQE address
	MOVQ	#TQE_DELTA,TQE$Q_DELTA(R5) ; Set the delta time
	MOVAB	W^TQE_TIMER,R3		; Set address of timer wakeup routine
	MOVB	#TQE$C_SSREPT,TQE$L_RQPID(R5) ; Set the TQE request type
	BSBW	FORK_TIMER		; Create fork process for TQE
;
; Put IRP on input queue to await master reset completion interrupt.
;
150$:	POPR	#^M<R3,R4,R5>		; Restore registers
	INSQUE	(R3),CDB_Q_INPUT(R4)	; Insert at front of input queue
	MOVL	UCB$L_CRB(R5),R2	; Get CRB adddress
	MOVL	@CRB$L_INTD+VEC$L_IDB(R2),R2 ; Get CSR address
;
; Master reset device
;
	DSBINT	UCB$B_DIPL(R5)		; Sync access to UCB
	MOVW	#XE_PCSR0_M_RSET,PCSR0(R2) ; Master Reset device
;
; The master reset will take some time to complete ...
; so we will execute some NOPs to give the DEUNA/DELUA some time.
;
	TIMEWAIT #1,#XE_PCSR0_M_DNI,PCSR0(R2),W ; Wait for DNI or 10 usec
	MOVZBL	S^#SS$_NORMAL,R0	; Return success
	MOVW	#XE_PCSR0_M_INTE,PCSR0(R2) ; Enable interrupts
	WFIKPCH	TIMEOUT,#16		; Wait for self test done interrupt.
					; We will want all initialization
					; to complete before clearing timeout
					; and interrupt bits in UCB$W_STS(R5).

;++
; FORK_TIMER - Routine to create fork a process to start a timer
;
; This routine starts up FORK process which is used to start a timer.
;
; Inputs:
;
;	R3 = Address of system routine to handle the timer expiration.
;	R5 = Address of TQE block
;
;	IPL = Greater than Queueast IPL
;
; Outputs:
;
;	Fork process is started.
;	R3, R4 are destroyed by EXE$FORK
;
;--
FORK_TIMER:				; Create fork process to start timer
	MOVB	#DYN$C_TQE,FKB$B_TYPE(R5) ; Set structure type
	MOVB	#IPL$_QUEUEAST,FKB$B_FIPL(R5) ; Set IPL of fork process
	PUSHAB	B^START_TIMER		; Push address of fork process
	JMP	G^EXE$FORK		; Create fork process to start timer

;++
; START_TIMER - Fork process to start the CDB timer
;
; This routine starts up the CDB which is used to monitor the DEUNA/DELUA 
; controller for proper operation.
;
; Inputs:
;
;	R5 = Address of TQE block
;
;	IPL = Queueast IPL
;
; Implicit inputs:
;
;	TQE$Q_DELTA(R5) = Delta time interval
;	TQE$L_RQPID(R5) = TQE request type (SSSNGL or SSREPT)
;
; Outputs:
;
;	R0-R3 are destroyed.
;	TQE element added to timer queue
;
;--
START_TIMER:
	DSBINT	#IPL$_TIMER		; Raise IPL
	MOVL	FKB$L_FR3(R5),TQE$L_FPC(R5) ; Set address of timer wakeup
	MOVB	TQE$L_RQPID(R5),-	; Set TQE request type
		TQE$B_RQTYPE(R5)	;
	MOVQ	TQE$Q_DELTA(R5),R0	; Get delta time
	ADDL	G^EXE$GQ_SYSTIME,R0	; Add in current time
	ADWC	G^EXE$GQ_SYSTIME+4,R1	;	...
	JSB	G^EXE$INSTIMQ		; Insert element on timer queue
	ENBINT				; Restore IPL
	RSB

	.SBTTL	INPUT - INSERT REQUEST ON INPUT PROCESS QUEUE
;++
; INPUT - INSERT REQUEST ON INPUT PROCESS QUEUE
;
; Functional description:
;
; This routine inserts the IRP packet on the input waiting queue and
; loads the port CSR's.
;
; Inputs:
;
;	R3 = IRP address
;	R5 = UCB address
;
;	IPL = FIPL
;
; Outputs:
;
;	The request is completed.
;--
INPUT::					; Insert request on input queue
	ASSUME	UCB$V_XE_INITED  EQ  0
	BLBS	UCB$W_DEVSTS(R5),10$	; Br if unit inited
	MOVZWL	#SS$_DEVINACT,R0	; Else, set error return
	BRW	IO_DONE			; Finish the request

10$:	MOVL	UCB$L_XE_CDB(R5),R4	; Get CDB address
	SETIPL	UCB$B_DIPL(R5)		; Sync access to device
	INSQUE	(R3),@CDB_Q_INPUT+4(R4)	; Insert at END of queue
	BRW	LOAD_PORT

	.SBTTL	INPUT_BUFFER - INSERT REQUEST ON INPUT PROCESS QUEUE AND MAP BUFFER
;++
; INPUT_BUFFER - INSERT REQUEST ON INPUT PROCESS QUEUE AND MAP BUFFER
;
; Functional description:
;
; This routine inserts the IRP packet on the input waiting queue and
; loads the port CSR's.
;
; Inputs:
;
;	R3 = IRP address
;	R5 = UCB address
;
;	IPL = FIPL
;
; Outputs:
;
;	R0,R1,R2 are destroyed.
;	The request is completed.
;--
	.ENABL	LSB
INPUT_BUFFER1::				; Insert request on input queue
	MOVL	UCB$L_XE_CDB(R5),R4	; Get CDB address
	BEQL	3$			; Br if no CDB
	MOVZWL	#SS$_DEVACTIVE,R0	; Assume unit is running
	BBS	#CDB_STS_V_RUN,-	; Br if DEUNA/DELUA is running - error
		CDB_B_STS(R4),5$	; 
INPUT_BUFFER::				; Insert request on input queue
	ASSUME	UCB$V_XE_INITED  EQ  0
	BLBS	UCB$W_DEVSTS(R5),10$	; Br if unit inited - okay
3$:	MOVZWL	#SS$_DEVINACT,R0	; Else, set error return
5$:	BRW	IO_DONE			; Finish the request

	ASSUME	P2B_L_POINTER EQ 0
10$:	PUSHL	R6			; Save a register
;
; Set up variant mapping info in UCB and CRB to allocate a set of map
; registers for the buffer.
;
	MOVL	@IRP$L_SVAPTE(R3),R6	; Get buffer address
	BICW3	#^C<VA$M_BYTE>,-	; Get byte offset
		R6,UCB$W_BOFF(R5)	;
	MOVW	IRP$W_BCNT(R3),-	; Set Block size
		UCB$W_BCNT(R5) 		;
	MOVL	UCB$L_CRB(R5),R4	; Get CRB address
	ASSUME	VEC$B_NUMREG EQ VEC$W_MAPREG+2
	ASSUME	VEC$B_DATAPATH EQ VEC$B_NUMREG+1
	CLRL	CRB$L_INTD+VEC$W_MAPREG(R4) ; Reset mapping info
	JSB	G^IOC$ALOUBAMAP		; Allocate map registers
	BLBC	R0,20$			; Br if NOT allocated
	ASSUME	VEC$B_NUMREG EQ VEC$W_MAPREG+2
	ASSUME	VEC$B_DATAPATH EQ VEC$B_NUMREG+1
	MOVL	CRB$L_INTD+VEC$W_MAPREG(R4),- ; Save mapping info in IRP
		IRP$L_XE_MAP(R3)	;
;
; Convert virtual buffer address to physical PTE address
;
	EXTZV	S^#VA$V_VPN,-		; Get PCBB page number
		S^#VA$S_VPN,R6,R1	;
	MOVL	G^MMG$GL_SPTBASE,R0	; Get SPT address
	MOVAL	(R0)[R1],UCB$L_SVAPTE(R5) ; Set PTE address
	JSB	G^IOC$LOADUBAMAP	; Load the PCBB map registers
	EXTZV	#7,#2,-			; Get BA16-BA17
		CRB$L_INTD+VEC$W_MAPREG(R4),R1 ;
	ASHL	#16,R1,R1		; Move to high word
	MOVW	UCB$W_BOFF(R5),R1	; Set BA0-BA8
	INSV	CRB$L_INTD+VEC$W_MAPREG(R4),- ; Set BA9-BA15
		#9,#7,R1		;
	MOVL	R1,IRP$L_XE_DGUNI(R3)	; Save UNIBUS address
	MOVL	CRB$L_AUXSTRUC(R4),R4	; Get CDB address
	POPL	R6			; Restore register
	SETIPL	UCB$B_DIPL(R5)		; Sync access to device
	INSQUE	(R3),@CDB_Q_INPUT+4(R4)	; Insert at END of queue
	BRW	LOAD_PORT
;
; Insufficient map registers
;
20$:	POPL	R6			; Restore R6
	MOVZWL	#SS$_INSFMAPREG,R0	; Else, set error return
	BRW	IO_DONE			; Finish the request
	.DSABL	LSB

	.SBTTL	FILLRCVLIST - FILL RECEIVE BUFFER LIST
;++
; FILLRCVLIST - FILL RECEIVE BUFFER LIST
;
; Functional description:
;
; This routine fills the receive buffer list up to the quota allocated
; at unit initialization.  It also gives any receive buffers allocated
; to the receiver.
;
; Inputs:
;
;	R2 = Buffer Address (ADDRCVLIST ONLY)
;	R4 = CDB address
; 
;	IPL = FIPL
;
; Outputs:
;
;	R0-R2 is destroyed.
;	All other registers are preserved.
;
;--
	.ENABL	LSB
FILLRCVLIST::				; Fill receive buffer list
	CLRL	R2			; No buffer here

ADDRCVLIST::				; Add a buffer to the receive list
	PUSHR	#^M<R3,R4,R5>		; Save registers
	MOVL	CDB_L_UCB0(R4),R5	; Get UCB address of unit #0
	BBC	#CDB_STS_V_RUN,-	; If BC device not running
		CDB_B_STS(R4),40$

10$:	CMPW	CDB_W_BSZ(R4),-		; Can new block be allocated ?
		CDB_W_QUOTA(R4)
	BGTRU	35$			; If GTRU then no, stop loop
	TSTL	R2			; Buffer already allocated?
	BNEQ	20$			; Br if so

	CLRL	R1			; Zero size 
	ADDW3	#CXB$C_HEADER+-		; Determine block size needed
		CXB$C_TRAILER,-		;
		CDB_W_BSZ(R4),R1	;
	JSB	G^EXE$ALONONPAGED	; Allocate the memory
	BLBC	R0,30$			; If failure then done
	MOVW	R1,CXB$W_SIZE(R2)	; Insert size
	MOVB	S^#DYN$C_CXB,-		; Insert type
		CXB$B_TYPE(R2)		;

20$:	SUBW	CDB_W_BSZ(R4),-		; Subtract from quota
		CDB_W_QUOTA(R4)		;
25$:	MOVB	#XE_FC_V_RECV,CXB$B_XE_FUNC(R2) ; Set function request
	INSQUE	(R2),CDB_Q_RCVBUF(R4)	; Insert block on list
	CLRL	R2			; No more buffers given
	BRB	10$			; Continue
;
; Buffer allocation failure
;
30$:	SETBIT	#XM$V_STS_BUFFAIL,-	; Set buffer alloc failure
		CDB_L_DEVDEPEND(R4)	;
	BRB	50$			; And give any receives to device

35$:	CLRBIT	#XM$V_STS_BUFFAIL,-	; Clear buffer alloc failure
		CDB_L_DEVDEPEND(R4)	;
	TSTL	R2			; Any buffer?
	BEQL	50$			; Br if not
	CMPB	CDB_B_AQUOTA(R4),-	; Can we use the additional quota?
		CDB_B_MQUOTA(R4)	;
	BGEQU	40$			; Br if not
	INCB	CDB_B_AQUOTA(R4)	; Else, increment the additional
	BRB	25$			; Use buffer, but don't let
					;  QUOTA go negative

40$:	MOVL	R2,R0			; Get address of buffer
	BEQL	50$			; Br if none
	JSB	G^COM$DRVDEALMEM	; Deallocate buffer

50$:	BSBB	START_RECEIVE		; Start the receives
	POPR	#^M<R3,R4,R5>		; Restore registers
	RSB
	.DSABL	LSB

	.SBTTL	START_RECEIVE - START ANY RECEIVE REQUESTS PENDING
;++
; START_RECEIVE - START ANY RECEIVE REQUESTS
;
; Functional description:
;
; This routine attemptes to start any receives that may be pending.  This
; involves dequeueing a free receive buffer, mapping it, and loading it's
; address and size into the device.
;
; Inputs:
;
;	R4 = CDB address
;	R5 = UCB address of unit # 0
;
;	IPL = FIPL
;
; Outputs:
;
;	R0-R3 are destroyed.
;	All other registers are preserved.
;
;--
 
START_RECEIVE::				; Start receive operation
	PUSHQ	R6			; Save R6, R7
	BBC	#CDB_STS_V_RUN,-	; Br if device is not running
		CDB_B_STS(R4),10$	;
5$:	FFC	#0,#MAX_C_RCV,CDB_B_RCVMAP(R4),R7 ; Get a free mapping slot
	BEQL	10$			; Br if none - just exit
	REMQUE	@CDB_Q_RCVBUF(R4),R3	; Get a free buffer
	BVC	20$			; Br if buffer found
10$:	POPQ	R6			; Restore R6, R7
	RSB				; Return to caller
;
; Mark slot in use and create buffer address/character count image
; in receive buffer and load UNIBUS adapter map registers.
;
20$:	SETBIT	R7,CDB_B_RCVMAP(R4)	; Mark slot in use
	MOVB	R7,CXB$B_XE_SLOT(R3)	; Save mapping slot index
	MOVL	UCB$L_CRB(R5),R2	; Get CRB address

	.IF DF	RCV_DATAP
;
; The following instruction also sets the default data path to the
; Direct Data Path.
;
	ASSUME	VEC$B_NUMREG EQ VEC$W_MAPREG+2
	ASSUME	VEC$B_DATAPATH EQ VEC$B_NUMREG+1
	MOVL	CDB_L_RCVMAP(R4)[R7],-	; Store mapping information
		 CRB$L_INTD+VEC$W_MAPREG(R2) ; into CRB.
;
; Try to allocate a buffered data path. If successful then use it, else
; use the Direct Data Path.
;
;*** The driver no longer uses the Buffered Data Paths for receive operations
;*** because there is no upper limit to the amount of time that the driver
;*** can hang onto the data path. Therefore, if there are other system devices
;*** (such as RK07s) which need the data paths then there is no guarantee as to
;*** when they will get one.
;***
	PUSHL	R2			; Save R2
	JSB	G^IOC$REQDATAPNW	; Try to get a buffered data path
	POPL	R2			; Restore R2
	ASSUME	VEC$B_NUMREG EQ VEC$W_MAPREG+2
	ASSUME	VEC$B_DATAPATH EQ VEC$B_NUMREG+1
	MOVL	CRB$L_INTD+VEC$W_MAPREG(R2),- ; Save number of data path
		 CDB_L_RCVMAP(R4)[R7]	;  used.

	.ENDC	; DF RCV_DATAP
;
; Find next ring entry and insert data
;
	MOVZBL	CDB_B_NEXTRCV(R4),R6	; Get next ring entry
	INCB	CDB_B_NEXTRCV(R4)	; Bump ring pointer
	BICB	#^C<MAX_C_RCV-1>,-	; Modulo rcv ring size
		 CDB_B_NEXTRCV(R4)	;
	MOVB	R6,CXB$B_XE_RING(R3)	; Save ring entry number
	MOVL	CDB_L_RRADDR(R4)[R6],R6	; Retrieve next ring entry address
	PUSHQ	R3			; Save IRP, CDB address

;
; Setup the ring descriptor entry for the recieve buffer. The length of the 
; buffer, which is a constant, was initiated when the controller was first 
; started up, and so is not setup here.
;

	MOVAB	CXB$T_R_DATA(R3),R1	; Get receive buffer data addr
	MOVW	R1,RCV_W_SEGBL(R6)	; Set BA0-BA8
	MOVAL	CDB_L_RCVMAP(R4)[R7],R7	; Get mapping info slot address
	INSV	(R7),#9,#7,RCV_W_SEGBL(R6) ; Set BA9-BA15 from map reg
	EXTZV	#7,#2,(R7),R0		; Get BA16-BA17 also
	MOVB	R0,RCV_B_SEGBH(R6)	; Set BA16-BA17
	MOVW	CXB$W_XE_RID(R3),RCV_W_RID(R6) ; Store unique request ID

	.IF DF	RCV_DATAP
	MOVZBL	CRB$L_INTD+VEC$B_DATAPATH(R2),R4 ; Get data path number
	.IFF	; DF RCV_DATAP
	CLRL	R4			; Use direct data path for rcvs
	.ENDC
	ASSUME	VEC$B_NUMREG EQ VEC$W_MAPREG+2
	MOVZBL	2(R7),R2		; Set number of map registers
	MOVZWL	(R7),R3			; Set first map register number
	JSB	G^IOC$LOADUBAMAPN	; Load the map registers
	POPQ	R3			; Restore IRP, CDB address
;
; Disable interrupts and queue request to input queue
;
	DSBINT	UCB$B_DIPL(R5)		; Disable interrupts
	MOVB	#RCV_FLG_M_OWN,RCV_B_FLAGS(R6) ; Give buffer to DEUNA/DELUA
	INCB	CDB_B_RCVCNT(R4)	; Tally one more receive in progress
	INSQUE	(R3),@CDB_Q_INPUT+4(R4)	; Insert receive buffer on
					;   input queue
	BNEQ	30$			; Br if not first entry on queue
	BSBB	LOAD_PORT		; Request port % give request to DEUNA/DELUA
30$:	ENBINT				; Re-enable interrupts
	BRW	5$			; Let's try it again

	.SBTTL	LOAD_PORT - LOAD CSR'S WITH COMMAND REQUEST
;++
; LOAD_PORT - LOAD CSR'S WITH COMMAND REQUEST
;
; Functional description:
;
; This routine loads the CSR's and PCBB with a command to process.
;
; Inputs:
;
;	R4 = CDB address
;	R5 = UCB address
;
;	IPL = DIPL
;
; Outputs:
;
;	R4,R5 are preserved.
;
;	R0-R3 may be destroyed.
;
;--
LOAD_PORT::				; Load port command
	BBCC	#CDB_STS_V_FUNC,CDB_B_STS(R4),10$ ; Br if function pending
	MOVL	UCB$L_CRB(R5),R2	; Get CRB address
	ASSUME	IDB$L_CSR EQ 0
	MOVL	@CRB$L_INTD+VEC$L_IDB(R2),R2 ; Get CSR address
	REMQUE	@CDB_Q_INPUT(R4),R3	; Get next IRP
	BVC	20$			; Br if got one
	BISB2	#CDB_STS_M_FUNC,CDB_B_STS(R4) ; Indicate no function pending
10$:	RSB				; Return to caller

20$:	MOVB	#DNI_TIM,CDB_B_TIM_DNI(R4) ; Start timer on DNI bit
	CMPB	IRP$B_TYPE(R3),#DYN$C_CXB ; Is this a CXB?
	BEQL	30$			; Br if yes
	MOVAB	CDB_G_PCBB(R4),R1	; Get PCBB address
	CMPB	IRP$B_TYPE(R3),#DYN$C_IRP ; Is this an IRP?
	BEQL	90$			; Br if yes
	BUG_CHECK NOBUFPCKT,FATAL	; Fatal error - what is it???
;
; Dispatch of CXB request
;
30$:	$DISPATCH	CXB$B_XE_FUNC(R3),TYPE=B,- ; Dispatch on function request
	<-	;function	action
		<XE_FC_V_XMIT	40$>,-	; XMIT requested
		<XE_FC_V_RECV	50$>,-	; RECV requested
	>

	BUG_CHECK NOBUFPCKT,FATAL	; Fatal error - not a valid IRP

;
; XMIT request
;
40$:	INSQUE	(R3),@CDB_Q_XMTPND+4(R4) ; Insert CXB on WAITING queue
	MOVB	#XMT_TIM,CDB_B_TIM_XMT(R4) ; Start xmit timer
	MOVB	#XE_PCSR0_M_INTE!XE_CMD_V_PDMD,- ; Load command
		PCSR0(R2)		;  and enable interrupts
	RSB				; Return to caller
;
; RECV request
;
50$:	INSQUE	(R3),@CDB_Q_RCVPND+4(R4) ; Insert CXB on WAITING queue
	MOVB	#XE_PCSR0_M_INTE!XE_CMD_V_PDMD,- ; Load command
		PCSR0(R2)		;  and enable interrupts
	RSB				; Return to caller

;
; Dispatch of IRP request
;
90$:	$DISPATCH	IRP$B_XE_FUNC(R3),TYPE=B,- ; Dispatch on function request
	<-	;function	action

		<XE_FC_V_INIT	IN_INIT>,-	; Initialize request
		<XE_FC_V_RESTART IN_INIT>,-	; Automatic restart
		<XE_FC_V_TESTD	IN_TESTD>,-	; Self-test done
		<XE_FC_V_LDRING	IN_RING>,-	; Setup ring descriptor
		<XE_FC_V_RDDPA	IN_RDDPA>,-	; Read default physical address
		<XE_FC_V_WTPHYAD IN_PHYAD>,-	; Write physical address
		<XE_FC_V_WTMULTI IN_MULTI>,-	; Write multicast address list
		<XE_FC_V_WTMODE	IN_MODE>,-	; Define mode
		<XE_FC_V_START	IN_START>,-	; Start XMIT/RECV process
		<XE_FC_V_RDCNTS	IN_RDCNTS>,-	; Read counters
		<XE_FC_V_RCCNTS IN_RCCNTS>,-	; Read and clear counters
		<XE_FC_V_MULTI	IN_MULTIC>,-	; Write new multicast list
		<XE_FC_V_LDMEM	IN_LDMEM>,-	; Load DEUNA/DELUA memory
		<XE_FC_V_RDMEM	IN_RDMEM>,-	; Read DEUNA/DELUA memory
		<XE_FC_V_UPST	IN_UPST>,-	; Load and start micro-address
		<XE_FC_V_LDSID	IN_LDSID>,-	; Load system ID parameters
		<XE_FC_V_RDSID	IN_RDSID>,-	; Read system ID parameters
		<XE_FC_V_STOPPR	IN_STOPPR>,-	; Stop xmit and receive process
		<XE_FC_V_STEST	IN_STEST>,-	; Perform DEUNA/DELUA self test
		<XE_FC_V_READST	IN_READST>,-	; Read port status
		<XE_FC_V_CHMODE	IN_CHMODE>,-	; Change the mode definition
		<XE_FC_V_STOP	IN_RSMODE>,-	; Reset the mode definition
		<XE_FC_V_MOPCTR	IN_RDCNTS>,-	; MOP read counters request
		<XE_FC_V_ESTEST	IN_ESTEST>,-	; Perform DELUA extended self test
		<XE_FC_V_HALT	IN_HALT>,-	; Halt port (DELUA only)
	>

	BUG_CHECK NOBUFPCKT,FATAL	; Fatal error - not a valid IRP


IN_INIT:				; Initialize DEUNA/DELUA request
;
;  Perform SELF-TEST on the UNA
;
	MOVB	#XE_PCSR0_M_INTE!XE_CMD_V_STEST,- ; Load self-test command
		PCSR0(R2)		;  and enable interrupts
	MOVB	#XE_FC_V_TESTD,IRP$B_XE_FUNC(R3) ; Set up next function
	BRW	CONTIN			; Contine the request
;
; Check completion status of self-test and load PCBB address if okay
;
IN_TESTD:				; SELF-TEST done
	BICW3	#XE_PCSR1_M_DEVID,-	; Get DEUA/DELUA status,
		PCSR1(R2),R0		;  minus device id
	CMPW	#XE_STAT_V_READY,R0	; Is the DEUNA/DELUA okay?
	BEQL	20$			; Br if YES - good DEUNA/DELUA
	MOVB	PCSR1+1(R2),CDB_L_DEVDEPEND(R4) ; Save self-test status code
	MOVZWL	#SS$_CTRLERR,R0		; Assume broken DEUNA/DELUA
	BBC	#XE_PCSR1_V_XPWR,PCSR1(R2),10$ ; Br if the XCVR power is okay
	MOVZWL	#SS$_MEDOFL,R0		; Else, return the correct indicator
	SETBIT	#XM$V_STS_DISC,CDB_L_DEVDEPEND(R4) ; Save Internal error reason
10$:	BRW	REQ_COM_ERR		; Complete request in error

20$:	MOVW	CDB_L_PCBBUA(R4),PCBB0(R2) ; Load PCBB UNIBUS address
	MOVB	CDB_L_PCBBUA+2(R4),PCBB2(R2) ;
	MOVB	#XE_PCSR0_M_INTE!XE_CMD_V_GETPCBB,- ; Load command
		PCSR0(R2)		;  and enable interrupts
	MOVB	#XE_FC_V_LDRING,IRP$B_XE_FUNC(R3) ; Set next function
	BRW	CONTIN			; Contine the request

IN_RING:				; Setup ring descriptor
	MOVW	#PB_FC_V_WTRING,PBB_B_FUNC(R1) ; Set function request
	MOVL	CDB_L_PCBBUA(R4),R0	; Get PCBB UNIBUS address
	ADDL	#CDB_G_XRUDB-CDB_G_PCBB,R0 ; Compute RING DESCRIPTOR address
	MOVL	R0,PBB_W_PCBB2(R1)	; Store RING DESCRIPTOR address
	MOVB	#XE_PCSR0_M_INTE!XE_CMD_V_GETCMD,- ; Load command
		PCSR0(R2)		;  and enable interrupts
	MOVB	#XE_FC_V_RDDPA,IRP$B_XE_FUNC(R3) ; Set next function
	BRW	CONTIN			; Continue request

IN_RDDPA:
	MOVW	#PB_FC_V_RDDEFAULT,PBB_B_FUNC(R1) ; Set function request
	MOVB	#XE_PCSR0_M_INTE!XE_CMD_V_GETCMD,- ; Load command
		PCSR0(R2)		;  and enable interrupts
	MOVB	#XE_FC_V_WTPHYAD,IRP$B_XE_FUNC(R3) ; Set next function
	BRB	CONTIN			; Continue request

IN_PHYAD:				; Write physical address
	MOVL	PBB_W_PCBB2(R1),CDB_G_HWA(R4) ; Save hardware physical address
	MOVW	PBB_W_PCBB6(R1),CDB_G_HWA+4(R4) ;	...
	MOVL	PBB_W_PCBB2(R1),CDB_G_PHYADR(R4) ; Save current address
	MOVW	PBB_W_PCBB6(R1),CDB_G_PHYADR+4(R4) ;	...
	BLBS	CDB_G_PHA(R4),IN_MULTI	; Br if physical address not there
	MOVW	#PB_FC_V_WTPHYAD,PBB_B_FUNC(R1) ; Set function request
	MOVL	CDB_G_PHA(R4),PBB_W_PCBB2(R1) ; Store physical address
	MOVW	CDB_G_PHA+4(R4),PBB_W_PCBB6(R1) ;	...
	MOVL	CDB_G_PHA(R4),CDB_G_PHYADR(R4) ; Store current address
	MOVW	CDB_G_PHA+4(R4),CDB_G_PHYADR+4(R4) ;	...
	MOVB	#XE_PCSR0_M_INTE!XE_CMD_V_GETCMD,- ; Load command
		PCSR0(R2)		;  and enable interrupts
	MOVB	#XE_FC_V_WTMULTI,IRP$B_XE_FUNC(R3) ; Set next function
	BRB	CONTIN			; Continue request

IN_MULTI:				; Write multicast address list
	TSTB	CDB_B_MULTI(R4)		; Any entries?
	BEQL	IN_MODE			; Br if none ..do a write mode
	MOVW	#PB_FC_V_WTMULTI,PBB_B_FUNC(R1) ; Set function request
	MOVL	CDB_L_PCBBUA(R4),R0	; Get PCBB UNIBUS address
	ADDL	#CDB_G_MUDB-CDB_G_PCBB,R0 ; Compute address of multicast list
	MOVL	R0,PBB_W_PCBB2(R1)	; Store address of multicast list
	MOVB	CDB_B_MULTI(R4),PBB_W_PCBB4+1(R1) ; Set number of entries
	MOVB	#XE_PCSR0_M_INTE!XE_CMD_V_GETCMD,- ; Load command
		PCSR0(R2)		;  and enable interrupts
	MOVB	#XE_FC_V_WTMODE,IRP$B_XE_FUNC(R3) ; Set next function
	BRB	CONTIN			; Continue request

IN_MODE:				; Define mode
	MOVB	#PB_FC_V_WTMODE,PBB_B_FUNC(R1) ; Set function request
	MOVW	CDB_W_MODE(R4),PBB_W_PCBB2(R1) ; Define new mode
	MOVB	#XE_PCSR0_M_INTE!XE_CMD_V_GETCMD,- ; Load command
		PCSR0(R2)		;  and enable interrupts
	MOVB	#XE_FC_V_START,IRP$B_XE_FUNC(R3) ; Set next function
CONTIN:	INSQUE	(R3),CDB_Q_INPUT(R4)	; Insert at front of input queue
	RSB

IN_CHMODE:				; Change the mode definition
	ASSUME	NMA$C_STATE_ON EQ 0
	ASSUME	NMA$C_STATE_OFF EQ 1
	CLRL	R0			; Assume we don't have to define mode
	BLBS	UCB$B_XE_PRM(R5),10$	; Br if not promiscuous user
	BBSS	#PB_MOD_V_PROM,-	; Else change to promiscuous mode
		CDB_W_MODE(R4),10$	; ..and skip if already set
	CLRB	CDB_B_PRM(R4)		; Set new characteristic in CDB
	INCL	R0			; Indicate we have to define the mode
10$:	BLBS	UCB$B_XE_MLT(R5),20$	; Br if all multicasts not enabled
	BBSS	#PB_MOD_V_ENAL,-	; Else, set to enable all mlts
		CDB_W_MODE(R4),20$	; ..and skip if already enabled
	CLRB	CDB_B_MLT(R4)		; Set new characteristic in CDB
	BISL	#1,R0			; Indicate need to define the mode
20$:	BLBC	R0,IN_MULTIC		; Br if we don't have to define mode
	MOVB	#PB_FC_V_WTMODE,PBB_B_FUNC(R1) ; Set function request
	MOVW	CDB_W_MODE(R4),PBB_W_PCBB2(R1) ; Define new mode
	MOVB	#XE_PCSR0_M_INTE!XE_CMD_V_GETCMD,- ; Load command
		PCSR0(R2)		;  and enable interrupts
	MOVB	#XE_FC_V_MULTI,IRP$B_XE_FUNC(R3) ; Set next function
	BRB	CONTIN			; Wait for next function

IN_RSMODE:				; Reset the mode definition
	MOVB	#PB_FC_V_WTMODE,PBB_B_FUNC(R1) ; Set function request
	MOVW	CDB_W_MODE(R4),PBB_W_PCBB2(R1) ; Define new mode
	BRB	DONE			; Request is complete
	
	.ENABL	LSB
IN_RCCNTS:				; Read and clear counters request
	MOVB	#PB_FC_V_RCCNTS,PBB_B_FUNC(R1) ; Set function request
	BRB	10$
IN_RDCNTS:				; Read counters request
	MOVB	#PB_FC_V_RDCNTS,PBB_B_FUNC(R1) ; Set function request
10$:	MOVL	CDB_L_PCBBUA(R4),R0	; Get PCBB UNIBUS address
	ADDL	#CDB_G_CUDB-CDB_G_PCBB,R0 ; Compute Counter UDB address
	MOVL	R0,PBB_W_PCBB2(R1)	; Store Counter UDB address
	MOVW	#UDB_CTR_K_LENGTH,PBB_W_PCBB6(R1) ; Set size of counter blk
PEND1:	MOVB	#XE_PCSR0_M_INTE!XE_CMD_V_GETCMD,- ; Load port command
		PCSR0(R2)		;  and enable interrupts
PEND:	INSQUE	(R3),@CDB_Q_DONE+4(R4)	; Post on waiting queue
	RSB
	.DSABL	LSB

IN_MULTIC:				; Write new multicast address list
	BSBW	MOVE_MULTI		; Copy the multicast address list
	MOVW	#PB_FC_V_WTMULTI,PBB_B_FUNC(R1) ; Set function request
	MOVL	CDB_L_PCBBUA(R4),R0	; Get PCBB UNIBUS address
	ADDL	#CDB_G_MUDB-CDB_G_PCBB,R0 ; Compute address of multicast list
	MOVL	R0,PBB_W_PCBB2(R1)	; Store address of multicast list
	MOVB	CDB_B_MULTI(R4),PBB_W_PCBB4+1(R1) ; Set number of entries
DONE:	MOVB	#XE_PCSR0_M_INTE!XE_CMD_V_GETCMD,- ; Load command
		PCSR0(R2)		;  and enable interrupts
	BRW	REQ_COM			; Request is complete

IN_LDMEM:				; Load DEUNA/DELUA memory
	MOVW	#PB_FC_V_LOADMEM,PBB_B_FUNC(R1) ; Set function request
	MOVL	CDB_L_PCBBUA(R4),R0	; Get PCBB UNIBUS address
	ADDL	#CDB_G_SCRUDB-CDB_G_PCBB,R0 ; Compute address of scratch UDB
	MOVL	R0,PBB_W_PCBB2(R1)	; Store address of scratch UDB
	MOVW	IRP$W_BCNT(R3),R0	; Get user buffer length
;
;	The following rounding is required by the DEUNA/DELUA hardware.
;	The rounding should have no effect on the buffer size, since
;	the allocation routine rounds to a multiple of 16 bytes anyway.
;
	ASSUME	P2B_T_DATA LE 12	; For rounding to be valid
	INCL	R0			; Round up buffer size
	BICW	#1,R0			;	...
	MOVW	R0,CDB_G_SCRUDB(R4)	; Set size of load
	MOVL	IRP$L_XE_DGUNI(R3),-	; Store user UNIBUS buffer address
		CDB_G_SCRUDB+2(R4)	;
	MOVW	IRP$L_XE_UPADR(R3),-	; Set IDBB internal address
		CDB_G_SCRUDB+6(R4)	;
	BRB	PEND1			; Request is pending

IN_RDMEM:				; Read DEUNA/DELUA memory
	MOVW	#PB_FC_V_DUMPMEM,PBB_B_FUNC(R1) ; Set function request
	MOVL	CDB_L_PCBBUA(R4),R0	; Get PCBB UNIBUS address
	ADDL	#CDB_G_SCRUDB-CDB_G_PCBB,R0 ; Compute address of scratch UDB
	MOVL	R0,PBB_W_PCBB2(R1)	; Store address of scratch UDB
	MOVW	IRP$W_BCNT(R3),R0	; Get user buffer length
;
;	The following rounding is required by the DEUNA/DELUA hardware.
;	The rounding should have no effect on the buffer size, since
;	the allocation routine rounds to a multiple of 16 bytes anyway.
;
	ASSUME	P2B_T_DATA LE 12	; For rounding to be valid
	INCL	R0			; Round up buffer size
	BICW	#1,R0			;	...
	MOVW	R0,CDB_G_SCRUDB(R4)	; Set size of load
	MOVL	IRP$L_XE_DGUNI(R3),-	; Store user UNIBUS buffer address
		CDB_G_SCRUDB+2(R4)	;
	MOVW	IRP$L_XE_UPADR(R3),-	; Set IDBB internal address
		CDB_G_SCRUDB+6(R4)	;
	BRW	PEND1			; Request is pending

IN_UPST:				; Load and start micro-address
	MOVW	#PB_FC_V_LSUADDR,PBB_B_FUNC(R1) ; Set function request
	MOVW	IRP$L_XE_UPADR(R3),-	; Set IDBB UNIBUS address
		PBB_W_PCBB2(R1)		;
	BRW	DONE			; Request is complete
	
IN_LDSID:				; Load system ID parameters
	MOVW	#PB_FC_V_WTSYSID,PBB_B_FUNC(R1) ; Set function request
	MOVL	CDB_L_PCBBUA(R4),R0	; Get PCBB UNIBUS address
	ADDL	#CDB_G_SIDUDB-CDB_G_PCBB,R0 ; Compute address of SID UDB
	MOVL	R0,PBB_W_PCBB2(R1)	; Store address of SID UDB
	ASSUME	P2B_L_POINTER EQ 0
	MOVL	@IRP$L_SVAPTE(R3),R0	; Get address of system ID parameters
	MOVQ	(R0),CDB_G_SIDUDB(R4)	; Copy system ID parameters
	MOVW	#4,PBB_W_PCBB6(R1)	; Write only 4 words - all others
					; are Read Only!
	BRW	DONE			; Request is complete

IN_RDSID:				; Read system ID parameters
	MOVW	#PB_FC_V_RDSYSID,PBB_B_FUNC(R1) ; Set function request
	MOVL	CDB_L_PCBBUA(R4),R0	; Get PCBB UNIBUS address
	ADDL	#CDB_G_SIDUDB-CDB_G_PCBB,R0 ; Compute address of SID UDB
	MOVL	R0,PBB_W_PCBB2(R1)	; Store address of SID UDB
	MOVW	#<UDB_SID_C_LENGTH/2>,-	; Set size of UDB
		PBB_W_PCBB6(R1)		;
	BRW	PEND1			; Request is pending

IN_STEST:				; Perform DEUNA/DELUA self-test
	MOVB	#XE_PCSR0_M_INTE!XE_CMD_V_STEST,- ; Load command
		PCSR0(R2)		;  and enable interrupts
	BICB	#CDB_STS_M_RUN,-	; Clear the RUN bit
		CDB_B_STS(R4)		;
	BRW	PEND			; Hold the request pending
					;  until DNI is set

IN_READST:				; Read port status
	MOVW	#PB_FC_V_RDSTATUS,PBB_B_FUNC(R1) ; Set function request
	BRW	PEND1			; Request is pending

IN_STOPPR:				; Stop XMIT/RECV processes
	MOVB	#XE_PCSR0_M_INTE!XE_CMD_V_STOP,- ; Load command
		PCSR0(R2)		;  and enable interrupts
	BICB	#CDB_STS_M_RUN,-	; Clear the RUN bit
		CDB_B_STS(R4)		;
	BRB	REQ_COM			; Request is now complete

IN_START:				; Start XMIT/RECV processes
	MOVB	#XE_PCSR0_M_INTE!XE_CMD_V_START,- ; Load command
		PCSR0(R2)		;  and enable interrupts
	BISB	#CDB_STS_M_RUN,-	; Set the RUN bit
		CDB_B_STS(R4)		;
	MOVL	IRP$L_UCB(R3),R5	; Get UCB address
	BISW	#UCB$M_XE_RUN,-		; Here also
		UCB$W_DEVSTS(R5)	;
	BICW	#UCB$M_INT!UCB$M_TIM,-	; No timeout is possible now
		UCB$W_STS(R5)		;
	SAVIPL				; Save the current IPL for WFIKPCH
	WFIKPCH	START_CONT,#2		; Wait 2 seconds for hardware state
					;   to get set
START_CONT:				; Continue with startup
	CLRBIT	#UCB$V_TIMOUT,UCB$W_STS(R5) ; Clear timeout status
	MOVL	UCB$L_CRB(R5),R2	; Get CRB address
	ASSUME	IDB$L_CSR EQ 0
	MOVL	@CRB$L_INTD+VEC$L_IDB(R2),R2 ; Get CSR address
	PUSHL	R5			; Save UCB address
	BSBB	REQ_COM			; Finish the startup request
	POPL	R5			; Restore R5
	RSB				; Return to timout processing

IN_ESTEST:				; Perform the DELUA extended self-test
	MOVB	#XE_PCSR0_M_INTE!XE_CMD_V_ESTEST,- ; Load command
		PCSR0(R2)		;  and enable interrupts
	BICB	#CDB_STS_M_RUN,-	; Clear the RUN bit
		CDB_B_STS(R4)		;
	BRW	PEND			; Hold the request pending
					;  until DNI is set

IN_HALT:				; Halt the port (DELUA only)
	MOVB	#XE_PCSR0_M_INTE!XE_CMD_V_HALT,- ; Load command
		PCSR0(R2)		;  and enable interrupts
	BICB	#CDB_STS_M_RUN,-	; Clear the RUN bit
		CDB_B_STS(R4)		;
	;BRB	REQ_COM			; Request is now complete

;+
; Complete request
;-

REQ_COM:				; Request complete
	MOVZBL	S^#SS$_NORMAL,R0	; Indicate success
REQ_COM_ERR:				; Complete request in error
	MOVW	R0,IRP$W_XE_STATUS(R3)	; Set completion status
	INSQUE	(R3),@CDB_Q_POST+4(R4)	; Insert IRP on posting queue
	MOVW	PCSR1(R2),R3		; Fetch the CSR contents
	ASHL	#16,R3,R3		; Shift to high word of R3
	MOVW	PCSR0(R2),R3		; Fetch remaining CSR contents
	BRW	SCHED_FORK		; Schedule a fork process

	.SBTTL	DONE_INTR - DEUNA/DELUA COMPLETION INTERRUPT SERVICE ROUTINE
;++
; DONE_INTR - DEUNA/DELUA COMPLETION INTERRUPT SERVICE ROUTINE
;
; Functional description:
;
; This routine services the interrupts generated by the DEUNA/DELUA for 
; completion of requests.
;
; Inputs:
;
;	00(SP) = ADDRESS OF UNIT IDB ADDRESS
;
;	R0,R1,R2,R3,R4,R5 ARE AT 04(SP) TO 1C(SP)
;
;
;	IPL = DIPL
;
; Outputs:
;
;	THE INTERRUPT IS DISMISSED
;
; IMPLICIT OUTPUTS:
;
;	A Fork process is started to check ring entries.
;--
DONE_INTR::				; DEUNA/DELUA done interrupt
	MOVL	@(SP)+,R4		; Get IDB address
	MOVL	IDB$L_UCBLST(R4),R5	; Get first UCB address
	ASSUME	IDB$L_CSR EQ 0
	MOVL	(R4),R2			; Get CSR address
	MOVL	UCB$L_XE_CDB(R5),R4	; Get CDB address
	BEQL	5$			; Br if CDB not allocated
	BBC	#CDB_STS_V_INITED,-	; Br if NOT inited
		CDB_B_STS(R4),5$	;
	BBS	#CDB_STS_V_ERR,- 	; Br if there was an error
		CDB_B_STS(R4),5$	;
	MOVW	PCSR1(R2),R3		; Fetch the CSR contents
	ASHL	#16,R3,R3		; Shift to high word of R3
	MOVW	PCSR0(R2),R3		; Fetch remaining CSR contents
	BBC	#XE_PCSR0_V_FATL,R3,1$	; Was FATL set (DELUA only) ?
	BICL2	#^C^XFFFF,R3		; If so, then zero PCSR1 bits
1$:	ASHL	#-8,R3,R1		; Shift out port command
;
; The interrupt bits can only be cleared by writing one's into them, therefore
; we will write one's into all bits which already have one's.
;
	MOVB	R1,PCSR0+1(R2)		; Release interrupt interlock
	BBS	#XE_PCSR0_V_INTR,R3,10$	; Br if valid interrupt
	BISL2	#XE_PCSR0_M_ILLINT,R3	; Indicate cause of error
	BRB	15$			; Schedule a fork process

5$:	BRW	INTEXIT			; Long branch to INTEXIT
;
; We will check for any errors at all, and then for fatal errors only.
; We do this for speed, since error cases should be the exception.
;
10$:	BITW	#XE_PCSR0_M_USCI!-	; Any errors?
		XE_PCSR0_M_FATL!-	;	...
		XE_PCSR0_M_PCEI!-	;	...
		XE_PCSR0_M_RCBI!-	;	...
		XE_PCSR0_M_SERI,R3	;	...
	BEQL	20$			; Br if NOT
	BBC	#XE_PCSR0_V_RCBI,R3,13$	; Br if FATAL error
	BISW	#CDB_STS_M_RCBI,-	; Indicate RCBI error
		CDB_B_STS(R4)		;
	INCC	CDB_W_SBUCTR(R4),W	; BUMP the counter
	BITW	#XE_PCSR0_M_USCI!-	; Is it also a FATAL error?
		XE_PCSR0_M_FATL!-	;	...
		XE_PCSR0_M_PCEI!-	;	...
		XE_PCSR0_M_SERI,R3	;	...
	BEQL	20$			; Br if NOT
13$:	BITW	#XE_PCSR0_M_USCI!-	; Is this a fatal error?
		XE_PCSR0_M_FATL!-	;	...
		XE_PCSR0_M_PCEI,R3	;
	BNEQ	15$			; Br if YES
	ASHL	#-16,R3,R0		; Shift down PCSR1 contents
	CMPB	#XE_STAT_V_RUN,R0	; Is this the run state?
	BEQL	20$			; Br if yes - ignore error indicator
15$:	SETBIT	#XE_PCSR0_V_USCI,R3	; Set fatal error indicator
	SETBIT	#CDB_STS_V_ERR,-	; Ignore futher interrupts
		CDB_B_STS(R4)		;
	BICB	#CDB_STS_M_FUNC,CDB_B_STS(R4) ; Indicate function is pending
	MOVB	CDB_G_PCBB(R4),-	; Save current PCBB contents
		CDB_B_SPARE(R4)		;  in temporary cell for now
	MOVW	#PB_FC_V_RDSTATUS,-	; Request the PORT STATUS
		CDB_G_PCBB(R4)		;
	MOVB	#XE_PCSR0_M_INTE!XE_CMD_V_GETCMD,- ; Fetch the port status
		PCSR0(R2)		;
	TIMEWAIT #5,#XE_PCSR0_M_DNI,PCSR0(R2),W ; Wait for DNI or 50 usec
	MOVB	CDB_B_SPARE(R4),-	; Save previous PCBB contents
		CDB_G_PCBB+1(R4)	;  in high byte of PCBB
	BRB	30$			; Schedule a fork process

20$:	BBC	#XE_PCSR0_V_DNI,R3,30$	; Br if not a completion interrupt
	BISB	#CDB_STS_M_FUNC,CDB_B_STS(R4) ; Indicate function complete
	CLRB	CDB_B_TIM_DNI(R4)	; Stop DNI timer
	REMQUE	@CDB_Q_DONE(R4),R2	; Get waiting packet
	BVS	25$			; Br if none
	MOVQ	CDB_G_PCBB(R4),-	; Take snapshot of PCBB
		IRP$Q_XE_PCB(R2)	;	...
	INSQUE	(R2),@CDB_Q_POST+4(R4)	; Insert packet on posting queue
25$:	PUSHQ	R3			; Save R3, R4
	BSBW	LOAD_PORT		; Load CSR's with next command
	POPQ	R3			; Restore R3, R4
30$:	BSBB	SCHED_FORK		; Schedule a fork process
	
INTEXIT:				; Exit interrupt
	MOVQ	(SP)+,R0		; Restore Regs
	MOVQ	(SP)+,R2
	MOVQ	(SP)+,R4
	REI				; Dismiss the interrupt

	.SBTTL	SCHED_FORK - SCHEDULE THE FORK PROCESS
	.SBTTL	SCHED_FORKC - SCHEDULE THE FORK PROCESS WITH R3 CLEAR
;++
; SCHED_FORK - Schedule the fork process
; SCHED_FORKC - Schedule the fork process with R3 clear
;
; Functional description:
;
; This routine is called to schedule the error and I/O completion fork process.
; The last controller port and CSR values are saved for examination.  If the
; fork process is already pending, only the last CSR values are saved if there
; was an error.
;
; Inputs:
;
;	R3 = Last PCSR0 and PCSR1 values
;	R4 = CDB address
;
;	IPL = DIPL or higher
;
; Outputs:
;
;	R3 is cleared if SCHED_FORKC entry.
;	R4 is destroyed.
;	R5 = CDB address
;
; If XE_PCSR0_V_USCI is set in PCSR0, then the following is returned:
;
;	CDB_L_PCSR0(R4) = PCSR0 and PCSR1 values
;
;--
 
SCHED_FORKC::				; Schedule fork process, clr R3
	CLRL	R3			; No device error
SCHED_FORK::				; Schedule fork process
	BBSS	#CDB_STS_V_FORK_PEND,CDB_B_STS(R4),10$ ; Br if fork pending
	ASSUME	CDB_L_FQFL EQ 0
	MOVL	R4,R5			; Get CDB fork block address
	PUSHAB	B^FORK_PROC		; Else, set address of fork process
	JMP	G^EXE$FORK		; Schedule the fork and return
 
10$:	BBC	#XE_PCSR0_V_USCI,R3,20$ ; Br if not error
	MOVL	R3,CDB_L_PCSR0(R4)	; Save last CSR values
20$:	RSB				; Return to caller

	.SBTTL	FORK_PROC - Error and completion fork process handling
;++
; FORK_PROC - Error and completion fork processing
;
; Functional description:
;
; This routine is called as a fork process to handle errors and all completions
; pending.
;
; Inputs:
;
;	R3 = Last SEL0 and SEL2 values
;	R4 = CDB address
;	R5 = CDB address
;
;	IPL = FIPL
;
; Outputs:
;
;	R0-R5 are destroyed.
;
;--
	.WORD	TIMEOUT-.		; Offset to timeout routine
	.ENABL	LSB
FORK_PROC::				; Error/completion fork process
	CLRBIT	#CDB_STS_V_FORK_PEND,CDB_B_STS(R4) ; Clear fork process flag
	BBC	#XE_PCSR0_V_USCI,R3,10$	; Br if not an error
	SETBIT	#XM$V_ERR_FATAL,CDB_L_DEVDEPEND(R4) ; Indicate fatal error
	ASHL	#-8,R3,R5		; Get high byte of PCSR0
	MOVB	R5,CDB_L_DEVDEPEND+3(R4) ; Save high byte of PCSR0
	MOVL	CDB_L_UCB0(R4),R5	; Get UCB #0 address
	INCW	UCB$W_ERRCNT(R5)	; Bump error counter
	BRW	SHUTDOWN_UNA		; Shutdown the DEUNA/DELUA device
;
; Complete any requests on completion queue
;
10$:	REMQUE	@CDB_Q_POST(R4),R3	; Get next completed block
	BVC	20$			; Br if got one
	BSBW	SCAN_LISTS		; Scan XMIT/RECV lists
	RSB				; Return to caller
;
; Found a completed block - finish it
;
20$:	CMPB	IRP$B_TYPE(R3),S^#DYN$C_IRP ; Was it an IRP?
	BEQL	30$			; Br if yes - complete it
	BUG_CHECK NOBUFPCKT,FATAL	; Else, fatal error
;
; IRP packet completion - branch to proper completion handling routine.
;
30$:	MOVZBL	IRP$B_XE_FUNC(R3),R2	; Get function type
	MOVL	IRP$L_UCB(R3),R5	; Set UCB address
	$DISPATCH	R2,TYPE=B,-
	<-	;function	action

		<XE_FC_V_INIT	FORK_INIT>,-	; Start request
		<XE_FC_V_RESTART FORK_INIT>,-	; Automatic restart
		<XE_FC_V_TESTD	FORK_INIT>,-	; Self-test done
		<XE_FC_V_LDRING	FORK_INIT>,-	; Load ring pointer
		<XE_FC_V_RDDPA	FORK_INIT>,-	; Read default physical address
		<XE_FC_V_WTPHYAD FORK_INIT>,-	; Write physical address
		<XE_FC_V_WTMULTI FORK_INIT>,-	; Write multicast address
		<XE_FC_V_WTMODE	FORK_INIT>,-	; Write DEUNA/DELUA mode
		<XE_FC_V_START	FORK_INIT>,-	; Start XMIT/RECV process
		<XE_FC_V_RDCNTS	FORK_COUNTER>,-	; Read counts
		<XE_FC_V_RCCNTS	FORK_COUNTER>,-	; Read and clear counts
		<XE_FC_V_MULTI	FORK_PKT>,-	; Write multicast address list
		<XE_FC_V_LDMEM	FORK_LDMEM>,-	; Load DEUNA/DELUA memory
		<XE_FC_V_RDMEM	FORK_RDMEM>,-	; Read DEUNA/DELUA memory
		<XE_FC_V_UPST	FORK_PKT>,-	; Load and start micro-address
		<XE_FC_V_LDSID	FORK_PKT>,-	; Load system ID parameters
		<XE_FC_V_RDSID	FORK_RDSID>,-	; Read system ID parameters
		<XE_FC_V_STOPPR	FORK_PKT>,-	; Stop xmit and receive process
		<XE_FC_V_STEST	FORK_PKT>,-	; Perform DEUNA/DELUA self test
		<XE_FC_V_READST	FORK_READST>,-	; Read port status
		<XE_FC_V_CHMODE	FORK_PKT>,-	; Change the mode definition
		<XE_FC_V_STOP	FORK_STOP>,-	; Stop protocol
		<XE_FC_V_MOPCTR	FORK_PKT>,-	; Mop counter read request
		<XE_FC_V_ESTEST	FORK_PKT>,-	; Perform DELUA extended self test
		<XE_FC_V_HALT	FORK_PKT>,-	; Halt port (DELUA only)
	>
;
; Otherwise BUG_CHECK if not a valid IRP
;
	BUG_CHECK NOBUFPCKT,FATAL	; Fatal driver error
 
FORK_PKT:				; Process completion on packet
	MOVZWL	IRP$W_XE_STATUS(R3),R0	; Get status of completion
	BSBW	IO_DONE			; Complete the I/O
	BRW	10$			; Get next packet
 
FORK_INIT:				; Process init completion
	CMPB	S^#XE_FC_V_INIT,IRP$L_MEDIA+1(R3) ; Was this an initialize?
	BNEQ	FORK_PKT		; Br if not
	MOVZWL	IRP$W_XE_STATUS(R3),R0	; Get completion status
	PUSHL	R0			; Save completion status
	CMPW	#SS$_BADPARAM,R0	; Is this bad parameter?
	BNEQ	35$			; Br if no
;
; For SS$_BADPARAM, must return bad parameter code
;
	MOVZWL	R0,IRP$L_IOST1(R3)	; Return error code
	MOVZWL	IRP$W_XE_CODE(R3),IRP$L_IOST2(R3) ; Return bad parameter code
	BSBW	IO_DONE2		; Complete the I/O request
	BRB	37$			; On our merry way...
;
; Not SS$_BADPARAM error code, no bad parameter code
;
35$:	BSBW	IO_DONE			; Complete the I/O request

37$:	POPL	R0			; Restore status
	BLBC	R0,40$			; Br ir error on startup
	BSBW	FILLRCVLIST		; Start the receives on success
40$:	BRW	10$			; Get next packet

FORK_STOP:
	BSBW	SHUTDOWN_PROTYP		; Shutdown the PROTOCOL
	MOVZBL	S^#SS$_NORMAL,R0	; Return success
	BRW	IO_DONE			; Complete the I/O request

FORK_COUNTER:				; Process counter done
	PUSHR	#^M<R4,R5,R6,R7>	; Save registers
	ASSUME	P2B_L_POINTER EQ 0
	MOVL	@IRP$L_SVAPTE(R3),R2	; Point to start of data area
	MOVAB	CDB_G_CUDB(R4),R6	; Get address of counters
	MOVAB	CTRTAB,R5		; Get address of counter format table
	MOVZBL	#LINE_CNT_SIZE,R1	; Get number of entries in table
50$:	MOVZWL	(R5)+,R0		; Get counter code
	MOVW	R0,(R2)+		; Return counter type code
	MOVZWL	(R5)+,R7		; Get offset word
	EXTZV	#NMA$V_CNT_MAP,#3,R0,R0	; Get width + bit map indicator
	CASE	R0,TYPE=B,LIMIT=#2,<-	; Dispatch on width and bit map
		60$,-			; 8 bit counter
		70$,-			; 8 bit counter + bit map
		80$,-			; 16 bit counter
		90$,-			; 16 bit counter + bit map
		100$>			; 32 bit counter
;
; All others - fatal error
;
	BUG_CHECK NOBUFPCKT,FATAL
;
; 8 bit counter
;
60$:	MOVB	(R6)[R7],(R2)+		; Store counter value
	BRB	110$			; Check if more
;
; 8 bit counter + bit map
;
70$:	MOVB	(R6)[R7],(R2)+		; Store bit map
	INCL	R7			; Skip to next byte
	MOVB	(R6)[R7],(R2)+		; Store rest of bit map
	INCL	R7			; Skip to next byte
	BRB	60$			; Store counter value
;
; 16 bit counter
;
80$:	MOVW	(R6)[R7],(R2)+		; Store counter value
	BRB	110$			; Check if more
;
; 16 bit counter + bit map
;
90$:	MOVW	(R6)[R7],(R2)+		; Store bit map
	INCL	R7			; Skip to counter
	BRB	80$			; Store counter value
;
; 32 bit counter
;
100$:	MOVL	(R6)[R7],(R2)+		; Store counter value
	;BRB	110$			; Check if more

110$:	SOBGTR	R1,50$			; Loop if more
;
; Get the counters kept by the driver
;
	MOVAB	LINE_CTR,R5		; Get address of counter format table
	MOVZBL	#LINE_CTR_SIZE,R1	; Get number of entries in table
112$:	MOVZWL	(R5)+,R0		; Get counter code
	MOVW	R0,(R2)+		; Return counter type code
	MOVZWL	(R5)+,R7		; Get offset word
	ADDL	R4,R7			; Point to counter in CDB
	EXTZV	#NMA$V_CNT_MAP,#3,R0,R0	; Get width + bit map indicator
	CASE	R0,TYPE=B,LIMIT=#2,<-	; Dispatch on width and bit map
		113$,-			; 8 bit counter
		113$,-			; 8 bit counter + bit map
		114$,-			; 16 bit counter
		113$,-			; 16 bit counter + bit map
		113$>			; 32 bit counter

113$:	BUG_CHECK NOBUFPCKT,FATAL	; All others, fatal error
;
; 16 BIT counter
;
114$:	MOVW	(R7),(R2)+		; Store counter in buffer
	CMPB	#XE_FC_V_RCCNTS,-	; Is this a clear operation
		IRP$B_XE_FUNC(R3)	;  as well?
	BNEQ	115$			; Br if not
	CLRW	(R7)			; Else, clear the counter
115$:	SOBGTR	R1,112$			; Loop if more

	POPR	#^M<R4,R5,R6,R7>	; Restore registers
	MOVZWL	IRP$W_BCNT(R3),R0	; Get size of P2 buffer
	CLRW	IRP$W_BCNT(R3)		; Assume error - no data return
	BLBC	IRP$W_XE_STATUS(R3),130$	; Br if err when getting counts
	CMPW	IRP$W_XE_USERSIZ(R3),R0	; Is user buffer larger than P2?
	BGEQU	120$			; Br if yes - okay
	MOVW	IRP$W_XE_USERSIZ(R3),R0	; Else, set user return size
	MOVW	#SS$_BUFFEROVF,IRP$W_XE_STATUS(R3) ; Set error return
120$:	MOVW	R0,IRP$W_BCNT(R3)	; Set user return size
	ASHL	#16,R0,R0		; Move count to high word
130$:	MOVW	IRP$W_XE_STATUS(R3),R0	; Set return status
	BSBW	IO_DONE			; Complete the I/O request
	BRW	10$			; Get next packet

FORK_RDMEM:				; Process READ DEUNA/DELUA MEMORY
	MOVZWL	IRP$W_BCNT(R3),R0	; Get size of P2 buffer
	CLRW	IRP$W_BCNT(R3)		; Assume error - no data return
	BLBC	IRP$W_XE_STATUS(R3),140$	; Br if err when getting counts
	MOVW	R0,IRP$W_BCNT(R3)	; Else, reset buffer size
140$:	ASHL	#16,R0,R0		; Get return buffer size
	MOVW	IRP$W_XE_STATUS(R3),R0	; Set return status
	BRB	145$			; Complete the request

FORK_LDMEM:				; Process LOAD DEUNA/DELUA MEMORY
	MOVZWL	IRP$W_XE_STATUS(R3),R0	; Get completion status
145$:	MOVL	UCB$L_CRB(R5),R2	; Get CRB address
	ASSUME	VEC$B_NUMREG EQ VEC$W_MAPREG+2
	ASSUME	VEC$B_DATAPATH EQ VEC$B_NUMREG+1
	MOVL	IRP$L_XE_MAP(R3),-	; Setup map register data
		CRB$L_INTD+VEC$W_MAPREG(R2) ;	...
	BSBW	IO_DONE			; Complete the request
	RELMPR				; Release map registers
	BRW	10$			; Look for more work

FORK_RDSID:				; Process READ SYSTEM ID PARAMETERS
	MOVZWL	IRP$W_BCNT(R3),R0	; Get size of P2 buffer
	CLRW	IRP$W_BCNT(R3)		; Assume error - no data return
	BLBC	IRP$W_XE_STATUS(R3),160$	; Br if err when getting parameters
	MOVW	#UDB_SID_C_LENGTH,-	; Assume user buffer is large enough
		IRP$W_BCNT(R3)		;
	CMPW	R0,#UDB_SID_C_LENGTH	; Is user buffer larger than UDB ?
	BGEQU	150$			; Br if yes - okay
	MOVW	R0,IRP$W_BCNT(R3)	; Else, set buffer size to user buffer
	MOVW	#SS$_BUFFEROVF,IRP$W_XE_STATUS(R3) ; Set error return
150$:	PUSHR	#^M<R3,R4,R5>		; Save registers
	ASSUME	P2B_L_POINTER EQ 0
	MOVL	@IRP$L_SVAPTE(R3),R2	; Point to start of data area
	MOVAB	CDB_G_SIDUDB(R4),R4	; Get address of SYSTEM ID PARAMETERS
	MOVZWL	IRP$W_BCNT(R3),R0	; Get size of transfer
	MOVC3	R0,(R4),(R2)		; Move data to system buffer
	POPR	#^M<R3,R4,R5>		; Restore registers
160$:	ASHL	#16,IRP$W_BCNT(R3),R0	; Get return buffer size
	MOVW	IRP$W_XE_STATUS(R3),R0	; Set return status
	BSBW	IO_DONE			; Complete the request
	BRW	10$			; Look for more

FORK_READST:				; Process READ PORT STATUS
	CLRW	IRP$W_BCNT(R3)		; Assume error - no data return
	BLBC	IRP$W_XE_STATUS(R3),180$	; Br if err when getting status
	MOVW	#8,IRP$W_BCNT(R3)	; Assume user buffer is large enough
	ASSUME	P2B_L_POINTER EQ 0
	MOVL	@IRP$L_SVAPTE(R3),R2	; Point to start of data area
	MOVQ	IRP$Q_XE_PCB(R3),(R2)	; Copy return data
180$:	ASHL	#16,IRP$W_BCNT(R3),R0	; Get return buffer size
	MOVW	IRP$W_XE_STATUS(R3),R0	; Set return status
	BSBW	IO_DONE			; Complete the request
	BRW	10$			; Look for more
	.DSABL	LSB

	.SBTTL	SCAN_LISTS - Scan transmit and receive ring entries
;++
; SCAN_LISTS - Scan transmit and recieve ring entries for completed requests
;
; Functional description:
;
; This routine is called to search the ring entries for completed operations.
;
; Inputs:
;
;	R4 = CDB address
;
;	IPL = FIPL
;
; Outputs:
;
;	R0-R3,R5 are destroyed.
;	All other registers are preserved.
;
;--

SCAN_LISTS::				; Scan XMIT/RECV rings
	PUSHL	R6			; Save R6
10$:	TSTB	CDB_B_RCVCNT(R4)	; Any receives in progress?
	BNEQ	20$			; Br if yes - process any receives
15$:	BRW	60$			; Else, skip to the xmit list

20$:	JSB	@CDB_L_ASSPKT(R4)	; Assemble receive packets
	BLBC	R0,15$			; Br on error or none
	BBS	#RCV_FLG_V_ERRS,-	; Br if FATAL receive error
		 CXB$B_R_FLAGS(R2),25$	;   DEUNA/DELUA should count this error
	MOVZWL	CXB$W_R_PTYPE(R2),R1	; Pick up protocol type from buffer
	
	.IF DF	POINT
	CMPW	R1,#XE_C_STPRO		;% Is this the startup protocol?
	BNEQ	21$			;% Br if not
	BSBW	FIND_POINT_UCB		;% Find the point to point user!
	BLBC	R0,22$			;% Br if failure, assume regular user
	BRB	25$			;% Else done with MSG block
	.ENDC

21$:	CMPW	R1,#NI_CTR_PROTYP	; Is this the Remote Console protocol?
	BNEQ	22$			; Br if not
	CMPB	#NI_CTR_READ,-		; Is this a read counters request?
		CXB$T_R_USERDAT(R2)	;
	BNEQ	22$			; Br if not
	BSBW	MOP_CTR_REQUEST		; Else, process the request for counters
	BRB	10$
22$:	BSBW	MATCH_PROTYP		; Try to match protocol type
	BLBS	R0,27$			; Br if success
23$:	MOVL	CDB_L_PRMUSER(R4),R5	; Try to get the PROMISCUOUS user
	BNEQ	34$			; Br if one found
	INCC	CDB_W_UFDCTR(R4),W	; Else, no such protocol type
25$:	PUSHL	CXB$L_LINK(R2)		; Save next in chain
	BSBW	ADDRCVLIST		; Add buffer to receive list
	POPL	R2			; Restore next buffer
	BNEQ	25$			; Loop if more
	BRB	10$			; Look for next completed buffer
;
; If there is a promiscuous user, then copy the packet for the promiscuous
; user. There is a chance that the data received is not for the protocol
; type user just found, we will have to re-verify that the destination
; address is for our physical address. This is because if we are running
; promiscuous mode, then we will receive all packets, including those not
; intended for the protocol user.
;
27$:	ASSUME	NMA$C_STATE_ON EQ 0
	ASSUME	NMA$C_STATE_OFF EQ 1
	BLBS	CDB_B_PRM(R4),32$	; Br if hardware is NOT in promiscuous mode
	BLBS	CXB$G_R_DEST(R2),30$	; Br if multicast address, this
					;  will be checked later.
	CMPL	CXB$G_R_DEST(R2),-	; Is this packet for this protocol
		CDB_G_PHYADR(R4)	;  user?
	BNEQ	23$			; Br if not, don't copy packet
	CMPW	CXB$G_R_DEST+4(R2),-	; Are we sure?
		CDB_G_PHYADR+4(R4)	;
	BNEQ	23$			; Br if no, dont't copy packet
;
;	Copy the packet for the promiscuous user
;
30$:	PUSHL	R5			; Save user's UCB address
	MOVL	CDB_L_PRMUSER(R4),R5	; Get PROMISCUOUS user's UCB address
	BEQL	31$			; Br if none
	BSBW	COPY_RCV		; Give buffer to promiscous user
31$:	POPL	R5			; Restore user's UCB address
;
; If multicast address is the destination, then make sure that multicast
; address is in multicast address list for this unit.
;
32$:	BLBC	CXB$G_R_DEST(R2),34$	; Br if physical address
	BSBW	MATCH_MULTI		; Try to match multicast address
	BLBS	R0,34$			; Br if success
33$:	INCC	UCB$W_XE_MNECTR(R5),W	; Else, multicast not enabled
	INCC	CDB_W_UFDCTR(R4),W	; Also added in unrecognized frame dest
	BRB	25$			; Release buffer
;
; If the user did not request data chaining, then check to make sure he gets
; no chained buffers... may be user of Internal IRPs!
;
34$:	TSTL	CXB$L_LINK(R2)		; Is this a chained message?
	BEQL	36$			; Br if not
	ASSUME	NMA$C_STATE_ON EQ 0
	ASSUME	NMA$C_STATE_OFF EQ 1
	BLBS	UCB$B_XE_DCH(R5),45$	; Br if chaining not allowed
;
; If there is a pending receive I/O request, complete it.
; Otherwise, queue the buffer and, if enabled, deliver attention AST.
;
36$:	MOVZWL	UCB$W_DEVBUFSIZ(R5),R0	; Get size of user's max buffer
	;&&
	;&& the following code could cause problems for an altstart user,
	;&& if the altstart user happens to receive a buffer which is 1 or 2
	;&& bytes longer than they are capable of handling. Only if the
	;&& protocol is not "padded", because the size check allows for
	;&& 2 bytes of count to be subtracted from the message size.
	;&&
;
; Check the size of the received buffer against what the user protocol can
; handle.
;
	SUBW3	#XE_C_HEADER+-		; Get the size of the
		XE_C_CRC+XE_C_CNTSIZ,-	;  receive buffer
		CXB$W_BCNT(R2),R1	;  minus the header and trailer
	CMPW	R1,R0			; Is the received size larger than
					;  what the user can handle?
	BGTRU	45$			; Br if yes, error
	TSTL	UCB$L_XE_FFI(R5)	; FAST Interface supported?
	BEQL	37$			; Br if not, standard interface
	BSBW	FINISH_RCV_FFI		; Else, complete FAST receive
	BRW	10$			; Look for more completions

37$:	MOVAB	UCB$Q_XE_RCVREQ(R5),R1	; Assume that we are running in
					;  exclusive mode
	BBC	#UCB$V_XE_SHARE,-	; Br if UCB is NOT in SHARED mode
		 UCB$W_DEVSTS(R5),38$	;
;
; If running in SHARED mode, then we must use the listheads in the SHR
; data structure. We will use the source address from the received message
; to match against the SHR structure destination address.
;
	BSBW	MATCH_SRC		; Check for a match on source address
	BNEQ	33$			; Br if no shared user found
;
;	SHARED user found, use listheads in SHR data structure.
;
	MOVAB	SHR_Q_RCVREQ(R1),R1	; Get address of waiting IRPs
38$:	REMQUE	@(R1),R3		; Remove waiting IRP
	BVS	40$			; Br if none - queue for later
	SUBW	R0,UCB$W_XE_QUOTA(R5)	; Else, lessen quota so it can be
					;..increased on completion
	BSBW	FINISH_RCV_IO		; And finish the I/O
	BRW	10$			; Look for next completion
;
; Check buffer quota and queue if quota okay.
;
40$:	SUBW	R0,UCB$W_XE_QUOTA(R5)	; Decrement the quota
	BGEQU	50$			; Br if we can buffer request
	ADDW	R0,UCB$W_XE_QUOTA(R5)	; Replace quota
45$:	INCC	UCB$W_XE_UBUCTR(R5),W	; Else, no buffer available
	INCC	CDB_W_UBUCTR(R4),W	; ...don't forget CDB counter
	BRW	25$			; Return buffer

50$:	ASSUME	UCB$Q_XE_RCVREQ EQ UCB$Q_XE_RCVMSG+8
	ASSUME	SHR_Q_RCVREQ EQ SHR_Q_RCVMSG+8
	SUBL	#4,R1			; Backup to backward link pointer
					;  of the message queue
	INSQUE	(R2),@(R1)		; Queue received msg for later
	BSBW	FILLRCVLIST		; Try to fill the receive list
	BSBW	POKE_USER		; Deliver ASTs
	BRW	10$			; Look for more completions
;
; NOW - scan the xmit ring entries
;
60$:	TSTB	CDB_B_XMTCNT(R4)	; Any xmits in progress?
	BNEQ	75$			; Br if yes - look for any completed
70$:	BRW	190$			; Else, all done

75$:	MOVZBL	CDB_B_LASTXMT(R4),R6	; Get last ring entry completed
	MOVL	CDB_L_XRADDR(R4)[R6],R6	; Retrieve last ring entry address
	BBS	#XMT_FLG_V_OWN,-	; Br if not done
		 XMT_B_FLAGS(R6),70$	;
	REMQUE	@CDB_Q_XMTPND(R4),R3	; Get next XMIT CXB
	BVS	70$			; Br if none there (yet)
	BNEQ	80$			; Br if more entries on queue
	CLRB	CDB_B_TIM_XMT(R4)	; Stop the xmit timer
80$:	DECB	CDB_B_XMTCNT(R4)	; One less transmit pending
	INCB	CDB_B_LASTXMT(R4)	; Bump ring pointer
	BICB	#^C<MAX_C_XMT-1>,-	; Modulo receive ring entry size
		CDB_B_LASTXMT(R4)	;	...

	CMPW	XMT_W_RID(R6),CXB$W_XE_RID(R3) ; Is this a match???
	BEQL	90$			; Br if yes, good
	BUG_CHECK NOBUFPCKT,FATAL	; Else, fatal error
;
; Transmit complete
;
90$:	MOVB	XMT_B_FLAGS(R6),-	; Save diagnostic return info
		 CDB_B_DIAG1(R4)	;
	MOVW	XMT_W_TDRERR(R6),-	; Save diagnostic return info
		 CDB_W_DIAG2(R4)	;
	MOVZWL	CXB$W_BOFF(R3),R5	; Get offset to start of data
	ADDL	R3,R5			; Point to header
	MOVL	XBUF_L_UCB(R5),R5	; Get UCB address
	MOVZBL	CXB$B_XE_SLOT(R3),R2	; Get mapping slot number used
	CLRBIT	R2,CDB_B_XMTMAP(R4)	; Clear in use flag
	MOVL	UCB$L_CRB(R5),R1	; Get CRB address
	ASSUME	VEC$B_NUMREG EQ VEC$W_MAPREG+2
	ASSUME	VEC$B_DATAPATH EQ VEC$B_NUMREG+1
	MOVL	CDB_L_XMTMAP(R4)[R2],-	; Setup map register data
		 CRB$L_INTD+VEC$W_MAPREG(R1) ;	and data path number
	TSTB	CRB$L_INTD+VEC$B_DATAPATH(R1) ; Is the data path the DDP?
	BEQL	93$			; Br if yes - don't do purge or release
	PUSHQ	R2			; Save R2, R3
	PURDPR				; Purge the data path (ignore errors)
	RELDPR				; Release the data path
	POPQ	R2			; Restore R2, R3
93$:	TSTB	R2			; Was it the pre-allocated one?
	BEQL	95$			; Br if yes - clear data path number
	MNEGL	#1,CDB_L_XMTMAP(R4)[R2]	; Indicate map register not allocated
	RELMPR				; Release the map registers
	BRB	100$			; Complete the request

95$:	ASSUME	VEC$B_DATAPATH EQ VEC$W_MAPREG+3
	CLRB	CDB_L_XMTMAP+3(R4)	; Clear data path number used
100$:	MOVZWL	CXB$W_BCNT(R3),R0	; Get byte count of message
	MOVL	R0,R1			; Copy converted length for accounting
	ASHL	#16,R0,R0		; Move to high word
	MOVW	S^#SS$_NORMAL,R0	; Set completion status
	BBC	#XMT_FLG_V_ERRS,XMT_B_FLAGS(R6),110$ ; Br if not a FATAL error
	MOVW	#SS$_DEVREQERR,R0	; Else, assume 16 retries failed
	BBS	#XMT_TERR_V_RTRY,XMT_W_TDRERR(R6),120$ ; Br if true
	MOVW	#SS$_DISCONNECT,R0	; Else, assume Loss of Carrier
	BBS	#XMT_TERR_V_LCAR,XMT_W_TDRERR(R6),120$ ; Br if true
	MOVW	#SS$_DATACHECK,R0	; Else, assume Late collision
	BBS	#XMT_TERR_V_LCOL,XMT_W_TDRERR(R6),120$ ; Br if true
	MOVW	#SS$_COMMHARD,R0	; Else, assume UNIBUS timeout
	BBS	#XMT_TERR_V_UBTO,XMT_W_TDRERR(R6),120$ ; Br if true
	MOVW	#SS$_CTRLERR,R0		; Else assume Data Underflow
	BBS	#XMT_TERR_V_UFLO,XMT_W_TDRERR(R6),120$ ; Br if true
	MOVW	#SS$_TOOMUCHDATA,R0	; Else, must be Buffer Length violation
	BRB	120$			; Skip the accounting
;
; Perform accounting on a per protocol type basis.
;
110$:	CNTR	R1,UCB$L_XE_SBYCTR(R5),L ; Bump the bytes sent counter
	INCC	UCB$L_XE_SBLCTR(R5),L	; Bump the blocks sent counter
120$:	TSTL	CXB$L_T_IRP(R3)		; FAST interface CXB?
	BEQL	130$			; Br if yes
	MOVL	CXB$L_T_IRP(R3),R3	; Else, get IRP address
	BSBW	IO_DONE			; Finish the I/O request
	BRB	170$			; Continue in common code
130$:	BSBW	FINISH_XMT_FFI		; Else, complete FFI XMIT
170$:	BSBW	XMT_ALT_START		; Start up any other transmits
	BRW	60$			; Look for next completion
	
190$:	POPL	R6			; Restore R6
	RSB


	.SBTTL	 SUBROUTINES TO FIND SHR MATCH ON SOURCE ADDRESS
;++
; Functional description:
;
; Subroutine to find SHR data structure for user
;
; Inputs:
;	R2 = Receive CXB address
;	R5 = UCB address
;
; Outputs:
;	R1 = Address if SHR data structure if match
;	All other registers preserved.
;	Z-Bit set then match.
;	Z-Bit clear then no match.
;--

MATCH_SRC:				; Try to find shared user
	PUSHR	#^M<R0,R2>		; Save registers
;
; Try to find match among limited shared users of protocol type
;
	MOVAB	UCB$Q_XE_SHARE(R5),R0	; Save address of listhead
	MOVL	R0,R1			; Copy listhead address
	ASSUME	SHR_L_QFL EQ 0
20$:	MOVL	(R1),R1			; Get next in list
	CMPL	R1,R0			; Back to start of list?
	BEQL	30$			; Br if yes - no source match
	BSBB	CHECK_SRC		; Check for match
	BNEQ	20$			; Br if none
	BRB	50$			; Return in success (Z-bit is set)
;
; No match on limited users - try to use default user
;
30$:	MOVL	UCB$L_XE_DEFUSR(R5),R1	; Get address of default user
	BEQL	40$			; Br if no default user
	CLRL	R0			; Return success
40$:	MOVL	R0,R0			; Return success/failure indicator
50$:	POPR	#^M<R0,R2>		; Restore registers, don't reset Z-BIT
	RSB

;++
; Functional description:
;
; Subroutine to check if source address in message matches SHR address
;
; Inputs:
;	R1 = Address of SHR
;	R2 = Address of MSG buffer
;
; Outputs:
;	Z-Bit set then match.
;	Z-Bit clear then no match.
;--

CHECK_SRC:				; Check for match with SHR data base
	CMPL	CXB$G_R_SRC(R2),SHR_G_DEST(R1) ; Source address match?
	BNEQ	10$			; Br if no - try for next
	CMPW	CXB$G_R_SRC+4(R2),-	; Really match?
		 SHR_G_DEST+4(R1)	;	...
10$:	RSB				; Return to caller

	.SBTTL	COPY_RCV - Copy a receive buffer for the PROMISCUOUS user
;++
; COPY_RCV - Copy a receive buffer for the PROMISCUOUS user
;
; Functional description:
;
; This routine allocates a receive buffer in which to copy the a receive
; buffer for the PROMISCUOUS user.
;
;  Inputs:
;
;	R2 = Receive CXB address
;	R4 = CDB address
;	R5 = UCB address of PROMISCUOUS user
;	R6 = Address of receive ring entry
;
;	IPL = FIPL
;
;  Outputs:
;
;	R0,R1,R3 are destroyed.
;	All other registers are preserved.
;--
COPY_RCV:				; Copy the xmit buffer to rcv buffer
	PUSHL	R2			; Save address of original buffer
	CMPW	#1,CXB$W_R_NCHAIN(R2)	; Is there more than 1 in chain?
	BNEQ	80$			; Br if yes - we can only handle 1
	MOVZWL	CXB$W_BCNT(R2),R1	; Get size of buffer
	ADDL	#CXB$C_HEADER,R1	; Compute size of needed buffer
	JSB	G^EXE$ALONONPAGED	; Allocate a receive buffer
	BLBC	R0,80$			; Br if failure
	MOVL	(SP),R3			; Get address of original buffer
	PUSHR	#^M<R1,R2,R4,R5>	; Save registers
	MOVC3	R1,(R3),(R2)		; Copy everything to new buffer
	POPR	#^M<R1,R2,R4,R5>	; Save registers
	MOVW	R1,CXB$W_SIZE(R2)	; Reset size field
;
; If there is a pending receive I/O request, complete it.
; Otherwise, queue the buffer and, if enabled, deliver attention AST.
;
	MOVZWL	UCB$W_DEVBUFSIZ(R5),R1	; Get the user's buffer size
	REMQUE	@UCB$Q_XE_RCVREQ(R5),R3	; Remove waiting IRP
	BVS	30$			; Br if none - queue for later
	SUBW	R1,UCB$W_XE_QUOTA(R5)	; Else, lessen quota so it can be
					;..increased on completion
	BSBW	FINISH_RCV_IO		; And finish the I/O
	BRB	80$			; Look for next completion

;
; Check buffer quota and queue if quota okay; otherwise, delete the buffer.
;

30$:	SUBW	R1,UCB$W_XE_QUOTA(R5)	; Decrement the quota
	BGEQU	50$			; Br if we can buffer request
	ADDW	R1,UCB$W_XE_QUOTA(R5)	; Replace quota
	INCC	UCB$W_XE_UBUCTR(R5),W	; Else, no buffer available
	INCC	CDB_W_UBUCTR(R4),W	; ...don't forget CDB counter
	MOVL	R2,R0			; Copy the buffer address
	JSB	G^COM$DRVDEALMEM	; DEALLOCATE the buffer
	BRB	80$			; Done

50$:	INSQUE	(R2),@UCB$Q_XE_RCVMSG+4(R5) ; Queue received msg for later
	BSBW	FILLRCVLIST		; Try to fill the receive list
	BSBW	POKE_USER		; Deliver ASTs
80$:	POPL	R2			; Restore R2
	RSB				; Return to caller

	.SBTTL	FINISH_XMT_FFI - Finish FAST interface transmit processing
;++
; FINISH_XMT_FFI - Finish FAST interface transmit processing
;
; Functional description:
;
; This routine completes a transmit CXB for a particular user of the fast
; interface.
;
;  Inputs:
;
;	R0 = Status of transmit request
;	R3 = transmit CXB address
;	R4 = CDB address
;	R5 = UCB address
;
;	IPL = FIPL
;
;  Outputs:
;
;	R0-R3 are destroyed.
;	All other registers are preserved.
;
;--
	ASSUME	IPL$_SYNCH EQ IPL$_XE_FIPL
FINISH_XMT_FFI::			; Finish FAST interface transmit request
	PUSHL	R4			; Save R4
	MOVL	UCB$L_XE_FFI(R5),R4	; Get FFI block address
	JSB	@FFI$L_XMIT_DONE(R4)	; Call back the user with CXB
	POPL	R4			; Restore R4
	RSB

	.SBTTL	FINISH_RCV_FFI - Finish FAST receive processing
;++
; FINISH_RCV_FFI - Finish FAST receive processing
;
; Functional description:
;
; This routine completes a receive CXB for a particular user of the fast
; interface.
;
;  Inputs:
;
;	R2 = receive CXB address
;	R4 = CDB address
;	R5 = UCB address
;
;	IPL = FIPL
;
;  Outputs:
;
;	R0-R3 are destroyed.
;	All other registers are preserved.
;
;--
	ASSUME	IPL$_SYNCH EQ IPL$_XE_FIPL
FINISH_RCV_FFI::			; Finish FAST recieve request
	PUSHL	R4			; Save CDB
	MOVL	R2,R3			; Copy CXB address
	MOVQ	CXB$G_R_SRC(R3),-	; Copy source address
		CXB$Q_STATION(R3)	;	...
	MOVW	#CXB$T_R_USERDAT,CXB$W_BOFF(R3) ; Set offset to received data
	ASSUME	NMA$C_STATE_ON EQ 0
	ASSUME	NMA$C_STATE_OFF EQ 1
	BLBS	UCB$B_XE_PAD(R5),30$	; Br if padding is disabled
	MOVW	CXB$W_R_SIZE(R3),-	; Else, set real size of buffer
		CXB$W_BCNT(R3)
	ADDW	#XE_C_CNTSIZ,CXB$W_BOFF(R3) ; Adjust offset
30$:	MOVL	CDB_L_DEVDEPEND(R4),R0	; Set controller bits
	BISL	UCB$L_DEVDEPEND(R5),R0	; Set status flags
	MOVL	UCB$L_XE_FFI(R5),R4	; Get FFI block address
	JSB	@FFI$L_RECV_DONE(R4)	; Call back the user with CXB
	POPL	R4			; Restore CDB
	MOVL	R3,R2			; Was buffer consumed?
	BEQL	90$			; Br if YES
	BSBW	ADDRCVLIST		; Else, add buffer to receive list
90$:	RSB

	.SBTTL	FINISH_RCV_IO - Finish receive I/O processing
;++
; FINISH_RCV_IO - Finish receive I/O processing
;
; Functional description:
;
; This routine completes a receive operation that has been matched with a
; message block. After the receive has been completed the message free list
; is filled and a receive is started if needed.
;
;  Inputs:
;
;	R2 = receive CXB address
;	R3 = I/O packet address
;	R4 = CDB address
;	R5 = UCB address
;
;	IPL = FIPL
;
;  Outputs:
;
;	R5 is reset to UCB address from IRP
;
;	The request is completed via I/O post.
;--

FINISH_RCV_IO::				; Finish recieve I/O request
	MOVL	R2,IRP$L_SVAPTE(R3)	; Save block address
	MOVQ	CXB$G_R_SRC(R2),-	; Copy source address for DECnet
		IRP$Q_STATION(R3)	;	...
	BBC	#IRP$V_DIAGBUF,-	; Br if no diagnotic buffer
		IRP$W_STS(R3),10$	;
	MOVL	IRP$L_DIAGBUF(R3),R1	; Get diagnostic buffer
	MOVAB	RHDR_T_DATA(R1),R0	; Assume this is just a read header
	CMPW	#RHDR_C_LENGTH,DIAG_W_SIZE(R1) ; Is this just a header buffer?
	BEQL	5$			; Br if yes
	MOVAB	DIAG_T_RDATA(R1),R0	; Else, must be a diagnostic buffer
	MOVB	CXB$B_R_FLAGS(R2),-	; Save diagnostic return info
		 CDB_B_DIAG1(R4)	;	...
	MOVW	CXB$W_R_LENERR(R2),-	;	...
		 CDB_W_DIAG2(R4)	;	...
5$:	PUSHR	#^M<R2,R3,R4,R5>	; Save registers
	MOVC3	#RHDR_C_DATA,CXB$T_R_DATA(R2),(R0) ; Move header info
	POPR	#^M<R2,R3,R4,R5>	; Restore registers
10$:	MOVAB	CXB$T_R_USERDAT(R2),(R2); Set address of received data
	MOVL	IRP$L_XE_DATBUF(R3),4(R2); Set address of user buffer
	ADDW	UCB$W_DEVBUFSIZ(R5),-	; Adjust receive buffer quota
		UCB$W_XE_QUOTA(R5)	;
	MOVZWL	CXB$W_BCNT(R2),R1	; Find length of received message
					;  includes the CRC size
;
; Perform accounting on a per protocol type basis.
;
	CNTR	R1,UCB$L_XE_RBYCTR(R5),L ; Bump the bytes received counter
	INCC	UCB$L_XE_RBLCTR(R5),L	; Bump the blocks received counter
	SUBL	#XE_C_HEADER,R1		; Remove DEUNA/DELUA header from size
;
; If padding is enabled, then the size of the data is contained in the
; message as the first word of data.
;
	ASSUME	NMA$C_STATE_ON EQ 0
	ASSUME	NMA$C_STATE_OFF EQ 1
	BLBS	UCB$B_XE_PAD(R5),15$	; Br if padding is disabled
	ADDW3	#XE_C_CRC,CXB$W_R_SIZE(R2),R0 ; Else, pick up real size of
					;  MSG from the message itself + CRC
	ADDL	#XE_C_CNTSIZ,(R2)	; Move pointer past the count field
;
; Verify that the 1st word of data at least makes some sense. The byte
; count for the message must be less than the size of the entire received
; message.
;
	CMPW	R0,R1			; Is size field larger than buffer?
	BGEQU	45$			; Br if yes -
					;  must be strictly Less Than, because
					;  the size field is 2 extra bytes.
	MOVZWL	R0,R1			; Else, copy the real buffer size
;
; We will attempt to return the CRC as part of the user data, but not
; tell the user that the CRC was returned (i.e. we do not set IOST1 size
; to include the CRC). If the CRC cannot be returned, then we only return
; the data portion of the buffer.
;
; This is done, so that users suspecting that data is being "picked" between
; the UBA and host system memory can check the CRC for themselves.
;
15$:	MOVZBW	S^#SS$_NORMAL,IRP$W_XE_STATUS(R3) ; Assume success
	MOVZBL	#XE_C_CRC,R0		; Get size of CRC
	CMPW	R1,IRP$W_BCNT(R3)	; Request larger than user buffer size?
	BLEQU	20$			; Br if no - okay
	SUBL	R0,R1			; Try it without the CRC being returned
	BLEQU	45$			; Br if DEUNA/DELUA hardware error
	CLRL	R0			; Remember that CRC is not returned
	CMPW	R1,IRP$W_BCNT(R3)	; Request larger than user buffer size?
	BLEQU	20$			; Br if no - okay (without CRC)
	MOVZWL	IRP$W_BCNT(R3),R1	; Else, set size to minimum of two
	MOVW	#SS$_DATAOVERUN,IRP$W_XE_STATUS(R3) ; Set return status
;
; If chained buffers, then setup IRP$W_STS and don't reset the USER BUFFER
; SIZE (IRP$W_BCNT), because chained buffers need to have the USER BUFFER
; SIZE in IRP$W_BCNT.
;
20$:	TSTL	CXB$L_LINK(R2)		; Is this a complex chained buffer?
	BEQL	30$			; Br if no - set transfer size
	BBC	#IRP$V_CHAINED,-	; Br if user cannot accept complex
		 IRP$W_STS(R3),45$	;  chained buffers
	BISW	#IRP$M_COMPLX,- 	; Else indicate complex
		 IRP$W_STS(R3)		;    chained buffers
	BRB	40$			; And don't change user buffer size
30$:	MOVW	R1,IRP$W_BCNT(R3)	; Set size to transfer
40$:	SUBL	R0,R1			; Return receive count without CRC 
	ASHL	#16,R1,R0		; Set buffer size in status
	BNEQ	50$			; Br if success
45$:	MOVW	#SS$_CTRLERR,-		; Set data transfer error
		IRP$W_XE_STATUS(R3)	;
 
50$:	MOVW	IRP$W_XE_STATUS(R3),R0	; Get status
60$:	BSBB	IO_DONE			; Post the I/O request
	BRW	FILLRCVLIST		; Fill up the receive buffers
;
; Complete an I/O request packet
;
ABORT_PKT:				; Abort the I/O request
	MOVZBL	S^#SS$_ABORT,R0		; Return aborted status
IO_DONE3:				; Complete the I/O request, check for
					;    timeout
	MOVL	IRP$L_UCB(R3),R5	; Get UCB address
	MOVL	UCB$L_XE_CDB(R5),R1	; Get CDB address
	BBC	#XM$V_STS_TIMO,CDB_L_DEVDEPEND(R1),IO_DONE ; Br if not a timeout
	MOVZWL	#SS$_TIMEOUT,R0		; Else, return real error code
IO_DONE:				; Complete an I/O request
	MOVL	R0,IRP$L_IOST1(R3)	; Set status return and size
IO_DONE1:				; Alternate entry point
	MOVL	IRP$L_UCB(R3),R5	; Get UCB address
	MOVL	UCB$L_DEVDEPEND(R5),IRP$L_IOST2(R3) ; Set other info
	MOVL	UCB$L_XE_CDB(R5),R1	; Get CDB address
	BEQL	IO_DONE2		; Br if no CDB
	BISL	CDB_L_DEVDEPEND(R1),IRP$L_IOST2(R3) ; Set controller bits
IO_DONE2:				; P1 IOST2 already setup
	PUSHL	R4			; Save R4
	MOVL	UCB$L_XE_CDB(R5),R4	; Get CDB address
	BBC	#IRP$V_DIAGBUF,-	; Br if no diagnotic buffer
		IRP$W_STS(R3),20$	;
	MOVL	IRP$L_DIAGBUF(R3),R0	; Get diagnostic buffer address
	CMPW	#RHDR_C_LENGTH,DIAG_W_SIZE(R0) ; Is this a real diag buffer?
	BEQL	20$			; Br if not - no diagnostic info
	ADDL3	#8,(R0),R0		; Address buffer past start time
	MOVQ	G^EXE$GQ_SYSTIME,(R0)+	; Insert stop time
	MOVL	CDB_L_UCB0(R4),R1	; Get address of UCB #0
	MOVZWL	UCB$W_ERRCNT(R1),(R0)+	; Insert error counter
	BSBW	REG_DUMP		; Dump registers
20$:	POPL	R4			; Restore R4
	JMP	G^COM$POST		; Post the I/O and return

	.SBTTL	ASSPKT_NODCH - Assemble receive packets without Data Chaining 
;++
; ASSPKT_NODCH - Assemble receive packets with Data Chaining Disabled
;
; Functional description:
;
; This routine finds and returns the first recieve packet that the controller
; has completed. This routine is invoked to assemble recieve packets if and 
; only if data chaining has been disabled.
;
;  Inputs:
;
;	R4 = CDB address
;
;	IPL = FIPL
;
;  Outputs:
;
;	R0 = Status for request
;	R2 = Address of receive buffer
;	R6 = Address of corresponding receive ring descriptor entry
;	R1,R3 are destroyed.
;	All other registers are preserved.
;
;--

ASSPKT_NODCH::				; Assemble receive packet
	BSBW	NEXTMSG			; Get message
	BLBS	R0,5$			; Branch if one
	RSB				; Else return in error
;
; Set CXB$W_R_NCHAIN, the number of messages in the chain, to 1 and
; place the size of the recieved message in CXB$W_BCNT.
;

5$:	MOVW	S^#1,CXB$W_R_NCHAIN(R2)	; There is only one buffer
	MOVW	CXB$W_LENGTH(R2),-	; Set the message size
		CXB$W_BCNT(R2)

;
; If the current message is both the beginning and end of a packet, then this
; message will be returned (if there was no error in its reception). Otherwise,
; return the buffer to the free list, and attempt to get the next message.
;

	ASSUME	RCV_FLG_V_ENP EQ 0
	ASSUME	RCV_FLG_V_STP EQ RCV_FLG_V_ENP+1
	CMPZV	#RCV_FLG_V_ENP,#2,-	; Is this message both the beginning
		CXB$B_R_FLAGS(R2),#3	; and the end of a packet?
	BEQLU	CRC			; Branch if so
	INCC	CDB_W_UFDCTR(R4),W	; Else increment counter
	BSBW	ADDRCVLIST		; Add the buffer to the recieve list
	BRB	ASSPKT_NODCH		; Continue to try and get the next msg

	.SBTTL	ASSPKT_DCH - Assemble receive packets with Data Chaining Enabled
;++
; ASSPKT_DCH - Assemble receive packets with Data Chaining Enabled
;
; Functional description:
;
; This routine assembles all receive packets into one chain of complex
; buffers. This routine is invoked to assemble recieve packets if and only if
; data chaining has been enabled.
;
;  Inputs:
;
;	R4 = CDB address
;
;	IPL = FIPL
;
;  Outputs:
;
;	R0 = Status for request
;	R2 = Address of first receive buffer in chain
;	R6 = Address of last buffer in receive ring
;	R1,R3 are destroyed.
;	All other registers are preserved.
;
;  Implicit Outputs:
;
;	IRP$V_CHAIN and IRP$V_COMPLX bits set in IRP$W_STS if the receive
;	buffer is comprised of complex chained buffers.
;--
	.ENABL	LSB
ASSPKT_DCH::				; Assemble receive packets
	BSBW	NEXTMSG			; Get first message
	BLBS	R0,5$			; Br if one
	RSB				; Return in error
;
; Save number of messages  in chain in CXB$W_R_NCHAIN and total size of
; all messages in CXB$W_BCNT
;
5$:	MOVW	S^#1,CXB$W_R_NCHAIN(R2)	; Compute total number of buffers
	CLRW	CXB$W_BCNT(R2)		; Init total size of buffers so far
;
; Toss message if not first in chain.
;
	BBS	#RCV_FLG_V_STP,-	; Br if beginning of packet
		 CXB$B_R_FLAGS(R2),7$	;
	BRW	TOSSMSG			; Else, toss the packet

7$:	BBS	#RCV_FLG_V_ENP,-	; Br if end of packet
		 CXB$B_R_FLAGS(R2),20$	; ..all done with this loop
	PUSHL	R2			; Save first receive buffer address
	MOVZBL	#MAX_C_CHAIN,R3		; Allow n messages in chain
10$:	MOVW	RCV_W_SLEN(R6),-	; Set size of buffer to maximum per rcv
		 CXB$W_LENGTH(R2)	;
	PUSHL	R2			; Save address of current bufr in chain
	BSBW	NEXTMSG			; Try for next message
	POPL	R1			; Get address of last buffer in chain
	BLBC	R0,12$			; Toss all messages on error
	MOVL	(SP),R0			; Get address of first in chain
	MOVL	R2,CXB$L_LINK(R1)	; Store address in chain
	ADDW	CXB$W_LENGTH(R1),-	; Compute total size of all buffers
		 CXB$W_BCNT(R0)		;  in chain - so far
	INCW	CXB$W_R_NCHAIN(R0)	; Compute number of msgs in chain
	BBS	#RCV_FLG_V_ENP,-	; Br if end of packet
		 CXB$B_R_FLAGS(R2),15$	;
	SOBGTR	R3,10$			; Loop if more than two in chain
;
; Done with loop and ENP bit still not set - toss all messages
;
12$:	BRB	TOSAMSG			; Toss all messages

15$:	MOVL	R2,R1			; Save address of last message
	POPL	R2			; Return first message address in R2
	MOVB	CXB$B_R_FLAGS(R1),-	; Save only last message buffer info
		 CXB$B_R_FLAGS(R2)	;  in first message of chain
	MOVW	CXB$W_R_LENERR(R1),-	; DITTO
		 CXB$W_R_LENERR(R2)	;
	SUBW	CXB$W_BCNT(R2),-	; Compute size of last message
		 CXB$W_LENGTH(R1)	;  and store in CXB format
20$:	BICW3	#^C<RCV_LERR_M_MLEN>,-	; Return size of complete message
		 CXB$W_R_LENERR(R2),-	;
		 CXB$W_BCNT(R2)		;
;
; We will only check CRCs on messages looped back to ourselves.
;
CRC::	BBC	#RCV_FLG_V_CRC,-	; Br if not a CRC error 
		CXB$B_R_FLAGS(R2),50$	;	...
	CMPL	CXB$G_R_SRC(R2),-	; Is this a "looped" message?
		CDB_G_PHYADR(R4)	;
	BNEQ	50$			; Br if not - drop it
	CMPW	CXB$G_R_SRC+4(R2),-	; Is it really "looped"?
		CDB_G_PHYADR+4(R4)	;
	BNEQ	50$			; Br if not - drop it
;
; There is not need to check the source address of the message, since
; while we are in loopback mode, we cannot receive messages from other
; sources.
;
; Calculate CRC on message
;
	MNEGL	#1,R0			; Initialize CRC value
	MOVL	R2,R3			; Copy address of first in chain
	BRB	35$			; Skip first chain
30$:	MOVL	CXB$L_LINK(R3),R3	; Get address of next in chain
35$:	MOVZWL	CXB$W_LENGTH(R3),R1	; Get size of data
	TSTL	CXB$L_LINK(R3)		; Is this the end of the data?
	BNEQ	40$			; Br if no
	SUBL	#XE_C_CRC,R1		; Subtract out the CRC
40$:	PUSHR	#^M<R1,R2,R3>		; Save registers
	CRC	CRCTABLE,R0,R1,CXB$T_R_DATA(R3) ; Calculate CRC on data
	POPR	#^M<R1,R2,R3>		; Restore registers
	TSTL	CXB$L_LINK(R3)		; Is there a next?
	BNEQ	30$			; Br if YES
	ADDL	R3,R1			; Point to end of buffer
	MCOML	R0,R0			; Complement the CRC
	CMPL	R0,CXB$T_R_DATA(R1)	; Is the CRC good?
	BNEQ	50$			; Br if not
	BICB	#RCV_FLG_M_ERRS!RCV_FLG_M_CRC,- ; Else, indicate good data
		CXB$B_R_FLAGS(R2)	;
50$:	MOVZBL	S^#SS$_NORMAL,R0	; Return success!
100$:	RSB
;
; Toss bad messages
;
TOSAMSG:POPL	R2			; Restore R2
TOSSMSG:INCC	CDB_W_UFDCTR(R4),W	; Up the counter
110$:	PUSHL	CXB$L_LINK(R2)		; Save address of next in chain
	BSBW	ADDRCVLIST		; Add buffer to receive list
	POPL	R2			; Restore address of next in chain
	BNEQ	110$			; Br if more in chain
120$:	CLRL	R0			; Assume failure
	BBC	#RCV_FLG_V_ENP,-	; Br if NOT end of chain
		 RCV_B_FLAGS(R6),130$	;  get rest of message
	BRW	ASSPKT_DCH		; Else, try for next valid message
130$:	BSBB	NEXTMSG			; Get next message
	BLBC	R0,100$			; Br if none
	BRB	120$			; Check if more possible
	.DSABL	LSB
;
; Find next message and check own bit
;
NEXTMSG::
	CLRL	R0			; Assume failure
	TSTB	CDB_B_RCVCNT(R4)	; Any more receives in progress?
	BEQL	20$			; Br if not
	MOVZBL	CDB_B_LASTRCV(R4),R6	; Get last ring entry completed
	MOVL	CDB_L_RRADDR(R4)[R6],R6	; Retrieve last ring entry address
	BBS	#RCV_FLG_V_OWN,RCV_B_FLAGS(R6),20$ ; Br if not done
	REMQUE	@CDB_Q_RCVPND(R4),R2	; Get next receive
	BVS	20$			; Br if none available (yet)
	CLRL	CXB$L_LINK(R2)		; Assume not a chained buffer
	DECB	CDB_B_RCVCNT(R4)	; One less receive pending
	INCB	CDB_B_LASTRCV(R4)	; Bump ring pointer
	BICB	#^C<MAX_C_RCV-1>,-	; Modulo receive ring entry size
		 CDB_B_LASTRCV(R4)	;	...

	CMPW	RCV_W_RID(R6),CXB$W_XE_RID(R2) ; Is this a match???
	BEQL	10$			; Br if yes, good
	BUG_CHECK NOBUFPCKT,FATAL	; Else, fatal error
;
; Adjust quota and release mapping slot
;
10$:	MOVW	RCV_W_LENERR(R6),-	; Save length and error bits
		 CXB$W_R_LENERR(R2)	;
	BICW3	#^C<RCV_LERR_M_MLEN>,-	; Store length in CXB format
		 RCV_W_LENERR(R6),-	;  also
		 CXB$W_LENGTH(R2)	;
	MOVB	RCV_B_FLAGS(R6),-	; Save flags byte
		 CXB$B_R_FLAGS(R2)	;
	TSTB	CDB_B_AQUOTA(R4)	; Are running on extra QUOTA?
	BNEQ	13$			; Br if not
	DECB	CDB_B_AQUOTA(R4)	; Else, decrement extra QUOTA
	BRB	16$			; Continue

13$:	ADDW	CDB_W_BSZ(R4),-		; Replenish CDB quota
		 CDB_W_QUOTA(R4)	;
16$:	MOVZBL	CXB$B_XE_SLOT(R2),R1	; Get mapping slot number used
;
;	Conditionalized use of buffered data paths
;
	.IF DF	RCV_DATAP
	PUSHQ	R2			; Save R2, R3
	MOVL	CDB_L_UCB0(R4),R5	; Get address of UCB #0
	MOVL	UCB$L_CRB(R5),R3	; Get CRB address
	MOVAL	CDB_L_RCVMAP(R4)[R1],R2	; Get map info slot address
	MOVL	(R2),CRB$L_INTD+VEC$W_MAPREG(R3) ; Copy data path number to CRB

	ASSUME	VEC$B_DATAPATH EQ VEC$W_MAPREG+3
	CLRB	3(R2)			; Clear data path number used

	.IFTF	; DF RCV_DATAP

	CLRBIT	R1,CDB_B_RCVMAP(R4)	; Clear in use flag

	.IFT	; DF RCV_DATAP

	PURDPR				; Purge the data path (ignore errors)
	RELDPR				; Release the data path
	POPQ	R2			; Restore R2, R3

	.ENDC	; DF RCV_DATAP

	MOVZBL	S^#SS$_NORMAL,R0	; Return success!
20$:	RSB

	.SBTTL	MOP_CTR_REQUEST - PROCESS MOP READ COUNTERS REQUEST
;++
; MOP_CTR_REQUEST - PROCESS MOP READ COUNTERS REQUEST
;
; FUNCTIONAL DESCRIPTION:
;
; This routine is called to process a remote request to read the LINE counters.
;
; Inputs:
;
;	R2 = Address of the received message
;	R4 = CDB address
;
; Outputs:
;
;	R0,R1 are destroyed
;	R4 is preserved
;--

MOP_CTR_REQUEST::			; Process a read counters request
	TSTL	CXB$L_LINK(R2)		; Is this a chained message?
	BNEQ	80$			; Br if yes, return packets
	CMPW	#IRP$C_LENGTH-		; Is a receive buffer large enough?
		+CXB$C_HEADER+3-
		+MOP_CTR_SIZE+8,-
		CXB$W_SIZE(R2)
	BGTRU	80$			; Br if no, ignore message
	MOVL	CDB_L_UCB0(R4),R5	; Get address of UCB #0
	MOVQ	CXB$G_R_SRC(R2),R0	; Save source node address
	MOVW	CXB$T_R_USERDAT+1(R2),-; Copy the request ID
		IRP$C_LENGTH+CXB$C_HEADER+1(R2) ;  to the Message block
	BSBW	BLD_IRP_CO		; Turn the message block into an IRP
	MOVQ	R0,IRP$Q_STATION(R3)	; Set the return node address
	MOVL	R4,IRP$L_ASTPRM(R3)	; Save the CDB address
	MOVB	#XE_FC_V_MOPCTR,-	; Request the counters
		IRP$B_XE_FUNC(R3)	;
	MOVW	S^#SS$_NORMAL,IRP$W_XE_STATUS(R3) ; Assume success
	MOVAB	B^MOP_CTR_BUILD,IRP$L_PID(R3) ; Store return address
	RSB				; Queue the request to the DEUNA/DELUA
;
; Error - returns packets to receive queue
;
80$:	PUSHL	CXB$L_LINK(R2)		; Save next in chain
	BSBW	ADDRCVLIST		; Add buffer to receive list
	POPL	R2			; Restore next buffer
	BNEQ	80$			; Loop if more
	RSB				; Return to caller


	.SBTTL	MOP_CTR_BUILD - BUILD THE MOP COUNTER RETURN MESSAGE
;++
; MOP_CTR_BUILD - BUILD THE MOP COUNTER RETURN MESSAGE
;
; FUNCTIONAL DESCRIPTION:
;
; This routine is called to build the return message in response to a
; MOP read counters request.
;
; Inputs:
;
;	R5 = IRP address
;
; Outputs:
;
;	R4 = CDB address
;	R5 = UCB address of UNIT 0
;
;	R0,R1 are destroyed
;--

MOP_CTR_BUILD:				; Build the MOP counter return msg
	BLBS	IRP$L_IOST1(R5),10$	; Br if error
	BRW	DELETE_BLOCK		; Else, deallocate the block

10$:	MOVL	R5,R3			; Copy IRP address
	MOVL	IRP$L_ASTPRM(R3),R4	; Get the CDB address
	PUSHR	#^M<R3,R4,R5,R6,R7,R8>	; Save registers
	MOVL	R4,R6			; Copy CDB address
	MOVAB	IRP$C_LENGTH+CXB$C_HEADER(R3),R3 ; Point to start of message block
	MOVB	#NI_CTR_REPLY,(R3)+	; Set function to reply
	TSTW	(R3)+			; Skip request ID (filled in earlier)
	MOVAB	MOPCTRTAB,R7		; Get address of MOP counters
20$:	MOVZBL	(R7)+,R8		; Get the offset to the counter desired
	BEQL	30$			; Br if end of table
	MOVAB	CDB_G_CUDB(R6),R2	; Get offset to counter block
	ADDL	R2,R8			; Compute address of the counters
	EXTZV	#0,#7,(R7),R2		; Get the width field without bitmap
	MOVC3	R2,(R8),(R3)		; Copy the counter
	MOVZBL	(R7)+,R1		; Get the width field again
	BBC	#7,R1,20$		; Br if no BITMAP to return
	MOVW	-2(R8),(R3)+		; Else, store the BITMAP
	BRB	20$			; Loop for next counter
;
; Now copy the counters that the table can't handle
;
30$:	MOVW	CDB_W_UFDCTR(R6),(R3)+	; Copy the UFD counter
	MOVW	CDB_G_CUDB+24(R6),(R3)+	; Copy the OVR counter
	MOVW	CDB_G_CUDB+26(R6),(R3)+	; Copy the LBE counter
	MOVW	CDB_W_UBUCTR(R6),(R3)+	; Copy the UBU counter
	POPR	#^M<R3,R4,R5,R6,R7,R8>	; Restore registers
	MOVAB	W^DELETE_BLOCK,IRP$L_PID(R3) ; Set the return address
	MOVAB	IRP$C_LENGTH(R3),R2	; Get address of CXB
	MOVB	#DYN$C_CXB,CXB$B_TYPE(R2) ; Make it look like a CXB
	MOVW	#MOP_CTR_SIZE+8+3,-	; Set size of transfer
		CXB$W_BCNT(R2)		;
	ASSUME	CXB$C_HEADER EQ CXB$T_T_DATA+XE_C_HEADER
	MOVW	#CXB$T_T_DATA,CXB$W_BOFF(R2) ; Set offset to start of data
	MOVL	R3,CXB$L_T_IRP(R2)	; Save IRP address in CXB
	MOVQ	IRP$Q_STATION(R3),CXB$Q_STATION(R2) ; Set STATION in CXB
	MOVB	#XE_FC_V_XMIT,CXB$B_XE_FUNC(R2) ; Set function request in CXB
	MOVAB	CXB$T_T_DATA(R2),R2	; Set R2 to start of data
	MOVQ	IRP$Q_STATION(R3),-	; Set th destination address
		XBUF_G_DEST(R2)
	MOVW	#NI_CTR_PROTYP,-	; Store the protocol type
		XBUF_W_TYPE(R2)
	MOVL	IRP$L_UCB(R3),R5	; Get back the UCB address
	MOVL	R5,XBUF_L_UCB(R2)	; Save UCB address
	INSQUE	IRP$C_LENGTH(R3),@CDB_Q_XMTREQ+4(R4) ; Insert request on request queue
	BRW	XMT_ALT_START		; Startup the reply
	

	.SBTTL	REG_DUMP - DEUNA/DELUA ERROR LOG AND DIAGNOSTICS REGISTER DUMP
;++
; REG_DUMP - DIAGNOSTICS REGISTER DUMP ROUTINE
;
; FUNCTIONAL DESCRIPTION:
;
; This routine is used to return the DEUNA/DELUA error log and diagnostics
; buffer on error or diagnostic QIO function.
;
; Inputs:
;
;	R0 = Address of the buffer
;	R4 = CDB address
;	R5 = UCB address of the unit
;
; Outputs:
;
;	R0,R1 are destroyed
;	R4,R5 are preserved
;--
REG_DUMP::
	ASSUME	DIAG_L_EXTRA EQ 32
	ASSUME	DIAG_Q_PCSR EQ DIAG_L_EXTRA+4
	ASSUME	DIAG_Q_PCBB EQ DIAG_Q_PCSR+8
	ASSUME	DIAG_W_ERR EQ DIAG_Q_PCBB+8
	ASSUME	DIAG_G_HWA EQ DIAG_W_ERR+2
	ASSUME	DIAG_W_ERR2 EQ DIAG_G_HWA+6
	BBC	#CDB_STS_V_RCBI,-	; Br if no RCBI error
		CDB_B_STS(R4),10$	;
	BISW	#XE_PCSR0_M_RCBI,-	; Else, indicate the error
		CDB_L_PCSR0(R4)		;
10$:	MOVZBL	#DIAG_C_EXTRA,(R0)+	; Insert number of returned long words
	;
	; If we are in the RUN state, then clear bit 13 which toggles
	; every second. This is to give the user a consistent "view" of
	; the UNA state!
	;
	EXTZV	#XE_PCSR1_V_STATE+16,-	; Get the current state
		#XE_PCSR1_S_STATE,-	;   (from high word)
		CDB_L_PCSR0(R4),R1	;    in R1
	CMPB	#XE_STAT_V_RUN,R1	; Are we in the RUN state?
	BNEQ	20$			; Br if no, don't clear BIT13
	CLRBIT	#13+16,CDB_L_PCSR0(R4)	; Else, clear BIT13 (in high word!)
20$:	MOVL	CDB_L_PCSR0(R4),(R0)+	; Insert last CSR contents
	CLRL	(R0)+			; Nothing from last port CSRs
	MOVQ	CDB_G_PCBB(R4),(R0)+	; Copy last PCBB info
	MOVZBW	CDB_B_DIAG1(R4),(R0)+	; Return error flags info
	MOVL	CDB_G_HWA(R4),(R0)+	; Return hardware physical address
	MOVW	CDB_G_HWA+4(R4),(R0)+	;	...
	MOVW	CDB_W_DIAG2(R4),(R0)+	; Return extra error info
	RSB

	.SBTTL	RESTART_ROUT - PROCESS EXPIRATION OF RESTART TIMER
;++
; RESTART_ROUT - PROCESS EXPIRATION OF RESTART TIMER
;
; Functional description:
;
; This routine is entered when the RESTART delta time has expired. The action
; is to check if the specified unit has been restarted, if so, then it is
; automatically restarted.
;
; Inputs:
;
;	R4 = CDB address
;	R5 = TQE address (but must be at least as long as an IRP)
;
;	IPL = IPL$_TIMER
;
; Implicit inputs:
;
;	IRP$L_RBOFF(R5) = UCB address for UNIT
;
; Outputs:
;
;	R0-R3 are destroyed.
;--
	.ENABL	LSB
RESTART_ROUT::				; Process expiration of restart timer
	PUSHL	R5			; Save R5
	ASSUME	IRP$L_RBOFF GT TQE$C_LENGTH
	MOVAB	TQE$C_LENGTH(R5),R2	; Point to IRP portion of TQE
	MOVL	IRP$L_RBOFF(R2),R5	; Reset R5 to UCB address
;
; Turn TQE into an IRP
;
	MOVAQ	(R2)+,R3		; Copy IRP address, skip to size field
	ASSUME	IRP$W_SIZE EQ 8
	ASSUME	IRP$B_TYPE EQ IRP$W_SIZE+2
	ASSUME	IRP$B_RMOD EQ IRP$B_TYPE+1
	ADDL	#2,R2			; Skip size field
	MOVW	#DYN$C_IRP,(R2)+	; Set type to IRP
	ASSUME	IRP$L_PID EQ IRP$B_RMOD+1
	MOVAB	W^RETURN_IRP,(R2)+	; Set return address form IOPOST
	ASSUME	IRP$L_AST EQ IRP$L_PID+4
	ASSUME	IRP$L_ASTPRM EQ IRP$L_AST+4
	CLRQ	(R2)+			; Clear AST, ASTPRM
	ASSUME	IRP$L_WIND EQ IRP$L_ASTPRM+4
	ASSUME	IRP$L_UCB EQ IRP$L_WIND+4
	CLRL	(R2)+			; Clear WIND
	MOVL	R5,(R2)+		; Set UCB address
	ASSUME	IRP$W_FUNC EQ IRP$L_UCB+4
	ASSUME	IRP$B_XE_FUNC EQ IRP$W_FUNC+1
	ASSUME	IRP$B_EFN EQ IRP$W_FUNC+2
	ASSUME	IRP$B_PRI EQ IRP$B_EFN+1
	ASSUME	IRP$L_IOSB EQ IRP$B_PRI+1
	MOVW	#<XE_FC_V_RESTART@8>,(R2)+ ; Set function request
	CLRW	(R2)+			; Clear EFN, PRI
	CLRL	(R2)+			; Clear IOSB
	ASSUME	IRP$W_CHAN EQ IRP$L_IOSB+4
	ASSUME	IRP$W_STS EQ IRP$W_CHAN+2
	ASSUME	IRP$L_SVAPTE EQ IRP$W_STS+2
	CLRQ	(R2)+			; Clear CHAN, STS, SVAPTE
	ASSUME	IRP$W_BOFF EQ IRP$L_SVAPTE+4
	ASSUME	IRP$W_BCNT EQ IRP$W_BOFF+2
	ASSUME	IRP$W_BCNT EQ IRP$L_BCNT
	ASSUME	IRP$L_MEDIA EQ IRP$W_BCNT+6
	CLRQ	(R2)+			; Clear BOFF, BCNT
	MOVZWL	#<XE_FC_V_INIT@8>,(R2)+	; Set MEDIA
	CLRL	(R2)+			; Clear MEDIA+4
;
; RESTART the UNIT
;
	DSBINT	UCB$B_FIPL(R5)		; Raise IPL
	BICW	#UCB$M_XE_INTERLOCK,-	; Clear the RESTART interlock
		UCB$W_DEVSTS(R5)	;
	BBSS	#UCB$V_XE_INITED,-	; Br if unit already inited
		UCB$W_DEVSTS(R5),10$	;
	BSBW	START			; Start protocol
	BLBS	R0,30$			; Br if success

	BSBW	STOP			; Shutdown unit
10$:	MOVL	R3,R5			; Point R5 to IRP
	BSBB	RETURN_IRP		; Return the IRP
30$:	ENBINT				; Re-enable interrupts
	POPL	R5			; Restore R5
	RSB				; Return to caller

RETURN_IRP:
	MOVAB	-TQE$C_LENGTH(R5),R0	; Get address of start of structure
	JMP	G^COM$DRVDEALMEM	; Deallocate the IRP

	.SBTTL	TQE_TIMER - PROCESS EXPIRATION OF TQE TIMER
;++
; TQE_TIMER - PROCESS EXPIRATION OF TQE TIMER
;
; Functional description:
;
; This routine is entered when the TQE delta time has expired. The action is to
; check all timer cells and shut down the controller if any have expired.
;
; Inputs:
;
;	R4 = CDB address
;	R5 = TQE address
;
;	IPL = IPL$_TIMER
;
; Outputs:
;
;	R0-R3 are destroyed.
;	R4,R5 are preserved
;--
	.ENABL	LSB
TQE_TIMER::				; Process expiration of TQE timer
	MOVL	CDB_L_UCB0(R4),R0	; Get first UCB address
	DSBINT	UCB$B_DIPL(R0)		; Sync access to UCB and CDB
	BBC	#CDB_STS_V_INITED,-	; Br if NOT inited
		CDB_B_STS(R4),STOP_TQE
	TSTB	CDB_B_TIM_XMT(R4)	; Is the xmit timer going?
	BEQL	10$			; Br if not
	DECB	CDB_B_TIM_XMT(R4)	; Timer expired?
	BEQL	TIMOUT			; Br if yes
10$:	TSTB	CDB_B_TIM_DNI(R4)	; Is the DNI timer going?
	BEQL	20$			; Br if not
	DECB	CDB_B_TIM_DNI(R4)	; Timer expired?
	BEQL	TIMOUT			; Br if yes
20$:	BBC	#XM$V_STS_BUFFAIL,-	; Br if NO buffer allocation failures
		CDB_L_DEVDEPEND(R4),30$	;
	SETIPL	CDB_B_FIPL(R4)		; Else, sync access to UCB & CDB
	BSBW	FILLRCVLIST		; And try to replenish receive buffers
30$:	ENBINT				; Restore IPL

	.IF DF	POINT
	PUSHQ	R4			;% Save R4, R5
	MOVL	CDB_L_UCB0(R4),R5	;% Get UCB address of unit 0
	DSBINT	UCB$B_FIPL(R5)		;% Sync access to UCB
50$:	MOVL	UCB$L_LINK(R5),R5	;% Travel down UCBs
	BEQL	70$			;% Br if end of list
	ASSUME	UCB$V_XE_INITED EQ 0
	BLBC	UCB$W_DEVSTS(R5),50$	;% Br if not inited
	BBC	#UCB$V_XE_RUN,-		;% Br if not running yet
		UCB$W_DEVSTS(R5),50$	;%
	CMPB	#NMA$C_LINPR_POI,-	;% Are we in point to point mode?
		UCB$B_XE_PRO(R5)	;%
	BNEQ	50$			;% Br if not
	BITW	#UCB$M_XE_START!-	;% Br if not in startup or
		 UCB$M_XE_STACK,-	;%  stack wait states
		UCB$W_DEVSTS(R5)	;%
	BEQL	50$			;%
	MOVL	UCB$L_XE_STIRP(R5),R2	;% Get startup IRP addresss
	BSBW	BLD_STRT_IRP		;% Build the startup IRP
	BRB	50$			;% Look for more
70$:	ENBINT				;% Re-enable interrupts
	POPQ	R4			;% Restore R4, R5
	.ENDC

	RSB				; Return to caller

TIMOUT:	PUSHQ	R4			; Save R4, R5
	MOVL	R0,R5			; Copy address of UCB0
	BSBB	DEV_TIMEOUT		; Else, timeout has occurred
	POPQ	R4			; Restore R4, R5

STOP_TQE:				; Stop the TQE
	BICB	#TQE$M_REPEAT,TQE$B_RQTYPE(R5) ; Stop the timer
	BICB	#CDB_STS_M_TIMER,-	; Indicate that timer is stopped
		CDB_B_STS(R4)		;
	BICB	#DPT$M_NOUNLOAD,-	; OKAY to unload the driver now
		DPT$TAB+DPT$B_FLAGS	;
	BRB	30$			; Leave
	.DSABL	LSB

	.SBTTL	TIMEOUT - TIMEOUT SERVICE ROUTINE
;++
; TIMEOUT - TIMEOUT SERVICE ROUTINE
;
; Functional description:
;
; This routine is entered on device timeout. The action is to
; shut the unit down.
;
; Inputs:
;
;	R5 = UCB ADDRESS
;
;	IPL = DIPL
;
; Outputs:
;
;	R3,R4 are destroyed.
;	R5 is preserved
;--
	.ENABL	LSB
TIMEOUT::				; Timeout or powerfail
	BICW	#UCB$M_TIM!UCB$M_INT,UCB$W_STS(R5) ; Disable timer

	ASSUME	UCB$V_XE_INITED  EQ  0
	BLBC	UCB$W_DEVSTS(R5),20$	; Br if not inited
	BBC	#UCB$V_POWER,-		; Branch if device timeout
		UCB$W_STS(R5),-
		DEV_TIMEOUT
	MOVL	UCB$L_XE_CDB(R5),R4	; Get CDB address
	BEQL	20$			; Just return if no CDB
	BISB2	#CDB_STS_M_POWER,-	; Set the CDB power failure bit
		CDB_B_STS(R4) 
	BRB	10$			; Go handle the error

DEV_TIMEOUT::				; Hardware device timeout
	MOVL	UCB$L_CRB(R5),R4	; Get CRB address
	ASSUME	IDB$L_CSR EQ 0
	MOVL	@CRB$L_INTD+VEC$L_IDB(R4),R3 ; Get CSR address
	MOVW	#XE_PCSR0_M_RSET,PCSR0(R3) ; Stop the device
	MOVL	CRB$L_AUXSTRUC(R4),R4	; Get CDB address
	BEQL	20$			; Br if no CDB
	SETBIT	#XM$V_STS_TIMO,CDB_L_DEVDEPEND(R4) ; Set error status
10$:	MOVW	#XE_PCSR0_M_USCI,R3	; Indicate fatal error
	PUSHL	R5			; Save UCB address
	BSBW	SCHED_FORK		; Schedule a fork process
	POPL	R5			; Restore UCB address
20$:	RSB				; Return to caller
	.DSABL	LSB

	.SBTTL	ALLOC_CDB - ALLOCATE THE CDB
;++
; ALLOC_CDB - ALLOCATE THE CDB
;
; Functional description:
;
; This routine allocates and initializes the CDB.
;
; Inputs:
;
;	R5 = UCB address
;
; Outputs:
;
;	R0 = Status return for request
;
;	All other registers are preserved.
;
;--

ALLOC_CDB:				; Allocate a CDB
	PUSHR	#^M<R1,R2,R3,R4,R5>	; Save registers
	MOVZWL	#CDB_C_LENGTH,R1	; Get size of CDB allocation
	JSB	G^EXE$ALONONPAGED	; Try to allocate CDB
	BLBC	R0,90$			; Br if error

	MOVL	UCB$L_CRB(R5),R4	; Get CRB address
	MOVL	R2,CRB$L_AUXSTRUC(R4)	; Store CDB address
	MOVL	UCB$L_DDB(R5),R4	; Get DDB address
	MOVL	DDB$L_UCB(R4),R4	; Get UCB0 address
	MOVL	R4,R3			; Save UCB0 address
10$:	MOVL	R2,UCB$L_XE_CDB(R4)	; Store CDB address
	MOVAB	CDB_G_HWA(R2),-		; Store address of NI device's
		UCB$L_NI_HWAPTR(R4)	; unique hardware address
	MOVL	UCB$L_LINK(R4),R4	; Position to next UCB and continue
	BNEQ	10$			; if there is a next UCB

;
; Initialize CDB
;
;   The PADDING MODE and the ECHO MODE of the DEUNA/DELUA will default to
;   the enabled (ON) state.
;
	ASSUME	NMA$C_STATE_ON EQ 0

	PUSHQ	R2			; Save CDB, UCB0 address
	MOVC5	#0,(R2),#0,R1,(R2)	; Zero the structure
	POPQ	R2			; Restore CDB, UCB0 address

	MOVL	R3,CDB_L_UCB0(R2)	; Setup address of UCB unit 0
;
;  Initialize fork block in CDB
;
	ASSUME	CDB_L_FQFL EQ 0
	ASSUME	CDB_L_FQBL EQ CDB_L_FQFL+4
	CLRQ	(R2)+			; Skip link pointers
	ASSUME	CDB_W_SIZE EQ CDB_L_FQBL+4
	ASSUME	CDB_B_TYPE EQ CDB_W_SIZE+2
	ASSUME	CDB_B_FIPL EQ CDB_B_TYPE+1
	MOVL	#<<<IPL$_XE_FIPL@8>!DYN$C_CDB>@16>!-; Set size, type and FIPL
		CDB_C_LENGTH,(R2)+
	ASSUME	CDB_L_FPC EQ CDB_B_FIPL+1
	MOVAB	FORK_PROC,(R2)+		; Set fork process address
	MOVZBL	S^#SS$_NORMAL,R0	; Return success
90$:	POPR	#^M<R1,R2,R3,R4,R5>	; Restore registers
	RSB				; Return to caller

	.SBTTL	SHUTDOWN_UNA - SHUTDOWN DEUNA/DELUA AND ALL UNITS
;++
; SHUTDOWN_UNA - SHUTDOWN DEUNA/DELUA AND ALL UNITS
;
; Inputs:
;
;	R4 = CDB address
;	R5 = UCB address of unit #0
;
;
;	IPL = FIPL
;
; Outputs:
;
;	R3-R5 are preserved.
;
;	R0-R2 are destroyed.
;--

SHUTDOWN_UNA::				; Shutdown DEUNA/DELUA
	BBS	#CDB_STS_V_INITED,-	; Br if DEUNA/DELUA inited
		CDB_B_STS(R4),10$	;
	RSB				; Else, return

10$:	PUSHR	#^M<R3,R5,R6,R7>	; Save registers
;
; Shutdown DEUNA/DELUA and reset controller status
;
	MOVL	UCB$L_CRB(R5),R2	; Get CRB address
	ASSUME	IDB$L_CSR EQ 0
	MOVL	@CRB$L_INTD+VEC$L_IDB(R2),R2 ; Get CSR address
	DSBINT	UCB$B_DIPL(R5)		; Raise IPL for master clear
	BISW	#XE_PCSR0_M_RSET,-	; Disable device
		PCSR0(R2)
	BICB	#^C<CDB_STS_M_FORK_PEND!- ; Reset all but needed bits
		CDB_STS_M_TIMER!CDB_STS_M_POWER!-
		CDB_STS_M_FUNC>,CDB_B_STS(R4) ;
	ENBINT				; Return to fork level
;
; Release the receive and transmit buffer map registers
;
	CLRL	R7			; Init slot number
	ASSUME	CDB_L_RCVMAP+<4*MAX_C_RCV> EQ CDB_L_XMTMAP
	MOVAB	CDB_L_RCVMAP(R4),R6	; Get address of mappig slots
20$:	MOVL	UCB$L_CRB(R5),R3	; Get CRB address
	ASSUME	VEC$W_MAPREG+2 EQ VEC$B_NUMREG
	ASSUME	VEC$B_NUMREG+1 EQ VEC$B_DATAPATH
	MOVL	(R6)+,CRB$L_INTD+VEC$W_MAPREG(R3) ; Set mapping information
	BLSS	30$			; Br if none allocated
	TSTB	CRB$L_INTD+VEC$B_DATAPATH(R3) ; Is there a datapath?
	BEQL	25$			; Br if not - don't do purge or release
	PURDPR				; Purge the data path
	RELDPR				; Release the data path
25$:	RELMPR				; Release the map register
	MNEGL	#1,-4(R6)		; Reset mapping info
30$:	CLRBIT	R7,CDB_B_RCVMAP(R4)	; Clear mapping slot flag
	AOBLSS	#MAX_C_RCV+MAX_C_XMT,R7,20$ ; Loop if more map registers
;
; Release the PCBB map registers
;
	MOVL	UCB$L_CRB(R5),R3	; Get CRB address
	ASSUME	VEC$W_MAPREG+2 EQ VEC$B_NUMREG
	ASSUME	VEC$B_NUMREG+1 EQ VEC$B_DATAPATH
	MOVL	CDB_L_PCBBMAP(R4),-	; Setup map info in CRB
		 CRB$L_INTD+VEC$W_MAPREG(R3) ;
	BEQL	50$			; Br if none
	CLRL	CDB_L_PCBBMAP(R4)	; No more mapping info
	RELMPR				; Release the map register
50$:	;
	; Deallocate all receive buffers and complete all I/O request packets
	;
	BICB	#CDB_STS_M_POWER,-	; Clear the powerfailure bit (if it had
		CDB_B_STS(R4)		; been set) at this time
	MOVAB	CDB_Q_QUEUES(R4),R6	; Get address of first queue listhead
	MOVZWL	#CDB_C_QUEUES,R7	; Get number of queues
60$:	REMQUE	@(R6),R3		; Get next IRP/BUFFER
	BVS	150$			; Br if none
	CMPB	IRP$B_TYPE(R3),S^#DYN$C_IRP ; Is this an IRP?
	BEQL	70$			; Br if yes
	CMPB	IRP$B_TYPE(R3),S^#DYN$C_CXB ; Is this a CXB?
	BEQL	80$			; Br if yes
	BUG_CHECK NOBUFPCKT,FATAL	; Else, fatal error
;
; IRP
;
70$:	BSBB	IRP_ABORTED		; Abort the IRP
	BRB	60$			; Try for more
;
; CXB
;
80$:	$DISPATCH	CXB$B_XE_FUNC(R3),TYPE=B,-
	<-	;function	action

		<XE_FC_V_XMIT	100$>,-	; XMIT request
		<XE_FC_V_RECV	140$>,-	; RECV request
	>

	BUG_CHECK NOBUFPCKT,FATAL	; Fatal error - not a valid IRP

;
; CXB - XMIT request
;
100$:	MOVL	CXB$L_T_IRP(R3),R0	; Get IRP address
	BEQL	110$			; Br if none, return buffer
	MOVL	R0,R3			; Copy IRP address
	BSBB	IRP_ABORTED		; Abort the IRP
	BRB	60$			; Try for more
	;
	;  FFI CXB transmit to complete
	;
110$:	MOVZWL	CXB$W_BOFF(R3),R1	; Get offset to start of data
	ADDL	R3,R1			; Compute start of Ethernet header
	MOVZWL	XBUF_W_TYPE(R1),R1	; Get protocol type
	BSBW	MATCH_PROTYP		; Find the protocol type
	BLBC	R0,140$			; Br if no UCB, drop buffer
	PUSHL	R4			; Save CDB address
	MOVL	UCB$L_XE_FFI(R5),R4	; Get FFI block address
	BEQL	120$			; Br if not there, drop buffer
	MOVZWL	#SS$_ABORT,R0		; Else, set return status
	JSB	@FFI$L_XMIT_DONE(R4)	; Complete the XMIT in error
	POPL	R4			; Restore CDB address
	BRB	60$			; Try for more
120$:	;
	;  No more UCB for CXB transmit request
	;
	POPL	R4			; Restore CDB address

;
; CXB - RECV request
;	

140$:	MOVL	R3,R0			; Copy buffer address
	JSB	G^COM$DRVDEALMEM	; Deallocate the buffer
	BRB	60$			; Try for more
	;
	; Loop to next queue
	;
150$:	ADDL	#8,R6			; Skip to next queue listhead
	SOBGTR	R7,60$			; Loop if more queues
	;
	; Cleanup all I/O on all UNITS
	;
	MOVL	CDB_L_UCB0(R4),R5	; Get UNIT #0 UCB address
	BEQL	190$			; Br if not set yet
170$:	MOVL	UCB$L_LINK(R5),R5	; Get next unit's address
	BEQL	190$			; Br if none
	BSBW	SHUTDOWN		; Shutdown the UNIT
	BRB	170$			; Check if more UNIT's
190$:	POPR	#^M<R3,R5,R6,R7>	; Restore registers
	RSB				; Return to caller

	.SBTTL	IRP_ABORTED - Abort an IRP on one of the CDB queues
;++
; IRP_ABORTED - Abort CDB IRP
;
; Functional description:
;
; The I/O is aborted according to the type of operation requested.  For
; initialization requests, the SS$_CTRLERR is returned except when the
; function was a self-test with the TRANSCEIVER DISCONNECTED, then the
; status is SS$_MEDOFL.  For all other I/O requests, the error returned
; is SS$_ABORT.
;
; Inputs:
;	R3 = IRP address
;	R4 = CDB address
;
; Outputs:
;	R4 is preserved
;	R0,R1,R2,R3,R5 are destroyed.
;-

IRP_ABORTED:				; Abort a CDB IRP
	$DISPATCH	IRP$B_XE_FUNC(R3),TYPE=B,-
	<-	;function	action

		<XE_FC_V_LDMEM	 10$>,-	; Load DEUNA/DELUA memory
		<XE_FC_V_RDMEM	 10$>,-	; Read DEUNA/DELUA memory
		<XE_FC_V_INIT	 30$>,-	; Start request
		<XE_FC_V_TESTD	 30$>,-	; Self-test done
		<XE_FC_V_RESTART 40$>,-	; Automatic restart
		<XE_FC_V_LDRING	 40$>,-	; Load ring pointer
		<XE_FC_V_RDDPA	 40$>,-	; Read default physical address
		<XE_FC_V_WTPHYAD 40$>,-	; Write physical address
		<XE_FC_V_WTMULTI 40$>,-	; Write multicast address
		<XE_FC_V_WTMODE	 40$>,-	; Write DEUNA/DELUA mode
		<XE_FC_V_START	 40$>,-	; Start XMIT/RECV process
	>
	BRB	20$			; All others
;
; For the Load/Read DEUNA/DELUA memory, we must release the MAP registers.
;
10$:	MOVL	CDB_L_UCB0(R4),R5	; Get address of UCB unit #0
	MOVL	UCB$L_CRB(R5),R2	; Get CRB address
;
;	The read memory and load memory functions do not use the buffered
;	data paths, therefore no purge or release is necessary.
;
	ASSUME	VEC$W_MAPREG+2 EQ VEC$B_NUMREG
	ASSUME	VEC$B_NUMREG+1 EQ VEC$B_DATAPATH
	MOVL	IRP$L_XE_MAP(R3),-	; Setup map register data
		 CRB$L_INTD+VEC$W_MAPREG(R2) ;	...
	RELMPR				; Release map registers
20$:	BSBW	ABORT_PKT		; ABORT the I/O request
	BRB	60$			; Leave
;
; Self-test failure codes go here
;
30$:	BBC	#XE_PCSR1_V_XPWR,-	; Br if the XCVR power is okay
		CDB_L_FR3+2(R4),40$	;  ..must be broken DEUNA/DELUA
	MOVZWL	#SS$_MEDOFL,R0		; Else, return the correct indicator
	SETBIT	#XM$V_STS_DISC,CDB_L_DEVDEPEND(R4) ; Save Internal error reason
	BRB	50$			; Complete the request
;
; All failures during intialization go here
;
40$:	MOVZWL	#SS$_CTRLERR,R0		; Return broken hardware
50$:	MOVB	CDB_L_FR3+3(R4),CDB_L_DEVDEPEND(R4) ; Copy self-test status code
	BSBW	IO_DONE3		; Complete the I/O request
60$:	RSB				; Return to caller

	.SBTTL SHUTDOWN - SHUT DOWN UNIT 
	.SBTTL SHUTDOWN_PROTYP - SHUT DOWN PROTOCOL TYPE
;++
; SHUTDOWN - SHUT DOWN UNIT
; SHUTDOWN_PROTYP - SHUT DOWN PROTOCOL TYPE
;
; Functional description:
;
; This routine is used to shut down the XE unit as a result of a 
; SETMODE and SHUTDOWN. The action is to abort all I/O for the unit
; and then to clean up the unit data base.
;
; Inputs:
;
;	R3 = IRP address (SHUTDOWN_PROTYP entry only)
;	R4 = CDB address
;	R5 = UCB address
;
;	IPL = FIPL
;
; Outputs:
;
;	R3-R5 are preserved
;
;	R0-R2 are destroyed.
;--
SHUTDOWN_PROTYP::			; Shut down protocol type
	BBC	#UCB$V_ONLINE,-		; Br if not online
		 UCB$W_STS(R5),10$	;
	ASSUME	UCB$V_XE_INITED  EQ  0
	BLBC	UCB$W_DEVSTS(R5),10$	; Br if not inited
	BBC	#UCB$V_XE_SHARE,-	; Br if not a shared UCB
		 UCB$W_DEVSTS(R5),SHUTDOWN ; shutdown entire unit
;
; Try to find SHR data structure
;
	BSBW	MATCH_SHR		; Check PID and CHAN
	BNEQ	10$			; Br if NO MATCH, skip it
;
; Match found - clear inited bit and clean up all I/O on SHR data structure
;
	PUSHL	R6			; Save R6
	MOVL	R1,R6			; Copy SHR address
	BSBW	CLEANUP_SHR		; Cleanup the SHR data structure
	POPL	R6			; Restore R6
10$:	RSB				; Return to caller

SHUTDOWN::				; Shut down unit
	BBC	#UCB$V_ONLINE,-
		UCB$W_STS(R5),5$	; If BC not online

	ASSUME	UCB$V_XE_INITED  EQ  0
	BLBS	UCB$W_DEVSTS(R5),10$	; Br if UCB is inited
5$:	RSB				; It's not time to shut down, yet

;
; If a power failure occurred, and the protocol has both initialized the FFI
; interface and supplied an asynchronous error routine, then call back
; the protocol at this routine address with a status value indicating that
; a power failure had taken place.
;

10$:	BBC	#CDB_STS_V_POWER,-	; Skip notification if power failure
		CDB_B_STS(R4),20$	; did not occur
	PUSHL	R4			; Save CDB address
	MOVL	UCB$L_XE_FFI(R5),R4	; Retrieve FFI address
	BEQL	15$			; Nothing to do if there isn't one
	MOVL	FFI$L_ERROR(R4),R2	; Retrieve asynch error routine address
	BEQL	15$			; Nothing to do if there isn't one
	MOVZWL	#SS$_POWERFAIL,R0	; Indicate that a powerfailure occurred
	JSB	(R2)			; Call back the asynch error routine 
15$:	POPL	R4			; Restore CDB address
	
;
; Start a 3-second timer to restart any UNIT needing automatic restart.
; This restart timer only runs if the device was halted due to a fatal error.
;
; Note, that the UCB multicast address list is purged, which will nullify
; any restart operation that may be performed by the DEUNA/DELUA driver itself 
; (only if the user has specified any multicast addresses).
;

20$:	PUSHR	#^M<R3,R6,R7>		; Save registers
	BBC	#UCB$V_XE_RESTART,-	; Br if this UNIT does not need
		UCB$W_DEVSTS(R5),22$	;  automatic restart
	ASSUME	IRP$C_LENGTH GE TQE$C_LENGTH
	MOVZBL	#IRP$C_LENGTH+TQE$C_LENGTH,R1 ; Get size of IRP/TQE
	JSB	G^EXE$ALONONPAGED	; Try to allocate a IRP/TQE
	BLBC	R0,22$			; Br if failure - too bad
	ASSUME	IRP$Q_STATION GT TQE$C_LENGTH
	BISW	#UCB$M_XE_INTERLOCK,-	; Interlock the RESTART operation
		UCB$W_DEVSTS(R5)	;

	ASSUME	TQE$B_TYPE EQ TQE$W_SIZE+2
	ASSUME	TQE$B_RQTYPE EQ TQE$B_TYPE+1
	MOVL	#<<DYN$C_TQE@16>!<IRP$C_LENGTH+TQE$C_LENGTH>>,- ; Set STRUCTURE
		TQE$W_SIZE(R2)		;  TYPE and SIZE
	MOVL	R5,TQE$C_LENGTH+IRP$L_RBOFF(R2)	; Save UCB address in IRP
	PUSHQ	R4			; Save R4, R5
	MOVL	R2,R5			; Copy TQE address
	MOVQ	#RESTART_DELTA,-	; Set the delta time
		TQE$Q_DELTA(R5)		;
	MOVAB	W^RESTART_ROUT,R3	; Get address of RESTART routine
	MOVB	#TQE$C_SSSNGL,-		; Set the request type
		TQE$L_RQPID(R5)		;
	BSBW	FORK_TIMER		; FORK to startup the timer
	POPQ	R4			; Restore R4, R5
	BRB	23$			; Continue

22$:	CLRBIT	#UCB$V_XE_RESTART,-	; Restart is not possible!
		 UCB$W_DEVSTS(R5)
23$:	MOVW	#INIT_C_QUOTA,UCB$W_XE_HBQ(R5) ; Reset hardware buffer quota
	BICW	#UCB$M_INT!UCB$M_POWER!-
		UCB$M_TIM,UCB$W_STS(R5)	; Reset device status
	BICW	#UCB$M_XE_INITED!-	; No longer inited
		 UCB$M_XE_RUN,UCB$W_DEVSTS(R5) ; ..or  running
	CLRBIT	#XM$V_STS_ACTIVE,UCB$L_DEVDEPEND(R5) ; Clear active bit
	BBC	#XM$V_ERR_FATAL,CDB_L_DEVDEPEND(R4),25$ ; Br if not FATAL
	SETBIT	#XM$V_ERR_FATAL,UCB$L_DEVDEPEND(R5) ; Else, indicate FATAL
;
; Reset UCB multicast address list
;
25$:	CMPL	R5,CDB_L_PRMUSER(R4)	; Is this unit the PROMISCUOUS user?
	BNEQ	27$			; Br if not
	CLRL	CDB_L_PRMUSER(R4)	; Else, clear the PROMISCUOUS user addr
	CLRBIT	#PB_MOD_V_PROM,CDB_W_MODE(R4) ; Reset from promiscuous mode
	BSBW	BLD_STOP_IRP		; Build an IRP to RESET hardware mode
27$:	BBS	#UCB$V_XE_RESTART,-	; Br if this UNIT is restarting
		UCB$W_DEVSTS(R5),28$	;  don't clear multicast list
	PUSHQ	R4			; Save R4, R5
	CLRB	UCB$B_XE_MULTI(R5)	; No more multicast addresses
	MOVC5	#0,UCB$G_XE_MULTI(R5),#0,- ; Zero the structure
		#6*MAX_C_MLT,UCB$G_XE_MULTI(R5) ;
	POPQ	R4			; Restore R4, R5
;
; Reset CDB multicast address list, Flush all attention ASTs.
;
28$:	BSBW	ADD_MULTI		; Re-calculate multicast address list
	PUSHL	R4			; Save CDB address
30$:	MOVAB	UCB$L_XE_AST(R5),R7	; Get address of AST listhead
	MOVL	(R7),R0			; Anything in list?
	BEQL	40$			; Br if not
	MOVZWL	ACB$L_KAST+10(R0),R6	; Force channel match
	MOVZWL	ACB$L_KAST+12(R0),R2	; Get process index
	MOVL	G^SCH$GL_PCBVEC,R4	; Get PCB address vector address
	MOVL	(R4)[R2],R4		; Get PCB address
	JSB	G^COM$FLUSHATTNS	; Flush AST
	BRB	30$
40$:	POPL	R4			; Restore CDB address
;
; Complete all RCV IRPs for this unit
;
	ASSUME	UCB$C_XE_QUEUES-1 EQ 3	; One queue for shared users
45$:	REMQUE	@UCB$Q_XE_RCVREQ(R5),R3	; Get IRP
	BVS	50$			; Br if none
	BSBW	ABORT_PKT		; Abort the I/O request
	BRB	45$			; Get next IRP
;
; Complete all XMIT CXBs for this unit
;
50$:	REMQUE	@UCB$Q_XE_XMTREQ(R5),R3	; Get CXB
	BVS	55$			; Br if none
	MOVL	CXB$L_T_IRP(R3),R0	; Get IRP address
	BNEQ	54$			; Br if present
	PUSHL	R4			; Save CDB address
	MOVL	UCB$L_XE_FFI(R5),R4	; Get FFI block address
	MOVZWL	#SS$_ABORT,R0		; Set status return
	JSB	@FFI$L_XMIT_DONE(R4)	; Complete CXB
	POPL	R4			; Restore CDB address
	BRB	50$			; Get next CXB

54$:	MOVL	R0,R3			; Copy IRP address
	BSBW	ABORT_PKT		; Abort the I/O request
	BRB	50$			; Get next CXB
;
; Deallocate all receive CXBs
;
55$:	REMQUE	@UCB$Q_XE_RCVMSG(R5),R2 ; Get message buffer
	BVS	70$			; Br if none
	ADDW	UCB$W_DEVBUFSIZ(R5),-	; Restore quota
		UCB$W_XE_QUOTA(R5)	;
;
;	The buffer may be smaller than the normal message size, if this
;	is a cloned buffer for the promiscuous user. Therefore, we must
;	check to make sure the buffer is large enough to be returned
;	the the device's receive buffer pool.
;
	ADDW3	#CXB$C_HEADER+-		; Calculate size of "normal"
		CXB$C_TRAILER,- 	;  receive buffer
		CDB_W_BSZ(R4),R0	;
	CMPW	R0,CXB$W_SIZE(R2)	; Can buffer be returned?
	BNEQ	60$			; Br if not, delete buffer instead
	BSBW	ADDRCVLIST		; Try to add to receiver list
	BRB	50$			; Loop for more

60$:	MOVL	R2,R0			; Copy buffer address for deallocation
	JSB	G^COM$DRVDEALMEM	; Deallocate the buffer
	BRB	50$			; Loop for more
;
; Cleanup all SHR structures if fatal error
;
70$:	BBC	#UCB$V_XE_SHARE,-	; Br if not a SHARED UCB
		UCB$W_DEVSTS(R5),100$	;
	MOVL	UCB$L_XE_DEFUSR(R5),R6	; Get default SHR structure address
	BEQL	90$			; Br if none
	BSBW	CLEANUP_SHR		; Else, cleanup the structure
	BBC	#XM$V_ERR_FATAL,-	; Br if not a fatal error
		UCB$L_DEVDEPEND(R5),90$
	BSBW	DELETE_SHR		; And delete the structure
90$:	MOVL	UCB$Q_XE_SHARE(R5),R6	; Get address of next LIMITED user
	CMPL	R6,UCB$Q_XE_SHARE(R5)	; End of list?
	BEQL	120$			; Br if yes, don't restore quota (yet)
	BSBW	CLEANUP_SHR		; Cleanup the I/O
	BBC	#XM$V_ERR_FATAL,-	; Br if not a fatal error
		UCB$L_DEVDEPEND(R5),90$
	BBS	#UCB$V_XE_RESTART,-	; Br if this UNIT is re-starting
		UCB$W_DEVSTS(R5),90$
	BSBW	DELETE_SHR		; Else, delete the structure
	BRB	90$			; Look for more
;
; Restore quota
;
100$:	BBS	#UCB$V_XE_RESTART,-	; Br if this UNIT is re-starting
		UCB$W_DEVSTS(R5),140$
	MOVZWL	UCB$L_XE_PID(R5),R0	; Get PID of last starter
	MOVL	G^SCH$GL_PCBVEC,R1	; Address PCB vector
	MOVL	(R1)[R0],R0		; Get PCB of owner
	CMPL	PCB$L_PID(R0),-
		UCB$L_XE_PID(R5)	; Still there?
	BNEQ	120$			; If NEQ no
	MOVL	PCB$L_JIB(R0),R0	; Get JIB address
	MOVZWL	UCB$W_XE_QUOTA(R5),R1	; Convert to longword
	ADDL	R1,JIB$L_BYTCNT(R0)	; Return byte count quota
	ADDL	R1,JIB$L_BYTLM(R0)	; ..and byte limit quota
	CLRW	UCB$W_XE_QUOTA(R5)	; Prevent this from being
					; returned again
;
; Delete the STARTUP IRP for point-to-point mode
;
120$:	MOVL	UCB$L_XE_STIRP(R5),R0	;% Get the startup IRP address
	BEQL	130$			;% Br if none
	CLRL	UCB$L_XE_STIRP(R5)	;% All done
	JSB	G^COM$DRVDEALMEM	;% Deallocate the IRP
;
; If there is an FFI block and the SHUT_DONE routine is set, then
; notify the FFI user that shutdown is now complete.
;
130$:	MOVL	UCB$L_XE_FFI(R5),R0	; Get FFI block address
	BEQL	140$			; Br if none
	CLRL	UCB$L_XE_FFI(R5)	; Cleanup FFI interface
	MOVL	FFI$L_SHUT_DONE(R0),R1	; Get address of routine
	BEQL	140$			; Br if none
	PUSHL	R4			; Save CDB address
	MOVL	R0,R4			; Copy FFI block address
	JSB	(R1)			; Call back FFI user
	POPL	R4			; Restore CDB address
;
; Decrement UNIT count on CDB and cleanup CDB if last unit
;
140$:	DECB	CDB_B_UNTCNT(R4)	; One less unit on CDB
	BNEQ	150$			; Br if more
	BSBW	SHUTDOWN_UNA		; Else, shutdown entire DEUNA/DELUA
150$:	POPR	#^M<R3,R6,R7>		; Restore registers
	RSB				; Return to caller


	.SBTTL	BLD_STOP_IRP - Build an IRP to reset promiscuous mode
;++
; BLD_STOP_IRP - Build an IRP to reset the promiscuous mode
;
; Functional description:
;
; This routine will allocate and build an IRP to reset the hardware mode
; from promiscous.
;
; Inputs:
;	R4 = CDB address
;	R5 = UCB address
;
; Outputs:
;	R0,R1,R2,R3 are destroyed.
;--
BLD_STOP_IRP:				; Build an IRP to reset hardware mode
;
; NOTE - we must use EXE$ALONONPAGED to allocate the IRP because the other
;	routines reset the IPL to ASTDEL.
;
	BBS	#XM$V_ERR_FATAL,-	; Br if fatal error,
		CDB_L_DEVDEPEND(R4),10$ ;  ignore reset of mode
	MOVZWL	#IRP$C_LENGTH,R1	; Set length of IRP
	JSB	G^EXE$ALONONPAGED	; Try to allocate an IRP
	BLBS	R0,20$			; Okay if buffer allocated
10$:	RSB				; Else, too bad if we can't do it

20$:	MOVW	R1,IRP$W_SIZE(R2)	; Fill in the size field
	BSBB	BLD_IRP_CO		; Build a template IRP
	MOVAB	B^DELETE_BLOCK,IRP$L_PID(R3) ; Store return address from IOPOST
	MOVB	#XE_FC_V_STOP,IRP$B_XE_FUNC(R3)	; Make this look like a STOP
	RSB				; Return to queue request to DEUNA/DELUA

DELETE_BLOCK:				; Deallocate a data structure
	MOVL	R5,R0			; Get address of structure
	JMP	G^COM$DRVDEALMEM	; Deallocate the structure


	.SBTTL	BLD_STRT_IRP - Build a point-to-point startup IRP
;++
; BLD_STRT_IRP - Build a point-to-point startup IRP
;
; Functional description:
;
; This routine will build an IRP to perform a datalink startup with a
; remote system.
;
; Inputs:
;	R2 = IRP address
;	R4 = CDB address
;	R5 = UCB address
;
; Outputs:
;	R0,R1,R2,R3 are destroyed.
;--
BLD_STRT_IRP:				;% Build a startup IRP
;
; We will use the back part of the IRP to build the data message. The
; data message only contains the standard header plus one byte of ^XAA.
;
	ASSUME	IRP$C_XE_STD+17 LE IRP$C_LENGTH ;% 14 bytes of header +
					;%    2 bytes of count + msg type.
	BSBB	BLD_IRP			;% Build the IRP
	MOVAB	IRP$C_XE_STD(R3),R2	;% Point to data portion of IRP
	MOVQ	UCB$G_XE_DES(R5),-	;% Store destination address
		XBUF_G_DEST(R2)		;%
	MOVW	#XE_C_STPRO,XBUF_W_TYPE(R2) ;% Store protocol type
	MOVW	#1,XBUF_W_SIZE(R2)	;% Store message size
	MOVB	#^XAA,XBUF_W_SIZE+2(R2)	;% Transmit one start byte of data
	BBS	#UCB$V_XE_START,UCB$W_DEVSTS(R5),50$ ;% Br if start
;;&&	BBC	#UCB$V_XE_STACK,UCB$W_DEVSTS(R5),90$ ;% Exit if not stack
	MOVB	#^XAB,XBUF_W_SIZE+2(R2)	;% Transmit one stack byte of data
50$:	MOVAB	B^90$,IRP$L_PID(R3)	;% Store return address
	MOVB	#XE_FC_V_XMIT,IRP$B_XE_FUNC(R3) ;% Set function request
	ASSUME	XBUF_C_HEADER EQ XBUF_W_SIZE
	MOVW	#XBUF_C_HEADER+3,-	;% Set data size
		IRP$W_BCNT(R3)		;%
	MOVL	R2,IRP$L_XE_SYSBUF(R3)	;% Set buffer address
	INSQUE	(R3),@CDB_Q_XMTREQ+4(R4);% Insert transmit request
	BSBW	XMT_ALT_START		;% Startup transmit process
90$:	RSB				;% Return to caller


	.SBTTL	BLD_IRP - Build an IRP routine
	.SBTTL	BLD_IRP_CO - Build an IRP co-routine
;++
; BLD_IRP - Build an IRP routine
; BLD_IRP_CO - Build an IRP co-routine
;
; Functional description:
;
; This routine will build a simple IRP and allow the caller to fill in the
; function requested and then queue it to the DEUNA/DELUA.
;
; Inputs:
;	R2 = IRP address
;	R5 = UCB address
;
; Outputs:
;	R0-R3 are destroyed.
;	R4,R5 are preserved.
;--
BLD_IRP:				; Build an IRP
	MOVAQ	(R2)+,R3		; Save IRP address, skip to size field
	ASSUME	IRP$W_SIZE EQ 8
	ASSUME	IRP$B_TYPE EQ IRP$W_SIZE+2
	ASSUME	IRP$B_RMOD EQ IRP$B_TYPE+1
	TSTW	(R2)+			; Skip SIZE
	MOVW	#DYN$C_IRP,(R2)+	; Make it look like an IRP
	ASSUME	IRP$L_PID EQ IRP$B_RMOD+1
	ASSUME	IRP$L_AST EQ IRP$L_PID+4
	CLRQ	(R2)+			; Clear PID, AST
	ASSUME	IRP$L_ASTPRM EQ IRP$L_AST+4
	ASSUME	IRP$L_WIND EQ IRP$L_ASTPRM+4
	CLRQ	(R2)+			; Clear ASTPRM, WIND
	ASSUME	IRP$L_UCB EQ IRP$L_WIND+4
	MOVL	R5,(R2)+		; Store UCB address
	ASSUME	IRP$W_FUNC EQ IRP$L_UCB+4
	ASSUME	IRP$B_EFN EQ IRP$W_FUNC+2
	ASSUME	IRP$B_PRI EQ IRP$B_EFN+1
	ASSUME	IRP$L_IOSB EQ IRP$B_PRI+1
	CLRQ	(R2)+			; Clear FUNC, EFN, PRI, IOSB
	ASSUME	IRP$W_CHAN EQ IRP$L_IOSB+4
	ASSUME	IRP$W_STS EQ IRP$W_CHAN+2
	ASSUME	IRP$L_SVAPTE EQ IRP$W_STS+2
	CLRQ	(R2)+			; Clear CHAN, STS, SVAPTE
	ASSUME	IRP$W_BOFF EQ IRP$L_SVAPTE+4
	ASSUME	IRP$W_BCNT EQ IRP$W_BOFF+2
	ASSUME	IRP$L_BCNT EQ IRP$W_BCNT
	CLRQ	(R2)+			; Clear BOFF, BCNT
	RSB				; Return to caller

BLD_IRP_CO:				; Build an IRP - co-routine call
	BSBB	BLD_IRP			; First, build the IRP
	;
	; On return to caller
	;
	;	R3 = IRP address
	;
	JSB	@(SP)+			; Return to caller
	;
	; After call back:
	;
	;	R4 = CDB address
	;	R5 = UCB address
	;	R0-R2 may be destroyed
	;
	DSBINT	UCB$B_DIPL(R5)		; Sync access to device
	INSQUE	(R3),@CDB_Q_INPUT+4(R4)	; Insert at END of queue
	PUSHQ	R4			; Save CDB, UCB addresses
	BSBW	LOAD_PORT		; Load request and return to caller
	POPQ	R4			; Restore CDB, UCB addresses
	ENBINT				; Re-enable interrupts
	RSB				; Return to caller


	.SBTTL	CLEANUP_SHR - CLEANUP ALL I/O ON SHARE DATA STRUCTURE
	.SBTTL	DELETE_SHR - DELETE SHR DATA STRUCTURE
;++
; CLEANUP_SHR - CLEANUP ALL I/O ON SHARE DATA STRUCTURE
;
; This routine aborts all read request in progress and return all message
; buffers back to the CDB structure for re-use.
;
; Inputs:
;
;	R4 = CDB address
;	R5 = UCB address
;	R6 = SHR address
;
;	IPL = FIPL
;
; Outputs:
;
;	R0-R2 are destroyed.
;	All other registers are preserved.
;--
CLEANUP_SHR::				; Cleanup all I/O on SHR structure
	PUSHL	R3			; Save R3

	.IF DF	POINT
	PUSHL	R7			;% Save R7
;
; Complete all waiting transmit IRPs
;
3$:	MOVAB	UCB$Q_XE_XMTREQ(R5),R7	;% Get address of XMIT wait queue
	MOVL	(R7),R3			;% Travel queue
5$:	CMPL	R3,R7			;% At end of queue?
	BEQL	9$			;% Br if yes
	MOVL	CXB$L_T_IRP(R3),R0	;% Get IRP address
	BEQL	6$			;% Br if none, only one chan allowed
	CMPW	IRP$W_CHAN(R0),SHR_W_CHAN(R6) ;% Same as SHR chan?
	BNEQ	7$			;% Br if not, else
6$:	REMQUE	(R3),R3			;% Remove IRP from list
	BSBW	ABORT_PKT		;% Abort the I/O request
	BRB	3$			;% Look for more
7$:	MOVL	(R3),R3			;% Travel link
	BRB	5$			;% Check for end of queue
9$:	POPL	R7			;% Restore R7
	.ENDC

	ASSUME	SHR_C_QUEUES EQ 2
;
; Complete all IRPs for this structure
;
10$:	REMQUE	@SHR_Q_RCVREQ(R6),R3	; Get IRP
	BVS	20$			; Br if none
	BSBW	ABORT_PKT		; Abort the I/O request
	BRB	10$			; Get next IRP
;
; Deallocate all message blocks
;
20$:	REMQUE	@SHR_Q_RCVMSG(R6),R2	; Get message buffer
	BVS	30$			; Br if none
	ADDW	UCB$W_DEVBUFSIZ(R5),-	; Restore quota
		 UCB$W_XE_QUOTA(R5)	;
	BSBW	ADDRCVLIST		; Try to add to receiver list
	BRB	20$			; Loop
30$:	POPL	R3			; Restore R3
	RSB				; Return to caller

;++
; DELETE_SHR - DELETE SHARE DATA STRUCTURE
;
; This routine deallocates the SHR data structure to system pool.
;
; Inputs:
;
;	R5 = UCB address
;	R6 = SHR address
;
;	IPL = FIPL
;
; Outputs:
;
;	R0-R1 are destroyed.
;	All other registers are preserved.
;--
DELETE_SHR::				; Delete SHR data structure
	DECW	UCB$W_REFC(R5)		; One less user of the unit
	CMPL	R6,UCB$L_XE_DEFUSR(R5)	; Is this the default user?
	BEQL	30$			; Br if yes
	MOVAB	UCB$Q_XE_SHARE(R5),R1	; Get address of SHARE queue
	MOVL	(R1),R0			; Get address of next in queue
10$:	CMPL	R0,R1			; Back to front of list?
	BEQL	90$			; Br if none found
	CMPL	R6,R0			; Is this the one?
	BEQL	20$			; Br if yes
	MOVL	(R0),R0			; Else, get next in queue
	BRB	10$			; And try for match
20$:	REMQUE	(R0),R0			; Remove structure from list
	BRB	40$			; And delete the structure
30$:	CLRL	UCB$L_XE_DEFUSR(R5)	; No more default user
40$:	MOVZWL	SHR_L_PID(R6),R0	; Get PID SHR structure
	MOVL	G^SCH$GL_PCBVEC,R1	; Address PCB vector
	MOVL	(R1)[R0],R0		; Get PCB of owner
	CMPL	PCB$L_PID(R0),-
		SHR_L_PID(R6)		; Still there?
	BNEQ	60$			; If NEQ no
	MOVL	PCB$L_JIB(R0),R0	; Get JIB address
	MOVZWL	SHR_W_QUOTA(R6),R1	; Convert to longword
	ADDL	R1,JIB$L_BYTCNT(R0)	; Return byte count quota
	ADDL	R1,JIB$L_BYTLM(R0)	; ..and byte limit quota
	SUBW	R1,UCB$W_XE_QUOTA(R5)	; Decrease the current quota
	SUBW	R1,UCB$W_XE_TOTQUO(R5)	;  and the total quota
60$:	MOVL	R6,R0			; Copy SHR structure address
	JMP	G^COM$DRVDEALMEM	; Deallocate the structure

;
; Bug check on error
;
90$:	BUG_CHECK NOBUFPCKT,FATAL

	.SBTTL	CANCEL - CANCEL I/O ON UNIT
;++
; CANCEL - CANCEL I/O ON UNIT
;
; Functional description:
;
; This routine is used to cancel specific or all I/O pending on an XE unit.
;
; Inputs:
;
;	R2 = Channel index number
;	R4 = PCB address (or zero)
;	R5 = UCB address
;	R8 = Cancel reason code (CAN$C_DASSGN or CAN$C_CANCEL)
;
;
;	IPL = FIPL
;
; Outputs:
;
;	R3-R5 are preserved.
;	R0-R2 are destroyed.
;
;--

CANCEL::				; Cancel I/O
	PUSHR	#^M<R3,R4,R6,R7>	; Save registers
	BBC	#UCB$V_XE_SHARE,-	; Br if not a shared UCB
		 UCB$W_DEVSTS(R5),2$	;  perform regular $CANCEL
;
; Try to find SHR data structure
;
	BSBW	FIND_SHR		; Check PID and CHAN
	BNEQ	2$			; Br if NO MATCH, maybe last $DASSGN
;
;	Match found - clear inited bit and clean up all I/O on SHR data
;	structure.
;
;	We will Delete the SHR structure if this is a $DASSGN function
;	request. We will get this function when called from SYS$DASSGN
;	system service and so we will have to delete the SHR structure
;	and decrement the reference count. Note that the reference count
;	can never reach zero. Therefore, SYS$DASSGN will decrement the
;	reference count on exit and we will be called again. This time
;	there will be no match on the PID/CHAN and so the UCB will be
;	cleaned up and deleted.
;
	MOVL	R1,R6			; Copy SHR address
	MOVL	UCB$L_XE_CDB(R5),R4	; Get CDB address
	BSBW	CLEANUP_SHR		; Cleanup the SHR data structure

	ASSUME	CAN$C_DASSGN EQ 1
	DECL	R8			; Deassign request?
	BNEQ	10$			; Br if no - all done
	BSBW	DELETE_SHR		; Else, delete the SHR data stucture
					; And NOW perform like a NON-SHARED
					; unit.
;
; Non-shared unit - perform $CANCEL function.
;
2$:	TSTW	UCB$W_REFC(R5)		; Last reference?
	BNEQ	20$			; Br if no - do selective cancel
3$:	MOVL	UCB$L_XE_CDB(R5),R4	; Get CDB address
	BSBW	SHUTDOWN		; Shutdown entire unit
	BBS	#CDB_STS_V_INITED,-	; Br if DEUNA/DELUA is still inited
		CDB_B_STS(R4),5$	;
	MNEGL	#1,CDB_G_PHA(R4)	; Reset physical address
	MNEGW	#1,CDB_G_PHA+4(R4)	;	...
;
; When this is the last reference to the unit, reset the CPID of the UCB.
;
5$:	BISW	S^#UCB$M_ONLINE,-	; Set the UNIT to ONLINE
		UCB$W_STS(R5)		;
	TSTL	UCB$L_XE_CPID(R5)	; Did we save the Creator PID?
	BEQL	10$			; Br if not
	MOVL	UCB$L_XE_CPID(R5),UCB$L_CPID(R5) ; Else, restore Creator PID
	CLRL	UCB$L_XE_CPID(R5)	; Never again!!
10$:	POPR	#^M<R3,R4,R6,R7>	; Restore registers
	RSB
;
; Abort all associated receive packets on UCB queue
;
20$:	MOVL	4(SP),R4		; Restore PCB address to R4
	BBC	#UCB$V_ONLINE,-		; Br if not online
		 UCB$W_STS(R5),10$	;

	ASSUME	UCB$V_XE_INITED  EQ  0
	BLBC	UCB$W_DEVSTS(R5),10$	; Br if not inited
	MOVAB	UCB$Q_XE_RCVREQ(R5),R6	; Get address of receive queue
	BSBB	CHECKER			; Check packets on queue
;
; Abort all xmit requests on CDB queue
;
	MOVL	UCB$L_XE_CDB(R5),R7	; Get CDB address
	BBC	#CDB_STS_V_INITED,-	; Br if not inited
		CDB_B_STS(R7),10$	;
	DSBINT	UCB$B_DIPL(R5)		; Sync access to CDB
	MOVAB	CDB_Q_QUEUES(R7),R7	; Get start of queues
	MOVZBL	S^#CDB_C_ABORTS,R8	; Get number of queues we can abort on
30$:	MOVL	R7,R6			; Set address of next queue
	BSBB	CXB_CHECKER		; Check CXBs on this queue
	ADDL	#8,R7			; Skip to next queue
	SOBGTR	R8,30$			; Loop thru queues
	ENBINT				; Enable interrupts
	BRB	10$			; Exit from cancel
;
; Subroutine to scan queue for match on all packets
;
CHECKER:
	MOVL	(R6),R3			; Get next entry
10$:	CMPL	R3,R6			; End of list?
	BEQL	30$			; Br if yes
	BSBB	CHECKPKT		; Cancel if appropriate match
	BNEQ	20$			; Br if no match
	REMQUE	(R3),R3			; Remove from list
	BSBW	ABORT_PKT		; Complete the I/O request
	BRB	CHECKER			; Look for more
20$:	MOVL	(R3),R3			; Travel link
	BRB	10$			; Look for more			
30$:	RSB				; Return to caller
;
; Subroutine to check for specific cancel
;
CHECKPKT:
	TSTL	IRP$L_PID(R3)		; Is this an Internal IRP?
	BLSS	30$			; Br if yes
	BNEQ	10$			; Br if valid PID

	TSTL	R4			; Valid PCB?
	BNEQ	50$			; Br if yes, no match
	BRB	40$			; Else, test CHAN

10$:	CMPL	PCB$L_PID(R4),IRP$L_PID(R3) ; PID match?
	BNEQ	50$			; Br if no
	BRB	40$			; Try CHAN match

30$:	CMPL	PCB$L_PID(R4),UCB$L_XE_PID(R5) ; IS this the starter's PID?
	BNEQ	50$			; Br if no
40$:	CMPW	R2,IRP$W_CHAN(R3)	; Channel match?
50$:	RSB				; Return to caller

CXB_CHECKER:
	MOVL	(R6),R3			; Get next entry
10$:	CMPL	R3,R6			; End of list?
	BEQL	30$			; Br if yes
	BSBB	CXB_CHECKPKT		; Cancel if appropriate match
	BNEQ	20$			; Br if no match
	REMQUE	(R3),R3			; Remove from CXB list
	MOVL	CXB$L_T_IRP(R3),R0	; Get IRP address
	BEQL	16$			; Br if not, FAST interface
	MOVL	R0,R3			; Copy IRP address
	BSBW	ABORT_PKT		; Complete the I/O request
	BRB	CXB_CHECKER		; Look for more
16$:	PUSHL	R4			; Else, save R4
	MOVL	UCB$L_XE_FFI(R5),R4	; Get FFI block address
	MOVZWL	#SS$_ABORT,R0		; Set status return
	JSB	@FFI$L_XMIT_DONE(R4)	; Complete the XMIT CXB
	POPL	R4			; Restore R4
	BRB	CXB_CHECKER		; Look for more
20$:	MOVL	(R3),R3			; Travel link
	BRB	10$			; Look for more			
30$:	RSB				; Return to caller
;
; Subroutine to check for specific cancel
;
CXB_CHECKPKT:
	MOVL	CXB$L_T_IRP(R3),R0	; Get IRP address
	BEQL	80$			; Br if no IRP
	TSTL	IRP$L_PID(R0)		; Is this an Internal IRP?
	BLSS	30$			; Br if yes
	BNEQ	10$			; Br if valid PID

	TSTL	R4			; Valid PCB?
	BNEQ	50$			; Br if yes, no match
	BRB	40$			; Else, test CHAN

10$:	CMPL	PCB$L_PID(R4),IRP$L_PID(R0) ; PID match?
	BNEQ	50$			; Br if no
	BRB	40$			; Try CHAN match

30$:	CMPL	PCB$L_PID(R4),UCB$L_XE_PID(R5) ; IS this the starter's PID?
	BNEQ	50$			; Br if no
40$:	CMPW	R2,IRP$W_CHAN(R0)	; Channel match?
50$:	RSB				; Return to caller

	; No IRP with CXB - FFI user

80$:	TSTL	R4			; No PCB?
	BEQL	50$			; Br if true - abort I/O
	MOVL	R3,R3			; Else, return Z-BIT clear
	RSB				; Return to caller

	.SBTTL	 SUBROUTINES TO FIND SHR DATA STRUCTURE GIVEN PCB AND CHAN
;+
; Subroutine to find SHR data structure for user
;
; Inputs:
;	R2 = Channel number
;	R4 = PCB address (or zero)
;	R5 = UCB address
;
; Outputs:
;	R1 = Address if SHR data structure if match
;	R0 is destroyed.
;	Z-Bit set then match.
;	Z-Bit clear then no match.
;-

FIND_SHR:				; Try to find shared user
	MOVL	UCB$L_XE_DEFUSR(R5),R1	; Get address of default user
	BEQL	10$			; Br if no default user
	BSBB	90$			; Check for match
	BEQL	40$			; Br if match
10$:	MOVAB	UCB$Q_XE_SHARE(R5),R0	; Save address of listhead
	MOVL	R0,R1			; Copy listhead address
	ASSUME	SHR_L_QFL EQ 0
20$:	MOVL	(R1),R1			; Get next in list
	CMPL	R1,R0			; Back to start of list?
	BEQL	30$			; Br if yes - no pid/chan match
	BSBB	90$			; Check for match
	BNEQ	20$			; Br if none
	BRB	40$			; Return in success
30$:	MOVL	R0,R0			; Return match failure
40$:	RSB

;+
; Subroutine to check if PID and SHR data base match up
;
; Inputs:
;	R1 = SHR address
;	R2 = Channel number
;	R4 = PCB address (or zero)
;
; Outputs:
;	Z-Bit set then match.
;	Z-Bit clear then no match.
;-

90$:					; Check for match with SHR data base
	TSTL	R4			; Valid PCB address?
	BNEQ	100$			; Br if yes
	TSTL	SHR_L_PID(R1)		; Zero PID?
	BNEQ	140$			; Br if not
	BRB	110$			; Try for CHAN
100$:	CMPL	PCB$L_PID(R4),SHR_L_PID(R1) ; PIDs match?
	BNEQ	140$			; Br if no - try for next
110$:	CMPW	R2,SHR_W_CHAN(R1)	; Channels match?
140$:	RSB				; Return to caller

	.SBTTL	FIND_POINT_UCB  - Find the point to point UCB
;++
; FIND_POINT_UCB - Find the point-to-point UCB
;
; Functional description:
;
; This routine is called to find the point-to-point UCB for some received
; message. This is only needed when the protocol is in the startup state.
;
; Inputs:
;
;	R1 = Protocol type (startup)
;	R2 = MSG buffer address
;	R4 = CDB address
;
;
;	IPL = FIPL
;
; Outputs:
;
;	R0 = Status return for request
;	All other registers are preserved
;--

FIND_POINT_UCB:					;% Find the point-to-point UCB
	PUSHR	#^M<R1,R2,R3,R5,R6>		;% Save registers
	CLRL	R0				;% Assume failure
	CMPW	#1,CXB$W_R_SIZE(R2)		;% Is buffer the right size?
	BNEQ	99$				;% Br if not!
	CMPB	#^XAA,CXB$W_R_SIZE+2(R2)	;% Is first byte start byte?
	BEQL	10$				;% Br if yes
	CMPB	#^XAB,CXB$W_R_SIZE+2(R2)	;% Is first byte stack byte?
	BNEQ	90$				;% Br if not
10$:	MOVL	CDB_L_UCB0(R4),R5		;% Get UCB address of unit 0
20$:	MOVL	UCB$L_LINK(R5),R5		;% Get address of next UCB
	BEQL	90$				;% Br if end of list
	ASSUME	UCB$V_XE_INITED EQ 0
	BLBC	UCB$W_DEVSTS(R5),20$		;% Br if not inited
	CMPB	#NMA$C_LINPR_POI,-		;% Is this a point-to-point user?
		UCB$B_XE_PRO(R5)		;%
	BNEQ	20$				;% Br if not
	CMPL	UCB$G_XE_DES(R5),-		;% Does the destination match?
		CXB$G_R_SRC(R2)			;%
	BNEQ	20$				;% Br if not
	CMPW	UCB$G_XE_DES+4(R5),-		;% Still match?
		CXB$G_R_SRC+4(R2)		;%
	BNEQ	20$				;% Br if not
	CMPB	#^XAB,CXB$W_R_SIZE+2(R2)	;% Is first byte stack byte?
	BNEQ	40$				;% Br if no
	BBSC	#UCB$V_XE_START,UCB$W_DEVSTS(R5),30$ ;% Clear Start state
	BBCC	#UCB$V_XE_STACK,UCB$W_DEVSTS(R5),60$ ;% We were in RUN, ignore
30$:	MOVL	UCB$L_XE_STIRP(R5),R2		;% Get start IRP
	BSBW	BLD_STRT_IRP			;% Send stack!
	BRB	60$				;% Then send data
40$:	CMPB	#^XAA,CXB$W_R_SIZE+2(R2)	;% Is first byte start byte?
99$:	BNEQ	90$				;% Br if not, ignore it
	BITW	#UCB$M_XE_START!UCB$M_XE_STACK,- ;% Are we in startup states?
		UCB$W_DEVSTS(R5)
	BEQL	120$				;% Br if not, start recvd in RUN
	CLRBIT	#UCB$V_XE_START,UCB$W_DEVSTS(R5);% Clear starting bit
	MOVL	UCB$L_XE_STIRP(R5),R2		;% Get start IRP
	BSBW	BLD_STRT_IRP			;% Send stack!
	BRB	80$				;% Wait for stack
60$:	REMQUE	@UCB$Q_XE_XMTREQ(R5),R3		;% Get transmit IRPs
	BVS	70$				;% Br if no more
	INSQUE	(R3),@CDB_Q_XMTREQ+4(R4)	;% Insert IRPs onto xmit queue
	BRB	60$				;% Look for more
70$:	BSBW	XMT_ALT_START			;% Startup the xmit process
80$:	MOVZBL	#1,R0				;% Return success

90$:	POPR	#^M<R1,R2,R3,R5,R6>		;% Restore registers
	RSB					;% Return to caller

;
; Start received in run mode
;
120$:	CMPL	UCB$Q_XE_SHARE(R5),-		;% Is limited queue empty?
		@UCB$Q_XE_SHARE(R5)		;%
	BEQL	90$				;% Br if yes, no IRPs
	CLRBIT	#XM$V_STS_ACTIVE,UCB$L_DEVDEPEND(R5) ;% Clear active bit
	SETBIT	#XM$V_ERR_START,UCB$L_DEVDEPEND(R5) ;% Indicate cause of error
	BICW	#UCB$M_XE_START!UCB$M_XE_STACK,-;% Clear start and stack flags
		UCB$W_DEVSTS(R5)		;%
	CLRBIT	#UCB$V_XE_RUN,UCB$W_DEVSTS(R5)	;% Clear the RUN flag
	MOVL	UCB$Q_XE_SHARE(R5),R6		;% Get address of share structure
	BSBW	CLEANUP_SHR			;% Cleanup all pending I/O
	BRB	90$				;% Exit
	

	.SBTTL	ADD_MULTI - ADD UP ALL THE MULTICAST ADDRESSES
;++
; ADD_MULTI - ADD UP ALL THE MULTICAST ADDRESSES
;
; Functional description:
;
; This routine is called to combine all the per protocol type multicast
; addresses into a single list in the CDB. If the sum of all multicast
; addresses is greater than the DEUNA/DELUA can manage, then an error is 
; returned.
;
; Inputs:
;
;	R5 = UCB address
;
;
;	IPL = FIPL
;
; Outputs:
;
;	R0 = Status return for request
;	R1,R2 are destroyed
;	R3-R5 are preserved
;
; Implicit outputs:
;
;	CDB_B_MLTTBL = Number of multicast addresses in CDB_G_MLTTBL
;	CDB_G_MLTTBL = New multicast address list
;--

ADD_MULTI:				; Add up all the multicast addresses
	PUSHR	#^M<R3,R4,R6,R7>	; Save registers
	MOVL	UCB$L_XE_CDB(R5),R4	; Get CDB address
	CLRB	CDB_B_MLTTBL(R4)	; Reset number of entries
	PUSHQ	R4			; Save CDB and UCB addresses
	MOVC5	#0,CDB_G_MLTTBL(R4),#0,- ; Zero the structure
		#6*MAX_C_MLT,CDB_G_MLTTBL(R4) ;
	POPQ	R4			; Restore CDB and UCB addresses
	MOVZBL	#MAX_C_MLT+1,R3		; Error if 1 more multicast address
					;  than we can handle
	MNEGL	#1,R0			; Assume success
	MOVAB	CDB_G_MLTTBL(R4),R6	; Get address of Multicast table
	MOVL	UCB$L_DDB(R5),R7	; Get DDB address
	MOVL	DDB$L_UCB(R7),R7	; Get 1st UCB address
10$:	MOVL	UCB$L_LINK(R7),R7	; Get next UCB in list
	BEQL	50$			; Br if no more UCB's

	ASSUME	UCB$V_XE_INITED  EQ  0
	BLBC	UCB$W_DEVSTS(R5),10$	; Br if not inited
	MOVAB	UCB$G_XE_MULTI(R7),R2	; Get address of Multicast list
	MOVZBL	UCB$B_XE_MULTI(R7),R1	; Set number addresses for UCB
20$:	TSTL	(R2)			; Is this field unused?
	BNEQ	25$			; Br if no
	TSTW	4(R2)			; Really?
	BEQL	30$			; Yes - skip it
25$:	DECB	R3			; One less available slot in CDB
	BEQL	40$			; Br if none left - error
	MOVL	(R2),(R6)+		; Else, insert next address
	MOVW	4(R2),(R6)+		;	...
	INCB	CDB_B_MLTTBL(R4)	; Count one more in list
	CMPB	CDB_B_MLTTBL(R4),-	; Is there enough room?
		 #MAX_C_MLT		;	...
	BGTRU	40$			; Br if no - error
30$:	ADDL	#6,R2			; Skip to next entry
	SOBGTR	R1,20$			; Br if more
	BRB	10$			; Else, skip to next UCB

40$:	CLRL	R0			; Return failure
50$:	POPR	#^M<R3,R4,R6,R7>	; Restore registers
	RSB

	.SBTTL	MOVE_MULTI - COPY THE MULTICAST ADDRESS LIST
;++
; MOVE_MULTI - COPY THE MULTICAST ADDRESS LIST
;
; Functional description:
;
; This routine is called to copy the multicast address list from the
; generation table to the actual list.
;
; Inputs:
;
;	R4 = CDB address
;
; Outputs:
;
;	All registers are preserved.
;
; Implicit outputs:
;
;	CDB_B_MULTI = Number of multicast addresses in CDB_G_MUDB
;	CDB_G_MUDB = New multicast address list
;--

MOVE_MULTI:				; Move the multicast address list
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	; Save registers
	MOVC3	#MAX_C_MLT*6,CDB_G_MLTTBL(R4),CDB_G_MUDB(R4) ; Copy list
	POPR	#^M<R0,R1,R2,R3,R4,R5>	; Restore registers
	MOVB	CDB_B_MLTTBL(R4),CDB_B_MULTI(R4) ; Set number of entries
	RSB

	.SBTTL	ROUTINES TO SAVE/RESTORE UCB'S MULTICAST ADDRESS LIST
;++
; ROUTINES TO SAVE/RESTORE UCB'S MULTICAST ADDRESS LIST
;
; Functional description:
;
; These routines are called to save or restore the multicast address list
; in the UCB.
;
; Inputs:
;
;	R5 = UCB address
;
; Outputs:
;
;	All registers are preserved.
;--

SAV_MULTI:				; Save multicast address list
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	; Save registers
	MOVC3	#6*MAX_C_MLT,UCB$G_XE_MULTI(R5),- ; Save multicast addresses
		UCB$G_XE_MLTTBL(R5)	;	...
	POPR	#^M<R0,R1,R2,R3,R4,R5>	; Restore registers
	MOVB	UCB$B_XE_MULTI(R5),-	; Save count of multicast addresses
		UCB$B_XE_MLTTBL(R5)	;	...
	RSB				; Return to caller

RES_MULTI:				; Restore multicast address list
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	; Save registers
	MOVC3	#6*MAX_C_MLT,UCB$G_XE_MLTTBL(R5),- ; Restore multicast addresses
		UCB$G_XE_MULTI(R5)	;	...
	POPR	#^M<R0,R1,R2,R3,R4,R5>	; Restore registers
	MOVB	UCB$B_XE_MLTTBL(R5),-	; Restore count of multicast addresses
		UCB$B_XE_MULTI(R5)	;	...
	RSB				; Return to caller

	.SBTTL	VALIDATE_P2 - VALIDATE P2 BUFFER PARAMETERS
 
;++
; VALIDATE_P2 - Validate P2 buffer parameters
;
; This routine is called to validate the P2 buffer parameters. The parameters
; are checked against a parameter table which verifies that the minimum value
; and maximum value is not violated, and that invalid status flags are not set.
; If the parameter is a string, then the string must not exceed the maximum
; string count for this parameter.
;
; Inputs:
;
;	R2 = Address of verification table
;	R3 = IRP address
;	R5 = UCB address
;
;
; Outputs:
;
;	R0 = Status return for request
;
; If no error:
;	R1 = Address of parameter verification table
; If error:
;	R1 = Bad parameter value
;
;	All other registers are preserved.
;
;--
 
VALIDATE_P2::				; Validate P2 buffer parameters
	PUSHR	#^M<R2,R3,R4,R6,R7,R8,R9> ; Save registers
	MOVL	IRP$L_SVAPTE(R3),R6	; Get system P2 buffer address
	BNEQ	20$			; Br if a system buffer
10$:	BRW	150$			; Else, leave

20$:	MOVL	UCB$L_XE_CDB(R5),R4	; Get CDB address
	MOVL	P2B_L_POINTER(R6),R6	; Point to start of P2 data
	MOVZWL	IRP$W_BCNT(R3),R8	; Get size of P2 buffer
;
; Loop to check next parameter in P2 buffer
;
30$:	SUBL	#2,R8			; Can we get another parameter?
	BLSS	10$			; Br if no - all done
	MOVZWL	(R6)+,R1		; Get parameter type from P2
;
; *** NOTE - R2 MUST be the very first item on the top of the stack
;
	MOVL	(SP),R7			; Get verification table address
;
; Loop to check P2 buffer parameter to Line parameter table
;
	ASSUME	PRM_W_TYPE EQ 0
40$:	MOVW	(R7)+,R0		; Get parameter type code
	BNEQ	45$			; Br if NOT end of verify table
43$:	BRW	170$			; Else exit in error

45$:	ASSUME	PRM_B_FLAG EQ PRM_W_TYPE+2
	MOVZBL	(R7)+,R9		; Get flags byte
	BICW	#^C<PRM_TYP_M_CODE>,R0	; Clear all but type code
	CMPW	R1,R0			; Parameters match?
	BEQL	50$			; Br if yes
	ADDL	#2,R7			; Skip offset word
	SKIP	PRM_FLG_V_MIN,R9,R7	; Skip minimum value
	SKIP	PRM_FLG_V_MAX,R9,R7	; Skip maximum value
	SKIP	PRM_FLG_V_INVALID,R9,R7	; Skip invalid flags
	BRB	40$			; Try next parameter
;
; Match found - nullify if same value & check min,max,valid,invalid
;
50$:	MOVW	(R7)+,R0		; Get offset + width
	EXTZV	#PRM_OFF_V_WIDTH,-	; Get width only
		#PRM_OFF_S_WIDTH,R0,R2	;	...
	EXTZV	#PRM_OFF_V_VALUE,-	; Get offset only
		#PRM_OFF_S_VALUE,R0,R0	;	...
	BBS	#PRM_FLG_V_CDB,R9,55$	; Br if CDB datum
	ADDL	R5,R0			; Compute offset in UCB
	BRB	57$			; Continue
55$:	ADDL	R4,R0			; Compute offset in CDB
57$:	ASSUME	PRM_B_FLAG EQ PRM_W_TYPE+2
	BBS	#PRM_TYP_V_STRING,-5(R7),95$ ; Br if string parameter
	SUBL	#4,R8			; Must be longword value
	BLSS	43$			; Br if error
	MOVL	(R6)+,R3		; Get parameter value
	CASE	R2,TYPE=B,LIMIT=#1,<-	; Br to handler
		60$,-			;   Byte value
		70$,-			;   Word value
		80$>			;   Longword value
;
; Byte value in structure
;
60$:	CMPB	R3,(R0)			; Is this the same?
	BRB	90$			; Check result
;
; Word value
;
70$:	CMPW	R3,(R0)			; Is this the same?
	BRB	90$			; Check result
;
; Longword value
;
80$:	CMPL	R3,(R0)			; Is this the same?
90$:	BNEQ	100$			; Br if no - continue checks
	CMPW	R1,#NMA$C_PCLI_PTY	; Is this the protocol type?
	BEQL	91$			; Br if yes - always store this
	CLRW	-6(R6)			; Nullify the parameter code
91$:	BRW	145$			; Try next parameter - skip checks
93$:	BRW	170$			; LONNGGG Branch to 170$
;
; String value
;
95$:	SUBL	#2,R8			; Can we fetch string length?
	BLSS	93$			; Br if no - error
	MOVZWL	(R6)+,R3		; Get string length
	SUBL	R3,R8			; Is there room for string?
	BLSS	93$			; Br if no - error
	CMPW	R3,R2			; Is the string too long?
	BGTRU	93$			; Br if yes - error
	ADDL	R3,R6			; Skip past string
	CMPW	#NMA$C_PCLI_DES,R1	; Is this the destination address?
	BEQL	96$			; Br if yes
	CMPW	#NMA$C_PCLI_PHA,R1	; Is this the physical address?
	BNEQ	97$			; Br if not
96$:	BSBW	VALID_PHYAD		; Validate the physical address
	BLBC	R0,93$			; Br if error in physical address
	BRW	145$			; Else, continue checking
97$:	CMPW	#NMA$C_PCLI_MCA,R1	; Is this the multicast address list?
	BNEQ	130$			; Br if no - okay
	BSBW	VALID_MULTI		; Validate the multicast address list
	BLBC	R0,93$			; Br if error
	DSBINT	UCB$B_FIPL(R5)		; Sync access to UCB
	BSBW	SAV_MULTI		; Save the multicast addresses
	PUSHR	#^M<R6,R9>		; Save registers
	SUBL	R3,R6			; Backup pointer to start of list
	MOVL	R3,R9			; Setup string count in R9
	BSBW	SET_MULTI		; See if we can set new addresses
					; R0 = return status
	POPR	#^M<R6,R9>		; Restore registers
	BSBW	RES_MULTI		; Restore the multicast list
	ENBINT				; Restore IPL
	BLBC	R0,170$			; Br if error
	BRB	130$			; Check if state okay

100$:	BBC	#PRM_FLG_V_MIN,R9,110$	; Br if no minimum value
	CMPW	R3,(R7)+		; Is the value too small?
	BLSSU	170$			; Br if yes - error
110$:	BBC	#PRM_FLG_V_MAX,R9,130$	; Br if no maximum value
	CMPW	R3,(R7)+		; Is the value too big?
	BGTRU	170$			; Br if yes - error
130$:	BBC	#PRM_FLG_V_INVALID,R9,145$ ; Br if no invalid flags
	MOVW	(R7)+,R2		; Get invalid flags
	BBS	#PRM_FLG_V_CDB,R9,135$	; Br if CDB datum
	BITW	R2,UCB$W_DEVSTS(R5)	; Check UCB invalid bits
	BRB	137$			; Continue
135$:	TSTL	R4			; Is CDB present?
	BEQL	140$			; Br if no - okay
	BITB	R2,CDB_B_STS(R4)	; Check CDB invalid bits
137$:	BNEQ	170$			; Br on error

140$:	MOVZBL	UCB$B_TYPE(R5),R0	; Retrieve device type
	$DISPATCH	R0,TYPE=B,-	; Dispatch based upon device type
	< -
		<DT$_DEUNA	141$>,-	; DEUNA - don't allow NMA$C_PCLI_ILP
		<DT$_DELUA	143$>,-	; DELUA - don't allow NMA$C_PCLI_EKO
	>

141$:	CMPW	R1,#NMA$C_PCLI_ILP	; Is this the ILP Line Parameter
	BEQL	170$			; Return bad parameter if so
	BRB	145$			; Else see if there are more parameters

143$:	CMPW	R1,#NMA$C_PCLI_EKO	; Is this the EKO Line Parameter
	BEQL	170$			; Return bad parameter if so
145$:	BRW	30$			; Loop if more parameters
 
150$:	MOVZBL	S^#SS$_NORMAL,R0	; Set success return
	BRB	180$			; And return
 
170$:	MOVZBL	S^#SS$_BADPARAM,R0	; Set error return
180$:	POPR	#^M<R2,R3,R4,R6,R7,R8,R9> ; Restore registers
	RSB				; Return to caller

	.SBTTL	CHANGE_PARAM - UPDATE UCB/CDB BASED ON P2 BUFFER PARAMETERS
 
;++
; CHANGE_PARAM - Update UCB/CDB with P2 buffer parameters
;
; This routine is called to update the UCB/CDB with the P2 buffer parameters.
; The parameters are stored in the appropriate cells of the UCB/CDB.
; This routine can only modify the LINE PARAMETERS.
;
; Inputs:
;
;	R2 = Address of verification table
;	R3 = IRP address
;	R5 = UCB address
;
;	IPL = FIPL
;
; Outputs:
;
;	R0 = destroyed.
;	All other registers are preserved.
;
;--
 
CHANGE_PARAM:				; Change the UCB/CDB parameters
	PUSHR	#^M<R1,R2,R3,R4,R6,R7,R8,R9,R10> ; Save registers
	MOVL	R2,R10			; Save table address
	MOVL	IRP$L_SVAPTE(R3),R6	; Get system P2 buffer address
	BNEQ	5$			; Br if system buffer
3$:	BRW	120$			; Else, return

5$:	MOVL	UCB$L_XE_CDB(R5),R4	; Get CDB address
	MOVL	P2B_L_POINTER(R6),R6	; Point to start of data
	MOVZWL	IRP$W_BCNT(R3),R8	; Get size of P2 buffer
;
; Loop to get next parameter from P2 buffer
;
10$:	SUBL	#2,R8			; Try to get next parameter
	BLSS	3$			; Br if not there
	MOVZWL	(R6)+,R0		; Get parameter type from P2
	BEQL	90$			; Br if null value parameter
	MOVL	R10,R7			; Get verification table address
	CMPW	R0,#NMA$C_PCLI_PTY	; Is this the protocol type?
	BNEQ	20$			; Br if not
	BISW	#UCB$M_XE_PROTYP,-	; Indicate that protocol type specified
		UCB$W_DEVSTS(R5)	;
;
; Loop to store buffer parameter in UCB/CDB
;
	ASSUME	PRM_W_TYPE EQ 0
20$:	MOVZWL	(R7)+,R1		; Get parameter type code
	BEQL	90$			; Br if end of verify table
	BICW	#^C<PRM_TYP_M_CODE>,R1	; Clear all but type code
	ASSUME	PRM_B_FLAG EQ PRM_W_TYPE+2
	MOVZBL	(R7)+,R9		; Get flags byte
	CMPW	R0,R1			; Parameters match?
	BEQL	30$			; Br if yes
	ADDL	#2,R7			; Skip offset word
	SKIP	PRM_FLG_V_MIN,R9,R7	; Skip minimum value
	SKIP	PRM_FLG_V_MAX,R9,R7	; Skip maximum value
	SKIP	PRM_FLG_V_INVALID,R9,R7	; Skip invalid flags
	BRB	20$			; Try next parameter
;
; Match found - nullify if same value & check min,max,valid,invalid
;
30$:	MOVW	(R7)+,R1		; Get offset + width
	EXTZV	#PRM_OFF_V_WIDTH,-	; Get width only
		#PRM_OFF_S_WIDTH,R1,R2	;	...
	EXTZV	#PRM_OFF_V_VALUE,-	; Get offset only
		#PRM_OFF_S_VALUE,R1,R1	;	...
	BBS	#PRM_FLG_V_CDB,R9,40$	; Br if CDB datum
	ADDL	R5,R1			; Compute offset in UCB
	BRB	50$			; Continue
40$:	ADDL	R4,R1			; Compute offset in CDB
50$:	ASSUME	PRM_B_FLAG EQ PRM_W_TYPE+2
	BBS	#PRM_TYP_V_STRING,-5(R7),100$ ; Br if string data
	SUBL	#4,R8			; Can we get value?
	BLSS	120$			; Br if no - exit
	MOVL	(R6)+,R3		; Get parameter value
	CASE	R2,TYPE=B,LIMIT=#1,<-	; Br to handler
		60$,-			;   Byte value
		70$,-			;   Word value
		80$>			;   Longword value
;
; Byte, word, longword value in structure
;
60$:	MOVB	R3,(R1)			; Store byte value
65$:	BRW	10$			; Check remainder
70$:	MOVW	R3,(R1)			; Store word value
	BRW	10$			; Check remainder
80$:	MOVL	R5,(R1)			; Store longword value
	BRW	10$			; See if more left in P2 buffer
;
; Unknown or invalidated parameter
;
90$:	ADDL	#4,R6			; Skip value parameter
	SUBL	#4,R8			; Assume a value parameter
	BGTR	65$			; Br if more
	BRB	120$			; Else, all done
;
; String parameter in structure
;
100$:	SUBL	#2,R8			; Can we get string?
	BLSS	120$			; Br if no - exit
	MOVZWL	(R6)+,R9		; Get string length
	SUBL	R9,R8			; Can we read entire string?
	BLSS	120$			; Br if no - exit
	CMPW	#NMA$C_PCLI_DES,R0	; Is this the destination address?
	BNEQ	101$			; Br if no
	BSBW	SET_DESAD		; Else, set new destination address
	BRB	110$			; Continue
101$:	CMPW	#NMA$C_PCLI_PHA,R0	; Is this the physical address?
	BNEQ	103$			; Br if no
	BSBW	SET_PHYAD		; Else set new physical address
	BRB	110$			; Continue
103$:	CMPW	#NMA$C_PCLI_MCA,R0	; Is this the multicast address list?
	BNEQ	105$			; Br if no
	BSBW	SET_MULTI		; Else, set up new UCB multicast list
	BRB	110$			; Continue
105$:	PUSHR	#^M<R1,R2,R3,R4,R5>	; Save registers
	MOVC3	R9,(R6),(R1)		; Store string
	POPR	#^M<R1,R2,R3,R4,R5>	; Restore registers
110$:	ADDL	R9,R6			; Point past the string in P2 buffer
	BRW	10$			; Try for more in P2 buffer

120$:	POPR	#^M<R1,R2,R3,R4,R6,R7,R8,R9,R10> ; Restore registers
	RSB				; Return to caller

	.SBTTL	RETURN_P2,  Return UCB/CDB buffer parameters
 
;++
; RETURN_P2 - Return P2 buffer parameters
;
; This routine is called to return the UCB/CDB buffer parameters.
;
; Inputs:
;
;	R3 = IRP address
;	R5 = UCB address
;
; Implicit inputs:
;
;	IRP$L_XE_P2BUF(R3) = User P2 buffer address
;	IRP$W_XE_USERSIZ(R3) = User P2 buffer size
;
; Outputs:
;
;	R0 = Size of buffer returned
;	All other registers are preserved.
;
;--
 
RETURN_P2::				; Return P2 buffer parameters
	PUSHR	#^M<R1,R2,R3,R4,R6,R7,R8,R9> ; Save registers
	CLRL	R0			; Assume no P2 buffer given
	MOVL	IRP$L_XE_P2BUF(R3),R6	; Get user P2 buffer address
	BNEQ	5$			; Br if given
	BRW	70$			; Else, return

5$:	MOVL	UCB$L_XE_CDB(R5),R4	; Get CDB address
	MOVZWL	IRP$W_XE_USERSIZ(R3),R8	; Get size of user buffer
	PUSHL	R6			; Save start of data address
	PUSHL	R3			; Save IRP address
	MOVAB	LINE_PARAM,R1		; Get address of verification talbe
;
; Loop to return next parameter
;
	ASSUME	PRM_W_TYPE EQ 0
10$:	MOVW	(R1)+,R7		; Get parameter type code
	BNEQ	11$			; Br if end of verify table
	BRW	65$			; ...

11$:	BICW3	#^C<PRM_TYP_M_CODE>,R7,R9 ; Get only the type code
	MOVZBL	(R1)+,R3		; Get flags byte
	MOVW	(R1)+,R0		; Get offset + width
;
; We will only return NMA$C_PCLI_DES to the SHARED-LIMITED users.
;
	CMPW	#NMA$C_PCLI_DES,R9	; Is this a point-to-point parameter?
	BNEQ	13$			; Br if not
	CMPB	#NMA$C_ACC_LIM,UCB$B_XE_ACC(R5) ; Is this a SHARED-LIMITED user?
	BNEQ	50$			; Br if not, else return parameter
13$:	EXTZV	#PRM_OFF_V_WIDTH,-	; Get width only
		#PRM_OFF_S_WIDTH,R0,R2	;	...
	EXTZV	#PRM_OFF_V_VALUE,-	; Get offset only
		#PRM_OFF_S_VALUE,R0,R0	;	...
	BBS	#PRM_FLG_V_CDB,R3,15$	; Br if CDB datum
	ADDL	R5,R0			; Compute offset in UCB
	BRB	17$			; Continue
15$:	TSTL	R4			; Is CDB given?
	BEQL	50$			; Br if no
	ADDL	R4,R0			; Compute offset in CDB
17$:	SUBL	#2,R8			; Any room left in buffer?
	BLSS	60$			; Br if no - all done
	MOVW	R7,(R6)+		; Return parameter
	BBS	#PRM_TYP_V_STRING,-5(R1),55$ ; Br if string parameter
	SUBL	#4,R8			; Any room left?
	BLSS	60$			; Br if no - all done
	CASE	R2,TYPE=B,LIMIT=#1,<-	; Br to handler
		20$,-			;   Byte value
		30$,-			;   Word value
		40$>			;   Longword value
;
; Byte, word, longword value in structure
;
20$:	MOVZBL	(R0),(R6)+		; Store byte value
	BRB	50$			; 
30$:	MOVZWL	(R0),(R6)+		; Store word value
	BRB	50$			;
40$:	MOVL	(R0),(R6)+		; Store longword value
50$:	SKIP	PRM_FLG_V_MIN,R3,R1	; Skip minimum value
	SKIP	PRM_FLG_V_MAX,R3,R1	; Skip maximum value
	SKIP	PRM_FLG_V_INVALID,R3,R1	; Skip invalid flags
	BRB	10$			; Try for more parameters
;
; String value in structure
;
55$:	CMPW	#NMA$C_PCLI_MCA,R9	; Is this the multicast address list?
	BNEQ	57$			; Br if no
	BSBW	RETURN_MULTI		; Else, return multicast address list
	BRB	50$			; Try for more parameters
57$:	SUBL	#8,R8			; Any room left?
	BLSS	60$			; Br if no - all done
	MOVZBW	#6,(R6)+		; Store string size
	MOVL	(R0)+,(R6)+		; Move data
	MOVW	(R0)+,(R6)+		;	...
	BRB	50$			; Try for more parameters

60$:	MOVL	(SP),R3			; Get IRP address
	MOVW	#SS$_BUFFEROVF,IRP$W_XE_STATUS(R3) ; Return error status
65$:	POPL	R3			; Pop stack
	SUBL3	(SP)+,R6,R0		; Return size of parameters
70$:	POPR	#^M<R1,R2,R3,R4,R6,R7,R8,R9> ; Restore registers
	RSB				; Return to caller

	.SBTTL	VALID_MULTI - VALIDATE THE MULTICAST ADDRESS LIST

;++
; VALID_MULTI - VALIDATE THE MULTICAST ADDRESS LIST
;
; Functional description:
;
; This routine checks all address in the multicast address list to make sure
; that the logical address bit (lsb) is on.
;
; Inputs:
;
;	R3 = Size of multicast string list
;	R4 = CDB address
;	R5 = UCB address
;	R6 = Address past multicast strings
;
; Outputs:
;
;	R0 = Low bit clear if invalid address in list
;	All other registers are preserved.
;
;--

VALID_MULTI:				; Validate the multicast address list
	PUSHR	#^M<R2,R3,R6>		; Save some registers
	MNEGL	#1,R0			; Assume success
	SUBL	R3,R6			; Point back at start of list
	SUBL	#2,R3			; Can we read modifier word?
	BLSS	20$			; Br if no - error
;
; Make sure modifier word is valid - non-zero and less than or equal to
; NMA$C_LINMC_CAL
;
	ASSUME	NMA$C_LINMC_SET EQ 1
	ASSUME	NMA$C_LINMC_CLR EQ 2
	ASSUME	NMA$C_LINMC_CAL EQ 3
	MOVW	(R6)+,R2		; Get modifier value
	BEQL	20$			; Br if zero - illegal
	CMPW	R2,#NMA$C_LINMC_CAL	; Is the modifier okay?
	BGTRU	20$			; Br if no - error
	BEQL	30$			; Br if "CLEAR ALL" - ignore strings
	DIVL	#6,R3			; Calculate number of strings
	BEQL	30$			; Br if none
10$:	BLBC	(R6),20$		; Br if not a logical address
	CMPL	(R6)+,R0		; Do low order 32 bits = -1?
	BNEQ	15$			; Br if no - okay
	CMPW	(R6),R0			; Do high order 16 bits = -1?
	BEQL	20$			; Br if yes - illegal
15$:	ADDL	#2,R6			; Point to next multicast address
	SOBGTR	R3,10$			; Loop if more
	BRB	30$			; Exit with success

20$:	CLRL	R0			; Return error
30$:	POPR	#^M<R2,R3,R6>		; Restore registers
	RSB

	.SBTTL	VALID_PHYAD - VALIDATE THE PHYSICAL ADDRESS

;++
; VALID_PHYAD - VALIDATE THE PHYSICAL ADDRESS
;
; Functional description:
;
; This routine checks the physical address to make sure the LSB is clear and
; that the modifier word is valid.
;
; Inputs:
;
;	R1 = Parameter type code
;	R3 = Size of string
;	R4 = CDB address
;	R5 = UCB address
;	R6 = Address past physical address string
;
; Outputs:
;
;	R0 = Low bit clear if invalid address in list
;	All other registers are preserved.
;
;--

VALID_PHYAD:				; Validate the physical address
	PUSHR	#^M<R2,R3,R6>		; Save some registers
	MNEGL	#1,R0			; Assume success
	SUBL	R3,R6			; Point back at start of list
	SUBL	#2,R3			; Can we read modifier word?
	BLSS	30$			; Br if no - error

;
; Make sure modifier word is valid.
;

	ASSUME	NMA$C_LINMC_SET EQ 1
	ASSUME	NMA$C_LINMC_CLR EQ 2
	ASSUME	NMA$C_LINMC_CAL EQ 3
	ASSUME	NMA$C_LINMC_SDF EQ 4
	MOVZWL	(R6)+,R2		; Get modifier value
	$DISPATCH	R2,TYPE=B,-	; Dispatch on modifier value
		<-
	    	<NMA$C_LINMC_SET 20$>,-	; Set the address
	    	<NMA$C_LINMC_CLR 40$>,-	; Clear the address
	    	<NMA$C_LINMC_CAL 30$>,-	; 3 - invalid value
	    	<NMA$C_LINMC_SDF 10$>,-	; 4 - check it out more
		>
	BRB	30$			; Any other values are invalid
	
10$:	CMPW	#NMA$C_PCLI_PHA,R1	; Set to def physical addr requested?
	BNEQ	30$			; Return failure if not
	BRB	40$			; Else, success

20$:	CMPL	#6,R3			; Is string size okay?
	BNEQ	30$			; Br if not
	BLBC	(R6),40$		; Br if a physical address

30$:	CLRL	R0			; Return error
40$:	POPR	#^M<R2,R3,R6>		; Restore registers
	RSB

	.SBTTL	SET_MULTI - SET THE UCB MULTICAST ADDRESS LIST

;++
; SET_MULTI - SET THE UCB MULTICAST ADDRESS LIST
;
; Functional description:
;
; This routine sets up the multicast addresses in the UCB.
;
; Inputs:
;
;	R4 = CDB address
;	R5 = UCB address
;	R6 = Address of multicast addresses to be set or cleared
;	R9 = Size of multicast list
;
;	IPL = FIPL
;
; Outputs:
;
;	R0 = Status return for request
;	All registers are preserved.
;
;--

SET_MULTI:				; Set up the UCB multicast address list
	PUSHR	#^M<R1,R2,R3,R6,R9>	; Save registers
	SUBL	#2,R9			; Can we read the modifier word?
	BLSS	90$			; Br if no - exit
	DIVL	#6,R9			; Calculate number of addresses
	MOVZWL	(R6)+,R1		; Get the modifier
	ASSUME	NMA$C_LINMC_SET EQ 1
	ASSUME	NMA$C_LINMC_CLR EQ 2
	ASSUME	NMA$C_LINMC_CAL EQ 3
	CASE	R1,TYPE=B,LIMIT=#1,<-	; Dispatch on modifier
		10$,-			; Set the address(es)
		40$,-			; Clear the address(es)
		70$>			; Clear ALL addresses
;
; Set address from list
;
10$:	TSTL	R9			; Any addresses present?
	BEQL	90$			; Br if no - exit
20$:	MOVL	(R6)+,R1		; Get multicast address
	MOVW	(R6)+,R2		;	...
	BSBW	MATCH_ADDRESS		; Try to find address in table
	BLBS	R0,30$			; Br if present - skip it
	BSBB	FIND_MLTENTRY		; Find entry in UCB multicast table
	BLBC	R0,100$			; Br if none - leave in error
	MOVL	R1,(R3)+		; Insert new address
	MOVW	R2,(R3)+		;	...
	INCB	UCB$B_XE_MULTI(R5)	; Count one more address
30$:	SOBGTR	R9,20$			; Br if more
	BRB	90$			; All done
;
; Clear address from list
;
40$:	TSTL	R9			; Any addresses present?
	BEQL	90$			; Br if no - exit
50$:	MOVL	(R6)+,R1		; Get multicast address
	MOVW	(R6)+,R2		;	...
	BSBW	MATCH_ADDRESS		; Try to find address in table
	BLBC	R0,60$			; Br if not present - skip it
	CLRL	(R3)+			; Mark slot as not in use
	CLRW	(R3)+			;	...
	DECB	UCB$B_XE_MULTI(R5)	; Count one less address
	BSBW	SQUEEZ_MULTI		; Squeeze up the multicast list
60$:	SOBGTR	R9,50$			; Br if more
	BRB	90$			; All done
;
; Clear all multicast addresses
;
70$:	CLRB	UCB$B_XE_MULTI(R5)	; Reset number of multicast addresses
	MOVZBL	#MAX_C_MLT*3,R1		; Get number of words in multicast list
	MOVAB	UCB$G_XE_MULTI(R5),R2	; Get address of multicast addresses
80$:	CLRW	(R2)+			; Init multicast address list
	SOBGTR	R1,80$			; Loop if more

90$:	MOVZBL	S^#SS$_NORMAL,R0	; Return success
100$:	POPR	#^M<R1,R2,R3,R6,R9>	; Restore registers
	RSB				; Return to caller

;+
; FIND_MLTENTRY - FIND EMPTY SLOT IN UCB MULTICAST ADDRESS LIST
;
; Inputs:
;
;	R5 = UCB address
;
; Outputs:
;
;	R0 = Status return for request
;	R3 = Address of available slot if successful
;-
FIND_MLTENTRY:
	PUSHL	R1			; Save R1
	MNEGL	#1,R0			; Assume success
	MOVAB	UCB$G_XE_MULTI(R5),R3	; Get address of multicast list
	MOVZBL	#MAX_C_MLT,R1		; Get maximum number of addresses
10$:	TSTL	(R3)+			; Empty slot?
	BNEQ	20$			; Br if no - skip to next entry
	TSTW	(R3)			; Really?
	BEQL	30$			; Br if yes - success
20$:	ADDL	#2,R3			; Skip to next address
	SOBGTR	R1,10$			; Br if more to try

	CLRL	R0			; Return failure
30$:	SUBL	#4,R3			; Back up pointer
	POPL	R1			; Restore registers
	RSB

;+
; SQUEEZ_MULTI - SQUEEZE UP THE MULTICAST ADDRESS LIST
;
; Functional description:
;
; The first empty slot is searched for in the multicast address list and
; the list is squeezed from that point down.
;
; Inputs:
;
;	R5 = UCB address
;
; Ouputs:
;
;	None
;
;--
SQUEEZ_MULTI:				; Squeeze down the multicast address list
	PUSHQ	R3			; Save R3, R4
	MOVZBL	UCB$B_XE_MULTI(R5),R4	; Get number of entries in list
	BEQL	40$			; Br if none
	MOVAB	UCB$G_XE_MULTI(R5),R3	; Get address of multicast list
;
; Search for empty slot in list
;
10$:	TSTL	(R3)			; Is this the empty slot
	BNEQ	20$			; Br if no
	TSTW	4(R3)			; Really?
	BEQL	30$			; Br if yes
20$:	ADDL	#6,R3			; Skip to next entry in list
	SOBGTR	R4,10$			; Loop if more possiblities
	BRB	40$			; Else, exit
;
; Empty slot found - put the squeeze on.
;
30$:	MOVL	6(R3),(R3)+		; Squeeze the list
	MOVW	6(R3),(R3)+		;	...
	SOBGTR	R4,30$			; Loop if more to go
	CLRL	(R3)+			; Zero the last entry
	CLRW	(R3)+			;	...
40$:	POPQ	R3			; Restore R3, R4
	RSB				; Return to caller

	.SBTTL	SET_PHYAD - SET THE PHYSICAL ADDRESS
	.SBTTL	SET_DESAD - SET THE DESTINATION ADDRESS
;++
; SET_PHYAD - SET THE PHYSICAL ADDRESS
; SET_DESAD - SET THE DESTINATION ADDRESS
;
; Functional description:
;
; This routine sets up the physical address in the CDB.
;
; Inputs:
;
;	R4 = CDB address
;	R5 = UCB address
;	R6 = Address of physical address to be set or cleared
;	R9 = Size of the string
;
;	IPL = FIPL
;
; Outputs:
;
;	R0 = destroyed.
;	All other registers are preserved.
;
;--
	.ENABL	LSB
SET_PHYAD:				; Set up the CDB physical address
	PUSHR	#^M<R1,R6,R7,R9>	; Save registers
	MOVAB	UCB$G_XE_PHA(R5),R7	; Get address of UCB cell
	BRB	10$			; Join common code
SET_DESAD:
	PUSHR	#^M<R1,R6,R7,R9>	; Save registers
	MOVAB	UCB$G_XE_DES(R5),R7	; Get address of UCB cell
10$:	SUBL	#2,R9			; Can we read the modifier word?
	BLSS	50$			; Br if no - exit
	DIVL	#6,R9			; Calculate number of addresses
	MOVZWL	(R6)+,R1		; Get the modifier

	ASSUME	NMA$C_LINMC_SET EQ 1
	ASSUME	NMA$C_LINMC_CLR EQ 2
	ASSUME	NMA$C_LINMC_CAL EQ 3
	ASSUME	NMA$C_LINMC_SDF EQ 4
	$DISPATCH	R1,TYPE=B,-	; Dispatch on modifier value
		<-
	    	<NMA$C_LINMC_SET 20$>,-	; Set the address
	    	<NMA$C_LINMC_CLR 30$>,-	; Clear the address
	    	<NMA$C_LINMC_CAL 50$>,-	; 3 - invalid value
	    	<NMA$C_LINMC_SDF 40$>,-	; Set physical as DECnet default address
		>
	BRB	50$			; Any other values are invalid

;
; Set physical address
;
20$:	TSTL	R9			; Any addresses present?
	BEQL	50$			; Br if no - exit
	MOVL	(R6)+,(R7)+		; Set new address
	MOVW	(R6)+,(R7)		;	...
	BRB	50$			; All done
;
; Clear address from list
;
30$:	MNEGL	#1,(R7)+		; Reset address
	MNEGW	#1,(R7)			;	...
	BRB	50$			; All done

;
; Set the physical address (Assume entered from SET_PHYAD) to the DECNET
; default address. The physical address is pre-set to -1 to default to
; the current PHA or HWA address. We will leave it alone if we are already
; initialized or we don't have SCSSYSTEMID set.
;
40$:	BBS	#CDB_STS_V_INITED,-	; Br if device is already inited
		CDB_B_STS(R4),50$	;  ... use current PHA or HWA
	MOVW	G^SCS$GB_SYSTEMID,R1	; Get unique high word of address
	BEQL	50$			; Br if not set, use default
	MOVL	#^X000400AA,(R7)+	; Set common low longword of addr
	MOVW	R1,(R7)			; Set unique high word of address

50$:	POPR	#^M<R1,R6,R7,R9>	; Restore registers
	RSB				; Return to caller
	.DSABL	LSB

	.SBTTL	RETURN_MULTI - RETURN THE MULTICAST ADDRESS LIST

;++
; RETURN_MULTI - RETURN THE MULTICAST ADDRESS LIST
;
; Functional description:
;
; This routine returns all the multicast addresses in the UCB list.
;
; Inputs:
;
;	R4 = CDB address
;	R5 = UCB address
;	R6 = Address where to store multicast address list
;	R8 = Size left in output buffer
;
; Outputs:
;
;	R6 = Address past stored multicast address list
;	All other registers are preserved.
;
;--

RETURN_MULTI:				; Return the multicast address list
	PUSHQ	R1			; Save R1, R2
	MOVZBL	UCB$B_XE_MULTI(R5),R2	; Set number of multicast addresses
	MOVAB	UCB$G_XE_MULTI(R5),R1	; Point to start of multicast lists
	SUBL	#2,R8			; Can string size fit?
	BLSS	40$			; Br if no - return
	ADDL	#2,R6			; Skip size field of return data
	PUSHL	R6			; Save start address of string
10$:	SUBL	#6,R8			; Room left in buffer?
	BLSS	30$			; Br if no .. exit now
	MOVL	(R1)+,(R6)+		; Return address
	MOVW	(R1)+,(R6)+		;	...
	SOBGTR	R2,10$			; Br if more possibles

30$:	POPL	R1			; Restore string address
	SUBL3	R1,R6,R2		; Get string size
	MOVW	R2,-2(R1)		; Return string size
40$:	POPQ	R1			; Restore R1, R2
	RSB				; Return to caller

	.SBTTL	MATCH_MULTI - CHECK MULTICAST ADDRESS

;++
; MATCH_MULTI - CHECK MULTICAST ADDRESS
;
; Functional description:
;
; This routine returns success if the unit is in promiscous mode, or the
; recognizes all multicast address or the multicast address in the buffer
; matches a multicast address in the unit's multicast address list.
;
; Inputs:
;
;	R2 = Receive buffer
;	R4 = CDB address
;	R5 = UCB address
;
; Outputs:
;
;	R0 = Status return for request
;	R1 = Destroyed
;	All other registers are preserved.
;
;--

MATCH_MULTI:				; Find multicast addres in UCB
	PUSHQ	R2			; Save R2, R3
	CLRL	R0			; Assume failure

	ASSUME	UCB$V_XE_INITED  EQ  0
	BLBC	UCB$W_DEVSTS(R5),10$	; Br if PROTOCOL TYPE is not valid
	INCL	R0			; Assume success
	ASSUME	NMA$C_STATE_ON EQ 0
	ASSUME	NMA$C_STATE_OFF EQ 1
	BLBC	UCB$B_XE_PRM(R5),10$	; Br if promiscuous mode - OKAY
	BLBC	UCB$B_XE_MLT(R5),10$	; Br if all multicasts are enabled
	MOVQ	CXB$G_R_DEST(R2),R1	; Get multicast address
	CMPL	#BRDCST1,R1		; Is this the broadcast address?
	BNEQ	5$			; Br if no
	CMPW	#BRDCST2,R2		; Really?
	BEQL	10$			; Br if yes - everybody get this one
5$:	BSBB	MATCH_ADDRESS		; Else, find exact match
10$:	POPQ	R2			; Restore R2, R3
	RSB				; Return to caller

	.SBTTL	MATCH_ADDRESS - FIND A MATCH ON A MULTICAST ADDRESS

;++
; MATCH_ADDRESS - FIND A MATCH ON A MULTICAST ADDRESS
;
; Functional description:
;
; This routine searches the UCB multicast address list for a match on a
; multicast address.
;
; Inputs:
;
;	R1 = Low 32 bits of 48 bit multicast address to match
;	R2 = High 16 bits of 48 bit multicast address to match
;	R4 = CDB address
;	R5 = UCB address
;
; Outputs:
;
;	R0 = Status return for request
;	R3 = Address of slot in multicast address list
;	All other registers are preserved.
;
;--

MATCH_ADDRESS:				; Find multicast address in UCB
	PUSHL	R4			; Save R4
	MOVZBL	S^#SS$_NORMAL,R0	; Assume success
	MOVZBL	UCB$B_XE_MULTI(R5),R4	; Set number of multicast addresses
	MOVAB	UCB$G_XE_MULTI(R5),R3	; Point to start of multicast lists
10$:	CMPL	(R3)+,R1		; Is this a match?
	BNEQ	20$			; Br if no - skip to next
	CMPW	(R3),R2			; Is it really?
	BEQL	30$			; Br if yes - all done
20$:	ADDL	#2,R3			; Skip to next entry
	SOBGTR	R4,10$			; Br if more in list

	CLRL	R0			; Return failure
30$:	SUBL	#4,R3			; Backup pointer
	POPL	R4			; Restore R4
	RSB				; Return to caller

	.SBTTL	POKE_USER - DELIVER ATTENTION ASTS

;++
; POKE_USER - Deliver attention AST
;
; Functional description:
;
; This routine is used to deliver an attention AST if one has been
; requested.
;
; Inputs:
;
;	R5 = UCB address
;
; Outputs:
;
;	R0 = Low bit clear only if user is not notified
;	R1-R3 are destroyed.
;
;--

POKE_USER:				; Poke user process
	DSBINT	UCB$B_FIPL(R5)		; Sync access to UCB
	CLRL	-(SP)			; Assume failure
	MOVAB	UCB$L_XE_AST(R5),R1	; Get AST listhead
	TSTL	(R1)			; Empty?
	BEQL	30$			; Branch if yes
	INCL	(SP)			; Indicate success
	PUSHL	R4			; Save R4
	MOVL	R1,R4			; Copy listhead address
10$:	MOVL	(R1),R1			; Address a block
	BEQL	20$			; Branch if done
	MOVL	UCB$L_DEVDEPEND(R5),-	; Change parameter
		ACB$L_KAST+4(R1)	;    return status
	BRB	10$			; Continue thru AST blocks
20$:	JSB	G^COM$DELATTNAST	; Deliver the AST's
	POPL	R4			; Restore R4
 
30$:	POPL	R0			; Return success indicator
	ENBINT				; Restore IPL
	RSB				; Return to caller

	.SBTTL	MATCH_PROTYP - Match protocol type
	.SBTTL	MATCH_PROMTYP - Find the promiscuous user

;++
; MATCH_PROTYP - Match protocol type
; MATCH_PROMTYP - Find the promiscuous user
;
; This routine checks for a match of a protocol type against that in
; existing UCB's.
;
; Inputs:
;
;	R1 = word of protocol type
;	R4 = CDB address
;
; Outputs:
;
;	R0 = LBS=> match; LBC=> no match
;	R5 = UCB address on success
;
;-

MATCH_PROTYP:				; Match protocol type
	CLRL	R0			; Assume failure
	MOVL	CDB_L_UCB0(R4),R5	; Get first UCB address
	BEQL	20$			; Br if not inited - yet
10$:	MOVL	UCB$L_LINK(R5),R5	; Get next UCB address
	BEQL	20$			; If EQL no match
	ASSUME	UCB$V_XE_INITED  EQ  0
	BLBC	UCB$W_DEVSTS(R5),10$	; Br if PROTOCOL TYPE is not valid

	ASSUME	NMA$C_STATE_ON EQ 0
	ASSUME	NMA$C_STATE_OFF EQ 1

	BLBC	UCB$B_XE_PRM(R5),10$ 	; Skip if PROMISCUOUS user
	CMPW	R1,UCB$W_XE_PROTYP(R5)	; Match?
	BNEQ	10$			; If NEQ no - loop
15$:	INCL	R0			; Return success
20$:	RSB				; Done

MATCH_PROMTYP:
	MOVZBL	#1,R0			; Assume success
	MOVL	CDB_L_PRMUSER(R4),R5	; Get PROMISCUOUS user's UCB address
	BNEQ	10$			; Br if present
	CLRL	R0			; Else, return error
10$:	RSB				; Return to caller


XE_END::
	.END
