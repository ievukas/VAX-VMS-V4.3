MODULE RSTTYPES (IDENT = 'V04-000') =

BEGIN

!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
! WRITTEN BY
!	Bert Beander	August, 1980
!	Ken Nappa	August, 1980
!
! MODULE FUNCTION
!	This module contains symbol table access routines for types.  These
!	routines accept a Type ID and return information about the correspond-
!	ing data type.
!
! MODIFIED BY
!	Ping Sager	May 1982	Correct the way to get BITSIZE value
!					in DBG$STA_TYP_VARIANT.
!	Ping Sager	Oct 1982	Added DBG$TYPEID_FOR_SET routine
!	Rich Title	Nov 1982	Added DBG$TYPEID_FOR_TPTR routine
!	Ping Sager      Jan 1983        Handled more cases for DST has SEPTYP
!	Rich Title	Jan 1982	Added DBG$TYPEID_FOR_ARRAY routine
! 006	Walter Carrell	Oct 1983	Added support for continuation DST records
!

REQUIRE 'SRC$:DBGPROLOG.REQ';

FORWARD ROUTINE
    DBG$FIND_SEPTYP,			! Get Separate Type Specification
    					!      from a given DST record
    DBG$GET_BITSIZE_FROM_DESC,		! Get the size from the descriptor
    DBG$GET_BITSIZE_FROM_TYPESPEC,	! Get the size from Type Spec.
    DBG$STA_SYMTYPE:	NOVALUE,	! Return a symbol's TYPEID and FCODE
    DBG$STA_SYMSIZE:	NOVALUE,	! Return the bit size of a data type
    DBG$STA_TYPEFCODE,			! Return the type format code
    DBG$STA_TYP_AREA: NOVALUE,		! Return the info for an area type
    DBG$STA_TYP_ARRAY:	NOVALUE,	! Return info for an array type
    DBG$STA_TYP_ATOMIC:	NOVALUE,	! Return type code for an atomic type
    DBG$STA_TYP_DESCR:	NOVALUE,	! Return descriptor for descriptor type
    DBG$STA_TYP_ENUM:	NOVALUE,	! Return info for an enumeration type
    DBG$STA_TYP_FILE:	NOVALUE,	! Return info for a file type
    DBG$STA_TYP_OFFSET: NOVALUE,	! Return info for a offset type
    DBG$STA_TYP_PICT:	NOVALUE,	! Return info for a picture type
    DBG$STA_TYP_TYPEDPTR: NOVALUE,	! Return info for a typed pointer type
    DBG$STA_TYP_RECORD:	NOVALUE,	! Return info for a record type
    DBG$STA_TYP_SET:	NOVALUE,	! Return info for a set type
    DBG$STA_TYP_SUBRNG:	NOVALUE,	! Return info for a subrange type
    DBG$STA_TYP_VARIANT:NOVALUE,	! Return info for a variant type
    DBG$STA_TYP_VARIANT_COMP: NOVALUE,	! XXX
    DBG$TRANS_TYPE_CODE,		! Translates DST fcodes to RST fcodes
    DBG$TYPEID_FOR_ARRAY,		! Return Type ID for array
    DBG$TYPEID_FOR_ATOMIC,		! Return Type ID for atomic type
    DBG$TYPEID_FOR_SET,			! Return Type ID for set type
    DBG$TYPEID_FOR_TPTR,		! Return Type ID for TPTR type
    TYPEID_FOR_COB_HACK,		! Return Type ID for COBOL Hack record
    TYPEID_FOR_DESCR,			! Return Type ID for descriptor type
    TYPEID_FROM_DST_TYPESPEC,		! Return Type ID from a Type Speci-
					!      fication embedded in the DST
    TYPEID_FROM_DST_RECORD,
    DESC_OR_ARRAY_OR_ATOM,		! Determines the nature of the type.
    FIND_RST_TYPE_ENTRY,
    FIND_TYPE_RECORD,			! Returns symid of type info
    FIND_TYPESPEC,			! Get Type Spec from Sep Type
    FIND_TYPREC_FROM_TSPEC,
    GET_BITSIZE_FROM_DTYPE,		! Get the size from Dtype
    GET_BITSIZE_FROM_BLIDST;		! Get the size from BLI DST

EXTERNAL ROUTINE
    DBG$DATA_LENGTH,			! Obtain bitsize from VMS descriptor
    DBG$GET_MEMORY,			! Get a permanent memory block
    DBG$GET_TEMPMEM,			! Get a "temporary" memory block
    DBG$READ_ACCESS: NOVALUE,		!
    DBG$RST_DST_PTR,			! Return the real DST pointer
    DBG$RST_NEXT_DST,			! Return the next DST given a DST
    DBG$STA_SYMKIND,			! Get a specified symbol's kind
    DBG$STA_SYMNAME: NOVALUE,		! Obtain symbol name.
    DBG$STA_SYMVALUE: NOVALUE,		! Evaluate a specified symbol's value
    DBG$STA_VALSPEC: NOVALUE;		! Evaluate a DST Value Spec

EXTERNAL
    DST$BEGIN_ADDR,			! The start address of the DST in memory
    RST$START_ADDR: REF RST$ENTRY,	! Pointer to RST anonymous module
    RST$TEMP_LIST;			! Pointer to Temporary RST Entry List

OWN
    NOVEL_LENGTH_FLAG;			! This flag is used to indicate
    					!   we have encounted a novel length
    					!   dst, we need to take the size
    					!   specificed in this dst to override
    					!   the original length.  Especially,
    					!   when a data has novel length dst,
    					!   and this data item has a typeid,
    					!   (typid has its own size), in
    					!   this case we need to modify the
    					!   typeid to reflect the novel
    					!   length by making a copy of
    					!   the typeid with new novel length
    					!   for the data.

GLOBAL ROUTINE DBG$FIND_SEPTYP(DST_PTR, TYPE_PTR, TYPE_SPEC) =
!
! FUNCTION
!	Given Separate Type Specification DST Record, Figure out its Type
!	Specification and the size of the described object is returned.
!
! INPUTS
!
!	DST_PTR		- Pointer to DST Record.
!
!	TYPE_PTR	- Pointer to DST Type Spec fields.
!
!	TYPE_SPEC	- Pointer to DST Type Spec.
!
! OUTPUTS
!	Size of the object in Type Spec is returned.
!

    BEGIN

    MAP
    	DST_PTR: REF DST$RECORD,	! Pointer to DST Type Spec Record
    	TYPE_PTR: REF VECTOR[,LONG],	! Pointer to DST Type Spec fields
    	TYPE_SPEC: REF VECTOR[,LONG];	! Pointer to DST Type Spec
    	
    LOCAL
    	ENUMBEG: REF DST$RECORD,	! Pointer to Enum. begin record
    	RECBEG: REF DST$RECBEG_TRLR,	! Pointer to Rec. begin trailer record
    	NAMEPTR: REF VECTOR[,BYTE],     ! Pointer to name of the record
    	TYPEPTR: REF DST$RECORD,	! Pointer to DST Type Spec fields
    	TYPESPEC: REF DST$TYPE_SPEC,	! Pointer to DST Type Spec
    	SIZE;				! Size of the Object

    SIZE = 0;
!    TYPEPTR = DST_PTR[DST$A_NEXT] + .DST_PTR[DST$B_LENGTH];			! D006
    TYPEPTR = DBG$RST_NEXT_DST( .DST_PTR );					! A006
    TYPESPEC = 
    	TYPEPTR[DST$A_TYPSPEC_TS_ADDR] + .TYPEPTR[DST$B_TYPSPEC_NAME];

    WHILE TRUE DO
	BEGIN
    	SELECTONE .TYPEPTR[DST$B_TYPE] OF
    	    SET
	    [DST$K_SEPTYP]:
	        BEGIN
	        TYPEPTR = DBG$RST_NEXT_DST( .TYPEPTR );				! M006
	        TYPESPEC = .TYPEPTR[DST$B_TYPSPEC_NAME] + 
    			TYPEPTR[DST$A_TYPSPEC_TS_ADDR];
	        END;

    	    [DST$K_GLOBNXT]:
		BEGIN
!		TYPEPTR = .TYPEPTR + 2;						! A006
		TYPEPTR = DBG$RST_NEXT_DST( .TYPEPTR );				! A006
		TYPESPEC = .TYPEPTR[DST$B_TYPSPEC_NAME] + 
		        TYPEPTR[DST$A_TYPSPEC_TS_ADDR];
		END;

    	    [DST$K_TYPSPEC]:
	        BEGIN
    		TYPESPEC = FIND_TYPESPEC(.TYPESPEC, SIZE, TYPEPTR);
    		EXITLOOP;
    		END;

    	    [DST$K_ENUMBEG]:
    		BEGIN
    		ENUMBEG = .TYPEPTR;
    		SIZE = .TYPEPTR[DST$B_ENUMBEG_LENG];
    		EXITLOOP;
    		END;

    	    [DST$K_RECBEG]:
    		BEGIN


    		! Advance the pointer to the name field.
    		! (1 byte length, 1 byte type, 1 byte vflags, 4 bytes value).
    		!
    		RECBEG = .TYPEPTR + 1 + 1 + 1 + 4;
    		NAMEPTR = .RECBEG;

    		! Advance the pointer to the trailer field.
    		!
    		RECBEG = .RECBEG + .NAMEPTR[0] + 1;
    		SIZE = .RECBEG[DST$L_RECBEG_SIZE];
    		EXITLOOP;
    		END;

    	    [OTHERWISE]:
    		EXITLOOP;

    	    TES;

    	END;			! End of WHILE Loop.

    IF .SIZE EQL 0 THEN SIZE = DBG$GET_BITSIZE_FROM_TYPESPEC(.TYPESPEC);
    TYPE_PTR[0] = .TYPEPTR;
    TYPE_SPEC[0] = .TYPESPEC;
    RETURN .SIZE;
    END;


GLOBAL ROUTINE DBG$STA_SYMTYPE(SYMID, FCODE, TYPEID): NOVALUE =
!
! FUNCTION
!	This routine takes a SYMID and returns a TYPEID and FCODE for the
!	type associated with the input SYMID.  In the case where the SYMID
!	defines a type item, the returned TYPEID is identical to the SYMID.
!
! INPUTS
!	SYMID	- The SYMID for the symbol or type whose TYPEID and  Format Code
!		  are to be returned.
!
!	FCODE	- The address of a longword location to receive the FCODE
!		  associated with the given SYMID.
!
!	TYPEID	- The address of a longword location to receive the
!		  TYPEID describing the type associated with SYMID.
!
! OUTPUTS
!	FCODE	- The format code associated with SYMID is returned to FCODE.
!
!	TYPEID 	- A TYPEID defining the type associated with the input
!		  SYMID is returned to TYPEID.
!
!

    BEGIN

    MAP
	SYMID: REF RST$ENTRY,		! Pointer to input symbol's RST entry
	FCODE: REF VECTOR[1],		! Address where FCODE is returned
	TYPEID: REF VECTOR[1];		! Address where TYPEID is returned

    LOCAL
	SIZE;				! Bit size of a data item of the type



    ! Find the Type RST Entry associated with the input SYMID.  Return its
    ! address to TYPEID[0] and its Format Code to FCODE[0].  Signal an internal
    ! error if the TYPEID turns out to be zero--that should never happen.
    !
    TYPEID[0] = FIND_TYPE_RECORD(.SYMID, FCODE[0], SIZE);
    IF .TYPEID[0] EQL 0
    THEN
	$DBG_ERROR('RSTTYPES\SYMTYPE');

    RETURN;

    END;

GLOBAL ROUTINE DBG$STA_SYMSIZE(SYMID, SIZE): NOVALUE =
!
! FUNCTION
!	This routine takes a SYMID and returns the size in bits associated
!	with that input SYMID.
!
! INPUTS
!	SYMID	- The SYMID for the symbol or type whose bitsize is to be
!		  returned.
!
!	SIZE	- The address of a longword location to receive the size in bits
!		  of the item described by the given SYMID.
!
! OUTPUTS
!	SIZE	- The size in bits of the input item is returned to SIZE.
!
!	No value is returned.
!

    BEGIN

    MAP
	SYMID: REF RST$ENTRY,		! Pointer to input symbol's RST entry
	SIZE: REF VECTOR[1];		! Address where size is to be returned

    LOCAL
	TYPEID: REF RST$ENTRY,		! The symbol's Type ID
	FCODE;				! The symbol's Type Format Code



    ! Get to the Type DST record and pick up the size information.  If no type
    ! info was found, set the bit size to zero (wich means size is unknown).
    !
    TYPEID = FIND_TYPE_RECORD(.SYMID, FCODE, SIZE[0]);
    IF .TYPEID EQL 0 THEN SIZE[0] = 0
    ELSE IF (.SIZE[0] EQL 0) AND
      ((.FCODE EQL RST$K_TYPE_PTR) OR (.FCODE EQL RST$K_TYPE_TPTR))
	THEN SIZE[0] = 32;
    RETURN;
    END;

GLOBAL ROUTINE DBG$STA_TYPEFCODE(SYMID) =
!
! FUNCTION
!	This routine returns the Format Code (FCODE) associated with a specified
!	type (given by a SYMID or TYPEID).  The Format Code is simply picked up
!	from the type's RST entry.
!
! INPUTS
!	SYMID	- The SYMID for the symbol or type whose type Format Code
!		  is to be returned.
!
! OUTPUTS
!	The type's Format Code is returned as the routine value.  The possible
!		  Format Codes are listed in DBGLIB.REQ.
!
!

    BEGIN

    LOCAL
	TYPEID,				! The symbol's Type ID
	FCODE;				! The symbol's type Format Code



    ! Get the symbol's type and Format Code.  Then return the type Format Code.
    !
    DBG$STA_SYMTYPE(.SYMID, FCODE, TYPEID);
    RETURN .FCODE;

    END;

GLOBAL ROUTINE DBG$STA_TYP_ARRAY(TYPEID, DSCADDR, CELLTYPE,
					NDIMS, DIMVECPTR, BITSIZE): NOVALUE =
!
! FUNCTION
!	This routine returns the type information associated with an Array data
!	type.  The type of interest is identified by a Type ID, and the returned
!	information includes the array descriptor, the cell type, the number of
!	dimensions, the size in bits of the array, and information about each
!	specific dimension (the subscript type, the lower bound, and the upper
!	bound).
!
! INPUTS
!	TYPEID	- The Type ID of the Array data type about which information is
!		  desired.  Its Format Code must be RST$K_TYPE_ARRAY.
!
!	DSCADDR	- The address of a longword location to receive a pointer to the
!		  array's descriptor.
!
!	CELLTYPE - The address of a longword location to receive the Type ID of
!		  the data type of the individual array elements.
!
!	NDIMS	- The address of a longword location to receive the number of
!		  dimensions in the array.
!
!	DIMVECPTR - The address of a longword location to receive a pointer to a
!		  vector of subscript information.
!
!	BITSIZE	- The address of a longword location to receive the size in bits
!		  of an array of this type.
!
! OUTPUTS
!	DSCADDR - The address of the array descriptor is returned to DSCADDR.
!		  This may be a contiguous or noncontiguous array descriptor.
!		  The descriptor may disappear at the end of the current Debug
!		  command.
!
!	CELLTYPE - The Type ID of the individual array elements' data type is
!		  returned to CELLTYPE.
!
!	NDIMS	- The number of array dimensions is returned to NDIMS.
!
!	DIMVECPTR - A pointer to a subscript vector is returned to
!		  DIMVECPTR.  This vector contains one longword
!		  per dimension, giving the subscript Type ID.
!		  The vector is allocated in temporary storage--it disappears
!		  at the end of the current Debug command.
!
!	BITSIZE	- The size in bits is returned to BITSIZE.
!
!	No value is returned.
!
! WARNING:
!	The five output parameters must be distinct locations in the
!	callers address space. For example, you cannot do:
!	DBG$STA_TYP_ARRAY (.TYPEID, JUNK, CELLTYPE, JUNK, JUNK, JUNK)
!	to just find out the celltype. The problem is that the routine
!	is using the addresses passed in (.JUNK in this case) as local
!	storage, which it really should not be doing, and stores into
!	one .JUNK will trip up reads from another. So you must pass
!	in distinct parameters,
!	DBG$STA_TYP_ARRAY (.TYPEID, JUNK1, CELLTYPE, JUNK2, JUNK3, JUNK4)
!	I got tripped up on this so I thought I'd warn others.
!	R. Title Nov 1982.
!

    BEGIN

    MAP
    	TYPEID : REF RST$ENTRY;		! The input TYPEID for the array type

    LOCAL
	I,
    	BITS_USED,
    	DATA_TYPE,
	SIZE,
	FCODE,
	VALKIND,
	TYPE_SPEC : REF DST$TYPE_SPEC,
	TYPE_SPEC1 : REF DST$TYPE_SPEC,
	DST_PTR : REF DST$RECORD,
	TYPEID_PTR : REF RST$ENTRY,
	DESC_PTR : REF BLOCK[,BYTE],
	SUBSCR_VECT : REF VECTOR,
	VAL_VECT : VECTOR[3],
	VAL_PTR : REF DST$VAL_SPEC;



    TYPEID_PTR = FIND_TYPE_RECORD(.TYPEID, FCODE, SIZE);


    ! TYPEID_PTR -> RST Entry for this array type.  Verify the format code.
    !
    IF .FCODE NEQ RST$K_TYPE_ARRAY THEN $DBG_ERROR('RSTTYPES\TYP_ARRAY 10');
    DST_PTR = .TYPEID_PTR[RST$L_DSTPTR];
    TYPE_SPEC = DST_PTR[DST$A_TYPSPEC_TS_ADDR] + .DST_PTR[DST$B_TYPSPEC_NAME];
    TYPE_SPEC = FIND_TYPESPEC(.TYPE_SPEC, SIZE, DST_PTR);


    ! For array, Typeid does not carray the size information.  However
    ! FIND_TYPESPEC routine does go further into the DST to dig out
    ! the size of the array for contiguous array.
    !
    .BITSIZE = .SIZE;


    ! TYPE_SPEC -> Type Specification field for this array type.
    ! If old format array spec, get info from descriptor
    !
    IF .TYPE_SPEC[DST$B_TS_KIND] EQL DST$K_TS_DSC
    THEN
	BEGIN

    	! Obtain a descriptor by evaluating the value specification.
    	!
	VAL_PTR = TYPE_SPEC[DST$A_TS_DSC_VSPEC_ADDR];
	DBG$STA_VALSPEC(.VAL_PTR, VAL_VECT, VALKIND);
	IF .VALKIND NEQ DBG$K_VAL_DESCR
	THEN
	    $DBG_ERROR('RSTTYPES\TYP_ARRAY 20');
	DESC_PTR = .VAL_VECT[0];
	DBG$READ_ACCESS(.DESC_PTR, 12);
	.DSCADDR = .DESC_PTR;

    	! Obtain the dtype of an element and the bitsize of an element.
    	! Note that DBG$DATA_LENGTH returns the bitsize of an element
    	! because it just looks at the dtype field and the length field,
    	! not the class field.
    	!
	DATA_TYPE = .DESC_PTR[DSC$B_DTYPE];
    	BITS_USED = DBG$DATA_LENGTH(.DESC_PTR);

    	! Build a typeid for the array element.
    	!
	IF (.BITS_USED NEQ 0)             AND
	   (.DESC_PTR[DSC$B_SCALE] EQL 0) AND
	   (.DESC_PTR[DSC$B_DIGITS] EQL 0)
	THEN
	    .CELLTYPE = DBG$TYPEID_FOR_ATOMIC(.DATA_TYPE,.BITS_USED,TRUE)

	ELSE
	    .CELLTYPE = TYPEID_FOR_DESCR(.DESC_PTR,RST$K_TYPE_DESCR,TRUE);

    	! Use the descriptor to fill in the remaining output parameters.
    	!
	.NDIMS = .DESC_PTR[DSC$B_DIMCT];
	SUBSCR_VECT = DBG$GET_TEMPMEM(..NDIMS);
	.DIMVECPTR = .SUBSCR_VECT;
	INCR I FROM 0 TO ..NDIMS - 1 DO
	    SUBSCR_VECT[.I] = 0;
	END


    ! New format type specification for this array.
    !
    ELSE
	BEGIN
	IF .TYPE_SPEC[DST$B_TS_KIND] EQL DST$K_TS_ARRAY
	THEN
	    BEGIN
	    LOCAL
		FLAGS_PTR : REF BITVECTOR;

	    .NDIMS = .TYPE_SPEC[DST$B_TS_ARRAY_DIM];
	    FLAGS_PTR = TYPE_SPEC[DST$A_TS_ARRAY_FLAGS_ADDR];


	    ! FLAGS_PTR -> Bitvector of optional Type-Spec indicators.
	    !
	    VAL_PTR = .FLAGS_PTR + (..NDIMS/8) + 1;
	    DBG$STA_VALSPEC(.VAL_PTR, VAL_VECT, VALKIND);
	    IF .VALKIND NEQ DBG$K_VAL_DESCR
	    THEN
		$DBG_ERROR('RSTTYPES\TYP_ARRAY 30');

	    DESC_PTR = .VAL_VECT[0];
	    .DSCADDR = .DESC_PTR;
	    IF .VAL_PTR[DST$B_VS_VFLAGS] EQL DST$K_VS_FOLLOWS
	    THEN
		TYPE_SPEC1 = .VAL_PTR + .VAL_PTR[DST$W_VS_LENGTH] + 3

	    ELSE
		TYPE_SPEC1 = .VAL_PTR + 5;


	    ! TYPE_SPEC1 -> First optional Type Spec within this record.
	    ! TYPE_SPEC1 will move along through the optional Type Specs.
	    !
	    IF .FLAGS_PTR[0]
	    THEN
		BEGIN
		! Optional cell type is present.
		.CELLTYPE = FIND_TYPREC_FROM_TSPEC(.TYPE_SPEC1);
		TYPE_SPEC1 = .TYPE_SPEC1 + 2 + .TYPE_SPEC1[DST$W_TS_LENGTH];
		END

	    ELSE
		BEGIN
		! no optional cell type; use cell type from descriptor.
		DBG$READ_ACCESS(.DESC_PTR, 12);

    		! Obtain the dtype of an element and the bitsize of an element.
    		! Note that DBG$DATA_LENGTH returns the bitsize of an element
    		! because it just looks at the dtype field and the length field,
    		! not the class field.
    		!
		DATA_TYPE = .DESC_PTR[DSC$B_DTYPE];
    		BITS_USED = DBG$DATA_LENGTH(.DESC_PTR);

		IF (.BITS_USED NEQ 0)             AND
		   (.DESC_PTR[DSC$B_SCALE] EQL 0) AND
		   (.DESC_PTR[DSC$B_DIGITS] EQL 0)
		THEN
		    .CELLTYPE = DBG$TYPEID_FOR_ATOMIC(.DATA_TYPE,.BITS_USED,TRUE)

		ELSE
		    .CELLTYPE = TYPEID_FOR_DESCR(.DESC_PTR,RST$K_TYPE_DESCR,TRUE);

		END;


	    ! Now build DIMVECPTR.  Each element receives either a TYPEID or
	    ! zero, depending on the appropriate bit in the flags vector.
	    !
	    SUBSCR_VECT = DBG$GET_TEMPMEM(..NDIMS);
	    .DIMVECPTR = .SUBSCR_VECT;
	    INCR I FROM 1 TO ..NDIMS DO
		BEGIN
		IF .FLAGS_PTR[.I]
		THEN
		    BEGIN
		    ! Optional subscript type exists; type_spec1 points to it.
		    SUBSCR_VECT[.I - 1] = FIND_TYPREC_FROM_TSPEC(.TYPE_SPEC1);
		    TYPE_SPEC1 = .TYPE_SPEC1 + 2 + .TYPE_SPEC1[DST$W_TS_LENGTH];
		    END

		ELSE
		    SUBSCR_VECT[.I-1] = 0;

		END;

	    END;

	END;

    RETURN;

    END;

GLOBAL ROUTINE DBG$STA_TYP_ATOMIC(TYPEID, TYPECODE, BITSIZE): NOVALUE =
!
! FUNCTION
!	This routine returns the VAX standard type code ("one-byte type code")
!	and the bit length for a specified atomic data type.
!
! INPUTS
!	TYPEID	- The Type ID of an Atomic data type whose VAX standard type
!		  code is to be returned.  This data type must have the Format
!		  Code RST$K_TYPE_ATOMIC.
!
!	TYPECODE - The address of a longword location to receive the type code.
!
!	BITSIZE	 - The address of a longword location to receive the bit length
!		   of an item of this type.
!
! OUTPUTS
!	TYPECODE - The VAX standard type code for the specified data type is
!		  returned to TYPECODE.
!
!	BITSIZE	 - The bit length is returned to BITSIZE.
!
!	No value is returned.
!

    BEGIN

    MAP
	TYPEID: REF RST$ENTRY;		! The input TYPEID for the atomic type

    LOCAL
	FCODE,
	SIZE,
	DST_PTR : REF DST$RECORD,
	TYPE_SPEC : REF DST$TYPE_SPEC,
	TYPEID_PTR : REF RST$ENTRY;



    TYPEID_PTR = FIND_TYPE_RECORD(.TYPEID, FCODE, SIZE);
    IF .FCODE NEQ RST$K_TYPE_ATOMIC
    THEN
	$DBG_ERROR('RSTTYPES\TYP_ATOMIC');

    DST_PTR = .TYPEID_PTR[RST$L_DSTPTR];
    TYPE_SPEC = DST_PTR[DST$A_TYPSPEC_TS_ADDR] + .DST_PTR[DST$B_TYPSPEC_NAME];
    .TYPECODE = .TYPE_SPEC[DST$B_TS_ATOM_TYP];
    .BITSIZE = .SIZE;
    IF (..TYPECODE EQL DSC$K_DTYPE_T) AND (.SIZE EQL 0) THEN .BITSIZE = %BPUNIT;
    RETURN;

    END;

GLOBAL ROUTINE DBG$STA_TYP_DESCR(TYPEID, DSCADDR): NOVALUE =
!
! FUNCTION
!	This routine returns the address of a VAX standard descriptor for a
!	specified descriptor-defined data type.
!
! INPUTS
!	TYPEID	- The Type ID of the data type whose descriptor is to be
!		  returned.  Its Format Code must be RST$K_TYPE_DESCR.
!
!	DSCADDR	- The address of a longword location to receive the descriptor
!		  address.
!
! OUTPUTS
!	DSCADDR	- A pointer to the data type's VAX standard descriptor is
!		  returned to DSCADDR.  This descriptor may not survive past
!		  the end of the current command.
!
!	No value is returned.
!

    BEGIN

    MAP
	TYPEID : REF RST$ENTRY;		! The input TYPEID for the descriptor
					!      data type

    LOCAL
	SIZE,
	FCODE,
	DSC_PTR,
	TYPE_SPEC : REF DST$TYPE_SPEC,
	DST_PTR : REF DST$RECORD,
	TYPEID_PTR : REF RST$ENTRY,
	VALKIND,
	VAL_VECT : VECTOR[3],
	VAL_PTR : REF DST$VAL_SPEC;



    TYPEID_PTR = FIND_TYPE_RECORD(.TYPEID, FCODE, SIZE);
    IF .FCODE NEQ RST$K_TYPE_DESCR THEN $DBG_ERROR('RSTTYPES\TYP_DESCR 10');
    DST_PTR = .TYPEID_PTR[RST$L_DSTPTR];
    TYPE_SPEC = DST_PTR[DST$A_TYPSPEC_TS_ADDR] + .DST_PTR[DST$B_TYPSPEC_NAME];
    TYPE_SPEC = FIND_TYPESPEC(.TYPE_SPEC, SIZE, DST_PTR);
    VAL_PTR = TYPE_SPEC[DST$A_TS_DSC_VSPEC_ADDR];
    DBG$STA_VALSPEC(.VAL_PTR, VAL_VECT, VALKIND);
    IF .VALKIND NEQ DBG$K_VAL_DESCR THEN $DBG_ERROR('RSTTYPES\TYP_DESCR 20');
    .DSCADDR = .VAL_VECT[0];
    RETURN;

    END;

GLOBAL ROUTINE DBG$STA_TYP_ENUM(TYPEID, NELTS, ELTVECPTR, BITSIZE): NOVALUE =
!
! FUNCTION
!	This routine returns information about a specified enumeration type.
!	The type is identified by a Type ID, and the returned information
!	includes the number of enumeration elements, a vector of SYMIDs
!	for all the elements, and the bit length of an element of this type.
!	(Each "element" is a constant of the enumeration type in this terminology.)
!
! INPUTS
!	TYPEID	- The Type ID of the Enumeration type whose information is to
!		  be returned.  Its Format Code must be RST$K_TYPE_ENUM.
!
!	NELTS	- The address of a longword location to receive the number of
!		  constants there are of the enumeration type.
!
!	ELTVECPTR - The address of a longword location to receive a pointer to
!		  a vector of SYMIDs for the enumeration type elements.
!
!	BITSIZE	- The address of a longword location to receive the bit length of
!		  an item of this type.
!
! OUTPUTS
!	NELTS	- The number of enumeration type "elements" (i.e., the number of
!		  distinct values of the type) is returned to NELTS.
!
!	ELTVECPTR - A pointer to a vector of SYMIDs for the enumeration type
!		  elements is returned to ELTVECPTR.  The elements are stored
!		  in order of their values.  Each element's SYMID can then be
!		  used to extract the element's name and value.  This vector
!		  disappears at the end of the current Debug command.
!
!	BITSIZE	- The bit length is returned to BITSIZE.
!
!	No value is returned.
!

    BEGIN

    MAP
	TYPEID : REF RST$ENTRY;		! The input TYPEID for the enumeration
					!     type

    LOCAL
	TYPEID_PTR : REF RST$ENTRY,
	FCODE,
    	SIZE;



    TYPEID_PTR = FIND_TYPE_RECORD(.TYPEID, FCODE, SIZE);
    IF .FCODE NEQ RST$K_TYPE_ENUM THEN $DBG_ERROR('RSTTYPES\TYP_ENUM');
    .NELTS = .TYPEID_PTR[RST$L_TYPCOMPCNT];
    .ELTVECPTR = TYPEID_PTR[RST$A_TYPCOMPLST];
    .BITSIZE = .SIZE;
    RETURN;

    END;

GLOBAL ROUTINE DBG$STA_TYP_PICT(TYPEID, LANGCODE, PICTPTR, PICTVAL, PSCALE): NOVALUE =
!
! FUNCTION
!	This routine returns information about a Picture data type (as used in
!	Cobol and PL/I).  The input data type is represented by a Type ID, and
!	the picture's language code and picture string are returned as output.
!
! INPUTS
!	TYPEID	- The Type ID of the Picture data type whose information is to
!		  be returned.  Its Format Code must be RST$K_TYPE_PICT.
!
!	LANGCODE - The address of a longword location to receive the language
!		  code.
!
!	PICTPTR	- The address of a longword location to receive a pointer to the
!		  picture itself.
!
!	PICTVAL	- The address of a longword location to receive a pointer to the
!		  language-specific picture encoding.
!
!	PSCALE	- (Optional) The address of a longword to receive the
!		   scale factor and digit-count for this picture.
! OUTPUTS
!	LANGCODE - The picture language code is returned to LANGCODE.
!
!	PICTPTR	- A pointer to the picture itself, represented as a Counted
!		  ASCII string, is returned to PICTPTR.
!
!	PICTVAL	- A pointer to the language-specific picture encoding is returned
!		  to PICTVAL; if no such encoding exists, zero is returned.
!
!	No value is returned.
!

    BEGIN

    BUILTIN
	ACTUALCOUNT;

    MAP
	TYPEID : REF RST$ENTRY;		! The input TYPEID for the picture type

    LOCAL
	TYPEID_PTR : REF RST$ENTRY,
	FCODE,
	DST_PTR : REF DST$RECORD,
	SIZE,
	VALKIND,
	VAL_SPEC,
	VAL_VECT : VECTOR[3],
	TYPE_SPEC : REF DST$TYPE_SPEC;



    TYPEID_PTR = FIND_TYPE_RECORD(.TYPEID, FCODE, SIZE);
    IF .FCODE NEQ RST$K_TYPE_PICT THEN $DBG_ERROR('RSTTYPES\TYP_PICT');
    DST_PTR = .TYPEID_PTR[RST$L_DSTPTR];
    TYPE_SPEC = DST_PTR[DST$A_TYPSPEC_TS_ADDR] + .DST_PTR[DST$B_TYPSPEC_NAME];
    TYPE_SPEC = FIND_TYPESPEC(.TYPE_SPEC, SIZE, DST_PTR);
    .LANGCODE = .TYPE_SPEC[DST$B_TS_PIC_LANG];
    .PICTPTR = TYPE_SPEC[DST$A_TS_PIC_ADDR];
    IF .TYPE_SPEC[DST$W_TS_LENGTH] GTR .TYPE_SPEC[DST$B_TS_PIC_PLENG] + 3
    THEN
	BEGIN
	VAL_SPEC = ..PICTPTR + .TYPE_SPEC[DST$B_TS_PIC_PLENG];
	DBG$STA_VALSPEC(.VAL_SPEC, VAL_VECT, VALKIND);
	.PICTVAL = .VAL_VECT[0];
	IF (..LANGCODE EQL DBG$K_COBOL) AND ACTUALCOUNT() GTR 4
	THEN
	    .PSCALE=.(.TYPE_SPEC+.TYPE_SPEC[DST$W_TS_LENGTH])<0,16,0>;

	END

    ELSE
	.PICTVAL = 0;

    RETURN;

    END;

GLOBAL ROUTINE DBG$STA_TYP_TYPEDPTR(TYPEID, REFTYPEID): NOVALUE =
!
! FUNCTION
!	This routine accepts as input the Type ID of a Typed Pointer data type
!	and returns the Type ID of the data type it points to.
!
! INPUTS
!	TYPEID	- The Type ID of the Typed Pointer type whose referenced type
!		  is to be returned.  Its Format Code must be RST$K_TYPE_TPTR.
!
!	REFTYPEID - The address of a longword location to receive the pointed-to
!		  data type's Type ID.
!
! OUTPUTS
!	REFTYPEID - The Type ID of the data type which is pointed to by the
!		  TYPEID Typed Pointer type is returned to REFTYPEID.
!
!	No value is returned.
!

    BEGIN

    MAP
	TYPEID: REF RST$ENTRY;		! The input TYPEID of the Typed Pointer
					!      data type

    LOCAL
	FCODE,
	TYPEID_PTR: REF RST$ENTRY,
	SIZE,
	DST_PTR: REF DST$RECORD,
	TYPE_SPEC: REF DST$TYPE_SPEC;



    TYPEID_PTR = FIND_TYPE_RECORD(.TYPEID, FCODE, SIZE);
    IF .FCODE NEQ RST$K_TYPE_TPTR THEN $DBG_ERROR('RSTTYPES\TYP_TYPEDPTR');
    DST_PTR = .TYPEID_PTR[RST$L_DSTPTR];
    TYPE_SPEC = DST_PTR[DST$A_TYPSPEC_TS_ADDR] + .DST_PTR[DST$B_TYPSPEC_NAME];
    TYPE_SPEC = FIND_TYPESPEC(.TYPE_SPEC, SIZE, DST_PTR);
    TYPE_SPEC = TYPE_SPEC[DST$A_TS_TPTR_TSPEC_ADDR];
    .REFTYPEID = FIND_TYPREC_FROM_TSPEC(.TYPE_SPEC);
    RETURN;

    END;

GLOBAL ROUTINE DBG$STA_TYP_FILE(TYPEID, LANGUAGE, RECTYPEID): NOVALUE =
!
! FUNCTION
!	This routine accepts as input the Type ID of a File data type
!	and returns the associated language code and record-type typeid.
!
! INPUTS
!	TYPEID	- The Type ID of the File type.
!		  Its Format Code must be RST$K_TYPE_FILE.
!
!	LANGUAGE - The address of a longword location to receive the File
!		  type's LANGUAGE code.
!
!	RECTYPEID - The address of a longword location to receive
!		    the typeid for the File's record type.
!
! OUTPUTS
!	LANGUAGE - The File type's language code.
!
!	RECTYPEID - The File's record-type typeid is returned to RECTYPEID.
!
!	No value is returned.
!

    BEGIN

    MAP
	TYPEID: REF RST$ENTRY;		! The input TYPEID of the file type

    LOCAL
	DST_PTR: REF DST$RECORD,
	TYPE_SPEC: REF DST$TYPE_SPEC,
	TYPEID_PTR: REF RST$ENTRY,
	SIZE,
	FCODE;



    TYPEID_PTR = FIND_TYPE_RECORD(.TYPEID, FCODE, SIZE);
    IF .FCODE NEQ RST$K_TYPE_FILE THEN $DBG_ERROR('RSTTYPES\TYP_FILE');
    DST_PTR = .TYPEID_PTR[RST$L_DSTPTR];
    TYPE_SPEC = DST_PTR[DST$A_TYPSPEC_TS_ADDR] + .DST_PTR[DST$B_TYPSPEC_NAME];
    TYPE_SPEC = FIND_TYPESPEC(.TYPE_SPEC, SIZE, DST_PTR);
    .LANGUAGE = .TYPE_SPEC[DST$B_TS_FILE_LANG];
    IF .TYPE_SPEC[DST$W_TS_LENGTH] GTR 2
    THEN
	BEGIN
	TYPE_SPEC = TYPE_SPEC[DST$A_TS_FILE_RCRD_TYP];
	.RECTYPEID = FIND_TYPREC_FROM_TSPEC(.TYPE_SPEC);
	END

    ELSE
	.RECTYPEID = 0;

    RETURN;

    END;

GLOBAL ROUTINE DBG$STA_TYP_RECORD(TYPEID, NCOMPS, COMPVECPTR, BITSIZE): NOVALUE =
!
! FUNCTION
!	This routine accepts as input a Type ID for a record (or "structure")
!	data type, and returns the number of record components, a vector of
!	record component SYMIDs, and the bit length of the record as output.
!	The record component SYMIDs can then be used as input to other symbol
!	table access routines to extract the component names, types, and values.
!
! INPUTS
!	TYPEID	- The Type ID of the Record data type whose component informa-
!		  tion is to be returned.  The Format Code of this data type
!		  must be RST$K_TYPE_RECORD.
!
!	NCOMPS	- The address of a longword location to receive the number of
!		  record components associated with the specified data type.
!
!	COMPVECPTR - The address of a longword location to receive a pointer to
!		  a vector of component information.
!
!	BITSIZE	- The address of a longword location to receive the bit length
!		  of the record.
!
! OUTPUTS
!	NCOMPS	- The number of record components is returned to NCOMPS.
!
!	COMPVECPTR - A pointer to a vector of record component SYMIDs is re-
!		  turned to COMPVECPTR.  There is one SYMID for each record
!		  component in the vector; this SYMID can then be used to
!		  extract the component's data type, name, or value (offset
!		  from the start of the record).  This vector disappears at
!		  the end of the current Debug command.
!
!	BITSIZE	- The record's bit length is returned to BITSIZE.
!
!	No value is returned.
!

    BEGIN

    MAP
	TYPEID: REF RST$ENTRY;		! The input TYPEID of the record type

    LOCAL
	TYPEID_PTR: REF RST$ENTRY,
	FCODE,
    	SIZE;



    TYPEID_PTR = FIND_TYPE_RECORD(.TYPEID, FCODE, SIZE);
    IF .FCODE NEQ RST$K_TYPE_RECORD THEN $DBG_ERROR('RSTTYPES\TYP_RECORD');
    .NCOMPS = .TYPEID_PTR[RST$L_TYPCOMPCNT];
    .COMPVECPTR = TYPEID_PTR[RST$A_TYPCOMPLST];
    .BITSIZE = .SIZE;
    RETURN;

    END;

GLOBAL ROUTINE DBG$STA_TYP_SET(TYPEID, PARENT_TYPE, BITSIZE, OFFSET): NOVALUE =
!
! FUNCTION
!	This routine accepts as input the Type ID of a Set data type (as in
!	Pascal, for example), and returns the set's length and parent data
!	type as output.  A set is always assumed to consist of a bit string
!	where each bit represents one member of the parent type.  The parent
!	data type, i.e. the data type of the set elements, can be any ordinal
!	type (such as integer, enumeration type, character, etc.).
!
! INPUTS
!	TYPEID	- The Type ID of the Set type whose attributes are to be
!		  returned.  Its Format Code must be RST$K_TYPE_SET.
!
!	PARENT_TYPE - The address of a longword location to receive the Type ID
!		  of the set's parent type.
!
!	BITSIZE	- The address of a longword location to receive the length of
!		  the set.
!
!	OFFSET	- (optional parameter) The address of a longword location to
!		  receive the virtual bit index of the first allocated bit
!
! OUTPUTS
!	PARENT_TYPE - The Type ID of the set's parent type (i.e., the data type
!		  of the set elements) is returned to PARENT_TYPE.
!
!	BITSIZE	- The length of the set type (in bits used to represent the
!		  set) is returned to BITSIZE.
!
!	OFFSET	- If this optional parameter was specified, the bit number of
!		  the first allocated bit is returned to OFFSET.  Currently
!		  all SETs are allocated starting at bit zero - this parameter
!		  is provided for future expansion.
!
!	No value is returned.
!

    BEGIN

    BUILTIN
	ACTUALCOUNT;

    MAP
	TYPEID : REF RST$ENTRY;		! The input TYPEID of the set type

    LOCAL
	FCODE,
	TYPEID_PTR: REF RST$ENTRY,
	DST_PTR: REF DST$RECORD,
	SIZE,
    	SIZETMP,
	TYPE_SPEC: REF DST$TYPE_SPEC;



    TYPEID_PTR = FIND_TYPE_RECORD(.TYPEID, FCODE, SIZE);
    IF .FCODE NEQ RST$K_TYPE_SET THEN $DBG_ERROR('RSTTYPES\TYP_SET');
    DST_PTR = .TYPEID_PTR[RST$L_DSTPTR];
    TYPE_SPEC = DST_PTR[DST$A_TYPSPEC_TS_ADDR] + .DST_PTR[DST$B_TYPSPEC_NAME];
    TYPE_SPEC = FIND_TYPESPEC(.TYPE_SPEC, SIZETMP, DST_PTR);
    TYPE_SPEC = TYPE_SPEC[DST$A_TS_SET_PAR_TSPEC_ADDR];
    .PARENT_TYPE = FIND_TYPREC_FROM_TSPEC(.TYPE_SPEC);
    .BITSIZE = .SIZE;
    IF ACTUALCOUNT() GEQ 4 THEN .OFFSET = 0;
    RETURN;

    END;

GLOBAL ROUTINE DBG$STA_TYP_SUBRNG(TYPEID, PARENT_TYPE, LOWPTR, HIGHPTR,
						BITSIZE): NOVALUE =
!
! FUNCTION
!	This routine accepts the Type ID of a Subrange data type (as in Pascal,
!	for instance) as input, and returns that type's parent type, subrange
!	interval, and bit length.  The parent type can be any data type with
!	values of reasonable size (e.g., anything that can be represented as an
!	integer or real	value), and the subrange interval is returned as
!	pointers to the lower bound value and the upper bound value.  Both
!	values are assumed to be of the parent type.
!
! INPUTS
!	TYPEID	- The Type ID of the Subrange data type whose attributes are to
!		  be returned.  Its Format Code must be RST$K_TYPE_SUBRNG.
!
!	PARENT_TYPE - The address of a longword location to receive the returned
!		  Type ID of subrange's parent type.
!
!	LOWPTR	- The address of a longword location to receive a pointer to the
!		  lower bound value of the subrange.
!
!	HIGHPTR	- The address of a longword location to receive a pointer to the
!		  upper bound value of the subrange.
!
!	BITSIZE	- The address of a longword location to receive the length in bits
!		  of an item of this type.
!
! OUTPUTS
!	PARENT_TYPE - The Type ID of the subrange's parent type (i.e., the data
!		  type of which this is a subrange) is returned to PARENT_TYPE.
!
!	LOWPTR	- A pointer to the lower bound value of the subrange is returned
!		  to LOWPTR.  This value must be interpreted as being of the
!		  parent type.  The value disappears at the end of the current
!		  Debug command.
!
!	HIGHPTR	- A pointer to the upper bound value of the subrange is returned
!		  to HIGHPTR.  This value must be intepreted as being of the
!		  parent type.  The value disappears at the end of the current
!		  Debug command.
!
!	BITSIZE	- The length in bits is returned to BITSIZE.
!
!	No value is returned.
!

    BEGIN

    MAP
	TYPEID: REF RST$ENTRY;		! The input TYPEID of the subrange type

    LOCAL
	SIZE,
    	SIZETMP,
	TYPEID_PTR: REF RST$ENTRY,
	TYPE_SPEC: REF DST$TYPE_SPEC,
	VAL_PTR: REF DST$VAL_SPEC,
	DST_PTR: REF DST$RECORD,
	VAL_VECT: VECTOR[3],
	VALKIND,
	FCODE;



    TYPEID_PTR = FIND_TYPE_RECORD(.TYPEID, FCODE, SIZE);
    IF .FCODE NEQ RST$K_TYPE_SUBRNG THEN $DBG_ERROR('RSTTYPES\TYP_SUBRNG');
    DST_PTR = .TYPEID_PTR[RST$L_DSTPTR];
    TYPE_SPEC = DST_PTR[DST$A_TYPSPEC_TS_ADDR] + .DST_PTR[DST$B_TYPSPEC_NAME];
    TYPE_SPEC = FIND_TYPESPEC(.TYPE_SPEC, SIZETMP, DST_PTR);
    TYPE_SPEC = TYPE_SPEC[DST$A_TS_SUBR_PAR_TSPEC_ADDR];
    .PARENT_TYPE = FIND_TYPREC_FROM_TSPEC(.TYPE_SPEC);
    VAL_PTR = .TYPE_SPEC + .TYPE_SPEC[DST$W_TS_LENGTH] + 2;
    DBG$STA_VALSPEC(.VAL_PTR, VAL_VECT, VALKIND);
    .LOWPTR = .VAL_VECT[0];
    IF .VAL_PTR[DST$B_VS_VFLAGS] EQL DST$K_VS_FOLLOWS
    THEN
	VAL_PTR = .VAL_PTR + .VAL_PTR[DST$W_VS_LENGTH] + 3

    ELSE
	VAL_PTR = .VAL_PTR + 5;

    DBG$STA_VALSPEC(.VAL_PTR, VAL_VECT, VALKIND);
    .HIGHPTR = .VAL_VECT[0];
    .BITSIZE = .SIZE;

    RETURN;

    END;

GLOBAL ROUTINE DBG$STA_TYP_OFFSET(TYPEID, AREA_ADDR, AREA_LEN): NOVALUE =
!
! FUNCTION
!	This routine accepts as input the Type ID of an Offset data type and
!	it returns the address and length of the associated Area.  Areas and
!	Offsets are PL/I data types.
!
! INPUTS
!	TYPEID	- The Type ID of the Offset data type whose attributes are to be
!		  returned.  Its Format Code must be RST$K_TYPE_OFFSET.
!
!	AREA_ADDR - The address of a longword location to receive the byte
!		  address of the Area associated with this Offset.
!
!	AREA_LEN - The address of a longword location to receive the byte
!		  length of the Area associated with this Offset.
!
! OUTPUTS
!	AREA_ADDR - The byte address of the Area associated with this Offset
!		  is returned to AREA_ADDR.
!
!	AREA_LEN - The byte length of the Area associated with this Offset
!		  is returned to AREA_LEN.
!
!	No routine value is returned.
!
!
    BEGIN

    MAP
	TYPEID: REF RST$ENTRY,		! Pointer to the input Type RST Entry
	AREA_ADDR: REF VECTOR[1],	! Address where we return Area address
	AREA_LEN: REF VECTOR[1];	! Address where we return Area length

    LOCAL
	DSTPTR: REF DST$RECORD,		! Pointer to Offset Type Spec DST record
	FCODE,				! The Format Code for this data type
	SIZE,				! The bit size of this data object
	TSPTR: REF DST$TYPE_SPEC,	! Pointer to DST Type Spec for Offset
	TYPEPTR: REF RST$ENTRY,		! Pointer to the offset Type RST Entry
	VALKIND,			! The kind of value returned by the
					!      DBG$STA_VALSPEC routine
	VALPTR: REF VECTOR[,LONG],	! Pointer to the Area length value
	VALVECTOR: VECTOR[3,LONG],	! Three-longword value vector returned
					!      by the DBG$STA_VALSPEC routine
	VSPTR: REF DST$VAL_SPEC;	! Pointer to Value Specs in the DST Type
					!      Spec for Offset



    ! In case the caller passed in a SYMID for the Offset symbol instead of its
    ! Type ID, we get the symbol's actual Type ID here.  We also make sure we
    ! really have an Offset data type.
    !
    TYPEPTR = FIND_TYPE_RECORD(.TYPEID, FCODE, SIZE);
    IF .FCODE NEQ RST$K_TYPE_OFFSET
    THEN
	$DBG_ERROR('RSTTYPES\TYP_OFFSET');


    ! Get a pointer to the Type Spec DST Record and get a pointer to the actual
    ! Type Spec within it (possibly after Type Spec indirection).
    !
    DSTPTR = .TYPEPTR[RST$L_DSTPTR];
    TSPTR = DSTPTR[DST$A_TYPSPEC_TS_ADDR] + .DSTPTR[DST$B_TYPSPEC_NAME];
    TSPTR = FIND_TYPESPEC(.TSPTR, SIZE, DSTPTR);


    ! Evaluate the first Value Spec in the Offset Type Spec.  Return the result
    ! (i.e., the address of the Area) to the AREA_ADDR parameter.
    !
    VSPTR = TSPTR[DST$A_TS_OFFSET_VALSPEC];
    DBG$STA_VALSPEC(.VSPTR, VALVECTOR, VALKIND);
    AREA_ADDR[0] = .VALVECTOR[0];


    ! Get to the second Value Spec in the Offset Type Spec and evaluate it.
    ! Return its result (i.e., the length of the Area) to AREA_LEN.
    !
    IF .VSPTR[DST$B_VS_VFLAGS] EQL DST$K_VS_FOLLOWS
    THEN
	VSPTR = VSPTR[DST$B_VS_ALLOC] + .VSPTR[DST$W_VS_LENGTH]

    ELSE
	VSPTR = .VSPTR + 5;

    DBG$STA_VALSPEC(.VSPTR, VALVECTOR, VALKIND);
    VALPTR = .VALVECTOR[0];
    AREA_LEN[0] = .VALPTR[0];


    ! We are all done--return to the caller.
    !
    RETURN;

    END;

GLOBAL ROUTINE DBG$STA_TYP_AREA(TYPEID, BYTE_LEN): NOVALUE =
!
! FUNCTION
!	This routine accepts as input the Type ID of an AREA data type
!	and returns the byte length of the AREA.
!
! INPUTS
!	TYPEID	- The Type ID of the AREA data type whose attributes are to be
!		  returned.  Its Format Code must be RST$K_TYPE_AREA.
!
!	BYTE_LEN - The address of a longword location to receive a pointer
!		  to the byte length of the AREA.
!
! OUTPUTS
!	BYTE_LEN - A pointer to the byte length of the AREA is returned to
!		    BYTE_LEN
!
!
!	No value is returned.
!
!
    BEGIN

    MAP
	TYPEID: REF RST$ENTRY;		! The input TYPEID of the PL/I AREA type

    LOCAL
	TYPEID_PTR: REF RST$ENTRY,
	DST_PTR: REF DST$RECORD,
	TYPE_SPEC: REF DST$TYPE_SPEC,
	VAL_SPEC: REF DST$VAL_SPEC,
	VALKIND,
	FCODE,
	VAL_VECT: VECTOR[3],
	SIZE;



    TYPEID_PTR = FIND_TYPE_RECORD(.TYPEID, FCODE, SIZE);
    IF .FCODE NEQ RST$K_TYPE_AREA THEN $DBG_ERROR('RSTTYPES\TYP_AREA');
    DST_PTR = .TYPEID_PTR[RST$L_DSTPTR];
    TYPE_SPEC = DST_PTR[DST$A_TYPSPEC_TS_ADDR] + .DST_PTR[DST$B_TYPSPEC_NAME];
    TYPE_SPEC = FIND_TYPESPEC(.TYPE_SPEC, SIZE, DST_PTR);
    IF .SIZE EQL 0
    THEN
	BEGIN
	VAL_SPEC = TYPE_SPEC[DST$A_TS_AREA_BYTE_LEN];
	DBG$STA_VALSPEC(.VAL_SPEC, VAL_VECT, VALKIND);
	.BYTE_LEN = .VAL_VECT[0];
	END

    ELSE
	.BYTE_LEN = .SIZE;

    RETURN;

    END;

GLOBAL ROUTINE DBG$STA_TYP_VARIANT(TYPEID, NCOMPS, COMPVECPTR, TAG,
						BITSIZE): NOVALUE =
!
! FUNCTION
!	This routine accepts as input the Type ID of a Variant data type or the
!	SYMID of a symbol of variant type, and it returns the number of variant
!	components, the SYMID of each such component, and the SYMID of the vari-
!	ant's tag field.
!
! INPUTS
!	TYPEID	- The Type ID of the Variant data type whose attributes and var-
!		  iants are to be returned.  The Kind of this data type
!		  must be RST$K_VARIANT.
!
!	NCOMPS	- The address of a longword location to receive the number of
!		  variant components of the TYPEID data type.
!
!	COMPVECPTR - The address of a longword location to receive a pointer to
!		  a vector of variant component SYMIDs and tag values.
!
!	TAG	- The address of a longword location to receive the SYMID of the
!		  Variant data type's tag field.
!
!	BITSIZE	- The address of a longword location to receive the size in bits
!		  of an item of this type.
!
! OUTPUTS
!	NCOMPS	- The number of components of the Variant data type (the number
!		  of different "variants") is returned to NCOMPS.
!
!	COMPVECPTR - A pointer to a vector of variant component information is
!		  returned to COMPVECPTR.  In this vector, there is a two-long-
!		  word entry for each variant component; each such entry gives
!		  the SYMID and a pointer to the tag value, respectively, of
!		  the corresponding component.  The SYMID can then be used to
!		  extract the component's name, data type, and value.  The tag
!		  value must be intepreted as a value of tag field's data type.
!		  This vector disappears at the end of the current command.
!
!	TAG	- The SYMID of the variant tag field is returned to TAG.  This
!		  SYMID can be used to extract the tag field name, data type,
!		  and value.
!
!	BITSIZE	- The size in bits of an item of this type is returned to
!		  BITSIZE.
!
!	No value is returned.
!

    BEGIN

    MAP
	TYPEID : REF RST$ENTRY;		! Pointer to Variant RST Entry

    LOCAL
	DSTPTR: REF DST$RECORD,
	TYPEID_PTR: REF RST$ENTRY,
	FCODE,
    	SIZE;



    TYPEID_PTR = FIND_TYPE_RECORD(.TYPEID, FCODE, SIZE);
    IF .FCODE NEQ RST$K_VARIANT THEN $DBG_ERROR('RSTTYPES\TYP_VARIANT');
    .NCOMPS = .TYPEID_PTR[RST$L_VARSETCNT];
    .COMPVECPTR = TYPEID_PTR[RST$A_VARSETTBL];
    .TAG = .TYPEID_PTR[RST$L_VARTAGPTR];
    .BITSIZE = .SIZE;
    RETURN;

    END;

GLOBAL ROUTINE DBG$STA_TYP_VARIANT_COMP(LIST_ID, NCOMPS, COMPVECPTR,
					NTAGS, TAGVECPTR, SIZE): NOVALUE =
!
! FUNCTION
!	This routine accepts as input a pointer to a set of Variant fields,
!	and it returns the number of fields, the SYMID for each field, the number
!	of tag blocks, a value range for each tag block, and the bit length of
!	the variant.
!
! INPUTS
!	LIST_ID	- A pointer to a list of variant fields; this list was produced
!		  by DBG$STA_TYP_VARIANT and was pointed to by one element of
!		  the COMPVECPTR it returned.
!
!	NCOMPS	- The address of a longword location to receive the number of
!		  fields in this variant.
!
!	COMPVECPTR - The address of a longword location to receive a pointer to
!		  a vector of field SYMIDs.
!
!	NTAGS	- The address of a longword location to receive the number of
!		  tag blocks.
!
!	TAGVECPTR - The address of a longword location to receive a pointer to a
!		    vector of tag value ranges. An element of this vector is the
!		    address of a three longword block; each block has the following
!		    format:
!			longword 1: dst$k_varval_single = single tag value
!						or
!				    dst$k_varval_range = range of tag values
!			longword 2: pointer to low bound value of tag range
!			longword 3: pointer to high bound value of tag range
!				    (or zero if single value)
!
!	SIZE	- The address of a longword location to receive the size in bits
!		  of an item of this type.
!
! OUTPUTS
!	NCOMPS	- The number of fields is returned to NCOMPS.
!
!	COMPVECPTR - A pointer to a vector of field SYMIDs is returned to
!		  COMPVECPTR.
!		  This vector disappears at the end of the current command.
!
!	NTAGS	- The number of tag blocks is returned to NTAGS.
!
!	SIZE	- The size in bits of this variant is returned to SIZE.
!
!	No value is returned.
!

    BEGIN

    MAP
	LIST_ID: REF RST$VAR_ENTRY;	! Pointer to Variant Component List Entry

    LOCAL
	TAG_LIST: REF RST$TAG_LIST,
	TAG_PTR: REF VECTOR[,BYTE],
	DST_PTR: REF DST$RECORD,
	VALUE_SPEC: REF DST$VAL_SPEC,
	VAL_LNGTH,
	VAL_VECT: VECTOR[3],
	VALKIND;



    DST_PTR = .LIST_ID[RST$L_VAR_DSTPTR];
    IF .DST_PTR[DST$B_TYPE] NEQ DST$K_VARVAL
    THEN
	$DBG_ERROR('RSTTYPES\VARIANT_COMP');

    .NCOMPS = .LIST_ID[RST$L_VAR_COMPCNT];
    .NTAGS = .DST_PTR[DST$W_VARVAL_COUNT];
    .SIZE = .DST_PTR[DST$L_VARVAL_SIZE];
    IF ..NCOMPS NEQ 0
    THEN
	.COMPVECPTR = LIST_ID[RST$A_VAR_COMPLST]
    ELSE
	.COMPVECPTR = 0;

    TAG_LIST = DBG$GET_TEMPMEM(RST$K_TAG_BLOCK_SIZE * ..NTAGS);
    TAG_PTR = DST_PTR[DST$A_VARVAL_RNGSPEC];
    INCR I FROM 0 TO ..NTAGS - 1 DO
	BEGIN
	VALUE_SPEC = TAG_PTR[1];
	TAG_LIST[.I,RST$L_TAG_NUMVALS] = .TAG_PTR[0];
	DBG$STA_VALSPEC(.VALUE_SPEC, VAL_VECT, VALKIND);
	TAG_LIST[.I,RST$L_TAG_LOWBOUND] = .VAL_VECT[0];
	VAL_LNGTH = 5;
	IF .VALUE_SPEC[DST$B_VS_VFLAGS] EQL DST$K_VS_FOLLOWS
	THEN
	    VAL_LNGTH = .VALUE_SPEC[DST$W_VS_LENGTH] + 3;

	IF .TAG_PTR[0] EQL DST$K_VARVAL_RANGE
	THEN
	    BEGIN
	    VALUE_SPEC = .TAG_PTR + .VAL_LNGTH + 1;
	    DBG$STA_VALSPEC(.VALUE_SPEC, VAL_VECT, VALKIND);
	    TAG_LIST[.I,RST$L_TAG_HIGHBOUND] = .VAL_VECT[0];
	    VAL_LNGTH = 5;
	    IF .VALUE_SPEC[DST$B_VS_VFLAGS] EQL DST$K_VS_FOLLOWS
	    THEN
		VAL_LNGTH = .VALUE_SPEC[DST$W_VS_LENGTH] + 3;

	    TAG_PTR = .TAG_PTR + .VAL_LNGTH;
	    END

	ELSE
	    TAG_PTR = .TAG_PTR + .VAL_LNGTH + 1;

	END;

    .TAGVECPTR = .TAG_LIST;
    RETURN;

    END;

GLOBAL ROUTINE DBG$TRANS_TYPE_CODE(CODE) =
!
! FUNCTION
!	This routine takes a DST type code and translates it to the
!	corresponding RST type code.
!
! INPUTS
!	CODE	- The DST type code to be translated.
!
! OUTPUTS
!	The corresponding RST type code is returned as the routine's value.
!

    BEGIN

    CASE .CODE FROM DST$K_TS_DTYPE_LOWEST TO DST$K_TS_DTYPE_HIGHEST OF
	SET

	[DST$K_TS_ATOM]:
	    RETURN RST$K_TYPE_ATOMIC;

	[DST$K_TS_DSC]:
	    RETURN RST$K_TYPE_DESCR;

	[DST$K_TS_TPTR]:
	    RETURN RST$K_TYPE_TPTR;

	[DST$K_TS_PTR]:
	    RETURN RST$K_TYPE_PTR;

	[DST$K_TS_PIC]:
	    RETURN RST$K_TYPE_PICT;

	[DST$K_TS_ARRAY]:
	    RETURN RST$K_TYPE_ARRAY;

	[DST$K_TS_SET]:
	    RETURN RST$K_TYPE_SET;

	[DST$K_TS_SUBRANGE]:
	    RETURN RST$K_TYPE_SUBRNG;

	[DST$K_TS_FILE]:
	    RETURN RST$K_TYPE_FILE;

	[DST$K_TS_SELF_REL_LABEL]:
	    RETURN RST$K_TYPE_SELF_REL_LAB;

	[DST$K_TS_RFA]:
	    RETURN RST$K_TYPE_RFA;

    	[DST$K_TS_AREA]:
    	    RETURN RST$K_TYPE_AREA;

    	[DST$K_TS_OFFSET]:
    	    RETURN RST$K_TYPE_OFFSET;

    	[DST$K_TS_TASK]:
    	    RETURN RST$K_TYPE_TASK;

	[INRANGE,OUTRANGE]:
	    RETURN 0;

	TES;

    END;

GLOBAL ROUTINE DBG$TYPEID_FOR_ARRAY(TYPEID, ADDRESS) =
!
! FUNCTION
!	This routine is called from DBGPARSER in the process of parsing
!	a C expression of the form PTR[n], where PTR was declared as
!	a pointer. Since arrays and pointers are treated the same in C,
!	we want to convert the pointer typeid to an equivalent array
!	typeid.
!
! INPUT
!	TYPEID	- The RST entry describing a pointer data type
!	ADDRESS - The value of the pointer (which will be the base
!		  address of the array).
!
! OUTPUT
!	A new typeid is constructed out of temporary memory, and 
!	a pointer to this typeid is returned.
!
! Example:
!	REAL *RPTR;
!	If RPTR is declared as a pointer to a floating number,
!	then if we pass in the TYPEID for RPTR, this routine returns
!	a typeid for an array of floating numbers (e.g., as if we
!	had declared an object
!	REAL RARRAY[n];
!
    BEGIN
    MAP
    	TYPEID: REF RST$ENTRY;		! The input TYPEID for the Type Pointer
					!      data type

    LOCAL
    	ADDRPTR,			! Pointer into array descriptor
    	ARG_DSTPTR: REF DST$RECORD,	! Pointer to DST record for argument
     	ARG_TYPEID: REF RST$ENTRY,	! Pointer to RST record for pointed-to
    					!    object.
    	BITSIZE,			! Bitsize of pointed-to object
    	BOUNDVEC: REF VECTOR[],		! Pointer to array bounds
    	DSCADDR: REF BLOCK[,BYTE],	! Pointer to array descriptor
    	DSTPTR: REF DST$RECORD,		! Pointer to dummy DST record
    	FLAGS_PTR: REF BITVECTOR[],	! "flags" field withing array type spec
    	RSTPTR: REF RST$ENTRY,		! Pointer to new RST record
    	TSPTR: REF DST$TYPE_SPEC,	! Pointer to type spec within DST record
    	TSPTR1: REF DST$TYPE_SPEC,	! Pointer to type spec within DST record
    	TSPTR2: REF DST$TYPE_SPEC,	! Pointer to type spec within DST record
    	VSPTR: REF DST$VAL_SPEC;	! Pointer to val spec within DST record

    
    ! Obtain a TYPEID and a DSTPTR for the pointed-to object.
    !
    DBG$STA_TYP_TYPEDPTR (.TYPEID, ARG_TYPEID);
    DBG$STA_SYMSIZE (.ARG_TYPEID, BITSIZE);
    ARG_DSTPTR = .ARG_TYPEID[RST$L_DSTPTR];

    ! Allocate a memory block large enough to hold the newly created
    ! RST record, the dummy DST record that it will point to, and the
    ! array descriptor for this dummy array we are creating.
    !
    RSTPTR = DBG$GET_MEMORY (RST$K_TYPENTSIZ + 14);	
    DSTPTR = .RSTPTR + 4*RST$K_TYPENTSIZ;

    ! Fill in some of the fields of the RST record.
    !
    RSTPTR[RST$L_DSTPTR] = .DSTPTR;
    RSTPTR[RST$L_UPSCOPEPTR] = .RST$START_ADDR;
    RSTPTR[RST$B_KIND] = RST$K_TYPE;
    RSTPTR[RST$B_FCODE] = RST$K_TYPE_ARRAY;

    ! Put the RST record on the temporary RST list. This will ensure that
    ! the space gets released when there are no more references to it.
    !
    RSTPTR[RST$L_HASH_FLINK] = .RST$TEMP_LIST;
    RST$TEMP_LIST = .RSTPTR;

    ! Fill in the header of the dummy DST record.
    !
    DSTPTR[DST$B_LENGTH] = 23;
    DSTPTR[DST$B_TYPE] = DST$K_TYPSPEC;
    DSTPTR[DST$B_TYPSPEC_NAME] = 0;

    ! Fill in the Type Spec record within the dummy DST record.
    ! This describes the array as a whole.
    !
    TSPTR = .DSTPTR + 3;    
    TSPTR[DST$W_TS_LENGTH] = 19;
    TSPTR[DST$B_TS_KIND] = DST$K_TS_ARRAY;
    TSPTR[DST$B_TS_ARRAY_DIM] = 1;
    FLAGS_PTR = TSPTR[DST$A_TS_ARRAY_FLAGS_ADDR];
    FLAGS_PTR[0] = TRUE;

    ! Fill in the Val Spec record within the dummy DST record.
    ! This points to the array descriptor that we will construct
    ! below this dummy DST record.
    !
    VSPTR = .FLAGS_PTR + 1;
    VSPTR[DST$B_VS_VFLAGS] = DST$K_VFLAGS_DSC;
    VSPTR[DST$L_VS_DSC_OFFS] = 11;

    ! Fill in the celltype type spec record within the dummy DST record.
    ! This describes the type of each element of the array. This type
    ! should be the same as the type of the pointed-to object, so
    ! we use an indirect type specification, and point to the DST
    ! we obtained from the argument.
    !
    TSPTR1 = .VSPTR + 5;
    TSPTR1[DST$W_TS_LENGTH] = 5;
    TSPTR1[DST$B_TS_KIND] = DST$K_TS_IND;
    TSPTR1[DST$L_TS_IND_PTR] = DBG$RST_DST_PTR( .ARG_DSTPTR - .DST$BEGIN_ADDR );					! M006


    ! Fill in the type specification for the type of the subscript.
    ! This type will just be longword integer.
    !
    TSPTR2 = .TSPTR1 + .TSPTR1[DST$W_TS_LENGTH] + 2;
    TSPTR2[DST$W_TS_LENGTH] = 2;
    TSPTR2[DST$B_TS_KIND] = DST$K_TS_ATOM;
    TSPTR2[DST$B_TS_ATOM_TYP] = DSC$K_DTYPE_L;

    ! Fill in the array descriptor.
    !
    DSCADDR = .TSPTR2 + .TSPTR2[DST$W_TS_LENGTH] + 2;
    DSCADDR[DSC$B_CLASS] = DSC$K_CLASS_A;
    DSCADDR[DSC$W_LENGTH] = .BITSIZE/8;
    DSCADDR[DSC$A_POINTER] = .ADDRESS;
    DSCADDR[DSC$B_DIMCT] = 1;
    DSCADDR[DSC$V_FL_COEFF] = TRUE;
    DSCADDR[DSC$V_FL_BOUNDS] = TRUE;
    ADDRPTR = .DSCADDR + 16;
    .ADDRPTR = .ADDRESS;
    BOUNDVEC = .DSCADDR + 24;
    BOUNDVEC[0] = 0;
    BOUNDVEC[1] = 2000000000;
    
    ! Return the pointer to the RST record.
    !
    RETURN .RSTPTR;
    END;

GLOBAL ROUTINE DBG$TYPEID_FOR_ATOMIC(TYPECODE, BITSIZE, DSC_FLAG) =
!
! FUNCTION
!	This routine returns the Type ID associated with a specified VAX stand-
!	ard type code (a "one-byte type code").  The Type ID is a pointer to an
!	RST entry for the data type.  This RST entry is added to the Temporary
!	RST Entry List so that it disappears as soon as there are no longer any
!	references to it.
!
!	The routine builds a Data Type RST Entry and a Type Specification DST
!	record, both in the same memory block.  The RST entry's FCODE is set to
!	be atomic and its DST pointer points to the DST record.  The DST record
!	is built to contain a DST Type Specification for the specified atomic
!	data type.
!
! INPUTS
!	TYPECODE - The VAX standard type code ("one-byte" type code) whose Type
!		  ID is to be returned.
!
!	BITSIZE  - The size in bits of an item of this type.
!
!	DSC_FLAG - A flag which, when set, indicates that we are processing a
!		   descriptor item; thus, we will signal INVALID ARRAY DESC
!		   in certain error situations.
!
! OUTPUTS
!	The corresponding Type ID (Type RST Entry pointer) is returned as the
!		  routine value.
!

    BEGIN

    LOCAL
	DSTPTR: REF DST$RECORD,		! Pointer to the generated DST record
	RSTPTR: REF RST$ENTRY,		! Pointer to the Type RST Entry
	TSPTR: REF DST$TYPE_SPEC;	! Pointer to Type Spec in DST record



    ! Make sure the VAX standard type code is in the valid range.
    !
    IF ((.TYPECODE LSS DSC$K_DTYPE_LOWEST) OR
	(.TYPECODE GTR DSC$K_DTYPE_HIGHEST)) AND
       (.TYPECODE NEQ DST$K_BOOL) AND
       (.TYPECODE NEQ DSC$K_DTYPE_TF)
    THEN
	BEGIN
	IF .DSC_FLAG
	THEN
	    SIGNAL(DBG$_INVARRDSC)

	ELSE
	    $DBG_ERROR('RSTTYPES\TYPEID_FOR_ATOMIC');

	END;


    ! Get a memory block large enough to contain both the RST entry and the
    ! dummy DST record.
    !
    RSTPTR = DBG$GET_MEMORY(RST$K_TYPENTSIZ + 2);
    DSTPTR = .RSTPTR + 4*RST$K_TYPENTSIZ;


    ! Build the Data Type RST Entry for the atomic type.
    !
    RSTPTR[RST$L_DSTPTR] = .DSTPTR;
    RSTPTR[RST$L_UPSCOPEPTR] = .RST$START_ADDR;
    RSTPTR[RST$B_KIND] = RST$K_TYPE;
    RSTPTR[RST$B_FCODE] = RST$K_TYPE_ATOMIC;
    RSTPTR[RST$L_BITSIZE] = .BITSIZE;


    ! Put this Data Type RST Entry on the Temporary RST Entry List.  This will
    ! cause the entry to be released at the end of a DEBUG command when there
    ! are no references to it (when it is not locked).
    !
    RSTPTR[RST$L_HASH_FLINK] = .RST$TEMP_LIST;
    RST$TEMP_LIST = .RSTPTR;


    ! Build the dummy Type Specification DST entry for the atomic type.
    !
    DSTPTR[DST$B_LENGTH] = 6;
    DSTPTR[DST$B_TYPE] = DST$K_TYPSPEC;
    DSTPTR[DST$B_TYPSPEC_NAME] = 0;
    TSPTR = .DSTPTR + 3;
    TSPTR[DST$W_TS_LENGTH] = 2;
    TSPTR[DST$B_TS_KIND] = DST$K_TS_ATOM;
    TSPTR[DST$B_TS_ATOM_TYP] = .TYPECODE;


    ! Return the type's Type ID (Data Type RST Entry address) to the caller.
    !
    RETURN .RSTPTR;

    END;

GLOBAL ROUTINE DBG$TYPEID_FOR_SET(ARG1, FCODE, BITSIZE) =
!
! FUNCTION
!	This routine builds a Data Type RST Entry for a set data type.
!	This routine is normally called when a Type ID (i.e., an RST
!	pointer to a Type RST Entry) must be produced for a set constant 
!	data type.  The RST entry is added to the Temporary RST Entry List so 
!	that it is released back to the memory pool once there are no longer 
!	any references to it.
!
!	The routine builds a Data Type RST Entry and a dummy DST record in the
!	same memory block.  The DST record is a Type Specification DST record
!	with the null name and an Set Type Specification.  Parent Type 
!	Specification in the Set Type Specification can be either an atomic 
!	type or an Indirect Type Specification pointing to the DST Type
!	Specification given as the input parameter.  
!
! INPUTS
!	ARG1	- DTYPE or DSTADDR
!		  Dtype is vax standard data type.
!		  Dstaddr is the address of the DST Parent Type Specification 
!		  for which a Set Type ID is to be generated.
!
!	FCODE	- The type Format Code associated with the Type Specification.
!
!	BITSIZE - The size in bits of an item of this type.
!
!	Optional 4th argument - If presents, that means the 1st argument is
!				passed in as Dtype.  An Atomic parent type
!				specification will be generated.
!
! OUTPUTS
!	The data type's Type ID (i.e., a pointer to the Type RST Entry) is
!		  returned as the routine's value.
!

    BEGIN

    BUILTIN
    	ACTUALCOUNT;

    LOCAL
    	DSTADDR,			! Parent type DST pointer
    	DTYPE: BYTE,			! Data type
	DSTPTR: REF DST$RECORD,		! Pointer to generated DST record
    	PARENT_TSPTR: REF DST$TYPE_SPEC,! Pointer to Parent Type Spec in Set
    					!	DST record
	RSTPTR: REF RST$ENTRY,		! Pointer to generated Type RST Entry
	TSPTR: REF DST$TYPE_SPEC;	! Pointer to Type Spec in DST record



    ! Depending on whether we have a fourth argument to this routine or not,
    ! the first argument is either a DTYPE or a DSTADDR.  Pick up the Data
    ! Type or the Parent type DST pointer accordingly.
    !
    IF ACTUALCOUNT() GTR 3 THEN DTYPE = .ARG1 ELSE DSTADDR = .ARG1;


    ! Get a memory block large enough to accommodate both the RST entry and
    ! the dummy DST record.
    !
    RSTPTR = DBG$GET_MEMORY(RST$K_TYPENTSIZ + 5);
    DSTPTR = .RSTPTR + 4*RST$K_TYPENTSIZ;


    ! Build the Data Type RST Entry for the input type.
    !
    RSTPTR[RST$L_DSTPTR] = .DSTPTR;
    RSTPTR[RST$L_UPSCOPEPTR] = .RST$START_ADDR;
    RSTPTR[RST$B_KIND] = RST$K_TYPE;
    RSTPTR[RST$B_FCODE] = .FCODE;
    RSTPTR[RST$L_BITSIZE] = .BITSIZE;


    ! Put this Data Type RST Entry on the Temporary RST Entry List.  This will
    ! cause the entry to be released at the end of a DEBUG command when there
    ! are no references to it (when it is not locked).
    !
    RSTPTR[RST$L_HASH_FLINK] = .RST$TEMP_LIST;
    RST$TEMP_LIST = .RSTPTR;


    ! Build the dummy DST record for the type.
    !
    DSTPTR[DST$B_LENGTH] = 4 ;
    DSTPTR[DST$B_TYPE] = DST$K_TYPSPEC;
    DSTPTR[DST$B_TYPSPEC_NAME] = 0;
    TSPTR = .DSTPTR + 3;
    TSPTR[DST$W_TS_LENGTH] = 5;
    TSPTR[DST$B_TS_KIND] = DST$K_TS_SET;
    TSPTR[DST$L_TS_SET_LENG] = .BITSIZE;
    PARENT_TSPTR = .TSPTR + 7;
    IF ACTUALCOUNT() GTR 3
    THEN
    	BEGIN
    	TSPTR[DST$W_TS_LENGTH] = .TSPTR[DST$W_TS_LENGTH] + DST$K_TS_ATOM_LENG;
    	PARENT_TSPTR[DST$W_TS_LENGTH] = 2;
    	PARENT_TSPTR[DST$B_TS_KIND] = DST$K_TS_ATOM;
    	PARENT_TSPTR[DST$B_TS_ATOM_TYP] = .DTYPE;
    	END

    ELSE
    	BEGIN
    	TSPTR[DST$W_TS_LENGTH] = .TSPTR[DST$W_TS_LENGTH] + DST$K_TS_IND_LENG;
    	PARENT_TSPTR[DST$W_TS_LENGTH] = 5;
    	PARENT_TSPTR[DST$B_TS_KIND] = DST$K_TS_IND;
    	PARENT_TSPTR[DST$L_TS_IND_PTR] = DBG$RST_DST_PTR( .DSTADDR - .DST$BEGIN_ADDR );					! M006
    	END;

    DSTPTR[DST$B_LENGTH] = .DSTPTR[DST$B_LENGTH] + .TSPTR[DST$W_TS_LENGTH];


    ! Return the RST pointer to the caller.
    !
    RETURN .RSTPTR;

    END;

GLOBAL ROUTINE DBG$TYPEID_FOR_TPTR(TYPEID) =
!
! FUNCTION
!	Given a TYPEID describing an arbitrary data type, this routine
!	constructs a TYPEID for a Typed Pointer data type, where the
!	typed pointer points to the given data type.
!
!	This is needed for the & operator in C.  For example, if X is data
!	of type T, then &X returns the address of X, and the type of &X is
!	"pointer to data of type T".  This routine is then used to transform
!	the TYPEID for X into the TYPEID for &X.
!
! INPUTS
!	TYPEID	- A TYPEID for the object to which the & operator is being
!		  applied.
!
! OUTPUTS
!	Return Value: A TYPEID is returned, as described above.
!

    BEGIN

    MAP
    	TYPEID: REF RST$ENTRY;		! The input TYPEID for the Type Pointer
					!      data type

    LOCAL
    	ARG_DSTPTR: REF DST$RECORD,	! Pointer to DST record for argument
     	ARG_TSPTR: REF DST$TYPE_SPEC,	! Pointer to Type Spec for argument
    	DSTPTR: REF DST$RECORD,		! Pointer to dummy DST record
    	RSTPTR: REF RST$ENTRY,		! Pointer to new RST record
    	TSPTR: REF DST$TYPE_SPEC;	! Pointer to type spec within DST record



    ! Obtain the DST pointer and Type Spec pointer for the argument.
    !
    ARG_DSTPTR = .TYPEID[RST$L_DSTPTR];
    ARG_TSPTR =  ARG_DSTPTR[DST$A_TYPSPEC_TS_ADDR] + 
    		.ARG_DSTPTR[DST$B_TYPSPEC_NAME];


    ! Allocate a memory block large enough to hold both the newly created
    ! RST record and the dummy DST record that it will point to.
    !
    RSTPTR = DBG$GET_MEMORY (RST$K_TYPENTSIZ + 4);
    DSTPTR = .RSTPTR + 4*RST$K_TYPENTSIZ;


    ! Fill in some of the fields of the RST record.
    !
    RSTPTR[RST$L_DSTPTR] = .DSTPTR;
    RSTPTR[RST$L_UPSCOPEPTR] = .RST$START_ADDR;
    RSTPTR[RST$B_KIND] = RST$K_TYPE;
    RSTPTR[RST$B_FCODE] = RST$K_TYPE_TPTR;
    RSTPTR[RST$L_BITSIZE] = 32;


    ! Put the RST record on the temporary RST list. This will ensure that
    ! the space gets released when there are no more references to it.
    !
    RSTPTR[RST$L_HASH_FLINK] = .RST$TEMP_LIST;
    RST$TEMP_LIST = .RSTPTR;


    ! Fill in the dummy DST record.
    !
    DSTPTR[DST$B_LENGTH] = 12;
    DSTPTR[DST$B_TYPE] = DST$K_TYPSPEC;
    DSTPTR[DST$B_TYPSPEC_NAME] = 0;


    ! Fill in the Type Spec record within the dummy DST record.
    !
    TSPTR = .DSTPTR + 3;    
    TSPTR[DST$W_TS_LENGTH] = 8;
    TSPTR[DST$B_TS_KIND] = DST$K_TS_TPTR;
    TSPTR = TSPTR[DST$A_TS_TPTR_TSPEC_ADDR];


    ! Fill in the Type Spec for the pointed-to object.
    ! Atomic types are filled in in-line, other types use the
    ! "indirect" Type Spec to point back to to argument DST.
    !
    IF .ARG_TSPTR[DST$B_TS_KIND] EQL DST$K_TS_ATOM
    THEN
    	BEGIN
    	TSPTR[DST$W_TS_LENGTH] = 2;
    	TSPTR[DST$B_TS_KIND] = DST$K_TS_ATOM;
    	TSPTR[DST$B_TS_ATOM_TYP] = .ARG_TSPTR[DST$B_TS_ATOM_TYP];
    	END

    ELSE
    	BEGIN
        TSPTR[DST$W_TS_LENGTH] = 5;
        TSPTR[DST$B_TS_KIND] = DST$K_TS_IND;
        TSPTR[DST$L_TS_IND_PTR] = DBG$RST_DST_PTR( .ARG_DSTPTR - .DST$BEGIN_ADDR );					! M006
    	END;


    ! Return the pointer to the RST record.
    !
    RETURN .RSTPTR;

    END;

ROUTINE TYPEID_FOR_COB_HACK(CH_DSTPTR) =
!
! FUNCTION
!	This routine builds an appropriate Data Type RST Entry for the data
!	type of an object described by a Cobol Hack DST Record.  It accepts
!	as input a pointer to the DST record and it builds and returns the
!	address of a Data Type RST Entry for the corresponding type.  The
!	memory block which contains the Type RST Entry also contains a dummy
!	Type Spec DST Record for the data type in question.
!
!	Cobol Hack records are obsolete, but are still found in programs com-
!	piled with the Version 1 COBOL compiler.  This routine therefore con-
!	verts such DST records into more "regular" DST structures so that on-
!	ly this routine needs to understand the obsolete Cobol Hack Record.
!
! INPUTS
!	CH_DSTPTR - A pointer to the Cobol Hack DST Record whose data type is
!		  to be extracted.
!
! OUTPUTS
!	This routine returns as its value a pointer to a Data Type RST Entry
!		  for the data type specified in the Cobol Hack DST Record.
!

    BEGIN

    MAP
	CH_DSTPTR: REF DST$RECORD;	! Pointer to Cobol Hack DST Record

    LOCAL
	BITSIZ,				! The bitsize of an atomic data type
	CH_TRLR_PTR: REF DST$CH_TRLR,	! Pointer to Cobol Hack record trailer
	DESCADDR: REF BLOCK[,BYTE],	! Pointer to VAX standard descriptor
	DSTPTR: REF DST$RECORD,		! Pointer to dummy Type Spec DST Record
					!      built by this routine
	RSTPTR: REF RST$ENTRY,		! Pointer to Type RST Entry built by
					!      by this routine for data item
	TSPTR: REF DST$TYPE_SPEC,	! Pointer to Type Spec in Type Spec DST
					!      record built by this routine
	VSPTR: REF DST$VAL_SPEC;	! Pointer to Value Spec in Type Spec
					!      DST record built by this routine



    ! If the descriptor address in the DST record is zero, this is an atomic
    ! data type defined by the DST$CH_TYPE field.  Build a Type RST Entry for
    ! it and return that entry's address as a TYPEID.
    !
    IF .CH_DSTPTR[DST$L_VALUE] EQL 0
    THEN
	BEGIN
	CH_TRLR_PTR = CH_DSTPTR[DST$A_COBHACK_TRLR] + .CH_DSTPTR[DST$B_NAME];
	BITSIZ = GET_BITSIZE_FROM_DTYPE(.CH_TRLR_PTR[DST$B_CH_TYPE]);
	RSTPTR = DBG$TYPEID_FOR_ATOMIC(.CH_TRLR_PTR[DST$B_CH_TYPE], .BITSIZ, FALSE);
	RETURN .RSTPTR;
	END;


    ! We have a descriptor-specified data type.  Compute the address of the
    ! descriptor.
    !
    IF .CH_DSTPTR[DST$B_VFLAGS] EQL DST$K_VFLAGS_DSC
    THEN
	DESCADDR = CH_DSTPTR[DST$A_DSC_BASE] + .CH_DSTPTR[DST$L_DSC_OFFS]

    ELSE
	SIGNAL(DBG$_INVDSTREC);


    ! If the descriptor is an array descriptor, we build an Array Type RST Entry
    ! and the corresponding dummy Type Spec DST Record.  We also return the
    ! address of the Type RST Entry as a TYPEID.
    !
    IF (.DESCADDR[DSC$B_CLASS] EQL DSC$K_CLASS_A)   OR
       (.DESCADDR[DSC$B_CLASS] EQL DSC$K_CLASS_NCA) OR
       (.DESCADDR[DSC$B_CLASS] EQL DSC$K_CLASS_UBA) OR
       (.DESCADDR[DSC$B_CLASS] EQL DSC$K_CLASS_VSA)
    THEN
	BEGIN


	! Get a memory block to hold both the Type RST Entry and the Type Spec
	! DST Record for the array.
	!
	RSTPTR = DBG$GET_MEMORY(RST$K_TYPENTSIZ + 4);
	DSTPTR = .RSTPTR + 4*RST$K_TYPENTSIZ;


	! Build the Data Type RST Entry.
	!
	RSTPTR[RST$L_DSTPTR] = .DSTPTR;
	RSTPTR[RST$L_UPSCOPEPTR] = .RST$START_ADDR;
	RSTPTR[RST$B_KIND] = RST$K_TYPE;
	RSTPTR[RST$B_FCODE] = RST$K_TYPE_ARRAY;


	! Put this Data Type RST Entry on the Temporary RST Entry List.  This
	! will cause the entry to be released at the end of a DEBUG command
	! when there are no references to it.
	!
	RSTPTR[RST$L_HASH_FLINK] = .RST$TEMP_LIST;
	RST$TEMP_LIST = .RSTPTR;


	! Then build the Type Specification DST Record.  This contains a Type
	! Spec containing a Value Spec which contains the descriptor address.
	!
	DSTPTR[DST$B_LENGTH] = 12;
	DSTPTR[DST$B_TYPE] = DST$K_TYPSPEC;
	TSPTR = DSTPTR[DST$A_TYPSPEC_TS_ADDR];
	TSPTR[DST$W_TS_LENGTH] = 8;
	TSPTR[DST$B_TS_KIND] = DST$K_TS_ARRAY;
	TSPTR[DST$B_TS_ARRAY_DIM] = .DESCADDR[DSC$B_DIMCT];
	VSPTR = TSPTR[DST$A_TS_ARRAY_FLAGS_ADDR] + 1;
	VSPTR[DST$B_VS_VFLAGS] = DST$K_VALKIND_DESC;
	VSPTR[DST$L_VS_VALUE] = .DESCADDR;


	! Return the address of the Type RST Entry we built (the TYPEID).
	!
	RETURN .RSTPTR;
	END;


    ! It is not an array descriptor.  We therefore generate a Descriptor Type
    ! RST Entry and the corresponding dummy Type Spec DST Record.
    !
    RSTPTR = DBG$GET_MEMORY(RST$K_TYPENTSIZ + 3);
    DSTPTR = .RSTPTR + 4*RST$K_TYPENTSIZ;


    ! Build the Data Type RST Entry.
    !
    RSTPTR[RST$L_DSTPTR] = .DSTPTR;
    RSTPTR[RST$L_UPSCOPEPTR] = .RST$START_ADDR;
    RSTPTR[RST$B_KIND] = RST$K_TYPE;
    RSTPTR[RST$B_FCODE] = RST$K_TYPE_DESCR;


    ! Put the Data Type RST Entry on the Temporary RST Entry List.  This will
    ! cause the entry to be released when no longer referenced.
    !
    RSTPTR[RST$L_HASH_FLINK] = .RST$TEMP_LIST;
    RST$TEMP_LIST = .RSTPTR;


    ! Then build the Type Specification DST Record.  This will contain a Type
    ! Spec containing a Value Spec containing the descriptor address.
    !
    DSTPTR[DST$B_LENGTH] = 10;
    DSTPTR[DST$B_TYPE] = DST$K_TYPSPEC;
    TSPTR = DSTPTR[DST$A_TYPSPEC_TS_ADDR];
    TSPTR[DST$W_TS_LENGTH] = 6;
    TSPTR[DST$B_TS_KIND] = DST$K_TS_DSC;
    VSPTR = TSPTR[DST$A_TS_DSC_VSPEC_ADDR];
    VSPTR[DST$B_VS_VFLAGS] = DST$K_VALKIND_DESC;
    VSPTR[DST$L_VS_VALUE] = .DESCADDR;


    ! Return the address of the Type RST Entry we build, i.e. the TYPEID.
    !
    RETURN .RSTPTR;

    END;

ROUTINE TYPEID_FOR_DESCR(DESCADDR, FCODE) =
!
! FUNCTION
!	This routine returns the Type ID associated with a VAX standard descrip-
!	tor type.  The routine builds a Data Type RST Entry for the data type
!	and returns its address as the Type ID.  This RST entry points to a dum-
!	my Type Specification DST Record, also built by this routine, which con-
!	tains a descriptor type specification which in turn contains a value
!	specification which points to the specified descriptor.  The RST entry
!	and the DST record are both built in the same memory block.  This block
!	is put on the Temporary RST Entry List so that it disappears as soon as
!	there no longer are any references to it.
!
! INPUTS
!	DESCADDR - The address of the descriptor for which a Type ID is to be
!		  returned.
!
!	FCODE	- The format code of the resultant Type ID.
!
!	ARRFLAG	- (Optional). If this argument is TRUE, DESCADDR is assumed
!		  to be an ARRAY descriptor,  and a VAX standard descriptor
!		  is built to describe an element of the array.  The descrip-
!		  tor is also placed in the same memory block.
!
! OUTPUTS
!	The corresponding Type ID is returned as the routine value.
!

    BEGIN

    MAP
    	DESCADDR: REF BLOCK[,BYTE];

    BUILTIN
	ACTUALCOUNT,
	ACTUALPARAMETER;

    LOCAL
	ARRFLAG,			! Flag set to TRUE if the input descrip-
					!      tor is an array descriptor
	DSTPTR: REF DST$RECORD,		! Pointer to the type's DST record
	ELEMENT: REF DBG$STG_DESC,	! Pointer to array element descriptor
					!      in constructed DST entry
	RSTPTR: REF RST$ENTRY,		! Pointer to the type's RST entry
    	SIZE,
	TSPTR: REF DST$TYPE_SPEC,	! Pointer to the DST Type Specification
	VSPTR: REF DST$VAL_SPEC;	! Pointer to the DST Value Specification


    ! *** How am I supposed to get this definition properly?
    !
    MACRO
    	DSC$B_DIMCNT = 8, 24, 8, 0%;

    ! If the input descriptor is an array descriptor, as declared by a third
    ! argument (the ARRFLAG argument), then we set the ARRFLAG flag to TRUE.
    ! Otherwise, it is not an array descriptor and ARRFLAG is set to FALSE.
    !
    ARRFLAG = (IF ACTUALCOUNT() GTR 2 THEN ACTUALPARAMETER(3) ELSE FALSE);

    ! Figure out how big the descriptor is.
    ! Assume 12 to start with.
    ! Then check for array descriptors, which are bigger.
    ! In some cases, there may be some slop (SIZE may be bigger
    ! than the descriptor really is), but that is OK.
    !
    SIZE = 12;
    IF .ARRFLAG 
    THEN
    	SIZE = 10
    ELSE
        IF (.DESCADDR[DSC$B_CLASS] EQL DSC$K_CLASS_A) OR
           (.DESCADDR[DSC$B_CLASS] EQL DSC$K_CLASS_NCA) OR
           (.DESCADDR[DSC$B_CLASS] EQL DSC$K_CLASS_UBA) OR
    	   (.DESCADDR[DSC$B_CLASS] EQL DSC$K_CLASS_VSA)
        THEN
    	    SIZE = 20 + (12 * .DESCADDR[DSC$B_DIMCNT]);

    ! Get a memory block to hold both the RST entry and the DST record,
    ! and the descriptor. Copy the descriptor into the end of this
    ! memory block, and reset DESCADDR to point to this copy. (The 
    ! reason for this is so that the descriptor resides in permanent
    ! memory, and in fact in the same permanent memory block as the
    ! typeid. This makes sure that the descriptor does not outlive
    ! the typeid or vice-versa.
    !
    RSTPTR = DBG$GET_MEMORY(RST$K_TYPENTSIZ + 3 + (.SIZE+3)/4);
    DSTPTR = .RSTPTR + 4*RST$K_TYPENTSIZ;
    ELEMENT = .DSTPTR+12;
    CH$MOVE(.SIZE,.DESCADDR,.ELEMENT);
    DESCADDR = .ELEMENT;

    ! For array descriptors we change the class field so it describes the
    ! element and not the entire array.
    !
    IF .ARRFLAG
    THEN
    	BEGIN
	ELEMENT[DSC$B_CLASS] = (IF .ELEMENT[DSC$B_DTYPE] EQL DSC$K_DTYPE_T
				THEN DSC$K_CLASS_S ELSE DSC$K_CLASS_SD);
        ELEMENT[DSC$A_POINTER] = 0;
    	END;

    ! Build the Data Type RST Entry for the descriptor type.
    !
    RSTPTR[RST$L_DSTPTR] = .DSTPTR;
    RSTPTR[RST$L_UPSCOPEPTR] = .RST$START_ADDR;
    RSTPTR[RST$B_KIND] = RST$K_TYPE;
    RSTPTR[RST$B_FCODE] = .FCODE;


    ! Put this Data Type RST Entry on the Temporary RST Entry List.  This will
    ! cause the entry to be released at the end of a DEBUG command when there
    ! are no references to it (when it is not locked).
    !
    RSTPTR[RST$L_HASH_FLINK] = .RST$TEMP_LIST;
    RST$TEMP_LIST = .RSTPTR;


    ! Then build the corresponding Type Specification DST Record.  This contains
    ! a type spec which contains a value spec containing the descriptor address.
    !
    DSTPTR[DST$B_LENGTH] = 10;
    DSTPTR[DST$B_TYPE] = DST$K_TYPSPEC;
    DSTPTR[DST$B_TYPSPEC_NAME] = 0;
    TSPTR = DSTPTR[DST$A_TYPSPEC_TS_ADDR];
    TSPTR[DST$W_TS_LENGTH] = 6;
    TSPTR[DST$B_TS_KIND] = DST$K_TS_DSC;
    VSPTR = TSPTR[DST$A_TS_DSC_VSPEC_ADDR];
    VSPTR[DST$B_VS_VFLAGS] = 0;
    VSPTR[DST$V_VS_VALKIND] = DST$K_VALKIND_DESC;
    VSPTR[DST$L_VS_VALUE] = .DESCADDR;


    ! Return the address of the Data Type RST Entry as the Type ID.
    !
    RETURN .RSTPTR;
    END;

ROUTINE TYPEID_FROM_DST_TYPESPEC(DSTADDR, FCODE, BITSIZE) =
!
! FUNCTION
!	This routine builds a Data Type RST Entry for a data type specified by a
!	DST Type Specification embedded in some other symbol's DST record.  For
!	example, the cell type of an array or the referenced type of a typed
!	pointer is specified by a Type Specification in the DST record for the
!	array or the typed pointer, but does not have a separate DST record of
!	its own.  This routine is normally called when a Type ID (i.e., an RST
!	pointer to a Type RST Entry) must be produced for such a data type.
!	The RST entry is added to the Temporary RST Entry List so that it is
!	released back to the memory pool once there are no longer any references
!	to it.
!
!	The routine builds a Data Type RST Entry and a dummy DST record in the
!	same memory block.  The DST record is a Type Specification DST record
!	with the null name and an Indirect Type Specification pointing to the
!	DST Type Specification given as the input parameter.  The RST entry is
!	then set to point to this dummy DST record.
!
! INPUTS
!	DSTADDR	- The address of the DST Type Specification for which a Type ID
!		  is to be generated.
!
!	FCODE	- The type Format Code associated with the Type Specification.
!
!	BITSIZE - The size in bits of an item of this type.
!
! OUTPUTS
!	The data type's Type ID (i.e., a pointer to the Type RST Entry) is
!		  returned as the routine's value.
!

    BEGIN

    LOCAL
	DSTPTR: REF DST$RECORD,		! Pointer to generated DST record
	RSTPTR: REF RST$ENTRY,		! Pointer to generated Type RST Entry
	TSPTR: REF DST$TYPE_SPEC;	! Pointer to Type Spec in DST record



    ! Get a memory block large enough to accommodate both the RST entry and
    ! the dummy DST record.
    !
    RSTPTR = DBG$GET_MEMORY(RST$K_TYPENTSIZ + 3);
    DSTPTR = .RSTPTR + 4*RST$K_TYPENTSIZ;


    ! Build the Data Type RST Entry for the input type.
    !
    RSTPTR[RST$L_DSTPTR] = .DSTPTR;
    RSTPTR[RST$L_UPSCOPEPTR] = .RST$START_ADDR;
    RSTPTR[RST$B_KIND] = RST$K_TYPE;
    RSTPTR[RST$B_FCODE] = .FCODE;
    RSTPTR[RST$L_BITSIZE] = .BITSIZE;


    ! Put this Data Type RST Entry on the Temporary RST Entry List.  This will
    ! cause the entry to be released at the end of a DEBUG command when there
    ! are no references to it (when it is not locked).
    !
    RSTPTR[RST$L_HASH_FLINK] = .RST$TEMP_LIST;
    RST$TEMP_LIST = .RSTPTR;


    ! Build the dummy DST record for the type.
    !
    DSTPTR[DST$B_LENGTH] = 9;
    DSTPTR[DST$B_TYPE] = DST$K_TYPSPEC;
    DSTPTR[DST$B_TYPSPEC_NAME] = 0;
    TSPTR = .DSTPTR + 3;
    TSPTR[DST$W_TS_LENGTH] = 5;
    TSPTR[DST$B_TS_KIND] = DST$K_TS_IND_TSPEC;
    TSPTR[DST$L_TS_IND_PTR] = DBG$RST_DST_PTR( .DSTADDR - .DST$BEGIN_ADDR );						! M006


    ! Return the RST pointer to the caller.
    !
    RETURN .RSTPTR;

    END;

ROUTINE TYPEID_FROM_DST_RECORD(DSTADDR, FCODE, BITSIZE) =
!
! FUNCTION
!	This routine returns a Type ID for the item described by the DST record
!	pointed to by DSTADDR.
!
! INPUTS
!	DSTADDR	- The DST address of the record defining this item.
!
!	FCODE	- The Format Code which corresponds to the type of this item.
!
!	BITSIZE - The size in bits of this item.
!
! OUTPUTS
!	A Type ID for the type of the item is returned as the routine's value.
!


    BEGIN

    MAP
	DSTADDR: REF DST$RECORD;	! Pointer to DST record from which we
					!      will construct a Type ID

    LOCAL
	RSTPTR: REF RST$ENTRY;		! Pointer to generated Type RST Entry



    ! If the data item is atomic, we call DBG$TYPEID_FOR_ATOMIC to build the
    ! desired Data Type RST Entry.  We return its output directly.
    !
    IF .FCODE EQL RST$K_TYPE_ATOMIC
    THEN
	RETURN DBG$TYPEID_FOR_ATOMIC(.DSTADDR[DST$B_TYPE], .BITSIZE, FALSE);


    ! Get a memory block to hold the Data Type RST Entry.
    !
    RSTPTR = DBG$GET_MEMORY(RST$K_TYPENTSIZ);


    ! Build the Data Type RST Entry for the input type.
    !
    RSTPTR[RST$L_DSTPTR] = .DSTADDR;
    RSTPTR[RST$L_UPSCOPEPTR] = .RST$START_ADDR;
    RSTPTR[RST$B_KIND] = RST$K_TYPE;
    RSTPTR[RST$B_FCODE] = .FCODE;
    RSTPTR[RST$L_BITSIZE] = .BITSIZE;


    ! Put this Data Type RST Entry on the Temporary RST Entry List.  This will
    ! cause the entry to be released at the end of a DEBUG command when there
    ! are no references to it (when it is not locked).
    !
    RSTPTR[RST$L_HASH_FLINK] = .RST$TEMP_LIST;
    RST$TEMP_LIST = .RSTPTR;


    ! Return the RST pointer to the caller.
    !
    RETURN .RSTPTR;

    END;

ROUTINE FIND_TYPE_RECORD(SYMID, FCODE, BITSIZE) =
!
! FUNCTION
!	This routine takes a symid, and tracks down the type spec which
!	describes it. In the process, it determines the Format Code and
!	bit size of the item.
!
! INPUTS
!	SYMID	- The SYMID of the item whose type we want.  (Note that the
!		  SYMID may itself represent a named type.)
!
!	FCODE	- The address of a longword to receive the format code of
!		  the specified item.
!
!	BITSIZE - The address of a longword to receive the size in bits of
!		  the specified item.
!
! OUTPUTS
!	FCODE	- The format code of the item is returned to FCODE.
!
!	BITSIZE	- The size in bits of the item is returned to BITSIZE.
!
!	The data type's Type ID (i.e., a pointer to the Type RST Entry) is
!		  returned as the routine's value; zero is returned if no
!		  type exists.
!

    BEGIN

    MAP
	SYMID: REF RST$ENTRY;

    LOCAL
    	CLASS,
	DESC_PTR: REF BLOCK[,BYTE],
	DST_PTR: REF DST$RECORD,
	HAVE_TYPE,
	KIND,
    	LENGTH,
	SAVEFCODE,
	SAVEID: REF RST$ENTRY,
	SIZE,
	TYPEID: REF RST$ENTRY,
	TYPE_PTR: REF DST$RECORD,
	TYPE_SPEC: REF DST$TYPE_SPEC,
    	VALKIND,
    	VAL_PTR,
    	VAL_VECT: VECTOR[3];


    NOVEL_LENGTH_FLAG = FALSE;
    DBG$STA_SYMKIND(.SYMID, KIND);
    SELECTONE .KIND OF
	SET
	[RST$K_TYPE]:
	    BEGIN
	    .FCODE = .SYMID[RST$B_FCODE];
	    .BITSIZE = .SYMID[RST$L_BITSIZE];
	    RETURN .SYMID;
	    END;

	[RST$K_TYPCOMP, RST$K_DATA]:
	    BEGIN
	    TYPEID = .SYMID[RST$L_TYPEPTR];
	    IF .TYPEID NEQ 0
	    THEN
		BEGIN
		HAVE_TYPE = TRUE;
		SAVEFCODE = .TYPEID[RST$B_FCODE];
		SAVEID = .TYPEID;
		END

	    ELSE
		HAVE_TYPE = FALSE;

	    DST_PTR = .SYMID[RST$L_DSTPTR];
	    SELECTONE .DST_PTR[DST$B_TYPE] OF
		SET
		[DST$K_SEPTYP]:
		    BEGIN


    		    ! Normally, TYPE_SPEC returned from DBG$FIND_SEPTYP does
    		    ! not mean anything if TYPE_PTR[DST$B_TYPE] EQL
    		    ! DST$K_ENUMBEG or DST$K_RECBEG.  In here this case
    		    ! is caught early by HAVE_TYPE set to TRUE.  In other
    		    ! words, in this routine, DST$K_ENUMBEG or DST$K_RECBEG
    		    ! always comes in to have TYPEID. (We hope).
    		    !
    		    SIZE = DBG$FIND_SEPTYP(.DST_PTR, TYPE_PTR, TYPE_SPEC);
		    .BITSIZE = .SIZE;
		    IF .HAVE_TYPE
		    THEN
			BEGIN
			.FCODE = .SAVEFCODE;


    			! The novel length flags gets set earlier, in
    			! FIND_TYPSPEC, if we encounterd a novel length
    			! type spec on the way to our "real" type_spec.
    			! If this flag is set, and if the "novel" size
    			! is different from the size we have in the
    			! typeid, then we build a new typeid with
    			! the novel length in it.
    			!
    			IF .NOVEL_LENGTH_FLAG AND 
    			  (.SAVEFCODE EQL RST$K_TYPE_ENUM) AND
    			  (.SIZE NEQ .TYPEID[RST$L_BITSIZE])
    			THEN
    			    BEGIN
    			    OWN
    			 	DUMMY: VECTOR[2];
    			    LOCAL
    				LAST_SYMID: REF RST$ENTRY,
    				TEMP_SYMID: REF RST$ENTRY;

    			    LENGTH = RST$K_TYPENTSIZ + .TYPEID[RST$L_TYPCOMPCNT];
    			    SAVEID = DBG$GET_MEMORY(.LENGTH + 3);


    			    ! Make the copy.
    			    !
    			    CH$MOVE(.LENGTH*4, .TYPEID, .SAVEID);


    			    ! Modify the typeid. We create a "dummy" hash
    			    ! chain for it.
    			    !
    			    SAVEID[RST$L_UPSCOPEPTR] = .RST$START_ADDR;
    			    SAVEID[RST$L_BITSIZE] = .SIZE;
    			    DUMMY[0] = .SAVEID;
    			    DUMMY[1] = .SAVEID;
    			    SAVEID[RST$L_HASH_FLINK] = .DUMMY;
    			    SAVEID[RST$L_HASH_BLINK] = .DUMMY;
    			    SAVEID[RST$L_SYMCHNPTR] = 0;

    			    ! We put the new SAVEID typeid on the symchain
    			    ! for this module so it gets freed up when we
    			    ! cancel the module.
    			    !
    			    TEMP_SYMID = .SYMID;
    			    WHILE .TEMP_SYMID NEQ 0 DO
    				BEGIN
    				LAST_SYMID = .TEMP_SYMID;
    				TEMP_SYMID = .TEMP_SYMID[RST$L_SYMCHNPTR];
    				END;
    			    LAST_SYMID[RST$L_SYMCHNPTR] = .SAVEID;
    			    SYMID[RST$L_TYPEPTR] = .SAVEID;
    			    END;

			RETURN .SAVEID;
			END;

    		    ! If we have a descriptor type, then we need to check
    		    ! whether this is an array descriptor.
    		    !
    		    IF  (.TYPE_SPEC[DST$B_TS_KIND] EQL DST$K_TS_DSC)
   	 	    THEN
    			BEGIN
			VAL_PTR = TYPE_SPEC[DST$A_TS_DSC_VSPEC_ADDR];
			DBG$STA_VALSPEC(.VAL_PTR, VAL_VECT, VALKIND);
			IF .VALKIND NEQ DBG$K_VAL_DESCR
			THEN
	    		    $DBG_ERROR('RSTTYPES\FIND_TYPE_RECORD 20');

			DESC_PTR = .VAL_VECT[0];
			DBG$READ_ACCESS(.DESC_PTR, 12);
			CLASS = .DESC_PTR[DSC$B_CLASS];
			IF (.CLASS EQL DSC$K_CLASS_A)   OR
	   		   (.CLASS EQL DSC$K_CLASS_NCA) OR
	   		   (.CLASS EQL DSC$K_CLASS_UBA) OR
	   		   (.CLASS EQL DSC$K_CLASS_VSA)
			THEN
    			    BEGIN
	    		    .FCODE = RST$K_TYPE_ARRAY;
    			    RETURN TYPEID_FOR_DESCR(.DESC_PTR, ..FCODE);
    			    END
			ELSE
    			    BEGIN
	    		    .FCODE = RST$K_TYPE_DESCR;
    			    RETURN TYPEID_FOR_DESCR(.DESC_PTR, ..FCODE);
    			    END;
    		        END;

		    .FCODE = DBG$TRANS_TYPE_CODE(.TYPE_SPEC[DST$B_TS_KIND]);
		    IF ..FCODE EQL RST$K_TYPE_ATOMIC
		    THEN
			RETURN DBG$TYPEID_FOR_ATOMIC(
    				.TYPE_SPEC[DST$B_TS_ATOM_TYP], .SIZE, FALSE)

		    ELSE
			RETURN TYPEID_FROM_DST_RECORD(.TYPE_PTR,..FCODE,.SIZE);

		    END;

		[DST$K_BLI]:
		    BEGIN
		    .FCODE = RST$K_TYPE_BLIDATA;
		    .BITSIZE = GET_BITSIZE_FROM_BLIDST(.SYMID[RST$L_DSTPTR]);
		    RETURN DBG$TYPEID_FOR_ATOMIC(RST$K_TYPE_BLIDATA,
			    ..BITSIZE, FALSE);
		    END;

		[DST$K_ENUMELT, DST$K_RECBEG]:
		    BEGIN
		    .FCODE = .SAVEID[RST$B_FCODE];
		    .BITSIZE = .SAVEID[RST$L_BITSIZE];
		    RETURN .SAVEID;
		    END;


		! Handle the COBOL Hack DST Record.  Here we call a routine
		! which converts that DST record into a more regular Type RST
		! Entry.  We then get the FCODE from that RST entry and re-
		! turn the entry's address as a Type ID.
		!
		[DST$K_COB_HACK]:
		    BEGIN
		    TYPEID = TYPEID_FOR_COB_HACK(.DST_PTR);
		    .FCODE = .TYPEID[RST$B_FCODE];
		    .BITSIZE = 0;
		    RETURN .TYPEID;
		    END;

		[DST$K_BLIFLD]:
		    BEGIN
		    .FCODE = RST$K_TYPE_BLIFLD;
		    .BITSIZE = 0;
		    RETURN DBG$TYPEID_FOR_ATOMIC(RST$K_TYPE_BLIFLD,0,FALSE);
		    END;

		[DST$K_LBLORLIT]:
		    BEGIN
		    .FCODE = RST$K_TYPE_ATOMIC;
		    .BITSIZE = 32;
		    RETURN DBG$TYPEID_FOR_ATOMIC(DSC$K_DTYPE_LU,32,FALSE);
		    END;

		[OTHERWISE]:
		    BEGIN
		    IF (.DST_PTR[DST$B_TYPE] LSS DSC$K_DTYPE_LOWEST OR
			.DST_PTR[DST$B_TYPE] GTR DSC$K_DTYPE_HIGHEST) AND
		       (.DST_PTR[DST$B_TYPE] NEQ DST$K_BOOL) AND
    		       (.DST_PTR[DST$B_TYPE] NEQ DSC$K_DTYPE_TF)
		    THEN
			$DBG_ERROR('RSTTYPES\FIND_TYPE_RECORD');

		    .FCODE = DESC_OR_ARRAY_OR_ATOM(.SYMID, DESC_PTR);
		    IF ..FCODE EQL RST$K_TYPE_ATOMIC
		    THEN
			BEGIN
			.BITSIZE = GET_BITSIZE_FROM_DTYPE(.DST_PTR[DST$B_TYPE]);
			RETURN DBG$TYPEID_FOR_ATOMIC(.DST_PTR[DST$B_TYPE],
				    ..BITSIZE,FALSE);
			END

		    ELSE
			BEGIN
			.BITSIZE = 0;
			RETURN TYPEID_FOR_DESCR(.DESC_PTR, ..FCODE);
			END;

		    END;

		TES;

	    END;

	[RST$K_VARIANT]:
	    BEGIN
    	    LOCAL
    		VAR_PTR: REF DST$VARBEG_TRAILER;

	    .FCODE = RST$K_VARIANT;
    	    DST_PTR = .SYMID[RST$L_DSTPTR];
            VAR_PTR = DST_PTR[DST$B_NAME] + 1 + .DST_PTR[DST$B_NAME];
            .BITSIZE = .VAR_PTR[DST$L_VARBEG_SIZE];
	    RETURN .SYMID;
	    END;

	[OTHERWISE]:
	    RETURN 0;

	TES;

    END;

ROUTINE DESC_OR_ARRAY_OR_ATOM(SYMID, DESC_PTR) =
!
! FUNCTION
!	This routine takes a SYMID and determines whether it is of type atomic,
!	array, or descriptor.
!
! INPUTS
!	SYMID	- The SYMID in question.
!
!	DESC_PTR - The address of a longword location to receive the address
!		  of the item's descriptor (if present).
!
! OUTPUTS
!	DESC_PTR - For return values of RST$K_TYPE_DESCR and RST$K_TYPE_ARRAY,
!		  DESC_PTR receives the address of the item's descriptor.
!
!	The routine's value will be one of RST$K_TYPE_ATOMIC, RST$K_TYPE_DESCR,
!		  or RST$K_TYPE_ARRAY.
!

    BEGIN
    BUILTIN
    	PROBER;
    MAP
	DESC_PTR: REF BLOCK[,BYTE],
	SYMID: REF RST$ENTRY;

    LOCAL
	CLASS,
	DESC_ADDR: REF BLOCK[,BYTE],
	DST_PTR: REF DST$RECORD,
	VALPTR: VECTOR[3],
	VKIND;



    DST_PTR = .SYMID[RST$L_DSTPTR];
    IF .DST_PTR[DST$V_VALKIND] NEQ DST$K_VALKIND_DESC
    THEN
	RETURN RST$K_TYPE_ATOMIC

    ELSE
	BEGIN
	IF .DST_PTR[DST$B_VFLAGS] EQL DST$K_VFLAGS_DSC
	THEN
	    DESC_ADDR = .DST_PTR[DST$L_DSC_OFFS] + DST_PTR[DST$A_DSC_BASE]

	ELSE
	    BEGIN
	    DBG$STA_SYMVALUE(.SYMID,VALPTR,VKIND);
	    IF .VKIND NEQ DBG$K_VAL_DESCR
	    THEN
		$DBG_ERROR('RSTTYPES\DESC_OR_ARRAY_OR_ATOM');

	    DESC_ADDR = .VALPTR[0];
	    END;

    	IF NOT PROBER( %REF(0), %REF(12), .DESC_ADDR)
    	THEN
    	    BEGIN
    	    LOCAL
    		NAME;
    	    DBG$STA_SYMNAME(.SYMID, NAME);
    	    SIGNAL(DBG$_BADDESCR, 1, .NAME);
    	    END;
	CLASS = .DESC_ADDR[DSC$B_CLASS];
	.DESC_PTR = .DESC_ADDR;
	IF (.CLASS EQL DSC$K_CLASS_A)   OR
	   (.CLASS EQL DSC$K_CLASS_NCA) OR
	   (.CLASS EQL DSC$K_CLASS_UBA) OR
	   (.CLASS EQL DSC$K_CLASS_VSA)
	THEN
	    RETURN (RST$K_TYPE_ARRAY)

	ELSE
	    RETURN (RST$K_TYPE_DESCR);

	END;

    END;


ROUTINE FIND_TYPESPEC(TYPE_SPEC, BITSIZE, DST_PTR) =
!
! FUNCTION
!	This routine takes a starting TYPE_SPEC and traces through the DST
!	to find the destination type specification; in this process, the
!	routine is sensitive to DST$K_TS_IND, DST$K_SEPTYP, DST$K_GLOBNXT,
!	and DST$K_TS_NOV_LENG. (All of these types indicate that the actual
!	type specification is found elsewhere.) When a DST$K_TS_NOV_LENG is
!	detected, BITSIZE is updated to reflect the novel length.
!
!	The routine loops until a true Type Spec is located.
!
! INPUTS
!	TYPE_SPEC - The DST address of the initial type-specification.
!
!	BITSIZE   - The address of a longword location to receive the size in
!		    bits of the specified type.
!
!	DST_PTR	  - The address of a longword location to receive the DST
!		    address of the DST record which contains the desired
!		    type specification.
!
! OUTPUTS
!	The routine's value is the DST address of the desired type-specification.
!
!	BITSIZE	- The size in bits of an item of this type is returned to
!		  BITSIZE. If a novel length record was detected, BITSIZE
!		  reflects the novel length; otherwise, BITSIZE receives the
!		  default size for the indicated data type.
!
!	DST_PTR - The address of the DST record which contains the desired
!		  type-spec is returned to DST_PTR. The routine's value is
!		  always of type DST$TYPE_SPEC; DST_PTR enables the calling
!		  routine to know the start address of the containing DST record.
!

    BEGIN

    LOCAL
    	RECBEG_TRLR: REF DST$RECBEG_TRLR,
	SIZE,
	TEMP_TS: REF DST$TYPE_SPEC,
	TYPE_PTR: REF DST$RECORD;


    TEMP_TS = .TYPE_SPEC;
    SIZE = 0;
    TYPE_PTR = 0;
    WHILE TRUE DO
	BEGIN
    	SELECTONE .TEMP_TS[DST$B_TS_KIND] OF
    	    SET
	    [DST$K_TS_IND]:
	        BEGIN
	        TYPE_PTR = DBG$RST_DST_PTR( .DST$BEGIN_ADDR + .TEMP_TS[DST$L_TS_IND_PTR] );				! M006
	        IF .TYPE_PTR[DST$B_TYPE] EQL DST$K_SEPTYP
	        THEN
		    BEGIN
		    TYPE_PTR = DBG$RST_NEXT_DST( .TYPE_PTR );								! M006
		    IF .TYPE_PTR[DST$B_TYPE] EQL DST$K_GLOBNXT
		    THEN
		        TYPE_PTR = DBG$RST_NEXT_DST( .TYPE_PTR );							! M006

		    END;

	        IF (.TYPE_PTR[DST$B_TYPE] EQL DST$K_ENUMBEG) OR
	           (.TYPE_PTR[DST$B_TYPE] EQL DST$K_RECBEG)
	        THEN
		    EXITLOOP;

	        TEMP_TS = TYPE_PTR[DST$A_TYPSPEC_TS_ADDR] +
			.TYPE_PTR[DST$B_TYPSPEC_NAME];
	        END;


	    ! Handle the kind of indirect pointer which points directly to
	    ! a DST Type Spec (as opposed to a Type Spec DST record).
	    !
	    [DST$K_TS_IND_TSPEC]:
	        TEMP_TS = DBG$RST_DST_PTR( .DST$BEGIN_ADDR + .TEMP_TS[DST$L_TS_IND_PTR] );				! M006


	    ! Handle the Novel Length Type Spec.  Here we pick up the length
	    ! of data objects of this type and indirect to the Type Spec.
	    !
	    [DST$K_TS_NOV_LENG]:
	        BEGIN


    		! Make a note for the fact, we have encounted a novel
    		! length dst.
    		!
    		NOVEL_LENGTH_FLAG = TRUE;
	        SIZE = .TEMP_TS[DST$L_TS_NOV_LENG];
	        TYPE_PTR = DBG$RST_DST_PTR( .DST$BEGIN_ADDR + .TEMP_TS[DST$L_TS_NOV_LENG_PAR_TSPEC] );			! M006
	        IF .TYPE_PTR[DST$B_TYPE] EQL DST$K_SEPTYP
	        THEN
		    BEGIN
		    TYPE_PTR = DBG$RST_NEXT_DST( .TYPE_PTR );								! M006
		    IF .TYPE_PTR[DST$B_TYPE] EQL DST$K_GLOBNXT
		    THEN
		        TYPE_PTR = DBG$RST_NEXT_DST( .TYPE_PTR );							! M006

		    END;

	        IF (.TYPE_PTR[DST$B_TYPE] EQL DST$K_ENUMBEG) OR
	           (.TYPE_PTR[DST$B_TYPE] EQL DST$K_RECBEG)
	        THEN
		    EXITLOOP;

	        TEMP_TS = TYPE_PTR[DST$A_TYPSPEC_TS_ADDR] +
			.TYPE_PTR[DST$B_TYPSPEC_NAME];
	        END;


	    ! In all other cases, just exit the loop.
	    !
    	    [OTHERWISE]:
	        EXITLOOP;
    	    TES;

	END;

    IF .TYPE_PTR NEQ 0 
    THEN 
    	BEGIN
        .DST_PTR = .TYPE_PTR;


    	! Note TEMP_TS does not mean anything for TYPE_PTR[DST$B_TYPE] EQL
    	! DST$K_ENUMBEG or DST$K_RECBEG.
    	!
    	IF .TYPE_PTR[DST$B_TYPE] EQL DST$K_RECBEG
    	THEN
    	    BEGIN
    	    RECBEG_TRLR = TYPE_PTR[DST$B_NAME] + 1 + .TYPE_PTR[DST$B_NAME];


    	    ! Get size only if there is no novel length overrides.
    	    !
    	    IF .SIZE EQL 0 THEN SIZE = .RECBEG_TRLR[DST$L_RECBEG_SIZE];
    	    .BITSIZE = .SIZE;
    	    RETURN .TEMP_TS;
    	    END

    	ELSE
    	    BEGIN
    	    IF .TYPE_PTR[DST$B_TYPE] EQL DST$K_ENUMBEG
    	    THEN
    		BEGIN


    		! Get size only if there is no novel length overrides.
    		!
    		IF .SIZE EQL 0 THEN SIZE = .TYPE_PTR[DST$B_ENUMBEG_LENG];
    		.BITSIZE = .SIZE;
    		RETURN .TEMP_TS;
    		END;

    	    END;

    	END;

    IF .SIZE EQL 0 THEN SIZE = DBG$GET_BITSIZE_FROM_TYPESPEC(.TEMP_TS);
    .BITSIZE = .SIZE;
    RETURN .TEMP_TS;

    END;

ROUTINE FIND_TYPREC_FROM_TSPEC( TYPE_SPEC ) =
!
! FUNCTION
!	This routine takes a TYPE SPECIFICATION and returns the (possibly)
!	constructed TYPEID which describes the type.
!
! INPUTS
!	TYPE_SPEC - The type specification for which we need a TYPEID.
!
! OUTPUTS
!	The address of a TYPEID describing type_spec.
!

BEGIN

    LOCAL
	FCODE,
	SIZE,
	TEMP_TS: REF DST$TYPE_SPEC,
	TYPEID: REF RST$ENTRY,
	TYPE_PTR: REF DST$RECORD;


    SIZE = 0;
    TYPE_PTR = 0;
    TEMP_TS = FIND_TYPESPEC(.TYPE_SPEC, SIZE, TYPE_PTR);
    IF .TYPE_PTR NEQ 0
    THEN
	BEGIN
	IF (.TYPE_PTR[DST$B_TYPE] EQL DST$K_ENUMBEG) OR
	   (.TYPE_PTR[DST$B_TYPE] EQL DST$K_RECBEG)
	THEN
	    BEGIN
	    TYPEID = FIND_RST_TYPE_ENTRY(.TYPE_PTR);
	    IF .TYPEID NEQ 0 THEN RETURN .TYPEID;
	    END;
	END;

    ! If we have a descriptor type, then we need to check
    ! whether this is an array descriptor.
    !
    IF  (.TEMP_TS[DST$B_TS_KIND] EQL DST$K_TS_DSC)
    THEN
   	BEGIN
    	LOCAL
    	    CLASS,
    	    DESC_PTR: REF BLOCK[,BYTE],
    	    VALKIND,
    	    VAL_PTR,
    	    VAL_VECT: VECTOR[3];

	VAL_PTR = TEMP_TS[DST$A_TS_DSC_VSPEC_ADDR];
	DBG$STA_VALSPEC(.VAL_PTR, VAL_VECT, VALKIND);
	IF .VALKIND NEQ DBG$K_VAL_DESCR
	THEN
	    $DBG_ERROR('RSTTYPES\FIND_TYPREC_FROM_TSPEC 20');

	DESC_PTR = .VAL_VECT[0];
	DBG$READ_ACCESS(.DESC_PTR, 12);
	CLASS = .DESC_PTR[DSC$B_CLASS];
	IF (.CLASS EQL DSC$K_CLASS_A)   OR
	   (.CLASS EQL DSC$K_CLASS_NCA) OR
	   (.CLASS EQL DSC$K_CLASS_UBA) OR
	   (.CLASS EQL DSC$K_CLASS_VSA)
	THEN
	    BEGIN
	    FCODE = RST$K_TYPE_ARRAY;
	    RETURN TYPEID_FOR_DESCR(.DESC_PTR, .FCODE);
	    END;
        END;

    FCODE = DBG$TRANS_TYPE_CODE(.TEMP_TS[DST$B_TS_KIND]);
    IF .FCODE EQL RST$K_TYPE_ATOMIC
    THEN
	RETURN DBG$TYPEID_FOR_ATOMIC(.TEMP_TS[DST$B_TS_ATOM_TYP],.SIZE, FALSE);

    IF .TYPE_PTR NEQ 0
    THEN
	RETURN TYPEID_FROM_DST_RECORD(.TYPE_PTR, .FCODE, .SIZE);

    RETURN TYPEID_FROM_DST_TYPESPEC(.TEMP_TS,.FCODE,.SIZE);

    END;

GLOBAL ROUTINE DBG$GET_BITSIZE_FROM_DESC(DESC_PTR): =
!
! FUNCTION
!	Given pointer to VAX Standard Descriptor, get its size.
!
! INPUT
!	DESC_PTR - Pointer to VAX Standard Descriptor.
!
! OUTPUT
!	Size in bits is returned, it can be zero for non-contiguous array.
!

    BEGIN

    MAP
    	DESC_PTR: REF BLOCK[,BYTE];

    LOCAL
    	SIZE;


    ! Check for read access.
    !
    DBG$READ_ACCESS(.DESC_PTR, 12);

    CASE .DESC_PTR[DSC$B_CLASS] FROM DSC$K_CLASS_S TO DSC$K_CLASS_UBA OF
    	SET

    	! Scalar types, scaled decimal types, and unaligned bit strings.
    	! The DBG$DATA_LENGTH routine computes a bit length by looking
    	! at the DSC$W_LENGTH field, and then looking at the dtype field
    	! to figure out whether the length is in bits, nibbles, or bytes.
    	!
    	[DSC$K_CLASS_S, DSC$K_CLASS_D, DSC$K_CLASS_SD, DSC$K_CLASS_UBS]:
    	    BEGIN
    	    SIZE = DBG$DATA_LENGTH(.DESC_PTR);
    	    END;

    	! Arrays. The length is given in the ARSIZE field. It is either
    	! in bytes or nibbles, depending on the dtype.
    	!
        [DSC$K_CLASS_A]:
    	    BEGIN
    	    IF .DESC_PTR[DSC$B_DTYPE] EQL DSC$K_DTYPE_P
    	    THEN
    		SIZE = .DESC_PTR[DSC$L_ARSIZE] * 4
    	    ELSE
    		SIZE = .DESC_PTR[DSC$L_ARSIZE] * 8;
    	    END;

    	! Non-contiguous arrays. The ARSIZE field contains a length,
    	! but that length may not be meaningful. Return 0 since we
    	! don't really know what the length is.
    	!
    	[DSC$K_CLASS_NCA, DSC$K_CLASS_UBA, DSC$K_CLASS_VSA]:
    	    BEGIN
    	    SIZE = 0;
    	    END;

    	! Varying string descriptor. The maximum string length in
    	! bytes is in the MAXSTRLEN field.
    	!
    	[DSC$K_CLASS_VS]:
    	    BEGIN
    	    SIZE = .DESC_PTR[DSC$W_MAXSTRLEN] * 8;
    	    END;

    	[INRANGE, OUTRANGE]:
    	    SIGNAL(DBG$_DESCNOTSET);

    	TES;

    RETURN .SIZE;
    END;

ROUTINE GET_BITSIZE_FROM_DTYPE(DTYPE) =
!
! FUNCTION
!	This routine takes an SRM DTYPE and returns the default bitsize
!	defined for that type.
!
! INPUTS
!	DTYPE	- The VAX Standard Data Type whose bit size we want.
!
! OUTPUTS
!	The corresponding bit size is returned as the routine's value.
!

    BEGIN

    BIND
	LENGTH_TBL = UPLIT BYTE(0, 1, 1,2,4,8, 1,2,4,8, 4,8,8,16,
				REP 11 OF (0), 16,16,8,16,16,32,
				12,8,8,0,0,0,0): VECTOR[,BYTE];

	%IF DSC$K_DTYPE_HIGHEST GTR 37	! If the LENGTH_TBL PLIT is too small,
	%THEN				!      generate a compile-time error
	    %ERROR('Error:  Must expand PLIT in Routine GET_BITSIZE_FROM_DTYPE')
	%FI;



    ! Return the bitsize corresponding to the input data type.  Note that
    ! we treat Boolean (as in PASCAL) as a special case.
    !
    IF .DTYPE EQL DST$K_BOOL OR .DTYPE EQL DSC$K_DTYPE_TF THEN RETURN 8;
    RETURN 8*.LENGTH_TBL[.DTYPE];

    END;

GLOBAL ROUTINE DBG$GET_BITSIZE_FROM_TYPESPEC( TYPE_SPEC ) =
!
! FUNCTION
!	This routine takes a type specification and returns the corresponding
!	default bit size.
!
! INPUTS
!	type_spec - The type specification whose default size we want.
!
! OUTPUTS
!	The type's default bit size is returned as the routine's value.
!

    BEGIN

    MAP
	TYPE_SPEC: REF DST$TYPE_SPEC;

    LOCAL
    	DESCPTR: REF BLOCK[,BYTE],
    	FLAGS_PTR: REF BITVECTOR,
    	NDIMS,
	SIZE,
    	VAL_VECT: VECTOR[3],
    	VALKIND,
    	VALPTR: REF DST$VAL_SPEC;


    SELECTONE .TYPE_SPEC[DST$B_TS_KIND] OF
	SET

	[DST$K_TS_ATOM]:
	    SIZE = GET_BITSIZE_FROM_DTYPE(.TYPE_SPEC[DST$B_TS_ATOM_TYP]);

    	[DST$K_TS_DSC]:
    	    BEGIN
    	    VALPTR = TYPE_SPEC[DST$A_TS_DSC_VSPEC_ADDR];
    	    DBG$STA_VALSPEC(.VALPTR, VAL_VECT, VALKIND);
    	    IF .VALKIND NEQ DBG$K_VAL_DESCR
    	    THEN
    		$DBG_ERROR('RSTTYPES\DBG$GET_BITSIZE_FROM_TYPESPEC');

    	    DESCPTR = .VAL_VECT[0];
    	    SIZE = DBG$GET_BITSIZE_FROM_DESC(.DESCPTR);
    	    END;

    	[DST$K_TS_TPTR, DST$K_TS_PTR, DST$K_TS_FILE]:
    	    SIZE = 32;

    	[DST$K_TS_PIC]:
	    SIZE = .TYPE_SPEC[DST$B_TS_PIC_DLENG]*%BPUNIT;

    	[DST$K_TS_ARRAY]:
    	    BEGIN
    	    NDIMS = .TYPE_SPEC[DST$B_TS_ARRAY_DIM];
    	    FLAGS_PTR = TYPE_SPEC[DST$A_TS_ARRAY_FLAGS_ADDR];
    	    VALPTR = .FLAGS_PTR + (.NDIMS/8) + 1;
    	    DBG$STA_VALSPEC(.VALPTR, VAL_VECT, VALKIND);
    	    IF .VALKIND NEQ DBG$K_VAL_DESCR
    	    THEN
    		$DBG_ERROR('RSTTYPES\DBG$GET_BITSIZE_FROM_TYPESPEC');

    	    DESCPTR = .VAL_VECT[0];
    	    SIZE = DBG$GET_BITSIZE_FROM_DESC(.DESCPTR);
    	    END;

	[DST$K_TS_SET]:
	    SIZE = .TYPE_SPEC[DST$L_TS_SET_LENG];

	[DST$K_TS_SUBRANGE]:
	    SIZE = .TYPE_SPEC[DST$L_TS_SUBR_LENG];

    	[DST$K_TS_NOV_LENG]:
    	    SIZE = .TYPE_SPEC[DST$L_TS_NOV_LENG];

    	[DST$K_TS_SELF_REL_LABEL]:
    	    SIZE = .TYPE_SPEC[DST$L_TS_SELF_LENG] * 8;

    	[DST$K_TS_RFA]:
    	    SIZE = 6 * 8;

    	[DST$K_TS_TASK]:
    	    SIZE = 32;

	[OTHERWISE]:
	    SIZE = 0;

	TES;

    RETURN .SIZE;

    END;

ROUTINE	GET_BITSIZE_FROM_BLIDST(DSTPTR) =
!
! FUNCTION
!	This routine takes the address of a BLISS type zero DST record, and
!	determines the bit size of the data item.
!
! INPUTS
!	DSTPTR	- The address of the DST record.
!
! OUTPUTS
!	The bit size of the item is returned as the routine's value.
!

    BEGIN

    MAP
	DSTPTR : REF DST$RECORD;

    LOCAL
	SIZE,
	BPTR1: REF DST$BLI_TRAILER1,
	BPTR2: REF DST$BLI_TRAILER2;



    IF .DSTPTR[DST$B_BLI_VFLAGS] NEQ 1 THEN RETURN 0;
    BPTR1 = DSTPTR[DST$A_BLI_TRLR1] + .DSTPTR[DST$B_BLI_LNG];
    BPTR2 = BPTR1[DST$A_BLI_TRLR2] + .BPTR1[DST$B_BLI_NAME];
    SIZE = .BPTR2[DST$L_BLI_SIZE];
    IF .DSTPTR[DST$V_BLI_REF] THEN SIZE = 4;
    RETURN .SIZE;

    END;

ROUTINE FIND_RST_TYPE_ENTRY(DSTPTR) =
!
! FUNCTION
!	This routine takes the address of a DST record, and tries to find the
!	RST record which it defined.  In particular, this routine serves to
!	find the TYPEID for those types which were built into the RST at SET
!	MODULE time (Record and Enumeration Types), but are now being referenced
!	via a DST pointer.  The routine simply passes through the RST looking
!	for an RST$L_DSTPTR which matches the input DSTPTR.
!
! INPUTS
!	DSTPTR	- The address of the DST record of interest.
!
! OUTPUTS
!	The TYPEID of the Record or Enumeration Type we are seeking is returned
!		  as the routine value.  If no such TYPEID exists, zero is re-
!		  turned as the routine value.
!

    BEGIN

    LOCAL
	MODPTR: REF RST$ENTRY,		! Pointer to current Module RST Entry
	SYMID: REF RST$ENTRY;		! Pointer to current symbol RST entry
					!      within the current module



    ! Start up a loop through the RST Module Chain which scans all modules.
    ! Note that we skip over the "anonymous module" at the start of the chain;
    ! this module contains all the Global Symbols and is not of interest.
    !
    MODPTR = .RST$START_ADDR[RST$L_NXTMODPTR];
    WHILE .MODPTR NEQ 0 DO
	BEGIN


	! Now search the Symbol Chain for the current module, looking for an
	! RST Entry whose DSTPTR is the same as the given DST pointer.  When
	! such an RST Entry is found, return its address as the symbol SYMID.
	!
	SYMID = .MODPTR[RST$L_SYMCHNPTR];
	WHILE .SYMID NEQ 0 DO
	    BEGIN
	    IF .SYMID[RST$L_DSTPTR] EQL .DSTPTR THEN RETURN .SYMID;
	    SYMID = .SYMID[RST$L_SYMCHNPTR];
	    END;


	! The DST pointer was not found in this module.  Link on to the next
	! module and search its symbol chain.
	!
	MODPTR = .MODPTR[RST$L_NXTMODPTR];
	END;


    ! We have search the whole RST without finding the desired DST pointer.
    ! Return zero to indicate that the search failed.
    !
    RETURN 0;

    END;

END ELUDOM
