%TITLE 'CONTENTS - Table of Contents formatter program'
!<BLF/NOFORMAT>

MODULE contents (IDENT = 'V04-000'
		%BLISS32[, ADDRESSING_MODE (EXTERNAL = LONG_RELATIVE, NONEXTERNAL = LONG_RELATIVE)]
		) =
BEGIN

!<BLF/FORMAT>
!<BLF/LOWERCASE_USER>
!<BLF/UPPERCASE_KEY>
!<BLF/MACRO>
!
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY:
!   DSR (Digital Standard RUNOFF) /DSRPLUS DSRTOC/CONTENTS Utility
!
! ABSTRACT: 
!   Read and process a RUNOFF binary table of contents file.
!
! ENVIRONMENT:	 Transportable
!
! AUTHOR:	 JPK
!
! CREATION DATE: March 1982
!
! MODIFIED BY:
!
!	013	JPK00011	20-May-1983
!		Modified CONTENTS to check status of $XPO_PARSE_SPEC to avoid
!		XPORT error messages.
!
!	012	JPK00010	05-May-1983
!		Modified CONTENTS to change text for index record group to all
!		caps. Modified CAPTION to change the number of blank lines 
!		after the entity title line.
!
!	011	JPK00009	24-Mar-1983
!		Modified CNTT20 to support new command line syntax.
!		Modified CONTENTS adding routines PROCESS_PAGE, 
!		PROCESS_ENTITY_INFO and PROCESS_ENTITY_TXT to remove 
!		code from routine TOC so that CONTENTS will compile on TOPS-20
!		Modified CNTVMSREQ to remove conditional require of RNODEF.
!
!	010	JPK00008	09-Mar-1983
!		Modified CONTENTS and CAPTION to support new BRN formats,
!		support SEND CONTENTS, /DOUBLE_SPACE, page numbered chapters,
!		guarantee space after section number and to write new 
!		prologue and epilog for RUNOFF output.
!		Modified FORMAT to quote only the RUNOFF flags used by CONTENTS.
!		Modified CNTVMS to fix default for /DOUBLE_SPACE and do more
!		value checking.
!
!	009	JPK00007	14-Feb-1983
!		Global edit of all sources for CONTENTS/DSRTOC:
!		- module names are now consistant with file names
!		- copyright dates have been updated
!		- facility names have been updated
!		- revision history was updated to be consistant with DSR/DSRPLUS
!
!	008	JPK00006	14-Feb-1983
!		Modified CNTVMS, CONTENTS, FORMAT and CNTVMSMSG to generate
!		error messages for DSRTOC or CONTENTS depending on the 
!		compiletime variant for DSRPLUS (/VARIANT:8192)
!
!	007	JPK00005	14-Feb-1983
!		Changed the names of the temporary files used to store
!		.SEND TOC, figure, table and example captions from XPORT.TMP;1,
!		;2, ;3, ;4 to 0CNTST.TMP, 0CNTFG.TMP, 0CNTTB.TMP, and 
!		0CNTEX.TMP respectively. Delete the output file if /NOOUTPUT
!		was specified on the command line. Module CONTENTS modified.
!
!	006	JPK00004	11-Feb-1983
!		Changed the global variable name INDENT to LINE_INDENT in 
!		modules CONTENTS, CAPTION, FORMAT and GBLDCL.
!		Removed declarations of PDENTS in modules CNTVMS, CONTENTS,
!		and CAPTION and replaced with a module wide BIND using the
!		new name INDENTS. 
!		Changed handling of INDENTS [1]. It no longer represents the
!		sum of the chapter and title indents.
!
!	005	KFA00003	04-Feb-1983
!		Modified format of header level one to not include
!		".0" in the counter.  Change was in OUTSEC in module CONTENTS.
!
!	004	KFA00002	14-Oct-1982
!		Modified CNTVMS, CONTENTS, CAPTION and CNTCLI.REQ to handle
!		new syntax for /INDENT qualifier. All indents are now
!		stored in the vector CMDBLK [CONTENTS$AG_HL_INDENT []],
!		where 0 = chapter indent, 1 = header level one indent, etc.
!
!	003	KFA00001	13-Oct-1982
!		Modified CONTENTS and CAPTION to allow null captions for 
!		headers, examples, figures, & tables. 
!
!	002	JPK00001	17-Sep-1982
!		Modified CONTENTS for TOPS-20. This included splitting routine 
!		toc () into toc () and tocfin () so that it can be compiled on 
!		the 20, and calling $XPO_GET_MEM and $XPO_FREE_MEM to 
!		temporarily store the prefix and suffix strings for HEADER 
!		EXAMPLE, FIGURE and TABLE.
!
!--

!
! TABLE OF CONTENTS:
!

FORWARD ROUTINE
    toc,					! Main routine
    tocini,					! Do initialization
    process_page : NOVALUE,			! Process page reference record
    process_entity_info : NOVALUE,		! Process figure/table/example info record
    process_entity_txt : NOVALUE,		! Process figure/table/example text record
    tocfin,					! Complete processing and clean up
    vfycap,					! Check caption style
    outsec : NOVALUE;				! Generate section number

!
! INCLUDE FILES:
!

LIBRARY 'NXPORT:XPORT';

%IF %BLISS (BLISS36)
%THEN

REQUIRE 'REQ:RNODEF';

%FI

%IF %BLISS (BLISS32)
%THEN

REQUIRE 'REQ:CNTVMSREQ';				! VMS error messages

%FI

REQUIRE 'REQ:BRNRTY';				! Binary RUNOFF file formats

REQUIRE 'REQ:PAGEN';				! Page reference format

REQUIRE 'REQ:TOCRTY';				! Table of Contents file formats

REQUIRE 'REQ:CNTCLI';				! Command line information block formats

!
! MACROS:
!

MACRO
    !
    ! Write a character to output line
    !
    write_char (ch) [] =
	BEGIN
	CH$WCHAR_A (ch, lp);
	intlin = .intlin + 1;

	%IF NOT %NULL (%REMAINING)
	%THEN
	    extlin = .extlin + 1;
	%FI

	END
    %,
    !
    ! Write a text literal to the output line
    !
    literal_text (str) =
	BEGIN
	CH$MOVE (%CHARCOUNT (str), CH$PTR (UPLIT (str)), .lp);
	lp = CH$PLUS (.lp, %CHARCOUNT (str));
	intlin = .intlin + %CHARCOUNT (str);
	END
    %,
    !
    ! Pad the output line with blanks
    !
    pad (n_blanks) =
	BEGIN

	IF n_blanks GTR 0
	THEN
	    BEGIN
	    CH$FILL (%C' ', n_blanks, .lp);
	    lp = CH$PLUS (.lp, n_blanks);
	    intlin = .intlin + n_blanks;
	    extlin = .extlin + n_blanks;
	    END;

	END
    %,
    !
    ! Clear the text lines being built up.
    !
    clr_line (_) =
	BEGIN
	lp = CH$PTR (line);
	intlin = 0;
	extlin = 0;
	END
    %,
    !
    ! Insert specified character sequence into file, as is.
    !
    put (str) =
	BEGIN
	$str_copy (string = str, target = tmpstr);
	chrout = .chrout + .tmpstr [str$h_length];
	$xpo_put (iob = tocoob, string = tmpstr);
	!
	! For TMS output, split the output file if it gets too large
	!

	IF .cmdblk [contents$v_tms11] THEN split ();

	END
    %;

!
! EQUATED SYMBOLS:
!

LITERAL
    true = 1,
    false = 0,
    new_captions = 1,				! Using HEADER FIGURE, etc.
    old_captions = -1,				! Using SEND TOC for captions
    tms_line_length = 600,
    infinity = 1^(%BPVAL - 1) - 1;

!
! OWN STORAGE:
!

OWN
    tociob : $xpo_iob (),			! IOB for binary index file.
    file_type,					! Input file type
    fgiob : $xpo_iob (),			! IOB for HEADER FIGUREs
    tbiob : $xpo_iob (),			! IOB for HEADER TABLEs
    exiob : $xpo_iob (),			! IOB for HEADER EXAMPLEs
    hlcnt,					! Maximum number of header levels
    lasthl,					! previous "n"
    toc_page : INITIAL (false),			! True if a CHAPTER should have a page reference
    captyp,					! To tell if SEND TOC or HEADER x was used
    capmsg,					! True if incompatable captions and message was written
    errcnt;					! Count of number of CONFUSED messages.

!
! EXTERNAL REFERENCES:
!

EXTERNAL
    cmdblk : $contents_cmd,			! Command line information block
    tocoob : $xpo_iob (),			! IOB for the resulting .RNT file
    stciob : $xpo_iob (),			! IOB for send toc temp file
    cntvrl,					! Length of version number string
    cntvrp,					! CH$PTR to version number string
    chrout,					! Number of characters written to output file
    tmpstr : $str_descriptor (),		! For temporary strings
    txtlen,					! Length of input text.
    hl_n,					! "n" from latest .HL n command
    hllist : VECTOR [100],			! Header level counters
    hldsp : VECTOR [100],			! Header level display characteristics
    major,					! Major record type code
    minor,					! Minor record type code
    pagen : page_definition,			! Current page number.
    nxtstc,					! Next SEND TOC "n" value to process
    rno_ex : $str_descriptor (),		! String constant 'EXAMPLES'
    rno_fg : $str_descriptor (),		! String constant 'FIGURES'
    rno_tb : $str_descriptor (),		! String constant 'TABLES'
    tms_ex : $str_descriptor (),		! String constant 'Examples'
    tms_fg : $str_descriptor (),		! String constant 'Figures'
    tms_tb : $str_descriptor (),		! String constant 'Tables'
    prestr : $str_descriptor (),		! Caption prefix strings
    sfxstr : $str_descriptor (),		! Caption suffix strings
    lp,						! CH$PTR along line being built up
    intlin,					! Number of characters needed to represent text
    extlin,					! Number of resulting print positions
    line : VECTOR [CH$ALLOCATION (10000)],	! Buffer in which line is being built up.
    lenpag,					! Number of characters in the converted page number.
    txtpag : VECTOR [CH$ALLOCATION (50)],	! The text (lots of room)
    ptrpag,					! A CH$PTR (working pointer)
    lensct,					! Number of characters in the converted section number
    txtsct : VECTOR [CH$ALLOCATION (150)],	! The text (lots of room)
    ptrsct,					! A CH$PTR (working pointer)
    rmargin,					! Used by ENDWRD for controlling filling lines.
    wrap,					! Wrap long lines around to here.
    line_indent;				! Assume this standard indentation before the text.

BIND
    indents = cmdblk [contents$ag_hl_indent] : VECTOR;

EXTERNAL ROUTINE
    fmttxt : NOVALUE,				! Generate formatted text
    insref : NOVALUE,				! Insert a page reference
    hdr_x : NOVALUE,				! Process .HEADER x Captions
    stchdr : NOVALUE,				! Process .SEND TOC n Captions
    insrnt : NOVALUE,				! Insert text directly into RNT
    split : NOVALUE,				! Start new output file for TMS
    pacbas,					! Convert a number to ASCII
    pacpag,					! Convert a PAGEN to a page number
    pacsec,					! Format a section number
    pacxxx;					! Convert number to ASCII using display codes

%IF %BLISS (BLISS32)
%THEN

EXTERNAL ROUTINE
    open_error;					! Action routine to handle file open failures

%FI

%SBTTL 'TOC - Transportable entry point'
GLOBAL ROUTINE toc =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Reads a binary table of contents file, as generated by RUNOFF
!	and uses it to generate a .RNT file.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	Implicit is the order in which records are written, and the
!	format of the file. The format of the file is adequately
!	documented by the code.  It will not be further explained.
!
!	The order of information in the file is not obvious, although
!	its use shows what is available when.
!
!	Briefly, there is an entry in the file (MAJ_PAGE) for every page
!	in the document, regardless of whether or not that page is
!	mentioned in the table of contents.  Further, the page number is
!	guaranteed to occur before you get some text associated with
!	that page.  So, if header level text is found, the page number
!	is already correct.
!
!	Similarily, header level numbers and display information are
!	always written before the header level text to which it is
!	applicable.  Note that the header level information is *not*
!	reset in the file at the start of a chapter; you have to wait
!	for the next header level number record to be input to be sure
!	where you are. The page number and header level information is
!	as valid for text from the .SEND command as it is for text from
!	a .HL command.
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN
    !
    ! Do initialization
    !
    IF NOT tocini () THEN RETURN false;

    !
    ! Read record-groups until end of file.  Process each record group
    ! in turn.  Return at end-of-file.
    !
    WHILE $xpo_get (iob = tociob, fullwords = 2) EQL xpo$_normal DO
	BEGIN

	BIND
	    codes = .tociob [iob$a_data] : VECTOR;

	IF (.file_type EQL brn_file) AND (.codes [0] NEQ brn_contents)
	THEN
	    BEGIN
	    !
	    ! Not a contents record group. Skip it.
	    !
	    $xpo_get (iob = tociob, fullwords = .codes [1]);
	    END
	ELSE
	    BEGIN
	    !
	    ! A contents record group or not a .BRN file
	    !
	    IF .file_type EQL brn_file THEN $xpo_get (iob = tociob, fullwords = 2);

	    major = .codes [0];
	    minor = .codes [1];

	    SELECTONE true OF
		SET

		[.major EQL maj_new_toc] :
		    BEGIN
		    !
		    ! File identification record in a BRN file
		    !
		    IF (.file_type NEQ brn_file)
		    OR (.minor NEQ toc_format)
		    THEN
			BEGIN
			!
			! Report bad file format and quit
			!

%IF %BLISS (BLISS32)
%THEN
			SIGNAL (contents$_invinput, 1, tociob [iob$t_resultant]);
%ELSE
			$xpo_put_msg (severity = warning,
			    string = $str_concat ('invalid file format ''',
				tociob [iob$t_resultant], ''''));
%FI
			END;

		    END;

		[(.major EQL maj_runoff) AND (.minor EQL min_page)] :
		    !
		    ! Process a page number.
		    !
		    process_page ();

		[(.major EQL maj_runoff) AND (.minor EQL min_index)] :
		    BEGIN
		    !
		    ! Make an entry in the table of contents for the index
		    !
		    errcnt = 0;			! Reset count of CONFUSED messages.

		    IF .cmdblk [contents$v_tms11]
		    THEN
			BEGIN
			put ('');

			IF .hl_n NEQ 0 THEN put ('[va15]');

			put ('*c0n*Index@@');
			END
		    ELSE
			BEGIN
			IF .hl_n NEQ 0 THEN put ('.SK2') ELSE put ('.SK1');

			IF .indents [0] NEQ 0
			THEN
			    put ($str_concat ('.I-', $str_ascii (.indents [0])));

			put ('INDEX');
			put ('.BLANK');
			END;

		    hl_n = 0;			! Set .BLANK info
		    lasthl = 0;
		    END;

		[(.major EQL maj_runoff) 
		    AND (
			(.minor EQL min_examp_inf) 
			OR (.minor EQL min_table_inf) 
			OR (.minor EQL min_figur_inf)
			)
		] :
		    !
		    ! Example, Table, or Figure information
		    !
		    process_entity_info ();

		[(.major EQL maj_runoff) 
		    AND (
			(.minor EQL min_examp_txt) 
			OR (.minor EQL min_examp_txt_u) 
			OR (.minor EQL min_figur_txt) 
			OR (.minor EQL min_figur_txt_u) 
			OR (.minor EQL min_table_txt) 
			OR (.minor EQL min_table_txt_u)
			)
		] :
		    !
		    ! Figure, Table or Example text
		    !
		    process_entity_txt ();

		[(.major EQL maj_runoff) AND (.minor EQL min_hl_inf)] :
		    BEGIN
		    !
		    ! Read header level counters and display descriptors
		    !
		    errcnt = 0;			! Reset count of CONFUSED messages.
		    !
		    ! First get count of header level counters.
		    !
		    $xpo_get (iob = tociob, fullwords = 1);
		    hlcnt = .(.tociob [iob$a_data]);
		    !
		    ! Next, get the "n" value for this ".HL n" command
		    !
		    $xpo_get (iob = tociob, fullwords = 1);
		    hl_n = .(.tociob [iob$a_data]);
		    !
		    ! Now read the complete set of header level counters,
		    ! not all of which are important
		    !
		    $xpo_get (iob = tociob, fullwords = .hlcnt);
		    BEGIN

		    BIND
			x = .tociob [iob$a_data] : VECTOR;

		    INCR i FROM 1 TO .hlcnt DO
			BEGIN
			!
			! Copy the header level counters to a safe place
			!
			hllist [.i - 1] = .x [.i - 1];
			END;

		    END;
		    !
		    ! Finally, read the header level display descriptors.
		    !
		    $xpo_get (iob = tociob, fullwords = .hlcnt);
		    BEGIN

		    BIND
			x = .tociob [iob$a_data] : VECTOR;

		    INCR i FROM 1 TO .hlcnt DO
			BEGIN
			!
			! Copy the header level descriptors to a safe place
			!
			hldsp [.i - 1] = .x [.i - 1];
			END;

		    END;
		    END;

		[(.major EQL maj_runoff) 
		    AND (
			(.minor EQL min_hl_txt) 
			OR (.minor EQL min_hl_txt_u)
			)
		] :
		    BEGIN
		    !
		    ! Process the text part of a header level.
		    !
		    LOCAL
			needed_fill;

		    errcnt = 0;			! Reset count of CONFUSED messages.
		    !
		    ! First read the number of characters needed to
		    ! represent the header level
		    !
		    $xpo_get (iob = tociob, fullwords = 1);
		    txtlen = .(.tociob [iob$a_data]);	! Save text length.
		    !
		    ! Generate a table of contents with or without text
		    ! The header level may or may not have text associated with it
		    ! Get the text, if there is any
		    !
		    IF .txtlen NEQ 0
		    THEN
			$xpo_get (iob = tociob, fullwords = CH$ALLOCATION (.txtlen));

		    !
		    ! Generate the associated TOC text only if this header
		    ! level is within the depth specified by the user.
		    !
		    IF .hl_n LEQ .cmdblk [contents$g_headers]
		    THEN
			BEGIN

			IF  (.hl_n LEQ .cmdblk [contents$g_double_space])
			AND NOT .cmdblk [contents$v_tms11]
			THEN
			    put ('.BLANK');

			!
			! Initialize output line.
			!
			clr_line ();
			!
			! All header level entries are generated under the
			! assumption of a .LMn command in the file.
			! Therefore, even though no text has been generated
			! yet we have to act as if "n" characters have been
			! taken up.
			!
			extlin = .indents [0];
			!
			! Set standard indentation in front of this header level line
			!
			line_indent = .indents [0];
			!
			! Generate the header level numbers if the header is
			! numbered. If unnumbered, just put out the text.
			!
			outsec ();
			!
			! Set up line-wrap point
			!
			wrap = .extlin;
			!
			! Generate the page number so as to get its length.
			! This is needed so that the proper number of dots
			! can be supplied.
			!
			ptrpag = CH$PTR (txtpag);

			IF NOT .cmdblk [contents$v_standard_page]
			THEN
			    BEGIN
			    !
			    ! Use the running page counter instead of a
			    ! real page number.
			    !
			    lenpag = pacbas (.pagen [sct_run_page], ptrpag, 10);
			    END
			ELSE
			    BEGIN
			    !
			    ! Supply the usual page number.
			    !
			    lenpag = pacpag (pagen, ptrpag);
			    END;

			!
			! Set limit beyond which words must be wrapped
			!
			rmargin = .cmdblk [contents$g_page_width] - .lenpag - 1;
			!
			! Scan text and put it onto the line.
			!
			fmttxt (.txtlen, CH$PTR (.tociob [iob$a_data]));
			!
			! Insert page reference into line if desired.
			!
			insref ();
			!
			! Now actually put this line of text into the file
			!
			put ((.intlin, CH$PTR (line)));
			clr_line ();
			END;

		    lasthl = .hl_n;
		    END;

		[(.major EQL maj_runoff)
		    AND (
			(.minor EQL min_chapt_inf)
			OR (.minor EQL min_append_inf)
			)
		] :
		    BEGIN
		    !
		    ! Process Chapter/Appendix info record
		    !
		    LOCAL
			len;

		    $xpo_get (iob = tociob, fullwords = 1);	! Get TOC page
		    toc_page = ..tociob [iob$a_data];
		    $xpo_get (iob = tociob, fullwords = 1);	! Skip unused word
		    $xpo_get (iob = tociob, fullwords = 1);	! Get prefix length
		    len = ..tociob [iob$a_data];

		    IF .len GTR 0
		    THEN					! Get prefix string
			$xpo_get (iob = tociob, fullwords = CH$ALLOCATION (.len));

		    $str_copy (string = (.len, CH$PTR (.tociob [iob$a_data])),
			target = prestr);

		    $xpo_get (iob = tociob, fullwords = 1);	! Get suffix length
		    len = ..tociob [iob$a_data];

		    IF .len GTR 0
		    THEN					! Get suffix string
			$xpo_get (iob = tociob, fullwords = CH$ALLOCATION (.len));

		    $str_copy (string = (.len, CH$PTR (.tociob [iob$a_data])),
			target = sfxstr);

		    END;

		[(.major EQL maj_runoff) 
		    AND (
			(.minor EQL min_chapt) 
			OR (.minor EQL min_chapt_txt)
			OR (.minor EQL min_chapt_txt_u)
			OR (.minor EQL min_append)
			OR (.minor EQL min_append_txt)
			OR (.minor EQL min_append_txt_u)
			)
		] :
		    BEGIN
		    !
		    ! Process the start of a chapter or appendix
		    !
		    LOCAL
			ptr;

		    errcnt = 0;			! Reset count of CONFUSED messages.
		    clr_line ();		! Clear the text buffer

		    IF .cmdblk [contents$v_tms11]
		    THEN
			BEGIN
			!
			! TMS output
			!
			put ('');

			IF .hl_n NEQ 0 THEN put ('[va15]');

			IF NOT .toc_page
			THEN
			    literal_text ('*c0n*')
			ELSE
			    literal_text ('*c0np*');

			END
		    ELSE
			BEGIN
			!
			! RUNOFF output
			!
			put ('.TEST PAGE 5');

			IF .cmdblk [contents$g_headers] NEQ 0
			THEN
			    BEGIN

			    IF .hl_n NEQ 0 THEN put ('.SK2') ELSE put ('.SK1');

			    END;

			IF  .indents [0] NEQ 0
			THEN
			    put ($str_concat ('.I-', $str_ascii (.indents [0])));

			line_indent = .indents [0];
			rmargin = .cmdblk [contents$g_page_width];
			END;

		    !
		    ! Now reset the .BLANK information
		    !
		    lasthl = 0;
		    hl_n = 0;

		    IF  (.minor NEQ min_chapt_txt_u)
		    AND (.minor NEQ min_append_txt_u)
		    THEN
			BEGIN
			!
			! Insert the word CHAPTER or APPENDIX
			!
			IF (.minor EQL min_chapt)
			OR (.minor EQL min_chapt_txt)
			THEN
			    BEGIN
			    !
			    ! This is the start of a chapter
			    !
			    IF .cmdblk [contents$v_tms11]
			    THEN
				fmttxt (8, CH$PTR (UPLIT ('Chapter ')))
			    ELSE
				fmttxt (8, CH$PTR (UPLIT ('CHAPTER ')));

			    END
			ELSE
			    BEGIN
			    !
			    ! This is the start of an appendix
			    !
			    IF .cmdblk [contents$v_tms11]
			    THEN
				fmttxt (9, CH$PTR (UPLIT ('Appendix ')))
			    ELSE
				fmttxt (9, CH$PTR (UPLIT ('APPENDIX ')));

			    END;

			!
			! Insert the prefix string if any
			!
			IF .prestr [str$h_length] NEQ 0
			THEN
			    fmttxt (.prestr [str$h_length], .prestr [str$a_pointer]);

			!
			! Convert the "number" of this chapter/appendix to its visual form.
			!
			ptrsct = CH$PTR (txtsct);
			lensct = pacsec (pagen, ptrsct);
			fmttxt (.lensct, CH$PTR (txtsct));

			!
			! Insert the suffix string if there is one
			!
			IF .sfxstr [str$h_length] NEQ 0
			THEN
			    fmttxt (.sfxstr [str$h_length], .sfxstr [str$a_pointer]);

			IF NOT .cmdblk [contents$v_tms11] THEN write_char (%C' ', counts_visually);
			END;

		    IF .cmdblk [contents$v_tms11] THEN write_char (%C'@');

		    !
		    ! Determine the number of characters in the chapter/appendix title
		    ! if any.
		    !
		    $xpo_get (iob = tociob, fullwords = 1);
		    txtlen = .(.tociob [iob$a_data]);	!Save text length.
		    !
		    ! Now read the chapter/appendix text if 
		    ! any exists.
		    !
		    IF .txtlen GTR 0
		    THEN
			$xpo_get (iob = tociob, fullwords = CH$ALLOCATION (.txtlen));

		    IF NOT .cmdblk [contents$v_tms11]
		    THEN
			pad ((.indents [0] + .indents [1] - .extlin));

		    !
		    ! Be sure that long chapter titles get wrapped around correctly
		    !
		    wrap = .extlin;

		    IF .toc_page
		    THEN
			BEGIN
			!
			! Generate a page number.
			!
			ptrpag = CH$PTR (txtpag);

			IF NOT .cmdblk [contents$v_standard_page]
			THEN
			    lenpag = pacbas (.pagen [sct_run_page], ptrpag, 10)
			ELSE
			    lenpag = pacpag (pagen, ptrpag);

			rmargin = .cmdblk [contents$g_page_width] - .lenpag - 1;
			END;

		    !
		    ! Scan text and put it onto the line.
		    !
		    fmttxt (.txtlen, CH$PTR (.tociob [iob$a_data]));

		    IF .toc_page
		    THEN
			BEGIN
			!
			! Insert page reference into line
			!
			insref ();
			toc_page = false;
			END
		    ELSE
			BEGIN

			IF .cmdblk [contents$v_tms11] THEN write_char (%C'@');
			END;

		    !
		    ! Now actually put this line of text into the file
		    !
		    put ((.intlin, CH$PTR (line)));
		    clr_line ();
		    !
		    ! Standard skipping after starting chapter/appendix entry
		    !
		    IF NOT .cmdblk [contents$v_tms11] THEN put ('.BLANK');
		    END;

		[.major EQL maj_send_contents] :
		    BEGIN
		    !
		    ! A SEND CONTENTS record
		    !
		    LOCAL
			type,
			position,
			len,
			iob_ptr : REF $xpo_iob ();

		    type = .minor<0, %BPVAL/2>;
		    position = .minor<%BPVAL/2, %BPVAL/2>;
		    $xpo_get (iob = tociob, fullwords = 1);	! Get text length
		    len = ..tociob [iob$a_data];

		    IF .len GTR 0
		    THEN					! Get text
			$xpo_get (iob = tociob, fullwords = CH$ALLOCATION (.len));

		    SELECTONE .position OF
			SET

			[scon_lev]:
			    BEGIN
			    !
			    ! Insert in main part of table of contents
			    !
			    iob_ptr = 0;

			    IF .type EQL scon_comm
			    THEN
				BEGIN
				!
				! A command. Insert directly into .RNT file
				!
				put ((.len, CH$PTR (.tociob [iob$a_data])));
				END
			    ELSE
				BEGIN
				!
				! Text to be inserted into the RNT
				!
				hl_n = 1;		! Treat as HL 1

				IF .type EQL scon_txt THEN toc_page = true;
				!
				! Set minor code to unnumbered HL so OUTSEC
				! won't generate a section number.
				!
				minor = min_hl_txt_u;
				!
				! Initialize formatting parameters
				!
				clr_line ();
				extlin = .indents [0];
				line_indent = .indents [0];
				!
				! Call OUTSEC to indent line to proper point
				!
				outsec ();
				wrap = .extlin;

				IF .toc_page
				THEN
				    BEGIN
				    !
				    ! Generate page number to get its length
				    !
				    ptrpag = CH$PTR (txtpag);

				    IF NOT .cmdblk [contents$v_standard_page]
				    THEN
					lenpag = pacbas (.pagen [sct_run_page], ptrpag, 10)
				    ELSE
					lenpag = pacpag (pagen, ptrpag);

				    END
				ELSE
				    lenpag = 0;

				rmargin = .cmdblk [contents$g_page_width] - .lenpag - 1;
				fmttxt (.len, CH$PTR (.tociob [iob$a_data]));

				IF .toc_page
				THEN
				    BEGIN
				    insref ();
				    toc_page = false;
				    END
				ELSE
				    BEGIN

				    IF .cmdblk [contents$v_tms11] THEN write_char (%C'@');
				    END;

				put ((.intlin, CH$PTR (line)));
				clr_line ();
				lasthl = .hl_n;
				END;

			    END;

			[scon_exa]:			! Insert with examples
			    iob_ptr = exiob;

			[scon_fig]:			! Insert with figures
			    iob_ptr = fgiob;

			[scon_tab]:			! Insert with tables
			    iob_ptr = tbiob;

			TES;

		    IF  (.iob_ptr NEQ 0)
		    AND vfycap (new_captions)
		    THEN
			BEGIN
			!
			! SEND CONTENTS is to be inserted with FIGURES, TABLES
			! or EXAMPLES. Write record to appropriate temp file.
			!
			LOCAL
			    record_header : VECTOR [3];

			record_header [0] = .major;
			record_header [1] = .minor;
			record_header [2] = .len;
			$xpo_put (iob = .iob_ptr, binary_data = (3, record_header));

			IF .len NEQ 0
			THEN
			    $xpo_put (iob = .iob_ptr, 
				binary_data = (CH$ALLOCATION (.len), .tociob [iob$a_data]));

			END;

		    END;

		[.major EQL maj_send] :
		    BEGIN
		    !
		    ! Process text given on a .SEND command
		    !
		    ! NOTE:  When the user said .SEND TOC n,text the value of "n"
		    ! was written to the file too.  It is now available as
		    ! the value saved in minor.  If the user didn't
		    ! specify n, then 0 was passed.
		    !
		    ! NOTE:  The value of "n" has the following meanings:
		    !
		    !		 0	insert directly into .RNT file
		    !
		    !		 1	Example caption
		    !		-1	insert directly into .RNT file with
		    !			example captions.
		    !
		    !		 2	Figure caption
		    !		-2	insert directly into .RNT file with
		    !			example captions.
		    !
		    !		 3	Table caption
		    !		-3	insert directly into .RNT file with
		    !			table captions
		    !
		    !		n>3	Caption with no title or lead-in
		    !		-n	insert directly into .RNT file with
		    !			+n captions
		    !
		    ! Captions are parsed for a leading word followed by a
		    ! comma. This word is used for the figure number.
		    ! Captions are treated like header levels in that they
		    ! are followed by dots and the chapter-page number.
		    !
		    LOCAL
			ptr;

		    errcnt = 0;			! Reset count of CONFUSED messages.
		    !
		    ! Determine the number of characters specified on the .SEND command
		    !
		    $xpo_get (iob = tociob, fullwords = 1);
		    txtlen = .(.tociob [iob$a_data]);	!Save text length.
		    !
		    ! If there was text given process it.
		    !
		    IF .txtlen GTR 0
		    THEN
			BEGIN
			!
			! There was text given.
			! Now actually read the text
			!
			LOCAL
			    record_header : VECTOR [3];

			$xpo_get (iob = tociob, fullwords = CH$ALLOCATION (.txtlen));
			record_header [0] = maj_send;
			record_header [1] = .minor;
			record_header [2] = .txtlen;

			IF .minor EQL 0
			THEN
			    BEGIN
			    !
			    ! Insert text directly into .RNT file
			    !
			    insrnt (.txtlen, CH$PTR (.tociob [iob$a_data]));
			    END
			ELSE
			    BEGIN
			    !
			    ! Miscellaneous caption or send
			    !
			    IF (ABS (.minor) GTR 3) OR ((ABS (.minor) LEQ 3) AND vfycap (old_captions))
			    THEN
				BEGIN
				!
				! Not a figure, table or example caption
				! OR a figure, table or example caption
				! and we're using old style (SEND TOC) captions
				!
				nxtstc = MIN (ABS (.minor), .nxtstc);
				$xpo_put (iob = stciob, binary_data = (3, record_header));
				$xpo_put (iob = stciob,
				    binary_data = (CH$ALLOCATION (.txtlen), .tociob [iob$a_data]));
				END;

			    END;

			END;

		    END;

		[OTHERWISE] :
		    BEGIN
		    errcnt = .errcnt + 1;

		    IF .errcnt LEQ 5
		    THEN
%IF %BLISS (BLISS32)
%THEN
			SIGNAL (contents$_invrecord, 1, tociob [iob$t_resultant]);
%ELSE
			$xpo_put_msg (severity = warning,
			    string = $str_concat ('invalid record group in file ''', 
				tociob [iob$t_resultant], ''''));
%FI

		    END;
		TES;

	    END;

	END;

    !
    ! Finished processing file.
    !

    IF .cmdblk [contents$v_log]
    THEN
%IF %BLISS (BLISS32)
%THEN
	SIGNAL (contents$_complete, 1, tociob [iob$t_resultant]);
%ELSE
	$xpo_put_msg (severity = success,
	    string = $str_concat ('processing complete ''', tociob [iob$t_resultant], ''''));
%FI

    $xpo_close (iob = tociob);			! Close input file
    RETURN true;				! Successful completion (by definition)
    END;					! End of toc

%SBTTL 'TOCINI - Initialization'
ROUTINE tocini =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine is called by toc () to do initialization.
!
!	It opens the input file and determines the input file type (BRN,
!	BTC or invalid).
!	
!	The output file, and several temporary files used to store
!	figure, table and example information are opened if they are not
!	already open. If they are not already open, the command line
!	text is prettied up for output to the output file and the output
!	file prologue is written. 
!
! FORMAL PARAMETERS:
!
!	None
!
! IMPLICIT INPUTS:
!
!	CMDBLK		- Command line information block
!
! IMPLICIT OUTPUTS:
!
!	CMDBLK		- Command line is reformatted
!	FILE_TYPE	- Set to BRN_FILE if .BRN or MAJ_NEW_TOC if .BTC
!	CAPTYP		- Set to zero if output files not opened
!	CAPMSG		- Set to zero if output files not opened
!	NXTSTC		- Set to INFINITY if output files not opened
!	CHROUT		- Set to zero if output files not opened
!	LASTHL		- Set to zero if output files not opened
!	TOCIOB		- Input file IOB
!	TOCOOB		- Output file IOB
!	STCIOB		- Send TOC temp file IOB
!	FGIOB		- Header Figure temp file IOB
!	TBIOB		- Header Table temp file IOB
!	EXIOB		- Header Example temp file IOB
!	LP		- CH$PTR (LINE)
!	INTLIN		- Set to zero
!	EXTLIN		- Set to zero
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	None
!
! SIDE EFFECTS:
!
!	None
!--
    BEGIN
    
    LOCAL
	parse_block : $xpo_spec_block;

    !
    ! Initialization
    !
    clr_line ();

    IF .cmdblk [contents$v_tms11] THEN cmdblk [contents$g_page_width] = tms_line_length;

    $xpo_iob_init (iob = tociob);

    IF NOT $xpo_parse_spec (spec_block = parse_block, failure = 0,
		file_spec = cmdblk [contents$t_input_file])
    THEN
	!
	! Parse failed. Set parse_block [xpo$h_file_type] non-zero to force
	! quick open failure message.
	!
	parse_block [xpo$h_file_type] = 1;

    IF .parse_block [xpo$h_file_type] NEQ 0
    THEN
	BEGIN
	!
	! User specified a file type. Open file with no defaults.
	!
	$xpo_open (iob = tociob, file_spec = cmdblk [contents$t_input_file], attributes = BINARY
	    %IF %BLISS (BLISS32) %THEN , failure = open_error %FI
	);
	END
    ELSE
	BEGIN
	!
	! User did not specify a file type. Try .BRN first.
	!
	IF $xpo_open (iob = tociob, file_spec = cmdblk [contents$t_input_file], default = ('.BRN'),
		attributes = BINARY, failure = 0) NEQ xpo$_normal
	THEN
	    BEGIN
	    !
	    ! No .BRN file. Try .BTC
	    !
	    $xpo_open (iob = tociob, file_spec = cmdblk [contents$t_input_file], default = '.BTC',
		attributes = BINARY
		    %IF %BLISS (BLISS32) %THEN , failure = open_error %FI
	    );
	    END;

	END;

    IF .cmdblk [contents$v_log]
    THEN
%IF %BLISS (BLISS32)
%THEN
	SIGNAL (contents$_procfile, 1, tociob [iob$t_resultant]);
%ELSE
	$xpo_put_msg (severity = success,
	    string = $str_concat ('processing file ''', tociob [iob$t_resultant], ''''));
%FI

    IF NOT .tocoob [iob$v_open]
    THEN
	BEGIN
	!
	! Output file not open.
	! Open it and do other once only initialization.
	!
	LOCAL
	    file_type,
	    cmd_line : REF $str_descriptor (),
	    cmd_len,
	    cmd_ptr,
	    ptr;

	!
	! General initialization
	!
	captyp = 0;				! No captions seen yet
	capmsg = false;				! No message written
	nxtstc = infinity;			! No .SEND TOC n's seen yet
	chrout = 0;				! No characters written to output
	lasthl = 0;				! Previous HL level

	IF .cmdblk [contents$v_tms11]
	THEN
	    BEGIN
	    hl_n = 0;				! Current HL level
	    file_type = CH$PTR (UPLIT ('.TMS')); ! Output file type
	    END
	ELSE
	    BEGIN
	    hl_n = -1;				! Current HL level
	    file_type = CH$PTR (UPLIT ('.RNT')); ! Output file type
	    END;

	!
	! Open output file and save resultant file name
	!
	$xpo_iob_init (iob = tocoob);
	$xpo_open (iob = tocoob, file_spec = cmdblk [contents$t_output_file], default = (4, .file_type),
	    related = tociob [iob$t_resultant], options = output
		%IF %BLISS (BLISS32) %THEN , failure = open_error %FI
	);
	!
	! Reformat command line before outputting.
	!
	cmd_line = cmdblk [contents$t_command_line];
	cmd_len = .cmd_line [str$h_length];
	cmd_ptr = .cmd_line [str$a_pointer];

	WHILE NOT CH$FAIL (ptr = CH$FIND_CH (.cmd_len, .cmd_ptr, %C'<')) DO
	    CH$WCHAR (%C'[', .ptr);		! Change '<' to '['

	WHILE NOT CH$FAIL (ptr = CH$FIND_CH (.cmd_len, .cmd_ptr, %C'>')) DO
	    CH$WCHAR (%C']', .ptr);		! Change '>' to ']'

	WHILE NOT CH$FAIL (ptr = CH$FIND_CH (.cmd_len, .cmd_ptr, %C';')) DO
	    CH$WCHAR (%C'.', .ptr);		! Change ';' to '.'

	IF .cmdblk [contents$v_tms11]
	THEN
	    BEGIN
	    !
	    ! Write the TMS prologue
	    !
%IF DSRPLUS
%THEN

	    put ($str_concat ('< CONTENTS version ', (.cntvrl, .cntvrp), ' >'));

%ELSE

	    put ($str_concat ('< DSRTOC version ', (.cntvrl, .cntvrp), ' >'));

%FI

	    put ($str_concat ('< ', cmdblk [contents$t_command_line], ' >'));
	    put ('*start*');
	    put ('*cinit*');
	    END
	ELSE
	    BEGIN
	    !
	    ! Write RUNOFF prologue
	    !
%IF DSRPLUS
%THEN

	    put ($str_concat ('.! CONTENTS version ', (.cntvrl, .cntvrp)));

%ELSE

	    put ($str_concat ('.! DSRTOC version ', (.cntvrl, .cntvrp)));

%FI

	    put ($str_concat ('.! ', cmdblk [contents$t_command_line]));
	    put ('.SAVE');
	    put ('.NO FLAGS ALL');
	    put ('.NO FLAGS BREAK		.NO FLAGS CAPITALIZE	.NO FLAGS ENDFOOTNOTE');
	    put ('.NO FLAGS HYPHENATE	.NO FLAGS INDEX		.NO FLAGS PERIOD');
	    put ('.NO FLAGS SPACE		.NO FLAGS SUBSTITUTE');
	    put ('.FLAGS ACCEPT _		.FLAGS BOLD *		.FLAGS COMMENT !');
	    put ('.FLAGS LOWERCASE \	.FLAGS OVERSTRIKE %	.FLAGS UNDERLINE &');
	    put ('.FLAGS UPPERCASE ^');
	    put ('.FLAGS ALL');
	    put ('.NO FILL		.NO JUSTIFY');
	    put (
		$str_concat (
		    '.LEFT MARGIN ',
		    $str_ascii (.indents [0]),
		    '		.RIGHT MARGIN ',
		    $str_ascii (.cmdblk [contents$g_page_width]),
		    '	.PAGE SIZE , ',
		    $str_ascii (.cmdblk [contents$g_page_width])
		)
	    );

	    END;

	!
	! Open SEND TOC temp file
	!
	$xpo_iob_init (iob = stciob);
	$xpo_open (iob = stciob, file_spec = '0CNTST.TMP', attributes = BINARY, options = output
	    %IF %BLISS (BLISS32) %THEN , failure = open_error %FI
	);
	!
	! Open figures temp file
	!
	$xpo_iob_init (iob = fgiob);
	$xpo_open (iob = fgiob, file_spec = '0CNTFG.TMP', attributes = BINARY, options = output
	    %IF %BLISS (BLISS32) %THEN , failure = open_error %FI
	);
	!
	! Open tables temp file
	!
	$xpo_iob_init (iob = tbiob);
	$xpo_open (iob = tbiob, file_spec = '0CNTTB.TMP', attributes = BINARY, options = output
	    %IF %BLISS (BLISS32) %THEN , failure = open_error %FI
	);
	!
	! Open examples temp file
	!
	$xpo_iob_init (iob = exiob);
	$xpo_open (iob = exiob, file_spec = '0CNTEX.TMP', attributes = BINARY, options = output
	    %IF %BLISS (BLISS32) %THEN , failure = open_error %FI
	);

	IF .cmdblk [contents$v_require]
	THEN
	    BEGIN
	    !
	    ! Include contents of require file now
	    !
	    LOCAL
		require_iob : $xpo_iob ();

	    $xpo_iob_init (iob = require_iob);
	    $xpo_open (iob = require_iob,
		file_spec = cmdblk [contents$t_require_file]
		    %IF %BLISS (BLISS32) %THEN , failure = open_error %FI
	    );

	    WHILE $xpo_get (iob = require_iob) EQL xpo$_normal DO
		put (require_iob [iob$t_string]);

	    $xpo_close (iob = require_iob);
	    END
	ELSE
	    BEGIN
	    !
	    ! No require file - generate standard heading
	    !
	    IF NOT .cmdblk [contents$v_tms11]
	    THEN
		BEGIN
		put ('.CENTER;CONTENTS');
		put ('.BLANK');
		END;

	    END;

	END;

    !
    ! Read file information record
    !
    IF $xpo_get (iob = tociob, fullwords = 2) NEQ xpo$_normal
    THEN
	BEGIN
	!
	! Empty input file
	!
%IF %BLISS (BLISS32)
%THEN
	SIGNAL (contents$_emptyin, 1, tociob [iob$t_resultant]);
%ELSE
	$xpo_put_msg (severity = warning,
	    string = $str_concat ('empty input file ''',
		tociob [iob$t_resultant], ''''));
%FI

	RETURN false;
	END
    ELSE
	BEGIN
	!
	! Determine file type
	!
	BIND
	    codes = .tociob [iob$a_data] : VECTOR;

	LOCAL
	    correct_format;

	correct_format = true;			! Assume file format is correct

	SELECTONE .codes [0] OF
	    SET

	    [brn_file] :
		BEGIN
		!
		! Validate .BRN format
		!
		file_type = brn_file;

		IF .codes [1] NEQ brn_ident THEN correct_format = false;
		END;

	    [maj_new_toc] :
		BEGIN
		!
		! Validate .BTC format
		!
		file_type = maj_new_toc;

		IF .codes [1] NEQ toc_format THEN correct_format = false;
		END;

	    [OTHERWISE] :
		!
		! Invalid file format
		!
		correct_format = false;

	    TES;

	IF NOT .correct_format
	THEN
	    BEGIN
	    !
	    ! Report bad file format and quit
	    !
%IF %BLISS (BLISS32)
%THEN
	    SIGNAL (contents$_invinput, 1, tociob [iob$t_resultant]);
%ELSE
	    $xpo_put_msg (severity = warning,
		string = $str_concat ('invalid file format ''',
		    tociob [iob$t_resultant], ''''));
%FI

	    RETURN false;
	    END;

	END;

    RETURN true;
    END;

%SBTTL 'PROCESS_PAGE - Process page reference record'
ROUTINE process_page : NOVALUE =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine is called by TOC () to process a page reference record.
!
! FORMAL PARAMETERS:
!
!	None
!
! IMPLICIT INPUTS:
!
!	None
!
! IMPLICIT OUTPUTS:
!
!	pagen		- contains the new page reference
!	The page reference record is written to the four temporary files.
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	None
!
! SIDE EFFECTS:
!
!	None
!--
    BEGIN
    errcnt = 0;			! Reset count of CONFUSED messages.

    !
    ! Read a page number.
    !
    $xpo_get (iob = tociob, fullwords = page_sct_size);

    BEGIN

    BIND
	page_ref = .tociob [iob$a_data] : VECTOR [page_sct_size];

    MAP
	pagen : VECTOR [page_sct_size];

    INCR i FROM 1 TO page_sct_size DO
	BEGIN
	!
	! Copy page number
	!
	pagen [.i - 1] = .page_ref [.i - 1];
	END;

    END;

    BEGIN
    !
    ! Write page information to temp files
    !
    LOCAL
	record_header : VECTOR [2];

    record_header [0] = maj_runoff;
    record_header [1] = min_page;
    $xpo_put (iob = stciob, binary_data = (2, record_header));
    $xpo_put (iob = stciob, binary_data = (page_sct_size, pagen));
    $xpo_put (iob = fgiob, binary_data = (2, record_header));
    $xpo_put (iob = fgiob, binary_data = (page_sct_size, pagen));
    $xpo_put (iob = tbiob, binary_data = (2, record_header));
    $xpo_put (iob = tbiob, binary_data = (page_sct_size, pagen));
    $xpo_put (iob = exiob, binary_data = (2, record_header));
    $xpo_put (iob = exiob, binary_data = (page_sct_size, pagen));
    END;

    END;

%SBTTL 'PROCESS_ENTITY_INFO - Process figure/table/example info record'
ROUTINE process_entity_info : NOVALUE =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine is called by TOC () to process a figure/table/example
!	information record.
!
! FORMAL PARAMETERS:
!
!	None
!
! IMPLICIT INPUTS:
!
!	major		- major record code
!	minor		- minor record code
!	exiob		- IOB for examples temp file
!	fgiob		- IOB for figures temp file
!	tbiob		- IOB for tables temp file
!
! IMPLICIT OUTPUTS:
!
!	The record is written to the appropriate temp file if new captions
!	are being processed.
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	None
!
! SIDE EFFECTS:
!
!	None
!--
    BEGIN

    LOCAL
	prefix_addr,
	prefix_fullwords,
	suffix_addr,
	suffix_fullwords,
	iob_ptr : REF $xpo_iob (),
	info_list : VECTOR [6];

    errcnt = 0;			! Reset count of CONFUSED messages.
    iob_ptr = (SELECTONE .minor OF
	SET
	[min_examp_inf] : exiob;
	[min_table_inf] : tbiob;
	[min_figur_inf] : fgiob;
	TES);

    info_list [0] = .major;
    info_list [1] = .minor;
    !
    ! Get counter, display descriptor and prefix text length
    !
    $xpo_get (iob = tociob, fullwords = 3);
    BEGIN

    BIND
	counter_info = .tociob [iob$a_data] : VECTOR;

    info_list [2] = .counter_info [0];	! Counter value
    info_list [3] = .counter_info [1];	! Counter display code
    info_list [4] = .counter_info [2];	! Prefix text length
    END;

    IF .info_list [4] NEQ 0
    THEN
	BEGIN
	!
	! There is prefix text
	!
	prefix_fullwords = CH$ALLOCATION (.info_list [4]);
	$xpo_get (iob = tociob, fullwords = .prefix_fullwords);
	!
	! Get some memory to store the prefix string in.
	!
	$xpo_get_mem (fullwords = .prefix_fullwords, result = prefix_addr);
	!
	! Copy the prefix string to the memory just allocated
	!
	BEGIN
	BIND
	    input_vector = .tociob [iob$a_data] : VECTOR,
	    prefix_vector = .prefix_addr : VECTOR;

	INCR i FROM 0 TO .prefix_fullwords - 1 DO
	    prefix_vector [.i] = .input_vector [.i];

	END;
	END;

    !
    ! Get length of suffix text
    !
    $xpo_get (iob = tociob, fullwords = 1);
    info_list [5] = .(.tociob [iob$a_data]);

    IF .info_list [5] NEQ 0
    THEN
	BEGIN
	!
	! There is suffix text
	!
	suffix_fullwords = CH$ALLOCATION (.info_list [5]);
	$xpo_get (iob = tociob, fullwords = .suffix_fullwords);
	!
	! Get some memory to store the suffix string in.
	!
	$xpo_get_mem (fullwords = .suffix_fullwords, result = suffix_addr);
	!
	! Copy the suffix string to the dynamic memory area
	!
	BEGIN
	BIND
	    input_vector = .tociob [iob$a_data] : VECTOR,
	    suffix_vector = .suffix_addr : VECTOR;

	INCR i FROM 0 TO .suffix_fullwords - 1 DO
	    suffix_vector [.i] = .input_vector [.i];

	END;
	END;

    IF vfycap (new_captions)
    THEN
	BEGIN
	!
	! Write major-code, minor-code, counter,
	! display-descriptor and prefix text length.
	!
	$xpo_put (iob = .iob_ptr, binary_data = (5, info_list));
	!
	! Write prefix text if any
	!
	IF .info_list [4] NEQ 0
	THEN
	    $xpo_put (iob = .iob_ptr,
		binary_data = (.prefix_fullwords, .prefix_addr));

	!
	! Write suffix text length
	!
	$xpo_put (iob = .iob_ptr, binary_data = (1, info_list [5]));
	!
	! Write suffix text if any
	!
	IF .info_list [5] NEQ 0
	THEN
	    $xpo_put (iob = .iob_ptr,
		binary_data = (.suffix_fullwords, .suffix_addr));

	END;

    IF .info_list [4] NEQ 0
    THEN
	BEGIN
	!
	! Deallocate the memory we allocated for the prefix string
	!
	$xpo_free_mem (binary_data = (.prefix_fullwords, .prefix_addr));
	END;

    IF .info_list [5] NEQ 0
    THEN
	BEGIN
	!
	! Deallocate the memory allocated for the suffix string
	!
	$xpo_free_mem (binary_data = (.suffix_fullwords, .suffix_addr));
	END;

    END;

%SBTTL 'PROCESS_ENTITY_TXT - Process figure/table/example text record'
ROUTINE process_entity_txt : NOVALUE =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine is called by TOC () to process a figure/table/example
!	text record.
!
! FORMAL PARAMETERS:
!
!	None
!
! IMPLICIT INPUTS:
!
!	major		- major record code
!	minor		- minor record code
!	exiob		- IOB for examples temp file
!	fgiob		- IOB for figures temp file
!	tbiob		- IOB for tables temp file
!
! IMPLICIT OUTPUTS:
!
!	txtlen		- length of caption text
!
!	The record is written to the appropriate temp file if new captions
!	are being processed.
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	None
!
! SIDE EFFECTS:
!
!	None
!--
    BEGIN

    LOCAL
	iob_ptr : REF $xpo_iob (),
	record_header : VECTOR [3];

    errcnt = 0;			! Reset count of CONFUSED messages.

    iob_ptr = (SELECTONE .minor OF
	SET
	[min_figur_txt] : fgiob;
	[min_figur_txt_u] : fgiob;
	[min_table_txt] : tbiob;
	[min_table_txt_u] : tbiob;
	[min_examp_txt] : exiob;
	[min_examp_txt_u] : exiob;
	TES);

    !
    ! Get length of text
    !
    $xpo_get (iob = tociob, fullwords = 1);
    txtlen = .(.tociob [iob$a_data]);

    record_header [0] = .major;
    record_header [1] = .minor;
    record_header [2] = .txtlen;
    !
    ! Get the text, if there is any
    !
    IF .txtlen NEQ 0
    THEN
	$xpo_get (iob = tociob, fullwords = CH$ALLOCATION (.txtlen));

    IF vfycap (new_captions)
    THEN
	BEGIN
	!
	! Write record to temp file
	!
	$xpo_put (iob = .iob_ptr, binary_data = (3, record_header));
	$xpo_put (iob = .iob_ptr,
	    binary_data = (CH$ALLOCATION (.txtlen), .tociob [iob$a_data]));

	END;

    END;

%SBTTL 'TOCFIN - Finish table of contents processing'
GLOBAL ROUTINE tocfin =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine is called to finish up processing the table of contents.
!
!	This entails writing the figure, table and example information,
!	closing and deleting the temporary files and closing the output file.
!
! FORMAL PARAMETERS:
!
!	None
!
! IMPLICIT INPUTS:
!
!	None
!
! IMPLICIT OUTPUTS:
!
!	None
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	true
!
! SIDE EFFECTS:
!
!	None
!--

    BEGIN
    !
    ! Close the caption temp files
    !
    $xpo_close (iob = exiob, options = remember);
    $xpo_close (iob = fgiob, options = remember);
    $xpo_close (iob = tbiob, options = remember);
    $xpo_close (iob = stciob, options = remember);
    !
    ! Process the caption temp files
    !
    IF .captyp EQL new_captions
    THEN
	BEGIN
	!
	! Using .HEADER X captions
	!
	IF .cmdblk [contents$v_tms11]
	THEN
	    BEGIN
	    !
	    ! For TMS...
	    !
	    hdr_x (exiob, tms_ex, min_examp_inf, min_examp_txt, min_examp_txt_u);
	    hdr_x (fgiob, tms_fg, min_figur_inf, min_figur_txt, min_figur_txt_u);
	    hdr_x (tbiob, tms_tb, min_table_inf, min_table_txt, min_table_txt_u);
	    END
	ELSE
	    BEGIN
	    !
	    ! For RUNOFF...
	    !
	    hdr_x (exiob, rno_ex, min_examp_inf, min_examp_txt, min_examp_txt_u);
	    hdr_x (fgiob, rno_fg, min_figur_inf, min_figur_txt, min_figur_txt_u);
	    hdr_x (tbiob, rno_tb, min_table_inf, min_table_txt, min_table_txt_u);
	    END;

	END;

    !
    ! Process the .SEND TOC temp file
    !
    stchdr ();
    !
    ! Delete temp files
    !
    $xpo_delete (iob = exiob);
    $xpo_delete (iob = fgiob);
    $xpo_delete (iob = tbiob);
    $xpo_delete (iob = stciob);
    !
    ! Write appropriate epilogue
    !
    IF .cmdblk [contents$v_tms11]
    THEN
	put ('*cfini*')
    ELSE
	put ('.RESTORE');

    !
    ! Finally, close the output file and call it quits
    !
    IF .cmdblk [contents$v_log]
    THEN
%IF %BLISS (BLISS32)
%THEN
	SIGNAL (contents$_created, 1, tocoob [iob$t_resultant]);
%ELSE
	$xpo_put_msg (severity = success, 
	    string = $str_concat ('''', tocoob [iob$t_resultant], ''' created'));
%FI

    IF .cmdblk [contents$v_output]
    THEN
	$xpo_close (iob = tocoob)
    ELSE
	BEGIN
	!
	! User specified /NOOUTPUT
	! Close and delete the output file.
	!
	$xpo_close (iob = tocoob, options = remember);
	$xpo_delete (iob = tocoob);
	END;

    RETURN true;
    END;

%SBTTL 'VFYCAP - Check caption type'
ROUTINE vfycap (type) =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine checks the caption type being processed against the
!	argument caption type. If they are the same, a value of true is
!	returned.
!
!	If they are different, a message is written if no message has been
!	written already, and false is returned.
!
!	If no caption type has been set yet, the caption type is set from
!	the argument type and true is returned.
!
! FORMAL PARAMETERS:
!
!	type	- argument caption type
!
! IMPLICIT INPUTS:
!
!	captyp	- caption type being processed
!	capmsg	- true if a message hase been written
!
! IMPLICIT OUTPUTS:
!
!	captyp	- will be set if it is zero
!	capmsg	- will be set to true if a message is written
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	See functional description above.
!
! SIDE EFFECTS:
!
!	None
!--

    BEGIN

    SELECTONE .captyp OF
	SET

	[old_captions] :

	    IF .type EQL new_captions
	    THEN
		BEGIN

		IF NOT .capmsg
		THEN
		    BEGIN
		    capmsg = true;

%IF %BLISS (BLISS32)
%THEN
		    SIGNAL (contents$_captions, 0, contents$_ignorenew);
%ELSE
		    $xpo_put_msg (severity = warning,
			string = 'both .SEND TOC captions and ".HEADER x" captions encountered',
			string = '".HEADER x" captions will be ignored');
%FI

		    END;

		RETURN false;
		END;

	[new_captions] :

	    IF .type EQL old_captions
	    THEN
		BEGIN

		IF NOT .capmsg
		THEN
		    BEGIN
		    capmsg = true;

%IF %BLISS (BLISS32)
%THEN
		    SIGNAL (contents$_captions, 0, contents$_ignoreold);
%ELSE
		    $xpo_put_msg (severity = warning,
			string = 'both .SEND TOC captions and ".HEADER x" captions encountered',
			string = '.SEND TOC captions will be ignored');
%FI

		    END;

		RETURN false;
		END;

	[OTHERWISE] :
	    captyp = .type;

	TES;

    RETURN true;
    END;

%SBTTL 'OUTSEC - Format a section number'
ROUTINE outsec : NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!
!	OUTSEC generates a section number of the form 1.2.3.....
!
! FORMAL PARAMETERS:
!
!	None
!
! IMPLICIT INPUTS:
!
!	cmdblk	- command line information block
!	lasthl	- previous HL "n"
!	hl_n	- current HL "n"
!	minor	- minor record type code
!	pagen	- current page number
!	hllist	- header level counters
!	hldsp	- header level display codes
!		- output line variables
!
! IMPLICIT OUTPUTS:
!
!	ptrsct	- modified
!	lensct	- length of section number
!	txtsct	- contains formatted section number
!		- output line variables modified (since section number is
!		  inserted into the output line)
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!	None
!
! SIDE EFFECTS:
!
!	None
!
!--

    BEGIN

    LOCAL
	hl_width;				! Number of columns reserved for header level.

    lensct = 0;
    ptrsct = CH$PTR (txtsct);

    IF .cmdblk [contents$v_tms11]
    THEN
	BEGIN
	!
	! Write out the HL level for TMS
	!
	IF (.lasthl NEQ .hl_n) AND (.lasthl NEQ 0) THEN put ('[va5]');

	literal_text ('*c');
	lensct = pacbas (.hl_n, ptrsct, 10);
	ptrsct = CH$PTR (txtsct);
	CH$MOVE (.lensct, .ptrsct, .lp);
	lp = CH$PLUS (.lp, .lensct);
	intlin = .intlin + .lensct;
	lensct = 0;
	literal_text ('n*');
	END;

    IF .cmdblk [contents$v_include_sections] 
	AND (
	    (.cmdblk [contents$g_sections] GEQ .hl_n) 
	    OR  (
		(.cmdblk [contents$g_sections] EQL -1) 
		AND (.minor NEQ min_hl_txt_u)
		)
	    )
    THEN
	BEGIN
	!
	! Don't write the number if user said heads are unnumbered.
	! The user must have requested numbered heads and
	! the header level must be less than the largest one the user
	! specified or the heads must be displayed as input and the
	! text is not for an unnumbered header.
	!
	IF (.pagen [sct_typ] EQL 0) AND (.hl_n EQL 1)
	THEN
	    BEGIN
	    !
	    ! This is a HL 1 for a document not divided into sections
	    !
	    lensct = pacxxx (.hllist [0], ptrsct, .hldsp [0]);
	    END
	ELSE
	    BEGIN

	    IF .pagen [sct_typ] NEQ 0
	    THEN
		BEGIN
		!
		! Document is divided into sections
		!
		lensct = pacsec (pagen, ptrsct);
		CH$WCHAR_A (%C'.', ptrsct);
		lensct = .lensct + 1;
		END;

	    INCR i FROM 1 TO .hl_n DO
		BEGIN
		lensct = .lensct + pacxxx (.hllist [.i - 1], ptrsct, .hldsp [.i - 1]);
		CH$WCHAR_A (%C'.', ptrsct);
		lensct = .lensct + 1;
		END;

	    !
	    ! Always get an extra dot, so uncount it.
	    !
	    lensct = .lensct - 1;
	    END;

	!
	! Now copy the converted section number into the line that's being built up.
	!
	fmttxt (.lensct, CH$PTR (txtsct));

	IF NOT .cmdblk [contents$v_tms11] THEN write_char (%C' ', counts_visually);
	END;

    IF .cmdblk [contents$v_tms11]
    THEN
	write_char (%C'@')
    ELSE
	BEGIN
	!
	! For RUNOFF...
	!
	! Compute the width of the region into which the header level
	! number was supposed to fit.
	!
	hl_width = 0;

	INCR i FROM 0 TO .hl_n  DO
	    hl_width = .hl_width + .indents [.i];

	!
	! Pad out this .HL number to fill the columns allocated.
	!
	pad ((.hl_width - .extlin));
	END;

    END;					! End of outsec

END						! End of module
ELUDOM
