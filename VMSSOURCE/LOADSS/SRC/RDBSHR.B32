%TITLE	'RDBSHR - Rights database loadable system services'
MODULE RDBSHR (IDENT = 'V04-000') =
BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY: EXECUTIVE, SYSTEM SERVICES
!
! ABSTRACT:
!
!	This module contains system services that maintain the rights
!	database. It is built as a privileged shareable image. The
!	remaining rights database system services are in the exec.
!	The system services in this module are:
!
!		$ADD_HOLDER	$ADD_IDENT	$CREATE_RDB
!		$FIND_HELD	$FIND_HOLDER	$MOD_HOLDER
!		$MOD_IDENT	$REM_HOLDER	$REM_IDENT
!
! ENVIRONMENT:
!
!	VAX/VMS native mode, user, supervisor, or exec modes.
!
!--
!
! AUTHOR:  Andrew C. Goldstein, CREATION DATE:  16-Nov-1982  18:51
!
! MODIFIED BY:
!
!	V03-013	ACG0447		Andrew C. Goldstein,	23-Aug-1984  16:35
!		Upcase all input identifier names
!
!	V03-012 JRL0009		John R. Lawson, Jr.	29-Jun-1984 11:28
!		Check for existence of current Rights Data Base.
!		Do not allow $CREATE if present.
!
!	V03-011	LY0469		Larry Yetto		22-MAR-1984 14:13
!		Add two new parameters to the MOD_IDENT service to
!		allow the identifier name or value to be modified.  This
!		change also requires the CHG attribut to be associated
!		with the secondary and tertiary keys therefore the create service
!		was also modified.
!
!	V03-010	RSH0100		R. Scott Hanna		03-Feb-1984
!		Update comments to indicate that the ATTRIB parameter is
!		optional for $ADD_HOLDER AND $ADD_IDENT.
!
!	V03-009	RSH0088		R. Scott Hanna		05-Jan-1984
!		Change $ADD_HOLDER, $ADD_IDENT, $MOD_HOLDER, $MOD_IDENT,
!		$REM_HOLDER, and $REM_IDENT to return SS$_NORMAL instead
!		of RMS$_NORMAL.
!
!	V03-008	TMK0001		Todd M. Katz		22-Oct-1983
!		The name of the real system service entry point for
!		$FINISH_RDB has been changed from EXE$FINISH_RDB to
!		EXE$$FINISH_RDB. This change was required because the
!		system service could no longer be reached directly from the
!		executive mode system service dispatcher.
!
!	V03-007	RSH0062		R. Scott Hanna		12-Sep-1983
!		Modify ID value validation to return SS$_IVIDENT for
!		an ID of 0. (All services except $ADD_IDENT)
!
!	V03-006	RSH0050		R. Scott Hanna		28-Jul-1983
!		Changed SYS$CREATE_RDB to use the new FAB bits
!		FAB$V_LNM_MODE instead of FAB$B_DSBMSK.
!
!	V03-005	RSH0046		R. Scott Hanna		24-Jul-1983
!		Modified SYS$CREATE_RDB to create records for the
!		environmental rights.
!
!	V03-004	RSH0041		R. Scott Hanna		21-Jun-1983
!		Provide additional ID name validation. Open the rights
!		database as a process permanent file when there is no
!		active image.
!
!	V03-003	RSH0033		R. Scott Hanna		26-May-1983
!		Modify FAB in EXE$OPEN_RDB so that a logical name
!		can be used for the Rights Database.
!
!	V03-002	GAS0126		Gerry Smith		26-May-1983
!		Put SYS$FIND_HELD into its own module.  This is 
!		necessary so that LOGINOUT can reference it before
!		the loadable system services are loaded, at boot time.
!
!	V03-001	RSH0008		R. Scott Hanna		01-Mar-1983
!		Changed SYS$CREATE_RDB to call EXE$SET_RDIPTR.
!
!**


LIBRARY 'SYS$LIBRARY:LIB.L32';

FORWARD ROUTINE
	SYS$ADD_HOLDER,
	SYS$ADD_IDENT,
	SYS$CREATE_RDB,
	SYS$FIND_HOLDER,
	SYS$MOD_HOLDER,
	SYS$MOD_IDENT,
	SYS$MOD_IDENT_ATTRIB,
	SYS$MOD_IDENT_ID,
	SYS$MOD_IDENT_NAME,
	SYS$REM_HOLDER,
	SYS$REM_IDENT;

LINKAGE
	EXE_VAL_IDNAME	= JSB (REGISTER=1; REGISTER=1, REGISTER=2) :
			  NOPRESERVE (3)
			  NOTUSED (4,5,6,7,8,9,10,11),
	EXE_ALOP1IMAG	= JSB (REGISTER=1; REGISTER=1,REGISTER=2) :
			  NOPRESERVE (3);

EXTERNAL ROUTINE
	EXE$OPEN_RDB	: ADDRESSING_MODE (ABSOLUTE),
	EXE$CLOSE_RDB	: NOVALUE ADDRESSING_MODE (ABSOLUTE),
	EXE$$FINISH_RDB	: ADDRESSING_MODE (ABSOLUTE),
	EXE$ALOP1IMAG	: EXE_ALOP1IMAG ADDRESSING_MODE (ABSOLUTE),
	EXE$VAL_IDNAME	: EXE_VAL_IDNAME ADDRESSING_MODE (ABSOLUTE),
	EXE$SET_RDIPTR	: ADDRESSING_MODE (ABSOLUTE),
	SYS$CMKRNL	: ADDRESSING_MODE (ABSOLUTE);

EXTERNAL 
	CTL$GL_RDIPTR 	: REF $BBLOCK ADDRESSING_MODE (ABSOLUTE),
	CTL$GL_IMGHDRBF : LONG ADDRESSING_MODE (ABSOLUTE),
	EXE$T_ID_UPCASE	: VECTOR [,BYTE] ADDRESSING_MODE (GENERAL);

BUILTIN
	PROBER,
	PROBEW;


LITERAL
	UIC$M_ID_FORM_FLAG = 1^31,	! mask for id form of identifier
	KGB$M_VALID_ATTRIB = KGB$M_RESOURCE; ! mask of valid attributes

%SBTTL ' SYS$ADD_HOLDER  -  add holder to RDB'
GLOBAL ROUTINE SYS$ADD_HOLDER (ID, HOLDER, ATTRIB) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine adds the specified holder record to the rights
!	database.
!
! CALLING SEQUENCE:
!	SYS$ADD_HOLDER (ID, HOLDER, ATTRIB)
!
! INPUT PARAMETERS:
!	ID:	identifier longword to associate the
!		holder record with
!	HOLDER:	address of the holder identifier quadword
!	ATTRIB: (optional) attributes longword to grant to the holder
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Status of operation
!
! SIDE EFFECTS:
!	Holder record created
!
!--

BEGIN

LOCAL
	LOC_ID		: LONG,		! local copy of ID
	LOC_HOLDER	: REF VECTOR,	! local copy of HOLDER
	HOLDER_ID	: VECTOR [2],	! local copy of holder id quadword
	LOC_ATTRIB	: LONG,		! local copy of ATTRIB
	ID_ATTRIB	: LONG,		! attributes of identifier
	STATUS		: LONG,		! general status value
	CLOSE		: LONG,		! call to EXE$CLOSE_RDB required flag
	RAB		: $RAB_DECL,	! RAB for file operations
	REC_BUFFER	: $BBLOCK [KGB$K_IDENT_RECORD];
					! general purpose record buffer

LABEL
	RDB_OPEN;			! rights database is open in this block

! Validate parameters
!

LOC_ID = .ID;
IF (.LOC_ID AND UIC$M_ID_FORM_FLAG) NEQU 0
THEN
    (IF (.LOC_ID GTRU UIC$K_LAST_ID) THEN RETURN SS$_IVIDENT)
ELSE
    (IF (.LOC_ID GTRU UIC$K_MAX_UIC) OR (.LOC_ID EQL 0) THEN RETURN SS$_IVIDENT);

LOC_HOLDER = .HOLDER;
IF NOT PROBER (%REF(0), %REF(8), .LOC_HOLDER) THEN RETURN SS$_ACCVIO;
HOLDER_ID[0] = .LOC_HOLDER[0];
HOLDER_ID[1] = .LOC_HOLDER[1];
IF .HOLDER_ID[0] GTRU UIC$K_MAX_UIC OR
   .HOLDER_ID[0] EQLU .LOC_ID OR
   .HOLDER_ID[1] NEQU 0
THEN
    RETURN SS$_IVIDENT;

LOC_ATTRIB = .ATTRIB;
IF (.LOC_ATTRIB AND NOT KGB$M_VALID_ATTRIB) NEQU 0 THEN RETURN SS$_BADPARAM;

! Get the rights database open for write.
!

$RAB_INIT (RAB = RAB,
	   RAC = KEY,
	   KRF = 0,
	   KBF = HOLDER_ID[0],
	   KSZ = 4,
	   ROP = (NLK, RRL),
	   UBF = REC_BUFFER,
	   USZ = KGB$K_IDENT_RECORD
	   );
STATUS = EXE$OPEN_RDB (0, 1, RAB[RAB$W_ISI], CLOSE);
IF NOT .STATUS THEN RETURN .STATUS;

RDB_OPEN:
    BEGIN

    ! Check to make sure that the holder ID exists.
    !

    STATUS = $FIND (RAB = RAB);
    IF .STATUS EQLU RMS$_RNF THEN STATUS = SS$_NOSUCHID;
    IF NOT .STATUS THEN LEAVE RDB_OPEN;

    ! Read and lock the ident record and save away its attributes.
    !

    RAB[RAB$V_RRL] = 0;
    RAB[RAB$V_NLK] = 0;
    RAB[RAB$V_RLK] = 1;
    RAB[RAB$V_ULK] = 1;
    RAB[RAB$V_WAT] = 1;
    RAB[RAB$L_KBF] = LOC_ID;
    STATUS = $GET (RAB = RAB);
    IF .STATUS EQLU RMS$_RNF THEN STATUS = SS$_NOSUCHID;
    IF NOT .STATUS
    THEN
	BEGIN
	$FREE (RAB = RAB);
	LEAVE RDB_OPEN;
	END;
    ID_ATTRIB = .REC_BUFFER[KGB$L_ATTRIBUTES];

    ! Now read all holder records to make sure that the specified holder
    ! doesn't already exist.
    !

    RAB[RAB$V_RLK] = 0;
    RAB[RAB$V_ULK] = 0;
    RAB[RAB$V_WAT] = 0;
    RAB[RAB$V_RRL] = 1;
    RAB[RAB$V_NLK] = 1;
    RAB[RAB$V_LIM] = 1;
    RAB[RAB$B_RAC] = RAB$C_SEQ;
    WHILE 1 DO
	BEGIN
	STATUS = $GET (RAB = RAB);
	IF .STATUS EQLU RMS$_EOF OR .STATUS EQLU RMS$_OK_LIM THEN EXITLOOP;
	IF NOT .STATUS
	THEN
	    BEGIN
	    $FREE (RAB = RAB);
	    LEAVE RDB_OPEN;
	    END;
	IF CH$EQL (KGB$S_HOLDER, HOLDER_ID[0], KGB$S_HOLDER, REC_BUFFER[KGB$Q_HOLDER])
	THEN
	    BEGIN
	    STATUS = SS$_DUPIDENT;
	    $FREE (RAB = RAB);
	    LEAVE RDB_OPEN;
	    END;
	END;

    ! Finally build and write the new holder record.
    !

    RAB[RAB$B_RAC] = RAB$C_KEY;
    RAB[RAB$W_RSZ] = KGB$K_HOLD_RECORD;
    RAB[RAB$L_RBF] = REC_BUFFER;
    REC_BUFFER[KGB$L_IDENTIFIER] = .LOC_ID;
    REC_BUFFER[KGB$L_ATTRIBUTES] = .LOC_ATTRIB AND .ID_ATTRIB;
    CH$MOVE (KGB$S_HOLDER, HOLDER_ID[0], REC_BUFFER[KGB$Q_HOLDER]);
    STATUS = $PUT (RAB = RAB);
    $FREE (RAB = RAB);
    END;

! Close the rights database if there is no image
!

IF .CLOSE THEN EXE$CLOSE_RDB();
IF .STATUS
THEN
    RETURN SS$_NORMAL
ELSE
    RETURN .STATUS;

END;					! End of routine SYS$ADD_HOLDER

%SBTTL ' SYS$ADD_IDENT  -  add identifier to RDB'
GLOBAL ROUTINE SYS$ADD_IDENT (NAME, ID, ATTRIB, RESID) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine creates the identifier of the specified name.
!	If an explicit identifier code is given, it is used; otherwise
!	the next available general code is used.
!
! CALLING SEQUENCE:
!	SYS$ADD_IDENT (NAME, ID, ATTRIB, RESID)
!
! INPUT PARAMETERS:
!	NAME:	address of the identifier name character
!		string descriptor
!	ID:	(optional) identifier longword to associate with 'name'
!	ATTRIB:	(optional) attributes longword to grant to the identifier
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	RESID:	(optional) address of a longword to return the assigned
!		identifier
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	success or failure status
!
! SIDE EFFECTS:
!	identifier record created
!
!--

BEGIN

LOCAL
	LOC_NAME	: REF VECTOR,	! local copy of NAME
	LENGTH		: LONG,		! output from EXE$VAL_IDNAME
	ADDRESS		: LONG,		! output from EXE$VAL_IDNAME
	LOC_ID		: LONG,		! local copy of ID
	IDENTIFIER	: LONG,		! identifier code to use
	LOC_ATTRIB	: LONG,		! local copy of ATTRIB
	LOC_RESID	: LONG,		! local copy of RESID
	STATUS		: LONG,		! general status value
	CLOSE		: LONG,		! call to EXE$CLOSE_RDB required flag
	RAB		: $RAB_DECL,	! RAB for record operations
	MAINT_RFA	: $BBLOCK [RAB$S_RFA],
					! RFA of maintenance record
	REC_BUFFER	: $BBLOCK [KGB$K_MAINT_RECORD],
					! general record buffer
	NAME_BUFFER	: $BBLOCK [KGB$S_NAME] ;
					! name key buffer

LABEL
	RDB_OPEN;			! rights database is open in this block

! Validate parameters
!

LOC_NAME = .NAME;
STATUS = EXE$VAL_IDNAME( .LOC_NAME; LENGTH, ADDRESS);
IF NOT .STATUS THEN RETURN .STATUS;
CH$TRANSLATE (EXE$T_ID_UPCASE, .LENGTH, .ADDRESS, ' ', KGB$S_NAME, NAME_BUFFER);

LOC_ID = .ID;
IF (.LOC_ID AND UIC$M_ID_FORM_FLAG) NEQU 0
THEN
    (IF (.LOC_ID GTRU UIC$K_LAST_ID) THEN RETURN SS$_IVIDENT)
ELSE
    (IF (.LOC_ID GTRU UIC$K_MAX_UIC) THEN RETURN SS$_IVIDENT);

LOC_ATTRIB = .ATTRIB;
IF (.LOC_ATTRIB AND NOT KGB$M_VALID_ATTRIB) NEQU 0 THEN RETURN SS$_BADPARAM;

LOC_RESID = .RESID;
IF .LOC_RESID NEQU 0 AND NOT PROBEW (%REF(0), %REF(4), .LOC_RESID)
THEN
    RETURN SS$_ACCVIO;

! Get the rights database open for write.
!

$RAB_INIT (RAB = RAB,
	   RAC = KEY,
	   KRF = 0,
	   KSZ = 4,
	   KBF = UPLIT (0),
	   ROP = (WAT, RLK, ULK),
	   USZ = KGB$K_MAINT_RECORD,
	   UBF = REC_BUFFER
	   );
STATUS = EXE$OPEN_RDB (0, 1, RAB[RAB$W_ISI], CLOSE);
IF NOT .STATUS THEN RETURN .STATUS;

RDB_OPEN:
    BEGIN

    ! First read the maintenance record to interlock the entire operation.
    !

    STATUS = $GET (RAB = RAB);
    IF NOT .STATUS
    THEN
	BEGIN
	$FREE (RAB = RAB);
	LEAVE RDB_OPEN;
	END;
    CH$MOVE (RAB$S_RFA, RAB[RAB$W_RFA], MAINT_RFA);

    ! Now see if the specified name is already in use.
    !

    RAB[RAB$V_WAT] = 0;
    RAB[RAB$V_ULK] = 0;
    RAB[RAB$V_RLK] = 0;
    RAB[RAB$V_NLK] = 1;
    RAB[RAB$V_RRL] = 1;
    RAB[RAB$B_KRF] = 2;
    RAB[RAB$B_KSZ] = KGB$S_NAME;
    RAB[RAB$L_KBF] = NAME_BUFFER;
    STATUS = $FIND (RAB = RAB);
    IF .STATUS THEN STATUS = SS$_DUPLNAM;
    IF .STATUS NEQU RMS$_RNF
    THEN
	BEGIN
	$FREE (RAB = RAB);
	LEAVE RDB_OPEN;
	END;

    ! If an explicit identifier is given, see if it is in use.
    !

    RAB[RAB$B_KRF] = 0;
    RAB[RAB$B_KSZ] = 4;

    IF .LOC_ID NEQU 0
    THEN
	BEGIN
	RAB[RAB$L_KBF] = LOC_ID;
	STATUS = $FIND (RAB = RAB);
	IF .STATUS THEN STATUS = SS$_DUPIDENT;
	IF .STATUS NEQU RMS$_RNF
	THEN
	    BEGIN
	    $FREE (RAB = RAB);
	    LEAVE RDB_OPEN;
	    END;
	IDENTIFIER = .LOC_ID;
	END

    ! Otherwise we have to select an identifier.
    !

    ELSE
	BEGIN
	IDENTIFIER = .REC_BUFFER[KGB$L_NEXT_ID];

	! Attempt to get the record pointed to by the new identifier. If it
	! exists, keep incrementing until a free identifier is found. Wrap
	! the identifier value when it overflows.
	!

	RAB[RAB$L_KBF] = IDENTIFIER;
	WHILE 1 DO
	    BEGIN
	    IF .IDENTIFIER GTRU UIC$K_LAST_ID
	    THEN
		IDENTIFIER = UIC$K_FIRST_ID;
	    STATUS = $FIND (RAB = RAB);
	    IF NOT .STATUS
	    THEN
		BEGIN
		IF .STATUS EQLU RMS$_RNF
		THEN
		    EXITLOOP
		ELSE
		    BEGIN
		    $FREE (RAB = RAB);
		    LEAVE RDB_OPEN;
		    END;
		END;
	    IDENTIFIER = .IDENTIFIER + 1;
	    END;

	! Write back the maintenance record with an updated next identifier
	! value. Note that while we increment the identifier here, it is
	! not necessary to wrap it, since that is done in the check above.
	!

	REC_BUFFER[KGB$L_NEXT_ID] = .IDENTIFIER + 1;
	RAB[RAB$B_RAC] = RAB$C_RFA;
	CH$MOVE (RAB$S_RFA, MAINT_RFA, RAB[RAB$W_RFA]);
	STATUS = $FIND (RAB = RAB);
	IF NOT .STATUS
	THEN
	    BEGIN
	    $FREE (RAB = RAB);
	    LEAVE RDB_OPEN;
	    END;

	STATUS = $UPDATE (RAB = RAB);
	IF NOT .STATUS
	THEN
	    BEGIN
	    $FREE (RAB = RAB);
	    LEAVE RDB_OPEN;
	    END;
	END;

    IF .LOC_RESID NEQU 0 THEN .LOC_RESID = .IDENTIFIER;

    ! Finally create the new identifier record and write it.
    !

    REC_BUFFER[KGB$L_IDENTIFIER] = .IDENTIFIER;
    REC_BUFFER[KGB$L_ATTRIBUTES] = .LOC_ATTRIB;
    CH$FILL (0, KGB$S_HOLDER, REC_BUFFER[KGB$Q_HOLDER]);
    CH$MOVE (KGB$S_NAME, NAME_BUFFER, REC_BUFFER[KGB$T_NAME]);
    RAB[RAB$B_RAC] = RAB$C_KEY;
    RAB[RAB$W_RSZ] = KGB$K_IDENT_RECORD;
    RAB[RAB$L_RBF] = REC_BUFFER;
    STATUS = $PUT (RAB = RAB);
    $FREE (RAB = RAB);
    END;

! Close the rights database if there is no image
!

IF .CLOSE THEN EXE$CLOSE_RDB();
IF .STATUS
THEN
    RETURN SS$_NORMAL
ELSE
    RETURN .STATUS;

END;					! End of routine SYS$ADD_IDENT

%SBTTL ' SYS$CREATE_RDB  -  create rights data base'
GLOBAL ROUTINE SYS$CREATE_RDB (SYSID) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine creates a new rights database. After creation the
!	database contains the maintenance record and records for the
!	environmental rights.
!
! CALLING SEQUENCE:
!	SYS$CREATE_RDB (SYSID)
!
! INPUT PARAMETERS:
!	SYSID:	(optional) address of the quadword system identifier
!		to store in the maintenance record
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Status value of operation
!
! SIDE EFFECTS:
!	All active streams terminated, rights cache flushed,
!	rights database created and opened
!
!--

BEGIN

REGISTER
	SIZE		= 1,		! size returned from EXE$ALOP1IMAG
	ADDRESS		= 2;		! address returned from EXE$ALOP1IMAG

LOCAL
	LOC_SYSID	: REF VECTOR,	! local copy of SYSID
	STATUS		: LONG,		! general status value
	CLOSE		: BYTE,		! close rights database flag
	MAINT_RECORD	: $BBLOCK [KGB$K_MAINT_RECORD],
					! buffer to build maintenance record
	FAB		: $FAB_DECL,	! FAB to create rights database
	RAB		: $RAB_DECL,	! RAB for rights database
	KEY0		: $XABKEY_DECL,	! XAB for primary key (identifier)
	KEY1		: $XABKEY_DECL,	! XAB for holder key
	KEY2		: $XABKEY_DECL,	! XAB for name key
	PROTECT		: $XABPRO_DECL,	! XAB for file protection
	ARGLIST		: VECTOR [2]	! argument list for EXE$SET_RDIPTR
			  INITIAL (1,0);

LABEL
	RDB_OPEN;			! rights database is open in this block

! Validate parameters
!

LOC_SYSID = .SYSID;
IF .LOC_SYSID NEQU 0 AND NOT PROBER (%REF(0), %REF(8), .LOC_SYSID)
THEN
    RETURN SS$_ACCVIO;

! Do not open if file already exists
!

$FAB_INIT (FAB = FAB,
	   FNM = 'RIGHTSLIST',
           DNM = 'SYS$SYSTEM:.DAT',
           FAC = GET,
           SHR = (GET, PUT, DEL, UPD) );

STATUS = $OPEN(FAB=FAB);
IF .STATUS THEN
   RETURN RMS$_FEX;

! Allocate RDI if it has not been allocated already
!

IF .CTL$GL_RDIPTR EQLU 0
THEN
    BEGIN
    STATUS = EXE$ALOP1IMAG (RDI$S_RDIDEF; SIZE, ADDRESS);
    IF NOT .STATUS THEN RETURN SS$_INSFMEM;
    .ADDRESS = .SIZE;
    ARGLIST[1] = .ADDRESS;
    STATUS = SYS$CMKRNL(EXE$SET_RDIPTR, ARGLIST);
    IF NOT .STATUS THEN RETURN .STATUS;
    CH$FILL (0, RDI$S_RDIDEF-4, .CTL$GL_RDIPTR+4);
    END

! Else Close out all active streams to the rights database
!

ELSE
    EXE$CLOSE_RDB();

! Now set up the FAB and XAB's and create the file.
!

$FAB_INIT (FAB = FAB,
	   FNM = 'RIGHTSLIST',
	   DNM = 'SYS$SYSTEM:.DAT',
	   ORG = IDX,
	   RFM = VAR,
	   MRS = KGB$K_MAINT_RECORD,
	   BKS = 2048,
	   XAB = KEY0,
	   FOP = (CBT, DFW),
	   FAC = (GET, PUT, DEL, UPD),
	   SHR = (GET, PUT, DEL, UPD)
	   );
FAB[FAB$V_LNM_MODE] = PSL$C_EXEC;

$XABKEY_INIT (
	   XAB = KEY0,
	   KREF = 0,
	   KNM = UPLIT BYTE ('IDENTIFIER                      '),
	   POS = $BYTEOFFSET (KGB$L_IDENTIFIER),
	   SIZ = 4,
	   DTP = BN4,
	   FLG = DUP,
	   NXT = KEY1
	   );

$XABKEY_INIT (
	   XAB = KEY1,
	   KREF = 1,
	   KNM = UPLIT BYTE ('HOLDER                          '),
	   POS = $BYTEOFFSET (KGB$Q_HOLDER),
	   SIZ = 8,
	   DTP = STG,
	   FLG = (DUP, NUL, CHG),
	   NUL = 0,
	   NXT = KEY2
	   );

$XABKEY_INIT (
	   XAB = KEY2,
	   KREF = 2,
	   KNM = UPLIT BYTE ('NAME                            '),
	   POS = $BYTEOFFSET (KGB$T_NAME),
	   SIZ = KGB$S_NAME,
	   DTP = STG,
	   FLG = (NUL,CHG),
	   NUL = 0,
	   NXT = PROTECT
	   );

$XABPRO_INIT (
	   XAB = PROTECT,
	   PRO = (RWED, RWED, R, R),
	   UIC = (1,4)
	   );

IF .CTL$GL_IMGHDRBF EQLU 0
THEN
    BEGIN
    CLOSE = 1;
    FAB[FAB$V_PPF] = 1;
    END
ELSE
    CLOSE = 0;
STATUS = $CREATE (FAB = FAB);
IF NOT .STATUS THEN RETURN .STATUS;

RDB_OPEN:
    BEGIN
    CTL$GL_RDIPTR[RDI$L_IFI_WRITE] = .FAB[FAB$W_IFI];

    ! Now set up and connect a RAB, and write the maintenance record.
    !

    $RAB_INIT (RAB = RAB,
	       FAB = FAB,
	       RAC = KEY,
	       RBF = MAINT_RECORD,
	       RSZ = KGB$K_MAINT_RECORD
	       );

    STATUS = $CONNECT (RAB = RAB);
    IF NOT .STATUS THEN LEAVE RDB_OPEN;
    VECTOR [CTL$GL_RDIPTR[RDI$L_ISI_VEC], 0] = .RAB[RAB$W_ISI];

    CH$FILL (0, KGB$K_MAINT_RECORD, MAINT_RECORD);
    CH$MOVE (KGB$S_NAME, UPLIT BYTE ('$$MAINTENANCE_RECORD            '),
	     MAINT_RECORD[KGB$T_NAME]);
    IF .LOC_SYSID NEQU 0
    THEN
	CH$MOVE (KGB$S_SYS_ID, .LOC_SYSID, MAINT_RECORD[KGB$Q_SYS_ID])
    ELSE
	$GETTIM (TIMADR = MAINT_RECORD[KGB$Q_SYS_ID]);
    MAINT_RECORD[KGB$W_LEVEL] = KGB$K_LEVEL1;
    MAINT_RECORD[KGB$L_NEXT_ID] = UIC$K_FIRST_ID;

    STATUS = $PUT (RAB = RAB);
    IF NOT .STATUS THEN LEAVE RDB_OPEN;

    ! Create records for the environmental rights
    !

    RAB[RAB$W_RSZ] = KGB$K_IDENT_RECORD;

    MAINT_RECORD[KGB$L_IDENTIFIER] = KGB$K_BATCH_ID;
    CH$MOVE (KGB$S_NAME, UPLIT BYTE ('BATCH                           '),
	     MAINT_RECORD[KGB$T_NAME]);
    STATUS = $PUT (RAB = RAB);
    IF NOT .STATUS THEN LEAVE RDB_OPEN;

    MAINT_RECORD[KGB$L_IDENTIFIER] = KGB$K_DIALUP_ID;
    CH$MOVE (KGB$S_NAME, UPLIT BYTE ('DIALUP                          '),
	     MAINT_RECORD[KGB$T_NAME]);
    STATUS = $PUT (RAB = RAB);
    IF NOT .STATUS THEN LEAVE RDB_OPEN;

    MAINT_RECORD[KGB$L_IDENTIFIER] = KGB$K_INTERACTIVE_ID;
    CH$MOVE (KGB$S_NAME, UPLIT BYTE ('INTERACTIVE                     '),
	     MAINT_RECORD[KGB$T_NAME]);
    STATUS = $PUT (RAB = RAB);
    IF NOT .STATUS THEN LEAVE RDB_OPEN;

    MAINT_RECORD[KGB$L_IDENTIFIER] = KGB$K_LOCAL_ID;
    CH$MOVE (KGB$S_NAME, UPLIT BYTE ('LOCAL                           '),
	     MAINT_RECORD[KGB$T_NAME]);
    STATUS = $PUT (RAB = RAB);
    IF NOT .STATUS THEN LEAVE RDB_OPEN;

    MAINT_RECORD[KGB$L_IDENTIFIER] = KGB$K_NETWORK_ID;
    CH$MOVE (KGB$S_NAME, UPLIT BYTE ('NETWORK                         '),
	     MAINT_RECORD[KGB$T_NAME]);
    STATUS = $PUT (RAB = RAB);
    IF NOT .STATUS THEN LEAVE RDB_OPEN;

    MAINT_RECORD[KGB$L_IDENTIFIER] = KGB$K_REMOTE_ID;
    CH$MOVE (KGB$S_NAME, UPLIT BYTE ('REMOTE                          '),
	     MAINT_RECORD[KGB$T_NAME]);
    STATUS = $PUT (RAB = RAB);
    IF NOT .STATUS THEN LEAVE RDB_OPEN;

    STATUS = SS$_NORMAL;
    END;

IF .CLOSE THEN EXE$CLOSE_RDB();
RETURN .STATUS;
END;					! End of routine SYS$CREATE_RDB

%SBTTL ' SYS$FIND_HOLDER  -  search RDB for ident holders'
GLOBAL ROUTINE SYS$FIND_HOLDER (ID, HOLDER, ATTRIB, CONTXT) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine searches the rights database for all holders
!	of the specified identifier, and returns their identifier and
!	attributes.
!
! CALLING SEQUENCE:
!	SYS$FIND_HOLDER (ID, HOLDER, ATTRIB, CONTXT)
!
! INPUT PARAMETERS:
!	ID:	 identifier longword whose holder records
!		 are to be found
!	CONTXT:  (optional) address of a longword containing the
!		 record stream context. initially should be zero,
!		 value output on first call, value input on
!		 subsequent calls.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	HOLDER:	 (optional) address to return the holder id quadword
!	ATTRIB:	 (optional) address to return the attributes longword
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Status of operation
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN

LOCAL
	LOC_ID		: LONG,		! local copy of ID
	LOC_HOLDER	: LONG,		! local copy of HOLDER
	LOC_ATTRIB	: LONG,		! local copy of ATTRIB
	LOC_CONTXT	: LONG,		! local copy of CONTXT
	STATUS		: LONG,		! general status value
	CONTINUE	: LONG,		! flag indicating continuation
	CLOSE		: LONG,		! call to EXE$CLOSE_RDB required flag
	RAB		: $RAB_DECL,	! RAB for file I/O
	REC_BUFFER	: $BBLOCK [KGB$K_IDENT_RECORD];
					! record buffer to read records


LABEL
	RDB_OPEN;			! rights database is open in this block

! Validate parameters
!

LOC_ID = .ID;
IF (.LOC_ID AND UIC$M_ID_FORM_FLAG) NEQU 0
THEN
    (IF (.LOC_ID GTRU UIC$K_LAST_ID) THEN RETURN SS$_IVIDENT)
ELSE
    (IF (.LOC_ID GTRU UIC$K_MAX_UIC) OR (.LOC_ID EQL 0) THEN RETURN SS$_IVIDENT);

LOC_HOLDER = .HOLDER;
IF .LOC_HOLDER NEQU 0 AND NOT PROBEW (%REF(0), %REF(8), .LOC_HOLDER)
THEN
    RETURN SS$_ACCVIO;

LOC_ATTRIB = .ATTRIB;
IF .LOC_ATTRIB NEQU 0 AND NOT PROBEW (%REF(0), %REF(4), .LOC_ATTRIB)
THEN
    RETURN SS$_ACCVIO;

LOC_CONTXT = .CONTXT;
IF .LOC_CONTXT NEQU 0 AND NOT PROBEW (%REF(0), %REF(4), .LOC_CONTXT)
THEN
    RETURN SS$_ACCVIO;

! Open the rights database for reading. Record whether this is an initial
! call or a continuation by checking if the context is zero or not.
!

CONTINUE = (IF .LOC_CONTXT NEQU 0 THEN ..LOC_CONTXT NEQU 0 ELSE 0);

$RAB_INIT (RAB = RAB,
	   RAC = KEY,
	   KRF = 0,
	   KSZ = 4,
	   KBF = LOC_ID,
	   ROP = (WAT, NLK, LIM),
	   USZ = KGB$K_IDENT_RECORD,
	   UBF = REC_BUFFER
	   );
STATUS = EXE$OPEN_RDB (.LOC_CONTXT, 0, RAB[RAB$W_ISI], CLOSE);
IF NOT .STATUS THEN RETURN .STATUS;

RDB_OPEN:
    BEGIN

    ! On an initial call, do an indexed $GET to position to the identifier
    ! record.
    !

    IF NOT .CONTINUE
    THEN
	BEGIN
	STATUS = $GET (RAB = RAB);
	IF .STATUS EQLU RMS$_RNF THEN STATUS = SS$_NOSUCHID;
	IF NOT .STATUS
	THEN
	    BEGIN
	    EXE$$FINISH_RDB (.LOC_CONTXT);
	    LEAVE RDB_OPEN;
	    END;
	END;

    ! Switch to sequential mode and read the next holder record, and
    ! return the data items.
    !

    RAB[RAB$B_RAC] = RAB$C_SEQ;
    STATUS = $GET (RAB = RAB);
    IF .STATUS EQLU RMS$_EOF OR .STATUS EQLU RMS$_OK_LIM
    THEN
	STATUS = SS$_NOSUCHID;
    IF NOT .STATUS
    THEN
	BEGIN
	EXE$$FINISH_RDB (.LOC_CONTXT);
	LEAVE RDB_OPEN;
	END;

    IF .LOC_HOLDER NEQU 0
    THEN
	CH$MOVE (KGB$S_HOLDER, REC_BUFFER[KGB$Q_HOLDER], .LOC_HOLDER);
    IF .LOC_ATTRIB NEQU 0
    THEN
	.LOC_ATTRIB = .REC_BUFFER[KGB$L_ATTRIBUTES];

    STATUS = SS$_NORMAL;
    END;

! Close the rights database if there is no image
!

IF .CLOSE THEN EXE$CLOSE_RDB();
RETURN .STATUS
END;					! End of routine SYS$FIND_HOLDER

%SBTTL ' SYS$MOD_HOLDER  -  modify holder record'
GLOBAL ROUTINE SYS$MOD_HOLDER (ID, HOLDER, SET_ATTRIB, CLR_ATTRIB) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine modifies the specified holder record.
!
! CALLING SEQUENCE:
!	SYS$MOD_HOLDER (ID, HOLDER, SET_ATTRIB, CLR_ATTRIB)
!
! INPUT PARAMETERS:
!	ID:	    identifier longword
!	HOLDER:	    address of the holder identifier quadword
!	SET_ATTRIB: (optional) longword containing the attributes to set
!		    into the holder record
!	CLR_ATTRIB: (optional) longword containing the attributes to clear
!		    in the holder record
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Status of operation
!
! SIDE EFFECTS:
!	Holder record modified
!
!--

BEGIN

LOCAL
	LOC_ID		: LONG,		! local copy of ID
	LOC_HOLDER	: REF VECTOR,	! local copy of HOLDER
	HOLDER_ID	: VECTOR [2],	! local copy of holder id quadword
	LOC_SET_ATTRIB	: LONG,		! local copy of SET_ATTRIB
	LOC_CLR_ATTRIB	: LONG,		! local copy of CLR_ATTRIB
	ID_ATTRIB	: LONG,		! attributes of identifier
	STATUS		: LONG,		! general status value
	CLOSE		: LONG,		! call to EXE$CLOSE_RDB required flag
	RAB		: $RAB_DECL,	! RAB for file operations
	REC_BUFFER	: $BBLOCK [KGB$K_IDENT_RECORD];
					! general purpose record buffer


LABEL
	RDB_OPEN;			! rights database is open in this block

! Validate parameters
!

LOC_ID = .ID;
IF (.LOC_ID AND UIC$M_ID_FORM_FLAG) NEQU 0
THEN
    (IF (.LOC_ID GTRU UIC$K_LAST_ID) THEN RETURN SS$_IVIDENT)
ELSE
    (IF (.LOC_ID GTRU UIC$K_MAX_UIC) OR (.LOC_ID EQL 0) THEN RETURN SS$_IVIDENT);

LOC_HOLDER = .HOLDER;
IF NOT PROBER (%REF(0), %REF(8), .LOC_HOLDER) THEN RETURN SS$_ACCVIO;
HOLDER_ID[0] = .LOC_HOLDER[0];
HOLDER_ID[1] = .LOC_HOLDER[1];
IF .HOLDER_ID[0] GTRU UIC$K_MAX_UIC OR .HOLDER_ID[1] NEQU 0
THEN
    RETURN SS$_IVIDENT;

LOC_SET_ATTRIB = .SET_ATTRIB;
IF (.LOC_SET_ATTRIB AND NOT KGB$M_VALID_ATTRIB) NEQU 0 THEN RETURN SS$_BADPARAM;

LOC_CLR_ATTRIB = .CLR_ATTRIB;
IF (.LOC_CLR_ATTRIB AND NOT KGB$M_VALID_ATTRIB) NEQU 0 THEN RETURN SS$_BADPARAM;

! Get the rights database open for write.
!

$RAB_INIT (RAB = RAB,
	   RAC = KEY,
	   KRF = 0,
	   KBF = LOC_ID,
	   KSZ = 4,
	   ROP = (LIM, WAT, RLK, ULK),
	   UBF = REC_BUFFER,
	   USZ = KGB$K_IDENT_RECORD
	   );
STATUS = EXE$OPEN_RDB (0, 1, RAB[RAB$W_ISI], CLOSE);
IF NOT .STATUS THEN RETURN .STATUS;

RDB_OPEN:
    BEGIN

    ! Read and lock the ident record and save away its attributes.
    !

    STATUS = $GET (RAB = RAB);
    IF .STATUS EQLU RMS$_RNF THEN STATUS = SS$_NOSUCHID;
    IF NOT .STATUS
    THEN
	BEGIN
	$FREE (RAB = RAB);
	LEAVE RDB_OPEN;
	END;
    ID_ATTRIB = .REC_BUFFER[KGB$L_ATTRIBUTES];

    ! Read the holder records looking for the specified one.
    !

    RAB[RAB$V_ULK] = 0;
    RAB[RAB$B_RAC] = RAB$C_SEQ;
    WHILE 1 DO
	BEGIN
	STATUS = $GET (RAB = RAB);
	IF .STATUS EQLU RMS$_EOF OR .STATUS EQLU RMS$_OK_LIM
	THEN
	    BEGIN
	    $FREE (RAB = RAB);
	    STATUS = SS$_NOSUCHID;
	    LEAVE RDB_OPEN;
	    END;

	IF CH$EQL (KGB$S_HOLDER, HOLDER_ID[0], KGB$S_HOLDER, REC_BUFFER[KGB$Q_HOLDER])
	THEN
	    EXITLOOP;
	END;

    ! Now set and clear attributes as specified, but limited by the ident
    ! record attributes.
    !

    IF .LOC_CLR_ATTRIB NEQU 0
    THEN
	REC_BUFFER[KGB$L_ATTRIBUTES] =
	.REC_BUFFER[KGB$L_ATTRIBUTES] AND NOT .LOC_CLR_ATTRIB;
    IF .LOC_SET_ATTRIB NEQU 0
    THEN
	REC_BUFFER[KGB$L_ATTRIBUTES] =
	(.REC_BUFFER[KGB$L_ATTRIBUTES] OR .LOC_SET_ATTRIB) AND .ID_ATTRIB;

    STATUS = $UPDATE (RAB = RAB);
    $FREE (RAB = RAB);
    END;

! Close the rights database if there is no image
!

IF .CLOSE THEN EXE$CLOSE_RDB();
IF .STATUS
THEN
    RETURN SS$_NORMAL
ELSE
    RETURN .STATUS;

END;					! End of routine SYS$MOD_HOLDER


%SBTTL ' SYS$MOD_IDENT  -  Modify identifier record'
GLOBAL ROUTINE SYS$MOD_IDENT (ID, SET_ATTRIB, CLR_ATTRIB, NEW_NAME, NEW_ID) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine modifies the attributes of the specified
!	identifier.
!
! CALLING SEQUENCE:
!	SYS$MOD_IDENT (ID, SET_ATTRIB, CLR_ATTRIB, NEW_NAME, NEW_ID )
!
! INPUT PARAMETERS:
!	ID:	    identifier longword
!	SET_ATTRIB: (optional) longword containing the attributes
!		    to set into the identifier record
!	CLR_ATTRIB: (optional) longword containing the attributes
!		    to clear in the identifier record
!	NEW_NAME:   address of a character string descriptor for
!	            the new name
!	NEW_ID:     new identifier value
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Status of operation
!
! SIDE EFFECTS:
!	Identifier record modified
!
!--

BEGIN
LITERAL
	BUFFER_LENGTH = MAX ( KGB$K_HOLD_RECORD,
	                      KGB$K_IDENT_RECORD,
	                      KGB$K_MAINT_RECORD ) ;

LOCAL
	LOC_ID		: $BBLOCK[4],	! local copy of ID
	LOC_SET_ATTRIB	: LONG,		! local copy of SET_ATTRIB
	LOC_CLR_ATTRIB	: LONG,		! local copy of CLR_ATTRIB
	LOC_NEW_NAME	: LONG,		! local copy of NEW_NAME
	LOC_NEW_ID	: $BBLOCK[4],	! local copy of NEW_ID
	NEW_NAMLEN	: LONG,		! Length of new name
	NEW_NAMADR	: LONG,		! address of new name
	STATUS		: LONG,		! general status value
	CLOSE		: LONG,		! call to EXE$CLOSE_RDB required flag
	RAB		: $RAB_DECL,	! RAB for file I/O
	REC_BUFFER	: $BBLOCK [BUFFER_LENGTH];
					! record buffer for records

LABEL
	RDB_OPEN;			! rights database is open in this block

! Validate parameters
!

LOC_ID = .ID;
IF .LOC_ID[UIC$V_FORMAT] EQL UIC$K_ID_FORMAT
THEN
    (IF (.LOC_ID GTRU UIC$K_LAST_ID) THEN RETURN SS$_IVIDENT)
ELSE
    (IF (.LOC_ID GTRU UIC$K_MAX_UIC) OR (.LOC_ID EQL 0) THEN RETURN SS$_IVIDENT);

LOC_SET_ATTRIB = .SET_ATTRIB;
IF (.LOC_SET_ATTRIB AND NOT KGB$M_VALID_ATTRIB) NEQU 0 THEN RETURN SS$_BADPARAM;

LOC_CLR_ATTRIB = .CLR_ATTRIB;
IF (.LOC_CLR_ATTRIB AND NOT KGB$M_VALID_ATTRIB) NEQU 0 THEN RETURN SS$_BADPARAM;

LOC_NEW_NAME = .NEW_NAME ;
IF .LOC_NEW_NAME NEQ 0
THEN
    BEGIN
    STATUS = EXE$VAL_IDNAME ( .LOC_NEW_NAME ; NEW_NAMLEN, NEW_NAMADR ) ;
    IF NOT .STATUS THEN RETURN .STATUS ;
    END ;

LOC_NEW_ID = .NEW_ID;
IF .LOC_NEW_ID NEQ 0
THEN
    BEGIN
    IF .LOC_NEW_ID[UIC$V_FORMAT] EQL UIC$K_ID_FORMAT
    THEN
	(IF (.LOC_NEW_ID GTRU UIC$K_LAST_ID) THEN RETURN SS$_IVIDENT)
    ELSE
	(IF (.LOC_NEW_ID GTRU UIC$K_MAX_UIC) THEN RETURN SS$_IVIDENT);
    
    ! Do not allow a format switch
    !
    IF .LOC_ID[UIC$V_FORMAT] NEQ .LOC_NEW_ID[UIC$V_FORMAT]
    THEN RETURN SS$_IVIDENT;
    END ;

! Open the rights database for writing.
!
$RAB_INIT (RAB = RAB,
	   RAC = KEY,
	   KRF = 0,
	   KSZ = 4,
	   KBF = LOC_ID,
	   ROP = (LIM, WAT, RLK, ULK),
	   USZ = BUFFER_LENGTH,
	   UBF = REC_BUFFER
	   );
STATUS = EXE$OPEN_RDB (0, 1, RAB[RAB$W_ISI], CLOSE);
IF NOT .STATUS THEN RETURN .STATUS;

RDB_OPEN:
    BEGIN

    !
    ! Modify the identifier name
    !
    IF .LOC_NEW_NAME NEQ 0
    THEN
	BEGIN
	STATUS = SYS$MOD_IDENT_NAME ( RAB, .LOC_ID, .NEW_NAMLEN, .NEW_NAMADR ) ;
	IF NOT .STATUS THEN LEAVE RDB_OPEN ;
	END ;

    !
    ! Modify the identifier attributes
    !
    IF ( .LOC_CLR_ATTRIB NEQ 0 ) OR
       ( .LOC_SET_ATTRIB NEQ 0 )
    THEN
	BEGIN
	STATUS = SYS$MOD_IDENT_ATTRIB ( RAB, .LOC_ID,
					.LOC_SET_ATTRIB, .LOC_CLR_ATTRIB ) ;
	IF NOT .STATUS THEN LEAVE RDB_OPEN ;
	END ;


    !
    ! Modify the identifier value
    !
    IF .LOC_NEW_ID NEQ 0
    THEN
	BEGIN
	STATUS = SYS$MOD_IDENT_ID ( RAB, .LOC_ID, .LOC_NEW_ID ) ;
	IF NOT .STATUS THEN LEAVE RDB_OPEN ;
	END ;

    END;		! End of RDB_OPEN

! Close the rights database if there is no image
!

IF .CLOSE THEN EXE$CLOSE_RDB();
IF .STATUS
THEN
    RETURN SS$_NORMAL
ELSE
    RETURN .STATUS;

END;					! End of routine SYS$MOD_IDENT


%SBTTL ' SYS$MOD_IDENT_ATTRIB  -  Modify identifier attributes'
ROUTINE SYS$MOD_IDENT_ATTRIB ( RAB_PTR, ID, SET_ATTRIB, CLR_ATTRIB) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine modifies the attributes of the specified
!	identifier.
!
! CALLING SEQUENCE:
!	SYS$MOD_IDENT_ATTRIB ( RAB_PTR, ID, SET_ATTRIB, CLR_ATTRIB)
!
! INPUT PARAMETERS:
!	RAB_PTR:    address of RAB for open rights data base file
!	ID:	    identifier longword
!	SET_ATTRIB: (optional) longword containing the attributes
!		    to set into the identifier record
!	CLR_ATTRIB: (optional) longword containing the attributes
!		    to clear in the identifier record
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Status of operation
!
! SIDE EFFECTS:
!	Identifier record modified
!
!--

BEGIN

LABEL
    MOD_ATTRIB ;

BIND
    RAB		= .RAB_PTR		: $RAB_DECL ,
    REC_BUFFER	= .RAB[RAB$L_UBF]	: $BBLOCK ;

LOCAL
    KRFSAV	: BYTE ,
    KSZSAV	: BYTE ,
    KBFSAV	: LONG ,
    RACSAV	: BYTE ,
    ROPSAV	: LONG ,
    USZSAV	: WORD ,
    IDENT_RFA	: $BBLOCK [RAB$S_RFA],	! RFA of ident record
    STATUS	: LONG ;

!
! Save the state of the RAB
!
KRFSAV = .RAB[RAB$B_KRF] ;
KSZSAV = .RAB[RAB$B_KSZ] ;
KBFSAV = .RAB[RAB$L_KBF] ;
RACSAV = .RAB[RAB$B_RAC] ;
ROPSAV = .RAB[RAB$L_ROP] ;
USZSAV = .RAB[RAB$W_USZ] ;

!
! Set up the RAB for key record access using the id key (primary)
!
RAB[RAB$B_RAC] = RAB$C_KEY ;
RAB[RAB$L_KBF] = ID ;
RAB[RAB$B_KSZ] = 4 ;
RAB[RAB$B_KRF] = 0 ;
RAB[RAB$L_ROP] = RAB$M_LIM OR
                 RAB$M_WAT OR
                 RAB$M_RLK OR
                 RAB$M_ULK ;
RAB[RAB$W_USZ] = KGB$K_IDENT_RECORD ;

MOD_ATTRIB:
    BEGIN

    ! If we are clearing attributes, we have to fix up the holder records
    ! first. Locate the identifier record.
    !
    IF .CLR_ATTRIB NEQU 0
    THEN
	BEGIN
	STATUS = $GET (RAB = RAB);
	IF .STATUS EQLU RMS$_RNF THEN STATUS = SS$_NOSUCHID;
	IF NOT .STATUS THEN LEAVE MOD_ATTRIB ;
	CH$MOVE (RAB$S_RFA, RAB[RAB$W_RFA], IDENT_RFA);

	! Now sequentially locate all the holder records and modify them.
	!

	RAB[RAB$B_RAC] = RAB$C_SEQ;
	RAB[RAB$V_ULK] = 0;
	WHILE 1 DO
	    BEGIN
	    STATUS = $GET (RAB = RAB);
	    IF .STATUS EQLU RMS$_EOF OR .STATUS EQLU RMS$_OK_LIM THEN EXITLOOP;
	    IF NOT .STATUS THEN LEAVE MOD_ATTRIB ;

	    REC_BUFFER[KGB$L_ATTRIBUTES] =
	    .REC_BUFFER[KGB$L_ATTRIBUTES] AND NOT .CLR_ATTRIB;
	    STATUS = $UPDATE (RAB = RAB);
	    IF NOT .STATUS THEN LEAVE MOD_ATTRIB ;
	    END;

	RAB[RAB$B_RAC] = RAB$C_RFA;
	CH$MOVE (RAB$S_RFA, IDENT_RFA, RAB[RAB$W_RFA]);
	END;

    ! Read the ident record, set and clear attributes as directed, and write
    ! it back.
    !

    STATUS = $GET (RAB = RAB);
    IF .STATUS EQLU RMS$_RNF THEN STATUS = SS$_NOSUCHID;
    IF NOT .STATUS THEN LEAVE MOD_ATTRIB ;

    IF .CLR_ATTRIB NEQU 0
    THEN
	REC_BUFFER[KGB$L_ATTRIBUTES] =
	.REC_BUFFER[KGB$L_ATTRIBUTES] AND NOT .CLR_ATTRIB;
    IF .SET_ATTRIB NEQU 0
    THEN
	REC_BUFFER[KGB$L_ATTRIBUTES] =
	.REC_BUFFER[KGB$L_ATTRIBUTES] OR .SET_ATTRIB;
    STATUS = $UPDATE (RAB = RAB);
    END;

!
! Clean up locks.
!
$FREE ( RAB = RAB ) ;

!
! Restore RAB
!
RAB[RAB$B_KRF] = .KRFSAV ;
RAB[RAB$B_KSZ] = .KSZSAV ;
RAB[RAB$L_KBF] = .KBFSAV ;
RAB[RAB$B_RAC] = .RACSAV ;
RAB[RAB$L_ROP] = .ROPSAV ;
RAB[RAB$W_USZ] = .USZSAV ;

!
! Get back to the beginning
!
IF .STATUS
    THEN STATUS = $REWIND ( RAB = RAB ) ;


RETURN .STATUS;

END;					! End of routine SYS$MOD_IDENT_ATTRIB


%SBTTL ' SYS$MOD_IDENT_ID  -  Modify identifier value'
ROUTINE SYS$MOD_IDENT_ID ( RAB_PTR, ID, NEW_ID ) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine modifies the name of the specified
!	identifier.
!
! CALLING SEQUENCE:
!	SYS$MOD_IDENT_ID ( RAB_PTR, ID, .NEW_ID )
!
! INPUT PARAMETERS:
!	RAB_PTR:	Address of RAB for the open rights data base file
!	ID:		identifier longword
!	NEW_ID:		new value for identifier
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Status of operation
!
! SIDE EFFECTS:
!	Identifier record modified
!
!--

BEGIN

!
! If the size of the holder ever changes then the OLD_HOLDER and NEW_HOLDER
! vectors will have to be adjusted.
!
$ASSUME ( KGB$S_HOLDER, EQL, 8 ) ;

LABEL
    MOD_ID ;

BIND
    RAB		= .RAB_PTR		: $RAB_DECL ,
    REC_BUFF	= .RAB[RAB$L_UBF]	: $BBLOCK ;

LOCAL
    KRFSAV	: BYTE ,
    KSZSAV	: BYTE ,
    KBFSAV	: LONG ,
    RACSAV	: BYTE ,
    ROPSAV	: LONG ,
    USZSAV	: WORD ,
    OLD_HOLDER	: VECTOR [2,LONG],
    NEW_HOLDER	: VECTOR [2,LONG],
    STATUS	: LONG ;

KRFSAV = .RAB[RAB$B_KRF] ;
KSZSAV = .RAB[RAB$B_KSZ] ;
KBFSAV = .RAB[RAB$L_KBF] ;
RACSAV = .RAB[RAB$B_RAC] ;
ROPSAV = .RAB[RAB$L_ROP] ;
USZSAV = .RAB[RAB$W_USZ] ;

MOD_ID:
    BEGIN

    !
    ! Make sure that the new value is not in use.
    !
    RAB[RAB$B_RAC] = RAB$C_KEY ;
    RAB[RAB$B_KRF] = 0 ;
    RAB[RAB$B_KSZ] = 4 ;
    RAB[RAB$L_KBF] = NEW_ID ;
    RAB[RAB$W_USZ] = KGB$K_IDENT_RECORD ;
    RAB[RAB$L_ROP] = RAB$M_NLK OR RAB$M_RRL ;	! No lock, read regardless
    STATUS = $FIND ( RAB = RAB ) ;
    IF .STATUS THEN STATUS = SS$_DUPLNAM ;
    IF .STATUS NEQ RMS$_RNF THEN LEAVE MOD_ID ;

    !
    ! Read the maintenance record to interlock the whole
    ! operation.
    !
    RAB[RAB$L_KBF] = UPLIT (0) ;
    RAB[RAB$W_USZ] = KGB$K_MAINT_RECORD ;
    RAB[RAB$L_ROP] = RAB$M_WAT OR RAB$M_RLK OR RAB$M_ULK ;
    STATUS = $GET ( RAB = RAB ) ;
    IF NOT .STATUS THEN LEAVE MOD_ID ;

    !
    ! We will now loop through all the holder records and modify them
    ! by reading in the ident record, change the value, delete the old record
    ! record and write out the new one.  The old one must be deleted
    ! not updated because we are modifying the primary key.
    !
    RAB[RAB$L_KBF] = ID;
    RAB[RAB$W_USZ] = KGB$K_IDENT_RECORD ;
    RAB[RAB$L_ROP] = RAB$M_LIM OR RAB$M_WAT OR RAB$M_RLK OR RAB$M_ULK ;

    WHILE 1 DO
	BEGIN
	STATUS = $GET (RAB = RAB);
	IF (.STATUS EQLU RMS$_EOF) OR (.STATUS EQLU RMS$_RNF) THEN EXITLOOP;
	IF NOT .STATUS THEN LEAVE MOD_ID ;

	REC_BUFF[KGB$L_IDENTIFIER] = .NEW_ID ;
    
	STATUS = $DELETE ( RAB = RAB ) ;
	IF NOT .STATUS THEN LEAVE MOD_ID ;
    
	STATUS = $PUT ( RAB = RAB ) ;
	IF NOT .STATUS THEN LEAVE MOD_ID ;
    
	END ;


    !
    ! Now fix all the holder records
    !
    $REWIND ( RAB = RAB ) ;
    OLD_HOLDER[0] = .ID ;
    OLD_HOLDER[1] = 0 ;
    NEW_HOLDER[0] = .NEW_ID ;
    NEW_HOLDER[1] = 0 ;
    RAB[RAB$B_KRF] = 1 ;
    RAB[RAB$L_KBF] = OLD_HOLDER;
    RAB[RAB$B_KSZ] = KGB$S_HOLDER ;
    RAB[RAB$W_USZ] = KGB$K_HOLD_RECORD ;
    WHILE 1 DO
	BEGIN
	STATUS = $GET (RAB = RAB);
	IF (.STATUS EQLU RMS$_EOF) OR (.STATUS EQLU RMS$_RNF) THEN EXITLOOP;
	IF NOT .STATUS THEN LEAVE MOD_ID ;

	CH$MOVE ( KGB$S_HOLDER, NEW_HOLDER, REC_BUFF[KGB$Q_HOLDER]) ;
    
	STATUS = $UPDATE ( RAB = RAB ) ;
	IF NOT .STATUS THEN LEAVE MOD_ID ;
    
	END ;

    STATUS = SS$_NORMAL ;

    END ;		! End of MOD_ID

!
! Clean up locks.
!
$FREE ( RAB = RAB ) ;

!
! Restore RAB
!
RAB[RAB$B_KRF] = .KRFSAV ;
RAB[RAB$B_KSZ] = .KSZSAV ;
RAB[RAB$L_KBF] = .KBFSAV ;
RAB[RAB$B_RAC] = .RACSAV ;
RAB[RAB$L_ROP] = .ROPSAV ;
RAB[RAB$W_USZ] = .USZSAV ;

!
! Get back to the beginning
!
IF .STATUS
    THEN STATUS = $REWIND ( RAB = RAB ) ;

RETURN .STATUS ;

END ;				! End of SYS$MOD_IDENT_ID


%SBTTL ' SYS$MOD_IDENT_NAME  -  Modify identifier ame'
ROUTINE SYS$MOD_IDENT_NAME ( RAB_PTR, ID, NEW_NAMLEN, NEW_NAMADR) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine modifies the name of the specified
!	identifier.
!
! CALLING SEQUENCE:
!	SYS$MOD_IDENT_NAME ( RAB_PTR, ID, .NEW_NAMLEN, .NEW_NAMADR)
!
! INPUT PARAMETERS:
!	RAB_PTR:	Address of RAB for the open rights data base file
!	ID:		identifier longword
!	NEW_NAMLEN:	Length of new name string
!	NEW_NAMADR:	Address of new name string
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Status of operation
!
! SIDE EFFECTS:
!	Identifier record modified
!
!--

BEGIN

LABEL
    MOD_NAME ;

BIND
    RAB		= .RAB_PTR		: $RAB_DECL ,
    REC_BUFF	= .RAB[RAB$L_UBF]	: $BBLOCK ;

LOCAL
    KRFSAV	: BYTE ,
    KSZSAV	: BYTE ,
    KBFSAV	: LONG ,
    RACSAV	: BYTE ,
    ROPSAV	: LONG ,
    USZSAV	: WORD ,
    NAME_BUFFER	: $BBLOCK [KGB$S_NAME],
    STATUS	: LONG ;

KRFSAV = .RAB[RAB$B_KRF] ;
KSZSAV = .RAB[RAB$B_KSZ] ;
KBFSAV = .RAB[RAB$L_KBF] ;
RACSAV = .RAB[RAB$B_RAC] ;
ROPSAV = .RAB[RAB$L_ROP] ;
USZSAV = .RAB[RAB$W_USZ] ;

MOD_NAME:
    BEGIN

    !
    ! First find out if there is a record with the new name already
    !
    CH$TRANSLATE (EXE$T_ID_UPCASE, .NEW_NAMLEN, .NEW_NAMADR,
		  ' ', KGB$S_NAME, NAME_BUFFER);
    RAB[RAB$B_KRF] = 2 ;			! Id name key
    RAB[RAB$B_KSZ] = KGB$S_NAME ;		! Key size
    RAB[RAB$L_KBF] = NAME_BUFFER ;		! Name string address
    RAB[RAB$L_ROP] = RAB$M_NLK OR RAB$M_RRL ;	! No lock, read regardless
    STATUS = $FIND ( RAB = RAB ) ;
    IF .STATUS THEN STATUS = SS$_DUPLNAM ;
    IF .STATUS NEQ RMS$_RNF THEN LEAVE MOD_NAME ;

    !
    ! The name doesn't exist.  Now we will get back to the beginning
    ! of the file and find the record that needs modification.
    !
    STATUS = $REWIND ( RAB = RAB ) ;
    IF NOT .STATUS THEN LEAVE MOD_NAME ;
    RAB[RAB$B_KRF] = 0 ;			! Id value key
    RAB[RAB$B_KSZ] = 4 ;			! Key size
    RAB[RAB$L_KBF] = ID ;			! ID value address
    RAB[RAB$L_ROP] = RAB$M_WAT OR		! Wait if locked
                     RAB$M_RLK OR		! Lock record
                     RAB$M_ULK ;		! manual unlock
    RAB[RAB$W_USZ] = KGB$K_IDENT_RECORD ;	! Ident record size
    STATUS = $GET ( RAB = RAB ) ;
    IF .STATUS EQL RMS$_RNF THEN STATUS = SS$_NOSUCHID ;
    IF NOT .STATUS THEN LEAVE MOD_NAME ;

    !
    ! Move the new name into the record and update the file.
    !
    CH$MOVE ( KGB$S_NAME, NAME_BUFFER, REC_BUFF[KGB$T_NAME] ) ;
    STATUS = $UPDATE ( RAB = RAB ) ;

    END ;		! End of MOD_NAME

!
! Clean up locks.
!
$FREE ( RAB = RAB ) ;

!
! Restore RAB
!
RAB[RAB$B_KRF] = .KRFSAV ;
RAB[RAB$B_KSZ] = .KSZSAV ;
RAB[RAB$L_KBF] = .KBFSAV ;
RAB[RAB$B_RAC] = .RACSAV ;
RAB[RAB$L_ROP] = .ROPSAV ;
RAB[RAB$W_USZ] = .USZSAV ;

!
! Get back to the beginning
!
IF .STATUS
    THEN STATUS = $REWIND ( RAB = RAB ) ;

RETURN .STATUS ;

END ;				! End of SYS$MOD_IDENT_NAME


%SBTTL ' SYS$REM_HOLDER  -  remove holder record'
GLOBAL ROUTINE SYS$REM_HOLDER (ID, HOLDER) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine removes the specified holder record.
!
! CALLING SEQUENCE:
!	SYS$REM_HOLDER (ID, HOLDER)
!
! INPUT PARAMETERS:
!	ID:	identifier longword
!	HOLDER:	address of the holder identifier quadword
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Status of operation
!
! SIDE EFFECTS:
!	Holder record removed
!
!--

BEGIN

LOCAL
	LOC_ID		: LONG,		! local copy of ID
	LOC_HOLDER	: REF VECTOR,	! local copy of HOLDER
	HOLDER_ID	: VECTOR [2],	! local copy of holder id quadword
	STATUS		: LONG,		! general status value
	CLOSE		: LONG,		! call to EXE$CLOSE_RDB required flag
	RAB		: $RAB_DECL,	! RAB for file operations
	REC_BUFFER	: $BBLOCK [KGB$K_IDENT_RECORD];
					! buffer to read records


LABEL
	RDB_OPEN;			! rights database is open in this block

! Validate parameters
!

LOC_ID = .ID;
IF (.LOC_ID AND UIC$M_ID_FORM_FLAG) NEQU 0
THEN
    (IF (.LOC_ID GTRU UIC$K_LAST_ID) THEN RETURN SS$_IVIDENT)
ELSE
    (IF (.LOC_ID GTRU UIC$K_MAX_UIC) OR (.LOC_ID EQL 0) THEN RETURN SS$_IVIDENT);

LOC_HOLDER = .HOLDER;
IF NOT PROBER (%REF(0), %REF(8), .LOC_HOLDER) THEN RETURN SS$_ACCVIO;
HOLDER_ID[0] = .LOC_HOLDER[0];
HOLDER_ID[1] = .LOC_HOLDER[1];
IF .HOLDER_ID[0] GTRU UIC$K_MAX_UIC OR .HOLDER_ID[1] NEQU 0
THEN
    RETURN SS$_IVIDENT;

! Get the rights database open for write.
!

$RAB_INIT (RAB = RAB,
	   RAC = KEY,
	   KRF = 0,
	   KBF = LOC_ID,
	   KSZ = 4,
	   ROP = (LIM, WAT, RLK, ULK),
	   UBF = REC_BUFFER,
	   USZ = KGB$K_IDENT_RECORD
	   );
STATUS = EXE$OPEN_RDB (0, 1, RAB[RAB$W_ISI], CLOSE);
IF NOT .STATUS THEN RETURN .STATUS;

RDB_OPEN:
    BEGIN

    ! Read and lock the ident record.
    !

    STATUS = $GET (RAB = RAB);
    IF .STATUS EQLU RMS$_RNF THEN STATUS = SS$_NOSUCHID;
    IF NOT .STATUS
    THEN
	BEGIN
	$FREE (RAB = RAB);
	LEAVE RDB_OPEN;
	END;

    ! Read the holder records looking for the specified one.
    !

    RAB[RAB$V_ULK] = 0;
    RAB[RAB$B_RAC] = RAB$C_SEQ;
    WHILE 1 DO
	BEGIN
	STATUS = $GET (RAB = RAB);
	IF .STATUS EQLU RMS$_EOF OR .STATUS EQLU RMS$_OK_LIM
	THEN
	    BEGIN
	    $FREE (RAB = RAB);
	    STATUS = SS$_NOSUCHID;
	    LEAVE RDB_OPEN;
	    END;

	IF CH$EQL (KGB$S_HOLDER, HOLDER_ID[0], KGB$S_HOLDER, REC_BUFFER[KGB$Q_HOLDER])
	THEN
	    EXITLOOP;
	END;

    ! Delete the located record.
    !

    STATUS = $DELETE (RAB = RAB);
    $FREE (RAB = RAB);
    END;

! Close the rights database if there is no image
!

IF .CLOSE THEN EXE$CLOSE_RDB();
IF .STATUS
THEN
    RETURN SS$_NORMAL
ELSE
    RETURN .STATUS;

END;					! End of routine SYS$REM_HOLDER

%SBTTL ' SYS$REM_IDENT  -  remove identifier from RDB'
GLOBAL ROUTINE SYS$REM_IDENT (ID) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine removes the specified identifier from the rights
!	database.
!
! CALLING SEQUENCE:
!	SYS$REM_IDENT (ID)
!
! INPUT PARAMETERS:
!	ID:	identifier longword
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	Status of operation
!
! SIDE EFFECTS:
!	Identifier record removed
!
!--

BEGIN

LOCAL
	LOC_ID		: VECTOR [2] INITIAL (0,0),
					! local copy of ID
	STATUS		: LONG,		! general status value
	CLOSE		: LONG,		! call to EXE$CLOSE_RDB required flag
	RAB		: $RAB_DECL,	! RAB for file I/O
	IDENT_RFA	: $BBLOCK [RAB$S_RFA],
					! RFA of ident record
	REC_BUFFER	: $BBLOCK [KGB$K_IDENT_RECORD];
					! Record buffer

LABEL
	RDB_OPEN;			! rights database is open in this block

! Validate ID
!

LOC_ID[0] = .ID;
IF (.LOC_ID[0] AND UIC$M_ID_FORM_FLAG) NEQU 0
THEN
    (IF (.LOC_ID[0] GTRU UIC$K_LAST_ID) THEN RETURN SS$_IVIDENT)
ELSE
    (IF (.LOC_ID[0] GTRU UIC$K_MAX_UIC) OR (.LOC_ID[0] EQL 0) THEN RETURN SS$_IVIDENT);

! Open the rights database for writing.
!

$RAB_INIT (RAB = RAB,
	   RAC = KEY,
	   KRF = 1,
	   KSZ = KGB$S_HOLDER,
	   KBF = LOC_ID[0],
	   USZ = KGB$K_IDENT_RECORD,
	   UBF = REC_BUFFER,
	   ROP = (LIM, WAT, RLK, ULK)
	   );
STATUS = EXE$OPEN_RDB (0, 1, RAB[RAB$W_ISI], CLOSE);
IF NOT .STATUS THEN RETURN .STATUS;

RDB_OPEN:
    BEGIN

    ! Delete holder records held by this id
    !

    STATUS = $GET (RAB = RAB);
    IF NOT .STATUS AND .STATUS NEQU RMS$_RNF THEN LEAVE RDB_OPEN;
    IF .STATUS
    THEN
	BEGIN
	RAB[RAB$B_RAC] = RAB$C_SEQ;
	WHILE 1 DO
	    BEGIN
	    STATUS = $DELETE (RAB = RAB);
	    IF NOT .STATUS
	    THEN
		BEGIN
		$FREE (RAB = RAB);
		LEAVE RDB_OPEN;
		END;
	    STATUS = $FIND (RAB = RAB);
	    IF .STATUS EQLU RMS$_EOF OR .STATUS EQLU RMS$_OK_LIM
	    THEN
		EXITLOOP;
	    IF NOT .STATUS
	    THEN
		BEGIN
		$FREE (RAB = RAB);
		LEAVE RDB_OPEN;
		END;
	    END;
	END;

    ! Now delete all holders of this identifier
    !

    RAB[RAB$B_RAC] = RAB$C_KEY;
    RAB[RAB$B_KRF] = 0;
    RAB[RAB$B_KSZ] = 4;

    ! First locate and lock the identifier record.
    !

    STATUS = $GET (RAB = RAB);
    IF .STATUS EQLU RMS$_RNF THEN STATUS = SS$_NOSUCHID;
    IF NOT .STATUS
    THEN
	BEGIN
	$FREE (RAB = RAB);
	LEAVE RDB_OPEN;
	END;
    CH$MOVE (RAB$S_RFA, RAB[RAB$W_RFA], IDENT_RFA);

    ! Now sequentially locate all the holder records and delete them.
    !

    RAB[RAB$B_RAC] = RAB$C_SEQ;
    RAB[RAB$V_ULK] = 0;
    WHILE 1 DO
	BEGIN
	STATUS = $FIND (RAB = RAB);
	IF .STATUS EQLU RMS$_EOF OR .STATUS EQLU RMS$_OK_LIM
	THEN
	    EXITLOOP;
	IF NOT .STATUS
	THEN
	    BEGIN
	    $FREE (RAB = RAB);
	    LEAVE RDB_OPEN;
	    END;

	STATUS = $DELETE (RAB = RAB);
	IF NOT .STATUS
	THEN
	    BEGIN
	    $FREE (RAB = RAB);
	    LEAVE RDB_OPEN;
	    END;
	END;

    ! Finally, re-locate and delete the identifier record.
    !

    RAB[RAB$B_RAC] = RAB$C_RFA;
    CH$MOVE (RAB$S_RFA, IDENT_RFA, RAB[RAB$W_RFA]);
    STATUS = $FIND (RAB = RAB);
    IF NOT .STATUS
    THEN
	BEGIN
	$FREE (RAB = RAB);
	LEAVE RDB_OPEN;
	END;

    STATUS = $DELETE (RAB = RAB);
    $FREE (RAB = RAB);
    END;

! Close the rights database if there is no image
!

IF .CLOSE THEN EXE$CLOSE_RDB();
IF .STATUS
THEN
    RETURN SS$_NORMAL
ELSE
    RETURN .STATUS;

END;					! End of routine SYS$REM_IDENT

END
ELUDOM
