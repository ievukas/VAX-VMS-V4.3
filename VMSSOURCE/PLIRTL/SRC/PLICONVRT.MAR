	.title pli$convert - pl1 general purpose data type conversion package
	.ident	/1-007/					;Edit DSB1007
							;Edit DSB1006
							;Edit WHM1005
							;Edit WHM1004
							;Edit WHM1003
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; 
; ++
; facility:
; 
;	VAX-11 PL1 runtime library.
; 
; abstract:
; 
; This routine converts any pl1 computational data type to any other.
; 
; author: R. Heinen 2-jan-1979
; 
; Modifications:
;
;
;	1-002	Bill Matthews	1982
;
;		Added conversions from non-zero scaled fixed binary to and
;		from all other data types.
;
;	1-003	Bill Matthews	29-September-1982
;
;		Invoke macros $defdat and rtshare instead of $defopr and share.
;
;	1-004	Bill Matthews	09-March-1983
;
;		Add convert from d_float to g_float and convert g_float to d_float
;		previously error was signalled.
;
;	1-005	Bill Matthews	16-June-1983
;
;		Fix bug in fixed binary to fixed decimal conversion
;
;	1-006	Dave Blickstein	13-April-1984
;
;		Changed float binary to fixed decimal to truncate instead
;		of round.   SPR #11-66476
;
;	1-007	Dave Blickstein	18-April-1984
;
;		Fixed bug in float binary to fixed decimal that caused a
;		decimal overflow at run-time.   The ASHP instruction was
;		interpreting a large negative shift factor as a positive
;		shift.  This was because the ASHP interprets the shift factor
;		as a byte.   Bugs note #8.  Test program: BUGS8.
; --
 
; 
; external definitions
; 
	$defdat				; define data types
	$psldef				; define psl bits
	$defpic				; define picture node offsets
	$chfdef				; condition handler offsets
	$defstk				; stack offsets
; 
; local macros
; 
	.macro casetab a
	.word	a-casebase
	.endm
 
	.macro	eo$insert,char
	.byte	^x44,char
	.endm	eo$insert

	.macro	eo$store_sign
	.byte	4
	.endm	eo$store_sign

	.macro	eo$fill,rept
	.byte	<^x80+rept>
	.endm	eo$fill

	.macro	eo$move,rept
	.byte	<^x90+rept>
	.endm	eo$move

	.macro	eo$float,rept
	.byte	<^xa0+rept>
	.endm	eo$float

	.macro	eo$end_float
	.byte	1
	.endm	eo$end_float

	.macro	eo$blank_zero,len
	.byte	45,len
	.endm	eo$blank_zero

	.macro	eo$replace_sign,len
	.byte	46,len
	.endm	eo$replace_sign

	.macro	eo$load_fill,char
	.byte	40,char
	.endm	eo$load_fill

	.macro	eo$load_sign,char
	.byte	41,char
	.endm	eo$load_sign

	.macro	eo$load_plus,char
	.byte	42,char
	.endm	eo$load_plus

	.macro	eo$load_minus,char
	.byte	43,char
	.endm	eo$load_minus

	.macro	eo$clear_signif
	.byte	2
	.endm	eo$clear_signif

	.macro	eo$set_signif
	.byte	3
	.endm	eo$set_signif

	.macro	eo$adjust_input,len
	.byte	47,len
	.endm	eo$adjust_input

	.macro	eo$end
	.byte	0
	.endm	eo$end

; 
; local data
; 
 
	rtshare
 
d_power_of_10:
	.double	1e0
	.double	1e-1
	.double	1e-2
	.double	1e-3
	.double	1e-4
	.double	1e-5
	.double	1e-6
	.double	1e-7
	.double	1e-8
	.double	1e-9
	.double	1e-10
	.double	1e-11
	.double	1e-12
	.double	1e-13
	.double	1e-14
	.double	1e-15
	.double	1e-16
	.double	1e-17
	.double	1e-18
	.double	1e-19
	.double	1e-20
	.double	1e-21
	.double	1e-22
	.double	1e-23
	.double	1e-24
	.double	1e-25
	.double	1e-26
	.double	1e-27
	.double	1e-28
	.double	1e-29
	.double	1e-30
	.double	1e-31
; 
h_power_of_10:
;
	.quad	^x0000000000004001
	.quad	^X0000000000000000
;
	.quad	^x9999999999993FFD
	.quad	^X999A999999999999
;
	.quad	^xE147147A47AE3FFA
	.quad	^X147B47AE7AE1AE14
;
	.quad	^x1A9FDD2F06243FF7
	.quad	^X10623958C8B4BE76
;
	.quad	^xC4322EB1A36E3FF3
	.quad	^X809DC226A786CA57
;
	.quad	^x368F588E4F8B3FF0
	.quad	^X66E401B81F9F0846
;
	.quad	^x5ED87A0B0C6F3FED
	.quad	^X858334934C7FD36B
;
	.quad	^xCAF429ABAD7F3FE9
	.quad	^X08D220EC7A658578
;
	.quad	^x08C3EE2357983FE6
	.quad	^X6D751A56FB849DF9
;
	.quad	^x6D69BE8212E03FE3
	.quad	^XF12A151162D04B2E
;
	.quad	^x7BDBFD9DB7CD3FDF
	.quad	^XB511881C6AE6AB7D
;
	.quad	^x9649FE175FD73FDC
	.quad	^X2A74D34AEF1E55FD
;
	.quad	^xDEA1981219793FD9
	.quad	^X885D0F6EF27F1197
;
	.quad	^x97682684C25C3FD5
	.quad	^X0D614BE450CB1C26
;
	.quad	^x12B9B86A68493FD2
	.quad	^X3DE70983A709B01E
;
	.quad	^x7561F9EE203A3FCF
	.quad	^X97EC6E021F3A59B2
;
	.quad	^x889B297DCD2B3FCB
	.quad	^XF3137CD0985DC2B6
;
	.quad	^x6D49546470EF3FC8
	.quad	^XF5A9FD73137D6892
;
	.quad	^x243ADD1D27253FC5
	.quad	^XC487645C75FEBA0E
;
	.quad	^x6D2A94FBD83C3FC1
	.quad	^XA0D8D3C75663C34A
;
	.quad	^x242210C979CA3FBE
	.quad	^X4D7A763911E935D5
;
	.quad	^xE9B440A02E3B3FBB
	.quad	^XD795F82DA7EDF7DD
;
	.quad	^x75EE0101E3923FB7
	.quad	^X25BB8D16A6495962
;
	.quad	^x2B25340182DB3FB4
	.quad	^X1E2F0A78EB6E144E
;
	.quad	^x88EA299A357C3FB1
	.quad	^XE4F2D52C892476A5
;
	.quad	^xA7DD0F5DEF2D3FAD
	.quad	^X07EABB7B75078AA2
;
	.quad	^xECB10C4A8C243FAA
	.quad	^X065595FC2A6C3BB5
;
	.quad	^x23C0A36F3CE93FA7
	.quad	^X9EAA44C9EEBDFC90
;
	.quad	^x06016BE5FB0F3FA3
	.quad	^X31113ADC1795941B
;
	.quad	^x6B34EFEA95A53FA0
	.quad	^X2741C8B012DD767C
;
	.quad	^xBC29BFEE44843F9D
	.quad	^X529A06F3424BF863
;
	.quad	^x96876658039D3F9A
	.quad	^X0EE29F2901D5F9E9
	.page
reverse_bit_tbl:
	.byte	^b00000000	;00000000
	.byte	^b10000000	;00000001
	.byte	^b01000000	;00000010
	.byte	^b11000000	;00000011
	.byte	^b00100000	;00000100
	.byte	^b10100000	;00000101
	.byte	^b01100000	;00000110
	.byte	^b11100000	;00000111
	.byte	^b00010000	;00001000
	.byte	^b10010000	;00001001
	.byte	^b01010000	;00001010
	.byte	^b11010000	;00001011
	.byte	^b00110000	;00001100
	.byte	^b10110000	;00001101
	.byte	^b01110000	;00001110
	.byte	^b11110000	;00001111
	.byte	^b00001000	;00010000
	.byte	^b10001000	;00010001
	.byte	^b01001000	;00010010
	.byte	^b11001000	;00010011
	.byte	^b00101000	;00010100
	.byte	^b10101000	;00010101
	.byte	^b01101000	;00010110
	.byte	^b11101000	;00010111
	.byte	^b00011000	;00011000
	.byte	^b10011000	;00011001
	.byte	^b01011000	;00011010
	.byte	^b11011000	;00011011
	.byte	^b00111000	;00011100
	.byte	^b10111000	;00011101
	.byte	^b01111000	;00011110
	.byte	^b11111000	;00011111
	.byte	^b00000100	;00100000
	.byte	^b10000100	;00100001
	.byte	^b01000100	;00100010
	.byte	^b11000100	;00100011
	.byte	^b00100100	;00100100
	.byte	^b10100100	;00100101
	.byte	^b01100100	;00100110
	.byte	^b11100100	;00100111
	.byte	^b00010100	;00101000
	.byte	^b10010100	;00101001
	.byte	^b01010100	;00101010
	.byte	^b11010100	;00101011
	.byte	^b00110100	;00101100
	.byte	^b10110100	;00101101
	.byte	^b01110100	;00101110
	.byte	^b11110100	;00101111
	.byte	^b00001100	;00110000
	.byte	^b10001100	;00110001
	.byte	^b01001100	;00110010
	.byte	^b11001100	;00110011
	.byte	^b00101100	;00110100
	.byte	^b10101100	;00110101
	.byte	^b01101100	;00110110
	.byte	^b11101100	;00110111
	.byte	^b00011100	;00111000
	.byte	^b10011100	;00111001
	.byte	^b01011100	;00111010
	.byte	^b11011100	;00111011
	.byte	^b00111100	;00111100
	.byte	^b10111100	;00111101
	.byte	^b01111100	;00111110
	.byte	^b11111100	;00111111
	.byte	^b00000010	;01000000
	.byte	^b10000010	;01000001
	.byte	^b01000010	;01000010
	.byte	^b11000010	;01000011
	.byte	^b00100010	;01000100
	.byte	^b10100010	;01000101
	.byte	^b01100010	;01000110
	.byte	^b11100010	;01000111
	.byte	^b00010010	;01001000
	.byte	^b10010010	;01001001
	.byte	^b01010010	;01001010
	.byte	^b11010010	;01001011
	.byte	^b00110010	;01001100
	.byte	^b10110010	;01001101
	.byte	^b01110010	;01001110
	.byte	^b11110010	;01001111
	.byte	^b00001010	;01010000
	.byte	^b10001010	;01010001
	.byte	^b01001010	;01010010
	.byte	^b11001010	;01010011
	.byte	^b00101010	;01010100
	.byte	^b10101010	;01010101
	.byte	^b01101010	;01010110
	.byte	^b11101010	;01010111
	.byte	^b00011010	;01011000
	.byte	^b10011010	;01011001
	.byte	^b01011010	;01011010
	.byte	^b11011010	;01011011
	.byte	^b00111010	;01011100
	.byte	^b10111010	;01011101
	.byte	^b01111010	;01011110
	.byte	^b11111010	;01011111
	.byte	^b00000110	;01100000
	.byte	^b10000110	;01100001
	.byte	^b01000110	;01100010
	.byte	^b11000110	;01100011
	.byte	^b00100110	;01100100
	.byte	^b10100110	;01100101
	.byte	^b01100110	;01100110
	.byte	^b11100110	;01100111
	.byte	^b00010110	;01101000
	.byte	^b10010110	;01101001
	.byte	^b01010110	;01101010
	.byte	^b11010110	;01101011
	.byte	^b00110110	;01101100
	.byte	^b10110110	;01101101
	.byte	^b01110110	;01101110
	.byte	^b11110110	;01101111
	.byte	^b00001110	;01110000
	.byte	^b10001110	;01110001
	.byte	^b01001110	;01110010
	.byte	^b11001110	;01110011
	.byte	^b00101110	;01110100
	.byte	^b10101110	;01110101
	.byte	^b01101110	;01110110
	.byte	^b11101110	;01110111
	.byte	^b00011110	;01111000
	.byte	^b10011110	;01111001
	.byte	^b01011110	;01111010
	.byte	^b11011110	;01111011
	.byte	^b00111110	;01111100
	.byte	^b10111110	;01111101
	.byte	^b01111110	;01111110
	.byte	^b11111110	;01111111
	.byte	^b00000001	;10000000
	.byte	^b10000001	;10000001
	.byte	^b01000001	;10000010
	.byte	^b11000001	;10000011
	.byte	^b00100001	;10000100
	.byte	^b10100001	;10000101
	.byte	^b01100001	;10000110
	.byte	^b11100001	;10000111
	.byte	^b00010001	;10001000
	.byte	^b10010001	;10001001
	.byte	^b01010001	;10001010
	.byte	^b11010001	;10001011
	.byte	^b00110001	;10001100
	.byte	^b10110001	;10001101
	.byte	^b01110001	;10001110
	.byte	^b11110001	;10001111
	.byte	^b00001001	;10010000
	.byte	^b10001001	;10010001
	.byte	^b01001001	;10010010
	.byte	^b11001001	;10010011
	.byte	^b00101001	;10010100
	.byte	^b10101001	;10010101
	.byte	^b01101001	;10010110
	.byte	^b11101001	;10010111
	.byte	^b00011001	;10011000
	.byte	^b10011001	;10011001
	.byte	^b01011001	;10011010
	.byte	^b11011001	;10011011
	.byte	^b00111001	;10011100
	.byte	^b10111001	;10011101
	.byte	^b01111001	;10011110
	.byte	^b11111001	;10011111
	.byte	^b00000101	;10100000
	.byte	^b10000101	;10100001
	.byte	^b01000101	;10100010
	.byte	^b11000101	;10100011
	.byte	^b00100101	;10100100
	.byte	^b10100101	;10100101
	.byte	^b01100101	;10100110
	.byte	^b11100101	;10100111
	.byte	^b00010101	;10101000
	.byte	^b10010101	;10101001
	.byte	^b01010101	;10101010
	.byte	^b11010101	;10101011
	.byte	^b00110101	;10101100
	.byte	^b10110101	;10101101
	.byte	^b01110101	;10101110
	.byte	^b11110101	;10101111
	.byte	^b00001101	;10110000
	.byte	^b10001101	;10110001
	.byte	^b01001101	;10110010
	.byte	^b11001101	;10110011
	.byte	^b00101101	;10110100
	.byte	^b10101101	;10110101
	.byte	^b01101101	;10110110
	.byte	^b11101101	;10110111
	.byte	^b00011101	;10111000
	.byte	^b10011101	;10111001
	.byte	^b01011101	;10111010
	.byte	^b11011101	;10111011
	.byte	^b00111101	;10111100
	.byte	^b10111101	;10111101
	.byte	^b01111101	;10111110
	.byte	^b11111101	;10111111
	.byte	^b00000011	;11000000
	.byte	^b10000011	;11000001
	.byte	^b01000011	;11000010
	.byte	^b11000011	;11000011
	.byte	^b00100011	;11000100
	.byte	^b10100011	;11000101
	.byte	^b01100011	;11000110
	.byte	^b11100011	;11000111
	.byte	^b00010011	;11001000
	.byte	^b10010011	;11001001
	.byte	^b01010011	;11001010
	.byte	^b11010011	;11001011
	.byte	^b00110011	;11001100
	.byte	^b10110011	;11001101
	.byte	^b01110011	;11001110
	.byte	^b11110011	;11001111
	.byte	^b00001011	;11010000
	.byte	^b10001011	;11010001
	.byte	^b01001011	;11010010
	.byte	^b11001011	;11010011
	.byte	^b00101011	;11010100
	.byte	^b10101011	;11010101
	.byte	^b01101011	;11010110
	.byte	^b11101011	;11010111
	.byte	^b00011011	;11011000
	.byte	^b10011011	;11011001
	.byte	^b01011011	;11011010
	.byte	^b11011011	;11011011
	.byte	^b00111011	;11011100
	.byte	^b10111011	;11011101
	.byte	^b01111011	;11011110
	.byte	^b11111011	;11011111
	.byte	^b00000111	;11100000
	.byte	^b10000111	;11100001
	.byte	^b01000111	;11100010
	.byte	^b11000111	;11100011
	.byte	^b00100111	;11100100
	.byte	^b10100111	;11100101
	.byte	^b01100111	;11100110
	.byte	^b11100111	;11100111
	.byte	^b00010111	;11101000
	.byte	^b10010111	;11101001
	.byte	^b01010111	;11101010
	.byte	^b11010111	;11101011
	.byte	^b00110111	;11101100
	.byte	^b10110111	;11101101
	.byte	^b01110111	;11101110
	.byte	^b11110111	;11101111
	.byte	^b00001111	;11110000
	.byte	^b10001111	;11110001
	.byte	^b01001111	;11110010
	.byte	^b11001111	;11110011
	.byte	^b00101111	;11110100
	.byte	^b10101111	;11110101
	.byte	^b01101111	;11110110
	.byte	^b11101111	;11110111
	.byte	^b00011111	;11111000
	.byte	^b10011111	;11111001
	.byte	^b01011111	;11111010
	.byte	^b11011111	;11111011
	.byte	^b00111111	;11111100
	.byte	^b10111111	;11111101
	.byte	^b01111111	;11111110
	.byte	^b11111111	;11111111
;
	.page
	.sbttl pli$cvrt_any - convert any data type
; ++
; pli$cvrt_any - convert any data type
; 
; functional descritpion:
; 
; This dispatch routine and the individual conversion routines represent
; an any to any conversion package. The philosophy is to convert wherever
; possible. If the arguments describe an undefined data type or out of range size
; of a known data type then the caller is in error and the general ERROR
; condition is signalled. Otherwise the conversion is done with expansion
; or truncation where necessary.
; 
; This routine sets up the arguments and dispatches to the proper routine
; based on the data types of the source and destination.
; 
; inputs: ( arguments are immediate )
; 
;	(ap) = 8
;	4(ap) = address of the address of the source
;	8(ap) = data type of source
;	12(ap) = size (p,q) of source
;	16(ap) = bit offset of source, if necessary
;	20(ap) = address of the address of the target
;	24(ap) = data type of target
;	28(ap) = size (p,q) of target
;	32(ap) = bit offset of target, if necessary
; 
; outputs:
; 
;	 The source is converted to the destination.
; --
	.entry pli$cvrt_any,^m<iv,dv,r2,r3,r4,r5,r6,r7,r8,r9,r10,r11>
	bispsw	#psl$m_fu		; enable underflow
; 
; merge data types and check for invalid types
; 
	movzbl	8(ap),r4		; get source data type
	movzbl	24(ap),r6		; get the target data type
	cmpb	r6,#dat_k_bit_align	; in range?
	bgtru	error			; if gtru then error
	bneq	5$			; if neq then continue
	decb	r6			; squeeze out bit varying
5$:	cmpb	r4,#dat_k_bit_align	; in range?
	bgtru	error			; if gtru then error
	bneq	10$			; if neq then continue
	decb	r4			; squeeze out bit varying
10$:	cmpb	r4,#dat_k_flt_dec	; simplify range, by making
					; making codes contiguous
	blequ	15$			; 
	subb	#4,r4; 
15$:	cmpb	r6,#dat_k_flt_dec	; 
	blequ	20$			; 
	subb	#4,r6; 
					; find table entry
20$:	decb	r4			; adjust to zero
	decb	r6			; 
	mulb	#9,r4			; 
	addb	r6,r4			; 
; 
; set up remainder of arguments
; 
	movl	@4(ap),r0		; address source
	movl	12(ap),r1		; get source size
	movl	16(ap),r5		; get source bit offset
	movl	@20(ap),r2		; get target address
	movl	28(ap),r3		; get target size
	movl	32(ap),r6		; get target bit offset
	brw	case_on_type		; continue
; 
; fatal - undefined conversion
; 
error:
	pushl	#pli$_cnverr		; actual error code
	clrl	-(sp)
	pushl	#pli$_error
	clrq	r0			; set no value - also no fcb
	calls	#3,g^lib$signal		; signal the error
	clrq	r0			; set no value
	ret
	.page
	.sbttl	pli$cvrt_cg - perform out of line conversion
; ++
; pli$cvrt_cg - perform a conversion
; 
; functional description:
; 
; This is the entry to the conversion logic for the codegenerator.
; 
; This routine is called to preserve trace back data, but the arguments are passed
; in registers.
; 
 
; inputs:
; 
;	r0 = address of the source
;	r1 = size of the source
;	r2 = address of the destination
;	r3 = size of the destination
;	r4 = case table index
;	r5 = bit offset of source if any
;	r6 = bit offset of destination if any
; 
; outputs:
; 
;	The operation is done.
; *********************************************************
; 
; WARNING
; 
; Do not change this interface without the proper changes to the codegenerator.
; 
; *********************************************************
; --
	.entry	pli$cvrt_cg_r3,^m<iv,dv,r4,r5,r6,r7,r8,r9,r10,r11>
; 
; enable arithmetic traps
; 
	bispsw	#psl$m_fu
case_on_type:
;
; NOTE WELL:	DO NOT CHANGE THIS CASE TABLE WITHOUT CHANGING THE CODE
;		GENERATOR, THE FORMAT CONVERSION ROUTINES, AND THE DEFINITION
;		OF $DEFCVTIND IN PL1MAC.MLB. IF YOU ADD ENTRIES, YOU WILL
;		ALSO WANT TO CHANGE THE GET AND PUT ITEM ROUTINES.
	caseb	r4,#0,#80		; 
casebase=.
	casetab	picpic
	casetab	picfixb
	casetab	picfltb
	casetab	picfixd
	casetab	picfltd
	casetab	picchar
	casetab	picvcha
	casetab	picbit
	casetab	picabit
	casetab	fixbpic
	casetab	fixbfixb
	casetab	fixbfltb
	casetab	fixbfixd
	casetab fixbfltd
	casetab	fixbchar
	casetab	fixbvcha
	casetab	fixbbit
	casetab	fixbabit
	casetab	fltbpic
	casetab	fltbfixb
	casetab	fltbfltb
	casetab	fltbfixd
	casetab	fltbfltd
	casetab	fltbchar
	casetab	fltbvcha
	casetab	fltbbit
	casetab	fltbabit
	casetab	fixdpic
	casetab	fixdfixb
	casetab	fixdfltb
	casetab	fixdfixd
	casetab	fixdfltd
	casetab	fixdchar
	casetab	fixdvcha
	casetab	fixdbit
	casetab	fixdabit
	casetab	fltdpic
	casetab	fltdfixb
	casetab	fltdfltb
	casetab	fltdfixd
	casetab	fltdfltd
	casetab	fltdchar
	casetab	fltdvcha
	casetab	fltdbit
	casetab	fltdabit
	casetab	charpic
	casetab	charfixb
	casetab	charfltb
	casetab	charfixd
	casetab	charfltd
	casetab	charchar
	casetab	charvcha
	casetab	charbit
	casetab	charabit
	casetab	vchapic
	casetab	vchafixb
	casetab	vchafltb
	casetab	vchafixd
	casetab	vchafltd
	casetab	vchachar
	casetab	vchavcha
	casetab	vchabit
	casetab	vchaabit
	casetab	bitpic
	casetab	bitfixb
	casetab	bitfltb
	casetab	bitfixd
	casetab	bitfltd
	casetab	bitchar
	casetab	bitvcha
	casetab	bitbit
	casetab	bitabit
	casetab	abitpic
	casetab	abitfixb
	casetab	abitfltb
	casetab	abitfixd
	casetab	abitfltd
	casetab	abitchar
	casetab	abitvcha
	casetab	abitbit
	casetab	abitabit
	brw	error
	.page
;++
;
; pli$cnvrt_hnd
;
; this handler is used by pli$convert routines that may generate
; reserved operand exceptions; that is, all the char and vchar
; to arithmetic or bit conversions.  it handles only reserved
; operand, by signalling a pl/i error with a conversion error
; subcode.  all other conditions are resignalled.
;
; input:
;	condition argument list
;
; output:
;	if roprand, error is signalled
;	else condition is resignalled
;--
	.sbttl	pli$cnvrt_hnd	conversion condition handler
;
	.entry	pli$cnvrt_hnd,0
;
	movl	#ss$_resignal,r0	; assume resignal
	movl	chf$l_sigarglst(ap),r1	; address arg list
	cmpl	chf$l_sig_name(r1),#ss$_roprand	; check for roprand
	bneq	30$			; if neq, resignal
	movl	fp,r1			; addr the frame
10$:	movab	30$,stk_l_pc(r1)	; force pc to be a return statement
	movl	stk_l_fp(r1),r1		; get the next frame
	moval	g^pli$cnvrt_hnd,r0	; get address
	cmpl	stk_l_cnd_hnd(r1),r0	; see if it's our establisher
	bneq	10$			; if not, keep looking
	clrl	stk_l_cnd_hnd(r1)	; else, take away this cond. hndlr
	pushl	#pli$_cnverr		; set conversion error subcode
	clrl	-(sp)
	pushl	#pli$_error		; set error condition code
	clrq	r0
	calls	#3,g^lib$signal		; and signal pli error
	movl	#ss$_continue,r0
30$:	ret
	.page
	.sbttl	input checking subroutines
; 
; chk_fixb_string - check fixed binary for overflow
; 
chk_fixb_string:			; check for overflow condition
					; on fixb to string conversion
	movzbl	r1,r5			; get prec
	movl	#7,r4			; assume less than 7 bits
	cmpl	r4,r5			; this range?
	beql	20$			; if eql then always ok
	bgtr	10$			; if gtr then check
	movl	#15,r4			; assume less than 15 bits
	cmpl	r4,r5			; this range?
	beql	20$			; if eql then always ok
	bgtr	10$			; if gtr then check
	movl	#31,r4			; assume less than 31 bits
	cmpl	r4,r5			; this range?
	beql	20$			; if eql then always ok
	blss	30$			; if less then illegal
10$:	subl	r5,r4			; get size of sign areai
	pushl	#0			; assume positive number
	bbc	r5,(r0),15$		; if clear then positive
	mnegl	#1,(sp)			; set negitive
15$:	incl	r5			; point to bit past the sign bit
	cmpv	r5,r4,(r0),(sp)+	; check sign
	bneq	25$			; if neq then overflow
20$:	rsb				; else done
25$:	pushl	#ss$_intovf		; signal error
	clrq	r0			; no value
	calls	#1,g^lib$signal		; signal error
	ret				; exit
30$:	brw	error			; signal error condition
 
; 
; chk_bit_arith - check for bit to arithmetic overflow
; 
	.enabl	lsb
chk_bit_arith:
	brb	10$			; continue to verify bits
chk_abit_arith:
10$:	cmpl	r1,#31			; less than 31 bits?
	bleq	30$			; then always ok
	subl	#31,r1
	addl3	r1,r5,-(sp)		; point at last 31 bits, and save
	pushl	r0			; save src base
15$:	tstl	r1			; more bits to verify?
	beql	20$			; if eql then no and string is checked
	bsbw	get_next_32bits		; get the next 32 bits of the string
	tstl	r4			; all 0's?
	beql	15$			; if eql then continue check
	pushl	#ss$_intovf		; 
	calls	#1,g^lib$signal		; signal error
	ret				; 
20$:	popr	#^m<r0,r5>		; restore desc with adjusted offset
	movl	#31,r1			; set max size
30$:	rsb
 
	.dsabl	lsb
;
; src_fltb_prec - calc floating source context
;
src_fltb_prec:
	bispsw	#psl$m_fu		; enable underflow
	bbcc	#7,r1,10$		; test for grand and clear it
	movl	#2,r4			; set grand context
	rsb
;
10$:	cmpl	r1,#24			; float?
	bgtr	20$			; if not, br
	clrl	r4			; set F float context
	rsb
;
20$:	cmpl	r1,#53			; double?
	bgtr	30$			; if not, br
	movl	#1,r4			; set double context
	rsb
;
30$:	movl	#3,r4			; must be huge
	rsb
;
; dest_fltb_prec - calc floating destination context
;
dest_fltb_prec:
	bispsw	#psl$m_fu		; enable underflow
	bbcc	#7,r3,10$		; test for grand
	movl	#2,r7			; set grand context
	rsb
;
10$:	cmpl	r3,#24			; float?
	bgtr	20$			; if not, br
	clrl	r7			; set F float context
	rsb
;
20$:	cmpl	r3,#53			; double?
	bgtr	30$			; if not, br
	movl	#1,r7			; set double context
	rsb
;
30$:	movl	#3,r7			; must be huge
	rsb
;
; src_fltd_prec - calc floating decimal source context
;
src_fltd_prec:
	bispsw	#psl$m_fu		; enable underflow
	bbcc	#7,r1,10$		; test for grand
	movl	#2,r4			; set grand context
	rsb
;
10$:	cmpl	r1,#7			; float?
	bgtr	20$			; if not, br
	clrl	r4			; set F float context
	rsb
;
20$:	cmpl	r1,#15			; double?
	bgtr	30$			; if not, br
	movl	#1,r4			; set double context
	rsb
;
30$:	movl	#3,r4			; must be huge
	rsb
;
; dest_fltd_prec - calc floating decimal source context
;
dest_fltd_prec:
	bispsw	#psl$m_fu		; enable underflow
	bbcc	#7,r3,10$		; test for grand
	movl	#2,r7			; set grand context
	rsb
;
10$:	cmpl	r3,#7			; float?
	bgtr	20$			; if not, br
	clrl	r7			; set F float context
	rsb
;
20$:	cmpl	r3,#15			; double?
	bgtr	30$			; if not, br
	movl	#1,r7			; set double context
	rsb
;
30$:	movl	#3,r7			; must be huge
	rsb
 
	.page
	.sbttl	picpic - picture to picture conversion
; ++
; picpic - picture to picture conversion
; 
; functional description:
; 
; This routine converts a picture value to a picture value.
; 
; inputs:
; 
;	r0 = address of the source
;	r1 = size or precision of source
;	r2 = address of the destination
;	r3 = size or the precision of the destination
; 
; outputs:
; 
;	The destination is filled in
; --
	.entry	pli$picpic_r6,^m<iv,dv,r4>
picpic:
	subl	#16,sp			; alloc packed temp
	pushl	sp			; addr of target temp
	movzwl	pic$w_pq(r1),-(sp)	; prec & scale of target
	pushl	r0			; addr of source
	movzbl	pic$b_byte_size(r1),-(sp); prec & scale of src
	pushl	r1			; addr of pic node
	movl	r1,r4			; save pic node addr
	calls	#5,g^pli$cvt_fr_pic	; conv from pic to fix dec
	pushl	r2			; final target addr
	movzbl	pic$b_byte_size(r3),-(sp); target prec & scale
	pushab	8(sp)			; addr of fix dec src
	movzwl	pic$w_pq(r4),-(sp)	; src prec & scale
	pushl	r3			; pic node addr
	calls	#5,g^pli$cvt_to_pic	; cvrt fix dec temp to pic
	ret
	.page
	.sbttl	picfixb - picture to fixed binary conversion
; ++
; picfixb - picture to fixed binary conversion
; 
; functional description:
; 
; This routine converts a picture value to a fixed binary value.
; 
; inputs:
; 
;	r0 = address of the source
;	r1 = size or precision of source
;	r2 = address of the destination
;	r3 = size or the precision of the destination
; 
; outputs:
; 
;	The destination is filled in
; --
	.entry	pli$picfixb_r6,^m<iv,dv,r4,r5>
picfixb:
	subl	#16,sp			; alloc packed temp
	pushl	sp			; addr of target temp
	pushl	#31			; max precision, 0 scale
	pushl	r0			; src addr
	movzbl	pic$b_byte_size(r1),-(sp); src prec & scale
	pushl	r1			; pic node
	calls	#5,g^pli$cvt_fr_pic	; cvrt from pic to fix dec
	movl	sp,r0			; reset src to fix dec temp
	movl	#31,r1			; reset src size
	bsbw	cvrt_fixd_fixb		; go cvrt to fix bin
	ret
	.page
	.sbttl	picfltb - picture to floating binary conversion
; ++
; picfltb - picture to floating binary conversion
; 
; functional description:
; 
; This routine converts a picture value to a floating binary value.
; 
; inputs:
; 
;	r0 = address of the source
;	r1 = size or precision of source
;	r2 = address of the destination
;	r3 = size or the precision of the destination
; 
; outputs:
; 
;	The destination is filled in
; --
	.entry	pli$picfltb_r6,^m<iv,dv,r4,r5,r6,r7>
picfltb:
	bsbw	dest_fltb_prec		; get dest context
	bsbb	cvrt_pic_flt
	ret
cvrt_pic_flt:
	subl	#16,sp			; alloc packed temp
	pushl	sp			; addr of target temp
	movzwl	pic$w_pq(r1),r4		; save src prec & scale
	pushl	r4			; use for target prec & scale
	pushl	r0			; addr of src
	movzbl	pic$b_byte_size(r1),-(sp); src prec 
	pushl	r1			; pic node
	calls	#5,g^pli$cvt_fr_pic	; conv to fixed dec
	movl	sp,r0			; reset src to fix dec temp
	movl	r4,r1			; reset src prec & scale
	bsbw	cvrt_fixd_flt		; go conv to float bin
	addl	#16,sp			; clean stack
	rsb
	.page
	.sbttl	picfixd - picture to fixed decimal conversion
; ++
; picfixd - picture to fixed decimal conversion
; 
; functional description:
; 
; This routine converts a picture value to a fixed decimal value.
; 
; inputs:
; 
;	r0 = address of the source
;	r1 = size or precision of source
;	r2 = address of the destination
;	r3 = size or the precision of the destination
; 
; outputs:
; 
;	The destination is filled in
; --
	.entry	pli$picfixd_r6,^m<iv,dv,r4>
picfixd:
	pushl	r2			; target addr
	pushl	r3			; target size
	pushl	r0			; src addr
	movzbl	pic$b_byte_size(r1),-(sp); src prec & scale
	pushl	r1			; pic node
	calls	#5,g^pli$cvt_fr_pic	; convert pic to fix dec
	ret
	.page
	.sbttl	picfltd - picture to float decimal conversion
; ++
; picfltd - picture to float decimal conversion
; 
; functional description:
; 
; This routine converts a picture value to a float decimal value.
; 
; inputs:
; 
;	r0 = address of the source
;	r1 = size or precision of source
;	r2 = address of the destination
;	r3 = size or the precision of the destination
; 
; outputs:
; 
;	The destination is filled in
; --
	.entry	pli$picfltd_r6,^m<iv,dv,r4,r5,r6,r7>
picfltd:
	bsbw	dest_fltd_prec		; get float context
	bsbb	cvrt_pic_flt		; convert value
	ret				; done
	.page
	.sbttl picchar - picture to character conversion
; ++
; picchar - picture to character conversion
; 
; functional description:
; 
; This routine converts a picture value to a character string.
; 
; inputs:
; 
;	r0 = address of the source
;	r1 = size or precision of source
;	r2 = address of the destination
;	r3 = size or the precision of the destination
; 
; outputs:
; 
;	The destination is filled in
; --
	.entry	pli$picchar_r6,^m<iv,dv,r4,r5>
picchar:
	movzbl	pic$b_byte_size(r1),r1	; get pic str size
	movc5	r1,(r0),#32,r3,(r2)	; copy to char str
	ret
	.page
	.sbttl	picvcha - picture to character varying conversion
; ++
; picvcha - picture to character varying conversion
; 
; functional description:
; 
; This routine converts a picture value to a character varying string.
; 
; inputs:
; 
;	r0 = address of the source
;	r1 = size or precision of source
;	r2 = address of the destination
;	r3 = size or the precision of the destination
; 
; outputs:
; 
;	The destination is filled in
; --
	.entry	pli$picvcha_r6,^m<iv,dv,r4,r5>
picvcha:
	movzbl	pic$b_byte_size(r1),r1	; get pic str size
	movw	r1,(r2)			; put in dest str size
	cmpw	r1,r3			; see if it fits
	blequ	10$			; if so, br
	movw	r3,(r2)			; else, use smaller size
10$:	tstw	(r2)+			; point to char str
	movc5	r1,(r0),#32,r3,(r2)	; do the move
	ret
	.page
	.sbttl	picbit - picture to bit string conversion
; ++
; picbit - picture to bit string conversion
; 
; functional description:
; 
; This routine converts a picture value to a bit string.
; 
; inputs:
; 
;	r0 = address of the source
;	r1 = size or precision of source
;	r2 = address of the destination
;	r3 = size or the precision of the destination
; 
; outputs:
; 
;	The destination is filled in
; --
	.entry	pli$picbit_r6,^m<iv,dv,r4,r5>
picbit:
	subl	#16,sp			; alloc packed temp
	movzwl	pic$w_pq(r1),-(sp)	; save the src prec,scale
					; arg.list
	pushal	4(sp)			; addr of fix dec target temp
	pushl	4(sp)			; use same prec,scale for target temp
	pushl	r0			; src addr
	movzbl	pic$b_byte_size(r1),-(sp); src prec
	pushl	r1			; pic node addr
	calls	#5,g^pli$cvt_fr_pic	; conv to fix dec
	popl	r1			; get back src prec,scale
	movl	sp,r0			; set src to fix dec temp
	brw	fixdbit			; go conv to bit
	.page
	.sbttl	picabit - picture to bit aligned conversion
; ++
; picabit - picture to bit aligned conversion
; 
; functional description:
; 
; This routine converts a picture value to a bit aligned string.
; 
; inputs:
; 
;	r0 = address of the source
;	r1 = size or precision of source
;	r2 = address of the destination
;	r3 = size or the precision of the destination
; 
; outputs:
; 
;	The destination is filled in
; --
	.entry	pli$picabit_r6,^m<iv,dv,r4,r5,r6>
picabit:
	subl	#16,sp			; alloc packed temp
	movzwl	pic$w_pq(r1),-(sp)	; save the src prec,scale
					; arg.list
	pushal	4(sp)			; addr of fix dec target temp
	pushl	4(sp)			; use same prec,scale for target temp
	pushl	r0			; src addr
	movzbl	pic$b_byte_size(r1),-(sp); src prec
	pushl	r1			; pic node addr
	calls	#5,g^pli$cvt_fr_pic	; conv to fix dec
	popl	r1			; get back src prec,scale
	movl	sp,r0			; set src to fix dec temp
	bsbw	clr_abit_trailer	; clear abit last byte
	brw	fixdbit			; go conv to bit
	.page
	.sbttl	fltbpic - floating to picture conversion
; ++
; fltbpic - floating to picture conversion
; 
; functional description:
; 
; This routine converts a floating binary value to a picture value.
; 
; inputs:
; 
;	r0 = address of the source
;	r1 = size or precision of source
;	r2 = address of the destination
;	r3 = size or the precision of the destination
; 
; outputs:
; 
;	The destination is filled in
; --
	.entry	pli$fltbpic_r6,^m<iv,dv,r4,r5,r6,r7,r8>
fltbpic:
	bsbw	src_fltb_prec		; get src context
	bsbb	cvrt_flt_pic
	ret
cvrt_flt_pic:
	subl	#16,sp			; alloc packed temp
	pushl	r2			; make frame for pic cvrt before regs go away
	movzbl	pic$b_byte_size(r3),-(sp); frame target size
	movab	8(sp),r2		; reset dest to temp
	pushl	r2			; push it as pic cvrt src
	movzwl	pic$w_pq(r3),-(sp)	; push target p,q as src p,q
	pushl	r3			; pic node addr
	movzwl	pic$w_pq(r3),r3		; reset dest size as pic p,q
	bsbw	cvrt_flt_fixd		; convert flt bin src to fix dec
	calls	#5,g^pli$cvt_to_pic	; frame all set, cvrt dec to pic
	addl	#16,sp			; clean stack
	rsb
	.page
	.sbttl	fltbfixb - floating to fixed binary conversion
; ++
; fltbfixb - floating to fixed binary conversion
; 
; functional description:
; 
; This routine converts a floating binary value to a fixed binary value.
; 
; inputs:
; 
;	r0 = address of the source
;	r1 = size or precision of source
;	r2 = address of the destination
;	r3 = size or the precision of the destination
; 
; outputs:
; 
;	The destination is filled in
; --
	.entry	pli$fltbfixb_r6,^m<iv,dv,r4>
fltbfixb:
	bsbw	src_fltb_prec		; get src context
	bsbb	cvrt_flt_fixb		; convert floating to fixed
	ret				;
cvrt_flt_fixb:
	extzv	#3,#2,r3,r3		; get dest size
	ashl	#-8,r3,r1		; get dest scale
	cvtbl	r1,r1			; sign extend dest scale
	bneq	120$			; if neq, scale ^= zero
5$:	mulb	#4,r4			; get source size times 4
	addb	r4,r3			; get case index
	case	type=b,r3,<10$,20$,30$,30$,40$,50$,60$,60$,70$,80$,90$,90$,100$,110$>
	cvthl	(r0),(r2)
	rsb
10$:	cvtfb	(r0),(r2)
	rsb
20$:	cvtfw	(r0),(r2)
	rsb
30$:	cvtfl	(r0),(r2)
	rsb
40$:	cvtdb	(r0),(r2)
	rsb
50$:	cvtdw	(r0),(r2)
	rsb
60$:	cvtdl	(r0),(r2)
	rsb
70$:	cvtgb	(r0),(r2)
	rsb
80$:	cvtgw	(r0),(r2)
	rsb
90$:	cvtgl	(r0),(r2)
	rsb
100$:	cvthb	(r0),(r2)
	rsb
110$:	cvthw	(r0),(r2)
	rsb

120$:	clrl	-(sp)			; temp for the longword result
	case	type=b,r4,<130$,140$,150$>
	clrq	-(sp)			; convert to huge temp
	clrl	-(sp)			;
	movl	r1,-(sp)		; set the power of 2 in the exponent
	addl2	#^x4001,(sp)		; add in the constant h_floating part
	emodh	(r0),#0,(sp),16(sp),(sp)+; adjust to dest scale and convert to integer
	brb	160$			; join common code
130$:	clrq	-(sp)			;
	insv	r1,#7,#25,(sp)		; set the power of 2 in the exponent
	addl2	#^x4080,(sp)		; add in the constant d_floating part
	cvtfd	(r0),-(sp)		; convert to double temp
	emodd	(sp)+,#0,(sp),8(sp),(sp)+; adjust to dest scale and convert to integer
	brb	160$			; join common code
140$:	clrq	-(sp)			;
	insv	r1,#7,#25,(sp)		; set the power of 2 in the exponent
	addl2	#^x4080,(sp)		; add in the constant d_floating part
	emodd	(r0),#0,(sp),8(sp),(sp)+; adjust to dest scale and convert to integer
	brb	160$			; join common code
150$:	clrq	-(sp)			; convert to huge temp
	clrl	-(sp)			;
	movl	r1,-(sp)		; set the power of 2 in the exponent
	addl2	#^x4001,(sp)		; add in the constant h_floating part
	cvtgh	(r0),-(sp)		; convert to huge temp
	emodh	(sp)+,#0,(sp),16(sp),(sp)+;adjust to dest scale and convert to integer
160$:	case	type=b,r3,<190$,180$,170$>; convert to target context
170$:	movl	(sp)+,(r2)		;
	rsb
180$:	cvtlw	(sp)+,(r2)		;
	rsb
190$:	cvtlb	(sp)+,(r2)		;
	rsb
	.page
	.sbttl	fltbfltb - floating to floating binary conversion
; ++
; fltbfltb - floating to floating binary conversion
; 
; functional description:
; 
; This routine converts a floating binary value to a floating binary value.
; 
; inputs:
; 
;	r0 = address of the source
;	r1 = size or precision of source
;	r2 = address of the destination
;	r3 = size or the precision of the destination
; 
; outputs:
; 
;	The destination is filled in
; --
	.entry	pli$fltbfltb_r6,^m<iv,dv,r4,r7>
fltbfltb:
	bsbw	src_fltb_prec		; calc floating context for source
	bsbw	dest_fltb_prec		; calc destination context
	bsbb	cvrt_flt_flt
	ret
cvrt_flt_flt:
	mulb2	#4,r7			; calculate index for case
	addb	r7,r4
	case	type=b,r4,<10$,20$,30$,40$,50$,60$,70$,80$,90$,100$, -
			110$,120$,130$,140$,150$>
	movh	(r0),(r2)
	rsb
10$:	movf	(r0),(r2)
	rsb
20$:	cvtdf	(r0),(r2)
	rsb
30$:	cvtgf	(r0),(r2)
	rsb
40$:	cvthf	(r0),(r2)
	rsb
50$:	cvtfd	(r0),(r2)
	rsb
60$:	movd	(r0),(r2)
	rsb
70$:	cvtgh	(r0),-(sp)
	cvthd	(sp)+,(r2)
	rsb
80$:	cvthd	(r0),(r2)
	rsb
90$:	cvtfg	(r0),(r2)
	rsb
100$:	cvtdh	(r0),-(sp)
	cvthg	(sp)+,(r2)
	rsb
110$:	movg	(r0),(r2)
	rsb
120$:	cvthg	(r0),(r2)
	rsb
130$:	cvtfh	(r0),(r2)
	rsb
140$:	cvtdh	(r0),(r2)
	rsb
150$:	cvtgh	(r0),(r2)
	rsb
	.page
	.sbttl	fltbfixd - floating to fixed decimal conversion
; ++
; fltbfixd - floating to fixed decimal conversion
; 
; functional description:
; 
; This routine converts a floating binary value to a fixed decimal value.
; 
; inputs:
; 
;	r0 = address of the source
;	r1 = size or precision of source
;	r2 = address of the destination
;	r3 = size or the precision of the destination
; 
; outputs:
; 
;	The destination is filled in
; --
	.entry	pli$fltbfixd_r6,^m<iv,dv,r4,r5,r6,r7,r8>
fltbfixd:
	bsbw	src_fltb_prec		;get src context
	bsbw	cvrt_flt_fixd
	ret
cvrt_flt_fixd:
	subl	#112,sp			; alloc local storage
	tstl	r4			; see if src is single floating
	bneq	10$			; if not F, br
	cvtfd	(r0),104(sp)		; cvrt float to double
	moval	104(sp),r0		; reset source
10$:	movab	52(sp),r1		; setup math call frame
	movab	56(sp),-20(r1)		; string_addr
	movzbl	r3,-16(r1)		; sig_digits
	insv	#1,#24,#1,-12(r1);	; flags (truncate)
	clrl	-32(r1)			; clr rt_round (no right rounding)
	movq	r2,-(sp)		; save dest. regs
	case	type=b,r4,<20$,20$,40$>
	bicpsw	#psl$m_iv		; turn off iv
	jsb	g^ots$$cvt_h_t_r8
	bispsw	#psl$m_iv
	brb	50$
20$:	jsb	g^ots$$cvt_d_t_r8
	brb	50$
40$:	bicpsw	#psl$m_iv
	jsb	g^ots$$cvt_g_t_r8
	bispsw	#psl$m_iv
;
50$:	movq	(sp)+,r6		; rest dest to r6,r7
	addl3	-32(r1),-20(r1),r8	; add offset to get start of digit str
	tstl	-24(r1)			; test sign returned by cvt
	bgtr	70$			;  and put appropriate sign char
	blss	60$			;  in front of digit string to make
	movb	#^a/ /,-(r8)		;  a proper leading separate string
	brb	80$
60$:	movb	#^a/-/,-(r8)
	brb	80$
70$:	movb	#^a/+/,-(r8)
80$:	movzbl	r7,r5			; get prec of dest
	cmpl	-28(r1),r5		; see if gtr exponent
	bleq	90$			; [note that ashp with count > destin.
					; length will not overflow on 11/780 ]
	pushl	#ss$_decovf		; signal decimal overflow
	clrq	r0
	calls	#1,g^lib$signal
	brb	100$
90$:	ashl	#-8,r7,r7		; get scale
	subl2	r5,r7			; scale-prec
	addl2	-28(r1),r7		; (scale-prec)+exponent
	bgeq	93$			; if positive scale factor
	cmpl	r7,#-31			; shift factor >max size of packed?
	bgeq	97$			; if so,
	mnegb	#31,r7			; use max
	brb	97$
93$:	cmpl	r7,#31			; shift factor >max size of packed?
	bleq	97$			; if so,
	movb	#31,r7			; use max
97$:	cvtsp	r5,(r8),r5,(sp)		; convert lead sep to packed temp
	ashp	r7,r5,(sp),#0,r5,(r6)	; adjust result to scale
100$:	addl	#112,sp			; clean stack
	rsb				;return
	.page
	.sbttl	fltbfltd - float binary to float decimal conversion
; ++
; fltbfltd - float binary to float decimal conversion
; 
; functional description:
; 
; This routine converts a float binary value to a float decimal value.
; 
; inputs:
; 
;	r0 = address of the source
;	r1 = size or precision of source
;	r2 = address of the destination
;	r3 = size or the precision of the destination
; 
; outputs:
; 
;	The destination is filled in
; --
	.entry	pli$fltbfltd_r6,^m<iv,dv,r4,r7>
fltbfltd:
	bsbw	src_fltb_prec		; get src context
	bsbw	dest_fltd_prec		; get dest context
	bsbw	cvrt_flt_flt		; continue in common
	ret
	.page
	.sbttl fltbchar - floating to character conversion
; ++
; fltbchar - floating to character conversion
; 
; functional description:
; 
; This routine converts a floating binary value to a character string.
; 
; inputs:
; 
;	r0 = address of the source
;	r1 = size or precision of source
;	r2 = address of the destination
;	r3 = size or the precision of the destination
; 
; outputs:
; 
;	r0 = size of actual data string
; 
;	The destination is filled in
; --
	.entry	pli$fltbchar_r6,^m<iv,dv,r4,r5,r6,r7,r8,r9,r10,r11>
fltbchar:
	bsbw	src_fltb_prec		; get src context
	mull2	#100,r1			; conv to decimal digit prec
	addl	#331,r1			; this will assure the ceil
	divl	#332,r1
	cmpl	r1,#34			; can't be greater than max dec prec
	bleq	6$
	movl	#34,r1			; set max
6$:	bsbb	cvrt_flt_char		; convert number
	ret
cvrt_flt_char:
	subl2	#132,sp			; alloc local storage
	tstl	r4			; check for single floating
	bneq	10$			; br if not F
	cvtfd	(r0),-128(sp)		; conv to D
	moval	-128(sp),r0		; reset src addr
	incl	r4			; reset context to D
;
10$:	pushl	r1			; save src prec
	moval	80(sp),r1		; setup math call frame (size=40 bytes)
	movl	r1,-20(r1)		; string_addr
	popl	-16(r1)			; sig_digits
	clrl	-12(r1)			; caller flags (default round)
	clrl	-36(r1)			; clr rt_round
	movq	r2,r9			; save r2,r3,r4
	movl	r4,r11
	case	type=b,r4,<21$,22$,23$>
	bicpsw	#psl$m_iv		; turn off iv
	jsb	g^ots$$cvt_h_t_r8
	bispsw	#psl$m_iv
	brb	25$
21$:	jsb	g^ots$$cvt_d_t_r8
	brb	25$
22$:	jsb	g^ots$$cvt_d_t_r8
	brb	25$
23$:
	bicpsw	#psl$m_iv
	jsb	g^ots$$cvt_g_t_r8
	bispsw	#psl$m_iv
;
25$:	movl	sp,r8			; addr of temp for char str
	tstl	-24(r1)			; tst sign
	bgeq	30$			; br if plus or zero
	movb	#^a/-/,(r8)+		; else put - sign in chr str
	brb	40$
30$:	movb	#^a/ /,(r8)+		; put in blank for pos or 0
40$:	addl3	-32(r1),-20(r1),r2	; add offset to str. addr to get 1st digit
	movb	(r2)+,(r8)+		; copy most sig digit
	movb	#^a/./,(r8)+		; put in dec. pt.
	subl3	#1,-16(r1),r6		; get length of remaining digits
	movl	r1,r7			; copy call frame ptr
	movc3	r6,(r2),(r8)		; copy remaining frac digits
	movl	r3,r8			; point r8 past end of dest string
	movb	#^a/E/,(r8)+		; put in the "E"
	incl	r11			; get correct exponent digit size
	tstl	-24(r7)			; test sign for zero
	beql	45$			; if 0, do not decr exponent 
	decl	-28(r7)			; adjust exponent for dec pt.
45$:	cvtlp	-28(r7),r11,-128(sp)	; cvt exp to packed
	cvtps	r11,-128(sp),r11,(r8)	; cvt packed to leading sep
	addl2	#5,r6			; get length of frac+extra chars
	addl2	r11,r6			; add in exp size
	movc5	r6,(sp),#32,r10,(r9)	; copy temp char str to dest
	movl	r6,r0			; return dest length
	addl2	#132,sp			; clean stack
	rsb
;
	.page
	.sbttl	fltbvcha - floating to character varying conversion
; ++
; fltbvcha - floating to character varying conversion
; 
; functional description:
; 
; This routine converts a floating binary value to a character varying string.
; 
; inputs:
; 
;	r0 = address of the source
;	r1 = size or precision of source
;	r2 = address of the destination
;	r3 = size or the precision of the destination
; 
; outputs:
; 
;	The destination is filled in
; --
	.entry	pli$fltbvcha_r6,^m<iv,dv,r4,r5,r6,r7,r8,r9,r10,r11>
fltbvcha:
	pushaw	(r2)+			; skip current length
	bsbw	src_fltb_prec		; get src context
	mull2	#100,r1			; conv to decimal digit prec
	addl2	#331,r1
	divl	#332,r1
	cmpl	r1,#34			; can't be gtr than max dec prec
	bleq	6$
	movl	#34,r1			;
6$:	bsbw	cvrt_flt_char		; convert to char
	movw	r0,@(sp)+		; store length 
	ret				; return
	.page
	.sbttl	floating to bit conversion
; ++
; fltbbit - floating to bit string conversion
; fltbabit - floating to bit aligned conversion
; 
; functional description:
; 
; This routine converts a floating binary value to a bit aligned string.
; 
; inputs:
; 
;	r0 = address of the source
;	r1 = size or precision of source
;	r2 = address of the destination
;	r3 = size or the precision of the destination
;	r6 = bit offset to destination
; 
; outputs:
; 
;	The destination is filled in
; --
	.entry	pli$fltbabit_r6,^m<iv,dv,r4,r5,r6>
fltbabit:
	bsbw	clr_abit_trailer	; clear abit last byte
	brb	fltbbit			;
	.entry	pli$fltbbit_r6,^m<iv,dv,r4,r5>
fltbbit:
	bsbw	src_fltb_prec		; get src context
	clrl	-(sp)			; get temp space
	cmpl	r1,#31			; see if gtr max binary prec
	bleq	10$			; if lss 31, ok
	movl	#31,r1			; else plug in max
10$:
	pushr	#^m<r1,r2,r3,r6>	; save destination
	moval	16(sp),r2		; plug address of temp for dest
	movl	r1,r3			; plug precision
	bsbw	cvrt_flt_fixb		; convert source to fixb temp
	popr	#^m<r1,r2,r3,r6>	; restore destination
	movl	sp,r0			; plug address of temp for source
	bsbw	cvrt_fixb_bit		; convert temp to bit
	ret
	.page
	.sbttl	fixbpic - fixed binary to picture conversion
; ++
; fixbpic - fixed binary to picture conversion
; 
; functional description:
; 
; This routine converts a fixed binary value to a picture value.
; 
; inputs:
; 
;	r0 = address of the source
;	r1 = size or precision of source
;	r2 = address of the destination
;	r3 = size or the precision of the destination
; 
; outputs:
; 
;	The destination is filled in
; --
	.entry	pli$fixbpic_r6,^m<iv,dv,r4,r5>
fixbpic:
	subl	#16,sp			; alloc packed temp
	pushl	r2			; make frame for pic cvrt before regs go away
	movzbl	pic$b_byte_size(r3),-(sp); frame target size
	movab	8(sp),r2		; reset dest to temp
	pushl	r2			; push it as pic cvrt src
	movzwl	pic$w_pq(r3),-(sp)	; push target p,q as src p,q
	pushl	r3			; pic node addr
	movzwl	pic$w_pq(r3),r3		; reset dest size as pic p,q
	bsbw	cvrt_fixb_fixd		; conv fixb src to fix dec
	calls	#5,g^pli$cvt_to_pic	; frame all set, cvrt dec to pic
	ret
	.page
	.sbttl	fixbfixb - fixed binary to fixed binary conversion
; ++
; fixbfixb - fixed binary to fixed binary conversion
; 
; functional description:
; 
; This routine converts fixed binary values to fixed binary values of a different 
; precision.
; 
; inputs:
; 
;	r0 = address of the source
;	r1 = size or precision of source
;	r2 = address of the destination
;	r3 = size or the precision of the destination
; 
; outputs:
; 
;	The destination is filled in
; --
	.entry	pli$fixbfixb_r6,^m<iv,dv,r4,r5>
fixbfixb:
	bsbb	cvrt_fixb_fixb		; store the result
	ret				;
;
; subroutine to store a fixed binary value
;
cvrt_fixb_fixb:				; store fixed binary result
	ashl	#-8,r1,r4		; get source scale
	extzv	#3,#2,r1,r1		; get valid contexts
	ashl	#-8,r3,r5		; get dest scale
	extzv	#3,#2,r3,r3		; get valid contexts
	subb2	r4,r5			; calc dest scale - source scale
	bneq	90$			; if neq different scales
	mulb	#4,r1			; 
	addb	r1,r3			; 
	case	type=b,r3,<10$,20$,30$,30$,40$,50$,60$,60$,70$,80$,5$,5$,70$,80$>
5$:
	movl	(r0),(r2)		; 
	rsb
 
10$:	movb	(r0),(r2)		; 
	rsb
20$:	cvtbw	(r0),(r2)		; 
	rsb
30$:	cvtbl	(r0),(r2)		; 
	rsb
40$:	cvtwb	(r0),(r2)		; 
	rsb
50$:	movw	(r0),(r2)		; 
	rsb
60$:	cvtwl	(r0),(r2)		; 
	rsb
70$:	cvtlb	(r0),(r2)		; 
	rsb
80$:	cvtlw	(r0),(r2)		; 
	rsb
 
90$:	case	type=b,r1,<120$,110$,100$>

100$:	movl	(r0),r0			; get source in longword
	brb	130$			;
110$:	cvtwl	(r0),r0			;
	brb	130$			;
120$:	cvtbl	(r0),r0			;
130$:	cvtbl	r5,r5			; sign extend dest scale - source scale
	blss	131$			; branch if shift right
	ashl	r5,r0,r1		; convert to dest scale
	brb	135$			; join common code
131$:	mnegl	r5,r5			; make positive
	cmpl	r5,#31			; trying to shift away all the bits?
	blssu	132$			; if lssu then no
	clrl	r1			; else result is zero
	brb	135$			; go move to dest
132$:	ashl	r5,#1,r5		; calc 2**(abs(dest scale))
	divl3	r5,r0,r1		; convert to dest scale
135$:	case	type=b,r3,<160$,150$,140$>
140$:	movl	r1,(r2)			; put back to dest context
	rsb				;
150$:	cvtlw	r1,(r2)			;
	rsb				;
160$:	cvtlb	r1,(r2)			;
	rsb				;
	.page
	.sbttl	fixbfltb - fixed binary to floating binary conversion
; ++
; fixbfltb - fixed binary to floating binary conversion
; 
; functional description:
; 
; This routine converts fixed binary values to floating binary values of a different 
; precision.
; 
; inputs:
; 
;	r0 = address of the source
;	r1 = size or precision of source
;	r2 = address of the destination
;	r3 = size or the precision of the destination
; 
; outputs:
; 
;	The destination is filled in
; --
	.entry	pli$fixbfltb_r6,^m<iv,dv,r4,r7>
fixbfltb:
	bsbw	dest_fltb_prec		; get destination floating context
	bsbb	cvrt_fixb_flt
	ret
cvrt_fixb_flt:
	ashl	#-8,r1,r4		; get source scale
	extzv	#3,#2,r1,r1		; determine size of source
	cvtbl	r4,r4			; non-zero scale?
	bneq	120$			; if neq, yes
	mulb	#4,r7			; calculate index for case
	addb	r1,r7			; 
	case	type=b,r7,<10$,20$,30$,30$,40$,50$,60$,60$,70$,80$,90$,90$,100$,110$>
	cvtlh	(r0),(r2)
	rsb
10$:	cvtbf	(r0),(r2)
	rsb
20$:	cvtwf	(r0),(r2)
	rsb
30$:	cvtlf	(r0),(r2)
	rsb
40$:	cvtbd	(r0),(r2)
	rsb
50$:	cvtwd	(r0),(r2)
	rsb
60$:	cvtld	(r0),(r2)
	rsb
70$:	cvtbg	(r0),(r2)
	rsb
80$:	cvtwg	(r0),(r2)
	rsb
90$:	cvtlg	(r0),(r2)
	rsb
100$:	cvtbh	(r0),(r2)
	rsb
110$:	cvtwh	(r0),(r2)
	rsb
	
120$:	case	type=b,r1,<150$,140$,130$>; convert source to long context

130$:	movl	(r0),r0			;
	brb	160$			;
140$:	cvtwl	(r0),r0			;
	brb	160$			;
150$:	cvtbl	(r0),r0			;
160$:	mnegl	r4,r4			;negate scale factor
	case	type=b,r7,<170$,180$,190$>; case on dest type
	cvtlh	r0,-(sp)		; convert to huge temp
	clrq	-(sp)			; convert to huge temp
	clrl	-(sp)			;
	movl	r4,-(sp)		; set the power of 2 in the exponent
	addl2	#^x4001,(sp)		; add in the constant h_floating part
	mulh3	(sp)+,(sp)+,(r2)	; adjust result for scale
	rsb
170$:	cvtld	r0,-(sp)		; convert to double temp
	clrq	-(sp)			;
	insv	r4,#7,#25,(sp)		; set the power of 2 in the exponent
	addl2	#^x4080,(sp)		; add in the constant h_floating part
	muld2	(sp)+,(sp)		; adjust for scale
	cvtdf	(sp)+,(r2)		; convert to float result
	rsb
180$:	cvtld	r0,-(sp)		; convert to double temp
	clrq	-(sp)			;
	insv	r4,#7,#25,(sp)		; set the power of 2 in the exponent
	addl2	#^x4080,(sp)		; add in the constant h_floating part
	muld3	(sp)+,(sp)+,(r2)	; adjust result for scale
	rsb
190$:	cvtlh	r0,-(sp)		; convert to huge temp
	clrq	-(sp)			; convert to huge temp
	clrl	-(sp)			;
	movl	r4,-(sp)		; set the power of 2 in the exponent
	addl2	#^x4001,(sp)		; add in the constant h_floating part
	muld2	(sp)+,(sp)		; adjust for scale
	cvthg	(sp)+,(r2)		; convert to grand result
	rsb
	.page
	.sbttl	fixbfixd - fixed binary to fixed decimal conversion
; ++
; fixbfixd - fixed binary to fixed decimal conversion
; 
; functional description:
; 
; This routine converts fixed binary values to fixed decimal values of a different 
; precision.
; 
; inputs:
; 
;	r0 = address of the source
;	r1 = size or precision of source
;	r2 = address of the destination
;	r3 = size or the precision for the destination
; 
; outputs:
; 
;	The destination is filled in
; --
	.entry	pli$fixbfixd_r6,^m<iv,dv,r4,r5>
fixbfixd:
	bsbb	cvrt_fixb_fixd
	ret
;
; convert fixed binary to fixed decimal
;
cvrt_fixb_fixd:
	ashl	#-8,r1,r5		; get the source scale factor
	cvtbl	r5,r5			; sign extend byte value scale to long
	movzbl	r1,r1			; zero extend precision
	bsbw	get_src_fixprec		; calc number of target digits
	ashl	#-8,r3,r4		; get scale factor of dest
	movzbl	r3,r3			; zero extend precision
	cvtbl	r4,r4			; sign extend scale
	bneq	10$			; if neq, no zero scale factor
	tstl	r5			; source scale factor negative?
	blss	10$			; if lss, yes
	cmpl	r5,#31			; trying to shift away all the bits?
	blssu	5$			; if lssu then no
	clrl	r0			; else the result is zero
	brb	7$			; go convert to decimal
5$:	ashl	r5,#1,r5		; calc 2** source scale factor
	divl2	r5,r0			; convert source to zero scale integer
7$:	cvtlp	r0,r3,(r2)		; do the conversion to decimal
	rsb				; return
; 
; convert number to stack
; 
10$:	subl	#16,sp			; allocate more than enough room
	pushr	#^m<r1,r2,r3>
	cvtlp	r0,r1,12(sp)		; convert value
	popr	#^m<r1,r2,r3>
	tstl	r5			; source scale factor zero?
	bneq	20$			; if neq, no.
	ashp	r4,r1,(sp),#0,r3,(r2)	; move to result field
	addl	#16,sp			; clean stack
	rsb
20$:	subl	#16,sp			; allocate another decimal buffer
	pushl	r2			; save dest address
	pushl	r3			; save dest prec
	ashp	r4,r1,24(sp),#0,#31,8(sp);make decimal integer
	tstl	r5			; source scale factor negative?
	bgtr	30$			; if gtr, no
	mnegl	r5,r5			; get abs(source scale)
	mull2	#6,r5			; use scale as an index to a power 2 table
	mulp	#10,g^pli$b_pac_2_power_00[r5],-;mul by 2**(abs(source scale))
		#31,8(sp),(sp),@4(sp)	; and move to result
	brb	40$			; join common return
30$:	mull2	#6,r5			; use scale as an index to a power 2 table
	divp	#10,g^pli$b_pac_2_power_00[r5],-;div by 2**(source scale) and
		#31,8(sp),(sp),@4(sp)	; move to result
40$:	addl	#40,sp			; clean up stack
	rsb				; return

; 
; get_src_fixprec
;
; calc the number of digits based on a fixed bin precision
; 
get_src_fixprec:
	pushl	r4
	addl3	#1,r1,r4		; get fixed field size
	extv	#0,r4,(r0),r0		; get the value
	mull2	#100,r1			; get precision of result by rule
	addl	#663,r1
	divl	#332,r1
	popl	r4
	rsb
	.page
	.sbttl	fixbfltd - fixed binary to float decimal conversion
; ++
; fixbfltd - fixed binary to float decimal conversion
; 
; functional description:
; 
; This routine converts a fixed binary value to a float decimal value.
; 
; inputs:
; 
;	r0 = address of the source
;	r1 = size or precision of source
;	r2 = address of the destination
;	r3 = size or the precision of the destination
; 
; outputs:
; 
;	The destination is filled in
; --
	.entry	pli$fixbfltd_r6,^m<iv,dv,r4,r7>
fixbfltd:
	bsbw	dest_fltd_prec		; get dest context
	bsbw	cvrt_fixb_flt		; continue in common
	ret
	.page
	.sbttl	fixbchar - convert fixed binary to character
; ++
; fixbchar - convert fixed binary to character
; 
; functional description:
; 
; This routine converts fixed binary numbers to character
; 
; inputs:
; 
;	r0 = source value
;	r1 = precision of source
;	r2 = address of the target
;	r3 = size of the target
; 
; outputs:
; 
;	The output field is filled.
; --
	.entry	pli$fixbchar_r6,^m<iv,dv,r4,r5,r6>
fixbchar:
	bsbw	chk_fixb_string		; check for possible overflow
	cmpw	#^xff,r1		; non-zero source scale?
	blssu	10$			; if lssu yes.
	bsbw	get_src_fixprec		; convert precision of source
	addl	#3,r1			; include for sign
	subl	r1,sp			; allocate the space
	movl	sp,r6			; save address
	bsbw	cvrt_fixb_char		; do conversion
	movc5	r1,(r6),#32,r3,(r2)	; move to target
	ret				; return to caller

10$:	bsbw	fixbfixdtemp		; first convert to a fixed decimal temp
	bsbw	fixdchar		; convert to char
	ret				; never used fixdchar does ret.
; 
; cvrt_fixb_char
;
; convert fixed bin to a character string
; 
;
cvrt_fixb_char:
	pushr	#^m<r0,r1,r2,r3>	; save regs
	movc5	#0,(r6),#32,r1,(r6)	; fill with spaces
	popl	r0			; get value
10$:	emul	#1,r0,#0,r0		; sign extend value
	ediv	#10,r0,r0,r2		; get remainder
	movl	r2,r1			; get remainder
	bgeq	15$			; if geq then no
	mnegl	r1,r1			; 
15$:	addb3	#^a/0/,r1,-(r3)		; insert character
	tstl	r0			; quo = 0?
	bneq	10$			; if neq then no
	tstl	r2			; last remainder negitive?
	bgeq	20$			; if geq then no
	movb	#^a/-/,-(r3)		; insert minus sign
20$:	popr	#^m<r1,r2,r3>		; 
	rsb
; 
; fixbfixdtemp
;
; convert fixed bin to a fixed decimal temporary
; 
;	inputs:
;		r0 - fixed bin value
;		r1 - (p,q) of source
;	outputs:
;		r0 - address of converted value
;		r1 - (p,q) of converted value
;			r4,r5 destroyed
;
fixbfixdtemp:
	popl	r6			; save return address
	movq	r2,-(sp)		; save some regs
	ashl	#-8,r1,r5		; get the source scale
	movzbl	r1,r4			; get source prec in longword
	addl3	#1,r4,r1		; get fixed field size
	extv	#0,r1,(r0),r0		; get source value in a longword
	subl	#16,sp			; allocate space for a decimal temp
	cvtlp	r0,#31,(sp)		; convert to decimal
	cvtbl	r5,r5			; source scale negative?
	bgtr	15$			; if geq no
	mnegl	r5,r1			; get abs(scale)
	addl	r1,r4			; calc number of decimal digits
15$:	mull2	#100,r4			;
	addl2	#663,r4			;
	divl2	#332,r4			;
	pushl	r4			; save number of decimal digits
	tstl	r5			; source scale negative?
	bgeq	16$			; if geq no
	mull2	#6,r1			; use scale as index into a power 2 table
	subl	#16,sp			; allocate more space
	mulp	#31,20(sp),#10,-	;scale up for implied zero bits
		g^pli$b_pac_2_power_00[r1],r4,(sp);
	movl	sp,r0			; set up for convert fixd to char
	movl	16(sp),r1		;
	movq	36(sp),r2		;
	jmp	(r6)			; return
16$:	mull3	#100,r5,r4		; convert scale to decimal precision
	addl	#331,r4			;
	divl	#332,r4			;
	subl	#16,sp			; allocate a second decimal temp
	ashp	r4,#31,20(sp),#0,#31,(sp);make a decimal integer
	movb	r4,17(sp)		; set decimal scale
	mull2	#6,r5			; use scale as index into power 2 table
	movzbl	16(sp),r1		; get decimal prec
	divp	#10,g^pli$b_pac_2_power_00[r5],-;div by 2**(source scale)
		#31,(sp),r1,20(sp)	;
	moval	20(sp),r0		; set up for convert fixd to char
	movl	16(sp),r1		;
	movq	36(sp),r2		;
	jmp	(r6)			; return

	.page
	.sbttl	fixbvcha - convert fixed binary to character varying
; ++
; fixbvcha - convert fixed binary to character varying
; 
; functional description:
; 
; This routine converts fixed binary numbers to character varying
; 
; inputs:
; 
;	r0 = source value
;	r1 = precision of source
;	r2 = address of the target
;	r3 = size of the target
; 
; outputs:
; 
;	The output field is filled.
; --
	.entry	pli$fixbvcha_r6,^m<iv,dv,r4,r5,r6>
fixbvcha:
	bsbw	chk_fixb_string		; check for possible overflow
	cmpw	#^xff,r1		; non-zero source scale?
	blssu	20$			; if lssu yes.
	bsbw	get_src_fixprec		; convert precision of source
	addl	#3,r1			; include for sign
	subl	r1,sp			; allocate the space
	movl	sp,r6			; save address
	bsbw	cvrt_fixb_char		; do conversion
	cmpw	r1,r3			; room enough?
	blequ	10$			; if lequ then yes
	movl	r3,r1			; use smaller size
10$:	movw	r1,(r2)+		; insert size
	movc3	r1,(sp),(r2)		; move to target
	ret

20$:	bsbw	fixbfixdtemp		; convert to fixed decimal temp
	bsbw	fixdvcha		; convert to char
	ret				; never used fixdvcha does ret.

	.page
	.sbttl	fixbbit - fixed binary to bit string conversion
	.sbttl	fixbabit - fixed binary to bit aligned conversion
; ++
; fixbabit - fixed binary to bit aligned conversion
; fixbbit - fixed binary to bit string conversion
; 
; functional description:
; 
; This routine converts a fixed binary value to a bit aligned string.
; 
; inputs:
; 
;	r0 = address of the source
;	r1 = size or precision of source
;	r2 = address of the destination
;	r3 = size or the precision of the destination
;	r6 = bit offset to destination
; 
; outputs:
; 
;	The destination is filled in
; --
	.entry	pli$fixbabit_r6,^m<iv,dv,r4,r5,r6>
fixbabit:
	bsbw	clr_abit_trailer	; clear abit last byte
	brb	fixbbit
	.entry	pli$fixbbit_r6,^m<iv,dv,r4,r5>
fixbbit:
	bsbw	cvrt_fixb_bit
	ret
cvrt_fixb_bit:
	bsbw	chk_fixb_string		; check values
	addb3	#1,r1,r5
	movzbl	r5,r5			; zero extend field size
	extv	#0,r5,(r0),r0		; get sign extended value
	bgtr	5$			; branch if positive
	mnegl	r0,r0			; make positive
5$:	ashl	#-8,r1,r5		; get source scale
	movzbl	r1,r1			; zero extend the source prec
	cvtbl	r5,r5			; sign extend source scale
	subl2	r5,r1			; get prec minus scale
	mnegl	r5,r5			; set up to convert to zero scale
	ashl	r5,r0,r0		; convert to zero scale
	movl	sp,r5			; address a temp
	clrl	-(sp)			;
;
10$:	movzbl	r0,r4			; get low order byte of src
	movb	reverse_bit_tbl[r4],-(r5) ; get reversed byte
	ashl	#-8,r0,r0		; shift src down a byte
	bgtr	10$			; if more, continue
;
	subl3	r1,#32,r5		; adjust to converted bit prec
	bgtr	15$			; if 32-(prec-scale)>0 get value
	movl	#31,r1			; set max prec
	movl	#1,r5			; get full 31 bit field
15$:	extzv	r5,r1,(sp),(sp)		;
	cmpl	r3,#32			; see if dest. gtr longword
	bleq	20$			; if not, ok
	bsbw	clr_bit_dest		; else, clr bit dest.
	movl	#32,r3			; set max src. prec.
20$:	insv	(sp)+,r6,r3,(r2)	; insert dest.
	rsb

	
;
; clr_abit_trailer
;
; inputs:
;
;	r2 = base address of the destination field
;	r3 = size of the destination field
;
; outputs:
;
;	r6 = 0
;	the last byte of the destination is cleared
;
clr_abit_trailer:
	movzwl	r3,r6			;
	addl	#7,r6
	bicl	#7,r6
	subl	r3,r6			; any trailer?
	beql	10$			; if eql then n
	insv	#0,r3,r6,(r2)		; insert zero trailer
	clrl	r6			;
10$:	rsb				; done

; 
; clr_bit_dest
; 
; inputs:
; 
;	r2 = base address of the destination field
;	r3 = size of the destination field
;	r6 = offset to the destination field
; 
; outputs:
; 
;	destination field is zeroed
; 
clr_bit_dest:
	cmpl	r3,#32			; short operation?
	bgtru	10$			; if gtru then no
	insv	#0,r6,r3,(r2)		; zero short field
	rsb
10$:	pushr	#^m<r0,r1,r2,r3,r4,r5,r6>; save registers
	extzv	#0,#3,r6,r4		; get offset byte bias
	beql	20$			; if eql then byte aligned
	subb3	r4,#8,r4		; get remainder in byte
	insv	#0,r6,r4,(r2)		; zero initial unaligned bits
	addl	r4,r6			; byte aligned now
	subl	r4,r3			; remove zeroed bits from count
20$:	divl3	#8,r3,r0		; calc number of bytes in field
	divl	#8,r6			; calc number of bytes to field from base
	extzv	#0,#3,r3,r4		; get end byte bias
	beql	30$			; if eql then byte sized
	addl	r6,r0			; point to last byte
	insv	#0,#0,r4,(r2)[r0]	; zero end field
30$:	movc5	#0,(r2)[r6],#0,r0,(r2)[r6]; clear middle
	popr	#^m<r0,r1,r2,r3,r4,r5,r6>; 
	rsb
	.page
	.sbttl	fixdpic - fixed decimal to picture conversion
; ++
; fixdpic - fixed decimal to picture conversion
; 
; functional description:
; 
; This routine converts a fixed decimal value to a picture value.
; 
; inputs:
; 
;	r0 = address of the source
;	r1 = size or precision of source
;	r2 = address of the destination
;	r3 = size or the precision of the destination
; 
; outputs:
; 
;	The destination is filled in
; --
	.entry	pli$fixdpic_r6,^m<iv,dv,r4>
fixdpic:
	pushl	r2			; target addr
	movzbl	pic$b_byte_size(r3),-(sp); target p,q
	pushl	r0			; src addr
	pushl	r1			; src p,q
	pushl	r3			; pic cons node
	calls	#5,g^pli$cvt_to_pic	; convert to picture
	ret
	.page
	.sbttl	fixdfixb - fixed decimal to fixed binary conversion
; ++
; fixdfixb - fixed decimal to fixed binary conversion
; 
; functional description:
; 
; This routine converts a fixed decimal value to a fixed binary value.
; 
; inputs:
; 
;	r0 = address of the source
;	r1 = size or precision of source
;	r2 = address of the destination
;	r3 = size or the precision of the destination
; 
; outputs:
; 
;	The destination is filled in
; --
	.entry	pli$fixdfixb_r6,^m<iv,dv,r4,r5>
fixdfixb:
	bsbb	cvrt_fixd_fixb		; use common routine
	ret				;
cvrt_fixd_fixb:
	subl	#16,sp			; make a buffer
	movzbl	r1,r5			; get prec
	ashl	#-8,r1,r1		; get scale
	cvtbl	r1,r1			; sign extend scale
	mnegl	r1,r1			; negate for shift off fraction digits
	ashl	#-8,r3,r4		; get destination scale
	movzbl	r3,r3			; zero extend dest prec
	cvtbl	r4,r4			; sign extend dest scale, zero scale?
	beql	60$			; if eql yes
	pushl	r3			; save destination prec and scale
	movq	r1,-(sp)		; save source prec and scale and target address
	subl	#16,sp			; allocate a second buffer
	tstl	r4			; dest scale negative?
	bgtr	10$			; if gtr, no
	mnegl	r4,r4			; calc abs(dest scale)
	mull2	#6,r4			; use scale as offset into a power 2 table
	divp	#10,g^pli$b_pac_2_power_00[r4],-;truncate implied zero bits for fixed bin negative scale
		r5,(r0),#31,(sp)	;
	brb	20$			; join common code for pos and neg scale
10$:	mull2	#6,r4			; use scale as offset into a power 2 table
	mulp	#10,g^pli$b_pac_2_power_00[r4],-; calc 2**(dest scale) * source
		r5,(r0),#31,(sp)	;
20$:	ashp	16(sp),#31,(sp),#0,#31,28(sp); shift to truncate decimal fraction
	cvtpl	#31,28(sp),r5		; do conversion to integer
	extzv	#3,#2,24(sp),r3		; get context
	movl	20(sp),r2		; restore address of destination
	addl	#44,sp			; clean up the stack
	case	type=b,r3,<50$,40$,30$>	; case on destination context
30$:	movl	r5,(r2)			;
	rsb
40$:	cvtlw	r5,(r2)			;
	rsb
50$:	cvtlb	r5,(r2)			;
	rsb
60$:	movq	r2,-(sp)		; 
	ashp	r1,r5,(r0),#0,#31,8(sp)	; shift into integer
	cvtpl	#31,8(sp),r5		; do conversion
	movq	(sp)+,r2		; restore
	pushl	r5			; store in memory
	movl	sp,r0			; address it
	movl	#31,r1			; set size
	bsbw	cvrt_fixb_fixb		; store result
	addl	#20,sp			; clean stack
	rsb
	.page
	.sbttl	fixdfltb - fixed decimal to floating binary conversion
; ++
; fixdfltb - fixed decimal to floating binary conversion
; 
; functional description:
; 
; This routine converts a fixed decimal value to a floating binary value.
; 
; inputs:
; 
;	r0 = address of the source
;	r1 = size or precision of source
;	r2 = address of the destination
;	r3 = size or the precision of the destination
; 
; outputs:
; 
;	The destination is filled in
; --
	.entry	pli$fixdfltb_r6,^m<iv,dv,r4,r5,r6,r7>
fixdfltb:
	bsbw	dest_fltb_prec		; get dest context
	bsbb	cvrt_fixd_flt
	ret
cvrt_fixd_flt:
	ashl	#-8,r1,r4		; save scale
	movzbl	r1,r5			; get prec
;
; try quick convert by going to longword
;
	bicpsw	#psl$m_iv		; turn off int overflow
	pushr	#^m<r0,r1,r2,r3>	; save regs
	cvtpl	r5,(r0),r6		; cvt packed to long
	popr	#^m<r0,r1,r2,r3>	; restore regs
	bvs	9$			; if overflow, do it the long way
	bispsw	#psl$m_iv		; re-enable int overflow
	case	type=b,r7,<1$,2$,3$>	; case on dest type
	cvtlh	r6,-(sp)		; cvrt to huge temp
	mulh3	h_power_of_10[r4],(sp)+,(r2)	; adjust result for scale
	rsb
1$:	cvtld	r6,r6			; cvrt to double
	muld2	d_power_of_10[r4],r6	; adjust for scale
	cvtdf	r6,(r2)			; cvrt to float result
	rsb
2$:	cvtld	r6,r6			; cvrt to double
	muld3	d_power_of_10[r4],r6,(r2)	;adjust result to scale
	rsb
3$:	cvtlh	r6,-(sp)		; cvrt src to huge
	mulh2	h_power_of_10[r4],(sp)	; adjust for scale
	cvthg	(sp)+,(r2)		; cvrt to grand result
	rsb
;
; the long way
;
9$:	bispsw	#psl$m_iv		; reset int overflow
	subl	#32,sp			; allocate temp for leading sep string
	pushl	sp			; make a descriptor for l.s. str
	addl3	#1,r5,-(sp)		; inc sign byte in desc str length
	movq	r2,-(sp)		; save dest. regs
	cvtps	r5,(r0),r5,16(sp)	; cvrt packed to leading sep
	movq	(sp),r2			; restore dest,but leave space on stack
	clrq	-(sp)			; and make more room for return value
;					; make frame for convert call
	clrl	-(sp)			; caller flags (default round)
	pushl	#0			; scale
	pushl	#0			; frac
	pushal	12(sp)			; return addr
	pushal	32(sp)			; src descriptor addr
;
	case	type=b,r7,<10$,20$,30$>	; case on dest context
;
	calls	#5,g^ots$cvt_t_h	; cvrt to huge
	blbc	r0,50$			; br if error
	mulh3	h_power_of_10[r4],(sp),(r2)	; mul return value by scale
	addl	#56,sp			; clean stack
	rsb
10$:	calls	#5,g^ots$cvt_t_d	; cvrt to double
	blbc	r0,50$			; br if error
	muld2	d_power_of_10[r4],(sp)	; adjust for scale
	cvtdf	(sp),(r2)		; cvrt result to float
	addl	#56,sp			; clean stack
	rsb
20$:	calls	#5,g^ots$cvt_t_d	; cvrt to double
	blbc	r0,50$			; br if error
	muld3	d_power_of_10[r4],(sp),(r2)	; mul return value by scale
	addl	#56,sp			; clean stack
	rsb
30$:	calls	#5,g^ots$cvt_t_h	; cvrt to huge
	blbc	r0,50$			; br if error
	mulh2	h_power_of_10[r4],(sp)	; adjust for scale
	cvthg	(sp),(r2)		; cvrt result to grand
	addl	#56,sp			; clean stack
	rsb
50$:	brw	error
	.page
	.sbttl	fixdfixd - fixed decimal to fixed decimal conversion
; ++
; fixdfixd - fixed decimal to fixed decimal conversion
; 
; functional description:
; 
; This routine converts a fixed decimal value to a fixed decimal value.
; 
; inputs:
; 
;	r0 = address of the source
;	r1 = size or precision of source
;	r2 = address of the destination
;	r3 = size or the precision of the destination
; 
; outputs:
; 
;	The destination is filled in
; --
	.entry	pli$fixdfixd_r6,^m<iv,dv,r4,r5>
fixdfixd:
	movzbl	r1,r4			; get prec and scale
	ashl	#-8,r1,r1		; 
	movzbl	r3,r5			; 
	ashl	#-8,r3,r3		; 
	subl	r1,r3			; calc scale change
	ashp	r3,r4,(r0),#0,r5,(r2)	; move data
	ret
	.page
	.sbttl	fixdfltd - fixed decimal to float decimal conversion
; ++
; fixdfltd - fixed decimal to float decimal conversion
; 
; functional description:
; 
; This routine converts a fixed decimal value to a float decimal value.
; 
; inputs:
; 
;	r0 = address of the source
;	r1 = size or precision of source
;	r2 = address of the destination
;	r3 = size or the precision of the destination
; 
; outputs:
; 
;	The destination is filled in
; --
	.entry	pli$fixdfltd_r6,^m<iv,dv,r4,r5,r6,r7>
fixdfltd:
	bsbw	dest_fltd_prec		; get dest context
	bsbw	cvrt_fixd_flt		; continue in common
	ret
	.page
; ++
; fixdchar - fixed decimal to character conversion
; 
; functional description:
; 
; This routine converts a fixed decimal value to a character string.
; 
; inputs:
; 
;	r0 = address of the source
;	r1 = size or precision of source
;	r2 = address of the destination
;	r3 = size or the precision of the destination
; 
; outputs:
; 
;	The destination is filled in
; --

edit_beg:
	eo$insert	<^x20>
	eo$insert	<^x20>
edint:	eo$float	0
	eo$float	15
	eo$end_float
	eo$set_signif
	eo$move		1
edpt:	eo$insert	<^a/./>
edfrac:	eo$move		0
	eo$move		15
	eo$move		1
	eo$end
	eo$end
edit_end:

no_int:	eo$set_signif
	eo$store_sign
	eo$insert	<^a/0/>

edit_len	=	edit_end-edit_beg
edit_int	=	edint-edit_beg
edit_pt		=	edpt-edit_beg
edit_frac	=	edfrac-edit_beg

	.entry	pli$fixdchar_r6,^m<iv,dv,r4,r5,r6>
fixdchar:
	movzbl	r1,r4			; 
	addl3	#3,r4,r6		; r6 is the precision based size
	subl	r6,sp			; allocate the space on the stack
	movq	r3,-(sp)		; save regs
	pushl	r2			; save r2
	movq	edit_beg+8,-(sp)	; copy end of edit table to stack
	movq	edit_beg,-(sp)		; copy beginning of table to stack
	movl	sp,r2			; save address of beginning of table
	ashl	#-8,r1,r5		; get scale
	bneq	10$			; if neq, scale present
	clrb	edit_pt(sp)		; no scale, don't do dec pt or frac
	brb	20$			; continue in common
10$:	subl	r5,r4			; get size of int part
	subl	#16,r5			; scale > 16
	bgtr	15$			; if gtr, yes
	bneq	14$			; if neq, scale < 16
	movb	#3,edit_frac(sp)	; nop first move of frac
	brb	16$			; continue
14$:	clrb	edit_frac+1(sp)		; skip last move for fraction
	addl	#16,r5			; readjust scale
15$:	insv	r5,#0,#4,edit_frac(sp)	; set size of fraction
16$:	tstw	(r2)+			; skip first insert in table
	tstl	r4			; check size of integer part
	beql	40$			; if eql, no integer part
20$:	decl	r4			; calculate size of float int part
	beql	50$			; if eql, only 1 digit integer
	subl	#15,r4			; int part > 15 digits?
	bgtr	25$			; if gtr, yes
	movb	#1,edit_int+1(sp)	; don't do second float
	addl	#15,r4			; readjust size
25$:	insv	r4,#0,#4,edit_int(sp)	; set size of float int part
30$:	editpc	24(sp),(r0),(r2),28(sp)	; edit the string
	movc5	r6,28(sp),#^x20,20(sp),@16(sp) ; copy to destination
	ret				; and return
40$:	movab	edit_int+1(sp),r2	; get address of new start of table
	movl	no_int,(r2)		; copy new start of table
	brb	30$			; continue in common
50$:	movb	no_int,edit_int(sp)	; nop first byte of float int part
	movw	no_int,edit_int+1(sp)	; nop rest of float int part
	brb	30$			; continue in common

	.page
	.sbttl	fixdvcha - fixed decimal to character varying conversion
; ++
; fixdvcha - fixed decimal to character varying conversion
; 
; functional description:
; 
; This routine converts a fixed decimal value to a character varying string.
; 
; inputs:
; 
;	r0 = address of the source
;	r1 = size or precision of source
;	r2 = address of the destination
;	r3 = size or the precision of the destination
; 
; outputs:
; 
;	The destination is filled in
; --
	.entry	pli$fixdvcha_r6,^m<iv,dv,r4,r5,r6>
fixdvcha:
	movzbl	r1,r4			; get precision of source
	addl	#3,r4			; get size of dest based on precision
	movw	r4,(r2)			; insert size
	cmpw	r4,r3			; destination large enough?
	blequ	10$			; if lequ then yes
	movw	r3,(r2)			; insert max size
10$:	tstw	(r2)+			; address actual text target
	brw	fixdchar		; continue in common
	.page
	.sbttl	fixdabit - fixed decimal to bit aligned conversion
; ++
; fixdabit - fixed decimal to bit aligned conversion
; fixdbit - fixed decimal to bit string conversion
; 
; functional description:
; 
; This routine converts a fixed decimal value to a bit aligned string.
; 
; inputs:
; 
;	r0 = address of the source
;	r1 = size or precision of source
;	r2 = address of the destination
;	r3 = size or the precision of the destination
;	r6 = bit offset to destination
; 
; outputs:
; 
;	The destination is filled in
; --
	.entry	pli$fixdabit_r6,^m<iv,dv,r4,r5,r6>
fixdabit:
	bsbw	clr_abit_trailer	; clear abit last byte
	brb	fixdbit
	.entry	pli$fixdbit_r6,^m<iv,dv,r4,r5>
fixdbit:
	subl	#4,sp			; get space for temp
	pushr	#^m<r2,r3,r6>		; save destination
	moval	12(sp),r2		; plug address of temp for dest
	movzbl	r1,r3			; get src prec
	ashl	#-8,r1,r4		; get src scale
	subl2	r4,r3			; prec-scale
	mull	#332,r3			; conv prec from dec to binary digits
	addl	#99,r3
	divl	#100,r3
	cmpl	r3,#31			; check for max prec
	bleq	20$			; if leq, br
	movl	#31,r3			; else set dest prec to max
20$:	pushl	r3			; save  binary prec
	movl	#31,r3			; convert to fixed bin(31)
	bsbw	cvrt_fixd_fixb		; convert source to fixb temp
	popl	r1			; reset src prec to binary prec
	popr	#^m<r2,r3,r6>		; restore destination
	movl	sp,r0			; plug address of temp for source
	brw	fixbbit			; done
	.page
	.sbttl	fltdpic - float decimal to picture conversion
; ++
; fltdpic - float decimal to picture conversion
; 
; functional description:
; 
; This routine converts a float decimal value to a picture value.
; 
; inputs:
; 
;	r0 = address of the source
;	r1 = size or precision of source
;	r2 = address of the destination
;	r3 = size or the precision of the destination
; 
; outputs:
; 
;	The destination is filled in
; --
	.entry	pli$fltdpic_r6,^m<iv,dv,r4,r5,r6,r7,r8>
fltdpic:
	bsbw	src_fltd_prec		; get src context
	bsbw	cvrt_flt_pic		; cont in common
	ret
	.page
	.sbttl	fltdfixb - float decimal to fixed binary conversion
; ++
; fltdfixb - float decimal to fixed binary conversion
; 
; functional description:
; 
; This routine converts a float decimal value to a fixed binary value.
; 
; inputs:
; 
;	r0 = address of the source
;	r1 = size or precision of source
;	r2 = address of the destination
;	r3 = size or the precision of the destination
; 
; outputs:
; 
;	The destination is filled in
; --
	.entry	pli$fltdfixb_r6,^m<iv,dv,r4>
fltdfixb:
	bsbw	src_fltd_prec		; get src context
	bsbw	cvrt_flt_fixb		; do conversion
	ret
	.page
	.sbttl	fltdfltb - float decimal to float binary conversion
; ++
; fltdfltb - float decimal to float binary conversion
; 
; functional description:
; 
; This routine converts a float decimal value to a float binary value.
; 
; inputs:
; 
;	r0 = address of the source
;	r1 = size or precision of source
;	r2 = address of the destination
;	r3 = size or the precision of the destination
; 
; outputs:
; 
;	The destination is filled in
; --
	.entry	pli$fltdfltb_r6,^m<iv,dv,r4,r7>
fltdfltb:
	bsbw	src_fltd_prec		; get src context
	bsbw	dest_fltb_prec		; get dest context
	bsbw	cvrt_flt_flt		; cont in common
	ret
	.page
	.sbttl	fltdfixd - float decimal to fixed decimal conversion
; ++
; fltdfixd - float decimal to fixed decimal conversion
; 
; functional description:
; 
; This routine converts a float decimal value to a fixed decimal value.
; 
; inputs:
; 
;	r0 = address of the source
;	r1 = size or precision of source
;	r2 = address of the destination
;	r3 = size or the precision of the destination
; 
; outputs:
; 
;	The destination is filled in
; --
	.entry	pli$fltdfixd_r6,^m<iv,dv,r4,r5,r6,r7,r8>
fltdfixd:
	bsbw	src_fltd_prec		; get src context
	bsbw	cvrt_flt_fixd		; do conversion
	ret
	.page
	.sbttl	fltdfltd - float decimal to float decimal conversion
; ++
; fltdfltd - float decimal to float decimal conversion
; 
; functional description:
; 
; This routine converts a float decimal value to a float decimal value.
; 
; inputs:
; 
;	r0 = address of the source
;	r1 = size or precision of source
;	r2 = address of the destination
;	r3 = size or the precision of the destination
; 
; outputs:
; 
;	The destination is filled in
; --
	.entry	pli$fltdfltd_r6,^m<iv,dv,r4,r7>
fltdfltd:
	bsbw	src_fltd_prec		; get src context
	bsbw	dest_fltd_prec		; get dest context
	bsbw	cvrt_flt_flt		; cont in common
	ret
	.page
	.sbttl	fltdchar - float decimal to character conversion
; ++
; fltdchar - float decimal to character conversion
; 
; functional description:
; 
; This routine converts a float decimal value to a character value.
; 
; inputs:
; 
;	r0 = address of the source
;	r1 = size or precision of source
;	r2 = address of the destination
;	r3 = size or the precision of the destination
; 
; outputs:
; 
;	The destination is filled in
; --
	.entry	pli$fltdchar_r6,^m<iv,dv,r4,r5,r6,r7,r8,r9,r10,r11>
fltdchar:
	bsbw	src_fltd_prec		; get src context
	bsbw	cvrt_flt_char		; do conversion
	ret
	.page
	.sbttl	fltdvcha - float decimal to character varying conversion
; ++
; fltdvcha - float decimal to character varying conversion
; 
; functional description:
; 
; This routine converts a float decimal value to a character varying value.
; 
; inputs:
; 
;	r0 = address of the source
;	r1 = size or precision of source
;	r2 = address of the destination
;	r3 = size or the precision of the destination
; 
; outputs:
; 
;	The destination is filled in
; --
	.entry	pli$fltdvcha_r6,^m<iv,dv,r4,r5,r6,r7,r8,r9,r10,r11>
fltdvcha:
	pushaw	(r2)+			; save dest & point to string
	bsbw	 src_fltd_prec		; get src context
	bsbw	cvrt_flt_char		; do conversion
	movw	r0,@(sp)+		; plug in size
	ret
	.page
	.sbttl	fltdbit - float decimal to bit conversion
; ++
; fltdbit - float decimal to bit conversion
; 
; functional description:
; 
; This routine converts a float decimal value to a bit value.
; 
; inputs:
; 
;	r0 = address of the source
;	r1 = size or precision of source
;	r2 = address of the destination
;	r3 = size or the precision of the destination
; 
; outputs:
; 
;	The destination is filled in
; --
	.entry	pli$fltdbit_r6,^m<iv,dv,r4,r5>
fltdbit:
	mull	#332,r1			; convert decimal to binary prec
	addl	#99,r1
	divl	#100,r1
	brw	fltbbit			; continue in common
	.page
	.sbttl	fltdabit - float decimal to bit aligned conversion
; ++
; fltdabit - float decimal to bit aligned conversion
; 
; functional description:
; 
; This routine converts a float decimal value to a bit aligned value.
; 
; inputs:
; 
;	r0 = address of the source
;	r1 = size or precision of source
;	r2 = address of the destination
;	r3 = size or the precision of the destination
; 
; outputs:
; 
;	The destination is filled in
; --
	.entry	pli$fltdabit_r6,^m<iv,dv,r4,r5,r6>
fltdabit:
	bsbw	clr_abit_trailer	; clear abit last byte
	brw	fltdbit
	.page
	.sbttl	charpic - character string to picture conversion
; ++
; charpic - character string to picture conversion
; 
; functional description:
; 
; This routine converts a character string to a picture value.
; 
; inputs:
; 
;	r0 = address of the source
;	r1 = size or precision of source
;	r2 = address of the destination
;	r3 = size or the precision of the destination
; 
; outputs:
; 
;	The destination is filled in
; --
	.entry	pli$charpic_r6,^m<iv,dv,r4,r5,r6,r7,r8,r9,r10,r11>
charpic:
	movab	pli$cnvrt_hnd,(sp)	; conversion condition handler
	movab	b^10$,r10		; address completion routine
	movl	r3,r11			; save pic node addr
	cvtwl	pic$w_pq(r3),r3		; set to target p,q
	brw	charfix			; convert to fixed decimal
;
; complete processing
;
10$:
	pushl	r2			; target addr
	movzbl	pic$b_byte_size(r11),-(sp); target size
	pushl	r0			; src addr
	pushl	r1			; src p,q
	pushl	r11			; pic node addr
	calls	#5,g^pli$cvt_to_pic	; convert to picture
	ret
	.page
	.sbttl	charfixb - character string to fixed binary conversion
; ++
; charfixb - character string to fixed binary conversion
; 
; functional description:
; 
; This routine converts a character string to a fixed binary value.
; 
; inputs:
; 
;	r0 = address of the source
;	r1 = size or precision of source
;	r2 = address of the destination
;	r3 = size or the precision of the destination
; 
; outputs:
; 
;	The destination is filled in
; --
	.entry	pli$charfixb_r6,^m<iv,dv,r4,r5,r6,r7,r8,r9,r10>
charfixb:
	movab	pli$cnvrt_hnd,(fp)	; conversion condition handler
	movab	w^fixdfixb,r10		; pass address of completion routine
	brw	charfix			; continue
	.page
	.sbttl	charfltb - character string to floating binary conversion
; ++
; charfltb - character string to floating binary conversion
; 
; functional description:
; 
; This routine converts a character string to a floating binary value.
; 
; inputs:
; 
;	r0 = address of the source
;	r1 = size or precision of source
;	r2 = address of the destination
;	r3 = size or the precision of the destination
; 
; outputs:
; 
;	The destination is filled in
; --
	.entry	pli$charfltb_r6,^m<iv,dv,r4,r7>
charfltb:
	movab	pli$cnvrt_hnd,(fp)	; conversion condition handler
	bsbw	dest_fltb_prec		; get dest context
	bsbb	cvrt_char_flt
	ret
cvrt_char_flt:
	clrl	r4			;set no default fractional digits
cvrt_fchr_flt:				;entry with fractional digits
	subl	#16,sp			; allocate a place for the return
	pushl	r0			; set up source desc
	pushl	r1			; 
	clrl	-(sp)			; caller flags: default round
	pushl	#0			; set scale
	pushl	r4			; set fraction size
	pushal	20(sp)			; address return
	pushal	16(sp)			; address source descr
	skpc	#^x20,20(sp),@24(sp)	; skip leading blanks
	beql	5$			; all blanks, ok
	locc	#^x20,r0,(r1)		; find next blank
	subl	r0,20(sp)		; treat as end of string
5$:	case 	type=b,r7,<6$,7$,8$>	; case to appropriate conversion
	calls	#5,g^ots$cvt_t_h
	blbc	r0,20$
	movh	8(sp),(r2)
	addl	#24,sp			; clean stack
	rsb
6$:	calls	#5,g^ots$cvt_t_d
	blbc	r0,20$
	cvtdf	8(sp),(r2)
	addl	#24,sp			; clean stack
	rsb
7$:	calls	#5,g^ots$cvt_t_d
	blbc	r0,20$
	movd	8(sp),(r2)
	addl	#24,sp			; clean stack
	rsb
8$:	calls	#5,g^ots$cvt_t_g
	blbc	r0,20$
	movg	8(sp),(r2)
	addl	#24,sp			; clean stack
	rsb
;
20$:	brw	error			; continue - no stack cleanup needed
	.page
	.sbttl	charfixd - character string to fixed decimal conversion
; ++
; charfixd - character string to fixed decimal conversion
; 
; functional description:
; 
; This routine converts character strings of the form:
; [<blanks>][sign][integer][.[fraction]][e|E[sign]exponent][<blanks>]
; to a fixed decimal value.
; 
; inputs:
;	r0 = address of source
;	r1 = length of source
;	r2 = address of destination
;	r3 = precision and scale of the destination
; 
; outputs:
;	r0-r5 destroyed
;	r6-r14 preserved
;	the input operand is converted to fixed decimal.
; 
; local register usage
;	r0-r5 clobbered by string instructions
;	r6 = address of next byte in source string
;	r7 = number of bytes remaining in source string
;	r8 = address of next byte in leading separate temp
;	r9 = mask value for scanc
;	r10 = address of routine to convert from fixd to final destination
; 
; --
 
; 
; local symbols
; 
 
blank=1
pt=2
exp=4
 
; 
; local data
; 
 
scantbl:
	.blkb	256
$$$t1=.
.=scantbl+^x20
	.byte	blank
.=scantbl+^x2e
	.byte	pt
.=scantbl+^x45
	.byte	exp
.=scantbl+^x65
	.byte	exp
.=$$$t1
 
 
	.enabl	lsb
 
	.entry	pli$charfixd_r6,^m<iv,dv,r4,r5,r6,r7,r8,r9,r10>
charfixd:
	movab	pli$cnvrt_hnd,(fp)	; conversion condition handler
	movab	w^fixdfixd,r10		; set completion routine address
	brw	charfix			; do the conversion
 
 
5$:	subl2	#16,sp			; get space for packed temp
	cvtlp	#0,#31,(sp)		; set result to zero
	brw	70$			; continue in common
charfix:
	pushr	#^m<r2,r3>		; save registers
	clrl	-(sp)			; initialize scale factor
	movq	r0,r6			; copy r0,r1 to r6,r7
	subl2	#32,sp			; get space for leading sep temp
	movl	sp,r8			; copy leading sep addr
	skpc	#^x20,r7,(r6)		; skip leading blanks in source
	beql	5$			; if eql, then all blanks, use 0
	movl	r0,r7			; update source length
	movl	r1,r6			; update source pointer
	movl	#<blank+exp+pt>,r9	; set mask to terminate integer
	bsbw	gen_lead_sep		; copy integer to lead sep temp
	clrl	32(sp)			; set zero scale
	tstl	r7			; more characters?
	beql	10$			; if eql then no
	cmpb	(r6),#^a/./		; was integer finished by a decimal pt?
	bneq	10$			; if neq, no
	incl	r6			; advance source pointer past dec. pt.
	decl	r7			; update source length
	scanc	r7,(r6),scantbl,#<blank+exp> ; find end of fraction
	subl2	r6,r1			; get number of digits in fraction
	subl2	r1,r7			; subtract from source length
	movl	r1,32(sp)		; save as scale
	movc3	r1,(r6),(r8)		; copy frac to lead sep temp
	movl	r1,r6			; update source pointer
	movl	r3,r8			; update dest pointer
10$:	subl2	sp,r8			; get size of leading sep string
	decl	r8			; 
	subl2	#16,sp			; get space for packed temp
	cvtsp	r8,16(sp),#31,(sp)	; convert leading sep to packed
	tstl	r7			; done with source string?
	beql	70$			; if eql, yes
	cmpb	(r6),#^a/E/		; exponent specified?
	beql	20$			; if eql, yes
	cmpb	(r6),#^a/e/		; exponent with a small e?
	bneq	50$			; if neq, no, check rest of source
20$:	incl	r6			; skip past e or E
	decl	r7			; update source length
	movab	16(sp),r8		; point to lead sep temp
	pushl	r8			; save address
	movl	#blank,r9		; set mask to terminate exponent
	bsbb	gen_lead_sep		; transfer sign and exponent to lead sep
	subl	(sp),r8			; calculate size of lead sep
	decl	r8
	cvtsp	r8,20(sp),#4,(sp)	; convert exponent to packed
	cvtpl	#4,(sp),(sp)		; convert exponent to long
	subl	(sp)+,48(sp)		; subtract exponent from scale
	bgeq	50$			; if scale geq, we're set
	movp	#31,(sp),16(sp)		; copy packed integer and fraction
	mnegl	48(sp),r0		; get negative scale
	ashp	r0,#31,16(sp),#0,#31,(sp) ; shift so we have positive scale
	clrl	48(sp)			; indicate this in scale factor
50$:	skpc	#^x20,r7,(r6)		; skip past blanks
	bneq	80$			; if blanks don't finish the source
70$:	movq	52(sp),r2		; get back original destination
	movl	sp,r0			; source is packed temp
	movl	#31,r1			; precision is max
	insv	48(sp),#8,#8,r1		; add in scale factor
	jmp	(r10)			; return
 
80$:	brw	error			; continue - no stack cleanup needed
 
	.dsabl	lsb
; + gen_lead_sep - copy sign and integer from source to destination
; 
; this routine copies an integer from the source string to the destination
; string. the destination string will be in leading separate format because
; gen_lead_sep will put a + into the first byte of the destination if there is
; no explicit sign in the source string. the source string pointer
; will be updated to point past the integer. the source string length
; will be updated to not include the integer. the destination pointer 
; will point to the byte after the integer in the destination string.
; no checking is done as the the validity of the integer. any leading
; blanks should be removed before calling int_sign.
; 
; inputs:
;	r6 = address of the source string
;	r7 = length of the source string
;	r8 = address of the destination string
;	r9 = mask to use with scanc to determine end of integer
; 
; outputs:
;	r0-r5 destroyed
;	r6 = address of the remaining source string
;	r7 = length of the remaining source string
;	r8 = address of the next free byte in the destination string
;	r9-r14 unchanged
; -
 
gen_lead_sep:
	movb	#^a/+/,(r8)		; plug a + into the destination
	cmpb	(r6),(r8)+		; was there a + in the source?
	beql	10$			; if eql, yes
	cmpb	(r6),#^a/-/		; was there a -?
	bneq	20$			; if neq	no, default to +
10$:	movb	(r6)+,-1(r8)		; plug the source sign into the dest
	decl	r7			; correct source length
20$:	scanc	r7,(r6),scantbl,r9	; look for terminator in source
	subl	r6,r1			; calculate length for movc
	subl	r1,r7			; correct source length
	cmpl	r1,#31			;is this too big?
	blequ	30$			;if lssu , no, cont	
	brw	error			;signal error
30$:	movc3	r1,(r6),(r8)		; move the integer
	movl	r1,r6			; update pointers
	movl	r3,r8			; 
	rsb				; return
 
 
	.page
	.sbttl	charfltd - character to float decimal conversion
; ++
; charfltd - character to float decimal conversion
; 
; functional description:
; 
; This routine converts a character value to a float decimal value.
; 
; inputs:
; 
;	r0 = address of the source
;	r1 = size or precision of source
;	r2 = address of the destination
;	r3 = size or the precision of the destination
; 
; outputs:
; 
;	The destination is filled in
; --
	.entry	pli$charfltd_r6,^m<iv,dv,r4,r7>
charfltd:
	movab	pli$cnvrt_hnd,(fp)	; conversion condition handler
	bsbw	dest_fltd_prec		; get dest context
	bsbw	cvrt_char_flt		; continue in common
	ret
	.page
	.sbttl	fchrfltd - fractioned character to float decimal conversion
; ++
; fchrfltd - fractioned character to float decimal conversion
; 
; functional description:
; 
; This routine converts a character value to a float decimal value. It
; accepts as input the default number of digits in the fraction, if no
; decimal point is contained within the character string source. This is
; currently used only by the e format input routine.
; 
; inputs:
; 
;	r0 = address of the source
;	r1 = size or precision of source
;	r2 = address of the destination
;	r3 = size or the precision of the destination
;	r4 = number of default fractional digits, if decimal point is missing
; 
; outputs:
; 
;	The destination is filled in
; --
	.entry	pli$fchrfltd_r6,^m<iv,dv,r4,r7>
	movab	pli$cnvrt_hnd,(fp)	; conversion condition handler
	bsbw	dest_fltd_prec		; get dest context
	bsbw	cvrt_fchr_flt		; continue in common
	ret
	.page
	.sbttl	charchar - convert character to character
; ++
; charchar - convert character to character
; 
; functional description:
; 
; This routine converts character strings to character.
; 
; inputs:
; 
;	r0 = address of the source
;	r1 = size or precision of source
;	r2 = address of the destination
;	r3 = size or the precision of the destination
; 
; outputs:
; 
;	The destination is filled in
; --
	.entry	pli$charchar_r6,^m<iv,dv,r4,r5>
charchar:
	movc5	r1,(r0),#32,r3,(r2)	; perform the operation
	ret
	.page
	.sbttl	charvcha - convert character to character varying
; ++
; charvcha - character to character varying
; 
; functional description:
; 
; This routine converts character string to character varying.
; 
; inputs:
; 
;	r0 = address of the source
;	r1 = size or precision of source
;	r2 = address of the destination
;	r3 = size or the precision of the destination
; 
; outputs:
; 
;	The destination is filled in
; --
	.entry	pli$charvcha_r6,^m<iv,dv,r4,r5>
charvcha:
	movw	r1,(r2)			; move size
	cmpw	r1,r3			; that size fit?
	blequ	10$			; if lequ then yes
	movw	r3,(r2)			; use smaller size
10$:	tstw	(r2)+			; point to string
	movc5	r1,(r0),#32,r3,(r2)	; move it
	ret
	.page
	.sbttl	charbit - convert character to bit
; ++
; charabit - character to bit aligned
; charbit - character to bit conversion
; 
; functional description:
; 
; This routine converts character string to a bit string.
; 
; inputs:
; 
;	r0 = address of the source
;	r1 = size or precision of source
;	r2 = address of the destination
;	r3 = size or the precision of the destination
;	r6 = bit offset of the destination
; 
; outputs:
; 
;	The destination is filled in
; --
	.entry	pli$charabit_r6,^m<iv,dv,r4,r5,r6>
charabit:
	movab	pli$cnvrt_hnd,(fp)	; conversion condition handler
	bsbw	clr_abit_trailer	; clear abit last byte
	brb	charbit			;
	.entry	pli$charbit_r6,^m<iv,dv,r4,r5>
charbit:
	movab	pli$cnvrt_hnd,(fp)	; conversion condition handler
 
	bsbw	clr_bit_dest		; reset bit destination
10$:	decl	r3			; get next bit
	blss	50$			; if lss then done
	decl	r1			; get next char
	blss	50$			; if lss then done
	movzbl	(r0)+,r4		; 
	subb	#^a/0/,r4		; find bit equiv
	blss	70$			; if lss then out of range
	cmpb	r4,#1			; in range
	bgtru	70$			; if gtru then error
	insv	r4,r6,#1,(r2)		; insert in list
	incl	r6			; address next offset
	brb	10$			; continue until done
 
50$:	cmpl	r1,r3			; see if there's more chars in src
	bleq	60$			; if not, br
55$:	decl	r1			; get the remaining chars
	blss	60$			;
	movb	(r0)+,r4		; 
	cmpb	#^a/ /,r4		; see if blank
	bneq	56$
	skpc	#^a/ /,r1,(r0)		; if blank, then must be all blank
	beql	60$			; all done, if all blank
	brb	70$			; else, error
56$:	subl	#^a/0/,r4		; see if valid bit char
	beql	55$			; if 0, ok
	decl	r4			; if 1, ok
	beql	55$			;
	brb	70$			; otherwise, error
60$:	ret
 
70$:	brw	error
	.page
	.sbttl	vchapic - character varying to picture conversion
; ++
; vchapic - character varying to picture conversion
; 
; functional description:
; 
; This routine converts a character varying string to a picture value.
; 
; inputs:
; 
;	r0 = address of the source
;	r1 = size or precision of source
;	r2 = address of the destination
;	r3 = size or the precision of the destination
; 
; outputs:
; 
;	The destination is filled in
; --
	.entry	pli$vchapic_r6,^m<iv,dv,r4,r5,r6,r7,r8,r9,r10,r11>
vchapic:
	movab	pli$cnvrt_hnd,(fp)	; conversion condition handler
	tstw	(r0)+			; point to char string
	brw	charpic
	.page
	.sbttl	vchafixb - character varying to fixed binary conversion
; ++
; vchafixb - character varying to fixed binary conversion
; 
; functional description:
; 
; This routine converts a character varying string to a fixed binary value.
; 
; inputs:
; 
;	r0 = address of the source
;	r1 = size or precision of source
;	r2 = address of the destination
;	r3 = size or the precision of the destination
; 
; outputs:
; 
;	The destination is filled in
; --
	.entry	pli$vchafixb_r6,^m<iv,dv,r4,r5,r6,r7,r8,r9,r10>
vchafixb:
	movab	pli$cnvrt_hnd,(fp)	; conversion condition handler
	tstw	(r0)+			; point to character string
	brw	charfixb		; 
	.page
	.sbttl	vchafltb - character varying to floating binary conversion
; ++
; vchafltb - character varying to floating binary conversion
; 
; functional description:
; 
; This routine converts a character varying string to a floating binary value.
; 
; inputs:
; 
;	r0 = address of the source
;	r1 = size or precision of source
;	r2 = address of the destination
;	r3 = size or the precision of the destination
; 
; outputs:
; 
;	The destination is filled in
; --
	.entry	pli$vchafltb_r6,^m<iv,dv,r4,r7>
vchafltb:
	movab	pli$cnvrt_hnd,(fp)	; conversion condition handler
	tstw	(r0)+			; point to character string
	brw	charfltb		; do conversion
	.page
	.sbttl	vchafixd - character varying to fixed decimal conversion
; ++
; vchafixd - character varying to fixed decimal conversion
; 
; functional description:
; 
; This routine converts a character varying string to a fixed decimal value.
; 
; inputs:
; 
;	r0 = address of the source
;	r1 = size or precision of source
;	r2 = address of the destination
;	r3 = size or the precision of the destination
; 
; outputs:
; 
;	The destination is filled in
; --
	.entry	pli$vchafixd_r6,^m<iv,dv,r4,r5,r6,r7,r8,r9,r10>
vchafixd:
	movab	pli$cnvrt_hnd,(fp)	; conversion condition handler
	tstw	(r0)+			; skip size of string
	brw	charfixd		; convert as character
	.page
	.sbttl	vchafltd - character varying to float decimal conversion
; ++
; vchafltd - character varying to float decimal conversion
; 
; functional description:
; 
; This routine converts a character varying value to a float decimal value.
; 
; inputs:
; 
;	r0 = address of the source
;	r1 = size or precision of source
;	r2 = address of the destination
;	r3 = size or the precision of the destination
; 
; outputs:
; 
;	The destination is filled in
; --
	.entry	pli$vchafltd_r6,^m<iv,dv,r4,r7>
vchafltd:
	movab	pli$cnvrt_hnd,(fp)	; conversion condition handler
	tstw	(r0)+			; point to string
	bsbw	dest_fltd_prec		; get dest context
	bsbw	cvrt_char_flt		; continue in common
	ret
	.page
	.sbttl	vchavcha - convert character varying to character varying
; ++
; vchavcha - convert character varying to character varying
; 
; functional description:
; 
; This routine converts character varying strings to character varying.
; 
; inputs:
; 
;	r0 = address of the source
;	r1 = size or precision of source
;	r2 = address of the destination
;	r3 = size or the precision of the destination
; 
; outputs:
; 
;	The destination is filled in
; --
	.entry	pli$vchavcha_r6,^m<iv,dv,r4,r5>
vchavcha:
	movw	r1,(r2)			; insert size
	cmpw	r1,r3			; room for source
	blequ	10$			; if lequ then yes
	movw	r3,(r2)			; 
10$:	cmpw	(r0)+,(r2)+		; point to strings
	movc5	r1,(r0),#32,r3,(r2)	; move it
	ret
	.page
	.sbttl	vchachar - convert character varying to character
; ++
; vchachar - character varying to character
; 
; functional description:
; 
; This routine converts character varying strings to character.
; 
; inputs:
; 
;	r0 = address of the source
;	r1 = size or precision of source
;	r2 = address of the destination
;	r3 = size or the precision of the destination
; 
; outputs:
; 
;	The destination is filled in
; --
	.entry	pli$vchachar_r6,^m<iv,dv,r4,r5>
vchachar:
	tstw	(r0)+			; 
	movc5	r1,(r0),#32,r3,(r2)	; move it
	ret
	.page
	.sbttl	vhcabit - character varying to bit string conversion
; ++
; vchabit - character varying to bit string conversion
; 
; functional description:
; 
; This routine converts a character varying string to a bit string.
; 
; inputs:
; 
;	r0 = address of the source
;	r1 = size or precision of source
;	r2 = address of the destination
;	r3 = size or the precision of the destination
;	r6 = bit offset to destination
; 
; outputs:
; 
;	The destination is filled in
; --
	.entry	pli$vchaabit_r6,^m<iv,dv,r4,r5,r6>
vchaabit:
	movab	pli$cnvrt_hnd,(fp)	; conversion condition handler
	bsbw	clr_abit_trailer	; clear abit last byte
	brb	vchabit
	.entry	pli$vchabit_r6,^m<iv,dv,r4,r5>
vchabit:
	movab	pli$cnvrt_hnd,(fp)	; conversion condition handler
	tstw	(r0)+			; 
	brw	charbit			; 
	.page
	.sbttl	bitpic - bit string to picture conversion
; ++
; bitpic - bit string to picture conversion
; 
; functional description:
; 
; This routine converts a bit string value to a picture value.
; 
; inputs:
; 
;	r0 = address of the source
;	r1 = size or precision of source
;	r2 = address of the destination
;	r3 = size or the precision of the destination
;	r5 = bit offset to source
; 
; outputs:
; 
;	The destination is filled in
; --
	.entry	pli$bitpic_r6,^m<iv,dv,r4>
bitpic:
	subl	#16,sp			; alloc packed temp
	pushl	r2			; make frame for pic cvrt before regs go away
	movzbl	pic$b_byte_size(r3),-(sp); frame target size
	movab	8(sp),r2		; reset dest to temp
	pushl	r2			; push it as pic cvrt src
	movzwl	pic$w_pq(r3),-(sp)	; push target p,q as src p,q
	pushl	r3			; pic node addr
	movzwl	pic$w_pq(r3),r3		; reset dest size as pic p,q
	bsbw	cvrt_bit_fixd		; conv bit src to fix dec
	calls	#5,g^pli$cvt_to_pic	; frame all set, cvrt dec to pic
	ret
	.page
	.sbttl	bitfixb - bit string to fixed binary conversion
; ++
; bitfixb - bit string to fixed binary conversion
; 
; functional description:
; 
; This routine converts a bit string value to a fixed binary value.
; 
; inputs:
; 
;	r0 = address of the source
;	r1 = size or precision of source
;	r2 = address of the destination
;	r3 = size or the precision of the destination
;	r5 = bit offset to source
; 
; outputs:
; 
;	The destination is filled in
; --
	.entry	pli$bitfixb_r6,^m<iv,dv,r4>
bitfixb:
	bsbb	cvrt_bits_fixb		; use common routine
	ret
cvrt_bits_fixb:
	bsbw	chk_bit_arith		; check values
	extzv	r5,r1,(r0),r0		; get bit string
	movl	sp,r5			; address a temp
	clrl	-(sp)			;
;
10$:	movzbl	r0,r4			; get low order byte
	movb	reverse_bit_tbl[r4],-(r5) ; get reversed byte
	ashl	#-8,r0,r0		; shift src down a byte
	bneq	10$
;
	subl3	r1,#32,r5		; adjust for proper prec.
	extzv	r5,r1,(sp),(sp)		; move it down 
	movab	(sp),r0			; address src
	bsbw	cvrt_fixb_fixb		; convrt to dest
	clrl	(sp)+			; clean stack
	rsb
	.page
	.sbttl	bitfltb - bit string to floating binary conversion
; ++
; bitfltb - bit string to floating binary conversion
; 
; functional description:
; 
; This routine converts a bit string value to a floating binary value.
; 
; inputs:
; 
;	r0 = address of the source
;	r1 = size or precision of source
;	r2 = address of the destination
;	r3 = size or the precision of the destination
;	r5 = bit offset to source
; 
; outputs:
; 
;	The destination is filled in
; --
	.entry	pli$bitfltb_r6,^m<iv,dv,r4,r7>
bitfltb:
	bsbw	dest_fltb_prec		; get dest context
	bsbw	cvrt_bit_flt
	ret
cvrt_bit_flt:
	movq	r2,-(sp)		; save dest
	moval	-(sp),r2		; allocate room for a temp
	movl	#31,r3			; specify max prec
	bsbw	cvrt_bits_fixb		; convert source to fixb
	movl	sp,r0			; temp is now source
	movl	#31,r1			; with max prec
	movq	4(sp),r2		; restore dest
	bsbw	cvrt_fixb_flt		; convert temp to fltb
	addl	#12,sp
	rsb
	.page
	.sbttl	bitfixd - bit string to fixed decimal conversion
; ++
; bitfixd - bit string to fixed decimal conversion
; 
; functional description:
; 
; This routine converts a bit string value to a fixed decimal value.
; 
; inputs:
; 
;	r0 = address of the source
;	r1 = size or precision of source
;	r2 = address of the destination
;	r3 = size or the precision of the destination
;	r5 = bit offset to source
; 
; outputs:
; 
;	The destination is filled in
; --
	.entry	pli$bitfixd_r6,^m<iv,dv,r4>
bitfixd:
	bsbb	cvrt_bit_fixd
	ret
cvrt_bit_fixd:
	tstl	-(sp)			; allocate some room for temp
	pushr	#^m<r2,r3>		; save real destination
	moval	8(sp),r2		; dest addr is on stack above r2,r3
	movl	#31,r3			; length is max
	bsbw	cvrt_bits_fixb		; convert to fixb
	popr	#^m<r2,r3>		; restore dest
	movl	sp,r0			; specify source is on stack
	movl	#31,r1			; specify max precision for source
	bsbw	cvrt_fixb_fixd		; convert to fixd
	tstl	(sp)+			; clean stack
	rsb
	.page
	.sbttl	bitfltd - bit to float decimal conversion
; ++
; bitfltd - bit to float decimal conversion
; 
; functional description:
; 
; This routine converts a bit value to a float decimal value.
; 
; inputs:
; 
;	r0 = address of the source
;	r1 = size or precision of source
;	r2 = address of the destination
;	r3 = size or the precision of the destination
; 
; outputs:
; 
;	The destination is filled in
; --
	.entry	pli$bitfltd_r6,^m<iv,dv,r4,r7>
bitfltd:
	bsbw	dest_fltd_prec		; get dest context
	bsbw	cvrt_bit_flt		; cont in common
	ret
	.page
	.sbttl bitchar - bit string to character conversion
; ++
; bitchar - bit string to character conversion
; 
; functional description:
; 
; This routine converts a bit string value to a character string.
; 
; inputs:
; 
;	r0 = address of the source
;	r1 = size or precision of source
;	r2 = address of the destination
;	r3 = size or the precision of the destination
;	r5 = bit offset to source
; 
; outputs:
; 
;	The destination is filled in
; --
	.entry	pli$bitchar_r6,^m<iv,dv,r4,r7,r8>
bitchar:
	movl	r3,r8			;copy dest size
	cmpl	r1,r3			;see if blank fill needed in dest
	bgeq	2$			;if source geq dest, then no
	movl	r1,r3			;set dest size=source size
2$:	subl2	r3,r8			;get count for blank fill
;
5$:	bsbw	get_next_32bits		; get next field
	movl	#32,r7			; set loop count
10$:	decl	r3			; count target character position
	blss	20$			; if lss then done
	movb	#^a/0/,(r2)		; assume zero
	blbc	r4,15$			; test bit
	incb	(r2)			; set to a one
15$:	incl	r2			; point to next character
	ashl	#-1,r4,r4		; adjust value
	sobgtr	r7,10$			; continue until done
	brb	5$			; get next field
;
20$:	tstl	r8			;see if blank fill needed
	beql	30$			;if not, br
	MOVC5	#0,(R0),#^A/ /,R8,(R2)	;MOVE IN THE BLANKS
30$:	ret
	
; 
; get_next_32bits - get next 32 bit field from source bit string
; 
; inputs:
; 
;	r0 = base address of string
;	r1 = remaining size
;	r5 = offset from base to string
; 
; outputs:
; 
;	r0,r1,r5 are updated to address then next field
;	r4 = value
; 
get_next_32bits:
	movl	#32,r4			; assume 32 bit return
	cmpl	r1,r4			; 32 bits remaining?
	bgtr	10$			; if gtr then yes
	movl	r1,r4			; 
	beql	20$			; if eql then done
10$:	subl	r4,r1			; remove bits from count
	extzv	r5,r4,(r0),r4		; get the bits
	addl	#4,r0			; point to next field
20$:	rsb				; 
	
; 
; put_next 32 bits - insert next 32 bit field
; 
; inputs:
; 
;	r2 = base address of the field
;	r3 = size remaining
;	r6 = offset from base to field
;	r4 = value to insert
; 
; outputs:
; 
;	r2,r3,r6 are updated to address then next field
; 
put_next_32bits:
	movl	#32,r7			; assume 32 bit insert
	cmpl	r3,r7			; room for 32?
	bgtr	10$			; if gtr then yes
	movl	r3,r7			; set low value
	beql	20$			; if eql then no room
10$:	subl	r7,r3			; remove size
	insv	r4,r6,r7,(r2)		; insert field
	addl	#4,r2			; point to next field
20$:	rsb
	.page
	.sbttl	bitvcha - bit string to character varying conversion
; ++
; bitvcha - bit string to character varying conversion
; 
; functional description:
; 
; This routine converts a bit string value to a character varying string.
; 
; inputs:
; 
;	r0 = address of the source
;	r1 = size or precision of source
;	r2 = address of the destination
;	r3 = size or the precision of the destination
;	r5 = bit offset to source
; 
; outputs:
; 
;	The destination is filled in
; --
	.entry	pli$bitvcha_r6,^m<iv,dv,r4,r7,r8>
bitvcha:
	movw	r1,(r2)			; insert source size
	cmpw	r1,r3			; enough room for source?
	blequ	10$			; 
	movw	r3,(r2)			; use smaller size
10$:	tstw	(r2)+			; 
	brw	bitchar			; 
	.page
	.sbttl	bitbit - bit string to bit string conversion
; ++
; bitbit - bit string to bit string conversion
; 
; functional description:
; 
; This routine converts a bit string value to a bit string.
; 
; inputs:
; 
;	r0 = address of the source
;	r1 = size or precision of source
;	r2 = address of the destination
;	r3 = size or the precision of the destination
;	r5 = bit offset to source
;	r6 = bit offset to the destination
; 
; outputs:
; 
;	The destination is filled in
; --
	.entry	pli$bitbit_r6,^m<iv,dv,r4,r7>
bitbit:
 
10$:	bsbw	get_next_32bits		; move field
	bsbw	put_next_32bits		; 
	tstl	r1			; source remaining?
	bneq	10$			; if neq then yes
	tstl	r3			; target remaining?
	bneq	10$			; 
	ret
	.page
	.sbttl	bitabit - bit string to bit aligned conversion
; ++
; bitabit - bit string to bit aligned conversion
; 
; functional description:
; 
; This routine converts a bit string value to a bit aligned string.
; 
; inputs:
; 
;	r0 = address of the source
;	r1 = size or precision of source
;	r2 = address of the destination
;	r3 = size or the precision of the destination
;	r5 = bit offset to source
; 
; outputs:
; 
;	The destination is filled in
; --
	.entry	pli$bitabit_r6,^m<iv,dv,r4,r6,r7>
bitabit:
	bsbw	clr_abit_trailer	; clear abit last byte
	brb	bitbit			; 
	.page
	.sbttl	abitpic - bit aligned to picture conversion
; ++
; abitpic - bit aligned to picture conversion
; 
; functional description:
; 
; This routine converts a bit aligned string to a picture value.
; 
; inputs:
; 
;	r0 = address of the source
;	r1 = size or precision of source
;	r2 = address of the destination
;	r3 = size or the precision of the destination
; 
; outputs:
; 
;	The destination is filled in
; --
	.entry	pli$abitpic_r6,^m<iv,dv,r4>
abitpic:
	clrl	r5			; clr src bit offset
	brw	bitpic
	.page
	.sbttl	abitfixb - bit aligned to fixed binary conversion
; ++
; abitfixb - bit aligned to fixed binary conversion
; 
; functional description:
; 
; This routine converts a bit aligned string to a fixed binary value.
; 
; inputs:
; 
;	r0 = address of the source
;	r1 = size or precision of source
;	r2 = address of the destination
;	r3 = size or the precision of the destination
; 
; outputs:
; 
;	The destination is filled in
; --
	.entry	pli$abitfixb_r6,^m<iv,dv,r4,r5>
abitfixb:
	clrl	r5			; set no source offset
	brw	bitfixb			; 
	.page
	.sbttl	abitfltb - bit aligned to floating binary conversion
; ++
; abitfltb - bit aligned to floating binary conversion
; 
; functional description:
; 
; This routine converts a bit aligned string to a floating binary value.
; 
; inputs:
; 
;	r0 = address of the source
;	r1 = size or precision of source
;	r2 = address of the destination
;	r3 = size or the precision of the destination
; 
; outputs:
; 
;	The destination is filled in
; --
	.entry	pli$abitfltb_r6,^m<iv,dv,r4,r5,r7>
abitfltb:
	clrl	r5			; set no source offset
	brw	bitfltb			; continue in common
	.page
	.sbttl	abitfixd - bit aligned to fixed decimal conversion
; ++
; abitfixd - bit aligned to fixed decimal conversion
; 
; functional description:
; 
; This routine converts a bit aligned string to a fixed decimal value.
; 
; inputs:
; 
;	r0 = address of the source
;	r1 = size or precision of source
;	r2 = address of the destination
;	r3 = size or the precision of the destination
; 
; outputs:
; 
;	The destination is filled in
; --
	.entry	pli$abitfixd_r6,^m<iv,dv,r4,r5>
abitfixd:
	clrl	r5			; set no source offset
	bsbw	bitfixd			; continue in common
	ret
	.page
	.sbttl	abitfltd - bit aligned to float decimal conversion
; ++
; abitfltd - bit aligned to float decimal conversion
; 
; functional description:
; 
; This routine converts a bit aligned value to a float decimal value.
; 
; inputs:
; 
;	r0 = address of the source
;	r1 = size or precision of source
;	r2 = address of the destination
;	r3 = size or the precision of the destination
; 
; outputs:
; 
;	The destination is filled in
; --
	.entry	pli$abitfltd_r6,^m<iv,dv,r4,r5,r7>
abitfltd:
	clrl	r5			; clr bit offset
	bsbw	dest_fltd_prec		; get dest context
	bsbw	cvrt_bit_flt		; cont in common
	ret
	.page
	.sbttl abitchar - bit aligned to character conversion
; ++
; abitchar - bit aligned to character conversion
; 
; functional description:
; 
; This routine converts a bit aligned string to a character string.
; 
; inputs:
; 
;	r0 = address of the source
;	r1 = size or precision of source
;	r2 = address of the destination
;	r3 = size or the precision of the destination
; 
; outputs:
; 
;	The destination is filled in
; --
	.entry	pli$abitchar_r6,^m<iv,dv,r4,r5,r7,r8>
abitchar:
	clrl	r5			; set no source offset
	brw	bitchar			; continue in common
	.page
	.sbttl	abitvcha - bit aligned to character varying conversion
; ++
; abitvcha - bit aligned to character varying conversion
; 
; functional description:
; 
; This routine converts a bit aligned string to a character varying string.
; 
; inputs:
; 
;	r0 = address of the source
;	r1 = size or precision of source
;	r2 = address of the destination
;	r3 = size or the precision of the destination
; 
; outputs:
; 
;	The destination is filled in
; --
	.entry	pli$abitvcha_r6,^m<iv,dv,r4,r5,r7,r8>
abitvcha:
	clrl	r5			; set no source offset
	movw	r1,(r2)			; assume that source will fit
	cmpl	r1,r3			; fit?
	blequ	10$			; if lequ then ok
	movw	r3,(r2)			; set max size
10$:	tstw	(r2)+			; address string
	brw	bitchar			; continue in common
	.page
	.sbttl	abitbit - bit aligned to bit string conversion
; ++
; abitbit - bit aligned to bit string conversion
; 
; functional description:
; 
; This routine converts a bit aligned string to a bit string.
; 
; inputs:
; 
;	r0 = address of the source
;	r1 = size or precision of source
;	r2 = address of the destination
;	r3 = size or the precision of the destination
;	r6 = bit offset to the destination
; 
; outputs:
; 
;	The destination is filled in
; --
	.entry	pli$abitbit_r6,^m<iv,dv,r4,r5,r7>
abitbit:
	clrl	r5			; set no source offset
	brw	bitbit			; 
	.page
	.sbttl	abitabit - bit aligned to bit aligned conversion
; ++
; abitabit - bit aligned to bit aligned conversion
; 
; functional description:
; 
; This routine converts a bit aligned string to a bit aligned string.
; 
; inputs:
; 
;	r0 = address of the source
;	r1 = size or precision of source
;	r2 = address of the destination
;	r3 = size or the precision of the destination
;	r6 = bit offset to the destination
; 
; outputs:
; 
;	The destination is filled in
; --
	.entry	pli$abitabit_r6,^m<iv,dv,r4,r5,r6,r7>
abitabit:
	clrl	r5			; set no source offset
	bsbw	clr_abit_trailer	; clear abit last byte
	brw	bitbit			; 
 
	.end

