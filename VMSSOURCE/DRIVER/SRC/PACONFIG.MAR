	.TITLE	PACONFIG
	.IDENT	'V04-001'

;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
;++
;
; FACILITY:
;
;	VAX/VMS EXECUTIVE, I/O DRIVERS
;
; ABSTRACT:  CI CLUSTER CONFIGURATION DATABASE MAINTENANCE
;
; AUTHOR:  N. KRONENBERG,  MAY 1981
;
;MODIFIED BY:
;
;	V04-001	NPK3066		N. Kronenberg		 7-Sep-1984
;		If the port microcode rev check fails, clear the
;		flag, INI$PORT_REV to indicate that, if a bugcheck
;		is taken as a result of crashing this port, it should
;		be the UCODEREV bugcheck, rather than the usual CIPORT
;		bugcheck.
;
;	V03-39	NPK3063		N. Kronenberg		20-Aug-1984
;		Fix SET_CIRCUIT to operate at high priority.  Fixes
;		the lost connect request message problem.
;		Add check to REFRESH_SB to return conflicting SCS
;		node name/ID if the SB being refreshed is the local
;		SB and the incarnation number being refreshed is 
;		different from the incarnation currently there.
;
;	V03-38	NPK3060		N. Kronenberg		 1-Aug-1984
;		Fix CNF$LBREC to attribute the loopback dg to the
;		correct path in the case where PANUMPORT .LE. 
;		PAMAXPORT. 
;		Fix check for own port number which was erroneously
;		concluding we had an ID pkt from a port other than
;		self and could therefore disable loopback datagrams.
;
;	V03-37	NPK3057		N. Kronenberg		23-Jul-1984
;		On port ucode rev level check failure, zero port's
;		reinit retry remaining count to force port to
;		stay offline.
;
;	V03-36	NPK3055		N. Kronenberg		14-Jul-1984
;		Add tally to CNF$IDREC, NEW_PATH, to track number
;		of ports known and if that number equals, or exceeds
;		the number of free dg buffers queued to the port
;		for receiving IDREC pkts, then queue 2 more dg buffers
;		to the port, one for IDREC and one for HSC error log
;		datagrams.  (This will be somewhat excessive if the
;		number of ports polled per poll interval is fewer
;		than 16.) 
;		Modify CNF$REMOVE_PB to decrement PDT$W_STDGUSED for
;		ports that disappear (but the free dg's queued for
;		IDRECs and HSC error log dgs concerning that port
;		are left queued for future use.)
;		Add the concept of legal port ucode rev's that require
;		a warning message and error log entry, but are still
;		supported.
;		Change behavior of illegal port ucode rev to set
;		the port offline permanently.
;		Change CNF$CALC_POLLSW to use number of free dgs
;		currently queued for IDREC's rather than SCS$GW_PAPPDDG,
;		then number sysgened.
;
;	V03-35	NPK3054		N. Kronenberg		24-Jun-1984
;		Add check for ci780/ci750 minimum microcode rev level.
;		Do this check only on own port when ID packet is
;		received and we are getting ready to open a vc to
;		own port.
;
;	V03-34	NPK3052		N. Kronenberg		19-Apr-1984
;		Correct computation of poll sweep time:  add PASTIMOUT
;		and account for limit in number of free datagram buffers
;		set aside for concurrent handshakes.
;
;	V03-33	WHM0001		Bill Matthews		14-Apr-1984
;		Remove reference to SCS$GB_NODENAMEH.
;
;	V03-32	NPK3048		N. Kronenberg		 4-Apr-1984
;		Overhaul CNF$STOP_VCS to scan the path blocks for
;		circuits to send shutdowns over.  This allows us
;		to check the PPD protocol level of target systems
;		and to send shutdowns only to ports with protocol
;		level 1 or above.  With that protocol level PPD
;		implementations are required to tolerate PPD types
;		they don't act upon.
;		Modify BREAK_HOST, which is executed upon receipt
;		of a host shutdown dg, to save SS$_NOSUCHNODE in
;		PB$W_VCFAIL_RSN as the aux status to report to SYSAPs.
;		Modify PB creation to initialize PB$W_VCFAIL_RSN to
;		0, i.e., no host shutdown in progress.
;		Modify SB creation to save PPD protocol level in
;		formative PB.
;
;	V03-31	NPK3047		N. Kronenberg		15-Mar-1984
;		Add new routine CNF$STOP_VCS to send host shutdown dgs
;		to all ports to which we have vcs open or are in
;		the process of opening circuits.
;		Modify logic in ENTER_PB which excludes systems
;		with unique system ID's but the same node names.
;		Enforce the exclusion except for V3.x systems which
;		will all have the same node name.
;		Fix EDIV in CNF$CALC_POLLSW.
;
;	V03-30	NPK3046		N. Kronenberg		 8-Mar-1984
;		On receipt of an error log datagram, call new routine
;		REC_ERROR_DG which returns the datagram to the free
;		queue and decrements the PA device error count.
;		Add to CNF$TIMER calculation of the number of
;		seconds to poll every port at least once and put
;		the result in PDT$L_POLL_SWEEP.
;		Fix local port name in PB to be PAc0, with the 0
;		in ASCII instead of binary.
;
;	V03-29	TMK0002		Todd M. Katz		14-Feb-1984
;		When ENTER_PB discovers that there is a conflict between a
;		known system in the local system-wide configuration database
;		and the information provided by a remote system to which 
;		it is attempting to establish a virtual circuit, the routine
;		terminates with an error status indicating that such a virtual
; 		circuit can not be allowed to be established. Add support for
;		the error logging of such events. 
;
;		This error logging is done only for the first time ENTER_PB
;		discovers that it is unable to talk to a remote system. This is 
;		accomplished through the use of the PDT bit mask, PDT$B_PLOGMAP.
;		Whenever ENTER_PB determines that the information provided by a
;		remote system conflicts with a known system it checks the bit 
;		within this mask which corresponds to the remote port number. 
;		If the bit is set this means that this particular conflict has 
;		already been logged; however, if the bit is clear this means 
;		that this particular conflict has not yet been logged, so the 
;		bit is set and the conflict between the remote and known systems
;		is logged. The bit corresponding to the remote port number is 
;		always un-conditionally cleared whenever ENTER_PB finds no 
;		conflict and moves the formative path block into the system-wide
;		configuration data base before returning success.
;
;	V03-28	PRD0071		Paul R. DeStefano	25-Feb-1984
;		Clear SB$L_CSB (link to newest Cluster System Block)
;		when a system block is created.
;
;	V03-27	NPK3044		N. Kronenberg		06-Feb-1984
;		Juggle action table event codes (EV$C...) to add 
;		EV$C_ELOG = 5 = PPD$C_ELOG, the new error log datagram.
;		Add error log datagram handling instructions to the
;		action table.
;		Change FMT_START_DATA to set protocol rev level to 1
;		so we can receive error log datagrams.
;
;	V03-26	TMK0001		Todd M. Katz		03-Feb-1984
;		Change the use of the SYSGEN parameter PAMAXPORT. The setting
;		of this parameter used to indicate not only whether the local 
;		port(s) should poll remote ports, but also represented a 
;		software setable value for the maximum port number to poll. 
;		PAMAXPORT still retains this latter function, but the former,
;		whether any polling at all should be done, has been taken over 
;		by the new SYSGEN parameter PANOPOLL. 
;
;		I have also fixed two bugs within CNF$TIMER:
;
;		1. Correct how the check is made for expiration of START/STACK
;		   datagrams. Right now timeouts will always be signalled for
;		   those timer cells within formative PBs which have not 
;		   expired while timeouts will never be signalled for those 
;		   timer cells that within formative PBs that have expired.
;		   It should be the other way around.
;
;		2. The check made for an empty pool waiter queue is done 
;		   incorrectly. The way it is currently done guarentees that
;		   the queue will never be found to be empty. It is left
;		   up to the subsequent REMQUE, which consquently must always 
;		   be done, to discover that the queue is actually empty.
;
;	V03-25	NPK3041		N. Kronenberg		30-Jan-1984
;		Fix ENTER_PB to not talk to a formative system with
;		different system ID, but same node name as a system
;		already in the system list.
;
;	V03-24	NPK3040		N. Kronenberg		20-Jan-1984
;		Fix bug in extraction of port number in CNF$SCSMSG_REC.
;
;	V03-23	NPK3039		N. Kronenberg		11-Jan-1984
;		Modify the routine to transition a formative PB
;		to fully open upon receipt of a CONNECT_REQ.  If
;		there is no formative or fully open PB (because the
;		ENTER_PB and no pool was available to close the vc
;		that was opened in anticipation of a successful
;		ENTER_PB), then close the vc now and return.
;		Modify ENTER_PB to close the vc if the enter fails.
;
;	V03-022	NPK3031		N. Kronenberg		 9-Aug-1983
;		Change UPDATE_SWINCARN to copy PPD$Q_SWINCARN instead
;		of PPD$Q_CURTIME.
;
;	V03-021	NPK3029		N. Kronenberg		18-Jul-1983
;		Enhancements for V4.0:
;		Remove temporary assembled in sysgen param for max
;		port number to poll.
;		Add routine CNF$SCSMSG_REC to complete transition of
;		formative path block to fully open state if a CONNECT_
;		REQ scs control msg is received before the start handshake
;		is complete or if the final ack is lost.
;		Add UPDATE_SWINCARN to use the latest sw incarnation from
;		a start handshake rather than the one received with the
;		1st START dg.
;		Clean up local symbols in ENTER_PB.  
;		Drop PB$L_SB in favor of PB$L_SBLINK.
;		Change CNF$IDREC to reflect slightly reordered PB.
;		Prevent systems from being configured that have the
;		same system id and different node names or the same
;		node name and different id's.
;
;	V03-020	KTA3046		Kerbey T. Altmann	30-Mar-1983
;		Redo for SCS/PPD split.
;
;	V03-019	NPK3022		N. Kronenberg		28-Feb-1983
;		Get system software version from SYS$GQ_VERSION instead
;		of SYS$K_VERSION for the start handshake.
;
;	V03-018 NPK3020		N. Kronenberg		28-Feb-1983
;		Fix word arithmetic in action dispatcher that computes
;		next state/action to be longwd arithmetic.
;
;	V03-017	DWT0068		David W. Thiel		20-Jan-1983
;		Add call to SCS$NEW_SB when a system block is created
;		or reused.
;
;	V03-016	NPK3015		N. Kronenberg		28-Dec-1982
;		Fix bugs in LB_ENABLE which turns loopback dgs back on
;		when all remote vc's gone.
;		Fix disable of lb dg in CNF$IDREC to be BICW instead of
;		BISW.
;
;	V03-015	NPK3014		N. Kronenberg		16-Dec-1982
;		Fix to return IDREC dg to free queue in case virtual circuit
;		must be crashed due to remote being in neither the enabled
;		nor maint enabled states.
;		Get node name for start/stack from the sysgened node name.	
;
;	V03-014	NPK3010		N. Kronenberg		11-Nov-1982
;		Implement probe of n ports per poll rather than 16
;		ports per poll.
;		Implement poll of sysgenable maximum number of ports
;		rather than all 16 (or 240).
;		Add loopback dg enabled flag which is updated when
;		VC's are broken or attempted rather than figuring out
;		if loopback dg's should be enabled each poller interval.
;		Allow SB's with no path blocks to stay in configuration
;		database and expand info held in SB.
;
;	V03-013	NPK3008		N. Kronenberg		 6-Oct-1982
;		Change FMT_START_DATA to include new protocol, nodename,
;		current time, and shortened hardware version fields in
;		start/stack dgs.
;
;	V03-012	NPK3006		N. Kronenberg		 9-Sep-1982
;		Fixed action table to show that SET_CIRCUIT can
;		return status.  Fixed action dispatcher to save event
;		code on stack and to discard received START/STACK dg
;		if any, in case of action routine error status.  Fixes
;		free dg disappearance problem.  Also fixed action   
;		dispatcher to discard received dg on action table lookup
;		failure only if there is a dg in hand.  Changed
;		FMT_START_DATA to put correct CPU type in dg.
;
;	V03-011	NPK3005		N. Kronenberg		19-Aug-1982
;		In CNF$DGREC fix search of configuration database
;		to call CNF$LKP_PB_MSG instead of manually matching
;		on remote station addr (which is an incomplete check)
;
;	V03-010	ROW0114		Ralph O. Weber		30-JUN-1982
;		Add a check to CNF$LBREC which prevents it from logging a 
;		successful loopback datagram received when the previous 
;		loopback datagram for the path in question was also 
;		successfully received.
;		This change will be in a new driver image shipped in V3.1.
;
;	V03-009	NPK3001		N. Kronenberg		28-Jun-1982
;		Modify ENTER_PB to save SB link permanently in PB$L_SBLINK.
;		Fix CNF$REMOVE_PB to patch the SB link to the next path to
;		use for a connection.
;
;	V03-008	ROW0112		Ralph O. Weber		27-JUN-1982
;		Change loopback datagram logging to use ELOG$CABLES instead of 
;		ELOG$PACKET so that the error log type field gets set 
;		correctly.  Remove crossed loopback path logic which isn't 
;		supported by the hardware anyway.  Fix loopback status to 
;		always be successful when no loopback datagram is sent because 
;		there is another known node.
;		This change will be in a new driver image shipped in V3.1.
;
;	V03-007	ROW0109		Ralph O. Weber		24-JUN-1982
;		Modify CNF$POLL to send loopback datagrams if and only if no 
;		bits are set in the PDT port bit map, or the only bit set in 
;		the map is the one for the port on which the loopback datagram 
;		would be sent.
;		This change will be in a new driver image shipped in V3.1.
;
;	V03-006	ROW0106		Ralph O. Weber		23-JUN-1982
;		Add error logging for loopback datagrams to CNF$POLL and 
;		CNF$LBREC.  Enhance this error logging to aid in the detection 
;		of a single pair of crossed wires between a port and the star 
;		coupler.  (N.B. the hardware currently does not support these
;		crossed wires checks.)
;		This change will be in a new driver image shipped in V3.1.
;
;	V03-005	ROW0097		Ralph O. Weber		 7-JUN-1982
;		Added calls to error logging routines in CNF$IDREC at 
;		UPDATE_CBL_STS and UPDATE_PTH_STS.  Modified comments in 
;		CNF$POLL is show that loop-back datagrams are not currently 
;		supported and thus their results need not be logged.  Also 
;		added necessary reference to the $PAERDEF macro.
;		This change will be in a new driver image shipped in V3.1.
;
;	V03-004	NPK2020		N. Kronenberg		23-Apr-1982
;		Modified ENTER_PB to discard formative PB for system
;		that is already in the database but with a different
;		incarnation number.  Prevents configuration of two
;		different systems that have the same system ID.
;
;	V03-003	NPK2019		N. Kronenberg		9-Apr-1982
;		Fixed PB allocation failure bug.
;		Made PB lookup failure in CNF$DGREC recoverable.
;	
;	V03-002	NPK2018		N. Kronenberg		25-Mar-1982
;		Fixed to use short datagrams instead of LRP's for
;		REQID and SETCKT's.
;		Fixed to not do start handshake with remote port
;		in other than an enabled state.  If IDREC arrives
;		from port to which VC is open and remote port is
;		in other than an enabled state, crash the VC.
;		Updated format of start/stack dg.
;		Modify to allocate and attach a dg pkt to each
;		PB for use during VC crash.
;
;	V03-001	NPK2016		N. Kronenberg		18-Mar-1982
;		Fixed .TITLE
;
;--

;++
; This module of the CI port driver is responsible for polling the
; nodes in the cluster for new arrivals and for conducting the
; START handshake protocol necessary to opening port-port virtual 
; circuits to new nodes.
;
; The system wide configuration database consists of:
;
;
;	SCS$GQ_CONFIG
;	     |
;	     v
;	System Block ----> Path Block ----> Path Block ---->...
;	     |
;	     v
;	System Block ----> Path Block ---->...
;	     |
;	     v
;	    ...
;
; Both systems and paths with open port-port VC's and systems
; with no open paths are kept on the above list.
;
; When an IDREC datagram is received for a node which is currently
; unknown, a PB is created for it and linked to the formative PB
; list for this port.  When a START/STACK datagram is received from
; that port as part of the START handshake, a formative SB is 
; created and linked to the PB.  The formative datastructure looks
; like:
;
;	PDT
;	 |
;	 v
;	Path Block ----> (System Block)
;	 |
;	 v
;	Path Block ----> (System Block)
;	 |
;	 v
;	...
;
; When the START handshake is complete, a matching SB is sought in
; the system configuration database.  If one is found, then the 
; formative SB is discarded and the formative PB linked to the
; existing SB.  If no matching SB is found, then the formative SB
; is moved to the system configuration database and, with it, its
; formative PB.
;
; The configuration poller is awakened periodically for each local 
; port by the timer scan module.  Each time it wakes up, it allocates
; n (SCS$GB_PANPOLL) datagrams from pool and uses these datagrams
; to send REQID's to the next n ports.
;
; Datagram management is as follows:  Upon port initialization
; SGN$GB_PPDDG datagrams are preallocated and linked to the 
; datagram free queue for receipt of IDREC's.  When any start
; handshake datagram is received (including IDREC) which is turned 
; around to send the next protocol message, it is sent with
; RETFLAG=FALSE so that the datagram is returned to the free
; queue.  A received datagram which does not result in a new 
; datagram being sent is simply returned to the free queue.  
; Datagrams that must be allocated from pool because there is no
; received datagram to turn around (e.g., START/STACK retries)
; are sent out with RETFLAG=TRUE to return them on the response
; queue.  Datagram buffers returned via the response queue are
; deallocated to pool again.
;
; The major routines in this module (in order of appearance) are:
;
; CNF$POLL		-The configuration poller which wakes up
;			 periodically and sends REQID's.
;
; CNF$IDREC		-Called by the interrupt service module when
;			 an unsolicited (XCT_ID=0) IDREC arrives.  
;			 If the sending port (station) currently has 
;			 no PB in either the system wide database or
;			 in the PDT formative PB list, then a PB is
;			 created and START handshake initiated.  Else
;			 the IDREC is discarded.
;
; CNF$DGREC		-Called by the interrupt service module when
;			 a START, STACK, or ACK dg is received.  The
;			 action dispatcher, ACTION_DISP is called.
;
; ACTION_DISP		-Based on the path's current state and the
;			 event that just occurred, a sequence of 
;			 action routines is called.  These correspond 
;			 to the handshake steps described in the 
;			 SCA spec.  The actions are table driven.
;
; Assorted action	-E.g., send a START dg, set a timer on the
; routines		 path, build a system block...
;
;--

	.SBTTL	DEFINITIONS

;
; Set PSECT to driver code:
;

	.PSECT	$$$115_DRIVER,LONG

;
; System definitions (LIB.MLB):
;

	.nocross
	$CRBDEF				; Channel Request Block offsets
	$DDBDEF				; Device Datablock offsets
	$DYNDEF				; Structure type codes
	$IPLDEF				; IPL definitions
	$PBDEF				; Path Block offsets
	$PDTDEF				; Port Descriptor Table offsets
	$PRDEF				; Internal Processor Registers
	$SBDEF				; System Block offsets
	$SSDEF				; System service definitions
	$SYSAPDEF			; DG disposal flags
	$UCBDEF				; Unit Control Block offsets

;
; PADRIVER definitions (PALIB.MLB):
;

	$PAERDEF			; Port driver error code values
	$PAPBDEF			; CI extension to PB
	$PAPDTDEF			; CI extension to PDT
	$PAUCBDEF			; CI extension to UCB
	$PPDDEF				; PPD layer of message/dg header
	.cross

	.SBTTL	CNF$POLL, PERIODICALLY SEND REQID TO PORTS

;+
; CNF$POLL is awakened periodically by CNF$TIMER. If remote port polling is
; enabled (SCS$GB_PANOPOLL is set to 0), it allocates as many datagram buffers 
; as there are ports to poll per interval (up to the maximum legal port # 
; specified by SCS$GB_PAMXPORT or the maximum legal hardware port # specified by
; PDT$B_MAX_PORT - which is ever is the smallest), and sends a REQID to each 
; port. The sent buffers are reclaimed on the response queue and returned to 
; pool.  
;
; If datagram receipt is currently inhibited from this remote port,
; then datagrams are first reenabled via a SETCKT command.
;
; If the sweep does not complete due to lack of pool, CNF$POLL returns
; without error.
;
; Later receipt of the IDREC's will cause the START 
; handshake to begin for the remote systems not currently known.
;
; The poller also initiates various diagnostic activities to 
; check for physical connection problems or other errors in the 
; cluster:
;
;	-Before polling begins, a loopback datagram is sent out if
;	 loopback dg's are enabled.  LB dg's are enabled when no 
;	 remote port is known; otherwise, they are disabled.
;	 Later, successful receipt of the LB dg is recorded in routine
;	 CNF$LBREC.  Successful receipt of the last LB dg sent on this
;	 path is checked here in LB_CHECK, before sending a new LB dg.
;
;	-REQID's are sent to all ports even if we have already 
;	 succeeded in a START handshake.  REQID's are sent with 
;	 explicit path select thus forcing the port to try the path
;	 even if it thinks it is bad.  Later receipt of an IDREC on this
;	 path forces the port to bring it back if it was previously
;	 marked bad.  It also lets us log the transition of a path
;	 from bad to good.
;
; Inputs:
;
;	R4			-Addr of PDT
;
; Outputs:
;
;	R0-R2			-Destroyed
;	other registers		-Preserved
;
;-

	.ENABL	LSB

CNF$POLL::

	PUSHR	#^M<R3,R5,R6,R7>	; Save some registers
	TSTB	G^SCS$GB_PANOPOLL	; Is remote polling enabled?
	BEQL	5$			; Continue if it is
	BRW	CONFIG_EXIT		; Else exit poller

5$:	MOVZBL	PDT$B_NXT_PORT(R4),R6	; Get starting port # to poll
	MOVZBL	G^SCS$GB_PAMXPORT,R5	; Get maximum port #
	MOVZBL	PDT$B_MAX_PORT(R4),R0	; Get max port supported by CI
	CMPL	R5,R0			; SYSGENed max greater than hardware?
	BLEQ	7$			; Branch if not
	MOVL	R0,R5			; Else hardware max prevails

7$:	MOVZBL	PDT$B_REQIDPS(R4),R7	; Get value of path to select

LB_CHECK:

	MOVB	PDT$B_P0_LBSTS-1(R4)[R7],R0  ; Get LB status byte for
					     ;  current path.  
	BICL3	#^C<PDT$M_CUR_LBS>,R0,R1     ; Isolate current status in R1
	BNEQ	10$			; Branch if current status is good.
	BITB	#PDT$M_PRV_LBS, R0	; Was previous status bad?
	BEQL	10$			; Branch if it was bad.
	CLRL	R2			; Indicate no packet present.
	ASSUME	PAER$K_ES_L1GB EQ <PAER$K_ES_L0GB + 1>
	ADDL3	#<PAER$K_ES_L0GB-1>, R7, R0 ; Form error subtype code.
	BSBW	ELOG$CABLES		; Log error via general cables state
					; change logger.

10$:	ADDL3	R1,R1,R3		; Position current status as
					;  previous and save
	BBS	#PDT$V_LBDG,-		; Branch if loopback dg's currently
		PDT$W_LPORT_STS(R4),-	;  enabled
		SEND_LB			;
	BISB3	#PDT$M_CUR_LBS, R3, -	; Otherwise, loopback datagrams are
		PDT$B_P0_LBSTS-1(R4)[R7];  not needed; pretend they were 
	BRB	START_REQID		;  successful and go do request id's.

SEND_LB:

	BSBW	INT$ALLOC_DG1		; Get a dg buffer for the 
					;  loopback dg
	BLBC	R0,20$			; Branch if no pool -- skip
					;  poller altogether
	MOVB	R3,PDT$B_P0_LBSTS-1(R4)[R7]  ; Else update LB status
					     ;  with current and set 
					     ;  current to pending
	PUSHR	#^M<R2,R3,R4,R5>	; Save registers
	MOVL	PDT$L_LBDG(R4),R0	; Get addr of LB dg template
	MOVC3	#<PPD$C_LB_LENGTH-PPD$B_PORT>,-
		PPD$B_PORT(R0),-	; Copy LB dg from tmplate
		PPD$B_PORT(R2)		;  to actual dg buffer
	POPR	#^M<R2,R3,R4,R5>	; Restore registers
	INSV	R7,#PPD$V_PS,-		; Insert current path
		#PPD$S_PS,PPD$B_FLAGS(R2)    ;  select in LB dg
	BSBW	INT$INS_COMQL		; Send loopback dg on its way

START_REQID:

	MOVZBL	G^SCS$GB_PANPOLL,R3	; Init count of # ports to poll this 
					;  cycle

NEXT_REQID:

	BBC	R6,PDT$B_DQIMAP(R4),40$	; Branch if dg rec'v enabled on
					;  this port
	BSBW	INT$ALLOC_PPDDG		; Else get a dg for SETCKT
	BLBS	R0,30$			; Branch if got it.

20$:	BRW	CONFIG_EXIT		; Else skip polling altogether

30$:	BISL3	#<PPD$M_RSP@24>!-	; Else command port to
		 <PPD$C_SETCKT@16>,-	;  enable dg reception
		R6,PPD$B_PORT(R2)	;  from specified remote port
	CLRL	PPD$W_M_VAL(R2)		; SETCKT
	MOVZWL	#PPD$M_DQI,PPD$W_MASK(R2)
	BBCC	R6,PDT$B_DQIMAP(R4),35$	; Clear DG inhibit
35$:	BSBW	INT$INS_COMQL		; Send it on its way
40$:	BSBW	INT$ALLOC_PPDDG		; Allocate a buffer from pool
	BLBC	R0,CONFIG_EXIT		; Branch if none available
	ASHL	#<PPD$V_PS+24>,R7,R0	; Use current path
	BISL	#<PPD$M_RSP@24>!-	; Send REQID to next port
		 <PPD$C_REQID@16>,R0	; REQID
	BISL3	R0,R6,PPD$B_PORT(R2)	;
	CLRQ	PPD$Q_XCT_ID(R2)	; Set transaction id = 0
	BSBW	INT$INS_COMQL		; Send it on its way
	INCL	R6			; Step to next port
	CMPL	R6,R5			; Past max legal port #?
	BGTRU	60$			; Branch if so
	SOBGTR	R3,50$			; Branch if more ports to poll
	MOVB	R6,PDT$B_NXT_PORT(R4)	; Else save # of next port to
					;  probe on next poll interval and
	BRB	CONFIG_EXIT		;  return.

50$:	BRW	NEXT_REQID		; Go poll next port

60$:	CLRB	PDT$B_NXT_PORT(R4)	; Zero # of next port to probe
					;  next poll interval
	INCL	R7			; Step to next path to use
	CMPL	R7,#PPD$C_PSP1		; More than max legal?
	BLEQ	70$			; Branch if not
	MOVB	#PPD$C_PSP0,R7		; Else reset to path A
	
70$:	MOVB	R7,PDT$B_REQIDPS(R4)	; Put next path to use in PDT

CONFIG_EXIT:

	POPR	#^M<R3,R5,R6,R7>	; Restore registers
	RSB				; Return

	.DSABL	LSB

	.SBTTL	CNF$IDREC, PROCESS UNSOLICITED IDREC

;+
; CNF$IDREC is called from IDREC for IDREC's with transaction 
; ID = 0.  CNF$IDREC checks the port bitmap to see if the IDREC
; is from a path already established or with START handshake in
; progress.  If not, and if the remote port is enabled, then
;  a formative path block is set up and a START handshake initiated.
;
; If the PB does exist, then go to UPDATE_CBL_STS.  UPDATE_CBL_STS
; checks if the path is fully open.  If not, no cable or path status
; information is maintained, and the IDREC is simply discarded.  If
; the path is open, and the remote port is in a state other than enabled,
; then the virtual circuit is crashed.  If the remote port is enabled,
; then cabling status is recorded in the path block as follows:
;
;	current cable status = 1 (OK) if the send path =
;			       receive path in IDREC;
;
;			     = 0 (bad) otherwise.
;
; If the new current status differs from the previous, then a cable status
; transition is logged.
;
; The arrival of the IDREC says that the receive path of the ID must
; be good.  Therefore, the path status in the PB is also updated as follows:
;
;	current path status  = 1 (OK).
;
; If the current path status differs from the previous, then a path status
; transition is logged.
;
; Inputs:
;
; 	R2			-Addr of IDREC datagram
;	R4			-Addr of PDT
;
; Outputs:
;
;	R0-R2			-Destroyed
;	other registers		-Preserved
;-

;
; Assumptions about PB format:
;

ASSUME	PB$W_SIZE+2	EQ  PB$B_TYPE
ASSUME	PB$B_TYPE+1	EQ  PB$B_SUBTYP
ASSUME	PB$B_SUBTYP+1	EQ  PB$B_RSTATION
ASSUME	PB$B_RSTATION+6	EQ  PB$W_STATE
ASSUME	PB$W_STATE+2	EQ  PB$L_RPORT_TYP
ASSUME	PB$L_RPORT_TYP+4   EQ  PB$L_RPORT_REV
ASSUME	PB$L_RPORT_REV+4   EQ  PB$L_RPORT_FCN
ASSUME	PB$L_RPORT_FCN+4   EQ  PB$B_RST_PORT
ASSUME	PB$B_RST_PORT+1	EQ  PB$B_RSTATE
ASSUME	PB$B_RSTATE+1	EQ  PB$W_RETRY
ASSUME	PB$W_RETRY+2	EQ  PB$T_LPORT_NAME
ASSUME	PB$T_LPORT_NAME+4  EQ  PB$B_CBL_STS
ASSUME	PB$B_CBL_STS+1	EQ  PB$B_P0_STS
ASSUME	PB$B_P0_STS+1	EQ  PB$B_P1_STS
ASSUME	PB$B_P1_STS+2	EQ  PB$L_PDT
ASSUME	PB$L_PDT+4	EQ  PB$L_SBLINK
ASSUME	PB$L_SBLINK+4	EQ  PB$L_CDTLST
ASSUME	PB$L_CDTLST+4	EQ  PB$L_WAITQFL
ASSUME	PB$L_WAITQFL+4	EQ  PB$L_WAITQBL
ASSUME	PB$L_WAITQBL	EQ  PB$L_DUETIME
ASSUME	PB$L_DUETIME+4	EQ  PB$L_SCSMSG
ASSUME	PB$L_SCSMSG+4	EQ  PB$W_STS
ASSUME	PB$W_STS+2	EQ  PB$W_VCFAIL_RSN

	.ENABL	LSB

CNF$IDREC::
	
	MOVZBL	PPD$B_PORT(R2),R1	; Get sender port #
	BBC	R1,PDT$B_PORTMAP(R4),-	; Branch if this path is
		NEW_PATH		;  currently unknown
	BRW	UPDATE_CBL_STS		; Go update cabling status info

NEW_PATH:

	CMPB	R1,PDT$B_PORT_NUM(R4)	; Is this ID from self
	BNEQ	5$			; Branch if not
	BSBW	CHECK_PORT_REV		; Else got check port rev level

5$:	EXTZV	#PPD$V_STATE,-		; Get state of remote
		#PPD$S_STATE,-		;  port from ID
		PPD$B_RSTATE(R2),R0	; 
	CMPB	R0,#PPD$C_ENAB		; Is remote enabled or enab maint?
	BEQL	10$			; Branch if yes
	BRW	NEW_PATH_ERR		; Else dont try for start handshake

10$:	PUSHL	R2			; Save copy of IDREC dg addr
	MOVL	#PB$C_PALENGTH,R1	; Get size of a pathblock
	JSB	G^EXE$ALONONPAGED	; Allocate one from pool
	BLBS	R0,15$			; Branch if got pool
	POPL	R2			; Else restore saved register
	BRW	NEW_PATH_ERR		;  and clean up before exit

15$:	MOVL	R2,R3			; Set PB addr in standard register
	POPL	R2			; Retreive IDREC dg addr
	MOVAL	PB$W_SIZE(R3),R0	; Get addr within PB of struct size
	MOVW	R1,(R0)+		; Set structure size
	MOVW	#DYN$C_SCS+<DYN$C_SCS_PB@8>,(R0)+  ; Set struct type, subtype
	MOVZBL	PPD$B_PORT(R2),R1	; Get remote port #
	BBCS	R1,PDT$B_PORTMAP(R4),20$  ; Mark port has PB in map

20$:	INCW	PDT$W_STDGUSED(R4)	; Step # dgs needed for IDRECs
	CMPW	PDT$W_STDGUSED(R4),-	; Compare # dgs needed with # queued now
		PDT$W_STDGDYN(R4)	;  
	BLSSU	22$			; Branch if enough for now
	PUSHR	#^M<R0,R1,R2>		; Else save our registers and
	MOVZBL	#2,R0			;  queue 1 dg for IDRECs + 1 dg
	BSBW	SCS$ALL_FRDGS		;  for HSC error logging
	BLBC	R0,21$			; Branch if didn't get buffers
	INCW	PDT$W_STDGDYN(R4)	; Show 1 more dg available for IDRECs

21$:	POPR	#^M<R0,R1,R2>		; Restore registers

22$:	CMPB	R1,PDT$B_PORT_NUM(R4)	; ID from self?
	BEQL	25$			; Branch if so
	BICW	#PDT$M_LBDG,-		; Else disable LB dg's because
		PDT$W_LPORT_STS(R4)	;  we can contact somebody else

25$:	MOVZBL	PPD$B_PORT(R2),(R0)+	; Set PB parameters:  remote station,
	CLRW	(R0)+			;
	MOVW	#PB$C_CLOSED,(R0)+	;  state = closed,
	MOVQ	PPD$L_RPORT_TYP(R2),(R0)+  ;  port type, dual path bit,
					   ;  and ucode revision,
	MOVL	PPD$L_RPORT_FCN(R2),(R0)+  ;  port function mask,
	MOVZWL	PPD$B_RST_PORT(R2),(R0)+   ;  reset port (owning port),
					   ;  and remote port state,
					   ;  zero retry count,
	MOVL	PDT$L_UCB0(R4),R1	; Trace back through
	MOVL	UCB$L_DDB(R1),R1	;  the UCB and DDB to device
	MOVL	DDB$T_NAME+1(R1),(R0)+	;  name, assumed to be format 'PAc0'
	MOVB	#^A/0/,-1(R0)		; Fix unit to be ascii 0 instead of binary
	MOVB	#PB$M_CUR_CBL,(R0)+	; Set current cable status ok --
					;  will update later when PB is	
					;  fully open
	MOVB	#PB$M_CUR_PS,(R0)+	; Set current path status good,
	MOVZBW	#PB$M_CUR_PS,(R0)+	;  both paths
	MOVL	R4,(R0)+		; Fill in addr of PDT
	CLRQ	(R0)+			; Zero SB link and CDT list pointer
	CLRQ	(R0)+			; Clear formative SB link
					;  and due time
	CLRL	(R0)+			; Clear SCS msg addr
	CLRL	(R0)+			; Zero handshake status and VC 
					;  fail reason
	CLRL	PB$L_CLSCKT_DG(R3)	; Zero addr of emergency SETCKT dg
	INSQUE	(R3),@PDT$Q_FORMPB+4(R4); Link PB to formative PB list
	MOVZWL	#EV$C_SEND_START,R1	; Set event=send a start
	BRW	ACTION_DISP		; Init START handshake

GOT_PATH:
NEW_PATH_ERR:

	BRW	INT$INS_DFREEQ1		; Return dg to free queue and return

UPDATE_CBL_STS:

	BSBW	CNF$LKP_PB_MSG		; Look up path block
	BLBC	R0,GOT_PATH		; Branch if only formative
	MOVL	R1,R3			; Copy PB addr to standard register
	EXTZV	#PPD$V_STATE,-		; Get remote port state
		#PPD$S_STATE,-		;  from ID
		PPD$B_RSTATE(R2),R0	;
	CMPB	R0,#PPD$C_ENAB		; Is remote enabled or maint enab?
	BEQL	30$			; Branch if so
	BSBW	ERR$CRASHVC		; Else go crash VC
	BRB	GOT_PATH		; Go return dg to free queue

30$:	CLRL	R1			; Set assumed new path status = bad
	EXTZV	#PPD$V_RP,#PPD$S_RP,-	; Isolate rec'v path in R0
		PPD$B_FLAGS(R2),R0	;
	PUSHL	R0			; Save rec'v path for later
	CMPZV	#PPD$V_SP,#PPD$S_SP,-	; Send path =
		PPD$B_FLAGS(R2),R0	;  receive path?
	BNEQ	40$			; Branch if not -- paths are crossed
	INCL	R1			; Else set new cable status ok

40$:	CMPZV	#PB$V_CUR_CBL,#1,-	; Previous status
		PB$B_CBL_STS(R3),R1	;  = new status?
	BEQL	50$			; Branch if so
	BSBW	ELOG$CBL_X_CHG		; Else, log change in cables crossed -
					; uncrossed status.

50$:	INSV	R1,#PB$V_CUR_CBL,#1,-	; Record new status 
		PB$B_CBL_STS(R3)	;  as the current status
	POPL	R0			; Retreive receive path number
	BEQL	GOT_PATH		 ; Branch if internal loopback
	MOVAB	PB$B_P0_STS-1(R3)[R0],R0  ; Get addr of path status byte
	BLBS	(R0),60$		  ; Branch if previous status ok
	MOVL	R3, R1			; Else, copy PB addr. to required place
	BSBW	ELOG$PTH_ST_CHG		; and log presence of new good path.

60$:	BISB	#PB$M_CUR_PS,(R0)	; Set current status good
	BRB	GOT_PATH		; Clean up IDREC dg and return

	.DSABL	LSB

	.SBTTL	CNF$SCSMSG_REC,	SCS MSG REC'D

;+
; Since the final ACK or STACK may be lost in the start handshake,
; the arrival of an SCS CONNECT request message from the remote
; system should be treated as a satisfactory substitute for receiving
; a final ACK  or STACK.  CNF$SCSMSG_REC is called by PASCSCTL upon
; receipt of every connect request to handle the transition of a 
; formative path block, if necessary, to the fully open state.
;
; Inputs:
;
;	R2			-Addr of SCS message (start of application
;				 data)
;	R4			-Addr of PDT
;
; Outputs:
;
;	R0,R1,R3		-Destroyed
;	Other registers		-Preserved
;-

	.ENABL	LSB

CNF$SCSMSG_REC::

	PUSHL	R2			; Save SCS msg addr
	MOVAQ	PDT$Q_FORMPB(R4),R3	; Get list of formative PB's
	SUBL3	PDT$L_MSGHDRSZ(R4),R2,R1; Back up to start of pkt
	MOVZBL	PPD$B_PORT(R1),R1	; Get # of port that sent SCS msg
	BSBW	SEARCH_PATHS		; See if this path is formative
	BLBS	R0,TRY_TRANSIT		; Branch if got formative PB
	BBS	R1,PDT$B_PORTMAP(R4),-	; Branch if not formative, but is
		10$			;  known (must be open) 
					;  Else path is closed.  Since
					;  we got a sequenced msg, the
					;  port thinks the vc is open
	MOVL	R1,R3			; Save port number
	BSBW	INT$ALLOC_PPDDG		; Allocate PPD dg
	BLBC	R0,10$			; Branch if no pool
	BISL3	#<PPD$M_RSP@24>!-	; Format PPD dg into a SETCKT
		<PPD$C_SETCKT@16>,-	;
		R3,-			;  to port specified in R3
		PPD$B_PORT(R2)		;
	MOVZWL	#<PPD$M_CST>,-		;
		PPD$W_MASK(R2)		;
	CLRL	PPD$W_M_VAL(R2)		;  and ask for vc state to be closed
	BSBW	INT$INS_COMQH		; Do SETCKT at high priority
	BRB	10$			; Go to finish up

TRY_TRANSIT:

	MOVZWL	#EV$C_SCSMSG,R1		; Else set event code 
	BSBW	ACTION_DISP		; Take action to move PB from
					;  formative to fully open
					;  If PB not in right state to
					;  transition to open or if
					;  there is insufficient pool,
					;  or if the system has bad
					;  system name or system ID,
					;  then formative PB and formative
					;  system block are cleaned up
					;  by action routines.
10$:	POPL	R2			; Retreive SCS msg addr
	RSB				; Return to PASCSCTL

	.DSABL	LSB

	.SBTTL	CNF$LBREC,	VERIFY REC'D LOOPBACK DG

;+
; CNF$LBREC checks the data in the received loopback datagram with
; the data stored in the template lb dg linked to the PDT.  If the
; data agrees, then the loopback status for the path on which the LB
; dg was received is updated to good.  (Transitions in the status are
; checked and logged in CNF$POLL.)
;
; Inputs:
;
;	R2			-Addr of loopback datagram
;	R4			-Addr of PDT
;	PDT$L_LBDG(R4)		-Addr of template LB dg
;
; Outputs:
;
;	R0-R2			-Destroyed
;	Other registers		-Preserved
;-

	.ENABL	LSB

CNF$LBREC::

	MOVL	PDT$L_LBDG(R4),R1	; Get addr of template
	MOVQ	R2,-(SP)		; Save registers
	CMPC	#<PPD$L_LBCRC - PPD$W_LENGTH>,-
		PPD$W_LENGTH(R1),-	; Verify rec'd data against template
		PPD$W_LENGTH(R2)	;  including LB dg length
	MOVQ	(SP)+,R2		; Restore registers
	TSTL	R0			; Check results of comparison
	BNEQ	10$			; Branch if don't match
	EXTZV	#PPD$V_PS,#PPD$S_PS,-	; Get path select, 1/2 for A/B
		PPD$B_FLAGS(R2),R0	;  in R0
	BBSS	#PDT$V_CUR_LBS, -	      ; Set loopback datagram received 
		PDT$B_P0_LBSTS-1(R4)[R0], 10$ ; & branch if already got one.
	BITB	#PDT$M_PRV_LBS,-	; Was the previous loopback datagram
		PDT$B_P0_LBSTS-1(R4)[R0];  also successful?
	BNEQ	10$			; Branch if last was successful too
	ASSUME	PAER$K_ES_L1BG EQ <PAER$K_ES_L0BG +1>
	ADDL	#<PAER$K_ES_L0BG-1>,R0	; Form LB dg succesful sybtype code
	BSBW	ELOG$CABLES		; Log cables state change

10$:	BRW	INT$DEAL_DG1		; Deallocate LB dg and return to
					;  interrupt service from there

	.DSABL	LSB

	.SBTTL	CNF$DGREC, DISPATCH A START/STACK/ACK DATAGRAM

;+
; CNF$DGREC first checks the port bit map to see if a path
; block exists for the incoming datagram.  If not, the datagram
; is deallocated.  Otherwise, the formative path block list and 
; system configuration data base are searched for the path block
; with matching station address.  When the path block is found,
; the ACTION_DISP routine is called to handle the datagram. 
;
; Inputs:
;
;	R2			-Addr of datagram
;	R4			-Addr of PDT
;
; Outputs:
;
;	R0-R3			-Destroyed
;	other registers		-Preserved
;-

	.ENABL	LSB

CNF$DGREC::

	MOVZBL	PPD$B_PORT(R2),R1	; Get remote port #
	BBS	R1,PDT$B_PORTMAP(R4),-	; Look PB existence up in
		PB_EXISTS		;  path map; branch if exists
	BRW	INT$INS_DFREEQ1		; Discard datagram and return
					;  from there to interrupt service

PB_EXISTS:

	MOVAL	PDT$Q_FORMPB(R4),R3	; Get formative PB listhead
	BSBW	SEARCH_PATHS		; Search path list for PB
	BLBS	R0,FOUND_PB		; Branch if success

CONFIG_LIST:

	BSBW	CNF$LKP_PB_MSG		; Locate PB in open config database
	BLBC	R0,CONFIG_ERR		; Branch if couldn't find it
	MOVL	R1,R3			; Else copy PB addr to right reg

FOUND_PB:

	MOVZWL	PPD$W_MTYPE(R2),R1	; Set event = rec'd dg type
	BRW	ACTION_DISP		; Transfer to action dispatcher
					;  and return from there

CONFIG_ERR:

	BUGCHECK	CIPORT,NONFATAL	; Inconsistent database

	BRW	INT$INS_DFREEQ1		; If nonfatal, discard dg
					;  and forget it happened

	.DSABL	LSB

	.SBTTL	CNF$STOP_VCS,	SEND STOPS TO ALL VCS

;+
; This routine is called during a bugcheck.  It is used to notify
; other systems to which we have circuits open, that this system is
; shutting down.  Notification is best try only, no guarantees of
; success. 
;
; CNF$STOP_VCS first checks if the PDT is offline.  If so, return
; is taken since the port is not operating.  Otherwise, the port
; map is examined to determine each port which is known.  For each
; known port (except self), a shutdown datagram is sent.  After a hang 
; of an adequate number of milliseconds, the port response queue is
; rummaged for the sent datagram.  If not found, the port is assumed
; to be not opreating and return is taken without further notifications.
; If the sent datagram is found, it is removed from the response queue
; for reuse in the next host shutdown datagram.
;
; Inputs:
;
;	R4			-PDT address
;
; Outputs:
;
;	R0-R3			-Destroyed
;
;	Other registers		-Preserved
;-

;
; Shutdown datagram is assembled into the PDT.  It must not be
; allocated from pool since that is too risky during a bugcheck:
;


	.ENABL	LSB

CNF$STOP_VCS::

	MOVL	PDT$L_UCB0(R4),R0	; Get UCB address
	BBC	#UCB$V_ONLINE,-		; Branch if the port 
		UCB$W_STS(R0),20$	;  is offline
	MOVAL	PDT$Q_TEMP_RSPQ(R4),-	; Init the temorary response
		PDT$Q_TEMP_RSPQ(R4)	;  queue to empty
	MOVAL	PDT$Q_TEMP_RSPQ(R4),-	;
		PDT$Q_TEMP_RSPQ+4(R4)	;
	MOVAL	PDT$B_HSHUT_DG(R4),R2	; Get addr of host shutdown dg
	CLRQ	(R2)			; Zero self relative links to 
					;  show dg not queued anywhere
	MOVL	#<PDT$C_HSHUT_SIZ + <DYN$C_CIDG@16>>,-
		PPD$W_SIZE(R2)		; Set structure size and type just
					;  for completeness
	BSBW	CNF$LKP_PB_PDT		; Look up 1st/next PB on this PDT
	BLBS	R0,FOUND_VC		; Branch if PB found to start of
					;  coroutine processing. Coroutine
					;  called back from CNF$LKP_PB_PDT

20$:	BRW	ALL_STOPPED		; Else no PB found and we are done

FOUND_VC:

	CMPB	PB$B_PROTOCOL(R3),-	; Is remote end of vc speaking a
		#PPD$C_PRT_ELOG		;  high enough rev level to receive
					;  a host shutdown even if he doesn't
					;  act upon it?
	BLSSU	40$			; Branch if not

STOP_NEXT:

	CMPB	PB$B_RSTATION(R3),-	; Is the remote end our
		PDT$B_PORT_NUM(R4)	;  own port number?
	BEQL	40$			; Branch if so and bypass shutdown dg
	MOVAL	PDT$B_HSHUT_DG(R4),R2	; Get addr of host shutdown dg buffer
	TSTL	(R2)			; Is dg still queued somewhere?
	BNEQ	40$			; Branch if so
	MOVZBW	PB$B_RSTATION(R3),-	; Set remote port # and
		PPD$B_PORT(R2)		;  zero status byte
	MOVW	#<PPD$C_SNDDG+<PPD$M_RSP@8>>,- 
		PPD$B_OPC(R2)		; Set opcode and response bit
	MOVL	#<PPD$C_HSHUT_LEN+<PPD$C_HOSTSHUT@16>>,- 
		PPD$W_LENGTH(R2)	; Set PPD length and PPD type code
	BSBW	INT$INS_COMQH		; Send it out
	TIMEWAIT #<2000>,#0,#0,B	; Wait unconditionally for 20 msec
	
SEARCH_RSPQ:
	
	$QRETRY	REMQHI PDT$Q_RSPQ(R4),R0,ERROR=LOCK_UNAVAIL
					; Remove next response pkt from
					;  head of response queue
	BVS	40$			; Branch if no more.
	MOVAL	PDT$B_HSHUT_DG(R4),R2	; Retreive addr of our datagram
	CMPL	R0,R2			; Is it our shutdown datagram?
	BNEQ	60$			; Branch if not
	CLRQ	(R2)			; Else show dg buffer dequeued
					;  from port queue

40$:	RSB				; Return from coroutine call and
					;  go look for next port to send 
					;  shutdown to

60$:	INSQUE	(R0),@PDT$Q_TEMP_RSPQ+4(R4) ; Else save the response on
					;  private queue - may want to
					;  look at it in the dump
	BRB	SEARCH_RSPQ		; Continue searching response queue

LOCK_UNAVAIL:
	
	TSTL	(SP)+			; $QRETRY BSBWs here, so pop return

ALL_STOPPED:

	RSB

	.DSABL	LSB

	.SBTTL	ACTION DISPATCHING
	.SBTTL	-	ACTION TABLE FORMAT

;+
; The ACTION_TABLE is a list of action routines to execute for
; each combination of port-port VC state and event.  The format
; of the table is a list of VC state entries.  Each state entry
; is followed by a list of events possible for that state.  Each
; event entry is followed by a list of actions to be taken for
; the event.  The table is arranged linearly.
;
; The various entries are generated by the macros STATE, EVENT,
; ACTION, and ENDACTION defined in the next section.  Actions
; may return status or not.  For actions which do return status,
; the action dispatcher checks R0 for success/fail status.  In
; case of failure the action disRatcher calls routine CLEANUP
; and terminates action routine execution.
;
; The format of the various types of entry in the action table:
;
;	STATE:		+--------+--------+--------+--------+
;			|offset to nxt st |  state code     |
;			+--------+--------+--------+--------+
;
;	EVENT:		+--------+--------+--------+--------+
;			|offset to nxt evt|  event code     |
;			+--------+--------+--------+--------+
;	
;	ACTION:		+--------+--------+--------+--------+
;			|offset to routine|  arg   |  code  |
;			+--------+--------+--------+--------+
;
; Standard inputs to action routines are:
;
;	R1		-Argument in action table entry
;	R2		-Addr of IDREC/START/STACK/ACK dg, if any
;	R3		-Addr of PB
;	R4		-Addr of PDt
;
; The end action actin type is special:  it moves the argument
; into the PB state word and terminates the list of actions.  End 
; action entries are a single word long.
;-

	.SBTTL	-	ACTION TABLE MACROS
;
; Macro to define a state entry:
;

	.MACRO	STATE	CODE
	 .NOSHOW
	 $$$=.				; Save start of state entry
	 .WORD	CODE			; State code
	 .IF DF $$$LAST_STATE		; If there was a previous
	 .=$$$LAST_STATE+ST$W_NEXT	;  state entry, go back and
	 .WORD	$$$-$$$LAST_STATE	;  file in its fwd link
	 .=$$$+ST$W_NEXT		;  and reset pointer to this entry
	 .ENDC				;
	 .WORD	0			; Allocate word for fwd link
	 $$$LAST_STATE=$$$		; Define start of this entry
	 $$$LAST_EVENT=0		; Reset addr of last event to
					;  show start of new list of events
	 .SHOW
	.ENDM	STATE

;
; Macro to define event entry:
;

	.MACRO	EVENT	CODE
	 .NOSHOW
	 $$$=.				; Save start of entry
	 .WORD	CODE			; Event code
	 .IF NE $$$LAST_EVENT		; If there was a previous event,
	 .=$$$LAST_EVENT+EV$W_NEXT	;  then go back to it and
	 .WORD	$$$-$$$LAST_EVENT	;  fill in its fwd link
	 .=$$$+EV$W_NEXT		;  and return to current entry
	 .ENDC				;
	 .WORD	0			; Allocate word for fwd link
	 $$$LAST_EVENT=$$$		; Define addr of this entry
	 .SHOW
	.ENDM	EVENT

;
; Macro to define action entry:
;

	.MACRO	ACTION ROUTINE,FLAG=0,ARG=0,CODE=AC$C_CONTINUE
	 .NOSHOW
	 $$$=.				; Save start of entry
	 .BYTE	CODE!FLAG		; Action type code
	 .BYTE	ARG			; Argument
	 .WORD	ROUTINE-$$$		; Offset to action routine
	 .SHOW
	.ENDM	ACTION			

;
; Macro to define an endaction entry:
;

	.MACRO	ENDACTION NEWSTATE
	 .NOSHOW
	 .BYTE	AC$C_END		; Action type code
	 .WORD	NEWSTATE		; Action arg =  new PB state
	 .SHOW
	.ENDM	ENDACTION

	.SBTTL	-	ACTION TABLE OFFSETS AND DEFINITIONS

;
; Offsets to state, event and action entries in the action
; dispatch table:
;

ST$W_CODE = 0			; State code (codes defined in $PBDEF)
ST$W_NEXT = 2			; Offset to next state entry

EV$W_CODE = 0			; Event code
EV$W_NEXT = 2			; Offset to next event entry

AC$B_CODE = 0			; Action code
AC$B_ARG = 1			; Action routine argument
AC$W_NEWST = 1			; New path blk state on end action
AC$W_ACTION = 2			; Offset to action routine

;
; Event code definitions:
;

				; Following codes (sign bit clear) assumed equal
				;  to the corresponding PPD msg types:
EV$C_START = 0			;  START dg received
EV$C_STACK = 1			;  STACK dg reveived
EV$C_ACK = 2 			;  ACK dg received
EV$C_ELOG = 5			;  Error log dg received
EV$C_HOSTSHUT = 6		;  Host shutdown dg received
				; The following codes are assumed to have
				;  no definition as PPD types that we
				;  will ever receive (needs to be in
				;  architecture that sign bit set codes
				;  are reserved.)
EV$C_SCSMSG = ^X8000		; SCS control msg received (connx
				;  management or credit)
EV$C_TIMEOUT = ^X8001		; Path timer expired
EV$C_SEND_START = ^X8002	; Send 1st START, initiate handshake

;
; Action code definitions:
;

AC$C_END = 0			; No more action routines, update PB state
AC$C_CONTINUE = 1		; More action routines.
STATUS = ^X80			; If set, action routine returns status

	.SBTTL	-	ACTION TABLE


ACTION_TABLE::

	STATE	PB$C_CLOSED			; New PB just created
	  
	  EVENT	EV$C_SEND_START			; Initiate START handshake
	    ACTION	SEND_1ST_START		; Send 1st START dg
	    ACTION	START_TIMER		; Enable timer
	    ENDACTION	PB$C_ST_SENT		; State moves to start sent

	  EVENT EV$C_ELOG			; Error log dg received
	    ACTION	REC_ERROR_DG		; Go log it
	    ENDACTION	PB$C_CLOSED		; State unchanged

	STATE	PB$C_ST_SENT			; State= start sent
	
	  EVENT		EV$C_STACK		; Received STACK dg
	    ACTION	STOP_TIMER		; Disable timer
	    ACTION	BUILD_SB,STATUS		; Build a formative SB
	    ACTION	SET_CIRCUIT,STATUS	; Tell port to open VC
	    ACTION	ENTER_PB,STATUS		; Move PB to system database
	    ACTION	SEND_ACK		; Send ACK
	    ENDACTION	PB$C_OPEN		; Move PB state to open

	  EVENT		EV$C_START		; Received START dg
	    ACTION	BUILD_SB,STATUS		; Build formative SB
	    ACTION	SET_CIRCUIT,STATUS	; Tell port to open VC
	    ACTION	SEND_1ST_STACK		; Send STACK dg
	    ACTION	START_TIMER		; Start a timer
	    ENDACTION	PB$C_ST_REC		; Move PB state to start rec'd

	  EVENT		EV$C_TIMEOUT		; Timer expired
	    ACTION	SEND_START,STATUS	; Retry send of START dg
	    ACTION	START_TIMER		; Restart timer
	    ENDACTION	PB$C_ST_SENT		; PB state stays start sent

	  EVENT		EV$C_ELOG		; Error log dg received
	    ACTION	REC_ERROR_DG		; Go log it
	    ENDACTION	PB$C_ST_SENT		; State unchanged

	STATE		PB$C_ST_REC		; State is start rec'd

	  EVENT		EV$C_ACK		; Rec'd ACK dg
	    ACTION	IGNORE_DG		; Return dg to DFREEQ
	    ACTION	STOP_TIMER		; Disable timer
	    ACTION	ENTER_PB,STATUS		; Move PB to system database
	    ENDACTION	PB$C_OPEN		; Move PB state to open

	  EVENT		EV$C_SCSMSG		; Rec'd SCS control msg
	    ACTION	STOP_TIMER		; Stop timer
	    ACTION 	ENTER_PB,STATUS		; Move PB to system database
	    ENDACTION	PB$C_OPEN		; Move PB state to open

	  EVENT		EV$C_STACK		; Rec'd STACK dg
	    ACTION	STOP_TIMER		; Disable timer	
	    ACTION	UPDATE_SWINCARN		; Copy new incarn # to SB
	    ACTION	ENTER_PB,STATUS		; Move PB to system database
	    ACTION	SEND_ACK		; Send ACK dg
	    ENDACTION	PB$C_OPEN		; Move PB state to open

	  EVENT		EV$C_START		; Rec'd START dg
	    ACTION	UPDATE_SWINCARN		; Copy new incarn # to SB
	    ACTION	SEND_1ST_STACK		; Send STACK dg
	    ACTION	START_TIMER		; Start timer
	    ENDACTION	PB$C_ST_REC		; PB state stays same

	  EVENT		EV$C_TIMEOUT		; Timer expired
	    ACTION	SEND_STACK,STATUS	; Try another STACK dg
	    ACTION	START_TIMER		; Start up the timer again
	    ENDACTION	PB$C_ST_REC		; PB state stays same

	  EVENT		EV$C_ELOG		; Error log dg received
	    ACTION	REC_ERROR_DG		; Go log it
	    ENDACTION	PB$C_ST_REC		; State unchanged

	STATE		PB$C_OPEN		; Path state is open

	  EVENT		EV$C_STACK		; Rec'd STACK dg
	    ACTION	SEND_ACK		; Send ACK dg
	    ENDACTION	PB$C_OPEN		; Leave PB state open


	  EVENT		EV$C_ACK		; Rec'd ACK dg
	    ACTION	IGNORE_DG		; Return dg to DFREEQ
	    ENDACTION	PB$C_OPEN		; Leave PB state open

	  EVENT		EV$C_START		; Rec'd START dg on open VC
	    ACTION	BREAK_PATH		; Collapse path 
	    ENDACTION	PB$C_VC_FAIL		;  leaving PB state as set
						;  by BREAK_PATH

	  EVENT		EV$C_ELOG		; Error log dg received
	    ACTION	REC_ERROR_DG		; Go log it
	    ENDACTION	PB$C_OPEN		; State unchanged

	  EVENT		EV$C_HOSTSHUT		; Host shutdown received
	    ACTION	BREAK_HOST		; Go close VC with special status
	    ENDACTION	PB$C_VC_FAIL		; State is vc fail

	STATE		PB$C_VC_FAIL		; VC failure in progress
	
	  EVENT		EV$C_START		; Rec'd START dg
	    ACTION	IGNORE_DG		; Discard without action
	    ENDACTION	PB$C_VC_FAIL		;

	  EVENT		EV$C_STACK		; Rec'd STACK dg
	    ACTION	IGNORE_DG		; Discard without action
	    ENDACTION	PB$C_VC_FAIL		;

	  EVENT		EV$C_ACK		; Rec'd ACK dg
	    ACTION	IGNORE_DG		; Discard without action
	    ENDACTION	PB$C_VC_FAIL		;

	  EVENT		EV$C_ELOG		; Error log dg received
	    ACTION	REC_ERROR_DG		; Go log it
	    ENDACTION	PB$C_VC_FAIL		; State unchanged


	.SBTTL	-	ACTION_DISP, ACTION DISPATCHER

;+
; The action dispatcher looks up in the action table the list of
; action routines to execute for the current path block state and
; the event that occurred.  If an action routine specifies that it
; returns status, the R0 is checked upon return for success (LBS)
; or failure (LBC).  On failure the cleanup routine, CLEANUP, is called 
; and ACTION_DISP exits.  Normally, action routines are executed 
; until an end action routine is encountered.  The end action automatically
; sets the path block state to the value specified in the end action
; argument.
;
; The following register conventions apply for action routines:
;
;	R2		-Addr of START/STACK/ACK/IDREC dg, if any
;	R3		-Addr of formative PB
;	R4		-Addr of PDT
;	R5		-Addr of current action entry
;
; Actions may use R0 and R1, but must use R2 with care.  Action
; routines must preserve all other registers.
;
; Inputs to ACTION_DISP:
;
;	R1			-Event code
;	R2-R4			-As shown above
;
; Outputs:
;
;	R0-R2 			-Destroyed
;	other registers		-Preserved
;-

ASSUME	EV$C_START	EQ  0		; Assume that events START and
ASSUME	EV$C_STACK	EQ  1		;  STACK are .LE. 1
ASSUME	EV$C_ACK	EQ  2		; Assume that events associated with
					;  rec'd dgs are .LE. 2

ASSUME	PB$C_CLOSED	EQ  0		; Assume that all the 
ASSUME	PB$C_ST_SENT	EQ  1		;  formative path block states
ASSUME	PB$C_ST_REC	EQ  2		;  are .LE. 2

	.ENABL	LSB

ACTION_DISP:

	PUSHL	R5			; Save a register
	PUSHL	R1			; Save event code
	MOVAL	ACTION_TABLE,R5		; Get addr of action table

NEXT_STATE:

	MOVW	ST$W_CODE(R5),R0	; Get next state code
	CMPW	R0,PB$W_STATE(R3)	; State codes match?
	BEQL	LOOKUP_EVENT		; Branch if so
	CVTWL	ST$W_NEXT(R5),R0	; Get offset to next state
	BEQL	PB_STATE_ERR		; Branch if no more states
	ADDL	R0,R5			; Else step to nxt state entry
	BRB	NEXT_STATE		;  and try it

LOOKUP_EVENT:

	TSTL	(R5)+			; Step to start of event list

NEXT_EVENT:

	CMPW	EV$W_CODE(R5),R1	; Event codes match?
	BEQL	NEXT_ACTION		; Branch if yes
	CVTWL	EV$W_NEXT(R5),R0	; Get offset to next event
	BEQL	PB_STATE_ERR		; Branch if no more events
	ADDL	R0,R5			; Else step to next event entry
	BRB	NEXT_EVENT		;  and try it

NEXT_ACTION:

	TSTL	(R5)+			; Step to 1st/next action entry
	TSTB	(R5)			; end of action routines?
	BEQL	END_ACTION		; Branch if so
	MOVZBL	AC$B_ARG(R5),R1		; Pick up argument
	CVTWL	AC$W_ACTION(R5),R0	; Get offset to routine
	JSB	(R5)[R0]		; Call action routine
	TSTB	(R5)			; Does routine return status?
	BGTR	NEXT_ACTION		; Branch if not
	BLBS	R0,NEXT_ACTION		; Branch if status good
	POPL	R1			; Retreive event code
	CMPL	R1,#EV$C_STACK		; Is it rec'd START or STACK dg?
	BGTR	10$			; Branch if not
	BSBW	INT$INS_DFREEQ1		; Else must return rec'd dg to 
					;  free queue to prevent depletion

10$:	POPL	R5			; Restore R5
	BRW	CLEANUP			; Else xfer to PB/SB cleanup and
					;  return from there

END_ACTION:

	MOVW	AC$W_NEWST(R5),-	; Update state of path block
		PB$W_STATE(R3)		;
	POPL	R1			; Clear event type code from stack

20$:	POPL	R5			; Restore R5
	RSB				; Return

PB_STATE_ERR:

	POPL	R1			; Retreive event code
	TSTL	R1			; Indicate that dg is held?
	BLSS	30$			; Branch if not
	BSBW	INT$INS_DFREEQ1		; Else return PPD handshake dg
					;  to free queue

30$:	CMPW	PB$W_STATE(R3),-	; Is path state in formative
		#PB$C_ST_REC		;  state?
	BLEQU	10$			; Branch if so to delete PB and
					;  abandon start attempt 
	BRB	20$			; Else ignore, join common exit

	.DSABL	LSB

	.SBTTL	ACTION ROUTINES
	.SBTTL	-	SEND_1ST_START, SEND 1ST START DG
	.SBTTL	-	SEND_START, SEND A START DATAGRAM

;+
; SEND_START allocates a dtagram buffer from nonpaged pool,
; formats a START message in it and sends the datagram.  The data
; that goes into the START message is assembled into the message
; by routine FMT_START_DATA.
;
; SEND_START has two entries:  SEND_1ST_START which resets the START
; retry count and SEND_START which decrements and checks the retry
; count before sending the datagram.
;
; The retries must continue until the target remote port is polled
; again.  This time depends on the interval between poller wakeups,
; the number of ports being polled at each poller wakeup, the total
; number of ports to be polled, and the time between retries
; (SCS$GW_PASTMOUT) as follows:
;
;	# retries = (SCS$GB_PAMXPORT * SCS$GW_PAPOLINT) /
;			(SCS$GB_PANPOLL * SCS$GW_PASTMOUT)
;
; The retry count is computed each time it's set since the dependent
; variables are dynamic SYSGEN parameters.
;
; SEND_START may fail for two reasons:  insufficient pool to
; allocate the datagram buffer, or retry count exceeded.
;
; Inputs:
;
;	R2			-Addr of datagram to turn around (1ST_START)
;	R3			-Addr of PB
;	R4			-Addr of PDT
;
; Outputs:
;
;	R0			-0/1 for fail/success (SEND_START only)
;	R1,R2			-Destroyed
;	other registers		-Preserved
;-

;
; PPD message format assumption:
;

ASSUME	PPD$W_LENGTH+2	EQ PPD$W_MTYPE

	.ENABL	LSB

SEND_1ST_START:

	MOVL	#<PPD$C_START@16 + PPD$C_START_LEN>,-
		PPD$W_LENGTH(R2)	; Set dg size and type
	BRB	COM_SEND_1		; Go do it

SEND_START:

	DECW	PB$W_RETRY(R3)		; Decrement retry count
	BEQL	SEND_ERR		; Branch if no retries left
	BSBW	INT$ALLOC_DG1		; Allocate buffer from pool
	BLBC	R0,SEND_ERR		; Branch if no pool

10$:	BSBW	FMT_START_DATA		; Set up start data
	MOVL	#<PPD$C_START@16 + PPD$C_START_LEN>,-
		PPD$W_LENGTH(R2)	; Set dg size and type
	BSBW	SNDDG_RET		; Send dg with RETFLAG=TRUE
					;  to channel dg to response
					;  queue for return to pool

SEND_SUCCESS:

	MOVZBL	#SS$_NORMAL,R0		; Status is success
	RSB				; Return

SEND_ERR:

	CLRL	R0			; Set status = fail
	RSB				;

	.DSABL	LSB

	.SBTTL	-	SEND_STACK, SEND A STACK DATAGRAM

;+
; This routine has two entries:  
;
; SEND_1ST_STACK resets the retry count for sending STACK's and
; recycles the received START datagram into a STACK message. 
; See SEND_1ST_START comments regarding calculation of the
; retry count.   This entry always completes with success.
;
; SEND_STACK is called when the timer expires and a retry is
; necessary.  It decrements and checks the retry count.  If more retries
; remain, it allocates a datagram buffer from pool.  This entry can
; fail due to expired retry count or insufficient pool.
;
; Both entries wind up by formatting and sending a STACK datagram.
;
; Inputs:
;
;	R2			-Addr of rec'd datagram (if 1ST_STACK)
;	R3			-Addr of PB
;	R4			-Addr of PDT
;
; Outputs:
;
;	R0			-0/1 for fail/success
;	R1,R2			-Destroyed
;	other registers		-Preserved
;-

;
; PPD message format assumption:
;


	.ENABL	LSB

SEND_1ST_STACK:

	MOVL	#<PPD$C_STACK@16 + PPD$C_STACK_LEN>,-
		PPD$W_LENGTH(R2)	; Set dg size and type

COM_SEND_1:

	MOVZBL	G^SCS$GB_PAMXPORT,R0	; Get maximum number of ports
	MULW2	G^SCS$GW_PAPOLINT,R0	; Compute maximum port #
					;  * poller interval
	MOVZBL	G^SCS$GB_PANPOLL,R1	; Get # ports to poll per interval
	MULW2	G^SCS$GW_PASTMOUT,R1	; Compute # ports to poll per
					;  interval * start timeout
	DIVL3	R1,R0,R0		; Divide, increment in case of
	ADDW3	#1,R0,PB$W_RETRY(R3)	;  remainder, and save retry count
	BSBW	FMT_START_DATA		; Set up start data
	BSBW	SNDDG_NORET		; Send dg with RETFLAG=FALSE
					;  to channel dg buffer back to
					;  free queue
	BRB	SEND_SUCCESS		; Take success exit

SEND_STACK:

	DECW	PB$W_RETRY(R3)		; Decrement retry counter
	BEQL	SEND_ERR		; Branch if no retries left
	BSBW	INT$ALLOC_DG1		; Allocate dg buffer
	BLBC	R0,SEND_ERR		; Branch if no pool
	BSBW	FMT_START_DATA		; Set up start data
	MOVL	#<PPD$C_STACK@16 + PPD$C_STACK_LEN>,-
		PPD$W_LENGTH(R2)	; Set dg size and type
	BSBW	SNDDG_RET		; Send dg with RETFLAG=TRUE
					;  to channel dg to response 
					;  queue when sent
	BRW	SEND_SUCCESS		; Take success exit

	.DSABL	LSB

	.SBTTL	-	SEND_ACK, SEND ACK DATAGRAM

;+
; SEND_ACK turns a previously received STACK datagram into an
; ACK and sends the datagram.  No failures are possible.
;
; Inputs:
;
;	R2			-Addr of dg being turned around
;	R3			-Addr of PB
;	R4			-Addr of PDT
;
; Outputs:
;
;	R0,R1			-Destroyed
;	other registers		-Preserved
;-

;
; PPD message format assumption:
;

ASSUME	PPD$W_LENGTH+2	EQ PPD$W_MTYPE

	.ENABL	LSB

SEND_ACK:

	MOVL	#<PPD$C_ACK@16 + PPD$C_ACK_LEN>,-
		PPD$W_LENGTH(R2)	; Set dg size and type
	BRW	SNDDG_NORET		; Send dg with RETFLAG=FALSE
					;  to channel dg buffer back
					;  free queue.

	.DSABL	LSB

	.SBTTL	-	UPDATE_INCARN,	UPDATE SW INCARN FROM
	.SBTTL	-			2ND START/STACK

;+
; This routine exists primarily for the convenience of the HSC 
; which wants to sent its incarnation to its startup time, but
; does not have a clock.  The HSC uses the first PPD$Q_CURTIME
; it sees in a START/STACK that is nonzero as its start time.
; Until it receives the time from some system in the cluster,
; it conducts start handshakes with a software incarnation number
; of zero.
;
; If VMS receives a START from the HSC before the HSC has set
; its start time, then the received START has an incarnation number
; of zero.  A subsequent START/STACK from the HSC will however have
; a proper incarnation number which is used by this routine to
; revise the formative SB.
;
; Inputs:
;
;	R2			-Addr of START/STACK dg
;	R3			-Addr of formative PB
;	R4			-Addr of PDT
;
; Outputs:
;
;	R0			-Destroyed
;	Other registers		-Preserved
;-

	.ENABL	LSB

UPDATE_SWINCARN:

	MOVL	PB$L_SBLINK(R3),R0	; Get formative SB
	MOVQ	PPD$Q_SWINCARN(R2),-	; Update formative SB with
		SB$Q_SWINCARN(R0)	;  latest SW incarnation #
	RSB				; Return

	.DSABL	LSB

	.SBTTL	-	ENTER_PB, MOVE PB (AND SB) FROM FORMATIVE
	.SBTTL	-		  LISTS TO SYSTEM WIDE DATABASE

;+
; ENTER_PB moves a pathblock and, if necessary, its associated system
; block from the formative pathblock list to the system wide
; configuration database.  In the process, and SCS send message 
; buffer and receive buffer, and SETCKT dg are allocated.  The send
; buffer address is stored in the PB and the receive buffer is queued to
; the port. If the allocation fails, the path block ad system block remain
; on the formative list and error exit is taken.
;
; What happens to the formative system block depends upon the current
; database:
;
;	-If a matching SB does not already exist,
;	 then the formative SB is inserted in the database along 
;	 with its formative PB.
;
;	-If a matching system exists, then check if the
;	 existing SB has any PB's linked to it.  If not, refresh the
;	 old SB with information from the formative SB and link the
;	 formative PB to the refreshed SB.
;
;	-If the existing matching SB has paths to it, check if the 
;	 existing SB and formative SB have the same software incarnation.
;	 If not, then two different systems must be masquarading as the
;	 same system ID and the formative SB and PB are thrown away
;	 (we refuse to talk to the newcomer.)
;
;	 If the incarnation numbers match, then we just add the formative
;	 PB to the existing SB's list of paths and discard the formative 
;	 SB.
;
; A matching system means one that matches in both system ID and node 
; name.  SB's that match in one, but not the other are rejected and no
; vc will be opened to such a system.
;
; Naturally, there is an exception to the rule excluding systems with
; the same node name.  Version 3.x systems with matching node names
; but unique system ID's will be permitted to enter the database.
; This is because 3.x systems all had the same node name (all blanks)
; and their presence will have no effect on the VAXcluster sysap
; in a 4.x system.
;
; Inputs:
;
;	R3			-Addr of formative PB
;	R4			-Addr of PDT
;
; Outputs:
;
;	R0			-0/1 for fail/success
;	R1			-Destroyed
;	other registers		-Preserved
;-

;
; System Block adjacency assumptions:
;

ASSUME	SB$B_SYSTEMID+8 EQ  SB$W_MAXDG
ASSUME	SB$W_MAXDG+2	EQ  SB$W_MAXMSG
ASSUME	SB$W_MAXMSG+2	EQ  SB$T_SWTYPE
ASSUME	SB$T_SWTYPE+4	EQ  SB$T_SWVERS
ASSUME	SB$T_SWVERS+4	EQ  SB$Q_SWINCARN
ASSUME	SB$Q_SWINCARN+8	EQ  SB$T_HWTYPE
ASSUME	SB$T_HWTYPE+4	EQ  SB$B_HWVERS
ASSUME	SB$B_HWVERS+12	EQ  SB$T_NODENAME
ASSUME	SB$T_NODENAME+16 EQ SB$L_DDB

UPDATE_LEN = SB$L_DDB-SB$B_SYSTEMID

	.ENABL	LSB

ENTER_PB:

	PUSHL	R2			; Save R2
	BSBW	INT$ALLOC_MSG		; Allocate a msg buffer
	BLBS	R0,10$			; Branch if got it
	BRW	ENTER_ERR		; Else go to error

10$:	MOVL	R2,PB$L_SCSMSG(R3)	; Assign buffer to PB for SCS 
					;  control messages sent
	BSBW	INT$ALLOC_PPDDG		; Allocate a PPD dg buffer
	BLBS	R0,30$			; Branch if got it
	BRW	ENTER_ERR1		; Else go clean up

30$:	MOVL	R2,PB$L_CLSCKT_DG(R3)	; Save addr of PPD dg
	BSBW	INT$ALLOC_MSG		; Allocate a msg buffer for
					;  SCS control msg receive
	BLBS	R0,40$			; Branch if got it
	BRW	ENTER_ERR2		; Else handle error

40$:	BSBW	INT$INS_MFREEQ		; Queue buffer to port
	MOVL	PB$L_SBLINK(R3),R0	; Get addr of formative SB
	MOVAL	G^SCS$GQ_CONFIG,R2	; Get SB listhead
	MOVL	R2,R1			; Hold starting point

CMP_EXIST_SBS:

	MOVL	(R2),R2			; Get next SB in list
	CMPL	R2,R1			; Back where we started?
	BEQL	MOVE_SB			; Branch if so, this system
					;  isn't here
	CMPL	SB$B_SYSTEMID(R0),-	; Check for system ID match
		SB$B_SYSTEMID(R2)	;  on low 4 bytes
	BNEQ	50$			; Branch if no match
	CMPW	SB$B_SYSTEMID+4(R0),-	; Check for system ID match
		SB$B_SYSTEMID+4(R2)	;
	BEQL	55$			; Branch if matches

50$:	CMPW	SB$T_SWVERS+1(R0),-	; Is the formative system block
		#^A/3./			;  for a V3.n system?
	BEQL	CMP_EXIST_SBS		; Branch if so and bypass node name
					;  uniqueness test
	PUSHR	#^M<R0,R1,R2,R3>	; Save registers destroyed in CMPC
	CMPC3	#16,SB$T_NODENAME(R0),-	; Are node names the same?
		SB$T_NODENAME(R2)	; 
	BEQL	56$			; Branch if node names are same, 
					;  but SYSIDs are not -- can't
					;  talk to this system because
					;  there is a configuration error
	POPR	#^M<R0,R1,R2,R3>	; Restore registers
	BRB	CMP_EXIST_SBS		; Continue searching existing SBs

55$:	PUSHR	#^M<R0,R1,R2,R3>	; Save reg destroyed by cmpc
	CMPC3	#16,SB$T_NODENAME(R0),-	; Do the system's node names
		SB$T_NODENAME(R2)	;  match?
	BEQL	57$			; Continue if so
56$:	BRW	ENTER_ERR4		; Branch if not -- don't talk to
					;  this system
57$:	POPR	#^M<R0,R1,R2,R3>	; Restore destroyed registers
	TSTL	SB$L_PBCONNX(R2)	; Does existing SB have paths?
	BNEQ	CHK_INCARN_ERR		; If so, go check for
					;  inconsistent incarnations

REFRESH_SB:

	CMPL	R2,#SCS$GA_LOCALSB	; Is this the local SB?
	BNEQ	DO_REFRESH		; Branch if not
	CMPL	SB$Q_SWINCARN(R0),-	; Else is the new incarnation the
		SB$Q_SWINCARN(R2)	;  same as the old?
	BNEQ	ENTER_ERR3		; Branch if not -- this must be
	CMPL	SB$Q_SWINCARN+4(R0),-	;  a different host masquerading
		SB$Q_SWINCARN+4(R2)	;  as us
	BNEQ	ENTER_ERR3		;

DO_REFRESH:

	MOVL	R3,SB$L_PBCONNX(R2)	; Set formative PB as first path
					;  to use for a connx in old SB
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	; Save regs destroyed by movc
	MOVC3	#UPDATE_LEN,-		; Update old SB with new
		SB$B_SYSTEMID(R0),-	;  SB info
		SB$B_SYSTEMID(R2)		;  from start handshake dg
	POPR	#^M<R0,R1,R2,R3,R4,R5>	; Restore registers destroyed
	BRB	DELETE_SB		; Go delete new SB and complete
					;  entering PB in database

CHK_INCARN_ERR:

	CMPL	SB$Q_SWINCARN(R0),-	; Is this the same incarnation of
		SB$Q_SWINCARN(R2)	;  of the system we've already got?
	BNEQ	ENTER_ERR3		; Branch if not because this means
	CMPL	SB$Q_SWINCARN+4(R0),-	;  the system is really a different
		SB$Q_SWINCARN+4(R2)	;  system with the same system ID
	BNEQ	ENTER_ERR3		;

;
; This system already has an SB in the database.  Delete formative
; SB and insert formative path block only into the system wide
; configuration database.  R0 has the address of the formative SB.
;

DELETE_SB:

	JSB	G^COM$DRVDEALMEM	; Deallocate it to pool
	BRB	MOVE_PB			; Join common PB move

;
; This system is new.  Move the formative SB to the system wide
; configuration database and link formative PB to it.  R0 has the 
; address of the formative SB.
;

MOVE_SB:

	MOVL	R0,R2			; Copy addr of formative SB
	INSQUE	(R2),@4(R1)		; Insert formative SB on tail of
					;  system configuration list
	MOVL	R3,SB$L_PBCONNX(R2)	; Set formative PB as first
					;  path to use for a connection

MOVE_PB:

	REMQUE	(R3),R3			; Remove formative path block
	INSQUE	(R3),@SB$L_PBBL(R2)	;  and link to system block
	BNEQ	60$			; Branch if not block in list
;
; Give notification that the SB is new or reused
;
;	R2 -> SB
;	R0,R1 need not be preserved
;
	JSB	G^SCS$NEW_SB		; Note the new SB
60$:
	MOVL	R2,PB$L_SBLINK(R3)	; Save final SB addr in PB
	MOVAL	PB$L_WAITQFL(R3),-	; Set PB general wait queue
		PB$L_WAITQFL(R3)	;  to no entries
	MOVAL	PB$L_WAITQFL(R3),-	; 
		PB$L_WAITQBL(R3)	;
	INCW	PDT$W_PBCOUNT(R4)	; Step count of PB's on this PDT
	MOVL	PB$B_RSTATION(R3),R0	; Retrieve the remote port number
	BBCC	R0,PDT$B_PLOGMAP(R4),65$; Clear bit in error logging mask
					; corresponding to remote port number
65$:	MOVZWL	#SS$_NORMAL,R0		; Set status = success

ENTER_DONE:

	POPL	R2			; Restore saved register
	RSB				; Return

ENTER_ERR1:
ENTER_ERR2:

	MOVL	PB$L_SCSMSG(R3),R2	; Get addr of SCS send buffer
	BSBW	INT$DEAL_MSG		;  and return to pool
	BRB	ENTER_ERR		; Join common error exit

ENTER_ERR3:

	MOVL	PB$B_RSTATION(R3),R1	; Retrieve the remote port number
	BBSS	R1,PDT$B_PLOGMAP(R4),70$; Branch if remote port already logged
	PUSHL	R5			; Otherwise save R5
	MOVL	R2,R5			; Move known system SB address into R5
	CLRL	R2			; Indicate that there is no packet
	MOVL	R3,R1			; Move remote PB address address into R3
	MOVZBL	#PAER$K_ES_RSCKS,R0	; Set the appropriate error subtype
	BSBW	ELOG$PACKET		; Go log conflict 
	POPL	R5			; Restore R5

70$:	BSBW	INT$MFQ2POOL		; Remove queued SCS recv buffer
	BRB	ENTER_ERR2		; Join rest of error handling

ENTER_ERR4:

	POPR	#^M<R0,R1,R2,R3>	; Restore reg lost in node name
					;  comparison
	BRB	ENTER_ERR3		; Join common cleanup

ENTER_ERR:

	MOVL	PB$L_CLSCKT_DG(R3),R2	; Get the close circuit dg addr
	BNEQ	80$			; Branch if got one
	BSBW	INT$ALLOC_PPDDG		; Else allocate a dg buffer
	BLBC	R0,ENTER_DONE		; Branch if no pool -- this vc will
					;  dangle till somebody tries to use 
					;  it by sending a connect request.
					;  At that time we have another chance
					;  to set it closed.

80$:	BISL3	#<PPD$M_RSP@24>!-	; Format the dg into a SETCKT
		<PPD$C_SETCKT@16>,-	;
		PB$B_RSTATION(R3),-	; 
		PPD$B_PORT(R2)		;
	MOVZWL	#PPD$M_CST,PPD$W_MASK(R2)
	CLRL	PPD$W_M_VAL(R2)		;  and ask for vc state to be closed
	BSBW	INT$INS_COMQH		; Do it at high priority
	CLRL	R0			; Set status to failed
	BRB	ENTER_DONE		; Go to exit routine

	.DSABL	LSB

	.SBTTL	-	BUILD_SB, BUILD A FORMATIVE SYSTEM BLOCK

;+
; BUILD_SB allocates a system block from nonpaged pool and sets
; it up with information from the received START or STACK datagram.
; If insufficient pool is available, then the routine returns failure.
;
; Inputs:
;
;	R2			-Addr of START/STACK dg
;	R3			-Addr of formative PB
;	R4			-Addr of PDT
;
; Outputs:
;
;	R0			-0/1 for fail/success
;	R1			-Destroyed
;	other registers 	-Preserved
;-

;
; Data structure adjacency assumptions:
;

ASSUME	SB$B_SYSTEMID+8 EQ SB$W_MAXDG
ASSUME	SB$W_MAXDG+2	EQ SB$W_MAXMSG
ASSUME	SB$W_MAXMSG+2	EQ SB$T_SWTYPE
ASSUME	SB$T_SWTYPE+4	EQ SB$T_SWVERS
ASSUME	SB$T_SWVERS+4	EQ SB$Q_SWINCARN
ASSUME	SB$Q_SWINCARN+8	EQ SB$T_HWTYPE
ASSUME	SB$T_HWTYPE+4	EQ SB$B_HWVERS
ASSUME	SB$T_NODENAME+16 EQ SB$L_DDB

ASSUME	PPD$B_SYSTEMID+8 EQ PPD$W_MAXDG
ASSUME	PPD$W_MAXDG+2	EQ PPD$W_MAXMSG
ASSUME	PPD$W_MAXMSG+2	EQ PPD$T_SWTYPE
ASSUME	PPD$T_SWTYPE+4	EQ PPD$T_SWVERS
ASSUME	PPD$T_SWVERS+4	EQ PPD$Q_SWINCARN
ASSUME	PPD$Q_SWINCARN+8 EQ PPD$T_HWTYPE
ASSUME	PPD$T_HWTYPE+4	EQ PPD$B_HWVERS
ASSUME	PPD$Q_NODENAME+8 EQ PPD$Q_CURTIME

DATA_LEN = <SB$B_HWVERS+12> - <SB$B_SYSTEMID>

	.ENABL	LSB

BUILD_SB:

	PUSHR	#^M<R2,R3,R4,R5>	; Save a bunch of registers
	MOVL	#SB$K_LENGTH,R1		; Get size of SB
	JSB	G^EXE$ALONONPAGED	; Allocate from nonpaged pool
	BLBC	R0,SB_DONE		; Branch if no pool
	MOVW	R1,SB$W_SIZE(R2)	; Set struct size
	MOVW	#DYN$C_SCS+<DYN$C_SCS_SB@8>,-  ; Set structure type
		SB$B_TYPE(R2)		       ;  and subtype
	MOVAL	SB$L_PBFL(R2),-		; Set path block list head
		SB$L_PBFL(R2)		;  to empty
	MOVAL	SB$L_PBFL(R2),-		;
		SB$L_PBBL(R2)		;
	MOVL	R2,R1			; Copy SB addr to R1
	MOVL	(SP),R2			; Retreive dg addr
	MOVL	4(SP),R3		;  and PB addr
	MOVL	R1,PB$L_SBLINK(R3)	; Link new SB to PB
	MOVB	PPD$B_PROTOCOL(R2),-	; Save PPD protocol level in
		PB$B_PROTOCOL(R3)	;  formative PB
	MOVQ	R1,-(SP)		; Save regs destroyed by movc
	MOVC3	#DATA_LEN,-		; Copy system ID, dg and msg
		PPD$B_SYSTEMID(R2),-	;  sizes, sw type, version, 
		SB$B_SYSTEMID(R1)	;  incarnation, HW type and version
	MOVL	4(SP),R2		; Retreive START/STACK dg addr
	LOCC	#^A/ /,#8,-		; Compute # characters prior
		PPD$Q_NODENAME(R2)	;  to blank fill
	SUBL3	R0,#8,R0		;  in node name
	MOVQ	(SP)+,R1		; Retreive saved registers
	MOVB	R0,SB$T_NODENAME(R1)	; Set count of characters
	CLRL	SB$L_CSB(R1)		; Zero link to newest CSB.
	MOVC5	R0,PPD$Q_NODENAME(R2),-	; Copy ASCII characters into
		#0,#15,SB$T_NODENAME+1(R1) ;  counted string node name in SB
	CLRL	(R3)			; Zero link to DDB chain for new SB
	MOVZWL	#SS$_NORMAL,R0		; Set status = success

SB_DONE:

	POPR	#^M<R2,R3,R4,R5>	; Restore registers
	RSB				; Return

	.DSABL	LSB

	.SBTTL	-	BREAK_PATH,	INITIATE CRASH
	.SBTTL	-			OF VIRTUAL CIRCUIT
	.SBTTL	-	BREAK_HOST,	HOST SHUTDOWN REC'D

;+
; BREAK_PATH is the action routine called when a START is received
; on a VC we think is open.  The START implies that the remote system
; has crashed the VC and that we should do the same.  Therefore, the 
; start datagram is discarded and ERR$CRASHVC is called to start
; the process of crashing the virtual circuit.
;
; BREAK_HOST is the action routine called when a host shutdown 
; dg is received.  It does the same as BREAK_PATH, but saves
; a special reason code in the path block to be used later when
; notifying SYSAP's of the circuit failure.
;
; Inputs:
;
;	R2			-Addr of START/Host shutdown dg
;	R3			-Addr of PB
;	R4			-Addr of PDT
;
; Outputs:
;
;	R0-R2			-Destroyed
;	Other registers		-Preserved
;-

	.ENABL	LSB

BREAK_HOST:

	MOVW	#SS$_NOSUCHNODE,-	; Save vc fail reason for
		PB$W_VCFAIL_RSN(R3)	;  later reporting to SYSAPs
					;  as the aux status
BREAK_PATH:

	BSBW	INT$INS_DFREEQ1		; Return dg buffer to 
					;  free queue
	MOVL	R3,R1			; Transfer PB address
	BRW	ERR$CRASHVC		; Start crash of VC on its way

	.DSABL	LSB

	.SBTTL	-	REC_ERROR_DG,		LOG ERROR DG

;+
; REC_ERROR_DG is the action routine called for an error log datagram
; PPD type.  These are datagrams received from hosts that have minimal
; error logging capability, do not have an scs connection over which
; to send an application datagram containing error info, and choose to
; send the info in one of these 'out of band' datagrams instead.
;
; Inputs:
;
;	R2			-Address of start of dg
;	R3			-Address of PB
;	R4			-Address of PDT
;
; Outputs:
;
;	R0			-Destroyed
;	Other registers 	-Preserved
;-

	.ENABL	LSB

REC_ERROR_DG:

	BSBW	ELOG$ERROR_DG		; Go log it
	MOVL	PDT$L_UCB0(R4),R0	; Get UCB address
	DECW	UCB$W_ERRCNT(R0)	; Decr error count incremented
					;  by error logger
	BRB	IGNORE_DG		; Go recycle to dg free queue

	.DSABL	LSB

	.SBTTL	-	IGNORE_DG,		DISCARD DATAGRAM WITHOUT ACTION

;+
; IGNORE_DG is the action routine called for received start handshake datagrams
; for a path block with VC failure in progress.  The datagram is returned to
; the free queue and no further action taken.
;
; Inputs:
;
;	R2			-Addr of handshake dg
;
; Outputs:
;
;	R0			-Destroyed
;	Other registers		-Preserved
;-

	.ENABL	LSB

IGNORE_DG:

	BRW	INT$INS_DFREEQ1		; Return dg to free queue

	.DSABL	LSB

	.SBTTL	UTILITY ROUTINES
	.SBTTL	-	FMT_START_DATA, FORMAT START DATA IN A
	.SBTTL	-			START/STACK DATAGRAM

;+
; FMT_START_DATA fills in the start data in a STACK or START datagram.
; Data is drqwn from sysgen paramters, SCS global locations, the
; system ID register, and constants. 
;
; Inputs:
;
;	R2			-Addr of datagram
;	R3			-Addr of PB
;	R4			-Addr of PDT
;
; Outputs:
;
;	R0,R1			-Destroyed
;	other registers		-Preserved
;-
;
; Message format adjacency assumptions:
;

	ASSUME	PPD$B_SYSTEMID+6 EQ PPD$B_PROTOCOL
	ASSUME	PPD$B_PROTOCOL+2 EQ PPD$W_MAXDG
	ASSUME	PPD$W_MAXDG+2	EQ PPD$W_MAXMSG
	ASSUME	PPD$W_MAXMSG+2	EQ PPD$T_SWTYPE
	ASSUME	PPD$T_SWTYPE+4	EQ PPD$T_SWVERS
	ASSUME	PPD$T_SWVERS+4	EQ PPD$Q_SWINCARN
	ASSUME	PPD$Q_SWINCARN+8 EQ PPD$T_HWTYPE
	ASSUME	PPD$T_HWTYPE+4 	EQ PPD$B_HWVERS
	ASSUME	PPD$B_HWVERS+12 EQ PPD$Q_NODENAME
	ASSUME	PPD$Q_NODENAME+8 EQ PPD$Q_CURTIME
	ASSUME	PPD$Q_CURTIME+8 EQ PPD$C_MIN_DGSIZ

	.ENABL	LSB

FMT_START_DATA:

	MOVAL	PPD$B_SYSTEMID(R2),R0	; Get system ID field addr
	MOVQ	G^SCS$GB_SYSTEMID,(R0)+	; Copy system ID
	MOVZBW	#PPD$C_PRT_ELOG,-2(R0)	; Set current protocol rev supported
	MOVL	G^SCS$GW_MAXDG,(R0)+	; Specify max bytes of dg and
					;  msg application data
	MOVL	#^A/VMS /,(R0)+		; Set operating system name
	MOVL	G^SYS$GQ_VERSION,(R0)+	; Set operating system version
	MOVQ	G^SCS$GA_LOCALSB+ -
		SB$Q_SWINCARN,(R0)+	; Set system boot seq #
	MOVL	INI$T_HWTYPE,(R0)+	; Set processor name
	MOVQ	G^EXE$GB_CPUDATA,(R0)+	; Copy CPU data (hardware/ ucode
	MOVL	G^EXE$GB_CPUDATA+8,(R0)+ ;  rev levels)
	MOVQ	G^SCS$GB_NODENAME,(R0)+	; Null node name, blank filled
	MOVQ	G^EXE$GQ_SYSTIME,(R0)+	; Set current system time
	RSB				; Return

	.DSABL	LSB

	.SBTTL	-	CLEANUP, REMOVE FORMATIVE PB AND SB

;+
; CLEANUP is called by the ACTION_DISP routine when fail status
; has been returned by an action routine.  The action routine
; detecting the error is expected to perform all cleanup other
; than deleting the formative path block and system block.  CLEANUP
; deletes the formative system block (if any) and formative
; path block.  The start handshake is simply abandoned to be
; restarted by a new IDREC later.
;
; Inputs:
;
;	R3			-Addr of formative PB
;	R4			-Addr of PDT
;
; Outputs:
;
;	R0			-Destroyed
;	other registers		-Preserved
;-

	.ENABL	LSB

CLEANUP:

	MOVL	PB$L_SBLINK(R3),R0	; Get addr of formative SB
	BEQL	10$			; Branch if none
	BSBB	CLEAN2			; Else deallocate SB
	
10$:	BBCC	PB$B_RSTATION(R3),-	; Mark no PB in path map
		PDT$B_PORTMAP(R4),20$	;
20$:	DECW	PDT$W_STDGUSED(R4)	; Decr count of # ports likely
					;  to send IDREC's and need
					;  start handshake
	BSBW	LB_ENABLE		; Enable loopback dg's if necessary
	REMQUE	(R3),R0			; Remove PB from formative list

CLEAN2:	JSB	G^COM$DRVDEALMEM	; Deallocate PB
	RSB				; Return

	.DSABL	LSB

	.SBTTL	-	SEARCH_PATHS, SEARCH FOR PB WITH STATION ADDR MATCH

;+
; SEARCH_PATHS searches a doubly linked list of PB's for the first
; PB with station address matching a specified station address.  The
; match is done only on the low order 8 bits of station address since
; CI station addresses are known to fit in 8 bits.
;
; Inputs:
;
;	R1			-Station address to match
;	R3			-Addr of PB listhead
;
; Outputs:
;
;	R0			-0/1 for fail/success on search
;	R3			-PB address if success
;	other registers		-Preserved
;-

	.ENABL	LSB

SEARCH_PATHS:

	MOVL	R3,R0			; Hold start point

SEARCH_CONT:

	MOVL	(R3),R3			; Get next PB
	CMPL	R3,R0			; Back at start?
	BEQL	20$			; Branch if so
	CMPB	PB$B_RSTATION(R3),R1	; Low byte matches?
	BNEQ	SEARCH_CONT		; Branch if not
	MOVZWL	#SS$_NORMAL,R0		; Else return success
	RSB				; Return

20$:	CLRL	R0			; Status = fail
	RSB				; Return

	.DSABL	LSB

	.SBTTL	-	CNF$LKP_PB_MSG,	LOOK UP THE PB CORRESPONDING
	.SBTTL	-			TO A PDT AND REMOTE STATION ADDR

;+
; CNF$LKP_PB_MSG extracts the remote station addr from a received message
; and looks through the system wide configuration database for the
; PB correxponding to the remote station and PDT.  Only the low order
; 8 bits of the station address are matched since CI station addresses
; always fit in 8 bits.
;
; Inputs:
;
;	R2			-Addr of message
;	R4			-Addr of PDT
;
; Outputs:
;
;	R0			-0/1 for fail/success on search
;	R1			-PB addr if success
;	Other registers		-Preserved
;-

	.ENABL	LSB

CNF$LKP_PB_MSG2::

	SUBL3	PDT$L_MSGHDRSZ(R4),R2,R1; Back up to top of PPD layer
	MOVZBL	PPD$B_PORT(R1),R1	; Get remote station addr
	BRB	5$

CNF$LKP_PB_MSG::

	MOVZBL	PPD$B_PORT(R2),R1	; Get remote station addr

5$:	PUSHL	R5			; Save a couple of registers
	PUSHL	R3			;
	MOVAL	G^SCS$GQ_CONFIG,R5	; Get addr of listhead for system
					;  configuration database

10$:	MOVL	(R5),R5			; Get next system block
	CMPL	R5,#SCS$GQ_CONFIG	; Back at start of list?
	BEQL	PB_NOT_FOUND		; Branch if so
	MOVAL	SB$L_PBFL(R5),R3	; Get addr of PB listhead
	BSBB	SEARCH_PATHS		; See if there is matching station

20$:	BLBC	R0,10$			; Branch if no matching station
	CMPL	PB$L_PDT(R3),R4		; Is this path block a path from
					;  the same PDT?
	BEQL	PB_FOUND		; Branch if yes
	MOVAL	SB$L_PBFL(R5),R0	; Else set up PB listhead addr again
	BSBB	SEARCH_CONT		; Continue PB search
	BRB	20$			;  and check results

PB_FOUND:

	MOVL	R3,R1			; Move PB addr to R1

30$:	POPL	R3			; Retreive caller's R3
	POPL	R5			;  and R5
	RSB				; Return

PB_NOT_FOUND:

	CLRQ	R0			; Show failure status
	BRB	30$			; Join common exit
	
	.DSABL	LSB

	.SBTTL	-	CNF$LKP_PB_PDT,	LOOK UP FIRST/NEXT
	.SBTTL	-			PB ASSOC WITH PDT

;+
; CNF$LKP_PB_PDT looks through the configuration database for PB's
; associated with a specified PDT.  For each one found, the caller is
; called back with the PB address in R3.  When the whole database has
; been searched, return is taken to the caller with failure status in R0.
;
; This routine is called during power failure to cleanup PB's and SB's
; associated with the local failing port.  Therefore, when a PB is 
; delivered to the caller, the PB and its SB may have been deleted
; upon return from the coroutine.  The forward links to the next PB and
; next SB in the configuration database will be destroyed in this case.
; Whenever an SB is being processed, the link to the next SB is saved on
; the stack.  When a PB is about to be delivered to the coroutine, the 
; link to the next PB is saved on the stack and, upon return, the saved
; link used as the address of the next PB to look at.
;
; Inputs:
;
;	R4			-PDT addr
;
; Outputs:
;
;	R0			-Status:  LBS/C if PB found/not found
;	R3			-PB addr if success
;	R1,R2			-Destroyed
;	Other registers		-Preserved
;-

ASSUME  PB$L_FLINK	EQ 0
ASSUME  SB$L_FLINK	EQ 0

	.ENABL	LSB

CNF$LKP_PB_PDT::

	MOVAL	G^SCS$GQ_CONFIG,R2	; Get configuration database ptr
	MOVL	(R2),R2			; Get next system blk

10$:	CMPL	R2,#SCS$GQ_CONFIG	; Back at header?
	BEQL	NOT_FOUND		; Branch if so
	PUSHL	(R2)			; Save link to next SB
	MOVAL	SB$L_PBFL(R2),R3	; Get PB list header
	MOVL	R3,R1			; Save listhead addr

20$:	MOVL	(R3),R3			; Get next PB

30$:	CMPL	R3,R1			; Back at start of list?
	BEQL	NEXT_SB			; Branch if so -- move to next SB
	CMPL	PB$L_PDT(R3),R4		; Is PB on this PDT?
	BNEQ	20$			; Branch if not
	MOVZWL	#SS$_NORMAL,R0		; Set success status for caller
					;  coroutine
	PUSHL	(R3)			; Save link to next PB
	PUSHR	#^M<R1,R2>		; Save registers caller destroys
	JSB	@<4*4>(SP)		; Call caller back to process PB
					;  (There are 2 flinks and 2
					;  registers saved on the stack)
	POPR	#^M<R1,R2>		; Restore registers
	POPL	R3			; Retreive addr of next PB
	BRB	30$			; Check next PB

NEXT_SB:

	POPL	R2			; Retreive addr of next SB
	BRB	10$			; Check next SB
NOT_FOUND:

	CLRL	R0			; Set fail status for caller coroutine
	RSB				; Return to caller

	.DSABL	LSB

	.SBTTL	-	CNF$REMOVE_PB,	REMOVE PB(SB) FROM 
	.SBTTL	-			CONFIG DATABASE

;+
; CNF$REMOVE_PB is called by ERR$VCCLOSED_MSG/PB or ERR$VC_CACHECLR
; when all connections associated with a failing path block have
; been cleaned up.  CNF$REMOVE_PB marks the remote port as unknown in 
; the port bitmap.  If this is a virutal circuit failure  due to reasons
; other than local port/system power failure, then the path block SCS 
; receive buffer and, if available, the SCS send buffer, are reclaimed from
; the message free queue and returned to pool.  In the case of a power 
; failure this step is omitted because all queue elements for all
; paths on the local port are collected together later.
;
; Finally, the path block is unlinked from the system block.  If this
; leaves the SB with no paths, then the SB link to the next PB to
; use in a connection is zeroed.  The PB is returned to pool and return taken.
;
; Inputs:
;
;	IPL			-Fork IPL
;	
;	R3			-PB addr
;	R4			-PDT addr
;
; Outputs:
;
;	R0-R2			-Destroyed
;	Other registers		-Preserved
;-

	.ENABL	LSB

CNF$REMOVE_PB::

	TSTL	PB$L_CDTLST(R3)		; Verify no CDT's remain
	BEQL	10$			; Branch if none do
	BRW	CONFIG_ERR		; Else inconsistent database

10$:	BBCC	PB$B_RSTATION(R3),-	; Mark the remote port unknown
		PDT$B_PORTMAP(R4),20$	;  to poller

20$:	DECW	PDT$W_STDGUSED(R4)	; Decr #ports that will likely
					;  send us IDREC's for a while
	BSBW	LB_ENABLE		; Enable loopback dg's if necessary
	DECW	PDT$W_PBCOUNT(R4)	; Decr count of PB's on this PDT
	CMPW	PB$W_STATE(R3),-	; Is this a power fail recovery?
		#PB$C_PWR_FAIL		; 
	BEQL	40$			; Branch if so
	MOVL	PB$L_SCSMSG(R3),R2	; Else get SCS send buffer
	BNEQ	30$			; Branch if available
	BSBW	INT$MFQ2POOL		; If unavailable, get it from
	BVS	40$			;  message free queue
	BRB	35$

30$:	BSBW	INT$DEAL_MSG		; Deallocate to pool
35$:	BSBW	INT$MFQ2POOL		; Get SCS receive buffer from free q

40$:	MOVL	PB$L_CLSCKT_DG(R3),R2	; Get CLSCKT dg addr
	BEQL	45$			; Branch if none
	BSBW	INT$DEAL_DG1		; Else return to pool

45$:	MOVL	PB$L_SBLINK(R3),R0	; Get addr of this path's SB
	CMPL	SB$L_PBCONNX(R0),R3	; Is SB ptr to next PB to use for
					;  a connection PB we are removing?
	BNEQ	46$			; Branch if not
	MOVL	PB$L_FLINK(R3),-	; Else patch SB to point to
		SB$L_PBCONNX(R0)	;  next path if any

46$:	REMQUE	(R3),R3			; Remove PB from PB list
	BNEQ	50$			; Branch if not last PB
	CLRL	SB$L_PBCONNX(R0)	; Zero link to next connx to use

50$:	MOVL	R3,R0			; Copy PB addr for deallocation
	BRW	CLEAN2			; Deallocate PB to pool

	.DSABL	LSB

	.SBTTL	-	SNDDG_RET,	SEND DG, RETURN BUFFER
	.SBTTL	-			TO RESPONSE QUEUE
	.SBTTL	-	SNDDG_NORET,	SEND DG, RETURN BUFFER
	.SBTTL	-			TO FREE QUEUE

;+
; The datagram is put on the low priority command queue with
; the response flag set/clear for the SEND_RET/NORET call.
;
; Inputs:
;
;	R2			-Addr of dg buffer
;	R3			-Addr of PB
;	R4			-Addr of PDT
;
; Outputs:
;
;	R0			-Destroyed
;	Other registers		-Preserved
;-

	.ENABL	LSB

SNDDG_RET:

	MOVL	R3,R1			; Transfer PB address
	MOVL	#SYSAP$C_DISPPO,R0	; RETFLAG=TRUE, DISP=POOL
	BRW	INT$SNDDG1		; Send it

SNDDG_NORET:

	MOVL	R3,R1			; Transfer PB address
	MOVL	#SYSAP$C_DISPQ,R0	; RETFLAG=FALSE
	BRW	INT$SNDDG1		; Send it

	.DSABL	LSB

	.SBTTL	-	LB_ENABLE,	ENABLE LB DG SENDS
	.SBTTL	-			IF NECESSARY

;+
; Called whenever a virtual circuit is lost to check and see if
; there are now no remote ports known besides self.  (Known means
; virtual circuits open or formative paths.) If there are no remote
; ports known besides self, then the loopback dg test is enabled.
; Otherwise, the loopback test flag is left alone.
;
; Inputs:
;
;	R4			-PDT addr
;	PDT$B_PORTMAP(R4)	-32 byte bit map of known ports
;	PDT$B_PORT_NUM(R4)	-# of local port
;
; Outputs:
;
;	R0			-Destroyed
;	Other registers		-Preserved
;	PDT$W_LPORT_STS		-PDT$M_LBDG set if no other
;				 ports known; else unchanged
;-

	.ENABL	LSB

LB_ENABLE:

	MOVQ	R1,-(SP)		; Save two registers for caller
	CLRL	R2			; Zero count of # bytes in map
	
10$:	MNEGL	#1,R1			; Init prev known port #, modulo 32

20$:	INCL	R1			; Incr prev known port #, mod 32
	FFS	R1,#32,-		; Find next known port, mod 32
		PDT$B_PORTMAP(R4)[R2],R1 ;  in this longwd of port map
	BEQL	40$			; Branch if none found
	ASHL	#32/4,R2,R0		; Convert port # mod 32 to
	ADDL	R0,R1			;  actual port number
	CMPB	R1,PDT$B_PORT_NUM(R4)	; Is known port = self?
	BEQL	20$			; Branch if so to search more
	BRB	50$			; Else return without doing anything

40$:	ADDL	#4,R2			; Step offset in port map to next longwd
	CMPL	R2,#32			; Past last longwd in map?
	BLSSU	10$			; Branch if not
	BISW	#PDT$M_LBDG,-		; Else no port other than
		PDT$W_LPORT_STS(R4)	;  self known, so enable LB dgs

50$:	MOVQ	(SP)+,R1		; Restore caller's registers
	RSB				; Return

	.DSABL	LSB

	.SBTTL	-	CHECK_PORT_REV,		CHECK PORT
	.SBTTL	-				UCODE REV LEVEL

;+
; Given and IDREC packet, check the port RAM and ROM rev levels
; to make sure they are adequate.  If not, log an error, print a
; message on OPA0, and (for now) continue.
;
; The algorithm for checking is to look up the ROM/RAM level read
; from the ID in a table of legal ROM/REAM combinations.  If it isn't
; in the table, then check to see if either the ROM or RAM level
; exceeds the maximum the table knows about.  If either exceeds
; the maximum in the table.  If either exceeds the max, do no 
; futher checking on the assumption that new ucode is being run
; that VMS hasn't been taught to judge.  If neither exceeds the
; max, then the ucode fails the test.
;
; If the rev level is found in the legal table, then check the
; cautionary rev table to see if we should print a warning before
; continuing.  A flag is set in the cautionary table for rev's
; which are known to have problems, but which have not yet been
; replaced by the fixed ucode in the field yet.  The cautionary
; message on OPA0 alerts customers to ask field service to install
; fixes.
;
; To add new legal rev combinations to the table, patch or extend
; LEGAL_REV_TABLE with the new legal combination(s), and patch
; MAX_RAM/ROM_REV.
;
; Inputs:
;
;	R2			-Addr of IDREC packet
;	R4			-PDT addr
;
; Outputs:
;
;	R0			-Destroyed
;	Other registers		-Preserved
;-

LEGAL_REV_TABLE:

					; .WORD n,n = RAM/ROM level

	.WORD	2,2			; Current as of June, 1984
	.WORD	3,3			; Next rev known to need fixes
					;  in both RAM and ROM
	.WORD	0,0			; Patch space for future revs
	.WORD	0,0

REV_TABLE_SIZ = <.- LEGAL_REV_TABLE>/4

CAUTION_REV:

					; .BYTE nonzero/0 for caution/
					;  caution message needed
	.BYTE	0			; Rev 2,2 -- no caution
	.BYTE 	0			; Rev 3,3 -- no caution
	.BYTE	0			; Future revs...
	.BYTE	0

MAX_RAM_REV:

	.WORD	3			; Max RAM level in table

MAX_ROM_REV:

	.WORD	3			; Max ROM level in table

	.ENABL	LSB

CHECK_PORT_REV:

	PUSHR	#^M<R0,R4,R5>		; Save caller's registers
	MOVL	PDT$L_UCB0(R4),R5	; Get UCB in case error logging needed
	MOVAL	LEGAL_REV_TABLE,R1	; Get addr of legal rev table
	CLRL	R0			; Zero index into table

10$:	CMPL	(R1)+,PPD$L_RPORT_REV(R2)  ; Is rev being checked in table?
	BEQL	CHECK_CAUTION		; Branch if so
	AOBLSS	#REV_TABLE_SIZ,R0,10$	; Branch if not, continue check
	CMPW	PPD$L_RPORT_REV+2(R2),-	; Is RAM level bigger than we know about?
		MAX_RAM_REV
	BGTRU	REV_OK			; Branch if so
	CMPW	PPD$L_RPORT_REV(R2),-	; Is ROM level bigger than we know about?
		MAX_ROM_REV
	BGTRU	REV_OK			; Branch if so
	BSBW	ELOG$UCODE_ERR		; Log problem 
	CLRB	INI$PORT_REV		; Clear port rev okay flag to force
					;  more informative UCODEREV bugcheck
					;  if a bugcheck is done
	CLRB	UCB$B_ERTCNT(R5)	; Take away all port's retries
	BSBW	ERR$CRASH_PORT		; Go crash port permanently

CHECK_CAUTION:

	MOVAL	CAUTION_REV,R1		; Get addr of table of caution flags
	TSTB	(R1)[R0]		; Rev legal, check if caution msg needed
	BEQL	REV_OK			; Branch if completely okay
	BSBW	ELOG$UCODE_WARN		; Log warning
	
REV_OK:

	POPR	#^M<R1,R4,R5>		; Restore caller's registers
	RSB				; Return.

	.DSABL	LSB

	.SBTTL	CNF$TIMER,	PERIODIC WAKEUP ROUTINE
	.SBTTL	CNF$CALCINTDUE,	RESET WAKEUP DUE TIME

;+
; CNF$TIMER is called from exec module TIMESCHDL once per n
; seconds, where n is the basic CI interval timeout.  Timer
; intervals are specifed in SYSGEN as follows:
;
;  Parameter name		Units			Variable name
;
;	PASIMTOUT	seconds (2, 2^15-1)	SCS$GW_PASTMOUT
;	PAPOLLINTERVAL	seconds (2, 2^15-1)	SCS$GW_PAPOLINT
;	PAPOOL_INTERVAL	seconds (2, 2^15-1)	SCS$GW_PAPOOLIN
;
; Note that if the poller interval and pool checking interval are not
; exact multiples of the basic interval, then they will be effecitvely
; rounded up to the nearest multiple of the basic interval.  The basic
; interval is equal to the start handshake timeout interval.
;
; Inputs:
;
;	R3			-Addr of CRB
;	IPL			-IPL$_POWER
;
; Outputs:
;
;	IPL			-IPL$_SCS
;	R0-R2,R4,R5		-Destroyed
;	Other registers		-Preserved
;
; Entry CNF$CALCINTDUE computes the due time for the next basic interval wakeup.
; It expects as inputs R3/CRB, R4/PDT and destroys R0.
;
;-

	.ENABL	LSB

CNF$TIMER::

	MOVL	CRB$L_AUXSTRUC(R3),R4	; Get PDT address
	BNEQ	5$			; Branch if there is a PDT
	RSB				; Else port init aborted, can't
					;  use port

5$:	MOVL	PDT$L_UCB0(R4),R5	; Get UCB address
	BBS	#UCB$V_ONLINE,-		; Branch if controller/unit is
		UCB$W_STS(R5),CONT_POLL	;  on line
	BRW	CNF$CALCINTDUE		; Else bypass poller and other activity
					;  and compute next wakeup time

CONT_POLL:

	MOVL	#1,@PDT$L_MTC(R4)	; Poke the maint timer in the
					;  port to tell it we are alive
	SETIPL	#IPL$_SCS		; Lower IPL for rest of polling, etc.
	PUSHL	R3			; Save CRB address
	MOVAL	PDT$Q_FORMPB(R4),R3	; Get formative PB listhead addr
	PUSHL	R3			;  and save a copy
	MOVL	(R3),R3			; Get addr of 1st entry in PB list

SCAN_FORMPB:

	CMPL	R3,(SP)			; Back at start of list?
	BEQL	FORM_PB_DONE		; Branch if so
	MOVL	(R3),R5			; Save addr of next PB in
					;  case this one gets deleted
	BBC	#PB$V_TIM,-		; Branch if no timeout 
		PB$W_STS(R3),10$	;  is in progress
	CMPL	PB$L_DUETIME(R3),-	; Passed this PB's duetime?
		G^EXE$GL_ABSTIM		;
	BGTRU	10$			; Branch if not
	MOVZWL	#EV$C_TIMEOUT,R1	; Set event = timed out
	BSBW	ACTION_DISP		; Call action dispatcher for
					;  this PB

10$:	MOVL	R5,R3			; Step to next formative  PB
	BRB	SCAN_FORMPB		; Check next PB

FORM_PB_DONE:

	TSTL	(SP)+			; Clear PB listhd from stack
	CMPL	PDT$L_POOLDUE(R4),-	; Passed pool chekcer's time?
		G^EXE$GL_ABSTIM		;
	BGTRU	CHECK_POLLER		; Branch if not
	MOVAL	PDT$L_WAITQBL(R4),R5	; Get pool waiter listhead addr
	CMPL	(R5),-4(R5)		; List empty?
	BEQL	POOL_DONE		; Branch if so
	MOVL	(R5),R5			; Else get addr of last waiter (if any)
	
20$:	MOVL	PDT$L_WAITQFL(R4),R3	; Get addr of next CDRP we are
					;  going to try to wake
	$RESUME_FP	-		; Resume next waiter
		@PDT$L_WAITQFL(R4),-	; 
		QEMPTY=POOL_DONE	; If none, go to POOL_DONE
	CMPL	R3,R5			; Was this waiter the last one when
					;  we started scanning the list?
					;  (More on the list now are
					;  repeat failures.)
	BNEQ	20$			; Branch if not

POOL_DONE:

	MOVZWL	G^SCS$GW_PAPOOLIN,R0	; Get pool check interval
	ADDL3	R0,G^EXE$GL_ABSTIM,-	; Add pool interval to current
		PDT$L_POOLDUE(R4)	;  time and store as due time

CHECK_POLLER:

	POPL	R3			; Retreive CRB addr
	CMPL	PDT$L_POLLERDUE(R4),-	; Passed poller's duetime?
		G^EXE$GL_ABSTIM		;
	BGTRU	CNF$CALCINTDUE		; Branch if not
	BSBW	CNF$POLL		; Call poller

	MOVZWL	G^SCS$GW_PAPOLINT,R0	; Get poller interval
	ADDL3	R0,G^EXE$GL_ABSTIM,-	; Add poll interval to current time and
		PDT$L_POLLERDUE(R4)	;  store as poller duetime
	BSBW	CNF$CALC_POLLSW		; Compute current time it takes
					;  to do a complete poll sweep
					;  over both paths -- this has
					;  to be recomputed periodically because
					;  the parameters are dynamic
	
CNF$CALCINTDUE::

	MOVZWL	G^SCS$GW_PASTMOUT,R0	; Get basic timer interval
	ADDL3	R0,G^EXE$GL_ABSTIM,-	; Add it to current time and
		CRB$L_DUETIME(R3)	;  and save in CRB

30$:	RSB				; Return

	.DSABL	LSB

	.SBTTL	CNF$CALC_POLLSW, CALCULATE TIME TO POLL 
	.SBTTL	-		 PORT AT LEAST ONCE

;+
; This routine computes the number of seconds it takes to poll
; every possible port at least once, even if only one path is
; working.  This value is used by the VAXcluster sysap.
;
; The formula is as follows:
;
;  {(maximum port # +1)/(# ports polled per interval)} * 2 paths * poll interval
;   +maximum time to wake up poller
;
; If the number of ports polled per interval exceeds the number of free
; datagrams available to conduct simultaneous start handshakes, then use
; the number of free datagrams instead of the number of ports per interval 
; in the above formula.  The number of free datagrams available is not known
; exactly since there is no accounting on the datagrams that can be tied
; up doing start handshakes.  The number available is estimated as 
; PDT$W_STDGDYN(R4).
;
; Inputs:
;
;	R4			-PDT address
;
; 	SCS$GB_PAMXPORT		-SYSGEN'ed maximum port #
;	SCS$GB_PANPOLL		-# ports to poll per interval
;	SCS$GW_PAPOLINT		-# seconds between polls, poll interval
;	SCS$GW_PASTIMOUT	-# seconds it might take to wake up poller
;	PDT$B_MAX_PORT(R4)	-maximum port # supported by this CI
;
; Outputs:
;
;	R0,R1,R2		-Destroyed
;	Other registers		-Preserved
;
;	PDT$L_POLLSWEEP(R4)	-# seconds to poll each port at least once
;-

	.ENABL	LSB

CNF$CALC_POLLSW::

	MOVZBL	G^SCS$GB_PAMXPORT,R1	; Get SYSGENed max port #
	MOVZBL	PDT$B_MAX_PORT(R4),R0	; Get hardware supported max port
	CMPL	R1,R0			; SYSGENed .GT. hardware max?
	BLEQ	10$			; Branch if not
	MOVL	R0,R1			; Else hardware value prevails
	
10$:	INCL	R1			; Convert port # to number of ports
	MOVZBL	G^SCS$GB_PANPOLL,R0	; Get # ports polled per interval
	MOVZWL	PDT$W_STDGDYN(R4),R2	; Get # dgs available for start
					;  start handshakes, max.
	CMPL	R0,R2			; # ports per interval .leq. free dg
					;  limit?
	BLEQU	15$			; Branch if so
	MOVL	R2,R0			; Else use free dg limit instead

15$:	CLRL	R2			; Clear h.o. longwd of dividend
	EDIV	R0,R1,R1,R0		; Compute # ports/ # per interval polled
	TSTL	R0			; If there was a remainder,
	BEQL	20$			; 
	INCL	R1			;  then round quotient up

20$:	ADDL	R1,R1			; Multipy by 2 paths *
	MOVZWL	G^SCS$GW_PAPOLINT,R0	;  the number of seconds between
	MULL	R0,R1			;  polls
	MOVZWL	G^SCS$GW_PASTMOUT,R0	; Get the timer before poller even
					;  awakened,
	ADDL3	R0,R1,PDT$L_POLLSWEEP(R4) ;  add in and save total in PDT
	RSB				  ; Return

	.DSABL	LSB

	.SBTTL	START_TIMER, START A PATH BLOCK TIMER
;+
; START_TIMER computes the due time for PB timeout and sets the
; timeout in porgress bit (PB$V_TIM in PB$W_STS) for the specified
; pathblock.
;
; Inputs:
;
;	R3			-Addr of PB
;	
; Outputs:
;
;	R0			-Destroyed
;	Other registers		-Preserved
;-

	.ENABL	LSB

START_TIMER:

	MOVZWL	G^SCS$GW_PASTMOUT,R0	; Get basic timer interval
	ADDL3	R0,G^EXE$GL_ABSTIM,-	; Add it to the current time
		PB$L_DUETIME(R3)	;  and save in PB due time
	BBSS	#PB$V_TIM,-		; Set timeout in progress
		PB$W_STS(R3),10$	;  in pathblock
10$:	RSB				; Return

	.DSABL	LSB

	.SBTTL	STOP_TIMER, STOP PATH BLOCK TIMER

;+
; STOP_TIMER disables path block timeout by clearing the timeout
; in progress bit in the pathblock.
;
; Inputs:
;
;	R3			-Addr of PB
;
; Outputs:
;
;	All registers		-Preserved
;-

STOP_TIMER:

	BBCC	#PB$V_TIM,-		; Clear the timeout in progress bit
		PB$W_STS(R3),10$	;  in specified pathblock
10$:	RSB				; Return

	.SBTTL	SET_CIRCUIT, PORT OPENS A PORT-PORT VIRTUAL CIRCUIT

;+
; SET_CIRCUIT allocates a datagram buffer.  If none are available, 
; return with error status.  Otherwise, send the SETCKT datagram
; to the port.
;
; Inputs:
;
;	R2			-Addr of START/STACK dg
;	R3			-Addr of formative PB
;	R4			-Addr of PDT
;
; Outputs:
;
;	R0			-0/1 for fail/success
;	Other registers		-Preserved
;-

	.ENABL	LSB

SET_CIRCUIT:

	PUSHL	R2			; Save dg addr
	BSBW	INT$ALLOC_PPDDG		; Allocate a dg buffer
	BLBC	R0,SET_ERR		; Branch if none
	MOVL	#<PPD$M_RSP@24>!-	;
		 <PPD$C_INVTC@16>,-	;
		PPD$B_PORT(R2)		; Set opcode and ask for response
	BSBW	INT$INS_COMQH		; Issue the invalidate command
	BSBW	INT$ALLOC_DG1		; Allocate a datagram buffer
					;  for the open circuit command
	BLBC	R0,SET_ERR		; Branch if insufficient pool
	BISL3	#<PPD$M_RSP@24>!-	; Open VC, reset sequence #'s
		 <PPD$C_SETCKT@16>,-	; Get SETCKT back for pool
		PB$B_RSTATION(R3),-	;
		PPD$B_PORT(R2)		;
	MOVZWL	#<PPD$M_CST!-		;
		 PPD$M_NR!PPD$M_NS>,-	;
		PPD$W_MASK(R2)		; Set mask
	MOVZWL	#PPD$M_CST,PPD$W_M_VAL(R2)
	BSBW	INT$INS_COMQH		; Send it on its way
	MOVZBL	#SS$_NORMAL,R0		; Set status to success

10$:	POPL	R2			; Retreive dg addr
	RSB				; Return

SET_ERR:

	CLRL	R0			; Set status to failure
	BRB	10$			; Take common exit

	.DSABL	LSB



	.END
