MODULE MAIL$SYSMAI( %TITLE 'OPEN/READ/WRITE SYS$SYSTEM:VMSMAIL.DAT'
		IDENT = 'V04-000' ) =
BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY:	VAX/VMS MAIL UTILITY
!
! ABSTRACT:	This module contains routines that deal with the
!		VMS MAIL data file, SYS$SYSTEM:VMSMAIL.DAT
!
! ENVIRONMENT:	NATIVE/USER MODE
!
! AUTHOR: Benn Schreiber, CREATION DATE: 13-Dec-1982
!
! MODIFIED BY:
!
!	V03-008	ROP0033		Robert Posniak		09-Aug-1984
!		Make sure locally allocated XABs are disconnected
!		from global FABs.
!
!	V03-007	BLS0255		Benn Schreiber		28-Dec-1983
!		New global flags
!
!	V03-006	BLS0246		Benn Schreiber		7-Nov-1983
!		Move new mail count into SYS$SYSTEM:VMSMAIL.DAT
!
!	V03-005	BLS0225		Benn Schreiber		17-Jun-1983
!		Break up file spec into fns='VMSMAIL', dns='SYS$SYSTEM:.DAT',
!		so that a system logical name for VMSMAIL can be used.
!
!	V03-004	BLS0221		Benn Schreiber		 5-May-1983
!		Correct SYSPRV handling
!
!	V03-003	BLS0220		Benn Schreiber		30-Apr-1983
!		Add MAIL$GET_DEV_DIR
!
!	V03-002	BLS0213		Benn Schreiber		21-Mar-1983
!		Don't report open error if just reading VMSMAIL
!--

!
! TABLE OF CONTENTS
!
LIBRARY	'SYS$LIBRARY:LIB';
REQUIRE	'SRC$:MAILREQ';
LIBRARY 'LIB$:MAILDEF';

GLOBAL
	MAIL$L_SYSMAIBUF: REF $BBLOCK,		! Pointer to VMSMAIL.DAT buffer
	MAIL$L_USRSYSBUF: REF $BBLOCK,		! Pointer to this user's
						!  vmsmail record
	MAIL$T_SYSMAIFAB: $FAB_DECL,		! FAB for I/O
	MAIL$T_SYSMAIRAB: $RAB_DECL;		! and a RAB


BIND
	VMSMAIL_DESC = $DESCRIPTOR('VMSMAIL') : $BBLOCK,
	SYSEXE_DESC = $DESCRIPTOR('SYS$SYSTEM:.DAT') : $BBLOCK;

OWN
	SYSMAIESS: $BBLOCK[NAM$C_MAXRSS],	! ESS for VMSMAIL
	SYSMAINAM: $NAM_DECL;			! NAM block for VMSMAIL

EXTERNAL
	MAIL$T_UAF_BUFF : REF $BBLOCK,		! UAF buffer
	MAIL$Q_USERNAME: $BBLOCK,		! String descriptor of username
	MAIL$GL_FLAGS : $BBLOCK;		! Control flags

EXTERNAL ROUTINE
	LIB$GET_VM: ADDRESSING_MODE(GENERAL),	! Allocate virtual memory
	MAIL$GET_USER,				! Get UAF record
	MAIL$UP_PRIV,				! Raise privileges
	MAIL$DOWN_PRIV,				! and drop them
	STR$APPEND,				! String append
	STR$COPY_DX,				! String copy
	UTIL$REPORT_IO_ERROR;			! Report I/O error
!
! Define shared messages
!
$SHR_MSGDEF(MAIL,126,LOCAL,
		(READERR,WARNING),
		(WRITEERR,WARNING),
		(OPENOUT,WARNING));

GLOBAL ROUTINE MAIL$UPDATE_SYSMAI_REC (RECBUF) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Write/update a new record in VMSMAIL for a user
!
! Inputs:
!
!	RECBUF = Address of record to write/update
!
!--
BEGIN
MAP
    RECBUF : REF $BBLOCK;

LOCAL
    STATUS;

MAIL$T_SYSMAIRAB[RAB$W_RSZ] = VMD_C_LENGTH + .RECBUF[VMD_B_FWDLNG]
			+ .RECBUF[VMD_B_FNMLNG] + .RECBUF[VMD_B_DIRLNG];
MAIL$T_SYSMAIRAB[RAB$L_RBF] = .RECBUF;
MAIL$T_SYSMAIRAB[RAB$V_UIF] = 1;
MAIL$T_SYSMAIRAB[RAB$L_KBF] = .MAIL$T_SYSMAIRAB[RAB$L_RBF];
MAIL$T_SYSMAIRAB[RAB$L_CTX] = MAIL$_WRITEERR;
STATUS = $PUT(RAB=MAIL$T_SYSMAIRAB,ERR=UTIL$REPORT_IO_ERROR);
MAIL$T_SYSMAIRAB[RAB$V_UIF] = 0;
IF .STATUS
    THEN STATUS = $FLUSH(RAB=MAIL$T_SYSMAIRAB,ERR=UTIL$REPORT_IO_ERROR);
!
! If this is the user's record, save the latest copy
!
IF .STATUS
    AND CH$EQL(VMD_C_USERNAME,RECBUF[VMD_T_USERNAME],
		VMD_C_USERNAME,MAIL$L_USRSYSBUF[VMD_T_USERNAME],%C' ')
    THEN CH$MOVE(.MAIL$T_SYSMAIRAB[RAB$W_RSZ],
		.MAIL$T_SYSMAIRAB[RAB$L_RBF],
		.MAIL$L_USRSYSBUF);

RETURN .STATUS
END;

GLOBAL ROUTINE MAIL$OPEN_SYSMAI =
BEGIN
!++
! FUNCTIONAL DESCRIPTION:
!
!	Open SYS$SYSTEM:VMSMAIL.DAT for update.
!
! INPUTS:
!
!	Static FAB/RAB
!
! OUTPUTS:
!
!	file opened.
!	Buffer allocated, pointed to by MAIL$L_SYSMAIBUF
!
! ROUTINE VALUE:
!
!	success if file opened
!	fail if not
!
!--

LOCAL
    STATUS,
    XABPRO: $XABPRO_DECL,
    XABKEY0: $XABKEY_DECL;
!
! Allocate a buffer to read/write from
!
IF .MAIL$L_SYSMAIBUF EQL 0
	THEN IF_ERR(LIB$GET_VM(%REF(VMD_C_LENGTH+3*NAM$C_MAXRSS),
				MAIL$L_SYSMAIBUF);,
			SIGNAL(.STATUS); RETURN TRUE);
IF .MAIL$L_USRSYSBUF EQL 0
	THEN IF_ERR(LIB$GET_VM(%REF(VMD_C_LENGTH+3*NAM$C_MAXRSS),
				MAIL$L_USRSYSBUF);,
			SIGNAL(.STATUS); RETURN TRUE);
!
! Initialize RMS data structures
!
$FAB_INIT(FAB=MAIL$T_SYSMAIFAB,
	FAC=(GET,PUT,DEL,UPD),
	FOP=(CIF,CBT),
	FNS=.VMSMAIL_DESC[DSC$W_LENGTH],
	FNA=.VMSMAIL_DESC[DSC$A_POINTER],
	DNS=.SYSEXE_DESC[DSC$W_LENGTH],
	DNA=.SYSEXE_DESC[DSC$A_POINTER],
	SHR=(GET,PUT,DEL,UPD),
	CTX=MAIL$_OPENOUT,
	ORG=IDX,			!Indexed
	RFM=VAR,			!Variable length records
	ALQ=10,
	DEQ=10);

    MAIL$T_SYSMAIFAB[FAB$V_LNM_MODE] = PSL$C_EXEC;

    $NAM_INIT(NAM=SYSMAINAM,
	ESS=NAM$C_MAXRSS,
	ESA=SYSMAIESS,
	RSS=NAM$C_MAXRSS,
	RSA=SYSMAIESS);


$XABPRO_INIT(XAB=XABPRO,
	PRO=(RWE,RWE),			!Owner and system access only
	UIC=(1,4),			!Owner is [1,4]
	NXT=XABKEY0);

$XABKEY_INIT(XAB=XABKEY0,
	KREF=0,
	POS0=0,
	SIZ0=VMD_C_USERNAME,		!Username is first 31 bytes
	NXT=0);

MAIL$T_SYSMAIFAB[FAB$L_XAB] = XABPRO;	!Point FAB to the XAB chain
!
! Open (or create) the file
!
MAIL$UP_PRIV(1^$BITPOSITION(PRV$V_SYSPRV),0);
STATUS = $CREATE(FAB=MAIL$T_SYSMAIFAB,ERR=UTIL$REPORT_IO_ERROR);
MAIL$DOWN_PRIV();

IF NOT .STATUS
    THEN RETURN .STATUS;

$RAB_INIT(RAB=MAIL$T_SYSMAIRAB,
	RAC=KEY,
	ROP=(RLK,NLK),
	KRF=0,
	KSZ=VMD_C_USERNAME,
	KBF=.MAIL$L_SYSMAIBUF,
	CTX=MAIL$_OPENOUT,
	FAB=MAIL$T_SYSMAIFAB,
	RBF=.MAIL$L_SYSMAIBUF,
	USZ=VMD_C_LENGTH+3*NAM$C_MAXRSS,
	UBF=.MAIL$L_SYSMAIBUF);

STATUS = $CONNECT(RAB=MAIL$T_SYSMAIRAB);
IF NOT .STATUS
 AND NOT (IF .STATUS EQL RMS$_CRMP
        THEN STATUS = (MAIL$T_SYSMAIFAB[FAB$W_GBC] = 0;
			$CONNECT(RAB=MAIL$T_SYSMAIRAB))
	ELSE FALSE)
THEN BEGIN
    UTIL$REPORT_IO_ERROR(MAIL$T_SYSMAIFAB);
    $CLOSE(FAB=MAIL$T_SYSMAIFAB);
    RETURN TRUE
    END;
MAIL$T_SYSMAIRAB[RAB$L_CTX] = MAIL$_READERR;
MAIL$T_SYSMAIFAB[FAB$L_XAB] = 0;
!
! Read the user record if it exists
!
IF NOT .MAIL$GL_FLAGS[MAIF_V_NETJOB]
THEN BEGIN
    CH$COPY(.MAIL$Q_USERNAME[DSC$W_LENGTH],.MAIL$Q_USERNAME[DSC$A_POINTER],
		' ',VMD_C_USERNAME,MAIL$L_USRSYSBUF[VMD_T_USERNAME]);
    !
    ! Read the record.  If it doesn't exist, then initialize the buffer
    ! and write out the record for this user.
    !
    MAIL$T_SYSMAIRAB[RAB$L_KBF] = .MAIL$L_USRSYSBUF;
    IF NOT $GET(RAB=MAIL$T_SYSMAIRAB)
	THEN BEGIN
	    IF .MAIL$T_SYSMAIRAB[RAB$L_STS] NEQ RMS$_RNF
		THEN RETURN UTIL$REPORT_IO_ERROR(MAIL$T_SYSMAIRAB);
	    CH$FILL(0,VMD_C_LENGTH+NAM$C_MAXRSS-$BYTEOFFSET(VMD_W_FLAGS),
				MAIL$L_USRSYSBUF[VMD_W_FLAGS]);
	    MAIL$UPDATE_SYSMAI_REC(.MAIL$L_USRSYSBUF);
	    END
	ELSE CH$MOVE(.MAIL$T_SYSMAIRAB[RAB$W_RSZ],	!Copy/save this user
			.MAIL$T_SYSMAIRAB[RAB$L_RBF],
			.MAIL$L_USRSYSBUF);
    END;

RETURN TRUE
END;

GLOBAL ROUTINE MAIL$CHECK_FORW(NAME_DESC,DATA_BUFFER) =
BEGIN
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine checks if the named user has forwarding enabled
!	in SYS$SYSTEM:VMSMAIL.DAT
!
! INPUTS:
!
!	NAME_DESC = Address of string descriptor for user name
!	DATA_BUFFER = Address of a buffer to read record in to (If not given,
!			MAIL$L_SYSMAIBUF will be used.
!
! OUTPUTS:
!
!	If found, the buffer pointed to by DATA_BUFFER contains
!	the record.
!
! ROUTINE VALUE:
!
!	True if name is forwarded
!	False if not
!--
BUILTIN
    NULLPARAMETER;

MAP
	NAME_DESC : REF $BBLOCK,
	DATA_BUFFER : REF $BBLOCK;

LOCAL
	BUFPTR : REF $BBLOCK,
	STATUS;

IF NOT NULLPARAMETER(2)
    THEN BUFPTR = .DATA_BUFFER
    ELSE BUFPTR = .MAIL$L_SYSMAIBUF;
CH$COPY(.NAME_DESC[DSC$W_LENGTH],.NAME_DESC[DSC$A_POINTER],
		' ',VMD_C_USERNAME,.BUFPTR);
MAIL$T_SYSMAIRAB[RAB$L_UBF] = .BUFPTR;
MAIL$T_SYSMAIRAB[RAB$L_KBF] = BUFPTR[VMD_T_USERNAME];
MAIL$T_SYSMAIRAB[RAB$V_NLK] = TRUE;
IF NOT $GET(RAB=MAIL$T_SYSMAIRAB)
    THEN RETURN 0;

RETURN (.BUFPTR[VMD_B_FWDLNG] NEQ 0);

END;

GLOBAL ROUTINE MAIL$GET_SYSMAI_REC(NAME_DESC,RECBUF) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Read the record from VMSMAIL.DAT for the named user
!
! INPUTS:
!
!	NAME_DESC = Address of descriptor for username
!	RECBUF = Address of buffer to return record in
!
!--
BEGIN
LOCAL
	STATUS;
MAP
	NAME_DESC : REF $BBLOCK,
	RECBUF : REF $BBLOCK;

CH$COPY(.NAME_DESC[DSC$W_LENGTH],.NAME_DESC[DSC$A_POINTER],
		' ',VMD_C_USERNAME,.RECBUF);
MAIL$T_SYSMAIRAB[RAB$L_UBF] = .RECBUF;
MAIL$T_SYSMAIRAB[RAB$L_KBF] = RECBUF[VMD_T_USERNAME];
MAIL$T_SYSMAIRAB[RAB$V_NLK] = TRUE;
STATUS = $GET(RAB=MAIL$T_SYSMAIRAB);

RETURN .STATUS		
END;

GLOBAL ROUTINE MAIL$GETLK_SYSMAI_REC (NAME_DESC, RECDESC) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Read and lock the designated record in VMSMAIL
!
!
! INPUTS:
!
!	NAME_DESC = Address of descriptor for username
!	RECDESC = Address of descriptor to return record descriptor in
!
!--
BEGIN
MAP
	NAME_DESC : REF $BBLOCK,
	RECDESC : REF VECTOR[,LONG];

LOCAL
	COUNTER,
	STATUS;

LITERAL
	RETRY_RLK = 10,			! number of retries for a locked record
	SLEEP_RLK = 75;			! ms to sleep before retrying

BIND
    WAKEDELTA = UPLIT LONG(-10*1000*SLEEP_RLK,-1);

CH$COPY(.NAME_DESC[DSC$W_LENGTH],.NAME_DESC[DSC$A_POINTER],
		' ',VMD_C_USERNAME,.MAIL$L_SYSMAIBUF);
MAIL$T_SYSMAIRAB[RAB$L_UBF] = .MAIL$L_SYSMAIBUF;
MAIL$T_SYSMAIRAB[RAB$L_KBF] = MAIL$L_SYSMAIBUF[VMD_T_USERNAME];
MAIL$T_SYSMAIRAB[RAB$V_NLK] = FALSE;
COUNTER = RETRY_RLK;
WHILE ((STATUS = $GET(RAB=MAIL$T_SYSMAIRAB)) EQL RMS$_RLK)
	AND ((COUNTER = .COUNTER - 1) GEQ 0)
    DO IF $SCHDWK(DAYTIM = WAKEDELTA) THEN $HIBER;

IF NOT .STATUS
    THEN RETURN .STATUS;

RECDESC[0] = .MAIL$T_SYSMAIRAB[RAB$W_RSZ];
RECDESC[1] = .MAIL$T_SYSMAIRAB[RAB$L_RBF];

RETURN .STATUS
END;

GLOBAL ROUTINE MAIL$GET_DEVDIR(USERDESC,DEVDIRDESC) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine gets the device/directory descriptor for USERNAME
!	and returns it in DEVDIRDESC via STR$COPY.
!
!--
BEGIN
MAP
    USERDESC : REF $BBLOCK,
    DEVDIRDESC : REF $BBLOCK;

LOCAL
    STATUS,
    DIRBUF : $BBLOCK[NAM$C_MAXRSS],
    PTR : REF VECTOR[,BYTE],
    DESC : VECTOR[2,LONG],
    SYSMAIBUF : $BBLOCK[VMD_C_LENGTH+3*NAM$C_MAXRSS];

PTR = DIRBUF;
IF NOT (STATUS = MAIL$GET_USER(.USERDESC))
THEN RETURN .STATUS
ELSE BEGIN
    PTR = CH$MOVE(.(MAIL$T_UAF_BUFF[UAF$T_DEFDEV])<CS_COUNT>,
			(MAIL$T_UAF_BUFF[UAF$T_DEFDEV])<CS_STRING>,
			DIRBUF);
    PTR = CH$MOVE(.(MAIL$T_UAF_BUFF[UAF$T_DEFDIR])<CS_COUNT>,
			(MAIL$T_UAF_BUFF[UAF$T_DEFDIR])<CS_STRING>,.PTR);
    END;
IF MAIL$GET_SYSMAI_REC(.USERDESC,SYSMAIBUF)
    AND .SYSMAIBUF[VMD_B_DIRLNG] NEQ 0
    THEN PTR = CH$MOVE(.SYSMAIBUF[VMD_B_DIRLNG]-1,
		SYSMAIBUF[VMD_T_FWDNAM]+.SYSMAIBUF[VMD_B_FWDLNG]+
			.SYSMAIBUF[VMD_B_FNMLNG]+1,.PTR-1);

IF .((MAIL$T_UAF_BUFF[UAF$T_DEFDIR])<CS_STRING>)<0,8> EQL %C'['
    THEN PTR[-1] = %C']'
    ELSE PTR[-1] = %C'>';
DESC[0] = .PTR - DIRBUF;
DESC[1] = DIRBUF;
STR$COPY_DX(.DEVDIRDESC,DESC);

RETURN TRUE
END;

GLOBAL ROUTINE MAIL$GET_NEWMAIL(USERDESC,COUNT) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Return the new mail count from VMSMAIL
!
!--
BEGIN

LOCAL
    PTR : REF $BBLOCK,
    SYSMAIBUF : $BBLOCK[VMD_C_LENGTH+3*NAM$C_MAXRSS];

.COUNT = 0;
IF_ERR(MAIL$GET_SYSMAI_REC(.USERDESC,SYSMAIBUF);,
	RETURN TRUE);

.COUNT = .SYSMAIBUF[VMD_W_MAIL];

RETURN TRUE
END;

GLOBAL ROUTINE MAIL$INCR_NEWMAIL(USERDESC,COUNT) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Increment the new mail count of the specified user
!
! Inputs:
!
!	Userdesc = address of descriptor of user to update
!	COUNT = (optional) address of value to set the count to
!
!--
BEGIN
BUILTIN
    ACTUALCOUNT;

MAP
    USERDESC : REF $BBLOCK;

LOCAL
    PTR : REF $BBLOCK,
    SYSMAIBUF : $BBLOCK[VMD_C_LENGTH],
    DESC : VECTOR[2,LONG];

RETURN (IF MAIL$GETLK_SYSMAI_REC(.USERDESC,DESC)
THEN BEGIN
    PTR = .DESC[1];
    IF ACTUALCOUNT() LSSU 2
 	THEN PTR[VMD_W_MAIL] = .PTR[VMD_W_MAIL] + 1
	ELSE PTR[VMD_W_MAIL] = .COUNT;
    MAIL$UPDATE_SYSMAI_REC(.DESC[1])
    END
ELSE BEGIN
    CH$FILL(0,VMD_C_LENGTH,SYSMAIBUF);
    CH$COPY(.USERDESC[DSC$W_LENGTH],.USERDESC[DSC$A_POINTER],
		' ',VMD_C_USERNAME,SYSMAIBUF);
    SYSMAIBUF[VMD_W_MAIL] = (IF ACTUALCOUNT() LSSU 2
					THEN 1
					ELSE .COUNT);
    MAIL$UPDATE_SYSMAI_REC(SYSMAIBUF)
    END)
END;

GLOBAL ROUTINE MAIL$DECR_NEWMAIL(USERDESC) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Decrement the new mail count
!
!--
BEGIN

MAP
    USERDESC : REF $BBLOCK;

LOCAL
    PTR : REF $BBLOCK,
    RECDESC : VECTOR[2,LONG];

IF MAIL$GETLK_SYSMAI_REC(.USERDESC,RECDESC)
THEN BEGIN
    PTR = .RECDESC[1];
    IF .PTR[VMD_W_MAIL] GTRU 0
	THEN PTR[VMD_W_MAIL] = .PTR[VMD_W_MAIL] - 1;
    MAIL$UPDATE_SYSMAI_REC(.RECDESC[1])
    END;

RETURN TRUE
END;

END
ELUDOM
