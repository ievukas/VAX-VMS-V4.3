	.TITLE	BAS$MAT_MUL		; BASIC matrix multiply
	.IDENT	/1-021/			; File: BASMATMUL.MAR	Edit: SBL1020

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY: BASIC code support
;
; ABSTRACT:
;
;	This module multiplies 2 arrays of any dtype and stores the result in a
;	third array of any dtype.
;
; ENVIRONMENT: User Mode, AST Reentrant
;
;--
; AUTHOR: R. Will, CREATION DATE: 11-Jul-79
;
; MODIFIED BY:
;++
; 1-001	- Original 
; 1-002	- Change MTH$DFLOOR_R1 to MTH$DFLOOR_R3.  JBS 25-JUL-1979
; 1-003 - Add check for Illegal Operation error.  RW  28-Sept-79
; 1-004 - Set IV bit in mask to signal integer overflow.  RW  2-Oct-79
; 1-005 - Redo scaling.  RW  13-Dec-79
; 1-006	- Change MTH$DFLOOR_R3 to MTH$DINT_R4.  JBS 19-DEC-1979
; 1-007 - Fix test for 'same array' for virtual.  RW  15-Feb-1980
; 1-008 - Add support for byte, g and h floating.  PLL 17-Sep-81
; 1-009 - More modifications for new data types.  PLL 24-Sep-81
; 1-010 - Changed shared external reference to G^ RNH 25-Sep-81
; 1-011 - Substitute a macro for the calls to the array fetch and store
;	  routines.  This should speed things up.  PLL 9-Nov-81
; 1-012 - Correct a run-time expression in the FETCH and STORE macros.
;	  PLL 20-Jan-82
; 1-013 - Do not store an hfloat element in R9.  PLL 15-Feb-82
; 1-014 - Don't list macro expansions.  PLL 16-Mar-82
; 1-015 - Fix problem with stack (created by edit 013).  PLL 5-Apr-1982
; 1-016 - Change order of instructions at STORE_HFLOAT.  PLL 14-Apr-1982
; 1-017 - Added code to support arrays of descriptors.  LEB 28-JUN-1982.
; 1-018 - Change own storage to stack storage.  LEB 9-Jul-1982
; 1-019 - Allow gfloat results to be stored in a double destination, and
;	  vice versa.  PLL 7-Oct-1982
; 1-020 - fix minor typos in byte*long, word*long, and anything*hfloat.
;	  MDL 15-Oct-1982
; 1-021 - Use G^ for ALL externals.  SBL 16-Nov-1982
;--

	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;

	$DSCDEF					; define descriptor offsets
	$SFDEF					; use to get scale

;
; EXTERNAL DECLARATIONS:
;

	.DSABL	GBL				; Prevent undeclared
						;  symbols from being
						;  automatically global.
	.EXTRN	BAS$K_ARGDONMAT			; signalled if all 3 blocks
						;  not present in array desc
						;  or dimct = 0
	.EXTRN	BAS$K_DATTYPERR			; signalled if dtype of array
						; isn't word long float double
	.EXTRN	BAS$K_MATDIMERR			; signalled if # of dims on any
						;  array isn't 0
	.EXTRN	BAS$K_ARRMUSSAM			; signalled if cols of src1 not
						;  = rows of src2
	.EXTRN	BAS$K_ILLOPE			; signalled if dest matrix is
						;  same as either src matrix
	.EXTRN	BAS$STO_FA_B_R8			; array element store for byte
	.EXTRN	BAS$STO_FA_W_R8			; array element store for word
	.EXTRN	BAS$STO_FA_L_R8			; array element store for long
	.EXTRN	BAS$STO_FA_F_R8			; array element store - float
	.EXTRN	BAS$STO_FA_D_R8			; array element store - double
	.EXTRN  BAS$STO_FA_G_R8			; array element store - gfloat
	.EXTRN	BAS$STO_FA_H_R8			; array element store - hfloat
	.EXTRN  BAS$FET_FA_B_R8			; array element fetch - byte
	.EXTRN	BAS$FET_FA_W_R8			; array element fetch - word
	.EXTRN	BAS$FET_FA_L_R8			; array element fetch - long
	.EXTRN	BAS$FET_FA_F_R8			; array element fetch - float
	.EXTRN	BAS$FET_FA_D_R8			; array element fetch - double
	.EXTRN	BAS$FET_FA_G_R8			; array element fetch - gfloat
	.EXTRN  BAS$FET_FA_H_R8			; array element fetch - hfloat
	.EXTRN	BAS$MAT_REDIM			; check if redimensioning of
						;  dest array is necessary, if
						;  so, do it
	.EXTRN	BAS$$SCALE_R1			; scale for double procision
	.EXTRN	MTH$DINT_R4			; routine to integerize double
	.EXTRN	BAS$$STOP			; signal fatal errors
	.EXTRN	BAS$FETCH_BFA
	.EXTRN	BAS$STORE_BFA

;
; MACROS:
;

;	$BAS$MAT_MUL	multiply loop algorithm,  see next page
;	FETCH		fetch an element from an array
;	STORE		store an element into an array

;
; EQUATED SYMBOLS:
;

	upper_bound_k = 0			; stack offset for temporary
						;  for upperbound of inner loop
	lower_bound_k = 4			; stack offset for temporary
						;  for lowerbound for innerloop
	upper_bound_j = 8			; stack offset for temporary
						;  for upperbound of middle loop
	lower_bound_j = 12			; stack offset for temporary
						;  for lowerbound of middle loop
	upper_bound_i = 16			; stack offset for temporary
						;  for upperbound of outer loop
	current_j = 20				; stack offset for temporary for
						;  current value of middle loop
	current_i = 24				; stack offset for temporary for
						;  current value of outer loop
	current_sum = 28			; stack offset for temporary for
						;  summing to get element
	scale = 44				; stack offset for temporary for
						;  scale
 	src1 = 52				; place to store element 1 while
						;  element 2 is fetched
	value_desc = 66
	str_len = 66
	dtype = 68
	class = 69
	pointer = 70
	data = 74
	dsc$l_l1_1 = 24				; desc offset if 1 sub
	dsc$l_u1_1 = 28				; desc offset if 1 sub
	dsc$l_l1_2 = 28				; desc offset if 2 sub
	dsc$l_u1_2 = 32				; desc offset if 2 sub
	dsc$l_l2_2 = 36				; desc offset if 2 sub
	dsc$l_u2_2 = 40				; desc offset if 2 sub

;
; OWN STORAGE:
;


;
; PSECT DECLARATIONS:
;
	.PSECT _BAS$CODE PIC, USR, CON, REL, LCL, SHR, -
			EXE, RD, NOWRT, LONG


;+
; This macro contains the looping mechanism for accessing all elements of
; an array.  It also contains all the logic for all the combinations of data
; types and scaling.  A macro is used to make it easy to maintain the parallel
; code for all the different data types.
;-
	.MACRO	$BAS$MAT_MUL src1_dtype, src2_dtype ; multiply algorithm

;+
; Get scale so if any of the arrays is double, the scale will be there
;-

	MOVL	SF$L_SAVE_FP(FP), R0		; pass FP to get scale
	JSB	G^BAS$$SCALE_R1			; get scale in R0 & R1
						; call a BLISS routine because
						; the frame offsets are only
						; defined for BLISS
	MOVD	R0, scale(SP)			; store the scale

;+
; Loop through all the rows of the destination matrix.
; Row and column upper and lower bounds have been initialized on the stack.
; Current row (current_i) has been initialized to its lower bound.
;-

LOOP_I_'src1_dtype'src2_dtype':
	MOVL	lower_bound_j(SP), current_j(SP) ; initialize current_j
						;   to lower_bound of j

;+
; Loop through all the elements (columns) of the current row of the destination
; matrix.  Current column (current_j) has been initialized to its lower bound.
; Column upper bound is on the stack (upper_bound_j).
;-

LOOP_J_'src1_dtype'src2_dtype':
	MOVL	lower_bound_k(SP), R11		; initialize current_k (R11) to
						;  lower_bound of k
	CLRQ	current_sum(SP)			; a CLRQ will set the temporary
						;  to 0 for all possible dtypes
	CLRQ	current_sum+8(SP)		; sum could be hfloat (but don't
						;  use h instruction here)
;+
; Loop through, summing the products of each element of the ith row of src1
; and the jth column of  src2.  current_i and current_j are on the stack.
; Source array element pointer (current_k) has been initialized in R11.
; Distinguish array by data type so that the correct fetch routine can 
; retrieve the data, the correct multiply and add can be done and the correct
; store routine can be called.

LOOP_K_'src1_dtype'src2_dtype':

;+
; Get the data from the first source array
;-

	MOVL	src1_matrix(AP), R0		; pointer to 1st src array
	MOVL	current_i(SP), R1		; current row
	MOVL	R11, R2				; current col
	FETCH	'src1_dtype'			; fetch data from src1 array
	MOV'src1_dtype'	R0, src1(SP)		; store the 1st array element

;+
; Get the data from the second source array
;-

	MOVL	src2_matrix(AP), R0		; pointer to 2nd src array
	MOVL	R11, R1				; current row
	MOVL	current_j(SP), R2		; current col
	FETCH	'src2_dtype'			; fetch data from src2 array

;+
; If the data types of the 2 source arrays is the same, do the arithmetic in
; that data type.  Else convert the data to a common type and multiply and add.
; If either of the source elements is double, descale and multiply.  Scale and
; integerize the product before adding it to the sum.
;-

	.IF	IDN	src1_dtype, src2_dtype	; src arrays are
						; same data type
	.IF	IDN	src1_dtype, D		; both sources are double
	MULD2	src1(SP), R0			; multiply
	DIVD2	scale(SP), R0			; remove extra scale from result
	CMPD	scale(SP), #1			; is the scale 0?
	BEQL	1$				; yes, do not integerize
	JSB	G^MTH$DINT_R4			; no, integerize
1$:	ADDD2	R0, current_sum(SP)		; add to sum
	.IFF					; sources same dtype, not double
	MUL'src1_dtype'2	src1(SP), R0	; multiply the source elements
	ADD'src1_dtype'2	R0, current_sum(SP) ; add product to current sum
	.ENDC					; end of same dtype code
	.IFF					; src arrays different dtype
	.IF	IDN	src1_dtype, H		; source 1 is hfloat
	CVT'src2_dtype'H	R0, R0		; cvt array2 to hfloat
	MULH2	src1(SP), R0			; mult the elements
	ADDH2	R0, current_sum(SP)		; add product to current sum
	.IFF
	.IF	IDN	src2_dtype, H		; source 2 is hfloat
	CVT'src1_dtype'H	src1(SP), src1(SP) ; cvt array1 to hfloat
	MULH2	src1(SP), R0			; mult the elements
	ADDH2	R0, current_sum(SP)		; add product to current sum
	.IFF
	.IF 	IDN	src1_dtype, G		; source 1 is gfloat
	.IF	IDN	src2_dtype, D		; special case if g & dbl
	DIVD2	scale(SP), R0			; descale src2
	CVTDH	R0, R0				; cvt src2 to hfloat
	CVTGH	src1(SP), src1(SP)		; cvt src1 to hfloat
	MULH2	src1(SP), R0			; mult the elements
	ADDH2	R0, current_sum(SP)		; add product to current sum
	.IFF					; src2 any type but dbl
	CVT'src2_dtype'G	R0, R0		; cvt src2 to gfloat
	MULG2	src1(SP), R0			; mult the elements
	ADDG2	R0, current_sum(SP)		; add product to current sum
	.ENDC					; end of src1 gfloat
	.IFF
	.IF	IDN	src2_dtype, G		; source 2 is gfloat
	.IF	IDN	src1_dtype, D		; special case gfloat & dbl
	DIVD2	scale(SP), src1(SP)		; descale src1
	CVTDH	src1(SP), src1(SP)		; cvt src1 to hfloat
	CVTGH	R0, R0				; cvt src2 to hfloat
	MULH2	src1(SP), R0			; mult the elements
	ADDH2	R0, current_sum(SP)		; add product to current sum
	.IFF					; src2 gfloat & src1 not dbl
	CVT'src1_dtype'G	src1(SP), src1(SP) ; cvt src1 to gfloat
	MULG2	src1(SP), R0			; mult the elements
	ADDG2	R0, current_sum(SP)		; add product to current sum
	.ENDC					; end of src2 gfloat
	.IFF
	.IF	IDN	src1_dtype, D		; source 1 is double
						; don't have to worry if src2
						;  is gfloat because we already
						;  checked
	CVT'src2_dtype'D	R0, R0		; cvt array2 to double & save
						;  no scaling needed because in
						;  multiply scale is in 2nd src
	MULD2	src1(SP), R0			; multiply
	JSB	G^MTH$DINT_R4			; integerize
	ADDD2	R0, current_sum(SP)		; add product to current sum
	.IFF					; 1st array not double
	.IF	IDN	src2_dtype, D		; is 2nd src double
						; yes, make src1 double & save
	CVT'src1_dtype'D	src1(SP), src1(SP) ; make 1st src double
						;  no scaling needed because for
						;  multiply only 1 number is
						;  needed to be scaled.  
	MULD2	src1(SP), R0			; compute the product
	JSB	G^MTH$DINT_R4			; integerize
	ADDD2	R0, current_sum(SP)		; add product to current sum
	.IFF					; no double operands try float
	.IF	IDN	src1_dtype, F		; is 1st element float
	CVT'src2_dtype'F	R0, R0		; make 2nd element float
	MULF2	src1(SP), R0			; multiply the elements
	ADDF2	R0, current_sum(SP)		; add to current sum
	.IFF					; 1st array not float
	.IF	IDN	src2_dtype, F		; is 2nd array float
	CVT'src1_dtype'F	src1(SP), src1(SP) ; yes-make 1st element float
	MULF2	src1(SP), R0			; multiply the elements
	ADDF2	R0, current_sum(SP)		; add to current sum
	.IFF					; no double or float, try long
	.IF	IDN	src1_dtype, L		; is 1st array long
	CVT'src2_dtype'L	R0, R0		; make 2nd element long
	MULL2	src1(SP), R0			; multiply elements
	ADDL2	R0, current_sum(SP)		; add product to current sum
	.IFF					
	.IF	IDN	src2_dtype, L		; src2 is long  
	CVT'src1_dtype'L	src1(SP), src1(SP) ; cvt src1 to long 
	MULL2	src1(SP), R0			; multiply the elements
	ADDL2	R0, current_sum(SP)		; add product to current sum
	.IFF
	.IF	IDN	src1_dtype, W		; src1 is word
	CVT'src2_dtype'W	R0, R0		; cvt src2
	MULW2	src1(SP), R0			; mult the elements
	ADDW2	R0, current_sum(SP)		; add product to current sum
	.IFF
	.IF	IDN	src1_dtype, B		; src1 is byte
	CVT'src2_dtype'B	R0, R0		; cvt src2
	MULB2	src1(SP), R0			; mult the elements
	ADDB2	R0, current_sum(SP)		; add product to current sum
	.IFF					; last case - src2 must be byte
	CVT'src1_dtype'B	src1(SP), src1(SP) ; cvt src1
	MULB2	src1(SP), R0			; mult the elements
	ADDB2	R0, current_sum(SP)		; add product to current sum
	.ENDC
	.ENDC
	.ENDC
	.ENDC
	.ENDC
	.ENDC
	.ENDC
	.ENDC
	.ENDC
	.ENDC
	.ENDC
	.ENDC
	.ENDC

;+
; Have multiplied next set of elements and added it to current sum.  See if
; it is the last product of the sum.  If not continue with current sum.
; Otherwise, store the sum in the destination array by calling a subroutine
; (pass pointer to dest in R10 and pointer to stack in R5)
; and continue with next destination element.
;-

	INCL	R11				; get next K
	CMPL	R11, upper_bound_k(SP)		; see if last product in sum
	BGTR	5$
	BRW	LOOP_K_'src1_dtype'src2_dtype	; no, continue inner loop

						; finished inner loop so store
5$:	MOVL	SP, R5				; point to temps
	.IF	IDN	src1_dtype, src2_dtype	; src arrays are
						; same data type
	BSBW	DEST_CASE_'src1_dtype'		; go cvrt to dest type and store
	.IFF					; src arrays different dtype
	.IF	IDN	src1_dtype, H		; source 1 is hfloat
	BSBW	DEST_CASE_H			; cvt from hfloat to dest type
	.IFF	
	.IF	IDN	src2_dtype, H		; source 2 is hfloat
	BSBW	DEST_CASE_H			; cvt from hfloat to dest type
	.IFF
	.IF	IDN	src1_dtype, G		; source 1 is gfloat
	.IF	IDN	src2_dtype, D		; special case gfloat & dbl
	BSBW	DEST_CASE_H			; ops done in hfloat so cvt
						;  from hfloat to dest type
	.IFF					; gfloat & all other dtypes
	BSBW	DEST_CASE_G			; cvt from gfloat to dest type
	.ENDC
	.IFF
	.IF	IDN	src2_dtype, G		; source 2 is gfloat
	.IF	IDN	src1_dtype, D		; special case dbl & gfloat
	BSBW	DEST_CASE_H			; ops done in hfloat so cvt
						;  from hfloat to dest type
	.IFF					; gfloat & all other dtypes
	BSBW	DEST_CASE_G			; cvt from gfloat to dest type
	.ENDC
	.IFF
	.IF	IDN	src1_dtype, D		; source 1 is double
	BSBW	DEST_CASE_D			; cnvrt from double to dest type
						; and store
						; (note that we don't have to 
						;  worry about dbl & gfloat here
						;  because it was handled above)
	.IFF					; 1st array not double
	.IF	IDN	src2_dtype, D		; is 2nd src double
						; yes, make src1 double & save
	BSBW	DEST_CASE_D			; cnvrt from double to dest type
						; and store
	.IFF					; no double operands try float
	.IF	IDN	src1_dtype, F		; is 1st element float
	BSBW	DEST_CASE_F			; cnvrt from float to dest type
						; and store
	.IFF					; 1st array not float
	.IF	IDN	src2_dtype, F		; is 2nd array float
	BSBW	DEST_CASE_F			; cnvrt from float to dest type
						; and store
	.IFF					
	.IF	IDN	src1_dtype, L		; source 1 is long
	BSBW	DEST_CASE_L			; cnvrt from long to dest type
						; and store
	.IFF
	.IF	IDN	src2_dtype, L		; source 2 is long
	BSBW	DEST_CASE_L			; cvt from long to dest type
	.IFF					
	.IF	IDN	src1_dtype, W		; source 1 is word
	BSBW	DEST_CASE_W			; cvt from word to dest type
	.IFF
	.IF	IDN	src2_dtype, W		; source 2 is word
	BSBW	DEST_CASE_W			; cvt from word to dest type
						; byte and any other data type
						; would've been caught by one
						; of the above cases, and byte
						; & byte is handles by case 1
	.IFF
	.IF	IDN	src1_dtype, B		; source 1 is byte
	BSBW	DEST_CASE_B
	.IFF
	BSBW	DEST_CASE_B			; only thing left
	.ENDC
	.ENDC
	.ENDC
	.ENDC
	.ENDC
	.ENDC
	.ENDC
	.ENDC
	.ENDC
	.ENDC
	.ENDC
	.ENDC
	.ENDC
	.ENDC

;+
; Have stored that element.  Now see if it was the last column.  If not,
; continue with the next column.  Otherwise continue to next row.
;-

	INCL	current_j(SP)			; get next column
	CMPL	current_j(sp), upper_bound_j(SP) ; see if last column done
	BGTR	20$
	BRW	LOOP_J_'src1_dtype'src2_dtype'	; no, continue inner loop

;+
; Have completed entire row.  See if it was the last row.  If not,
; continue with next row.
;-

20$:	INCL	current_i(SP)			; get next row
	CMPL	current_i(SP), upper_bound_i(SP) ; see if last row done
	BGTR	10$
	BRW	LOOP_I_'src1_dtype'src2_dtype'	; no, continue outer loop

10$:	RET					; yes, finished

	.ENDM

	.SBTTL	BAS$MAT_MUL  - Multiply 2 arrays giving a third
;++
; FUNCTIONAL DESCRIPTION:
;
;	Multiply 2 arrays giving a third.  Signal an error if the upper and
;	lower bounds (excluding 0) for columns in src1_matrix does not equal
;	the upper and lower bounds (excluding 0) for rows in src2_matrix.
;	An error will also be signalled if any of the three matrices does not
;	have a DIMCT of 2, or if DSC$A_POINTER in either src1_matrix or
;	src2_matrix is the same as DSC$A_POINTER of dest_matrix.
;	Redimension the output to have a lower bound of 0 for both dimensions,
;	and an upper bound for rows equal to the upper bound for rows for
;	src1_matrix, and an upper bound for columns equal to the upper bound
;	for columns for src2_matrix.  Initialize all the necessary
;	looping	information on the stack.  Conversions may have to be done
;	so that the sources are the same data type, so divide
;	the looping portion according to the data types.  Conversion to the
;	correct destination data type will be done by a JSB to a routine,
;	instead of multiplying the number of possible combinations by 4.
;
; CALLING SEQUENCE:
;
;	CALL BAS$MAT_MUL (src1_array.rx.da, src2_array.rw.da, dest_matrix.wx.da)
;
; INPUT PARAMETERS:
;
	src1_matrix = 4
	src2_matrix = 8
;
; IMPLICIT INPUTS:
;
;	Scale from the callers frame to scale double precision.
;
; OUTPUT PARAMETERS:
;
	dest_matrix = 12
;
; IMPLICIT OUTPUTS:
;
;	NONE
;
; FUNCTION VALUE:
; COMPLETION CODES:
;
;	NONE
;
; SIDE EFFECTS:
;
;	This routine calls the redimensioning routine and the array element
;	fetch and store routines and therefore may signal any of their errors.
;	It may also signal any of the errors listed in the externals section.
;	It may also cause the destination array to have different dimensions.
;
;--

	.ENTRY BAS$MAT_MUL, ^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11,IV>

;+
;	REGISTER USAGE
;	R0 - R8 destroyed by store routines
;	R9	not used
;	R10	pointer to dest matrix descriptor (except for double in which
;		case R10 is part of double value R9-R10)
;	R11	current value of inner subscript
;-

;+
; Put routine arguments into registers for ease of use.
; If block 2 of array descriptor (multipliers) is not present then error.
;-

	MOVL	src1_matrix(AP), R2		; ptr to src1 array descr
	BBC	#DSC$V_FL_BOUNDS, DSC$B_AFLAGS(R2), ERR_ARGDONMAT
						; exit if block 3 not
						; present in descriptor
	CMPB	DSC$B_DIMCT(R2), #2		; 2 dimensional?
	BNEQU	ERR_MATDIMERR			; if not, error
	MOVL	src2_matrix(AP), R3		; ptr to src2 array descr
	BBC	#DSC$V_FL_BOUNDS, DSC$B_AFLAGS(R3), ERR_ARGDONMAT
						; exit if block 3 not
						; present in descriptor
	MOVL	dest_matrix(AP), R10		; pointer to dest descriptor
	CLRQ	-(SP)				; save space for VALUE_DESC
	CLRQ	-(SP)				;	AND
	CLRQ	-(SP)				; DATA
	CLRD	-(SP)				; space for src1 element
	CLRD	-(SP)				;  it may be hfloat
	TSTD	-(SP)				; save space for scale
	CLRD	-(SP)				; reserve space to save sum
	CLRD	-(SP)				;  possible hfloat sum
	CMPB	DSC$B_DIMCT(R3), #2		; 2 dimensional?
	BEQLU	INIT_TWO_SUBS			; if 2-D continue, else
						; fall into error

ERR_MATDIMERR:
	PUSHL	#BAS$K_MATDIMERR		; Signal error, src arrays
	CALLS	#1, G^BAS$$STOP			;  don't have same # dimensns

ERR_ARGDONMAT:
	PUSHL	#BAS$K_ARGDONMAT		; signal error, 0 for dimct
	CALLS	#1, G^BAS$$STOP			; or block 2 or 3 absent

ERR_ARRMUSSAM:
	PUSHL	#BAS$K_ARRMUSSAM		; Signal error, src arrays
	CALLS	#1, G^BAS$$STOP			;  same bounds

ERR_ILLOPE:
	PUSHL	#BAS$K_ILLOPE			; Signal error, dest array is
	CALLS	#1, G^BAS$$STOP			;  as one of source arrays

;+
; There are 2 subscripts.  Check and redimension the destination array if
; necessary.  Put the upper bound for both subscripts on the
; stack and make sure that the lower bound for both subscripts will start
; at 1 (do not alter row or col 0)
;-

INIT_TWO_SUBS:
	CMPB	dsc$l_u2_2(R2), dsc$l_u1_2(R3)	; does src1 array have the same
						;  2nd upper bound as src2 array
						;  has for 1st upper bound
	BNEQU	ERR_ARRMUSSAM			; no, error
	CMPB	dsc$l_l2_2(R2), dsc$l_l1_2(R3)	; does src1 array have the same
						;  2nd lower bound as src2 array
						;  has for 1st lower bound
	BNEQU	ERR_ARRMUSSAM			; no, error
	PUSHL	dsc$l_u2_2(R3)			; 2nd upper bound
	PUSHL	dsc$l_u1_2(R2)			; 1st upper bound
	PUSHL	R10				; dest array pointer
	CALLS	#3, G^BAS$MAT_REDIM		; redimension destination
	CMPB	DSC$B_CLASS(R10), #DSC$K_CLASS_A	; is array virtual?
	BNEQU	VIRTUAL_SAME			; yes, go check virtual
						; if dest not virtual even if
						;  src is virtual pointer will
						;  be 0 and won't match
	CMPL	DSC$A_POINTER(R2), DSC$A_POINTER(R10) ; is dest same as src1
	BEQLU	ERR_ILLOPE			; yes, error
	CMPL	DSC$A_POINTER(R3), DSC$A_POINTER(R10) ; is dest same as src2
	BEQLU	ERR_ILLOPE			; yes, error
	BRB	INIT_STACK
VIRTUAL_SAME:
	CMPB	DSC$B_CLASS(R2), #DSC$K_CLASS_A	; is src1 virtual?
	BEQLU	1$				; no, cant be same
	CMPL	DSC$L_LOGUNIT(R2), DSC$L_LOGUNIT(R10) ; is dest same as src1?
	BNEQ	1$				; no
	CMPL	DSC$L_BYTEOFF(R2), DSC$L_BYTEOFF(R10) ; is dest same as src1?
						; (check logunit and byteoff)
	BEQL	ERR_ILLOPE			; yes error
1$:	CMPB	DSC$B_CLASS(R3), #DSC$K_CLASS_A	; is src2 virtual?
	BEQLU	INIT_STACK			; no, can't be same
	CMPL	DSC$L_LOGUNIT(R2), DSC$L_LOGUNIT(R10) ; is dest same as src1?
	BNEQ	INIT_STACK
	CMPL	DSC$L_BYTEOFF(R3), DSC$L_BYTEOFF(R10) ; is dest same as src2?
	BEQL	ERR_ILLOPE			; yes error
INIT_STACK:
	PUSHL	dsc$l_l1_2(R2)			; initialize current_i counter
	BGTR	1$				; not row 0 or neg
	MOVL	#1, (SP)			; start with 1
1$:	CLRL	-(SP)				; save space for current j
	PUSHL	dsc$l_u1_2(R2)			; upper_bound_i
	PUSHL	dsc$l_l2_2(R3)			; lower_bound_j
	BGTR	2$				; not row 0 or neg, do cols
	MOVL	#1, (SP)			; start with row 1
2$:	PUSHL	dsc$l_u2_2(R3)			; upper_bound_j
	PUSHL	dsc$l_l2_2(R2)			; lower_bound_k
	BGTR	3$				; not col 0 or neg
	MOVL	#1, (SP)			; start with k=1
3$:	PUSHL	dsc$l_u2_2(R2)			; upper_bound_k

;+
; Algorithm now differs according to data types
;-

SEPARATE_DTYPES:

5$:	CASEB	DSC$B_DTYPE(R2), #DSC$K_DTYPE_B, #<DSC$K_DTYPE_D - DSC$K_DTYPE_B>
2$:	.WORD	BYTE-2$				; code for byte dtype
	.WORD	WORD-2$				; code for word dtype
	.WORD	LONG-2$				; code for long dtype
	.WORD	ERR_DATTYPERR-2$		; quad not supported
	.WORD	FLOAT-2$			; code for float dtype
	.WORD	DOUBLE-2$			; code for double dtype

;+
; G and H floating fall outside the range of the CASEB.
;-

	CMPB	DSC$B_DTYPE(R2), #DSC$K_DTYPE_G
	BNEQ	3$
	BRW	GFLOAT				; code for gfloat dtype

3$:	CMPB	DSC$B_DTYPE(R2), #DSC$K_DTYPE_H
	BNEQ	4$
	BRW	HFLOAT				; code for hfloat dtype

4$:	CMPB	DSC$B_DTYPE(R2), #DSC$K_DTYPE_DSC
	BNEQ	ERR_DATTYPERR
	MOVL	4(R2), R2			; R2 <-- addr of descriptor
	BRB	5$				; CASE again on dtype in desc

ERR_DATTYPERR:
	PUSHL	#BAS$K_DATTYPERR		; Signal error, unsupported
	CALLS	#1, G^BAS$$STOP			; dtype in array desc

	.PAGE
;+
; Source1 array is a byte array.  Now differentiate on the source2 type.
;-

BYTE:	CASEB	DSC$B_DTYPE(R3), #DSC$K_DTYPE_B, #<DSC$K_DTYPE_D - DSC$K_DTYPE_B>
1$:	.WORD	BYTE_TO_BYTE-1$			; code for byte dtype
	.WORD	BYTE_TO_WORD-1$			; code for word dtype
	.WORD	BYTE_TO_LONG-1$			; code for long dtype
	.WORD	ERR_DATTYPERR-1$		; quad not supported
	.WORD	BYTE_TO_FLOAT-1$		; code for float dtype
	.WORD	BYTE_TO_DOUBLE-1$		; code for double dtype

;+
; G and H floating fall outside the range of the CASEB.
;-

	CMPB	DSC$B_DTYPE(R3), #DSC$K_DTYPE_G
	BNEQ	2$
	BRW	BYTE_TO_GFLOAT

2$:	CMPB	DSC$B_DTYPE(R3), #DSC$K_DTYPE_H
	BNEQ	3$
	BRW	BYTE_TO_HFLOAT

3$:	CMPB	DSC$B_DTYPE(R3), #DSC$K_DTYPE_DSC
	BNEQ	4$
	MOVL	4(R3), R3			; R3 <-- addr of descriptor
	BRB	BYTE				; CASE again on dtype in desc

4$:	BRW	ERR_DATTYPERR	
;+
; Now type of source1 and source2 arrays are known.  Use the macro to
; generate the code for each case
;-

	.PAGE
BYTE_TO_BYTE:	$BAS$MAT_MUL	B, B

	.PAGE
BYTE_TO_WORD:	$BAS$MAT_MUL	B, W

	.PAGE
BYTE_TO_LONG:	$BAS$MAT_MUL	B, L

	.PAGE
BYTE_TO_FLOAT:	$BAS$MAT_MUL	B, F

	.PAGE
BYTE_TO_DOUBLE:	$BAS$MAT_MUL	B, D

	.PAGE
BYTE_TO_GFLOAT: $BAS$MAT_MUL	B, G

	.PAGE
BYTE_TO_HFLOAT: $BAS$MAT_MUL	B, H
	.PAGE
;+
; Source1 array is a word array.  Now differentiate on the source2 type.
;-

WORD:	CASEB	DSC$B_DTYPE(R3), #DSC$K_DTYPE_B, #<DSC$K_DTYPE_D - DSC$K_DTYPE_B>
1$:	.WORD	WORD_TO_BYTE-1$			; code for byte dtype
	.WORD	WORD_TO_WORD-1$			; code for word dtype
	.WORD	WORD_TO_LONG-1$			; code for long dtype
	.WORD	ERR_DATTYPERR-1$		; quad not supported
	.WORD	WORD_TO_FLOAT-1$		; code for float dtype
	.WORD	WORD_TO_DOUBLE-1$		; code for double dtype

;+
; G and H floating fall outside the range of the CASEB.
;-

	CMPB	DSC$B_DTYPE(R3), #DSC$K_DTYPE_G
	BNEQ	2$
	BRW	WORD_TO_GFLOAT			; code for gfloat dtype

2$:	CMPB	DSC$B_DTYPE(R3), #DSC$K_DTYPE_H
	BNEQ	3$
	BRW	WORD_TO_HFLOAT			; code for hfloat dtype

3$:	CMPB	DSC$B_DTYPE(R3), #DSC$K_DTYPE_DSC
	BNEQ	4$
	MOVL	4(R3), R3			; R3 <-- addr of descriptor
	BRB	WORD				; CASE again on dtype in desc

4$:	BRW	ERR_DATTYPERR	

;+
; Now type of source1 and source2 arrays are known.  Use the macro to
; generate the code for each case
;-

	.PAGE
WORD_TO_BYTE:	$BAS$MAT_MUL	W, B

	.PAGE
WORD_TO_WORD:	$BAS$MAT_MUL	W, W

	.PAGE
WORD_TO_LONG:	$BAS$MAT_MUL	W, L

	.PAGE
WORD_TO_FLOAT:	$BAS$MAT_MUL	W, F

	.PAGE
WORD_TO_DOUBLE:	$BAS$MAT_MUL	W, D
	
	.PAGE
WORD_TO_GFLOAT: $BAS$MAT_MUL	W, G

	.PAGE
WORD_TO_HFLOAT: $BAS$MAT_MUL	W, H
	.PAGE
;+
; Source1 array is a longword array.  Now differentiate on the source2 type
;-

LONG:	CASEB	DSC$B_DTYPE(R3), #DSC$K_DTYPE_B, #<DSC$K_DTYPE_D - DSC$K_DTYPE_B>
1$:	.WORD	LONG_TO_BYTE-1$			; code for byte dtype
	.WORD	LONG_TO_WORD-1$			; code for word dtype
	.WORD	LONG_TO_LONG-1$			; code for long dtype
	.WORD	ERR_DATTYPERR-1$		; quad not supported
	.WORD	LONG_TO_FLOAT-1$		; code for float dtype
	.WORD	LONG_TO_DOUBLE-1$		; code for double dtype


;+
; G and H floating fall outside the range of the CASEB.
;-

	CMPB	DSC$B_DTYPE(R3), #DSC$K_DTYPE_G
	BNEQ	2$
	BRW	LONG_TO_GFLOAT			; code for gfloat dtype

2$:	CMPB	DSC$B_DTYPE(R3), #DSC$K_DTYPE_H
	BNEQ	3$
	BRW	LONG_TO_HFLOAT			; code for hfloat dtype

3$:	CMPB	DSC$B_DTYPE(R3), #DSC$K_DTYPE_DSC
	BNEQ	4$
	MOVL	4(R3), R3			; R3 <-- addr of descriptor
	BRB	LONG				; CASE again on dtype in desc

4$:	BRW	ERR_DATTYPERR	
;+
; Now type of source1 and source2 arrays are known.  Use the macro to
; generate the code for each case
;-
	.PAGE
LONG_TO_BYTE:	$BAS$MAT_MUL	L, B

	.PAGE
LONG_TO_WORD:	$BAS$MAT_MUL	L, W

	.PAGE
LONG_TO_LONG:	$BAS$MAT_MUL	L, L

	.PAGE
LONG_TO_FLOAT:	$BAS$MAT_MUL	L, F

	.PAGE
LONG_TO_DOUBLE:	$BAS$MAT_MUL	L, D

	.PAGE
LONG_TO_GFLOAT: $BAS$MAT_MUL	L, G

	.PAGE
LONG_TO_HFLOAT:	$BAS$MAT_MUL	L, H

	.PAGE
;+
; Source1 array is a floating array.  Now differentiate on the source2 type
;-

FLOAT:	CASEB	DSC$B_DTYPE(R3), #DSC$K_DTYPE_B, #<DSC$K_DTYPE_D - DSC$K_DTYPE_B>
1$:	.WORD	FLOAT_TO_BYTE-1$		; code for byte dtype
	.WORD	FLOAT_TO_WORD-1$		; code for word dtype
	.WORD	FLOAT_TO_LONG-1$		; code for long dtype
	.WORD	ERR_DATTYPERR-1$		; quad not supported
	.WORD	FLOAT_TO_FLOAT-1$		; code for float dtype
	.WORD	FLOAT_TO_DOUBL-1$		; code for double dtype

;+
; G and H floating fall outside the range of the CASEB.
;-

	CMPB	DSC$B_DTYPE(R3), #DSC$K_DTYPE_G
	BNEQ	2$
	BRW	FLOAT_TO_GFLOA

2$:	CMPB	DSC$B_DTYPE(R3), #DSC$K_DTYPE_H
	BNEQ	3$
	BRW	FLOAT_TO_HFLOA

3$:	CMPB	DSC$B_DTYPE(R3), #DSC$K_DTYPE_DSC
	BNEQ	4$
	MOVL	4(R3), R3			; R3 <-- addr of descriptor
	BRB	FLOAT				; CASE again on dtype in desc

4$:	BRW	ERR_DATTYPERR	
;+
; Now type of source1 and source2 arrays are known.  Use the macro to
; generate the code for each case
;-
	.PAGE
FLOAT_TO_BYTE:  $BAS$MAT_MUL	F, B

	.PAGE
FLOAT_TO_WORD:	$BAS$MAT_MUL	F, W

	.PAGE
FLOAT_TO_LONG:	$BAS$MAT_MUL	F, L

	.PAGE
FLOAT_TO_FLOAT:	$BAS$MAT_MUL	F, F

	.PAGE
FLOAT_TO_DOUBL: $BAS$MAT_MUL	F, D

	.PAGE
FLOAT_TO_GFLOA:	$BAS$MAT_MUL	F, G

	.PAGE
FLOAT_TO_HFLOA: $BAS$MAT_MUL	F, H

	.PAGE
;+
; Source1 array is a double array.  Now differentiate on the source2 type.
;-

DOUBLE:	CASEB	DSC$B_DTYPE(R3), #DSC$K_DTYPE_B, #<DSC$K_DTYPE_D - DSC$K_DTYPE_B>
1$:	.WORD	DOUBLE_TO_BYTE-1$		; code for byte dtype	
	.WORD	DOUBLE_TO_WORD-1$		; code for word dtype
	.WORD	DOUBLE_TO_LONG-1$		; code for long dtype
	.WORD	ERR_DATTYPERR-1$		; quad not supported
	.WORD	DOUBLE_TO_FLOA-1$		; code for float dtype
	.WORD	DOUBLE_TO_DOUBL-1$		; code for double dtype

;+
; G and H floating fall outside the range of the CASEB.
;-

	CMPB	DSC$B_DTYPE(R3), #DSC$K_DTYPE_G
	BNEQ	2$
	BRW	DOUBLE_TO_GFLOA

2$:	CMPB	DSC$B_DTYPE(R3), #DSC$K_DTYPE_H
	BNEQ	3$
	BRW	DOUBLE_TO_HFLOA

3$:	CMPB	DSC$B_DTYPE(R3), #DSC$K_DTYPE_DSC
	BNEQ	4$
	MOVL	4(R3), R3			; R3 <-- addr of descriptor
	BRB	DOUBLE				; CASE again on dtype in desc

4$:	BRW	ERR_DATTYPERR	
;+
; Now type of source1 and source2 arrays are known.  Use the macro to
; generate the code for each case
;-
	.PAGE
DOUBLE_TO_BYTE: $BAS$MAT_MUL	D, B

	.PAGE
DOUBLE_TO_WORD:	$BAS$MAT_MUL	D, W

	.PAGE
DOUBLE_TO_LONG:	$BAS$MAT_MUL	D, L

	.PAGE
DOUBLE_TO_FLOA:	$BAS$MAT_MUL	D, F

	.PAGE
DOUBLE_TO_DOUBL: $BAS$MAT_MUL	D, D

	.PAGE
DOUBLE_TO_GFLOA: $BAS$MAT_MUL	D, G

	.PAGE
DOUBLE_TO_HFLOA: $BAS$MAT_MUL	D, H
	.PAGE
;+
; Source1 array is a gfloat array.  Now differentiate on the source2 type.
;-

GFLOAT:	CASEB	DSC$B_DTYPE(R3), #DSC$K_DTYPE_B, #<DSC$K_DTYPE_D - DSC$K_DTYPE_B>
1$:	.WORD	GFLOAT_TO_BYTE-1$		; code for byte dtype
	.WORD	GFLOAT_TO_WORD-1$		; code for word dtype
	.WORD	GFLOAT_TO_LONG-1$		; code for long dtype
	.WORD	ERR_DATTYPERR-1$		; quad not supported
	.WORD	GFLOAT_TO_FLOAT-1$		; code for float dtype
	.WORD	GFLOAT_TO_DOUBL-1$		; code for double dtype

;+
; G and H floating fall outside the range of the CASEB.
;-

	CMPB	DSC$B_DTYPE(R3), #DSC$K_DTYPE_G
	BNEQ	2$
	BRW	GFLOAT_TO_GFLOA

2$:	CMPB	DSC$B_DTYPE(R3), #DSC$K_DTYPE_H
	BNEQ	3$
	BRW	GFLOAT_TO_HFLOA

3$:	CMPB	DSC$B_DTYPE(R3), #DSC$K_DTYPE_DSC
	BNEQ	4$
	MOVL	4(R3), R3			; R3 <-- addr of descriptor
	BRB	GFLOAT				; CASE again on dtype in desc

4$:	BRW	ERR_DATTYPERR	
;+
; Now type of source1 and source2 arrays are known.  Use the macro to
; generate the code for each case
;-
	.PAGE
GFLOAT_TO_BYTE: $BAS$MAT_MUL	G, B

	.PAGE
GFLOAT_TO_WORD:	$BAS$MAT_MUL	G, W

	.PAGE
GFLOAT_TO_LONG:	$BAS$MAT_MUL	G, L

	.PAGE
GFLOAT_TO_FLOAT:$BAS$MAT_MUL	G, F

	.PAGE
GFLOAT_TO_DOUBL:$BAS$MAT_MUL	G, D

	.PAGE
GFLOAT_TO_GFLOA:$BAS$MAT_MUL	G, G

	.PAGE
GFLOAT_TO_HFLOA:$BAS$MAT_MUL	G, H

	.PAGE
;+
; Source1 array is an hfloat array.  Now differentiate on the source2 type.
;-

HFLOAT:	CASEB	DSC$B_DTYPE(R3), #DSC$K_DTYPE_B, #<DSC$K_DTYPE_D - DSC$K_DTYPE_B>
1$:	.WORD	HFLOAT_TO_BYTE-1$		; code for byte dtype
	.WORD	HFLOAT_TO_WORD-1$		; code for word dtype
	.WORD	HFLOAT_TO_LONG-1$		; code for long dtype
	.WORD	ERR_DATTYPERR-1$		; quad not supported
	.WORD	HFLOAT_TO_FLOAT-1$		; code for float dtype
	.WORD	HFLOAT_TO_DOUBL-1$		; code for double dtype

;+
; G and H floating fall outside the range of the CASEB.
;-

	CMPB	DSC$B_DTYPE(R3), #DSC$K_DTYPE_G
	BNEQ	2$
	BRW	HFLOAT_TO_GFLOA

2$:	CMPB	DSC$B_DTYPE(R3), #DSC$K_DTYPE_H
	BNEQ	3$
	BRW	HFLOAT_TO_HFLOA

3$:	CMPB	DSC$B_DTYPE(R3), #DSC$K_DTYPE_DSC
	BNEQ	4$
	MOVL	4(R3), R3			; R3 <-- addr of descriptor
	BRB	HFLOAT				; CASE again on dtype in desc

4$:	BRW	ERR_DATTYPERR	
;+
; Now type of source1 and source2 arrays are known.  Use the macro to
; generate the code for each case
;-
	.PAGE
HFLOAT_TO_BYTE: $BAS$MAT_MUL	H, B

	.PAGE
HFLOAT_TO_WORD:	$BAS$MAT_MUL	H, W

	.PAGE
HFLOAT_TO_LONG:	$BAS$MAT_MUL	H, L

	.PAGE
HFLOAT_TO_FLOAT:$BAS$MAT_MUL	H, F

	.PAGE
HFLOAT_TO_DOUBL:$BAS$MAT_MUL	H, D

	.PAGE
HFLOAT_TO_GFLOA:$BAS$MAT_MUL	H, G

	.PAGE
HFLOAT_TO_HFLOA:$BAS$MAT_MUL	H, H

;+
; Add has been in byte.  Determine destination type to convert to dest.
;-

DEST_CASE_B:
	MOVB	current_sum(R5), R0		; get # to store in R0
	MOVL	R10, R6				; save original pointer
5$:	CASEB	DSC$B_DTYPE(R6), #DSC$K_DTYPE_B, #<DSC$K_DTYPE_D - DSC$K_DTYPE_B>
1$:	.WORD	STORE_BYTE-1$			; no conversion needed
	.WORD	DEST_B_TO_W-1$			; code for word dtype
	.WORD	DEST_B_TO_L-1$			; code for long dtype
	.WORD	ERR_DATTYPERR-1$		; quad not supported
	.WORD	DEST_B_TO_F-1$			; code for float dtype
	.WORD	DEST_B_TO_D-1$			; code for double dtype

;+
; G and H floating fall outside the range of the CASEB.
;-

	CMPB	DSC$B_DTYPE(R6), #DSC$K_DTYPE_G
	BNEQ	2$
	BRW	DEST_B_TO_G

2$:	CMPB	DSC$B_DTYPE(R6), #DSC$K_DTYPE_H
	BNEQ	3$
	BRW	DEST_B_TO_H

3$:	CMPB	DSC$B_DTYPE(R6), #DSC$K_DTYPE_DSC
	BNEQ	4$
	MOVL	4(R6), R6			; R6 <-- addr of descriptor
	BRB	5$				; CASE again for dtype in desc

4$:	BRW	ERR_DATTYPERR

;+
;+
; Add has been in word.  Determine destination type to convert to dest.
;-

DEST_CASE_W:
	MOVW	current_sum(R5), R0		; get # to store in R0
	MOVL	R10, R6				; save original pointer
5$:	CASEB	DSC$B_DTYPE(R6), #DSC$K_DTYPE_B, #<DSC$K_DTYPE_D - DSC$K_DTYPE_B>
1$:	.WORD	DEST_W_TO_B-1$			; code for byte dtype
	.WORD	STORE_WORD-1$			; no conversion needed
	.WORD	DEST_W_TO_L-1$			; code for long dtype
	.WORD	ERR_DATTYPERR-1$		; quad not supported
	.WORD	DEST_W_TO_F-1$			; code for float dtype
	.WORD	DEST_W_TO_D-1$			; code for double dtype

;+
; G and H floating fall outside the range of the CASEB.
;-

	CMPB	DSC$B_DTYPE(R6), #DSC$K_DTYPE_G
	BNEQ	2$
	BRW	DEST_W_TO_G

2$:	CMPB	DSC$B_DTYPE(R6), #DSC$K_DTYPE_H
	BNEQ	3$
	BRW	DEST_W_TO_H

3$:	CMPB	DSC$B_DTYPE(R6), #DSC$K_DTYPE_DSC
	BNEQ	4$
	MOVL	4(R6), R6			; R6 <-- addr of descriptor
	BRB	5$				; CASE again for dtype in desc

4$:	BRW	ERR_DATTYPERR

;+
; Add has been in long.  Determine destination type to convert to dest.
;-

DEST_CASE_L:
	MOVL	current_sum(R5), R0		; get # to store in R0
	MOVL	R10, R6				; save original pointer
5$:	CASEB	DSC$B_DTYPE(R6), #DSC$K_DTYPE_B, #<DSC$K_DTYPE_D - DSC$K_DTYPE_B>
1$:	.WORD	DEST_L_TO_B-1$			; code for byte dtype
	.WORD	DEST_L_TO_W-1$			; code for word dtype
	.WORD	STORE_LONG-1$			; no conversion needed
	.WORD	ERR_DATTYPERR-1$		; quad not supported
	.WORD	DEST_L_TO_F-1$			; code for float dtype
	.WORD	DEST_L_TO_D-1$			; code for double dtype
;+
; G and H floating fall outside the range of the CASEB.
;-

	CMPB	DSC$B_DTYPE(R6), #DSC$K_DTYPE_G
	BNEQ	2$
	BRW	DEST_L_TO_G

2$:	CMPB	DSC$B_DTYPE(R6), #DSC$K_DTYPE_H
	BNEQ	3$
	BRW	DEST_L_TO_H

3$:	CMPB	DSC$B_DTYPE(R6), #DSC$K_DTYPE_DSC
	BNEQ	4$
	MOVL	4(R6), R6			; R6 <-- addr of descriptor
	BRB	5$				; CASE again for dtype in desc

4$:	BRW	ERR_DATTYPERR


;+
; Add has been in float.  Determine destination type to convert to dest.
;-

DEST_CASE_F:
	MOVF	current_sum(R5), R0		; get # to store in R0
	MOVL	R10, R6				; save original pointer
5$:	CASEB	DSC$B_DTYPE(R6), #DSC$K_DTYPE_B, #<DSC$K_DTYPE_D - DSC$K_DTYPE_B>
1$:	.WORD	DEST_F_TO_B-1$			; code for byte dtype
	.WORD	DEST_F_TO_W-1$			; code for word dtype
	.WORD	DEST_F_TO_L-1$			; code for long dtype
	.WORD	ERR_DATTYPERR-1$		; quad not supported
	.WORD	STORE_FLOAT-1$			; no conversion needed
	.WORD	DEST_F_TO_D-1$			; code for double dtype
;+
; G and H floating fall outside the range of the CASEB.
;-

	CMPB	DSC$B_DTYPE(R6), #DSC$K_DTYPE_G
	BNEQ	2$
	BRW	DEST_F_TO_G

2$:	CMPB	DSC$B_DTYPE(R6), #DSC$K_DTYPE_H
	BNEQ	3$
	BRW	DEST_F_TO_H

3$:	CMPB	DSC$B_DTYPE(R6), #DSC$K_DTYPE_DSC
	BNEQ	4$
	MOVL	4(R6), R6			; R6 <-- addr of descriptor
	BRB	5$				; CASE again for dtype in desc

4$:	BRW	ERR_DATTYPERR


;+
; Add has been in double.  Determine destination type to convert to dest.
;-

DEST_CASE_D:
	MOVD	current_sum(R5), R0		; get # to store in R0&R1
	MOVL	dest_matrix(AP), R10		; point to dest matrix
	MOVL	R10, R6				; save original pointer
5$:	CASEB	DSC$B_DTYPE(R6), #DSC$K_DTYPE_B, #<DSC$K_DTYPE_D - DSC$K_DTYPE_B>
1$:	.WORD	DEST_D_TO_B-1$			; code for byte dtype
	.WORD	DEST_D_TO_W-1$			; code for word dtype
	.WORD	DEST_D_TO_L-1$			; code for long dtype
	.WORD	ERR_DATTYPERR-1$		; quad not supported
	.WORD	DEST_D_TO_F-1$			; code for float dtype
	.WORD	STORE_DOUBLE-1$			; no conversion needed
;+
; G and H floating fall outside the range of the CASEB.
;-

	CMPB	DSC$B_DTYPE(R6), #DSC$K_DTYPE_G
	BNEQ	2$
	BRW	DEST_D_TO_G

2$:	CMPB	DSC$B_DTYPE(R6), #DSC$K_DTYPE_H
	BNEQ	3$
	BRW	DEST_D_TO_H

3$:	CMPB	DSC$B_DTYPE(R6), #DSC$K_DTYPE_DSC
	BNEQ	4$
	MOVL	4(R6), R6			; R6 <-- addr of descriptor
	BRB	5$				; CASE again for dtype in desc

4$:	BRW	ERR_DATTYPERR


;+
; Add has been in gfloat.  Determine destination type to convert to dest.
;-

DEST_CASE_G:
	MOVG	current_sum(R5), R0		; get # to store in R0
	MOVL	R10, R6				; save original pointer
5$:	CASEB	DSC$B_DTYPE(R6), #DSC$K_DTYPE_B, #<DSC$K_DTYPE_D - DSC$K_DTYPE_B>
1$:	.WORD	DEST_G_TO_B-1$			; code for byte dtype
	.WORD	DEST_G_TO_W-1$			; code for word dtype
	.WORD	DEST_G_TO_L-1$			; code for long dtype
	.WORD	ERR_DATTYPERR-1$		; quad not supported
	.WORD	DEST_G_TO_F-1$			; code for float dtype
	.WORD	DEST_G_TO_D-1$			; code for double dtype

;+
; G and H floating fall outside the range of the CASEB.
;-

	CMPB	DSC$B_DTYPE(R6), #DSC$K_DTYPE_G
	BNEQ	2$
	BRW	STORE_GFLOAT

2$:	CMPB	DSC$B_DTYPE(R6), #DSC$K_DTYPE_H
	BNEQ	3$
	BRW	DEST_G_TO_H

3$:	CMPB	DSC$B_DTYPE(R6), #DSC$K_DTYPE_DSC
	BNEQ	4$
	MOVL	4(R6), R6			; R6 <-- addr of descriptor
	BRB	5$				; CASE again for dtype in desc

4$:	BRW	ERR_DATTYPERR

;+
; Add has been in hfloat.  Determine destination type to convert to dest.
;-

DEST_CASE_H:
	MOVH	current_sum(R5), R0		; get # to store in R0
	MOVL	R10, R6				; save original pointer
5$:	CASEB	DSC$B_DTYPE(R6), #DSC$K_DTYPE_B, #<DSC$K_DTYPE_D - DSC$K_DTYPE_B>
1$:	.WORD	DEST_H_TO_B-1$			; code for byte dtype
	.WORD	DEST_H_TO_W-1$			; code for word dtype
	.WORD	DEST_H_TO_L-1$			; code for long dtype
	.WORD	ERR_DATTYPERR-1$		; quad not supported
	.WORD	DEST_H_TO_F-1$			; code for float dtype
	.WORD	DEST_H_TO_D-1$			; code for double dtype

;+
; G and H floating fall outside the range of the CASEB.
;-

	CMPB	DSC$B_DTYPE(R6), #DSC$K_DTYPE_G
	BNEQ	2$
	BRW	DEST_H_TO_G

2$:	CMPB	DSC$B_DTYPE(R6), #DSC$K_DTYPE_H
	BNEQ	3$
	BRW	STORE_HFLOAT

3$:	CMPB	DSC$B_DTYPE(R6), #DSC$K_DTYPE_DSC
	BNEQ	4$
	MOVL	4(R6), R6			; R6 <-- addr of descriptor
	BRB	5$				; CASE again for dtype in desc

4$:	BRW	ERR_DATTYPERR

DEST_W_TO_B:	
	CVTWB	R0, R0				; convert
	BRB	STORE_BYTE			; go store

DEST_L_TO_B:
	CVTLB	R0, R0				; convert
	BRB	STORE_BYTE			; go store

DEST_F_TO_B:
	CVTFB	R0, R0				; convert
	BRB	STORE_BYTE			; go store

DEST_D_TO_B:
	CVTDB	R0, R0				; convert
	BRB	STORE_BYTE			; go store

DEST_G_TO_B:
	CVTGB	R0, R0				; convert
	BRB	STORE_BYTE			; go store

DEST_H_TO_B:
	CVTHB	R0, R0				; convert
						; fall into store

STORE_BYTE:
	MOVL	R10, R1				; pointer to dest descriptor
	MOVL	current_i(R5), R2		; current row
	MOVL	current_j(R5), R3		; current column
	MOVB	R0, DATA(SP)
	STORE	B
	RSB					; go continue loop

DEST_B_TO_W:
	CVTBW	R0, R0				; convert
	BRB	STORE_WORD			; go store

DEST_L_TO_W:
	CVTLW	R0, R0				; convert
	BRB	STORE_WORD			; go store

DEST_F_TO_W:
	CVTFW	R0, R0				; convert
	BRB	STORE_WORD			; go store

DEST_D_TO_W:
	DIVD2	scale(R5), R0			; descale for dest
	CVTDW	R0, R0				; convert to word
	BRB	STORE_WORD			; go store			

DEST_G_TO_W:
	CVTGW	R0, R0				; convert
	BRB	STORE_WORD			; go store

DEST_H_TO_W:
	CVTHW	R0, R0				; convert
						; fall into store
STORE_WORD:	
	MOVL	R10, R1				; pointer to dest descriptor
	MOVL	current_i(R5), R2		; current row
	MOVL	current_j(R5), R3		; current column
	MOVW	R0, DATA(SP)
	STORE	W				; store
	RSB					; go continue loop

DEST_B_TO_L:
	CVTBL	R0, R0				; convert
	BRB	STORE_LONG			; go store

DEST_W_TO_L:
	CVTWL	R0, R0				; convert
	BRB	STORE_LONG			; go store

DEST_F_TO_L:
	CVTFL	R0, R0				; convert
	BRB	STORE_LONG			; go store

DEST_D_TO_L:
	DIVD2	scale(R5), R0			; descale for dest
	CVTDL	R0, R0				; convert
	BRB	STORE_LONG			; go store

DEST_G_TO_L:
	CVTGL	R0, R0				; convert
	BRB	STORE_LONG			; go store

DEST_H_TO_L:
	CVTHL	R0, R0				; convert
						; fall into store			

STORE_LONG:
	MOVL	R10, R1				; pointer to dest descriptor
	MOVL	current_i(R5), R2		; current row
	MOVL	current_j(R5), R3		; current column
	MOVL	R0, DATA(SP)
	STORE	L				; store
	RSB					; go continue loop

DEST_B_TO_F:
	CVTBF	R0, R0				; convert
	BRB	STORE_FLOAT			; go store

DEST_W_TO_F:
	CVTWF	R0, R0				; convert
	BRB	STORE_FLOAT			; go store

DEST_L_TO_F:
	CVTLF	R0, R0				; convert
	BRB	STORE_FLOAT			; go store

DEST_D_TO_F:
	CVTDF	R0, R0				; convert
	BRB	STORE_FLOAT			; go store

DEST_G_TO_F:
	CVTGF	R0, R0				; convert
	BRB	STORE_FLOAT			; go store

DEST_H_TO_F:
	CVTHF	R0, R0				; convert
						; fall into store			

STORE_FLOAT:
	MOVL	R10, R1				; pointer to dest descriptor
	MOVL	current_i(R5), R2		; current row
	MOVL	current_j(R5), R3		; current column
	MOVF	R0, DATA(SP)
	STORE	F				; store
	RSB					; go continue loop

DEST_B_TO_D:
	CVTBD	R0, R0				; save double
	MULD2	scale(R5), R0			; scale for dest
						;  no integerize necessary
	BRB	STORE_DOUBLE			; go store

DEST_W_TO_D:
	CVTWD	R0, R0				; save double
	MULD2	scale(R5), R0			; scale for dest
						;  no integerize necessary
	BRB	STORE_DOUBLE			; go store

DEST_L_TO_D:
	CVTLD	R0, R0				; save double
	MULD2	scale(R5), R0			; scale for dest
						;  no integerize necessary
	BRB	STORE_DOUBLE			; go store

DEST_F_TO_D:
	CVTFD	R0, R0				; save double
	MULD2	scale(R5), R0			; scale for dest
	CMPD	scale(R5), #1			; is the scale 0?
	BEQL    1$				; yes, do not integerize
	JSB	G^MTH$DINT_R4			; no, integerize
1$:	BRB	STORE_DOUBLE			; go store

DEST_G_TO_D:
	;+
	; Note the intermediate conversion to hfloat.
	;-
	MOVL	R2, -(SP)			; save regs which CVTGH
	MOVL	R3, -(SP)			;  will destroy
	CVTGH	R0, R0				; cvt gfloat to hfloat
	CVTHD 	R0, R0				; cvt to desired double
	MOVL	(SP)+, R3			; restore regs
	MOVL	(SP)+, R2	
	MULD2	scale(R5), R0			; scale for dest
	CMPD	scale(R5), #1			; scale 0?
	BEQL	STORE_DOUBLE			; yes, don't integerize
	MOVL	R4, -(SP)			; save R4
	JSB	G^MTH$DINT_R4			; integerize
	MOVL	(SP)+, R4			; restore R4
	BRW 	STORE_DOUBLE

DEST_H_TO_D:
	CVTHD	R0, R0				; save double
	MULD2	scale(R5), R0			; scale for dest
	CMPD	scale(R5), #1			; is the scale 0?
	BEQL	STORE_DOUBLE			; yes, do not integerize
	JSB	G^MTH$DINT_R4			; no, integerize
						; fall into store
STORE_DOUBLE:
	MOVL	R10, R2				; pointer to dest descriptor
	MOVL	current_i(R5), R3		; current row
	MOVL	current_j(R5), R4		; current column
	MOVD	R0, DATA(SP)
	STORE	D				; store
	RSB					; go continue loop

DEST_B_TO_G:
	CVTBG	R0, R0				; convert
	BRB	STORE_GFLOAT			; go store

DEST_W_TO_G:
	CVTWG	R0, R0				; convert
	BRB	STORE_GFLOAT			; go store

DEST_L_TO_G:
	CVTLG	R0, R0				; convert
	BRB	STORE_GFLOAT			; go store

DEST_F_TO_G:
	CVTFG	R0, R0				; convert
	BRB	STORE_GFLOAT			; go store

DEST_D_TO_G:
	;+
	; Note the intermediate conversion to hfloat.
	;-
	MOVL	R2, -(SP)			; save regs which CVTDH
	MOVL	R3, -(SP)			;  will destroy
	CVTDH	R0, R0				; cvt dbl to hfloat
	CVTHG 	R0, R0				; cvt to desired gfloat
	MOVL	(SP)+, R3			; restore regs
	MOVL	(SP)+, R2	
	BRW 	STORE_GFLOAT

DEST_H_TO_G:
	CVTHG	R0, R0				; convert
						; fall into store			

STORE_GFLOAT:
	MOVL	R10, R2				; pointer to dest descriptor
	MOVL	current_i(R5), R3		; current row
	MOVL	current_j(R5), R4		; current column
	MOVG	R0, DATA(SP)
	STORE	G
	RSB					; go continue loop

DEST_B_TO_H:
	CVTBH	R0, R0				; convert
	BRB	STORE_HFLOAT			; go store

DEST_W_TO_H:
	CVTWH	R0, R0				; convert
	BRB	STORE_HFLOAT			; go store

DEST_L_TO_H:
	CVTLH	R0, R0				; convert
	BRB	STORE_HFLOAT			; go store

DEST_F_TO_H:
	CVTFH	R0, R0				; convert
	BRB	STORE_HFLOAT			; go store

DEST_D_TO_H:
	CVTDH	R0, R0				; convert
	BRB	STORE_HFLOAT			; go store

DEST_G_TO_H:
	CVTGH	R0, R0				; convert
						; fall into store			

STORE_HFLOAT:
	MOVL	R10, R4				; pointer to dest descriptor
	MOVL	current_j(R5), R6		; current column
	MOVL	current_i(R5), R5		; current row
	MOVH	R0, DATA(SP)
	STORE	H
	RSB					; go continue loop
	.END
