	.TITLE	MSCP - MSCP Server - Emulator
	.IDENT	'V04-001'

;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
;
; FACILITY:	MSCP Server
;
; ABSTRACT:
;
;	This program implements an MSCP(Mass Storage Control Protocol) server.
;	It accepts as input valid MSCP command packets.  It then accesses the
;	disk(s) connected to it to perform the indicated operations.  It
;	returns MSCP status packets and possibly data to the driver.
;
; ENVIORNMENT:	User mode
;
; AUTHOR:	Kerbey T. Altmann
;
; CREATION DATE:06-AUG-1980
;
; MODIFIED BY:
;
;	V04-001	DWT0240		David W. Thiel		7-Sep-1984
;		Disable advertisement of volume shadowing capabilities.
;
;	V03-015	DWT0232		David W. Thiel/Ellen M. Batbouta	31-Aug-1984
;		Update storage allocation scheme.  Correct references
;		to CDRP$L_CDT and CDRP$L_CDTX.  Tie local CDRP
;		definitions to global symbols better.  Detect and
;		bugcheck when response sent using stale CDT address.
;		Deal with CDRP$W_STATE more rigorously.  Add
;		bug traps to packet deallocation routine.  Correct
;		packet initialization on invalid commands.  Support
;		determine access paths.  Include every incoming
;		message in OPC_COUNT.  Add reference count to HQB.
;		Adjust values of PACKETS and SMALL to guarantee that
;		things will not hang.  Make acess command return
;		invalid opcode.  Validate I/O function code before
;		queuing request to driver.  Return correct setting
;		of MSCP$B_CPYS for UDA disks.  Add many bug traps.
;
;	V03-014 EMB0108		Ellen M. Batbouta	19-JUL-1984
;		Check for mount verification in progress on a local
;		device in routines, NSEQ and NSEQB.  If MV is in
;		progress, mark unit as available and return without
;		processing the request.  This prevents a deadlock 
;		situation.
;
;	V03-013	KTA3130		Kerbey T. Altmann	15-May-1984
;		Fix error in subcode.
;
;	V03-012	KTA3127		Kerbey T. Altmann	23-Apr-1984
;		Fix problem with VC error.
;
;	V03-011	KTA3116		Kerbey T. Altmann	02-Apr-1984
;		Decrement UCB queue length cell, and add entry to
;		error table for SS$_TIMEOUT.
;
;	V03-010	KTA3112		Kerbey T. Altmann	12-Mar-1984
;		Redo way UQB pointers are handled.  Also redo handling
;		of blocked commands.
;
;	V03-009	KTA3108		Kerbey T. Altmann	06-Mar-1984
;		Fix two small bugs and allow for new error return from
;		IO$_PACKACK.
;
;	V03-008	KTA3089		Kerbey T. Altmann	12-Nov-1983
;		Rewrite to add shadowing.
;
;	V03-007	ROW0278		Ralph O. Weber		12-JAN-1984
;		Remove reference to MSCP$M_UF_INACT, the inactive shadow set 
;		unit flag.  This is no longer a unit flag.
;
;	V03-006	ROW0246		Ralph O. Weber		26-OCT-1983
;		Move the "no units at this address" exit label in GET_UNIT_STS 
;		such that a "next unit modifier" get unit status command gets 
;		a zero unit number returned when there are no units to 
;		describe.
;
;	V03-005	ROW0236		Ralph O. Weber		10-OCT-1983
;		Move increment of number of online hosts counter in UQB to 
;		before increment of UCB$B_ONLCNT in online routine.  Also make 
;		increment of UCB$B_ONLCNT conditional on UQB$B_HOST_CNT 
;		indicating that this is the first host to bring the unit 
;		online.  This makes online operations consistant with their 
;		description by Kerbey and with the operations performed when a 
;		available command is processed.
;
;	V03-004	KTA3081		Kerbey T. Altmann	13-Sep-1983
;		Upgrade AVAIL support. Add underpinnings for shadowing.
;
;	V03-003	SSA0001		Stan Amway		12-Sep-1983
;		Add I/O performance monitoring support.
;		Redefined CDRP$L_LBN to avoid conflicting use
;		of CDRP$L_SEQNUM/IRP$L_SEQNUM by PMS routines.
;
;	V03-002	KTA3076		Kerbey T. Altmann	12-Aug-1983
;		Add support for explicit PACK_ACK and AVAIL.
;		Redo error routines.  Return ALLOCLASS.
;
;	V03-001	KTA3070		Kerbey T. Altmann	09-Jul-1983
;		Fix bug in host que search.
;
;--
	.PAGE
	.SBTTL	DECLARATIONS

;
; INCLUDE FILES:
;

	.NOCROSS
	$CDRPDEF
	$CDTDEF
	$DDTDEF
	$DEVDEF
	$DYNDEF
	$IODEF
	$IPLDEF
	$IRPDEF
	$MSCPDEF
	$PDTDEF
	$PRDEF
	$SCSDEF			; SCS message header definitions
	$SLVDEF
	$SSDEF
	$UCBDEF
	$VADEF

	$MSUDEF
	$HQBDEF
	$UQBDEF

;
; MACROS:
;

	.MACRO	BLOCKH
	 BSBW	BLOCKEDH
	.ENDM

	.MACRO	BLOCKT
	 BSBW	BLOCKEDT
	.ENDM

	.MACRO	WFINT
	 BSBW	WAIT_FOR_INT
	.ENDM

	.MACRO	WFINTX
	 BSBW	WAIT_FOR_INTX
	.ENDM
;
	.MACRO	QUE_HEAD LABEL
LABEL:	.LONG	LABEL-MSCP_BEGIN
	.LONG	LABEL-MSCP_BEGIN
	.ENDM

	.MACRO	ACTION,SYSERR,MSCPERR,ROUTINE
	 .WORD	SYSERR
	 .WORD	MSCPERR
	 .IF B ROUTINE
	  .WORD	0
	 .IFF
	  .WORD	ROUTINE-.
	 .ENDC
	.ENDM		

;
; EQUATED SYMBOLS:
;

	HOSTSET		=	<MSCP$M_UF_CMPRD!-
				 MSCP$M_UF_CMPWR!-
				 MSCP$M_UF_576!-
				 MSCP$M_UF_SCCHH!-
				 MSCP$M_UF_SCCHL!-
				 MSCP$M_UF_WBKNV!-
				 MSCP$M_UF_WRTPS>

	NONHOSTSET	=	<MSCP$M_UF_REPLC!-
				 MSCP$M_UF_RMVBL!-
				 MSCP$M_UF_WRTPH!-
				 MSCP$M_UF_SSMEM!-
				 MSCP$M_UF_SSMST>

;
	CDRP$L_MSGBUFX	=	CDRP$L_AST
	CDRP$L_BUFLEN	=	CDRP$L_ASTPRM
	CDRP$L_BUFADR	=	CDRP$L_WIND
	CDRP$B_SHDW_CNT	=	CDRP$B_EFN
	CDRP$L_UQB	=	CDRP$L_IOSB
	CDRP$W_STATE	=	CDRP$L_BCNT+4
	CDRP$L_UQB_FL	=	CDRP$L_SEGVBN
	CDRP$L_UQB_BL	=	CDRP$L_DIAGBUF
	CDRP$L_CMD_STS	=	CDRP$L_EXTEND
	CDRP$W_SLOT	=	CDRP$L_ARB
	CDRP$B_FLAGS	=	CDRP$L_ARB+2
	CDRP$B_OPCODE	=	CDRP$L_ARB+3
;
; Define MSCP server private areas beyond normal CDRP fields
;
	CDRP$L_LBN	=	CDRP$K_CD_LEN
	CDRP$L_SHDW_LNK	=	CDRP$L_LBN+4
	CDRP$L_FPCX	=	CDRP$L_SHDW_LNK+4
	CDRP$L_FR3X	=	CDRP$L_FPCX+4
	CDRP$L_FR4X	=	CDRP$L_FR3X+4
	CDRP$L_SAVD_RTX	=	CDRP$L_FR4X+4
	CDRP$L_CDTX	=	CDRP$L_SAVD_RTX+4
	CDRP$L_XCT_LENX	=	CDRP$L_CDTX+4
	CDRP$B_LBUFF	=	CDRP$L_XCT_LENX+4
	CDRP$L_STRT_UQB	=	CDRP$B_LBUFF+12
	CDRP$L_MST_UQB	=	CDRP$L_STRT_UQB+4
	CDRP$L_HQB	=	CDRP$L_MST_UQB+4
BIG_CDRP =		<CDRP$L_HQB+4>-CDRP$L_IOQFL

	IRP$B_SHDW_CNT	=	CDRP$B_SHDW_CNT-CDRP$L_IOQFL
	IRP$L_UQB	=	CDRP$L_UQB-CDRP$L_IOQFL
	IRP$W_STATE	=	CDRP$W_STATE-CDRP$L_IOQFL
	IRP$W_SLOT	=	CDRP$W_SLOT-CDRP$L_IOQFL
	IRP$B_FLAGS	=	CDRP$B_FLAGS-CDRP$L_IOQFL
	IRP$L_LBN	=	CDRP$L_LBN-CDRP$L_IOQFL
	IRP$L_SHDW_LNK	=	CDRP$L_SHDW_LNK-CDRP$L_IOQFL
	IRP$L_FPCX	=	CDRP$L_FPCX-CDRP$L_IOQFL
	IRP$L_MAINCDRP	=	CDRP$L_FR3X-CDRP$L_IOQFL
	IRP$L_FR4X	=	CDRP$L_FR4X-CDRP$L_IOQFL
	ASSUME <IRP$L_FR4X+4> LE IRP$C_LENGTH

	CDRP$V_SLAVE	=	0	; This is a slave IRP
	CDRP$V_BUFFER	=	1	; This CDRP has a buffer
;	CDRP$V_		=	2	;
;	CDRP$V_		=	3	;
	CDRP$V_ABORT	=	4	; This CDRP has been aborted
	CDRP$V_NOHSTBUF	=	5	; This CDRP has no host buffer

	CDRP$K_ST_MEM_WAIT =	0	; Buffer memory wait
	CDRP$K_ST_MAP_WAIT =	1	; SCS mapping resource wait
	CDRP$K_ST_DRVRD_WAIT =	2	; Disk read wait
	CDRP$K_ST_DATA_WAIT =	3	; SCS data transfer wait
	CDRP$K_ST_DRVWRT_WAIT =	4	; Disk write wait
	CDRP$K_ST_MSG_WAIT =	5	; Response message credit wait
	CDRP$K_ST_SHQ_QUE =	6	; Special holding queue wait
	CDRP$K_ST_BLK_QUE =	7	; Blocked queue wait
	CDRP$K_ST_ONBLK_QUE =	8	; Online-copy blocked queue
	CDRP$K_ST_MSG1_WAIT =	9	; Attention message credit/buffer wait
	CDRP$K_ST_INVALID =	63	; Invalid state

;
; EXTERNAL SYMBOLS:
;

	.CROSS
	.DEFAULT DISPLACEMENT WORD

	.PAGE
	.SBTTL	COMMUNICATIONS AREA

	.PSECT	MSCP$CODE,PAGE

MSCP_BEGIN:
MSCP_COMM_AREA:

	PRMSW 	= 1

	SLVTAB	END	= MSCP_END,-
		INITRTN	= MSCP_START,-
		SUBTYP	= DYN$C_LC_MSCP,-
		FACILITY= <MSCP_SERVER>

	LOADVEC	TYPE	  = SLV$K_SDATA,-
		ENTRY	  = SCS$GL_MSCP,-
		SEC_LABEL = MSCP_BEGIN
		DEF_RTN	  = 0

	.LONG	-1,-1,-1

	.ALIGN	QUAD

	.=MSCP_COMM_AREA+MSU$L_STATE
STATE:
	.LONG	0

	.=MSCP_COMM_AREA+MSU$W_PACKET
PACKET:	.WORD	0

	.=MSCP_COMM_AREA+MSU$W_INI_PKT
INI_PKT:				; Number of allocated (free+in-use) packets
	.WORD	0

	.=MSCP_COMM_AREA+MSU$W_NUM_PKT
NUM_PKT:				; Number of free packets
	.WORD	0

	.=MSCP_COMM_AREA+MSU$W_MAX_PKT
MAX_PKT:				; Maximum number of packets to cache
	.WORD	0

	.=MSCP_COMM_AREA+MSU$W_INI_HOST
INI_HOST:
	.WORD	0

	.=MSCP_COMM_AREA+MSU$W_NUM_HOST
NUM_HOST:
	.WORD	0

	.=MSCP_COMM_AREA+MSU$L_BUFF_HEAD
BUFF_HEAD:
	.LONG	0

	.=MSCP_COMM_AREA+MSU$L_MAX_BUF
MAX_BUF:
	.LONG	0

	.=MSCP_COMM_AREA+MSU$L_SMALL
SMALL:
	.LONG	0

	.=MSCP_COMM_AREA+MSU$L_FRACTION
FRACTION:
	.LONG	0

	.=MSCP_COMM_AREA+MSU$W_NUM_QUE
NUM_QUE:
	.WORD	0

	.=MSCP_COMM_AREA+MSU$W_MAX_QUE
MAX_QUE:
	.WORD	0
	.LONG	0			; Reserved

	.=MSCP_COMM_AREA+MSU$L_CDSV_SIZE
CDSV_SIZE:
	.LONG	0

	.=MSCP_COMM_AREA+MSU$L_CDRP_SAVE
CDRP_SAVE:
	.LONG	0

	.=MSCP_COMM_AREA+MSU$L_CDRP_LIST
QUEUES:	QUE_HEAD CDRP_LIST
	.=MSCP_COMM_AREA+MSU$L_MEM_WAIT
	QUE_HEAD MEM_WAIT
	.=MSCP_COMM_AREA+MSU$L_UQB_LIST
	QUE_HEAD UQB_LIST
QUE_NUM = <.-QUEUES>/8
	ASSUME MSU$C_NUMQUE EQ QUE_NUM

	.=MSCP_COMM_AREA+MSU$L_HOST_DSBL
HOST_DSBL:
	.LONG	0

	.=MSCP_COMM_AREA+MSU$L_UNIT_VEC-4
	.LONG	0			; *** ENTRY FOR UNIT # -1 !!!!!
UNIT_VEC:
	.BLKL	2*MSU$K_MAX_UNIT

	.=MSCP_COMM_AREA+MSU$L_HOST_VEC
HOST_VEC:
	.BLKL	2*MSU$K_MAX_HOST

	.=MSCP_COMM_AREA+MSU$Q_CTRL_ID
CTRL_ID:
	.LONG	0		; Controller id
	.WORD	0
	.BYTE	MSCP$K_CM_EMULA
	.BYTE	MSCP$K_CL_CNTRL

	.=MSCP_COMM_AREA+MSU$Q_CTRL_INFO
CTRL_INFO:
VERSION:
	.WORD	0		; VERSION
	.WORD	<MSCP$M_CF_REPLC!- ; controller flags
- ; disable advertisement of shadowing	 MSCP$M_CF_SHADW!-
		 MSCP$M_CF_MLTHS>
	.WORD	-1		; Controller timeout
	.WORD	0		; Reserved

	.=MSCP_COMM_AREA+MSU$B_CTRL_DAT
CTRL_DAT:
	.QUAD	0
	.QUAD	0

	.=MSCP_COMM_AREA+MSU$L_OPCOUNT
OPC_COUNT:
	.BLKL	64

	.=MSCP_COMM_AREA+MSU$L_BLKCOUNT
BLK_COUNT:
	.BLKL	129		; Statistics for block sizes

	.=MSCP_COMM_AREA+MSU$Q_HQBLIST
HQBLIST:
	.BLKQ	1		; List of allocated HQB's

	.=MSCP_COMM_AREA+MSU$K_LENGTH

BUFF_LENGTH:
	.BLKL	1		; Length of allocated buffer
BUFF_ADDR:
	.BLKL	1		; Address of allocated buffer
BUFF_END:
	.BLKL	1		; Length+Address
IO_PRI:
	.BLKB	1

	.PAGE
	.SBTTL	MSU ACTION ROUTINES

;+
;
; These routines are called by the MSU program to carry out actions
; that must be done from high IPL code that lives in non-paged pool.
;
; Inputs:
;
;	AP -->	#arguments
;		action code
;		parameter(s)
;
; Outputs:
;
;	R0 = status code
;
;-

	ASSUME	MSU$K_AC_STRT	EQ 1
	ASSUME	MSU$K_AC_STOP	EQ 2
	ASSUME	MSU$K_AC_ADD	EQ 3
	ASSUME	MSU$K_AC_REM	EQ 4
	ASSUME	MSU$K_AC_DISC	EQ 5

	.ENABLE LSB

MSCP_START:

	CASE	4(AP),LIMIT=#1,TYPE=B-
	<START,-			; Startup
	 STOP,-				; Stop
	 ADD,-				; Add a unit
	 REMOVE,-			; Remove a unit
	 DISCON>			; Disconnect a host

	MOVZWL	#SS$_BADPARAM, R0	; Command out of range
10$:	RSB				; Leave

;
; START the server
;

START:	MOVZWL	#SS$_ILLSEQOP,R0	; Set an error code
	BBSS	#MSU$V_START,-		; Check if already started
		 STATE,10$
	BRW	START_CONT		; Do it

	.DISABLE LSB

;
; ADD a disk unit
;
	.ENABLE	LSB

10$:	MOVL	#1,R0
	RSB
ADD:	BBC	#MSU$V_START,- 		; Leave if not started yet
		 STATE,10$
	MOVL	8(AP),R2		; Transfer UQB address

	.DISABLE LSB

SEND_ATTN:
	MOVQ	R6,-(SP)		; Unit counter
	MOVL	#<MSU$K_MAX_HOST*2>-1,R6 ; Largest host slot index
	MOVL	R2,R7			; UQB address
10$:	MOVL	HOST_VEC[R6],R3		; Obtain the HQB pointer
	BEQL	20$			; None, skip on
	BSBW	GET_STRUCT		; Allocate a packet
	BLBC	R0,30$			; Branch on failure
	MOVL	R3,CDRP$L_HQB(R5)	; Store HQB address
	INCW	HQB$W_REFC(R3)		; Up HQB reference count
	MOVL	R7,CDRP$L_UQB(R5)	; Address of UQB
	CLRL	CDRP$L_RSPID(R5)	; Never send w/RSPID
	MOVL	HQB$L_CDT(R3),R4	; Pick up CDT
	MOVL	R4,CDRP$L_CDT(R5)	; Set into CDRP
	MOVL	CDT$L_PDT(R4),R4	; Now grab the PDT address
	BSBB	40$			; Set up to return synchronously
20$:	SOBGEQ	R6,10$			; Iterate over all units
30$:	MOVQ	(SP)+,R6		; Restore registers
	RSB

40$:	MOVW	#CDRP$K_ST_MSG1_WAIT, -	; Tag this state
		CDRP$W_STATE(R5)
	ALLOC_MSG_BUF			; Allocate a message buffer
	CLRL	(R2)+			; No command ref number on attn msg
	MOVL	CDRP$L_UQB(R5),R3	; Pick up unit block
	MOVZWL	UQB$W_UNIT(R3),(R2)+	; Copy unit number
	MOVZBL	#64,(R2)+		; Set the attn msg code
	MOVL	UQB$W_MULT_UNT(R3),(R2)+; Set mulit_unit & unit_flags
	CLRL	(R2)+			; Reserved field
	MOVQ	UQB$Q_UNIT_ID(R3),(R2)+	; Copy unit identifier
	MOVL	UQB$L_MEDIA_ID(R3),(R2)	; Copy media identifier
	MOVL	#32,R1			; Size
	SEND_CNT_MSG_BUF		; Send it out
ATTN_CLEANUP:
	MOVL	CDRP$L_HQB(R5),R3	; HQB address
	DECW	HQB$W_REFC(R3)
	BRW	FREE_STRUCT		; Release data structure
;
; REMOVE a disk unit
;

REMOVE:	RSB

;
; DISCONNECT a host
;

DISCON:	MOVL	8(AP),R3		; Pick up CDT
	MOVL	CDT$L_PDT(R3),R4	; Pick up PDT
	BSBW	VC_ERR			; Do the disconnect
	MOVL	#1,R0			; Always success
	RSB
	.PAGE
	.SBTTL	LISTEN ACTION ROUTINE
;
; When someone wants to connect with us, control will come here
; as a fork process initiated by the port driver at IPL 8.  If the
; connector is the class driver, we will accept it, otherwise we will
; reject the connection.  Upon a successful acceptance, allocate a
; host control block and wait for a message.
;
;	R2  -->	Connect message
;	R3  -->	CDT of listen
;	R4  --> PDT
;

LIS_FORK:
	EXTZV	#0,#4,-			; Pick up low 4 bits of node
		 CDT$B_RSTATION(R3),R1
	BBC	R1,HOST_DSBL,20$	; Have we disabled this host?
10$:	REJECT	#1			; Yes, don't connect
	RSB				; Return to Port Driver

20$:	TSTW	NUM_HOST		; Any host space left?
	BEQL	10$			; No, reject this connect
	CMPB	R1,#MSU$K_MAX_HOST	; Is it a funny one?
	BGEQU	30$			; Yes, bring it in line
	TSTL	HOST_VEC[R1]		; Any one there now?
	BEQL	50$			; No, okay to use
30$:	MOVL	#MSU$K_MAX_HOST,R1	; Starting place for search
40$:	TSTL	HOST_VEC[R1]		; Any one there now?
	BEQL	50$			; Yes
	AOBLSS	#MSU$K_MAX_HOST*2,R1,40$; Try again
	BRB	10$			; No room, reject the connect

50$:	PUSHL	R1			; Save vector
	PUSHL	R3
	MOVZWL	#HQB$C_LEN, R1		; Size needed
	BSBW	ALLOMEM			; Grab some pool
	POPL	R3
	BLBS	R0,60$			; All set
	TSTL	(SP)+			; Clean stack
	BRB	10$			; Reject the connect

	ASSUME	HQB$B_FLAG EQ HQB$B_VEC+1
60$:	CVTLW	(SP)+,HQB$B_VEC(R2)	; Set the vector number & clear flag
	MOVL	R2,R5			; Transfer address
	CLRQ	(R2)+			; Clean out trash
	MOVW	R1,(R2)+		; Set length
	MOVW	#<DYN$C_SCS_HQB@8>!-	; Set type
		 DYN$C_SCS,(R2)+
;
; ACCEPT the connection and que up the HQB
;
	ACCEPT	MSGADR=MSG_IN,-		; Message input addr
		DGADR =B^DG_ERR,-	; DG input
		ERRADR=VC_ERR,-		; Error address
		INITCR=PACKET,-		; Initial credit
		MINSCR=#1,-		; Minimum send credit
		CONDAT=CTRL_DAT,-	; CONNECT/ACCEPT data
		AUXSTR=(R5)		; Auxiliary structure
	BLBC	R0,DEALR0		; ERROR
	INSQUE	HQB$L_FLINK(R5),HQBLIST	; Link to list of allocated HQB's
	MOVAL	12(R5),R2		; Bump to next
	CLRQ	(R2)+
	ASSUME	HQB$L_CDT EQ 20
	MOVL	R3,(R2)+		; Save the CDT address
	CLRL	(R2)+			; Clear more flags
	ASSUME	HQB$W_USE_FRAC EQ 28
	CMPB	#PDT$C_PS,-
		 PDT$B_PDT_TYPE(R4)	; Is it the passthru driver?
	BNEQ	70$			; No
	MOVB	#1,HQB$B_FLAG(R5)	; Yes, set flag	
70$:	CLRW	HQB$W_NUM_QUE(R5)
	CLRW	HQB$W_MAX_QUE(R5)
	MOVW	#1,HQB$W_REFC(R5)	; Reference count = 1 for CDT
	MOVAB	HQB$Q_PENDING(R5),R0	; Cleanup pending queue
	MOVL	R0,(R0)			; Initialize forward pointer
	MOVAL	(R0)+,(R0)		; Initialize back pointer
	MOVZBL	HQB$B_VEC(R5),R1
	MOVL	R5,HOST_VEC[R1]		; Save the host block address
	DECW	NUM_HOST		; Drop number of hosts left
	RSB

DEALR0:	MOVL	R5,R0			; Set up pointer

DEALMEM:JMP	@#EXE$DEANONPAGED	; Get rid of HQB and return

ALLOMEM:JMP	@#EXE$ALONONPAGED	; Get memory
;
; Error
;
DG_ERR:	BUG_CHECK MSCPSERV,FATAL	; ERROR

STOP:	MOVL	LIS_CDT, R3		; Pick up the listen cdt

LIS_ERR:DISCONNECT			; Do a disconnect
RSBX:	RSB				; Return

	.DISABLE lsb
	.page
	.SBTTL	VIRTUAL CIRCUIT ERROR ROUTINE

;************************************************************************
;									*
;									*
;	D I S C O N N E C T   A   V I R T U A L   C I R C U I T		*
;									*
;									*
;************************************************************************
;
; Return all data structures for this host and break link
;
;	R3 = CDT addr
;	R4 = PDT addr
;

	.ENABLE LSB

VC_ERR:
	PUSHR	#^M<R3,R4,R6,R7,R8,R9,R10,R11> ; Save registers
	MOVL	CDT$L_AUXSTRUC(R3),R8	; Pick up HQB
	TSTW	HQB$W_NUM_QUE(R8)	; Are there any CDRP's outstanding?
	BEQL	30$			; No, leave now
	MOVL	#1,R9			; Init iteration counter
10$:	MNEGL	#1,R10			; Yes, Start at unit 0
20$:	INCL	R10			; Next bit position
	MOVZBL	#<2*MSU$K_MAX_UNIT>-1,R1; Max bit size
	SUBL	R10,R1			; Number left
	FFS	R10,R1,-
		 HQB$L_UNIT_ONLN(R8),R10; Find any units online
	BNEQ	40$			; Got one
	SOBGEQ	R9,10$			; Finished?
30$:	BRW	FIN_HQB			; Yes, leave now
;
; Now run thru the queues on the UQB to find all CDRP's.  NOTE: The order
; in which queues are accessed is important and should not be changed.
;
40$:	MOVL	UNIT_VEC[R10],R11	; Get unit que block
	BEQL	20$			; None
	MOVAB	UQB$Q_SHQ(R11),R6	; Point to special holding quehead
	BSBB	50$			; Do the work
	MOVAB	UQB$Q_BLOCKQ(R11),R6	; Point to blocked quehead
	BSBB	50$			; Do the work
	TSTW	UQB$W_NUM_QUE(R11)	; Any CDRP's queued?
	BEQL	20$			; No
	MOVAB	UQB$L_CDRP_FL(R11),R6	; Point to quehead
	BSBB	50$			; Do the work
	BRB	20$			; Try for another unit
;
; Subroutine to scan queue and dispatch to appropriate code.
;	
50$:	MOVL	(R6),R7			; Get first entry
60$:	CMPL	R7,R6			; Is there any more?
	BEQL	RSBX			; No
	MOVAL	-CDRP$L_UQB_FL(R7),R5	; Cover the CDRP portion
	MOVL	(R7),R7			; Get next entry (later REMQUE zeros flink)
	CMPL	HQB$L_CDT(R8),-		; Belong to this host?
		 CDRP$L_CDTX(R5)
	BNEQ	60$			; No
;
; Dispatch on the state value.  This is changed each time the CDRP goes
; thru a particular routine.  Each state may need different treatment.
;
	BISB	#1@CDRP$V_ABORT,-	; Set 'ABORTED' bit
		 CDRP$B_FLAGS(R5)
    	MOVL	HQB$L_CDT(R8),R3	; Pick up the cdt address in r3
	MOVZBL	CDRP$W_STATE(R5),R0	; Pick up state
	CASE	R0,-
		<ST_MEM_WAIT,-		; 0-Memory wait
		 ST_MAP_WAIT,-		; 1-MAP resource wait
		 ST_DRV_WAIT,-		; 2-Driver que wait
		 ST_DRV_WAIT,-		; 3-DATA command wait
		 ST_DRV_WAIT,-		; 4-Driver que wait
		 ST_MSG_WAIT,-		; 5-MSG send wait
		 ST_SHQ_QUE,-		; 6-Special holding que
		 ST_BLK_QUE,-		; 7-Blocked que
		 ST_ONBLK_QUE>		; 8-Online-copy Blocked que

	BUG_CHECK MSCPSERV,FATAL	; ERROR

65$:	BUG_CHECK MSCPSERV,FATAL	; ERROR	-- connection / CDT mismatch

;
; Driver wait:  The CDRP has been delivered to the disk driver and is
; awaiting completion.  It has a mapping resource, a buffer, and a
; message buffer.
;
ST_DRV_WAIT:
	BLBS	R9,60$			; Skip first time
	MOVL	CDRP$L_MSGBUFX(R5),R2	; Pick up message buffer
	CMPL	CDT$L_LCONID(R3), -	; Check validity of remote conid
		SCS$L_DST_CONID(R2)
	BNEQ	65$			; Trying to respond to stale connection
	CLRL	CDRP$L_MSGBUFX(R5)	; Show it gone
	DEALLOC_MSG_BUF_REG		; Deallocate it
	CMPW	#3,CDRP$W_STATE(R5)	; Is it data wait?
	BNEQ	60$			; No, allow it to finish
	
;
; Send/Request data wait:  The CDRP is somewhere in the process of doing
; a send/request data operation.  It has a mapping resource, a buffer, and
; possibly a RSPID and a message buffer.
;
ST_DAT_WAIT:
	TSTL	CDRP$L_RSPID(R5)	; No, if there is a RSPID
	BEQL	70$			; .. then
	DEALLOC_RSPID			; Deallocate it
70$:	TSTL	CDRP$L_MSG_BUF(R5)	; If there is something
	BEQL	80$			; .. then
	DEALLOC_MSG_BUF			; Deallocate the message buffer
80$:
; ??? Crock that assumes that this field is initialized!
	MOVL	CDRP$L_FQFL(R5),R0	; Get possible next element
	ASSUME	CDRP$L_FQFL EQ 0
	CMPL	4(R0),R5		; Is this block queued to anything?
	BNEQ	90$			; No
	REMQUE	CDRP$L_FQFL(R5),R0	; Remove from wait que
; ??? End crock
90$:	CLRL	R0			; Set for failure
	MOVQ	R3,-(SP)		; Save CDT,PDT	
	JSB	@CDRP$L_FPC(R5)		; Finish it off
	MOVQ	(SP)+,R3		; Restore
	BRW	60$			; Loop for next CDRP

;
; Memory wait:  The CDRP is waiting for a data buffer.  It has no resources
; and can be immediately cleaned up after being dequeued from memory wait.
;
ST_MEM_WAIT:
	DECW	NUM_QUE

;
; Message wait:  The CDRP is on a credit wait queue from a RECYCL_MSG_BUF
; operation.  It has a buffer and a message buffer.  It can be dequeued
; from the credt wait queue.
;
ST_MSG_WAIT:

;
; Map wait:  The CDRP is waiting for mapping resources.  It has a data
; buffer resource only.  It can be immediately cleaned up after being dequeued
; from the map wait queue.
;
ST_MAP_WAIT:
	REMQUE	CDRP$L_FQFL(R5),R0	; Remove from wait que
	BRB	150$			;  and finish off

;
; Special holding que:  The CDRP is waiting for CIP.  It has no resources
; and can be immediately cleaned up after being dequeued.
;
ST_SHQ_QUE:
	REMQUE	CDRP$L_UQB_FL(R5),R0	; Remove from special holding que
	BNEQ	100$			; Not the last entry
	BICB	#UQB$M_CMDPEND,-	; Clear the command pending status
		 UQB$B_FLAGS(R11)
100$:	CLRL	(R0)			; Show not queued
	BRB	155$			; Done

;
; Blocked que:  The CDRP is blocked.  It has a message buffer and possibly
; a buffer. It can be immediately cleaned up after being dequeued.
;
ST_BLK_QUE:
	PUSHAB	B^150$			; Set return address
120$:	DECW	UQB$W_NUM_BLK(R11)	; Drop the blocked count
	REMQUE	CDRP$L_UQB_FL(R5),R0	; Remove from blocked queue
	BNEQ	130$			; Not the last entry
	BICB	#UQB$M_BLOCKED,-	; None left, clear flag
		 UQB$B_FLAGS(R11)
130$:	CLRL	(R0)			; Clear link
	RSB				; Leave now

;
; Online-copy blocked que:  The CDRP is blocked.  It has no resources
; and can be immediately cleaned up after being dequeued.
;
ST_ONBLK_QUE:
	BLBS	R9,160$			; If second time, then
	BSBB	120$			;  clean up
	MOVQ	CDRP$L_FR3(R5),R3	; Pick up registers
	BSBW	CLEAN_UP_ONLCPY		; Do the special clean up

;
; Clean up the CDRP and deallocate resources.
;
150$:	CMPB	CDRP$B_OPCODE(R5), -	; If non-sequential command
		 #MSCP$K_OP_ONLIN
	BLEQU	155$			;  then
	UNMAP				; Get rid of possible map resource
155$:	MOVL	CDRP$L_MSGBUFX(R5),R2	; Pick up message buffer
	BEQL	157$			; Just in case!
	CMPL	CDT$L_LCONID(R3), -	; Check validity of remote conid
		SCS$L_DST_CONID(R2)
	BNEQ	165$			; Trying to respond to stale connection
	CLRL	CDRP$L_MSGBUFX(R5)	; Show it gone
	DEALLOC_MSG_BUF_REG		; Deallocate it
157$:	MOVL	R8,R3			; Set HQB address
	PUSHL	R4			; Save PDT
	BSBW	SEND_PKT		; Clean up the packet
	POPL	R4			; Restore PDT
160$:	BRW	60$			; Continue

165$:	BUG_CHECK MSCPSERV,FATAL	; ERROR

	.DISABLE LSB
;
; Clean up of CDRP's all done. Now finish up UNIT and HOST blocks.
;
FIN_HQB:
	MNEGL	#1,R10			; Yes, Start at unit 0
10$:	MOVL	R8,R3			; Transfer HQB address
	INCL	R10			; Next bit position
	MOVZBL	#<2*MSU$K_MAX_UNIT>-1,R1; Max bit size
	SUBL	R10,R1			; Number left
	FFS	R10,R1,-
		 HQB$L_UNIT_ONLN(R8),R10; Find any units online
	BEQL	40$			; No units alive
	MOVL	UNIT_VEC[R10],R4	; Get unit que block
	BNEQ	20$			; Got one
	BBSC	R10,-			; Clear the bogus bit
		 HQB$L_UNIT_ONLN(R3),10$
20$:	BSBW	GET_STRUCT		; Get data structure
	BLBS	R0,30$			; Branch on success
	BUG_CHECK MSCPSERV,FATAL	; It failed

30$:	MOVL	R3,CDRP$L_HQB(R5)	; Address of HQB
	INCW	HQB$W_REFC(R3)		; Upreference count
	CLRL	CDRP$L_MSGBUFX(R5)	; Prevent spurious unloads
	MOVL	R10,CDRP$W_SLOT(R5)	; Clean out flags and others
	MOVB	#MSCP$K_OP_AVAIL,-	; Set the command
		 CDRP$B_OPCODE(R5)
	MOVL	R4,CDRP$L_MST_UQB(R5)	; Needed by routine
	BSBW	SEQ			; Go do the AVAIL
	BRB	10$			; Loop until done

40$:
; ??? Insert bug trapping code here to find live references to the now stale CDT
	MOVL	HQB$L_CDT(R8),R3	; CDT to look up
	MOVL	CDT$L_PDT(R3),R4	; PDT address
	MOVAB	B^100$,R0		; Action routine
	JSB	G^SCS$LKP_RDTCDRP	; Look for matching CDRPs on RDT
	MOVAB	B^100$,R0		; Action routine
	JSB	G^SCS$LKP_RDTWAIT	; Look for matching CDRPs on RSPID wait queue
	MOVAB	B^100$,R0		; Action routine
	JSB	G^SCS$LKP_MSGWAIT	; Look for matching CDRPs on message send queues
	BRB	110$

100$:	BUG_CHECK	MSCPSERV,FATAL	; Found dangling CDT reference

110$:
; ??? End of bug traps
	MOVL	R8,R5			; Hold HQB address
	POPR	#^M<R3,R4,R6,R7,R8,R9,R10,R11>
	DISCONNECT
; ??? more bug traps
	MOVL	#1,HQB$L_CDT(R5)	; zap CDT address
; ??? end of more bug traps
	MOVZBL	HQB$B_VEC(R5),R1	; Pick up vect number
	CLRL	HOST_VEC[R1]		; Show us gone
	INCW	NUM_HOST		; Up number of host slot left
	MOVL	R5,R3			; HQB address
	DECW	HQB$W_REFC(R3)		; Decrement reference count of HQB
	BNEQ	120$			; Not yet 0 -- we never deallocate in this case
	REMQUE	HQB$L_FLINK(R3),R0	; Remove from list headed by MSU$Q_HQBLIST
	BSBW	DEALMEM			; Get rid of HQB
120$:	RSB

	.page
	.SBTTL	WAIT FOR INT

;+
;
; The resuming address and R3/R4 are saved in the CDRP.  Control
; is returned to caller's caller.
;
; Input:
;	R3 -->	HQB
;	R4 -->	UQB
;	R5 -->	CDRP
;-

	.ENABLE	LSB

BLOCKEDH:		
	INSQUE	CDRP$L_UQB_FL(R5), -	; Insert this packet on blocked que
		 UQB$Q_BLOCKQ(R4)	;  at head
	BRB	10$

BLOCKEDT:
	INSQUE	CDRP$L_UQB_FL(R5), -	; Insert this packet on blocked que
		 @UQB$Q_BLOCKQ+4(R4)	;  at tail
10$:	MOVW	#7,CDRP$W_STATE(R5)	; Ditto
	BISB	#UQB$M_BLOCKED,-	; Set blocked flag
		 UQB$B_FLAGS(R4)
	INCW	UQB$W_NUM_BLK(R4)	; Bump number of packet queue to unit
	CMPW	UQB$W_NUM_BLK(R4),-	; Is this number <= max?
		 UQB$W_MAX_BLK(R4)
	BLEQU	WAIT_FOR_INT		; Yes, skip
	MOVW	UQB$W_NUM_BLK(R4),-	; No, set new max
		 UQB$W_MAX_BLK(R4)
					; And fall thru to wait
WAIT_FOR_INT:
	MOVQ	R3,CDRP$L_FR3(R5)	; Save registers
	POPL	CDRP$L_FPC(R5)		; Store resume point
	RSB				; Return to caller's caller

	.DISABLE LSB
	.page
	.SBTTL	MAIN LINE ROUTINE

;+
;
; This is the main line routine that does all the work.
;
; Inputs:
;
;	R1  =	Length of message
;	R2  --> Message
;	R3  --> CDT
;	R4  --> PDT
;
;-
	
	.ENABLE LSB

10$:	PUSHR	#^M<R3,R4>		; Save vital registers
	DEALLOC_MSG_BUF_REG		; Deallocate message buffer
	POPR	#^M<R3,R4>		; Restore registers
	BRW	VC_ERR			; Break connection and return

MSG_IN:
	BSBW	GET_STRUCT		; Get data structure
	BLBC	R0,10$			; Failed to get one
	INCL	OPC_COUNT		; Grand total of requests
	MOVL	R2,CDRP$L_MSGBUFX(R5)	; Store the message pointer
	CLRL	CDRP$L_MSG_BUF(R5)	; Mark it not in use
	MOVL	R3,CDRP$L_CDT(R5)	;  and the CDT
	MOVL	R3,CDRP$L_CDTX(R5)	; Store CDT in non-volatile cell
	MOVL	CDT$L_AUXSTRUC(R3),R3	; Pick up the HQB address
	MOVL	R3,CDRP$L_HQB(R5)	; Store HQB address
	INCW	HQB$W_REFC(R3)		; Up reference count
	INCW	HQB$W_NUM_QUE(R3)	; Bump number of packet queue to host
	CMPW	HQB$W_NUM_QUE(R3),-	; Is this number <= max?
		 HQB$W_MAX_QUE(R3)
	BLEQU	30$			; Yes, skip
	MOVW	HQB$W_NUM_QUE(R3),-	; No, set new max
		 HQB$W_MAX_QUE(R3)
;
; Check the MSCP command packet for protocol errors
;
30$:	CMPW	R1,#MSCP$K_MIN_SIZE	; Is it the min length?
	BLSS	40$			; No, error
	MOVZBL	MSCP$B_OPCODE(R2),R0	; Pick up the opcode
	BEQL	ERR_1			; None is error
	CMPB	R0,#MSU$K_MAX_OPC	; Out of valid range?
	BGTR	ERR_1			; Yes, error
	MOVZBL	COM_PKT_LEN[R0],R4	; Get expected length
	BEQL	ERR_1			; Invalid command
	CMPW	R1,R4			; Big enough?
40$:	BLSS	ERR_2			; No, error
	BITW	MOD_TBL[R0], -
		 MSCP$W_MODIFIER(R2)	; Check allowable
	BNEQ	ERR_3			; Non-allow bit set, error
	MNEGL	#2,CDRP$L_CMD_STS(R5)	; Set up initial cmd status
;
; Grab the unit number and try to find a UQB for it
;
	MOVL	R2,R1			; Transfer to a better reg
	MOVZWL	MSCP$W_UNIT(R1),R2	; Pick up unit number from command
	MOVL	R2,R0			; Copy
	BICL3	#^C<<1@MSU$K_UNIT_SIZ>-1>,R2,R4 ; Slot
	MOVL	UNIT_VEC[R4],R2 	; Look for unit block in slot
	BEQL	50$			; Empty
	CMPW	MSCP$W_UNIT(R1),-
		 UQB$W_UNIT(R2)		; Hit, is it a match?
	BEQL	60$			; Yes
50$:	BSBB	FIND_SLOT		; No, try more probing
	BLSS	NOT_FOUND		; Still did not find it
60$:	MOVL	R2,CDRP$L_MST_UQB(R5)	; Save UQB pointer
65$:	MOVZWL	R4,CDRP$W_SLOT(R5)	; Save slot in CDRP and zero FLAGS
	MOVZBL	MSCP$B_OPCODE(R1),R0	; Pick up the opcode
	MOVB	R0,CDRP$B_OPCODE(R5)	; Save opcode in CDRP
	INCL	OPC_COUNT[R0]		; Count the opcode
	BLBC	HQB$B_FLAG(R3),70$	; Is this the passthru driver?
	BISB	#1@CDRP$V_NOHSTBUF,-	; Yes, set flag
		 CDRP$B_FLAGS(R5)
;
; Split up command into class then dispatch on it.
;
70$:	ASHL	#-3,R0,R0		; Pick up class field
	CASE	R0,-			; Dispatch on class
		<IMMED,-		;  0 - IMMEDIATE
		 SEQ,-			;  8 - SEQUENTIAL
		 NSEQ,-			; 16 - NON-SEQUENTIAL
		 MAINT,-		; 24 - MAINTENANCE
		 NSEQB>			; 32 - NON-SEQUENTIAL/BUFFER
;
; Error paths
;
ERR_1:	ROTL	#24,#MSCP$B_OPCODE,R0	; Opcode error
	BRB	ERR_X
;
ERR_2:	CLRL	R0			; Illegal length
	BRB	ERR_X
;
ERR_3:	ROTL	#24,#MSCP$W_MODIFIER,R0	; Modifier error
ERR_X:	MOVL	CDRP$L_MSGBUFX(R5),R2	; Recover message buffer
	BISL3	#<MSCP$K_ST_ICMD@16-
		 !MSCP$K_OP_END>,-	; Set invalid
		 R0,MSCP$B_OPCODE(R2)
	CLRL	CDRP$L_MST_UQB(R5)	; No master UQB
	MOVL	#MSCP$K_MIN_SIZE,R1	; Length of message
	BRW	SEND_END
;
NOT_FOUND:
	CLRL	CDRP$L_MST_UQB(R5)	; Zero out UQB pointer
	CMPB	MSCP$B_OPCODE(R1),-	; Command need unit?
		 #MSCP$K_OP_AVAIL
	BLSSU	65$			; No, allow to continue
	MOVL	#MSCP$K_ST_OFFLN,R0	; Yes, set failure status
	BRW	SEND_PKT		; And leave

	.DISABLE LSB
;
; Routine to find slot number from unit number
;
;	R0 = Unit number to match against
;
FIND_SLOT:
	ADDL	#MSU$K_MAX_UNIT,R4	; Try for second probe
	MOVL	UNIT_VEC[R4],R2 	; Look for unit block in slot
	BEQL	60$			; Empty
	CMPW	R0,UQB$W_UNIT(R2)	; Hit, is it a match?
	BEQL	100$			; Yes
60$:	MOVL	#<2*MSU$K_MAX_UNIT>-1,R4; Sequential search
70$:	MOVL	UNIT_VEC[R4],R2		; Pick up unit
	BEQL	80$			; Empty
	CMPW	R0,UQB$W_UNIT(R2)	; Hit, is it a match?
	BEQL	100$			; Yes
80$:	DECL	R4			; Loop thru
	CMPL	R4,#MSU$K_MAX_UNIT	; Reached end?
	BGEQ	70$			; No, try again
90$:	MNEGL	#1,R4			; Set a failure indicator
100$:	RSB
	.PAGE
	.SBTTL	IMMEDIATE class commands
;
;	R0   scratch
;	R1 = Ptr to message buffer
;	R2 = low 3 bits of command
;	R3 = Ptr to HQB
;	R4 = Unit number
;	R5 = Ptr to CDRP
;
IMMED:	CASE	CDRP$B_OPCODE(R5),-	; Dispatch on command subtype
		 TYPE=B,LIMIT=#MSCP$K_OP_ABORT-
		<ABORT,-		; 1-ABORT
		 GET_CMD_STS,-		; 2-GET COMMAND STATUS
		 GET_UNIT_STS,-		; 3-GET UNIT STATUS
		 SET_CTRL_CHR>		; 4-SET CONTROLLER CHARACTERISTICS
	BRB	ERR_1			; Illegal command
	.PAGE
	.SBTTL	-	 1 - ABORT
;********************************************************
;							*
;	# 1  -  A B O R T				*
;							*
;********************************************************
;
ABORT:
	BSBW	SEARCH_QUE		; Find the entry
	BLBC	R0,SS			; Failed to find it
	CASE	CDRP$W_STATE-CDRP$L_UQB_FL(R1),TYPE=W-
		<10$,-			; 0 - Mem wait
		 20$,-			; 1 - Map wait
		 40$,-			; 2 - Driver que wait
		 40$,-			; 3 - Data command wait
		 40$,-			; 4 - Driver que wait
		 20$,-			; 5 - Msg send wait
		 50$,-			; 6 - Special holding que
		 70$,-			; 7 - Blocked que
		 70$>			; 8 - Online-copy blocked que

	BUG_CHECK  MSCPSERV,FATAL	; ERROR
;
; CDRP was on the memory wait queue.  Remove it and post it.
;
10$:	DECW	NUM_QUE
;
; CDRP was on the map resource wait queue.  Remove it and post it.
;
20$:	REMQUE	CDRP$L_FQFL- -
		 CDRP$L_UQB_FL(R1),R0	; Remove from wait queue
30$:	PUSHAB	-CDRP$L_UQB_FL(R1)	; Push addr of CDRP to be aborted
	BSBB	SS			; Return the ABORT end packet
	POPL	R5			; Recover aborted CDRP pointer
	CMPB	CDRP$B_OPCODE(R5), -	; If non-sequential command
		 #MSCP$K_OP_ONLIN
	BLEQU	35$			;  then
	UNMAP				; Get rid of possible map resource
35$:	MOVL	#MSCP$K_ST_ABRTD, R0	; Set status
	MOVL	CDRP$L_MSGBUFX(R5),R2	; Recover message pointer
	MOVL	CDRP$L_ABCNT(R5),-
		 MSCP$L_BYTE_CNT(R2)	; Show acumulated byte count
	BRW	SEND_PKT		; Return the command end packet
;
; CDRP was a activity pending queue.  We cannot arbitrarily remove it.
; Therefore, just set the "ABORT" bit and let the action routine deal with
; it when it returns.
;
40$:	BISB	#1@CDRP$V_ABORT,-	; Set 'ABORTED' bit
		 CDRP$B_FLAGS-CDRP$L_UQB_FL(R1)
	BRB	SS			; Leave with success
;
; CDRP was on the special holding queue.  Remove it and post it.
;
50$:	REMQUE	(R1),R0			; Remove from special holding que
	BNEQ	60$			; Not the last entry
	BICB	#UQB$M_CMDPEND,-	; Clear the command pending status
		 UQB$B_FLAGS(R4)
60$:	CLRL	(R1)			; Show not queued
	BRB	30$			; Finish up
;
; CDRP was on the blocked queue.  Remove it and post it.
;
70$:	DECW	UQB$W_NUM_BLK(R4)	; Drop the blocked count
	REMQUE	(R1),R0			; Remove from blocked queue
	BNEQ	60$			; Not the last entry
	BICB	#UQB$M_BLOCKED,-	; Clear blocked flag
		 UQB$B_FLAGS(R4)
	BRB	60$			; And finish up
	.PAGE
	.SBTTL	-	 2 - GET COMMAND STATUS
;********************************************************
;							*
;	# 2  -  G E T   C M D   S T S			*
;							*
;********************************************************
;
GET_CMD_STS:
	BSBW	SEARCH_QUE		; Find entry
	BLBC	R0, SS			; None, always return success
	MOVL	CDRP$L_MSGBUFX(R5), R4	; Pick up buffer address
	MOVL	CDRP$L_CMD_STS-CDRP$L_UQB_FL(R1),- ; Found it,
		 MSCP$L_CMD_STS(R4)	;  copy the status code
SS:	BRW	SEND_SUCCESS
	.PAGE
	.SBTTL	-	 3 - GET UNIT STATUS
;********************************************************
;							*
;	# 3  -  G E T   U N I T   S T S			*
;							*
;********************************************************
;
GET_UNIT_STS:
	ASSUME	MSCP$V_MD_NXUNT EQ 0
	BLBC	MSCP$W_MODIFIER(R1),50$	; If not NXTUNT, do staight processing
	MOVZWL	MSCP$W_UNIT(R1),R2	; Pick up orginal unit number
	MOVAL	UQB_LIST,R4		; Point to head of list
	CMPL	(R4),R4			; Queue empty?
	BEQL	20$			; Yes, return OFFLINE failure, unit=0
	MOVL	R4,R0			; No, copy starting point
10$:	MOVL	(R4),R4			; Get next entry
	CMPL	R4,R0			; End of line?
	BNEQ	40$			; No, continue
20$:	CLRW	MSCP$W_UNIT(R1)		; Yes, give special code (Unit 0)
30$:	MOVL	#MSCP$K_ST_OFFLN,R0	; Set for OFFLINE
	BRW	SEND_PKT		; Return end packet

40$:	CMPW	R2,UQB$W_UNIT- -
		 UQB$Q_UNITQ(R4)	; Compare unit numbers
	BGTRU	10$			; Not far enough, keep looping
	MOVAL	-UQB$Q_UNITQ(R4),R4	; Set R4 to head of UQB
	BRB	60$			; Done

50$:	MOVL	UNIT_VEC[R4], R4	; Get pointer to UQB
	BEQL	30$			; None, return status
;
; Found UQB for unit, transfer information
;
60$:	MOVW	UQB$W_UNIT(R4),-
		 MSCP$W_UNIT(R1)	; Return the unit
	CLRB	MSCP$B_RCT_CPYS(R1)	; Assume no RCT
	MOVL	UQB$L_UCB(R4),R0	; Get device UCB
	BEQL	80$			; None
	MOVZBW	UCB$B_SECTORS(R0),-	; Transfer number of sectors
		 MSCP$W_TRACK(R1)	;  per track.
	MOVZBW	UCB$B_TRACKS(R0),-	; Number of tracks per group.
		 MSCP$W_GROUP(R1)
	BBC	#DEV$V_RCT, -		; Branch if no RCT
		UCB$L_DEVCHAR(R0),80$
	MOVB	#1,MSCP$B_RCT_CPYS(R1)	; Mark RCT present
80$:	MOVL	#1,MSCP$W_CYLINDER(R1)	; Number of groups per cylinder.
	CLRW	MSCP$W_RCT_SIZE(R1)	; No disk has these
	CLRB	MSCP$B_RBNS(R1)		;
	MOVZWL	UQB$W_STATUS(R4),R0	; Pick up unit status
	BNEQ	FIN_UNIT_STS		; Either OFFLINE or AVAIL
	MOVZBL	UQB$B_SLOT(R4),R2	; Pick up slot number
	BBS	R2,HQB$L_UNIT_ONLN(R3),-
		 FIN_UNIT_STS 		; If not already ONLINE to this host
	MOVZWL	#MSCP$K_ST_AVLBL,R0	;  then it is AVAIL to it

FIN_UNIT_STS:
	MOVL	UQB$W_MULT_UNT(R4), -
		 MSCP$W_MULT_UNT(R1)	; Copy mult_unit & unit_flags
	MOVQ	UQB$Q_UNIT_ID(R4), -
		 MSCP$Q_UNIT_ID(R1)	; Copy unit identifier
	MOVQ	UQB$L_MEDIA_ID(R4),-
		 MSCP$L_MEDIA_ID(R1)	; Copy media identifier & shdw unit/flgs
	BRB	SEND_PKT
	.PAGE
	.SBTTL	-	 4 - SET CONTROLLER CHARACTERISTICS
;********************************************************
;							*
;	# 4  -  S E T   C T R L   C H R			*
;							*
;********************************************************
;
SEND_MISMATCH:
	BUG_CHECK	MSCPSERV,FATAL	; Responding using stale CDT address

SET_CTRL_CHR:
	CMPW	MSCP$W_VERSION(R1), -
		 VERSION		; Does the version match?
	BEQL	10$			; Yes, okay
	ROTL	#24,#MSCP$W_VERSION,R0	; No, set sub status
	BRW	ERR_X			; Send invalid command packet

10$:	MOVB	MSCP$W_CNT_FLGS(R1), -
		 HQB$W_CNT_FLGS(R3)	; Transfer Low byte
	MOVW	MSCP$W_HST_TMO(R1),-
		 HQB$W_HST_TMO(R3)
	MOVQ	MSCP$Q_TIME(R1), -
		 HQB$Q_TIME(R3)		; ... and time
;
; Return controller information to host
;
	MOVB	@#CLU$GL_ALLOCLS,-	; Transfer the allocation class
		 MSCP$B_CNT_ALCS(R1)
	MOVQ	CTRL_INFO, -
		 MSCP$W_VERSION(R1)	; Send back info
	MOVQ	CTRL_ID, -
		 MSCP$Q_CNT_ID(R1)	; ... and ID

SEND_SUCCESS:
	CLRL	R0			; Set success

SEND_PKT:
	MOVL	CDRP$L_MSGBUFX(R5),R2	; Pick up message buffer ptr
	BEQL	CLEAN_UP		; No message buffer
	MOVW	R0,MSCP$W_STATUS(R2)	; Set the status

SEND_PKT_STS:
	MOVZBL	MSCP$B_OPCODE(R2),R1	; Pick up opcode
	BISB2	#MSCP$K_OP_END, -
		 MSCP$B_OPCODE(R2)	; Make an end packet
	MOVZBL	END_PKT_LEN[R1],R1	; Pick up length

SEND_END:
	MOVL	R2,CDRP$L_MSG_BUF(R5)	; Stuff the message buffer address
	MOVL	CDRP$L_CDTX(R5),R4	; Pick up the CDT address
	MOVL	R4,CDRP$L_CDT(R5)	; Store into standard location
	CMPL	CDT$L_LCONID(R4), -	; Check validity of remote conid
		SCS$L_DST_CONID(R2)
	BNEQ	SEND_MISMATCH		; Trying to respond to stale connection
	MOVW	#5,CDRP$W_STATE(R5)	; Message send wait state
	MOVL	CDT$L_AUXSTRUC(R4),R3	; Pick up HQB address
	MOVL	CDT$L_PDT(R4),R4	; Set up PDT address
	MOVL	R1,CDRP$L_PID(R5)	; Save the length
	RECYCL_MSG_BUF			; Recycle the message
	MOVL	CDRP$L_PID(R5),R1	; Restore the length
	SEND_CNT_MSG_BUF		; Send the message
	MOVL	CDRP$L_HQB(R5),R3	; Get HQB address
	DECW	HQB$W_NUM_QUE(R3)	; Drop count on host

	.ENABLE	LSB
CLEAN_UP:
	CMPB	CDRP$B_OPCODE(R5), -	; For immediate commands
		 #MSCP$K_OP_AVAIL
	BLSSU	5$
	PUSHL	R5			; Save CDRP address
	BSBB	20$			; Finish cleaning up
	POPL	R5			; Restore CDRP address
5$:	MOVL	CDRP$L_HQB(R5),R3	; Get HQB address	
	DECW	HQB$W_REFC(R3)		; Decrement HQB reference count
	BSBW	FREE_STRUCT		; Free data structure
10$:	RSB				; Just leave

20$:	MOVL	CDRP$L_MST_UQB(R5),R4	; Pick up UQB pointer
	BEQL	10$			; There is none
	TSTL	CDRP$L_UQB_FL(R5)	; Is this CDRP queued on a UQB?
	BEQL	30$			; No
	REMQUE	CDRP$L_UQB_FL(R5),R0	; Remove from unit que
	CLRL	CDRP$L_UQB_FL(R5)	; Prevent double remque - if this code
					;  is moved, always get rid of link!!!
	DECW	UQB$W_NUM_QUE(R4)	; Drop count on unit
;
; Check for any buffer resource and return it.  If possible start up any
; thread waiting for buffer.
;
30$:	BITB	#1@CDRP$V_BUFFER, -	; Check for buffer
		 CDRP$B_FLAGS(R5)
	BEQL	40$			; None, skip next
	BSBW	DEALLOC_BUFF		; Yes, get rid of it
	TSTW	NUM_QUE			; Anyone waiting?
	BEQL	40$			; No, leave now
	REMQUE	@MEM_WAIT,R5		; Grab first entry
	BVS	40$			; None
	PUSHL	R4			; Save context
	MOVQ	CDRP$L_FR3(R5),R3	; Restore old context
	JSB	@CDRP$L_FPC(R5)		; Finish off the pkt
	POPL	R4			; Restore old, old context
;
; If this is last command on execute queue, then check for any blocked
; commands.  If there are some, start up the first one.  If the SEQ bit
; is still set, we are in single command mode, so do not fetch any more
; commands, otherwise drain the blocked queue.
;
40$:	TSTW	UQB$W_NUM_QUE(R4)	; Any entries queued?
	BNEQ	10$			; Yes, leave

	.DISABLE	LSB
DRAIN_BLOCKQ:
10$:	TSTW	UQB$W_NUM_BLK(R4)	; Any entries queued?
	BEQL	30$			; No, leave
	REMQUE	@UQB$Q_BLOCKQ(R4),R5	; Remove from blocked que
	BVS	30$			; None, leave
	DECW	UQB$W_NUM_BLK(R4)	; Drop count
	BNEQ	20$			; Is it the last?
	BICB	#UQB$M_BLOCKED,-	; Yes, clear the flag
		 UQB$B_FLAGS(R4)
20$:	MOVAL	CDRP$L_FQFL- -
		 CDRP$L_UQB_FL(R5),R5	; Set new CDRP ptr
	PUSHL	R4			; Save old UQB
	MOVQ	CDRP$L_FR3(R5),R3	; Restore old context
	JSB	@CDRP$L_FPC(R5)		; Finish off the pkt
	POPL	R4			; Restore old UQB
	BITB	#<UQB$M_SEQ!UQB$M_RIP>,-; Check if in SEQ mode
		 UQB$B_FLAGS(R4)
	BEQL	10$			; No, get next command
30$:	RSB
	.PAGE
	.SBTTL	SEQUENTIAL class commands
;
; This section of code sets up for sequential command processing.  First
; we make checks for sequentiality.
;	a) If commands are already blocked, then this command must be blocked
;		also to preserve sequentiality.  Code at label CLEAN_UP will
;		unravel all of this
;	b) If there are any non-sequential commands on the processing queue,
;		then this command must be blocked and the blocked flag set
;		in the UQB.
;	c) EXCEPT that an ONLINE or AVAILABLE to a shadow master in the
;		copy-in-progress phase will be let thru, since that phase
;		is not strictly sequential.
;
;	R0   scratch
;	R1 = Ptr to message buffer
;	R2 = low 3 bits of command
;	R3 = Ptr to HQB
;	R4 = Unit slot number
;	R5 = Ptr to CDRP
;
SEQ:	CMPB	CDRP$B_OPCODE(R5),-	; Check opcode now
		 #MSCP$K_OP_DTACP
	BGTRU	70$			; Out of range - error
	BLSSU	10$			; In range, continue
	BRW	DET_ACC_PATH		; DAP is a nop

10$:	MOVL	CDRP$L_MST_UQB(R5),R4	; Get UQB pointer
	BITB	#<UQB$M_BLOCKED!-	; If already blocked,
		  UQB$M_RIP!-		;  or in a repair
		  UQB$M_SEQ>,-		;  or in sequential mode
		 UQB$B_FLAGS(R4)	; block this cmd
	BNEQ	30$
	BBC	#MSCP$V_UF_SSMST,-	; If not shadow master, skip test
		 UQB$W_UNT_FLGS(R4),20$
	BBS	#UQB$V_CIP,-		; If CIP, then allow thru
		 UQB$B_FLAGS(R4),50$
20$:	TSTW	UQB$W_NUM_QUE(R4)	; Any entries queued?
	BEQL	50$			; No, leave now
30$:	BISB	#UQB$M_SEQ,-		; Yes, set for sequential mode
		 UQB$B_FLAGS(R4)	;    (rundown the IO)
	BLOCKT				;  and block the command until done
;
; Just in case we get restarted and there are entries left in progress, we
; have to wait, but we also have to block any new entries.
;
40$:	TSTW	UQB$W_NUM_QUE(R4)	; Any entries queued?
	BEQL	50$			; No, leave now
	BISB	#UQB$M_SEQ,-		; Yes, set sequential mode while waiting
		 UQB$B_FLAGS(R4)
	BLOCKH				; Block the command
	BRB	40$			; Command is resumed, check again
	
50$:	CLRL	CDRP$L_UQB_FL(R5)	; So no spurious remques
	BICB	#UQB$M_SEQ,-		; Clear the flag in event of an
		 UQB$B_FLAGS(R4)	;    error exit
	MOVL	#MSCP$K_ST_OFFLN,R0	; Assume offline status
	MOVZWL	UQB$W_STATUS(R4),R0	; Pick up status from unit
	BNEQ	60$			; Either OFFLINE or AVAIL
	MOVZBL	UQB$B_SLOT(R4),R1	; Recover slot number
	BBS	R1,HQB$L_UNIT_ONLN(R3),60$ ; If not alread ONLINE this host
	MOVL	#MSCP$K_ST_AVLBL, R0	;  then it is AVAIL
60$:	MOVL	CDRP$L_MSGBUFX(R5),R1	; Pick up message buffer
	CASE	CDRP$B_OPCODE(R5),-	; Dispatch on command subtype
		 TYPE=B,LIMIT=#MSCP$K_OP_AVAIL-
		<AVAIL,-		;  8 - AVAILABLE
		 ONLINE,-		;  9 - ONLINE
		 SET_UNIT_CHR,-		; 10 - SET UNIT CHARACTERISTICS
		 DET_ACC_PATH>		; 11 - DETERMINCE ACCESS PATH
70$:	BRW	ERR_1
	.PAGE
	.SBTTL	-	 8 - AVAILABLE
;********************************************************
;							*
;	# 8  -  A V A I L A B L E			*
;							*
;********************************************************
;
AVAIL:	TSTW	R0			; Check unit status
	BNEQ	30$			; Either offline or available
10$:	MOVZWL	CDRP$W_SLOT(R5),R1	; Pick up unit number
	BISB	#UQB$M_SEQ,-		; Set for sequential mode
		 UQB$B_FLAGS(R4)	;    no new IO until done
	INSQUE	CDRP$L_UQB_FL(R5),-	; Insert this CDRP on unit queue
		 @UQB$L_CDRP_BL(R4)
	INCW	UQB$W_NUM_QUE(R4)	; Account for it
	BSBB	MAKE_AVAIL		; Make available
	MOVL	CDRP$L_MST_UQB(R5),R4	; Recover UQB pointer
	BICB	#UQB$M_SEQ,-		; Clear the sequential flag -
		 UQB$B_FLAGS(R4)	;   allow any IO now
	CLRL	R0			; Send success
20$:	BRW	SEND_PKT		; Do it
;
; If unit was OFFLINE, command is illegal in this state, send OFFLINE status
;
	ASSUME	<MSCP$K_ST_OFFLN&1> NE 0
30$:	BLBS	R0,20$			; OFFLINE
	TSTL	R4			; Any UQB?
	BEQL	40$			; No, skip next
	BBS	#MSCP$V_UF_SSMST,-	; If this is a shadow master,
		 UQB$W_UNT_FLGS(R4),10$	;  then allow the command else ...
40$:	BRW	SEND_SUCCESS		; AVAILABLE, is NOP
;
; Subroutine to make unit AVAILABLE.  It can be called recursively.
;
;	R1  =	Unit number
;	R3 -->	HQB
;	R4 -->	UQB
;	SP -->	Caller of MAKE_AVAIL
;	4(SP)>	Caller's caller
;
MAKE_AVAIL:
	BBCC	R1,HQB$L_UNIT_ONLN(R3),10$ ; Show this unit not online this host
10$:	MOVZBL	HQB$B_VEC(R3),R1	; Pick up host slot number
	TSTL	R4			; Any UQB?
	BEQL	30$			; No, skip next
	BBCC	R1,UQB$L_HOST_ONLN(R4),20$ ; Show this host not online this unit
	DECB	UQB$B_HOST_CNT(R4)	; Drop host count on unit
	BGEQ	30$			; If any host left, leave now
	BBS	#MSCP$V_UF_SSMST,-	; If this is a shadow master,
		 UQB$W_UNT_FLGS(R4),-	;  then allow the command else ...
		 AV_CASE3
	MOVW	#MSCP$K_ST_AVLBL,-	;  else set status for unit
		 UQB$W_STATUS(R4)	; ONLINE --> AVAILABLE
	MOVL	UQB$L_UCB(R4),R2	; Pick up UCB pointer
	DECB	UCB$B_ONLCNT(R2)	; Decrement count
	BLEQ	40$			; If zero, do IO
;
; This is the last host online to this unit, but there is a local path
; to the unit.  Thus there is no actual IO needed to the unit.  However,
; check if any post processing is called for (shadow member only).
;
	BBC	#MSCP$V_UF_SSMEM,-	; If this is a shadow member,
		 UQB$W_UNT_FLGS(R4),30$	;  then
	BRW	AV_CASE2X		; Continue in special routine
;
; Host was never online to this unit.  However make special check for
; a shadow master with no units and in a transistion state.
;
20$:	BBS	#MSCP$V_UF_SSMST,-	; If this is a shadow master,
		 UQB$W_UNT_FLGS(R4),-	;  then allow the command else ...
		 AV_CASE3
30$:	RSB				; Leave without further processing
;
; This is the last host online to this unit, and there are no local paths
; to it either.  Thus decide if SPINDOWN is needed, and issue the AVAIL.
;
40$:	TSTL	R5			; Is there a CDRP?
	BEQL	30$			; No, skip tests
	MOVL	CDRP$L_MSGBUFX(R5),R1	; Recover MSCP packet pointer
	BEQL	50$			; None
	BBC	#MSCP$V_MD_SPNDW,-	; If SPINDOWN modifier...
		 MSCP$W_MODIFIER(R1),50$
	MOVW	#IO$_UNLOAD!-		; Set function to UNLOAD
		 IO$M_INHERLOG,-
		 CDRP$W_FUNC(R5)
	BRB	60$

50$:	MOVW	#IO$_AVAILABLE!-	; Set function to AVAILABLE
		 IO$M_INHERLOG,-
		 CDRP$W_FUNC(R5)
60$:	BBC	#MSCP$V_UF_SSMEM,-	; If this is a shadow member,
		 UQB$W_UNT_FLGS(R4),70$	;  then
	POPL	CDRP$L_SVAPTE(R5)	; Save normal return address
	PUSHAB	AV_CASE2		;  and substitute special routine
70$:;	BSBB	SETX			; Do the IO
;
; Subroutine to setup for disk IO
;
SETX:	MOVW	#2,CDRP$W_STATE(R5)	; Show it queued to driver
	MOVL	R3,CDRP$L_FR3X(R5)	; Save the HQB pointer
	MOVL	R4,CDRP$L_UQB(R5)	; Save the UQB pointer
	MOVL	UQB$L_UCB(R4),-		; Transfer UCB address
		 CDRP$L_UCB(R5)		;   to UCB addr in IRP
	CLRL	CDRP$L_LBN(R5)		; Just in case
	MOVAL	CDRP$L_IOQFL(R5),R3	; Cover IRP w/R3
	BBSS	#IRP$V_PHYSIO,-		; Set PHYSICAL IO bypass
		 CDRP$W_STS(R5),10$
10$:	BRW	DO_DISKX		; Send it off
;
; AVAILABLE to a shadow set master: Send AVAILABLE to each of the physical
; units in the shadow set.  If the shadow set is disolved, then get rid of
; the shadow master unit.
;
AV_CASE3:
	CVTWB	UQB$W_SHDW_STS(R4),-
		 CDRP$B_SHDW_CNT(R5)	; If no members ...
	BEQL	30$			;  then just deallocate shadow UQB
	POPL	CDRP$L_SAVD_RTX(R5)	; Save return address
	BICB	#1@CDRP$V_SLAVE,-	; Clear out unneeded flag
		 CDRP$B_FLAGS(R5)
10$:	MOVL	UQB$L_SHDW_FL(R4),R4	; Pick up next shadow member
	BEQL	20$			; None left
	MOVZBL	UQB$B_SLOT(R4),R1	; Pick up unit slot
	BSBW	MAKE_AVAIL		; Do the available
	DECB	CDRP$B_SHDW_CNT(R5)	; Drop the count
	BGTRU	10$			; Loop if not done
20$:	PUSHL	CDRP$L_SAVD_RTX(R5)	; Return address
	MOVL	CDRP$L_MST_UQB(R5),R4	; Pick up shadow master UQB
	TSTW	UQB$W_SHDW_STS(R4)	; Is this the last physical unit?
	BNEQ	40$			; No, just return
30$:	MOVZBL	UQB$B_SLOT(R4),R1	; Pick up unit slot
	CLRL	UNIT_VEC[R1]		; Clear shadow unit out of vector
	REMQUE	UQB$Q_UNITQ(R4),R0	; Unlink from chain
	MOVL	R4,R0			; Set R0 to point to head
	BRW	DEALMEM			; Get rid of shadow master UQB	
					;  control returns to MAKE_AVAIL caller
40$:	RSB				; Return to caller's caller
;
; AVAILABLE to a shadow set member: Clear out the shadowing fields, remove
; this unit from the shadow set ring, and if last unit, set shadow set
; master unit to available.
;
AV_CASE2:
	MOVQ	CDRP$L_FR3X(R5),R3	; Recover HQB & UQB
	PUSHL	CDRP$L_SVAPTE(R5)	; Return address

AV_CASE2X:
	BBCC	#MSCP$V_UF_SSMEM,-	; Clear the shadow set member flag
		 UQB$W_UNT_FLGS(R4),10$
10$:	CLRW	UQB$W_SHDW_UNT(R4)	; Clear out old shadow master
	MOVL	UQB$L_SHDW_MST(R4),R0	; Point to shadow master
	CLRL	UQB$L_SHDW_MST(R4)	; Remove the pointer
	DECW	UQB$W_SHDW_STS(R0)	; Decre shadow member count
	BNEQ	20$			; At least one left
	CLRL	UQB$L_SHDW_FL(R0)	; Clear master pointer
	CLRL	UQB$L_SHDW_LOW(R0)	;  and low pointer
	MOVW	#MSCP$K_ST_AVLBL,-	; Set status to AVAIL
		 UQB$W_STATUS(R0)
	BRB	40$			; Skip all else

20$:	MOVL	UQB$L_SHDW_FL(R4),R2	; Get our successor
	REMQUE	UQB$L_SHDW_FL(R4),R1	; Remove us from the shadow ring
	CMPL	UQB$L_SHDW_LOW(R0),R4	; Were we the lowest unit?
	BNEQ	30$			; No, leave
	MOVW	UQB$W_UNIT(R2),-	; Transfer its unit
		 UQB$W_SHDW_UNT(R0)	;  to shadow master's unit field
	MOVL	UQB$L_UCB(R2),-		; Transfer its UCB pointer
		 UQB$L_UCB(R0)		;  to shadow master
	MOVL	R2,UQB$L_SHDW_LOW(R0)	; Update the new lowest pointer
30$:	CMPL	UQB$L_SHDW_FL(R0),R4	; Were we the first in the ring?
	BNEQ	40$			; No, skip on
	MOVL	R2,UQB$L_SHDW_FL(R0)	; Yes, update master with new link
40$:	RSB				; Return to MAKE_AVAIL caller
;
; AVAIL_ALL: Make the unit AVAILABLE to all hosts to which it is currently
; 	ONLINE.  Also make it physically AVAILABLE.  Cannot be called for
;	shadow masters.
;
;	R4 -->	UQB of unit to be made AVAIL
;
AVAIL_ALL:
	POPL	CDRP$L_SAVD_RTX(R5)	; Save return address
	MOVL	R4,CDRP$L_UQB(R5)	; Save UQB pointer
	MOVZBW	UQB$B_SLOT(R4),-	; Pick up the slot index
		 CDRP$W_SLOT(R5)	;  and save in CDRP
	BICB	#1@CDRP$V_SLAVE,-	; Clear unneeded flag
		 CDRP$B_FLAGS(R5)
	MOVW	#<2*MSU$K_MAX_HOST>-1,-	; Stuff max index into convenient
		 CDRP$W_BOFF(R5)	;  place
10$:	MOVZWL	CDRP$W_BOFF(R5),R3	; Pick up index
	MOVL	HOST_VEC[R3],R3		; Pick up possible HQB address
	BEQL	20$			; Non, loop for more
	MOVZWL	CDRP$W_SLOT(R5),R1	; Pick up the slot index
	BSBW	MAKE_AVAIL		; AVAILABLE the unit
20$:	DECW	CDRP$W_BOFF(R5)		; Count down the index
	BGEQ	10$			; Loop for more hosts
	JMP	@CDRP$L_SAVD_RTX(R5)	; Leave
	.PAGE
	.SBTTL	-	 9 - ONLINE
;********************************************************
;							*
;	# 9  -  O N L I N E				*
;							*
;********************************************************
;
ONLINE:
	BLBS	R0,60$			; If OFFLINE, error out
	BICW	#^C<HOSTSET>,-		; Clear non-host flags in the packet
		 MSCP$W_UNT_FLGS(R1)
	BBS	#MSCP$V_MD_SHDSP,-
		 MSCP$W_MODIFIER(R1),10$; Is this a shadowing operation?
;
; CASE 1: ONLINE to a single physical unit, no shadowing at all
;

;;***							;***
;; TEMP UNTIL VMS GETS SHADOWING IN MOUNT		;***
;;							;***
	BBS	#MSCP$V_UF_SSMST,UQB$W_UNT_FLGS(R4),20$	;***
;;***							;***

	BITW	#<MSCP$M_UF_SSMST!-	; No, check consistency
		  MSCP$M_UF_SSMEM>,-
		 UQB$W_UNT_FLGS(R4)	; Is the unit involved in shadowing?
	BEQL	CHECK_ONLINE		; No, go directly to ONLINE test
	ROTL	#24,#MSCP$W_MODIFIER,R0	; Yes, set illegal modifier
	BRB	40$			; ... send invalid end message
 
10$:	BBC	#MSCP$V_UF_SSMST,-	; Is this unit a shadow master?
		 UQB$W_UNT_FLGS(R4),70$
;
; CASE 3: ONLINE to a shadow master unit
;

;;***							;***
;; TEMP							;***
;;							;***
20$:	MOVW	MSCP$W_UNIT(R1),MSCP$W_SHDW_UNT(R1)	;***
;;***							;***

	CMPW	MSCP$W_SHDW_UNT(R1),-	; Yes, now does the virtual
		 UQB$W_UNIT(R4)		;  unit match the physical?
	BEQL	50$			; Yes
30$:	ROTL	#24,#MSCP$W_SHDW_UNT,R0	; No, set illegal shadow unit
40$:	BRW	ERR_X

50$:	MOVW	UQB$W_SHDW_STS(R4),-	; Pick up the number of members
		 MSCP$W_SHDW_STS(R1)
	BNEQ	CHECK_ONLINE		; Non-zero, continue processing
	MOVW	#<1*MSCP$K_ST_SBCOD>!-
		 MSCP$K_ST_AVLBL,R0	; AVAILABLE, NO MEMBERS
60$:	BRW	SEND_PKT
;
; CASE 2: ONLINE to a physical unit to bring it into a shadow set
;
70$:	MOVW	MSCP$W_SHDW_UNT(R1),R0	; Pick up shadow unit
	BGEQ	30$			; Error if sign bit not set
	CMPW	R0,UQB$W_UNIT(R4)	; Does virtual unit match the physical?
	BEQL	30$			; Yes, error (only true for master)
	BBC	#MSCP$V_UF_SSMEM,-	; No, now is this an existing shadow
		 UQB$W_UNT_FLGS(R4),100$;  set member
	CMPW	R0,UQB$W_SHDW_UNT(R4)	; Yes, does its shadow master match?
	BNEQ	30$			; No, error
80$:	ADDL3	MSCP$L_EXCL_LBA(R1),-	; Now pick up the excluded area
		 MSCP$W_EXCL_LBC(R1),R2
	CMPL	R2,UQB$L_MAXBLOCK(R4)	; Is it beyond the legal limits
	BLEQU	CHECK_ONLINE		; No, all is okay
	ROTL	#24,#MSCP$L_EXCL_LBA,R0	; Yes, set status
90$:	BRW	ERR_X			;  ... send invalid end message
;
; Physical unit is not already a shadow set member.  Now test if it is
; already ONLINE as a non-shadow unit to anyone.  If so, error out.
;
100$:	TSTB	UQB$B_HOST_CNT(R4)	; Is it already online?
	BLSS	80$			; No, allow it thru
	MOVL	#^XFF000000,R0		; Yes, this is illegal
	BRB	90$			; Tell host
;
; Now check status of unit.
;
CHECK_ONLINE:
	TSTW	R0			; Check status
	BNEQ	30$			; AVAIL
;
; Was ONLINE to this host already
;
	BISW2	#<MSCP$K_SC_ALONL*-	; Set subcode "Already online"
		 MSCP$K_ST_SBCOD>,R0
	PUSHAB	COPY_CHAR		; Where to go next
10$:	PUSHL	R2			; Save register
	BICW3	#NONHOSTSET,-		; Pick up host settable flags from
		 UQB$W_UNT_FLGS(R4),R2	;  the unit
	CMPW	MSCP$W_UNT_FLGS(R1),R2	; Check againts host settable flags
	POPR	#^M<R2>			; Restore, but leave CC set
	BEQL	20$			; All okay, fill in info
	TSTL	(SP)+			; Remove return address
	ROTL	#24,#MSCP$W_UNT_FLGS,R0	; Set secondary status
	BRW	ERR_X			; ... send invalid end packed

20$:	RSB
;
; Was AVAILABLE, now turn ONLINE
;
30$:	TSTW	UQB$W_STATUS(R4)	; Check the actual unit
	BNEQ	35$			; No other host has it online, skip
	BSBB	10$			; Test unit flags
35$:	BBS	#MSCP$V_UF_SSMST,-	; If shadow master unit,
		 UQB$W_UNT_FLGS(R4),50$	;  skip the physical online stuff
	MOVZBL	HQB$B_VEC(R3),R2	; Pick up host slot number
	BBS	R2,UQB$L_HOST_ONLN(R4),40$ ; If host online bit set, MOUNTVER
	TSTB	UQB$B_HOST_CNT(R4)	; Test count of online hosts
	BGEQ	50$			; Skip UCB & packack, if already done
	MOVL	UQB$L_UCB(R4),R2	; Pick up UCB address
	INCB	UCB$B_ONLCNT(R2)	; Increment the online count
	CMPB	UCB$B_ONLCNT(R2),#1	; Is it already ONLINE?
	BGTRU	50$			; Yes, do not issue another PACK_ACK
40$:	MOVW	#IO$_PACKACK!-		; Set function to PACK_ACK
		 IO$M_INHERLOG,-
		 CDRP$W_FUNC(R5)
	BISB	#UQB$M_SEQ,-		; Set the sequential flag
		 UQB$B_FLAGS(R4)
	INSQUE	CDRP$L_UQB_FL(R5),-	; Insert on unit queue
		 @UQB$L_CDRP_BL(R4)
	INCW	UQB$W_NUM_QUE(R4)	; Account for it
	BSBW	SETX			; Do the IO 
	MOVQ	CDRP$L_FR3X(R5),R3	; Restore HQB & UQB address
	BICB	#UQB$M_SEQ,-		; Clear the sequential flag
		 UQB$B_FLAGS(R4)
	MOVL	CDRP$L_MSGBUFX(R5),R1	; Restore message buffer address
; ??? bug trap
	BEQL	47$			; Bug trap
; ??? end bug trap
	ASSUME	MSCP$K_ST_SUCC EQ 0
	BLBS	R0,50$			; Success
	CMPW	R0,#SS$_ILLIOFUNC	; Error, was it illegal function
	BEQL	50$			; Yes, okay because drive not support
	MOVL	UQB$L_UCB(R4),R2	; Pick up UCB address
	DECB	UCB$B_ONLCNT(R2)	; Drop the online count
	CMPW	R0,#SS$_VOLINV		; Is it volume invalid?
	BEQL	45$			; Yes, change error to mscp error
    	CMPW	R0,#SS$_MEDOFL		; Is it medium offline?
    	BEQL	45$			; Yes, change error to mscp error
	MOVL	#MSCP$K_ST_DRIVE,R0	; Make the error fatal drive error
	BRB	46$

45$:	MOVL	#MSCP$K_ST_OFFLN,R0	; Substitute MSCP error status
46$:	BRW	SEND_PKT		;  and leave now

47$:	BUG_CHECK	MSCPSERV,FATAL	; HQB invalid!!!

50$:	CLRL	R0			; Set success status (ONLINE)
	MOVZBL	HQB$B_VEC(R3),R2	; Pick up host slot number
	BBSS	R2,UQB$L_HOST_ONLN(R4),60$ ; Set host online bit in unit
	INCB	UQB$B_HOST_CNT(R4)	; Bump the host online count
60$:	MOVZWL	CDRP$W_SLOT(R5),R2	; Pick up unit slot number
	BBSS	R2,HQB$L_UNIT_ONLN(R3),70$ ; Set unit-online bit in host
70$:	CLRW	UQB$W_STATUS(R4)	; Set ONLINE status in unit
;
; Physical IO to unit, if any, done.  Now check if any post processing
; needed - shadow physical units only.
;
	BBS	#MSCP$V_UF_SSMST,-	; Leave now if shadow master unit
		 UQB$W_UNT_FLGS(R4),CCHAR
	BBS	#MSCP$V_MD_SHDSP,-	; Leave now if not shadowing
		 MSCP$W_MODIFIER(R1),CASE2A
CCHAR:	BRW	COPY_CHAR
	.PAGE
	.SBTTL	-	 	Shadow units
;
; CASE 2: Deal with the shadow unit
;
CASE2A:
	CMPB	UQB$B_HOST_CNT(R4),#1	; If this unit is already ONLINE
	BGEQU	CCHAR			;  then leave now
	PUSHR	#^M<R3,R4,R5>		; Save some registers
;
; Look up the shadow unit.  If it exists we will do some checks, if it
; does not.  We will create a new UQB for it.  If there is no space we
; will return an error code.
;
	MOVZWL	MSCP$W_SHDW_UNT(R1),R2	; Pick up shadow unit from command
	MOVL	R2,R0			; Copy
	BICL3	#^C<<1@MSU$K_UNIT_SIZ>-1>,R2,R4 ; Slot
	MOVL	UNIT_VEC[R4],R2 	; Look for unit block in slot
	BEQL	10$			; Empty
	CMPW	MSCP$W_SHDW_UNT(R1),-
		 UQB$W_UNIT(R2)		; Hit, is it a match?
	BEQL	OLD_UQB			; Yes
10$:	BSBW	FIND_SLOT		; No, try more probing
	BGEQ	OLD_UQB			; Found unit
;
; No match in table.  Find an empty slot.
;
	MOVZWL	MSCP$W_SHDW_UNT(R1),R2	; Pick up shadow unit from command
	BICL3	#^C<<1@MSU$K_UNIT_SIZ>-1>,R2,R3 ; Slot
	MOVL	UNIT_VEC[R3],R5 	; Look for unit block in slot
	BEQL	30$			; Empty
	ADDL	#MSU$K_MAX_UNIT,R3	; Try for second probe
	MOVL	UNIT_VEC[R3],R5 	; Look for unit block in slot
	BEQL	NEW_UQB			; Empty
	MOVL	#<2*MSU$K_MAX_UNIT>-1,R3; Sequential search
20$:	MOVL	UNIT_VEC[R3],R5		; Pick up unit
30$:	BEQL	NEW_UQB			; Empty
	DECL	R3			; Loop thru
	CMPL	R3,#MSU$K_MAX_UNIT	; Reached end?
	BGEQ	20$			; No, try again
;
; No slots left in the unit table.  Return an error
;
CASE2A_ERR:
	MOVW	#<5*MSCP$K_ST_SBCOD>!-
		 MSCP$K_ST_CNTLR,R0	; Insufficient resources

CASE2A_ERR_OUT:
	POPR	#^M<R3,R4,R5>		; Restore registers
	BRW	SEND_PKT
;
; Existing UQB, check characteristics
;
OLD_UQB:
	MOVL	4(SP),R4		; Recover physical unit UQB
	CMPL	UQB$L_MAXBLOCK(R4),-	; Check maxblock
		 UQB$L_MAXBLOCK(R2)
	BNEQ	10$			; Failed
	CMPL	UQB$L_MEDIA_ID(R4),-	; Check media_id
		 UQB$L_MEDIA_ID(R2)
	BEQL	20$			; Okay, continue
10$:	MOVW	#<8*MSCP$K_ST_SBCOD>!-
		 MSCP$K_ST_MFMTE,R0	; MEDIA FORMAT ERROR
	BRB	CASE2A_ERR_OUT
;
; Update fields for shadowing
;
20$:	INCW	UQB$W_SHDW_STS(R2)	; Bump the count of units
	MOVW	UQB$W_UNIT(R2),-	; Copy virtual unit number
		 UQB$W_SHDW_UNT(R4)	;  to physical unit's shadow unit field
	BBSS	#MSCP$V_UF_SSMEM,-	; Set shadow set member flag
		 UQB$W_UNT_FLGS(R4),30$
30$:	CMPW	UQB$W_UNIT(R4),-	; Is this unit number smaller than
		 UQB$W_SHDW_UNT(R2)	;  any other in the shadow chain?
	BGEQU	40$			; No, skip on
	MOVW	UQB$W_UNIT(R4),-	; Yes, update the field in shadow
		 UQB$W_SHDW_UNT(R2)	;  master unit field
	MOVL	UQB$L_UCB(R4),-		; Update the field in shadow
		 UQB$L_UCB(R2)		;  master UCB field
	MOVL	R4,UQB$L_SHDW_LOW(R2)	; Update the lowest unit pointer
40$:	MOVL	R2,UQB$L_SHDW_MST(R4)	; Set pointer to shadow master
;
; Link this physical UQB into shadowing ring
;
	MOVL	UQB$L_SHDW_FL(R2),R0	; Start with R0-->first entry
	MOVL	R0,R2			; Copy
50$:	MOVL	UQB$L_SHDW_BL(R2),R2	; Get next entry
	CMPL	R0,R2			; End of the line?
	BEQL	60$			; Yes
	CMPW	UQB$W_UNIT(R4),-	; Compare unit numbers
		 UQB$W_UNIT-UQB$L_SHDW_FL(R2)
	BLSSU	50$			; Current is still higher than target
60$:	INSQUE	UQB$L_SHDW_FL(R4),(R2)	; Insert ahead of this unit
	BRW	CASE2A_DONE		;  and leave now	
;
; No existing UQB, create one
;
;	R1 -->	MSCP packet
;	R2  =	Shadow unit number
;	R3  =	Shadow slot
;	R4 -->	Physical unit UQB
;	(SP)-->	HQB
;
NEW_UQB:
	PUSHR	#^M<R1,R2,R3>		; Save registers
	CLRW	MSCP$W_COPY_SPD(R1)	; Ignore copy speed field
	MOVZBL	#UQB$C_LEN,R1		; Size of unit block
	BSBW	ALLOMEM			; Go get it
	BLBS	R0,110$			; Okay
	ADDL	#3*4,SP			; Clear off registers
	BRW	CASE2A_ERR		; Error out

110$:	MOVL	R2,R5			; New UQB pointer
	MOVL	8(SP),R0		; Restore slot number
	MOVQ	12(SP),R3		; Pick up HQB & UQB
	BBSS	R0,HQB$L_UNIT_ONLN(R3),111$ ; Set a 'online' bit
111$:	MOVL	R5,UNIT_VEC[R0]		; Stuff it where it belongs
	MOVL	R4,(R2)+		; Set link to first UQB
	CLRL	(R2)+			; Clear out unused
	MOVW	R1,(R2)+		; Set size field
	MOVW	#<DYN$C_SCS_UQB@8>!-	; Set type
		 DYN$C_SCS,(R2)+
	ASSUME	UQB$B_HOST_CNT EQ 12
	MNEGW	#1,(R2)+		; Set initial HOST_CNT, AVL
	MOVW	#MSCP$K_ST_AVLBL,(R2)+	; Set STATUS to AVAILABLE
	ASSUME	UQB$W_MULT_UNT EQ UQB$B_HOST_CNT+4
	CLRW	(R2)+			; Set unit
	MOVW	#<MSCP$M_UF_REPLC!-	; Set flags - Controller Bad Block
		  MSCP$M_UF_SSMST>,-	;	    - Shadow set master
		 (R2)+			; ... in the unit block
	CLRL	(R2)+			; Clear out reserved
	ASSUME	UQB$Q_UNIT_ID EQ UQB$W_MULT_UNT+8
	CLRQ	(R2)+			; Clear low 32 bits of unit id
	MOVB	#4,-1(R2)		; Set MSCP class code
	ASSUME	UQB$L_MEDIA_ID EQ UQB$Q_UNIT_ID+8
	MOVL	UQB$L_MEDIA_ID(R4),(R2)+; Media ID
	ASSUME	UQB$W_SHDW_UNT EQ UQB$L_MEDIA_ID+4
	MOVW	UQB$W_UNIT(R4),(R2)+	; Shadow unit (lowest phys unit)
	ASSUME	UQB$W_SHDW_STS EQ UQB$W_SHDW_UNT+2
	MOVW	#1,(R2)+		; Shadow status (number of phys units)
	ASSUME	UQB$W_UNIT EQ UQB$W_SHDW_STS+2
	MOVW	4(SP),(R2)+		; Set in unit number
	ASSUME	UQB$B_SLOT EQ UQB$W_UNIT+2
	MOVB	8(SP),(R2)+		; Set in slot number
	CLRB	(R2)+			; Shadow count
	ASSUME	UQB$L_VOL_SER EQ UQB$B_SLOT+2
	CLRL	(R2)+			; Clear volume serial
	ASSUME	UQB$L_UCB EQ UQB$L_VOL_SER+4
	MOVL	UQB$L_UCB(R4),(R2)+	; Set UCB pointer
	CLRL	(R2)+			; Hosts online
	MOVW	#^X5306,(R2)+		; Length
	MOVL	#^A/HADO/,(R2)+
	MOVL	#^A/W   /,(R2)+
	CLRW	(R2)+
	CLRL	(R2)+
	ASSUME	UQB$L_MAXBLOCK EQ UQB$T_NAME+16
	MOVL	UQB$L_MAXBLOCK(R4),(R2)+; Maxblocks
	ASSUME	UQB$L_START_LBN EQ UQB$L_MAXBLOCK+4
	CLRL	(R2)+			; Start LBN
	ASSUME	UQB$W_NUM_QUE EQ UQB$L_START_LBN+4
	CLRQ	(R2)+			; Counts
	ASSUME	UQB$L_FENCEL EQ UQB$W_NUM_QUE+8
	CLRQ	(R2)+			; Fence low and high
	ASSUME	UQB$L_CDRP_FL EQ UQB$L_FENCEL+8
	MOVAL	(R2),(R2)		; Executing CDRP que head
	MOVAL	(R2)+,(R2)+
	ASSUME	UQB$Q_BLOCKQ EQ UQB$L_CDRP_FL+8
	MOVAL	(R2),(R2)		; Blocked CDRP que head
	MOVAL	(R2)+,(R2)+
	ASSUME	UQB$Q_SHQ EQ UQB$Q_BLOCKQ+8
	MOVAL	(R2),(R2)		; Special holding que head
	MOVAL	(R2)+,(R2)+
	ASSUME	UQB$L_SHDW_LOW EQ UQB$Q_SHQ+8
	MOVL	R4,(R2)+		; Set lowest phys unit
	ASSUME	UQB$W_NUM_BLK EQ UQB$L_SHDW_LOW+4
	CLRL	(R2)+			; Blocked counts
	ASSUME	UQB$Q_UNITQ EQ UQB$W_NUM_BLK+4
	CLRQ	(R2)+			; Unit que head
	CLRQ	(R2)+
	MOVW	4(SP),UQB$W_SHDW_UNT(R4); Set phys unit shadow unit field
	MOVL	R5,UQB$L_SHDW_MST(R4)	; Set pointer to shadow master
	BBSS	#MSCP$V_UF_SSMEM,-	; Set shadow set member flag
		 UQB$W_UNT_FLGS(R4),120$
;
; Now link shadow UQB into unit chain
;
120$:	MOVAL	UQB_LIST,R1		; UQB list head
	MOVL	R1,R0			; Copy
130$:	MOVL	4(R1),R1		; Get next entry, backwards
	CMPL	R0,R1			; End of the line?
	BEQL	140$			; Yes
	CMPW	4(SP),UQB$W_UNIT- -
		 UQB$Q_UNITQ(R1)	; Compare unit numbers
	BLSSU	130$			; Current is still higher than target
140$:	INSQUE	UQB$Q_UNITQ(R5),(R1)	; Insert ahead of this unit
;
; Send AVAIL attention message announcing the new shadow unit
;
	MOVL	R5,R2			; Transfer UQB
	BSBW	SEND_ATTN		; Send the attn message
	POPR	#^M<R1,R2,R3>		; Restore registers

CASE2A_DONE:
	POPR	#^M<R3,R4,R5>
	TSTW	MSCP$W_COPY_SPD(R1)	; Is this a shadow copy
	BNEQ	ONL_COPY		; Yes, go do it
CCX:	CLRL	R0			; Set success status
	BRW	COPY_CHAR		; Transfer the ONLINE information
	.PAGE
	.SBTTL	-	 	ONLINE shadow copy
;
;	R1 -->	MSCP packet
;	R4 -->	UQB of physical unit
;	R5 -->	CDRP for ONL command
;

	WRT_UQB = ^X24
	RED_UQB = ^X28
	MST_UQB = ^X2C

ONL_COPY:
	BICB	#1@CDRP$V_NOHSTBUF,-	; Clear special flag
		 CDRP$B_FLAGS(R5)
	TSTB	UQB$B_HOST_CNT(R4)	; Is it already online and copied?
	BGTR	CCX			; Yes, leave with success
	BISB	#UQB$M_SEQ,-		; Set seq mode on write (physical) 
		 UQB$B_FLAGS(R4)	;   unit - lock IO until this is done
	MOVL	R1,R2			; Transfer MSCP packet pointer
	MOVL	R4,WRT_UQB(R2)		; Store the write UQB
	REMQUE	CDRP$L_UQB_FL(R5),R0	; Pull CDRP off physical unit que
	DECW	UQB$W_NUM_QUE(R4)	;  and show it
	MOVL	R5,UQB$L_CPY_CDRP(R4)	; Save a pointer to this cdrp
	MOVL	UQB$L_SHDW_MST(R4),R4	; Get pointer to shadow master
	MOVL	R4,MST_UQB(R2)		; Store the shadow master UQB
;
; Handle the excluded block area
;
	MOVL	MSCP$W_EXCL_LBC(R2),R1	; Pick up count
	MOVL	MSCP$L_EXCL_LBA(R2),R0	; Pick up exclude address
	BNEQ	10$			; Non-zero
	MOVL	R1,MSCP$L_LBN(R2)	; Set as starting address
	BSBW	GET_MAX_BLOCK		; Find the maximum block
	BRB	20$			; Go set the byte count

10$:	CLRL	MSCP$L_LBN(R2)		; Set to start at beginning
	ADDL	R0,R1			; Find end of exclude area
	CMPL	R1,UQB$L_MAXBLOCK(R4)	; Is it the end of the disk?
	BGEQU	20$			; Yes
	BISB	#UQB$M_2PASS,-
		 UQB$B_FLAGS(R4)	; No, set a flag for later
20$:	ASHL	#9,R0,MSCP$L_BYTE_CNT(R2) ; Convert to number of bytes
;
; Now check that there are no IO's in progress on the shadow unit.
; If there are we must block the copy CDRP, set sequential mode (rundown)
; and wait for the last IO to wake the CDRP.
;
30$:	TSTW	UQB$W_NUM_QUE(R4)	; Check the shadow master for IO
	BEQL	40$			; None, all okay
	BISB	#UQB$M_SEQ,-		; Set sequential mode while waiting
		 UQB$B_FLAGS(R4)
	BLOCKH				; IO in progress, rundown and wait
	BRB	30$

40$:	BISB	#UQB$M_CIP,-		; Set the copy in progress flag
		 UQB$B_FLAGS(R4)
	MOVL	WRT_UQB(R2),R1		; Write UQB pointer
	BISB	#UQB$M_CIP,-		; Set the copy in progress flag
		 UQB$B_FLAGS(R1)
;
; Start of read/write loop
;
ONL_LOOP:
;	BBS	#CDRP$V_ABORT,-		; Leave if aborted
;		 CDRP$B_FLAGS(R5),90$
	BICB	#UQB$M_SEQ,-		; Turn off sequential mode
		 UQB$B_FLAGS(R4)
	MOVW	#IO$_READPBLK,R0	; Set up for read
	BSBW	SETUP			; Common set up
	MOVL	CDRP$L_MSGBUFX(R5),R2	; Refresh MSCP packet pointer
	MOVL	CDRP$L_UQB(R5),-	; Pick up read UQB
		 RED_UQB(R2)		;  and refresh the copy

ONL_READ:
	MOVW	#IO$_READPBLK,-		; Set up for read
		 CDRP$W_FUNC(R5)
	MOVL	CDRP$L_MSGBUFX(R5),R2	; Refresh MSCP packet pointer
	MOVL	RED_UQB(R2),R4		; Pick up read UQB
	MOVL	R4,CDRP$L_UQB(R5)	; Stuff it in CDRP
	MOVL	UQB$L_UCB(R4),-		; Refresh the read UCB
		 CDRP$L_UCB(R5)
	MOVL	MST_UQB(R2),R4		; Pick up shadow master UQB
	MOVL	CDRP$L_LBN(R5),-	; Stuff the starting fence lbn
		 UQB$L_FENCEL(R4)
	ASHL	#-9,CDRP$L_BCNT(R5),R0	; Pick up the byte count
	ADDL3	R0,UQB$L_FENCEL(R4),-	; Caclulate the high fence
		 UQB$L_FENCEH(R4)
	MOVW	#2,CDRP$W_STATE(R5)	; Set the state
	BSBW	DO_DISK			; Set up fro disk transfer
	BBS	#CDRP$V_ABORT,-		; Leave if aborted
		 CDRP$B_FLAGS(R5),-
		 ONL_LOOP_CHK
	CLRW	CDRP$W_FUNC(R5)		; Allow modifier in error routine
	BLBS	R0,ONL_WRITE		; Success
	BRW	ONL_READ_ERR		; Attempt to recover the error
;
; Read has finished, now switch some parameters for writes
;
ONL_WRITE:
	BISW	#IO$_WRITEPBLK,-	; Set up for write
		 CDRP$W_FUNC(R5)
	MOVL	CDRP$L_MSGBUFX(R5),R2	; Grab the MSCP packet pointer
	MOVL	WRT_UQB(R2),R4		; Now get the write UQB
	MOVL	R4,CDRP$L_UQB(R5)	; Stuff it in CDRP
	MOVL	UQB$L_UCB(R4),-		; Transfer the write UCB
		 CDRP$L_UCB(R5)
	MOVW	#4,CDRP$W_STATE(R5)	; Bump the state
	BSBW	DO_DISK			; Do the disk transfer
	BLBS	R0,ONL_LOOP_CHK		; Success
	BRW	ONL_WRITE_ERR		; Error out
;
; Write has finished, now check if need to loop again or possibly
; wait for a pending write.
;
ONL_LOOP_CHK:
	MOVL	CDRP$L_MSGBUFX(R5),R2	; Grab pointer to MSCP packet
	MOVL	MST_UQB(R2),R4		; Pick up master UQB
	ADDL	CDRP$L_BCNT(R5), -	; Calc accumulated bytes xfer
		 CDRP$L_ABCNT(R5)
	BBC	#CDRP$V_ABORT,-		; Leave if aborted
		 CDRP$B_FLAGS(R5),5$
	BRW	ONL_ABORT_ERR

5$:	SUBL3	CDRP$L_ABCNT(R5), -
		 CDRP$L_OBCNT(R5),R0	; Calc how much left to do
	BLEQ	30$			; None, we are finished
	ASHL	#-9,CDRP$L_BCNT(R5),R1	; Select the correct disk block
	ADDL	CDRP$L_LBN(R5),R1	; Compute next start LBN
	MOVL	R1,CDRP$L_LBN(R5)	; Store it away
	CMPL	CDRP$L_BCNT(R5),-	; If the bytecount has been reduced
		 CDRP$L_BUFLEN(R5)	;  as a result of error recovery...
	BGEQU	10$			; Then
	MOVL	CDRP$L_BUFLEN(R5),-	;  Set it back to original
		 CDRP$L_BCNT(R5)
10$:	CMPL	R0,CDRP$L_BCNT(R5)	; If piece left less than BCNT
	BGEQ	20$			; .. then ..
	MOVL	R0,CDRP$L_BCNT(R5)	; Use it
20$:	BRB	60$
;
; Finished all the copy specified in the packet, now check if a possible
; second pass is needed because the exclude area is in the middle of the disk.
;
30$:	BBSC	#UQB$V_2PASS,-		; Skip if no second pass needed
		 UQB$B_FLAGS(R4),50$
40$:	BRW	ONL_FINI

50$:	MOVQ	MSCP$L_EXCL_LBA(R2),R0	; Pick the exclude parameters
	ADDL	R0,R1			; Starting LBN after exclude area
	MOVL	R1,CDRP$L_LBN(R5)	; Put it in CDRP
	BSBW	GET_MAX_BLOCK		; Find the maximum blocks to copy
	ASHL	#9,R0,R0		; Convert to bytes for next copy loop
	MOVL	R0,CDRP$L_OBCNT(R5)	; Store in IRP
	CLRL	CDRP$L_ABCNT(R5)	; Reset accumulated count
;
; Another round is needed.  Check if there is a write pending, if so
; stall the copy and do the write.  At the end of the write, the copy
; will be restarted.
;
;	R0  =	#bytes left to copy
;	R1  =	LBN to start copy at
;	R4 -->	Master UQB
;
60$:	BBSC	#UQB$V_CMDPEND,-	; Go around again if no write pend
		 UQB$B_FLAGS(R4),70$
	BRW	ONL_READ

70$:	MOVL	R0,MSCP$L_BYTE_CNT(R2)	; Update copy in packet
	MOVL	R1,MSCP$L_LBN(R2)	; Ditto
	MNEGL	#1,UQB$L_FENCEL(R4)	; Set special value for tests in SETUP
	MOVAB	ONL_LOOP,CDRP$L_FPC(R5)	; Store resume point
	BISB	#UQB$M_SEQ,-		; Set sequential mode while waiting
		 UQB$B_FLAGS(R4)
	BSBW	BLOCK_CDRP		; Block the CDRP
;
; Now empty the special holding queue.
;
EMPTY_SHQ:
	REMQUE	@UQB$Q_SHQ(R4),R0	; Remove from special que
	BVS	10$			; None, leave
	MOVAL	CDRP$L_FQFL- -
		 CDRP$L_UQB_FL(R0),R5	; Set new CDRP ptr
	PUSHL	R4			; Save old UQB
	MOVQ	CDRP$L_FR3(R5),R3	; Restore old context
	JSB	@CDRP$L_FPC(R5)		; Finish off the pkt
	POPL	R4			; Restore old UQB
	BRB	EMPTY_SHQ		; No, get next command

10$:	RSB				; Finish this thread
;
; All copying is done.  Clean up status flags and do the copy of parameters.
; At this point the CDRP is still queued to shadow master UQB.  We must
; remque it, and adjust other fields so this CDRP looks like it was on
; the physical unit que.
;
ONL_FINI:
	CLRL	R0			; Set good status

ONL_FINIX:
	PUSHL	R0			; Save status
	REMQUE	CDRP$L_UQB_FL(R5),R0	; Strip it from que
	CLRL	(R0)			;  show it not queued
	DECW	UQB$W_NUM_QUE(R4)	;  and account for it
	BSBW	CLEAN_UP_ONLCPY		; Do a clean up
	BSBB	EMPTY_SHQ		; Finish off and held commands
	POPL	R0			; Recover status
	MOVL	CDRP$L_MSGBUFX(R5),R1	; Recover MSCP pointer
	MOVL	WRT_UQB(R1),R4		;  and write unit UQB pointer
	MOVL	R4,CDRP$L_MST_UQB(R5)	; Stuff it CDRP
	CLRL	UQB$L_CPY_CDRP(R4)	; Clear out pointer
	BRW	COPY_CHAR		;  and leave
	.PAGE
	.SBTTL	-		ERROR HANDLING

;++
;
; Read error recovery for bad blocks.  First we attempt an ordinary read
; read repair operation.  That operation can return with four cases:
;
;	1) R0 = SS$_NORMAL: Read partially succeded, up to a parity or
;		forcederror, but all blocks before the one in error have
;		been successfully read into our buffer  Continue the loop
;		and write out the good blocks to the target unit. The next
;		read will either succeded or will encounter a forcederror/
;		parity error immediately on the first block.  If the latter
;		then we retry until success or no more units.  If no more
;		units we will return here with SS$_PARITY or SS$_FORCEDERROR.
;
;	2) R0 = SS$_SHACHASTA: An unrepairable, fatal error occurred on one
;		of the source units or the target unit.  We abort the copy
;		operation, failout the offending unit, and report to host.
;
;	3) R0 = SS$_PARITY: This error means we have a parity error in the
;		same LBN of all the source units.  We then just write out
;		one block of whatever is in the buffer to the target unit.
;		Hopefully, the host's file structure will be able to deal
;		with this crazy block.  After the one block write, we continue
;		the normal loop.  The shadow set remains intact.
;
;	4) R0 = SS$_FORCEDERROR: As case 3 above, only the block is written
;		out with a FORCERR modifier.  The host's file structure will
;		eventually catch this.
;
;--

	.ENABLE LSB

ONL_READ_ERR:
	MOVAB	ONL_READ,CDRP$L_FPCX(R5); Where to send blocked reads
	BSBW	READ_REPAIR		; Attempt read repair
	BLBC	R0,10$			; A failure of some sort
	MOVL	CDRP$L_MSGBUFX(R5),R2	; Refresh MSCP packet pointer
	MOVL	CDRP$L_UQB(R5),-	; Pick up new read UQB
		 RED_UQB(R2)		;  and refresh the copy
	PUSHL	R5			; Save R5
	MOVL	MST_UQB(R2),R4		; Pick up master UQB
	BSBW	DRAIN_BLOCKQ		; See if anything blocked while repair
	POPL	R5			; Restore R5
	BRB	30$			; Repair succeded, continue
;
; Either PARITY or FORCEDERROR.  Set up for a one block write.
;
10$:	CMPW	R0,#SS$_PARITY		; Is it parity error?
	BEQL	20$			; Yes, adjust buffer
	CMPW	R0,#SS$_FORCEDERROR	; No, is it forced errro?
	BNEQ	40$			; No, real hard error
	MOVW	#IO$M_FORCERR,-		; Set for writing forced error
		 CDRP$W_FUNC(R5)
20$:	MOVZWL	#512,CDRP$L_BCNT(R5)	; Adjust byte counts
30$:	BRW	ONL_WRITE		; Return inline

;
; Write error recovery for bad blocks
;
ONL_WRITE_ERR:
	CMPW	R0,#SS$_PARITY		; Is it parity error?
	BNEQ	40$			; No, hard error
	ASHL	#-9,CDRP$L_IOST1+2(R5),R1 ; Number of blocks transfered
	INCL	R1			; Skip over bad block
	ASHL	#9,R1,CDRP$L_BCNT(R5)	; Update number of bytes to copy
	BRW	ONL_LOOP_CHK		; Return inline
;
; Fatal error - take care of shadow set housekeeping
;
40$:	MOVL	CDRP$L_UQB(R5),R4	; Pick up pointer to phy unit
	BSBW	AVAIL_ALL		; Throw it out of shadow set
	BRB	50$			; Finish up

ONL_ABORT_ERR:
	CLRL	R4			; Always want the write unit
50$:	MOVL	CDRP$L_MSGBUFX(R5),R2	; Recover MSCP pointer
	MOVL	WRT_UQB(R2),R0		; Pick up write (target) UQB
	CMPL	R0,R4			; Was the error on the write?
	BEQL	60$			; Yes, then just fail it out
	MOVL	R0,R4			; No, we must also fail write out
	BSBW	AVAIL_ALL		; Throw it out of shadow set
60$:	MOVZWL	#MSCP$K_ST_SHST,R0	; Set error code
	MOVL	CDRP$L_MSGBUFX(R5),R2	; Recover MSCP pointer
	MOVL	MST_UQB(R2),R4		; Recover master UQB pointer
	BRW	ONL_FINIX		; Leave

	.DISABLE LSB
;
; CLEAN_UP_ONLCPY
;
CLEAN_UP_ONLCPY:
	MOVL	CDRP$L_MSGBUFX(R5),R2	; Recover MSCP pointer
	BICB	#<UQB$M_CIP!UQB$M_SEQ>,-; Clear flags on shadow unit
		 UQB$B_FLAGS(R4)
	MOVL	WRT_UQB(R2),R1		; Grab write unit UQB pointer
	BICB	#<UQB$M_CIP!UQB$M_SEQ!-	; Clear flags on physical unit
		  UQB$M_BLOCKED>,-
		 UQB$B_FLAGS(R1)
	RSB

;
; GET_MAX_BLOCK
;
	.ENABLE LSB

GET_MAX_BLOCK:
	PUSHL	R2			; Get a register
	SUBL3	R1,UQB$L_MAXBLOCK(R4),R0; Calculate number of blocks to copy
	MOVL	UQB$L_UCB(R4),R2	; Pick up UCB pointer
	BBS	#DEV$V_RCT,-		; Skip next if no last track device
		 UCB$L_DEVCHAR(R2),10$
	MOVZBL	UCB$B_SECTORS(R2),R2	; Pick up #sectors in last track
	SUBL	R2,R0			; Subtract it out from total
10$:	POPL	R2			; Restore register
20$:	RSB
;
; BLOCK_CDRP
;
BLOCK_CDRP:
	MOVQ	R3,CDRP$L_FR3(R5)	; Save R3 & R4
	REMQUE	CDRP$L_UQB_FL(R5),R0	; Remove from head of execute queue and
	DECW	UQB$W_NUM_QUE(R4)	;   (make count agree)
	INSQUE	(R0),UQB$Q_BLOCKQ(R4)	;  insert at head of block queue
	INCW	UQB$W_NUM_BLK(R4)	;   (make count agree)
	MOVW	#8,CDRP$W_STATE(R5)	; Show proper state

DEALLOC_BUFF:
	BBCC	#CDRP$V_BUFFER,-	; Clear the buffer flag
		 CDRP$B_FLAGS(R5),20$
	MOVL	CDRP$L_BUFLEN(R5),R1	; Pick up the buffer
	MOVL	CDRP$L_BUFADR(R5),R0	; Ditto
; ??? BUG TRAP
	CMPL	R0,BUFF_ADDR		; Does address precede allocation region
	BLSSU	70$			; Branch if yes
	ADDL3	R0,R1,R3		; End of region+1
	CMPL	R3,BUFF_END		; Is it beyond+1
	BGTRU	70$
; ??? END BUG TRAP
	MOVAB	BUFF_HEAD,R3		; Allocation list head

	JMP	@#EXE$DEALLOCATE	; Get rid of buffer

70$:	BUG_CHECK	MSCPSERV,FATAL	; Invalid buffer deallocation

	.DISABLE LSB
	.PAGE
	.SBTTL	-	10 - SET UNIT CHARACTERISTICS
;********************************************************
;							*
;	# 10 -  S E T   U N I T   C H R			*
;							*
;********************************************************
;
	.ENABLE	LSB

SET_UNIT_CHR:
	TSTW	R0			; Check status
	BNEQ	50$			; Either AVAIL or OFFLINE
;
; Unit ONLINE to this host - set the unit characteristics
;
10$:	BBS	#MSCP$V_MD_STWRP,-	; Check for correct modifier
		 MSCP$W_MODIFIER(R1),20$
	BBCC	#MSCP$V_UF_WRTPS,-	; Not allowed, remove it
		 MSCP$W_UNT_FLGS(R1),20$
20$:	BISW	MSCP$W_UNT_FLGS(R1),-
		 UQB$W_UNT_FLGS(R4)	; Host settable flags
	MOVW	MSCP$W_SHDW_UNT(R1), -
		 UQB$W_SHDW_UNT(R4)	; Shadow unit
;
; Move in returned info to end packet
;
COPY_CHAR:
	MOVL	UQB$L_MAXBLOCK(R4), -	; Size
		 MSCP$L_UNT_SIZE(R1)
	BNEQ	40$			; All okay
	MOVL	UQB$L_UCB(R4),R2	; Pick up UCB pointer
	BNEQ	30$			; There is one
	MOVL	UQB$L_SHDW_LOW(R4),R2	; For shadow master, use first phys unit
	MOVL	UQB$L_UCB(R2),R2	; Pick up UCB pointer
30$:	MOVL	UCB$L_MAXBLOCK(R2),-	; Get it from the UCB
		 UQB$L_MAXBLOCK(R4)
	MOVL	UQB$L_MAXBLOCK(R4), -	; Size (try again)
		 MSCP$L_UNT_SIZE(R1)
40$:	MOVL	UQB$L_VOL_SER(R4), -
		 MSCP$L_VOL_SER(R1)	; VOL_ID
	BRW	FIN_UNIT_STS		; Finish packet elsewhere

50$:	BRW	SEND_PKT		; Return AVAIL/OFFLINE error

	.DISABLE lsb
	.PAGE
	.SBTTL	-	11 - DETERMINE ACCESS PATHS
;********************************************************
;							*
;	# 11 -  D E T   A C C   P A T H			*
;							*
;********************************************************
;
DET_ACC_PATH:
	BRW	SEND_SUCCESS		; NOP
	.PAGE
	.SBTTL	NON-SEQUENTIAL NON-BUFFER class commands
;
;	R0   scratch
;	R1 = Ptr to message buffer
;	R2 = low 3 bits of command
;	R3 = Ptr to HQB
;	R4 = Unit number
;	R5 = Ptr to CDRP
;
NSEQ:	MOVL	CDRP$L_MST_UQB(R5),R4	; Recover UQB pointer
	MOVZWL	UQB$W_STATUS(R4),R0	; Pick up status
	BEQL	10$			; Success - ONLINE
	BRW	SEND_PKT		; Return error code

10$:	MOVL	UQB$L_UCB(R4),R0	; Ucb address
    	BBC	#UCB$V_MNTVERIP,UCB$L_STS(R0),15$	
    					; Branch if mount verification is not
    					; progress
    	MOVL	#MSCP$K_ST_AVLBL,R0	; mark unit as available
    	BRW	SEND_PKT		; return unit available	

15$:	BITB	#<UQB$M_SEQ!-		; Check if in SEQ mode
		  UQB$M_RIP!-		;  or in repair
		  UQB$M_BLOCKED>,- 	;  or blocked
		 UQB$B_FLAGS(R4)
	BEQL	20$			; If so ...
	BLOCKT				;  then block the command

20$:	CASE	CDRP$B_OPCODE(R5),-	; Dispatch on command subtype
		 TYPE=B,LIMIT=#MSCP$K_OP_ACCES-
		<ACCESS,-		; 16-ACCESS
		 COMP_CTRL_DAT,-	; 17-COMPARE CONTROLLER DATA
		 ERASE,-		; 18-ERASE
		 FLUSH,-		; 19-FLUSH
		 REPLACE>		; 20-REPLACE
	BRW	ERR_1
	.PAGE
	.SBTTL	-	16 - ACCESS
;********************************************************
;							*
;	# 16 -  A C C E S S				*
;							*
;********************************************************
;
ACCESS:
	BISB	#1@CDRP$V_NOHSTBUF,-	; Set for no host buffer
		 CDRP$B_FLAGS(R5)
	BUG_CHECK	MSCPSERV,FATAL	; ?? Tied off here and in opcode table
	BRW	READ			; And join read code
	.PAGE
	.SBTTL	-	17 - COMPARE CONTROLLER DATA
;********************************************************
;							*
;	# 17 -  C O M P   C T R L   D A T		*
;							*
;********************************************************
;
COMP_CTRL_DAT:
	BRW	SEND_SUCCESS		; NOP
	.PAGE
	.SBTTL	-	18 - ERASE
;********************************************************
;							*
;	# 18 -  E R A S E				*
;							*
;********************************************************
;
ERASE:
	BITW	#<MSCP$M_UF_WRTPS!-
		  MSCP$M_UF_WRTPH>,-
		 UQB$W_UNT_FLGS(R4)	; If WRITE_PROTECT
	BEQL	10$
	MOVL	#MSCP$K_ST_WRTPR, R0	; Set error status
	BRW	SEND_PKT		; ... and exit

10$:	BISB	#1@CDRP$V_NOHSTBUF,-	; Set for no host buffer
		 CDRP$B_FLAGS(R5)
	MOVW	#IO$_DSE,R0		; Indicate write
	BRW	DO_WRT			; Join WRITE command
	.PAGE
	.SBTTL	-	19 - FLUSH
;********************************************************
;							*
;	# 19 -  F L U S H				*
;							*
;********************************************************
;
FLUSH:
	BRW	SEND_SUCCESS		; Nop
	.PAGE
	.SBTTL	-	20 - REPLACE
;********************************************************
;							*
;	# 20 -  R E P L A C E				*
;							*
;********************************************************
;
REPLACE:
	BRW	ERR_1			; Invalid opcode - Host Bad Not Supp
	.PAGE
	.SBTTL	MAINTENANCE class commands
;
MAINT:
	BRW	ERR_1
	.PAGE
	.SBTTL	NON-SEQUENTIAL BUFFER class commands
;
;	R0   scratch
;	R1 = Ptr to message buffer
;	R2 = low 3 bits of command
;	R3 = Ptr to HQB
;	R4 = Unit number
;	R5 = Ptr to CDRP
;
NSEQB:	MOVL	CDRP$L_MST_UQB(R5),R4	; Recover UQB pointer
	MOVZWL	UQB$W_STATUS(R4),R0	; Pick up status
	BEQL	10$			; Success - ONLINE
	BRW	SEND_PKT		; Return error code

10$:	MOVL	UQB$L_UCB(R4),R0	; Ucb address
    	BBC	#UCB$V_MNTVERIP,UCB$L_STS(R0),15$	
    					; Branch if mount verification is not
    					; progress
    	MOVL	#MSCP$K_ST_AVLBL,R0	; mark unit as available
    	BRW	SEND_PKT		; return unit available	

15$:	BITB	#<UQB$M_SEQ!-		; Check if in SEQ mode
		  UQB$M_RIP!-		;  or in repair
		  UQB$M_BLOCKED>,- 	;  or blocked
		 UQB$B_FLAGS(R4)
	BEQL	20$			; If so ...
	BLOCKT				;  then block the command

20$:	CASE	CDRP$B_OPCODE(R5),-	; Dispatch on command subtype
		 TYPE=B,LIMIT=#MSCP$K_OP_COMP-
		<COMP_HOST_DAT,-	; 32-COMPARE HOST DATA
		 READ,-			; 33-READ
		 WRITE>			; 34-WRITE
	BRW	ERR_1
	.PAGE
	.SBTTL	-	32 - COMPARE HOST DATA
;********************************************************
;							*
;	# 32 -  C O M P   H O S T   D A T		*
;							*
;********************************************************
;
COMP_HOST_DAT:
	MOVW	#IO$_WRITECHECK,R0	; Set function code
	BRW	DO_WRT			;  and go do it
	.PAGE
	.SBTTL	-	33 - READ
;********************************************************
;							*
;	# 33 -  R E A D					*
;							*
;********************************************************
;
READ:
	MOVW	#IO$_READPBLK,R0	; Set up for read
	BSBW	SETUP			; Common set up
	BITB	#1@CDRP$V_NOHSTBUF,-	; Test flags
		 CDRP$B_FLAGS(R5)
	BNEQ	READ_LOOP		; Skip if no host buffer
	MOVW	#1,CDRP$W_STATE(R5)	; Show it in mapping resource wait
	MAP_IRP				; Map the buffer
;
; Read the data from the disk
;
READ_LOOP:
	MOVW	#2,CDRP$W_STATE(R5)	; Set the state
	BSBW	DO_DISK			; Set up fro disk transfer
	BITB	#1@CDRP$V_ABORT,-	; Check if aborted
		 CDRP$B_FLAGS(R5)
	BNEQ	FINI			; Leave if so
	BLBS	R0,READ_CONT		; Success
	BRW	READ_ERR		; Leave now for error

READ_INVALID_CDT:
	BUG_CHECK	MSCPSERV,FATAL	; Stale CDT
;
; Send the data to the host buffer
;
READ_CONT:
	BITB	#1@CDRP$V_NOHSTBUF,-	; Test flags
		 CDRP$B_FLAGS(R5)
	BNEQ	FINI			; Skip if no host buffer
	MOVW	#3,CDRP$W_STATE(R5)	; Show it queued to SCS block transfer
; ??? Begin bug trap
	MOVL	CDRP$L_MSGBUFX(R5),R2	; Get message buffer address for validity check
	MOVL	CDRP$L_CDT(R5),R1	; Get CDT address
	CMPL	CDT$L_LCONID(R1), -	; Check validity of remote conid
		SCS$L_DST_CONID(R2)
	BNEQ	READ_INVALID_CDT	; Trying to use stale connection
; ??? End bug trap
	CLRL	CDRP$L_MSG_BUF(R5)	; Mark it not in use
	SEND_DATA			; Send to host buffer
	BLBC	R0,ABX_ER		; Aborted
	DECL	CDRP$L_CMD_STS(R5) 	; Set the command status
FINI:	PUSHAB	READ_LOOP		; Loop again

;
; TST_END: Update the accumulated byte count and compare to original to
; determine if another round is needed.  Also check for errors and translate
; VMS errors to MSCP errors.  Finally, clean up resources and branch off
; to return end packet with status.
;
	.ENABLE LSB

	MOVL	CDRP$L_IOST1+2(R5),R3	; Pick up transfered bytes
	BRB	10$			; Join common code

TST_END:
	MOVL	CDRP$L_BCNT(R5),R3	; Pick up transfered bytes
10$:	ASHL	#-9,R3,R1		; Make it blocks
	ADDL	R3,CDRP$L_ABCNT(R5)	; Calc accumulated bytes xfer
	BITB	#1@CDRP$V_ABORT,-	; Check if aborted
		 CDRP$B_FLAGS(R5)
	BNEQ	ABO_ER			; Leave if so
	BLBC	R0,OUT_ER		; Leave if error
	CLRL	R0			; Assume success
	SUBL3	CDRP$L_ABCNT(R5), -	; Calc how much left to do
		 CDRP$L_OBCNT(R5),R2
	BLEQ	OUT			; None, we are finished
	CMPL	R2,CDRP$L_BCNT(R5)	; If piece left less than BCNT
	BGEQ	20$			; .. then ..
	MOVL	R2,CDRP$L_BCNT(R5)	; Use it
	MOVL	R2,CDRP$L_XCT_LEN(R5)	; Ditto
20$:	MOVL	CDRP$L_ABCNT(R5), -	; Set the remote byte offset
		 CDRP$L_RBOFF(R5)	;  to be accumlated xfer size
	ADDL	R1,CDRP$L_LBN(R5)	; Update LBN
	RSB				; Loop again

	.DISABLE LSB
;
; Command was aborted while on disk queue
;
ABO_ER:	TSTL	(SP)+			; Clean stack
;
; Command was aborted during SEND/RECEIVE DATA to host
;
ABX_ER:	MOVL	#MSCP$K_ST_ABRTD,R0	; Set status
	BRB	OUT1
;
; Command received a disk error - translate from VMS to MSCP status.
;
OUT_ER:	TSTL	(SP)+			; Get rid of return address
	BBS	#CDRP$V_ABORT,-		; Check if aborted
		 CDRP$B_FLAGS(R5),ABX_ER; Leave if so (has priority over errors)
	MOVAW	ERR_TBL,R2		; Pick up error table address
10$:	MOVZWL	(R2)+,R1		; Grab VMS error entry
	BEQL	20$			; End of table, quit
	CMPW	R1,R0			; Try for a match
	BEQL	20$			; Success
	ADDL	#4,R2			; Step to next entry
	BRB	10$			; Loop

20$:	MOVZWL	(R2)+,R0		; Pick up MSCP error
	CVTWL	(R2),R1			; Get possible routine
	BEQL	OUT1			; None
	JSB	(R1)[R2]		; Invoke the routine
	BRB	OUT1			; Continue on
;
; Final clean up for transfer commands.  Set status, release resources.
;
OUT:	TSTL	(SP)+			; Get rid of return
OUT1:	MOVL	CDRP$L_MSGBUFX(R5),R2	; Pick up old message buffer ptr
	BEQL	10$			; None, probably an abort
	MOVL	CDRP$L_ABCNT(R5),-	; Set byte count
		 MSCP$L_BYTE_CNT(R2)
	MOVW	R0,MSCP$W_STATUS(R2)	; Store the status
10$:	MOVW	#5,CDRP$W_STATE(R5)	; Set state
	BITB	#1@CDRP$V_NOHSTBUF,-
		 CDRP$B_FLAGS(R5)
	BNEQ	20$			; Skip if no host buffer
	MOVL	CDRP$L_CDTX(R5),R3	; Pick up the CDT address
	MOVL	CDT$L_PDT(R3),R4	; Set up PDT address
	UNMAP				; Get rid of mapping resources
20$:	MOVL	CDRP$L_SHDW_LNK(R5),R4	; Check possible IRP link
	BEQL	40$			; None, continue on
30$:	MOVL	R4,R0			; Transfer IRP pointer
	BEQL	40$			; Done
	MOVL	IRP$L_SHDW_LNK(R4),R4	; Transfer next IRP pointer
	BSBW	DEALMEM			; Get rid of it
	BRB	30$			; Loop for more IRP's

40$:	MOVL	CDRP$L_MSGBUFX(R5),R2	; Pick up old message buffer ptr
	BEQL	50$			; None, probably an abort
	CLRL	MSCP$L_FRST_BAD(R2)	; Clear unused field
	BRW	SEND_PKT_STS		; Return the end packet

50$:	BRW	CLEAN_UP		; Finish up

ERR_TBL:
	ACTION	SS$_MEDOFL,MSCP$K_ST_AVLBL,ERR_AVAIL
	ACTION	SS$_VOLINV,MSCP$K_ST_AVLBL,ERR_AVAIL
	ACTION	SS$_WRITLCK,MSCP$K_ST_WRTPR,ERR_WRITLCK
	ACTION	SS$_DATACHECK,MSCP$K_ST_COMP
	ACTION	SS$_CTRLERR,MSCP$K_ST_CNTLR
	ACTION	SS$_FORMAT,MSCP$K_ST_MFMTE
	ACTION	SS$_FORCEDERROR,MSCP$K_ST_DATA
	ACTION	SS$_PARITY,<<MSCP$K_ST_DATA>!<1*MSCP$K_ST_SBCOD>>
	ACTION	SS$_IVBUFLEN,MSCP$K_ST_HSTBF
	ACTION	SS$_SHACHASTA,MSCP$K_ST_SHST,ERR_SHACHA
	ACTION	SS$_TIMEOUT,<MSCP$K_ST_OFFLN!MSCP$K_SC_UNKNO>,ERR_OFFLINE
	ACTION	0,MSCP$K_ST_DRIVE	; PATCH SPACE
	ACTION	0,MSCP$K_ST_DRIVE	; End of table - default error

ERR_AVAIL:
	MOVL	CDRP$L_UQB(R5),R4	; Pick up pointer
	MOVW	#MSCP$K_ST_AVLBL,-	; Set new status in unit
		 UQB$W_STATUS(R4)
	RSB

ERR_OFFLINE:
	MOVL	CDRP$L_UQB(R5),R4	; Pick up pointer
	MOVW	#MSCP$K_ST_OFFLN,-	; Set new status in unit
		 UQB$W_STATUS(R4)
	RSB

ERR_WRITLCK:
	MOVL	CDRP$L_UQB(R5),R1	; Pick up pointer
	BBSS	#MSCP$V_UF_WRTPH, -
		UQB$W_UNT_FLGS(R1),20$	; Set in unit flags
20$:	RSB

ERR_SHACHA:
	TSTL	(SP)+			; Remove return address
	MOVL	CDRP$L_UQB(R5),R4	; Pick up pointer
	BSBW	AVAIL_ALL		; Kick unit out of shadow set
	MOVL	#MSCP$K_ST_SHST,R0	; Restore status
	BRW	OUT1			; Continue

;
; Error recovery routine for shadow reads.  First, verify that this is
; really a shadow read.  If so, attempt the read repair.  There are only
; two cases to consider:
;
;	1) R0 = SS$_NORMAL: Read partially succeded, up to a parity or
;		forcederror.  Continue the SEND_DATA part of the loop
;		and retry the read at the failed block.  The read will
;		either succede or fail back here with an error.
;
;	2) R0 = failure: The repair/retry logic failed.  Terminate the
;		read and report the error to host.
;
READ_ERR:
	MOVL	CDRP$L_UQB(R5),R1	; Pick up UQB pointer
	MOVL	CDRP$L_MST_UQB(R5),R2	; Pick up master UQB pointer
	BBC	#MSCP$V_UF_SSMEM,-	; If this unit is shadow member
		 UQB$W_UNT_FLGS(R1),20$	;  and
	CMPL	R1,R2			; If IO directed to shadow master
	BEQL	20$			;  then
	MOVAB	READ_LOOP,CDRP$L_FPCX(R5) ; Where to send blocked reads
	BSBB	READ_REPAIR		; Attempt read repair
	BLBC	R0,20$			; Failed to find good block
	ASHL	#-9,CDRP$L_IOST1+2(R5),R1 ; Find how much was transfered
	ASHL	#9,R1,CDRP$L_XCT_LEN(R5); Back to bytes
	MOVL	CDRP$L_BUFLEN(R5),-	; Restore the old bytecnt
		 CDRP$L_BCNT(R5)
	BBC	#CDRP$V_NOHSTBUF,-	; If this is a passthru,
		 CDRP$B_FLAGS(R5),10$
	ASHL	#2,R1,R1		; Make it number of longwords
	ADDL	R1,CDRP$L_SVAPTE(R5)	; Update PTE pointer
10$:	BRW	READ_CONT		; Succeded in repair, continue SEND

20$:	BRW	FINI			; Leave for good
	.PAGE
	.SBTTL	-		READ REPAIR routine

;++
;
; READ_REPAIR
;
; Read error recovery for bad blocks. This operation has two phases:
;
;    Phase 1:	If error is not SS$_PARITY or SS$_FORCEDERROR, then
;		leave immediately with R0 = SS$_SHACHASTA.  Next we check
;		the bytecnt.  If at least one block has been successfully
;		read, then we leave with R0 = SS$_NORMAL after updating
;		transfer parameters to reflect a transfer of up to but not
;		including the bad block.  The next read will then cause us
;		to return here for phase 2.  Otherwise we drop immediately
;		into phase 2.
;
;    Phase 2:	We enter with an immediate error in the first block.  We
;		can return with four cases:
;
;	1) R0 = SS$_NORMAL: The block in error on all source units has been
;		successfully repaired if a FORCEDERROR or a good block on an
;		alternate unit has been found for PARITY error.  We leave
;		with transfer parameters indicating a good one block read.
;
;	2) R0 = SS$_SHACHASTA: An unrepairable, fatal error occurred on one
;		of the source units or the target unit.  The calling routine
;		must fail the offending unit out of the shadow set.
;
;	3) R0 = SS$_PARITY: We have a parity error in the same LBN of all
;		the source units.  No repair is possible. The shadow set
;		remains intact.
;
;	4) R0 = SS$_FORCEDERROR: As case 3 above, only a forcederror.
;
; Any error that occurs while a repair is pending is put on the blocked queue
; and will be restarted from the read when the repair operation is finished.
; This routine is non-abortable.
;
; Inputs:
;	R0  =	Disk failure code
;	R1 -->	Failing UQB
;	R2 -->	Master UQB
;	R3/R4	saved
;	R5 -->	CDRP
;	CDRP$L_UQB  --> Failing unit UQB
;	CDRP$L_FPCX --> Where to restart blocked reads
;
; Outputs:
;	R0  =	Status code
;	CDRP$L_IOST1 = upated
;
;--

READ_REPAIR:
	MOVL	CDRP$L_UQB(R5),R1	; Pick up UQB pointer
	MOVL	CDRP$L_MST_UQB(R5),R2	; Pick up master UQB pointer
	CMPW	R0,#SS$_FORCEDERROR	; Is this a repairable error?
	BEQL	10$			; Yes, go off to repair logic
	CMPW	R0,#SS$_PARITY		; Is it parity error
	BEQL	10$			; Yes, go off to repair logic
	CLRL	CDRP$L_IOST1+2(R5)	; No bytes transfered to host
	MOVZWL	#SS$_SHACHASTA,R0	; Set fatal error
	RSB				; Leave
;
; Set RIP mode (rundown) for the shadow unit.  If this is not the first
; error for this unit, hold it on the blocked queue until the first
; repair is finished.  ALL REPAIR OPERATIONS MUST BE SEQUENTIAL!!!
; When the repair is finished, these operations will be restarted.
;
10$:	POPL	CDRP$L_SAVD_RTX(R5)	; Save return address
	BBC	#UQB$V_RIP,-		; If already a RIP
		 UQB$B_FLAGS(R2),20$
	MOVL	R2,R4			; Transfer to proper register
	REMQUE	CDRP$L_UQB_FL(R5),R0	; Remove from execute queue
	DECW	UQB$W_NUM_QUE(R4)	; Account for it
	BLOCKT				; Block until first RIP over
	INSQUE	CDRP$L_UQB_FL(R5),-	; Insert packet on unit que
		 @UQB$L_CDRP_BL(R4)
	INCW	UQB$W_NUM_QUE(R4)	; Account for it
	MOVL	CDRP$L_FR4X(R5),R4	; Restore R4 (PDT)
	JMP	@CDRP$L_FPCX(R5)	; Attempt the read again
;
; First repairable error on this volume.  Check for any I/O.  If so
; block the RIP CDRP until all other I/O done, saving current state.
;	
20$:	MOVW	CDRP$W_FUNC(R5),-	; Save old function code
		 CDRP$L_FR3X+2(R5)
	ASHL	#-9,CDRP$L_IOST1+2(R5),R0; Number of blocks transfered
	BEQL	30$			; None, we are in real repair
	ASHL	#9,R0,CDRP$L_BCNT(R5)	; Update transfer parameter
	MOVL	CDRP$L_BCNT(R5),-	; Also update status
		 CDRP$L_IOST1+2(R5)
	BRW	140$			; Leave now, first part done

30$:	BISB	#UQB$M_RIP,-		; Set the repair in progress flag
		 UQB$B_FLAGS(R2)	;  on shadow master unit
	BISB	#UQB$M_RIP,-		; Set the repair in progress flag
		 UQB$B_FLAGS(R1)	;  on physical unit
	MOVW	CDRP$L_IOST1(R5),-	; Save old status
		 CDRP$L_FR3X(R5)
	CMPW	UQB$W_NUM_QUE(R2),#1	; Check the shadow master for IO
	BLEQU	40$			; None, all okay
	MOVL	R2,R4			; Transfer to proper register
	REMQUE	CDRP$L_UQB_FL(R5),R0	; Remove from execute queue
	DECW	UQB$W_NUM_QUE(R4)	; Account for it
	BLOCKT				; Block until all I/O rundown
	INSQUE	CDRP$L_UQB_FL(R5),-	; Insert packet on unit que
		 @UQB$L_CDRP_BL(R4)
	INCW	UQB$W_NUM_QUE(R4)	; Account for it
	MOVL	CDRP$L_UQB(R5),R1	; Pick up failed UQB pointer
	MOVL	CDRP$L_MST_UQB(R5),R2	; Pick up master UQB pointer
40$:	MOVZWL	#512,CDRP$L_BCNT(R5)	; Only do one block
;	MOVL	R1,CDRP$L_STRT_UQB(R5)	; Set a end condition
;
; Attempt to find a good copy of the block, reading all units if necesary.
; Keep a list of units that are unreadable.  If no units are readable, we
; will return the IO with the FORCEDERROR status.  If any unit has an
; unrepairable error, we will fail out with Shadow Set Status has changed.
;
50$:	MOVZWL	CDRP$L_FR3X(R5),R0	; Pick up true status code
	BSBW	SELECT_NEXT_UNIT	; Get the next unit
	BEQL	90$			; None, left error out
	MOVW	#<IO$_READPBLK!-	; Set for READ/COMPARE
		 IO$M_DATACHECK>,-
		 CDRP$W_FUNC(R5)
	MOVW	#2,CDRP$W_STATE(R5)	; Set the state
	BSBW	DO_DISK			; Do the read
	MOVL	CDRP$L_UQB(R5),R1	; Pick up UQB pointer
	BLBS	R0,60$			; Success now go to write
	CMPW	R0,CDRP$L_FR3X(R5)	; Was the error repairable?
	BNEQ	80$			; No, leave with failure
	BISB	#UQB$M_RIP,-		; Set the repair in progress flag
		 UQB$B_FLAGS(R1)
	BRB	50$			; Try for another unit
;
; Read phase succeded in locating a good copy of the block.  Now run thru
; the list of units with a bad copy and repair them.
;
60$:	MOVL	R1,CDRP$L_STRT_UQB(R5)	; Set end condition & save good unit UQB
	MOVW	#<IO$_WRITEPBLK!-	; Now change to write
		  IO$M_DATACHECK>,-
		 CDRP$W_FUNC(R5)
70$:	BSBW	SELECT_NEXT_UNIT	; Get the next unit
	BEQL	130$			; None left, leave
	BBCC	#UQB$V_RIP,-		; Check for units needing repair
		 UQB$B_FLAGS(R1),70$
	CMPW	CDRP$L_FR3X(R5),-	; If parity error,
		 #SS$_PARITY		;  then skip write
	BEQL	70$			;  since it cannot be written
	MOVW	#4,CDRP$W_STATE(R5)	; Set the state
	BSBW	DO_DISK			; Do the write
	MOVL	CDRP$L_UQB(R5),R1	; Pick up UQB pointer
	BLBS	R0,70$			; Success, look for next unit
	CMPW	R0,#SS$_WRITLCK		; Was the error writelock?
	BEQL	70$			; If so, ignore it
;
; A hard, unrepairable error has occurred.  Clean up any status and
; then fail this unit out of shadow set and report status to host.
;
80$:	MOVW	#SS$_SHACHASTA,R0	; Set the fatal error code
90$:	MOVL	CDRP$L_STRT_UQB(R5),R1	; Get starting point
	BRB	110$			; Do it

100$:	MOVL	UQB$L_SHDW_FL(R1),R1	; Advance to next unit
	CMPL	R1,CDRP$L_STRT_UQB(R5)	; End?
	BEQL	120$			; Yes
110$:	BICB	#UQB$M_RIP,-		; Clear flags
		 UQB$B_FLAGS(R1)
	BRB	100$			; Loop for more

120$:	CLRL	CDRP$L_IOST1+2(R5)	; Show nothing transfered
	BRB	150$			; Leave
;
; Repair is finished.  Clean up, restore original parameters and
; restart the read from the beginning.
;
130$:	BICB	#UQB$M_RIP,-		; Clear status bit
		 UQB$B_FLAGS(R1)
	MOVL	CDRP$L_STRT_UQB(R5),R1	; Recover original UQB
	MOVL	R1,CDRP$L_UQB(R5)	; Restore it
	MOVL	UQB$L_UCB(R1),-		; Transfer UCB pointer
		 CDRP$L_UCB(R5)
	MOVZWL	#512,CDRP$L_IOST1+2(R5)	; Show one block read
140$:	MOVZWL	#SS$_NORMAL,R0		; Set success status
150$:	MOVW	CDRP$L_FR3X+2(R5),-	; Restore function code
		 CDRP$W_FUNC(R5)
	MOVL	CDRP$L_MST_UQB(R5),R2	; Grab shadow master UQB
	BICB	#UQB$M_RIP,-		; Clear status bit
		 UQB$B_FLAGS(R2)
	MOVL	CDRP$L_CDTX(R5),R4	; Pick up CDT address
	MOVL	CDT$L_PDT(R4),R4	; Pick up PDT address
	JMP	@CDRP$L_SAVD_RTX(R5)	; Return
	.PAGE
	.SBTTL	-	34 - WRITE
;********************************************************
;							*
;	# 34 -  W R I T E				*
;							*
;********************************************************
;
	.ENABLE LSB

WRITE:
	BITW	#<MSCP$M_UF_WRTPS!-
		  MSCP$M_UF_WRTPH>,-
		 UQB$W_UNT_FLGS(R4)	; If WRITE_PROTECT
	BEQL	10$
	MOVL	#MSCP$K_ST_WRTPR, R0	; Set error status
	BRW	SEND_PKT		; ... and exit

10$:	MOVW	#IO$_WRITEPBLK,R0	; Set up for write
DO_WRT:	BSBW	SETUP
	BITB	#1@CDRP$V_NOHSTBUF,-	; Test flags
		 CDRP$B_FLAGS(R5)
	BNEQ	20$			; Skip if no host buffer
	MOVW	#1,CDRP$W_STATE(R5)	; Mapping resource wait state
	MAP_IRP				; Map the data
;
; Request data from host buffer
;
20$:	MOVW	#3,CDRP$W_STATE(R5)	; Bump the state
	BITB	#1@CDRP$V_NOHSTBUF,-	; Test flags
		 CDRP$B_FLAGS(R5)
	BNEQ	30$			; Skip if no host buffer
; ??? Begin bug trap
	MOVL	CDRP$L_MSGBUFX(R5),R2	; Get message buffer address for validity check
	MOVL	CDRP$L_CDT(R5),R1	; Get CDT address
	CMPL	CDT$L_LCONID(R1), -	; Check validity of remote conid
		SCS$L_DST_CONID(R2)
	BNEQ	25$			; Trying to use stale connection
; ??? End bug trap
	CLRL	CDRP$L_MSG_BUF(R5)	; Mark it not in use
	REQUEST_DATA			; Get the data from host
	BLBS	R0,30$			; Success
	BRW	ABX_ER			; Aborted

25$:	BUG_CHECK	MSCPSERV,FATAL	; Trying to use stale CDT
;
; Write the data to the disk
;
30$:	DECL	CDRP$L_CMD_STS(R5) 	; Set the command status
	INCW	CDRP$W_STATE(R5)	; Set state
	MOVL	CDRP$L_SHDW_LNK(R5),R3	; Pick up the first IRP
	BEQL	60$			; No shadowing, skip
	MOVL	#1,CDRP$L_IOST1(R5)	; Set default success
40$:	PUSHL	IRP$L_SHDW_LNK(R3)	; Save pointer to next IRP
	MOVQ	R4,-(SP)		; Save registers
	BSBB	70$			; Do it
	MOVQ	(SP)+,R4		; Restore registers
	POPL	R3			; Restore pointer
	BNEQ	40$			;  and loop
50$:	RSB				; None left, leave now
;
; Non-shadowed writes
;
60$:	BSBW	DO_DISK			; Do the disk transfer
	PUSHAB	20$			; Loop return
	BRW	TST_END			; Check if finished
;
; Shadowed writes
;
70$:	INCB	CDRP$B_SHDW_CNT(R5)	; Count the number of copies
80$:	BSBW	DO_DISKA		; Do the disk transfer
	BLBC	R0,WRITE_ERR		; Error
90$:	DECB	CDRP$B_SHDW_CNT(R5)	; Drop the count
	BNEQ	50$			; Not finished, go back for more
	PUSHAB	20$			; Loop return
	MOVL	CDRP$L_IOST1(R5),R0	; Pick up composite status
	BRW	TST_END			; Check if finished
;
; Shadowed write error recovery.
;
WRITE_ERR:
	BBS	#CDRP$V_ABORT,-		; Leave if abort
		 CDRP$B_FLAGS(R5),90$
	CMPW	R0,#SS$_PARITY		; If not parity
	BEQL	110$			;  then
	MOVZWL	#SS$_SHACHASTA,-	; Update composite status
		 CDRP$L_IOST1(R5)
	BRB	90$			; Continue

110$:	MOVL	#1,R0			; Set for success
	ASHL	#-9,IRP$L_IOST1+2(R3),R1; Number of blocks transfered
	INCL	R1			; Skip this block
	ADDL	R1,IRP$L_LBN(R3)	; Show it
	ASHL	#2,R1,R1		; Number of bytes of svapte
	ADDL	R1,IRP$L_SVAPTE(R3)	; Update buffer address
	ASHL	#7,R1,R1		; Number of bytes "transfered"
	SUBL	R1,IRP$L_BCNT(R3)	; Left to go
	BNEQ	80$			; Redo the IO
	BRB	90$			; Nothing left, fake success

	.DISABLE LSB
	.PAGE
	.SBTTL	SETUP - Setup the CDRP for transfers

;++
;
; SETUP - Set up the all the entries for both disk and CI transfers
;
; Inputs:
;	R0  =	Function code
;	R2 -->	MSCP packet
;	R4 -->	UQB
;	R5 -->	CDRP
;
; Output:
;	R4 -->	PDT
;	R5 -->	CDRP
;
;--

SETUP:	MOVL	CDRP$L_MSGBUFX(R5),R2	; Refresh R2 => MSCP message.
	MOVL	R4,CDRP$L_UQB(R5)	; Save the UQB pointer
	MOVL	R4,CDRP$L_MST_UQB(R5)	; Save master UQB pointer
	INSQUE	CDRP$L_UQB_FL(R5), -	; Insert this packet on unit que
		 @UQB$L_CDRP_BL(R4)
	INCW	UQB$W_NUM_QUE(R4)	; Bump number of packet queue to unit
	CMPW	UQB$W_NUM_QUE(R4),-	; Is this number <= max?
		UQB$W_MAX_QUE(R4)
	BLEQU	10$			; Yes, skip
	MOVW	UQB$W_NUM_QUE(R4),-	; No, set new max
		UQB$W_MAX_QUE(R4)
10$:	CLRW	CDRP$W_STATE(R5)	; Set state
	BITW	#1@MSCP$V_MD_COMP,-
		 MSCP$W_MODIFIER(R2)
	BEQL	20$			; If COMPARE modifier
	BISW	#IO$M_DATACHECK,R0	; ... set DATACHECK modifier
20$:	BITW	#1@MSCP$V_MD_SEREC,-
		 MSCP$W_MODIFIER(R2)
	BEQL	30$			; If SUPPRESS ERROR CORRECT modifier
	BISW	#IO$M_INHRETRY,R0	; ... set INHIBIT RETRY modifier
30$:	MOVW	R0,CDRP$W_FUNC(R5)	; Set completed code in packet
	MOVL	MSCP$L_BYTE_CNT(R2),R1	; Pick up size of request
	BEQL	60$			; Special case zero length
	MOVL	UQB$L_UCB(R4),-		; Transfer UCB address
		 CDRP$L_UCB(R5)		;   to UCB addr in IRP
	CLRL	CDRP$L_ABCNT(R5)	; Clear accumulated byte count
	MOVL	R1,CDRP$L_OBCNT(R5)	; Set original byte count
	MOVL	R1,R3			; Copy to another register
	DECL	R3			; Round byte count down
	ASHL	#-VA$S_BYTE,R3,R3	; Convert to block count
	MOVL	R3,R0			; Block count
	CMPL	R0,#127			; If less than, skip on
	BLEQU	40$
	MOVZBL	#127,R0			; Else make 127
40$:	INCL	BLK_COUNT+4[R0]		; Keep statistics
	MOVL	MSCP$L_LBN(R2),R0	; Transfer the logical block number
	ADDL	R0,R3			; Calculate ending block number
	CMPL	R3,UQB$L_MAXBLOCK(R4)	; Legal block number
	BGTRU	50$			; If GTRU no
	ADDL3	R0,UQB$L_START_LBN(R4),-
		 CDRP$L_LBN(R5)		; Set 'real' starting LBN
	BITB	#1@CDRP$V_NOHSTBUF,-	; Is this a no host buffer IO?
		 CDRP$B_FLAGS(R5)
	BEQL	70$			; No, continue with setup
	MOVL	R1,CDRP$L_BUFLEN(R5)	; Yes, save length
	MOVQ	MSCP$B_BUFFER(R2),-	; Xfer SVAPTE and BOFF
		 CDRP$L_SVAPTE(R5)
	BRW	130$			; And finish

;
; Out of line error routine
;

50$:	TSTL	(SP)+			; Get rid of return address
	MOVZWL	#MSCP$K_ST_ICMD -
		!<MSCP$L_BYTE_CNT@8>,R0	; Set error status
	BRW	SEND_PKT		; Leave in disgrace

60$:	INCL	BLK_COUNT		; Count zero block transfer
	TSTL	(SP)+			; Get rid of return address
	BRW	SEND_SUCCESS

;
; Not a passthru so grab an internal buffer, and map it
;

70$:	MOVAL	MSCP$B_BUFFER(R2), -	; Calculate offset of remote buf hdl
		 CDRP$L_RBUFH_AD(R5)
	CLRL	CDRP$L_RBOFF(R5)	; Clear remote offset
	CMPL	R1,FRACTION		; Greater than the fraction?
	BLEQU	80$			; No, continue
	MOVL	FRACTION,R1		; Yes, use the fraction
80$:	MOVAB	511(R1),R1		; Round up
	BICL2	#511,R1
	BEQL	90$			; Less than a page
	MOVAL	BUFF_HEAD,R3		; Set up
	PUSHL	R1			; Save request size
	JSB	@#EXE$ALLOCATE		; Grab the block
	BLBS	R0,110$			; Space
	POPL	R1			; Retrieve request size
	CMPL	R1,SMALL		; Less than smallest fragment?
	BLEQU	90$			; Yes, wait for pool
	ASHL	#-1,R1,R1		; Try for half
	BRB	80$			; And go again

90$:	POPL	CDRP$L_SAVD_RTN(R5)	; Store return address
	INSQUE	CDRP$L_FQFL(R5),-	; Insert on the waiting que
		 @MEM_WAIT+4
	INCW	NUM_QUE			; Bump memory wait counter
	CMPW	NUM_QUE,MAX_QUE		; Maximize with
	BLEQU	100$			;  current
	MOVW	NUM_QUE,MAX_QUE		;  maximum
100$:	WFINT				; Stall until resource avail
					; (Will be activated at CLEAN_UP)
	DECW	NUM_QUE			; Decr memory wait counter
	PUSHL	CDRP$L_SAVD_RTN(R5)	; Set return address
	MOVL	CDRP$L_OBCNT(R5),R1	; Pick up needed length
	BRB	80$			; Try again

105$:	BUG_CHECK	MSCPSERV,FATAL	; Allocated region out of bounds

110$:	ADDL2	#4,SP			; Flush request size
; ??? BUG TRAP
	CMPL	R2,BUFF_ADDR		; Does address precede allocation region
	BLSSU	105$			; Branch if yes
	ADDL3	R2,R1,R0		; End of region+1
	CMPL	R0,BUFF_END		; Is it beyond+1
	BGTRU	105$
; ??? END BUG TRAP
	INCW	CDRP$W_STATE(R5)	; Bump the state
	MOVQ	R1,CDRP$L_BUFLEN(R5)	; Save length and address
	CMPL	R1,CDRP$L_OBCNT(R5)	; If the length has been rounded
	BLEQ	120$			;  then
	MOVL	CDRP$L_OBCNT(R5),R1	; Restore the original byte count
120$:	MOVL	R1,CDRP$L_XCT_LEN(R5)	; Set length in place for S/R DATA
	BISB	#1@CDRP$V_BUFFER, -
		 CDRP$B_FLAGS(R5)	; Set buffer flag
	BICW3	#^XFE00,R2, -
		 CDRP$W_BOFF(R5)	; Set the byte offset
	EXTZV	#VA$V_VPN,#VA$S_VPN,-
		 R2,R2			; Virtual page number
	MOVL	@#MMG$GL_SPTBASE, R0	; Get address of sys page table
	MOVAL	(R0)[R2],CDRP$L_SVAPTE(R5)  ; Set in CDRP
130$:	MOVL	R1,CDRP$L_BCNT(R5)	; Set the length = byte count
;
; Almost done, now check for shadowing and allocate multiple IRP's
;
	CLRL	CDRP$L_SHDW_LNK(R5)	; Clear out shadow irp link
	MOVAL	CDRP$L_IOQFL(R5),R1	; Cover IRP portion w/R1
	BITW	#1@MSCP$V_UF_SSMST,-	; If shadow unit
		 UQB$W_UNT_FLGS(R4)
	BNEQ	SETUP_SHADOW		;  then do shadow specific

SETUP_OUT:
	MOVL	CDRP$L_CDTX(R5),R4	; Pick up the CDT address
	MOVL	CDT$L_PDT(R4),R4	; Set up PDT address
	RSB

;
; Shadowing enabled, grab extra IRP's for the multiple operations.
;

SETUP_SHADOW:
	CMPB	#MSCP$K_OP_WRITE,-
		 CDRP$B_OPCODE(R5)	; Leave if not write
	BEQL	SETUP_SHADOW_WRITE
	BRW	SETUP_SHADOW_READ
;
; Shadow writes.  Check for CIP.  If so may need to hold write.  If not
; spawn extra IRP's for the multiple write operations.
;
SETUP_SHADOW_WRITE:
	BITW	#UQB$M_CIP,-
		 UQB$B_FLAGS(R4) 	; If CIP not in progress
	BEQL	20$			;  just continue on
	CLRL	CDRP$L_FR4X(R5)		; Clear a flag
	MOVL	CDRP$L_LBN(R5),R0	; Pick up starting block
	ASHL	#-9,CDRP$L_OBCNT(R5),R1	; Get block range
	ADDL	R0,R1			; Now ending block
	CMPL	R0,UQB$L_FENCEH(R4)	; Check
	BGEQU	20$			; Outside (over)
	INCL	CDRP$L_FR4X(R5)		; Set a flag
	CMPL	R1,UQB$L_FENCEL(R4)	; Check block range
	BLEQU	20$			; Outside (under)
10$:	BISB	#UQB$M_CMDPEND,-	; Set a write pending
		 UQB$B_FLAGS(R4)
	POPL	CDRP$L_SAVD_RTN(R5)	; Hold return adress
	BSBW	DEALLOC_BUFF		; Get rid of buffer
	REMQUE	CDRP$L_UQB_FL(R5),R0	; Remove from executing queue
	DECW	UQB$W_NUM_QUE(R4)	;  (make count agree)
	INSQUE	(R0),@UQB$Q_SHQ+4(R4)	; Insert on special queue
	MOVW	#6,CDRP$W_STATE(R5)	; Set state as special queued
	WFINT				; Block and wait for copy to complete
	PUSHL	CDRP$L_SAVD_RTN(R5)	; Restore
	MOVW	#IO$_WRITEPBLK,R0	; Set for write
	BRW	SETUP			; Now try again
;
; Now either we had no copy-in-progress on the shadow unit or we did but
; the IO was outside the fence.  If the latter, then we write to all
; units if under the fence; and to all units except the CIP unit if over.
;
20$:	CMPW	UQB$W_SHDW_STS(R4),#1	; If shadow count <= 1,
	BGTRU	25$			;  then
	BRW	SETUP_OUT		;  do NOT shadow

25$:	MOVZWL	UQB$W_SHDW_STS(R4),-(SP); Set up unit counter
	MOVAL	CDRP$L_IOQFL(R5),R1	; Cover IRP portion w/R1
30$:	MOVL	UQB$L_SHDW_FL(R4),R3	; Pick up possible shadown UQB's
	BITB	#UQB$M_CIP,-		; Check for copy in progress
		 UQB$B_FLAGS(R3)
	BEQL	40$			; None, all is okay
	BLBS	CDRP$L_FR4X(R5),40$	; CIP, but IO is under the fence
	MOVL	R3,R4			; Ooops, try another
	BRB	50$			; Check for end of line
;
; Grab an IRP for each active shadow set member
;
40$:	PUSHL	R1			; Save R1
	MOVZWL	#IRP$C_LENGTH,R1	; Size for an IRP
	BSBW	ALLOMEM			; Grab one
	POPL	R1			; Restore
	BLBS	R0,45$			; Success
	BRW	SETUP_ERR		; No space left
;
; Fill in the IRP with the essential transfer fields
;
45$:	MOVL	#<DYN$C_IRP@16>!-	; Set size and DYN code
		 <<IRP$C_LENGTH+15>&-16>,-
		 IRP$W_SIZE(R2)
	BISB	#1@CDRP$V_SLAVE,-	; Set the slave IRP flag
		 CDRP$B_FLAGS(R5)
	MOVL	R5,IRP$L_MAINCDRP(R2)	; Set pointer to CDRP
	MOVL	R3,IRP$L_UQB(R2)	; Set pointer to UQB
	CLRL	IRP$L_SHDW_LNK(R2)	; Clear shadowing pointer
	MOVL	R2,IRP$L_SHDW_LNK(R1)	; Set back pointer
	MOVQ	CDRP$W_STS(R5),-	; Copy transfer parameters
		 IRP$W_STS(R2)
	MOVL	CDRP$L_BCNT(R5),-	; Ditto
		 IRP$L_BCNT(R2)
	MOVL	CDRP$L_LBN(R5),-	; Ditto
		 IRP$L_LBN(R2)
	MOVL	R3,R4			; Copy UQB pointer	
	MOVL	CDRP$W_FUNC(R5),-	; Ditto
		 IRP$W_FUNC(R2)
	MOVL	UQB$L_UCB(R4),-		; Ditto
		 IRP$L_UCB(R2)
	MOVL	R2,R3			; Cover IRP
	MOVL	CDRP$W_SLOT(R5),-	; Copy flags and unit
		 IRP$W_SLOT(R2)
	MOVL	R2,R1			; Copy IRP pointer
	CLRW	IRP$W_STATE(R2)		; Clear out indicator
	BISB	#1@CDRP$V_SLAVE,-	; Set the slave IRP flag
		 IRP$B_FLAGS(R1)
50$:	DECL	(SP)			; Count down
	BGTRU	30$			; More to go
	TSTL	(SP)+			; Clean stack
	BRW	SETUP_OUT		; End of the line
;
; Shadow reads.  Pick the next unit to read from.  Advance the ring pointer.
;
SETUP_SHADOW_READ:
	MOVL	UQB$L_SHDW_FL(R4),R1	; Pick up first unit
	MOVL	R1,CDRP$L_STRT_UQB(R5)	; Set end condition
	BSBB	SELECT_FIRST_UNIT	; Pick up first useable reader
	BEQL	999$			; ERROR
	MOVL	UQB$L_SHDW_FL(R1),-	; Update master UQB pointer
		 UQB$L_SHDW_FL(R4)
	BRW	SETUP_OUT		; Leave

999$:	BUG_CHECK  MSCPSERV,FATAL	; ERROR
;
; SELECT_NEXT_UNIT - Loop thru the shadow members
;
;	R1 -->	Base UQB to start from
; **** USE CIP IF BELOW FENCE?
;
	.ENABLE LSB

SELECT_NEXT_UNIT:
10$:	MOVL	UQB$L_SHDW_FL(R1),R1	; Pick up next candidate
	CMPL	R1,CDRP$L_STRT_UQB(R5)	; Have we gone around the ring
	BEQL	20$			; Yes, just error out

SELECT_FIRST_UNIT:
	BITB	#UQB$M_CIP,-		; Check for possible copy in progress
		 UQB$B_FLAGS(R1)
	BNEQ	10$			; Yes, disqualify
	TSTW	UQB$W_STATUS(R1)	; Check for ONLINE
	BNEQ	10$			; No, disqualify
	MOVL	R1,CDRP$L_UQB(R5)	; Transfer new UQB pointer
	MOVL	UQB$L_UCB(R1),-		; Transfer UCB pointer
		 CDRP$L_UCB(R5)
20$:	RSB				; Leave with status

	.DISABLE LSB
;
; ERROR handler
;
SETUP_ERR:
	ADDL	#8,SP			; Get rid of return address & count
	MOVZWL	#<5*MSCP$K_ST_SBCOD!-
		 MSCP$K_ST_CNTLR>,R0	; Set error status ;*** TEMP
	BRW	SEND_PKT		; Leave in disgrace
	.PAGE
	.SBTTL	DO_DISK & BACK - DISK IO utility routines

;++
;
; DO_DISK - Routine to set up IRP for disk I/O
;
; Inputs:
;
;	R3 -	Current IRP address
;	R4 -	PDT address
;	R5 -	(Master) CDRP address
;
;--

	.ENABLE	LSB

DO_DISK:
	MOVAB	CDRP$L_IOQFL(R5),R3	; Cover IRP portion

DO_DISKA:
	MOVL	CDRP$L_UQB(R5),R1	; Pick up UQB ptr
	TSTW	UQB$W_STATUS(R1)	; Has it gone AVAIL while we waited?
	BEQL	DO_DISKX		; No, finish IO
	MOVZWL	#SS$_MEDOFL,R0		; Yes, give error code
	RSB				;  and leave

INV_FUNC:
	BUG_CHECK	MSCPSERV,FATAL	; Invalid function code

DO_DISKX:
	POPL	IRP$L_FPCX(R3)		; Where to return after IOPOST
	MOVL	R4,IRP$L_FR4X(R3)	; Save R4
	ASSUME	CDRP$V_SLAVE EQ 0
	BLBS	IRP$B_FLAGS(R3),5$	; If this is a slave IRP, then
	MOVL	CDRP$L_XCT_LEN(R5),-	;  Save length in a safe place
		 CDRP$L_XCT_LENX(R5)
5$:	MOVAB	W^BACK,IRP$L_PID(R3)	; Addr to which IOPOST will return IRP
	CLRL	CDRP$L_MSG_BUF(R5)	; Mark it not in use
; ??? begin bug trap
	EXTZV	#IO$V_FCODE, -		; Isolate function code
		#IO$S_FCODE, -
		IRP$W_FUNC(R3),R0
	CMPW	R0,#IO$_READPBLK	; Read?
	BEQL	7$			; Branch if read
	CMPW	R0,#IO$_WRITEPBLK	; Write?
	BEQL	7$			; Branch if write
	PUSHL	R5			; Save CDRP address
	MOVL	IRP$L_UCB(R3),R5	; Get UCB address
	MOVL	UCB$L_DDT(R5),R5	; DDT address
	BBC	R0,@DDT$L_FDT(R5),INV_FUNC	; Branch if function code is invalid
	POPL	R5			; Restore CDRP address
	CMPW	R0,#IO$_WRITECHECK	; Writecheck?
	BNEQ	9$
7$:	CMPL	IRP$L_BCNT(R3),CDRP$L_BUFLEN(R5)
	BGTRU	8$			; Tilt!
	SUBL3	@#MMG$GL_SPTBASE, -	; Get address of buffer page table
		IRP$L_SVAPTE(R3),R0
	ASHL	#9-2,R0,R0		; Convert to address in segment
	BBSS	#31,R0,71$		; Set 80000000 bit
71$:	ADDW2	CDRP$W_BOFF(R5),R0
	CMPL	R0,CDRP$L_BUFADR(R5)	; Is buffer address consistent?
	BNEQ	8$
	CMPL	R0,BUFF_ADDR
	BLSSU	8$			; Start of buffer out of bounds
	ADDL2	IRP$L_BCNT(R3),R0
	CMPL	R0,BUFF_END		; Is buffer contained within range?
	BLEQU	9$			; Branch if yes
8$:	BUG_CHECK	MSCPSERV,FATAL	; Invalid disk buffer address

9$:
; ??? end bug trap
	MOVL	IRP$L_LBN(R3),R0	; Pick up starting logical block
	MOVL	IRP$L_UQB(R3),R5	; Pick up UQB ptr
	INCW	UQB$W_NUM_OPS(R5)	; Bump number of packets queued to unit
	CMPW	UQB$W_NUM_OPS(R5),-	; Greater than current max?
		 UQB$W_MAX_OPS(R5)
	BLEQU	10$			; No, skip on
	MOVW	UQB$W_NUM_OPS(R5),-	; Yes, replace current max
		 UQB$W_MAX_OPS(R5)
10$:	MOVL	IRP$L_UCB(R3),R5	;  and now UCB
	TSTL	@#PMS$GL_IOPFMPDB	; I/O performance monitoring enabled ?
	BNEQ	30$			; BR if yes
	DSBINT	#15			; Protect I/O sequence # manipulation
	MOVL	@#PMS$GL_IOPFMSEQ,-	; Insert I/O sequence # into IRP
		 IRP$L_SEQNUM(R3)
	INCL	@#PMS$GL_IOPFMSEQ	; and bump global counter
	ENBINT				; Restore previous IPL
20$:	JSB	@#IOC$CVTLOGPHY		; Convert logical to physical block
	JMP	@#EXE$INSIOQ		; Queue the IRP to the driver

30$:	JSB	@#PMS$START_RQ		; Gather Start I/O Request statistics
	BRB	20$

	.DISABLE LSB
;
; Routine will RSB back to our caller's caller which is in the PORT
; DRIVER.  Thread is now suspended and will resume when IOPOST calls us
; at entry BACK.
;
;	R5 -->	IRP
;
BACK:	DSBINT	#IPL$_SCS		; Set IPL to FORK
	BICW	#IRP$M_PHYSIO,-		; Clear the physical IO flag
		 IRP$W_STS(R5)		;  only needed for ONLINE
	TSTL	@#PMS$GL_IOPFMPDB	; I/O performance monitoring enabled ?
	BEQL	10$			; BR if no
	JSB	@#PMS$END_RQ		; Gather End I/O Request statistics
10$:	MOVL	R5,R3			; R3-->head of IRP
	MOVL	IRP$L_FR4X(R3),R4	; Restore PDT
	MOVL	IRP$L_UQB(R3),R1	; Pick up UQB pointer
	DECW	UQB$W_NUM_OPS(R1)	; Drop count of operations
	MOVL	IRP$L_UCB(R3),R1	; Pick up UCB pointer
	DECW	UCB$W_QLEN(R1)		; Drop queue length counter
	ASSUME	CDRP$V_SLAVE EQ 0
	BLBC	IRP$B_FLAGS(R3),20$	; If this is a slave IRP
	MOVL	IRP$L_MAINCDRP(R3),R5	;  then get CDRP addr from IRP
	BRB	30$			;  and skip a lot of code

20$:	MOVAL	-CDRP$L_IOQFL(R5), R5	; Pick up address of CDRP
	MOVL	CDRP$L_CDTX(R5),-	; Restore our CDT address
		 CDRP$L_CDT(R5)
	CLRL	CDRP$L_RWCPTR(R5)	; Clear out any trash
	CLRL	CDRP$L_MSG_BUF(R5)	; Mark it not in use
	MOVAB	CDRP$B_LBUFF(R5),-	; Reset local buff handle
		 CDRP$L_LBUFH_AD(R5)
	CLRL	CDRP$L_LBOFF(R5)	; Ditto
	MOVL	CDRP$L_ABCNT(R5), -	; Set the remote byte offset
		 CDRP$L_RBOFF(R5)	;  to be accumlated xfer size
	MOVL	CDRP$L_MSGBUFX(R5),R0	; Pick up message buffer address
	BEQL	30$			; None, skip next instruction
	MOVAL	MSCP$B_BUFFER(R0), -	; Calculate offset of remote buf hdl
		 CDRP$L_RBUFH_AD(R5)
30$:	MOVL	CDRP$L_XCT_LENX(R5),-	; Restore length
		 CDRP$L_XCT_LEN(R5)
	DECL	CDRP$L_CMD_STS(R5) 	; Set the command status
	INCW	IRP$W_STATE(R3)		; Bump the state
	MOVL	IRP$L_IOST1(R3),R0	; Pick up iosb
	JSB	@IRP$L_FPCX(R3)		; Resume thread
	ENBINT				; Lower IPL to IOPOST
	RSB				;  and return
	.page
	.SBTTL	UTILITY ROUTINES

;************************************************************************
;									*
;									*
;			S E A R C H _ Q U E				*
;									*
;									*
;************************************************************************
;+
; Input:
;	R3 = Address of HQB possible having a CDRP with that command
;	R4 = Unit number
;	R5 = Address of CDRP containing command reference # to search for
;
; Output:
;	R0 = Status
;		Low bit clear if not found
;		Low bit set if found
;	R1 --> CDRP$L_UQB_FL of the CDRP found
;-

SEARCH_QUE:
	CLRL	R0			; Set for failure
	MOVL	UNIT_VEC[R4],R4		; Grab UQB
	BEQL	40$			; None there
	PUSHL	R6			; Grab a register
	MOVL	CDRP$L_MSGBUFX(R5),R6	; Pick up buffer
	MOVL	MSCP$L_OUT_REF(R6),R6	; Id to search for
	TSTW	UQB$W_NUM_QUE(R4)	; Any entries on normal que?
	BEQL	10$			; No, leave now
	MOVAB	UQB$L_CDRP_FL(R4),R1	; Set to head of que
	BSBB	50$			; Look for the packet
	BLBS	R0,30$			; Found it

10$:	TSTW	UQB$W_NUM_BLK(R4)	; Any entries on blocked que?
	BEQL	20$			; No, leave now
	MOVAB	UQB$Q_BLOCKQ(R4),R1	; Set to head of que
	BSBB	50$			; Look for the packet
	BLBS	R0,30$			; Found it

20$:	MOVAB	UQB$Q_SHQ(R4),R1	; Set to head of special hold que
	BSBB	50$			; Look for the packet
	BLBS	R0,30$			; Found it
	BBC	#UQB$V_CIP,-		; If unit is part of shadow copy
		 UQB$B_FLAGS(R4),30$	;  then
	MOVL	UQB$L_CPY_CDRP(R4),R1	; Pick up pointer to its CDRP
	MOVAB	CDRP$L_UQB_FL(R1),R1	; Adjust pointer
	CMPL	HQB$L_CDT(R3),-		; Is this CDRP for this HQB?
		 CDRP$L_CDTX-CDRP$L_UQB_FL(R1)
	BNEQ	30$			; No
	ASSUME	MSCP$L_CMD_REF EQ 0
	TSTL	CDRP$L_MSGBUFX- -	; Is there a message buffer?
		 CDRP$L_UQB_FL(R1)
	BEQL	30$			; No, so can never match
	CMPL	@CDRP$L_MSGBUFX- -
		 CDRP$L_UQB_FL(R1),R6	; Match com ref no in host chain
	BNEQ	30$			; No, leave
	INCL	R0			; Set success
30$:	POPL	R6
40$:	RSB

50$:	CLRL	R0			; Set for failure
	MOVL	R1,R2			; Store pointer
60$:	MOVL	(R1),R1			; No, try next entry
	CMPL	R1,R2			; End of que?
	BEQL	70$			; Yes
	CMPL	HQB$L_CDT(R3),-		; Is this CDRP for this HQB?
		 CDRP$L_CDTX(R5)
	BNEQ	60$			; No, flink on
	ASSUME	MSCP$L_CMD_REF EQ 0
	TSTL	CDRP$L_MSGBUFX- -	; Is there a message buffer?
		 CDRP$L_UQB_FL(R1)
	BEQL	60$			; No, so can never match
	CMPL	@CDRP$L_MSGBUFX- -
		 CDRP$L_UQB_FL(R1),R6	; Match com ref no in host chain
	BNEQ	60$			; No, loop
	INCL	R0			; Set success
70$:	RSB
	.PAGE
	.SBTTL	DATA STRUCTURE ALLOCATION

;************************************************************************
;									*
;									*
;			GET_STRUCT					*
;									*
;									*
;************************************************************************
;+
; Input:
;	NONE
;
; Output:
;	R0 = Status
;		Low bit clear if none available
;		Low bit set if found
;	R5 --> CDRP found
;-

GET_STRUCT:
	REMQUE	@CDRP_LIST,R5		; Pick up a CDRP
	BVS	30$			; None left
	DECW	NUM_PKT			; Drop number of free packets
	MOVL	S^#SS$_NORMAL,R0	; Set success status
	RSB

20$:	MOVZWL	#SS$_INSFMEM,R0		; ERROR
	POPR	#^M<R1,R2,R3,R4>	; Restore volatile registers
	RSB				; Leave

30$:	PUSHR	#^M<R1,R2,R3,R4>	; Save volatile registers
	MOVZWL	#BIG_CDRP,R1		; Get total size
	BSBW	ALLOMEM			; Allocate them
	BLBC	R0,20$			; No memory available
;
; Fill in skeletal CDRP
;
	MOVQ	R1,-(SP)		; Save
	MOVC5	#0,(SP),#0,R1,(R2)	; Clear it all out
	MOVQ	(SP)+,R4		; Recover length
	MOVAL	-CDRP$L_IOQFL(R5), R5	; Set to the CDRP portion
	MOVB	#DYN$C_IRP, -
		CDRP$B_IRP_TYPE(R5)	; Fill in size/type/rmod fields
	MOVW	R4,CDRP$W_IRP_SIZE(R5)	; Fill in size/type/rmod fields
	MOVB	#IPL$_SCS,CDRP$B_FIPL(R5) ; CDRP IPL
	MOVB	#DYN$C_CDRP, -
		CDRP$B_CD_TYPE(R5)	; CDRP block type
	MOVW	#CDRP$L_IOQFL,-
		CDRP$W_CDRPSIZE(R5)	; Ditto for smaller portion
	MOVB	IO_PRI,CDRP$B_PRI(R5)	; Set the IO priority
	MOVAL	CDRP$B_LBUFF(R5), -	; Set pointer to local buffer handle
		CDRP$L_LBUFH_AD(R5)
	INCW	INI_PKT			; Total packets
	POPR	#^M<R1,R2,R3,R4>	; Restore volatile registers
	BSBB	FREE_STRUCT		; Put on free list -- has side effect
					;  of initializing CDRP$L_FQFL linkage
	BRB	GET_STRUCT		; Try again

;************************************************************************
;									*
;									*
;			FREE_STRUCT					*
;									*
;									*
;************************************************************************
;+
; Input:
;	R5 --> CDRP
;
; Output:
;	NONE
;-

FREE_STRUCT:
; Mung structure to trap bugs
	MOVL	#1,CDRP$L_IOQBL(R5)	; Zap IRP queue linkage to catch bugs
	MOVL	#1,CDRP$L_FQBL(R5)	; Zap CDRP queue linkage to catch bugs
	MOVL	#1,CDRP$L_UQB_BL(R5)	; Zap another queue linkage
	MOVL	#1,CDRP$L_CDT(R5)	; ZAP CDT address
	MOVL	#1,CDRP$L_CDTX(R5)	; ZAP CDT address
	MOVL	#1,CDRP$L_MSGBUFX(R5)	; ZAP SCS message buffer address
	MOVL	#1,CDRP$L_MSG_BUF(R5)	; ZAP SCS message buffer address
	MOVL	#1,CDRP$L_UQB(R5)	; ZAP UQB address
	MOVL	#1,CDRP$L_MST_UQB(R5)	; ZAP master UQB address
	MOVL	#1,CDRP$L_FR3X(R5)	; Alia IRP$L_MAINCDRP
	MOVL	#1,CDRP$L_HQB(R5)	; ZAP HQB address
	MOVW	#63,CDRP$W_STATE(R5)	; Set state invalid
	MOVAB	B^20$,CDRP$L_FPC(R5)	; Zap CDRP fork PC
	MOVAB	B^20$,CDRP$L_PID(R5)	; Zap IRP fork PC
	MOVAB	B^20$,CDRP$L_FPCX(R5)	; Zap another fork PC
; Now deallocate the structure
;; Avoid problems (maybe) by hanging onto packets forever
;;	CMPW	NUM_PKT,MAX_PKT		; Are enough packets cached?
;;	BGEQU	10$			; Branch if yes
	INSQUE	(R5),@CDRP_LIST+4	; Return the cdrp
	INCW	NUM_PKT			; Account for it
	RSB

;;10$:	PUSHR	#^M<R0,R1,R2,R3>	; Save volatile registers
;;	MOVAL	CDRP$L_IOQFL(R5),R0	; Structure address
;;	BSBW	DEALMEM			; Deallocate structure
;;	POPR	#^M<R0,R1,R2,R3>	; Restore volatile registers
;;	DECW	INI_PKT			; Drop count of allocated structures
;;	RSB				; Return

20$:	BUG_CHECK	MSCPSERV,FATAL

	.PAGE
	.SBTTL	READ ONLY DATA

	.ALIGN	LONG

LIS_CDT:.LONG	0
;
SERV_INFO:
SERV_NAME:
	.ASCII	/MSCP$DISK       /
;
COM_PKT_LEN:
	.BYTE	0*4,4*4,5*4,3*4,7*4,0*4,0*4,0
	.BYTE	3*4,9*4,9*4,3*4,0*4,0*4,0*4,0
	.BYTE	0*4,8*4,8*4,8*4,8*4,0*4,0*4,0
	.BYTE	0*4,0*4,0*4,0*4,0*4,0*4,0*4,0
	.BYTE	8*4,8*4,8*4,0*4,0*4,0*4,0*4,0
;
END_PKT_LEN:
	.BYTE	0*4,4*4,5*4,12*4,7*4,0*4,0*4,0
	.BYTE	3*4,11*4,11*4,3*4,0*4,0*4,0*4,0
	.BYTE	8*4,8*4,8*4,8*4,3*4,0*4,0*4,0
	.BYTE	0*4,0*4,0*4,0*4,0*4,0*4,0*4,0
	.BYTE	8*4,8*4,8*4,0*4,0*4,0*4,0*4,0
;
MOD_TBL:
	.WORD	^C0
	.WORD	^C0			; 1-ABORT
	.WORD	^C0			; 2-GET CMD STS
	.WORD	^C<MSCP$M_MD_NXUNT!-
		   MSCP$M_MD_CLSEX>	; 3-GET UNIT STS
	.WORD	^C0			; 4-SET CTRL CHAR
	.WORD	^C0			; 5
	.WORD	^C0			; 6
	.WORD	^C0			; 7
	.WORD	^C<MSCP$M_MD_SPNDW!-	; 8-AVAILABLE
		   MSCP$M_MD_ALLCD!-
		   MSCP$M_MD_CLSEX>
	.WORD	^C<MSCP$M_MD_RIP!-	; 9-ONLINE
		   MSCP$M_MD_IGNMF!-
		   MSCP$M_MD_STWRP!-
		   MSCP$M_MD_SHDSP!-
		   MSCP$M_MD_CLSEX>
	.WORD	^C<MSCP$M_MD_STWRP!-	; 10-SET UNIT CHAR
		   MSCP$M_MD_SHDSP!-
		   MSCP$M_MD_CLSEX>
	.WORD	^C0			; 11-DETERMINE ACCESS PATH
	.WORD	^C0			; 12
	.WORD	^C0			; 13
	.WORD	^C0			; 14
	.WORD	^C0			; 15
	.WORD	^C<MSCP$M_MD_EXPRS!-	; 16-ACCESS
		   MSCP$M_MD_CLSEX!-
		   MSCP$M_MD_SCCHH!-
		   MSCP$M_MD_SCCHL!-
		   MSCP$M_MD_SEREC!-
		   MSCP$M_MD_SECOR!-
		   MSCP$M_MD_SSHDW>
	.WORD	^C<MSCP$M_MD_EXPRS!-	; 17-COMP CTRL DATA
		   MSCP$M_MD_CLSEX!-
		   MSCP$M_MD_SCCHH!-
		   MSCP$M_MD_SCCHL!-
		   MSCP$M_MD_SEREC!-
		   MSCP$M_MD_SECOR!-
		   MSCP$M_MD_SSHDW>
	.WORD	^C<MSCP$M_MD_EXPRS!-	; 18-ERASE
		   MSCP$M_MD_SEREC!-
		   MSCP$M_MD_ERROR!-
		   MSCP$M_MD_WBKVL!-
		   MSCP$M_MD_WBKNV!-
		   MSCP$M_MD_CLSEX!-
		   MSCP$M_MD_WRSEQ!-
		   MSCP$M_MD_SSHDW>
	.WORD	^C<MSCP$M_MD_EXPRS!-	; 19-FLUSH
		   MSCP$M_MD_FLENU!-
		   MSCP$M_MD_CLSEX!-
		   MSCP$M_MD_SECOR!-
		   MSCP$M_MD_SEREC!-
		   MSCP$M_MD_SSHDW!-
		   MSCP$M_MD_VOLTL>
	.WORD	^C<MSCP$M_MD_EXPRS!-	; 20-REPLACE
		   MSCP$M_MD_CLSEX!-
		   MSCP$M_MD_PRIMR>
	.WORD	^C0			; 21
	.WORD	^C0			; 22
	.WORD	^C0			; 23
	.WORD	^C0			; 24-MAINT READ
	.WORD	^C0			; 25-MAINT WRITE
	.WORD	^C0			; 26
	.WORD	^C0
	.WORD	^C0			; 28
	.WORD	^C0
	.WORD	^C0			; 30
	.WORD	^C0
	.WORD	^C<MSCP$M_MD_EXPRS!-	; 32-COMP HOST DATA
		   MSCP$M_MD_CLSEX!-
		   MSCP$M_MD_SCCHH!-
		   MSCP$M_MD_SCCHL!-
		   MSCP$M_MD_SEREC!-
		   MSCP$M_MD_SECOR!-
		   MSCP$M_MD_SSHDW>
	.WORD	^C<MSCP$M_MD_EXPRS!-	; 33-READ
		   MSCP$M_MD_COMP!-
		   MSCP$M_MD_CLSEX!-
		   MSCP$M_MD_SCCHH!-
		   MSCP$M_MD_SCCHL!-
		   MSCP$M_MD_SEREC!-
		   MSCP$M_MD_SECOR!-
		   MSCP$M_MD_SSHDW>
	.WORD	^C<MSCP$M_MD_EXPRS!-	; 34-WRITE
		   MSCP$M_MD_COMP!-
		   MSCP$M_MD_CLSEX!-
		   MSCP$M_MD_ERROR!-
		   MSCP$M_MD_WRSEQ!-
		   MSCP$M_MD_WBKNV!-
		   MSCP$M_MD_WBKVL!-
		   MSCP$M_MD_SEREC!-
		   MSCP$M_MD_SECOR!-
		   MSCP$M_MD_SSHDW>
	.WORD	^C0			; 35
	.WORD	^C0
	.WORD	^C0			; 37
	.WORD	^C0
	.WORD	^C0			; 39
;
; Patch area
;

	LC=.
	.=<LC+15>&-16
PATCH:	.LONG	120
	.LONG	PATCH+8
	.BLKB	120

	.PAGE
	.SBTTL	INITIALIZATION ROUTINE

;++
;
; This routine is called to initialize MSCP server from SYSGEN.
;
; Inputs:
;
;	AP -->	#Args
;		action #
		BUF=8	; BUFfers
		PAC=12	; PACkets
		HOS=16	; HOSts
		TIM=20	; TIMeout
		PRI=24	; PRIority
		SMA=28	; SMAllest buffer
		FRA=32	; FRActional buffer
;
; Outputs:
;
;	R0	Status code
;
;--

	.ENABLE	LSB

10$:	MOVZWL	#SS$_INSFMEM,R0		; Insufficient non-paged pool
	BRW	40$

START_CONT:
	MOVL	BUF(AP),R1		; Pick up user specified
	MOVAB	511(R1),R1
	BICW	#511,R1			; Round up to page
	MOVL	R1,MAX_BUF		; Save size
	ADDL	#16,R1			; Allow for header
	SETIPL	#2			; Set us non-deletable
	BSBW	ALLOMEM			; Allocate it
	BLBC	R0,10$			; Can't allocate buffer
	MOVL	R1,BUFF_LENGTH		; Length of buffer
	MOVL	R2,BUFF_ADDR		; Buffer header address
	ADDL3	R1,R2,BUFF_END		; First byte beyond buffer
	CLRQ	(R2)+			; Clear FLINK,BLINK
	ADDL3	#<DYN$C_BUFIO@16>,R1,(R2)+ ; Set pool info
	CLRL	(R2)+			; Skip to 16-byte boundary
	MOVL	R2,BUFF_HEAD		; Set pointer to buffer pool
	CLRL	(R2)+			; Set up head
	SUBL3	#16,R1,(R2)		; Ditto
;
; Pre-allocate CDRP's
;
	MOVL	PAC(AP),R7		; Pick up user specified
	CMPL	R7,#2			; Must be at least 2
	BGEQU	15$			; Branch if 2 or more
	MOVL	#2,R7			; Make it 2
15$:	MOVW	R7,PACKET		; Send to MSCP
	MOVL	HOS(AP),R1		; Pick un number of hosts
	MOVW	R1,INI_HOST		; Save in comm area
	MOVW	R1,NUM_HOST		; Save in comm area
	MULL3	R1,R7,MAX_PKT		; Times the hosts = maximum packets to cache
;
; Set up the queues.
;
	MOVAB	MSCP_BEGIN,R5		; Point to our header
	MOVAL	CDRP_LIST,R4		; Start address of queue
	MOVL	#2*MSU$C_NUMQUE,R0	; Number of queues
20$:	ADDL2	R5,(R4)+		; Make addresses absolute
	SOBGTR	R0,20$			; Loop thru
	MOVAQ	HQBLIST,R0		; List of HQB's
	MOVL	R0,(R0)			; Initialize forward pointer
	MOVAL	(R0)+,(R0)		; Initialize backward pointer

	SUBB3	PRI(AP),#32,IO_PRI	; Set the IO priority to internal value

;
; Set some miscellaneous values
;
30$:	MOVL	FRA(AP),R0		; Set the fractional buffer per I/O
	CMPL	R0,#127*512		; Is it bigger than 127 block?
	BLEQU	32$			; No, all is well
	MOVL	#127*512,R0		; Biggest fraction is 127 block
32$:	MOVL	R0,FRACTION		; Must be I/O viable on any disk
	MOVL	SMA(AP),R0		; Set the smallest fragment per I/O
	CMPL	R0,MAX_BUF		; SMALL may not be larger than MAX_BUF
	BLEQU	35$			; Branch if less than MAX_BUF
	MOVL	MAX_BUF,R0		; Use MAX_BUF
35$:	MOVL	R0,SMALL		; Set the smallest fragment per I/O
	MOVW	TIM(AP),CTRL_INFO+4	; Set the controller timeout
	MOVL	G^SCS$GB_SYSTEMID,-
		 CTRL_ID		; Set the controller id
	MOVW	G^SCS$GB_SYSTEMID+4,-
		 CTRL_ID+4
;
; Establish link with PORT_DRIVER
;
	SETIPL	#IPL$_SCS		; Coordinate activities
	LISTEN	MSGADR=LIS_FORK,-	; Establish ourselves as listener
		ERRADR=LIS_ERR,-
		LPRNAM=SERV_NAME,-
		PRINFO=SERV_INFO
	MOVL	R3,LIS_CDT		; Store the CDT away
	MOVL	#SS$_NORMAL,R0		; Set success
40$:	SETIPL	#0			; Drop IPL
	RSB				; Leave, finished initialization

	.DISABLE	LSB

	LC=.
	.=<LC+15>&-16

MSCP_END:
	.END  
