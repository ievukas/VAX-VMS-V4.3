MODULE DBGDEFINE (IDENT = 'V04-000') =
BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY:	DEBUG
!
! ABSTRACT:
!
!	This module contains all the routines that are used to implement
!	the DEFINE command. This includes the parse and execute networks,
!	and also the utility routines for managing the DEFINE symbol table.
!
! ENVIRONMENT:	VAX/VMS
!
! AUTHOR:	Richard Title, CREATION DATE:	Mar 1982
!
! VERSION:	V3.1-001
!
! MODIFIED BY:
!		V. Holt, May 1982
!
! REVISION HISTORY:
! 3B.0	14-May-82	VJH	Added call to DBG$FLUSHBUF to replace
!				initialization of local buffer pointer.
! 3B.1   3-Jun-82	VJH	Removed all references to DBG$FAO_PUT and
!				DBG$OUT_PUT, as these routines are now obsolete.
!				Replaced them with calls to DBG$PRINT and 
!				DBG$NEWLINE, respectively.
! 3B.2   8-JUN-82	VJH	Removed reference to local output buffer in
!				routine dump_entries.
! 4.0	13-SEP-83	BAB	Implemented full functionality for the
!				DEFINE/KEY and the DELETE/KEY or UNDEFINE/KEY.
!

!
! TABLE OF CONTENTS:
!

FORWARD ROUTINE
    	DBG$CANCEL_LOC_VAL: NOVALUE,	! Cancel saved values of dot and backslash
    	DBG$DEF_SYM_ADD,		! Adds a symbol to the DEFINE symbol table
    	DBG$DEF_SYM_FIND,		! Finds a symbols in the DEFINE symbol table
    	DBG$DEF_SYM_REMOVE,		! Removes a symbol from the DEFINE symbol table
    	DBG$DEF_SYM_REMOVE_ALL,		! Remove all define symbols from a list
    	DBG$DUMP_DEFINE,		! Dump the define symbol table
	DBG$NPARSE_DEFINE,		! Parse network for DEFINE
	DBG$NPARSE_DEF_KEY,		! Parse network for DEFINE/KEY
    	DBG$NPARSE_DELETE,		! Parse network for DELETE
    	DBG$NPARSE_UNDEFINE,		! Parse network for UNDEFINE
	DBG$NPARSE_DEL_KEY,		! Parse network for DELETE/KEY and/or UNDEFINE/KEY
    	DBG$NEXECUTE_DEFINE,		! Execution network for DEFINE
    	DBG$NEXECUTE_DELETE,		! Execution network for DELETE
    	DBG$NEXECUTE_UNDEFINE,		! Execution network for UNDEFINE
    	DBG$NREAD_NAME,			! Parses a name
    	DBG$SAVE_LOC: NOVALUE,		! Save .
    	DBG$SAVE_VAL: NOVALUE,		! Save \
    	DBG$WILDCARD_NAME_MATCH,	! Matches a pair of names with wildcards
	DBG$READ_KEY_INFO,		! Returns a pointer with key info string.
    	DUMP_ENTRY,			! Dump a define entry
    	FREE_ENTRY,			! Frees up space occupied by a define entry
    	NAME_MATCH;			! Matches a pair of names

!
! REQUIRE FILES:
!
REQUIRE 'SRC$:DBGPROLOG.REQ';
LIBRARY 'LIB$:DBGGEN.L32';

!
! EQUATED SYMBOLS:
!
LITERAL
    	define_local  = 0,		! Code to indicate the symbol is local
    	define_global = 1,		! Code to indicate the symbol is global
    	undefine_all  = 1,		! Code for UNDEFINE/ALL
    	undefine_all_global = 2,	! Code for UNDEFINE/ALL/GLOBAL
    	undefine_key = 3;		! Code for UNDEFINE/KEY

!
! EXTERNAL REFERENCES:
!
EXTERNAL LITERAL
    	DBG$K_MAX_PR_NESTING,		     ! Maximum level of procedure nesting
	SMG$_NOMOREKEYS,		     ! No more keys in table
	SMG$_KEYNOTDEF;			     ! Key is not defined

EXTERNAL
    	DBG$GB_KEYPAD_INPUT: BYTE,
    	DBG$GB_DEFINE_PTR:REF VECTOR[,BYTE], ! Points to data structure for SET DEFINE
    	DBG$GB_RADIX: VECTOR[3, BYTE],	     ! Radix settings
    	DBG$GL_KEY_TABLE_ID,		     ! Used in DEFINE/KEY
    	DBG$GL_PARAM_COUNT: VECTOR[],	     ! Count of number of params
    	DBG$GL_PR_NEST_LEVEL,		     ! Nesting level of @ procedures
    	DBG$GL_SIGN_FLAG;		     ! Print '+' before signed variable

EXTERNAL ROUTINE
    	DBG$COPY_MEMORY,		! Copy a block of memory
    	DBG$GET_MEMORY,			! Allocate permanent memory
    	DBG$GET_TEMPMEM,		! Allocate permanent memory
    	DBG$PRIM_TO_VAL,		! Convert descriptors
	DBG$PRINT:  NOVALUE,		! Formatted ASCII output
    	DBG$PRINT_IDENTIFIER: NOVALUE,	! Print name of Primary
    	DBG$PRINT_VALUE: NOVALUE,	! Print value of Value Descriptor
    	DBG$POP_TEMPMEM: NOVALUE,	! Pop temporary memory pool
    	DBG$PUSH_TEMPMEM,		! Push temporary memory pool
	DBG$FLUSHBUF:  NOVALUE,		! Initialize new print line
	DBG$NEWLINE:  NOVALUE,		! Output print buffer to terminal
    	DBG$NACCEPT_STRING,		! Accepts a quoted string
    	DBG$NCOPY_DESC,			! Copies a descriptor
    	DBG$NEXTLOC,			! Logical successor
    	DBG$NFREE_DESC,			! Free up space occupied by a descriptor
    	DBG$NGET_SYMID,			! Obtain symid list 
	DBG$NMAKE_ARG_VECT,		! Constructs a message vector
    	DBG$NMATCH,			! Matches a token
    	DBG$NNEXT_WORD,			! Gets the next word of input
    	DBG$NPARSE_ADDRESS,		! Parse an address expression
    	DBG$NPARSE_EXPRESSION,		! Parse a value expression
    	DBG$NSAVE_BREAK_BUFFER,		! Reads a buffer of DEBUG commands
	DBG$NSYNTAX_ERROR,		! Constructs a message vector for a syntax error
    	DBG$NTYPE_CONV,			! Type converter
    	DBG$PREVLOC,			! Logical predecessor
    	DBG$REL_MEMORY,			! Release memory
    	DBG$SET_DEFINE_LVL,		! Manipulates data structure for 
    					!    SET DEFINE command
    	DBG$STA_LOCK_SYMID: NOVALUE,	! Lock symid list
    	DBG$STA_UNLOCK_SYMID: NOVALUE,	! Unlock symid list
        STR$COMPARE_EQL,		! Compares two descriptors
    	SMG$ADD_KEY_DEF, 		! Execute the DEFINE/KEY command
    	SMG$DELETE_KEY_DEF,		! Processes DELETE/KEY
	SMG$LIST_KEY_DEFS,		! Returns key definitions from the table
	SMG$SET_DEFAULT_STATE;		! Returns the current default state

!
! OWN STORAGE
!
OWN
        CURLOC_VMSDESC: BLOCK[12, BYTE];! Area to store a copy of the vms descriptor
    					!     representing dot (current location)

GLOBAL
	DBG$GL_CURLOC_VMSDESC: INITIAL(0),	! Pointer to a copy of the vms descriptor
    						!     representing dot (current location)
    	DBG$GL_GLOBAL_DEFINE_PTR,		! Pointer to head of global define list
    	DBG$GL_LOCAL_DEFINE_PTR;		! Pointer to head of local define list

!
! MACROS
!
! The following macro is just an abbreviation for some error-reporting
! code that occurs repeatedly
!
MACRO report_error =
    BEGIN
    .message_vect = (
    	IF dbg$nmatch (.input_desc, dbg$cs_cr, 1)
    	THEN
    	    dbg$nmake_arg_vect (dbg$_needmore)
    	ELSE
    	    dbg$nsyntax_error (dbg$nnext_word (.input_desc)));
    RETURN sts$k_severe;
    END %;

!+
! Definition for the list of state names in the IF_STATE qualifier of the
! Define/key command.
!-

FIELD
    DBG$STATE_NAME_FIELDS =
        SET

        DBG$L_STATE_NAME_PTR		= [0, 0, 32, 0],	! Pointer to name descriptor
	DBG$L_STATE_NAME_LINK		= [1, 0, 32, 0]		! Pointer to next state name

	TES;

LITERAL
	DBG$K_STATE_NAME_SIZE		= 2;			! length in long words

MACRO
	DBG$STATE_NAME_NODE = BLOCK [DBG$K_STATE_NAME_SIZE] FIELD (DBG$STATE_NAME_FIELDS) %;



GLOBAL ROUTINE dbg$cancel_loc_val: NOVALUE =
!++
! Routine Description
!
!	Cancels the stored values for dot and backslash. This routine is
!	called during the processing of the SET LANGUAGE command.
!
! Inputs
!
!	None.
!
! Outputs
!
!	The DEFINE symbol table is modified.
!--
    BEGIN
    LOCAL
    	dummy; 		! Output parameter - value not used here

    ! Remove definition for backslash.
    !
    dbg$def_sym_remove (UPLIT BYTE (%ASCIC '%CURVAL'),
    			TRUE,
    			dummy,
    			dummy);

    ! Remove the definition for dot.
    !
    dbg$def_sym_remove (UPLIT BYTE (%ASCIC '%CURLOC'),
    			TRUE,
    			dummy,
    			dummy);

    ! Zero out the pointer to the saved vms descriptor for dot.
    !
    dbg$gl_curloc_vmsdesc = 0;    
    END;

GLOBAL ROUTINE dbg$def_sym_add (symbol_name, symbol_kind,   symbol_value,
    			   	global_flag, replaced_flag, message_vect) =
!++
! Functional Description
!
!	This routine adds a new symbol to DEBUG's internal DEFINE symbol
!	table. It is given the symbol's name, value, kind, and an 
!	indication of whether the symbol is to be local or global.
!	It sets the output parameter REPLACED_FLAG to TRUE if the 
!	symbol replaced an existing occurence. 
!
! Routine Inputs
!
!	SYMBOL_NAME -	Points to a counted string with the symbol name.
!	SYMBOL_KIND -	One of the legal kinds DEFINE_ADDRESS, DEFINE_VALUE,
!    			    and so on, (defined in DBGLIB.REQ)
!	SYMBOL_VALUE - 	Points to the "value" of the symbol. This may be
!			    an address expression descriptor, a value
!			    descriptor, and so on, depending on kind.
!	GLOBAL_FLAG -	TRUE if the symbol is global, FALSE otherwise.
!	REPLACED_FLAG -	This is the address of a flag to be set to TRUE if 
!			    adding the symbol replaces an existing occurence
!			    of the name.
!	MESSAGE_VECT -	The address of an error message vector.
!
! Routine Outputs
!
!	REPLACED_FLAG -	This is the address of a flag to be set to TRUE if 
!			    adding the symbol replaces an existing occurence
!			    of the name.
!
! Routine Value
!
!	An unsigned longword completion code:
!
!	STS$K_SUCCESS -	Success. Symbol addition was successful.
!	STS$K_SEVERE -	Failure. Message argument vector is constructed
!			     with an indication of the error.
!
!--
    BEGIN

    LOCAL
    	head_ptr: REF define$header,	! Points to the head of the
    					!     appropriate DEFINE list
    	first_entry,			! Flag saying whether this is the
    					!     first entry on the list
    	name: REF VECTOR [,BYTE],	! Points to a counted string with
    					!     the DEFINE symbol name
    	prev_sym_ptr: REF define$entry, ! Points to a DEFINE entry
    	sym_ptr: REF define$entry;	! 

    !++
    ! First we search for a pre-existing occurence of the symbol.
    !--

    ! Set up pointer to the appropriate define list.
    !
    IF .global_flag
    THEN
    	head_ptr = .dbg$gl_global_define_ptr
    ELSE
    	head_ptr = .dbg$gl_local_define_ptr;

    ! Walk through the list searching for the given name.
    !
    sym_ptr = .head_ptr [def$a_define_list];

    ! Set the flag saying whether there are any entries on the list.
    !
    IF .sym_ptr EQL 0
    THEN
    	first_entry = TRUE
    ELSE
    	first_entry = FALSE;

    prev_sym_ptr = 0;
    WHILE .sym_ptr NEQ 0 DO
    	BEGIN
    	name = .sym_ptr [def$a_name];
    	IF name_match (.symbol_name, .name)
    	THEN
    	    BEGIN
    	    
    	    !++
    	    ! If we find a match then replace the existing entry
    	    ! with the new definition.
    	    !--

    	    ! First free up the space taken up by the old entry.
    	    !
    	    IF NOT free_entry (.sym_ptr, .message_vect)
    	    THEN
    		RETURN sts$k_severe;

    	    ! Fill in the fields with the new values.
    	    !
    	    sym_ptr [def$b_kind] = .symbol_kind;
    	    sym_ptr [def$a_name] = .symbol_name;
    	    sym_ptr [def$a_value] = .symbol_value;
    	    .replaced_flag = TRUE;
    	    
            ! Return success
    	    !
    	    RETURN sts$k_success;
    	    END;

    	! Set up for the next time around the loop.
    	!
    	prev_sym_ptr = .sym_ptr;
    	sym_ptr = .sym_ptr [def$a_entry_next_link];
        END; ! While loop

    ! If we get here then we have failed to find a define entry
    ! with that name. Allocate a new entry and link it in.
    !
    sym_ptr = dbg$get_memory (dbg$k_define_entry_size_w); 

    ! If we are adding the first one, then it is linked to the
    ! header; else it is linked to the last symbol on the list.
    !
    IF .first_entry
    THEN
    	head_ptr [def$a_define_list] = .sym_ptr
    ELSE
    	prev_sym_ptr [def$a_entry_next_link] = .sym_ptr;

    ! Fill in the fields of the newly allocated entry.
    !
    sym_ptr [def$a_entry_next_link] = 0;
    sym_ptr [def$a_entry_prev_link] = .prev_sym_ptr;
    sym_ptr [def$b_kind] = .symbol_kind;
    sym_ptr [def$a_name] = .symbol_name;
    sym_ptr [def$a_value] = .symbol_value;

    ! Set the output parameter and return success.
    !
    .replaced_flag = FALSE;
    RETURN sts$k_success;

    END; ! dbg$def_sym_add            

GLOBAL ROUTINE dbg$def_sym_find (symbol_name, returned_kind,
    				 returned_value, global_flag,
    				 message_vect) =
!++
! Functional Description
!
!	This routine looks up a name in the DEFINE symbol table. It
!	returns the kind of symbol and the value of the symbol.
!
! Routine Inputs
!
!	SYMBOL_NAME -	Points to a counted string with the name to
!			be looked up.
!	RETURNED_KIND -	The address of a longword, in which a code for
!			the kind of symbol will be deposited.
!	RETURNED_VALUE- The address of a longword, in which a pointer
!			to the symbol value will be deposited.
!	GLOBAL_FLAG -	The address of a longword. The longword will
!			be filled in with FALSE if the symbol was found
!			in the local define list, and to TRUE if the
!			symbol was found only in the global DEFINE list.
!
! Routine Outputs
!
!	RETURNED_KIND -	See above
!	RETURNED_VALUE-	See above
!	GLOBAL_FLAG -	See above
!
! Return Value
!
!	TRUE -	A matching symbol was found.
!	FALSE - A matching symbol was not found.
!--
    BEGIN
    MAP
    	symbol_name: REF VECTOR[,BYTE];

    LOCAL
    	desc_copy,			! Points to a copy of a primary descriptor
    	head_ptr : REF define$header,	! Points to a header block in the
    					!    DEFINE symbol table.
    	name : REF VECTOR [,BYTE],	! Points to a symbol name.
    	nextloc_flag,			! TRUE for %NEXTLOC
    	prevloc_flag,			! TRUE for %PREVLOC
    	sym_ptr : REF define$entry;	! Points to an entry in the
    					!    DEFINE symbol table.

    ! Set up nextloc_flag and prevloc_flag.
    !
    prevloc_flag = FALSE;
    nextloc_flag = FALSE;
    IF .symbol_name[0] EQL 8
    THEN
    	BEGIN
    	IF ch$eql (8, symbol_name[1], 
    		   8, UPLIT BYTE (%ASCII '%PREVLOC'))
    	THEN
    	    BEGIN
    	    prevloc_flag = TRUE;
    	
    	    ! Dummy up the symbol to look like %CURLOC.
    	    ! 
    	    symbol_name = UPLIT BYTE (%ASCIC '%CURLOC');
    	    END;
    	IF ch$eql (8, symbol_name[1], 
    		   8, UPLIT BYTE (%ASCII '%NEXTLOC'))
    	THEN
    	    BEGIN
    	    nextloc_flag = TRUE;

    	    ! Dummy up the symbol to look like %CURLOC.
    	    ! 
    	    symbol_name = UPLIT BYTE (%ASCIC '%CURLOC');
    	    END;
    	END;    	  

    ! First search the local define lists, then the global define list.
    ! When I EQL 1 we are searching local, and when I EQL 2 we are 
    ! searching the global list.
    !
    INCR i FROM 1 TO 2 DO
    	BEGIN

    	! Set up HEAD_PTR to point to the appropriate list,
    	! and SYM_PTR to point to the first entry in this list.
    	!
    	IF .i EQL 1 
    	THEN
    	    head_ptr = .dbg$gl_local_define_ptr
    	ELSE
    	    head_ptr = .dbg$gl_global_define_ptr;

    	! Loop through all the define lists, from the current (innermost)
    	! scope outward.
    	!
    	WHILE .head_ptr NEQ 0 DO
    	    BEGIN
    	    sym_ptr = .head_ptr [def$a_define_list];

    	    ! Walk the list looking for a name match.
    	    !
    	    WHILE .sym_ptr NEQ 0 DO
    	        BEGIN
    	        name = .sym_ptr [def$a_name];
    	        IF name_match (.symbol_name, .name)
    	        THEN
    		    BEGIN

    		    ! We have found a match. Fill in the output
    		    ! parameters.
    	 	    !
    		    .returned_kind = .sym_ptr [def$b_kind];
    		    .returned_value = .sym_ptr [def$a_value];
    		    IF .i EQL 1 
    		    THEN
    		        .global_flag = FALSE
    		    ELSE
    		        .global_flag = TRUE;

    		    ! Check for special symbols %PREVLOC and %NEXTLOC.
    		    ! These are handled specially - we call the new 
    		    ! routines DBG$PREVLOC or DBG$NEXTLOC to obtain the
    		    ! logical successor or predecessor.
    		    !
    		    IF .prevloc_flag
    		    THEN
    			BEGIN

    			! Construct a copy of the descriptor into
    			! temporary memory so that DBG$PREVLOC
    			! can play with it. Then call DBG$PREVLOC to
    			! give us the logical predecessor.
    			!
    			dbg$ncopy_desc (.sym_ptr [def$a_value],
    				    	desc_copy,
    				    	.message_vect,
    					FALSE);
    			.returned_value = dbg$prevloc (.desc_copy);
    			END;
    		    IF .nextloc_flag
    		    THEN 
    			BEGIN

    			! Construct a copy of the descriptor into
    			! temporary memory so that DBG$NEXTLOC
    			! can play with it. Then call DBG$NEXTLOC to
    			! give us the logical predecessor.
    			!
    			dbg$ncopy_desc (.sym_ptr [def$a_value],
    					desc_copy,
    					.message_vect,
    					FALSE);
    			.returned_value = dbg$nextloc (.desc_copy);
    			END;

    		    RETURN TRUE;
    		    END;

    	        ! Set up for next time around loop.
    	        !
    	        sym_ptr = .sym_ptr [def$a_entry_next_link];
    	        END; ! inner while loop

    	    ! Set up for the next time around the loop.
    	    !
    	    head_ptr = .head_ptr [def$a_next_link];
    	    END; ! Outer while loop

    	END; ! Incr loop

    ! If we reach this point we have failed to find a 
    ! name match. Return false.
    ! Note - if we were searching for %CURLOC or %CURVAL and didn't find
    ! it that means that dot or backslash were not defined. In this case,
    ! signal an appropriate error message.
    !
    IF .symbol_name[0] EQL 7
    THEN
    	BEGIN
    	IF CH$EQL (7, symbol_name[1], 7, UPLIT BYTE (%ASCII '%CURLOC'))
    	THEN
    	    SIGNAL (dbg$_nocurloc);
    	IF CH$EQL (7, symbol_name[1], 7, UPLIT BYTE (%ASCII '%CURVAL'))
        THEN
    	    SIGNAL (dbg$_nolastval);
    	END;
    RETURN FALSE;

    END; ! dbg$def_sym_find

GLOBAL ROUTINE dbg$def_sym_remove (symbol_name, global_flag, 
    				   found_flag, message_vect) =
!++
! Functional Description
!
!	This routine removes a symbol from DEBUG's internal DEFINE symbol
!	table. It is given the symbol's name and an 
!	indication of whether the symbol is local or global.
!	It sets FOUND_FLAG to true if it found an occurence of the symbol
!	to be removed; false otherwise.
!
! Routine Inputs
!
!	SYMBOL_NAME -	Points to a counted string with the symbol name.
!	GLOBAL_FLAG -	TRUE if the symbol is global, FALSE otherwise.
!	FOUND_FLAG -	This is the address of a flag to be set to TRUE if 
!			    an occurence of the symbol was found and removed.
!	MESSAGE_VECT -	The address of an error message vector.
!
! Routine Outputs
!
!	FOUND_FLAG -	This is the address of a flag to be set to TRUE if 
!			    an occurence of the symbol was found and removed.
!
! Routine Value
!
!	An unsigned longword completion code:
!
!	STS$K_SUCCESS -	Success. Symbol addition was successful.
!	STS$K_SEVERE -	Failure. Message argument vector is constructed
!			     with an indication of the error.
!
!--
    BEGIN

    LOCAL
    	head_ptr: REF define$header,	! Points to the head of the
    					!     appropriate DEFINE list
    	name: REF VECTOR [,BYTE],	! Points to a counted string with
    					!     the DEFINE symbol name
    	next_sym_ptr: REF define$entry,	! Points to a DEFINE entry
    	prev_sym_ptr: REF define$entry, ! Points to a DEFINE entry
    	sym_ptr: REF define$entry;	! Points to a DEFINE entry

    ! Initialize found_flag.
    !
    .found_flag = FALSE;

    !++
    ! Search for an occurence of the symbol.
    !--

    ! Set up pointer to the appropriate define list.
    !
    IF .global_flag
    THEN
    	head_ptr = .dbg$gl_global_define_ptr
    ELSE
    	head_ptr = .dbg$gl_local_define_ptr;

    ! Loop through the define lists.
    !
    WHILE .head_ptr NEQ 0 DO
    	BEGIN

        ! Walk through the list searching for the given name.
        !
        prev_sym_ptr = 0;
        sym_ptr = .head_ptr [def$a_define_list];
        WHILE .sym_ptr NEQ 0 DO
    	    BEGIN
    	    next_sym_ptr = .sym_ptr [def$a_entry_next_link];
    	    name = .sym_ptr [def$a_name];
     	    IF name_match (.symbol_name, .name)
    	    THEN
    	        BEGIN
    	    
    	        !++
    	        ! If we find a match then remove the entry.
    	        !--

    	        ! First free up the space taken up by the entry.
    	        !
    	        IF NOT free_entry (.sym_ptr, .message_vect)
    	        THEN
    		    RETURN sts$k_severe;

    	        ! Unlink the entry.
    	        !
    	        IF .prev_sym_ptr EQL 0
    	        THEN

    		    ! First entry
       		    !
    		    head_ptr [def$a_define_list] = .next_sym_ptr
    	
    	        ELSE
 
       		    ! Not first entry.
    		    !
    	            prev_sym_ptr [def$a_entry_next_link] = .next_sym_ptr;

    	        IF .next_sym_ptr NEQ 0
    	        THEN    		

    		    ! Not last entry
    		    !
    	            next_sym_ptr [def$a_entry_prev_link] = .prev_sym_ptr;

    	        ! Free up the space.
    	        !
    	        dbg$rel_memory (.sym_ptr);
    		sym_ptr = .prev_sym_ptr;

                ! Set found_flag to true.
    	        !
    	        .found_flag = TRUE;
    	        END;

    	    ! Set up for the next time around the loop.
    	    !
    	    prev_sym_ptr = .sym_ptr;
    	    sym_ptr = .next_sym_ptr;
            END; ! inner While loop

        ! Set up for next time around outer loop.
    	!
    	head_ptr = .head_ptr [def$a_next_link];
    	END; ! outer WHILE loop

    ! We are all done. Return success.
    !
    RETURN sts$k_success;
    END; ! dbg$def_sym_remove            

GLOBAL ROUTINE dbg$def_sym_remove_all (global_flag, message_vect) =
!++
! Functional Description
!
!	This routine removes a all symbols from an internal DEFINE symbol
!	table. global_flag indicates whether to remove local or global 
!	symbols.
!
! Routine Inputs
!
!	GLOBAL_FLAG -	TRUE for global, FALSE otherwise.
!	MESSAGE_VECT -	The address of an error message vector.
!
! Routine Value
!
!	An unsigned longword completion code:
!
!	STS$K_SUCCESS -	Success. Symbol addition was successful.
!	STS$K_SEVERE -	Failure. Message argument vector is constructed
!			     with an indication of the error.
!
!--
    BEGIN

    LOCAL
    	head_ptr: REF define$header,	! Points to the head of the
    					!     appropriate DEFINE list
    	next_sym_ptr: REF define$entry,	! Points to a DEFINE entry
    	sym_ptr: REF define$entry;	! Points to a DEFINE entry


    ! Set up pointer to the appropriate define list.
    !
    IF .global_flag
    THEN
    	head_ptr = .dbg$gl_global_define_ptr
    ELSE
    	head_ptr = .dbg$gl_local_define_ptr;

    ! Loop through the define lists.
    !
    WHILE .head_ptr NEQ 0 DO
    	BEGIN

        ! Walk through the list searching for the given name.
        !
        sym_ptr = .head_ptr [def$a_define_list];
        WHILE .sym_ptr NEQ 0 DO
    	    BEGIN
    	    next_sym_ptr = .sym_ptr [def$a_entry_next_link];

    	    ! First free up the space taken up by the entry.
    	    !
    	    IF NOT free_entry (.sym_ptr, .message_vect)
    	    THEN
    		RETURN sts$k_severe;

    	    ! Free up the space.
    	    !
    	    dbg$rel_memory (.sym_ptr);

    	    ! Set up for the next time around the loop.
    	    !
    	    sym_ptr = .next_sym_ptr;
            END; ! inner While loop

    	! Zero out the pointer to the define list.
    	!
    	head_ptr [def$a_define_list] = 0;

        ! Set up for next time around outer loop.
    	!
    	head_ptr = .head_ptr [def$a_next_link];
    	END; ! outer WHILE loop

    ! We are all done. Return success.
    !
    RETURN sts$k_success;
    END; ! dbg$def_sym_remove_all            

GLOBAL ROUTINE dbg$def_pr_entry (message_vect) =
!++
! Routine Description
!
!	This routine is called at entry to a command procedure. It allocates
!	a new define list for the procedure.
!
! Inputs
!
!	message_vect	-	Error message vector.
!
! Outputs
!
!	The local define list is modified.
!	A status code is returned. This is one of:
!	sts$k_success - success.
!	sts$k_severe - failure.
!--
    BEGIN

    MAP 
    	dbg$gl_local_define_ptr: REF define$header;

    LOCAL
    	head_ptr: REF define$header;

    ! Save away a pointer to the current top-level local define header.
    !
    head_ptr = .dbg$gl_local_define_ptr;

    ! Allocate space for a new header block.
    !
    dbg$gl_local_define_ptr = dbg$get_memory (dbg$k_define_header_size_w);

    ! Fill in the fields of the newly-allocated header block.
    !
    dbg$gl_local_define_ptr [def$a_next_link] = .head_ptr;
    dbg$gl_local_define_ptr [def$a_prev_link] = 0;
    dbg$gl_local_define_ptr [def$a_define_list] = 0;

    ! Fill in the back pointer for the second entry.
    !
    head_ptr [def$a_prev_link] = .dbg$gl_local_define_ptr;

    ! Increment the count of the number of levels of procedure nesting.
    ! Check for exceeding the maximum nesting level. If so, we will print
    ! an error and abort the processing of "@". Even after aborting
    ! the "@" processing, DBG$DEF_PR_EXIT will get called to un-do
    ! the work we have done in this routine to this point.
    !
    dbg$gl_pr_nest_level = .dbg$gl_pr_nest_level + 1;
    IF .dbg$gl_pr_nest_level GTR dbg$k_max_pr_nesting
    THEN
    	BEGIN
    	.message_vect = dbg$nmake_arg_vect (dbg$_provrflow);
    	RETURN sts$k_severe;
    	END;
    dbg$gl_param_count [.dbg$gl_pr_nest_level] = 0;

    RETURN sts$k_success;
    END; ! dbg$def_pr_entry

GLOBAL ROUTINE dbg$def_pr_exit (message_vect) =
!++
! Routine Description
!
!	This routine is called at the exit from a command procedure.
!	It removes the define list for that procedure.
!
! Inputs
!
!	message_vect 	-	An error message vector
!
! Outputs
!
!	The local define list is modified.
!	A status code is returned:
!	sts$k_success - success
!	sts$k_severe - failure
!--
    BEGIN
    
    MAP
    	dbg$gl_local_define_ptr: REF define$header;

    LOCAL
    	head_ptr: REF define$header, 	! Saved pointer to head of list.
    	next_sym_ptr: REF define$entry, ! Points to a define entry
    	sym_ptr: REF define$entry;	! Points to a define entry

    ! Decrement the count of levels of procedure nesting.
    !
    dbg$gl_pr_nest_level = .dbg$gl_pr_nest_level - 1;
    IF .dbg$gl_pr_nest_level LSS 0
    THEN
    	BEGIN
    	$DBG_ERROR('DBGDEFINE\DBG$DEF_PR_EXIT');
    	END;

    ! Save away a pointer to the top header block.
    !
    head_ptr = .dbg$gl_local_define_ptr;

    ! Cut out the first entry.
    !
    dbg$gl_local_define_ptr = .dbg$gl_local_define_ptr [def$a_next_link];

    !
    ! Free up the space being occupied by the list.
    !

    ! Obtain a pointer to the define list.
    !
    sym_ptr = .head_ptr [def$a_define_list];

    ! Free up space occupied by the header block.
    !
    dbg$rel_memory (.head_ptr);

    ! Walk through the list freeing up each entry.
    !
    WHILE .sym_ptr NEQ 0 DO
    	BEGIN

    	! Obtain a pointer to the next list entry.
    	!
    	next_sym_ptr = .sym_ptr [def$a_entry_next_link];

    	! Free up the space taken up by the name and value.
    	!
    	IF NOT free_entry (.sym_ptr, .message_vect)
    	THEN
    	    RETURN sts$k_severe;

    	! Free up the space occupied by the entry.
    	!
    	dbg$rel_memory (.sym_ptr);

    	! Set up for next time around.
    	!
    	sym_ptr = .next_sym_ptr;
    	END;     

    RETURN sts$k_success;
    END; ! dbg$def_pr_exit

GLOBAL ROUTINE dbg$dump_define (string, addr_flag, global_flag, type_flag, 
    				found_status, message_vect) =
!++
! Routine Description
!
! 	This routine dumps the DEFINE symbol table. It is called from
!	the SHOW SYM/DEFINED command.
!
! Inputs
!
!	string		- A string representing the defined symbol
!			  whose definition the users wants to see.
!			  Asterisk may be used as a wild card character.
!	addr_flag	- Says to print the thing that the defined symbol
!			  is bound to.
!	global_flag	- A flag set to TRUE if the user is requesting
!			  globally defined symbols; false otherwise.
!	type_flag	- says to print the kind of defined symbol.
!	found_status	- This is used in the case of SHOW SYMBOL xxx,
!			  where we have previously called the 
!			  DBG$STA_SHOSYMBOL routine. This flag is set to:
!			  TRUE: DBG$STA_SHOSYMBOL has already matched some
!			        symbols, so don't signal an error if this
!			 	routine does not match anything.
!			  FALSE: DBG$STA_SHOSYMBOL has not matched any symbols.
!	message_vect 	- An error message vector.
!
! Implicit Inputs
!
!	The DEFINE symbol table.
!
! Output
!
!	The contents of the DEFINE symbol table are displayed at the terminal.
!	A condition code is returned, which is one of:
!	STS$K_SUCCESS 	- Routine was successful
!	STS$K_SEVERE 	- Routine was not successful. Error message vector 
!			  constructed.
!
! Side Effects
!
!	None.
!--
    BEGIN
    LOCAL
    	found_flag,			! True if we find any matches
    	head_ptr: REF define$header,	! A pointer to a define list header
    	name: REF VECTOR[,BYTE],	! Points to a symbol name
    	sym_ptr: REF define$entry;	! A pointer to a define list entry
    
    ! Initialize found_flag
    !
    found_flag = FALSE;

    ! Set up a pointer to either the head of the global define table or
    ! the head of the local define table.
    !
    IF .global_flag
    THEN
    	head_ptr = .dbg$gl_global_define_ptr
    ELSE
    	head_ptr = .dbg$gl_local_define_ptr;

    ! Loop through the define tables.
    !
    WHILE .head_ptr NEQ 0 DO
    	BEGIN

    	! Loop through the symbols in the define table.
    	!
    	sym_ptr = .head_ptr [def$a_define_list];
    	WHILE .sym_ptr NEQ 0 DO
    	    BEGIN

    	    ! Pick up the name and determine if it is a match.
    	    !
    	    name = .sym_ptr [def$a_name];
    	    IF dbg$wildcard_name_match (.string, .name)
    	    THEN
    		BEGIN
    		LABEL
    		    search_block;	
    		LOCAL
    		    print_flag,
    		    temp_head_ptr: REF define$header,
    		    temp_name,
    		    temp_sym_ptr: REF define$entry;

    		found_flag = TRUE;
    		
search_block:	BEGIN
    		
    		! Check whether we have already printed the name.
    		!
    		IF .global_flag 
    		THEN
    		    temp_head_ptr = .dbg$gl_global_define_ptr
    		ELSE
    		    temp_head_ptr = .dbg$gl_local_define_ptr;
    		WHILE .temp_head_ptr NEQ 0 DO
    		    BEGIN
    		    temp_sym_ptr = .temp_head_ptr [def$a_define_list];
    		    WHILE .temp_sym_ptr NEQ 0 DO
    			BEGIN
    			IF .temp_sym_ptr EQL .sym_ptr
    			THEN
    			    BEGIN
    			    print_flag = TRUE;
    			    LEAVE search_block;
    			    END;
    			temp_name = .temp_sym_ptr[def$a_name];
    			IF name_match (.temp_name, .name)
    			THEN
    			    BEGIN
    			    print_flag = FALSE;
    			    LEAVE search_block;
    			    END;
    			temp_sym_ptr = .temp_sym_ptr [def$a_entry_next_link];
    			END;
    		    temp_head_ptr = .temp_head_ptr [def$a_next_link];
    		    END;
    		END; ! search_block
    		
    		IF .print_flag
    		THEN
    		    dump_entry (.sym_ptr, .addr_flag, .type_flag, .message_vect);
    		END;
    
    	    ! Set up for next time around loop.
    	    !
    	    sym_ptr = .sym_ptr [def$a_entry_next_link];
    	    END; ! inner while loop

    	! Set up for next time around loop.
    	!
    	head_ptr = .head_ptr [def$a_next_link];
    	END; ! outer while loop

    ! If we did not find any matches, signal an informational to that effect.
    !
    IF (NOT .found_status) AND (NOT .found_flag)
    THEN
    	SIGNAL (dbg$_symnotfnd, 1, .string);

    RETURN sts$k_success;
    END; ! of DBG$DUMP_DEFINE

GLOBAL ROUTINE dbg$nparse_define (input_desc, verb_node, message_vect) =
!++
! Functional Description
!
!	This is the top-level parse network for the DEFINE command.
!
! Routine Inputs
!
!	input_desc -	A string descriptor for the remaining input.
!	verb_node -	A pointer to the verb node for DEFINE, which
!			    will be the top-level node in the command
!			    execution tree.
!	message_vect -	An error message vector
!
! Routine Outputs
!
!	A command execution tree is constructed starting at the verb
! 	node:
!
!	 ------      ------      ------
!	| VERB | -> | NOUN | -> | NOUN | -> ... 
!	 ------      ------      ------
!
!	The DBG$B_VERB_COMPOSITE field contains an indication of the
!	"kind" of DEFINE.
!	In each noun node, all three fields contain information
!	about the symbol being defined:
!	DBG$L_NOUN_VALUE -	Points to a counted string with the name of
!				the symbol (the left-hand-side of the 
!				definition).
!	DBG$L_NOUN_VALUE2 -	Points to some kind of descriptor or
!				counted string with the right-hand-side
!				of the definition.
!	DBG$L_ADJECTIVE_PTR -	Contains an indication of whether the
!				definition was local (=) or global (==).
!	The string descriptor is updated to point past the
!	input that has been parsed. A completion code is returned:
!	STS$K_SUCCESS - The input was successfully parsed.
!	STS$K_SEVERE -  There were errors during the parse. An error
!			message vector is constructed and returned
!			in message_vect.
!--
    BEGIN

    MAP
    	input_desc : REF BLOCK [,BYTE],	! The string descriptor for the
    					!    remaining input.
    	verb_node : REF dbg$verb_node;	! The verb node with the DEFINE verb.

    BIND
    	dbg$cs_address = 	UPLIT BYTE (7, 'ADDRESS'),
    	dbg$cs_command = 	UPLIT BYTE (7, 'COMMAND'),
    	dbg$cs_key = 		UPLIT BYTE (3, 'KEY'),
    	dbg$cs_local =		UPLIT BYTE (5, 'LOCAL'),
    	dbg$cs_procedure = 	UPLIT BYTE (9, 'PROCEDURE'),
    	dbg$cs_string = 	UPLIT BYTE (6, 'STRING'),
    	dbg$cs_value =		UPLIT BYTE (5, 'VALUE'),
    	dbg$cs_comma = 		UPLIT BYTE (1, dbg$k_comma),
    	dbg$cs_cr =		UPLIT BYTE (1, dbg$k_car_return),
    	dbg$cs_dblquote = 	UPLIT BYTE (1, dbg$k_dblquote),
    	dbg$cs_equal = 		UPLIT BYTE (1, dbg$k_equal),
    	dbg$cs_left_paren =	UPLIT BYTE (1, dbg$k_left_parenthesis),
    	dbg$cs_slash = 		UPLIT BYTE (1, dbg$k_slash);


    LOCAL
    	addr_exp_desc: REF dbg$aed,		! Points to an address 
    						!    expression descriptor
    	define_kind,				! Holds "kind" of symbol
    	first_time,				! True during parsing of first
    						!     element of comma list.
    	global_flag,				! Will be true on ==
    	new_noun_node   : REF dbg$noun_node,	! Another pointer to a noun node
    	noun_node       : REF dbg$noun_node,	! Pointer to a noun node
    	ptr: REF VECTOR[,BYTE],			! Points into input string
    	status,
    	stg_desc: dbg$stg_desc,			! String descriptor
    	symid_list;				! Pointer to symid list

    ! Special case check for DEFINE/KEY. And save the input descriptor.
    !

    ch$move(8, .input_desc, stg_desc);
    IF dbg$nmatch (stg_desc, dbg$cs_slash, 1)
    THEN
        IF dbg$nmatch (stg_desc, dbg$cs_key, 1)
        THEN
	    BEGIN
	    CH$MOVE(8, stg_desc, .input_desc);
	    status = dbg$nparse_def_key(.input_desc, .verb_node, .message_vect);
	    IF NOT .status
            THEN
		RETURN .status;
            RETURN sts$k_success;
	    END;


    ! Initialize global flag. The default is /GLOBAL, so the flag is
    ! initially TRUE.
    !
    global_flag = TRUE;

    ! First look for the qualifier on the DEFINE command.
    ! 
    WHILE dbg$nmatch (.input_desc, dbg$cs_slash, 1) DO
    	BEGIN
    	SELECTONE TRUE OF 
    	    SET

    	    [dbg$nmatch (.input_desc, dbg$cs_address, 1)] :
    		BEGIN
    		dbg$set_define_lvl (override_define);
    		dbg$gb_define_ptr [define_only] = define_address;
    		END;

    	    [dbg$nmatch (.input_desc, dbg$cs_command, 1)] :
    		BEGIN
    		dbg$set_define_lvl (override_define);
    		dbg$gb_define_ptr [define_only] = define_command;
    		END;


    	    ! /GLOBAL is not allowed since it is a no-op.
    	    !
    	    ! [dbg$nmatch (.input_desc, dbg$cs_global, 1)] :
    	    ! 	  global_flag = TRUE;

    	    [dbg$nmatch (.input_desc, dbg$cs_local, 1)]:
    		global_flag = FALSE;

    	    ! [dbg$nmatch (.input_desc, dbg$cs_procedure, 1)] :
    	    !	dbg$gb_define_ptr [define_only] = define_procedure;

    	    ! [dbg$nmatch (.input_desc, dbg$cs_string, 1)] :
    	    !	dbg$gb_define_ptr [define_only] = define_string;

    	    [dbg$nmatch (.input_desc, dbg$cs_value, 1)] :
    		BEGIN
    		dbg$set_define_lvl (override_define);
    		dbg$gb_define_ptr [define_only] = define_value;
    		END;

    	    [OTHERWISE] :
    		report_error;

    	    TES;
    	END;

    define_kind = .dbg$gb_define_ptr [define_only];


    ! Now that we have decided what kind of DEFINE this is,
    ! put that piece of information in the verb node.
    !
    verb_node [dbg$b_verb_composite] = .define_kind;


    ! Now that we have collected the qualifier, we loop through
    ! the list of definitions (e.g, 
    ! DEFINE A=B,C=D,E=F
    ! Most of the time there will only be one in the list, but
    ! we are prepared to handle a list here.)
    !
    first_time = TRUE;
    WHILE TRUE DO
    	BEGIN

    	! Check for end-of-line.
    	! It is an error at this point.
    	!
    	IF dbg$nmatch (.input_desc, dbg$cs_cr, 1)
    	THEN
    	    BEGIN
    	    .message_vect = dbg$nmake_arg_vect (dbg$_needmore);
    	    RETURN sts$k_severe;
    	    END;

    	! Allocate a noun node to hold the definition
    	!
    	new_noun_node = dbg$get_tempmem (dbg$k_noun_node_size);

    	! We must link in the noun node. If this is the first definition
    	! in the list, it is attached to the verb node; otherwise it
    	! is attached to the previous noun node.
    	!
    	IF .first_time
    	THEN
    	    BEGIN
    	    first_time = FALSE;
    	    verb_node [dbg$l_verb_object_ptr] = .new_noun_node;
    	    noun_node = .new_noun_node;
    	    noun_node [dbg$l_noun_link] = 0
    	    END

    	ELSE
    	    BEGIN
    	    noun_node [dbg$l_noun_link] = .new_noun_node;
    	    noun_node = .new_noun_node;
    	    noun_node [dbg$l_noun_link] = 0
    	    END;


    	! Now we read the name that is being defined and store a 
    	! pointer to the counted string in the value field of
    	! the noun node.
    	!
    	IF NOT dbg$nread_name (.input_desc, 
    		noun_node [dbg$l_noun_value],
    		.message_vect)
    	THEN
    	    RETURN sts$k_severe;

    	! Look for =.
    	!
    	IF NOT dbg$nmatch (.input_desc, dbg$cs_equal, 1)
    	THEN
    	    report_error;

    	! We use the "adjective" field to keep an indication
    	! of whether the user specified /GLOBAL.
    	!
    	IF .global_flag
    	THEN
    	    noun_node [dbg$l_adjective_ptr] = define_global

    	ELSE
    	    noun_node [dbg$l_adjective_ptr] = define_local;


    	! Now we collect the right-hand-side of the definition.
    	! What we are looking for depends on the qualifier that
    	! was specified.
    	!
     	CASE .define_kind FROM define_lowest TO define_highest OF
    	    SET

    	    [define_address] :
    		BEGIN
    		LOCAL
    		    status,
    		    temp_addr_exp_desc;		! Filled in by AEI

    		! Call the address expression interpreter.
    		!
    		status = dbg$nparse_address (.input_desc, temp_addr_exp_desc,
    			.dbg$gb_radix[dbg$b_radix_input],
    			token$k_term_comma, .message_vect);
    		IF .status NEQ sts$k_success AND .status NEQ sts$k_warning
    		THEN
    		    RETURN sts$k_severe;
    		        		
    		! Copy the descriptor.
    		!
    		dbg$nget_symid (.temp_addr_exp_desc, symid_list, .message_vect);
	    	dbg$ncopy_desc (.temp_addr_exp_desc, addr_exp_desc, .message_vect);
    		dbg$sta_lock_symid (.symid_list);

    		! Fill in the "value2" field of the noun node with
    		! a pointer to the address expression descriptor.
    		!
    		noun_node [dbg$l_noun_value2] = .addr_exp_desc;
    		END;

    	    [define_command, define_string] :
    		BEGIN

    		! In these cases we want to pick up a quoted string.
    		! First we pick up the leading quote.
    		!
    		IF NOT dbg$nmatch (.input_desc, dbg$cs_dblquote, 1)
    		THEN
    		    report_error;

    		! Now call a routine to accept the string.
    		!
    		IF NOT dbg$naccept_string (.input_desc,
    			noun_node [dbg$l_noun_value2],
    			dbg$k_dblquote,
    			TRUE,
    			.message_vect,
                        TRUE)
    		THEN
    		    RETURN sts$k_severe;

    		END;

    	    [define_procedure] :
    		BEGIN

    		! For this case we want to pick up a sequence of DEBUG
    		! commands inside of parenthesis.
    		! First we eat the left paren.
    		!
    		IF NOT dbg$nmatch (.input_desc, dbg$cs_left_paren, 1)
    		THEN
    		    report_error;

    		! Call the routine which picks up a sequence of 
    		! DEBUG commands.
    		!
    		IF NOT dbg$nsave_break_buffer (.input_desc, 
    			noun_node [dbg$l_noun_value2],
    			.message_vect)
    		THEN
    		    RETURN sts$k_severe;

    		END;

    	    [define_value] :
    		BEGIN
    		LOCAL
    		    status,
    		    temp_desc: REF dbg$dhead; ! Variable to hold a 
    					      ! pointer to a value descriptor

    		! For this case we just call the expression interpreter
    		! to parse a language expression.
    		!
    		status = dbg$nparse_expression (.input_desc, 
    			.dbg$gb_radix[dbg$b_radix_input],
    			temp_desc, token$k_term_comma, .message_vect);
    		IF .status NEQ sts$k_success AND .status NEQ sts$k_warning
    		THEN
    		    RETURN sts$k_severe;

    		! If the descriptor is volatile, then we cannot save it.
    		! First try to make it into an ordinary value descriptor.
    		! If that attempt fails, then report an error message saying
    		! that we cannot save the value (this should only happen
    		! for very large values, e.g., long strings).
    		!
    		IF .temp_desc [dbg$b_dhead_type] EQL dbg$k_v_value_desc
    		THEN
    		    dbg$prim_to_val(.temp_desc, dbg$k_value_desc, temp_desc);
    		IF .temp_desc [dbg$b_dhead_type] EQL dbg$k_v_value_desc
    		THEN
    		    BEGIN
    		    .message_vect = dbg$nmake_arg_vect (dbg$_unasavval,
    			1, .noun_node[dbg$l_noun_value]);
    		    RETURN sts$k_severe;
    		    END;

    		! Copy the descriptor into permanent memory.
    		!
    		IF dbg$nget_symid(
    				.temp_desc, 
    				symid_list,
    				.message_vect)
    		THEN
    		    IF dbg$ncopy_desc( 
    				    .temp_desc,
    		    		    noun_node [dbg$l_noun_value2], 
    				    .message_vect)
    		    THEN
    		        dbg$sta_lock_symid (.symid_list)
    		    ELSE
    			RETURN sts$k_severe
    		ELSE
    		    RETURN sts$k_severe;	    		    

    		END;

    	    [INRANGE,OUTRANGE] :
    		BEGIN
    		report_error;
    		END;

    	    TES;


    	! Check for exhausted input. If so, exit the loop.
    	!
    	IF .input_desc [dsc$w_length] EQL 0
    	THEN
    	    EXITLOOP;

    	! Now check for comma, indicating there are further elements in
       	! the list
    	!
    	IF NOT dbg$nmatch (.input_desc, dbg$cs_comma, 1)
    	THEN 
    	    EXITLOOP;

    	END;				! End of WHILE loop

    RETURN sts$k_success;

    END;

ROUTINE dbg$nparse_def_key (input_desc, verb_node, message_vect) =
!++
! Functional Description
!
!	This is the parse network for the DEFINE/KEY command.
!
! Routine Inputs
!
!	input_desc	-	A pointer to a string descriptor for the 
!				    remaining input.
!	a_verb_node	-	The address of a pointer to the verb node
!				    for DEFINE, which will be the top-level
!				    node in the command execution tree.
!	message_vect	-	A pointer to an error message vector.
!
! Routine Outputs
!
!	A command execution tree is constructed starting at the verb
! 	node:
!
!	 ------      ------ 
!	| VERB | -> | NOUN |
!	 ------      ------ 
!           |			The DBG$B_VERB_COMPOSITE field contains a
!	 -------		value for the DEFINE/KEY command.
!	|ADVERB0|
!	 -------		The noun node has the following information:
!	    |
!	 -------		DBG$L_NOUN_VALUE - A pointer to a descriptor
!	|ADVERB1|			that contains the key-name.
!	 -------		DBG$L_ADJECTIVE_PTR - A pointer to a
!	    |				descriptor that contains the
!           :				equilalence string for the key.
!	    :
!	 -------		The adverb nodes appear as follows:
!	|ADVERB5|
!	 -------		DBG$B_ADVERB_LITERAL - Qualifier Code.
!				DBG$L_ADVERB_VALUE - Value or location of data
!					for this qualifier.
!				DBG$L_ADVERB_LINK - Link to next Adverb-node.
!
!	For Adverb1, which contains the qualifier information for the IF_STATE
!	qualifier, there exists a list of state names with DBG$L_ADVERB_VALUE
!	pointing at a state_name_node.  This node is defined above, but you 
!	should note that the node consists of 2 fields. 1) A pointer to a
!	descriptor of the state name and 2) A link field to the next node in
!	the list.
!
!
!	The string descriptor is updated to point past the
!	input that has been parsed. A completion code is returned:
!
!	STS$K_SUCCESS - The input was successfully parsed.
!	STS$K_SEVERE -  There were errors during the parse. An error
!			message vector is constructed and returned
!			in message_vect.
!--
    BEGIN

    MAP
	input_desc		: REF BLOCK [,BYTE],	! String descriptor
        verb_node		: REF dbg$verb_node;

    BIND
	dbg$cs_echo		= UPLIT BYTE (4, 'ECHO'),
	dbg$cs_if_state		= UPLIT BYTE (8, 'IF_STATE'),
	dbg$cs_lock_state	= UPLIT BYTE (10, 'LOCK_STATE'),
	dbg$cs_log		= UPLIT BYTE (3, 'LOG'),
	dbg$cs_set_state	= UPLIT BYTE (9, 'SET_STATE'),
	dbg$cs_terminate	= UPLIT BYTE (9, 'TERMINATE'),
	dbg$cs_NO		= UPLIT BYTE ('NO'),
	dbg$cs_left_paren	= UPLIT BYTE (1, dbg$k_left_parenthesis),
	dbg$cs_right_paren	= UPLIT BYTE (1, dbg$k_right_parenthesis),
	dbg$cs_comma		= UPLIT BYTE (1, dbg$k_comma),
	dbg$cs_cr		= UPLIT BYTE (1, dbg$k_car_return),
	dbg$cs_dblquote		= UPLIT BYTE (1, dbg$k_dblquote),
	dbg$cs_equal		= UPLIT BYTE (1, dbg$k_equal),
	dbg$cs_slash		= UPLIT BYTE (1, dbg$k_slash);

    LITERAL
	dbg$k_lowest_qualifier	= 0,	! These literals correspond to the
	dbg$k_echo		= 0,	! adverb-nodes in the structure
	dbg$k_if_state		= 1,	! that gets built.
	dbg$k_lock_state	= 2,
	dbg$k_log		= 3,
	dbg$k_set_state		= 4,
	dbg$k_terminate		= 5,
	dbg$k_highest_qualifier = 5;

    LOCAL
	define_kind		: INITIAL(0),		! Value of DEFINE/KEY qualifier
    	noun_node       	: REF dbg$noun_node,	! Pointer to a noun node
    	new_noun_node   	: REF dbg$noun_node,	! Another pointer to a noun node
	adverb_node     	: REF dbg$adverb_node,	! Pointer to a noun node
	new_adverb_node 	: REF dbg$adverb_node,	! Another pointer to a adverb node
	state_name_node		: REF dbg$state_name_node,	! Pointer to a state-name node
	new_state_name_node	: REF dbg$state_name_node,	! Another pointer to a state-name node
    	ptr			: REF VECTOR[,BYTE],	! Points into input string
    	status,
        temp_key_desc		: REF dbg$stg_desc,	! String desc. for DEFINE/KEY symbols
	d_key_no,					! Flag for NOxxx qualifier
        define_key_value;				! Value for the qualifier


    ! Check whether we are on a system that allows keypad input.
    !
    IF NOT .dbg$gb_keypad_input
    THEN
        SIGNAL(dbg$_nokeydef);

    ! Fill in the fact that this is a DEFINE/KEY command in the verb node.
    ! And clear the noun link value.
    !
    verb_node [dbg$b_verb_composite] = define_key;
    verb_node [dbg$l_verb_object_ptr] = 0;

    ! Build adverb list with defaults.
    !

    new_adverb_node = dbg$get_tempmem(dbg$k_adverb_node_size);	! Get first node

    verb_node [dbg$l_verb_adverb_ptr] = .new_adverb_node;
    adverb_node = .new_adverb_node;

    adverb_node [dbg$b_adverb_literal] = dbg$k_lowest_qualifier;	! Initialize first node
    adverb_node [dbg$l_adverb_value]   = 0;
    adverb_node [dbg$l_adverb_link] = 0;

    define_kind = dbg$k_lowest_qualifier + 1;
    WHILE .define_kind LEQ dbg$k_highest_qualifier DO		! Build rest of adverb list
	BEGIN
        new_adverb_node = dbg$get_tempmem(dbg$k_adverb_node_size);
        adverb_node [dbg$l_adverb_link] = .new_adverb_node;
        adverb_node = .new_adverb_node;

        adverb_node [dbg$b_adverb_literal] = .define_kind;
        IF .define_kind EQL dbg$k_if_state
        THEN
            BEGIN
            ! Initialize the if-state node to point to a state name node that
            ! points to a descriptor that has the current state-name.
            !
            temp_key_desc = dbg$get_tempmem(2);
            temp_key_desc [dsc$w_length]  = 0;
            temp_key_desc [dsc$b_dtype]   = dsc$k_dtype_t;
            temp_key_desc [dsc$b_class]   = dsc$k_class_d;
            temp_key_desc [dsc$a_pointer] = 0;

            state_name_node = dbg$get_tempmem(dbg$k_state_name_size);

            ! Get the current state-name
            !
            smg$set_default_state(dbg$gl_key_table_id, 0, .temp_key_desc);
            state_name_node [dbg$l_state_name_ptr] = .temp_key_desc;
            state_name_node [dbg$l_state_name_link] = 0;

            adverb_node [dbg$l_adverb_value] = .state_name_node;
            END
        ELSE
            ! Let zero be the default for all the other adverb nodes
            !
            adverb_node [dbg$l_adverb_value] = 0;

        define_kind = .define_kind + 1;
        END;
    adverb_node [dbg$l_adverb_link] = 0;

    WHILE (NOT dbg$nmatch(.input_desc, dbg$cs_cr, 1)) AND
          (.input_desc [dsc$w_length] GTR 0) DO

        BEGIN
        IF dbg$nmatch(.input_desc, dbg$cs_slash, 1)
        THEN
            BEGIN

            ! Find out what kind of qualifier it is
            !
            ! Initialize value

            define_key_value = 0;
            d_key_NO = FALSE;

            ! Check for a NO qualifier 

            WHILE CH$EQL(1, UPLIT(' '), 1, CH$PTR(.input_desc [dsc$a_pointer])) DO
                BEGIN
                input_desc [dsc$a_pointer] = CH$PLUS(.input_desc [dsc$a_pointer], 1);
                input_desc [dsc$w_length]  = .input_desc [dsc$w_length] - 1;
                END;

            IF CH$EQL(2, CH$PTR(dbg$cs_NO), 2, CH$PTR(.input_desc [dsc$a_pointer]))
            THEN
                BEGIN
                d_key_NO = TRUE;
                input_desc [dsc$a_pointer] = CH$PLUS(.input_desc [dsc$a_pointer], 2);
                input_desc [dsc$w_length]  = .input_desc [dsc$w_length] - 2;
                END;

            ! Set Define_key with qualifier code, and get value of define_key_value.

            SELECTONE TRUE  OF
                SET

                [dbg$nmatch(.input_desc, dbg$cs_echo, 1)] :
                    BEGIN
                    define_key_value = 0;
                    define_kind = dbg$k_echo;
                    IF .d_key_NO THEN define_key_value = 1;
                    END;

                [dbg$nmatch(.input_desc, dbg$cs_if_state, 1)] :
                    BEGIN
		    define_key_value = 0;
                    define_kind = dbg$k_if_state;
                    IF NOT .d_key_NO
		    THEN
                        BEGIN
                        temp_key_desc = dbg$get_tempmem(2);
                        temp_key_desc[dsc$w_length]  = 0;
                        temp_key_desc[dsc$b_dtype]   = dsc$k_dtype_t;
                        temp_key_desc[dsc$b_class]   = dsc$k_class_d;
                        temp_key_desc[dsc$a_pointer] = 0;

			! Look for =
			!

			IF NOT dbg$nmatch (.input_desc, dbg$cs_equal, 1)
			THEN
                            report_error;

			! Look for a left paren
			!

			IF dbg$nmatch (.input_desc, dbg$cs_left_paren, 1)
			THEN
                            BEGIN

                            ! Pick up the first state name
			    !
                            status = dbg$read_key_info (.input_desc,
                                                        .temp_key_desc,
                                                        .message_vect);
			    IF NOT .status
			    THEN
			        RETURN sts$k_severe;

                            new_state_name_node = dbg$get_tempmem(dbg$k_state_name_size);
                            state_name_node = .new_state_name_node;
                            state_name_node [dbg$l_state_name_ptr] = .temp_key_desc;
                            state_name_node [dbg$l_state_name_link] = 0;
                            define_key_value = .state_name_node;

                            WHILE dbg$nmatch (.input_desc, dbg$cs_comma, 1) DO
                                BEGIN
	                        temp_key_desc = dbg$get_tempmem(2);
        	                temp_key_desc[dsc$w_length]  = 0;
                	        temp_key_desc[dsc$b_dtype]   = dsc$k_dtype_t;
                        	temp_key_desc[dsc$b_class]   = dsc$k_class_d;
                      		temp_key_desc[dsc$a_pointer] = 0;

                                ! Pick up the next state name
                                !
                                status = dbg$read_key_info (.input_desc,
                                                            .temp_key_desc,
                                                            .message_vect);
			        IF NOT .status
			        THEN
			            RETURN sts$k_severe;

                                new_state_name_node = dbg$get_tempmem(dbg$k_state_name_size);
                                state_name_node [dbg$l_state_name_link] = .new_state_name_node;
                                state_name_node = .new_state_name_node;
                                state_name_node [dbg$l_state_name_ptr] = .temp_key_desc;
                                state_name_node [dbg$l_state_name_link] = 0;

                                END;

			    ! Eat right paren
			    !

			    IF NOT dbg$nmatch (.input_desc, dbg$cs_right_paren, 1)
			    THEN
                                report_error;

                            END

                        ELSE
                            BEGIN

                            ! Pick up the only state name
		            !

                            status = dbg$read_key_info (.input_desc,
                                                        .temp_key_desc,
                                                        .message_vect);
			    IF NOT .status
			    THEN
			        RETURN sts$k_severe;

                            new_state_name_node = dbg$get_tempmem(dbg$k_state_name_size);
                            state_name_node = .new_state_name_node;
                            state_name_node [dbg$l_state_name_ptr] = .temp_key_desc;
                            state_name_node [dbg$l_state_name_link] = 0;
                            define_key_value = .state_name_node;

                            END;

                        END;
                    END;

                [dbg$nmatch(.input_desc, dbg$cs_lock_state, 3)] :
                    BEGIN
                    define_key_value = 1;
                    define_kind = dbg$k_lock_state;
                    IF .d_key_NO THEN define_key_value = 0;
                    END;

                [dbg$nmatch(.input_desc, dbg$cs_log, 3)] :
                    BEGIN
                    define_key_value = 0;
                    define_kind = dbg$k_log;
                    IF .d_key_NO THEN define_key_value = 1;
                    END;

                [dbg$nmatch(.input_desc, dbg$cs_set_state, 1)] :
                    BEGIN
                    define_kind = dbg$k_set_state;
		    define_key_value = 0;
                    IF NOT .d_key_NO
		    THEN
                        BEGIN
                        temp_key_desc = dbg$get_tempmem(2);
                        temp_key_desc[dsc$w_length]  = 0;
                        temp_key_desc[dsc$b_dtype]   = dsc$k_dtype_t;
                        temp_key_desc[dsc$b_class]   = dsc$k_class_d;
                        temp_key_desc[dsc$a_pointer] = 0;

			! Look for =
			!

			IF NOT dbg$nmatch (.input_desc, dbg$cs_equal, 1)
			THEN
                            report_error;

			! Pick up the state name
			!

                        status = dbg$read_key_info (.input_desc,
                                                    .temp_key_desc,
                                                    .message_vect);
			IF NOT .status
			THEN
			    RETURN sts$k_severe;

                        define_key_value = .temp_key_desc;
                        END;
                    END;

                [dbg$nmatch(.input_desc, dbg$cs_terminate, 1)] :
                    BEGIN
                    define_key_value = 1;
                    define_kind = dbg$k_terminate;
                    IF .d_key_NO THEN define_key_value = 0;

                    ! Since we may have to reset the default from 1 to 0
                    ! It is best to do this here and allow it to skip
                    ! over the similar code down below.
                    ! ( This is hacked up because the /NOECHO and /NOTERM are
                    !   mutually exlusive qualifiers. ) This bothers me too.
                    !
                    adverb_node = .verb_node [dbg$l_verb_adverb_ptr];
                    WHILE .adverb_node [dbg$b_adverb_literal] NEQ dbg$k_terminate DO
                        adverb_node = .adverb_node [dbg$l_adverb_link];
                    adverb_node [dbg$l_adverb_value] = .define_key_value;
                    define_key_value = 0;	! This is to jump over the code below.
                    END;

                [OTHERWISE] :
                    report_error;
                TES;

            ! Process the qualifier if it changes the default

            IF .define_key_value NEQ 0
            THEN
                BEGIN
                adverb_node = .verb_node [dbg$l_verb_adverb_ptr];
                WHILE (.adverb_node [dbg$b_adverb_literal] NEQ .define_kind) DO
                    adverb_node = .adverb_node [dbg$l_adverb_link];
                adverb_node [dbg$l_adverb_value] = .define_key_value;

                ! If the qualifier is /NOECHO then the default of the terminate
                ! qualifier changes to /TERMINATE
                IF .adverb_node [dbg$b_adverb_literal] EQL dbg$k_echo
                THEN
                    BEGIN
                    WHILE .adverb_node [dbg$b_adverb_literal] NEQ dbg$k_terminate DO
                        adverb_node = .adverb_node [dbg$l_adverb_link];
                    adverb_node [dbg$l_adverb_value] = 1;
                    END;
                END;

            END	! End of picking up qualifier after slash

	ELSE
            BEGIN

            ! Process key name or equivalence string

            IF .verb_node [dbg$l_verb_object_ptr] EQL 0
            THEN
		BEGIN

		! Get key name
                !

	        temp_key_desc = dbg$get_tempmem(2);
                temp_key_desc[dsc$w_length]  = 0;
                temp_key_desc[dsc$b_dtype]   = dsc$k_dtype_t;
                temp_key_desc[dsc$b_class]   = dsc$k_class_d;
                temp_key_desc[dsc$a_pointer] = 0;
	        status = dbg$read_key_info (.input_desc,
                                            .temp_key_desc,
                                            .message_vect);
	        IF NOT .status
	        THEN
		    RETURN sts$k_severe;

	        ! Make noun node for key-name and equivalence string
	        !

	        new_noun_node = dbg$get_tempmem(dbg$k_noun_node_size);

	        verb_node [dbg$l_verb_object_ptr] = .new_noun_node;
	        noun_node = .new_noun_node;
	        noun_node [dbg$l_noun_value] = .temp_key_desc;
                noun_node [dbg$l_adjective_ptr] = 0;
                noun_node [dbg$l_noun_link] = 0;
		END
    
            ! If we got the key-name ok, go after the equivalence string
	    ! Provided there is still something left to get.
	    !

            ELSE
                IF .noun_node [dbg$l_adjective_ptr] EQL 0
                THEN
    		    BEGIN
		    temp_key_desc = dbg$get_tempmem(2);
                    temp_key_desc[dsc$w_length]  = 0;
                    temp_key_desc[dsc$b_dtype]   = dsc$k_dtype_t;
                    temp_key_desc[dsc$b_class]   = dsc$k_class_d;
                    temp_key_desc[dsc$a_pointer] = 0;

		    ! Pick up leading quote
		    !

		    IF NOT dbg$nmatch (.input_desc, dbg$cs_dblquote, 1)
		    THEN
                        BEGIN
                        status = dbg$read_key_info (.input_desc,
                                                    .temp_key_desc,
                                                    .message_vect);
                        IF NOT .status
                        THEN
                            report_error;
                        END
                    ELSE
                        BEGIN
                        ! Pick up the quoted string
		        !

                        status = dbg$naccept_string (.input_desc,
                                                     temp_key_desc [dsc$a_pointer],
                                                     dbg$k_dblquote,
                                                     FALSE,
                                                     .message_vect,
                                                     FALSE);

                        IF NOT .status
		        THEN
		            RETURN sts$k_severe;

                        ! Grab the length of the string and move the pointer.
                        !
                        temp_key_desc [dsc$w_length] = CH$RCHAR_A(temp_key_desc [dsc$a_pointer]);

                        END;

		    noun_node [dbg$l_adjective_ptr] = .temp_key_desc;

		    END
                ELSE
                    report_error;
	    END;

	END;	! End While

    ! Check to see if key-name and the equivalence string have been entered.
    ! If not, return a need more message and error status.
    !

    IF .verb_node [dbg$l_verb_object_ptr] EQL 0
    THEN
        BEGIN
        .message_vect = dbg$nmake_arg_vect(dbg$_needmore);
        RETURN sts$k_severe;
        END;
    IF .noun_node [dbg$l_adjective_ptr] EQL 0
    THEN
        BEGIN
        .message_vect = dbg$nmake_arg_vect(dbg$_needmore);
        RETURN sts$k_severe;
        END;

    RETURN sts$k_success;
    END;


GLOBAL ROUTINE dbg$nparse_delete (input_desc, verb_node, message_vect) =
!++
! Functional Description
!
!	This is the top-level parse network for the DELETE command.
!	DELETE is the same as UNDEFINE so we just call that parse
!	network.
!
! Inputs
!	input_desc	- String descriptor for the remaining input.
!	verb_node	- Top-level node in the command tree.
!	message_vect	- error message vector.
!
! Routine Outputs
!
!	A command execution tree is constructed starting at the verb
! 	node:
!
!	 ------      ------      ------
!	| VERB | -> | NOUN | -> | NOUN | -> ... 
!	 ------      ------      ------
!
!	In each noun node, all the following fields contain information
!	about the symbol being undefined:
!	DBG$L_NOUN_VALUE -	Points to a counted string with the name of
!				the symbol (the left-hand-side of the 
!				definition).
!	DBG$L_ADJECTIVE_PTR -	Contains an indication of whether the
!				definition was local (=) or global (==).
!	The string descriptor is updated to point past the
!	input that has been parsed. A completion code is returned:
!	STS$K_SUCCESS - The input was successfully parsed.
!	STS$K_SEVERE -  There were errors during the parse. An error
!			message vector is constructed and returned
!			in message_vect.
!--
    BEGIN
    RETURN dbg$nparse_undefine(.input_desc, .verb_node, .message_vect);
    END;

GLOBAL ROUTINE dbg$nparse_undefine (input_desc, verb_node, message_vect) =
!++
! Functional Description
!
!	This is the top-level parse network for the UNDEFINE command.
!
! Routine Inputs
!
!	input_desc -	A string descriptor for the remaining input.
!	verb_node -	A pointer to the verb node for UNDEFINE, which
!			    will be the top-level node in the command
!			    execution tree.
!	message_vect -	An error message vector
!
! Routine Outputs
!
!	A command execution tree is constructed starting at the verb
! 	node:
!
!	 ------      ------      ------
!	| VERB | -> | NOUN | -> | NOUN | -> ... 
!	 ------      ------      ------
!
!	In each noun node, all the following fields contain information
!	about the symbol being undefined:
!	DBG$L_NOUN_VALUE -	Points to a counted string with the name of
!				the symbol (the left-hand-side of the 
!				definition).
!	DBG$L_ADJECTIVE_PTR -	Contains an indication of whether the
!				definition was local (=) or global (==).
!	The string descriptor is updated to point past the
!	input that has been parsed. A completion code is returned:
!	STS$K_SUCCESS - The input was successfully parsed.
!	STS$K_SEVERE -  There were errors during the parse. An error
!			message vector is constructed and returned
!			in message_vect.
!--
    BEGIN

    MAP
    	input_desc : REF BLOCK [,BYTE],	! The string descriptor for the
    					!    remaining input.
    	verb_node : REF dbg$verb_node;	! The verb node with the UNDEFINE verb.

    BIND
    	dbg$cs_all	= UPLIT BYTE (3, 'ALL'),
    	dbg$cs_global	= UPLIT BYTE (6, 'GLOBAL'),
    	dbg$cs_key 	= UPLIT BYTE (3, 'KEY'),
    	dbg$cs_local	= UPLIT BYTE (5, 'LOCAL'),
    	dbg$cs_comma	= UPLIT BYTE (1, dbg$k_comma),
    	dbg$cs_cr	= UPLIT BYTE (1, dbg$k_car_return),
    	dbg$cs_slash	= UPLIT BYTE (1, dbg$k_slash);

    LOCAL
    	all_flag,			    ! Flag for UNDEFINE/ALL
    	first_time,			    ! Flag for first time around the main loop
    	global_flag,			    ! Flag for UNDEFINE/GLOBAL
    	new_noun_node: REF dbg$noun_node,   ! Pointer to a noun node
    	noun_node: REF dbg$noun_node,	    ! Pointer to a noun node
    	saved_input_desc: dbg$stg_desc;	    ! Copy of input desc


    ! Check for UNDEFINE/KEY.
    !

    ch$move(8, .input_desc, saved_input_desc);
    IF dbg$nmatch (saved_input_desc, dbg$cs_slash, 1)
    THEN
    	IF dbg$nmatch (saved_input_desc, dbg$cs_key, 1)
    	THEN
    	    BEGIN
    	    LOCAL
    		status;

            ch$move(8, saved_input_desc, .input_desc);
    	    status = dbg$nparse_del_key(.input_desc, .verb_node, .message_vect);
    	    IF NOT .status
    	    THEN
    		RETURN sts$k_severe;
    	    RETURN sts$k_success;
    	    END;

    ! Initialize flags.
    !
    all_flag = FALSE;
    first_time = TRUE;
    global_flag = TRUE;
    verb_node [dbg$b_verb_composite] = 0;

    ! Look for qualifiers.
    !
    WHILE dbg$nmatch (.input_desc, dbg$cs_slash, 1) DO
    	SELECTONE TRUE OF
    	    SET

    	    [dbg$nmatch (.input_desc, dbg$cs_all, 1)]:
    		all_flag = TRUE;
    		
    	    ! /GLOBAL is not allowed since it is the default.
    	    !
    	    ! [dbg$nmatch (.input_desc, dbg$cs_global, 1)]:
    	    !	  global_flag = TRUE;

    	    [dbg$nmatch (.input_desc, dbg$cs_local, 1)]:
    		global_flag = FALSE;

    	    [OTHERWISE] :
    		report_error;

    	    TES;

    ! For UNDEFINE/ALL, we don't pick up a list of names
    !
    IF .all_flag
    THEN
    	BEGIN
    	IF .global_flag
    	THEN
    	    verb_node [dbg$b_verb_composite] = undefine_all_global
    	ELSE
    	    verb_node [dbg$b_verb_composite] = undefine_all;
    	RETURN sts$k_success;
    	END;

    ! Loop through the list of names to be undefined.
    !
    WHILE TRUE DO
    	BEGIN

    	! Check for end of line. It is an error at this point.
    	! 
    	IF dbg$nmatch (.input_desc, dbg$cs_cr, 1)
    	THEN
    	    BEGIN
    	    .message_vect = dbg$nmake_arg_vect (dbg$_needmore);
    	    RETURN sts$k_severe;
    	    END;

    	! Allocate a noun node to hold the name
    	!
    	new_noun_node = dbg$get_tempmem (dbg$k_noun_node_size);

    	! We must link in the noun node. If this is the first definition
    	! in the list, it is attached to the verb node; otherwise it
    	! is attached to the previous noun node.
    	!
    	IF .first_time
    	THEN
    	    BEGIN
    	    first_time = FALSE;
    	    verb_node [dbg$l_verb_object_ptr] = .new_noun_node;
    	    noun_node = .new_noun_node;
    	    noun_node [dbg$l_noun_link] = 0
    	    END

    	ELSE
    	    BEGIN
    	    noun_node [dbg$l_noun_link] = .new_noun_node;
    	    noun_node = .new_noun_node;
    	    noun_node [dbg$l_noun_link] = 0
    	    END;

    	! Now we read the name that is being undefined and store a 
    	! pointer to the counted string in the value field of
    	! the noun node.
    	!
    	IF NOT dbg$nread_name (.input_desc, 
    		noun_node [dbg$l_noun_value],
    		.message_vect)
    	THEN
    	    RETURN sts$k_severe;

    	! Check for the global qualifier on the name.
    	!
    	IF dbg$nmatch (.input_desc, dbg$cs_slash, 1)
    	THEN
    	    IF dbg$nmatch (.input_desc, dbg$cs_global, 1)
    	    THEN
    		 noun_node [dbg$l_adjective_ptr] = define_global
    	    ELSE
    		report_error;
    	IF .global_flag
        THEN
    	    noun_node [dbg$l_adjective_ptr] = define_global;

    	! Check for exhausted input. If so, exit the loop.
    	!
    	IF .input_desc [dsc$w_length] EQL 0
    	THEN
    	    EXITLOOP;

    	! Now check for comma, indicating more in the list.
    	!
    	IF NOT dbg$nmatch (.input_desc, dbg$cs_comma, 1)
    	THEN
    	    EXITLOOP;
    	END;

    ! We are all done. Return success.
    !
    RETURN sts$k_success;
    END;

ROUTINE dbg$nparse_del_key (input_desc, verb_node, message_vect) =
!++
! Functional Description
!
!	This is the parse network for the DELETE/KEY command.
!
! Routine Inputs
!
!	input_desc	-	A pointer to a string descriptor for the 
!				    remaining input.
!	verb_node	-	A pointer to the verb node for the DELETE
!				    command, which will be the top-level
!				    node in the command execution tree.
!	message_vect	-	A pointer to an error message vector.
!
! Routine Outputs
!
!	A command execution tree is constructed starting at the verb
! 	node:
!
!	 ------      ------ 
!	| VERB | -> | NOUN |
!	 ------      ------ 
!           |			The DBG$B_VERB_COMPOSITE field contains a
!	 -------		value for the DELETE/KEY command.
!	|ADVERB0|
!	 -------		The noun node has the following information:
!	    |
!	 -------		DBG$L_NOUN_VALUE - A pointer to a descriptor
!	|ADVERB1|			that contains the key-name.
!	 -------
!	    |
!	 -------
!	|ADVERB2|		The adverb nodes appear as follows:
!	 -------
!				DBG$L_ADVERB_VALUE - Value or location of data
!					for this qualifier.
!				DBG$L_ADVERB_LINK - Link to next Adverb-node.
!
!	The string descriptor is updated to point past the
!	input that has been parsed. A completion code is returned:
!
!	STS$K_SUCCESS - The input was successfully parsed.
!	STS$K_SEVERE -  There were errors during the parse. An error
!			message vector is constructed and returned
!			in message_vect.
!--
    BEGIN

    MAP
	input_desc		: REF BLOCK [,BYTE],	! String descriptor
        verb_node		: REF dbg$verb_node;

    BIND
	dbg$cs_all		= UPLIT BYTE (3, 'ALL'),
	dbg$cs_log		= UPLIT BYTE (3, 'LOG'),
	dbg$cs_state		= UPLIT BYTE (5, 'STATE'),
	dbg$cs_NO		= UPLIT BYTE ('NO'),
	dbg$cs_left_paren	= UPLIT BYTE (1, dbg$k_left_parenthesis),
	dbg$cs_right_paren	= UPLIT BYTE (1, dbg$k_right_parenthesis),
	dbg$cs_comma		= UPLIT BYTE (1, dbg$k_comma),
	dbg$cs_cr		= UPLIT BYTE (1, dbg$k_car_return),
	dbg$cs_equal		= UPLIT BYTE (1, dbg$k_equal),
	dbg$cs_slash		= UPLIT BYTE (1, dbg$k_slash);

    LITERAL
	dbg$k_lowest_qualifier	= 0,	! Corresponds to the adverb-nodes
	dbg$k_all		= 0,	! in the structure that is built.
	dbg$k_log		= 1,
	dbg$k_state		= 2,
	dbg$k_highest_qualifier = 2;

    LOCAL
        all_flag		: INITIAL(FALSE),	! True if /ALL
	define_kind		: INITIAL(0),		! Value of DELETE/KEY qualifier
    	noun_node       	: REF dbg$noun_node,	! Pointer to a noun node
    	new_noun_node   	: REF dbg$noun_node,	! Another pointer to a noun node
	adverb_node     	: REF dbg$adverb_node,	! Pointer to a noun node
	new_adverb_node 	: REF dbg$adverb_node,	! Another pointer to a adverb node
	state_name_node		: REF dbg$state_name_node,	! Pointer to a state-name node
	new_state_name_node	: REF dbg$state_name_node,	! Another pointer to a state-name node
    	ptr			: REF VECTOR[,BYTE],	! Points into input string
    	status,
        temp_key_desc		: REF dbg$stg_desc,	! String desc. for DELETE/KEY symbols
	d_key_no,					! Flag for NOxxx qualifier
        define_key_value;				! Value for the qualifier


    ! Check whether we are on a system that allows keypad input.
    !
    IF NOT .dbg$gb_keypad_input
    THEN
        SIGNAL(dbg$_nokeydef);

    ! Fill in the fact that this is a DELETE/KEY command in the verb node.
    ! And clear the noun link value.
    !
    verb_node [dbg$b_verb_composite] = undefine_key;
    verb_node [dbg$l_verb_object_ptr] = 0;

    ! Build adverb list with defaults.
    !

    new_adverb_node = dbg$get_tempmem(dbg$k_adverb_node_size);	! Get first node

    verb_node [dbg$l_verb_adverb_ptr] = .new_adverb_node;
    adverb_node = .new_adverb_node;

    adverb_node [dbg$b_adverb_literal] = dbg$k_lowest_qualifier;	! Initialize first node
    adverb_node [dbg$l_adverb_value]   = 0;
    adverb_node [dbg$l_adverb_link]    = 0;

    define_kind = dbg$k_lowest_qualifier + 1;
    WHILE .define_kind LEQ dbg$k_highest_qualifier DO		! Build rest of adverb list
	BEGIN
        new_adverb_node = dbg$get_tempmem(dbg$k_adverb_node_size);
        adverb_node [dbg$l_adverb_link] = .new_adverb_node;
        adverb_node = .new_adverb_node;

        adverb_node [dbg$b_adverb_literal] = .define_kind;
        IF .define_kind EQL dbg$k_state
        THEN
            BEGIN
            ! If the adverb-node is for the state name, let the adverb-node-value
            ! be a pointer to a state-name-node that points to a descriptor with
            ! the current state name.
            !
            temp_key_desc = dbg$get_tempmem(2);
            temp_key_desc [dsc$w_length]  = 0;
            temp_key_desc [dsc$b_dtype]   = dsc$k_dtype_t;
            temp_key_desc [dsc$b_class]   = dsc$k_class_d;
            temp_key_desc [dsc$a_pointer] = 0;

            ! This will return the current state name
            !
            smg$set_default_state(dbg$gl_key_table_id, 0, .temp_key_desc);

            state_name_node = dbg$get_tempmem(dbg$k_state_name_size);
            state_name_node [dbg$l_state_name_ptr] = .temp_key_desc;
            state_name_node [dbg$l_state_name_link] = 0;
            adverb_node [dbg$l_adverb_value] = .state_name_node;
            END
        ELSE
            ! In all other cases, let the default be zero.
            !
            adverb_node [dbg$l_adverb_value] = 0;

        define_kind = .define_kind + 1;
        END;
    adverb_node [dbg$l_adverb_link] = 0;

    WHILE (NOT dbg$nmatch(.input_desc, dbg$cs_cr, 1)) AND
          (.input_desc [dsc$w_length] GTR 0) DO

        BEGIN
        IF dbg$nmatch(.input_desc, dbg$cs_slash, 1)
        THEN
            BEGIN

            ! Find out what kind of qualifier it is
            !
            ! Initialize value

            define_key_value = 0;
            d_key_NO = FALSE;

            ! Check for a NO qualifier 

            WHILE CH$EQL(1, UPLIT(' '), 1, CH$PTR(.input_desc [dsc$a_pointer])) DO
                BEGIN
                input_desc [dsc$a_pointer] = CH$PLUS(.input_desc [dsc$a_pointer], 1);
                input_desc [dsc$w_length]  = .input_desc [dsc$w_length] - 1;
                END;

            IF CH$EQL(2, CH$PTR(dbg$cs_NO), 2, CH$PTR(.input_desc [dsc$a_pointer]))
            THEN
                BEGIN
                d_key_NO = TRUE;
                input_desc [dsc$a_pointer] = CH$PLUS(.input_desc [dsc$a_pointer], 2);
                input_desc [dsc$w_length]  = .input_desc [dsc$w_length] - 2;
                END;

            ! Set Define_key with qualifier code, and get value of define_key_value.

            SELECTONE TRUE  OF
                SET

                [dbg$nmatch(.input_desc, dbg$cs_all, 1)] :
                    BEGIN
                    define_kind = dbg$k_all;
                    define_key_value = 1;
                    all_flag = TRUE;
                    IF .d_key_NO
                    THEN
                        report_error;
                    IF .verb_node [dbg$l_verb_object_ptr] NEQ 0
                    THEN
                        SIGNAL(dbg$_conflict);
                    END;

                [dbg$nmatch(.input_desc, dbg$cs_state, 1)] :
                    BEGIN
		    define_key_value = 0;
                    define_kind = dbg$k_state;
                    IF NOT .d_key_NO
		    THEN
                        BEGIN
                        temp_key_desc = dbg$get_tempmem(2);
                        temp_key_desc[dsc$w_length]  = 0;
                        temp_key_desc[dsc$b_dtype]   = dsc$k_dtype_t;
                        temp_key_desc[dsc$b_class]   = dsc$k_class_d;
                        temp_key_desc[dsc$a_pointer] = 0;

			! Look for =
			!

			IF NOT dbg$nmatch (.input_desc, dbg$cs_equal, 1)
			THEN
                            report_error;

			! Look for a left paren
			!

			IF dbg$nmatch (.input_desc, dbg$cs_left_paren, 1)
			THEN
                            BEGIN

                            ! Pick up the first state name
			    !
                            status = dbg$read_key_info (.input_desc,
                                                        .temp_key_desc,
                                                        .message_vect);
			    IF NOT .status
			    THEN
			        RETURN sts$k_severe;

                            new_state_name_node = dbg$get_tempmem(dbg$k_state_name_size);
                            state_name_node = .new_state_name_node;
                            state_name_node [dbg$l_state_name_ptr] = .temp_key_desc;
                            state_name_node [dbg$l_state_name_link] = 0;
                            define_key_value = .state_name_node;

                            WHILE dbg$nmatch (.input_desc, dbg$cs_comma, 1) DO
                                BEGIN
	                        temp_key_desc = dbg$get_tempmem(2);
        	                temp_key_desc[dsc$w_length]  = 0;
                	        temp_key_desc[dsc$b_dtype]   = dsc$k_dtype_t;
                        	temp_key_desc[dsc$b_class]   = dsc$k_class_d;
                      		temp_key_desc[dsc$a_pointer] = 0;

                                ! Pick up the next state name
                                !
                                status = dbg$read_key_info (.input_desc,
                                                            .temp_key_desc,
                                                            .message_vect);
			        IF NOT .status
			        THEN
			            RETURN sts$k_severe;

                                new_state_name_node = dbg$get_tempmem(dbg$k_state_name_size);
                                state_name_node [dbg$l_state_name_link] = .new_state_name_node;
                                state_name_node = .new_state_name_node;
                                state_name_node [dbg$l_state_name_ptr] = .temp_key_desc;
                                state_name_node [dbg$l_state_name_link] = 0;

                                END;

			    ! Eat right paren
			    !

			    IF NOT dbg$nmatch (.input_desc, dbg$cs_right_paren, 1)
			    THEN
                                report_error;

                            END

                        ELSE
                            BEGIN

                            ! Pick up the only state name
		            !

                            status = dbg$read_key_info (.input_desc,
                                                        .temp_key_desc,
                                                        .message_vect);
			    IF NOT .status
			    THEN
			        RETURN sts$k_severe;

                            new_state_name_node = dbg$get_tempmem(dbg$k_state_name_size);
                            state_name_node = .new_state_name_node;
                            state_name_node [dbg$l_state_name_ptr] = .temp_key_desc;
                            state_name_node [dbg$l_state_name_link] = 0;
                            define_key_value = .state_name_node;

                            END;

                        END;
                    END;

                [dbg$nmatch(.input_desc, dbg$cs_log, 3)] :
                    BEGIN
                    define_key_value = 0;
                    define_kind = dbg$k_log;
                    IF .d_key_NO THEN define_key_value = 1;
                    END;

                [OTHERWISE] :
                    report_error;
                TES;

            ! Process the qualifier

            IF .define_key_value NEQ 0
            THEN
                BEGIN
                adverb_node = .verb_node [dbg$l_verb_adverb_ptr];
                WHILE (.adverb_node [dbg$b_adverb_literal] NEQ .define_kind) DO
                    adverb_node = .adverb_node [dbg$l_adverb_link];
                adverb_node [dbg$l_adverb_value] = .define_key_value;
                END;

            END	! End of qualifier look up

	ELSE

            ! Process key name 

            IF (.verb_node [dbg$l_verb_object_ptr] EQL 0) AND (NOT .all_flag)
            THEN
		BEGIN

		! Get key name
                !

	        temp_key_desc = dbg$get_tempmem(2);
                temp_key_desc[dsc$w_length]  = 0;
                temp_key_desc[dsc$b_dtype]   = dsc$k_dtype_t;
                temp_key_desc[dsc$b_class]   = dsc$k_class_d;
                temp_key_desc[dsc$a_pointer] = 0;
	        status = dbg$read_key_info (.input_desc,
                                            .temp_key_desc,
                                            .message_vect);
	        IF NOT .status
	        THEN
		    RETURN .status;

	        ! Make noun node for key-name string
	        !

	        new_noun_node = dbg$get_tempmem(dbg$k_noun_node_size);

	        verb_node [dbg$l_verb_object_ptr] = .new_noun_node;
	        noun_node = .new_noun_node;
	        noun_node [dbg$l_noun_value] = .temp_key_desc;
                noun_node [dbg$l_adjective_ptr] = 0;
                noun_node [dbg$l_noun_link] = 0;
		END

            ELSE
                report_error;

	END;	! End While

    ! Check to see if key-name string or /ALL has been entered.
    ! If not, return a message and error status.
    !

    IF (.verb_node [dbg$l_verb_object_ptr] EQL 0) AND (NOT .all_flag)
    THEN
        BEGIN
        .message_vect = dbg$nmake_arg_vect(dbg$_needmore);
        RETURN sts$k_severe;
        END;

    RETURN sts$k_success;
    END;


GLOBAL ROUTINE dbg$nexecute_define (verb_node, message_vect) =
!++
! Functional Description
!
!	This routine performs the action associated with the DEFINE command.
!
! Routine Inputs
!
!	verb_node -	The head of a command execution tree. This is built
!			by the routine DBG$NPARSE_DEFINE or by the routine
!			DBG$NPARSE_DEF_KEY in the case of a DEFINE/KEY command,
!			its structure is described in the header of the 
!			routine.
!	message_vect -	An error message vector.
!
! Routine Outputs
!
!	New entries may be made to the DEFINE symbol table. (See DBGLIB.REQ
!	for documentation of the structure of the DEFINE symbol table.)
!	Or, new entries are made to the key-definition table for the DEFINE/KEY
!	command.  This table is external to the debugger structures.
!
!	The routine value is one of:
!	sts$k_success -	Success code.
!	sts$k_severe -	Error. An error message vector is contructed.
!--
    BEGIN

    MAP 
    	verb_node : REF dbg$verb_node;

    LOCAL
    	first_time,					! TRUE first time in loop
    	global_flag,					! TRUE for symbols defined with ==
    	noun_node	: REF dbg$noun_node,		! Points to a noun node
	adverb_node	: REF dbg$adverb_node,		! Points to an adverb node
    	replaced_flag;					! TRUE if definition already existed

    ! Check for DEFINE/KEY.
    !

    IF .verb_node[dbg$b_verb_composite] EQL define_key
    THEN
        BEGIN

        LITERAL
            v_key_noecho	= 0,
            v_key_terminate	= 1,
            v_key_lock		= 2;

        LOCAL
            attributes			: BITVECTOR [32],
            if_state_desc_address	: REF dbg$state_name_node,
            set_state_desc_address	: REF dbg$state_name_node,
            output_log,
            add_status,
            desc_ptr			: REF dbg$stg_desc;

        !+
        !      We will set up the noun and verb pointers and proceed to walk
        ! down the adverb list with the knowledge that the qualifier information
        ! is in order.  After checking the qualifiers, a call is made to the
        ! routine SMG$ADD_KEY_DEF to execute the command; if there is more than
        ! one state noted in the if_state qualifier a call is made to
        ! SMG$ADD_KEY_DEF to load each possible key definition.
        !      Then exit successfully, unless some error was found on the way.
        !-

        noun_node   = .verb_node [dbg$l_verb_object_ptr];
        adverb_node = .verb_node [dbg$l_verb_adverb_ptr];
        attributes  = 0;

        ! ECHO qualifier

        attributes [v_key_noecho] = .adverb_node [dbg$l_adverb_value];
        adverb_node = .adverb_node [dbg$l_adverb_link];

        ! IF_STATE qualifier

        if_state_desc_address = .adverb_node [dbg$l_adverb_value];
        adverb_node = .adverb_node [dbg$l_adverb_link];

        ! LOCK_STATE qualifier

        attributes [v_key_lock] = .adverb_node [dbg$l_adverb_value];
        adverb_node = .adverb_node [dbg$l_adverb_link];

        ! LOG qualifier

        output_log = NOT .adverb_node [dbg$l_adverb_value];
        adverb_node = .adverb_node [dbg$l_adverb_link];

        ! SET_STATE qualifier

        set_state_desc_address = .adverb_node [dbg$l_adverb_value];
        IF (.set_state_desc_address EQL 0) AND (.attributes [v_key_lock])
        THEN
            SIGNAL(dbg$_conflict);
        adverb_node = .adverb_node [dbg$l_adverb_link];

        ! TERMINATE qualifier

        attributes [v_key_terminate] = .adverb_node [dbg$l_adverb_value];
        IF (.attributes [v_key_noecho]) AND (NOT .attributes [v_key_terminate])
        THEN
            SIGNAL(dbg$_conflict);

        ! Execute the define-key command by calling smg$add_key_def.
        ! Loop until no more if_state names exist.

        WHILE TRUE DO
            BEGIN
            ! Add the key definition

            add_status = smg$add_key_def (dbg$gl_key_table_id,
                                          .noun_node [dbg$l_noun_value],
                                          .if_state_desc_address [dbg$l_state_name_ptr],
                                          attributes,
                                          .noun_node [dbg$l_adjective_ptr],
                                          .set_state_desc_address);
            IF NOT .add_status
            THEN
                SIGNAL(dbg$_defkeyerr);
            IF .output_log
            THEN
                SIGNAL(dbg$_defkey, 2,
                       .if_state_desc_address [dbg$l_state_name_ptr],
                       .noun_node [dbg$l_noun_value]);

            if_state_desc_address = .if_state_desc_address [dbg$l_state_name_link];
            IF .if_state_desc_address EQL 0
            THEN
                EXITLOOP;
            END;

        RETURN sts$k_success;
        END;


    ! Loop through the DEFINE list.
    !
    first_time = TRUE;
    WHILE TRUE DO
    	BEGIN

    	! For the first time around the loop, recover the noun node
    	! by following the pointer in the verb node.
    	!
    	IF .first_time
    	THEN 
    	    BEGIN
    	    noun_node = .verb_node [dbg$l_verb_object_ptr];

    	    ! Set first_time to false for future times around the loop.
    	    !
    	    first_time = FALSE;
    	    END

    	! For subsequent times around the loop, get the next noun node
    	! from the link in the current noun node.
    	! Exit the loop when that link is zero.
    	!
    	ELSE
    	    BEGIN
    	    noun_node = .noun_node [dbg$l_noun_link];
    	    IF .noun_node EQL 0
    	    THEN
    		EXITLOOP;
    	    END;

    	! Now determine whether the define was local or global.
    	!
    	IF .noun_node [dbg$l_adjective_ptr] EQL define_global
    	THEN
    	    global_flag = TRUE
    	ELSE
    	    global_flag = FALSE;

 	! We just call the routine DBG$DEF_SYM_ADD to perform the action.
	!
	IF NOT dbg$def_sym_add (.noun_node [dbg$l_noun_value],
				.verb_node [dbg$b_verb_composite],
				.noun_node [dbg$l_noun_value2],
				.global_flag,
    				replaced_flag,
    				.message_vect)
    	THEN
    	    RETURN sts$k_severe;
        END; ! While loop    	

    RETURN sts$k_success;
    END; ! dbg$nexecute_define

GLOBAL ROUTINE dbg$nexecute_delete (verb_node, message_vect) =
!++
! Functional Description
!
!	This routine performs the action associated with the DELETE command.
!	DELETE is the same as UNDEFINE so we just call that routine.
!
! Routine Inputs
!
!	verb_node -	The head of a command execution tree. This is built
!			by the routine DBG$NPARSE_UNDEFINE, and its structure
!			is described in the header of that routine.
!	message_vect -	An error message vector.
!
! Routine Outputs
!
!	Entries may be remove from the DEFINE symbol table. (See DBGLIB.REQ
!	for documentation of the structure of the DEFINE symbol table.
!
!	The routine value is one of:
!	sts$k_success -	Success code.
!	sts$k_severe -	Error. An error message vector is contructed.
!--
    BEGIN
    RETURN dbg$nexecute_undefine(.verb_node, .message_vect);
    END;

GLOBAL ROUTINE dbg$nexecute_undefine (verb_node, message_vect) =
!++
! Functional Description
!
!	This routine performs the action associated with the UNDEFINE command.
!
! Routine Inputs
!
!	verb_node -	The head of a command execution tree. This is built
!			by the routine DBG$NPARSE_UNDEFINE, and its structure
!			is described in the header of that routine.
!	message_vect -	An error message vector.
!
! Routine Outputs
!
!	Entries may be remove from the DEFINE symbol table. (See DBGLIB.REQ
!	for documentation of the structure of the DEFINE symbol table.
!
!	The routine value is one of:
!	sts$k_success -	Success code.
!	sts$k_severe -	Error. An error message vector is contructed.
!--
    BEGIN

    MAP 
    	verb_node : REF dbg$verb_node;

    LOCAL
    	first_time,				! TRUE first time in loop
    	global_flag,				! TRUE for global symbols
    	noun_node	: REF dbg$noun_node,	! Points to a noun node
        adverb_node	: REF dbg$adverb_node,	! Points to an adverb node
    	removed_flag;				! TRUE after the definition is removed

    ! Check for UNDEFINE/KEY.
    !
    IF .verb_node [dbg$b_verb_composite] EQL undefine_key
    THEN

        BEGIN

        LOCAL
            all_flag,
            context		: INITIAL(0),
            output_log,
            del_status,
            temp_state_address	: REF dbg$state_name_node,
            state_desc_address	: REF dbg$state_name_node,
            desc_ptr		: REF dbg$stg_desc,
            key_name_desc	: dbg$stg_desc,
            state_name_desc	: dbg$stg_desc;

        !+
        !      We will set up the noun and verb pointers and proceed to walk
        ! down the adverb list with the knowledge that the qualifier information
        ! is in order.  After checking the qualifiers, a call is made to the
        ! routine SMG$DELETE_KEY_DEF to execute the command; if the /ALL
        ! qualifier exits then calls are made to SMG$LIST_KEY_DEFS to get all
        ! the key definitions in the table.  A call is also made for each
        ! state specified by the State qualifier.
        !      Then exit successfully, unless some error was found on the way.
        !-

        ! Initialize descriptors
        !

        key_name_desc[dsc$w_length] = 0;
        key_name_desc[dsc$b_dtype]  = dsc$k_dtype_t;
        key_name_desc[dsc$b_class]  = dsc$k_class_d;
        key_name_desc[dsc$a_pointer]= 0;

        state_name_desc[dsc$w_length] = 0;
        state_name_desc[dsc$b_dtype]  = dsc$k_dtype_t;
        state_name_desc[dsc$b_class]  = dsc$k_class_d;
        state_name_desc[dsc$a_pointer]= 0;

        noun_node   = .verb_node [dbg$l_verb_object_ptr];
        adverb_node = .verb_node [dbg$l_verb_adverb_ptr];

        ! ALL qualifier

        all_flag = .adverb_node [dbg$l_adverb_value];
        adverb_node = .adverb_node [dbg$l_adverb_link];

        ! LOG qualifier

        output_log = NOT .adverb_node [dbg$l_adverb_value];
        adverb_node = .adverb_node [dbg$l_adverb_link];

        ! STATE qualifier

        state_desc_address = .adverb_node [dbg$l_adverb_value];

        ! If the /ALL qualifier exists
        !

        WHILE .all_flag DO
            BEGIN
            temp_state_address = .state_desc_address;

            del_status = smg$list_key_defs(dbg$gl_key_table_id,
                                           context,
                                           key_name_desc,
                                           state_name_desc);
            IF NOT .del_status
            THEN
                IF .del_status EQL smg$_nomorekeys
                THEN
                    EXITLOOP
                ELSE
                    SIGNAL(dbg$_delkeyerr);

            WHILE .temp_state_address NEQ 0 DO
                BEGIN
                desc_ptr = .temp_state_address [dbg$l_state_name_ptr];

                ! Check to see if the state names match, if so, delete the key
                ! Remember, str$compare_eql returns 0 for a match.
                !

                IF NOT str$compare_eql(state_name_desc, .desc_ptr)
                THEN
                    BEGIN
                    del_status = smg$delete_key_def (dbg$gl_key_table_id,
                                                     key_name_desc,
                                                     state_name_desc);
                    IF NOT .del_status
                    THEN
                        IF .del_status EQL smg$_keynotdef
                        THEN
                            BEGIN
                            IF .output_log THEN
                                SIGNAL(dbg$_undkey, 2, state_name_desc, key_name_desc);
                            EXITLOOP;
                            END
                        ELSE
                            SIGNAL(dbg$_delkeyerr);

                    IF (.output_log) AND (NOT .del_status EQL smg$_keynotdef)
                    THEN
                        BEGIN
                        SIGNAL(dbg$_delkey, 2, state_name_desc, key_name_desc);
                        EXITLOOP;
                        END;
                    END
                ELSE
                    ! If the state names are not the same, look for the next one
                    !

                    temp_state_address =.temp_state_address [dbg$l_state_name_link];
                END;
            END;

        ! If not /ALL
        !

        WHILE NOT .all_flag DO
            BEGIN
            ch$move(8, .noun_node [dbg$l_noun_value], key_name_desc);
            ch$move(8, .state_desc_address [dbg$l_state_name_ptr], state_name_desc);

            del_status = smg$delete_key_def (dbg$gl_key_table_id,
                                             key_name_desc,
                                             state_name_desc);
            IF NOT .del_status
            THEN
                IF .del_status EQL smg$_keynotdef
                THEN
                    BEGIN
                    IF .output_log THEN
                        SIGNAL(dbg$_undkey, 2, state_name_desc, key_name_desc);
                    END
                ELSE
                    SIGNAL(dbg$_delkeyerr);

            IF (.output_log) AND (NOT .del_status EQL smg$_keynotdef)
            THEN
                SIGNAL(dbg$_delkey, 2, state_name_desc, key_name_desc);

            state_desc_address = .state_desc_address [dbg$l_state_name_link];
            IF .state_desc_address EQL 0
            THEN
                EXITLOOP;
            END;

        RETURN sts$k_success;
        END;


    ! Check for UNDEFINE/ALL
    !
    IF .verb_node [dbg$b_verb_composite] EQL undefine_all
    THEN
    	RETURN dbg$def_sym_remove_all (FALSE, .message_vect);

    ! Check for UNDEFINE/ALL/GLOBAL
    !
    IF .verb_node [dbg$b_verb_composite] EQL undefine_all_global
    THEN
    	RETURN dbg$def_sym_remove_all (TRUE, .message_vect);

    ! Loop through the DEFINE list.
    !
    first_time = TRUE;
    WHILE TRUE DO
    	BEGIN

    	! For the first time around the loop, recover the noun node
    	! by following the pointer in the verb node.
    	!
    	IF .first_time
    	THEN 
    	    BEGIN
    	    noun_node = .verb_node [dbg$l_verb_object_ptr];

    	    ! Set first_time to false for future times around the loop.
    	    !
    	    first_time = FALSE;
    	    END

    	! For subsequent times around the loop, get the next noun node
    	! from the link in the current noun node.
    	! Exit the loop when that link is zero.
    	!
    	ELSE
    	    BEGIN
    	    noun_node = .noun_node [dbg$l_noun_link];
    	    IF .noun_node EQL 0
    	    THEN
    		EXITLOOP;
    	    END;

    	! Now determine whether the define was local or global.
    	!
    	IF .noun_node [dbg$l_adjective_ptr] EQL define_global
    	THEN
    	    global_flag = TRUE
    	ELSE
    	    global_flag = FALSE;

 	! We just call the routine DBG$DEF_SYM_REMOVE to perform the action.
	!
	IF NOT dbg$def_sym_remove (.noun_node [dbg$l_noun_value],
				   .global_flag,
    				   removed_flag,
    				   .message_vect)
    	THEN
    	    RETURN sts$k_severe;
    
    	! Signal an informational if the symbol was not defined.
    	!
    	IF NOT .removed_flag
    	THEN
    	    SIGNAL (dbg$_notdefine, 1, .noun_node [dbg$l_noun_value]);

        END; ! While loop    	

    RETURN sts$k_success;
    END;

GLOBAL ROUTINE dbg$nread_name (input_desc, result_addr, message_vect) =
!++
! Functional Description
!
!	Reads the name which is the left-hand-side of the DEFINE command.
!	For now, the names allowed are any string beginning with an
!	alphabetic and followed by any number of alphabetics or numerics
!	and also characters from the set { _, $, % }.
!	The input string descriptor is updated beyond the string that
!	is read. Space is allocated for a counted string to hold the
!	result.
!
! Inputs
!
! 	input_desc -	A pointer to a string descriptor with the input.
!	result_addr - 	The address in which to place the result.
!	message_vect -	A pointer to an error message vector.
! 
! Outputs
!	
!	Space is allocated for a counted string to hold the result.
!	A pointer to this counted string is returned in result_addr.
!	One of the following values is returned:
!	sts$k_success -		Success code.
!	sts$k_severe -		Failure. The input did not contain
!				a legal name. An error message vector
!				is constructed and returned in message_vect.
!--
    BEGIN
    
    MAP
    	input_desc: REF BLOCK [,BYTE];

    LOCAL
    	char,				! Holds a character in the input stream
    	count,				! Count of characters in the name
    	first_char,			! Flag saying we are 
    					!     reading the first character
    	pointer,			! Pointer into the input stream
    	result: REF VECTOR[,BYTE];	! Holds the result

    ! Check for exhausted input.
    !
    IF .input_desc [dsc$w_length] EQL 0
    THEN
    	BEGIN
    	.message_vect = dbg$nmake_arg_vect (dbg$_needmore);
    	RETURN sts$k_severe;
    	END;

    ! Read past leading blanks.
    !
    WHILE TRUE DO
    	BEGIN
    	char = ch$rchar (.input_desc [dsc$a_pointer]);
    	IF  .char NEQ dbg$k_blank
    	AND .char NEQ dbg$k_tab
    	THEN
    	    EXITLOOP;
    	input_desc [dsc$a_pointer] = ch$plus (.input_desc [dsc$a_pointer], 1); 
    	input_desc [dsc$w_length] = .input_desc [dsc$w_length] - 1;
    	END;
    
    ! Check for exhausted input again.
    !
    IF .input_desc [dsc$w_length] EQL 0
    THEN
    	BEGIN
    	.message_vect = dbg$nmake_arg_vect (dbg$_needmore);
    	RETURN sts$k_severe;
    	END;

    ! Initialize the count to zero and the pointer to point to the 
    ! next character in the input stream.
    !
    count = 0;
    pointer = .input_desc [dsc$a_pointer];

    ! Read until we hit a character that cannot be part of the string.
    !
    first_char = TRUE;
    WHILE TRUE DO
    	BEGIN
    	char = ch$rchar (.pointer);

    	! For first character we accept only alphabetics.
    	! Allow % also
    	!
    	IF .first_char AND (.char LSS 'A' OR .char GTR 'Z')
    		       AND (.char LSS 'a' OR .char GTR 'z')
    		       AND .char NEQ '%'
    	THEN
    	    EXITLOOP;

    	! Set first_char to FALSE for future times around loop.
    	!
    	first_char = FALSE;

    	! Accept alphabetics, numerics, $, _, %
    	!
    	IF (.char LSS 'A' OR .char GTR 'Z') AND .char NEQ '_'
    		         AND .char NEQ '$' AND .char NEQ '%'
    			 AND (.char LSS '0' OR .char GTR '9')
    			 AND (.char LSS 'a' OR .char GTR 'z')
    	THEN
    	    EXITLOOP;

    	count = .count + 1;
    	pointer = ch$plus (.pointer, 1);
    	END;    	

    ! Check for running off the end of the input stream.
    !
    IF .count GTR .input_desc [dsc$w_length]
    THEN
    	BEGIN
    	.message_vect = dbg$nmake_arg_vect (dbg$_needmore);
    	RETURN sts$k_severe;
    	END;

    ! Check for no characters read.
    !
    IF .count EQL 0
    THEN
    	BEGIN
    	.message_vect = dbg$nmake_arg_vect (dbg$_illdefnam, 1, 
    		dbg$nnext_word(.input_desc));
    	RETURN sts$k_severe;
    	END;

    ! Allocate space for the result.
    !
    result = dbg$get_memory (1+(1+.count)/4);

    ! Fill in the result, translating lower case to upper case.
    !
    result[0] = .count;
    pointer = result[1];
    INCR i FROM 1 TO .count DO
    	BEGIN
    	char = ch$rchar_a (input_desc[dsc$a_pointer]);
    	IF .char GEQ 'a' AND .char LEQ 'z'
    	THEN
    	    char = .char - ('a' - 'A');
    	ch$wchar_a (.char, pointer);
    	END;
    .result_addr = .result;

    ! Update the input descriptor to point past the string that was read.
    ! The pointer has already been advanced.
    !
    input_desc [dsc$w_length] = .input_desc [dsc$w_length] - .count;

    RETURN sts$k_success;

    END; ! dbg$nread_name

GLOBAL ROUTINE dbg$save_loc (desc1, desc2): NOVALUE =
!
! ROUTINE FUNCTION
!
!	Save away the given descriptor(s) as the current value of dot.
!
! INPUTS
!
!	DESC1		- points to a descriptor to be saved as .
!	DESC2		- points to a VMS descriptor which may also be 
!			  saved. This is stored in an own variable in
!			  this module.
!
! IMPLICIT OUTPUT
!
!	A copy of the given descriptor is constructed out of permanent memory.
!	The DEFINE table is modified to include a new entry for %CURLOC.
!	The secondary descriptor, if present, is copied into an area in this
!	module.
!	
    BEGIN

    BUILTIN
    	actualcount;		! Count of actual parameters

    LOCAL
    	desc1_copy,		! Points to a copy of DESC1.
    	dummy,			! Third parameter for message vectors 
    				!    (not used here)
    	name,			! Point to name %CURLOC.
    	symid_list,		! Points to a symid list.
    	vms_desc;		! Points to the vms descriptor to be saved

    IF actualcount() LSS 2
    THEN
    	vms_desc = 0
    ELSE
    	vms_desc = .desc2;

    ! Copy the descriptor.
    !
    dbg$nget_symid (.desc1, symid_list, dummy);
    dbg$ncopy_desc (.desc1, desc1_copy, dummy);
    dbg$sta_lock_symid (.symid_list);

    ! Save away the copy.
    ! The name must be allocated out of permanent memory.
    !
    name = dbg$get_memory (2);
    ch$move (8, UPLIT BYTE (%ASCIC '%CURLOC'), .name);
    dbg$def_sym_add(.name, define_address, .desc1_copy, TRUE, dummy, dummy);

    ! See if a secondary descriptor was supplied.
    !
    IF .vms_desc EQL 0
    THEN
    	dbg$gl_curloc_vmsdesc = 0
    ELSE
    	BEGIN

    	! Copy it into the area in this module.
    	! and set up the pointer to this area.
    	!
    	ch$move (12, .vms_desc, curloc_vmsdesc);
    	dbg$gl_curloc_vmsdesc = curloc_vmsdesc;
    	END;    

    RETURN;
    END;

GLOBAL ROUTINE dbg$save_val (desc): NOVALUE =
!
! ROUTINE FUNCTION
!
!	Save away the given descriptor as the current value of backslash.
!
! INPUTS
!
!	DESC		- points to a descriptor to be saved as \
!
! IMPLICIT OUTPUT
!
!	A copy of the given descriptor is constructed out of permanent memory.
!	The DEFINE table is modified to include a new entry for %CURVAL.
!	
    BEGIN

    LOCAL
    	desc_copy,		! Points to a copy of DESC.
    	dummy,			! Third parameter for message vectors 
    				!    (not used here)
    	name,			! Point to name %CURVAL
    	symid_list;		! Points to a symid list.

    ! Copy the descriptor.
    !
    dbg$nget_symid (.desc, symid_list, dummy);
    dbg$ncopy_desc (.desc, desc_copy, dummy);
    dbg$sta_lock_symid (.symid_list);

    ! Save away the copy.
    ! The name must be allocated out of permanent memory.
    !
    name = dbg$get_memory (2);
    ch$move (8, UPLIT BYTE (%ASCIC '%CURVAL'), .name);
    dbg$def_sym_add(.name, define_value, .desc_copy, TRUE, dummy, dummy);

    RETURN;
    END;

GLOBAL ROUTINE DBG$WILDCARD_NAME_MATCH (NAME1, NAME2) =
!++
! Functional Description
!	Determines whether the wildcarded name in NAME1 matches the name
!	in NAME2. Asterisk is the wildcard character, and it may match any
!	string of zero or more characters.
!
! Inputs
!	NAME1		- points to a counted string containing a name. The
!			  name may include one or more * (the wildcard char)
!	NAME2		- points to a counted string containing a name.
!
! Outputs
!	The return value is one of:
!	TRUE	- the names do match
!	FALSE	- the names do not match
!--
    BEGIN

    MAP
    	NAME1   : REF VECTOR [,BYTE],
    	NAME2   : REF VECTOR [,BYTE];

    LOCAL
    	ASTER_PTR,		! Points to * in NAME1
    	LENGTH,			! Length to asterisk
    	LENGTH1,		! Remaining length of first string
    	LENGTH2,		! Remaining length of second string
    	NAME1_PTR,		! Pointer into NAME1 string
    	NAME2_PTR,		! Pointer into NAME2 string
    	NEW_NAME1: REF VECTOR[,BYTE],	! Padded copy of NAME1
    	NEW_NAME2: REF VECTOR[,BYTE], 	! Padded copy of NAME2
    	POOLID,			! Memory Pool id
    	RET_VALUE,		! Return value
    	SUBSTR_PTR;		! Points to substring that we find

    ! Copy names into new area padded on left and right.
    !
    POOLID = DBG$PUSH_TEMPMEM();

    NEW_NAME1 = DBG$GET_TEMPMEM ((5+.NAME1[0])/4);
    CH$MOVE (.NAME1[0], NAME1[1], NEW_NAME1[1]);
    NEW_NAME1[0] = 0;
    NEW_NAME1[1+.NAME1[0]] = 0;

    NEW_NAME2 = DBG$GET_TEMPMEM ((5+.NAME2[0])/4);
    CH$MOVE (.NAME2[0], NAME2[1], NEW_NAME2[1]);
    NEW_NAME2[0] = 0;
    NEW_NAME2[1+.NAME2[0]] = 0;

    ! Initialize lengths, pointers, and flags.
    !
    LENGTH1 = 2+.NAME1[0];
    NAME1_PTR = .NEW_NAME1;
    LENGTH2 = 2+.NAME2[0];
    NAME2_PTR = .NEW_NAME2;
    RET_VALUE = TRUE;

    ! Loop through the portions of the string between asterisks.
    !
    WHILE .LENGTH1 GTR 0 DO
    	BEGIN
    	
    	! If we have exhausted the second string, return false.
    	!
    	IF .LENGTH2 LEQ 0
    	THEN
    	    BEGIN
    	    RET_VALUE = FALSE;
    	    EXITLOOP;
    	    END;

    	! Obtain pointer to first asterisk.
    	!
        ASTER_PTR = CH$FIND_CH (.LENGTH1, .NAME1_PTR, '*');
    	IF .ASTER_PTR EQL 0
    	THEN
    	    ASTER_PTR = .NAME1_PTR + .LENGTH1;
    	LENGTH = .ASTER_PTR - .NAME1_PTR;
    	    	
    	! Look for the next match.
    	!
    	SUBSTR_PTR = CH$FIND_SUB ( .LENGTH2,	! Context length
    				   .NAME2_PTR,	! Context pointer
    				   .LENGTH,		! Pattern length
    				   .NAME1_PTR);	! Pattern pointer
    	IF .SUBSTR_PTR EQL 0
    	THEN
    	    BEGIN
    	    RET_VALUE = FALSE;
    	    EXITLOOP;
    	    END;

    	LENGTH1 = .LENGTH1 - (1 + .LENGTH);
    	NAME1_PTR = .ASTER_PTR + 1;
    	LENGTH2 = .LENGTH2 - (.LENGTH + .SUBSTR_PTR - .NAME2_PTR);
    	NAME2_PTR = .SUBSTR_PTR + .LENGTH;
    	END;

    ! If we have exactly matched the second string, return true.
    !
    IF .LENGTH2 NEQ 0
    THEN
        RET_VALUE = FALSE;
    
    DBG$POP_TEMPMEM (.POOLID);
    RETURN .RET_VALUE;
    END; ! dbg$wildcard_name_match

ROUTINE dump_entry (sym_ptr, addr_flag, type_flag, message_vect) = 
!++
! Routine Description
!
! 	This routine dumps an entry in a define list.
!
! Inputs
!
!	sym_ptr 	- A pointer to the entry.
!	addr_flag	- says to display the thing that the symbol is bound to
!	type_flag 	- says to display the kind of defined symbol
!   	message_vect	- An error message vector
!
! Outputs
!
!	The entry is displayed at the terminal.
!   	A status code is returned.
!--
    BEGIN

    MAP
        sym_ptr: REF define$entry; 

    LOCAL
    	sym_kind: BYTE;	! Holds code for kind of symbol

    ! Print the symbol name.
    !
    dbg$print (UPLIT BYTE (%ASCIC 'defined '));
    dbg$print (.sym_ptr [def$a_name]);
    dbg$newline();

    ! Print the value.
    !
    IF .addr_flag
    THEN
    	BEGIN
        dbg$print (UPLIT BYTE (%ASCIC '    bound to: '));
        CASE .sym_ptr [def$b_kind] FROM define_lowest TO define_highest OF
    	    SET
    	    [define_address] :
    	        BEGIN
    	        LOCAL
    		    addr_exp_desc : REF dbg$valdesc,
    		    string_desc : dbg$stg_desc;

	        addr_exp_desc = .sym_ptr [def$a_value];

	        ! Case on kind of descriptor.
	        !
	        CASE .addr_exp_desc [dbg$b_dhdr_type] FROM dbg$k_min_descr_type
						  TO dbg$k_max_descr_type
						  OF
	            SET

    		    ! Implementation level 3 Primary Descriptors.
    		    !
    		    [dbg$k_primary_desc] :
    		        dbg$print_identifier (.addr_exp_desc);

    		    ! Implementation level 3 volatile value descriptors
    		    !
    		    [dbg$k_v_value_desc] :
    		        BEGIN
    		        LOCAL
    			    val_desc: REF dbg$valdesc;    	

    		        ! Turn the volatile value descriptor into an ordinary
    		        ! value descriptor and then print it.
    		        !
    		        IF NOT dbg$ncopy_desc (.addr_exp_desc, val_desc, 
    					   .message_vect, FALSE)
    		        THEN
    			    RETURN sts$k_severe;
    		        val_desc[dbg$b_dhdr_type] = dbg$k_value_desc;
    		        val_desc[dbg$l_value_value0] = 
    			    .val_desc[dbg$l_value_pointer];
    		        val_desc[dbg$l_value_pointer] = 
    			     val_desc[dbg$l_value_value0];
    		        dbg$print_value (.val_desc, 
    					 .dbg$gb_radix[dbg$b_radix_output_over],
    			    .dbg$gl_sign_flag, false);
    		        END;

    		    ! We do not expect any other kind of descriptor.
    		    !
    		    [INRANGE, OUTRANGE] :
    		        $dbg_error ('DBGDEFINE\DBG$DUMP_DEFINE');
    			
    		    TES;
    	        END;
    		
    	    [define_command,
    	     define_parameter,
    	     define_procedure,
    	     define_string] :
    	        BEGIN
    	        dbg$print (UPLIT BYTE (%ASCIC '"'));
    	        dbg$print (.sym_ptr [def$a_value]);
    	        dbg$print (UPLIT BYTE (%ASCIC '"'));
    	        END;

    	    [define_value] :
    	        BEGIN
    		dbg$print_value (.sym_ptr[def$a_value], 
    				 .dbg$gb_radix[dbg$b_radix_output_over],
    			         .dbg$gl_sign_flag, false);
    	        END;	

    	    [INRANGE, OUTRANGE] :
    		$DBG_ERROR('DBGDEFINE\DUMP_ENTRY');

       	    TES;
        dbg$newline();
    	END;

    ! Print the kind of symbol.
    !
    IF .type_flag
    THEN
    	BEGIN
        dbg$print (UPLIT BYTE (%ASCIC '    '));
        CASE .sym_ptr [def$b_kind] FROM define_lowest TO define_highest OF
            SET
    	    [define_address] :
    	        dbg$print (UPLIT BYTE (%ASCIC 'was defined /address'));
    	    [define_command] :
    	        dbg$print (UPLIT BYTE (%ASCIC 'was defined /command'));
            [define_parameter] :
    	        dbg$print (UPLIT BYTE (%ASCIC 'parameter to DEBUG command procedure'));
    	    [define_procedure] :
    	        dbg$print (UPLIT BYTE (%ASCIC 'was defined /procedure'));
    	    [define_string] :
    	        dbg$print (UPLIT BYTE (%ASCIC 'was defined /string'));
    	    [define_value] :
       	        dbg$print (UPLIT BYTE (%ASCIC 'was defined /value'));
    	    [INRANGE,OUTRANGE]:
    		$DBG_ERROR('DBGDEFINE\DUMP_ENTRY');
       	    TES;
    	dbg$newline();
    	END;

    RETURN sts$k_success;
    END; ! of dump_entry 

ROUTINE free_entry (sym_ptr, message_vect) =
!++
! Routine Description
!
!	This routine frees up the space occupied by the define entry pointed
!	to by sym_ptr.
!
! Inputs
!
!	sym_ptr -	Points to an entry in the define list
!	message_vect -	An error message vector
!
! Outputs
!
!	A condition code which is one of:
!	STS$K_SUCCESS -		Success.
!	STS$K_SEVERE  -		Failure. An error message vector is constructed.
!--
    BEGIN

    MAP
    	sym_ptr : REF define$entry;

    LOCAL
    	symid_list;			! Points to a symid list

    ! Free up the space taken up by the name.
    !
    dbg$rel_memory (.sym_ptr[def$a_name]);

    ! Free up the space taken up by the value.
    !
    CASE .sym_ptr[def$b_kind] FROM define_lowest TO define_highest OF
    	SET

    	! Addresses are stored as an address expression descriptor.
    	! We free up the space occupied by the descriptor, and depending
    	! on the kind of descriptor, free up any space occupied by
    	! auxiliary primary descriptors.
    	!
    	[define_address] :
    	    BEGIN
    	    IF dbg$nget_symid (.sym_ptr[def$a_value],
    				symid_list, .message_vect)
    	    THEN
    		dbg$sta_unlock_symid (.symid_list);
    	    IF NOT dbg$nfree_desc (.sym_ptr[def$a_value], .message_vect)
    	    THEN
    		RETURN sts$k_severe;
    	    END;    	    
    	
    	! For the four cases below, the value is stored as a counted 
    	! string, so we just free up the storage.
    	!
    	[define_command,
    	define_parameter,
    	define_procedure,
    	define_string] :
    	    dbg$rel_memory (.sym_ptr[def$a_value]);

    	! Values are stored in the form of language-specific
    	! descriptors, so we call the free_desc routine that vectors on
    	! the language and calls the appropriate routine to free up 
    	! the descriptor.
    	!
    	[define_value] :
    	    BEGIN
    	    IF dbg$nget_symid (.sym_ptr[def$a_value],
    				symid_list, .message_vect)
    	    THEN
    		dbg$sta_unlock_symid (.symid_list);
    	    IF NOT dbg$nfree_desc (.sym_ptr[def$a_value], .message_vect)
    	    THEN
    		RETURN sts$k_severe;
    	    END;

    	[INRANGE,OUTRANGE]:
    	    $DBG_ERROR('DBGDEFINE\FREE_ENTRY');

    	TES;
    
    RETURN sts$k_success;

    END; ! free_entry

ROUTINE name_match (name1, name2) =
!++
! Functional Description
!
!	This routine is used by the SYM_ADD and SYM_FIND routines to 
!	determine whether a pair of DEFINEd names are the same. 
!	This is now a straightforward string match (which could be
!	done inline), but I made it a subroutine in case the rules
!	for name matching become more complex, in which case we
!	will only want to change the code in only one place.
!
! Inputs
!
!	name1 -	Points to a counted string for the first name.
!	name2 - Points to a counted string for the second name.
!
! Outputs
!
!	Returns TRUE if the names match and FALSE if they don't.
!--
    BEGIN

    MAP
    	name1: REF VECTOR [,BYTE],
    	name2: REF VECTOR [,BYTE];

    ! Compare lengths
    !
    IF .name1[0] NEQ .name2[0]
    THEN
    	RETURN FALSE;

    ! Compare the actual strings
    !
    IF NOT ch$eql (.name1[0], name1[1], .name2[0], name2[1])
    THEN
    	RETURN FALSE;

    RETURN TRUE;
    END; ! name_match


GLOBAL ROUTINE dbg$read_key_info (input_desc, result_desc, message_vect) =
!++
! Functional Description
!
!	Reads a string from the DEFINE/KEY command.  The string will be
!	any length of alphanumeric characters, including $ and _.
!
!	The input string descriptor is updated beyond the string that
!	is read. Space is allocated for a counted string to hold the
!	result.
!
! Inputs
!
! 	input_desc -	A pointer to a string descriptor with the input.
!	result_desc - 	A pointer to a string descriptor with the result.
!	message_vect -	A pointer to an error message vector.
! 
! Outputs
!	
!	Space is allocated for a counted string to hold the result.
!	A pointer to this counted string is returned in result_addr.
!	One of the following values is returned:
!	sts$k_success -		Success code.
!	sts$k_severe -		If input descriptor has nothing in it to
!				return.
!--
    BEGIN
    
    MAP
    	input_desc	: REF BLOCK [,BYTE],
	result_desc	: REF BLOCK [,BYTE];

    LOCAL
    	char,				! Holds a character in the input stream
    	count,				! Count of characters in the name
    	pointer,			! Pointer into the input stream
    	result	: REF VECTOR[,BYTE];	! Holds the result

    ! Check for exhausted input.
    !
    IF .input_desc [dsc$w_length] EQL 0
    THEN
    	BEGIN
    	.message_vect = dbg$nmake_arg_vect (dbg$_needmore);
    	RETURN sts$k_severe;
    	END;

    ! Read past leading blanks.
    !
    WHILE TRUE DO
    	BEGIN
    	char = ch$rchar (.input_desc [dsc$a_pointer]);
    	IF  .char NEQ dbg$k_blank
    	AND .char NEQ dbg$k_tab
    	THEN
    	    EXITLOOP;
    	input_desc [dsc$a_pointer] = ch$plus (.input_desc [dsc$a_pointer], 1); 
    	input_desc [dsc$w_length] = .input_desc [dsc$w_length] - 1;
    	END;
    
    ! Check for exhausted input again.
    !
    IF .input_desc [dsc$w_length] EQL 0
    THEN
    	BEGIN
    	.message_vect = dbg$nmake_arg_vect (dbg$_needmore);
    	RETURN sts$k_severe;
    	END;

    ! Initialize the count to zero and the pointer to point to the 
    ! next character in the input stream.
    !
    count = 0;
    pointer = .input_desc [dsc$a_pointer];

    ! Read until we hit a character that cannot be part of the string.
    !
    WHILE TRUE DO
    	BEGIN
    	char = ch$rchar (.pointer);

    	! Accept alphanumerics, $, and _.
    	!
    	IF (.char GEQ 'A' AND .char LEQ 'Z') OR
           (.char GEQ 'a' AND .char LEQ 'z') OR
           (.char GEQ '0' AND .char LEQ '9') OR
           (.char EQL '$') OR (.char EQL '_')
    	THEN
            BEGIN
            count = .count + 1;
    	    pointer = ch$plus (.pointer, 1);
            END
        ELSE
    	    EXITLOOP;
    	END;    	

    ! Check for no characters read.
    !
    IF .count EQL 0
    THEN
    	BEGIN
    	.message_vect = dbg$nmake_arg_vect (dbg$_needmore);
    	RETURN sts$k_severe;
    	END;

    ! Allocate space for the result.
    !
    result = dbg$get_tempmem (1+(1+.count)/4);

    ! Fill in the result, translating lower case to upper case.
    !
    result_desc [dsc$w_length] = .count;
    pointer = result[0];
    INCR i FROM 1 TO .count DO
    	BEGIN
    	char = ch$rchar_a (input_desc[dsc$a_pointer]);
    	IF .char GEQ 'a' AND .char LEQ 'z'
    	THEN
    	    char = .char - ('a' - 'A');
    	ch$wchar_a (.char, pointer);
    	END;
    result_desc [dsc$a_pointer] = .result;

    ! Update the input descriptor to point past the string that was read.
    ! The pointer has already been advanced.
    !
    input_desc [dsc$w_length] = .input_desc [dsc$w_length] - .count;

    RETURN sts$k_success;

    END;
END

ELUDOM
