	.TITLE	MAIL$IOSUBS - INPUT/OUTPUT SUBROUTINES
	.IDENT	'V04-000'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:	VAX/VMS MAIL UTILITY
;
; ABSTRACT:	INPUT AND OUTPUT SUBROUTINES.
;
; ENVIRONMENT:	NATIVE/USER MODE 
;
; AUTHOR:	LEN KAWELL, CREATION DATE: 2-FEB-79
;
; MODIFICATION HISTORY:
;
;	V03-008	BLS0255		Benn Schreiber		28-Dec-1983
;		Correct upcase_q, use new global flags
;
;	V03-007	BLS0246		Benn Schreiber		 8-Nov-1983
;		Add MAIL$IOSUB_INIT to remove statically allocated buffers
;
;	V03-006	BLS0229		Benn Schreiber		16-Jul-1983
;		Remove routines rewritten into BLISS and fold in what
;		is left of NETSEND.MAR
;
;	V03-005	BLS0220		Benn Schreiber		30-Apr-1983
;		Keyapd input routine support
;
;	V03-004	BLS0214		Benn Schreiber		27-Mar-1983
;		Add MAIL$FAO_GETMSG to GETMSG a message and then
;		apply fao to it.
;
;	V03-003	BLS0211		Benn Schreiber		13-Mar-1983
;		Rework alternate net support for more flexibility.  Handle
;		CTRL/C as EOF in MAIL$GET_INPUT
;
;	V03-002	BLS0194		Benn Schreiber		19-Nov-1982
;		Add support for alternate incoming network access
;
;	V03-001	BLS0189		Benn Schreiber		15-Oct-1982
;		Add routine to upcase except in double quote pairs
;		Add routine to do wildcard matching
;--

	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;

;
; EQUATED SYMBOLS:
;
BUFF_DESC	= 4			;BUFFER DESCRIPTOR ARGUMENT
FAOARG1		= 8			;FIRST FAO ARGUMENT ARGUMENT

MAIL$K_INBUFFSZ	= 512			;INPUT BUFFER SIZE

	$STSDEF				;STATUS MESSAGE DEFINITIONS
	$SHRDEF				;SHARED MESSAGE DEFINITIONS
	CNCTDEF				;CNCT BLOCK DEFINITIONS
	LNKDEF				;LOGICAL LINK DEFINITIONS
	MAIFDEF				;MAIL CONTROL FLAG DEFINITIONS
;
; LOCAL MACROS:
;

;
; OWN STORAGE:
;

	.PSECT	$OWN$,LONG,RD,WRT,NOEXE

MSGDESC:.LONG	255			;EVENTUALLY A DESCRIPTOR (ORDER ASSUMED)
MSGBUF:	.LONG	0
FAODESC:.LONG	512			;AND ANOTHER DESCRIPTOR
FAOBUF:	.LONG	0

	.PSECT	$CODE$,LONG,RD,NOWRT,EXE

	.SBTTL	MAIL$IOSUB_INIT - ALLOCATE SOME BUFFERS
;++
; FUNCTIONAL DESCRIPTION:
;
;	ALLOCATE BUFFERS FOR ROUTINES IN THIS MODULE
;
;--

	.ENTRY	MAIL$IOSUB_INIT,^M<R2,R3,R4>
	MOVZWL	#255,-(SP)		;SIZE OF BUFFER TO ALLOCATE
	PUSHAB	MSGBUF			;ADDRESS OF LONGWORD TO STORE ADDR IN
	PUSHAB	4(SP)			;ADDR OF SIZE OF BUFFER
	CALLS	#2,G^LIB$GET_VM		;ALLOCATE IT
	BLBC	R0,20$			;BRANCH IF ERROR
	MOVZWL	#512,(SP)		;ALLOCATE FAO BUFFER
	PUSHAB	FAOBUF			;ADDR TO STORE BUFFER ADDR INTO
	PUSHAB	4(SP)			;ADDR OF SIZE OF BUFFER
	CALLS	#2,G^LIB$GET_VM		;ALLOCATE
	BLBS	R0,40$			;BRANCH IF ALL OK
20$:	PUSHL	R0			;SIGNAL ERROR
	CALLS	#1,G^LIB$SIGNAL
40$:	RET


	.SBTTL	MAIL$CONFIRM - PROMPT FOR CONFIRMATION
;++
; FUNCTIONAL DESCRIPTION:
;
;	 IF THIS IS NOT A NETWORK JOB, THEN PROMPT FOR A YES OR NO
;	RESPONSE AND CHECK IF YES OR NO.
;
; CALLING SEQUENCE:
;	CALL MAIL$CONFIRM(BUFF_DESC,PROMPT_DESC)
;
; INPUT PARAMETERS:
;	BUFF_DESC(AP) = ADDR OF BUFFER DESCRIPTOR
;	PROMPT_DESC(AP) = ADDR OF PROMPT DESCRIPTOR
;
; IMPLICIT INPUTS:
;	MAIL$GL_FLAGS[MAIF_V_NETJOB] = 1 IF THIS IS A NETWORK JOB.
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	NONE
;
; COMPLETION CODES:
;	R0 = SUCCESS IF RESPONSE WAS A "Y",
;	   = ERROR IF NO RESPONSE, RESPONSE WAS NOT A "Y", OR JOB IS
;	     A NETWORK JOB.
;
; SIDE EFFECTS:
;	PROMPT DISPLAYED AND INPUT OBTAINED FROM INPUT DEVICE.
;
;--
	.ENTRY	MAIL$CONFIRM,-		;PROMPT AND GET RESPONSE
		^M<R2>			;(ENTRY MASK)
	BBS	#MAIF_V_NETJOB,MAIL$GL_FLAGS,20$ ;BR IF NETWORK JOB
	PUSHL	8(AP)			;STACK PROMPT DESCRIPTOR ADDRESS
	PUSHL	4(AP)			;STACK GET-STRING
	PUSHAB	MAIL$L_SMG_KEYBOARD	;AND KEYBOARD ID
	CALLS	#3,G^SMG$READ_STRING	;READ FROM SYS$INPUT
	MOVL	BUFF_DESC(AP),R2	;GET ADDRESS OF BUFFER DESC
	TSTW	(R2)			;NO RESPONSE?
	BEQL	20$			;BR IF YES - NO RESPONSE = "NO"
	CMPB	#^A"Y",@4(R2)		;WAS RESPONSE "YES"?
	BEQL	10$			;BR IF YES
	CMPB	#^A"y",@4(R2)		;WAS RESPONSE "yes"?
	BNEQ	20$			;BR IF NO
10$:
	MOVL	#1,R0			;SET "YES" RESPONSE
	RET				;
20$:
	CLRL	R0			;SET "NO" RESPONSE
	RET				;


	.SBTTL	MAIL$UPCASE - CONVERT A STRING TO UPPERCASE
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO CONVERT A STRING TO UPPER CASE CHARACTERS.
;
; INPUTS:
;
;	BUFF_DESC = ADDRESS OF STRING DESCRIPTOR.
;
; OUTPUTS:
;
;	STRING CONVERTED TO UPPERCASE.
;--
	.ENTRY	MAIL$UPCASE,-			;CONVERT TO UPPER CASE
		^M<R2>				;(ENTRY MASK)
	MOVL	BUFF_DESC(AP),R0		;GET ADDRESS OF DESCRIPTOR
	MOVZWL	(R0),R1				;GET SIZE OF STRING
	BEQL	30$				;EXIT IF ZERO
	MOVL	4(R0),R0			;GET ADDRESS OF STRING
10$:	MOVB	(R0)+,R2			;GET NEXT CHARACTER
	CMPB	R2,#^A"a"			;LOWER CASE LETTER?
	BLSSU	20$				;IF LSSU NO
	CMPB	R2,#^A"z"			;LOWER CASE LETTER?
	BGTRU	20$				;IF GTRU NO
	SUBB3	#32,R2,-1(R0)			;CONVERT TO UPPERCASE LETTER
20$:	SOBGTR	R1,10$				;DECREMENT COUNT AND LOOP
30$:	RET					;

	.SBTTL	MAIL$UPCASE_Q - CONVERT A STRING TO UPPERCASE HANDLING QUOTES
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE IS CALLED TO CONVERT A STRING TO UPPER CASE CHARACTERS.
;	CHARACTERS INSIDE DOUBLE QUOTES ARE NOT CONVERTED
;
; INPUTS:
;
;	BUFF_DESC = ADDRESS OF STRING DESCRIPTOR.
;
; OUTPUTS:
;
;	STRING CONVERTED TO UPPERCASE.
;--
	.ENTRY	MAIL$UPCASE_Q,-			;CONVERT TO UPPER CASE
		^M<R2,R3>				;(ENTRY MASK)
	MOVL	BUFF_DESC(AP),R0		;GET ADDRESS OF DESCRIPTOR
	MOVZWL	(R0),R1				;GET SIZE OF STRING
	BEQL	30$				;EXIT IF ZERO
	CVTBL	#-1,R3				;ASSUME NOT IN DOUBLE QUOTES
	MOVL	4(R0),R0			;GET ADDRESS OF STRING
10$:	MOVB	(R0)+,R2			;GET NEXT CHARACTER
	CMPB	R2,#^A/"/			;DOUBLE QUOTE CHARACTER?
	BNEQ	15$				;IF NEQ NO
	INCL	R3				;YES--INCREMENT LEVEL
	BEQL	20$				;IF EQL FIRST QUOTE
	CVTBL	#-1,R3				;RESET QUOTE LEVEL
	BRB	20$				;CONTINUE
15$:	TSTL	R3				;INSIDE QUOTES?
	BGEQ	20$				;IF GEQ YES
	CMPB	R2,#^A"a"			;LOWER CASE LETTER?
	BLSSU	20$				;IF LSSU NO
	CMPB	R2,#^A"z"			;LOWER CASE LETTER?
	BGTRU	20$				;IF GTRU NO
	SUBB3	#32,R2,-1(R0)			;CONVERT TO UPPERCASE LETTER
20$:	SOBGTR	R1,10$				;DECREMENT COUNT AND LOOP
30$:	RET					;

	.SBTTL	MAIL$GETMSG - Find message text for code
;++
; Functional description:
;
;	return descriptor for message code
;
; inputs:
;
;	4(ap) = value of code to lookup
;
; routine value:
;
;	r0 = address of descriptor of message text
;
;--
	.ENTRY	MAIL$GETMSG,^M<R2>

	MOVAB	L^MSGDESC,R2
	MOVZWL	#512,(R2)
	$GETMSG_S MSGID=4(AP),-
		MSGLEN=MSGDESC,-
		BUFADR=MSGDESC,-
		FLAGS=#1
	MOVL	R2,R0
	RET

	.SBTTL	MAIL$FAO_GETMSG, GETMSG and then FAO message
;++
; FUNCTIONAL DESCRIPTION:
;
;	This routine performs a $GETMSG on a message, then does a $FAO,
;	and returns the address of the string descriptor of the result.
;
; Inputs:
;
;	4(AP) = Value of message code
;	8(AP) = Start of $fao arglist
;
;--
	.ENTRY	MAIL$FAO_GETMSG,^M<R2>
	PUSHL	4(AP)
	CALLS	#1,W^MAIL$GETMSG
	MOVAB	FAODESC,R2		;GET ADDRESS OF BUFFER DESCRIPTOR
	MOVZWL	#512,(R2)		;RESET DESCRIPTOR
	MOVL	R0,R1			;GET ADDRESS OF CONTROL STRING DESCR
	$FAOL_S	CTRSTR=(R1),-		;DO THE FAO
		OUTLEN=(R2),-
		OUTBUF=(R2),-
		PRMLST=8(AP)
	BLBC	R0,10$			;IF THERE IS AN ERROR, WILL ACCVIO
	MOVL	R2,R0			; EVENTUALLY
10$:	RET

	.SBTTL	MAIL$MATCH_NAME, general wild card matching
;++
; Functional Description:
;	This routine performs the general embedded wild card matching
;	algorithm.
;
; Calling Sequence:
;	ret_status.wlc.v = STR$MATCH_NAME (CAND.rt.dx,PATRN.rt.dx)
;
; Formal Parameters:
;	CAND.rt.dx	Address of string descriptor for candidate string
;			 (The current item being looked at)
;	PATRN.rt.dx	Address of string descriptor for pattern string
;			 (The item looking for)
;
; Implicit Inputs:
;	none
;
; Output Parameters:
;	none
;
; Implicit Outputs:
;	none
;
; Routines Called:
;	STR$ANALYZE_SDESC_R1
;
; Routine Value:
;	STR$_MATCH   if the strings match.
;	STR$_NOMATCH if the strings don't match
;
; Signals:
;	Errors from STR$ANALYZE_SDESC
;
; Side Effects:
;	none
;
;--
	STR$_MATCH = 1
	STR$_NOMATCH = 0

	.ENTRY	mail$match_name,^M<R2,R3,R4,R5,R6,R7,R8,R9>

	MOVL	4(AP),R0		; get first descriptor address
	JSB	G^STR$ANALYZE_SDESC_R1	; extract string length and address
	MOVQ	R0,-(SP)		; save descriptor
	MOVL	8(AP),R0		; get second descriptor address
	JSB	G^STR$ANALYZE_SDESC_R1	; analyze second descriptor
	MOVQ	R0,R4			; set up for match algorithm
	MOVQ	(SP)+,R2		; retrieve first descriptor
	MOVL	#STR$_NOMATCH,R0	; Assume failure
	CLRL	R6			; Clear saved candidate count
;
; Main scanning loop.
;
10$:	DECL	R4			; Pattern exhausted?
	BLSS	30$			; Branch if yes
	MOVZBL	(R5)+,R1		; Get next character in pattern
	CMPB	R1,#^A'*'		; Pattern specifies wild string?
	BEQL	60$			; Branch if yes
	DECL	R2			; Candidate exhausted?
	BLSS	50$			; Branch if yes
	CMPB	R1,(R3)+		; Compare pattern to candidate
	BEQL	10$			; Branch if pattern equals candidate
	CMPB	R1,#^A'%'		; Pattern specifies wild character?
	BEQL	10$			; Branch if yes
;
; We have detected a mismatch, or we are out of pattern while there is
; candidate left.  Back up to the last '*', advance a candidate character,
; and try again.
;
20$:	DECL	R6			; Count a saved candidate character
	BLSS	50$			; Branch if no saved candidate
	INCL	R7			; Set to try next character
	MOVQ	R6,R2			; Restore descriptors to backup point
	MOVQ	R8,R4			;
	BRB	10$			; Continue testing
;
; Here when pattern is exhausted.
;
30$:	TSTL	R2			; Candidate exhausted?
	BNEQ	20$			; Branch if no
;
; Here to return.
;
40$:	MOVL	#STR$_MATCH,R0		; Set success return
50$:	RET				; Return
;
; We have detected a '*' in the pattern.  Save the pointers for backtracking.
;
60$:	TSTL	R4			; Pattern null after '*'?
	BEQL	40$			; Branch if yes
	MOVQ	R2,R6			; Save descriptors of both strings
	MOVQ	R4,R8			;
	BRB	10$			; Continue testing

	.SBTTL	MAIL$READ_ERROR_TEXT
;
; FUNCTIONAL DESCRIPTION:
;
;	READ THE ERROR MESSAGE TEXT FROM THE REMOTE NODE AND SIGNAL
;	THEM ALL AT ONCE.
;
; INPUTS:
;
;	4(AP) CONTEXT BLOCK ADDRESS
;	8(AP) ADDR OF ROUTINE TO CALL TO READ NEXT RECORD
;
;	QUITS READING ON BYTE OF 0
;
;
; GET STATUS MESSAGE(S) FROM SLAVE AND SIGNAL
;
	.ENTRY MAIL$READ_ERROR_TEXT,^M<R2,R3,R4>
	CLRL	R3			;SET END-OF-MESSAGES MARKER
20$:
	MOVAL	-MAIL$K_INBUFFSZ(SP),SP ;CREATE MESSAGE BUFFER
	PUSHL	R3			;STACK ADDR OF PREVIOUS MSG DESC
	PUSHAB	4(SP)			;CREATE DESCRIPTOR OF THIS MSG DESC
	PUSHL	#MAIL$K_INBUFFSZ	;...
	MOVL	SP,R4			;SAVE ADDR OF THIS ONE
	PUSHL	R4			;STACK DESCRIPTOR ADDRESS
	PUSHL	4(AP)			;STACK CONTEXT ADDRESS
	CALLS	#2,@8(AP)		;CALL GET-ROUTINE
	BLBC	R0,30$			;TREAT ERROR AS END OF MESSAGE
27$:	TSTB	@4(R4)			;END OF MESSAGES?
	BEQL	30$			;BR IF YES - SIGNAL THEM
	MOVL	R4,R3			;SET NEW PREVIOUS DESC ADDR
	BRB	20$			;GET NEXT MESSAGE
30$:
	CLRL	R4			;INIT SIGNAL ARGUMENT COUNT
40$:
	PUSHL	R3			;SET ADDR OF MESSAGE DESC
	BEQL	60$			;BRANCH IF NONE
	MOVW	#1,-(SP)		;SET MESSAGE FLAGS (NO %MAIL-F-TEXT,)
	MOVW	#1,-(SP)		;SET FAO COUNT
	PUSHL	#SHR$_TEXT!-		;SET MESSAGE NAME
		<MAIL$_FACILITY @ STS$V_FAC_NO>
	ADDL	#3,R4			;INCREMENT SIGNAL ARGUMENT COUNT
	MOVL	8(R3),R3		;GET ADDR OF NEXT DESC
	BNEQ	40$			;BR IF THERE IS ONE
	CALLS	R4,G^LIB$SIGNAL		;SIGNAL THE MESSAGES
60$:	RET				;DONE




	.SBTTL	MAIL$INCLINKADR - INCREMENT LINK ADDRESSEE COUNT
;++
; FUNCTIONAL DESCRIPTION:
;
;	INCREMENT THE ADDRESSEE COUNT ASSOCIATED WITH A LINK
;
; INPUTS:
;
;	4(AP)	ADDRESS OF LINK BLOCK
;
; OUTPUTS:
;
;	LNK_L_ADRCNT IN LINK BLOCK INCREMENTED IF LINK BLOCK ADDRESS
;	NON-0
;
;--
	.ENTRY	MAIL$INCLINKADR,^M<R2>

	MOVL	4(AP),R2		;GET LINK BLOCK ADDRESS
	BEQL	10$			;IF EQL ALL DONE
	BBS	#LNK_V_DEAD,LNK_B_FLAGS(R2),10$ ;DON'T INCREMENT IT IF DEAD
	INCL	LNK_L_ADRCNT(R2)	;INCREMENT THE COUNT
10$:	RET

	.SBTTL	MAIL$DECLINKADR - DECREMENT LINK ADDRESSEE COUNT

;++
; FUNCTIONAL DESCRIPTION:
;
;	DECREMENTS THE ADDRESSEE COUNT ASSOCIATED WITH A LINK
;
; INPUTS:
;
;	4(AP)	ADDRESS OF THE LINK BLOCK
;
;--

	.ENTRY	MAIL$DECLINKADR,^M<R2>
	MOVL	4(AP),R2		;GET ADDRESS OF LINK BLOCK
	BEQL	10$			;IF 0 THEN NONE
	TSTL	LNK_L_ADRCNT(R2)	;ALREADY 0?
	BEQL	10$
	DECL	LNK_L_ADRCNT(R2)	;DECREMENT IT'S ADDRESEE COUNT
10$:	RET

	.SBTTL	MAIL$DELEMPLINK - DELETE ALL LINKS WITH NO ADDRESSEES
;++
; FUNCTIONAL DESCRIPTION
;
;	DELETE ALL LOGICAL LINKS WHICH HAVE NO ADDRESSEES ASSOCIATED
;	WITH THEM
;
; INPUTS:
;
;	THE LINK LIST
;
;--

	.ENTRY	MAIL$DELEMPLINK,^M<R2,R3,R4>

	MOVL	4(AP),R2		;START AT THE HEAD OF THE LIST
	MOVL	R2,R4			;SAVE LISTHEAD ADDRESS
10$:	MOVL	LNK_L_FLINK(R2),R2	;GET NEXT LINK BLOCK
20$:	CMPL	R2,R4			;DONE WITH LIST?
	BEQL	30$			;IF EQL YES
	TSTL	LNK_L_ADRCNT(R2)	;NO--ANY ADDRESSEES THIS NODE?
	BNEQ	10$			;IF NEQ YES
	MOVL	LNK_L_FLINK(R2),R3	;NO--GET NEXT IN LIST
	REMQUE	(R2),R2			;REMOVE THIS LINK FROM THE QUEUE
	BSBB	DEALLOC_LNK		;DELETE THE LINK AND MEMORY
	MOVL	R3,R2			;CONTINUE SCANNING
	BRB	20$			;CONTINUE
30$:	RET

	.SBTTL	MAIL$DELETELINK - DELETE ALL THE LOGICAL LINKS
;++
; FUNCTIONAL DESCRIPTION:
;
;	DELETE ALL THE LOGICAL LINKS IN THE LOGICAL LINK LIST.
;
; CALLING SEQUENCE:
;	CALL MAIL$DELETELINK(LISTHEAD)
;
; INPUT PARAMETERS:
;	NONE
;
; IMPLICIT INPUTS:
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	NONE
;
; COMPLETION CODES:
;	NONE
;
; SIDE EFFECTS:
;	ALL LOGICAL LINKS ARE DELETED AND SLAVE MAIL JOBS ARE STOPPED.
;
;--
	.ENTRY	MAIL$DELETELINK,-	;DELETE ALL THE LOGICAL LINKS
		^M<R2,R3>		;(ENTRY MASK)
	MOVL	4(AP),R3
10$:
	REMQUE	@(R3),R2		;REMOVE NEXT ENTRY
	BVS	20$			;BR IF NONE - ALL DONE
	BSBB	DEALLOC_LNK		;DEALLOCATE THE LINK BLOCK
	BRB	10$			;CHECK FOR ANOTHER
20$:
	RET				;RETURN

;
; DEALLOCATE THE LINK BLOCK AFTER DELETING THE LOGICAL LINK
;
; LINK BLOCK ADDRESS IN R2
;
DEALLOC_LNK:
	BBS	#LNK_V_ALTP,LNK_B_FLAGS(R2),20$ ;BR IF ALTERNATE PROTOCOL
	$DASSGN_S CHAN=LNK_W_CHAN(R2)	;DELETE THE LOGICAL LINK
10$:	MOVZBL	LNK_B_PNLEN(R2),R0	;GET LENGTH OF PROTOCOL NAME
	PUSHAB	LNK_C_LENGTH(R0)	;SET SIZE OF ENTRY TO DEALLOCATE
	PUSHL	R2			;SET ADDR OF ENTRY
	PUSHAL	(SP)			;SET ADDR OF ADDR OF ENTRY
	PUSHAL	8(SP)			;SET ADDR OF SIZE OF ENTRY
	CALLS	#4,G^LIB$FREE_VM	;DEALLOCATE THE LIST ENTRY
	RSB
20$:	MOVL	LNK_L_TFRADR(R2),R0	;WAS ROUTINE OBTAINED?
	BEQL	10$			;IF EQL NO--JUST CONTINUE
	PUSHL	#LNK_C_OUT_DEACCESS	;CODE TO DEACESS
	PUSHAB	LNK_L_CONTEXT(R2)	;CONTEXT ADDRESS
	CALLS	#2,(R0)			;CALL ALTERNATE NET PROTOCOL HANDLER
	BRB	10$			;DEALLOCATE LINK BLOCK

	.END
