{
{ Version:	'V04-002'
{
{****************************************************************************
{*									    *
{*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
{*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
{*  ALL RIGHTS RESERVED.						    *
{* 									    *
{*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
{*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
{*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
{*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
{*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
{*  TRANSFERRED.							    *
{* 									    *
{*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
{*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
{*  CORPORATION.							    *
{* 									    *
{*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
{*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
{* 									    *
{*									    *
{****************************************************************************

{++
{
{ FACILITY:  VAX/VMS System Macro Libraries
{
{ ABSTRACT:
{
{	This file contains the SDL source for all operating system control
{	blocks, from A to E.  That is, all control blocks from AAA to EZZ.
{
{ ENVIRONMENT:
{
{	n/a
{
{--
{
{
{ AUTHOR:  The VMS Group	 CREATION DATE:  1-Aug-1976
{
{ MODIFIED BY:
{
{	V04-002	ACG0467		Andrew C. Goldstein,	12-Sep-1984  17:28
{		Add separate read and write protection check bits to CCB
{
{	V04-001	SRB0145		Steve Beckhardt		9-Sep-1984
{		Moved CDRP$L_VAL9 into regular CDRP out of long CDRP.
{
{	V03-156	RLRBIDEFS4	Robert L. Rappaport	21-Aug-1984
{		Once more another update $BUADEF from even newer, newer specs.
{
{	V03-155	RLRBIDEFS3	Robert L. Rappaport	13-Aug-1984
{		Again update $BUADEF from even newer specs.
{
{	V03-154	RLRBIDEFS2	Robert L. Rappaport	11-Aug-1984
{		Bring $BIICDEF and $BUADEF into line with latest spec.
{
{	V03-153	KDM0106		Kathleen D. Morse	01-Aug-1984
{		Move ICCS back into the cpu-independent registers so that
{		11/730 and MicroVAX I dumps do not lose the bugcheck code,
{		when writing the EMB crash entry.
{
{	V03-152	ROW0396		Ralph O. Weber		22-JUL-1984
{		Add CDRP$V_DENSCK, a class driver flag used to signal that a 
{		tape density check is required.
{
{	V03-151	WMC151		Wayne Cardoza		19-Jul-1984
{		New quorum disk flag for write-locked.
{
{	V03-150	WMC150		Wayne Cardoza		10-Jul-1984
{		Fix a typo.
{
{	V03-149	ROW0378		Ralph O. Weber		 6-JUL-1984
{		Add DYN$C_CD_SHDW_WRK for the class driver shadow set work 
{		buffer.  Add CDDB$V_DAPBYS, a busy flag for the DAP CDRP, and 
{		CDDB$V_2PBSY, a busy flag for failover fork block.
{
{	V03-148	WMC148		Wayne Cardoza		27-Jun-1984
{		Add an error bit to CLUDCBDEF.
{
{	V03-147	DWT0221		David W. Thiel		25-Jun-1984
{		Add CLUFCB$V_WAITING bit to CLUFCB sub-block of CLUB.
{
{	V03-146	ROW0356		Ralph O. Weber		 1-MAY-1984
{		Add CDDB$V_QUORLOST to CDDB$W_STATUS.  This bit will be used 
{		to indicate that disk revalidation is occuring because 
{		connection manager quorum has been lost.
{
{	V03-145	KTA3124		Kerbey T. Altmann	11-Apr-1984
{		Add new DYN codes.
{
{	V03-144	LMP0221		L. Mark Pilant,		7-Apr-1984  12:59
{		Remove the last vestiges of the old CHKPRO interface.  The
{		definition of the CHIP block.
{
{	V03-143	ROW0336		Ralph O. Weber		 7-APR-1984
{		Remove CDDB$L_CONNQ[F/B]L.  Add two more reserved longwords to 
{		the CDDB definition.  Add CDRP$V_IVCMD to CDRP$L_DUTUFLAGS.
{
{	V03-142	KPL0001		Peter Lieberwirth	 6-Apr-1984
{		Add several reserved longwords to the ADP to be used
{		to support volatile BI adapter information.
{
{	V03-141 EMD0073		Ellen M. Dusseault	06-Apr-1984
{		Add new field, CDRP$L_KEYDESC, corresponding to 
{		in the IRP field for the address of a descriptor
{		describing an encryption key.
{
{	V03-140	DWT0209		David W. Thiel		06-Apr-1984
{		Add CLUBPWF substructure to CLUBDEF for use as a
{		fork block during power failures.
{		Add CLUB$V_NO_FORM.  Remove unused fields from
{		CLUB.
{
{	V03-139	RSH0124		R. Scott Hanna		25-Mar-1984
{		Replace $CLUDCBDEF.
{
{	V03-138	SSA0021		Stan Amway		23-Mar-1984
{		Backed out DWT0198, since it is no longer necessary.
{
{	V03-137	DWT0198		David W. Thiel		22-Mar-1984
{		Length CLUB$S_HANG_FKB to make it look more like
{		an IRP.
{
{	V03-136	SRB0117		Steve Beckhardt		22-Mar-1984
{		Added VAL9 and VAL10 to CDRP definitions.
{
{	V03-135	DWT0196		David W. Thiel		21-Mar-1984
{		Remove CDRP$L_BTX, CDRP$K_PART_RESP, CSB$T_SYSTEMID,
{		CSB$W_WAITCNT, CSB$V_QUORUM, CSB$V_TRANSITION,
{		CSB$V_QF_DYNVOTE, CSB$L_MSGS_SENT, CSB$L_MSGS_RCVD.
{		Add CLUB$V_QF_NEWVOTE, CLUB$W_NEWQDVOTES.
{
{	V03-134	ACG0408		Andrew C. Goldstein,	21-Mar-1984  11:22
{		Add ARB$C_HEADER
{
{	V03-133	LMP0214		L. Mark Pilant,		21-Mar-1984  10:02
{		Modify $ARBDEF to remove the temporary SDL hack.
{		Add two new structures: $CHPCTLDEF and CHPRETDEF.  These are
{		used in the new interface to EXE$CHKPRO_INT.
{
{	V03-132	RSH0121		R. Scott Hanna		21-Mar-1984
{		$CLUBDEF / Remove the QF_WRITE flags bit. Rename the
{		QF_SKIP_READ flags bit to QF_FAILED_NODE.
{
{	V03-131 EMD0065		Ellen M. Dusseault	14-Mar-198
{		Move the journal definition in $DYNDEF to the sub-
{		type region where its subtypes are defined. Ensure
{		that the first subtype of a generic function has a
{		value of 1.
{
{	V03-130	JLV0340		Jake VanNoy		 9-MAR-1984
{		Remove BRK$Q_OLDPRIVS, add BRK$T_DEVNAME.
{
{	V03-129	DWT0189		David W. Thiel		9-Mar-1984
{		Add CLUB$L_RETRYCNT.  Add CDRP$K_PART_MAP.  Add
{		CSB$Q_REFTIME.
{
{	V03-128	LMP0206		L. Mark Pilant,		7-Mar-1984  11:53
{		Add additional flags to the CCB status to note that physical
{		and logical I/O access checks have been done.
{
{	V03-127	RLRBIDEFS1	Robert L. Rappaport	5-Mar-1984
{		Correct error in $BUADEF and update $BIICDEF.
{
{	V03-126	CDS0002		Christian D. Saether	28-Feb-1984
{		Add AQB$V_XQIOPROC, AQB$L_BUFCACHE,
{		DYN$C_PGD, DYN$C_PGD_F11BC.
{
{	V03-125	DWT0180		David W. Thiel		27-Feb-1984
{		Add CLUB$V_SHUTDOWN, CLUB$V_QF_DYNVOTE, CLUB$T_QDNAME,
{		CLUB$V_ADJ_QUORUM, CLUB$W_ADJ_QUORUM,
{		CSB$W_WAITCNT, CSB$L_CURRCDRP, CSB$V_SHUTDOWN,
{		CSB$V_QF_DYNVOTE, CSB$W_CNX_STS_R0, CSB$W_CNX_STS_R1.
{
{	V03-124	WHM0004		Bill Matthews		24-feb-1984
{		Remove obsolete field ACF$B_VECTOR.
{		
{	V03-123	SSA0010		Stan Amway		14-Feb-1984
{		Added DYN$C_DCCB to module $DYNDEF.
{
{	V03-122	ROW0298		Ralph O. Weber		10-FEB-1984
{		Define CDRB$W_ENDMSGSIZ, a field in the class driver CDRP 
{		extension which holds the size of the most recent MSCP end 
{		message.
{
{	V03-121	ROW0296		Ralph O. Weber		 6-FEB-1984
{		Add CDDB$V_RSTRTWAIT which when set indicates that a 
{		connection is waiting to execute RESTART_NEXT_CDRP.
{
{	V03-120	WHM0003		Bill Matthews		04-Feb-1984
{		Change field ACF$B_COMBO_VECTOR to ACF$B_VECTOR and added
{		field ACF$B_COMBO_VECTOR_OFFSET	to clean up support for
{		combo style devices.
{
{	V03-119	LMP0185		L. Mark Pilant,		31-Jan-1984  11:02
{		Add CCB$V_PROCHKDON to indicate that a protection check
{		has been completed on the channel (for sharable, non-mountable
{		devices).
{
{	V03-118	ROW0289		Ralph O. Weber		25-JAN-1984
{		Add three DDT dispatch fields for various driver-specific 
{		flavors of mount verification:  DDT$L_MNTV_SQD for sequential 
{		device mount verification, DDT$L_MNTV_FOR for foreign device 
{		mount verification, and DDT$L_MNTV_SSSC for shadow set state 
{		change mount verification.
{
{	V03-117	ROW0280		Ralph O. Weber		14-JAN-1984
{		Rearrange bits in CDRP$L_DUTUFLAGS so that CDRP$M_CAND is the 
{		low-order bit.  This provides for the fastest possible testing 
{		of the bit, which must be tested on every trip through the 
{		mainline code path of the disk class driver.  Add CDRP$M_PERM 
{		and CDRP$M_HIRT to CDRP$L_DUTUFLAGS.  Add CDDB$M_NOCONN to 
{		CDDB$W_STATUS.  Add CDDB$W_WTUCBCTR, a counter of the number 
{		of UCBs waiting for mount verification to complete before 
{		single stream CDRP processing can begin.
{
{	V03-116	WHM0002		Bill Matthews		12-Jan-1984
{		Moved $ACFDEF back into this module since it can be
{		referenced by drivers.
{
{	V03-115	DWT0160		David W. Thiel		11-Jan-1984
{		Rename CSB$Q_TIMEOUT to CSB$L_TIMEOUT.  Remove
{		CSB$L_SPARE% fields.
{
{	V03-114	RSH0090		R. Scott Hanna		11-Jan-1984
{		Add QF_CSP bit to FLAGS longword in $CLUDCBDEF.
{
{	V03-113	ACG0385		Andrew C. Goldstein,	9-Jan-1984  17:04
{		Add $ALFDEF - auto-login file definitions
{
{	V03-112	ROW0275		Ralph O. Weber		 7-JAN-1984
{		Add CDRP$K_PART_RESP, block transfer partner responding, 
{		to connection manager extension in $CDRPDEF.  Add 
{		CDRP$L_DUTUFLAGS and CDRP$W_DUTUCNTR to class driver 
{		extension in $CDRPDEF.
{
{	V03-111	SSA0004		Stan Amway		29-Dec-1983
{		Added DYN$C_PMB and DYN$C_PFB to module $DYNDEF.
{
{	V03-110	WHM001		Bill Matthews		14-Dec-1983	14:12
{		Moved $ACFDEF to BOOTDEF.SDL
{
{	V03-109 LY0440		Larry Yetto		7-DEC-1983 16:12
{		Add DYN$C_JNL_DIOREAD
{
{	V03-018	LMP0177		L. Mark Pilant,		7-Dec-1983  10:06
{		Reduce the size of te local rights list in the ARB.
{		Also, move $ACLDEF to STARDEFAE.SDL.
{
{	V03-107	ACG0376		Andrew C. Goldstein,	5-Dec-1983  13:14
{		Restructure CIA block for breakin detection changes
{
{	V03-106	ROW0263		Ralph O. Weber		24-NOV-1983
{		Add DDB$L_2P_UCB which is equivalent to DDB$L_DP_UCB.  Add 
{		CDDB$V_ALCLS_SET bit which provides a mechanism for limiting 
{		the determination of allocation class for class driver devices 
{		to once.
{
{	V03-105	DWT0151		David W. Thiel		17-Nov-1983
{		Replace CLUB$W_NEWMEMSEQ with CLUB$W_QDVOTES.
{		Add CSB$W_QDVOTES.
{
{	V03-104	SOP0001		J. R. Sopka		11-Nov-1983
{		Change definition of DDB$T_NAME and DDB$T_DRVNAME fields
{		of $DDBDEF to produce DDB$S_NAME and DDB$S_DRVNAME symbols
{		and *_LEN and *_STR symbols for referencing subfields of 
{		these counted ASCII strings.
{
{	V03-103	DWT0146		David W. Thiel		11-Nov-1983
{		$CSBDEF - Add CSB$W_LCKDIRWT to support distribution of
{			lock manager directory over a cluster.
{		$CLUBDEF - Add CLUB$W_MEMSEQ and CLUB$W_NEWMEMSEQ to
{			provide sequence number for cluster membership
{			transitions.
{		$DYNDEF - Add DYN$C_CLU_LCKDIR to identify lock
{			manager directory vector.
{
{	V03-102	RSH0077		R. Scott Hanna		10-Nov-1983
{		$CLUDCBDEF - Change BUF0 and BUF1 sizes. Add FLAGS longword.
{		$CLUBDEF - Remove QF_TRANS and QF_TIMEOUT FLAGS bits. (Moved
{			   to $CLUDCBDEF). Add FMERIT longword.
{
{	V03-101	RLRBIDEFS	Robert L. Rappaport	09-Nov-1983
{		Add $BUADEF, $BIMEMDEF and $BIICDEF.
{
{	V03-100	DWT0142		David W. Thiel		07-Nov-1983
{		Define $CLUOPTDEF structure for maintaining the
{		context needed to perform optimal cluster reconfigurations.
{
{	V03-099	DWT0135		David W. Thiel		05-Oct-1983
{		Add CLUB$V_LOST_CNX bit to $CLUBDEF to more finely
{		sort out states during cluster failover.
{
{	V03-098	KDM0083		Kathleen D. Morse	20-Sep-1983
{		Fix offsets in $EMBCRDEF, which were incorrect due to
{		moving 4 IPRs from the cpu-independent area to the cpu-
{		dependent area.
{
{	V03-097	KDM0082		Kathleen D. Morse	20-Sep-1983
{		Add BTD symbols for QNA and PROM for Micro-VAX booting.
{
{	V03-096	DWT0130		David W. Thiel		15-Sep-1983
{		Add CLUB$V_RECONFIG and CLUB$V_LOSTMSG bits to the
{		CLUB$L_FLAGS field in $CLUBDEF.  Add CLUB$B_HANG_FKB
{		field to $CLUBDEF.
{
{	V03-095	ACG0354		Andrew C. Goldstein,	9-Sep-1983  19:11
{		Remove unused fields from CHIP$ block, rearrange
{		for more efficient access
{
{	V03-094	ROW0215		Ralph O. Weber		25-AUG-1983
{		Add CDDB$B_FOVER_CTR and some reserved fields to the CDDB.
{		Also correct comments on CDDB$W_RSTRTCNT.
{
{	V03-093	RSH0056		R. Scott Hanna		23-Aug-1983
{		Add $CLUDCBDEF. Add DYN$C_CLU_CLUDCB to $DYNDEF.
{
{	V03-092	KDM0073		Kathleen D. Morse	22-Aug-1983
{		Add BQO$L_UMR_TMPL, BQO$B_UMR_DP, BQO$B_CPUTYPE, BQO$L_CPUDATA,
{		BQO$L_TENUSEC, and BQO$L_UBDELAY.
{
{	V03-091	GAS0168		Gerry Smith		22-Aug-1983
{		Add definitions for the Compound Intrusion Analysis block,
{		as well as DYN$C_CIA, to identify the block type.
{
{	V03-090	DWT0120		David W. Thiel		19-Aug-1983
{		Improve use of SDL in $CLUBDEF and $CSBDEF.  Add $CLUBFKB
{		subblock and other fields to $CLUBDEF.
{
{	V03-089	LMP0136		L. Mark Pilant,		9-Aug-1983  13:15
{		Correctly align the protection fields in $CHIPDEF.
{
{	V03-088	CDS0001		Christian D. Saether	2-Aug-1983
{		Remove type definition for obsolete RVX structure.
{
{	V03-087 LY0404		Larry Yetto		2-AUG-1983 14:42:03
{		Add DYN$C_JNL_MSGDATA
{
{	V03-086	DWT0115		David W. Thiel		1-Aug-1983
{		Add CLUB$V_BACKOUT bit to $CLUBDEF.
{
{	V03-085	BLS0231		Benn Schreiber		31-Jul-1983
{		Correct EMBCR definition
{
{	V03-084	DWT0113		David W. Thiel		29-Jul-1983
{		Add quorum disk support to CLUB and CSB.  Add
{		CLUB$V_INIT bit to CLUB to synchronize with SYSINIT.
{
{	V03-083	MLJ0115		Martin L. Jack		29-Jul-1983
{		Add DJI$K_FILE_SPECIFICATION.
{
{	V03-082 LY0402		Larry Yetto		 29-JUL-1983 14:27:42
{		Add DYN$C_JNL_BXSTS
{
{	V03-081	PRB0229		Paul Beck		 29-JUL-1983 13:40
{		Add CLUB$L_CSPFL, CLUB$L_CSPBL, CLUB$L_CSPIPID.
{
{	V03-080	NPK3029		N. Kronenberg		29-Jul-1983
{		Add performance counters to $CDTDEF.
{
{	V03-079	KDM0062		Kathleen D. Morse	28-Jul-1983
{		Move ICCS, ICR, ACCS, and TODR to cpu-dependent registers
{		in $EMBCRDEF.
{
{	V03-078	JLV0276		Jake VanNoy		27-JUL-1983
{		Change CRB$x_TT symbols to CRB$x_DZ.
{
{	V03-077	RLREMB		Robert L. Rappaport	27-Jul-1983
{		Add EMB$C_INVSTS, EMB$C_INVATT, EMB$C_NOUNIT_DG, and
{		EMB$C_LOGMSCP.
{
{	V03-076	JSV0366		Joost Verhofstad	27-JUL-1983
{		Add DYN$C_JNL_MSG
{
{	V03-075 LY0395		Larry Yetto		25-JUL-1983 13:42:30
{		Add DYN$C_JNLWCB and CLUB$L_JNL_FAIL
{
{	V03-074	RNG0074		Rod Gamache		25-Jul-1983
{		Add CXB$Q_STATION overlay to $CXBDEF.
{
{	V03-073	JLV0275		Jake VanNoy		25-JUL-1983
{		Add $BRKTDEF, used by $BRKTHRU and cluster broadcast module.
{		Remove obsolete $BRDDEF.
{
{	V03-072	LMP0125		L. Mark Pilant,		26-Jun-1983  21:35
{		Twiddle the $CHIPDEF structure definition to make the
{		symbol CHIP$L_PROTECTION available in MACRO.
{
{	V03-071	DWT0107		David W. Thiel		23-Jun-1983
{		Correct previous entry.  Remove the CLUB$W_LOCKCNT
{		field and add the CLUB$L_TQE field to $CLUBDEF.
{
{	V03-070	RPG0069		Bob Grosso		23-Jun-1983
{		Add structure type codes for new Known file structures
{		and remove KFI and KFH from DYNDEF.
{
{	V03-069	RLRCDDB1	Robert L. Rappaport	23-Jun-1983
{		Added CDDB$B_DAPCOUNT.
{
{	V03-068	KTA060		Kerbey T. Altmann	23-Jun-1983
{		Added BQO$L_UNIT_DISC and BQO$L_DEVNAME.
{
{	V03-067	ADE0001		Alan D. Eldridge	22-Jun-1983
{		Added CXB$L_END_ACTION, CXB$W_BOFF, CXB$W_BCNT.
{		Removed CXB$W_UQUO, CXB$W_JQUO, CXB$B_ASTCNT CXB$L_SSB and
{		CXB$L_ENDACTION.
{
{	V03-066	ROW0185		Ralph O. Weber		21-JUN-1983
{		Delete CSB$L_SELQFL and CSB$L_SELQBL and replace that queue 
{		header with CSB$L_PARTNERQFL and CSB$L_PARTNERQBL, the queue 
{		header for the queue of active block-transfer partner BTX 
{		blocks.  Add block transfer fields to the connection manager 
{		CDRP extension.   Add NO_JOIN bit in CLUB.
{
{	V03-065	RLRCDDB		Robert L. Rappaport	17-Jun-1983
{		Add CDDB$L_DAPCDRP and CDDB$L_CDDBLINK.
{
{	V03-064	LMP0120		L. Mark Pilant,		16-Jun-1983  10:11
{		Add subfields to the protection vector in the CHIP
{		block.
{
{	V03-063 MKL0095		Mary Kay Lyons		01-Jun-1983
{		Add DYN$C_JNL_RC subtype field for read context structure.
{
{	V03-062	DWT0102		David W. Thiel		27-May-1983
{		Add CLUFCB sub-block and CLUB$L_LOCAL_CSID to $CLUBDEF.
{
{	V03-061	RLRALOCLS	Robert L. Rappaport	26-May-1983
{		Add CDDB$L_ALLOCLS.
{
{	V03-060	RLRDPATH	Robert L. Rappaport	25-May-1983
{		Add DDB$L_DP_UCB, secondary UCB link for dual path
{		controllers.
{
{	V03-059 LY0376		Larry Yetto		24-MAY-1983 16:31:35
{		Add DYN$C_JNL_CWQ subtype field for journal cluster write Q
{		entry.
{
{	V03-058	DWT0100		David W. Thiel		23-May-1983
{		Revise $CLUBDEF and $CSBDEF to support N node clusters.
{
{	V03-057	JSV0294		Joost Verhofstad	20-MAY-1983
{		Add DYN$ subtype values for journaling, add DYN$C_JNL
{		and remove other journaling DYN$ type values
{
{	V03-056	KDM0044		Kathleen D. Morse	 3-May-1983
{		Change EXE$GL_ARCHFLAGS to EXE$GL_ARCHFLAG.
{		Also, add new sub-types for loadable instruction emulation code.
{
{	V03-55	EAD0055		Elliott A. Drayton	 1-May-1983
{		Removed one of two lines which defined CLU_CLUB in $DYNDEF.
{
{	V03-54	DWT0097		David W. Thiel		29-Apr-1983
{		Add pointer to system block to $CSBDEF.
{
{	V03-53	KDM0043		Kathleen D. Morse	29-Apr-1983
{		Add $ARCDEF, architectural bit field definitions for
{		EXE$GL_ARCHFLAGS.
{
{	V03-052	LMP0109		L. Mark Pilant,		29-Apr-1983  12:47
{		Add item to $CHIPDEF for returning the access rights mask.
{
{	V03-051	JLV0246		Jake VanNoy		29-APR-1983
{		Move $BRKDEF to STARLET.
{
{	V03-050	TCM0005		Trudy C. Matthews	28-Apr-1983
{		Add new field to $DDBDEF, DDB$L_ALLOCLS.
{
{	V03-049	SRB0082		Steve Beckhardt		28-Apr-1983
{		Removed message queue from $CDRPDEF
{
{	V03-048	GAS0128		Gerry Smith		28-Apr-1983
{		Add a new type for $DYNDEF, DYN$C_RIGHTSLIST.
{
{	V03-047	MLJ0112		Martin L. Jack,	27-Apr-1983  16:48
{		Add $DJIDEF.
{
{	V03-046	ROW0185		Ralph O. Weber		24-APR-1983
{		Add CLU subtype for the block transfer extension, BTX.
{
{	V03-45	LMP0095		L. Mark Pilant,		14-Apr-1983  16:19
{		Add a hack definition in $CHIPDEF until the new SDL comes along.
{
{	V03-044	ROW0181		Ralph O. Weber		14-APR-1983
{		Add CDRP$L_VAL7 and CDRP$L_VAL8.  Eventually, these fields 
{		should replace currently used fields.  However, the current 
{		fields cannot be deleted yet.  Therefore, the CDRP and the 
{		IRP will be bigger than we want for a few weeks.
{
{	V03-043	MMD0143		Meg Dumont,	14-Apr-1983  9:15
{		Add $EO4DEF, EOF4 definitions.
{
{	V03-42	LMP0099		L. Mark Pilant,		14-Apr-1983  8:32
{		Add return length addr storage to $CHIPDEF.
{
{	V03-041	DWT0094		David W. Thiel		12-Apr-1983
{		More miscellaneous $CLUBDEF and $CSBDEF changes.
{
{	V03-040	TCM0004		Trudy C. Matthews	12-Apr-1983
{		Add error log types EMB$C_EMM (Environmental Monitor logs),
{		EMB$C_HLT (processor error halt logs), and EMB$C_CRBT
{		(console reboot logs) to $EMBETDEF.
{
{	V03-039 LY0350		Larry Yetto		11-APR-1983 07:48:25
{		Remove DYN$C_NTE and replace it with DYN$C_JNLCB
{
{	V03-038	DWT0092		David W. Thiel		6-Apr-1983
{		Add fields to $CSBDEF and $CLUBDEF
{
{	V03-037	DWT0088		David W. Thiel		29-Mar-1983
{		Add fields to $CSBDEF and $CLUBDEF.
{
{	V03-036	JWH0204		Jeffrey W. Horn		24-Mar-1983
{		Add DYN$C_NON_PAGED and DYN$C_PAGED as subtypes of
{		DYN$C_LOADCODE.
{
{	V03-035	LMP0086		L. Mark Pilant,		11-Mar-1983  9:25
{		Longword align the $CHIPDEF structure.
{
{	V03-034	DWT0084		David W. Thiel		10-Mar-1983
{		Add $CLUBDEF to define cluster block.
{
{	V03-033	LMP0084		L. Mark Pilant,		1-Mar-1983  16:05
{		Add $CHIPDEF, the internal interface definition to the
{		$CHKPRO system service.
{
{	V03-032	JLV0235		Jake VanNoy		 1-MAR-1983
{		Add $BRKDEF, for $BRKTHRU system service.
{
{	V03-031	RLRDDBB		Robert L. Rappaport	1-Mar-1983
{		Also added CDDB$L_ORIGUCB, pointer to UCB created by SYSGEN.
{
{	V03-030	RLRDDBA		Robert L. Rappaport	1-Mar-1983
{		Also added CDDB$L_UCBCHAIN to link all UCB's
{		on a connection into a chain.
{
{	V03-029	RLRDDB		Robert L. Rappaport	1-Mar-1983
{		Add DDB$L_CONLINK, (Connection Link) to allow linking
{		of all DDB's that service one Disk or Tape Class Connection.
{
{	V03-028	JLV0232		Jake VanNoy		24-FEB-1983
{		Add CCB$V_IMGTMP flag to allow an image temporary,
{		kernel mode channel.
{
{	V03-027	ROW0162		Ralph O. Weber		23-FEB-1983
{		Add CANCEL type for associated mailbox.  This will be used 
{		when the a mailbox driver's cancel I/O routine is called as 
{		the result of a channel deassign which disassociates a mailbox 
{		causing the mailbox reference count to go to zero.  In this 
{		case the mailbox is about to be deleted and the driver is 
{		required to cleanup preparatory to that event.
{
{	V03-026	DWT0076		David W. Thiel		22-Feb-1983
{		Add DYN$C_CLU as the major type for all cluster 
{		related control blocks.  Make CSB to be a subtype.
{		Add fields to $CSBDEF.
{		Add DYN$C_SCS_SPNB to $DYNDEF.
{
{	V03-025	DWT0075		David W. Thiel		11-Feb-1983
{		Correct previous entry.  Add fields to $CSBDEF.
{
{	V03-024	DWT0066		David W. Thiel		20-Jan-1983
{		Add DYN$C_SCS_SPPB control block subtype.
{
{	V03-023	MIR0022		Michael I. Rosenblum	19-Jan-1983
{		Move TTDRIVER local CRB and IDB definitions into
{		the main definitions.
{
{	V03-022	ROW0156		Ralph O. Weber		12-JAN-1983
{		Remove hard coded filler offsets in IRP to be symbolic.  
{		Reorder connection manager extension to CDRP so that the VAL1 
{		through VAL6 fields overlay the fields in the block transfer 
{		CDRP extension.  Add DYN$C_NTE for journaling memory-format 
{		name table entries which will be produced on slave nodes.
{
{	V03-021	SRB0060		Steve Beckhardt		7-Jan-1983
{		Added some new data structure definitions in $DYNDEF.
{		Added $CSBDEF (Cluster System Blocks).  Added connection
{		manager extension to $CDRPDEF.
{
{	V03-020	WMC0020		Wayne Cardoza		05-JAN-1982
{		New machine check error codes in EMBETDEF.
{
{	V03-019	KTA3026		Kerbey T. Altmann	03-Jan-1983
{		Add GETDONE flag to $ACFDEF.
{
{	V03-018	ACG0307		Andrew C. Goldstein,	30-Dec-1982  17:11
{		Add rights list to ARB
{
{	V03-017	ACG0303		Andrew C. Goldstein,	9-Dec-1982  15:11
{		Add FILL attribute to extraneous field names
{
{	V03-016	DMW4015		DMWalp			9-Dec-1982
{		Added DYN structure type for LNM blocks
{
{	V03-015	MLJ0101		Martin L. Jack,	17-Nov-1982  13:56
{		Fix AVECTOR definition.
{
{	V03-014	KTA3019		Kerbey T. Altmann	08-Nov-1982
{		Add new field to DDB for system block address.
{
{	V03-013	TCM0003		Trudy C. Matthews	29-Oct-1982
{		Move definition of ADP$L_AVECTOR (see TCM0002) into
{		common portion of ADP structure.  Add $CONDEF, which
{		defines console function codes.
{
{	V03-012	RLRPOLL		Robert L. Rappaport	8-Oct-1982
{		Add CDDB$M_POLLING bit to CDDB$W_STATUS.
{
{	V03-011	ROW0131		Ralph O. Weber		 7-OCT-1982
{		Increment DPT$C_VERSION to indicate significant change in 
{		driver data structures.  This will cause SYSGEN to abort, with 
{		an error message, attempts to load V3.x drivers on post X1NR 
{		systems and vice versa.
{
{	V03-010	ROW0125		Ralph O. Weber		19-SEP-1982
{		Add DDT$L_CLONEDUCB to driver entry points listed in $DDTDEF, 
{		the offset deffinitions for the driver dispatch table.
{
{	V03-009	TCM0002		Trudy C. Matthews	10-Aug-1982
{		Add new field ADP$L_AVECTOR, the address of the 1st SCB
{		vector for this adaptor, to $ADPDEF
{
{	V03-008	LMP0036		L. Mark Pilant,		29-Jun-1982  13:00
{		Add the Access Control List (ACL) data structure.  Also,
{		add the DYN$C_ACL data structure type code.
{
{	V03-007 LY0026		Larry Yetto		29-Jun-1982
{		Add DYN$C_NDL to data structure type definitions
{
{	V03-006	TMH0006		Tim Halvorsen		14-Jun-1982
{		Add WQE and XWB structure codes for DECnet.
{
{	V03-005	JSV007		Joost Verhofstad	10-Jun-1982
{		Add DYN$C_ADL, DYN$C_JNL_BUF, DYN$C_VCL
{
{	V03-004	RLRV3A3		Robert L. Rappaport	15-Apr-1982
{		Add EMB$C_ACPTH to log Attention messages.
{
{	V03-003	RLRV3A2		Robert L. Rappaport	6-Apr-1982
{		Add EMB$C_AVATN, EMB$C_DUPUN so as to log Attention
{		messages from MSCP controllers. Also add EMB$C_IVCMD.
{
{	V03-002	KTA0090		Kerbey T. Altmann	29-Mar-1982
{		Add new field to BOOT QIO vector for microcode address.
{
{	V03-001	RLRV3A1		Robert L. Rappaport	23-Mar-1982
{		Add two state bits to CDDB definition and add field
{		to EMBSPDEF (Error Log Software Parameter block).
{
{**

module $ACMDEF;
/*+
/* ACMDEF - ACCOUNTING MANAGER DEFINITIONS
/*-



aggregate ACMDEF  union prefix ACM$;
    ACMDEF_BITS structure fill;
        PROCESS bitfield;				/* PROCESS ACCOUNTING ENABLED 
        IMAGE bitfield;					/* IMAGE ACCOUNTING ENABLED 
        INTERACTIVE bitfield;				/* INTERACTIVE ACCOUNTING ENABLED 
        LOGFAIL bitfield;				/* LOGIN FAILURE ACCOUNTING ENABLED 
        SUBPROCESS bitfield;				/* SUBPROCESS ACCOUNTING ENABLED 
        DETACHED bitfield;				/* DETACHED PROCESS ACCOUNTING ENABLED 
        BATCH bitfield;					/* BATCH ACCOUNTING ENABLED 
        NETWORK bitfield;				/* NETWORK PROCESS ACCOUNTING ENABLED 
        PRINT bitfield;					/* PRINT JOB ACCOUNTING ENABLED 
        USER_DATA bitfield;				/* USER_DATA ACCOUNTING ENABLED 
        ACM_FUNC bitfield;				/* ACM FUNCTION ACCOUNTING ENABLED 
        SYS_FUNC bitfield;				/* SYSTEM FUNCTION ACCOUNTING ENABLED 
    end ACMDEF_BITS;
    
end ACMDEF;

    aggregate ACMDEF1 structure prefix ACM$ origin TYPE;
    MSGSTS word unsigned;				/* MSG STATUS IN MAILBOX IOSB (JOBCTL SPECIFIC) 
    MSGLEN word unsigned;				/* MSG LENGTH IN MAILBOX IOSB (JOBCTL SPECIFIC) 
    PROCID longword unsigned;				/* PROCESS ID IN MAILBOX IOSB (JOBCTL SPECIFIC) 
    TYPE word unsigned;					/* MESSAGE TYPE 
    MAILBOX word unsigned;				/* MAILBOX UNIT NUMBER 
    PRVMSK quadword unsigned;				/* PROCESS PRIV MASK 
    UIC_OVERLAY union fill;
        UIC longword unsigned;				/* PROCESS UIC 
	UIC_FIELDS structure fill;
            MEM word unsigned;				/* MEMBER UIC 
            GRP word unsigned;				/* GROUP UIC 
	end UIC_FIELDS;
    end UIC_OVERLAY;
    USERNAME character length 12;			/* USERNAME 
    ACCOUNT character length 8;				/* ACCOUNT NAME 
    PROCPRI byte unsigned;				/* PROCESS BASE PRIORITY 
    FILL_1 byte dimension 3 fill prefix ACMDEF tag $$;	/* SPARE BYTES (LONGWORD ALIGNMENT) 
    PID longword unsigned;				/* PROCESS ID 
    STS longword unsigned;				/* PROCESS STATUS 
    OWNER longword unsigned;				/* OWNER PROCESS ID (0 => NONE) 
    TERMINAL character length 8;			/* TERMINAL NAME (COUNTED ASCII STRING) 
    SYSTIME quadword unsigned;				/* CURRENT SYSTEM TIME 
/*
/* SEND TO ACCOUNTING MANAGER FIELDS
/*
    end ACMDEF1;

aggregate ACMDEF2 structure prefix ACM$;
    FILL_2 byte dimension 68 fill prefix ACMDEF tag $$;
    USERREQ word unsigned;				/* USER REQUEST TYPE 
    DATA character length 256;				/* USER DATA 
/*
/* PROCESS/IMAGE DELETE/PURGE FIELDS
/*
end ACMDEF2;

aggregate ACMDEF3 structure prefix ACM$;
    FILL_3 byte dimension 68 fill prefix ACMDEF tag $$;
    LOGIN quadword unsigned;				/* PROCESS/IMAGE START TIME 
    FINALSTS longword unsigned;				/* PROCESS FINAL STATUS 
    IMGCNT longword unsigned;				/* IMAGE EXECUTION COUNT 
    CPUTIME longword unsigned;				/* CPU USAGE 
    PAGEFLTS longword unsigned;				/* PAGEFAULT COUNT 
    PGFLTIO longword unsigned;				/* PAGEFAULT I/O 
    WSPEAK longword unsigned;				/* WORKING SET PEAK 
    PGFLPEAK longword unsigned;				/* PAGE FILE PEAK 
    DIOCNT longword unsigned;				/* DIRECT I/O COUNT 
    BIOCNT longword unsigned;				/* BUFFERED I/O COUNT 
    VOLUMES longword unsigned;				/* VOLUME MOUNT COUNT 
    NODEADDR word unsigned;				/* MESSAGE OFFSET TO REMOTE NODE ADDRESS 
    NODENAME word unsigned;				/* MESSAGE OFFSET TO REMOTE NODE NAME 
    REMOTEID word unsigned;				/* MESSAGE OFFSET TO REMOTE ID 
    IMAGENAME word unsigned;				/* MESSAGE OFFSET TO IMAGE NAME 
    constant PROCLEN equals . prefix ACM$ tag K;	/* MIN. PROCESS/IMAGE TERMINATION MESSAGE LENGTH 
    constant PROCLEN equals . prefix ACM$ tag C;	/* MIN. PROCESS/IMAGE TERMINATION MESSAGE LENGTH 
end ACMDEF3;

end_module $ACMDEF;


module $ACBDEF;
/*+
/* AST CONTROL BLOCK DEFINITIONS
/*
/* AST CONTROL BLOCKS EXIST AS SEPARATE STRUCTURES AND AS SUBSTRUCTURES
/* WITHIN LARGER CONTROL BLOCKS SUCH AS I/O REQUEST PACKETS AND TIMER
/* QUEUE ENTRIES.
/*
/*-



aggregate ACBDEF structure prefix ACB$;
    ASTQFL longword unsigned;				/*AST QUEUE FORWARD LINK 
    ASTQBL longword unsigned;				/*AST QUEUE BACKWARD LINK 
    SIZE word unsigned;					/*STRUCTURE SIZE IN BYTES 
    TYPE byte unsigned;					/*STRUCTURE TYPE CODE 
    RMOD_OVERLAY union fill;
        RMOD byte unsigned;				/*REQUEST ACCESS MODE 
	RMOD_BITS structure fill;
            MODE bitfield length 2;			/*MODE FOR FINAL DELIVERY 
            FILL_1 bitfield length 2 fill prefix ACBDEF tag $$;/*SPARE 
            PKAST bitfield mask;			/*PIGGY BACK SPECIAL KERNEL AST 
            NODELETE bitfield mask;			/*DON'T DELETE ACB ON DELIVERY 
            QUOTA bitfield mask;			/*ACCOUNT FOR QUOTA 
            KAST bitfield mask;				/*SPECIAL KERNEL AST 
	end RMOD_BITS;
    end RMOD_OVERLAY;
    PID longword unsigned;				/*PROCESS ID OF REQUEST 
    AST longword unsigned;				/*AST ROUTINE ADDRESS 
    ASTPRM longword unsigned;				/*AST PARAMETER 
    KAST longword unsigned;				/*INTERNAL KERNEL MODE XFER ADDRESS 
    constant "LENGTH" equals . prefix ACB$ tag K;	/* Length of block. 
    constant "LENGTH" equals . prefix ACB$ tag C;	/* Length of block. 
    
end ACBDEF;

end_module $ACBDEF;

module $ACFDEF;
/*
/* CONFIGURATION CONTROL BLOCK OFFSET DEFINITIONS
/*



aggregate ACFDEF structure prefix ACF$;
    ADAPTER longword unsigned;				/*ADDRESS OF ADAPTER CONTROL BLOCK 
    CONFIGREG longword unsigned;			/*ADDRESS OF CONFIGURATION STATUS REGISTER 
    AVECTOR word unsigned;				/*OFFSET TO ADAPTER INTERRUPT VECTOR (SCB) 
    AUNIT byte unsigned;				/*ADAPTER UNIT NUMBER 
    AFLAG_OVERLAY union fill;
        AFLAG byte unsigned;				/*ADAPTER GENERATION CONTROL FLAGS 
	AFLAG_BITS structure fill;
            RELOAD bitfield mask;			/* RELOAD DRIVER 
            CRBBLT bitfield mask;			/* CRB AND IDB ARE BUILT 
            SCBVEC bitfield mask;			/* CVECTOR IS OFFSET INTO SCB 
            NOLOAD_DB bitfield mask;			/* DON'T LOAD DATABASE, ONLY LOAD DRIVER 
            SUPPORT bitfield mask;			/* DEVICE IS SUPPORTED 
	    GETDONE bitfield mask;			/* GET OF IO DATABASE ALREADY DONE
	end AFLAG_BITS;
    end AFLAG_OVERLAY;
    CONTRLREG longword unsigned;			/*ADDRESS OF CONTROL REGISTER 
    CVECTOR word unsigned;				/*OFFSET TO CONTROLLER INTERRUPT VECTOR (TABLE) 
    CUNIT word unsigned;				/*CONTROLLER UNIT NUMBER 
    DEVNAME longword unsigned;				/*ADDRESS OF DEVICE NAME COUNTED STRING 
    DRVNAME longword unsigned;				/*ADDRESS OF DRIVER NAME COUNTED STRING 
    MAXUNITS word unsigned;				/*MAXIMUM UNITS THAT CAN BE CONNECTED 
    CNUMVEC byte unsigned;				/*NUMBER OF CONTROLLER VECTORS 
    COMBO_VECTOR_OFFSET byte;				/*OFFSET TO START OF VECTORS FOR A COMBO STYLE DEVICE
    COMBO_CSR_OFFSET byte;				/*OFFSET TO START OF CONTROL REGISTERS FOR A COMBO DEVICE
    NUMUNIT byte unsigned;				/*NUMBER OF UNITS TO CONFIGURE 
    FILL_1 word fill prefix ACFDEF tag $$;		/*(SPARE) 
    DLVR_SCRH longword unsigned;			/*SCRATCH FOR DELIVER ROUTINES 
    constant "LENGTH" equals . prefix ACF$ tag K;	/*LENGTH OF DEVICE DESCRIPTOR ARGUMENT LIST 
    constant "LENGTH" equals . prefix ACF$ tag C;	/*LENGTH OF DEVICE DESCRIPTOR ARGUMENT LIST 
    
end ACFDEF;

end_module $ACFDEF;

module $ADPDEF;

/*+
/* ADAPTER CONTROL BLOCK DEFINITIONS
/*
/* THERE IS ONE ADP FOR EACH SYSTEM INTERCONNECT ADAPTER THAT IS
/* USED FOR ANY TYPE OF I/O.  FOR EXAMPLE: MASBUSS ADAPTER, UNIBUS
/* ADAPTER.  THERE IS NO ADAPTER CONTROL BLOCK FOR MAIN MEMORY ADAPTERS.
/*-



aggregate ADPDEF structure prefix ADP$;
    CSR longword unsigned;				/*ADAPTER CONFIGURATION STATUS REGISTER ADDRESS 
    LINK longword unsigned;				/*ADDRESS OF NEXT ADAPTER CONTROL BLOCK 
    SIZE word unsigned;					/*STRUCTURE SIZE IN BYTES 
    TYPE byte unsigned;					/*STRUCTURE TYPE CODE 
    NUMBER byte unsigned;				/*ORDINAL ADAPTER NUMBER 
    TR word unsigned;					/*CONFIGURATION TR NUMBER 
    ADPTYPE word unsigned;				/*SOFTWARE ADAPTER TYPE 
    VECTOR_OVERLAY union fill;
        VECTOR longword unsigned;			/*UBA - ADDRESS OF VECTOR JUMP TABLE 
        CRB longword unsigned;				/*MBA OR DR32 - ADDRESS OF ADAPTER'S CRB 
    end VECTOR_OVERLAY;
    DPQFL_OVERLAY union fill;
        DPQFL longword unsigned;			/*UBA - DATAPATH WAIT QUEUE FORWARD LINK 
	PRQQFL_OVERLAY union fill;
            PRQQFL longword unsigned;			/*MPM - INTER-PROCESSOR REQUEST WAIT QUEUE FLINK 
            MBASCB longword unsigned;			/*MBA - SCB VECTOR VALUE FOR MBA NEXUS 
	end PRQQFL_OVERLAY;
    end DPQFL_OVERLAY;
    DPQBL_OVERLAY union fill;
        DPQBL longword unsigned;			/*UBA - DATAPATH WAIT QUEUE BACKWARD LINK 
	PRQQBL_OVERLAY union fill;
            PRQQBL longword unsigned;			/*MPM - INTER-PROCESSOR REQUEST WAIT QUEUE BLINK 
            MBASPTE longword unsigned;			/*MBA - SPTE VALUE WHICH MAPS MBA ADDRESS SPACE 
	end PRQQBL_OVERLAY;
    end DPQBL_OVERLAY;
    AVECTOR longword unsigned;				/* ADDR OF 1ST SCB VECTOR FOR THIS ADAPTOR
    BI_ONLY longword unsigned dimension 4;		/*BI ADAPTER VOLATILE INFO
    constant MBAADPLEN equals . prefix ADP$ tag K;	/*LENGTH OF ADP FOR MASSBUS ADAPTER 
    constant MBAADPLEN equals . prefix ADP$ tag C;	/*LENGTH OF ADP FOR MASSBUS ADAPTER 
    constant DRADPLEN equals . prefix ADP$ tag K;	/*LENGTH OF ADP FOR DR32 
    constant DRADPLEN equals . prefix ADP$ tag C;	/*LENGTH OF ADP FOR DR32 
    constant CIADPLEN equals . prefix ADP$ tag K;	/*LENGTH OF ADP FOR CI 
    constant CIADPLEN equals . prefix ADP$ tag C;	/*LENGTH OF ADP FOR CI 
    MRQFL_OVERLAY union fill;
        MRQFL longword unsigned;			/*UBA - MAP REGISTER WAIT QUEUE FORWARD LINK 
        SHB longword unsigned;				/*MPM - SHARED MEMORY CONTROL BLOCK ADDR 
    end MRQFL_OVERLAY;
    MRQBL_OVERLAY union fill;
        MRQBL longword unsigned;			/*UBA - MAP REGISTER WAIT QUEUE BACKWARD LINK 
        PORT byte unsigned;				/*MPM - PORT NUMBER 
    end MRQBL_OVERLAY;
    INTD longword unsigned dimension 3;			/*UBA - INTERRUPT TRANSFER VECTOR 
    constant MPMADPLEN equals . prefix ADP$ tag K;	/*LENGTH OF ADP FOR MULTI-PORT MEMORY 
    constant MPMADPLEN equals . prefix ADP$ tag C;	/*LENGTH OF ADP FOR MULTI-PORT MEMORY 
    UBASCB longword unsigned dimension 4;		/*UBA - SCB VECTOR VALUE FOR 4 UBA VECTORS 
    UBASPTE longword unsigned dimension 2;		/*UBA - SPTE VALUES FOR MAPPING UBA ADDRESSES 
    MRACTMDRS longword unsigned;			/* UBA - ! active map register descriptors 
    DPBITMAP word unsigned;				/* UBA - Datapath Allocation Bitmap 
    MRNFENCE word unsigned;				/* Fence preceeding array. Init'ed to -1 
    MRNREGARY word unsigned dimension 124;		/* ! map regs in an extent array 
    MRFFENCE word unsigned;				/* Fence precedding array. Init'ed to -1 
    MRFREGARY word unsigned dimension 124;		/* 1st reg in extent array. 
    UMR_DIS word unsigned;				/* Num of Map Registers to disable 
                                            		/* NOTE** - UNIBUS ADP must be integral
                                            		/*  number of longwords long so that 780
                                            		/*  interrupt vectors are longword aligned.
    constant UBAADPLEN equals . prefix ADP$ tag K;	/*LENGTH OF ADP FOR UNIBUS ADAPTER 
    constant UBAADPLEN equals . prefix ADP$ tag C;	/*LENGTH OF ADP FOR UNIBUS ADAPTER 
    constant NUMDATAP	equals 16  prefix ADP tag $C;	/*UBA - NUMBER OF DATAPATHS 
    
end ADPDEF;

end_module $ADPDEF;


module $AIBDEF;
/*+
/* FORMAT OF ACP I/O BUFFER PACKET. THIS PACKET CONTAINS ALL THE DATA
/* TRANSMITTED FROM THE USER TO THE ACP AND BACK FOR AN ACP FUNCTION.
/* NOTE THAT THE DESCRIPTORS IN THE PACKET ARE TREATED BY BLISS CODE
/* AS A BLOCKVECTOR.
/*-



aggregate AIBDEF structure prefix AIB$;
    DESCRIPT longword unsigned;				/* ADDRESS OF START OF DESCRIPTORS 
    FILL_1 longword fill prefix AIBDEF tag $$;		/* SPARE LONGWORD 
    SIZE word unsigned;					/* SIZE OF PACKET 
    TYPE byte unsigned;					/* PACKET TYPE CODE 
    FILL_2 byte fill prefix AIBDEF tag $$;		/* SPARE 
    constant "LENGTH" equals . prefix AIB$ tag K;	/* LENGTH OF PACKET HEADER 
    constant "LENGTH" equals . prefix AIB$ tag C;	/* LENGTH OF PACKET HEADER 
    
end AIBDEF;

end_module $AIBDEF;


module $ABDDEF;



aggregate ABDDEF structure prefix ABD$;
    TEXT word unsigned;					/* WORD OFFSET TO DATA TEXT 
    COUNT word unsigned;				/* BYTE COUNT OF TEXT 
    USERVA longword unsigned;				/* USER VIRTUAL ADDRESS OF TEXT 
    constant "LENGTH" equals . prefix ABD$ tag K;	/* SIZE OF DESCRIPTOR 
    constant "LENGTH" equals . prefix ABD$ tag C;	/* SIZE OF DESCRIPTOR 
    constant WINDOW	equals 0  prefix ABD tag $C;	/* DESCRIPTOR FOR WINDOW ADDRESS 
    constant FIB	equals 1  prefix ABD tag $C;	/* DESCRIPTOR FOR FIB 
    constant NAME	equals 2  prefix ABD tag $C;	/* DESCRIPTOR FOR NAME STRING 
    constant RESL	equals 3  prefix ABD tag $C;	/* DESCRIPTOR FOR RESULT LENGTH 
    constant RES	equals 4  prefix ABD tag $C;	/* DESCRIPTOR FOR RESULT STRING 
    constant ATTRIB	equals 5  prefix ABD tag $C;	/* FIRST ATTRIBUTE DESCRIPTOR 
    
end ABDDEF;

end_module $ABDDEF;


module $ALFDEF;
/*+
/*
/* $ALFDEF - structure for auto-login file.
/*
/*-


aggregate ALFDEF structure prefix ALF$;
    DEVNAME character length 63;		/* Terminal device name
    USERNAME character length 32;		/* Associated username
    FILL_1 byte dimension 33 fill;
    constant "LENGTH" equals . tag C;
    constant "LENGTH" equals . tag K;
end ALFDEF;

end_module $ALFDEF;

module $AQBDEF;
/*+
/* DEFINITION OF ACP QUEUE HEADER
/*-



aggregate AQBDEF structure prefix AQB$;
    ACPQFL longword unsigned;				/* QUEUE FORWARD LINK 
    ACPQBL longword unsigned;				/* QUEUE BACK LINK 
    SIZE word unsigned;					/* CONTROL BLOCK SIZE IN BYTES 
    TYPE byte unsigned;					/* BLOCK TYPE CODE 
    MNTCNT byte unsigned;				/* ACP MOUNT COUNT 
    ACPPID longword unsigned;				/* ACP PROCESS PID 
    LINK longword unsigned;				/* AQB LIST LINKAGE 
    STATUS_OVERLAY union fill;
        STATUS byte unsigned;				/* STATUS BYTE 
	STATUS_BITS structure fill;
            UNIQUE bitfield mask;			/* ACP IS UNIQUE TO THIS DEVICE 
            DEFCLASS bitfield mask;			/* ACP IS DEFAULT FOR THIS CLASS 
            DEFSYS bitfield mask;			/* ACP IS DEFAULT FOR THE SYSTEM 
            CREATING bitfield mask;			/* ACP IS CURRENTLY BEING CREATED 
	    XQIOPROC bitfield mask;			/* eXtended QIO PROCessor is being used.
	end STATUS_BITS;
    end STATUS_OVERLAY;
    ACPTYPE byte unsigned;				/* ACP TYPE CODE 
/*
/* ***** The following ACP type codes are now a user visible interface
/* ***** and the values may not be changed.  There are parallel definitions
/* ***** in the $DVIDEF macro that define symbols of the form:
/* *****
/* *****                DVI$C_ACP_F11V1
/* *****                DVI$C_ACP_F11V2
/* *****                DVI$C_ACP_MTA
/* *****                ...
/* *****
/* ***** All new ACP type values must be added at the end and the names
/* ***** must be 5 characters or less to keep the DVI form of the name
/* ***** 15 characters or less.  Any additions must also be made in $DVIDEF
/* ***** and in the list of ASSUMES in the module SYSGETDEV in [SYS.SRC]
/*
    constant(
          UNDEFINED					/* UNDEFINED ACP 
        , F11V1						/* FILES-11 STRUCTURE LEVEL 1 
        , F11V2						/* FILES-11 STRUCTURE LEVEL 2 
        , MTA						/* MAGTAPE 
        , NET						/* NETWORKS 
        , REM						/* REMOTE I/O 
        , JNL						/* JOURNAL 
    
        ) equals 0 increment 1  prefix AQB tag $K;
    CLASS byte unsigned;				/* ACP CLASS CODE 
    FILL_1 byte fill prefix AQBDEF tag $$;		/* RESERVED 
    BUFCACHE longword unsigned;				/* POINTER TO BUFFER CACHE
    constant "LENGTH" equals . prefix AQB$ tag K;	/* SIZE OF AQB 
    constant "LENGTH" equals . prefix AQB$ tag C;	/* SIZE OF AQB 
    
end AQBDEF;

end_module $AQBDEF;


module $ARBDEF;
/*+
/*
/* Access Rights Block - structure defining process access rights and
/* privileges. Currently part of the PCB (meaning that the size of the
/* ARB declared here must track in the PCB).
/*
/*-

aggregate ARBDEF structure prefix ARB$;
    PRIV quadword unsigned;		/* Privilege mask 
    FILL_1 longword fill tag $$;	/* Spare to allow for JIB type,size 
    CLASS structure;			/* Security classification mask
	FILL_2 longword dimension 5 fill tag $$;
    end CLASS;
    RIGHTSLIST longword unsigned dimension 4; /* Rights list descriptors
    constant HEADER equals . prefix ARB$ tag C; /* Length of header
    constant HEADER equals . prefix ARB$ tag K; /* Length of header
    RIGHTSDESC structure;		/* Descriptor for local rights list
	FILL_3 longword dimension 2 fill tag $$;
    end RIGHTSDESC;
    LOCALRIGHTS structure;		/* Process local rights list
	UIC longword unsigned;		/* User identification code. 
	FILL_4 longword dimension 15 fill tag $$;
    end LOCALRIGHTS;
    constant "LENGTH" equals . prefix ARB$ tag K;	/* Structure length 
    constant "LENGTH" equals . prefix ARB$ tag C;	/* Structure length 
end ARBDEF;

end_module $ARBDEF;


module $ARCDEF;

/*+
/*
/* Bit definitions for EXE$GL_ARCHFLAG - flags for VAX architecture differences
/*
/*-


aggregate ARCDEF  union prefix ARC$;
    ARCDEF_BITS structure;
        FILL_1 bitfield length 4 fill prefix ARCDEF tag $$;/*
        CHAR_EMUL bitfield mask;			/* Char Str Ins Emul 
        DCML_EMUL bitfield mask;			/* Decimal String Emul
        EDPC_EMUL bitfield mask;			/* EDITPC Instr Emul 
        CRC_EMUL bitfield mask;				/* CRC Instr Emul
        DFLT_EMUL bitfield mask;			/* D-flt Data Type Emul
        FFLT_EMUL bitfield mask;			/* F-flt Data Type Emul
        GFLT_EMUL bitfield mask;			/* G-flt Data Type Emul
        HFLT_EMUL bitfield mask;			/* H-flt Data Type Emul
        FILL_2 bitfield length 20 fill prefix ARCDEF tag $$;/* 
    end ARCDEF_BITS;
end ARCDEF;

end_module $ARCDEF;


module $BBSDEF;
/*+
/*
/* Structure of message from disk ACP to bad block scan utility.
/*
/*-



aggregate BBSDEF structure prefix BBS$;
    MSGTYPE byte unsigned;				/* message type code (MSG$C_SCANBAD) 
    FILL_1 byte dimension 3 fill prefix BBSDEF tag $$;	/* unused 
    SEQUENCE word unsigned;				/* message sequence number 
    FILL_2 word fill prefix BBSDEF tag $$;		/* unused 
    UCB longword unsigned;				/* UCB address of device 
    FID word unsigned dimension 3;			/* file ID of file 
    constant "LENGTH" equals . prefix BBS$ tag K;
    constant "LENGTH" equals . prefix BBS$ tag C;
    
end BBSDEF;

end_module $BBSDEF;


module $BIICDEF;
/*+
/* BI Interface Chip Register Offset Definitions
/*-

aggregate BIICDEF structure prefix BIIC$;

/*+
/* BI Required Registers
/*-

    DTREG_OVERLAY union fill;
	DTREG longword unsigned;		/*Device Type Register
	DEVTYPE_FIELD_OVERLAY union fill;
	    DEVTYPE word unsigned;		/* Device Type Field
	    DEVTYPE_BITS structure fill;
		FILL_1  bitfield length 8 fill prefix BIICDEF tag $$;
						/* Lo order devtype bits
		MEMNODE bitfield length 7;	/* If zero, then memory
		NONDEC  bitfield mask;		/* If set, non-DEC node
	    	REVCODE word unsigned;		/* Revision code
	    end DEVTYPE_BITS;
	end DEVTYPE_FIELD_OVERLAY;
    end DTREG_OVERLAY;

    BICSR_OVERLAY union fill;
	BICSR longword unsigned;		/*BI Control/Status Register
	BICSR_BITS structure fill;
	    NODE_ID  bitfield length 4;		/* Node ID
	    ARBCNTL  bitfield length 2;		/* Arbitration Control
	    SEIE     bitfield mask;		/* Soft Error interrupt enable
	    HEIE     bitfield mask;		/* Hard Error interrupt enable
	    UWP      bitfield mask;		/* Unlock Write Pending
	    FILL_2   bitfield length 1 fill prefix BIICDEF tag $$;
	    SST      bitfield mask;		/* Start Self test
	    STS      bitfield mask;		/* Self test Status
	    BROKE    bitfield mask;		/* Broke bit
	    INIT     bitfield mask;		/* Init bit
	    SES      bitfield mask;		/* Soft error summary
	    HES      bitfield mask;		/* Hard error summary
	    BIICTYPE bitfield length 8;		/* BIIC type
	    BIICREVN bitfield length 8;		/* BIIC Revision Number
	end BICSR_BITS;
    end BICSR_OVERLAY;

    BER_OVERLAY union fill;	
	BER longword unsigned;			/*Bus Error Register
	BER_BITS structure fill;
	    NPE      bitfield mask;		/* Null Bus Parity Error
	    CRD      bitfield mask;		/* Corrected Read Data
	    IPE      bitfield mask;		/* ID Parity Error
	    UPEN     bitfield mask;		/* User Parity Enabled
	    FILL_3   bitfield length 12 fill prefix BIICDEF tag $$;
	    ICE      bitfield mask;		/* Illegal Confirmation Error
	    NEX      bitfield mask;		/* Non-existent Address
	    BTO      bitfield mask;		/* Bus Timeout
	    STO      bitfield mask;		/* Stall Timeout
	    RTO      bitfield mask;		/* Retry Timeout
	    RDS      bitfield mask;		/* Read Data Substitute
	    SPE      bitfield mask;		/* Slave Parity Error
	    CPE      bitfield mask;		/* Command Parity Error
	    IVE      bitfield mask;		/* IDENT Vector Error
	    TDF      bitfield mask;		/* Transmitter During Fault
	    ISE      bitfield mask;		/* Interlock Sequence Error
	    MPE      bitfield mask;		/* Master Parity Error
	    CTE      bitfield mask;		/* Control Transmit Error
	    MTCE     bitfield mask;		/* Master Transmit Check Error
	    NMR      bitfield mask;		/* No Ack to Multi-Responder Command
	end BER_BITS;
    end BER_OVERLAY;

    EICR_OVERLAY union fill;
	EICR longword unsigned;			/*Error Interrupt Control Register
	EICR_BITS structure fill;
	    FILL_4   bitfield length 2 fill prefix BIICDEF tag $$;
	    EIVECTOR bitfield length 12;	/* Vector
	    FILL_5   bitfield length 2 fill prefix BIICDEF tag $$;
	    LEVEL    bitfield length 4;		/* Interrupt Level
	    EIFORCE  bitfield mask;		/* Force
	    EISENT   bitfield mask;		/* INTR command sent
	    FILL_6   bitfield length 1 fill prefix BIICDEF tag $$;
	    EIINTC   bitfield mask;		/* Interrupt Complete
	    EIINTAB  bitfield mask;		/* Interrupt Abort
	end EICR_BITS;
    end EICR_OVERLAY;

    IDR longword unsigned;			/* Interrupt Destination
						/*  decoded ID in Lo order
/*+
/* BIIC Specific Device Registers
/*-

    IPIMR longword unsigned;			/* IP Interrupt Mask
						/*  decoded ID in Hi order

    IPIDR longword unsigned;			/* IP Interrupt Destination
						/*  decoded ID in Lo order

    IPISR longword unsigned;			/* IP Interrupt Source
						/*  decoded ID in Hi order

						/*Note: following two
						/* registers have lo order
						/* 18 bits MBZ. This means
						/* memories are multiples
						/* of 256KB.
    SAR   longword unsigned;			/* Starting Address Register
    EAR   longword unsigned;			/* Ending Address Register

    BCICR_OVERLAY union fill;
	BCICR longword unsigned;		/*BCI Control Register
	BCICR_BITS structure fill;
	    FILL_7   bitfield length 3 fill prefix BIICDEF tag $$;
	    RTOEVEN  bitfield mask;		/* RTO EV Enable
	    PNXTEN   bitfield mask;		/* Pipeline NXT Enable
	    IPINTREN bitfield mask;		/* IP Interrupt Enable
	    INTREN   bitfield mask;		/* Interrupt Enable
	    BICSREN  bitfield mask;		/* BIIC CSR Space Enable
	    UCSREN   bitfield mask;		/* User CSR Space Enable
	    WINVALEN bitfield mask;		/* Write Invalidate Enable
	    INVALEN  bitfield mask;		/* INVAL Enable
	    IDENTEN  bitfield mask;		/* IDENT Enable
	    RESEN    bitfield mask;		/* Reserved Enable
	    STOPEN   bitfield mask;		/* STOP Enable
	    BDCSTEN  bitfield mask;		/* Broadcast Enable
	    MSEN     bitfield mask;		/* Multicast Space Enable
	    IPINTRF  bitfield mask;		/* IP Interrupt Force
	    BURSTEN  bitfield mask;		/* Burst Enable
	end BCICR_BITS;
    end BCICR_OVERLAY;

    WSR_OVERLAY union fill;
	WSR longword unsigned;			/*Write Status Register
	WSR_BITS structure fill;
	    FILL_8   bitfield length 28 fill prefix BIICDEF tag $$;
	    GPR0     bitfield mask;		/* These bits indicate
	    GPR1     bitfield mask;		/*  that the corresponding
	    GPR2     bitfield mask;		/*  General Purpose Register
	    GPR3     bitfield mask;		/*  has been written to.
	end WSR_BITS;
    end WSR_OVERLAY;

    IPISTPF_OVERLAY union fill;
	IPISTPF longword unsigned;		/*IPINTR/STOP Force CMD Reg
	IPISTPF_BITS structure fill;
	    FILL_9   bitfield length 11 fill prefix BIICDEF tag $$;
	    MIDEN    bitfield mask;		/* Determines whether Master ID
						/*  transmitted on BI D<31:16>.
	    CMD      bitfield length 4;		/* Command (IPINTR or STOP).
	end IPISTPF_BITS;
    end IPISTPF_OVERLAY;

    FILL_10 longword fill;			/*Unused
    FILL_11 longword fill;			/*Unused
    FILL_12 longword fill;			/*Unused


    UICR_OVERLAY union fill;
	UICR longword unsigned;			/*UserInterrupt Control Register
	UICR_BITS structure fill;
	    FILL_13  bitfield length 2 fill prefix BIICDEF tag $$;
	    UIVECTOR bitfield length 12;	/* Vector
	    FILL_14  bitfield length 1 fill prefix BIICDEF tag $$;
	    EXVECTOR bitfield mask;		/* External Vector
	    UIFORCE  bitfield length 4;		/* Force (1 for each level)
	    UISENT   bitfield length 4;		/* INTR command sent(1 for each level)
	    UIINTC   bitfield length 4;		/* Interrupt Complete(1 for each level)
	    UIINTAB  bitfield length 4;		/* Interrupt Abort(1 for each level)
	end UICR_BITS;
    end UICR_OVERLAY;

    FILL_15 byte dimension 172 fill prefix BIICDEF tag $$;

/*+
/* BIIC General Purpose Device Registers
/*-

    GPR0 longword unsigned;			/*General Purpose Register 0
    GPR1 longword unsigned;			/*General Purpose Register 1
    GPR2 longword unsigned;			/*General Purpose Register 2
    GPR3 longword unsigned;			/*General Purpose Register 3

end BIICDEF;

end_module $BIICDEF;

module $BIMEMDEF;

/*+
/* BI Memory Node Registers
/*-

aggregate BIMEMDEF structure prefix BIMEM$;

    FILL_15 byte dimension 256 fill prefix BIMEMDEF tag $$;

    CSR1_OVERLAY union fill;
	CSR1 longword unsigned;				/*CSR 1
	CSR1_OVERLAY union fill;
	    CSR1_BITS structure fill;
		DIAGBTS bitfield length 7;		/* Used during ECC diag cycles
		FILL_1  bitfield length 1 fill prefix BIMEMDEF tag $$;
		INTLV   bitfield mask;			/* 1=> internally lnterleaved
		CNTLERR bitfield mask;			/* Controller error
		MWRITER bitfield mask;			/* RDS on masked write
		FILL_2  bitfield length 1 fill prefix BIMEMDEF tag $$;
		BROKE   bitfield mask;			/* Broke bit
		INTLK   bitfield mask;			/* Interlock flag
		MEMVAL  bitfield mask;			/* Memory contents valid
		INHCRD  bitfield mask;			/* Inhib. CRD reporting
		RAMTYPE bitfield length 2;		/* 00=>64Ks, 01=>256Ks
		MEMSIZE bitfield length 11;		/* Size in 256KB increments
		ECCDIS  bitfield mask;			/* Used with following bit
		ECCDIAG bitfield mask;			/* 
		ERRSUM  bitfield mask;			/* Error summary(includes CSR2)
	    end CSR1_BITS;
	end CSR1_OVERLAY;
    end CSR1_OVERLAY;

    CSR2_OVERLAY union fill;
	CSR2 longword unsigned;				/*CSR 2
	CSR2_OVERLAY union fill;
	    CSR2_BITS structure fill;
		ERRSYND bitfield length 7;		/* Error syndrome
		FILL_3  bitfield length 1 fill prefix BIMEMDEF tag $$;
		INTLVAD bitfield mask;			/* Interleave Address
		ERRADDR bitfield length 15;		/* Internal addr of error
		FILL_4  bitfield length 4 fill prefix BIMEMDEF tag $$;
		ADRSERR bitfield mask;			/* Internal address parity error
		CRDLOGR bitfield mask;			/* CRD Error Log REQ
		HIERATE bitfield mask;			/* Hi Error Rate
		RDSLOGR bitfield mask;			/* RDS Error Log REQ
	    end CSR2_BITS;
	end CSR2_OVERLAY;
    end CSR2_OVERLAY;

end BIMEMDEF;
end_module $BIMEMDEF;

module $BOODEF;
/*+
/* BOO - Boot Control Block
/*
/* A boot control block is produced by SYSBOOT and placed in non-paged
/* pool.  It is pointed to by the cell EXE$GL_BOOTCB and contains
/* the mapping information for SYS.EXE, SYSDUMP.DMP, SYSPARAM portion
/* of SYS.EXE, and non-resident BUGCHECK code.
/*-

aggregate BOODEF structure prefix BOO$;
    CHECKSUM longword unsigned;				/* Checksum 
    PARAM_MAP longword unsigned;			/* Address of map for SYSPARAM 
    SIZE word unsigned;					/* Size of fixed portion of BOOTCB 
    TYPE byte unsigned;					/* Type of control block 
    SUBTYP byte unsigned;				/* Sub-type 
    SYS_VBN longword unsigned;				/* SYS.EXE starting VBN 
    SYS_SIZE longword unsigned;				/* SYS.EXE size in blocks 
                                    			/* from starting VBN to end of executable image
    SYS_MAP longword unsigned;				/* Adr of map for SYS.EXE 
    DMP_VBN longword unsigned;				/* Starting VBN for dump file 
    DMP_SIZE longword unsigned;				/* Size in blocks of dump file 
                                    			/* from starting VBN to end of file
    DMP_MAP longword unsigned;				/* Adr of map for SYSDUMP.DMP 
    BUG_MAP longword unsigned;				/* Adr of map for non-resident BUGCHECK code 
    constant "LENGTH" equals . prefix BOO$ tag K;
    constant "LENGTH" equals . prefix BOO$ tag C;
end BOODEF;

end_module $BOODEF;


module $BQODEF;
/*+
/*
/* Offsets into the IO vector of the BOOT driver.
/*
/*-



aggregate BQODEF structure prefix BQO$;
    QIO longword unsigned;				/* QIO entry 
    MAP longword unsigned;				/* Mapping entry 
    SELECT longword unsigned;				/* Selection entry 
    DRIVRNAME longword unsigned;			/* Offset to driver name 
    VERSION word unsigned;				/* Version number of VMB 
    VERCHECK word unsigned;				/* Check field 
    RESELECT longword unsigned;				/* Reselection entry 
    MOVE longword unsigned;				/* Move driver entry 
    UNIT_INIT longword unsigned;			/* Unit initialization entry 
    AUXDRNAME longword unsigned;			/* Offset to auxiliary driver name 
    UMR_DIS longword unsigned;				/* UNIBUS Map Registers to disable 
    UCODE longword unsigned;				/* Absolute address of booting microcode 
    UNIT_DISC longword unsigned;			/* Unit disconnecting entry
    DEVNAME longword unsigned;				/* Offset to boot device name
    UMR_TMPL longword unsigned;				/* UNIBUS map register template
    UMR_DP byte unsigned;				/* UNIBUS map register data path
    CPUTYPE byte unsigned;				/* Cpu type from SID
    CPUDATA longword unsigned;				/* Cpu data from SID
    TENUSEC longword unsigned;				/* TIMEDWAIT loop delay counter
    UBDELAY longword unsigned;				/* TIMEDWAIT loop delay counter
end BQODEF;

end_module $BQODEF;

MODULE	$BRKTDEF;	   /*
/* +
/* 
/*  Structure of breakthru message descriptor block.
/* 
/* -

AGGREGATE $BRKTDEF STRUCTURE;

BRKTHRU_OVERLAY UNION;		/* set up overlay

BRKTHRU_1 STRUCTURE PREFIX BRK$;
/* 
/*  Common Storage
/*  
    PRIVS	quadword unsigned;  		/*  privs to set
    SIZE	word unsigned; 			/*  block size
    OUTCNT	word unsigned;			/*  outstanding I/O count
    DEVNAME	character length 16;		/*  device name for $ASSIGN
    PCB		longword unsigned; 		/*  Address of PCB
    IOSB	longword unsigned; 		/*  Address of return IOSB
    ASTADR	longword unsigned; 		/*  Address of AST routine
    ASTPRM	longword unsigned; 		/*  Value of AST parameter
    TIMEOUT	quadword unsigned; 		/*  Timeout value
    CARCON	longword unsigned; 		/*  carriage control
    FLAGS	longword unsigned; 		/*  flags
    SENDNAME	character length 16;		/*  username/terminal name
    SENDTYPE	word unsigned;			/*  send descriptor type
    SECONDS	word unsigned;			/*  Timeout in seconds
    REQID	longword unsigned; 		/*  send requestor ID
/* 
/*  miscellaneous context
/* 
    PIDCTX	longword unsigned; 		/*  Last PID in user search
    UCBCTX	longword unsigned; 		/*  Last UCB in TTY search
    DDBCTX	longword unsigned; 		/*  Last DDB in TTY search
    QIOCTX	longword unsigned; 		/*  per QIO context address

    EFN		word unsigned;			/*  user event flag *BYTE***?
    STS_OVERLAY UNION FILL;	
	STS	byte unsigned; 			/*  status flags
	STS_BITS STRUCTURE FILL;		/* status flags bit definition
	    LOCKED 	bitfield mask;		/* I/O dataabse locked
	    DONE	bitfield mask;		/* done looking for terminals
	    CHKPRIV	bitfield mask;		/* check privilege
	END STS_BITS;
    END STS_OVERLAY;
    PRVMODE	byte unsigned; 			/*  previous mode

    SCRMSGLEN	longword unsigned; 		/*  screen message length
    SCRMSG	longword unsigned; 		/*  screen message address
/* 
/*  status block
/*  
    STATUS	word unsigned;			/*  status
    SUCCESSCNT 	word unsigned;			/*  Success count
    TIMEOUTCNT 	word unsigned;			/*  Timeout count
    REFUSEDCNT 	word unsigned;			/*  Refused count
/* 
/*  start of mailbox message 
/* 
    TRMMSG	word unsigned;			/*  mailbox message code
    TRMUNIT	word unsigned;			/*  tty unit number
    TRMNAME	character length 16;		/*  terminal name
/* 
/*  real message starts here
/* 
    MSGLEN	word unsigned;			/*  length of msgbuf
    MSGBUF	character length 0;		/*  start of message    
/*
/* Length
/*
    CONSTANT LENGTH EQUALS . TAG C;

END BRKTHRU_1;

BRKTHRU_2 STRUCTURE PREFIX brk2$;

/* 
/*  Per QIO storage
/* 

    COMMON	longword unsigned;  		/*  address of common area
    IOSB	quadword unsigned;  		/*  iosb for QIO
    CHAN	word unsigned;			/*  channel

/*
/* Length of Per QIO context
/*
    constant LENGTH equals . tag C;

END BRKTHRU_2;
END BRKTHRU_OVERLAY;

end $BRKTDEF;
end_module $BRKTDEF;



module $BTDDEF;
/*+
/*
/* Boot device codes
/*
/*-


	 						/* "$K_" added, 8/30/79, CHP 
constant MB	equals 0  prefix BTD tag $K;		/* Massbus device 
                                        		/* Types 1-31. reserved for unibus
                                        		/* devices
constant DM	equals 1  prefix BTD tag $K;		/* RK06/7 
constant DL	equals 2  prefix BTD tag $K;		/* RL02 
constant DQ	equals 3  prefix BTD tag $K;		/* RB02/RB80 
constant QNA	equals 7  prefix BTD tag $K;		/* QNA
constant PROM	equals 8  prefix BTD tag $K;		/* PROM
constant UDA	equals 17  prefix BTD tag $K;		/* UDA 
                                        		/* End of unibus devices
constant HSCCI	equals 32  prefix BTD tag $K;		/* HSC on CI 
constant CONSOLE	equals 64  prefix BTD tag $K;	/* Console block storage device 

end_module $BTDDEF;


module $BUADEF;
/*+
/* BI Bus UNIBUS Adapter Register Offset Definitions
/*-

aggregate BUADEF structure prefix BUA$;
    FILL_1 byte dimension 240 fill prefix BUADEF tag $$; /* Value is  F0 (Hex)

    GPR0_OVERLAY union fill;			/* BIIC GPR0 used by BUA.
	GPR0 longword unsigned;
	GPR0FIELDS structure fill;
	    UBPUP    bitfield mask;		/* UNIBUS Power Up (RO)
            FILL_2   bitfield length 15 fill prefix BUADEF tag $$;/*SPARE 
	    IEN_COPY bitfield length 16;	/* Internal Error Number copied
						/*  here from BUACSR.
	end GPR0FIELDS;
    end GPR0_OVERLAY;

    FILL_3 byte dimension 1580 fill prefix BUADEF tag $$;/* Cummulative Value
							 /*  is 720 (Hex)
/* This register holds the error summaries and error interrupt enable for BUA.

    CSR_OVERLAY union fill;
        CSR longword unsigned;		/* Control and Status Register
	CSR_BITS structure fill;
            IEN    bitfield length 8;	/* Instruction Error Number (RO)
					/*  Self Test failure code

            FILL_4 bitfield length 8 fill prefix BUADEF tag $$;/* Reserved Field

            REGDMP bitfield mask;	/* uDiagnostic Register Dump bit.  (WO)
					/*  When 1 is written, causes uEngine to
					/*  dump stored internal registers.
            UPI    bitfield mask;	/* UNIBUS Power Initialization bit. (WO)
					/*  When 1 written, causes power up init
					/*  on UNIBUS.

            FILL_5 bitfield length 2 fill prefix BUADEF tag $$;/* Reserved Field

            EIE    bitfield mask;	/* BUA Error Interrupt Enable (R/W)

            FILL_6 bitfield length 3 fill prefix BUADEF tag $$;/* Reserved Field

            BADBDP bitfield mask;	/* Bit set if BDP 6 or 7 selected (W1C).
            IMR    bitfield mask;	/* Invalid Map Register (W1C)
            UIE    bitfield mask;	/* Bit set if DATO(B) does not follow
					/*  DATIP on UNIBUS (W1C)
            USSTO  bitfield mask;	/* UNIBUS SSYNC timeout (W1C)
            BIF    bitfield mask;	/* UNIBUS to BI failure (W1C)

            FILL_7 bitfield length 2 fill prefix BUADEF tag $$;/* Reserved Field

            ERR    bitfield mask;	/* Logical OR of error bits in CSR (RO)
	end CSR_BITS;
    end CSR_OVERLAY;


/* BUA Vector Offset Register - BITS [13:09] of the VOR register are
/*  concatenated with the incoming UNIBUS vector to form a 14 bit BI vector.

    VOR_OVERLAY union fill;
        VOR longword unsigned;		/* Vector Offset Register
	VOR_BITS structure fill;

            FILL_8 bitfield length 9 fill prefix BUADEF tag $$;/* Reserved Field

	    VECOFF bitfield length 5;	/* Vector Offset (R/W)
	end VOR_BITS;
    end VOR_OVERLAY;

/* Failed UNIBUS Address Register (FUBAR)

    FUBAR_OVERLAY union fill;
        FUBAR longword unsigned;	/* Failed UNIBUS Address Register
	FUBAR_BITS structure fill;
            FUBAR_ADR bitfield length 16;/* Failed UNIBUS Address (Hi 16 bits)
	end FUBAR_BITS;
    end FUBAR_OVERLAY;

    FILL_9 byte dimension 4 fill prefix BUADEF tag $$;

    BDP1_OVERLAY union fill;
	BDP1 longword unsigned;				/* BDP1
	BDPFIELDS structure fill;
	    STATUS bitfield length 16;			/* Bit for each byte
	    ADDR   bitfield length 16;			/* UNIBUS addr of octaword
	end BDPFIELDS;
    end BDP1_OVERLAY;
	BDP2 longword unsigned;				/* BDP2
	BDP3 longword unsigned;				/* BDP3
	BDP4 longword unsigned;				/* BDP4
	BDP5 longword unsigned;				/* BDP5

    FILL_10 byte dimension 12 fill prefix BUADEF tag $$;/* Cummulative Value

    DPCSR0_OVERLAY union fill;
	DPCSR0 longword unsigned;			/* Datapath 0 CSR
	DPCSR_BIT structure fill;
	    PURGE bitfield mask;			/* Purge (WO) bit
            FILL_11 bitfield length 20 fill prefix BUADEF tag $$;/*SPARE 
	    DPSEL bitfield length 3;			/* Data Path #
	end DPCSR_BIT;
    end DPCSR0_OVERLAY;

	DPCSR1 longword unsigned;			/* Datapath 1 CSR
	DPCSR2 longword unsigned;			/* Datapath 2 CSR
	DPCSR3 longword unsigned;			/* Datapath 3 CSR
	DPCSR4 longword unsigned;			/* Datapath 4 CSR
	DPCSR5 longword unsigned;			/* Datapath 5 CSR

    FILL_12 byte dimension 8 fill prefix BUADEF tag $$;/* Cummulative Value

    FILL_13 byte dimension 144 fill prefix BUADEF tag $$;

    MAP_OVERLAY union fill;
        MAP longword unsigned dimension 496;	/* Map Registers
	MAP_BITS structure fill;
            MAP_ADDR bitfield length 21;	/* PFN
            MAP_DPD bitfield length 3;		/* Datapath Designator

	    FILL_14 bitfield length 1 fill prefix BUADEF tag $$;/* Reserved field

            MAP_BO  bitfield mask;		/* Byte Offset
            LWAEN   bitfield mask;		/* Long Word Access Enable

            FILL_15 bitfield length 3 fill prefix BUADEF tag $$;/* Reserved field

	    PPIE    bitfield mask;		/* Reserved for use on BUA's
						/*  with PDP-11 on UNIBUS.
            MAP_VALID bitfield mask;		/* Map Register Valid
	end MAP_BITS;
        constant MAXDP	equals 5  prefix BUA tag $C;	/*MAXIMUM DATAPATH ! 
        
    end MAP_OVERLAY;
end BUADEF;

end_module $BUADEF;


module $CADEF;

/*+
/* CONDITIONAL ASSEMBLY PARAMETER DEFINITIONS
/*
/*        A NONZERO PARAMETER VALUE INDICATES PRESENCE OF THE FEATURE.
/*        A ZERO PARAMETER VALUE INDICATES ABSENCE OF THE FEATURE
/*
/*        ALL PARAMETERS MUST BE DEFINED
/*-


constant SIMULATOR	equals 1  prefix CA tag $;	/*INCLUDE SIMULATOR SUPPORT CODE 
constant MEASURE	equals 2  prefix CA tag $;	/*INCLUDE PERFORMANCE MEASUREMENT HOOKS 
constant MEASURE_IOT	equals 4  prefix CA tag $;	/*INCLUDE I/O TRANSACTION DATA COLLECTION 


end_module $CADEF;


module $CANDEF;

/*+
/* CAN - DEFINE DRIVER CANCEL ROUTINE REASON CODES
/*
/* THESE CODES ARE PASSED TO THE CANCEL ROUTINE OF A DRIVER SO THAT
/* THE ROUTINE CAN DISTINGUISH BETWEEN CALLS FROM $DASSGN AND $CANCEL.
/*
/*-


constant(
      CANCEL						/*CANCEL INVOKED DUE TO $CANCEL SERVICE 
    , DASSGN						/*CANCEL INVOKED DUE TO $DASSGN SERVICE 
    , AMBXDGN						/*CANCEL INVOKED DUE TO MB DISASSOCIATION
    ) equals 0 increment 1 prefix CAN tag $C;

end_module $CANDEF;


module $CDRPDEF;
/*+
/* CDRP - CLASS DRIVER I/O REQUEST PACKET
/*
/* This structure contains within it, at negative offsets, a full IRP.
/* For this reason all IRP fields must be at the same relative offsets
/* as the corresponding fields in the IRP.
/*
/*-



aggregate CDRPDEF structure prefix CDRP$ origin FQFL;
    IOQFL longword unsigned;				/*I/O QUEUE FORWARD LINK 
    IOQBL longword unsigned;				/*I/O QUEUE BACKWARD LINK 
    IRP_SIZE word unsigned;				/*SIZE OF IRP IN BYTES 
    IRP_TYPE byte unsigned;				/*STRUCTURE TYPE FOR IRP 
    RMOD byte unsigned;					/*ACCESS MODE OF REQUEST 
{    RMOD subfields [defined in IRPDEF]
{	bitfield MODE length 2;				/* MODE SUBFIELD
    PID longword unsigned;				/*PROCESS ID OF REQUESTING PROCESS 
    AST longword unsigned;				/*ADDRESS OF AST ROUTINE 
    ASTPRM longword unsigned;				/*AST PARAMETER 
    WIND longword unsigned;				/*ADDRESS OF WINDOW BLOCK 
    UCB longword unsigned;				/*ADDRESS OF DEVICE UCB 
    FUNC word unsigned;					/*I/O FUNCTION CODE AND MODIFIERS 
{    FUNC subfields [defined in IRPDEF]
{	bitfield FCODE length 6;			/* FUNCTION CODE FIELD
{	bitfield FMOD length 10;			/* FUNCTION MODIFIER FIELD
    EFN byte unsigned;					/*EVENT FLAG NUMBER AND EVENT GROUP 
    PRI byte unsigned;					/*BASE PRIORITY OF REQUESTING PROCESS 
    IOSB longword unsigned;				/*ADDRESS OF I/O STATUS DOUBLE LONGWORD 
    CHAN word unsigned;					/*PROCESS I/O CHANNEL NUMBER 
    STS word unsigned;					/*REQUEST STATUS 
{    STS subfields [defined in IRPDEF]
{	bitfield BUFIO;					/* BUFFERED I/O FLAG   /*THESE BITS
{	bitfield FUNC;					/* 1=>READ FUNCTION    /*MUST BE ADJACENT
{	bitfield PAGIO;					/* PAGING I/O FLAG     /*AND IN ORDER
{	bitfield COMPLX;				/* COMPLEX BUFFERED I/O
{	bitfield VIRTUAL;				/* VIRTUAL I/O FUNCTION
{	bitfield CHAINED;				/* CHAINED BUFFERED I/O OPERATION
{	bitfield SWAPIO;				/* SWAP I/O OPERATION
{	bitfield DIAGBUF;				/* DIAGNOSTIC BUFFER ALLOCATED
{	bitfield PHYSIO;				/* PHYSICAL I/O
{	bitfield TERMIO;				/* TERMINAL I/O (FOR SELECTING PRIORITY INC)
{	bitfield MBXIO;					/* MAILBOX BUFFERED READ
{	bitfield EXTEND;				/* AN IRPE IS LINKED TO THIS IRP
{	bitfield FILACP;				/* FILE ACP I/O (BOTH DIOCNT AND BIOCNT)
{	bitfield MVIRP;					/* MOUNT VERIFICATION IRP
{	bitfield KEY;					/* ENCRYPTION KEY
    SVAPTE longword unsigned;				/*SYSTEM VIRTUAL ADDRESS OF FIRST PTE 
    BOFF word unsigned;					/*BYTE OFFSET IN FIRST PAGE 
    BCNT_OVERLAY union fill;
        BCNT longword unsigned;				/*BYTE COUNT OF TRANSFER 
        BCNT word unsigned;				/* OLD WORD DEFINITION FOR COMPATIBILITY 
    end BCNT_OVERLAY;
    FILL_1 word fill prefix CDRPDEF tag $$;		/* ROUND UP TO NEXT LONGWORD 
    IOST1_OVERLAY union fill;
        IOST1 longword unsigned;			/*FIRST I/O STATUS LONGWORD (FOR I/O POST) 
        MEDIA longword unsigned;			/*MEDIA ADDRESS 
    end IOST1_OVERLAY;
    IOST2_OVERLAY union fill;
        IOST2 longword unsigned;			/*SECOND I/O STATUS LONGWORD 
	TT_TERM_OVERLAY union fill;
            TT_TERM longword unsigned;			/*ADDRESS OF READ TERMINATORS MASK 
            CARCON byte unsigned;			/*CARRIAGE CONTROL 
	end TT_TERM_OVERLAY;
    end IOST2_OVERLAY;
    NT_PRVMSK_OVERLAY union fill;
        NT_PRVMSK quadword unsigned;			/* PRIVILEGE MASK FOR DECNET 
	NT_PRVMSK_FIELDS structure fill;
	    ABCNT_OVERLAY union fill;
                ABCNT longword unsigned;		/* ACCUMULATED BYTES TRANSFERED 
		ABCNT_OVERLAY1 union;
                    ABCNT word unsigned;		/* OLD WORD DEFINITION FOR COMPATIBILITY 
                    TT_PRMPT word unsigned;		/* PROMPT SIZE 
		end ABCNT_OVERLAY1;
	    end ABCNT_OVERLAY;
	    OBCNT_OVERLAY union fill;
                OBCNT longword unsigned;		/* ORIGINAL TRANSFER BYTE COUNT 
                OBCNT word unsigned;			/* OLD WORD DEFINITION FOR COMPATIBILITY 
	    end OBCNT_OVERLAY;
	end NT_PRVMSK_FIELDS;
    end NT_PRVMSK_OVERLAY;
    SEGVBN_OVERLAY union fill;
        SEGVBN longword unsigned;			/*VIRTUAL BLOCK NUMBER OF CURRENT SEGMENT 
        JNL_SEQNO longword unsigned;			/* SEQUENCE NUMBER IN JOURNAL 
    end SEGVBN_OVERLAY;
    DIAGBUF longword unsigned;				/* DIAGNOSTIC BUFFER ADDRESS 
    SEQNUM longword unsigned;				/* SEQUENCE NUMBER 
    EXTEND longword unsigned;				/* ADDRESS OF IRPE 
    ARB longword unsigned;				/* ACCESS RIGHTS BLOCK ADDRESS 
    KEYDESC longword unsigned;				/* ADDRESS OF ENCRYPTION KEY DESCRIPTOR
/*
/*
    constant CDRPBASE equals . prefix CDRP$ tag K;
    constant CDRPBASE equals . prefix CDRP$ tag C;
    FQFL longword unsigned;				/* Fork Queue FLINK 
    FQBL longword unsigned;				/* Fork Queue Blink 
    CDRPSIZE word unsigned;				/* Size field for positive section only 
    CD_TYPE byte unsigned;				/* Type, always of interest 
    FIPL byte unsigned;					/* Fork IPL 
    FPC longword unsigned;				/* Fork PC 
    FR3 longword unsigned;				/* Fork R3 
    FR4 longword unsigned;				/* Fork R4 
    SAVD_RTN longword unsigned;				/* Saved return address from level 1 JSB 
    MSG_BUF longword unsigned;				/* Address of allocated MSCP buffer 
    RSPID longword unsigned;				/* Allocated Request ID 
    CDT longword unsigned;				/* Address of Connection Descriptor Table 
    RWCPTR longword unsigned;				/* RWAITCNT pointer 
    constant "LENGTH" equals . prefix CDRP$ tag K;
    constant "LENGTH" equals . prefix CDRP$ tag C;
    
/*	CDRP extensions

    CDRP_EXTENSIONS union fill;

/*	Block Transfer Extension

	BLK_XFER_EXTENSION structure fill;
	    LBUFH_AD longword unsigned;			/* Local BUFfer Handle ADress 
	    LBOFF longword unsigned;			/* Local Byte OFFset 
	    RBUFH_AD longword unsigned;			/* Remote BUFfer Handle ADress 
	    RBOFF longword unsigned;			/* Remote Byte OFFset 
	    XCT_LEN longword unsigned;			/* Transfer length in bytes 
	    constant BT_LEN equals .;
	    constant BT_LEN equals . tag C;
	end BLK_XFER_EXTENSION;
    
/*	Class Driver Extension
    
	CLS_DRV_EXTENSION structure fill;
	    FILL_3 longword fill;			{  Skip local buffer handle address (above)
	    LBUFHNDL character length 12;		/* Local buffer handle 
	    UBARSRCE longword unsigned;			/* UNIBUS mapping resources allocated 
	    DUTUFLAGS structure longword unsigned;	/* Class driver status flags:
		CAND bitfield mask;			/*  canceled I/O request
		CANIO bitfield mask;			/*  cancel operation I/O request
		ERLIP bitfield mask;			/*  error log in progress
		PERM bitfield mask;			/*  CDDB permanent IRP/CDRP
		HIRT bitfield mask;			/*  HIRT permanent IRP/CDRP
		DENSCK bitfield mask;			/*  Tape density check required
		filler bitfield length 2 fill; 		{   Byte align IVCMD
		IVCMD bitfield mask;			/*  Invalid command processing in progress
	    end DUTUFLAGS;
	    DUTUCNTR word unsigned;			/* General purpose counter
	    ENDMSGSIZ word unsigned;			/* Size of most recent MSCP end message
	    constant CD_LEN equals .;
	    constant CD_LEN equals . tag C;
	end CLS_DRV_EXTENSION;

/*	Connection management extension

	CON_MGT_EXTENSION structure fill;
	    CNX_WORK_AREA  union fill;
		CNX_CLIENT_DATA structure fill;
		    VAL1 longword unsigned;		/* data value 1
		    VAL2 longword unsigned;		/* data value 2
		    VAL3 longword unsigned;		/* data value 3
		    VAL4 longword unsigned;		/* data value 4
		    VAL5 longword unsigned;		/* data value 5
		    VAL6 longword unsigned;		/* data value 6
		    VAL7 longword unsigned;		/* data value 7
		    VAL8 longword unsigned;		/* data value 8
		end CNX_CLIENT_DATA;
		CNX_BLOCK_XFER structure fill;
		    FILL_LBUFH_AD longword fill;	{ filler for CDRP$L_LBUFH_AD
		    FILL_VAL longword dimension 4;	{ filler for VAL2 through VAL5
		    CNXSVAPTE longword unsigned;	/* Block SVAPTE
		    CNXBOFF word unsigned;		/* Block buffer offset
		    CNXBCNT longword unsigned;		/* Block xfer length
		    CNXRMOD byte unsigned;		/* Block access mode
		    CLTSTS byte unsigned;		/* A client's status field
		end CNX_BLOCK_XFER;
	    end CNX_WORK_AREA;
	    MSGBLD longword unsigned;			/* Address of MSG BUILD routine
	    SAVEPC longword unsigned;			/* Caller's saved PC
	    SENDSEQNM word unsigned;			/* Message sequence number
	    CNXSTATE byte unsigned;			/* CNX message state
		constant (				/* Possible states:
		      NORMAL				/* The standard case (particulary no block xfer)
		    , REQUESTOR				/* Block transfer requestor
		    , PARTNER				/* Block transfer partner, active
		    , PART_IDLE				/* Block transfer partner, idle
		    , REQ_MAP				/* Block transfer requestor, waiting for buffer handle
		    , PART_MAP				/* Block transfer partner, waiting for buffer handle
		    ) equals 0 increment 1;
	    FILL_5 byte fill;
	    RETRSPID longword unsigned;			/* RSPID to return
	    VAL9 longword unsigned;			/* data value 9
	    constant CM_LENGTH equals .;
	    /*
	    /* The following fields are only valid
	    /* for long connection manager CDRPs.
	    /*
	    VAL10 longword unsigned;			/* data value 10
	    constant CM_LONG_LENGTH equals.;
	end CON_MGT_EXTENSTION;

    end CDRP_EXTENSIONS;

end CDRPDEF;

end_module $CDRPDEF;


module $CINDEF;
/*+
/*
/* Connect to interrupt definitions for QIO parameters
/*
/*-




aggregate CINDEF  union prefix CIN$;
    CINDEF_BITS structure fill;
        EFN bitfield mask;				/* Set event flag on interrupt. 
        USECAL bitfield mask;				/* Use CALL interface. 
        REPEAT bitfield mask;				/* Do repeated interrupt service. 
        AST bitfield mask;				/* Queue AST on interrupt. 
        INIDEV bitfield mask;				/* Device initialization to do. 
        START bitfield mask;				/* Start I/O routine. 
        ISR bitfield mask;				/* ISR to execute. 
        CANCEL bitfield mask;				/* Cancel I/O routine. 
        FILL_1 bitfield length 8 fill prefix CINDEF tag $$;/* Spare bits. 
        EFNUM bitfield mask length 16;			/* Event flag number. 
    end CINDEF_BITS;
    
end CINDEF;

    aggregate CINDEF1 structure prefix CIN$;
    INIDEV longword unsigned;				/* Offset to device init routine. 
    START longword unsigned;				/* Offset to start device routine. 
    ISR longword unsigned;				/* Offset to interrupt service routine. 
    CANCEL longword unsigned;				/* Offset to cancel I/O routine. 
    
    
    end CINDEF1;

aggregate CINDEF2 structure prefix CIN$;
    SPTCOUNT longword unsigned;				/* Number of SPTs allocated. 
    STARTVPN_OVERLAY union fill;
        STARTVPN longword unsigned;			/* Starting VPN allocated. 
        STARTBIT longword unsigned;			/* Starting bit in bitmap. 
        
        
    end STARTVPN_OVERLAY;
end CINDEF2;

end_module $CINDEF;


module $CCBDEF;


/*+
/* CCB - CHANNEL CONTROL BLOCK
/*
/* THERE IS ONE CHANNEL CONTROL BLOCK FOR EACH SOFTWARE CHANNEL THAT A
/* PROCESS MAY INITIATE I/O REQUESTS ON. THE NUMBER OF SUCH I/O CHANNELS
/* IS DETERMINED BY THE FIXED NUMBER ASSIGNED TO A PROCESS PLUS ANY
/* ADDITIONAL CHANNELS REQUIRED BY THE IMAGE CURRENTLY BEING EXECUTED
/* BY THE PROCESS.
/*
/* **** WARNING ****
/*        THE CHANNEL CONTROL BLOCK IS ASSUMED TO BE FOUR LONG WORDS
/* THROUGHOUT THE EXEC.  ITS SIZE MAY BE CHANGED BUT ONLY BY POWERS OF 2.
/*-



aggregate CCBDEF structure prefix CCB$;
    UCB longword unsigned;				/*ADDRESS OF ASSIGNED DEVICE UCB 
    WIND longword unsigned;				/*ADDRESS OF WINDOW BLOCK 
    STS_OVERLAY union fill;
        STS byte unsigned;				/*CHANNEL STATUS 
	STS_BITS structure fill;
            AMB bitfield mask;				/* MAILBOX ASSOCIATED WITH CHANNEL 
	    IMGTMP bitfield mask;			/* IMAGE TEMPORARY
	    RDCHKDON bitfield mask;			/* READ PROTECTION CHECK COMPLETED
	    WRTCHKDON bitfield mask;			/* WRITE PROTECTION CHECK COMPLETED
	    LOGCHKDON bitfield mask;			/* LOGICAL I/O ACCESS CHECK DONE
	    PHYCHKDON bitfield mask;			/* PHYSICAL I/O ACCESS CHECK DONE
	end STS_BITS;
    end STS_OVERLAY;
    AMOD byte unsigned;					/*ACCESS MODE THAT ASSIGNED CHANNEL 
    IOC word unsigned;					/*NUMBER OF OUTSTANDING I/O REQUESTS ON CHANNEL 
    DIRP longword unsigned;				/*DEACCESS I/O REQUEST PACKET ADDRESS 
    constant "LENGTH" equals . prefix CCB$ tag K;	/*LENGTH OF CCB 
    constant "LENGTH" equals . prefix CCB$ tag C;	/*LENGTH OF CCB 
end CCBDEF;

end_module $CCBDEF;


module $CDDBDEF;
/*+
/* CDDB - Class Driver Data Block
/*
/* Auxiliary data block pointed at by the CRB$L_AUXSTRUC of an MSCP speaking
/* intelligent disk or tape controller.  There is one CDDB per such intelligent
/* controller.
/*
/*-



aggregate CDDBDEF structure prefix CDDB$;
    CDRPQFL longword unsigned;				/*Active CDRP Q FLINK 
    CDRPQBL longword unsigned;				/*Active CDRP Q BLINK 
    SIZE word unsigned;					/*Size of CDDB in bytes 
    TYPE byte unsigned;					/*Major structure type for Class Driver 
    SUBTYPE byte unsigned;				/* CDDB structure subtype field 
    SYSTEMID byte unsigned dimension 6;			/*48 bit system ID. 
    STATUS_OVERLAY union fill;
        STATUS word unsigned;				/*Status word 
	STATUS_BITS structure fill;
            SNGLSTRM bitfield mask;			/* Single stream mode after VC crash 
            IMPEND bitfield mask;			/* IMmediate command PENDing 
            INITING bitfield mask;			/* Currently initializing CONNECTION 
            RECONNECT bitfield mask;			/* Currently re-CONNECTING to MSCP server 
            RESYNCH bitfield mask;			/* re_CONNECT initiated by Class Driver 
            POLLING bitfield mask;			/* Polling for units
	    ALCLS_SET bitfield mask;			/* Allocation class has been set
	    NOCONN bitfield mask;			/* CDDB currently has no connection
	    RSTRTWAIT bitfield mask;			/* Waiting to RESTART_NEXT_CDRP
	    QUORLOST bitfield mask;			/* CNXMAN quorum lost processing
	    DAPBSY bitfield mask;			/* DAP CDRP is busy
	    "2PBSY" bitfield mask;			/* Failover fork block is busy
	end STATUS_BITS;
    end STATUS_OVERLAY;
    PDT longword unsigned;				/*Port Descriptor Table address 
    CRB longword unsigned;				/*CRB address 
    DDB longword unsigned;				/*DDB address 
    CNTRLID_OVERLAY union fill;
        CNTRLID quadword unsigned;			/*Controller ID returned by MSCP END PACKET 
	CNTRLID_FIELDS structure fill;
            FILL_2 byte dimension 6 fill prefix CDDBDEF tag $$;
            CNTRLMDL byte unsigned;			/* Controller model ! (byte 6 of controller id) 
            CNTRLCLS byte unsigned;			/* Controller class (byte 7 of controller id) 
	end CNTRLID_FIELDS;
    end CNTRLID_OVERLAY;
    CNTRLFLGS word unsigned;				/*Controller flags also returned by END PACKET 
    CNTRLTMO word unsigned;				/*Controller timeout also returned by END PACKET 
    OLDRSPID longword unsigned;				/*RSPID of oldest outstanding MSCP command 
    OLDCMDSTS longword unsigned;			/*Latest MSCP command status for this command 
    RSTRTCDRP longword unsigned;			/*Addr of only active CDRP after VC re-establish 
    RETRYCNT byte unsigned;				/*# retries remaining for CDRP after VC reset 
    DAPCOUNT byte unsigned;				/*# DU$TMR loops until DAP_THREAD
    RSTRTCNT word unsigned;				/*# of resynch or connection error since boot
    RSTRTQFL longword unsigned;				/*Queue wherein we accumulate, sort and select 
    RSTRTQBL longword unsigned;				/* for re-submission following VC re-establish 
    SAVED_PC longword unsigned;				/*Saved PC on internal subroutine calls 
    UCBCHAIN longword unsigned;				/*Chain of UCBs on connection
    ORIGUCB longword unsigned;				/*Ptr to Orig. UCB if unchained
    ALLOCLS longword unsigned;				/*Device Allocation Class
    DAPCDRP longword unsigned;				/*Ptr to Deter.Acc.Path CDRP
    CDDBLINK longword unsigned;				/*Link in CDDB chain
    FOVER_CTR byte unsigned;				/* counter of reconnect intervals per failover try
    RSVDB byte unsigned;				/* reserved byte
    WTUCBCTR word unsigned;				/* counter of UCBs waiting for mount ver. to finish
							{  so that single stream CDRP processing may begin
    RSVD1 longword unsigned;				/* reserved longword
    RSVD2 longword unsigned;				/* reserved longword
    RSVD3 longword unsigned;				/* reserved longword
    RSVD4 longword unsigned;				/* reserved longword
    constant "LENGTH" equals . prefix CDDB$ tag K;	/*Standard length of CDDB 
    constant "LENGTH" equals . prefix CDDB$ tag C;	/*Standard length of CDDB 
    PERMCDRP longword unsigned;				/*Beginning of a permanent CDRP allocated 
                                    			/*  contiguous to CDDB
    
end CDDBDEF;

end_module $CDDBDEF;


module $CDLDEF;
/*+
/* CDL - SCS CONNECTION DESCRIPTOR LIST
/*
/* THERE IS A SYSTEM WIDE LIST OF CONNECTION DESCRIPTORS POINTED
/* TO BY THE CDL.
/*-



aggregate CDLDEF structure prefix CDL$ origin BASE;
    MAXCONIDX word unsigned;				/*MAXIMUM ! OF CDT'S 
    FILL_1 word fill prefix CDLDEF tag $$;		/*RESERVED WORD 
    FREECDT longword unsigned;				/*ADDR OF 1ST FREE CDT 
    SIZE word unsigned;					/*STRUCTURE SIZE IN BYTES 
    TYPE byte unsigned;					/*SCS STRUCTURE TYPE 
    SUBTYP byte unsigned;				/*SCS STRUCT SUBTYPE FOR CDL 
    FILL_2 longword fill prefix CDLDEF tag $$;		/*RESERVED LONGWORD 
    BASE longword unsigned;				/*BASE OF THE TABLE 
    constant "LENGTH"	equals 16  prefix CDL tag $C;	/*LENGTH OF NEG PORTION OF STRUCTURE 
    
end CDLDEF;

end_module $CDLDEF;


module $CDTDEF;
/*+
/* CDT - SCS CONNECTION DESCRIPTOR TABLE
/*
/* THESE DESCRIPTORS ARE POINTED TO BY THE SYSTEM WIDE CONNECTION
/* DESCRIPTOR LIST (CDL).  ONE CDT IS USED PER SCS VIRTUAL CIRCUIT
/* OR LISTENING CONNECTION.
/*-



aggregate CDTDEF structure prefix CDT$;
    MSGINPUT_OVERLAY union fill;
        MSGINPUT longword unsigned;			/*ADDR OF MSG INPUT DISPATCHER 
        LINK longword unsigned;				/* OR LINK TO NEXT FREE CDT 
    end MSGINPUT_OVERLAY;
    DGINPUT longword unsigned;				/*ADDR TO CALL ON DG RECEIVED 
    SIZE word unsigned;					/*STRUCTURE SIZE IN BYTES 
    TYPE byte unsigned;					/*SCS STRUCTURE TYPE 
    SUBTYP byte unsigned;				/*SCS STRUCT SUBTYPE FOR CDT 
    ERRADDR longword unsigned;				/*ADDR TO CALL FOR ERROR NOTIFICATION 
    PDT longword unsigned;				/*ADDR OF ASSOC PORT DESC TABLE 
    RCONID longword unsigned;				/*REMOTE CONNECTION ID 
    LCONID longword unsigned;				/*LOCAL CONNECTION ID 
    PB longword unsigned;				/*ADDR OF ASSOC PATH BLOCK 
    RSTATION byte unsigned dimension 6;			/*REMOTE STATION ADDR 
    REASON word unsigned;				/*REJECT/DISCONNECT REASON 
    STATE word unsigned;				/*CONNECTION STATE 
                                            		/*STATE VALUES:
    	 						/* 0 ORIGIN, INCREMENTS OF 1: 
    constant(
          CLOSED					/* CLOSED 
        , LISTEN					/* LISTENING FOR CONNX REQUESTS 
        , OPEN						/* OPEN 
        , DISC_ACK					/* DISCONNECT ACKNOWLEDGED 
        , DISC_REC					/* DISCONNECT REQ RECEIVED 
        , DISC_SENT					/* DISCONNECT SENT 
        , DISC_MTCH					/* DISCONNECT MATCH 
        , CON_SENT					/* CONNECT REQ SENT 
        , CON_ACK					/* CONNECT REQ SENT AND ACK'ED 
        , CON_REC					/* CONNECT REQ RECEIVED 
        , ACCP_SENT					/* ACCEPT REQ SENT 
        , REJ_SENT					/* REJECT SENT 
        , VC_FAIL					/* VIRTUAL CIRCUIT FAILED 
        ) equals 0 increment 1  prefix CDT tag $C;	/* 
    BLKSTATE word unsigned;				/*SCS SEND BLOCKED STATE 
                                            		/*STATE VALUES:
    	 						/* 1 ORIGIN, INCREMENTS OF 1: 
    constant(
          CON_PEND					/* WAITING TO SEND CONNECT REQ 
        , ACCP_PEND					/* WAITING TO SEND ACCEPT REQ 
        , REJ_PEND					/* WAITING TO SEND REJECT REQ 
        , DISC_PEND					/* WAITING TO SEND DISCONNECT REQ 
        , CR_PEND					/* WAITING TO SEND CREDIT 
        , DCR_PEND					/* WAITING TO SEND CREDIT IN 
                                            		/*  PREPARATION FOR DISCONNECT
        ) equals 1 increment 1  prefix CDT tag $C;	/* 
    SCSMSG longword unsigned;				/*ADDR OF SCS RECEIVE BUFFER 
    WAITQFL longword unsigned;				/*SEND SCS MSG WAIT QUEUE FLINK 
    WAITQBL longword unsigned;				/*SEND SCS MSG WAIT QUEUE BLINK 
    CRWAITQFL longword unsigned;			/*SEND CREDIT WAIT QUEUE FLINK 
    CRWAITQBL longword unsigned;			/*SEND CREDIT WAIT QUEUE BLINK 
    SEND word unsigned;					/*CURRENT SEND CREDIT 
    REC word unsigned;					/*RECEIVE CREDIT (SEND CREDIT 
                                            		/* HELD BY REMOTE
    MINREC word unsigned;				/*MINIMUM RECEIVE CREDIT (MIN 
                                            		/* SEND REQUIRED BY REMOTE)
    PENDREC word unsigned;				/*RECEIVE CREDIT NOT YET EXTENDED 
                                            		/* TO REMOTE
    INITLREC word unsigned;				/*INITIAL RECEIVE CREDIT 
    MINSEND word unsigned;				/*MINIMUM SEND CREDIT 
    DGREC word unsigned;				/*DATAGRAMS QUEUED FOR RECEIVE 
    PRIORITY byte unsigned;				/*BLOCK TRANSFER PRIORIY 
    FILL_1 byte fill prefix CDTDEF tag $$;		/*RESERVED 
    RPROCNAM longword unsigned;				/*ADDR OF REMOTE PROCESS NAME 
    LPROCNAM longword unsigned;				/*ADDR OF LOCAL PROCESS NAME 
    CONDAT longword unsigned;				/*ADDR OF CONNECT DATA 
    AUXSTRUC longword unsigned;				/*ADDR OF AUXILARY DATA STRUCTURE 
    BADRSP longword unsigned;				/*ADDR IN SYSAP TO CALL WITH 
							/* BAD RESPONSE(UNIMPLEMENTED) 
    FPC longword unsigned;				/*SAVED FORK PROCESS PC 
    FR5 longword unsigned;				/*SAVED FORK PROCESS R5 
    CDTLST longword unsigned;				/*LINK FOR CDT LIST FROM PB 
    DGSENT longword unsigned;				/*# APPLICATION DGS SENT
    DGRCVD longword unsigned;				/*# APPLICATION DGS REC'D
    DGDISCARD longword unsigned;			/*# DGS DISCARDED BY DRIVER
    MSGSENT longword unsigned;				/*# APPLICATION MSGS SENT
    MSGRCVD longword unsigned; 				/*# APPLICATION MSGS REC'D
    SNDDATS longword unsigned;				/*# SEND DATAS INITIATED
    BYTSENT longword unsigned;				/*# BYTES SENT VIA SEND DATAS
    REQDATS longword unsigned;				/*#REQ DATAS INITIATED
    BYTREQD longword unsigned;				/*BYTES REC'D VIA REQ DATAS
    BYTMAPD longword unsigned;				/*TOTAL BYTES MAPPED
    QCR_CNT word unsigned;				/*# TIMES QUEUED FOR SEND CREDIT
    QBDT_CNT word unsigned;				/*# TIMES QUEUED FOR BDT
    FILL_2 longword fill prefix CDTDEF tag $$;		/*RESERVED
    constant "LENGTH" equals . prefix CDT$ tag K;	/*LENGTH OF CDT 
    constant "LENGTH" equals . prefix CDT$ tag C;	/*LENGTH OF CDT 
    
end CDTDEF;

end_module $CDTDEF;


module $CEBDEF;
/*+
/* COMMON EVENT BLOCK
/*-


aggregate CEBDEF structure prefix CEB$;
    CEBFL_OVERLAY union fill;
        CEBFL longword unsigned;			/*POINTER TO NEXT COMMON EVENT BLOCK 
	CEBFL_BITS structure fill;
            VALID bitfield mask;			/*SHMEM MASTER CEB, SET IF VALID ENTRY 
            LOCKED bitfield mask;			/*SHMEM MASTER CEB, SET IF ENTRY LOCKED 
            REFCNTLCK bitfield mask;			/*SHMEM MASTER CEB, LOCKED FOR REFCNT CHG 
	end CEBFL_BITS;
    end CEBFL_OVERLAY;
    CEBBL longword unsigned;				/*POINTER TO PREVIOUS COMMON EVENT BLOCK 
    SIZE word unsigned;					/*SIZE OF COMMON EVENT BLOCK IN BYTES 
    TYPE byte unsigned;					/*STRUCTURE TYPE CODE FOR CEB 
    STS_OVERLAY union fill;
        STS byte unsigned;				/*STATUS FLAGS FOR CEB 
	STS_BITS structure fill;
            NOQUOTA bitfield;				/*NO QUOTA UPDATE 
            PERM bitfield;				/*PERMANENT CLUSTER 
	end STS_BITS;
    end STS_OVERLAY;
    PID longword unsigned;				/*PID OF CREATOR 
    EFC longword unsigned;				/*EVENT FLAGS (32 BIT VECTOR) 
    WQFL longword unsigned;				/*HEAD OF WAIT QUEUE 
    WQBL longword unsigned;				/*TAIL OF WAIT QUEUE 
    WQCNT_OVERLAY union fill;
        WQCNT word unsigned;				/*WAIT QUEUE COUNT(LENGTH) 
                                                	/*SHMEM FIELDS IN THIS WORD
	WQCNT_FIELDS structure fill;
            LOCK byte unsigned;				/*SHMEM MASTER CEB, ! OF PORT OWNING LOCK 
            PROCCNT byte unsigned;			/*SHMEM MASTER CEB, MAX ! OF PROCESSORS 
	end WQCNT_FIELDS;
    end WQCNT_OVERLAY;
    STATE_OVERLAY union fill;
        STATE word unsigned;				/*CEF WAIT STATE NUMBER 
                                                	/*SHMEM FIELDS IN THIS WORD
	STATE_FIELDS structure fill;
            CREATPORT byte unsigned;			/*SHMEM MASTER CEB, ! OF CREATOR PORT 
            DELETPORT byte unsigned;			/*SHMEM MASTER CEB, ! OF DELETER PORT 
	end STATE_FIELDS;
    end STATE_OVERLAY;
    UIC_OVERLAY union fill;
        UIC longword unsigned;				/*USER IDENT OF CEB CREATOR 
	UIC_FIELDS structure fill;
            FILL_2 byte dimension 2 fill prefix CEBDEF tag $$;
            GRP word unsigned;				/*GROUP NUMBER OF OWNER 
	end UIC_FIELDS;
    end UIC_OVERLAY;
    PROT word unsigned;					/*PROTECTION MASK 
    REFC word unsigned;					/*REFERENCE COUNT FOR CEB 
    EFCNAM character length 16;				/*EVENT CLUSTER TEXT NAME 
    constant "LENGTH" equals . prefix CEB$ tag K;	/*LENGTH OF NORMAL COMMON EVENT BLOCK 
    constant "LENGTH" equals . prefix CEB$ tag C;	/*LENGTH OF NORMAL COMMON EVENT BLOCK 
    
/*
/* THE FOLLOWING FIELDS ARE DEFINED FOR SHARED MEMORY COMMON EVENT BLOCKS.
/* CEB$L_SHB, CEB$W_INDX, AND CEB$L_MASTER ARE CONTAINED IN THE SLAVE CEB WHILE
/* CEB$L_VASLAVE1 IS THE OFFSET IN THE MASTER CEB TO THE FIRST SLAVE CEB.
/*
    SHB_OVERLAY union fill;
        SHB longword unsigned;				/*SHMEM SLAVE CEB, SHMEM CTL BLK ADR 
        VASLAVE1 longword unsigned;			/*SHMEM MASTER CEB, PTR TO 1ST SLAVE CEB 
    end SHB_OVERLAY;
    INDX word unsigned;					/*SHMEM SLAVE CEB, INDEX TO MASTER CEB 
    FILL_1 word fill prefix CEBDEF tag $$;		/*SHMEM SLAVE CEB, 
                                            		/*SHMEM MASTER CEB, FIELDS IN NEXT N
                                            		/* LONGWORDS ARE PROCESSOR REFCNTS
                                            		/* (ONE WORD FOR EACH PROCESSOR)
                                            		/* (OFFSET IS COMPUTED AT RUN-TIME)
    MASTER longword unsigned;				/*SHMEM SLAVE CEB, VA OF MASTER CEB 
    constant SLAVLNG equals . prefix CEB$ tag K;	/*LENGTH OF SHMEM SLAVE COMMON EVENT BLK 
    constant SLAVLNG equals . prefix CEB$ tag C;	/*LENGTH OF SHMEM SLAVE COMMON EVENT BLK 
    
end CEBDEF;

end_module $CEBDEF;


module $CHPCTLDEF;
/*+
/*
/* CHeck Protection ConTroL block definition.  This block contains the
/* information concerning the type of access check being made.
/*
/*-

aggregate CHPCTL structure prefix CHPCTL$;
    ACCESS longword unsigned;			/* Type of access desired
    FLAGS structure longword unsigned;		/* Control flags
	READ bitfield mask;			/* Read access
	WRITE bitfield mask;			/* Write access
	USEREADALL bitfield mask;		/* Try for read access via READALL
    end FLAGS;
    MODE byte unsigned;				/* Access mode of request
    FILL_1 byte dimension 3 fill prefix CHPCTLDEF tag $$;
    constant "LENGTH" equals . prefix CHPCTL$ tag K;
    constant "LENGTH" equals . prefix CHPCTL$ tag C;
end CHPCTL;

end_module $CHPCTLDEF;

module $CHPRETDEF;
/*+
/*
/* CHeck Protection ConTroL RETurn argument block.  This block contains
/* the information needed to return arguments from the protection check.
/*
/*-

aggregate CHPRET structure prefix CHPRET$;
    AUDITLEN word unsigned;			/* Size of the audit ACE buffer
    FILL_1 word fill prefix CHPRETDEF tag $$;
    AUDIT longword unsigned;			/* Address of the audit ACE buffer
    AUDITRET longword unsigned;			/* Address of word to get ACE length
    ALARMLEN word unsigned;			/* Size of the alarm ACE buffer
    FILL_2 word fill prefix CHPRETDEF tag $$;
    ALARM longword unsigned;			/* Address of the alarm ACE buffer
    ALARMRET longword unsigned;			/* Address of word to get ACE length
    MATCHED_ACELEN word unsigned;		/* Size of the matched ACE buffer
    FILL_3 word fill prefix CHPRETDEF tag $$;
    MATCHED_ACE longword unsigned;		/* Address of the matched ACE buffer
    MATCHED_ACERET longword unsigned;		/* Address of word to get ACE length
    PRIVS_USED longword unsigned;		/* Address of longword to get privileges used
    constant "LENGTH" equals . prefix CHPRET$ tag K;
    constant "LENGTH" equals . prefix CHPRET$ tag C;
end CHPRET;

end_module $CHPRETDEF;

module $CIADEF;
/*+
/* CIA - Compound Intrusion Analysis block
/*
/* Contains information about suspected and known intruders
/*-

aggregate CIADEF structure prefix CIA$;
    FLINK longword unsigned;			/* Forward link to next block
    BLINK longword unsigned;			/* Backward link to previous block
    SIZE word unsigned;				/* Size of block
    TYPE byte unsigned;				/* Structure type 
    SUBTYPE BYTE unsigned;			/* Structure subtype
    constant (					/* Source of breakin attempt
	  TERMINAL				/* Unknown user at terminal
	, TERM_USER				/* Known username at terminal
	, NETWORK				/* Network source
	, USERNAME				/* Username of parent process
	) equals 1 increment 1 tag K;
    FLAGS structure word unsigned;		/* Breakin type flags 
	INTRUDER bitfield mask;			/* Entry is an intruder
    end FLAGS;
    COUNT word unsigned;			/* Count of attempts
    TIME quadword unsigned;			/* Expiration time of entry
    DATA character length 56;			/* Data area
    constant "LENGTH" equals . tag K;		/* Length of CIA block
    constant "LENGTH" equals . tag C;		/* Length of CIA block
    
end CIADEF;

end_module $CIADEF;

module $CIBDTDEF;
/*+
/* CIBDT - CI BUFFER DESCRIPTOR TABLE
/*
/* THIS TABLE IS SHARABLE AMONG ALL CI PORTS ON A SYSTEM.  BUFFER
/* DESCRIPTORS (BD'S) ARE ALLOCATED FOR CI BLOCK TRANSFERS.
/*-



aggregate CIBDTDEF structure prefix CIBDT$ origin FILL_2;
    WAITFL longword unsigned;				/*BD WAIT QUEUE FWD LINK 
    WAITBL longword unsigned;				/*BD WAIT QUEUE BACK LINK 
    SIZE word unsigned;					/*STRUCTURE SIZE IN BYTES 
    TYPE byte unsigned;					/*CI STRUCTURE TYPE 
    SUBTYP byte unsigned;				/*CI STRUCT SUBTYPE FOR CI BDT 
    FREEBD longword unsigned;				/*ADDR OF FIRST FREE BD 
    MAXIDX longword unsigned;				/*MAX INDEX INTO BUFFER DESCRIPTORS 
    FILL_1 longword fill prefix CIBDTDEF tag $$;	/*RESERVED LONGWORD 
    constant BDLIST equals . prefix CIBDT$ tag K;	/*START OF BUFFER DESCRIPTORS 
    constant BDLIST equals . prefix CIBDT$ tag C;	/*START OF BUFFER DESCRIPTORS 
    constant "LENGTH"	equals 24  prefix CIBDT tag $C;	/*LENGTH OF NEGATIVE PORTION OF STRUCT 
/*
    FILL_2 byte fill prefix CIBDTDEF tag $$;
end CIBDTDEF;

end_module $CIBDTDEF;


module $CIBDDEF;
/*+
/* BD - CI BUFFER DESCRIPTOR FORMAT
/*-



aggregate CIBDDEF structure prefix CIBD$;
    FLAGS_OVERLAY union fill;
        FLAGS word unsigned;				/*FLAGS WORD 
	FLAGS_BITS structure fill;
            BOFF bitfield length 9;			/* BYTE OFFSET OF START OF BUFFER 
            FILL_1 bitfield length 3 fill prefix CIBDDEF tag $$;/* 3 SPARE BITS 
            AC bitfield mask;				/* ACCESS MODE CHECK ENABLED IF SET 
            ACMOD bitfield length 2;			/* ACCESS MODE REQ'D IN PTE'S 
            V bitfield mask;				/* VALID BIT 
	end FLAGS_BITS;
    end FLAGS_OVERLAY;
    KEY word unsigned;					/*SEQUENCE NUMBER 
    BLEN longword unsigned;				/*LENGTH OF MAPPED BUFFER 
    SVAPTE longword unsigned;				/*SVA OF PTE MAPPING START OF BUFFER 
    CDRP_OVERLAY union fill;
        CDRP longword unsigned;				/*ADDR OF ASSOCIATED CDRP 
        constant "LENGTH" equals . prefix CIBD$ tag K;	/*LENGTH OF A BUFFER DESCRIPTOR 
        constant "LENGTH" equals . prefix CIBD$ tag C;	/*LENGTH OF A BUFFER DESCRIPTOR 
        LINK longword unsigned;				/* OR ADDR OF NEXT FREE DESCRIPTOR 
        
    end CDRP_OVERLAY;
end CIBDDEF;

end_module $CIBDDEF;


module $CIBHANDEF;
/*+
/* CIBHAN - CI BUFFER HANDLE FORMAT
/*-



aggregate CIBHANDEF structure prefix CIBHAN$;
    BOFF longword unsigned;				/*BYTE OFFSET IN LOCAL BUFFER 
    BNAME longword unsigned;				/*NAME OF LOCAL BUFFER 
    RCONID longword unsigned;				/*REMOTE CONNECTION ID 
    constant "LENGTH" equals . prefix CIBHAN$ tag K;	/*LENGTH OF CI BUFFER HANDLE 
    constant "LENGTH" equals . prefix CIBHAN$ tag C;	/*LENGTH OF CI BUFFER HANDLE 
    
end CIBHANDEF;

end_module $CIBHANDEF;


module $CIFQDTDEF;
/*+
/* CIFQDT - CI FREE MESSAGE/DATAGRAM QUEUE DESCRIPTOR TABLE
/*
/* THIS DATA STRUCTURE AND THE QUEUES IT HAS HEADERS FOR MAY BE
/* SHARED AMONG ALL CI'S ON THE SYSTEM.
/*-



aggregate CIFQDTDEF structure prefix CIFQDT$;
    DGSIZ word unsigned;				/*DATAGRAM SIZE (INCL PORT HEADER) 
    MSGSIZ word unsigned;				/*MESSAGE SIZE (INCL PORT HEADER) 
    FILL_1 longword fill prefix CIFQDTDEF tag $$;	/*RESERVED LONGWORD 
    SIZE word unsigned;					/*STRUCTURE SIZE IN BYTES 
    TYPE byte unsigned;					/*CI STRUCTURE TYPE 
    SUBTYP byte unsigned;				/*CI STRUCT SUBTYPE FOR CI FQDT 
    DGCNT word unsigned;				/*SUM OF INITL DG CREDITS FOR ALL CONNX 
    MSGCNT word unsigned;				/*SUM OF INITL MSG CREDITS FOR ALL CONNX 
    DGFL longword unsigned;				/*DG FREE QUEUE FWD LINK 
    DGBL longword unsigned;				/*DG FREE QUEUE BACK LINK 
    MSGFL longword unsigned;				/*MSG FREE QUEUE FWD LINK 
    MSGBL longword unsigned;				/*MSG FREE QUEUE BACK LINK 
    constant "LENGTH" equals . prefix CIFQDT$ tag K;	/*LENGTH OF CI FQDT 
    constant "LENGTH" equals . prefix CIFQDT$ tag C;	/*LENGTH OF CI FQDT 
    
end CIFQDTDEF;

end_module $CIFQDTDEF;


module $CLUBDEF;
/*+
/* CLUB - CLUSTER BLOCK.  
/*
/*	THERE IS ONE CLUB IN A VMS SYSTEM THAT IS PART OF A CLUSTER.
/*	THE CLUB DEFINES THE STATE OF THE THE CLUSTER AS KNOWN TO
/*	THE LOCAL SYSTEM.
/*-

/*
/*	THE CLUB FORK BLOCK (CLUBFKB) IS A SUBBLOCK OF THE CLUB THAT IS
/*	USED WHEN IT NECESSARY TO WAIT IN ORDER TO ALLOCATE MEMORY OR
/*	WHEN IT IS DESIRABLE TO FORK TO ALLOW OTHER FORK PROCESSES A
/*	CHANCE TO RUN.

aggregate CLUBFKBDEF structure prefix CLUBFKB$;
    FORK_BLOCK byte dimension (24);		/* FORK BLOCK TO WAIT IN
    PC2 longword unsigned;			/* SAVED PC
    STATUS structure longword unsigned;		/* CLUSTER FAILOVER STATUS FLAGS
	FKB_BUSY bitfield mask;			/*  FORK BLOCK IN USE FLAG
    end STATUS;
    constant "LENGTH" equals . tag C;		/* LENGTH OF CLUBFKB
    constant "LENGTH" equals . tag K;		/* LENGTH OF CLUBFKB
end CLUBFKBDEF;

/*
/*	THE CLUB POWERFAIL FORK BLOCK (CLUBPWF) IS A SUBBLOCK OF THE CLUB
/*	THAT IS USED TO FORK FROM IPL 31 TO IPL SCS DURING POWER RECOVERY.

aggregate CLUBPWFDEF structure prefix CLUBPWF$;
    FORK_BLOCK byte dimension (24);		/* FORK BLOCK TO WAIT IN
    STATUS structure longword unsigned;		/* BLOCK STATUS FLAGS
	BUSY bitfield mask;			/*  FORK BLOCK IN USE FLAG
    end STATUS;
    constant "LENGTH" equals . tag C;		/* LENGTH OF CLUBPWF
    constant "LENGTH" equals . tag K;		/* LENGTH OF CLUBPWF
end CLUBPWFDEF;

/*
/*	THE CLUSTER FAILOVER CONTROL BLOCK (CLUFCB) IS A SUBBLOCK OF
/*	THE CLUB THAT IS USED TO SEQUENCE FAILOVER ACTIONS IN A CLUSTER.
/*

aggregate CLUFCBDEF structure prefix CLUFCB$;
    FORK_BLOCK byte dimension (24);		/* FORK BLOCK TO WAIT IN
    STEP longword unsigned;			/* CURRENT FAILOVER STEP INDEX
    ID longword unsigned;			/* FAILOVER INSTANCE IDENTIFICATION
    STATUS structure longword unsigned;		/* CLUSTER FAILOVER STATUS FLAGS
	ACTIVE bitfield mask;			/*  FAILOVER ROUTINE ACTIVE
	PENDING bitfield mask;			/*  FAILOVER PENDING
	SYNC_NODE bitfield mask;		/*  LOCAL NODE IS SYNCHRONIZER
	FKB_BUSY bitfield mask;			/*  FORK BLOCK IN USE FLAG
	WAITING bitfield mask;			/*  WAITING FOR NODES TO RESPOND
    end STATUS;
    SYNC_CSB longword unsigned;			/* ADDRESS OF CSB OF SYNCHRONIZING SYSTEM
    NODEMAP byte dimension (32);		/* BITMAP OF ALL INVOLVED NODES
    RESPMAP byte dimension (32);		/* BITMAP OF NODES READY FOR A STEP
    constant "LENGTH" equals . tag C;		/* LENGTH OF CLUFCB
    constant "LENGTH" equals . tag K;		/* LENGTH OF CLUFCB
end CLUFCBDEF;

aggregate CLUBDEF structure prefix CLUB$;
    CSBQFL longword unsigned;			/* CSB QUEUE FORWARD LINK
    CSBQBL longword unsigned;			/* CSB QUEUE BACKWARD LINK
    SIZE word unsigned;				/* SIZE OF CLUB IN BYTES
    TYPE byte unsigned;				/* STRUCTURE TYPE 
    SUBTYPE byte unsigned;			/* STRUCTURE SUBTYPE
    POLL_CTX longword unsigned;			/* SCS POLLER CONTEXT
    LOCAL_CSB longword unsigned;		/* ADDRESS OF THE CSB FOR LOCAL SYSTEM
    JNL_DISPT longword unsigned;		/* DISPATCH FOR INCOMING JNL MESSAGES
    JNL_FAIL longword unsigned;			/* JOURNALING FAIL OVER ENTRY POINT
    FLAGS structure longword unsigned;		/* CLUSTER STATUS FLAGS
	CLUSTER bitfield mask;			/*  THIS NODE IS MEMBER OF CLUSTER
	QF_ACTIVE bitfield mask;		/*  QUORUM FILE IS READABLE, CONTRIBUTE TO STATIC QUORUM
	SHUTDOWN bitfield mask;			/*  NODE READY FOR CLUSTER SHUTDOWN
	FILL_0 bitfield length 5 fill;		/*  PAD TO BYTE BOUNDARY
	STS_PPHASE bitfield mask;		/*  STATUS ANALYZER POLLING PHASE
	STS_PH0 bitfield mask;			/*  STATUS ANALYZER, PHASE 0 SEEN
	STS_PH1B bitfield mask;			/*  STATUS ANALYZER, PHASE 1 (COORD CNX BROKEN) SEEN
	STS_PH1 bitfield mask;			/*  STATUS ANALYZER, PHASE 1 (COORD CNX OK) SEEN
	STS_PH2 bitfield mask;			/*  STATUS ANALYZER, PHASE 2 SEEN
	FILL_01 bitfield length 3 fill;		/*  PAD TO BYTE BOUNDARY
	FKB_BUSY bitfield mask;			/*  FORK BLOCK IN USE
	UNLOCK bitfield mask;			/*  UNLOCK REQUESTED
	NO_FORM bitfield mask;			/*  PROHIBIT NODE FROM FORMING A NEW CLUSTER
	INIT bitfield mask;			/*  READY FOR CLUSTER JOIN/FORMATION
	BACKOUT bitfield mask;			/*  MUST EVENTUALLY BACK-OUT TRANSITION
	FILL_1 bitfield fill;			/*  FILLER
	FILL_2 bitfield fill;			/*  FILLER
	LOST_CNX bitfield mask;			/*  CONNECTION TO CLUSTER MEMBER HAS BEEN LOST
	QF_FAILED_NODE bitfield mask;		/*  A NODE HAS BEEN FAILED OUT
	QF_VOTE bitfield mask;			/*  QUORUM DISK IS CONTRIBUTING A (STATIC) VOTE
	QF_NEWVOTE bitfield mask;		/*  STAGING FOR QF_VOTE
	ADJ_QUORUM bitfield mask;		/*  QUORUM ADJUSTMENT REQUESTED
	QUORUM bitfield mask;			/*  CLUSTER IS IN QUORUM
	TRANSITION bitfield mask;		/*  STATE TRANSITION IN PROGRESS
	QF_DYNVOTE bitfield mask;		/*  QUORUM FILE CAN CONTRIBUTE TO DYNAMIC QUORUM
    end FLAGS;
    QUORUM word unsigned;			/* CLUSTER QUORUM
    VOTES word unsigned;			/* CLUSTER VOTES
    NODES word unsigned;			/* NODES IN CLUSTER
    FSYSID byte dimension (6);			/* FOUNDING NODE'S SYSID
    FTIME quadword;				/* FOUNDING TIME
    LST_XTN longword unsigned;    		/* LAST COMPLETED TRANSACTION NUMBER
    LST_COORD longword unsigned;		/* LAST COMPLETED TRANSACTION COORDINATOR CSID
    LST_TIME quadword;				/* LAST COMPLETED TRANSACTION TIME-STAMP
    LST_CODE byte unsigned;			/* LAST COMPLETED TRANSACTION CODE
    LST_PHASE byte unsigned;			/* LAST COMPLETED TRANSACTION CODE
    NEWQDVOTES word unsigned;			/* STAGING FOR QDVOTES
    CUR_XTN longword unsigned;    		/* CURRENT TRANSACTION NUMBER
    CUR_COORD longword unsigned;		/* CURRENT TRANSACTION COORDINATOR CSID
    CUR_TIME quadword;				/* CURRENT TRANSACTION TIME-STAMP
    CUR_CODE byte unsigned;			/* TRANSACTION CODE
    CUR_PHASE byte unsigned;			/* TRANSACTION PHASE
    MSGCNT word unsigned;			/* OUTSTANDING/WAITING MESSAGE COUNT
    COORD longword unsigned;			/* COORDINATOR'S CSB ADDRESS
    LOCAL_CSID structure longword unsigned;	/* LOCAL SYSTEM CSID
	LOCAL_CSID_IDX word unsigned;		/* SLOT INDEX
	LOCAL_CSID_SEQ word unsigned;		/* SEQUENCE NUMBER
    end LOCAL_CSID;
    NEXT_CSID word unsigned;			/* INDEX OF NEXT CSID TO ASSIGN
    FIRST_INDEX word unsigned;			/* INDEX OF FIRST CSID ASSIGNED
    MAX_XTN longword unsigned;			/* LARGEST TRANSACTION ID SEEN
    RETRYCNT longword unsigned;			/* RESOURCE ALLOCATION RETRIES AVAILABLE
    CTX0 longword unsigned;			/* LEVEL 0 CONTEXT AREA
    RET1 longword unsigned;			/* LEVEL 1 SUBROUTINE RETURN
    CTX1 longword unsigned;			/* LEVEL 1 CONTEXT AREA
    RET2 longword unsigned;			/* LEVEL 2 SUBROUTINE RETURN
    CTX2 longword unsigned;			/* LEVEL 2 CONTEXT AREA
    TQE longword unsigned;			/* ADDRESS OF TIMER ENTRY
    CSPFL longword unsigned;			/* Q OF FORK-INITIATED REQ'S FOR CSP
    CSPBL longword unsigned;			/* ...
    CSPIPID longword unsigned;			/* PID OF CLUSTER SERVER (FOR SCH$WAKE)
    NEWTIME quadword unsigned;			/* NEW VALUE OF TIME
    NEWTIME_REF quadword unsigned;		/* LOCAL REFERENCE FOR NEW TIME
    NEWQUORUM word unsigned;			/* NEW VALUE FOR QUORUM
    ADJ_QUORUM word unsigned;			/* QUORUM ADJUSTMENT REQUESTED VALUE
    FMERIT longword unsigned;			/* FIGURE OF MERIT FOR OPTIMAL CLUSTER
    MEMSEQ word unsigned;			/* MEMBERSHIP STATE SEQUENCE NUMBER
    QDVOTES word unsigned;			/* VOTES HELD BY QUORUM DISK
    RANDOM longword unsigned;			/* RANDOM NUMBER GENERATOR CONTEXT
    CLUDCB longword unsigned;			/* ADDRESS OF QUORUM DISK CONTROL BLOCK
    QDNAME character dimension (16);		/* QUORUM DISK FULLDEVNAM
    FOREIGN_CLUSTER longword unsigned;		/* SHIFT REGISTER INDICATING FOREIGN CLUSTER SEEN
    FORK_BLOCK byte dimension (CLUBFKB$K_LENGTH); /* FORK BLOCK TO WAIT IN (CLUBFKB SUB-STRUCTURE)
    NODEMAP byte dimension (32);		/* BITMAP OF ALL POSSIBLE NODES
    CLUFCB byte dimension (CLUFCB$K_LENGTH);	/* CLUSTER FAILOVER CONTROL BLOCK
    HANG_FKB byte dimension (24);		/* FORK BLOCK TO USE TO BLOCK ACTIVITY AT IPL 4
    CLUBPWF byte dimension (CLUBPWF$K_LENGTH);	/* FORK BLOCK TO USE DURING POWER RECOVERY
    constant "LENGTH" equals . tag C;		/* LENGTH OF CLUB 
    constant "LENGTH" equals . tag K;		/* LENGTH OF CLUB 
end CLUBDEF;

end_module $CLUBDEF;

module $CLUDCBDEF;

/*+
/* CLUDCB - Cluster Quorum Disk Control Block
/*-

aggregate CLUDCB structure prefix CLUDCB$;

    CLUDCBFL longword unsigned;		/* Forward Link (not used)
    CLUDCBBL longword unsigned;		/* Backward Link (not used)
    SIZE word unsigned;			/* Size of CLUDCB (bytes)
    TYPE byte unsigned;			/* Structure type
    SUBTYPE byte unsigned;		/* Structure subtype
    UCB longword unsigned;		/* Address of quorum disk UCB
    IRP longword unsigned;		/* Address of IRP
    TQE longword unsigned;		/* Address of timer queue entry
    ACT_COUNT longword unsigned;	/* Saved activity counter
    QFLBN longword unsigned;		/* Quorum file logical block number
    STATE structure word unsigned;	/* Quorum disk state bits
	QS_NOT_READY bitfield mask;	/* Not ready
	QS_READY bitfield mask;		/* Ready
	QS_ACTIVE bitfield mask;	/* Active
	QS_CLUSTER bitfield mask;	/* Active and this node is a cluster member
	QS_VOTE bitfield mask;		/* Potential vote
    end STATE;
    FLAGS structure word unsigned;	/* CLUDCB status bits
	QF_TIM bitfield mask;		/* Read or write timed out
	QF_RIP bitfield mask;		/* Read in progress
	QF_WIP bitfield mask;		/* Write in progress
	QF_ERROR bitfield mask;		/* Quorum disk error has been reported
	QF_CSPACK bitfield mask;	/* CSP request has been acknowledged
	QF_FIRST_ERR bitfield mask;	/* First error has already been seen
	QF_WRL_ERR bitfield mask;	/* Quorum disk is write-locked
    end flags;
    COUNTER byte unsigned;		/* Iteration counter
    BUFFER character length 512+4;	/* Quorum file buffer

    constant "LENGTH" equals . prefix CLUDCB$ tag K; /* Length of CLUDCB
    constant "LENGTH" equals . prefix CLUDCB$ tag C; /* Length of CLUDCB

    /* The quorum disk is specified with 4 sysgen parameters. DISK_QUORUM1
    /* to DISK_QUORUM4. Each parameter can specify 4 bytes.

    constant DISK_QUORUM equals 16 prefix CLUDCB$ tag S;

end CLUDCB;

end_module $CLUDCBDEF;

 module $CLUOPTDEF;

/*+
/* CLUOPT - Cluster Optimal ReConfiguration Context Block
/*-

aggregate CLUOPT structure prefix CLUOPT$;
    PREV longword unsigned;		/* Link to previous CLUOPT block
    BEST longword fill;			/* Link to best attained CLUOPT block
    SIZE word unsigned;			/* Size of CLUOPT (bytes)
    TYPE byte unsigned;			/* Structure type
    SUBTYPE byte unsigned;		/* Structure subtype
    CMERIT longword unsigned;		/* Figure of merit of nodes in CMAP
    ACMERIT longword unsigned;		/* Figure of merit of nodes in AMAP + CMAP
    CMAP byte dimension (32);		/* Map of nodes in proposed cluster
    AMAP byte dimension (32);		/* Map of nodes available for cluster
    RMAP byte dimension (32);		/* Map of nodes remaining for consideration
    constant "LENGTH" equals . tag K;	/* Length of CLUOPT
    constant "LENGTH" equals . tag C;	/* Length of CLUOPT
end CLUOPT;

end_module $CLUOPTDEF;

module $CONDEF;
/*+
/*
/* Console function codes (defined in SRM).
/*
/*-


constant BOOTCPU equals 2  prefix CON tag $C;		/* Boot function code
constant CLRWARM equals 3  prefix CON tag $C;		/* Clear warm start flag
constant CLRCOLD equals 4  prefix CON tag $C;		/* Clear cold start flag

end_module $CONDEF;


module $CRBDEF;
/*+
/* CRB - CHANNEL REQUEST BLOCK
/*
/* THERE IS ONE CHANNEL REQUEST BLOCK FOR EACH SET OF DEVICES WHOSE
/* ACCESS TO A SET OF CONTROLLERS MUST BE SYNCHRONIZED. EACH CHANNEL
/* CONTROL BLOCK ALLOWS UP TO FOUR CONTROLLERS TO WHICH THE INDIVIDUAL
/* DEVICES CAN BE ATTACHED.
/*-



aggregate CRBDEF structure prefix CRB$;
    WQFL longword unsigned;				/*WAIT QUEUE FORWARD LINK 
    WQBL longword unsigned;				/*WAIT QUEUE BACKWARD LINK 
    SIZE word unsigned;					/*SIZE OF CRB IN BYTES 
    TYPE byte unsigned;					/*STRUCTURE TYPE FOR CRB 
    TT_TYPE byte unsigned;				/*controler type (DZ11, DZ32)
    REFC word unsigned;					/*REFERENCE COUNT OF UCB'S 
    MASK_OVERLAY union fill;
        "MASK" byte unsigned;				/*CHANNEL ALLOCATION MASK 
	MASK_BITS structure fill;
            BSY bitfield mask;				/* CHANNEL IS BUSY (1=YES) 
	end MASK_BITS;
    end MASK_OVERLAY;
    FILL_2 byte fill prefix CRBDEF tag $$;		/*SPARE UNUSED BYTE 
    AUXSTRUC longword unsigned;				/*Auxiliary structure addr (CDDB for class driver) 
    TIMELINK_OVERLAY union fill;
	TIMELINK longword unsigned;			/*Thread of CRB's for periodic wakeup 
	TT_MODEM longword unsigned;			/*modem control timer thread
    end TIMELINK_OVERLAY;
    DUETIME_OVERLAY union fill;
	DUETIME longword unsigned;			/*Due time for periodic wakeup 
	DZ_MODEM longword unsigned;			/*DZ11 modem transition detection timer thread
    end DUETIME_OVERLAY;
    TOUTROUT_OVERLAY union fill;
	TOUTROUT longword unsigned;			/*Address of periodic wakeup routine 
	TTY_TOUTROUT_FIELDS structure fill;
	    DZ_RING byte unsigned;			/*last sampled ring for DZ11
	    DZ_CARRIER byte unsigned;			/*last sampled carrier for DZ11
	    DZ_DTR byte unsigned;			/*last output DTR for DZ11
	    TT_TIMREFC byte unsigned;			/*lines with active modem timers
	end TTY_TOUTROUT_FIELDS;
    end TOUTROUT_OVERLAY;
    LINK longword unsigned;				/*ADDRESS OF SECONDARY CRB 
    INTD longword unsigned dimension 9;			/*INTERRUPT TRANSFER VECTOR 
    constant "LENGTH" equals . prefix CRB$ tag K;	/*LENGTH OF STANDARD CRB 
    constant "LENGTH" equals . prefix CRB$ tag C;	/*LENGTH OF STANDARD CRB 
    INTD2 longword unsigned dimension 9;		/*SECOND INTERRUPT VECTOR 
end CRBDEF;

end_module $CRBDEF;


module $VECDEF;

/*+
/* CRB INTERRUPT TRANSFER VECTOR STRUCTURE DEFINITIONS
/*-



aggregate VECDEF structure prefix VEC$;
    DISPATCH quadword unsigned;				/*REGISTER SAVE AND DISPATCH INSTRUCTIONS 
    IDB longword unsigned;				/*ADDRESS OF ASSOCIATED IDB 
    INITIAL longword unsigned;				/*CONTROLLER INITIALIZATION ENTRY ADDRESS 
    MAPREG_OVERLAY union fill;
        MAPREG word unsigned;				/*STARTING MAP REGISTER ALLOCATED 
	MAPREG_BITS structure fill;
            MAPREG bitfield length 15;			/* MAP REGISTER NUMBER 
            MAPLOCK bitfield mask;			/* MAP REGISTER ALLOCATION PERMANENT 
	end MAPREG_BITS;
    end MAPREG_OVERLAY;
    NUMREG byte unsigned;				/*NUMBER OF MAP REGISTERS ALLOCATED 
    DATAPATH_OVERLAY union fill;
        DATAPATH byte unsigned;				/*BUFFERED DATAPATH ALLOCATED 
	DATAPATH_BITS structure fill;
            DATAPATH bitfield length 5;			/* DATAPATH NUMBER 
            LWAE bitfield mask;				/* LONGWORD ACCESS ENABLED 
            FILL_1 bitfield fill prefix VECDEF tag $$;	/* SPARE BIT 
            PATHLOCK bitfield mask;			/* DATAPATH PERMANENT 
	end DATAPATH_BITS;
    end DATAPATH_OVERLAY;
    ADP longword unsigned;				/*ADDRESS OF ADP 
    UNITINIT longword unsigned;				/*ADDRESS OF UNIT INITIALIZE 
    START longword unsigned;				/*ADDRESS OF UNIT START 
    UNITDISC longword unsigned;				/*ADDRESS OF UNIT DISCONNECT 
    constant "LENGTH" equals . prefix VEC$ tag K;	/*LENGTH OF STANDARD DISPATCHER 
    constant "LENGTH" equals . prefix VEC$ tag C;	/*LENGTH OF STANDARD DISPATCHER 
end VECDEF;

end_module $VECDEF;


module $CSBDEF;
/*+
/* CSB - CLUSTER SYSTEM BLOCK.  
/*
/*	THERE IS ONE CSB FOR EACH SYSTEM IN THE CLUSTER.
/*-


aggregate CSBDEF structure prefix CSB$;
    SYSQFL longword unsigned;			/* SYSTEM QUEUE FORWARD LINK
    SYSQBL longword unsigned;			/* SYSTEM QUEUE BACKWARD LINK
    SIZE word unsigned;				/* SIZE OF CSB IN BYTES
    TYPE byte unsigned;				/* STRUCTURE TYPE 
    SUBTYPE byte unsigned;			/* STRUCTURE SUBTYPE
    CDT longword unsigned;			/* CDT ADDRESS
    PDT longword unsigned;			/* PDT ADDRESS
    SENTQFL longword unsigned;			/* SENT LIST HEAD LINK
    SENTQBL longword unsigned;			/* SENT LIST TAIL LINK
    RESENDQFL longword unsigned;		/* RESEND LIST HEAD LINK
    RESENDQBL longword unsigned;		/* RESEND LIST TAIL LINK
    WARMCDRPQFL longword unsigned;		/* WARM CDRP QUEUE FORWARD LINK
    WARMCDRPQBL longword unsigned;		/* WARM CDRP QUEUE BACKWARD LINK
    SENDSEQNM word unsigned;			/* NEXT SEQUENCE NUMBER TO SEND
    RCVDSEQNM word unsigned;			/* LAST SEQUENCE NUMBER RECEIVED
    ACKRSEQNM word unsigned;			/* LAST ACK RECEIVED SEQ. NUM.
    UNACKEDMSGS byte unsigned;			/* NUMBER OF UNACKED MESSAGES
    REMACKLIM byte unsigned;			/* REMOTE SIDE'S ACK LIMIT
    CURRCDRP longword unsigned;			/* ADDRESS OF CDRP IN CRITICAL SECTION
    SWINCARN quadword unsigned;			/* REMOTE SOFTWARE INCARN. NUM.
    ECOLVL byte unsigned;			/* PROTOCOL ECO LEVEL
    VERNUM byte unsigned;			/* PROTOCOL VERSION NUMBER
    WARMCDRPS byte unsigned;			/* NUMBER OF CDRPS ON FREE QUEUE
    STATE byte unsigned;			/* STATE OF CONNECTION
    constant (					/* STATE VALUES:
	OPEN,					/*  OPEN
	STATUS,					/*  SENDING/WAITING FOR STATUS
	RECONNECT,				/*  ATTEMPTING TO RECONNECT
	NEW,					/*  BRAND NEW BLOCK
	CONNECT,				/*  ATTEMPTING INITIAL CONNECTION
	ACCEPT,					/*  ACCEPTING INITIAL CONNECTION
	DISCONNECT,				/*  DISCONNECT IN PROGRESS
	REACCEPT,				/*  ACCEPTING RECONNECT REQUEST
	WAIT,					/*  TIME-OUT IN PROGRESS
	DEAD,					/*  NO CONNECTION POSSIBLE
	LOCAL					/*  LOCAL SYSTEM CSB
	    ) equals 1 increment 1 tag K;
    TQE longword unsigned;			/* ADDRESS OF TIMER QUEUE ENTRY
    TIMEOUT longword unsigned;			/* TIME TO GIVE UP RECONNECTING
    CSID structure longword unsigned;		/* Cluster System ID
	CSID_IDX word unsigned;			/* Slot index
	CSID_SEQ word unsigned;			/* Sequence number
    end CSID;
    VOTES word unsigned;			/* VOTES HELD BY NODE
    QUORUM word unsigned;			/* QUORUM SET IN NODE
    LCKDIRWT word unsigned;			/* LOCK MANAGER DISTRIBUTED DIRECTORY WEIGHT
    QDVOTES word unsigned;			/* VOTES ASSIGNED TO QUORUM DISK
    PARTNERQFL longword unsigned;		/* LISTHEAD FWD PTR FOR BLOCK-XFER PARTNER BTXs
    PARTNERQBL longword unsigned;		/* LISTHEAD BACK PTR FOR BLOCK-XFER PARTNER BTXs
    STATUS structure longword unsigned;		/* STATUS OF NODE IN CLUSTER
	/* THE FOLLOWING BITS ARE ALWAYS MEANINGFUL
	LONG_BREAK bitfield mask;		/*  LONG BREAK IN CONNECTION
	MEMBER bitfield mask;			/*  NODE IS MEMBER OF LOCAL CLUSTER
	REMOVED bitfield mask;			/*  NODE REMOVED FROM CLUSTER
	QF_SAME bitfield mask;			/*  REMOTE QUORUM DISK MATCHES LOCAL DISK
	FILL_2 bitfield length 4 fill;		/*  PAD TO BYTE BOUNDARY
    	/*  THE FOLLOWING THREE BITS ARE SIGNIFICANT WHILE FORMING/JOINING
	/*  A CLUSTER
	CLUSTER bitfield mask;			/*  REMOTE NODE IS CLUSTER MEMBER
	QF_ACTIVE bitfield mask;		/*  REMOTE NODE'S QUORUM FILE IS READABLE
	    					/*    AND MATCHES THIS NODE'S FILE
	SHUTDOWN bitfield mask;			/*  REMOTE NODE READY FOR CLUSTER SHUTDOWN
	FILL_3 bitfield length 5 fill;		/*  PAD TO THIRD BYTE BOUNDARY
	/* THE FOLLOWING BITS ARE MEANINGFUL IF THIS NODE IS THE COORDINATOR
	LOCKED bitfield mask;			/*  NODE LOCKED BY COORDINATOR
	SELECTED bitfield mask;			/*  NODE SELECTED BY COORDINATOR
	FILL_5 bitfield length 6 fill;		/*  PAD TO BYTE BOUNDARY
	/* THE FOLLOWING BITS ARE OF LOCAL SIGNIFICANCE ONLY
	LOCAL bitfield mask;			/*  MARK CSB FOR LOCAL SYSTEM
	STATUS_RCVD bitfield mask;		/*  STATUS RECEIVED FROM REMOTE SYSTEM
	SEND_STATUS bitfield mask;		/*  NEED TO SEND STATUS TO REMOTE SYSTEM
    end STATUS;
    CLUB longword unsigned;			/* ADDRESS OF CLUB
    SB longword unsigned;			/* ADDRESS OF SB FOR REMOTE SYSTEM
    REF_CNT byte unsigned;			/* REFERENCE COUNT
    FILL_4 byte fill;				/* PAD to word boundary
    NODES word unsigned;			/* Number of nodes in remote cluster
    CNX_STS_R0 word unsigned;			/* CONNECTION REQUEST R0 STATUS
    CNX_STS_R1 word unsigned;			/* CONNECTION REQUEST R1 STATUS
    REFTIME quadword;				/* CREATION/ADDITION/REMOVAL TIME
    CNCT byte dimension (16);			/* CONNECT/ACCEPT DATA AREA
    NODEMAP byte dimension (32);		/* BITMAP OF NODE CONNECTIVITY
    constant "LENGTH" equals . tag C;		/* LENGTH OF CSB 
    constant "LENGTH" equals . tag K;		/* LENGTH OF CSB 
end CSBDEF;

end_module $CSBDEF;

module $CXBDEF;
/*+
/* CXB - COMPLEX CHAINED BUFFER
/*
/* THESE OFFSETS ARE USED IN THE HEADER OF DISJOINT SEGMENTS
/* WHICH ARE TO BE PRESENTED TO THE USER AS A UNIT.
/*
/*-

aggregate CXBDEF structure prefix CXB$;
    FL longword unsigned;			/*FORWARD QUEUE LINK 
    BL longword unsigned;			/*BACKWARD QUEUE LINK 
    SIZE word unsigned;				/*BLOCK SIZE 
    TYPE byte unsigned;				/*BLOCK TYPE 
    CODE byte unsigned;				/*BUFFER CODE 
    "LENGTH" word unsigned;			/*LENGTH OF DATA 
    OFFSET word unsigned;			/*OFFSET TO START OF NSP MESSAGE 
    LINK_OVERLAY union fill;
        LINK longword unsigned;			/*LINK WORD FOR CHAINED DATA MESSAGE 
        CHANNEL word unsigned;			/* STORE CHANNEL NUMBER FOR AST 
    end LINK_OVERLAY;
    IRP longword;				/*IRP ADDRESS FOR TRANSMITS 
    BOFF word unsigned;				/*OFFSET TO DATALINK DATA
    BCNT word unsigned;				/*SIZE OF DATALINK DATA
    END_ACTION longword unsigned;		/*POINTER TO I/O DONE ROUTINE
    SPARE1 longword unsigned;			/*RESERVED
    SPARE0 longword unsigned;			/*RESERVED
    constant "LENGTH" equals . prefix CXB$ tag K; /*LENGTH OF A STANDARD CXB 
    constant "LENGTH" equals . prefix CXB$ tag C; /*LENGTH OF A STANDARD CXB 

    DLL_OVERLAY union fill;
	DLL character length 32;		/*SCRATCH AREA FOR DATALINK LAYER 
	STATION quadword unsigned;		/*REMOTE STATION ADDRESS
    end DLL_OVERLAY;
    constant DLL  equals 32  prefix CXB tag $C;	/*SIZE OF CXB$T_DLL 
						/*** this field must be quadword
						/*** aligned
    constant HEADER equals . prefix CXB$ tag K;	/*CXB SIZE UP TO THIS POINT 
    constant HEADER equals . prefix CXB$ tag C; /*CXB SIZE UP TO THIS POINT 

    constant TRAILER equals 4  prefix CXB tag $C; /*SPACE AFTER CXB DATA FOR CRC CODE 
    FILL_1 longword fill prefix CXBDEF tag $$;	  /*THIS REPRESENTS THE SPACE TAKEN FOR 
                                            	  /*THE CRC TRAILER
    constant OVERHEAD equals . prefix CXB$ tag K; /*CXB$C_HEADER + CXB$C_TRAILER 
    constant OVERHEAD equals . prefix CXB$ tag C; /*CXB$C_HEADER + CXB$C_TRAILER 
end CXBDEF;

end_module $CXBDEF;


module $DDBDEF;
/*+
/* DDB - DEVICE DATA BLOCK
/*
/* THERE IS ONE DEVICE DATA BLOCK FOR EACH CONTROLLER IN A SYSTEM.
/*+



aggregate DDBDEF structure prefix DDB$;
    LINK longword unsigned;				/*ADDRESS OF NEXT DDB IN LIST (0=LAST) 
    UCB longword unsigned;				/*ADDRESS OF FIRST UCB FOR THIS DDB 
    SIZE word unsigned;					/*SIZE OF DDB IN BYTES 
    TYPE byte unsigned;					/*TYPE OF DATA STRUCTURE FOR DDB 
    FILL_1 byte fill prefix DDBDEF tag $$;		/*SPARE UNUSED BYTE 
    DDT longword unsigned;				/*ADDRESS OF THE DRIVER DISPATCH TABLE 
    ACPD_OVERLAY union fill;
        ACPD longword unsigned;				/*NAME OF DEFAULT ACP FOR DEVICE UNITS 
	ACPD_FIELDS structure fill;
            FILL_4 byte dimension 3 fill prefix DDBDEF tag $$;
            ACPCLASS byte unsigned;			/*CLASS CODE OF DEFAULT ACP 
            	 					/*ACP CLASS CODE FOR DISKS 
            constant(
                  PACK					/*LARGE DISK PACKS 
                , CART					/*DISK CARTRIDGES 
                , SLOW					/*SLOW (CHEAP) DISKS (E.G., FLOPPY) 
                , TAPE					/*BLOCK STRUCTURED TAPE (E.G., TU58) 
                ) equals 1 increment 1  prefix DDB tag $K;
	end ACPD_FIELDS;
    end ACPD_OVERLAY;

    NAME_OVERLAY union fill;				/* GENERIC PATHNAME 
	NAME character length 16;			/*   OF THE DEVICE 
							/* AS AN
	NAME_ASCIC structure fill;			/*   ASCIC STRUCTURE
	    NAME_LEN byte unsigned;			/* 	CHARACTER COUNT
	    NAME_STR character length 15;		/* 	CHARACTER STRING
	end NAME_ASCIC;
    end NAME_OVERLAY;

    DRVNAM_OVERLAY union fill;				/* DEVICE DRIVER NAME
	DRVNAME character length 16;			/*
							/* AS AN
	DRVNAM_ASCIC structure fill;			/*   ASCIC STRUCTURE
	    DRVNAM_LEN byte unsigned;			/* 	CHARACTER COUNT
	    DRVNAM_STR character length 15;		/* 	CHARACTER STRING
	end DRVNAM_ASCIC;
    end DRVNAM_OVERLAY;

    SB longword unsigned;				/*ADDR OF SYSTEMBLOCK
    CONLINK longword unsigned;				/*NEXT DDB IN CONNECTION SUB-CHAIN
    ALLOCLS longword unsigned;				/*DEVICE ALLOCATION CLASS
    "2P_UCB" structure longword unsigned;		/* ADDRESS OF FIRST UCB ON SECONDARY PATH
	DP_UCB longword unsigned;			/* OLD STYLE SYNONYM FOR ABOVE
    end "2P_UCB";
    constant "LENGTH" equals . prefix DDB$ tag K;	/*LENGTH OF STANDARD DDB 
    constant "LENGTH" equals . prefix DDB$ tag C;	/*LENGTH OF STANDARD DDB 
end DDBDEF;

end_module $DDBDEF;


module $DDTDEF;
/*+
/* DDT - DRIVER DISPATCH TABLE
/*
/* EACH DEVICE DRIVER HAS A DRIVER DISPATCH TABLE.
/*-



aggregate DDTDEF structure prefix DDT$;
    START longword unsigned;				/*ADDRESS OF DRIVER START I/O ROUTINE 
    UNSOLINT longword unsigned;				/*ADDRESS OF UNSOLICITED INTERRUPT ROUTINE 
    FDT longword unsigned;				/*ADDRESS OF FUNCTION DECISION TABLE 
    CANCEL longword unsigned;				/*ADDRESS OF CANCEL I/O ENTRY POINT 
    REGDUMP longword unsigned;				/*ADDRESS OF DEVICE REGISTER DUMP ROUTINE 
    DIAGBUF word unsigned;				/*SIZE OF DIAGNOSTIC BUFFER IN BYTES 
    ERRORBUF word unsigned;				/*SIZE OF ERROR LOG BUFFER IN BYTES 
    UNITINIT longword unsigned;				/*UNIT INITIALIZATION ENTRY POINT 
    ALTSTART longword unsigned;				/*ALTERNATE START I/O ENTRY POINT 
    MNTVER longword unsigned;				/*ADDRESS OF MOUNT VERIFICATION ROUTINE 
    CLONEDUCB longword unsigned;			/*ADDRESS OF CLONED UCB ENTRY POINT
    FDTSIZE word unsigned;				/*SIZE OF FDT IN BYTES 
    filler word fill;					{ filler to gain longword alignment
    MNTV_SSSC longword unsigned;			/*ADDRESS OF SHADOW SET STATE CHANGE MV ENTRY
    MNTV_FOR longword unsigned;				/*ADDRESS OF FOREIGN DEVICE MV ENTRY
    MNTV_SQD longword unsigned;				/*ADDRESS OF SEQUENTIAL DEVICE MV ENTRY
    constant "LENGTH" equals . prefix DDT$ tag K;	/*LENGTH OF DDT 
    constant "LENGTH" equals . prefix DDT$ tag C;	/*LENGTH OF DDT 
    
end DDTDEF;

end_module $DDTDEF;

module $DJIDEF;
/*
/* Item codes for interface from job controller to LOGINOUT.
/*
aggregate ITEM_HEADER structure prefix DJI$;
    ITEM_SIZE		word unsigned;		/* Item size
    ITEM_CODE		word unsigned;		/* Item code
	constant (				{  Define BATCH_OUTPUT items
	    CPU_MAXIMUM				/* (longword)	CPU maximum (10 ms units)
	,   FILE_IDENTIFICATION			/* (28 bytes)	DVI, FID, DID of command procedure
	,   FLAGS				/* (longword)	flags
	,   JOB_NAME				/* (string)	job name
	,   LOG_QUEUE				/* (string)	log file queue
	,   LOG_SPECIFICATION			/* (string)	log file specification
	,   PARAMETER_1				/* (string)	value of P1
	,   PARAMETER_2				/* (string)	value of P2
	,   PARAMETER_3				/* (string)	value of P3
	,   PARAMETER_4				/* (string)	value of P4
	,   PARAMETER_5				/* (string)	value of P5
	,   PARAMETER_6				/* (string)	value of P6
	,   PARAMETER_7				/* (string)	value of P7
	,   PARAMETER_8				/* (string)	value of P8
	,   RESTART				/* (string)	value of BATCH$RESTART
	,   USERNAME				/* (string)	username
	,   WSDEFAULT				/* (longword)	working set default
	,   WSEXTENT				/* (longword)	working set extent
	,   WSQUOTA				/* (longword)	working set quota
	) equals 1 increment 1 prefix DJI$;
	constant (				{  Define BATCH_INPUT items
	    INPUT_FLAGS				/* (longword)	flags
	,   CONDITION_VECTOR			/* (1 to 3 longwords) error conditions
	,   FILE_SPECIFICATION			/* (string)	filespec of failed logfile
	) equals 32769 increment 1 prefix DJI$;
end;
/*
/* Structure of FLAGS item.
/*
aggregate FLAGS structure fill prefix DJI$;
    FLAGS structure longword unsigned;
	DELETE_FILE		bitfield mask;	/* delete command procedure
	LOG_DELETE		bitfield mask;	/* delete log file
	LOG_NULL		bitfield mask;	/* log specification is NLA0:
	LOG_SPOOL		bitfield mask;	/* spool log file
	NOTIFY			bitfield mask;	/* spool log file with /NOTIFY
	RESTARTING		bitfield mask;	/* job is restarting
	TERMINATE		bitfield mask;	/* job should terminate
	USE_CPU_MAXIMUM		bitfield mask;	/* use specified CPU_MAXIMUM
	USE_WSDEFAULT		bitfield mask;	/* use specified WSDEFAULT
	USE_WSEXTENT		bitfield mask;	/* use specified WSEXTENT
	USE_WSQUOTA		bitfield mask;	/* use specified WSQUOTA
    end;
end;
/*
/* Structure of INPUT_FLAGS item.
/*
aggregate INPUT_FLAGS structure fill prefix DJI$;
    INPUT_FLAGS structure longword unsigned;
	NO_FILE			bitfield mask;	/* do not return a file
    end;
end;

end_module $DJIDEF;

module $DPTDEF;
/*+
/* DPT - DRIVER PROLOGUE TABLE
/*
/* EACH DEVICE DRIVER HAS A DRIVER PROLOGUE TABLE.
/*-



aggregate DPTDEF structure prefix DPT$;
    FLINK longword unsigned;				/*FORWARD LINK TO NEXT DPT 
    BLINK longword unsigned;				/*BACKWARD LINK TO PREVIOUS DPT 
    SIZE word unsigned;					/*SIZE OF DRIVER 
    TYPE byte unsigned;					/*STRUCTURE TYPE 
    REFC byte unsigned;					/*COUNT OF DDB'S THAT REFERENCE DRIVER 
    ADPTYPE byte unsigned;				/*ADAPTER TYPE CODE 
    FLAGS_OVERLAY union fill;
        FLAGS byte unsigned;				/*DRIVER LOADER FLAGS 
	FLAGS_BITS structure fill;
            SUBCNTRL bitfield mask;			/*DEVICE IS A SUB-CONTROLLER 
            SVP bitfield mask;				/*DEVICE REQUIRES A SYSTEM PAGE 
            NOUNLOAD bitfield mask;			/*DRIVER IS NOT TO BE UNLOADED 
            SCS bitfield mask;				/*SCS CODE MUST BE LOADER WITH DRIVER 
	end FLAGS_BITS;
    end FLAGS_OVERLAY;
    UCBSIZE word unsigned;				/*SIZE OF UCB 
    INITTAB word unsigned;				/*OFFSET TO INIT TABLE 
    REINITTAB word unsigned;				/*OFFSET TO RE-INIT TABLE 
    UNLOAD word unsigned;				/*OFFSET TO UNLOAD ACTION ROUTINE 
    MAXUNITS word unsigned;				/*MAXIMUM UNITS THAT CAN BE CONNECTED 
    VERSION word unsigned;				/*DRIVER PROLOGUE VERSION NUMBER 
    constant VERSION	equals 4  prefix DPT tag $C;	/*CURRENT VERSION NUMBER 
    DEFUNITS word unsigned;				/*DEFAULT NUMBER OF UNITS 
    DELIVER word unsigned;				/*OFFSET TO DRIVER UNIT DELIVERY ROUTINE 
    VECTOR word unsigned;				/*OFFSET TO VECTOR TABLE (IN TTDRIVER) 
    NAME character length 12;				/*DRIVER NAME (COUNTED STRING) 
    LINKTIME quadword unsigned;				/*LINK DATE AND TIME FROM IMAGE HEADER 
    ECOLEVEL longword unsigned;				/*ECO LEVEL FROM IMAGE HEADER 
    constant "LENGTH" equals . prefix DPT$ tag K;	/*LENGTH OF PROLOGUE TABLE 
    constant "LENGTH" equals . prefix DPT$ tag C;	/*LENGTH OF PROLOGUE TABLE 
    
end DPTDEF;

end_module $DPTDEF;


module $DYNDEF;

/*+
/* DATA STRUCTURE TYPE DEFINITIONS
/*
/* EACH DATA STRUCTURE THAT IS ALLOCATED FROM THE DYNAMIC MEMORY
/* POOL SHOULD HAVE A VALID TYPE IN ITS 11TH BYTE.
/*-


	 						/*BASE AND OFFSET OF 1 

constant(
      ADP						/*UNIBUS ADAPTER CONTROL BLOCK 
    , ACB						/*AST CONTROL BLOCK 
    , AQB						/*ACP QUEUE BLOCK 
    , CEB						/*COMMON EVENT BLOCK 
    , CRB						/*CHANNEL REQUEST BLOCK 
    , DDB						/*DEVICE DESCRIPTOR BLOCK 
    , FCB						/*FILE CONTROL BLOCK 
    , FRK						/*FORK BLOCK 
    , IDB						/*INTERRUPT DISPATCH BLOCK 
    , IRP						/*I/O REQUEST PACKET 
    , LOG						/*LOGICAL NAME BLOCK 
    , PCB						/*PROCESS CONTROL BLOCK 
    , PQB						/*PROCESS QUOTA BLOCK 
    , RVT						/*RELATIVE VOLUME TABLE 
    , TQE						/*TIMER QUEUE ENTRY 
    , UCB						/*UNIT CONTROL BLOCK 
    , VCB						/*VOLUME CONTROL BLOCK 
    , WCB						/*WINDOW CONTROL BLOCK 
    , BUFIO						/*BUFFERED I/O BLOCK 
    , TYPAHD						/*TERMINAL TYPEAHEAD BUFFER 
    , GSD						/*GLOBAL SECTION DESCRIPTOR BLOCK 
    , MVL						/*MAGNETIC TAPE VOLUME LIST 
    , NET						/*NETWORK MESSAGE BLOCK 
    , KFE						/*KNOWN FILE ENTRY 
    , MTL						/*MOUNTED VOLUME LIST ENTRY 
    , BRDCST						/*BROADCAST MESSAGE BLOCK 
    , CXB						/*COMPLEX CHAINED BUFFER 
    , NDB						/* NETWORK NODE DESCRIPTOR BLOCK 
    , SSB						/* LOGICAL LINK SUBCHANNEL STATUS BLOCK 
    , DPT						/* DRIVER PROLOGUE TABLE 
    , JPB						/* JOB PARAMETER BLOCK 
    , PBH						/* PERFORMANCE BUFFER HEADER 
    , PDB						/* PERFORMANCE DATA BLOCK 
    , PIB						/* PERFORMANCE INFORMATION BLOCK 
    , PFL						/* PAGE FILE CONTROL BLOCK 
    , JNLWCB						/* JOURNAL WINDOW CONTROL BLOCK
    , PTR						/* POINTER CONTROL BLOCK 
    , KFRH						/* KNOWN FILE IMAGE HEADER 
    , DCCB						/* Data Cache Control Block
    , EXTGSD						/*EXTENDED GLOBAL SECTION DESCRIPTOR 
    , SHMGSD						/*SHARED MEMORY GLOBAL SECTION DESCRIPTOR 
    , SHB						/*SHARED MEMORY CONTROL BLOCK 
    , MBX						/*MAILBOX CONTROL BLOCK 
    , IRPE						/*I/O REQUEST PACKET EXTENSION 
    , SLAVCEB						/*SLAVE COMMON EVENT BLOCK 
    , SHMCEB						/*SHARED MEMORY MASTER COMMON EVENT BLOCK 
    , JIB						/*JOB INFORMATION BLOCK 
    , TWP						/* Terminal driver write packet 
    , RBM						/* Realtime SPT bit map 
    , VCA						/* Disk volume cache block 
    , CDB						/*X25 LES CHANNEL DATA BLOCK 
    , LPD						/*X25 LES PROCESS DESCRIPTOR 
    , LKB						/*LOCK BLOCK 
    , RSB						/*RESOURCE BLOCK 
    , LKID						/*LOCK ID TABLE 
    , RSHT						/*RESOURCE HASH TABLE 
    , CDRP						/*CLASS DRIVER REQUEST PACKET 
    , ERP						/* ERRORLOG PACKET 
    , CIDG						/*DATAGRAM BUFFER FOR CI PORT 
    , CIMSG						/*MESSAGE BUFFER FOR CI PORT 
    , XWB						/*DECNET LOGICAL LINK CONTEXT BLOCK 
                                        		/*   (REPLACES "NDB" BLOCK)
    , WQE						/*DECNET WORK QUEUE BLOCK 
                                        		/*   (REPLACES "NET" BLOCK)
    , ACL						/*ACCESS CONTROL LIST QUEUE ENTRY 
    , LNM						/*LOGICAL NAME BLOCK 
    , UNUSED_2						/*UNUSED
    , RIGHTSLIST					/*RIGHTS LIST
    , KFD						/* Known File Device Directory block
    , KFPB						/* Known File list Pointer Block
    , CIA						/* Compound Intrusion Analysis block
    , PMB						/* Page Fault Monitor Control Block
    , PFB						/* Page Fault Monitor Buffer
    , CHIP						/* Internal CHKPRO block
    , ORB						/* Objects Rights Block
    ) equals 1 increment 1  prefix DYN tag $C;
/*
/* THE FOLLOWING CODES ARE SUBTYPABLE, THAT IS EACH CODE REFERS TO A GENERIC
/* FUNCTION AND WITHIN THAT FUNCTION THERE MAY BE MANY DIFFERENT SUB-TYPES
/* OF BLOCKS.  THIS SCHEME WAS ADOPTED TO PRESERVE TYPES.  THE SUB-TYPE IS
/* IN THE 12TH BYTE.
/*
constant SUBTYPE	equals 96  prefix DYN tag $C;	/* START OF SUBTYPABLES 
constant SCS	equals 96  prefix DYN tag $C;		/* SYSTEM COMMUNICATION SERVICES 
constant(
      SCS_CDL						/* CONNECT DISPATCH LIST 
    , SCS_CDT						/* CONNECT DISPATCH TABLE 
    , SCS_DIR						/* DIRECTORY BLOCK 
    , SCS_PB						/* PATH BLOCK 
    , SCS_PDT						/* PORT DESCRIPTOR TABLE 
    , SCS_RDT						/* REQUEST DESCRIPTOR TABLE 
    , SCS_SB						/* SYSTEM BLOCK 
    , SCS_SPPB						/* SCA POLLER PROCESS BLOCK
    , SCS_SPNB						/* SCA POLLER NAME BLOCK
    , SCS_UQB						/* MSCP SERVER UNIT BLOCK
    , SCS_HQB						/* MSCP SERVER HOST BLOCK
    ) equals 1 increment 1  prefix DYN tag $C;
constant CI	equals 97  prefix DYN tag $C;		/* CI PORT SPECIFIC 
constant(
      CI_BDT						/* BUFFER DESCRIPTOR TABLE 
    , CI_FQDT						/* FREE QUE DESCRIPTOR TABLE 
    ) equals 1 increment 1  prefix DYN tag $C;
constant LOADCODE	equals 98  prefix DYN tag $C;	/* LOADABLE CODE 
constant(
      NON_PAGED						/* NON PAGED CODE
    , PAGED						/* PAGED CODE
    , LC_MP						/* MULTIPROCESSOR CODE 
    , LC_SCS						/* SCS CODE 
    , LC_CLS						/* CLUSTER CODE
    , LC_CHREML						/* CHAR/DECIMAL INS EMUL 
    , LC_FPEMUL						/* FLOAT PNT EMULATOR
    , LC_MSCP						/* MSCP SERVER
    , LC_SYSL						/* SYSLOA
    ) equals 1 increment 1  prefix DYN tag $C;
constant INIT	equals 99  prefix DYN tag $C;		/* STRUCTURES SET UP BY INIT 
constant(
      PCBVEC						/* PROCESS CONTROL BLOCK VECTOR 
    , PHVEC						/* PROCESS HEADER VECTOR 
    , SWPMAP						/* SWAPPER MAP 
    , MPWMAP						/* MODIFIED PAGE WRITER MAP 
    , PRCMAP						/* PROCESS BITMAP 
    , BOOTCB						/* BOOT CONTROL BLOCK 
    , CONF						/* CONFIGURATION ARRAYS 
    , CST						/* CLUSTER SYSTEM TABLE
    ) equals 1 increment 1  prefix DYN tag $C;
constant CLASSDRV	equals 100  prefix DYN tag $C;	/* CLASS DRIVER MAJOR STRUCTURE TYPE CODE 
constant(
      CD_CDDB						/* CLASS DRIVER DATA BLOCK 
    , CD_BBRPG						/* BAD BLOCK REPLACEMENT PAGE 
    , CD_SHDW_WRK					/* SHADOW SET WORK BUFFER
    ) equals 1 increment 1  prefix DYN tag $C;
constant CLU		equals 101  prefix DYN tag $C;	/* CLUSTER MAJOR STRUCTURE TYPE CODE
constant(
      CLU_CSB						/* CONNECTION STATUS BLOCK
    , CLU_CLUVEC					/* CLUSTER SYSTEM VECTOR
    , CLU_CLUB						/* CLUSTER BLOCK
    , CLU_BTX						/* CLUSTER BLOCK TRANSFER EXTENSION
    , CLU_CLUDCB					/* CLUSTER DISK QUORUM CONTROL BLOCK
    , CLU_CLUOPT					/* CLUSTER OPTIMAL RECONFIGURATION CONTEXT BLOCK
    , CLU_LCKDIR					/* LOCK MANAGER DISTRIBUTED DIRECTORY VECTOR
    ) equals 1 increment 1 prefix DYN tag $C;
constant PGD		equals 102  prefix DYN tag $C;	/* PAGED DYNAMIC MEMORY
constant (
      PGD_F11BC						/* F11BXQP BUFFER CACHE.
    ) equals 1 increment 1  prefix DYN tag $C;
constant JNL		equals 103  prefix DYN tag $C;  /* JOURNALING STRUCTURE
constant(						/* JOURNALING SUBTYPES
      JNL_ABL						/* AI-BI LIST
    , JNL_ADL						/* ALLOCATED DEVICE LIST
    , JNL_BCB						/* BUFFER CONTROL BLOCK
    , JNL_ACBM						/* JOURNAL ACCESS BIT MAP
    , JNL_BUF						/* JOURNAL BUFFER
    , JNL_DB						/* JOURNAL DATA BLOCK
    , JNL_SFT						/* SPOOL FILE TABLE
    , JNL_NDL						/* NAME TABLE DEVICE LIST
    , JNL_JMT						/* JOURNAL MERGE TABLE
    , JNL_RM						/* JOURNAL REMASTER BLOCK
    , JNL_RRP						/* RECOVERY REQUEST BLOCK
    , JNL_RCPC						/* RCP CONTROL BLOCK
    , JNL_RUL						/* RECOVERY UNIT LIST
    , JNL_VCL						/* VCB LIST
    , JNL_VLE						/* VCB ELEMENT
    , JNL_CWQ						/* CLUSTER WRITE Q ENTRY
    , JNL_RC						/* READ CONTEXT
    , JNL_MSG						/* JOURNAL MESSAGE
    , JNL_BXSTS						/* BLOCK XFER STATUS BLOCK
    , JNL_MSGDATA					/* CI MESSAGE DATA
    , JNL_DIOREAD					/* DIO read data
    ) equals 1 increment 1  prefix DYN tag $C;

/*
/* SPECIAL DYNAMIC MEMORY TYPES.  THESE ARE HANDLED SPECIALLY BY
/* EXE$DALONONPAGED.
/*
constant SPECIAL	equals 128  prefix DYN tag $C;	/* START OF SPECIAL TYPES 
	 						/* BASE OF 128 AND OFFSET OF 1 

constant(
      SHRBUFIO						/* SHARED MEMORY BUFFERED I/O 
    ) equals 128 increment 1  prefix DYN tag $C;

end_module $DYNDEF;


module $EMBHDDEF;

/*
/* ERROR MESSAGE BUFFER HEADER
/*
/*                ******        CAUTION  ******
/*
/*        ALL OF THE EMBxxDEF STRUCTURES ASSUME THAT THE HEADER IS
/*        EXACTLY ONE LONGWORD IN LENGTH.  IF THIS FIELD CHANGES,
/*        IF EFFECTS ALL OF THE OTHER STRUCTURES.
/*        ALL MESSAGES HAVE TYPE, TIME, SYSTEM ID, AND ERROR SEQUENCE IN THE
/*        SAME RELATIVE LOCATIONS.
/*



aggregate EMBHDDEF structure prefix EMB$ origin HD_SID;
    SIZE word unsigned;					/*SIZE OF ERROR MESSAGE IN BYTES 
    BUFIND byte unsigned;				/*ALLOCATION BUFFER INDICATOR (0 OR 1) 
    VALID byte unsigned;				/*ERROR MESSAGE VALID INDICATOR 
    constant "LENGTH"	equals 4  prefix EMB tag $K;	/*LENGTH OF FIXED PART OF MESSAGE HEADER 
    HD_SID longword unsigned;				/*SYSTEM ID 
    HD_ENTRY_OVERLAY union fill;
        HD_ENTRY word unsigned;				/*ERROR MESSAGE ENTRY TYPE 
	HD_ENTRY_FIELDS structure fill;
            DEVTYP byte unsigned;			/*DEVICE TYPE 
            DEVCLS byte unsigned;			/*DEVICE CLASS 
	end HD_ENTRY_FIELDS;
    end HD_ENTRY_OVERLAY;
    HD_TIME quadword unsigned;				/*TIME OF MESSAGE ENTRY 
    HD_ERRSEQ word unsigned;				/*ERROR SEQUENCE FOR MESSAGE 
    constant HD_LENGTH equals . prefix EMB$ tag K;	/*LENGTH OF PART COMMON TO ALL MESSAGES 
    constant HD_LENGTH equals . prefix EMB$ tag C;	/*LENGTH OF PART COMMON TO ALL MESSAGES 
end EMBHDDEF;

end_module $EMBHDDEF;

module $EMBBCDEF;

/*
/* BUGCHECK ERROR MESSAGE BUFFER FORMAT (SYSTEM AND USER)
/*



aggregate EMBBCDEF structure prefix EMB$;
    BC_SID longword unsigned;				/*SYSTEM ID 
    BC_ENTRY word unsigned;				/*ENTRY TYPE 
    BC_TIME quadword unsigned;				/*TIME IN 64 BITS 
    BC_ERRSEQ word unsigned;				/*ERROR SEQUENCE NUMBER 
    BC_KSP longword unsigned;				/*KERNEL STACK POINTER 
    BC_ESP longword unsigned;				/*EXECUTIVE STACK POINTER 
    BC_SSP longword unsigned;				/*SUPERVISOR STACK POINTER 
    BC_USP longword unsigned;				/*USER STACK POINTER 
    BC_ISP longword unsigned;				/*INTERRUPT STACK POINTER 
    BC_R0 longword unsigned;				/*REGISTER R0 
    BC_R1 longword unsigned;				/*REGISTER R1 
    BC_R2 longword unsigned;				/*REGISTER R2 
    BC_R3 longword unsigned;				/*REGISTER R3 
    BC_R4 longword unsigned;				/*REGISTER R4 
    BC_R5 longword unsigned;				/*REGISTER R5 
    BC_R6 longword unsigned;				/*REGISTER R6 
    BC_R7 longword unsigned;				/*REGISTER R7 
    BC_R8 longword unsigned;				/*REGISTER R8 
    BC_R9 longword unsigned;				/*REGISTER R9 
    BC_R10 longword unsigned;				/*REGISTER R10 
    BC_R11 longword unsigned;				/*REGISTER R11 
    BC_AP longword unsigned;				/*ARGUMENT POINTER 
    BC_FP longword unsigned;				/*FRAME POINTER 
    BC_SP longword unsigned;				/*CURRENT STACK POINTER 
    BC_PC longword unsigned;				/*PROGRAM COUNTER 
    BC_PSL longword unsigned;				/*PROCESSOR STATUS 
    BC_CODE longword unsigned;				/*BUGCHECK CODE 
    BC_PID longword unsigned;				/*CURRENT PROCESS ID 
    BC_LNAME character length 16;			/*CURRENT PROCESS NAME 
    constant BC_LENGTH equals . prefix EMB$ tag K;	/*SIZE OF FIXED PART OF BUGCHECK MESSAGE 
    constant BC_LENGTH equals . prefix EMB$ tag C;	/*SIZE OF FIXED PART OF BUGCHECK MESSAGE 
end EMBBCDEF;

end_module $EMBBCDEF;

module $EMBCRDEF;

/*
/* CRASH-RESTART ERROR MESSAGE BUFFER FORMAT
/*



aggregate EMBCRDEF structure prefix EMB$;
    CR_SID longword unsigned;				/*SYSTEM ID 
    CR_ENTRY word unsigned;				/*ENTRY TYPE 
    CR_TIME quadword unsigned;				/*TIME IN 64 BITS 
    CR_ERRSEQ word unsigned;				/*ERROR SEQUENCE NUMBER 
    CR_KSP longword unsigned;				/*KERNEL STACK POINTER 
    CR_ESP longword unsigned;				/*EXECUTIVE STACK POINTER 
    CR_SSP longword unsigned;				/*SUPERVISOR STACK POINTER 
    CR_USP longword unsigned;				/*USER STACK POINTER 
    CR_ISP longword unsigned;				/*INTERRUPT STACK POINTER 
    CR_R0 longword unsigned;				/*REGISTER R0 
    CR_R1 longword unsigned;				/*REGISTER R1 
    CR_R2 longword unsigned;				/*REGISTER R2 
    CR_R3 longword unsigned;				/*REGISTER R3 
    CR_R4 longword unsigned;				/*REGISTER R4 
    CR_R5 longword unsigned;				/*REGISTER R5 
    CR_R6 longword unsigned;				/*REGISTER R6 
    CR_R7 longword unsigned;				/*REGISTER R7 
    CR_R8 longword unsigned;				/*REGISTER R8 
    CR_R9 longword unsigned;				/*REGISTER R9 
    CR_R10 longword unsigned;				/*REGISTER R10 
    CR_R11 longword unsigned;				/*REGISTER R11 
    CR_AP longword unsigned;				/*ARGUMENT POINTER 
    CR_FP longword unsigned;				/*FRAME POINTER 
    CR_SP longword unsigned;				/*CURRENT STACK POINTER 
    CR_PC longword unsigned;				/*PROGRAM COUNTER 
    CR_PSL longword unsigned;				/*PROCESSOR STATUS 
    CR_P0BR longword unsigned;				/*PROGRAM REGION BASE REGISTER 
    CR_P0LR longword unsigned;				/*PROGRAM REGION LIMIT REGISTER 
    CR_P1BR longword unsigned;				/*CONTROL REGION BASE REGISTER 
    CR_P1LR longword unsigned;				/*CONTROL REGION LIMIT REGISTER 
    CR_SBR longword unsigned;				/*SYSTEM BASE REGISTER 
    CR_SLR longword unsigned;				/*SYSTEM LIMIT REGISTER 
    CR_PCBB longword unsigned;				/*PROCESS CONTROL BLOCK BASE REGISTER 
    CR_SCBB longword unsigned;				/*SYSTEM CONTROL BLOCK BASE REGISTER 
    CR_ASTLVL longword unsigned;			/*AST DELIVERY LEVEL REGISTER 
    CR_SISR longword unsigned;				/*SOFTWARE INTERRUPT SUMMARY REGISTER 
    CR_ICCS longword unsigned;				/*INTERVAL TIMER CONTROL STATUS REGISTER 
    CR_CPUREG longword unsigned;			/*START OF CPU-SPECIFIC IPR'S 
end EMBCRDEF;

aggregate EMBCRDEF1 structure prefix EMB$;
    FILL_1 byte dimension 148 fill prefix EMBCRDEF tag $$;
    CR_ICR longword unsigned;				/*INTERVAL COUNT REGISTER 
    CR_TODR longword unsigned;				/*TIME OF DAY REGISTER 
    CR_ACCS longword unsigned;				/*ACCELERATOR CONTROL REGISTER 
    CR_SBIFS longword unsigned;				/* SBI FAULT STATUS 
    CR_SBISC longword unsigned;				/* SBI COMPARATOR REGISTER 
    CR_SBIMT longword unsigned;				/* SBI MAINT REGISTER 
    CR_SBIER longword unsigned;				/* SBI ERROR REGISTER 
    CR_SBITA longword unsigned;				/* SBI TIMEOUT ADDR REGISTER 
    CR_SBIS longword unsigned dimension 16;		/* SBI SILO 
end EMBCRDEF1;

aggregate EMBCRDEF2 structure prefix EMB$;
    FILL_2 byte dimension 148 fill prefix EMBCRDEF tag $$;
    FILL_4 byte dimension 12 fill prefix EMBCRDEF tag $$;/*Allow room for ICR,TODR,ACCS
    CR_TBDR longword unsigned;				/* TB DISABLE REGISTER 
    CR_CADR longword unsigned;				/* CACHE DISABLE REGISTER 
    CR_MCESR longword unsigned;				/* MACHINE CHECK ERROR SUMMARY 
    CR_CAER longword unsigned;				/* CACHE ERROR REGISTER 
    CR_CMIERR longword unsigned;			/* CMI ERROR SUMMARY REGISTER 
                                            		/* 16 UNUSED LONGWDS IN EMB
end EMBCRDEF2;

aggregate EMBCRDEF3 structure prefix EMB$;
    FILL_3 byte dimension 244 fill prefix EMBCRDEF tag $$;
    CR_CODE longword unsigned;				/*BUGCHECK/CRASH CODE 
    CR_PID longword unsigned;				/*CURRENT PROCESS ID 
    CR_LNAME character length 16;			/*CURRENT PROCESS NAME 
    constant CR_LENGTH equals . prefix EMB$ tag K;	/*SIZE OF FIXED PART OF BUGCHECK MESSAGE 
    constant CR_LENGTH equals . prefix EMB$ tag C;	/*SIZE OF FIXED PART OF BUGCHECK MESSAGE 
end EMBCRDEF3;

end_module $EMBCRDEF;

module $EMBDVDEF;

/*
/* DEVICE ERROR MESSAGE BUFFER FORMAT (ERROR AND TIMEOUT)
/*



aggregate EMBDVDEF structure prefix EMB$;
    DV_SID longword unsigned;				/*SYSTEM ID 
    DV_ENTRY word unsigned;				/*ENTRY TYPE (1=ERROR, 96=TIMEOUT) 
    DV_TIME quadword unsigned;				/*TIME OF ERROR 
    DV_ERRSEQ word unsigned;				/*ERROR SEQUENCE NUMBER 
    DV_ERTCNT byte unsigned;				/*REMAINING NUMBER OF ERROR RETRIES 
    DV_ERTMAX byte unsigned;				/*MAXIMUM NUMBER OF ERROR RETRIES 
    DV_IOSB quadword unsigned;				/*FINAL I/O STATUS 
    DV_STS word unsigned;				/*FINAL DEVICE STATUS 
    DV_CLASS byte unsigned;				/*DEVICE CLASS 
    DV_TYPE byte unsigned;				/*DEVICE TYPE 
    DV_RQPID longword unsigned;				/*REQUESTER PROCESS ID 
    DV_BOFF word unsigned;				/*BYTE OFFSET IN PAGE 
    DV_BCNT word unsigned;				/*TRANSFER BYTE COUNT 
    DV_MEDIA longword unsigned;				/*STARTING MEDIA ADDRESS 
    DV_UNIT word unsigned;				/*PHYSICAL UNIT NUMBER 
    DV_ERRCNT word unsigned;				/*UNIT ERROR COUNT 
    DV_OPCNT longword unsigned;				/*UNIT OPERATION COUNT 
    DV_OWNUIC longword unsigned;			/*VOLUME OWNER UIC 
    DV_CHAR longword unsigned;				/*DEVICE CHARACTERISTICS 
    DV_SLAVE byte unsigned;				/*SLAVE CONTROLLER NUMBER 
    FILL_1 byte fill prefix EMBDVDEF tag $$;		/*SPARE UNUSED BYTES 
    DV_FUNC word unsigned;				/*I/O FUNCTION VALUE 
    DV_NAME character length 16;			/*DEVICE NAME 
    DV_REGSAV longword unsigned;			/*START OF REGISTER SAVE AREA 
end EMBDVDEF;

end_module $EMBDVDEF;

module $EMBTSDEF;

/*
/* TIME STAMP MSG FORMAT
/*



aggregate EMBTSDEF structure prefix EMB$;
    TS_SID longword unsigned;				/*SYSTEM ID 
    TS_ENTRY word unsigned;				/*ENTRY TYPE 
    TS_TIME quadword unsigned;				/*TIME IN 64 BITS 
    TS_ERRSEQ word unsigned;				/*ERROR SEQ ! 
    constant TS_LENGTH equals . prefix EMB$ tag K;	/*LENGTH OF TIME STAMP MSG 
    constant TS_LENGTH equals . prefix EMB$ tag C;	/*LENGTH OF TIME STAMP MSG 
end EMBTSDEF;

end_module $EMBTSDEF;

module $EMBSSDEF;

/*
/* SYSTEM SERVICE MESSAGE
/*
/*        NOTE:        SYSTEM SERVICE MESSAGE COVERS:
/*
/*                1) THE MESSAGES FROM THE SERVICE
/*                2) OPERATOR MESSAGES
/*                3) NETWORK MESSAGES
/*
/*        ONLY THE TYPE FIELD IS DIFERENT
/*



aggregate EMBSSDEF structure prefix EMB$;
    SS_SID longword unsigned;				/*SYSTEM ID 
    SS_ENTRY word unsigned;				/*ENTRY TYPE 
    SS_TIME quadword unsigned;				/*TIME IN 64 BITS 
    SS_ERRSEQ word unsigned;				/*ERROR SEQUENCE NUMBER 
    SS_MSGSZ word unsigned;				/*MESSAGE TEXT SIZE IN BYTES 
    constant SS_LENGTH equals . prefix EMB$ tag K;	/*LENGTH OF CONSTANT PART 
    constant SS_LENGTH equals . prefix EMB$ tag C;	/*LENGTH OF CONSTANT PART 
    SS_MSGTXT byte unsigned;				/*FIRST BYTE OF MESSAGE TEXT 
end EMBSSDEF;

end_module $EMBSSDEF;

module $EMBVMDEF;

/*
/* VOLUME MOUNT/DISMOUNT MESSAGE TYPE
/*



aggregate EMBVMDEF structure prefix EMB$;
    VM_SID longword unsigned;				/*SYSTEM ID 
    VM_ENTRY word unsigned;				/*ENTRY TYPE = EMB$K_VM OR EMB$K_VD 
    VM_TIME quadword unsigned;				/*TIME IN 64 BIT FORMAT 
    VM_ERRSEQ word unsigned;				/*ERROR SEQUENCE NUMBER 
    VM_OWNUIC longword unsigned;			/*OWNER UIC OF THE VOLUME 
    VM_ERRCNT longword unsigned;			/*UNIT ERROR COUNT FROM UCB 
    VM_OPRCNT longword unsigned;			/*UNIT OPERATION COUNT FROM UCB 
    VM_UNIT word unsigned;				/*DEVICE UNIT NUMBER 
    VM_NAMLNG byte unsigned;				/*LENGTH OF DEVICE GENERIC NAME 
    VM_NAMTXT character length 15;			/*DEVICE GENERIC NAME 
    VM_VOLNUM word unsigned;				/*VOLUME NUMBER WITHIN SET 
    VM_NUMSET word unsigned;				/*NUMBER OF VOLUMES WITHIN SET 
    VM_LABEL character length 12;			/*VOLUME LABEL 
    constant VM_LENGTH equals . prefix EMB$ tag K;	/*LENGTH OF BUFFER 
    constant VM_LENGTH equals . prefix EMB$ tag C;	/*LENGTH OF BUFFER 
end EMBVMDEF;

end_module $EMBVMDEF;

module $EMBSUDEF;
/*
/* SYSTEM STARTUP MESSAGE
/*


aggregate EMBSUDEF structure prefix EMB$;
    SU_SID longword unsigned;				/*SYSTEM ID 
    SU_ENTRY word unsigned;				/*ENTRY TYPE (IE: BOOT OR POWER RECOVERY) 
    SU_TIME quadword unsigned;				/*CONTENTS OF SYSTEM TIME QUADWORD 
    SU_ERRSEQ word unsigned;				/*ERROR SEQUENCE NUMBER 
    SU_DAYTIM longword unsigned;			/*CONTENTS OF TIME OF DAY CLOCK 
    constant SU_LENGTH equals . prefix EMB$ tag K;	/*LENGTH OF MESSAGE 
    constant SU_LENGTH equals . prefix EMB$ tag C;	/*LENGTH OF MESSAGE 
end EMBSUDEF;

end_module $EMBSUDEF;

module $EMBMCDEF;


/*
/* MACHINE CHECK LOG BUFFER FORMAT
/*



aggregate EMBMCDEF structure prefix EMB$;
    MC_SID longword unsigned;				/*SYSTEM ID 
    MC_ENTRY word unsigned;				/*ENTRY TYPE 
    MC_TIME quadword unsigned;				/*TIME IN 64 BITS 
    MC_ERRSEQ word unsigned;				/*ERROR SEQUENCE NUMBER 
    MC_SUMCOD byte unsigned;				/*SUMMARY CODE 
    MC_TOPF byte unsigned;				/*TIME OUT PENDING FLAG 
    MC_OPCODE byte unsigned;				/*OPCODE OF INSTRUCTION CAUSING CHECK 
    MC_CACHEF byte unsigned;				/*CACHE DISABLE FLAG, 1=GROUP 0, 2=G 1 
    MC_CES longword unsigned;				/*CPU ERROR STATUS 
    MC_UPC longword unsigned;				/*MICRO-PC AT FAULT TIME 
    MC_VA longword unsigned;				/*VIRTUAL ADDRESS AT FAULT TIME 
    MC_D longword unsigned;				/*CPU D REGISTER AT FAULT TIME 
    MC_TBER0 longword unsigned;				/*TRANSLATION BUFFER STATUS REG 0 
    MC_TBER1 longword unsigned;				/*TRANSLATION BUFFER STATUS REG 1 
    MC_TIMOAD longword unsigned;			/*PHYSICAL ADDRESS CAUSING SBI TIMEOUT 
    MC_PARITY longword unsigned;			/*CACHE STATUS REGISTER 
    MC_SBIERR longword unsigned;			/*SBI ERROR REGISTER 
    MC_PC longword unsigned;				/*PC OF INSTRUCTION CAUSING CHECK 
    MC_PSL longword unsigned;				/*PSL OF MACHINE AT FAULT TIME 
    constant MC_LENGTH equals . prefix EMB$ tag K;	/*LENGTH OF MACHINE CHECK FRAME 
    constant MC_LENGTH equals . prefix EMB$ tag C;	/*LENGTH OF MACHINE CHECK FRAME 
end EMBMCDEF;

end_module $EMBMCDEF;

module $EMBSEDEF;

/*
/* SOFT ECC DETECTED ERRORS AND SBI ALERT BUFFER FORMAT
/*



aggregate EMBSEDEF structure prefix EMB$;
    SE_SID longword unsigned;				/*SYSTEM ID 
    SE_ENTRY word unsigned;				/*ENTRY TYPE 
    SE_TIME quadword unsigned;				/*TIME IN 64 BITS 
    SE_ERRSEQ word unsigned;				/*ERROR SEQUENCE NUMBER 
    SE_NUMCON longword unsigned;			/*NUMBER OF MEMORY CONTROLLERS 
    constant SE_LENGTH equals . prefix EMB$ tag K;	/*LENGTH OF FIXED PART OF MSG 
    constant SE_LENGTH equals . prefix EMB$ tag C;	/*LENGTH OF FIXED PART OF MSG 
    SE_TR longword unsigned;				/*ADAPTOR TR NUMBER 
    SE_A longword unsigned;				/*MEMORY REGISTER A 
    SE_B longword unsigned;				/*MEMORY REGISTER B 
    SE_C longword unsigned;				/*MEMORY REGISTER C 
    SE_PC longword unsigned;				/*PC OF INSTRUCTION AT FAULT TIME 
    SE_PSL longword unsigned;				/*PSL OF MACHINE AT FAULT TIME 
end EMBSEDEF;

end_module $EMBSEDEF;

module $EMBSBDEF;

/*
/* SBI FAULT BUFFER FORMAT AND ASYNCHRONOUS WRITE ERROR FORMAT
/*



aggregate EMBSBDEF structure prefix EMB$;
    SB_SID longword unsigned;				/*SYSTEM ID 
    SB_ENTRY word unsigned;				/*ENTRY TYPE 
    SB_TIME quadword unsigned;				/*TIME IN 64 BITS 
    SB_ERRSEQ word unsigned;				/*ERROR SEQUENCE NUMBER 
    SB_FAULT longword unsigned;				/*SBI FAULT/STATUS REGISTER 
    SB_SILCMP longword unsigned;			/*SBI SILO COMPARATOR 
    SB_MAINT longword unsigned;				/*SBI MAINTENANCE 
    SB_ERROR longword unsigned;				/*SBI ERROR REG 
    SB_TIMOUT longword unsigned;			/*SBI TIMEOUT REG 
    SB_SILO longword unsigned dimension 16;		/*SBI SILO REG 
    SB_SBIRGS longword unsigned dimension 16;		/*REGISTER A'S ON BUS (OR 0) 
    SB_PC longword unsigned;				/*PC OF INSTRUCTION AT FAULT TIME 
    SB_PSL longword unsigned;				/*PSL OF MACHINE AT FAULT TIME 
    constant SB_LENGTH equals . prefix EMB$ tag K;	/*LENGTH OF SBI ERROR BUFFER 
    constant SB_LENGTH equals . prefix EMB$ tag C;	/*LENGTH OF SBI ERROR BUFFER 
end EMBSBDEF;

end_module $EMBSBDEF;

module $EMBUIDEF;

/*
/* UNDEFINED ADAPTER INTERRUPT BUFFER FORMAT
/*


aggregate EMBUIDEF structure prefix EMB$;
    UI_SID longword unsigned;				/*SYSTEM ID 
    UI_ENTRY word unsigned;				/*ENTRY TYPE 
    UI_TIME quadword unsigned;				/*TIME IN 64 BITS 
    UI_ERRSEQ word unsigned;				/*ERROR SEQUENCE NUMBER 
    UI_TR longword unsigned;				/*ADAPTER TR NUMBER 
    UI_CSR longword unsigned;				/*ADAPTER CONGIGURATION STATUS REGISTER 
    constant UI_LENGTH equals . prefix EMB$ tag K;	/*LENGTH OF MESSAGE 
    constant UI_LENGTH equals . prefix EMB$ tag C;	/*LENGTH OF MESSAGE 
end EMBUIDEF;

end_module $EMBUIDEF;

module $EMBUEDEF;


/*
/* ERROR BUFFER FORMAT FOR UNIBUS ERROR SUMMARY REGISTER
/*        ***** USED ONLY BY 11/730 ****
/*


aggregate EMBUEDEF structure prefix EMB$;
    UE_SID longword unsigned;				/*SYSTEM ID 
    UE_ENTRY word unsigned;				/*ENTRY TYPE 
    UE_TIME quadword unsigned;				/*TIME IN 64 BITS 
    UE_ERRSEQ word unsigned;				/*ERROR SEQUENCE NUMBER 
    UE_UBERR longword unsigned;				/*UNIBUS ERROR REGISTER 
    constant UE_LENGTH equals . prefix EMB$ tag K;	/*LENGTH OF MESSAGE 
    constant UE_LENGTH equals . prefix EMB$ tag C;	/*LENGTH OF MESSAGE 
end EMBUEDEF;

end_module $EMBUEDEF;

module $EMBSPDEF;


/*
/* ERROR BUFFER FORMAT FOR SAVING SOFTWARE PARAMETERS FOR CLASS DRIVER THAT
/*        CORRESPOND TO A LOGGED MESSAGE (SEE EMBLMDEF BELOW) ORIGINATING
/*        IN AN INTELLIGENT MASS STORAGE CONTROLLER.
/*



aggregate EMBSPDEF structure prefix EMB$;
    SP_SID longword unsigned;				/* System ID 
    SP_ENTRY word unsigned;				/* Entry type (of this errorlog buffer) 
    SP_TIME quadword unsigned;				/* Time this entry created 
    SP_ERRSEQ word unsigned;				/* Error Sequence Number 
    SP_CLASS byte unsigned;				/* Device Class 
    SP_TYPE byte unsigned;				/* Device Type 
    SP_BOFF word unsigned;				/* Byte OFFset of data transfer 
    SP_BCNT longword unsigned;				/* Byte Count of data transfer 
    SP_MEDIA longword unsigned;				/* Media address (LBN) of data transfer 
    SP_RQPID longword unsigned;				/* Requesting PID 
    SP_IOSB quadword unsigned;				/* Final I/O status 
    SP_FUNC word unsigned;				/* I/O function code 
    SP_UNIT word unsigned;				/* Unit number of drive 
    SP_OPCNT longword unsigned;				/* Cummulative operation count this unit 
    SP_ERRCNT word unsigned;				/* Cummulative error count for this unit 
    SP_UCBSTS word unsigned;				/* Copy of UCB$W_STS field 
    SP_OWNUIC longword unsigned;			/* Unit's owner's UIC 
    SP_CHAR longword unsigned;				/* Device Characteristics 
    SP_CMDREF longword unsigned;			/* Command Reference number (RSPID) 
    SP_DEVNAM character length 16;			/* Device name 
    constant SP_LENGTH equals . prefix EMB$ tag K;
    constant SP_LENGTH equals . prefix EMB$ tag C;
    
end EMBSPDEF;

end_module $EMBSPDEF;

module $EMBLMDEF;

/*
/* LOGGED MESSAGE (DEVICE DEPENDENT CONTENTS).  DRIVER LOGS MESSAGE
/*        WHICH MAY COME DIRECT FROM INTELLIGENT MASS STORAGE CONTROLLER.
/*



aggregate EMBLMDEF structure prefix EMB$;
    LM_SID longword unsigned;				/* System ID 
    LM_ENTRY word unsigned;				/* Entry type (i.e. Logged Message) 
    LM_TIME quadword unsigned;				/* Time this entry created 
    LM_ERRSEQ word unsigned;				/* Error sequence number 
    LM_CLASS byte unsigned;				/* Device Class 
    LM_TYPE byte unsigned;				/* Device Type 
    LM_UNIT word unsigned;				/* Device unit number 
    LM_DEVNAM character length 16;			/* Device name 
    LM_MSGTYP word unsigned;				/* Type of logged message 
    constant LM_LENGTH equals . prefix EMB$ tag K;
    constant LM_LENGTH equals . prefix EMB$ tag C;
    
end EMBLMDEF;

end_module $EMBLMDEF;

module $EMBLTDEF;

/*
/* LOGGED MESSAGE MESSAGE TYPES
/*


constant DM	equals 01  prefix EMB tag $C;		/* Disk MSCP message 
constant DM	equals 01  prefix EMB tag $K;		/* Disk MSCP message 
constant TM	equals 02  prefix EMB tag $C;		/* Tape MSCP message 
constant TM	equals 02  prefix EMB tag $K;		/* Tape MSCP message 
constant PM	equals 03  prefix EMB tag $C;		/* Port (CI) message 
constant PM	equals 03  prefix EMB tag $K;		/* Port (CI) message 
constant UM	equals 04  prefix EMB tag $C;		/* Port (UDA) message 
constant UM	equals 04  prefix EMB tag $K;		/* Port (UDA) message 
constant AVATN	equals 05  prefix EMB tag $C;		/* Available Attention Message 
constant AVATN	equals 05  prefix EMB tag $K;		/* Available Attention Message 
constant DUPUN	equals 06  prefix EMB tag $C;		/* Duplicate Unit ! Attention Message 
constant DUPUN	equals 06  prefix EMB tag $K;		/* Duplicate Unit ! Attention Message 
constant IVCMD	equals 07  prefix EMB tag $C;		/* Invalid Command Log message. 
constant IVCMD	equals 07  prefix EMB tag $K;		/* Invalid Command Log message. 
constant ACPTH	equals 08  prefix EMB tag $C;		/* Access Path Attention Message 
constant ACPTH	equals 08  prefix EMB tag $K;		/* Access Path Attention Message 
constant INVSTS	equals 09  prefix EMB tag $C;		/* Invalid Status in End Message
constant INVSTS	equals 09  prefix EMB tag $K;		/* Invalid Status in End Message
constant INVATT	equals 10  prefix EMB tag $C;		/* Invalid Attention Message
constant INVATT	equals 10  prefix EMB tag $K;		/* Invalid Attention Message
constant NOUNIT_DG	equals 11  prefix EMB tag $C;	/* No unit in Datagram
constant NOUNIT_DG	equals 11  prefix EMB tag $K;	/* No unit in Datagram


end_module $EMBLTDEF;

module $EMBETDEF;
/*
/* ERROR MESSAGE ENTRY TYPE DEFINITIONS
/*

constant DE	equals 01  prefix EMB tag $C;		/*DEVICE ERROR 
constant DE	equals 01  prefix EMB tag $K;		/*DEVICE ERROR 
constant MC	equals 02  prefix EMB tag $C;		/*MACHINE CHECK 
constant MC	equals 02  prefix EMB tag $K;		/*MACHINE CHECK 
constant BE	equals 04  prefix EMB tag $C;		/*BUS ERROR 
constant BE	equals 04  prefix EMB tag $K;		/*BUS ERROR 
constant SA	equals 05  prefix EMB tag $C;		/*SBI ALERT 
constant SA	equals 05  prefix EMB tag $K;		/*SBI ALERT 
constant SE	equals 06  prefix EMB tag $C;		/*SOFT ECC ERROR 
constant SE	equals 06  prefix EMB tag $K;		/*SOFT ECC ERROR 
constant AW	equals 07  prefix EMB tag $C;		/*ASYNCHRONOUS WRITE ERROR 
constant AW	equals 07  prefix EMB tag $K;		/*ASYNCHRONOUS WRITE ERROR 
constant HE	equals 08  prefix EMB tag $C;		/*HARD ECC ERROR 
constant HE	equals 08  prefix EMB tag $K;		/*HARD ECC ERROR 
constant UBA	equals 09  prefix EMB tag $C;		/* 11/780 Unibus Adapter error 
constant UBA	equals 09  prefix EMB tag $K;		/* 11/780 Unibus Adapter error 
constant SI	equals 10  prefix EMB tag $C;		/* 11/750 Fault through SBI vector 
constant SI	equals 10  prefix EMB tag $K;		/* 11/750 Fault through SBI vector 
constant UE	equals 11  prefix EMB tag $C;		/* 11/730 Unibus Error 
constant UE	equals 11  prefix EMB tag $K;		/* 11/730 Unibus Error 
constant MBA	equals 12  prefix EMB tag $C;		/* 11/780 Massbus Adapter Error 
constant MBA	equals 12  prefix EMB tag $K;		/* 11/780 Massbus Adapter Error 
constant SBIA	equals 13  prefix EMB tag $C;		/* 11/790 SBIA error
constant SBIA	equals 13  prefix EMB tag $K;		/* 11/790 SBIA error
constant CRD	equals 14  prefix EMB tag $C;		/* 11/790 CRD log
constant CRD	equals 14  prefix EMB tag $K;		/* 11/790 CRD log
constant EMM	equals 15  prefix EMB tag $C;		/* 11/790 Environmental MOnitor
constant EMM	equals 15  prefix EMB tag $K;		/* 11/790 Environmental MOnitor
constant HLT	equals 16  prefix EMB tag $C;		/* 11/790 Processor Error Halt
constant HLT	equals 16  prefix EMB tag $K;		/* 11/790 Processor Error Halt
constant CRBT	equals 17  prefix EMB tag $C;		/* 11/790 Console Reboot
constant CRBT	equals 17  prefix EMB tag $K;		/* 11/790 Console Reboot
constant CS	equals 32  prefix EMB tag $C;		/*COLD START (IE: SYSTEM BOOT) 
constant CS	equals 32  prefix EMB tag $K;		/*COLD START (IE: SYSTEM BOOT) 
constant NF	equals 35  prefix EMB tag $K;		/*NEW FILE CREATED 
constant NF	equals 35  prefix EMB tag $C;		/*NEW FILE CREATED 
constant WS	equals 36  prefix EMB tag $C;		/*WARM START (IE: SYSTEM POWER RECOVERY) 
constant WS	equals 36  prefix EMB tag $K;		/*WARM START (IE: SYSTEM POWER RECOVERY) 
constant CR	equals 37  prefix EMB tag $C;		/*CRASH RE-START 
constant CR	equals 37  prefix EMB tag $K;		/*CRASH RE-START 
constant TS	equals 38  prefix EMB tag $C;		/*TIME STAMP ENTRY 
constant TS	equals 38  prefix EMB tag $K;		/*TIME STAMP ENTRY 
constant SS	equals 39  prefix EMB tag $C;		/*SYSTEM SERVICE MESSAGE 
constant SS	equals 39  prefix EMB tag $K;		/*SYSTEM SERVICE MESSAGE 
constant SBC	equals 40  prefix EMB tag $C;		/*SYSTEM BUGCHECK 
constant SBC	equals 40  prefix EMB tag $K;		/*SYSTEM BUGCHECK 
constant OM	equals 41  prefix EMB tag $C;		/*OPERATOR MESSAGE 
constant OM	equals 41  prefix EMB tag $K;		/*OPERATOR MESSAGE 
constant NM	equals 42  prefix EMB tag $C;		/*NETWORK MESSAGE 
constant NM	equals 42  prefix EMB tag $K;		/*NETWORK MESSAGE 
constant VM	equals 64  prefix EMB tag $C;		/*VOLUME MOUNT 
constant VM	equals 64  prefix EMB tag $K;		/*VOLUME MOUNT 
constant VD	equals 65  prefix EMB tag $C;		/*VOLUME DISMOUNT 
constant VD	equals 65  prefix EMB tag $K;		/*VOLUME DISMOUNT 
constant DT	equals 96  prefix EMB tag $C;		/*DEVICE TIMEOUT 
constant DT	equals 96  prefix EMB tag $K;		/*DEVICE TIMEOUT 
constant UI	equals 97  prefix EMB tag $C;		/*UNDEFINED INTERRUPT 
constant UI	equals 97  prefix EMB tag $K;		/*UNDEFINED INTERRUPT 
constant DA	equals 98  prefix EMB tag $C;		/* Asynchronous Device Attention 
constant DA	equals 98  prefix EMB tag $K;		/* Asynchronous Device Attention 
constant SP	equals 99  prefix EMB tag $C;		/* Software Parameters 
constant SP	equals 99  prefix EMB tag $K;		/* Software Parameters 
constant LM	equals 100  prefix EMB tag $C;		/* Logged Message 
constant LM	equals 100  prefix EMB tag $K;		/* Logged Message 
constant LOGMSCP equals 101  prefix EMB tag $C;		/* Logged MSCP Message
constant LOGMSCP equals 101  prefix EMB tag $K;		/* Logged MSCP Message 
constant UBC	equals 112  prefix EMB tag $C;		/*USER BUGCHECK 
constant UBC	equals 112  prefix EMB tag $K;		/*USER BUGCHECK 


end_module $EMBETDEF;


module $EO1DEF;
/*+
/* EOF1 ANSI MAGNETIC TAPE LABEL
/* THIS IS THE FIRST LABEL IN FILE TRAILER LABEL SET.  IT IS EQUIVALENT TO
/* HDR1 EXCEPT FOR THE FOLLOWING FIELDS.
/*-


aggregate EO1DEF structure prefix EO1$;
    EO1LID longword unsigned;				/*LABEL IDENTIFIER AND NUMBER 'EOF1' 
    FILL_1 character length 50 fill prefix EO1DEF tag $$;/*SAME AS HDR1 
    BLOCKCNT character length 6;			/*BLOCK COUNT 
end EO1DEF;

end_module $EO1DEF;


module $EO2DEF;

/*+
/* EOF2 ANSI MAGNETIC TAPE LABEL
/* THIS IS THE SECOND LABEL IN THE FILE TRAILER LABEL SET.  IT IS EQUIVALENT
/* TO HDR2 EXCEPT FOR THE FOLLOWING FIELDS.
/*-


aggregate EO2DEF union prefix EO2$;
    EO2LID longword unsigned;				/*LABEL IDENTIFIER AND NUMBER 'EOF2' 
end EO2DEF;

end_module $EO2DEF;


module $EO3DEF;

/*+
/* EOF3 ANSI MAGNETIC TAPE LABEL
/* THIS IS THE THIRD LABEL IN THE FILE TRAILER LABEL SET.  IT IS EQUIVALENT
/* TO HDR3 EXCEPT FOR THE FOLLOWING FIELDS.
/*-


aggregate EO3DEF union prefix EO3$;
    EO3LID longword unsigned;				/*LABEL IDENTIFIER AND NUMBER 'EOF3' 
end EO3DEF;

end_module $EO3DEF;


module $EO4DEF;

/*+
/* EOF4 ANSI MAGNETIC TAPE LABEL
/* THIS IS THE FOURTH LABEL IN THE FILE TRAILER LABEL SET.  IT IS EQUIVALENT
/* TO HDR4 EXCEPT FOR THE FOLLOWING FIELDS.
/*-


aggregate EO4DEF union prefix EO4$;
    EO4LID longword unsigned;				/*LABEL IDENTIFIER AND NUMBER 'EOF4' 
end EO4DEF;

end_module $EO4DEF;


module $ERLDEF;
/*
/* ERROR LOG ALLOCATION BUFFER HEADER
/*



aggregate ERLDEF structure prefix ERL$;
    BUSY byte unsigned;					/*NUMBER OF BUSY MESSAGES IN BUFFER 
    MSGCNT byte unsigned;				/*NUMBER OF COMPLETED MESSAGES IN BUFFER 
    BUFIND byte unsigned;				/*BUFFER INDICATOR OF RESPECTIVE BUFFER 
    FLAGS byte unsigned;				/*BUFFER CONTROL FLAGS 
    NEXT longword unsigned;				/*ADDRESS OF NEXT AVAILABLE SPACE IN BUFFER 
    END_OVERLAY union fill;
        "END" longword unsigned;			/*ADDRESS OF END OF BUFFER + 1 
        constant "LENGTH" equals . prefix ERL$ tag K;	/*LENGTH OF ALLOCATION BUFFER HEADER 
        constant "LENGTH" equals . prefix ERL$ tag C;	/*LENGTH OF ALLOCATION BUFFER HEADER 
        
	END_BITS structure fill;
            LOCK bitfield mask;				/*BUFFER ALLOCATION INTERLOCK 
            TIMER bitfield mask;			/*TIMER ACTIVE 
	end END_BITS;
        
    end END_OVERLAY;
end ERLDEF;

end_module $ERLDEF;
{
{ Version:	'V04-001'
{
{****************************************************************************
{*									    *
{*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
{*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
{*  ALL RIGHTS RESERVED.						    *
{* 									    *
{*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
{*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
{*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
{*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
{*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
{*  TRANSFERRED.							    *
{* 									    *
{*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
{*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
{*  CORPORATION.							    *
{* 									    *
{*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
{*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
{* 									    *
{*									    *
{****************************************************************************

{++
{
{ FACILITY:  VAX/VMS System Macro Libraries
{
{ ABSTRACT:
{
{        This file contains the SDL source for all operating system control
{        blocks, from F to L.  That is, all control blocks from FAA to LZZ.
{
{ ENVIRONMENT:
{
{        n/a
{
{--
{
{
{ AUTHOR:  The VMS Group         CREATION DATE:  1-Aug-1976
{
{ MODIFIED BY:
{
{	V04-001	SRB0145		Steve Beckhardt		6-Sep-1984
{		Moved CDRP$L_VAL9 into regular CDRP out of long CDRP.
{
{	V03-099	MSH0063		Michael S. Harvey	31-Jul-1984
{		Eliminate GSNAMOFF cell from KFE.
{
{	V03-098	ACG0440		Andrew C. Goldstein,	23-Jul-1984  11:49
{		Add ref count and classification valid flag to ORB in the FCB;
{		add FCB$L_CACHELKID for file cache interlocks
{
{	V03-097	MSH0063		Michael S. Harvey	20-Jul-1984
{		Add symbol for maximum length of KFE.
{
{	V03-096	CDS0006		Christian D. Saether	15-July-1984
{		Add another pool to F11BC.  Add FCB$L_DIRINDX.
{
{	V03-095	RAS0319		Ron Schaefer		29-Jun-1984
{		Add new structure to logical names structures:
{		LNMC -- the logical name table name cache structure.
{
{	V03-094	ACG0432		Andrew C. Goldstein,	9-Jul-1984  21:35
{		Add JIB$L_ORG_BYTLM and JIB$L_ORG_PBYTLM fields
{
{	V03-093	MSH0061		Michael S. Harvey	5-Jul-1984
{		Add EXEONLY image flag to the KFE.
{
{	V03-092	MSH0058		Michael S. Harvey	27-Jun-1984
{		Define a new cell in the KFE to hold the length of a
{		string which will be used to more accurately specify
{		which memory a set of global sections for the KFE was
{		created in.
{
{	V03-091	MSH0057		Michael S. Harvey	25-Jun-1984
{		Define new KFE bit used to propagate some context across
{		the INSTALL REPLACE command.
{
{	V03-090	CDS0005		Christian D. Saether	9-May-1984
{		Correct longword misalignment introduced by CDS0004.
{
{	V03-089	MSH0041		Michael S. Harvey	2-May-1984
{		Add image alias limit constants to $IHDDEF.
{
{	V03-088	CDS0004		Christian D. Saether	19-Apr-1984
{		Changes to FCB.
{
{	V03-087	MSH0032		Michael S. Harvey	12-Apr-1984
{		Add GSD$L_ORB for all types of GSD. This cell will
{		be used to locate the Object Rights Block associated
{		with a global section.
{
{	V03-086	ADE0001		Alan D. Eldridge	11-Apr-1984
{		Add IHD$V_INISHR and IHA$L_INISHR.
{
{	V03-085	TMK0005		Todd M. Katz		11-Apr-1984
{		Add KFE$L_ORB to $KFEDEF. This cell will contain the address
{		of the Object Rights Block associated with a Known File Entry.
{
{	V03-084	ACG0414		Andrew C. Goldstein,	9-Apr-1984  11:17
{		Add IOC$V_ALLOC bit
{
{	V03-083	KPL0006		Peter Lieberwirth	 7-Apr-1984
{		Add IOC$V_NO_TRANS to $IOCDEF.  This flag tells
{		IOC$TRANDEVNAM that logical name translation is
{		unnecessary because the caller already did the
{		translation.
{
{	V03-082	TMK0004		Todd M. Katz		07-Apr-1984
{		Change LNMTH$L_CHP to LNMTH$L_ORB within $LNMSTRDEF to reflect
{		the replacement of shareable logical name tables' CHIP 
{		protection templates with Object Rights Blocks.
{
{	V03-081 EMD0074		Ellen M. Dusseault	06-Apr-1984
{		Define status bit, IRP$V_KEY in IRP$W_STS and 
{		IRP$L_KEYDESC which will contain an address of a 
{		descriptor describing an encryption key.
{
{	V03-080	LMP0221		L. Mark Pilant,		26-Mar-1984  9:25
{		Move FCB fields around to define an ORB within the FCB.
{
{	V03-079	KPL0005		Peter Lieberwirth	23-Mar-1984
{		Fix $IO8NNDEF to track Nautilus changes.
{
{	V03-078	SSA0021		Stan Amway		23-Mar-1984
{		Backed out SSA0017. Bit 15 of IRP$W_STS conflicts with
{		a private definition and usage in DUDRIVER. Added
{		comment to warn others of impending doom.
{
{	V03-077	WMC0077		Wayne Cardoza		23-Mar-1984
{		Add hash byte to GSD.
{
{	V03-076	ACG0408		Andrew C. Goldstein,	22-Mar-1984  23:04
{		Rearrange XQP base address cells so they form descriptors
{
{	V03-075	JWT0169		Jim Teague		22-Mar-1984
{		Bump image ident minorid.  Long shareable image names
{		require larger entries in the shareable image list.
{
{	V03-074	MMD0267		Meg Dumont,	22-Mar-1984  17:05
{		Add ANSI 3 file length extension in HDR4 label.
{
{	V03-073	SRB0117		Steve Beckhardt		18-Mar-1984
{		Added LKB$B_TSLT and LKB$L_DLCKPRI to $LKBDEF.
{		Added VAL9 and VAL10 to $IRPDEF
{
{	V03-072	SSA0017		Stan Amway		9-Mar-1984
{		Add IRP$V_QLEN as bit in IRP$W_STS to indicate that
{		the device queue length in the UCB has been incremented to
{		account for the IRP. IOCIOPOST conditionally decrements the 
{		device queue length based on the setting of this bit.
{
{	V03-071	LMP0207		L. Mark Pilant,		9-Mar-1984  9:02
{		Add FCB$V_BADACL to indicate that the ACL is present, but
{		should not be used in protection checks.  This is to note
{		that the ACL has been corrupted.
{
{	V03-070	TMK0003		Todd M. Katz		09-Mar-1984
{		Add LNMX$W_HASH to $LNMSTRDEF's definition of a logical 
{		name translation block.
{
{	V03-069	ACG0399		Andrew C. Goldstein,	28-Feb-1984  16:13
{		Add $IOCDEF - flag bits for IOC$SEARCH
{
{	V03-068	CDS0003		Christian D. Saether	28-Feb-1984
{		Forgot some counters in F11BC.
{
{	V03-067	CDS0002		Christian D. Saether	28-Feb-1984
{		Add modules F11BDEF and F11BCDEF.
{
{	V03-066	RLRIO8SS1	Robert L. Rappaport	27-Feb-1984
{		Add explicit PFN's to $IO8SSDEF for PCNTL, NIPACKETBUF, etc.
{
{	V03-065	JWT0152		Jim Teague		27-Feb-1984
{		Make changes to $ISDDEF and $IHIDEF required for variable
{		length ISDs and long shareable image filenames.
{
{	V03-064	ROW0298		Ralph O. Weber		27-FEB-1984
{		Define IRP$W_ENDMSGSIZ, a field in the class driver CDRP 
{		extension which holds the size of the most recent MSCP end 
{		message.
{
{	V03-063	WHM0003		Bill Matthews		24-Feb-1984
{		Renamed IDB$B_COMBO_VECTOR to IDB$B_VECTOR now that
{		IDB$B_COMBO_VECTOR_OFFSET has been added.
{
{	V03-062	RLRKDZ2		Robert L. Rappaport	22-Feb-1984
{		Fix $KDZDEF and extend fill space following BIIC register
{		definition so that the BIIC registers occupy an entire
{		virtual page.
{
{	V03-061	KPL0004		Peter Lieberwirth	 6-Feb-1984
{		Fix bug introduced in V03-058.  Doubly-defined PERNEX.
{
{	V03-060	WHM0002		Bill Matthews		3-Feb-1984
{		Added field IDB$B_COMBO_VECTOR_OFFSET. Additional support
{		for edit 51.
{
{	V03-059	LMP0188		L. Mark Pilant,		3-Feb-1984  16:22
{		Add support for a classification block in the FCB.
{
{	V03-058	KPL0003		Peter Lieberwirth	 3-Feb-1984
{		Add $IO8NNDEF, IO space layout for Nautilus.
{
{	V03-057	MSH0004		Michael S. Harvey	2-Feb-1984
{		Redefine parts of global section descriptors to
{		accomodate longer global section names. The name
{		field will be variable length for local memory and
{		PFN-mapped global section descriptors, and will simply
{		be lengthened for the fixed length shared memory variety.
{
{	V03-056 HH0002		Hai Huang		31-Jan-1984
{		Redefine the mount list head in the JIB as a standard 
{		two-word list head
{
{	V03-055	ROW0281		Ralph O. Weber		14-JAN-1984
{		Add IRP$L_DUTUFLAGS and IRP$W_DUTUCNTR to class driver CDRP 
{		extension.
{
{	V03-054	ACG0387		Andrew C. Goldstein,	12-Jan-1984  14:28
{		Add job mount list head to JIB; get job type codes in
{		proper order
{
{	V03-053	ACG0385		Andrew C. Goldstein,	11-Jan-1984  18:30
{		Make MAXDETACH and MAXJOBS JIB fields words
{
{	V03-053	LJK0257		Lawrence J. Kenah	5-Jan-1984
{		Reorder fields in JIB to speed up process creation time.
{
{	V03-052	ACG0385		Andrew C. Goldstein,	29-Dec-1983  13:34
{		Add JIB$B_JOBTYPE field, remove JIB$V_DISxxx flags
{
{	V03-051	WHM0001		Bill Matthews		27-Dec-1983
{		Added the field IDB$B_COMBO_CSR_OFFSET. Replaced the
{		field IDB$B_VECTOR with IDB$B_COMBO_VECTOR in $IDBDEF. These
{		changes allow a driver for devices in a combo device to find
{		the beginning of the CSRs and Vector table for the combo device.
{
{	V03-050	RLRKDZ1		R0bert L. Rappaport	9-Dec-1983
{		Add ability to get to BIIC registers thru $KDZDEF so
{		that a node can read its own BIIC registers without
{		having to know what node it is.
{
{	V03-049	RSH0087		R. Scott Hanna		07-Dec-1983
{		Move $KGBDEF to STARDEFFL.SDL
{
{	V03-048	RLRKDZ		Robert L. Rappaport	6-Dec-1983
{		Add $KDZDEF, Virtual memory offsets to internal KDZ11
{		registers and devices.
{
{	V03-047	ACG0377		Andrew C. Goldstein,	6-Dec-1983  11:46
{		Realign JIB fields after WMC0020
{
{	V03-046	SRB0106		Steve Beckhardt		18-Nov-1983
{		Added EPID field to LKB, reduced LKB$L_REFCNT field to a word.
{
{	V03-045	RLRIO8SS	Robert L. Rappaport	8-Nov-1983
{		Add $IO8SSDEF, Scorpio I/O space layout.
{
{	V03-044	KPL0002		Peter Lieberwirth	17-Oct-1983
{		Add IMP$V_RUH_SYNCH to $IMPDEF.
{
{	V03-043	SSA00002	Stan Amway		30-Sep-1983
{		Add IPL$_PERFMON to $IPLDEF.
{
{	V03-042	TMK0002		Todd M. Katz		18-Aug-1983
{		Add LNMTH$V_GROUP and LNMTH$V_SYSTEM to $LNMSTRDEF.
{
{	V03-041	KDM0068		Kathleen D. Morse	5-Aug-1983
{		Add $IOUV1DEF.
{
{	V03-040	RSH0047		R. Scott Hanna		24-Jul-1983
{		Add environmental ID definitions to $KGBDEF
{
{	V03-039	RNG0039		Rod N. Gamache		22-Jul-1983
{		Add new DECnet FAST Interface definitions $FFIDEF.
{
{	V03-038	LJK0217		Lawrence J. Kenah	26-Jun-1983
{		Put IHD$V_DBGDMT back into $IHDDEF
{
{	V03-037	LJK0214		Lawrence J. Kenah	24-Jun-1983
{		Remove Image Control Block (nee ICB) until various naming
{		issues are resolved.
{
{	V03-036	RPG0036		Bob Grosso		24-Jun-1983
{		Add new IHDDEF and ISDOLDDEF.
{
{	V03-035	CDS0001		Christian D. Saether	23-Jun-1983
{		Add FCB$L_ACCLKID field.
{
{	V03-034	RPG0034		Bob Grosso		23-Jun-1983
{		Add new Known File structures, KFRH, KFE, KFD, KFPB,
{		as well as ICB which is for the image activator.
{
{	V03-033	RNG0033		Rod Gamache		21-Jun-1983
{		Added IRP$Q_STATION to overlay IRP$Q_NT_PRVMSK.
{
{	V03-032	SRB0095		Steve Beckhardt		21-Jun-1983
{		Added LKB$M_PROTECT status bit
{
{	V03-031	ROW0185		Ralph O. Weber		21-JUN-1983
{		Add block transfer fields to the connection manager CDRP 
{		extension to IRP definition.
{
{	V03-030 LY0382		Larry Yetto		16-JUN-1983 14:16:40
{		Add IRP$V_JNL_REMREQ to IRP STS flags
{
{	V03-029	SRB0091		Steve Beckhardt		1-Jun-1983
{		Removed several state codes from $LKBDEF.  Renamed other
{		state codes.
{
{	V03-028	SRB0087		Steve Beckhardt		24-May-1983
{		Added RESEND status bit to $LKBDEF
{
{	V03-027	SRB0082		Steve Beckhardt		28-Apr-1983
{		Removed message queue from CDRP in $IRPDEF
{
{	V03-026	TMK0001		Todd M. Katz		14-APR-1983
{		Make several changes to $LNMSTRDEF. Delete LNMTH$L_LOGNAM,
{		replace LNMTH$V_SUBTABLE with LNMTH$V_DIRECTORY, and add
{		LNMB$V_NODELETE.
{
{	V03-025	ROW0181		Ralph O. Weber		14-APR-1983
{		Add IRP$L_VAL7 and IRP$L_VAL8.  Eventually, these fields 
{		should replace currently used fields.  However, the current 
{		fields cannot be deleted yet.  Therefore, the CDRP and the 
{		IRP will be bigger than we want for a few weeks.
{
{	V03-024	MMD0138		Meg Dumont,	13-Apr-1983  10:17
{		Add HD4DEF which will contain extension to HDR1 FILE IDENTIFIER
{		field on magnetic tape
{
{	V03-023	SRB0075		Steve Beckhardt		6-Apr-1983
{		More changes to $LKBDEF.
{
{	V03-022	SRB0072		Steve Beckhardt		25-Mar-1983
{		Added some new definitions in $LKBDEF.
{
{	V03-021	STJ3073		Steven T. Jeffreys	25-Mar-1983
{		- Added FCB$L_HIGHWATER
{		- Added FCB$V_ERASE
{
{	V03-020	WMC0020		Wayne Cardoza		15-Mar-1983
{		Add MAXJOBS and MAXDETACH to JIB
{
{	V03-019	SRB0069		Steve Beckhardt		9-Mar-1983
{		Added NOQUOTA status bit to LKBDEF.
{
{	V03-018	KTA3037		Kerbey T. Altmann	11-Feb-1983
{		Add FLOAT definition to IO750DEF.
{
{	V03-017	MIR0022		Michael I. Rosenblum	19-Jan-1983
{		Add terminal speific IDB definition.
{
{	V03-016	ROW0156		Ralph O. Weber		11-JAN-1983
{		Add connection manager extension to CDRP portion of the IRP.  
{		Remove hard coded filler offsets in IRP to be symbolic.  
{		Reorder connection manager extension to CDRP so that the VAL1 
{		through VAL6 fields overlay the fields in the block transfer 
{		CDRP extension.
{
{	V03-015	WMC0015		Wayne Cardoza		9-Jan-1982
{		Add back KFPDEF which was accidentally removed in V03-012.
{
{	V03-014	ACG0307		Andrew C. Goldstein,	7-Jan-1983  16:30
{		Remove privilege mask and UIC from JIB
{
{	V03-013	SRB0060		Steve Beckhardt		7-Jan-1983
{		Added more definitions to $LKBDEF
{
{	V03-012	ACG0307		Andrew C. Goldstein,	30-Dec-1982  17:42
{		Add rights database definitions ($KGBDEF)
{
{	V03-011	SRB0057		Steve Beckhardt		15-Dec-1982
{		Reordered fields and added new fields and definitions
{		in $LKBDEF for distributed lock manager.
{
{	V03-010	SRB0056		Steve Beckhardt		14-Dec-1982
{		Changed IPL$_SYNCH and IPL$_TIMER to be 8 (instead of 7).
{		Added IPL$_TIMERFORK equal to 7.
{
{	V03-009	JWT0073		Jim Teague		09-Dec-1982
{		Add $IHSDEF fields IHS$L_DMTVBN and IHS$L_DMTBYTES for
{		description of Debugger module/psect information.
{		Also define IHD$V_DBGDMT bit in IHD$L_LNKFLAGS in $IHDDEF 
{		to indicate presence of above fields.
{
{	V03-008	ACG0303		Andrew C. Goldstein,	9-Dec-1982  15:12
{		Add FILL attribute to extraneous names
{
{	V03-007	DMW4013		DMWalp			 1-Dec-1982
{		Added $LNMSTRDEF
{
{	V03-006	JWH0130		Jeffrey W. Horn			19-Nov-1982
{		Change IMP$C_NPIOFILES to 63 so that the Process Perm
{		IFB/IRB tables take up a full page.
{
{	V03-005	KPL0001		Peter Lieberwirth		13-Oct-1982
{		Add IMP$V_RECOVERY to $IMPDEF
{
{	V03-004	TCM0003		Trudy C. Matthews		11-Aug-1982
{		Add IO790$AL_PERABS to $IO790DEF.
{
{        V03-003 JWH0001                Jeffrey W. Horn                29-Jul-1982
{                Add IMP$V_RUH to $IMPDEF.
{
{        V03-002        TCM0002                Trudy C. Matthews        28-Jul-1982  09:45
{                Change $IO7VVDEF to $IO790DEF.  Remove 11/790-specific
{                definitions ($PAMMDEF and SBIA register definitions) to
{                11/790-specific definition file, [SYSLOA.SRC]790DEF.MDL.
{
{        V03-001        LMP0036                L. Mark Pilant,                28-Jun-1982  13:37
{                Add space in the FCB definition for the Access Control List
{                queue listhead.
{
{**

module $F11BDEF;
/*+
/* F11B - System wide F11BXQP structures.
/*
/* This structure is actually part of the XQP impure area and
/* is pointed to by CTL$GL_F11BXQP.  That cell is initialized
/* during process creation by the XQP initialization code.
/*
/*-

aggregate F11BDEF structure prefix F11B$;
    XQPQUEUE quadword;			/* XQP per-process queue.
    DISPATCH longword unsigned;		/* Address of XQP dispatch routine.
    CODESIZE longword unsigned;		/* Size of XQP code in bytes.
    CODEBASE longword unsigned;		/* Base address of XQP code.
    IMPSIZE longword unsigned;		/* Size of impure area in bytes.
    IMPBASE longword unsigned;		/* Base address of XQP impure area.

end F11BDEF;

end_module $F11BDEF;

module $F11BCDEF;
/*+
/* F11BC - Files 11 Block Cache
/*
/* Header area which describes block cache used by F11BXQP.
/*
/*-

aggregate F11BCDEF structure prefix F11BC$;
    BUFBASE longword unsigned;		/* Base address of buffer area.
    BUFSIZE longword unsigned;		/* Size of buffer area in bytes.

    SIZE word unsigned;			/* Standard size field.
    TYPE byte unsigned;			/* Standard type field.
    SUBTYPE byte unsigned;		/* Standard subtype field.
    REALSIZE longword unsigned;		/* Structure size as a longword.

    LBNHSHBAS longword unsigned;	/* Base of LBN hash table.
    LBNHSHCNT word unsigned;		/* Count of entries in LBN hash tbl.
    BFRCNT word unsigned;		/* Total buffer count.

    BFRDBAS longword unsigned;		/* Buffer descriptor base address.
    BFRLDBAS longword unsigned;		/* Buffer lock descriptor base addr.

    BLHSHBAS longword unsigned;		/* Base addr of buffer lock hash tbl.
    BLHSHCNT word unsigned;		/* Num entries in buff lock hash tbl.
    FREEBFRL word unsigned;		/* First free buffer lock block.

    constant NUM_POOLS equals 4;	/* Number of buffer pools.

    POOL_LRU quadword dimension F11BC$K_NUM_POOLS;  /* Per pool LRU listhead.

    POOL_WAITQ quadword dimension F11BC$K_NUM_POOLS; /* Per pool cache wait listhead.

    POOLAVAIL longword dimension F11BC$K_NUM_POOLS; /* Available buffers per pool.
    POOLCNT word dimension F11BC$K_NUM_POOLS;	/* Count of buffers per pool.

    AMBIGQFL longword unsigned;		/* Ambiguity queue forward link.
    AMBIGQBL longword unsigned;		/* Ambiguity queue back link.

/*
/* Cache performance counters.
/*

    PROCESS_HITS longword unsigned;	/* In-process buffer hits.
    VALID_HITS longword unsigned;	/* Valid buffer cache hits.
    INVALID_HITS longword unsigned;	/* Buffer found but invalid contents.
    MISSES longword unsigned;		/* Buffer not in cache at all.
    DISK_READS longword unsigned;	/* Buffer reads from disk.
    DISK_WRITES longword unsigned;	/* Buffer writes to disk.
    CACHE_SERIAL longword unsigned;	/* Cache serialization calls.
    CACHE_STALLS longword unsigned;	/* Cache serialization stalls.
    BUFFER_STALLS longword unsigned;	/* Stalls for lack of buffers.

    CACHENAME character length 24;	/* Name of this cache (display only).

end F11BCDEF;

/*
/* Buffer descriptors.
/*

aggregate BFRDDEF structure prefix BFRD$;
    QFL longword unsigned;		/* Queue forward link.
    QBL longword unsigned;		/* Queue back link.

    LBN longword unsigned;		/* LBN of buffer.
    UCB longword unsigned;		/* UCB of buffer.

    LOCKBASIS longword unsigned;	/* Unique file identifier.
    SEQNUM longword unsigned;		/* Buffer validation sequence number.

    FLAGS_OVERLAY union fill;
	FLAGS byte unsigned;		/* Status flags.
	FLAGS_BITS structure fill;
	    POOL bitfield length 2;	/* Pool number of this buffer.
	    DIRTY bitfield mask;	/* Buffer has been modified.
	    VALID bitfield mask;	/* Buffer has been read from disk.
	end FLAGS_BITS;
    end FLAGS_OVERLAY;
    BTYPE byte unsigned;		/* Buffer type.
    BFRL word unsigned;			/* Index to buffer lock.
    CURPID word unsigned;		/* Index of current process.
    NXTBFRD word unsigned;		/* Index of next BFRD (hash chain).

end BFRDDEF;

/*
/* Buffer lock descriptor blocks.
/*

aggregate BFRLDEF structure prefix BFRL$;
    NXTBFRL word unsigned;		/* Index to next BFRL in list.
    REFCNT word unsigned;		/* Number of buffers backed by this lock.
    LKID longword unsigned;		/* Lock ID of buffer lock.

    LCKBASIS longword unsigned;		/* Unique file identifier.
    PARLKID longword unsigned;		/* Unique volume set identifier.

end BFRLDEF;

end_module $F11BCDEF;

module $FCBDEF;
/*+
/* FCB - FILE CONTROL BLOCK
/*
/* THERE IS ONE FILE CONTROL BLOCK FOR EACH UNIQUELY ACCESSED FILE ON A
/* VOLUME. THE FILE CONTROL BLOCK PROVIDES THE VEHICLE WHEREBY SHARED
/* ACCESS TO A FILE MAY BE CONTROLLED.
/*-


aggregate FCBDEF structure prefix FCB$;
    FCBFL longword unsigned;				/* FCB LIST FORWARD LINK 
    FCBBL longword unsigned;				/* FCB LIST BACKWARD LINK 
    SIZE word unsigned;					/* SIZE OF FCB IN BYTES 
    TYPE byte unsigned;					/* STRUCTURE TYPE OF FCB 
    ACCLKMODE byte unsigned;				/* Access lock mode.
    EXFCB longword unsigned;				/* ADDRESS OF EXTENSION FCB 
    WLFL longword unsigned;				/* WINDOW LISTHEAD FORWARD LINK 
    WLBL longword unsigned;				/* WINDOW LISTHEAD BACKWARD LINK 
    REFCNT word unsigned;				/* Total references to this FCB.
    ACNT word unsigned;					/* FILE ACCESS COUNT 
    WCNT word unsigned;					/* FILE WRITER COUNT 
    LCNT word unsigned;					/* FILE LOCK COUNT 
    TCNT word unsigned;					/* COUNT OF TRUNCATE LOCKS 
    STATUS_OVERLAY union fill;
        STATUS word unsigned;				/* FILE STATUS 
	STATUS_BITS structure fill;
            DIR bitfield;				/* FCB IS A DIRECTORY LRU ENTRY 
            MARKDEL bitfield;				/* FILE IS MARKED FOR DELETE 
            BADBLK bitfield;				/* BAD BLOCK ENCOUNTERED IN FILE 
            EXCL bitfield;				/* FILE IS EXCLUSIVELY ACCESSED 
            SPOOL bitfield;				/* FILE IS AN INTERMEDIATE SPOOL FILE 
            RMSLOCK bitfield;				/* FILE IS OPEN WITH RMS RECORD LOCKING 
	    ERASE bitfield;				/* ERASE DATA WHEN BLOCKS REMOVED FROM FILE
	    BADACL bitfield;				/* ACL IS CORRUPT
	    STALE bitfield;				/* Reconstruct FCB from header.
	    DELAYTRNC bitfield;				/* Delay truncation.
	end STATUS_BITS;
    end STATUS_OVERLAY;
    FID_OVERLAY union fill;
        FID word unsigned dimension 3;			/* FILE IDENTIFICATION 
	FID_FIELDS structure fill;
            FID_NUM word unsigned;			/* FILE NUMBER 
            FID_SEQ word unsigned;			/* FILE SEQUENCE NUMBER 
	    FID_RVN_OVERLAY union fill;
                FID_RVN word unsigned;			/* RELATIVE VOLUME NUMBER 
		FID_RVN_FIELDS structure fill;
                    FID_RVN byte unsigned;		/* SHORT FORM RVN 
                    FID_NMX byte unsigned;		/* EXTENDED FILE NUMBER 
		end FID_RVN_FIELDS;
	    end FID_RVN_OVERLAY;
	end FID_FIELDS;
    end FID_OVERLAY;
    SEGN word unsigned;					/* FILE SEGMENT NUMBER 
    STVBN longword unsigned;				/* STARTING VIRTUAL BLOCK NUMBER 
    STLBN longword unsigned;				/* STARTING LOGICAL BLOCK NUMBER 
    HDLBN longword unsigned;				/* LBN OF FILE HEADER 
    FILESIZE longword unsigned;				/* FILE SIZE IN BLOCKS 
    EFBLK longword unsigned;				/* END OF FILE VBN 
    VERSIONS word unsigned;				/* MAXIMUM NUMBER OF VERSIONS IN DIRECTORY 
    DIRSEQ word unsigned;				/* DIRECTORY USE SEQUENCE NUMBER 
    HIGHWATER longword unsigned;			/* HIGH WATER MARK IN FILE
    ACCLKID longword unsigned;				/* Access lock ID.
    LOCKBASIS longword unsigned;			/* Lock basis for this FCB.
    TRUNCVBN longword unsigned;				/* VBN for delayed truncation.
    CACHELKID longword unsigned;			/* Cache interlock lock ID
    ORB structure;					/* Object's Rights Block
	FILEOWNER structure longword unsigned;		/* FILE OWNER UIC 
	    UICMEMBER word unsigned;			/* MEMBER NUMBER 
	    UICGROUP word unsigned;			/* GROUP NUMBER 
	end FILEOWNER;
	FILL_5 longword unsigned fill;			/* ACL mutex
	FILL_3 longword unsigned fill;			/* Structure size & type
	FILL_6 longword unsigned fill;			/* Spare + ref count
	ACMODE quadword unsigned;			/* Access mode protection vector
	SYS_PROT structure longword unsigned;		/* Protection word/vector
	    FILEPROT word unsigned;			/* FILE PROTECTION MASK 
	    FILL_4 word unsigned fill;
	end SYS_PROT;
	OWN_PROT longword unsigned;			/* Owner protection
	GRP_PROT longword unsigned;			/* Group protection
	WOR_PROT longword unsigned;			/* World protection
	ACLFL longword unsigned;			/* ACCESS CONTROL LIST FORWARD LINK 
	ACLBL longword unsigned;			/* ACCESS CONTROL LIST BACKWARD LINK 
	MIN_CLASS_PROT structure;			/* Minimum security classification mask
	    FILL_2 byte dimension 20 fill;		/* see structure $CLSDEF
	end MIN_CLASS_PROT;
	MAX_CLASS_PROT structure;			/* Maximum security classification mask
	    FILL_2 byte dimension 20 fill;		/* see structure $CLSDEF
	end MAX_CLASS_PROT;
    end ORB;
    DIRINDX longword unsigned;				/* Directory index pointer
    constant "LENGTH" equals . prefix FCB$ tag K;	/* LENGTH OF STANDARD FCB 
    constant "LENGTH" equals . prefix FCB$ tag C;	/* LENGTH OF STANDARD FCB 
end FCBDEF;

end_module $FCBDEF;

module $FFIDEF;
/*+
/* FFI - DECnet-VAX Fast Interface
/*
/*-

aggregate FFIDEF structure prefix FFI$;
    FL longword unsigned;			/*FORWARD QUEUE LINK 
    BL longword unsigned;			/*BACKWARD QUEUE LINK 
    SIZE word unsigned;				/*BLOCK SIZE 
    TYPE byte unsigned;				/*BLOCK TYPE 
    SPARE byte unsigned;			/*DATALINK SPARE BYTE
    CTX_DL longword unsigned;			/*DATALINK CONTEXT AREA
    XMIT longword unsigned;			/*DATALINK TRANSMIT ROUTINE ADDRESS
    XMIT_DONE longword unsigned;		/*CALLER'S TRANSMIT DONE ROUTINE ADDRESS
    RECV_DONE longword unsigned;		/*CALLER'S RECEIVE DONE ROUTINE ADDRESS
    ERROR longword unsigned;			/*CALLER'S ERROR HANDLER
    SHUT_DONE longword unsigned;		/*CALLER'S SHUTDOWN COMPLETE ROUTINE ADDRESS
    SPARE0 longword unsigned;			/*   spare
    SPARE1 longword unsigned;			/*   spare
    SPARE2 longword unsigned;			/*   spare
    SPARE3 longword unsigned;			/*   spare
    DL_UCB longword unsigned;			/*DATALINK UCB ADDRESS
    PID longword unsigned;			/*CALLER'S PID (or zero)
    CHAN word unsigned;				/*CALLER'S CHAN (or zero)
    constant CTX_USER equals . prefix FFI$ tag G; /*CALLER'S CONTEXT BLOCK
    constant "LENGTH" equals . prefix FFI$ tag K; /*LENGTH OF A STANDARD FFI 
    constant "LENGTH" equals . prefix FFI$ tag C; /*LENGTH OF A STANDARD FFI 
end FFIDEF;

end_module $FFIDEF;


module $FKBDEF;
/*+
/* FKB - FORK BLOCK
/*
/* A FORK BLOCK DESCRIBES THE CONTEXT OF A FORK PROCESS. EACH UNIT CONTROL
/* BLOCK CONTAINS A FORK BLOCK AS ITS FIRST SIX LONGWORDS.
/*-



aggregate FKBDEF structure prefix FKB$;
    FQFL longword unsigned;				/*FORK QUEUE FORWARD LINK 
    FQBL longword unsigned;				/*FORK QUEUE BACKWARD LINK 
    SIZE word unsigned;					/*SIZE OF FKB IN BYTES 
    TYPE byte unsigned;					/*STRUCTURE TYPE OF FKB 
    FIPL byte unsigned;					/*FORK INTERRUPT PRIORITY LEVEL 
    FPC longword unsigned;				/*FORK PC 
    FR3 longword unsigned;				/*FORK R3 
    FR4 longword unsigned;				/*FORK R4 
    constant "LENGTH" equals . prefix FKB$ tag K;	/*STANDARD LENGTH OF FKB 
    constant "LENGTH" equals . prefix FKB$ tag C;	/*STANDARD LENGTH OF FKB 
    
end FKBDEF;

end_module $FKBDEF;


module $GSDDEF;

/*+
/* GLOBAL SECTION DESCRIPTOR BLOCK
/*-


aggregate GSDDEF structure prefix GSD$;
    GSDFL_OVERLAY union fill;
        GSDFL longword unsigned;			/*POINTER TO NEXT GSD 
	GSDFL_BITS structure fill;
            VALID bitfield mask;			/*SH MEM GSD FLAG, SET IF VALID ENTRY 
            LOCKED bitfield mask;			/*SH MEM GSD FLAG, SET IF ENTRY LOCKED 
            DELPEND bitfield mask;			/*SH MEM GSD FLAG, GS MARKED FOR DELETE 
            INITFAIL bitfield mask;			/*SH MEM GSD FLAG, SET WHEN GS INIT FAILS 
            DUPGSD bitfield mask;			/*SH MEM GSD FLAG, DUPLICATE GSD FOUND 
	end GSDFL_BITS;
    end GSDFL_OVERLAY;
    GSDBL longword unsigned;				/*POINTER TO PREVIOUS GSD 
    SIZE word unsigned;					/*SIZE OF GSD IN BYTES 
    TYPE byte unsigned;					/*STRUCTURE TYPE CODE FOR GSD 
    HASH byte unsigned;					/*HASH FOR GSD NAME
    PCBUIC_OVERLAY union fill;
        PCBUIC longword unsigned;			/*UIC OF CREATOR OF SECTION, FROM HIS PCB 
	PCBUIC_FIELDS structure fill;
            FILL_6 byte dimension 2 fill prefix GSDDEF tag $$;
            PCBGRP word unsigned;			/*GROUP OF CREATOR OF SECTION, FROM PCB 
	end PCBUIC_FIELDS;
    end PCBUIC_OVERLAY;
    FILUIC longword unsigned;				/*OWNER OF FILE, UIC FROM FCB 
    PROT word unsigned;					/*PROTECTION MASK 
    GSTX word unsigned;					/*GLOBAL SECTION TABLE INDEX 
    "IDENT" longword unsigned;				/*IDENTIFICATION OF GLOBAL SECTION 
    ORB longword unsigned;				/*OBJECT RIGHTS BLOCK LOCATOR
    FLAGS word unsigned;				/*SECTION FLAGS 
    GSDNAM character;					/*LOCAL MEMORY AND SHARED MEMORY SECTION NAME
    constant "LENGTH" equals . prefix GSD$ tag K;	/*LENGTH OF LOCAL MEMORY GSD 
    constant "LENGTH" equals . prefix GSD$ tag C;	/*LENGTH OF LOCAL MEMORY GSD 
    #GSDLEN = . ;
    
/*
/* THE FOLLOWING FIELDS ARE ONLY FOUND IN EXTENDED GSD'S.  THESE ARE USED
/* WHENEVER A GSD IS NEEDED WITHOUT A SECTION TABLE ENTRY, I.E., FOR SHARED
/* MEMORY AND FOR PAGES MAPPED BY PFN.
/*
    FILL_2 byte fill prefix GSDDEF tag $$;		/*SPARE BYTE
    BASEPFN longword unsigned;				/*FIRST RELATIVE BASE PFN 
    PAGES longword unsigned;				/*COUNT OF PAGES AT FIRST BASE PFN 
    REFCNT longword unsigned;				/*FIRST PROCESSOR PTE REF COUNT 
    PFNGSDNAM character;				/*PFN-MAPPED SECTION NAME
    constant EXTGSDLNG equals . prefix GSD$ tag K;	/*MINIMUM EXTENDED GSD LENGTH 
    constant EXTGSDLNG equals . prefix GSD$ tag C;	/*MINIMUM EXTENDED GSD LENGTH 
    
/*
/* THE FOLLOWING FIELDS ARE CONTAINED ONLY IN SHARED MEMORY GSD'S.  THE LENGTH,
/* GSD$C_SHMGSDLNG, IS ONLY THE CONSTANT SIZE OF THE GSD.  IN ADDITION, THERE IS
/* ONE LONGWORD FOR EACH PROCESSOR AND TWO LONGWORDS FOR EACH BASE PFN-SIZE PAIR.
/*
end GSDDEF;

aggregate GSDDEF1 structure prefix GSD$;
    FILL_7 byte dimension #GSDLEN+45 fill prefix GSDDEF tag $$; /*SHMEM GLOBAL SECTION NAME
    LOCK byte unsigned;					/*INTERPROCESSOR LOCK FOR GSD 
    PROCCNT byte unsigned;				/*NUMBER OF PROCESSOR REF. COUNTS IN GSD 
    CREATPORT byte unsigned;				/*PORT ! FOR CREATOR PROCESSOR 
    DELETPORT byte unsigned;				/*PORT ! FOR DELETOR PROCESSOR 
    constant PFNBASMAX	equals 4  prefix GSD tag $C;	/*MAXIMUM ! OF PFN BASES ALLOWED 
    BASPFN1 longword unsigned;				/*FIRST BASE PFN FOR SECTION PAGES 
    BASCNT1 longword unsigned;				/*CNT OF SECTION PAGES AT FIRST BASE PFN 
                                            		/*FIRST PFN/PAGE COUNT PAIR
    FILL_3 quadword fill prefix GSDDEF tag $$;		/* NOTE: THE NUMBER OF QUADWORDS 
    FILL_4 quadword fill prefix GSDDEF tag $$;		/* RESERVED FOR PFN/PAGE COUNTS PAIRS 
    FILL_5 quadword fill prefix GSDDEF tag $$;		/* MUST BE EQUAL TO GSD$C_PFNBASMAX-1. 
    constant SHMGSDLNG equals . prefix GSD$ tag K;	/*LENGTH OF CONSTANT PART OF SHM GSD 
    constant SHMGSDLNG equals . prefix GSD$ tag C;	/*LENGTH OF CONSTANT PART OF SHM GSD 
    PTECNT1 longword unsigned;				/*PTE COUNT FOR FIRST PROCESSOR 
    
end GSDDEF1;

end_module $GSDDEF;


module $HD1DEF;
/*+
/* HDR1 ANDSI MAGNETIC TAPE LABEL
/* THIS IS THE FIRST LABEL IN THE FILE LABEL HEADER SET.  IF IDENTIFIES THE FILE.
/*-


aggregate HD1DEF structure prefix HD1$;
    HD1LID longword unsigned;				/*LABEL IDENTIFIER AND NUMBER 'HDR1' 
    FILEID character length 17;				/*FILE IDENTIFIER 
    FILESETID character length 6;			/*FILE SET IDENTIFIER 
    FILESECNO character length 4;			/*FILE SECTION NUMBER 
    FILESEQNO character length 4;			/*FILE SEQUENCE NUMBER 
    GENNO character length 4;				/*FILE GENERATION NUMBER 
    GENVER character length 2;				/*FILE GENERATION VERSION NUMBER 
    CREATEDT character length 6;			/*CREATION DATE ( YYDDD) 
    EXPIREDT character length 6;			/*EXPIRATION DATE 
    FILACCESS byte unsigned;				/*FILE ACCESS 
    BLOCKCNT character length 6;			/*BLOCK COUNT 
    SYSCODE character length 13;			/*SYSTEM CODE 
    FILL_1 character length 7 fill prefix HD1DEF tag $$;/*SPACES 
end HD1DEF;

end_module $HD1DEF;


module $HD2DEF;


/*+
/* HDR2 ANSI MAGNETIC TAPE LABEL
/* THIS IS THE SECOND LABEL IN FILE LABEL HEADER SET.
/* THE FILE ATTRIBUTES HAVE BEEN REMOVED FROM HDR2, AND PLACED IN HDR3.
/* THE FIELDS REMAIN IN THE DEFINITION TO SUPPORT OLD TAPES.
/*-


aggregate HD2DEF structure prefix HD2$;
    HD2LID longword unsigned;				/*LABEL IDENTIFIER AND NUMBER 'HDR2' 
    RECFORMAT byte unsigned;				/*RECORD FORMAT 
    BLOCKLEN character length 5;			/*BLOCK LENGTH 
    RECLEN character length 5;				/*RECORD LENGTH 
    RECATR1 character length 20;			/*FIRST 20 BYTES OF FILES-11 RECORD ATTRIBUTES 
    FILL_1 character fill prefix HD2DEF tag $$;		/*SPACES 
    FORMCNTRL byte unsigned;				/*FORMS CONTROL 
    RECATR2 character length 12;			/*LAST 12 BYTES OF FILES-11 RECORD ATTRIBUTES 
    FILL_2 character fill prefix HD2DEF tag $$;		/*SPACES 
    BUFOFF character length 2;				/*BUFFER OFFSET 
    FILL_3 character length 20 fill prefix HD2DEF tag $$;/*SPACES 
end HD2DEF;

end_module $HD2DEF;


module $HD3DEF;

/*+
/* HDR3 ANSI MAGNETIC TAPE LABEL
/* THIS IS THE THIRD LABEL IN FILE LABEL HEADER SET.
/* IT IDENTIFIES THE FILE ATTRIBUTES.
/*-



aggregate HD3DEF structure prefix HD3$;
    HD3LID longword unsigned;				/*LABEL IDENTIFIES AND NUMBER 'HDR3' 
    RECATR character length 64;				/*64 BYTES OF FILES-11 RECORD ATTRIBUTES 
    FILL_1 character length 12 fill prefix HD3DEF tag $$;/*SPACES 
end HD3DEF;

end_module $HD3DEF;


module $HD4DEF;


/*+
/* HDR4 ANSI MAGNETIC TAPE LABEL
/* THIS IS THE FOURTH LABEL IN FILE LABEL HEADER SET.
/* IT CONTAINS THE LONG FILENAME EXTENSION TO THE HDR1 FILE IDENTIFIER
/* FOR VMS LONG FILE NAMES
/*-


aggregate HD4DEF structure prefix HD4$;
    HD4LID longword unsigned;				/*LABEL IDENTIFIER AND NUMBER 'HDR4' 
    FILEID_EXT_SIZE byte unsigned;			/*SIZE OF FILE ID EXT FOR ANSI 4 VOLUMES
    FILEID_EXT character length 62;			/*EXTENSION OF HDR1 FILEID
    FILEID_EXT_V3 character length 2;			/*SIZE OF FILE ID EXT FOR ANSI 3 VOLUMES
    FILL_1 character length 13 fill prefix HD4DEF tag $$; /*SPACES 
end HD4DEF;

end_module $HD4DEF;


module $IAFDEF;
/*+
/* IAF - IMAGE ACTIVATOR FIXUP SECTION
/*
/* THE IMAGE ACTIVATOR FIXUP SECTION IS AN IMAGE SECTION THAT IS CREATED
/* BY THE LINKER AND USED BY THE IMAGE ACTIVATOR TO MODIFY THE IMAGE AS
/* IT IS ACTIVATED.  THIS IS DONE TO MAINTAIN THE POSITION INDEPENDENCE
/* OF EXTERNAL REFERENCES.
/*-



aggregate IAFDEF structure prefix IAF$;
    IAFLINK longword unsigned;				/* Link for image activator use 
    FIXUPLNK longword unsigned;				/* Link for shareable image fixups 
    SIZE word unsigned;					/* Size of fixed part of IAF 
    FLAGS_OVERLAY union fill;
        FLAGS word unsigned;				/* Flags 
	FLAGS_BITS structure fill;
            SHR bitfield;				/* This is in a shareable image 
	end FLAGS_BITS;
    end FLAGS_OVERLAY;
    G_FIXOFF longword unsigned;				/* Offset to g^ address data 
    DOTADROFF longword unsigned;			/* Offset to .address fixup data 
    CHGPRTOFF longword unsigned;			/* Offset to isect change prot. data 
    SHLSTOFF longword unsigned;				/* Offset to shareable image list 
    SHRIMGCNT longword unsigned;			/* Number of shareable images in shlst 
    SHLEXTRA longword unsigned;				/* Number of extra shareable images allowed 
    PERMCTX longword unsigned;				/* Permanent sharable image context 
    FILL_1 longword fill prefix IAFDEF tag $$;		/* Spare 
    FILL_2 longword fill prefix IAFDEF tag $$;		/* Spare 
    FILL_3 longword fill prefix IAFDEF tag $$;		/* Spare 
    FILL_4 longword fill prefix IAFDEF tag $$;		/* Spare 
    FILL_5 longword fill prefix IAFDEF tag $$;		/* Spare 
    FILL_6 longword fill prefix IAFDEF tag $$;		/* Spare 
    constant "LENGTH" equals . prefix IAF$ tag K;	/* Length of fixed area 
    constant "LENGTH" equals . prefix IAF$ tag C;	/* Length of fixed area 
end IAFDEF;

end_module $IAFDEF;


module $ICPDEF;
/*+
/* ICP - CHANGE IMAGE SECTION PROTECTION DATA
/*
/* THIS STRUCTURE IS USED IN THE IMAGE FIXUP SECTION BY THE LINKER
/* TO INFORM THE IMAGE ACTIVATOR OF THE IMAGE SECTIONS THAT NEED
/* THEIR PROTECTION CHANGED.
/*-


aggregate ICPDEF structure prefix ICP$;
    BASEVA longword unsigned;				/* virtual address of start of section 
    NPAGES word unsigned;				/* number of pages to change protection on 
    NEWPRT word unsigned;				/* new protection 
    constant "LENGTH" equals . prefix ICP$ tag K;	/* size of one section's data 
    constant "LENGTH" equals . prefix ICP$ tag C;	/* size of one section's data 
end ICPDEF;

end_module $ICPDEF;


module $IDBDEF;
/*+
/* IDB - INTERRUPT DISPATCH BLOCK
/*
/* AN INTERRUPT DISPATCH BLOCK PROVIDES THE INFORMATION NECESSARY FOR A
/* UNIT INDEPENDENT, BUT CONTROLLER SPECIFIC, INTERRUPT DISPATCHER TO
/* DISPATCH INTERRUPTS TO THE PROPER DRIVER TO HANDLE AN INTERRUPT ON
/* A DEVICE UNIT.
/*-



aggregate IDBDEF structure prefix IDB$;
    CSR longword unsigned;				/*CONTROLLER CSR ADDRESS 
    OWNER longword unsigned;				/*OWNER UCB ADDRESS 
    SIZE word unsigned;					/*SIZE OF IDB IN BYTES 
    TYPE byte unsigned;					/*STRUCTURE TYPE OF IDB 
    VECTOR byte unsigned;				/*CONTROLLER VECTOR OFFSET
    UNITS word unsigned;				/*NUMBER OF UNITS (SIZE OF UCBLST) 
    TT_ENABLE byte unsigned;				/* DZ32 line enable field
    COMBO_CSR_OFFSET byte;				/*OFFSET TO START OF COMBO DEVICE STYLE CSRS
    COMBO_VECTOR_OFFSET byte;				/*OFFSET TO START OF COMBO STYLE DEVICE VECTORS
    SPARE1 byte;					/*A SPARE BYTE
    SPARE2 word;					/*A SPARE WORD
    ADP longword unsigned;				/*ADDRESS OF UBA ADAPTER CONTROL BLOCK 
    UCBLST longword unsigned dimension 8;		/*UCB OR SECONDARY IDB ADDRESSES 
                                            		/*(DEFAULT OF 8)
    constant "LENGTH" equals . prefix IDB$ tag K;	/*LENGTH OF STANDARD IDB 
    constant "LENGTH" equals . prefix IDB$ tag C;	/*LENGTH OF STANDARD IDB 
    
end IDBDEF;

end_module $IDBDEF;


module $IFDDEF;
/*+
/* IMAGE FILE DESCRIPTOR BLOCK - RETURNED BY IMAGE ACTIVATOR
/*-



aggregate IFDDEF structure prefix IFD$;
    SIZE word unsigned;					/*SIZE IN BYTES OF IMAGE FILE DESCRIPTOR 
    FILNAMOFF word unsigned;				/*OFFSET TO RESULTANT FILE NAME STRING 
    FILL_1 word fill prefix IFDDEF tag $$;		/*RESERVED OFFSET 1 
    FILL_2 word fill prefix IFDDEF tag $$;		/*RESERVED OFFSET 2 
    CHAN word unsigned;					/*CHANNEL ON WHICH IMAGE FILE IS OPEN 
    CMCHAN word unsigned;				/*COMPATIBILITY MODE CHANNEL 
    CMKFIADR longword unsigned;				/*COMPATIBILITY MODE IMAGE 
                                            		/*KNOWN FILE ENTRY ADDRESS OR 0
    FLAGS_OVERLAY union fill;
        FLAGS word unsigned;				/*IMAGE FILE DESCRIPTOR FLAGS 
	FLAGS_BITS structure fill;
            EXEONLY bitfield mask;			/*EXECUTE ONLY FILE 
            PRIV bitfield mask;				/*IMAGE INSTALLED WITH ENHANCED PRIVILEGE 
            SETVECTOR bitfield mask;			/*PRIVILEGED VECTORS TO BE INSTALLED 
	end FLAGS_BITS;
    end FLAGS_OVERLAY;
    FILL_3 word fill prefix IFDDEF tag $$;		/*SPARE WORD 
    CURPROG quadword unsigned;				/*STRING DESCRIPTOR FOR CURRENTLY 
                                            		/*RUNNING PROGRAM NAME
    constant "LENGTH" equals . prefix IFD$ tag K;	/*LENGTH OF FIXED AREA OF IFD 
    constant "LENGTH" equals . prefix IFD$ tag C;	/*LENGTH OF FIXED AREA OF IFD 
    
end IFDDEF;

end_module $IFDDEF;



module $IHDDEF;
/*+
/* IMAGE HEADER RECORD DEFINITIONS - FIRST RECORD OF IMAGE HEADER
/*-


aggregate IHDDEF structure prefix IHD$;
    SIZE word unsigned;					/* Size in bytes of Image Header record 
    ACTIVOFF word unsigned;				/* Byte offset to activation data 
    SYMDBGOFF word unsigned;				/* Byte offset to symbol table and debug data 
    IMGIDOFF word unsigned;				/* Byte offset to image ident data 
    PATCHOFF word unsigned;				/* Byte offset to patch data 
    SPARE word unsigned;				/* spare 
    MAJORID word unsigned;				/* Major id 
    constant MAJORID	equals "02"  prefix IHD tag $K;	/* Major id value 
    MINORID word unsigned;				/* Minor id 
    constant MINORID	equals "05"  prefix IHD tag $K;	/* Minor id value 
    HDRBLKCNT byte unsigned;				/* Count of header blocks 
    IMGTYPE byte unsigned;				/* Image type 
/*
/* IMAGE TYPE CODES
/*
    constant EXE	equals 1  prefix IHD tag $K;	/* Executable image 
    constant LIM	equals 2  prefix IHD tag $K;	/* Linkable image 
    
    FILL_2 word fill prefix IHDDEF tag $$;		/* Reserved 
    PRIVREQS  quadword unsigned;			/* Requested privilege mask 
    IOCHANCNT word unsigned;				/*! of channels requested 
                                            		/*0 if default
    IMGIOCNT  word unsigned;				/*! of pages of image i/o section requested 
                                            		/*0 if default
    LNKFLAGS_OVERLAY union;
        LNKFLAGS longword unsigned;			/* Linker produced image flags 
	LNKFLAGS_BITS structure;
            LNKDEBUG bitfield mask;			/* Full debugging requested 
            LNKNOTFR bitfield mask;			/* First transfer address missing 
            NOP0BUFS bitfield mask;			/* RMS use of P0 for image i/o disabled 
            PICIMG   bitfield mask;			/* Image is position independent 
            P0IMAGE  bitfield mask;			/* Image is in P0 space only 
	    DBGDMT   bitfield mask;			/* Image header has dmt fields
	    INISHR   bitfield mask;			/* Transfer array contains valid IHA$L_INISHR
            FILL_3   bitfield length 17 fill prefix IHDDEF tag $$;/*FILL OUT TO HIGH BYTE OF LONG WORD 
            MATCHCTL bitfield mask length 3;		/* Match control for linkable image 
	end LNKFLAGS_BITS;
    end LNKFLAGS_OVERLAY;
    "IDENT" longword unsigned;				/* GBL SEC ident value for linkable image 
    SYSVER  longword unsigned;				/* SYS$K_VERSION or 0 if not linked with exec 
    IAFVA   longword unsigned;				/* Relative virtual address of fixup info 
    constant "LENGTH" equals . prefix IHD$ tag K;	/* Length of fixed area 
    constant "LENGTH" equals . prefix IHD$ tag C;	/* Length of fixed area 

    SKIP character length 510 - .;			/* ALIAS should be last word in 512 byte block
    ALIAS word unsigned;				/* Code to use secondary image name
    /******************************************
    /*
    /*  Define legal range of ALIAS constants. MINCODE must be equal to the
    /*	lowest value and MAXCODE must be equal to the highest value.
    /*
    constant MINCODE equals -1 prefix IHD$ tag C;	/* Low bound of ALIAS values
    constant NATIVE equals -1 prefix IHD$ tag C;	/* Native mode image
    constant RSX    equals  0 prefix IHD$ tag C;	/* RSX image produced by TKB
    constant BPA    equals  1 prefix IHD$ tag C;	/* BASIC plus analog
    constant ALIAS  equals  2 prefix IHD$ tag C;	/* Last 126 bytes contains ASCIC of image to activate
    constant CLI    equals  3 prefix IHD$ tag C;	/* Image is a CLI, run LOGINOUT
    constant MAXCODE equals 3 prefix IHD$ tag C;	/* High bound of ALIAS values
    /*
    /*******************************************

    /*
    /*	Generation number returned by IMGSHR IMG$GET_IHD to SYSIMGACT.
    /*	These do not appear in the image header but are inferred from the 
    /*	contents of the image header
    /*
    constant GEN_XLNKR	equals 1  prefix IHD tag $C;	/* Cross linker
    constant GEN_NATIVE	equals 2  prefix IHD tag $C;	/* First native mode image header.
							/*  does not have LNKFLAGS, SYSVER and IAFVA fields
    constant GEN_LNKFLG	equals 3  prefix IHD tag $C;	/* Native with LNKFLAGS longword added
							/*  does not have SYSVER and IAFVA fields
    constant GEN_SYSVER	equals 4  prefix IHD tag $C;	/* Native with LNKFLAGS and SYSVER added
							/*  does not have IAFVA field
    constant GEN_FIXUP	equals 5  prefix IHD tag $C;	/* Version III image
							/*  contains LNKFLAGS, SYSVER, and IAFVA fields
    constant GEN_NEWISD	equals 6  prefix IHD tag $C;	/* ISD size field is a byte

    
end IHDDEF;

end_module $IHDDEF;


module $IHADEF;

/*+
/* IMAGE HEADER ACTIVATION SECTION OFFSETS
/*-



aggregate IHADEF structure prefix IHA$;
    TFRADR1 longword unsigned;				/*FIRST TRANSFER ADDRESS 
    TFRADR2 longword unsigned;				/*SECOND TRANSFER ADDRESS 
    TFRADR3 longword unsigned;				/*THIRD TRANSFER ADDRESS 
    FILL_1  longword fill prefix IHADEF tag $$;		/*GUARANTEED TRAILING 0 ADDRESS
    INISHR  longword unsigned;				/*SHARED IMAGE INITIALIZATION
							/*(valid if IHD$V_INISHR set)
    constant "LENGTH" equals . prefix IHA$ tag K;	/*SIZE OF ACTIVATION SECTION 
    constant "LENGTH" equals . prefix IHA$ tag C;	/*SIZE OF ACTIVATION SECTION 
    
end IHADEF;

end_module $IHADEF;


module $IHPDEF;

/*+
/* IMAGE HEADER PATCH SECTION OFFSETS
/*-



aggregate IHPDEF structure prefix IHP$;
    ECO1 longword unsigned;				/*DEC ECO LEVELS 1-32 
    ECO2 longword unsigned;				/*DEC ECO LEVELS 33-64 
    ECO3 longword unsigned;				/*DEC ECO LEVELS 65-98 
    ECO4 longword unsigned;				/*USER ECO LEVELS 99-132 
    RW_PATSIZ longword unsigned;			/*SIZE OF FREE RW PATCH AREA 
    RW_PATADR longword unsigned;			/*VIR ADDR OF NEXT FREE RW PATCH AREA 
    RO_PATSIZ longword unsigned;			/*SIZE OF FREE RO PATCH AREA 
    RO_PATADR longword unsigned;			/*VIR ADDR OF NEXT FREE RO PATCH AREA 
    PATCOMTXT longword unsigned;			/*PATCH COMMAND TEXT VIRTUAL BLOCK NUMBER 
    PATDATE quadword unsigned;				/*DATE OF MOST RECENT PATCH 
    constant "LENGTH" equals . prefix IHP$ tag K;	/*LENGTH OF PATCH HEADER SECTION 
    constant "LENGTH" equals . prefix IHP$ tag C;	/*LENGTH OF PATCH HEADER SECTION 
    
end IHPDEF;

end_module $IHPDEF;


module $IHSDEF;

/*+
/* IMAGE HEADER SYMBOL TABLE AND DEBUG SECTION OFFSETS
/*-



aggregate IHSDEF structure prefix IHS$;
    DSTVBN longword unsigned;				/*DEBUG SYMBOL TABLE VIRTUAL BLOCK NUMBER 
    GSTVBN longword unsigned;				/*GLOBAL SYMBOL TABLE VIRTUAL BLOCK NUMBER 
    DSTBLKS word unsigned;				/*DEBUG SYMBOL TABLE BLOCK COUNT 
    GSTRECS word unsigned;				/*GLOBAL SYMBOL TABLE RECORD COUNT 
    DMTVBN  longword unsigned;				/*VBN OF DMT INFORMATION
    DMTBYTES longword unsigned;				/*LENGTH OF DMT INFO
    constant "LENGTH" equals . prefix IHS$ tag K;	/*LENGTH OF SYMBOL TABLE SECTION 
    constant "LENGTH" equals . prefix IHS$ tag C;	/*LENGTH OF SYMBOL TABLE SECTION 
    
end IHSDEF;

end_module $IHSDEF;


module $IHIDEF;


/*+
/* IMAGE HEADER IDENTIFICATION SECTION OFFSETS
/*-



aggregate IHIDEF structure prefix IHI$;
    IMGNAM character length 40;				/*IMAGE NAME STRING 
    IMGID character length 16;				/*IMAGE IDENT STRING 
    LINKTIME quadword unsigned;				/*DATE AND TIME THIS IMAGE WAS LINKED 
                                            		/*STANDARD SYSTEM QUADWORD FORMAT
    LINKID character length 16;				/*LINKER IDENT STRING 
    constant "LENGTH" equals . prefix IHI$ tag K;	/*LENGTH OF IMAGE HEADER IDENT SECTION 
    constant "LENGTH" equals . prefix IHI$ tag C;	/*LENGTH OF IMAGE HEADER IDENT SECTION 
    
end IHIDEF;

end_module $IHIDEF;


module $IHXDEF;
/*+
/* IMAGE HEADER RECORD DEFINITIONS - CROSS LINKER - MAJORID = "01"
/*         1ST RECORD OF IMAGE HEADER BLOCK
/*-



aggregate IHXDEF structure prefix IHX$;
    SIZE word unsigned;					/*SIZE IN BYTE OF IMAGE HEADER RECORD 
    HDRBLKCNT byte unsigned;				/*COUNT OF BLOCKS IN IMAGE HEADER 
    FILL_1 byte fill prefix IHXDEF tag $$;		/*SPARE 
    STARTADR quadword unsigned;				/*START ADDRESS 
    MAJORID word unsigned;				/*MAJOR ID OF IMAGE HEADER 
    constant MAJORID	equals (%X3130)  prefix IHX tag $K;/*^A/01/ MAJOR ID VALUE FOR CROSS LINKER 
    MINORID word unsigned;				/*MINOR ID OF IMAGE HEADER 
    constant MINORID	equals (%X3130)  prefix IHX tag $K;/*^A/01/ MINOR ID VALUE FOR CROSS LINKER 
    constant MINORID1	equals (%X3130)  prefix IHX tag $K;/*^A/01/ MINOR ID VALUE FOR CROSS LINKER WITH 
                                            		/*SYMBOL TABLE AND 3RD TRANSFER ADR
    IMGNAM character length 24;				/*IMAGE NAME 
/*
/* THE FOLLOWING FIELDS ARE PRESENT FOR MINOR ID'S GREATER OR EQUAL TO "03"
/*
    DSTVBN longword unsigned;				/*DEBUG SYMBOL TABLE VBN 
    GSTVBN longword unsigned;				/*GLOBAL SYMBOL TABLE VBN 
    DSTBLKS word unsigned;				/*DEBUG SYMBOL TABLE BLOCKS 
    GSTRECS word unsigned;				/*GLOBAL SYMBOL TABLE RECORD COUNT 
    TFRADR3 longword unsigned;				/*THIRD TRANSFER ADDRESS 
    constant "LENGTH" equals . prefix IHX$ tag K;	/*LENGTH OF CROSS LINKER HEADER 
    constant "LENGTH" equals . prefix IHX$ tag C;	/*LENGTH OF CROSS LINKER HEADER 
    
end IHXDEF;

end_module $IHXDEF;


module $IMPDEF;
/*+
/*        RMS32 IMPURE AREA OFFSET DEFINITIONS
/*
/*-


aggregate IMPDEF structure prefix IMP$;
    RMSSTATUS_OVERLAY union fill;
        RMSSTATUS word unsigned;			/* RMS OVERALL STATUS 
	RMSSTATUS_BITS structure fill;
            IIOS bitfield;				/* SET IF THIS IS THE IMAGE 
                                    			/* I.O SEGMENT
            AST bitfield;				/* SET IF RUNNING AT EXEC AST LEVEL 
            TEMP1 bitfield;				/* TEMPORARY FLAG 
            TEMP2 bitfield;				/* " 
            IORUNDOWN bitfield;				/* SET IF IO RUNDOWN IN PROGRESS 
            NOP0BUFS bitfield;				/* SET IF RMS USE OF P0 FOR IMAGE I/O DISABLED 
            RUH bitfield;				/* Set if within RMS RU Handler 
	    RECOVERY bitfield;				/* SET IF RECOVERY IN PROGRESS
	    RUH_SYNCH bitfield;				/* SET IF RMS IO MUST SYNCH
							/* WITH THE RU HANDLER
	end RMSSTATUS_BITS;
/*
        constant ASYEFN	equals 30  prefix IMP tag $C;	/* EFN FOR ASYNC WAITS 
        constant IOREFN	equals 30  prefix IMP tag $C;	/* EFN FOR IO RUNDOWN SYNCHRONIZATION 
        constant ASYQIOEFN	equals 31  prefix IMP tag $C;/* EFN FOR ASYNC QIOS 
        constant SYNCEFN	equals 27  prefix IMP tag $C;/* BASE EFN FOR SYNCHRONOUS QIO'S 
                                			/* (28, 29 ALSO USED)
        constant MBXEFN	equals 26  prefix IMP tag $C;	/* EFN FOR QIOS TO NETWORK MAILBOXES 
/*
    end RMSSTATUS_OVERLAY;
    PROT byte unsigned;					/* PROTECTION FOR I/O BUFFER PAGES 
    FILL_1 byte fill prefix IMPDEF tag $$;		/* SPARE 
    IOSEGADDR longword unsigned;			/* ADDRESS OF FIRST FREE PAGE 
                            				/* IN THIS (IMAGE OR PROCESS)
                            				/* I/O SEGMENT
    IOSEGLEN longword unsigned;				/* ! OF FREE BYTES AT ABOVE ADDR 
    FREEPGLH longword unsigned dimension 2;		/* FREE PAGE LIST HEAD 
    SAVED_SP longword unsigned;				/* SAVED VALUE OF SP AT ENTRY 
    IFABTBL longword unsigned;				/* IFAB TABLE ADDR 
    IRABTBL longword unsigned;				/* IRAB TABLE ADDR 
    ENTPERSEG word unsigned;				/* ! OF SLOTS PER TABLE SEGMENT 
    constant NPIOFILES	equals 63  prefix IMP tag $C;	/* ! OF PIO SEGMENT FILES 
    constant ENTPERSEG	equals 15  prefix IMP tag $C;	/* ! OF IIO SEGMENT SLOTS 
                                    			/* PER INDEX TABLE SEGMENT
    NUM_IFABS word unsigned;				/* NUMBER OF IFABS & IRABS CURRENTLY ALLOCATED 
    IFBTBLINK longword unsigned;			/* START OF IFAB TABLE (LINK TO NEXT SEGMENT) 
    FILL_2 longword dimension 15 fill prefix IMPDEF tag $$;/* FIRST IFAB TABLE SEGMENT 
    IRBTBLINK longword unsigned;			/* START OF IRAB TABLE (LINK TO NEXT SEGMENT) 
end IMPDEF;

end_module $IMPDEF;


module $IOCDEF;

/*+
/*
/* $IOCDEF - flag bits used in I/O database search routines.
/*
/*-


aggregate IOCDEF structure prefix IOC$;
					/* IOC$V_PHY must be bit 0!!
    PHY bitfield mask;			/* physical device specified
    TYPE bitfield mask;			/* device type name specified
    CLASS bitfield mask;		/* allocation class present
    LOCAL bitfield mask;		/* search local devices only
    EXISTS bitfield mask;		/* device exists
    "2P" bitfield mask;			/* device is on UCB secondary path
    ANY bitfield mask;			/* find any matching device
    MOUNT bitfield mask;		/* find only mountable devices
    ALT bitfield mask;			/* alternate UCB found
    NO_TRANS bitfield mask;		/* caller translated logical name
    ALLOC bitfield mask;		/* allocate mountable device

end IOCDEF;

end_module $IOCDEF;

module $IO780DEF;
/*+
/* I/O SPACE LAYOUT FOR 11/780 CPU
/*-


	 						/*DEFINE CONSTANT ADDRESSES 
constant IOBASE	equals +%X20000000  prefix IO780$ tag AL;/*START OF I/O SPACE 
constant PERNEX	equals +%X2000  prefix IO780$ tag AL;	/*! BYTES OR REGISTER SPACE/NEXUS 
constant NNEX	equals 16  prefix IO780$ tag AL;	/*! OF NEXUSES 
constant UB0SP	equals +%X20100000  prefix IO780$ tag AL;/*ADDR OF UB 0 SPACE 
constant UB1SP	equals +%X20140000  prefix IO780$ tag AL;/*ADDR OF UB 1 SPACE 
constant UB2SP	equals +%X20180000  prefix IO780$ tag AL;/*ADDR OF UB 2 SPACE 
constant UB3SP	equals +%X201C0000  prefix IO780$ tag AL;/*ADDR OF UB 3 SPACE 

end_module $IO780DEF;

module $IO750DEF;
/*+
/* I/O SPACE LAYOUT FOR 11/750 CPU
/*-


	 						/*DEFINE CONSTANT ADDRESSES 
constant IOBASE	equals +%XF20000  prefix IO750$ tag AL;	/*START OF I/O SPACE FOR SLOT 16 
constant PERNEX	equals +%X2000  prefix IO750$ tag AL;	/*! BYTES OF REGISTER SPACE/NEXUS 
constant UBBASE	equals +%XF30000  prefix IO750$ tag AL;	/*START OF UB 0 SPACE 
constant MBBASE	equals +%XF28000  prefix IO750$ tag AL;	/*START OF MB0 REGISTER SPACE 
constant FLOAT	equals +%XF34000  prefix IO750$ tag AL;	/*START OF FLOATING ADAPTER SPACE 
constant NNEX	equals 16  prefix IO750$ tag AL;	/*! CONFIGURABLE NEXUSES 
constant UB0SP	equals +%XFC0000  prefix IO750$ tag AL;	/*ADDR OF UB0 SPACE 
constant UB1SP	equals +%XF80000  prefix IO750$ tag AL;	/*ADDR OF UB1 SPACE 
	 						/*FIXED ADAPTER ASSIGNMENTS FOR 
                                        		/* SLOTS 0-9:
constant MEM0	equals 0  prefix IO750$C_ tag SL;	/* MEMORY CONTROLLER 
constant MPM0	equals 1  prefix IO750$C_ tag SL;	/* MULTIPORT MEMORIES... 
constant MPM1	equals 2  prefix IO750$C_ tag SL;	/* 
constant MPM2	equals 3  prefix IO750$C_ tag SL;	/* 
constant MB0	equals 4  prefix IO750$C_ tag SL;	/* MASSBUS ADAPTERS... 
constant MB1	equals 5  prefix IO750$C_ tag SL;	/* 
constant MB2	equals 6  prefix IO750$C_ tag SL;	/* 
constant MB3	equals 7  prefix IO750$C_ tag SL;	/* 
constant UB0	equals 8  prefix IO750$C_ tag SL;	/* UNIBUS 0 
constant UB1	equals 9  prefix IO750$C_ tag SL;	/* UNIBUS 1 

end_module $IO750DEF;

module $IO730DEF;
/*++
/* I/O SPACE LAYOUT FOR 11/730 CPU
/*--


constant IOBASE	equals +%XF20000  prefix IO730$ tag AL;	/* START OF I/O SPACE 
constant PERNEX	equals +%X2000  prefix IO730$ tag AL;	/* ! BYTES OF REGISTER SPACE/NEXUS 
constant NNEX	equals 16  prefix IO730$ tag AL;	/* ! OF NEXUSES 
constant UB0SP	equals +%XFC0000  prefix IO730$ tag AL;	/* ADDR OF UB0 SPACE 

end_module $IO730DEF;

module $IO790DEF;

/*++
/* I/O SPACE LAYOUT FOR 11/790 CPU
/*--


constant IOA0	equals +%X20000000  prefix IO790$ tag AL;/*START OF I/O SPACE FOR ABUS ADAPTER 0 
constant IOA1	equals +%X22000000  prefix IO790$ tag AL;/*START OF I/O SPACE FOR ABUS ADAPTER 1 
constant IOA2	equals +%X24000000  prefix IO790$ tag AL;/*START OF I/O SPACE FOR ABUS ADAPTER 2 
constant IOA3	equals +%X26000000  prefix IO790$ tag AL;/*START OF I/O SPACE FOR ABUS ADAPTER 3 
constant PERNEX	equals +%X2000  prefix IO790$ tag AL;	/*! OF BYTES OF REGISTER SPACE/NEXUS 
constant NNEX	equals 16  prefix IO790$ tag AL;	/*NUMBER OF NEXUS PER SBIA 
constant UB0SP	equals +%X100000  prefix IO790$ tag AL;	/* OFFSET OF UB 0 SPACE FROM BASE OF SBIA 
constant IOACR	equals +%X80000  prefix IO790$ tag AL;	/* OFFSET OF IO ADAPTER CR FROM BASE OF SBIA 
constant PERABS equals +%X2000000 prefix IO790$ tag AL;	/* ADDRESS SPACE FOR EACH ABUS ADAPTER

constant SBIA	equals 1 prefix IO790$ tag K;		/* TYPE CODE FOR SBIA ADAPTER
constant SBIA	equals 1 prefix IO790$ tag C;		/* TYPE CODE FOR SBIA ADAPTER

end_module $IO790DEF;

module $IOUV1DEF;
/*++
/* I/O SPACE LAYOUT FOR MICRO-VAX I CPU
/*--


constant QB0SP	equals +%X20000000  prefix IOUV1$ tag AL; /* ADDR OF QBUS SPACE 

end_module $IOUV1DEF;

module $IO8NNDEF;

/*+
/* I/O SPACE LAYOUT FOR 11/8NN CPU
/*-

/* NBIA Type code found in NAC field
constant NBIA	equals +%x10	   prefix IO8NN$ tag K;	 /* NBIA type
constant NBIA	equals +%x10	   prefix IO8NN$ tag C;	 /* NBIA type

/* Define constant addresses

constant IOBASE	equals +%X20000000  prefix IO8NN$ tag AL; /* Start of I/O space
/*
constant NBIA_0	equals +%X20000000  prefix IO8NN$ tag AL; /* I/O space for first NBIA
constant NBIB_0	equals +%X20000000  prefix IO8NN$ tag AL; /* I/O space 1st BI
constant NBIB_1	equals +%X22000000  prefix IO8NN$ tag AL; /* I/O space 2nd BI
/*
constant NBIA_1	equals +%X24000000  prefix IO8NN$ tag AL; /* I/O space for second NBIA
constant NBIB_2	equals +%X24000000  prefix IO8NN$ tag AL; /* I/O space 3rd BI
constant NBIB_3	equals +%X26000000  prefix IO8NN$ tag AL; /* I/O space 4th BI
/*
constant NMI_MEM equals +%X3E000000  prefix IO8NN$ tag AL; /* Nautilus Memory
/*
constant NMI_CSR0 equals +%X80000   prefix IO8NN$ tag AL; /* offset to NMI CSR0
constant PERNMI	  equals +%X2000000 prefix IO8NN$ tag AL; /* I/O space per NMI nexus
constant PERNBIA  equals +%X40000   prefix IO8NN$ tag AL; /* offset to next NBIA
constant PERNBIB  equals +%X20000   prefix IO8NN$ tag AL; /* offset to next NBIB
constant PERNEX	  equals +%X2000    prefix IO8NN$ tag AL; /* # bytes of register space/nexus 
constant NNEX	  equals 16 	    prefix IO8NN$ tag AL; /* # of Nexuses per BI
constant UB0SP    equals +%X100000  prefix IO8NN$ tag AL; /* First unibus space

/* Define BI address space offsets and lengths

constant BRDCST	equals +%X20000	    prefix IO8NN$ tag AL; /* offset to broadcast space
constant BTROM	equals +%X40000	    prefix IO8NN$ tag AL; /* offset to boot rom space
constant NODESP equals +%X400000    prefix IO8NN$ tag AL; /* offset to BI node window 0
constant NDSPER equals +%X40000	    prefix IO8NN$ tag AL; /* size of BI node window

end_module $IO8NNDEF;

module $IO8SSDEF;
/*+
/* I/O SPACE LAYOUT FOR 11/8SS CPU
/*-


	 						 /* Define constant addresses 
constant IOBASE	equals +%X20000000  prefix IO8SS$ tag AL;/* Base of I/O space
constant PERNEX	equals +%X2000      prefix IO8SS$ tag AL;/* Size of Register Space/Node
constant NNEX	equals 16  	    prefix IO8SS$ tag AL;/* # of Nodes
constant BRDCST	equals +%X20020000  prefix IO8SS$ tag AL;/* Base of Broadcast Space
constant BTROM	equals +%X20040000  prefix IO8SS$ tag AL;/* Base of Bootrom Space
constant NDPRIV	equals +%X20080000  prefix IO8SS$ tag AL;/* Base of Node Private Space
constant PCNTL	equals +%X20088000  prefix IO8SS$ tag AL;/* Pcntl CSR in Node Private Space
constant NIBUF	equals +%X20090000  prefix IO8SS$ tag AL;/* NI Packet Buffer in Node Private Space
constant EEPROM	equals +%X20098000  prefix IO8SS$ tag AL;/* EEPROM in Node Private Space
constant NIDATA	equals +%X200A0000  prefix IO8SS$ tag AL;/* NI Data Register in Node Private Space
constant NIADDR	equals +%X200A8000  prefix IO8SS$ tag AL;/* NI ADDR Register in Node Private Space
constant RCX50	equals +%X200B0000  prefix IO8SS$ tag AL;/* RX50 Registers in Node Private Space
constant WATCH	equals +%X200B8000  prefix IO8SS$ tag AL;/* Watch Chip in Node Private Space
constant NODESP	equals +%X20400000  prefix IO8SS$ tag AL;/* Node 0 Window Space
constant NDSPER	equals +%X40000     prefix IO8SS$ tag AL;/* Size of Window Space

end_module $IO8SSDEF;

module $IPLDEF;
/*+
/* TEMPORARY PROCESSOR PRIORITY LEVEL DEFINITIONS
/*-

	 						/* 
constant HWCLK	equals 24  prefix IPL tag $;		/*HARDWARE CLOCK LEVEL 
constant PERFMON equals 15  prefix IPL tag $;		/*PERFORMANCE MONITORING SYNCH LEVEL 
constant IOPOST	equals 4  prefix IPL tag $;		/*I/O POST PROCESSING LEVEL 
constant MAILBOX	equals 11  prefix IPL tag $;	/*WRITE MAILBOX INTERLOCK LEVEL 
constant POWER	equals 31  prefix IPL tag $;		/*POWERFAIL INTERLOCK LEVEL 
constant QUEUEAST	equals 6  prefix IPL tag $;	/*QUEUE AST LEVEL 
constant SCHED	equals 3  prefix IPL tag $;		/*SCHEDULER LEVEL 
constant SYNCH	equals 8  prefix IPL tag $;		/*SYSTEM DATA BASE SYNCHRONIZATION LEVEL 
constant TIMER	equals 8  prefix IPL tag $;		/*TIME QUEUE PROCESSING LEVEL 
constant TIMERFORK equals 7 prefix IPL tag $;		/*TIMER FORK INTERRUPT LEVEL
constant ASTDEL	equals 2  prefix IPL tag $;		/*AST DELIVERY INTERRUPT 
constant SCS	equals 8  prefix IPL tag $;		/*SCS SYNCHRONIZATION IPL 

end_module $IPLDEF;


module $IRPDEF;
/*+
/* IRP - I/O REQUEST PACKET
/*
/* I/O REQUEST PACKETS ARE CONSTRUCTED BY THE QUEUE I/O REQUEST SYSTEM
/* SERVICE. THE CONTENT OF AN I/O REQUEST PACKET DESCRIBES A FUNCTION TO
/* BE PERFORMED ON A DEVICE UNIT.
/*
/* NOTE: SEVERAL FIELDS OF THE IRP MUST BE AT THE SAME OFFSETS AS THEIR
/* CORRESPONDING FIELDS IN THE IRPE (SEE NEXT PAGE).
/*
/*-



aggregate IRPDEF structure prefix IRP$;
    IOQFL longword unsigned;				/*I/O QUEUE FORWARD LINK 
    IOQBL longword unsigned;				/*I/O QUEUE BACKWARD LINK 
    SIZE word unsigned;					/*SIZE OF IRP IN BYTES 
    TYPE byte unsigned;					/*STRUCTURE TYPE FOR IRP 
    RMOD_OVERLAY union fill;
        RMOD byte unsigned;				/*ACCESS MODE OF REQUEST 
	RMOD_BITS structure fill;
            MODE bitfield length 2;			/* MODE SUBFIELD 
	end RMOD_BITS;
    end RMOD_OVERLAY;
    PID longword unsigned;				/*PROCESS ID OF REQUESTING PROCESS 
    AST longword unsigned;				/*ADDRESS OF AST ROUTINE 
    ASTPRM longword unsigned;				/*AST PARAMETER 
    WIND longword unsigned;				/*ADDRESS OF WINDOW BLOCK 
    UCB longword unsigned;				/*ADDRESS OF DEVICE UCB 
    FUNC_OVERLAY union fill;
        FUNC word unsigned;				/*I/O FUNCTION CODE AND MODIFIERS 
	FUNC_BITS structure fill;
            FCODE bitfield mask length 6;		/* FUNCTION CODE FIELD 
            FMOD bitfield length 10;			/* FUNCTION MODIFIER FIELD 
	end FUNC_BITS;
    end FUNC_OVERLAY;
    EFN byte unsigned;					/*EVENT FLAG NUMBER AND EVENT GROUP 
    PRI byte unsigned;					/*BASE PRIORITY OF REQUESTING PROCESS 
    IOSB longword unsigned;				/*ADDRESS OF I/O STATUS DOUBLE LONGWORD 
    CHAN word unsigned;					/*PROCESS I/O CHANNEL NUMBER 
    STS_OVERLAY union fill;
        STS word unsigned;				/*REQUEST STATUS 
	STS_BITS structure fill;
            BUFIO bitfield mask;			/* BUFFERED I/O FLAG ;THESE BITS 
            FUNC bitfield mask;				/* 1=>READ FUNCTION ;MUST BE ADJACENT 
            PAGIO bitfield mask;			/* PAGING I/O FLAG ;AND IN ORDER 
            COMPLX bitfield mask;			/* COMPLEX BUFFERED I/O 
            VIRTUAL bitfield mask;			/* VIRTUAL I/O FUNCTION 
            CHAINED bitfield mask;			/* CHAINED BUFFERED I/O OPERATION 
            SWAPIO bitfield mask;			/* SWAP I/O OPERATION 
            DIAGBUF bitfield mask;			/* DIAGNOSTIC BUFFER ALLOCATED 
            PHYSIO bitfield mask;			/* PHYSICAL I/O 
            TERMIO bitfield mask;			/* TERMINAL I/O (FOR SELECTING PRIORITY INC) 
            MBXIO bitfield mask;			/* MAILBOX BUFFERED READ 
            EXTEND bitfield mask;			/* AN IRPE IS LINKED TO THIS IRP 
            FILACP bitfield mask;			/* FILE ACP I/O (BOTH DIOCNT AND BIOCNT) 
            MVIRP bitfield mask;			/* MOUNT VERIFICATION IRP 
	    JNL_REMREQ bitfield mask;			/* REMOTE (SLAVE) REQUEST
            KEY bitfield mask;				/* KEY FOR ENCRYPTION
	end STS_BITS;
    end STS_OVERLAY;
    SVAPTE longword unsigned;				/*SYSTEM VIRTUAL ADDRESS OF FIRST PTE 
    BOFF word unsigned;					/*BYTE OFFSET IN FIRST PAGE 
    BCNT_OVERLAY union fill;
        BCNT longword unsigned;				/*BYTE COUNT OF TRANSFER 
        BCNT word unsigned;				/* OLD WORD DEFINITION FOR COMPATIBILITY 
    end BCNT_OVERLAY;
    FILL_1 word fill prefix IRPDEF tag $$;		/* ROUND UP TO NEXT LONGWORD 
    IOST1_OVERLAY union fill;
        IOST1 longword unsigned;			/*FIRST I/O STATUS LONGWORD (FOR I/O POST) 
        MEDIA longword unsigned;			/*MEDIA ADDRESS 
    end IOST1_OVERLAY;
    IOST2_OVERLAY union fill;
        IOST2 longword unsigned;			/*SECOND I/O STATUS LONGWORD 
	TT_TERM_OVERLAY union fill;
            TT_TERM longword unsigned;			/*ADDRESS OF READ TERMINATORS MASK 
            CARCON byte unsigned;			/*CARRIAGE CONTROL 
	end TT_TERM_OVERLAY;
    end IOST2_OVERLAY;
    NT_PRVMSK_OVERLAY union fill;
        NT_PRVMSK quadword unsigned;			/* PRIVILEGE MASK FOR DECNET 
        STATION quadword unsigned;			/* STATION FIELD FOR DECNET DRIVERS
	TT_STATE_OVERLAY union fill;
            TT_STATE quadword unsigned;			/* TERMINAL STATE DEFINITIONS 
	    TT_STATE_FIELDS structure fill;
		ABCNT_OVERLAY union fill;
                    ABCNT longword unsigned;		/* ACCUMULATED BYTES TRANSFERED 
                    ABCNT word unsigned;		/* OLD WORD DEFINITION FOR COMPATIBILITY 
		end ABCNT_OVERLAY;
		OBCNT_OVERLAY union fill;
                    OBCNT longword unsigned;		/* ORIGINAL TRANSFER BYTE COUNT 
                    OBCNT word unsigned;		/* OLD WORD DEFINITION FOR COMPATIBILITY 
		end OBCNT_OVERLAY;
	    end TT_STATE_FIELDS;
	end TT_STATE_OVERLAY;
    end NT_PRVMSK_OVERLAY;
    SEGVBN_OVERLAY union fill;
        SEGVBN longword unsigned;			/*VIRTUAL BLOCK NUMBER OF CURRENT SEGMENT 
        JNL_SEQNO longword unsigned;			/* SEQUENCE NUMBER IN JOURNAL 
    end SEGVBN_OVERLAY;
    DIAGBUF_OVERLAY union fill;

        DIAGBUF longword unsigned;			/* DIAGNOSTIC BUFFER ADDRESS 
        TT_PRMPT word unsigned;				/* PROMPT SIZE 
    end DIAGBUF_OVERLAY;
    SEQNUM longword unsigned;				/* SEQUENCE NUMBER 
    EXTEND longword unsigned;				/* ADDRESS OF IRPE 
    ARB longword unsigned;				/* ACCESS RIGHTS BLOCK ADDRESS 
    KEYDESC longword unsigned;				/* ADDRESS OF ENCRYPTION DESCRIPTOR
    
/* Standard IRP must contain space for Class Driver CDRP fields.
    
    constant CDRP equals .;				/* Offset to the CDRP within the IRP 
    constant CDRP equals . tag C;			/* Offset to the CDRP within the IRP

    FQFL longword unsigned;				/* Fork Queue FLINK 
    FQBL longword unsigned;				/* Fork Queue Blink 
    CDRPSIZE word unsigned;				/* Size field for positive section only 
    CD_TYPE byte unsigned;				/* Type, always of interest 
    FIPL byte unsigned;					/* Fork IPL 
    FPC longword unsigned;				/* Fork PC 
    FR3 longword unsigned;				/* Fork R3 
    FR4 longword unsigned;				/* Fork R4 
    SAVD_RTN longword unsigned;				/* Saved return address from level 1 JSB 
    MSG_BUF longword unsigned;				/* Address of allocated MSCP buffer 
    RSPID longword unsigned;				/* Allocated Request ID 
    CDT longword unsigned;					/* Address of Connection Descriptor Table 
    RWCPTR longword unsigned;				/* RWAITCNT pointer 

/*	Extensions to the CDRP within the IRP

    CDRP_EXTENSIONS union fill;

/*	Block Transfer Extension

	BLK_XFER_EXTENSION structure fill;
	    LBUFH_AD longword unsigned;			/* Local BUFfer Handle ADress 
	    LBOFF longword unsigned;			/* Local Byte OFFset 
	    RBUFH_AD longword unsigned;			/* Remote BUFfer Handle ADress 
	    RBOFF longword unsigned;			/* Remote Byte OFFset 
	    XCT_LEN longword unsigned;			/* Transfer length in bytes 
	    constant BT_LEN equals .;
	    constant BT_LEN equals . tag C;
	end BLK_XFER_EXTENSION;
    
/*	Class Driver Extension
    
	CLS_DRV_EXTENSION structure fill;
	    FILL_3 longword fill;			{  Skip local buffer handle address (above)
	    LBUFHNDL character length 12;		/* Local buffer handle 
	    UBARSRCE longword unsigned;			/* UNIBUS mapping resources allocated 
	    DUTUFLAGS longword unsigned;		/* Class driver status flags:
		{ See CDRP definition for bit field 
		{ definitions.
	    DUTUCNTR word unsigned;			/* General purpose counter
	    ENDMSGSIZ word unsigned;			/* Size of most recent MSCP end message
	    constant CD_LEN equals .;
	    constant CD_LEN equals . tag C;
	end CLS_DRV_EXTENSION;

/*	Connection management extension

	CON_MGT_EXTENSION structure fill;
	    CNX_WORK_AREA  union fill;
		CNX_CLIENT_DATA structure fill;
		    VAL1 longword unsigned;		/* data value 1
		    VAL2 longword unsigned;		/* data value 2
		    VAL3 longword unsigned;		/* data value 3
		    VAL4 longword unsigned;		/* data value 4
		    VAL5 longword unsigned;		/* data value 5
		    VAL6 longword unsigned;		/* data value 6
		    VAL7 longword unsigned;		/* data value 7
		    VAL8 longword unsigned;		/* data value 8
		end CNX_CLIENT_DATA;
		CNX_BLOCK_XFER structure fill;
		    FILL_LBUFH_AD longword fill;	{ filler for CDRP$L_LBUFH_AD
		    FILL_VAL longword dimension 4;	{ filler for VAL2 through VAL5
		    CNXSVAPTE longword unsigned;	/* Block SVAPTE
		    CNXBOFF word unsigned;		/* Block buffer offset
		    CNXBCNT longword unsigned;		/* Block xfer length
		    CNXRMOD byte unsigned;		/* Block access mode
		    CLTSTS byte unsigned;		/* A client's status field
		end CNX_BLOCK_XFER;
	    end CNX_WORK_AREA;
	    MSGBLD longword unsigned;			/* Address of MSG BUILD routine
	    SAVEPC longword unsigned;			/* Caller's saved PC
	    SENDSEQNM word unsigned;			/* Message sequence number
	    CNXSTATE byte unsigned;			/* CNX message state
		constant (				/* Possible states:
		      NORMAL				/* The standard case (particulary no block xfer)
		    , REQUESTOR				/* Block transfer requestor
		    , PARTNER				/* Block transfer partner
		    ) equals 0 increment 1;
	    FILL_5 byte fill;
	    RETRSPID_OVERLAY union fill;
		RETRSPID longword unsigned;		/* RSPID to return
		BTX longword unsigned;			/* BTX address
	    end RETRSPID;
	    VAL9 longword unsigned;			/* data value 9
	    constant CM_LENGTH equals .;
	    /*
	    /* The following fields are only valid
	    /* for long connection manager CDRPs.
	    /*
	    VAL10 longword unsigned;			/* data value 10
	    constant CM_LONG_LENGTH equals.;
	end CON_MGT_EXTENSTION;

    end CDRP_EXTENSIONS;
    
    constant "LENGTH" equals .;			/* LENGTH OF STANDARD IRP 
    constant "LENGTH" equals . tag C;		/* LENGTH OF STANDARD IRP 

end IRPDEF;

end_module $IRPDEF;


module $IRPEDEF;
/*+
/* IRPE - I/O REQUEST PACKET EXTENSION
/*
/* I/O REQUEST PACKET EXTENSIONS ARE USED TO HOLD ADDITIONAL INFORMATION
/* ABOUT I/O REQUESTS FOR DEVICES THAT REQUIRE MORE CONTEXT THAN CAN FIT INTO
/* THE STANDARD IRP.  IRPE'S ARE BUILT AND LINKED ONTO IRP'S BY DEVICE
/* DRIVER FDT ROUTINES.  ANY FIELDS THAT ARE NOT DEFINED IN THIS STRUCTURE
/* MAY BE USED TO HOLD DRIVER DEPENDENT DATA.
/*
/* THE CURRENTLY DEFINED FIELDS IN THE IRPE WERE POSITIONED SO THAT THE
/* PACKET COULD BE USED AS A FORK BLOCK.  THIS SHOULD BE KEPT IN MIND IF
/* AND WHEN NEW FIELDS ARE DEFINED.
/*
/* THE FIELDS DEFINED HERE MUST BE AT THE SAME OFFSETS AS THEIR CORRESPONDING
/* FIELDS IN THE IRP (SEE PREVIOUS PAGE).
/*
/*-



aggregate IRPEDEF structure prefix IRPE$;
    FILL_1 longword fill prefix IRPEDEF tag $$;		/* SPARE LONGWORD 
    FILL_2 longword fill prefix IRPEDEF tag $$;		/* SPARE LONGWORD 
    SIZE word unsigned;					/* SIZE OF IRPE IN BYTES 
    TYPE byte unsigned;					/* STRUCTURE TYPE FOR IRPE 
    FILL_3 byte fill prefix IRPEDEF tag $$;		/* SPARE BYTE 
    FILL_4 longword dimension 7 fill prefix IRPEDEF tag $$;/* 7 SPARE LONGWORDS 
    FILL_5 word fill prefix IRPEDEF tag $$;		/* SPARE WORD 
    STS_OVERLAY union fill;
        STS word unsigned;				/* STATUS 
	STS_BITS structure fill;
            FILL_6 bitfield length 11 fill prefix IRPEDEF tag $$;/* SKIP OVER 11 BITS 
            EXTEND bitfield mask;			/* ANOTHER IRPE IS LINKED TO THIS ONE 
	end STS_BITS;
    end STS_OVERLAY;
    SVAPTE1 longword unsigned;				/* SYSTEM VIR. ADDR. OF PTE FOR REGION 1 
    BOFF1 word unsigned;				/* BYTE OFFSET FOR REGION 1 
    FILL_7 word fill prefix IRPEDEF tag $$;		/* SPARE WORD 
    BCNT1 longword unsigned;				/* BYTE COUNT FOR REGION 1 
    SVAPTE2 longword unsigned;				/* SYSTEM VIR. ADDR. OF PTE FOR REGION 2 
    BOFF2 word unsigned;				/* BYTE OFFSET FOR REGION 2 
    FILL_8 word fill prefix IRPEDEF tag $$;		/* SPARE WORD 
    BCNT2 longword unsigned;				/* BYTE COUNT FOR REGION 2 
    FILL_9 longword dimension 4 fill prefix IRPEDEF tag $$;/* 4 SPARE LONGWORDS 
    EXTEND longword unsigned;				/* ADDRESS OF NEXT IRPE 
    constant "LENGTH" equals . prefix IRPE$ tag K;	/* LENGTH OF IRPE 
    constant "LENGTH" equals . prefix IRPE$ tag C;	/* LENGTH OF IRPE 
end IRPEDEF;

end_module $IRPEDEF;


module $ISDDEF;
/*+
/* IMAGE SECTION DESCRIPTOR DEFINITIONS
/*-



aggregate ISDDEF structure prefix ISD$;
    SIZE word unsigned;					/*SIZE IN BYTES OF THIS ISD 
    PAGCNT word unsigned;				/*! OF PAGES DESCRIBED BY THIS ISD 
    VPNPFC_OVERLAY union fill;
        VPNPFC longword unsigned;			/*VPN & PFC VIELDS 
	VPNPFC_BITS0 structure fill;
            VPN bitfield length 21;			/* STARTING VIRTUAL PAGE NUMBER 
            P1 bitfield;				/* P1 SPACE 
            SYSTEM bitfield;				/* SYSTEM SPACE 
            FILL_1 bitfield fill prefix ISDDEF tag $$;	/* SPARE 
            PFC bitfield length 8;			/* PAGE FAULT CLUSTER 
	end VPNPFC_BITS0;
	VPNPFC_BITS1 structure fill;
            VPG bitfield length 23;			/* VIRTUAL PAGE INCLUDING P1 & S 
	end VPNPFC_BITS1;
	VPNPFC_FIELDS2 structure fill;
            FILL_4 byte dimension 3 fill prefix ISDDEF tag $$;
            PFC byte unsigned;				/*PAGE FAULT CLUSTER 
	end VPNPFC_FIELDS2;
    end VPNPFC_OVERLAY;
    FLAGS_OVERLAY union fill;
        FLAGS longword unsigned;			/*FLAGS AND ISD TYPE 
        constant LENDZRO equals . prefix ISD$ tag K;	/*LENGTH OF DEMAND ZERO ISD 
        constant LENDZRO equals . prefix ISD$ tag C;	/*LENGTH OF DEMAND ZERO ISD 
	FLAGS_BITS structure fill;
            GBL bitfield mask;				/* GLOBAL 
            CRF bitfield mask;				/* COPY ON REFERENCE 
            DZRO bitfield mask;				/* DEMAND ZERO PAGE 
            WRT bitfield mask;				/* WRITABLE 
            MATCHCTL bitfield mask length 3;		/* IDENT MATCH CONTROL FIELD 
            LASTCLU bitfield mask;			/* ISD IS PART OF LAST P0 SPACE CLUSTER 
            COPYALWAY bitfield mask;			/* COPY ALWAYS FROM USER IMAGE 
            "BASED" bitfield mask;			/* ISECT IS BASED 
            FIXUPVEC bitfield mask;			/* ISECT IS FIXUP SECTION 
            FILL_2 bitfield length 6 fill prefix ISDDEF tag $$;/* UNUSED, RESERVED FOR FUTURE USE 
            VECTOR bitfield mask;			/* VECTOR CONTAINED IN IMAGE SECTION 
            PROTECT bitfield mask;			/* IMAGE SECTION IS PROTECTED 
            FILL_3 bitfield length 5 fill prefix ISDDEF tag $$;/* UNUSED, RESERVED FOR FUTURE USE 
	end FLAGS_BITS;
        constant FLAGSIZ	equals 24  prefix ISD tag $S;/* NUMBER OF FLAG BITS, ISD TYPE EXCLUDED 
	FLAGS_FIELDS structure fill;
            FILL_5 byte dimension 3 fill prefix ISDDEF tag $$;
            TYPE byte unsigned;				/*ISD TYPE CODE 
	end FLAGS_FIELDS;
    end FLAGS_OVERLAY;
    VBN longword unsigned;				/*BASE VIRTUAL BLOCK NUMBER 
    constant LENPRIV equals . prefix ISD$ tag K;	/*LENGTH OF PRIVATE ISD 
    constant LENPRIV equals . prefix ISD$ tag C;	/*LENGTH OF PRIVATE ISD 
    "IDENT" longword unsigned;				/*IDENT FOR GLOBAL SECTION 
    GBLNAM character length 44;				/*GLOBAL NAME COUNTED STRING 
    constant LENGLBL equals .-28 prefix ISD$ tag K;	/*LENGTH OF OLD GLOBAL ISD 
    constant LENGLBL equals .-28 prefix ISD$ tag C;	/*LENGTH OF OLD GLOBAL ISD 
    constant MAXLENGLBL equals . prefix ISD$ tag K;	/*MAX LENGTH OF NEW GLOBAL ISD 
    constant MAXLENGLBL equals . prefix ISD$ tag C;	/*MAX LENGTH OF NEW GLOBAL ISD 
    
    
/*+
/* MATCH CONTROL VIELD VALUES
/*-
    	 						/*BASE OF ZERO , INCR 1 
    constant(
          MATALL					/*MATCH ALWAYS, USE GLOBAL SECTION 
        , MATEQU					/*MATCH IF ISD$L_IDENT EQU GBL ID 
        , MATLEQ					/*MATCH IF ISD$L_IDENT LEQ GBL ID 
        , MATNEV					/*MATCH NEVER, USE PRIVATE COPY 
        ) equals 0 increment 1  prefix ISD tag $K;
    
/*+
/* ISD TYPE FIELD DEFINITIONS
/*-
    
    constant NORMAL	equals 0  prefix ISD tag $K;	/*NORMAL PROGRAM IMAGE SECTION 
                                            		/*NO SPECIAL ACTION REQUIRED
    constant SHRFXD	equals 1  prefix ISD tag $K;	/*SHAREABLE FIXED SECTION 
    constant PRVFXD	equals 2  prefix ISD tag $K;	/*PRIVATE FIXED SECTION 
    constant SHRPIC	equals 3  prefix ISD tag $K;	/*SHAREABLE PIC SECTION 
    constant PRVPIC	equals 4  prefix ISD tag $K;	/*PRIVATE PIC SECTION 
    constant USRSTACK	equals (256-3)  prefix ISD tag $K;/*USER STACK SECTION 
    
end ISDDEF;

end_module $ISDDEF;


module ISDOLDDEF;
/*+
/* OLD IMAGE SECTION DESCRIPTOR DEFINITIONS
/*-

aggregate ISDOLDDEF structure prefix ISD_;
    SIZE word unsigned;					/*SIZE IN BYTES OF THIS ISD 
    PAGCNT word unsigned;				/*! OF PAGES DESCRIBED BY THIS ISD 
    VPNPFC_OVERLAY union;
        VPNPFC longword unsigned;			/*VPN & PFC VIELDS 
	VPNPFC_BITS0 structure;
            VPN bitfield length 21;			/* STARTING VIRTUAL PAGE NUMBER 
            P1 bitfield;				/* P1 SPACE 
            SYSTEM bitfield;				/* SYSTEM SPACE 
            FILL_1 bitfield fill prefix ISDOLDDEF tag __;	/* SPARE 
            PFC bitfield length 8;			/* PAGE FAULT CLUSTER 
	end VPNPFC_BITS0;
	VPNPFC_BITS1 structure;
            VPG bitfield length 23;			/* VIRTUAL PAGE INCLUDING P1 & S 
	end VPNPFC_BITS1;
	VPNPFC_FIELDS2 structure;
            FILL_4 byte dimension 3 fill prefix ISDOLDDEF tag __;
            PFC byte unsigned;				/*PAGE FAULT CLUSTER 
	end VPNPFC_FIELDS2;
    end VPNPFC_OVERLAY;
    FLAGS_OVERLAY union;
        FLAGS longword unsigned;			/*FLAGS AND ISD TYPE 
        constant LENDZRO equals . prefix ISD_ tag K;	/*LENGTH OF DEMAND ZERO ISD 
        constant LENDZRO equals . prefix ISD_ tag C;	/*LENGTH OF DEMAND ZERO ISD 
	FLAGS_BITS structure;
            GBL bitfield mask;				/* GLOBAL 
            CRF bitfield mask;				/* COPY ON REFERENCE 
            DZRO bitfield mask;				/* DEMAND ZERO PAGE 
            WRT bitfield mask;				/* WRITABLE 
            MATCHCTL bitfield mask length 3;		/* IDENT MATCH CONTROL FIELD 
            LASTCLU bitfield mask;			/* ISD IS PART OF LAST P0 SPACE CLUSTER 
            COPYALWAY bitfield mask;			/* COPY ALWAYS FROM USER IMAGE 
            "BASED" bitfield mask;			/* ISECT IS BASED 
            FIXUPVEC bitfield mask;			/* ISECT IS FIXUP SECTION 
            FILL_2 bitfield length 6 fill prefix ISDOLDDEF tag __;/* UNUSED, RESERVED FOR FUTURE USE 
            VECTOR bitfield mask;			/* VECTOR CONTAINED IN IMAGE SECTION 
            PROTECT bitfield mask;			/* IMAGE SECTION IS PROTECTED 
            FILL_3 bitfield length 5 fill prefix ISDOLDDEF tag __;/* UNUSED, RESERVED FOR FUTURE USE 
	end FLAGS_BITS;
        constant FLAGSIZ	equals 24  prefix ISD tag _S;/* NUMBER OF FLAG BITS, ISD TYPE EXCLUDED 
	FLAGS_FIELDS structure;
            FILL_5 byte dimension 3 fill prefix ISDOLDDEF tag __;
            TYPE byte unsigned;				/*ISD TYPE CODE 
	end FLAGS_FIELDS;
    end FLAGS_OVERLAY;
    VBN longword unsigned;				/*BASE VIRTUAL BLOCK NUMBER 
    constant LENPRIV equals . prefix ISD_ tag K;	/*LENGTH OF PRIVATE ISD 
    constant LENPRIV equals . prefix ISD_ tag C;	/*LENGTH OF PRIVATE ISD 
    "IDENT" longword unsigned;				/*IDENT FOR GLOBAL SECTION 
    GBLNAM character length 16;				/*GLOBAL NAME COUNTED STRING 
    constant LENGLBL equals . prefix ISD_ tag K;	/*LENGTH OF GLOBAL ISD 
    constant LENGLBL equals . prefix ISD_ tag C;	/*LENGTH OF GLOBAL ISD 
    
    
/*+
/* MATCH CONTROL VIELD VALUES
/*-
    	 						/*BASE OF ZERO , INCR 1 
    constant(
          MATALL					/*MATCH ALWAYS, USE GLOBAL SECTION 
        , MATEQU					/*MATCH IF ISD_L_IDENT EQU GBL ID 
        , MATLEQ					/*MATCH IF ISD_L_IDENT LEQ GBL ID 
        , MATNEV					/*MATCH NEVER, USE PRIVATE COPY 
        ) equals 0 increment 1  prefix ISD tag _K;
    
/*+
/* ISD TYPE FIELD DEFINITIONS
/*-
    
    constant NORMAL	equals 0  prefix ISD tag _K;	/*NORMAL PROGRAM IMAGE SECTION 
                                            		/*NO SPECIAL ACTION REQUIRED
    constant SHRFXD	equals 1  prefix ISD tag _K;	/*SHAREABLE FIXED SECTION 
    constant PRVFXD	equals 2  prefix ISD tag _K;	/*PRIVATE FIXED SECTION 
    constant SHRPIC	equals 3  prefix ISD tag _K;	/*SHAREABLE PIC SECTION 
    constant PRVPIC	equals 4  prefix ISD tag _K;	/*PRIVATE PIC SECTION 
    constant USRSTACK	equals (256-3)  prefix ISD tag _K;/*USER STACK SECTION 
    
end ISDOLDDEF;

end_module ISDOLDDEF;


module $JIBDEF;
/*+
/* Job Information Block - Structure containing common context for a set
/*                          of related processes.
/*
/* Note: The Executive module SYSCREPRC assumes that the job mount list head
/* preceeds the username field in the JIB.
/*
/*-

aggregate JIBDEF structure prefix JIB$;
    MTLFL longword unsigned;				/* Job mount list head forward link
    MTLBL longword unsigned;				/* Job mount list head back link
    SIZE word unsigned;					/* Size of structure in bytes 
    TYPE byte unsigned;					/* Structure type code 
    DAYTYPES byte unsigned;				/* Set bits 0-6 flag non-prime days of week 
    USERNAME character length 12;			/* User name for easy access 
    ACCOUNT character length 8;				/* Account name for resident access 
    BYTCNT longword unsigned;				/* Buffered I/O byte count avail 
    BYTLM longword unsigned;				/* Original value for Byte count 
    PBYTCNT longword unsigned;				/* Paged pool byte count remaining 
    PBYTLIM longword unsigned;				/* Paged pool byte limit 
    FILCNT word unsigned;				/* Open File count remaining 
    FILLM word unsigned;				/* Open file limit 
    TQCNT word unsigned;				/* Timer queue entry count remaining 
    TQLM word unsigned;					/* Timer queue entry limit 
    PGFLQUOTA longword unsigned;			/* Paging file quota 
    PGFLCNT longword unsigned;				/* Paging file limit 
    CPULIM longword unsigned;				/* CPU time quota remaining 
    PRCCNT word unsigned;				/* Count of subprocesses existing 
    PRCLIM word unsigned;				/* Limit on number of subprocesses 
    SHRFCNT word unsigned;				/* Shared file block count remaing 
    SHRFLIM word unsigned;				/* Shared file count limit 
    ENQCNT word unsigned;				/* Enqueue count avail 
    ENQLM word unsigned;				/* Enqueue limit 
    MAXJOBS word unsigned;				/* Max jobs limit on user
    MAXDETACH word unsigned;				/* Max detached processes for user
    MPID longword unsigned;				/* PID of master process 
    JLNAMFL longword unsigned;				/* Forward link for job-wide logical names 
    JLNAMBL longword unsigned;				/* Back link for job-wide logical names 
    PDAYHOURS longword unsigned;			/* Field describing primary day access 
    ODAYHOURS longword unsigned;			/* Field describing off day access 
    JOBTYPE byte unsigned;				/* Job origin type
	constant (
	  DETACHED
	, NETWORK
	, BATCH
	, LOCAL
	, DIALUP
	, REMOTE
	) equals 0 increment 1 tag C;
    FILL_4 byte dimension 3 fill tag $$;
    ORG_BYTLM longword unsigned;			/* Original BYTLM
    ORG_PBYTLM longword unsigned;			/* Original PBYTLM
    constant "LENGTH" equals . prefix JIB$ tag K;	/* Structure length 
    constant "LENGTH" equals . prefix JIB$ tag C;	/* Structure length 
end JIBDEF;

end_module $JIBDEF;


module $KDZDEF;
/*+
/* KDZ11 Offset Definitions for Registers Accessible Through BI Node Private
/*  Space.  Note that in making these registers available in virtual space,
/*  we have only mapped real registers.  Therefore these virtual offsets are
/*  different than the hardware physical offsets.
/*-

aggregate KDZDEF structure prefix KDZ$;

/*
/* BIIC registers - here we reserve space for the 256 bytes that these
/*		    registers occupy and we also fill out the virtual page to
/*		    512 bytes so that other items appear on page boundaries.
/*		    Being able to address the BIIC via these virtual addresses
/*		    allows a Scorpio CPU to determine its own node number.
/*		    That is, a reference here is via node private space and
/*		    always addresses a nodes own registers via a loop back
/*		    request.
/*

    BIICBASE byte unsigned;				/*BIIC register Base
    FILL_1 byte dimension 511 fill prefix KDZDEF tag $$;/* Fill out to page.

/*
/* Port Control CSR register
/*

    PCNTL_OVERLAY union fill;
	PCNTL longword unsigned;			/*Port Control CSR Register
	PCNTL_BITS structure fill;			/* Port Controller CSR
            PCNTL_RSTRT  bitfield  mask;		/* (RO) Front Panel Switch
							/*  selecting RSTRT/HALT
            PCNTL_PHYLOG bitfield  mask;		/* (RO) Backplane Bit
							/*  selecting PHYS/LOG Console
            PCNTL_SECENB bitfield  mask;		/* (RO) Front Panel Switch
							/*  to lock out console input
            PCNTL_STINIT bitfield  mask;		/* Self-Test INIT.
            PCNTL_STFAST bitfield  mask;		/* (RO) Backplane bit to
							/*  select Fast Self-Test.
            PCNTL_ENBAPT bitfield  mask;		/* Enable APT.
            PCNTL_STPASS bitfield  mask;		/* Self-Test Pass.
            PCNTL_RUN    bitfield  mask;		/* 1=>Program mode,0=>Console
            FILL_2 bitfield fill prefix KDZ tag $$;	/* 
            PCNTL_CLREVL bitfield  mask;		/* Clear Event Lock
            PCNTL_WRMEM  bitfield  mask;		/* Write Memory Bit
            PCNTL_EV4    bitfield  mask;		/* Event Bits - These
            PCNTL_EV3    bitfield  mask;		/*  RO bits are event
            PCNTL_EV2    bitfield  mask;		/*  codes from BIIC to
            PCNTL_EV1    bitfield  mask;		/*  allow CPU to monitor
            PCNTL_EV0    bitfield  mask;		/*  BI status
            PCNTL_WWPO   bitfield  mask;		/* Write Wrong Parity Odd
            FILL_3 bitfield length 2 fill prefix KDZ tag $$;/*
            PCNTL_RXDIS  bitfield  mask;		/* Disable RX50
            PCNTL_NIDIS  bitfield  mask;		/* Disable NI Lance
            PCNTL_CNSLIE bitfield  mask;		/* Console Interrupt Enable
            PCNTL_CNSLCL bitfield  mask;		/* Clear Console Interrupt
            PCNTL_CNSLIN bitfield  mask;		/* Console Interrupt RCVD
            PCNTL_WWPE   bitfield  mask;		/* Write Wrong Parity Even
            PCNTL_RXDONE bitfield  mask;		/* RX Done Interrupt
            PCNTL_RXSTAT bitfield  mask;		/* RX Status Interrupt
            PCNTL_CLRIPI bitfield  mask;		/* Clear IP Interrupt
            PCNTL_IPINTR bitfield  mask;		/* IP Interrupt RCVD
            PCNTL_CRDIE  bitfield  mask;		/* CRD Interrupt Enable
            PCNTL_CLRCRD bitfield  mask;		/* Clear CRD Interrupt
            PCNTL_CRDINT bitfield  mask;		/* CRD Interrupt RCVD
	end PCNTL_BITS;

    end PCNTL_OVERLAY;

    FILL_4 byte dimension 508 fill prefix KDZDEF tag $$;/* Fill out page

/*
/* NI Packet Buffer
/*

    NIBUF byte unsigned;				  /*NI Packet Buffer Base
    FILL_5 byte dimension 32767 fill prefix KDZDEF tag $$;/* Fill out to 32KB

/*
/* EEPROM
/*

    EEPROM byte unsigned;				 /*EEPROM Base
    FILL_6 byte dimension 8191 fill prefix KDZDEF tag $$;/* Fill out to 8KB

/*
/* NI Data Register
/*

    NIDATA longword unsigned;				/* NI Data Register
    FILL_7 byte dimension 508 fill prefix KDZDEF tag $$;/* Fill out page

/*
/* NI Address Register
/*

    NIADDR longword unsigned;				/* NI Address Register
    FILL_8 byte dimension 508 fill prefix KDZDEF tag $$;/* Fill out page

/*
/* RCX50 Registers
/*

    RCX50 byte unsigned;				/* RCX50 Registers
    FILL_9 byte dimension 511 fill prefix KDZDEF tag $$;/* Fill out page

/*
/* Watch Chip Registers
/*

    WATCH byte unsigned;				 /* Watch Chip Registers
    FILL_10 byte dimension 511 fill prefix KDZDEF tag $$;/* Fill out page

end KDZDEF;

end_module $KDZDEF;

module $KFDDEF;
/*
/* KNOWN FILE DEVICE AND DIRECTORY BLOCK DEFINITIONS
/*


aggregate KFDDEF structure prefix KFD$;
    LINK longword unsigned;				/* Device, Directory, Extension (KFD) list link
    KFELIST longword unsigned;				/* Ordered Known file entry list header
    SIZE word unsigned;					/* Size of block 
    TYPE byte unsigned;					/* Structure type 
    SPARE byte unsigned;				/* spare
    REFCNT word unsigned;				/* Number of KFE's with same KFD
    DEVLEN byte unsigned;				/* Length of Device string
    DIRLEN byte unsigned;				/* Length of Directory string
    DDTSTRLEN byte unsigned;				/* Length of Device, Directory, Type (DDT) string
    constant "LENGTH" equals . prefix KFD$ tag C;	/* Length of fixed area of kfd entry 
    DDTSTR character length 0;				/* Offset to DDT string

end KFDDEF;

end_module $KFDDEF;

module $KFEDEF;
/*
/* KNOWN FILE ENTRY DEFINITIONS
/*


aggregate KFEDEF structure prefix KFE$;
    HSHLNK longword unsigned;				/* Known file Hash table link 
    KFELINK longword unsigned;				/* Ordered Known file entry list link
    SIZE word unsigned;					/* Size of block 
    TYPE byte unsigned;					/* Structure type 
    HSHIDX byte unsigned;				/* KFE hash table index (index into vector of HSHQ's) 
    KFD longword unsigned;				/* Device, Directory, Type block
    FLAGS_OVERLAY union;
        FLAGS word unsigned;				/* Flags word 
	FLAGS_BITS structure;
            PROTECT bitfield mask;			/* Known file was installed protected 
            LIM bitfield mask;				/* Linkable image 
            PROCPRIV bitfield mask;			/* Use process privilege mask 
	    OPEN bitfield mask;				/* Image installed /OPEN
            HDRRES bitfield mask;			/* Image header block is resident 
            SHARED bitfield mask;			/* Image is shared 
            SHMIDENT bitfield mask;			/* Shared memory ident already set 
            COMPATMOD bitfield mask;			/* Image is compatability mode 
	    NOPURGE bitfield mask;			/* Image entry may not be purged
	    ACCOUNT bitfield mask;			/* Image level accounting
	    WRITEABLE bitfield mask;			/* Global sections are writeable
	    EXEONLY bitfield mask;			/* Image has only execute access allowed
	end FLAGS_BITS;
    end FLAGS_OVERLAY;
    GBLSECCNT word unsigned;				/* Global section count if shared 
    USECNT longword unsigned;				/* Usage counter 
    WINDOW_OVERLAY union;
        WCB longword unsigned;				/* WCB address if open 
	WINDOW_FIELDS structure;
	    FID_OVERLAY union;
                FID word unsigned;			/* File id 
                FID_NUM word unsigned;			/* File number field of file id 
	    end FID_OVERLAY;
            FID_SEQ word unsigned;			/* File sequence number field of file id 
	end WINDOW_FIELDS;
    end WINDOW_OVERLAY;
    IMGHDR_OVERLAY union;
        IMGHDR longword unsigned;			/* Image header address if resident 
        FID_RVN word unsigned;				/* Relative volume number field of file id 
    end IMGHDR_OVERLAY;
    PROCPRIV quadword unsigned;				/* Process privilege mask 
    MATCHCTL byte unsigned;				/* Global section match control 
    FILL_4 byte fill prefix KFEDEF tag $$;		/* spare byte 
    AMECOD word unsigned;				/* Image header code specifying AME 
    "IDENT" longword unsigned;				/* Global section ident value 
    ORB longword unsigned;				/* Address of Object Rights Block
    SHRCNT word unsigned;				/* High water mark for sharing
    FILNAMLEN byte unsigned;				/* Length of file name
    constant "LENGTH" equals . prefix KFE$ tag K;	/* Length of fixed area of KFE entry 
    constant "LENGTH" equals . prefix KFE$ tag C;	/* Length of fixed area of KFE entry 
    constant MAXLEN equals .+39 prefix KFE$ tag K;	/* Max KFE length (includes max filename)
    constant MAXLEN equals .+39 prefix KFE$ tag C;	/* Max KFE length (includes max filename)
    FILNAM character length 0;				/* Offset to file name
    
end KFEDEF;

end_module $KFEDEF;


module $KFHDEF;
/*
/* KNOWN FILE IMAGE HEADER DEFINITIONS	*** obsolete, to be removed ***
/*



aggregate KFHDEF structure prefix KFH$;
    BUFEND longword unsigned;				/*ADDRESS OF END OF KNOWN FILE HEADER 
    KFIADR longword unsigned;				/*ADDRESS OF ASSOCIATED KNOWN FILE ENTRY 
    SIZE word unsigned;					/*SIZE OF DYNAMIC STRUCTURE 
    TYPE byte unsigned;					/*DYNAMIC STRUCTURE TYPE 
    FILL_1 byte fill prefix KFHDEF tag $$;		/*SPARE BYTE 
    constant "LENGTH" equals . prefix KFH$ tag K;	/*LENGTH OF OVERHEAD AREA 
    constant "LENGTH" equals . prefix KFH$ tag C;	/*LENGTH OF OVERHEAD AREA 
    
/*
/* THE REMAINDER OF THIS STRUCTURE CONTAINS THE IMAGE HEADER OF THE
/* SPECIFIED KNOWN FILE.  THE LOCATION KFI$L_IMGHDR IN THE KNOWN FILE
/* ENTRY POINTS KFH$C_LENGTH INTO THIS STRUCTURE, I.E AT THE IMAGE HEADER
/* ITSELF.
/*
end KFHDEF;

end_module $KFHDEF;


module $KFIDEF;
/*
/* KNOWN FILE ENTRY DEFINITIONS 	*** obsolete, to be removed ***
/*


aggregate KFIDEF structure prefix KFI$;
    KFIQFL longword unsigned;				/*KNOWN FILE QUEUE FORWARD LINK 
    KFIQBL longword unsigned;				/*KNOWN FILE QUEUE BACK LINK 
    SIZE word unsigned;					/*SIZE OF BLOCK 
    TYPE byte unsigned;					/*STRUCTURE TYPE 
    KFICTL_OVERLAY union fill;
        KFICTL byte unsigned;				/*CONTROL BITS 
	KFICTL_BITS structure fill;
            KFIHD bitfield mask;			/*KNOWN FILE HEADER BLOCK 
            FILIDOPEN bitfield mask;			/*OPEN BY FILE ID IF SET 
            DONOTOPEN bitfield mask;			/*DO NOT OPEN THE FILE IF SET 
            FILL_1 bitfield length 3 fill prefix KFIDEF tag $$;/*SPARE 
            NOREPLACE bitfield mask;			/*DELETE AND DO NOT REPLACE ENTRY 
            MARKDEL bitfield mask;			/*ENTRY IS TO BE DELETED 
	end KFICTL_BITS;
    end KFICTL_OVERLAY;
    DEVUCB_OVERLAY union fill;
        DEVUCB byte unsigned;				/*DEVICE UCB OFFSET 
        DEVNAM byte unsigned;				/*NAME THE ABOVE CONSISTENTLY 
    end DEVUCB_OVERLAY;
    DIRNAM byte unsigned;				/*DIRECTORY NAME STRING OFFSET 
    FILNAM byte unsigned;				/*FILE NAME STRING OFFSET 
    TYPNAM byte unsigned;				/*FILE TYPE STRING OFFSET 
    REFCNT word unsigned;				/*REFERENCE COUNT 
    KFIQNUM byte unsigned;				/*KFIQ NUMBER (INDEX INTO VECTOR OF KFIQ'S) 
    KFISEQ_OVERLAY union fill;
        KFISEQ byte unsigned;				/*KNOWN FILE ENTRY SEQUENCE NUMBER 
        constant KFIHDLEN equals . prefix KFI$ tag K;	/*LENGTH OF KFI HEADER FIXED PORTION 
        constant KFIHDLEN equals . prefix KFI$ tag C;	/*LENGTH OF KFI HEADER FIXED PORTION 
	KFISEQ_BITS structure fill;
            KFISEQ bitfield mask length 2;		/*SEQUENCE NUMBER FIELD 
	end KFISEQ_BITS;
    end KFISEQ_OVERLAY;
    FLAGS_OVERLAY union fill;
        FLAGS word unsigned;				/*FLAGS WORD 
	FLAGS_BITS structure fill;
            KP_OPEN bitfield mask;			/*KEEP THE IMAGE FILE OPEN 
            KP_RESHDR bitfield mask;			/*MAKE IMAGE HEADER RESIDENT 
            KP_SHARED bitfield mask;			/*MAKE IMAGE SHARED 
            PROTECT bitfield mask;			/*KNOWN FILE WAS INSTALLED PROTECTED 
            FILL_2 bitfield length 2 fill prefix KFIDEF tag $$;/*SPARE BITS 
            LIM bitfield mask;				/*LINKABLE IMAGE 
            PROCPRIV bitfield mask;			/*USE PROCESS PRIVILEGE MASK 
            IS_RESHDR bitfield mask;			/*IMAGE HEADER BLOCK IS RESIDENT 
            IS_SHARED bitfield mask;			/*IMAGE IS SHARED 
            FILL_3 bitfield length 4 fill prefix KFIDEF tag $$;/*SPARE BITS 
            SHMIDENT bitfield mask;			/*SHARED MEMORY IDENT ALREADY SET 
            COMPATMOD bitfield mask;			/*IMAGE IS COMPATABILITY MODE 
	end FLAGS_BITS;
    end FLAGS_OVERLAY;
    GBLSECCNT word unsigned;				/*GLOBAL SECTION COUNT IF SHARED 
    USECNT longword unsigned;				/*USAGE COUNTER 
    WINDOW_OVERLAY union fill;
        WINDOW longword unsigned;			/*WCB ADDRESS IF OPEN 
	WINDOW_FIELDS structure fill;
	    FID_OVERLAY union fill;
                FID word unsigned;			/*FILE ID 
                FID_NUM word unsigned;			/*FILE NUMBER FIELD OF FILE ID 
	    end FID_OVERLAY;
            FID_SEQ word unsigned;			/*FILE SEQUENCE NUMBER FIELD OF FILE ID 
	end WINDOW_FIELDS;
    end WINDOW_OVERLAY;
    IMGHDR_OVERLAY union fill;
        IMGHDR longword unsigned;			/*IMAGE HEADER ADDRESS IF RESIDENT 
        FID_RVN word unsigned;				/*RELATIVE VOLUME NUMBER FIELD OF FILE ID 
    end IMGHDR_OVERLAY;
    PROCPRIV quadword unsigned;				/*PROCESS PRIVILEGE MASK 
    MATCHCTL byte unsigned;				/*GLOBAL SECTION MATCH CONTROL 
    FILL_4 byte fill prefix KFIDEF tag $$;		/*SPARE BYTE 
    AMECOD word unsigned;				/*IMAGE HEADER CODE SPECIFYING AME 
    "IDENT" longword unsigned;				/*GLOBAL SECTION IDENT VALUE 
    constant "LENGTH" equals . prefix KFI$ tag K;	/*LENGTH OF FIXED AREA OF KFI ENTRY 
    constant "LENGTH" equals . prefix KFI$ tag C;	/*LENGTH OF FIXED AREA OF KFI ENTRY 
    
end KFIDEF;

end_module $KFIDEF;


module $KFPDEF;
/*
/* KNOWN FILE POINTER BLOCK DEFINITIONS 	*** obsolete, to be removed ***
/*


aggregate KFPDEF structure prefix KFP$;
    QUECOUNT byte unsigned;				/*INDEX OF LAST KNOWN FILE LIST IN USE 
    FILL_1 byte fill prefix KFPDEF tag $$;		/*SPARE BYTE 
    FILL_2 word fill prefix KFPDEF tag $$;		/*SPARE WORD 
    FILL_3 longword fill prefix KFPDEF tag $$;		/*SPARE LONG WORD 
    SIZE word unsigned;					/*SIZE OF POINTER BLOCK IN BYTES 
    TYPE byte unsigned;					/*POINTER BLOCK TYPE 
    TYPE1 byte unsigned;				/*TYPE OF STRUCTURE POINTED TO 
    QUE0 longword unsigned;				/*POINTER TO KNOWN FILE QUEUE 0 
    
end KFPDEF;

end_module $KFPDEF;


module $KFPBDEF;
/*
/* KNOWN FILE POINTER BLOCK DEFINITIONS
/*


aggregate KFPBDEF structure prefix KFPB$;
    KFDLST longword unsigned;				/* Device, Directory, Extension (KFD) list link
    KFEHSHTAB longword unsigned;			/* Address of Known file name hash table
    SIZE word unsigned;					/* Size of pointer block in bytes 
    TYPE byte unsigned;					/* Pointer block type 
    SPARE byte unsigned;				/* spare byte
    KFDLSTCNT word unsigned;				/* Number of entries in KFD list
    HSHTABLEN word unsigned;				/* Length of Hash table
    constant "LENGTH" equals . prefix KFPB$ tag K;	/* Length of pointer block
    constant "LENGTH" equals . prefix KFPB$ tag C;	/* Length of pointer block
    
end KFPBDEF;

end_module $KFPBDEF;


module $KFRHDEF;
/*
/* KNOWN FILE RESIDENT IMAGE HEADER DEFINITIONS
/*



aggregate KFRHDEF structure prefix KFRH$;
    BUFEND longword unsigned;				/* Address of end of known file header 
    ALIAS word unsigned;				/* Use secondary name on activation
    FILL_1 word fill prefix KFRHDEF tag $$;		/* SPARE BYTE 
    SIZE word unsigned;					/* Size of dynamic structure 
    TYPE byte unsigned;					/* Dynamic structure type 
    HDRVER byte unsigned;				/* Image header version
    constant "LENGTH" equals . prefix KFRH$ tag K;	/* Length of overhead area 
    constant "LENGTH" equals . prefix KFRH$ tag C;	/* Length of overhead area 
    IHD character length 0;				/* Offset to decoded Image Header
    
/*
/* THE REMAINDER OF THIS STRUCTURE CONTAINS THE IMAGE HEADER OF THE
/* SPECIFIED KNOWN FILE.  THE LOCATION KFE$L_IMGHDR IN THE KNOWN FILE
/* ENTRY POINTS KFRH$C_LENGTH INTO THIS STRUCTURE, I.E AT THE IMAGE HEADER
/* ITSELF.
/*
end KFRHDEF;

end_module $KFRHDEF;


module $LKBDEF;
/*+
/* LKB - LOCK BLOCK
/*
/* LOCK BLOCKS ARE USED TO REPRESENT LOCK REQUESTS (ONE BLOCK FOR EACH
/* REQUEST).  LOCK BLOCKS HAVE AN ENTRY IN THE LOCK ID TABLE POINTING
/* TO THEM AND ARE LINKED ONTO ONE OF THREE QUEUES IN A RESOURCE BLOCK (RSB)
/*-



aggregate LKBDEF structure prefix LKB$;
    ASTQFL longword unsigned;			/*AST QUEUE FORWARD LINK 
    ASTQBL longword unsigned;			/*AST QUEUE BACKWARD LINK 
    SIZE word unsigned;				/*SIZE OF LKB IN BYTES 
    TYPE byte unsigned;				/*STRUCTURE TYPE 
        RMOD structure byte unsigned;		/*ACCESS MODE OF REQUEST 
            MODE bitfield length 2;		/* MODE SUBFIELD 
            FILL_1 bitfield length 2 fill prefix LKBDEF tag $$;/* SPARE 
            PKAST bitfield mask;		/* PIGGY BACK SPECIAL KERNEL AST 
            NODELETE bitfield mask;		/* DON'T DELETE ACB ON DELIVERY 
            QUOTA bitfield mask;		/* ACCOUNT FOR QUOTA 
            KAST bitfield mask;			/* SPECIAL KERNEL AST 
	end RMOD;
    PID longword unsigned;			/*PROCESS ID OF REQUESTING PROCESS 
    AST_OVERLAY union fill;
	AST longword unsigned;			/*ADDRESS OF AST ROUTINE 
	RQSEQNM word unsigned;			/*REQUEST SEQ. NUMBER 
    end AST_OVERLAY;
    ASTPRM_OVERLAY union fill;
	ASTPRM longword unsigned;		/*AST PARAMETER 
	EPID longword unsigned;			/*EPID (MASTER COPIES ONLY)
    end ASTPRM_OVERLAY;
    KAST_OVERLAY union fill;
        KAST longword unsigned;			/*SPECIAL KERNEL AST ADDRESS 
        DUETIME longword unsigned;		/*DUETIME FOR WAITING LOCKS 
    end KAST_OVERLAY;
    CPLASTADR longword unsigned;		/*ADDRESS OF COMPLETION AST ROUTINE 
    BLKASTADR longword unsigned;		/*ADDRESS OF BLOCKING AST ROUTINE 
    LKSB_OVERLAY union fill;
	LKSB longword unsigned;			/*ADDRESS OF LOCK STATUS BLOCK 
	DLCKPRI longword unsigned;		/*DEADLOCK PRIORITY (MASTER COPIES)
    end LKSB_OVERLAY;
    FLAGS word unsigned;			/*USER SPECIFIED FLAGS 
        STATUS structure word unsigned;		/*INTERNAL STATUS 
            DCPLAST bitfield mask;		/* DELIVER COMPLETION AST 
            DBLKAST bitfield mask;		/* DELIVER BLOCKING AST 
            ASYNC bitfield mask;		/* REQUEST COMPLETED ASYNCHRONOUSLY 
            BLKASTQED bitfield mask;		/* BLOCKING AST HAS BEEN QUEUED 
	    MSTCPY bitfield mask;		/* LKB IS A MASTER COPY
	    NOQUOTA bitfield mask;		/* DON'T CHARGE QUOTA
            TIMOUTQ bitfield mask;		/* LKB IS ON TIMEOUT QUEUE 
	    WASSYSOWN bitfield mask;		/* WAS SYSTEM OWNED LOCK
	    CVTTOSYS bitfield mask;		/* CVT BACK TO SYS. OWNED
	    PROTECT bitfield mask;		/* PROTECTED LOCK
	    RESEND bitfield mask;		/* RESEND DURING FAILOVER
	end STATUS;
    LKST1 longword unsigned;			/*FIRST LOCK STATUS LONGWORD 
    LKST2_OVERLAY union fill;
        LKST2 longword unsigned;		/*SECOND LOCK STATUS LONGWORD 
        constant ACBLEN equals . prefix LKB$ tag K;	/*LENGTH OF ACB PORTION OF LKB 
        constant ACBLEN equals . prefix LKB$ tag C;	/*LENGTH OF ACB PORTION OF LKB 
        LKID longword unsigned;			/*LOCK ID 
    end LKST2_OVERLAY;
    RQMODE byte unsigned;			/*REQUEST MODE 
    GRMODE byte unsigned;			/*GRANTED MODE 
    STATE byte unsigned;			/*LOCK STATE 
    constant (					/*LOCK STATE VALUES
		GRANTED,			/* GRANTED
		CONVERT,			/* CONVERSION
		WAITING,			/* WAITING
		RETRY,				/* RETRY REQUEST
		SCSWAIT,			/* SCS WAIT
		RSPNOTQED,			/* RESPONSE NOT QUEUED
		RSPQUEUED,			/* RESPONSE QUEUED
		RSPGRANTD,			/* RESPONSE GRANTED
		RSPDOLOCL,			/* RESPONSE DO LOCALLY
		RSPRESEND			/* RESPONSE RESEND
	     ) equals 1 increment -1;
    EFN byte unsigned;				/*EVENT FLAG NUMBER 
    SQFL longword unsigned;			/*STATE QUEUE FORWARD LINK 
    SQBL longword unsigned;			/*STATE QUEUE BACKWARD LINK 
    OWNQFL longword unsigned;			/*OWNER QUEUE FORWARD LINK 
    OWNQBL longword unsigned;			/*OWNER QUEUE BACKWARD LINK 
    PARENT longword unsigned;			/*ADDRESS OF PARENT LKB 
    REFCNT word unsigned;			/*SUB LKB REFERENCE COUNT 
    TSLT byte unsigned;				/*TIMESTAMP LIFETIME
    FILL_2 byte fill;				/*SPARE
    RSB longword unsigned;			/*ADDRESS OF OWNER RSB 
    REMLKID longword unsigned;			/*REMOTE LOCK ID
    CSID_OVERLAY union fill;
	CSID longword unsigned;			/*CLUSTER SYSTEM ID (MASTER ONLY)
	OLDASTPRM longword unsigned;		/*OLD AST PARAMETER
    end CSID_OVERLAY;
    OLDBLKAST longword unsigned;		/*OLD BLOCKING AST ADDR,
    constant "LENGTH" equals . prefix LKB$ tag K;	/*LENGTH OF LKB 
    constant "LENGTH" equals . prefix LKB$ tag C;	/*LENGTH OF LKB 
end LKBDEF;

end_module $LKBDEF;

module $LOGDEF;
/*+
/* LOG - LOGICAL NAME BLOCK
/*
/* THERE IS ONE LOGICAL NAME BLOCK FOR EACH LOGICAL NAME ASSIGNMENT IN A
/* SYSTEM. LOGICAL NAME BLOCKS CAN BE LINKED INTO ONE OF THREE TABLES:
/*        1. A PER PROCESS TABLE.
/*        2. A GROUP WIDE TABLE.
/*        3. THE SYSTEM WIDE TABLE.
/*-



aggregate LOGDEF structure prefix LOG$;
    LTFL longword unsigned;				/*LOGICAL TABLE FORWARD LINK 
    LTBL longword unsigned;				/*LOGICAL TABLE BACKWARD LINK 
    SIZE word unsigned;					/*SIZE OF LOG IN BYTES 
    TYPE byte unsigned;					/*STRUCTURE TYPE FOR LOG 
    TABLE byte unsigned;				/*LOGICAL NAME TABLE TYPE 
    GROUP word unsigned;				/*CREATOR GROUP NUMBER 
    AMOD byte unsigned;					/*ACCESS MODE OF CREATOR 
    FILL_1 byte fill prefix LOGDEF tag $$;		/*SPARE BYTE 
    MBXUCB_OVERLAY union fill;
        MBXUCB longword unsigned;			/*MAILBOX UCB ADDRESS 
        constant "LENGTH" equals . prefix LOG$ tag K;	/*LENGTH OF FIXED PART OF LOG 
        constant "LENGTH" equals . prefix LOG$ tag C;	/*LENGTH OF FIXED PART OF LOG 
	MBXUCB_FIELDS structure fill;
            FILL_2 byte dimension 4 fill prefix LOGDEF tag $$;
            NAME character length 0 tag T;		/*START OF LOGICAL NAME 
            
/*
/* LOGICAL NAME TABLE NUMBERS
/*
            
            constant SYSTEM	equals 0  prefix LOG tag $C;/*SYSTEM NAME TABLE 
            constant GROUP	equals 1  prefix LOG tag $C;/*GROUP NAME TABLE 
            constant PROCESS	equals 2  prefix LOG tag $C;/*PROCESS NAME TABLE 
            
/*
/* MAXIMUM LENGTH OF LOGICAL NAME STRING
/*
            
            constant NAMLENGTH	equals 64  prefix LOG tag $C;/*MAXIMUM LENGTH OF LOGICAL NAME STRING 
            
	end MBXUCB_FIELDS;
    end MBXUCB_OVERLAY;
end LOGDEF;

end_module $LOGDEF;

module $LNMSTRDEF;
{+
{ LNMB - LOGICAL NAME BLOCK
{
{ There is one logical name block per logical name that is defined.
{ These block are chained from the hash table ($LNMHSH).
{ Each translation is a sub-block of this structure.
{-

aggregate LNMBDEF structure prefix LNMB$;
    FLINK longword unsigned;				/* Forward link in list
    BLINK longword unsigned;				/* Backward link in list
    SIZE word unsigned;					/* Size of LNMB in bytes
    TYPE byte unsigned;					/* Structure type for LNMB
    ACMODE byte unsigned;				/* Owner access mode / integrity level byte
    TABLE longword unsigned;				/* Logical name table header address
    FLAG_BITS union;
	FLAGS byte unsigned;				/* Name attributes
	BITS structure;
	    NO_ALIAS bitfield mask;			/* Do not allow outer mode alias
	    CONFINE bitfield mask;			/* Do not copy into subprocess
	    CRELOG bitfield mask;			/* Created with old $CRELOG service
	    TABLE bitfield mask;			/* This is a table name
	    NODELETE bitfield mask;			/* Do not allow this table to be deleted
	    end BITS;
	end FLAG_BITS;
    NAME character length 1;				/* Name string (counted)
							/* Translation blocks begin immediately
							/* following name
end LNMBDEF;


{+
{ LNMC - LOGICAL NAME TABLE NAME CACHE BLOCK
{
{ There are some logical name table name cache blocks per process.
{ These block are doubly-linked from a P1 space cell (CTL$GQ_LNMTBLCACHE).
{-

aggregate LNMCDEF structure prefix LNMC$;
    FLINK longword unsigned;				/* Forward link in list
    BLINK longword unsigned;				/* Backward link in list
    SIZE word unsigned;					/* Size of LNMC in bytes
    TYPE byte unsigned;					/* Structure type for LNMC
    CACHEINDX byte unsigned;				/* Current entry number
    TBLADDR longword unsigned;				/* Logical name table name address
    PROCDIRSEQ longword unsigned;			/* Process directory sequence number
    SYSDIRSEQ longword unsigned;			/* System directory sequence number

    constant NUM_ENTRIES equals 26;			/* Number of table header entries.

    ENTRY longword dimension LNMC$K_NUM_ENTRIES;  	/* Logical name table header addresses

constant LENGTH equals . prefix LNMC$ tag K;		/* Length of header

end LNMCDEF;


{+
{ LNMX - LOGICAL NAME TRANSLATION BLOCK
{
{ There is one logical name translation block per logical name translation.
{ These blocks are sub-blocks of the logical name block ($LNMB).
{-

aggregate LNMXDEF structure prefix LNMX$;
    FLAG_BITS union;
	FLAGS byte unsigned;				/* Translation attributes
	BITS structure;
	    CONCEALED bitfield mask;			/* Do not display result of translation
	    TERMINAL bitfield mask;			/* Do not retranslate result of translation
	    XEND bitfield mask;				/* End of translations flag
	    end BITS;
	end FLAG_BITS;
    INDEX byte;						/* Translation index
    constant (
	"HSHFCN",					/* Hash function value
	"BACKPTR",					/* Backpointer translation
	"TABLE"						/* Logical name table header
	) equals -128 increment 1 prefix LNMX$ tag C;
    HASH word;						/* Hash code for logical names in directories
    XLATION character length 1;				/* Translation string (counted)
							/* The next translation block
							/* begins immediately following
							/* this translation string
end LNMXDEF;


{+
{ LNMTH - LOGICAL NAME TABLE HEADER BLOCK
{
{ There is one logical name table header block for each logical name table.
{ A logical name table header is a specially flagged translation.
{-

aggregate LNMTHDEF structure prefix LNMTH$;
    FLAG_BITS union;
	FLAGS byte unsigned;				/* Logical name table flags
	BITS structure;
	    SHAREABLE bitfield mask;			/* Logical name table is shareable (S0 space)
	    DIRECTORY bitfield mask;			/* Logical name table is a directory table
	    GROUP bitfield mask;			/* Logical name table is a group logical name table
	    SYSTEM bitfield mask;			/* Logical name table is the system logical name table
	    end BITS;
	end FLAG_BITS;
    HASH longword unsigned;				/* Address of hash table
    ORB longword unsigned;				/* Address of Object Rights Block
    NAME longword unsigned;				/* Address of containing LNMB block
    PARENT longword unsigned;				/* Address of parent table
    CHILD longword unsigned;				/* Address of a child table
    SIBLING longword unsigned;				/* Address of a sibling table
    QTABLE longword unsigned;				/* Address of table holding quota
    BYTESLM longword;					/* Initial quota
    BYTES longword;					/* Remaining quota
constant LENGTH equals . prefix LNMTH$ tag K;		/* Length of header
end LNMTHDEF;


{+
{ LNMHSH - LOGICAL NAME HASH TABLE BLOCK
{
{ There is one logical name hash table block for system space and
{ another for each process.
{-

aggregate LNMHSHDEF structure prefix LNMHSH$;
    MASK longword unsigned;				/* Mask for hash value
    FILL_1 longword fill;				/* Spare longword
    SIZE word unsigned;					/* Size of LNMHSH in bytes
    TYPE byte unsigned;					/* Structure type for LNMHSH
    FILL_2 byte fill;					/* Spare byte
    constant "BUCKET" equals . prefix LNMHSH$ tag C;	/* Length of fixed part of LNMHSH
    constant "BUCKET" equals . prefix LNMHSH$ tag K;	/* Length of fixed part of LNMHSH
end LNMHSHDEF;

end_module $LNMSTRDEF;
{
{ Version:	'V04-000'
{
{****************************************************************************
{*									    *
{*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
{*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
{*  ALL RIGHTS RESERVED.						    *
{* 									    *
{*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
{*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
{*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
{*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
{*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
{*  TRANSFERRED.							    *
{* 									    *
{*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
{*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
{*  CORPORATION.							    *
{* 									    *
{*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
{*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
{* 									    *
{*									    *
{****************************************************************************

{++
{
{ FACILITY:  VAX/VMS System Macro Libraries
{
{ ABSTRACT:
{
{        This file contains the SDL soucre for all operating system control
{        blocks, from M to P.  That is, all control blocks from MAA to PZZ.
{
{ ENVIRONMENT:
{
{        n/a
{
{--
{
{
{ AUTHOR:  The VMS Group         CREATION DATE:  1-Aug-1976
{
{ MODIFIED BY:
{
{	V03-101	LJK0288		Lawrence J. Kenah	9-Aug-1984
{		Add AUTHPRI cell to PCB that duplicates existing PHD field.
{
{	V03-100	ACG0440		Andrew C. Goldstein,	23-Jul-1984  11:26
{		Add ref count and classification valid flag to ORB
{
{	V03-099	ROW0397		Ralph O. Weber		21-JUL-1984
{		Add definition for "position lost" MSCP end flag
{
{	V03-098	ROW0374		Ralph O. Weber		19-JUL-1984
{		Add an entry to the MVMSL at a negative offset from the MVMSL 
{		base which gives the maximum MVMSL index value, MVMSL$B_MAXIDX.
{		Add the following MSCP controller error subcodes; 
{		MSCP$K_SC_EDCER, MSCP$K_SC_DTSTR, and MSCP$K_SC_REMRSRC.  Add 
{		symbol definitions for the three kind of shadow copy operation;
{		MSCP$K_CS_NOCPY, MSCP$K_CS_COPY, and MSCP$K_CS_MGCPY.  Add a 
{		no members subcode for MSCP available, MSCP$K_SC_NOMEMB.  Add 
{		definitions related to bad block replacement error logging.
{
{	V03-097	RLRBINDT1	Robert L. Rappaport	12-Jul-1984
{		Add more BI devices to $NDTDEF.
{
{	V03-096	LMP0271		L. Mark Pilant,		29-Jun-1984  13:03
{		Add ORB$V_NOACL to indicate that the object can not
{		have an ACL.
{
{	V03-095	WMC0095		Wayne Cardoza		02-May-1984
{		Add PHD$M_NO_WS_CHNG
{
{	V03-094	NPK3051		N. Kronenberg		17-Apr-1984
{		Add MSCP$K_EMD_EMUL to $MSCPDEF.
{
{	V03-093	GRR3093		Gregory R. Robert	11-Apr-1984
{		Added $PSMDEF (previously part of $SMBDEF)
{
{	V03-092	ACG0415		Andrew C. Goldstein,	11-Apr-1984  15:18
{		Update $NSAARGDEF for last set of audit changes
{
{	V03-091	RLRPDTADP	Robert L. Rappaport	10-Apr-1984
{		Add PDT$L_ADP to common $PDTDEF.
{
{	V03-090	SSA0024		Stan Amway		10-Apr-1984
{		Add PIB$B_SRQ_ACCESS and PIB$W_SRQ_ACON to module $PIBDEF.
{
{	V03-089	ROW0341		Ralph O. Weber		 9-APR-1984
{		Correct equated value for MSCP$K_CL_D144, an MSCP controller 
{		or unit identifier class.  Add MVMSL$M_SUPRESS, a flag to 
{		indicate that a given mount verification message can be 
{		suppressed.
{
{	V03-088	WHM0002		Bill Matthews		09-Apr-1984
{		Added additional size constants in $PRMDEF to support
{		long ascii sysgen parameters.
{
{	V03-087	LMP0221		L. Mark Pilant,		9-Apr-1984  12:16
{		Add additional subfields to the ORB definition.
{
{	V03-086	MHB0132		Mark Bramhall		 9-Apr-1984
{		Add SPAWN_CLI and SPAWN_TABLE to $PQBDEF.
{
{ 	V03-085	NPK3048		N. Kronenberg		 5-Apr-1984
{		Add protocol level and vc failure reason to $PBDEF.
{
{	V03-084	KPL0001		Peter Lieberwirth	22-Mar-1984
{		Add $NBIADEF.
{
{	V03-083	NPK3047		N. Kronenberg		22-Mar-1984
{		Change 1st longword in PDT from reserved to forward
{		link.  Add a new port driver vector to $PDTDEF, 
{		PDT$L_STOP_VCS.
{
{	V03-082	RLRPDTUCB0	Robert L. Rappaport	21-Mar-1984
{		Add PDT$L_UCB0 field to common PDT.
{
{	V03-081	LMP0214		L. Mark Pilant,		21-Mar-1984  9:48
{		Add ORB$L_ACL_MUTEX, the ACL mutex to the ORB.
{
{	V03-080	SSA0019		Stan Amway		13-Mar-1984
{		In $PMBDEF, add ACMODE field to indicate owner access mode.
{
{	V03-079	LMP0206		L. Mark Pilant,		9-Mar-1984  14:27
{		Add a new structure, $ORBDEF, to define an Object's Rights
{		Block.
{
{	V03-078	NPK3046		N. Kronenberg		 7-Mar-1984
{		Add PDT$L_POLLSWEEP to PDTDEF.  This field contains
{		a port driver estimate of the number of seconds it
{		will take to discover all possible ports currently
{ 		in the cluster.
{		Add PBO$K_LENGTH to PBODEF.
{
{	V03-077	SSA0012		Stan Amway		27-Feb-1984
{		In $PMBDEF, move overflow counter out of ACB_OVERLAY.
{		Use former location of overflow counter as address of
{		piggy-back kernel AST routine.
{
{		Add flag PMB$V_QAST to indicate imbedded ACB is queued.
{
{	V03-076	ROW0315		Ralph O. Weber		27-FEB-1984
{		Add new controller models produced by revised MSCP 
{		specification to $MSCPDEF.
{
{	V03-075	ROW0314		Ralph O. Weber		27-FEB-1984
{		Add $MVMSLDEF, mount verification messages list, structure 
{		definition.
{
{	V03-074	ROW0313		Ralph O. Weber		27-FEB-1984
{		Correct MSCP$K_ST_RDTRN, MSCP$K_ST_PLOST, MSCP$K_ST_PRESE, and 
{		MSCP$K_ST_LED definitions (they all had values one less than 
{		they should be).
{
{	V03-073	MMD0243		Meg Dumont,	24-Feb-1984  14:56
{		Add support for MVL$V_OPER adn MVL$B_STDVER
{
{	V03-072	SSA0008		Stan Amway		10-Feb-1984
{		Changed timestamp in $PIBDEF to a quadword.
{
{	V03-071	SSA0007		Stan Amway		 6-Feb-1984
{		Modified $PFBDEF and $PMBDEF to track changes
{		in page fault monitor buffer management routines.
{
{	V03-070	RSH0096		R. Scott Hanna		02-Feb-1984
{		Add mandatory security auditing bit to PCB status bits.
{		Replace $NSAARGDEF, $NSAEVTDEF, and $NSAIDTDEF.
{
{	V03-069	WHM0001		Bill Matthews		01-Feb-1984
{		Add a new parameter type for the LGI_ SYSGEN parameters.
{
{	V03-068	TMK0002		Todd M. Katz		31-Jan-1984
{		Increase the number of reserved vectors in $PDTDEF from 3 to 10.
{
{	V03-067	ROW0291		Ralph O. Weber		29-JAN-1984
{		Add MSCP unit number definitions for foreign disk "old 
{		controller sub types."  This plus the 8 foreign disk device 
{		types (DT$_FD1 through DT$_FD8) allow foreign disks to be
{		served using the MSCP server.
{
{	V03-066	ACG0385		Andrew C. Goldstein,	10-Jan-1984  16:21
{		New network proxy file format ($NAFDEF)
{
{	V03-064	LJK0257		Lawrence J. kenah	5-Jan-1984
{		Increase all text fields in PQB to 256 characters to
{		accommodate longer logical names, file specifications, and
{		so on. Move page file parameters and SWAPSIZE from PQB to
{		PCB to allow PQB to be allocated from paged memory. Add
{		security clearance fields to PHD. 
{
{	V03-063	ROW0271		Ralph O. Weber		29-DEC-1983
{		Add MSCP structure definitions for shadowed volume set 
{		operations to $MSCPDEF.  The unit flags bitfield definitions 
{		have been omitted from this update because their exact values 
{		are, as yet, unclear.
{
{	V03-062	SSA0004		Stan Amway		28-Dec-1983
{		Added support for page fault monitor enhancements.
{		Added PCB$L_PMB to PCB.
{		Replaced module $PMBDEF with a substantially changed version.
{		Added new module $PFBDEF.
{
{	V03-061	ROW0264		Ralph O. Weber		27-DEC-1983
{		Replace the entire $MSCPDEF module with a new, more readable 
{		version.  Several previously undefined mask symbols are now 
{		defined.  The new $MSCPDEF is believed to produce useable 
{		symbols for BLISS.
{
{	V03-060	TCM0001		Trudy C. Matthews	14-Dec-1983
{		Add new nexus device type code: NDT$_MEM1664NI, to describe
{		11/750 memory controller, which can hold a mixture of
{		16k and 64k chip array cards.
{
{	V03-059	LMP0177		L. Mark Pilant,		7-Dec-1983  9:51
{		Add an ACL listhead to the PCB.
{
{	V03-058	SSA0003		Stan Amway		 5-Dec-1983
{		Added support for outswap scheduling changes.
{		Removed PHD$W_WAITIME from PHD.
{		Added   PCB$L_WAITIME to   PCB.
{
{	V03-057	WMC0057		Wayne Cardoza		05-Dec-1983
{		Change PHD$W_BAK,_WSLX,PSTBASMAX to longwords.
{
{	V03-056	JWT0145		Jim Teague		18-Nov-1983
{		Define masks for $PCBDEF bitfields.
{
{	V03-055	ROW0249		Ralph O. Weber		10-NOV-1983
{		Add MSCP$B_CNT_ALCS, the MSCP Set Controller Characteristics 
{		end message field in which the allocation class will be 
{		returned.
{
{	V03-054	LMP0167		L. Mark Pilant,		10-Nov-1983  15:22
{		Modify $NMBDEF to add support for full ODS-1 wildcarding.
{
{	V03-053	RLRBINDT	Robert L. Rappaport	9-Nov-1983
{		Add BI devices to $NDTDEF.
{
{	V03-052	TMK0001		Todd M. Katz		26-Oct-1983
{		Add PQB$L_JTQUOTA to $PQBDEF.
{
{	V03-051	SSA00002	Stan Amway		30-Sep-1983
{		Module $PIBDEF - added aggregate PIBDEF5 to support
{		new routine PMS$ABORT_RQ in IOPERFORM. Added aborted
{		I/O request as new transaction type in aggregate 
{		PIBDEF4.
{
{	V03-050	KTA3084		Kerbey T. Altmann	27-Sep-1983
{		Differentiate between RP/RM on MASSBUS disks in
{		the MSCP unit number.
{
{	V03-049	SSA0001		Stan Amway		13-Sep-1983
{		Module $PIBDEF, aggregate PIBDEF2 - Made transfer
{		byte count a longword and relocated to end of
{		structure. Added FILL_9 to redefine word formerly
{		used as transfer byte count.
{
{	V03-048	WMC0047		Wayne Cardoza		31-Aug-1983
{		Add a flag to MMGDEF
{
{	V03-047	GAS0171		Gerry Smith		24-Aug-1983
{		For NSAEVTDEF, remove terminal and mailbox I/O, and
{		add interactive and remote login/logout.
{
{	V03-046	WMC0046		Wayne Cardoza	28-Jul-1983
{		Add PQB fields for logical name characteristics.
{
{	V03-045	RSH0048		R. Scott Hanna		28-Jul-1983
{		Replace $NSAARGDEF
{
{	V03-044	RLRTMSCP	Robert L. Rappaport	28-Jul-1983
{		Add MSCP$K_ST_LED (LEOT detected status),
{		MSCP$K_SC_DLATE( Data Late subcode), MSCP$x_MD_IMMED
{		(request Immediate completion modifier) and MSCP$x_MD_DLEOT
{		(request LEOT detection modifier).
{
{	V03-043	NPK3029		N. Kronenberg		26-Jul-1983
{		Rearrange PB slightly.  Add new send dg w/register
{		entry to PDT and 3 new reserved longwords at end
{		of SCS entry list.
{
{	V03-042	RNG0042		Rod N. Gamache		22-Jul-1983
{		Add MS780-H nexus device types to $NDTDEF.
{
{	V03-041	RLRMSLG		Robert L. Rappaport	22-Jul-1983
{		Add MSLG (MSCP Error Log) definitions.
{		Also add "Host Buffer Access Error" sub-codes to MSCPDEF.
{
{	V03-040	MSH0002		Maryann Hinden		23-Jun-1983
{		Add $PRCPOLDEF.
{
{	V03-039	RSH0037		R. Scott Hanna		17-Jun-1983
{		Permanent fix to $NSAARGDEF symbols. Add ARG_COUNT
{		to $NSAARGDEF. Add EVT_UPGRADE and EVT_DOWNGRADE to
{		$NSAEVTDEF.
{
{	V03-038	SRB0093		Steve Beckhardt		6-Jun-1983
{		Added PCB$M_RECOVER to $PCBDEF
{
{	V03-037	ADE9001		A. ELDRIDGE		27-May-1983
{		Temporary fix to $NSAARGDEF to allow system to build.
{
{	V03-036	RSH0024		R. Scott Hanna		24-May-1983
{		Add $NSAIDTDEF and $NSAARGDEF
{
{	V03-035	RLRPCHAR	Robert L. Rappaport	19-May-1983
{		Add PDT$W_PORTCHAR field and add PDT$M_SNGLHOST bit
{		in this word.
{
{	V03-034	KTA3051		Kerbey T. Altmann	18-May-1983
{		Add more PDT types.
{
{	V03-033	LMP0112		L. Mark Pilant,		10-May-1983  9:24
{		Add a new cell, PCB$L_DEFPROT, to contain the process
{		default protection.
{
{	V03-032 RSH0016		R. Scott Hanna		30-Apr-1983
{		Replace $NSAEVTDEF
{
{	V03-031 MSH0001		Maryann Hinden		25-Mar-1983
{		Add ASCII type flag to $PRMDEF
{
{	V03-030	MMD0110		Meg Dumont,	24-Mar-1983  17:53
{		Fix the def for MVL$K(C)_FIXLEN
{
{	V03-029	WMC0029		Wayne Cardoza		15-Mar-1983
{ 		Add IMGDMP flag to PHD
{		Add flags word to PQB.
{
{	V03-028 RSH0011		R. Scott Hanna		13-Mar-1983
{		Add $NSAEVTDEF
{
{	V03-027	MMD0107		Meg Dumont,	10-Mar-1983  15:54
{		Add field MVL$T_VOLOWNER to contain VOL1 owner id field
{
{	V03-026	RLRUNIT		Robert L. Rappaport	8-Mar-1983
{		Add subfields to MSCP$W_UNIT for HSC emulator.
{
{	V03-025	WMC0025		Wayne Cardoza		07-Mar-1983
{		Add PCB$V_INTER
{
{	V03-024	RLRDDB		Robert L. Rappaport	1-Mar-1983
{		Add subfields to MSCP$L_MEDIA_ID.
{
{	V03-023	DWT0079		David W. Thiel		1-Mar-1983
{		Add PRM$V_CLUSTER to define cluster SYSGEN parameters.
{
{	V03-022	RLRMXBCNT	Robert L. Rappaport	25-Feb-1983
{		Add PDT$L_MAXBCNT.
{
{	V03-021 CWH1002		CW Hobbs		24-Feb-1983
{		Rename PCB$L_PID_EXTERNAL to PCB$L_EPID, and add PCB$L_EOWNER.
{
{	V03-020	KBT0499		Keith B. Thompson	16-Feb-1983
{		Increase the size of PQB$C_MAXDIRLEN to 178 (match FWA$C_MAXDIRLEN)
{
{	V03-019 CWH0001		CW Hobbs		19-Feb-1983
{		Add PCB$L_PID_EXTERNAL for pid changes.
{
{	V03-018	RLRRDRX		Robert L. Rappaport	9-Feb-1983
{		Add MSCP$K_CM_RDRX, MSCP$K_OP_RWATN and MSCP$M_MD_EXCLU.
{
{	V03-017	WMC0016		Wayne Cardoza		26-Jan-1983
{		Make PTE$V_STX a signed bitfield.
{
{	V03-016	ACG0307		Andrew C. Goldstein,	10-Jan-1983  16:25
{		Add system protection block ($PRBDEF)
{
{	V03-015	WMC0015		Wayne Cardoza		10-Jan-1982
{		Put PRMDEF back.
{		It was accidentally deleted in V03-013.
{
{	V03-014	WMC0014		Wayne Cardoza		8-Jan-1983
{		Temporarily delete PRODEF to make build run.
{		There is a conflict with the object language.
{
{	V03-013	ACG0307		Andrew C. Goldstein,	30-Dec-1982  17:08
{		Add enhanced protection structures to PCB
{
{	V03-012	ACG0303		Andrew C. Goldstein,	9-Dec-1982  15:13
{		Add FILL attribute to extraneous names
{
{	V03-011	NPK3010		N. Kronenberg		12-Nov-1982
{		Add $PBODEF to define offsets to output from SCS$CONFIG_PTH
{		call.
{		Add CI port type codes symbols to $PBDEF.
{
{	V03-010	CDS0001		C Saether		22-Oct-1982
{		Add PCB$B_DPC delete pending counter.
{
{	V03-009	RLRPRESE	Robert L. Rappaport	15-Oct-1982
{		Add MSCP$K_ST_PRESE (previously existing serious exception).
{
{	  V03-008	 WMC0002		Wayne Cardoza		28-Sep-1982
{		Expand PQB to add page file selection.
{
{        V03-007        WMC0001                Wayne Cardoza                28-Jul-1982
{                Add "useable by checkpoint" bit to page file control block.
{
{        V03-006        RLR0002                Robert L. Rappaport        13-July-1982
{                Correct some Tape MSCP errors.
{
{        V03-005        RLR0001                Robert L. Rappaport        17-June-1982
{                Add Tape MSCP definitions to MSCPDEF.
{
{**

module $MBADEF;

/*+
/* MASSBUS ADAPTER REGISTER OFFSET DEFINITIONS
/*-



aggregate MBADEF structure prefix MBA$;
    CSR_OVERLAY union fill;
        CSR longword unsigned;				/*CONFIGURATION STATUS REGISTER 
	CSR_BITS structure fill;
            CSR_ADCOD bitfield length 8;		/* ADAPTER CODE FIELD 
            FILL_1 bitfield length 13 fill prefix MBADEF tag $$;/* RESERVED BITS 
            CSR_OT bitfield mask;			/* OVER TEMPERATURE 
            CSR_PU bitfield mask;			/* ADAPTER POWER UP 
            CSR_PD bitfield mask;			/* ADAPTER POWER DOWN 
            FILL_2 bitfield length 2 fill prefix MBADEF tag $$;/* RESERVED BITS 
            CSR_XMFLT bitfield mask;			/* TRANSMITTER FAULT 
            CSR_MT bitfield mask;			/* MULTIPLE TRANSMITTERS 
            FILL_3 bitfield fill prefix MBADEF tag $$;	/* RESERVED BIT 
            CSR_URD bitfield mask;			/* UNEXPECTED READ DATA 
            CSR_WS bitfield mask;			/* WRITE SEQUENCE DATA 
            CSR_PE bitfield mask;			/* SBI PARITY ERROR 
	end CSR_BITS;
    end CSR_OVERLAY;
    CR_OVERLAY union fill;
        CR longword unsigned;				/*CONTROL REGISTER 
	CR_BITS structure fill;
            CR_INIT bitfield mask;			/* ADAPTER INITIALIZATION 
            CR_ABORT bitfield mask;			/* ABORT OPERATION 
            CR_IE bitfield mask;			/* INTERRUPT ENABLE 
	end CR_BITS;
    end CR_OVERLAY;
    SR_OVERLAY union fill;
        SR longword unsigned;				/*STATUS REGISTER 
	SR_BITS structure fill;
            SR_RDTO bitfield mask;			/* READ DATA TIMEOUT 
            SR_ISTO bitfield mask;			/* INTERFACE SEQUENCE TIMEOUT 
            SR_RDS bitfield mask;			/* READ DATA SUBSTITUTE 
            SR_ERCONF bitfield mask;			/* ERROR CONFIRMATION 
            SR_INVMAP bitfield mask;			/* INVALID MAP REGISTER 
            SR_MAPPE bitfield mask;			/* MAP PARITY ERROR 
            SR_MDPE bitfield mask;			/* MASSBUS DATA PARITY ERROR 
            SR_MBEXC bitfield mask;			/* MASSBUS EXCEPTION 
            SR_MXF bitfield mask;			/* MISSED TRANSFER ERROR 
            SR_WCKLWR bitfield mask;			/* WRITE CHECK ERROR LOWER BYTE 
            SR_WCKUPR bitfield mask;			/* WRITE CHECK ERROR UPPER BYTE 
            SR_DLT bitfield mask;			/* DATA LATE ERROR 
            SR_DTABT bitfield mask;			/* DATA TRANSFER ABORTED 
            SR_DTCOMP bitfield mask;			/* DATA TRANSFER COMPLETE 
            SR_SPE bitfield mask;			/* SILO PARITY ERROR 
            FILL_4 bitfield fill prefix MBADEF tag $$;	/* RESERVED BITS 
            SR_ATTN bitfield mask;			/* MASSBUS ATTENTION 
            SR_MCPE bitfield mask;			/* MASSBUS COMTROL PARITY ERROR 
            SR_NED bitfield mask;			/* NONEXISTENT DRIVE 
            SR_PGE bitfield mask;			/* PROGRAM ERROR 
            FILL_5 bitfield length 3 fill prefix MBADEF tag $$;/* RESERVED BITS 
            SR_CBHUNG bitfield mask;			/* CB HUNG 
            FILL_6 bitfield length 5 fill prefix MBADEF tag $$;/* RESERVED BITS 
            SR_CRD bitfield mask;			/* CORRECTED READ DATA 
            SR_NRCONF bitfield mask;			/* NO RESPONSE CONFIRMATION 
            SR_DTBUSY bitfield mask;			/* DATA TRANSFER BUSY 
	end SR_BITS;
        	 					/* ERROR BITS 
        constant ERROR	equals
            ( MBA$M_SR_RDTO!
        	MBA$M_SR_ISTO!
        	MBA$M_SR_RDS!
        	MBA$M_SR_ERCONF!
        	MBA$M_SR_INVMAP!
        	MBA$M_SR_MAPPE!
        	MBA$M_SR_MDPE!
        	MBA$M_SR_MBEXC!
        	MBA$M_SR_MXF!
        	MBA$M_SR_WCKLWR!
        	MBA$M_SR_WCKUPR!
        	MBA$M_SR_DLT!
        	MBA$M_SR_SPE!
        	MBA$M_SR_DTABT!
        	MBA$M_SR_MCPE!
        	MBA$M_SR_NED!
        	MBA$M_SR_PGE  )
         prefix MBA tag $M;				/* PROGRAM ERROR 
    end SR_OVERLAY;
    VAR longword unsigned;				/*VIRTUAL ADDRESS REGISTER 
    BCR longword unsigned;				/*BYTE COUNT REGISTER 
    DR longword unsigned;				/*DIAGNOSTIC REGISTER 
    SELMR longword unsigned;				/*SELECTED MAP REGISTER 
    FILL_7 byte dimension 996 fill prefix MBADEF tag $$;/* VALUE IS 1024-<4*7> 
    ERB_OVERLAY union fill;
        ERB longword unsigned;				/*BASE ADDRESS OF EXTERNAL REGISTERS 
	ERB_BITS structure fill;
            FILL_8 bitfield length 7 fill prefix MBADEF tag $$;/* REGISTER OFFSET ADDRESS BITS 
            ERB_UNIT bitfield length 3;			/* DRIVE UNIT NUMBER 
	end ERB_BITS;
    end ERB_OVERLAY;
    FILL_9 byte dimension 12 fill prefix MBADEF tag $$;	/* DRIVE REGISTER ADDRESS SPACE 
    AS longword unsigned;				/*ATTENTION SUMMARY REGISTER 
    FILL_10 byte dimension 1004 fill prefix MBADEF tag $$;/* VALUE IS 2048-. 
                                            		/* TO POSITION TO 2048
    MAP longword unsigned dimension 256;		/*MAP REGISTERS 
    
end MBADEF;

end_module $MBADEF;


module $MBXDEF;
/*+
/* SHARED MEMORY MAILBOX CONTROL BLOCK DEFINITIONS
/*
/* THERE IS ONE MAILBOX CONTROL BLOCK FOR EACH MAILBOX IN SHARED
/* MEMORY.  ANY PROCESSOR THAT WANTS TO ACCESS THE MAILBOX CREATES
/* A UCB TO CONTROL ACCESS TO THE MAILBOX.
/*-



aggregate MBXDEF structure prefix MBX$;
    MSG quadword unsigned;				/*MESSAGE QUEUE LISTHEAD 
    FLAGS_OVERLAY union fill;
        FLAGS byte unsigned;				/*FLAGS 
	FLAGS_BITS structure fill;
            ALLOC bitfield mask;			/* MAILBOX ALLOCATED 
            VALID bitfield mask;			/* MAILBOX INITIALIZED AND USEABLE 
            DELPEND bitfield mask;			/* DELETE PENDING 
            QUOTALCK bitfield mask;			/* QUOTA/COUNT MODIFICATION LOCK 
	end FLAGS_BITS;
    end FLAGS_OVERLAY;
    CREATPORT byte unsigned;				/*PORT NUMBER OF MAILBOX CREATOR 
    UNIT word unsigned;					/*MAILBOX UNIT NUMBER 
    "REF" word unsigned;				/*REFERENCE FLAGS (1 BIT/PORT) 
    READER word unsigned;				/*WAITING READER (1 BIT/PORT) 
    READAST word unsigned;				/*WAITING READ AST (1 BIT/PORT) 
    WRITAST word unsigned;				/*WAITING WRITE AST (1 BIT/PORT) 
    MAXMSG word unsigned;				/*MAXIMUM MESSAGE SIZE 
    MSGCNT word unsigned;				/*CURRENT NUMBER OF MESSAGES 
    BUFFQUO word unsigned;				/*BUFFER QUOTA 
    PROT word unsigned;					/*PROTECTION MASK 
    OWNUIC longword unsigned;				/*OWNER UIC 
    NAME character length 16;				/*MAILBOX NAME (COUNTED STRING) 
/* *** THE LENGTH OF THIS STRUCTURE MUST BE AN EVEN MULTIPLE OF 8 ***
/* *** BECAUSE THE MESSAGE QUEUE HEADER MUST BE QUADWORD ALIGNED ***
    constant "LENGTH" equals . prefix MBX$ tag K;	/*LENGTH OF STRUCTURE 
    constant "LENGTH" equals . prefix MBX$ tag C;	/*LENGTH OF STRUCTURE 
    
end MBXDEF;

end_module $MBXDEF;


module $MCHKDEF;
/*+
/* MACHINE CHECK ERROR RECOVERY BLOCK MASK BIT DEFFINITIONS
/* BITS USED TO FILTER AND TEST FOR ERROR TYPES
/*-


aggregate MCHKDEF  union prefix MCHK$;
    MCHKDEF_BITS structure fill;
        LOG bitfield mask;				/*INHIBIT ERROR LOGGIN FOR THE ERROR 
        MCK bitfield mask;				/*PROTECT AGAINST MACHINE CHECKS 
        NEXM bitfield mask;				/*PROTECT AGAINST NON-EXISTENT MEMORY 
        UBA bitfield mask;				/*PROTECT AGAINST UBA ADAPTER ERROR INTRPT 
    end MCHKDEF_BITS;
end MCHKDEF;

end_module $MCHKDEF;


{+
{ Define the frame pointer offsets that determine what the impure area
{ used by the memory management system services looks like.
{-
module $MMGDEF;

/*        -F        ,B,0                        /* ending address of negated structure
                                        		/* (needed to obtain length definition)


aggregate MMGDEF structure prefix MMG$ origin FILL_2;
    constant "LENGTH" equals . prefix MMG$ tag K;	/* size of scratch area 
    constant "LENGTH" equals . prefix MMG$ tag C;	/* size of scratch area 
    EFBLK longword unsigned;				/* stored end-of-file block from WCB 
    VFYFLAGS longword unsigned;				/* verified section flags and maximum 
                                            		/*  access mode for writing
    SVSTARTVA longword unsigned;			/* saved starting virtual address 
    PAGESUBR longword unsigned;				/* address of per page subroutine 
    SAVRETADR longword unsigned;			/* saved return address range 
    CALLEDIPL longword unsigned;			/* caller's IPL 
    MAXACMODE_OVERLAY union fill;
        MAXACMODE longword unsigned;			/* maximized read access mode 
/*
	MAXACMODE_BITS structure fill;
            FILL_1 bitfield length 8 fill prefix MMGDEF tag $$;/* no flags in first byte 
            CHGPAGFIL bitfield mask;			/* charge page file for this PTE 
            DELGBLDON bitfield mask;			/* global pages in this range 
                                                    	/*  already deleted
	    NOWAIT_IPL0 bitfield mask;			/* abort instead of dropping to 0
	end MAXACMODE_BITS;
/*
    end MAXACMODE_OVERLAY;
    FILL_2 byte fill prefix MMGDEF tag $$;
end MMGDEF;

end_module $MMGDEF;


module $MTLDEF;
/*+
/* MOUNTED VOLUME LIST ENTRY. ONE SUCH ENTRY APPEARS IN THE PROCESS MOUNTED
/* VOLUME LIST FOR EACH VOLUME MOUNTED BY THE PROCESS AS /SHARE OR /NOSHARE.
/* IN ADDITION, EACH VOLUME MOUNTED /SYSTEM OR /GROUP HAS AN ENTRY IN THE
/* SYSTEM WIDE MOUNTED VOLUME LIST.
/*-


aggregate MTLDEF structure prefix MTL$;
    MTLFL longword unsigned;				/* FORWARD LIST POINTER 
    MTLBL longword unsigned;				/* BACK LIST POINTER 
    SIZE word unsigned;					/* STRUCTURE SIZE IN BYTES 
    TYPE byte unsigned;					/* STRUCTURE TYPE CODE 
    STATUS_OVERLAY union fill;
        STATUS byte unsigned;				/* STATUS BYTE 
	STATUS_BITS structure fill;
            VOLSET bitfield;				/* ENTRY IS FOR A VOLUME SET 
	end STATUS_BITS;
    end STATUS_OVERLAY;
    UCB longword unsigned;				/* POINTER TO DEVICE UCB 
    LOGNAME longword unsigned;				/* POINTER TO ASSOCIATED LOGICAL NAME 
    FILL_1 longword fill prefix MTLDEF tag $$;		/* RESERVED LONGWORD 
    constant "LENGTH" equals . prefix MTL$ tag K;	/* LENGTH OF STRUCTURE 
    constant "LENGTH" equals . prefix MTL$ tag C;	/* LENGTH OF STRUCTURE 
end MTLDEF;

end_module $MTLDEF;


module $MTXDEF;
/*+
/* MUTEX DEFINITIONS
/*-


aggregate MTXDEF union prefix MTX$;
    FILL_1 longword fill prefix MTXDEF tag $$;
	FILL_1_BITS structure fill;
            FILL_2 bitfield length 16 fill prefix MTXDEF tag $$;
            WRT bitfield;				/* WRITE PENDING OR IN PROGRESS 
	end FILL_1_BITS;
	FILL_1_FIELDS structure fill;
            OWNCNT word unsigned;			/*OWNERSHIP COUNT 
            STS word unsigned;				/*STATUS BITS 
            
	end FILL_1_FIELDS;
end MTXDEF;

end_module $MTXDEF;


module $MPMDEF;
/*+
/* MULTIPORT MEMORY (MA780/MA750) ADAPTER REGISTER OFFSET DEFINITIONS
/*-
/*
/* The UETP for the MA780 depends on some of the following definitions.  Please
/* let someone in that group know if the definitions change substantially.
/*


constant PORTS	equals 4  prefix MPM tag $C;		/*MAXIMUM NUMBER OF PORTS PER MEMORY 

aggregate MPMDEF structure prefix MPM$;
    CSR_OVERLAY union fill;
        CSR longword unsigned;				/*CONFIGURATION STATUS REGISTER 
	CSR_BITS0 structure fill;
            CSR_PORT bitfield mask length 2;		/* PORT NUMBER 
	end CSR_BITS0;
	CSR_BITS1 structure fill;
            CSR_ADCOD bitfield mask length 8;		/* ADAPTER CODE FIELD 
            FILL_1 bitfield length 14 fill prefix MPMDEF tag $$;/* RESERVED BITS 
            CSR_PU bitfield mask;			/* ADAPTER POWER UP 
            CSR_PD bitfield mask;			/* ADAPTER POWER DOWN 
            FILL_2 bitfield length 2 fill prefix MPMDEF tag $$;/* RESERVED BITS 
            CSR_XMFLT bitfield mask;			/* TRANSMITTER FAULT 
            CSR_MT bitfield mask;			/* MULTIPLE TRANSMITTERS 
            CSR_IS bitfield mask;			/* INTERLOCK SEQUENCE 
            FILL_3 bitfield fill prefix MPMDEF tag $$;	/* RESERVED BIT 
            CSR_WS bitfield mask;			/* WRITE SEQUENCE DATA 
            CSR_PE bitfield mask;			/* SBI PARITY ERROR 
	end CSR_BITS1;
        constant CSR_TYPE	equals 64  prefix MPM tag $C;/* MULTIPORT ADAPTER TYPE CODE 
    end CSR_OVERLAY;
    CR_OVERLAY union fill;
        CR longword unsigned;				/*CONTROL REGISTER 
	CR_BITS structure fill;
            CR_MIE bitfield mask;			/* MASTER INTERRUPT ENABLE 
            CR_EIE bitfield mask;			/* ERROR INTERRUPT ENABLE 
            FILL_4 bitfield length 22 fill prefix MPMDEF tag $$;/* 
            CR_ERRS bitfield mask length 8;		/* PORT INTERFACE ERRORS 
	end CR_BITS;
    end CR_OVERLAY;
    SR_OVERLAY union fill;
        SR longword unsigned;				/*STATUS REGISTER 
	SR_BITS structure fill;
            FILL_5 bitfield fill prefix MPMDEF tag $$;	/* (UNUSED) 
            SR_EIE bitfield mask;			/* ERROR INTERRUPT ENABLE 
            FILL_6 bitfield length 11 fill prefix MPMDEF tag $$;/* 
            SR_SS bitfield mask;			/* SINGLE STEP 
            SR_IDL bitfield mask;			/* INVALIDATE DATA LOST IN MPC 
            SR_IT bitfield mask;			/* INTERLOCK TIMEOUT 
            FILL_7 bitfield length 12 fill prefix MPMDEF tag $$;/* 
            SR_AGP bitfield mask;			/* ADMI GRANT PARITY ERROR 
            SR_XDF bitfield mask;			/* XMIT DURING FAULT 
            SR_MXF bitfield mask;			/* MULTIPLE XMITTER FAULT 
            SR_ACA bitfield mask;			/* ADMI COMMAND ABORT 
	end SR_BITS;
    end SR_OVERLAY;
    INV_OVERLAY union fill;
        INV longword unsigned;				/*INVALIDATION CONTROL REGISTER 
	INV_BITS structure fill;
            INV_ID bitfield mask length 16;		/* CACHED DEVICE NEXUS ID'S 
            INV_MEMSZ bitfield mask length 3;		/* MEMORY SIZE (256KB BOARDS) 
            FILL_8 bitfield fill prefix MPMDEF tag $$;	/* (UNUSED) 
            INV_STADR bitfield mask length 11;		/* STARTING SBI ADDR OF MEMORY 
            INV_CACHF bitfield mask;			/* CACHED FORCE (IGNORE ID'S) 
	end INV_BITS;
    end INV_OVERLAY;
    ERR_OVERLAY union fill;
        ERR longword unsigned;				/*ARRAY ERROR REGISTER 
	ERR_BITS structure fill;
            FILL_9 bitfield length 28 fill prefix MPMDEF tag $$;/* 
            ERR_ELR bitfield mask;			/* ERROR LOG REQUEST 
            ERR_HI bitfield mask;			/* HIGH ERROR RATE 
            ERR_ICRD bitfield mask;			/* INHIBIT CRD ERRORS 
            ERR_IMP bitfield mask;			/* INVALIDATE MAP PARITY ERROR 
	end ERR_BITS;
    end ERR_OVERLAY;
    CSR0_OVERLAY union fill;
        CSR0 longword unsigned;				/*CONFIGURATION STATUS REGISTER 0 
	CSR0_BITS structure fill;
            FILL_10 bitfield length 4 fill prefix MPMDEF tag $$;/* 
            CSR0_POW bitfield length 4;			/* PER PORT POWER STATUS 
            CSR0_ERR bitfield length 4;			/* PER PORT ERROR STATUS 
            CSR0_ONL bitfield length 4;			/* PER PORT ONLINE STATUS 
	end CSR0_BITS;
    end CSR0_OVERLAY;
    CSR1_OVERLAY union fill;
        CSR1 longword unsigned;				/*CONFIGURATION STATUS REGISTER 1 
	CSR1_BITS structure fill;
            FILL_11 bitfield length 10 fill prefix MPMDEF tag $$;/* 
            CSR1_MIA bitfield mask;			/* MULTIPLE INTERLOCK ACCEPTED 
	end CSR1_BITS;
    end CSR1_OVERLAY;
    MR_OVERLAY union fill;
        MR longword unsigned;				/*MAINTENANCE REGISTER 
	MR_BITS structure fill;
            FILL_12 bitfield length 14 fill prefix MPMDEF tag $$;/* (ERROR BITS) 
            MR_UNIT bitfield length 2;			/* MEMORY UNIT NUMBER 
	end MR_BITS;
    end MR_OVERLAY;
    IIR_OVERLAY union fill;
        IIR longword unsigned;				/*INTERPORT INTERRUPT REQUEST REGISTER 
	IIR_BITS structure fill;
            IIR_STS bitfield length 16;			/* STATUS BITS (WRITE TO CLEAR) 
            IIR_CTL bitfield length 16;			/* CONTROL BITS (WRITE TO SET STATUS BITS) 
	end IIR_BITS;
    end IIR_OVERLAY;
    IIE_OVERLAY union fill;
        IIE longword unsigned;				/*INTERPORT INTERRUPT ENABLE REGISTER 
	IIE_BITS structure fill;
            IIE_STS bitfield length 16;			/* CONTROL BITS (WRITE TO CLEAR) 
            IIE_CTL bitfield length 16;			/* STATUS BITS (WRITE TO SET STATUS BITS) 
	end IIE_BITS;
        
    end IIE_OVERLAY;
end MPMDEF;

end_module $MPMDEF;


module $MSLGDEF;

/*+
/* MSLG, MScp error LoG message definitions
/* 	These definitions describe the format of the error log messages 
/* 	generated by MSCP and TMSCP devices.
/*-

/*
/*	Generic MSCP/TMSCP error log entry format
/*


aggregate GENERIC_MSCP_ERRLOG structure prefix MSLG$;
    CMD_REF longword unsigned;			/* Command reference number 
    UNIT word unsigned;				/* Unit number 
    SEQ_NUM word unsigned;			/* Sequence Number
    FORMAT byte unsigned;			/* Format
    FLAGS structure byte unsigned;		/* Error Log Message Flags
	LF_SQNRS bitfield mask;			/*   Sequence Number Reset
	filler bitfield length 3 fill;
	LF_RPLER bitfield mask;			/*   Error during replacement
	LF_BBR bitfield mask;			/*   Bad block replacement request
	LF_CONT bitfield mask;			/*   Operation continuing
	LF_SUCC bitfield mask;			/*   Operation successful
    end FLAGS;
    EVENT word unsigned;			/* Event Code
    constant (
	  CNT_ERR				{     Controller error
	, BUS_ADDR				{     Host memory access error
	, DISK_TRN				{     Disk transfer error (disks)
	, SDI					{     SDI error (disks)
	, SML_DSK				{     Small disk error (disks)
	, TAPE_TRN				{     Tape transfer error (tapes)
	, STI_ERR				{     STI communication or command error (tapes)
	, STI_DEL				{     STI driver error log (tapes)
	, STI_FEL				{     STI formatter error log (tapes)
	, REPLACE				{     Bad block replacement attempt (disks)
	) equals 0 increment 1;
    CNT_ID quadword unsigned;			/* Controller ID
    CNT_SVR byte unsigned;			/* Controller software version
    CNT_HVR byte unsigned;			/* Controller hardware version
    #cnt_err_base = .;
    MULT_UNT word unsigned;			/* Multi-unit Code
    #bus_addr_base = .;
    UNIT_ID quadword unsigned;			/* Unit ID
    UNIT_SVR byte unsigned;			/* Unit software version
    UNIT_HVR byte unsigned;			/* Unit hardware version
    #format_dependent = .;
    LEVEL byte unsigned;			/* Level
    RETRY byte unsigned;			/* Retry
    VOLSER_GAPCNT union fill;
	VOL_SER longword unsigned;		/* Volume Serial Number (disks)
	GAP_CNT longword unsigned;		/* Position - object count (tapes)
    end VOLSER_GAPCNT;
    #generic_disk_base = .;
    FMTR_SVR byte unsigned;			/* Formatter software version
    FMTR_HVR byte unsigned;			/* Formatter hardware version
    reserved word fill;
    #generic_tape_base = .;
end GENERIC_MSCP_ERRLOG;

/*
/*  Controller Error (MSLG$K_CNT_ERR)
/*

aggregate MSLG_CNT_ERR structure prefix MSLG$;

    filler byte dimension #cnt_err_base fill;
    CNT_ERR byte tag Z;				/* Controller dependent data

end MSLG_CNT_ERR;

/*
/*  Host Memory Access Error (MSLG$K_BUS_ADDR)
/*

aggregate MSLG_BUS_ADDR structure prefix MSLG$;

    filler byte dimension #bus_addr_base fill;
    BUS_ADDR longword unsigned;			/* Bus Address

end MSLG_BUS_ADDR;

/*
/*  Disk Transfer Error (MSLG$K_DISK_TRN)
/*

aggregate MSLG_DISK_TRN structure prefix MSLG$;

    filler byte dimension #generic_disk_base fill;
    HDR_CODE longword unsigned;			/* Header Code
    DISK_TRN byte tag Z;			/* Controller or disk dependent data

end MSLG_DISK_TRN;

/*
/*  SDI Error (MSLG$K_SDI)
/*

aggregate MSLG_SDI structure prefix MSLG$;

    filler byte dimension #generic_disk_base fill;
    hdr_code longword fill;			{  Header Code (defined above)
    SDI byte unsigned dimension 12;		/* SDI Information

end MSLG_SDI;

/*
/*  Small Disk Error (MSLG$K_SML_DSK)
/*

aggregate MSLG_SML_DSK structure prefix MSLG$;

    filler_1 byte dimension #format_dependent fill;
    SDE_CYL word unsigned;			/* Cylinder
    filler_2 byte dimension #generic_disk_base-. fill;
    SML_DSK byte tag Z;				/* Controller or device dependent

end MSLG_SML_DSK;

/*
/*  Tape Transfer Error (MSLG$K_STI_ERR)
/*
/*	There are no special field definitions for tape transfer errors at this time.

/*
/*  STI communication or command failure (MSLG$K_STI_ERR)
/*  STI drive error log (MSLG$K_STI_DEL)
/*  STI formatter error log (MSLG$K_STI_FEL)
/*

aggregate MSLG_STI_ERR structure prefix MSLG$;

    filler byte dimension #generic_tape_base fill;
    STI byte unsigned dimension 20;		/* STI Information

end MSLG_STI_ERR;

/*
/*  Bad Block Replacement Attempted (MSLG$K_REPLACE)
/*

aggregate MSLG_REPLACE structure prefix MSLG$;

    filler_1 byte dimension #format_dependent fill;
    RPL_FLGS structure word unsigned;		/* Replace Flags
	bit_fill bitfield length 10 fill;
	LFR_BR bitfield mask;			/*  Bad RBN
	LFR_RI bitfield mask;			/*  RCT inconsistent
	LFR_RF bitfield mask;			/*  Reformat error
	LFR_TE bitfield mask;			/*  Tertiary revector
	LFR_FE bitfield mask;			/*  Forced error (data not recovered)
	LFR_RP bitfield mask;			/*  Replace attempted (block really bad)
    end RPL_FLGS;
    filler_2 byte dimension #generic_disk_base-. fill;
    BAD_LBN longword unsigned;			/* Bad LBN
    OLD_RBN longword unsigned;			/* Previous RBN
    NEW_RBN longword unsigned;			/* New RBN
    CAUSE word unsigned;			/* Event code causing replacement

end MSLG_REPLACE;

end_module $MSLGDEF;

module $MSCPDEF;

/*++
/* MSCP (Mass Storage Control Protocol) Definitions
/*
/*	These definitions describe the format of the command and end message 
/*	packets exchanged under MSCP between the host and the controller.
/*--

aggregate GENERIC_MSCP structure prefix MSCP$;

    CMD_REF longword unsigned;				/* Command reference number
    UNIT structure word unsigned;			/* Unit number
	EU_NO_OVERLAY union fill;
	    EU_NO bitfield length 8 mask;		/* Emulated unit number
	    EU_SUB_NO structure fill;
		EU_SUBU bitfield length 3 mask;		/* Old-style unit number
		EU_SUBC bitfield length 5 mask;		/* Old-style controller subtype
		constant (				{  subtype values:
		    EMS_CNSL,				{	Console
		    EMS_RP,				{	RP04/05/06
		    EMS_RM,				{	RM03/05/80/RP07
		    EMS_RK,				{	RK06/07
		    EMS_RL,				{	RL01/02
		    EMS_RX,				{	RX211
		    EMS_FD1,				{	Foreign disk type 1
		    EMS_FD2,				{	Foreign disk type 2
		    EMS_FD3,				{	Foreign disk type 3
		    EMS_FD4,				{	Foreign disk type 4
		    EMS_FD5,				{	Foreign disk type 5
		    EMS_FD6,				{	Foreign disk type 6
		    EMS_FD7,				{	Foreign disk type 7
		    EMS_FD8				{	Foreign disk type 8
		    ) equals 0 increment 1;
	    end EU_SUB_NO;
	end EU_NO_OVERLAY;
	EU_CTYPE bitfield length 4 mask;		/* Emulated controller type
	constant (					{  controller type values:
	    EMD_OLD,					{	old-style (highest unit number is 7)
	    EMD_UDA,					{	UDA
	    EMD_HSC,					{	HSC
	    EMD_AZT,					{	RC25 (AZTEC)
	    EMD_RDRX,					{	RD/RX
	    EMD_EMUL					{	Emulated
	    ) equals 0 increment 1;
	EU_DESIG bitfield length 3 mask;		/* Emulated controller designator
	SHADOW bitfield mask;				/* Shadow unit
    end UNIT;
    reserved word fill;
    OPCODE structure byte unsigned;			/* MSCP operation code
	code bitfield length 3 fill;			{  function code
	type bitfield length 3 fill;			{  immediate / sequential / non-sequential
	OP_ATTN bitfield mask;				/* Attention message
	OP_END bitfield mask;				/* End message
    end OPCODE;
    MODIFIERS_STATUS union fill;
	MODIFIERS structure fill;
	    reserved byte fill;
	    #modifier_base =.; 				{  base for modifiers setup
	    MODIFIER word unsigned;			/* MSCP command modifiers
	end MODIFIERS;
	FLAGS_STATUS structure fill;
	    FLAGS structure byte unsigned;		/* End message flags
		filler bitfield length 2 fill;
		EF_PLS bitfield mask;			/* Position Lost (tapes only)
		EF_EOT bitfield mask;			/* End of Tape Encountered (tapes only)
        	EF_SEREX bitfield mask;			/* Serious exception (tapes only)
        	EF_ERLOG bitfield mask;			/* Error log generated
        	EF_BBLKU bitfield mask;			/* Bad block unreported (disks only)
        	EF_BBLKR bitfield mask;			/* Bad block reported (disks only)
	    end FLAGS;
	    #status_base =.;				{  base for status setup
	    STATUS structure word unsigned;		/* End message status
		ST_MASK bitfield length 5 mask;		/* Status code bits
		constant (				{  status code values:
			ST_SUCC,			{	Success
			ST_ICMD,			{	Invalid command
			ST_ABRTD,			{	Command aborted
			ST_OFFLN,			{	Unit-offline
			ST_AVLBL,			{	Unit-available
			ST_MFMTE,			{	Media format error
			ST_WRTPR,			{	Write protected
			ST_COMP,			{	Compare error
			ST_DATA,			{	Data error
			ST_HSTBF,			{	Host buffer access error
			ST_CNTLR,			{	Controller error
			ST_DRIVE,			{	Drive error
			ST_FMTER,			{	Formatter error (tapes only)
			ST_BOT,				{	BOT encountered (tapes only)
			ST_TAPEM			{	Tape mark encountered (tapes only)
			) equals 0 increment 1,
			ST_SHST equals 12, (		{	Shadow set state change (disks only)
			ST_RDTRN,			{	Record data truncated (tapes only)
			ST_PLOST,			{	Position lost (tapes only)
			ST_PRESE,			{	Previous serious exception (tapes only)
			ST_LED,				{	LEOT detected (tapes only)
			ST_BBR				{	Bad block replacement completed (disks only)
			) equals 16 increment 1, (
			ST_DIAG,			{	Message from internal diagnostic
			ST_SBCOD			{	Subcode multiplier
			) equals 31 increment 1;
		ST_SBCOD bitfield length 11 mask;	/* Subcode bits
							{  Subcode values defined seperately below
	    end STATUS;
	end FLAGS_STATUS;
    end MODIFIERS_STATUS;

    #end_basic_packet = .;

    /* MSCP Command Operation Codes (defined in alphabetical order)

    constant OP_ABORT equals 1;				/* Abort
    constant OP_ACCES equals 16;			/* Access
    constant OP_AVAIL equals 8;				/* Available
    constant OP_CMPCD equals 17;			/* Compare Controller Data
    constant OP_COMP  equals 32;			/* Compare Host Data
    constant OP_DTACP  equals 11;			/* Determine Access Paths
    constant OP_ERASE equals 18;			/* Erase
    constant OP_ERGAP equals 22;			/* Erase Gap (tapes only)
    constant OP_FLUSH equals 19;			/* Flush
    constant OP_GTCMD equals 2;				/* Get Command Status
    constant OP_GTUNT equals 3;				/* Get Unit Status
    constant OP_ONLIN equals 9;				/* Online
    constant OP_READ  equals 33;			/* Read
    constant OP_REPLC equals 20;			/* Replace
    constant OP_REPOS equals 37;			/* Reposition (tapes only)
    constant OP_STCON equals 4;				/* Set Controller Characteristics
    constant OP_STUNT equals 10;			/* Set Unit Characteristics
    constant OP_WRITE equals 34;			/* Write
    constant OP_WRITM equals 36;			/* Write Tape Mark

    /* MSCP End Message Codes

    constant OP_END   equals %x80;			/* End Message Flag
    constant OP_SEREX equals 7;				/* Serious Execption (end message only)

    /* MSCP Attention Message Codes (listed in alphabetical order)

    constant OP_ACPTH equals 66;			/* Access Path
    constant OP_AVATN equals 64;			/* Available
    constant OP_DUPUN equals 65;			/* Duplicate Unit Number
    constant OP_RWATN equals 67;			/* Rewind (tapes only)

end GENERIC_MSCP;

aggregate MSCP_MODIFIERS structure prefix MSCP$;

  filler byte dimension #modifier_base fill;
  ALL_MODIFIERS union fill;

    /* Generic MSCP Modifiers

    GENERIC_MODIFIERS structure fill;			{  Generic command modifiers:
	filler bitfield length 8 fill;
        MD_SEREC bitfield mask;				/*   Suppress error recovery
        MD_SECOR bitfield mask;				/*   Suppress error correction
	filler bitfield length 3 fill;
        MD_CLSEX bitfield mask;				/*   Clear serious exception
        MD_COMP bitfield mask;				/*   Compare
    end GENERIC_MODIFIERS;

    DISK_MODIFIERS structure fill;			{  Generic disk command modifiers:
	filler bitfield length 4 fill;
        MD_WRSEQ bitfield mask;				/*   Write shadow set 1 unit at a time
        MD_WBKVL bitfield mask;				/*   Write-back (volatile)
        MD_WBKNV bitfield mask;				/*   Write-back (non-volatile)
        MD_SSHDW bitfield mask;				/*   Suppress Shadowing
	filler bitfield length 2 fill;
        MD_SCCHL bitfield mask;				/*   Suppress caching (low speed)
        MD_SCCHH bitfield mask;				/*   Suppress caching (high speed)
        MD_ERROR bitfield mask;				/*   Force error
	filler bitfield length 2 fill;
        MD_EXPRS bitfield mask;				/*   Express request
    end DISK_MODIFIERS;

    TAPE_MODIFIERS structure fill;			{  Generic tape command modifiers:
	filler bitfield length 1 fill;
	MD_REWND bitfield mask;				/*   Rewind
	MD_OBJCT bitfield mask;				/*   Object count
	MD_REVRS bitfield mask;				/*   Reverse
	MD_UNLOD bitfield mask;				/*   Unload
	MD_EXCLU bitfield mask;				/*   Exclusive
	MD_IMMED bitfield mask;				/*   Request immediate completion
	MD_DLEOT bitfield mask;				/*   Request detect LEOT
    end TAPE_MODIFIERS;

    AVAIL_MODIFIERS structure fill;			{  Available command modifiers:
	MD_ALLCD bitfield mask;				/*   All class drivers
	MD_SPNDW bitfield mask;				/*   Spin down
	MD_DSOLV bitfield mask;				/*   Disolve shadow set
    end AVAIL_MODIFIERS;

    FLUSH_MODIFIERS structure fill;			{  Flush command modifiers:
	MD_FLENU bitfield mask;				/*   Flush entire unit
	MD_VOLTL bitfield mask;				/*   Flush volitile only
    end FLUSH_MODIFIERS;

    GTUNT_MODIFIERS structure fill;			{  Get unit status command modifiers:
	MD_NXUNT bitfield mask;				/*   Next unit
    end GTUNT_MODIFIERS;

    ONLIN_STUNT_MODIFIERS structure fill;		{  Online and set unit characteristics modifiers:
	MD_RIP bitfield mask;				/*   Allow self-destruct (online only)
	MD_IGNMF bitfield mask;				/*   Ignore media format error (online only)
	MD_STWRP bitfield mask;				/*   Enable Set Write Protect
	MD_CLWBL bitfield mask;				/*   Clear Write-Back Data Lost
	MD_SHDSP bitfield mask;				/*   Shadow Unit Specified
    end ONLIN_STUNT_MODIFIERS;

    REPLC_MODIFIERS structure fill;			{  Replace command modifiers:
	MD_PRIMR bitfield mask;				/*   Primary replacement block
    end REPLC_MODIFIERS;

  end ALL_MODIFIERS;

end MSCP_MODIFIERS;

aggregate MSCP_SUBCODES structure prefix MSCP$;

  filler byte dimension #status_base fill;
  ALL_SUBCS union fill;

{ NOTE:
{	Many of the subcode values are defined such that they produce bit 
{	fields.  This is not a requirement in the MSCP specification.  So long 
{	as new subcodes continue to produce bit fields, the bit field 
{	definitions here may remain.  When, as, and if, bit fields are no 
{	longer produced, the bit field definitions MUST be removed here and 
{	the code which breaks must be fixed.

    /* Success Subcode Values

    SC_SUCC structure fill;
	constant SC_NORML equals 0;			/* Normal
	constant SC_SDIGN equals 1;			/* Spin Down IGNored
	constant SC_STCON equals 2;			/* STill CONnected
	constant SC_DUPUN equals 4;			/* DUPlicate UNit number
	constant SC_ALONL equals 8;			/* ALready ONLine
        constant SC_STONL equals 16;			/* STill ONLine
	constant SC_EOT   equals 32;			/* EOT encountered (tapes only)
	constant SC_INREP equals 32;			/* INcomplete REPlacement (disks only)
	constant SC_IVRCT equals 64;			/* InValid RCT (disks only)
	bit_fields union fill;
	    fields_1 structure fill;
		filler bitfield length 5 fill;
		SC_SDIGN bitfield mask;			/* Spin Down IGNored
		SC_STCON bitfield mask;			/* STill CONnected
		SC_DUPUN bitfield mask;			/* DUPlicate UNit number
		SC_ALONL bitfield mask;			/* ALready ONLine
		SC_STONL bitfield mask;			/* STill ONLine
		SC_EOT bitfield mask;			/* EOT encountered (tapes only)
	    end fields_1;
	    field_2 structure fill;
		filler bitfield length 10 fill;
		SC_INREP bitfield mask;			/* INcomplete REPlacement (disks only)
		SC_IVRCT bitfield mask;			/* InValid RCT (disks only)
	    end fields_2;
	end bit_fields;
    end SC_SUCC;

    /* Invalid Command Subcode Values

    constant SC_INVML equals 0;				/* INValid Message Length

    /* Unit-Offline Subcode Values

    SC_OFFLN structure fill;
	constant SC_UNKNO equals 0;			/* UNKoNOwn unit or online to another controller
	constant SC_NOVOL equals 1;			/* NO VOLume mounted or drive disabled (RUN/STOP)
	constant SC_INOPR equals 2;			/* unit is INOPeRative
							{  duplicate unit number (already defined above)
	constant SC_UDSBL equals 8;			/* Unit disabled by field service or diagnostic
	filler bitfield length 5 fill;
	SC_NOVOL bitfield mask;				/* NO VOLume mounted or drive disabled (RUN/STOP)
	SC_INOPR bitfield mask;				/* unit is INOPeRative
	dupun bitfield fill;				{  duplicate unit number (already defined above)
	SC_UDSBL bitfield mask;				/* Unit disabled by field service or diagnostic
    end SC_OFFLN;

/* Unit-Available Subcode Values

    constant SC_NOMEMB equals 1;			{  No members


    /* Write-Protected Subcode Values

    SC_WRTPR structure fill;
	constant SC_DATAL equals 8;			/* Unit is DATA Loss write protected
	constant SC_SOFTW equals 128;			/* Unit is SOFTWare protected 
	constant SC_HARDW equals 256;			/* Unit is HARDWare protected 
	filler bitfield length 8 fill;
	SC_DATAL bitfield mask;				/* Unit is DATA Loss write protected
	filler bitfield length 3 fill;
	SC_SOFTW bitfield mask;				/* Unit is SOFTWare protected 
	SC_HARDW bitfield mask;				/* Unit is HARDWare protected 
    end SC_WRTPR;

    /* Data Error Subcode Values

    constant SC_FRCER equals 0;				/* FoRDed ERror

    /* Host Buffer Access Error Subcode Values

    constant (
	SC_ODDTA,					{  Odd transfer address
	SC_ODDBC,					{  Odd BCNT
	SC_NXM,						{  Non-existant memory
	SC_MPAR,					{  Host memory parity
	SC_IVPTE,					{  Invalid page table entry
	SC_IVBFN,					{  Invalid buffer name
	SC_BLENV,					{  Buffer length violation
	SC_ACVIO					{  Access control violation
	) equals 1 increment 1;

    /* Controller Error Subcode Values

    constant (
	SC_DLATE,					{  Date late
	SC_EDCER,					{  EDC error
	SC_DTSTR,					{  Data structure error
	SC_IEDC,					{  Internal EDC error
	SC_LACIN,					{  LESI adapter card input parity
	SC_LACOU,					{  LESI adapter card output parity
	SC_LACCB,					{  LESI adapter card "cable in place" not asserted
	SC_OVRUN,					{  Controller overrun or underrun
	SC_MEMER,					{  Controller memory error
	SC_REMRSRC					{  Insufficient resources
	) equals 1 increment 1;

    /* Bad Block Replacement Subcode Values

    constant (
	SC_BBROK,					{  Bad block replacement successful
	SC_NOTRP,					{  Block tested ok, not replaced
	SC_RPLFL,					{  REPLACE command failure
	SC_ICRCT,					{  Inconsistant RCT
	SC_DRVER					{  Drive error
	) equals 0 increment 1;

  end ALL_SUBCS;

end MSCP_SUBCODES;

/* Definitions for MSCP Transfer Commands

aggregate TRANSFER_COMMANDS structure prefix MSCP$;
    base byte dimension #end_basic_packet fill;

    BYTE_CNT longword unsigned;				/* Byte count
    BUFFER byte unsigned dimension 12;			/* Buffer descriptor
    DISK_TAPE union fill;
	DISK structure fill;
	    LBN structure longword unsigned;		/* Logical block number
		FRST_BAD longword unsigned;		/*   First bad block
	    end LBN;
	end DISK;
	TAPE structure fill;
	    POSITION longword unsigned;			/* Position (object count)
	    TAPEREC longword unsigned;			/* Tape record byte count
	end TAPE;
    end DISK_TAPE;

end TRANSFER_COMMANDS;

/* Definitions for Abort and Get Command Status Commands and End Messages

aggregate ABORT_GTCMD structure prefix MSCP$;
    base byte dimension #end_basic_packet fill;
    OUT_REF longword unsigned;				/* Outstanding reference number
    CMD_STS longword unsigned;				/* Command status
end ABORT_GTCMD;

/* Definitions for the Get Unit Status Command and End Message

aggregate GTUNT structure prefix MSCP$;

    base byte dimension #end_basic_packet fill;
    MULT_UNT word unsigned;				/* Multi-unit code
    UNT_FLGS structure word unsigned;			/* Unit flags
	UF_CMPRD bitfield mask;				/*   Compare reads 
	UF_CMPWR bitfield mask;				/*   Compare writes 
	UF_576 bitfield mask;				/*   576 byte sectors [disks only]
	filler bitfield fill;
	UF_VARSP bitfield mask;				/*   Variable speed unit [tapes only]
	UF_VSMSU bitfield mask;				/*   Variable speed mode suppression [tapes only]
	UF_WBKNV bitfield mask;				/*   Write-back (non-volatile) [disks only]
	UF_RMVBL bitfield mask;				/*   Removeable media [disks only]
	UF_WRTPD bitfield mask;				/*   Write protect (data loss)
	UF_SSMST bitfield mask;				/*   Shadow set master
	UF_SCCHL bitfield mask;				/*   Suppress caching (Low speed) [disks only]
	UF_SCCHH bitfield mask;				/*   Suppress caching (High speed) [disks only]
	UF_WRTPS bitfield mask;				/*   Write protect (software) 
	UF_WRTPH bitfield mask;				/*   Write protect (hardware)
	UF_SSMEM bitfield mask;				/*   Shadow set member
	UF_REPLC bitfield mask;				/*   Controller initiated bad block replacement [disks only]
    end UNT_FLGS;
    reserved longword fill;
    UNIT_ID structure quadword unsigned;		/* Unit identifier
	EXCL_LBA longword unsigned;			/* Excluded LBN area address [disks only]
	EXCL_LBC word unsigned;				/* Excluded LBN block count [disks only]
    end UNIT_ID;
    DEV_PARM_OVERLAY union fill;
	DEV_PARM longword unsigned;			/* Device dependent parameters
	MEDIA_ID structure longword unsigned;		/* Media type identifier
            MTYP_N bitfield length 7 mask;		/*   Media # (i.e. 7 of RK07)
            MTYP_A2 bitfield length 5 mask;		/*   Media name char.
            MTYP_A1 bitfield length 5 mask;		/*   Media name continued
            MTYP_A0 bitfield length 5 mask;		/*     "    "      "
            MTYP_D1 bitfield length 5 mask;		/*   Dev mnemonic char.
            MTYP_D0 bitfield length 5 mask;		/*   Mnemonic continued
	end MEDIA_ID;
    end DEV_PARM_OVERLAY;
    DISK_TAPE_CMD union fill;
	DISK_CMD structure fill;
	    SHDW_UNT word unsigned;			/* Shadow unit
	    SPD_STS union fill;
		COPY_SPD word unsigned;			/* Copy speed
		constant (				{  Copy speeds:
		    CS_NOCPY,				{	no copy
		    CS_COPY,				{	regular copy
		    CS_MGCPY				{	merge copy
		    ) equals 0 increment 1;
		SHDW_STS word unsigned;			/* Shadow unit status
		    COPYIP bitfield mask;		/*  Shadow copy in progress
	    end SPD_STS;
	end DISK_CMD;
	TAPE_CMD structure fill;
	    FORMAT structure word unsigned;		/* Format
		TF_800 bitfield mask;			/*  NRZI 800 bpi
		TF_PE bitfield mask;			/*  Phase encoded 1600 bpi
		TF_GCR bitfield mask;			/*  Group code recording 6250 bpi
	    end FORMAT;
	    SPEED word unsigned;			/* Speed
   	end TAPE_CMD;
    end DISK_TAPE_CMD;
    #onlin_stunt_base = .; {-- marker for beginning of online & set unit characteristics defs.

    {{{{ The longest command ends here. }}}}
    #longest_command = .;

    DISK_TAPE_END union fill;
	DISK_END structure fill;
	    TRACK word unsigned;			/* Track size
	    GROUP word unsigned;			/* Group size
	    CYLINDER word unsigned;			/* Cylinder size
	    UNIT_SVR byte unsigned;			/* Unit software version
	    UNIT_HVR byte unsigned;			/* Unit hardware version
	    RCT_SIZE word unsigned;			/* RCT size
	    RBNS byte unsigned;				/* RBNs per track
	    RCT_CPYS byte unsigned;			/* Number of RCT copies
	end DISK_END;
	TAPE_END structure fill;
	    FORMENU word unsigned;			/*  Format menu
	end TAPE_END;
    end DISK_TAPE_END;

    {{{{ The longest end-message ends here. }}}}
    #longest_end_message = .;

end GTUNT;

/* Definitions for Online and Set Unit Characteristics Command and End Messages

aggregate ONLIN_STUNT structure prefix MSCP$;

    marker byte dimension #onlin_stunt_base fill;
    DISK_TAPE union fill;
	DISK structure fill;
	    UNT_SIZE longword unsigned;			/* Unit size
	    VOL_SER longword unsigned;			/* Volume serial number
	end DISK;
	TAPE structure fill;
	    MAXWTREC longword unsigned;			/* Maximum write record size
	    NOISEREC word unsigned;			/* Noise record
	end TAPE;
    end DISK_TAPE;

end ONLIN_STUNT;

/* Definitions for the Replace Command and End Message (disks only)

aggregate REPLC structure prefix MSCP$;
    base byte dimension #end_basic_packet fill;
    RBN longword unsigned;				/* Replacement block number
end REPLC;

/* Definitions for the Reposition Command and End Message (tapes only)

aggregate REPOS structure prefix MSCP$;
    base byte dimension #end_basic_packet fill;
    CMDEND union fill;
	CMD structure fill;
	    REC_CNT longword unsigned;			/* Record/Object count
	    TMGP_CNT longword unsigned;			/* Tape mark count
	end CMD;
	ENDMSG structure fill;
	    RCSKIPED longword unsigned;			/* Records skipped
	    TMSKIPED longword unsigned;			/* Tape markes skipped
	end ENDMSG;
    end CMDEND;
end REPOS;

/* Definitions for the Set Controller Characteristics Command and End Message

aggregate STCON structure prefix MSCP$;

    filler byte dimension 4 fill;
    CNT_ALCS byte unsigned;				/* Allocation class
    filler byte dimension #end_basic_packet-5 fill;
    VERSION word unsigned;				/* MSCP version
    CNT_FLGS structure word unsigned;			/* Controller flags
	CF_576 bitfield mask;				/*   576 byte sectors [disks only]
	CF_SHADW bitfield mask;				/*   Shadowing [disks only]
	CF_MLTHS bitfield mask;				/*   Multi-Host
	filler bitfield length 1 fill;
	CF_THIS bitfield mask;				/*   Enable this host's error log
	CF_OTHER bitfield mask;				/*   Enable other host's error log
	CF_MISC bitfield mask;				/*   Enable miscellaneous error log
	CF_ATTN bitfield mask;				/*   Enable attention messages
	filler bitfield length 7 fill;
	CF_REPLC bitfield mask;				/*   Controller Initiated Bad Block Replacement [disks only]
    end CNT_FLGS;
    HST_TMO structure word unsigned;			/* Host timeout
	CNT_TMO word unsigned;				/* Controller timeout
    end HST_TMO;
    CNT_SVR byte unsigned;				/* Controller software version
    CNT_HVR byte unsigned;				/* Controller hardware version
    TIME structure quadword unsigned;			/* Quad-word date-time
	CNT_ID quadword unsigned;			/* Controller ID
    end TIME;

    /*  Controller and Unit identifier Classes. (Device Class)
    constant CL_CNTRL equals 1;				/* MSCP Controller
    constant CL_DISK  equals 2;				/* Disk Class Device
    constant CL_TAPE  equals 3;				/* Tape Class Device
    constant CL_D144  equals 4;				/* DEC144 Disk Class Device

    /*  MSCP Controller Model
    constant CM_HSC50 equals 1;				/* HSC50
    constant CM_UDA50 equals 2;				/* UDA50
    constant CM_RC25  equals 3;				/* RC25 (AZTEC)
    constant CM_EMULA equals 4;				/* Emulator 
    constant CM_TU81  equals 5;				/* TU81 
    constant CM_UDA52 equals 6;				/* UDA52 (UDA50A old name)
    constant CM_UDA50A equals 6;			/* UDA50A
    constant CM_RDRX  equals 7;				/* RD/RX
    constant CM_TOPS  equals 8;				/* TOPS 10/20 Emulator
    constant CM_TK50  equals 9;				/* TK50
    constant CM_RUX50 equals 10;			/* RUX50
    constant CM_RC26  equals 11;			/* RC26
    constant CM_AIO   equals 12;			/* AURORA I/O
    constant CM_QDA50 equals 13;			/* QDA50
    constant CM_BDA   equals 14;			/* BDA
    constant CM_BSA   equals 15;			/* BSA
    constant CM_CDR50 equals 16;			/* CDR50
    constant CM_QDA25 equals 17;			/* QDA25

    constant MXCMDLEN equals #longest_command;		/* Longest Command
    constant MXCMDLEN equals #longest_command tag C;	/* Longest Command

    constant LEN equals #longest_end_message;		/* Longest End Message
    constant LEN equals #longest_end_message tag C;	/* Longest End Message

end STCON;

end_module $MSCPDEF;

module $MVLDEF;

/*+
/* MAGNETIC TAPE VOLUME LIST
/* THIS STRUCTURE DESCRIBES THE VOLUMES IN A VOLUME SET
/*-

aggregate MVLDEF structure prefix MVL$;
    VCB longword unsigned;				/*ADDRESS OF VCB 
    FILL_1 longword fill prefix MVLDEF tag $$;		/*SPARE 
    SIZE word unsigned;					/*SIZE OF STRUCTURE 
    TYPE byte unsigned;					/*TYPE OF STRUCTURE 
    NVOLS byte unsigned;				/*NUMBER OF VOLUMES IN VOLUME SET 
    SET_ID character length 6;				/*FILE SET ID FOR THE VOLUME SET 
    VOL_ACC byte unsigned;				/*VOLUME ACCESSIBILTY CHARACTER DEFAULT 
    MOU_PRV_OVERLAY union fill;
        MOU_PRV byte unsigned;				/*USER'S MOUNT TIME PRIVILEGES 
	MOU_PRV_BITS structure fill;
            VOLPRO bitfield;				/*VOLPRO PRIVILEGE 
            OVRPRO bitfield;				/*OVERRIDE PRIVILEGE (BYPASS,SYSPRV,VOLPRO) 
	    OPER bitfield;				/*OPER PRIVILEDGE
	end MOU_PRV_BITS;
        
    end MOU_PRV_OVERLAY;
	VOLOWNER character length 14;			/* VOL1 ONER IDENTIFIER  FIELD
	STDVER byte unsigned;				/* ANSI VERSION OF VOLUME SET
	FILL_2 byte fill prefix MVLDEF tag $$;		/* SPARE
        constant FIXLEN equals . prefix MVL$ tag K;	/*LENGTH OF FIXED AREA OF STRUCTURE 
        constant FIXLEN equals . prefix MVL$ tag C;	/*LENGTH OF FIXED AREA OF STRUCTURE 
end MVLDEF;

/* THE FOLLOWING STRUCTURE IN REPEATED IN MVL FOR EACH REEL IN VOLUME SET

aggregate MVLDEF1 structure prefix MVL$;
    VOLLBL character length 6;				/*VOLUME LABEL 
    RVN byte unsigned;					/*RELATIVE UNIT NUMBER 
    STATUS_OVERLAY union fill;
        STATUS byte unsigned;				/*STATUS OF VOLUME 
        constant "LENGTH" equals . prefix MVL$ tag K;	/*LENGTH OF STRUCTURE 
        constant "LENGTH" equals . prefix MVL$ tag C;	/*LENGTH OF STRUCTURE 
	STATUS_BITS structure fill;
            MOUNTED bitfield;				/*REEL IS MOUNTED 
            UNUSED bitfield;				/*IS THIS ENTRY IN USE 
            OVERIDE bitfield;				/*CAN OVERRIDE PROTECTION ON THIS REEL 
	end STATUS_BITS;
    end STATUS_OVERLAY;
end MVLDEF1;

end_module $MVLDEF;


module $MVMSLDEF;

/*++
/*  $MVMSLDEF - mount verification messages list structure definition
/*
/*	The MVMSL provides a mechanism for communicating information about 
/*	mount verification messages to device driver special mount 
/*	verification processing routines.
/*--
aggregate MVMSLDEF structure prefix MVMSL$ origin MSG_CODE;

    MAXIDX byte unsigned;			/* Maximum legal MVMSL index.
    SNDMSGOFF longword;				/* Offset from MVMSL base to SEND_MESSAGE routine
    MSG_CODE word unsigned;			/* The MSG$_ code for this entry.
    FLAGS structure word unsigned;		/* Processing flags:
	NOSUFFIX bitfield mask;			/*	Do not add suffix.
	SUPRESS bitfield mask;			/*	May be suppressed.
    end FLAGS;
    TEXTOFF longword;				/* Offset from MVMSL base to ASCIC message text.
    constant "LENGTH" equals .;			/* Length of a MVMSL entry.

end MVMSLDEF;

end_module $MVMSLDEF;

module $NBIADEF;

aggregate NBIADEF structure prefix NBIA$;

/**
/*	Nautilus NBIA register definitions
/*
/* The NBIA sits in an NMI nexus and can connect one or two BIs to a Nautilus.
/**

    CSR0_OVERLAY union fill;
	CSR0 longword unsigned;			/* Control and Status
	CSR0_FIELD_OVERLAY union fill;
	    NAC byte unsigned;			/* Adapter Type Field
	    CSR0_BITS structure fill;
		FILL_0 bitfield length 8 fill prefix NBIADEF tag $$;
		BI0PU bitfield mask;		/* BI0 Power Up
		NBIVO bitfield length 6;	/* Vector Offset Register
		NPE bitfield mask;		/* NBI Parity Error
		BILP bitfield mask;		/* BIIC Loopback
		FNPE bitfield mask;		/* Force NBI Parity error
		FDB  bitfield mask;		/* Force DMA busy
		FLIP_29_22 bitfield mask;	/* Maintenance Magic
		FILL_1 bitfield length 1 fill prefix NBIADEF tag $$;
		NIE bitfield mask;		/* NBI Interrupt Enable
		FILL_2 bitfield length 2 fill prefix NBIADEF tag $$;
		TOI  bitfield length 3;		/* Time-out Interrupt
		TDF  bitfield mask;		/* Transmitter During Fault
		WDSF bitfield mask;		/* Write Data Sequence Fault
		RDSF bitfield mask;		/* Read Data Sequence Fault
		CPF  bitfield mask;		/* Control Parity Fault
		DPF  bitfield mask;		/* Data Parity Fault
	    end CSR0_BITS;
	end CSR0_FIELD_OVERLAY;
    end CSR0_OVERLAY;

    CSR1_OVERLAY union fill;
	CSR1 longword unsigned;			/* NBIA CSR1
	CSR1_BITS structure fill;
	    ADIN bitfield mask;			/* Adaptor Init
	    BI0P bitfield mask;			/* BI0 Present
	    BI1P bitfield mask;			/* BI1 Present
	    BI0_PE bitfield mask;		/* BI0 Parity Error
	    BI1_PE bitfield mask;		/* BI1 Parity Error
	    FILL_3 bitfield length 3 fill prefix NBIADEF tag $$;
	    BI1PU bitfield mask;		/* BI1 Power Up
	    NAWR  bitfield mask;		/* NBIA Wraparound (Maint Magic)
	    FBPE  bitfield mask;		/* Force NBIB Parity Error
	    FILL_4 bitfield length 21 fill prefix NBIADEF tag $$;
	end CSR1_BITS;
    end CSR1_OVERLAY;	

    BI0I longword unsigned;			/* BI0 Stop Register

    BI1I longword unsigned;			/* BI1 Stop Register

    BR4VR longword unsigned;			/* BR4 Vector Register

    BR5VR longword unsigned;			/* BR5 Vector Register

    BR6VR longword unsigned;			/* BR6 Vector Register

    BR7VR longword unsigned;			/* BR7 Vector Register

end NBIADEF;

end_module $NBIADEF;

module $NAFDEF;

/*++
/*
/* Structure for network proxy login file, NETUAF.DAT
/*
/*--


aggregate NAFDEF structure prefix NAF$;
    REMNAME structure character length 64;	/* Combined nodename and remote username 
        NODE character length 32;		/* Node name 
        REMUSER character length 32;		/* Remote username 
    end REMNAME;
    LOCALUSER character length 32;		/* Local username 
    FLAGS structure longword;			/* Flags longword
	TASK bitfield mask;			/* Allow task=0 access
	BATCH bitfield mask;			/* Allow batch jobs
	INTERACTIVE bitfield mask;		/* Allow interactive login
    end FLAGS;
    constant "LENGTH" equals . tag K;		/* Length of record 
    constant "LENGTH" equals . tag C;		/* Length of record 
end NAFDEF;

end_module $NAFDEF;

module $NDTDEF;


/*+
/* NEXUS DEVICE AND ADAPTER TYPE CODES
/*-


	 						/*DEFINE CONSTANT TYPE CODES 
constant MEM4NI	equals 8  prefix NDT tag $;		/*MEMORY, 4K NOT INTERLEAVED 
constant MEM4I	equals 9  prefix NDT tag $;		/*MEMORY, 4K INTERLEAVED 
constant MEM16NI	equals +%X10  prefix NDT tag $;	/*MEMORY, 16K NOT INTERLEAVED 
constant MEM16I	equals +%X11  prefix NDT tag $;		/*MEMORY, 16K INTERLEAVED 
constant MEM1664NI	equals +%X12  prefix NDT tag $; /*MEMORY, 16K AND 64K MIXED
constant MB	equals +%X20  prefix NDT tag $;		/*MBA 0,1,2, OR 3 
constant UB0	equals +%X28  prefix NDT tag $;		/*UB ADAPTER OR INTERCONNECT 0, 
constant UB1	equals +%X29  prefix NDT tag $;		/* 1, 
constant UB2	equals +%X2A  prefix NDT tag $;		/* 2, 
constant UB3	equals +%X2B  prefix NDT tag $;		/* OR 3 
constant CI	equals +%X38  prefix NDT tag $;		/*CI780'S, CI750'S 
constant MPM0	equals +%X40  prefix NDT tag $;		/*MULTIPORT MEMORY 0, 
constant MPM1	equals +%X41  prefix NDT tag $;		/* 1, 
constant MPM2	equals +%X42  prefix NDT tag $;		/* 2, 
constant MPM3	equals +%X43  prefix NDT tag $;		/* OR 3 
constant DR32	equals +%X30  prefix NDT tag $;		/*DR32 0,1,2,... 
constant MEM64NIL	equals +%X68  prefix NDT tag $;	/*64K NON-INTERLEAVED MEM, LOWER CONTROLLER 
constant MEM64EIL	equals +%X69  prefix NDT tag $;	/*64K EXTERNALLY INTERLEAVED MEM, LOWER 
constant MEM64NIU	equals +%X6A  prefix NDT tag $;	/*64K NON-INTERLEAVED MEM, UPPER CONTROLLER 
constant MEM64EIU	equals +%X6B  prefix NDT tag $;	/*64K EXTERNALLY INTERLEAVED MEM, UPPER 
constant MEM64I	equals +%X6C  prefix NDT tag $;		/*64K INTERNALLY INTERLEAVED MEMORY 
constant MEM256NIL	equals +%X70  prefix NDT tag $;	/*256K NON-INTERLEAVED MEM, LOWER CONTROLLER 
constant MEM256EIL	equals +%X71  prefix NDT tag $;	/*256K EXTERNALLY INTERLEAVED MEM, LOWER 
constant MEM256NIU	equals +%X72  prefix NDT tag $;	/*256K NON-INTERLEAVED MEM, UPPER CONTROLLER 
constant MEM256EIU	equals +%X73  prefix NDT tag $;	/*256K EXTERNALLY INTERLEAVED MEM, UPPER 
constant MEM256I	equals +%X74  prefix NDT tag $;	/*256K INTERNALLY INTERLEAVED MEMORY 

/* BI node device types.  Note low word is hardware device type on BI.
/*  High order word (i.e. the 8000) distinguishes device as a BI device.

/* First BI memory nodes

constant SCORMEM equals +%X80000001  prefix NDT tag $;	/* Scorpio Memory

/* Then other BI devices

constant BIMFA	 equals +%X80000101  prefix NDT tag $;	/* BI Multi-Function Adapter
constant BUA	 equals +%X80000102  prefix NDT tag $;	/* BI UNIBUS adapter
constant BSA	 equals +%X80000104  prefix NDT tag $;	/* BI-SI Adapter
constant KDZ11	 equals +%X80000105  prefix NDT tag $;	/* KDZ11 processor
constant NBA	 equals +%X80000106  prefix NDT tag $;	/* BI-NMI Adapter
constant BNA	 equals +%X80000107  prefix NDT tag $;	/* BI-NI Adapter
constant BCA	 equals +%X80000108  prefix NDT tag $;	/* BI-CI Adapter
constant BICOMBO equals +%X80000109  prefix NDT tag $;	/* BI Combo Board
constant BAA	 equals +%X8000010A  prefix NDT tag $;	/* BI-VenusAbus Adapter
constant BCI750	 equals +%X8000010B  prefix NDT tag $;	/* Interim BI-CI Adapter
constant BIACP	 equals +%X8000010C  prefix NDT tag $;	/* Aurora Processor Module
constant AIO	 equals +%X8000010D  prefix NDT tag $;	/* Aurora I/O Module
constant BDA	 equals +%X8000010E  prefix NDT tag $;	/* BI-to-Disk Adapter
constant AIE	 equals +%X8000010F  prefix NDT tag $;	/* Aurora I/O Extension Module


end_module $NDTDEF;


module $NMBDEF;
/*+
/*
/* FORMAT OF THE FILE NAME BLOCK. THE FILE NAME BLOCK IS USED AS AN INTERNAL
/* INTERFACE TO THE DIRECTORY SCAN ROUTINE, AND IS ALSO THE FORMAT OF A
/* DIRECTORY RECORD.
/*
/*-



aggregate NMBDEF structure prefix NMB$;
    FID_OVERLAY union fill;
        FID word unsigned dimension 3;			/* FILE ID 
	FID_FIELDS structure fill;
            FID_NUM word unsigned;			/* FID - FILE NUMBER 
            FID_SEQ word unsigned;			/* FID - FILE SEQUENCE NUMBER 
            FID_RVN word unsigned;			/* FID - RELATIVE VOLUME NUMBER 
	end FID_FIELDS;
    end FID_OVERLAY;
    NAME word unsigned dimension 3;			/* FILE NAME (RAD-50) 
    TYPE word unsigned;					/* FILE TYPE (RAD-50) 
    VERSION word;					/* VERSION NUMBER 
    constant DIRENTRY equals . prefix NMB$ tag K;	/* LENGTH OF DIRECTORY ENTRY 
    constant DIRENTRY equals . prefix NMB$ tag C;	/* LENGTH OF DIRECTORY ENTRY 
    
    FLAGS_OVERLAY union fill;
        FLAGS word unsigned;				/* NAME STATUS FLAGS 
	FLAGS_BITS structure fill;
            FILL_1 bitfield length 3 fill prefix NMBDEF tag $$;
            ALLVER bitfield mask;			/* MATCH ALL VERSIONS 
            ALLTYP bitfield mask;			/* MATCH ALL TYPES 
            ALLNAM bitfield mask;			/* MATCH ALL NAMES 
            FILL_2 bitfield length 2 fill prefix NMBDEF tag $$;
            WILD bitfield mask;				/* WILD CARDS IN FILE NAME 
            NEWVER bitfield mask;			/* MAXIMIZE VERSION NUMBER 
            SUPERSEDE bitfield mask;			/* SUPERSEDE EXISTING FILE 
            FINDFID bitfield mask;			/* SEARCH FOR FILE ID 
            FILL_3 bitfield length 2 fill prefix NMBDEF tag $$;
            LOWVER bitfield mask;			/* LOWER VERSION OF FILE EXISTS 
            HIGHVER bitfield mask;			/* HIGHER VERSION OF FILE EXISTS 
	end FLAGS_BITS;
    end FLAGS_OVERLAY;
    ASCNAME structure fill;
	ASCNAMSIZ byte unsigned;
	ASCNAMTXT character dimension 19;
    end ASCNAME;
    CONTEXT word unsigned;				/* START POINT FOR NEXT FIND 
    constant "LENGTH" equals . prefix NMB$ tag K;	/* LENGTH OF NAME BLOCK 
    constant "LENGTH" equals . prefix NMB$ tag C;	/* LENGTH OF NAME BLOCK 
end NMBDEF;

end_module $NMBDEF;


module $NSAARGDEF;

/*+
/* Security Auditing argument list definitions
/*-

/*+
/* Argument list header offset definitions
/*-

aggregate NSAARGHDRDEF structure prefix NSA$;

    ARG_COUNT longword unsigned;		/* Argument list count
    ARG_ID_OVERLAY union fill;
	ARG_ID longword unsigned;		/* Record identification longword
	ARG_ID_FIELDS structure fill;
	    ARG_TYPE word unsigned;		/* Record type
	    ARG_SUBTYPE word unsigned;		/* Record subtype
	end ARG_ID_FIELDS;
    end ARG_ID_OVERLAY;
    ARG_FLAG_OVERLAY union fill;
	ARG_FLAG byte unsigned;			/* Flags byte
	FLAG_BITS structure fill;
	    ARG_FLAG_ALARM bitfield mask;	/* Generate alarm for this record
	    ARG_FLAG_JOURN bitfield mask;	/* Journal this record
	    ARG_FLAG_MANDY bitfield mask;	/* Mandatory auditing
	end FLAG_BITS;
    end ARG_FLAG_OVERLAY;
    ARG_PKTNUM byte unsigned;			/* Number of packets
    ARG_SPARE character length 2;		/* Spare bytes
    ARG_LIST character length 0;

    constant ARGHDR_LENGTH equals . tag C;
    constant ARGHDR_LENGTH equals . tag K;

end NSAARGHDRDEF;


/*+
/* Data packet argument passing mechanism definitions
/*-

constant (ARG_MECH_BYTE,		/* Byte value
	  ARG_MECH_WORD,		/* Word value
	  ARG_MECH_LONG,		/* Longword value
	  ARG_MECH_QUAD,		/* Quadword value
	  ARG_MECH_DESCR,		/* Descriptor
	  ARG_MECH_ADESCR)		/* Address of descriptor
	 equals 0 increment 1 counter #MECHNUM prefix NSA$;

constant ARG_MECHNUM equals #MECHNUM+1 prefix NSA$;


/*+
/* Argument list definitions
/*-

/* File access

aggregate NSAARG1DEF structure prefix NSA$;

    $$ character length NSA$K_ARGHDR_LENGTH fill; /* Argument list header
    ARG1_FACMOD_TM longword unsigned;		/* FACMOD type and mechanism 
    ARG1_FACMOD longword unsigned;		/* File access mode
    ARG1_FILNAM_TM longword unsigned;		/* FILNAM type and mechanism
    ARG1_FILNAM_SIZ longword unsigned;		/* File name size
    ARG1_FILNAM_PTR longword unsigned;		/* File name address
    ARG1_IMGNAM_TM longword unsigned;		/* IMGNAM type and mechanism
    ARG1_IMGNAM quadword unsigned;		/* Image name
    ARG1_PRIVUSED_TM longword unsigned;		/* PRIVUSED type and mechanism
    ARG1_PRIVUSED longword unsigned;		/* Privileges used for access

    constant ARG1_LENGTH equals . tag C;
    constant ARG1_LENGTH equals . tag K;

end NSAARG1DEF;


/* Volume mount

aggregate NSAARG2DEF structure prefix NSA$;

    $$ character length NSA$K_ARGHDR_LENGTH fill; /* Argument list header
    ARG2_UIC_TM longword unsigned;		/* UIC type and mechanism 
    ARG2_UIC longword unsigned;			/* Volume UIC
    ARG2_VOLPRO_TM longword unsigned;		/* VOLPRO type and mechanism
    ARG2_VOLPRO longword unsigned;		/* Volume protection 
    ARG2_MOUFLG_TM longword unsigned;		/* MOUFLG type and mechanism
    ARG2_MOUFLG longword unsigned;		/* Mount flags
    ARG2_IMGNAM_TM longword unsigned;		/* IMGNAM type and mechanism
    ARG2_IMGNAM quadword unsigned;		/* Image name
    ARG2_DEVNAM_TM longword unsigned;		/* DEVNAM type and mechanism
    ARG2_DEVNAM_SIZ longword unsigned;		/* Device name size
    ARG2_DEVNAM_PTR longword unsigned;		/* Device name address
    ARG2_LOGNAM_TM longword unsigned;		/* LOGNAM type and mechanism
    ARG2_LOGNAM_SIZ longword unsigned;		/* Logical name size
    ARG2_LOGNAM_PTR longword unsigned;		/* Logical name address
    ARG2_VOLNAM_TM longword unsigned;		/* VOLNAM type and mechanism
    ARG2_VOLNAM_SIZ longword unsigned;		/* Volume name size
    ARG2_VOLNAM_PTR longword unsigned;		/* Volume name address
    ARG2_VOLSNAM_TM longword unsigned;		/* VOLSNAM type and mechanism
    ARG2_VOLSNAM_SIZ longword unsigned;		/* Volume set name size
    ARG2_VOLSNAM_PTR longword unsigned;		/* Volume set name address

    constant ARG2_LENGTH equals . tag C;
    constant ARG2_LENGTH equals . tag K;

end NSAARG2DEF;


/* Volume dismount

aggregate NSAARG3DEF structure prefix NSA$;

    $$ character length NSA$K_ARGHDR_LENGTH fill; /* Argument list header
    ARG3_DMOUFLG_TM longword unsigned;		/* DMOUFLG type and mechanism
    ARG3_DMOUFLG longword unsigned;		/* Dismount flags
    ARG3_IMGNAM_TM longword unsigned;		/* IMGNAM type and mechanism
    ARG3_IMGNAM quadword unsigned;		/* Image name
    ARG3_DEVNAM_TM longword unsigned;		/* DEVNAM type and mechanism
    ARG3_DEVNAM_SIZ longword unsigned;		/* Device name size
    ARG3_DEVNAM_PTR longword unsigned;		/* Device name address
    ARG3_LOGNAM_TM longword unsigned;		/* LOGNAM type and mechanism
    ARG3_LOGNAM_SIZ longword unsigned;		/* Logical name size
    ARG3_LOGNAM_PTR longword unsigned;		/* Logical name address
    ARG3_VOLNAM_TM longword unsigned;		/* VOLNAM type and mechanism
    ARG3_VOLNAM_SIZ longword unsigned;		/* Volume name size
    ARG3_VOLNAM_PTR longword unsigned;		/* Volume name address
    ARG3_VOLSNAM_TM longword unsigned;		/* VOLSNAM type and mechanism
    ARG3_VOLSNAM_SIZ longword unsigned;		/* Volume set name size
    ARG3_VOLSNAM_PTR longword unsigned;		/* Volume set name address

    constant ARG3_LENGTH equals . tag C;
    constant ARG3_LENGTH equals . tag K;

end NSAARG3DEF;

end_module $NSAARGDEF;

module $NSAEVTDEF;

/*+
/* Security Auditing event class bit definitions: This macro defines
/* the bits which are used to enable audit journaling and alarms for
/* each class of system event.
/*-

aggregate NSAEVTDEF structure prefix NSA$;

    EVT_SYS_OVERLAY union fill;
	EVT_SYS longword unsigned;	/* Misc system event mask
	EVT_SYS_BITS structure fill;
	    EVT_ACL bitfield mask;	/* ACL requested audits
	    EVT_MOUNT bitfield mask;	/* MOUNT and DISMOUNT requests
					/* Modifications made to the system
	    EVT_UAF bitfield mask;	/* or network authorization files
	    EVT_SPARE bitfield length 32-^ mask;
	end EVT_SYS_BITS;
    end EVT_SYS_OVERLAY;

    EVT_LOGB byte unsigned;		/* Breakin detection event mask
    EVT_LOGI byte unsigned;		/* Login  event mask
    EVT_LOGF byte unsigned;		/* Login failure event mask
    EVT_LOGO byte unsigned;		/* Logout event mask
/*****************************************************************************
/* The following file access masks must be contiguous and in the current order
/*****************************************************************************
    EVT_FAILURE longword unsigned; 	/* Access failures event mask
    EVT_SUCCESS longword unsigned; 	/* Successful access event mask
    EVT_SYSPRV longword unsigned; 	/* Success due to SYSPRV event mask
    EVT_BYPASS longword unsigned; 	/* Success due to BYPASS event mask
    EVT_UPGRADE longword unsigned;	/* Success due to UPGRADE event mask
    EVT_DOWNGRADE longword unsigned;	/* Success due to DOWNGRADE event mask
    EVT_GRPPRV longword unsigned; 	/* Success due to GRPPRV event mask
    EVT_READALL longword unsigned; 	/* Success due to READALL event mask
/*****************************************************************************
/* End of file access masks
/*****************************************************************************

    constant EVT_LENGTH equals . tag C;
    constant EVT_LENGTH equals . tag K;

end NSAEVTDEF;

aggregate NSAEVTLOGBITS structure prefix NSA$;
    EVT_LOG_BAT bitfield mask;		/* Batch
    EVT_LOG_DIA bitfield mask;		/* Dialup
    EVT_LOG_LOC bitfield mask;		/* Local
    EVT_LOG_REM bitfield mask;		/* Remote
    EVT_LOG_NET bitfield mask;		/* Network
    EVT_LOG_SUB bitfield mask;		/* Subprocess
    EVT_LOG_DET bitfield mask;		/* Detached process
end NSAEVTLOGBITS;

end_module $NSAEVTDEF;


module $NSAIDTDEF;

/*+
/* Security Auditing Impure Data Table offset definitions
/*-

aggregate NSAIDTDEF structure prefix NSA$;

    IDT_ALARM_HDR character length 38+8;	/* Alarm header buffer
    IDT_RECORD_BUF character length 1024;	/* Record buffer
    IDT_RECORD_DESCR quadword unsigned;		/* Record buffer descriptor
    IDT_RECORD_DT character length 128;		/* Record descriptor table
    IDT_AUDIT_CHAN longword unsigned;		/* Audit journal channel number

    constant IDT_LENGTH equals . tag C;
    constant IDT_LENGTH equals . tag K;

    constant IDT_PAGES equals (.+511)@-9;	/* Number of pages for IDT

end NSAIDTDEF;

end_module $NSAIDTDEF;


module $ORBDEF;
/*+
/*
/* Object's Rights Block - structure defining the protection information
/* for various objects within the system.
/*
/*-

aggregate ORBDEF structure prefix ORB$;
    OWNER structure longword unsigned;		/* Object's owner
	UICMEMBER word unsigned;		/* Member number
	UICGROUP word unsigned;			/* Group number
    end OWNER;
    ACL_MUTEX longword unsigned;		/* Mutex for this ACL
    SIZE word unsigned;				/* Size of the ORB in bytes
    TYPE byte unsigned;				/* Structure type
    FLAGS structure byte unsigned;		/* Field modifiers
	PROT_16 bitfield mask;			/* Use word not vector protection
	ACL_QUEUE bitfield mask;		/* Use ACL queue not descriptor list
	MODE_VECTOR bitfield mask;		/* Use vector not byte mode protection
	NOACL bitfield mask;			/* Object cannot have an ACL
	CLASS_PROT bitfield mask;		/* Security classification is valid
    end FLAGS;
    FILL_1 word fill;				/* Unused
    REFCOUNT word unsigned;			/* Reference count
    MODE_OVERLAY union fill;
	MODE_PROT structure quadword unsigned;	/* Mode protection vector
	    MODE_PROTL longword unsigned;	/* Low longword of vector
	    MODE_PROTH longword unsigned;	/* High longword of vector
	end MODE_PROT;
	MODE byte unsigned;			/* Simple access mode
    end MODE_OVERLAY;
    SYS_PROT_OVERLAY union fill;
	SYS_PROT longword unsigned;		/* System protection field
	PROT word unsigned;			/* Standard SOGW protection
    end SYS_PROT_OVERLAY;
    OWN_PROT longword unsigned;			/* Owner protection field
    GRP_PROT longword unsigned;			/* Group protection field
    WOR_PROT longword unsigned;			/* World protection field
    ACL_1_OVERLAY union fill;
	ACLFL longword unsigned;		/* ACL queue forward link
	ACL_COUNT longword unsigned;		/* Count of ACL segments
    end ACL_1_OVERLAY;
    ACL_2_OVERLAY union fill;
	ACLBL longword unsigned;		/* ACL queue backward link
	ACL_DESC longword unsigned;		/* Address of ACL segment descriptor list
    end ACL_2_OVERLAY;
    MIN_CLASS structure;
	FILL_2 byte dimension 20 fill;		/* Minimum classification mask
    end MIN_CLASS;
    MAX_CLASS structure;
	FILL_3 byte dimension 20 fill;		/* Maximum classification mask
    end MAX_CLASS;
    constant "LENGTH" equals . prefix ORB$ tag K;	/* Structure length
    constant "LENGTH" equals . prefix ORB$ tag C;	/* Structure length
end ORBDEF;

end_module $ORBDEF;

module $PBDEF;
/*+
/* PB - SCS PATH BLOCK
/*
/* THE PB HAS INFORMATION ABOUT THE PHYSICAL PATH TO ANOTHER
/* SYSTEM IN A CLUSTER.  PATH BLOCKS TO THE SAME SYSTEM ARE
/* LINKED TOGETHER TO THE SYSTEM BLOCK (SB).
/*-



aggregate PBDEF structure prefix PB$;
    FLINK longword unsigned;				/*FWD LINK TO NEXT PB 
    BLINK longword unsigned;				/*BACK LINK TO PREVIOUS PB 
    SIZE word unsigned;					/*STRUCTURE SIZE IN BYTES 
    TYPE byte unsigned;					/*SCS STRUCTURE TYPE 
    SUBTYP byte unsigned;				/*SCS STRUCT SUBTYPE FOR PB 
    RSTATION byte unsigned dimension 6;			/*REMOTE STATION ADDRESS 
    STATE word unsigned;				/*PATH STATE 
                                            		/*STATE DEFINITIONS:
    	 						/* 0 ORIGIN, INCREMENTS OF 1 
    constant(
          CLOSED					/* NEWLY CREATED PATHBLOCK 
        , ST_SENT					/* START SENT 
        , ST_REC					/* START RECEIVED 
        , OPEN						/* OPEN PORT-PORT VIRTUAL CIRCUIT 
        ) equals 0 increment 1  prefix PB tag $C;	/* 
    constant VC_FAIL	equals (%X8000)  prefix PB tag $C;/* VC FAILURE IN PROGRESS STATE 
    constant PWR_FAIL	equals (%X4000)  prefix PB tag $C;/* PWR FAIL RECOVERY IN PROGRESS STATE 
    RPORT_TYP_OVERLAY union fill;
        RPORT_TYP longword unsigned;			/*HARDWARE PORT TYPE CODE 
	RPORT_TYP_BITS structure fill;
            PORT_TYP bitfield length 31;		/* HARDWARE PORT TYPE, 
            DUALPATH bitfield mask;			/* 0/1 FOR SINGLE PATH/DUAL PATH PORT 
	end RPORT_TYP_BITS;
    end RPORT_TYP_OVERLAY;
    constant CI780	equals 2	prefix PB tag $C;/* CI780 PORT
    constant CI750	equals 2	prefix PB tag $C;/* CI750 PORT (=CI780)
    constant HSC	equals 4	prefix PB tag $C;/* HSC PORT
    constant KL10	equals 6	prefix PB tag $C;/* KLIPA PORT
    constant CINT	equals 7	prefix PB tag $C;/* CI NODE TESTER
    constant NI		equals 8	prefix PB tag $C;/* NI-DEUNA PORT
    constant PS		equals 9	prefix PB tag $C;/* PASSTHRU PORT

    RPORT_REV longword unsigned;			/*REMOTE PORT HW REV LEVEL 
    RPORT_FCN longword unsigned;			/*REMOTE PORT FUNCTION MASK 
    RST_PORT byte unsigned;				/*OWNING PORT WHICH RESET REMOTE PORT 
    RSTATE_OVERLAY union fill;
        RSTATE byte unsigned;				/*REMOTE PORT STATUS: 
	RSTATE_BITS structure fill;
            MAINT bitfield mask;			/* 0/1 FOR MAINTENANCE MODE NO/YES 
            STATE bitfield length 2;			/* REMOTE PORT STATE: 
	end RSTATE_BITS;
        	 					/* DEFINE REMOTE STATES, 0 ORIGIN 
        constant(
              UNINIT					/* UNINITIALIZED, 
            , DISAB					/* DISABLED 
            , ENAB					/* ENABLED 
            ) equals 0 increment 1  prefix PB tag $C;	/* 
    end RSTATE_OVERLAY;
    RETRY word unsigned;				/*START HANDSHAKE RETRY COUNT 
    LPORT_NAME character length 4;			/*LOCAL PORT DEVICE NAME 
    CBL_STS_OVERLAY union fill;
        CBL_STS byte unsigned;				/*CABLE STATUS TO THE REMOTE 
	CBL_STS_BITS structure fill;
            CUR_CBL bitfield mask;			/* 1/0 FOR CURRENT STATUS OK/BAD 
	end CBL_STS_BITS;
    end CBL_STS_OVERLAY;
    P0_STS byte unsigned;				/*PATH 0 STATUS 
    P1_STS_OVERLAY union fill;
        P1_STS byte unsigned;				/*PATH 1 STATUS 
	P1_STS_BITS structure fill;
            CUR_PS bitfield mask;			/* 1/0 FOR CURRENT STATUS OK/BROKEN 
	end P1_STS_BITS;
    end P1_STS_OVERLAY;
    FILL_1 byte fill prefix PBDEF tag $$;		/*RESERVED BYTE 
    PDT longword unsigned;				/*ADDR OF PORT DESCRIPTOR TABLE FOR 
                                            		/* LOCAL PORT
    SBLINK longword unsigned;				/*LINK TO SYSTEM BLOCK
    CDTLST longword unsigned;				/*LINK TO FIRST CDT OVER THIS PATH 
                                            		/* (0 IF NO CDT'S)
    WAITQFL longword unsigned;				/* SCS SEND MSG WAIT QUEUE FLINK
    WAITQBL_OVERLAY union fill;
        WAITQBL longword unsigned;			/*SCS SEND MSG WAIT QUEUE BLINK 
        DUETIME longword unsigned;			/*START HANDSHAKE TIMER 
    end WAITQBL_OVERLAY;
    SCSMSG longword unsigned;				/*ADDR OF SCS MESSAGE BUFFER 
    STS_OVERLAY union fill;
        STS word unsigned;				/*PATH BLOCK STATUS 
	STS_BITS structure fill;
            TIM bitfield mask;				/* HANDSHAKE TIMEOUT IN PROGRESS 
	end STS_BITS;
    end STS_OVERLAY;
    VCFAIL_RSN word unsigned;				/*VC FAILURE REASON (VMS
							/*STATUS CODE
    PROTOCOL byte unsigned;				/*PPD PROTOCOL LEVEL
    FILL_2 byte dimension 3 fill prefix PBDEF tag $$;	/*RESERVED BYTES
    FILL_3 longword dimension 2 fill prefix PBDEF tag $$;/*RESERVED LONGWDS
    constant "LENGTH" equals . prefix PB$ tag K;	/*LENGTH OF A PATH BLOCK 
    constant "LENGTH" equals . prefix PB$ tag C;	/*LENGTH OF A PATH BLOCK 
    
end PBDEF;

end_module $PBDEF;


module $PBHDEF;
/*+
/* DEFINE PERFORMANCE BUFFER HEADER
/*-



aggregate PBHDEF structure prefix PBH$;
    BUFRFL longword unsigned;				/*BUFFER FORWARD LINK 
    BUFRBL longword unsigned;				/*BUFFER BACKWARD LINK 
    SIZE word unsigned;					/*SIZE OF PERFORMANCE DATA BUFFER 
    TYPE byte unsigned;					/*DATA STRUCTURE TYPE 
    MSGCNT word unsigned;				/*COUNT OF MESSAGES IN BUFFER 
    constant START equals . prefix PBH$ tag K;		/*START OF DATA AREA 
    constant START equals . prefix PBH$ tag C;		/*START OF DATA AREA 
    FILL_1 byte dimension 499 fill prefix PBHDEF tag $$;/*DATA AREA 
    constant "LENGTH" equals . prefix PBH$ tag K;	/*LENGTH OF PERFORMANCE DATA BUFFER 
    constant "LENGTH" equals . prefix PBH$ tag C;	/*LENGTH OF PERFORMANCE DATA BUFFER 
    
end PBHDEF;

end_module $PBHDEF;


module $PBODEF;
/*+
/* PBO - SCS$CONFIG_PTH CALL OUTPUT ARRAY FORMAT
/*
/* THE OUTPUT ARRAY RETURNED FROM THE SCS$CONFIG_PTH CALL.  DATA IS MOSTLY COPIED
/* FROM THE PATH BLOCK (PB) BEING LOOKED UP.
/*-


aggregate PBODEF structure prefix PBO$;
    RSTATION byte unsigned dimension 6;			/*REMOTE STATION ADDR
    STATE word unsigned;				/*PATH STATE
    RPORT_TYP longword unsigned;			/*REMOTE PORT HW PORT TYPE
    RPORT_REV longword unsigned;			/*REMOTE PORT REV LEVEL
    RPORT_FCN longword unsigned;			/*REMOTE PORT FUNCTION MASK
    RST_PORT byte unsigned;				/*OWNING PORT WHICH LAST
							/* RESET THIS REMOTE
    RSTATE byte unsigned;				/*REMOTE PORT STATE
    RETRY word unsigned;				/*START HANDSHAKE RETRIES LEFT
    LPORT_NAME character length 4;			/*LOCAL PORT DEVICE NAME
    CBL_STS byte unsigned;				/*CURRENT CABLE STATUS
    P0_STS byte unsigned;				/*PATH 0 STATUS
    P1_STS byte unsigned;				/*PATH 1 STATUS
    FILL_1 byte fill prefix PBODEF tag $$;		/*RESERVED BYTE
    constant NXT_VC equals . prefix PBO$ tag C;		/*SPECIFIER OF NEXT VC (PB)
    constant NXT_VC equals . prefix PBO$ tag K;		/* TO THIS SYSTEM (12 BYTE
							/* SPECIFIER FOLLOWS:)
    NXT_RSTAT byte unsigned dimension 6;		/* REMOTE STATION ADDR
    FILL_1 word fill prefix PBODEF tag $$;		/* RESERVED WORD
    NXT_LPORT character length 4;			/* LOCAL PORT NAME ON NXT PB
    SYSTEMID byte unsigned dimension 6;			/*ID OF SYSTEM ASSOC WITH 
							/* THIS PB
    FILL_1 word fill prefix PBODEF tag $$;		/*RESERVED WORD
    constant "LENGTH" equals . prefix PBO$ tag C;	/*LENGTH OF PBO
    constant "LENGTH" equals . prefix PBO$ tag K;	/*LENGTH OF PBO

end PBODEF;

end_module $PBODEF;


module $PCBDEF;
/*+
/* PCB DEFINITIONS
/*-


aggregate PCBDEF structure prefix PCB$;
    SQFL longword unsigned;				/*STATE QUEUE FORWARD LINK 
    SQBL longword unsigned;				/*STATE QUEUE BACKWARD LINK 
    SIZE word unsigned;					/*SIZE IN BYTES 
    TYPE byte unsigned;					/*STRUCTURE TYPE CODE FOR PCB 
    PRI byte unsigned;					/*PROCESS CURRENT PRIORITY 
    ASTACT byte unsigned;				/*ACCESS MODES WITH ACTIVE ASTS 
    ASTEN byte unsigned;				/*ACCESS MODES WITH ASTS ENABLED 
    MTXCNT word unsigned;				/*COUNT OF MUTEX SEMAPHORES OWNED 
    ASTQFL longword unsigned;				/*AST QUEUE FORWARD LINK(HEAD) 
    ASTQBL longword unsigned;				/*AST QUEUE BACK LINK(TAIL) 
    PHYPCB longword unsigned;				/*PHYSICAL ADDRESS OF HW PCB 
    OWNER longword unsigned;				/*PID OF CREATOR 
    WSSWP longword unsigned;				/*SWAP FILE DISK ADDRESS 
    STS structure longword unsigned;			/*PROCESS STATUS FLAGS 
        RES bitfield mask;				/* RESIDENT, IN BALANCE SET 
        DELPEN bitfield mask;				/* DELETE PENDING 
        FORCPEN bitfield mask;				/* FORCE EXIT PENDING 
        INQUAN bitfield mask;				/* INITIAL QUANTUM IN PROGRESS 
        PSWAPM bitfield mask;				/* PROCESS SWAP MODE (1=NOSWAP) 
        RESPEN bitfield mask;				/* RESUME PENDING, SKIP SUSPEND 
        SSFEXC bitfield mask;				/* SYSTEM SERVICE EXCEPTION ENABLE (K) 
        SSFEXCE bitfield mask;				/* SYSTEM SERVICE EXCEPTION ENABLE (E) 
        SSFEXCS bitfield mask;				/* SYSTEM SERVICE EXCEPTION ENABLE (S) 
        SSFEXCU bitfield mask;				/* SYSTEM SERVICE EXCEPTION ENABLE (U) 
        SSRWAIT bitfield mask;				/* SYSTEM SERVICE RESOURCE WAIT DISABLE 
        SUSPEN bitfield mask;				/* SUSPEND PENDING 
        WAKEPEN bitfield mask;				/* WAKE PENDING, SKIP HIBERNATE 
        WALL bitfield mask;				/* WAIT FOR ALL EVENTS IN MASK 
        BATCH bitfield mask;				/* PROCESS IS A BATCH JOB 
        NOACNT bitfield mask;				/* NO ACCOUNTING FOR PROCESS 
        SWPVBN bitfield mask;				/* WRITE FOR SWP VBN IN PROGRESS 
        ASTPEN bitfield mask;				/* AST PENDING 
        PHDRES bitfield mask;				/* PROCESS HEADER RESIDENT 
        HIBER bitfield mask;				/* HIBERNATE AFTER INITIAL IMAGE ACTIVATE 
        LOGIN bitfield mask;				/* LOGIN WITHOUT READING AUTH FILE 
        NETWRK bitfield mask;				/* NETWORK CONNECTED JOB 
        PWRAST bitfield mask;				/* POWER FAIL AST 
        NODELET bitfield mask;				/* NO DELETE 
        DISAWS bitfield mask;				/* 1=DISABLE AUTOMATIC WS ADJUSTMENT 
	INTER bitfield mask;				/* PROCESS IS AN INTERACTIVE JOB
	RECOVER bitfield mask;				/* PROCESS CAN RECOVER LOCKS
	SECAUDIT bitfield mask;				/* MANDATORY SECURITY AUDITING
    end STS;
    WTIME structure longword unsigned;			/*TIME AT START OF WAIT 
        PRISAV byte unsigned;				/*SAVED CURRENT PRIORITY 
        PRIBSAV byte unsigned;				/*SAVE BASE PRIORITY 
	DPC byte unsigned;				/*DELETE PENDING COUNT
        AUTHPRI byte unsigned;				/*INITIAL PROCESS PRIORITY 
    end WTIME;
    STATE word unsigned;				/*PROCESS STATE 
    WEFC byte unsigned;					/*WAITING EF CLUSTER NUMBER 
    PRIB byte unsigned;					/*BASE PRIORITY 
    APTCNT word unsigned;				/*ACTIVE PAGE TABLE COUNT 
    TMBU word unsigned;					/*TERMINATION MAILBOX UNIT NO. 
    GPGCNT word unsigned;				/*GLOBAL PAGE COUNT IN WS 
    PPGCNT word unsigned;				/*PROCESS PAGE COUNT IN WS 
    ASTCNT word unsigned;				/*AST COUNT REMAINING 
    BIOCNT word unsigned;				/*BUFFERED I/O COUNT REMAINING 
    BIOLM word unsigned;				/*BUFFERED I/O LIMIT 
    DIOCNT word unsigned;				/*DIRECT I/O COUNT REMAINING 
    DIOLM word unsigned;				/*DIRECT I/O COUNT LIMIT 
    PRCCNT word unsigned;				/*SUBPROCESS COUNT 
    TERMINAL character length 8;			/*TERMINAL DEVICE NAME STRING 
                                            		/*FOR INTERACTIVE JOBS
    PQB_OVERLAY union fill;
        PQB longword unsigned;				/*POINTER TO PROCESS QUOTA BLOCK 
                                                	/*(PROCESS CREATION ONLY)
        EFWM longword unsigned;				/*EVENT FLAG WAIT MASK 
    end PQB_OVERLAY;
    EFCS longword unsigned;				/*LOCAL EVENT FLAG CLUSTER,SYSTEM 
    EFCU longword unsigned;				/*LOCAL EVENT FLAG CLUSTER, USER 
    CEFC_OVERLAY union fill;
        CEFC_OVERLAY_1 structure fill;		/*(USED BY SHELL)
            PGFLCHAR word unsigned;		/*PAGE FILE CHARACTERISTICS
            PGFLINDEX byte unsigned;		/*DESIRED PAGE FILE INDEX
            PGFL_FILL_1 byte fill tag $$;	/*SPARE
            SWAPSIZE longword unsigned;		/*INITIAL SWAP BLOCK ALLOCATION 
            end CEFC_OVERLAY_1;
        CEFC_OVERLAY_2 structure fill;
            EFC2P longword unsigned;		/*POINTER TO GLOBAL CLUSTER !2 
            EFC3P longword unsigned;		/*POINTER TO GLOBAL CLUSTER !3
            end CEFC_OVERLAY_2;
        end CEFC_OVERLAY;
    PID longword unsigned;				/*PROCESS ID USED BY EXEC ON LOCAL NODE ONLY
/*
/**** WARNING - THE INTERNAL STRUCTURE OF THE EPID IS SUBJECT TO RADICAL CHANGE BETWEEN
/****           VERSIONS OF VMS.  NO ASSUMPTIONS SHOULD EVER BE MADE ABOUT ITS FORMAT
/*
    EPID structure longword unsigned;			/*CLUSTER-WIDE PROCESS ID SEEN BY THE WORLD
	EPID_PROC bitfield length 21;			/*PROCESS ID FIELD, CAN CONVERT TO PCB$L_PID
{
{	Currently, the PCB$V_EPID_PROC field can be decomposed into the PCB$L_PID by extracting the
{	process index and sequence number according to:
{
{	    EPID_PROC_PIX  bitfield length SCH$GL_PIXWIDTH;
{	    EPID_PROC_SEQ  bitfield length (PCB$S_EPID_PROC - SCH$GL_PIXWIDTH);
{
	EPID_NODE_IDX  bitfield length 8;		/*IDX - INDEX TO TABLE OF NODE IDENTIFICATIONS
	EPID_NODE_SEQ  bitfield length 2;		/*SEQ - SEQUENCE NUMBER FOR NODE TABLE ENTRY REUSE
	EPID_WILD  bitfield mask;			/*FLAG THAT EPID IS WILDCARD CONTEXT FOR $GETJPI, AND NOT
	end EPID;					/* A VALID EPID
/*
    EOWNER longword unsigned;				/*EPID OF PROCESS OWNER
/*
    PHD longword unsigned;				/*PROCESS HEADER ADDRESS 
    LNAME character length 16;				/*LOGICAL NAME OF PROCESS 
    JIB longword unsigned;				/*ADDRESS OF JOB INFORMATION BLOCK 
    PRIV quadword unsigned;				/*CURRENT PRIVILEGE MASK 
    ARB longword unsigned;				/*ADDRESS OF ACCESS RIGHTS BLOCK 
    ARB_FILL_1 byte dimension 44 fill tag $$;		/*RIGHTS LIST DESCRIPTORS, ETC.
    UIC structure longword unsigned;			/*LOGON UIC OF PROCESS 
        MEM word unsigned;				/*MEMBER NUMBER IN UIC 
        GRP word unsigned;				/*GROUP NUMBER IN UIC 
    end UIC;
    ARB_FILL_2 byte dimension 60 fill tag $$;		/*REMAINDER OF ARB
    ACLFL longword unsigned;				/* ACL queue forward link
    ACLBL longword unsigned;				/* ACL queue backward link
    LOCKQFL longword unsigned;				/*LOCK QUEUE FORWARD LINK 
    LOCKQBL longword unsigned;				/*LOCK QUEUE BACKWARD LINK 
    DLCKPRI longword unsigned;				/*DEADLOCK RESOLUTION PRIORITY 
    IPAST longword unsigned;				/*VECTOR OF MODE BITS FOR IPASTS 
    DEFPROT longword unsigned;				/*PROCESS DEFAULT PROTECTION
    WAITIME longword unsigned;				/*ABS TIME OF LAST PROCESS EVENT
    PMB longword unsigned;				/*PMB ADDRESS
    constant "LENGTH" equals . prefix PCB$ tag K;	/*LENGTH OF PCB 
    constant "LENGTH" equals . prefix PCB$ tag C;	/*LENGTH OF PCB 
    
end PCBDEF;

end_module $PCBDEF;


module $PDBDEF;
/*+
/* DEFINE DEVICE PERFORMANCE DATA BLOCK
/*-



aggregate PDBDEF structure prefix PDB$;
    FREEFL longword unsigned;				/*FREE BUFFER LISTHEAD FORWARD LINK 
    FREEBL longword unsigned;				/*FREE BUFFER LISTHEAD BACKLINK 
    SIZE word unsigned;					/*SIZE OF DATA STRUCTURE 
    TYPE byte unsigned;					/*TYPE OF DATA STRUCTURE 
    OVERRUN byte unsigned;				/*OVERRUN INDICATOR 
    FILLFL longword unsigned;				/*FILLED BUFFER LISTHEAD FORWARD LINK 
    FILLBL longword unsigned;				/*FILLED BUFFER LISTHEAD BACKWARD LINK 
    CURBUF longword unsigned;				/*ADDRESS OF CURRENT BUFFER 
    NXTBUF longword unsigned;				/*ADDRESS OF NEXT LOCATION IN BUFFER 
    ENDBUF longword unsigned;				/*ADDRESS OF END OF BUFFER 
    PID longword unsigned;				/*PROCESS ID OF DATA COLLECTION PROCESS 
    DEVCLASS byte unsigned;				/*DEVICE CLASS SELECTION 
    DEVTYPE byte unsigned;				/*DEVICE TYPE SELECTION 
    ANDM word unsigned;					/*STATUS SELECTION 'AND' MASK 
    XORM word unsigned;					/*STATUS SELECTION 'XOR' MASK 
    BUFCNT word unsigned;				/*COUNT OF FILLED BUFFERS 
    FUNC quadword unsigned;				/*SELECTION FUNCTION MASK 
    constant "LENGTH" equals . prefix PDB$ tag K;	/*LENGTH OF DATA CONTROL BLOCK 
    constant "LENGTH" equals . prefix PDB$ tag C;	/*LENGTH OF DATA CONTROL BLOCK 
    
end PDBDEF;

end_module $PDBDEF;


module $PDTDEF;
/*+
/* DEFINE PORT-INDEPENDENT OFFSETS IN A PORT DESCRIPTOR TABLE.
/*
/* THERE IS ONE PDT PER PORT ACCESSED VIA SCS.  THESE PORTS INCLUDE
/* CI'S AND UDA'S.  THE PDT CONTAINS A PORT-INDEPENDENT PIECE (DEFINED
/* HERE) FOLLOWED BY AN OPTIONAL PORT-SPECIFIC PIECE DEFINED IN THE
/* PORT DRIVER.  PDT'S ARE CREATED BY THE CONTROLLER INIT ROUTINES
/* OF THE INDIVIDUAL PORT DRIVERS.
/*-



aggregate PDTDEF structure prefix PDT$;
    FLINK longword unsigned;				/*LINK TO NEXT SCS PDT
    PORTCHAR_OVERLAY union fill;
        PORTCHAR word unsigned;				/*Port Characteristics
	PORTCHAR_BITS structure fill;
            SNGLHOST bitfield mask;			/* Port to single host bus
	end PORTCHAR_BITS;
    end PORTCHAR_OVERLAY;
    FILL_2 byte fill prefix PDTDEF tag $$;		/* UNUSED BYTE 
    PDT_TYPE byte unsigned;				/* TYPE OF PDT 
    constant PA	equals 1  prefix PDT tag $C;		/* CI PORT 
    constant PU	equals 2  prefix PDT tag $C;		/* UDA PORT 
    constant PE equals 3  prefix PDT tag $C;		/* NI PORT
    constant PS equals 4  prefix PDT tag $C;		/* PASSTHRU PORT
    SIZE word unsigned;					/*STRUCTURE SIZE IN BYTES 
    TYPE byte unsigned;					/*STRUCTURE TYPE = SCS 
    SUBTYP byte unsigned;				/*STRUCTURE SUBTYPE 
    constant SCSBASE equals . prefix PDT$ tag K;	/*SCS ENTRIES INTO THE PORT DRIVER: 
    constant SCSBASE equals . prefix PDT$ tag C;	/*SCS ENTRIES INTO THE PORT DRIVER: 
    ACCEPT longword unsigned;				/* ACCEPT A CONNECT REQUEST 
    ALLOCDG longword unsigned;				/* ALLOCATE A DG BUFFER 
    ALLOCMSG longword unsigned;				/* ALLOCATE A MESSAGE BUFFER 
    CONNECT longword unsigned;				/* REQUEST CONNECTION TO REMOTE 
    DEALLOCDG longword unsigned;			/* DEALLOCATE DG BUFFER 
    DEALLOMSG longword unsigned;			/* DEALLOCATE MSG BUFFER 
    DEALRGMSG longword unsigned;			/* DEALLOC MSG BUFF, ARGS IN REGISTERS 
    DCONNECT longword unsigned;				/* BREAK CONNECTION 
    MAP longword unsigned;				/* MAP A BUFFER FOR BLK XFER 
    MAPBYPASS longword unsigned;			/* MAP, DISABL ACCESS CHECKS 
    MAPIRP longword unsigned;				/* MAP, GET ARGS FROM IRP 
    MAPIRPBYP longword unsigned;			/* MAP, ARGS FROM IRP, DISABL ACCESS CHECKS 
    QUEUEDG longword unsigned;				/* QUEUE A DG FOR RECEIVE 
    QUEUEMDGS longword unsigned;			/* ALLOC/DEALLOC DG'S FOR RECEIVE 
    RCHMSGBUF longword unsigned;			/* RECYCLE MSG BUFF, HIGH PRIORITY 
    RCLMSGBUF longword unsigned;			/* RECYCLE MSG BUFF, LOW PRIORITY 
    REJECT longword unsigned;				/* REJECT CONNECT REQUEST 
    REQDATA longword unsigned;				/* REQUEST BLK DATA XFER 
    SENDDATA longword unsigned;				/* SEND BLK DATA XFER 
    SENDDG longword unsigned;				/* SEND A DATAGRAM 
    SENDMSG longword unsigned;				/* SEND A MESSAGE 
    SNDCNTMSG longword unsigned;			/* SEND MSG WITH BYTE COUNT 
    UNMAP longword unsigned;				/* UNMAP A BUFFER 
    READCOUNT longword unsigned;			/* READ COUNTERS (FMT PORT SPECIFIC) 
    RLSCOUNT longword unsigned;				/* RELEASE AND READ COUNTERS 
    MRESET longword unsigned;				/* MAINT RESET OF REMOTE 
    MSTART longword unsigned;				/* MAINT START OF REMOTE 
    MAINTFCN longword unsigned;				/* MISC MAINT FUNCTIONS NOT SUPPORTED 
                                            		/*  IN VMS
    SENDRGDG longword unsigned;				/* SEND DG W/ REGISTER INPUTS
    STOP_VCS longword unsigned;				/* SEND STOP DGS ON ALL VCS
    constant SCSEND equals . prefix PDT$ tag K;		/*END OF SCS ENTRIES TO PORT DRIVER 
    constant SCSEND equals . prefix PDT$ tag C;		/*END OF SCS ENTRIES TO PORT DRIVER 
    FILL_3 longword dimension 10 fill prefix PDTDEF tag $$; /*RESERVED VECTORS
    WAITQFL longword unsigned;				/*LISTHEAD FOR FORK BLOCKS WAITING 
    WAITQBL longword unsigned;				/* FOR NONPAGED POOL 
    MSGHDRSZ longword unsigned;				/*MESSAGE HEADER SIZE 
    DGOVRHD longword unsigned;				/*DATAGRAM HEADER SIZE 
    MAXBCNT longword unsigned;				/*MAXIMUM TRANSFER BCNT
    FLAGS_OVERLAY union fill;
        FLAGS word unsigned;				/*PORT FLAGS 
	FLAGS_BITS structure fill;
            CNTBSY bitfield mask;			/* COUNTERS IN USE 
            CNTRLS bitfield mask;			/* RELEASE COUNTERS 
	end FLAGS_BITS;
    end FLAGS_OVERLAY;
    FILL_4 word fill prefix PDTDEF tag $$;		/*RESERVED WORD 
    CNTOWNER character length 16;			/*NAME OF SYSAP USING COUNTERS 
    CNTCDRP longword unsigned;				/*CDRP OF SYSAP READING COUNTERS 
    POLLSWEEP longword unsigned;			/*# SECONDS TO DO A POLLER SWEEP
    UCB0 longword unsigned;				/*ADDR OF UCB.
    ADP  longword unsigned;				/*ADDR OF ADP.
    constant "LENGTH" equals . prefix PDT$ tag K;	/*SIZE OF PORT-INDEPENDENT PIECE 
    constant "LENGTH" equals . prefix PDT$ tag C;	/*SIZE OF PORT-INDEPENDENT PIECE 
                                            		/* OF PDT.
    
end PDTDEF;

end_module $PDTDEF;


module $PFBDEF;

/*+
/* PAGE FAULT MONITOR BUFFER
/*-



aggregate PFBDEF structure prefix PFB$;
    FLINK longword unsigned;				/*Forward link
    BLINK longword unsigned;				/*Back    link
    SIZE word unsigned;					/*Structure size
    TYPE byte unsigned;					/*Dynamic structure type (PFB)
    SPARE_1 byte fill prefix PFBDEF tag $$;		/*SPARE

    #pfb_ubuff_size = 512;
    constant "USER_BUFFER" equals . prefix PFB$ tag B;
    USER_BUFFER structure;				/*Buffer returned to user
	#pfb_ubase = .;
	RECCNT longword unsigned;			/*Record count
	OVERFLOW longword unsigned;			/*Overflow count
	#pfb_ubuff_oh = . - #pfb_ubase;
	constant "BUFFER" equals . prefix PFB$ tag B;	/*Beginning of PC/VA pairs
	FILL_1 byte dimension (#pfb_ubuff_size - #pfb_ubuff_oh) fill prefix PFBDEF tag $$;
    end USER_BUFFER;

    constant "LENGTH" equals . prefix PFB$ tag K;	/*Length of PFB 
    constant "LENGTH" equals . prefix PFB$ tag C;	/*Length of PFB 
end PFBDEF;

end_module $PFBDEF;


module $PFLDEF;

/*+
/* PAGE FILE CONTROL BLOCK
/*-


/*
/* ***** L_VBN, L_WINDOW, AND B_PFC MUST BE THE SAME OFFSET VALUES AS THE
/* ***** EQUIVALENTLY NAMED OFFSETS IN $SECDEF
/*

aggregate PFLDEF structure prefix PFL$;
    BITMAP longword unsigned;				/*ADDRESS OF START OF BIT MAP 
                                            		/*BIT = 1 MEANS AVAILABLE
    STARTBYTE longword unsigned;			/*STARTING BYTE OFFSET TO SCAN 
    SIZE word unsigned;					/*SIZE OF PAGE FILE CONTROL BLOCK 
    TYPE byte unsigned;					/*PAGE FILE CONTROL BLOCK TYPE CODE 
    PFC byte unsigned;					/*PAGE FAULT CLUSTER FOR PAGE READS 
    WINDOW longword unsigned;				/*WINDOW ADDRESS 
    VBN longword unsigned;				/*BASE VBN 
    BITMAPSIZ longword unsigned;			/*SIZE IN BYTES OF PAGE FILE 
    FREPAGCNT longword unsigned;			/*COUNT - 1 OF PAGES WHICH MAY BE ALLOCATED 
    MAXVBN longword unsigned;				/*MASK APPLIED TO PTE WITH PAGING FILE 
                                            		/* BACKING STORE ADDRESS
    ERRORCNT word unsigned;				/*COUNT OF POTENTIALLY BAD PAGES 
    ALLOCSIZ byte unsigned;				/*CURRENT ALLOCATION REQUEST SIZE 
    FLAGS_OVERLAY union fill;
        FLAGS byte unsigned;				/*FLAGS BYTE FOR THIS PAGE FILE 
        constant "LENGTH" equals . prefix PFL$ tag K;	/*SIZE OF PAGE FILE CONTROL BLOCK 
        constant "LENGTH" equals . prefix PFL$ tag C;	/*SIZE OF PAGE FILE CONTROL BLOCK 
	FLAGS_BITS structure fill;
            INITED bitfield mask;			/*THIS PAGE FILE IS USABLE 
            PAGFILFUL bitfield mask;			/*REQUEST FOR PAGING SPACE HAS FAILED 
            SWPFILFUL bitfield mask;			/*REQUEST FOR SWAPPING SPACE HAS FAILED 
            CHKPNT bitfield mask;			/*USEABLE BY CHECKPOINT/RESART 
            FILL_1 bitfield length 3 fill prefix PFLDEF tag $$;/*SPARE BITS FOR EXPANSION 
            STOPPER bitfield mask;			/*RESERVED FOR ALL TIME (MUST NEVER BE SET) 
	end FLAGS_BITS;
    end FLAGS_OVERLAY;
    BITMAPLOC longword unsigned;			/*BITMAP FOLLOWS PFL HEADER 
    
end PFLDEF;

end_module $PFLDEF;


module $PFNDEF;

/*+
/* PFN DATA BASE DEFINITIONS
/*-

/*
/* VIELD DEFINITIONS IN PFN$AB_STATE
/*

aggregate PFNDEF  union prefix PFN$;
    PFNDEF_BITS0 structure fill;
        LOC bitfield mask length 3;			/*LOCATION OF PAGE 
/*
/* ***** THE FOLLOWING SPARE BIT MUST BE USED FOR EXTENSION OF THE LOC FIELD
/* ***** OR ALTERNATIVELY THE DELCON BIT MUST BE MOVED ADJACENT TO LOC
/*
        FILL_1 bitfield fill prefix PFNDEF tag $$;	/*NOT IN USE 
        DELCON bitfield mask;				/*DELETE PFN CONTENTS WHEN REF=0 
        FILL_2 bitfield length 2 fill prefix PFNDEF tag $$;/*NOT IN USE 
        MODIFY bitfield mask;				/*MODIFY BIT 
    end PFNDEF_BITS0;
/*
/* VIELD DEFINITIONS IN PFN$AB_TYPE
/*
    PFNDEF_BITS1 structure fill;
        PAGTYP bitfield mask length 3;			/*PAGE TYPE 
        FILL_3 bitfield fill prefix PFNDEF tag $$;	/*NOT IN USE 
        COLLISION bitfield mask;			/*EMPTY COLLISION QUEUE WHEN PAGE READ COMPLETE 
        BADPAG bitfield mask;				/*BAD PAGE BIT 
        RPTEVT bitfield mask;				/*REPORT EVENT ON I/O COMPLETE 
    end PFNDEF_BITS1;
/*
/* VIELD DEFINITIONS IN PFN$AL_BAK
/*
    PFNDEF_BITS2 structure fill;
        BAK bitfield mask length 23;			/*BACKUP ADDRESS 
        GBLBAK bitfield mask;				/*GLOBAL BACKING STORE ADDRESS 
        PGFLX bitfield mask length 8;			/*PAGE FILE INDEX 
    end PFNDEF_BITS2;
/*
/* LOCATION VIELD VALUES
/*
    constant FREPAGLST	equals 0  prefix PFN tag $C;	/*ON FREE PAGE LIST 
    constant MFYPAGLST	equals 1  prefix PFN tag $C;	/*ON MODIFIED PAGE LIST 
    constant BADPAGLST	equals 2  prefix PFN tag $C;	/*ON BAD PAGE LIST 
    constant RELPEND	equals 3  prefix PFN tag $C;	/*RELEASE PENDING 
                                            		/*WHEN REFCNT = 0 RELEASE PFN
    constant RDERR	equals 4  prefix PFN tag $C;	/*READ ERROR WHILE PAGING IN 
    constant WRTINPROG	equals 5  prefix PFN tag $C;	/*WRITE IN PROGRESS (BY MFY PAG WRITER) 
    constant RDINPROG	equals 6  prefix PFN tag $C;	/*READ IN PROGRESS (PAGE IN) 
    constant ACTIVE	equals 7  prefix PFN tag $C;	/*PAGE IS ACTIVE AND VALID 
/*
/* PAGE TYPE VIELD DEFINITIONS
/*
    constant PROCESS	equals 0  prefix PFN tag $C;	/*PROCESS PAGE 
    constant SYSTEM	equals 1  prefix PFN tag $C;	/*SYSTEM PAGE 
    constant "GLOBAL"	equals 2  prefix PFN tag $C;	/*GLOBAL PAGE (READ ONLY) 
    constant GBLWRT	equals 3  prefix PFN tag $C;	/*GLOBAL WRITABLE PAGE 
    constant PPGTBL	equals 4  prefix PFN tag $C;	/*PROCESS PAGE TABLE 
    constant GPGTBL	equals 5  prefix PFN tag $C;	/*GLOBAL PAGE TABLE 
    
end PFNDEF;

end_module $PFNDEF;


module $PHDDEF;
/*+
/* A PROCESS HEADER CONTAINS THE SWAPPABLE SCHEDULER AND
/* MEMORY MANAGEMENT DATA BASES FOR A PROCESS IN THE
/* BALANCE SET.
/*-



aggregate PHDDEF structure prefix PHD$;
    PRIVMSK quadword unsigned;				/*PRIVILEGE MASK 
/*
/* WORKING SET LIST POINTERS - THESE CONTAIN LONG WORD OFFSETS FROM THE
/* BEGINNING OF THE PROCESS HEADER.
/*
    WSLIST word unsigned;				/*1ST WORKING SET LIST ENTRY 
    WSAUTH word unsigned;				/*AUTHORIZED WORKING SET SIZE 
    WSLOCK word unsigned;				/*1ST LOCKED WORKING SET LIST ENTRY 
    WSDYN word unsigned;				/*1ST DYNAMIC WORKING SET LIST ENTRY 
    WSNEXT word unsigned;				/*LAST WSL ENTRY REPLACED 
    WSLAST word unsigned;				/*LAST WSL ENTRY IN LIST 
    WSAUTHEXT word unsigned;				/*AUTHORIZED WS EXTENT 
/*
/* THE FOLLOWING THREE WORDS SPECIFY THE MAXIMUM AND INITIAL WORKING SET
/* SIZES FOR THE PROCESS.  RATHER THAN CONTAINING THE COUNT OF PAGES
/* THEY CONTAIN THE LONG WORD INDEX TO WHAT WOULD BE THE LAST WORKING
/* SET LIST ENTRY.
/*
    WSEXTENT word unsigned;				/*MAX WORKING SET SIZE AGAINST BORROWING 
    WSQUOTA word unsigned;				/*QUOTA ON WORKING SET SIZE 
    DFWSCNT word unsigned;				/*DEFAULT WORKING SET SIZE 
    PAGFIL_OVERLAY union fill;
        PAGFIL longword unsigned;			/*PAGING FILE INDEX, LONG WORD REF 
	PAGFIL_FIELDS structure fill;
            FILL_28 byte dimension 3 fill prefix PHDDEF tag $$;
            PAGFIL byte unsigned;			/*PAGING FILE INDEX, BYTE REFERENCE 
/*
/* PROCESS SECTION TABLE DATA BASE
/*        PSTBASOFF IS THE BYTE OFFSET (INTEGRAL ! OF PAGES) FROM THE
/* BEGINNING OF THE PROCESS HEADER TO THE 1ST LONG WORD BEYOND THE
/* PROCESS SECTION TABLE.
/*        THE WORDS, PSTLAST AND PSTFREE ARE SECTION TABLE INDICES WHICH
/* ARE THE NEGATIVE LONG WORD INDEX FROM THE END OF THE SECTION TABLE TO
/* THE SECTION TABLE ENTRY.
/*
	end PAGFIL_FIELDS;
    end PAGFIL_OVERLAY;
    PSTBASOFF longword unsigned;			/*BYTE OFFSET TO BASE OF PST 
                                                	/*FIRST LONG WORD NOT IN PST
                                                	/*PST GROWS BACKWARDS FROM HERE
    PSTLAST word unsigned;				/*END OF PROCESS SECTION TABLE 
                                            		/*ADR OF LAST PSTE ALLOCATED
    PSTFREE word unsigned;				/*HEAD OF FREE PSTE LIST 
/*
/* CREATE/DELETE PAGE CONTEXT
/*
    FREP0VA longword unsigned;				/*1ST FREE VIRTUAL ADR AT END OF P0 SPACE 
                                            		/****** MUST BE QUAD WORD AWAY FROM FREP1VA
    FREPTECNT longword unsigned;			/*CNT OF FREE PTE'S BETWEEN THE ENDS 
                                            		/*0F THE P0 AND P1 PAGE TABLES
    FREP1VA longword unsigned;				/*1ST FREE VIRTUAL ADR AT END OF P1 SPACE 
    DFPFC byte unsigned;				/*DEFAULT PAGE FAULT CLUSTER 
    PGTBPFC byte unsigned;				/*PAGE TABLE CLUSTER FACTOR 
    FLAGS_OVERLAY union fill;
        FLAGS word unsigned;				/*FLAGS WORD 
	FLAGS_BITS structure fill;
            PFMFLG bitfield mask;			/*PAGE FAULT MONITORING ENABLED 
            DALCSTX bitfield mask;			/*NEED TO DEALLOCATE SECTION INDICES 
            WSPEAKCHK bitfield mask;			/*CHECK FOR NEW WORKING SET SIZE (PROC) 
            NOACCVIO bitfield mask;			/*SET AFTER INSWAP OF PROCESS HEADER 
            IWSPEAKCK bitfield mask;			/*CHECK FOR NEW WORKING SET SIZE (IMAGE) 
            IMGDMP bitfield mask;			/*TAKE IMAGE DUMP ON ERROR EXIT
	    NO_WS_CHNG bitfield mask;			/*NO CHANGE TO SORKING SET OR SWAPPING
							/* SHORT TERM USE BY MMG CODE ONLY
	end FLAGS_BITS;
/*
/* QUOTAS AND LIMITS
/*
    end FLAGS_OVERLAY;
    CPUTIM longword unsigned;				/*ACCUMULATED CPU TIME CHARGED 
    QUANT word unsigned;				/*ACCUMULATED CPU TIME SINCE 
                                            		/*LAST QUANTUM OVERFLOW
    PRCLM word unsigned;				/*SUBPROCESS QUOTA 
    ASTLM word unsigned;				/*AST LIMIT 
    
    PHVINDEX word unsigned;				/*PROCESS HEADER VECTOR INDEX 
    BAK longword unsigned;				/*POINTER TO BACKUP ADDRESS VECTOR FOR 
                                            		/*PROCESS HEADER PAGES
    WSLX_OVERLAY union fill;
        WSLX longword unsigned;				/*POINTER TO WORKING SET LIST INDEX 
                                                	/*SAVE AREA
        PSTBASMAX longword unsigned;			/*LW OFFSET TO TOP PST ADDRESS 
    end WSLX_OVERLAY;
    PAGEFLTS longword unsigned;				/*COUNT OF PAGE FAULTS 
    WSSIZE word unsigned;				/*CURRENT ALLOWED WORKING SET SIZE 
    SWAPSIZE word unsigned;				/*CURRENT SWAP BLOCK ALLOCATION 
    
/*
/* THE NEXT TWO I/O COUNTERS MUST BE ADJACENT
/*
    
    DIOCNT longword unsigned;				/*DIRECT I/O COUNT 
    BIOCNT longword unsigned;				/*BUFFERED I/O COUNT 
    
    CPULIM longword unsigned;				/*LIMIT ON CPU TIME FOR PROCESS 
    CPUMODE byte unsigned;				/*ACCESS MODE TO NOTIFY ABOUT CPUTIME 
    AWSMODE byte unsigned;				/*ACCESS MODE FLAG FOR AUTO WS AST 
    FILL_30 word unsigned;				/*SPARE
/*
/* PAGE TABLE STATISTICS
/*
    PTWSLELCK longword unsigned;			/* BYTE OFFSET TO BYTE ARRAY OF COUNTS 
                                            		/* OF LOCKED WSLE'S IN THIS PAGE TABLE
    PTWSLEVAL longword unsigned;			/* BYTE OFFSET TO BYTE ARRAY OF COUNTS 
                                            		/* OF VALID WSLE'S IN THIS PAGE TABLE
    constant PHDPAGCTX	equals 8  prefix PHD tag $C;	/* SIZE OF CONTEXT FOR PHD PAGES 
    PTCNTLCK word unsigned;				/* COUNT OF PAGE TABLES CONTAINING 
                                            		/* 1 OR MORE LOCKED WSLE
    PTCNTVAL word unsigned;				/* COUNT OF PAGE TABLES CONTAINING 
                                            		/* 1 OR MORE VALID WSLE
    PTCNTACT word unsigned;				/* COUNT OF ACTIVE PAGE TABLES 
    PTCNTMAX word unsigned;				/* MAX COUNT OF PAGE TABLES 
                                            		/* WHICH HAVE NON-ZERO PTE'S
    WSFLUID word unsigned;				/* GUARANTEED NUMBER OF FLUID WS PAGES 
    EXTDYNWS word unsigned;				/* EXTRA DYNAMIC WORKING SET LIST ENTRIES 
                                            		/* ABOVE REQUIRED WSFLUID MINIMUM
/*
/* HARDWARE PCB PORTION OF PROCESS HEADER
/*
    PCB_OVERLAY union fill;
        PCB longword unsigned;				/*HARDWARE PCB 
        KSP longword unsigned;				/*KERNEL STACK POINTER 
    end PCB_OVERLAY;
    ESP longword unsigned;				/*EXEC STACK POINTER 
    SSP longword unsigned;				/*SUPERVISOR STACK POINTER 
    USP longword unsigned;				/*USER STACK POINTER 
    R0 longword unsigned;				/*R0 
    R1 longword unsigned;				/*R1 
    R2 longword unsigned;				/*R2 
    R3 longword unsigned;				/*R3 
    R4 longword unsigned;				/*R4 
    R5 longword unsigned;				/*R5 
    R6 longword unsigned;				/*R6 
    R7 longword unsigned;				/*R7 
    R8 longword unsigned;				/*R8 
    R9 longword unsigned;				/*R9 
    R10 longword unsigned;				/*R10 
    R11 longword unsigned;				/*R11 
    R12 longword unsigned;				/*R12 
    R13 longword unsigned;				/*R13 
    PC longword unsigned;				/*PC 
    PSL longword unsigned;				/*PROGRAM STATUS LONGWORD 
    P0BR longword unsigned;				/*P0 BASE REGISTER 
    P0LRASTL_OVERLAY union fill;
        P0LRASTL longword unsigned;			/*P0LR, ASTLVL 
	P0LRASTL_BITS structure fill;
            P0LR bitfield length 24;			/*P0 LENGTH REGISTER 
            ASTLVL bitfield length 8;			/* AST LEVEL 
	end P0LRASTL_BITS;
	P0LRASTL_FIELDS structure fill;
            FILL_29 byte dimension 3 fill prefix PHDDEF tag $$;
            ASTLVL byte unsigned;			/*AST LEVEL SUBFIELD 
	end P0LRASTL_FIELDS;
    end P0LRASTL_OVERLAY;
    P1BR longword unsigned;				/*P1 BASE REGISTER 
    P1LR longword unsigned;				/*P1 LENGTH REGISTER 
    EMPTPG word unsigned;				/*COUNT OF EMPTY WORKING SET PAGES 
    RESPGCNT word unsigned;				/*RESIDENT PAGE COUNT 
    REQPGCNT word unsigned;				/*REQUIRED PAGE COUNT 
    CWSLX word unsigned;				/*CONTINUATION WSLX 
    AUTHPRIV quadword unsigned;				/*AUTHORIZED PRIVILEGES MASK 
    IMAGPRIV quadword unsigned;				/*INSTALLED IMAGE PRIVILEGES MASK 
    RESLSTH longword unsigned;				/*POINTER TO RESOURCE LIST 
    IMGCNT longword unsigned;				/*IMAGE COUNTER BUMPED BY SYSRUNDWN 
    PFLTRATE longword unsigned;				/*PAGE FAULT RATE 
    PFLREF longword unsigned;				/*PAGE FAULTS AT END OF LAST INTERVAL 
    TIMREF longword unsigned;				/*TIME AT END OF LAST INTERVAL 
    MPINHIBIT longword unsigned;			/*COUNT OF REASONS WHY PROCESS 
                                            		/* MUST RUN ON PRIMARY IN MP SYSTEM
    PGFLTIO longword unsigned;				/*COUNT OF PAGEFAULT I/O 
    AUTHPRI byte unsigned;				/*INITIAL PROCESS PRIORITY 
    FILL_1 byte fill prefix PHDDEF tag $$;		/*SPARE 
    FILL_2 word fill prefix PHDDEF tag $$;		/*SPARE 
    EXTRACPU longword unsigned;				/*ACCUMULATED CPU TIME LIMIT EXTENSION 
    MIN_CLASS structure;			/* MINIMUM AUTHORIZED SECURITY CLEARANCE
        FILL_3 byte unsigned dimension 20 fill tag $$;
        end MIN_CLASS;
    MAX_CLASS structure;			/* MAXIMUM AUTHORIZED SECURITY CLEARANCE
        FILL_4 byte unsigned dimension 20 fill tag $$;	
        end MAX_CLASS;
    SPARE longword unsigned;				/*SPARE 
    FILL_13 longword fill prefix PHDDEF tag $$;		/*SPARE 
    FILL_14 longword fill prefix PHDDEF tag $$;		/*SPARE 
    FILL_15 longword fill prefix PHDDEF tag $$;		/*SPARE 
    FILL_16 longword fill prefix PHDDEF tag $$;		/*SPARE 
    FILL_17 longword fill prefix PHDDEF tag $$;		/*SPARE 
    FILL_18 longword fill prefix PHDDEF tag $$;		/*SPARE 
    FILL_19 longword fill prefix PHDDEF tag $$;		/*SPARE 
    FILL_20 longword fill prefix PHDDEF tag $$;		/*SPARE 
    FILL_21 longword fill prefix PHDDEF tag $$;		/*SPARE 
    FILL_22 longword fill prefix PHDDEF tag $$;		/*SPARE 
    FILL_23 longword fill prefix PHDDEF tag $$;		/*SPARE 
    FILL_24 longword fill prefix PHDDEF tag $$;		/*SPARE 
    FILL_25 longword fill prefix PHDDEF tag $$;		/*SPARE 
    FILL_26 longword fill prefix PHDDEF tag $$;		/*SPARE 
    FILL_27 longword fill prefix PHDDEF tag $$;		/*SPARE 
/*
/* END OF FIXED PORTION OF PROCESS HEADER
/*
    constant "LENGTH" equals . prefix PHD$ tag K;	/*LENGTH OF FIXED PART OF PROCESS HEADER 
    constant "LENGTH" equals . prefix PHD$ tag C;	/*LENGTH OF FIXED PART OF PROCESS HEADER 
    WSL longword unsigned;				/*FIRST WORKING SET LIST ENTRY 
    
end PHDDEF;

end_module $PHDDEF;


module $PIBDEF;
/*+
/* PERFORMANCE I/O INFORMATION BLOCK
/*-



aggregate PIBDEF union prefix PIB$;
    TYPE byte unsigned;					/*TYPE OF ENTRY 
    
/*
/* START OF I/O REQUEST TRANSACTION MESSAGE BLOCK
/*
    
end PIBDEF;

aggregate PIBDEF1 structure prefix PIB$;
    FILL_5 byte fill prefix PIBDEF tag $$;
    SRQ_PRI byte unsigned;				/*BASE PRIORITY OF PROCESS 
    SRQ_ACON word unsigned;				/*Access control info from WCB or 0
    SRQ_TIME quadword unsigned;				/*TIME OF I/O TRANSACTION 
    SRQ_SEQN longword unsigned;				/*SEQUENCE NUMBER OF I/O TRANSACTION 
    SRQ_PID longword unsigned;				/*REQUESTER PID 
    SRQ_UCB longword unsigned;				/*ADDRESS OF DEVICE UCB 
    SRQ_FUNC word unsigned;				/*I/O FUNCTION CODE 
    SRQ_STS word unsigned;				/*I/O PACKET STATUS 
    SRQ_ACCESS byte unsigned;				/*Access control info from WCB or 0
    FILL_1 byte dimension 3 fill prefix PIBDEF tag $$;	/*SPARE UNUSED BYTES 
    constant SRQ_SIZE equals . prefix PIB$ tag K;	/*LENGTH OF START I/O MESSAGE 
    constant SRQ_SIZE equals . prefix PIB$ tag C;	/*LENGTH OF START I/O MESSAGE 
    
/*
/* START OF I/O TRANSACTION MESSAGE BLOCK
/*
    
end PIBDEF1;

aggregate PIBDEF2 structure prefix PIB$;
    FILL_6 byte fill prefix PIBDEF tag $$;
    FILL_2 byte fill prefix PIBDEF tag $$;		/*SPARE UNUSED BYTE 
    FILL_9 word fill prefix PIBDEF tag $$;		/*SPARE UNUSED WORD
    SIO_TIME quadword unsigned;				/*TIME OF TRANSACTION 
    SIO_SEQN longword unsigned;				/*SEQUENCE NUMBER OF TRANSACTION 
    SIO_MEDIA longword unsigned;			/*TRANSFER MEDIA ADDRESS 
    SIO_BCNT longword unsigned;				/*TRANSFER BYTE COUNT 
    constant SIO_SIZE equals . prefix PIB$ tag K;	/*LENGTH OF I/O TRANSACTION MESSAGE 
    constant SIO_SIZE equals . prefix PIB$ tag C;	/*LENGTH OF I/O TRANSACTION MESSAGE 
    
/*
/* END OF I/O TRANSACTION MESSAGE BLOCK
/*
    
end PIBDEF2;

aggregate PIBDEF3 structure prefix PIB$;
    FILL_7 byte fill prefix PIBDEF tag $$;
    FILL_3 byte dimension 3 fill prefix PIBDEF tag $$;	/*SPARE UNUSED BYTES 
    EIO_TIME quadword unsigned;				/*TIME OF TRANSACTION 
    EIO_SEQN longword unsigned;				/*SEQUENCE NUMBER OF TRANSACTION 
    EIO_IOSB quadword unsigned;				/*FINAL I/O STATUS 
    constant EIO_SIZE equals . prefix PIB$ tag K;	/*LENGTH OF END OF I/O TRANSACTION 
    constant EIO_SIZE equals . prefix PIB$ tag C;	/*LENGTH OF END OF I/O TRANSACTION 
    
/*
/* END OF I/O REQUEST MESSAGE BLOCK
/*
    
end PIBDEF3;

aggregate PIBDEF4 structure prefix PIB$;
    FILL_8 byte fill prefix PIBDEF tag $$;
    FILL_4 byte dimension 3 fill prefix PIBDEF tag $$;	/*SPARE UNUSED BYTES 
    ERQ_TIME quadword unsigned;				/*TIME OF TRANSACTION 
    ERQ_SEQN longword unsigned;				/*SEQUENCE NUMBER OF TRANSACTION 
    constant ERQ_SIZE equals . prefix PIB$ tag K;	/*LENGTH OF END OF I/O REQUEST TRANSACTION 
    constant ERQ_SIZE equals . prefix PIB$ tag C;	/*LENGTH OF END OF I/O REQUEST TRANSACTION 
    
/*
/* I/O MESSAGE BLOCK ENTRY TYPE CODES
/*
    
    constant SRQ	equals 0  prefix PIB tag $K;	/*START OF I/O REQUEST 
    constant SIO	equals 1  prefix PIB tag $K;	/*START OF I/O TRANSACTION 
    constant EIO	equals 2  prefix PIB tag $K;	/*END OF I/O TRANSACTION 
    constant ERQ	equals 3  prefix PIB tag $K;	/*END OF I/O REQUEST 
    constant ARQ	equals 4  prefix PIB tag $K;	/*ABORTED I/O REQUEST 
    
end PIBDEF4;

aggregate PIBDEF5 structure prefix PIB$;
    FILL_10 byte fill prefix PIBDEF tag $$;
    FILL_11 byte dimension 3 fill prefix PIBDEF tag $$;	/*SPARE UNUSED BYTES 
    ARQ_TIME quadword unsigned;				/*TIME OF TRANSACTION 
    ARQ_SEQN longword unsigned;				/*SEQUENCE NUMBER OF TRANSACTION 
    constant ARQ_SIZE equals . prefix PIB$ tag K;	/*LENGTH OF ABORTED I/O TRANSACTION
    constant ARQ_SIZE equals . prefix PIB$ tag C;	/*LENGTH OF ABORTED I/O TRANSACTION 
    
/*
/* ABORTED I/O REQUEST MESSAGE BLOCK
/*
    
end PIBDEF5;

end_module $PIBDEF;


module $PMBDEF;
/*+
/* PAGE FAULT MONITOR CONTROL BLOCK
/*-



aggregate PMBDEF structure prefix PMB$;
    CURBUF longword unsigned;				/*Current buffer pointer 
    BUFBASE longword unsigned;				/*Current buffer base address
    SIZE word unsigned;					/*Block size field 
    TYPE byte unsigned;					/*Dynamic structure type (PMB)
    FLAGS structure byte unsigned;			/*Processing flags
	MODE bitfield mask;				/*Mode of operation
	    constant "SUBPROC" equals 0; /*Subprocess mode
	    constant "IMAGE"   equals 1; /*Image mode
	ASTIP bitfield mask;				/*AST in progress flag
	QAST bitfield mask;				/*Imbedded ACB is enqueued on the PCB
    end FLAGS;
    LASTCPU longword unsigned;				/*Last recorded CPU time
    OVERFLOW longword unsigned;				/*Buffer overflow counter (both modes)
    HDR quadword unsigned;				/*Free   buffer queue header 
    SBPHDR quadword unsigned;				/*Filled buffer queue header 
    ACB_OVERLAY union fill;
	AST_BLOCK structure fill;			/*Used as AST block in image mode
	    ASTQFL longword unsigned;			/*ACB flink
	    ASTQBL longword unsigned;			/*ACB blink
	    SPARE_1 byte dimension 2 fill prefix PMBDEF tag $$; /*SPARE
	    ACMODE byte unsigned;			/*Owner access mode
	    RMOD byte unsigned;				/*AST delivery mode/flags
	    PID longword unsigned;			/*PID for AST delivery
	    AST longword unsigned;			/*AST routine address
	    ASTPRM longword unsigned;			/*AST parameter
	    KAST longword unsigned;			/*Address of piggy-back kernel AST routine
	end AST_BLOCK;
	SUBP_BLOCK structure fill;			/*Utility storage in subprocess mode
	    SPARE_2 longword dimension 2 fill prefix PMBDEF tag $$; /*SPARE
	    MBXCHN word unsigned;			/*Subprocess mailbox channel 
	    OACMODE byte unsigned;			/*Owner access mode (Synonym for ACMODE)
	    SPARE_3 byte dimension 1 fill prefix PMBDEF tag $$; /*SPARE
	    IPID longword unsigned;			/*IPID of subprocess (Synonym for PID)
	    EPID longword unsigned;			/*EPID of subprocess
	    SPARE_4 longword dimension 2 fill prefix PMBDEF tag $$; /*SPARE
	end SUBP_BLOCK;
    end ACB_OVERLAY;
    constant "LENGTH" equals . prefix PMB$ tag K;	/*Length of PMB 
    constant "LENGTH" equals . prefix PMB$ tag C;	/*Length of PMB 
end PMBDEF;

end_module $PMBDEF;



module $PQBDEF;
/*+
/* PROCESS QUOTA BLOCK DEFINITION
/*-

aggregate PQBDEF structure prefix PQB$;
    PRVMSK quadword unsigned;			/* PRIVILEGE MASK 
    SIZE word unsigned;				/* SIZE OF PQB IN BYTES 
    TYPE byte unsigned;				/* STRUCTURE TYPE CODE 
    STS byte unsigned;				/* STATUS FLAGS 

    ASTLM longword unsigned;			/* AST LIMIT 
    BIOLM longword unsigned;			/* BUFFERED I/O LIMIT 
    BYTLM longword unsigned;			/* BUFFERED I/O LIMIT 
    CPULM longword unsigned;			/* CPU TIME LIMIT 
    DIOLM longword unsigned;			/* DIRECT I/O LIMIT 
    FILLM longword unsigned;			/* OPEN FILE LIMIT 
    PGFLQUOTA longword unsigned;		/* PAGING FILE QUOTA 
    PRCLM longword unsigned;			/* SUB-PROCESS LIMIT 
    TQELM longword unsigned;			/* TIMER QUEUE ENTRY LIMIT 
    WSQUOTA longword unsigned;			/* WORKING SET QUOTA 
    WSDEFAULT longword unsigned;		/* WORKING SET DEFAULT 
    ENQLM longword unsigned;			/* ENQUEUE LIMIT 
    WSEXTENT longword unsigned;			/* MAXIMUM WORKING SET SIZE 
    JTQUOTA longword unsigned;			/* JOB-WIDE LOGICAL NAME TABLE CREATION QUOTA

    FLAGS structure word unsigned;		/* MISC FLAGS
	IMGDMP bitfield mask;			/* TAKE IMAGE DUMP ON SERIOUS ERROR
	end FLAGS;
    MSGMASK byte unsigned;			/* MESSAGE FLAGS 
    FILL_1 byte unsigned;			/* Spare
    UAF_FLAGS longword unsigned;		/* FLAGS FROM UAF RECORD
    CREPRC_FLAGS longword unsigned;		/* FLAGS FROM $CREPRC ARGUMENT LIST

    MIN_CLASS structure;			/* MINIMUM AUTHORIZED SECURITY CLEARANCE
        FILL_2 byte unsigned dimension 20 fill tag $$;
        end MIN_CLASS;

    MAX_CLASS structure;			/* MAXIMUM AUTHORIZED SECURITY CLEARANCE
        FILL_3 byte unsigned dimension 20 fill tag $$;	
        end MAX_CLASS;

    INPUT_ATT longword unsigned;		/*  SYS$INPUT attributes
    OUTPUT_ATT longword unsigned;		/*  SYS$OUTPUT attributes
    ERROR_ATT longword unsigned;		/*  SYS$ERROR attributes
    DISK_ATT longword unsigned;			/*  SYS$DISK attributes

    CLI_NAME character length 32;		/* CLI name
    CLI_TABLE character length 256;		/* CLI table name
    SPAWN_CLI character length 32;		/* Spawn CLI name
    SPAWN_TABLE character length 256;		/* Spawn CLI table name

    INPUT character length 256;			/* LOGICAL NAME FOR INPUT 
    OUTPUT character length 256;		/* LOGICAL NAME FOR OUTPUT 
    ERROR character length 256;			/* LOGICAL NAME FOR ERROR OUTPUT 
    DISK character length 256;			/* LOGICAL NAME FOR SYS$DISK 

    DDSTRING character length 256;		/* DEFAULT DIRECTORY STRING 

    IMAGE character length 256;			/* IMAGE NAME FOR NEW PROCESS 

    constant "LENGTH" equals . prefix PQB$ tag K;	/* LENGTH OF PROCESS QUOTA BLOCK 
    constant "LENGTH" equals . prefix PQB$ tag C;	/* LENGTH OF PROCESS QUOTA BLOCK 
    
end PQBDEF;

end_module $PQBDEF;


module $PRBDEF;

/*+
/*
/* Protection block definition. The protection block is used to specify
/* protection on objects internal to the system (e.g., devices, logical
/* name tables, etc.) It is used as input to the EXE$CHECKACCESS routine.
/*
/*-

aggregate PRBDEF structure prefix PRB$;
    FLAGS structure word unsigned;	/* Presence flag bits
	UIC bitfield mask;		/* Set for simple UIC protection
	ACL bitfield mask;		/* Set for access control list
	CLASS bitfield mask;		/* Set for security classification
	CLASSMAX bitfield mask;		/* Set for security class range
    end FLAGS;
    PROTECTION word unsigned;		/* SOGW protection mask
    OWNER longword unsigned;		/* Owner UIC

/*
/* The remaining items in the protection block are optional and therefore
/* do not have fixed offsets. The description given below is for a
/* hypothetical fully configured protection block.
/*
/*  ACL quadword;			/* ACL listhead
/*  CLASS structure;			/* Classification mask
/*	FILL_1 long dimension 5 fill;
/*	end CLASS;
/*  CLASSMAX structure;			/* Maximum class mask for range
/*	FILL_2 long dimension 5 fill;
/*	end CLASSMAX;
/*

end PRBDEF;
end_module $PRBDEF;

module $PRCPOLDEF;
/*+
/* PROCESS POLLER MAILBOX MESSAGE DEFINITIONS
/*-

aggregate PRCPOLDEF structure prefix PRCPOL$;
    SYSIDL longword unsigned;				/*LOW ORDER SYSTEM ID
    SYSIDH word unsigned;				/*HIGH ORDER SYSTEM ID
    FILL_1 word unsigned fill;				/* (UNUSED)
    NODNAM character length 16;				/*SCA NODE NAME (COUNTED ASCII)
    PRCNAM byte unsigned dimension 16;			/*PROCESS NAME
    DIRINF byte unsigned dimension 16;			/*DIRECTORY INFORMATION
    constant "SIZ" equals . prefix PRCPOL$ tag C;	/*SIZE OF MESSAGE	

end PRCPOLDEF;

end_module $PRCPOLDEF;

module $PRIDEF;

/*+
/* PRIORITY INCREMENT CLASS DEFINITIONS
/*-


constant NULL	equals 0  prefix PRI tag $;		/* NO PRIORITY INCREMENT 
constant IOCOM	equals 1  prefix PRI tag $;		/* DIRECT I/O COMPLETION 
constant RESAVL	equals 2  prefix PRI tag $;		/* RESOURCE AVAIL 
constant TOCOM	equals 3  prefix PRI tag $;		/* TERMINAL OUTPUT COMPLETE 
constant TICOM	equals 4  prefix PRI tag $;		/* TERMINAL INPUT COMPLETE 
constant TIMER	equals 2  prefix PRI tag $;		/* TIMER INTERVAL COMPLETION 

end_module $PRIDEF;

module $PRMDEF;
/*+
/* DEFINE PARAMETER DESCRIPTOR BLOCK
/*-


aggregate PRM_DEF structure prefix PRM$;
    ADDR longword unsigned;				/*ADDRESS OF PARAMETER 
    "DEFAULT" longword unsigned;			/*DEFAULT VALUE 
    MIN longword unsigned;				/*MINIMUM VALUE (-1)=>NONE 
    MAX longword unsigned;				/*MAXIMUM VALUE (-1)=>NONE 
    FLAGS_OVERLAY union fill;
        FLAGS longword unsigned;			/*TYPE FLAGS 
	FLAGS_BITS structure fill;
            DYNAMIC bitfield mask;			/* DYNAMIC PARAMETER 
            STATIC bitfield mask;			/* STATIC PARAMETER 
            SYSGEN bitfield mask;			/* SYSGEN PARAMETER 
            ACP bitfield mask;				/* ACP CONTROL PARAMETER 
            JBC bitfield mask;				/* JOB CONTROL PARAMETER 
            RMS bitfield mask;				/* RMS CONTROL PARAMETER 
            SYS bitfield mask;				/* GENERAL SYSTEM PARAMETER 
            SPECIAL bitfield mask;			/* SPECIAL PARAMETER 
            DISPLAY bitfield mask;			/* DISPLAY ONLY (NO CHANGE) 
            CONTROL bitfield mask;			/* CONTROL PARAMETER 
            MAJOR bitfield mask;			/* MAJOR PARAMETER 
            PQL bitfield mask;				/* PROCESS QUOTA LIST 
            NEG bitfield mask;				/* NEGATIVE 
            TTY bitfield mask;				/* TERMINAL CONTROL PARAMETER 
            SCS bitfield mask;				/* SCS CONTROL PARAMETERS 
	    CLUSTER bitfield mask;			/* CLUSTER CONTROL PARAMETERS
            ASCII bitfield mask;			/* ASCII PARAMETER
	    LGI bitfield mask;				/* LOGIN PARAMETER
	end FLAGS_BITS;
    end FLAGS_OVERLAY;
    SIZE byte unsigned;					/*SIZE CODE FOR DATUM 
    constant "BYTE"	equals 8   prefix PRM tag $C;	/* 
    constant "WORD"	equals 16  prefix PRM tag $C;	/* 
    constant LONG	equals 32  prefix PRM tag $C;	/* 
    constant "QUAD"	equals 64  prefix PRM tag $C;	/*
    constant "OCTA"	equals 128 prefix PRM tag $C;	/*
    POS byte unsigned;					/*BIT POSITION 
    NAME character length 16;				/*ASCIC NAME STRING 
    constant MAXNAMLEN	equals 15  prefix PRM tag $C;	/*MAXIMUM LENGTH FOR PARAMETER NAME 
    UNIT character length 12;				/*ASCIC UNIT STRING 
    constant MAXUNILEN	equals 11  prefix PRM tag $C;	/*MAXIMUM LENGTH FOR UNIT NAME 
    constant "LENGTH" equals . prefix PRM$ tag K;	/*SIZE OF DESCRIPTOR BLOCK 
    constant "LENGTH" equals . prefix PRM$ tag C;	/*SIZE OF DESCRIPTOR BLOCK 
end PRM_DEF;

end_module $PRMDEF;

module $PRQDEF;
/*+
/* INTER-PROCESSOR REQUEST BLOCK DEFINITIONS
/*
/* THIS IS THE BASIC FORMAT FOR AN EXECUTIVE OR DRIVER REQUEST FROM
/* ONE PROCESSOR TO ANOTHER PROCESSOR.
/*-



aggregate PRQDEF structure prefix PRQ$;
    FLINK longword unsigned;				/*FORWARD LINK TO NEXT BLOCK 
    BLINK longword unsigned;				/*BACKWARD LINK TO PREVIOUS BLOCK 
    FILL_1 longword dimension 4 fill prefix PRQDEF tag $$;/* (RESERVED FOR FORK CONTEXT) 
    TO_PORT word unsigned;				/*PORT NUMBER TO SEND REQUEST TO 
    FR_PORT word unsigned;				/*PORT NUMBER REQUEST IS FROM 
    DISPATCH word unsigned;				/*MESSAGE DISPATCHER ID 
                                            		/* MESSAGE DISPATCHER ID'S
    constant EXEC	equals 0  prefix PRQ tag $C;	/* EXECUTIVE REQUEST ID 
    constant MAILBOX	equals 1  prefix PRQ tag $C;	/* MAILBOX REQUEST ID 
    constant REMDISK	equals 2  prefix PRQ tag $C;	/* REMOTE DISK REQUEST ID 
    constant HSC50	equals 3  prefix PRQ tag $C;	/* HSC-50 REQUEST ID 
    FILL_2 word fill prefix PRQDEF tag $$;		/*(UNUSED) 
/*
    REQTYPE word unsigned;				/*REQUEST TYPE 
                                            		/* MESSAGE DISPATCHER REQUEST SUB-TYPES
    constant SETEF	equals 0  prefix PRQ tag $C;	/* COPY COMMON EVENT FLAG REQUEST ID 
    constant RESAVL	equals 1  prefix PRQ tag $C;	/* REPORT RESOURCE AVAILABLE 
    UNIT word unsigned;					/*UNIT NUMBER 
    PARAM longword unsigned;				/*FIRST PARAMETER 
    constant MINLENGTH	equals 64  prefix PRQ tag $C;	/*MINIMUM REQUEST BLOCK LENGTH 
    
end PRQDEF;

end_module $PRQDEF;

module $PSMDEF;				/* Print symbiont definitions

/*+
/* Symbolic definitions for print symbionts.
/*
/*	Public definition of various constants and data structures
/*	used by the standard VMS print symbiont, and by user modified
/*	print symbionts.
/*
/*-


/*
/*	Service routine function codes
/*

constant (

  /*
  /* IO functions
  /*

    CANCEL,			/* Cancel pending operations
    CLOSE,			/* Release resources
    FORMAT,			/* Format buffer
    OPEN,			/* Obtain resources
    READ,			/* Read
    GET_KEY,			/* Read record key
    POSITION_TO_KEY,		/* Read by record context
    REWIND,			/* Rewind file
    WRITE,			/* Write
    WRITE_NOFORMAT,		/* Write with driver formatting disabled
    WRITE_SUPPRESSED,		/* Write but suppress output


  /*
  /* Message notification functions
  /*

    PAUSE_TASK,			/* STOP /QUEUE
    RESET_STREAM,		/* STOP /QUEUE /RESET
    RESUME_TASK,		/* START /QUEUE	(when paused)
    START_STREAM,		/* START /QUEUE (when stopped)
    START_TASK,			/* (ofiginated by job controller)
    STOP_TASK,			/* STOP /QUEUE /ABORT or /REQUEUE
    STOP_STREAM			/* STOP /QUEUE /NEXT

) equals 1 increment 1 prefix PSM$;



/*
/*	Replacement routines
/*

constant (

  /*
  /* Task services -- where applicable the ordering of these literals
  /* determines the sequence of the corresponding service routines.
  /*

  /*
  /* Page services
  /*

    PAGE_SETUP,			/* Page setup	    - page setup modules
    PAGE_HEADER,		/* Page separation  - page headers


  /*
  /* Library module service
  /*

    LIBRARY_INPUT,		/* Module services


  /*
  /* Filter services
  /*

    INPUT_FILTER,		/* Filter service   - input
    MAIN_FORMAT,		/* Format service   - carriage control
    OUTPUT_FILTER,		/* Filter service   - output


  /*
  /* Output services
  /*

    OUTPUT,			/* Main output routine


  /*
  /* General input services
  /*

    JOB_SETUP,			/* Job setup	    - job reset modules
    FORM_SETUP,			/* Form setup	    - form setup modules
    JOB_FLAG,			/* Job separation   - flag page
    JOB_BURST,			/* Job separation   - burst page
    FILE_SETUP,			/* File setup	    - file setup modules
    FILE_FLAG,			/* File separation  - flag page
    FILE_BURST,			/* File separation  - burst page
    FILE_SETUP_2,		/* File setup	    - top of form
    MAIN_INPUT,			/* File service	    - main routine
    FILE_INFORMATION,		/* Additional information print
    FILE_ERRORS,		/* Errors during task processing
    FILE_TRAILER,		/* File separation  - trailer page
    JOB_RESET,			/* Job reset	    - job reset modules
    JOB_TRAILER,		/* Job separation   - trailer page
    JOB_COMPLETION,		/* Job completion   - top of form

    max				/* MUST BE LAST

) equals 1 increment 1 prefix PSM$;



/*
/*	Carriage control types
/*

constant (
    INTERNAL,			/*  - imbedded
    IMPLIED,			/*  - implied
    FORTRAN,			/*  - fortran
    PRINT,			/*  - print file (PRN)
    MAX				/* MUST BE LAST

) equals 1 increment 1 prefix PSM$ tag K_CC;

end_module $PSMDEF;


module $PTEDEF;

/*+
/* DEFINE PAGE TABLE ENTRY VIELDS AND VALUES
/*-
/*
/* VIELD DEFINITION FOR "VALID" PTE'S
/*

aggregate PTEDEF  union prefix PTE$;
    PTEDEF_BITS0 structure fill;
        PFN bitfield mask length 21;			/* PAGE FRAME NUMBER 
        WINDOW bitfield mask;				/* WINDOW BIT 
        FILL_1 bitfield fill prefix PTEDEF tag $$;	/* RESERVED 
        OWN bitfield mask length 2;			/* MODE OF THE OWNER 
        FILL_2 bitfield fill prefix PTEDEF tag $$;	/* RESERVED 
        MODIFY bitfield mask;				/* MODIFY BIT 
        PROT bitfield mask length 4;			/* PROTECTION 
        VALID bitfield mask;				/* VALID BIT 
    end PTEDEF_BITS0;
/*
/* VIELD DEFINITIONS FOR VARIOUS INVALID FORMS OF PTE
/*
    PTEDEF_BITS1 structure fill;
        STX bitfield length 16 signed;				/* SECTION TABLE INDEX 
        CRF bitfield mask;				/* COPY ON REFERENCE 
        DZRO bitfield mask;				/* DEMAND ZERO 
        WRT bitfield mask;				/* SECTION FILE IS ACCESSED FOR WRITING 
        FILL_3 bitfield length 3 fill prefix PTEDEF tag $$;/* SPARE 
        TYP0 bitfield mask;				/* LOW ORDER BIT OF PTE TYPE 
        FILL_4 bitfield length 2 fill prefix PTEDEF tag $$;/* OWNER FIELD 
        FILL_5 bitfield fill prefix PTEDEF tag $$;	/* RESERVED 
        TYP1 bitfield mask;				/* HIGH ORDER BIT OF PTE TYPE 
                                                	/* OVERLAYS MODIFY BIT
    end PTEDEF_BITS1;
    PTEDEF_BITS2 structure fill;
        PGFLVB bitfield mask length 22;			/* PAGE FILE VBN 
    end PTEDEF_BITS2;
    PTEDEF_BITS3 structure fill;
        FILL_6 bitfield length 21 fill prefix PTEDEF tag $$;/* SPACING 
        CHKPNT bitfield mask;				/* FORGET THAT THIS PAGE HAS A BACKING STORE 
    end PTEDEF_BITS3;
                                            		/*  TO BE FORGOTTEN
    
    PTEDEF_BITS4 structure fill;
        GPTX bitfield mask length 22;			/* GLOBAL PAGE TABLE INDEX 
    end PTEDEF_BITS4;
/*+
/* PROTECTION FIELD DEFINITIONS
/*-
    constant NA	  equals 0 prefix PTE tag $C;		/* NO ACCESS 
    constant KR	  equals %X18000000 prefix PTE tag $C;	/* KERNEL READ ONLY 
    constant KW	  equals %X10000000 prefix PTE tag $C;	/* KERNEL WRITE 
    constant ER	  equals %X38000000 prefix PTE tag $C;	/* EXEC READ ONLY 
    constant EW	  equals %X28000000 prefix PTE tag $C;	/* EXEC WRITE 
    constant SR	  equals %X58000000 prefix PTE tag $C;	/* SUPER READ ONLY 
    constant SW	  equals %X40000000 prefix PTE tag $C;	/* SUPER WRITE 
    constant UR   equals %X78000000 prefix PTE tag $C;	/* USER READ ONLY 
    constant UW	  equals %X20000000 prefix PTE tag $C;	/* USER WRITE 
    constant ERKW equals %X30000000 prefix PTE tag $C;	/* EXEC READ KERNEL WRITE 
    constant SRKW equals %X50000000 prefix PTE tag $C;	/* SUPER READ KERNEL WRITE 
    constant SREW equals %X48000000 prefix PTE tag $C;	/* SUPER READ EXEC WRITE 
    constant URKW equals %X70000000 prefix PTE tag $C;	/* USER READ KERNEL WRITE 
    constant UREW equals %X68000000 prefix PTE tag $C;	/* USER READ EXEC WRITE 
    constant URSW equals %X60000000 prefix PTE tag $C;	/* USER READ SUPER WRITE 
/*+
/* OWNER FIELD DEFINITIONS
/*_
    constant KOWN equals 0 prefix PTE tag $C;		/* KERNEL OWNER 
    constant EOWN equals %X00800000 prefix PTE tag $C;	/* EXEC OWNER 
    constant SOWN equals %X01000000 prefix PTE tag $C;	/* SUPER OWNER 
    constant UOWN equals %X01800000 prefix PTE tag $C;	/* USER OWNER 
end PTEDEF;

end_module $PTEDEF;


module $PTRDEF;

/*+
/* POINTER CONTROL BLOCK
/*        THIS IS A STRUCTURE OF POINTERS TO OTHER DYNAMIC STRUCTURES
/*        OF LIKE KIND.  TYPICALLY THE STRUCTURES POINTED TO ARE KNOWN
/*        BY THEIR LONG WORD INDEX INTO THE TABLE AND TO FACILITATE FETCHING
/*        THESE, IT IS CONVENTIONAL TO KEEP A POINTER TO THE BASE OF THE
/*        STRUCTURE POINTERS RATHER THAN (OR IN ADDITION TO) THE POINTER
/*        TO THE FRONT OF THE POINTER CONTROL BLOCK.  THE NUMBER OF POINTERS
/*        IN THE ARRAY PRECEEDS THE FIRST POINTER IN THE ARRAY.
/*-



aggregate PTRDEF structure prefix PTR$;
    FILL_1 quadword fill prefix PTRDEF tag $$;		/*RESERVED QUAD WORD FOR LINKAGE 
    SIZE word unsigned;					/*SIZE OF DYNAMIC CONTROL BLOCK 
    TYPE byte unsigned;					/*TYPE OF DYNAMIC CONTROL BLOCK 
    PTRTYPE byte unsigned;				/*TYPE OF CONTROL BLOCK POINTED TO 
    PTRCNT longword unsigned;				/*COUNT OF ENTRIES 
    constant "LENGTH" equals . prefix PTR$ tag K;	/*LENGTH OF FIXED PORTION 
    constant "LENGTH" equals . prefix PTR$ tag C;	/*LENGTH OF FIXED PORTION 
    PTR0 longword unsigned;				/*PTR NUMBER 0 
    
end PTRDEF;

end_module $PTRDEF;
{
{ Version:	'V04-000'
{
{****************************************************************************
{*									    *
{*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
{*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
{*  ALL RIGHTS RESERVED.						    *
{* 									    *
{*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
{*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
{*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
{*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
{*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
{*  TRANSFERRED.							    *
{* 									    *
{*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
{*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
{*  CORPORATION.							    *
{* 									    *
{*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
{*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
{* 									    *
{*									    *
{****************************************************************************

{++
{
{ FACILITY:  VAX/VMS System Macro Libraries
{
{ ABSTRACT:
{
{        This file contains the SDL source for all operating system control
{        blocks, from Q to Z.  That is, all control blocks from QAA to ZZZ.
{
{ ENVIRONMENT:
{
{        n/a
{
{--
{
{
{ AUTHOR:  The VMS Group         CREATION DATE:  1-Aug-1976
{
{ MODIFIED BY:
{
{	V03-125	ROW0410		Ralph O. Weber		 6-AUG-1984
{		Define a UCB$L_STS bit indicating VAXcluster state transition 
{		processing in progress, UCB$V_CLUTRAN.  This bit is used to 
{		force mount verification to execute after (or as a part of) a 
{		VAXcluster state transition.
{
{	V03-124	ACG0441		Andrew C. Goldstein,	2-Aug-1984  15:16
{		Add CLUSLOCK flag to VCB, DISMOUNT flag to UCB
{
{	V03-123	TCM0005		Trudy C. Matthews	23-Jul-1984  16:50
{		Add RPB$B_CTRLLTR to $RPBDEF.
{
{	V03-122	ACG0438		Andrew C. Goldstein,	23-Jul-1984  15:16
{		Add VCA structures for cache interlocks
{
{	V03-121	MMD0314		Meg Dumont,	19-Jul-1984  12:23
{		Add $XGDEF to LIB.ML
{
{	V03-120	ROW392		Ralph O. Weber		19-JUL-1984
{		Add UCB$W_DEVSTS bit UCB$V_MSCP_WRTP which is the inclusive or 
{		of all the various MSCP write protection bits.
{
{	V03-119	LY0501		Larry Yetto		 6-JUL-1984 13:11
{		Add subfields to UCB$L_MEDIA_ID
{
{	V03-118	ROW0379		Ralph O. Weber		21-JUN-1984
{		Add UCB$W_2P_MSCPUNIT to provide for future implementation of 
{		dual-path UDA support via MSCP unit number switching in the 
{		MSCP class driver.
{
{	V03-117	ROW0357		Ralph O. Weber		 1-MAY-1984
{		Add UCB$V_MNTVERPND in UCB$L_STS.  This bit will be set along 
{		with UCB$V_MNTVERIP when it is necessary to stall a busy 
{		device due to loss of quorum.  Also add UCB$V_MSCP_PKACK in 
{		UCB$W_DEVSTS for MSCP devices.  This will be used by the disk 
{		class driver to indicate that a IO$_PACKACK operation is in 
{		progress.
{
{	V03-116	CDS0012		Christian D. Saether	18-Apr-1984
{		Add wcb$v_noacclock, remove wcb$v_acclkid.
{
{	V03-115	GRR4115		Gregory R. Robert	12-Apr-1984
{		Split $SMBDEF into symbiont services and print symbiont
{		sections.  Move latter into $PSMDEF.
{
{	V03-114	LJK0265		Lawrence J. Kenah	9-Apr-1984
{		Add SHL_SIZE cell and OLD_SHL_SIZE constant to $SHLDEF
{		to allow image activator and ANALYZE /IMAGE to handle
{		shareable image list elements of different sizes.
{
{	V03-113	LMP0221		L. Mark Pilant,		7-Apr-1984  13:13
{		Add a pointer to the ORB in the UCB.  Also remove the
{		definitions, in the UCB, of the owner UIC, volume
{		protection, and the ACL queue segment list head.
{
{	V03-112	ROW0337		Ralph O. Weber		 7-APR-1984
{		Remove UCB$L_CANLINK.  This field is no longer used.
{
{	V03-111	MHB0118		Mark Bramhall		26-Mar-1984
{		Add UAF$V_DISRECONNECT.
{
{	V03-110	MIR0370		Michael I. Rosenblum	20-Mar-1984
{		Add definitions for TTY$V_ST_TABRIGHT and CTSLOW
{		Add UCB cell to store the cursor positioning from the
{		last read.
{
{	V03-109	SSA0020		Stan Amway		20-Mar-1984
{		Moved UCB$W_QLEN from disk/tape extension to main UCB.
{		Changed UCB$W_DCCB in disk/tape extension to UCB$L_DCCB.
{
{	V03-108	ROW0325		Ralph O. Weber		19-MAR-1984
{		Remove UCB$L_MVIOQFL and UCB$L_MVIOQBL; these fields are no 
{		longer used.  Add UCB$Q_MSCP_RESV, eight bytes of space 
{		reserved for use by new MSCP features implemented during the 
{		Version 4 life-time.  Add VCB$L_SHAD_RESV to the standard 
{		disk VCB and VCB$Q_SHDM_RESV to the shadow set member VCB, 
{		both fields provide reserved space for implementation of 
{		volume shadowing during the Version 4 life-time.
{
{	V03-107	JWT0163		Jim Teague		10-Mar-1984
{		Enlarge name fields in shareable image list ($SHLDEF)
{
{	V03-106	ACG0400		Andrew C. Goldstein,	10-Mar-1984  2:01
{		Add quota cache structures for cluster-wide quota cacheing
{
{	V03-105	WHM0001		Bill Matthews		02-Mar-1984
{		Added field SLV$A_SYSVECS( address of vectors in SYS.EXE)
{		to $SLVDEF.
{
{	V03-104	CDS0011		Christian D. Saether	 8-Mar-1984
{		Add WRITE_TURN flag to WCB.
{
{	V03-103	PRD0072		Paul R. DeStefano	27-Feb-1984
{		Added SB$L_CSB (link to newest Cluster System Block)
{		to $SBDEF.
{
{	V03-102	ROW0316		Ralph O. Weber		27-FEB-1984
{		Change UCB$V_TU_OVRSEQCHK to UCB$V_TU_OVRSQCHK in 
{		UCB$W_DEVSTS.  Add a fourth type of VCB for shadow set 
{		members.  Add fields to the disk VCB for shadow set and 
{		enhanced mount verification handling.
{
{	V03-101	SSA0011		Stan Amway		27-Feb-1984
{		Changed UCB$L_DCCB in disk/tape UCB extension to UCB$W_DCCB.
{		Moved UCB$W_QLEN to disk/tape UCB extension.
{		Deleted UCB$L_WRTCNT.
{
{	V03-100	MMD0244		Meg Dumont,	24-Feb-1984  14:59
{		Add support for VCB$V_FIL_ACCESS
{
{	V03-099	SSA0010		Stan Amway		14-Feb-1984
{		Added UCB$V_DATACACHE as a disk-specific bit in UCB$W_DEVSTS.
{		Added UCB$L_DCCB in disk/tape UCB extension.
{
{		Added UCB$L_WRTCNT & UCB$W_QLEN to support MONITOR disk class.
{		(Done on behalf of Tom Cafarella.)
{
{	V03-098	ROW0303		Ralph O. Weber		10-FEB-1984
{		Add definition of UCB$M_AST_ARMED defined as the sign bit of 
{		UCB$W_DIRSEQ.
{
{	V03-097	ROW0300		Ralph O. Weber		 9-FEB-1984
{		Add UCB$V_MSCP_FLOVR, a bit which a MSCP driver toggles 
{		(changes the state of) whenever a device sucessfully moves 
{		from one controller to another.
{
{	V03-096	ROW0297		Ralph O. Weber		 7-FEB-1984
{		Add UCB$V_TU_SEQNOP a device dependent status bit which the 
{		tape class driver sets when the wait count is bumped due to a 
{		sequential nop operation being in progress.
{
{	V03-095	PCG0001		Peter George		06-Feb-1984
{		Add UAF$V_DISREPORT.
{
{	V03-094	LMP0188		L. Mark Pilant,		4-Feb-1984  11:19
{		Add a classification block to the VCB.
{
{	V03-093	TMK0004		Todd M. Katz		04-Feb-1984
{		Add a NI device extension to $UCBDEF.
{
{	V03-092	KPL0100		Peter Lieberwirth	 2-Feb-1984
{		Lengthen RPB BOOTNDT field to a word.  Leave byte definition
{		as well.  Only newly-defined FLAGS byte need move as a result,
{		it shifts left one byte.
{
{	V03-091	ROW0282		Ralph O. Weber		14-JAN-1984
{		Add UCB$V_SUPMVMSG bit to UCB$L_STS.  When set, this bit 
{		supresses success status messages from mount verification.
{		Add UCB$L_WAIT_CDDB to the MSCP UCB extension.  This field 
{		points to a CDDB which is waiting for mount verification to 
{		complete before beginning single CDRP processing.
{
{	V03-090	ACG0385		Andrew C. Goldstein,	9-Jan-1984  17:07
{		Replace $UAFDEF (authorization file) with new V4 format
{
{	V03-089	LMP0177		L. Mark Pilant,		7-Dec-1983  10:22
{		Add an ACL queue listhead to the UCB.
{
{	V03-088	CDS0010		Christian D. Saether	6-Dec-1983
{		Add VCB$V_NOSHARE flag.
{
{	V03-087	SRB0106		Steve Beckhardt		6-Dec-1983
{		Made several changes to $RSBDEF.
{
{	V03-086	ROW0256		Ralph O. Weber		16-NOV-1983
{		Move the general disk UCB$W_DEVSTS bit definitions from being 
{		a UCB$L_DPC subfield to being a UCB$W_DEVSTS subfield.  Also 
{		redo the MSCP and TU device status bit definitions to 
{		accomodate these recently discovered disk device status bits.
{
{	V03-085	ROW0255		Ralph O. Weber		14-NOV-1983
{		Restore UCB$W_EC1 and UCB$W_EC2 symbols which were lost during 
{		the preparation of ROW0253.
{
{	V03-084	TMK0003		Todd M. Katz		12-Nov-1983
{		Lets try again and this time fix both TMK0002 and ROW0253.
{		My previous attempt doubly defined the symbol UCB$K_2P_LENGTH.
{		Replace one of the definitions with local symbol #2P_LENGTH.
{
{	V03-083	TMK0002		Todd M. Katz		12-Nov-1983
{		Fix ROW0253 and system build by defining UCB$K_2P_LENGTH.
{
{	V03-082	ROW0253		Ralph O. Weber		11-NOV-1983
{		Make changes to the UCB to accomidate more class driver fields 
{		becoming publicly available.  Make DEVSTS definitions for 
{		class driver bits.  Add 2P synonyms for all dual-path fields.  
{		Restructure disk and tape specific sections of the device 
{		dependent UCB to add class driver fields and to overlay some 
{		unused local-disk fields with these class driver fields.
{
{	V03-081	TMK0001		Todd M. Katz		26-Oct-1983
{		Add UAF$L_JTQUOTA within $UAFDEF.
{
{	V03-080	CDS0009		Christian D. Saether	14-Oct-1983
{		Remove VCB$L_ALLOCLKID.  Add various VCB and RVT
{		fields to support volume activity blocking for rebuild.
{
{	V03-079	CDS0008		Christian D. Saether	10-Oct-1983
{		Add VCB$L_ALLOCLKID.
{
{	V03-078	JSV0411		Joost Verhofstad	27-SEP-1983
{		Add UCB$W_JNL_PROT
{
{	V03-077	GRR0005		Gregory R. Robert	26-Sep-1983
{		Added $SMBDEF, public symbiont definitions.
{
{	V03-076	CWH3076		CW Hobbs		10-Sep-1983
{		Add a RPB$B_FLAGS field to $RPBDEF, and define a bit
{		RPB$V_NOSYSDISK, which means that the boot volume is no
{		longer present (e.g. for S/A BACKUP from console).
{
{	V03-075	ROW0220		Ralph O. Weber		 7-SEP-1983
{		Switch bit positions of the Phase 1 in progress and Phase 2 in 
{		progress flags in the Replacement and Caching Table structure 
{		definition, $RCTDEF.  This causes the definition to conform 
{		with the DSDF specification, from which it is derived.
{
{		Also define UCB$V_LCL_VALID in UCB$L_STS.  This bit being set 
{		indicates that one of the reasons a disk is volume valid is a 
{		PACKACK operation performed on the local node.
{
{	V03-074	CDS0007		Christian D. Saether	24-Aug-1983
{		Add RVT$T_VLSLCKNAM to the RVT.
{
{	V03-073	ROW0211		Ralph O. Weber		16-AUG-1983
{		Add two LENGTH symbols to $UCBDEF.  UCB$K_LCL_DISK_LENGTH is 
{		the length of a device-independent UCB for a local disk.  
{		UCB$K_LCL_TAPE_LENGTH is the length of a device-independent 
{		UCB for a local magnetic tape.  (Someday there will be 
{		different LENGTH symbols for remote disks and tapes.)  
{
{		Also make UCB$W_BCR have a longword form for the convenience 
{		of DBDRIVER.
{
{	V03-072	ROW0204		Ralph O. Weber		 5-AUG-1983
{		Move UCB$L_CPID from its current overlay with UCB$L_DUETIM to 
{		a new overlay with UCB$L_LOCKID.
{
{	V03-071	KTA3072		Kerbey T. Altmann	02-Aug-1983
{		Add UCB$B_ONLCNT - count of number of ONLINEs to
{		a disk or tape.
{		Change location of RVT$L_STRUCLKID added by CDS0006.
{
{	V03-070	CDS0006		Christian D. Saether	 2-Aug-1983
{		Remove RVX structure.
{		Add RVT$L_STRUCLKID.
{
{	V03-069	NPK3029		N. kronenberg		29-JUL-1983
{		Redefine the SCS$C_ST status codes to conform to
{ 		the latest SCA format (error type*8+severity.)
{
{	V03-068 LY0401		Larry Yetto		29-JUL-1983 12:15:59
{		Add UCB$L_JNL_BTXSEQNO
{
{	V03-067	JLV0283		Jake VanNoy		28-JUL-1983
{		Correct fill problem in UCBDEF.
{
{	V03-066	JSV0367		Joost Verhofstad	28-JUL-1983
{		Change journal name length to 18
{
{	V03-065	MMD0190		Meg Dumont,	28-Jul-1983  9:45
{		Changed bit in VCBDEF from AUTO to NOAUTO to make mag tape
{		AVL/AVR consistent between DCL and MOUNT system service
{
{	V03-064 LY0398		Larry Yetto			28-JUL-1983
{		Add UCB$L_JNL_WCBFL and UCB$L_JNL_WCBBL. Remove
{		VCB$L_JNL_WCBFL and VCB$L_JNL_WCBBL.
{
{	V03-063	CDS0005		Christian D. Saether		28-Jun-1983
{		Add VCB$L_VOLLKID, VCA$L_EXTCLKID, and VCA$L_FIDCLKID.
{
{	V03-062	MIR0052		Michael I. Rosenblum		27-Jun-1983
{		Add missing deffinitions for UCB$L_RTT_BANDEXCL and BANDEXMSK
{
{	V03-061	MIR0051		Michael I. Rosenblum		24-Jun-1983
{		Add $TTYUCBDEF to this module.  Also note this Definition
{		Must follow $UCBDEF as it gets a local symbol defined
{		in $UCBDEF.
{
{	V03-060	CDS0004		Christian D. Saether	23-Jun-1983
{		Add VCB$T_VOLCKNAM to end of vcb instead of in middle.
{
{	V03-059	RLRDPATH1	Robert L. Rappaport	23-Jun-1983
{		Add UCB$L_DP_ALTUCB to Dual Path section of UCB.
{
{	V03-058	CDS0003		Christian D. Saether	23-Jun-1983
{		Add VCB$T_VOLCKNAM field.
{
{	V03-057	WMC0055		Wayne Cardoza		21-Jun-1983
{		Increase number of vector pages in SGNDEF
{
{	V03-056 PRB0198		Paul R. Beck		 13-JUN-1983 13:28
{		Add RUCBDEF and RUHDEF (formerly defined in [RUF.SRC]RUF.SDL)
{
{	V03-055 LY0381		Larry Yetto		13-JUN-1983 07:57:45
{		Add WCB$L_JNL_RC
{
{	V03-054	WMC0054		Wayne Cardoza		29-May-1983
{		New protection and spare fields in SLVDEF.
{
{	V03-053	MLJ0113		Martin L. Jack		27-May-1983
{		Add UAF$B_QUEPRI.
{
{	V03-052	RLRDPATH	Robert L. Rappaport	25-May-1983
{		Create a new UCB extension for Dual Ported Devices that
{		resides after the errorlogging extension and before
{		the DISK_UCB_EXTENSION.  Place in it UCB$L_DP_DDB and
{		UCB$L_DP_LINK.
{
{	V03-051	LY0375		Larry Yetto		24-MAY-1983 15:44:29
{		Add cluster write Q list head to UCB journal extention.
{		Also added status bits DIRENTER and CHKVAL in $RSBDEF.
{
{	V03-050	KTA3052		Kerbey T. Altmann	24-May-1983
{		Updated SCSDEF for split up of layers.
{
{	V03-049 LY0366		Larry Yetto		18-MAY-1983 17:08:36
{		Add UCB$V_JNL_UNMAST, UCB$L_JNL_RMBLK, UCB$L_JNL_ACBM,
{		and UCB$L_JNL_LSEQNO
{
{	V03-048	JLV0253		Jake VanNoy		18-MAY-1983
{		Add symbols to $TASTDEF.
{
{	V03-047	MMD0151		Meg Dumont,	26-Apr-1983  9:06
{		Add VCB$B_LBLCNT to the MTAACP portion of VCBDEF
{
{	V03-046 LY0356		Larry Yetto		21-APR-1983 08:16:48
{		Add UCB$L_JNL_FAILQFL and UCB$L_JNL_FAILQBL
{
{	V03-045	MSH0004		Maryann Hinden		14-Apr-1983
{		Add SPNB$W_REFC.
{
{	V03-044	JWH0208		Jeffrey W. Horn		12-Apr-1983
{		Add SLV$B_PROT and SLV$T_FACILTY to $SLVDEF.
{
{	V03-043	TCM0004		Trudy C. Matthews	12-Apr-1983
{		Add UCB$L_LOCKID to $UCBDEF.
{
{	V03-042	JWT0104		Jim Teague		29-Mar-1983
{		Add UAF$T_CLITABLES field to $UAFDEF.
{
{	V03-041	JSV0201		Joost Verhofstad	28-MAR-1983
{		Add monitor counts in UCB for journals
{
{	V03-040	ROW0171		Ralph O. Weber		25-MAR-1983
{		Extend UCB$L_DEVCHAR to a quadword, UCB$Q_DEVCHAR.  
{		Also create symbol for second portion of the quadword, 
{		UCB$L_DEVCHAR2.
{
{	V03-039	SRB0072		Steve Beckhardt		25-Mar-1983
{		Added some fields to $RSBDEF.
{
{	V03-038 MSH0003		Maryann Hinden		25-Mar-1983
{		Delete SPNB$L_HEADER definition, add SPNB$C_HDRSIZ.
{
{	V03-037	STJ3075		Steven Jeffreys,25-Mar-1983
{		- Add VCB$V_ERASE and VCB$V_NOHIGHWATER.
{
{	V03-036	MMD0108		Meg Dumont,	11-Mar-1983  12:32
{ 		Add defs to VL1DEF for handling of VOL1 owner id field 
{		and added VL2DEF to handle the VOL2 label.
{
{	V03-035	MMD0106		Meg Dumont,	10-Mar-1983  9:55
{		Add fields in VCB for AVR, AVL and the VOL2, HDR4 
{		additions to MTAACP
{
{	V03-034	SRB0069		Steve Beckhardt		9-Mar-1983
{		Removed SYSNAM status bit from $RSBDEF.
{
{	V03-033 LY0316		Larry Yetto		07-mar-1983
{		Add WCB$V_JDB field to WCB$B_JNL_STAT
{
{	V03-032	WMC0001		Wayne Cardoza		06-Mar-1983
{		Add UAF$B_MAXDETACH
{
{	V03-031	JSV0161		Joost Verhofstad	28-FEB-1983
{		Add VCB$L_JNLIOCNT
{
{	V03-030	RLRMXBCNT	Robert L. Rappaport	24-Feb-1982
{		Add UCB$L_MAXBCNT.
{
{	V03-029 MSH0002		Maryann Hinden		24-Feb-1983
{		Add $SPNBDEF.
{
{	V03-028	ROW0139		Ralph O. Weber		18-FEB-1983
{		Move JNL_CLS and JNL_SLV to UCB$W_DEVSTS.  Overlay UCB$L_PDT 
{		with UCB$L_JNL_MCSID.  Remove UCB$W_JNL_CHAR, UCB$L_JNL_CDT, 
{		UCB$L_SCSFL, and UCB$L_SCSBL journal UCB extension.
{
{	V03-027 RSH0005		R. Scott Hanna		10-Feb-1983
{		Added $RDIDEF which defines the rights database
{		identifier block offsets.
{
{	V03-026	TCM0003		Trudy C. Matthews	9-Feb-1983
{		Added new VMB input flags to $RPBDEF: AUTOTEST and CRDTEST.
{
{	V03-025	SRB0065		Steve Beckhardt		21-Jan-1983
{		Added new resource CLUSTRAN to $RSNDEF.
{
{	V03-024	DWT0067		David W. Thiel		20-Jan-1983
{		Add $SPPBDEF.  Add fields to $SBDEF.
{
{	V03-023	CDS0002		Christian D. Saether	27-Dec-1982
{		Move WCB$L_ACCLKID to avoid ambush by inexplicit assumptions.
{
{	V03-022	STJ3045		Steven T. Jeffreys	16-Dec-1982
{		Add $SLVDEF macro definition.
{
{	V03-021	SRB0057		Steve Beckhardt		16-Dec-1981
{		Added some new fields and reordered others in $RSBDEF
{		for distributed lock manager support.
{
{	V03-020	CDS0001		Christian D. Saether	9-Dec-1982
{		Add WCB$L_ACCLKID.
{
{	V03-019	ACG0303		Andrew C. Goldstein,	9-Dec-1982  15:13
{		Add FILL attribute to extraneous names
{
{	V03-018	NPK3010		N. Kronenberg	15-Nov-1982
{		Modify $SBDEF to add node name, hardware type and version,
{		and DDB pointer.  Add $SBODEF and $SYSAPDEF.
{
{	V03-017	MMD0001		Meg Dumont,	11-Nov-1982  14:42
{		Add bit inMODE field of VCBDEF to allow users to 
{		enable EOT handling in the MTAACP.
{
{	  V03-016 TCM0002		Trudy C. Matthews	31-Oct-1982
{		  Add new field to Restart Parameter Block: RPB$L_BADPGS.
{
{	  V03-015 KTA0017		Kerbey T. Altmann	21-Oct-1982
{		  Add new fields to SCS system block.
{
{	  V03-014 CWH0014		CW Hobbs		20-Oct-1982
{		  Add some warnings to $WSLDEF about strange constants
{
{	  V03-013 JSV0081		Joost Verhofstad	8-Oct-1982
{		  Add WCB$L_JNL_PUIC
{
{	  V03-012 SRB0054		Steve Beckhardt		6-Oct_1982
{		  Added new resource for SCS waits in RSNDEF.
{
{	  V03-011 JSV0068		 Joost Verhofstad	 22-Sep-1982
{		  Add some journaling specific WCB fields and change the fixed
{		  constants produced by conversion routines from MDL, into
{		  computed constants for the WCB and VCB.
{	
{
{	  V03-010 ROW0122		 Ralph O. Weber		 12-SEP-1982
{		  Work over the UCB definition.  Change machined SDL into 
{		  human senseable SDL.  Extend UCB$W_STS to a longword, 
{		  defining UCB$L_STS.  Add a spare word for alignment after 
{		  UCB$W_DEVSTS.  Move UCB$L_DEVDEPND2 next to UCB$L_DEVDEPEND 
{		  and create UCB$Q_DEVDEPEND.
{
{        V03-009 JSV0063                Joost Verhofstad        09-Sep-1982
{                Change names of symbols that existed in V3.0 and
{		  are used for journaling and have changed. This is 
{		  to allow builds of journaling facilities on both
{		  the latest system and V3.0 (for early field test)
{
{	  V03-008 MSH0001		 Maryann Hinden		 09-Sep-1982
{		  Add UAS definitions.
{
{        V03-006 JSV0031                Joost Verhofstad        27-Jul-1982
{                Add some UCB and WCB fields for journaling
{
{        V03-005 JSV0022                Joost Verhofstad        16-Jul-1982
{                Include errorlog UCB fields in journal UCB
{
{        V03-005 JSV0019                Joost Verhofstad        12-Jul-1982
{                Add UCB$V_KNOWN_JNL
{
{        V03-004 LY0027                Larry Yetto                29-Jun-1982
{                Define UCB$L_JNL_NDL to be the same as UCB$L_JNL_ASID
{
{        V03-003        JSV008                Joost Verhofstad        10-Jun-1982
{                Add UCB, VCB and WCB fields for journals
{
{        V03-002        KTA0100                Kerbey T. Altmann        07-Jun-1982
{                Add field MEDIA_ID to UCB.
{
{        V03-001        KDM0078                Kathleen D. Morse        15-Mar-1982
{                Add RPB$V_FINDMEM flag, for 11/782 installations.
{
{**

module $RBMDEF;
/*+
/* RBM        - realtime bit map of SPTs available for real time processes
/*-



aggregate RBMDEF structure prefix RBM$;
    STARTVPN longword unsigned;				/* Starting VPN of bit map. 
    FREECOUNT longword unsigned;			/* Number of free SPTs. 
    SIZE word unsigned;					/* Size of control block. 
    TYPE byte unsigned;					/* Type of control block. 
    FILL_1 byte fill prefix RBMDEF tag $$;		/* Spare byte. 
    constant "LENGTH" equals . prefix RBM$ tag K;	/* Length of block so far. 
    constant "LENGTH" equals . prefix RBM$ tag C;	/* Length of block so far. 
    BITMAP longword unsigned;				/* Start of bit map. 
    
end RBMDEF;

end_module $RBMDEF;


module $RDIDEF;
/*++
/* Rights Database Identifier Block definitions: This structure contains the
/* RMS Internal File Identifiers (IFI's) and Internal Stream Identifiers
/* (ISI's) for the rights database. This structure is allocated from the
/* process allocation region pool.
/*--

aggregate RDIDEF structure prefix RDI$;

    #ISI_MAX = 10;
    constant ISI_MAX equals #ISI_MAX;	/* Maximum number of concurrent record streams

    SIZE longword unsigned;		/* Size of allocated block
    IFI_READ longword unsigned;		/* Internal File Identifier for read operations
    IFI_WRITE longword unsigned;	/* Internal File Identifier for write operations
    ISI_VEC longword unsigned dimension 0:#ISI_MAX; /* Internal Stream Identifier vector

end RDIDEF;

end_module $RDIDEF;

module $RDPDEF;
/*
/* REMOTE DEVICE PROTOCOL DEFINITIONS
/*


aggregate RDPDEF structure prefix RDP$;
    OPCODE word unsigned;				/*OPERATION CODE 
    MOD word unsigned;					/*OPERATION CODE MODIFIERS 
    REFID longword unsigned;				/*REFERENCE ID 
    UNIT_OVERLAY union fill;
        UNIT word unsigned;				/*DEVICE UNIT NUMBER 
        constant HEADERLEN equals . prefix RDP$ tag K;	/*HEADER LENGTH 
        constant HEADERLEN equals . prefix RDP$ tag C;	/*HEADER LENGTH 
        SIZE word unsigned;				/*SIZE OF MESSAGE (ACP/DRIVER USE ONLY) 
    end UNIT_OVERLAY;
    PARAM1 longword unsigned;				/*PARAMETER 1 
    PARAM2 longword unsigned;				/*PARAMETER 2 
    PARAM3 longword unsigned;				/*PARAMETER 3 
    PARAM4 longword unsigned;				/*PARAMETER 4 
    PARAM5 longword unsigned;				/*PARAMETER 5 
    PARAM6 longword unsigned;				/*PARAMETER 6 
/*
/* RESPONSE FROM REMOTE PACKET DEFINITIONS
/*
    	 						/*RESPONSE PACKET OPCODES 
    constant(
          ATTN						/* ATTENTION 
        , "END"						/* I/O REQUEST COMPLETE 
        , LOG						/* ERROR LOG 
        ) equals -1 increment -1  prefix RDP tag $C;
end RDPDEF;

aggregate RDPDEF1 structure prefix RDP$;
    FILL_3 byte dimension 10 fill prefix RDPDEF tag $$;
    STATUS quadword unsigned;				/*END PACKET I/O STATUS 
/*
/* TERMINAL SPECIFIC PARAMETER DEFINITIONS
/*
/*  READ/WRITE REQUEST
end RDPDEF1;

aggregate RDPDEF2 structure prefix RDP$;
    FILL_4 byte dimension 10 fill prefix RDPDEF tag $$;
    TT_BCNT longword unsigned;				/*BYTE COUNT 
    TT_CARCON_OVERLAY union fill;
        TT_CARCON longword unsigned;			/*WRITE CARRIAGE CONTROL 
        TT_TIMOUT longword unsigned;			/*READ TIMEOUT 
    end TT_CARCON_OVERLAY;
    TT_WDATA_OVERLAY union fill;
        TT_WDATA character;				/*WRITE DATA 
        TT_TERM character;				/*BYTE OF SIZE + TERMINATOR MASK 
                                                	/*WORD OF SIZE + PROMPT STRING
/* SET MODE/CHARACTERISTICS REQUEST
    end TT_WDATA_OVERLAY;
end RDPDEF2;

aggregate RDPDEF3 structure prefix RDP$;
    FILL_5 byte dimension 10 fill prefix RDPDEF tag $$;
    TT_CHAR_OVERLAY union fill;
        TT_CHAR quadword unsigned;			/*CHARACTERISTICS 
        TT_ASTPRM longword unsigned;			/*AST PARAMETER 
    end TT_CHAR_OVERLAY;
    TT_SPEED longword unsigned;				/*LINE SPEED 
    TT_FILL longword unsigned;				/*FILL SPECIFIER 
    TT_PARITY longword unsigned;			/*PARITY FLAGS 
    TT_CHAR2 longword unsigned;				/* Remaining longword of characters 
/*  READ REQUEST END PACKET
end RDPDEF3;

aggregate RDPDEF4 structure prefix RDP$;
    FILL_6 byte dimension 10 fill prefix RDPDEF tag $$;
    FILL_1 quadword fill prefix RDPDEF tag $$;		/*I/O STATUS 
    TT_RDATA character;					/*WORD OF SIZE + READ DATA 
/*  SENSE MODE/CHARACTERISTICS END PACKET
end RDPDEF4;

aggregate RDPDEF5 structure prefix RDP$;
    FILL_7 byte dimension 10 fill prefix RDPDEF tag $$;
    FILL_2 quadword fill prefix RDPDEF tag $$;		/*I/O STATUS 
    TT_SCHAR quadword unsigned;				/*SENSED CHARACTERISTICS 
    TT_SCHAR2 longword unsigned;			/* Additional longword of characters 
    
/* Broadcast message attention packet
end RDPDEF5;

aggregate RDPDEF6 structure prefix RDP$;
    FILL_8 byte dimension 10 fill prefix RDPDEF tag $$;
    TT_BRDTOTSIZE word unsigned;			/* Total size of data 
    TT_BRDMSG word unsigned;				/* Message code 
    TT_BRDUNIT word unsigned;				/* Unit number 
    TT_BRDNAME character length 16;			/* Device name as counted string 
    constant TT_BRDNAME	equals 16  prefix RDP tag $C;	/* Size of name field 
    TT_BRDTXTSIZE_OVERLAY union fill;
        TT_BRDTXTSIZE word unsigned;			/* Count for message text 
	TT_BRDTXTSIZE_FIELDS structure fill;
            FILL_9 byte dimension 2 fill prefix RDPDEF tag $$;
            TT_BRDTEXT character length 0 tag T;	/* Message text start 
            
/* Out of band attention packet
            
	end TT_BRDTXTSIZE_FIELDS;
    end TT_BRDTXTSIZE_OVERLAY;
end RDPDEF6;

aggregate RDPDEF7 structure prefix RDP$;
    FILL_10 byte dimension 10 fill prefix RDPDEF tag $$;
    TT_OUTBAND byte unsigned;				/* Out of band character 
    
/* ATTENTION PACKET MODIFIERS
    constant(
          TT_UNSOL					/*UNSOLICITED DATA 
        , TT_HANGUP					/*MODEM HANGUP 
        , TT_CTRLC					/*CONTROL/C 
        , TT_CTRLY					/*CONTROL/Y 
        , TT_STARTRCV					/* Start a receive to the net 
        , TT_BRDCST					/* Broadcast message for mailbox 
        , TT_OUTBAND					/* Out of band AST 
        ) equals 0 increment 1 prefix RDP tag $C;
    
end RDPDEF7;

end_module $RDPDEF;


module $RBFDEF;
/*
/*        Remote buffer as stored in dynamic memory
/*
/*        This structure must be identical to the above structure except
/*        for the header, which is the header for a buffered io buffer.
/*


/*
/*        Buffered io buffer header
/*


aggregate RBFDEF structure prefix RBF$;
    MSGDAT longword unsigned;				/* Address of message data 
    USRBFR longword unsigned;				/* User buffer address 
    SIZE word unsigned;					/* Size of structure 
    TYPE byte unsigned;					/* Type of structure, DYN$C_BUFIO 
    SPARE byte unsigned;				/* Alignment 
    DATSIZE word unsigned;				/* Data size 
    
/*
/*        End of header
/*
    
    OPCODE word unsigned;				/*OPERATION CODE 
    MOD word unsigned;					/*OPERATION CODE MODIFIERS 
    REFID longword unsigned;				/*REFERENCE ID 
    UNIT word unsigned;					/*DEVICE UNIT NUMBER 
/*        S        SIZE,0,W                /*SIZE OF MESSAGE (ACP/DRIVER USE ONLY)
    constant HEADERLEN equals . prefix RBF$ tag K;	/*HEADER LENGTH 
    constant HEADERLEN equals . prefix RBF$ tag C;	/*HEADER LENGTH 
    PARAM1 longword unsigned;				/*PARAMETER 1 
    PARAM2 longword unsigned;				/*PARAMETER 2 
    PARAM3 longword unsigned;				/*PARAMETER 3 
    PARAM4 longword unsigned;				/*PARAMETER 4 
    PARAM5 longword unsigned;				/*PARAMETER 5 
    PARAM6 longword unsigned;				/*PARAMETER 6 
/*
/* RESPONSE FROM REMOTE PACKET DEFINITIONS
/*
    	 						/*RESPONSE PACKET OPCODES 
    constant(
          ATTN						/* ATTENTION 
        , "END"						/* I/O REQUEST COMPLETE 
        , LOG						/* ERROR LOG 
        ) equals -1 increment -1  prefix RBF tag $C;
end RBFDEF;

aggregate RBFDEF1 structure prefix RBF$;
    FILL_3 byte dimension 24 fill prefix RBFDEF tag $$;
    STATUS quadword unsigned;				/*END PACKET I/O STATUS 
/*
/* TERMINAL SPECIFIC PARAMETER DEFINITIONS
/*
/*  READ/WRITE REQUEST
end RBFDEF1;

aggregate RBFDEF2 structure prefix RBF$;
    FILL_4 byte dimension 24 fill prefix RBFDEF tag $$;
    TT_BCNT longword unsigned;				/*BYTE COUNT 
    TT_CARCON_OVERLAY union fill;
        TT_CARCON longword unsigned;			/*WRITE CARRIAGE CONTROL 
        TT_TIMOUT longword unsigned;			/*READ TIMEOUT 
    end TT_CARCON_OVERLAY;
    TT_WDATA_OVERLAY union fill;
        TT_WDATA character;				/*WRITE DATA 
        TT_TERM character;				/*BYTE OF SIZE + TERMINATOR MASK 
                                                	/*WORD OF SIZE + PROMPT STRING
/* SET MODE/CHARACTERISTICS REQUEST
    end TT_WDATA_OVERLAY;
end RBFDEF2;

aggregate RBFDEF3 structure prefix RBF$;
    FILL_5 byte dimension 24 fill prefix RBFDEF tag $$;
    TT_CHAR_OVERLAY union fill;
        TT_CHAR quadword unsigned;			/*CHARACTERISTICS 
        TT_ASTPRM longword unsigned;			/*AST PARAMETER 
    end TT_CHAR_OVERLAY;
    TT_SPEED longword unsigned;				/*LINE SPEED 
    TT_FILL longword unsigned;				/*FILL SPECIFIER 
    TT_PARITY longword unsigned;			/*PARITY FLAGS 
    TT_CHAR2 longword unsigned;				/* Another longword of characters 
/*  READ REQUEST END PACKET
end RBFDEF3;

aggregate RBFDEF4 structure prefix RBF$;
    FILL_6 byte dimension 24 fill prefix RBFDEF tag $$;
    FILL_1 quadword fill prefix RBFDEF tag $$;		/*I/O STATUS 
    TT_RDATA character;					/*WORD OF SIZE + READ DATA 
/*  SENSE MODE/CHARACTERISTICS END PACKET
end RBFDEF4;

aggregate RBFDEF5 structure prefix RBF$;
    FILL_7 byte dimension 24 fill prefix RBFDEF tag $$;
    FILL_2 quadword fill prefix RBFDEF tag $$;		/*I/O STATUS 
    TT_SCHAR quadword unsigned;				/*SENSED CHARACTERISTICS 
    TT_SCHAR2 longword unsigned;			/* Another longword of characters 
    
/* Broadcast message attention packet
end RBFDEF5;

aggregate RBFDEF6 structure prefix RBF$;
    FILL_8 byte dimension 24 fill prefix RBFDEF tag $$;
    TT_BRDTOTSIZE word unsigned;			/* Total size of data 
    TT_BRDMSG word unsigned;				/* Message code 
    TT_BRDUNIT word unsigned;				/* Unit number 
    TT_BRDNAME character length 16;			/* Device name as counted string 
    constant TT_BRDNAME	equals 16  prefix RBF tag $C;	/* Size of name field 
    TT_BRDTXTSIZE_OVERLAY union fill;
        TT_BRDTXTSIZE word unsigned;			/* Count for message text 
	TT_BRDTXTSIZE_FIELDS structure fill;
            FILL_9 byte dimension 2 fill prefix RBFDEF tag $$;
            TT_BRDTEXT character length 0 tag T;	/* Message text start 
            
/* Out of band attention packet
            
	end TT_BRDTXTSIZE_FIELDS;
    end TT_BRDTXTSIZE_OVERLAY;
end RBFDEF6;

aggregate RBFDEF7 structure prefix RBF$;
    FILL_10 byte dimension 24 fill prefix RBFDEF tag $$;
    TT_OUTBAND byte unsigned;				/* Out of band character 
    
/* ATTENTION PACKET MODIFIERS
    constant(
          TT_UNSOL					/*UNSOLICITED DATA 
        , TT_HANGUP					/*MODEM HANGUP 
        , TT_CTRLC					/*CONTROL/C 
        , TT_CTRLY					/*CONTROL/Y 
        , TT_STARTRCV					/* Start a receive to the net 
        , TT_BRDCST					/* Broadcast message for mailbox 
        , TT_OUTBAND					/* Out of band AST 
        ) equals 0 increment 1 prefix RBF tag $C;
    
end RBFDEF7;

end_module $RBFDEF;


module $RCTDEF;
/*+
/* RCT - Replacement and Caching Table sector !0 layout.
/*        The RCT is a structure residing on disks controlled by MSCP
/*        speaking disk controllers.  The RCT is maintained by the intelligent
/*        controllers and the disk class driver.  The disk class driver mainly
/*        gets involved in RCT manipulations during host initiated bad
/*        block replacement.



aggregate RCTDEF structure prefix RCT$;
    VOLSER quadword unsigned;				/* Volume serial number 
    FLAGS_OVERLAY union fill;
        FLAGS word unsigned;				/* Flags word 
	FLAGS_BITS structure fill;
            WB bitfield mask;				/* Write back caching in use 
            FILL_1 bitfield length 6 fill prefix RCTDEF tag $$;
            FE bitfield mask;				/* Forced Error flag for block being replaced 
            FILL_2 bitfield length 5 fill prefix RCTDEF tag $$;
            BR bitfield mask;				/* Replacement caused by Bad RBN 
	    RP2 bitfield mask;				/* Replacement in Progress phase 2 
	    RP1 bitfield mask;				/* Replacement in Progress phase 1 
	end FLAGS_BITS;
    end FLAGS_OVERLAY;
    FILL_3 word fill prefix RCTDEF tag $$;		/* Reserved word 
    LBN longword unsigned;				/* LBN curently being replaced. 
    RBN longword unsigned;				/* RBN allocated to replace LBN 
    BAD_RBN longword unsigned;				/* If BR flag, RBN of bad replacement block 
    WB_CTRL quadword unsigned;				/* Serial ! of last controller doing Write back 
    WB_INCAR longword unsigned;				/* Write back incarnation ! 
    INCARTIME_OVERLAY union fill;
        INCARTIME quadword unsigned;			/* Date-time of last update of incarnation no. 
/*
/* Structure of a Replacement Block Descriptor
/*
	INCARTIME_BITS0 structure fill;
            LBN bitfield mask length 28;		/* Space for LBN replaced by this RBN 
            CODE bitfield mask length 4;		/* Describes how this descriptor being used 
	end INCARTIME_BITS0;
        
	INCARTIME_BITS1 structure fill;
            FILL_4 bitfield length 28 fill prefix RCTDEF tag $$;/* LBN 
            NONPRIME bitfield mask;			/* Set implies allocated, but not prime RBN 
            ALLOCATED bitfield mask;			/* This RBN allocated 
            UNUSABLE bitfield mask;			/* This RBN unusable 
            NULL bitfield mask;				/* This marks a NULL entry 
	end INCARTIME_BITS1;
        	 					/* Values of CODE 
        constant EMPTY	equals 0  prefix RCT tag $K;	/* Unallocated (empty) replacement block 
        constant ALOCPRIME	equals 2  prefix RCT tag $K;/* Allocated replace blk - primary RBN 
        constant ALOCNONP	equals 3  prefix RCT tag $K;/* Allocated replace blk - non-primary RBN 
        constant UNUSABLE	equals 4  prefix RCT tag $K;/* Unusable replacement block 
        constant ALTUNUSE	equals 5  prefix RCT tag $K;/* Alternate unusable replacement block 
        constant NULL	equals 8  prefix RCT tag $K;	/* Null entry - no corresponding RBN sector 
    end INCARTIME_OVERLAY;
end RCTDEF;

end_module $RCTDEF;

module $RDTDEF;
/*+
/* RDT - SCS RESPONSE DESCRIPTOR TABLE
/*
/* ONE RESPONSE DESCRIPTOR (RD) IS ALLOCATED FOR EACH SCS MESSAGE
/* SENT FOR WHICH THE SENDER EXPECTS A MATCHING RESPONSE.
/*-



aggregate RDTDEF structure prefix RDT$ origin FILL_2;
    WAITFL longword unsigned;				/*RD WAIT QUEUE FWD LINK 
    WAITBL longword unsigned;				/*RD WAIT QUEUE BACK LINK 
    SIZE word unsigned;					/*STRUCTURE SIZE IN BYTES 
    TYPE byte unsigned;					/*SCS STURCTURE TYPE 
    SUBTYP byte unsigned;				/*SCS STRUCT SUBTYPE FOR RDT 
    FREERD longword unsigned;				/*ADDR OF 1ST FREE RD 
    MAXRDIDX longword unsigned;				/*MAXIMUM ! OF DESCRIPTORS 
    FILL_1 longword fill prefix RDTDEF tag $$;		/*RESERVED FOR FUTURE USE 
    constant "LENGTH"	equals 24  prefix RDT tag $C;	/*LENGTH OF NEG PORTION OF STRUCTURE 
/*
    FILL_2 byte fill prefix RDTDEF tag $$;
end RDTDEF;

end_module $RDTDEF;


module $RDDEF;
/*+
/* RD - SCS RESPONSE DESCRIPTOR FORMAT
/*-



aggregate RDDEF structure prefix RD$;
    CDRP_OVERLAY union fill;
        CDRP longword unsigned;				/*ADDR OF ASSOC CDRP OR 
                                                	/* OR OTHER CONTEXT BLOCK
        LINK longword unsigned;				/* OR LINK TO NEXT FREE RD 
    end CDRP_OVERLAY;
    STATE_OVERLAY union fill;
        STATE word unsigned;				/*RD STATE FLAGS 
	STATE_BITS structure fill;
            BUSY bitfield;				/* ALLOCATED IF SET 
            PERM bitfield;				/* PERMANENTLY ALLOCATED RD IF SET 
	end STATE_BITS;
    end STATE_OVERLAY;
    SEQNUM word unsigned;				/*SEQUENCE NUMBER OF RD 
    constant "LENGTH" equals . prefix RD$ tag K;	/*LENGTH OF RD 
    constant "LENGTH" equals . prefix RD$ tag C;	/*LENGTH OF RD 
    
end RDDEF;

end_module $RDDEF;



module $RPBDEF;
/*+
/* RESTART PARAMETER BLOCK DEFINITIONS
/*-

aggregate RPBDEF structure prefix RPB$;
    BASE longword unsigned;				/*PHYSICAL BASE ADDRESS OF 64K BLOCK 
    RESTART longword unsigned;				/*POINTER TO RESTART ROUTINE (PHYSICAL) 
    CHKSUM longword unsigned;				/*CHECKSUM OF BYTES 0-7F OF RESTART ROUTINE 
    RSTRTFLG longword unsigned;				/*RESTART IN PROGRESS FLAG 
    HALTPC longword unsigned;				/*PC AT RESTART/HALT 
    HALTPSL longword unsigned;				/*PSL AT RESTART/HALT 
    HALTCODE longword unsigned;				/*CODE DESCRIBING RESTART REASON 
    BOOTR0_OVERLAY union fill;
        BOOTR0 longword unsigned;			/*SAVED BOOT PARAMETER R0 
	BOOTR0_FIELDS structure fill;
            R0DEVTYP byte unsigned;			/* DEVICE TYPE SUBFIELD 
            FILL_1 byte fill prefix RPBDEF tag $$;	/* RESERVED 
            R0UBVEC word unsigned;			/* UNIBUS INT VECTOR SUBFIELD 
	end BOOTR0_FIELDS;
    end BOOTR0_OVERLAY;
    BOOTR1_OVERLAY union fill;
        BOOTR1 longword unsigned;			/*SAVED BOOT PARAMETER R1 
	BOOTR1_BITS structure fill;
            NEXUS bitfield length 4;			/*NEXUS OF SYSTEM DEVICE ADAPTER 
            ABUS bitfield length 2;			/*ABUS ADAPTER NUMBER OF SBIA 
	end BOOTR1_BITS;
    end BOOTR1_OVERLAY;
    BOOTR2 longword unsigned;				/*SAVED BOTT PARAMETER R2 
    BOOTR3 longword unsigned;				/*SAVED BOOT PARAMETER R3 
    BOOTR4 longword unsigned;				/*SAVED BOOT PARAMETER R4 
    BOOTR5_OVERLAY union fill;
        BOOTR5 longword unsigned;			/*SAVED BOOT PARAMETER R5 
	BOOTR5_BITS structure fill;
            CONV bitfield;				/* CONVERSATIONAL BOOTSTRAP 
            DEBUG bitfield;				/* KEEP DEBUGGER CODE 
            INIBPT bitfield;				/* INITIAL BREAKPOINT 
            BBLOCK bitfield;				/* TRANSFER TO BOOTBLOCK 
            DIAG bitfield;				/* BOOT DIAGNOSTIC FILE 
            BOOBPT bitfield;				/* BOOTSTRAP BREAKPOINT 
            HEADER bitfield;				/* USE START ADDRESS FROM IMAGE HEADER 
            NOTEST bitfield;				/* FLAG TO INHIBIT MEMORY TESTING 
            SOLICT bitfield;				/* SOLICIT BOOT FILE NAME 
            HALT bitfield;				/* HALT BEFORE TRANSFER 
            NOPFND bitfield;				/* INHIBIT PFN DELETION 
            MPM bitfield mask;				/* MULTI-PROCESSOR BOOT, USE MA780 ONLY 
            USEMPM bitfield mask;			/* USE MA780 AS IF IT WERE LOCAL MEMORY 
            MEMTEST bitfield mask;			/* USE STRICTER TEST TO VALIDATE MEMORY 
            FINDMEM bitfield mask;			/* FIND SUFFICIENT MEMORY TO BOOT (>512K) 
	    AUTOTEST bitfield mask;			/* USED BY DIAGNOSTIC SUPERVISOR
	    CRDTEST bitfield mask;			/* REMOVE PAGES WITH CRD ERRORS
            FILL_2 bitfield length 11 fill prefix RPBDEF tag $$;
            TOPSYS bitfield mask length 4;		/*SYSTEM DIRECTORY NUMBER 
	end BOOTR5_BITS;
    end BOOTR5_OVERLAY;
    IOVEC longword unsigned;				/*ADDRESS OF BOOTSTRAP QIO VECTOR 
    IOVECSZ longword unsigned;				/*SIZE OF BOOT QIO ROUTINE 
    FILLBN longword unsigned;				/*LOGICAL BLOCK NUMBER OF BOOT FILE 
    FILSIZ longword unsigned;				/*SIZE OF BOOT FILE 
    PFNMAP quadword unsigned;				/*DESCRIPTOR FOR PFN BITMAP 
    PFNCNT longword unsigned;				/*COUNT OF PHYSICAL PAGES 
    SVASPT longword unsigned;				/*SYSTEM VIRTUAL ADDRESS OF SPT 
    CSRPHY longword unsigned;				/*UBA DEVICE CSR ADDRESS (PHYSICAL) 
    CSRVIR longword unsigned;				/*UBA DEVICE CSR ADDRESS (VIRTUAL) 
    ADPPHY longword unsigned;				/*ADAPTER CONFIGURATION REGISTER (PHYSICAL) 
    ADPVIR longword unsigned;				/*ADAPTER CONFIGURATION REGISTER (VIRTUAL) 
    UNIT word unsigned;					/*UNIT NUMBER 
    DEVTYP byte unsigned;				/*DEVICE TYPE CODE 
    SLAVE byte unsigned;				/*SLAVE UNIT NUMBER 
    FILE character length 40;				/*BOOT FILE NAME (ASCIC) 
    CONFREG byte unsigned dimension 16;			/*ARRAY OF ADAPTER TYPES 
    HDRPGCNT byte unsigned;				/*COUNT OF HEADER PAGES 
    BOOTNDT_OVERLAY union fill;
	BOOTNDT word unsigned;				/*16-BIT BOOT ADAPTER NEXUS DEVICE TYPE
	BOOTNDT byte unsigned;				/* 8-BIT BOOT ADAPTER NEXUS DEVICE TYPE
    end BOOTNDT_OVERLAY;
    FLAGS structure byte unsigned;			/*MISCELLANEOUS FLAG BITS
	NOSYSDISK bitfield mask;			/* BOOT DISK IS NOT PRESENT
    end FLAGS;
    ISP longword unsigned;				/*PWR FAIL INTERRUPT STACK POINTER 
    PCBB longword unsigned;				/*PROCESS CONTROL BLOCK BASE 
    SBR longword unsigned;				/*SYSTEM BASE REGISTER 
    SCBB longword unsigned;				/*SYSTEM CONTROL BLOCK BASE 
    SISR longword unsigned;				/*SOFTWARE INTERRUPT SUMMARY REGISTER 
    SLR longword unsigned;				/*SYSTEM LENGTH REGISTER 
    MEMDSC_OVERLAY union fill;
        MEMDSC longword unsigned dimension 16;		/*MEMORY DESCRIPT. - PAGCNT, TR, BASE PFN 
	MEMDSC_BITS structure fill;
            PAGCNT bitfield length 24;			/* COUNT OF PAGES FOR THIS MEMORY 
            TR bitfield length 8;			/* TR NUMBER FOR THIS MEMORY 
            BASEPFN bitfield length 32;			/* BASE PFN FOR THIS MEMORY 
	end MEMDSC_BITS;
        constant MEMDSCSIZ	equals 8  prefix RPB tag $C;/*NUMBER OF BYTES IN ONE MEM DESCRIPTOR 
        constant NMEMDSC	equals 8  prefix RPB tag $C;/*NUMBER OF MEMORY DESCRIPTORS IN RPB 
    end MEMDSC_OVERLAY;
    BUGCHK longword unsigned;				/*BUGCHECK LOOP ADDRESSS FOR MP SECONDARY 
    WAIT byte unsigned dimension 4;			/*BUGCHECK LOOP CODE FOR MP SECONDARY 
    BADPGS longword unsigned;				/*NUMBER OF BAD PAGES FOUND IN MEM SCAN
    CTRLLTR byte unsigned;				/*CONTROLLER LETTER DESIGNATOR
    constant "LENGTH" equals . prefix RPB$ tag K;	/*LENGTH OF RPB 
    constant "LENGTH" equals . prefix RPB$ tag C;	/*LENGTH OF RPB 
end RPBDEF;

end_module $RPBDEF;


module $RSBDEF;
/*+
/* RSB - RESOURCE BLOCK
/*
/* RESOURCE BLOCKS REPRESENT RESOURCES FOR WHICH THERE ARE LOCKS OUTSTANDING.
/* EACH RESOURCE BLOCK MAY HAVE ONE OR MORE LOCK BLOCKS (LKB) QUEUED TO IT.
/*-



aggregate RSBDEF structure prefix RSB$;
    HSHCHN longword unsigned;			/*HASH CHAIN 
    HSHCHNBK longword unsigned;			/*HASH CHAIN BACK POINTER 
    SIZE word unsigned;				/*SIZE OF RSB 
    TYPE byte unsigned;				/*STRUCTURE TYPE 
    DEPTH byte unsigned;			/*DEPTH IN TREE 
    GGMODE byte unsigned;			/*GROUP GRANT MODE 
    CGMODE byte unsigned;			/*CONVERSION GRANT MODE 
    STATUS_OVERLAY union fill;
	STATUS word unsigned;			/*STATUS
	STATUS_BITS structure fill;
    	    DIRENTRY bitfield mask;		/* ENTERED IN DIR. DURING FAILOVER
	    VALINVLD bitfield mask;		/* VALUE BLOCK INVALID
	end STATUS_BITS;
    end STATUS_OVERLAY;
    GRQFL longword unsigned;			/*GRANTED QUEUE FORWARD LINK 
    GRQBL longword unsigned;			/*GRANTED QUEUE BACKWARD LINK 
    CVTQFL longword unsigned;			/*CONVERSION QUEUE FORWARD LINK 
    CVTQBL longword unsigned;			/*CONVERSION QUEUE BACKWARD LINK 
    WTQFL longword unsigned;			/*WAIT QUEUE FORWARD LINK 
    WTQBL longword unsigned;			/*WAIT QUEUE BACKWARD LINK 
    VALBLK quadword unsigned;			/*VALUE BLOCK 
    FILL_1 quadword fill prefix RSBDEF tag $$;	/*MORE VALUE BLOCK 
    CSID longword unsigned;			/*SYSTEM ID OF MASTER SYS.
    VALSEQNUM longword unsigned;		/*VALUE BLOCK SEQ. NUMBER
    REFCNT word unsigned;			/*SUB RSB REFERENCE COUNT 
    BLKASTCNT word unsigned;			/*BLOCKING AST COUNT 
    HASHVAL word unsigned;			/*HASH VALUE
    RQSEQNM word unsigned;			/*REQUEST SEQUENCE NUMBER
    PARENT longword unsigned;			/*ADDRESS OF PARENT RSB 
    GROUP word unsigned;			/*GROUP NUMBER 
    RMOD byte unsigned;				/*ACCESS MODE OF RESOURCE 
    RSNLEN byte unsigned;			/*RESOURCE NAME LENGTH 
    constant "LENGTH" equals . prefix RSB$ tag K;	/*LENGTH OF FIXED PART OF RSB 
    constant "LENGTH" equals . prefix RSB$ tag C;	/*LENGTH OF FIXED PART OF RSB 
    RESNAM character length 0 tag T;			/*START OF RESOURCE NAME 
    constant MAXLEN equals 31  prefix RSB tag $K;	/*MAXIMUM LENGTH OF RESOURCE NAME 
end RSBDEF;

end_module $RSBDEF;


module $RSNDEF;
/*+
/* RESOURCE NAME DEFINITIONS
/*-

	 						/*0 ORIGIN IN INCREMENTS OF 1 
constant(
      ASTWAIT						/*WAIT FOR AST EVENT, CHANNEL INTERLOCK 
    , MAILBOX						/*MAILBOX SPACE 
    , NPDYNMEM						/*NON-PAGED DYNAMIC MEMORY 
    , PGFILE						/*PAGING FILE SPACE 
    , PGDYNMEM						/*PAGED DYNAMIC MEMORY 
    , BRKTHRU						/*TERMINAL BROADCAST 
    , IACLOCK						/*IMAGE ACTIVATION INTERLOCK 
    , JQUOTA						/*JOB POOLED QUOTA 
    , LOCKID						/*LOCKIDS 
    , SWPFILE						/*SWAPPING FILE SPACE 
    , MPLEMPTY						/*MODIFIED PAGE LIST EMPTY 
    , MPWBUSY						/*MODIFIED PAGE WRITER BUSY 
    , SCS						/*SYSTEM COMMUNICATION
    , CLUSTRAN						/*CLUSTER STATE TRANSITION
    , MAX						/*MAXIMUM RESOURCE NUMBER 
    ) equals 1 increment 1  prefix RSN tag $;

end_module $RSNDEF;

module $RUCBDEF;
/*+
/* Internal control block for use by Recovery Unit services.
/*
/* This structure is created when a process first issues a
/* RUF service and is pointed to by CTL$L_RUF.
/*-

aggregate RUCBDEF structure fill prefix RUCB$;
    RUID_OVERLAY union fill;
        RUID character length 16;			/* 128-bit id 
        constant ID_LEN equals . prefix RUCB$ tag K;	/* length of the ID 
        constant ID_LEN equals . prefix RUCB$ tag C;	/* length of the ID 
	RUID_FIELDS structure fill;
            ID_TIME quadword unsigned;			/* system time in 100ns. units
            ID_CSID longword unsigned;			/* cluster ID 
            ID_EPID longword unsigned;			/* cluster PID of initiating process 
	end RUID_FIELDS;
    end RUID_OVERLAY;
    RU_CTRL_OVERLAY union fill;
        RU_CTRL longword unsigned;			/* control longword 
	RU_CTRL_FIELDS structure fill;
            STATE byte unsigned;			/* RU current state 
            constant ACTIVE	equals 1  prefix RUCB tag $C;/* active 
            constant PH1_INIT	equals 2  prefix RUCB tag $C;/* phase 1 commit started 
            constant PH1_FIN	equals 3  prefix RUCB tag $C;/* phase 1 commit completed 
            constant PH2_INIT	equals 4  prefix RUCB tag $C;/* phase 2 commit started 
            constant PH2_FIN	equals 5  prefix RUCB tag $C;/* phase 2 commit completed 
            constant CANCEL	equals 6  prefix RUCB tag $C;/* cancel in progress 
            constant RESET	equals 7  prefix RUCB tag $C;/* reset to markpoint in progress 
	    CTRL_OVERLAY union fill;
                CTRL byte unsigned;			/* control flags 
		CTRL_BITS structure fill;
                    INIT bitfield mask;			/* RUCB has been initialized 
                    ACTIVE bitfield mask;		/* Recovery Unit is currently active 
                    INHANDLER bitfield mask;		/* processing handlers 
                    RUSYNC bitfield mask;		/* handler has specified synchronous RUs 
		end CTRL_BITS;
	    end CTRL_OVERLAY;
            SRVCODE word unsigned;			/* current operation change mode code 
	end RU_CTRL_FIELDS;
    end RU_CTRL_OVERLAY;
    HACTION longword unsigned;				/* handler action code 
    HREASON longword unsigned;				/* handler invocation reason code (see $RUHRSNDEF) 
    MARKPT longword unsigned;				/* most recent markpoint value 
    RUH_EXEC longword unsigned;				/* exec mode handler listhead 
    RUH_SUPV longword unsigned;				/* supervisor mode handler listhead 
    RUH_USER longword unsigned;				/* user mode handler listhead 
    SV_PCPSL quadword unsigned;				/* saved user's PC and PSL from original CHMK 
    SV_RSB longword unsigned;				/* saved return address from RUF$CALL_HANDLERS 
    FREESP longword unsigned;				/* free handler cell listhead 
    AILIST longword unsigned;				/* ptr to list of AI jnls touched in RU 
    BILIST longword unsigned;				/* ptr to list of BI jnls touched in RU 
    IMPURE longword unsigned;				/* ptr to impure storage area for ENDRU 
    AMODE byte unsigned;				/* mode of caller of RUF$START 
    SV_AMODE byte unsigned;				/* saved access mode (R4) from RUF$CALL_HANDLERS 
    FILL_1 byte dimension 2 fill prefix RUCBDEF tag $$;	/* spare 
    constant "LENGTH" equals . prefix RUCB$ tag K;	/* length of RUCB 
    constant "LENGTH" equals . prefix RUCB$ tag C;	/* length of RUCB 
end RUCBDEF;

end_module $RUCBDEF;


module $RUHDEF;
/*+
/*        Recovery Unit Handler storage cell definitions
/*-

aggregate RUHDEF structure fill prefix RUH$;
    LINK longword unsigned;				/* Next cell address ptr 
    ADDR longword unsigned;				/* Routine addr 
    PARAM longword unsigned;				/* Routine parameter 
    constant SIZE equals . prefix RUH$ tag K;		/* Size of cell 
    constant SIZE equals . prefix RUH$ tag C;		/* Size of cell 
end RUHDEF;

end_module $RUHDEF;


module $RVTDEF;
/*+
/* RVT - RELATIVE VOLUME TABLE
/*
/* A RELATIVE VOLUME MAPPING TABLE IS REQUIRED FOR EVERY MULTIVOLUME
/* STRUCTURE THAT IS MOUNTED IN A SYSTEM.
/*-



aggregate RVTDEF structure prefix RVT$;
    STRUCLKID longword unsigned;			/* LOCK ID OF VOLUME SET LOCK.
    REFC word unsigned;					/* REFERENCE COUNT 
    ACTIVITY word unsigned;				/* ACTIVITY COUNT/FLAG
    SIZE word unsigned;					/* SIZE OF RVT IN BYTES 
    TYPE byte unsigned;					/* STRUCTURE TYPE OF RVT 
    NVOLS byte unsigned;				/* NUMBER OF VOLUMES IN SET 
    STRUCNAME character length 12;			/* STRUCTURE (VOLUME SET) NAME 
    VLSLCKNAM character length 12;			/* Volume set lock name.
    BLOCKID longword unsigned;				/* Blocking lock id.
    ACB byte unsigned dimension 28;			/* ACB for blocking ast.
    constant "LENGTH" equals . prefix RVT$ tag K;	/* LENGTH OF STANDARD RVT 
    constant "LENGTH" equals . prefix RVT$ tag C;	/* LENGTH OF STANDARD RVT 
    UCBLST longword unsigned;				/* ADDRESSES OF THE RESPECTIVE UCB'S 
    constant MINSIZE	equals 18  prefix RVT tag $C;	/* MINIMUM NUMBER OF ENTRIES TO ALLOCATE 
    
end RVTDEF;

end_module $RVTDEF;


module $SBDEF;
/*+
/* SB - SCS SYSTEM BLOCK
/*
/* THE SB HAS INFORMATION ABOUT KNOWN SYSTEMS IN A CPU CLUSTER.
/*-



aggregate SBDEF structure prefix SB$;
    FLINK longword unsigned;				/*FWD LINK TO NEXT SB 
    BLINK longword unsigned;				/*BACK LINK TO PREVIOUS SB 
    SIZE word unsigned;					/*STRUCTURE SIZE IN BYTES 
    TYPE byte unsigned;					/*SCS STRUCTURE TYPE 
    SUBTYP byte unsigned;				/*SCS STRUCT SUBTYPE FOR SB 
    PBFL longword unsigned;				/*LINK TO NEXT PATH BLOCK 
    PBBL longword unsigned;				/*LINK TO PREVIOUS PATH BLOCK 
    PBCONNX longword unsigned;				/*ADDR OF NEXT PB TO USE FOR 
                                            		/* A CONNECTION
    SYSTEMID byte unsigned dimension 6;			/*SYSTEM ID 
    FILL_1 word fill prefix SBDEF tag $$;		/*RESERVED WORD 
    MAXDG word unsigned;				/*MAXIMUM DATAGRAM SIZE 
    MAXMSG word unsigned;				/*MAXIMUM MESSAGE SIZE 
    SWTYPE character length 4;				/*SOFTWARE TYPE, 1-4 CHAR 
    SWVERS character length 4;				/*SOFTWARE VERSION, 1-4 CHAR 
    SWINCARN quadword unsigned;				/*SOFTWARE INCARNATION # 
    HWTYPE character length 4;				/*HW TYPE; 1-4 CHAR, BLANK FILL
    HWVERS byte unsigned dimension 12;			/*HW VERSION #
    NODENAME character length 16;			/*SCS NODENAME, COUNTED ASCII STRING
    DDB longword unsigned;				/*DDB LIST HEAD
    TIMEOUT word;					/*SCA PROCESS POLLER, WAITING TIME REMAINING
    ENBMSK byte unsigned dimension 2;			/*SCA PROCESS POLLER, PROCESS ENABLE MASK
    CSB longword unsigned;				/*LINK TO NEWEST CLUSTER SYSTEM BLOCK
    constant "LENGTH" equals . prefix SB$ tag K;	/*LENGTH OF SB 
    constant "LENGTH" equals . prefix SB$ tag C;	/*LENGTH OF SB 
    
end SBDEF;

end_module $SBDEF;


module $SBODEF;
/*+
/* SBO - SCS CONFIG_SYS OUTPUT ARRAY FORMAT
/*
/* THE OUTPUT ARRAY RETURNED FROM CALL TO SCS$CONFIG_SYS.  DATA IS MOSTLY COPIED FROM 
/* THE SYSTEM BLOCK (SB) BEING LOOKED UP.
/*-



aggregate SBODEF structure prefix SBO$;
    SYSTEMID byte unsigned dimension 6;			/*SYSTEM ID
    FILL_1 word fill prefix SBODEF tag $$;		/*RESERVED WORD
    MAXDG word unsigned;				/*MAXIMUM DG SIZE
    MAXMSG word unsigned;				/*MAXIMUM MSG SIZE
    SWTYPE character length 4;				/*SW TYPE, 1-4 CHAR, BLNK FILL
    SWVERS character length 4;				/*SW VERSION, 1-4 CHAR, BLNK FILL
    SWINCARN quadword unsigned;				/*SW INCARNATION #
    HWTYPE character length 4;				/*HW TYPE, 1-4 CHAR BLNK FILL
    HWVERS byte unsigned dimension 12;			/*HW VERSION, 1-4 CHAR BLNK FILL
    NODENAME character length 16;			/*NODE NAME, COUNTED ASCII STRING
    constant VC1 equals . prefix SBO$ tag C;		/*START OF 12 BYTE SPECIFIER OF
    constant VC1 equals . prefix SBO$ tag K;		/* 1ST VC (PATH BLK) TO SYSTEM
    RSTATION1 byte unsigned dimension 6;		/*REMOTE STATION OF 1ST VC
    FILL_1 word fill prefix SBODEF tag $$;		/*RESERVED WORD
    LPORT1 character length 4;				/*LOCAL PORT NAME OF 1ST VC
    NXT_SYSID byte unsigned dimension 6;		/*ID OF NEXT SYSTEM IN CONFIGURATION
    FILL_1 word fill prefix SBODEF tag $$;		/*RESERVED WORD
    constant "LENGTH" equals . prefix SBO$ tag K;	/*LENGTH OF SBO ARRAY
    constant "LENGTH" equals . prefix SBO$ tag C;	/*LENGTH OF SBO ARRAY

end SBODEF;

end_module $SBODEF;

module $SCSDEF;
/*+
/* SCS MESSAGE DEFINITIONS
/*
/* THIS STRUCTURE DEFINES OFFSETS AND FIELDS WITHIN THE SCS PORTION OF
/* A CLUSTER MESSAGE.  OFFSETS ARE DEFINED RELATIVE TO THE START OF THE
/* APPLICATION DATA OR SCS CONTROL MESSAGE DATA.  THE FULL MESSAGE FORMAT
/* CONSISTS OF A PORT DRIVER LAYER HEADER (SEE STRUCTURE PPD) FOLLOWED
/* BY THE SCS HEADER LAYER FOLLOWED BY THE APPLICATION DATA OR SCS CONTROL
/* MESSAGE DATA.
/*-



aggregate SCSDEF structure prefix SCS$ origin MIN_CR;
    PPD byte unsigned dimension 16;			/*16 BYTES OF PPD HEADER 
    "LENGTH" word unsigned;				/*MESSAGE LENGTH (INCLUDES ALL 
                                            		/* BYTES FROM SCS$W_LENGTH ON,
                                            		/* NOT INCLUDING SCS$W_LENGTH)
                                            		/* (FIELD SHARED BY PPD)
    	 						/*DEFINE LENGTHS OF SCS CONTROL MSGS: 
    constant OVHD	equals 14  prefix SCS tag $C;	/* SCS LAYER OVERHEAD
    constant CON_REQL	equals 66  prefix SCS tag $C;	/* CONNECT_REQ LENGTH 
    constant CON_RSPL	equals 18  prefix SCS tag $C;	/* CONNECT_RSP LENGTH 
    constant ACCP_REQL	equals 66  prefix SCS tag $C;	/* ACCEPT_REQ LENGTH 
    constant ACCP_RSPL	equals 18  prefix SCS tag $C;	/* ACCEPT_RSP LENGTH 
    constant REJ_REQL	equals 18  prefix SCS tag $C;	/* REJECT_REQ LENGTH 
    constant REJ_RSPL	equals 14  prefix SCS tag $C;	/* REJECT_RSP LENGTH 
    constant DISC_REQL	equals 18  prefix SCS tag $C;	/* DISCONNECT_REQ LENGTH 
    constant DISC_RSPL	equals 14  prefix SCS tag $C;	/* DISCONNECT_RSP LENGTH 
    constant CR_REQL	equals 18  prefix SCS tag $C;	/* CREDIT_REQ LENGTH 
    constant CR_RSPL	equals 14  prefix SCS tag $C;	/* CREDIT_RSP LENGHT 
    FILL_1 word fill prefix SCSDEF tag $$;		/*WORD RESERVED FOR PPD LAYER 
    MTYPE word unsigned;				/*SCS MESSAGE TYPE 
                                            		/*SCS MESSAGE TYPE CODES:
    	 						/* 0 ORIGIN, INCREMENTS OF 1 
    constant(
          CON_REQ					/* CONNECT_REQ 
        , CON_RSP					/* CONNECT_RSP 
        , ACCP_REQ					/* ACCEPT_REQ 
        , ACCP_RSP					/* ACCEPT_RSP 
        , REJ_REQ					/* REJECT_REQ 
        , REJ_RSP					/* REJECT_RSP 
        , DISC_REQ					/* DISCONNECT_REQ 
        , DISC_RSP					/* DISCONNECT_RSP 
        , CR_REQ					/* CREDIT_REQ 
        , CR_RSP					/* CREDIT_RSP 
        , APPL_MSG					/* APPLICATION MESSAGE 
        , APPL_DG					/* APPLICATION DATAGRAM 
        ) equals 0 increment 1  prefix SCS tag $C;
    CREDIT word unsigned;				/*CREDIT BEING EXTENDED 
    DST_CONID longword unsigned;			/*DESTINATION (RECVING) CONNX ID 
    SRC_CONID longword unsigned;			/*SOURCE (SENDING) CONNX ID 
    constant APPL_BASE equals . prefix SCS$ tag K;	/*BASE OF APPLICTION MESSAGE DATA 
    constant APPL_BASE equals . prefix SCS$ tag C;	/*BASE OF APPLICTION MESSAGE DATA 
    MIN_CR word unsigned;				/*MINIMUM SEND CREDIT 
    STATUS word unsigned;				/*STATUS/REASON 
                                            		/*DEFINE STATUS/REASON CODES:
    constant STNORMAL equals 1 prefix SCS$ tag K;	/* NORMAL, SUCCESS
    constant STNORMAL equals 1 prefix SCS$ tag C;	/*
    constant STNOMAT  equals 10 prefix SCS$ tag K;	/* NO MATCHING LISTENER
    constant STNOMAT  equals 10 prefix SCS$ tag C;	/*
    constant STNORS   equals 18 prefix SCS$ tag K;	/* NO RESOURCES
    constant STNORS   equals 18 prefix SCS$ tag C;	/*
    constant STDISC   equals 25 prefix SCS$ tag K;	/* DISCONNECTED
    constant STDISC   equals 25 prefix SCS$ tag C;	/*
    constant STINSFCR equals 33 prefix SCS$ tag K;	/* INSUFF CREDIT
    constant STINSFCR equals 33 prefix SCS$ tag C;	/*

    constant CON_BASE equals . prefix SCS$ tag K;	/*BASE OF CONNECT/ACCEPT INFO TO 
    constant CON_BASE equals . prefix SCS$ tag C;	/*BASE OF CONNECT/ACCEPT INFO TO 
                                            		/* GIVE TO SYSAP'S
                                            		/*FORMAT OF CONNECT/ACCEPT_REQ MSGS:
    DST_PROC character length 16;			/* DESTINATION PROCESS NAME 
    SRC_PROC character length 16;			/* SOURCE PROCESS NAME 
    CON_DAT byte unsigned dimension 16;			/* CONNECT DATA 
    
end SCSDEF;

/*
/* DEFINITION OF THE REQUEST/SEND DATA OFFSETS 
/*

aggregate SCSDEF1 structure prefix SCS$ origin SND_BOFF;
    LCONID longword unsigned;				/* LOCAL CONNECTION ID
    RSPID longword unsigned;				/* LOCAL RESPONSE ID
    XCT_LEN longword unsigned;				/* TRANSACTION LENGTH
    SND_NAME longword unsigned;				/* SEND BUFFER NAME
    SND_BOFF longword unsigned;				/*  AND OFFSET
    REC_NAME longword unsigned;				/* RECEIVE BUFFER NAME
    REC_BOFF longword unsigned;				/*  AND OFFSET
end SCSDEF1;

end_module $SCSDEF;


module $SCSCMGDEF;
/*+
/* SCSCMG - SCS CONNECTION MANAGEMENT MESSAGE FORMAT
/*
/* THIS PORTION OF A CONNECT/ACCEPT MESSAGE IS SEEN BY A
/* SYSTEM APPLICATION.
/*-



aggregate SCSCMGDEF structure prefix SCSCMG$;
    RECNAM character length 16;				/*RECEIVE PROCESS NAME 
    SNDNAM character length 16;				/*SENDER PROCESS NAME 
    SNDDAT byte unsigned dimension 16;			/*SENDER CONNECT DATA 
    
end SCSCMGDEF;

end_module $SCSCMGDEF;


module $SDIRDEF;
/*+
/* SDIR - SCS DIRECTORY ENTRY
/*
/* THIS DATA STRUCTURE IS ALLOCATED FOR EACH LOCAL PROCESS THAT WANTS
/* TO BE KNOWN TO SCS.
/*-



aggregate SDIRDEF structure prefix SDIR$;
    FLINK longword unsigned;				/*FWD LINK 
    BLINK longword unsigned;				/*BCK LINK 
    SIZE word unsigned;					/*STRUCTURE SIZE IN BYTES 
    TYPE byte unsigned;					/*SCS STRUCTURE TYPE 
    SUBTYP byte unsigned;				/*SCS STRUCTURE SUBTYPE FOR SDIR 
    PROCNAM byte unsigned dimension 16;			/*ASCII STRING FOR PROCESS NAME 
    PROCINF byte unsigned dimension 16;			/*ASCII STRING FOR PROCESS INFO 
    CONID longword unsigned;				/*CONNECTION ID 
    constant "LENGTH" equals . prefix SDIR$ tag K;
    constant "LENGTH" equals . prefix SDIR$ tag C;
    
end SDIRDEF;

end_module $SDIRDEF;


module $SGNDEF;

/*+
/* SYSGEN PARAMETER DEFINITIONS
/*-


	 						/* 
constant BALSETCNT	equals 24  prefix SGN tag $C;	/* NUMBER OF PROCESSES IN BALANCE SET 
constant DFWSCNT	equals 100  prefix SGN tag $C;	/* DEFAULT WORKING SET COUNT 
constant DFWSQUOTA	equals 120  prefix SGN tag $C;	/* DEFAULT WORKING SET QUOTA 
constant GBLSECCNT	equals 40  prefix SGN tag $C;	/* GLOBAL SECTION COUNT 
constant MAXGPGCNT	equals 2*1024  prefix SGN tag $C;/* GLOBAL PAGE COUNT (GPT SIZE) 
constant MAXPAGCNT	equals 128*32*4  prefix SGN tag $C;/* PHYSICAL MEMORY SIZE IN PAGES 
constant MAXPGFL	equals 4096  prefix SGN tag $C;	/* DEFAULT MAXIMUM PAGING FILE 
constant MAXPSTCNT	equals 5  prefix SGN tag $C;	/* MAX NUMBER OF PST ENTRIES 
constant MAXVPGCNT	equals 8*8*128  prefix SGN tag $C;/* MAX PROCESS VIRTUAL SIZE (PAGES) 
constant MAXWSCNT	equals 1024  prefix SGN tag $C;	/* MAX WORKING SET SIZE (PAGES) 
constant MINWSCNT	equals 10  prefix SGN tag $C;	/* MIN WORKING SET SIZE (PAGES) 
constant NPAGEDYN	equals 52*512  prefix SGN tag $C;/* NON-PAGED DYNAMIC POOL SIZE 
constant NPROCS	equals 64  prefix SGN tag $C;		/* MAX NUMBER OF PROCESSES 
constant PAGEDYN	equals 2*16*512  prefix SGN tag $C;/* PAGED DYNAMIC POOL SIZE IN BYTES 
constant PHYPAGCNT	equals 32*128  prefix SGN tag $C;/* ACTUAL PHYSICAL PAGE COUNT 
constant SYSDWSCNT	equals 40  prefix SGN tag $C;	/* DEFAULT SYSTEM WORKING SET COUNT 
constant SYSVECPGS	equals 5  prefix SGN tag $C;	/* NO. OF PAGES OF SYSTEM SERVICE VECTORS 
constant SYSWSCNT	equals 96  prefix SGN tag $C;	/* SYSTEM WORKING SET COUNT 

end_module $SGNDEF;


module $SHBDEF;
/*+
/* SHARED MEMORY CONTROL BLOCK DEFINITIONS
/*-
/*
/* The UETP for the MA780 depends on some of the following definitions.  Please
/* let someone in that group know if the definitions change substantially.
/*



aggregate SHBDEF structure prefix SHB$;
    LINK longword unsigned;				/*LINK TO NEXT SHB 
    DATAPAGE longword unsigned;				/*VIRTUAL ADDRESS OF DATAPAGE 
    SIZE word unsigned;					/*SIZE OF SHB IN BYTES 
    TYPE byte unsigned;					/*STRUCTURE TYPE FOR SHB 
    FLAGS_OVERLAY union fill;
        FLAGS byte unsigned;				/*FLAGS 
	FLAGS_BITS structure fill;
            CONNECT bitfield mask;			/* MEMORY IS CONNECTED, USEABLE 
	end FLAGS_BITS;
    end FLAGS_OVERLAY;
    REFCNT longword unsigned;				/*COUNT OF REFERENCES TO MEMORY 
    BASGSPFN longword unsigned;				/*BASE PFN FOR GLOBAL SECTION PAGES 
    NEXUS byte unsigned;				/*NEXUS OF PORT 
    PORT byte unsigned;					/*PORT NUMBER 
    FILL_1 word fill prefix SHBDEF tag $$;		/* UNUSED 
    POOLEND longword unsigned;				/*ADDRESS PAST LAST BYTE OF POOL 
    ADP longword unsigned;				/*ADAPTER CONTROL BLOCK ADDRESS 
    constant "LENGTH" equals . prefix SHB$ tag K;	/*LENGTH OF CONTROL BLOCK 
    constant "LENGTH" equals . prefix SHB$ tag C;	/*LENGTH OF CONTROL BLOCK 
    
end SHBDEF;

end_module $SHBDEF;


module $SHDDEF;
/*+
/* SHARED MEMORY DATAPAGE DEFINITIONS
/*-
/*
/* The UETP for the MA780 depends on some of the following definitions.  Please
/* let someone in that group know if the definitions change substantially.
/*


constant MAXPORTS	equals 16  prefix SHD tag $C;	/*MAXIMUM NUMBER PORTS HANDLED BY THIS 
                                        		/*DATA STRUCTURE
/**** START OF CONSTANT FIELDS:

aggregate SHDDEF structure prefix SHD$;
    MBXPTR longword unsigned;				/*RELATIVE POINTER TO MAILBOX TABLE 
    GSDPTR longword unsigned;				/*RELATIVE POINTER TO GSD TABLE 
    CEFPTR longword unsigned;				/*RELATIVE POINTER TO CEF TABLE 
    GSBITMAP longword unsigned;				/*RELATIVE POINTER TO BITMAP 
    GSPAGCNT longword unsigned;				/*CNT OF PAGES ALLOTTED FOR GBL SECTIONS 
    GSPFN longword unsigned;				/*RELATIVE PFN OF 1ST GBL SECTION PAGE 
    GSDMAX word unsigned;				/*MAX GSD'S (SIZE OF TABLE) 
    MBXMAX word unsigned;				/*MAX MAILBOXES (SIZE OF TABLE) 
    CEFMAX word unsigned;				/*MAX CEF CLUSTERS (SIZE OF TABLE) 
    FILL_1 word fill prefix SHDDEF tag $$;		/*UNUSED 
    NAME character length 16;				/*NAME OF MEMORY (COUNTED STRING) 
    constant NAMLENGTH	equals 16  prefix SHD tag $C;	/*MAXIMUM LENGTH OF NAME OF MEMORY 
    INITTIME quadword unsigned;				/*INITIALIZATION TIME 
/**** END OF CONSTANT FIELDS.
    CRC longword unsigned;				/*CRC OF CONSTANT FIELDS 
    GSDQUOTA word unsigned dimension 16;		/*COUNT OF GSD'S CREATED (ONE/PORT) 
    MBXQUOTA word unsigned dimension 16;		/*COUNT OF MAILBOXES CREATED (ONE/PORT) 
    CEFQUOTA word unsigned dimension 16;		/*COUNT OF CLUSTERS CREATED (ONE/PORT) 
    PORTS byte unsigned;				/*NUMBER OF PORTS 
    INITLCK byte unsigned;				/*OWNER OF INIT LOCK 
    BITMAPLCK byte unsigned;				/*OWNER OF GS BITMAP LOCK 
    FLAGS_OVERLAY union fill;
        FLAGS byte unsigned;				/*FLAGS FOR LOCKING DATA STRUCTURES 
	FLAGS_BITS structure fill;
            INITLCK bitfield mask;			/*COMMON DATA PAGE BEING INITIALIZED 
            BITMAPLCK bitfield mask;			/*BITMAP BEING MODIFIED 
            GSDLCK bitfield mask;			/*GLOBAL SECTION DSC TABLE BEING SEARCHED 
            MBXLCK bitfield mask;			/*MAILBOX TABLE BEING SEARCHED 
            CEFLCK bitfield mask;			/*COMMON EVENT FLAG TABLE BEING SEARCHED 
	end FLAGS_BITS;
    end FLAGS_OVERLAY;
    GSDLOCK byte unsigned;				/*OWNER OF GSD TABLE LOCK 
    MBXLOCK byte unsigned;				/*OWNER OF MBX TABLE LOCK 
    CEFLOCK byte unsigned;				/*OWNER OF CEF TABLE LOCK 
    FILL_2 byte fill prefix SHDDEF tag $$;		/*UNUSED 
    PRQWAIT word unsigned;				/*PORTS WAITING FOR INTER-PROCESSOR REQUEST BLOCKS 
                                            		/* (ONE BIT/PORT)
    POLL word unsigned;					/*PORTS ACTIVELY USING THE MEMORY 
                                            		/* (ONE BIT/PORT)
    RESWAIT word unsigned dimension 16;			/*PORTS WAITING FOR A RESOURCE 
                                            		/* (ONE BIT/PORT, ONE MASK/RESOURCE)
    RESAVAIL word unsigned dimension 16;		/*PORTS NEEDING TO REPORT RESOURCE AVAILABLE 
                                            		/* (ONE BIT/PORT, ONE MASK/RESOURCE)
    RESSUM word unsigned;				/*PORTS WITH RESOURCES TO REPORT 
                                            		/* (ONE BIT/PORT)
    FILL_3 word fill prefix SHDDEF tag $$;		/*UNUSED 
    FILL_4 longword fill prefix SHDDEF tag $$;		/*UNUSED 
/**** NOTE: THE FOLLOWING FIELDS MUST BE QUADWORD ALIGNED:
    PRQ quadword unsigned;				/*FREE INTER-PROCESSOR REQUEST BLOCK LISTHEAD 
    POOL quadword unsigned;				/*FREE POOL BLOCK LISTHEAD 
    PRQWRK quadword unsigned dimension 16;		/*INTER-PROCESSOR REQUEST WORK QUEUE LISTHEADS 
                                            		/* (ONE LISTHEAD/PORT)
    constant "LENGTH" equals . prefix SHD$ tag K;	/*LENGTH OF DATAPAGE 
    constant "LENGTH" equals . prefix SHD$ tag C;	/*LENGTH OF DATAPAGE 
end SHDDEF;

end_module $SHDDEF;


module $SHLDEF;
/*+
/* SHL - SHAREABLE IMAGE LIST
/*
/* THIS LIST IS CREATED IN THE IMAGE FIXUP SECTION BY THE LINKER AND
/* USED BY THE IMAGE ACTIVATOR FOR DOING SHAREABLE IMAGE FIXUPS.
/*-


aggregate SHLDEF structure prefix SHL$;
    BASEVA longword unsigned;				/* Base address of this shareable image 
    SHLPTR longword unsigned;				/* Pointer from SHL in shareable image 
                                            		/*  to associated SHL in executable image
    "IDENT" longword unsigned;				/* GSMATCH 
    PERMCTX longword unsigned;				/* Permanent sharable image context 
    SHL_SIZE byte unsigned;				/* Size of SHL elements
    FILL_1 byte fill prefix SHLDEF tag $$;		/* Spare for extensions 
    FILL_2 word fill prefix SHLDEF tag $$;		/* Spare for extensions 
    FILL_3 longword fill prefix SHLDEF tag $$;		/* Spare for extensions 
    constant OLD_SHL_SIZE equals 56 prefix SHL tag $C;	/* Size of "old" SHL
    constant MAXNAMLNG	equals 39  prefix SHL tag $C;	/* Maximum length of image name 
    IMGNAM_OVERLAY union fill;
        IMGNAM character length 40;			/* Shareable image name (ASCIC string) 
        constant "LENGTH" equals . prefix SHL$ tag K;	/* Length of shareable image list element 
        constant "LENGTH" equals . prefix SHL$ tag C;	/* Length of shareable image list element 
        NAMLNG byte unsigned;				/* Synonym for name count 
    end IMGNAM_OVERLAY;
end SHLDEF;

end_module $SHLDEF;


module $SLVDEF;
/*
/*
/* Define symbolic offsets for System Loadable Vectors.  These symbols
/* are used by the various pieces of the loadable EXEC, notably SCSVEC,
/* to create a list of vectors in system space and a corresponding image
/* that will be loaded into pool and connected to the system vectors.
/*
/*
aggregate SLV structure prefix SLV$;
    CODESIZE	longword unsigned;	/* Loadable image size (in bytes)
    INITRTN	longword unsigned;	/* Offset to init. routine
    SIZE	word unsigned;		/* Same as SLV$L_CODESIZE
    TYPE	byte unsigned;		/* Structure type (DYN$C_LOADCODE)
    SUBTYP	byte unsigned;		/* Sturcture Subtype
    PROT_R	byte unsigned;		/* writeable protection for image
    PROT_W	byte unsigned;		/* read-only protection for image
    SPARE	word unsigned;		/* spare field for future use
    SYSVECS	address;		/* address of vectors in SYS.EXE
    FACILITY	character length 16;	/* facility name (.ASCIC)
    LIST	character length 640;	/* Start of vector list (MAXVEC*5)
constant "LENGTH" equals .;		/* SLV$K_LENGTH
end SLV;
/*
/*
/* Define vector type codes.  The codes LODUMMY and HIDUMMY are
/* used as placeholders, to make the definition of the upper and
/* lower bound vector type symbols automatic.  New vector type codes
/* should be added at the end of the list, but before HIDUMMY.
/*
/*
constant (LODUMMY,			/* 
	  LDATA,			/* Longword pointer to data
	  AJUMP,			/* Aligned jump
	  UJUMP,			/* Unaligned jump
	  SDATA,			/* Specified data
	  SJUMP,			/* Specified jump
	  HIDUMMY			/*
	 )
	equals 0 increment 1 prefix SLV tag $K;
constant MINTYPE equals SLV$K_LODUMMY+1 prefix SLV tag $K; /* Lower bound of vector type codes
constant MAXTYPE equals SLV$K_HIDUMMY-1 prefix SLV tag $K; /* Upper bount of vector type codes
constant MAXVEC equals 128 prefix SLV tag $K;		   /* Max. # of vectors in list.

end_module $SLVDEF;

module $SMBDEF;				/* Symbiont interface definitions

/*+
/* Symbolic definitions for the symbiont to job controller interface.
/*
/*	Public definitions of message types, item codes, and
/*	other constants utilied by the symbiont to job controller
/*	interface facility.
/*
/*-

/*
/*	Structure level
/*

constant SMBMSG$K_STRUCTURE_LEVEL   equals 1;	/* Current structure level
constant SMBMSG$K_STRUCTURE_LEVEL_1 equals 1;	/* Structure level 1


/*
/*	Request header
/*

aggregate REQUEST_HEADER structure prefix SMBMSG$;
    REQUEST_CODE	word unsigned;		/* Request code

	constant (				/*  Define request codes
	    PAUSE_TASK,				/*  - STOP /QUEUE
	    RESET_STREAM,			/*  - STOP /QUEUE /RESET
	    RESUME_TASK,			/*  - START /QUEUE (when paused)
	    START_STREAM,			/*  - START /QUEUE (when stopped)
	    START_TASK,				/*  - task available
	    STOP_STREAM,			/*  - STOP /QUEUE /NEXT
	    STOP_TASK,				/*  - STOP /QUEUE /ABORT or /REQUEUE
	    TASK_COMPLETE,			/*  - stream is idle
	    TASK_STATUS,			/*  - asynchronous status update
	    MAX_REQUEST_CODE			/* MUST BE LAST
	) equals 1 increment 1;

    STRUCTURE_LEVEL	byte unsigned;		/* Message structure level
    STREAM_INDEX	byte unsigned;		/* Stream index
end;



/*
/*	Item header
/*

aggregate ITEM_HEADER structure prefix SMBMSG$;
    ITEM_SIZE		word unsigned;		/* Item size
    ITEM_CODE		word unsigned;		/* Item code

	constant (				/*  Define item codes
	    ACCOUNTING_DATA,			/*  - accounting information
	    ACCOUNT_NAME,			/*  - account name
	    AFTER_TIME,				/*  - /AFTER value
	    ALIGNMENT_PAGES,			/*  - /ALIGN count
	    BOTTOM_MARGIN,			/*  - trailing blank lines
	    CHARACTERISTICS,			/*  - /CHARACTERISTICS value
	    CHECKPOINT_DATA,			/*  - checkpoint information
	    CONDITION_VECTOR,			/*  - task error messages
	    DEVICE_NAME,			/*  - /ON value
	    DEVICE_STATUS,			/*  - device status
	    ENTRY_NUMBER,			/*  - job entry number
	    EXECUTOR_QUEUE,			/*  - this output queue
	    FILE_COPIES,			/*  - /COPIES value
	    FILE_COUNT,				/*  - current file copy number
	    FILE_SETUP_MODULES,			/*  - file setup module list
	    FIRST_PAGE,				/*  - first page to print
	    FORM_LENGTH,			/*  - lines per page
	    FORM_NAME,				/*  - name of physical form
	    FORM_SETUP_MODULES,			/*  - form setup module list
	    FORM_WIDTH,				/*  - columns per line
	    FILE_IDENTIFICATION,		/*  - device, fid, and did
	    FILE_SPECIFICATION,			/*  - file name
	    JOB_COPIES,				/*  - /JOB_COUNT value
	    JOB_COUNT,				/*  - current job copy number
	    JOB_NAME,				/*  - /NAME value
	    JOB_RESET_MODULES,			/*  - job reset module list
	    LAST_PAGE,				/*  - last page to print
	    LEFT_MARGIN,			/*  - leading blank columns
	    LIBRARY_SPECIFICATION,		/*  - library name
	    MAXIMUM_STREAMS,			/*  - maximum supported symbiont
	    MESSAGE_VECTOR,			/*  - error messages to print
	    NOTE,				/*  - /NOTE value
	    PAGE_SETUP_MODULES,			/*  - page setup module list
	    PARAMETER_1,			/*  - user parameter 1
	    PARAMETER_2,			/*  - user parameter 2
	    PARAMETER_3,			/*  - user parameter 3
	    PARAMETER_4,			/*  - user parameter 4
	    PARAMETER_5,			/*  - user parameter 5
	    PARAMETER_6,			/*  - user parameter 6
	    PARAMETER_7,			/*  - user parameter 7
	    PARAMETER_8,			/*  - user parameter 8
	    PRINT_CONTROL,			/*  - printing control
	    PRIORITY,				/*  - queue priority
	    QUEUE,				/*  - generic queue name
	    REFUSE_REASON,			/*  - reason task refused
	    RELATIVE_PAGE,			/*  - /BACKWARD, /FORWARD values
	    REQUEST_CONTROL,			/*  - request control
	    REQUEST_RESPONSE,			/*  - request code being responded to
	    RIGHT_MARGIN,			/*  - trailing blank columns
	    SEARCH_STRING,			/*  - /SEARCH value
	    SEPARATION_CONTROL,			/*  - separation control
	    STOP_CONDITION,			/*  - reason for print abort
	    TIME_QUEUED,			/*  - time queued
	    TOP_MARGIN,				/*  - leading blank lines
	    UIC,				/*  - UIC of submittor
	    USER_NAME,				/*  - username
						/*
	    MAX_ITEM_CODE			/* MUST BE LAST
	) equals 1 increment 1;

end;



/*
/*	ACCOUNTING_DATA item
/*

aggregate ACCOUNTING_DATA structure prefix SMBMSG$;
    PAGES_PRINTED	longword unsigned;		/* Pages printed
    qio_puts		longword unsigned;		/* Lines printed
    rms_gets		longword unsigned;		/* File reads
    CPU_TIME		longword unsigned;		/* Processor time
#s_accounting_data = .;
end;



/*
/*	CHECKPOINT_DATA item
/*

aggregate CHECKPOINT_DATA structure prefix SMBMSG$;
    FILLER		byte unsigned;			/* Reserved
    CHECKPOINT_LEVEL	byte unsigned;			/* Checkpoint structure level
    OFFSET		word unsigned;			/* Offset into record
    CARCON		longword unsigned;		/* Carriage control
    PAGE		longword unsigned;		/* Page number
    RECORD_NUMBER	longword unsigned;		/* Record number
    USER_KEY		quadword;			/* User positioning key
#s_checkpoint_data = .;
end;



/*
/*	DEVICE_STATUS item
/*

aggregate DEVICE_STATUS	structure prefix SMBMSG$;
    DEVICE_FLAGS	structure longword unsigned;	/* Device flags
	LOWERCASE	    bitfield mask;		/*  - supports lowercase
	PAUSE_TASK	    bitfield mask;		/*  - symbiont initiated pause
	REMOTE		    bitfield mask;		/*  - device is remote
	SERVER		    bitfield mask;		/*  - server symbiont
	STALLED		    bitfield mask;		/*  - task stalled
	STOP_STREAM	    bitfield mask;		/*  - symbiont requesting stop stream
	TERMINAL	    bitfield mask;		/*  - device is a terminal
	UNAVAILABLE	    bitfield mask;		/*  - device unavailable
	FILLER		    bitfield length 32-^ fill;	/*  - force longword
    	end;
end;



/*
/*	PRINT_CONTROL item
/*

aggregate PRINT_CONTROL	structure prefix SMBMSG$;
    PRINT_FLAGS		structure longword unsigned;	/* Print flags
	DOUBLE_SPACE	    bitfield mask;		/*  - double space
	PAGE_HEADER	    bitfield mask;		/*  - print page headers
	PAGINATE	    bitfield mask;		/*  - insert <FF>'s
	PASSALL		    bitfield mask;		/*  - binary print file
	SEQUENCED	    bitfield mask;		/*  - print sequence numbers
	SHEET_FEED	    bitfield mask;		/*  - pause at every TOF
	TRUNCATE	    bitfield mask;		/*  - truncate on overflow
	WRAP		    bitfield mask;		/*  - wrap on overflow
	FILLER		    bitfield length 32-^ fill;	/*  - force longword
    end;
end;



/*
/*	REQUEST_CONTROL item
/*

aggregate REQUEST	structure prefix SMBMSG$;
    REQUEST_FLAGS	structure longword unsigned;	/* Print flags
	ALIGNMENT_MASK	    bitfield mask;		/*  - print A's and 9's
	PAUSE_COMPLETE	    bitfield mask;		/*  - pause when request complete
	RESTARTING	    bitfield mask;		/*  - job is restarting
	TOP_OF_FILE	    bitfield mask;		/*  - rewind before resume
	FILLER		    bitfield length 32-^ fill;	/*  - force longword
    end;
end;



/*
/*	SEPARATION_CONTROL item
/*

aggregate SEPARATION_CONTROL	structure prefix SMBMSG$;
    SEPARATION_FLAGS		structure longword unsigned;	/* Print flags
	FILE_BURST	    bitfield mask;		/*  - print file burst page
	FILE_FLAG	    bitfield mask;		/*  - print file flag page
	FILE_TRAILER	    bitfield mask;		/*  - print file trailer page
	FILE_TRAILER_ABORT  bitfield mask;		/*  - print file trailer page
	JOB_FLAG	    bitfield mask;		/*  - print job flag page
	JOB_BURST	    bitfield mask;		/*  - print job burst page
	JOB_RESET	    bitfield mask;		/*  - execute job reset sequence
	JOB_RESET_ABORT	    bitfield mask;		/*  - execute job reset sequence
	JOB_TRAILER	    bitfield mask;		/*  - print job trailer page
	JOB_TRAILER_ABORT   bitfield mask;		/*  - print job trailer page
	FILLER		    bitfield length 32-^ fill;	/*  - force longword
    end;
end;

end_module $SMBDEF;

module $SPNBDEF;
/*+
/* SPNB - SCA POLLER NAME BLOCK
/*
/* THIS DATA STRUCTURE CONTAINS A LIST OF PROCESS NAMES WHICH WILL
/* BE SEARCHED FOR ON THE GIVEN REMOTE NODE.
/*-



aggregate SPNBDEF structure prefix SPNB$;
    FLINK longword unsigned;				/*FWD LINK 
    BLINK longword unsigned;				/*BCK LINK 
    SIZE word unsigned;					/*STRUCTURE SIZE IN BYTES 
    TYPE byte unsigned;					/*SCS STRUCTURE TYPE 
    SUBTYP byte unsigned;				/*SCS STRUCTURE SUBTYPE FOR SPNB
    SB longword unsigned;				/*SYSTEM BLOCK OF REMOTE NOTE
    ROUTINE longword unsigned;				/*ADDRESS OF ROUTINE TO BE CALLED WHEN PROCESS FOUND
    INDEX byte unsigned;				/*INDEX INTO PROCESS LIST OF NEXT PROCESS TO SEARCH FOR
    REFC word unsigned;					/*NUMBER OF REFERENCES TO SPNB
    FREE byte unsigned dimension 1;			/*FREE BYTE
    constant "HDRSIZ" equals . prefix SPNB$ tag C;	/*SIZE OF HEADER
    NAMLST byte unsigned;				/*START OF VARIABLE LENGTH LIST OF ADDRESSES OF PROCESS NAMES
							/*LIST IS ZERO TERMINATED
end SPNBDEF;

end_module $SPNBDEF;


module $SPPBDEF;
/*+
/* SPPB - SCA POLLER PROCESS BLOCK
/*
/* THIS DATA STRUCTURE DESCRIBES A PROCESS NAME KNOWN
/* TO THE SCA DIRECTORY POLLER.
/*-



aggregate SPPBDEF structure prefix SPPB$;
    FLINK longword unsigned;				/*FWD LINK 
    BLINK longword unsigned;				/*BCK LINK 
    SIZE word unsigned;					/*STRUCTURE SIZE IN BYTES 
    TYPE byte unsigned;					/*SCS STRUCTURE TYPE 
    SUBTYP byte unsigned;				/*SCS STRUCTURE SUBTYPE FOR SPPB
    PROCNAM byte unsigned dimension 16;			/*ASCII STRING FOR PROCESS NAME 
    RTN longword unsigned;				/*ADDRESS OF NOTIFICATION ROUTINE
    CTX longword unsigned;				/*CONTEXT FOR NOTIFICATION ROUTINE
    BIT word unsigned;					/*BIT ASSIGNED TO THIS PROCESS NAME
    UNUSED_1 word unsigned fill;			/*WORD RESERVED FOR EXPANSION
    constant "LENGTH" equals . prefix SPPB$ tag K;
    constant "LENGTH" equals . prefix SPPB$ tag C;
    
end SPPBDEF;

end_module $SPPBDEF;


module $STATEDEF;

/*+
/* SCHEDULING STATES
/*-


	 						/* DEFINITIONS START AT 1 
constant(
      COLPG						/*COLLIDED PAGE WAIT 
    , MWAIT						/*MUTEX AND MISCELLANEOUS RESOURCE WAIT 
    , CEF						/*COMMON EVENT FLAG WAIT STATE 
    , PFW						/*PAGE FAULT WAIT 
    , LEF						/*LOCAL EVENT FLAG WAIT 
    , LEFO						/*LOCAL EVENT FLAG WAIT OUT OF BALANCE SET 
    , HIB						/*HIBERNATE WAIT 
    , HIBO						/*HIBERNATE WAIT OUT OF BALANCE SET 
    , SUSP						/*SUSPENDED 
    , SUSPO						/*SUSPENDED OUT OF THE BALANCE SET 
    , FPG						/*FREEPAGE WAIT 
    , COM						/*COMPUTE, IN BALANCE SET STATE 
    , COMO						/*COMPUTE, OUT OF BALANCE SET STATE 
    , CUR						/*CURRENT PROCESS STATE 
    ) equals 1 increment 1  prefix SCH tag $C;

end_module $STATEDEF;


module $SYSAPDEF;

/*+
/* SYSAP - FLAGS USED IN THE SYSAP-SCS INTERFACE
/*-



							/*OPTIONS FOR DISPOSING OF
							/* SENT DATAGRAM:
							/* 0 ORIGIN, INCR OF 1:
constant (
      DISPQ						/* DISPOSE ON DG FREE QUEUE
    , DISPRET						/* DISPOSE BY RETURN TO SYSAP
    , DISPPO						/* DISPOSE BY RETURN TO POOL
    ) equals 0 increment 1 prefix SYSAP tag $C;

							/*FLAGS SPECIFYING TYPE OF DG
							/* REC'D FROM REMOTE SYSAP:
							/* 0 ORIGIN, INCR OF 1:
constant (
      DGREC						/* DG REC'D FROM REMOTE
    , DGSNT						/* DG SENT
    ) equals 0 increment 1 prefix SYSAP tag $C;

end_module $SYSAPDEF;

module $TASTDEF;
/*
/* TERMINAL AST PACKET. THIS STRUCTURE IS USED BY TERMINAL SERVICES TO
/* DELIVER OUT OF BAND CHARACTER ASTS.
/*


aggregate TASTDEF structure prefix TAST$;
    FILL_1 longword dimension 7 fill prefix TASTDEF tag $$;/*RESERVE ACB REGION 
    FLINK longword unsigned;				/*FORWARD LINK 
    AST longword unsigned;				/*SAVED AST ADDRESS 
    ASTPRM longword unsigned;				/*SAVED AST PARAMETER 
    PID longword unsigned;				/*SAVED PID 
    RMOD byte unsigned;					/*SAVED RMOD 
    CTRL_OVERLAY union fill;
        CTRL byte unsigned;				/*CONTROL FIELD 
	CTRL_BITS structure fill;
            MASK_DSBL bitfield mask;			/*DISABLE MASK PROCESSING 
            INCLUDE bitfield mask;			/*INCLUDE CHARACTER 
            ONE_SHOT bitfield mask;			/*ONE SHOT AST 
            BUSY bitfield mask;				/*BLOCK BUSY 
            LOST bitfield mask;				/*AST LOST
	    ABORT bitfield mask;			/*ABORT I/O
	end CTRL_BITS;
    end CTRL_OVERLAY;
    CHAN word unsigned;					/*CHANNEL 
    "MASK" longword unsigned;				/*OUT OF BAND MASK 
    constant "LENGTH" equals . prefix TAST$ tag K;
    constant "LENGTH" equals . prefix TAST$ tag C;

    STATUS_BITS structure;
	FILL bitfield length 14;			/* First byte and spares
	ABO bitfield mask;				/* ABORT flag
	INC bitfield mask;				/* INCLUDE flag
    end STATUS_BITS;    

end TASTDEF;

end_module $TASTDEF;


module $TQEDEF;
/*+
/* TQE - TIME QUEUE ENTRY
/*
/* TIME QUEUE ENTRIES ARE UTILIZED TO SET TIMERS, WAKE UP PROCESSES, AND
/* FOR INTERNAL SYSTEM SUBROUTINES.
/*-



aggregate TQEDEF structure prefix TQE$;
    TQFL longword unsigned;				/*TIME QUEUE FORWARD LINK 
    TQBL longword unsigned;				/*TIME QUEUE BACKWARD LINK 
    SIZE word unsigned;					/*SIZE OF TQE IN BYTES 
    TYPE byte unsigned;					/*STRUCTURE TYPE FOR TQE 
    RQTYPE_OVERLAY union fill;
        RQTYPE byte unsigned;				/*TIME QUEUE ENTRY TYPE 
	RQTYPE_BITS structure fill;
            FILL_1 bitfield length 2 fill prefix TQEDEF tag $$;/* STARTING OFFSET 
            REPEAT bitfield mask;			/* REPEAT REQUEST (1=YES) 
            ABSOLUTE bitfield mask;			/* Absolute expiration time specified 
	end RQTYPE_BITS;
    end RQTYPE_OVERLAY;
    PID_OVERLAY union fill;
        PID longword unsigned;				/*TIMER OR WAKE REQUEST PROCESS ID 
        FPC longword unsigned;				/*TIMER SUBROUTINE ADDRESS 
    end PID_OVERLAY;
    AST_OVERLAY union fill;
        AST longword unsigned;				/*ADDRESS OF AST ROUTINE 
        FR3 longword unsigned;				/*TIMER SUBROUTINE SAVED R3 
    end AST_OVERLAY;
    ASTPRM_OVERLAY union fill;
        ASTPRM longword unsigned;			/*AST PARAMETER 
        FR4 longword unsigned;				/*TIMER SUBROUTINE SAVED R4 
    end ASTPRM_OVERLAY;
    TIME quadword unsigned;				/*ABSOLUTE EXPIRATION TIME 
    DELTA quadword unsigned;				/*DELTA REPEAT TIME 
    RMOD byte unsigned;					/*ACCESS MODE OF REQUEST 
    EFN byte unsigned;					/*EVENT FLAG NUMBER AND EVENT GROUP 
    FILL_2 word fill prefix TQEDEF tag $$;		/*SPARE WORD 
    RQPID longword unsigned;				/*REQUESTER PROCESS ID 
    constant "LENGTH" equals . prefix TQE$ tag K;	/*LENGTH OF STANDARD TQE 
    constant "LENGTH" equals . prefix TQE$ tag C;	/*LENGTH OF STANDARD TQE 
    
/*
/* TIME QUEUE ENTRY REQUEST TYPE DEFINITIONS
/*
    
    constant TMSNGL	equals 0  prefix TQE tag $C;	/*TIMER ENTRY SINGLE SHOT REQUEST 
    constant SSREPT	equals 1+TQE$M_REPEAT  prefix TQE tag $C;/*SYSTEM SUBROUTINE REPEAT REQUEST 
    constant SSSNGL	equals 1  prefix TQE tag $C;	/*SYSTEM SUBROUTINE SINGLE SHOT REQUEST 
    constant WKREPT	equals 2+TQE$M_REPEAT  prefix TQE tag $C;/*WAKE ENTRY REPEAT REQUEST 
    constant WKSNGL	equals 2  prefix TQE tag $C;	/*WAKE ENTRY SINGLE SHOT REQUEST 
    
end TQEDEF;

end_module $TQEDEF;


module $UAFDEF;
/*++
/* User authorization file format
/* Note: With the exception of the username and account name,
/* all strings are blank padded counted strings. Username and
/* account name are uncounted, blank padded.
/*--


aggregate UAFDEF structure prefix UAF$;
    RTYPE byte unsigned;			/* UAF record type
    constant (
	USER_ID					/* main user ID record
	) equals 1 increment 1 tag C;
    VERSION byte unsigned;			/* UAF format version
    constant (
	VERSION1				/* this version
	) equals 1 increment 1 tag C;
    USRDATOFF word unsigned;			/* offset of counted string of user data

    USERNAME structure character length 32;	/* username
	FILL_0 character length 31 fill;
	USERNAME_TAG character;			/* tag to differentiate records
    end USERNAME;
    UIC structure longword unsigned;		/* user ID code
	MEM word unsigned;			/* member subfield
	GRP word unsigned;			/* group subfield
    end UIC;
    SUB_ID longword unsigned;			/* user sub-identifier
    PARENT_ID quadword unsigned;		/* identifier of owner of this account
    constant KEYED_PART equals . tag C;		/* ISAM keys come this far
    ACCOUNT character length 32;		/* account name
    OWNER character length 32;			/* owner's name
    DEFDEV character length 32;			/* default device
    DEFDIR character length 64;			/* default directory
    LGICMD character length 64;			/* login command file
    DEFCLI character length 32;			/* default command interpreter
    CLITABLES character length 32;		/* user CLI tables

    PWD structure quadword unsigned;		/* hashed password
        PWD longword unsigned;			/* 32 bit subfield
    end PWD;
    PWD2 quadword unsigned;			/* second password
    LOGFAILS word unsigned;			/* count of login failures
    SALT word unsigned;				/* random password salt
    ENCRYPT byte unsigned;			/* encryption algorithm
    constant(					/* encryption codes
          AD_II					/* AUTODIN-II 32 bit crc code
        , PURDY					/* Purdy polynomial over salted input
	, PURDY_V				/* Purdy polynomial + variable length username
        ) equals 0 increment 1 tag C;
    ENCRYPT2 byte unsigned;			/* encryption algorithm for 2nd pwd
    PWD_LENGTH byte unsigned;			/* minimum password length
    FILL_1 byte dimension 1 fill tag $$;
    EXPIRATION quadword unsigned;		/* expiration date for account
    PWD_LIFETIME quadword unsigned;		/* password lifetime
    PWD_DATE quadword unsigned;			/* date of password change
    PWD2_DATE quadword unsigned;		/* date of 2nd password change
    LASTLOGIN_I quadword unsigned;		/* date of last interactive login
    LASTLOGIN_N quadword unsigned;		/* date of last non-interactive login
    PRIV quadword unsigned;			/* process privilege vector
    DEF_PRIV quadword unsigned;			/* default process privileges
    MIN_CLASS structure;			/* minimum security class
	FILL_2 byte dimension 20 fill;
    end MIN_CLASS;
    MAX_CLASS structure;			/* maximum security class
	FILL_3 byte dimension 20 fill;
    end MAX_CLASS;
    FLAGS structure longword unsigned;		/* user flags longword
        DISCTLY bitfield;			/* no user control-y
        DEFCLI bitfield;			/* only allow user default CLI
        LOCKPWD bitfield;			/* disable SET PASSWORD command
        CAPTIVE bitfield;			/* captive account (no overrides)
        DISACNT bitfield;			/* no interactive login
        DISWELCOM bitfield;			/* skip welcome message
        DISMAIL bitfield;			/* skip new mail message
	NOMAIL bitfield;			/* disable mail delivery
	GENPWD bitfield;			/* passwords must be generated
	PWD_EXPIRED bitfield;			/* password has expired
	PWD2_EXPIRED bitfield;			/* 2nd password has expired
	AUDIT bitfield;				/* audit all actions
	DISREPORT bitfield;			/* skip last login messages
	DISRECONNECT bitfield;			/* inhibit reconnections
    end FLAGS;
    NETWORK_ACCESS_P byte unsigned dimension 3;	/* hourly network access, primary
    NETWORK_ACCESS_S byte unsigned dimension 3;	/* hourly network access, secondary
    BATCH_ACCESS_P byte unsigned dimension 3;	/* hourly batch access, primary
    BATCH_ACCESS_S byte unsigned dimension 3;	/* hourly batch access, secondary
    LOCAL_ACCESS_P byte unsigned dimension 3;	/* hourly local access, primary
    LOCAL_ACCESS_S byte unsigned dimension 3;	/* hourly local access, secondary
    DIALUP_ACCESS_P byte unsigned dimension 3;	/* hourly dialup access, primary
    DIALUP_ACCESS_S byte unsigned dimension 3;	/* hourly dialup access, secondary
    REMOTE_ACCESS_P byte unsigned dimension 3;	/* hourly remote access, primary
    REMOTE_ACCESS_S byte unsigned dimension 3;	/* hourly remote access, secondary
    FILL_4 byte dimension 12 fill tag $$;	/* space for 2 more access types
    PRIMEDAYS structure byte unsigned;		/* bits representing primary days
        MONDAY bitfield;			/* bit clear means this is a primary day
        TUESDAY bitfield;			/* bit set means this is an off day
        WEDNESDAY bitfield;
        THURSDAY bitfield;
        FRIDAY bitfield;
        SATURDAY bitfield;
        SUNDAY bitfield;
    end PRIMEDAYS;
    FILL_5 byte dimension 1 fill tag $$;

    PRI byte unsigned;				/* base process priority
    QUEPRI byte unsigned;			/* maximum job queuing priority
    MAXJOBS word unsigned;			/* maximum jobs for UIC allowed
						/* 0 means no limit
    MAXACCTJOBS word unsigned;			/* maximum jobs for account allowed
						/* 0 means no limit
    MAXDETACH word unsigned;			/* maximum detached processes for UIC
						/* 0 means no limit
    PRCCNT word unsigned;			/* subprocess creation limit
    BIOLM word unsigned;			/* buffered I/O limit
    DIOLM word unsigned;			/* direct I/O limit
    TQCNT word unsigned;			/* timer queue entry limit
    ASTLM word unsigned;			/* AST queue limit
    ENQLM word unsigned;			/* enqueue limit
    FILLM word unsigned;			/* open file limit
    SHRFILLM word unsigned;			/* shared file limit
    WSQUOTA longword unsigned;			/* working set size quota
    DFWSCNT longword unsigned;			/* default working set size
    WSEXTENT longword unsigned;			/* working set size limit
    PGFLQUOTA longword unsigned;		/* page file quota
    CPUTIM longword unsigned;			/* CPU time quota
    BYTLM longword unsigned;			/* buffered I/O byte count limit
    PBYTLM longword unsigned;			/* paged buffer I/O byte count limit
    JTQUOTA longword unsigned;			/* job-wide logical name table creation quota
    PROXY_LIM word unsigned;			/* number of proxies user can grant
    PROXIES word unsigned;			/* number of proxies granted
    ACCOUNT_LIM word unsigned;			/* number of sub-accounts allowed
    ACCOUNTS word unsigned;			/* number of sub-accounts in use
    FILL_99 byte dimension 64 fill tag $$;
    constant FIXED equals . prefix UAF$ tag K;	/* length of fixed portion
    constant FIXED equals . prefix UAF$ tag C;	/* length of fixed portion
    FILL_100 byte dimension 768 fill tag $$;	/* user-extensible area
    constant "LENGTH" equals . prefix UAF$ tag K;
    constant "LENGTH" equals . prefix UAF$ tag C;
end UAFDEF;

end_module $UAFDEF;

module $UASDEF;
/*+
/* UNIBUS ADDRESS SPACE REGISTER DEFINITIONS FOR DW750
/* 	(SECOND UNIBUS ADAPTER ON 11/750)
/*-


aggregate UASDEF structure prefix UAS$;
	FILL_1 byte dimension 5216 fill prefix UASDEF tag $$;

	IP structure;						/* INTER-PROCESSOR EXERCISER COMMUNICATOR
		FILL_2 word dimension 2 fill prefix UASDEF tag $$; /* ADDRESS AND DATA REGISTERS NOT CURRENTLY USED

		CR1_OVERLAY union fill;
			IP_CR1 word unsigned;			/* THE THIRD IPEC REGISTER, CR1
			CR1_BITS structure fill;
				FILL_3 bitfield length 12 fill prefix UASDEF tag $$; /* SKIP BITS OF NO INTEREST
				IP_CR1_PIE bitfield mask;	/* POWERFAIL INTERRUPT ENABLE
				IP_CR1_PDN bitfield mask;	/* POWER DOWN STATUS BIT
			end CR1_BITS;
		end CR1_OVERLAY;

	end IP;

end UASDEF;

end_module $UASDEF;


module $UBADEF;
/*+
/* UNIBUS ADAPTER REGISTER OFFSET DEFINITIONS
/*-



aggregate UBADEF structure prefix UBA$;
    CSR_OVERLAY union fill;
        CSR longword unsigned;				/*CONFIGURATION STATUS REGISTER 
	CSR_BITS structure fill;
            CSR_ADCOD bitfield length 8;		/* ADAPTER CODE FIELD 
            FILL_1 bitfield length 8 fill prefix UBADEF tag $$;/* RESERVED BITS 
            CSR_UBIC bitfield mask;			/* UNIBUS INITIALIZATION COMPLETE 
            CSR_UBPDN bitfield mask;			/* UNIBUS POWER DOWN 
            CSR_UBIIP bitfield mask;			/* UNIBUS INITIALIZATION IN PROGRESS 
            FILL_2 bitfield length 2 fill prefix UBADEF tag $$;/* RESERVED BITS 
            CSR_OT bitfield mask;			/* OVER TEMPERATURE 
            CSR_PU bitfield mask;			/* ADAPTER POWER UP 
            CSR_PD bitfield mask;			/* ADAPTER POWER DOWN 
            FILL_3 bitfield length 2 fill prefix UBADEF tag $$;/* RESERVED BITS 
            CSR_XMFLT bitfield mask;			/* TRANSMITTER FAULT 
            CSR_MT bitfield mask;			/* MULTIPLE TRANSMITTERS 
            CSR_IS bitfield mask;			/* INTERLOCK SEQUENCE FAULT 
            CSR_URD bitfield mask;			/* UNEXPECTED READ DATA 
            CSR_WS bitfield mask;			/* WRITE SEQUENCE DATA 
            CSR_PE bitfield mask;			/* SBI PARITY ERROR 
	end CSR_BITS;
    end CSR_OVERLAY;
    CR_OVERLAY union fill;
        CR longword unsigned;				/*CONTROL REGISTER 
	CR_BITS structure fill;
            CR_INIT bitfield mask;			/* ADAPTER INITIALIZATION 
            CR_UBPF bitfield mask;			/* UNIBUS POWER FAIL 
            CR_CNFIE bitfield mask;			/* CONFIGURATION INTERRUPT ENABLE 
            CR_SUEFIE bitfield mask;			/* SBI TO UNIBUS ERROR FIELD INTERRUPT ENABLE 
            CR_USEFIE bitfield mask;			/* UNIBUS TO SBI ERROR FIELD INTERRUPT ENABLE 
            CR_BRIE bitfield mask;			/* BUS REQUEST INTERRUPT ENABLE 
            CR_IFSIE bitfield mask;			/* INTERRUPT FIELD SWITCH INTERRUPT ENABLE 
            CR_ARLVL bitfield mask length 2;		/* ADAPTER REQUEST LEVEL 
            FILL_4 bitfield length 17 fill prefix UBADEF tag $$;/* RESERVED BITS 
            CR_MRDSB bitfield length 5;			/* MAP REGISTER DISABLE 
	end CR_BITS;
    end CR_OVERLAY;
    SR_OVERLAY union fill;
        SR longword unsigned;				/*STATUS REGISTER 
	SR_BITS structure fill;
            SR_SSYNC bitfield mask;			/* UNIBUS SLAVE SYNC TIMEOUT 
            SR_UBSTO bitfield mask;			/* UNIBUS SELECT TIMEOUT 
            SR_LER bitfield mask;			/* LOST ERROR 
            SR_MRPE bitfield mask;			/* MAP REGISTER PARITY ERROR 
            SR_IVMR bitfield mask;			/* INVALID MAP REGISTER 
            SR_DPPE bitfield mask;			/* DATAPATH PARITY ERROR 
            SR_CXTMO bitfield mask;			/* COMMAND TRANSMISSION TIMEOUT 
            SR_CXTER bitfield mask;			/* COMMAND TRANSMISSION ERROR 
            SR_CRD bitfield mask;			/* CORRECTED READ DATA 
            SR_RDS bitfield mask;			/* READ DATA SUBSTITUTE 
            SR_RDTO bitfield mask;			/* READ DATA TIMEOUT 
            SR_BRID bitfield mask;			/* BUS REQUEST INTERRUPT DONE 
            FILL_5 bitfield length 12 fill prefix UBADEF tag $$;/* RESERVED BITS 
            SR_BRRVF bitfield length 4;			/* BUS REQUEST RECEIVE VECTOR FULL 
            SR_BRSVF bitfield mask;			/* BUS REQUEST SEND VECTOR FULL 
            SR_RIE bitfield mask;			/* REQUEST INTERRUPT ENABLED 
            SR_UBIFS bitfield mask;			/* UNIBUS INTERRUPT FIELD SWITCH 
	end SR_BITS;
    end SR_OVERLAY;
    DCR longword unsigned;				/*DIAGNOSTIC CONTROL REGISTER 
    FMER_OVERLAY union fill;
        FMER longword unsigned;				/*FAILED MAP ENTRY REGISTER 
	FMER_BITS structure fill;
            FMER_MRN bitfield length 9;			/* FAILED MAP REGISTER NUMBER 
	end FMER_BITS;
    end FMER_OVERLAY;
    FUBAR_OVERLAY union fill;
        FUBAR longword unsigned;			/*FAILED UNIBUS ADDRESS REGISTER 
	FUBAR_BITS structure fill;
            FUBAR_ADR bitfield length 18;		/* FAILED SBI TO UNIBUS ADDRESS 
	end FUBAR_BITS;
    end FUBAR_OVERLAY;
    FILL_6 longword dimension 2 fill prefix UBADEF tag $$;/*RESERVED REGISTERS 
    BRSVR longword unsigned dimension 4;		/*BUS REQUEST SEND VECTOR REGISTERS 
    BRRVR_OVERLAY union fill;
        BRRVR longword unsigned dimension 4;		/*BUS REQUEST RECEIVE VECTOR REGISTER 
	BRRVR_BITS structure fill;
            BRRVR_IVA bitfield length 16;		/* INTERRUPT VECTOR ADDRESS 
            FILL_7 bitfield length 15 fill prefix UBADEF tag $$;/* RESERVED BITS 
            BRRVR_AIR bitfield mask;			/* ADAPTER INTERRUPT REQUEST PENDING 
	end BRRVR_BITS;
    end BRRVR_OVERLAY;
    DPR_OVERLAY union fill;
        DPR longword unsigned dimension 16;		/*DATAPATH REGISTERS 
	DPR_BITS structure fill;
            DPR_ADDR bitfield length 16;		/* BUFFERED UNIBUS ADDRESS 
            DPR_STATE bitfield length 8;		/* BUFFER STATE FLAGS 
            FILL_8 bitfield length 5 fill prefix UBADEF tag $$;/* RESERVED BITS 
            DPR_DPF bitfield mask;			/* DATAPATH FUNCTION 
            DPR_XMTER bitfield mask;			/* BUFFER TRANSFER ERROR 
            DPR_BNE bitfield mask;			/* BUFFER NOT EMPTY 
	end DPR_BITS;
    end DPR_OVERLAY;
    FILL_9 byte dimension 1920 fill prefix UBADEF tag $$;/* VALUE IS 2048-128 
    MAP_OVERLAY union fill;
        MAP longword unsigned dimension 496;		/*MAP REGISTERS 
	MAP_BITS structure fill;
            MAP_ADDR bitfield length 21;		/* SBI PAGE ADDRESS 
            MAP_DPD bitfield length 4;			/* DATAPATH DESIGNATOR 
            MAP_BO bitfield mask;			/* BYTE OFFSET 
            FILL_10 bitfield length 5 fill prefix UBADEF tag $$;/* RESERVED BITS 
            MAP_VALID bitfield mask;			/* MAP REGISTER VALID 
	end MAP_BITS;
        constant MAXDP	equals 15  prefix UBA tag $C;	/*MAXIMUM DATAPATH ! 
        
    end MAP_OVERLAY;
end UBADEF;

end_module $UBADEF;


module $UBIDEF;
/*+
/* UNIBUS INTERCONNECT (VAX 11/750 & 11/730) REGISTER OFFSETS AND FIELDS
/*-



aggregate UBIDEF union prefix UBI$;
    DPR longword unsigned dimension 4;			/*DATAPATH REGISTERS 
                                            		/* (DPR 0 NOT IMPLEMENTED)
	DPR_BITS structure fill;
            DPR_PUR bitfield mask;			/* DATAPATH PURGE 
            FILL_1 bitfield length 28 fill prefix UBIDEF tag $$;/* RESERVED BITS 
            DPR_UCE bitfield mask;			/* UNCORRECTABLE ERROR 
            DPR_NXM bitfield mask;			/* NON-EXISTENT MEMORY 
            DPR_ERROR bitfield mask;			/* ERROR (UCE!NXM) 
	end DPR_BITS;
end UBIDEF;

aggregate UBIDEF1 structure prefix UBI$;
    FILL_6 byte dimension 16 fill prefix UBIDEF tag $$;
    DSR_OVERLAY union fill;
        DSR longword unsigned dimension 4;		/*DIAGNOSTIC STATUS REGISTERS 
                                                	/* (DSR 0 NOT IMPLEMENTED)
	DSR_BITS structure fill;
            FILL_2 bitfield length 27 fill prefix UBIDEF tag $$;/* RESERVED BITS 
            DSR_CD bitfield mask;			/* ALL 4 BYTES IN BDP FULL 
            DSR_BF bitfield length 4;			/* BYTE 0,1,2,3 IN BDP HAS VALID DATA 
	end DSR_BITS;
    end DSR_OVERLAY;
end UBIDEF1;

aggregate UBIDEF2 structure prefix UBI$;
    FILL_7 byte dimension 16 fill prefix UBIDEF tag $$;
    SR_OVERLAY union fill;
        SR longword unsigned;				/*UB STATUS REGISTER: 
	SR_BITS structure fill;
            FILL_3 bitfield length 14 fill prefix UBIDEF tag $$;/* RESERVED BITS 
            SR_UWE bitfield mask;			/* UNCORRECTED WRITE ERROR 
            SR_MRPE bitfield mask;			/* MAP REGISTER PARITY ERROR 
            SR_NXM bitfield mask;			/* NONEXISTENT MEMORY REF 
            FILL_4 bitfield length 14 fill prefix UBIDEF tag $$;/* RESERVED BITS 
            SR_UCE bitfield mask;			/* UNCORRECTED READ ERROR 
	end SR_BITS;
                                                	/*END OF CPU_SPECIFIC REGISTERS
    end SR_OVERLAY;
end UBIDEF2;

aggregate UBIDEF3 structure prefix UBI$;
    FILL_5 byte dimension 2048 fill prefix UBIDEF tag $$;/*RESERVE ^X800 BYTES 
    MAP longword unsigned dimension 496;		/*MAP REGISTERS, SAME FORMAT AS UBA 
    constant MAXDP	equals 3  prefix UBI tag $C;	/*MAXIMUM DATAPATH ! 
    constant PURCNT	equals 10  prefix UBI tag $C;	/*MAX ! OF TESTS OF PURGE DONE 
end UBIDEF3;

end_module $UBIDEF;


module $UBMDDEF;
/*+
/* UBMD - UNIBUS Map Descriptor used to record UNIBUS map registers
/*        and datapaths allocated.
/*-



aggregate UBMDDEF structure prefix UBMD$;
    MAPREG word unsigned;				/* Starting map register 
    NUMREG byte unsigned;				/* Number of registers in extent 
    DATAPATH byte unsigned;				/* Associated Buffered datapath 
    
end UBMDDEF;

end_module $UBMDDEF;


{+
{ UCB - UNIT CONTROL BLOCK
{
{ THERE IS ONE UCB FOR EACH DEVICE UNIT IN A SYSTEM.
{-

module $UCBDEF;

aggregate UCBDEF structure prefix UCB$;
    FQFL_OVERLAY union fill;
        FQFL longword unsigned;				/*FORK QUEUE FORWARD LINK 
	UNIT_SEED word unsigned;			/* UNIT NUMBER SEED 
	MB_SEED word unsigned;				/* MB -- UNIT NUMBER SEED 
        RQFL longword unsigned;				/* NET -- RCV QUEUE FORWARD LINK 
    end FQFL_OVERLAY;
    FQBL_OVERLAY union fill;
        FQBL longword unsigned;				/*FORK QUEUE BACKWARD LINK 
        RQBL longword unsigned;				/* NET -- RCV QUEUE BACKWARD LINK 
    end FQBL_OVERLAY;
    SIZE word unsigned;					/*SIZE OF UCB IN BYTES 
    TYPE byte unsigned;					/*STRUCTURE TYPE FOR UCB 
    FIPL byte unsigned;					/*FORK INTERRUPT PRIORITY LEVEL 
    FPC_OVERLAY union fill;
        FPC longword unsigned;				/*FORK PC 
        ASTQFL longword unsigned;			/* MB -- AST QUEUE LISTHEAD FORWARD LINK 
	PARTNER character;				/* NET -- PARTNER'S NODENAME 
    end FPC_OVERLAY;
    FR3_OVERLAY union fill;
        FR3 longword unsigned;				/*FORK R3 
        ASTQBL longword unsigned;			/* MB -- AST QUEUE LISTHEAD BACKWARD LINK 
    end FR3_OVERLAY;
    FR4_OVERLAY union fill;
        FR4 longword unsigned;				/*FORK R4 
	MB_FR4_FIELDS structure fill;
	    MSGMAX word unsigned;			/* MB -- MAXIMUM MESSAGES ALLOWED 
	    MSGCNT word unsigned;			/* MB -- CURRENT NUMBER OF MESSAGES 
	end MB_FR4_FIELDS;
        FIRST longword unsigned;			/* NET -- ADDR OF 1ST SEG OF CHAINED MSG 
    end FR4_OVERLAY;
    BUFQUO_OVERLAY union fill;
        BUFQUO word unsigned;				/* BUFFERED I/O QUOTA CHARGED FOR THIS UCB
        DSTADDR word unsigned;				/* NET -- REMOTE CONNECT NO. 
    end BUFQUO_OVERLAY;
    SRCADDR word unsigned;				/* NET -- LOCAL CONNECT NO. 
    ORB longword unsigned;				/* OBJECT'S RIGHTS BLOCK ADDRESS
    LOCKID_OVERLAY union fill;
	LOCKID longword unsigned;			/*DEVICE LOCK ID
	CPID longword unsigned;				/*PID CHARGED FOR BUFQUO BY UCBCREDEL
    end LOCKID_OVERLAY;
    CRB longword unsigned;				/*ADDRESS OF PRIMARY CHANNEL REQUEST BLOCK 
    DDB longword unsigned;				/*BACKPOINTER TO DEVICE DATA BLOCK 
    PID longword unsigned;				/*PROCESS ID OF OWNER PROCESS 
    LINK longword unsigned;				/*ADDRESS OF NEXT UCB FOR RESPECTIVE DDB 
    VCB longword unsigned;				/*ADDRESS OF VOLUME CONTROL BLOCK 
    DEVCHAR union fill;					/*DEVICE CHARACTERISTIC BITS
	DEVCHAR quadword unsigned;			/* Device characteristic bits quadword
	DEVCHAR_Q_BLOCK structure fill;
	    DEVCHAR longword unsigned;			/*  Original device characteristic bits
	    DEVCHAR2 longword unsigned;			/*  Extended device characteristic bits
	end DEVCHAR_Q_BLOCK;
    end DEVCHAR;
    DEVCLASS byte unsigned;				/*DEVICE CLASS 
    DEVTYPE byte unsigned;				/*DEVICE TYPE 
    DEVBUFSIZ word unsigned;				/*DEVICE DEFAULT BUFFER SIZE 
    DEVDEPEND_Q_OVERLAY union fill;			/*DEVICE DEPENDENT DATA 
	DEVDEPEND quadword unsigned;			/*Device dependent quadword
	DEVDEPEND_Q_BLOCK structure;
	    DEVDEPEND_OVERLAY union fill;
		DEVDEPEND longword unsigned;		/*  First device dependent longword
		DISK_DEVDEPEND structure;		/*    Disk fields
		    SECTORS byte unsigned;		/*	Sectors per track
		    TRACKS byte unsigned;		/*	Track per cylinder
		    CYLINDERS word unsigned;		/*	Cylinders per disk
		end DISK_DEVDEPEND;
		TERM_DEVDEPEND structure;		/*    Terminal fields
		    TERM_DEVDEPEND_FILL byte dimension 3
			fill prefix UCBDEF tag $$;
		    VERTSZ byte unsigned;		/*	Vertical page size (lines per page)
		end TERM_DEVDEPEND;
		NET_DEVDEPEND structure;		/*    Network fields
		    LOCSRV byte unsigned;		/*	Local link services 
                    REMSRV byte unsigned;		/*	Remote link services
                    BYTESTOGO word unsigned;		/*	No. of bytes left in rcv bfr
		end NET_DEVDEPEND;
        	JNL_SEQNO longword unsigned;		/*    Journal -- Running sequence number 
	    end DEVDEPEND_OVERLAY;
	    DEVDEPND2_OVERLAY union fill;
		DEVDEPND2 longword unsigned;		/*  Second device dependent long word 
		TT_DEVDP1 longword unsigned;		/*    Terminal -- Device dependent long word 
	    end DEVDEPND2_OVERLAY;
	end DEVDEPEND_Q_BLOCK;
    end DEVDEPEND_Q_OVERLAY;
    IOQFL longword unsigned;				/*I/O QUEUE LISTHEAD FORWARD LINK 
    IOQBL longword unsigned;				/*I/O QUEUE LISTHEAD BACKWARD LINK 
    UNIT word unsigned;					/*PHYSICAL DEVICE UNIT NUMBER 
    CHARGE_OVERLAY union fill;
        CHARGE word unsigned;				/*MAILBOX BYTE COUNT QUOTA CHARGE 
	RWAITCNT word unsigned;				/* CLASS DRIVERS -- THREADS WAITING RESOURCES 
	CTRLR_ALLOC_FIELDS structure fill;
	    CM1 byte unsigned;				/* LEVEL 1 CONTROLLER ALLOCATION MASK 
	    CM2 byte unsigned;				/* LEVEL 2 CONTROLLER ALLOCATION MASK 
	end CTRLR_ALLOC_FIELDS;
    end CHARGE_OVERLAY;
    IRP longword unsigned;				/*CURRENT I/O REQUEST PACKET ADDRESS 
    REFC word unsigned;					/*REFERENCE COUNT OF PROCESSES 
    DIPL_OVERLAY union fill;
        DIPL byte unsigned;				/*DEVICE INTERRUPT PRIORITY LEVEL 
        STATE byte unsigned;				/* NET -- LINK STATE FOR NETWORK TRANSITIONS 
    end DIPL_OVERLAY;
    AMOD byte unsigned;					/*ALLOCATION ACCESS MODE 
    AMB longword unsigned;				/*ASSOCIATED UNIT CONTROL BLOCK POINTER 
    STS_OVERLAY union fill;
	STS longword unsigned;				/*DEVICE UNIT STATUS 
        STS word unsigned;
	STS_BITS structure fill;
            TIM bitfield mask;				/* TIME OUT ENABLED (1=YES) 
            INT bitfield mask;				/* INTERRUPT EXPECTED (1=YES) 
            ERLOGIP bitfield mask;			/* ERROR LOG IN PROGRESS ON UNIT (1=YES) 
            CANCEL bitfield mask;			/* CANCEL I/O ON UNIT (1=YES) 
            ONLINE bitfield mask;			/* UNIT ONLINE (1=YES) 
            POWER bitfield mask;			/* POWER FAILED WHILE UNIT BUSY (1=YES) 
            TIMOUT bitfield mask;			/* UNIT TIMED OUT (1=YES) 
            INTTYPE bitfield mask;			/* RECEIVER INTERRUPT IF SET 
            BSY bitfield mask;				/* UNIT IS BUSY (1=YES) 
            MOUNTING bitfield mask;			/* DEVICE IS BEING MOUNTED 
            DEADMO bitfield mask;			/* DEALLOCATE AT DISMOUNT 
            VALID bitfield mask;			/* VOLUME IS SOFTWARE VALID 
            UNLOAD bitfield mask;			/* UNLOAD VOLUME AT DISMOUNT 
            TEMPLATE bitfield mask;			/* SET IF THIS IS TEMPLATE UCB
                                                    	{  FROM WHICH OTHER UCB'S FOR
                                                    	{  THIS DEVICE TYPE ARE MADE
            MNTVERIP bitfield mask;			/* MOUNT VERIFICATION IN PROGRESS 
            WRONGVOL bitfield mask;			/* WRONG VOLUME DETECTED DURING MOUNT VERIFICATION 
	    DELETEUCB bitfield mask;			/* DELETE THIS UCB WHEN REFC REACHES ZERO
	    LCL_VALID bitfield mask;			/* VOLUME IS VALID ON THE LOCAL NODE
	    SUPMVMSG bitfield mask;			/* IF SET, SUPPRESS SUCCESS TYPE MOUNT VER. MSGS.
							{  CLEARED BY ANY ERROR IN MOUNT VERIFICATION
	    MNTVERPND bitfield mask;			/* MOUNT VERIFICATION IS PENDING ON BUSY DEVICE.
	    DISMOUNT bitfield mask;			/* DISMOUNT IN PROGRESS
	    CLUTRAN bitfield mask;			/* VAXcluster STATE TRANSITION IN PROGRESS
	end STS_BITS;
    end STS_OVERLAY;
    DEVSTS_OVERLAY union fill;
        DEVSTS word unsigned;				/*DEVICE DEPENDENT STATUS 
	DEVSTS_GENERAL_BITS structure fill;		/* Generally used bits
            JOB bitfield mask;				/*   Job Controller notified 
	    devsts_gen_fill bitfield length 5 fill;
            TEMPL_BSY bitfield mask;			/*   Template UCB is busy 
	end DEVSTS_GENERAL_BITS;
	DEVSTS_MAILBX_BITS structure fill;		/* Mailbox status bits
            PRMMBX bitfield mask;			/*   Permanent mailbox 
            DELMBX bitfield mask;			/*   Mailbox marked for delete 
	    devsts_mb_fill bitfield length 1 fill;
            SHMMBX bitfield mask;			/*   Shared memory mailbox 
	end DEVSTS_MAILBX_BITS;
	DEVSTS_TERM_BITS structure fill;		/* Terminal status bits
	    devsts_tt_fill bitfield length 1 fill;
            TT_TIMO bitfield mask;			/*   Terminal read timeout in progress 
            TT_NOTIF bitfield mask;			/*   Terminal user notified of unsolicted data 
            TT_HANGUP bitfield mask;			/*   Process hang up
	    TT_DEVSTS_FILL bitfield length 15-^;	/*   fill to the end the word
	    TT_NOLOGINS bitfield mask;			/* NOLOGINS ALLOWED
	end DEVSTS_TERM_BITS;
	DEVSTS_NET_BITS structure fill;			/* Network status bits
	    devsts_net_fill1 bitfield length 2 fill;
	    NT_BFROVF bitfield mask;			/*   Too many bytes rcvd 
	    devsts_net_fill2 bitfield fill;
	    NT_NAME bitfield mask;			/*   Link has declared a connect name 
	    NT_BREAK bitfield mask;			/*   Link is being broken 
	end DEVSTS_NET_BITS;
	DEVSTS_DISKS structure fill;			/* Disk (all disks) status bits
							{  (using the low order byte, for
							{  compatibility with class driver
							{  usage of the high order word)
	    ECC bitfield mask;				/*   ECC correction was made
	    DIAGBUF bitfield mask;			/*   Diagnostic buffer specified
	    NOCNVRT bitfield mask;			/*   No LBN to media address conversion
	    DX_WRITE bitfield mask;			/*   Console floppy write operation
	    DATACACHE bitfield mask;			/*   Data blocks being cached
	end DEVSTS_DISKS;
	DEVSTS_MSCP_CLASS_BITS structure fill;		/* MSCP class driver bits
	    byte_fill bitfield length 8 fill;		{  (using the high order byte only)
	    MSCP_MNTVERIP bitfield mask;		/*   Mount verification in progress
	    MSCP_INITING bitfield mask;			/*   UCB is being initialized
	    MSCP_WAITBMP bitfield mask;			/*   RWAITCNT has been bumped
	    MSCP_FLOVR bitfield mask;			/*   Bit toggled everytime a failover succeeds.
	    MSCP_PKACK bitfield mask;			/*   Set when a IO$_PACKACK is in progress.
	    MSCP_WRTP bitfield mask;			/*   Unit MSCP write protected in some way.
	end DEVSTS_MSCP_CLASS_BITS;
	DEVSTS_TAPE_CLASS_BITS structure fill;		/* Tape class driver bits
	    						{  (using the low order byte only)
	    TU_OVRSQCHK bitfield mask;			/*   Override sequence checking
	    TU_TRACEACT bitfield mask;			/*   IRP trace table active
	    TU_SEQNOP bitfield mask;			/*   Sequential NOP tape operation in progress
	end DEVSTS_TU_CLASS_BITS;
	DEVSTS_JOURNAL_BITS structure fill;		/* Journal status bits
	    devsts_jnl_fill bitfield length 4 fill;
            PERM_JNL bitfield mask;			/*   Permanent journal device 
            KNOWN_JNL bitfield mask;			/*   Known journal
            JNL_CLS bitfield mask;			/*   Cluster journal 
            JNL_SLV bitfield mask;			/*   Slave journal UCB 
	    CDELE_PND bitfield mask;			/*   Cluster delete operation pending
	    JNL_UNMAST bitfield mask;			/*   Device unmastered
	end DEVSTS_JOURNAL_BITS;
    end DEVSTS_OVERLAY;
    QLEN word unsigned;					/* Device queue length
    DUETIM longword unsigned;				/*DUE TIME FOR I/O COMPLETION 
    OPCNT longword unsigned;				/*COUNT OF OPERATIONS COMPLETED 
    SVPN_OVERLAY union fill;
        SVPN longword unsigned;				/*SYSTEM VIRTUAL PAGE/MAP REGISTER NUMBER 
        LOGADR longword unsigned;			/* MB -- LOGICAL NAME BLOCK ADDRESS 
    end SVPN_OVERLAY;
    SVAPTE longword unsigned;				/*SYSTEM VIRTUAL ADDRESS OF PTE 
    BOFF word unsigned;					/*BYTE OFFSET IN FIRST PAGE 
    BCNT word unsigned;					/*BYTE COUNT OF TRANSFER 
    ERTCNT byte unsigned;				/*ERROR LOG DEVICE CURRENT ERROR RETRY COUNT 
    ERTMAX byte unsigned;				/*ERROR LOG DEVICE MAXIMUM ERROR RETRY COUNT 
    ERRCNT word unsigned;				/*DEVICE ERROR COUNT 
    PDT_OVERLAY union fill;
	PDT longword unsigned;				/*ADDR OF PORT DESCRIPTOR TABLE
	JNL_MCSID longword unsigned;			/*MASTER NODE'S CSID (JOURNALING)
    end PDT_OVERLAY;
    DDT longword unsigned;				/*ADDR OF DDT (OPTIONAL BUT PREFERRED) 
    MEDIA_ID_OVERLAY union fill ;
	MEDIA_ID longword unsigned;			/*BIT ENCODED MEDIA IDENTIFICATION 
	MEDIA_ID_SUBFIELDS structure fill;
	    MEDIA_ID_NN bitfield length 7;		/* MEDIA NAME NUMBER
	    MEDIA_ID_N2 bitfield length 5;		/* MEDIA NAME CHAR 2
	    MEDIA_ID_N1 bitfield length 5;		/* MEDIA NAME CHAR 1
	    MEDIA_ID_N0 bitfield length 5;		/* MEDIA NAME CHAR 0
	    MEDIA_ID_T1 bitfield length 5;		/* MEDIA TYPE CHAR 1
	    MEDIA_ID_T0 bitfield length 5;		/* MEDIA TYPE CHAR 0
	end MEDIA_ID_SUBFIELDS;
    end MEDIA_ID_OVERLAY;
    constant "LENGTH" equals . prefix UCB$ tag K;	/*LENGTH OF STANDARD UCB 
    constant "LENGTH" equals . prefix UCB$ tag C;	/*LENGTH OF STANDARD UCB 
    #UCB_LENGTH = .;		/* for $TTYUCBDEF
end UCBDEF;

/*
/* DEVICE DEPENDENT UCB EXTENSIONS
/*
/* MAILBOX
/*

aggregate UCBDEF3 structure prefix UCB$;
    FILL_7 byte dimension UCB$K_LENGTH fill prefix UCBDEF tag $$;
    MB_WAST longword unsigned;				/*WRITE ATTENTION AST BLOCK ADDR 
    MB_RAST longword unsigned;				/*READ ATTENTION AST BLOCK ADDR 
    MB_MBX longword unsigned;				/*MAILBOX CONTROL BLOCK ADDR 
    MB_SHB longword unsigned;				/*SHARED MEM. CONTROL BLOCK ADDR 
    MB_WIOQFL longword unsigned;			/*WRITE I/O QUEUE FORWARD LINK 
    MB_WIOQBL longword unsigned;			/*WRITE I/O QUEUE BACKWARD LINK 
    MB_PORT longword unsigned;				/*SHARED MEM. PORT NUMBER 
    constant MB_LENGTH equals . prefix UCB$ tag K;	/*SIZE OF MAILBOX UCB 
    constant MB_LENGTH equals . prefix UCB$ tag C;	/*SIZE OF MAILBOX UCB 
end UCBDEF3;
    
/*
/* ERROR LOG DEVICES (ALL)
/*

aggregate UCBDEF4 structure prefix UCB$;
    FILL_8 byte dimension UCB$K_LENGTH fill prefix UCBDEF tag $$;
    SLAVE byte unsigned;				/*SLAVE CONTROLLER NUMBER 
    SPR byte unsigned;					/*SPARE UNUSED BYTE 
    FEX byte unsigned;					/*FUNCTION DISPATCH TABLE INDEX 
    CEX byte unsigned;					/*CASE TABLE FUNCTION EXECUTION INDEX 
    EMB longword unsigned;				/*ADDRESS OF ERROR MESSAGE BUFFER 
    FILL_1 word fill prefix UCBDEF tag $$;		/*SPARE UNUSED WORD 
    FUNC word unsigned;					/*I/O FUNCTION MODIFIERS 
    DPC longword unsigned;				/*SAVED DRIVER SUBROUTINE RETURN ADDRESS
    constant ERL_LENGTH equals .;			/*SIZE OF ERROR LOG UCB
    constant ERL_LENGTH equals . tag C;			/*SIZE OF ERROR LOG UCB
end UCBDEF4;
    
/*
/* DUAL PORTED DEVICES (ALL DISKS AND MOST TAPES)
/*

aggregate DUALPATH_EXTENSION structure prefix UCB$;
    fill_dualpath byte dimension UCB$K_ERL_LENGTH fill;
    DUAL_PATH union fill;				{  Setup two versions of the dual-path names
	OLD_DUAL_PATH structure fill;			{  This is the old way of naming things
	    DP_DDB longword unsigned;			/* Pointer to alternate DDB
	    DP_LINK longword unsigned;			/* Address of next UCB for this DDB 
	    DP_ALTUCB longword unsigned;		/* Addr of alternate UCB for this unit
	end OLD_DUAL_PATH;
	PREFERED_DUAL_PATH structure fill;		{  This is the prefered way of naming things
	    "2P_DDB" longword unsigned;			/* Pointer to alternate DDB
	    "2P_LINK" longword unsigned;		/* Address of next UCB for this DDB 
	    "2P_ALTUCB" longword unsigned;		/* Addr of alternate UCB for this unit
	end PREFERED_DUAL_PATH;
    end DUAL_PATH;
    constant DP_LENGTH equals .;			/* Size of dual path UCB
    constant DP_LENGTH equals . tag C;			/* size of dual path UCB
    constant "2P_LENGTH" equals .;			/* Size of dual path UCB
    constant "2P_LENGTH" equals . tag C;		/* size of dual path UCB
    #2P_LENGTH  = .;
end DUALPATH_EXTENSION;

/*
/* ALL DISKS AND TAPES
/*
    
aggregate DISKTAPE_UCB_EXTENSION structure prefix UCB$;
    fill_disktape byte dimension #2P_LENGTH fill;
    DIRSEQ structure word unsigned;			/* Directory sequence number
	filler bitfield length 15 fill;			{   skip value portion of sequence number
	AST_ARMED bitfield mask;			/*  Blocking AST armed flag
    end DIRSEQ;
    ONLCNT byte unsigned;				/* Online count
    reserved byte fill;					{  Reserved byte
    DISKTAPE_OVERLAY union fill;
	MAXBLOCK longword unsigned;			/* Random access device highest block
	RECORD longword unsigned;			/* Current tape position or frame counter
    end DISKTAPE_OVERLAY;
    constant LCL_TAPE_LENGTH equals .;			/* Size of local tape UCB
    constant LCL_TAPE_LENGTH equals . tag C;		/* Size of local tape UCB
    MAXBCNT  longword unsigned;				/* Maximum transfer BCNT
    DCCB longword unsigned;				/* Pointer to data cache control block
    #BEGIN_LOCAL_DISKS = .;
    #BEGIN_MSCP = .;
end DISKTAPE_UCB_EXTENSION;

aggregate LCL_DISK_UCB_EXTENSION structure prefix UCB$;
    fill_lcl_disk byte dimension #BEGIN_LOCAL_DISKS fill;
    MEDIA structure longword unsigned;			/* Media address (longword)
	DA word unsigned;				/* Saved desired sector/track address register
	DC word unsigned;				/* Saved desired cylinder address register
    end MEDIA;
    BCR structure longword unsigned;			/* Byte count register
	BCR word unsigned;
    end BCR;
    EC1 word unsigned;					/* ECC position register
    EC2 word unsigned;					/* ECC pattern register
    OFFSET word unsigned;				/* Current offset register contents
    OFFNDX byte unsigned;				/* Current offset table index
    OFFRTC byte unsigned;				/* Current offset retry count
    constant LCL_DISK_LENGTH equals .;			/* Size of local disk UCB
    constant LCL_DISK_LENGTH equals . tag C;		/* Size of local disk UCB
    
/*
/* FLOPPY DEPENDENT BIT DEFINITIONS
/*
    DX_BUF longword unsigned;				/*ADDRESS OF SECTOR BUFFER 
    DX_BFPNT longword unsigned;				/*CURRENT SECTOR BUFFER POINTER 
    DX_RXDB longword unsigned;				/*SAVED RECEIVER DATA BUFFER 
    DX_BCR word unsigned;				/*CURRENT FLOPPY BYTE COUNT 
    DX_SCTCNT byte unsigned;				/*CURRENT SECTOR BYTE COUNT 
    FILL_2 byte fill prefix UCBDEF tag $$;		/*SPARE UNUSED BYTE 

end LCL_DISK_UCB_EXTENSION;
/*
/* MSCP DISKS AND TAPES UCB EXTENSION
/*

aggregate MSCP_UCB_EXTENSION structure prefix UCB$;
    mscp_fill byte dimension #BEGIN_MSCP fill;
    CDDB longword unsigned;				/* Pointer to active CDDB
    "2P_CDDB" longword unsigned;			/* Pointer to alternate CDDB
    CDDB_LINK longword unsigned;			/* Pointer to next UCB in CDDB chain
    CDT longword unsigned;				/* Pointer to active CDT
    UNIT_ID quadword unsigned;				/* Unique MSCP unit identifier
    MSCPUNIT word unsigned;				/* Primary path MSCP unit number 
    "2P_MSCPUNIT" word unsigned;			/* Secondary path MSCP unit number
    MSCPDEVPARAM longword unsigned;			/* MSCP device-dependent parameters
    WAIT_CDDB longword unsigned;			/* Address of the CDDB waiting for mnt. ver.
							{  to complete on this UCB
    UNIT_FLAGS word unsigned;				/* MSCP unit flags
    reserved word unsigned fill;			{  reserved word, for alignment
    MSCP_RESV quadword unsigned;			/* Reserved for MSCP enhancements
    constant MSCP_DISK_LENGTH equals .;			/* Size of MSCP disk UCB
    constant MSCP_TAPE_LENGTH equals .;			/* Size of MSCP tape UCB

end MSCP_UCB_EXTENSION;

/*
/* NETWORK LOGICAL LINK (NETWORK MAILBOX) EXTENSION
/*

aggregate UCBDEF7 structure prefix UCB$;
    FILL_11 byte dimension UCB$K_LENGTH fill prefix UCBDEF tag $$;
    NT_DATSSB longword unsigned;			/* ADDRESS OF DATA SUBCHANNEL STATUS BLOCK 
    NT_INTSSB longword unsigned;			/* ADDRESS OF INT/LS SSB 
    NT_CHAN word unsigned;				/* DDCMP CHANNEL NO. 
    FILL_3_OVERLAY union fill;
        FILL_3 word fill prefix UCBDEF tag $$;		/* DUMMY FIELD 
	FILL_3_BITS structure fill;
            LTYPE bitfield length 2;			/* LINK TYPE BITS 
            SEGFLO bitfield;				/* SEGMENT REQUEST COUNTS 
            MSGFLO bitfield;				/* MESSAGE REQUEST COUNTS 
            MSGACK bitfield;				/* MESSAGE ACK/NAK 
            BACKP bitfield mask;			/* BACKPRESSURE (1=> NO FLOW) 
            LNKPRI bitfield length 2;			/* LINK PRIORITY (IGNORED) 
	end FILL_3_BITS;
        	 					/* NETWORK CONSTANTS 
        constant LOGLNK	equals 1  prefix UCB tag $C;	/* CONNECT IS FOR LOGICAL LINK (NOT SINGLE MSG) 
    end FILL_3_OVERLAY;
end UCBDEF7;

/*
/* JOURNAL DEVICE EXTENSION
/*

aggregate UCBDEF8 structure prefix UCB$;
    FILL_12 byte dimension UCB$K_ERL_LENGTH fill prefix UCBDEF tag $$;
    JNL_BCB_OVERLAY union fill;
        JNL_BCB longword unsigned;			/* ADDRESS OF BUFFER CONTROL BLOCK 
        JNL_ADL longword unsigned;			/* ALLOCATED JOURNAL DEVICE LIST 
    end JNL_BCB_OVERLAY;
    JNL_RUL longword unsigned;				/* ADDRESS OF RUL (RU JOURNALS ONLY) 
    JNL_WQFL longword unsigned;				/* WAIT QUEUE FORWARD LINK 
    JNL_WQBL longword unsigned;				/* WAIT QUEUE BACKWARD LINK 
    JNL_FQFL longword unsigned;				/* FORCE QUEUE FORWARD LINK 
    JNL_FQBL longword unsigned;				/* FORCE QUEUE BACKWARD LINK 
    JNL_NAM character;					/* JOURNAL NAME LENGTH 
    JNL_NAM byte unsigned dimension 18;			/* JOURNAL NAME 
    FILL_4 byte fill prefix UCBDEF tag $$;		/* SPARE 
    JNL_QUOT longword unsigned;				/* QUOTA FOR RU JOURNALS 
    JNL_ID word unsigned;				/* JOURNAL ID (TAPES ONLY) 
    JNL_MUNIT word unsigned;				/* MASTER'S DEVICE UNIT NUMBER 
    JNL_MASK longword unsigned;				/* JOURNAL MASK 
    JNL_ASID_OVERLAY union fill;
        JNL_ASID longword unsigned;			/* ASSIGN ID 
        JNL_NDL longword unsigned;			/* POINTER TO NAME TABLE DEVICE LIST 
    end JNL_ASID_OVERLAY;
    JNL_REFC longword unsigned;				/* LOCAL REFERENCE COUNT 
    JNL_TREFC longword unsigned;			/* TOTAL REFERENCE COUNT 
    JNL_MXENT word unsigned;				/* MAXIMUM ENTRY SIZE 
    JNL_PROT word unsigned;				/* PROTECTION MASK 
    JNL_WRCNT longword unsigned;			/* WRITE COUNT
    JNL_BWCNT longword unsigned;			/* BUFFER WRITE COUNT
    JNL_EXCNT longword unsigned;			/* JOURNAL EXTEND COUNT
    JNL_FAILQFL longword unsigned;			/* FAIL OVER WAIT Q FORWARD LINK
    JNL_FAILQBL longword unsigned;			/* FAIL OVER WAIT Q BACKWARD LINK
    JNLSEQ_OVLY union fill;
	JNL_LSEQNO	longword unsigned;		/* LOCAL SEQUENCE NUMBER
	JNL_BTXSEQNO	longword unsigned;		/* BLOCK TRANSFER SEQ NUM (PROTO UCB ONLY)
    end JNLSEQ_OVLY;
    JNL_ACBM	longword unsigned;			/* ADDRESS OF ACCESS BIT MAP
    JNL_RMBLK	longword unsigned;			/* ADDRESS OF REMASTER BLOCK
    JNL_CWQFL	longword unsigned;			/* Cluster write Q forward link
    JNL_CWQBL	longword unsigned;			/* Cluster write Q backward link
    JNL_WCBFL   longword unsigned;			/* WCB LISTHEAD FORWARD LINK 
    JNL_WCBBL   longword unsigned;			/* WCB LISTHEAD BACKWARD LINK 
    FILL_5 longword fill prefix UCBDEF tag $$;		/* SPARE 
    constant JNL_LENGTH equals . prefix UCB$ tag C;	/* JOURNAL UCB LENGTH 
end UCBDEF8;

/*
/* NI DEVICE EXTENSION
/*

aggregate UCBDEF9 structure prefix UCB$;
    FILL_13 byte dimension UCB$K_LENGTH fill prefix UCBDEF tag $$;
    NI_HWAPTR longword unsigned;			/*ADDRESS OF NI DEVICE HARDWARE ADDRESS
    NI_MLTPTR longword unsigned;			/*ADDRESS OF PROTOCOL MULTICAST TABLE
    constant NI_LENGTH equals . prefix UCB$ tag K;	/*SIZE OF NI DEVICE UCB 
    constant NI_LENGTH equals . prefix UCB$ tag C;	/*SIZE OF NI DEVICE UCB 
end UCBDEF9;
    
end_module $UCBDEF;


MODULE $TTYUCBDEF;
/*
/*  $TTYUCBDEF follows here only because there is no way to get the 
/*  UCB$K_LENGTH symbol into another module. TTYUCBDEF was formerly
/*  included in TTYDEF.MAR.
/*
/* TERMINAL DRIVER DEFINITIONS
/*
/* These definitions define the device dependent extensions of the UCB.
/* Certain portions of the ucb are assumed to be contiguous and must not
/* be split. These areas are documented in the following definitions.
/*

aggregate TTYUCBDEF structure prefix UCB$;

	TT_UCBFILL byte dimension #UCB_LENGTH fill prefix UCBDEF tag $$; 
/*
/* Logical terminal UCB extension
/*

	TL_CTRLY	longword unsigned; 	/* CONTROL Y AST BLOCK LIST HEAD
	TL_CTRLC	longword unsigned;  	/* CONTROL C AST BLOCK LIST HEAD
	TL_OUTBAND	longword unsigned; 	/* OUT OF BAND CHARACTER MASK
	TL_BANDQUE	longword unsigned; 	/* OUT OF BAND AST QUEUE
	TL_PHYUCB	longword unsigned; 	/* THE PHYSICAL UCB ADDRESS
	TL_CTLPID	longword unsigned; 	/* CONTROLING PID (USED WITH SPAWN)
	TL_BRKTHRU	quadword unsigned; 	/* FACILITY BROADCAST BITMASK

	constant TL_LENGTH equals . tag C;
	constant TL_LENGTH equals . tag K;
/*
/* Terminal class driver dependant region
/* Split here between local and remote terminal UCB's
/*
	TTYRTTUCB union;	/* local/remote union (overlay)

	TTYUCB structure;	/* this structure defines remainder of local ucb

/* READ TIMEOUT CONTROL

	TT_RDUE		longword unsigned;  	/* ABSTIME WHEN READ TIMEOUT DUE
	TT_RTIMOU	longword unsigned; 	/* ADDRESS OF READ TIMEOUT ROUTINE

/* TERMINAL DRIVER STATE TABLE

	TT_STATE_OVERLAY union fill;
	TT_STATE	quadword unsigned; 	/* CURRENT UNIT STATE VECTOR
	TT_STATE_Q_BLOCK structure fill;
	  TT_STATE1_OVERLAY union fill;
	    TT_STATE1	longword unsigned;
	    TT_STATE1_FIELDS structure fill prefix TTY$;
		ST_POWER	bitfield mask;	/*
		ST_CTRLS	bitfield mask;	/*
		ST_FILL		bitfield mask;	/*
		ST_CURSOR	bitfield mask;	/*
		ST_SENDLF	bitfield mask;	/*
		ST_BACKSPACE	bitfield mask;	/*
		ST_MULTI	bitfield mask;	/*
		ST_WRITE	bitfield mask; 	
		ST_EOL		bitfield mask;	/*
		ST_EDITREAD	bitfield mask;	/*
		ST_RDVERIFY	bitfield mask;	/*
		ST_RECALL	bitfield mask;	/*
		ST_READ		bitfield mask;	/*
	    end TT_STATE1_FIELDS;
	  end TT_STATE1_OVERLAY;

	  TT_STATE2_OVERLAY union fill;
	    TT_STATE2 longword unsigned;
	    TT_STATE2_FIELDS structure fill prefix TTY$;
		ST_CTRLO	bitfield mask;	/*
		ST_DEL		bitfield mask;	/*
		ST_PASALL	bitfield mask;	/*
		ST_NOECHO	bitfield mask;	/*
		ST_WRTALL	bitfield mask;	/*
		ST_PROMPT	bitfield mask;	/*
		ST_NOFLTR	bitfield mask;	/*
		ST_ESC		bitfield mask;	/*
		ST_BADESC	bitfield mask;	/*
		ST_NL		bitfield mask;	/*
		ST_REFRSH	bitfield mask;	/*
		ST_ESCAPE	bitfield mask;	/*
		ST_TYPFUL	bitfield mask;	/*
		ST_SKIPLF	bitfield mask;	/*
		ST_ESC_O	bitfield mask;	/*
		ST_WRAP		bitfield mask;	/*
		ST_OVRFLO	bitfield mask;	/*
		ST_AUTOP	bitfield mask;	/*
		ST_CTRLR	bitfield mask;	/*
		ST_SKIPCRLF	bitfield mask;	/*
		ST_EDITING	bitfield mask;	/*
		ST_TABEXPAND	bitfield mask;	/*
		ST_QUOTING	bitfield mask;	/*
		ST_OVERSTRIKE	bitfield mask;	/*
		ST_TERMNORM	bitfield mask;	/*
		ST_ECHAES	bitfield mask;	/*
		ST_PRE		bitfield mask;	/*
		ST_NINTMULTI	bitfield mask;	/*
		ST_RECONNECT	bitfield mask;	/*
		ST_CTSLOW	bitfield mask;  /*
		ST_TABRIGHT	bitfield mask;	/*
	    end TT_STATE2_FIELDS;
	  end TT_STATE2_OVERLAY;
	end TT_STATE_Q_BLOCK;
	end TT_STATE_OVERLAY;

	TT_LOGUCB	longword unsigned;	/* ADDRESS OF THE LOGICAL UCB

/* DEFAULT CHARACTERISTICS

	TT_DECHAR	longword unsigned; 	/* DEFAULT DEVICE CHARACTERISTICS
	TT_DECHA1	longword unsigned; 	/* DEFAULT DEVICE CHAR EXTENSIONS

/* WRITE QUEUE POINTERS

	TT_WFLINK	longword unsigned; 	/* Write queue forward link.
	TT_WBLINK	longword unsigned; 	/* Write queue backward link.
	TT_WRTBUF	longword unsigned; 	/* Current write buffer block.
/* ADDRESS AND LENGTH OF MULTI-ECHO STRING

	TT_MULTI	longword unsigned; 	/* CURRENT MULTIECHO BUFFER ADDRESS
	TT_MULTILEN	word unsigned;		/* LENGTH OF STRING TO OUTPUT
	TT_SMLTLEN	word unsigned;		/* SAVED MULTI LENGTH
	TT_SMLT		longword unsigned;	/* AND THE SAVED ADDRESS
/* Typeahead buffer address

	TT_TYPAHD	longword unsigned;	 /* TYPEAHEAD BUFFER ADDRESS

/*-- **********************************************************************

/* DEFAULT SPEED, FILL ,PARITY (MUST BE CONTIGUOUS)

/*++ *******************************************************************

	TT_DESPEE	word unsigned; 		/* DEFAULT SPEED
	TT_DECRF	byte unsigned;	 	/* DEFAULT CR FILL
	TT_DELFF	byte unsigned;	 	/* DEFAULT LF FILL

	TT_DEPARI	byte unsigned;		/* DEFAULT PARITY/CHAR SIZE
	TT_DEFSPE_SPARE1 byte unsigned;
	TT_DEFSPE_SPARE2 word unsigned;
/*-- **********************************************************************
/*
/* DEFAULT TERMINAL TYPE AND SIZE (MUST BE CONTIGUOUS)
/*
/*++  ***********************************************************************

	TT_DETYPE	byte unsigned; 		/* DEFAULT TERMINAL TYPE
	TT_DESIZE	word unsigned; 		/* DEFAULT LINE SIZE
	TT_SPARE1 	byte unsigned;		/* SPARE BYTE MUST FOLLOW
/*-- **********************************************************************

/* SPEED, FILL, PARITY (MUST BE CONTIGUOUS)

/*++ *****************************************************************

	TT_SPEED_OVERLAY union fill;
	    TT_SPEED	word unsigned; 		/* SPEED CODES (SPLIT SPEED)
	    TT_SPEED_FIELDS structure fill;
		TT_TSPEED byte unsigned;	/* TRANSMIT SPEED
		TT_RSPEED byte unsigned; 	/* RECEIVE SPEED
	    end TT_SPEED_FIELDS;
	end TT_SPEED_OVERLAY;

	TT_CRFILL	byte unsigned; 		/* NUMBER FILLS TO OUTPUT ON CR
	TT_LFFILL	byte unsigned; 		/* NUMBER FILLS TO OUTPUT ON LF

	PARITY_OVERLAY union fill;
	    TT_PARITY	byte unsigned;		/* PARITY AND CHARACTER SIZE DEFINITIONS
	    TT_PARITY_BITS structure fill;
		TT_XXPARITY 	bitfield mask;	/* UNUSED ??
		TT_DISPARERR 	bitfield mask;	/* SPECIFY DISREGARD PARITY ERRORS
		TT_USERFRAME 	bitfield mask;	/* SPECIFY USER FRAME SETUP
		TT_LEN bitfield mask length 2;	/* CHARACTER LENGTH
		TT_STOP 	bitfield mask;	/* STOP BITS
		TT_PARTY 	bitfield mask; 	/* PARITY ENABLED
		TT_ODD 		bitfield mask; 	/* ODD PARITY
	    end TT_PARITY_BITS;
	end PARITY_OVERLAY;
	TT_PAR_SPARE1	byte unsigned;
	TT_PAR_SPARE2	word unsigned;
/*-- ******************************************************************

/* CURRENT CURSOR AND LINE POSITION FOR FORMATTED OPERATIONS

	TT_CURSOR	word unsigned;		/* CURRENT CURSOR POSITION
	TT_LINE		byte unsigned;	 	/* CURRENT LINE ON PAGE
	TT_LASTC	byte unsigned;	 	/* LAST FORMATTED OUTPUT CHARACTER

/* Number of back spaces to output for non-ansi terminals

	TT_BSPLEN	word unsigned;		/* NUMBER OF BACKSPACES

/* FILL HANDLING

	TT_FILL		byte unsigned;		/* CURRENT FILL COUNT

/* ESCAPE SYNTAX RULE STATE.

	TT_ESC		byte unsigned;	 	/* CURRENT  READ ESCAPE SYNTAX STATE
	TT_ESC_O	byte unsigned;		/* OUPUT ESCAPE STATE

/* Count of characters in interrupt string

	TT_INTCNT	byte unsigned;

/* Bit used for modem control

	TT_UNITBIT	word unsigned;		/* BIT USED TO ENABLE AND DISABLE MODEM CONTROL.

/* PORT SPECIFIC OUTPUT CONTROL

	TT_HOLD_OVERLAY union fill;
	    TT_HOLD word unsigned; 	/* UNIT HOLDING TANK AND PORT DISPATCH
	    TT_HOLD_BITS structure fill prefix TTY$;
		TANK_CHAR 	byte unsigned;	/* CHARACTER
		TANK_PREMPT 	bitfield mask;	/* SEND PREMPT CHARACTER
		TANK_STOP 	bitfield mask;	/* STOP OUTPUT
		TANK_HOLD 	bitfield mask;	/* CHAR IN TANK
		TANK_BURST 	bitfield mask;	/* BURST ACTIVE
		TANK_DMA 	bitfield mask;	/* DMA ACTIVE **** SHOULD MOVE BEFORE BURST ****
	    end TT_HOLD_BITS;
	end TT_HOLD_OVERLAY;

	TT_PREMPT	byte unsigned;		/* THE BYTE USED TO PREMPT INPUT
	TT_OUTYPE	byte unsigned;		/* TYPE OF OUTPUT THAT THIS CALL

/* CLASS & PORT VECTOR POINTERS

	TT_GETNXT	longword unsigned; 	/* ADDRESS OF CLASS INPUT ROUTINE
	TT_PUTNXT	longword unsigned; 	/* ADDRESS OF CLASS OUTPUT ROUTINE
	TT_CLASS	longword unsigned; 	/* ADDRESS OF CLASS VECTOR
	TT_PORT		longword unsigned; 	/* ADDRESS OF PORT VECTOR

	TT_OUTADR	longword unsigned;	/* ADDRESS OF OUTPUT  CURRENT STREAM
	TT_OUTLEN	word unsigned;		/* LENGTH OF OUTPUT STREAM

	TT_PRTCTL_OVERLAY union fill;
	    TT_PRTCTL	word unsigned;		/* THE PORT DRIVER CONTROL WORD
	    TT_PRTCTL_BITS structure fill prefix TTY$;
		PC_NOTIME bitfield mask;	/* IF SET NO TIMEOUT WILL BE CALCULATED
		PC_DMAENA bitfield mask;	/* DMA CURRENTLY ENABLED 
		PC_DMAAVL bitfield mask;	/* DMA SUPPORTED ON THIS PORT
		PC_PRMMAP bitfield mask;	/* UNIT CAN HAVE PERMANENT MAP REGISTERS
		PC_MAPAVL bitfield mask;	/* MAP REGISTER CURRENTLY ALLOCATED
		PC_XOFAVL bitfield mask;	/* AUTO XOFF SUPPORTED ON THIS PORT
		PC_XOFENA bitfield mask;	/* AUTO XOFF CURRENTLY ENABLED 
		PC_NOCRLF bitfield mask;	/* don't do free linefeed after creturn
	    end TT_PRTCTL_BITS;
	end TT_PRTCTL_OVERLAY;

/* MODEM CONTROL DEFINITIONS

	TT_DS_RCV	byte unsigned;		/* CURRENT RECEIVE MODEM
	TT_DS_TX	byte unsigned;		/* CURRENT TRANSMIT MODEM
	TT_DS_ST	word unsigned;		/* CURRENT MODEM STATE
	TT_DS_TIM	word unsigned;		/* CURRENT MODEM TIMEOUT

	TT_MAINT_OVERLAY union fill;
	    TT_MAINT	byte unsigned;		/* MAINTENANCE PARAMETERS
	    TT_MAINT_BITS structure fill;
		TT_MAINT_FILL bitfield length 7;
		TT_DSBL bitfield mask;		/* LINE DISABLED
	    end TT_MAINT_BITS;
	end TT_MAINT_OVERLAY;

	TT_OLDCPZORG	byte unsigned;		/* spare byte make this longword alligned

	constant TT_CLSLEN equals . tag C;
	constant TT_CLSLEN equals . tag K;

/*****************************************************************
/*
/* Terminal Port driver dependant extension region

	TP_MAP	longword unsigned;		/* UNIBUS MAP REGISTERS
	TP_STAT_OVERLAY union fill;
	    TP_STAT	byte unsigned;		/* DMA PORT SPECIFIC STATUS
	    TP_STAT_BITS structure fill prefix TTY$; /* BITS DEFINED IN THE DMA STATUS WORD
		TP_ABORT bitfield mask;		/* DMA ABORT REQUESTED ON THIS LINE
		TP_ALLOC bitfield mask;		/* ALLOC MAP FORK IN PROGRESS
		TP_DLLOC bitfield mask;		/* DEALLOCATE MAP FORK IN PROGRESS
	    end TP_STAT_BITS;
	end TP_STAT_OVERLAY;

	TP_SPARE1	byte unsigned;
	TP_SPARE2	word unsigned;

	constant TP_LENGTH equals . tag C;
	constant TP_LENGTH equals . tag K;
	constant TT_LENGTH equals . tag C;
	constant TT_LENGTH equals . tag K;

	TT_STATE_SX structure prefix TTY$;
		SX_POWER	bitfield;	/*	
		SX_CTRLS	bitfield;	/*
		SX_FILL		bitfield;	/*
		SX_CURSOR	bitfield;	/*
		SX_SENDLF	bitfield;	/*
		SX_BACKSPACE	bitfield;	/* OUTPUT BACKSPACES FOR SEVERAL LOOPS
		SX_MULTI	bitfield;	/*
		SX_WRITE	bitfield;	/* Write state
		SX_EOL		bitfield;	/*
		SX_EDITREAD	bitfield;	/*
		SX_RDVERIFY	bitfield;	/*
		SX_RECALL	bitfield;	/*
		SX_READ		bitfield;	/*
		SX_FILLBITS	bitfield length 32-^;	/* END OF FIRST LONGWORD

		SX_CTRLO	bitfield;	/*
		SX_DEL		bitfield;	/*
		SX_PASALL	bitfield;	/*
		SX_NOECHO	bitfield;	/*
		SX_WRTALL	bitfield;	/*
		SX_PROMPT	bitfield;	/*
		SX_NOFLTR	bitfield;	/*
		SX_ESC		bitfield;	/*
		SX_BADESC	bitfield;	/*
		SX_NL		bitfield;	/* New line must directly precede
		SX_REFRSH	bitfield;	/* refresh, or all breaks.
		SX_ESCAPE	bitfield;	/*
		SX_TYPFUL	bitfield;	/*
		SX_SKIPLF	bitfield;	/*
		SX_ESC_O	bitfield;	/*
		SX_WRAP		bitfield;	/*
		SX_OVRFLO	bitfield;	/*
		SX_AUTOP	bitfield;	/*
		SX_CTRLR	bitfield;	/*
		SX_SKIPCRLF	bitfield;	/*
		SX_EDITING	bitfield;	/*
		SX_TABEXPAND	bitfield;	/*
		SX_QUOTING	bitfield;	/*
		SX_OVERSTRIKE	bitfield;	/*
		SX_TERMNORM	bitfield;	/*
		SX_ECHAES	bitfield;	/*
		SX_PRE		bitfield;	/*
		SX_NINTMULTI	bitfield;	/*
		SX_RECONNECT	bitfield;	/*
		SX_CTSLOW	bitfield;	/*
		SX_TABRIGHT	bitfield;	/*
	    end TT_STATE_SX;
	end TTYUCB;

/* remote terminal extension

	RTTUCB structure;

	    RTT_NETUCB		longword unsigned;	/* NET DEVICE UCB
	    RTT_NETWIND		longword unsigned;	/* NET DEVICE WCB
	    RTT_IRPFL		longword unsigned;	/* IRP QUEUE
	    RTT_IRPBL		longword unsigned;	/* IRP QUEUE
	    RTT_NETIRP		longword unsigned;	/* READ NET IIRP
	    RTT_BANDINCL	longword unsigned;	/* OUT OF BAND INCLUDES
	    RTT_BANDINMSK	longword unsigned;	/* OUT OF BAND INCLUDE MASK
	    RTT_BANDEXCL	longword unsigned;	/* out of band exclude mask
	    RTT_BANDEXMSK	longword unsigned;	/* out of band exclude

	    RTT_PROVRS		byte unsigned;		/* PROTOCOL VERSION
	    RTT_PROECO		byte unsigned;		/* PROTOCOL ECO
	    RTT_LINK		word unsigned;		/* LINK NUMBER (for LOGINOUT)

	    RTT_OBJ		byte unsigned;		/* OBJECT NUMBER CONNECTED
	    RTT_SYSTYPE		word unsigned;		/* SYSTEM TYPE (VMS=7)
	    RTT_FILLBYTE	byte unsigned;		/* fill - use when convenient

/*	CTERM driver only

	    CT_FLAGS_OVERLAY union fill;
	        CT_FLAGS	word unsigned;		/* MISC FLAGS
	        CT_FLAGS_BITS structure fill prefix "FLG$";
 		    WIIRP_BSY	bitfield mask;		/* WIIRP BUSY
		    CTRLO	bitfield mask;		/* CTRLO IN PROGRESS
		    CANCTRLO	bitfield mask;		/* CANCEL CTRLO ON WRITE
		    INWRTFDT	bitfield mask;		/* IN WRITE FDT 
		    QUOTA	bitfield mask;		/* QUOTA CHARGED
		    VAXTOVAX	bitfield mask;		/* VAX TO VAX
		    BUFFER	bitfield mask;		/* DO BUFFERED WRITES
	    	end CT_FLAGS_BITS;
 	    end CT_FLAGS_OVERLAY;

	    CT_QCTPCNT		word unsigned;		/* QUEUED CTP COUNT
	    CT_WIIRP		longword unsigned;	/* WRITE IIRP
	    CT_TQE		longword unsigned;	/* TQE ADDRESS
	    CT_NETQFL		longword unsigned;	/* WAITING FOR WRITE
	    CT_NETQBL		longword unsigned;	/*   TO NET QUEUE
	    CT_STALLQFL		longword unsigned;	/* IRPs BEING HELD
	    CT_STALLQBL		longword unsigned;	/*   QUEUE
	    CT_WRTCTP		longword unsigned;	/* BUFFERED WRITE CTP
	    CT_WRTCUR		longword unsigned;	/* CURRENT FILL POINTER
	    CT_WRTSIZ    	word unsigned;		/* REMAINING SIZE
	    CT_WRTCNT		word unsigned;		/* COUNT SINCE LAST TQE
	    CT_MAXMSG		word unsigned;		/* MAX WRITE TO NET SIZE
	    CT_MAXREAD		word unsigned;		/* MAX READ IN SERVER
	    CT_LEGALMSG		longword unsigned;	/* LEGAL MESSAGE MASK
	    CT_VERSION		byte unsigned;		/* CTERM VERSION
	    CT_ECO		byte unsigned;		/* CTERM ECO
	    CT_FILLWORD		word unsigned;		/* fill

	    CT_DEBUG_FILL	CHARACTER LENGTH 4*10;	/* 10 LONGWORD FOR DEBUG

	constant RTT_LENGTH equals . tag C;		/* Length must be same for both RTTDRIVER
	constant RTT_LENGTH equals . tag K;		/* and CTDRIVER.

	end RTTUCB;

    end TTYRTTUCB;	/* end union

end TTYUCBDEF;

end_module $TTYUCBDEF;


module $VADEF;

/*+
/* VIRTUAL ADDRESS VIELDS
/*-


aggregate VADEF  union prefix VA$;
    VADEF_BITS0 structure fill;
        "BYTE" bitfield mask length 9;			/*BYTE VIELD 
        VPN bitfield mask length 21;			/*VIRTUAL PAGE NUMBER 
        P1 bitfield mask;				/*P1 SPACE 
        SYSTEM bitfield mask;				/*SYSTEM SPACE 
    end VADEF_BITS0;
    VADEF_BITS1 structure fill;
        FILL_1 bitfield length 9 fill prefix VADEF tag $$;
        VPG bitfield mask length 23;			/*VIRTUAL PAGE INCLUDING P1 & S 
    end VADEF_BITS1;
end VADEF;

end_module $VADEF;


module $VCADEF;
/*+
/*
/* VCA - Volume Cache Block. This block contains the specialized caches for
/* a disk volume; to wit, the file ID cache, the extent cache, and the quota
/* file cache. The file ID cache and extent cache are together in one block;
/* the quota cache is located separately in another block. Both are pointed to
/* by the VCB.
/*
/*-



aggregate VCADEF structure prefix VCA$;
    FIDCACHE longword unsigned;			/* pointer to file ID cache 
    EXTCACHE longword unsigned;			/* pointer to extent cache 
    SIZE word unsigned;				/* block size 
    TYPE byte unsigned;				/* block type code 
    FLAGS structure byte;			/* cache flags
	FIDC_VALID bitfield mask;		/* FID cache valid
	EXTC_VALID bitfield mask;		/* Extent cache valid
	FIDC_FLUSH bitfield mask;		/* FID cache to be flushed
	EXTC_FLUSH bitfield mask;		/* Extent cache to be flushed
    end FLAGS;
    constant "LENGTH" equals . tag K;		/* length of block header 
    constant "LENGTH" equals . tag C;		/* length of block header 
/*
/* The file ID cache consists of the cache header, followed by a longword
/* vector of file numbers, densely packed.
/*
end VCADEF;

aggregate VCADEF1 structure prefix VCA$;
    FIDSIZE word unsigned;			/* number of entries allocated 
    FIDCOUNT word unsigned;			/* number of entries present 
    FIDCLKID longword unsigned;			/* FID cache lock id.
    FIDCACB byte unsigned dimension 28;		/* FID cache blocking ACB
    FIDLIST longword unsigned;			/* first entry in list 
/*
/* The extent cache consists of the cache header, followed by a quadword
/* vector of extents, densely packed. Each quadword contains block count
/* and starting LBN.
/*
end VCADEF1;

aggregate VCADEF2 structure prefix VCA$;
    EXTSIZE word unsigned;			/* number of entries allocated 
    EXTCOUNT word unsigned;			/* number of entries present 
    EXTTOTAL longword unsigned;			/* total number of blocks contained in cache 
    EXTLIMIT word unsigned;			/* limit of volume to be cached, in percent/10 
    FILL_2 word fill tag $$;			/* spare 
    EXTCLKID longword unsigned;			/* EXT cache lock id.
    EXTCACB byte unsigned dimension 28;		/* Extent cache blocking ACB.
    EXTLIST quadword unsigned;			/* first entry in list 
end VCADEF2;

aggregate VCADEF3 structure prefix VCA$;
    EXTBLOCKS longword unsigned;		/* number of blocks 
    EXTLBN longword unsigned;			/* starting LBN 
/*
/* The quota cache consists of the cache header, followed by the cache
/* entries. Each cache entry is a block as defined below.
/*
end VCADEF3;

aggregate VCADEF4 structure prefix VCA$;
    QUOSIZE word unsigned;			/* number of entries allocated 
    QUOLRU word unsigned;			/* current LRU counter 
    QUOCLKID longword unsigned;			/* whole cache lock ID
    FILL_3 byte dimension 3 fill tag $$;	/* 2nd longword & block size & type 
    QUOCFLAGS structure byte;			/* cache flags
	CACHEVALID bitfield mask;		/* cache is valid
	CACHEFLUSH bitfield mask;		/* cache is to be flushed
    end QUOCACHEFLAGS;
    QUOACB byte unsigned dimension 28;		/* ACB to deliver blocking AST
    QUOFLUSHACB byte unsigned dimension 28;	/* ACB to deliver cache flush AST
    QUOLIST longword unsigned;			/* start of entries 
    
end VCADEF4;

aggregate VCADEF5 structure prefix VCA$;
    QUOLOCK structure;				/* lock status block
	QUOSTATUS_OVERLAY union fill;
	    QUOSTATUS word unsigned;		/* $ENQ status
	    QUOINDEX word unsigned;		/* index in cache of this entry
	end QUOSTATUS_OVERLAY;
	QUOLRUX word unsigned;			/* LRU index for entry 
        QUOLKID longword unsigned;		/* lock ID of cache entry
	QUORECNUM byte unsigned dimension 3 tag L; /* record number 
	QUOFLAGS structure byte unsigned;	/* flags byte 
	    QUOVALID bitfield mask;		/* valid entry is present
	    QUODIRTY bitfield mask;		/* dirty flag 
	end QUOFLAGS;
	USAGE longword unsigned;		/* current usage 
	PERMQUOTA longword unsigned;		/* permanent quota 
	OVERDRAFT longword unsigned;		/* overdraft limit 
    end QUOLOCK;
    QUOUIC longword unsigned;			/* UIC 
    constant QUOLENGTH equals . tag K;		/* length of quota cache entry 
    constant QUOLENGTH equals . tag C;		/* length of quota cache entry 
end VCADEF5;

end_module $VCADEF;

{+
{ VCB - VOLUME CONTROL BLOCK
{
{ THERE IS ONE VOLUME CONTROL BLOCK FOR EACH MOUNTED DEVICE UNIT IN A
{ SYSTEM. IT CONTAINS INFORMATION NECESSARY TO CONTROL ACCESS TO AND
{ VERIFY CERTAIN VOLUME PARAMETERS IN THE CASE A DEVICE UNIT SHOULD
{ ERRONEOUSLY GO OFFLINE.
{-

module $VCBDEF;

aggregate VCBDEF_COMMON structure prefix VCB$;		{  COMMON VCB DEFINITIONS
    FORWARD_LINK union fill;
	FCBFL longword unsigned;			/* FCB listhead forward link
	BLOCKFL longword unsigned;			/*  or - Blocked request listhead forward link
	MEMQFL longword unsigned;			/*  or - Shadow set members queue forward link
    end FORWARD_LINK;
    BACKWARD_LINK union fill;
	FCBBL longword unsigned;			/* FCB listhead backward link
	BLOCKBL longword unsigned;			/*  or - Blocked request listhead backward link
	MEMQBL longword unsigned;			/*  or - Shadow set members queue backward link
    end BACKWARD_LINK;
    SIZE word unsigned;					/* Size of VCB in bytes
    TYPE byte unsigned;					/* structure type of VCB 

    constant MRKLEN equals .;				/* Mark length
    constant MRKLEN equals . tag C;			/* Mark length
    #VCBMARK2 = .;					/* Second mark point

    VOLSTS union fill;
	STATUS byte unsigned;				/* Volume status:
	DISK_BITS structure fill;			{   for disks:
            WRITE_IF bitfield mask;			/*    Index file is write accessed
            WRITE_SM bitfield mask;			/*    Storage map is write accessed
            HOMBLKBAD bitfield mask;			/*    Primary home block is bad
            IDXHDRBAD bitfield mask;			/*    Primary index file header is bad
            NOALLOC bitfield mask;			/*    Allocation/deallocation inhibited (bad bitmaps)
            EXTFID bitfield mask;			/*    Volume has 24 bit file numbers
            GROUP bitfield mask;			/*    Volume is mounted /group
            SYSTEM bitfield mask;			/*    Volume is mounted /system
	end DISK_BITS;
	TAPE_BITS structure fill;			{   for tapes:
            PARTFILE bitfield mask;			/*    Partial file exists on tape
            LOGICEOVS bitfield mask;			/*    Positioned at logical end of volume set
            WAIMOUVOL bitfield mask;			/*    Wait for volume mount
            WAIREWIND bitfield mask;			/*    Wait for rewind completion
            WAIUSRLBL bitfield mask;			/*    Wait for user label
            CANCELIO bitfield mask;			/*    Cancel I/O 
            MUSTCLOSE bitfield mask;			/*    Must close file
            NOWRITE bitfield mask;			/*    Don't write trailers
	end TAPE_BITS;
	SHADOW_BITS structure fill;			{   for shadow set members
	    SHADMAST bitfield mask;			/*    This VCB is for shadow set master
	    NEWSSMEMB bitfield mask;			/*    New shadow set member
	    FAILED bitfield mask;			/*    Member failed out of shadow set
	end SHADOW_BITS;
    end VOLSTS;
    TRANS word unsigned;				/* VOLUME TRANSACTION COUNT 
    RVN word unsigned;					/* RELATIVE VOLUME NUMBER 
    AQB longword unsigned;				/* ADDRESS OF AQB 
    VOLNAME character length 12;			/* VOLUME LABEL BLANK FILLED 
    RVT longword unsigned;				/* ADDRESS OF UCB OR RELATIVE VOLUME TABLE 
    #VCBMARK3 = . ;					/* THIRD MARK POINT
    constant COMLEN equals . prefix VCB$ tag K;		/* LENGTH OF COMMON AREA 
end VCBDEF_COMMON;

aggregate VCBDEF_DISKS structure prefix VCB$;
    filldisks byte dimension #VCBMARK3 fill;
    constant COMLEN equals . prefix VCB$ tag C;		/* LENGTH OF COMMON AREA 
    HOMELBN longword unsigned;				/* LBN OF VOLUME HOME BLOCK 
    HOME2LBN longword unsigned;				/* LBN OF ALTERNATE VOLUME HOME BLOCK 
    IXHDR2LBN longword unsigned;			/* LBN OF ALTERNATE INDEX FILE HEADER 
    IBMAPLBN longword unsigned;				/* LBN OF INDEX FILE BITMAP 
    SBMAPLBN longword unsigned;				/* LBN OF STORAGE BITMAP 
    IBMAPSIZE byte unsigned;				/* SIZE OF INDEX FILE BITMAP 
    SBMAPSIZE byte unsigned;				/* SIZE OF STORAGE BITMAP 
    IBMAPVBN byte unsigned;				/* CURRENT VBN IN INDEX FILE BIT MAP 
    SBMAPVBN byte unsigned;				/* CURRENT VBN IN STORAGE MAP 
    CLUSTER word unsigned;				/* VOLUME CLUSTER SIZE 
    EXTEND word unsigned;				/* VOLUME DEFAULT FILE EXTENSION LENGTH 
    FREE longword unsigned;				/* NUMBER OF FREE BLOCKS ON VOLUME 
    MAXFILES longword unsigned;				/* MAXIMUM NUMBER OF FILES ALLOWED ON VOLUME 
    WINDOW byte unsigned;				/* VOLUME DEFAULT WINDOW SIZE 
    LRU_LIM byte;					/* VOLUME DIRECTORY LRU SIZE LIMIT 
    FILEPROT word unsigned;				/* VOLUME DEFAULT FILE PROTECTION 
    MCOUNT word unsigned;				/* MOUNT COUNT 
    EOFDELTA byte unsigned;				/* INDEX FILE EOF UPDATE COUNT 
    RESFILES byte unsigned;				/* NUMBER OF RESERVED FILES ON VOLUME 
    RECORDSZ word unsigned;				/* NUMBER OF BYTES IN A RECORD 
    BLOCKFACT byte unsigned;				/* VOLUME BLOCKING FACTOR 
    STATUS2_OVERLAY union fill;
        STATUS2 byte unsigned;				/* SECOND STATUS BYTE 
	STATUS2_BITS structure fill;
            WRITETHRU bitfield;				/* VOLUME IS TO BE WRITE-THROUGH CACHED 
            NOCACHE bitfield;				/* ALL CACHEING IS DISABLED ON VOLUME 
            MOUNTVER bitfield;				/* VOLUME CAN UNDERGO MOUNT VERIFICATION 
	    ERASE bitfield;				/* ERASE DATA WHEN BLOCKS REMOVED FROM FILE
	    NOHIGHWATER bitfield;			/* TURN OFF HIGH-WATER MARKING (D = ON)
	    NOSHARE bitfield;				/* non-shared mount
	    CLUSLOCK bitfield;				/* CLUSTER WIDE LOCKING NECESSARY
	end STATUS2_BITS;
    end STATUS2_OVERLAY;
    QUOTAFCB longword unsigned;				/* ADDRESS OF FCB OF DISK QUOTA FILE 
    CACHE longword unsigned;				/* ADDRESS OF VOLUME CACHE BLOCK 
    QUOCACHE longword unsigned;				/* ADDRESS OF VOLUME QUOTA CACHE 
    QUOSIZE word unsigned;				/* LENGTH OF QUOTA CACHE TO ALLOCATE 
    PENDERR word unsigned;				/* COUNT OF PENDING WRITE ERRORS 
    SERIALNUM longword unsigned;			/* VOLUME SERIAL NUMBER (DISKS ONLY) 
    JNLIOCNT longword unsigned;				/* JOURNALING IO COUNT
    RETAINMIN quadword unsigned;			/* MINIMUM FILE RETENTION PERIOD 
    RETAINMAX quadword unsigned;			/* MAXIMUM FILE RETENTION PERIOD 
    VOLLKID longword unsigned;				/* VOLUME LOCK ID
    VOLCKNAM character length 12;			/* NAME FOR VOLUME LOCKS
    BLOCKID longword unsigned;				/* VOLUME BLOCKING LOCK.
    MOUNTTIME quadword unsigned;			/* VOLUME MOUNT TIME
    MEMHDFL longword unsigned;				/* SHADOW SET MEMBERS QUEUE HEADER FL
    MEMHDBL longword unsigned;				/* SHADOW SET MEMBERS QUEUE HEADER BL
    ACTIVITY word unsigned;				/* ACTIVITY COUNT/FLAG
    fill_1 byte fill;
    SHAD_STS byte unsigned;				/* STATUS BYTE RELATIVE TO MEMHDFL
    SHAD_RESV longword unsigned;			/* RESERVED FOR SHADOW SET PROCESSING
    ACB byte unsigned dimension 28;			/* ACB FOR BLOCKING AST.
    MIN_CLASS structure;				/* MINIMUM CLASSIFICATION
	FILL_2 byte dimension 20 fill;
    end MIN_CLASS;
    MAX_CLASS structure;				/* MAXIMUM CLASSIFICATION
	FILL_3 byte dimension 20 fill;
    end MAX_CLASS;
    constant "LENGTH" equals . prefix VCB$ tag K;	/* LENGTH OF STANDARD VCB 
    constant "LENGTH" equals . prefix VCB$ tag C;	/* LENGTH OF STANDARD VCB 
    
end VCBDEF_DISKS;

/*
/* SHADOW SET MEMBER VOLUME CONTROL BLOCK FIELDS
/*

aggregate VCBDEF_SHADOW structure prefix VCB$;
    fillshadow byte dimension #VCBMARK3 fill;
    MEM_UCB longword unsigned;				/* Shadow set member UCB address
    MAST_UCB longword unsigned;				/* Shadow set master UCB address
    MAST_VCB longword unsigned;				/* Shadow set master VCB address
    WORKQFL longword unsigned;				/* Work queue forward link
    WORKQBL longword unsigned;				/* Work queue backward link
    MSCP_STS longword unsigned;				/* MSCP status information
    SHDM_RESV quadword unsigned;			/* Reserved for future enhancements
    constant SHAD_LEN equals .;				/* Shadow set member VCB length
end VCBDEF_SHADOW;

/*
/* MTAACP VOLUME CONTROL BLOCK FIELDS
/*

aggregate VCBDEF2 structure prefix VCB$;
    FILL_3 byte dimension #VCBMARK3 fill prefix VCBDEF tag $$;
    CUR_FID_OVERLAY union fill;
        CUR_FID longword unsigned;			/* CURRENT FILE IDENTIFICATION 
	CUR_FID_FIELDS structure fill;
            CUR_NUM word unsigned;			/* CURRENT FILE SECTION NUMBER 
            CUR_SEQ word unsigned;			/* CURRENT FILE SEQUENCE NUMBER 
	end CUR_FID_FIELDS;
    end CUR_FID_OVERLAY;
    START_FID_OVERLAY union fill;
        START_FID longword unsigned;			/* FILE IDENTIFICATION AT START OF SEARCH 
	START_FID_FIELDS structure fill;
            START_NUM word unsigned;			/* FILE SECTION NUMBER AT START OF SEARCH 
            START_SEQ word unsigned;			/* FILE SEQUENCE NUMBER AT START OF SEARCH 
	end START_FID_FIELDS;
    end START_FID_OVERLAY;
    MODE_OVERLAY union fill;
        MODE word unsigned;				/* MODE OF OPERATION 
	MODE_BITS structure fill;
            OVREXP bitfield;				/* OVERRIDE EXPIRATION 
            OVRACC bitfield;				/* OVERRIDE ACCESS 
            OVRLBL bitfield;				/* OVERRIDE LABELS 
            OVRSETID bitfield;				/* OVERRIDE SET IDENTIFIER 
            INTCHG bitfield;				/* INTERCHANGE TAPE 
            EBCDIC bitfield;				/* EBCDIC CODE SET 
            NOVOL2 bitfield;				/* DO NOT WRITE A VOL2 LABEL
            NOHDR3 bitfield;				/* DO NOT WRITE HDR3 LABELS 
            STARFILE bitfield;				/* CURRENT FILE IS A STARLET PRODUCED FILE 
	    ENUSEREOT bitfield;				/* SET WHEN USER HANDLING OF EOT IS ENABLED
	    BLANK bitfield;				/* SET FOR AVL WHEN NO READ SHOULD HAPPEN FIRST
	    INIT bitfield;				/* SET FOR AVL WHEN NEXT VOL MOUNTED SHOULD BE INITED
	    NOAUTO bitfield;				/* MTAACP NOT RUNNING IN AVL AND AVR MODE
	    OVRVOLO bitfield;				/* OVERRIDE THEVOL1 OWNER IDENT FIELD
	    FIL_ACCESS bitfield;			/* SET IF ACCESS ROUTINE ALLOWS CHECK OF VMS PROTECTION ON FILE
	end MODE_BITS;
        
    end MODE_OVERLAY;
    TM byte unsigned;					/* NUMBER OF TM'S INTO FILE 
    CUR_RVN byte unsigned;				/* CURRENT RELATIVE VOLUME 
    ST_RECORD longword unsigned;			/* NUMBER OF RECORDS UP TO AND INCLUDING LAST TAPE MARK 
    MVL longword unsigned;				/* ADDRESS OF MAGNETIC TAPE VOLUME LIST 
    WCB longword unsigned;				/* ADDRESS OF WINDOW FOR THIS VOLUME 
    VPFL longword unsigned;				/* VIRTUAL PAGE LIST HEAD 
    VPBL longword unsigned;				/* VIRTUAL PAGE LIST TAIL 
    USRLBLAST longword unsigned;			/* ADDRESS OF USER LABEL AST CONTROL BLOCK 
    LBLCNT byte unsigned;				/* Count of HDRn labels read on file open
    
/* NOTE THAT FCP AND MTAACP SHARE VCB$W_MCOUNT(DISPLACEMENT 76)
    
end VCBDEF2;

aggregate VCBDEF3 structure prefix VCB$;
    FILL_4 byte dimension #VCBMARK2 fill prefix VCBDEF tag $$;
    QNAMECNT byte unsigned;				/* BYTE COUNT OF QUEUE NAME 
    QNAME character length 20;				/* ASCII NAME OF QUEUE FOR THIS DEVICE 
/*
/* JOURNAL ACP VOLUME CONTROL BLOCK FIELDS
/*
end VCBDEF3;

aggregate VCBDEF4 structure prefix VCB$;
    FILL_5 byte dimension #VCBMARK3 fill prefix VCBDEF tag $$;
    JNL_CHAR_OVERLAY union fill;
        JNL_CHAR longword unsigned;			/* journal media characteristics 
	JNL_CHAR_BITS structure fill;
            JNL_DISK bitfield mask;			/* journal is on disk 
            JNL_TAPE bitfield mask;			/* journal is on tape 
            JNL_TMPFI bitfield mask;			/* temporary file 
	end JNL_CHAR_BITS;
    end JNL_CHAR_OVERLAY;
    JNL_JFTA longword unsigned;				/* JOURNAL FILE TABLE ADDRESS (IN ACP) 
    JNL_IRPS longword unsigned dimension 2;		/* PREALLOCATED FREE IRP QUEUE HEADER 
    JNL_JMT longword unsigned;				/* ADDRESS OF JMT (JOURNAL MERGE TABLE) 
    JNL_UCB longword unsigned;				/* UCB ADDRESS 
    JNL_JMTFL longword unsigned;			/* JMT FORWARD LINK 
    JNL_JMTBL longword unsigned;			/* JMT BACKWARD LINK 
    JNL_MODE byte unsigned;				/* ACCESS MODE OF CREATOR 
    JNL_COP word unsigned;				/* NUMBER OF JOURNAL FILE COPIES 
    FILL_2 byte fill prefix VCBDEF tag $$;		/* SPARE 
    JNL_MASK longword unsigned;				/* MASK 
    constant JNL_LENGTH equals . prefix VCB$ tag K;	/* LENGTH OF JOURNAL VCB 
    constant JNL_LENGTH equals . prefix VCB$ tag C;	/* LENGTH OF JOURNAL VCB 
end VCBDEF4;

end_module $VCBDEF;

module $VL1DEF;
/*+
/* VOL1 ANSI MAGNETIC TAPE LABEL
/* THIS IS THE FIRST BLOCK ON EVERY ANSI LABELED MAGNETIC TAPE.
/* IT IDENTIFIES THE VOLUME AND ITS PROTECTION.
/*-


aggregate VL1DEF structure prefix VL1$;
    VL1LID longword unsigned;				/*LABEL IDENTIFIER AND NUMBER 'VOL1' 
    VOLLBL character length 6;				/*VOLUME LABEL 
    VOLACCESS byte unsigned;				/*VOLUME ACCESS 
    FILL_1 character length 13 fill prefix VL1DEF tag $$;/*SPACES 
    SYSCODE character length 13;			/* SYSTEM CODE
    OWNER_UNION union fill;
	OWNER_IDENT character length 14;		/* VOL1 OWNER ID FIELD
	OLD_VOLOWNER structure fill;
	   VOLOWNER character length 13;		/*VOLUME OWNER IDENTIFICATION 
	   DECSTDVER byte unsigned;				/*DEC STANDARD VERSION 
	end OLD_VOLOWNER;
    end OWNER_UNION;
    FILL_2 character length 28 fill prefix VL1DEF tag $$;/*SPACES 
    LBLSTDVER byte unsigned;				/*LABEL STANDARD VERSION '3' 
end VL1DEF;

end_module $VL1DEF;

module $VL2DEF;
/*+
/* VOL2 ANSI MAGNETIC TAPE LABEL
/* THIS IS BLOCK IS WRITTEN TO TAPES WHEN A VMS PROTECTION IS SPECIFIED
/*-


aggregate VL2DEF structure prefix VL2$;
    VL2LID longword unsigned;				/*LABEL IDENTIFIER AND NUMBER 'VOL2' 
    VOLOWNER character length 15;		/*VOLUME OWNER IDENTIFICATION 
end VL2DEF;

end_module $VL2DEF;


module $WCBDEF;

/*+
/* WCB - WINDOW CONTROL BLOCK
/*
/* THERE IS A WINDOW CONTROL BLOCK FOR EACH FILE ACCESSED BY A PROCESS.
/* IT CONTAINS MAPPING INFORMATION SUCH THAT A LARGE PERCENTAGE OF VIRTUAL
/* FILE I/O CAN BE MAPPED FROM VIRTUAL TO LOGICAL BLOCK NUMBERS WITHOUT
/* HAVING TO READ THE RESPECTIVE FILE HEADER.
/*-


aggregate WCBDEF structure prefix WCB$;
    WLFL longword unsigned;				/* WINDOW LIST FORWARD LINK 
    WLBL longword unsigned;				/* WINDOW LIST BACKWARD LINK 
    SIZE word unsigned;					/* SIZE OF WINDOW BLOCK IN BYTES 
    TYPE byte unsigned;					/* STRUCTURE TYPE OF WCB 
    ACCESS_OVERLAY union fill;
        ACCESS byte unsigned;				/* ACCESS CONTROL BYTE 
	ACCESS_BITS structure fill;
            READ bitfield mask;				/* READ ACCESS ALLOWED (1=YES) 
            WRITE bitfield mask;			/* WRITE ACCESS ALLOWED (1=YES) 
            NOTFCP bitfield mask;			/* FILE NOT ACCESSED BY FCP IF SET 
            SHRWCB bitfield mask;			/* SHARED WINDOW 
            OVERDRAWN bitfield mask;			/* FILE ACCESSOR HAS OVERDRAWN HIS QUOTA 
            COMPLETE bitfield mask;			/* SET WINDOW MAPS ENTIRE FILE 
            CATHEDRAL bitfield mask;			/* LARGE, COMPLEX WINDOW (SIC) TO MAP 
                                            		/* FILE COMPLETELY
            EXPIRE bitfield mask;			/* FILE EXPIRATION DATE MAY NEED TO BE SET 
	end ACCESS_BITS;
    end ACCESS_OVERLAY;
    PID_OVERLAY union fill;
        PID longword unsigned;				/* PROCESS ID OF ACCESSOR PROCESS 
	PID_FIELDS structure fill;
            FILL_5 byte dimension 2 fill prefix WCBDEF tag $$;
            REFCNT word unsigned;			/* REFERENCE COUNT FOR SHARED WINDOW 
	end PID_FIELDS;
    end PID_OVERLAY;
    ORGUCB longword unsigned;				/* ADDRESS OF ORIGINAL UCB FROM CCB 
    ACON_OVERLAY union fill;
        ACON word unsigned;				/* ACCESS CONTROL INFORMATION 
                                        		/* NOTE - THESE BITS TRACK THE BITS
                                        		/* IN FIB$L_ACCTL
	ACON_BITS0 structure fill;
            NOWRITE bitfield;				/* NO OTHER WRITERS 
            DLOCK bitfield;				/* ENABLE DEACCESS LOCK 
            FILL_1 bitfield length 2 fill prefix WCBDEF tag $$;/* UNUSED 
            SPOOL bitfield;				/* SPOOL FILE ON CLOSE 
            WRITECK bitfield;				/* ENABLE WRITE CHECK 
            SEQONLY bitfield;				/* SEQUENTIAL ONLY ACCESS 
            FILL_2 bitfield fill prefix WCBDEF tag $$;	/* SPARE 
            WRITEAC bitfield;				/* WRITE ACCESS 
            READCK bitfield;				/* ENABLE READ CHECK 
            NOREAD bitfield;				/* NO OTHER READERS 
            NOTRUNC bitfield;				/* NO TRUNCATES 
	end ACON_BITS0;
	ACON_BITS1 structure fill;
            FILL_3 bitfield length 2 fill prefix WCBDEF tag $$;
		/* THE FOLLOWING FIELD OVERLAYS THE FIRST
		/* UNUSED FLAG IN WCB$W_ACON ABOVE.
	    NOACCLOCK bitfield;				/* NO ACCESS LOCK CHECKING
	    FILL_4 bitfield length 8 fill prefix WCBDEF tag $$;
            READINIT bitfield;				/* A READINIT WAS DONE OVER THIS CHANNEL 
	    WRITE_TURN bitfield;			/* FORCE WINDOW TURN ON WRITES
	end ACON_BITS1;
    end ACON_OVERLAY;
    #WCBMARK2 = . ;					/* SIZE DEVICE INDEPENDENT PART OF WCB
    NMAP word unsigned;					/* NUMBER OF MAPPING POINTERS 
    FCB longword unsigned;				/* ADDRESS OF FCB 
    RVT longword unsigned;				/* ADDRESS OF RELATIVE VOLUME TABLE 
    LINK longword unsigned;				/* LINK TO NEXT WINDOW SEGMENT 
    READS longword unsigned;				/* COUNT OF READS PERFORMED 
    WRITES longword unsigned;				/* COUNT OF WRITES PERFORMED 
    STVBN longword unsigned;				/* STARTING VBN MAPPED BY WINDOW 
    constant MAP equals . prefix WCB$ tag K;		/* MAP POINTERS START HERE 
    constant MAP equals . prefix WCB$ tag C;		/* MAP POINTERS START HERE 
    constant "LENGTH" equals . prefix WCB$ tag K;	/* LENGTH OF STANDARD WCB SANS POINTERS 
    constant "LENGTH" equals . prefix WCB$ tag C;	/* LENGTH OF STANDARD WCB SANS POINTERS 
							/* NOTE THAT VIRTUAL MAPPING
							/* NEEDS P1_COUNT IMMEDIATELY
							/* FOLLOWING STVBN
    P1_COUNT word unsigned;				/* COUNT FIELD OF FIRST POINTER 
    P1_LBN longword unsigned;				/* LBN FIELD OF SECOND POINTER 
    P2_COUNT word unsigned;				/* COUNT FIELD OF SECOND POINTER 
    P2_LBN longword unsigned;				/* LBN FIELD OF FIRST POINTER 
                                    			/* FORMAT OF RETRIEVAL POINTER
end WCBDEF;

aggregate WCBDEF1 structure prefix WCB$;
    COUNT word unsigned;				/* COUNT FIELD 
    LBN longword unsigned;				/* LBN FIELD 
end WCBDEF1;

aggregate WCBDEF2 structure prefix WCB$ origin FILL_6;
    PREVCOUNT word unsigned;				/* PREVIOUS RETRIEVAL POINTER 
    PREVLBN longword unsigned;
                                    			/* RETRIEVAL POINTER FORMAT
    FILL_6 byte fill prefix WCBDEF tag $$;
end WCBDEF2;

aggregate WCBDEF3 structure prefix WCB$;
    FILL_7 byte dimension #WCBMARK2 fill prefix WCBDEF tag $$;
    JNL_REFC word unsigned;				/* REFERENCE COUNT AT $ASSJNL TIME 
    JNL_FCOD word unsigned;				/* FACILITY CODE OWNER JOURNAL CHANNEL
    JNL_STAT_OVERLAY union fill ;
	JNL_STAT byte unsigned;				/* STATUS 
	JNL_STAT_BITS structure fill ;
	    JDB bitfield mask ;				/* JDB ALLREADY WRITTEN OVER THIS CHANNEL
	end JNL_STAT_BITS ;
    end JNL_STAT_OVERLAY ;
    JNL_ACMOD byte unsigned;				/* ACCESS MODE 
    JNL_PROT word unsigned;				/* PROTECTION MASK 
    JNL_AID longword unsigned;				/* ASSIGN SEQUENCE NUMBER 
    JNL_SEQ longword unsigned;				/* SEQUENCE NUMBER LAST ENTRY WRITTEN 
    JNL_PRCNAM character length 16;			/* PROCESS NAME OF CHANNEL OWNER
    JNL_UIC longword unsigned;				/* UIC USED FOR ENTRIES WRITTEN OVER CHANNEL
    JNL_PUIC longword unsigned;				/* UIC OF PROCESS
    JNL_TIME quadword unsigned;				/* TIME AT WHICH CHANNEL WAS ASSIGNED
    JNL_WLFL longword unsigned;				/* FORWARD LINK WCB QUEUE
    JNL_WLBL longword unsigned;				/* BACKWARD LINK WCB QUEUE
    JNL_RC longword unsigned;				/* READ CONTEXT BLOCK
    constant JNL_LEN equals . prefix WCB$ tag K;	/* LENGTH WCB FOR JOURNAL CHANNELS 
    constant JNL_LEN equals . prefix WCB$ tag C;	/* LENGTH WCB FOR JOURNAL CHANNELS 
end WCBDEF3;

end_module $WCBDEF;


module $WSLDEF;
/*+
/* WORKING SET LIST DEFINITIONS
/*-



aggregate WSLDEF  union prefix WSL$;
    WSLDEF_BITS structure fill;
        VALID bitfield mask;				/*WSL ENTRY VALID 
        PAGTYP bitfield mask length 3;			/*PAGE TYPE (SEE PFNDEF FOR VALUES) 
        PFNLOCK bitfield mask;				/*PAGE FRAME LOCK 
                                                	/*THE PRECEDING 5 BITS MUST BE IN ORDER
        WSLOCK bitfield mask;				/*WORKING SET LOCK 
        GOODPAGE bitfield mask;				/*THIS PAGE SHOULD REMAIN IN WS ONE MORE PASS 
        FILL_1 bitfield fill prefix WSLDEF tag $$;	/*SPARE BIT 
        MODIFY bitfield mask;				/*SAVED MODIFY BIT 
    end WSLDEF_BITS;
                                            		/*THE FOLLOWING 5 BITS MUST BE IN ORDER
    
    constant "LENGTH"	equals 4  prefix WSL tag $C;	/*SIZE OF WS LIST ENTRY 
/*
/* PAGE TYPE VIELD DEFINITIONS
/*
/*	N.B.:	These constants have been adjusted by left-shifting the constant by the offset to the field WSL$V_PAGTYP.  
/*		To use these when explicitly extracting the field, the adjustment must be removed.  For example:
/*
/*		   IF .wsle [wsl$v_pagtyp] EQL (wsl$c_system^-1)		! Or (wsl$c_system/2)
/*
    constant PROCESS	equals %X00 prefix WSL tag $C;	/*PROCESS PAGE 
    constant SYSTEM	equals %X02 prefix WSL tag $C;	/*SYSTEM PAGE 
    constant "GLOBAL"	equals %X04 prefix WSL tag $C;	/*GLOBAL PAGE (READ ONLY) 
    constant GBLWRT	equals %X06 prefix WSL tag $C;	/*GLOBAL WRITABLE PAGE 
    constant PPGTBL	equals %X08 prefix WSL tag $C;	/*PROCESS PAGE TABLE 
    constant GPGTBL	equals %X0A prefix WSL tag $C;	/*GLOBAL PAGE TABLE 
end WSLDEF;

end_module $WSLDEF;


module $WQHDEF;
/*+
/* WAIT QUEUE HEADER DEFINITIONS
/*-



aggregate WQHDEF structure prefix WQH$;
    WQFL longword unsigned;				/*HEAD OR FORWARD LINK 
    WQBL longword unsigned;				/*TAIL OR BACKWARD LINK 
    WQCNT word unsigned;				/*WAIT QUEUE COUNT 
    WQSTATE word unsigned;				/*STATE NUMBER FOR WAIT 
    constant "LENGTH" equals . prefix WQH$ tag K;	/*LENGTH OF WAIT QUEUE HEADER 
    constant "LENGTH" equals . prefix WQH$ tag C;	/*LENGTH OF WAIT QUEUE HEADER 
    
end WQHDEF;

end_module $WQHDEF;






{+
{ XG - Definitions for the fields within the XGDRIVER.
{
{-

module $XGDEF;
constant PRIXMT	equals 0  prefix XG tag $C;		/* Primary xmt use vector slot 0 
constant SECXMT	equals 1  prefix XG tag $C;		/* Secondary xmt use vector slot 1 
constant PRIRCV	equals 2  prefix XG tag $C;		/* Primary rcv use vector slot 2 
constant SECRCV	equals 3  prefix XG tag $C;		/* Secondary rcv use vector slot 3 
constant RCV_CSR	equals 0  prefix XG tag $C;	/* Receive CSR 
constant XMT_CSR	equals 2  prefix XG tag $C;	/* Transmit CSR 
constant MISC_REG	equals 4  prefix XG tag $C;	/* Set misc bits 
constant IND_ADDR	equals 6  prefix XG tag $C;	/* Use to access the ind reg (IR) 
constant(
      PROTOCOL						/* 0th IR def's the protocol char 
    , RCV_ERR						/* 1st IR def's rcv errors 
    , XMT_ERR						/* 2nd IR def's xmt errors 
    , SYNC						/* 3rd IR def's sync charateristics 
    , MODEM						/* 4th IR def's modem state change 
    , STN_ADDR						/* 5th IR use to set station address 
    , PRI_RCV						/* 6th and 7th IR used to define 
    , PRI_RCV1						/* primary rcv buffer and address 
    , SEC_RCV						/* 8th and 9th IR used to define 
    , SEC_RCV1						/* secondary rcv buffer and address 
    , PRI_XMT						/* 10th and 11th IR used to define 
    , PRI_XMT1						/* primary xmt buffer and address 
    , SEC_XMT						/* 12th and 13th IR used to define 
    , SEC_XMT1						/* secondary xmt buffer and address 
    , TERM_CHAR						/* 14th used to describe term char 
    , FREE						/* 15th unused register 
    ) equals 0 increment 1  prefix XG tag $C;


/* Bit def's for RCV and XMT CSR


aggregate XGDEF  union fill prefix XG$;
    XGDEF_BITS0 structure fill;
        ENABLE bitfield mask;				/* Enable the receiver 
        FILL_1 bitfield fill prefix XGDEF tag $$;	/* reserved 
        PRM_SEC bitfield mask;				/* 0 = prim 1 = sec buffer and addr 
        TERM_IDL bitfield mask;				/* Term char for RCV's Idle for XMT's 
        DATA_SET_IE bitfield mask;			/* Enable intrpts for data set change 
        INT_ENABLE bitfield mask;			/* Enable intrpts for rcv and xmt's 
        ACT_DSC bitfield mask;				/* Active (rcv's) Data set change (xmt') 
        DONE_S bitfield mask;				/* Sec buffer proceesing is finished 
        ILP_XCS bitfield mask;				/* Interal loopback (rcv) XMT clock src 
        LOOP_TYPE bitfield mask length 2;		/* Loopb type for devices like CPI which support many 
        FILL_2 bitfield fill prefix XGDEF tag $$;	/* reserved 
        RESIDUAL bitfield mask;				/* Bit protocols only 
        PRI_SEC_STN bitfield mask;			/* 0 = control 1 = tributary station 
        ERROR bitfield mask;				/* Error on rcv or xmt 
        DONE_P bitfield mask;				/* Primary buffer processing complete 
    end XGDEF_BITS0;
    
    
/* Misc reg definitions
    
    XGDEF_BITS1 structure fill;
        IND_REG bitfield length 4;			/* Ind reg address to access 
        FILL_3 bitfield length 3 fill prefix XGDEF tag $$;/* reserved 
        MASTER_RESET bitfield mask;			/* Master reset bit 
        FILL_4 bitfield length 2 fill prefix XGDEF tag $$;/* reserved 
        USER_RCV_FLAG bitfield mask;			/* User receive flag 
        FILL_5 bitfield fill prefix XGDEF tag $$;
        CTS_FLAG bitfield mask;				/* Clear to send flag 
        CARRIER_FLAG bitfield mask;			/* Carrier detect flag 
        RING_FLAG bitfield mask;			/* Ring indicator flag 
        DSR_FLAG bitfield mask;				/* Data set ready flag 
    end XGDEF_BITS1;
    
/* Protocol parameter definitions Indirect register 0
    
    XGDEF_BITS2 structure fill;
        ERR_CNTRL bitfield length 3;			/* Error control def CRC_CCITT 1's 
        PROTOCOL bitfield length 3;			/* Protocol type def DDCMP 
        STRIP_SYNC bitfield mask;			/* Set to strip excess sync characters 
        FILL_6 bitfield fill prefix XGDEF tag $$;	/* reserved 
        RCV_BPC bitfield length 3;			/* RCV bits/char default is 8 
        FILL_7 bitfield length 2 fill prefix XGDEF tag $$;/* reserved 
        XMT_RCV bitfield length 3;			/* XMT bits/char default is 8 
    end XGDEF_BITS2;
    
/* Receive errors definitions Indirect register 1
    
    XGDEF_BITS3 structure fill;
        FILL_8 bitfield fill prefix XGDEF tag $$;	/* reserved 
        LATENCY_RCV bitfield mask;			/* RCV latency error 
        NXM_RCV bitfield mask;				/* Non-existant memory error 
        BCC_ERR bitfield mask;				/* Block check error 
        VRC_ERR bitfield mask;				/* Byte prot only char parity error 
        ABORT bitfield mask;				/* Bit prot only 
        BUFOVR bitfield mask;				/* When char COUNT and msg len aren't eq 
        FILL_9 bitfield fill prefix XGDEF tag $$;	/* Reserved 
        RES_BIT_CNT bitfield mask length 3;		/* Residual bit count 
        FILL_10 bitfield length 5 fill prefix XGDEF tag $$;/* Reserved 
    end XGDEF_BITS3;
    
/* Transmit error definitions Indirect register 2
    
    XGDEF_BITS4 structure fill;
        MSG_LEN bitfield mask;				/* Char count indicates a buff too small 
        NXM_XMT bitfield mask;				/* Non existant memory 
        LATENCY_XMT bitfield mask;			/* XMT latency error 
        FILL_11 bitfield length 5 fill prefix XGDEF tag $$;/* Reserved 
        XMT_BRG bitfield length 4;			/* Baud rate 
        FILL_12 bitfield length 4 fill prefix XGDEF tag $$;/* Reserved 
    end XGDEF_BITS4;
    
/* Sync information definitions Indirect register 3
    
    XGDEF_BITS5 structure fill;
        NMB_OF_SYNC bitfield length 5;			/* Number of syncs to send bettweenmsgs 
        FILL_13 bitfield length 3 fill prefix XGDEF tag $$;/* Reserved 
        SYNC bitfield length 8;				/* Contains the sync char 
    end XGDEF_BITS5;
    
    
/* Data set change register Indirect register 4
    
    XGDEF_BITS6 structure fill;
        FILL_14 bitfield length 4 fill prefix XGDEF tag $$;/* Reserved 
        CTS bitfield mask;				/* Clear to send 
        CARRIER bitfield mask;				/* Carrier detect 
        RING_IND bitfield mask;				/* Ring indicator 
        DSR bitfield mask;				/* Data set ready 
        USER_XMT bitfield mask;				/* User transmit 
        DTR bitfield mask;				/* Data terminal ready 
        DATA_SGNL bitfield mask;			/* Data signal rate 
        FILL_15 bitfield fill prefix XGDEF tag $$;	/* reserved 
        RTS bitfield mask;				/* Request to send 
        FILL_16 bitfield length 3 fill prefix XGDEF tag $$;/* Reserved 
    end XGDEF_BITS6;
    
/* Internal clock def's TX.CSR<8>
    
    constant INTCLK_OFF	equals 0  prefix XG tag $C;	/* No internal clock 
    constant INTCLK_ON	equals 1  prefix XG tag $C;	/* Set internal clock 
    
/* Error control definitions IR0<0:3>
    
    constant(
          ERR_CRC1					/* CRC-CCITT preset to 1's 
        , ERR_CRC0					/* CRC-CCITT preset to 0's 
        , ERR_LVE					/* LRC/VRC even 
        , ERR_CRC16					/* CRC-16 preset to 0's 
        , ERR_LRCO					/* LRC odd 
        , ERR_LRCE					/* LRC even 
        , ERR_LVO					/* LRC/VRC odd 
        , NOCON						/* No error control 
        ) equals 0 increment 1  prefix XG tag $C;
    
    
/* Protocol definitions  IR0<3:3>
    
    constant PRO_DDCMP	equals 0  prefix XG tag $C;	/* DDCMP 
    constant PRO_SDLC	equals 1  prefix XG tag $C;	/* SDLC 
    constant PRO_HDLC	equals 2  prefix XG tag $C;	/* HDLC 
    constant BISYNC	equals 3  prefix XG tag $C;	/* BISYNC 
    constant GENBYTE	equals 7  prefix XG tag $C;	/* General byte 
    
/* Bits per char definitions. RCV: IR0<8:10>  XMT:IR0<13:15>
    
    constant(
          BPC_8	
        , BPC_1	
        , BPC_2	
        , BPC_3	
        , BPC_4	
        , BPC_5	
        , BPC_6	
        , BPC_7	
        ) equals 0 increment 1  prefix XG tag $C;
    
    
/* Baud rate generator definitions IR2<8:11>
    
    constant(
          BRG_800	
        , BRG_1200	
        , BRG_1760	
        , BRG_2152	
        , BRG_2400	
        , BRG_4800	
        , BRG_9600	
        , BRG_19200	
        ) equals 0 increment 1  prefix XG tag $C;
    
    
/* Sync character definitions IR3<8:15>
    
    constant SYNC_DDCMP	equals 150  prefix XG tag $C;	/* Set sync character to HEX 96 
    constant SYNC_HDLC	equals 0  prefix XG tag $C;	/* Set no sync character 
    constant SYNC_BISYNC	equals 50  prefix XG tag $C;/* Set sync character to HEX 32 
    
    
/* Struct of parameter buffer
    
end XGDEF;

    aggregate XGDEF1 structure fill prefix XG$;
    ERR_CNTRL byte unsigned;				/* Set the type of error control to use 
    PROTOCOL byte unsigned;				/* Set protocol type 
    TX_BPC byte unsigned;				/* Set XMT bits per char 
    RX_BPC byte unsigned;				/* Set RCV bits per char 
    BAUD byte unsigned;					/* Set line speed 
    NUM_SYNC byte unsigned;				/* Set number of sync to send 
    SYNC_REG byte unsigned;				/* Set sync char to send 
    ICLK byte unsigned;					/* Set the internal clock 
    BPC byte unsigned;					/* RCV/XMT bits per char 
    MNTLOOP_OVERLAY union fill;
        MNTLOOP byte unsigned;				/* Maint loopb type 
/*
/* Bit def for interface with the frame routine
/*
/* XG$V_BUFFER_CHAR         clear        Buffer char in the next position
/*                        set         Use XG$V_BUFFER_IN_PREV_POS
/* XG$V_BUFFER_IN_PREV_POS
/*                        clear        ignore the char
/*                        set        Buffer in previous position
/* XG$V_COMPLETE_READ        set        complete framed buffer to user
/*
	MNTLOOP_BITS structure fill;
            BUFFER_CHAR bitfield mask;
            BUFFER_IN_PREV_POS bitfield mask;
            COMPLETE_READ bitfield mask;
            FILL_17 bitfield length 28 fill prefix XGDEF tag $$;/* reserved 
            NEW_FRAME bitfield mask;			/* set if new rcv message 
	end MNTLOOP_BITS;
    end MNTLOOP_OVERLAY;
    end XGDEF1;

end_module $XGDEF;

