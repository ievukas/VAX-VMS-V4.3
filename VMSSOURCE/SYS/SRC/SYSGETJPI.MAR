	.TITLE	SYSGETJPI - GET JOB PROCESS INFORMATION SYSTEM SERVICE
	.IDENT	'V04-000'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
; FACILITY: VMS Executive, System services.
;
; ABSTRACT:
;
;	Return accounting, quota, and informational data about the current
;	process, or any other process.
;
; ENVIRONMENT: Kernel Mode
;
; AUTHOR: Henry M. Levy	, CREATION DATE: 20-October-1977
;
; MODIFIED BY:
;
;	V03-024	MSH0071		Michael S. Harvey	26-Jul-1984
;		Don't clobber user address space when issuing JPI items
;		that get serviced via kernel ASTs.
;
;	V03-023	MSH0062		Michael S. Harvey	6-Jul-1984
;		Don't skip the NULL process when wildcarding through
;		the process set.
;
;	V03-022	MSH0040		Michael S. Harvey	1-May-1984
;		Look for image name in designated area whenever an AME
;		is running in the process.
;
;	V03-021	HWS0055		Harold Schultz		11-Apr-1984
;		Add JPI$_MASTER_PID item so that the PID of the
;		master process in a job can be accessed.
;		(since the MPID in the JIB is in internal format, it
;		 is translated to extended format before it is returned)
;		Change JPI$_PROC_INDEX special processing entry point to
;		be local.
;		
;	V03-020	CWH3020		CW Hobbs		20-Mar-1984
;		Add JPI$_PROC_INDEX item so that applications which used to
;		look at the low word of the PID can adapt.
;
;	V03-019	MSH0010		Michael S. Harvey	14-Feb-1984
;		Restructure internal item information tables to
;		accomodate counted strings up to 255 bytes.
;
;	V03-018	KFH0009		Ken Henderson		 7 Sep 1983
;		Fix KFH0008 more thoroughly
;		Also add SPC_MODE routine.
;
;	V03-017	KFH0008		Ken Henderson		29 Aug 1983
;		Add documentation on how
;		to add itemcodes.
;
;	V03-016	KFH0008		Ken Henderson		18 Aug 1983
;		Don't return ACCVIO if can't get data
;
;	V03-015	WMC0001		Wayne Cardoza		28-Jul-1983
;		Allow chained item lists.
;
;	V03-014	KFH0007		Ken Henderson		18 Jul 1983
;		Fixed IMAGNAME bug in source.
;
;	V03-013	KFH0006		Ken Henderson		12 Jul 1983
;		Fixed STRDSC bug in source.
;
;	V03-012	KFH0005		Ken Henderson		16 Jun 1983
;		Fixed various bugs in source.
;
;	V03-011	KFH0004		Ken Henderson		27 May 1983
;		Added HEXSTR datatype to macro.
;		Fixed wildcarding bug, DELPEN bug,
;		and sKAST buffer length bug. Cleaned
;		up use of stack scratch space.
;
;	V03-010	KFH0003		Ken Henderson		24 Mar 1983
;		Fetch other processes' PHD items directly
;		if the header is resident, and allow
;		NULL and SWAPPER processes to be visible.
;
;	V03-009	KFH0002		Ken Henderson		 1 Mar 1983
;		Mods to support bitfield item-codes.
;
;	V03-008	CWH1002		CW Hobbs		25-Feb-1983
;		Modify to use extended pids.  Use SCH$C_SWPPIX to locate the
;		pcb of the swapper.
;
;	V03-007	KFH0001		Ken Henderson		10 Feb 1983
;		Condense the table macros into JPI_ITEM_CODE,
;		and add call the JPI_GENERATE_TABLE to invoke
;		JPI_ITEM_CODE for each item-code.
;
;	V03-006	LJK0187		Lawrence J. Kenah	22-Oct-1982
;		Correct erroneous reference to ASTCNT. Make routine that checks
;		accessibility of image name a global routine.
;
;	V03-005	LJK0157		Lawrence J. Kenah	7-Apr-1982
;		Add support for JPI$_IMAGECOUNT for LIB$SPAWN's benefit
;
;	V03-004	LJK0155		Lawrence J. Kenah	1-Apr-1982
;		Handle quota deductions in consistent fashion.
;
;	V03-003 MSH0001		Maryann Hinden		23-Mar-1982
;		Fix broken BSBW's.
;
;	V03-002	DWT0032		David Thiel		22-Mar-1982
;		Correct length of probe for returning asynchronous result
;		length.
;
;	V03-001	LJK0146		Lawrence J. Kenah	16-Mar-1982
;		Correct bugs along code path for not enough nonpaged pool.
;		Use action routine to convert AUTHPRI item. Do not return
;		address items for another process. Add additional check
;		that item list has not changed before second scan.
;
;--

;		GUIDE TO GETJPI/GETSYI/GETDVI
;		-----------------------------
;
;Overview
;--------
;
;These three system services are table-driven. The macro definition files
;that help define their tables are shared with DCL and the RTL. This results
;in new item-codes becoming useable with DCL's F$GETXXI lexical functions and
;the RTL's LIB$GETXXI routines automatically. Additionally, new SYSBOOT
;parameters become item-codes to the GETSYIs.
;
;The macro definition files are called JPITABLE.MAR, SYITABLE.MAR, and
;DVITABLE.MAR, and live in MASD$:<VMSLIB.SRC>. During a systembuild, they
;are inserted into the library SYS$LIBRARY:SYSBLDMLB.MLB. DCL and the RTL
;and SYS use this library to define their GETXXI tables. The system
;parameter file <SYS.SRC>SYSPARAM.MAR has also been conditionalized to be
;used to define GETSYI item-codes and is also inserted into SYSBLDMLB.MLB.
;
;
;NOTE:	SYSBLDMLB.MLB is a general macro library for holding macro
;	definitions that are shared between facilities, but will not
;	ship to the customer.
;
;
;When adding an item-code, at least two files need to be edited. One of the
;macro files listed above, as well as an SDL file that defines the 16-bit
;number which is the user-visible item-code. Also, if a SYSBOOT parameter is
;added, an SDL file needs to be updated to define the new GETSYI item-code.
;
;The GETDVI service actually uses only one table, but the GETSYI and GETJPI
;services use several. The JPITABLE file defines all the tables for GETJPI
;and the SYITABLE file defines all the tables for GETSYI. The different
;tables group the pieces of data according to method of retrieval.
;
;In some cases, the piece of data to be returned by the service requires
;special processing to fetch, calculate, or format it before returning it.
;In these cases, the code of the system service needs to be enhanced.
;If the data returned is a new format for DCL, the lexical function
;module of DCL may need to be enhanced. This is also true for the RTL code.

;The Macros
;----------
;
;A two-level scheme exists for defining the item tables used by the three
;services and the other facilities. A commonly defined macro (called
;JPI_GENERATE_TABLE, SYI_GENERATE_TABLE, or DVI_GENERATE_TABLE) contains
;multiple calls to a lower-level macro (called JPI_ITEM_CODE, SYI_ITEM_CODE,
;or DVI_ITEM_CODE) which actually defines each element in the table.
;While the _GENERATE_TABLE macros are commonly defined, the _ITEM_CODE macros
;are individually defined according to the needs of facility. (For instance,
;the LEXICON module must store the name of the item as an ASCIC string - in
;order to match it with the string supplied in the F$GETXXI function call;
;the other facilities need not store the item name in text.)
;
;When an item-code must be added, an additional call to the _ITEM_CODE macro
;must be added to the appropriate _GENERATE_TABLE macro. In the case of GETJPI
;and GETDVI, the _GENERATE_TABLE macro is defined in the JPITABLE and DVITABLE
;modules. The SYI_GENERATE_TABLE macro is defined by the SYSPARAM module
;- all the calls to the PARAMETER and PQL macros are 'collected' into the
;SYI_GENERATE_TABLE macro. When used in that mode (when GETSYISW is defined),
;the SYI_ITEMTABLES macro also becomes part of the SYI_GENERATE_TABLE macro.
;SYI_ITEMTABLES is defined in the SYITABLE module and contains all the calls
;to the SYI_ITEM_CODE macro that are Not related to SYSBOOT parameters.
;When GETSYISW is defined in SYSPARAM, the PARAMETER macro does not allocate
;or store memory, but rather passes some of the arguments to it on through via
;a call to SYI_ITEM_CODE. That is how all the calls to PARAMETER become calls
;to SYI_ITEM_CODE.
;
;The following is the situation that exists when the symbol GETSYISW is defined.
;The non-SYSBOOT items are defined by the macro SYI_ITEMTABLES in SYITABLE.MAR.
;The SYSBOOT items are defined by each invokation of the PARAMETER macro in
;SYSPARAM.MAR. Note that each invokation of the PQL macro in SYSPARAM.MAR
;invokes the PARAMETER macro twice. When GETSYISW is defined, the PARAMETER
;macro merely passes its arguments through to a call to the SYI_ITEM_CODE
;macro. The SYI_ITEM_CODE macro is locally defined as needed by the facility.
;
;+---------------------------------------------------------------------+
;|                    SYI_GENERATE_TABLE                               |
;|   SYI_ITEMTABLES          |                                         |
;|                           | PARAMETER   |           PQL             |
;|                           |             | PARAMETER   | PARAMETER   |
;|             |             |             |             |             |
;|SYI_ITEM_CODE|SYI_ITEM_CODE|SYI_ITEM_CODE|SYI_ITEM_CODE|SYI_ITEM_CODE|
;+---------------------------------------------------------------------+
;\                          / \                                       /
; \                        /   \                                     /
;     FROM SYITABLE.MAR                  FROM SYSPARAM.MAR
;    (NON-SYSBOOT ITEMS)                  (SYSBOOT ITEMS)

	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;

	$ACBDEF				; AST control block parameters
	$DYNDEF				; dynamic memory block types
	$IFDDEF				; image file descriptor block
	$IPLDEF				; interrupt priority levels
	$JIBDEF				; define job information block
	$JPIDEF				; define GETJPI item identifiers
	$PCBDEF				; define process control block
	$PHDDEF				; define process header
	$PSLDEF				; processor state longword
	$STATEDEF			; scheduler state definitions
	$PRDEF				; define processor registers
	$PRIDEF				; define priority increment classes
	$RSNDEF				; define resource wait codes
	$SSDEF				; define status codes

;
; MACROS:
;

;
; Macros to define entries in the six item information tables.
; There is a table for each data structure from which the user may
; request information, and one table for information returned as an
; address.  Tables are indexed by low byte of item identifier.
; Refer to "OWN STORAGE:" for pictures of the table entries.
;

	.MACRO	JPI_ITEM_CODE	BASE,-		; for service to use
				NAME,-		; of the item-code
				SOURCE,-	; of the data
				DTYPE,-		; of returned value
				BITPOS,-	; of 'bitval' field
				BITSIZ,-	; of 'bitval' field
				OUTLEN,-	; of returned value
				STRUCT		; containing the field

	.IF NOT_DEFINED JPI$_'NAME
	.WARN ; JPI$_'NAME' IS NOT DEFINED IN STARDEFFL.SDL
	.ENDC

	STEP = 4
	.IIF IDENTICAL <BASE><PCB>,	STEP	= 5
	.IIF IDENTICAL <BASE><PHD>,	STEP	= 5
	.IIF IDENTICAL <BASE><ADR>,	STEP	= 5
	.IIF IDENTICAL <BASE><CTL>,	STEP	= 7
	.IIF IDENTICAL <BASE><PCBFLD>,	STEP	= 7
	.IIF IDENTICAL <BASE><PHDFLD>,	STEP	= 7

	.=BASE'TBL+<<JPI$_'NAME&^XFF>*STEP>

	.IIF IDENTICAL <BASE><PCB>,	.WORD	'STRUCT'$'SOURCE
	.IIF IDENTICAL <BASE><PHD>,	.WORD	'STRUCT'$'SOURCE
	.IIF IDENTICAL <BASE><PCBFLD>,	.WORD	PCB$'SOURCE
	.IIF IDENTICAL <BASE><PHDFLD>,	.WORD	PHD$'SOURCE
	.IIF IDENTICAL <BASE><ADR>,	.LONG	SOURCE
	.IIF IDENTICAL <BASE><CTL>,	.LONG	SOURCE

	.IF IDENTICAL <BASE><PCBFLD>
	.WORD	<'BITSIZ'-1>@11!PCB$V_'BITPOS'
	.ENDC

	.IF IDENTICAL <BASE><PHDFLD>
	.WORD	<'BITSIZ'-1>@11!PHD$V_'BITPOS'
	.ENDC

	.IF DIFFERENT <BASE><ADR>

	$XX$ = VALUE
	.IIF IDENTICAL <DTYPE><HEXNUM>,	$XX$ = VALUE
	.IIF IDENTICAL <DTYPE><DECNUM>,	$XX$ = VALUE
	.IIF IDENTICAL <DTYPE><HEXSTR>,	$XX$ = BSTRING
	.IIF IDENTICAL <DTYPE><PRVMSK>,	$XX$ = BSTRING
	.IIF IDENTICAL <DTYPE><PRTMSK>,	$XX$ = BSTRING
	.IIF IDENTICAL <DTYPE><PADSTR>,	$XX$ = BSTRING
	.IIF IDENTICAL <DTYPE><CNTSTR>,	$XX$ = CSTRING
	.IIF IDENTICAL <DTYPE><STRDSC>,	$XX$ = DSTRING
	.IIF IDENTICAL <DTYPE><BITVEC>,	$XX$ = VALUE
	.IIF IDENTICAL <DTYPE><BITVAL>,	$XX$ = BOOLE
	.IIF IDENTICAL <DTYPE><STDUIC>,	$XX$ = VALUE
	.IIF IDENTICAL <DTYPE><STDTIM>,	$XX$ = BSTRING
	.IIF IDENTICAL <DTYPE><ACPTYP>,	$XX$ = BSTRING

	.BYTE	$XX$
	.BYTE	OUTLEN

	.ENDC	; IF DIFFERENT <BASE><ADR>

	.BYTE	JPI$C_'STRUCT'TYPE

	.ENDM	JPI_ITEM_CODE


;
; This macro defines the entries to the table of special items.
; The items in this table must be handled by action routines 
; before being returned.  Each entry has a word item identifier
; followed by the address of an action routine.
;

	.MACRO	SPECIAL_ITEM NAME,ROUTINE
	.WORD	JPI$_'NAME
	.ADDRESS ROUTINE
	.ENDM	SPECIAL_ITEM

;
; This macro defines flag bits.
;

	.MACRO	JPIBITS NAME,SIZE
	JPI_V_'NAME' = JPI_BIT
	JPI_S_'NAME' = SIZE
	JPI_BIT = JPI_BIT + SIZE
	.ENDM	JPIBITS

;
; EQUATED SYMBOLS:
;

	EFN = 4				; event flag number argument
	PIDADR = 8			; address of PID
	PRCNAM = 12			; address of name descriptor
	ITMLST = 16			; address of item identifiers
	IOSB = 20			; I/O status block address
	ASTADR = 24			; ast routine address
	ASTPRM = 28			; ast parameter

;
; Space is left on stack for routines which may 
; manipulate values before returning them.
;

	LOCAL_SPACE = -40
	SCRATCH = LOCAL_SPACE+0
	BITDEF = LOCAL_SPACE+16
	PHDTEMP = LOCAL_SPACE+20
	WSLIST = LOCAL_SPACE+28
	DIRCNT = LOCAL_SPACE+32
	FLAGS = LOCAL_SPACE+36

;
; Bit definitions for flags longword on stack
;

	JPI_BIT = 0
	JPIBITS	WILD,1			; we're doing a wildcard operation
	JPIBITS	NULLSWAP,1		; the target is NULL or SWAPPER
	JPIBITS STRDSC,1		; the datatype is a string descriptor

;
; Max structure number definitions
;

	MAX_ADR_ITEM = <JPI$_LASTADR&^XFF>-1 ; maximum ADRTBL item number
	MAX_CTL_ITEM = <JPI$_LASTCTL&^XFF>-1 ; maximum CTLTBL item number
	MAX_PCB_ITEM = <JPI$_LASTPCB&^XFF>-1 ; maximum PCBTBL item number
	MAX_PHD_ITEM = <JPI$_LASTPHD&^XFF>-1 ; maximum PHDTBL item number
	MAX_PCBFLD_ITEM = <JPI$_LASTPCBFLD&^XFF>-1 ; max PCBFLDTBL item number
	MAX_PHDFLD_ITEM = <JPI$_LASTPHDFLD&^XFF>-1 ; max PHDFLDTBL item number

;
; Data type codes (all numeric types have same code)
;

	VALUE = 0			; numeric value
	BSTRING = 1			; blank filled string
	CSTRING = 2			; counted ascii string
	BOOLE = 3			; bit value
	DSTRING = 4			; string descriptor

;
; AST control block extensions
;
	$DEFINI	ACB

	.=ACB$L_KAST+4				;

$DEF	ACB_L_DADDR	.BLKL	1		; data buffer address
$DEF	ACB_L_EFN	.BLKL	1		; event flag number
$DEF	ACB_L_IOSB	.BLKL	1		; completion AST routine addr
$DEF	ACB_L_OPID	.BLKL	1		; original requester's PID
$DEF	ACB_L_IMGCNT	.BLKL	1		; PHD$L_IMGCNT of requester
$DEF	ACB_L_COUNT	.BLKL	1		; item descriptor count
$DEF	ACB_L_ILIST				; item descriptor list

	ACB_C_IDESC = 12			; item descriptor size

	$DEFEND	ACB


;
; OWN STORAGE:
;

	.PSECT	YF$$SYSGETJPI

;
; This array contains the maximum item number for each of the
; six item data structures, indexed by structure number.
;

MAXCOUNT:
	.BYTE	MAX_ADR_ITEM
	.BYTE	MAX_CTL_ITEM
	.BYTE	MAX_PCB_ITEM
	.BYTE	MAX_PHD_ITEM
	.BYTE	MAX_PCBFLD_ITEM
	.BYTE	MAX_PHDFLD_ITEM
	.PAGE
;
; Define the six item data structures.  Each data structure is indexed
; by item identifier.
;

ADRTBL:
	;------------------------;
	; .LONG  ADDRESS         ;
	; .BYTE  JPI$C_ADRTYPE   ;
	;------------------------;

	.BLKB	5*<MAX_ADR_ITEM+1>		; define adr table

CTLTBL:
	;------------------------;
	; .LONG  ADDRESS         ;
	; .BYTE  DTYPE		 ;
	; .BYTE  LENGTH		 ;
	; .BYTE  JPI$C_CTLTYPE   ;
	;------------------------;

	.BLKB	7*<MAX_CTL_ITEM+1>		; define ctl table

PCBTBL:
	;------------------------;
	; .WORD  XXX$OFFSET      ;
	; .BYTE  DTYPE		 ;
	; .BYTE  LENGTH		 ;
	; .BYTE  JPI$C_PCBTYPE   ;
	;------------------------;

	.BLKB	5*<MAX_PCB_ITEM+1>		; define pcb table

PHDTBL:
	;------------------------;
	; .WORD  XXX$OFFSET      ;
	; .BYTE  DTYPE		 ;
	; .BYTE  OUTLEN		 ;
	; .BYTE  JPI$C_PHDTYPE   ;
	;------------------------;

	.BLKB	5*<MAX_PHD_ITEM+1>		; define phd table

PCBFLDTBL:
	;-----------------------------;
	; .WORD  XXX$OFFSET           ;
	; .WORD <BITSIZ-1>@11!BITPOS  ;
	; .BYTE  DTYPE		      ;
	; .BYTE  OUTLEN		      ;
	; .BYTE  JPI$C_PCBFLDTYPE     ;
	;-----------------------------;

	.BLKB	7*<MAX_PCBFLD_ITEM+1>		; define pcbfld table

PHDFLDTBL:
	;-----------------------------;
	; .WORD  XXX$OFFSET           ;
	; .WORD <BITSIZ-1>@11!BITPOS  ;
	; .BYTE  DTYPE		      ;
	; .BYTE  OUTLEN		      ;
	; .BYTE  JPI$C_PHDFLDTYPE     ;
	;-----------------------------;

	.BLKB	7*<MAX_PHDFLD_ITEM+1>		; define phdfld table

	.SAVE					; save current location

;
;**********************************************************
;
; GENERATE THE SIX TABLES USING THE COMMONLY DEFINED MACRO
;
;**********************************************************
;
	JPI_GENERATE_TABLE


	.RESTORE				; restore location

;
; Table to define items which must be handled
; by action routines.
;

SPECIAL:
	SPECIAL_ITEM	PRI,SPC_PRI		; handle priority ...
	SPECIAL_ITEM	PRIB,SPC_PRI		; ... evaluations
	SPECIAL_ITEM	AUTHPRI,SPC_PRI		; all of them
						; compute working set
	SPECIAL_ITEM	WSAUTH,SPC_WORKSET	; ...parameters
	SPECIAL_ITEM	WSQUOTA,SPC_WORKSET	;
	SPECIAL_ITEM	WSEXTENT,SPC_WORKSET	;
	SPECIAL_ITEM	WSAUTHEXT,SPC_WORKSET	;
	SPECIAL_ITEM	DFWSCNT,SPC_WORKSET	;
	SPECIAL_ITEM	IMAGNAME,SPC_IMAGNAME	; find image name
	SPECIAL_ITEM	MODE,SPC_MODE		; return the process' mode
	SPECIAL_ITEM	PROC_INDEX,SPC_PROC_INDEX ; create a process index
	SPECIAL_ITEM	MASTER_PID,SPC_MASTER_PID ; return PID of master proc.

SPECIAL_LEN = <.-SPECIAL>/6			; compute number of entries
	.PAGE
	.SBTTL	SYSGETJPI - GETJPI main program

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This service allows a process to receive information about itself, or
;	any process which it has the UIC privilege to examine.
;	
; CALLING SEQUENCE:
;
;	CALLS/CALLG
;
; INPUTS:
;
;	EFN(AP) = number of the event flag to set when all of the requested
;		  data is valid. 
;	PIDADR(AP) = address of a longword containing the process ID of the
;		     process for which the information is being requested
;	PRCNAM(AP) = address of a string descriptor for the process name
;		     of the process for which the information is requested
;	ITMLST(AP) = address of a list of item descriptors of the form:
;
;		+-----------------------------+
;		!  ITEM CODE   !  BUF. LENGTH !
;		+-----------------------------+
;		!      BUFFER ADDRESS         !
;		+-----------------------------+
;		!  ADDRESS TO RETURN LENGTH   !
;		+-----------------------------+
;
;	IOSB(AP) = address of a quadword I/O status block to receive final
;		status
;	ASTADR(AP) = address of an AST routine to be called when all of the
;		requested data has been supplied.
;	ASTPRM(AP) = 32 bit ast parameter
;
; IMPLICIT INPUTS:
;
;	none
;
; OUTPUTS:
;
;	none
;
; IMPLICIT OUTPUTS:
;
;	none
;
; ROUTINE VALUE:
;
;	SS$_NORMAL -> normal completion
;	SS$_ACCVIO -> ITMLST can not be read by the calling access mode,
;			or the return buffer or return length word can not
;			be written by the calling access mode
;	SS$_BADPARAM -> an invalid item identifier was supplied
;	SS$_IVLOGNAM -> zero or greater than maximum length process name string
;	SS$_NONEXPR -> nonexistant/deleted process or invalid process ID
;		       specified
;	SS$_NOPRIV -> calling process does not have privilege to get information
;		      about the specified process.
;
; SIDE EFFECTS:
;
;	none
;--

	.PSECT	YEXEPAGED		; only entry mask in this program section

	.ENTRY	EXE$GETJPI,^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	BRW	EXE_GETJPI		; transfer to real procedure

	.PSECT	YF$$SYSGETJPI

EXE_GETJPI:
	MOVAL	LOCAL_SPACE(SP),SP	; allocate local space on stack
	CLRL	FLAGS(FP)		; reset the flags longword
	BSBW	NAMPID			; get PID/PCB address of desired process
	BLBC	R0,15$			; exit if invalid process specified
;
; Check for, and clear possible IOSB
;
	MOVL	IOSB(AP),R1		; get IOSB address
	BEQL	3$			; branch if none
	IFWRT	#8,(R1),29$		; check access to it
	BRW	30$			; ACCVIO
29$:	CLRQ	(R1)			; clear IOSB
;
; Check for, and clear event flag
;
3$:	MOVZBL	EFN(AP),R3		; get event flag number
	JSB	SCH$CLREF		; clear this event flag
4$:	BLBC	R0,15$			; and return on errors.
;
; Validate AST, if present. Note R4 still has our PCB address, and R9
; has the PCB address of the process we want information from.
;
	TSTL	ASTADR(AP)
	BEQL	5$			; no AST to check.
	TSTW	PCB$W_ASTCNT(R4)	; is quota exceeded?
	BGTR	5$			; nope
	BRW	35$			; quota exceeded - return error
;
; R10 is used to count the items that are in the other process's address
; space. The accumulated size of the user buffers is kept track of
; on top of the stack. DIRCNT(FP) counts the number of PHD cells that
; were successfully fetched from another processes' header.
;
5$:	CLRL	R10			; no items yet
	PUSHL	#0			; no accumulated size either
	CLRL	DIRCNT(FP)		; no fetched items yet
;
; Loop through the item descriptor blocks, validating the requested item
; identifiers and moving accessible items.  A zero item identifier terminates
; the list.
;

	MOVL	ITMLST(AP),R5		; get item descriptor list address
6$:	IFRD	#4,(R5),10$		; check first longword readable
	BRW	30$

7$:	MOVL	(R5),R5			; get pointer to next chained item list
	BRB	6$			; process it

10$:
	MOVZWL	(R5)+,R6		; get buffer size
	MOVZWL	(R5)+,R1		; get item identifier
	BEQL	49$			; done if zero, take normal exit
	CMPW	R1,#JPI$_CHAIN		; is it a chained item list
	BEQL	7$
	IFRD	#12,(R5),11$		; check rest of this descriptor ...
	BRW	30$			; ... plus first longword of next one
11$:	MOVQ	(R5)+,R7		; get buffer address and return address
	PUSHL	R1			; save R1 across accessibility check
	MOVL	R7,R0			; buffer address to R0
	MOVL	R6,R1			; and size to R1
	CLRL	R3			; PROBE will use PSL<PRVMOD>
	JSB	EXE$PROBEW		; check write accessibility of buffer
	POPL	R1			; restore R1 for use by CHECKITEM
15$:	BLBC	R0,31$			; return error if inaccessible
	PUSHL	R5			; save R5 from action routines
	BSBW	CHECKITEM		; validate identifier and get item info.
	BLBC	R0,41$			; invalid item if error
	CMPL	R9,SCH$GL_CURPCB	; is this for current process?
	BNEQ	16$			; branch if not
	BBC	#JPI_V_NULLSWAP,FLAGS(FP),20$
					; branch if it's current 'full' process

	CASE	R2,<-			; the current process is null or swap
		45$,-	; ADR
		45$,-	; CTL
		20$,-	; PCB
		20$,-	; PHD
		20$,-	; PCBFLD
		20$,-	; PHDFLD
		45$-	; JIB
		>B,#1

16$:	CASE	R2,<-			; it isn't the current process
		45$,-	; ADR
		18$,-	; CTL
		20$,-	; PCB
		17$,-	; PHD
		20$,-	; PCBFLD
		17$,-	; PHDFLD
		21$-	; JIB
		>B,#1

49$:	BRB	50$			; HELPER BRANCHES
31$:	BRW	GRET
41$:	BRW	40$

17$:	BBC	#PCB$V_PHDRES,PCB$L_STS(R9),18$ ; is the header resident?
	; R0 returned from MOVEPHD can be the following:
	; SS$_ACCVIO - routine MOVEIT couldn't stuff RETLEN
	; SS$_NONEXPR - got into MOVEPHD and DELPEN was set
	; SS$_NORMAL - everything fine - got the data
	; 0 - got into MOVEPHD and PHD had gone away - get with sKAST
	BSBW	MOVEPHD			; must be, go get the data
	BLBS	R0,102$			; got it! count it.
	CMPL	R0,#SS$_ACCVIO		; was the retlen bad?
	BEQL	GRET			; EQL means it was
	BBS	#JPI_V_NULLSWAP,FLAGS(FP),45$ ; couldn't get Null/Swap? oh oh.
	TSTL	R0			; now check for PHD no longer RES
	BEQL	19$			; EQL means PHD no longer RES
	BRB	GRET			; whatever the error, go return it

102$:	INCL	DIRCNT(FP)		; successful at getting it directly
	BRB	19$

18$:	BBS	#JPI_V_NULLSWAP,FLAGS(FP),45$
					; Null and Swapper don't have CTL reg.
19$:	INCL	R10			; count up one more for sKAST later.
	ADDL2	R6,4(SP)		; Add in size of user's buffer
	BRB	25$
21$:	BBS	#JPI_V_NULLSWAP,FLAGS(FP),45$
					; Null and Swapper don't have a JIB
20$:	BSBW	MOVEIT			; move item to user
25$:	POPL	R5			; restore R5
	BLBC	R0,GRET			; return length not writeable
	BRW	10$			; back for next descriptor

30$:	MOVZWL	#SS$_ACCVIO,R0		; access violation
	BRB	GRET

35$:	MOVZWL	#SS$_EXQUOTA,R0		; AST quota exceeded
	BRB	GRET

40$:	MOVZWL	#SS$_BADPARAM,R0	; illegal item or request
	BRB	GRET

45$:	MOVAL	SCRATCH(FP),R4		; make a 16-byte zeroed buffer
	CLRQ	(R4)
	CLRQ	8(R4)
	BRB	20$			; ... through common subroutine

50$:	MOVZWL	#SS$_NORMAL,R0		; normal return
	CMPL	DIRCNT(FP),R10		; any items we couldn't get?
	BNEQ	RESCAN			; if so, go obtain them.
;
; Set the event flag, post the completion status, and declare a completion AST
;
GRET:	PUSHL	R0			; save completion status
	MOVL	SCH$GL_CURPCB,R4	; get PCB address
	MOVL	PCB$L_PID(R4),R1	; get process's PID
	CLRL	R2			; set null priority increment
	MOVL	EFN(AP),R3		; get event flag number to set
	JSB	SCH$POSTEF		; set the event flag
10$:	MOVL	IOSB(AP),R1		; get address of IOSB
	BEQL	20$			; branch if none
	IFNOWRT	#8,(R1),20$		; check if writable
	MOVL	(SP),(R1)		; store completion status
20$:	MOVL	ASTADR(AP),R5		; get address of AST routine
	BEQL	30$			; branch if none specified
	MOVPSL	R4			; get PSL
	EXTZV	#PSL$V_PRVMOD,#PSL$S_PRVMOD,R4,R4 ; extract previous mode
	$DCLAST_S (R5),ASTPRM(AP),R4	; queue the completion AST
30$:	POPL	R0			; restore completion status
	RET				; and return.
	.PAGE
	.SBTTL	RESCAN - Rescan item list creating list of items in process
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	Routine to obtain information that is contained in another process's
;	virtual address space.  This is accomplished by first creating a list
;	of items that are to be obtained from the other process. An AST is
;	then queued to the process to execute a routine in this service that 
;	copies the desired items to a buffer in non-paged pool.  The routine
;	then queues another AST back to the requesting process to execute
;	another routine in this service to copy the items from the system
;	buffer to the requester's buffers.
;
; CALLING SEQUENCE:
;
;	Branch
;
; INPUTS:
;
;	R10 = number of items that are in other process's address space
;	R11 = PID of other process
;	(SP) = accumulated size of user buffers. A buffer of this size
;		will be allocated from nonpaged pool to hold data from
;		the target process.
;
; OUTPUTS:
;
;	none
;
; IMPLICIT OUTPUTS:
;
;	An extended AST control block is allocated and filled-in with the
;	usual AST parameters with the extension containing a list of
;	item descriptors.  A data buffer is also allocated to contain the
;	item data.
;
; ROUTINE VALUE:
;
;	none
;
; SIDE EFFECTS:
;
;	lots
;--

	.ENABLE	LOCAL_BLOCK

5$:	BBC	#PCB$V_SSRWAIT,PCB$L_STS(R4),7$ ; do not wait if set
	ENBINT				; allow interrupts again
	MOVZWL	#SS$_INSFMEM,R0		; indicate no pool left
6$:	BRB	GRET			; and join common exit path

; There is not enough nonpaged pool. The process must be placed into resource
; wait until pool becomes available.

7$:	MOVPSL	R0			; get current PSL
	BICL3	#PSL$M_IPL,R0,(SP)	; wait at IPL 0 to allow ASTs 
	MOVZWL	#RSN$_NPDYNMEM,R0	; ... for some pool to be given back
	JSB	G^SCH$RWAIT		; quota check will be repeated
	MOVL	R6,R1			;  when process executes again
	BRB	8$			; pool available. repeat quota check

RESCAN:
;
; Allocate an extended AST block
;
	MOVL	SCH$GL_CURPCB,R4	; get current PCB address
	MULL3	#ACB_C_IDESC,R10,R1	; compute size of item descriptors
	ADDL2	#ACB_L_ILIST,R1		; plus header
	ADDL2	(SP),R1			; plus buffer size
	MOVL	R1,R6			; save request size for later storage
8$:	JSB	G^EXE$BUFFRQUOTA	; check buffer quota
	BLBC	R0,6$			; quit if not enough quota
9$:	DSBINT	120$			; elevate IPL to SYNCH
	JSB	G^EXE$ALONONPAGED	; now allocate the chunk of pool
	BLBC	R0,5$			; get out if no pool available
;
; Fill-in the standard AST parameters and header information
;
	ENBINT				; allow scheduling again
	MOVL	PCB$L_JIB(R4),R0	; get JIB address
	SUBL	R6,JIB$L_BYTCNT(R0)	; adjust buffer quota
	MOVL	R11,ACB$L_PID(R2)	; PID of target process
	MOVL	R2,R11			; save address of AST block
	MOVW	R6,ACB$W_SIZE(R11)	; save block size for deallocation
	MOVB	#DYN$C_ACB,ACB$B_TYPE(R11) ; set block type
	MOVPSL	R1			; get PSL
	EXTZV	#PSL$V_PRVMOD,#PSL$S_PRVMOD,R1,R1 ; get requester's mode
	BISB3	#<1@ACB$V_KAST>,R1,ACB$B_RMOD(R11) ; and put into block
	MOVAB	W^MOVEFU,ACB$L_KAST(R11)	; special kernel address
	MOVL	ASTADR(AP),ACB$L_AST(R11) ; return ast address
	BEQL	10$			; skip quota check if none
	MOVZWL	#SS$_EXQUOTA,R0		; assume exceeded
	TSTL	PCB$W_ASTCNT(R4)	; any left
	BNEQ	91$			; hop, skip to error return
	BRW	35$
91$:	DECW	PCB$W_ASTCNT(R4)	; subtract from quota
	BBSS	#ACB$V_QUOTA,ACB$B_RMOD(R11),10$ ; and record that fact in ACB
10$:	MOVL	ASTPRM(AP),ACB$L_ASTPRM(R11) ; and parameter
	MOVZBL	EFN(AP),ACB_L_EFN(R11)	; efn to set on return
	MOVL	IOSB(AP),ACB_L_IOSB(R11) ; address of possible iosb
	MOVL	PCB$L_PID(R4),ACB_L_OPID(R11) ; our PID
	MOVL	CTL$GL_PHD,R3		; get address of process header
	MOVL	PHD$L_IMGCNT(R3),ACB_L_IMGCNT(R11) ; sequence number of this image
	MOVL	R10,ACB_L_COUNT(R11)	; item count
	CLRL	ACB_L_DADDR(R11)	; no data buffer yet
					; allocated but location not recorded

;
; Loop through the list, copying the item descriptors for items in the
; process's address space to the extended AST block.
;
; The item descriptor list will look like:
;
;	+--------------------------------+
;	! item code     ! buffer length  !
;	+--------------------------------+
;	!    user buffer address         !
;	+--------------------------------+
;	! address to return length       !
;	+--------------------------------+
;
; When the item list comes back from the kernel ASTs, the item code field
; is overwritten with the actual length of the source data for each item.
;
	MOVAL	ACB_L_ILIST(R11),R8	; get address of item descriptor list
	MOVL	ITMLST(AP),R7		; get address of item specifier list
12$:	IFNORD	#4,(R7),30$		; check first longword still readable

15$:	MOVZWL	(R7)+,R6		; get user buffer size
	MOVZWL	(R7)+,R1		; get item identifier
	BEQL	40$			; if zero, we're done with list.
	IFNORD	#12,(R7),30$		; check still readable
	CMPW	R1,#JPI$_CHAIN		; is it a chained item list
	BEQL	19$
	MOVQ	(R7)+,-(SP)		; get user buffer and length addresses
	BSBW	CHECKITEM		; get structure type into R2
	BLBC	R0,20$			; make sure argument list has not changed
	MOVL	R3,R0			; save item length
	MOVQ	(SP)+,R3		; get user buffer and length addresses
	MOVZBL	#<<1@JPI$C_PCBTYPE>!-	; create mask of types in system space
		  <1@JPI$C_PCBFLDTYPE>!- ;  plus address type, which is 
		  <1@JPI$C_JIBTYPE>!-	;  returned as zero if not for caller
		  <1@JPI$C_ADRTYPE>>,R5 ;
	BBS	R2,R5,15$		; branch if we already got it
	DECL	R10			; decrement item counter
	BLSS	20$			; error if count goes negative
	SUBL2	R6,(SP)			; subtract user buffer size from input
	BLSS	20$			; error if result goes negative
	MOVW	R6,(R8)+		; copy user buffer size

18$:	MOVW	R1,(R8)+		; copy item identifier
	MOVQ	R3,(R8)+		; copy user buffer and length address
	BRB	15$			; and loop through till done.

19$:	MOVL	(R7)+,R7		; pointer to next item list
	BRB	12$			; go process it

20$:	PUSHL	S^#SS$_BADPARAM		; set bad parameters failure
	BRB	35$			;

30$:	PUSHL	S^#SS$_ACCVIO		; set access violation failure
35$:	BRW	100$			;

40$:	TSTL	R10			; count should be zero
	BNEQ	20$			; error if it is not.
	TSTL	(SP)+			; so should size be zero
	BNEQ	20$			; error if it is not.
	MOVL	R8,ACB_L_DADDR(R11)	; fill in buffer address
;
; The AST is queued to the destination process unless it has delete or
; suspend pending set, or is currently suspended.
;
50$:	SETIPL	120$			; raise IPL to synch, lock code
	MOVL	R11,R5			; set address of AST block
	MOVZWL	ACB$L_PID(R5),R4	; PIX of destination process
	MOVL	@SCH$GL_PCBVEC[R4],R4	; get PCB address
	CMPL	PCB$L_PID(R4),ACB$L_PID(R5) ; see if PIDs the same
	BNEQ	80$			; and exit if not
	BBS	#PCB$V_DELPEN,PCB$L_STS(R4),80$ ; or if delete pending
	BBS	#PCB$V_SUSPEN,PCB$L_STS(R4),90$ ; or if suspend pending
	CMPW	#SCH$C_SUSP,PCB$W_STATE(R4)
	BEQL	90$			; process suspended, error exit
	CMPW	#SCH$C_SUSPO,PCB$W_STATE(R4)
	BEQL	90$			; or suspended out of memory
	CMPW	#SCH$C_MWAIT,PCB$W_STATE(R4)
	BEQL	90$			; or an indeterminately long wait state
	MOVL	#PRI$_TICOM,R2		; give a big priority increment
	BBS	#JPI_V_NULLSWAP,FLAGS(FP),30$ ; don't ever queue it to these!
	JSB	SCH$QAST		; queue AST to other process
;
; If process is in compute state and at a lower priority than the requesting
; process, boost its current priority to the requesting process's current
; priority.  (Required because event reporting won't normally boost a COM
; state process's priority).
;
	CMPW	#SCH$C_COM,PCB$W_STATE(R4) ; process in compute state?
	BEQL	60$			;
	CMPW	#SCH$C_COMO,PCB$W_STATE(R4) ; or compute out of memory
	BNEQ	70$			; 
60$:	MOVL	SCH$GL_CURPCB,R3	; get requestor's PCB address
	MOVB	PCB$B_PRI(R3),R0	; get requestor's current priority
	CMPB	R0,PCB$B_PRI(R4)	; other process have a higher priority?
	BGEQU	70$			; if GEQU yes - don't boost priority
	CMPB	#16,R0			; will boost be into realtime priority?
	BGTRU	70$			; if GTRU yes - don't boost priority
	JSB	SCH$CHSEP		; boost other process's priority
70$:	MOVZWL	#SS$_NORMAL,R0		; so far, so good.
	SETIPL	#0			;
	RET				;
;
; Error recovery when the process we want to send the AST to has vanished,
; has delete pending, or is suspended; we must release both blocks
;
80$:	MOVZWL	#SS$_NONEXPR,-(SP)	; non-existent process
	BRB	100$

90$:	MOVZWL	#SS$_SUSPENDED,-(SP)	; process is suspended
					;
100$:	MOVZWL	ACB$W_SIZE(R11),R0	; need to restore BYTCNT quota
	MOVL	G^SCH$GL_CURPCB,R4	; to caller of $GETJPI
	MOVL	PCB$L_JIB(R4),R1	; get JIB address
	ADDL2	R0,JIB$L_BYTCNT(R1)	; and give back quota
	BBC	#ACB$V_QUOTA,ACB$B_RMOD(R11),105$ ; also ASTCNT if that
	INCW	PCB$W_ASTCNT(R4)	; was subtracted before
105$:	MOVL	R11,R0			; get address of AST block
	JSB	G^EXE$DEANONPAGED	; deallocate the block
	POPL	R0			; restore status
	SETIPL	#0			; restore IPL to allow page faults
	CMPW	R0,#SS$_NONEXPR		; is error nonexistent process?
	BEQL	130$			; branch if yes
110$:	BRW	GRET			; 


;
; The preceding code must raise IPL to synchronize access to process database,
; but since it is paged it must be locked in memory. The usage of the SETIPL
; macro above, both raises IPL and faults the code into memory.
;
120$:
	.BYTE	IPL$_SYNCH		; end of locked code region
	ASSUME	<.-5$> LE 512		; only 512 bytes can be locked
	ASSUME	<.-50$> LE 512		; only 512 bytes can be locked

;  If process has disappeared (has already been deleted or is in a delete
;  pending state) in the interval between selection and queuing the AST, 
;  and the initial call indicated wild card mode, then go back to the 
;  beginning of the service. Note that wild card mode is indicated by a
;  negative number (usually -1) in the upper word of the PID argument in 
;  the caller's argument list.

130$:	MOVL	PIDADR(AP),R1		; Get PIDADR from argument list
	BEQL	110$			; If not there, can't be wild card mode
	IFNORD	#2,2(R1),110$		; Don't repeat if cannot read parameter
	TSTW	2(R1)			; Look at wild card indicator
	BGEQ	110$			; Must be negative for wild card mode
	MOVL	FP,SP			; Restore SP to its value on entry
	BRW	EXE$GETJPI + 2		;  and go back to the beginning.

	.DISABLE	LOCAL_BLOCK

	.PAGE
	.SBTTL	CHECKITEM - Validate item identifier

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	Routine to validate item identifier and return information
;	about the item.
;
; CALLING SEQUENCE:
;
;	JSB/BSB
;
; INPUTS:
;
;	R1 = item identifier
;	R9 = Target PCB address
;
; IMPLICIT INPUTS:
;
;	none
;
; OUTPUTS:
;
;	R1 = item identifier
;	R2 = structure number
;	R3 = item length
;	R4 = item address (actual address for PCB data, assumes current process
;		for other data) < if we're getting PHD data directly, it will
;				be the PHD offset, not the address >
;	R5 = item type code
;
; IMPLICIT OUTPUTS:
;
;	none
;
; ROUTINE VALUE:
;
;	R0 low bit clear -> successful return
;	R0 low bit set -> invalid item identifier
;
; SIDE EFFECTS:
;
;	none
;--

CHECKITEM:
	CLRL	R0			; assume error
	MOVZBL	R1,R3			; get item number
	EXTZV	#8,#8,R1,R2		; get structure number
	BEQL	79$			; error if structure number zero
	CMPB	R2,#JPI$C_MAXSTRUC	; structure number valid?
	BGTRU	79$			; error if not
	CMPB	R3,MAXCOUNT-1[R2]	; check max item values (1 origin)
	BGTRU	79$			; error if illegal item number
	CLRL	R4			; assume zero base
	CASE	R2,<-			; case on structure base
		    10$,-	; ADR
		    50$,-	; CTL
		    20$,-	; PCB
		    30$,-	; PHD
		    100$,-	; PCBFLD
		    110$-	; PHDFLD
		    >B,#1

79$:
	BRW	80$			; CASE out of bounds - return

10$:					; item is an address
	MOVAL	ADRTBL[R3],R4		; address is table address
	ADDL	R3,R4			; base+indexvalue*5
	MOVZBL	4(R4),R2		; get structure type code
	MOVL	#4,R3			; size of data is four bytes
	MOVZBL	#VALUE,R5		; item is a value
	BRW	70$			; all done
20$:					; item is from PCB
	MOVL	R9,R4			; get back PCB address
	MOVAL	PCBTBL,R5		; get address of PCB item table
	BRB	40$			; continue
30$:					; item is from process header
	CMPL	R9,SCH$GL_CURPCB	; is the target process our own?
	BNEQ	35$			; NEQ means it's not, don't touch CTL
	MOVL	@#CTL$GL_PHD,R4		; get process header address
35$:	MOVAL	PHDTBL,R5		; get address of PHD item table
40$:
	MULL	#5,R3			; each element is 5 bytes long
	ADDL	R5,R3			; compute address in item table
	MOVZWL	(R3)+,R5		; get offset into data structure

	BRB	60$			; 
100$:					; item is from PCBFLD
	MOVL	R9,R4			; get back PCB address
	MULL	#7,R3			; each element is 7 bytes long
	MOVAB	PCBFLDTBL[R3],R3	; get address of PCBFLD item
	BRB	120$			; continue
110$:					; item is from PHDFLD
	CMPL	R9,SCH$GL_CURPCB	; is the target process our own?
	BNEQ	115$			; NEQ means not, don't touch CTL
	MOVL	@#CTL$GL_PHD,R4		; get process header address
115$:	MULL	#7,R3			; each element is 7 bytes long
	MOVAB	PHDFLDTBL[R3],R3	; get address of PHDFLD item
120$:
	MOVZWL	(R3)+,R5		; get offset into data structure
	MOVZWL	(R3)+,BITDEF(FP)	; save the BITSIZ and BITPOS

	BRB	60$			; 
50$:					; item is in control region
	MULL	#7,R3			; compute index into item table
	CLRL	R4			; assume zero base value
	MOVAB	CTLTBL[R3],R3		; get address of item information
	MOVL	(R3)+,R5		; get item address
60$:	MOVZBL	2(R3),R2		; fetch actual structure type
	CMPB	#JPI$C_JIBTYPE,R2	; is it the JIB?
	BNEQ	65$			; br if not
	MOVL	PCB$L_JIB(R9),R4	; else get address of JIB
65$:	ADDL	R5,R4			; form complete address
	MOVZBL	(R3)+,R5		; get item type code
	CMPL	#DSTRING,R5		; is it a string descriptor?
	BNEQ	67$			; NEQ means nope
	BISL2	#<1@JPI_V_STRDSC>,FLAGS(FP) ; it's special, flag it
	BRB	69$
67$:	BICL2	#<1@JPI_V_STRDSC>,FLAGS(FP) ; not special, clear flag
69$:	MOVZBL	(R3),R3			; get item length
	CMPB	#JPI$C_PCBFLDTYPE,R2	; is it a bit field?
	BEQL	90$			; EQL means it is
	CMPB	#JPI$C_PHDFLDTYPE,R2	; is it s bit field?
	BNEQ	70$			; NEQ means it's not a FLD at all
	CMPL	R9,SCH$GL_CURPCB	; is the target process our own?
	BNEQ	70$			; NEQ means it's not
90$:	BSBB	EXTFLD
70$:	INCL	R0			; set successful return
80$:	RSB				; return to caller
	.PAGE
	.SBTTL	EXTFLD - Extract a bitfield from a datum

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	Routine to fetch bitfield data from within a data cell.
;
; CALLING SEQUENCE:
;
;	JSB/BSB
;
; INPUTS:
;
;	BITDEF(FP) = BITPOS/BITSIZ fields from item table
;	R4 = address of cell containing data
;
; IMPLICIT INPUTS:
;
;	none
;
; OUTPUTS:
;
;	R4 = new address on stack where bit is saved
;
; IMPLICIT OUTPUTS:
;
;	none
;
; ROUTINE VALUE:
;
;	none
;
; SIDE EFFECTS:
;
;	none
;--

EXTFLD:
	PUSHR	#^M<R2,R3>		; get some room
	EXTZV	#11,#5,BITDEF(FP),R2	; get BITSIZ-1
	INCL	R2			; make it BITSIZ
	EXTZV	#0,#11,BITDEF(FP),R3	; get BITPOS
	EXTZV	R3,R2,(R4),BITDEF(FP)	; get the bitfield
	MOVAL	BITDEF(FP),R4		; point to it
	POPR	#^M<R2,R3>		; restore the registers
	RSB
	.PAGE
	.SBTTL	MOVEIT - Move data to user's buffer

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	Move the requested data to user buffer. Zero fill to end of buffer.
;	Return actual data length to user.  Assumes user's buffer has
;	been probed.
;
; CALLING SEQUENCE:
;
;	JSB/BSB
;
; INPUTS:
;
;	R1 = item identifier
;	R2 = data structure number
;	R3 = item length
;	R4 = item address
;	R5 = item type code
;	R6 = user buffer length
;	R7 = user buffer address
;	R8 = address to return length
;	R11 = PID of process to get data from
;
; IMPLICIT INPUTS:
;
;	none
;
; OUTPUTS:
;
;	none
;
; IMPLICIT OUTPUTS:
;
;	none
;
; ROUTINE VALUE:
;
;	R0 low bit set -> success
;	R0 low bit clear -> access violation on write of length
;
; SIDE EFFECTS:
;
;	Registers R1-R4 destroyed
;--

MOVEIT:

;
; Call routine to check for special conditions
;

	BSBW	CHECK_SPC

;
; Check for counted string, and find actual length if so.
;

	CMPL	#CSTRING,R5		; is this special string?
	BNEQ	10$			; branch if not
	MOVZBL	(R4)+,R3		; get length and skip length byte
;
; Check that process still exists.  This assures that data address is good.
;
10$:	MOVZWL	R11,R0			; get process ID index
	MOVL	@SCH$GL_PCBVEC[R0],R0	; get PCB address
	CMPL	PCB$L_PID(R0),R11	; same PID?
	BEQL	15$			; branch if yes
	CLRL	R3			; else, zero data size
;
; Move the data
;
15$:	PUSHR	#^M<R3,R5>		; save needed registers from movc
	MOVC5	R3,(R4),#0,R6,(R7)	; move data to user's buffer, zero fill
	POPR	#^M<R3,R5>		; restore registers
	TSTL	R8			; did caller want return length?
	BEQL	30$			; branch if not
	IFNOWRT	#2,(R8),40$		; exit if word not writable
	CMPL	R3,R6			; see how much was moved
	BLEQ	20$			; use valid data length if it fit
	MOVL	R6,R3			; else give him "too short" buffer size
20$:	MOVW	R3,(R8)			; return length to user
30$:	MOVZWL	#SS$_NORMAL,R0		; set success code
	RSB

40$:	MOVZWL	#SS$_ACCVIO,R0		; couldn't stuff RETLEN cell
	RSB				; return
	.PAGE
	.SBTTL	MOVEPHD - Fetch data from other process' PHD

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	Disable interrupts and fetch the data from the other process' header.
;	Always get WSLIST in case it'll be needed. Make R4 point to the
;	saved data, and call EXTFLD if it's a PHDFLDTYPE item.
;
; CALLING SEQUENCE:
;
;	JSB/BSB
;
; INPUTS:
;
;	R1 = item identifier
;	R2 = data structure number
;	R3 = item length
;	R4 = offset into other process' PHD
;	R5 = item type code
;	R6 = user buffer length
;	R7 = user buffer address
;	R8 = address to return length
;	R11 = PID of process to get data from
;
; IMPLICIT INPUTS:
;
;	none
;
; OUTPUTS:
;
;	none
;
; IMPLICIT OUTPUTS:
;
;	none
;
; ROUTINE VALUE:
;
;	SS$_ACCVIO - routine MOVEIT couldn't stuff RETLEN
;	SS$_NONEXPR - got into MOVEPHD and DELPEN was set
;	SS$_NORMAL - everything fine - got the data
;	0 - got into MOVEPHD and PHD had gone away - get with sKAST
;
; SIDE EFFECTS:
;
;	Registers R1-R4 destroyed
;--

MOVEPHD:
	MOVQ	R5,-(SP)		; save R5 and R6
LOCK_BEGIN = .
	DSBINT	LOCK_IPL		; raise IPL to Synch and lock code
	MOVZWL	R11,R0			; get process ID index
	MOVL	@SCH$GL_PCBVEC[R0],R0	; get PCB address
	CMPL	PCB$L_PID(R0),R11	; same PID?
	BNEQ	90$			; NEQ means not the same
	BBC	#PCB$V_PHDRES,PCB$L_STS(R0),90$ ; if the PHD isn't there, exit
	BBS	#PCB$V_DELPEN,PCB$L_STS(R0),85$ ; if process will go away, exit
	MOVL	PCB$L_PHD(R0),R5	; get the header address
	MOVZWL	PHD$W_WSLIST(R5),WSLIST(FP) ; save the WSLIST just in case
	ADDL3	R4,R5,R6		; PHD offset + PHD address => R6
	MOVQ	(R6),PHDTEMP(FP)	; save the data from the PHD
	ENBINT				; allow interrupts again
	MOVAL	PHDTEMP(FP),R4		; point to the saved data
	MOVQ	(SP)+,R5		; restore R5 and R6
	CMPB	#JPI$C_PHDFLDTYPE,R2	; is it a bit field?
	BNEQ	30$			; NEQ means it is not
	BSBW	EXTFLD			; extract out the bitfield
30$:	BRW	MOVEIT			; now "fetch" the data the normal way

85$:	MOVZWL	#SS$_NONEXPR,R0		; process going away
	BRB	95$

90$:	CLRL	R0			; PHD not resident anymore
95$:	ENBINT
	MOVQ	(SP)+,R5		; clean off the stack, restore R5,R6
	RSB

	.PAGE
	.SBTTL	SPECIAL - Handle special conditions

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	These routines handle data items which must be transformed
;	before they are returned to the user.  Generally, some
;	transformation is applied to the data item and the newly
;	computed item is stored in LOCAL_SPACE on the stack.
;	The handling routine then changes R4 to point to LOCAL_SPACE
;	so that MOVEIT will move the item from local storage.
;
; CALLING SEQUENCE:
;
;	JSB/BSB
;
; INPUTS:
;
;	R1 = item identifier
;	R3 = item length
;	R4 = item address
;	R6 = user's buffer length
;	R9 = PCB address of target process
;
; IMPLICIT INPUTS:
;
;	none
;
; OUTPUTS:
;
;	none
;
; IMPLICIT OUTPUTS:
;
;	none
;
; ROUTINE VALUE:
;
;	none
;
; SIDE EFFECTS:
;
;	none
;--

CHECK_SPC:

;
; Registers R5 and R6 are saved at this level and may be used by
; the action routines without being saved.  Action routines are JSB'ed
; to with R5 containing the address of LOCAL_SPACE on the stack.
;

	MOVQ	R5,-(SP)		; save registers
	MOVL	#SPECIAL_LEN,R5		; get number of table entries
	MOVAL	SPECIAL,R6		; get address of table
10$:
	CMPW	R1,(R6)+		; does entry match item?
	BEQL	20$			; yes, go handle it
	ADDL	#4,R6			; skip handler address
	SOBGTR	R5,10$			; scan rest of table
	BRB	30$			; nothing to do, exit
20$:
	MOVAL	LOCAL_SPACE(FP),R5	; load local address for action routine
	JSB	@(R6)+			; call action routine
30$:
	MOVQ	(SP)+,R5		; restore registers
	RSB
;
; Data handling routines
;

;
; Internal priority must be subtracted from 31 before being returned.
;

SPC_PRI:
	SUBB3	(R4),#31,(R5)		; compute external priority
	MOVL	R5,R4			; change address for move routine
	RSB

;
; Check the PCB$L_STS bits to get the mode
;

SPC_MODE:
	MOVL	PCB$L_STS(R9),R6	; the bits are in the STS
	MOVL	#JPI$K_NETWORK,(R5)	; assume network
	BBS	#PCB$V_NETWRK,R6,10$	; if set, all done
	MOVL	#JPI$K_BATCH,(R5)	; now try batch mode
	BBS	#PCB$V_BATCH,R6,10$
	MOVL	#JPI$K_INTERACTIVE,(R5)	; now try interactive mode
	BBS	#PCB$V_INTER,R6,10$
	MOVL	#JPI$K_OTHER,(R5)	; it must be 'other' mode
10$:	MOVL	R5,R4			; point at the 'data'
	RSB

;
; Working set pointers are indices into working set list
; and must be subtracted from first list element.
;

SPC_WORKSET:
	CMPL	R9,SCH$GL_CURPCB	; is the target process our own?
	BEQL	15$			; EQL means it is
	SUBW3	WSLIST(FP),(R4),(R5)	; use the saved WSLIST
	BRB	17$			; don't touch CTL here
15$:	MOVL	@#CTL$GL_PHD,R6		; get process header address
	SUBW3	PHD$W_WSLIST(R6),(R4),(R5) ; compute argument size
17$:	MOVL	R5,R4			; change item address
	INCW	(R4)			; must add one to index
	RSB

;
; Convert the pcb vector index into a process index.  This is so that applications
; which used to use the low word of the PID as an index can adapt.  This item,
; JPI$_PROC_INDEX, is very similar to the current pix:
;
;	PROC_INDEX is a number between 1 and the sysgen parameter MAXPROCESSCNT.
;	This means that it is a small number, and that it is practical to
;	statically allocate bitvectors or other vectors for the maximum
;	number of processes expected.
;
;	At any instant, no more than one process will have a given PROC_INDEX.
;	In particular, no other process will have the same PROC_INDEX as you.
;	This guarantees no collisions.  If the application wanted to know
;	about reuse of the PROC_INDEX, it could store the EPID in the
;	vector and do its own check.
; 
; No program should assume that PROC_INDEX is anything more than this.  Note that
; the sole purpose of the following arithmetic is to make sure that PROC_INDEX is
; NOT the pcb vector index!
;
SPC_PROC_INDEX:
	MOVZWL	(R4),R6			; Get the PIX into a register
	MOVZWL	SGN$GW_MAXPRCCT,(R5)	; Move the MAXPROCESSCNT into the scratch
	SUBL2	R6,(R5)			; Convert 0 to N-1 to range N to 1
	MOVL	R5,R4			; Point at the new value for move routine
	RSB				


;
; Convert the MPID from the JIB to extended format.
;
; Inputs:
;
;	R4 = Addr of MPID in internal format
;	R5 = Addr of scratch buffer
;
; Outputs:
;
;	R4 = Addr. MPID in extended format
;

SPC_MASTER_PID:
	MOVL	(R4),R0			; get MPID
	JSB	G^EXE$IPID_TO_EPID	; convert it to extended format
	MOVL	R0,(R5)			; store converted PID in scratch buffer
	MOVL	R5,R4			; point to the converted PID
	RSB

;
; The current image file name is in the Image File Descriptor Block.  It
; is also in user writable memory, so all addresses must be probed.
;
; Inputs:
;	R4 = CTL$GL_IMGHDRBF, address of image header buffer
;
; Outputs:
;	R3 = size of image file name
;	R4 = address of image file name
;

EXE$CHKIMAGNAME::
	MOVL	(R4),R4			; get address of image header buffer
	BEQL	11$			; if EQL, no image active
	MOVL	4(R4),R5		; get address of image file descriptor
	IFNORD	#8,IFD$Q_CURPROG(R5),11$,#PSL$C_USER ; check access to desc
	MOVQ	IFD$Q_CURPROG(R5),R3	; get image name descriptor
	MOVZWL	R3,R3			; assure size of string is in range
	IFNORD	R3,(R4),11$,#PSL$C_USER	; check access to string
	RSB				;
11$:
	CLRQ	R3			; zero string descriptor
	RSB				;

;
; The current image file name is in the Image File Descriptor Block.
; Probe it for maximum protection.
;
; If a compatibility mode exception handler has been declared for the
; process, assume that an AME is running. Further assume that the second
; compatibility mode context page has been patterned enough after the
; image file descriptor block such that an alternate image name can be
; found there. In this case, return that image name. If the name is null,
; fall back to the name in the Image File Descriptor Block. Note that the
; second compatibility mode context page is user writeable, so it must
; be probed.
;
; Inputs:
;	R4 = CTL$GL_IMGHDRBF, address of image header buffer
;	8(SP) = user's buffer length
;
; Outputs:
;	R3 = size of image file name
;	R4 = address of image file name
;

SPC_IMAGNAME:
	MOVL	8(SP),R6		; get the user's buffer length
	MOVL	(R4),R4			; get address of image header buffer
	BEQL	10$			; if EQL, no image active
	TSTL	G^CTL$GL_CMHANDLR	; is there an AME running?
	BEQL	5$			; if EQL no, use image in IFD
	MOVAL	G^CTL$AL_CMCNTX+^X200,R5 ; point to second c-mode context page
	IFNORD	#8,IFD$Q_CURPROG(R5),10$,#PSL$C_USER ; check access to desc
	MOVL	IFD$Q_CURPROG(R5),R3	; get length of image name string
	BEQL	5$			; if EQL, string is null, get from IFD
	MOVL	IFD$Q_CURPROG+4(R5),R4	; get address of string
	BRB	6$			; join common code

5$:	MOVL	4(R4),R5		; get address of image file descriptor
	IFNORD	#8,IFD$Q_CURPROG(R5),10$,#PSL$C_USER ; check access to desc
	MOVQ	IFD$Q_CURPROG(R5),R3	; get image name descriptor
6$:	MOVZWL	R3,R3			; assure size of string is in range
	CMPL	R3,R6			; is it bigger than the user's buffer?
	BLEQ	7$
	MOVL	R6,R3			; yes, make user's size the real size
7$:	IFNORD	R3,(R4),10$,#PSL$C_USER	; check access to string
	RSB				;
10$:
	CLRQ	R3			; zero string descriptor
	RSB				;

LOCK_IPL:
	.BYTE	IPL$_SYNCH
LOCK_END:
	ASSUME	<LOCK_END-LOCK_BEGIN> LE 512
	.PAGE
	.SBTTL	MOVEFU - Move data from user to system buffer
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is entered as the result of a special kernel AST
;	generated by a process requesting information through $GETJPI
;	on another process.  MOVEFU is passed control information and
;	the item list in the AST packet.  Also chained into the AST
;	packet is another packet for returning the data.  This packet
;	is returned by issuing a special kernel AST to the process
;	requesting the information, to the label MOVETU in GETJPI.
;
; CALLING SEQUENCE:
;
;	JSB (as the result of a special kernel AST)
;
; INPUTS:
;
;	R0:R3 - scratch
;	R4 - PCB ADDRESS
;	R5 - AST control block address
;	Control block (see below)
;
; OUTPUTS:
;
;	None
;
; ROUTINE VALUE:
;
;	None
;
; SIDE EFFECTS:
;
;	If the process requesting information still exists, a special
;	kernel AST is issued to address MOVETU to process the filled
;	information packets.
;
;--
	.enable lsb
MOVEFU:
	PUSHR	#^M<R4,R5,R6,R7,R8,R9,R10,R11,FP>
	MOVL	SP,FP			; set address of local storage
	MOVAL	LOCAL_SPACE(SP),SP	; allocate local storage
	MOVL	ACB_L_OPID(R5),ACB$L_PID(R5) ; turn the block around
	MOVAB	W^MOVETU,ACB$L_KAST(R5)	; new AST routine 
	BISB2	#<1@ACB$V_KAST>,ACB$B_RMOD(R5)	; set special kernel bit again
	MOVL	ACB_L_COUNT(R5),R10	; get item count
	MOVL	ACB_L_DADDR(R5),R11	; get data block address
	MOVAL	ACB_L_ILIST(R5),R7	; point to start of item list
	MOVL	R4,R9			; setup for call to CHECKITEM
;
; Loop through item descriptor list, moving data to the system buffer
;
10$:	MOVZWL	(R7)+,R6		; get user buffer size
	MOVL	R7,PHDTEMP(FP)		; save address of item identifier
	MOVZWL	(R7)+,R1		; item identifier
	BSBW	CHECKITEM		; get address and size of item
	BSBW	CHECK_SPC		; check for special types
	CMPL	#CSTRING,R5		; counted string?
	BNEQ	20$			; branch if not
	MOVZBL	(R4)+,R3		; get length and skip length byte

20$:	MOVW	R3,@PHDTEMP(FP)		; clobber item code with source size
	MOVC5	R3,(R4),#0,R6,(R11)	; move data to system buffer
	MOVL	R3,R11			; update system buffer pointer
	ADDL	#8,R7			; update item descriptor pointer
					; by skipping user buffer addresses
	SOBGTR	R10,10$			; decrement item count and loop
;
; We have moved all the data to the system buffer. Restore registers, and
; check to see if the requesting process is still active, before we queue the
; return kernel AST.
;
	MOVAL	-LOCAL_SPACE(SP),SP	; remove local storage from stack
	POPR	#^M<R4,R5,R6,R7,R8,R9,R10,R11,FP>
30$:	SETIPL	50$			; raise IPL to synch, lock code.
	MOVZWL	ACB_L_OPID(R5),R1	; old PID
	MOVL	@SCH$GL_PCBVEC[R1],R1	; PCB address associated.
	CMPL	PCB$L_PID(R1),ACB$L_PID(R5)	; same PID in both places?
	BNEQ	40$			; error if not.
	BBS	#PCB$V_DELPEN,PCB$L_STS(R1),40$ ; error if delete pending
	CLRL	R2			; null priority increment
	JSB	SCH$QAST		; queue the AST
	SETIPL	#IPL$_ASTDEL		; drop back to AST delivery level
	RSB				;
;
; If the process did not exist, or was marked for delete, deallocate the 
; blocks and return.
;
40$:	SETIPL	#IPL$_ASTDEL		; drop back to AST delivery level
	MOVL	R5,R0			; get AST block address
DEANONPAGED:				; local point for all calls to EXE$D...
	JMP	G^EXE$DEANONPAGED	; deallocate it and exit
;
; The preceding code must raise IPL to synchronize access to process database,
; but since it is paged it must be locked in memory. The usage of the SETIPL
; macro above, both raises IPL and faults the code into memory.
;
50$:
	.BYTE	IPL$_SYNCH		; end of locked code region
	ASSUME	<.-30$> LE 512		; only 512 bytes can be locked
	.disable lsb

	.PAGE
	.SBTTL	MOVETU - Move data from system buffer to user
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	MOVETU is entered as the result of a special kernel AST queued by
;	the routine MOVEFU from the process we were requesting information
;	from on a GETJPI system service.  The data buffer has been filled,
;	and now we must move that data from the system buffer to the user.
;
;	Prior to storing the data, we check to see if the copy of PHD$L_IMGCNT
;	that was saved in the packet is the same as that in the process header.
;	If they are not equal, it means the image that issued the GETJPI service
;	has exited, and a new image is in memory; we should not move the data
;	to the user.
;
; CALLING SEQUENCE:
;
;	JSB (as the result of a special kernel AST)
;
; INPUTS:
;
;	R0:R3 - scratch
;	R4 - PCB address
;	R5 - AST control block address
;	Control block data
;
; OUTPUTS:
;
;	none
;
; ROUTINE VALUE:
;
;	none
;
; SIDE EFFECTS:
;
;	Attempts to move data to user buffers, as requested by original
;	GETJPI request. May cause setting of event flags, IOSB, and
;	possibly an AST to the requestor.  Errors in processing result
;	in an attempt to post the error status in the IOSB, if specified.
;--
MOVETU:
;
; See if PHD$L_IMGCNT has what we think it has in it, and free the blocks
; and exit if it doesn't; if not equal, a different image is running!
;
	MOVL	CTL$GL_PHD,R3		; get process header address
	CMPL	PHD$L_IMGCNT(R3),ACB_L_IMGCNT(R5) ; see if the same thing.
	BEQL	10$			; go move data if equal
	BBC	#ACB$V_QUOTA,ACB$B_RMOD(R5),5$ ; has AST quota been charged?
	INCW	PCB$W_ASTCNT(R4)	; give it back
5$:	MOVL	R5,R0			; get address of AST block
	MOVL	PCB$L_JIB(R4),R1	; get address of JIB
	MOVZWL	ACB$W_SIZE(R0),R2	; convert count to longword
	ADDL	R2,JIB$L_BYTCNT(R1)	; restore buffer quota
	BRB	DEANONPAGED		; deallocate AST block and exit

10$:
	PUSHR	#^M<R4,R5,R6,R7,R8,R9,R10,R11>
	MOVZBL	ACB$B_RMOD(R5),R9	; get requester's access mode
	MOVL	ACB_L_COUNT(R5),R10	; get item count
	MOVL	ACB_L_DADDR(R5),R1	; get data buffer address
	MOVAL	ACB_L_ILIST(R5),R6	; get starting address of the list
;
; Loop through item descriptor list, moving data to user buffer(s)
;
20$:
	MOVZWL	(R6)+,R7		; user buffer length
	MOVZWL	(R6)+,R8		; actual data length
	MOVL	(R6)+,R5		; user buffer address
;
; Check that requester still has write access to his buffer
;
	MOVL	R5,R0			; buffer address to R0
	PUSHL	R1			; Save R1
	MOVL	R7,R1			; and size to R1
	MOVL	R9,R3			; use access mode value from ACB for PROBE
	JSB	EXE$PROBEW		; check write accessibility of buffer
	POPL	R1			; Restore R1
	BLBC	R0,50$			; get out if buffer inaccessible
;
; Now actually move the data
;
	MOVC3	R7,(R1),(R5)		; move data to user buffer
	MOVL	(R6)+,R0		; get address to store actual length
	BEQL	40$			; branch if no length wanted
	IFNOWRT	#2,(R0),50$,R9		; requester still have access to buffer?
	CMPL	R8,R7			; actual data length less than user's?
	BLEQ	30$			; branch if yes - use actual length
	MOVL	R7,R8			; use user buffer length
30$:	MOVW	R8,(R0)			; return buffer length
40$:	SOBGTR	R10,20$			; decrement item count and loop
	MOVZWL	#SS$_NORMAL,R0		; set successful completion
	BRB	60$			;
50$:	MOVZWL	#SS$_ACCVIO,R0		; set access violation failure
;
; Restore original registers, set the event flag, and post completion status
;
60$:	POPR	#^M<R4,R5,R6,R7,R8,R9,R10,R11>
	PUSHL	R0			; save status
	MOVL	ACB_L_EFN(R5),R3	; get event flag number
	MOVL	PCB$L_PID(R4),R1	; and PID for process
	CLRL	R2			; set null priority increment
	JSB	G^SCH$POSTEF		; set the event flag
	POPL	R0			; restore exit status
	MOVL	ACB_L_IOSB(R5),R3	; possible IOSB address?
	BEQL	70$			; branch if none supplied
	IFNOWRT	#4,(R3),70$,ACB$B_RMOD(R5) ; check if IOSB still accessable
	MOVL	R0,(R3)			; store completion status
; Return the BYTCNT quota to the caller
;
70$:	MOVZWL	ACB$W_SIZE(R5),R2	; convert to longword
	MOVL	PCB$L_JIB(R4),R1	; get JIB address
	ADDL	R2,JIB$L_BYTCNT(R1)	; restore buffer quota
;
; If an AST was specified, queue it to caller and return.
;
	TSTL	ACB$L_AST(R5)		; is an address supplied?
	BEQL	80$			; branch if not.
	CLRL	R2			; no priority increment
	JMP	SCH$QAST		; queue AST to user and exit
;
; No AST specified, deallocate the AST control block and return.
;
80$:	MOVL	R5,R0			; set the address of the AST block
	BRW	DEANONPAGED		; deallocate the block and exit
	.PAGE
	.SBTTL	NAMPID - Get specified process ID
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	Routine to convert a process name to a PID and check privileges. If a
;	valid PID or process name is specified, the standard conversion
;	routine EXE$NAMPID is simply called.  If, however, a PID that implies
;	a "wildcard" PID (-1) is specified, then the next active process is
;	chosen as the process ID to pass to EXE$NAMPID.  EXE$NAMPID then
;	checks the requestor's privilege to obtain information about the
;	process and returns the process's PCB address.
;
; INPUTS:
;
;	R4 = current process PCB address
;	PIDADR(AP) = address of specified PID
;	PRCNAM(AP) = address of specified process name descriptor
;
; OUTPUTS:
;
;	R0 = success/failure of operation
;	R4 = current process PCB address
;	R9 = specified process PCB address
;	R11 = specified process PID
;	@PIDADR(AP) = specified process PID or special "wildcard" context PID
;--
NAMPID:
	.ENABL	LSB
	MOVL	PIDADR(AP),R6		; get PID address
	BEQL	20$			; if eql - none
	IFNOWRT	#4,(R6),50$		; check access to PID
	MOVL	(R6),R0			; get PID
	BGEQ	20$			; if geq - standard extended PID
;
; "Wildcard" type PID specified
;
	CVTWL	R0,R5			; get PIX (Process IndeX) from PID
	MOVAL	G^SCH$GL_NULLPCB,R0	; special case handling for NULL proc
	BISL2	#<1@JPI_V_WILD>,FLAGS(FP) ; mark wildcarding in progress
10$:	INCW	R5			; increment PIX
	CMPW	R5,SCH$GL_MAXPIX	; is PIX in valid range?
	BGTRU	60$			; if gtru, no - no more processes
	MOVZWL	R5,R5			; clean out top half of R5
	BEQL	15$			; if eql, this indicates actual NULL proc
	MOVL	@SCH$GL_PCBVEC[R5],R0	; get PCB address
	CMPL	R0,#SCH$GL_NULLPCB	; unused process slot?
	BEQL	10$			; if eql, yes - try next one
15$:	BBS	#PCB$V_DELPEN,PCB$L_STS(R0),10$ ; also get next one if this
					; one is going away
	MOVL	PCB$L_EPID(R0),(R6)	; store extended PID in argument list
;
; Convert process name to PID, if specified, and check privileges
;
20$:	ADDL	#4,AP			; make PIDADR top argument
	JSB	25$			; get into nonpaged code
	.SAVE_PSECT			; save current .PSECT context

;  The reason for jumping to the nonpaged exec rather than dynamically
;  locking down pageable pages is that EXE$NAMPID cannot be entered
;  above IPL 2 and the dynamic locking would cause that to happen. The
;  reason that EXE$NAMPID must be entered at IPL 2 or lower is that it
;  touches the caller's argument list (which contains arguments that
;  could fault) and page faults are not allowed above IPL 2.

	.PSECT	AEXENONPAGED		; EXE$NAMPID returns at IPL$_SYNCH
25$:	BSBW	EXE$NAMPID		; get PCB address and check privileges
	SETIPL	#0			; restore IPL - PCB is no longer locked
	RSB				; go back to paged code

	.RESTORE_PSECT			; get paged .PSECT context back
	SUBL	#4,AP			; restore argument pointer
	MOVL	R1,R11			; save PID
	BBC	#JPI_V_WILD,FLAGS(FP),30$ ; "wildcard" PID specified?
	MOVW	R1,(R6)			; restore process index context
	MNEGW	#1,2(R6)		; else, set continuation context
;
; Check PID address and return
;
30$:	BLBC	R0,40$			; branch if error
	MOVL	R4,R9			; save PCB address
	CMPW	R11,S^#SCH$C_SWPPIX	; is PID a normal one?
	BGTRU	40$			; if GTRU, yes
	BISL2	#<1@JPI_V_NULLSWAP>,FLAGS(FP) ; indicate Null or Swapper process
40$:	MOVL	SCH$GL_CURPCB,R4	; restore current PCB address
	RSB

50$:	MOVZWL	#SS$_ACCVIO,R0		; set access violation
	BRB	40$			;
60$:	MOVZWL	#SS$_NOMOREPROC,R0	; set no more processes
	BRB	40$			;

	.END
