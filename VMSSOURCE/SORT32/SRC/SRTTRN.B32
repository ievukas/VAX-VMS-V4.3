MODULE SRTTRN(	MAIN = SRTTRN,
		IDENT = 'V04-000'	! File: SRTTRN.B32 Edit: PDG3006
		%IF %BLISS(BLISS32) %THEN
		,ADDRESSING_MODE(EXTERNAL=GENERAL)
		%FI
		) =
BEGIN
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
!
! FACILITY:	VAX-11 SORT/MERGE & PDP-11 SORT/MERGE
!
! ABSTRACT:
!
!	This module translates specification files,
!	from:
!		SORT-11 V2.0 or VAX-11 SORT/MERGE V3.0 format
!	to:
!		PDP-11 SORT/MERGE V3.0 or VAX-11 SORT/MERGE V3B format.
!
! ENVIRONMENT:	VAX/VMS user mode
!
! AUTHORS:
!	Peter D Gilbert, Victor L Bennison,	CREATION DATE: 21-Jan-1982
!
! MODIFIED BY:
!
!	T03-001		Original
!	T03-002	Distinguish between F and D floating.  PDG 3-Mar-1983
!	T03-003	Major fixes, including variable-format support, and addition
!		of /S11 and /S32 qualifiers.  PDG 3-Mar-1983
!	T03-004	Remove GLOBAL declarations.  PDG 11-May-1983
!	T03-005	Changes so this can be used on PDP-11s.  PDG 28-Sep-1983
!	T03-006	Added forced fields to the key list so they are now output
!		in the correct order relative to other keys.
!		Changed to GCML for Bliss-11.  Added DTYPE_AZ and DTYPE_DIBOL.
!		Interpretation of 'Z' data type depend on /S11/S32 qualifier.
!		Check output LRL length.  PDG 26-Oct-1983
!--

LITERAL
	K_NATIVE = 1;		! True to use native routines for VAXen
LITERAL
	K_NEW = 1;

LIBRARY	'SRC$:SFKEYWRD';	! Keywords in specification file
%IF %BLISS(BLISS32) %THEN
LIBRARY	'SYS$LIBRARY:STARLET';	! Defines system services,etc.
LIBRARY	'SYS$LIBRARY:XPORT';
REQUIRE	'SRC$:SRTTRNMSG';	! Error message definitions
%ELSE
LIBRARY	'SYS$LIBRARY:RMSINT';	! Defines system services,etc.
LIBRARY	'SYS$LIBRARY:XPORT';
REQUIRE	'SRC$:SRTTRNMSC';	! Miscellaneous
REQUIRE	'SRC$:SRTTRNMSG';	! Error message definitions
LIBRARY	'SYS$LIBRARY:RSX11M';
%FI

LINKAGE
    CALL = CALL;
FORWARD ROUTINE
    SRTTRN,			! Main entry
    DEF_FIELDS:	NOVALUE,
    DEF_SUBFIELDS: NOVALUE,
    PUT_DEFN:	NOVALUE,
    PUT_NAME:	NOVALUE,
    PUT_FFLD:	NOVALUE,
    REPORT_IO_ERROR:	CALL,	! Report on I/O errors
    INIT_IO:	NOVALUE,	! Parses command line, opens and connects files
    CVT_DTB,			! Converts ascii to binary
    CVT_BTA,			! Converts binary to ascii
    NEW_FMT,
    DO_FIELD:	NOVALUE,	! Get all field definitions if no record types
    DO_HEADER:	NOVALUE,	! Get header information
    DO_ALTSEQ:	NOVALUE,	! Process altseq line
    GET_VM:	NOVALUE,
    DO_RECORD:	NOVALUE,	! Process an include or omit
    GET_DEFN,			! Get position, size and type from factor
    GET_FFLD,			! Create a new forced field block
    GET_LINE,			! Get line of old spec file
    TREE_INSERT,
    SOR_ERROR,			! Issue diagnostic
    PUT_LITE:	NOVALUE,	! Output a literal to new spec file
    PUT_QUOT:	NOVALUE,	! Output quoted text to new spec file
    PUT_TEXT:	NOVALUE CALL,	! Output text to new spec file
    PUT_LINE:	NOVALUE CALL,	! Output line to new spec file
    NEW_KEY:	CALL,		! Create a new key description
    UPCASE:	NOVALUE,	! Convert to upper case
    FREE_FIXED:	NOVALUE,	! Convert from free-format to fixed-format
    CLOSE_FILES: NOVALUE;	! Close input and output files

LITERAL 
	HEADER_LINE =	1,	! Types of lines in old spec file
	ALTSEQ_LINE =	2,
	RECORD_LINE =	3,
	FIELD_LINE =	4;

LITERAL
	FALSE =	0,
	TRUE =	1;

STRUCTURE
	BBLOCK[O,P,S,E;BS=0] = [BS](BBLOCK+O)<P,S,E>;

MACRO
	BASE_ = 0,0,0,0 %,
	ELIF = ELSE IF %,
	LENADR_[] = %CHARCOUNT(%REMAINING), UPLIT BYTE(%STRING(%REMAINING)) %;

%IF %BLISS(BLISS32)
%THEN MACRO STR_LOG_WORKFILE = 'SORTD0' %;
%ELSE MACRO STR_LOG_WORKFILE = 'SYS$SCRATCH:SRTTRN.SRT' %;
%FI

LITERAL
	INP_BUF_WIDTH = 132,
	OUT_BUF_WIDTH = 255,
	OUT_WIDTH = 80 - 8 - 1;

OWN
	INP_BUF: 	VECTOR[INP_BUF_WIDTH,BYTE],	! Input record buffer
	OUT_BUF:  	VECTOR[OUT_BUF_WIDTH,BYTE],	! Output record buffer
	OUT_DSC:	VECTOR[2],		! Len/adr of remaining room
	INP_REC_SIZ;				! Input record size

OWN
	CUR_RAB: REF $RAB_DECL;			! Current input RAB
OWN
	INP_FNA: BLOCK[NAM$C_MAXRSS, BYTE],	! File name string area
	INP_NAM: $NAM(
		ESS=%ALLOCATION(INP_FNA),	! Expanded name string size
		ESA=INP_FNA,			! Expanded name string area
		RSS=%ALLOCATION(INP_FNA),	! Resultant name string size
		RSA=INP_FNA),			! Resultant name string area
	INP_FAB: $FAB(
		NAM=INP_NAM[BASE_],
		DNA=UPLIT BYTE('.SRT'),		! Default for /S11 only!
		DNS=%CHARCOUNT('.SRT'),		! Default for /S11 only!
		FAC=GET,	! Read-only
		FOP=<SQO>,	! Sequential only
		RFM=VAR,	! Variable length format
		SHR=GET),	! Share read
	INP_RAB: $RAB(
		FAB=INP_FAB[BASE_],
!		MBC=16,		! Multi-block count
!		MBF=2,		! Multi-buffer count
		USZ=%ALLOCATION(INP_BUF),
		UBF=INP_BUF);	! Input buffer
OWN
	TMP_FNA: BLOCK[NAM$C_MAXRSS, BYTE],	! File name string area
	TMP_NAM: $NAM(
		ESS=%ALLOCATION(TMP_FNA),	! Expanded name string size
		ESA=TMP_FNA,			! Expanded name string area
		RSS=%ALLOCATION(TMP_FNA),	! Resultant name string size
		RSA=TMP_FNA),			! Resultant name string area
	TMP_FAB: $FAB(
		NAM=TMP_NAM[BASE_],
		FNA=UPLIT BYTE(STR_LOG_WORKFILE),
		FNS=%CHARCOUNT(STR_LOG_WORKFILE),
		FAC=<GET,PUT>,
		FOP=<DFW,DLT,TMD,TMP,SUP,SQO>,
		RFM=VAR,	! Variable length format
		SHR=NIL),	! No sharing
	TMP_RAB: $RAB(
		FAB=TMP_FAB[BASE_],
!		MBC=16,		! Multi-block count
!		MBF=2,		! Multi-buffer count
		USZ=%ALLOCATION(INP_BUF),	! Same as input file
		UBF=INP_BUF,
		RBF=INP_BUF);	! Output buffer
OWN
	OUT_FNA: BLOCK[NAM$C_MAXRSS, BYTE],	! File name string area
	OUT_NAM: $NAM(
		RLF=INP_NAM[BASE_],	! Related file name string
		ESS=%ALLOCATION(OUT_FNA),	! Expanded name string size
		ESA=OUT_FNA,			! Expanded name string area
		RSS=%ALLOCATION(OUT_FNA),	! Resultant name string size
		RSA=OUT_FNA),			! Resultant name string area
	OUT_FAB: $FAB(
		NAM=OUT_NAM[BASE_],
		DNA=UPLIT BYTE('.SRT'),
		DNS=%CHARCOUNT('.SRT'),
		FOP=<OFP,SQO>,	! Output file parse
		FAC=PUT,	! Write access
		RAT=CR,		! Line feed and carriage return
		RFM=VAR),	! Variable length format
	OUT_RAB: $RAB(
		FAB=OUT_FAB[BASE_],
!		MBC=16,		! Multi-block count
!		MBF=2,		! Multi-buffer count
		RSZ=%ALLOCATION(OUT_BUF),
		RBF=OUT_BUF);	! Output buffer

LITERAL
    LUN_K_MSG = 1,
    LUN_K_INP = 2,
    LUN_K_OUT = 3,
    LUN_K_TMP = 4;

! Define shared messages
!
MACRO
    DEFSHR_[MSG,SEV] =
	%NAME('SRTTRN$_',MSG) =
	    %NAME('SHR$_',MSG) + %NAME('STS$K_',SEV)
	    %IF %BLISS(BLISS32) AND K_NATIVE %THEN
		+ SRTTRN$_FACILITY ^ 16
	    %FI
	%;
LITERAL
    DEFSHR_(
	BADLOGIC, SEVERE,	! Internal logic error detected
	CLOSEDEL, ERROR,	! Error closing !AS
	CLOSEIN,  ERROR,	! Error closing !AS as input
	CLOSEOUT, ERROR,	! Error closing !AS as output
	INSVIRMEM,SEVERE,	! Insufficient virtual memory
	OPENIN,   SEVERE,	! Error opening !AS as input
	OPENOUT,  SEVERE,	! Error opening !AS as output
	READERR,  ERROR,	! Error reading !AS
	SYSERROR, SEVERE,	! System service error
	WRITEERR, ERROR);	! Error writing !AS

! Define the keyword strings
!
MACRO
	DEFSTR_[A,B] = %NAME('X_',A) = B %QUOTE % %;
MACRO
	DEFSTR_(KEYWORDS);


! Define a structure for holding field definitions
!
$UNIT_FIELD
	FLD_FIELDS =
	SET
	FLD_LSON=	[$ADDRESS],	! Pointer to FLD_BLOCK
	FLD_RSON=	[$ADDRESS],	! Pointer to FLD_BLOCK
	FLD_POS=	[$BITS(16)],	! Position of field in record
	FLD_SIZ=	[$BITS(16)],	! Size of field in record
	FLD_FFLD=	[$ADDRESS],	! Pointer to FFLD_BLOCK
	FLD_DTY=	[$BITS(8)]	! Datatype of field
	TES;
LITERAL	FLD_K_SIZE=	$FIELD_SET_UNITS;	! Size in units
MACRO	FLD_BLOCK=	BBLOCK[FLD_K_SIZE] FIELD(FLD_FIELDS) %;

! Define a structure for holding forced field definitions
!
$UNIT_FIELD
	FFLD_FIELDS =
	SET
	FFLD_NEXT=	[$ADDRESS],	! Pointer to alternate FFLD_BLOCK or 0
	FFLD_COND=	[$BITS(16)],	! Condition number
	FFLD_LIT=	[$BITS(8)]	! Literal value for this FFLD
	TES;
LITERAL	FFLD_K_SIZE=	$FIELD_SET_UNITS;	! Size in units
MACRO	FFLD_BLOCK=	BBLOCK[FFLD_K_SIZE] FIELD(FFLD_FIELDS) %;

! Define a structure for format information
!
$UNIT_FIELD
	FMT_FIELDS =
	SET
	FMT_NEXT=	[$ADDRESS],		! Pointer to next FMT_BLOCK
	FMT_KEYS=	[$ADDRESS],		! Pointer to KEY_BLOCK
	FMT_CKEY=	[$ADDRESS],		! Pointer to current KEY_BLOCK
	FMT_OUTLRL=	[$INTEGER],		! Output LRL for this format
	FMT_COND=	[$BITS(16)]		! Conditionality of this format
	TES;
LITERAL	FMT_K_SIZE=	$FIELD_SET_UNITS;	! Size in units
MACRO	FMT_BLOCK=	BBLOCK[FMT_K_SIZE] FIELD(FMT_FIELDS) %;

! Define a structure for holding keys of different formats
!
$UNIT_FIELD
	KEY_FIELDS =
	SET
	KEY_NEXT=	[$ADDRESS],		! Pointer to next KEY_BLOCK
	KEY_FLD=	[$ADDRESS],		! Pointer to FLD_BLOCK
	KEY_ASCE=	[$BIT],			! True if ascending key
$OVERLAY(KEY_ASCE)
	KEY_LIT=	[$BITS(8)]		! Literal key (if key_fld = 0)
$CONTINUE
	TES;
LITERAL	KEY_K_SIZE=	$FIELD_SET_UNITS;	! Size in units
MACRO	KEY_BLOCK=	BBLOCK[KEY_K_SIZE] FIELD(KEY_FIELDS) %;


! OWN Storage
!
GLOBAL
	CLR_0:		VECTOR[0],
	ASCENDING,		! True if ascending is the default
	ALTSEQ,			! Altseq expected = 1, unexpected = 0
	FLD_ROOT,		! Tree of field names
	FMT_ROOT:	REF FMT_BLOCK,
	FMT_CURR:	REF FMT_BLOCK,
	LINE_TYPE,		! Type of input line
	LINE_NUM,		! Last line number
	LINE_SEQ,		! True if line numbers were out of sequence
	ADDINCKEY,		! True if additional keys were added
	COND_NUM,		! Condition number
	PASS,			! What pass we are working on
	PROCESS,		! What sort process we are doing
	EBCDIC,			! True for ebcdic collating sequence
	NOSTRIP,		! True if we are not doing key stripping
	OUTLRL,			! Output LRL
	SWITCH_S32,		! True if /S32 qualifier was present
	SOR_SEV,		! Worst severity (encoded)
	SOR_STS,		! Worst status
	CLR_1:		VECTOR[0];

%IF %BLISS(BLISS16) %THEN
EXTERNAL LITERAL
	EX$SEV, EX$SUC, EX$WAR, EX$ERR;
%FI
%IF NOT %DECLARED(DSC$K_DTYPE_DIBOL) %THEN
LITERAL
	DSC$K_DTYPE_DIBOL = 40;
%FI
%IF NOT %DECLARED(DSC$K_DTYPE_AZ) %THEN
LITERAL
	DSC$K_DTYPE_AZ = 41;
%FI

GLOBAL ROUTINE SOR_ERROR(ERR) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine signals an error diagnostic.
!
! FORMAL PARAMETERS:
!
!	Parameters passed to SIGNAL.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	System status (first parameter of signalled status), with the
!	INHIB_MSG bit set.
!
! SIDE EFFECTS:
!
!	The image may be exitted due to the error.
!
!--
    BEGIN
    SIGNAL(.ERR);
    RETURN .ERR OR STS$M_INHIB_MSG;
    END;

ROUTINE CVTBTA(X, P) =
    BEGIN
    IF .X LSS 0
    THEN
	BEGIN
	CH$WCHAR_A('-',P);
	X = -.X;
	END;
    IF .X GEQ 10 THEN P = CVTBTA(.X/10, .P);
    CH$WCHAR_A((.X MOD 10)+'0', P);
    RETURN .P;
    END;

%IF %BLISS(BLISS32) AND K_NATIVE
%THEN %ELSE
ROUTINE PUT_MSG(LEN, ADR): NOVALUE =
    BEGIN
    %IF %BLISS(BLISS32)
    %THEN
	$XPO_PUT_MSG(
	    STRING = (.LEN, .ADR),
	    FAILURE = 0);
    %ELSE
	OWN
	    LUN:	INITIAL(0);
	EXTERNAL
	    $DSW;			! Directive status word
	LOCAL
	    IOSB:	VECTOR[4,BYTE];	! I/O status block

	IF .LUN EQL 0
	THEN
	    BEGIN
	    !
	    ! Assign lun 1
	    !
	    ALUN$S( LUN_K_MSG, 'TI', 0 );
	    IF .$DSW NEQ IS_SUC THEN RETURN;
	    LUN = LUN_K_MSG;
	    END;

	! Attach the device and write the buffer
	!
	QIOW$S( IO_ATT, LUN_K_MSG, 10,, IOSB );
	IF .IOSB[0] NEQ IS_SUC THEN RETURN;
	QIOW$S( IO_WLB, LUN_K_MSG, 10,, IOSB,, <.ADR, .LEN> );
	IF .IOSB[0] NEQ IS_SUC THEN RETURN;

	! Detatch the device
	!
	QIOW$S( IO_DET, LUN_K_MSG, 10,, IOSB );
	IF .IOSB[0] NEQ IS_SUC THEN RETURN;
    %FI
    END;
%FI

ROUTINE COND_HAND(
	SIG:	REF VECTOR,
	MCH:	REF VECTOR,
	ENA:	REF VECTOR) =
    BEGIN
    BIND
	COND = SIG[1]: %BLISS32(BLOCK[,BYTE]) %BLISS16(CONDITION_VALUE),
	RETURN_VALUE = MCH[ %BLISS16(1) %BLISS32(3) ];
    LITERAL
	FAO_COUNT = 2,	! Index in SIG of the FAO count
	SIG_IGNORE = %IF %BLISS(BLISS32) %THEN 2 %ELSE 0 %FI;

    %IF %BLISS(BLISS32) AND K_NATIVE
    %THEN
	BEGIN
	RETURN SS$_RESIGNAL;
	END
    %ELSE
	BEGIN
	LITERAL
	    BUF_SIZE = 255;
	%IF %BLISS(BLISS32) %THEN LOCAL %ELSE OWN %FI
	    B:	VECTOR[BUF_SIZE,BYTE];
	LOCAL
	    P,
	    Q:	REF VECTOR[,BYTE,UNSIGNED],
	    X;
	BIND
	    SEV = UPLIT('WSEIF567'): VECTOR[,BYTE];
	MACRO
	    CRLF = %CHAR(%X'0D',%X'0A') %;

	! Issue the original error message
	!
	P = CH$MOVE(LENADR_(%STRING(CRLF,'%SRTTRN-')), B[0]);
	CH$WCHAR_A(.SEV[.COND[STS$V_SEVERITY]], P);
	CH$WCHAR_A('-', P);

	! Is this a known message?
	!
	IF .COND[STS$V_COND_ID] GEQU .ERR_D[-1]
	THEN
	    Q = UPLIT BYTE(%ASCIC 'NOMSG', %ASCIC 'Message number ')
	ELSE
	    Q = .ERR_D[.COND[STS$V_COND_ID]];
	P = CH$MOVE(.Q[0], Q[1], .P);
	Q = .Q + .Q[0] + 1;
	CH$WCHAR_A(',',P);
	CH$WCHAR_A(' ',P);

	! Index of first (if any) FAO parameter
	!
	X = FAO_COUNT+1;

	! Look for and substitute any !AS in the control string
	!
	BEGIN
	LOCAL D: VECTOR[2];
	MACRO FAO_STR = '!AS' %;
	D[0] = .Q[0];
	D[1] = Q[1];
	WHILE .D[0] GTR 0 DO
	    BEGIN
	    LOCAL R;
	    R = CH$FIND_SUB(.D[0], .D[1], LENADR_(FAO_STR));
	    IF CH$FAIL(.R) THEN R = .D[0] ELSE R = CH$DIFF(.R, .D[1]);
	    R = MINU(.R, CH$DIFF(B[BUF_SIZE],.P));
	    P = CH$MOVE(.R, .D[1], .P);
	    R = .R + %CHARCOUNT(FAO_STR);
	    D[0] = .D[0] - .R;
	    D[1] = .D[1] + .R;
	    IF	.X LEQ .SIG[0] - SIG_IGNORE AND
		.X LEQ .SIG[FAO_COUNT]+FAO_COUNT
	    THEN
		BEGIN
		R = MINU(.VECTOR[.SIG[.X],0], CH$DIFF(B[BUF_SIZE],.P));
		P = CH$MOVE(.R, .VECTOR[.SIG[.X],1], .P);
		X = .X + 1;
		END;
	    END;

	! If this is an unknown message, append the number
	!
	IF .COND[STS$V_COND_ID] GEQU .ERR_D[-1]
	THEN
	    P = CVTBTA(.COND, .P);
	END;

	! Ensure that we've skipped all the FAO parameters
	!
	IF .SIG[0] GEQ FAO_COUNT - SIG_IGNORE
	THEN
	    X = FAO_COUNT+1 + .SIG[FAO_COUNT];

	! Issue the first line
	!
	P = CH$MOVE(LENADR_(CRLF), .P);
	PUT_MSG(CH$DIFF(.P,B[0]),B[0]);

	! Print any other parameters as numbers
	!
	IF .X LEQ .SIG[0] - SIG_IGNORE
	THEN
	    BEGIN
	    P = CH$MOVE(LENADR_('-I-ADDSTS, additional status '), B[0]);
	    WHILE TRUE DO
		BEGIN
		IF CH$DIFF(B[BUF_SIZE],.P) LEQ 16 THEN EXITLOOP;
		P = CVTBTA(.SIG[.X], .P);
		IF .X EQL .SIG[0] - SIG_IGNORE THEN EXITLOOP;
		P = CH$MOVE(LENADR_(' / '), .P);
		X = .X + 1;
		END;
	    P = CH$MOVE(LENADR_(CRLF), .P);
	    PUT_MSG(CH$DIFF(.P,B[0]),B[0]);
	    END;

	! Hang onto the worst error we've seen
	!
	BEGIN
	BIND CVT_SEV = UPLIT BYTE(2,0,3,1,4,5,6,7): VECTOR[,BYTE];
	LOCAL SEV;
	SEV = .CVT_SEV[.COND[STS$V_SEVERITY]];
	IF .SEV GTRU .SOR_SEV
	THEN
	    %IF %BLISS(BLISS32)
	    %THEN
		BEGIN
		SOR_SEV = .SEV;
		SOR_STS = .COND OR STS$M_INHIB_MSG;
		END
	    %ELSE
		BEGIN
		BIND
		    CVT_STS = UPLIT(
			EX$SUC, EX$SUC, EX$WAR, EX$ERR,
			EX$SEV, EX$SEV, EX$SEV, EX$SEV ): VECTOR;
		SOR_SEV = .SEV;
		SOR_STS = .CVT_STS[.SEV] OR STS$M_INHIB_MSG;
		END
	    %FI;
	END;

	! Abort if the severity is fatal (or worse)
	!
	%IF %BLISS(BLISS16)
	%THEN
	    IF .SOR_SEV GEQU 4 THEN EXST$S( .SOR_STS );
	%FI
	RETURN 1;	! Just resignal
	END
    %FI;
    END;

ROUTINE SRTTRN =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This is the main entry point for the spec file translator.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	Status code.
!
! SIDE EFFECTS:
!
!	NONE
!
!--
    BEGIN
    LOCAL
	PTR;

    ENABLE
	COND_HAND;

    ! Initialize our storage
    !
    CH$FILL( 0, CLR_1[0] - CLR_0[0], CLR_0[0] );

    ! Initialize the severity and message to success
    !
    SOR_SEV = 0;
    SOR_STS = %BLISS32(SS$_NORMAL) %BLISS16(EX$SUC);

    OUT_DSC[0] = OUT_WIDTH;
    OUT_DSC[1] = OUT_BUF[0];

    INIT_IO();

    ASCENDING = TRUE;

!+
!
! Make a first pass to:
!	Output original file as comments
!	Process the header line
!	Define the fields
!
! Make a second pass to:
!	Describe the fields
!	Process the altseq line
!	Describe conditions
!
! Make a third pass to:
!	Describe omits/includes and keys
!
!-
    LINE_SEQ = FALSE;
    EBCDIC = FALSE;
    PROCESS = %C'R';
    LINE_NUM = -1;

    PASS = 0;
    WHILE TRUE DO
	BEGIN

	PASS = .PASS + 1;

	SELECTONE .PASS OF
	    SET
	    [1]:BEGIN
		PUT_TEXT(LENADR_('!++'));
		PUT_LINE();
		END;
	    [2]:BEGIN
		PUT_TEXT(LENADR_('!--'));
		PUT_LINE();
		SELECTONE .PROCESS OF
		    SET
		    ['R']:	PUT_TEXT(LENADR_('/',X_PROC,'=',X_RECD));
		    ['T']:	PUT_TEXT(LENADR_('/',X_PROC,'=',X_TAG));
		    ['A']:	PUT_TEXT(LENADR_('/',X_PROC,'=',X_ADDR));
		    ['I']:	PUT_TEXT(LENADR_('/',X_PROC,'=',X_INDX));
		    [OTHERWISE]:	0;
		    TES;
		IF .EBCDIC
		THEN
		    PUT_TEXT(LENADR_('/',X_COLL,'=(',X_SEQU,':',X_EBC,')'));

		! Define all fields that will be needed
		! Then actually issue text to describe them.
		! Also, describe subfields that are used in key specifications.
		!
		DEF_SUBFIELDS();
		DEF_FIELDS(.FLD_ROOT);
		END;
	    [3]:BEGIN
		0;
		END;
	    TES;

	! Initialize the current record format
	!
	FMT_CURR = FMT_ROOT - %FIELDEXPAND(FMT_NEXT,0);

	! Start counting conditions from zero
	!
	COND_NUM = 0;

	! Get a line.  Check for a header record, and an altseq record
	!
	GET_LINE();
	IF .LINE_TYPE EQL HEADER_LINE THEN DO_HEADER();
	IF .LINE_TYPE EQL ALTSEQ_LINE THEN DO_ALTSEQ();

	! Get the rest of the records
	!
	WHILE .LINE_TYPE NEQ 0 DO DO_RECORD();

	! Exit the loop if this was the last pass
	!
	IF .PASS EQL 3 THEN EXITLOOP;

	! Switch to the temporary file, if needed
	!
	IF .TMP_FAB[FAB$W_IFI] NEQ 0 THEN CUR_RAB = TMP_RAB[BASE_];
	CUR_RAB[RAB$L_CTX] = SRTTRN$_READERR;
	$REWIND( RAB=CUR_RAB[BASE_], ERR=REPORT_IO_ERROR );
	END;


    ! Flush the output, and close the files
    !
    PUT_LINE();
    CLOSE_FILES();

    ! Exit with status
    !
    %IF %BLISS(BLISS16)
    %THEN
	EXST$S( .SOR_STS );
    %FI
    RETURN .SOR_STS;
    END;

ROUTINE GETFILENAME (FAB: REF $FAB_DECL) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine returns a string descriptor for a file.
!
! INPUTS:
!
!	FAB	Address of FAB
!
! OUTPUTS:
!
!	Address of string descriptor for file name
!
!--
    BEGIN
    LOCAL
	NAM: REF $NAM_DECL;

    OWN
	DESC:	VECTOR[2];

    NAM = .FAB[FAB$L_NAM];
    IF NAM[BASE_] NEQ 0
    THEN
	BEGIN
	IF   (DESC[0] = .NAM[NAM$B_RSL]) NEQ 0 THEN DESC[1] = .NAM[NAM$L_RSA]
	ELIF (DESC[0] = .NAM[NAM$B_ESL]) NEQ 0 THEN DESC[1] = .NAM[NAM$L_ESA]
	ELSE
	    BEGIN
	    DESC[0] = .FAB[FAB$B_FNS];
	    DESC[1] = .FAB[FAB$L_FNA];
	    END;
	END
    ELSE
	BEGIN
	DESC[0] = .FAB[FAB$B_FNS];
	DESC[1] = .FAB[FAB$L_FNA];
	END;

    RETURN DESC[0];
    END;

ROUTINE REPORT_IO_ERROR (FRAB: REF BLOCK[,BYTE]): CALL =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine signals an I/O error.
!
! INPUTS:
!
!	FRAB	The FAB or the RAB which got the error
!		The $L_CTX field of the FAB/RAB must contain the
!		error code to signal
!		 (SHR$_OPENIN/OPENOUT/READERR/WRITEERR/CLOSEIN/CLOSEOUT)
!		If FRAB is a RAB, then RAB$L_FAB must point to the FAB
!		In either case, the FAB must point to a valid NAM block
!		with both the expanded and resultant name strings in
!		order for consistent error reporting.
!
! OUTPUTS:
!
!	The error is signalled.  RMS$_EOF is not signalled
!
! ROUTINE VALUE:
!
!	The $L_STS field of FRAB is returned
!
!--
    BEGIN
    IF .FRAB[RAB$L_STS] NEQ RMS$_EOF
    THEN
	SIGNAL(.FRAB[FAB$L_CTX], 1,
	    GETFILENAME((IF .FRAB[FAB$B_BID] EQL FAB$C_BID
		THEN FRAB[BASE_] ELSE .FRAB[RAB$L_FAB])),
	    .FRAB[FAB$L_STS], .FRAB[FAB$L_STV]);

    RETURN .FRAB[FAB$L_STS];
    END;

ROUTINE GET_QUAL(
	DESC:	REF VECTOR[2]
	):	NOVALUE =
    BEGIN
    MACRO
	IS_QUAL(X) = (IF .D[0] LSS %CHARCOUNT(X) THEN FALSE ELSE
	    CH$EQL(%CHARCOUNT(X), UPLIT BYTE(X), %CHARCOUNT(X), .D[1])) %,
	LOCC(X) = (LOCAL T; T = CH$FIND_CH(.D[0], .D[1], X);
	    IF CH$FAIL(.T) THEN T = CH$PLUS(.D[1], .D[0]); .T) %;
    LOCAL
	D:	REF VECTOR[2],
	PTR;

    ! Get a local pointer to the descriptor
    !
    D = DESC[0];

    IF   IS_QUAL('/S32') THEN SWITCH_S32 = TRUE
    ELIF IS_QUAL('/S11') THEN SWITCH_S32 = FALSE
    ELSE
	RETURN SOR_ERROR(SRTTRN$_INV_QUAL);

    ! Advance past this qualifier
    !
    IF (D[0] = .D[0] - 1) EQL 0 THEN RETURN;
    D[1] = .D[1] + 1;
    PTR = MINA( LOCC(%C'/'), LOCC(%C' ') );
    D[0] = .D[0] - CH$DIFF(.PTR, .D[1]);
    D[1] = .PTR;
    END;

ROUTINE GET_FILE_SPEC(
	DESC:	REF VECTOR[2],
	FNA:	REF VECTOR[1],
	FNS:	REF VECTOR[1,BYTE]
	):	NOVALUE =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Extract one file name string from DESC, storing the address and length
!	in FNA and FNS respectively, and updating DESC.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
    BEGIN
    LOCAL
	PTR;

    ! Find the beginning of the file name string
    !
    WHILE TRUE DO
	BEGIN
	PTR = CH$FIND_NOT_CH(.DESC[0], .DESC[1], %C' ');
	IF CH$FAIL(.PTR) THEN PTR = CH$PLUS(.DESC[1], .DESC[0]);
	DESC[0] = CH$DIFF(CH$PLUS(.DESC[1], .DESC[0]), .PTR);
	DESC[1] = .PTR;
	IF .DESC[0] EQL 0 THEN EXITLOOP;
	IF CH$RCHAR(.DESC[1]) NEQ %C'/' THEN EXITLOOP;
	GET_QUAL(DESC[0]);
	END;

    ! Store the file name string's address
    !
    FNA[0] = .PTR;

    ! Check for an equal sign
    !
    IF CH$RCHAR(.PTR) EQL %C'='
    THEN
	BEGIN
	DESC[0] = .DESC[0] - 1;
	DESC[1] = .DESC[1] + 1;
	FNS[0] = CH$DIFF(.DESC[1], .FNA[0]);
	RETURN;
	END;

    ! Find the next space (or equal sign) that is not enclosed in quotes.
    !
    WHILE TRUE DO
	BEGIN
	LOCAL
	    QUO;
	PTR = CH$FIND_CH(.DESC[0], .DESC[1], %C' ');
	IF CH$FAIL(.PTR) THEN PTR = CH$PLUS(.DESC[1], .DESC[0]);

	QUO = CH$FIND_CH(CH$DIFF(.PTR,.DESC[1]), .DESC[1], %C'=');
	IF NOT CH$FAIL(.QUO) THEN IF .QUO LSSA .PTR THEN PTR = .QUO;

	QUO = CH$FIND_CH(CH$DIFF(.PTR,.DESC[1]), .DESC[1], %C'"');
	DESC[0] = CH$DIFF(CH$PLUS(.DESC[1], .DESC[0]), .PTR);
	DESC[1] = .PTR;
	IF CH$FAIL(.QUO) THEN EXITLOOP;
	PTR = CH$FIND_CH(.DESC[0], .DESC[1], %C'"');
	IF CH$FAIL(.PTR) THEN EXITLOOP;
	DESC[0] = CH$DIFF(CH$PLUS(.DESC[1], .DESC[0]), .PTR);
	DESC[1] = .PTR;
	END;

    ! Store the file name string's length
    !
    FNS[0] = CH$DIFF(.DESC[1], .FNA[0]);

    END;

ROUTINE GET_FOREIGN(
	DESC:	REF VECTOR[2]
	): NOVALUE =
    BEGIN
    %IF %BLISS(BLISS32) %THEN
    MACRO
	PROMPT = 'SRTTRN> ' %;
    %ELSE
    MACRO
	PROMPT = 'TRN> ' %;
    %FI

    LOCAL
	STATUS;

    %IF %BLISS(BLISS32) !AND K_NATIVE
    %THEN
	BEGIN
	EXTERNAL ROUTINE LIB$GET_FOREIGN;
	STATUS = LIB$GET_FOREIGN(DESC[0]);
	IF NOT .STATUS THEN SIGNAL(.STATUS);
	END
    %ELSE
	BEGIN
	LITERAL
	    K_VICS = FALSE;

	%IF K_VICS
	%THEN
	    EXTERNAL ROUTINE $TRNGC;
	    STATUS = $TRNGC(DESC[0]);
	%ELSE
	    LIBRARY 'SYS$LIBRARY:FCS11';
	    FSRSZ$(1);
	    GCMLB$( GCMLB, 1, 'trn' );
	    EXTERNAL $DSW;			! Directive status word
	    LOCAL STATUS;
	    ALUN$S( LUN_K_MSG, 'TI', 0 );
	    IF .$DSW NEQ IS_SUC THEN RETURN;
	    DO
		BEGIN
		GCML$( GCMLB, UPLIT BYTE(%X'0A',PROMPT), %CHARCOUNT(PROMPT) );
	    	STATUS = .GCMLB[G_ERR];
		DESC[0] = .GCMLB[G_CMLD_L];
		DESC[1] = .GCMLB[G_CMLD_A];
		IF .STATUS EQL GE_EOF
		THEN
		    EXST$S( EX$SUC );
		END
	    WHILE .DESC[ 0 ] EQL 0;
	%FI

	IF .STATUS NEQ 0 THEN SIGNAL(SRTTRN$_NO_COMMAND,0,.STATUS);
	END
    %FI;
    END;

ROUTINE INIT_IO: NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Initialization routine.
!	Translates foreign command line, opens input and output files.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--
    BEGIN
    %IF %BLISS(BLISS32) %THEN LOCAL %ELSE OWN %FI
	COM_BUF: 	VECTOR[256,BYTE];	! Holds foreign command line
    LOCAL
	OPT_DESC:	VECTOR[2],		! Command line desc
	DUMMY_L,
	DUMMY_B:	BYTE,
	STATUS;

    OPT_DESC[0] = %ALLOCATION(COM_BUF);
    OPT_DESC[1] = COM_BUF[0];

    ! Get command line options if any
    !
    GET_FOREIGN(OPT_DESC[0]);

    %IF %BLISS(BLISS32) AND K_NATIVE
    %THEN
	BEGIN
	!
	! SRTTRN inp-file out-file
	! SRTTRN inp-file
	! SRTTRN
	!
	GET_FILE_SPEC(OPT_DESC, INP_FAB[FAB$L_FNA], INP_FAB[FAB$B_FNS]);
	GET_FILE_SPEC(OPT_DESC, OUT_FAB[FAB$L_FNA], OUT_FAB[FAB$B_FNS]);
	GET_FILE_SPEC(OPT_DESC, DUMMY_L, DUMMY_B);
	IF .DUMMY_B NEQ 0 THEN SOR_ERROR(SRTTRN$_INV_QUAL);
	END
    %ELSE
	BEGIN
	!
	! SRTTRN out-file = inp-file
	! SRTTRN = inp-file
	!
	GET_FILE_SPEC(OPT_DESC, OUT_FAB[FAB$L_FNA], OUT_FAB[FAB$B_FNS]);
	IF CH$EQL(.OUT_FAB[FAB$B_FNS], .OUT_FAB[FAB$L_FNA], LENADR_('='))
	THEN
	    OUT_FAB[FAB$B_FNS] = 0
	ELSE
	    BEGIN
	    GET_FILE_SPEC(OPT_DESC, DUMMY_L, DUMMY_B);
	    IF CH$NEQ(.DUMMY_B, .DUMMY_L, LENADR_('='))
	    THEN
		SOR_ERROR(SRTTRN$_INV_QUAL);
	    END;
	GET_FILE_SPEC(OPT_DESC, INP_FAB[FAB$L_FNA], INP_FAB[FAB$B_FNS]);
	GET_FILE_SPEC(OPT_DESC, DUMMY_L, DUMMY_B);
	IF .DUMMY_B NEQ 0 THEN SOR_ERROR(SRTTRN$_INV_QUAL);
	END
    %FI;

    ! Initialize RMS
    !
    %IF %BLISS(BLISS16)
    %THEN
	$RMS_INITIF();
	INP_FAB[FAB$B_LCH] = LUN_K_INP;
	OUT_FAB[FAB$B_LCH] = LUN_K_OUT;
	TMP_FAB[FAB$B_LCH] = LUN_K_TMP;
    %FI

    ! Default the file names as needed
    !
    IF .INP_FAB[FAB$B_FNS] EQL 0
    THEN
	BEGIN
	INP_FAB[FAB$L_FNA] = UPLIT BYTE('SYS$INPUT');
	INP_FAB[FAB$B_FNS] = %CHARCOUNT('SYS$INPUT');
	IF .OUT_FAB[FAB$B_FNS] EQL 0
	THEN
	    BEGIN
	    OUT_FAB[FAB$L_FNA] = UPLIT BYTE('SYS$OUTPUT');
	    OUT_FAB[FAB$B_FNS] = %CHARCOUNT('SYS$OUTPUT');
	    END;
	END;

    ! There is no default extension for /S32
    !
    IF .SWITCH_S32
    THEN
	BEGIN
	SOR_ERROR(SRTTRN$_LINE_NUM);	! ????
        INP_FAB[FAB$L_DNA] = 0;
	INP_FAB[FAB$B_DNS] = 0;
	END;

    ! Open input file
    !
    INP_FAB[FAB$L_CTX] = SRTTRN$_OPENIN;
    INP_RAB[RAB$L_CTX] = SRTTRN$_OPENIN;
    $OPEN(    FAB=INP_FAB[BASE_], ERR=REPORT_IO_ERROR );
    $CONNECT( RAB=INP_RAB[BASE_], ERR=REPORT_IO_ERROR );
    CUR_RAB = INP_RAB[BASE_];

    ! If the input file is not on a local file-oriented device,
    ! we want to make a copy of the file.
    !
    IF
	%IF %BLISS(BLISS32)
	%THEN
	    NOT .BLOCK[INP_FAB[FAB$L_DEV], DEV$V_FOD] OR
		.BLOCK[INP_FAB[FAB$L_DEV], DEV$V_NET]
	%ELSE
	    NOT .INP_FAB[FAB$V_MDI] AND		! Not MULTI-DIRECTORY
	    NOT .INP_FAB[FAB$V_SDI] AND		! Not SINGLE DIRECTORY
	    NOT .INP_FAB[FAB$V_SQD]		! Not SEQUENTIAL DEVICE
	%FI
    THEN
	BEGIN
	TMP_FAB[FAB$L_CTX] = SRTTRN$_OPENOUT;
	TMP_RAB[RAB$L_CTX] = SRTTRN$_OPENOUT;
	$CREATE(  FAB=TMP_FAB[BASE_], ERR=REPORT_IO_ERROR );
	$CONNECT( RAB=TMP_RAB[BASE_], ERR=REPORT_IO_ERROR );
	END;

    ! Open output file
    !
    OUT_FAB[FAB$L_CTX] = SRTTRN$_OPENOUT;
    OUT_RAB[RAB$L_CTX] = SRTTRN$_OPENOUT;
    $CREATE(  FAB=OUT_FAB[BASE_], ERR=REPORT_IO_ERROR );
    $CONNECT( RAB=OUT_RAB[BASE_], ERR=REPORT_IO_ERROR );

    ! Issue lines indicating the translation
    !
    BEGIN
    LOCAL Z: REF VECTOR[2];
    PUT_TEXT(LENADR_('!++'));
    PUT_LINE();
    PUT_TEXT(LENADR_('! SRTTRN'));
    PUT_LINE();
    Z = GETFILENAME(INP_FAB[BASE_]);
    PUT_TEXT(LENADR_('!',%CHAR(9)), .Z[0], .Z[1]);
    PUT_LINE();
    Z = GETFILENAME(OUT_FAB[BASE_]);
    PUT_TEXT(LENADR_('!',%CHAR(9)), .Z[0], .Z[1]);
    PUT_LINE();
    END;

    END;

ROUTINE DO_HEADER: NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Get the header record information.
!	This includes /process, /nostrip, /collating_sequence,
!	and normal sequence (ascending or descending) info.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	Status code.
!
! SIDE EFFECTS:
!
!	NONE
!
!--
    BEGIN

    IF .PASS EQL 1
    THEN
	BEGIN
	LOCAL
	    PTR;

	! Convert to upper case
	!
	UPCASE(.INP_REC_SIZ, INP_BUF);

	! Determine if "normal" is ascending or descending
	!
	SELECTONE .INP_BUF[17] OF
	    SET
	    [' ', 'A']:		ASCENDING = TRUE;
	    ['D']:		ASCENDING = FALSE;
	    [OTHERWISE]:	SOR_ERROR(SRTTRN$_INV_SEQ);
	    TES;

	! Get key stripping information
	!
	SELECTONE .INP_BUF[27] OF
	    SET
	    [' ']:		NOSTRIP = TRUE;
	    ['X']:		NOSTRIP = FALSE;
	    [OTHERWISE]:	SOR_ERROR(SRTTRN$_INV_STRIP);
	    TES;

	IF CH$NEQ(LENADR_('SORT'), 4, INP_BUF[6], %C' ')
	THEN
	    PROCESS = %C' '
	ELSE
	    PROCESS = CH$RCHAR(INP_BUF[6+4]);

	SELECTONE .INP_BUF[6+4] OF
	    SET
	    ['R','T','A','I']:	0;
	    [OTHERWISE]:	SOR_ERROR(SRTTRN$_INV_PROCESS);
	    TES;

	SELECTONE .INP_BUF[25] OF
	    SET
	    [' ']:		0;		! This is the default
	    ['E']:		EBCDIC = TRUE;
	    ['X']:		ALTSEQ = TRUE;
	    [OTHERWISE]:	SOR_ERROR(SRTTRN$_INV_ALT);
	    TES;

	IF NOT CVT_DTB(4, INP_BUF[28], OUTLRL) THEN OUTLRL = %X'FFFF';
	END;

    GET_LINE();
 
    END;

ROUTINE CVT_OTB(X: REF VECTOR[,BYTE]) =
    BEGIN
    LOCAL
	PTR, RES, NUM;
    PTR = X[0];
    RES = 0;
    DECR I FROM 2 TO 0 DO
	BEGIN
	NUM = CH$RCHAR_A(PTR) - %C'0';
	IF .NUM GEQU 8
	THEN
	    BEGIN
	    SOR_ERROR(SRTTRN$_INV_ALT);
	    RETURN 0;
	    END;
	RES = .RES * 8 + .NUM;
	END;
    RETURN .RES<0,8,0>;		! Just use 8 bits
    END;

ROUTINE CVT_BTO(X) =
    BEGIN
    OWN
	O: VECTOR[4,BYTE];
    LOCAL
	Y;

    Y = .X;
    O[2] = .Y MOD 8 OR %C'0';	Y = .Y / 8;
    O[1] = .Y MOD 8 OR %C'0';	Y = .Y / 8;
    O[0] = .Y MOD 8 OR %C'0';

    RETURN O[0];
    
    END;

ROUTINE DO_ALTSEQ: NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Translates an alternate collating sequence line.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	0 or 1
!
! SIDE EFFECTS:
!
!	NONE
!
! NOTES:
!
!	There is a basic difference between how collating values are specified
!	in the old format spec file and the new format.  In the old format,
!	oct1 = oct2 means that:
!		character oct1 is given the collating value oct2,
!	while in the new format, oct1 = oct2 means:
!		character oct1 is given the collating value of character oct2.
!
!	In order to translate this, we maintain a table representing the old
!	collating sequence table.  When we make a modification, we search for
!	a character that has that collating value (or is close), and make the
!	appropriate modification.
!--
    BEGIN
    LOCAL
	SEQ:	VECTOR[256, BYTE],
	PTR,
	FIRST,
	PAIR_PTR:	REF VECTOR[,BYTE];
    MACRO
	STR_FIRST =
	    %STRING('/',X_COLL,'=(',X_SEQU,':',X_ASC,', ',X_MODF,':( ') %;

    IF .PASS NEQ 2
    THEN
	BEGIN
	DO GET_LINE() UNTIL .LINE_TYPE NEQ ALTSEQ_LINE;
	RETURN;
	END;

    ! Initialize the collating sequence table
    !
    DECR I FROM 255 TO 0 DO SEQ[.I] = .I;

    ! Check that user defined sequence has been requested
    !
    IF NOT .ALTSEQ
    THEN
	SOR_ERROR(SRTTRN$_UNX_ALTSEQ);

    ! Indicate that we haven't written any text yet
    !
    FIRST = TRUE;

    ! While there are altseq lines
    !
    WHILE TRUE DO
	BEGIN

	! Look for max of groups of 6 octal digits
	!
	INCRA PAIR_PTR FROM INP_BUF[8] TO INP_BUF[74] BY 6 DO
	    BEGIN
	    MAP
		PAIR_PTR: REF VECTOR[,BYTE];
	    LOCAL
		CH1, CH2,
		IX:	REF VECTOR[,BYTE];

	    ! Should not be any blanks in next 6 columns
	    !
	    IF NOT CH$FAIL(CH$FIND_CH(6, .PAIR_PTR, %C' ')) THEN EXITLOOP;
		
	    ! Fetch the two numbers
	    !
	    CH1 = CVT_OTB(PAIR_PTR[0]);
	    CH2 = CVT_OTB(PAIR_PTR[3]);

	    ! Find a character that has nearly the same collating value
	    !
	    DECR I FROM .CH2 TO 0 DO
		BEGIN
		IX = CH$FIND_CH( 256, SEQ[0], .I );
		IF NOT CH$FAIL(.IX) THEN EXITLOOP;
		END;
	    IF CH$FAIL(.IX) THEN
	    INCR I FROM .CH2+1 TO 255 DO
		BEGIN
		IX = CH$FIND_CH( 256, SEQ[0], .I );
		IF NOT CH$FAIL(.IX) THEN EXITLOOP;
		END;

	    IF .FIRST
		THEN PUT_TEXT(LENADR_(STR_FIRST))
		ELSE PUT_TEXT(LENADR_(', '));
	    FIRST = FALSE;
	    PUT_TEXT(LENADR_('%O'),
		3, PAIR_PTR[0],
		%CHARCOUNT(' ? %O'), (SELECTONE SIGN(.CH2 - CH$RCHAR(.IX)) OF
		    SET
		    [-1]: UPLIT BYTE(' < %O');
		    [ 0]: UPLIT BYTE(' = %O');
		    [+1]: UPLIT BYTE(' > %O');
		    TES),
		3, CVT_BTO(CH$DIFF(.IX, SEQ[0])));

	    ! Update the collating sequence table
	    !
	    SEQ[.CH1] = .CH2;
	    END;

	! Look for next altseq
	!
	GET_LINE();

	IF .LINE_TYPE NEQ ALTSEQ_LINE THEN EXITLOOP;

	END;
	
    ! Add end parentheses; through processing the altseq
    !
    IF .FIRST
	THEN PUT_TEXT(LENADR_(')'))
	ELSE PUT_TEXT(LENADR_('))'));

    END;

ROUTINE PUT_NEST(NESTED): NOVALUE =
    BEGIN
    IF .NESTED
    THEN
	BEGIN
	PUT_TEXT(LENADR_(','));
	PUT_LINE(1);
	END
    ELSE
	PUT_TEXT(LENADR_('/'));
    END;

ROUTINE CHECK_LENGTH(NAM: REF FLD_BLOCK): NOVALUE =
    BEGIN
    LOCAL
	SIZ;

    SIZ = .NAM[FLD_SIZ];

    !<s1>
    SELECTONE .NAM[FLD_DTY] OF
	SET
	[DSC$K_DTYPE_NL,
	 DSC$K_DTYPE_NR]:	SIZ = .SIZ + 1;
	[DSC$K_DTYPE_P]:	SIZ = .SIZ / 2 + 1;
	[OTHERWISE]:	0;
	TES;

    FMT_CURR[FMT_OUTLRL] = .FMT_CURR[FMT_OUTLRL] + .SIZ;
    IF .FMT_CURR[FMT_OUTLRL] GTRU .OUTLRL
    THEN
	BEGIN
        SOR_ERROR(SRTTRN$_DATALONG);
	FMT_CURR[FMT_OUTLRL] = 0;
	END;

    END;

ROUTINE DO_FIELD(NESTED): NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Does all the field lines in specification file which
!	does not have an include or omit line.
!
! FORMAL PARAMETERS:
!
!	NESTED	True to indicate that the field definition is nested
!		within an omit/include.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	0 or 1
!
! SIDE EFFECTS:
!
!	NONE
!--
    BEGIN
    LOCAL
	LEN;

    ! Look for all fields
    !
    WHILE .LINE_TYPE EQL FIELD_LINE DO
	BEGIN

	! Convert the first 8 character position to upper case
	!
	UPCASE(8, INP_BUF);

	! Force, key, or data field
	!
	SELECTONE .INP_BUF[6] OF
	    SET
	    ['F']:	! Force field
		BEGIN
%if k_new
%then
		LOCAL
		    FFLD: REF FFLD_BLOCK;

		IF .PASS EQL 1
		THEN
		    BEGIN
		    !
		    ! Create a KEY_BLOCK for this force field
		    !
		    LOCAL FLD: REF FLD_BLOCK;
		    GET_VM(FLD_K_SIZE, FLD);
		    FLD[FLD_POS] = -1;
		    FLD[FLD_SIZ] = 1;
		    FLD[FLD_DTY] = DSC$K_DTYPE_BU;
		    BBLOCK[ NEW_KEY(FLD[BASE_]), KEY_ASCE ] = .ASCENDING;
		    FFLD = FLD[FLD_FFLD] - %FIELDEXPAND(FFLD_NEXT,0);
		    END;
%else
%fi
		IF .INP_BUF[18] NEQ %C' '
		THEN
		    IF .PASS EQL 3 THEN SOR_ERROR(SRTTRN$_UNX_FORCE);

		! Unconditional?
		!
		IF .INP_BUF[16] EQL %C' '
		THEN
		    BEGIN
%if k_new
%then
		    IF .PASS EQL 1
		    THEN
			FFLD = FFLD[FFLD_NEXT] = GET_FFLD(.INP_BUF[17],0);
%else
		    IF .PASS EQL 3
		    THEN
			BEGIN
			PUT_NEST(.NESTED);
			PUT_TEXT(LENADR_(X_KEY,'=%O'),
			    3, CVT_BTO(.INP_BUF[17]));
			END;
%fi
		    GET_LINE();
		    END
		ELSE
		    BEGIN
		    !
		    ! Lots of fun.
		    ! We have a conditional force field.
		    ! On the first pass:
		    !	Define the field.
		    ! On the second pass:
		    !	Describe the condition(s).
		    ! On the third pass:
		    !	Describe the field.
		    !
%if k_new
%then
%else
		    IF .PASS EQL 3
		    THEN
			BEGIN
			PUT_NEST(.NESTED);
			PUT_TEXT( LENADR_(X_KEY,'=(',%CHAR(9)) );
			END;
%fi
		    WHILE TRUE DO
			BEGIN
			LOCAL NAM, POS;

			IF NOT CVT_DTB(4, INP_BUF[12], POS)
			THEN
			    IF .PASS EQL 2
			    THEN
				SOR_ERROR(SRTTRN$_NO_FORCE_TO);

			NAM = TREE_INSERT(.POS, 1, DSC$K_DTYPE_BU);
			SELECTONE .PASS OF
			    SET
%if k_new
%then
			    [1]:
				BEGIN
				FFLD = FFLD[FFLD_NEXT] = GET_FFLD(.INP_BUF[17],
					COND_NUM = .COND_NUM+1);
				END;
%else
			    [1]: 0;
%fi
			    [2]:
				BEGIN
				PUT_TEXT(
				    LENADR_('/',X_COND,'=(NAME:COND_'),
				    3, CVT_BTO(COND_NUM = .COND_NUM + 1),
				    LENADR_(', ',X_TEST,':('));
				PUT_NAME(.NAM);
				PUT_TEXT(
				    LENADR_(' EQ %O'),
				    3, CVT_BTO(.INP_BUF[16]),
				    LENADR_('))'));
				END;
%if k_new
%then
			    [3]: 0;
%else
			    [3]:
				BEGIN
				!
				! Note that we can't use CVT_BTO twice here
				!
				PUT_TEXT(
				    LENADR_(X_IF,' COND_'),
				    3, CVT_BTO(COND_NUM = .COND_NUM + 1));
				PUT_TEXT(
				    LENADR_(' ',X_THEN,' %O'),
				    3, CVT_BTO(.INP_BUF[17]),
				    LENADR_(' ',X_ELSE));
				PUT_LINE(.NESTED+1);
				END;
%fi
			    TES;

			GET_LINE();

			UPCASE(8, INP_BUF);

			! Is next line a continuation of force key?
			!
			IF  .LINE_TYPE EQL FIELD_LINE AND
			    .INP_BUF[6] EQL %C'F' AND
			    .INP_BUF[18] NEQ %C' '
			THEN
			    IF .INP_BUF[16] EQL %C' '
			    THEN NAM = .INP_BUF[17]
			    ELSE NAM = -1
			ELSE
			    IF .ASCENDING
			    THEN NAM = %X'FF'
			    ELSE NAM = %X'00';

			IF .NAM GEQ 0
			THEN
			    BEGIN
%if k_new
%then
			    IF .PASS EQL 1
			    THEN
				FFLD = FFLD[FFLD_NEXT] = GET_FFLD(.NAM, 0);
%else
			    IF .PASS EQL 3
			    THEN
				PUT_TEXT(
				    LENADR_(' %O'),
				    3, CVT_BTO(.NAM));
%fi
			    EXITLOOP;
			    END;

			END;
		    END;

%if k_new
%then
%else
		IF .PASS EQL 3 THEN PUT_TEXT(LENADR_(')'));
%fi
		END;

	    ['D']:	! Data field
		BEGIN
		LOCAL NAM;
		NAM = GET_DEFN(8);
		IF .PASS EQL 3
		THEN
		    BEGIN
		    PUT_NEST(.NESTED);
		    PUT_TEXT(LENADR_(X_DATA,'='));
		    PUT_NAME(.NAM);
		    CHECK_LENGTH(.NAM);
		    END;
		GET_LINE();
		END;


	    ! Note that the keys (except for user-specified forces)
	    ! are not written by this routine.
	    !
	    ['N']:
		BEGIN
		IF .PASS EQL 1
		THEN
		    BBLOCK[ NEW_KEY(GET_DEFN(8)), KEY_ASCE ] = .ASCENDING;
		GET_LINE();
		END;
	    ['O']:
		BEGIN
		IF .PASS EQL 1
		THEN
		    BBLOCK[ NEW_KEY(GET_DEFN(8)), KEY_ASCE ] = NOT .ASCENDING;
		GET_LINE();
		END;

	    [OTHERWISE]:
		BEGIN
		IF .PASS EQL 1
		THEN
		    SOR_ERROR(SRTTRN$_INV_FIELD);
		GET_LINE();
		END;

	    TES;

	END;

    RETURN;

    END;

ROUTINE DO_RECORD: NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Process one record type corresponding to an include or an omit line.
!	Finds all fields associated with that include or omit.
!
!	In pass 1, define the fields that will be needed.
!	In pass 2, describe the condition.
!	In pass 3, describe the omit/include.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	0 or 1
!
! SIDE EFFECTS:
!
!	NONE
!--
    BEGIN
    LOCAL
	LEN,
	UNCOND,
	NESTED;

    NESTED = FALSE;
    UNCOND = FALSE;

    ! Define a new record format
    !
    FMT_CURR = .FMT_CURR[FMT_NEXT];
    IF FMT_CURR[BASE_] EQL 0 THEN FMT_CURR = NEW_FMT();

    IF .LINE_TYPE EQL RECORD_LINE
    THEN
	BEGIN

	IF CH$EQL(39-6, INP_BUF[6], 0, INP_BUF[6], %C' ')
	THEN
	    UNCOND = TRUE
	ELSE
	    NESTED = TRUE;

	SELECTONE .PASS OF
	    SET
	    [1]:BEGIN
		0;
		END;
	    [2]:BEGIN
		IF NOT .UNCOND
		THEN
		    BEGIN
		    PUT_TEXT(
			LENADR_('/',X_COND,'=(NAME:COND_'),
			3, CVT_BTO(COND_NUM = .COND_NUM + 1),
			LENADR_(', ',X_TEST,':'));
		    DECR I FROM .FMT_CURR[FMT_COND]-1 TO 0 DO
			PUT_TEXT(LENADR_('('));
		    END;
		END;
	    [3]:BEGIN
		IF .INP_BUF[5] EQL %C'O'
		    THEN PUT_TEXT(LENADR_('/',X_OMIT))
		    ELSE PUT_TEXT(LENADR_('/',X_INCL));
		IF NOT .UNCOND
		THEN
		    PUT_TEXT(
			LENADR_('=(',X_COND,':COND_'),
			3, CVT_BTO(COND_NUM = .COND_NUM + 1));
		END;
	    TES;
	END;

    ! While record is continued
    !
    WHILE .LINE_TYPE EQL RECORD_LINE DO
	BEGIN
	LOCAL
	    NAM;

	! Don't process the conditions for unconditional omits/includes.
	!
	IF .UNCOND
	THEN
	    BEGIN
	    GET_LINE();
	    EXITLOOP;
	    END;

	! Convert to upper case
	!
	UPCASE(.INP_REC_SIZ, INP_BUF);

	! Get the first field
	!
	NAM = GET_DEFN(8);
	IF .PASS EQL 2
	THEN
	    BEGIN
	    PUT_NAME(.NAM);		! Get the definition
	    PUT_TEXT(
		LENADR_(' '),
		2, INP_BUF[16],		! The operator
		LENADR_(' '));
	    END;

	! Is there a second field or constant?
	!
	SELECTONE .INP_BUF[18] OF
	    SET
	    ['F']:
		BEGIN
		NAM = GET_DEFN(19);
		IF .PASS EQL 2 THEN PUT_NAME(.NAM);
		END;
	    ['C']:
		BEGIN
		IF .PASS EQL 2
		THEN
		    PUT_LITE(MINU(20, .INP_REC_SIZ-19), INP_BUF[19], .NAM);
		END;
	    [OTHERWISE]:
		BEGIN
		IF .PASS EQL 2
		THEN
		    SOR_ERROR(SRTTRN$_INV_CONST);
		END;
	    TES;

	SELECTONE .PASS OF
	    SET
	    [1]: FMT_CURR[FMT_COND] = .FMT_CURR[FMT_COND] + 1;
	    [2]: PUT_TEXT(LENADR_(')'));
	    [3]: 0;
	    TES;

	GET_LINE();

	IF .LINE_TYPE NEQ RECORD_LINE OR .INP_BUF[6] EQL %C' '
	THEN
	    EXITLOOP;			! It's not a continuation

	! Convert to upper case
	!
	UPCASE(.INP_REC_SIZ, INP_BUF);

	! Is it an "and" or an "or"
	!
	IF .PASS EQL 2
	THEN
	    BEGIN
	    SELECTONE .INP_BUF[6] OF
		SET
		['A']: PUT_TEXT(LENADR_(' ',X_AND,' '));
		['O']: PUT_TEXT(LENADR_(' ',X_OR,'  '));
		[OTHERWISE]:	SOR_ERROR(SRTTRN$_INV_CONT);
		TES;
	    END;

	END;


    ! Issue the keys for the current record format
    !
    IF .PASS EQL 3
    THEN
	BEGIN
	LOCAL
	    KEY: REF KEY_BLOCK;
	KEY = FMT_CURR[FMT_KEYS] - %FIELDEXPAND(KEY_NEXT,0);
	WHILE (KEY = .KEY[KEY_NEXT]) NEQ 0 DO
	    BEGIN
	    LOCAL
		FLD:	REF FLD_BLOCK,
		AD;
	    PUT_NEST(.NESTED);
	    PUT_TEXT(
		LENADR_(X_KEY,'=('));
	    FLD = .KEY[KEY_FLD];
	    IF FLD[BASE_] EQL 0
	    THEN
		BEGIN
		PUT_TEXT(
		    LENADR_('%O'),
		    3, CVT_BTO(.KEY[KEY_LIT]));
		AD = .ASCENDING;
		END
	    ELSE
		BEGIN
%if k_new
%then
		IF .FLD[FLD_FFLD] NEQ 0
		THEN
		    PUT_FFLD(FLD[BASE_], .NESTED)
		ELSE
%else
%fi
		    PUT_NAME(FLD[BASE_]);
		AD = .KEY[KEY_ASCE];
		END;
	    IF .AD
		THEN PUT_TEXT(LENADR_(',',%CHAR(9),X_ASCE,')'))
		ELSE PUT_TEXT(LENADR_(',',%CHAR(9),X_DESC,')'));

	    ! If keys are not being stripped, also issue this as a data field.
	    !
	    IF FLD[BASE_] NEQ 0
	    THEN
		BEGIN
		IF .NOSTRIP
		THEN
		    BEGIN
		    PUT_NEST(.NESTED);
		    PUT_TEXT(LENADR_(X_DATA,'='));
%if k_new
%then
		    IF .FLD[FLD_FFLD] NEQ 0
		    THEN
			BEGIN
			PUT_TEXT(LENADR_('('));
			PUT_FFLD(FLD[BASE_], .NESTED);
			PUT_TEXT(LENADR_(')'));
			END
		    ELSE
%else
%fi
			PUT_NAME(FLD[BASE_]);
		    CHECK_LENGTH(FLD[BASE_]);
		    END
		END
	    ELSE
		BEGIN
		IF NOT .ADDINCKEY THEN SOR_ERROR(SRTTRN$_ADDINCKEY);
		ADDINCKEY = TRUE;
		END;
	    END;

	END;

    ! Now look for all fields defined for this record type
    !
    WHILE .LINE_TYPE EQL FIELD_LINE DO DO_FIELD(.NESTED);

    ! Close the omit, include or condition statement
    !
    IF .NESTED AND .PASS NEQ 1
    THEN
	PUT_TEXT(LENADR_(')'));

    END;

ROUTINE GET_VM(SIZ, ADR: REF VECTOR[1]): NOVALUE =
    BEGIN
    LOCAL
	STATUS;
    MACRO
	ROUND_(X) = (((X)+%UPVAL-1) AND NOT %UPVAL-1) %;
    ADR[0] = 0;
    %IF %BLISS(BLISS32) AND K_NATIVE
    %THEN
	BEGIN
	EXTERNAL ROUTINE LIB$GET_VM;
	STATUS = LIB$GET_VM(SIZ, ADR[0]);
	IF NOT .STATUS THEN RETURN SOR_ERROR(.STATUS);
	END
    %ELSE
	BEGIN
	EXTERNAL
	    MEM_0,
	    MEM_1;
	OWN
	    P:	INITIAL(MEM_0);
	ADR[0] = .P;
	P = .P + ROUND_(.SIZ);
	IF .P GEQA MEM_1 THEN RETURN SOR_ERROR(SRTTRN$_INSVIRMEM);
	END
    %FI;
    CH$FILL(0, .SIZ, .ADR[0]);
    END;

ROUTINE NEW_FMT =
    BEGIN
    LOCAL
	FMTADR:	REF VECTOR[1],
	FMT:	REF FMT_BLOCK;
    FMTADR = FMT_ROOT;
    WHILE (FMT = .FMTADR[0]) NEQ 0 DO FMTADR = FMT[FMT_NEXT];
    GET_VM(FMT_K_SIZE, FMTADR[0]);
    FMT = .FMTADR[0];
    RETURN FMT[BASE_];
    END;

ROUTINE NEW_KEY(FLD: REF FLD_BLOCK, FMTX: REF FMT_BLOCK): CALL =
    BEGIN
    !
    ! Insert FLD in the key list for the current format, just before the
    ! current key definition.  Leave the current key alone, and return the
    ! address of the new key definition.
    !
    BUILTIN
	NULLPARAMETER;
    LOCAL
	KEYADR:	REF VECTOR[1],
	KEY:	REF KEY_BLOCK,
	FMT:	REF FMT_BLOCK;
    IF NOT NULLPARAMETER(2)
	THEN FMT = FMTX[BASE_]
	ELSE FMT = FMT_CURR[BASE_];
    KEYADR = FMT[FMT_KEYS];
    WHILE (KEY = .KEYADR[0]) NEQ .FMT[FMT_CKEY] DO KEYADR = KEY[KEY_NEXT];
    GET_VM(KEY_K_SIZE, KEYADR[0]);
    BBLOCK[.KEYADR[0], KEY_NEXT] = KEY[BASE_];
    KEY = .KEYADR[0];
    KEY[KEY_FLD] = FLD[BASE_];
    RETURN KEY[BASE_];
    END;

ROUTINE TREE_INSERT(
	POS,
	SIZ,
	DTY) =
    BEGIN
    LOCAL
	PTRADR: REF VECTOR[1],
	PTR:	REF FLD_BLOCK;

    PTRADR = FLD_ROOT;
    WHILE (PTR = .PTRADR[0]) NEQ 0 DO
	BEGIN
	  IF .POS LSS .PTR[FLD_POS] THEN PTRADR = PTR[FLD_LSON]
	ELIF .POS GTR .PTR[FLD_POS] THEN PTRADR = PTR[FLD_RSON]
	ELIF .SIZ LSS .PTR[FLD_SIZ] THEN PTRADR = PTR[FLD_LSON]
	ELIF .SIZ GTR .PTR[FLD_SIZ] THEN PTRADR = PTR[FLD_RSON]
	ELIF .DTY LSS .PTR[FLD_DTY] THEN PTRADR = PTR[FLD_LSON]
	ELIF .DTY GTR .PTR[FLD_DTY] THEN PTRADR = PTR[FLD_RSON]
	ELSE
	    RETURN PTR[BASE_];
	END;

    GET_VM(FLD_K_SIZE, PTRADR[0]);
    PTR = .PTRADR[0];
    PTR[FLD_LSON] = 0;
    PTR[FLD_RSON] = 0;
    PTR[FLD_POS] = .POS;
    PTR[FLD_SIZ] = .SIZ;
    PTR[FLD_DTY] = .DTY;

    RETURN PTR[BASE_];

    END;

ROUTINE MINCOMPAT(
	K1:	REF KEY_BLOCK,
	K2:	REF KEY_BLOCK,
	RESLEN:	REF VECTOR[1,WORD]) =
!++
!
! Test two key descriptions for compatibility.
!
! If the keys are compatible, return true, otherwise false.
! If the keys are compatible, store their compatibility length in reslen.
! This is used to split keys into several pieces, so that string keys will
! be compared with equal size (as the old spec file did it), instead of padding
! (as the new spec file will do it).
!
! If (sometime) it's decided that keys of different datatypes are compatible
! (for example, packed and decimal), reslen should be expressed in terms of k2.
!
!--
    BEGIN
    LOCAL
	F1:	REF FLD_BLOCK,
	F2:	REF FLD_BLOCK;
    IF .K1[KEY_ASCE] NEQ .K2[KEY_ASCE] THEN RETURN FALSE;
    F1 = .K1[KEY_FLD];		! ??? Might this be zero?
    F2 = .K2[KEY_FLD];		! ??? Might this be zero?
    IF .F1[FLD_DTY] NEQ .F2[FLD_DTY] THEN RETURN FALSE;
    SELECTONE .F1[FLD_DTY] OF
	SET
	[DSC$K_DTYPE_T]: 0;
	[OTHERWISE]: IF .F1[FLD_SIZ] NEQ .F2[FLD_SIZ] THEN RETURN FALSE;
	TES;
    RESLEN[0] = MINU(.F1[FLD_SIZ], .F2[FLD_SIZ]);
    RETURN TRUE;
    END;

ROUTINE DEF_FIELDS(PTR: REF FLD_BLOCK): NOVALUE =
    BEGIN
    IF PTR[BASE_] EQL 0 THEN RETURN;
    DEF_FIELDS(.PTR[FLD_LSON]);
    PUT_DEFN(PTR[BASE_]);
    DEF_FIELDS(.PTR[FLD_RSON]);
    END;    

ROUTINE DEF_SUBFIELDS: NOVALUE =
    BEGIN
    !
    ! Define any subfields that may be required due to key incompatibilities
    ! in multiple record formats.
    !
    LOCAL
	FMT:	REF FMT_BLOCK;

    ! Initialize the current key being worked on for each format.
    !
    FMT = FMT_ROOT - %FIELDEXPAND(FMT_NEXT,0);
    WHILE (FMT = .FMT[FMT_NEXT]) NEQ 0 DO FMT[FMT_CKEY] = .FMT[FMT_KEYS];

    ! While there are more keys to be processed
    !
    WHILE TRUE DO
	BEGIN
	LOCAL
	    FLD:	REF FLD_BLOCK,
	    KEY:	REF KEY_BLOCK,
	    MINKEY:	KEY_BLOCK,
	    MINFLD:	FLD_BLOCK,
	    COMPAT;

	! Find a current key
	!
	FMT = FMT_ROOT - %FIELDEXPAND(FMT_NEXT,0);
	KEY = 0;
	WHILE (FMT = .FMT[FMT_NEXT]) NEQ 0 DO
	    IF (KEY = .FMT[FMT_CKEY]) NEQ 0 THEN EXITLOOP;

	! Exit loop if all keys have been processed
	!
	IF KEY[BASE_] EQL 0 THEN EXITLOOP;

	! Save this key
	!
	MINKEY[KEY_FLD] = MINFLD[BASE_];
	MINKEY[KEY_ASCE] = .KEY[KEY_ASCE];
	FLD = .KEY[KEY_FLD];			! ??? Might this be zero?
	MINFLD[FLD_SIZ] = .FLD[FLD_SIZ];
	MINFLD[FLD_DTY] = .FLD[FLD_DTY];

	! Assume that all the keys are compatible
	!
	COMPAT = TRUE;

	! Loop through the rest of the formats, determining compatibility
	! and minimizing our description of the key.
	!
	WHILE (FMT = .FMT[FMT_NEXT]) NEQ 0 DO
	    IF NOT MINCOMPAT( .FMT[FMT_CKEY], MINKEY[BASE_], MINFLD[FLD_SIZ] )
	    THEN
		COMPAT = FALSE;

	! Now that we have a short description, loop through all the
	! current keys, 'taking off' this minimal key.
	!
	FMT = FMT_ROOT - %FIELDEXPAND(FMT_NEXT,0);
	WHILE (FMT = .FMT[FMT_NEXT]) NEQ 0 DO
	IF (KEY = .FMT[FMT_CKEY]) NEQ 0 THEN	! More keys for this format?
	    BEGIN
	    LOCAL
		T: WORD;	! Size
	    !
	    ! Check for compatability of the current key with the minimum key.
	    ! If they are compatible, check that the length hasn't changed.
	    !
	    FLD = .KEY[KEY_FLD];	! ??? Might this be zero?
	    IF MINCOMPAT( MINKEY[BASE_], .FMT[FMT_CKEY], T )
	    THEN
		BEGIN
		IF NOT .COMPAT
		THEN
		    BBLOCK[ NEW_KEY(0,FMT[BASE_]), KEY_LIT ] = 0;
		IF .T NEQ .FLD[FLD_SIZ]
		THEN
		    BEGIN
		    !
		    ! Break the key up into two pieces, by defining the short
		    ! key just before the current key, and updating the current
		    ! key's length.
		    !
		    BBLOCK[
			NEW_KEY(
			    TREE_INSERT(.FLD[FLD_POS],.T,.FLD[FLD_DTY]),
			    FMT[BASE_]), KEY_ASCE] = .KEY[KEY_ASCE];
		    FLD[FLD_SIZ] = .FLD[FLD_SIZ] - .T;
		    END
		ELSE
		    BEGIN
		    !
		    ! The keys are completely compatible, advance
		    !
		    FMT[FMT_CKEY] = .KEY[KEY_NEXT];
		    END;
		END
	    ELSE
		BEGIN
		!
		! Add a constant key to distinguish the formats
		!
		BBLOCK[ NEW_KEY(0,FMT[BASE_]), KEY_LIT ] = 1;
		END;
	    END;
	END;

    ! Initialize all the current key pointers.
    !
    FMT = FMT_ROOT - %FIELDEXPAND(FMT_NEXT,0);
    WHILE (FMT = .FMT[FMT_NEXT]) NEQ 0 DO FMT[FMT_CKEY] = .FMT[FMT_KEYS];


    ! Make another pass over the key definitions,
    ! combining adjacent constant keys.
    !
    ! Although this is not strictly necessary, the output looks terrible
    ! if the user has many different record formats, each with a key that
    ! incompatible in a different way.
    !
    WHILE TRUE DO
	BEGIN
	LOCAL
	    CKEY:	REF KEY_BLOCK,
	    LIT:	BYTE;

	LIT = 0;

	! Advance all the format descriptions to constant keys (if any).
	!
	CKEY = 0;
	FMT = FMT_ROOT - %FIELDEXPAND(FMT_NEXT,0);
	WHILE (FMT = .FMT[FMT_NEXT]) NEQ 0 DO
	    BEGIN
	    LOCAL KEY:	REF KEY_BLOCK;
	    KEY = FMT[FMT_CKEY] - %FIELDEXPAND(KEY_NEXT,0);
	    WHILE (KEY = .KEY[KEY_NEXT]) NEQ 0 DO
		IF .KEY[KEY_FLD] EQL 0 THEN EXITLOOP;
	    FMT[FMT_CKEY] = KEY[BASE_];
	    IF KEY[BASE_] NEQ 0 THEN CKEY = KEY[BASE_];
	    END;
	IF CKEY[BASE_] EQL 0 THEN EXITLOOP;	! All done

	WHILE TRUE DO
	    BEGIN
	    LOCAL
		CCNT,
		KEY:	REF KEY_BLOCK;

	    ! Find the last format with constant keys,
	    ! Checking that we don't accept non-constant keys.
	    !
	    CKEY = 0;
	    FMT = FMT_ROOT - %FIELDEXPAND(FMT_NEXT,0);
	    WHILE (FMT = .FMT[FMT_NEXT]) NEQ 0 DO
		IF (KEY = .FMT[FMT_CKEY]) NEQ 0 THEN
		IF .KEY[KEY_FLD] EQL 0 THEN CKEY = KEY[BASE_];
	    IF CKEY[BASE_] EQL 0 THEN EXITLOOP;

	    ! Count the number of constant keys for this format.
	    !
	    CCNT = 1;
	    KEY = CKEY[BASE_];
	    WHILE (KEY = .KEY[KEY_NEXT]) NEQ 0 DO
		IF .KEY[KEY_FLD] NEQ 0 THEN EXITLOOP ELSE CCNT = .CCNT + 1;

	    ! Pass through all the formats, determining which formats
	    ! have constant keys equal to this group.
	    !
	    FMT = FMT_ROOT - %FIELDEXPAND(FMT_NEXT,0);
	    WHILE (FMT = .FMT[FMT_NEXT]) NEQ 0 DO
	    IF (KEY = .FMT[FMT_CKEY]) NEQ 0 THEN
	    IF .KEY[KEY_FLD] EQL 0 THEN
		BEGIN
		LOCAL
		    K2: REF KEY_BLOCK;
		KEY = .FMT[FMT_CKEY];
		K2 = CKEY[BASE_];
		IF  BEGIN
		    IF NOT (DECR I FROM .CCNT-1 TO 0 DO
			BEGIN
			IF KEY[BASE_] EQL 0 THEN EXITLOOP FALSE;
			IF .KEY[KEY_FLD] NEQ 0 THEN EXITLOOP FALSE;
			IF .KEY[KEY_LIT] NEQ .K2[KEY_LIT] THEN EXITLOOP FALSE;
			KEY = .KEY[KEY_NEXT];
			K2 = .K2[KEY_NEXT];
			END) THEN FALSE
		    ELIF KEY[BASE_] EQL 0 THEN TRUE
		    ELIF .KEY[KEY_FLD] NEQ 0 THEN TRUE
		    ELSE FALSE
		    END
		THEN
		    BEGIN
		    !
		    ! The constant keys are identical.
		    ! Compress these constants, and advance FMT_CKEY past them.
		    ! Note that this is why CKEY must be the processed last.
		    !
		    KEY = K2 = .FMT[FMT_CKEY];
		    K2[KEY_LIT] = .LIT;
		    DECR I FROM .CCNT-1 TO 0 DO K2 = .K2[KEY_NEXT];
		    FMT[FMT_CKEY] = KEY[KEY_NEXT] = K2[BASE_];
		    END;
		END;


	    ! Go look for some more, this time using a different literal
	    !
	    LIT = .LIT + 1;
	    IF .LIT EQL 0
	    THEN
		SOR_ERROR(SRTTRN$_COMPLEX);
	    END;

	END;

    RETURN;
    END;

ROUTINE PUT_NAME(PTR: REF FLD_BLOCK): NOVALUE =
    BEGIN

    ! Since we will issue this name in pieces,
    ! first make sure it will all fit on one line.
    !
    IF .OUT_DSC[0] LEQ 4+5+1+5 THEN PUT_LINE(1);

    !<s1>
    SELECTONE .PTR[FLD_DTY] OF
	SET
	[DSC$K_DTYPE_B]:	PUT_TEXT(LENADR_('B_'));
	[DSC$K_DTYPE_T]:	PUT_TEXT(LENADR_('T_'));
	[DSC$K_DTYPE_NRO]:	PUT_TEXT(LENADR_('NRO_'));
	[DSC$K_DTYPE_F]:	PUT_TEXT(LENADR_('F_'));
	[DSC$K_DTYPE_D]:	PUT_TEXT(LENADR_('D_'));
	[DSC$K_DTYPE_NL]:	PUT_TEXT(LENADR_('NL_'));
	[DSC$K_DTYPE_NR]:	PUT_TEXT(LENADR_('NR_'));
	[DSC$K_DTYPE_NLO]:	PUT_TEXT(LENADR_('NLO_'));
	[DSC$K_DTYPE_NU]:	PUT_TEXT(LENADR_('NU_'));
	[DSC$K_DTYPE_P]:	PUT_TEXT(LENADR_('P_'));
	[DSC$K_DTYPE_NZ]:	PUT_TEXT(LENADR_('NZ_'));
	[DSC$K_DTYPE_BU]:	PUT_TEXT(LENADR_('BU_'));
	[DSC$K_DTYPE_DIBOL]:	PUT_TEXT(LENADR_('DIBOL_'));
	[DSC$K_DTYPE_AZ]:	PUT_TEXT(LENADR_('AZ_'));
	[OTHERWISE]:	RETURN SOR_ERROR(SRTTRN$_INV_DATA);
	TES;
    CVT_BTA(.PTR[FLD_POS]);
    PUT_TEXT(LENADR_('_'));
    CVT_BTA(.PTR[FLD_SIZ]);
    END;

ROUTINE PUT_FFLD(PTR: REF FLD_BLOCK, NESTED): NOVALUE =
    BEGIN
    LOCAL
	FFLD: REF FFLD_BLOCK;

    FFLD = .PTR[FLD_FFLD];

    WHILE .FFLD[FFLD_NEXT] NEQ 0 DO
	BEGIN
	PUT_TEXT(
	    LENADR_(%CHAR(9),X_IF,' COND_'),
	    3, CVT_BTO(.FFLD[FFLD_COND]));
	PUT_TEXT(
	    LENADR_(' ',X_THEN,' %O'),
	    3, CVT_BTO(.FFLD[FFLD_LIT]),
	    LENADR_(' ',X_ELSE));
	PUT_LINE(.NESTED);
	FFLD = .FFLD[FFLD_NEXT];
	END;

    PUT_TEXT(LENADR_(%CHAR(9),'%O'),
	3, CVT_BTO(.FFLD[FFLD_LIT]));

    END;

ROUTINE PUT_DEFN(PTR: REF FLD_BLOCK): NOVALUE =
    BEGIN
    PUT_TEXT(LENADR_('/',X_FIEL,'=(',X_NAME,':'));
    PUT_NAME(PTR[BASE_]);
    PUT_TEXT(LENADR_(', ',X_POSI,':'));
    CVT_BTA(.PTR[FLD_POS]);
    !<s1>
    SELECTONE .PTR[FLD_DTY] OF
	SET
	[DSC$K_DTYPE_B,
	 DSC$K_DTYPE_T,
	 DSC$K_DTYPE_BU,
	 DSC$K_DTYPE_F,
	 DSC$K_DTYPE_AZ,
	 DSC$K_DTYPE_D]:	PUT_TEXT(LENADR_(', ',X_SIZE,':'));
	[DSC$K_DTYPE_NRO,
	 DSC$K_DTYPE_NL,
	 DSC$K_DTYPE_NR,
	 DSC$K_DTYPE_NLO,
	 DSC$K_DTYPE_NU,
	 DSC$K_DTYPE_P,
	 DSC$K_DTYPE_DIBOL,
	 DSC$K_DTYPE_NZ]:	PUT_TEXT(LENADR_(', ',X_DIGI,':'));
	[OTHERWISE]:	RETURN SOR_ERROR(SRTTRN$_INV_DATA);
	TES;
    CVT_BTA(.PTR[FLD_SIZ]);
    PUT_TEXT(LENADR_(', '));
    !<s1>
    SELECTONE .PTR[FLD_DTY] OF
	SET
	[DSC$K_DTYPE_B]:	PUT_TEXT(LENADR_(X_BINA,')'));
	[DSC$K_DTYPE_T]:	PUT_TEXT(LENADR_(X_CHAR,')'));
	[DSC$K_DTYPE_NRO]:	PUT_TEXT(LENADR_(X_DECI,',',X_TRAI,',',X_OVER,')'));
	[DSC$K_DTYPE_F]:	PUT_TEXT(LENADR_(X_FFLT,')'));
	[DSC$K_DTYPE_D]:	PUT_TEXT(LENADR_(X_DFLT,')'));
	[DSC$K_DTYPE_NL]:	PUT_TEXT(LENADR_(X_DECI,',',X_LEAD,',',X_SEPA,')'));
	[DSC$K_DTYPE_NR]:	PUT_TEXT(LENADR_(X_DECI,',',X_TRAI,',',X_SEPA,')'));
	[DSC$K_DTYPE_NLO]:	PUT_TEXT(LENADR_(X_DECI,',',X_LEAD,',',X_OVER,')'));
	[DSC$K_DTYPE_NU]:	PUT_TEXT(LENADR_(X_DECI,',',X_UNSI,')'));
	[DSC$K_DTYPE_P]:	PUT_TEXT(LENADR_(X_PACK,')'));
	[DSC$K_DTYPE_AZ]:	PUT_TEXT(LENADR_(X_ASCZ,')'));
	[DSC$K_DTYPE_NZ]:	PUT_TEXT(LENADR_(X_ZONE,')'));
	[DSC$K_DTYPE_BU]:	PUT_TEXT(LENADR_(X_BINA,',',X_UNSI,')'));
	[DSC$K_DTYPE_DIBOL]:	PUT_TEXT(LENADR_(X_DIBO,')'));
	[OTHERWISE]:	RETURN SOR_ERROR(SRTTRN$_INV_DATA);
	TES;

    RETURN TRUE;

    END;

ROUTINE GET_DEFN(IN) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Gets the definition for a field.
!
! FORMAL PARAMETERS:
!
!	IN	Index into the input buffer for start location of field.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	Number identifying the field
!
! SIDE EFFECTS:
!
!	NONE
!--
    BEGIN
    LOCAL
	POS,	! Position
	SIZ,	! Size
	DTY;	! Datatype

    ! Get the value from the 'to' field
    !
    IF NOT CVT_DTB(4, INP_BUF[.IN+4], SIZ)
    THEN
	SOR_ERROR(SRTTRN$_INV_LIMIT);

    ! Look for a value in the 'from' field
    !
    IF CH$FAIL(CH$FIND_NOT_CH(4,INP_BUF[.IN],%C' '))
    THEN
	BEGIN
	!
	! We have a one-byte field
	!
	POS = .SIZ;
	END
    ELSE
	BEGIN
	!
	! Convert the position to binary
	!
	IF NOT CVT_DTB(4, INP_BUF[.IN], POS)
	THEN
	    SOR_ERROR(SRTTRN$_INV_LIMIT);
	END;

    ! Compute the size of this field
    !
    IF .SIZ GEQ .POS
    THEN
	SIZ = .SIZ - .POS + 1
    ELSE
	BEGIN
	SOR_ERROR(SRTTRN$_INV_LIMIT);
	SIZ = .POS - .SIZ + 1;
	END;

    ! Determine the datatype
    !
    SELECTONE .INP_BUF[7] OF
	SET
	['B']:	DTY = DSC$K_DTYPE_B;
	['C']:	DTY = DSC$K_DTYPE_T;
	['D']:	DTY = DSC$K_DTYPE_NRO;
	['F']:	DTY = (IF .SIZ EQL 8 THEN DSC$K_DTYPE_D ELSE DSC$K_DTYPE_F);
	['I']:	BEGIN
		DTY = DSC$K_DTYPE_NL;
		SIZ = .SIZ - 1;
		END;
	['J']:	BEGIN
		DTY = DSC$K_DTYPE_NR;
		SIZ = .SIZ - 1;
		END;
	['K']:	DTY = DSC$K_DTYPE_NLO;
	['L']:	DTY = DSC$K_DTYPE_DIBOL;
	['P']:	BEGIN
		DTY = DSC$K_DTYPE_P;
		!
		! SORT-32 incorectly determines the size of the packed number
		! SORT-11 does this correctly
		!
		IF NOT .SWITCH_S32 THEN SIZ = .SIZ * 2 - 1;
		END;
	['Z']:	BEGIN
		!
		! SORT-32 considered this to be zoned
		! SORT-11 considered this to be ascii zoned
		!
		IF .SWITCH_S32
		THEN DTY = DSC$K_DTYPE_NZ
		ELSE DTY = DSC$K_DTYPE_AZ;
		END;
	[OTHERWISE]:	RETURN SOR_ERROR(SRTTRN$_INV_DATA);
	TES;

    RETURN TREE_INSERT(.POS, .SIZ, .DTY);

    END;

ROUTINE GET_FFLD(LIT, COND) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Create a FFLD_BLOCK
!
! FORMAL PARAMETERS:
!
!	LIT	Value for FFLD_LIT
!	COND	Value for FFLD_COND
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	Address of FFLD_BLOCK
!
! SIDE EFFECTS:
!
!	NONE
!--
    BEGIN
    LOCAL
	FFLD:	REF FFLD_BLOCK;

    GET_VM(FFLD_K_SIZE, FFLD);
    FFLD[FFLD_COND] = .COND;
    FFLD[FFLD_LIT] = .LIT;
    RETURN FFLD[BASE_];

    END;

ROUTINE PUT_QUOT (LEN, ADR: REF VECTOR[,BYTE]): NOVALUE =
    BEGIN
    LOCAL
	BUF:	VECTOR[OUT_BUF_WIDTH, BYTE],
	PTR1:	REF VECTOR[,BYTE],
	PTR2:	REF VECTOR[,BYTE];
    PTR1 = ADR[0];
    PTR2 = BUF[0];
    CH$WCHAR_A(%C'"',PTR2);
    DECR I FROM .LEN-1 TO 0 DO
	BEGIN
	CH$WCHAR_A( CH$RCHAR(.PTR1), PTR2 );
	IF CH$RCHAR_A(PTR1) EQL %C'"' THEN CH$WCHAR_A(%C'"',PTR2);
	END;
    CH$WCHAR_A(%C'"',PTR2);
    PUT_TEXT( CH$DIFF(.PTR2, BUF[0]), BUF[0] );
    END;

ROUTINE PUT_HEX (LEN, ADR: REF VECTOR[,BYTE]): NOVALUE =
    BEGIN
    LOCAL
	BUF:	VECTOR[18, BYTE],
	PTR:	REF VECTOR[,BYTE];
    PTR = BUF[0];
    CH$WCHAR_A(%C'%', PTR);
    CH$WCHAR_A(%C'X', PTR);
    DECR I FROM .LEN-1 TO 0 DO
	BEGIN
	LOCAL	R: BYTE;
	BIND	X = UPLIT BYTE('0123456789ABCDEF'): VECTOR[,BYTE];
	R = .ADR[.I];
	CH$WCHAR_A(.X[.R<4,4,0>], PTR);
	CH$WCHAR_A(.X[.R<0,4,0>], PTR);
	END;
    PUT_TEXT( CH$DIFF(.PTR, BUF[0]), BUF[0] );
    END;

ROUTINE PUT_NUMB (LEN, ADR: REF VECTOR[,BYTE], NAM: REF FLD_BLOCK): NOVALUE =
    BEGIN
    LOCAL
	SIZ;

    ! Determine how large a field is needed.
    !
    SIZ = .NAM[FLD_SIZ];
    !<s1>
    SELECTONE .NAM[FLD_DTY] OF
	SET
	[DSC$K_DTYPE_B,
	 DSC$K_DTYPE_BU]:
	    BEGIN
	    LOCAL
		RES:	INITIAL(0);
	    IF NOT CVT_DTB(.LEN, ADR[0], RES) THEN SOR_ERROR(SRTTRN$_INV_CONST);
	    PUT_HEX( MINU(.SIZ,%ALLOCATION(RES)), RES );
	    RETURN;
	    END;
	[DSC$K_DTYPE_NL,
	 DSC$K_DTYPE_NR]:	SIZ = .SIZ + 1;
	[DSC$K_DTYPE_P]:	SIZ = .SIZ / 2 + 1;
	[OTHERWISE]:	0;
	TES;
    PUT_QUOT(MINU(.LEN,.SIZ), ADR[0]);
    END;

ROUTINE PUT_FLOT (LEN, ADR: REF VECTOR[,BYTE], ITMLEN): NOVALUE =
    BEGIN
    LOCAL
	PTR:	REF VECTOR[,BYTE],
	DESC:	VECTOR[2],
	RESULT:	VECTOR[8,BYTE],
	STATUS;

    ! Find the end of the string, and convert the text string to D-floating.
    !
    PTR = CH$FIND_CH(.LEN, ADR[0], %C' ');
    IF CH$FAIL(.PTR) THEN PTR = ADR[.LEN];

    DESC[0] = CH$DIFF(.PTR, ADR[0]);
    DESC[1] = ADR[0];

    ! Convert the number to floating
    !
    BEGIN
    EXTERNAL ROUTINE OTS$CVT_T_D;
    STATUS = OTS$CVT_T_D(DESC[0], RESULT[0]);
    IF NOT .STATUS
    THEN
	SOR_ERROR(SRTTRN$_INV_CONST AND NOT STS$M_SEVERITY OR STS$K_ERROR);
    END;

    ! Now output the number, in HEX
    !
    PUT_HEX (.ITMLEN, RESULT[0]);

    END;

ROUTINE PUT_LITE (LEN, ADR: REF VECTOR[,BYTE], NAM: REF FLD_BLOCK): NOVALUE =
    BEGIN
    !<s1>
    SELECTONE .NAM[FLD_DTY] OF
	SET
	[DSC$K_DTYPE_B,
	 DSC$K_DTYPE_BU]:	PUT_NUMB(.LEN, ADR[0], NAM[BASE_]);
	[DSC$K_DTYPE_T]:	PUT_QUOT(MINU(.LEN,.NAM[FLD_SIZ]), ADR[0]);
	[DSC$K_DTYPE_NRO,
	 DSC$K_DTYPE_NL,
	 DSC$K_DTYPE_NR,
	 DSC$K_DTYPE_NLO,
	 DSC$K_DTYPE_NU,
	 DSC$K_DTYPE_P,
	 DSC$K_DTYPE_DIBOL,
	 DSC$K_DTYPE_AZ,
	 DSC$K_DTYPE_NZ]:	PUT_NUMB(.LEN, ADR[0], NAM[BASE_]);
	[DSC$K_DTYPE_F]:	PUT_FLOT(.LEN, ADR[0], 4);
	[DSC$K_DTYPE_D]:	PUT_FLOT(.LEN, ADR[0], 8);
	[OTHERWISE]:	RETURN SOR_ERROR(SRTTRN$_INV_DATA);
	TES;
    END;

ROUTINE PUT_TEXT (LEN, ADR): NOVALUE CALL =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Put some text to the output buffer.
!
! FORMAL PARAMETERS:
!
!	LEN	Length of the text
!	ADR	Address of the text
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	0 or 1
!
! SIDE EFFECTS:
!
!	NONE
!--
    BEGIN
    BUILTIN
	ACTUALCOUNT,
	ACTUALPARAMETER;
    MACRO
	LEN_(X) = ACTUALPARAMETER(X) %,
	ADR_(X) = ACTUALPARAMETER(X+1) %;
    LOCAL
	TOT_LEN;

    IF .LEN GTR 0 THEN
    IF CH$RCHAR(.ADR) EQL %C'/'
    THEN
	PUT_LINE();

    TOT_LEN = 0;
    INCR I FROM 1 TO ACTUALCOUNT()-1 BY 2 DO
	TOT_LEN = .TOT_LEN + LEN_(.I);

    IF .TOT_LEN GTRU .OUT_DSC[0] AND .TOT_LEN LSSU OUT_WIDTH
    THEN
	PUT_LINE(1);

    INCR I FROM 1 TO ACTUALCOUNT()-1 BY 2 DO
	BEGIN
	OUT_DSC[1] = CH$MOVE(LEN_(.I), ADR_(.I), .OUT_DSC[1]);
	OUT_DSC[0] = .OUT_DSC[0] - LEN_(.I);
	END;

    END;

ROUTINE PUT_LINE(TAB): NOVALUE CALL =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Output a line
!
! FORMAL PARAMETERS:
!
!	TAB	Amount to tab over on the new line (optional)
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	0 or 1
!
! SIDE EFFECTS:
!
!	NONE
!--
    BEGIN
    BUILTIN
	NULLPARAMETER;

    ! Write the line to the file
    !
    OUT_RAB[RAB$W_RSZ] = .OUT_DSC[1] - OUT_BUF[0];

    OUT_RAB[RAB$L_CTX] = SRTTRN$_WRITEERR;
    $PUT( RAB=OUT_RAB[BASE_], ERR=REPORT_IO_ERROR );

    OUT_DSC[0] = OUT_WIDTH;
    OUT_DSC[1] = OUT_BUF[0];

    IF NOT NULLPARAMETER(1)
    THEN
	PUT_TEXT(.TAB, UPLIT BYTE(REP 10 OF (%CHAR(9))));

    END;

ROUTINE CLOSE_FILES : NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Close the input and output files.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	0 or 1
!
! SIDE EFFECTS:
!
!	NONE
!--
    BEGIN

    ! Close input file
    !
    INP_FAB[FAB$L_CTX] = SRTTRN$_CLOSEIN;
    $CLOSE( FAB=INP_FAB[BASE_], ERR=REPORT_IO_ERROR );

    ! Close temporary file
    !
    IF .TMP_FAB[FAB$W_IFI] NEQ 0
    THEN
	BEGIN
	TMP_FAB[FAB$L_CTX] = SRTTRN$_CLOSEDEL;
	$CLOSE( FAB=TMP_FAB[BASE_], ERR=REPORT_IO_ERROR );
	END;

    ! Close output file
    !
    OUT_FAB[FAB$L_CTX] = SRTTRN$_CLOSEOUT;
    $CLOSE( FAB=OUT_FAB[BASE_], ERR=REPORT_IO_ERROR );

    END;

ROUTINE GET_LINE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Get a line from the input file.
!
! FORMAL PARAMETERS:
!
!	NONE
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	0 or 1
!
! SIDE EFFECTS:
!
!	NONE
!--
    BEGIN
    LOCAL
	STATUS;

    DO
	BEGIN

	CUR_RAB[RAB$L_CTX] = SRTTRN$_READERR;
	STATUS = $GET( RAB=CUR_RAB[BASE_], ERR=REPORT_IO_ERROR );

	! Check for end of file
	!
	IF .STATUS EQL RMS$_EOF
	THEN
	    BEGIN
	    LINE_TYPE = 0;
	    RETURN FALSE;
	    END;

	! Get record size from record access block
	!
	INP_REC_SIZ = .CUR_RAB[RAB$W_RSZ];

	! Fill unused portion of buffer with blanks
	!
	CH$FILL(%C' ',
	    %ALLOCATION(INP_BUF)-.INP_REC_SIZ,
	    INP_BUF[.INP_REC_SIZ]);

	! If this is the first pass, output the line as a comment
	!
	IF .PASS EQL 1
	THEN
	    BEGIN
	    !
	    ! Issue the line as a comment.
	    ! If the input file is not on a rewindable device,
	    ! also write the record to the temporary file.
	    !
	    PUT_TEXT(
		LENADR_('!'),
		.INP_REC_SIZ, INP_BUF[0]);
	    PUT_LINE();
	    IF .TMP_FAB[FAB$W_IFI] NEQ 0
	    THEN
		BEGIN
		TMP_RAB[RAB$W_RSZ] = .CUR_RAB[RAB$W_RSZ];
		TMP_RAB[RAB$L_CTX] = SRTTRN$_WRITEERR;
		$PUT( RAB=TMP_RAB[BASE_], ERR=REPORT_IO_ERROR );
		END;
	    END;

	IF .INP_BUF[6] EQL %C'*'
	THEN
	    LINE_TYPE = 0
	ELIF
	    CH$EQL(.INP_REC_SIZ, INP_BUF[0], 0, INP_BUF[0], %C' ')
	THEN
	    LINE_TYPE = 0
	ELSE
	    BEGIN
	    LOCAL
		TEMP;

	    ! Convert first 6 character positions of record
	    !
	    UPCASE(6, INP_BUF[0]);

	    ! Find type of record
	    !
	    IF CH$EQL(LENADR_('ALTSEQ'),6,INP_BUF[0],%C' ')
	    THEN
		BEGIN
		LINE_TYPE = ALTSEQ_LINE;
		RETURN TRUE;
		END;

	    ! Check whether this record is in free format, and convert to
	    ! fixed format if it is.
	    !
	    FREE_FIXED();

	    ! Check line number order (if not altseq)
	    !
	    IF .PASS EQL 1 AND NOT .LINE_SEQ
	    THEN
		BEGIN
		IF CH$EQL(5, INP_BUF[0], 0, INP_BUF[0], %C' ')
		THEN
		    0		! Ignore blank line numbers
		ELIF
		    BEGIN
		    IF CVT_DTB(5, INP_BUF[0], TEMP)
		    THEN .TEMP GTR .LINE_NUM
		    ELSE FALSE
		    END
		THEN
		    LINE_NUM = .TEMP
		ELSE
		    BEGIN
		    SOR_ERROR(SRTTRN$_LINE_NUM);
		    LINE_SEQ = TRUE;
		    END;
		END;

	    ! Determine the type of line
	    !
	    LINE_TYPE = (SELECTONE .INP_BUF[5] OF
		SET
		['H']:	HEADER_LINE;
		['I']:	RECORD_LINE;
		['O']:	RECORD_LINE;
		['F']:	FIELD_LINE;
		[OTHERWISE]:
			(IF .PASS EQL 1 THEN SOR_ERROR(SRTTRN$_INV_TYPE);0);
		TES);

	    END;

	END
    UNTIL .LINE_TYPE NEQ 0;

    ! If the user is translating an old-format Sort-32 spec file,
    ! apply some defaults for things that Sort-32 never implemented.
    !
    IF .SWITCH_S32 AND .LINE_TYPE EQL HEADER_LINE
    THEN
	BEGIN
	INP_BUF[25] = %C' ';	! Ascii collating sequence
	INP_BUF[27] = %C'X';	! Strip the keys
	END;

    RETURN TRUE;
    END;

ROUTINE FREE_FIXED: NOVALUE =
    BEGIN
    LITERAL
	NUM = 0,
	CHR = 1;
    BIND
	! Each entry in this table consists of three fields,
	! The fixed-format position of the field,
	! The maximum length of the field,
	! Whether the field is numeric or character.
	!
	H_FIELDS = UPLIT BYTE(
		 1-1, 2, NUM,	! Page number
		 3-1, 3, NUM,	! Line number
		 6-1, 1, CHR,	! Record type
		 7-1, 5, CHR,	! Sort to perform
		13-1, 5, NUM,	! Total key size
		18-1, 1, CHR,	! Sort order
		26-1, 1, CHR,	! Collating sequence
		28-1, 1, CHR,	! Keys stripping
		29-1, 4, NUM,	! Maximum record size
		33-1, 0, CHR),	! Comment
	F_FIELDS = UPLIT BYTE(
		 1-1, 2, NUM,
		 3-1, 3, NUM,
		 6-1, 1, CHR,	! Record type
		 7-1, 1, CHR,	! Key order
		 8-1, 1, CHR,	! Key type
		 9-1, 4, NUM,	! Key position
		13-1, 4, NUM,	! Key ending position
		17-1, 3, CHR,	! Force character
		20-1, 0, CHR);	! Comment
    LITERAL
	RT_POS	= 0,		! Position of this field
	RT_SIZ	= 1,		! Maximum length of this field
	RT_TYP	= 2;		! Type of this field
    LOCAL
	BUFFER:	VECTOR[80,BYTE],
	PTR,
	INP:	VECTOR[2],
	OUT:	VECTOR[2],
	RT:	REF VECTOR[3,BYTE];

    ! Skip leading spaces
    !
    PTR = CH$FIND_NOT_CH(.INP_REC_SIZ, INP_BUF[0], %C' ');
    IF CH$FAIL(.PTR) THEN RETURN;

    ! Skip digits (page number)
    !
    WHILE (CH$RCHAR_A(PTR) - %C'0') LEQU 9 DO 0;
    IF CH$RCHAR(CH$PLUS(.PTR,-1)) NEQ %C',' THEN RETURN;

    ! Skip digits (line number)
    !
    WHILE (CH$RCHAR_A(PTR) - %C'0') LEQU 9 DO 0;
    IF CH$RCHAR(CH$PLUS(.PTR,-1)) NEQ %C',' THEN RETURN;

    ! It seems to be in free-format.  Determine the record type.
    !
    SELECTONE CH$RCHAR(.PTR) OF
	SET
	['F']:	RT = F_FIELDS;	! Field specification
	['H']:	RT = H_FIELDS;	! Header specification
	[OTHERWISE]:	RETURN;	! Who knows?
	TES;

    ! Make a copy of the original record, and set up descriptors
    !
    INP[0] = .INP_REC_SIZ;
    INP[1] = BUFFER[0];
    OUT[0] = %ALLOCATION(INP_BUF);
    OUT[1] = INP_BUF[0];
    CH$COPY(.INP_REC_SIZ, INP_BUF[0], %C' ', %ALLOCATION(BUFFER), BUFFER[0]);
    CH$FILL(%C' ', %ALLOCATION(INP_BUF), INP_BUF[0]);

    ! Now loop through the fields in the record, reformatting as we go.
    !
    WHILE TRUE DO
	BEGIN
	!
	! Skip blanks
	!
	PTR = CH$FIND_NOT_CH(.INP[0], .INP[1], %C' ');
	IF CH$FAIL(.PTR) THEN EXITLOOP;		! Done if only blanks remain
	!
	! Remove the spaces from the descriptor
	!
	INP[0] = .INP[0] - CH$DIFF(.PTR, .INP[1]);
	INP[1] = .PTR;
	IF CH$RCHAR(.PTR) NEQ %C','
	THEN
	    BEGIN
	    !
	    ! Find the end of this field (a comma)
	    !
	    PTR = CH$FIND_CH(.INP[0], .INP[1], %C',');
	    IF CH$FAIL(.PTR) THEN PTR = CH$PLUS(.INP[1], .INP[0]);
	    INP_REC_SIZ = CH$MOVE( MIN(CH$DIFF(.PTR,.INP[1]),.RT[RT_SIZ]),
		.INP[1], INP_BUF[ .RT[RT_POS] +
		    (IF .RT[RT_TYP] EQL CHR THEN 0 ELSE
		    MAX(0, .RT[RT_SIZ]-CH$DIFF(.PTR,.INP[1])))]) - INP_BUF[0];

	    ! Remove this field from the descriptor
	    !
	    INP[0] = .INP[0] - CH$DIFF(.PTR, .INP[1]);
	    INP[1] = .PTR;
	    END;

	! Now scan past the comma
	!
	IF .INP[0] EQL 0 THEN EXITLOOP;
	INP[0] = .INP[0] - 1;
	INP[1] = .INP[1] + 1;

	! Advance to the next field description
	!
	RT = RT[3];
	IF .RT[RT_SIZ] EQL 0 THEN EXITLOOP;
	END;

    ! Output the reformatted line
    !
    IF .PASS EQL 1
    THEN
	BEGIN
	PUT_TEXT(
	    LENADR_('!'),
	    .INP_REC_SIZ, INP_BUF);
	PUT_LINE();
	END;

    END;

ROUTINE CVT_BTA (X) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Converts positive binary integer to ascii string in the output buffer.
!
! FORMAL PARAMETERS:
!
!	X	 The value to be converted
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	0 or 1
!
! SIDE EFFECTS:
!
!	NONE
!--
    BEGIN
    LOCAL
	TMP_BUF:	VECTOR [20,BYTE],
	Y,
	IDX,
	PTR;

    ! Is x valid?
    !
    IF .X LEQ 0
    THEN
	BEGIN
	IF .X EQL 0
	THEN
	    BEGIN
	    PUT_TEXT(LENADR_('0'));
	    RETURN TRUE;
	    END
	ELSE
	    RETURN FALSE;
	END;

    ! Initialize index in output string
    !
    PTR = TMP_BUF[%ALLOCATION(TMP_BUF)-1];

    ! Get a local copy of the value
    !
    Y = .X;
    WHILE .Y GTR 0 DO
	BEGIN
	CH$WCHAR(%C'0'+(.Y MOD 10), .PTR);
	PTR = CH$PLUS( .PTR, -1 );
	Y = .Y/10;
	END;

    PUT_TEXT(
	CH$DIFF(TMP_BUF[%ALLOCATION(TMP_BUF)-1], .PTR),
	CH$PLUS(.PTR, 1));

    RETURN TRUE;

    END;

ROUTINE CVT_DTB(
	LENGTH,
	INP_ADR,
	OUT_ADR:	REF VECTOR[1]) = 
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Converts decimal ascii string to a binary integer.
!
! FORMAL PARAMETERS:
!
!	LENGTH	Length of input string
!	INP_ADR	Address of input string
!	OUT_ADR	Address to store the result
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	0 or 1
!
! SIDE EFFECTS:
!
!	NONE
!--
    BEGIN
    LOCAL
	PTR;

    IF CH$FAIL(CH$FIND_NOT_CH(.LENGTH, .INP_ADR, %C' ')) THEN RETURN FALSE;

    OUT_ADR[0] = 0;
    PTR = .INP_ADR;

    DECR I FROM .LENGTH-1 TO 0 DO
	BEGIN
	LOCAL
	    NUM;
	NUM = CH$RCHAR_A(PTR);
	IF .NUM EQL %C' ' THEN NUM = 0 ELSE NUM = .NUM - %C'0';
	IF .NUM GTRU 9 THEN RETURN FALSE;
	OUT_ADR[0] = .OUT_ADR[0] * 10 + .NUM;
	END;

    RETURN TRUE;
    END;

ROUTINE UPCASE (LENGTH, INP_ADR): NOVALUE = 

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Upcase a string in place.
!
! FORMAL PARAMETERS:
!
!	LENGTH	Length of string
!	INP_ADR	Address of string
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	0 or 1
!
! SIDE EFFECTS:
!
!	NONE
!--
    BEGIN
    LOCAL
	PTR:	REF VECTOR[,BYTE];

    PTR = .INP_ADR;
    DECR I FROM .LENGTH-1 TO 0 DO
	BEGIN
	SELECTONE CH$RCHAR(.PTR) OF
	    SET
	    [%X'61' TO %X'7A']:	CH$WCHAR_A(CH$RCHAR(.PTR)-%X'20', PTR);
	    [OTHERWISE]:	PTR = PTR[1];
	    TES;
	END;

    END;

END
ELUDOM
