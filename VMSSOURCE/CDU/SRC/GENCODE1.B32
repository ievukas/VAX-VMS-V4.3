MODULE gencode1		(IDENT='V04-000',
			ADDRESSING_MODE(EXTERNAL=GENERAL))
= BEGIN

!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************

!++
! Facility:	Command Definition Utility, Table Generator Module 1
!
! Abstract:	This module is one of a few modules that is responsible
!		for generating the blocks that make up the DCL tables.
!		The blocks are generated by traversing the intermediate
!		representation of the CLD file created by the parsing
!		modules.
!
!		It is recommended that you read over the CLITABDEF.SDL file
!		before reading this code.
!
! Environment:	Standard CDU environment.
!
! Author:	Paul C. Anagnostopoulos
! Creation:	8 December 1982
!
! Modifications:
!--


library 'sys$library:lib';
require 'clitabdef';
require 'cdureq';

!	T A B L E   O F   C O N T E N T S
!	---------   ---   ---------------

forward routine
	cdu$generate_table_blocks: novalue,
	cdu$report_semantic_error: novalue,
	cdu$remember_reference: novalue,
	cdu$resolve_references: novalue;


!	E X T E R N A L   R E F E R E N C E S
!	---------------   -------------------

external routine
	cdu$create_node,
	cdu$generate_command,
	cdu$report_listing_line,
	cdu$lookup_child,
	cdu$generate_type,
	lib$signal;

external
	cdu$gl_cld_errors: long,
	cdu$gl_root_node: ref node,
	cdu$gl_table: pointer;

!	O W N   S T O R A G E
!	-----   -------------

! The following item is the head of the linked list of resolution nodes.

own
	resolution_list: long;

!	O V E R V I E W   O F   C O D E   G E N E R A T I O N
!	---------------   ---   -------   -------------------

! CLI table blocks are generated by traversing the intermediate
! representation tree built by the parsing routines.  There is a generation
! routine for each of the table block formats, which is responsible for
! looking at the subtree representing the construct to be converted into a
! block, pulling out the necessary information, and stashing it in the
! table block.
!
! Each generation routine operates by first allocating space for the
! largest possible table block.  It then traverses the subtree representing
! its construct, filling in the table block.  If it encounters a node which
! represents another construct, it calls that construct's generation
! routine to do its thing.  All the blocks are linked together on the fly
! via Table-Relative Offsets (TRO).
!
! Note that when the generation process is complete, the table blocks are
! spread all over memory.  Before the table is written out, it must be
! collected into one contiguous area.  This is done in module TABLE.

!++
! Description:	This routine is responsible for driving the generation of
!		table blocks for the CLD file that has just been parsed.
!		It scan the children of the top-level node in the
!		intermediate representation, looking for verb, syntax,
!		and type definitions.
!
! Parameters:	None.
!
! Returns:	Nothing.
!
! Notes:
!--

GLOBAL ROUTINE cdu$generate_table_blocks	: novalue
= BEGIN

local
	child: ref node;


! Clear the head of the resolution node linked list.  We will link nodes
! onto this list as we generate blocks.

resolution_list = 0;

! Simply scan the children of the root node, looking for definitions.

scan_children(cdu$gl_root_node,child,

	! Case on the type of child node.

	case .child[node_w_type] from 0 to node_k_max_type of set

	 [node_k_ident,
	 node_k_module]:

		! The above nodes can be ignored.

		;

	[node_k_define_verb,
	node_k_define_syntax]:

		! Call a routine to generate all blocks for the verb
		! or syntax change definition.

		cdu$generate_command(.child);

	[node_k_define_type]:

		! Call a routine to generate all blocks for the type
		! definition.

		cdu$generate_type(.child);

	[inrange,
	 outrange]:

		! Oops!  We've got some kind of bug.

		signal(msg(cdu$_intinvnode));
	tes;
);

! We have generated table blocks for the entire CLD file.  In the process,
! however, we probably encountered inter-block references that couldn't be
! resolved.  Resolve them now.

cdu$resolve_references();

return;

END;

!++
! Description:	This routine is called when a semantic error is encountered.
!		It signals the error so that it will appear on the
!		terminal.  It also includes the error in the listing file,
!		if any.
!
! Parameters:	Standard $PUTMSG argument list.
!
! Returns:	Nothing.
!
! Notes:	You may want to compare this to CDU$REPORT_SYNTAX_ERROR.
!--

GLOBAL ROUTINE cdu$report_semantic_error	: novalue
= BEGIN

builtin
	argptr,
	callg;


! Signal the error.

callg(argptr(),lib$signal);

! Include the error message in the listing file.

callg(argptr(),cdu$report_listing_line);

! Keep track of the number of semantic errors.

increment(cdu$gl_cld_errors);

return;

END;

!	R E F E R E N C E   R E S O L U T I O N
!	-----------------   -------------------

! Definitions in a CLD file can make references to other definitions in
! the file.  These references cannot be resolved as the CLD is parsed,
! because definitions do not have to appear before references to them.
! Therefore, the references must be resolved during code generation.
!
! When a reference is encountered during code generation, a reference
! resolution node is created.  This node contains the following information:
!
!	o  This sister pointer is used to chain all of the resolution nodes
!	   on a list, so that we can process them quickly after code
!	   generation.
!
!	o  The child pointer is used to reference the top-level node of the
!	   definition being referenced.  After code generation, this node
!	   will contain the TRO of the table block being referenced.
!
!	o  The code pointer is used to reference the longword which is to
!	   contain the reference.  We can fill in this longword after code
!	   generation is completed.

!++
! Description:	This routine is called to remember a definition reference
!		which must be resolved after code generation is completed.
!		A resolution node is created and used to remember the
!		information needed to resolve the reference later.
!
! Parameters:	referencor	By reference, the longword to contain the
!				reference to the table block containing
!				the definition.
!		definition	By reference, the node representing the
!				definition being referenced.
!
! Returns:	Nothing.
!
! Notes:
!--

GLOBAL ROUTINE cdu$remember_reference(referencor: pointer,
				      definition: ref node)	: novalue
= BEGIN

local
	resolution: ref node;


! Create a resolution node to remember the reference for later processing.
! Link the node on the front of the list of resolution nodes.

resolution = cdu$create_node(node_k_resolution);
resolution[node_l_sister] = .resolution_list;
resolution_list = .resolution;

! Remember the referencing longword in the code pointer, and the referenced
! definition node in the child pointer.

resolution[node_l_code] = .referencor;
resolution[node_l_child] = .definition;

return;

END;

!++
! Description:	This routine is called after code generation is completed.
!		It finishes up the task of resolving references to
!		definitions by scanning the list of resolution nodes and
!		storing the final TRO of the referenced block into the
!		referencing longword.
!
! Parameters:	None.
!
! Returns:	Nothing.
!
! Notes:
!--

GLOBAL ROUTINE cdu$resolve_references		: novalue
= BEGIN

local
	resolution: ref node,
	definition: ref node,
	referencor: pointer;


! Scan all of the resolution nodes that were created as references were
! discovered during code generation.

resolution = .resolution_list;
while .resolution neqa 0 do (

	! The child pointer references a node representing the definition
	! being referenced.  That node now contains the TRO of the
	! definition block.

	definition = .resolution[node_l_child];

	! The code pointer points at a longword in some table block
	! which is to receive the TRO of the referenced definition block.
	! Store the TRO in the longword.

	referencor = .resolution[node_l_code];
	referencor[0,0,32,0] = .definition[node_l_code];

	! Go on to the next resolution node.

	resolution = .resolution[node_l_sister];
);

return;

END;

END
ELUDOM
