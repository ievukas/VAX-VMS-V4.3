MODULE SMG$KEYPAD ( %TITLE 'Screen Management Facility Keypad Procedures'
		IDENT = '1-006'		! File: SMGKEYPAD.B32 Edit: SBL1006
		) =
BEGIN
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY:	Screen Management Facility
!
! ABSTRACT:
!
!	This module contains procedures to manage keypad key definitions.
!
! ENVIRONMENT:	User mode - AST reentrant
!
! AUTHOR: Steven B. Lionel, CREATION DATE: 10-Feb-1983
!
! MODIFIED BY:
!
! 1-001	- Original.  SBL 10-Feb-1983
! 1-002 - Use 'DEFAULT' as the default state name.  SBL 18-May-1983
! 1-003 - Keep the default state name in the KTH, so it can be sticky
!	  across operations.  SBL 23-Jun-1983
! 1-004 - Add SMG$LIST_KEY_DEFS and SMG$SET_DEFAULT_STATE.  When creating
!	  a "total key", swap the bytes of the key code so that control
!	  keys sort in the proper order.  SBL 10-Aug-1983
! 1-005 - Set KTH_A_DEF_KEYCODE in SMG$SET_DEFAULT_STATE.  SBL 14-Sep-1983
! 1-006 - Insert required NUL into TKEY in SMG$SET_DEFAULT_STATE.  SBL 15-Sep-1983
!--


%SBTTL 'Declarations'
!
! PROLOGUE FILE:
!

REQUIRE 'RTLIN:SMGPROLOG';			! Screen management definitions

!
! LINKAGE
!

LINKAGE
    CONSTRUCT_TKEY$LNK =
	CALL (REGISTER=6, REGISTER=7; REGISTER=7);

!
! TABLE OF CONTENTS:
!

FORWARD ROUTINE
    SMG$CREATE_KEY_TABLE,			! Create a key table
    SMG$ADD_KEY_DEF,				! Add a key definition
    SMG$GET_KEY_DEF,				! Get a key definition
    SMG$DELETE_KEY_DEF,				! Delete a key definition
    SMG$SET_DEFAULT_STATE,			! Set or get a default state
    SMG$$LOOKUP_KEY: SMG$$LOOKUP_KEY$LNK,	! Lookup a key
    CONSTRUCT_TKEY: CONSTRUCT_TKEY$LNK,		! Construct the total key
    COMPARE_ROUTINE,				! Compare two entries
    ALLOC_ROUTINE,				! Allocate an entry
    SMG$DEFINE_KEY,				! Process DEFINE/KEY
    DEFINE_KEY_HANDLER,				! Handler for SMG$DEFINE_KEY
    SMG$LOAD_KEY_DEFS,				! Load a file of key defs
    SMG$LIST_KEY_DEFS,				! List key definitions
    TRAVERSE_ROUTINE;				! Traverse key table

!
! MACROS:
!
!	NONE
!
! EQUATED SYMBOLS:
!

!+
! Define a mask of those control keys used by advanced line editing.
!-

LITERAL
    K_CTRLA = 1,
    K_CTRLB = 2,
    K_CTRLD = 4,
    K_CTRLE = 5,
    K_CTRLF = 6,
    K_BS = 8,
    K_HT = 9,
    K_LF = 10,
    M_EDIT_KEYS = (1^K_CTRLA) + (1^K_CTRLB) + (1^K_CTRLD) + (1^K_CTRLE) + 
	(1^K_CTRLF) + (1^K_BS) + (1^K_LF);

!
! FIELDS:
!
!	NONE
!
! OWN STORAGE:
!
!	NONE
!
! EXTERNAL DECLARATIONS:
!

EXTERNAL ROUTINE
    CLI$DCL_PARSE,		! Parse command line
    CLI$GET_VALUE,		! Get value of item from command line
    CLI$PRESENT,		! Indicate whether item is present
    LIB$GET_VM,			! Allocate virtual memory
    LIB$ANALYZE_SDESC_R2: LIB$ANALYZE_SDESC_R2$LINKAGE,	! Analyze string desc
    LIB$SCOPY_R_DX6: LIB$SCOPY_R_DX6$LINKAGE,	! Copy string
    LIB$SCOPY_DXDX6: LIB$SCOPY_DXDX6$LINKAGE,	! Copy string
    LIB$SFREE1_DD,				! Free string
    LIB$SFREE1_DD6: LIB$SFREE1_DD6$LINKAGE,	! Free string
    LIB$SFREEN_DD,		! Free strings
    LIB$SIGNAL,			! Signal continuable error
    LIB$INSERT_TREE,		! Insert item in balanced tree
    LIB$LOOKUP_TREE,		! Find item in tree
    LIB$TRAVERSE_TREE,		! Traverse balanced tree
    SMG$CREATE_VIRTUAL_KEYBOARD,! Create a virtual keyboard
    SMG$DELETE_VIRTUAL_KEYBOARD,! Delete a virtual keyboard
    SMG$READ_STRING,		! Read a string
    SMG$$KEYCODE_TO_NAME,	! Convert key code to name
    SMG$$NAME_TO_KEYCODE;	! Convert key name to key code

EXTERNAL LITERAL
    CLI$_FACILITY: UNSIGNED(6),	! CLI facility code
    CLI$_NOCOMD,		! No command on line
    SMG$_FILTOOLON,		! Filespec too long
    SMG$_INVDEFATT,		! Invalid key-definition attributes
    SMG$_INVKEYNAM,		! Invalid key name
    SMG$_INVSTANAM,		! Invalid state name
    SMG$_KEYDEFPRO,		! Key definition is protected
    SMG$_KEYNOTDEF,		! Key is not defined
    SMG$_NOMOREKEYS,		! No more keys
    SMG$_PREDEFREP;		! Previous key-definition replaced

EXTERNAL
    LIB$AB_UPCASE,		! Upcase translate table
    SMG$$AB_DEFKEY_CLD;		! Command line definition for DEFINE/KEY

%SBTTL 'SMG$CREATE_KEY_TABLE'
GLOBAL ROUTINE SMG$CREATE_KEY_TABLE (
    KEY_TABLE_ID: REF VECTOR [, LONG]
    ) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This procedure creates a key-definition table, which can then have
!	key definitions added to it by calls to SMG$ADD_KEY_DEF, 
!	SMG$DEFINE_KEY and SMG$LOAD_KEY_DEFS.
!
! CALLING SEQUENCE:
!
!	RET_STATUS.wlc.v = SMG$CREATE_KEY_TABLE (
!				KEY_TABLE_ID.wl.r)
!
! FORMAL PARAMETERS:
!
!	KEY_TABLE_ID	A longword into which is written the identification
!			of the newly-created key-definition table.  This
!			identification can then be passed to other Screen
!			Management procedures to uniquely identify this set
!			of key definitions.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	SS$_NORMAL	Normal successful completion
!	LIB$_INSVIRMEM	Insufficient virtual memory
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LOCAL
	KTH: REF KTH_R_KTH_STRUCT,		! Key table header
	VM_STATUS;

    !+
    ! Allocate and initialize the key table header.  For a default terminator
    ! mask, use all control characters except those used by advanced line
    ! editing and <HT>.
    !-

    VM_STATUS = LIB$GET_VM (%REF(KTH_S_KTH_STRUCT), KEY_TABLE_ID [0]);
    IF NOT .VM_STATUS
    THEN
	RETURN .VM_STATUS;
    KTH = .KEY_TABLE_ID [0];
    KTH [KTH_A_TREEHEAD] = 0;
    KTH [KTH_L_FLAGS] = 0;
    KTH [KTH_L_MODIFIERS] = 0;
    KTH [KTH_L_TERM_MASK] = %X'FFFFFFFF' - M_EDIT_KEYS - (1^K_HT);

    !+
    ! Establish 'DEFAULT' as the default state.  The string contains
    ! the default state name, a byte of zero, and two bytes for the
    ! keycode.
    !-

    KTH [KTH_W_DEF_STATE_LEN] = %CHARCOUNT('DEFAULT') + 3;
    KTH [KTH_B_DEF_STATE_CLASS] = DSC$K_CLASS_S;
    KTH [KTH_B_DEF_STATE_DTYPE] = DSC$K_DTYPE_T;
    KTH [KTH_A_DEF_STATE_POINTER] = KTH [KTH_T_DEF_STATE_STRING];
    KTH [KTH_A_DEF_KEYCODE] = CH$MOVE (
	%CHARCOUNT('DEFAULT') + 1,
	UPLIT BYTE ('DEFAULT',0),
	KTH [KTH_T_DEF_STATE_STRING]);

    KTH [KTH_L_CHECK] = .KTH;

    RETURN SS$_NORMAL;

    END;				! End of routine SMG$CREATE_KEY_TABLE

%SBTTL 'SMG$ADD_KEY_DEF'
GLOBAL ROUTINE SMG$ADD_KEY_DEF (
    KEY_TABLE_ID: REF VECTOR [, LONG],
    KEY_NAME: REF BLOCK [, BYTE],
    IF_STATE: REF BLOCK [, BYTE],
    ATTRIBUTES: REF VECTOR [, LONG],
    EQUIV_STRING: REF BLOCK [, BYTE],
    STATE_STRING: REF BLOCK [, BYTE]
    ) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This procedure adds a key definition to a table of key definitions.
!	The table must have been created by a call to SMG$CREATE_KEY_TABLE.
!
! CALLING SEQUENCE:
!
!	RET_STATUS.wlc.v = SMG$ADD_KEY_DEF (
!				KEY_TABLE_ID.rl.r,
!				KEY_NAME.rt.dx
!				[, [IF_STATE.rt.dx]
!				[, [ATTRIBUTES.rl.r]
!				[, [EQUIV_STRING.rt.dx]
!				[, [STATE_STRING.rt.dx] ]]]])
!
! FORMAL PARAMETERS:
!
!	KEY_TABLE_ID	A longword containing the identification of the
!			key-definition table to which this definition is
!			to be added.
!
!	KEY_NAME	A string containing the name of the key to be defined.
!			The key name is stripped of trailing blanks and is
!			converted to upper-case before use.  The key name must
!			be one of the key names listed in table _\_\ TBS _\_\.
!
!	IF_STATE	A string containing a state name which further qualifies
!			KEY_NAME.  If specified, this definition of KEY_NAME is
!			used only if the current state is IF_STATE.  See the
!			description of key states in the Screen Management
!			Functional Specification.  If omitted, 'DEFAULT'
!			is used.
!
!	ATTRIBUTES	A longword bit mask specifying additional attributes of
!			this key definition.  If omitted, a mask of zero is 
!			used.  The attributes defined are:
!
!			  SMG$V_KEY_NOECHO - Bit 0
!			    If set, specifies that EQUIV_STRING is not to
!			    be echoed when this key is pressed.  If clear,
!			    EQUIV_STRING is echoed.  If SMG$V_KEY_TERMINATE
!			    is not set, SMG$V_KEY_NOECHO is ignored.
!
!			  SMG$V_KEY_TERMINATE - Bit 1
!			    If set, specifies that when this key is pressed
!			    (qualified by IF_STATE), that the input line is
!			    complete and that more characters should not be
!			    accepted.  If clear, more more characters may be
!			    accepted.
!
!			  SMG$V_KEY_LOCKSTATE - Bit 2
!			    If set, and if STATE_STRING is specified, the
!			    state name specified by STATE_STRING remains the
!			    current state until explicitly changed by a 
!			    subsequent keystroke whose definition includes
!			    a STATE_STRING.  If clear, the state name specified
!			    by STATE_STRING remains in effect only for the next
!			    defineable key.
!
!			  SMG$V_KEY_PROTECTED - Bit 3
!			    If set, indicates that this key definition cannot
!			    be modified or deleted.  If clear, indicates that
!			    this key definition can be modified or deleted.
!
!			  SMG$V_KEY_SETSTATE - Bit 4
!			    This bit is ignored by SMG$ADD_KEY_DEF.  It is
!			    returned by SMG$GET_KEY_DEF and SMG$LIST_KEY_DEFS
!			    to indicate that the key sets a state.
!
!			The remaining bits are undefined and must be zero.
!
!	EQUIV_STRING	A string which is to be substituted for the keystroke
!			in the returned line.  Unless SMG$V_NOECHO is specified,
!			the equivalence string is echoed.  If omitted, no
!			equivalence string is defined for this key.
!
!	STATE_STRING	A string containing a new state name which is to become
!			the current state when this key is pressed.  If omitted,
!			no new state is defined.  If the current state is
!			temporary (SMG$V_KEY_LOCKSTATE was not specified for
!			the previous key), the current state reverts to 
!			the default state.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	SS$_NORMAL	Normal successful completion
!	SMG$_INVDEFATT	Invalid key-definition attributes
!	SMG$_INVKTB_ID	Invalid key-table id
!	SMG$_KEYDEFPRO	Key-definition is protected against change or deletion
!	SMG$_PREDEFREP	Previous key-definition replaced
!	LIB$_INSVIRMEM	Insufficient virtual memory
!	LIB$_xxx	Any error status from LIB$SCOPY_DXDX
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LOCAL
	KTH: REF KTH_R_KTH_STRUCT,		! Key table header
	KDE: REF KDE_R_KDE_STRUCT,		! Key definition entry
	NEW_KDE,				! Pointer to new KDE
	TKEY: VECTOR [34, BYTE],		! Total key (state-key)
	TKEY_DESC: BLOCK [8, BYTE],		! Descriptor for TKEY
	TKEY_DESC_PTR: REF BLOCK [8, BYTE],	! Pointer to a TKEY desc
	TKEY_STATUS,				! Status from CONSTRUCT_TKEY
	INSERT_STATUS, 				! Status from insert
	COPY_STATUS1, COPY_STATUS2, 		! Status from calls to
	COPY_STATUS3, COPY_STATUS4,		! LIB$SCOPY_ routines
	RET_STATUS;				! Our return status
	
    BUILTIN
	AP,
	NULLPARAMETER;

    !+
    ! Define positions of arguments
    !-

    LITERAL
	K_KEY_TABLE_ID = 1,	
	K_KEY_NAME = 2,
	K_IF_STATE = 3,
	K_ATTRIBUTES = 4,
	K_EQUIV_STRING = 5,
	K_STATE_STRING = 6;

    !+
    ! Validate KEY_TABLE_ID and get the Key Table Header.
    !-

    $SMG$VALIDATE_KTH (KEY_TABLE_ID, KTH);

    !+
    ! Construct TKEY from IF_STATE and KEY_NAME.
    !-

    TKEY_DESC [DSC$A_POINTER] = TKEY;
    TKEY_DESC_PTR = TKEY_DESC;
    TKEY_STATUS = CONSTRUCT_TKEY (.AP, .TKEY_DESC_PTR; TKEY_DESC_PTR);
    IF NOT .TKEY_STATUS
    THEN
	RETURN .TKEY_STATUS;

    INSERT_STATUS = LIB$INSERT_TREE (
	KTH [KTH_A_TREEHEAD],	! Address of treehead,
	TKEY_DESC_PTR [0,0,0,0],! Descriptor of TKEY,
	%REF(0),		! Return address of existing entry
	COMPARE_ROUTINE,	! Address of compare routine
	ALLOC_ROUTINE,		! Address of allocation routine
	NEW_KDE,		! Address of new KDE
	0);			! Context - not used

    IF NOT .INSERT_STATUS
    THEN
	RETURN .INSERT_STATUS;

    !+
    ! Check for previously defined key.
    !-

    KDE = .NEW_KDE;
    RET_STATUS = SS$_NORMAL;	! Assume not previously defined
    IF .KDE [KDE_V_DEFINED]	! Already defined?
    THEN
	BEGIN
	RET_STATUS = SMG$_PREDEFREP;	! Success - Previous key definition replaced
	IF .KDE [KDE_V_PROTECTED]
	THEN
	    RETURN SMG$_KEYDEFPRO;	! Key definition protected
	END;

    !+
    ! Turn off DEFINED and user attribute bits in KDE.  Other bits might
    ! still be set.
    ! Store items in new KDE.
    !-

    KDE [KDE_V_DEFINED] = 0;
    KDE [KDE_V_USER_ATTR] = 0;
    IF NOT NULLPARAMETER (K_ATTRIBUTES)	! ATTRIBUTES present?
    THEN
	BEGIN
	KDE [KDE_V_USER_ATTR] = .ATTRIBUTES [0];
	KDE [KDE_V_SETSTATE] = 0;	! Assume no state set.
	IF (.KDE [KDE_L_ATTR] AND KDE_M_RESERVED) NEQ 0
	THEN
	    RETURN SMG$_INVDEFATT;	! Invalid key-definition attributes
	IF NOT .KDE [KDE_V_TERMINATE]
	THEN
	    KDE [KDE_V_NOECHO] = 0;	! NOTERMINATE implies ECHO
	END;

    COPY_STATUS1 = LIB$SCOPY_R_DX6 (.TKEY_DESC_PTR [DSC$W_LENGTH],
	.TKEY_DESC_PTR [DSC$A_POINTER], KDE [KDE_R_TKEY_DESC]);
    IF NOT .COPY_STATUS1
    THEN
	RETURN .COPY_STATUS1;

    IF NOT NULLPARAMETER (K_EQUIV_STRING)
    THEN
	BEGIN
	COPY_STATUS2 = LIB$SCOPY_DXDX6 (EQUIV_STRING [0,0,0,0],
	    KDE [KDE_R_EQUIV_DESC]);
	IF NOT .COPY_STATUS2
	THEN
	    RETURN .COPY_STATUS2;
	END
    ELSE IF .KDE [KDE_A_EQUIV_POINTER] NEQA 0
    THEN
	LIB$SFREE1_DD6 (KDE [KDE_R_EQUIV_DESC]);

    IF NOT NULLPARAMETER (K_STATE_STRING)	! STATE present?
    THEN
	BEGIN
	COPY_STATUS3 = LIB$SCOPY_DXDX6 (STATE_STRING [0,0,0,0],
	    KDE [KDE_R_STATE_DESC]);
	IF NOT .COPY_STATUS3
	THEN
	    RETURN .COPY_STATUS3;
	KDE [KDE_V_SETSTATE] = 1;
	END
    ELSE IF .KDE [KDE_A_STATE_POINTER] NEQA 0
    THEN
	LIB$SFREE1_DD6 (KDE [KDE_R_STATE_DESC]);

    !+
    ! If this is a control key, add that key's
    ! bit to the terminator mask.
    !-

    KTH [KTH_L_TERM_MASK] = .KTH [KTH_L_TERM_MASK] OR 
	.KDE [KDE_L_TERM_MASK];

    !+
    ! Indicate that definition is valid and return success.
    !-

    KDE [KDE_V_DEFINED] = 1;
    RETURN .RET_STATUS;

    END;					! End of routine SMG$ADD_KEY_DEF

%SBTTL 'SMG$GET_KEY_DEF'
GLOBAL ROUTINE SMG$GET_KEY_DEF (
    KEY_TABLE_ID: REF VECTOR [, LONG],
    KEY_NAME: REF BLOCK [, BYTE],
    IF_STATE: REF BLOCK [, BYTE],
    ATTRIBUTES: REF VECTOR [, LONG],
    EQUIV_STRING: REF BLOCK [, BYTE],
    STATE_STRING: REF BLOCK [, BYTE]
    ) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This procedure returns the key definition associated with a
!	specified key and state name.
!
! CALLING SEQUENCE:
!
!	RET_STATUS.wlc.v = SMG$GET_KEY_DEF (
!				KEY_TABLE_ID.rl.r,
!				KEY_NAME.rt.dx
!				[, [IF_STATE.rt.dx]
!				[, [ATTRIBUTES.wl.r]
!				[, [EQUIV_STRING.wt.dx]
!				[, [STATE_STRING.wt.dx] ]]]])
!
! FORMAL PARAMETERS:
!
!	KEY_TABLE_ID	A longword containing the identification of the
!			key-definition table in which this key is
!			to be looked up.
!
!	KEY_NAME	A string containing the name of the key whose 
!			definition is to be returned.
!			The key name is stripped of trailing blanks and is
!			converted to upper-case before use.  The key name must
!			be one of the key names listed in table _\_\ TBS _\_\.
!
!	IF_STATE	A string containing a state name which further qualifies
!			KEY_NAME. If omitted, the null state is used.
!
!	ATTRIBUTES	A longword into which is stored the attributes
!			bitmask for this key definition.  See the description
!			of SMG$ADD_KEY_DEF for more information.
!
!	EQUIV_STRING	A string into which is stored the equivalence-string
!			for this key definition.
!
!	STATE_STRING	A string into which is stored the new state-name,
!			if any, which is set by this key definition.  If this
!			key definition sets a state, the ATTRIBUTES flag
!			SMG$V_KEY_SETSTATE is set.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	SS$_NORMAL	Normal successful completion
!	SMG$_INVKTB_ID	Invalid key-table id
!	SMG$_KEYNOTDEF	Key is not defined
!	LIB$_xxx	Any error status from LIB$SCOPY_DXDX
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LOCAL
	FOUND_KDE,				! KDE found
	KDE: REF KDE_R_KDE_STRUCT,		! Key definition entry
	KTH: REF KTH_R_KTH_STRUCT,		! Key table header
	TKEY: VECTOR [34, BYTE],		! Total key (state-key)
	TKEY_DESC: BLOCK [8, BYTE],		! Descriptor for TKEY
	TKEY_DESC_PTR: REF BLOCK [8, BYTE],	! Pointer to TKEY_DESC
	TKEY_STATUS,				! Status from CONSTRUCT_TKEY
	LOOKUP_STATUS,				! Status from LIB$LOOKUP_TREE
	COPY_STATUS1, COPY_STATUS2, 		! Status from calls to
	COPY_STATUS3;				! LIB$SCOPY_ routines
	
    BUILTIN
	AP,
	NULLPARAMETER;

    !+
    ! Define positions of arguments
    !-

    LITERAL
	K_KEY_TABLE_ID = 1,	
	K_KEY_NAME = 2,
	K_IF_STATE = 3,
	K_ATTRIBUTES = 4,
	K_EQUIV_STRING = 5,
	K_STATE_STRING = 6;

    !+
    ! Validate KEY_TABLE_ID and get the Key Table Header.
    !-

    $SMG$VALIDATE_KTH (KEY_TABLE_ID, KTH);

    !+
    ! Construct TKEY from IF_STATE and KEY_NAME.
    !-

    TKEY_DESC [DSC$A_POINTER] = TKEY;
    TKEY_DESC_PTR = TKEY_DESC;
    TKEY_STATUS = CONSTRUCT_TKEY (.AP, .TKEY_DESC_PTR; TKEY_DESC_PTR);
    IF NOT .TKEY_STATUS
    THEN
	RETURN .TKEY_STATUS;

    !+
    ! Look up key name.
    !-

    LOOKUP_STATUS = LIB$LOOKUP_TREE (
	KTH [KTH_A_TREEHEAD], 		! Address of treehead
	.TKEY_DESC_PTR,			! Total state-key string
	COMPARE_ROUTINE,		! Key comparison routine
	FOUND_KDE);			! Pointer to found KDE
    IF NOT .LOOKUP_STATUS
    THEN
	RETURN SMG$_KEYNOTDEF;		! Key not defined

    !+
    ! If KDE is not defined, return "not found".
    !-

    KDE = .FOUND_KDE;
    IF NOT .KDE [KDE_V_DEFINED]
    THEN
	RETURN SMG$_KEYNOTDEF;	! Key not defined

    !+
    ! Store values.
    !-

    IF NOT NULLPARAMETER (K_ATTRIBUTES)
    THEN
	ATTRIBUTES [0] = .KDE [KDE_L_ATTR] AND KDE_M_USER_ATTR;

    IF NOT NULLPARAMETER (K_EQUIV_STRING)
    THEN
	BEGIN
	COPY_STATUS1 = LIB$SCOPY_DXDX6 (KDE [KDE_R_EQUIV_DESC],
	    EQUIV_STRING [0,0,0,0]);
	IF NOT .COPY_STATUS1
	THEN
	    RETURN .COPY_STATUS1;
	END;

    IF NOT NULLPARAMETER (K_STATE_STRING)
    THEN
	BEGIN
	COPY_STATUS2 = LIB$SCOPY_DXDX6 (KDE [KDE_R_STATE_DESC],
	    STATE_STRING [0,0,0,0]);
	IF NOT .COPY_STATUS2
	THEN
	    RETURN .COPY_STATUS2;
	END;

    RETURN SS$_NORMAL;

    END;					! End of routine SMG$GET_KEY_DEF

%SBTTL 'SMG$DELETE_KEY_DEF'
GLOBAL ROUTINE SMG$DELETE_KEY_DEF (
    KEY_TABLE_ID: REF VECTOR [, LONG],
    KEY_NAME: REF BLOCK [, BYTE],
    IF_STATE: REF BLOCK [, BYTE]
    ) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This procedure deletes a key definition from the specified table
!	of key definitions.
!
! CALLING SEQUENCE:
!
!	RET_STATUS.wlc.v = SMG$DELETE_KEY_DEF (
!				KEY_TABLE_ID.rl.r,
!				KEY_NAME.rt.dx
!				[, [IF_STATE.rt.dx] ])
!
! FORMAL PARAMETERS:
!
!	KEY_TABLE_ID	A longword containing the identification of the
!			key-definition table from which this key is
!			to be deleted.
!
!	KEY_NAME	A string containing the name of the key which is
!			to be deleted.
!			The key name is stripped of trailing blanks and is
!			converted to upper-case before use.  The key name must
!			be one of the key names listed in table _\_\ TBS _\_\.
!
!	IF_STATE	A string containing a state name which further qualifies
!			KEY_NAME. If omitted, the null state is used.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	SS$_NORMAL	Normal successful completion
!	SMG$_INVKTB_ID	Invalid key-table id
!	SMG$_KEYNOTDEF	Key is not defined
!	SMG$_KEYDEFPRO	Key definition is protected
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LOCAL
	FOUND_KDE,				! KDE found
	KDE: REF KDE_R_KDE_STRUCT,		! Key definition entry
	KTH: REF KTH_R_KTH_STRUCT,		! Ket table header
	TKEY: VECTOR [34, BYTE],		! Total key (state-key)
	TKEY_DESC: BLOCK [8, BYTE],		! Descriptor for TKEY
	TKEY_DESC_PTR: REF BLOCK [8, BYTE],	! Pointer to a TKEY desc
	TKEY_STATUS,				! Status from CONSTRUCT_TKEY
	LOOKUP_STATUS;				! Status from LIB$LOOKUP_TREE
	
    BUILTIN
	AP;

    !+
    ! Define positions of arguments
    !-

    LITERAL
	K_KEY_TABLE_ID = 1,	
	K_KEY_NAME = 2,
	K_IF_STATE = 3;

    !+
    ! Validate KEY_TABLE_ID and get the Key Table Header.
    !-

    $SMG$VALIDATE_KTH (KEY_TABLE_ID, KTH);

    !+
    ! Construct TKEY from IF_STATE and KEY_NAME.
    !-

    TKEY_DESC [DSC$A_POINTER] = TKEY;
    TKEY_DESC_PTR = TKEY_DESC;
    TKEY_STATUS = CONSTRUCT_TKEY (.AP, .TKEY_DESC_PTR; TKEY_DESC_PTR);
    IF NOT .TKEY_STATUS
    THEN
	RETURN .TKEY_STATUS;

    !+
    ! Look up key name.
    !-

    LOOKUP_STATUS = LIB$LOOKUP_TREE (
	KTH [KTH_A_TREEHEAD], 		! Address of treehead
	.TKEY_DESC_PTR,			! Total state-key string
	COMPARE_ROUTINE,		! Key comparison routine
	FOUND_KDE);			! Pointer to found KDE
    IF NOT .LOOKUP_STATUS
    THEN
	RETURN SMG$_KEYNOTDEF;	! Key not defined

    KDE = .FOUND_KDE;
    IF NOT .KDE [KDE_V_DEFINED]
    THEN
	RETURN SMG$_KEYNOTDEF;	! Key not defined

    !+
    ! Delete key definition by freeing the strings and clearing KDE_V_DEFINED.
    ! We can't actually remove this KDE from the tree, but it can be reused if
    ! the same key is redefined.
    !-

    KDE [KDE_V_DEFINED] = 0;	! Invalidate KDE
    IF .KDE [KDE_A_EQUIV_POINTER] NEQA 0
    THEN
	LIB$SFREE1_DD6 (KDE [KDE_R_EQUIV_DESC]);
    IF .KDE [KDE_A_STATE_POINTER] NEQA 0
    THEN
	LIB$SFREE1_DD6 (KDE [KDE_R_STATE_DESC]);
    IF .KDE [KDE_A_PREFIX_POINTER] NEQA 0
    THEN
	LIB$SFREE1_DD6 (KDE [KDE_R_PREFIX_DESC]);

    !+
    ! If this was a control key, reflect the deletion
    ! in the KTH.
    !-

    KTH [KTH_L_TERM_MASK] = .KTH [KTH_L_TERM_MASK] AND 
	(NOT .KDE [KDE_L_TERM_MASK]);

    !+
    ! Note that we can't free TKEY since it needs to be compared
    ! against in future searches.
    !-

    RETURN SS$_NORMAL;

    END;					! End of routine SMG$GET_KEY_DEF

%SBTTL 'SMG$SET_DEFAULT_STATE'
GLOBAL ROUTINE SMG$SET_DEFAULT_STATE (
    KEY_TABLE_ID: REF VECTOR [, LONG],
    NEW_STATE: REF BLOCK [, BYTE],
    OLD_STATE: REF BLOCK [, BYTE]
    ) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This procedure sets a new default state name and/or returns the
!	default state name for a key definition table.
!
! CALLING SEQUENCE:
!
!	RET_STATUS.wlc.v = SMG$SET_DEFAULT_STATE (
!				KEY_TABLE_ID.rl.r,
!				[NEW_STATE.rt.dx]
!				[, [OLD_STATE.wt.dx]])
!
! FORMAL PARAMETERS:
!
!	KEY_TABLE_ID	A longword containing the identification of the
!			key-definition table for which the default state 
!			name is to be set or returned.
!
!	NEW_STATE	A string containing the new default state name to be set
!			for this key-definition table.  If omitted, the
!			existing default state name is unchanged.  
!			The state name is converted to upper case and is 
!			stripped of trailing blanks before use.
!
!	OLD_STATE	A string into which is written the existing default 
!			state name of the key-definition table.  
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	SS$_NORMAL	Normal successful completion
!	SMG$_INVKTB_ID	Invalid key-table id
!	SMG$_INVSTANAM	Invalid state name
!	LIB$_INVSTRDES	Invalid string descriptor
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LOCAL
	KTH: REF KTH_R_KTH_STRUCT;		! Key table header
	
    BUILTIN
	NULLPARAMETER;

    !+
    ! Define positions of arguments
    !-

    LITERAL
	K_KEY_TABLE_ID = 1,	
	K_NEW_STATE= 2,
	K_OLD_STATE = 3;

    !+
    ! Validate KEY_TABLE_ID and get the Key Table Header.
    !-

    $SMG$VALIDATE_KTH (KEY_TABLE_ID, KTH);

    !+
    ! Return the old default state name, if requested.
    !-

    IF NOT NULLPARAMETER (K_OLD_STATE)
    THEN
	BEGIN
	LOCAL
	    COPY_STATUS;
	COPY_STATUS = LIB$SCOPY_R_DX6 ((.KTH [KTH_W_DEF_STATE_LEN] - 3),
	    KTH [KTH_T_DEF_STATE_STRING], OLD_STATE [0,0,0,0]);
	IF NOT .COPY_STATUS
	THEN
	    RETURN .COPY_STATUS;
	END;

    !+
    ! Set the new default state, if requested.
    !-

    IF NOT NULLPARAMETER (K_NEW_STATE)
    THEN
	BEGIN
	LOCAL
	    NEW_STATE_PTR,		! Pointer to string
	    NEW_STATE_LEN: WORD,	! Length of string
	    CHAR_PTR,			! Pointer to current character
	    KEY_PTR,			! Pointer to current pos in TKEY
	    ANL_STATUS;			! Status from LIB$ANALYZE_SDESC

	!+
	! Analyze NEW_STATE string.
	!-

	ANL_STATUS = LIB$ANALYZE_SDESC_R2 (NEW_STATE [0,0,0,0];
	    NEW_STATE_LEN, NEW_STATE_PTR);
	IF NOT .ANL_STATUS
	THEN
	    RETURN .ANL_STATUS;

	IF .NEW_STATE_LEN GTRU 31
	THEN
	    RETURN SMG$_INVSTANAM;	! Invalid state name

	!+
	! Find position of last non-blank character.
	!-

	CHAR_PTR = .NEW_STATE_PTR + .NEW_STATE_LEN;
	WHILE ((CHAR_PTR=.CHAR_PTR-1;CH$RCHAR(.CHAR_PTR)) EQLU %C' ') DO
	    BEGIN
	    NEW_STATE_LEN = .NEW_STATE_LEN - 1;
	    IF .NEW_STATE_LEN EQL 0 THEN EXITLOOP;
	    END;

	KEY_PTR = CH$TRANSLATE (LIB$AB_UPCASE, .NEW_STATE_LEN, .NEW_STATE_PTR,
	    0, .NEW_STATE_LEN, KTH [KTH_T_DEF_STATE_STRING]);
	CH$WCHAR_A (0, KEY_PTR);
	KTH [KTH_A_DEF_KEYCODE] = .KEY_PTR;
	KTH [KTH_W_DEF_STATE_LEN] = .NEW_STATE_LEN + 3;
	END;

    RETURN SS$_NORMAL;

    END;				! End of routine SMG$SET_DEFAULT_STATE

%SBTTL 'SMG$$LOOKUP_KEY'
GLOBAL ROUTINE SMG$$LOOKUP_KEY (
    KTH: REF KTH_R_KTH_STRUCT,
    TKEY_DESC: REF BLOCK [, BYTE];
    KDE: REF KDE_R_KDE_STRUCT
    ): SMG$$LOOKUP_KEY$LNK =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This procedure is called by SMG$READ_COMPOSED_LINE to return
!	the Key Definition Entry for a given "total key".
!
! CALLING SEQUENCE:
!
!	ret_status.wlc.v = SMG$$LOOKUP_KEY (
!				KTH.rr.r, TKEY_DESC.rr.r, KDE.wr.r)
!
! FORMAL PARAMETERS:
!
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	SS$_NORMAL	Normal successful completion
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LOCAL
	KEYCODE: REF VECTOR [2, BYTE],		! Key code
	TEMP: BYTE,				! Temporary
	FOUND_KDE,				! KDE found
	LOOKUP_STATUS;				! Status from LIB$LOOKUP_TREE
	
    !+
    ! Swap the two bytes of the key code so that a string comparison works.
    !-

    KEYCODE = .TKEY_DESC [DSC$A_POINTER] + (.TKEY_DESC [DSC$W_LENGTH] - 2);
    TEMP = .KEYCODE [0];
    KEYCODE [0] = .KEYCODE [1];
    KEYCODE [1] = .TEMP;

    !+
    ! Look up key name.
    !-

    LOOKUP_STATUS = LIB$LOOKUP_TREE (
	KTH [KTH_A_TREEHEAD], 			! Address of treehead
	TKEY_DESC [0,0,0,0],		! Total state-key string
	COMPARE_ROUTINE,		! Key comparison routine
	FOUND_KDE);			! Pointer to found KDE
    IF NOT .LOOKUP_STATUS
    THEN
	RETURN SMG$_KEYNOTDEF;		! Key not defined

    !+
    ! If KDE is not defined, return "not found".
    !-

    KDE = .FOUND_KDE;
    IF NOT .KDE [KDE_V_DEFINED]
    THEN
	RETURN SMG$_KEYNOTDEF;	! Key not defined

    RETURN SS$_NORMAL;

    END;				! End of routine SMG$$LOOKUP_KEY

%SBTTL 'CONSTRUCT_TKEY'
ROUTINE CONSTRUCT_TKEY (
    CALLERS_AP: REF VECTOR [, LONG],
    TKEY_DESC: REF BLOCK [, BYTE];
    OUT_TKEY_DESC: REF BLOCK [, BYTE]
    ) : CONSTRUCT_TKEY$LNK =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This procedure builds a "total key" from the IF_STATE and the
!	KEY_NAME in the caller's argument list.
!
! CALLING SEQUENCE:
!
!	CONSTRUCT_TKEY (CALLERS_AP.rl.v, TKEY_DESC.rr.r;
!		OUT_TKEY_DESC.wa.v)
!
! FORMAL PARAMETERS:
!
!	CALLERS_AP 	- The caller's argument pointer.
!
!	TKEY_DESC	- A descriptor for the TKEY.
!
!	OUT_TKEY_DESC	- A longword into which is written the address
!			  of the TKEY descriptor actually used.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	SS$_NORMAL	Normal successful completion
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LOCAL
	KEY_CODE,				! Key code number
	CODE_STATUS,				! Status from conversion
	NAME_TMP: VECTOR [32, BYTE],		! Upcased/stripped key name
	KTH: REF KTH_R_KTH_STRUCT,		! Key table header
	TKEY_PTR: REF VECTOR [, BYTE];		! Pointer to current pos in TKEY
	
    !+
    ! Define positions of arguments
    !-

    LITERAL
	K_KEY_TABLE_ID = 1,	
	K_KEY_NAME = 2,
	K_IF_STATE = 3;

    !+
    ! Upcase key name and strip blanks.  If key name has invalid length,
    ! return an error.
    !-

	BEGIN
	LOCAL
	    KEY_NAME_PTR,	! Pointer to KEY_NAME string
	    KEY_NAME_LEN: WORD,	! Length of key name
	    CHAR_PTR,		! Pointer to current character in KEY_NAME
	    ANL_STATUS;		! Status from LIB$ANALYZE_SDESC_R2

	ANL_STATUS = LIB$ANALYZE_SDESC_R2 (.CALLERS_AP [K_KEY_NAME];
	    KEY_NAME_LEN, KEY_NAME_PTR);
	IF NOT .ANL_STATUS
	THEN
	    RETURN .ANL_STATUS;
	IF (.KEY_NAME_LEN - 1) GTRU 30	! Between 1 and 31?
	THEN
	    RETURN SMG$_INVKEYNAM;		! Invalid key name

	!+
	! Find the position of the last non-blank character.
	!-

	CHAR_PTR = .KEY_NAME_PTR + .KEY_NAME_LEN;
	WHILE ((CHAR_PTR=.CHAR_PTR-1;CH$RCHAR(.CHAR_PTR)) EQLU %C' ') DO
	    BEGIN
	    KEY_NAME_LEN = .KEY_NAME_LEN - 1;
	    IF .KEY_NAME_LEN EQL 0 THEN EXITLOOP;
	    END;

	!+
	! Move an upcased counted string to NAME_TMP;
	!-

	NAME_TMP [0] = .KEY_NAME_LEN;
	IF .NAME_TMP [0] EQL 0
	THEN
	    RETURN SMG$_INVKEYNAM;	! Invalid key name
	CH$TRANSLATE (LIB$AB_UPCASE, .KEY_NAME_LEN, .KEY_NAME_PTR,
	    0, .KEY_NAME_LEN, NAME_TMP [1]);
	END;

    !+
    ! Get the code number corresponding to this key name, if any.
    !-

    CODE_STATUS = SMG$$NAME_TO_KEYCODE (NAME_TMP, KEY_CODE);
    IF NOT .CODE_STATUS
    THEN
	RETURN .CODE_STATUS;

    !+
    ! Construct TKEY by appending IF_STATE, a <NUL>, and KEY_CODE.
    ! Swap the bytes of KEY_CODE so that they compare as strings.
    ! Upcase and blank trim IF_STATE while we're at it.
    !-

    KTH = ..CALLERS_AP [K_KEY_TABLE_ID];
    OUT_TKEY_DESC = KTH [KTH_R_DEF_STATE_DESCR]; ! Assume default state
    TKEY_PTR = .KTH [KTH_A_DEF_KEYCODE];
    IF (.CALLERS_AP[0])<0,8> GEQU K_IF_STATE
    THEN
	IF .CALLERS_AP [K_IF_STATE] NEQA 0
	THEN
	    BEGIN
	    LOCAL
		IF_STATE_PTR,		! Pointer to IF_STATE string
		IF_STATE_LEN: WORD,	! Length of IF_STATE string
		CHAR_PTR,		! Pointer to current character
		ANL_STATUS;		! Status from LIB$ANALYZE_SDESC_R2
    
	    ANL_STATUS = LIB$ANALYZE_SDESC_R2 (.CALLERS_AP [K_IF_STATE];
		IF_STATE_LEN, IF_STATE_PTR);
	    IF NOT .ANL_STATUS
	    THEN
		RETURN .ANL_STATUS;
	    IF (.IF_STATE_LEN - 1) GTRU 30	! Between 1 and 31?
	    THEN
		RETURN SMG$_INVSTANAM;		! Invalid state name

	    !+
	    ! Find the position of the last non-blank character.
	    !-

	    CHAR_PTR = .IF_STATE_PTR+ .IF_STATE_LEN;
	    WHILE ((CHAR_PTR=.CHAR_PTR-1;CH$RCHAR(.CHAR_PTR)) EQLU %C' ') DO
		BEGIN
		IF_STATE_LEN = .IF_STATE_LEN - 1;
		IF .IF_STATE_LEN EQL 0 THEN EXITLOOP;
		END;
    
	    TKEY_DESC [DSC$W_LENGTH] = .IF_STATE_LEN + 3;
	    TKEY_PTR = CH$TRANSLATE (LIB$AB_UPCASE, .IF_STATE_LEN, .IF_STATE_PTR,
		0, .IF_STATE_LEN, .TKEY_DESC [DSC$A_POINTER]);
	    CH$WCHAR_A (0, TKEY_PTR);
    
	    OUT_TKEY_DESC = .TKEY_DESC;
	    OUT_TKEY_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	    OUT_TKEY_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
	    END;

    !+
    ! Move the key code, swapping the bytes.
    !-

    TKEY_PTR [0]  = .KEY_CODE<8,8>;
    TKEY_PTR [1] = .KEY_CODE<0,8>;

    RETURN SS$_NORMAL;

    END;					! End of routine CONSTRUCT_TKEY

%SBTTL 'COMPARE_ROUTINE'
ROUTINE COMPARE_ROUTINE (
    KEY_DESC: REF BLOCK [, BYTE],		! Key being compared
    KDE: REF KDE_R_KDE_STRUCT,			! Key definition being compared
    CONTEXT					! Not used
    ) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Routine called by LIB$INSERT_TREE and LIB$LOOKUP_TREE to compare
!	keys.
!
! CALLING SEQUENCE:
!
!	Not directly called.
!
! FORMAL PARAMETERS:
!
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	SS$_NORMAL	Normal successful completion
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    RETURN CH$COMPARE (
	.KEY_DESC [DSC$W_LENGTH],
	.KEY_DESC [DSC$A_POINTER],
	.KDE [KDE_W_TKEY_LENGTH],
	.KDE [KDE_A_TKEY_POINTER]);

    END;					! End of routine COMPARE_ROUTINE

%SBTTL 'ALLOC_ROUTINE'
ROUTINE ALLOC_ROUTINE (
    TKEY_DESC: REF BLOCK [, BYTE],		! Key descriptor
    KDE_POINTER: REF VECTOR [, LONG],		! Pointer to new KDE
    CONTEXT					! Not used
    ) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Routine called by LIB$INSERT_TREE to allocate a node.
!
! CALLING SEQUENCE:
!
!	Not directly called.
!
! FORMAL PARAMETERS:
!
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	SS$_NORMAL	Normal successful completion
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LOCAL
	VM_STATUS,			! Status from LIB$GET_VM
	KDE: REF KDE_R_KDE_STRUCT,	! Key Definition Entry
	KEY_CODE: WORD;

    !+
    ! Allocate the memory.
    !-

    VM_STATUS = LIB$GET_VM (%REF(KDE_S_KDE_STRUCT), KDE_POINTER [0]);
    IF NOT .VM_STATUS
    THEN
	RETURN .VM_STATUS;
    
    !+
    ! Initialize the KDE.
    !-

    KDE = .KDE_POINTER [0];
    CH$FILL (0, KDE_S_KDE_STRUCT, KDE [0,0,0,0]);
    KDE [KDE_B_TKEY_CLASS] = DSC$K_CLASS_D;
    KDE [KDE_B_TKEY_DTYPE] = DSC$K_DTYPE_T;
    KDE [KDE_B_EQUIV_CLASS] = DSC$K_CLASS_D;
    KDE [KDE_B_EQUIV_DTYPE] = DSC$K_DTYPE_T;
    KDE [KDE_B_STATE_CLASS] = DSC$K_CLASS_D;
    KDE [KDE_B_STATE_DTYPE] = DSC$K_DTYPE_T;
    KDE [KDE_B_PREFIX_CLASS] = DSC$K_CLASS_D;
    KDE [KDE_B_PREFIX_DTYPE] = DSC$K_DTYPE_T;

    !+
    ! If the key being defined is CTRLx, set the terminator mask to include
    ! this control key.  
    !-

    
    KEY_CODE = .((.TKEY_DESC [DSC$A_POINTER] + 
	.TKEY_DESC [DSC$W_LENGTH]) - 2)<0,16>;
    IF .KEY_CODE NEQ 0 AND
       .KEY_CODE LEQU SMG$K_TRM_CTRLZ
    THEN
	KDE [KDE_L_TERM_MASK] = 1^.KEY_CODE;
		
    RETURN SS$_NORMAL;

    END;					! End of routine ALLOC_ROUTINE

%SBTTL 'SMG$DEFINE_KEY'
GLOBAL ROUTINE SMG$DEFINE_KEY (
    KEY_TABLE_ID: REF VECTOR [, LONG],
    COMMAND_LINE: REF BLOCK [, BYTE]
    ) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This procedure parses and performs a DEFINE/KEY command.  It can
!	be used by utilities which accept DEFINE/KEY commands but which
!	do not wish to parse the commands themselves.
!
!	SMG$DEFINE_KEY calls CLI$DCL_PARSE to parse the command line and
!	then makes the appropriate call to SMG$ADD_KEY_DEF.  Use of this
!	procedure requires that the image be run under the DCL command
!	language interpreter.
!
! CALLING SEQUENCE:
!
!	RET_STATUS.wlc.v = SMG$DEFINE_KEY (
!				KEY_TABLE_ID.rl.r,
!				COMMAND_LINE.rt.dx)
!
! FORMAL PARAMETERS:
!
!	KEY_TABLE_ID	A longword containing the identification of the
!			key-definition table for which the DEFINE/KEY
!			command is to be performed.
!
!	COMMAND_LINE	A string containing the entire DEFINE/KEY command
!			to be performed.  Obtain this by calling
!			CLI$GET_VALUE with the '$LINE' keyword.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	SS$_NORMAL	Normal successful completion
!	LIB$_xxx	Any error status from LIB$SCOPY_DXDX
!	CLI$_xxx	Any error status returned from CLI$ routines
!	SMG$_xxx	Any error status returned by SMG$ADD_KEY_DEF
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LOCAL
	DESC_LIST: BLOCKVECTOR [5, 8, BYTE], 
					! List of descriptors for
					! items returned from CLI
	ATTRIBUTES,			! Attributes bit mask
	SET_STATE_PTR,			! Pointer to SET_STATE desc, if any
	IF_STATE_PTR,			! Pointer to IF_STATE desc, if any
	DESC_LIST_PTR: VOLATILE,	! Pointer to DESC_LIST
	IF_STATE_PRESENT;		! 1 if IF_STATE was specified

    BUILTIN
	NULLPARAMETER;

    !+
    ! Define codes that index the descriptors.
    !-

    LITERAL
	K_KEY_NAME = 0,		! Key name (P1)
	K_EQUIV_STRING = 1,	! Equivalence string (P2)
	K_IF_STATE = 2,		! /IF_STATE
	K_SET_STATE = 3,	! /SET_STATE
	K_ITEM_NAME = 4;	! Name of command line item

    !+
    ! Enable the error handler.
    !-

    ENABLE DEFINE_KEY_HANDLER (DESC_LIST_PTR);

    !+
    ! Initialize the descriptors.
    !-

	BEGIN
	LOCAL
	    PTR1: REF VECTOR [, LONG],
	    PTR2: REF VECTOR [, LONG];

	DESC_LIST [K_KEY_NAME, DSC$W_LENGTH] = 0;
	DESC_LIST [K_KEY_NAME, DSC$B_DTYPE] = DSC$K_DTYPE_T;
	DESC_LIST [K_KEY_NAME, DSC$B_CLASS] = DSC$K_CLASS_D;
	DESC_LIST [K_KEY_NAME, DSC$A_POINTER] = 0;

	PTR1 = DESC_LIST [K_KEY_NAME, 0,0,0,0];
	PTR2 = DESC_LIST [K_EQUIV_STRING, 0,0,0,0];
	$LIB$COPY_QUAD_A (PTR1, PTR2);	! Initialize EQUIV_STRING desc
	$LIB$COPY_QUAD_A (PTR1, PTR2);	! Initialize IF_STATE desc
	$LIB$COPY_QUAD_A (PTR1, PTR2);	! Initialize SET_STATE desc
	$LIB$COPY_QUAD_A (PTR1, PTR2);	! Initialize ITEM_NAME desc
	DESC_LIST [K_ITEM_NAME, DSC$B_CLASS] = DSC$K_CLASS_S;
	END;

    !+
    ! Set the enable argument pointer.
    !-

    DESC_LIST_PTR = DESC_LIST;

    !+
    ! Parse the command line
    !-

	BEGIN
	LOCAL
	    CLI_STATUS;
	CLI_STATUS = CLI$DCL_PARSE (COMMAND_LINE [0,0,0,0],
	    SMG$$AB_DEFKEY_CLD);
	IF NOT .CLI_STATUS
	THEN
	    RETURN LIB$SIGNAL (.CLI_STATUS);
	END;

    !+
    ! Get the key name.
    !-

	BEGIN
	LOCAL
	    STATUS;
	DESC_LIST [K_ITEM_NAME, DSC$W_LENGTH] = %CHARCOUNT ('P1');
	DESC_LIST [K_ITEM_NAME, DSC$A_POINTER] = UPLIT BYTE ('P1');
    
	STATUS = CLI$GET_VALUE (DESC_LIST [K_ITEM_NAME, 0,0,0,0],
	    DESC_LIST [K_KEY_NAME, 0,0,0,0]);
	IF NOT .STATUS
	THEN
	    RETURN LIB$SIGNAL (.STATUS);
	END;

    !+
    ! Get the equivalence string.
    !-

	BEGIN
	LOCAL
	    STATUS;
	DESC_LIST [K_ITEM_NAME, DSC$W_LENGTH] = %CHARCOUNT ('P2');
	DESC_LIST [K_ITEM_NAME, DSC$A_POINTER] = UPLIT BYTE ('P2');
    
	STATUS = CLI$GET_VALUE (DESC_LIST [K_ITEM_NAME, 0,0,0,0],
	    DESC_LIST [K_EQUIV_STRING, 0,0,0,0]);
	IF NOT .STATUS
	THEN
	    RETURN LIB$SIGNAL (.STATUS);
	END;

    !+
    ! Get the new state name, if any.
    !-

    DESC_LIST [K_ITEM_NAME, DSC$W_LENGTH] = %CHARCOUNT ('SET_STATE');
    DESC_LIST [K_ITEM_NAME, DSC$A_POINTER] = UPLIT BYTE ('SET_STATE');
    SET_STATE_PTR = 0;
    IF CLI$PRESENT (DESC_LIST [K_ITEM_NAME, 0,0,0,0])
    THEN
	BEGIN
	LOCAL
	    STATUS;
	STATUS = CLI$GET_VALUE (DESC_LIST [K_ITEM_NAME, 0,0,0,0],
	    DESC_LIST [K_SET_STATE, 0,0,0,0]);
	IF NOT .STATUS
	THEN
	    RETURN LIB$SIGNAL (.STATUS);
	SET_STATE_PTR = DESC_LIST [K_SET_STATE, 0,0,0,0];
	END;

    !+
    ! Get the attributes.
    !-

    ATTRIBUTES = 0;
    DESC_LIST [K_ITEM_NAME, DSC$W_LENGTH] = %CHARCOUNT ('ECHO');
    DESC_LIST [K_ITEM_NAME, DSC$A_POINTER] = UPLIT BYTE ('ECHO');
    IF NOT CLI$PRESENT (DESC_LIST [K_ITEM_NAME, 0,0,0,0])
    THEN
	ATTRIBUTES = .ATTRIBUTES OR SMG$M_KEY_NOECHO;

    DESC_LIST [K_ITEM_NAME, DSC$W_LENGTH] = %CHARCOUNT ('TERMINATE');
    DESC_LIST [K_ITEM_NAME, DSC$A_POINTER] = UPLIT BYTE ('TERMINATE');
    IF CLI$PRESENT (DESC_LIST [K_ITEM_NAME, 0,0,0,0])
    THEN
	ATTRIBUTES = .ATTRIBUTES OR SMG$M_KEY_TERMINATE;

    DESC_LIST [K_ITEM_NAME, DSC$W_LENGTH] = %CHARCOUNT ('LOCK_STATE');
    DESC_LIST [K_ITEM_NAME, DSC$A_POINTER] = UPLIT BYTE ('LOCK_STATE');
    IF CLI$PRESENT (DESC_LIST [K_ITEM_NAME, 0,0,0,0])
    THEN
	ATTRIBUTES = .ATTRIBUTES OR SMG$M_KEY_LOCK;

    !+
    ! See if IF_STATE was specified, and set IF_STATE_PRESENT accordingly.
    !-

    DESC_LIST [K_ITEM_NAME, DSC$W_LENGTH] = %CHARCOUNT ('IF_STATE');
    DESC_LIST [K_ITEM_NAME, DSC$A_POINTER] = UPLIT BYTE ('IF_STATE');

    IF_STATE_PTR = 0;
    IF_STATE_PRESENT = CLI$PRESENT (DESC_LIST [K_ITEM_NAME, 0,0,0,0]);
    IF .IF_STATE_PRESENT
    THEN
	IF_STATE_PTR = DESC_LIST [K_IF_STATE, 0,0,0,0];

    !+
    ! Loop adding key definitions until all IF_STATE values are used, or
    ! if no IF_STATE, just once.
    !-

    WHILE 1 DO
	BEGIN

	!+
	! If IF_STATE was on the command line, get the next value.
	!-

	IF .IF_STATE_PRESENT
	THEN
	    BEGIN
	    LOCAL
		STATUS;
	    STATUS = CLI$GET_VALUE (DESC_LIST [K_ITEM_NAME, 0,0,0,0],
		DESC_LIST [K_IF_STATE, 0,0,0,0]);
	    IF NOT .STATUS	! Exit if no more values
	    THEN
		EXITLOOP;
	    END;

	!+
	! Add the key definition.
	!-
    
	    BEGIN
	    LOCAL
		ADD_STATUS;
	    ADD_STATUS = SMG$ADD_KEY_DEF (
		KEY_TABLE_ID [0],
		DESC_LIST [K_KEY_NAME, 0,0,0,0],
		.IF_STATE_PTR,
		ATTRIBUTES,
		DESC_LIST [K_EQUIV_STRING, 0,0,0,0],
		.SET_STATE_PTR);
	    IF NOT .ADD_STATUS
	    THEN
		RETURN LIB$SIGNAL (.ADD_STATUS);
	    END;

	!+
	! If IF_STATE wasn't on the command line, exit.
	!-

	IF NOT .IF_STATE_PRESENT
	THEN
	    EXITLOOP;
	END;

    !+
    ! Free our dynamic strings.
    !-

    RETURN LIB$SFREEN_DD (%REF(4), DESC_LIST);


    END;				! End of routine SMG$DEFINE_KEY

%SBTTL 'DEFINE_KEY_HANDLER'
ROUTINE DEFINE_KEY_HANDLER (
    SIGARGS: REF BLOCK [, BYTE],	! Signal arguments list
    MCHARGS: REF BLOCK [, BYTE],	! Mechanism arguments list
    ENBARGS: REF VECTOR [, LONG]	! Enable arguments list
    ) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This procedure is the condition handler for SMG$DEFINE_KEY.
!	It intercepts CLI$ errors signalled by CLI routines which are
!	called from SMG$DEFINE_KEY, and also any errors signalled
!	by SMG$DEFINE_KEY itself.  The handler frees the dynamic strings
!	which were allocated by SMG$DEFINE_KEY and causes a return to
!	the caller of SMG$DEFINE_KEY with a return status value of the
!	error which was signalled.
!
! CALLING SEQUENCE:
!
!	Called by VMS exception handling
!
! FORMAL PARAMETERS:
!
!	SIGARGS		- The signal arguments list
!
!	MCHARGS		- The mechanism arguments list
!
!	ENBARGS		- The enable arguments list.  The enable
!			  argument is:
!
!				..ENBARGS [1] - Pointer to the first of
!						four dynamic string
!						descriptors to be freed.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	SS$_NORMAL	Normal successful completion
!	SS$_RESIGNAL	Resignal condition to next handler
!
! SIDE EFFECTS:
!
!	Causes an unwind.
!
!--

    BEGIN

    LOCAL
	COND_NAME: BLOCK [4, BYTE];

    COND_NAME = .SIGARGS [CHF$L_SIG_NAME];

    !+
    ! Return if this is SS$_UNWIND.
    !-

    IF .COND_NAME EQLU SS$_UNWIND
    THEN
	RETURN SS$_RESIGNAL;

    !+
    ! If this is not a zero-level error and is not from the CLI$ facility,
    ! resignal.
    !

    IF (.COND_NAME [STS$V_FAC_NO] NEQU CLI$_FACILITY) AND
       (.MCHARGS [CHF$L_MCH_DEPTH] NEQU 0)
    THEN
	RETURN SS$_RESIGNAL;

    !+
    ! If the error is "no command on line", just change the return status
    ! to SS$_NORMAL, otherwise use the signalled status.
    !-

    IF .COND_NAME EQLU CLI$_NOCOMD
    THEN
	MCHARGS [CHF$L_MCH_SAVR0] = SS$_NORMAL
    ELSE
	MCHARGS [CHF$L_MCH_SAVR0] = .COND_NAME;
	    
    !+
    ! Free the dynamic strings.
    !-

    IF ..ENBARGS [1] NEQA 0
    THEN
	LIB$SFREEN_DD (%REF(4), ..ENBARGS [1]);

    !+
    ! Unwind back to the caller of SMG$DEFINE_KEY.
    !-

    RETURN $UNWIND ();

    END;				! End of routine DEFINE_KEY_HANDLER

%SBTTL 'SMG$LOAD_KEY_DEFS'
GLOBAL ROUTINE SMG$LOAD_KEY_DEFS (
    KEY_TABLE_ID: REF VECTOR [, LONG],
    FILESPEC: REF BLOCK [, BYTE],
    DEFAULT_FILESPEC: REF BLOCK [, BYTE],
    LOGNAM_FLAG: REF VECTOR [, LONG]
    ) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This procedure opens and reads a file containing DEFINE/KEY
!	command lines and calls SMG$DEFINE_KEY for each line in the file.
!	This can be used by utilities to conveniently load a default set
!	of key definitions.
!
!	Use of SMG$LOAD_KEY_DEFS requires that the calling program be
!	run under the DCL command language interpreter.
!
! CALLING SEQUENCE:
!
!	RET_STATUS.wlc.v = SMG$LOAD_KEY_DEFS (
!				KEY_TABLE_ID.rl.r,
!				FILESPEC.rt.dx
!				[, [DEFAULT_FILESPEC.rt.dx]
!				[, [DEFAULT_LOGNAM.rt.dx] ]])
!
! FORMAL PARAMETERS:
!
!	KEY_TABLE_ID	 A longword containing the identification of the
!			 key-definition table into which are to be loaded
!			 the key definitions.
!
!	FILESPEC	 A string containing the file specification for the
!			 file of DEFINE/KEY commands.
!
!	DEFAULT_FILESPEC A string containing the default file specification
!			 for the file of DEFINE/KEY commands.  If omitted,
!			 the empty string is used.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	SS$_NORMAL	Normal successful completion
!	SMG$_FILTOOLON	File specification is too long (over 255 characters)
!	SMG$_xxx	Any error status returned from SMG$DEFINE_KEY
!	RMS$_xxx	Any error status returned from $OPEN
!
! SIDE EFFECTS:
!
!	Errors encountered while processing command lines are signalled.
!
!--

    BEGIN

    LOCAL
	KEYBOARD_ID,				! Keyboard id
	FILESPEC_PTR,				! Pointer to filespec desc
	RSLBUF: VECTOR [LNM$C_NAMLENGTH, BYTE], ! Resultant buffer
	RSLBUF_DESC: BLOCK [8, BYTE],		! Resultant descriptor
	LOGNAM_DESC: BLOCK [8, BYTE],		! Logical name descriptor
	LINE_DESC: BLOCK [8, BYTE],		! Command line descriptor
	OPEN_STATUS;

    BUILTIN
	ACTUALCOUNT,
	NULLPARAMETER;

    LITERAL
	K_KEY_TABLE_ID = 1,
	K_FILESPEC = 2,
	K_DEFAULT_FILESPEC = 3,
	K_LOGNAM_FLAG = 4;

    !+
    ! If LOGNAM_FLAG was specified, replace FNM with the null string if
    ! it doesn't translate as a logical name.
    !-

    FILESPEC_PTR = FILESPEC [0,0,0,0];
    IF NOT NULLPARAMETER (K_LOGNAM_FLAG)
    THEN
	BEGIN
	IF .LOGNAM_FLAG [0]
	THEN
	    BEGIN
	    !+
	    ! Set up the descriptors.
	    !-

	    LOCAL
		ANL_STATUS;
	    ANL_STATUS = LIB$ANALYZE_SDESC_R2 (FILESPEC [0,0,0,0];
		LOGNAM_DESC [DSC$W_LENGTH], LOGNAM_DESC [DSC$A_POINTER]);
	    IF NOT .ANL_STATUS
	    THEN
		RETURN .ANL_STATUS;
	    LOGNAM_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	    LOGNAM_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
	    RSLBUF_DESC [DSC$W_LENGTH] = LNM$C_NAMLENGTH;
	    RSLBUF_DESC [DSC$A_POINTER] = RSLBUF;
	    RSLBUF_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	    RSLBUF_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;

	    !+
	    ! Try translating the logical name.  If it doesn't translate,
	    ! use a zero-length string as the filespec.
	    !-

	    IF ($TRNLOG (LOGNAM=LOGNAM_DESC, RSLBUF=RSLBUF_DESC) EQLU
		SS$_NOTRAN)
	    THEN
		BEGIN
		LOGNAM_DESC [DSC$W_LENGTH] = 0;
		FILESPEC_PTR = LOGNAM_DESC;
		END;
	    END;
	END;


    !+
    ! Open the file.
    !-

    OPEN_STATUS = SMG$CREATE_VIRTUAL_KEYBOARD (KEYBOARD_ID, .FILESPEC_PTR,
	(IF ACTUALCOUNT() GEQU K_DEFAULT_FILESPEC
	 THEN
	    .DEFAULT_FILESPEC
	 ELSE
	    0));
    IF NOT .OPEN_STATUS
    THEN
	RETURN .OPEN_STATUS;

    !+
    ! Set up LINE_DESC.
    !_

    LINE_DESC [DSC$W_LENGTH] = 0;
    LINE_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
    LINE_DESC [DSC$B_CLASS] = DSC$K_CLASS_D;
    LINE_DESC [DSC$A_POINTER] = 0;

    !+
    ! While we're not at EOF, read records and call SMG$DEFINE_KEY to
    ! process the command line.
    !-

    WHILE (SMG$READ_STRING (KEYBOARD_ID,LINE_DESC)) DO
	BEGIN
	LOCAL
	    DEFINE_STATUS;
	DEFINE_STATUS = SMG$DEFINE_KEY (KEY_TABLE_ID [0], LINE_DESC);
	IF NOT .DEFINE_STATUS
	THEN
	    SIGNAL (.DEFINE_STATUS);
	END;

    LIB$SFREE1_DD (LINE_DESC);
    SMG$DELETE_VIRTUAL_KEYBOARD (KEYBOARD_ID);

    RETURN SS$_NORMAL;

    END;					! End of routine SMG$LOAD_KEY_DEFS

%SBTTL 'SMG$LIST_KEY_DEFS'
GLOBAL ROUTINE SMG$LIST_KEY_DEFS (
    KEY_TABLE_ID: REF VECTOR [, LONG],
    CONTEXT: REF VECTOR [, LONG],
    KEY_NAME: REF BLOCK [, BYTE],
    IF_STATE: REF BLOCK [, BYTE],
    ATTRIBUTES: REF VECTOR [, LONG],
    EQUIV_STRING: REF BLOCK [, BYTE],
    STATE_STRING: REF BLOCK [, BYTE]
    ) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This procedure, when called repeatedly, returns all of the
!	key definitions in a key table.
!
! CALLING SEQUENCE:
!
!	RET_STATUS.wlc.v = SMG$LIST_KEY_DEFS (
!				KEY_TABLE_ID.rl.r,
!				CONTEXT.ml.r,
!				[, [KEY_NAME.rt.dx]
!				[, [IF_STATE.rt.dx]
!				[, [ATTRIBUTES.wl.r]
!				[, [EQUIV_STRING.wt.dx]
!				[, [STATE_STRING.wt.dx] ]]]]])
!
! FORMAL PARAMETERS:
!
!	KEY_TABLE_ID	A longword containing the identification of the
!			key-definition table which is to be listed.
!
!	CONTEXT		A longword which supplies context to the search.
!			On the initial call, CONTEXT should be set to zero
!			by the caller.  It will be updated by SMG$LIST_KEY_DEFS;
!			the updated value should then be passed on subsequent
!			calls to obtain the next key definition.
!
!	KEY_NAME	A string into which is stored the key name of the next
!			definition in the key table.
!
!	IF_STATE	A string into which is stored the state name which
!			qualifies the next definition in the key table
!
!	ATTRIBUTES	A longword into which is stored the attributes
!			bitmask for the next key definition.  See the description
!			of SMG$ADD_KEY_DEF for more information.
!
!	EQUIV_STRING	A string into which is stored the equivalence-string
!			for the next key definition.
!
!	STATE_STRING	A string into which is stored the new state-name,
!			if any, which is set by the next key definition.
!			If this key definition sets a state, the ATTRIBUTES
!			flag SMG$V_KEY_SETSTATE is set.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	SS$_NORMAL	Normal successful completion
!	SMG$_INVKTB_ID	Invalid key-table id
!	SMG$_NOMOREKEYS	No more keys in table
!	LIB$_xxx	Any error status from LIB$SCOPY_DXDX
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LOCAL
	FOUND_KDE,				! KDE found
	KDE: REF KDE_R_KDE_STRUCT,		! Key definition entry
	KTH: REF KTH_R_KTH_STRUCT,		! Key table header
	DUMMY_KDE: KDE_R_KDE_STRUCT;		! Used to store first entry
	
    BUILTIN
	AP,
	NULLPARAMETER;

    !+
    ! Define positions of arguments
    !-

    LITERAL
	K_KEY_TABLE_ID = 1,	
	K_CONTEXT = 2,
	K_KEY_NAME = 3,
	K_IF_STATE = 4,
	K_ATTRIBUTES = 5,
	K_EQUIV_STRING = 6,
	K_STATE_STRING = 7;

    !+
    ! Validate KEY_TABLE_ID and get the Key Table Header.
    !-

    $SMG$VALIDATE_KTH (KEY_TABLE_ID, KTH);

    !+
    ! If this is the first time, form a linear linked list of the tree.
    !-

    KDE = .CONTEXT [0];
    IF .KDE EQLA 0
    THEN
	BEGIN
	LOCAL
	    LAST_KDE: REF KDE_R_KDE_STRUCT,
	    TRAVERSE_STATUS;

	LAST_KDE = DUMMY_KDE;
	DUMMY_KDE [KDE_A_NEXT] = 0;
	TRAVERSE_STATUS = LIB$TRAVERSE_TREE (
	    KTH [KTH_A_TREEHEAD], 	! Address of treehead
	    TRAVERSE_ROUTINE,		! Traverse routine
	    LAST_KDE);			! Pointer to previous KDE
	IF NOT .TRAVERSE_STATUS
	THEN
	    RETURN .TRAVERSE_STATUS;
	KDE = DUMMY_KDE;	! Get first KDE
	END;

    !+
    ! Get address of next KDE.  If no more keys, return status.
    ! Skip over deleted keys.
    !-

    DO
	BEGIN
	KDE = .KDE [KDE_A_NEXT];
	CONTEXT [0] = .KDE;
	IF .KDE EQLA 0
	THEN
	    RETURN SMG$_NOMOREKEYS;
	END
    UNTIL .KDE [KDE_V_DEFINED];

    !+
    ! Store values.
    !-

    IF NOT NULLPARAMETER (K_ATTRIBUTES)
    THEN
	ATTRIBUTES [0] = .KDE [KDE_L_ATTR] AND KDE_M_USER_ATTR;

    IF NOT NULLPARAMETER (K_KEY_NAME)
    THEN
	BEGIN
	LOCAL
	    KEY_NAME_AREA: VECTOR [32, BYTE],
	    KEY_CODE_PTR: REF VECTOR [, BYTE],
	    KEY_CODE: WORD,
	    STATUS;
	
	!+
	! Convert key code to key name.
	!-

	KEY_CODE_PTR = (.KDE [KDE_A_TKEY_POINTER] + .KDE [KDE_W_TKEY_LENGTH]) 
	    - 2;
	KEY_CODE<8,8> = .KEY_CODE_PTR [0]; ! Swap bytes
	KEY_CODE<0,8> = .KEY_CODE_PTR [1];
	IF NOT SMG$$KEYCODE_TO_NAME (.KEY_CODE, KEY_NAME_AREA)
	THEN
	    KEY_NAME_AREA [0] = 0;
	STATUS = LIB$SCOPY_R_DX6 (.KEY_NAME_AREA [0], KEY_NAME_AREA [1],
	    KEY_NAME [0,0,0,0]);
	IF NOT .STATUS
	THEN
	    RETURN .STATUS;
	END;

    IF NOT NULLPARAMETER (K_IF_STATE)
    THEN
	BEGIN
	LOCAL
	    STATUS;
	STATUS = LIB$SCOPY_R_DX6 (.KDE [KDE_W_TKEY_LENGTH] - 3, 
	    .KDE [KDE_A_TKEY_POINTER], IF_STATE [0,0,0,0]);
	IF NOT .STATUS
	THEN
	    RETURN .STATUS;
	END;

    IF NOT NULLPARAMETER (K_EQUIV_STRING)
    THEN
	BEGIN
	LOCAL
	    STATUS;
	STATUS = LIB$SCOPY_DXDX6 (KDE [KDE_R_EQUIV_DESC],
	    EQUIV_STRING [0,0,0,0]);
	IF NOT .STATUS
	THEN
	    RETURN .STATUS;
	END;

    IF NOT NULLPARAMETER (K_STATE_STRING)
    THEN
	BEGIN
	LOCAL
	    STATUS;
	STATUS = LIB$SCOPY_DXDX6 (KDE [KDE_R_STATE_DESC],
	    STATE_STRING [0,0,0,0]);
	IF NOT .STATUS
	THEN
	    RETURN .STATUS;
	END;

    RETURN SS$_NORMAL;

    END;					! End of routine SMG$LIST_KEY_DEFS

%SBTTL 'TRAVERSE_ROUTINE'
ROUTINE TRAVERSE_ROUTINE (
    NEXT_KDE_PTR:,				! Pointer to next KDE
    LAST_KDE_PTR: REF VECTOR [, LONG]		! Contains pointer to last KDE
    ) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Routine called by LIB$TRAVERSE_TREE.  It is used to link in this
!	KDE to the list that is being built of KDEs in order.
!
! CALLING SEQUENCE:
!
!	Not directly called.
!
! FORMAL PARAMETERS:
!
!	NEXT_KDE_PTR	A longword that contains a pointer to the next
!			KDE.
!
!	LAST_KDE_PTR	A longword that contains a pointer to the previous
!			KDE.
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION STATUS:
!
!	SS$_NORMAL	Normal successful completion
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    LOCAL
	THIS_KDE: REF KDE_R_KDE_STRUCT,	! This Key Definition Entry
	LAST_KDE: REF KDE_R_KDE_STRUCT;	! Previous Key Definition Entry

    !+
    ! Get pointers.
    !-

    THIS_KDE = .NEXT_KDE_PTR;
    LAST_KDE = .LAST_KDE_PTR [0];

    !+
    ! Link in this KDE and zero the next pointer.
    !-

    LAST_KDE [KDE_A_NEXT] = THIS_KDE [0,0,0,0];
    THIS_KDE [KDE_A_NEXT] = 0;

    !+
    ! Update the "last KDE" pointer.
    !-

    LAST_KDE_PTR [0] = THIS_KDE [0,0,0,0];

    RETURN SS$_NORMAL;

    END;					! End of routine TRAVERSE_ROUTINE

END						! End of module SMG$KEYPAD

ELUDOM
