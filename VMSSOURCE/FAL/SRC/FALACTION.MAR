	.TITLE	FALACTION - STATE TABLE ACTION ROUTINES
	.IDENT	'V04-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; Facility: FAL (DECnet File Access Listener)
;
; Abstract:
;
;	This module contains action routines called by the state table manager.
;
; Environment: VAX/VMS, user mode
;
; Author: James A. Krycka,	Creation Date:	16-JUN-1977
;
; Modified By:
;
;	V03-020	JEJ0052		J E Johnson	21-Aug-1984
;		Fix the sharing support in the NT$CREATE logic to not
;		indiscriminately turn off the SHRGET bit.  Note that
;		since some non-VMS always set SHRGET on $CREATE this bit
;		is turned off if the file format does not support sharing.
;
;	V03-019	JEJ0040		J E Johnson	19-Jun-1984
;		Fix 3-part name message handling to always send the
;		directory spec if the device spec has changed.
;
;	V03-018	JAK0145		J A Krycka	12-APR-1984
;		Track changes in DAP message building algorithm.
;
;	V03-017	JAK0143		J A Krycka	11-APR-1984
;		Use NAM$V_SRCHXABS option of the NAM$B_NOP field instead of the
;		FAB$L_CTX field to request return of XAB information on $SEARCH.
;
;	V03-016	JAK0137		J A Krycka	12-MAR-1984
;		Implement FAL logging option to disable poor-man's (or manual)
;		routing which is an unsupported and undocumented feature.
;
;	V03-015	JAK0136		J A Krycka	07-MAR-1984
;		Use FAL$GQ_WILDSPEC for wildcard file specification string.
;
;	V03-014	JAK0129		J A Krycka	11-JAN-1984
;		Correct success exit path in WRITE_FTM_NORBK action routine.
;
;	V03-013	JAK0128		J A Krycka	16-SEP-1983
;		Add FAL$DISCARD_DAT action routine to CRC check data being
;		discarded during file transfer storage mode error recovery.
;
;	V03-012	JAK0120		J A Krycka	29-JUL-1983
;		Add FAL$SAVE_MSG action routine to defer message processing.
;		Add FAL$BIT_BUCKET action routine to discard buffered data
;		during file transfer storage mode error recovery.
;		Also, reclassify error on Access Complete (end-of-stream) as
;		a file close error instead of a file transfer error to enable
;		the accessing system to distinguish between a $PUT/$WRITE
;		and a $DISCONNECT failure in file transfer storage mode.
;
;	V03-011	JAK0117		J A Krycka	08-JUL-1983
;		Preserve alternate success codes on record mode operations
;		instead of converting them to RMS$_SUC.
;
;	V03-010	JAK0110		J A Krycka	22-JUN-1983
;		Fix bug in return of Acknowledge message in FAL$DIR_SEARCH.
;
;	V03-009	JAK0109		J A Krycka	20-JUN-1983
;		Change SEND_CMP to be a subroutine.
;		Rename SEND_STS_SUC to EXIT_STS_SUC and SEND_STS_FAIL to
;		EXIT_STS_FAIL, as they also terminate the action routine.
;		Also, miscellaneous cleanup.
;
;	V03-008	JAK0108		J A Krycka	16-JUN-1983
;		Fix bug in CRC computation for retrieval of VFC formatted file
;		introduced in JAK0104.
;
;	V03-007	KRM0112		K Malik		31-MAY-1983
;		Continuation of KRM0106 to support DAP V7.0 specification.
;
;	V03-006	KRM0106		K Malik		10-MAY-1983
;		Update FAL$ERASE, FAL$EXTEND, and FAL$DIR_SEARCH to support
;		DAP V7.0 message exchange rules.
;
;	V03-005	JAK0104		J A Krycka	19-APR-1983
;		Rewrite FAL$GET_READ and FAL$PUT_WRITE action routines to
;		improve block I/O file transfer mode performance and to
;		organize these routines into eight distinct code paths for
;		clarity and efficiency. The FAL$GET_READ and FAL$PUT_WRITE
;		state table entry point names have been replaced by
;		FAL$RETRV_RAM, FAL$RETRV_FTM, FAL$STORE_RAM, and
;		FAL$STORE_FTM plus a new one called FAL$STORE_END.
;
;	V03-004	KRM0095		K Malik		06-APR-1983
;		Update FAL$RENAME to support DAP V7.0 specification.
;		Also, change SEND_ACK to be a subroutine.
;
;	V03-003	KRM0082		K Malik		23-MAR-1983
;		Add support for STMLF and STMCR file formats.
;
;	V03-002	KRM0067		K Malik		23-NOV-1982
;		Add FAL$RENAME routine to support $RENAME operation.
;
;--

	.SBTTL	DECLARATIONS
	.PSECT	FAL$DATA	SHR,NOEXE,RD,WRT,LONG

;
; Include Files:
;

	$DAPPLGDEF			; Define DAP prologue symbols
	$DAPHDRDEF			; Define DAP message header
	$DAPCNFDEF			; Define DAP Configuration message
	$DAPATTDEF			; Define DAP Attributes message
	$DAPACCDEF			; Define DAP Access message
	$DAPCTLDEF			; Define DAP Control message
	$DAPCONDEF			; Define DAP Continue Transfer message
	$DAPACKDEF			; Define DAP Acknowledge message
	$DAPCMPDEF			; Define DAP Access Complete message
	$DAPDATDEF			; Define DAP Data message
	$DAPSTSDEF			; Define DAP Status message
	$DAPKEYDEF			; Define DAP Key Definition message
	$DAPALLDEF			; Define DAP Allocation message
	$DAPSUMDEF			; Define DAP Summary message
	$DAPTIMDEF			; Define DAP Date and Time message
	$DAPPRODEF			; Define DAP Protection message
	$DAPNAMDEF			; Define DAP Name message
	$DAPCRCDEF			; Define DAP CRC checksum symbols
	$DAPFIDDEF			; Define DAP field ID symbols
	$FABDEF				; Define File Access Block symbols
	$FALWRKDEF			; Define FAL Work Area symbols
	$FALSTBDEF			; Define Statistics Block symbols
	$NAMDEF				; Define Name Block symbols
	$RABDEF				; Define Record Access Block symbols
	$RMSDEF				; Define RMS completion codes
	$SSDEF				; Define System Service status codes
	$XABDEF				; Define symbols common to all XABs
	$XABALLDEF			; Define Allocation XAB symbols
	$XABDATDEF			; Define Date and Time XAB symbols
	$XABFHCDEF			; Define File Header Char XAB symbols
	$XABKEYDEF			; Define Key Definition XAB symbols
	$XABPRODEF			; Define Protection XAB symbols
	$XABRDTDEF			; Define Revision Date and Time symbols
	$XABSUMDEF			; Define Summary XAB symbols

;
; Macros:
;
;	None
;
; Equated Symbols:
;

LF=10					; Line feed
VT=11					; Vertical tab
FF=12					; Form feed
CR=13					; Carriage return
DLE=16					; Data link error  (Control-P)
DC1=17					; Device control 1 (Control-Q)
DC2=18					; Device control 2 (Control-R)
DC3=19					; Device control 3 (Control-S)
DC4=20					; Device control 4 (Control-T)
CTRLZ=26				; Control-Z
ESC=27					; Escape

CRLF=^X0A0D				; ASCII codes for CR and LF

	ASSUME	DAP$Q_DCODE_FLG EQ 0
	ASSUME	FAL$Q_FLG EQ 0

;
; Own Storage:
;
; The following bitmask represents the DAP terminator set for stream (STM)
; format files where each bit position corresponds to an ASCII character code
; for a single-character terminator. Note that the default terminator, CRLF,
; is not expressed in this mask.
;

FAL$STM_MASK::				; DAP stream terminator bitmask
	.LONG	<<1@LF> + <1@FF> + <1@VT> + <1@CTRLZ> + <1@ESC> + -
		<1@DLE> + <1@DC1> + <1@DC2> + <1@DC3> + <1@DC4>>

	.SBTTL	STATE TABLE ACTION ROUTINES
	.PSECT	FAL$CODE	NOSHR,EXE,RD,NOWRT,BYTE

;++
; Functional Description:
;
;	This module contains action routines invoked by the state table
;	manager (FAL$STATE).
;
;	The input parameters and completion codes listed below are applicable
;	for all of these action routines. Note that an action routine may use
;	R0-R7 and AP without restoring them on exit. R0 on exit, however, must
;	represent a status code to indicate success/failure of the routine or
;	a true/false condition, as appropriate. This status code is used by
;	the state table manager to advance to the next state.
;
; Calling Sequence:
;
;	BSBW	FAL$name
;
; Input Parameters:
;
;	R8	Address of FAL work area
;	R9	Address of DAP control block
;	R10	Address of FAB
;	R11	Address of RAB
;
; Implicit Inputs:
;
;	None
;
; Output Parameters:
;
;	R0	Completion Code
;	R1-R7	Destroyed
;	AP	Destroyed
;
; Implicit Outputs:
;
;	None
;
; Completion Codes:
;
;	R0	1 = success; 0 = failure
;
; Side Effects:
;
;	None
;
;--

	.SBTTL	FAL$NEXT_MSG, FAL$INTE_MSG

;++
; The following routines have separate entry points but share common code ...
;
; This routine obtains the next DAP message from partner (excluding interrupt
; messages). Then it syntax checks this message and stores the results in the
; DAP control block.
;--

FAL$NEXT_MSG::				; Entry point
	BBCC	#FAL$V_MBXAST,(R8),10$	; Branch if no mailbox message has
					;  been received
	BSBW	FAL$MBX_RCV_QIO		; Ignore any interrupt message and
					;  re-issue mailbox read with AST
10$:	BSBW	FAL$RECEIVE		; Get next DAP message and parse it
CHECK_PARSE:				; FAL$INTE_MSG branches here
	BLBC	DAP$L_DCODE_STS(R9),10$	; Branch on message parse failure

;
; The DAP message parse was successful; use message type as the next state
; table value.
;

	MOVB	DAP$B_DCODE_MSG(R9),-	; Store new state transition value
		FAL$B_VALUE(R8)		;
	BRW	EXIT_SUCCESS		; Exit state with success

;
; Parse of DAP message failed; send Status message to partner.
;

10$:	MOVZBL	DAP$B_DCODE_FID(R9),R0	; Get ID of field in error
	MOVZBL	DAP$B_DCODE_MSG(R9),R1	; Get message type number
	MOVZBL	DAP$B_DCODE_MAC(R9),R2	; Get maccode error value
	BRW	EXIT_STS_FAIL		; Return error in Status message

;++
; This routine obtains the next DAP message from partner sent as an interrupt
; message. Then it syntax checks this message and stores the results in the
; DAP control block.
;--

FAL$INTE_MSG::				; Entry point
	MOVQ	DAP$Q_MSG_BUF1(R9),-(SP); Save decode context
	MOVQ	DAP$Q_MSG_BUF2(R9),-(SP); "
	BSBW	FAL$RECEIVE_MBX		; Get next DAP message delivered as
					;  an interrupt message and parse it
	MOVQ	(SP)+,DAP$Q_MSG_BUF2(R9); Restore decode context
	MOVQ	(SP)+,DAP$Q_MSG_BUF1(R9); "
	BRB	CHECK_PARSE		; Join common code

	.SBTTL	FAL$TEST_MSG

;++
; This routine determines whether or not a DAP message has been received from
; partner. The receive AST flag stored in the FAL work area is used to form
; the state transition status code.
;--

FAL$TEST_MSG::				; Entry point
	EXTZV	#FAL$V_RCVAST,#1,(R8),R0; Form yes/no reply
	RSB				; Exit state with status code in R0


	.SBTTL	FAL$SAVE_MSG

;++
; This routine restores the input message descriptor in the DAP control block
; to its state before the last message was requested (via FAL$NEXT_MSG) and
; decoded. This allows a message to be parsed, examined, and then returned
; to the input stream (via FAL$SAVE_MSG) to defer its processing (until after
; an interrupt message, for example, has been received and processed). To
; reparse the saved message, FAL$NEXT_MSG is called.
;--

FAL$SAVE_MSG::				; Entry point
	ADDL2	DAP$Q_MSG_BUF2(R9),-	; Restore size of input message
		DAP$Q_MSG_BUF1(R9)	;  descriptor
	MOVL	DAP$Q_MSG_BUF2+4(R9),-	; Restore address of input message
		DAP$Q_MSG_BUF1+4(R9)	;  descriptor
	BRW	EXIT_SUCCESS		; Exit state with success

	.SBTTL	FAL$FIL_PARSE

;++
; This routine parses the file specification received from partner for file
; access functions other than the DAP DIRECTORY list function.
;
; Note:	If the $PARSE operation finds a wildcard character, but the partner
;	process declares that it does not support wildcard operations, then
;	an RMS$_WLD error will be returned. This is done to assist systems
;	(such as DECnet-IAS) that do not understand VAX/VMS wildcard file
;	specifications, and therefore cannot determine that one has been
;	specified.
;--

FAL$FIL_PARSE::				; Entry point
	$PARSE	FAB=R10			; Parse the file specification
	BSBW	CHECK_FOR_PMR		; Possibly disallow poor-man's routing
	BLBC	R0,20$			; Branch on failure
	BBC	#NAM$V_WILDCARD,-	; Branch if non-wild expanded string
		FAL$L_NAM+NAM$L_FNB(R8),10$
	$SETBIT	#FAL$V_WILD,(R8)	; Denote wildcard operation
	BBS	#DAP$V_WILDCARD,-	; Branch if partner supports wildcard
		DAP$Q_SYSCAP(R9),10$	;  operations
	MOVZWL	#<RMS$_WLD&^XFFFF>,R0	; If not, return an error code for
	BRB	20$			;  'invalid wildcard operation'
10$:	BRW	EXIT_SUCCESS		; Exit state with success
20$:	BRW	ERR_FILE_OPEN		; Return error in Status message


	.SBTTL	FAL$CHECK_WILD

;++
; This routine determines whether or not the parsed file specification contains
; any wildcard characters. The wildcard status bit stored in the FAL work area
; is used to form the state transition status code.
;--

FAL$CHECK_WILD::			; Entry point
	EXTZV	#FAL$V_WILD,#1,(R8),R0	; Form yes/no reply
	RSB				; Exit state with status code in R0

	.SBTTL	FAL$FIL_SEARCH

;++
; This routine performs the search operation on a wildcard file specification
; for file access functions other than the DAP DIRECTORY list function.
;--

FAL$FIL_SEARCH::			; Entry point
	$SEARCH	FAB=R10			; Search for next file name match
	BLBC	R0,10$			; Branch on failure

;
; Re-establish the FHCXAB at the head of the XAB chain.
;

	MOVAL	FAL$L_FHCXAB(R8),-	; Store FHCXAB pointer in XAB chain
		FAB$L_XAB(R10)		;
	MOVAL	FAL$L_FHCXAB+XAB$L_NXT(R8),-
		FAL$L_CHAIN_NXT(R8)	; Save address of next chain pointer
	CLRL	@FAL$L_CHAIN_NXT(R8)	; Terminate XAB chain at FHCXAB
	BRW	EXIT_SUCCESS		; Exit state with success

;
; Note that RMS$_NMF converts to an Access Complete message.
;

10$:	CMPW	R0,#<RMS$_NMF&^XFFFF>	; Check for normal termination
	BEQL	20$			;  of wildcard operation
	BRW	ERR_FILE_OPEN		; Return error in Status message
20$:	BSBW	SEND_CMP		; Send Access Complete message
	BRW	EXIT_SUCCESS		; Exit state with success


	.SBTTL	FAL$CHECK_NMF

;++
; This routine determines whether or not an RMS$_NMF (no more files found)
; completion code was returned on the last $SEARCH call.
;--

FAL$CHECK_NMF::				; Entry point
	CMPW	FAB$L_STS(R10),-	; Branch if last error code was
		#<RMS$_NMF&^XFFFF>	;  RMS$_NMF
	BEQL	10$			;
	BRW	EXIT_FAILURE		; Exit state with failure
10$:	BRW	EXIT_SUCCESS		; Exit state with success

	.SBTTL	FAL$OPEN

;++
; This routine performs the DAP OPEN file function for both single file and
; wildcard requests.
;--

FAL$OPEN::				; Entry point

;
; An Attributes message must precede the Access message. Check for it.
;

	BBS	#FAL$V_ATT_MSG,(R8),10$	; Branch if ok
	BRW	ERR_SYNCHRONIZE		; Return error in Status message

;
; On a wildcard operation return Name messages derived from the resultant name
; string obtained on the $SEARCH call.
;

10$:	BBC	#FAL$V_WILD,(R8),20$	; Branch if not wildcard operation
	BSBW	SEND_3PART_NAM		; Send resultant name in three Name
					;  message format

;
; Open the specified file.
;

20$:	BSBW	CHAIN_RQST_XABS		; Add required XABs to XAB chain
	CLRW	FAB$W_DEQ(R10)		; Clear the old DEQ value
	$OPEN	FAB=R10			; Open the file
	BLBC	R0,60$			; Branch on failure
	BSBW	FAL$LOG_RESNAM		; Log resultant name in print file
	BBS	#DAP$V_GEQ_V70,(R9),30$	; Branch if partner uses DAP since V7.0
	CMPB	FAB$B_RFM(R10),-	; Return error if file has a record
		#FAB$C_STM		;  format that cannot be mapped into
	BGTRU	50$			;  DAP RFM field of an earlier DAP spec

;
; Set-up to compute file level CRC checksum if requested.
;

30$:	BBC	#DAP$V_RET_CRC,-	; Branch if checksum option not
		FAL$B_ACCOPT(R8),40$	;  requested by accessing node
	MOVL	#DAP$K_CRC_INIT,-	; Use initial CRC value as first
		DAP$L_CRC_RSLT(R9)	;  CRC resultant value

;
; Return (main) Attributes, Extended Attributes, and (resultant) Name messages
; to partner as directed by request mask, terminated by an Acknowledge message.
;

40$:	BSBW	CHAIN_RQST_PRT2		; Fill in alterate ALLXABs and KEYXABs
					;  as directed by NOA and NOK values
	BLBC	R0,60$			; Branch on failure
	BSBW	SEND_OPTNL_MSGS		; Build and send optional DAP messages
	$SETBIT	#FAL$V_LAST_MSG,(R8)	; Declare this last message to block
	BSBW	SEND_ACK		; Send Acknowledge message
	BRW	EXIT_SUCCESS		; Exit state with success
50$:	MOVZWL	#<RMS$_RFM&^XFFFF>,R0	; Generate invalid record format error
	CLRL	FAB$L_STV(R10)		; Zero secondary status value
60$:	BRW	ERR_FILE_OPEN		; Return error in Status message

	.SBTTL	FAL$SUBMIT, FAL$CREATE

;++
; The following routines have separate entry points but share common code ...
;
; This routine performs the DAP SUBMIT file function which consists of creating
; the command file, submitting it to the symbiont manager for execution, and
; finally deleting the command file when the job is finished.
;--

FAL$SUBMIT::				; Entry point
	BISL2	#<<FAB$M_SCF>!-		; Set submit-on-close and
		  <FAB$M_DLT>!-		;  delete-after-execution bits
		0>,FAB$L_FOP(R10)	; Fall thru to FAL$CREATE ...

;++
; This routine performs the DAP CREATE file function.
;--

FAL$CREATE::				; Entry point

;
; An Attributes message must precede the Access message. Check for it.
;

	BBS	#FAL$V_ATT_MSG,(R8),10$	; Branch if ok
	BRW	ERR_SYNCHRONIZE		; Return error in Status message

	ASSUME	FAB$C_SEQ EQ 0
10$:	TSTB	FAB$B_ORG(R10)		; Is this a sequential file?
	BNEQ	15$			; Branch if it isn't.
	CMPB	#FAB$C_FIX,-		; Is this a fixed record format?
		FAB$B_RFM(R10)
	BNEQ	12$			; Branch if not
	CMPW	#512,FAB$W_MRS(R10)	; Is the recordsize right for sharing?
	BEQL	15$			; Branch if it is
12$:	BICB2	#FAB$M_SHRGET,-		; Only allow sharing to be set on files
		FAB$B_SHR(R10)		; that can be.  Some systems will try
					; to always set SHRGET regardless.

;
; Create the specified file.
;

15$:	BBC	#FAL$V_DIS_PMR,(R8),20$	; If poor-man's routing is not allowed
	$PARSE	FAB=R10			;  then first parse the filespec to
	BSBW	CHECK_FOR_PMR		;  determine if a node name is present
	BLBC	R0,40$			; Branch on failure (node name found)
20$:	BSBW	CHAIN_RECV_XABS		; Add received XABs to XAB chain
	$CREATE	FAB=R10			; Create the file
	BLBC	R0,40$			; Branch on failure
	BSBW	FAL$LOG_RESNAM		; Log resultant name in print file

;
; Set-up to compute file level CRC checksum if requested.
;

	BBC	#DAP$V_RET_CRC,-	; Branch if checksum option not
		FAL$B_ACCOPT(R8),30$	;  requested by accessing node
	MOVL	#DAP$K_CRC_INIT,-	; Use initial CRC value as first
		DAP$L_CRC_RSLT(R9)	;  CRC resultant value

;
; Return (main) Attributes, Extended Attributes, and (resultant) Name messages
; to partner as directed by request mask, followed by an Acknowledge message.
;

30$:	BSBW	SEND_OPTNL_MSGS		; Build and send optional DAP messages
	$SETBIT	#FAL$V_LAST_MSG,(R8)	; Declare this last message to block
	BSBW	SEND_ACK		; Send Acknowledge message
	BRW	EXIT_SUCCESS		; Exit state with success
40$:	BRW	ERR_FILE_OPEN		; Return error in Status message

	.SBTTL	FAL$ERASE

;++
; This routine performs the DAP ERASE file function.
;
; Note:	RMS does not return XAB information on $ERASE. The DAP specification,
;	however, allows partner to request that DAP Extended Attributes messages
;	be returned, but it is unlikely that anyone will make a request for
;	anything but a Name message.
;--

FAL$ERASE::				; Entry point
	BSBW	CHAIN_RQST_XABS		; Add required XABs to XAB chain
	$ERASE	FAB=R10			; Erase (delete) the file
	BLBC	R0,30$			; Branch on failure
	BSBW	FAL$LOG_RESNAM		; Log resultant name in print file
	TSTW	FAL$W_DISPLAY(R8)	; Branch if no additional information
	BEQL	10$			;  to return
	BSBW	SEND_OPTNL_MSGS		; Build and send optional DAP messages
	BBC	#DAP$V_GEQ_V70,(R9),10$	; Send Acknowledge message only if
	BSBW	SEND_ACK		;  partner uses DAP since V7.0
10$:	BBS	#FAL$V_WILD,(R8),20$	; Branch if wildcard operation
	BSBW	SEND_CMP		; Send Access Complete message
20$:	BRW	EXIT_SUCCESS		; Exit state with success
30$:	BBC	#FAL$V_WILD,(R8),40$	; Branch if not wildcard operation
	BSBW	SEND_3PART_NAM		; Send resultant name in three Name
					;  message format
40$:	BRW	ERR_FILE_OPEN		; Return error in Status message

	.SBTTL	FAL$RENAME

;++
; This routine performs the DAP RENAME file function.
;--

FAL$RENAME::				; Entry point
	BBS	#DAP$V_GEQ_V70,(R9),10$	; Exit if partner does not support
	BRW	FAL$UNS_ACCFUNC		;  DAP V7.0

;
; Set up registers
;

10$:	PUSHR	#^M<R10,R11>		; Save registers
	MOVL	R10,R6			; Get old filename FAB address
	MOVL	FAB$L_NAM(R6),R7	; Get old filename NAM address
	MOVAL	FAL$L_FAB2(R8),R10	; Get new filename FAB address (FAB2)
	MOVL	FAB$L_NAM(R10),R11	; Get new filename NAM address (NAM2)
	SUBL2	#FAL$K_FAB,SP		; Make room on stack for temporary
	MOVL	SP,AP			;  FAB (old filename) and save pointer

;
; Create a temporary FAB (old filename) on the stack and fill in or clear
; appropriate fields.
;

	MOVC3	#FAL$K_FAB,(R6),(SP)	; Copy old FAB onto the stack
	BBC	#FAL$V_WILD,(R8),20$	; Branch in non-wild operation
	MOVL	NAM$L_RSA(R7),-		; Since an open by NAM block is
		FAB$L_FNA(SP)		;  not allowed, overwrite the FNA
	MOVB	NAM$B_RSL(R7),-		;  and FNS with the RSA and RSL
		FAB$B_FNS(SP)		;
	CLRW	FAB$W_IFI(SP)		; Clear the IFI field
	CLRL	FAB$L_NAM(SP)		; Clear the NAM field (so that the
					;  wildcard context is not touched
					;  by the $RENAME)

;
; Parse the new filename against the old filename to resolve any wildcards
; or empty fields - i.e. rename a.a to .b or a.a to *.b
;

20$:	PUSHL	FAB$L_FNA(R10)		; Save the new FNA on the stack
	MOVZBL	FAB$B_FNS(R10),-(SP)	; Save the new FNS on the stack
	MOVL	R7,NAM$L_RLF(R11)	; Use old filename NAM as RLF
	$SETBIT	#FAB$V_OFP,FAB$L_FOP(R10);Set the output file parse bit
	BSBW	FAL$FIL_PARSE		; Parse the new filename
	MOVL	NAM$L_ESA(R11),-	; Overwrite the FNA with the old
		FAB$L_FNA(R10)		;  filename ESA and ESL
	MOVB	NAM$B_ESL(R11),-	; 
		FAB$B_FNS(R10)		;

;
; Any wildcards have now been resolved. Do the $RENAME, restore the registers
; and stack, process optional messages, do logging and exit.
;

	$RENAME	OLDFAB=AP,NEWFAB=R10	; Rename the file
	POPR	#^M<R1>			; Get the new FNS
	MOVB	R1,FAB$B_FNS(R10)	; Restore the new FNS
	POPL	FAB$L_FNA(R10)		; Restore the new FNA
	ADDL2	#FAL$K_FAB,SP		; Evaporate temporary old FAB
	POPR	#^M<R10,R11>		; Restore registers (old FAB in R10)
	BLBC	R0,40$			; Branch if $RENAME failed
	BSBW	FAL$LOG_RESNAM		; Log old resultant name in print file
	BSBW	SEND_OPTNL_MSGS		; Build and send old optional DAP msgs
	BSBW	SEND_ACK		; Send Acknowledge message
	MOVAL	FAL$L_FAB2(R8),R10	; Set up with new FAB
	$SETBIT	#FAL$V_NEWNAM,(R8)	; Set flag to send new resultant nam msg
	BSBW	FAL$LOG_RESNAM		; Log new resultant name in print file
	BSBW	SEND_OPTNL_MSGS		; Build and send new optional DAP msgs
	BSBW	SEND_ACK		; Send Acknowledge message
	MOVAL	FAL$L_FAB(R8),R10	; Restore old FAB address
	BBS	#FAL$V_WILD,(R8),30$	; Branch if wildcard operation
	BSBW	SEND_CMP		; Send Access Complete message
30$:	BRW	EXIT_SUCCESS		; Exit state with success
40$:	BBC	#FAL$V_WILD,(R8),50$	; Branch if not wildcard operation
	BSBW	SEND_3PART_NAM		; Send resultant name in three Name
					;  message format
50$:	BRW	ERR_FILE_OPEN		; Return error in Status message

	.SBTTL	FAL$EXECUTE

;++
; This routine performs the DAP EXECUTE file function which consists of
; submitting a command file to the symbiont manager for execution. The command
; file must exist on the destination node and it is not deleted after execution.
;
; Note:	The DAP specification allows partner to request that DAP Extended
;	Attributes messages be returned, but it is unlikely that anyone will
;	make a request for anything but a Name message.
;--

FAL$EXECUTE::				; Entry point
	$SETBIT	#FAB$V_SCF,FAB$L_FOP(R10);Set submit-on-close bit
	BSBW	CHAIN_RQST_XABS		; Add required XABs to XAB chain
	$OPEN	FAB=R10			; Open the file
	BLBC	R0,30$			; Branch on failure
	BSBW	FAL$LOG_RESNAM		; Log resultant name in print file
	CLRL	FAB$L_XAB(R10)		; Remove any XABs from chain
	$CLOSE	FAB=R10			; Close the file and submit it
	BLBC	R0,50$			; Branch on failure
	MOVL	FAB$L_FOP(R10),R1	; Get FOP options
	BSBW	FAL$LOG_CLSMSG		; Log file close in print file
	TSTW	FAL$W_DISPLAY(R8)	; Branch if no additional information
	BEQL	10$			;  to return
	BSBW	SEND_OPTNL_MSGS		; Build and send optional DAP messages
	BBC	#DAP$V_GEQ_V70,(R9),10$	; Send Acknowledge message only if
	BSBW	SEND_ACK		;  partner uses DAP since V7.0
10$:	BBS	#FAL$V_WILD,(R8),20$	; Branch if wildcard operation
	BSBW	SEND_CMP		; Send Access Complete message
20$:	BRW	EXIT_SUCCESS		; Exit state with success
30$:	BBC	#FAL$V_WILD,(R8),40$	; Branch if not wildcard operation
	BSBW	SEND_3PART_NAM		; Send resultant name in three Name
					;  message format
40$:	BRW	ERR_FILE_OPEN		; Return error in Status message
50$:	BBC	#FAL$V_WILD,(R8),60$	; Branch if not wildcard operation
	BSBW	SEND_3PART_NAM		; Send resultant name in three Name
					;  message format
60$:	BRW	ERR_FILE_CLOS		; Return error in Status message

	.SBTTL	FAL$DIR_PARSE

;++
; This routine performs the parse phase of the DAP DIRECTORY list function.
;--

FAL$DIR_PARSE::				; Entry point
	MOVB	W^FAL$GQ_WILDSPEC,-	; Store size of wildcard string used
		FAB$B_DNS(R10)		;  as default file name (namely *.*;*)
	MOVL	W^FAL$GQ_WILDSPEC+4,-	; Store address of default wildcard file
		FAB$L_DNA(R10)		;  specification string buffer
	$PARSE	FAB=R10			; Parse the directory file specification
	BSBW	CHECK_FOR_PMR		; Possibly disallow poor-man's routing
	BLBC	R0,20$			; Branch on failure
	CLRB	FAB$B_DNS(R10)		; Discard default file name string
					;  in case an $OPEN is performed
	BSBW	CHAIN_RQST_XABS		; Add required XABs to XAB chain for
					;  use on subsequent $SEARCH or $OPEN
	MOVB	#<<FAB$M_SHRGET>!-	; Specify shared access to files
		  <FAB$M_SHRPUT>!-	;  so that subsequent $OPEN to obtain
		  <FAB$M_UPI>!-		;  file attributes will be less likely
		0>,FAB$B_SHR(R10)	;  to fail with RMS$_FLK error
	BBC	#NAM$V_WILDCARD,-	; Branch if non-wild expanded string
		FAL$L_NAM+NAM$L_FNB(R8),10$
	$SETBIT	#FAL$V_WILD,(R8)	; Denote wildcard operation
10$:	BRW	EXIT_SUCCESS		; Exit state with success
20$:	BRW	ERR_FILE_OPEN		; Return error in Status message


	.SBTTL	FAL$DIR_END

;++
; This routine performs the final phase of the DAP DIRECTORY list function.
;--

FAL$DIR_END::				; Entry point
	BSBW	SEND_CMP		; Send Access Complete message
	BRW	EXIT_SUCCESS		; Exit state with success

	.SBTTL	FAL$DIR_SEARCH

;++
; This routine performs the search phase of the DAP DIRECTORY list function.
;
; Note:	This routine performs only one search operation and therefore it
;	must be called repeatedly to find all requested files.
;--

FAL$DIR_SEARCH::			; Entry point
	MOVL	FAB$L_NAM(R10),R7	; Get address of NAM block
	BICW3	#DAP$M_DSP_NAM,-	; Are any attributes requested
		FAL$W_DISPLAY(R8),R0	;  (excluding resultant name)?
	BEQL	10$			; Branch if not
	BBC	#NAM$V_NODE,-		; Branch if this is the end node
		NAM$L_FNB(R7),10$	;  (i.e., not an intermediate node)
	$SETBIT	#NAM$V_SRCHXABS,NAM$B_NOP(R7)
					; Request return of XAB info to avoid
					;  opening file to get its attributes
10$:	$SEARCH	FAB=R10			; Search for next file specification
	BLBC	R0,20$			; Branch on failure
	BSBW	FAL$LOG_RESNAM		; Log resultant name in print file

;
; Send (three part) Name messages to partner.
;

	BSBW	SEND_3PART_NAM		; Send resultant name in three Name
					;  message format
	BRB	SEND_ATTRIBUTES		; Send requested attribute information

;
; Note that RMS$_NMF is converted to an Access Complete message.
;

20$:	CMPW	R0,#<RMS$_NMF&^XFFFF>	; Check for normal termination
	BEQL	30$			;  of directory search sequence
	BRW	ERR_FILE_OPEN		; Return error in Status message
30$:	BSBW	SEND_CMP		; Send Access Complete message
	BRW	EXIT_SUCCESS		; Exit state with success

;+
; Open and close the file specified in the resultant string to obtain its
; attributes, unless this is an intermediate node. (If the file name given to
; $SEARCH contained a node name, then attributes have already been returned.)
;-

SEND_ATTRIBUTES:			;
	MOVL	FAB$L_NAM(R10),R7	; Get address of NAM block
	BICW3	#DAP$M_DSP_NAM,-	; Are any attributes requested
		FAL$W_DISPLAY(R8),R0	;  (excluding resultant name)?
	BEQL	30$			; Branch if not
	BBC	#NAM$V_NODE,-		; Branch if this is the end node
		NAM$L_FNB(R7),10$	;  (i.e., not an intermediate node)
	MOVL	FAB$L_STV(R10),R1	; Branch if not partial success
	BEQL	20$			;  (i.e., file attributes were returned
					;  as requested on $SEARCH)
	BSBB	MAP_SS_TO_RMS		; Convert SS code to RMS code and
	BRB	60$			;  say error occurred on file open

;
; Now open and close the file to obtain file attributes. Note that the required
; XABs have already been chained into the XAB chain by FAL$DIR_PARSE.
;

10$:	CLRW	FAB$W_DEQ(R10)		; Clear the old DEQ value
	$OPEN	FAB=R10			; Open the file
	BLBC	R0,50$			; Branch on failure
	PUSHL	FAB$L_XAB(R10)		; Save XAB chain pointer
	CLRL	FAB$L_XAB(R10)		; Remove any XABs from chain
	$CLOSE	FAB=R10			; Close the file
	POPL	FAB$L_XAB(R10)		; Restore XAB chain pointer
	BLBC	R0,70$			; Branch on failure

;
; Return (main) Attributes, Extended Attributes, and (resultant) Name messages
; to partner as directed by request mask.
;

20$:	BSBW	SEND_OPTNL_MSGS		; Build and send optional DAP messages

;
; Send Acknowledge message to partner and exit state successfully.
;

30$:	BBC	#DAP$V_GEQ_V70,(R9),40$	; Send Acknowledge message only if
	BSBW	SEND_ACK		;  partner uses DAP since V7.0
40$:	BRW	EXIT_SUCCESS		; Exit state with success

;
; Error processing.
;

50$:	CMPW	R0,#<RMS$_FNF&^XFFFF>	; Convert RMS$_FNF to RMS$_ATR if
	BNEQ	60$			;  $SEARCH succeeded but subsequent
	MOVZWL	#<RMS$_ATR&^XFFFF>,R0	;  $OPEN failed because file does not
					;  exist although directory entry does
60$:	BRW	ERR_FILE_OPEN		; Return error in Status message
70$:	BRW	ERR_FILE_CLOS		; Return error in Status message

;+
; This routine maps a System Service code to an RMS completion code.
;-

MAP_SS_TO_RMS:				; Entry point
	CMPW	R1,#SS$_ACCONFLICT	; Check for file access locked error
	BNEQ	10$			; Branch if no match
	MOVZWL	#<RMS$_FLK&^XFFFF>,R0	; Convert to FLK (lower 16 bits)
	RSB				; Exit
10$:	CMPW	R1,#SS$_NOPRIV		; Check for privilege violation
	BNEQ	20$			; Branch if no match
	MOVZWL	#<RMS$_PRV&^XFFFF>,R0	; Convert to PRV (lower 16 bits)
	RSB				; Exit
20$:	CMPW	R1,#SS$_FILELOCKED	; Check for file deaccess locked error
	BNEQ	30$			; Branch if no match
	MOVZWL	#<RMS$_ACC&^XFFFF>,R0	; Convert to ACC (lower 16 bits)
	RSB				; Exit
30$:	CMPW	R1,#SS$_FCPREADERR	; Check for read attributes error
	BNEQ	40$			; Branch if no match; map to ATR
40$:	MOVZWL	#<RMS$_ATR&^XFFFF>,R0	; Convert to ATR (lower 16 bits)
	RSB				; Exit

	.SBTTL	FAL$LOAD_IMAGE

;++
; This routine performs the VMS system specific load image function to support
; the DCL command '$RUN node::file.exe'. To accomplish this, FAL ceases to use
; DAP after the file is opened to send the image file to the VMS image activator
; at the requesting node. Instead, FAL sends the image file in 512 byte chunks
; via QIOs until end-of-file is reached, then waits for the requesting node to
; disconnect the logical link.
;--

FAL$LOAD_IMAGE::			; Entry point
	$CONNECT RAB=R11		; Establish a record stream
	BLBC	R0,30$			; Branch on failure
	MOVL	FAL$Q_XMT+4(R8),R1	; Get address of transmit buffer
	MOVL	R1,FAL$Q_BLD+4(R8)	; Initialize address in BLD descriptor	
	MOVL	R1,RAB$L_UBF(R11)	; Initialize buffer address in RAB
	MOVW	FAL$W_DAPBUFSIZ(R8),-	; Put size of transmit buffer
		RAB$W_USZ(R11)		;  in RAB
	MOVAL	FAL$L_STB(R8),R7	; Get address of Statistics block
10$:	$GET	RAB=R11			; Get the next record
	BLBC	R0,20$			; Branch on error
	MOVZWL	RAB$W_RSZ(R11),R4	; Update BLD descriptor with size
	MOVL	R4,FAL$Q_BLD(R8)	;  of record (512 bytes for image files)
	$SETBIT	#FAL$V_LAST_MSG,(R8)	; Declare this last message to block
	BSBW	FAL$TRANSMIT		; Send record to partner
	INCL	FAL$L_XMT_DAT(R7)	; Increment XMT record/block count
	ADDL2	R4,FAL$L_XMT_USR(R7)	; Update XMT user data byte count
	BRB	10$			; Loop until EOF or error
20$:	CMPW	R0,#<RMS$_EOF&^XFFFF>	; Is it an end-of-file?
	BNEQ	30$			; Branch if not
	BRW	EXIT_SUCCESS		; Exit state with success
30$:	BRW	EXIT_FAILURE		; Exit state with failure

	.SBTTL	FAL$CONNECT

;++
; This routine performs the DAP CONNECT record stream function.
;--

FAL$CONNECT::				; Entry point
	CLRW	FAL$Q_RMS+2(R8)		; Initialize portion of RMS buffer
					;  descriptor for block I/O FTM
	$CONNECT RAB=R11		; Establish a record stream
	BLBC	R0,10$			; Branch on failure
	$SETBIT	#FAL$V_LAST_MSG,(R8)	; Declare this last message to block
	BSBW	SEND_ACK		; Send Acknowledge message
	BRW	EXIT_SUCCESS		; Exit state with success
10$:	BRW	ERR_FILE_XFER		; Return error in Status message


	.SBTTL	FAL$CHECK_FTM

;++
; This routine determines whether or not DAP file transfer mode has been
; specified. The file transfer mode flag stored in the FAL work area is used
; to form the state transition status code.
;--

FAL$CHECK_FTM::				; Entry point
	EXTZV	#FAL$V_FTM,#1,(R8),R0	; Form yes/no reply
	RSB				; Exit state with status code in R0

	.SBTTL	FAL$RETRV_RAM, FAL$RETRV_FTM

;++
; These routines perform both DAP GET record and DAP READ block functions
; (also called the record/block retrieval functions in the DAP specification).
;
; This section includes two action routine entry points (which together
; transfer control to four action routines) and support routines used by the
; action routines.
;
; FAL$RETRV_RAM and FAL$RETRV_FTM are entry points referenced in the
; state transition table which dispatch to four related but distinct input
; action routines that perform the requested data retrieval operation. Each
; of these routines is specialized to use a combination of either record I/O
; or block I/O in either record access mode (RAM) or file transfer mode (FTM).
;--

FAL$RETRV_RAM::				; Entry point
	BBS	#FAL$V_BLK_IO,(R8),10$	; Branch if block I/O access
	BRW	FAL$GET_RAM		; This is a GET in record access mode
10$:	BRW	FAL$READ_RAM		; This is a READ in record access mode

FAL$RETRV_FTM::				; Entry point
	BBS	#FAL$V_BLK_IO,(R8),10$	; Branch if block I/O access
	BRW	FAL$GET_FTM		; This is a GET in file transfer mode
10$:	BRW	FAL$READ_FTM		; This is a READ in file transfer mode

;+
; Compute new cumulative CRC checksum value for the file based on the current
; record/block and the previous cumulative CRC value (if the CRC checking
; option has been requested by the partner process).
;
; Note that this routine is called only from the GET and READ code paths.
;
; On input <R4,R6> is descriptor of user record/block.
; On output R0-R3 is destroyed and DAP$L_CRC_RSLT is updated.
;-

COMPUTE_XMT_CRC:			; Entry point
	BBC	#DAP$V_RET_CRC,-	; Branch if checksum option not
		FAL$B_ACCOPT(R8),10$	;  requested by accessing node
	CRC	W^FAL$CRC_TABLE,-	; Compute CRC value (destroying R0-R3)
		DAP$L_CRC_RSLT(R9),-	;  using result of previous CRC value
		R4,(R6)			;  calculation as initial CRC value
	MOVL	R0,DAP$L_CRC_RSLT(R9)	; Store resultant CRC value

;
; Update statistics relative to the transmission of user data to the partner
; process.
;

10$:	MOVAL	FAL$L_STB(R8),R7	; Get address of Statistics Block
	INCL	FAL$L_XMT_DAT(R7)	; Increment XMT record/block count
	ADDL2	R4,FAL$L_XMT_USR(R7)	; Update XMT user data byte count
	RSB				; Exit

;+
; Perform record terminator processing if the record format of the file is
; one of the three flavors of stream (i.e., stream, stream_LF, or stream_CR).
;
; On input R3 is address of last byte in record + 1.
; On output R0 is destroyed and R3 is updated if a terminator is appended.
;-

CHECK_STREAM:				; Entry point

	ASSUME	FAB$C_UDF EQ 0
	ASSUME	FAB$C_FIX EQ 1
	ASSUME	FAB$C_VAR EQ 2
	ASSUME	FAB$C_VFC EQ 3
	ASSUME	FAB$C_STM EQ 4
	ASSUME	FAB$C_STMLF EQ 5
	ASSUME	FAB$C_STMCR EQ 6

	$CASEB	SELECTOR=FAB$B_RFM(R10)- ;Dispatch on record format
		BASE=#FAB$C_STM-	;
		DISPL=<-		; Record format:
		    10$-		;  STM
		    40$-		;  STMLF
		    50$-		;  STMCR
		>			;  UDF, FIX, VAR, and VFC
	RSB				; Exit

;
; Stream format--append CRLF if no valid terminator character found.
;

10$:	TSTL	R4			; Branch if null record
	BEQL	20$			;
	MOVZBL	-1(R3),R0		; Get record terminator character
	CMPB	R0,#31			; Branch if out-of-range for a stream
	BGTRU	20$			;  terminator character
	BBS	R0,W^FAL$STM_MASK,30$	; Branch on valid stream terminator
20$:	MOVW	#CRLF,(R3)+		; Add CRLF to terminate record
30$:	RSB				; Exit

;
; Stream_LF format--append LF to record.
;

40$:	MOVB	#LF,(R3)+		; Add LF to terminate record
	RSB				; Exit

;
; Stream_CR format--append CR to record.
;

50$:	MOVB	#CR,(R3)+		; Add CR to terminate record
	RSB				; Exit

	.SBTTL	FAL$GET_RAM subsection

;+
; Perform the DAP GET record function in record access mode. This mode
; requires that an explicit Status message be returned with each Data message.
;-

FAL$GET_RAM::				; GET specific code segment
	MOVL	R3,R7			; Save address of start of buffer

;
; Build and send Data message to partner.
; If VFC format, record header is prefixed to the record in one data field.
;

	BBS	#DAP$V_GEQ_V56,(R9),10$	; Branch if partner uses DAP since V5.6
	$SETBIT	#FAL$V_LAST_MSG,(R8)	; Declare this last message to block
10$:	MOVL	#DAP$K_DAT_MSG,R0	; Get message type value
	BSBW	FAL$BUILD_HEAD		; Construct message header
	CLRB	(R3)+			; Do not return record number
	MOVL	R3,R6			; Save current address (i.e., start of
					;  DAP FILEDATA field in message)
	CMPB	FAB$B_RFM(R10),#FAB$C_VFC
	BNEQ	20$			; Branch if not VFC format
	MOVL	R3,RAB$L_RHB(R11)	; Store address of record header buffer
	MOVZBL	FAB$B_FSZ(R10),R0	; Get size of record header
	ADDL2	R0,R3			; Skip over RHB storage area in DAP msg
20$:	MOVL	R3,RAB$L_UBF(R11)	; Store buffer address
	SUBL3	R7,R3,R1		; Compute # bytes preceding data record
	SUBW3	R1,FAL$W_DAPBUFSIZ(R8),-; Compute max # bytes that can be read
		RAB$W_USZ(R11)		;  into rest of buffer
	CMPB	FAB$B_RFM(R10),#FAB$C_STM
	BLSSU	30$			; Branch if not STM, STMLF, or STMCR
	SUBW2	#2,RAB$W_USZ(R11)	; Reserve space in message buffer for
					;  subsequent addition of terminator(s)
30$:	$GET	RAB=R11			; Get the record
	BLBC	R0,50$			; Branch on failure
	MOVZWL	RAB$W_RSZ(R11),R4	; Get record size
	ADDL2	R4,R3			; Update next byte pointer
	BSBW	CHECK_STREAM		; Process stream file terminator
	SUBL3	R6,R3,R4		; Compute size of FILEDATA field
	BSBW	FAL$BUILD_TAIL		; Finish building message
	BSBW	COMPUTE_XMT_CRC		; Compute CRC value (destroying R0-R3)
					;  and update XMT data statistics
	BSBW	FAL$TRANSMIT		; Send Data message

;
; Send Status message to partner with RFA and BKT fields.
;

	BBC	#DAP$V_GEQ_V56,(R9),40$	; Branch if partner uses DAP before V5.6
	$SETBIT	#FAL$V_RET_RFA,(R8)	; Return RFA of record
	$SETBIT	#FAL$V_RET_RECN,(R8)	; Return record number (meaningful for
					;  REL file or fixed length SEQ file)
	MOVL	RAB$L_STS(R11),R0	; Restore success code
	BRW	EXIT_STS_SUC		; Convey success in Status message
40$:	BRW	EXIT_SUCCESS		; Exit state with success
50$:	BRW	ERR_FILE_XFER		; Return error in Status message

	.SBTTL	FAL$GET_FTM subsection

;+
; Perform the DAP GET record function in file transfer mode. This mode
; allows Data messages to be blocked together and pipelined on return.
;-

FAL$GET_FTM::				; GET specific code segment
	MOVL	R3,R7			; Save address of start of buffer

;
; Build and send Data message to partner.
; If VFC format, record header is prefixed to the record in one data field.
;

	MOVL	#DAP$K_DAT_MSG,R0	; Get message type value
	BSBW	FAL$BUILD_HEAD		; Construct message header
	CLRB	(R3)+			; Do not return record number
	MOVL	R3,R6			; Save current address (i.e., start of
					;  DAP FILEDATA field in message)
	CMPB	FAB$B_RFM(R10),#FAB$C_VFC
	BNEQ	10$			; Branch if not VFC format
	MOVL	R3,RAB$L_RHB(R11)	; Store address of record header buffer
	MOVZBL	FAB$B_FSZ(R10),R0	; Get size of record header
	ADDL2	R0,R3			; Skip over RHB storage area in DAP msg
10$:	MOVL	R3,RAB$L_UBF(R11)	; Store buffer address
	SUBL3	R7,R3,R1		; Compute # bytes preceding data record
	SUBW3	R1,FAL$W_DAPBUFSIZ(R8),-; Compute max # bytes that can be read
		RAB$W_USZ(R11)		;  into rest of buffer
	CMPB	FAB$B_RFM(R10),#FAB$C_STM
	BLSSU	20$			; Branch if not STM, STMLF, or STMCR
	SUBW2	#2,RAB$W_USZ(R11)	; Reserve space in message buffer for
					;  subsequent addition of terminator(s)
20$:	$GET	RAB=R11			; Get the record
	BLBC	R0,30$			; Branch on failure
	MOVZWL	RAB$W_RSZ(R11),R4	; Get record size
	ADDL2	R4,R3			; Update next byte pointer
	BSBW	CHECK_STREAM		; Process stream file terminator 
	SUBL3	R6,R3,R4		; Compute size of FILEDATA field
	BSBW	FAL$BUILD_TAIL		; Finish building message
	BSBW	COMPUTE_XMT_CRC		; Compute CRC value (destroying R0-R3)
					;  and update XMT data statistics
	BSBW	FAL$TRANSMIT		; Send Data message
	BRW	EXIT_SUCCESS		; Exit state with success
30$:	BRW	ERR_FILE_XFER		; Return error in Status message

	.SBTTL	FAL$READ_RAM subsection

;+
; Perform the DAP READ block function in record access mode. This mode
; requires that an explicit Status message be returned with each Data message.
;-

FAL$READ_RAM::				; READ specific code segment

;
; Build and send Data message to partner.
;

	BBS	#DAP$V_GEQ_V56,(R9),10$	; Branch if partner uses DAP since V5.6
	$SETBIT	#FAL$V_LAST_MSG,(R8)	; Declare this last message to block
10$:	MOVL	#DAP$K_DAT_MSG,R0	; Get message type value
	BSBW	FAL$BUILD_HEAD		; Construct message header
	CLRB	(R3)+			; Do not return virtual block number
	MOVL	R3,R6			; Save current address (i.e., start of
					;  DAP FILEDATA field in message)
	MOVL	R3,RAB$L_UBF(R11)	; Store buffer address
	MOVW	FAB$W_BLS(R10),-	; Request exactly one block
		RAB$W_USZ(R11)		;
	$READ	RAB=R11			; Read the block
	BLBC	R0,30$			; Branch on failure
	MOVZWL	RAB$W_RSZ(R11),R4	; Get number of bytes read
	ADDL2	R4,R3			; Update next byte pointer
	BSBW	FAL$BUILD_TAIL		; Finish building message
	BSBW	COMPUTE_XMT_CRC		; Compute CRC value (destroying R0-R3)
					;  and update XMT data statistics
	BSBW	FAL$TRANSMIT		; Send Data message

;
; Send Status message to partner with RFA field.
;

	BBC	#DAP$V_GEQ_V56,(R9),20$	; Branch if partner uses DAP before V5.6
	$SETBIT	#FAL$V_RET_RFA,(R8)	; Return RFA of record
	MOVL	RAB$L_STS(R11),R0	; Restore success code
	BRW	EXIT_STS_SUC		; Convey success in Status message
20$:	BRW	EXIT_SUCCESS		; Exit state with success
30$:	BRW	ERR_FILE_XFER		; Return error in Status message

	.SBTTL	FAL$READ_FTM subsection

;+
; Perform the DAP READ block function in file transfer mode. This mode
; allows Data messages to be blocked together and pipelined on return.
;-

FAL$READ_FTM::				; READ specific code segment
	CMPW	FAB$W_BLS(R10),#512	; Branch if we're using a nonstandard
	BNEQ	10$			;  block size
	BBC	#FAL$V_DIS_RBK,(R8),-	; Are multi-block reads desired?
		READ_FTM_RBK		;  Yes, take the normal path
10$:	BRW	READ_FTM_NORBK		;  No, read one block at a time

;+
; This code path utilizes multi-block reads from disk where the buffer size
; is determined by the value in FAL$B_RBK_CACHE. Note that use of this RMS
; multi_block cache optimization for block I/O file transfer mode retrieval
; necessitates an additional copy of the data in memory to be performed.
;-

READ_FTM_RBK:				; Enable buffering of RMS blocks
	TSTW	FAL$Q_RMS+2(R8)		; Branch if there is data in RMS
	BNEQ	10$			;  buffer to process
	MOVW	FAL$Q_RMS(R8),-		; Store buffer size
		RAB$W_USZ(R11)		;
	MOVL	FAL$Q_RMS+4(R8),-	; Store buffer address
		RAB$L_UBF(R11)		;
	$READ	RAB=R11			; Read specified number of blocks
	BLBC	R0,30$			; Branch on failure
	CLRL	RAB$L_BKT(R11)		; Zero VBN value to imply use of NBP
					;  in case Control message initiated
					;  file transfer with a non-zero VBN
	MOVW	RAB$W_RSZ(R11),-	; Save number of bytes actually read
		FAL$Q_RMS+2(R8)		;  into buffer
	MOVL	FAL$Q_RMS+4(R8),-	; Initialize next byte pointer to
		FAL$L_RMS_PTR(R8)	;  beginning of buffer

;
; Build and send Data message to partner.
;

10$:	MOVZWL	FAB$W_BLS(R10),R4	; Get block size
	CMPW	FAL$Q_RMS+2(R8),R4	; Is there at least one full block left?
	BGEQU	20$			; Branch if yes
	MOVZWL	FAL$Q_RMS+2(R8),R4	; Otherwise get partial block size
20$:	SUBW2	R4,FAL$Q_RMS+2(R8)	; Update remaining byte count
	MOVL	#DAP$K_DAT_MSG,R0	; Get message type value
	BSBW	FAL$BUILD_HEAD		; Construct message header
	CLRB	(R3)+			; Do not return virtual block number
	MOVL	R3,R6			; Save current address (i.e., start of
					;  DAP FILEDATA field in message)
	MOVC3	R4,@FAL$L_RMS_PTR(R8),(R3)
	MOVL	R1,FAL$L_RMS_PTR(R8)	; Copy data and update next byte pointer
	SUBL3	R6,R3,R4		; Compute size of FILEDATA field
	BSBW	FAL$BUILD_TAIL		; Finish building message
	BSBW	COMPUTE_XMT_CRC		; Compute CRC value (destroying R0-R3)
					;  and update XMT data statistics
	BSBW	FAL$TRANSMIT		; Send Data message
	BRW	EXIT_SUCCESS		; Exit state with success
30$:	BRW	ERR_FILE_XFER		; Return error in Status message

;+
; This code path does not use the RMS multi-block cache optimization for
; block I/O file transfer mode retrieval.
;
; Note that this represents the FAL functionality for the VMS V3.0 release.
;-

READ_FTM_NORBK:				; Disable buffering of RMS blocks

;
; Build and send Data message to partner.
;

	MOVL	#DAP$K_DAT_MSG,R0	; Get message type value
	BSBW	FAL$BUILD_HEAD		; Construct message header
	CLRB	(R3)+			; Do not return virtual block number
	MOVL	R3,R6			; Save current address (i.e., start of
					;  DAP FILEDATA field in message)
	MOVL	R3,RAB$L_UBF(R11)	; Store buffer address
	MOVW	FAB$W_BLS(R10),-	; Request exactly one block
		RAB$W_USZ(R11)		;
	$READ	RAB=R11			; Read the block
	BLBC	R0,10$			; Branch on failure
	CLRL	RAB$L_BKT(R11)		; Zero VBN value to imply use of NBP
					;  in case Control message initiated
					;  file transfer at a non-zero VBN
	MOVZWL	RAB$W_RSZ(R11),R4	; Get number of bytes read
	ADDL2	R4,R3			; Update next byte pointer
	BSBW	FAL$BUILD_TAIL		; Finish building message
	BSBW	COMPUTE_XMT_CRC		; Compute CRC value (destroying R0-R3)
					;  and update XMT data statistics
	BSBW	FAL$TRANSMIT		; Send Data message
	BRW	EXIT_SUCCESS		; Exit state with success
10$:	BRW	ERR_FILE_XFER		; Return error in Status message

	.SBTTL	FAL$STORE_RAM, FAL$STORE_FTM

;++
; These routines perform both DAP PUT record and DAP WRITE block functions
; (also called the record/block storage functions in the DAP specification).
;
; This section includes two action routine entry points (which together
; transfer control to four action routines) and support routines used by the
; action routines.
;
; FAL$STORE_RAM and FAL$STORE_FTM are entry points referenced in the
; state transition table which dispatch to four related but distinct output
; action routines that perform the requested data storage operation. Each
; of these routines is specialized to use a combination of either record I/O
; or block I/O in either record access mode (RAM) or file transfer mode (FTM).
;--

FAL$STORE_RAM::				; Entry point
	BBS	#FAL$V_BLK_IO,(R8),10$	; Branch if block I/O access
	BRW	FAL$PUT_RAM		; This is a PUT in record access mode
10$:	BRW	FAL$WRITE_RAM		; This is a WRITE in record access mode

FAL$STORE_FTM::				; Entry point
	BBS	#FAL$V_BLK_IO,(R8),10$	; Branch if block I/O access
	BRW	FAL$PUT_FTM		; This is a PUT in file transfer mode
10$:	BRW	FAL$WRITE_FTM		; This is a WRITE in file transfer mode

;+
; Compute new cumulative CRC checksum value for the file based on the current
; record/block and the previous cumulative CRC value (if the CRC checking
; option has been requested by the partner process).
;
; Note that this routine is called only from the PUT and WRITE code paths,
; and from the FAL$UPDATE routine.
;
; On input <R4,R5> is descriptor of user record/block.
; On output R0-R3 is destroyed and DAP$L_CRC_RSLT is updated.
;-

COMPUTE_RCV_CRC:			; Entry point
	BBC	#DAP$V_RET_CRC,-	; Branch if checksum option not
		FAL$B_ACCOPT(R8),10$	;  requested by accessing node
	CRC	W^FAL$CRC_TABLE,-	; Compute CRC value (destroying R0-R3)
		DAP$L_CRC_RSLT(R9),-	;  using result of previous CRC value
		R4,(R5)			;  calculation as initial CRC value
	MOVL	R0,DAP$L_CRC_RSLT(R9)	; Store resultant CRC value

;
; Update statistics relative to the reception of user data from the partner
; process.
;

10$:	MOVAL	FAL$L_STB(R8),R7	; Get address of Statistics Block
	INCL	FAL$L_RCV_DAT(R7)	; Increment RCV record/block count
	ADDL2	R4,FAL$L_RCV_USR(R7)	; Update RCV user data byte count
	RSB				; Exit

	.SBTTL	FAL$PUT_RAM subsection

;+
; Perform the DAP PUT record function in record access mode. This mode
; requires that an explicit Status message be returned.
;-

FAL$PUT_RAM::				; PUT specific code segment

;+
; Process the DAP record number field of the Data message.
; For random access by key value for a relative (or fixed length sequential)
; file it contains the relative record number. Otherwise, it is not used.
;-

	BBC	#DAP$V_X_RECNUM,(R9),10$; Branch if DAP record number field
					;  was null (as opposed to specified
					;  with a zero value)
	CMPB	RAB$B_RAC(R11),#RAB$C_KEY;Branch if not random access
	BNEQ	10$		  	;  by key value
	CMPB	FAB$B_ORG(R10),#FAB$C_IDX;Branch if IDX organization
	BEQL	10$			; Fall thru if SEQ or REL organization
	MOVL	DAP$L_RECNUM1(R9),-	; Update relative record number
		FAL$L_NUMBER(R8)	;  for next PUT operation

;+
; Process the DAP FILEDATA field.
; If VFC format, it contains the record header prefixed to the record.
;-

10$:	MOVQ	DAP$Q_FILEDATA(R9),R4	; Store record descriptor in <R4,R5>
	BSBW	COMPUTE_RCV_CRC		; Compute CRC value (destroying R0-R3)
					;  and update RCV data statistics
	CMPB	FAB$B_RFM(R10),#FAB$C_VFC
	BNEQ	20$			; Branch if not VFC format
	MOVL	R5,RAB$L_RHB(R11)	; Store address of record header buffer
	MOVZBL	FAB$B_FSZ(R10),R2	; Get size of record header
	SUBL2	R2,R4			; Compute size of record
	ADDL2	R2,R5			; Compute address of record
20$:	MOVW	R4,RAB$W_RSZ(R11)	; Store record size
	MOVL	R5,RAB$L_RBF(R11)	; Store record address
	$PUT	RAB=R11			; Put the record
	BLBC	R0,40$			; Branch on failure

;
; Send Status message to partner with RFA and BKT fields.
;

	BBC	#DAP$V_GEQ_V56,(R9),30$	; Branch if partner uses DAP before V5.6
	$SETBIT	#FAL$V_RET_RFA,(R8)	; Return RFA of record
	$SETBIT	#FAL$V_RET_RECN,(R8)	; Return record number (meaningful for
					;  REL file or fixed length SEQ file)
	BRW	EXIT_STS_SUC		; Convey success in Status message
30$:	BRW	EXIT_SUCCESS		; Exit state with success
40$:	BRW	ERR_FILE_XFER		; Return error in Status message

	.SBTTL	FAL$PUT_FTM subsection

;+
; Perform the DAP PUT record function in file transfer mode. This mode
; allows Data messages received to be blocked together and pipelined.
;-

FAL$PUT_FTM::				; PUT specific code segment

;+
; Process the DAP FILEDATA field.
; If VFC format, it contains the record header prefixed to the record.
;-

	MOVQ	DAP$Q_FILEDATA(R9),R4	; Store record descriptor in <R4,R5>
	BSBW	COMPUTE_RCV_CRC		; Compute CRC value (destroying R0-R3)
					;  and update RCV data statistics
	CMPB	FAB$B_RFM(R10),#FAB$C_VFC
	BNEQ	10$			; Branch if not VFC format
	MOVL	R5,RAB$L_RHB(R11)	; Store address of record header buffer
	MOVZBL	FAB$B_FSZ(R10),R2	; Get size of record header
	SUBL2	R2,R4			; Compute size of record
	ADDL2	R2,R5			; Compute address of record
10$:	MOVW	R4,RAB$W_RSZ(R11)	; Store record size
	MOVL	R5,RAB$L_RBF(R11)	; Store record address
	$PUT	RAB=R11			; Put the record
	BLBC	R0,20$			; Branch on failure
	BRW	EXIT_SUCCESS		; Exit state with success
20$:	BRW	ERR_FILE_XFER		; Return error in Status message

	.SBTTL	FAL$WRITE_RAM subsection

;+
; Perform the DAP WRITE block function in record access mode. This mode
; requires that an explicit Status message be returned.
;-

FAL$WRITE_RAM::				; WRITE specific code segment

;+
; Process the DAP record number field of the Data message.
; For random block I/O access, if the RECNUM field of the Data message is
; explicitly specified, it supersedes the KEY field of the Control message.
;-

	BBC	#DAP$V_X_RECNUM,(R9),10$; Branch if DAP record number field
					; was null (as opposed to specified
					; with a zero value)
	MOVL	DAP$L_RECNUM1(R9),-	; Store virtual block number in BKT
		RAB$L_BKT(R11)		;  field of RAB

;+
; Process the DAP FILEDATA field.
;-

10$:	MOVQ	DAP$Q_FILEDATA(R9),R4	; Store block descriptor in <R4,R5>
	BSBW	COMPUTE_RCV_CRC		; Compute CRC value (destroying R0-R3)
					;  and update RCV data statistics
	MOVW	R4,RAB$W_RSZ(R11)	; Store block size
	MOVL	R5,RAB$L_RBF(R11)	; Store block address
	$WRITE	RAB=R11			; Write the block
	BLBC	R0,30$			; Branch on failure

;
; Send Status message to partner with RFA field.
;

	BBC	#DAP$V_GEQ_V56,(R9),20$	; Branch if partner uses DAP before V5.6
	$SETBIT	#FAL$V_RET_RFA,(R8)	; Return RFA of record
	BRW	EXIT_STS_SUC		; Convey success in Status message
20$:	BRW	EXIT_SUCCESS		; Exit state with success
30$:	BRW	ERR_FILE_XFER		; Return error in Status message

	.SBTTL	FAL$WRITE_FTM subsection

;+
; Perform the DAP WRITE block function in file transfer mode. This mode
; allows Data messages received to be blocked together and pipelined.
;-

FAL$WRITE_FTM::				; WRITE specific code segment

;+
; Process the DAP FILEDATA field.
;-

	MOVQ	DAP$Q_FILEDATA(R9),R4	; Store block descriptor in <R4,R5>
	BSBW	COMPUTE_RCV_CRC		; Compute CRC value (destroying R0-R3)
					;  and update RCV data statistics
	CMPW	FAB$W_BLS(R10),#512	; Branch if we're using a nonstandard
	BNEQ	10$			;  block size
	BBC	#FAL$V_DIS_RBK,(R8),-	; Are multi-block writes desired?
		WRITE_FTM_RBK		;  Yes, take the normal path
10$:	BRW	WRITE_FTM_NORBK		;  No, write one block at a time

;+
; This code path utilizes multi-block writes to disk where the buffer size
; is determined by the value in FAL$B_RBK_CACHE. Note that use of this RMS
; multi_block cache optimization for block I/O file transfer mode storage
; necessitates an additional copy of the data in memory to be performed.
;-

WRITE_FTM_RBK:				; Enable buffering of RMS blocks
	BBC	#RAB$V_ASY,-		; Branch if no asynchronous write
		RAB$L_ROP(R11),20$	;  operation requires a wait call
	TSTW	RAB$L_STS(R11)		; Increment wait counter if write
	BNEQ	10$			;  operation is still pending (but
	INCL	W^FAL$GL_WRITWAIT	;  issue wait request regardless)
10$:	$WAIT	RAB=R11			; Wait for asynchronous write to finish
	$CLRBIT	#RAB$V_ASY,RAB$L_ROP(R11);Clear asynchronous operation flag
	BLBC	R0,40$			; Branch on write failure
20$:	ADDW2	R4,FAL$Q_RMS+2(R8)	; Update byte count
	MOVC3	R4,(R5),@FAL$L_RMS_PTR(R8)
	MOVL	R3,FAL$L_RMS_PTR(R8)	; Copy data and update next byte pointer
	SUBW3	FAL$Q_RMS+2(R8),-	; Compute number of unused bytes in RMS
		FAL$Q_RMS(R8),R0	;  buffer
	CMPW	R0,FAB$W_BLS(R10)	; Branch if there is at least one full
	BGEQU	30$			;  block left in RMS buffer
	MOVW	FAL$Q_RMS+2(R8),-	; Store buffer size
		RAB$W_RSZ(R11)		;
	MOVL	FAL$Q_RMS+4(R8),-	; Store buffer address
		RAB$L_RBF(R11)		;
	$SETBIT	#RAB$V_ASY,RAB$L_ROP(R11);Set asynchronous operation flag
	$WRITE	RAB=R11			; Write specified number of blocks
	BLBC	R0,40$			; Branch on failure
	CLRL	RAB$L_BKT(R11)		; Zero VBN value to imply use of NBP
					;  in case Control message initiated
					;  file transfer with a non-zero VBN
	CLRW	FAL$Q_RMS+2(R8)		; Initialize byte counter
	MOVL	FAL$Q_RMS+4(R8),-	; Initialize next byte pointer
		FAL$L_RMS_PTR(R8)	;
30$:	BRW	EXIT_SUCCESS		; Exit state with success
40$:	BRW	ERR_FILE_XFER		; Return error in Status message

;+
; This code path does not use the RMS multi-block cache optimization for
; block I/O file transfer mode storage.
;
; Note that this represents the FAL functionality for the VMS V3.0 release.
;-

WRITE_FTM_NORBK:			; Disable buffering of RMS blocks
	MOVW	R4,RAB$W_RSZ(R11)	; Store block size
	MOVL	R5,RAB$L_RBF(R11)	; Store block address
	$WRITE	RAB=R11			; Write the block
	BLBC	R0,10$			; Branch on failure
	CLRL	RAB$L_BKT(R11)		; Zero VBN value to imply use of NBP
					;  in case Control message initiated
					;  file transfer at a non-zero VBN
	BRW	EXIT_SUCCESS		; Exit state with success
10$:	BRW	ERR_FILE_XFER		; Return error in Status message

	.SBTTL	FAL$STORE_END

;++
; This routine completes any block I/O activity in progress in order to
; terminate file transfer mode.
;--

FAL$STORE_END::				; Entry point
	BBC	#FAL$V_BLK_IO,(R8),20$	; Branch if record mode access
	BBS	#FAL$V_DIS_RBK,(R8),20$	; Branch if RMS buffering is disabled
	TSTW	FAL$Q_RMS+2(R8)		; Branch if there is data in RMS
	BNEQ	10$			;  buffer to write to disk

;+
; Wait for previous write request to complete.
;-

	BBC	#RAB$V_ASY,-		; Branch if no asynchronous write
		RAB$L_ROP(R11),20$	;  operation requires a wait call
	$WAIT	RAB=R11			; Wait for asynchronous write to finish
	$CLRBIT	#RAB$V_ASY,RAB$L_ROP(R11);Clear asynchronous operation flag
	BLBC	R0,30$			; Branch on write failure
	BRB	20$			; Branch on success

;+
; Write out blocks already moved to the RMS buffer.
;-

10$:	MOVW	FAL$Q_RMS+2(R8),-	; Store buffer size
		RAB$W_RSZ(R11)		;
	MOVL	FAL$Q_RMS+4(R8),-	; Store buffer address
		RAB$L_RBF(R11)		;
	$WRITE	RAB=R11			; Write specified number of blocks
	BLBC	R0,30$			; Branch on failure
20$:	BRW	EXIT_SUCCESS		; Exit state with success
30$:	BRW	ERR_FILE_XFER		; Return error in Status message

	.SBTTL	FAL$BIT_BUCKET

;++
; This routine throws away any data that may be stored in the RMS buffer
; to support the skip record/block error recovery option for file transfer
; storage mode. (Note that the data has already been CRC checked when the
; Data message was processed, and the data buffered in memory).
;--

FAL$BIT_BUCKET::			; Entry point
	CLRW	FAL$Q_RMS+2(R8)		; Zero size in RMS buffer descriptor
	BRW	EXIT_SUCCESS		; Exit state with success


	.SBTTL	FAL$DISCARD_DAT

;++
; This routine computes the CRC checksum of the record/block just received
; and then throws away the data. It is called during file transfer storage
; mode error recovery where data in the pipe is discarded until (but CRC
; checked) until a synchronization point is reached (typically an Access
; Complete message is received).
;--

FAL$DISCARD_DAT::			; Entry point
	MOVQ	DAP$Q_FILEDATA(R9),R4	; Store block descriptor in <R4,R5>
	BSBW	COMPUTE_RCV_CRC		; Compute CRC value (destroying R0-R3)
					;  and update RCV data statistics
	BRW	EXIT_SUCCESS		; Exit state with success

	.SBTTL	FAL$UPDATE

;++
; This routine performs the DAP UPDATE record function.
;--

FAL$UPDATE::				; Entry point

;+
; Process the DAP FILEDATA field.
; If VFC format, it contains the record header prefixed to the record.
;-

	MOVQ	DAP$Q_FILEDATA(R9),R4	; Store record descriptor in <R4,R5>
	BSBW	COMPUTE_RCV_CRC		; Compute CRC value (destroying R0-R3)
					;  and update RCV data statistics
	CMPB	FAB$B_RFM(R10),#FAB$C_VFC
	BNEQ	10$			; Branch if not VFC format
	MOVL	R5,RAB$L_RHB(R11)	; Store address of record header buffer
	MOVZBL	FAB$B_FSZ(R10),R2	; Get size of record header
	SUBL2	R2,R4			; Compute size of record
	ADDL2	R2,R5			; Compute address of record
10$:	MOVW	R4,RAB$W_RSZ(R11)	; Store record size
	MOVL	R5,RAB$L_RBF(R11)	; Store record address
	$UPDATE	RAB=R11			; Update the record
	BLBC	R0,30$			; Branch on failure

;
; Send Status message to partner with RFA field.
;

	BBC	#DAP$V_GEQ_V56,(R9),20$	; Branch if partner uses DAP before V5.6
	$SETBIT	#FAL$V_RET_RFA,(R8)	; Return RFA of record
	BRW	EXIT_STS_SUC		; Convey success in Status message
20$:	BRW	EXIT_SUCCESS		; Exit state with success
30$:	BRW	ERR_FILE_XFER		; Return error in Status message

	.SBTTL	FAL$DELETE

;++
; This routine performs the DAP DELETE record function.
;--

FAL$DELETE::				; Entry point
	$DELETE RAB=R11			; Delete the record
	BLBC	R0,20$			; Branch on failure

;
; Send Status message to partner.
;

	BBC	#DAP$V_GEQ_V56,(R9),10$	; Branch if partner uses DAP before V5.6
	BRW	EXIT_STS_SUC		; Convey success in Status message
10$:	BRW	EXIT_SUCCESS		; Exit state with success
20$:	BRW	ERR_FILE_XFER		; Return error in Status message

	.SBTTL	FAL$FIND

;++
; This routine performs the DAP FIND record function.
;--

FAL$FIND::				; Entry point
	$FIND	RAB=R11			; Find the record
	BLBC	R0,20$			; Branch on failure

;
; Send Status message to partner with RFA and BKT fields.
;

	BBC	#DAP$V_GEQ_V56,(R9),10$	; Branch if partner uses DAP before V5.6
	$SETBIT	#FAL$V_RET_RFA,(R8)	; Return RFA of record
	$SETBIT	#FAL$V_RET_RECN,(R8)	; Return record number (meaningful for
					;  REL file or fixed length SEQ file)
	BRW	EXIT_STS_SUC		; Convey success in Status message
10$:	BRW	EXIT_SUCCESS		; Exit state with success
20$:	BRW	ERR_FILE_XFER		; Return error in Status message

	.SBTTL	FAL$DISPLAY

;++
; This routine performs the DAP DISPLAY file attributes function.
;
; Note:	RMS returns only XAB information on $DISPLAY. The DAP specification,
;	however, allows partner to request that the DAP Attributes and Name
;	messages be returned in addition to Extended Attributes messages.
;	If Attributes or Name messages are requested, they will be built from
;	information in the FAB and NAM blocks, respectively, that were updated
;	at open/create time.
;--

FAL$DISPLAY::				; Entry point
	CLRL	FAB$L_XAB(R10)		; Remove any XABs from chain
	MOVAL	FAB$L_XAB(R10),-	;
		FAL$L_CHAIN_NXT(R8)	; Save address of next chain pointer
	BSBW	CHAIN_RQST_XABS		; Add required XABs to XAB chain
	$DISPLAY FAB=R10		; Obtain attributes of the file
	BLBC	R0,10$			; Branch on failure
	BSBW	CHAIN_RQST_PRT2		; Fill in alterate ALLXABs and KEYXABs
					;  as directed by NOA and NOK values
	BLBC	R0,10$			; Branch on failure

;
; Return (main) Attributes, Extended Attributes, and (resultant) Name messages
; to partner as directed by request mask, terminated by an Acknowledge message.
;

	BSBW	SEND_OPTNL_MSGS		; Build and send optional DAP messages
	$SETBIT	#FAL$V_LAST_MSG,(R8)	; Declare this last message to block
	BSBW	SEND_ACK		; Send Acknowledge message
	BRW	EXIT_SUCCESS		; Exit state with success
10$:	BRW	ERR_FILE_XFER		; Return error in Status message

	.SBTTL	FAL$EXTEND

;++
; This routine performs the DAP EXTEND file allocation function.
;--

FAL$EXTEND::				; Entry point
	CLRL	FAB$L_XAB(R10)		; Remove any XABs from chain
	MOVAL	FAB$L_XAB(R10),-	;
		FAL$L_CHAIN_NXT(R8)	; Save address of next chain pointer
	BSBW	CHAIN_RECV_XABS		; Add received XABs to XAB chain
	$EXTEND FAB=R10			; Extend the file
	BLBC	R0,10$			; Branch on failure

;
; Return Allocation message(s) terminated by an Acknowledge message.
;

	BSBW	SEND_OPTNL_MSGS		; Build and send optional DAP messages
	$SETBIT	#FAL$V_LAST_MSG,(R8)	; Declare this last message to block
	BSBW	SEND_ACK		; Send Acknowledge message
	BRW	EXIT_SUCCESS		; Exit state with success
10$:	BRW	ERR_FILE_XFER		; Return error in Status message

	.SBTTL	FAL$REWIND
	.SBTTL	FAL$TRUNCATE, FAL$FLUSH
	.SBTTL	FAL$FREE, FAL$RELEASE

;++
; The following routines have separate entry points but share common code ...
;
; This routine performs the DAP REWIND file function.
;--

FAL$REWIND::				; Entry point
	$REWIND RAB=R11			; Rewind the record stream
	BRB	EXIT_STS_ALWAYS		; Join common code

;++
; This routine performs the DAP TRUNCATE file function.
;--

FAL$TRUNCATE::				; Entry point
	$TRUNCATE RAB=R11		; Truncate the file
	BRB	EXIT_STS_ALWAYS		; Join common code

;++
; This routine performs the DAP FLUSH file function.
;--

FAL$FLUSH::				; Entry point
	$FLUSH RAB=R11			; Flush I/O buffers and write modified
					;  file attributes
	BRB	EXIT_STS_ALWAYS		; Join common code

;++
; This routine performs the DAP FREE locked record function.
;--

FAL$FREE::				; Entry point
	$FREE RAB=R11			; Free all locked records
	BRB	EXIT_STS_ALWAYS		; Join common code

;++
; This routine performs the DAP RELEASE all locked records function.
;--

FAL$RELEASE::				; Entry point
	$RELEASE RAB=R11		; Release specified locked record
	BRB	EXIT_STS_ALWAYS		; Join common code

	.SBTTL	FAL$SPACE_BW, FAL$SPACE_FW

;++
; These routines perform the DAP SPACE functions, space-forward and
; space-backward.
;
; Note:	They return the actual # blocks spaced as an unsigned number obtained
;	from STV which may be non-zero for RMS$_NORMAL, RMS$_BOF, and RMS$_EOF
;	completion codes.
;--

FAL$SPACE_BW::				; Entry point for space backward
	MNEGL	RAB$L_BKT(R11),-	; DAP sends an absolute value,
		RAB$L_BKT(R11)		;  so negate it
FAL$SPACE_FW::				; Entry point for space forward
	$SPACE	RAB=R11			; Skip or backspace specified # blocks
	$SETBIT	#FAL$V_RET_RECN,(R8)	; Always return actual # blocks spaced
					;  as an unsigned number in RECNUM2
	MOVL	RAB$L_STV(R11),-	; Copy STV value to BKT field so that
		RAB$L_BKT(R11)		;  STV value will be returned in DAP
					;  RECNUM2 field per DAP spec

;
; Common exit path for $REWIND, $TRUNCATE, $FLUSH, $FREE, $RELEASE, and $SPACE.
;

EXIT_STS_ALWAYS:			; Check status of RMS function call
	BLBC	R0,10$			; Branch on failure

;
; Send Status message to partner.
;

	BRW	EXIT_STS_SUC		; Convey success in Status message
10$:	BRW	ERR_FILE_XFER		; Return error in Status message

	.SBTTL	FAL$DISCONNECT

;++
; This routine performs the DAP DISCONNECT record stream function
; (also called the end-of-stream function in the DAP specification).
;--

FAL$DISCONNECT::			; Entry point
	$DISCONNECT RAB=R11		; Destroy the record stream
	BLBC	R0,20$			; Branch on failure
	BBC	#DAP$V_GEQ_V42,(R9),10$	; Branch if partner uses DAP before V4.2
					;  (namely, DAP V4.1)
	BSBW	SEND_CMP		; Send Access Complete message
10$:	BRW	EXIT_SUCCESS		; Exit state with success
20$:	BRW	ERR_FILE_CLOS		; Return error in Status message

	.SBTTL	FAL$RESET, FAL$CHANGE

;++
; The following routines have separate entry points but share common code ...
;
; This routine performs the DAP RESET file function. RESET is similar to CLOSE
; except that the file is erased if it was created by this access operation.
; 
; Note:	Before DAP V6.0 this function was called PURGE.
;--

FAL$RESET::				; Entry point
	CMPB	FAL$B_ACCFUNC(R8),-	; Erase file if this was a
		#DAP$K_CREATE		;  file creation
	BEQL	10$			;
	CMPB	FAL$B_ACCFUNC(R8),-	;  or a
		#DAP$K_SUBMIT		;  file submission
	BNEQ	CLOSE_COMMON		;  operation
10$:	$SETBIT	#FAB$V_DLT,FAB$L_FOP(R10);Set delete-on-close bit
	BRB	CLOSE_COMMON		; Join common close code

;++
; This routine performs the DAP CHANGE file attributes on close function.
;--

FAL$CHANGE::				; Entry point

;
; Protection and Revision Date and Time XABs are input on close, so create an
; XAB chain with these XABs if DAP Protection and/or Date and Time messages
; have been received from partner.
;

	BICW2	#FAL$M_DATXAB,-		; Clear DATXAB flag as both DATXAB and
		FAL$W_RECEIVED(R8)	;  RDTXABs are generated when a Date
					;  and Time message is received
	BSBW	CHAIN_RECV_XABS		; Add received XABs to XAB chain
	BRB	CLOSE_COMMON		; Join common close code

	.SBTTL	FAL$CLOSE

;++
; This routine performs the DAP CLOSE file function.
;--

FAL$CLOSE::				; Entry point
	CLRL	FAB$L_XAB(R10)		; Remove any XABs from chain
	MOVAL	FAB$L_XAB(R10),-	;
		FAL$L_CHAIN_NXT(R8)	; Save address of next chain pointer

;
; Simulate support of the Revision Date and Time XAB on close if all of the
; following are true:
;   (1)	partner does not support change of revision information on close
;   (2)	this is a file creation operation
;   (3) a DAP Date and Time message was received on create
;
; If a Date and Time message is received on create, FAL$CREATE generates a
; RDTXAB for use on create. This XAB can now be used as input on close to
; preserve the revision date and time and revision number of the file that was
; established on create. This is the desired action for a file COPY operation
; where the remote node is not capable of specifying this action when the file
; is closed.
;

	BBS	#DAP$V_CHGTIMCLS,-	; Branch if partner supports change
		DAP$Q_SYSCAP(R9),-	;  of revision information on close
		CLOSE_COMMON		;
	CMPB	FAL$B_ACCFUNC(R8),-	; Branch if this was not a file
		#DAP$K_CREATE		;  creation operation
	BNEQ	CLOSE_COMMON		;
	MOVAL	FAL$L_RDTXAB(R8),R7	; Get address of RDTXAB
	CMPB	XAB$B_COD(R7),#XAB$C_RDT; Branch if RDTXAB has not been
	BNEQ	CLOSE_COMMON		;  initialized (and filled in on create)
	BSBW	CHAIN_THIS_XAB		; Add this XAB to XAB chain
	CLRL	XAB$L_NXT(R7)		; Be sure XAB chain is terminated as
					;  RDTXAB was on chain during create!

;+
; Common code path for FAL$RESET, FAL$CHANGE, and FAL$CLOSE.
;-

CLOSE_COMMON:				; Code common to all close operations

;
; Process optional DAP level CRC checksum value.
;

	BBC	#DAP$V_RET_CRC,-	; Branch if checksum option not
		FAL$B_ACCOPT(R8),10$	;  requested by accessing node
	BBC	#DAP$V_X_CHECK,(R9),10$	; Branch if checksum value not
					;  explicitly sent by partner
	CMPW	DAP$W_CHECK(R9),-	; Compare the checksums
		DAP$L_CRC_RSLT(R9)	;  (order 16 CRC)
	BEQLU	10$			; Branch if they match
	BSBW	FAL$CRC_LOGERR		; Log the DAP CRC error
	MOVZWL	#<RMS$_CRC&^XFFFF>,R0	; Stuff error code (lower 16 bits)
	BRB	30$			; Return CRC error to partner

;
; Close the file.
;

10$:	$CLOSE	FAB=R10			; Close the file
	BLBC	R0,30$			; Branch on failure
	MOVL	FAB$L_FOP(R10),R1	; Get FOP options
	BSBW	FAL$LOG_CLSMSG		; Log file close in print file
	BBS	#FAL$V_WILD,(R8),20$	; Branch if wildcard operation
	BSBW	SEND_CMP		; Send Access Complete message
20$:	BICL2	#<<FAB$M_DLT>!-		; Clear FOP options (DLT, SCF, SPL)
		  <FAB$M_SCF>!-		;  as wildcard file retrieval operation
		  <FAB$M_SPL>!-		;  will not re-initialize the FAB and
		0>,FAB$L_FOP(R10)	;  these bits are input to RMS for
					;  both open and close operations
	BRW	EXIT_SUCCESS		; Exit state with success
30$:	BRW	ERR_FILE_CLOS		; Return error in Status message

	.SBTTL	STATE TABLE ERROR ROUTINES

;++
; The following routines are called by the state table manager to report state
; table transition errors. These are due to an inappropriate DAP message being
; received for the current state, or an invalid or unsupported operation being
; requested for the current state. Each of these routines sends a Status message
; to the partner process.
;--


	.SBTTL	FAL$OUT_OF_SEQ

;++
; The DAP message being processed is incorrect (out-of-sequence) for the state.
;--

FAL$OUT_OF_SEQ::			; Entry point
	BRW	ERR_SYNCHRONIZE		; Return error in Status message


	.SBTTL	FAL$INV_ACCFUNC
	.SBTTL	FAL$INV_CTLFUNC
	.SBTTL	FAL$INV_CONFUNC, FAL$UNS_CONFUNC
	.SBTTL	FAL$INV_CMPFUNC

;++
; The ACCFUNC field value is invalid for state table context.
;--

FAL$INV_ACCFUNC::			; Entry point
	MOVL	#DAP$_ACCFUNC,R0	; Get field ID code
	BRW	ERR_INVALID		; Return error in Status message

;++
; The CTLFUNC field value is invalid for state table context.
;--

FAL$INV_CTLFUNC::			; Entry point
	MOVL	#DAP$_CTLFUNC,R0	; Get field ID code
	BRW	ERR_INVALID		; Return error in Status message

;++
; The CONFUNC field value is invalid for state table context.
;--

FAL$INV_CONFUNC::			; Entry point
	MOVL	#DAP$_CONFUNC,R0	; Get field ID code
	BRW	ERR_INVALID		; Return error in Status message

;++
; The ACCFUNC field value is unsupported for state table context.
;--

FAL$UNS_ACCFUNC::			; Entry point
	MOVL	#DAP$_ACCFUNC,R0	; Get field ID code
	BRW	ERR_UNSUPPORT		; Return error in Status message

;++
; The CONFUNC field value is unsupported for state table context.
;--

FAL$UNS_CONFUNC::			; Entry point
	MOVL	#DAP$_CONFUNC,R0	; Get field ID code
	BRW	ERR_UNSUPPORT		; Return error in Status message

;++
; The CMPFUNC field value is invalid for state table context.
;--

FAL$INV_CMPFUNC::			; Entry point
	MOVL	#DAP$_CMPFUNC,R0	; Get field ID code
	BRW	ERR_INVALID		; Return error in Status message

;++
; This routine returns a Status message with an unsupported-key-field error
; code. It is actually an internal support routine for FAL$DECODE_CTL.
;--

FAL$UNS_KEY::				; Entry point
	MOVL	#DAP$_KEY,R0		; Get field ID code
	BRW	ERR_UNSUPPORT		; Return error in Status message

	.SBTTL	SHARED SUPPORT ROUTINES


	.SBTTL	CHAIN_RQST_XABS

;++
; This routine initializes XABs and adds them to the XAB chain as necessary
; to obtain the requested file attribute information when the subsequent $OPEN
; is performed.
;
; Note:	Only requests for the DAP KEY, ALL, SUM, TIM, and PRO messages are
;	handled here by chaining in the appropriate XABs. Furthermore, only
;	primary Allocation and Key Definition XABs are chained into the list
;	at this time, as the NOA and NOK values from the Summary XAB are not
;	known yet.
;
; Inputs include:
;
;	FAL$W_DISPLAY
;	FAL$L_CHAIN_NXT
;--

CHAIN_RQST_XABS:			; Entry point
	MOVZWL	FAL$W_DISPLAY(R8),AP	; Copy display mask to scratch register
					;  (i.e., list of DAP Extended
					;  Attributes messages to return)
	CLRL	FAL$L_ALLXABINI(R8)	; Zero list of ALLXABs initialized
	CLRL	FAL$L_KEYXABINI(R8)	; Zero list of KEYXABs initialized
	BITW	#<<DAP$M_DSP_ALL>!-	; Branch if neither Allocation nor
		  <DAP$M_DSP_KEY>!-	;  Key Definition messages are to be
		0>,AP			;  returned
	BEQL	10$			;
	$SETBIT	#DAP$V_DSP_SUM,AP	; Include Summary XAB (to obtain NOA and
					;  NOK values) in case an indexed file
					;  is opened
10$:	CLRL	R6			; Indicate AID=0 and REF=0 for
					;  Allocation and Key Definition XABs

	ASSUME	DAP$V_DSP_ATT+1 EQ DAP$V_DSP_KEY
	ASSUME	DAP$V_DSP_KEY+1 EQ DAP$V_DSP_ALL
	ASSUME	DAP$V_DSP_ALL+1 EQ DAP$V_DSP_SUM
	ASSUME	DAP$V_DSP_SUM+1 EQ DAP$V_DSP_TIM
	ASSUME	DAP$V_DSP_TIM+1 EQ DAP$V_DSP_PRO

CHAIN_RQST_LOOP:			;
	FFS	#DAP$V_DSP_KEY,#5,AP,R0	; Get position of next bit set
	$CLRBIT	R0,AP			; Clear request bit just found
	PUSHAB	B^10$			; Push return address on stack
	$CASEB	SELECTOR=R0-		; Next XAB to add to chain:
		BASE=#DAP$V_DSP_KEY-	;
		DISPL=<-		;
		    FAL$INIT_KEYXAB-	;  Key Definition
		    FAL$INIT_ALLXAB-	;  Allocation
		    FAL$INIT_SUMXAB-	;  Summary
		    FAL$INIT_DATXAB-	;  Date and Time
		    FAL$INIT_PROXAB-	;  Protection
		>			;
	POPR	#^M<R0>			; Throw away loop return address
	RSB				; Exit
10$:	BSBW	CHAIN_THIS_XAB		; Add this XAB to XAB chain
	BRB	CHAIN_RQST_LOOP		; Handle next request

	.SBTTL	CHAIN_RQST_PRT2

;++
; This routine creates an XAB chain of alternate Allocation and Key Definition
; XABs (as required) and then calls $DISPLAY to fill them in.
;
; If an indexed file was opened and DAP Allocation and/or Key Definition
; messages are to be returned, then the NOA and NOK values from the Summary XAB
; are used to determine how may alternate XABs are required to be filled.
;--

CHAIN_RQST_PRT2:			; Entry point
	MOVL	#1,R0			; Assume success
	CMPB	FAB$B_ORG(R10),-	; Branch if not IDX organization
		#FAB$C_IDX		;
	BNEQ	50$			;
	BITW	#<<DAP$M_DSP_ALL>!-	; Branch if neither Allocation nor
		  <DAP$M_DSP_KEY>!-	;  Key Definition messages are to be
		0>,FAL$W_DISPLAY(R8)	;  returned
	BEQL	50$			;
	MOVAL	FAB$L_XAB(R10),-	; Get address of start of XAB chain
		FAL$L_CHAIN_NXT(R8)	;  and store it

;
; Initialize multiple Allocation XABs as required and chain them in.
;

	BBC	#DAP$V_DSP_ALL,-	; Branch if DAP Allocation message
		FAL$W_DISPLAY(R8),20$	;  is not requested
	MOVZBL	FAL$L_SUMXAB+XAB$B_NOA(R8),AP ; Get number of areas value
	CMPL	AP,#1			; Branch if there are no alternate
	BLEQU	20$			;  areas
	CLRL	R6			; Initialize area ID value
10$:	BSBW	FAL$INIT_ALLXAB		; Initialize next Allocation XAB
					;  on return R7 = address of XAB
	BLBC	R0,20$			; Branch on failure (AID too large)
	BSBW	CHAIN_THIS_XAB		; Add this XAB to XAB chain
	INCL	R6			; Increment area ID value
	SOBGTR	AP,10$			; Branch if more to process

;
; Initialize multiple Key Definition XABs (as required) and chain them in.
;

20$:	BBC	#DAP$V_DSP_KEY,-	; Branch if DAP Key Definition message
		FAL$W_DISPLAY(R8),40$	;  is not requested
	MOVZBL	FAL$L_SUMXAB+XAB$B_NOK(R8),AP ; Get number of keys value
	CMPL	AP,#1			; Branch if there are no alternate
	BLEQU	40$			;  keys
	CLRL	R6			; Initialize key of reference value
30$:	BSBW	FAL$INIT_KEYXAB		; Initialize next Key Definition XAB
					;  on return R7 = address of XAB
	BLBC	R0,40$			; Branch on failure (REF too large)
	BSBW	CHAIN_THIS_XAB		; Add this XAB to XAB chain
	INCL	R6			; Increment key of reference value
	SOBGTR	AP,30$			; Branch if more to process

;
; Obtain additional file attribute information.
;

40$:	$DISPLAY FAB=R10		; Fill in primary and alternate
					;  Allocation and Key Definition XABs
50$:	RSB				; Exit

	.SBTTL	CHAIN_RECV_XABS

;++
; This routine adds XABs to the XAB chain that were received from the partner
; process for use when a subsequent $CREATE, $EXTEND, or $CLOSE is performed.
;
; Note:	Only XABs generated from the DAP KEY, ALL, TIM, and PRO messages are
;	handled here by chaining in the appropriate XABs. However, in contrast
;	To CHAIN_RQST_XABs, multiple Allocation and Key Definition XABs are
;	chained into the list (if present).
;
; Inputs include:
;
;	FAL$W_RECEIVED
;	FAL$L_KEYXABINI
;	FAL$L_ALLXABINI
;	FAL$L_CHAIN_NXT
;--

CHAIN_RECV_XABS:			; Entry point
	MOVZWL	FAL$W_RECEIVED(R8),AP	; Copy received mask to scratch register
					;  (i.e., list of XABs generated from
					;  receipt of optional DAP messages)

	ASSUME	FAL$V_KEYXAB   EQ 0
	ASSUME	FAL$V_KEYXAB+1 EQ FAL$V_ALLXAB
	ASSUME	FAL$V_ALLXAB+1 EQ FAL$V_DATXAB
	ASSUME	FAL$V_DATXAB+1 EQ FAL$V_PROXAB
	ASSUME	FAL$V_PROXAB+1 EQ FAL$V_RDTXAB

CHAIN_RECV_LOOP:			;
	FFS	#FAL$V_KEYXAB,#5,AP,R0	; Get position of next bit set
	$CLRBIT	R0,AP			; Clear request bit just found
	$CASEB	SELECTOR=R0-		; Next XAB to add to chain:
		DISPL=<-		;
		    10$-		;  Key definition
		    20$-		;  Allocation
		    30$-		;  Date and Time
		    40$-		;  Protection
		    50$-		;  Revision Date and Time
		>			;
	RSB				; Exit

;
; Chain Key Definition XAB(s).
;

10$:	MOVL	FAL$L_KEYXABINI(R8),R5	; Put list of KEYXABs received in
					;  scratch register; at least one bit
					;  in range is guaranteed to be set
15$:	FFS	#0,#FAL$K_MAX_REF+1,R5,R6;Get REF value of next KEYXAB
	BEQL	CHAIN_RECV_LOOP		; Branch if mask exhausted
	$CLRBIT	R6,R5			; Clear bit just found
	MULL2	#FAL$K_KEYXAB,R6	; Using REF as an index, compute
	MOVAB	FAL$L_KEYXAB(R8)[R6],R7	;  address of KEYXAB to use
	BSBW	CHAIN_THIS_XAB		; Add this XAB to XAB chain
	BRB	15$			; Handle next alternate KEYXAB

;
; Chain Allocation XAB(s).
;

20$:	MOVL	FAL$L_ALLXABINI(R8),R5	; Put list of ALLXABs received in
					;  scratch register; at least one bit
					;  in range is guaranteed to be set
25$:	FFS	#0,#FAL$K_MAX_AID+1,R5,R6;Get AID value of next ALLXAB
	BEQL	CHAIN_RECV_LOOP		; Branch if mask exhausted
	$CLRBIT	R6,R5			; Clear bit just found
	MULL2	#FAL$K_ALLXAB,R6	; Using AID as an index, compute
	MOVAB	FAL$L_ALLXAB(R8)[R6],R7	;  address of ALLXAB to use
	BSBW	CHAIN_THIS_XAB		; Add this XAB to XAB chain
	BRB	25$			; Handle next alternate ALLXAB

;
; Chain Date and Time, Protection, and Revision Date and Time XABs.
;

30$:	MOVAL	FAL$L_DATXAB(R8),R7	; Get address of Date and Time XAB
	BRB	60$			;
40$:	MOVAL	FAL$L_PROXAB(R8),R7	; Get address of Protection XAB
	BRB	60$			;
50$:	MOVAL	FAL$L_RDTXAB(R8),R7	; Get address of Rev Date and Time XAB
60$:	BSBW	CHAIN_THIS_XAB		; Add this XAB to XAB chain
	BRB	CHAIN_RECV_LOOP		; Handle next request

	.SBTTL	CHAIN_THIS_XAB

;++
; This routine chains the specified XAB into the XAB chain.
;
; Inputs include:
;
;	R7 contains address of XAB
;
;	FAL$L_CHAIN_NXT
;--

CHAIN_THIS_XAB:				; Entry point
	MOVL	R7,@FAL$L_CHAIN_NXT(R8)	; Insert XAB address into XAB chain
	ADDL3	R7,#XAB$L_NXT,-		; Compute address of next chain pointer
		FAL$L_CHAIN_NXT(R8)	;  and save it
	RSB				; Exit


	.SBTTL	CHECK_FOR_PMR

;++
; This routine is intended to be called after an RMS file parse operation has
; been performed. It checks for the existence of a node name in the file
; specification, and if found, it returns an error if the FAL logging option
; to disable poor-man's routing (also called manual routing) has been selected.
;
; Note:	Poor-man's routing is an unsupported and undocumented feature.
;--

CHECK_FOR_PMR:				; Entry point
	BLBC	R0,10$			; Do not alter error status from
					;  previous RMS parse operation
	BBC	#NAM$V_NODE,-		; Exit if file specification did not
		FAL$L_NAM+NAM$L_FNB(R8),-; yield a node name (i.e., initiator
		10$			;  did not specify multiple node names)
	BBC	#FAL$V_DIS_PMR,(R8),10$	; Allow FAL to act as file access router
					;  unless feature is disabled by user
	MOVZWL	#<RMS$_NOD&^XFFFF>,R0	; Generate 'invalid node name' error
10$:	RSB				; Exit

	.SBTTL	SEND_ACK

;++
; Build and send Acknowledge message to partner.
;--

SEND_ACK:				; Entry point
	MOVL	#DAP$K_ACK_MSG,R0	; Get message type value
	BSBW	FAL$BUILD_HEAD		; Construct message header
					; There are no fields in message body!
	BSBW	FAL$BUILD_TAIL		; Finish building message
	BSBW	FAL$TRANSMIT		; Send Acknowledge message
	RSB				; Return


	.SBTTL	SEND_CMP

;++
; Build and send Access Complete message to partner.
; Declare this last message of a response sequence and exit state with success.
;--

SEND_CMP:				; Entry point
	$SETBIT	#FAL$V_LAST_MSG,(R8)	; Declare this last message to block
	MOVL	#DAP$K_CMP_MSG,R0	; Get message type value
	BSBW	FAL$BUILD_HEAD		; Construct message header
	MOVB	#DAP$K_RESPONSE,(R3)+	; Store CMPFUNC field
	BSBW	FAL$BUILD_TAIL		; Finish building message
	BSBW	FAL$TRANSMIT		; Send Access Complete message
	RSB				; Exit

	.SBTTL	SEND_OPTNL_MSGS

;++
; Build and send (main) Attributes, Extended Attributes, and Name messages to
; partner as directed by the request mask (FAL$W_DISPLAY).
;
; Note:	The Summary message will be sent before any of the other Extended
;	Attributes messages (per DAP V6.0 specification).
;
; Inputs include:
;
;	FAL$W_DISPLAY
;	FAL$L_KEYXABINI
;	FAL$L_ALLXABINI
;--

SEND_OPTNL_MSGS:			; Entry point
	MOVZWL	FAL$W_DISPLAY(R8),AP	; Copy display mask to scratch register
					;  (i.e., list of DAP Extended
					;  Attributes messages to return)

	ASSUME	DAP$V_DSP_ATT   EQ 0
	ASSUME	DAP$V_DSP_ATT+1 EQ DAP$V_DSP_KEY
	ASSUME	DAP$V_DSP_KEY+1 EQ DAP$V_DSP_ALL
	ASSUME	DAP$V_DSP_ALL+1 EQ DAP$V_DSP_SUM
	ASSUME	DAP$V_DSP_SUM+1 EQ DAP$V_DSP_TIM
	ASSUME	DAP$V_DSP_TIM+1 EQ DAP$V_DSP_PRO
	ASSUME	DAP$V_DSP_PRO+3 EQ DAP$V_DSP_NAM

	EXTZV	#DAP$V_DSP_KEY,#2,AP,R0	; Rearrange display mask to put
	EXTZV	#DAP$V_DSP_SUM,#1,AP,R1	;  Summary message ahead of
	INSV	R1,#DAP$V_DSP_KEY,#1,AP	;  Key Definition and
	INSV	R0,#DAP$V_DSP_ALL,#2,AP	;  Allocation messages
SEND_OPTNL_LOOP:			;
	FFS	#0,#DAP$V_DSP_NAM+1,AP,R0;Get position of next bit set
	$CLRBIT	R0,AP			; Clear request bit just found
	PUSHAB	B^50$			; Push return address on stack
	$CASEB	SELECTOR=R0-		; Next message:
		DISPL=<-		;
		    FAL$ENCODE_ATT-	;  Attributes
		    FAL$ENCODE_SUM-	;  Summary
		    10$-		;  Key Definition
		    20$-		;  Allocation
		    FAL$ENCODE_TIM-	;  Date and Time
		    FAL$ENCODE_PRO-	;  Protection
		    40$-		;  (reserved)
		    40$-		;  (reserved)
		    FAL$ENCODE_NAM-	;  (resultant) Name
		>			; Exit loop
	POPR	#^M<R0>			; Throw away loop return address
	RSB				; Exit
10$:	PUSHL	AP			; Save register
	MOVL	FAL$L_KEYXABINI(R8),AP	; Put list of KEYXABs initialized in
					;  scratch register; at least one bit
					;  is guaranteed to be set
15$:	FFS	#0,#FAL$K_MAX_REF+1,AP,R6;Get REF value of next KEYXAB
	BEQL	30$			; Branch if mask exhausted
	$CLRBIT	R6,AP			; Clear bit just found
	MULL3	R6,#FAL$K_KEYXAB,R0	; Using REF as an index, compute
	MOVAB	FAL$L_KEYXAB(R8)[R0],R7	;  address of KEYXAB to use
	BSBW	FAL$ENCODE_KEY		; Build next Key Definition message
	BSBW	FAL$TRANSMIT		; Send message just built
	BRB	15$			; Handle next alternate KEYXAB
20$:	PUSHL	AP			; Save register
	MOVL	FAL$L_ALLXABINI(R8),AP	; Put list of ALLXABs initialized in
					;  scratch register; at least one bit
					;  in range is guaranteed to be set
25$:	FFS	#0,#FAL$K_MAX_AID+1,AP,R6;Get AID value of next ALLXAB
	BEQL	30$			; Branch if mask exhausted
	$CLRBIT	R6,AP			; Clear bit just found
	MULL3	R6,#FAL$K_ALLXAB,R0	; Using AID as an index, compute
	MOVAB	FAL$L_ALLXAB(R8)[R0],R7	;  address of ALLXAB to use
	BSBW	FAL$ENCODE_ALL		; Build next Allocation message
	BSBW	FAL$TRANSMIT		; Send message just built
	BRB	25$			; Handle next alternate ALLXAB
30$:	POPL	AP			; Restore register
40$:	POPR	#^M<R0>			; Throw away loop return address
	BRB	SEND_OPTNL_LOOP		; Handle next request
50$:	BSBW	FAL$TRANSMIT		; Send message just built
	BRB	SEND_OPTNL_LOOP		; Loop until done

	.SBTTL	SEND_3PART_NAM

;++
; Build and send the (volume) Name, (directory) Name, and (file) Name messages
; to partner.
;
; On output R1-R7 and AP are destroyed.
;--

SEND_3PART_NAM:				; Entry point
	PUSHR	#^M<R0>			; Save status code
	MOVL	FAB$L_NAM(R10),AP	; Get address of NAM block

;+
; Return DAP (volume) Name message to partner.
; The volume string in this context means nodespec (if present) plus device name
; string.
;-

SEND_VOL_NAM:				;
	MOVQ	FAL$Q_VOLNAME(R8),R4	; <R4,R5> => previous volume name
	MOVZBL	NAM$B_NODE(AP),R6	; Get size of node name string
	ADDB2	NAM$B_DEV(AP),R6	; Add size of device name string
	MOVL	NAM$L_NODE(AP),R7	; <R6,R7> => current volume name
	CMPC5	R4,(R5),#0,R6,(R7)	; Branch if previous and current
	BEQL	SEND_DIR_NAM		;  strings match
	MOVL	R6,FAL$Q_VOLNAME(R8)	; It's a new one, so save it
	MOVC3	R6,(R7),(R5)		;  (making it the previous one)
	MOVZBL	#DAP$M_VOLNAME,R5	; Get name type parameter
	BSBW	FAL$ENCODE_NAM1		; Build (volume) Name message
	BSBW	FAL$TRANSMIT		; Send Name message
	CLRL	FAL$Q_DIRNAME(R8)	; Clear the directory spec to force
					; sending of directory name msg.

;+
; Return DAP (directory) Name message to partner.
;-

SEND_DIR_NAM:				;
	MOVQ	FAL$Q_DIRNAME(R8),R4	; <R4,R5> => previous directory name
	MOVZBL	NAM$B_DIR(AP),R6	; Get size of directory name string
	MOVL	NAM$L_DIR(AP),R7	; <R6,R7> => current directory name
	CMPC5	R4,(R5),#0,R6,(R7)	; Branch if previous and current
	BEQL	SEND_FIL_NAM		;  strings match
	MOVL	R6,FAL$Q_DIRNAME(R8)	; It's a new one, so save it
	MOVC3	R6,(R7),(R5)		;  (making it the previous one)
	MOVZBL	#DAP$M_DIRNAME,R5	; Get name type parameter
	BSBW	FAL$ENCODE_NAM1		; Build (directory) Name message
	BSBW	FAL$TRANSMIT		; Send Name message

;+
; Return DAP (file) Name message to partner.
; The file string in this context can be either:
;   (1)	file name plus file type plus file version strings concatenated,
;	which is the normal case, or
;   (2) quoted string (if FAL received a file specification of the form
;	nodespec::"foreign-filespec").
;-


SEND_FIL_NAM:				;
	MOVZBL	NAM$B_NAME(AP),R6	; Get size of file name string
	ADDB2	NAM$B_TYPE(AP),R6	; Add size of file type string
	ADDB2	NAM$B_VER(AP),R6	; Add size of file version string
	MOVL	NAM$L_NAME(AP),R7	; <R6,R7> => current file name
	MOVZBL	#DAP$M_FILNAME,R5	; Get name type parameter
	BSBW	FAL$ENCODE_NAM1		; Build (file) Name message
	BSBW	FAL$TRANSMIT		; Send Name message
	POPR	#^M<R0>			; Restore status code
	RSB				; Exit

	.SBTTL	SHARED STATE EXIT ROUTINES

;++
; Return DAP file open error.
; R0 contains RMS completion code on input.
;--

ERR_FILE_OPEN:				; Entry point
	MOVL	#DAP$_FILE_OPEN,R2	; Get DAP MACCODE value
	MOVL	FAB$L_STV(R10),R1	; Get status value from FAB
	BRB	ERR_FILE		; Send Status message

;++
; Return DAP file transfer error.
; R0 contains RMS completion code on input.
;--

ERR_FILE_XFER:				; Entry point
	MOVL	#DAP$_FILE_XFER,R2	; Get DAP MACCODE value
	MOVL	RAB$L_STV(R11),R1	; Get status value from RAB
	BRB	ERR_FILE		; Send Status message

;++
; Return DAP file close error.
; R0 contains RMS completion code on input.
;--

ERR_FILE_CLOS:				; Entry point
	MOVL	#DAP$_FILE_CLOS,R2	; Get DAP MACCODE value
	MOVL	FAB$L_STV(R10),R1	; Get status value from FAB
ERR_FILE:				;
	BEQL	10$			; Branch on zero STV
	BBC	#DAP$V_VAXVMS,(R9),10$	; Branch if partner is not VAX/VMS
	$SETBIT	#FAL$V_RET_STV,(R8)	; Request return of STV field in
					;  DAP Status message
10$:	BRB	EXIT_STS_FAIL		; Send Status message

;++
; Return DAP invalid error.
; R0 contains DAP field ID code on input.
;--

ERR_INVALID:				; Entry point
	MOVZBL	DAP$B_TYPE(R9),R1	; Get DAP message type
	MOVL	#DAP$_INVALID,R2	; Get DAP MACCODE value
	BRB	EXIT_STS_FAIL		; Send Status message

;++
; Return DAP unsupported error.
; R0 contains DAP field ID code on input.
;--

ERR_UNSUPPORT:				; Entry point
	MOVZBL	DAP$B_TYPE(R9),R1	; Get DAP message type
	MOVL	#DAP$_UNSUPPORT,R2	; Get DAP MACCODE value
	BRB	EXIT_STS_FAIL		; Send Status message

;++
; Return DAP message-out-of-sequence error.
;--

ERR_SYNCHRONIZE:			; Entry point
	MOVZBL	DAP$B_TYPE(R9),R1	; Get DAP message type
	MOVL	#DAP$_MSG_SYNC,R2	; Get DAP MACCODE value

;++
; Build and send (failure) Status message to partner.
; Declare this last message of a response sequence and exit state with failure.
; R0 contains RMS completion code on input.
;--

EXIT_STS_FAIL:				; Entry point
	$SETBIT	#FAL$V_LAST_MSG,(R8)	; Declare this last message to block
	BSBW	FAL$ENCODE_STS		; Build Status message
	BSBW	FAL$TRANSMIT		; Send Status message to partner

;++
; Exit state with failure.
;--

EXIT_FAILURE:				; Entry point
	CLRL	R0			; Signal state transition failure
	RSB				; Exit to state table manager

;++
; Build and send (success) Status message to partner.
; Declare this last message of a response sequence and exit state with success.
; R0 contains RMS (success) completion code on input.
;--

EXIT_STS_SUC:				; Entry point
	$SETBIT	#FAL$V_LAST_MSG,(R8)	; Declare this last message to block
	MOVL	#DAP$_SUCCESS,R2	; Get DAP MACCODE value
	BSBW	FAL$ENCODE_STS		; Build Status message
	BSBW	FAL$TRANSMIT		; Send Status message to partner

;++
; Exit state with success.
;--

EXIT_SUCCESS:				; Entry point
	MOVL	#1,R0			; Signal state transition success
	RSB				; Exit to state table manager

	.END				; End of module
