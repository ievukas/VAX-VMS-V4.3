MODULE DBGLANGOP (IDENT = 'V04-000') =

BEGIN

!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
! WRITTEN BY
!	Rich Title	Nov 1982
!
! MODULE FUNCTION
!	This module contains the routines that are used to evaluate the
!	following language operators in C: * (dereference), & (address of),
!	SIZEOF, and addition and subtraction involving pointers.
!
! MODIFIED BY
!	B. Becker	Nov 1983	! Add routines for Ada tick operator support
!       B. Becker	Dec 1983	! Add arithmetic routines for Scaled Binary.
!

REQUIRE 'SRC$:DBGPROLOG.REQ';

FORWARD ROUTINE
    DBG$ABS_FIXED	: NOVALUE,	! Perform the absolute value operation on Scaled Binary
    DBG$ADD_FIXED_FIXED	: NOVALUE,	! Perform the add operation on Scaled Binary
    DBG$C_ADD_TPTR_L	: NOVALUE,	! Add an integer to a pointer
    DBG$C_ADDRESS_OF	: NOVALUE,	! Address-of operator
    DBG$C_INDIRECTION,			! Indirection operator
    DBG$C_PRE_DECR_TPTR,		! --PTR
    DBG$C_PRE_INCR_TPTR,		! ++PTR
    DBG$C_SIZEOF,			! SIZEOF operator
    DBG$C_SUB_TPTR_L	: NOVALUE,	! Subtract an integer from a pointer
    DBG$C_SUB_TPTR_TPTR	: NOVALUE,	! Subtract two pointers
    DBG$DIV_FIXED_FIXED	: NOVALUE,	! Perform the divide operation on Scaled Binary
    DBG$ENUM_FIRST,			! Find first enumeration element
    DBG$ENUM_POS,			! Find position of enumeration element
    DBG$ENUM_SUCC,			! Find successor of enumeration element
    DBG$ENUM_VAL,			! Given position, find value of enum element
    DBG$EQL_FIXED_FIXED	: NOVALUE,	! Perform the equal evaluation on Scaled Binary
    DBG$EVAL_ADA_TICK,			! Evaluate an Ada tick operator
    DBG$GTR_FIXED_FIXED	: NOVALUE,	! Perform the greater than evaluation on Scaled Binary
    DBG$GEQ_FIXED_FIXED	: NOVALUE,	! Perform the greater than or equal evaluation on Scaled Binary
    DBG$LEQ_FIXED_FIXED	: NOVALUE,	! Perform the less than or equal evaluation on Scaled Binary
    DBG$LSS_FIXED_FIXED	: NOVALUE,	! Perform the less than evaluation on Scaled Binary
    DBG$MAKE_VALUE_DESC,		! Gets a DST value from a Data Type Comp. entry		
    DBG$MUL_FIXED_FIXED	: NOVALUE,	! Perform the multiply operation on Scaled Binary
    DBG$NEQ_FIXED_FIXED	: NOVALUE,	! Perform the not equal evaluation on Scaled Binary
    DBG$NORMALIZE_FIXED	: NOVALUE,	! Normalize a scaled binary
    DBG$PRED_ENUM	: NOVALUE,	! Return the Predecessor of the enumerated type		
    DBG$SUCC_ENUM	: NOVALUE,	! Return the Successor of the enumerated type		
    DBG$SUB_FIXED_FIXED	: NOVALUE,	! Perform the subtract operation on Scaled Binary
    DBG$TYPEID_TO_PRIMARY,		! Convert typeid to Primary
    DBG$UNARY_PLUS_FIXED: NOVALUE,	! Perform the unary plus operation on Scaled Binary
    DBG$UNARY_MINUS_FIXED: NOVALUE,	! Perform the unary minus operation on Scaled Binary
    MATCH_FIXED_BINARYS	: NOVALUE;	! Matches the scales of the fixed binarys

EXTERNAL
    DBG$GB_LANGUAGE: BYTE,		! Current language setting
    DBG$GL_CONVERT_TOKEN;		! Language value for call to EVAL_LANG_OPERATOR

LINKAGE
    JSB_R1 = JSB (REGISTER = 0, REGISTER = 1): PRESERVE (0, 1);

EXTERNAL ROUTINE
    DBG$BUILD_PRIMARY_SUBNODE: NOVALUE,	! Used in constructing Primary Descriptors
    DBG$CVT_CVTLH_R1: JSB_R1 NOVALUE,	! Convert longword to H_Float
    DBG$DATA_LENGTH,			! Obtain length from VMS descriptor
    DBG$EVAL_LANG_OPERATOR,		! Convert a primary to a value descriptor
    DBG$FILL_IN_VMS_DESC,		! Fills in the VMS desc. fields
    DBG$GET_BIF_ARGUMENTS,		! Obtain Ada tick operator arguments
    DBG$GET_TEMPMEM,			! Allocate temporary memory
    DBG$MAKE_SKELETON_DESC,		! Make up a descriptor.
    DBG$STA_ADDRESS_TO_REGDESCR,	! Obtain register descriptor
    DBG$STA_SYMSIZE: NOVALUE,		! Obtain length from SYMID
    DBG$STA_SYMTYPE: NOVALUE,		! Obtain type from symid
    DBG$STA_SYMVALUE,			! Obtain value of the symbol
    DBG$STA_TYP_ARRAY: NOVALUE,		! Obtain info about array
    DBG$STA_TYP_ENUM: NOVALUE,		! Obtain info about enumeration type
    DBG$STA_TYP_TYPEDPTR: NOVALUE,	! Obtain info about typed pointer
    DBG$STA_TYPEFCODE,			! Obtain FCODE from SYMID
    DBG$STA_TYP_SUBRNG: NOVALUE,	! Obtain Parent typeid for subrange
    DBG$TYPEID_FOR_ATOMIC,		! Obtain TYPEID for an atomic data type
    DBG$TYPEID_FOR_TPTR;		! Obtain TYPEID for TPTR data type

BUILTIN
    DIVH,
    EMUL;


GLOBAL ROUTINE DBG$ABS_FIXED (ARG_DESC, RESULT_DESC): NOVALUE =
!
! FUNCTION
!
!	This routine is called to perform the absolute value operation
!	on a scaled binary variable. 
!
! INPUTS
!
!	ARG_DESC	- points to the value descriptor representing the
!			  argument of the operation.
!	RESULT_DESC	- points to the value descriptor representing the result.
!			  of the operation.
!
! OUTPUTS
!
!	The result value descriptor is filled in.
!	No value is returned.
!	
    BEGIN

    MAP
        RESULT_DESC	: REF DBG$VALDESC,
        ARG_DESC	: REF DBG$VALDESC;


    .RESULT_DESC[DBG$L_VALUE_POINTER] = ABS(..ARG_DESC[DBG$L_VALUE_POINTER]);
    RESULT_DESC[DBG$B_VALUE_SCALE] = .ARG_DESC[DBG$B_VALUE_SCALE];
    RESULT_DESC[DBG$B_VALUE_DTYPE] = .ARG_DESC[DBG$B_VALUE_DTYPE];
    END;

GLOBAL ROUTINE DBG$ADD_FIXED_FIXED (ARG_DESC1, ARG_DESC2, RESULT_DESC): NOVALUE =
!
! FUNCTION
!
!	This routine is called to perform the add operation
!	on a scaled binary variable. 
!
! INPUTS
!
!	ARG_DESC1	- points to the value descriptor representing the
!			  left argument of the operation.
!	ARG_DESC2	- points to the value descriptor representing the
!			  right argument of the operation.
!	RESULT_DESC	- points to the value descriptor representing the result.
!			  of the operation.
!
! OUTPUTS
!
!	The result value descriptor is filled in.
!	No value is returned.
!	
    BEGIN

    MAP
        ARG_DESC1	: REF DBG$VALDESC,
        ARG_DESC2	: REF DBG$VALDESC,
        RESULT_DESC	: REF DBG$VALDESC;

    LOCAL
        RESULT_VALUE,
        SCALE,
        VAL_DESC1	: DBG$STG_DESC,
        VAL_DESC2	: DBG$STG_DESC,
        VALUE1,
        VALUE2;

    ! Set up working variables.  This way we don't mess up anything important.
    !
    CH$MOVE(DBG$K_STG_DESC_SIZE, ARG_DESC1[DBG$A_VALUE_VMSDESC], VAL_DESC1);
    CH$MOVE(DBG$K_STG_DESC_SIZE, ARG_DESC2[DBG$A_VALUE_VMSDESC], VAL_DESC2);

    VALUE1 = ..ARG_DESC1[DBG$L_VALUE_POINTER];
    VALUE2 = ..ARG_DESC2[DBG$L_VALUE_POINTER];
    VAL_DESC1[DSC$A_POINTER] = VALUE1;
    VAL_DESC2[DSC$A_POINTER] = VALUE2;

    DBG$NORMALIZE_FIXED(VAL_DESC1);
    DBG$NORMALIZE_FIXED(VAL_DESC2);

    MATCH_FIXED_BINARYS(VAL_DESC1, VAL_DESC2);

    ! Do the add.
    !
    RESULT_VALUE = .VALUE1 + .VALUE2;
    SCALE = .VAL_DESC1[DSC$B_SCALE];

    ! Has an overflow occured?
    !
    IF .RESULT_VALUE<31, 1, 0> NEQ .VALUE1<31, 1, 0> AND
       .RESULT_VALUE<31, 1, 0> NEQ .VALUE2<31, 1, 0>
    THEN
        BEGIN
        IF .RESULT_VALUE<0, 1, 0>
        THEN
            SIGNAL(DBG$_IFIXUND);
        RESULT_VALUE = .RESULT_VALUE ^ -1;
        SCALE = .SCALE + 1;
        RESULT_VALUE<31, 1, 0> = .VALUE1<31, 1, 0>;
        END;

    .RESULT_DESC[DBG$L_VALUE_POINTER] = .RESULT_VALUE;
    RESULT_DESC[DBG$B_VALUE_DTYPE] = DSC$K_DTYPE_L;
    RESULT_DESC[DBG$B_VALUE_SCALE] = .SCALE;

    END;

GLOBAL ROUTINE DBG$C_ADD_TPTR_L (ARG1_DESC, ARG2_DESC, RESULT_DESC): NOVALUE =
!
! FUNCTION
!
!	This routine is called from DBG$PERFORM_OPERATOR to do the
!	+ operator in C when one of the arguments is a pointer. 
!
! INPUTS
!
!	ARG1_DESC	- points to the value descriptor representing the left 
!			  argument of the + operator.
!	ARG2_DESC	- points to the value descriptor representing the right
!			  argument of the + operator.
!	RESULT_DESC	- points to the value descriptor representing the result.
!			  of the + operator.
!
! OUTPUTS
!
!	The result value descriptor is filled in.
!	No value is returned.
!	
    BEGIN
    MAP
    	ARG1_DESC	: REF DBG$VALDESC,
    	ARG2_DESC	: REF DBG$VALDESC,
    	RESULT_DESC	: REF DBG$VALDESC;

    LOCAL
    	ARG1_IS_TPTR,			! TRUE if first arg is typed pointer
    	ARG2_IS_TPTR,			! TRUE if second arg is typed pointer
    	BITSIZE,			! Size in bits of pointed to object
    	FCODE1,				! FCODE for first argument
    	FCODE2,				! FCODE for second argument
    	JUNK: VECTOR[4],		! Dummy output parameter
    	SCALE,				! Scale factor in the operation
    	SYMID,				! Points to a SYMID
    	TYPEID1,			! Points to a TYPEID
    	TYPEID2;			! Points to a TYPEID

    ! Obtain a typeid and fcode for the first argument.
    !
    TYPEID1 = .ARG1_DESC [DBG$L_DHDR_TYPEID];
    IF .TYPEID1 EQL 0
    THEN
    	FCODE1 = 0
    ELSE
    	FCODE1 = DBG$STA_TYPEFCODE (.TYPEID1);

    ! Obtain a typeid and fcode for the second argument.
    !
    TYPEID2 = .ARG2_DESC [DBG$L_DHDR_TYPEID];
    IF .TYPEID2 EQL 0
    THEN
    	FCODE2 = 0
    ELSE
    	FCODE2 = DBG$STA_TYPEFCODE (.TYPEID2);

    ! One of the two arguments must be of type array or typed pointer.
    ! The other must be an integer. Set the flag ARG1_IS_TPTR if the
    ! first argument is the one of type TPTR or array. Set the
    ! flag ARG2_IS_TPTR if the second argument is the one which is of
    ! type TPTR or array.
    !
    IF  .FCODE1 EQL RST$K_TYPE_ARRAY OR .FCODE1 EQL RST$K_TYPE_TPTR
    THEN
    	ARG1_IS_TPTR = TRUE
    ELSE
    	ARG1_IS_TPTR = FALSE;
    IF .FCODE2 EQL RST$K_TYPE_ARRAY OR .FCODE2 EQL RST$K_TYPE_TPTR
    THEN
    	ARG2_IS_TPTR = TRUE
    ELSE
    	ARG2_IS_TPTR = FALSE;

    ! Ensure that exactly one of the flags is TRUE.
    !
    IF .ARG1_IS_TPTR AND .ARG2_IS_TPTR
    THEN
    	$DBG_ERROR ('DBGLANGOP\both args are pointer');
    IF (NOT .ARG1_IS_TPTR) AND (NOT .ARG2_IS_TPTR)
    THEN
    	$DBG_ERROR ('DBGLANGOP\DBG$C_ADD_TPTR_L neither arg is pointer');

    ! Obtain a SYMID which describes the type of the object that
    ! the typed pointer points to.
    !
    IF .ARG1_IS_TPTR
    THEN
    	IF .FCODE1 EQL RST$K_TYPE_TPTR
    	THEN
    	    DBG$STA_TYP_TYPEDPTR (.TYPEID1, SYMID)
    	ELSE
    	    DBG$STA_TYP_ARRAY (.TYPEID1, JUNK[0], SYMID,  ! The JUNK parameters
    			       JUNK[1], JUNK[2], JUNK[3]) ! must be distinct
    							  ! addresses; see note
    							  ! in RSTTYPES
    ELSE 
    	IF .ARG2_IS_TPTR
        THEN
    	    IF .FCODE2 EQL RST$K_TYPE_TPTR
    	    THEN
    	        DBG$STA_TYP_TYPEDPTR (.TYPEID2, SYMID)
    	    ELSE
    	        DBG$STA_TYP_ARRAY (.TYPEID2, JUNK[0], SYMID, 
    				   JUNK[1], JUNK[2], JUNK[3]);

    ! Obtain the bitsize of the object. The scale factor for the addition
    ! is in bytes, so convert to bytes.
    !
    DBG$STA_SYMSIZE (.SYMID, BITSIZE);
    SCALE = (.BITSIZE+7) / 8;    

    ! Now perform the addition, scaling the appropriate operand.
    !
    IF .ARG1_IS_TPTR
    THEN
    	BEGIN
    	RESULT_DESC[DBG$L_VALUE_VALUE0] = 
    	             .ARG1_DESC[DBG$L_VALUE_VALUE0] +
    	    .SCALE * .ARG2_DESC[DBG$L_VALUE_VALUE0];
    	RESULT_DESC[DBG$L_DHDR_TYPEID] = .ARG1_DESC[DBG$L_DHDR_TYPEID];
    	END
    ELSE
    	BEGIN
    	RESULT_DESC[DBG$L_VALUE_VALUE0] = 
    	    .SCALE * .ARG1_DESC[DBG$L_VALUE_VALUE0] +
    	             .ARG2_DESC[DBG$L_VALUE_VALUE0];
    	RESULT_DESC[DBG$L_DHDR_TYPEID] = .ARG2_DESC[DBG$L_DHDR_TYPEID];
    	END;

    ! Signal an informational message informing the user that scaling has
    ! taken place.
    !
    SIGNAL(DBG$_SCALEADD, 2, .SCALE, 
    	(IF .ARG1_IS_TPTR 
    	 THEN UPLIT BYTE (%ASCIC 'right')
    	 ELSE UPLIT BYTE (%ASCIC 'left' )));
    END;

GLOBAL ROUTINE DBG$C_ADDRESS_OF (ARG_DESC, RESULT_DESC): NOVALUE =
!
! FUNCTION
!
!	This routine is called from DBG$PERFORM_OPERATOR to do the
!	& operator in C. 
!
! INPUTS
!
!	ARG_DESC	- points to the value descriptor representing the argument
!			  of the & operator.
!	RESULT_DESC	- points to the value descriptor representing the result.
!			  of the & operator.
!
! OUTPUTS
!
!	The result value descriptor is filled in.
!	No value is returned.
!	
    BEGIN
    MAP
    	ARG_DESC	: REF DBG$VALDESC,
    	RESULT_DESC	: REF DBG$VALDESC;

    LOCAL
    	REGDESCR: DBG$REGDESCR;

    ! Fill in the value field of the result value descriptor. Since we
    ! used the DBG$PRIM_TO_ADDR routine to convert the Primary to
    ! a value descriptor, address of the argument is already in
    ! the VALUE0 field of the input value descriptor. We thus only
    ! need to copy this address.
    !
    RESULT_DESC[DBG$L_VALUE_VALUE0] = .ARG_DESC[DBG$L_VALUE_VALUE0];

    ! Check for typeid of zero. This indicates that the argument was
    ! not an identifier (it was instead the result of an expression),
    ! and therefore we cannot apply & to it.
    !
    IF .ARG_DESC[DBG$L_DHDR_TYPEID] EQL 0
    THEN
    	SIGNAL (DBG$_AMPERSAND);

    ! Fill in the TYPEID field of the result. This typeid describes
    ! the type "pointer to type X", where X is the type of the 
    ! argument. A routine in RSTTYPES builds this typeid for us.
    !
    RESULT_DESC[DBG$L_DHDR_TYPEID] = 
    	DBG$TYPEID_FOR_TPTR (.ARG_DESC[DBG$L_DHDR_TYPEID]);

    ! Check for result being a register. This is an error since you
    ! cannot do & on a variable that is bound to a register.
    !
    REGDESCR = DBG$STA_ADDRESS_TO_REGDESCR (.RESULT_DESC[DBG$L_VALUE_VALUE0]);
    IF .REGDESCR NEQ 0
    THEN
    	SIGNAL (DBG$_ADDRREG, 1, .REGDESCR[DBG$B_REGD_REGNUM]);

    RETURN;    				
    END;

GLOBAL ROUTINE DBG$C_INDIRECTION (ARG_DESC) =
!
! FUNCTION
!
!	This routine is called from DBG$PERFORM_OPERATOR to do the
!	* operation in C.
!
! INPUTS
!
!	ARG_DESC	- points to the value descriptor representing the argument
!			  of the indirection operation.
!
! OUTPUTS
!
!	A Primary Descriptor is constructed out of temporary memory representing
!	the result of the indirection. A pointer to this Primary Descriptor
!	is returned.
!	
    BEGIN
    MAP
    	ARG_DESC	: REF DBG$VALDESC;
    
    LOCAL
    	ADDRESS,			! Address of pointed-to object
    	ARG_TYPEID,			! TYPEID for argument
    	FCODE,				! FCODE for argument
    	JUNK: VECTOR[4],		! unused output parameters
    	RESULT_TYPEID;			! TYPEID for result


    ! Determine whether the object is a typed pointer or an array.
    !
    ARG_TYPEID = .ARG_DESC[DBG$L_DHDR_TYPEID];
    FCODE = DBG$STA_TYPEFCODE(.ARG_TYPEID);

    ! Given the argument TYPEID, obtain a typeid for the pointed-to
    ! object. A new typeid will be created for this anonymous object.
    !
    IF .FCODE EQL RST$K_TYPE_TPTR
    THEN
        DBG$STA_TYP_TYPEDPTR (.ARG_TYPEID, RESULT_TYPEID)
    ELSE IF .FCODE EQL RST$K_TYPE_ARRAY
    THEN
    	DBG$STA_TYP_ARRAY (.ARG_TYPEID, JUNK[0], RESULT_TYPEID,
    			    JUNK[1], JUNK[2], JUNK[3])
    ELSE
    	$DBG_ERROR ('DBGLANGOP\DBG$C_INDIRECTION arg must be pointer or array');

    ! Determine the address of the object. The value of the pointer
    ! is the address of the pointed-to object. We have already checked
    ! that the argument is of type "pointer", so we assume its longword
    ! value is sitting in the normal "VALUE0" field of the descriptor,
    ! and we don't bother to do any further type checking, type conversions,
    ! bitfield extractions, or whatever.
    !
    ADDRESS = .ARG_DESC[DBG$L_VALUE_VALUE0];

    ! Convert this TYPEID to a Primary, and return a pointer to this
    ! Primary.
    !
    RETURN DBG$TYPEID_TO_PRIMARY (.RESULT_TYPEID, .ADDRESS);
    END;

GLOBAL ROUTINE DBG$C_PRE_DECR_TPTR (ARG_DESC) =
!
! FUNCTION
!
    BEGIN
    MAP
    	ARG_DESC: REF DBG$VALDESC;
    0
    END;

GLOBAL ROUTINE DBG$C_PRE_INCR_TPTR (ARG_DESC) =
! 
! FUNCTION
!
    BEGIN
    MAP
    	ARG_DESC: REF DBG$VALDESC;
    0
    END;

GLOBAL ROUTINE DBG$C_SIZEOF (ARG_DESC) =
!
! FUNCTION
!
!	This routine is called from DBG$PERFORM_OPERATOR to do the
!	SIZEOF operation in C.
!
! INPUTS
!
!	ARG_DESC	- points to the value descriptor representing the argument
!			  of the SIZEOF operator.
!
! OUTPUTS
!
!	The return value is the result of the SIZEOF operation. This result
!	is the size in bytes of its argument.
!	
    BEGIN
    MAP
    	ARG_DESC	: REF DBG$VALDESC;

    LOCAL
    	BIT_SIZE;	! Size in bits of the argument

    ! Try obtaining the size from the SYMID.
    !
    IF .ARG_DESC[DBG$L_DHDR_SYMID0] NEQ 0
    THEN
    	DBG$STA_SYMSIZE (.ARG_DESC[DBG$L_DHDR_SYMID0], BIT_SIZE)

    ! Try obtaining the size from the TYPEID.
    !
    ELSE IF .ARG_DESC[DBG$L_DHDR_TYPEID] NEQ 0
    THEN
    	DBG$STA_SYMSIZE (.ARG_DESC[DBG$L_DHDR_TYPEID], BIT_SIZE)

    ! Try obtaining the size from the VMS descriptor.
    !
    ELSE IF .ARG_DESC[DBG$B_DHDR_FCODE] EQL RST$K_TYPE_ATOMIC
         OR .ARG_DESC[DBG$B_DHDR_FCODE] EQL RST$K_TYPE_DESCR
    THEN
    	BIT_SIZE = DBG$DATA_LENGTH (ARG_DESC[DBG$A_VALUE_VMSDESC])

    ! If the value descriptor did not have a symid or a typeid, and
    ! it was not an atomic or vax-standard descriptor type, then
    ! we are unable to determine the bit size. This situation should
    ! not arise, so we signal an error.
    !
    ELSE
    	$DBG_ERROR ('DBGLANGOP\DBG$C_SIZEOF cannot determine bitsize: typeid lost');

    ! Return the size in bytes.
    !
    RETURN .BIT_SIZE / 8;
    END;

GLOBAL ROUTINE DBG$C_SUB_TPTR_L (ARG1_DESC, ARG2_DESC, RESULT_DESC): NOVALUE =
!
! FUNCTION
!
!	This routine is called from DBG$PERFORM_OPERATOR to do the
!	- operator in C when one of the arguments is a pointer. 
!
! INPUTS
!
!	ARG1_DESC	- points to the value descriptor representing the left 
!			  argument of the - operator.
!	ARG2_DESC	- points to the value descriptor representing the right
!			  argument of the - operator.
!	RESULT_DESC	- points to the value descriptor representing the result.
!			  of the - operator.
!
! OUTPUTS
!
!	The result value descriptor is filled in.
!	No value is returned.
!	
    BEGIN
    MAP
    	ARG1_DESC	: REF DBG$VALDESC,
    	ARG2_DESC	: REF DBG$VALDESC,
    	RESULT_DESC	: REF DBG$VALDESC;

    LOCAL
    	BITSIZE,			! Size in bits of pointed to object
    	FCODE1,				! FCODE for first argument
    	JUNK: VECTOR[4],		! Dummy output parameter
    	SCALE,				! Scale factor in the operation
    	SYMID,				! Points to a SYMID
    	TYPEID1;			! Points to a TYPEID

    ! Obtain a typeid and fcode for the first argument.
    !
    TYPEID1 = .ARG1_DESC [DBG$L_DHDR_TYPEID];
    IF .TYPEID1 EQL 0
    THEN
    	BEGIN
    	$DBG_ERROR ('DBGLANGOP\DBG$C_SUB_TPTR_L no typeid for first arg')
    	END
    ELSE
    	FCODE1 = DBG$STA_TYPEFCODE (.TYPEID1);

    ! Obtain a SYMID which describes the type of the object that
    ! the typed pointer points to.
    !
    IF .FCODE1 EQL RST$K_TYPE_TPTR
    THEN
        DBG$STA_TYP_TYPEDPTR (.TYPEID1, SYMID)
    ELSE
    	DBG$STA_TYP_ARRAY (.TYPEID1, JUNK[0], SYMID,
    			    JUNK[1], JUNK[2], JUNK[3]);

    ! Obtain the bitsize of the object. The scale factor for the addition
    ! is in bytes, so convert to bytes.
    !
    DBG$STA_SYMSIZE (.SYMID, BITSIZE);
    SCALE = (.BITSIZE+7) / 8;    

    ! Now perform the subtraction, scaling the second operand.
    !
    RESULT_DESC[DBG$L_VALUE_VALUE0] = 
    	         .ARG1_DESC[DBG$L_VALUE_VALUE0] -
    	.SCALE * .ARG2_DESC[DBG$L_VALUE_VALUE0];
    RESULT_DESC[DBG$L_DHDR_TYPEID] = .ARG1_DESC[DBG$L_DHDR_TYPEID];

    ! Signal an informational telling the user that a scale factor
    ! was applied.
    !
    SIGNAL(DBG$_SCALESUB, 2, .SCALE, UPLIT BYTE(%ASCIC 'right argument'));
    END;

GLOBAL ROUTINE DBG$C_SUB_TPTR_TPTR (ARG1_DESC, ARG2_DESC, RESULT_DESC): NOVALUE =
!
! FUNCTION
!
!	This routine is called from DBG$PERFORM_OPERATOR to do the
!	- operator in C when both of the arguments are pointers. 
!
! INPUTS
!
!	ARG1_DESC	- points to the value descriptor representing the left 
!			  argument of the - operator.
!	ARG2_DESC	- points to the value descriptor representing the right
!			  argument of the - operator.
!	RESULT_DESC	- points to the value descriptor representing the result.
!			  of the - operator.
!
! OUTPUTS
!
!	The result value descriptor is filled in.
!	No value is returned.
!	
    BEGIN
    MAP
    	ARG1_DESC	: REF DBG$VALDESC,
    	ARG2_DESC	: REF DBG$VALDESC,
    	RESULT_DESC	: REF DBG$VALDESC;

    LOCAL
    	ARG1_IS_TPTR,			! TRUE if first arg is typed pointer
    	ARG2_IS_TPTR,			! TRUE if second arg is typed pointer
    	BITSIZE1,			! Size in bits of pointed to object
    	BITSIZE2,			! Size in bits of pointed to object
    	FCODE1,				! FCODE for first argument
    	FCODE2,				! FCODE for second argument
    	JUNK: VECTOR[4],		! Dummy output parameter
    	SCALE,				! Scale factor in the operation
    	SYMID1,				! Points to a SYMID
    	SYMID2,				! Points to a SYMID
    	TYPEID1,			! Points to a TYPEID
    	TYPEID2;			! Points to a TYPEID

    ! Obtain a typeid and fcode for the first argument.
    !
    TYPEID1 = .ARG1_DESC [DBG$L_DHDR_TYPEID];
    IF .TYPEID1 EQL 0
    THEN
    	BEGIN
    	$DBG_ERROR ('DBGLANGOP\DBG$C_SUB_TPTR_TPTR no typeid for first arg')
    	END
    ELSE
    	FCODE1 = DBG$STA_TYPEFCODE (.TYPEID1);

    ! Obtain a typeid and fcode for the second argument.
    !
    TYPEID2 = .ARG2_DESC [DBG$L_DHDR_TYPEID];
    IF .TYPEID2 EQL 0
    THEN
    	BEGIN
    	$DBG_ERROR ('DBGLANGOP\DBG$C_SUB_TPTR_TPTR no typeid for second arg')
    	END
    ELSE
    	FCODE2 = DBG$STA_TYPEFCODE (.TYPEID2);

    ! Both arguments must be of type array or TPTR.
    !
    IF  .FCODE1 NEQ RST$K_TYPE_ARRAY AND .FCODE1 NEQ RST$K_TYPE_TPTR
    THEN
    	BEGIN
    	$DBG_ERROR ('DBGLANGOP\DBG$C_SUB_TPTR_TPTR second arg is not ptr')
    	END;
    IF .FCODE2 NEQ RST$K_TYPE_ARRAY AND .FCODE2 NEQ RST$K_TYPE_TPTR
    THEN
    	BEGIN
    	$DBG_ERROR ('DBGLANGOP\DBG$C_SUB_TPTR_TPTR second arg is not ptr')
    	END;

    ! Obtain a SYMID which describes the type of the object that
    ! the typed pointer points to.
    !
    IF .FCODE1 EQL RST$K_TYPE_TPTR
    THEN
        DBG$STA_TYP_TYPEDPTR (.TYPEID1, SYMID1)
    ELSE
    	DBG$STA_TYP_ARRAY (.TYPEID1, JUNK[0], SYMID1, 
    			    JUNK[1], JUNK[2], JUNK[3]);
    IF .FCODE2 EQL RST$K_TYPE_TPTR
    THEN
        DBG$STA_TYP_TYPEDPTR (.TYPEID2, SYMID2)
    ELSE
        DBG$STA_TYP_ARRAY (.TYPEID2, JUNK[0], SYMID2, 
    			    JUNK[1], JUNK[2], JUNK[3]);

    ! Check for compatible pointers (?)
    !
    !<<<---------------------------------

    ! Obtain the bitsize of the objects. The scale factor for the addition
    ! is in bytes, so convert to bytes.
    !
    DBG$STA_SYMSIZE (.SYMID1, BITSIZE1);
    DBG$STA_SYMSIZE (.SYMID2, BITSIZE2);
    IF .BITSIZE1 NEQ .BITSIZE2
    THEN
    	SIGNAL (DBG$_INCOMPPTR);
    SCALE = (.BITSIZE1+7) / 8;    
    IF .SCALE EQL 0
    THEN
    	$DBG_ERROR ('DBGLANGOP\DBG$SUB_TPTR_TPTR scale factor of zero');

    ! Now perform the subtraction, scaling the result.
    !
    RESULT_DESC[DBG$L_VALUE_VALUE0] = 
    	(.ARG1_DESC[DBG$L_VALUE_VALUE0] - .ARG2_DESC[DBG$L_VALUE_VALUE0]) /
    	    .SCALE;
    
    ! Signal an informational telling the user that scaling was applied
    ! to the result.
    !
    SIGNAL(DBG$_SCALESUB, 2, .SCALE, UPLIT BYTE (%ASCIC 'result'));
    END;

GLOBAL ROUTINE DBG$DIV_FIXED_FIXED (ARG_DESC1, ARG_DESC2, RESULT_DESC): NOVALUE =
!
! FUNCTION
!
!	This routine is called to perform the divide operation
!	on a scaled binary variable. 
!
! INPUTS
!
!	ARG_DESC1	- points to the value descriptor representing the
!			  left argument of the operation.
!	ARG_DESC2	- points to the value descriptor representing the
!			  right argument of the operation.
!	RESULT_DESC	- points to the value descriptor representing the result.
!			  of the operation.
!
! OUTPUTS
!
!	The result value descriptor is filled in.
!	No value is returned.
!	
    BEGIN

    MAP
        ARG_DESC1	: REF DBG$VALDESC,
        ARG_DESC2	: REF DBG$VALDESC,
        RESULT_DESC	: REF DBG$VALDESC;

    LOCAL
        RESULT_VALUE,
        SCALE,
        SIGN,
        TEMP_RESULT	: VECTOR [4,LONG],
        TEMP_VAL1	: VECTOR [4,LONG],
        TEMP_VAL2	: VECTOR [4,LONG],
        TEMP_DESC	: DBG$STG_DESC,
        VAL_DESC1	: DBG$STG_DESC,
        VAL_DESC2	: DBG$STG_DESC,
        VALUE1,
        VALUE2;

    ! Set up working variables.  This way we don't mess up anything important.
    !
    CH$MOVE(DBG$K_STG_DESC_SIZE, ARG_DESC1[DBG$A_VALUE_VMSDESC], VAL_DESC1);
    CH$MOVE(DBG$K_STG_DESC_SIZE, ARG_DESC2[DBG$A_VALUE_VMSDESC], VAL_DESC2);

    VALUE1 = ..ARG_DESC1[DBG$L_VALUE_POINTER];
    VALUE2 = ..ARG_DESC2[DBG$L_VALUE_POINTER];

    IF .VALUE2 EQL 0
    THEN
        SIGNAL(DBG$_DIVBYZERO);

    VAL_DESC1[DSC$A_POINTER] = VALUE1;
    VAL_DESC2[DSC$A_POINTER] = VALUE2;

    DBG$NORMALIZE_FIXED(VAL_DESC1);
    DBG$NORMALIZE_FIXED(VAL_DESC2);

    MATCH_FIXED_BINARYS(VAL_DESC1, VAL_DESC2);

    DBG$CVT_CVTLH_R1(VALUE1, TEMP_VAL1);
    DBG$CVT_CVTLH_R1(VALUE2, TEMP_VAL2);

    ! Do the divide.
    !
    DIVH(TEMP_VAL2, TEMP_VAL1, TEMP_RESULT);

    ! Now convert the H_float to Fixed Binary.
    ! This is not pretty, but it's better that trying to set up to call
    ! CVT_DX_DX to do the same thing.  This will be a lot faster.
    !
    RESULT_VALUE = 0;
    SIGN = .TEMP_RESULT<15, 1, 0>;
    TEMP_RESULT<15, 1, 0> = 0;
    SCALE = .TEMP_RESULT<0, 16, 0> - 16384;
    SCALE = .SCALE - 31;
    RESULT_VALUE<30, 1, 0> = 1;
    RESULT_VALUE<14, 16, 0> = .TEMP_RESULT<16, 16, 0>;
    RESULT_VALUE<0, 14, 0> = .(TEMP_RESULT+4)<18, 14, 0>;
    IF .SIGN THEN RESULT_VALUE = 0 - .RESULT_VALUE;

    ! Normalize the result.  Makes the output look neater.
    ! (We don't need all the fields filled in.)
    !
    TEMP_DESC[DSC$W_LENGTH] = 4;
    TEMP_DESC[DSC$B_SCALE] = .SCALE;
    TEMP_DESC[DSC$A_POINTER] = RESULT_VALUE;
    DBG$NORMALIZE_FIXED(TEMP_DESC);
    
    .RESULT_DESC[DBG$L_VALUE_POINTER] = .RESULT_VALUE;
    RESULT_DESC[DBG$B_VALUE_DTYPE] = DSC$K_DTYPE_L;
    RESULT_DESC[DBG$B_VALUE_SCALE] = .TEMP_DESC[DSC$B_SCALE];

    END;

GLOBAL ROUTINE DBG$ENUM_FIRST (TYPEID: REF RST$ENTRY) =
!
! FUNCTION
!	This routine finds the first enumeration element in a set of
!	enumeration elements, and returns the integer value of that
!	element. It thus does the same thing as the "'FIRST" operator
!	in ADA. The code is taken from the TOKEN$K_TICK_FIRST case
!	in the DBG$EVAL_ADA_TICK routine in this module.
!
!	This routine is needed when indexing ADA arrays that are
!	subscripted by enumeration types.
! INPUTS
!	TYPEID	- describes the enumeration type for which we
!		  want the first element.
! OUTPUTS
!	The value of the first element is returned.
!
    BEGIN
    LOCAL
    	ADR_KIND,
    	COMPONENT_LIST: REF VECTOR[],
    	DST_VALUE: VECTOR[3],
    	DUMMY,
    	HIGHBOUND,
    	LOWBOUND;

    ! If we do not have a typeid then just return 0.
    !
    IF .TYPEID EQL 0
    THEN
    	RETURN 0;

    ! If we have a subrange type, get the parent type.
    !
    WHILE .TYPEID[RST$B_FCODE] EQL RST$K_TYPE_SUBRNG DO
    	DBG$STA_TYP_SUBRNG(.TYPEID, TYPEID, LOWBOUND, HIGHBOUND, DUMMY);

    ! If we do not have an enumeration type then just return 0.
    !
    IF .TYPEID[RST$B_FCODE] NEQ RST$K_TYPE_ENUM
    THEN
    	RETURN 0;

    ! Obtain the component list.
    !
    COMPONENT_LIST = TYPEID[RST$A_TYPCOMPLST];

    ! Return the value of the first element.
    !
    DBG$STA_SYMVALUE(.COMPONENT_LIST[0], DST_VALUE, ADR_KIND);
    IF .ADR_KIND NEQ DBG$K_VAL_LITERAL
    THEN
    	$DBG_ERROR('DBGLANGOP\DBG$ENUM_FIRST');
    RETURN ..DST_VALUE[0];
    END;

GLOBAL ROUTINE DBG$ENUM_POS (TYPEID: REF RST$ENTRY, VALUE) =
!
! FUNCTION
!	Given an enumeration value, this routine finds which position
!	in the list of enumeration values corresponds to that value.
!
!	This is needed in subscripting ADA arrays, where we want
!	to index by enumeration position and not by value. This
!	routine does the same thing as the "'POS" function in ADA.
! INPUTS
!	TYPEID	- describes the enumeration type for which we
!		  are doing this operation.
!	VALUE	- The enumeration value, expressed as an integer,
!		  for which we want the position.
! OUTPUTS
!	The position of the enumeration element is returned.
!
    BEGIN
    LOCAL
    	ADR_KIND,
    	COMPONENT_LIST: REF VECTOR[],
    	DST_VALUE: VECTOR[3],
    	DUMMY,
    	HIGHBOUND,
    	INDEX,
    	LOWBOUND;

    ! If we do not have a typeid then just return the input.
    !
    IF .TYPEID EQL 0
    THEN
    	RETURN .VALUE;

    ! If we have a subrange type, get the parent type.
    !
    WHILE .TYPEID[RST$B_FCODE] EQL RST$K_TYPE_SUBRNG DO
    	DBG$STA_TYP_SUBRNG(.TYPEID, TYPEID, LOWBOUND, HIGHBOUND, DUMMY);

    ! If we do not have an enumeration type then just return the input.
    !
    IF .TYPEID[RST$B_FCODE] NEQ RST$K_TYPE_ENUM
    THEN
    	RETURN .VALUE;

    ! Obtain the component list.
    !
    COMPONENT_LIST = TYPEID[RST$A_TYPCOMPLST];

    ! Loop through the component list looking for a value that matches.
    !
    INDEX = 0;
    INCR I FROM 0 TO .TYPEID[RST$L_TYPCOMPCNT]-1 DO
    	BEGIN
        DBG$STA_SYMVALUE(.COMPONENT_LIST[.INDEX], DST_VALUE, ADR_KIND);
        IF .ADR_KIND NEQ DBG$K_VAL_LITERAL
        THEN
    	    $DBG_ERROR('DBGLANGOP\DBG$ENUM_FIRST');
    	IF .VALUE EQL ..DST_VALUE[0]
    	THEN
    	    RETURN .INDEX
    	ELSE
    	    INDEX = .INDEX + 1;
    	END;

    ! If we get here we did not find a matching enumeration value.
    ! In this case, just return the input value.
    !
    RETURN .VALUE;
    END;

GLOBAL ROUTINE DBG$ENUM_SUCC (TYPEID: REF RST$ENTRY, VALUE) =
!
! FUNCTION
!	Given an enumeration value, this routine finds the enumeration
!	value of the successor element. This corresponds to the "'SUCC"
!	function in ADA.
!
!	This routine is needed when we do an aggregate examine, in ADA,
!	of an array indexed by an enumeration type.
! INPUTS
!	TYPEID	- describes the enumeration type for which we
!		  are doing this operation.
!	VALUE	- The enumeration value, expressed as an integer,
!		  for which we want the successor.
!
! OUTPUTS
!	The value of the successor is returned.
!
    BEGIN
    LOCAL
    	ADR_KIND,
    	COMPONENT_LIST: REF VECTOR[],
    	DST_VALUE: VECTOR[3],
    	DUMMY,
    	FOUND_FLAG,
    	HIGHBOUND,
    	INDEX,
    	LOWBOUND;

    ! If we do not have a typeid then just return the value + 1.
    !
    IF .TYPEID EQL 0
    THEN
    	RETURN .VALUE+1;

    ! If we have a subrange type, get the parent type.
    !
    WHILE .TYPEID[RST$B_FCODE] EQL RST$K_TYPE_SUBRNG DO
    	DBG$STA_TYP_SUBRNG(.TYPEID, TYPEID, LOWBOUND, HIGHBOUND, DUMMY);

    ! If we do not have an enumeration type then just return the value + 1.
    !
    IF .TYPEID[RST$B_FCODE] NEQ RST$K_TYPE_ENUM
    THEN
    	RETURN .VALUE+1;

    ! Obtain the component list.
    !
    COMPONENT_LIST = TYPEID[RST$A_TYPCOMPLST];

    ! Loop through the component list looking for a value that matches.
    !
    INDEX = 0;
    FOUND_FLAG = FALSE;
    INCR I FROM 0 TO .TYPEID[RST$L_TYPCOMPCNT]-1 DO
    	BEGIN
        DBG$STA_SYMVALUE(.COMPONENT_LIST[.INDEX], DST_VALUE, ADR_KIND);
        IF .ADR_KIND NEQ DBG$K_VAL_LITERAL
        THEN
    	    $DBG_ERROR('DBGLANGOP\DBG$ENUM_FIRST');

    	! If we found a value that matched last time around,
    	! then return the value we computed this time around.
    	!
    	IF .FOUND_FLAG
    	THEN
    	    RETURN ..DST_VALUE[0];

    	! If we match this time around, set the flag saying we want to
    	! stop next time around.
    	!
    	IF .VALUE EQL ..DST_VALUE[0]
    	THEN
    	    FOUND_FLAG = TRUE;
    	INDEX = .INDEX + 1;
    	END;

    ! If we get here we did not find a matching enumeration value.
    ! In this case, just return the input value + 1.
    !
    RETURN .VALUE + 1;
    END;

GLOBAL ROUTINE DBG$ENUM_VAL (TYPEID: REF RST$ENTRY, POSITION) =
!
! FUNCTION
!	Given a position in a list of enumeration values, this routine
!	returns the enumeration value in that position. This corresponds
!	to the "'VAL" function in ADA.
!
!	This routine is used for bounds-checking of ADA arrays that
!	are indexed by enumeration types.
! INPUTS
!	TYPEID	- describes the enumeration type for which we
!		  are doing this operation.
!	POSITION- The position number of the enumeration value. 
!
! OUTPUTS
!	The enumeration value at that position is returned.
    BEGIN
    LOCAL
    	ADR_KIND,
    	COMPONENT_LIST: REF VECTOR[],
    	DST_VALUE: VECTOR[3],
    	DUMMY,
    	HIGHBOUND,
    	LOWBOUND;

    ! If we do not have a typeid then just return the input.
    !
    IF .TYPEID EQL 0
    THEN
    	RETURN .POSITION;

    ! If we have a subrange type, get the parent type.
    !
    WHILE .TYPEID[RST$B_FCODE] EQL RST$K_TYPE_SUBRNG DO
    	DBG$STA_TYP_SUBRNG(.TYPEID, TYPEID, LOWBOUND, HIGHBOUND, DUMMY);

    ! If we do not have an enumeration type then just return the input.
    !
    IF .TYPEID[RST$B_FCODE] NEQ RST$K_TYPE_ENUM
    THEN
    	RETURN .POSITION;

    ! Obtain the component list, look up the Nth element, and return 
    ! its value.
    !
    COMPONENT_LIST = TYPEID[RST$A_TYPCOMPLST];
    DBG$STA_SYMVALUE(.COMPONENT_LIST[.POSITION], DST_VALUE, ADR_KIND);
    IF .ADR_KIND NEQ DBG$K_VAL_LITERAL
    THEN
        $DBG_ERROR('DBGLANGOP\DBG$ENUM_FIRST');
    RETURN ..DST_VALUE[0];
    END;

GLOBAL ROUTINE DBG$EQL_FIXED_FIXED (ARG_DESC1, ARG_DESC2, RESULT_DESC): NOVALUE =
!
! FUNCTION
!
!	This routine is called to perform the equal to operation
!	on a scaled binary variable. 
!
! INPUTS
!
!	ARG_DESC1	- points to the value descriptor representing the
!			  left argument of the operation.
!	ARG_DESC2	- points to the value descriptor representing the
!			  right argument of the operation.
!	RESULT_DESC	- points to the value descriptor representing the result.
!			  of the operation.
!
! OUTPUTS
!
!	The result value descriptor is filled in.
!	No value is returned.
!	
    BEGIN

    MAP
        ARG_DESC1	: REF DBG$VALDESC,
        ARG_DESC2	: REF DBG$VALDESC,
        RESULT_DESC	: REF DBG$VALDESC;

    LOCAL
        VAL_DESC1	: DBG$STG_DESC,
        VAL_DESC2	: DBG$STG_DESC,
        VALUE1,
        VALUE2;

    ! Set up working variables.  This way we don't mess up anything important.
    !
    CH$MOVE(DBG$K_STG_DESC_SIZE, ARG_DESC1[DBG$A_VALUE_VMSDESC], VAL_DESC1);
    CH$MOVE(DBG$K_STG_DESC_SIZE, ARG_DESC2[DBG$A_VALUE_VMSDESC], VAL_DESC2);

    VALUE1 = ..ARG_DESC1[DBG$L_VALUE_POINTER];
    VALUE2 = ..ARG_DESC2[DBG$L_VALUE_POINTER];
    VAL_DESC1[DSC$A_POINTER] = VALUE1;
    VAL_DESC2[DSC$A_POINTER] = VALUE2;

    DBG$NORMALIZE_FIXED(VAL_DESC1);
    DBG$NORMALIZE_FIXED(VAL_DESC2);

    MATCH_FIXED_BINARYS(VAL_DESC1, VAL_DESC2);

    ! Do the Equal evaluation.
    !
    .RESULT_DESC[DBG$L_VALUE_POINTER] = .VALUE1 EQL .VALUE2;

    END;

GLOBAL ROUTINE DBG$EVAL_ADA_TICK (TYPEID, OPERATOR) =
!
! FUNCTION
!	This routine does the evaluation of an Ada tick operator.
!
!	It receives the operand type, and  selects the actual Ada tick routine
!	to do the operation based on the operator sub-code and the typeid.
!	DBG$PERFORM_TICK_xxxxx routine is called to actually perform the
!	specific operation.
!
!	This routine cases on the TOKEN$W_SUBCODE value of this operator to
!	determine which actual routine will do the operation with the operand.
!	If a routine is not found to handle the operation a error is signaled.
!
!	A Primary or a Value Descriptor may be returned as the routine value.
!								
! INPUTS
!	TYPEID   - The typeid of the previous operand.
!
!	OPERATOR - A pointer to the Ada tick operator Token Entry for the
!			operator to be evaluated.
!
! OUTPUTS
!	A pointer to the Value Descriptor which results from the evaluation of
!		  the operator is returned as this routine's result.  Or,
!	A pointer to the Primary Descritpor.
!

    BEGIN

    MAP
	OPERATOR	: REF TOKEN$ENTRY,	! Token Entry for operator to perform
	TYPEID		: REF RST$ENTRY;	! RST entry for the operand

    LOCAL
        ARG_LIST	: REF VECTOR [,LONG],	! Counted vector of arguments
	ARG_VALUE,				! Value of the argument
	BOUNDVEC	: REF VECTOR [,LONG],	! Pointer to bounds vector in
						! array descriptor.
        COMPONENT_LIST	: REF VECTOR [,LONG],	! Vector of RST type components
	DSCADDR		: REF BLOCK [,BYTE],	! Array Descriptor
        DST_VALUE	: VECTOR [3, LONG],	! Value contained in DST
        DUM1,DUM2,DUM3,				! Dummy Variables for calls
	HIGHBOUND,				! Higher bound of the range
	INDEX,					! Index for component list
	LOWBOUND,				! Lower bound of the range
	NDIMS,					! Number of dimensions in array
	OPCODE,					! Operator sub-code for current operator
	RESULT		: REF DBG$VALDESC,	! Pointer to result value descriptor
        RSTPTR		: REF RST$ENTRY,	! Temp pointer to an RST entry
	STRIDEVEC	: REF VECTOR [,LONG],	! Pointer to stride vector in
						! array descriptor.
        TEMP_VAL_DESC	: REF DBG$VALDESC;	! Temp value desc.



    ! Pick up the operator sub-code and case on it to determine what operator
    ! routine to call.
    !
    OPCODE = .OPERATOR[TOKEN$W_SUBCODE];

    SELECTONE .OPCODE OF
        SET

        [TOKEN$K_TICK_CONSTRAINED]:
            BEGIN
            SIGNAL(DBG$_NOTIMPLAN, 1, UPLIT BYTE (%ASCIC '''CONSTRAINED'));
            END;

        [TOKEN$K_TICK_FIRST]:
            BEGIN

            ! Check to see that the incoming typeid is one of the possible
            ! RSTs for this operator.
            !
            IF .TYPEID[RST$B_KIND] EQL RST$K_DATA
            THEN
                DBG$STA_SYMTYPE(.TYPEID, DUM1, TYPEID);

            IF .TYPEID[RST$B_FCODE] NEQ RST$K_TYPE_ENUM AND
               .TYPEID[RST$B_FCODE] NEQ RST$K_TYPE_SUBRNG AND
               .TYPEID[RST$B_FCODE] NEQ RST$K_TYPE_ARRAY
            THEN
                SIGNAL(DBG$_OPNOTALLOW, 1, OPERATOR[TOKEN$B_OPLEN]);

            ! If the input typeid is enumeration, then execute the code for
            ! this, otherwise it will be an array type which requires different
            ! processing.
            !
            IF .TYPEID[RST$B_FCODE] EQL RST$K_TYPE_ENUM OR
               .TYPEID[RST$B_FCODE] EQL RST$K_TYPE_SUBRNG
            THEN
                BEGIN

                ! There should not be an argument list.  If there is one,
                ! signal the error.
                !
                IF .OPERATOR[TOKEN$V_ARGUMENT_LIST]
                THEN
                    SIGNAL(DBG$_INVARGLIS, 1, OPERATOR[TOKEN$B_OPLEN]);

                ! Make a value descriptor for the result.
                !
                RESULT = DBG$MAKE_VALUE_DESC(.TYPEID, 0, RST$K_TYPE_ENUM);

                ! Check to see if the type is subrange of enumeration.  If so
                ! handle the 'FIRST for the subrange.
                !
                IF .TYPEID[RST$B_FCODE] EQL RST$K_TYPE_SUBRNG
                THEN
                    BEGIN
                    DBG$STA_TYP_SUBRNG(.TYPEID, RSTPTR, LOWBOUND, HIGHBOUND, DUM1);
                    IF .RSTPTR[RST$B_FCODE] NEQ RST$K_TYPE_ENUM
                    THEN
                        SIGNAL(DBG$_OPNOTALLOW, 1, OPERATOR[TOKEN$B_OPLEN]);

                    ! Fix up typeid to point to the parent typeid not the subrange
                    !
                    RESULT[DBG$L_DHDR_TYPEID]  = .RSTPTR;

                    RESULT[DBG$L_VALUE_VALUE0] = ..LOWBOUND;
                    END
                ELSE
                    BEGIN

                    ! Go get the first element of this enumeration type and
                    ! return it.
                    !
                    COMPONENT_LIST = TYPEID[RST$A_TYPCOMPLST];
                    RSTPTR = .COMPONENT_LIST[0];
                    DBG$STA_SYMVALUE(.RSTPTR, DST_VALUE[0], DUM1);
                    RESULT[DBG$L_VALUE_VALUE0] = ..DST_VALUE[0];
                    END;
                END

            ELSE
                BEGIN

                ! If there's an argument list, go get the argument.  Otherwise,
                ! set the default value of the 'FIRST function to one.
                !
                IF .OPERATOR[TOKEN$V_ARGUMENT_LIST]
                THEN
                    BEGIN
                    ! Get the argument
                    !
                    ARG_LIST = DBG$GET_BIF_ARGUMENTS(1, OPERATOR[TOKEN$B_OPLEN]);
                    TEMP_VAL_DESC = .ARG_LIST[1];
                    ARG_VALUE = .TEMP_VAL_DESC[DBG$L_VALUE_VALUE0];
                    END
                ELSE
                    ARG_VALUE = 1;

                ! Get array information.
                !
                DBG$STA_TYP_ARRAY(.TYPEID, DSCADDR, DUM2, NDIMS, COMPONENT_LIST, DUM3);

                ! Check to see that the input value in the proper range.
                ! If not signal novalue.
                !
                IF .ARG_VALUE LEQ 0 OR .ARG_VALUE GTR .NDIMS
                THEN
                    SIGNAL(DBG$_INVARRDIM);
                
                ARG_VALUE = .ARG_VALUE - 1;

                ! Make a value descriptor for the first array subscript value
                !
                IF .COMPONENT_LIST[.ARG_VALUE] EQL 0
                THEN
                    RSTPTR = DBG$TYPEID_FOR_ATOMIC(DSC$K_DTYPE_L, 32, FALSE)
                ELSE
                    BEGIN
                    RSTPTR = .COMPONENT_LIST[.ARG_VALUE];
                    IF .RSTPTR[RST$B_FCODE] EQL RST$K_TYPE_SUBRNG
                    THEN
                        DBG$STA_TYP_SUBRNG(.RSTPTR, RSTPTR, DUM1, DUM2, DUM3);
                    END;

                RESULT = DBG$MAKE_VALUE_DESC(.RSTPTR, 0, .RSTPTR[RST$B_FCODE]);
                STRIDEVEC = .DSCADDR + 20;
                BOUNDVEC = .STRIDEVEC + 4 * .NDIMS;
                RESULT[DBG$L_VALUE_VALUE0] = .BOUNDVEC[2 * .ARG_VALUE];

                END;
            END;

        [TOKEN$K_TICK_LAST]:
            BEGIN

            ! Check to see that the incoming typeid is one of the possible
            ! RSTs for this operator.
            !
            IF .TYPEID[RST$B_KIND] EQL RST$K_DATA
            THEN
                DBG$STA_SYMTYPE(.TYPEID, DUM1, TYPEID);

            IF .TYPEID[RST$B_FCODE] NEQ RST$K_TYPE_ENUM AND
               .TYPEID[RST$B_FCODE] NEQ RST$K_TYPE_SUBRNG AND
               .TYPEID[RST$B_FCODE] NEQ RST$K_TYPE_ARRAY
            THEN
                SIGNAL(DBG$_OPNOTALLOW, 1, OPERATOR[TOKEN$B_OPLEN]);

            ! If the input typeid is enumeration, then execute the code for
            ! this, otherwise it will be an array type which requires different
            ! processing.
            !
            IF .TYPEID[RST$B_FCODE] EQL RST$K_TYPE_ENUM OR
               .TYPEID[RST$B_FCODE] EQL RST$K_TYPE_SUBRNG
            THEN
                BEGIN

                ! There should not be an argument list.  If there is one,
                ! signal the error.
                !
                IF .OPERATOR[TOKEN$V_ARGUMENT_LIST]
                THEN
                    SIGNAL(DBG$_INVARGLIS, 1, OPERATOR[TOKEN$B_OPLEN]);

                ! Make a value descriptor for the result.
                !
                RESULT = DBG$MAKE_VALUE_DESC(.TYPEID, 0, RST$K_TYPE_ENUM);

                ! Check to see if the type is subrange of enumeration.  If so
                ! handle the 'LAST for the subrange.
                !
                IF .TYPEID[RST$B_FCODE] EQL RST$K_TYPE_SUBRNG
                THEN
                    BEGIN
                    DBG$STA_TYP_SUBRNG(.TYPEID, RSTPTR, LOWBOUND, HIGHBOUND, DUM1);
                    IF .RSTPTR[RST$B_FCODE] NEQ RST$K_TYPE_ENUM
                    THEN
                        SIGNAL(DBG$_OPNOTALLOW, 1, OPERATOR[TOKEN$B_OPLEN]);

                    ! Fix up typeid to point to the parent typeid not the subrange
                    !
                    RESULT[DBG$L_DHDR_TYPEID]  = .RSTPTR;

                    RESULT[DBG$L_VALUE_VALUE0] = ..HIGHBOUND;
                    END
                ELSE
                    BEGIN

                    ! Go get the first element of this enumeration type and
                    ! return it.
                    !
                    COMPONENT_LIST = TYPEID[RST$A_TYPCOMPLST];
                    RSTPTR = .COMPONENT_LIST[.TYPEID[RST$L_TYPCOMPCNT] - 1];
                    DBG$STA_SYMVALUE(.RSTPTR, DST_VALUE[0], DUM1);
                    RESULT[DBG$L_VALUE_VALUE0] = ..DST_VALUE[0];
                    END;
                END

            ELSE
                BEGIN

                ! If there's an argument list, go get the argument.  Otherwise,
                ! set the default value of the 'LAST function to one.
                !
                IF .OPERATOR[TOKEN$V_ARGUMENT_LIST]
                THEN
                    BEGIN
                    ! Get the argument
                    !
                    ARG_LIST = DBG$GET_BIF_ARGUMENTS(1, OPERATOR[TOKEN$B_OPLEN]);
                    TEMP_VAL_DESC = .ARG_LIST[1];
                    ARG_VALUE = .TEMP_VAL_DESC[DBG$L_VALUE_VALUE0];
                    END
                ELSE
                    ARG_VALUE = 1;

                ! Get array information.
                !
                DBG$STA_TYP_ARRAY(.TYPEID, DSCADDR, DUM2, NDIMS, COMPONENT_LIST, DUM3);

                ! Check to see that the input value in the proper range.
                ! If not signal novalue.
                !
                IF .ARG_VALUE LEQ 0 OR .ARG_VALUE GTR .NDIMS
                THEN
                    SIGNAL(DBG$_INVARRDIM);
                
                ARG_VALUE = .ARG_VALUE - 1;

                ! Make a value descriptor for the first array subscript value
                !
                IF .COMPONENT_LIST[.ARG_VALUE] EQL 0
                THEN
                    RSTPTR = DBG$TYPEID_FOR_ATOMIC(DSC$K_DTYPE_L, 32, FALSE)
                ELSE
                    BEGIN
                    RSTPTR = .COMPONENT_LIST[.ARG_VALUE];
                    IF .RSTPTR[RST$B_FCODE] EQL RST$K_TYPE_SUBRNG
                    THEN
                        DBG$STA_TYP_SUBRNG(.RSTPTR, RSTPTR, DUM1, DUM2, DUM3);
                    END;

                RESULT = DBG$MAKE_VALUE_DESC(.RSTPTR, 0, .RSTPTR[RST$B_FCODE]);
                STRIDEVEC = .DSCADDR + 20;
                BOUNDVEC = .STRIDEVEC + 4 * .NDIMS;
                RESULT[DBG$L_VALUE_VALUE0] = .BOUNDVEC[2 * .ARG_VALUE + 1];

                END;
            END;

        [TOKEN$K_TICK_LENGTH]:
            BEGIN

            ! Check to see that the incoming typeid is one of the possible
            ! RSTs for this operator.
            !
            IF .TYPEID[RST$B_KIND] EQL RST$K_DATA
            THEN
                DBG$STA_SYMTYPE(.TYPEID, DUM1, TYPEID);

            IF .TYPEID[RST$B_FCODE] NEQ RST$K_TYPE_ARRAY
            THEN
                SIGNAL(DBG$_OPNOTALLOW, 1, OPERATOR[TOKEN$B_OPLEN]);

            ! If there's an argument list.  Get the argument.
            ! Otherwise let the default dimension value be 1.
            !
            IF .OPERATOR[TOKEN$V_ARGUMENT_LIST]
            THEN
                BEGIN

                ! Get the argument
                !
                ARG_LIST = DBG$GET_BIF_ARGUMENTS(1, OPERATOR[TOKEN$B_OPLEN]);
                TEMP_VAL_DESC = .ARG_LIST[1];
                ARG_VALUE = .TEMP_VAL_DESC[DBG$L_VALUE_VALUE0];
                END
            ELSE
                ARG_VALUE = 1;

            ! Get array information.
            !
            DBG$STA_TYP_ARRAY(.TYPEID, DSCADDR, DUM1, NDIMS, DUM2, DUM3);

            ! Check to see that the input value in the proper range.
            ! If not signal novalue.
            !
            IF .ARG_VALUE LEQ 0 OR .ARG_VALUE GTR .NDIMS
            THEN
                SIGNAL(DBG$_INVARRDIM);

            ! Make a typeid for the result desc.
            !
            RSTPTR = DBG$TYPEID_FOR_ATOMIC(DSC$K_DTYPE_L, 32, FALSE);

            ! Make a value descriptor for the result.
            !
            RESULT = DBG$MAKE_VALUE_DESC(.RSTPTR, 0, RST$K_TYPE_ATOMIC);

            ! Set up pointers.
            !
            STRIDEVEC = .DSCADDR + 20;
            BOUNDVEC = .STRIDEVEC + 4 * .NDIMS;

            ! Calculate the length.
            !
            ARG_VALUE = .ARG_VALUE - 1;
            RESULT[DBG$L_VALUE_VALUE0] = 
                .BOUNDVEC[2 * .ARG_VALUE + 1] - .BOUNDVEC[2 * .ARG_VALUE] + 1;

            END;

        [TOKEN$K_TICK_POS]:
            BEGIN

            ! Check to see that the incoming typeid is one of the possible
            ! RSTs for this operator.
            !
            IF .TYPEID[RST$B_KIND] EQL RST$K_DATA
            THEN
                DBG$STA_SYMTYPE(.TYPEID, DUM1, TYPEID);

            IF .TYPEID[RST$B_FCODE] NEQ RST$K_TYPE_ENUM AND
               .TYPEID[RST$B_FCODE] NEQ RST$K_TYPE_SUBRNG
            THEN
                SIGNAL(DBG$_OPNOTALLOW, 1, OPERATOR[TOKEN$B_OPLEN]);

            ! There should be an argument list of one.  If there is not,
            ! signal the error now.
            !
            IF NOT .OPERATOR[TOKEN$V_ARGUMENT_LIST]
            THEN
                SIGNAL(DBG$_INVARGLIS, 1, OPERATOR[TOKEN$B_OPLEN]);

            ! Make a typeid for the result desc.
            !
            RSTPTR = DBG$TYPEID_FOR_ATOMIC(DSC$K_DTYPE_L, 32, FALSE);

            ! Make a value descriptor for the result.
            !
            RESULT = DBG$MAKE_VALUE_DESC(.RSTPTR, 0, RST$K_TYPE_ATOMIC);

            ! Get the argument
            !
            ARG_LIST = DBG$GET_BIF_ARGUMENTS(1, OPERATOR[TOKEN$B_OPLEN]);

            IF .TYPEID[RST$B_FCODE] EQL RST$K_TYPE_SUBRNG
            THEN
                BEGIN

                ! Make sure the parent type of the subrange is enumeration.
                ! And make the parent type the new type.
                !
                DBG$STA_TYP_SUBRNG(.TYPEID, TYPEID, LOWBOUND, HIGHBOUND, DUM3);
                IF .TYPEID[RST$B_FCODE] NEQ RST$K_TYPE_ENUM
                THEN
                    SIGNAL(DBG$_OPNOTALLOW, 1, OPERATOR[TOKEN$B_OPLEN]);
                END;

            ! Find out which component in the typeid list is the one specified
            ! by the symid in the argument list.  Then return the index as the
            ! position of this element.  If the component was not found signal
            ! an error.
            !
            TEMP_VAL_DESC = .ARG_LIST[1];
            IF .TEMP_VAL_DESC[DBG$L_DHDR_TYPEID] NEQ .TYPEID
            THEN
                SIGNAL(DBG$_INVARGLIS, 1, OPERATOR[TOKEN$B_OPLEN]);

            INDEX = 0;
            COMPONENT_LIST = TYPEID[RST$A_TYPCOMPLST];
            WHILE .INDEX LEQ .TYPEID[RST$L_TYPCOMPCNT]-1 DO
                BEGIN
                DBG$STA_SYMVALUE(.COMPONENT_LIST[.INDEX], DST_VALUE[0], DUM1);
                IF .TEMP_VAL_DESC[DBG$L_VALUE_VALUE0] EQL ..DST_VALUE[0]
                THEN
                    BEGIN
                    RESULT[DBG$L_VALUE_VALUE0] = .INDEX;
                    EXITLOOP;
                    END
                ELSE
                    INDEX = .INDEX + 1;
                END;

            IF .INDEX GEQ .TYPEID[RST$L_TYPCOMPCNT]
            THEN
                SIGNAL(DBG$_CMPNOTFND);

            END;

        [TOKEN$K_TICK_PRED]:
            BEGIN

            ! Check to see that the incoming typeid is one of the possible
            ! RSTs for this operator.
            !
            IF .TYPEID[RST$B_KIND] EQL RST$K_DATA
            THEN
                DBG$STA_SYMTYPE(.TYPEID, DUM1, TYPEID);

            IF .TYPEID[RST$B_FCODE] NEQ RST$K_TYPE_ENUM AND
               .TYPEID[RST$B_FCODE] NEQ RST$K_TYPE_SUBRNG
            THEN
                SIGNAL(DBG$_OPNOTALLOW, 1, OPERATOR[TOKEN$B_OPLEN]);

            ! Make a value descriptor for the result.
            !
            RESULT = DBG$MAKE_VALUE_DESC(.TYPEID, 0, RST$K_TYPE_ENUM);

            ! We expect an argument list.  If there isn't one, signal the error.
            !
            IF NOT .OPERATOR[TOKEN$V_ARGUMENT_LIST]
            THEN
                SIGNAL(DBG$_INVARGLIS, 1, OPERATOR[TOKEN$B_OPLEN]);
            
            ! Get the argument
            !
            ARG_LIST = DBG$GET_BIF_ARGUMENTS(1, OPERATOR[TOKEN$B_OPLEN]);

            IF .TYPEID[RST$B_FCODE] EQL RST$K_TYPE_SUBRNG
            THEN
                BEGIN

                ! Make sure the parent type of the subrange is enumeration
                !
                DBG$STA_TYP_SUBRNG(.TYPEID, RSTPTR, LOWBOUND, HIGHBOUND, DUM3);
                IF .RSTPTR[RST$B_FCODE] NEQ RST$K_TYPE_ENUM
                THEN
                    SIGNAL(DBG$_OPNOTALLOW, 1, OPERATOR[TOKEN$B_OPLEN]);
                END;

            ! Perform the operation
            !
            DBG$PRED_ENUM(.ARG_LIST[1], .RESULT);

            END;

        [TOKEN$K_TICK_SIZE]:
            BEGIN

            ! There should be no argument list.  If there is one, signal the
            ! error now.
            !
            IF .OPERATOR[TOKEN$V_ARGUMENT_LIST]
            THEN
                SIGNAL(DBG$_SYNERREXPR, 1, UPLIT BYTE (%ASCIC '(') );

            ! Make a typeid for the result desc.
            !
            RSTPTR = DBG$TYPEID_FOR_ATOMIC(DSC$K_DTYPE_L, 32, FALSE);

            ! Make a value descriptor for the result.
            !
            RESULT = DBG$MAKE_VALUE_DESC(.RSTPTR, 0, RST$K_TYPE_ATOMIC);

            ! Get the bit size of the input typeid. This may be a symbol or a
            ! type.
            !
            DBG$STA_SYMSIZE(.TYPEID, RESULT[DBG$A_VALUE_ADDRESS]);

            END;

        [TOKEN$K_TICK_SUCC]:
            BEGIN

            ! Check to see that the incoming typeid is one of the possible
            ! RSTs for this operator.
            !
            IF .TYPEID[RST$B_KIND] EQL RST$K_DATA
            THEN
                DBG$STA_SYMTYPE(.TYPEID, DUM1, TYPEID);

            IF .TYPEID[RST$B_FCODE] NEQ RST$K_TYPE_ENUM AND
               .TYPEID[RST$B_FCODE] NEQ RST$K_TYPE_SUBRNG
            THEN
                SIGNAL(DBG$_OPNOTALLOW, 1, OPERATOR[TOKEN$B_OPLEN]);

            ! Make a value descriptor for the result.
            !
            RESULT = DBG$MAKE_VALUE_DESC(.TYPEID, 0, RST$K_TYPE_ENUM);

            ! We expect an argument list.  If there isn't one, signal the error.
            !
            IF NOT .OPERATOR[TOKEN$V_ARGUMENT_LIST]
            THEN
                SIGNAL(DBG$_INVARGLIS, 1, OPERATOR[TOKEN$B_OPLEN]);
            
            ! Get the argument
            !
            ARG_LIST = DBG$GET_BIF_ARGUMENTS(1, OPERATOR[TOKEN$B_OPLEN]);

            IF .TYPEID[RST$B_FCODE] EQL RST$K_TYPE_SUBRNG
            THEN
                BEGIN

                ! Make sure the parent type of the subrange is enumeration
                !
                DBG$STA_TYP_SUBRNG(.TYPEID, RSTPTR, LOWBOUND, HIGHBOUND, DUM3);
                IF .RSTPTR[RST$B_FCODE] NEQ RST$K_TYPE_ENUM
                THEN
                    SIGNAL(DBG$_OPNOTALLOW, 1, OPERATOR[TOKEN$B_OPLEN]);
                END;

            ! Perform the operation
            !
            DBG$SUCC_ENUM(.ARG_LIST[1], .RESULT);

            END;

        [TOKEN$K_TICK_VAL]:
            BEGIN

            ! Check to see that the incoming typeid is one of the possible
            ! RSTs for this operator.
            !
            IF .TYPEID[RST$B_KIND] EQL RST$K_DATA
            THEN
                DBG$STA_SYMTYPE(.TYPEID, DUM1, TYPEID);

            IF .TYPEID[RST$B_FCODE] NEQ RST$K_TYPE_ENUM AND
               .TYPEID[RST$B_FCODE] NEQ RST$K_TYPE_SUBRNG
            THEN
                SIGNAL(DBG$_OPNOTALLOW, 1, OPERATOR[TOKEN$B_OPLEN]);

            ! We expect an argument list.  If there isn't one, signal the error.
            !
            IF NOT .OPERATOR[TOKEN$V_ARGUMENT_LIST]
            THEN
                SIGNAL(DBG$_INVARGLIS, 1, OPERATOR[TOKEN$B_OPLEN]);
            
            ! Get the argument
            !
            ARG_LIST = DBG$GET_BIF_ARGUMENTS(1, OPERATOR[TOKEN$B_OPLEN]);

            IF .TYPEID[RST$B_FCODE] EQL RST$K_TYPE_SUBRNG
            THEN
                BEGIN

                ! Make sure the parent type of the subrange is enumeration.
                ! And make the parent type the new type.
                !
                DBG$STA_TYP_SUBRNG(.TYPEID, TYPEID, LOWBOUND, HIGHBOUND, DUM3);
                IF .TYPEID[RST$B_FCODE] NEQ RST$K_TYPE_ENUM
                THEN
                    SIGNAL(DBG$_OPNOTALLOW, 1, OPERATOR[TOKEN$B_OPLEN]);
                END;

            ! We must now convert the value of the argument to an integer.
            ! To do this we must set up a new value descriptor.  We allocate
            ! a skeleton descriptor and fill in some of the fields.
            !
            TEMP_VAL_DESC = DBG$MAKE_SKELETON_DESC(DBG$K_VALUE_DESC, 4);
            TEMP_VAL_DESC[DBG$B_DHDR_KIND] = RST$K_DATA;
            TEMP_VAL_DESC[DBG$L_DHDR_TYPEID] = 0;
            TEMP_VAL_DESC[DBG$L_VALUE_POINTER] = TEMP_VAL_DESC[DBG$A_VALUE_ADDRESS];
            TEMP_VAL_DESC[DBG$B_DHDR_FCODE] = RST$K_TYPE_ATOMIC;
            TEMP_VAL_DESC[DBG$B_VALUE_CLASS] = DSC$K_CLASS_S;
            TEMP_VAL_DESC[DBG$B_VALUE_DTYPE] = DSC$K_DTYPE_L;
            TEMP_VAL_DESC[DBG$W_VALUE_LENGTH] = 4;

            ! Now call the conversion routine.  Put the result back into
            ! the temporary descriptor.
            !
            TEMP_VAL_DESC = DBG$EVAL_LANG_OPERATOR(DBG$GL_CONVERT_TOKEN,
                                                      .ARG_LIST[1], .TEMP_VAL_DESC);

            ! Check to see that the input value is in the proper range.
            ! If not signal novalue.
            !
            IF .TEMP_VAL_DESC[DBG$L_VALUE_VALUE0] LSS 0 OR
               .TEMP_VAL_DESC[DBG$L_VALUE_VALUE0] GEQ .TYPEID[RST$L_TYPCOMPCNT]
            THEN
                SIGNAL(DBG$_NOVALUE);

            ! Get the symbol RST from the type RST
            !
            COMPONENT_LIST = TYPEID[RST$A_TYPCOMPLST];
            RSTPTR = .COMPONENT_LIST[.TEMP_VAL_DESC[DBG$L_VALUE_VALUE0]];

            ! Make a value descriptor for the result.
            !
            RESULT = DBG$MAKE_VALUE_DESC(.TYPEID, .RSTPTR, .TYPEID[RST$B_FCODE]);

            ! Get the value of this RST element.
            !
            DBG$STA_SYMVALUE(.RSTPTR, DST_VALUE[0], DUM1);
            RESULT[DBG$L_VALUE_VALUE0] = ..DST_VALUE[0];

            END;

        [OTHERWISE]:
            BEGIN
            $DBG_ERROR('DBGLANGOP\DBG$EVAL_ADA_TICK, invalid token sub-code');
            END;

        TES;

    ! Return a pointer to the result value descriptor.
    !
    RETURN .RESULT;
    END;

GLOBAL ROUTINE DBG$GEQ_FIXED_FIXED (ARG_DESC1, ARG_DESC2, RESULT_DESC): NOVALUE =
!
! FUNCTION
!
!	This routine is called to perform the greater than or equal to operation
!	on a scaled binary variable. 
!
! INPUTS
!
!	ARG_DESC1	- points to the value descriptor representing the
!			  left argument of the operation.
!	ARG_DESC2	- points to the value descriptor representing the
!			  right argument of the operation.
!	RESULT_DESC	- points to the value descriptor representing the result.
!			  of the operation.
!
! OUTPUTS
!
!	The result value descriptor is filled in.
!	No value is returned.
!	
    BEGIN

    MAP
        ARG_DESC1	: REF DBG$VALDESC,
        ARG_DESC2	: REF DBG$VALDESC,
        RESULT_DESC	: REF DBG$VALDESC;

    LOCAL
        VAL_DESC1	: DBG$STG_DESC,
        VAL_DESC2	: DBG$STG_DESC,
        VALUE1,
        VALUE2;

    ! Set up working variables.  This way we don't mess up anything important.
    !
    CH$MOVE(DBG$K_STG_DESC_SIZE, ARG_DESC1[DBG$A_VALUE_VMSDESC], VAL_DESC1);
    CH$MOVE(DBG$K_STG_DESC_SIZE, ARG_DESC2[DBG$A_VALUE_VMSDESC], VAL_DESC2);

    VALUE1 = ..ARG_DESC1[DBG$L_VALUE_POINTER];
    VALUE2 = ..ARG_DESC2[DBG$L_VALUE_POINTER];
    VAL_DESC1[DSC$A_POINTER] = VALUE1;
    VAL_DESC2[DSC$A_POINTER] = VALUE2;

    DBG$NORMALIZE_FIXED(VAL_DESC1);
    DBG$NORMALIZE_FIXED(VAL_DESC2);

    MATCH_FIXED_BINARYS(VAL_DESC1, VAL_DESC2);

    ! Do the Greater than or Equal to evaluation.
    !
    .RESULT_DESC[DBG$L_VALUE_POINTER] = .VALUE1 GEQ .VALUE2;

    END;

GLOBAL ROUTINE DBG$GTR_FIXED_FIXED (ARG_DESC1, ARG_DESC2, RESULT_DESC): NOVALUE =
!
! FUNCTION
!
!	This routine is called to perform the greater than operation
!	on a scaled binary variable. 
!
! INPUTS
!
!	ARG_DESC1	- points to the value descriptor representing the
!			  left argument of the operation.
!	ARG_DESC2	- points to the value descriptor representing the
!			  right argument of the operation.
!	RESULT_DESC	- points to the value descriptor representing the result.
!			  of the operation.
!
! OUTPUTS
!
!	The result value descriptor is filled in.
!	No value is returned.
!	
    BEGIN

    MAP
        ARG_DESC1	: REF DBG$VALDESC,
        ARG_DESC2	: REF DBG$VALDESC,
        RESULT_DESC	: REF DBG$VALDESC;

    LOCAL
        VAL_DESC1	: DBG$STG_DESC,
        VAL_DESC2	: DBG$STG_DESC,
        VALUE1,
        VALUE2;

    ! Set up working variables.  This way we don't mess up anything important.
    !
    CH$MOVE(DBG$K_STG_DESC_SIZE, ARG_DESC1[DBG$A_VALUE_VMSDESC], VAL_DESC1);
    CH$MOVE(DBG$K_STG_DESC_SIZE, ARG_DESC2[DBG$A_VALUE_VMSDESC], VAL_DESC2);

    VALUE1 = ..ARG_DESC1[DBG$L_VALUE_POINTER];
    VALUE2 = ..ARG_DESC2[DBG$L_VALUE_POINTER];
    VAL_DESC1[DSC$A_POINTER] = VALUE1;
    VAL_DESC2[DSC$A_POINTER] = VALUE2;

    DBG$NORMALIZE_FIXED(VAL_DESC1);
    DBG$NORMALIZE_FIXED(VAL_DESC2);

    MATCH_FIXED_BINARYS(VAL_DESC1, VAL_DESC2);

    ! Do the Greater Than evaluation.
    !
    .RESULT_DESC[DBG$L_VALUE_POINTER] = .VALUE1 GTR .VALUE2;

    END;

GLOBAL ROUTINE DBG$LEQ_FIXED_FIXED (ARG_DESC1, ARG_DESC2, RESULT_DESC): NOVALUE =
!
! FUNCTION
!
!	This routine is called to perform the less than or equal to operation
!	on a scaled binary variable. 
!
! INPUTS
!
!	ARG_DESC1	- points to the value descriptor representing the
!			  left argument of the operation.
!	ARG_DESC2	- points to the value descriptor representing the
!			  right argument of the operation.
!	RESULT_DESC	- points to the value descriptor representing the result.
!			  of the operation.
!
! OUTPUTS
!
!	The result value descriptor is filled in.
!	No value is returned.
!	
    BEGIN

    MAP
        ARG_DESC1	: REF DBG$VALDESC,
        ARG_DESC2	: REF DBG$VALDESC,
        RESULT_DESC	: REF DBG$VALDESC;

    LOCAL
        VAL_DESC1	: DBG$STG_DESC,
        VAL_DESC2	: DBG$STG_DESC,
        VALUE1,
        VALUE2;

    ! Set up working variables.  This way we don't mess up anything important.
    !
    CH$MOVE(DBG$K_STG_DESC_SIZE, ARG_DESC1[DBG$A_VALUE_VMSDESC], VAL_DESC1);
    CH$MOVE(DBG$K_STG_DESC_SIZE, ARG_DESC2[DBG$A_VALUE_VMSDESC], VAL_DESC2);

    VALUE1 = ..ARG_DESC1[DBG$L_VALUE_POINTER];
    VALUE2 = ..ARG_DESC2[DBG$L_VALUE_POINTER];
    VAL_DESC1[DSC$A_POINTER] = VALUE1;
    VAL_DESC2[DSC$A_POINTER] = VALUE2;

    DBG$NORMALIZE_FIXED(VAL_DESC1);
    DBG$NORMALIZE_FIXED(VAL_DESC2);

    MATCH_FIXED_BINARYS(VAL_DESC1, VAL_DESC2);

    ! Do the Less Than or Equal to evaluation.
    !
    .RESULT_DESC[DBG$L_VALUE_POINTER] = .VALUE1 LEQ .VALUE2;

    END;

GLOBAL ROUTINE DBG$LSS_FIXED_FIXED (ARG_DESC1, ARG_DESC2, RESULT_DESC): NOVALUE =
!
! FUNCTION
!
!	This routine is called to perform the less than operation
!	on a scaled binary variable. 
!
! INPUTS
!
!	ARG_DESC1	- points to the value descriptor representing the
!			  left argument of the operation.
!	ARG_DESC2	- points to the value descriptor representing the
!			  right argument of the operation.
!	RESULT_DESC	- points to the value descriptor representing the result.
!			  of the operation.
!
! OUTPUTS
!
!	The result value descriptor is filled in.
!	No value is returned.
!	
    BEGIN

    MAP
        ARG_DESC1	: REF DBG$VALDESC,
        ARG_DESC2	: REF DBG$VALDESC,
        RESULT_DESC	: REF DBG$VALDESC;

    LOCAL
        VAL_DESC1	: DBG$STG_DESC,
        VAL_DESC2	: DBG$STG_DESC,
        VALUE1,
        VALUE2;

    ! Set up working variables.  This way we don't mess up anything important.
    !
    CH$MOVE(DBG$K_STG_DESC_SIZE, ARG_DESC1[DBG$A_VALUE_VMSDESC], VAL_DESC1);
    CH$MOVE(DBG$K_STG_DESC_SIZE, ARG_DESC2[DBG$A_VALUE_VMSDESC], VAL_DESC2);

    VALUE1 = ..ARG_DESC1[DBG$L_VALUE_POINTER];
    VALUE2 = ..ARG_DESC2[DBG$L_VALUE_POINTER];
    VAL_DESC1[DSC$A_POINTER] = VALUE1;
    VAL_DESC2[DSC$A_POINTER] = VALUE2;

    DBG$NORMALIZE_FIXED(VAL_DESC1);
    DBG$NORMALIZE_FIXED(VAL_DESC2);

    MATCH_FIXED_BINARYS(VAL_DESC1, VAL_DESC2);

    ! Do the Less Than evaluation.
    !
    .RESULT_DESC[DBG$L_VALUE_POINTER] = .VALUE1 LSS .VALUE2;

    END;

GLOBAL ROUTINE DBG$MAKE_VALUE_DESC (TYPEID, SYMID, FCODE) =
!
! FUNCTION
!	Allocates space for a value descriptor of the given type, and
!	fills in the fields.
!
! INPUTS
!	TYPEID  - RST Type Entry
!	SYMID	- RST Symbol Entry (May be zero)
!	FCODE	- Format code for value descriptor
!
! OUTPUTS
!	Returns the address of a value descriptor allocated out of temporary
!	memory.
!

    BEGIN

    MAP
        TYPEID	: REF RST$ENTRY;	! RST Entry type for the value descriptor

    LITERAL
    	DESC_LENGTH = 10;		! Length of the descriptor

    LOCAL
        DUM1,DUM2,			! Dummy variables for routine call
    	RESULT	: REF DBG$VALDESC;	! Address of the result descriptor


    ! Get temporary memory for the new descriptor
    !
    RESULT = DBG$GET_TEMPMEM (DESC_LENGTH); 

    ! Fill in the fields of the new value descriptor.
    !
    RESULT [DBG$B_DHDR_LANG]	= .DBG$GB_LANGUAGE;
    RESULT [DBG$B_DHDR_TYPE]	= DBG$K_VALUE_DESC;
    RESULT [DBG$W_DHDR_LENGTH]	= 4 * DESC_LENGTH;
    RESULT [DBG$B_DHDR_KIND]	= RST$K_DATA;
    RESULT [DBG$B_DHDR_FCODE]	= .FCODE;
    RESULT [DBG$L_DHDR_TYPEID]	= .TYPEID;
    RESULT [DBG$L_DHDR_SYMID0]	= .SYMID;

    IF NOT DBG$FILL_IN_VMS_DESC(.FCODE, .TYPEID, 0,
                                RESULT[DBG$A_VALUE_VMSDESC],DUM1, DUM2)
    THEN
        $DBG_ERROR ('DBGLANGOP\DBG$MAKE_VALUE_DESC could not fill in the VMS fields');

    RESULT [DBG$L_VALUE_POINTER] = RESULT[DBG$A_VALUE_ADDRESS];

    RETURN .RESULT;
    END;

GLOBAL ROUTINE DBG$MUL_FIXED_FIXED (ARG_DESC1, ARG_DESC2, RESULT_DESC): NOVALUE =
!
! FUNCTION
!
!	This routine is called to perform the multiply operation
!	on a scaled binary variable. 
!
! INPUTS
!
!	ARG_DESC1	- points to the value descriptor representing the
!			  left argument of the operation.
!	ARG_DESC2	- points to the value descriptor representing the
!			  right argument of the operation.
!	RESULT_DESC	- points to the value descriptor representing the result.
!			  of the operation.
!
! OUTPUTS
!
!	The result value descriptor is filled in.
!	No value is returned.
!	
    BEGIN

    MAP
        ARG_DESC1	: REF DBG$VALDESC,
        ARG_DESC2	: REF DBG$VALDESC,
        RESULT_DESC	: REF DBG$VALDESC;

    LOCAL
        INDEX,
        RESULT_VALUE	: VECTOR[2,LONG],
        SCALE,
        TEMP_VAL	: BITVECTOR[32],
        VAL_DESC1	: DBG$STG_DESC,
        VAL_DESC2	: DBG$STG_DESC,
        VALUE1,
        VALUE2;

    ! Set up working variables.  This way we don't mess up anything important.
    !
    CH$MOVE(DBG$K_STG_DESC_SIZE, ARG_DESC1[DBG$A_VALUE_VMSDESC], VAL_DESC1);
    CH$MOVE(DBG$K_STG_DESC_SIZE, ARG_DESC2[DBG$A_VALUE_VMSDESC], VAL_DESC2);

    VALUE1 = ..ARG_DESC1[DBG$L_VALUE_POINTER];
    VALUE2 = ..ARG_DESC2[DBG$L_VALUE_POINTER];
    VAL_DESC1[DSC$A_POINTER] = VALUE1;
    VAL_DESC2[DSC$A_POINTER] = VALUE2;

    DBG$NORMALIZE_FIXED(VAL_DESC1);
    DBG$NORMALIZE_FIXED(VAL_DESC2);

    ! Do the add.
    !
    EMUL(VALUE1, VALUE2, %REF(0), RESULT_VALUE);
    SCALE = .VAL_DESC1[DSC$B_SCALE] + .VAL_DESC2[DSC$B_SCALE];

    ! Now it gets tricky...
    ! We've got to put this quadword result into a longword and check
    ! for a loss of precision.
    !
    ! Let's start by finding the most significant bit in the second longword.
    !     First: if the value of the second longword is 0 or -1, we needn't
    !     waste our time.
    !
    IF .RESULT_VALUE[1] EQL 0 OR
       .RESULT_VALUE[1] EQL -1
    THEN
        BEGIN
        TEMP_VAL = .RESULT_VALUE[0];
        IF .TEMP_VAL[31] NEQ .(RESULT_VALUE+4)<0, 1, 0>
        THEN
            BEGIN
            IF .TEMP_VAL[0]
            THEN
                SIGNAL(DBG$_IFIXUND);
            TEMP_VAL = .TEMP_VAL ^ -1;
            SCALE = .SCALE + 1;
            END;
        END
    ELSE
        BEGIN
        TEMP_VAL = .RESULT_VALUE[1];
        INDEX = 30;
        WHILE (.TEMP_VAL[.INDEX] NEQ .TEMP_VAL[31]) AND (.INDEX GEQ 0) DO
            INDEX = .INDEX - 1;
        IF .INDEX EQL -1
        THEN
            $DBG_ERROR('DBGLANGOP\DBG$MUL_FIXED_FIXED should never be here');

        ! Move the 32 bits into our temporary location, and modify the scale.
        !
        TEMP_VAL = .RESULT_VALUE<(.INDEX + 2), 32, 0>;
        SCALE = .SCALE + .INDEX + 2;
        IF .RESULT_VALUE<0, (.INDEX + 2), 0> NEQ 0
        THEN
            SIGNAL(DBG$_IFIXUND);
        END;

    .RESULT_DESC[DBG$L_VALUE_POINTER] = .TEMP_VAL;
    RESULT_DESC[DBG$B_VALUE_DTYPE] = DSC$K_DTYPE_L;
    RESULT_DESC[DBG$B_VALUE_SCALE] = .SCALE;

    END;

GLOBAL ROUTINE DBG$NEQ_FIXED_FIXED (ARG_DESC1, ARG_DESC2, RESULT_DESC): NOVALUE =
!
! FUNCTION
!
!	This routine is called to perform the not equal to operation
!	on a scaled binary variable. 
!
! INPUTS
!
!	ARG_DESC1	- points to the value descriptor representing the
!			  left argument of the operation.
!	ARG_DESC2	- points to the value descriptor representing the
!			  right argument of the operation.
!	RESULT_DESC	- points to the value descriptor representing the result.
!			  of the operation.
!
! OUTPUTS
!
!	The result value descriptor is filled in.
!	No value is returned.
!	
    BEGIN

    MAP
        ARG_DESC1	: REF DBG$VALDESC,
        ARG_DESC2	: REF DBG$VALDESC,
        RESULT_DESC	: REF DBG$VALDESC;

    LOCAL
        VAL_DESC1	: DBG$STG_DESC,
        VAL_DESC2	: DBG$STG_DESC,
        VALUE1,
        VALUE2;

    ! Set up working variables.  This way we don't mess up anything important.
    !
    CH$MOVE(DBG$K_STG_DESC_SIZE, ARG_DESC1[DBG$A_VALUE_VMSDESC], VAL_DESC1);
    CH$MOVE(DBG$K_STG_DESC_SIZE, ARG_DESC2[DBG$A_VALUE_VMSDESC], VAL_DESC2);

    VALUE1 = ..ARG_DESC1[DBG$L_VALUE_POINTER];
    VALUE2 = ..ARG_DESC2[DBG$L_VALUE_POINTER];
    VAL_DESC1[DSC$A_POINTER] = VALUE1;
    VAL_DESC2[DSC$A_POINTER] = VALUE2;

    DBG$NORMALIZE_FIXED(VAL_DESC1);
    DBG$NORMALIZE_FIXED(VAL_DESC2);

    MATCH_FIXED_BINARYS(VAL_DESC1, VAL_DESC2);

    ! Do the Not Equal evaluation.
    !
    .RESULT_DESC[DBG$L_VALUE_POINTER] = .VALUE1 NEQ .VALUE2;

    END;

GLOBAL ROUTINE DBG$NORMALIZE_FIXED (FIXED_DESC): NOVALUE =
!
! FUNCTION
!
!	This routine is called to normalize a scaled binary value.
!	It will shift the bits as far towards bit zero as possible,
!	by moving the rightmost one bit to bit zero and likewise
!	adjusting all the rest.  The value of the DSC$B_SCALE field
!	in the descriptor will be adjusted accordingly.
!
! INPUTS
!
!	FIXED_DESC	- points to the scaled binary descriptor to be altered.
!
! OUTPUTS
!
!	The descriptor is altered as described above.
!	No value is returned.
!	
    BEGIN

    MAP
        FIXED_DESC	: REF DBG$STG_DESC;

    LOCAL
        FIXED_LENGTH,
        FIXED_VALUE	: REF BITVECTOR[32];	! Bit vector of the value.


    ! Make sure FIXED_LENGTH is a valid length.
    !
    FIXED_LENGTH = .FIXED_DESC[DSC$W_LENGTH];
    IF (.FIXED_LENGTH NEQ 1) AND (.FIXED_LENGTH NEQ 2) AND (.FIXED_LENGTH NEQ 4)
    THEN
        $DBG_ERROR('DBGLANGOP\DBG$NORMALIZE_FIXED, invalid scaled binary size');

    ! Do the normalization.
    !
    FIXED_LENGTH = .FIXED_LENGTH * 8;
    FIXED_VALUE = .FIXED_DESC[DSC$A_POINTER];
    IF ..FIXED_VALUE EQL 0
    THEN
        FIXED_DESC[DSC$B_SCALE] = 0
    ELSE
        WHILE NOT .FIXED_VALUE[0] DO
            BEGIN
            .FIXED_VALUE = ..FIXED_VALUE ^ -1;
            FIXED_DESC[DSC$B_SCALE] = .FIXED_DESC[DSC$B_SCALE] + 1;
            END;
    END;

GLOBAL ROUTINE DBG$PRED_ENUM (ARG_DESC, RESULT_DESC): NOVALUE =
!
! FUNCTION
!
!	This routine is called to perform the PRED built-in function
!	or 'PRED function for Ada on an enumerated type variable. 
!
! INPUTS
!
!	ARG_DESC	- points to the value descriptor representing the
!			  argument of the PRED built-in function.
!	RESULT_DESC	- points to the value descriptor representing the result.
!			  of the PRED built-in function operator.
!
! OUTPUTS
!
!	The result value descriptor is filled in.
!	No value is returned.
!	
    BEGIN
    MAP
    	ARG_DESC	: REF DBG$VALDESC,
    	RESULT_DESC	: REF DBG$VALDESC;

    LOCAL
	COMPLIST	: REF VECTOR [,LONG],	! Type component list in the RST
	COMPCOUNT,				! Number of components in list
        DST_VALUE	: VECTOR [3,LONG],	! Value contained in DST
        DUMMY,					! Dummy for DBG$STA_SYMVALUE
	INDEX,					! Index for component search loop
    	FCODE,					! FCODE for argument
    	TYPEID		: REF RST$ENTRY;	! Points to a TYPEID

    ! Obtain a typeid and fcode for the argument.
    !
    DBG$STA_SYMTYPE(.ARG_DESC[DBG$L_DHDR_TYPEID], FCODE, TYPEID);
    
    ! Obtain enumeration type info.
    !
    DBG$STA_TYP_ENUM(.TYPEID, COMPCOUNT, COMPLIST, DUMMY);

    ! Now perform the PRED operation by finding the current enumeration
    ! element and from there finding the value of the previous element and
    ! moving the new value into RESULT_DESC.
    !
    RESULT_DESC[DBG$L_DHDR_TYPEID] = .ARG_DESC[DBG$L_DHDR_TYPEID];
    INDEX = 0;
    WHILE .INDEX LEQ .COMPCOUNT-1 DO
        BEGIN

        ! Compare the values to see if this is the current enumerated element
        ! Must go down into the DST to get the value.
        !
        DBG$STA_SYMVALUE(.COMPLIST[.INDEX], DST_VALUE[0], DUMMY);
        IF .ARG_DESC[DBG$L_VALUE_VALUE0] EQL ..DST_VALUE[0]
        THEN
            EXITLOOP;
        INDEX = .INDEX + 1;
        END;

    IF .INDEX GEQ .COMPCOUNT
    THEN
        $DBG_ERROR ('DBGLANGOP\DBG$PRED_ENUM component not found in the RST');

    IF .INDEX GTR 0
    THEN
        BEGIN
        DBG$STA_SYMVALUE(.COMPLIST[.INDEX-1], DST_VALUE[0], DUMMY);
        RESULT_DESC[DBG$L_VALUE_VALUE0] = ..DST_VALUE[0];
        RESULT_DESC[DBG$L_DHDR_SYMID0] = .COMPLIST[.INDEX-1];
        END
    ELSE

        ! If enumeration is out of range, signal the error here.
        !
        SIGNAL(DBG$_ILLENUMVAL);

    END;

GLOBAL ROUTINE DBG$SUB_FIXED_FIXED (ARG_DESC1, ARG_DESC2, RESULT_DESC): NOVALUE =
!
! FUNCTION
!
!	This routine is called to perform the subtract operation
!	on a scaled binary variable. 
!
! INPUTS
!
!	ARG_DESC1	- points to the value descriptor representing the
!			  left argument of the operation.
!	ARG_DESC2	- points to the value descriptor representing the
!			  right argument of the operation.
!	RESULT_DESC	- points to the value descriptor representing the result.
!			  of the operation.
!
! OUTPUTS
!
!	The result value descriptor is filled in.
!	No value is returned.
!	
    BEGIN

    MAP
        ARG_DESC1	: REF DBG$VALDESC,
        ARG_DESC2	: REF DBG$VALDESC,
        RESULT_DESC	: REF DBG$VALDESC;

    LOCAL
        RESULT_VALUE,
        SCALE,
        VAL_DESC1	: DBG$STG_DESC,
        VAL_DESC2	: DBG$STG_DESC,
        VALUE1,
        VALUE2;

    ! Set up working variables.  This way we don't mess up anything important.
    !
    CH$MOVE(DBG$K_STG_DESC_SIZE, ARG_DESC1[DBG$A_VALUE_VMSDESC], VAL_DESC1);
    CH$MOVE(DBG$K_STG_DESC_SIZE, ARG_DESC2[DBG$A_VALUE_VMSDESC], VAL_DESC2);

    VALUE1 = ..ARG_DESC1[DBG$L_VALUE_POINTER];
    VALUE2 = ..ARG_DESC2[DBG$L_VALUE_POINTER];
    VAL_DESC1[DSC$A_POINTER] = VALUE1;
    VAL_DESC2[DSC$A_POINTER] = VALUE2;

    DBG$NORMALIZE_FIXED(VAL_DESC1);
    DBG$NORMALIZE_FIXED(VAL_DESC2);

    MATCH_FIXED_BINARYS(VAL_DESC1, VAL_DESC2);

    ! Do the Subtraction.
    !
    RESULT_VALUE = .VALUE1 - .VALUE2;
    SCALE = .VAL_DESC1[DSC$B_SCALE];

    ! Has an overflow occured?
    !
    IF .VALUE1<31, 1, 0> NEQ .VALUE2<31, 1, 0> AND
       .RESULT_VALUE<31, 1, 0> EQL .VALUE2<31, 1, 0>
    THEN
        BEGIN
        IF .RESULT_VALUE<0, 1, 0>
        THEN
            SIGNAL(DBG$_IFIXUND);
        RESULT_VALUE = .RESULT_VALUE ^ -1;
        SCALE = .SCALE + 1;
        RESULT_VALUE<31, 1, 0> = .VALUE1<31, 1, 0>;
        END;

    .RESULT_DESC[DBG$L_VALUE_POINTER] = .RESULT_VALUE;
    RESULT_DESC[DBG$B_VALUE_DTYPE] = DSC$K_DTYPE_L;
    RESULT_DESC[DBG$B_VALUE_SCALE] = .SCALE;

    END;

GLOBAL ROUTINE DBG$SUCC_ENUM (ARG_DESC, RESULT_DESC): NOVALUE =
!
! FUNCTION
!
!	This routine is called to perform the SUCC built-in function
!	or 'SUCC function for Ada on an enumerated type variable. 
!
! INPUTS
!
!	ARG_DESC	- points to the value descriptor representing the
!			  argument of the SUCC built-in function.
!	RESULT_DESC	- points to the value descriptor representing the result.
!			  of the SUCC built-in function operator.
!
! OUTPUTS
!
!	The result value descriptor is filled in.
!	No value is returned.
!	
    BEGIN
    MAP
    	ARG_DESC	: REF DBG$VALDESC,
    	RESULT_DESC	: REF DBG$VALDESC;

    LOCAL
	COMPLIST	: REF VECTOR [,LONG],	! Type component list in the RST
	COMPCOUNT,				! Number of components in list
        DST_VALUE	: VECTOR [3,LONG],	! Value contained in DST
        DUMMY,					! Dummy for DBG$STA_XXXXX
	INDEX,					! Index for component search loop
    	FCODE,					! FCODE for argument
    	TYPEID		: REF RST$ENTRY;	! Points to a TYPEID

    ! Obtain a typeid and fcode for the argument.
    !
    DBG$STA_SYMTYPE(.ARG_DESC[DBG$L_DHDR_TYPEID], FCODE, TYPEID);
    
    ! Obtain enumeration type info.
    !
    DBG$STA_TYP_ENUM(.TYPEID, COMPCOUNT, COMPLIST, DUMMY);

    ! Now perform the SUCC operation by finding the current enumeration
    ! element and from there finding the value of the next element and moving
    ! the new value into RESULT_DESC.
    !
    RESULT_DESC[DBG$L_DHDR_TYPEID] = .ARG_DESC[DBG$L_DHDR_TYPEID];
    INDEX = 0;
    WHILE .INDEX LEQ .COMPCOUNT-1 DO
        BEGIN

        ! Compare the values to see if this is the current enumerated element
        ! Must go down into the DST to get the value.
        !
        DBG$STA_SYMVALUE(.COMPLIST[.INDEX], DST_VALUE[0], DUMMY);
        IF .ARG_DESC[DBG$L_VALUE_VALUE0] EQL ..DST_VALUE[0]
        THEN
            EXITLOOP;
        INDEX = .INDEX + 1;
        END;

    IF .INDEX GEQ .COMPCOUNT
    THEN
        $DBG_ERROR ('DBGLANGOP\DBG$SUCC_ENUM component not found in the RST');

    IF .INDEX LSS .COMPCOUNT-1
    THEN
        BEGIN
        DBG$STA_SYMVALUE(.COMPLIST[.INDEX+1], DST_VALUE[0], DUMMY);
        RESULT_DESC[DBG$L_VALUE_VALUE0] = ..DST_VALUE[0];
        RESULT_DESC[DBG$L_DHDR_SYMID0] = .COMPLIST[.INDEX+1];
        END
    ELSE

        ! If enumeration is out of range, signal the error here.
        !
        SIGNAL(DBG$_ILLENUMVAL);

    END;

ROUTINE DBG$TYPEID_TO_PRIMARY (TYPEID, ADDRESS) =
!
! FUNCTION
!	This routine takes a TYPEID which describes an anonymous object,
!	and builds a Primary Descriptor for the object.
!	For example, if we dereference a typed pointer in C with (*PTR)
!	then we can get a typeid describing the pointed-to object,
!	and we also know the address of the anonymous object.
!	This routine turns the typeid into a Primary Descriptor.
!	It first constructs a Primary root node and then calls 
!	DBG$BUILD_PRIMARY_SUBNODE to create the Primary sub-node.
!	Finally, it stuffs the address into the RELOC field.
!
! INPUTS
!	TYPEID  - TYPEID for the object
!	ADDRESS - A byte address for the object
!
! OUTPUTS
!	A Primary Descriptor is built out of temporary memory and a 
!	pointer to this descriptor is returned. 
!
    BEGIN

    LOCAL
    	FCODE,				! Fcode for this Primary
    	NODEPTR: REF DBG$PRIM_NODE,	! Pointer to a Primary Subnode
    	PRIMPTR: REF DBG$PRIMARY,	! Pointer to a Primary Descriptor
    	RSTPTR;				! An rstptr (either a symid or a typeid)


    ! Obtain the fcode from the typeid.
    !
    FCODE = DBG$STA_TYPEFCODE (.TYPEID);

    ! Allocate space for the Primary and fill in some of the header fields.
    !
    PRIMPTR = DBG$GET_TEMPMEM (DBG$K_PRIMARY_SIZE);
    PRIMPTR[DBG$B_DHDR_LANG] = .DBG$GB_LANGUAGE;
    PRIMPTR[DBG$B_DHDR_TYPE] = DBG$K_PRIMARY_DESC;
    PRIMPTR[DBG$W_DHDR_LENGTH] = DBG$K_PRIMARY_SIZE*%UPVAL;
    PRIMPTR[DBG$B_DHDR_KIND] = RST$K_DATA;
    PRIMPTR[DBG$B_DHDR_FCODE] = .FCODE;
    PRIMPTR[DBG$L_DHDR_TYPEID] = .TYPEID;
    PRIMPTR[DBG$L_DHDR_SYMID0] = 0;
    PRIMPTR[DBG$L_PRIM_FLINK] = PRIMPTR[DBG$A_PRIM_FLINK];
    PRIMPTR[DBG$L_PRIM_BLINK] = PRIMPTR[DBG$A_PRIM_FLINK];

    ! Call BUILD_PRIMARY_SUBNODE to build a subnode and fill in all of 
    ! the subnode information. Note that this routine also fills in
    ! SYMID, KIND, FCODE, and TYPEID for the root node, so we do not have
    ! to do that here.
    !
    DBG$BUILD_PRIMARY_SUBNODE (.PRIMPTR, RST$K_DATA, 0, .FCODE, .TYPEID, 0);

    ! We already know the address of the object described by the Primary.
    ! This address is put in the "RELOC" field so that PRIM_TO_VAL 
    ! can determine the address of this object.
    !
    NODEPTR = .PRIMPTR[DBG$L_PRIM_BLINK];
    NODEPTR[DBG$L_PNODE_RELOC] = .ADDRESS;

    ! Return a pointer to a Primary.
    !
    RETURN .PRIMPTR;
    END;

GLOBAL ROUTINE DBG$UNARY_MINUS_FIXED (ARG_DESC, RESULT_DESC): NOVALUE =
!
! FUNCTION
!
!	This routine is called to perform the unary minus operation
!	on a scaled binary variable. 
!
! INPUTS
!
!	ARG_DESC	- points to the value descriptor representing the
!			  argument of the operation.
!	RESULT_DESC	- points to the value descriptor representing the result.
!			  of the operation.
!
! OUTPUTS
!
!	The result value descriptor is filled in.
!	No value is returned.
!	
    BEGIN

    MAP
        RESULT_DESC	: REF DBG$VALDESC,
        ARG_DESC	: REF DBG$VALDESC;


    .RESULT_DESC[DBG$L_VALUE_POINTER] = 0 - ..ARG_DESC[DBG$L_VALUE_POINTER];
    RESULT_DESC[DBG$B_VALUE_SCALE] = .ARG_DESC[DBG$B_VALUE_SCALE];
    RESULT_DESC[DBG$B_VALUE_DTYPE] = .ARG_DESC[DBG$B_VALUE_DTYPE];
    END;

GLOBAL ROUTINE DBG$UNARY_PLUS_FIXED (ARG_DESC, RESULT_DESC): NOVALUE =
!
! FUNCTION
!
!	This routine is called to perform the unary plus operation
!	on a scaled binary variable. 
!
! INPUTS
!
!	ARG_DESC	- points to the value descriptor representing the
!			  argument of the operation.
!	RESULT_DESC	- points to the value descriptor representing the result.
!			  of the operation.
!
! OUTPUTS
!
!	The result value descriptor is filled in.
!	No value is returned.
!
    BEGIN

    MAP
        RESULT_DESC	: REF DBG$VALDESC,
        ARG_DESC	: REF DBG$VALDESC;


    RESULT_DESC[DBG$L_VALUE_POINTER] = .ARG_DESC[DBG$L_VALUE_POINTER];
    RESULT_DESC[DBG$B_VALUE_SCALE] = .ARG_DESC[DBG$B_VALUE_SCALE];
    RESULT_DESC[DBG$B_VALUE_DTYPE] = .ARG_DESC[DBG$B_VALUE_DTYPE];
    END;

ROUTINE MATCH_FIXED_BINARYS(ARG_DESC1, ARG_DESC2): NOVALUE =
!
! FUNCTION
!
!	This routine is called to match the scaling factors of the input
!	scaled binarys.  We do this by moving the value with the largest
!	scale down (or the decimal point to the left) until the scales are
!	equal.  Sometimes this would require shifting out the most
!	significant bit of that value, in this case we then shift the other
!	value up (to the right) to match.  This means we would be shifting
!	out some bits so we signal a message to that effect.
!
! INPUTS
!
!	ARG_DESC1	- points to the VMS descriptor representing the
!			  first argument of the operation.
!	ARG_DESC2	- points to the VMS descriptor representing the
!			  second argument of the operation.
!
! OUTPUTS
!
!	The VMS descriptors are altered.
!	No value is returned.
!
    BEGIN

    MAP
        ARG_DESC1	: REF DBG$STG_DESC,
        ARG_DESC2	: REF DBG$STG_DESC;

    LOCAL
        VAL1		: REF BITVECTOR[32],
        VAL2		: REF BITVECTOR[32];


    VAL1 = .ARG_DESC1[DSC$A_POINTER];
    VAL2 = .ARG_DESC2[DSC$A_POINTER];

    WHILE .ARG_DESC1[DSC$B_SCALE] GTR .ARG_DESC2[DSC$B_SCALE] DO
        BEGIN
        IF .VAL1[30] NEQ .VAL1[31]
        THEN
            BEGIN
            SIGNAL(DBG$_IFIXUND);
            WHILE .ARG_DESC2[DSC$B_SCALE] LSS .ARG_DESC1[DSC$B_SCALE] DO
                BEGIN
                .VAL2 = ..VAL2 ^ -1;
                ARG_DESC2[DSC$B_SCALE] = .ARG_DESC2[DSC$B_SCALE] + 1;
                END;
            EXITLOOP;
            END;
        .VAL1 = ..VAL1 ^ 1;
        ARG_DESC1[DSC$B_SCALE] = .ARG_DESC1[DSC$B_SCALE] - 1;
        END;

    WHILE .ARG_DESC2[DSC$B_SCALE] GTR .ARG_DESC1[DSC$B_SCALE] DO
        BEGIN
        IF .VAL2[30] NEQ .VAL2[31]
        THEN
            BEGIN
            SIGNAL(DBG$_IFIXUND);
            WHILE .ARG_DESC1[DSC$B_SCALE] LSS .ARG_DESC2[DSC$B_SCALE] DO
                BEGIN
                .VAL1 = ..VAL1 ^ -1;
                ARG_DESC1[DSC$B_SCALE] = .ARG_DESC1[DSC$B_SCALE] + 1;
                END;
            EXITLOOP;
            END;
        .VAL2 = ..VAL2 ^ 1;
        ARG_DESC2[DSC$B_SCALE] = .ARG_DESC2[DSC$B_SCALE] - 1;
        END;

    END;

END ELUDOM
