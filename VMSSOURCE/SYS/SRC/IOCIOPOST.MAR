	.TITLE	IOCIOPOST - I/O COMPLETION POSTING
	.IDENT	'V04-001'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
; FACILITY: EXECUTIVE, I/O SYSTEM
;
; ABSTRACT:
;	IOCIOPOST IMPLEMENTS THE DEVICE INDEPENDENT COMPLETION PROCESSING FOR
;	I/O PACKETS.  IT IS INVOKED BY QUEUEING THE PACKET ON THE I/O POST QUEUE
;	AND TRIGGERING THE IPL$_IOPOST SOFTWARE INTERRUPT.  SOME OF THE IOPOST
;	OPERATIONS SUCH AS SETTING EVENT FLAGS, UNLOCKING BUFFER PAGES,
;	RELEASING BUFFERS AND PAGING I/O COMPLETION ARE PERFORMED IN THE IOPOST
;	INTERRUPT SERVICE ROUTINE, WHILE OTHER OPERATIONS THAT REQUIRE ACCESS
;	TO PROCESS ADDRESS SPACE ARE PERFORMED BY SENDING A SPECIAL KERNEL AST.
;
; ENVIRONMENT:	MODE = KERNEL, RESIDENT
;
;--
	.SBTTL	HISTORY			; DETAILED
;
; AUTHOR: R. HUSTVEDT, CREATION DATE: 26-AUG-76
;
; MODIFIED BY:
;
;	V04-001	SSA0031		Stan Amway		 7-Sep-1984
;		Fix bug introduced by EMD0076 that destroys UCB address
;		in R0 if encryption key buffer is present.
;
;	V03-025	WMC0025		Wayne Cardoza		31-May-1984
;		Make sure direct I/O completion unlocks at least one page.
;
;	V03-024	ACG0422		Andrew C. Goldstein,	1-May-1984  19:35
;		Fix use of R0 in ACG0421
;
;	V03-023	ACG0421		Andrew C. Goldstein,	20-Apr-1984  14:19
;		Fix segment byte count limiting in erase QIO's
;
;	V03-022 EMD0076		Ellen M. Dusseault	05-Apr-1984
;		Modify IOPOST to check for a valid status bit for
;		encryption.  If valid, deallocate nonpaged pool buffer
;		which contains the encryption key.
;
;	V03-021	SSA0021		Stan Amway		22-Mar-1984
;		Decrement device queue length in UCB.
;
;	V03-020	WMC0020		Wayne Cardoza		07-Mar-1984
;		Move POSTEF to fork context to regain optimization which
;		avoids reexecution of WAITFR.
;
;	V03-019	WMC0019		Wayne Cardoza		28-Dec-1983
;		Erase QIOs can be physical, logical, or virtual.
;
;	V03-018	CDS0003		Christian D. Saether	14-Dec-1983
;		Add IOC$BUFPOST entry point.  This is used to perform
;		the iopost level part of i/o posting to be executed as
;		a subroutine call directly and avoid the iopost software
;		interrupt entirely.  The F11BXQP is the initial user
;		of this feature.
;
;	V03-017	ROW49597C	Ralph O. Weber		21-SEP-1983
;		Change PAGEIO_OR_SWAPIO patch (from ROW49597B and ROW49597) to
;		zero bytes transfered count in the IOSB when status is not
;		successful and bytes transfered is greater than or equal to 
;		bytes requested. 
;
;	V03-016	ROW0218		Ralph O. Weber		 7-SEP-1983
;		Change maximum byte count, UCB$L_MAXBCNT, tests to be 
;		unsigned.
;
;	V03-015	ADE9005		Alan D. Eldridge	30-May-1983
;		Changed BSBW to JSB for calls to IOC$MAPVBLK and IOC$CVTLOGPHY.
;
;	V03-014	STJ3100		Steven T. Jeffreys,	03-May-1983
;		-Added local subroutine CHECK_ERASE.
;		-Do not update IRP$L_SVAPTE for ALL erase I/O's.  This
;		 is an extention of STJ3085.
;
;	V03-013	STJ3085		Steven T. Jeffreys,	13-Apr-1983
;		-Do not update IRP$L_SVAPTE for erase I/O segmented
;		 requests if using the specail erase PPT.
;		-After segmentation complete, resore original SVAPTE
;		 address to IRP$L_SVAPTE.
;
;	V03-012	ROW49597B	Ralph O. Weber		 9-APR-1983
;		Change PAGEIO_OR_SWAPIO from ROW49597 to zero bytes 
;		transfered count when status is not successful and bytes 
;		transfered is greater than or equal to bytes requested.
;
;	V03-011	RLRMXBCNTc	Robert L. Rappaport	28-Mar-1983
;		Verify IRP$L_DIAGBUF is non-zero before assuming that it
;		contains the original value of IRP$L_SVAPTE in VIRTUAL_LOGIO.
;
;	V03-010	RLRMXBCNTb	Robert L. Rappaport	22-Mar-1983
;		Check for file oriented device before going to VIRTUAL_LOGIO.
;
;	V03-009	RLRMXBCNTa	Robert L. Rappaport	22-Mar-1983
;		CLRL the byte count in the I/O status before queueing
;		an IRP back to the ACP in VIRTUAL_LOGIO.
;
;	V03-008	RLRMXBCNT	Robert L. Rappaport	11-Mar-1983
;		Allow for segmentation of Logical I/O (and Virtual)
;		based on the UCB$L_MAXBCNT field.
;
;	V03-007	ROW49597	Ralph O. Weber		26-JAN-1983
;		Change both VIRTUAL and PAGEIO_OR_SWAPIO to guarantee an error 
;		status in IRP$L_IOST1 whenever the bytes transfered is less 
;		than the bytes requested.  For V3.x, the error will be 
;		SS$_CTRLERR.  After that, it will be SS$_INCSEGTRA.  The check 
;		and error status are required to detect and gracefully 
;		revcover from the instance where a driver returns success 
;		status but bytes transfered is less than bytes requested.  
;		The segmented transfer logic goes berserk when this happens 
;		and eventually crashes the system.
;
;	V03-006	STJ3049		Steven T. Jeffreys	06-Jan-1983
;		Add support for the erase qio.
;
;	V03-005	CDS0002		C Saether		12-Oct-1982
;		Fix bug where R5 was not preserved when queuing
;		packet to xqp.
;
;	V03-004	CDS0001		C Saether		18-Jul-1982
;		Changes to accomodate XQP mechanism.
;
;	V03-003	KDM0002		Kathleen D. Morse	28-Jun-1982
;		Added $DEVDEF and $SSDEF.
;
;	V03-002	LJK45299	Lawrence J. Kenah	2-Jun-1982
;		Fix deaccess-pending-on-spooled-device logic.
;
;
;**

	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;
	$ACBDEF				; AST CONTROL BLOCK DEFINITIONS
	$AQBDEF				; DEFINE AQB OFFSETS
	$CADEF				; CONDITIONAL ASSEMBLY PARAMETERS
	$CCBDEF				; CCB DEFINITIONS
	$CXBDEF				; DEFINE CXB OFFSETS
	$DCDEF				; DEVICE TYPE CODES
	$DEVDEF				; DEVICE TYPE DEFINITIONS
	$IODEF				; I/O REQUEST CODES
	$IPLDEF				; IPL DEFINITIONS
	$IRPDEF				; IRP DEFINITIONS
	$IRPEDEF			; IRPE DEFINITIONS
	$JIBDEF				; JIB DEFINITIONS
	$PCBDEF				; PCB DEFINITIONS
	$PFNDEF				; PFN DATA BASE DEFINITIONS
	$PHDDEF				; PROCESS HEADER DEFINITIONS
	$PRDEF				; PROCESSOR REGISTER DEFINITIONS
	$PRIDEF				; PRIORITY INCREMENT DEFS
	$PTEDEF				; PAGE TABLE ENTRY DEFINITIONS
	$RSNDEF				; DEFINE RESOURCE WAIT NUMBERS
	$SSDEF				; DEFINE SYSTEM STATUS CODES
	$UCBDEF				; DEFINE UCB OFFSETS
	$VADEF				; DEFINE VIRTUAL ADDRESS FIELDS
	$VCBDEF				; DEFINE VCB OFFSETS
	$WCBDEF				; DEFINE WCB OFFSETS
	$WQHDEF				; WAIT QUEUE HEADER DEFINITIONS

;
; OWN STORAGE:
;
	.PSECT	$AEXENONPAGED,LONG
PRITBL:					; TABLE OF PRIORITY INCR CLASSES
	.BYTE	PRI$_IOCOM		; 0 => DIRECT WRITE
	.BYTE	PRI$_TOCOM		; 1 => BUFFERED WRITE
	.BYTE	PRI$_IOCOM		; 2 => DIRECT READ
	.BYTE	PRI$_TICOM		; 3 => BUFFERED READ

	.SBTTL	I/O COMPLETION POSTING
;++
; FUNCTIONAL DESCRIPTION:
;
;	IOC$IOPOST IS INITIATED BY TRIGGERING AN IPL$_IOPOST SOFTWARE
;	INTERRUPT AFTER PLACING A COMPLETED I/O PACKET IN THE IOPOST
;	QUEUE.  IOC$IOPOST PERFORMS ALL APPROPRIATE COMPLETION ACTIVITY
;	REQUIRED FOR THE PACKET EITHER DIRECTLY OR BY QUEUEING KERNEL
;	ASTS TO CONCLUDE PROCESSING IN THE CONTEXT OF THE PROCESS
;	WHEN REQUIRED.
;
; CALLING SEQUENCE:
;
;	SOFTINT	#IPL$_IOPOST
;
; INPUT PARAMETERS:
;
;	NONE
;
; IMPLICIT INPUTS:
;
;	IOC$GL_PSFL - IOPOSTING QUEUE
;
; OUTPUT PARAMETERS:
;
;	NONE
;
;--

	.ENABL	LSB
IOC$IOPOST::				; I/O POSTING INTERRUPT
	MOVQ	R4,-(SP)		; SAVE
	MOVQ	R2,-(SP)		; NORMAL
	MOVQ	R0,-(SP)		; REGISTERS
IOPOST:	REMQUE	@W^IOC$GL_PSFL,R5	; GET HEAD OF POST QUEUE
	BVC	10$			; QUEUE NOT YET EMPTY
	MOVQ	(SP)+,R0		; RESTORE
	MOVQ	(SP)+,R2		; REGISTERS
	MOVQ	(SP)+,R4		; AND EXIT
	REI				; IF QUEUE EMPTY

5$:	BRW	VIRTUAL_LOGIO		; PROCESS VIRTUAL (OR LOGICAL) I/O COMPLETION

7$:	JSB	(R1)			; CALL END ACTION ROUTINE
	BRB	IOPOST			;

8$:	CLRW	UCB$W_QLEN(R0)		; Device queue length went negative
	BRB	11$			; Reset queue length and continue

10$:	MOVL	IRP$L_PID(R5),R1	; GET PID/END ACTION ADDRESS
	BLSS	7$			; BR IF END ACTION ADDRESS
					; (SYSTEM SPACE ADDRESSES ARE NEGATIVE)
	MOVZWL	R1,R1			; GET PROCESS INDEX
	MOVL	@W^SCH$GL_PCBVEC[R1],R4	; AND TRANSLATE TO PCB ADDRESS
	MOVL	IRP$L_UCB(R5),R0	; R0 => UCB. (Presets UCB for DIO path)
	DECW	UCB$W_QLEN(R0)		; Decrement device queue length
	BLSS	8$			; Length went negative, so go adjust
11$:	BBC	#IRP$V_KEY,IRP$W_STS(R5),12$ ; set, buffer alloc for encryption
	PUSHL	R0			; Save UCB address
    	MOVL	IRP$L_KEYDESC(R5), R0	; r0 contains address of alloc buffer
    	BSBW	EXE$DEANONPAGED		; deallocate buffer (R0-R3 destroyed)
	POPL	R0			; Restore UCB address
12$:	BBC	#IRP$V_BUFIO,IRP$W_STS(R5),13$	; IF CLEAR, DIRECT I/O
	BRW	BUFIO			; BUFFERED I/O
13$:	INCW	PCB$W_DIOCNT(R4)	; UPDATE DIRECT I/O COUNT
	MOVL	IRP$L_SVAPTE(R5),R3	; GET ADDRESS OF FIRST PTE

	ASSUME	IRP$V_PAGIO LE 7
	ASSUME	IRP$V_SWAPIO LE 7
	BITB	#<IRP$M_PAGIO ! IRP$M_SWAPIO>,IRP$W_STS(R5) ; PAGIO OR SWAPIO?
	BNEQ	PAGIO_OR_SWAPIO
 
;
; DIRECT I/O COMPLETION
;
 
DIRIO:	TSTL	R3			; PTE ADDRESS VALID?
	BEQL	18$			; IF EQL NO PAGES TO UNLOCK
	MOVL	IRP$L_BCNT(R5),R1	; GET REQUESTED TRANSFER BYTE COUNT
	MOVZWL	IRP$W_BOFF(R5),R2	; GET BYTE OFFSET IN PAGE
	BBS	#IRP$V_PHYSIO,-
		IRP$W_STS(R5),UNLOCK	; BRANCH IF PHYSICAL I/O
	BBC	#DEV$V_FOD,-		; If NOT file oriented, go to UNLOCK.
		UCB$L_DEVCHAR(R0),UNLOCK; (R0 preloaded in common DIO/BIO path)
	BLBC	IRP$L_IOST1(R5),5$	; BRANCH IF ERROR IN VIRT. OR LOG. REQUEST
	TSTW	IRP$L_OBCNT+2(R5)	; WAS ORIGINAL COUNT > 64K?
	BEQL	14$			; EQL IMPLIES NO
	CMPL	IRP$L_IOST1+2(R5),-	; LONGWORD COMPARE FOR > 64K OBCNT
		IRP$L_OBCNT(R5)		; IF COMPLETED ORIGINAL BYTE COUNT
					; THEN NO SPECIAL VIRTUAL PROCESSING
	BRB	16$			; BRANCH AROUND TO COMMON 'BNEQ'
14$:
	CMPW	IRP$L_IOST1+2(R5),-	; *NOTE 'CMPW' DUE TO CODE PATH FOR <64K BCNT
		IRP$L_OBCNT(R5)		; IF COMPLETED ORIGINAL BYTE COUNT
					; THEN NO SPECIAL VIRTUAL PROCESSING
16$:
	BNEQ	5$			; OTHERWISE DO THE SEGMENTED COMPLETION
UNLOCK:	MOVAB	511(R1)[R2],R1		; COMBINE OFFSET AND COUNT AND ROUND
	ASHL	#-VA$S_BYTE,R1,R1	; CONVERT TO NUMBER OF PAGES
	BNEQ	165$			; CHECK FOR AT LEAST ONE PAGE
	INCL	R1			; THE FDT ROUTINE LOCKED ONE PAGE
165$:	BBC	#IO$V_ERASE,-		; BRANCH IF DEFINITELY NOT AN ERASE
		IRP$W_FUNC(R5),17$	;
	BSBW	CHECK_ERASE		; IS THIS AN ERASE FUNCTION?
	BLBS	R0,19$			; BRANCH IF IT IS AN ERASE
17$:	BSBW	MMG$UNLOCK		; UNLOCK PAGES
18$:	BBC	#IRP$V_EXTEND,-
		IRP$W_STS(R5),19$	; BRANCH IF NO IRPE'S ATTACHED
	BSBW	UNLOCK_MORE		; UNLOCK AREAS DESCRIBED IN IRPE'S
19$:					; REFERENCE LABEL
 
	.IF DF	CA$_MEASURE_IOT
 
	BSBW	PMS$END_RQ		; INSERT END OF I/O REQUEST MESSAGE
 
	.ENDC
 
	MOVAB	W^DIRPOST,ACB$L_KAST(R5) ; SET SPECIAL KERNEL AST ADDRESS
	BRW	40$			;

BRW_QNXTSEG:
	BRW	QNXTSEG			; GO DO THE NEXT VIRTUAL SEGMENT

;
;	PAGE I/O OR SWAP I/O COMPLETION
;

PAGIO_OR_SWAPIO:			; HERE WE ASSUME DISK I/O FOR PAGING
					;  AND SWAPPING AND WE FURTHER RELY
					;  ON THE FACT THAT ALL DISK DRIVERS
					;  TRADITIONALLY RETURN ZERO IN THE 2ND
					;  LONGWORD OF THE I/O STATUS BLOCK FOR
					;  DATA TRANSFER OPERATIONS.  THEREFORE
					;  THIS IS COMPATIBLE WITH DISK CLASS
					;  DRIVER WHICH GROWS THE # OF BYTES
					;  TRANSFERRED FIELD IN THE IOSB TO A
					;  FULL LONGWORD.
	MOVL	IRP$L_IOST1+2(R5), R1	; Get bytes transfered.
	BLBC	IRP$L_IOST1(R5), 21$	; Branch if transfer not successful.
	CMPL	R1, IRP$L_OBCNT(R5)	; If completed whole transfer, skip
	BEQL	26$			; all this segmenting junk.
	CMPL	R1, IRP$L_BCNT(R5)	; Bytes transfered = bytes requested?
	BEQL	23$			; Branch if equal.
	MOVW	#SS$_INCSEGTRA, -	; Else, change success status
		IRP$L_IOST1(R5)		; to error status.
					; For the error cases:
21$:	CMPL	R1, IRP$L_BCNT(R5)	; Bytes transfered < bytes requested?
	BLSSU	23$			; Branch if less than.
	CLRL	R1			; Else, assume no bytes transfered.
	CLRL	IRP$L_IOST1+2(R5)	; Clear bytes transfered in IRP too.
23$:	ADDL	R1, IRP$L_ABCNT(R5)	; Update accumulated byte count.
	EXTZV	#VA$V_VPN, -		; Convert bytes transfered to 
		#<32-VA$V_VPN>, R1, R1	; pages transfered.
	ADDL	R1,IRP$L_SEGVBN(R5)	; NEXT STARTING VBN (OR ERROR VBN)
	BLBC	IRP$L_IOST1(R5),24$	; BRANCH IF ERROR
	SUBL3	IRP$L_ABCNT(R5),-
		IRP$L_OBCNT(R5),-	; CALCULATE REMAINING BYTE
		IRP$L_BCNT(R5)		; COUNT TO BE TRANSFERRED
	BNEQ	BRW_QNXTSEG		; BRANCH IF ANOTHER SEGMENT TO DO
;
; LAST SEGMENT COMPLETED OR ERROR
;
24$:
	MOVL	IRP$L_ABCNT(R5),-
		IRP$L_IOST1+2(R5)	; SET BYTES TRANSFERRED
	MOVL	IRP$L_DIAGBUF(R5),R3	; GET SAVED SVAPTE
	MOVL	R3,IRP$L_SVAPTE(R5)	; AND PUT IT BACK
26$:
	.IF DF	CA$_MEASURE_IOT
 
	BSBW	PMS$END_RQ		; INSERT END OF I/O REQUEST MESSAGE
 
	.ENDC
 
	BBS	#IRP$V_PAGIO,IRP$W_STS(R5),PAGIO ; BRANCH IF PAGE I/O

;
;	SWAP I/O COMPLETION
;

	MOVL	IRP$L_ASTPRM(R5),ACB$L_KAST(R5)	; SET KERNEL AST ADDRESS
	BRB	40$			; AND ENQUEUE AST

;
; BUFFERED I/O COMPLETION
;
 
BUFIO:	PUSHAB	40$			; 'INLINE' SUBROUTINE CALL.

;
; THE FOLLOWING PIECE OF CODE MAY BE CALLED AS A SUBROUTINE DIRECTLY
; TO DO THE PART OF BUFFERED I/O COMPLETION THAT NORMALLY EXECUTES
; AS A RESULT OF AN IOPOST SOFTWARE INTERRUPT.
;
; THE F11BXQP, FOR EXAMPLE, EXECUTES VIRTUAL FILE SYSTEM FUNCTIONS
; IN PROCESS CONTEXT.  THERE IS NO NEED FOR THE IOPOST INTERRUPT
; AND SPECIAL KERNEL AST TO POST I/O COMPLETION.  AFTER RETURNING
; FROM THIS SUBROUTINE, THE F11BXQP WILL DO A
;
;	JSB	@ACB$L_KAST (R5)
;
; TO COMPLETE POSTING THE I/O COMPLETION.
; BOTH THE IOPOST SOFTWARE INTERRUPT AND THE SPECIAL KERNEL COMPLETION
; AST ARE AVOIDED.
;
; THE CALLER SHOULD TEST IRP$L_PID AND POST A NORMAL IOPOST INTERRUPT
; IF IT IS NEGATIVE, AS THAT CASE IS NOT HANDLED HERE.
;
; THE F11BXQP CODE THAT USES THIS ROUTINE IS IN [F11X.SRC]IODONE.MAR.
;
; IPL = IPL$_ASTDEL TO BLOCK PROCESS DELETION (PREVENT LOSS OF IRP).
; R4 = PCB ADDRESS
; R5 = IRP ADDRESS
;

IOC$BUFPOST::
	INCW	PCB$W_BIOCNT(R4)	; UPDATE BUFFERED I/O COUNT
	BBC	#IRP$V_FILACP,IRP$W_STS(R5),NOTACP ; BR IF NOT ACP I/O
	INCW	PCB$W_DIOCNT(R4)	; RESTORE DIRECT I/O COUNT
NOTACP:					;
 
	.IF DF	CA$_MEASURE_IOT
 
	BSBW	PMS$END_RQ		; INSERT END OF I/O REQUEST MESSAGE
 
	.ENDC
 
	MOVL	PCB$L_JIB(R4),R0	; GET JIB ADDRESS
	MOVZWL	IRP$W_BOFF(R5),R1	; Convert I/O byte count to a longword.
	ADDL	R1,JIB$L_BYTCNT(R0)	; Update Byte Count Quota.
	MOVL	IRP$L_SVAPTE(R5),R0	; ANY BUFFER SPECIFIED?
	BEQL	30$			; IF EQL NO
	MOVAB	W^BUFPOST,ACB$L_KAST(R5) ; ASSUME READ FUNCTION
	BBS	#IRP$V_FUNC,IRP$W_STS(R5),35$  ; IF SET, READ FUNCTION
	BSBW	EXE$DEANONPAGED		; DEALLOCATE WRITE BUFFER
30$:	MOVAB	W^DIRPOST,ACB$L_KAST(R5) ; SET SPECIAL KERNEL AST ADDRESS
35$:	RSB				; RETURN TO PROCESS CONTEXT IOPOSTING
					; PROCESS, OR CONTINUE INLINE IF THIS
					; IS NORMAL IOPOST SOFTWARE INTERRUPT.
40$:	EXTZV	#IRP$V_BUFIO,#2,IRP$W_STS(R5),R0  ; GET PACKET TYPE
	BBS	#IRP$V_TERMIO,IRP$W_STS(R5),50$	; BR IF TERMINAL I/O
	BICW	#1,R0			; ELSE TREAT AS NORMAL I/O COMPLETION
50$:					; FOR PRIORITY INCREMENT SELECTION
	MOVL	IRP$L_PID(R5),R1	; PROCESS IDENTIFICATION
	MOVZBL	PRITBL[R0],R2		; SET PRIORITY INCREMENT CLASS
	MOVZBL	IRP$B_EFN(R5),R3	; GET EVENT FLAG NUMBER
	DSBINT	#IPL$_SYNCH		; PREVENT INTERRUPT FROM MP SECONDARY
	BSBW	SCH$POSTEF		; AND POST IT
	BISB	#^X80,ACB$B_RMOD(R5)	; SET INTERNAL AST FLAG
	BSBW	SCH$QAST		; NOW QUEUE THE KERNEL AST
	ENBINT
	BRW	IOPOST			; GET NEXT PACKET TO POST
	.DSABL	LSB

	.SBTTL	PAGIO - PAGE I/O COMPLETION
;
; PAGING I/O COMPLETION
;
; INPUTS:
;
;	R3 = SYSTEM VIRTUAL ADDRESS OF PAGE TABLE ENTRY
;	R4 = PROCESS CONTROL BLOCK ADDRESS
;	R5 = I/O REQUEST PACKET ADDRESS
;
;		FOR PAGE READ COMPLETION, THE FOLLOWING LOCATIONS IN THE
;	I/O REQUEST PACKET HAVE SPECIAL SIGNIFICANCE.
;
;	IRP$L_ASTPRM	= ORIGINAL PROCESS PAGE TABLE ENTRY BACKING STORE
;			  ADDRESS IF PAGE WAS A COPY ON REFERENCE PAGE.
;			  PFN$V_GBLBAK SET IF IT WAS GLOBAL CRF
;			= 0 IF NOT A COPY ON REFERENCE PAGE
;	IRP$L_AST	= MASTER PTE CONTENTS IF GLOBAL CRF (>0)
;			= SLAVE PTE ADDRESS IF GLOBAL NOT CRF (<0)
;			= 0 IF NOT GLOBAL
;
;		FOR PAGE WRITE COMPLETION, THE FOLLOWING LOCATIONS IN
;	THE I/O REQUEST PACKET HAVE SIGNIFICANCE.
;
;	IRP$B_RMOD	= REQUEST MODE ! ACB$V_QUOTA.  IF ACB$V_QUOTA IS SET,
;			  PROCESS REQUESTED AN AST ON PAGE WRITE COMPLETION
;	IRP$L_AST	= AST ADDRESS IF REQUESTED
;	IRP$L_ASTPRM	= AST PARAMETER IF SPECIFIED
;	IRP$L_IOSB	= ADDRESS OF I/O STATUS BLOCK IF SPECIFIED.  IF
;			  NON-ZERO, THEN PROCESS EXPECTS I/O STATUS RETURNED.
;
PAGIO:	MOVQ	R6,-(SP)		; SAVE SOME MORE REGISTERS
	MOVL	R5,R6			; USE R6 FOR IRP ADDRESS

	SETIPL	#IPL$_SYNCH		; SYNCHRONIZE ACCESS TO SYSTEM DATA BASE
	MOVL	PCB$L_PHD(R4),R5	; USE R5 FOR PROCESS HEADER ADR
	EXTZV	#VA$V_VPN,-
		#<32-VA$V_VPN>,-	; FORM PAGE COUNT
		IRP$L_IOST1+2(R6),R7	; OF THE DATA TRANSFERRED
	BBS	#IRP$V_FUNC,IRP$W_STS(R6),PAGRD_DONE ; BRANCH IF PAGE READ
;
; PAGE WRITE COMPLETE - R7 = NUMBER OF PAGES
;	CONDITION CODES SET FROM LOAD OF R7
;
	BEQL	60$			; BRANCH IF NO PAGES SUCCESSFULLY TRANSFERRED
	EXTZV	#PTE$V_PFN,#PTE$S_PFN,(R3),R0 ;GET PFN FROM PTE
	CMPL	R0,MMG$GL_MAXPFN	;IS THIS PAGE IN SHARED MEMORY?
	BGTRU	60$			;BR IF PAGE IN SH MEM, NO PFN DATABASE
20$:	PUSHL	R3			; SAVE SVAPTE
	BSBW	PFN_IO_DONE		; SET PFN DATA BASE
;
; CONDITION CODES SET FROM DECREF
;
	BGTR	40$			; BRANCH IF REFCNT NOT 0
	BSBW	MMG$RELPFN		; RELEASE THE PAGE
40$:	ADDL3	#4,(SP)+,R3		; GET NEXT PTE ADDRESS
	SOBGTR	R7,20$			; DO THE NEXT PAGE IF ANY
60$:	SUBW3	#IRP$C_LENGTH,IRP$W_SIZE(R6),R7 ; IF EXTENDED I/O PACKET
					; THEN COMPLETION IS DONE BY
					; SPECIAL UPDATE SECTION KERNEL AST
	BLBC	IRP$L_IOST1(R6),PAGWRT_ERR ; BRANCH IF PAGE WRITE ERROR
;
; CONDITION CODES SET FROM LOAD OF R7
;
PAGWRT_ERR_DONE:
	BEQL	PAGIO_DONE1		; BRANCH IF NOT, COMPLETE THE I/O HERE
	BRB	PAGIO_DONE2		; COMPLETE I/O IN PROCESS CONTEXT
PAGWRT_ERR:
	BRW	PAGWRT_ERR1
;
; PAGE READ COMPLETE - R7 = NUMBER OF PAGES
;	CONDITION CODES SET FROM LOAD OF R7
;
PAGRD_DONE:
	BEQL	100$			; BRANCH IF NO PAGES SUCCESSFULLY TRANSFERRED
20$:	BSBW	PFN_IO_DONE		; RECORD PAGE READ DONE
;
; CONDITION CODES SET FROM DECREF
;
	BGTR	30$			; BRANCH IF REFCNT NOT ZERO
;
; NO MORE REFERENCES FOR THIS PAGE, DON'T MAKE IT VALID, RELEASE IT
;
	PUSHAL	4(R3)			; SAVE PTE ADR FOR NEXT PTE
	BSBW	MMG$RELPFN		; RELEASE THE PFN
	POPR	#^M<R3>			; RECOVER PTE FOR NEXT PAGE IN CLUSTER
	ADDL3	#4,IRP$L_AST(R6),R1	; GLOBAL PAGE?
	BGEQ	80$			; BRANCH IF IT ISN'T
	BRB	60$			; YES, SET CONTEXT FOR NEXT PAGE IN CLUSTER
30$:	BISB	#PFN$C_ACTIVE,@W^PFN$AB_STATE[R0] ; PAGE IS NOW ACTIVE
	BBSS	#PTE$V_VALID,R0,40$	; TURN VALID ON WITH PFN
40$:	BISL	R0,(R3)+		; SET VALID IN PTE
					; NEXT PTE ADDRESS IN R3
	MOVL	IRP$L_AST(R6),R1	; GLOBAL PAGE?
	BGEQ	80$			; BRANCH IF NOT
;
; PAGE IS A GLOBAL PAGE, R1 = PROCESS PTE, MUST MAKE IT VALID TOO
;
	BICL3	#^C<PTE$M_PROT ! PTE$M_OWN>,(R1),R2 ; PROTECTION AND OWNER FIELDS
	BISL3	R0,R2,(R1)+		; MAKE PROCESS PTE VALID
60$:	MOVL	R1,IRP$L_AST(R6)	; SET UP FOR NEXT PAGE IN CLUSTER
80$:	SOBGTR	R7,20$			; DO THE NEXT PAGE IF ANY
100$:	BLBC	IRP$L_IOST1(R6),PAGRD_ERR ; BRANCH IF PAGE READ ERROR
;
; LAST PAGE IN CLUSTER HAS BEEN PROCESSED, COMPLETE THE PROCESSING
; ASSOCIATED WITH THE TRANSFER AS A WHOLE.
;
PAGIO_DONE:
	MOVL	IRP$L_ASTPRM(R6),R1	; COPY ON REFERENCE SECTION?
	BEQL	20$			; BRANCH IF NOT
	BBC	#PFN$V_GBLBAK,R1,10$	; BRANCH IF NOT GBL CRF
	MOVAL	@MMG$GL_SYSPHD,R5	; SYSTEM HDR FOR GBL CRF PAGE
	MOVL	IRP$L_AST(R6),R1	; CONTENTS OF GBL PTE FOR GBL CRF
10$:	CVTWL	R1,R1			; SECTION INDEX
	EXTZV	#VA$V_VPN,-
		#<32-VA$V_VPN>,-	; PAGE COUNT FROM
		IRP$L_IOST1+2(R6),R0	; BYTE COUNT TRANSFERRED
	BSBW	MMG$SUBSECREF		; SUBTRACT R0 FROM SECTION REFERENC COUNT
;
; REPORT THAT PAGE I/O HAS COMPLETED.
;
; NORMALLY IT IS ONLY NECESSARY TO REPORT "PAGE FAULT COMPLETE"
; TO THE PROCESS THAT INITIATED THE I/O, BUT FOR SYSTEM PAGES
; AND FOR GLOBAL PAGES, MULTIPLE FAULTS CAN OCCUR FOR THE SAME
; PAGE WHILE IT IS ON ITS WAY INTO MEMORY.  ALL PROCESSES WHICH
; FAULT THE PAGE WHILE ITS STATE IS "READ IN PROGRESS" GET QUEUED
; ON THE COLLISION PAGE QUEUE, AND THE COLLISION BIT IS SET IN THE
; TYPE BYTE OF THE PFN DATA BASE.  THIS ROUTINE ALSO REPORTS THE
; COLLISION PAGE AVAILABLE EVENT TO ALL PROCESSES ON THE COLLISION
; QUEUE, IF THE COLLISION BIT IS SET.
;
20$:
PAGIO_DONE1:
	MOVZBL	#PRI$_NULL,R2		; SET FOR NULL PRIORITY INCREMENT
	RPTEVT	PFCOM			; REPORT PAGE FAULT COMPLETE
;
; IRP$W_BOFF WAS INCREMENTED IF ANY OF THE PAGES HAD THE COLLISION BIT SET
;
;	R7 = NON ZERO IF SUPPOSED TO ISSUE KERNEL AST
;	     USED ONLY FOR PAGE WRITE COMPLETION
;	     BUT MUST BE ZERO FOR PAGE READ COMPLETION
;
PAGIO_DONE2:
	TSTW	IRP$W_BOFF(R6)		; ANY PAGES WITH COLLISION BIT SET?
	BEQL	60$			; BRANCH IF NOT
	PUSHL	R4			; SAVE PCB ADDRESS
40$:	TSTW	W^SCH$GQ_COLPGWQ+WQH$W_WQCNT ; ANYONE WAITING?
	BLEQ	50$			; BRANCH IF NOT
	MOVL	W^SCH$GQ_COLPGWQ,R4	; GET NEXT PCB
	RPTEVT	COLPGA			; REPORT "COLLISION PAGE AVAILABLE"
	BRB	40$			; REPEAT UNTIL QUEUE IS EMPTY
50$:	POPR	#^M<R4>			; RESTORE SAVED PCB ADDRESS
60$:	SETIPL	#IPL$_IOPOST		; LOWER TO I/O POST LEVEL
	TSTL	R7			; EXHAUSTED PAGE COUNT NON-ZERO?
	BNEQ	PAGIO_KAST		; BRANCH IF YES, COMPLETE I/O IN PROCESS
	BLBC	IRP$L_IOST1(R6),PAGIO_ERR ; BRANCH IF MORE ERROR PROCESSING TO DO
	MOVL	R6,R0			; GET PACKET ADDRESS FOR RELEASE
	MOVQ	(SP)+,R6		; RESTORE SAVED REGISTERS
;
; R0 = I/O REQUEST PACKET ADDRESS
;
PAGIO_ERR_DONE:
	BSBW	EXE$DEANONPAGED		; AND RELEASE IT
	MOVZWL	#RSN$_ASTWAIT,R0	; SET AST WAIT RESOURCE WAIT NUMBER
	BSBW	SCH$RAVAIL		; SET RESOURCE AVAILABLE
	BRW	IOPOST			; CONTINUE TO PROCESS POST QUEUE
;
; COMPLETE THE PAGE WRITE IN THE PROCESS CONTEXT
;
PAGIO_KAST:
	MOVL	R6,R5			; I/O PACKET ADDRESS BACK TO NORMAL REG
	MOVQ	(SP)+,R6		; RESTORE SAVED REGISTERS
	MOVL	IRP$L_PID(R5),R1	; PROCESS ID FOR ISSUING KERNEL AST
	MOVAB	MMG$UPDSECAST,ACB$L_KAST(R5) ; ADDRESS TO START KERNEL AST
	MOVZBL	#PRI$_IOCOM,R2		; PRIORITY INCREMENT
	BISB	#^X80,ACB$B_RMOD(R5)	; SET INTERNAL AST FLAG
	BSBW	SCH$QAST		; NOW QUEUE THE KERNEL AST
	BRW	IOPOST			; GET NEXT PACKET TO POST
;
; PAGE READ ERROR - CLEAN UP LOGIC
;
;	R3 = PTE ADDRESS OF BAD PAGE
;	R4 = PCB ADDRESS
;	R5 = PROCESS HEADER ADDRESS
;	R6 = I/O REQUEST PACKET ADDRESS
;	R7 = 0 AND MUST BE PRESERVED
;	IRP$L_AST(R6) = PROCESS PTE ADR OF BAD PAGE IF GLOBAL PAGE
;	IRP$L_ASTPRM(R6) = GPTX FOR START OF TRANSFER IF GLOBAL CRF
;
PAGRD_ERR:
	BSBW	PFN_IO_DONE		; COMPLETE THE I/O FOR ERR PAGE
	MOVB	#<PFN$M_DELCON ! PFN$C_RDERR>,- ; SET PAGE TO
		@W^PFN$AB_STATE[R0]	; READ ERROR STATE
	MOVL	IRP$L_ASTPRM(R6),R1	; GET BACKING STORE ADR IF CRF
	BEQL	120$			; BRANCH IF NOT COPY ON REFERENCE
	BBC	#PFN$V_GBLBAK,R1,100$	; BRANCH IF NOT GLOBAL CRF
	EXTZV	#VA$V_VPN,-
		#<32-VA$V_VPN>,-	; ADJUST GPTX BY
		IRP$L_IOST1+2(R6),R2	; TRANSFERRED PAGE COUNT
	ADDL	R2,R1			; TO GET CORRECT GPTX FOR BAD PAGE
	ADDL3	#1,R1,IRP$L_ASTPRM(R6)	; SET GPTX FOR START OF NEXT TRANSFER
100$:	MOVL	R1,@W^PFN$AL_BAK[R0]	; FIX BACKING STORE ADDRESS
120$:	TSTL	IRP$L_AST(R6)		; IF GLOBAL PAGE (NOT CRF)
	BGEQ	140$
	ADDL	#4,IRP$L_AST(R6)	; THEN SKIP OVER PROCESS PTE ADR
140$:	TSTW	@W^PFN$AW_REFCNT[R0]	; IS THIS THE LAST REFERENCE?
	BGTR	160$			; BRANCH IF NOT
	TSTW	@W^PFN$AW_SWPVBN[R0]	; IF THIS PROCESS HAS BEEN SWAPPED OUT
	BEQL	150$
	MOVZBL	#PFN$C_BADPAGLST,R2	; THEN PUT THIS PAGE IN LIMBO
	BSBW	MMG$INSPFNT		; ON THE BAD PAGE LIST
	BRB	160$
150$:	BSBW	MMG$RELPFN		; OTHERWISE RELEASE THE PAGE
160$:	BRW	PAGIO_DONE		; COMPLETE THIS PORTION OF THE PAGE READ
;
; DO THE REMAINING SEGMENT OF THE I/O FOR A PAGE READ OR WRITE ERROR
; SKIP OVER THE PORTION THAT WAS TRANSFERRED SUCCESSFULLY AND SKIP OVER
; THE PAGE IN ERROR WHICH WAS DEALT WITH BY EITHER PAGRD_ERR OR
; PAGWRT_ERR AND SET UP TO TRANSFER THE REMAINING PAGES IF ANY.
; NOTE THAT FOR PAGE WRITE ERRORS THE REST OF THE TRANSFER IS NOT DONE
; IF I/O COMPLETION STATUS IS RETURNED TO THE PROCESS.
;
PAGIO_ERR:
	MOVL	R6,R5			; IRP ADDRESS
	MOVQ	(SP)+,R6		; RESTORE ADDITIONAL SAVED REGISTERS
	EXTZV	#VA$V_VPN,-
		#<32-VA$V_VPN>,-	; GET PAGE COUNT TRANSFERRED
		IRP$L_IOST1+2(R5),R1
	INCL	R1			; COUNT THE ERROR PAGE AS DONE
	ROTL	#9,R1,R0		; BYTE COUNT COMPLETED
	SUBL	R0,IRP$L_OBCNT(R5)	; BYTE COUNT REMAINING
	BEQL	40$			; BRANCH IF NOTHING LEFT TO DO
	CLRL	IRP$L_ABCNT(R5)		; ZERO ACCUMULATED BYTE COUNT

	CLRW	IRP$W_BOFF(R5)		; ZERO BOFF AND
	MOVL	IRP$L_OBCNT(R5),-
		IRP$L_BCNT(R5)		; SET NEW BYTE COUNT
	INCL	IRP$L_SEGVBN(R5)	; SEGMENT VBN WAS POINTING AT ERROR VBN
	MOVL	IRP$L_DIAGBUF(R5),R3	; STARTING SVAPTE OF ENTIRE TRANSFER
	MOVAL	(R3)[R1],IRP$L_DIAGBUF(R5) ; STARTING PTE ADDRESS OF THIS SEGMENT

	.IF	DF,CA$_MEASURE_IOT
	PUSHL	R3			;REMEMBER SVAPTE
	MOVL	R5,R3			;SET ADR OF IRP
	BSBW	PMS$START_RQ		; INSERT START OF I/O REQUEST MESSAGE
	POPL	R3			;RESTORE SVAPTE
	.ENDC

	BRW	QNXTSEG			; QUEUE THIS SEGMENT AND RETURN TO IOPOST
40$:	MOVL	R5,R0			; I/O PACKET ADDRESS
	BRW	PAGIO_ERR_DONE
;
; PAGE WRITE ERROR - CLEAN UP LOGIC
;
;	R3 = PTE ADDRESS FOR ERROR PAGE
;	R4 = PCB ADDRESS
;	R5 = PROCESS HEADER ADDRESS
;	R6 = I/O REQUEST PACKET ADDRESS
;	R7 = 0 IF ALL COMPLETION LOGIC IS DONE IN IOPOST
;	   = NON-ZERO IF COMPLETION (AND ERROR REPORT) ARE TO BE
;	     RETURNED TO THE PROCESS.
;
PAGWRT_ERR1:
	PUSHL	R7			; SAVE KERNEL AST FLAG
	EXTZV	#VA$V_VPN,-
		#<32-VA$V_VPN>,-	; PAGE COUNT TRANSFERRED
		IRP$L_IOST1+2(R6),R0
	EXTZV	#VA$V_VPN,-
		#<32-VA$V_VPN>,-	; ORIGINAL PAGE COUNT
		IRP$L_OBCNT(R6),R7
	SUBL	R0,R7			; COUNT OF REMAINING PAGES
	TSTL	(SP)			; IF NOT REPORTING ERROR TO PROCESS
	BNEQ	20$
	MOVL	#1,R7			; ONLY CLEAN UP THE ERROR PAGE HERE
					; REST OF TRANSFER WILL BE DONE BY PAGIO_ERR
20$:	CLRL	-(SP)			; INIT "ERROR PAGE" FLAG
	EXTZV	#PTE$V_PFN,#PTE$S_PFN,(R3),R0 ;GET PFN FROM PTE
	CMPL	R0,MMG$GL_MAXPFN	;IS THIS PAGE IN SHARED MEMORY?
	BGTRU	130$			;BR IF PAGE IN SH MEM, NO PFN DATABASE
70$:	PUSHL	R3			; SAVE SVAPTE
	BSBW	PFN_IO_DONE		; COMPLETE I/O FOR THIS PAGE
	BBSS	#PFN$V_MODIFY,@W^PFN$AB_STATE[R0],80$ ; FORCE MODIFY BIT
80$:
;
; CONDITION CODES STILL SET FROM DECREF AT END OF PFN_IO_DONE
;
	BGTR	120$			; BRANCH IF NOT THE LAST REFERENCE
	BBSS	#0,4(SP),100$		; BRANCH IF NOT ERROR PAGE
;
; THIS IS THE PAGE THAT HAD THE WRITE ERROR
;
	MOVL	#PFN$C_BADPAGLST,R2	; PUT IT ON THE BAD PAGE LIST
	BSBW	MMG$INSPFNT		; WITH "MODIFY" SET AND "BAD" CLEAR
	BRB	120$
100$:	BSBW	MMG$RELPFN		; NO MORE REFERENCES, RELEASE THE PAGE
120$:	ADDL3	#4,(SP)+,R3		; NEXT PTE ADDRESS
	SOBGTR	R7,70$
130$:	POPR	#^M<R0,R1>		;CLEAN OFF BAD PAGE FLAG
					; R1 = SAVED KERNEL AST INDICATOR
	MOVL	R1,R7			; PUT IT IN R7, SET CONDITION CODES
	BRW	PAGWRT_ERR_DONE
;
; PFN_IO_DONE
;
; INPUTS:
;
;	R3 = SVAPTE
;	R4 = PROCESS CONTROL BLOCK ADDRESS OF PROCESS THAT REQUESTED THE I/O
;	R5 = PROCESS HEADER OF THE PROCESS THAT REQUESTED THIS I/O
;	R6 = I/O REQUEST PACKET ADDRESS
;
; OUTPUTS:
;
;	R0 = PFN
;	R3 PRESERVED
;	IRP$W_BOFF(R6) INCREMENTED IF THIS WAS A COLLISION PAGE
;	CONDITION CODES SET FROM DECW @W^PFN$AW_REFCNT[R0]
;
PFN_IO_DONE:
	EXTZV	#PTE$V_PFN,#PTE$S_PFN,(R3),R0 ; GET PAGE FRAME NUMBER
	BICB3	#^C<PFN$M_COLLISION ! PFN$M_PAGTYP>,- ; FETCH THESE
		@W^PFN$AB_TYPE[R0],R1	; BITS FROM PFN TYPE BYTE
	BBCC	#PFN$V_COLLISION,R1,20$	; CLEAR COLLISION BIT, BRANCH IF WAS CLEAR
	BICB	#PFN$M_COLLISION,@W^PFN$AB_TYPE[R0] ; CLEAR IT IN PFN DATA
	INCW	IRP$W_BOFF(R6)		; MUST EMPTY THE COLLISION QUEUE
20$:	CMPB	R1,#PFN$C_PPGTBL	; IF PROCESS PAGE TABLE PAGE
	BNEQ	40$
	MOVZWL	PHD$W_PHVINDEX(R5),R1	; MUST COUNT ONE LESS
	BSBW	MMG$DECPHDREF1		; PROCESS HEADER REFERENCE
40$:	DECREF				; ONE LESS REFERENCE FOR THE PAGE
	RSB				; RETURN WITH CONDITION CODES SET
					; TO NEW STATE OF THE REFCNT

	.SBTTL	VIRTUAL (OR LOGICAL) I/O COMPLETION
;
; VIRTUAL (OR LOGICAL) I/O COMPLETION
;
; CALLING SEQUENCE:
;
;	BRW	VIRTUAL
;
; INPUTS:
;
;	R1 = REQUESTED BYTE COUNT, POSSIBLY DIFFERENT FROM TRANSFERRED
;	     BYTE COUNT FOR MAGTAPE
;	R2 = IRP$W_BOFF CONTENTS
;	R3 = SVAPTE OF START OF TRANSFER
;	R4 = PCB ADDRESS ASSOCIATED WITH THE PID IN THE PACKET
;	R5 = IRP ADDRESS
;
; OUTPUTS:
;
;	BRANCHES TO UNLOCK, PRESERVING R1,R2,R3
;	OR BRANCHES TO IOPOST
;

	.ENABL	LSB

VIRTUAL_LOGIO:				; VIRTUAL (OR LOGICAL) I/O FUNCTION
	TSTW	IRP$L_OBCNT+2(R5)	; SEE IF BYTE COUNT > 64K
	BEQL	1$			; EQL IMPLIES NO, BRANCH TO OLD CODE

	MOVL	IRP$L_IOST1+2(R5), R0	; Else pickup new, longer count.
	ADDL	R0, IRP$L_ABCNT(R5)	; Accumulate total bytes transfered.
	MOVL	IRP$L_ABCNT(R5), -	; Set accumulated bytes transfered.
		IRP$L_IOST1+2(R5)	
	BRB	3$			; Rejoin common code.

1$:	MOVZWL	IRP$L_IOST1+2(R5), R0	; Get old bytes transfered count.
	ADDL	R0, IRP$L_ABCNT(R5)	; Accumulate total bytes transfered.
	MOVW	IRP$L_ABCNT(R5), -	; Set accumulated bytes transfered.
		IRP$L_IOST1+2(R5)	; (Note movw due to code path that
					; insures < 64K byte transfer.)

3$:	PUSHL	R0			; Save # bytes transferred.
	CMPL	R0, R1			; Do bytes xfered and requested match?
	BEQL	9$			; Branch if they match.
	MOVL	IRP$L_UCB(R5),R0	; R0 => UCB.
	BBS	S^#DEV$V_SQD,-
		UCB$L_DEVCHAR(R0),9$	; If SET, sequential device
	BLBC	IRP$L_IOST1(R5), 9$	; If xfer count wrong, guarantee
	MOVW	#SS$_INCSEGTRA, -	; that final status is an error
		IRP$L_IOST1(R5)		; (either the driver's or ours).
9$:	ASHL	#-VA$S_BYTE,(SP)+, R0	; Calculate number of blocks transfered.
	ADDL	R0, IRP$L_SEGVBN(R5)	; Calculate next disk segment address.
	BLBC	IRP$L_IOST1(R5),20$	; IF LBC I/O ERROR
	MOVL	IRP$L_UCB(R5),R0	; GET ADDRESS OF DEVICE UCB
	BBS	S^#DEV$V_SQD,UCB$L_DEVCHAR(R0),10$ ; IF SET, SEQUENTIAL DEVICE
	SUBL3	IRP$L_ABCNT(R5),-
		IRP$L_OBCNT(R5),-	; CALCULATE BYTES REMAINING
		IRP$L_BCNT(R5)		;
	BEQL	10$			; IF EQL NONE
	ASHL	#-VA$S_BYTE,R1,R1	; CALCULATE NUMBER OF PAGES REQUESTED
QNXTSEG:
;
; ADVANCE THE SVAPTE TO POINT TO THE PORTION OF THE PAGE TABLES THAT MAP THE
; BUFFER FOR THIS SEGMENT.  IF THIS IS AN ERASE I/O, DO NOT ADVANCE THE
; SVAPTE, AS THE ENTIRE TRANSFER IS MAPPED BY A SINGLE PAGE TABLE PAGE.
;
	INCL	W^PMS$GL_SPLIT		; COUNT A SPLIT TRANSFER
	BBC	#IO$V_ERASE,-		; BRANCH IF NOT ERASE - UPDATE SVAPTE
		IRP$W_FUNC(R5),13$	;
	BSBW	CHECK_ERASE		; IS THIS AN ERASE I/O REQUEST
	BLBS	R0,69$			; BRANCH IF YES - DO NOT ADVANCE SVAPTE
13$:	MOVAL	(R3)[R1],IRP$L_SVAPTE(R5) ; SET ADDRESS OF NEXT PTE ENTRY
69$:	MOVL	R5,R3			; COPY I/O REQUEST PACKET ADDRESS
	MOVL	IRP$L_UCB(R3),R5	; COPY UCB ADDRESS
	BSBB	IOC$QNXTSEG		; QUEUE THE NEXT VIRTUAL SEGMNET
5$:	BRW	IOPOST
;
; ALL SEGMENTS OF THIS TRANSFER ARE COMPLETE
;
10$:
	MOVL	IRP$L_OBCNT(R5),R1	; GET ORIGINAL BYTE COUNT
	MOVL	IRP$L_DIAGBUF(R5),R3	; GET ORIGINAL PAGE TABLE ADDRESS
	BNEQ	15$			; NEQ implies IRP$L_DIAGBUF was valid.
	MOVL	IRP$L_SVAPTE(R5),R3	; If not valid, then IRP$L_SVAPTE is.
15$:	MOVL	R3,IRP$L_SVAPTE(R5)	; SVAPTE MUST BE CORRECT
	BRW	UNLOCK			;
 
;
; I/O OPERATION ENDED WITH AN UNSUCCESSFUL STATUS
;
;		IF THE REQUEST IS  LOGICAL I/O, BRANCH BACK TO UNLOCK. (10$)
;
;		IF THE DEVICE IS A SEQUENTIAL DEVICE, THEN THE I/O PACKET IS
;		MERELY SENT TO THE ACP FOR NOTIFICATION OF THE ERROR.
;
;		IF THE DEVICE IS A RANDOM DEVICE, THEN THE VIRTUAL BLOCK NUMBER
;		STORED IN IRP$L_SEGVBN IS THE BLOCK THAT HAS AN ERROR.
;
 
20$:	BBC	#IRP$V_VIRTUAL,-
		IRP$W_STS(R5),10$	; Branch IF Logical I/O
	TSTW	IRP$L_OBCNT+2(R5)	; SEE IF BYTE COUNT > 64K
	BEQL	30$			; EQL implies < 64K.
	CLRL	IRP$L_IOST1+2(R5)	; Zero byte count before recycleing IRP
	BRB	40$			; Branch around
30$:
	CLRW	IRP$L_IOST1+2(R5)	; Zero byte count before recycleing IRP
40$:
	MOVL	R5,R3			; COPY IRP ADDRESS
	DECW	PCB$W_DIOCNT(R4)	; ADJUST DIRECT I/O COUNT
	BICW	#IRP$M_VIRTUAL,IRP$W_STS(R3) ; CLEAR VIRTUAL I/O FLAG
	MOVL	IRP$L_DIAGBUF(R3),IRP$L_SVAPTE(R3) ; RESET PAGE TABLE ADDRESS
	MOVL	IRP$L_OBCNT(R3),R2	; GET ORIGINAL BYTE COUNT
	BSBW	IOC$QTOACP		; QUEUE PACKET TO ACP
	BRB	5$

	.DSABL	LSB

	.SBTTL	QUEUE NEXT SEGMENT
;
; FUNCTIONAL DESCRIPTION:
;
;	IOC$QNXTSEG PERFORMS THE FUNCTION OF QUEUEING THE NEXT
;	SEGMENT OF A VIRTUAL I/O REQUEST THAT DID NOT MAP TO A
;	SINGLE CONTIGUOUS I/O REQUEST.
;
; CALLING SEQUENCE:
;
;	BSBW	IOC$QNXTSEG
;
; INPUTS:
;
;	R3 = I/O REQUEST PACKET ADDRESS
;	R4 = PCB ADDRESS ASSOCIATED WITH THE PID IN THE PACKET
;	R5 = UCB ADDRESS OF THE ASSOCIATED DEVICE
;
; OUTPUTS:
;
;	R4 NOT PRESERVED
;

	.ENABLE	LSB
					; Out of line code for Logical I/O.
					; This code mimics results of
					;  IOC$MAPVBLK for Logical I/O.
5$:	MOVL	R0,R1			; Namely R1 = LBN.
	BRB	10$			; Branch back to common code.

IOC$QNXTSEG::
	MOVL	IRP$L_WIND(R3),R2	; GET ADDRESS OF MAPPING WINDOW
	MOVL	IRP$L_BCNT(R3),R1	; GET SIZE OF NEXT SEGMENT
	MOVL	IRP$L_SEGVBN(R3),R0	; GET STARTING VIRTUAL BLOCK NUMBER
;
; ALTERNATE ENTRY TO IOC$QNXTSEG:
;
;	BSBW	IOC$QNXTSEG1
;
; ADDITIONAL INPUTS:
;
;	R0 = VIRTUAL BLOCK NUMBER OF START OF NEXT SEGMENT
;	R1 = DESIRED BYTE COUNT OF NEXT SEGMENT
;	R2 = WINDOW ADDRESS
;
IOC$QNXTSEG1::
	DECW	PCB$W_DIOCNT(R4)	; ADJUST THE DIRECT I/O COUNT
	BBC	#IRP$V_VIRTUAL,-	; Branch to out of line code if this
		IRP$W_STS(R3),5$	;  is Logical I/O.
	JSB	G^IOC$MAPVBLK		; MAP VIRTUAL TO LOGICAL BLOCK
	MOVL	R5,IRP$L_UCB(R3)	; STORE POSSIBLY MODIFIED UCB ADDRESS
	SUBL	R2,IRP$L_BCNT(R3)	; CALCULATE SIZE OF NEXT SEGMENT
	BEQL	30$			; IF EQL TOTAL MAP FAILURE
10$:	MOVL	UCB$L_MAXBCNT(R5),R2	; R2 = 0 or Max. permissible BCNT.
	BNEQ	15$			; NEQ implies Max. permissible BCNT in R0.
	MOVZWL	#512*127,R2		; If 0, use default Max. permissible.
15$:	BBC	#IO$V_ERASE,-		; BRANCH IF DEFINITELY NOT AN ERASE
		IRP$W_FUNC(R3),17$	;
	PUSHL	R5			; SAVE UCB ADDRESS
	MOVL	R3,R5			; COPY IRP ADDRESS
	BSBW	CHECK_ERASE		; IS THIS AN ERASE FUNCTION?
	POPL	R5			; RESTORE UCB ADDRESS
	BLBC	R0,17$			; BRANCH IF IT IS NOT AN ERASE
	TSTL	IRP$L_SVAPTE(R3)	; ARE WE USING A DUMMY PAGE TABLE?
	BEQL	17$			; BRANCH IF NOT
	MOVZWL	#512*127,R0		; GET MAX BYTE COUNT FOR PPT
	CMPL	R2,R0			; CHECK LIMIT AGAINST MAX
	BLEQU	17$			; BRANCH IF OK
	MOVL	R0,R2			; LIMIT TRANSFER TO PPT SIZE

17$:	CMPL	R2,IRP$L_BCNT(R3)	; See if BCNT too large.
	BGEQU	20$			; GEQU implies we are OK.
	MOVL	R2,IRP$L_BCNT(R3)	; Else scale down to maximum allowed.
20$:
	MOVL	IRP$L_BCNT(R3),R2	; GET TRANSFER BYTE COUNT
	DECL	R2			; ROUND DOWN AND...
	ASHL	#-VA$S_BYTE,R2,R2	; SHIFT DOWN FOR BLOCK COUNT - 1
	ADDL	R1,R2			; COMPUTE ENDING BLOCK NUMBER
	BCS	25$			; BRANCH ON OVERFLOW
	CMPL	R2,UCB$L_MAXBLOCK(R5)	; AND CHECK AGAINST DEVICE SIZE
	BGEQU	25$			; BRANCH IF NOT LEGAL
	MOVL	R1,R0			; COPY STARTING LOGICAL BLOCK NUMBER
	JSB	G^IOC$CVTLOGPHY		; CONVERT LOGICAL TO PHYSICAL BLOCK
	BRW	EXE$INSIOQ		; INSERT I/O PACKET IN DEVICE QUEUE
					; AND RETURN
;
; TO HERE IF THE VIRTUAL BLOCKS MAP OFF THE END OF THE VOLUME. COMPLETE THE
; I/O WITH AN ERROR. WE QUEUE THE PACKET FOR PROCESSING, RATHER THAN WANDERING
; OFF INTO THE COMPLETION CODE BECAUSE THIS IS A GENERALLY CALLABLE ROUTINE.
;
25$:	MOVZWL	#SS$_ILLBLKNUM,IRP$L_IOST1(R3) ; SET ILLEGAL BLOCK NUMBER STATUS
	CLRL	IRP$L_IOST2(R3)		; ZERO 2ND I/O STATUS LONGWORD
	INSQUE	(R3),@IOC$GL_PSBL	; INSERT AT TAIL OF I/O POST QUEUE
	BNEQ	26$			; BRANCH IF NOT EMPTY
	SOFTINT	#IPL$_IOPOST		; WAKE UP I/O COMPLETION
26$:	RSB

30$:
	.DISABLE LSB
;
; ALTERNATE ENTRY TO IOC$WAKACP:
;
;	BSBW	IOC$QTOACP
;
; INPUTS:
;
;	R2 = DESIRED BYTE COUNT
;	R3 = IRP ADDRESS
;	PCB$W_DIOCNT(R4) ALREADY DECREMENTED
;
IOC$QTOACP:
	MOVL	R2,IRP$L_BCNT(R3)	; SET REMAINING BYTES TO TRANSFER
	MOVL	IRP$L_WIND(R3),R2	; GET WINDOW ADDRESS
	BBS	#WCB$V_NOTFCP,WCB$B_ACCESS(R2),- ; IF SET THEN
		NOTFCPWCB		; NOT FCP WINDOW
	MOVL	IRP$L_UCB(R3),R2	; GET ADDRESS OF DEVICE UCB
;
; FUNCTIONAL DESCRIPTION:
;
;	SUBROUTINE TO QUEUE AN I/O PACKET FOR AN ACP PROCESS AND WAKE
;	THE PROCESS IF ITS QUEUE WAS PREVIOUSLY EMPTY.
;
; CALLING SEQUENCE:
;
;	BSBW	IOC$WAKACP
;
; INPUTS:
;
;	R2 = DEVICE UCB ADDRESS
;	R3 = I/O REQUEST PACKET ADDRESS
;
; OUTPUTS:
;
;	R4 ALTERED
;
	.ENABL	LSB
IOC$WAKACP::				; QUEUE I/O PACKET AND WAKE ACP PROCESS
	DSBINT	#IPL$_SYNCH		; SYNCHRONIZE ACCESS TO SYSTEM DATA BASE
	MOVL	UCB$L_VCB(R2),R2	; GET ASSOCIATED VCB ADDRESS
	MOVL	VCB$L_AQB(R2),R2	; GET ACP QUEUE BLOCK ADDRESS
	TSTL	AQB$L_ACPPID(R2)	; PROCEDURE BASED? NO PID IF SO
	BEQL	XQP			; EQL THEN IS NOT AN ACP
	BSBW	EXE$INSERTIRP		; INSERT I/O PACKET IN ACP QUEUE
	BNEQ	10$			; IF NEQ NOT FIRST IN QUEUE
	MOVL	AQB$L_ACPPID(R2),R1	; GET ACP PROCESS ID
	BSBW	SCH$WAKE		; WAKE ACP PROCESS
	BLBS	R0,10$			; IF LBS ACP STILL PRESENT
	BUG_CHECK NONEXSTACP		; NONEXISTENT ACP PROCESS
10$:	ENBINT				; RESTORE SAVED IPL
	RSB				;
;
; THIS VOLUME IS BEING HANDLED BY AN XQP INSTEAD OF AN ACP.  CALL THE
; XQP QUEUEING ROUTINE AS A SPECIAL KERNEL AST TO GET IN THE CONTEXT
; OF THE PROCESS THAT INITIATED THIS REQUEST TO HANDLE IT.
;

XQP:
	PUSHL	R5			; PRESERVE R5.
	MOVAB	IRP$L_FQFL(R3), R5	; GET TEMP ACB ADDR INTO R5.
	MOVB	#ACB$M_KAST, ACB$B_RMOD(R5) ; NOTE AS SPECIAL KERNEL AST
	MOVL	IRP$L_PID(R3), ACB$L_PID(R5) ; COPY PID OF PROCESS.
	MOVAB	W^EXE$QXQPPKT, ACB$L_KAST(R5) ; ADDR OF QUEUEING ROUTINE.
	CLRL	R2			; NO PRIORITY INCREMENT.
	BSBW	SCH$QAST		; QUEUE THE AST.
	POPL	R5			; RESTORE R5.
	BRB	10$			; BRANCH TO EXIT.

	.DSABL	LSB
;
; WINDOW IS NOT AN FCP WINDOW, ONLY USED FOR BOOT TIME INTIALIZED WINDOWS
; FOR CONTIGUOUS FILES.  IT IS NOT POSSIBLE TO NEED TO TURN SUCH A WINDOW.
;
NOTFCPWCB:
	BUG_CHECK NOTFCPWCB,FATAL

	.SBTTL	BUFFERED READ COMPLETION AST ROUTINE
;++
; FUNCTIONAL DESCRIPTION:
;
;	BUFPOST PERFORMS ALL NECESSARY COMPLETION OPERATIONS REQUIRED
;	FOR A BUFFERED READ OPERATION IN THE CONTEXT OF THE PROCESS
;	ISSUING THE I/O REQUEST.
;
; CALLING SEQUENCE:
;
;	JSB	BUFPOST
;
; INPUT PARAMETERS:
;
;	R4 = CURRENT PROCESS PCB ADDRESS.
;	R5 = IRP/AST CONTROL BLOCK.
;
; IMPLICIT INPUTS:
;
;	SCH$GL_CURPCB - POINTER TO PCB OF CURRENT PROCESS
;--

BUFPOST:				; BUFFERED READ COMPLETION
	PUSHR	#^M<R5,R6,R7>		; SAVE REGISTERS
	MOVL	IRP$L_SVAPTE(R5),R6	; GET ADDRESS OF I/O BUFFER
	MOVL	IRP$L_BCNT(R5),R7	; GET COUNT OF BYTES OR DESCRIPTORS
	BBC	#IRP$V_COMPLX,IRP$W_STS(R5),40$ ;IF CLR, NOT COMPLEX BUFFER FORMAT
	BBS	#IRP$V_CHAINED,IRP$W_STS(R5),50$ ;IF SET ,CHAINED BUFFERS
	MOVL	(R6),R6			; GET ADDRESS OF FIRST BUFFER DESCRIPTOR
10$:	MOVZWL	2(R6),R0		; GET COUNT OF BYTES TO TRANSFER
	BEQL	30$			; IF EQL NONE THIS DESCRIPTOR
	MOVL	4(R6),R1		; GET ADDRESS OF USER BUFFER
	ADDL	R1,R0			; CALCULATE ENDING ADDRESS OF BUFFER
	BICW	#VA$M_BYTE,R1		; TRUNCATE ADDRESS TO PAGE BOUNDARY
	SUBL	R1,R0			; COMPUTE NUMBER OF BYTES TO PROBE
	MOVZWL	(R6),R4			; GET OFFSET TO DATA AREA
	CVTWL	#-^X200,R3		; SET ADDITION CONSTANT
20$:	IFNOWRT	R0,(R1),35$,(R6)[R4]	; CAN BUFFER BE WRITTEN?
	SUBL	R3,R1			; UPDATE ADDRESS OF BUFFER
	MOVAW	(R0)[R3],R0		; UPDATE REMAINING LENGTH
	BGTR	20$			; IF GEQ MORE TO CHECK
	MOVC	2(R6),1(R6)[R4],@4(R6)	; MOVE DATA TO USER BUFFER
	MOVL	(SP),R5			; RESTORE ADDRESS OF I/O PACKET
30$:	ADDL	#8,R6			; ADVANCE TO NEXT BUFFER DESCRIPTOR
	SOBGTR	R7,10$			; ANY MORE DESCRIPTORS TO PROCESS?
	BRW	130$			;
35$:	BRB	120$			; CONTINUE
40$:	BSBW	MOVBUF			; MOVE BUFFER TO USER
	MOVL	(SP),R5			; RETRIEVE ADDRESS OF I/O PACKET
	BBC	#IRP$V_MBXIO,IRP$W_STS(R5),130$; BR IF NOT MAILBOX READ
	MOVZBL	#RSN$_MAILBOX,R0	; SET UP RESOURCE RELEASE
	BSBW	SCH$RAVAIL		; DECLARE MAILBOX RESOURCE AVAILABLE
	BRB	130$			;

;
; NB: THE FOLLOWING SECTION OF CODE USES A WORD-SIZE BUFFER LENGTH
;     (ALTHOUGH IRP$L_BCNT WAS EXPANDED TO BE A LONGWORD).  
;
50$:	MOVL	R7,R0			; SET LENGTH OF USER BUFFER
	MOVL	4(R6),R1		; SET ADDRESS OF USER BUFFER
	ADDL	R1,R0			; CALCULATE END OF USER BUFFER
	BICW	#VA$M_BYTE,R1		; TRUNCATE TO PAGE BOUNDARY
	SUBL	R1,R0			; COMPUTE NUMBER OF BYTES TO PROBE
	EXTZV	#0,#2,IRP$B_RMOD(R5),R2 ; GET REQUEST ACCESS MODE
	CVTWL	#-^X200,R3		; SET ADDITION CONSTANT
60$:	IFNOWRT	R0,(R1),90$,R2		; CAN BUFFER BE WRITTEN?
	SUBL	R3,R1			; UPDATE ADDRESS OF BUFFER
	MOVAW	(R0)[R3],R0		; CALCULATE NEW LENGTH
	BGTR	60$			; IF GEQ MORE TO PROBE
	MOVL	4(R6),R3		; GET STARTING ADDRESS OF USER BUFFER
70$:	CMPW	R7,CXB$W_LENGTH(R6)	; REMAINING LENGTH LARGER THAN DATA AREA?
	BGEQU	80$			; IF GEQU YES
	MOVW	R7,CXB$W_LENGTH(R6)	; TRUNCATE LENGTH OF DATA AREA
80$:	MOVC	CXB$W_LENGTH(R6),@(R6)+,(R3) ; MOVE DATA TO USER BUFFER
	MOVL	(SP),R5			; RETRIEVE ADDRESS OF I/O PACKET
	SUBW	CXB$W_LENGTH-4(R6),R7	; REDUCE REMAINING BYTES TO TRANSFER
	BEQL	100$			; IF EQL DONE
	MOVL	CXB$L_LINK-4(R6),R6	; GET ADDRESS OF NEXT BUFFER IN CHAIN
	BNEQ	70$			; IF NEQ MORE TO GO
	BRB	100$			;
90$:	BSBW	ACCVIO			; SET ACCESS VIOLATION
100$:	MOVL	IRP$L_SVAPTE(R5),R0	; GET ADDRESS OF FIRST BUFFER
110$:	MOVL	CXB$L_LINK(R0),R6	; GET ADDRESS OF NEXT BUFFER
	BEQL	140$			; IF EQL NONE
	BSBW	EXE$DEANONPAGED		; DEALLOCATE BUFFER
	MOVL	R6,R0			; SET ADDRESS OF NEXT BUFFER
	BRB	110$			;
120$:	BSBW	ACCVIO			; SET ACCESS VIOLATION STATUS
130$:	MOVL	IRP$L_SVAPTE(R5),R0	; GET ADDRESS OF BUFFER TO RELEASE
140$:	BSBW	EXE$DEANONPAGED		; DEALLOCATE BUFFER
	POPR	#^M<R5,R6,R7>		; RESTORE REGISTERS

	.SBTTL	DIRECT I/O COMPLETION AST ROUTINE
;++
; FUNCTIONAL DESCRIPTION:
;
;	DIRPOST PERFORMS ALL GENERAL I/O COMPLETION ACTIVITIES WHICH
;	MUST BE DONE IN THE CONTEXT OF THE PROCESS. THESE INCLUDE
;	I/O STATUS POSTING IF AN IOSB WAS SPECIFIED, CHANNEL CONTROL
;	BLOCK ACTIVITY COUNT DECREMENTING, QUEUEING OF ANY REQUESTED
;	AST OR RELEASE OF THE I/O REQUEST PACKET.
;
; CALLING SEQUENCE:
;
;	JSB	DIRPOST
;
; INPUT PARAMETERS:
;
;	R4 = CURRENT PROCESS PCB ADDRESS.
;	R5 = IRP/AST CONTROL BLOCK ADDRESS.
;
; IMPLICIT INPUTS:
;
;	SCH$GL_CURPCB - POINTER TO CURRENT PCB
;--

DIRPOST:				; DIRECT I/O POSTING AST
	EXTZV	#IRP$V_BUFIO,#1,IRP$W_STS(R5),R0 ; GET INDEX TO ACCOUNTING ENTRY
	MOVL	@#CTL$GL_PHD,R1		; GET PROCESS HEADER ADDRESS
	INCL	PHD$L_DIOCNT(R1)[R0]	; ACCOUNT FOR BUFFERED OR DIRECT I/O

	.IF NE	CA$_MEASURE		; CHECK FOR MEASUREMENT ENABLED
	INCL	PMS$GL_DIRIO[R0]	; UPDATE MEASUREMENT I/O COUNTER
	.ENDC

	BBC	#IRP$V_DIAGBUF,IRP$W_STS(R5),10$ ; IF CLR, NO DIAGNOSTIC BUFFER
	PUSHR	#^M<R5,R6,R7>		; SAVE REGISTERS
	MOVL	IRP$L_DIAGBUF(R5),R6	; GET ADDRESS OF DIAGNOSTIC BUFFER
	MOVZWL	IRP$W_SIZE(R6),R7	; GET SIZE OF DIAGNOSTIC BUFFER
	SUBL	#12,R7			; REDUCE BY SIZE OF BUFFER HEADER
	BSBW	MOVBUF			; MOVE DIAGNOSTIC INFORMATION TO USER
	POPR	#^M<R5,R6,R7>		; RESTORE REGISTERS
	MOVL	IRP$L_DIAGBUF(R5),R0	; RETRIEVE ADDRESS OF DIAGNOSTIC BUFFER
	BSBW	EXE$DEANONPAGED		; DEALLOCATE DIAGNOSTIC BUFFER
10$:	CVTWL	IRP$W_CHAN(R5),R0	; GET CHANNEL NUMBER (NEGATED)
	MOVAB	@CTL$GL_CCBBASE[R0],R1	; SET CCB BASE ADDRESS
	DECW	CCB$W_IOC(R1)		; DECREMENT I/O COUNT FOR CHANNEL
	BNEQ	30$			; NOT IDLE YET
	MOVL	CCB$L_DIRP(R1),R3	; GET ADDRESS OF DEACCESS PACKET
	BEQL	30$			; IF EQL NONE
	CLRL	CCB$L_DIRP(R1)		; CLEAR ADDRESS OF DEACCESS PACKET
	INCW	CCB$W_IOC(R1)		; ACCOUNT FOR DEACCESS
	MOVL	IRP$L_UCB(R3),R2	; GET ASSIGNED DEVICE UCB ADDRESS
	BSBW	IOC$WAKACP		; QUEUE I/O PACKET AND WAKE ACP
					; R4 ALTERERED
30$:
;
; R4 DOES NOT NECESSARILY HAVE CURRENT PCB ADDRESS IN IT AT THIS POINT
;
IOC$DIRPOST1::
	MOVL	IRP$L_IOSB(R5),R0	; GET IOSB ADDRESS
	BEQL	35$			; IF EQL NONE SPECIFIED
	EXTZV	#0,#2,IRP$B_RMOD(R5),R1	; GET REQUEST ACCESS MODE
	IFNOWRT	#8,(R0),35$,R1		; CAN I/O STATUS BE WRITTEN?
	MOVQ	IRP$L_IOST1(R5),(R0)	; MOVE STATUS INTO IOSB
35$:	MOVL	IRP$L_PID(R5),R1	; PROCESS IDENTIFICATION
	BBS	#IRP$V_EXTEND,IRP$W_STS(R5),50$ ; BRANCH TO DEALLOCATE IRPE'S
37$:	BBC	#ACB$V_QUOTA,IRP$B_RMOD(R5),40$ ; IF CLR, NO AST SPECIFIED
	CLRL	R2			; SET NULL PRIORITY INCREMENT
	BRW	SCH$QAST		; QUEUE AST FOR REQUESTOR
40$:	BBC	#IO$V_ERASE,-		; BRANCH IF NOT AN ERASE REQUEST
		IRP$W_FUNC(R5),42$	;
	BSBB	CLEANUP_ERASE		; CLEAN UP AFTER AN ERASE REQUEST
42$:	MOVL	R5,R0			; SETUP ADDRESS FOR DEALLOCATE
	BRW	EXE$DEANONPAGED		; AND RELEASE I/O PACKET
	
	;
	; DEALLOCATE IRPE'S
	;

50$:	MOVL	IRP$L_EXTEND(R5),R0	; GET ADDRESS OF FIRST IRPE

60$:	CLRL	R4			; WILL HOLD ADDRESS OF NEXT IRPE
	BBC	#IRPE$V_EXTEND,IRPE$W_STS(R0),70$ ; BR. IF NO MORE IRPE'S
	MOVL	IRPE$L_EXTEND(R0),R4	; SAVE ADDRESS OF NEXT IRPE
70$:	BSBW	EXE$DEANONPAGED		; DEALLOCATE IRPE POINTED TO BY R0
	MOVL	R4,R0			; PUT ADDRESS OF NEXT IRPE IN R0
	BNEQ	60$			; BR. IF THERE IS ANOTHER IRPE
	BRB	37$			; DONE DEALLOCATING IRPE'S

	.SBTTL	ERASE I/O HELPER ROUTINES
	;++
	; CLEANUP_ERASE
	;
	; LOCAL SUBROUTINE TO FINISH PROCESSING AN ERASE REQUEST
	; THE CLEANUP WILL VARY WITH THE TYPE OF ERASE REQUEST.
	; SEE THE ROUTINE HEADER OF THE SUBROUTINE "SETUP_ERASE"
	; IN SYSACPFDT FOR DETAILS.
	;
	; INPUT:	R5 = IRP ADDRESS
	; OUTPUT:	NONE.
	;--

CLEANUP_ERASE:				; FINISH UP AFTER AN ERASE REQUEST
	BSBB	CHECK_ERASE		; IS THIS AN ERASE I/O?
	BLBC	R0,69$			; BRANCH IF NOT
	MOVL	IRP$L_SVAPTE(R5),R0	; GET ADDRESS OF PPT
	BEQL	69$			; BRANCH IF NONE
	CMPL	G^EXE$GL_ERASEPPT,R0	; IS THIS THE SYSTEM PPT?
	BEQL	69$			; BRANCH IF YES
	SUBL2	#12,R0			; CALC ADDRESS OF HEADER
	BSBW	EXE$DEANONPAGED		; RETURN THE POOL TO THE SYSTEM
69$:	RSB				; RETURN


;++
; CHECK_ERASE
;
; LOCAL SUBROUTINE TO DETERMINE IF THIS IRP IS FOR AN ERASE I/O REQUEST.
; THIS LEVEL OF PARANOIA IS NECESSARY TO PREVENT THE TOTAL CHAOS THAT
; WOULD ARISE SHOULD AN IRP THAT 'LOOKS' LIKE AN ERASE IRP BE TREATED
; INCORRECTLY.
;
; INPUT: 	R5 = IRP ADDRESS
; OUTPUT:	R0 = STATUS; LOW BIT SET IMPLIES THIS IS AN ERASE IRP
;--

CHECK_ERASE:				; CHECK FOR ERASE I/O REQUEST
	MOVL	IRP$L_UCB(R5),R0	; GET UCB ADDRESS.  NOTE: LOW BIT CLEAR
	BBC	#IO$V_ERASE,-		; BRANCH IF ERASE MODIFIER NOT SET
		IRP$W_FUNC(R5),13$	;
	CMPZV	#IRP$V_FCODE,-		; CHECK FUNCTION CODE
		#IRP$S_FCODE,-		;   ONLY DISKS AND TAPES SUPPORT DSE
		IRP$W_FUNC(R5),#IO$_DSE	;
	BEQL	11$			; BRANCH IF SO
	CMPB	#DC$_DISK,-		; IS THIS A DISK DEVICE?
		UCB$B_DEVCLASS(R0)	;
	BNEQ	13$			; NO - THEREFORE NOT AN ERASE
	CMPZV	#IRP$V_FCODE,-		; CHECK FUNCTION CODE
		#IRP$S_FCODE,-		;   ONLY DISKS SUPPORT THE MODIFIED-
		IRP$W_FUNC(R5),-	;   WRITE TYPE OF ERASE REQUEST
		#IO$_WRITEPBLK		;
	BEQL	11$	
	CMPZV	#IRP$V_FCODE,-
		#IRP$S_FCODE,-
		IRP$W_FUNC(R5),-
		#IO$_WRITELBLK	
	BEQL	11$	
	CMPZV	#IRP$V_FCODE,-
		#IRP$S_FCODE,-
		IRP$W_FUNC(R5),-
		#IO$_WRITEVBLK	
	BNEQ	13$			; NOT A WRITE - THEREFORE NOT AN ERASE
11$:	BISB2	#1,R0			; SET LOW BIT IN R0 TO INDICATE ERASE
13$:	RSB				; RETURN STATUS VALUE

	.SBTTL	MOVE DATA TO USER BUFFER
;
; SUBROUTINE TO MOVE DATA FROM A SIMPLE BUFFERED I/O BUFFER TO A USER BUFFER
;
 
MOVBUF:					; MOVE BUFFER
	MOVL	R7,R1			; SET LENGTH OF USER BUFFER
	BEQL	5$			; BR IF NULL STRING
	MOVL	4(R6),R0		; GET ADDRESS OF USER BUFFER
	EXTZV	#0,#2,IRP$B_RMOD(R5),R3 ; GET REQUEST ACCESS MODE
	JSB	EXE$PROBEW		; CHECK ACCESS
	BLBC	R0,ACCVIO		; IF LBC, NO ACCESS
	MOVC	R7,@(R6)+,@(R6)+	; MOVE DATA TO USER BUFFER
5$:	RSB				; RETURN
ACCVIO:	MOVW	#SS$_ACCVIO,IRP$L_IOST1(R5) ; SET FINAL TRANSFER STATUS
	RSB

	.SBTTL	UNLOCK AREAS IN IRPE'S
;++
; FUNCTIONAL DESCRIPTION:
;
;	THIS ROUTINE UNLOCKS THE AREAS DESCRIBED BY FIELDS IN THE IRPE'S.  EACH
;	IRPE HAS SPACE TO HOLD TWO AREA DESCRIPTIONS.
;
; CALLING SEQUENCE:
;
;	BSBW	UNLOCK_MORE
;
; INPUT PARAMETERS:
;
;	R5 = I/O REQUEST PACKET ADDRESS
;
; SIDE EFFECTS:
;
;	R0 - R3 ARE NOT PRESERVED
;--

	ASSUME	IRP$L_EXTEND EQ IRPE$L_EXTEND

UNLOCK_MORE:
	PUSHL	R5			; SAVE IRP ADDRESS

10$:	; UNLOCK AREAS SPECIFIED IN NEXT IRPE

	MOVL	IRPE$L_EXTEND(R5),R5	; GET ADDRESS OF NEXT IRPE
	MOVL	IRPE$L_SVAPTE1(R5),R3	; GET SVAPTE OF FIRST AREA
	BEQL	20$			; BR. IF NOTHING TO UNLOCK
	MOVZWL	IRPE$W_BOFF1(R5),R2	; GET BYTE OFFSET IN PAGE
	MOVL	IRPE$L_BCNT1(R5),R1	; GET SIZE OF AREA
	BSBB	UNLK			; UNLOCK FIRST AREA

20$:	MOVL	IRPE$L_SVAPTE2(R5),R3	; GET SVAPTE OF SECOND AREA
	BEQL	30$			; BR. IF NOTHING TO UNLOCK
	MOVZWL	IRPE$W_BOFF2(R5),R2	; GET BYTE OFFSET IN PAGE
	MOVL	IRPE$L_BCNT2(R5),R1	; GET SIZE OF AREA
	BSBB	UNLK			; UNLOCK SECOND AREA

30$:	BBS	#IRPE$V_EXTEND,IRPE$W_STS(R5),10$ ; BR. IF THERE'S ANOTHER IRPE
	POPL	R5			; RESTORE R5
	RSB

	;
	; LOCAL SUBROUTINE TO UNLOCK PAGES
	;
	;	R1 = BYTE COUNT (OR SIZE OF AREA)
	;	R2 = BYTE OFFSET IN PAGE
	;	R3 = SVAPTE OF START OF AREA
	;

UNLK:	MOVAB	511(R1)[R2],R1		; COMBINE OFFSET AND SIZE AND ROUND
	ASHL	#-VA$S_BYTE,R1,R1	; CONVERT TO NUMBER OF PAGES TO UNLOCK
	BSBW	MMG$UNLOCK		; UNLOCK PAGES
	RSB


	.END
