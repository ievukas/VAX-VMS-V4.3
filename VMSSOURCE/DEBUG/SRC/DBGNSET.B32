MODULE DBGNSET (IDENT = 'V04-000') =
BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
!
! FACILITY:	DEBUG
!
! ABSTRACT:
!
!	This module contains the ATN parse network and the command execution network
!	for the SET verb. These are currently the largest and most complicated
!	networks. Briefly, the parse network constructs a command execution tree
! 	which consists of at least a verb node, and possibly one or more noun nodes
!	The execution network accepts this tree as input and decodes the arguments
!	of the various nodes to perform the specified command.
!
! ENVIRONMENT:	VAX/VMS
!
! AUTHOR:	David Plummer	, CREATION DATE:	3/28/80
!
! VERSION:	V02.2-001
!
! MODIFIED BY:
!
!		Richard Title	31-Jul-81
!		Sid Maxwell	07-May-82
!		Brad Becker	13-Sep-83
!
! REVISION HISTORY:
! 3.0	31-JUL-81	RT	Added new nouns FLOAT, D_FLOAT, etc.
!				in the SET TYPE command.
! 3.1	13-SEP-81	RT	Implemented new SET commands: 
!				SET STEP SOURCE
!				SET SOURCE dir-list 
!				SET MAX_SOURCE_FILES n
!				as part of source line display
! 3.2 	 9-Oct-81	RT	Implemented SET MARGINS
! 3.3	13-Oct-81	RT	Implemented SET SEARCH
! 3B.0  18-Feb-82       PS      Implemented SET DEVELOPER
! ???   06-May-82	RT	Implemented SET DEFINE
!	07-May-82	SRM	Added hooks for new:
!				    SET BREAK
!				    SET TRACE
!				    SET WATCH
! 	09-Aug-82	RT	Added implementation level 3 code for
!				SET BREAK, SET TRACE, SET WATCH
!	15-Apr-83	RT	Added SET SCOPE/MODULE
!	22-Apr-83	RT	Added SET MODULE/ALLOCATE
!	15-Jul-83	WC3	Added SET TYPE PACKED:n and SET TYPE/OVERRIDE PACKED:n
!	18-Jul-83	WC3	Added SET TYPE DATE_TIME and SET TYPE/OVERRIDE DATE_TIME
!	17-Aug-83       PS      Added SET MODE G/NOG_FLOAT.
! 4.0	13-Sep-83	BAB	Added SET KEY.
!

REQUIRE 'SRC$:DBGPROLOG.REQ';

LIBRARY 'LIB$:DBGGEN.L32';

FORWARD ROUTINE
    DBG$NPARSE_SET,			! SET verb parse network
    DBG$NEXECUTE_SET,			! SET verb execution network
    DBG$NSET_LOG,			! Sets up an output log
    DBG$NSETUP_LOG,			! Opens and connects an output log
    DUMMY: NOVALUE;			! Dummy routine to foil BLISS
    					!      compiler optimization

EXTERNAL ROUTINE
    DBG$EVENT_SYNTAX,			! Event syntax (parser)
    DBG$EVENT_SEMANTICS,		! Event semantics
    DBG$NGET_LENGTH,			! Returns bit length for a primary
    DBG$NGET_DIR_LIST,			! Parses a directory list for the
					!      SET SOURCE dir-list command
    DBG$NGET_TRANS_RADIX,		! Translate radix
    DBG$SCR_EXECUTE_DISPLAY_CMD:NOVALUE,! Execute the SET DISPLAY command
    DBG$SCR_EXECUTE_SETTERM_CMD:NOVALUE,! Execute the SET TERMINAL command
    DBG$SCR_EXECUTE_SETWIND_CMD:NOVALUE,! Execute the SET WINDOW command
    DBG$SCR_PARSE_DISPLAY_CMD: NOVALUE,	! Parse the SET DISPLAY command
    DBG$SCR_PARSE_SETTERM_CMD: NOVALUE,	! Parse the SET TERMINAL command
    DBG$SCR_PARSE_SETWIND_CMD: NOVALUE,	! Parse the SET WINDOW command
    DBG$SCR_SCREEN_MODE: NOVALUE,	! Set or clear screen mode
    DBG$STA_GETSOURCEMOD,		! Finds a Module RST pointer
    DBG$SRC_SET_SOURCE: NOVALUE,	! Implements the SET SOURCE command
    DBG$NSAVE_DECIMAL_INTEGER,		! Saves an inline numeric literal
    DBG$NSAVE_INTEGER,			! Saves a numeric literal in the current radix
    DBG$NSAVE_STRING,			! Saves a counted string from input
    DBG$NGET_TYPE,			! Obtains type of primary
    DBG$PRINT: NOVALUE,			! Format print output
    DBG$NEWLINE: NOVALUE,		! Output a line of print output
    DBG$SET_SEARCH_LVL: NOVALUE,	! Sets search data structure pointer
    DBG$SET_STP_LVL: NOVALUE,		! Sets step data structure pointer
    DBG$SET_DEFINE_LVL: NOVALUE,	! Sets define data structure pointer
    DBG$SET_MOD_LVL,			! Sets mode structure level
    DBG$NPARSE_SET_TASK: NOVALUE,	! Parses SET TASK command
    DBG$NEXECUTE_SET_TASK: NOVALUE,	! Handles SET TASK command
    DBG$RST_SETSCOPE: NOVALUE,		! Sets user specified scopes
    DBG$NPARSE_SCOPE_LIST,		! Parses a scope list
    DBG$NSHOW_MARGINS: NOVALUE,		! Shows the margins
    DBG$SRC_SET_MAX_FILES: NOVALUE,	! Performs SET MAX command
    DBG$NPATHDESC_TO_CS: NOVALUE,	! Translates a pathname desc to a c.s.
    DBG$RST_SETMOD,			! Sets a module
    DBG$GET_MEMORY,			! Allocates a permanent memory block
    DBG$REL_MEMORY: NOVALUE,		! Releases a memory block
    DBG$GET_TEMPMEM,			! Allocates and lists dynamic storage
    DBG$NSAVE_FILESP,			! Eats and stores a filespec string
    DBG$NMATCH,				! Routine to match keywords
    DBG$NPARSE_ADDRESS,			! Interface routine to Address Expression Interpreter
    DBG$NNEXT_WORD,			! Isolates next word of input for syntax errors
    DBG$NOUT_INFO,			! Outputs an informational message
    DBG$NMAKE_ARG_VECT,			! Constructs a message argument vector
    DBG$NSYNTAX_ERROR,			! Constructs a syntax error message
    DBG$SET_LANG,			! Version 2 routine to change language
    DBG$READ_KEY_INFO,			! Reads in the state-name string for SET KEY
    SMG$SET_DEFAULT_STATE,		! Sets the default keypad state
    SMG$SET_KEYPAD_MODE;		! Sets terminal to numeric/applicat. mode

EXTERNAL
    DBG$GB_KEYPAD_INPUT: BYTE,		! TRUE if keypad input is enabled
    DBG$GL_KEY_TABLE_ID,		! Used in SET KEY
    DBG$GL_KEYBOARD_ID,			! Used in SET MODE KEY
    DBG$GB_RADIX: VECTOR[3, BYTE],	! Override and default radix
    DBG$GL_GBLTYP,			! Override type
    DBG$GW_GBLLNGTH: WORD,		! Override length
    DBG$GL_DFLTTYP,			! Default type
    DBG$GW_DFLTLENG: WORD,		! Default length
    DBG$GB_LANGUAGE: BYTE,		! Current language
    DBG$GB_SEARCH_PTR: REF VECTOR[,BYTE],! Search structure
    DBG$GB_MOD_PTR: REF VECTOR [,BYTE],	! Mode structure
    DBG$GB_DEFINE_PTR: REF VECTOR [,BYTE],! Define structure
    DBG$RUNFRAME: BLOCK [,BYTE],	! Current runframe
    DBG$GB_RESIGNAL: BYTE,		! If TRUE, then resignal exeptions
    DBG$GL_LOG_BUF,			! Old debugger pointer to counted string filespec
    DBG$GL_CONTEXT: BITVECTOR,		! Old debugger context switches 
    DBG$GB_DEF_OUT: VECTOR [,BYTE],	! Old debugger output control vector
    DBG$GL_LOGFAB: BLOCK [,BYTE],	! FAB for log file
    DBG$GL_LOGRAB: BLOCK [,BYTE],	! RAB for log file
    DBG$GL_LOGNAM: REF $NAM_DECL,	! NAM block for file spec
    DBG$GB_LOGFSR: REF VECTOR [,BYTE],	! Resultant LOG filespec buffer
    DBG$GB_LOGFSE: REF VECTOR [,BYTE],	! Expanded LOG filespec buffer
    DBG$GL_SCREEN_LOG,			! Flag set to activate screen logging
    DBG$GB_STP_PTR:			! Pointer to current stepping descriptor
	REF EVENT$STEPPING_DESCRIPTOR,	!
    DBG$SRC_LEFT_MARGIN,		! Left margin for source display
    DBG$SRC_RIGHT_MARGIN,		! Right margin for source display
    DBG$GL_ORIG_COMMAND_PTR,		! Pointer to original command string
    DBG$GL_UPCASE_COMMAND_PTR: VECTOR[2];
    					! Pointers to start and end
    					!    of current command string




! These are composite verb literals used in parsing and execution.
!
! Note - you may cause yourself problems if you try to renumber these,
! because the EVENT$K_SET_XXX definitions in DBGLIB.REQ must correspond
! to the numbers here.
!
LITERAL
    SET_MINIMUM		= 1,
    SET_BREAK		= 1,		! Also defined as EVENT$K_SET_BREAK
    SET_BREAK_DO	= 2,
    SET_EXCEPTION_BREAK	= 3,		! Also defined as EVENT$K_SET_BREAK_EXC
    SET_LANGUAGE	= 4,
    SET_LOG		= 5,
    SET_MODE		= 6,
    SET_MODULE		= 7,
    SET_MODULE_ALL	= 8,
    SET_OUTPUT		= 9,
    SET_RADIX		= 27,
    SET_RADIX_OVERRIDE  = 28,
    SET_SCOPE		= 10,
    SET_STEP		= 11,
    SET_TYPE		= 12,
    SET_TYPE_OVERRIDE	= 13,
    SET_TRACE		= 14,		! Also defined as EVENT$K_SET_TRACE
    SET_TRACE_CALLS	= 15,
    SET_TRACE_BRANCH	= 16,
    SET_WATCH		= 17,		! Also defined as EVENT$K_SET_WATCH
    SET_SOURCE		= 18,
    SET_MAX_SOURCE_FILES= 19,
    SET_MARGINS		= 20,
    SET_SEARCH		= 21,
    SET_DEVELOPER	= 22,
    SET_DEFINE		= 23,
    SET_DISPLAY		= 24,
    SET_TERMINAL	= 25,
    SET_WINDOW		= 26,
    SET_KEY             = 29,
    SET_TASK		= 30,
    SET_MAXIMUM		= 30;

! These are the legal mode literals for the SET MODE command.
!
LITERAL
    MODE_LOWEST		= 1,
    MODE_BINARY		= 1,
    MODE_OCTAL		= 2,
    MODE_DECIMAL	= 3,
    MODE_HEX		= 4,
    MODE_SYMBLS		= 5,
    MODE_NOSYMBLS	= 6,
    MODE_DEFAULT	= 7,
    MODE_SCREEN		= 8,
    MODE_NOSCREEN	= 9,
    MODE_KEYPAD		= 10,
    MODE_NOKEYPAD	= 11,
    MODE_G_FLOAT	= 12,
    MODE_NOG_FLOAT	= 13,
    MODE_HIGHEST	= 13;

GLOBAL
    DBG$GL_DEVELOPER:			! Special mode bits for developers
	BITVECTOR[32] INITIAL(0);	!

MACRO

	! OUTPUT_RMS_ERROR reports RMS errors caused by $CREATE, $OPEN, and $CONNECT
	!
	OUTPUT_RMS_ERROR (BLOCK_TYPE) =
	    BEGIN
		LOCAL
		    MSG_DESC : REF dbg$stg_desc,
		    STS,
		    STV;

    		msg_desc = dbg$get_tempmem (2);

		build_error_desc (msg_desc);
		IF block_type EQL 1
		THEN
		    BEGIN
			sts = .dbg$gl_logfab [fab$l_sts];
			stv = .dbg$gl_logfab [fab$l_stv];
		    END
		ELSE
		    BEGIN
			sts = .dbg$gl_lograb [rab$l_sts];
			stv = .dbg$gl_lograb [rab$l_stv];
		    END;

	    	.message_vect = dbg$nmake_arg_vect (shr$_openout+dbg_fac_code,
						    1, .msg_desc, .sts, .stv);

		RETURN sts$k_severe;

	    END %,

	! Build_error_desc creates a descriptor for RMS error reporting

	BUILD_ERROR_DESC (MSG_DESC) =
	    IF .dbg$gl_log_buf NEQ 0
	    THEN
		BEGIN
		    msg_desc [dsc$w_length] = .dbg$gl_logfab [fab$b_fns];
		    msg_desc [dsc$a_pointer] = .dbg$gl_logfab [fab$l_fna];
		END
	    ELSE
		BEGIN
		    msg_desc [dsc$w_length] = .dbg$gl_logfab [fab$b_dns];
		    msg_desc [dsc$a_pointer] = .dbg$gl_logfab [fab$l_dna];
		END %,

	! Restore_nam restores an  RMS NAM block

	RESTORE_NAM =

	    BEGIN

	    LOCAL
		ERR,
		TYPE_B;

	    ! Release storage for the aborted log file

    	    dbg$rel_memory (.temp_nam);
    	    dbg$rel_memory (.temp_fsr);
    	    dbg$rel_memory (.temp_fse);

	    dbg$gl_lognam = .old_nam_ptr;
	    old_nam_ptr = 0;
	    dbg$gl_logfab [fab$l_nam] = .dbg$gl_lognam;
	    dbg$gl_logfab [fab$l_fna] = .fna;
	    dbg$gl_logfab [fab$b_fns] = .fns;

	    dbg$gl_logfab [fab$v_nam] = 1;
	    dbg$gl_logfab [fab$v_cif] = 1;
	    dbg$gl_logfab [fab$v_mxv] = 0;

	    err = dbg$nsetup_log (type_b);

	    IF NOT .err
	    THEN output_rms_error (.type_b);

	    dbg$gb_def_out [out_log] = .log_temp;

	    END %;

GLOBAL ROUTINE DBG$NPARSE_SET (INPUT_DESC, VERB_NODE, MESSAGE_VECT) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine comprises the ATN parse network for the SET verb. The network
!	recognizes various keywords and contructs appropriate noun nodes which it
! 	links to the verb node. Many composite verbs are recognized in this network
!	as well. The value of these composite verbs are placed in the verb node (verb composite)
!	field.
!
! FORMAL PARAMETERS:
!
!	INPUT_DESC -		The present command line input descriptor
!
!	VERB_NODE _		The first node in the command execution tree.
!				Value field has already been filled in by
!				DBG$NPARSE_CMD.
!
!	MESSAGE_VECT -		The address of a longword to contain the address
!				of a message argument vector
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	The command execution tree corresponding to the input command is constructed.
!
! ROUTINE VALUE:	
!
!	An unsigned integer longword completion code
!
! COMPLETION CODES:
!
!	STS$K_SEVERE (4)	- Unsuccessful parse
!
!	STS$K_SUCCESS (1)	- Successful parse
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    ! Define strings used at this level.
    !
    BIND
	DBG$CS_BREAK 		= UPLIT BYTE (%ASCIC 'BREAK'),
    	DBG$CS_DEFINE		= UPLIT BYTE (%ASCIC 'DEFINE'),
    	DBG$CS_DEVELOPER        = UPLIT BYTE (%ASCIC 'DEVELOPER'),
	DBG$CS_DISPLAY		= UPLIT BYTE (%ASCIC 'DISPLAY'),
	DBG$CS_EXCEPTION 	= UPLIT BYTE (%ASCIC 'EXCEPTION'),
	DBG$CS_LANGUAGE 	= UPLIT BYTE (%ASCIC 'LANGUAGE'),
	DBG$CS_LOG 		= UPLIT BYTE (%ASCIC 'LOG'),
	DBG$CS_KEY		= UPLIT BYTE (%ASCIC 'KEY'),
    	DBG$CS_MARGINS		= UPLIT BYTE (%ASCIC 'MARGINS'),
    	DBG$CS_MAX_SOURCE_FILES = UPLIT BYTE (%ASCIC 'MAX_SOURCE_FILES'),
	DBG$CS_MODE		= UPLIT BYTE (%ASCIC 'MODE'),
	DBG$CS_MODULE 		= UPLIT BYTE (%ASCIC 'MODULE'),
	DBG$CS_OUTPUT 		= UPLIT BYTE (%ASCIC 'OUTPUT'),
    	DBG$CS_RADIX		= UPLIT BYTE (%ASCIC 'RADIX'),
	DBG$CS_SCOPE		= UPLIT BYTE (%ASCIC 'SCOPE'),
    	DBG$CS_SEARCH		= UPLIT BYTE (%ASCIC 'SEARCH'),
        DBG$CS_SOURCE		= UPLIT BYTE (%ASCIC 'SOURCE'),
	DBG$CS_STEP 		= UPLIT BYTE (%ASCIC 'STEP'),
    	DBG$CS_TASK		= UPLIT BYTE (%ASCIC 'TASK'),
	DBG$CS_TERMINAL		= UPLIT BYTE (%ASCIC 'TERMINAL'),
	DBG$CS_TRACE 		= UPLIT BYTE (%ASCIC 'TRACE'),
	DBG$CS_TYPE		= UPLIT BYTE (%ASCIC 'TYPE'),
	DBG$CS_WATCH 		= UPLIT BYTE (%ASCIC 'WATCH'),
	DBG$CS_WINDOW		= UPLIT BYTE (%ASCIC 'WINDOW'),
    	DBG$CS_COLON		= UPLIT BYTE (%ASCIC ':'),
	DBG$CS_COMMA 		= UPLIT BYTE (%ASCIC ','),
    	DBG$CS_EQUAL		= UPLIT BYTE (%ASCIC '='),
	DBG$CS_SLASH 		= UPLIT BYTE (%ASCIC '/'),
	DBG$CS_CR 		= UPLIT BYTE (1, DBG$K_CAR_RETURN);

    MAP 
	VERB_NODE: REF DBG$VERB_NODE;	! Pointer to command Verb Node

    LOCAL
	NOUN_NODE: REF DBG$NOUN_NODE;	! Pointer to current Noun Node



    ! Construct the noun node.
    !
    NOUN_NODE = DBG$GET_TEMPMEM (DBG$K_NOUN_NODE_SIZE);


    ! Link the noun node to the verb node.
    !
    VERB_NODE [DBG$L_VERB_OBJECT_PTR] = .NOUN_NODE;


    ! Recognize keyword and transfer control to subnetwork if appropriate.
    !
    SELECTONE TRUE OF
	SET


	! Parse the SET BREAK command.
	!
	[DBG$NMATCH (.INPUT_DESC, DBG$CS_BREAK, 1)]:
	    BEGIN
	    VERB_NODE [DBG$B_VERB_COMPOSITE] = EVENT$K_SET_BREAK;
	    RETURN DBG$EVENT_SYNTAX (.INPUT_DESC,
	    			     .VERB_NODE,
				     .MESSAGE_VECT
				    );
	    END;


    	[dbg$nmatch (.input_desc, dbg$cs_define, 1)] : 		! Set Define
    	    BEGIN
    	
    	    ! Define the keywords that are legal after SET DEFINE
    	    !
    	    BIND
    		dbg$cs_address	= UPLIT BYTE (7, 'ADDRESS'),
    	 	dbg$cs_command	= UPLIT BYTE (7, 'COMMAND'),
    		dbg$cs_procedure= UPLIT BYTE (9, 'PROCEDURE'),
    	 	dbg$cs_string	= UPLIT BYTE (6, 'STRING'),
    		dbg$cs_value	= UPLIT BYTE (5, 'VALUE');

    	    verb_node [dbg$b_verb_composite] = set_define;
    	
    	    ! Pick up one keyword. 
    	    ! *** Two of the five are commented out because they are
    	    ! *** not yet supported.
    	    !
    	    SELECTONE TRUE OF 
    		SET 

    		[dbg$nmatch (.input_desc, dbg$cs_address, 1)]:
    		    noun_node [dbg$l_noun_value] = define_address;

    		[dbg$nmatch (.input_desc, dbg$cs_command, 1)]:
    		    noun_node [dbg$l_noun_value] = define_command;

    		! [dbg$nmatch (.input_desc, dbg$cs_procedure, 1)]:
    		!    noun_node [dbg$l_noun_value] = define_procedure;

    		! [dbg$nmatch (.input_desc, dbg$cs_string, 1)]:
    		!    noun_node [dbg$l_noun_value] = define_string;

    		[dbg$nmatch (.input_desc, dbg$cs_value, 1)]:
    		    noun_node [dbg$l_noun_value] = define_value;

    		[OTHERWISE]:
    		    BEGIN
    		    IF dbg$nmatch (.input_desc, dbg$cs_cr, 1)
    		    THEN
    			.message_vect = dbg$nmake_arg_vect (dbg$_needmore)
    		    ELSE
    			.message_vect = 
    			  dbg$nsyntax_error (
    			    dbg$nnext_word (.input_desc));
    		    RETURN sts$k_severe;
    		    END;

    		TES;
    	    END;

    	[dbg$nmatch (.input_desc, dbg$cs_developer, 9)] :	! Set Developer
    	    BEGIN
    	    LOCAL
    		link;

    	    verb_node [dbg$b_verb_composite] = set_developer;
    	    link = verb_node[dbg$l_verb_object_ptr];
 	    IF NOT dbg$nmatch(.input_desc, dbg$cs_cr, 1)
    	    THEN
    		BEGIN
    	        WHILE true DO
    		    BEGIN
    		    IF NOT dbg$nsave_integer(.input_desc, noun_node[dbg$l_noun_value])
    		    THEN
    		        RETURN sts$k_severe;

    		    IF (.noun_node[dbg$l_noun_value] LSS 0) OR
    		       (.noun_node[dbg$l_noun_value] GTR 31)
    		    THEN
    		        BEGIN
    		        .message_vect = dbg$nmake_arg_vect(dbg$_bitrange);
    		        RETURN sts$k_severe;
    		        END;

    		    link = noun_node[dbg$l_noun_link];
    		    IF NOT dbg$nmatch(.input_desc, dbg$cs_comma, 1)
    		    THEN
    		        BEGIN
    		        IF NOT dbg$nmatch(.input_desc, dbg$cs_cr, 1)
    		        THEN
    			    BEGIN
    			    .message_vect = dbg$nsyntax_error(dbg$nnext_word(.input_desc));
    			    RETURN sts$k_severe;
    			    END

    		        ELSE
    			    EXITLOOP;

    		        END;

    		    noun_node = dbg$get_tempmem (dbg$k_noun_node_size);
    		    .link = .noun_node;
    		    END;			! End of WHILE loop.

    		END				! End of SET DEVELOPER 0,1...

    	    ELSE
    		BEGIN
    		.message_vect = dbg$nmake_arg_vect(dbg$_needmore);
    		RETURN sts$k_severe;
    		END;

    	    .link = 0;

    	    END;


	! Parse the SET DISPLAY command.
	!
	[DBG$NMATCH(.INPUT_DESC, DBG$CS_DISPLAY, 3)]:
	    BEGIN
	    VERB_NODE[DBG$B_VERB_COMPOSITE] = SET_DISPLAY;
	    DBG$SCR_PARSE_DISPLAY_CMD(.INPUT_DESC, TRUE, .VERB_NODE);
	    END;


	! Parse the SET EXCEPTION BREAK command.
	!
	[DBG$NMATCH (.INPUT_DESC, DBG$CS_EXCEPTION, 1)]:
	    BEGIN

	    ! We are looking for SET EXCEPTION BREAK

	    IF NOT dbg$nmatch (.input_desc, dbg$cs_break, 1)
	    THEN
	    	BEGIN
		.message_vect =
		( IF dbg$nmatch (.input_desc, dbg$cs_cr, 1)
		  THEN
		      dbg$nmake_arg_vect (dbg$_needmore)
		  ELSE
		      dbg$nsyntax_error (dbg$nnext_word (.input_desc)));
		RETURN sts$k_severe;
		END;

	    ! Set the verb composite

	    verb_node [dbg$b_verb_composite] = set_exception_break;


	    ! Reset the noun and adverb pointers.
	    !
	    verb_node [dbg$l_verb_object_ptr] = 0;
	    verb_node [dbg$l_verb_adverb_ptr] = 0;
	    END;

        ! Parse SET KEY
        !

        [dbg$nmatch (.input_desc, dbg$cs_key, 1)]:
            BEGIN

            MAP
                input_desc		: REF BLOCK [,BYTE];

            BIND
                dbg$cs_state		= UPLIT BYTE (5, 'STATE'),
                dbg$cs_nostate		= UPLIT BYTE (7, 'NOSTATE'),
                dbg$cs_nolog		= UPLIT BYTE (5, 'NOLOG');

            LOCAL
                temp_key_desc		: REF dbg$stg_desc,
                status;


            IF NOT .dbg$gb_keypad_input
            THEN
                SIGNAL(dbg$_nokeydef);

	    verb_node [dbg$b_verb_composite] = set_key;

            ! Initialize the noun node to point to a descriptor of the 
            ! current state.
            !
            temp_key_desc = dbg$get_tempmem(2);
            temp_key_desc [dsc$w_length] = 0;
            temp_key_desc [dsc$b_dtype]  = dsc$k_dtype_t;
            temp_key_desc [dsc$b_class]  = dsc$k_class_d;
            temp_key_desc [dsc$a_pointer]= 0;

            smg$set_default_state (dbg$gl_key_table_id, 0, .temp_key_desc);

            ! Let this field indicate whether to output a log of the SET KEY command
            !
            verb_node [dbg$l_verb_adverb_ptr] = 1;

            noun_node [dbg$l_noun_value] = .temp_key_desc;

            WHILE (NOT dbg$nmatch (.input_desc, dbg$cs_cr, 1)) AND
                  (.input_desc [dsc$w_length] GTR 0) DO

                IF dbg$nmatch (.input_desc, dbg$cs_slash,1)
                THEN
                    SELECTONE TRUE OF
                        SET

                        [dbg$nmatch(.input_desc, dbg$cs_nolog, 3)] :
                            BEGIN
                            verb_node [dbg$l_verb_adverb_ptr] = 0;
                            END;

                        [dbg$nmatch(.input_desc, dbg$cs_nostate, 3)] :
                            BEGIN
                            ! In this case the noun node field that points to
                            ! the state name is reset anyway, as above.
                            !
                            smg$set_default_state(dbg$gl_key_table_id, 0, .temp_key_desc);
                            noun_node [dbg$l_noun_value] = .temp_key_desc;
                            END;

                        [dbg$nmatch(.input_desc, dbg$cs_log, 1)] :
                            BEGIN
                            verb_node [dbg$l_verb_adverb_ptr] = 1;
                            END;

                        [dbg$nmatch(.input_desc, dbg$cs_state, 1)] :
                            BEGIN
                            ! Check for =
                            !
                            IF NOT dbg$nmatch(.input_desc, dbg$cs_equal, 1)
                            THEN
                                BEGIN
                                IF dbg$nmatch(.input_desc, dbg$cs_cr, 1)
                                THEN
                                    .message_vect = dbg$nmake_arg_vect (dbg$_needmore)
                                ELSE
                                    .message_vect = dbg$nsyntax_error (dbg$nnext_word(.input_desc));
                                RETURN sts$k_severe;
                                END;

                            temp_key_desc [dsc$a_pointer] = 0;
                            temp_key_desc [dsc$w_length]  = 0;
                            status = dbg$read_key_info (.input_desc,
                                                        .temp_key_desc,
                                                        .message_vect);
                            IF NOT .status
                            THEN
                                RETURN .status;
                            END;

                        [OTHERWISE] :
                            BEGIN
                            IF dbg$nmatch(.input_desc, dbg$cs_cr, 1)
                            THEN
                                .message_vect = dbg$nmake_arg_vect (dbg$_needmore)
                            ELSE
                                .message_vect = dbg$nsyntax_error (dbg$nnext_word(.input_desc));
                            RETURN sts$k_severe;
                            END;
                        TES
                ELSE
                    BEGIN
                    .message_vect = dbg$nsyntax_error (dbg$nnext_word(.input_desc));
                    RETURN sts$k_severe;
                    END;
            END;		! End of SET KEY parse


	[dbg$nmatch (.input_desc, dbg$cs_language, 2)]:
	    BEGIN

	    BIND
		DBG$CS_MACRO	= UPLIT BYTE(%ASCIC 'MACRO'),
		DBG$CS_FORTRAN	= UPLIT BYTE(%ASCIC 'FORTRAN'),
 		DBG$CS_BLISS	= UPLIT BYTE(%ASCIC 'BLISS'),
		DBG$CS_COBOL	= UPLIT BYTE(%ASCIC 'COBOL'),
		DBG$CS_BASIC	= UPLIT BYTE(%ASCIC 'BASIC'),
		DBG$CS_PLI	= UPLIT BYTE(%ASCIC 'PLI'),
		DBG$CS_PASCAL	= UPLIT BYTE(%ASCIC 'PASCAL'),
		DBG$CS_C	= UPLIT BYTE(%ASCIC 'C'),
		DBG$CS_RPG	= UPLIT BYTE(%ASCIC 'RPG'),
		DBG$CS_ADA	= UPLIT BYTE(%ASCIC 'ADA'),
		DBG$CS_UNKNOWN	= UPLIT BYTE(%ASCIC 'UNKNOWN');


	    VERB_NODE [DBG$B_VERB_COMPOSITE] = SET_LANGUAGE;

	    SELECTONE TRUE OF
		SET

		[DBG$NMATCH (.INPUT_DESC, DBG$CS_MACRO, 2)] :
		    NOUN_NODE [DBG$L_NOUN_VALUE] = DBG$K_MACRO;

		[DBG$NMATCH (.INPUT_DESC, DBG$CS_FORTRAN, 2)] :
		    NOUN_NODE [DBG$L_NOUN_VALUE] = DBG$K_FORTRAN;

		[DBG$NMATCH (.INPUT_DESC, DBG$CS_BLISS, 2)] :
		    NOUN_NODE [DBG$L_NOUN_VALUE] = DBG$K_BLISS;

		[DBG$NMATCH (.INPUT_DESC, DBG$CS_COBOL, 2)] :
		    NOUN_NODE [DBG$L_NOUN_VALUE] = DBG$K_COBOL;

		[DBG$NMATCH (.INPUT_DESC, DBG$CS_BASIC, 2)] :
		    NOUN_NODE [DBG$L_NOUN_VALUE] = DBG$K_BASIC;
			
		[DBG$NMATCH (.INPUT_DESC, DBG$CS_PLI, 2)] :
		    NOUN_NODE [DBG$L_NOUN_VALUE] = DBG$K_PLI;

		[DBG$NMATCH (.INPUT_DESC, DBG$CS_PASCAL, 2)] :
		    NOUN_NODE [DBG$L_NOUN_VALUE] = DBG$K_PASCAL;

		[DBG$NMATCH(.INPUT_DESC, DBG$CS_C, 1)]:
	 	    NOUN_NODE[DBG$L_NOUN_VALUE] = DBG$K_C;

		[DBG$NMATCH(.INPUT_DESC, DBG$CS_RPG, 2)]:
		    NOUN_NODE[DBG$L_NOUN_VALUE] = DBG$K_RPG;

		[IF NOT .DBG$GL_DEVELOPER[0] THEN FALSE ELSE
		 DBG$NMATCH(.INPUT_DESC, DBG$CS_ADA, 2)]:
		    NOUN_NODE[DBG$L_NOUN_VALUE] = DBG$K_ADA;

		[DBG$NMATCH(.INPUT_DESC, DBG$CS_UNKNOWN, 3)]:
		    NOUN_NODE[DBG$L_NOUN_VALUE] = DBG$K_UNKNOWN;

		[OTHERWISE] :
		    BEGIN
		    IF DBG$NMATCH (.INPUT_DESC, DBG$CS_CR, 1)
		    THEN
		    	.MESSAGE_VECT = DBG$NMAKE_ARG_VECT (DBG$_NEEDMORE)

		    ELSE
			.MESSAGE_VECT =
				DBG$NSYNTAX_ERROR(DBG$NNEXT_WORD(.INPUT_DESC));

		    RETURN STS$K_SEVERE;
		    END;

		TES;

	    END;

	[DBG$NMATCH (.INPUT_DESC, DBG$CS_LOG, 2)] :
	    BEGIN
	    VERB_NODE [DBG$B_VERB_COMPOSITE] = SET_LOG;
	    IF NOT DBG$NSAVE_FILESP (.INPUT_DESC,
				     NOUN_NODE [DBG$L_NOUN_VALUE], 
				     .MESSAGE_VECT)
	    THEN
	 	RETURN STS$K_SEVERE;
	    END;

    	[DBG$NMATCH (.INPUT_DESC, DBG$CS_MARGINS, 3)] :
    	    BEGIN
    	    LOCAL
    		LEFT_MARGIN,
    		RIGHT_MARGIN;

    	    VERB_NODE[DBG$B_VERB_COMPOSITE] = SET_MARGINS;


    	    ! Legal forms of the SET MARGINS command are:
    	    ! 1. SET MARGINS l:r
    	    ! 2. SET MARGINS r
    	    ! 3. SET MARGINS l:
    	    ! 4. SET MARGINS :r
    	    !
    	    IF DBG$NMATCH (.INPUT_DESC, DBG$CS_COLON, 1)
    	    THEN
		BEGIN


    		! This must be case four, above
		!
    		IF NOT DBG$NSAVE_DECIMAL_INTEGER(.INPUT_DESC,
    			RIGHT_MARGIN, .MESSAGE_VECT)
    		THEN
    		    RETURN STS$K_SEVERE;
    		LEFT_MARGIN = .DBG$SRC_LEFT_MARGIN;
    		END

    	    ELSE
    		BEGIN
    		IF NOT DBG$NSAVE_DECIMAL_INTEGER (.INPUT_DESC, 
    		    RIGHT_MARGIN, .MESSAGE_VECT)
    		THEN 
    		    RETURN STS$K_SEVERE;


    	        ! Look for colon
    	        !
    	        IF DBG$NMATCH (.INPUT_DESC, DBG$CS_COLON, 1)
    	        THEN
		    BEGIN


    		    ! This must be case 1 or case 3 above
		    !
    		    LEFT_MARGIN = .RIGHT_MARGIN;
    		    IF DBG$NMATCH (.INPUT_DESC, DBG$CS_CR, 1)
    		    THEN ! case 3
    			RIGHT_MARGIN = .DBG$SRC_RIGHT_MARGIN

    		    ELSE ! case 1
			BEGIN
    		        IF NOT DBG$NSAVE_DECIMAL_INTEGER (.INPUT_DESC,
    		            RIGHT_MARGIN, .MESSAGE_VECT)
    		        THEN
    			    RETURN STS$K_SEVERE;

			END;

    		    END

   	        ELSE
   		    ! case 2
    		    BEGIN
    		    LEFT_MARGIN = 1;
    		    END;

    		END;


    	    ! Check that left margin is less than right margin
    	    !
    	    IF .LEFT_MARGIN GEQ .RIGHT_MARGIN
    	    THEN
    		BEGIN
    		DBG$NSHOW_MARGINS();
    		SIGNAL(DBG$_INVMAR);
    		END;


    	    ! Fill in the noun node
    	    !
    	    NOUN_NODE[DBG$L_NOUN_VALUE] = .LEFT_MARGIN;
    	    NOUN_NODE[DBG$L_NOUN_VALUE2] = .RIGHT_MARGIN;

    	    END;

    	[DBG$NMATCH (.INPUT_DESC, DBG$CS_MAX_SOURCE_FILES, 3)] :
    	    BEGIN
    	    LOCAL
    		MAX_FILES;
    	    VERB_NODE[DBG$B_VERB_COMPOSITE] = SET_MAX_SOURCE_FILES;
    	    IF NOT DBG$NSAVE_DECIMAL_INTEGER(
    		.INPUT_DESC, MAX_FILES, .MESSAGE_VECT)
    	    THEN
    		RETURN STS$K_SEVERE;
    	    NOUN_NODE[DBG$L_NOUN_VALUE] = .MAX_FILES;
    	    END;

	[DBG$NMATCH (.INPUT_DESC, DBG$CS_MODE, 1)] :
	    BEGIN

	    LOCAL
		LINK;

	    BIND
		DBG$CS_BINARY		= UPLIT BYTE(%ASCIC 'BINARY'),
		DBG$CS_DECIMAL		= UPLIT BYTE(%ASCIC 'DECIMAL'),
    		DBG$CS_DEFAULT		= UPLIT BYTE(%ASCIC 'DEFAULT'),
    		DBG$CS_G_FLOAT		= UPLIT BYTE(%ASCIC 'G_FLOAT'),
		DBG$CS_HEXADECIMAL	= UPLIT BYTE(%ASCIC 'HEXADECIMAL'),
    		DBG$CS_KEYPAD		= UPLIT BYTE(%ASCIC 'KEYPAD'),
    		DBG$CS_NOG_FLOAT	= UPLIT BYTE(%ASCIC 'NOG_FLOAT'),
    		DBG$CS_NOKEYPAD		= UPLIT BYTE(%ASCIC 'NOKEYPAD'),
		DBG$CS_NOSCREEN		= UPLIT BYTE(%ASCIC 'NOSCREEN'),
		DBG$CS_NOSYMBOLS	= UPLIT BYTE(%ASCIC 'NOSYMBOLIC'),
		DBG$CS_OCTAL		= UPLIT BYTE(%ASCIC 'OCTAL'),
		DBG$CS_SCREEN		= UPLIT BYTE(%ASCIC 'SCREEN'),
		DBG$CS_SYMBOLS		= UPLIT BYTE(%ASCIC 'SYMBOLIC');

	    VERB_NODE [DBG$B_VERB_COMPOSITE] = SET_MODE;
	    
	    ! Accept the mode switches
	    !
	    WHILE TRUE DO
		BEGIN

		SELECTONE TRUE OF
		    SET

		    [DBG$NMATCH (.INPUT_DESC, DBG$CS_BINARY, 1)] :
			NOUN_NODE [DBG$L_NOUN_VALUE] = MODE_BINARY;

    		    [DBG$NMATCH (.INPUT_DESC, DBG$CS_DEFAULT, 3)]:
    			NOUN_NODE [DBG$L_NOUN_VALUE] = MODE_DEFAULT;

		    [DBG$NMATCH (.INPUT_DESC, DBG$CS_DECIMAL, 1)] :
			NOUN_NODE [DBG$L_NOUN_VALUE] = MODE_DECIMAL;

		    [DBG$NMATCH (.INPUT_DESC, DBG$CS_HEXADECIMAL, 1)] :
			NOUN_NODE [DBG$L_NOUN_VALUE] = MODE_HEX;

    		    [DBG$NMATCH(.INPUT_DESC, DBG$CS_KEYPAD, 1)]:
    			NOUN_NODE [DBG$L_NOUN_VALUE] = MODE_KEYPAD;

    		    [DBG$NMATCH(.INPUT_DESC, DBG$CS_NOKEYPAD, 3)]:
    			NOUN_NODE[DBG$L_NOUN_VALUE] = MODE_NOKEYPAD;

		    [DBG$NMATCH (.INPUT_DESC, DBG$CS_NOSCREEN, 5)] :
			NOUN_NODE [DBG$L_NOUN_VALUE] = MODE_NOSCREEN;

		    [DBG$NMATCH (.INPUT_DESC, DBG$CS_NOSYMBOLS, 1)] :
			NOUN_NODE [DBG$L_NOUN_VALUE] = MODE_NOSYMBLS;

		    [DBG$NMATCH (.INPUT_DESC, DBG$CS_OCTAL, 1)] :
			NOUN_NODE [DBG$L_NOUN_VALUE] = MODE_OCTAL;

		    [DBG$NMATCH (.INPUT_DESC, DBG$CS_SCREEN, 3)] :
			NOUN_NODE [DBG$L_NOUN_VALUE] = MODE_SCREEN;

		    [DBG$NMATCH (.INPUT_DESC, DBG$CS_SYMBOLS, 1)] :
			NOUN_NODE [DBG$L_NOUN_VALUE] = MODE_SYMBLS;

    		    [DBG$NMATCH (.INPUT_DESC, DBG$CS_G_FLOAT, 1)] :
    			NOUN_NODE [DBG$L_NOUN_VALUE] = MODE_G_FLOAT;

    		    [DBG$NMATCH (.INPUT_DESC, DBG$CS_NOG_FLOAT, 3)] :
    			NOUN_NODE [DBG$L_NOUN_VALUE] = MODE_NOG_FLOAT;

		    [OTHERWISE] :
			BEGIN
			IF DBG$NMATCH(.INPUT_DESC, DBG$CS_CR, 1)
			THEN
			    .MESSAGE_VECT = DBG$NMAKE_ARG_VECT(DBG$_NEEDMORE)

			ELSE
			    .MESSAGE_VECT = DBG$NSYNTAX_ERROR(
						DBG$NNEXT_WORD(.INPUT_DESC));

			RETURN STS$K_SEVERE;
			END;
	
		    TES;


		! Check for a comma to see if more input should follow
		!
		IF NOT DBG$NMATCH (.INPUT_DESC, DBG$CS_COMMA, 1)
		THEN
		    EXITLOOP;


		! More input should follow. Create another noun node and link
		!
		LINK = NOUN_NODE [DBG$L_NOUN_LINK];
    		NOUN_NODE = DBG$GET_TEMPMEM (DBG$K_NOUN_NODE_SIZE);
		.LINK = .NOUN_NODE;

		END;			! End of loop


	    ! Place a 0 in the last noun link field
	    !
	    NOUN_NODE [DBG$L_NOUN_LINK] = 0;

	    END;

	[DBG$NMATCH (.INPUT_DESC, DBG$CS_MODULE, 4)] :
	    BEGIN

    	    LOCAL
    		ALL_FLAG,
    		ALLOCATE_FLAG,
    		NOWAIT_FLAG;


    	    ! Initialize the flags for SET MODULE/ALL and SET MODULE/NOWAIT
    	    !
    	    ALL_FLAG = FALSE;
    	    ALLOCATE_FLAG = FALSE;
    	    NOWAIT_FLAG = FALSE;


	    ! Check for SET MODULE/ALL or SET MODULE/NOWAIT.
    	    !
    	    WHILE DBG$NMATCH (.INPUT_DESC, DBG$CS_SLASH, 1) DO
    		BEGIN
		BIND
		    DBG$CS_ALL    = 	UPLIT BYTE (3, 'ALL'),
    		    DBG$CS_ALLOCATE = 	UPLIT BYTE (8, 'ALLOCATE'),
    		    DBG$CS_NOWAIT = 	UPLIT BYTE (6, 'NOWAIT');

    		IF DBG$NMATCH (.INPUT_DESC, DBG$CS_ALLOCATE, 4)
    		THEN
    		    ALLOCATE_FLAG = TRUE

		ELSE IF DBG$NMATCH (.INPUT_DESC, DBG$CS_ALL, 1)
		THEN
    		    ALL_FLAG = TRUE

    		ELSE IF (IF NOT .DBG$GL_DEVELOPER[0] THEN FALSE ELSE
			DBG$NMATCH (.INPUT_DESC, DBG$CS_NOWAIT, 1))
    		THEN
    		    NOWAIT_FLAG = TRUE

    		ELSE
		    BEGIN
		    IF DBG$NMATCH(.INPUT_DESC, DBG$CS_CR, 1)
		    THEN
			.MESSAGE_VECT = DBG$NMAKE_ARG_VECT(DBG$_NEEDMORE)

		    ELSE
			.MESSAGE_VECT = DBG$NSYNTAX_ERROR(
						DBG$NNEXT_WORD(.INPUT_DESC));

		    RETURN STS$K_SEVERE;
		    END;

    		END;


    	    ! Use the ADVERB_POINTER field to indicate whether /NOWAIT 
    	    ! was specified and/or whether /ALLOCATE was specified.
    	    ! The codes are
    	    !	0 - neither /NOWAIT or /ALLOCATE
    	    !   1 - /NOWAIT, not /ALLOCATE
    	    !   2 - not /NOWAIT, /ALLOCATE
    	    !   3 - both were specified
    	    !
    	    VERB_NODE [DBG$L_VERB_ADVERB_PTR] = .NOWAIT_FLAG +
    						2*.ALLOCATE_FLAG;


    	    ! If /ALL was specified, indicate this in the verb_composite node.
    	    !
    	    IF .ALL_FLAG
    	    THEN
		VERB_NODE [DBG$B_VERB_COMPOSITE] = SET_MODULE_ALL


    	    ! Only pick up a module if /ALL was not specified.
	    ! We have a module name list to parse.
    	    !
    	    ELSE
	 	BEGIN

		BIND
		    DBG$CS_COMMA = UPLIT BYTE (1, dbg$k_comma);

		LOCAL
		    LINK;		! Temporary pointer


		! Accept strings and commas
		!
		WHILE TRUE DO
		    BEGIN

    		    ! For language C, we do some fancy footwork to
    		    ! make sure we preserve the original casing of
    		    ! the identifier (since casing is significant
    		    ! in C).
    		    !
    		    IF .dbg$gb_language EQL dbg$k_c
    		    THEN
    		 	BEGIN
    			MAP
    			    input_desc: REF dbg$stg_desc;
    			LOCAL
    			    length,
    			    new_pointer: REF VECTOR [,BYTE],
    					! Pointer to orig. command input
    			    pointer,	! Pointer into input string
    			    stg_desc: dbg$stg_desc, ! String descriptor
    			    temp_ptr;

    			pointer = .input_desc[dsc$a_pointer];
    			length = .input_desc[dsc$w_length];
	    		IF (.pointer LSS .dbg$gl_upcase_command_ptr[0]) OR
	       		   (.pointer GTR .dbg$gl_upcase_command_ptr[1])
    	    		THEN
    			    $DBG_ERROR('DBGNSHOW\DBG$NPARSE_SET 10');

    			! We unfortunately have to allocate memory
    			! and copy strings in order to stuff a
    			! trailing carriage return at the end.
    			!
	    		new_pointer = dbg$get_tempmem((.length+3)/4);
    			temp_ptr = (.pointer - .dbg$gl_upcase_command_ptr[0]) + 
    			            .dbg$gl_orig_command_ptr;
    			CH$MOVE (.length, .temp_ptr, .new_pointer);
    			new_pointer[.length-1] = dbg$k_car_return;

    			! Fill in the string descriptor.
    			!
    			stg_desc[dsc$b_class] = dsc$k_class_s;
    			stg_desc[dsc$b_dtype] = dsc$k_dtype_t;
    			stg_desc[dsc$w_length] = .length;
    			stg_desc[dsc$a_pointer] = .new_pointer;
    			stg_desc[dsc$l_pos] = 0;

    		        ! Pick up the symbol name.
    		        !
    		        IF NOT dbg$nsave_string( stg_desc,
						 NOUN_NODE [DBG$L_NOUN_VALUE],
    						.message_vect)
    		        THEN
    		            RETURN sts$k_severe;

    			! Update the input descriptor.
    			!
    			input_desc[dsc$w_length] = .input_desc[dsc$w_length] -
    			    (.length - .stg_desc[dsc$w_length]);
    			input_desc[dsc$a_pointer] = .input_desc[dsc$a_pointer] +
    			    (.length - .stg_desc[dsc$w_length]);
    			END

    		    ! All other languages besides C ...
    		    !
    		    ELSE


		        IF NOT DBG$NSAVE_STRING(.INPUT_DESC, 
			       NOUN_NODE [DBG$L_NOUN_VALUE], .MESSAGE_VECT)
		        THEN
			    RETURN STS$K_SEVERE;


		    ! Check for a comma
		    !
		    IF NOT DBG$NMATCH (.INPUT_DESC, DBG$CS_COMMA, 1)
		    THEN
			EXITLOOP;


		    ! Create a new noun node to hold the next string
		    !
		    LINK = NOUN_NODE [DBG$L_NOUN_LINK];
    		    NOUN_NODE = DBG$GET_TEMPMEM (DBG$K_NOUN_NODE_SIZE);
		    .LINK = .NOUN_NODE;

		    END;		! End of loop


		! Place a zero in the last link field
		!
		NOUN_NODE [DBG$L_NOUN_LINK] = 0;
		VERB_NODE [DBG$B_VERB_COMPOSITE] = SET_MODULE;
		END;

	    END;

	[DBG$NMATCH (.INPUT_DESC, DBG$CS_OUTPUT, 1)] :
	    BEGIN

	    LITERAL
		NOUN_LITERAL_LOG	= 1,
		NOUN_LITERAL_NOLOG	= 2,
		NOUN_LITERAL_SCREEN	= 3,
		NOUN_LITERAL_NOSCREEN	= 4,
		NOUN_LITERAL_TERMINAL	= 5,
		NOUN_LITERAL_NOTERMINAL	= 6,
		NOUN_LITERAL_VERIFY	= 7,
		NOUN_LITERAL_NOVERIFY	= 8;

	    BIND
		DBG$CS_LOG		= UPLIT BYTE (%ASCIC 'LOG'),
	   	DBG$CS_NOLOG		= UPLIT BYTE (%ASCIC 'NOLOG'),
		DBG$CS_SCREEN_LOG	= UPLIT BYTE (%ASCIC 'SCREEN_LOG'),
		DBG$CS_NOSCREEN_LOG	= UPLIT BYTE (%ASCIC 'NOSCREEN_LOG'),
		DBG$CS_TERMINAL		= UPLIT BYTE (%ASCIC 'TERMINAL'),
		DBG$CS_NOTERMINAL	= UPLIT BYTE (%ASCIC 'NOTERMINAL'),
		DBG$CS_VERIFY		= UPLIT BYTE (%ASCIC 'VERIFY'),
		DBG$CS_NOVERIFY		= UPLIT BYTE (%ASCIC 'NOVERIFY');

	    LOCAL
		LINK;			! Used as a link pointer


	    ! Set the verb composite.
	    !
	    VERB_NODE [DBG$B_VERB_COMPOSITE] = SET_OUTPUT;


	    ! Accept the SET OUTPUT xxx objects.
	    !
	    WHILE TRUE DO
		BEGIN
		SELECTONE TRUE OF
		    SET

		    [DBG$NMATCH (.INPUT_DESC, DBG$CS_LOG, 1)] :
			NOUN_NODE [DBG$L_NOUN_VALUE] = NOUN_LITERAL_LOG;

		    [DBG$NMATCH (.INPUT_DESC, DBG$CS_NOLOG, 3)] :
			NOUN_NODE [DBG$L_NOUN_VALUE] = NOUN_LITERAL_NOLOG;

		    [DBG$NMATCH (.INPUT_DESC, DBG$CS_SCREEN_LOG, 1)] :
			NOUN_NODE [DBG$L_NOUN_VALUE] = NOUN_LITERAL_SCREEN;

		    [DBG$NMATCH (.INPUT_DESC, DBG$CS_NOSCREEN_LOG, 3)] :
			NOUN_NODE [DBG$L_NOUN_VALUE] = NOUN_LITERAL_NOSCREEN;

		    [DBG$NMATCH (.INPUT_DESC, DBG$CS_TERMINAL, 1)] :
			NOUN_NODE [DBG$L_NOUN_VALUE] = NOUN_LITERAL_TERMINAL;

		    [DBG$NMATCH (.INPUT_DESC, DBG$CS_NOTERMINAL, 3)] :
			NOUN_NODE [DBG$L_NOUN_VALUE] = NOUN_LITERAL_NOTERMINAL;

		    [DBG$NMATCH (.INPUT_DESC, DBG$CS_VERIFY, 1)] :
			NOUN_NODE [DBG$L_NOUN_VALUE] = NOUN_LITERAL_VERIFY;

		    [DBG$NMATCH (.INPUT_DESC, DBG$CS_NOVERIFY, 3)] :
			NOUN_NODE [DBG$L_NOUN_VALUE] = NOUN_LITERAL_NOVERIFY;

		    [OTHERWISE] :
			BEGIN
			IF DBG$NMATCH (.INPUT_DESC, DBG$CS_CR, 1)
			THEN
			    .MESSAGE_VECT = DBG$NMAKE_ARG_VECT (DBG$_NEEDMORE)

			ELSE
			    .MESSAGE_VECT = DBG$NSYNTAX_ERROR (DBG$NNEXT_WORD
							       (.INPUT_DESC));
			RETURN STS$K_SEVERE;
			END;
	
		    TES;


		! Look for a comma and exit the loop if none found
		!
		IF NOT DBG$NMATCH (.INPUT_DESC, DBG$CS_COMMA, 1)
		THEN
		    EXITLOOP;


		! Since we expect more input, create another noun node
		!
		LINK = NOUN_NODE [DBG$L_NOUN_LINK];
    		NOUN_NODE = DBG$GET_TEMPMEM (DBG$K_NOUN_NODE_SIZE);
		.LINK = .NOUN_NODE;

		END;			! End of loop


	    ! Put a zero in the last link field of the noun node chain
	    !
	    NOUN_NODE [DBG$L_NOUN_LINK] = 0;

	    END;
		    
	[DBG$NMATCH (.INPUT_DESC, DBG$CS_RADIX, 1)] :
	    BEGIN
	    BIND
		DBG$CS_BINARY		= UPLIT BYTE(%ASCIC 'BINARY'),
		DBG$CS_DECIMAL		= UPLIT BYTE(%ASCIC 'DECIMAL'),
    		DBG$CS_DEFAULT		= UPLIT BYTE(%ASCIC 'DEFAULT'),
		DBG$CS_HEXADECIMAL	= UPLIT BYTE(%ASCIC 'HEXADECIMAL'),
    		DBG$CS_INPUT		= UPLIT BYTE(%ASCIC 'INPUT'),
		DBG$CS_OCTAL		= UPLIT BYTE(%ASCIC 'OCTAL'),
    		DBG$CS_OUTPUT		= UPLIT BYTE(%ASCIC 'OUTPUT'),
    		DBG$CS_OVERRIDE		= UPLIT BYTE(%ASCIC 'OVERRIDE');

    	    ! Check for the /OVERRIDE switch. Then fill in the verb
    	    ! composite field accordingly. Also check for /INPUT or
    	    ! /OUTPUT.
    	    !
    	    VERB_NODE[DBG$B_VERB_COMPOSITE] = SET_RADIX;
    	    WHILE DBG$NMATCH (.INPUT_DESC, DBG$CS_SLASH, 1) DO
    		SELECTONE TRUE OF
    		    SET

    		    [DBG$NMATCH (.INPUT_DESC, DBG$CS_INPUT, 1)]:
    			NOUN_NODE[DBG$L_NOUN_VALUE2] = 1;

    		    [DBG$NMATCH (.INPUT_DESC, DBG$CS_OUTPUT, 2)]:
    			NOUN_NODE[DBG$L_NOUN_VALUE2] = 2;

    		    [DBG$NMATCH (.INPUT_DESC, DBG$CS_OVERRIDE, 2)]:
    		        VERB_NODE [DBG$B_VERB_COMPOSITE] = SET_RADIX_OVERRIDE;

    		    [OTHERWISE]:
    			BEGIN
    			LOCAL
    			    CS: REF VECTOR[,BYTE],
    			    STG_DESC: DBG$STG_DESC;
    		        IF DBG$NMATCH (.INPUT_DESC, DBG$CS_CR, 1)
    		        THEN
    			    SIGNAL(DBG$_NEEDMORE)
    		        ELSE
    			    BEGIN
    			    CS = DBG$NNEXT_WORD(.INPUT_DESC);
    			    STG_DESC[DSC$B_CLASS] = DSC$K_CLASS_S;
    			    STG_DESC[DSC$B_DTYPE] = DSC$K_DTYPE_T;
    			    STG_DESC[DSC$W_LENGTH] = .CS[0];
    			    STG_DESC[DSC$A_POINTER] = CS[1];
    			    SIGNAL(DBG$_SYNTAX, 1, STG_DESC);
    			    END;
    			END;
    		    TES;

	    ! Accept the radix argument.
	    !
	    SELECTONE TRUE OF
		SET

		[DBG$NMATCH (.INPUT_DESC, DBG$CS_BINARY, 1)] :
		    NOUN_NODE [DBG$L_NOUN_VALUE] = MODE_BINARY;

    		[DBG$NMATCH (.INPUT_DESC, DBG$CS_DEFAULT, 3)]:
    		    NOUN_NODE [DBG$L_NOUN_VALUE] = MODE_DEFAULT;

		[DBG$NMATCH (.INPUT_DESC, DBG$CS_DECIMAL, 1)] :
		    NOUN_NODE [DBG$L_NOUN_VALUE] = MODE_DECIMAL;

		[DBG$NMATCH (.INPUT_DESC, DBG$CS_HEXADECIMAL, 1)] :
		    NOUN_NODE [DBG$L_NOUN_VALUE] = MODE_HEX;

		[DBG$NMATCH (.INPUT_DESC, DBG$CS_OCTAL, 1)] :
		    NOUN_NODE [DBG$L_NOUN_VALUE] = MODE_OCTAL;

		[OTHERWISE] :
		    BEGIN
		    IF DBG$NMATCH(.INPUT_DESC, DBG$CS_CR, 1)
		    THEN
			.MESSAGE_VECT = DBG$NMAKE_ARG_VECT(DBG$_NEEDMORE)

		    ELSE
			.MESSAGE_VECT = DBG$NSYNTAX_ERROR(
						DBG$NNEXT_WORD(.INPUT_DESC));
		    RETURN STS$K_SEVERE;
		    END;
	
		 TES;
	    END;


	[DBG$NMATCH (.INPUT_DESC, DBG$CS_SCOPE, 2)] :
	    BEGIN
	    VERB_NODE [DBG$B_VERB_COMPOSITE] = SET_SCOPE;
    	
    	    ! Fill in 1 to the ADVERB field if SET SCOPE/MODULE was
    	    ! specified; 0 otherwise.
    	    !
    	    IF DBG$NMATCH (.INPUT_DESC, DBG$CS_SLASH, 1)
    	    THEN
    		IF DBG$NMATCH (.INPUT_DESC, DBG$CS_MODULE, 1)
    		THEN
    		    VERB_NODE[DBG$L_VERB_ADVERB_PTR] = 1
    		ELSE
    		    SIGNAL(DBG$_SETSCOMOD, 1, DBG$NNEXT_WORD(.INPUT_DESC))
    	    ELSE
    		VERB_NODE[DBG$L_VERB_ADVERB_PTR] = 0;

	    IF NOT DBG$NPARSE_SCOPE_LIST(.INPUT_DESC, 
				NOUN_NODE[DBG$L_NOUN_VALUE], .MESSAGE_VECT)
	    THEN
		RETURN STS$K_SEVERE;

	    END;

    	[DBG$NMATCH (.INPUT_DESC, DBG$CS_SEARCH, 2)] :
    	    BEGIN

    	    LITERAL
    	        NOUN_LITERAL_ALL = 1,
    	        NOUN_LITERAL_NEXT = 2,
    	        NOUN_LITERAL_STRING = 3,
    	        NOUN_LITERAL_IDENT = 4;

    	    BIND
    		DBG$CS_ALL	= UPLIT BYTE (3, 'ALL'),
    		DBG$CS_NEXT	= UPLIT BYTE (4, 'NEXT'),
    		DBG$CS_STRING	= UPLIT BYTE (6, 'STRING'),
    		DBG$CS_IDENT	= UPLIT BYTE(10, 'IDENTIFIER');

    	    LOCAL
    		LINK;			! Used as a link pointer


    	    ! Set up the verb composite
    	    !
    	    VERB_NODE[DBG$B_VERB_COMPOSITE] = SET_SEARCH;

    	    ! Accept the SET SEARCH xxx objects
    	    !
    	    WHILE TRUE DO
    		BEGIN
    		SELECTONE TRUE OF
    		    SET

    		    [DBG$NMATCH (.INPUT_DESC, DBG$CS_ALL, 1)] :
    			NOUN_NODE [DBG$L_NOUN_VALUE] = NOUN_LITERAL_ALL;

    		    [DBG$NMATCH (.INPUT_DESC, DBG$CS_IDENT, 1)] :
    			NOUN_NODE [DBG$L_NOUN_VALUE] = NOUN_LITERAL_IDENT;
    
    		    [DBG$NMATCH (.INPUT_DESC, DBG$CS_NEXT, 1)] :
    			NOUN_NODE [DBG$L_NOUN_VALUE] = NOUN_LITERAL_NEXT;

    		    [DBG$NMATCH (.INPUT_DESC, DBG$CS_STRING, 1)] :
    			NOUN_NODE [DBG$L_NOUN_VALUE] = NOUN_LITERAL_STRING;

    		    [OTHERWISE] :
    			BEGIN
    			IF DBG$NMATCH (.INPUT_DESC, DBG$CS_CR, 1)
    			THEN
    			    .MESSAGE_VECT = DBG$NMAKE_ARG_VECT (DBG$_NEEDMORE)

    			ELSE
    			    .MESSAGE_VECT = DBG$NSYNTAX_ERROR(
						DBG$NNEXT_WORD(.INPUT_DESC));

    			RETURN STS$K_SEVERE;
    			END;

    		    TES;


    		! Look for comma and exit the loop if none found.
    		!
    		IF NOT DBG$NMATCH (.INPUT_DESC, DBG$CS_COMMA, 1)
    		THEN
    		    EXITLOOP;


    		! Since we expect more input, create another noun node.
    		!
    		LINK = NOUN_NODE[DBG$L_NOUN_LINK];
    		NOUN_NODE = DBG$GET_TEMPMEM (DBG$K_NOUN_NODE_SIZE);
    		.LINK = .NOUN_NODE;

    		END;			! End of loop


    	    ! Put a zero in the last link field of the noun node chain.
    	    !
    	    NOUN_NODE [DBG$L_NOUN_LINK] = 0;

    	    END;


	! Parse the SET SOURCE command.
	!
    	[DBG$NMATCH (.INPUT_DESC, DBG$CS_SOURCE, 2)] : 
    	    BEGIN
    	    VERB_NODE[DBG$B_VERB_COMPOSITE] = SET_SOURCE;
    

    	    ! Check for SET SOURCE/MODULE=dir-list
	    !
    	    IF DBG$NMATCH (.INPUT_DESC, DBG$CS_SLASH, 1)
    	    THEN
    		BEGIN

    		LOCAL
    		    MODNAMEPTR;

    		BIND
    		    DBG$CS_MODULE = UPLIT BYTE (6, 'MODULE');


    		! Read the string MODULE.
		!
    		IF NOT DBG$NMATCH (.INPUT_DESC, DBG$CS_MODULE, 4)
    		THEN
    		    BEGIN
    		    .MESSAGE_VECT = DBG$NSYNTAX_ERROR(
					DBG$NNEXT_WORD(.INPUT_DESC));
    		    RETURN STS$K_SEVERE;
    		    END;


    		! Read the = sign.
		!
    		IF NOT DBG$NMATCH (.INPUT_DESC, DBG$CS_EQUAL, 1)
    		THEN
    		    BEGIN
    		    .MESSAGE_VECT = DBG$NSYNTAX_ERROR(
					DBG$NNEXT_WORD(.INPUT_DESC));
    		    RETURN STS$K_SEVERE;
    		    END;


    		! Read the module name.
		!
    		IF NOT DBG$NSAVE_STRING(.INPUT_DESC, MODNAMEPTR, .MESSAGE_VECT)
    		THEN
    		    RETURN STS$K_SEVERE;


    		! Convert the module name into an rst pointer and
    		! save into the adjective field of the noun node.
		!
    		NOUN_NODE[DBG$L_ADJECTIVE_PTR] =
    		    DBG$STA_GETSOURCEMOD(.MODNAMEPTR);
    	

    		! If the above routine returns zero then the user has
    		! entered an invalid module.
		!
    		IF .NOUN_NODE[DBG$L_ADJECTIVE_PTR] EQL 0
    		THEN
    		    BEGIN
    		    .MESSAGE_VECT = DBG$NMAKE_ARG_VECT(
					DBG$_NOSUCHMODU, 1, .MODNAMEPTR);
    		    RETURN STS$K_SEVERE;
    		    END;

    		END;			! SET SOURCE/MODULE=


    	    ! Now read the directory list.
	    !
    	    IF NOT DBG$NGET_DIR_LIST (.INPUT_DESC,
			NOUN_NODE[DBG$L_NOUN_VALUE], .MESSAGE_VECT)
    	    THEN
    		RETURN STS$K_SEVERE;

    	    END;			! SET SOURCE
    	    		

	! Parse the SET STEP command.
	!
	[DBG$NMATCH (.INPUT_DESC, DBG$CS_STEP, 1)] :
	    BEGIN
	    VERB_NODE [DBG$B_VERB_COMPOSITE] = EVENT$K_SET_STEP;
	    RETURN DBG$EVENT_SYNTAX (.INPUT_DESC, .VERB_NODE, .MESSAGE_VECT);
	    END;


    	! Parse the SET TASK command.
    	!
	[IF NOT .DBG$GL_DEVELOPER[0] THEN FALSE ELSE
	 DBG$NMATCH (.INPUT_DESC, DBG$CS_TASK, 2)]:
    	    BEGIN
    	    VERB_NODE[DBG$B_VERB_COMPOSITE] = SET_TASK;
    	    DBG$NPARSE_SET_TASK(.INPUT_DESC, .VERB_NODE);
    	    END;


	! Parse the SET TERMINAL command.
	!
	[DBG$NMATCH(.INPUT_DESC, DBG$CS_TERMINAL, 4)]:
	    BEGIN
	    VERB_NODE[DBG$B_VERB_COMPOSITE] = SET_TERMINAL;
	    DBG$SCR_PARSE_SETTERM_CMD(.INPUT_DESC, .VERB_NODE);
	    END;


	! Parse the SET TRACE command.
	!
	[DBG$NMATCH(.INPUT_DESC, DBG$CS_TRACE, 1)]:
	    BEGIN
	    VERB_NODE [DBG$B_VERB_COMPOSITE] = SET_TRACE;
	    RETURN DBG$EVENT_SYNTAX (.INPUT_DESC,
				     .VERB_NODE,
				     .MESSAGE_VECT
				    );
	    END;


	[dbg$nmatch (.input_desc, dbg$cs_type, 2)] :	! SET TYPE or SET TYPE/OVERRIDE
	    BEGIN
	    LOCAL
		LENGTH_NODE : REF dbg$noun_node;

	    BIND
    		DBG$CS_AC	= UPLIT BYTE (2, 'AC'),
    		DBG$CS_AD	= UPLIT BYTE (2, 'AD'),
    		DBG$CS_ASCIC	= UPLIT BYTE (5, 'ASCIC'),
    		DBG$CS_ASCID	= UPLIT BYTE (5, 'ASCID'),
		DBG$CS_ASCII	= UPLIT BYTE (5, 'ASCII'),
    		DBG$CS_ASCIZ	= UPLIT BYTE (5, 'ASCIZ'),
    		DBG$CS_AZ	= UPLIT BYTE (2, 'AZ'),
		DBG$CS_BYTE	= UPLIT BYTE (4, 'BYTE'),
		DBG$CS_COLON	= UPLIT BYTE (1, dbg$k_colon),
		DBG$CS_D_FLOAT	= UPLIT BYTE (7, 'D_FLOAT'),
		DBG$CS_FLOAT	= UPLIT BYTE (5, 'FLOAT'),
		DBG$CS_F_FLOAT	= UPLIT BYTE (7, 'F_FLOAT'),
		DBG$CS_G_FLOAT	= UPLIT BYTE (7, 'G_FLOAT'),
		DBG$CS_H_FLOAT	= UPLIT BYTE (7, 'H_FLOAT'),
		DBG$CS_PACKED	= UPLIT BYTE (6, 'PACKED'),
		DBG$CS_INSTRUCTION = UPLIT BYTE (11, 'INSTRUCTION'),
		DBG$CS_DATE_TIME = UPLIT BYTE (9, 'DATE_TIME'),
		DBG$CS_LONGWORD	= UPLIT BYTE (8, 'LONGWORD'),
		DBG$CS_OCTAWORD = UPLIT BYTE (8, 'OCTAWORD'),
		DBG$CS_OVERRIDE	= UPLIT BYTE (8, 'OVERRIDE'),
		DBG$CS_QUADWORD = UPLIT BYTE (8, 'QUADWORD'),
		DBG$CS_WORD	= UPLIT BYTE (4, 'WORD');

	    ! Create and link the length node (the second noun node).
    	    !
    	    length_node = dbg$get_tempmem (dbg$k_noun_node_size);
	    noun_node [dbg$l_noun_link] = .length_node;

	    ! Look for slash
    	    !
	    IF dbg$nmatch (.input_desc, dbg$cs_slash, 1)
	    THEN
		BEGIN

		! Must find 'override'
    		!
		IF NOT dbg$nmatch (.input_desc, dbg$cs_override, 1)
		THEN
		    BEGIN
		    .message_vect =
		    (IF dbg$nmatch (.input_desc, dbg$cs_cr, 1)
		    THEN
			dbg$nmake_arg_vect (dbg$_needmore)
		    ELSE
			dbg$nsyntax_error (dbg$nnext_word (.input_desc)));
		    RETURN sts$k_severe;
		    END;
		
		! Set the verb composite
    		!
		verb_node [dbg$b_verb_composite] = set_type_override;
		END

	    ELSE
		verb_node [dbg$b_verb_composite] = set_type;

	    ! The verb composite has been set. We must recognize the type specified.
    	    !
	    SELECTONE true
		OF
		SET

    		[dbg$nmatch (.input_desc, dbg$cs_ascic, 5),
    		 dbg$nmatch (.input_desc, dbg$cs_ac, 2)] :
    		    BEGIN
    		    noun_node [dbg$l_noun_value] = dsc$k_dtype_ac;
    		    length_node [dbg$l_noun_value] = 0;
    		    END;

!    		[dbg$nmatch (.input_desc, dbg$cs_ascid, 5) OR
!    		 dbg$nmatch (.input_desc, dbg$cs_ad, 2)] :
!    		    BEGIN
!    		    noun_node [dbg$l_noun_value] = dsc$k_dtype_ad;
!    		    length_node [dbg$l_noun_value] = 8;
!    		    END;

	    	[dbg$nmatch (.input_desc, dbg$cs_packed, 1)] :		       
		    BEGIN							       
		    noun_node [dbg$l_noun_value] = dsc$k_dtype_p;
									       
		    ! Accept the ':' and integer. If there is no colon, use	       
		    ! a length or default of 10.				       
		    !							       
		    IF NOT dbg$nmatch (.input_desc, dbg$cs_colon, 1)	       
		    THEN							       
		        SIGNAL(dbg$_pacsizreq)
		    ELSE							       
		        BEGIN						       
									       
		        ! We found the colon. Accept the integer		       
		        !							       
		        IF NOT dbg$nsave_integer (.input_desc,
						  length_node [dbg$l_noun_value])
		        THEN	    					           
			    RETURN sts$k_severe;				       
									       
		        ! Check to see that the length is within 0 and 31	       
		        !							       
		        IF (.length_node [dbg$l_noun_value] LSS 0)  OR  (.length_node [dbg$l_noun_value] GTR 31)
		        THEN						           
			    SIGNAL(dbg$_illpacsiz, 1, .length_node [dbg$l_noun_value]);		       
		        END;						       
		    END;							       

		[dbg$nmatch (.input_desc, dbg$cs_ascii, 1)] :
		    BEGIN
		    noun_node [dbg$l_noun_value] = dsc$k_dtype_t;

		    ! There may be a colon followed by integer. If not,
		    ! we use a default length of 4.
    		    !
		    length_node [dbg$l_noun_value] = 4;

		    ! See if a colon follows
    		    !
		    IF dbg$nmatch (.input_desc, dbg$cs_colon, 1)
		    THEN
			BEGIN

			! Obtain the integer.
    			!
			IF NOT dbg$nsave_integer (.input_desc,
						  length_node [dbg$l_noun_value])
			THEN
			    RETURN sts$k_severe;

			! Check for a zero length
    			!
			IF .length_node [dbg$l_noun_value] EQL 0
			THEN
			    BEGIN

			    ! Set up for an error message
    			    !
			    OWN
				ZERO_DESC : dbg$stg_desc;
			    zero_desc [dsc$w_length] = 1;
			    zero_desc [dsc$a_pointer] = UPLIT BYTE ('0');
			    .message_vect = dbg$nmake_arg_vect (dbg$_invnumber,
								1,
								zero_desc);
			    RETURN sts$k_severe;
			    END;
			END;
		    END;

    		[dbg$nmatch (.input_desc, dbg$cs_asciz, 5),
    		 dbg$nmatch (.input_desc, dbg$cs_az, 2)] :
    		    BEGIN
    		    noun_node [dbg$l_noun_value] = dsc$k_dtype_az;
    		    length_node [dbg$l_noun_value] = 0;
    		    END;

		[dbg$nmatch (.input_desc, dbg$cs_byte, 1)] :
		    BEGIN
		    noun_node [dbg$l_noun_value] = dsc$k_dtype_b;
		    length_node [dbg$l_noun_value] = 1;
		    END;

		[dbg$nmatch (.input_desc, dbg$cs_date_time, 2)] :
		    BEGIN
		    noun_node [dbg$l_noun_value] = dsc$k_dtype_adt;
		    length_node [dbg$l_noun_value] = 8;
		    END;

		[dbg$nmatch (.input_desc, dbg$cs_d_float, 1) ] :
		    BEGIN
		    noun_node [dbg$l_noun_value] = dsc$k_dtype_d;
		    length_node [dbg$l_noun_value] = 8;
		    END;

		[dbg$nmatch (.input_desc, dbg$cs_float, 1),
		 dbg$nmatch (.input_desc, dbg$cs_f_float, 1)] :
		    BEGIN
		    noun_node [dbg$l_noun_value] = dsc$k_dtype_f;
		    length_node [dbg$l_noun_value] = 4;
		    END;

		[dbg$nmatch (.input_desc, dbg$cs_g_float, 1) ] :
		    BEGIN
		    noun_node [dbg$l_noun_value] = dsc$k_dtype_g;
		    length_node [dbg$l_noun_value] = 8;
		    END;

		[dbg$nmatch (.input_desc, dbg$cs_h_float, 1) ] :
		    BEGIN
		    noun_node [dbg$l_noun_value] = dsc$k_dtype_h;
		    length_node [dbg$l_noun_value] = 16;
		    END;

		[dbg$nmatch (.input_desc, dbg$cs_instruction, 1)] :
		    BEGIN
		    noun_node [dbg$l_noun_value] = dsc$k_dtype_zi;
		    length_node [dbg$l_noun_value] = 0;
		    END;

		[dbg$nmatch (.input_desc, dbg$cs_longword, 1)] :
		    BEGIN
		    noun_node [dbg$l_noun_value] = dsc$k_dtype_l;
		    length_node [dbg$l_noun_value] = 4;
		    END;

		[dbg$nmatch (.input_desc, dbg$cs_octaword, 1)] :
		    BEGIN
		    noun_node [dbg$l_noun_value] = dsc$k_dtype_o;
		    length_node [dbg$l_noun_value] = 16;
		    END;

		[dbg$nmatch (.input_desc, dbg$cs_quadword, 1)] :
		    BEGIN
		    noun_node [dbg$l_noun_value] = dsc$k_dtype_q;
		    length_node [dbg$l_noun_value] = 8;
		    END;

		[dbg$nmatch (.input_desc, dbg$cs_word, 1)] :
		    BEGIN
		    noun_node [dbg$l_noun_value] = dsc$k_dtype_w;
		    length_node [dbg$l_noun_value] = 2;
		    END;

		[OTHERWISE] :
		    BEGIN
		    .message_vect =
		    (IF dbg$nmatch (.input_desc, dbg$cs_cr, 1)
		    THEN
			dbg$nmake_arg_vect (dbg$_needmore)
		    ELSE
			dbg$nsyntax_error (dbg$nnext_word (.input_desc)));
		    RETURN sts$k_severe;
		    END;

		TES;

	    END;


	! Parse the SET WATCH command.
	!
	[DBG$NMATCH (.INPUT_DESC, DBG$CS_WATCH, 1)]:
	    BEGIN
	    VERB_NODE [DBG$B_VERB_COMPOSITE] = SET_WATCH;
	    RETURN DBG$EVENT_SYNTAX(.INPUT_DESC, .VERB_NODE, .MESSAGE_VECT);
	    END;


	! Parse the SET WINDOW command.
	!
	[DBG$NMATCH(.INPUT_DESC, DBG$CS_WINDOW, 3)]:
	    BEGIN
	    VERB_NODE[DBG$B_VERB_COMPOSITE] = SET_WINDOW;
	    DBG$SCR_PARSE_SETWIND_CMD(.INPUT_DESC, .VERB_NODE);
	    END;


	! Any other SET command keyword constitutes a syntax error.
	!
	[OTHERWISE]:
	    BEGIN
	    IF DBG$NMATCH (.INPUT_DESC, DBG$CS_CR, 1)
	    THEN
	 	.MESSAGE_VECT = DBG$NMAKE_ARG_VECT(DBG$_NEEDMORE)

	    ELSE
		.MESSAGE_VECT = DBG$NSYNTAX_ERROR(DBG$NNEXT_WORD (.INPUT_DESC));

	    RETURN STS$K_SEVERE;
	    END;

	TES;


    ! The SET command has been successfully parsed.  Return to the caller.
    !
    RETURN STS$K_SUCCESS;

    END;

GLOBAL ROUTINE DBG$NEXECUTE_SET (VERB_NODE, MESSAGE_VECT) =
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine processes the command execution tree corresponding to the parsed
!	SET ... command. Appropriate semantic actions are taken.
!
! FORMAL PARAMETERS:
!
!	VERB_NODE -		The head node in the command execution tree
!
!	MESSAGE_VECT -		The address of a longword to contain the address
!				of a message argument vector
!
! IMPLICIT INPUTS:
!
!	DBG$GL_LOG_BUF -	Version 2 debugger pointer to counted string filespec
!
!	DBG$GL_CONTEXT -	   "    "    "     context switch vector for log and output
!
!	DBG$GB_DEF_OUT -	   "    "    "     output control vector
!
!	DBG$GL_LOGFAB -		   "    "    "     FAB for log file
!
!	DBG$GL_LOGRAB -		   "    "    "     RAB  "   "   "
!
! IMPLICIT OUTPUTS:
!
!	Any of the above implicit inputs may be altered
!
! ROUTINE VALUE:	
!
!	An unsigned integer longword completion code
!
! COMPLETION CODES:
!
!	STS$K_SEVERE (4)	 - Signifies that the command was not executed
!
!	STS$K_SUCCESS (1)	 - Signifies that a command was executed.
!
! SIDE EFFECTS:
!
!	Various semantic actions are performed on data structures. That is, the
!	state of the debugger is altered.
!

    BEGIN

    MAP
	VERB_NODE : REF DBG$VERB_NODE;	! Pointer to command Verb Node

    LOCAL
	NOUN_NODE : REF DBG$NOUN_NODE;	! Pointer to current Noun Node



    ! Recover the noun node.
    !
    NOUN_NODE = .VERB_NODE [DBG$L_VERB_OBJECT_PTR];
        

    ! Transfer to a subnetwork on the basis of the composite verb.
    !
    CASE .VERB_NODE[DBG$B_VERB_COMPOSITE] FROM SET_MINIMUM TO SET_MAXIMUM OF
	    SET


	    ! Execute the SET BREAK command.
	    !
	    [SET_BREAK]:
		DBG$EVENT_SEMANTICS (.VERB_NODE, .MESSAGE_VECT);


	    ! Execute the SET DEVELOPER command by setting the specified
	    ! bits in the DBG$GL_DEVELOPER longword.
	    !
	    [SET_DEVELOPER] :
    		BEGIN
    		IF .VERB_NODE[DBG$L_VERB_OBJECT_PTR] NEQ 0
    		THEN
    		    BEGIN
    		    NOUN_NODE = .VERB_NODE[DBG$L_VERB_OBJECT_PTR];
    		    WHILE TRUE DO
    			BEGIN
    			DBG$GL_DEVELOPER[.NOUN_NODE [DBG$L_NOUN_VALUE]] = TRUE;
    			IF .NOUN_NODE[DBG$L_NOUN_LINK] EQL 0 THEN EXITLOOP;
    			NOUN_NODE = .NOUN_NODE[DBG$L_NOUN_LINK];
    			END;

    		    END;

    		END;


	    ! Execute the SET DEFINE command.
	    !
    	    [SET_DEFINE] :
    		BEGIN
    		DBG$SET_DEFINE_LVL (USER_DEF_DEFINE);
    		DBG$GB_DEFINE_PTR[DEFINE_ONLY] = .NOUN_NODE [DBG$L_NOUN_VALUE];
    		END;


	    ! Execute the SET DISPLAY command.
	    !
	    [SET_DISPLAY]:
		DBG$SCR_EXECUTE_DISPLAY_CMD(.VERB_NODE, TRUE);


	    ! Execute the SET EXCEPTION BREAK command.
	    !
	    [set_exception_break] :
		BEGIN
		dbg$gb_resignal = false;
		RETURN DBG$EVENT_SEMANTICS (.VERB_NODE, .MESSAGE_VECT);
		END;

	   
            ! Execute the SET KEY command.
            !
            [SET_KEY] :
                BEGIN

                LOCAL
                    OUTPUT_LOG,
                    SET_STATUS,
                    DESC_PTR: REF DBG$STG_DESC;

                OUTPUT_LOG = .VERB_NODE [DBG$L_VERB_ADVERB_PTR];


                ! Make the call to set the status.
                !
                SET_STATUS = SMG$SET_DEFAULT_STATE (DBG$GL_KEY_TABLE_ID,
						.NOUN_NODE [DBG$L_NOUN_VALUE]);
                IF NOT .SET_STATUS THEN SIGNAL(DBG$_SETKEYERR);
                IF .OUTPUT_LOG
                THEN
                    SIGNAL(DBG$_SETKEY, 1, .NOUN_NODE [DBG$L_NOUN_VALUE]);

                END;

	    [SET_LANGUAGE] :
		BEGIN
		DBG$SET_LANG (0, .NOUN_NODE [DBG$L_NOUN_VALUE]);
		END;

	    [set_log] :
		BEGIN
		dbg$gl_log_buf = .noun_node [dbg$l_noun_value];
		IF NOT dbg$nset_log (.message_vect)
		THEN
		    RETURN sts$k_severe;
		END;

    	    [set_margins] :
    		BEGIN
    		dbg$src_left_margin = .noun_node[dbg$l_noun_value];
    		dbg$src_right_margin = .noun_node[dbg$l_noun_value2];
    		END;

    	    [set_max_source_files] :
    		BEGIN
    		dbg$src_set_max_files(.noun_node[dbg$l_noun_value]);
    		END;


	    ! Execute the SET MODE command.
	    !
	    [SET_MODE] :
		BEGIN


		! Set the mode level to the correct level.
		!
		DBG$SET_MOD_LVL (USER_DEF_MODE);


		! Now fill in the correct mode values.
		!
		WHILE .NOUN_NODE NEQA 0 DO
		    BEGIN
		    CASE .NOUN_NODE [DBG$L_NOUN_VALUE]
					FROM MODE_LOWEST TO MODE_HIGHEST OF
			SET

			[MODE_BINARY] :
    			    BEGIN
    			    DBG$GB_RADIX[DBG$B_RADIX_INPUT] = DBG$K_BINARY;
    			    DBG$GB_RADIX[DBG$B_RADIX_OUTPUT] = DBG$K_BINARY;
    			    END;

			[MODE_OCTAL] :
    			    BEGIN
    			    DBG$GB_RADIX[DBG$B_RADIX_INPUT] = DBG$K_OCTAL;
    			    DBG$GB_RADIX[DBG$B_RADIX_OUTPUT] = DBG$K_OCTAL;
    			    END;

			[MODE_DECIMAL] :
    			    BEGIN
    			    DBG$GB_RADIX[DBG$B_RADIX_INPUT] = DBG$K_DECIMAL;
    			    DBG$GB_RADIX[DBG$B_RADIX_OUTPUT] = DBG$K_DECIMAL;
    			    END;

    			[MODE_DEFAULT] :
    			    BEGIN
    			    DBG$GB_RADIX[DBG$B_RADIX_INPUT] = 
    				DBG$NGET_TRANS_RADIX(DBG$K_DEFAULT);
    			    DBG$GB_RADIX[DBG$B_RADIX_OUTPUT] = 
    				DBG$NGET_TRANS_RADIX(DBG$K_DEFAULT);
    			    END;

			[MODE_HEX] :
    			    BEGIN
    			    DBG$GB_RADIX[DBG$B_RADIX_INPUT] = DBG$K_HEX;
    			    DBG$GB_RADIX[DBG$B_RADIX_OUTPUT] = DBG$K_HEX;
    			    END;

			[MODE_SYMBLS] :
			    DBG$GB_MOD_PTR [MODE_SYMBOLS] = TRUE;

			[MODE_NOSYMBLS] :
			    DBG$GB_MOD_PTR [MODE_SYMBOLS] = FALSE;

    			[MODE_G_FLOAT]:
    			    DBG$GB_MOD_PTR [MODE_G_FLOATS] = TRUE;

    			[MODE_NOG_FLOAT]:
    			    DBG$GB_MOD_PTR [MODE_G_FLOATS] = FALSE;

			[MODE_SCREEN]:
			    DBG$SCR_SCREEN_MODE(TRUE);

			[MODE_NOSCREEN]:
			    DBG$SCR_SCREEN_MODE(FALSE);

    			[MODE_KEYPAD]:
    			    BEGIN
    			    DBG$GB_KEYPAD_INPUT = TRUE;
    			    SMG$SET_KEYPAD_MODE (DBG$GL_KEYBOARD_ID,%REF(1));
    			    END;

    			[MODE_NOKEYPAD]:
    			    BEGIN
    			    DBG$GB_KEYPAD_INPUT = FALSE;
    			    SMG$SET_KEYPAD_MODE (DBG$GL_KEYBOARD_ID,%REF(0));
    			    END;

			TES;


		    ! Recover the next Noun Node and loop.
		    !
		    NOUN_NODE = .NOUN_NODE [DBG$L_NOUN_LINK];

		    END;		! End of loop over SET MODE keywords

		END;			! End of SET MODE command


	    ! Handle the SET MODULE command.
	    !
	    [SET_MODULE, SET_MODULE_ALL] :
		BEGIN

    		EXTERNAL ROUTINE 
    		    LIB$SPAWN,
    		    SYS$WAITFR;

		LOCAL
    		    ALLOCATE_FLAG,
    		    EVNT_FLAG,
    		    FLAGS,
		    NAME_BUFF: REF VECTOR [,BYTE],	! Module name buffer
    		    STATUS;


    		! Before doing anything, check for /NOWAIT flag.
    	        ! The ADVERB_POINTER field indicates whether /NOWAIT 
    	        ! was specified and/or whether /ALLOCATE was specified.
    	        ! The codes are
    	        !   0 - neither /NOWAIT or /ALLOCATE
    	        !   1 - /NOWAIT, not /ALLOCATE
    	        !   2 - not /NOWAIT, /ALLOCATE
    	        !   3 - both were specified
    	        !
    		STATUS = FALSE;
    		IF .VERB_NODE [DBG$L_VERB_ADVERB_PTR]
    		THEN
    		    BEGIN


    		    ! We accomplish SET MODU/NOWAIT by spawning a subprocess
    		    ! with the /NOWAIT flag passed to LIB$SPAWN. The 
    		    ! subprocess can accept DCL commands until the 
    		    ! SET MODU completes. We pass in an event flag number (0)
    		    ! to be set when the subprocess completes.
    		    !
    		    FLAGS = 1;
    		    EVNT_FLAG = 0;
    		    STATUS = LIB$SPAWN(0,0,0,FLAGS,0,0,0,EVNT_FLAG);
    		    IF NOT .STATUS
    		    THEN
    			SIGNAL(DBG$_NOSPAWNI,0,.STATUS);
    		    END;    	

    		! SET MODULE/ALLOCATE was specified if the 2nd bit of
    		! the ADVERB_PTR field is set.
    		!
    		ALLOCATE_FLAG = .VERB_NODE[DBG$L_VERB_ADVERB_PTR]/2;

    		! Loop through the list of modules to set.
    		!
    		IF .verb_node[dbg$b_verb_composite] EQL set_module_all
    		THEN
		    dbg$rst_setmod (0, 0, .allocate_flag)
    		
    		ELSE
       		    WHILE .noun_node NEQA 0
   	 	    DO
		        BEGIN

		        ! Retrieve the name buffer and call the symbol table
		        ! Module names are stored away as counted strings
    		        !
		        name_buff = .noun_node [dbg$l_noun_value];
		        IF NOT dbg$rst_setmod (name_buff [1], .name_buff [0],
    					       .allocate_flag)
		        THEN
			    BEGIN
			    .message_vect = dbg$nmake_arg_vect (dbg$_nosuchmodu,
							    1,
							    name_buff [0]);
			    RETURN sts$k_severe;
			    END;

		        ! Obtain the next noun node
    		        !
		        noun_node = .noun_node [dbg$l_noun_link];
		        END;	! End of Loop
	
    		! Wait for spawned subprocess to complete if there was one.
    		!
    		IF .status
    		THEN
    		    BEGIN
    		    SIGNAL(DBG$_SETMODU);
    		    SYS$WAITFR(.EVNT_FLAG); 
    		    END;
		END;

	    [set_output] :
		BEGIN
		LITERAL
		    NOUN_LITERAL_LOG		= 1,
		    NOUN_LITERAL_NOLOG		= 2,
		    NOUN_LITERAL_SCREEN		= 3,
		    NOUN_LITERAL_NOSCREEN	= 4,
		    NOUN_LITERAL_TERMINAL	= 5,
		    NOUN_LITERAL_NOTERMINAL	= 6,
		    NOUN_LITERAL_VERIFY		= 7,
		    NOUN_LITERAL_NOVERIFY	= 8;

		! Add the user defined output setting

		WHILE TRUE DO
		    BEGIN
		    CASE .NOUN_NODE[DBG$L_NOUN_VALUE] FROM NOUN_LITERAL_LOG
						TO NOUN_LITERAL_NOVERIFY OF
		        SET

		        [NOUN_LITERAL_LOG] :
		 	    BEGIN
			    LOCAL
				STATUS,
				B_TYPE;

			    STATUS = DBG$NSETUP_LOG (B_TYPE);
			    IF NOT .STATUS
			    THEN
				OUTPUT_RMS_ERROR (.B_TYPE);

			    DBG$GB_DEF_OUT [OUT_LOG] = TRUE;
			    IF .DBG$GB_DEF_OUT[OUT_SCREEN]
			    THEN
				DBG$GL_SCREEN_LOG = TRUE;

			    END;

			[NOUN_LITERAL_NOLOG] :
			    BEGIN
			    IF NOT .DBG$GB_DEF_OUT [OUT_TERM]
			    THEN
				DBG$NOUT_INFO (DBG$_OUTPUTLOST);

			    DBG$GB_DEF_OUT [OUT_LOG] = FALSE;
			    DBG$GL_SCREEN_LOG = FALSE;
			    END;

			[NOUN_LITERAL_SCREEN]:
			    BEGIN
			    DBG$GB_DEF_OUT[OUT_SCREEN] = TRUE;
			    IF .DBG$GB_DEF_OUT[OUT_LOG]
			    THEN
				DBG$GL_SCREEN_LOG = TRUE;

			    END;

			[NOUN_LITERAL_NOSCREEN]:
			    BEGIN
			    DBG$GB_DEF_OUT[OUT_SCREEN] = FALSE;
			    DBG$GL_SCREEN_LOG = FALSE;
			    END;

			[NOUN_LITERAL_TERMINAL] :
			    BEGIN
			    DBG$GB_DEF_OUT [OUT_TERM] = TRUE;
			    END;

			[NOUN_LITERAL_NOTERMINAL] :
			    BEGIN
			    IF NOT .DBG$GB_DEF_OUT [OUT_LOG]
			    THEN
				DBG$NOUT_INFO (DBG$_OUTPUTLOST);

			    DBG$GB_DEF_OUT [OUT_TERM] = FALSE;
			    END;

			[NOUN_LITERAL_VERIFY] :
			    DBG$GB_DEF_OUT [OUT_VERIFY] = TRUE;

			[NOUN_LITERAL_NOVERIFY] :
			    DBG$GB_DEF_OUT [OUT_VERIFY] = FALSE;

			TES;

		    ! Check for another object
		    !
		    IF .NOUN_NODE [DBG$L_NOUN_LINK] EQLA 0
		    THEN
		        EXITLOOP;

		    ! Update the noun node
		    !
		    NOUN_NODE = .NOUN_NODE [DBG$L_NOUN_LINK];

		    END;		! End of loop over OUTPUT parameters

		END;


	    ! Execute the SET RADIX command.
	    !
	    [SET_RADIX, SET_RADIX_OVERRIDE] :
		BEGIN
    		LOCAL
    		    RADIX;

		! Fill in the correct radix value.
		!
		CASE .NOUN_NODE [DBG$L_NOUN_VALUE]
				FROM MODE_LOWEST TO MODE_HIGHEST OF
		    SET

		    [MODE_BINARY]  : RADIX = DBG$K_BINARY;

		    [MODE_OCTAL]   : RADIX = DBG$K_OCTAL;

		    [MODE_DECIMAL] : RADIX = DBG$K_DECIMAL;

    		    [MODE_DEFAULT] : RADIX = DBG$K_DEFAULT;

		    [MODE_HEX]     : RADIX = DBG$K_HEX;

		    [INRANGE, OUTRANGE]:
    			$DBG_ERROR('DBGNSET\DBG$NEXECUTE_SET unexpected radix');

		    TES;

    		! The VALUE2 field contains:
    		!	0 if no /INPUT or /OUTPUT was specified (in this
    		!	  case we set both radices)
    		!	1 if /INPUT was specified
    		!	2 if /OUTPUT was specified
    		! The VERB_COMPOSITE field tells us whether /OVERRIDE was
    		! specified.
    		! We use these pieces of information to tell us which
    		! of the three elements of the DBG$GB_RADIX byte vector to
    		! fill in.
    		!
    		IF .VERB_NODE[DBG$B_VERB_COMPOSITE] EQL SET_RADIX
    		THEN
    		    BEGIN
    		    IF .RADIX EQL DBG$K_DEFAULT
    		    THEN
    			RADIX = DBG$NGET_TRANS_RADIX(.RADIX);

    		    IF .NOUN_NODE[DBG$L_NOUN_VALUE2] LEQ 1
    		    THEN
    			DBG$GB_RADIX[DBG$B_RADIX_INPUT] = .RADIX;

    		    IF NOT .NOUN_NODE[DBG$L_NOUN_VALUE2]
    		    THEN
    			DBG$GB_RADIX[DBG$B_RADIX_OUTPUT] = .RADIX;

    		    END

    		ELSE IF .VERB_NODE[DBG$B_VERB_COMPOSITE] EQL SET_RADIX_OVERRIDE
    		THEN
    		    DBG$GB_RADIX[DBG$B_RADIX_OUTPUT_OVER] = .RADIX

    		ELSE
    		    $DBG_ERROR('DBGNSET\DBG$NEXECUTE_SET');

		END;			! End of SET RADIX command


	    [set_scope] :
		BEGIN
		LOCAL
		    SCOPE_LIST : REF VECTOR [,LONG],
		    BAD_SCOPE,
		    ERR_INDEX;

		! Recover the scope vector
    		!
		scope_list = .noun_node [dbg$l_noun_value];

		! Set the scopes. 1 was filled into the adverb field if
    		! SET SCOPE/MODULE was specified; 0 otherwise.
    		!
		dbg$rst_setscope (.scope_list, err_index,
    				  .verb_node[dbg$l_verb_adverb_ptr]);

		! Check for an error
    		!
		IF .err_index NEQ 0
		THEN
		    BEGIN

		    ! Translate the bad scope to a counted string
    		    !
		    dbg$npathdesc_to_cs (.scope_list [.err_index], bad_scope);

		    ! Format an error message
    		    !
		    .message_vect = dbg$nmake_arg_vect (dbg$_badscope, 1, .bad_scope);

		    RETURN sts$k_severe;
		    END;
		END;

    	    [set_search] :
    		BEGIN

    	        LITERAL
    		    noun_literal_all = 1,
    		    noun_literal_next = 2,
    		    noun_literal_string = 3,
    		    noun_literal_ident = 4;

    		! First set the search structure to the user defined level
    		!
    		dbg$set_search_lvl (user_def_search);

    		! Add the new user defined settings. Remember the first noun
    		! node has already been recovered.
    		!
    		WHILE TRUE DO
    		    BEGIN
    		    
    		    CASE .noun_node [dbg$l_noun_value] FROM noun_literal_all
    						       TO   noun_literal_ident
    			OF SET

    			[noun_literal_all] : ! SET SEARCH ALL
    			    BEGIN
    			    dbg$gb_search_ptr[search_all] = TRUE;
    			    END;

    			[noun_literal_next] : ! SET SEARCH NEXT
    			    BEGIN
    			    dbg$gb_search_ptr[search_all] = FALSE;
    			    END;

    			[noun_literal_ident] : ! SET SEARCH IDENT
    			    BEGIN
    			    dbg$gb_search_ptr[search_ident] = TRUE;
    			    END;

    			[noun_literal_string] : ! SET SEARCH STRING
    			    BEGIN
    			    dbg$gb_search_ptr[search_ident] = FALSE;
    			    END;

    			TES;

    		    ! Now check for another switch. If none, exit the loop.
    		    !
    		    IF .noun_node [dbg$l_noun_link] EQL 0
    		    THEN
    			EXITLOOP;

    		    ! Update the noun node to the next object
    		    !
    		    noun_node = .noun_node [dbg$l_noun_link];

    		    END;	! End of loop
    	
    		END;

    	    [set_source] :		! Set source directory search list
    		BEGIN

    		dbg$src_set_source(
    		    .noun_node[dbg$l_adjective_ptr],
    		    .noun_node[dbg$l_noun_value]);

    		END;


	    [set_step] :		! Set step values
		BEGIN
		RETURN DBG$EVENT_SEMANTICS (.VERB_NODE, .MESSAGE_VECT);
		END;


    	    ! Execute the SET TASK command.
    	    !
    	    [SET_TASK]:
    		DBG$NEXECUTE_SET_TASK(.VERB_NODE);


	    ! Execute the SET TERMINAL command.
	    !
	    [SET_TERMINAL]:
		DBG$SCR_EXECUTE_SETTERM_CMD(.VERB_NODE);


    	    ! Execute the SET TRACE command.
    	    !
	    [SET_TRACE]:
		DBG$EVENT_SEMANTICS(.VERB_NODE, .MESSAGE_VECT);


	    [set_type] :
		BEGIN
		LOCAL
		    LENGTH_NODE : REF dbg$noun_node;

		! We always have a second noun node (containing the length).
    		!
		length_node = .noun_node [dbg$l_noun_link];

		dbg$gl_dflttyp = .noun_node [dbg$l_noun_value];
		dbg$gw_dfltleng = .length_node [dbg$l_noun_value];
		END;

	    [set_type_override] :
		BEGIN
		LOCAL
		    LENGTH_NODE : REF dbg$noun_node;

		! We always have a second noun node (containing the length).
    		!
		length_node = .noun_node [dbg$l_noun_link];

		dbg$gl_gbltyp = .noun_node [dbg$l_noun_value];
		dbg$gw_gbllngth = .length_node [dbg$l_noun_value];
		END;


    	    ! Execute the SET WATCH command.
    	    !
	    [set_watch]: 
		DBG$EVENT_SEMANTICS (.VERB_NODE, .MESSAGE_VECT);


	    ! Execute the SET WINDOW command.
	    !
	    [SET_WINDOW]:
		DBG$SCR_EXECUTE_SETWIND_CMD(.VERB_NODE);


	    ! Any other command CASE index should never occur.  Hence we signal
	    ! an internal DEBUG error in this case.
	    !
	    [INRANGE, OUTRANGE]:
		$DBG_ERROR('DBGNSET\NEXECUTE_SET');

	    TES;


    ! The command has successfully been executed.  Now return.
    !
    RETURN STS$K_SUCCESS;

    END;

GLOBAL ROUTINE DBG$NSET_LOG  (MESSAGE_VECT) =
!++
! FUNCTIONAL DESCRIPTION:
!	This routine closes any log file that is currently open and opens
! the file specified by the user in SET LOG "filespec"
!
! FORMAL PARAMETERS:
!	
!	message_vect	- The address of a longword to contain the address of a
!			  message argument vector
!
! IMPLICIT INPUTS:
!	The RMS-set IFI (internal file identifier field) bit is used to
! determine if a previous log file is still open.
!
!	dbg$gl_log_buf _ 	pointer to log filespec buffer
!
! IMPLICIT OUTPUTS:
!	none
!
! ROUTINE VALUE:
!
!	sts$k_severe (4) -	the log could not be set to the specified filespec
!
!	sts$k_success (1) -	the log file was set to the user specified filespec
!
! SIDE EFFECTS:
!	Any previously open log file is closed and a new log file is opened.
! Logging is inhibited for the duration of this routine.
!--

	BEGIN
	
	LOCAL
		STATUS,
		OPENED_LOG,
		FNS : BYTE,
		FNA,
		OLD_NAM_PTR,
		B_TYPE,
		TEMP_NAM : REF $NAM_DECL,
		TEMP_FSE : REF VECTOR [,BYTE],
		TEMP_FSR : REF VECTOR [,BYTE],
		LOG_TEMP : BYTE;
	
	opened_log = FALSE ;

	! inhibit logging until we can redirect the log file

	log_temp = .dbg$gb_def_out [out_log];
	dbg$gb_def_out [out_log] = FALSE;

	! see if a log file has been previously opened. If so, close it,
	! since it must be CLOSEd befor we can do the new $PARSE.

	IF .dbg$gl_logfab [fab$w_ifi] NEQ 0
	THEN
		BEGIN

		opened_log = TRUE;
		fna = .dbg$gl_logfab [fab$l_fna];
		fns = .dbg$gl_logfab [fab$b_fns];

		status = $CLOSE (FAB = dbg$gl_logfab);
		IF NOT .status
		THEN
			BEGIN

			LOCAL
				MSG_DESC : REF dbg$stg_desc;

    			msg_desc = dbg$get_tempmem(2);
			build_error_desc (msg_desc);
			.message_vect = dbg$nmake_arg_vect
						 (shr$_closeout+dbg_fac_code, 
						  1, .msg_desc,
			       			  .dbg$gl_logfab[fab$l_sts],
						  .dbg$gl_logfab[fab$l_stv]); 

			RETURN sts$k_severe;

			END;

		! get new NAM block, preserve the original

		temp_nam = dbg$get_memory ((nam$c_bln+3) / %UPVAL);
		$nam_init (nam = .temp_nam);
		temp_fse = dbg$get_memory ((nam$c_maxrss+3)/%UPVAL);
		temp_fsr = dbg$get_memory ((nam$c_maxrss+3)/%UPVAL);
		temp_nam [nam$l_esa] = .temp_fse;
		temp_nam [nam$l_rsa] = .temp_fsr;
		temp_nam [nam$b_ess] = nam$c_maxrss;
		temp_nam [nam$b_rss] = nam$c_maxrss;
		dbg$gl_logfab [fab$l_nam] = .temp_nam;
		old_nam_ptr = .dbg$gl_lognam;
		dbg$gl_lognam = .temp_nam;

		END;

	! reset the appropriate FAB file process options

	dbg$gl_logfab [fab$v_cif] = 0;
	dbg$gl_logfab [fab$v_mxv] = 1;
	dbg$gl_logfab [fab$v_nam] = 0;

	! Set up file name

	IF .dbg$gl_log_buf NEQ 0
	THEN
		BEGIN

		MAP
		    DBG$GL_LOG_BUF : REF VECTOR [,BYTE];

		dbg$gl_logfab [fab$l_fna] = .dbg$gl_log_buf + 1; ! filename addr starts in 2nd byte
		dbg$gl_logfab [fab$b_fns] = .dbg$gl_log_buf [0];  ! 1st byte is count

		! Parse the filespec to see if an explicit version number was
		! given. If so set the CIF bit, otherwise we must maximize
		! the version number.

		status = $PARSE (FAB = dbg$gl_logfab);
		IF NOT .status
		THEN
			BEGIN
			LOCAL
				STS,
				STV,
				MSG_DESC : REF dbg$stg_desc;

    			msg_desc = dbg$get_tempmem (2);

			! save these because restore_nam will reset them

			sts = .dbg$gl_logfab [fab$l_sts];
			stv = .dbg$gl_logfab [fab$l_stv];
			build_error_desc (msg_desc);

			IF .opened_log
			THEN
				restore_nam 
			ELSE
				BEGIN
				dbg$gl_logfab [fab$l_fna] = 0;
				dbg$gl_logfab [fab$b_fns] = 0;
				dbg$gl_log_buf	= 0;
				END;

			.message_vect = dbg$nmake_arg_vect
					 (shr$_syntax + dbg_fac_code,
					  1, .msg_desc, .sts, .stv);

			RETURN sts$k_severe;

			END;

		IF .dbg$gl_lognam [nam$v_exp_ver]
		THEN
			BEGIN
			dbg$gl_logfab [fab$v_cif] = 1;
			dbg$gl_logfab [fab$v_mxv] = 0;
			END;

		dbg$gl_logfab [fab$v_nam] = 1;		! open by NAM block since
		END;					! we've already parsed the filespec

	! now open the new log file

	status = dbg$nsetup_log (b_type);
	IF NOT .status
	THEN
		BEGIN
		LOCAL 
			MSG_DESC : REF dbg$stg_desc,
			STS,
			STV;

    		msg_desc = dbg$get_tempmem (2);
		build_error_desc (msg_desc);
		IF .b_type EQL 1
		THEN
			BEGIN
			sts = .dbg$gl_logfab [fab$l_sts];
			stv = .dbg$gl_logfab [fab$l_stv];
			END
		ELSE
			BEGIN
			sts = .dbg$gl_lograb [rab$l_sts];
			stv = .dbg$gl_lograb [rab$l_stv];
			END;

		IF .opened_log
		THEN
			restore_nam 
		ELSE
			BEGIN
			dbg$gl_logfab [fab$l_fna] = 0;
			dbg$gl_logfab [fab$b_fns] = 0;
			dbg$gl_log_buf	= 0;
			dbg$gl_logfab [fab$v_nam] = 0;
			END;

		.message_vect = dbg$nmake_arg_vect
				 (shr$_openout+dbg_fac_code, 3,
				 .msg_desc, .sts, .stv);

		RETURN sts$k_severe;

		END;

	! restore logging status and free temp storage

	dbg$gb_def_out [out_log] = .log_temp;		
	IF .opened_log
	THEN
	
		! Cleanup the "original" NAM block

		BEGIN
    		dbg$rel_memory (.old_nam_ptr);
		dbg$rel_memory (.dbg$gb_logfse);
		dbg$rel_memory (.dbg$gb_logfsr);

		dbg$gb_logfsr = .temp_fsr;
		dbg$gb_logfse = .temp_fse;

		! Release the buffer that holds the log file spec. Since this
		! is a counted string we have to adjust the address to free

		IF .fns NEQ 0
		THEN
    		    dbg$rel_memory (.fna-1);
		END;

	RETURN sts$k_success;

	END;

ROUTINE DBG$NSETUP_LOG (BLOCK_TYPE)  =
!++
! FUNCTIONAL DESCRIPTION:
!	This routine creates and opens the log file.
!
! FORMAL PARAMETERS:
!
!	block_type - indicates whether error to report is for 
!		     FAB ( = 1) or RAB ( = 2)
!
! IMPLICIT INPUTS:
!
!	dbg$gl_log_buf - 	pointer to log filespec buffer
!
! IMPLICIT OUTPUTS:
!	The resultant LOG file-spec as resolved by RMS
!
! ROUTINE VALUE:
!	Returns the RMS status code if there's an error, otherwise returns TRUE
!
! SIDE EFFECTS:
!	The log file is created and a RAB connected to it.
!--

	BEGIN
	
	LOCAL 
		STATUS;
	MAP
		DBG$GL_LOG_BUF : REF VECTOR [,BYTE];

	! See if a log file is already open

	IF .dbg$gl_logfab [fab$w_ifi] NEQ 0
	THEN
		RETURN sts$k_success;

	.block_type = 1;
	status = $CREATE(FAB = dbg$gl_logfab);

	IF NOT .status
	THEN
		RETURN (.status) ;

	dbg$gl_lograb [rab$l_fab] = dbg$gl_logfab;
	.block_type = 2;
	status = $CONNECT (RAB = dbg$gl_lograb);

	IF NOT .status
	THEN
		RETURN (.status) ;


	! Eventually put out the title line here

	RETURN true;

	END;		! END OF DBG$NSET_UP_LOG

ROUTINE DUMMY(X): NOVALUE =
!
! FUNCTION
!	This is a do-nothing routine that is called from within DBG$NPARSE_SET
!	in order to foil an incorrect BLISS compiler optimization.
!
    BEGIN
    0
    END;
END				! End of module
ELUDOM
