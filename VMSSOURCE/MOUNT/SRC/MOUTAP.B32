MODULE MOUTAP (
		LANGUAGE (BLISS32),
		IDENT = 'V04-000'
		) =
BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
!
! FACILITY:  MOUNT Utility
!
! ABSTRACT:
!
!	These routines handle the mounting of magnetic tape
!
! ENVIRONMENT:
!
!	VAX/VMS operating system, including privileged system services
!	and internal exec routines.
!
!--
!
!
! AUTHOR:  D. H. Gillespie,	 CREATION DATE:  05-Dec-1977  
!
! MODIFIED BY:
!
!	V03-021	HH0046		Hai Huang		10-Aug-1984
!		Increment refcount stored in UCB on mount.
!
!	V03-020	HH0041		Hai Huang		24-Jul-1984
!		Remove REQUIRE 'LIBD$:[VMSLIB.OBJ]MOUNTMSG.B32'.
!
!	V03-019	HH0035		Hai Huang		10-Jul-1984
!		Fix truncation errors.
!
!	V03-018	MMD0290		Meg Dumont,	10-Apr-1984  14:41
!		Fix to the return from $MTACCESS code were ACCESS could
!		be set to normal processing with out processing all the
!		possible error conditions.
!
!	V03-017	LMP0221		L. Mark Pilant,		28-Mar-1984  10:03
!		Change UCB$L_OWNUIC to ORB$L_OWNER and UCB$W_VPROT to
!		ORB$W_PROT.
!
!	V03-016	MMD0270		Meg Dumont,	23-Mar-1984  9:29
!		Change the processing of the accessibility character fields
!		in the VOL1 and or HDR1 label to call the installation
!		specific accessibility routine. The return from this
!		routine determines the users access to the volume and/or file.
!		This support includes saving the ANSI version number from the
!		VOL1 for future processing of the file header accessibility 
!		field.
!
!	V03-015 HH0002		Hai Huang	01-Feb-1984
!		Add job-wide mount support, i.e. always deallocate
!		mount list entry to paged-pool in condition handler.
!
!	V03-014 HH0001		Hai Huang	16-Jan-1984  14:52
!		Fix bug in privilege check code.
!
!	V03-013	MMD0215		Meg Dumont,	3-Jan-1984  16:04
!		Fix bug in protection check code.
!
!	V03-012	MMD0199		Meg Dumont,	25-Aug-1983  10:12
!		Fix bug where if /PROTECTION is specified SYSTEM and
!		OWNER are not given access to the tape. SYSTEM and
!		OWNER should always have access to mounted tapes.
!
!	V03-011	MMD0186		Meg Dumont,	7-Jul-1983  9:59
!		Make the default for AVL/AVR the same from the DCL call
!		and from the system service call.
!		
!
!	V03-010	DMW4042		DMWalp			 7-Jun-1983
!		Remove (S)LOG_ENTRY
!
!	V03-009	MMD0179		Meg Dumont,	26-May-1983  15:15
!		Change VOL1 to indicate ANSI level 4 when writing a SYSTEM CODE
!		in the VOL1 label
!
!	V03-008	MMD0136		Meg Dumont,	12-Apr-1983  17:29
!		Added support for writng and interrupting the VOL1
!		OWNER IDENTIFIER field, so that it is no longer
!		treated as a VMS field, strictly. Added support for
!		the underscore as a valid character to tape.
!
!
!	V03-007	MMD0113		Meg Dumont,	29-Mar-1983  0:27
!		Added support for setting AVR, AVL. Added support for new VMS 
!		protection on tape, which includes understanding a VOL2
!		label. Also reformated so that routines common to INIT,
!		MOUNT and the MTAACP could all be shared.
!
!	V03-006	MMD0105		Meg Dumont,	17-Feb-1983  13:25
!		Changed call to CLEAR_VALID to issue a IO$_AVAILABLE
!
!	V03-005	MMD0002		Meg Dumont,	3-Jan-1983  14:50
!		Allow user with read access to tape to mount it writelocked.
!
!	V03-004	MMD0001		Meg Dumont,	13-Aug-1982  13:07
!		Change from call to SET_VALID to QIO IO$_PACKACK
!
!	V03-003 STJ0302		Steven T. Jeffreys,	18-May-1982
!		Add support for /NOUNLOAD qualifier.
!
!	V03-002	STJ0261		Steven T. Jeffreys,	22-Apr-1982
!		Do not mung device allocation access mode.
!		Set the DEADMO bit properly for multi-volume mounts.
!
!	V03-001	STJ0255		Steven T. Jeffreys,	04-Apr-1982
!		Use common I/O routines where possible.
!
!	V02-022	STJ0154		Steven T. Jeffreys,	02-Jan-1981
!		Fix external references to use general addressing mode.
!
!	V02-021 DMW0018		David Michael Walp	17-Dec-1981
!		Increase the size of the translation table to 256
!
!	V02-020 DMW0017		David Michael Walp	 3-Dec-1981
!		Return non-ANSI characters as space and	fix edit cut
!		and paste error ( wrong index )
!
!	V02-019 DMW0016		David Michael Walp	15-Sep-1981
!		Uppercase and set NOT Unused the MVL entries.
!
!	V02-018	STJ0121		Steven T. Jeffreys	10-Sep-1981
!		Make descriptor references use symbolic offsets.!	
!		Checked in a new source.
!
!	V02-017 DMW0015		David Michael Walp	18-Jul-1981
!		Upcase Volume labels, Added 1st Reel Volume Protection
!		and UIC, handles BAD UICs in VOL1
!
!	V02-016 DMW0012		David Michael Walp	30-Jul-1981
!		Store need privilege mask in MVL
!
!	V02-015 DMW0011		David Michael Walp	22-Jul-1981
!		Detect write ring.  Prompted by SPR
!
!	V02-014 DMW0010		David Michael Walp	20-Jul-1981
!		Reset the blocksize when the density is reset.
!
!	V02-013 DMW0009		David Michael Walp	6-Jul-1981
!		Clean up defaulting of density.
!
!	V02-012 DMW0006		David Michael Walp	10-Jun-1981
!		Major rewrite of MOUNT_TAPE code to allow operator assist
!		to work.  The loop that was in MOUNT_TAPE to ALLOCATE and
!		ASSIGN devices is now in the MOUNT_VOLUME.  READ_VOLLABEL
!		and MOUNT_TAPE may now be called more than once ( if more
!		then a single device is specified to be used ).
!
!	V02-011 DMW0004		David Michael Walp	11-May-1981
!		Stuffed volume access character in MVL and reguire
!		VOLPRO or UIC ownership to MOUNT/FOR an ANSI tape.
!
!	V02-010 DMW0003		David Michael Walp	27-Apr-1981
!		Made "/FOREIGN" and "/NOLABEL" work the same
!
!	V02-009 DMW0002		David Michael Walp	14-Apr-1981
!		Added V3 volume accesiblity code, cleaned up protection holes,
!		added storage of ANSI volume file set id in MVL.
!
!	V02-008	RLR36704		Robert L. Rappaport	2-April-1981
!		Correct the problem of MOUNT returning SS$_VOLINV when
!		the MOUNT command follows a DISMOUNT/NOUNLOAD sequence
!		in a command procedure.
!
!	V02-006	ACG0169		Andrew C. Goldstein,	18-Apr-1980  14:02
!		Bug check on internal errors
!
!	V02-005	ACG0167		Andrew C. Goldstein,	18-Apr-1980  13:38
!		Previous revision history moved to MOUNT.REV
!**

LIBRARY 'SYS$LIBRARY:LIB.L32';
REQUIRE 'SRC$:MOUDEF.B32';

FORWARD ROUTINE
	ERROR_HANDLER,				! handler to clear valid on
						!  secondary UCB's
	KERNEL_HANDLER	: NOVALUE,		! kernel mode exception handler
	MAKE_TAPE_MOUNT,			! kernel moude tape mount
	MOUNT_TAPE	: NOVALUE,		! mount magnetic tape
	READ_VOLLABEL,				! read and verify VOL1 label
	RESET_DENSITY	: NOVALUE,		! reset the density default
	SET_CHARACTER   : NOVALUE;		! set device characteristics

EXTERNAL ROUTINE
	ALLOC_LOGNAME,				! allocate logical name
	ALLOCATE_MEM,				! allocate memory
	CHECK_PROT,				! check the UIC protection
	ENTER_LOGNAME,				! enter logical name
	GET_CHANNELUCB,				! get UCB from channel
	GET_RECORD,				! get current record drive is reading
	LIB$CVT_OTB	: ADDRESSING_MODE (GENERAL),
	LOCK_IODB	: ADDRESSING_MODE (GENERAL), ! lock I/O data base
	PROCESS_VOL2_LABEL,			! process VOL2 label
	SEND_ERRLOG,				! send message to error logger
	START_ACP,				! startup ACP
	TAPE_OWN_PROT,				! determine owner and 
						!  protection of tape
	TRAN_LOGNAME,				! translate logical name
	UNLOCK_IODB	: ADDRESSING_MODE (GENERAL); ! unlock I/O database


EXTERNAL
	BLOCKSIZE,				! value of /BLOCKSIZE:
	CHANNEL,				! channel of tape being mounted
	CLEANUP_FLAGS	: BITVECTOR,		! cleanup flags
	CLEANUP_ALLOC	: BITVECTOR,		! cleanup allocation flags
	CTL$GL_VOLUMES	: ADDRESSING_MODE (ABSOLUTE),
	DEVICE_CHAR	: BBLOCK,		! characteristics of device
						!  current being mounted
	DEVICE_INDEX	: LONG VOLATILE,	! index into the device and
						!  label lists
	MOUNT_OPTIONS	: BITVECTOR,		! mount option bits
	LABEL_COUNT,				! number of labels specified
	RECORDSZ,				! value of /RECORD:
	VOL1		: BBLOCK;		! VOL1 label

LITERAL
	PROTO_RVT_LEN	= $BYTEOFFSET (RVT$L_UCBLST) + (4*DEVMAX),
	PROTO_MVL_LEN	= MVL$K_FIXLEN + (MVL$K_LENGTH*LABMAX);
OWN
	ACCESS,					! user's access to magnetic tape
	ANSI_LABEL	: BBLOCK [80],		! buffer to store labels
	BLOCKSZ		: WORD,			! block size for this volume
	FIRST_V_UIC,				! owner UIC of 1st tape
	FIRST_V_PROT,				! 1st tape protection
	IO_STATUS	: VECTOR [4,WORD],	! I/O status block
	LABEL_VER,				! decimal ANSI label version
	PRIVILEGE_MASK	: REF BBLOCK,		! user privileges
	PROCESS_UIC,				! UIC of current process
	PROTO_VCB	: BBLOCK[VCB$C_LENGTH]	! prototype VCB
			   INITIAL ( REP VCB$C_LENGTH OF BYTE (0)),
	PROTO_RVT	: BBLOCK[PROTO_RVT_LEN]	! prototype RVT
			   INITIAL ( REP PROTO_RVT_LEN OF BYTE (0)),
	PROTO_MVL	: BBLOCK[PROTO_MVL_LEN] ! prototype MVL
			   INITIAL ( REP PROTO_MVL_LEN OF BYTE (0)),
	VOLUME_PROT,				! tape protection
	VOLUME_UIC,				! owner UIC of tape
	WRITE_RING	: BITVECTOR [ 1 ];	! are any write rings missing

BIND
	STARID = UPLIT ('DECFILE11A'),

	! UPLIT was used instead of CH$TRANSTABLE here, the code
        !  produced is the same (ie the constant string generated).
        !  UPLIT was used because CH$TRANSTABLE generates a warning error
        !  because more then a single character at a time is specified
        !  in the %ASCII. ( BLISS KLUDGE )
        !
        ! The table will upcase a..z and return space for any non ANSI
        !  'a' characters.
        !
        TRANSLATION_TABLE = UPLIT BYTE (
		%ASCII '                                ',
		%ASCII ' !"  %&''()*+,-./0123456789:;<=>?',
		%ASCII ' ABCDEFGHIJKLMNOPQRSTUVWXYZ    _',
		%ASCII ' ABCDEFGHIJKLMNOPQRSTUVWXYZ     ',
		%ASCII '                                ',
		%ASCII '                                ',
		%ASCII '                                ',
		%ASCII '                                ');

GLOBAL ROUTINE READ_VOLLABEL (VOLUME_LABEL)  =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine reads the first block on the magnetic tape and
!	checks that it is an ANSI tape
!
! CALLING SEQUENCE:
!	READ_VOLLABEL (ARG1)
!
! INPUT PARAMETERS:
!	ARG1 - address of volume label string descriptor
!
! IMPLICIT INPUTS:
!	CHANNEL - channel number assigned to device being mounted
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	VOL1		- VOL1 magnetic tape label
!	VOLUME_UIC	- owner of tape
!	VOLUME_PROT	- tape protection
!
! ROUTINE VALUE:
!	SS$_NORMAL	- if valid ANSI volume label
!	SS$_NOTLABELMT	- not labeled ANSI magnetic tape
!	SS$_INCVOLLABEL - incorrect volume label
!	SS$_DEVOFFLINE	- device not on system
!	SS$_MEDOFL	- medium off_line
!
! SIDE EFFECTS:
!	NONE
!
! USER ERRORS:
!	NONE
!
!--

BEGIN

EXTERNAL
	CTL$GL_PHD	: REF BBLOCK ADDRESSING_MODE(ABSOLUTE);

MAP
	VOLUME_LABEL	: REF BBLOCK;	! volume label ( from command line )
					!   string desc 

LOCAL
    CURRENT_RECORD,			! Current record the tape drive is reading
    UCB	: REF BBLOCK,			! Address of ucb
    UPCASE_INPUT    : VECTOR [ VL1$S_VOLLBL, BYTE ],
    UPCASE_TAPE	    : VECTOR [ VL1$S_VOLLBL, BYTE ],    
    TAPE_OWNER_STS,
    STATUS,
    VMS_TAPE;				! Set if VMS created tape

BIND
    SECONDS	    = UPLIT (-10000000,-1);	! one second in 100 nsec units

! Enable handler to clear valid on all but current device
!
ENABLE ERROR_HANDLER;
!
! The following is here for historical reasons only
!******************************************************************************
! Here we have inserted two extra QIO's (IO$_REWIND) which apparently are not
!  needed but which in fact are here to take care of an anomaly that
!  sometimes occurs when the MOUNT command appears in a command file
!  immediately following a DISMOUNT/NOUNLOAD command.
!
!  Under certain circumstances the MOUNT fails with a SS$_VOLINV status.
!  The problem is due to a complicated interaction involving QIO dispatching
!  logic, the MAGTAPE ACP, and the MOUNT command.  What occurs is the
!  following.
!
!  DISMOUNT, before finishing issues a $QIOW with an I/O function code of
!  IO$_ACPCONTROL!IO$M_DMOUNT.  This request is forwarded to the ACP and
!  DISMOUNT then has its image rundown.
!
!  The ACP then issues a $QIOW with a function code of IO$_REWIND!IO$M_NOWAIT,
!  while in parallel, MOUNT is starting up and it proceeds to set the
!  UCB$M_VALID bit in UCB$W_STS (which in this case was still on due to the
!  volume previously having been mounted) and then MOUNT issues its own
!  $QIOW with an IO$_REWIND funciton code.
!
!  In some instances, the ACP's REWIND QIO does not get as far as REQCOM
!  until after MOUNT's REWIND has been queued.  If this occurs, INIT's
!  queued REWIND is started up before the ACP actually regains control and
!  the driver has no trouble since it finds the UCB$M_VALID bit still on.
!  Unfortunately, as soon as the ACP regains control, following the
!  driver's WFIKPCH, the ACP clears the UCB$M_VALID bit.  The next QIO
!  issued by MOUNT will fail due to the absence of the UCB$M_VALID
!  bit.
!
!  The solution (pronounced KLUDGE) herein implemented, simply inserts an extra
!  couple of $QIOW's with IO$_REWIND function code, preceeded by explicit
!  settings of the UCB$M_VALID bit, before the real logic of MOUNT begins.
!  These $QIOW's allow the above potential interaction to occur, and after they
!  have finished, we again set the UCB$M_VALID bit on in the normal way.
!******************************************************************************
! 
! The above is no longer true; that is we have elimentated the race condition
! mentioned above by not doing issuing the rewind at dismount time
! but infact marking the drive available. The following IO's mark
! the volume valid then issue the rewind, which is neccesary because
! of the preMSCP drivers will not rewind on this function. The MSCP drivers
! will and the second IO here becomes an NOP.
!
!

STATUS = DO_IO(
	CHAN = .CHANNEL,
	FUNC = IO$_PACKACK,
	IOSB = IO_STATUS[0]);


STATUS = DO_IO(
	CHAN = .CHANNEL,
	FUNC = IO$_REWIND,
	IOSB = IO_STATUS[0]);


! some things which need to be set up only the first time thru

IF .DEVICE_INDEX EQL 0
THEN
    BEGIN

    ! Assume that the user is correct on the command line about write ring
    !	status

    WRITE_RING [ 0 ] = .MOUNT_OPTIONS [ OPT_WRITE ];

    ! get the UIC of the current process

    $GETJPI ( ITMLST = UPLIT( WORD(4), WORD(JPI$_UIC), LONG(PROCESS_UIC,0,0)));

    ! determine user's privilege from process privilege mask

    PRIVILEGE_MASK = CTL$GL_PHD[PHD$Q_PRIVMSK];

    END;

! Set up the device characteristics.  This can be done even if the drive is 
! offline.

SET_CHARACTER ();

! Set up the default volume UIC and volume protection.  Default UIC is the
! current process.  This is done in case this is a non-ANSI tape or more device
! then labels have been specified. Default protection is no world or 
! group access to the tape.

VOLUME_UIC  = .PROCESS_UIC;
VOLUME_PROT = 0;

! If there are more devices then labels specified then exit here because we
! can not check a label if we do not know it.  This does not matter if it is
! the first time thru because the label must be specified or /OVER=ID used
! ( in which case we will return the label )

IF    (.DEVICE_INDEX NEQ 0)
  AND (.DEVICE_INDEX GEQ .LABEL_COUNT)
  AND NOT ( .MOUNT_OPTIONS [ OPT_FOREIGN ] OR .MOUNT_OPTIONS [ OPT_NOLABEL ] )
THEN RETURN SS$_NORMAL;

! Position tape to BOT and check status
! wait 10 seconds before deciding that the device is offline

INCRU J FROM 0 TO 9 DO
    BEGIN
	STATUS = DO_IO(
		CHAN = .CHANNEL,
		FUNC = IO$_PACKACK,
		IOSB = IO_STATUS[0]);
    STATUS = DO_IO (	CHAN = .CHANNEL,
			FUNC = IO$_REWIND,
			IOSB = IO_STATUS);
    IF .STATUS THEN STATUS = .IO_STATUS[0];
    IF .STATUS NEQ SS$_MEDOFL AND .STATUS NEQ SS$_VOLINV THEN EXITLOOP;
    IF $SETIMR (REQIDT = 999, DAYTIM = SECONDS, EFN = TIMER_EFN)
    THEN
	BEGIN
	$WAITFR (EFN = TIMER_EFN);
	$CANTIM (REQIDT = 999);
	$SETEF  (EFN = TIMER_EFN);
	END;
    END;

! All errors other than device not in system or medium off line reported 
!  to user

IF NOT .STATUS THEN ERR_EXIT (.STATUS);

! Test to see if the write ring is really there, only if we think it should
! be there.

IF .WRITE_RING [ 0 ]
THEN
    BEGIN

    ! allow us to get at the information nicely

    BIND DEVICE_DEPENDENT = IO_STATUS [ 2 ] : BBLOCK;
    
    STATUS = DO_IO (CHAN = .CHANNEL,
		    IOSB = IO_STATUS,
		    FUNC = IO$_SENSEMODE);
    IF .STATUS THEN STATUS = .IO_STATUS[0];
    IF NOT .STATUS THEN ERR_EXIT (.STATUS);

    ! NOTE: assignment done only if we think a write ring should be there

    WRITE_RING [ 0 ] = NOT (.DEVICE_DEPENDENT [ MT$V_HWL ]);

    END;

! Do not read the tape if /FORIEGN and /OVER=(ACC,EXP), VOLPRO and OPER
! This allows the operator to initialize blank tapes.
!  ( run away tape condition with brand new tapes )
! Please note that this really is a hack to allow operators to get around the
! fact that some hardware can not deal with blank tapes. This should
! not be the defacto for initializing tapes.

IF   .PRIVILEGE_MASK [ PRV$V_VOLPRO ]
  AND .PRIVILEGE_MASK [ PRV$V_OPER ]
  AND ( .MOUNT_OPTIONS [ OPT_FOREIGN ] OR .MOUNT_OPTIONS [ OPT_NOLABEL ] )
  AND .MOUNT_OPTIONS [ OPT_OVR_ACC ]
  AND .MOUNT_OPTIONS [ OPT_OVR_EXP ]
THEN RETURN SS$_NORMAL;

! Read first block on tape and check status

STATUS = DO_IO (CHAN = .CHANNEL,
		FUNC = IO$_READLBLK,
		IOSB = IO_STATUS,
		P1 = VOL1,
		P2 = 80);
IF .STATUS THEN STATUS = .IO_STATUS[0];

! If first record is TM then not ANSI tape
! If label is more than 80 characters ignore error

IF (NOT .STATUS) AND (.STATUS NEQ SS$_DATAOVERUN)
THEN
    BEGIN
    RESET_DENSITY ();
    RETURN SS$_NOTLABELMT;
    END;

! Now check that first block is VOL1 ANSI label 

IF .VOL1[VL1$L_VL1LID] NEQ 'VOL1'
THEN
    BEGIN
    RESET_DENSITY ();
    RETURN SS$_NOTLABELMT;
    END;

! determine owner and VMS protection of tape

TAPE_OWNER_STS = TAPE_OWN_PROT (VOLUME_UIC, VOLUME_PROT, .PROCESS_UIC, VOL1);

! Get the ANSI version from the label and subtract the character 0 to
! make it a decimal value rather than ASCII. Use the channel to get the
! physical UCB.

LABEL_VER = .VOL1[VL1$B_LBLSTDVER] - '0';
UCB = KERNEL_CALL(GET_CHANNELUCB, .CHANNEL);

! Call the accessibility system service to check the accessibility char
! on the VOL1 label.
! First keep the record that the UCB is reading. The accessibility 
! routine can not move the tape from under us! Thus we will compare
! this to the field after the call and if the tape was moved we punt
! the operation. Grant the user access to the volume according to
! the error code returned from the system service.

CURRENT_RECORD = KERNEL_CALL(GET_RECORD, .UCB);
ACCESS = $MTACCESS(LBLNAM = VOL1,
		 UIC = .PROCESS_UIC,
		 STD_VERSION = .LABEL_VER,
		 ACCESS_CHAR = 0,
		 ACCESS_SPEC = MTA$K_NOCHAR,
		 TYPE = MTA$K_INVOL1);
STATUS = KERNEL_CALL(GET_RECORD, .UCB);
IF .CURRENT_RECORD NEQ .STATUS
   THEN ERR_EXIT(SS$_TAPEPOSLOST);

! Now check the ACCESS returned from the service. For SS$_FILACCERR
! check to make sure /OVERRIDE=ACCESS was specified and the user
! has privilege then set to check VMS protection. 
! For SS$_NOFILACC, SS$_NOVOLACC return the code
! to the user. In this case the user has no access to the tape volume.
! For a 0 give the user all access. For SS$_NORMAL check the VMS
! protection.

IF .ACCESS EQL SS$_NOVOLACC
   OR .ACCESS EQL SS$_NOFILACC
	THEN ERR_EXIT(.ACCESS);

IF .ACCESS EQL SS$_FILACCERR
   THEN
	BEGIN
	   IF NOT .MOUNT_OPTIONS[OPT_OVR_ACC]
		THEN ERR_EXIT(.ACCESS);
	   IF NOT .PRIVILEGE_MASK[PRV$V_VOLPRO]
		THEN ERR_EXIT(.ACCESS);
	   ACCESS = SS$_NORMAL;
	END;


! If ACCESS is 0 then the user has full access to the tape regardless 
! of the VMS protection specified

IF NOT .ACCESS THEN VOLUME_PROT = 0;

! If tape was created by VMS then the system code should match that
! of VMS. If the system code does not then do not process the VOL2 
! label

IF CH$EQL(10,STARID,10,VOL1[VL1$T_SYSCODE],0)
   THEN VMS_TAPE = 1
   ELSE VMS_TAPE = 0;

! first record on tape is VOL1.  The next record may be a VOL2
! label if it is then process it otherwise process the HDR1 label. 
! NOTE:  User volume labels may intervene.

WHILE 1 DO
    BEGIN
    STATUS = DO_IO(
	CHAN = .CHANNEL,
	FUNC = IO$_READLBLK,
	IOSB = IO_STATUS[0],
	P1 = ANSI_LABEL,
	P2 = 80);
    IF .STATUS THEN STATUS = .IO_STATUS[0];

    ! ANSI tape, but can't read HDR1

    IF NOT .STATUS AND (.STATUS NEQ SS$_DATAOVERUN) THEN RETURN SS$_NOTLABELMT;

    ! If the SYSCODE was VMS's and there is a VOL2 Label then process it.
    ! After processing the VOL2 label we must check the ACCESS field so that
    ! if the accessibility routine gave the user full access to the volume
    ! then the VMS protection must be set up so that the user has full
    ! access to the volume.

    IF .VMS_TAPE AND .ANSI_LABEL[VL2$L_VL2LID] EQL 'VOL2'
	THEN 
	BEGIN
	   PROCESS_VOL2_LABEL(VOLUME_UIC, VOLUME_PROT, .PROCESS_UIC,
				ANSI_LABEL);
	   IF NOT .ACCESS THEN VOLUME_PROT = 0;
	END;
    IF .ANSI_LABEL[HD1$L_HD1LID] EQL 'HDR1' THEN EXITLOOP;
    END;

! Must have VOLPRO privilege or UIC ownership to mount a ANSI tape /foreign

IF ( .MOUNT_OPTIONS [ OPT_FOREIGN ] OR .MOUNT_OPTIONS [ OPT_NOLABEL ] )
THEN
    BEGIN
    IF (.PRIVILEGE_MASK [ PRV$V_VOLPRO ]) OR (.PROCESS_UIC EQL .VOLUME_UIC)
    THEN
	BEGIN
	RESET_DENSITY ();
	RETURN SS$_NORMAL;
	END
    ELSE RETURN SS$_NOPRIV;
    END;


! If the owner identifier field of the VOL1 label can not allow the user to
! access the tape with out forceing the user to specify /OVERRIDE=OWNER_ID
! and the accessibility routine specified to check VMS protection than
! punt the MOUNT.

    IF NOT .TAPE_OWNER_STS AND NOT .MOUNT_OPTIONS[OPT_OVR_VOLO] AND .ACCESS
	THEN ERR_EXIT (SS$_VOLOERR);

! Now check if the labels match.  First, test the length of the input string

IF .VOLUME_LABEL [DSC$W_LENGTH] GTRU VL1$S_VOLLBL THEN ERR_EXIT (SS$_MTLBLLONG);

! Next translate the labels into uppercase and put in ' ' for any non-ANSI
!  "'a' characters" found.  Pad with space, in case the label from command is
!  less than six characters long.
!
CH$TRANSLATE (TRANSLATION_TABLE, .VOLUME_LABEL[DSC$W_LENGTH], .VOLUME_LABEL[DSC$A_POINTER], ' ',
				 VL1$S_VOLLBL,	   UPCASE_INPUT);
CH$TRANSLATE (TRANSLATION_TABLE, VL1$S_VOLLBL,	   VOL1[VL1$T_VOLLBL], ' ',
				 VL1$S_VOLLBL,	   UPCASE_TAPE);

IF CH$NEQ (VL1$S_VOLLBL, UPCASE_INPUT, VL1$S_VOLLBL, UPCASE_TAPE)
THEN RETURN SS$_INCVOLLABEL;

RETURN SS$_NORMAL;
END;					! end of routine READ_VOLLABEL

ROUTINE SET_CHARACTER : NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine sets the tape drive characteristics.
!
! CALLING SEQUENCE:
!	SET_CHARACTER ();
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	DEVICE_CHAR	- The current device characteristics
!	MOUNT_OPTIONS	- The mount option specified by the user
!	BLOCKSIZE	- value of "/BLOCKSIZE"
!	RECORDSIZE	- value of "/RECORDSIZE"
!	CHANNEL		- the I/O channel of the tape drive
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	IO_STATUS	- set to the return status of the QIO
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
! USER ERRORS:
!	NONE
!
!--

BEGIN

LITERAL
	ODD_PARITY	= 0;

LOCAL
	CHARACTERISTIC	: VECTOR [4,WORD],	! characteristics to set
	STATUS;

BIND
	!  Set up offsets into the characteristics buffer

	FORMAT		= CHARACTERISTIC[2] : BBLOCK,
	PARITY		= CHARACTERISTIC[2] : BBLOCK,
	BUFFER_SIZE	= CHARACTERISTIC[1] : WORD,
	DENSITY		= CHARACTERISTIC[2] : BBLOCK;

!
! Initialize characteristics
!

CHARACTERISTIC[0] = .(DEVICE_CHAR + 4);
CHARACTERISTIC[1] = .(DEVICE_CHAR + 6);
CHARACTERISTIC[2] = .(DEVICE_CHAR + 8);
CHARACTERISTIC[3] = .(DEVICE_CHAR + 10);

! Now set density

IF .MOUNT_OPTIONS[OPT_DENSITY] THEN
    BEGIN
    IF .MOUNT_OPTIONS[OPT_DENS_800]
      THEN DENSITY[MT$V_DENSITY] = MT$K_NRZI_800
      ELSE
	IF .MOUNT_OPTIONS[OPT_DENS_1600]
	  THEN DENSITY[MT$V_DENSITY] = MT$K_PE_1600
	  ELSE DENSITY[MT$V_DENSITY] = MT$K_GCR_6250;
    END
    ELSE

    ! use the default 1600 BPI

    DENSITY[MT$V_DENSITY] = MT$K_PE_1600;



! Parity set to odd, we only support 9-tracks and 9-tracks are always odd

PARITY [ MT$V_PARITY ] = ODD_PARITY;

! Reset Tape format to FILES-11 ( only supported format )

FORMAT [ MT$V_FORMAT ] = MT$K_NORMAL11;

!
! record and block sizes only for mount ( not init )
!

! Determine block size to set

IF ( .MOUNT_OPTIONS[OPT_FOREIGN] OR .MOUNT_OPTIONS[OPT_NOLABEL] )
    THEN BLOCKSZ = 512
    ELSE BLOCKSZ = 2048;

! Check that blocksize for mounted labeled tape is not less than 18

IF .MOUNT_OPTIONS[OPT_BLOCKSIZE] THEN
    BEGIN
    IF	   NOT .MOUNT_OPTIONS[OPT_FOREIGN]
       AND NOT .MOUNT_OPTIONS[OPT_NOLABEL]
       AND .BLOCKSIZE LSS 18
      THEN ERR_EXIT (MOUN$_ILLANSIBS);
    BLOCKSZ = .BLOCKSIZE;
    END;

BUFFER_SIZE = .BLOCKSZ;

! Check legal record size

IF .RECORDSZ GTRU .BLOCKSZ THEN ERR_EXIT (MOUN$_RECGTRBL);

! write the characteristics to the tape drive

STATUS = DO_IO (CHAN = .CHANNEL,
		IOSB = IO_STATUS,
		FUNC = IO$_SETMODE,
		P1 = CHARACTERISTIC);
IF .STATUS THEN STATUS = .IO_STATUS[0];
IF (NOT .STATUS) AND (.DEVICE_INDEX LSS .LABEL_COUNT) THEN ERR_EXIT (.STATUS);

END;				! end of Routine SET_CHARACTER

ROUTINE RESET_DENSITY : NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine resets the density of the tape drive.  It is called
!	if this a foreign mount.
!
! CALLING SEQUENCE:
!	RESET_DENSITY ();
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	CHANNEL		- the I/O channel of the tape drive
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	IO_STATUS	- set to the return status of the QIO
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
! USER ERRORS:
!	NONE
!
!--

BEGIN

LOCAL
	CHARACTERISTIC	: VECTOR [4,WORD],	! characteristics to set
	STATUS;

BIND
	!  Set up offsets into the characteristics buffer

	BUFFER_SIZE	= CHARACTERISTIC[1] : WORD,
	DENSITY		= CHARACTERISTIC[2] : BBLOCK;


! must be at beginning of tape to set characteristics

STATUS = DO_IO (CHAN = .CHANNEL,
		IOSB = IO_STATUS,
		FUNC = IO$_REWIND);
IF .STATUS THEN STATUS = .IO_STATUS[0];
IF NOT .STATUS THEN ERR_EXIT (.STATUS);

! read the characteristics of the tape drive 

STATUS = DO_IO (CHAN = .CHANNEL,
		IOSB = CHARACTERISTIC,
		FUNC = IO$_SENSEMODE);
IF .STATUS THEN STATUS = .CHARACTERISTIC[0];
IF NOT .STATUS THEN ERR_EXIT (.STATUS);

! Set up the buffer to hold the new characteristics.  Get the device
!  independent stuff from the 2nd long word of IO_STATUS, use the default
!  buffersize and zero the notused field

CHARACTERISTIC [ 0 ] = 0;
BUFFER_SIZE	     = .BLOCKSZ;

! Now reset density to what the user specified.

IF .MOUNT_OPTIONS [ OPT_DENSITY ]
THEN
    BEGIN
    IF .MOUNT_OPTIONS[OPT_DENS_800]
    THEN DENSITY[MT$V_DENSITY] = MT$K_NRZI_800
    ELSE
	IF .MOUNT_OPTIONS[OPT_DENS_1600]
	THEN DENSITY[MT$V_DENSITY] = MT$K_PE_1600
	ELSE DENSITY[MT$V_DENSITY] = MT$K_GCR_6250;
    END;

! write the characteristics to the tape drive

STATUS = DO_IO (CHAN = .CHANNEL,
		IOSB = IO_STATUS,
		FUNC = IO$_SETMODE,
		P1 = CHARACTERISTIC);
IF .STATUS THEN STATUS = .IO_STATUS[0];
IF NOT .STATUS THEN ERR_EXIT (.STATUS);

END;					! end of routine RESET_DENSITY
						! end of routine TAPE_OWN_PRO

MACRO INITIALIZE_MOUNT_TAPE = 

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This MACRO is the code that is done 1st thru the routine MOUNT_TAPE.
!	It initialize the prototypes for the MVL, RVT and VCB.  The code also
!	does some one time only checks.
!
! CALLING SEQUENCE:
!	INITIALIZE_MOUNT_TAPE
!
! PARAMETERS:
!	All of MOUNT_TAPE's parameters
!
!--

BEGIN


! get a handle on the UCB list contained in the RVT
!
UCBLIST = PROTO_RVT[RVT$L_UCBLST];

! Now fill in VCB prototype
!
PROTO_VCB[VCB$W_TRANS]	  = 1;
PROTO_VCB[VCB$W_MCOUNT]	  = 1;
PROTO_VCB[VCB$W_RECORDSZ] = .RECORDSZ;

! If Files-11 use label in VOL1 else use user's label as the volume name in the
! VCB
!
IF .MOUNT_OPTIONS[OPT_IS_FILES11]
THEN CH$COPY ( VL1$S_VOLLBL,  VOL1[VL1$T_VOLLBL],    ' ',
	       VCB$S_VOLNAME, PROTO_VCB[VCB$T_VOLNAME])
ELSE CH$COPY ( .LABEL_STRING[0,LEN], .LABEL_STRING[0,ADDR],  ' ',
	       VCB$S_VOLNAME,	     PROTO_VCB[VCB$T_VOLNAME]);

! If Files-11 mount, fill in MVL + VCB
!
IF NOT ( .MOUNT_OPTIONS[OPT_FOREIGN] OR .MOUNT_OPTIONS[OPT_NOLABEL] )
THEN
    BEGIN

    ! stuff away the number of labels we have
    !
    IF .LABEL_COUNT EQL 0 THEN LABEL_COUNT = 1;
    PROTO_MVL[MVL$B_NVOLS] = .LABEL_COUNT;

    ! copy the FILE SET ID to the MVL ( checked on tape reel switch by MTAACP )
    !
    CH$COPY ( HD1$S_FILESETID, ANSI_LABEL [ HD1$T_FILESETID ], ' ',
	      MVL$S_SET_ID,    PROTO_MVL [ MVL$T_SET_ID ] );

    ! copy VOL1 Accessibility Charater to MVL for default writing during
    !	MTAACP next volume writes
    !
    CH$MOVE (MVL$S_VOLOWNER, VOL1[VL1$T_VOLOWNER],PROTO_MVL[MVL$T_VOLOWNER]);
    PROTO_MVL[MVL$B_VOL_ACC] = .VOL1[VL1$B_VOLACCESS];

    ! get a handle on the label list inside the MVL
    !
    MVL_ENTRY = PROTO_MVL+MVL$K_FIXLEN;

    ! Fill in the known constant for the prototype VCB
    !
    PROTO_VCB[VCB$V_OVRACC]   = .MOUNT_OPTIONS[OPT_OVR_ACC];
    PROTO_VCB[VCB$V_OVREXP]   = .MOUNT_OPTIONS[OPT_OVR_EXP];
    PROTO_VCB[VCB$V_OVRLBL]   = .MOUNT_OPTIONS[OPT_OVR_ID];
    PROTO_VCB[VCB$V_OVRSETID] = .MOUNT_OPTIONS[OPT_OVR_SETID];
    PROTO_VCB[VCB$V_NOHDR3]   = .MOUNT_OPTIONS[OPT_NOHDR3];
    PROTO_VCB[VCB$V_OVRVOLO]  = .MOUNT_OPTIONS[OPT_OVR_VOLO];
    PROTO_VCB[VCB$V_INIT]     = .MOUNT_OPTIONS[OPT_INIT_ALL] OR .MOUNT_OPTIONS[OPT_INIT_CONT];
    PROTO_VCB[VCB$V_NOAUTO]   = .MOUNT_OPTIONS[OPT_NOAUTO];
    PROTO_VCB[VCB$V_INTCHG]   = .MOUNT_OPTIONS[OPT_INTERCHG];


    PROTO_MVL[MVL$V_OPER]     = .PRIVILEGE_MASK[PRV$V_OPER];
    PROTO_MVL[MVL$V_VOLPRO]   = .PRIVILEGE_MASK[PRV$V_VOLPRO];
    PROTO_MVL[MVL$V_OVRPRO]   = .PRIVILEGE_MASK[PRV$V_VOLPRO] OR
				.PRIVILEGE_MASK[PRV$V_BYPASS] OR
				.PRIVILEGE_MASK[PRV$V_OPER]   OR
				.PRIVILEGE_MASK[PRV$V_SYSPRV];
    PROTO_MVL[MVL$B_STDVER]   = .LABEL_VER;

    END;

! must have operator privilege to monkey with the ACP
!
IF  (.MOUNT_OPTIONS[OPT_UNIQUEACP] OR
     .MOUNT_OPTIONS[OPT_SAMEACP]   OR
     .MOUNT_OPTIONS[OPT_FILEACP])
    AND (NOT .PRIVILEGE_MASK[PRV$V_OPER]) 
  THEN ERR_EXIT (SS$_NOPRIV);

! If not Files-11 mount or mount foreign or mount no labels then
! only one unit can be involved.  If Files-11 allocate
! secondary units checking that the maximum number of devices  is not exceeded.
!
IF (.DEVICE_COUNT EQL 0)
   OR ((NOT .MOUNT_OPTIONS[OPT_IS_FILES11]
 	 OR .MOUNT_OPTIONS[OPT_FOREIGN]
	 OR .MOUNT_OPTIONS[OPT_NOLABEL])
       AND (.DEVICE_COUNT NEQ 1))
  THEN ERR_EXIT (MOUN$_DEVICES);

! remember the first volume's UIC and Protection ( used in the UCB )
!
FIRST_V_UIC  = .VOLUME_UIC;
FIRST_V_PROT = .VOLUME_PROT;
END;
%;				    ! end of Macro INITIALIZE_MOUNT_TAPE

MACRO DONE_MOUNT_TAPE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This MACRO is the code that is done the last time thru the routine
!	MOUNT_TAPE.  It fills the MVL with the extra labels.  The real MVL,
!	RVT and VCB get put into system space.  The user is notified of which
!	reels are mounted where.
!
! CALLING SEQUENCE:
!	DONE_MOUNT_TAPE
!
! PARAMETERS:
!	All of MOUNT_TAPE's parameters
!
!--

BEGIN

! If Files-11 mount, fill in MVL with the extra labels ( if more labels then
! devices are specified )
!
IF NOT (.MOUNT_OPTIONS[OPT_FOREIGN] OR .MOUNT_OPTIONS[OPT_NOLABEL])
THEN
    INCR I FROM (.DEVICE_INDEX + 1) TO .LABEL_COUNT - 1 DO
	BEGIN
	IF .LABEL_STRING [.I, LEN] GTRU VL1$S_VOLLBL
	  THEN ERR_EXIT (SS$_MTLBLLONG);
	CH$TRANSLATE ( TRANSLATION_TABLE,
		 .LABEL_STRING[.I,LEN], .LABEL_STRING[.I,ADDR], ' ',
		 MVL$S_VOLLBL,		MVL_ENTRY[.I,MVL$T_VOLLBL]);
	MVL_ENTRY[.I, MVL$B_STATUS]  = 0;
	END;


! update the number of units available to volume set
!
PROTO_RVT[RVT$B_NVOLS] = .DEVICE_INDEX + 1;

! make the mount a real thing
!
STATUS = KERNEL_CALL (MAKE_TAPE_MOUNT);
IF NOT .STATUS THEN ERR_EXIT (.STATUS);

! Let the user know if the volume has been changed to write lock
! (ie He said the write ring was there but it wasn't )
!
IF .WRITE_RING [ 0 ] NEQ .MOUNT_OPTIONS [ OPT_WRITE ]
THEN ERR_MESSAGE ( MOUN$_WRITELOCK );


!
! Print information message stating which volumes are mounted on which units
!

IF NOT ( .MOUNT_OPTIONS[OPT_FOREIGN] OR .MOUNT_OPTIONS[OPT_NOLABEL] )
THEN
    BEGIN
    LOCAL LADDR : REF VECTOR[,BYTE],
	  SIZE;
    MVL_ENTRY = PROTO_MVL+MVL$K_FIXLEN;
    INCR I FROM 0 TO .PHYS_COUNT-1 DO
	INCR J FROM 0 TO .PROTO_MVL[MVL$B_NVOLS] -1 DO
	    IF .MVL_ENTRY[.J,MVL$B_RVN] EQL .I AND .MVL_ENTRY[.J,MVL$V_MOUNTED]
	    THEN
		BEGIN
		LADDR = MVL_ENTRY[.J,MVL$T_VOLLBL];
		DECR K FROM MVL$S_VOLLBL TO 0 DO
		    BEGIN
		    SIZE = .K;
		    IF .SIZE NEQ 0 
		    THEN
			IF .LADDR[.SIZE-1] NEQ ' ' THEN EXITLOOP;
		    END;
		ERR_MESSAGE (MOUN$_MOUNTED,3,.SIZE,MVL_ENTRY[.J,MVL$T_VOLLBL],
			     PHYS_NAME[.I,LEN]);
		END;
    END
ELSE
    BEGIN
    LOCAL LADDR	: REF VECTOR[,BYTE],
	  SIZE;
    LADDR = PROTO_VCB[VCB$T_VOLNAME];
    DECR I FROM VCB$S_VOLNAME TO 0 DO
	BEGIN
	SIZE = .I;
	IF .SIZE NEQ 0 
	THEN
	    IF .LADDR[.SIZE-1] NEQ ' ' THEN EXITLOOP;
	END;
    ERR_MESSAGE (MOUN$_MOUNTED,3,.SIZE,PROTO_VCB[VCB$T_VOLNAME],
		 PHYS_NAME[0,LEN]);
    END;
END;					! end of Macro DONE_MOUNT_TAPE
%;

GLOBAL ROUTINE MOUNT_TAPE : NOVALUE  =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine performs the mechanics of mounting magnetic tape 
! 	given as input the parsed and partially validated command line.
!
! CALLING SEQUENCE:
!	MOUNT_TAPES ()
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	mount parser data base
!	CHANNEL channel number for I/O
!	VOL1 ANSI VOL1 label if Files_11
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	VCB,RVT,MVL created
!
! USER ERRORS:
!	NONE
!
!--

BEGIN

! Define descriptor vector displacements
!
MACRO LEN	= 0,0,16,0%;
MACRO ADDR	= 4,0,32,0%;

EXTERNAL
	DEVICE_COUNT,				    ! # of devices specified
	DEVICE_STRING	: BBLOCKVECTOR[DEVMAX,8],   ! vector of devices string
						    !  descriptors
	LABEL_STRING	: BBLOCKVECTOR[LABMAX,8],   ! vector of label string
						    !   descriptors
	PHYS_COUNT,				    ! number of physical
						    !   devices allocated
	PHYS_NAME	: BBLOCKVECTOR[DEVMAX,8];   ! vector of physical
						    !   devices allocated

LOCAL
	STATUS,
	UCB;

OWN
	MVL_ENTRY	: REF BBLOCKVECTOR[LABMAX,MVL$K_LENGTH],
	UCBLIST		: REF VECTOR;		    ! vector of UCB in RVT

! Enable handler to clear valid on all but current device

ENABLE ERROR_HANDLER;

! initialize things and do some 1 time checks if first time thru

IF .DEVICE_INDEX EQL 0 THEN INITIALIZE_MOUNT_TAPE;

! Position tape to beginning again

STATUS = DO_IO (CHAN = .CHANNEL,
		FUNC = IO$_REWIND,
		IOSB = IO_STATUS);
IF .STATUS THEN STATUS = .IO_STATUS[0];
IF (NOT .STATUS) AND (.DEVICE_INDEX LSS .LABEL_COUNT) THEN ERR_EXIT (.STATUS);

! If the accessibility routine allows us to check the VMS protection then 
! check privileges.
! First check to see if users has read/write access to the volume. If the
! user does not have access to the volume then check to see if the user
! has priv's to override the access or if the user is the owner of the volume.

IF .ACCESS 
   THEN
   BEGIN
	IF NOT KERNEL_CALL (CHECK_PROT, VOLUME_PROT, VOLUME_UIC, .PROCESS_UIC,
				    WRITE_RING[0])
	   THEN
	   BEGIN
		IF (.MOUNT_OPTIONS[OPT_OVR_PRO] 
		   AND ( NOT (.PRIVILEGE_MASK[PRV$V_VOLPRO]
		      OR (.VOLUME_UIC EQL .PROCESS_UIC) ) ) )
		THEN ERR_EXIT (SS$_NOPRIV);
	   END;
  END;


! get the UCB of the currect channel and stuff it away in the RVT


UCB = KERNEL_CALL (GET_CHANNELUCB,.CHANNEL);

! Check that duplicate device has not been specified

INCR J FROM 0 TO .DEVICE_INDEX - 1 DO
    IF .UCBLIST[.J] EQL .UCB THEN ERR_EXIT (MOUN$_DUPDEVSPC);

UCBLIST[.DEVICE_INDEX] = .UCB;

! If Files-11 mount, stuff the label in the MVL and mark it mounted

IF NOT ( .MOUNT_OPTIONS[OPT_FOREIGN] OR .MOUNT_OPTIONS[OPT_NOLABEL] )
THEN
    BEGIN
    CH$TRANSLATE ( TRANSLATION_TABLE,
	      VL1$S_VOLLBL, VOL1 [VL1$T_VOLLBL], ' ',
	      MVL$S_VOLLBL, MVL_ENTRY [.DEVICE_INDEX, MVL$T_VOLLBL]);
    MVL_ENTRY[.DEVICE_INDEX, MVL$B_STATUS]  = 0;
    MVL_ENTRY[.DEVICE_INDEX, MVL$V_MOUNTED] = 1;
    MVL_ENTRY[.DEVICE_INDEX, MVL$B_RVN]	    = .DEVICE_INDEX;
    END;

! do some last time only stuff

IF .DEVICE_INDEX EQL (.DEVICE_COUNT - 1)
THEN DONE_MOUNT_TAPE;

END;					! end of routine MOUNT_TAPE


ROUTINE MAKE_TAPE_MOUNT  =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine does the data base manipulation to get a 
!	volume mounted
!
! CALLING SEQUENCE:
!	MAKE_TAPE_MOUNT (), called in kernel mode
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	mount parser variables
!	own variables in this module
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	1 - success
!	other status codes
!
! SIDE EFFECTS:
!	NONE
!
! USER ERRORS:
!	NONE
!
!--

BEGIN

EXTERNAL
	OWNER_UIC,				! owner UIC from command line
	PROTECTION,				! protection from command line
	REAL_MVL	: REF BBLOCK,		! real MVL
	REAL_RVT	: REF BBLOCK,		! real RVT
	REAL_VCB	: REF BBLOCK,		! real VCB
	SCH$GL_CURPCB	: REF BBLOCK ADDRESSING_MODE (ABSOLUTE),
	USER_UIC;				! user UIC from command line

LOCAL
	PRIMARY_UCB	: REF BBLOCK,		! primary UCB
	UCB		: REF BBLOCK,		! secondary UCB
	PRIMARY_ORB	: REF BBLOCK,		! primary ORB
	ORB		: REF BBLOCK,		! secondary ORB
	UCBLIST		: REF VECTOR[DEVMAX];	! UCB list in RVT

! Enable our condition handler.
!
ENABLE KERNEL_HANDLER;

! get the UCB of the first channel in the volume set
!
PRIMARY_UCB = .PROTO_RVT [ RVT$L_UCBLST ];
PRIMARY_ORB = .PRIMARY_UCB[UCB$L_ORB];

! Setup ownership and protection
!
IF .MOUNT_OPTIONS[OPT_OWNER_UIC]
THEN PRIMARY_ORB[ORB$L_OWNER] = .OWNER_UIC
ELSE PRIMARY_ORB[ORB$L_OWNER] = .FIRST_V_UIC;

PRIMARY_ORB[ORB$V_PROT_16] = 1;			! SOGW protection word
IF .MOUNT_OPTIONS[OPT_PROTECTION]
THEN PRIMARY_ORB[ORB$W_PROT] = .PROTECTION<0,16> AND %X'FF00'
ELSE
    IF .MOUNT_OPTIONS[OPT_FOREIGN] OR .MOUNT_OPTIONS[OPT_NOLABEL]
    THEN PRIMARY_ORB[ORB$W_PROT] = %X'FF00'
    ELSE PRIMARY_ORB[ORB$W_PROT] = .FIRST_V_PROT<0,16>;

! Create real VCB
!
REAL_VCB = ALLOCATE_MEM (VCB$K_LENGTH,0);
REAL_VCB[VCB$B_TYPE] = DYN$C_VCB;
CH$MOVE (VCB$K_LENGTH-11,PROTO_VCB+11,.REAL_VCB+11);

! If not foreign and no labels then allocate RVT and MVL
!
IF NOT .MOUNT_OPTIONS[OPT_FOREIGN] AND NOT .MOUNT_OPTIONS[OPT_NOLABEL] THEN
    BEGIN
    REAL_RVT		    = ALLOCATE_MEM ($BYTEOFFSET (RVT$L_UCBLST) +
					    (.PROTO_RVT[RVT$B_NVOLS] * 4),0);
    REAL_RVT[RVT$B_TYPE]    = DYN$C_RVT;
    CH$MOVE (.REAL_RVT[RVT$W_SIZE]-11,PROTO_RVT+11,.REAL_RVT+11);
    REAL_MVL		    = ALLOCATE_MEM (MVL$K_FIXLEN + 
				   (.PROTO_MVL[MVL$B_NVOLS] * MVL$K_LENGTH),0);
    REAL_MVL[MVL$B_TYPE]    = DYN$C_MVL;
    CH$MOVE (.REAL_MVL[MVL$W_SIZE] - 11,PROTO_MVL + 11,.REAL_MVL + 11);
    REAL_MVL[MVL$L_VCB]	    = .REAL_VCB;
    REAL_VCB[VCB$L_RVT]     = .REAL_RVT;
    REAL_VCB[VCB$L_MVL]	    = .REAL_MVL;
    REAL_VCB[VCB$L_BLOCKFL] = REAL_VCB[VCB$L_BLOCKFL];
    REAL_VCB[VCB$L_BLOCKBL] = REAL_VCB[VCB$L_BLOCKFL];
    REAL_VCB[VCB$L_VPFL]    = REAL_VCB[VCB$L_VPFL];
    REAL_VCB[VCB$L_VPBL]    = REAL_VCB[VCB$L_VPFL];
    END;

ALLOC_LOGNAME (0);

! Set the "unload at dismount" characteristic in the UCB appropriately.
!
PRIMARY_UCB[UCB$V_UNLOAD] = NOT .MOUNT_OPTIONS [OPT_NOUNLOAD];

! Check for data check requests at mount time
!
BBLOCK[PRIMARY_UCB[UCB$L_DEVCHAR],DEV$V_RCK] = .MOUNT_OPTIONS[OPT_READCHECK];
BBLOCK[PRIMARY_UCB[UCB$L_DEVCHAR],DEV$V_WCK] = .MOUNT_OPTIONS[OPT_WRITECHECK];
IF NOT .MOUNT_OPTIONS[OPT_FOREIGN] AND NOT .MOUNT_OPTIONS[OPT_NOLABEL]
THEN
    BEGIN
    PRIMARY_UCB[UCB$L_DEVCHAR] = .PRIMARY_UCB[UCB$L_DEVCHAR] AND NOT DEV$M_REC;
    START_ACP (.PRIMARY_UCB,.REAL_VCB,AQB$K_MTA);
    END
ELSE
    BEGIN
    LOCK_IODB ();
    PRIMARY_UCB[UCB$L_VCB]     = .REAL_VCB;
    PRIMARY_UCB[UCB$L_DEVCHAR] = .PRIMARY_UCB[UCB$L_DEVCHAR] OR
				   (DEV$M_MNT OR DEV$M_FOR OR DEV$M_REC);
    PRIMARY_UCB[UCB$L_DEVCHAR] = .PRIMARY_UCB[UCB$L_DEVCHAR] AND 
				   NOT (DEV$M_DIR OR DEV$M_SDI);
    UNLOCK_IODB ();
    END;

IF .CLEANUP_ALLOC[0] THEN PRIMARY_UCB[UCB$V_DEADMO] = 1;

IF NOT .WRITE_RING [ 0 ] THEN BBLOCK[PRIMARY_UCB[UCB$L_DEVCHAR],DEV$V_SWL] = 1;

PRIMARY_UCB [UCB$W_REFC] = .PRIMARY_UCB [UCB$W_REFC] + 1;

! Make allocation permanent
!
!PRIMARY_UCB[UCB$B_AMOD] = 0;
SEND_ERRLOG (1,.PRIMARY_UCB);

! Now set secondary UCB values if needed
!
IF .REAL_RVT NEQ 0
THEN
  BEGIN
  UCBLIST = REAL_RVT[RVT$L_UCBLST];
  INCR I FROM 1 TO .REAL_RVT[RVT$B_NVOLS] -1 DO
    BEGIN
    UCB			 = .UCBLIST[.I];
    ORB			 = .UCB[UCB$L_ORB];
    UCB[UCB$V_UNLOAD]	 = .PRIMARY_UCB[UCB$V_UNLOAD];
!   UCB[UCB$B_AMOD]	 = 0;			! make allocation permanent
    ORB[ORB$L_OWNER]	 = .PRIMARY_ORB[ORB$L_OWNER];
    ORB[ORB$V_PROT_16]	 = 1;
    ORB[ORB$W_PROT]	 = .PRIMARY_ORB[ORB$W_PROT];
    UCB[UCB$L_VCB]	 = .REAL_VCB;
    UCB[UCB$W_DEVBUFSIZ] = .PRIMARY_UCB[UCB$W_DEVBUFSIZ];
    (UCB[UCB$L_DEVDEPEND])<0,16>
			 = .(PRIMARY_UCB[UCB$L_DEVDEPEND])<0,16>;
    UCB[UCB$L_DEVCHAR]	 = .UCB[UCB$L_DEVCHAR] OR
				(DEV$M_MNT OR DEV$M_DIR OR DEV$M_SDI);
    BBLOCK[UCB[UCB$L_DEVCHAR],DEV$V_RCK]
			 = .BBLOCK[PRIMARY_UCB[UCB$L_DEVCHAR],DEV$V_RCK];
    BBLOCK[UCB[UCB$L_DEVCHAR],DEV$V_WCK]
			 = .BBLOCK[PRIMARY_UCB[UCB$L_DEVCHAR],DEV$V_WCK];
    BBLOCK[UCB[UCB$L_DEVCHAR],DEV$V_REC]
			 = 0;

    IF .CLEANUP_ALLOC[.I] THEN UCB[UCB$V_DEADMO] = 1;
    IF NOT .WRITE_RING [ 0 ] THEN BBLOCK[UCB[UCB$L_DEVCHAR],DEV$V_SWL] = 1;

    UCB [UCB$W_REFC] = .UCB [UCB$W_REFC] + 1;

    SEND_ERRLOG (1,.UCB);
    END;
  END;

ENTER_LOGNAME (.PRIMARY_UCB,.REAL_VCB);
CTL$GL_VOLUMES = .CTL$GL_VOLUMES + 1;

RETURN 1;
END;						! end of routine MAKE_TAPE_MOUNT

ROUTINE KERNEL_HANDLER (SIGNAL, MECHANISM) : NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine is the condition handler for all of the kernel mode
!	code. It undoes any damage done so far and returns the error
!	status to the user mode caller.
!
! CALLING SEQUENCE:
!	KERNEL_HANDLER (ARG1, ARG2)
!
! INPUT PARAMETERS:
!	ARG1: address of signal vector
!	ARG2: address of mechanism vector
!
! IMPLICIT INPUTS:
!	global pointers to blocks allocated
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	stack unwound, allocations undone
!
!--

BEGIN

MAP
	SIGNAL		: REF BBLOCK,	! signal vector
	MECHANISM	: REF BBLOCK;	! mechanism vector

LOCAL
	UCB		: REF BBLOCK,
	ORB		: REF BBLOCK,
	P		: REF BBLOCK;	! pointer to scan system lists

EXTERNAL
	MAILBOX_CHANNEL,		! channel number of ACP mailbox
	REAL_VCB	: REF BBLOCK,	! address of VCB allocated
	REAL_RVT	: REF BBLOCK,	! address of FCB allocated
	REAL_MVL	: REF BBLOCK,	! address of window allocated
	REAL_AQB	: REF BBLOCK,	! address of AQB allocated
	MTL_ENTRY	: REF BBLOCK,	! address of mounted volume list entry
	IOC$GL_AQBLIST	: REF BBLOCK ADDRESSING_MODE (ABSOLUTE);
					! system AQB list

EXTERNAL ROUTINE
	LOCK_IODB	: ADDRESSING_MODE (GENERAL), ! interlock system I/O database
	UNLOCK_IODB	: ADDRESSING_MODE (GENERAL), ! unlock system I/O database
	DEALLOCATE_MEM;			! deallocate system dynamic memory


! Deallocate whatever control blocks exist to wherever they came from.
!

IF .SIGNAL[CHF$L_SIG_NAME] NEQ SS$_UNWIND
THEN
    BEGIN

    IF .SIGNAL[CHF$L_SIG_ARGS] NEQ 3
    THEN BUG_CHECK (UNXSIGNAL, FATAL, 'Unexpected signal in MOUNT');

! If there is a mailbox in existence, deassign its channel, thereby
! deleting the mailbox.
!

    IF .CLEANUP_FLAGS[CLF_DEASSMBX]
    THEN
	$DASSGN (CHAN = .MAILBOX_CHANNEL);

! If we have created an AQB but no ACP, we must remove the AQB from the
! system list.
!

    IF .CLEANUP_FLAGS[CLF_DELAQB]
    THEN
	BEGIN
	LOCK_IODB ();
	P = .IOC$GL_AQBLIST;
	IF .P EQL .REAL_AQB
	THEN
	    IOC$GL_AQBLIST = .REAL_AQB[AQB$L_LINK]
	ELSE
	    BEGIN
	    UNTIL .P[AQB$L_LINK] EQL .REAL_AQB DO P = .P[AQB$L_LINK];
	    P[AQB$L_LINK] = .REAL_AQB[AQB$L_LINK];
	    END;
	DEALLOCATE_MEM (.REAL_AQB, 0);
	UNLOCK_IODB ();
	END;

    IF .REAL_VCB NEQ 0
    THEN DEALLOCATE_MEM (.REAL_VCB, 0);

    IF .REAL_RVT NEQ 0
    THEN DEALLOCATE_MEM (.REAL_RVT, 0);

    IF .REAL_MVL NEQ 0
    THEN DEALLOCATE_MEM (.REAL_MVL, 0);

    IF .MTL_ENTRY NEQ 0
    THEN DEALLOCATE_MEM (.MTL_ENTRY, 1); 

!
! Cleanup protection on primary UCB
!

    UCB			= GET_CHANNELUCB (.CHANNEL);
    ORB			= .UCB[UCB$L_ORB];
    ORB[ORB$L_OWNER]	= 0;
    ORB[ORB$L_SYS_PROT]	= 0;
    ORB[ORB$L_OWN_PROT]	= 0;
    ORB[ORB$L_GRP_PROT]	= 0;
    ORB[ORB$L_WOR_PROT]	= 0;
    UCB[UCB$L_VCB]	= 0;

! Return the condition code in R0.
!

    MECHANISM[CHF$L_MCH_SAVR0] = .SIGNAL[CHF$L_SIG_NAME];
    $UNWIND ();

    END;
END;					! end of routine KERNEL_HANDLER

ROUTINE ERROR_HANDLER (SIGNAL, MECHANISM)  =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	 This routine clears the valid bit for all but current UCB.
!
! CALLING SEQUENCE:
!	ERROR_HANDLER ()
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	PROTO_RVT - lists all UCB's
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN

MAP
	SIGNAL		: REF BBLOCK,	! signal vector
	MECHANISM	: REF BBLOCK;	! mechanism vector

LOCAL 
	STATUS,
	UCBLIST	: REF VECTOR;

IF .BBLOCK[SIGNAL[CHF$L_SIG_NAME],STS$V_SEVERITY] EQL STS$K_SEVERE
THEN
    BEGIN
    UCBLIST = PROTO_RVT[RVT$L_UCBLST];
    DECR I FROM .PROTO_RVT[RVT$B_NVOLS] - 2 TO 1 DO
	STATUS = DO_IO ( CHAN = .CHANNEL,
			 FUNC = IO$_AVAILABLE,
			 IOSB = IO_STATUS [0]);
    END;

RETURN SS$_RESIGNAL;
END;					! end of routine ERROR_HANDLER

END
ELUDOM
