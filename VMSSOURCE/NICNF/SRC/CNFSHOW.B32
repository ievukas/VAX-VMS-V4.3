%TITLE	'DECnet Ethernet Configurator Module'
MODULE CNFSHOW		(
			LANGUAGE (BLISS32),
			IDENT = 'V04-000'
			) =
BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY:	DECnet Configurator Module (NICONFIG)
!
! ABSTRACT:
!
!	This module contains the routines to return information on a 
!	SHOW request generated by an NCP> SHOW MODULE CONFIGUTOR command.
!
! ENVIRONMENT:	VAX/VMS Operating System
!
! AUTHOR:	Bob Grosso, 	CREATION DATE:  13-Oct-1982
!
! MODIFIED BY:
!
!--

%SBTTL	'Definitions'

!
! INCLUDE FILES:
!

LIBRARY 'SYS$LIBRARY:STARLET';	! VMS common definitions

LIBRARY 'SHRLIB$:NMALIBRY';	! NICE code definitions

REQUIRE 'LIB$:CNFDEF.R32';

REQUIRE 'SRC$:CNFPREFIX.REQ';
    

!
! BUILTIN functions
!

BUILTIN
    SUBM;			! To support quadword subtraction

LITERAL
    NICE_BUFLEN = 128;

!
! TABLE OF CONTENTS:
!

FORWARD ROUTINE

	PROCESS_SHOW,		! Cover routine for common error handling of SHOW processing
	SHOW_CIRCUIT,		! Format circuit info 
	SHOW_SYSTEM;		! Format info for a system ID message.

!
! EXTERNAL REFERENCES:
!

EXTERNAL ROUTINE

    ! Module CNFMAIN

	CNF$EXIT,		! Clean up and exit
	CNF$TRACE,		! Log messages to log file
	CNF$FREE_VM,		! Free virtual memory
	CNF$GET_ZVM,		! Get zeroed virtual memory

    ! Module CNFREQUES

	CNF$LOCATE_CIR_BLK,	! Locate circuit block from circuit name

    ! Module CNFSEND

	CNF$BUFR_NICE_MSG,	! Buffer NICE response messages
	CNF$BUFR_ERR_MSG;	! Buffer NICE error responses

EXTERNAL

	CNF$GQ_CIRSURLST : VECTOR [2];	! List of circuits under surveillance

OWN
    NICE_DONE_DSC :			! NICE 'DONE' message
	BBLOCK [DSC$C_S_BLN] INITIAL
	(
	    1,
	    UPLIT (
		BYTE (%X'80')
		)
	),

    NICE_MORE_DSC :			! NICE 'MORE' message
	BBLOCK [DSC$C_S_BLN] INITIAL
	(
	    4,
	    UPLIT (
		BYTE (%X'02'),
		WORD (%X'FFFF'),
		BYTE (%X'00')
		)
	);

%SBTTL	'CNF$PROCESS_SHOW   Search the data base and format a response message'
GLOBAL ROUTINE CNF$PROCESS_SHOW (IRB, KNOWN, CIRCUITNAM_DSC, INFTYP) =
 
!++
! FUNCTIONAL DESCRIPTION:
!
!  Shell routine to supply a common entrance and error exit to the
!  routine which builds the SHOW message.
!
! FORMAL PARAMETERS:
!
!	irb		Interrupt request block, contains context for returning
!			responses to connectee.
!
!	known		Was SHOW KNOWN CIRCUITS requested?
!
!	circuitnam_dsc	Descriptor of circuit name if SHOW was requested for
!			a specific circuit.
!
!	inftyp		Code determining which information type was requested
!			for the SHOW, either CHARACTERISTICS, SUMMARY or STATUS.
!
! IMPLICIT INPUTS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
! COMPLETION CODES:
!
!  Always success, errors are buffered for return to connectee.
!
! SIDE EFFECTS:
!	NONE
!
!--
    BEGIN
    LOCAL
	STATUS;

    CNF$TRACE (DBG$C_TRACE, $DESCRIPTOR('TRACE'), 
	$DESCRIPTOR ('CNF$PROCESS_SHOW'));

    !
    !	Send MORE message
    !
    EXECUTE (CNF$BUFR_NICE_MSG (.IRB, NICE_MORE_DSC, 0));

    !
    !	Request that the SHOW information be gathered, formatted and buffered.
    !
    STATUS = PROCESS_SHOW (.IRB, .KNOWN, .CIRCUITNAM_DSC, .INFTYP);
    IF NOT .STATUS
    THEN
	CNF$BUFR_ERR_MSG (.IRB, NMA$C_STS_MPR, 0, .STATUS);

    !
    !	Send DONE message
    !
    EXECUTE (CNF$BUFR_NICE_MSG (.IRB, NICE_DONE_DSC, 0));

    RETURN TRUE;
    END;			! Routine CNF$PROCESS_SHOW

%SBTTL	'process_show   Search the data base and format a response message'
ROUTINE PROCESS_SHOW (IRB, KNOWN, CIRCUITNAM_DSC, INFTYP) =
 
!++
!  Locate requested circuit or dispatch for all known circuits to
!  the routine which will format and buffer the SHOW response.
!
!	irb		Interrupt request block, contains context for returning
!			responses to connectee.
!
!	known		Was SHOW KNOWN CIRCUITS requested?
!
!	circuitnam_dsc	Descriptor of circuit name if SHOW was requested for
!			a specific circuit.
!
!	inftyp		Code determining which information type was requested
!			for the SHOW, either CHARACTERISTICS, SUMMARY or STATUS.
!
!  Always return success, any errors will be buffered for return to
!  connectee.
!--
 
    BEGIN
    MAP
	CIRCUITNAM_DSC : REF BBLOCK;

    LOCAL
	CIR : REF BBLOCK;


    CNF$TRACE (DBG$C_TRACE, $DESCRIPTOR('TRACE'), 
	$DESCRIPTOR ('process_show'));

    IF .KNOWN
    THEN
	!
	!   Format the data for all circuits
	!
	BEGIN
	CIR = .CNF$GQ_CIRSURLST;		! List of circuits under surveillance
	WHILE .CIR NEQ CNF$GQ_CIRSURLST DO	! For the entire list of circuits
	    BEGIN
	    EXECUTE (SHOW_CIRCUIT (.IRB, .CIR, .INFTYP));
	    CIR = .CIR [CIR$L_LINK];		! Get next circuit in list
	    END;				! While traversing list of circuits
	END
    ELSE
	BEGIN
	!
	!   Locate the requested circuit and format the data for it.
	!
	IF CNF$LOCATE_CIR_BLK (.CIRCUITNAM_DSC, CIR)
	THEN
	    EXECUTE (SHOW_CIRCUIT (.IRB, .CIR, .INFTYP))
	ELSE
	    BEGIN				! Oops, that circuit is not in the data base
	    CNF$BUFR_ERR_MSG (.IRB, NMA$C_STS_IDE, NMA$C_ENT_CIR, 0, .CIRCUITNAM_DSC);
	    RETURN TRUE;
	    END;

	END;

    RETURN TRUE;
    END;			! Routine process_show

%SBTTL	'show_circuit   Format all systems for circuit'
ROUTINE SHOW_CIRCUIT (IRB, CIR, INFTYP) =
 
!++
!  Build the NICE for the SHOW response message and buffer it for
!  transmission to the connectee.
!
!	irb		Interrupt request block, contains context for returning
!			responses to connectee.
!
!	cir		Address of Circuit control block of circuit SHOW
!			was requested for.
!
!	inftyp		Code determining which information type was requested
!			for the SHOW, either CHARACTERISTICS, SUMMARY or STATUS.
!
!  Always return success, any errors will be buffered for return to
!  connectee.
!--
 
    BEGIN
    MAP
	CIR : REF BBLOCK;

    LOCAL
	CURRENT_TIMBUF : BBLOCK [8],		! Buffer to obtain the current system time
	DELTA_TIMBUF : BBLOCK [8],		! Buffer to calculate the time difference between the current time
						!  the time surveillance began on the circuit.
	NICE : REF BBLOCK,			! Pointer into the buffer where the NICE message is being built
	NICE_BUFDSC : BBLOCK [DSC$C_S_BLN],	! Descriptor of NICE message buffer
	NICE_TMPDSC : BBLOCK [DSC$C_S_BLN],	! Descriptor of NICE Template buffer
	SID : REF BBLOCK,			! Pointer to a system ID message
	TIMBUF : VECTOR [7, WORD];		! Buffer for converting binary time format to ASCII for NICE message

    BIND
	CONF = UPLIT (%ASCIC 'CONFIGURATOR') : VECTOR [,BYTE];	! Module name to place into NICE return


    CNF$TRACE (DBG$C_TRACE, $DESCRIPTOR('TRACE'), 
	$DESCRIPTOR ('show_circuit'));

    !
    !	Zero the descriptor which will locate the buffer where the NICE response
    !	will be built, allocate the buffer, and initialize buffer pointer.
    !
    CH$FILL (0, DSC$C_S_BLN, NICE_TMPDSC);
    EXECUTE (CNF$GET_ZVM (%REF (NICE_BUFLEN), NICE_TMPDSC [DSC$A_POINTER]));
    NICE = .NICE_TMPDSC [DSC$A_POINTER];

    !
    !	Place Error status
    !
    !	    1 byte	return code
    !	    2 bytes	error detail
    !	    1 byte	length of error message
    !
    (.NICE) <0, 8> = %X'01';			! Return code SUCCESS
    (.NICE) <8, 16> = %X'FFFF';			! Error detail, SUCCESS
    (.NICE) <24, 8> = %X'00';			! Error text length

    !
    !	Copy over the module entity, CONFIGURATOR 
    !
    !	    1 byte	Length of CONFIGURATOR string
    !	    12 bytes	CONFIGURATOR string
    !
    (.NICE) <32, 8> = .CONF [0];		! Length of CONFIGURATOR string
    NICE = .NICE + 5;				! Set pointer to beginning of circuit name
    CH$MOVE (.CONF [0], CONF [1], .NICE);
    NICE_TMPDSC [DSC$W_LENGTH] = 5 + .CONF [0];
    NICE = .NICE + .CONF [0];			! Point to free space in buffer after 
						!  the circuit name which was just copied in

    !
    !	Copy over Circuit name entity
    !
    !	    2 bytes	Circuit entity ID
    !	    1 byte	Parameter type = ASCII
    !	    1 byte	Length of circuit name
    !	    n bytes	Circuit name
    !
    (.NICE) <0, 16> = NMA$C_PCCN_CIR;
    (.NICE) <16, 8> = NMA$C_PTY_AI;		! Type = ASCII
    (.NICE) <24, 8> = .CIR [CIR$W_CIRNAMLEN];	! Length of Circuit name
    NICE = .NICE + 4;				! Set pointer to beginning of circuit name
    CH$MOVE (.CIR [CIR$W_CIRNAMLEN], CIR [CIR$T_CIRNAM], .NICE);
    NICE = .NICE + .CIR [CIR$W_CIRNAMLEN];	! Point to free space in buffer after 
						!  the circuit name which was just copied in
    NICE_TMPDSC [DSC$W_LENGTH] = .NICE_TMPDSC [DSC$W_LENGTH] + 4 + .CIR [CIR$W_CIRNAMLEN];

    !
    !	Place in Surveillance parameter
    !	as a coded value
    !
    !	    2 bytes	Surviellance parameter ID
    !	    1 byte	Surveillance type = coded byte
    !	    1 byte	Surveillance value
    !
    (.NICE) <0, 16> = NMA$C_PCCN_SUR;
	BEGIN
	BIND
	    TYPE = .NICE + 2 : BBLOCK;
	TYPE [NMA$V_PTY_COD] = TRUE;		! Surveillance is returned as a coded value
	TYPE [NMA$V_PTY_CLE] = 1;		! The coded value is 1 byte in length
	END;
    (.NICE) <24, 8> = .CIR [CIR$B_SURVEIL];
    NICE = .NICE + 4;				! Set pointer to end of buffer where Elapsed Time will be placed

    !
    !	Place in Elapsed Time parameter
    !	as a coded multiple
    !
    !	    2 bytes	Elasped Time parameter ID
    !	    1 byte	Elasped time type = coded multiple of 3 fields
    !	    1 byte	hours type = unsigned decimal word
    !	    2 bytes	hours value
    !	    1 byte 	minutes type = unsigned decimal byte
    !	    1 byte	minutes value
    !	    1 byte 	seconds type = unsigned decimal byte
    !	    1 byte	seconds value
    !
    (.NICE) <0, 16> = NMA$C_PCCN_ELT;			! Set parameter ID
	BEGIN
	BIND
	    CODMUL_TYP = .NICE + 2 : BBLOCK,
	    HR_TYP = .NICE + 3 : BBLOCK,
	    MIN_TYP = .NICE + 6 : BBLOCK,
	    SEC_TYP = .NICE + 8 : BBLOCK;

	CODMUL_TYP [NMA$V_PTY_COD] = TRUE;		! Elapsed Time is returned as a coded 
	CODMUL_TYP [NMA$V_PTY_MUL] = TRUE;		!  multiple.
	CODMUL_TYP [NMA$V_PTY_CLE] = 3;			! There are three fields in the coded multiple

	!
	!    Get the current system time, subtract 
	!    Time of Surveillance start from Current time
	!    to get negative Delta time 
	!
	EXECUTE ($GETTIM (TIMADR = CURRENT_TIMBUF));
	SUBM (2, CIR [CIR$Q_ELAPSDTIM], CURRENT_TIMBUF, DELTA_TIMBUF);
	EXECUTE ($NUMTIM (TIMBUF = TIMBUF, TIMADR = DELTA_TIMBUF));

        HR_TYP [NMA$V_PTY_NTY] = NMA$C_NTY_DU;		! Unsigned decimal
	HR_TYP [NMA$V_PTY_NLE] = 2;			!  word.
	(.NICE) <32, 16> = .TIMBUF [3];			! Hours

        MIN_TYP [NMA$V_PTY_NTY] = NMA$C_NTY_DU;		! Unsigned decimal
	MIN_TYP [NMA$V_PTY_NLE] = 1;			!  byte.
	(.NICE) <56, 8> = .TIMBUF [4];			! Minutes

        SEC_TYP [NMA$V_PTY_NTY] = NMA$C_NTY_DU;		! Unsigned decimal
	SEC_TYP [NMA$V_PTY_NLE] = 1;			!  byte.
	(.NICE) <72, 8> = .TIMBUF [5];			! Seconds
	END;

    NICE_TMPDSC [DSC$W_LENGTH] = 14 + .NICE_TMPDSC [DSC$W_LENGTH];

    SID = .CIR [CIR$L_SIDFLINK];			! Point to first System ID

    IF (.SID EQL CIR [CIR$L_SIDFLINK]) OR		! There are no ID's collected for this circuit
	((.INFTYP NEQ NMA$C_OPINF_STA) AND		! or Summary requested
	    (.INFTYP NEQ NMA$C_OPINF_CHA))
    THEN
	!
	!   Print only circuit info, not system ID's, since either
	!   there are no ID's collected, or a SHOW SUMMARY was requested.
	!
	BEGIN
	CNF$BUFR_NICE_MSG (.IRB, NICE_TMPDSC, NICE_BUFLEN);
	RETURN TRUE;
	END

    ELSE
	!
	!   Traverse the list of system ID's and format a NICE response
	!   for each one.  Each one will be appended to a repeat of the 
	!   circuit info already gathered.
	!
	BEGIN
	WHILE .SID NEQ CIR [CIR$L_SIDFLINK] DO		! For all the System ID's
	    BEGIN
	    !
	    !	Zero the descriptor and allocate a clean buffer for the NICE
	    !	response message.  Then copy the message already built for the
	    !	circuit info as the start of the message to which the system ID
	    !	info will be appended.
	    !
	    CH$FILL (0, DSC$C_S_BLN, NICE_BUFDSC);
	    EXECUTE (CNF$GET_ZVM (%REF (NICE_BUFLEN), NICE_BUFDSC [DSC$A_POINTER]));
	    CH$MOVE (.NICE_TMPDSC [DSC$W_LENGTH], .NICE_TMPDSC [DSC$A_POINTER],
		.NICE_BUFDSC [DSC$A_POINTER]);
	    NICE_BUFDSC [DSC$W_LENGTH] = .NICE_TMPDSC [DSC$W_LENGTH];

	    !
	    !	Append the system ID info to the NICE response, and
	    !	buffer the message for later transmission.
	    !	Then follow list pointer to next system ID.
	    !
	    SHOW_SYSTEM (.SID, NICE_BUFDSC);
	    CNF$BUFR_NICE_MSG (.IRB, NICE_BUFDSC, NICE_BUFLEN);
	    SID = .SID [SID$L_LINK];
	    END;			! While processing all system ID's for the circuit
	!
	!   Return the buffer which we used to build the circuit info part
	!   of the response.
	!
	EXECUTE (CNF$FREE_VM (%REF (NICE_BUFLEN), NICE_TMPDSC [DSC$A_POINTER]));
	END;				! There are system ID's for this circuit

    RETURN TRUE;
    END;				! Routine show_circuit

%SBTTL	'show_system   Format System ID info'
ROUTINE SHOW_SYSTEM (SID, NICEBUF) =
 
!++
!  Format the information in the system ID message stored in
!  SID and build a NICE message which will be appended to the
!  NICE message for the circuit which is in NICEBUF.
!
!	sid	  Pointer to buffer containing a system ID message
!
!	nicebuf	  Descriptor of buffer containing circuit NICE message
!
!  Always return success.  There is no error checking.
!
!--
    BEGIN
    MAP
	NICEBUF : REF BBLOCK,
	SID : REF BBLOCK;
    LOCAL
	NICE : REF BBLOCK,
	TIMBUF : VECTOR [7, WORD];

    CNF$TRACE (DBG$C_TRACE, $DESCRIPTOR('TRACE'), 
	$DESCRIPTOR ('show_system'));

    NICE = .NICEBUF [DSC$A_POINTER] + .NICEBUF [DSC$W_LENGTH];

    !
    !	Place in Physical Address parameter
    !	as a Hex Image 6
    !
    !	    2 bytes	Physical Address parameter ID
    !	    1 byte	Physical Address type = Hex Image (HI-6)
    !	    6 bytes	Physical Address value
    !
    (.NICE) <0, 16> = NMA$C_PCCN_PHA;
	BEGIN
	BIND
	    TYPE = .NICE + 2 : BBLOCK;
	TYPE [NMA$V_PTY_NTY] = NMA$C_NTY_H;	! returned as a Hex
	TYPE [NMA$V_PTY_NLE] = NMA$C_NLE_IMAGE;	!   image.
	END;
    (.NICE) <24,8> = SID$C_ADRLEN;
    CH$MOVE (SID$C_ADRLEN, SID [SID$T_CURADR], (.NICE + 4) );
    NICE = .NICE + 4 + SID$C_ADRLEN;		! Set pointer to end of buffer where next parameter will be placed

    !
    !	Place in Last Report parameter
    !	as a coded multiple
    !
    !	    2 bytes	Last Report parameter ID
    !	    1 byte	Last Report type = coded multiple of 5 fields
    !	    1 byte	Day type = unsigned decimal byte
    !	    1 byte	Day value
    !	    1 byte	Month type = Coded byte
    !	    1 byte	Month coded value
    !	    1 byte	hour type = unsigned decimal byte
    !	    1 byte	hour value
    !	    1 byte 	minutes type = unsigned decimal byte
    !	    1 byte	minutes value
    !	    1 byte 	seconds type = unsigned decimal byte
    !	    1 byte	seconds value
    !
    (.NICE) <0, 16> = NMA$C_PCCN_LRP;
	BEGIN
	BIND
	    CODMUL_TYP = .NICE + 2 : BBLOCK,
	    DAY_TYP = .NICE + 3 : BBLOCK,
	    MON_TYP = .NICE + 5 : BBLOCK,
	    HR_TYP = .NICE + 7 : BBLOCK,
	    MIN_TYP = .NICE + 9 : BBLOCK,
	    SEC_TYP = .NICE + 11 : BBLOCK;

	CODMUL_TYP [NMA$V_PTY_COD] = TRUE;		! Last Report is returned as a coded 
	CODMUL_TYP [NMA$V_PTY_MUL] = TRUE;		!  multiple.
	CODMUL_TYP [NMA$V_PTY_CLE] = 5;			! There are five fields in the coded multiple

	EXECUTE ($NUMTIM (TIMBUF = TIMBUF, TIMADR = SID [SID$Q_LSTREPORT]) );

        DAY_TYP [NMA$V_PTY_NTY] = NMA$C_NTY_DU;	! Unsigned decimal
	DAY_TYP [NMA$V_PTY_NLE] = 1;		!  byte.
	(.NICE) <32, 8> = .TIMBUF [2];		! Day

	MON_TYP [NMA$V_PTY_COD] = TRUE;		! Month is returned as a coded value
	MON_TYP [NMA$V_PTY_CLE] = 1;		!   contained in 1 byte.
	(.NICE) <48, 8> = .TIMBUF [1];		! Month

        HR_TYP [NMA$V_PTY_NTY] = NMA$C_NTY_DU;	! Unsigned decimal
	HR_TYP [NMA$V_PTY_NLE] = 1;		!  byte.
	(.NICE) <64, 8> = .TIMBUF [3];		! Hour

        MIN_TYP [NMA$V_PTY_NTY] = NMA$C_NTY_DU;	! Unsigned decimal
	MIN_TYP [NMA$V_PTY_NLE] = 1;		!  byte.
	(.NICE) <80, 8> = .TIMBUF [4];		! Minute

        SEC_TYP [NMA$V_PTY_NTY] = NMA$C_NTY_DU;	! Unsigned decimal
	SEC_TYP [NMA$V_PTY_NLE] = 1;		!  byte.
	(.NICE) <96, 8> = .TIMBUF [5];		! Second
	END;
    NICE = .NICE + 13;


    !
    !	Place in Maintenance Version parameter
    !	as a coded multiple
    !
    !	    2 bytes	Maintenance Version parameter ID
    !	    1 byte	Maintenance Version type = coded multiple of 3 fields
    !	    1 byte	Version Number type = unsigned decimal byte
    !	    1 byte	Version Number value
    !	    1 byte 	ECO number type = unsigned decimal byte
    !	    1 byte	ECO number value
    !	    1 byte 	User ECO number type = unsigned decimal byte
    !	    1 byte	User ECO value
    !
    (.NICE) <0, 16> = NMA$C_PCCN_MVR;
	BEGIN
	BIND
	    CODMUL_TYP = .NICE + 2 : BBLOCK,
	    VN_TYP = .NICE + 3 : BBLOCK,
	    EN_TYP = .NICE + 5 : BBLOCK,
	    UEN_TYP = .NICE + 7 : BBLOCK;

	CODMUL_TYP [NMA$V_PTY_COD] = TRUE;		! Maintenance Version is returned as a coded 
	CODMUL_TYP [NMA$V_PTY_MUL] = TRUE;		!  multiple.
	CODMUL_TYP [NMA$V_PTY_CLE] = 3;			! There are three fields in the coded multiple

        VN_TYP [NMA$V_PTY_NTY] = NMA$C_NTY_DU;		! Unsigned decimal
	VN_TYP [NMA$V_PTY_NLE] = 1;			!  byte.
	(.NICE) <32, 8> = .SID [SID$B_MOPVER];		! MOP version

        EN_TYP [NMA$V_PTY_NTY] = NMA$C_NTY_DU;		! Unsigned decimal
	EN_TYP [NMA$V_PTY_NLE] = 1;			!  byte.
	(.NICE) <48, 8> = .SID [SID$B_MOPECO];		! MOP ECO

        UEN_TYP [NMA$V_PTY_NTY] = NMA$C_NTY_DU;		! Unsigned decimal
	UEN_TYP [NMA$V_PTY_NLE] = 1;			!  byte.
	(.NICE) <64, 8> = .SID [SID$B_MOPUSRECO];
	END;

    NICE = .NICE + 9;


    !
    !	Place in Functions parameter
    !	as a coded multiple
    !
    !	    2 bytes	Functions parameter ID
    !	    1 byte	Functions type = coded multiple of up to 16 fields
    !	    n bytes	Function type = Coded byte
    !
    !	    up to 16 functions permitted
    !

    IF .SID [SID$B_NUMFUNC] NEQ 0
    THEN
	BEGIN
	BIND
	    CODMUL_TYP = .NICE + 2 : BBLOCK,
	    FUNCTIONS = SID [SID$W_FUNCTIONS] : BITVECTOR [16];

	(.NICE) <0, 16> = NMA$C_PCCN_FCT;		! Place in Function paramter ID
	CODMUL_TYP [NMA$V_PTY_COD] = TRUE;		! Report is returned as a coded 
	CODMUL_TYP [NMA$V_PTY_MUL] = TRUE;		!   multiple.

	CODMUL_TYP [NMA$V_PTY_CLE] = .SID [SID$B_NUMFUNC];	! 16 fields are permitted in the coded multiple
	NICE = .NICE + 3;

	INCR INDEX FROM 0 TO SID$C_MAXFUNC - 1 DO
	    BEGIN
	    BIND
		FUN_TYP = .NICE : BBLOCK;

	    IF .FUNCTIONS [.INDEX]
	    THEN
		BEGIN
		FUN_TYP [NMA$V_PTY_COD] = TRUE;		! Functions are returned as a coded value
		FUN_TYP [NMA$V_PTY_CLE] = 1;		!   contained in 1 byte.
		(.NICE) <8, 8> = .INDEX;		! Place Function value in NICE message
		NICE = .NICE + 2;			! Advance to end of NICE buffer
		END;
	    END;
	END;

    !
    !	Place in Hardware Address parameter
    !	as a Hex Image 6
    !
    !	    2 bytes	Hardware Address parameter ID
    !	    1 byte	Hardware Address type = Hex Image (HI-6)
    !	    1 byte	Image length = 6
    !	    6 bytes	Hardware Address value
    !
    (.NICE) <0, 16> = NMA$C_PCCN_HWA;
	BEGIN
	BIND
	    TYPE = .NICE + 2 : BBLOCK;
	TYPE [NMA$V_PTY_NTY] = NMA$C_NTY_H;		! returned as a Hex
	TYPE [NMA$V_PTY_NLE] = NMA$C_NLE_IMAGE;		!   image
	END;
    (.NICE) <24,8> = SID$C_ADRLEN;			!   of length 6
    CH$MOVE (SID$C_ADRLEN, SID [SID$T_HRDWADR], (.NICE + 4) );
    NICE = .NICE + 4 + SID$C_ADRLEN;			! Set pointer to end of buffer where next parameter will be placed


    !
    !	Place in Device Type parameter
    !	as a coded value
    !
    !	    2 bytes	Device Type parameter ID
    !	    1 byte	Device Type type = coded byte
    !	    1 byte	Device Type code
    !
    (.NICE) <0, 16> = NMA$C_PCCN_DTY;
	BEGIN
	BIND
	    TYPE = .NICE + 2 : BBLOCK;
	TYPE [NMA$V_PTY_COD] = TRUE;		! Device Type is returned as a coded value
	TYPE [NMA$V_PTY_CLE] = 1;		! The coded value is 1 byte in length
	END;
    (.NICE) <24, 8> = .SID [SID$B_DEVICE];
    NICE = .NICE + 4;				! Set pointer to end of buffer where Elapsed Time will be placed

    NICEBUF [DSC$W_LENGTH] = .NICE - .NICEBUF [DSC$A_POINTER];

    RETURN TRUE;
    END;			! Routine show_system

END				! End of module CNFSHOW
ELUDOM
