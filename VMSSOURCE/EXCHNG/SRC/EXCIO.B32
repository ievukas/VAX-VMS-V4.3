MODULE	exch$io					%TITLE 'IO - Device and File I/O routines'
		(
		IDENT = 'V04-000',
		ADDRESSING_MODE (EXTERNAL=LONG_RELATIVE, NONEXTERNAL=WORD_RELATIVE)
		) =
BEGIN
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************

!++
! FACILITY:	EXCHANGE - Foreign volume interchange facility
!
! ABSTRACT:	IO - Device I/O Routines
!
! ENVIRONMENT:	VAX/VMS User mode
!
! AUTHOR:	CW Hobbs		CREATION DATE: 25-Aug-1982
!
! MODIFIED BY:
!
!	V03-003	CWH3003		CW Hobbs		21-Jul-1984
!		Remove a debugging message accidentally left in.
!
!	V03-002	CWH3002		CW Hobbs		12-Nov-1983
!		During read and write checking, make sure to do a $rewind
!		if the block is LBN 0.  Was giving spurious errors during
!		COPY /BOOT operations.
!
!--

! Include files:
!
MACRO $module_name_string = 'exch$io' %;	! The require file needs to know our module name
REQUIRE 'SRC$:EXCREQ'				! Facility-wide require file
    ;

%SBTTL 'Module table of contents'

! Module table of contents:
!
FORWARD ROUTINE
    exch$io_dos11_count_blocks,			! Count blocks to the next tape mark
    exch$io_dos11_read,				! Read a block on a dos-11 device
    exch$io_dos11_read_label,			! Read a label on a dos-11 device
    exch$io_dos11_rewind,			! Rewind a dos-11 sequential device
    exch$io_dos11_set_density,			! Set the density on a magtape device
    exch$io_dos11_skip_file,			! Skip files on a tape
    exch$io_dos11_skip_record,			! Skip records on a tape
    exch$io_dos11_write_label,			! Write a label on a dos-11 device
    exch$io_dos11_write_tape_mark,		! Write a single tape mark on an dos-11 device
    exch$io_rt11_read,				! Read blocks from block-addressable device
    exch$io_rt11_read_1,			! Read blocks one at a time from block-addressable device
    exch$io_rt11_write,				! Write blocks on block-addressable device
    exch$io_rt11_write_1			! Write blocks one at a time on block-addressable device
    ;

! EXCHANGE facility routines
!
EXTERNAL ROUTINE
    exch$util_file_error			! Signal file error
    ;

! Equated symbols:
!
!LITERAL
!    ;

! Bound declarations:
!
!BIND
!    ;

GLOBAL ROUTINE exch$io_dos11_count_blocks (volb : $ref_bblock) =  	%SBTTL 'exch$io_dos11_count_blocks (volb)'
BEGIN
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Count blocks until the next tape mark on a dos-11 sequential device
!
! INPUTS:
!
!	volb   - pointer to a volb which contains the active record stream
!
! IMPLICIT INPUTS:
!
!	dos11 context block hanging off the volb
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	dos11 context block hanging off the volb
!
! ROUTINE VALUE:
!
!	success or error status
!
! SIDE EFFECTS:
!
!	none
!--

$dbgtrc_prefix ('io_dos11_count_blocks> ');

LOCAL
    status
    ;

BIND
    dosv = volb [volb$a_vfmt_specific] : $ref_bblock	! Format specific block, contains iosb
    ;

$debug_print_lit ('entry');
$block_check (2, .volb, volb, 611);
$block_check (2, .dosv, dos11, 613);
$logic_check (2, (.dosv [dos11$v_position_valid]), 269);	! We should know where we are

! Start by assuming no blocks, the skip count includes the tape mark
!
dosv [dos11$w_block_count] = -1;

! Now start looping, we will return from the loop on error or tape mark
!
WHILE 1
DO
    BEGIN

    ! Issue the io operation to space in the forward direction
    !
    IF (status = $qiow (efn=0,
			chan=.volb [volb$w_channel],
			func=io$_skiprecord,
			iosb=dosv [dos11$q_iosb],
			p1=32767))
    THEN
	status = .dosv [dos11$w_iosb_status];

    ! Finish up based on the status
    !
    SELECTONE .status OF
    SET
	! Normal means we have a very large file, add the skip count to the blocks and continue to loop
	!
	[ss$_normal] :
			BEGIN

			! Count the blocks
			!
			dosv [dos11$w_block_count] = .dosv [dos11$w_block_count] + 32767;

			! Set the bits and pieces to reflect that the tape has moved
			!
			dosv [dos11$v_beg_of_tape] = false;
			dosv [dos11$v_end_of_tape] = false;
			dosv [dos11$v_tape_mark]   = false;
			END;

	! End of file means that we have found the end
	!
	[ss$_endoffile] :
			BEGIN

			! Count the blocks, and note that we are at the next file
			!
			dosv [dos11$w_block_count] = .dosv [dos11$w_block_count] + .dosv [dos11$w_iosb_skipcnt];
			dosv [dos11$l_current_file] = .dosv [dos11$l_current_file] + 1;

			! Set the bits and pieces to reflect that the tape has moved
			!
			dosv [dos11$v_beg_of_tape] = false;
			dosv [dos11$v_end_of_tape] = false;
			dosv [dos11$v_tape_mark]   = true;

			RETURN true;

			END;

	! If this is the end, oops
	!
	[ss$_endoftape] :
			BEGIN
			LOCAL
			    stat2;

			! Count the blocks, and note that we are at the next file
			!
			dosv [dos11$w_block_count] = .dosv [dos11$w_block_count] + .dosv [dos11$w_iosb_skipcnt];

			! Signal that we have had a problem
			!
			$exch_signal (exch$_dos11_ioerror, 2,
					.volb [volb$l_vol_ident_len], volb [volb$t_vol_ident], .status);

			! Rewind the tape so that the position will be known again
			!
			$exch_signal (exch$_dos11_position);			! This might take a while, warn 'em
			dosv [dos11$v_error_rewind] = true;
			IF NOT (stat2 = exch$io_dos11_rewind (.volb))
			THEN
			    RETURN .stat2;

			! Return the ss$_endoftape status
			!
			RETURN .status;

			END;

	! Any thing else and we'd better crap out
	!
	[OTHERWISE] :	BEGIN
			dosv [dos11$v_position_valid] = false;	! After an error, we don't know where we are
			$exch_signal_return (exch$_dos11_ioerror, 2,
					.volb [volb$l_vol_ident_len], volb [volb$t_vol_ident], .status);
			END;
    TES;

    END;

RETURN 0;
END;

GLOBAL ROUTINE exch$io_dos11_read (volb : $ref_bblock, buffer) =  %SBTTL 'exch$io_dos11_read'
BEGIN
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Read one block on a dos-11 sequential device
!
! INPUTS:
!
!	volb   - pointer to a volb which contains the active record stream
!
! IMPLICIT INPUTS:
!
!	dos11 context block hanging off the volb
!
! OUTPUTS:
!
!	buffer - pointer to the buffer to receive the block
!
! IMPLICIT OUTPUTS:
!
!	dos11 context block hanging off the volb
!
! ROUTINE VALUE:
!
!	success if label, false if not a label or error status
!
! SIDE EFFECTS:
!
!	none
!--

$dbgtrc_prefix ('io_dos11_read> ');

LOCAL
    func,
    status
    ;

BIND
    dosv = volb [volb$a_vfmt_specific] : $ref_bblock	! Format specific block, contains iosb
    ;

$debug_print_lit ('entry');
$block_check (2, .volb, volb, 625);
$block_check (2, .dosv, dos11, 626);
$check_call (4, exch$dbg_dump_dosv, .volb, (dmpdsv$m_status OR dmpdsv$m_position));
$logic_check (2, (.dosv [dos11$v_position_valid]), 279);	! We should know where we are
$logic_check (2, (NOT .dosv [dos11$v_tape_mark]), 280);		! And that should be right after a tape mark
$logic_check (2, (NOT .dosv [dos11$v_end_of_tape]), 281);	! But not at the end of the tape

! Issue the io operation to read the next logical block in the forward direction
!
func = io$_readlblk;
IF .volb [volb$v_read_check] THEN func = .func OR io$m_datacheck;
IF (status = $qiow (efn=0,
		    chan=.volb [volb$w_channel],
		    func=.func,
		    iosb=dosv [dos11$q_iosb],
		    p1=.buffer,
		    p2=512))
THEN
    status = .dosv [dos11$w_iosb_status];

! Finish up based on the status
!
SELECTONE .status OF
SET
    ! Status is normal
    !
    [ss$_normal] :	BEGIN

			! If the block isn't 512 bytes long, pad it with nulls
			!
			IF .dosv [dos11$w_iosb_bytecnt] NEQ 512
			THEN
			    BEGIN
			    LOCAL
				adr,
				len;
			    len = 512 - .dosv [dos11$w_iosb_bytecnt];
			    adr = .buffer + .dosv [dos11$w_iosb_bytecnt];
			    CH$FILL (0, .len, .adr);
			    END;

			! Set the bits and pieces to reflect that the tape has moved
			!
			dosv [dos11$v_end_of_tape] = false;
			dosv [dos11$v_beg_of_tape] = false;
			dosv [dos11$v_tape_mark]   = false;
			END;

    ! If the data is longer than the buffer, we have a bad tape format
    !
    [ss$_dataoverun] :	BEGIN
			dosv [dos11$v_position_valid] = false;	! After an error, we don't know where we are
			$exch_signal_return (exch$_dos11_blocksize, 2,
					.volb [volb$l_vol_ident_len], volb [volb$t_vol_ident]);
			END;

    ! We saw a tape mark (end of file status)
    !
    [ss$_endoffile] :	BEGIN
			$trace_print_lit ('got an SS$_ENDOFFILE');
			dosv [dos11$v_tape_mark] = true;
			END;

    ! If this is the end, oops
    !
    [ss$_endoftape] :	BEGIN
			LOCAL
			    stat2;

			! Signal that we have had a problem
			!
			$exch_signal (exch$_dos11_ioerror, 2,
					.volb [volb$l_vol_ident_len], volb [volb$t_vol_ident], .status);

			! Rewind the tape so that the position will be known again
			!
			$exch_signal (exch$_dos11_position);			! This might take a while, warn 'em
			dosv [dos11$v_error_rewind] = true;
			IF NOT (stat2 = exch$io_dos11_rewind (.volb))
			THEN
			    RETURN .stat2;

			! Return the ss$_endoftape status
			!
			END;

    ! Any thing else and we better crap out
    !
    [OTHERWISE] :	BEGIN
			dosv [dos11$v_position_valid] = false;	! After an error, we don't know where we are
			$exch_signal_return (exch$_dos11_ioerror, 2,
					.volb [volb$l_vol_ident_len], volb [volb$t_vol_ident], .status);
			END;
TES;

RETURN .status;
END;

GLOBAL ROUTINE exch$io_dos11_read_label (volb : $ref_bblock) =  	%SBTTL 'exch$io_dos11_read_label (volb)'
BEGIN
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Read a label on a dos-11 sequential device
!
! INPUTS:
!
!	volb   - pointer to a volb which contains the active record stream
!
! IMPLICIT INPUTS:
!
!	dos11 context block hanging off the volb
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	dos11 context block hanging off the volb
!
! ROUTINE VALUE:
!
!	success if label, false if not a label or error status
!
! SIDE EFFECTS:
!
!	none
!--

$dbgtrc_prefix ('io_dos11_read_label> ');

LOCAL
    func,
    status
    ;

BIND
    dosv = volb [volb$a_vfmt_specific] : $ref_bblock	! Format specific block, contains iosb
    ;

$debug_print_lit ('entry');
$block_check (2, .volb, volb, 602);
$block_check (2, .dosv, dos11, 603);
$logic_check (2, (.dosv [dos11$v_position_valid]), 257);	! We should know where we are
$logic_check (2, (.dosv [dos11$v_tape_mark]), 258);		! And that should be right after a tape mark
$logic_check (2, (NOT .dosv [dos11$v_end_of_tape]), 268);	! But not at the end of the tape

! Issue the io operation to read the next logical block in the forward direction
!
$logic_check (3, (dos11$s_label_buf EQL 14), 267);
func = io$_readlblk;
IF .volb [volb$v_read_check] THEN func = .func OR io$m_datacheck;
IF (status = $qiow (efn=0,
		    chan=.volb [volb$w_channel],
		    func=.func,
		    iosb=dosv [dos11$q_iosb],
		    p1=dosv [dos11$t_label_buf],
		    p2=dos11$s_label_buf))
THEN
    status = .dosv [dos11$w_iosb_status];

! Finish up based on the status
!
SELECTONE .status OF
SET
    ! Status is normal, make a cursory check that the label is the correct length.  There is little else we can
    ! do as far as checking, since just about anything that is 14 bytes long could be a valid label.
    !
    [ss$_normal] :	BEGIN

			! If the block isn't 14 bytes long, it is not a dos11 label
			!
			IF .dosv [dos11$w_iosb_bytecnt] NEQ 14
			THEN
			    BEGIN
			    dosv [dos11$v_position_valid] = false;	! After an error, we don't know where we are
			    $exch_signal_return (exch$_dos11_badlabel, 2,
					.volb [volb$l_vol_ident_len], volb [volb$t_vol_ident], .status);
			    END;

			! Set the bits and pieces to reflect that the tape has moved
			!
			dosv [dos11$v_beg_of_tape] = false;
			dosv [dos11$v_end_of_tape] = false;
			dosv [dos11$v_tape_mark]   = false;
			END;

    ! If the data is longer than the buffer, it is obviously not 14 bytes long, therefore we have a bad label
    !
    [ss$_dataoverun] :	BEGIN
			dosv [dos11$v_position_valid] = false;	! After an error, we don't know where we are
			$exch_signal_return (exch$_dos11_badlabel, 2,
					.volb [volb$l_vol_ident_len], volb [volb$t_vol_ident], .status);
			END;

    ! If this is a freshly initialized dos tape, we should see a tape mark (end of file status)
    !
    [ss$_endoffile] :	BEGIN
			$debug_print_lit ('got an SS$_ENDOFFILE');
			dosv [dos11$v_end_of_tape] = true;
			END;

    ! If this is the end, oops
    !
    [ss$_endoftape] :	BEGIN
			LOCAL
			    stat2;

			! Signal that we have had a problem
			!
			$exch_signal (exch$_dos11_ioerror, 2,
					.volb [volb$l_vol_ident_len], volb [volb$t_vol_ident], .status);

			! Rewind the tape so that the position will be known again
			!
			$exch_signal (exch$_dos11_position);			! This might take a while, warn 'em
			dosv [dos11$v_error_rewind] = true;
			IF NOT (stat2 = exch$io_dos11_rewind (.volb))
			THEN
			    RETURN .stat2;

			! Return the ss$_endoftape status
			!
			END;

    ! Any thing else and we better crap out
    !
    [OTHERWISE] :	BEGIN
			dosv [dos11$v_position_valid] = false;	! After an error, we don't know where we are
			$exch_signal_return (exch$_dos11_badlabel, 2,
					.volb [volb$l_vol_ident_len], volb [volb$t_vol_ident], .status);
			END;
TES;

RETURN .status;
END;

GLOBAL ROUTINE exch$io_dos11_rewind (volb : $ref_bblock) =  	%SBTTL 'exch$io_dos11_rewind (volb)'
BEGIN
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Rewind a dos-11 sequential device
!
! INPUTS:
!
!	volb   - pointer to a volb which contains the active record stream
!
! IMPLICIT INPUTS:
!
!	dos11 context block hanging off the volb
!
! OUTPUTS:
!
!	volb$v_beg_of_tape is set
!
! IMPLICIT OUTPUTS:
!
!	dos11 context block hanging off the volb
!
! ROUTINE VALUE:
!
!	success or error status
!
! SIDE EFFECTS:
!
!	none
!--

$dbgtrc_prefix ('io_dos11_rewind> ');

LOCAL
    status
    ;

BIND
    dosv = volb [volb$a_vfmt_specific] : $ref_bblock	! Format specific block, contains iosb
    ;

$debug_print_lit ('entry');
$block_check (2, .volb, volb, 600);
$block_check (2, .dosv, dos11, 601);

! Issue the io operation to rewind the device
!
IF (status = $qiow (efn=0,
		    chan=.volb [volb$w_channel],
		    func=io$_rewind,
		    iosb=dosv [dos11$q_iosb]))
THEN
    status = .dosv [dos11$w_iosb_status];

! If either the qio or the io operation failed, scream and shout
!
IF NOT .status
THEN
    BEGIN
    dosv [dos11$v_position_valid] = false;	! After an error, we don't know where we are
    $exch_signal_return (exch$_dos11_ioerror, 2,
				.volb [volb$l_vol_ident_len], volb [volb$t_vol_ident], .status);
    END;

! Set the bits and pieces to reflect that the tape is now at the beginning
!
dosv [dos11$l_current_file] = 0;		! BOT is first file (#0)
dosv [dos11$v_position_valid] = true;		! After a rewind, we know exactly where we are
dosv [dos11$v_beg_of_tape] = true;
dosv [dos11$v_end_of_tape] = false;
dosv [dos11$v_tape_mark]   = true;		! Make it look like we are sitting right after a tape mark

RETURN .status;
END;

GLOBAL ROUTINE exch$io_dos11_set_density (volb : $ref_bblock) =  	%SBTTL 'exch$io_dos11_set_density (volb)'
BEGIN
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Set the density on a tape device
!
! INPUTS:
!
!	volb   - pointer to a volb which contains the active record stream
!
! IMPLICIT INPUTS:
!
!	dos11 context block hanging off the volb
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	dos11 context block hanging off the volb
!
! ROUTINE VALUE:
!
!	success or error status
!
! SIDE EFFECTS:
!
!	drive density is set to the new value
!--

$dbgtrc_prefix ('io_dos11_set_density> ');

LOCAL
    dib : $bblock [12],				! First three longwords of dib
    dib_desc : VECTOR [2, LONG],		! A descriptor for the above
    status
    ;

BIND
    mtchr = dib [dib$l_devdepend] : $bblock [4],	! Characteristics field as structure
    dosv = volb [volb$a_vfmt_specific] : $ref_bblock	! Format specific block, contains iosb
    ;

$debug_print_lit ('entry');
$block_check (2, .volb, volb, 627);
$block_check (2, .dosv, dos11, 628);

! Get the device information
!
dib_desc [0] = 12;
dib_desc [1] = dib;
IF NOT (status = $getchn (chan=.volb [volb$w_channel], scdbuf=dib_desc))
THEN
    BEGIN
    LOCAL
	desc : VECTOR [2, LONG];
    desc [0] = .volb [volb$l_vol_ident_len];
    desc [1] = volb [volb$t_vol_ident];
    $exch_signal_stop (exch$_accessfail, 1, desc, .status);
    END;
$debug_print_fao ('devchar !XL, devclass !XB, devtype !XB, devbufsiz !UL, devdepend !XL', .dib [dib$l_devchar],
		.dib [dib$b_devclass], .dib [dib$b_devtype], .dib [dib$w_devbufsiz], .dib [dib$l_devdepend]);

! Set the new characteristics buffer
!
mtchr [mt$v_density] = (SELECTONE cli$_present OF	! Set the new density
			SET
			    [cli$present (%ASCID 'DENSITY.800')] :	mt$k_nrzi_800;
			    [cli$present (%ASCID 'DENSITY.1600')] :	mt$k_pe_1600;
			    [cli$present (%ASCID 'DENSITY.6250')] :	mt$k_gcr_6250;
			    [OTHERWISE] :				$logic_check (0, (false), 117);
			TES);

! Issue the setmode io operation to change the density
!
IF (status = $qiow (efn=0,
		    chan=.volb [volb$w_channel], 
		    func=io$_setmode,
		    iosb=dosv [dos11$q_iosb],
		    p1=dib [dib$b_devclass],
		    p2=8))
THEN
    status = .dosv [dos11$w_iosb_status];

! If either the qio or the io operation failed, scream and shout
!
IF NOT .status
THEN
    BEGIN
    dosv [dos11$v_position_valid] = false;	! After an error, we don't know where we are
    $exch_signal_return (exch$_dos11_ioerror, 2,
				.volb [volb$l_vol_ident_len], volb [volb$t_vol_ident], .status);
    END;

RETURN .status;
END;

GLOBAL ROUTINE exch$io_dos11_skip_file (volb : $ref_bblock, files) =  	%SBTTL 'exch$io_dos11_skip_file (volb, files)'
BEGIN
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Skip a given number of files
!
! INPUTS:
!
!	volb   - pointer to a volb which contains the active record stream
!	files  - number of files to skip (positive - skip forward, negative - skip reverse)
!
! IMPLICIT INPUTS:
!
!	dos11 context block hanging off the volb
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	dos11 context block hanging off the volb
!
! ROUTINE VALUE:
!
!	success or error status
!
! SIDE EFFECTS:
!
!	none
!--

$dbgtrc_prefix ('io_dos11_skip_file> ');

LOCAL
    skipc,
    iosb_skip,
    skip_adjust,
    status
    ;

BIND
    dosv = volb [volb$a_vfmt_specific] : $ref_bblock	! Format specific block, contains iosb
    ;

$debug_print_fao ('initial file count !SL', .files);
$block_check (2, .volb, volb, 614);
$block_check (2, .dosv, dos11, 612);
$logic_check (2, (.dosv [dos11$v_position_valid]), 270);	! We should know where we are

IF .files EQL 0
THEN
    RETURN 1;

! If the skip count is negative, we will have to skip one extra file and then space forward.  In addition, if
! we are at the end of tape we need an extra skip to get past the extra tapemark.  We assume that
! nobody will try to skipfile to file 0 (they should rewind instead).
!
IF (skipc = .files) LSS 0
THEN
    BEGIN
    skip_adjust = (IF .dosv [dos11$v_end_of_tape] THEN 2 ELSE 1);
    skipc = .skipc - .skip_adjust;
    END;

! Issue the io operation to skip to the next file
!
$debug_print_fao ('actual skip count !SL', .skipc);
IF (status = $qiow (efn=0,
		    chan=.volb [volb$w_channel],
		    func=io$_skipfile,
		    iosb=dosv [dos11$q_iosb],
		    p1=.skipc))
THEN
    status = .dosv [dos11$w_iosb_status];
iosb_skip = .dosv [dos11$w_iosb_skipcnt];	! Save skip count in case we do another I/O

! If either the qio or the io operation failed, scream and shout
!
IF  (NOT .status)
  AND
    (.status NEQ ss$_endofvolume)
THEN
    BEGIN
    dosv [dos11$v_position_valid] = false;	! After an error, we don't know where we are
    $exch_signal_return (exch$_dos11_ioerror, 2,
				.volb [volb$l_vol_ident_len], volb [volb$t_vol_ident], .status);
    END;

! If the skip was negative, we will be positioned right before the tapemark which precedes the file we want.
! Therefore, we must read that tapemark so that we will be positioned right before the label.
!
IF .skipc LSS 0
THEN
    BEGIN
    LOCAL
	buf : $bvector [32];

    iosb_skip = .iosb_skip - .skip_adjust;	! Adjust back to the desired skip

    ! Issue the io operation to skip over the tapemark
    !
    IF (status = $qiow (efn=0,
			chan=.volb [volb$w_channel],
			func=io$_readlblk,
			iosb=dosv [dos11$q_iosb],
			p1=buf,
			p2=32))
    THEN
	status = .dosv [dos11$w_iosb_status];

    ! If either the qio or the io operation failed, scream and shout
    !
    IF NOT .status
    THEN
	BEGIN
	IF .status NEQ ss$_endoffile
	THEN
	    BEGIN
	    dosv [dos11$v_position_valid] = false;	! After an error, we don't know where we are
	    $exch_signal_return (exch$_dos11_ioerror, 2,
				.volb [volb$l_vol_ident_len], volb [volb$t_vol_ident], .status);
	    END
	ELSE
	    status = ss$_normal;		! Turn endofvolume into normal, return the normal status
	END;
    END;

! Set the bits and pieces to reflect that the tape has moved
!
$debug_print_fao ('current file before !UL', .dosv [dos11$l_current_file]);
dosv [dos11$l_current_file] = .dosv [dos11$l_current_file] + (IF .skipc GEQ 0 THEN .iosb_skip ELSE -.iosb_skip);
$debug_print_fao ('current file after  !UL', .dosv [dos11$l_current_file]);
dosv [dos11$v_beg_of_tape] = false;	!?? might be true
dosv [dos11$v_tape_mark]   = true;

IF .status EQL ss$_endofvolume
THEN
    BEGIN
    status = true;				! Want a success status
    dosv [dos11$v_end_of_tape] = true;
    END
ELSE
    dosv [dos11$v_end_of_tape] = false;

RETURN .status;
END;

GLOBAL ROUTINE exch$io_dos11_skip_record (volb : $ref_bblock, records) =  	%SBTTL 'exch$io_dos11_skip_record (volb, records)'
BEGIN
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Skip a given number of physcial records on a dos-11 sequential device
!
! INPUTS:
!
!	volb    - pointer to a volb which contains the active record stream
!	records - number of records to skip (positive => forward, negative => backward)
!
! IMPLICIT INPUTS:
!
!	dos11 context block hanging off the volb
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	dos11 context block hanging off the volb
!
! ROUTINE VALUE:
!
!	success or error status
!
! SIDE EFFECTS:
!
!	none
!--

$dbgtrc_prefix ('io_dos11_skip_record> ');

LOCAL
    status
    ;

BIND
    dosv = volb [volb$a_vfmt_specific] : $ref_bblock	! Format specific block, contains iosb
    ;

$debug_print_lit ('entry');
$block_check (2, .volb, volb, 635);
$block_check (2, .dosv, dos11, 636);
$logic_check (2, (.dosv [dos11$v_position_valid]), 287);	! We should know where we are

! Start by assuming no records
!
dosv [dos11$w_block_count] = 0;

! Issue the io operation to space in the desired direction
!
IF (status = $qiow (efn=0,
		    chan=.volb [volb$w_channel],
		    func=io$_skiprecord,
		    iosb=dosv [dos11$q_iosb],
		    p1=.records))
THEN
    status = .dosv [dos11$w_iosb_status];

! Finish up based on the status
!
SELECTONE .status OF
SET
    [ss$_normal] :
		    BEGIN

		    ! Set the bits and pieces to reflect that the tape has moved
		    !
		    dosv [dos11$v_tape_mark]   = false;
		    dosv [dos11$v_end_of_tape] = false;

		    END;

    ! End of file means that we have found the end
    !
    [ss$_endoffile] :
		    BEGIN

		    status = true;		! Return true instead of endoffile

		    ! Set the bits and pieces to reflect that the tape has moved
		    !
		    dosv [dos11$v_tape_mark]   = true;
		    dosv [dos11$v_end_of_tape] = false;
		    dosv [dos11$l_current_file] = .dosv [dos11$l_current_file] + 1;

		    END;

    ! If this is the end, oops
    !
    [ss$_endoftape] :
		    BEGIN

		    ! Signal that we have had a problem
		    !
		    $exch_signal (exch$_dos11_ioerror, 2,
				    .volb [volb$l_vol_ident_len], volb [volb$t_vol_ident], .status);

		    ! Set the bits and pieces to reflect that the tape has moved
		    !
		    dosv [dos11$v_tape_mark]   = false;
		    dosv [dos11$v_end_of_tape] = true;
		    dosv [dos11$l_current_file] = .dosv [dos11$l_current_file] + 1;

		    END;

    ! Any thing else and we'd better crap out
    !
    [OTHERWISE] :   BEGIN
		    dosv [dos11$v_position_valid] = false;	! After an error, we don't know where we are
		    $exch_signal_return (exch$_dos11_ioerror, 2,
				    .volb [volb$l_vol_ident_len], volb [volb$t_vol_ident], .status);
		    END;
TES;

! Set position info common to all paths
!
dosv [dos11$v_beg_of_tape] = false;

! Count the blocks
!
dosv [dos11$w_block_count] = .dosv [dos11$w_iosb_skipcnt];

RETURN .status;
END;

GLOBAL ROUTINE exch$io_dos11_write (volb : $ref_bblock, buffer, len) =  %SBTTL 'exch$io_dos11_write (volb, buffer, len)'
BEGIN
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Write one block on a dos-11 sequential device
!
! INPUTS:
!
!	volb   - pointer to a volb which contains the active record stream
!	buffer - pointer to the buffer containing the block
!	len    - length of the buffer
!
! IMPLICIT INPUTS:
!
!	dos11 context block hanging off the volb
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	dos11 context block hanging off the volb
!
! ROUTINE VALUE:
!
!	success if label, false if not a label or error status
!
! SIDE EFFECTS:
!
!	none
!--

$dbgtrc_prefix ('io_dos11_write> ');

LOCAL
    func,
    io_len,
    status
    ;

BIND
    dosv = volb [volb$a_vfmt_specific] : $ref_bblock	! Format specific block, contains iosb
    ;

$debug_print_lit ('entry');
$block_check (2, .volb, volb, 569);
$block_check (2, .dosv, dos11, 596);
$logic_check (2, (.dosv [dos11$v_position_valid]), 272);	! We should know where we are
$logic_check (2, (NOT .dosv [dos11$v_tape_mark]), 282);		! And that not should be right after a tape mark
$logic_check (2, (.dosv [dos11$v_end_of_tape]), 288);		! But instead at the end of the tape

! The minimum size io to a tape is 14 bytes.  We assume that any shorter buffers are null padded to at least
! 14 bytes.  If the input length is 0 an outer routine has made a mistake.  In addition, all transfers are
! even length.
!
$logic_check (2, (.len NEQ 0), 290);		! Make sure it is non-zero
io_len = MAXU (.len, 14);			! Make sure it is at least 14 bytes long
IF .io_len <0,1,0> THEN io_len = .io_len + 1;	! If odd, then make it even
$logic_check (2, (.io_len LEQU 512), 291);	! Make sure it isn't too long

! Issue the io operation to write the next logical block in the forward direction
!
func = io$_writelblk;
IF .volb [volb$v_read_check] THEN func = .func OR io$m_datacheck;
IF (status = $qiow (efn=0,
		    chan=.volb [volb$w_channel],
		    func=.func,
		    iosb=dosv [dos11$q_iosb],
		    p1=.buffer,
		    p2=.io_len))
THEN
    status = .dosv [dos11$w_iosb_status];

! Finish up based on the status
!
SELECTONE .status OF
SET
    ! Status is normal
    !
    [ss$_normal] :	BEGIN

			! Set the bits and pieces to reflect that the tape has moved
			!
			dosv [dos11$v_beg_of_tape] = false;
			dosv [dos11$v_end_of_tape] = true;
			dosv [dos11$v_tape_mark]   = false;
			END;

    ! If this is the end, oops
    !
    [ss$_endoftape] :	BEGIN
			LOCAL
			    stat2;

			! Signal that we have had a problem
			!
			$exch_signal (exch$_dos11_ioerror, 2,
					.volb [volb$l_vol_ident_len], volb [volb$t_vol_ident], .status);

			! Set the bits and pieces to reflect that the tape has moved
			!
			dosv [dos11$v_beg_of_tape] = false;
			dosv [dos11$v_end_of_tape] = true;
			dosv [dos11$v_tape_mark]   = false;

			! Return the ss$_endoftape status
			!
			END;

    ! Any thing else and we better crap out
    !
    [OTHERWISE] :	BEGIN
			dosv [dos11$v_position_valid] = false;	! After an error, we don't know where we are
			$exch_signal_return (exch$_dos11_ioerror, 2,
					.volb [volb$l_vol_ident_len], volb [volb$t_vol_ident], .status);
			END;
TES;

RETURN .status;
END;

GLOBAL ROUTINE exch$io_dos11_write_label (volb : $ref_bblock, label_buf) =  	%SBTTL 'exch$io_dos11_write_label (volb, label_buf)'
BEGIN
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Write a label on a dos-11 sequential device
!
! INPUTS:
!
!	volb   - pointer to a volb which contains the active record stream
!	label_buf  - pointer to the label to be written
!
! IMPLICIT INPUTS:
!
!	dos11 context block hanging off the volb
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	dos11 context block hanging off the volb
!
! ROUTINE VALUE:
!
!	success if able to write, false if error status
!
! SIDE EFFECTS:
!
!	none
!--

$dbgtrc_prefix ('io_dos11_write_label> ');

LOCAL
    func,
    status
    ;

BIND
    dosv = volb [volb$a_vfmt_specific] : $ref_bblock	! Format specific block, contains iosb
    ;

$debug_print_lit ('entry');
$block_check (2, .volb, volb, 469);
$block_check (2, .dosv, dos11, 564);
$logic_check (2, (.dosv [dos11$v_position_valid]), 284);	! We should know where we are
$logic_check (2, (.dosv [dos11$v_tape_mark]), 285);		! And that should be at a tape mark

! Issue the io operation to write a logical block in the forward direction
!
$logic_check (3, (dos11$s_label_buf EQL 14), 286);
func = io$_writelblk;
IF .volb [volb$v_read_check] THEN func = .func OR io$m_datacheck;
IF (status = $qiow (efn=0,
		    chan=.volb [volb$w_channel],
		    func=.func,
		    iosb=dosv [dos11$q_iosb],
		    p1=.label_buf,
		    p2=dos11$s_label_buf))
THEN
    status = .dosv [dos11$w_iosb_status];

! Finish up based on the status
!
SELECTONE .status OF
SET
    ! Status is normal
    !
    [ss$_normal] :	BEGIN

			! Set the bits and pieces to reflect that the tape has moved
			!
			dosv [dos11$v_beg_of_tape] = false;
			dosv [dos11$v_end_of_tape] = true;
			dosv [dos11$v_tape_mark]   = false;
			END;

    ! If this is the end, oops
    !
    [ss$_endoftape] :	BEGIN
			LOCAL
			    stat2;

			! Signal that we have had a problem
			!
			$exch_signal (exch$_dos11_ioerror, 2,
					.volb [volb$l_vol_ident_len], volb [volb$t_vol_ident], .status);

			! Set the bits and pieces to reflect that the tape has moved
			!
			dosv [dos11$v_beg_of_tape] = false;
			dosv [dos11$v_end_of_tape] = true;
			dosv [dos11$v_tape_mark]   = false;

			! Return the ss$_endoftape status
			!
			END;

    ! Any thing else and we better crap out
    !
    [OTHERWISE] :	BEGIN
			dosv [dos11$v_position_valid] = false;	! After an error, we don't know where we are
			$exch_signal_return (exch$_dos11_ioerror, 2,
					.volb [volb$l_vol_ident_len], volb [volb$t_vol_ident], .status);
			END;
TES;

RETURN .status;
END;

GLOBAL ROUTINE exch$io_dos11_write_tape_mark (volb : $ref_bblock) =  	%SBTTL 'exch$io_dos11_write_tape_mark (volb)'
BEGIN
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Write a single tape mark on a dos-11 sequential device
!
! INPUTS:
!
!	volb   - pointer to a volb which contains the active record stream
!
! IMPLICIT INPUTS:
!
!	dos11 context block hanging off the volb
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	dos11 context block hanging off the volb
!
! ROUTINE VALUE:
!
!	success or error status
!
! SIDE EFFECTS:
!
!	none
!--

$dbgtrc_prefix ('io_dos11_write_tape_mark> ');

LOCAL
    status
    ;

BIND
    dosv = volb [volb$a_vfmt_specific] : $ref_bblock	! Format specific block, contains iosb
    ;

$debug_print_lit ('entry');
$block_check (2, .volb, volb, 606);
$block_check (2, .dosv, dos11, 607);
$logic_check (2, (.dosv [dos11$v_position_valid]), 271);	! We should know where we are

! Issue the io operation to write the tape mark
!
IF (status = $qiow (efn=0,
		    chan=.volb [volb$w_channel],
		    func=io$_writeof,
		    iosb=dosv [dos11$q_iosb]))
THEN
    status = .dosv [dos11$w_iosb_status];

! If either the qio or the io operation failed, scream and shout
!
IF NOT .status
  AND
   .status NEQ ss$_endoftape			! End of tape can be ignored
THEN
    BEGIN
    dosv [dos11$v_position_valid] = false;	! After an error, we don't know where we are
    $exch_signal_return (exch$_dos11_ioerror, 2,
				.volb [volb$l_vol_ident_len], volb [volb$t_vol_ident], .status);
    END;

! Set the bits and pieces to reflect what we did to the tape 
!
dosv [dos11$v_end_of_tape] = true;
dosv [dos11$v_tape_mark]   = true;

RETURN .status;
END;

GLOBAL ROUTINE exch$io_rt11_read (volb : $ref_bblock, 	%SBTTL 'exch$io_rt11_read (volb, pbn, cnt, adr)'
			      blkpbn, blkcnt, bufadr : $ref_bvector) =
BEGIN
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Read a range of "physical" blocks from the device.  Block
!	numbers are in the range 0 to MaxBlocks-1.
!
! INPUTS:
!
!	volb   - pointer to a volb which contains the active record stream
!	blkpbn - starting physical block number on device
!	blkcnt - number of blocks to read
!
! IMPLICIT INPUTS:
!
!	none
!
! OUTPUTS:
!
!	bufadr - pointer to buffer to receive the data
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	success or error status
!
! SIDE EFFECTS:
!
!	none
!--

$dbgtrc_prefix ('io_rt11_read> ');

LOCAL
    check_buf : $bvector [ctx$k_buffer_length],
    bytecnt,
    transferred,
    lbn,
    status
    ;

BIND
    fab = .volb [volb$a_fab] : $bblock,	! New name for File Access Block
    rab = .volb [volb$a_rab] : $bblock,	! New name for Record Access Block
    nam = .volb [volb$a_nam] : $bblock	! New name for NAM block
    ;

$block_check (2, .volb, volb, 527);
$trace_print_fao ('pbn!5UL,  cnt!3UL,  adr !XL,  volb !XL', .blkpbn, .blkcnt, .bufadr, .volb);

! Adjust the externally useful block count to the RMS required byte count
!
$logic_check (2, ((.blkcnt GTRU 0) AND (.blkcnt LEQU 127)), 140);
bytecnt = .blkcnt * 512;

! Return an end of file error if the request is past the end of the device
!
IF .blkpbn GEQU .volb [volb$l_volmaxblock]
THEN
    RETURN exch$util_file_error (exch$_readerr, rms$_eof, fab, 0);

! Adjust the externally useful "physical" block number to the RMS required
! logical block number
!
lbn = .blkpbn;					! Assume volume relative lbn.
IF .volb [volb$v_virtual]
THEN
    lbn = .lbn + 1;				! File-relative virtual block numbers

! See if the request is for block 0
!
IF .lbn EQL 0
THEN
    BEGIN

    ! Since BKT = 0 means sequential read, we must trick it with the
    ! documented technique of REWIND, then set BKT=0.
    !
    IF NOT (status = $rewind (rab = rab))
    THEN
	BEGIN
	$debug_print_lit ('rewind error');
	RETURN exch$util_file_error (exch$_readerr, .status, fab, .rab [rab$l_stv]);
	END;

    END;

! Set the RMS record stream buffer and block parameters
!
rab [rab$l_ubf] = .bufadr;			! User buffer address
rab [rab$w_usz] = .bytecnt;			! User buffer size
rab [rab$l_bkt] = .lbn;

! Read the chunk
!
IF NOT (status = $read (rab = rab))
THEN
    BEGIN
    $debug_print_fao ('error at lbn !UL     blk_cnt !UL', .rab [rab$l_bkt], .rab [rab$w_usz] / 512);
    $check_call (4, exch$util_file_error, exch$_readerr, .status, fab, .rab [rab$l_stv]);
    IF .status EQL rms$_rer
    THEN
	BEGIN
	LOCAL
	    stv,
	    stat_1;
	stv = .rab [rab$l_stv];
	stat_1 = exch$io_rt11_read_1 (.volb, .blkpbn, .blkcnt, .bufadr);
	IF .stat_1
	THEN
	    $exch_signal (exch$_readerrrec, 2, .volb [volb$l_vol_ident_len], volb [volb$t_vol_ident], 
						.status, .stv);
	RETURN .stat_1;
	END
    ELSE
	RETURN exch$util_file_error (exch$_readerr, .status, fab, .rab [rab$l_stv]);
    END;

transferred = .rab [rab$w_rsz];			! Save actual byte count
IF .transferred NEQ .bytecnt		!??shouldn't happen, but has been
THEN
    $print_fao ('transfer count error, requested !UL bytes, received !UL bytes, status !XL',
		.bytecnt, .transferred, .status);

! If read checking, reread the chunk and compare
!
IF .volb [volb$v_read_check]
THEN
    BEGIN
    LOCAL
	len;

    ! See if the request is for block 0, if so rewind
    !
    IF .lbn EQL 0
    THEN
	BEGIN
	IF NOT (status = $rewind (rab = rab))
	THEN
	    BEGIN
	    $debug_print_lit ('rewind error');
	    RETURN exch$util_file_error (exch$_readerr, .status, fab, .rab [rab$l_stv]);
	    END;
	END;

    len = .bytecnt;

    rab [rab$l_ubf] = check_buf;		! User buffer address
    rab [rab$w_usz] = .len;			! User buffer size
    rab [rab$l_bkt] = .lbn;

    ! Read the chunk again
    !
    IF NOT (status = $read (rab = rab))
    THEN
	BEGIN
	$trace_print_fao ('reread error at lbn !UL     blk_cnt !UL', .rab [rab$l_bkt], .rab [rab$w_usz] / 512);
	$check_call (4, exch$util_file_error, exch$_readcheck, .status, fab, .rab [rab$l_stv]);
	IF .status EQL rms$_rer
	THEN
	    BEGIN
	    LOCAL
		stv,
		stat_1;
	    stv = .rab [rab$l_stv];
	    stat_1 = exch$io_rt11_read_1 (.volb, .blkpbn, .blkcnt, .bufadr);
	    IF .stat_1
	    THEN
		$exch_signal (exch$_readcheckrec, 2, .volb [volb$l_vol_ident_len], volb [volb$t_vol_ident], 
						    .status, .stv);
	    RETURN .stat_1;
	    END
	ELSE
	    RETURN exch$util_file_error (exch$_readcheck, .status, fab, .rab [rab$l_stv]);
	END;

    IF CH$NEQ (.len, check_buf, .len, .bufadr, 0)
    THEN
	BEGIN
	%IF switch_trace
	%THEN
	    LITERAL
		chunk = 100;
	    LOCAL
		c,		! count of loops
		l,		! length of string remaining
		a1,		! address of remainder of string 1
		a2;		! address of remainder of string 2
	    c = 0;
	    l = .len;
	    a1 = .bufadr;
	    a2 = check_buf;
	    $trace_print_fao ('pbn!5UL,  cnt!3UL,  adr !XL,  volb !XL', .blkpbn, .blkcnt, .bufadr, .volb);
	    WHILE .l GTR 0
	    DO
		BEGIN
		LOCAL
		    ll;		! length for this loop
		c = .c + 1;
		ll = MINU (.l, chunk);
		IF CH$NEQ (.ll, .a1, .ll, .a2, 0)
		THEN
		    BEGIN
		    $trace_print_fao ('!4UL  "!AF"', .c, .ll, .a1);
		    $trace_print_fao ('      "!AF"', .ll, .a2);
		    END;
		l = .l - chunk;
		a1 = .a1 + chunk;
		a2 = .a2 + chunk;
		END;
	%FI
	BEGIN
	LOCAL
	    stat_1;
	stat_1 = exch$io_rt11_read_1 (.volb, .blkpbn, .blkcnt, .bufadr);
	IF .stat_1
	THEN
	    $exch_signal (exch$_readcheckrec, 2, .volb [volb$l_vol_ident_len], volb [volb$t_vol_ident]);
	RETURN .stat_1;
	END;
	END;
    END;

! Check to make sure that the correct number of bytes was found
!
IF .transferred NEQ .bytecnt
THEN
    $logic_check (0, (false), 315);	! This error should not occur

RETURN .status;
END;

GLOBAL ROUTINE exch$io_rt11_read_1 (volb : $ref_bblock, 	%SBTTL 'exch$io_rt11_read_1 (volb, pbn, cnt, adr)'
			      blkpbn, blkcnt, bufadr : $ref_bvector) =
BEGIN
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Read a range of "physical" blocks from the device.  Block numbers are in the range 0 to MaxBlocks-1.  
!	Blocks are read one at a time to try to locate bad blocks
!
! INPUTS:
!
!	volb   - pointer to a volb which contains the active record stream
!	blkpbn - starting physical block number on device
!	blkcnt - number of blocks to read
!
! IMPLICIT INPUTS:
!
!	none
!
! OUTPUTS:
!
!	bufadr - pointer to buffer to receive the data
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	success or error status
!
! SIDE EFFECTS:
!
!	none
!--

$dbgtrc_prefix ('io_rt11_read_1> ');

LOCAL
    check_buf : $bvector [512],
    adr,
    lbn,
    status
    ;

BIND
    fab = .volb [volb$a_fab] : $bblock,	! New name for File Access Block
    rab = .volb [volb$a_rab] : $bblock,	! New name for Record Access Block
    nam = .volb [volb$a_nam] : $bblock	! New name for NAM block
    ;

$block_check (2, .volb, volb, 563);
$trace_print_fao ('pbn!5UL,  cnt!3UL,  adr !XL,  volb !XL', .blkpbn, .blkcnt, .bufadr, .volb);

$logic_check (2, ((.blkcnt GTRU 0) AND (.blkcnt LEQU 127)), 205);

! Adjust the externally useful "physical" block number to the RMS required
! logical block number
!
$logic_check (2, (.blkpbn LSSU .volb [volb$l_volmaxblock]), 213);
lbn = .blkpbn;					! Assume volume relative lbn.
IF .volb [volb$v_virtual]
THEN
    lbn = .lbn + 1;				! File-relative virtual block numbers

! See if the request is for block 0
!
IF .lbn EQL 0
THEN
    BEGIN

    ! Since BKT = 0 means sequential read, we must trick it with the
    ! documented technique of REWIND, then set BKT=0.
    !
    IF NOT (status = $rewind (rab = rab))
    THEN
	BEGIN
	$debug_print_lit ('rewind error');
	RETURN exch$util_file_error (exch$_readerr, .status, fab, .rab [rab$l_stv]);
	END;

    END;

! Prepare for the loop
!
rab [rab$w_usz] = 512;				! User buffer size
adr = .bufadr;

DECR cnt FROM .blkcnt-1 TO 0
DO
    BEGIN

    ! Set the RMS record stream buffer and block parameters
    !
    rab [rab$l_ubf] = .adr;			! User buffer address
    rab [rab$l_bkt] = .lbn;

    ! Read the chunk
    !
    IF NOT (status = $read (rab = rab))
    THEN
	BEGIN
	$trace_print_fao ('error at lbn !UL     blk_cnt !UL', .rab [rab$l_bkt], .rab [rab$w_usz] / 512);
	RETURN exch$util_file_error (exch$_readerr, .status, fab, .rab [rab$l_stv]);
	END;

    ! If read checking, reread the chunk and compare
    !
    IF .volb [volb$v_read_check]
    THEN
	BEGIN
	LOCAL
	    tmp_desc : VECTOR [2, LONG],
	    len;

	! See if the request is for block 0, if so rewind
	!
	IF .lbn EQL 0
	THEN
	    BEGIN
	    IF NOT (status = $rewind (rab = rab))
	    THEN
		BEGIN
		$debug_print_lit ('rewind error');
		RETURN exch$util_file_error (exch$_readerr, .status, fab, .rab [rab$l_stv]);
		END;
	    END;

	len = 512;

	rab [rab$l_ubf] = check_buf;		! User buffer address
	rab [rab$w_usz] = .len;			! User buffer size
	rab [rab$l_bkt] = .lbn;

	! Read the chunk again
	!
	IF NOT (status = $read (rab = rab))
	THEN
	    BEGIN
	    $trace_print_fao ('reread error at lbn !UL     blk_cnt !UL', .rab [rab$l_bkt], .rab [rab$w_usz] / 512);
	    RETURN exch$util_file_error (exch$_readcheck, .status, fab, .rab [rab$l_stv]);
	    END;

	IF CH$NEQ (.len, check_buf, .len, .adr, 0)
	THEN
	    BEGIN
	    %IF switch_trace
	    %THEN
		LITERAL
		    chunk = 100;
		LOCAL
		    c,		! count of loops
		    l,		! length of string remaining
		    a1,		! address of remainder of string 1
		    a2;		! address of remainder of string 2
		c = 0;
		l = .len;
		a1 = .adr;
		a2 = check_buf;
		$trace_print_fao ('pbn!5UL,  cnt!3UL,  adr !XL,  volb !XL', .blkpbn, .blkcnt, .adr, .volb);
		WHILE .l GTR 0
		DO
		    BEGIN
		    LOCAL
			ll;		! length for this loop
		    c = .c + 1;
		    ll = MINU (.l, chunk);
		    IF CH$NEQ (.ll, .a1, .ll, .a2, 0)
		    THEN
			BEGIN
			$trace_print_fao ('!4UL  "!AF"', .c, .ll, .a1);
			$trace_print_fao ('      "!AF"', .ll, .a2);
			END;
		    l = .l - chunk;
		    a1 = .a1 + chunk;
		    a2 = .a2 + chunk;
		    END;
	    %FI
	    tmp_desc [0] = .volb [volb$l_vol_ident_len];
	    tmp_desc [1] = volb [volb$t_vol_ident];
	    $exch_signal_return (exch$_readcheck, 1, tmp_desc);
	    END;

	END;

    ! Move to the next block
    !
    adr = .adr + 512;
    lbn = .lbn + 1;

    END;

RETURN .status;
END;

GLOBAL ROUTINE exch$io_rt11_write (volb : $ref_bblock, 	%SBTTL 'exch$io_rt11_write (volb, pbn, cnt, adr)'
				   blkpbn, blkcnt, bufadr : $ref_bvector) =
BEGIN
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Write a range of "physical" blocks to a random access device.  Block
!	numbers are in the range 0 to MaxBlocks-1.
!
! INPUTS:
!
!	volb   - pointer to a volb which contains the active record stream
!	blkpbn - starting physical block number on device
!	blkcnt - number of blocks to write
!	bufadr - pointer to buffer containing the data
!
! IMPLICIT INPUTS:
!
!	none
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	success or error status
!
! SIDE EFFECTS:
!
!	none
!--

$dbgtrc_prefix ('io_rt11_write> ');

LOCAL
    check_buf : $bvector [ctx$k_buffer_length],
    bytecnt,
    lbn,
    status
    ;

BIND
    fab = .volb [volb$a_fab] : $bblock,	! New name for File Access Block
    rab = .volb [volb$a_rab] : $bblock,	! New name for Record Access Block
    nam = .volb [volb$a_nam] : $bblock	! New name for NAM block
    ;

$block_check (2, .volb, volb, 428);
$logic_check (2, (.volb [volb$v_write]), 145);	! We shouldn't get this far if we aren't supposed to write to it

$trace_print_fao ('  pbn!5UL,  cnt!3UL,  adr !XL,  volb !XL', .blkpbn, .blkcnt, .bufadr, .volb);

! Adjust the externally useful block count to the RMS required byte count
!
$logic_check (2, ((.blkcnt GTRU 0) AND (.blkcnt LEQU 127)), 112);
bytecnt = .blkcnt * 512;

! Adjust the externally useful "physical" block number to the RMS required
! logical block number
!
$logic_check (2, (.blkpbn LSSU .volb [volb$l_volmaxblock]), 113);
lbn = .blkpbn;					! Assume volume relative lbn.
IF .volb [volb$v_virtual]
THEN
    lbn = .lbn + 1;				! File-relative virtual block numbers

! See if the request is for block 0
!
IF .lbn EQL 0
THEN
    BEGIN

    ! Since BKT = 0 means sequential read, we must trick it with the
    ! documented technique of REWIND, then set BKT=0.
    !
    IF NOT (status = $rewind (rab = rab))
    THEN
	BEGIN
	$debug_print_lit ('rewind error');
	RETURN exch$util_file_error (exch$_writeerr, .status, fab, .rab [rab$l_stv]);
	END;

    END;

! Set the RMS record stream buffer and block parameters
!
rab [rab$l_rbf] = .bufadr;			! Record buffer address
rab [rab$w_rsz] = .bytecnt;			! Record buffer size
rab [rab$l_bkt] = .lbn;

! Write the chunk
!
IF NOT (status = $write (rab = rab))
THEN
    BEGIN
    $trace_print_fao ('error at lbn !UL     blk_cnt !UL', .rab [rab$l_bkt], .rab [rab$w_rsz] / 512);
    $check_call (4, exch$util_file_error, exch$_writeerr, .status, fab, .rab [rab$l_stv]);

    ! If the error is a simple WER write error, try to rewrite it using single block I/O
    !
    IF .status EQL rms$_wer
    THEN
	BEGIN
	LOCAL
	    stv,
	    stat_1;
	stv = .rab [rab$l_stv];
	stat_1 = exch$io_rt11_write_1 (.volb, .blkpbn, .blkcnt, .bufadr);
	IF .stat_1
	THEN
	    $exch_signal (exch$_writeerrrec, 2, .volb [volb$l_vol_ident_len], volb [volb$t_vol_ident], 
						.status, .stv);
	RETURN .stat_1;
	END

    ! If the error is anything else, signal it and return
    !
    ELSE
	RETURN exch$util_file_error (exch$_writeerr, .status, fab, .rab [rab$l_stv]);
    END;

! If write checking, reread the chunk and compare
!
IF .volb [volb$v_write_check]
THEN
    BEGIN
    LOCAL
	len;

    ! See if the request is for block 0, if so rewind
    !
    IF .lbn EQL 0
    THEN
	BEGIN
	IF NOT (status = $rewind (rab = rab))
	THEN
	    BEGIN
	    $debug_print_lit ('rewind error');
	    RETURN exch$util_file_error (exch$_readerr, .status, fab, .rab [rab$l_stv]);
	    END;
	END;

    len = .bytecnt;

    rab [rab$l_ubf] = check_buf;		! User buffer address
    rab [rab$w_usz] = .len;
    rab [rab$l_bkt] = .lbn;

    ! Read the chunk again
    !
    IF NOT (status = $read (rab = rab))
    THEN
	BEGIN
	$trace_print_fao ('reread error at lbn !UL     blk_cnt !UL', .rab [rab$l_bkt], .rab [rab$w_usz] / 512);
	$check_call (4, exch$util_file_error, exch$_writecheck, .status, fab, .rab [rab$l_stv]);
	IF .status EQL rms$_rer
	THEN
	    BEGIN
	    LOCAL
		stv,
		stat_1;
	    stv = .rab [rab$l_stv];
	    stat_1 = exch$io_rt11_write_1 (.volb, .blkpbn, .blkcnt, .bufadr);
	    IF .stat_1
	    THEN
		$exch_signal (exch$_writecheckrec, 2, .volb [volb$l_vol_ident_len], volb [volb$t_vol_ident], 
						    .status, .stv);
	    RETURN .stat_1;
	    END
	ELSE
	    RETURN exch$util_file_error (exch$_writecheck, .status, fab, .rab [rab$l_stv]);
	END;

    IF CH$NEQ (.len, check_buf, .len, .bufadr, 0)
    THEN
	BEGIN
	%IF switch_trace
	%THEN
	    LITERAL
		chunk = 100;
	    LOCAL
		c,		! count of loops
		l,		! length of string remaining
		a1,		! address of remainder of string 1
		a2;		! address of remainder of string 2
	    c = 0;
	    l = .len;
	    a1 = .bufadr;
	    a2 = check_buf;
	    $trace_print_fao ('pbn!5UL,  cnt!3UL,  adr !XL,  volb !XL', .blkpbn, .blkcnt, .bufadr, .volb);
	    WHILE .l GTR 0
	    DO
		BEGIN
		LOCAL
		    ll;		! length for this loop
		c = .c + 1;
		ll = MINU (.l, chunk);
		IF CH$NEQ (.ll, .a1, .ll, .a2, 0)
		THEN
		    BEGIN
		    $trace_print_fao ('!4UL  "!AF"', .c, .ll, .a1);
		    $trace_print_fao ('      "!AF"', .ll, .a2);
		    END;
		l = .l - chunk;
		a1 = .a1 + chunk;
		a2 = .a2 + chunk;
		END;
	%FI
	BEGIN
	LOCAL
	    stat_1;
	stat_1 = exch$io_rt11_write_1 (.volb, .blkpbn, .blkcnt, .bufadr);
	IF .stat_1
	THEN
	    $exch_signal (exch$_writecheckrec, 2, .volb [volb$l_vol_ident_len], volb [volb$t_vol_ident]);
	RETURN .stat_1;
	END;
	END;
    END;

RETURN .status;
END;

GLOBAL ROUTINE exch$io_rt11_write_1 (volb : $ref_bblock, 	%SBTTL 'exch$io_rt11_write_1 (volb, pbn, cnt, adr)'
				   blkpbn, blkcnt, bufadr : $ref_bvector) =
BEGIN
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	Write a range of "physical" blocks to a random access device.  Block
!	numbers are in the range 0 to MaxBlocks-1.  Blocks are written one at
!	a time to find exact pbns of bad blocks
!
! INPUTS:
!
!	volb   - pointer to a volb which contains the active record stream
!	blkpbn - starting physical block number on device
!	blkcnt - number of blocks to write
!	bufadr - pointer to buffer containing the data
!
! IMPLICIT INPUTS:
!
!	none
!
! OUTPUTS:
!
!	none
!
! IMPLICIT OUTPUTS:
!
!	none
!
! ROUTINE VALUE:
!
!	success or error status
!
! SIDE EFFECTS:
!
!	none
!--

$dbgtrc_prefix ('io_rt11_write_1> ');

LOCAL
    check_buf : $bvector [512],
    adr,
    lbn,
    status
    ;

BIND
    fab = .volb [volb$a_fab] : $bblock,	! New name for File Access Block
    rab = .volb [volb$a_rab] : $bblock,	! New name for Record Access Block
    nam = .volb [volb$a_nam] : $bblock	! New name for NAM block
    ;

$block_check (2, .volb, volb, 562);
$logic_check (2, (.volb [volb$v_write]), 170);	! We shouldn't get this far if we aren't supposed to write to it

$trace_print_fao ('  pbn!5UL,  cnt!3UL,  adr !XL,  volb !XL', .blkpbn, .blkcnt, .bufadr, .volb);

$logic_check (2, ((.blkcnt GTRU 0) AND (.blkcnt LEQU 127)), 185);

! Adjust the externally useful "physical" block number to the RMS required
! logical block number
!
$logic_check (2, (.blkpbn LSSU .volb [volb$l_volmaxblock]), 193);
lbn = .blkpbn;					! Assume volume relative lbn.
IF .volb [volb$v_virtual]
THEN
    lbn = .lbn + 1;				! File-relative virtual block numbers

! See if the request is for block 0
!
IF .lbn EQL 0
THEN
    BEGIN

    ! Since BKT = 0 means sequential read, we must trick it with the
    ! documented technique of REWIND, then set BKT=0.
    !
    IF NOT (status = $rewind (rab = rab))
    THEN
	BEGIN
	$debug_print_lit ('rewind error');
	RETURN exch$util_file_error (exch$_writeerr, .status, fab, .rab [rab$l_stv]);
	END;

    END;

! Prepare for the loop
!
rab [rab$w_rsz] = 512;				! Record buffer size
adr = .bufadr;

DECR cnt FROM .blkcnt-1 TO 0
DO
    BEGIN

    ! Set the RMS record stream buffer and block parameters
    !
    rab [rab$l_rbf] = .adr;			! Record buffer address
    rab [rab$l_bkt] = .lbn;

    ! Write the chunk
    !
    IF NOT (status = $write (rab = rab))
    THEN
	BEGIN
	$trace_print_fao ('error at lbn !UL     blk_cnt !UL', .rab [rab$l_bkt], .rab [rab$w_rsz] / 512);
	RETURN exch$util_file_error (exch$_writeerr, .status, fab, .rab [rab$l_stv]);
	END;

    ! If write checking, reread the chunk and compare
    !
    IF .volb [volb$v_write_check]
    THEN
	BEGIN
	LOCAL
	    tmp_desc : VECTOR [2, LONG],
	    len;

	! See if the request is for block 0, if so rewind
	!
	IF .lbn EQL 0
	THEN
	    BEGIN
	    IF NOT (status = $rewind (rab = rab))
	    THEN
		BEGIN
		$debug_print_lit ('rewind error');
		RETURN exch$util_file_error (exch$_readerr, .status, fab, .rab [rab$l_stv]);
		END;
	    END;

	len = 512;

	rab [rab$l_ubf] = check_buf;		! User buffer address
	rab [rab$w_usz] = .len;
	rab [rab$l_bkt] = .lbn;

	! Read the chunk again
	!
	IF NOT (status = $read (rab = rab))
	THEN
	    BEGIN
	    $trace_print_fao ('reread error at lbn !UL     blk_cnt !UL', .rab [rab$l_bkt], .rab [rab$w_usz] / 512);
	    RETURN exch$util_file_error (exch$_writecheck, .status, fab, .rab [rab$l_stv]);
	    END;

	IF CH$NEQ (.len, check_buf, .len, .adr, 0)
	THEN
	    BEGIN
	    %IF switch_trace
	    %THEN
		LITERAL
		    chunk = 100;
		LOCAL
		    c,		! count of loops
		    l,		! length of string remaining
		    a1,		! address of remainder of string 1
		    a2;		! address of remainder of string 2
		c = 0;
		l = .len;
		a1 = .adr;
		a2 = check_buf;
		$trace_print_fao ('pbn!5UL,  cnt!3UL,  adr !XL,  volb !XL', .blkpbn, .blkcnt, .adr, .volb);
		WHILE .l GTR 0
		DO
		    BEGIN
		    LOCAL
			ll;		! length for this loop
		    c = .c + 1;
		    ll = MINU (.l, chunk);
		    IF CH$NEQ (.ll, .a1, .ll, .a2, 0)
		    THEN
			BEGIN
			$trace_print_fao ('!4UL  "!AF"', .c, .ll, .a1);
			$trace_print_fao ('      "!AF"', .ll, .a2);
			END;
		    l = .l - chunk;
		    a1 = .a1 + chunk;
		    a2 = .a2 + chunk;
		    END;
	    %FI
	    tmp_desc [0] = .volb [volb$l_vol_ident_len];
	    tmp_desc [1] = volb [volb$t_vol_ident];
	    $exch_signal (exch$_writecheck, 1, tmp_desc);
	    RETURN 1;
	    END;

	END;

    ! Move to the next block
    !
    adr = .adr + 512;
    lbn = .lbn + 1;

    END;

RETURN .status;
END;

END
ELUDOM
