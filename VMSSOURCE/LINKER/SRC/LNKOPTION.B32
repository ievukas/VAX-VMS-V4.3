module lnk_procoptions 
		(ident = 'V04-000'
		,addressing_mode 
			(external    = general
			,nonexternal = long_relative
		)	) =
begin

%title 'Linker options parser'
;
!
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
!
!
!
!

!++
!
! MODULE: LNK_PROCOPTIONS
!
! FACILITY: LINKER
!
! ABSTRACT: Options processing
!
! HISTORY:
!
!    VERSION: V03-001
!
!    AUTHOR: B. Schreiber, 10-Jul-1980
!
!    MODIFIED BY:
!
!	V03-33	ADE0003		Alan D. Eldridge	13-Aug-1984
!		Always save options file input in an OEB.  It was only 
!		being done if LNK$V_LONG was set, but that flag doesn't 
!		get set until after the routines in this module have executed.
!
!	V03-032	ADE0002		Alan D. Eldirdge	 6-Aug-1984
!		Add LNK$GL_UNSUPPORTED support.  This is a mask settable
!		from the options file, and is used at this time solely to
!		enable demand zero ISD's in shareable images.
!
!	V03-031	ADE0001		Alan D. Eldridge	29-Jun-1984
!		Remove improper complaint about DZRO_MIN option being
!		ignored for shareable images.
!
!	V03-030	JWT0156		Jim Teague		20-Feb-1984
!		The SYMBOL option and the UNIVERSAL option don't
!		play together very well.  Declaring a symbol 
!		by the SYMBOL option followed by making it
!		UNIVERSAL would yield an undefined symbol.
!		However, reversing the order would cause an
!		access violation.  
!	
!	V03-029	JWT0149		Jim Teague		21-Dec-1983
!		Allow the characters "$" and "_" in directory specs.
!
!	V03-028 MCN0001		Maria del C. Nasr	25-Jul-1983
!		If SET VERIFY is on and option file is being read from
!		SYS$INPUT, do not echo line to output.  DCL is doing
!		that now.
!
!	V03-027	JWT0125		Jim Teague		21-Jun-1983
!		Reincarnate UNIV=* when accompanied by /NOEXE.
!
!	V03-026	JWT0123		Jim Teague		27-May-1983
!		Add message for UNIV=*.
!
!	V03-025	JWT0121		Jim Teague		20-May-1983
!		Sound the death knell for UNIVERSAL=*.
!
!	V03-024 JWT0108		Jim Teague		13-Mar-1983
!		Adjustments to new CLI interface.
!
!	V03-023	JWT0099		Jim Teague		14-Mar-1983
!		New CLI interface.
!
!	V03-022	JWT0071		Jim Teague		02-Dec-1982
!		Added NAME and IDENTIFICATION options.
!
!	V03-021 JWT0050		Jim Teague		10-Aug-1982
!		Add IMAGE_TYPE option with CLI value.
!
!	V03-020 JWT0034		Jim Teague 		25-May-1982
!		Remove the GSMATCH "NEVER" option.
!
!--

%sbttl 'Declarations'
;
!
! Include files:
!

library 'LIBL32';				!System macros

library 'TPAMACL32';				!TPARSE macros

library 'DATBAS';				!Linker data structures

require 'PREFIX';				!Linker macros

forward routine
    readoption,					!Read record from options file
    set_alluniv,				!Set all universal temporarily
    scanline,					!Collapse continuation lines
    set_base,					!Set image base
    set_channels,				!Set number of I/O channels
    set_unsupported,				!Set 'unsupported features' mask
    insertcluster,				!Insert cluster in cluster list
    processfile,				!Process a file specification
    getfilename,				!Extract filename portion of file specification
    search_insert_symbol,			!Lookup/insert a symbol into symbol table
    crossref_symbol,				!Enter symbol into cross reference
    set_universal,				!Process universal symbols
    definesymbolname,				!Process symbol name part of defining a symbol
    definesymbolval,				!Process value part of defining a symbol
    createpsect,				!Create a psect
    createcluster,				!Create a cluster
    setclusterbase,				!Set the base address of a cluster
    setclusterpfc,				!Set page fault factor for cluster
    clusterdone,				!Finish cluster option processing
    set_collect,				!Start collecting psects into clusters
    collect_psect,				!Collect a psect into a cluster
    set_gsmatch_ctl,				!Store match control part of GSMATCH option
    set_gsmatch_maj,				!Store major id of GSMATCH
    set_gsmatch_min,				!Store minor id of GSMATCH
    set_min_dzro,				!Store dzro_min option data
    set_isd_max,				!Store isd_max option data
    set_ioseg,					!Set size of I/O segment
    set_pscatrib,				!Set psect attributes
    set_p0bufs,					!Set/clear nop0bufs flag
    set_protect,				!Set protect flag
    set_shl,					!Set shl_extra option
    set_stack,					!Set stack option
    set_include,				!Set /include qualifier
    set_library,				!Set /library qualifier
    set_selective,				!Set /selective qualifier
    set_shareable,				!Set /shareable qualifier
    set_shrcopyflag,				!Set copy / nocopy flag for /shareable qualifier
    set_qual_flags,				!Set bits for qualifiers
    set_image_type,				!Set image type bit
    set_image_ident,				!Set image file identification
    set_image_name,				!Set image name
    search_insert_list,				!Search linked list for name
    namelengthcheck,				!Check max length of name
    debug_stop,					!Stop to look at tparse tables
    missingargerr,				!Argument missing for option
    optionvaluerr,				!Value out of range error
    syntaxerr;					!Report syntax error

!
! External references
!
external routine
    inputfile,					!Process input file
    crf$insrtref,				!Insert cross reference reference
    crf$insrtkey,				!Insert key into cross reference
    lib$insert_tree,				!Insert into balanced binary tree
    lib$lookup_tree,				!Lookup in balanced binary tree
    lnk$alloblk,				!Allocate dynamic memory
    lnk$alloc_pdd,				!Allocate psect def. descriptor
    lnk$allocluster,				!Allocate a cluster descriptor
    lnk$compare_pdd,				!Compare names in psect def. descriptor
    lnk$clunamcmp,				!Compare cluster name routine
    lnk$insert_clu,				!Insert cluster into cluster tree
    lnk$dealblk,				!Deallocate dynamic memory
    lnk$insudfsym,				!Insert a symbol into the undefined list
    lnk$insert,					!Insert a symbol into symbol table
    lnk$search,					!Search symbol table for symbol
    lnk$setlibrin,				!Set input file as a library
    lnk$setshrblin,				!Set input file as a shareable image
    lnk$upcase_d,				!Convert string to upper case
    lib$put_output,				!Write to SYS$OUTPUT
    lib$tparse,					!Table driver parser
    sys$fao;					!Formatted ASCII output

external
    lnk$gb_matchctl	: byte,			!Global section match control
    lnk$gl_matchid	: bblock,		!Global section match
    lnk$gl_defclu	: bblock,		!Default cluster descriptor
    lnk$gl_curclu	: ref bblock,		!Pointer to current cluster descriptor
    lnk$gl_clutree,				!Tree head for cluster tree
    lnk$gl_ctlmsk	: bblock,		!Linker control flags
    lnk$gl_fvmlst	: ref bblock,		!Listhead of free VM
    lnk$gw_stack	: word,			!Size of stack
    lnk$gt_pscstring,				!ASCIC string that says PSECT
    lnk$gt_clustring,				! or cluster
    lnk$gt_symstring,				! or string
    lnk$gt_imgnam	: vector [, byte],	!Image name field
    lnk$gt_imgid	: vector [, byte],	!Image file identification field
    lnk$al_valctltb,				!Cref by value control table
    lnk$al_sytblfmt,				!Cref by symbol control table
    lnk$gl_maxsymsz,				!Maximum symbol name length
    lnk$gl_maxmodsz,				!Maximum module name length
    lnk$gl_sysinput_flag,			!Set if option file is SYS$INPUT
    lnk$gw_ncrosrfs	: word,			!Number of cross references
    lnk$gw_misects	: word,			!Maximum number of isects
    lnk$gw_dzromin	: word,			!Minimum demand zero number of pages
    lnk$gw_nudfsyms	: word;			!Number of undefined symbols

external literal
    lin$_cmdtoolong,				!Command line too long
    lin$_confqual,				!Conflicting qualifiers
    lin$_crferr,				!Error from cross reference
    lin$_illnamelen,				!Illegal name length
    lin$_linerr,				!Command segment in error
    lin$_mulcluopt,				!Cluster multiply defined in options file
    lin$_optignshr,				!Option ignored in shareable image
    lin$_optignsys,				!Option ignored in system image
    lin$_optlin,				!Option line in error
    lin$_optsynerr,				!General syntax error
    lin$_optvalerr,				!Option value error
    lin$_optargmis,				!Argument missing for option
    lin$_premeof,				!Premature eof on options file
    lin$_readerr,				!Read error on file blah
    lin$_shrcpyign,				!/SHARE=COPY attempted
    lin$_shrinsys,				!Shareable image in system image
    lin$_shrsepclu,				!Shareable image requires seperate cluster
    lnk$k_max_filename_length;			!Maximum filename length
!
! Own storage
!
global
    lnk$gl_inclst	: ref bblock [dsc$c_s_bln],	!Include list descriptor
    lnk$gl_defclunum,					!Default cluster number
    lnk$gl_optextp 	: ref bblock,			!Listhead of option file text
    lnk$gl_optexte 	: ref bblock initial (lnk$gl_optextp),	!Pointer to last text block
    lnk$gl_shlextra,					!Requested shl_extra
    lnk$gw_chans 	: word,				!Number of channels requested
    lnk$gw_ioseg 	: word,				!Size of i/o segment
    lnk$gq_privs 	: vector [2] initial (long (-1, -1)),	!Requested privileges
    lnk$gl_unsupported	: long initial (0),		!Unsupported features mask
    lnk$gl_cclulst 	: ref bblock,			!List head for collect cluster list
    lnk$gl_pscdflst 	: ref bblock;			!List head for psect definitions

global literal
    lnk$k_maxchans  = 4095,			!Maximum number of channels
    lnk$k_maxstack  = 65535,			!Maximum stack pages
    lnk$k_maxioseg  = 65535,			!Maximum size of I/O segment
    lnk$k_maxisds   = 65535,			!Maximum number of isects
    lnk$k_mindzro   = 65535,			!Maximum min_dzro size
    lnk$k_maxmajid  = 255,			!Maximum major ident
    lnk$k_maxminid  = %x'FFFFFF',		!Maximum minor ident
    lnk$k_maxoptlin = 32767,			!Maximum size of option line
    lnk$k_maxpfc    = 255;			!Maximum page fault cluster factor

own
    tparse_block : bblock [tpa$k_length0]	!Tparse parameter block
		   initial (long (tpa$k_count0)
			   ,long (tpa$m_abbrfm)	!Abbreviate first match
			   ),
cmdbuffer,					!Address of command buffer
optlinedesc 	: bblock [dsc$c_s_bln],		!String descriptor of complete line
fileflagsadr 	: ref bblock,			!Address of caller's file flags
optrabadr 	: ref bblock,			!Address of RAB for GET sequential
include_desc	: bblock[dsc$c_s_bln],		!Address of include list
curcollectdesc 	: ref bblock,			!Address of current collect descriptor
curpsectdesc 	: ref bblock,			!Address of current psect descriptor
cursymdesc 	: ref bblock,			!Address of current symbol descriptor
cursymsnb 	: ref bblock,			!Address of current symbol name block
filespec_desc 	: bblock [dsc$c_s_bln],		!String descriptor for file specification
optionfilename 	: ref bblock,			!Address of string descriptor for options file name
quoteflag,					!True when inside double quotes
cluoptflag,					!True if processing cluster option
sharecopy,					!Set true if /share=copy
protectflag;					!set true if clusters are to be protected

literal
    delimited     = 1,				!Ident string is delimited
    sign_bit      = %x'80000000',		!Mask for sign bit
    word_sign_bit = %x'8000',			!Sign bit of a word
    rh_mask       = %x'FFFF';			!Mask for right half

bind
    image_ident_name 	= cstring ('Image identification'),
    image_name_name 	= cstring ('Image name'),
    channels_name 	= cstring ('Channel'),		!Name of option
    clusterpfc_name 	= cstring ('Page fault cluster'),
    defined_by_option 	= cstring ('<Linker option>'),
    optionfilestring 	= cstring ('OPTION FILE'),
    dzromin_name 	= cstring ('DZRO_MIN'),
    gsmatch_name 	= cstring ('GSMATCH'),
    ioseg_name 		= cstring ('IOSEG'),
    isdmax_name 	= cstring ('ISD_MAX'),
    unsupported_name	= cstring ('Unsupported'),
    stack_name 		= cstring ('Stack');


%sbttl 'Options parser TPARSE table';
!
! Linker options command parsing table
!
$init_state (state_table, key_table);
!
! Parse Linker options
!
$state (option, ((parse_filelist), tpa$_exit), 
	((base_option), tpa$_exit), 
	((channels_option), tpa$_exit),
	((cluster_option), tpa$_exit), 
	((collect_option), tpa$_exit), 
	((dzro_min_option), tpa$_exit),
	((gsmatch_option), tpa$_exit), 
	((iosegment_option), tpa$_exit), 
	((isd_max_option), tpa$_exit),
	((protect_option), tpa$_exit), 
	((psect_option), tpa$_exit), 
	((shl_option), tpa$_exit),
	((stack_option), tpa$_exit), 
	((symbol_option), tpa$_exit), 
	((universal_option), tpa$_exit),
	((unsupported_option), tpa$_exit),
	((image_type_option), tpa$_exit), 
	((image_ident_option), tpa$_exit), 
	((image_name_option), tpa$_exit));
!
! Parse BASE option
!
$state (base_option, 
	('BASE'));
$state (, 
	('=', baseop1));
$state (baseop1, 
	((parse_number), baseop2, set_base), ((errorparse_1)));
$state (baseop2, 
	((endline_1), tpa$_exit));
!
! Parse CHANNELS option
!
$state (channels_option, 
	('CHANNELS'));
$state (, 
	('=', chanop1));
$state (chanop1, 
	((parse_number), chanop2, set_channels), ((errorparse_1)));
$state (chanop2, 
	((endline_1), tpa$_exit));
!
! Parse CLUSTER option
!
$state (cluster_option, 
	('CLUSTER'));
$state (, 
	('='));
$state (, 
	((get_symbol), cluop1, createcluster), 	!Cluster name
	((errorparse_1)));
$state (cluop1, 
	(tpa$_eos, cluop7a), 		!If that's all, then that's ok
	(',', cluop2), ((errorparse_1)));
$state (cluop2, 
	(tpa$_eos, cluop7a), 		!If that's all, then that's ok
	((parse_number_or_null), cluop3, setclusterbase), 	!Cluster base address
	((errorparse_1)));
$state (cluop3, 
	(tpa$_eos, cluop7a), 		!If that's all, then that's ok
	(',', cluop4), ((errorparse_1)));
$state (cluop4, 
	(tpa$_eos, cluop7a), 		!If that's all, then that's ok
	((parse_number_or_null), cluop5, setclusterpfc), 	!Cluster page fault cluster factor
	((errorparse_1)));
$state (cluop5, 
	(tpa$_eos, cluop7a), 		!Allow null file list
	(',', cluop6), ((errorparse_1)));
$state (cluop6, 
	(tpa$_eos, cluop7a), 		!Allow null file list
	((parse_filelist), cluop7), 		!List of files in this cluster
	((errorparse_1)));
$state (cluop7, 
	((endline_1), cluop8));
$state (cluop7a, 				!No files in cluster option
	(tpa$_lambda, cluop8, insertcluster));
$state (cluop8, 
	(tpa$_lambda, tpa$_exit, clusterdone));
!
! Parse COLLECT option
!
$state (collect_option, 
	('COLLECT'));
$state (, 
	('='));
$state (, 
	((get_symbol), collop1, set_collect), 	!Cluster name
	((errorparse_1)));
$state (collop1, 
	(',', collop2), ((errorparse_1)));
$state (collop2, 
	((collect_psect_list), collop3), 	! followed by a list of psects
	((errorparse_1)));
$state (collop3, 
	((endline_1), tpa$_exit));
!
! Parse the psect list in the COLLECT option
!
$state (collect_psect_list, 
	((get_symbol), colpsc1, collect_psect), 	!Get a psect name
	((errorparse_1)));
$state (colpsc1, 
	(',', collect_psect_list), (tpa$_eos, tpa$_exit), ((errorparse_1)));
!
! Parse DZRO_MIN option
!
$state (dzro_min_option, 
	('DZRO_MIN'));
$state (, 
	('=', dzromin1));
$state (dzromin1, 
	((parse_number), dzromin2, set_min_dzro), ((errorparse_1)));
$state (dzromin2, 
	((endline_1), tpa$_exit));
!
! Parse GSMATCH option
!
$state (gsmatch_option, 
	('GSMATCH'));
$state (, 
	('='));
$state (, 
	((gsmatch_parse_control), gsmop1), 	!GSMATCH control
	((errorparse_1)));
$state (gsmop1, 
	(',', gsmop2), ((errorparse_1)));
$state (gsmop2, 
	((parse_number), gsmop3, set_gsmatch_maj), 	!Major id
	((errorparse_1)));
$state (gsmop3, 
	(',', gsmop4), ((errorparse_1)));
$state (gsmop4, 
	((parse_number), gsmop5, set_gsmatch_min), 	!Minor id
	((errorparse_1)));
$state (gsmop5, 
	((endline_1), tpa$_exit));
!
! Parse GSMATCH match control
!
$state (gsmatch_parse_control, 
	('ALWAYS', tpa$_exit, set_gsmatch_ctl, , , isd$k_matall),
	('EQUAL', tpa$_exit, set_gsmatch_ctl, , , isd$k_matequ),
	('LEQUAL', tpa$_exit, set_gsmatch_ctl, , , isd$k_matleq), ((errorparse_1)));
!
! Parse IMAGE_TYPE option
!
$state (image_type_option, 
	('IMAGE_TYPE'));
$state (, 
	('='));
$state (, 
	((image_type_parse), imageop1), ((errorparse_1)));
$state (imageop1, 
	((endline_1), tpa$_exit));
$state (image_type_parse, 
	('CLI', tpa$_exit, set_image_type), ((errorparse_1)));
!
! Parse IDENT option
!
$state (image_ident_option, 
	('IDENTIFICATION'));
$state (, 
	('='));
$state (, 
	('"', tpa$_exit, set_image_ident, , , delimited),
	(tpa$_symbol, tpa$_exit, set_image_ident, , , not delimited), ((errorparse_1)));
!
! Parse NAME option
!
$state (image_name_option, 
	('NAME'));
$state (, 
	('='));
$state (, 
	((get_symbol), nameop1, set_image_name), ((errorparse_1)));
$state (nameop1, 
	((endline_1), tpa$_exit));
!
! Parse IOSEGMENT option
!
$state (iosegment_option, 
	('IOSEGMENT'));
$state (, 
	('='));
$state (, 
	((parse_number), iosegop1, set_ioseg), 	!Number of buffers
	((errorparse_1)));
$state (iosegop1, 
	(tpa$_eos, tpa$_exit), 	!P0BUFS keyword is optional
	(',', iosegop2), ((errorparse_1)));
$state (iosegop2, 
	('P0BUFS', tpa$_exit, set_p0bufs, , , 0), 
	('NOP0BUFS', tpa$_exit, set_p0bufs, , , 1),
	((errorparse_1)));
!
! Parse ISD_MAX option
!
$state (isd_max_option, 
	('ISD_MAX'));
$state (, 
	('='));
$state (, 
	((parse_number), isdmaxop1, set_isd_max), ((errorparse_1)));
$state (isdmaxop1, 
	((endline_1), tpa$_exit));
!
! Parse PROTECT option
!
$state (protect_option, 
	('PROTECT'));
$state (, 
	('='));
$state (, 
	('YES', protop1, set_protect, , , 1), 
	('NO', protop1, set_protect, , , 0), ((errorparse_1)));
$state (protop1, 
	((endline_1), tpa$_exit));
!
! Parse PSECT option
!
$state (psect_option, 
	('PSECT_ATTRIBUTES'));
$state (, 
	('='));
$state (, 
	((get_symbol), pscop1, createpsect), 	!Psect name
	((errorparse_1)));
$state (pscop1, 
	(',', pscop2), ((errorparse_1)));
$state (pscop2, 
	((psect_parse_attribute), pscop3));	!Followed by a list of attributes
$state (pscop3, 
	(',', pscop2), 			! separated by commas
	(tpa$_eos, tpa$_exit), 			!Quit at end of line
	((errorparse_1)));
!
! Parse PSECT option attributes
!
$state (psect_parse_attribute, 
	('ABS', tpa$_exit, set_pscatrib, , , (( not gps$m_rel) and rh_mask)),
	('REL,', tpa$_exit, set_pscatrib, , , gps$m_rel),
	('CON', tpa$_exit, set_pscatrib, , , (( not gps$m_ovr) and rh_mask)),
	('OVR', tpa$_exit, set_pscatrib, , , gps$m_ovr),
	('EXE', tpa$_exit, set_pscatrib, , , (gps$m_exe or gps$m_rd)),
	('NOEXE', tpa$_exit, set_pscatrib, , , (( not gps$m_exe) and rh_mask)),
	('GBL', tpa$_exit, set_pscatrib, , , gps$m_gbl),
	('LCL', tpa$_exit, set_pscatrib, , , (( not gps$m_gbl) and rh_mask)),
	('LIB', tpa$_exit, set_pscatrib, , , gps$m_lib),
	('USR', tpa$_exit, set_pscatrib, , , (( not gps$m_lib) and rh_mask)),
	('PIC', tpa$_exit, set_pscatrib, , , gps$m_pic),
	('NOPIC', tpa$_exit, set_pscatrib, , , (( not gps$m_pic) and rh_mask)),
	('RD', tpa$_exit, set_pscatrib, , , gps$m_rd),
	('NORD', tpa$_exit, set_pscatrib, , , (( not gps$m_rd) and rh_mask)),
	('SHR', tpa$_exit, set_pscatrib, , , gps$m_shr),
	('NOSHR', tpa$_exit, set_pscatrib, , , (( not gps$m_shr) and rh_mask)),
	('WRT', tpa$_exit, set_pscatrib, , , (gps$m_rd or gps$m_wrt)),
	('NOWRT', tpa$_exit, set_pscatrib, , , (( not gps$m_wrt) and rh_mask)),
	('VEC', tpa$_exit, set_pscatrib, , , gps$m_vec),
	('NOVEC', tpa$_exit, set_pscatrib, , , (( not gps$m_vec) and rh_mask)),
	('BYTE', tpa$_exit, set_pscatrib, , , (0 or sign_bit)),
	('WORD', tpa$_exit, set_pscatrib, , , (1 or sign_bit)),
	('LONG', tpa$_exit, set_pscatrib, , , (2 or sign_bit)),
	('QUAD', tpa$_exit, set_pscatrib, , , (3 or sign_bit)),
	('PAGE', tpa$_exit, set_pscatrib, , , (9 or sign_bit)),
!
! Allow alignment to be specified numerically also
!
	('0', tpa$_exit, set_pscatrib, , , (0 or sign_bit)), 
	('1', tpa$_exit, set_pscatrib, , , (1 or sign_bit)),
	('2', tpa$_exit, set_pscatrib, , , (2 or sign_bit)), 
	('3', tpa$_exit, set_pscatrib, , , (3 or sign_bit)),
	('9', tpa$_exit, set_pscatrib, , , (9 or sign_bit)), ((errorparse_1)));
!
! Parse SHL_EXTRA option
!
$state (shl_option, 
	('SHL_EXTRA'));
$state (, 
	('='));
$state (, 
	((parse_number), shl1, set_shl), ((errorparse_1)));
$state (shl1, 
	((endline_1), tpa$_exit));
!
! Parse STACK option
!
$state (stack_option, 
	('STACK'));
$state (, 
	('='));
$state (, 
	((parse_number), stackop1, set_stack), ((errorparse_1)));
$state (stackop1, 
	((endline_1), tpa$_exit));
!
! Parse SYMBOL option
!
$state (symbol_option, 
	('SYMBOL'));
$state (, 
	('='));
$state (, 
	((get_symbol), symbolop1, definesymbolname), 	!Symbol name
	((errorparse_1)));
$state (symbolop1, 
	(',', symbolop2), ((errorparse_1)));
$state (symbolop2, 
	((parse_number), symbolop3, definesymbolval), 	! and symbol value
	((errorparse_1)));
$state (symbolop3, 
	((endline_1), tpa$_exit));
!
! Parse UNSUPPORTED option
!
$state (unsupported_option, 
	('UNSUPPORTED'));
$state (, 
	('=', unsuppop1));
$state (unsuppop1, 
	((parse_number), unsuppop2, set_unsupported), ((errorparse_1)));
$state (unsuppop2, 
	((endline_1), tpa$_exit));
!
! Parse UNIVERSAL option
!
$state (universal_option, 
	('UNIVERSAL'));
$state (, 
	('='));
$state (, 
	((parse_univ_symbols), tpa$_exit));	!List of symbols to universalize
!
! Parse the symbols in the UNIVERSAL option
!
$state (parse_univ_symbols, 
	('*',prsuniv2),
	((get_symbol), prsuniv1, set_universal), ((errorparse_1)));
$state (prsuniv1, 
	(',', parse_univ_symbols), 
	(tpa$_eos, tpa$_exit), 	!Quit at end of string
	((errorparse_1)));
$state (prsuniv2,
	(tpa$_eos,prsuniv3),
	((errorparse_1)));
$state (prsuniv3,
	(tpa$_lambda, tpa$_exit, set_alluniv));		! Flag all universal temporarily
!
! Parse a comma-separated file list
!
$state (parse_filelist, 
	((filespec), parsefl1, , , filespec_desc));	!Do a file specification
$state (parsefl1, 
	('_', tpa$_fail), 		!Return failure if underscore, that is part of option
						!  syntax.
	('=', tpa$_fail), 			!Return failure if it looks like an option
	(',', parse_filelist, processfile), 	!Process comma-separated list
	('/', parsefl2), 			!Process qualifiers
	(tpa$_eos, tpa$_exit, processfile), 	!Quit at end
	((errorparse_1)));
$state (parsefl2, 
	((include_qual), parsefl3, set_include, , , (fdb$m_shr or fdb$m_option or fdb$m_selser)),
	('LIBRARY', parsefl3, set_library, , , (fdb$m_shr or fdb$m_option or fdb$m_selser)),
	('SELECTIVE_SEARCH', parsefl3, set_selective, , , (fdb$m_option or fdb$m_libr)),
	((share_qual), parsefl3, set_shareable, , , (fdb$m_libr)), ((errorparse_1)));
$state (parsefl3, 
	('/', parsefl2), 		!Process all qualifiers
	(tpa$_lambda, parsefl4));
$state (parsefl4, 
	(',', parse_filelist, processfile), 	!Comma means more files
	(tpa$_eos, tpa$_exit, processfile), 	!Exit at end of string
	((errorparse_1)));
!
! Detect and check general file specification
!
$state (filespec, 				! General file spec check
	((nodespec), fil0), (tpa$_lambda, fil0));
$state (fil0, 
	((devname), fil1), 
	(tpa$_lambda, fil1));
$state (fil1, 
	((direct), fil2), 
	(tpa$_lambda, fil2));
$state (fil2, 
	(tpa$_symbol));
$state (, 					!
	((type), fil3), 				! Check for type and version
	(tpa$_lambda, fil3));			!
$state (fil3, 					!
	((version), tpa$_exit), 			!
	(tpa$_lambda, tpa$_exit));
!
! Recognize node name (with optional access string)
!
$state (nodespec, 
	((node1), node0));		! Get the first node spec
$state (node0, 				! Then try to get more
	((node1), node0), 		!  try for one
	(tpa$_lambda, tpa$_exit));	!  but if we don't get one, the exit successfully with the one
$state (node1, 
	(tpa$_symbol));
$state (, 
	(':', node3), ('"'));		! Check for access control
$state (node2, 
	('"', node4), 			! Look for end of access control
	(tpa$_eos, tpa$_fail), 
	(':', tpa$_fail), 
	(tpa$_any, node2));
$state (node3, 
	(':', tpa$_exit));		! Second colon delimiting node spec
$state (node4, 
	(':', node3));			! Must terminate the node spec.
!
! Recognize device name
!
$state (devname, 
	(tpa$_symbol));
$state (,
	(':', tpa$_exit));
!
! Recognize directory
!
$state (direct, 
	('<'), 
	('['));
$state (, 					!
	((ufd), dir2), 				! Check for uic directory name
	((dirsub)));				!
$state (dir2, 					!
	('>', tpa$_exit), 
	(']', tpa$_exit));	
!
! Recognize string directories and subdirectories
!
$state (dirsub, 				!
	(tpa$_symbol, dirsub1), 		!
	('-', dirsub1), 			! Allow [-]
	(tpa$_lambda));				! Allow [.sub.sub]
$state (dirsub1, 				!
	('.', dirsub), 				! Loop for another directory name
	(tpa$_lambda, tpa$_exit));
!
! Recognize ufd directory format
!
$state (ufd, 					!
	(tpa$_octal));				!
$state (, 					!
	(','));
$state (, 					!
	(tpa$_octal, tpa$_exit));			!
!
! Recognize file type
!
$state (type, 					!
	('.'));					!
$state (, 					!
	(tpa$_string, tpa$_exit), 			!
	(tpa$_blank, tpa$_exit), 			!
	(tpa$_lambda, tpa$_exit));
!
! Recognize file version
!
$state (version, 				!
	(';'));					!
$state (, 					!
	(tpa$_decimal, tpa$_exit), 			!
	(tpa$_blank, tpa$_exit), 			!
	(tpa$_lambda, tpa$_exit));
!
! Parse a number or a null field
!
$state (parse_number_or_null, 
	((parse_number), tpa$_exit), 	!All ok if number
	(tpa$_lambda, tpa$_exit));			! or else nothing
!
! Recognize number
!
$state (parse_number, 				!
	(tpa$_decimal, tpa$_exit), 			! Decimal number
	('%'));					! Base prefix
$state (, 					!
	('D', decnum), 				! Decimal base designator
	('X', hexnum), 				! Hex base designator
	('O'));					! Octal number
$state (, 					!
	(tpa$_octal, tpa$_exit));			! Introduced octal number
$state (hexnum, 				! Introduced hex number
	(tpa$_hex, tpa$_exit));			! Hex number
$state (decnum, 				! Introduced decimal number
	(tpa$_decimal, tpa$_exit));
!
! Parse INCLUDE qualifier
!
$state (include_qual, 
	('INCLUDE'));		!Include
$state (, 
	((qualvalsep), incl1), 		!Followed by '=' or ':'
	((errorparse_1)));				! or its an error
$state (incl1, 
	('(', include_list), 		!If a left parens
	((get_symbol), tpa$_exit, , , include_desc), 	! or a symbol then ok
	((errorparse_1)));				! otherwise an error
!
!   Parse a list of symbols enclosed in parens
!
$state (include_list, 
	((parse_include_list), incl2, , , include_desc));
						!Call the routine and store the descriptor
$state (incl2, 
	(')', tpa$_exit), 		!Followed by a right parens
	((errorparse_1)));				! or a syntax error
$state (parse_include_list, 
	((get_symbol), incl3), 	!Get one symbol
	((errorparse_1)));				! or an error
$state (incl3, 
	(',', parse_include_list), 	!Go for more if a comma
	(tpa$_lambda, tpa$_exit));			!otherwise return
!
! Parse /SHARE qualifier
!
$state (share_qual, 
	('SHAREABLE', , set_shrcopyflag, , , 0));	!Zero flag
$state (, 
	((qualvalsep), parseshareval), 
	(tpa$_lambda, tpa$_exit));
$state (parseshareval, 
!	('COPY', tpa$_exit, set_shrcopyflag, , , 1),
	('NOCOPY', tpa$_exit, set_shrcopyflag, , , 0), ((errorparse_1)));
!
! Parse a symbol, which may include periods (.MAIN.)
!
$state (get_symbol, 
	('.', getsym1), 		!Make sure we get at least one character
	(tpa$_symbol, getsym1), 
	(tpa$_lambda, tpa$_fail));	!Fail if not at least one character
$state (getsym1, 
	('.', getsym1), 
	(tpa$_symbol, getsym1), 
	(tpa$_lambda, tpa$_exit));
!
! Check qualifier and value separator
!
$state (qualvalsep, 
	(':', tpa$_exit), 
	('=', tpa$_exit));
!
! Try to parse something and then call the error routine
!
$state (errorparse_1, 
	(tpa$_eos, , missingargerr), 
	(tpa$_symbol, , syntaxerr), 
	(tpa$_string, , syntaxerr),
	(tpa$_any, , syntaxerr), 
	(tpa$_lambda, , syntaxerr));
!
! Check end of line conditions
!
$state (endline_1, 
	(tpa$_eos, tpa$_exit), 	!End of string is a good exit
	(tpa$_symbol, , syntaxerr), 		!Else try to get a symbol
	(tpa$_string, , syntaxerr), 		!Else try to get a string
	(tpa$_any, , syntaxerr));			! or anything to flag as error

%sbttl 'readoption - Read record from options file'
;
routine readoption (linedesc, errorsignal) =
!
! This routine reads and returns to the caller in linedesc the
! next record of the options file.  If end of file is detected, then
! one of two things can happen.  If the errorsignal argument is
! supplied, then the error is signaled.  If it is not supplied,
! rms$_eof is returned to the caller.
!
begin
map
	linedesc 	: ref bblock;
builtin
	nullparameter;
local
	status,
	blocksize,
	blockaddr 	: ref bblock;

status = $get (rab = .optrabadr);			!Read the record
linedesc [dsc$w_length]  = .optrabadr [rab$w_rsz];	!Return it to caller
linedesc [dsc$a_pointer] = .optrabadr [rab$l_rbf];

if .status						!If a successful read
then begin
     if      .lnk$gl_ctlmsk [lnk$v_verify]		!Echo line if SET VERIFY
     and not .lnk$gl_sysinput_flag			!and not SYS$INPUT
     then lib$put_output (.linedesc);

     blocksize = oeb$c_size + .linedesc [dsc$w_length];	!Figure size of block to allocate
     lnk$alloblk (.blocksize, blockaddr);		!Allocate it
     blockaddr [oeb$l_nxtoeb] = 0;
     blockaddr [oeb$w_bytcnt] = .linedesc [dsc$w_length]; !Set size of line into descriptor
     ch$move (.linedesc [dsc$w_length]		 	! and copy out the text
	     ,.linedesc [dsc$a_pointer]	
	     , blockaddr [oeb$t_text]);
     lnk$gl_optexte [oeb$l_nxtoeb] = .blockaddr;	!Link the block into the end of the list
     lnk$gl_optexte = .blockaddr;			! and make it the last one
     end
else begin
     !
     ! An error occurred on the read
     !
     if .status eql rms$_eof				!If this is end of file
     then begin
	  if not nullparameter (2)			! and signal code supplied
	  then signal (.errorsignal, 1, .optionfilename	! then signal it (eof not expected)
		      ,.status, .optrabadr [rab$l_stv]
		      );
	  end
     else signal_stop (lin$_readerr, 1, .optionfilename	!Not eof, signal the read error and give up
		      ,.status, .optrabadr [rab$l_stv]
		      );
     end;

return .status
end;


%sbttl 'LNK$PROCOPTNS -- Entry point to options parsing';
global routine lnk$procoptns ( optfilename, fileflags, optionrab) =
    begin
!
! This routine parses the options file
!
! Inputs:
!
!	optfilename	The address of the string descriptor for the options file
!	fileflags	Address of file control flags
!	optionrab	Address of the RAB connected for GET sequential
!
! Outputs:
!
!	Linker data structures created according to inputs found in options file.
!--
    map
	optfilename : ref bblock,
	fileflags : ref bblock,
	optionrab : ref bblock;
    local
	blockaddr : ref bblock,
	blocksize,
	linedesc : bblock [dsc$c_s_bln],
	commentline,
	rmsstatus;

    fileflagsadr = .fileflags;			!Put file flags address into own storage
    optrabadr = .optionrab;			!Put RAB address in own storage
    optionfilename = .optfilename;		!Put string descriptor address into own storage
    ch$fill (0, dsc$c_s_bln, linedesc);		!Clear out the descriptor
!
! Copy option file name out to the option text list
!

    if .lnk$gl_ctlmsk [lnk$v_long]		!If creating a long map
    then
	begin
	blocksize = oeb$c_size + .optionfilename [dsc$w_length] + 2;	!Figure size of block to allocate
	lnk$alloblk (.blocksize, blockaddr);	!Allocate it
	blockaddr [oeb$l_nxtoeb] = 0;
	blockaddr [oeb$w_bytcnt] = .optionfilename [dsc$w_length] + 2;	!Set size of line into descriptor
	begin
	bind
	    filenamestring = blockaddr [oeb$t_text] : vector [, byte];

	filenamestring [0] = %ascii'<';
	ch$move (.optionfilename [dsc$w_length], 	!Copy the filename out
	    .optionfilename [dsc$a_pointer], filenamestring [1]);
	filenamestring [.optionfilename [dsc$w_length] + 1] = %ascii'>';
	end;
	lnk$gl_optexte [oeb$l_nxtoeb] = .blockaddr;	!Link the block into the end of the list
	lnk$gl_optexte = .blockaddr;		! and make it the last one
	end;

!
! Allocate a buffer.  This buffer will be used to pack continuation lines into one continuous line
!
    lnk$alloblk (lnk$k_maxoptlin, cmdbuffer);
!
! Loop, reading and parsing commands until end of file
!
    while (rmsstatus = readoption (linedesc)) neq rms$_eof do
	begin
	tparse_block [tpa$l_stringcnt] = 0;	!Zero line length
	tparse_block [tpa$l_stringptr] = .cmdbuffer;	!Point TPARSE to the buffer
	quoteflag = false;			!Not inside double quotes
	cluoptflag = false;			!Not processing cluster option

	if .linedesc [dsc$w_length] neq 0	!If line is not null
	then
	    scanline (linedesc, commentline);	! scan the line and store in the buffer

	if .tparse_block [tpa$l_stringcnt] neq 0
	then
	    begin
	    ch$move (dsc$c_s_bln, tparse_block [tpa$l_stringcnt],
						!Make a copy of the options line descriptor
		optlinedesc);
	    lnk$upcase_d (tparse_block [tpa$l_stringcnt]);	!Convert string to upper case
!
! Parse the command line
!
	    if not lib$tparse (tparse_block, state_table, key_table) then syntaxerr ();
!
! Reset current cluster to default cluster at end of each options line
!
	    lnk$gl_curclu = lnk$gl_defclu;
	    end;
	end;
!
! Deallocate the buffer
!
    lnk$dealblk (lnk$k_maxoptlin, .cmdbuffer);
    return true
    end;					!Of lnk$procoptns

%sbttl 'Form complete options line, handling continuations';
routine scanline (indesc, commentline) =
    begin
!
! This routine scans a line and handles continuations.
!
! Inputs:
!
!	indesc	address of string descriptor for input line
!
! Outputs:
!
!	tparse_block[tpa$l_stringcnt] set to count of characters in .cmdbuffer
!	commentline	set true if line was a comment line (used in recursive
!			internal calls only)
!
!	Blanks and tabs are stripped from line, continuation lines processed.
!---
!
! Routine to store a character into the buffer
!
    routine storecharacter (cchar) =
	begin
	if .tparse_block [tpa$l_stringcnt] eql lnk$k_maxoptlin - 1
	then
	    signal_stop (lin$_cmdtoolong, 1,
		.optionfilename);

	if (.cchar neq %c' ' and .cchar neq %c'	')	!If character is not space or tab
	    or .quoteflag			! or we are inside double quotes
	then
	    begin
	    bind
		charvector = .tparse_block [tpa$l_stringptr] + .tparse_block [tpa$l_stringcnt] : vector [,
			byte];

	    charvector [0] = .cchar;		!Store the character
	    tparse_block [tpa$l_stringcnt] = .tparse_block [tpa$l_stringcnt] + 1;

	    if .cchar eql %c'"'			!If double quote, then toggle the quote flag
	    then
		quoteflag = not .quoteflag;
	    end;
	return true
	end;					!of storecharacter
!
! Main body of scanline
!
    map
	indesc : ref bblock;
    local
	rmsstatus,
	stringstart,
	cchar : byte,
	tempdesc : bblock [dsc$c_s_bln];

    if .indesc [dsc$w_length] eql 0 then return (.commentline = true);

    ch$fill (0, dsc$c_s_bln, tempdesc);		! Clear descriptor
    stringstart = .tparse_block [tpa$l_stringcnt];
!
! Copy the line into the command buffer a character at a time, watching for
! continuation lines and comments.
!
    incru i from 0 to .indesc [dsc$w_length] - 1 do
	begin
	bind
	    linebuffer = .indesc [dsc$a_pointer] : vector [, byte];

	if (cchar = .linebuffer [.i]) eql %ascii'!'	!If character is comment character
	then
	    exitloop (.commentline = true);	!  then done with line
	if .cchar eql %ascii'-'			!If character is a possible continuation character
	then
	    begin				!  then check it out
	    if .i eql .indesc [dsc$w_length] - 1	!Are we on the last character?
		or
		begin				!  or is everything following it blank or a comment?
		local
		    status;
		status = true;
		incru j from .i + 1 to .indesc [dsc$w_length] - 1 do
		    if .linebuffer [.j] eql %ascii'!'	!It's a continuation if comment follows
		    then
			exitloop (.commentline = status = true)
		    else
			if .linebuffer [.j] neq %ascii' '	! but not if it's not a space
			    and .linebuffer [.j] neq %ascii'	'	! or tab
			then
			    exitloop (.commentline = status = false);
		.status
		end
		!
		! It is a continuation line
		!
	    then
		while true do
		    begin
		    rmsstatus = readoption (tempdesc, lin$_premeof);	!Read next line
		    scanline (tempdesc, .commentline);	!Scan the line

		    if not ..commentline	!If we did not just
		    then
			return true;		! scan a comment then done
		    end
		    !
		    ! Not a continuation line
		    !
	    else
		storecharacter (.cchar);
	    end
	else
	    storecharacter (.cchar);
	end;
    if ..commentline				!If we just scanned a comment line
	and (.tparse_block [tpa$l_stringcnt] eql .stringstart)	! with nothing else on it
    then
	return (.commentline = true)
    else
	begin
	.commentline = false;
	return true
	end;
    end;

%sbttl 'TPARSE action routines';
routine set_base =
    begin
!---
!
! This routine is called by TPARSE to process the BASE= option
!
! Inputs:
!
!	AP			Points to tparse_block
!	AP[tpa$l_number]	base as specified by user
!
! Outputs:
!
!	Base stored in clu$l_base of the default cluster
!
!---
    builtin
	ap;
    map
	ap : ref bblock;
    if .lnk$gl_ctlmsk [lnk$v_sys]
    then
	begin
	signal (lin$_optignsys);
	return true
	end;

    lnk$gl_defclu [clu$l_base] = (.ap [tpa$l_number]	!Get value and round up
    + 511) and not 511;				! to a page boundary
    lnk$gl_defclu [clu$v_based] = true;		!Flag cluster is based
!lnk$gl_defclu[clu$v_usrbased] = true;			! by user (not currently need for object clusters)
    lnk$gl_ctlmsk [lnk$v_ubased] = true;	!Flag image based by user
    return true
    end;					!Of set_base

routine set_channels =
    begin
!---
!
! This routine is called by TPARSE to process the CHANNELS= option
!
! Inputs:
!
!	AP			Points to tparse_block
!	AP[tpa$l_number]	Number of channels as specified in options file
!
! Outputs:
!
!	lnk$gw_chans		set up
!
!---
    builtin
	ap;
    map
	ap : ref bblock;
    if (lnk$gw_chans = .ap [tpa$l_number]) gtru lnk$k_maxchans or .ap [tpa$l_number] eql 0
    then
	optionvaluerr (channels_name, .ap, 1, lnk$k_maxchans);
    return true
    end;					!Of set_channels

routine createcluster =
    begin
!---
!
! This routine is called by TPARSE to create the cluster descriptor
! after the option has been parsed
!
! Inputs:
!
!	AP			Points to tparse_block
!	AP[tpa$l_tokencnt]	String descriptor for cluster name
!
! Outputs:
!
!	New cluster descriptor allocated, cluster name set into descriptor.
!
!	lnk$gl_curclu		Pointer to new cluster descriptor
!	AP[tpa$l_number]	Zeroed
!
!---
    builtin
	ap;
    map
	ap : ref bblock;
    namelengthcheck (ap [tpa$l_tokencnt], lnk$gt_clustring, lnk$k_max_filename_length);  !Check length of cluster name
    lnk$allocluster (lnk$gl_curclu);		!Allocate cluster descriptor
    cluoptflag = true;				!Flag processing a cluster option
!
! Move in the cluster name.  Don't call LNK$INSERT_CLU here because the file specified
! may contain the /SHARE qualifier.  The cluster will be inserted in processfile
!
    ch$move ((lnk$gl_curclu [clu$b_namlng] = .ap [tpa$l_tokencnt]), .ap [tpa$l_tokenptr],
	lnk$gl_curclu [clu$t_name]);
    lnk$gl_curclu [clu$v_protect] = .protectflag;	!Set protect flag as requested
    ap [tpa$l_number] = 0;			!Preset base to 0
    return true
    end;					!Of createcluster

routine setclusterbase =
    begin
!---
!
! This routine is called by TPARSE when the base field of the cluster option is parsed
!
! Inputs:
!
!	AP			pointer to tparse_block
!	AP[tpa$l_number]	Base as specified in option
!	AP[tpa$l_tokencnt]	Size of token just parsed (i.e. non-zero if base specified)
!
! Outputs:
!
!	Cluster base and based flag set (iff base specified) for current cluster
!
!---
    builtin
	ap;
    map
	ap : ref bblock;
    lnk$gl_curclu [clu$l_usrbase] = (.ap [tpa$l_number] + 511)	!Set cluster base
    and not 511;				! rounded up to page boundary
    lnk$gl_curclu [clu$v_usrbased] = (.ap [tpa$l_tokencnt] neq 0);
						!If number present,then cluster is based
    lnk$gl_ctlmsk [lnk$v_ubased] = .lnk$gl_ctlmsk [lnk$v_ubased]	! set if based by user
    or .lnk$gl_curclu [clu$v_usrbased];
    ap [tpa$l_number] = 0;			!Zero in case pfc defaulted
    return true
    end;					!Of setclusterbase

routine setclusterpfc =
    begin
!---
!
! This routine is called by TPARSE to store the pfc in the cluster descriptor
!
! Inputs:
!
!	AP			Pointer to tparse_block
!	AP[tpa$l_number]	Cluster page fault cluster factor
!
! Outputs:
!
!	pfc field set in current cluster
!
!---
    builtin
	ap;
    map
	ap : ref bblock;
    if (lnk$gl_curclu [clu$b_pfc] = .ap [tpa$l_number]) gtru lnk$k_maxpfc
    then
	optionvaluerr (clusterpfc_name, .ap, 0, lnk$k_maxpfc);
    return true
    end;					!Of set clusterpfc

routine clusterdone =
    begin
!
! This routine finishes cluster option processing
!
    if not .lnk$gl_curclu [clu$v_shrimg]	!If not a shareable image cluster
	and .lnk$gl_curclu [clu$v_usrbased]	! and it was based by user
    then
	begin
	lnk$gl_curclu [clu$l_base] = .lnk$gl_curclu [clu$l_usrbase];	!Set cluster base
	lnk$gl_curclu [clu$l_usrbase] = 0;	!Clear usrbase
	lnk$gl_curclu [clu$v_based] = true;	!Flag cluster as based
	end;
    return true
    end;

routine set_collect =
    begin
!---
!
! This routine is called by TPARSE when the cluster name field of the COLLECT option is parsed
!
! Inputs:
!
!	AP			Pointer to tparse_block
!	AP[tpa$l_tokencnt]	string descriptor for cluster name
!
! Outputs:
!
!	currcollectdesc		Pointer to allocated collect descriptor
!
!---
    builtin
	ap;
    map
	ap : ref bblock;
    namelengthcheck (ap [tpa$l_tokencnt], lnk$gt_clustring, lnk$k_max_filename_length);	!Check cluster name length
    search_insert_list (lnk$gl_cclulst, ap [tpa$l_tokencnt],
						!Insert / lookup the cluster in the cluster collect list
	ccd$c_size, curcollectdesc);
    curcollectdesc [ccd$b_protect] = .protectflag;	!Propogate the cluster protected flag
    return true
    end;					!Of set_colect

routine collect_psect =
    begin
!---
!
! This routine is called by TPARSE for each psect in the COLLECT option
!
! Inputs:
!
!	AP			Pointer to tparse_block
!	AP[tpa$l_tokencnt]	String descriptor for psect name
!
! Outputs:
!
!	Psect name block hung off of currcollectdesc in name order.
!
!---
    builtin
	ap;
    map
	ap : ref bblock;
    local
	scratchptr;
    namelengthcheck (ap [tpa$l_tokencnt], lnk$gt_pscstring);	!Check psect name length
    search_insert_list (curcollectdesc [ccd$l_psclst], ap [tpa$l_tokencnt],
						!Lookup/insert psect into list for cluster
	cpd$c_size, scratchptr);
    return true
    end;					!Of collect_psect

routine set_min_dzro =
    begin
!
! This routine is called by TPARSE to set the DZRO_MIN= option
!
    builtin
	ap;
    map
	ap : ref bblock;

    if (lnk$gw_dzromin = .ap [tpa$l_number]) gtru lnk$k_mindzro
    then
	optionvaluerr (dzromin_name, .ap, 0,
	    lnk$k_mindzro);
    if .lnk$gl_ctlmsk [lnk$v_sys] then signal (lin$_optignsys);
    return true
    end;					!Of set_min_dzro

routine set_gsmatch_ctl =
    begin
!
! This routine is called by TPARSE when the match control field of the GSMATCH option is processed
!
    builtin
	ap;
    map
	ap : ref bblock;
    lnk$gb_matchctl = .ap [tpa$l_param];	!Match control is passed as a parameter
    ap [tpa$l_number] = 0;			!Preset GSMATCH
    return true
    end;					!Of set_gsmatch_ctl

routine set_gsmatch_maj =
    begin
!
! This routine is called by TPARSE to process the major id of the GSMATCH option
!
    builtin
	ap;
    map
	ap : ref bblock;

    if (lnk$gl_matchid [gmt$b_majorid] = .ap [tpa$l_number]) gtru lnk$k_maxmajid
    then
	optionvaluerr (gsmatch_name, .ap, 0, lnk$k_maxmajid);
    ap [tpa$l_number] = 0;
    return true
    end;					!Of set gsmatch_maj

routine set_gsmatch_min =
    begin
!
! This routine is called by TPARSE to process the minor id of the GSMATCH option
!
    builtin
	ap;
    map
	ap : ref bblock;
    if (lnk$gl_matchid [gmt$b_minorid] = .ap [tpa$l_number]) gtru lnk$k_maxminid
    then
	optionvaluerr (gsmatch_name, .ap, 0, lnk$k_maxminid);
    return true;
    end;					!Of set gsmatch_min

routine set_image_type =
    begin
!
! This routine sets the image type.
!
    lnk$gl_ctlmsk [lnk$v_cli] = true;
    return true
    end;

routine set_image_ident =
    begin
!
! This routine is called by TPARSE to set the image file identification
!
    builtin
	ap;
    map
	ap : ref bblock;
    local
	ptr,
	delimited_ident,
	ident_desc : vector [2];

    lnk$gl_ctlmsk [lnk$v_imgidopt] = true;	! Flag that image id is manually set
    if (delimited_ident = .ap [tpa$l_param])
    then 					! Yes, then better find matching end delimiter
	if (ptr = ch$find_ch (.ap [tpa$l_stringcnt], .ap [tpa$l_stringptr], .ap [tpa$l_char])) eql 0
	then
	    return false			! If no end delimiter match, balk
	else
	    begin				! If found one, adjust pointers accordingly
	    ident_desc [0] = .ptr - .ap [tpa$l_stringptr];
	    ident_desc [1] = .ap [tpa$l_stringptr];
	    ap [tpa$l_stringcnt] = .ap [tpa$l_stringcnt] - (.ident_desc [0] + 1);
	    ap [tpa$l_stringptr] = .ptr + 1;
	    end
    else 					! If not delimited,
	begin					!   then token points to
	ident_desc [0] = .ap [tpa$l_tokencnt];	!   the ident string
	ident_desc [1] = .ap [tpa$l_tokenptr];
	end;

    namelengthcheck (ident_desc [0], image_ident_name, 15);	! make sure legal length
    lnk$gt_imgid [0] = .ident_desc [0];		! fill in image id field
    ch$move (.ident_desc [0], .ident_desc [1], lnk$gt_imgid [1]);
    return true
    end;

routine set_image_name =
    begin
!
! This routine is called by TPARSE to set the image name
!
    builtin
	ap;
    map
	ap : ref bblock;

    namelengthcheck (ap [tpa$l_tokencnt], image_name_name, lnk$k_max_filename_length);	! make sure legal length
    lnk$gt_imgnam [0] = .ap [tpa$l_tokencnt];	! fill in image name field
    ch$move (.lnk$gt_imgnam [0], .ap [tpa$l_tokenptr], lnk$gt_imgnam [1]);
    return true
    end;

routine set_ioseg =
    begin
!
! This routine is called by TPARSE to set the IOSEG= option
!
    builtin
	ap;
    map
	ap : ref bblock;
    if (lnk$gw_ioseg = .ap [tpa$l_number]) gtru lnk$k_maxioseg
    then
	optionvaluerr (ioseg_name, .ap, 0,
	    lnk$k_maxioseg);
    return true
    end;					!Of set_ioseg

routine set_p0bufs =
    begin
!
! Clear the NOP0BUFS flag
!
    builtin
	ap;
    map
	ap : ref bblock;

    lnk$gl_ctlmsk [lnk$v_nop0bufs] = .ap [tpa$l_param];
    return true
    end;					!Of p0bufs_on

routine set_isd_max =
    begin
!
! This routine is called by TPARSE to set the ISD_MAX= option
!
    builtin
	ap;
    map
	ap : ref bblock;

    if (lnk$gw_misects = .ap [tpa$l_number]) gtru lnk$k_maxisds or .lnk$gw_misects eql 0
    then
	optionvaluerr (isdmax_name, .ap, 1, lnk$k_maxisds);
    if .lnk$gl_ctlmsk [lnk$v_shr] then signal (lin$_optignshr);
    if .lnk$gl_ctlmsk [lnk$v_sys] then signal (lin$_optignsys);
    return true
    end;					!Of set_isd_max

routine set_protect =
    begin
!
! This action routine sets the protect flag
!
    builtin
	ap;
    map
	ap : ref bblock;
    protectflag = .ap [tpa$l_param];
    return true
    end;					!Of set_protect

routine createpsect =
    begin
!
! This routine is called by TPARSE when the PSECT= option is parsed.  It defines
! the psect.
!
    builtin
	ap;
    map
	ap : ref bblock;
    local
	psectnamebuf : vector [sym$c_maxlng + 1, byte];

    namelengthcheck (ap [tpa$l_tokencnt], lnk$gt_pscstring);	!Check length of name
    psectnamebuf [0] = .ap [tpa$l_tokencnt];	!Create ASCIC name string
    ch$move (.ap [tpa$l_tokencnt], .ap [tpa$l_tokenptr], psectnamebuf [1]);
    lib$insert_tree (lnk$gl_pscdflst, psectnamebuf, %ref (0), lnk$compare_pdd, lnk$alloc_pdd, curpsectdesc);
    return true
    end;					!Of createpsect

routine set_pscatrib =
    begin
!
! This routine is called by TPARSE for each attribute found in the PSECT= option
!
    builtin
	ap;
    map
	ap : ref bblock;
    local
	maskflag,
	attribit;
    attribit = .ap [tpa$l_param];
!
! Check if this is psect alignment and process
!
    if (.attribit and sign_bit) neq 0
    then
	begin
	curpsectdesc [pdd$b_align] = .attribit<0, 8>;	!Set psect aligment for later
	return true;
	end
    else
	if (.attribit and word_sign_bit) neq 0	!If clearing the bit
	then
	    begin
	    curpsectdesc [pdd$w_flags] = .curpsectdesc [pdd$w_flags] and not ( not (.attribit and %x'FFFF'));
	    curpsectdesc [pdd$w_flgmsk] = .curpsectdesc [pdd$w_flgmsk] or ( not (.attribit and %x'FFFF'));
	    end
	else
	    begin
	    curpsectdesc [pdd$w_flags] = .curpsectdesc [pdd$w_flags] or .attribit;
	    curpsectdesc [pdd$w_flgmsk] = .curpsectdesc [pdd$w_flgmsk] or .attribit;
	    end;
    return true
    end;					!Of set_pscatrib

routine set_shl =
    begin
!
! This routine is called by TPARSE for the SHL_EXTRA option
!
    builtin
	ap;
    map
	ap : ref bblock;
    lnk$gl_shlextra = .ap [tpa$l_number];
    if .lnk$gl_ctlmsk [lnk$v_sys] then signal (lin$_optignsys);
    return true
    end;

routine set_stack =
    begin
!
! This routine is called by TPARSE to process the STACK= option
!
    builtin
	ap;
    map
	ap : ref bblock;
    if (lnk$gw_stack = .ap [tpa$l_number]) gtru lnk$k_maxstack or .lnk$gw_stack eql 0
    then
	optionvaluerr (stack_name, .ap, 1, lnk$k_maxstack);
    if .lnk$gl_ctlmsk [lnk$v_shr] then signal (lin$_optignshr);
    if .lnk$gl_ctlmsk [lnk$v_sys] then signal (lin$_optignsys);
    return true
    end;					!Of set_stack

routine definesymbolname =
    begin
!
! This routine is called by TPARSE when the symbol name is parsed for the SYMBOL= option
!
    builtin
	ap;
    map
	ap : ref bblock;
    local
	crfsts;
    namelengthcheck (ap [tpa$l_tokencnt], lnk$gt_symstring);	!Check symbol name length
    search_insert_symbol (ap [tpa$l_tokencnt], cursymdesc, 	!Insert into symbol table
	cursymsnb);
    cursymdesc [sym$w_flags] = (.cursymdesc [sym$w_flags] and 	!Clear all the flag bits
    (gsy$m_uni or sym$m_supres))		! except uni and supres
    or (gsy$m_def or sym$m_optsym);		! and set def and optsym

    if .lnk$gl_ctlmsk [lnk$v_cros]		!If cross referencing
    then
	begin
	crossref_symbol (.cursymdesc, .cursymsnb, 	!Insert symbol definition
	    .cursymdesc [sym$w_flags]);
	crfsts = crf$insrtref (lnk$al_sytblfmt, cursymsnb [snb$b_namlng], 	!  then insert a reference
	    defined_by_option, gsy$m_def, 	!  saying defined by option
	    crf$k_def);				!  and this is a defining reference

	if not .crfsts				!Report error from cref if so
	then
	    signal (lin$_crferr, 0, .crfsts);

	lnk$gl_maxsymsz = maxu (.lnk$gl_maxsymsz, 	!Set maximum symbol name length
	    .cursymsnb [snb$b_namlng]);
	lnk$gl_maxmodsz = maxu (.lnk$gl_maxmodsz, 	! and maximum module name length
	    %charcount ('<Linker option>'));
	lnk$gw_ncrosrfs = .lnk$gw_ncrosrfs + 1;	!Count the cross reference
	end;
    return true
    end;					!Of definesymbolname

routine definesymbolval =
    begin
!
! This routine is called by TPARSE when the value is parsed in the SYMBOL= option
!
    builtin
	remque,
	ap;
    map
	ap : ref bblock;
    local
	nxtsyment,
	crfsts;

    if .cursymdesc[sym$l_udflink] neq 0		! Is symbol on undefined list already?
    then					!  (via a previous UNIV=this_symbol)
	begin
	remque(cursymdesc[sym$l_udflink], nxtsyment);	! If so, then remove it and lower
	lnk$gw_nudfsyms = .lnk$gw_nudfsyms - 1;		!  the count of undefined symbols 
	end;
    cursymdesc [sym$l_value] = .ap [tpa$l_number];	!Set the symbol value
    if .lnk$gl_ctlmsk [lnk$v_long]		!If generating a long map
    then
	begin
	crfsts = crf$insrtref (lnk$al_valctltb, cursymdesc [sym$l_value],
						! then insert a reference to its value
	    cursymsnb [snb$b_namlng], .cursymdesc [sym$w_flags], 0);
	if not .crfsts then signal (lin$_crferr, 0, .crfsts);
	end;
    return true
    end;					!of definesymbolval

routine set_unsupported =
    begin
!---
!
! This routine is called by TPARSE to process the UNSUPPORTED= option.
!
! Currently, only the low bit of this mask is defined -- when set it means
! that demand zero pages should be allowed for a shareable image.  In the future,
! this should be done by looking at the ISD attributes, but this is too risky
! at this stage in the release.  (The real problem is that the image-activator
! does not know how to deal with shared demand zero sections.)
!
! Inputs:
!
!	AP			Points to tparse_block
!	AP[tpa$l_number]	Bit mask for LNK$GL_UNSUPPORTED
!
! Outputs:
!
!	lnk$gl_unsupported	set up
!
!---
    builtin
	ap;
    map
	ap : ref bblock;
    lnk$gl_unsupported = .ap [tpa$l_number] ;
    return true
    end;


routine set_universal =
    begin
!
! This routine is called for each symbol in the UNIVERSAL option by TPARSE
!
    builtin
	ap;
    map
	ap : ref bblock;

    namelengthcheck (ap [tpa$l_tokencnt], lnk$gt_symstring);	!Check length of symbol name
    search_insert_symbol (ap [tpa$l_tokencnt], cursymdesc, cursymsnb);
						!Lookup/insert symbol into symbol table
    cursymdesc [sym$w_flags] = (.cursymdesc[sym$w_flags] and	! Preserve def and supres 
				(gsy$m_def or sym$m_supres))	!  bits, and set universal
				 or gsy$m_uni;			!  flag 
    if not .cursymdesc[sym$v_def] 			! If not defined,
    then 						!  then insert in
	lnk$insudfsym (.cursymdesc);			!  undefined list
    crossref_symbol (.cursymdesc, .cursymsnb,		!Cross reference the symbol
			.cursymdesc[sym$w_flags]);
    return true
    end;					!Of set_univ

routine set_alluniv =
    begin
!
! Flag all universal temporarily
!
    lnk$gl_ctlmsk [lnk$v_alluniv] = true;
    return true;				
    end;

routine set_include =
    begin
!
! This routine processes the /include qualifier
!
    builtin
	ap;
    map
	ap : ref bblock;
    set_qual_flags (.ap, (fdb$m_libr or fdb$m_libextr));	!Set qualifier flag
    lnk$setlibrin(1);
    return true
    end;					!Of set_include

routine set_library =
    begin
!
! This routine processes the /library qualifier
!
    builtin
	ap;
    map
	ap : ref bblock;
    set_qual_flags (.ap, (fdb$m_libr or fdb$m_libsrch));
    lnk$setlibrin(1);
    return true
    end;					!Of set_library

routine set_selective =
    begin
!
! This routine processes the /selective qualifier
!
    builtin
	ap;
    map
	ap : ref bblock;
    set_qual_flags (.ap, fdb$m_selser);
    return true
    end;					!Of set_selective

routine set_shareable =
    begin
!
! This routine processes the /shareable qualifier
!
    builtin
	ap;
    map
	ap : ref bblock;
    local
	descr : bblock [dsc$c_s_bln];

    set_qual_flags (.ap, fdb$m_shr);
    if .lnk$gl_ctlmsk [lnk$v_sys]		!Don't allow /share with /sys
    then
	signal_stop (lin$_shrinsys);
!
! If this is in a cluster= option and there are other
! files in the cluster, issue a warning and create a new
! cluster.
!
    if .cluoptflag and .lnk$gl_curclu [clu$l_fstfdb] neq 0
    then
	begin
	descr [dsc$w_length] = .tparse_block [tpa$l_tokenptr] - .cmdbuffer;
	descr [dsc$a_pointer] = .cmdbuffer;
	signal (lin$_shrsepclu, 0, lin$_optlin, 3, descr, tparse_block [tpa$l_tokencnt],
	    tparse_block [tpa$l_stringcnt]);
	lnk$allocluster (lnk$gl_curclu);	!Allocate a new cluster
	lnk$gl_curclu [clu$v_protect] = .protectflag;	!Set protect if on
	end;

    if not .cluoptflag				!If not processing cluster= option
    then
	begin
	lnk$allocluster (lnk$gl_curclu);	! then allocate a new cluster descriptor
	lnk$gl_curclu [clu$v_protect] = .protectflag;	!Set protect if on
	end;

    lnk$gl_curclu [clu$v_shrimg] = true;
    lnk$gl_curclu [clu$v_copy] = .sharecopy;
    lnk$setshrblin ();
    return true
    end;					!Of set_shareable

routine set_shrcopyflag =
    begin
!
! This routine is called by TPARSE to set/clear the copyflag for /share
!
    builtin
	ap;
    map
	ap : ref bblock;
    if .sharecopy neq 0
    then
	begin
	signal (lin$_shrcpyign);
	sharecopy = 0;
	end;
    return true
    end;					!Of set_shrcopyflag

routine insertcluster =
    begin
!
! This routine inserts the current cluster in the cluster tree
!
    local
	blockaddr;

    if lib$lookup_tree (lnk$gl_clutree, lnk$gl_curclu [clu$b_namlng], 	!If cluster name already in tree
	    lnk$clunamcmp, blockaddr)
    then
	signal (lin$_mulcluopt, 2, lnk$gl_curclu [clu$b_namlng], 	!  then tell user
	    .optionfilename);

    lnk$insert_clu (.lnk$gl_curclu);		!Insert the cluster in the tree
    return true
    end;

routine processfile =
    begin
!
! This routine is called by TPARSE when a complete file specification
! has been scanned.
!
    builtin
	ap;
    map
	ap : ref bblock;
    local
	descr : bblock [dsc$c_s_bln];
    bind
	filebits = .fileflagsadr : bitvector;

    if (.filebits and fdb$m_libr)	! Call lnk$setlibrin now that all 
    then				!  qualifier parsing is done
	lnk$setlibrin(1);
    if .cluoptflag				!If processing a cluster= option
    then
	begin
	if .lnk$gl_curclu [clu$v_shrimg]	!If current cluster is shareable image
	    and ((.filebits and fdb$m_shr) eql 0)	! and this file is not a shareable image
	then
	    begin
	    descr [dsc$w_length] = .tparse_block [tpa$l_tokenptr] - .cmdbuffer;
						!Create string descriptor for part of line
	    descr [dsc$a_pointer] = .cmdbuffer;
	    signal (lin$_shrsepclu, 0, 		!Tell user we are creating new cluster
		lin$_optlin, 3, descr, tparse_block [tpa$l_tokencnt], tparse_block [tpa$l_stringcnt]);
	    lnk$allocluster (lnk$gl_curclu);	!Allocate a new cluster
	    descr [dsc$w_length] = sym$c_maxlng;	!Set length of buffer
	    descr [dsc$a_pointer] = lnk$gl_curclu [clu$t_name];	!And starting address
	    sys$fao (uplit (stringdesc ('!AC_!UL')), descr, descr,
						!Create cluster name of default_cluster_N
		lnk$gl_defclu [clu$b_namlng], .lnk$gl_defclunum);
	    lnk$gl_curclu [clu$b_namlng] = .descr [dsc$w_length];	!Set resulting cluster name length
	    lnk$gl_defclunum = .lnk$gl_defclunum + 1;
	    lnk$gl_curclu [clu$v_protect] = .protectflag;
	    end;
	end
    else
	if .lnk$gl_curclu [clu$v_shrimg]	!Not cluster option, is current cluster shr image?
	    and .lnk$gl_curclu [clu$l_fstfdb] neq 0	! and there are files in the cluster
	then
	    lnk$gl_curclu = lnk$gl_defclu;	!Put this file in the default cluster
!
! If this file is a shareable image, or the first file in a CLUSTER=
! option, then insert the cluster into the cluster list
!
    if .lnk$gl_curclu [clu$v_shrimg] or (.cluoptflag and (.lnk$gl_curclu [clu$l_fstfdb] eql 0))
    then
	begin
	if .lnk$gl_curclu [clu$v_shrimg]	!If cluster is shareable image
	then
	    begin				! then we must set the cluster name
	    getfilename (filespec_desc, descr);	!Get filename portion of file spec
	    lnk$gl_curclu [clu$b_namlng] = .descr [dsc$w_length];	!Set length into cluster descriptor
	    ch$move (.descr [dsc$w_length], .descr [dsc$a_pointer], 	!Copy in cluster name
		lnk$gl_curclu [clu$t_name]);
	    end;
	insertcluster ();			!Insert cluster in cluster tree
	end;

    lnk$gl_inclst = include_desc;
    inputfile(filespec_desc, 1 );
    return true
    end;					!Of processfile

routine getfilename (filedesc, retdesc) =
    begin
!
! This routine returns the filename portion of a
! file specification
!
    map
	filedesc : ref bblock,
	retdesc : ref bblock;
    local
	status,
	rsldsc : vector [2],
	rslbuf : bblock [nam$c_maxrss],
	rsabuf : bblock [nam$c_maxrss],		! buffer for resultant string
	esabuf : bblock [nam$c_maxrss],		! buffer for expanded string
	filefab : bblock [fab$c_bln],		! temporary FAB
	filenam : bblock [nam$c_bln];		! temporary NAM block

    rsldsc [0] = nam$c_maxrss;
    rsldsc [1] = rslbuf;

    if (status = $trnlog (lognam = .filedesc, 	! If the filedesc is a logical name,
	    rslbuf = rsldsc)) eql ss$_normal
    then 					!   don't translate, just return
	begin
	retdesc [dsc$w_length] = .filedesc [dsc$w_length];
	retdesc [dsc$a_pointer] = .filedesc [dsc$a_pointer];
	return true;
	end;

    $nam_init (nam = filenam, rsa = rsabuf, rss = nam$c_maxrss, esa = esabuf, ess = nam$c_maxrss);
    $fab_init (fab = filefab, fop = nam, fna = .filedesc [dsc$a_pointer], fns = .filedesc [dsc$w_length],
	nam = filenam);
    $parse (fab = filefab);
    retdesc [dsc$w_length] = .filenam [nam$b_name];
    retdesc [dsc$a_pointer] = ch$find_sub (.filedesc [dsc$w_length], .filedesc [dsc$a_pointer],
	.filenam [nam$b_name], .filenam [nam$l_name]);
    return true
    end;

routine set_qual_flags (tpablock, qualbits) =
!
! This routine checks for conflicting qualifiers and then sets the proper bits
!
    begin
    map
	tpablock : ref bblock;
    local
	descr : bblock [dsc$c_s_bln];

    if (..fileflagsadr and .tpablock [tpa$l_param]) neq 0	!Check for conflicting qualifiers
    then
	begin
	descr [dsc$w_length] = .tpablock [tpa$l_tokenptr] - .cmdbuffer;
	descr [dsc$a_pointer] = .cmdbuffer;
	signal_stop (lin$_confqual, 0, lin$_optlin, 3, descr, tpablock [tpa$l_tokencnt],
	    tpablock [tpa$l_stringcnt]);
	end
    else
	.fileflagsadr = ..fileflagsadr or .qualbits;
    return true
    end;					!Of set_qual_flags

%sbttl 'Search / insert into linked, ordered list';
routine search_insert_list (listhead, namedesc, blocksize, blockaddr) =
    begin
!---
! This routine searches a linked list for a given name.  If the name is
! not found, a new node is created and the name is inserted.  The structure
! of the links in the list must be as follows:
!
!	ptr===>	link to next entry
!		size of name (byte)
!		name
!		(any other data)
!
! Inputs:
!
!	listhead	the address of the linked list head
!	blocksize	size of block to allocate if not found
!
! Outputs:
!
!	blockaddr	entry address
!
!---
    macro
	nextblock =  0,0,32,0%,					!First longword is link
	namesize =  4,0,8,0%,					!Then a byte of name length
	nameaddr =  5,0,0,0%;					!Followed by name
    map
	listhead : ref bblock,
	namedesc : ref bblock;
    local
	lastblock : ref bblock,
	thisblock : ref bblock;

    thisblock = .listhead;			!Start at top of list
    lastblock = .thisblock;
!
! Loop looking for entry, or one less than desired entry
!
    while (thisblock = .thisblock [nextblock]) neq 0 do
	if ch$eql (.thisblock [namesize], thisblock [nameaddr], .namedesc [dsc$w_length],
		.namedesc [dsc$a_pointer], 0)
	then
	    begin
	    .blockaddr = .thisblock;		!Return found entry to caller
	    return true;
	    end
	else
	    lastblock = .thisblock;
!
! Name was not found...allocate a new one
!
    lnk$alloblk (.blocksize, thisblock);
    ch$fill (0, .blocksize, .thisblock);	!Zero the block
    thisblock [nextblock] = .lastblock [nextblock];	!Link into the list
    lastblock [nextblock] = .thisblock;
    thisblock [namesize] = .namedesc [dsc$w_length];
    ch$move (.namedesc [dsc$w_length], .namedesc [dsc$a_pointer], thisblock [nameaddr]);
    .blockaddr = .thisblock;			!Return address to caller
    return true
    end;					!Of search_insert_list

%sbttl 'Search / insert a symbol';
routine search_insert_symbol (symboldesc, symblock, snblock) =
    begin
!---
! This routine looks up the symbol in the symbol table and returns
! the address of the symbol block.  If it is not found, it is inserted.
!
! Inputs:
!
!	symboldesc	Address of a string descriptor for symbol name
!	symblock	Address of location to return symbol block address
!	snblock		Address of location to return symbol name block address
!
!---
    map
	symboldesc : ref bblock;
    local
	symptr : ref bblock,
	symbolstring : vector [sym$c_maxlng*2, byte];
    ch$move ((symbolstring [0] = .symboldesc [dsc$w_length]), 	!Create an ASCIC string
	.symboldesc [dsc$a_pointer], symbolstring [1]);
    if lnk$search (symbolstring, .symblock, .snblock)	!Look up the symbol
    then
	return true;				! and if found then all done
!
! Not in table, so insert it
!
    lnk$insert (symbolstring, symptr, .snblock);
    symptr [sym$l_udflink] = 0;
    symptr [sym$w_flags] = 0;
    .symblock = .symptr;
    return true
    end;					!Of search_insert_list

%sbttl 'Cross reference a symbol';
routine crossref_symbol (symbolblock, snblock, flags) =
    begin
!---
!
! Enter symbol into cross reference if generating one.
!
! Inputs:
!
!	symbolblock		Pointer to symbol descriptor block
!	snblock			Pointer to name part of symbol block
!	flags			Flags to enter into cross reference
!
!---
    map
	symbolblock : ref bblock,
	snblock : ref bblock;
    local
	crfsts;

    if .lnk$gl_ctlmsk [lnk$v_map]		!If generating a map
	and not .lnk$gl_ctlmsk [lnk$v_brief]	! that is not brief
    then
	begin
	crfsts = crf$insrtkey (lnk$al_sytblfmt, 	!  then insert the symbol
	    snblock [snb$b_namlng], 		!  passing the name
	    symbolblock [sym$l_value], 		!  the value address
	    .flags);				!  and the flags

	if not .crfsts then signal (lin$_crferr, 0, .crfsts);

	lnk$gl_maxsymsz = maxu (.lnk$gl_maxsymsz, 	!Set maximum symbol name length
	    .snblock [snb$b_namlng]);
	end;
    return true
    end;					!Of crossref_symbol

%sbttl 'Debug routine to catch TPARSE in action';
routine debug_stop =
    begin
    return true
    end;

%sbttl 'Check length of name';
routine namelengthcheck (namedesc, nametype, special_length) =
    begin
!
! This routine checks that the symbol name is gtr 0
! and leq sym$c_maxlng and issues a SIGNAL_STOP if not
!
    map
	namedesc : ref bblock;
    local
	max_length;
    builtin
	nullparameter;

    if not nullparameter (3) 
	then max_length = .special_length 
	else max_length = sym$c_maxlng;
    if .namedesc [dsc$w_length] eql 0 or .namedesc [dsc$w_length] gtru .max_length
						!Check for illegal name length
    then
	begin
	local
	    symbolbuf : vector [512, byte];	!Local buffer to copy name

	symbolbuf [0] = .namedesc [dsc$w_length];	!Create ASCIC string
	ch$move (minu (.namedesc [dsc$w_length], 512), 	!Copy as much of name in as possible
	    .namedesc [dsc$a_pointer], symbolbuf [1]);
	signal_stop (lin$_illnamelen, 6, .nametype, 	!Report error and quit
	    symbolbuf, .namedesc [dsc$w_length], .max_length, optionfilestring, .optionfilename);
	end;
    return true
    end;

%sbttl 'Options parsing error routines';
routine syntaxerr =
    begin
!
! This routine is called by TPARSE to report a syntax error and quit
!
    local
	descr : bblock [dsc$c_s_bln];

    descr [dsc$w_length] = .tparse_block [tpa$l_tokenptr] - .cmdbuffer;
    descr [dsc$a_pointer] = .cmdbuffer;
    signal_stop (lin$_optsynerr, 1, .optionfilename, lin$_optlin, 3, descr, tparse_block [tpa$l_tokencnt],
	tparse_block [tpa$l_stringcnt]);
    return true					!SIGNAL_STOP doesn't return, but...
    end;					!Of syntaxerr

routine optionvaluerr (option_name, tpablock, minval, maxval) =
    begin
!
! This routine signals an option value error and stops the image.
!
    map
	tpablock : ref bblock;
    local
	descr : bblock [dsc$c_s_bln];

    descr [dsc$w_length] = .tpablock [tpa$l_tokenptr] - .cmdbuffer;
    descr [dsc$a_pointer] = .cmdbuffer;
    signal_stop (lin$_optvalerr, 5, .option_name, .tpablock [tpa$l_number], .minval, .maxval,
	.optionfilename, lin$_optlin, 3, descr, tpablock [tpa$l_tokencnt], tpablock [tpa$l_stringcnt]);
    return true
    end;					!Of optionvaluerr

routine missingargerr =
    begin
!
! This routine is called by TPARSE to report a missing argument for an option
!
    local
	descr : bblock [dsc$c_s_bln];

    descr [dsc$w_length] = .tparse_block [tpa$l_tokenptr] - .cmdbuffer;
    descr [dsc$a_pointer] = .cmdbuffer;
    signal_stop (lin$_optargmis, 1, .optionfilename, lin$_optlin, 3, descr, tparse_block [tpa$l_tokencnt],
	tparse_block [tpa$l_stringcnt]);
    return true
    end;					!Of missingargerr
end

eludom
