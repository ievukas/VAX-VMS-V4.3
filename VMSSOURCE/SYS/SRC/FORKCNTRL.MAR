	.TITLE	FORKCNTRL - FORK PROCESS CONTROL
	.IDENT	'V04-000'
 
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; D. N. CUTLER 9-AUG-76
;
; MODIFIED BY:
;
;	V03-002	DWT0158		David W. Thiel		 27-DEC-1983
;		Speed up fork processing a bit by doing fewer interrupts
;		and REMQUE's.
;
;	V03-001	ROW0176		Ralph O. Weber		 4-APR-1983
;		Add EXE$FORK_WAIT, the entry fork-and-wait routine which is 
;		the object of the FORK_WAIT macro.
;
;
; MACRO LIBRARY CALLS
;
 
	$FKBDEF				;DEFINE FKB OFFSETS
	$PRDEF				;DEFINE PROCESSOR REGISTERS
	$UCBDEF				;DEFINE UCB OFFSETS
	.PAGE
	.SBTTL	CREATE FORK-AND-WAIT PROCESS
;+
; EXE$FORK_WAIT - CREATE FORK-AND-WAIT PROCESS
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called to fold a fork context into a fork block and 
;	place that block on the fork-and-wait work queue, EXE$GL_FKWAITFL.  
;	From zero to one seconds later, EXE$TIMEOUT will remove all entries in 
;	the fork-and-wait work queue and restart the fork thread saved here.
;
; INPUTS:
;
;	00(SP)	= Return address of the caller
;	04(SP)	= Return address of the caller's caller
;
;	R5	= Address of a fork block
;	R3 & R4	= Saved fork context registers
;
;	IPL >= IPL$_SYNCH
;
;
; OUTPUTS (to caller's caller):
;
;	All registers and IPL are returned as they were when this routine was 
;	called.  Depending upon actions taken by the caller this may be 
;	equivalent to destroying R0 through R5 and altering IPL.
;
; OUTPUTS (to caller after fork-and-wait completed):
;
;	R3 through R5 preserved.
;	All other registers destroyed.
;	IPL = FKB$B_FIPL(R5)
;-

EXE$FORK_WAIT::

	ASSUME	FKB$L_FR4 EQ <FKB$L_FR3 + 4>
	MOVQ	R3, FKB$L_FR3(R5)		; Save fork context registers.
	POPL	FKB$L_FPC(R5)			; Save fork context PC.
	INSQUE	(R5), @W^EXE$GL_FKWAITBL	; Put fork block on work queue.
	RSB					; Return to caller's caller.
	.PAGE
	.SBTTL	CREATE I/O DRIVER FORK PROCESS
;+
; EXE$IOFORK - CREATE I/O DRIVER FORK PROCESS
;
; THIS ROUTINE IS CALLED BY AN I/O DRIVER TO CREATE A FORK PROCESS.
;
; INPUTS:
;
;	00(SP) = RETURN ADDRESS OF CALLER.
;	04(SP) = RETURN ADDRESS OF CALLER'S CALLER.
;
;	R5 = UCB ADDRESS OF DEVICE UNIT.
;
; OUTPUTS:
;
;	***TBS***
;-
 
	.PSECT	A$EXENONPAGED,LONG
EXE$IOFORK::				;CREATE I/O DRIVER FORK PROCESS
	BICW	#UCB$M_TIM,UCB$W_STS(R5);DISABLE TIMEOUT AND FALL THROUGH
					;TO EXE$FORK

	.SBTTL	CREATE FORK PROCESS
;+
; EXE$FORK - CREATE FORK PROCESS
;
; THIS ROUTINE IS CALLED TO CREATE A FORK PROCESS.
;
; INPUTS:
;
;	00(SP) = RETURN ADDRESS OF CALLER.
;	04(SP) = RETURN ADDRESS OF CALLER'S CALLER.
;
;	R5 = ADDRESS OF FORK BLOCK.
;
; OUTPUTS:
;
;	***TBS***
;-
 
EXE$FORK::				;CREATE FORK PROCESS
	MOVQ	R3,FKB$L_FR3(R5)	;SAVE REGISTERS R3 AND R4
	POPL	FKB$L_FPC(R5)		;SET FORK PROCESS PC
	MOVZBL	FKB$B_FIPL(R5),R4	;GET FORK IPL
	MOVAQ	W^SWI$GL_FQFL-<6*8>[R4],R3 ;GET ADDRESS OF FORK QUEUE LISTHEAD
	INSQUE	(R5),@4(R3)		;INSERT FORK BLOCK IN FORK QUEUE
	BNEQ	10$			;IF QUEUE ALREADY POPULATED AVOID EXTRA INTERRUPT
	SOFTINT	R4			;INITIATE SOFTWARE INTERRUPT
10$:	RSB				; AND RETURN

	.SBTTL	SOFTWARE INTERRUPT ENTRY POINTS
;+
; THE APPROPRIATE ENTRY POINT IS AUTOMATICALLY VECTORED TO WHEN THE SOFTWARE 
; INTERRUPT PRIORITY ARBITRATION LOGIC IN THE CENTRAL PROCESSOR DETECTS A
; PENDING INTERRUPT AT LEVEL 6, 8, 9, 10, OR 11 AND THE CURRENT PRIORITY LEVEL
; IS LOWER THAN THE PENDING LEVEL. THE STATE OF THE STACK ON ENTRY IS:
;
;	00(SP) = INTERRUPT PC.
;	04(SP) = INTERRUPT PSL.
;
; THERE IS AN ENTRY POINT FOR EACH FORK LEVEL SO THAT THE HARDWARE IPL REGISTER
; WILL NOT HAVE TO BE READ TO DETERMINE THE CURRENT PROCESSOR IPL.  READING THE
; IPL REGISTER IS SLOW ENOUGH TO WARRANT THE ADDITIONAL CODE.
;-

	.ALIGN	LONG			;ENTRY POINT MUST BE LONGWORD ALIGNED
EXE$FRKIPL6DSP::			;FORK IPL 6 ENTRY POINT
	PUSHL	R6			;SAVE R6.
	MOVAQ	W^SWI$GL_FQFL,R6	;GET ADDRESS OF FORK QUEUE LISTHEAD
	BRB	EXE$FORKDSPTH		;BRANCH TO COMMON CODE

	.ALIGN	LONG			;ENTRY POINT MUST BE LONGWORD ALIGNED
EXE$FRKIPL9DSP::			;FORK IPL 9 ENTRY POINT
	PUSHL	R6			;SAVE R6.
	MOVAQ	W^SWI$GL_FQFL+24,R6	;GET ADDRESS OF FORK QUEUE LISTHEAD
	BRB	EXE$FORKDSPTH		;BRANCH TO COMMON CODE

	.ALIGN	LONG			;ENTRY POINT MUST BE LONGWORD ALIGNED
EXE$FRKIPL10DSP::			;FORK IPL 10 ENTRY POINT
	PUSHL	R6			;SAVE R6.
	MOVAQ	W^SWI$GL_FQFL+32,R6	;GET ADDRESS OF FORK QUEUE LISTHEAD
	BRB	EXE$FORKDSPTH		;BRANCH TO COMMON CODE

	.ALIGN	LONG			;ENTRY POINT MUST BE LONGWORD ALIGNED
EXE$FRKIPL11DSP::			;FORK IPL 11 ENTRY POINT
	PUSHL	R6			;SAVE R6.
	MOVAQ	W^SWI$GL_FQFL+40,R6	;GET ADDRESS OF FORK QUEUE LISTHEAD
	BRB	EXE$FORKDSPTH		;BRANCH TO COMMON CODE

	.ALIGN	LONG			;ENTRY POINT MUST BE LONGWORD ALIGNED
EXE$FRKIPL8DSP::			;FORK IPL 8 ENTRY POINT
	PUSHL	R6			;SAVE R6.
	MOVAQ	W^SWI$GL_FQFL+16,R6	;GET ADDRESS OF FORK QUEUE LISTHEAD
	NOP				;PAD OUT TO LONGWORD BOUNDARY
	;
	; DROP THROUGH TO COMMON CODE
	;

	.SBTTL	SOFTWARE INTERRUPT FORK DISPATCHER
;+
; EXE$FORKDSPTH - SOFTWARE INTERRUPT FORK DISPATCHER
;
; FOR EACH OF THE LEVELS 6, 8, 9, 10, AND 11, THERE EXISTS A QUEUE OF FORK
; BLOCKS WAITING TO BE PROCESSED. WHEN A FORK BLOCK IS ENTERED IN ITS 
; CORRESPONDING QUEUE AND IT IS THE FIRST TO BE ENTERED (I. E. THE QUEUE
; WAS PREVIOUSLY EMPTY), A SOFTWARE INTERRUPT IS REQUESTED FOR THAT LEVEL.
; THE FORK DISPATCHER GAINS CONTROL AND EMPTIES THE QUEUE ONE ENTRY AT A
; TIME. AS EACH FORK IS DISPATCHED, REGISTERS R3 AND R4 ARE RESTORED FROM
; THE FORK BLOCK AND THE FORK PROCESS IS CALLED VIA A JSB INSTRUCTION.
; ON RETURN, THE FORK DISPATCHER RETRIEVES THE NEXT ENTRY FROM THE QUEUE
; AND REPEATS THE DISPATCHING OPERATION. THIS PROCESS CONTINUES UNTIL
; THERE ARE NO MORE FORKS TO DISPATCH AT WHICH TIME THE INTERRUPT IS
; DISMISSED.
;
; 
;-
	.ALIGN	LONG
EXE$FORKDSPTH::				;SOFTWARE INTERRUPT FORK DISPATCHER
	PUSHL	R5			;SAVE R5 .
	PUSHL	R4			;SAVE R4  .
	PUSHL	R3			;SAVE R3   . PUSHLS ARE FASTEST!
	PUSHL	R2			;SAVE R2  .
	PUSHL	R1			;SAVE R1 .
	PUSHL	R0			;SAVE R0.
	BRB	20$			;BRANCH TO BODY OF DISPATCHER
;
; DISPATCH FORK PROCESS WHEN QUEUE IS NOT YET EMPTY
; DISPATCH FORK PROCESS WITH:
;
;	R0 THRU R2 = SCRATCH REGISTERS.
;	R3 AND R4 = RESTORED FROM FORK BLOCK.
;	R5 = ADDRESS OF FORK BLOCK.
;
10$:	MOVQ	FKB$L_FR3(R5),R3	;RESTORE REGISTERS R3 AND R4
	JSB	@FKB$L_FPC(R5)		;DISPATCH FORK
20$:	REMQUE	@(R6),R5		;REMOVE NEXT ENTRY FROM FORK QUEUE
	BNEQ	10$			;BRANCH IF QUEUE NOT YET EMPTY
	BVS	30$			;IF VS NO ENTRY REMOVED
					;HERE WHEN LAST ENTRY DEQUEUED
;
; DISPATCH LAST ENTRY IN THE QUEUE
; DISPATCH FORK PROCESS WITH:
;
;	R0 THRU R2 = SCRATCH REGISTERS.
;	R3 AND R4 = RESTORED FROM FORK BLOCK.
;	R5 = ADDRESS OF FORK BLOCK.
;
	MOVQ	FKB$L_FR3(R5),R3	;RESTORE REGISTERS R3 AND R4
	JSB	@FKB$L_FPC(R5)		;DISPATCH FORK
30$:	POPR	#^M<R0,R1,R2,R3,R4,R5,R6> ;RESTORE FORK PROCESS REGISTER SET
	REI				;DISMISS INTERRUPT	

	.END
