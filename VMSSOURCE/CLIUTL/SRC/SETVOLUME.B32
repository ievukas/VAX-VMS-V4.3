
MODULE setvol	(
		IDENT = 'V04-000',
    		ADDRESSING_MODE(EXTERNAL=GENERAL,
    				NONEXTERNAL=LONG_RELATIVE)
		) =
BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY:	Set Volume Command
!
! ABSTRACT:
!
!	This module processes the Set Volume command.
!
! ENVIRONMENT:
!
!	Vax native, privileged user mode
!
!--
!
! AUTHOR:	Gerry Smith	 	CREATION DATE: 3-Nov-1981
!
! MODIFIED BY:
!
!
!	V03-010 AEW0003		Anne E. Warner		18-Jul-1984
!		Add a check to see if the device specified is a
!		Files-11 format disk and if not tell the user.
!		This check includes the new error message:
!		  set$_notdisk, device is not a files-11 format disk 
!
!		Also check to see if qualifiers with 'values' check
!		that the qualifier is present before looking for values.
!		This is because most qualifiers are negatable now.
!		As a result this check was added to /LABEL when it is
!		checked for.
!
!	V03-009	DAS0001		David Solomon		09-Jul-1984
!		Add support for /REBUILD - perform volume rebuild.
!
!	V03-008 AEW0002		Anne E. Warner		24-May-1984
!		Change RMS access to $QIOW access so that the home
!		block can be found in ODS1 structure blocks.  The 
!		problem was that RMS sees the End-of-File as zero
!		on an ODS1 initialized volume and will not look for a
!		valid home block.
!
!	V03-007	LMP0221		L. Mark Pilant,		9-Apr-1984  10:46
!		Change UCB$L_OWNUIC to ORB$L_OWNER and UCB$W_VPROT to
!		ORB$W_PROT.
!
!	V03-006	MCN0164		Maria del C. Nasr	03-Apr-1984
!		The /DATA_CHECK qualifier must accept NOREAD and NOWRITE.
!
!       V03-005 AEW0001         Anne E. Warner          21-Mar-1984
!               Add a check to see if volume is mounted foreign.  If
!               it is it cannot be modified because it is not in 
!               Files-11 format so notify the user and exit.
!
!	V03-004	GAS0132		Gerry Smith		13-May-1983
!		Add [NO]HIGHWATER, [NO]UNLOAD, [NO]MOUNT_VERIFICATION,
!		[NO]ERASE_ON_DELETE.  Also modify VOLSET.SYS on the
!		root volume for volume sets if /LABEL specified.
!
!	V03-003	GAS0121		Gerry Smith		14-Apr-1983
!		For ODS1 disks, fold long UICs into <377,377>.
!
!	V03-002	GAS0112		Gerry Smith		29-Mar-1983
!		Convert to new CLI interface, and new command dispatcher.
!
!	V03-001	GAS52349	Gerry Smith		 4-Jan-1983
!		Remove one level of indirection from the DEVCHAR field
!		of the UCB when modifying its contents.
!
!	V03-006	GAS0091		Gerry Smith		19-Oct-1982
!		Change input request for new CLD syntax.
!
!	V03-005	GAS0040		Gerry Smith		 2-Feb-1982
!		Fix privilege checking to check for write access to
!		the volume's index file.  Also, fix write bug that
!		prevented modified home blocks to be written back.
!
!	V03-004	GAS0033		Gerry Smith		12-Jan-1982
!		Fix various bugs.
!
!	V03-003	GAS0030		Gerry Smith		 1-Jan-1982
!		Add /RETENTION, the default retention period for files
!		created on a volume.
!
!	V03-002 GAS0026		Gerry Smith		18-Dec-1981
!		Use shared message file, and lower fatal messages to
!		simple error messages.
!
!	V03-001	GAS0025		Gerry Smith		14-Dec-1981
!		Add /LOG qualifier 
!
!**

LIBRARY	'SYS$LIBRARY:LIB';
LIBRARY 'SYS$LIBRARY:TPAMAC';


!
! ***** Note: The following macro violates the Bliss language definition
! ***** in that it makes use of the value of SP while building the arg list.
! ***** It is the opinion of the Bliss maintainers that this usage is safe
! ***** from planned future optimizations.
!
! Macro to call the change mode to kernel system service.
! Macro call format is "KERNEL_CALL (ROUTINE, ARG1, ARG2, ... )".
!
MACRO
	KERNEL_CALL (R) =
	    BEGIN
	    EXTERNAL ROUTINE SYS$CMKRNL : ADDRESSING_MODE (ABSOLUTE);
	    BUILTIN SP;
	    SYS$CMKRNL (R, .SP, %LENGTH-1
			%IF %LENGTH GTR 1 %THEN ,%REMAINING %FI)
	    END%;


FORWARD ROUTINE
    set$volume : NOVALUE,		! Main routine for volume
    get_quals,				! Get qualifiers
    parse_class,			! Parse a protection class
    process_volume_set : NOVALUE,	! Process volume set
    process_one_volume : NOVALUE,	! Process each volume
    modify_volset : NOVALUE,		! Fix VOLSET.SYS
    set_home,				! Modify the homeblock
    set_ucbvcb : NOVALUE,		! Modify the UCB and VCB for the disk
    read_homeblock;			! Find and read first good homeblock
    

EXTERNAL ROUTINE
    cli$present,			! Get qualifier
    cli$get_value,			! Get value for qualifier
    lib$file_scan,			! Routine to get next directory
    check_privilege : NOVALUE,		! Routine to check for privilege
    search_error,			! Where to go if file search fails
    file_error,				! Where to go if file error occurs
    checksum2,				! Compute checksum
    get_channelucb,			! Routine to get address of UCB
    lib$cvt_dtb,			! Convert decimal to number
    lib$cvt_dtime,			! Convert delta time 
    lib$tparse,				! Parser
    parse_uic,				! Parse a UIC
    sys$fao;				! Formatted ASCII output

!
! External data references
!
EXTERNAL
!
! Data
!
    exte_value,					! EXTENSION value
    uic_value,					! Owner UIC
    group,					! UIC group number
    member;					! UIC member number

!
! Error messages
!
EXTERNAL LITERAL
    cli$_ivprot,			! Invalid protection value
    cli$_absent,
    set$_operreq,			! OPER privilege required
    set$_badfrmt,                       ! Volume doesn't have Files-11 format 
    set$_hbread,			! Error reading homeblock
    set$_hbwrite,			! Error writing homeblock
    set$_modified,			! Volume modified
    set$_nohome,			! Volume has no good home block
    set$_notdisk,			! Device is not a files-11 format disk
    set$_notmod,                        ! Volume not modified
    set$_notods2,			! Qualifier invalid for ODS1
    set$_readerr,			! Error reading volume
    set$_sysnotupd,			! Error updating ucb and vcb
    set$_writeerr;			! Could not write to file

!
! Declare some shared messages
!
$SHR_MSGDEF	(SET,119,LOCAL,
    		(valerr,	error),
    		(syntax,	error),
    		(openout,	error),
    		(closeout,	error),
    		(invquaval,	error));


!
! Literal data definitions
!
LITERAL
    true = 1,
    false = 0;

LITERAL
    $EQULST
	(QUAL_,,1,1,
	(access,),			! ACCESSED bit
	(data,),			! DATA_CHECK bit
	(exte,),			! EXTENSION bit
	(fprot,),			! FILE_PROTECTION bit
	(label,),			! LABEL bit
	(log,),				! LOG bit
	(owner,),			! OWNER_UIC bit
	(retent,),			! RETENTION bit
	(username,),			! USER_NAME bit
	(vprot,),			! PROTECTION bit
	(windows,),			! WINDOWS bit
	(erase,),			! [NO]ERASE
	(erase_val),
	(fhw,),				! [NO]HIGHWATER
	(fhw_val,),
	(mntver,),			! [NO]MOUNT_VERIFICATION
	(mntver_val,),
	(unl,),				! [NO]UNLOAD
	(unl_val,),
	(rebuild,),			! [NO]REBUILD
	(rebuild_val,),
	(lbl_cpy,));			! Old label was saved
LITERAL
    $EQULST
	(DATA_,,1,1,
	(read,),				! DATA_CHECK = READ
	(write,),				! DATA_CHECK = WRITE
	(noread,),				! DATA_CHECK = NOREAD
	(nowrite,));				! DATA_CHECK = NOWRITE


!
! Define storage for this module that must be global
!
GLOBAL
    acc_value,					! ACCESSED value
    fprot_value,				! FILE_PROTECTION value
    label_value : VECTOR[2],			! LABEL label
    vprot_value,				! PROTECTION value
    retmin_value : VECTOR[2],			! Minimum retention period
    retmax_value : VECTOR[2],			! Maximum retention period
    user_value : VECTOR[2],			! USER_NAME 
    window_value;				! WINDOWS
    

!
! Define own storage for this module
!
OWN
    flags : BITVECTOR[32],		! Qualifier flags word
    dflags : BITVECTOR[32],		! DATA_CHECK flags word
    user_label : VECTOR[12,BYTE],	! Place to put username
    label_buff : VECTOR[vcb$s_volname,BYTE],	! Place to store old label
    buffer : BLOCK[512,BYTE],		! Place for home block
    acc_inc : BYTE,			! Increment to LRU limit
    ods1 : BYTE,			! ODS1 indicator
    channel,				! Channel for $QIOW

    result_file : VECTOR[nam$c_maxrss,BYTE],

    NAM : $NAM (RSA = result_file,
		RSS = nam$c_maxrss),

    FAB : $FAB (DNA = UPLIT BYTE ('[0,0]INDEXF.SYS'),
		DNS = %CHARCOUNT ('[0,0]INDEXF.SYS'),
		FAC = (get, put, bio),
		SHR = (get, upi),
		NAM = nam,
		FOP = ufo);
		

GLOBAL ROUTINE set$volume : NOVALUE =
!++
!
! Functional description
!
!	This is the main control module for SET VOLUME.  It obtains the
!	qualifiers and, for each volume specification, calls the routine
!	that actually modifies the volume's home block.
!
! Calling sequence
!
!	CALL set$volume()
!
! Input parameters
!	none
!
! Output parameters
!	none
!
! Implicit outputs
!	none
!
! Routine value
!	none
!
! Side effects
!	none
!
!--
BEGIN

LOCAL
    dyn_desc : $BBLOCK[dsc$c_s_bln];

!
! Check that the image is running with appropriate privilege.
!
check_privilege();

!
! Get the command qualifiers.
!
IF NOT get_quals()
THEN RETURN;


!
! For each volume specified, perform the operations requested.
!
$init_dyndesc(dyn_desc);				! Make desc. dynamic
WHILE cli$get_value(%ASCID 'VOLUME', dyn_desc)		! For each volume specified,
DO
    BEGIN
    LOCAL
	status,
	max_rvn : volatile,				! Total volumes in set
	original_rvn : volatile,			! Original rvn (this disk)
	root_desc : VECTOR[2],				! Root volume descriptor
    	root_buffer : VECTOR[128,BYTE],			! Place to put root name
	iosb : VECTOR[4,WORD],				! Status block for GETDVI
        devchar : $BBLOCK [DIB$K_LENGTH],               ! Longword of device characterisitcs
							! defined in $DEVDEF
	dvi_list : $ITMLST_DECL(ITEMS=4);		! $GETDVI item list

!
! Get the root volume, the total number of volumes, and the volume number of
! the original volume.
!
    $ITMLST_INIT(ITMLST = dvi_list,			! Set up DVI list
    		(ITMCOD = dvi$_rootdevnam,		! Want root volume
    		 BUFADR = root_buffer,			! name,
    		 BUFSIZ = %ALLOCATION(root_buffer),
    		 RETLEN = root_desc),
    		(ITMCOD = dvi$_volnumber,		! this disk's volume
    		 BUFADR = original_rvn),		! number, and
    		(ITMCOD = dvi$_volcount,		! the total number of
    		 BUFADR = max_rvn),			! volumes.
                (ITMCOD = dvi$_devchar,                 ! Get the device characteristics
                 BUFADR = devchar));                    ! to find if mounted foreign.

    root_desc[1] = root_buffer;                         ! Set up parameter for
                                                        ! later processing.
    status = $GETDVIW(ITMLST = dvi_list,		! Get the information.
    		      DEVNAM = dyn_desc,
    		      IOSB   = iosb);
    IF .status
    THEN status = .iosb[0];
    IF NOT .status					! If a problem, signal,
    THEN SIGNAL(.status)				! otherwise
    ELSE 
!
!  If the device specified is not a Files-11 volume or the volume was mounted 
!  foreign it cannot be modified, so signal an error and exit.
!
!
!  Check if a Files-11 volume was specified
!
      BEGIN
        IF NOT .devchar[dev$v_rnd]
        THEN                                       
        BEGIN
        LOCAL
          nodisk_desc : $BBLOCK[dsc$c_s_bln];           ! descriptor for device
  
          $INIT_DYNDESC (nodisk_desc);
          nodisk_desc[dsc$w_length] = .root_desc[0];    ! length of device name
          nodisk_desc[dsc$a_pointer] = .root_desc[1];   ! device name
          SIGNAL                                        ! inform user of error
           (set$_notmod, 1, nodisk_desc, set$_notdisk);
          RETURN false;
        END;
!
!  It is a Files-11 device so check if mounted foreign
!
        IF .devchar[dev$v_for]                     
        THEN                                       
        BEGIN
        LOCAL
          foreign_desc : $BBLOCK[dsc$c_s_bln];          ! descriptor for volume name
  
          $INIT_DYNDESC (foreign_desc);
          foreign_desc[dsc$w_length] = .root_desc[0];   ! length of volume name
          foreign_desc[dsc$a_pointer] = .root_desc[1];  ! volume name
          SIGNAL                                        ! inform user of error
           (set$_notmod, 1, foreign_desc, set$_badfrmt);
          RETURN false;
        END;
!
!  If everything is alright process the volume set.
!
        process_volume_set(root_desc,			
			    .original_rvn,
			    .max_rvn);
      END;
    END;

RETURN;
END;

ROUTINE get_quals =
!++
!
! This routine interrogates the CLI to get all the qualifiers and 
! values.
!
!__
BEGIN

BUILTIN
    addm,
    cmpm;

LOCAL
    status,
    desc : $BBLOCK[dsc$c_s_bln];

$init_dyndesc(desc);				! Make the desc. dynamic

!
! /ACCESSED
!
IF cli$present(%ASCID 'ACCESSED')
THEN
    BEGIN
    LOCAL privs : $BBLOCK[8];		! Place to store the process privileges
    flags[qual_access] = 1;

!
! Call $SETPRV to get the current privileges of the process.  If the process
! does not have OPER, then signal an error and stop.
!
    IF NOT (status = $SETPRV(ENBFLG = 1,		! Enable
			     PRVADR = 0,		! No new privileges
			     PRMFLG = 1,		! Get current privileges
			     PRVPRV = privs))
    THEN
	BEGIN
	SIGNAL(.status);
	RETURN false;
	END;
    IF NOT .privs[prv$v_oper]
    THEN 
	BEGIN
	SIGNAL(set$_operreq);
	RETURN false;
	END;

!
! The process has the correct privilege, so go ahead and get the value
!
    acc_value = 3;			! Set up the default

!
! If a value was specified, use it; otherwise, use the default.
!
    IF cli$get_value(%ASCID 'ACCESSED', desc)
    THEN 
        BEGIN
	IF NOT LIB$CVT_DTB(.desc[dsc$w_length],
    			   .desc[dsc$a_pointer],
			   acc_value)
	THEN
	    BEGIN
	    SIGNAL(set$_syntax, 1, desc);
	    RETURN false;
	    END;
	IF .acc_value LSS 0			! Check that value is in range
	OR .acc_value GTR 255
	THEN
	    BEGIN
	    SIGNAL(set$_syntax, 1, desc, set$_valerr);
	    RETURN false;
	    END;
	END;
    END;

!
! /DATA_CHECK
!
IF cli$present(%ASCID 'DATA_CHECK')
THEN
    BEGIN
    flags[qual_data] = 1;
    IF NOT cli$get_value(%ASCID 'DATA_CHECK', desc)
    THEN
	dflags[data_write] = 1
    ELSE 
	WHILE cli$get_value(%ASCID 'DATA_CHECK', desc) DO
	BEGIN
	IF CH$EQL(.desc[dsc$w_length], .desc[dsc$a_pointer],
		  .desc[dsc$w_length], UPLIT(BYTE('WRITE')))
	THEN dflags[data_write] = 1
	ELSE IF CH$EQL(.desc[dsc$w_length], .desc[dsc$a_pointer],
		       .desc[dsc$w_length], UPLIT(BYTE('READ')))
	THEN dflags[data_read] = 1
	ELSE IF CH$EQL(.desc[dsc$w_length], .desc[dsc$a_pointer],
		       .desc[dsc$w_length], UPLIT(BYTE('NOWRITE')))
	THEN dflags[data_nowrite] = 1
	ELSE IF CH$EQL(.desc[dsc$w_length], .desc[dsc$a_pointer],
		       .desc[dsc$w_length], UPLIT(BYTE('NOREAD')))
	THEN dflags[data_noread] = 1
	ELSE
	    BEGIN
	    SIGNAL(set$_syntax, 1, desc);
	    RETURN false;
	    END;
	END;
    END;

!
! /[NO]ERASE_ON_DELETE
!
status = cli$present(%ASCID 'ERASE_ON_DELETE');
IF .status NEQ cli$_absent
THEN
    BEGIN
    flags[qual_erase] = 1;
    flags[qual_erase_val] = .status;
    END;

!
! /EXTENSION
!
IF cli$present(%ASCID 'EXTENSION')
THEN
    BEGIN
    flags[qual_exte] = 1;
    exte_value = 5;
    IF cli$get_value(%ASCID 'EXTENSION', desc)
    THEN
	BEGIN
	IF NOT lib$cvt_dtb(.desc[dsc$w_length],
			   .desc[dsc$a_pointer],
			   exte_value)
	THEN
	    BEGIN
	    SIGNAL(set$_syntax, 1, desc);
	    RETURN false;
	    END;
	IF .exte_value LSS 0
	OR .exte_value GTR 65535
	THEN
	    BEGIN
	    SIGNAL(set$_syntax, 1, desc, set$_valerr);
	    RETURN false;
	    END;
	END;
    END;

!
! /FILE_PROTECTION
!
IF cli$present(%ASCID 'FILE_PROTECTION')
THEN
    BEGIN
    BIND
    	setpro_mask = fprot_value + 2 : WORD,
    	setpro_prot = fprot_value : WORD;

    flags[qual_fprot] = 1;
    fprot_value = 0;
    
    IF cli$present(%ASCID 'FILE_PROTECTION.SYSTEM')
    THEN
	BEGIN
	setpro_mask = .setpro_mask OR %X'000F';
	IF cli$get_value(%ASCID 'FILE_PROTECTION.SYSTEM',desc)
	THEN setpro_prot = parse_class(desc);
	END;
    IF cli$present(%ASCID 'FILE_PROTECTION.OWNER')
    THEN
	BEGIN
	setpro_mask = .setpro_mask OR %X'00F0';
	IF cli$get_value(%ASCID 'FILE_PROTECTION.OWNER',desc)
	THEN setpro_prot = .setpro_prot OR parse_class(desc)^4;
	END;
    IF cli$present(%ASCID 'FILE_PROTECTION.GROUP')
    THEN
	BEGIN
	setpro_mask = .setpro_mask OR %X'0F00';
	IF cli$get_value(%ASCID 'FILE_PROTECTION.GROUP',desc)
	THEN setpro_prot = .setpro_prot OR parse_class(desc)^8;
	END;
    IF cli$present(%ASCID 'FILE_PROTECTION.WORLD')
    THEN
	BEGIN
	setpro_mask = .setpro_mask OR %X'F000';
	IF cli$get_value(%ASCID 'FILE_PROTECTION.WORLD',desc)
	THEN setpro_prot = .setpro_prot OR parse_class(desc)^12;
	END;
    END;

!
! /[NO]HIGHWATER_MARKING
!
status = cli$present(%ASCID 'HIGHWATER_MARKING');
IF .status NEQ cli$_absent
THEN
    BEGIN
    flags[qual_fhw] = 1;
    flags[qual_fhw_val] = NOT .status;
    END;

!
! /LABEL
!
IF cli$present(%ASCID 'LABEL')
THEN
    IF cli$get_value(%ASCID 'LABEL', desc)
    THEN
    BEGIN
    flags[qual_label] = 1;
    IF .desc[dsc$w_length] GTR vcb$s_volname
    THEN
	BEGIN
	SIGNAL(set$_syntax, 1, desc);
	RETURN false;
	END;
    label_value[0] = .desc[dsc$w_length];
    label_value[1] = .desc[dsc$a_pointer];
    $init_dyndesc(desc);
    END;

!
! /LOG
!
flags[qual_log] = cli$present(%ASCID 'LOG');

!
! /[NO]MOUNT_VERIFICATION
!
status = cli$present(%ASCID 'MOUNT_VERIFICATION');
IF .status NEQ cli$_absent
THEN
    BEGIN
    flags[qual_mntver] = 1;
    flags[qual_mntver_val] = .status;
    END;

!
! /OWNER_UIC
!
IF cli$present(%ASCID 'OWNER_UIC')
THEN
    BEGIN
    flags[qual_owner] = 1;
    IF NOT cli$get_value(%ASCID 'OWNER_UIC', desc)
    THEN
	BEGIN
	LOCAL
	    iosb : VECTOR[4,WORD];
	status = $GETJPIW(ITMLST = UPLIT(WORD(4,jpi$_uic),
				         uic_value,
				 	 0,
				 	 0),
			   IOSB = iosb);
	IF .status
	THEN status = .iosb[0];
	IF NOT .status
	THEN
	    BEGIN
	    SIGNAL(.status);
	    RETURN false;
	    END;
	END
    ELSE parse_uic(desc, uic_value);
    END;

!
! /PROTECTION
!
IF cli$present(%ASCID 'PROTECTION')
THEN
    BEGIN
    BIND
    	setpro_mask = vprot_value + 2 : WORD,
    	setpro_prot = vprot_value : WORD;

    flags[qual_vprot] = 1;
    vprot_value = 0;
    
    IF cli$present(%ASCID 'PROTECTION.SYSTEM')
    THEN
	BEGIN
	setpro_mask = .setpro_mask OR %X'000F';
	IF cli$get_value(%ASCID 'PROTECTION.SYSTEM',desc)
	THEN setpro_prot = parse_class(desc);
	END;
    IF cli$present(%ASCID 'PROTECTION.OWNER')
    THEN
	BEGIN
	setpro_mask = .setpro_mask OR %X'00F0';
	IF cli$get_value(%ASCID 'PROTECTION.OWNER',desc)
	THEN setpro_prot = .setpro_prot OR parse_class(desc)^4;
	END;
    IF cli$present(%ASCID 'PROTECTION.GROUP')
    THEN
	BEGIN
	setpro_mask = .setpro_mask OR %X'0F00';
	IF cli$get_value(%ASCID 'PROTECTION.GROUP',desc)
	THEN setpro_prot = .setpro_prot OR parse_class(desc)^8;
	END;
    IF cli$present(%ASCID 'PROTECTION.WORLD')
    THEN
	BEGIN
	setpro_mask = .setpro_mask OR %X'F000';
	IF cli$get_value(%ASCID 'PROTECTION.WORLD',desc)
	THEN setpro_prot = .setpro_prot OR parse_class(desc)^12;
	END;
    END;

!
! /[NO]REBUILD
!
status = cli$present(%ASCID 'REBUILD');
IF .status NEQ cli$_absent
THEN
    BEGIN
    flags[qual_rebuild] = 1;
    flags[qual_rebuild_val] = .status;
    END;

!
! /RETENTION
!
IF cli$present(%ASCID 'RETENTION')
THEN
    BEGIN
    LOCAL temp_desc : VECTOR[2];

    flags[qual_retent] = 1;
    
    CH$FILL(0, 8, retmin_value);		! Zero minimum value
    CH$FILL(0, 8, retmax_value);		! Zero maximum value

!
! If a minimum value was not supplied, signal an error
!
    IF NOT cli$get_value(%ASCID 'RETENTION', desc)
    THEN
	BEGIN
	SIGNAL(set$_syntax, 1, desc);
	RETURN false;
	END;

!
! Convert the minimum retention value to 64-bit system delta time format
!
    IF NOT (status = LIB$CVT_DTIME(desc, temp_desc))
    THEN
	BEGIN
	SIGNAL(set$_syntax, 1, retmin_value);
	RETURN false;
	END
    ELSE CH$MOVE(8, temp_desc, retmin_value);	! If no error, put 64-bit 
						    ! delta time in place

!
! If a maximum value was supplied, then convert it in the same way.
!
    IF cli$get_value(%ASCID 'RETENTION', desc)
    THEN
	BEGIN
	IF NOT (status = LIB$CVT_DTIME(desc, temp_desc))
	THEN
	    BEGIN
	    SIGNAL(set$_syntax, 1, retmax_value);
	    RETURN false;
	    END
	ELSE CH$MOVE(8, temp_desc, retmax_value);
	END

!
! If no maximum value was supplied, then use the lesser of:
!	twice the minimum value or
!	the minimum value plus one week
!
!
    ELSE
	BEGIN
	LOCAL
	    double : VECTOR[2],				! Place for 2*RETMIN
	    week_plus : VECTOR[2],			! Place for RETMIN + 7
	    one_week : VECTOR[2]
	    	INITIAL(%X'D71BC000',			! Binary for 7 days
	    		%X'FFFFFA7F');
	ADDM(2, retmin_value, retmin_value, double);	! Get 2*RETMIN
	ADDM(2, one_week, retmin_value, week_plus);	! and RETMIN+7
	IF CMPM(2, double, week_plus) GTR 0		! compare...
	THEN CH$MOVE(8, double, retmax_value)
	ELSE CH$MOVE(8, week_plus, retmax_value);
	END;
    END;

!
! /[NO]UNLOAD
!
status = cli$present(%ASCID 'UNLOAD');
IF .status NEQ cli$_absent
THEN
    BEGIN
    flags[qual_unl] = 1;
    flags[qual_unl_val] = .status;
    END;

!
! /USER_NAME
!
IF cli$present(%ASCID 'USER_NAME')
THEN
    BEGIN
    flags[qual_username] = 1;
    IF NOT cli$get_value(%ASCID 'USER_NAME', desc)
    THEN
	BEGIN
	LOCAL
	    jpi_list : $ITMLST_DECL (ITEMS = 1),
	    iosb : VECTOR[4,WORD];
	$ITMLST_INIT(ITMLST = jpi_list,
		    (ITMCOD = jpi$_username,
	 	     BUFADR = user_label,
	 	     BUFSIZ = hm2$s_ownername,
		     RETLEN = user_value[0]));
	status = $GETJPIW(ITMLST = jpi_list,
			  IOSB   = iosb);
	IF .status
	THEN status = .iosb[0];
	IF NOT .status
	THEN
	    BEGIN
	    SIGNAL(.status);
	    RETURN false;
	    END;
	user_value[1] = user_label;
	END
    ELSE
	BEGIN
	IF .desc[dsc$w_length] GTR hm2$s_ownername
	THEN
	    BEGIN
	    SIGNAL(set$_syntax, 1, desc);
	    RETURN false;
	    END;
	user_value[0] = .desc[dsc$w_length];
	user_value[1] = .desc[dsc$a_pointer];
	$init_dyndesc(desc);
	END;
    END;

!
! /WINDOWS
!
IF cli$present(%ASCID 'WINDOWS')
THEN
    BEGIN
    flags[qual_windows] = 1;
    window_value = 7;
    IF cli$get_value(%ASCID 'WINDOWS', desc)
    THEN
	BEGIN
	IF NOT lib$cvt_dtb(.desc[dsc$w_length],
			   .desc[dsc$a_pointer],
	  		   window_value)
	THEN
	    BEGIN
	    SIGNAL(set$_syntax, 1, desc);
	    RETURN false;
	    END;
	IF .window_value LSS 7
	OR .window_value GTR 80
	THEN
	    BEGIN
	    SIGNAL(set$_syntax, 1, desc, set$_valerr);
	    RETURN false;
	    END;
	END;
    END;

RETURN true;
END;

ROUTINE process_volume_set (root_desc, original_rvn, max_rvn) : NOVALUE =
BEGIN

!++
!
! Find each volume in the volume set and modify it.
!
! Inputs:
!	root_desc - descriptor of root volume
!	original_rvn - volume number of original volume
!	max_rvn - highest volume number in set
!
! Outputs:
!	None.
!
!--

MAP
    root_desc : REF VECTOR;


LOCAL
    status,
    status2,
    saved_flags,				! Saved original flags
    reduced_flags,				! Reduced flags
    this_rvn : volatile,
    iosb : VECTOR[4,WORD],			! $GETDVI status block
    desc1 : VECTOR[2],				! Device descriptors
    desc2 : VECTOR[2],
    buffer1 : VECTOR[128,BYTE],			! Device buffers
    buffer2 : VECTOR[128,BYTE],
    dvi_list : $ITMLST_DECL(ITEMS=2);		! $GETDVI item list

!
! Do a little sneaky stuff first.  Transfer the root volume's name to the
! local descriptor.  Save the current flag settings, and calculate the
! flags for other volumes in this volume set.
!
desc1[0] = .root_desc[0];			! Set up so we
desc1[1] = buffer1;				! can loop easily
desc2[1] = buffer2;
CH$MOVE(.root_desc[0],
    	.root_desc[1],
    	buffer1);

saved_flags = .flags;				! Save original
reduced_flags = .flags AND			! The reduced set has
		(1^qual_erase OR		! only the ERASE
		 1^qual_erase_val OR		! and
		 1^qual_fhw OR			! HIGHWATER
		 1^qual_fhw_val);		! qualifiers

!
! For each volume in the set, check to see if this is the original, or only
! one of the sister volumes, and set FLAGS accordingly.  To do this, we need
! to call $GETDVI to see what the volume number is.  But I'm getting ahead
! of myself...
!
WHILE true DO
    BEGIN
	    
!
! Open a file to the disk.
!
    fab[fab$b_fns] = .desc1[0];
    fab[fab$l_fna] = .desc1[1];
    IF NOT (status = $OPEN(FAB = fab))
    THEN SIGNAL(set$_writeerr,			! Error accessing
		1,
		desc1,				! this disk
		.status)			! for this reason
    ELSE 
        channel = .fab[fab$l_stv];
!
! Get the next volume in the volume set, even if we can't use this one.
! If we can't even get to the next volume, then hang it up.
!
    $ITMLST_INIT(ITMLST = dvi_list,		! Set up DVI list
		(ITMCOD = dvi$_volnumber,	! want current
		 BUFADR = this_rvn),		! volume number,
		(ITMCOD = dvi$_nextdevnam,	! next volume
		 BUFADR = buffer2,		! name.
		 BUFSIZ = %ALLOCATION(buffer2),
		 RETLEN = desc2));
    status2 = $GETDVIW(ITMLST = dvi_list,	! Get the info.
		       DEVNAM = desc1,
		       IOSB   = iosb);
    IF .status2					! If an error at
    THEN status2 = .iosb[0];			! this point, we
    IF NOT .status2				! can't proceed,
    THEN 					! since we don't
	BEGIN					! know which RVN
	SIGNAL(set$_writeerr,			! we're playing with
	       1,
	       desc1,
	       .status2);
	RETURN;
	END;

!
! If the OPEN was successful, then process this volume.
!
    IF .status
    THEN
	BEGIN
	IF .this_rvn NEQ .original_rvn		! If not original disk,
	THEN flags = .reduced_flags;		! use reduced flags.
	IF .flags NEQ 0				! If anything to set,
	THEN process_one_volume(desc1);		! do it.
	flags = .saved_flags;			! Restore flags
	END;

    $DASSGN(CHAN = .channel);			! Deassign the channel

    ! Perform volume rebuild, if requested.
    !
    IF .status AND ( .this_rvn EQL .original_rvn )
    THEN
	IF .flags[qual_rebuild] AND .flags[qual_rebuild_val]
	THEN
	    BEGIN

	    EXTERNAL ROUTINE
		stand_alone_rebuild;	! Perform volume rebuild

	    LOCAL chan: WORD;

	    status = $ASSIGN( DEVNAM=desc1, CHAN=chan );
	    IF NOT .status
	    THEN SIGNAL (set$_openout, 1, desc1, .status, 0);

	    stand_alone_rebuild( .chan );	! Do the rebuild.

	    status = $DASSGN( CHAN=.chan );
	    IF NOT .status
	    THEN SIGNAL (set$_closeout, 1, desc1, .status, 0);

	    END;

    IF .this_rvn EQL .max_rvn			! If end of volume 
    THEN EXITLOOP;				! set, leave

    CH$MOVE(.desc2[0],				! Now switch to the
    	    buffer2,				! next volume in this
    	    buffer1);				! volume set.
    END;

!
! For this volume set, if the /LABEL flag was set, then we must also
! modify [0,0]VOLSET.SYS on the root volume.  Note that ODS1 volumes
! cannot be volume sets so will fail this test.
!
IF .max_rvn GTR 1
AND .flags[qual_label]
THEN modify_volset(.root_desc);

RETURN;
END;

ROUTINE process_one_volume (desc) : NOVALUE =
BEGIN

!++
!
! Find each volume in the volume set and call the routines which
! actually modify the data.
!
! Inputs:
!	desc - address of volume descriptor
!
! Outputs:
!	None.  The volumes and I/O database are modified.
!
!---

LOCAL
    status,
    vbn,				! Place to store vbn
    ucb,				! Place to store UCB address
    cluster;				! Cluster size of volume

IF NOT read_homeblock(cluster) 		! If can't read home block
THEN SIGNAL(set$_nohome)		! then tell the user
ELSE
    BEGIN
    status = 0;				! Show that no homeblocks modified yet
    INCR vbn FROM 2 TO .cluster*3 DO	! Go thru all homeblocks on the volume
	BEGIN
!
! Call the routine that reads, modifies, and writes the homeblock.  If 
! successful, set STATUS = 1
!
	IF set_home(.vbn, .desc) 
    	THEN status = 1;
	IF .ods1 
    	THEN EXITLOOP;			! Finished for ODS1
	END;
!
! If STATUS = 1, then at least some of the homeblocks were good and were 
! modified.
!
    IF .status THEN		
	BEGIN
	! So, go ahead and change the I/O database.
	!
        ucb = KERNEL_CALL (GET_CHANNELUCB, .channel);
        KERNEL_CALL(SET_UCBVCB, .ucb);

	IF .flags[qual_log]		! If /LOG, tell user
	THEN SIGNAL (set$_modified, 1, .desc);
	END;
    END;

RETURN;
END;

ROUTINE read_homeblock(cluster) =
!++
!
! This routine reads the first good home block of the volume.
! It uses $QIOW's because $READ finds the End-of-File block to be
! zero in ODS1 initialized disks and thus will not try to read the home block.
! In addition the cluster size and structure level are determined and stored.
!
! Outputs:
!	cluster - cluster size
!	ods1 - 0 => ODS2
!	       1 => ODS1
!
!--
BEGIN

LOCAL
    desc : $BBLOCK[dsc$c_s_bln],	! Descriptor for the FIB in $QIOW
    fib  : $BBLOCK[fib$c_extdata],	! File Information Block for $QIOW
    atr  : BLOCKVECTOR[2,8,BYTE],	! Attribute list for $QIOW
    stablk : $BBLOCK[32],		! Where statistics block is stored after $QIOW
    file_size : VECTOR[2,WORD],		! The file size from statistics block
    iosb : VECTOR[4,WORD],		! Status block for the $QIOW
    block,				! Temporary block count
    status;				! Status

! Before we can look at the homeblock we have to find how many blocks there 
! are (or the block number or the last block).  This is done by issuing a
! $QIOW to get the statistics block.

desc[dsc$w_length] = fib$c_extdata;	! Initialize descriptor pointing to
desc[dsc$a_pointer] = fib;		! to the file info block

CH$FILL(0, fib$c_extdata, fib);		! Zero the fib for new info

fib[fib$l_acctl] = fib$m_noread OR 	! Deny read and write access to others
		   fib$m_nowrite;
fib[fib$w_fid_num] = .nam[nam$w_fid_num];
fib[fib$w_fid_seq] = .nam[nam$w_fid_seq];  ! Specify file identification
fib[fib$w_fid_rvn] = .nam[nam$w_fid_rvn];

atr[0,atr$w_type] = atr$c_statblk;	! The attribute we want is the
atr[0,atr$w_size] = atr$s_statblk;	! statistics block
atr[0,atr$l_addr] = stablk;		! It goes into stablk
atr[1,0,0,32,0]   = 0;			! Indicate end of information

status = $QIOW (CHAN = .channel,	! Access the statistics block
		FUNC = IO$_ACCESS,
		IOSB = iosb,
		P1   = desc,
		P5   = atr);
IF  .status THEN status = .iosb[0];	! Check if everything Okay
IF NOT .status 
THEN SIGNAL(.status)			! If not, tell user, go to end
ELSE					! If okay
BEGIN
    file_size[1] = .stablk[sbk$w_filesizh];  ! The file size is stored
    file_size[0] = .stablk[sbk$w_filesizl];  ! backwards so invert

!
! It is possible the homeblock exists so . . .
! Keep reading until we get a block that reads without errors and meets the 
! criteria for a homeblock.
!
    INCR block FROM 2 TO 100 DO
        BEGIN
        IF .block LEQ .file_size 		! If we have not passed the end of file
	THEN
	BEGIN
	    status = $QIOW (CHAN = .channel,	   ! Read the virtual 'block'
			    FUNC = IO$_READVBLK,
			    IOSB = iosb,
			    P1   = buffer,	   ! Put it in 'buffer'
			    P2   = 512,		   ! Get a whole block
			    P3   = .block);
	    IF  .status THEN status = .iosb[0];
	    IF NOT .status
	    THEN 
	    BEGIN
		SIGNAL(.status);
		RETURN false;
	    END;
	    IF
      	        .buffer[hm2$b_struclev] EQL 2 AND
                .buffer[hm2$l_altidxlbn] NEQ 0 AND
     	        .buffer[hm2$w_cluster] NEQ 0 AND
	        .buffer[hm2$w_homevbn] NEQ 0 AND
	        .buffer[hm2$w_alhomevbn] NEQ 0 AND
	        .buffer[hm2$w_altidxvbn] NEQ 0 AND
	        .buffer[hm2$w_ibmapvbn] NEQ 0 AND
	        .buffer[hm2$l_ibmaplbn] NEQ 0 AND
	        .buffer[hm2$l_maxfiles] NEQ 0 AND
	        .buffer[hm2$w_ibmapsize] NEQ 0 AND
	        .buffer[hm2$w_resfiles] NEQ 0 AND
	        checksum2(buffer, $BYTEOFFSET(hm2$w_checksum1)) AND
	        checksum2(buffer, $BYTEOFFSET(hm2$w_checksum2))
	    THEN
	    BEGIN
	        ods1 = 0;				! This is an ODS2 volume
	        .cluster = .buffer[hm2$w_cluster];	! with this cluster size
	        IF .flags[qual_access]	! If /ACCESSED was specified,
	        THEN				! compute the value to add
		BEGIN				! to the LRU value in the VCB
	            acc_inc = 0;
		    IF .acc_value GTR .buffer[hm2$b_lru_lim]
		    THEN acc_inc = .acc_value - .buffer[hm2$b_lru_lim];
	        END;
		RETURN true;
	    END
		ELSE IF
		    .buffer[hm1$w_struclev] EQL hm1$c_level1 AND
		    .buffer[hm1$w_cluster] NEQ 0 AND
		    .buffer[hm1$l_ibmaplbn] NEQ 0 AND
		    .buffer[hm1$w_maxfiles] NEQ 0 AND
		    .buffer[hm1$w_ibmapsize] NEQ 0 AND
		    checksum2(buffer, $BYTEOFFSET(hm1$w_checksum1)) AND
		    checksum2(buffer, $BYTEOFFSET(hm1$w_checksum2))
		THEN
		    BEGIN
		    ods1 = 1;				! Volume is ODS1
		    .cluster = 1;			! Dummy in a cluster size of 1
		    IF .flags[qual_access]	! If /ACCESSED was specified,
		    THEN				! compute the value to add
			BEGIN				! to the LRU value in the VCB
			acc_inc = 0;
			IF .acc_value GTR .buffer[hm1$b_lru_lim]
			THEN acc_inc = .acc_value - .buffer[hm1$b_lru_lim];
			END;
		    RETURN true;
		    END;
		END;					! End of read success block
	    END;					! End of INC block
	END;						! End of file access block
!
! If here, then no good homeblock was found. Return a value of FALSE to
! show that.
!
RETURN false;
END;

ROUTINE parse_class (desc) =
BEGIN

!---
!
! This routine parses one class of user (e.g. SYSTEM, OWNER, GROUP, WORLD)
! to see what protection is allowed.  The value returned in the low 4 bits 
! is the protection code, with the bits set to reflect that access is 
! requested.  Note that this is exactly the opposite of what the system wants.
!
! Inputs:
!
!	DESC - a descriptor pointing to the ASCII representation of the
!	       protection desired
!
!---

MAP desc : REF $BBLOCK;

LOCAL
    result,
    string : REF VECTOR[,BYTE];		! String pointer

!
! Initially set the value to all zeros, no access
!
result = 0;

!
! Scan for the occurrence of each keyletter, and, if it is there, set the
! appropriate bit.
!
string = .desc[dsc$a_pointer];
INCR index FROM 0 to (.desc[dsc$w_length] -1) DO
    BEGIN
    IF .string[.index] EQL'R'
    THEN result = .result OR %X'1'
    ELSE IF .string[.index] EQL  'W'
    THEN result = .result OR %X'2'
    ELSE IF .string[.index] EQL 'E'
    	 OR .string[.index] EQL 'P'
    THEN result = .result OR %X'4'
    ELSE IF .string[.index] EQL 'D'
    	 OR .string[.index] EQL 'L'
    THEN result = .result OR %X'8'
    ELSE SIGNAL_STOP(cli$_ivprot);
    END;

RETURN .result;
END;

ROUTINE set_home (vbn, desc) =
!++
!
! This routine reads a homeblock, modifies it, and writes it back to the
! volume.
!
! Inputs:
!	vbn - current vbn to read 
!	ods1 - 0 => ODS2
!    	       1 => ODS1
!	desc - descriptor for the volume
!
!--
BEGIN


LOCAL
    iosb : VECTOR[4,WORD],	! I/O Status Block for $QIOW 
    status;			! General status return

!
! Read the homeblock.
!
status = $QIOW (CHAN = .channel,
		FUNC = IO$_READVBLK,	! Read virtual block
		IOSB = iosb,
		P1   = buffer,		! Place it in 'buffer'
		P2   = 512,		! Read 512 bytes
		P3   = .vbn);		! Starting at this virutal block
IF .status THEN status = .iosb[0];
IF NOT .status
THEN
    BEGIN
    SIGNAL(set$_hbread,		! Error reading homeblock
	   1,
	   .desc,		! for this volume
	   .status);		! for this reason
    RETURN false;
    END;

!
! Change the ACCESSED (LRU) value, if requested
!
IF .flags[qual_access]
THEN
    IF .ods1 THEN buffer[hm1$b_lru_lim] = .acc_value	! For ODS1
    ELSE buffer[hm2$b_lru_lim] = .acc_value;		! For ODS2

!
! If the DATA_CHECK qualifier is set, check to see if ODS1 or ODS2.  If ODS1, 
! tell the user that DATA_CHECK is illegal.  Otherwise, set the bits.
!
IF .flags[qual_data]
THEN IF .ods1					! If ODS1,
THEN SIGNAL(set$_notods2,			! tell user no
	    1,
	    $DESCRIPTOR('DATA_CHECK'))
ELSE
    BEGIN
    IF .dflags[data_read] THEN buffer[hm2$v_readcheck] = 1;
    IF .dflags[data_noread] THEN buffer[hm2$v_readcheck] = 0;
    IF .dflags[data_write] THEN buffer[hm2$v_writcheck] = 1;
    IF .dflags[data_nowrite] THEN buffer[hm2$v_writcheck] = 0;
    END;

!
! [NO]ERASE_ON_DELETE only works for ODS2.
!
IF .flags[qual_erase]
THEN IF .ods1
THEN SIGNAL(set$_notods2, 1, %ASCID 'ERASE_ON_DELETE')
ELSE buffer[hm2$v_erase] = .flags[qual_erase_val];

!
! For the EXTENSION qualifier, if ODS1, the field is only a byte long, so
! the greatest value is 255.  If the user specified a larger value, tell the
! user and return.  Otherwise, make the change.
!
IF .flags[qual_exte]
THEN IF .ods1
THEN
    BEGIN						! Start of ODS1
    IF .exte_value GTR 255
    THEN
	BEGIN
	SIGNAL(set$_valerr);
	RETURN false;
	END
    ELSE buffer[hm1$b_extend] = .exte_value;
    END							! End of ODS1
ELSE buffer[hm2$w_extend] = .exte_value;		! Change ODS2 extend

!
! For FILE_PROTECTION, the location is different, depending on which type of 
! disk we have.
!
! Also, a word about the value in FPROT_VALUE.  The high word, 
! FPROT_VALUE<16,16>, contains a mask indicating which groups are to
! be changed (SYSTEM,OWNER,GROUP,WORLD), while the low word, 
! FPROT_VALUE<0,16>, contains the complement of the new protection for each group.
! Thus, if FPROT_VALUE<16,16> is zero, then nothing is to be changed and 
! there's no need to go thru the Boolean algebra.
!
IF .flags[qual_fprot] AND (.fprot_value<16,16> NEQ 0)
THEN
    IF .ods1
    THEN			! For ODS1
    buffer[hm1$w_fileprot] = (.buffer[hm1$w_fileprot] AND NOT.fprot_value<16,16>)
    			    OR (NOT.fprot_value<0,16> AND .fprot_value<16,16>)
    ELSE			! For ODS2
    buffer[hm2$w_fileprot] = (.buffer[hm2$w_fileprot] AND NOT.fprot_value<16,16>)
    			    OR (NOT.fprot_value<0,16> AND .fprot_value<16,16>);

!
! [NO]HIGHWATER only works for ODS2.
!
IF .flags[qual_fhw]
THEN IF .ods1
THEN SIGNAL(set$_notods2, 1, %ASCID 'HIGHWATER_MARKING')
ELSE buffer[hm2$v_nohighwater] = .flags[qual_fhw_val];

!
! In the case of LABEL, the label is stored in the same place on both ODS1 and 
! ODS2 disks.  However, there is an additional field in ODS1 homeblocks, which 
! contain the volume label, padded with zeroes instead of blanks.
!
If .flags[qual_label]
THEN
    BEGIN
    IF NOT .flags[qual_lbl_cpy]		! If old label not copied
    THEN 
	BEGIN				! then do so now.
	CH$MOVE(vcb$s_volname,
    		 buffer[hm1$t_volname2],
    		 label_buff);
	flags[qual_lbl_cpy] = 1;
	END;
    CH$COPY(.label_value[0],		! Copy label into VOLNAME2,
	    .label_value[1],
	    ' ',			! padding with spaces.
	    vcb$s_volname,
	    buffer[hm1$t_volname2]);
    IF .ods1
    THEN CH$COPY(.label_value[0],	! For ODS1, also copy to VOLNAME,
		 .label_value[1],
		 0,			! padding with zeroes
		 vcb$s_volname,
		 buffer[hm1$t_volname]);
    END;

!
! For OWNER_UIC, the ODS2 homeblock allows a full 16 bits for group, and 
! another 16 bits for member.  In the case of ODS1 disks, each of these fields 
! is only 8 bits long.  Also, if fold long UIC's into <377,377> for ODS1 disks.

IF .flags[qual_owner]
THEN
    BEGIN
    IF .ods1
    THEN
	BEGIN
	IF .uic_value<8,8> NEQ 0
	OR .uic_value<24,8> NEQ 0
	THEN
	    BEGIN
	    uic_value<0,8> = -1;
	    uic_value<8,8> = 0;
	    uic_value<16,8> = -1;
	    uic_value<24,8> = 0;
	    END;
	buffer[hm1$w_volowner] = (.uic_value<16,8> ^8) + .uic_value<0,8>;
	END
    ELSE buffer[hm2$l_volowner] = .uic_value;
    END;

!
! The retention period is something that only exists for ODS2 volumes.  If
! this volume is not an ODS2 disk, then signal an error.  Otherwise, set the
! default retention periods.
!

IF .flags[qual_retent]
THEN
    BEGIN
    IF .ods1				! IF ODS1 disk
    THEN SIGNAL(set$_notods2,		! Signal an error
    		1,
    		$DESCRIPTOR('/RETENTION'))	! Saying it can't be done
    ELSE
    	BEGIN
	CH$MOVE(8, retmin_value, buffer[hm2$q_retainmin]);
	CH$MOVE(8, retmax_value, buffer[hm2$q_retainmax]);
	END;
    END;
    	
!
! PROTECTION, the volume protection, is also stored in two different places in 
! the home blocks.  See the discussion of the protection value for 
! FILE_PROTECTION, above.
!
IF .flags[qual_vprot] AND (.vprot_value<16,16> NEQ 0)
THEN
    IF .ods1
    THEN			! For ODS1
    buffer[hm1$w_protect] = (.buffer[hm1$w_protect] AND NOT.vprot_value<16,16>)
    			    OR (NOT.vprot_value<0,16> AND .vprot_value<16,16>)
    ELSE			! For ODS2
    buffer[hm2$w_protect] = (.buffer[hm2$w_protect] AND NOT.vprot_value<16,16>)
    			    OR (NOT.vprot_value<0,16> AND .vprot_value<16,16>);


!
! WINDOWS is also in two different places.
!
IF .flags[qual_windows]
THEN
    BEGIN
    IF .ods1 THEN buffer[hm1$b_window] = .window_value	! For ODS1
    ELSE buffer[hm2$b_window] = .window_value;		! For ODS2
    END;

!
! The USER_NAME is in the same place for both types of home blocks.
!
IF .flags[qual_username]
THEN CH$COPY(.user_value[0],		! Copy the username to the homeblock
	     .user_value[1],
	     ' ',			! padded with spaces
	     hm2$s_ownername,
	     buffer[hm2$t_ownername]);

!
! Recompute the checksums
!

checksum2(buffer, $BYTEOFFSET(hm2$w_checksum1));
checksum2(buffer, $BYTEOFFSET(hm2$w_checksum2));

!
! Write the modified homeblock back to the disk
!
status = $QIOW (CHAN = .channel,
		FUNC = IO$_WRITEVBLK,	! Read Virtual Block
		IOSB = iosb,		
		P1   = buffer,		! From 'buffer'
		P2   = 512,		! Write 512 bytes
		P3   = .vbn);		! To this virtual block
IF .status THEN status = .iosb[0];
IF NOT .status 				! If not able to read
THEN
    BEGIN
    SIGNAL(set$_hbwrite,		! Error writing a homeblock
	   1,
	   .desc,			! to this disk
	   .status);			! for this reason
    RETURN false;			! don't mod database
    END
ELSE RETURN true;
END;

ROUTINE set_ucbvcb (ucb) : NOVALUE =
!++
!
! This routine is called in kernel mode, to modify the fields in the UCB and 
! VCB which correspond to changes made in the homeblock.  The address of the 
! UCB is passed as the input argument.
!
!--
BEGIN

MAP ucb : REF $BBLOCK;				! Define the UCB

BIND
    orb = .ucb[ucb$l_orb] : $BBLOCK,		! Define the ORB
    vcb = .ucb[ucb$l_vcb] : $BBLOCK,		! Define the VCB
    devchar = ucb[ucb$l_devchar] : $BBLOCK;	! and devchar longword

!
! Go thru the UCB and VCB, making the same changes to it that were made
! to the homeblock.  Note that, if the LABEL qualifier is set, the volume 
! label is changed in the homeblock and in the VCB, but the logical name
! (DISK$label) is NOT CHANGED.
!

IF .flags[qual_access] AND (.acc_inc NEQ 0)
THEN vcb[vcb$b_lru_lim] = .vcb[vcb$b_lru_lim] + .acc_inc;

IF (.flags[qual_data] AND (.buffer[hm2$b_struclev] NEQ 1))
THEN
    BEGIN
    IF .dflags[data_read] THEN devchar[dev$v_rck] = 1;
    IF .dflags[data_noread] THEN devchar[dev$v_rck] = 0;
    IF .dflags[data_write] THEN devchar[dev$v_wck] = 1;
    IF .dflags[data_nowrite] THEN devchar[dev$v_wck] = 0;
    END;

IF .flags[qual_erase]
AND NOT .ods1
THEN vcb[vcb$v_erase] = .flags[qual_erase_val];

IF .flags[qual_exte]
THEN vcb[vcb$w_extend] = .exte_value;

IF .flags[qual_fprot] AND (.fprot_value<16,16> NEQ 0)
THEN vcb[vcb$w_fileprot] = (.vcb[vcb$w_fileprot] AND NOT .fprot_value<16,16>)
    			  OR (NOT.fprot_value<0,16> AND .fprot_value<16,16>);

IF .flags[qual_fhw]
AND NOT .ods1
THEN vcb[vcb$v_nohighwater] = .flags[qual_fhw_val];

IF .flags[qual_label]
THEN CH$COPY(.label_value[0],
	     .label_value[1],
	     ' ',
	     vcb$s_volname,
	     vcb[vcb$t_volname]);

IF .flags[qual_mntver]
THEN vcb[vcb$v_mountver] = .flags[qual_mntver_val];

IF .flags[qual_owner]
THEN orb[orb$l_owner] = .uic_value;

IF .flags[qual_retent] AND (NOT .ods1)
THEN
    BEGIN
    CH$MOVE(8, retmin_value, vcb[vcb$q_retainmin]);
    CH$MOVE(8, retmax_value, vcb[vcb$q_retainmax]);
    END;

IF .flags[qual_unl]
THEN ucb[ucb$v_unload] = .flags[qual_unl_val];

IF .flags[qual_vprot] AND (.vprot_value<16,16> NEQ 0)
THEN orb[orb$w_prot] = (.orb[orb$w_prot] AND NOT .vprot_value<16,16>)
    			OR (NOT.vprot_value<0,16> AND .vprot_value<16,16>);
orb[orb$v_prot_16] = 1;				! SOGW protection word

IF .flags[qual_windows]
THEN vcb[vcb$b_window] = .window_value;

RETURN;
END;

ROUTINE modify_volset (desc) : NOVALUE =
BEGIN

!++
!
! Modify [0,0]VOLSET.SYS on the root volume of the volume set.
! Only ODS2 initialized volumes can be volume sets so we don't 
! have to worry about the $READ finding the End-of-File value
! as zero in this case
!
! Inputs:
!	desc - address of root volume device descriptor
!
! Outputs:
!	None.
!
!--

MAP
    desc : REF VECTOR;

LOCAL
    status,
    buffer : VECTOR[vsl$c_length,BYTE],
    fab : $FAB(DNM = '[0,0]VOLSET.SYS',
    	       FAC = <get,put,upd>),
    rab : $RAB(FAB = fab,
	       UBF = buffer,
	       USZ = 100);

!
! Put the root device name in place
!
fab[fab$l_fna] = .desc[1];
fab[fab$b_fns] = .desc[0];

!
! Open and connect to [0,0]VOLSET.SYS
!
IF (status = $OPEN(FAB = fab))
THEN status = $CONNECT(RAB = rab);
IF NOT .status
THEN
    BEGIN
    LOCAL
    	ptr,
	d : VECTOR[2],
	b : VECTOR[30];
    ptr = CH$MOVE(.fab[fab$b_fns],
    		  .fab[fab$l_fna],
    		  b);
    ptr = CH$MOVE(.fab[fab$b_dns],
    		  .fab[fab$l_dna],
    		  .ptr);
    SIGNAL(set$_writeerr,
	   1,
	   d,
	   .status);
    END

ELSE
    BEGIN

!
! The first record contains the volume set name.  Skip it.
!
    $GET(RAB = rab);

!
! Search thru the records until the one matching the saved old label
! is found.  When found, replace the old label with the new one, and
! update the record.
!
    WHILE $GET(RAB = rab) DO
	BEGIN
	IF CH$EQL(vcb$s_volname,
	    	  label_buff,
    		  vsl$s_name,
    		  buffer,
    		  ' ')
	THEN
	    BEGIN
	    CH$COPY(.label_value[0],
		    .label_value[1],
	            ' ',
	            vsl$s_name,
	     	    buffer);
	    rab[rab$l_rbf] = buffer;
	    rab[rab$w_rsz] = vsl$c_length;
	    $UPDATE(RAB = rab);
	    EXITLOOP
	    END;
	END;
    END;

$CLOSE(FAB = fab);

RETURN;
END;

GLOBAL ROUTINE COMMON_IO (EFN,CHAN,FUNC,IOSTS,ASTADR,ASTPRM,P1,P2,P3,P4,P5,P6)=

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine simply executes a $QIOW call with the parameters
!	supplied. It is called by the MOUNT code that SET links with.
!
! CALLING SEQUENCE:
!	COMMON_IO (EFN,CHAN,FUNC,IOSTS,ASTADR,ASTPRM,P1,P2,P3,P4,P5,P6)
!
! INPUT PARAMETERS:
!	As to $QIOW
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	As to $QIOW
!
! SIDE EFFECTS:
!	As to $QIOW
!
!--

BEGIN

BUILTIN
	AP,
	CALLG;

EXTERNAL ROUTINE
	SYS$QIOW	: ADDRESSING_MODE (GENERAL);


! We simply pass the call and its parameters along to $QIOW.
!

CALLG (.AP, SYS$QIOW)

END;					! End of routine COMMON_IO

END
ELUDOM
