	.TITLE	PAINIT
	.IDENT	'V04-001'

;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
;++
;
; FACILITY:
;
;	VAX/VMS EXECUTIVE, I/O DRIVERS
;
; ABSTRACT: CI PORT INITIALIZATION
;
; AUTHOR:  N. KRONENBERG,  MAY 1981
;
; MODIFIED BY:
;
;	V04-001	NPK3066		N. Kronenberg		 9-Sep-1984
;		Add flags INI$CPU/PORT_REV.  Flags = 1/0 if ucode is
;		okay/insufficient.  Used to trigger UCODEREV bugcheck
;		rather than usual CIPORT bugcheck if bugcheck is needed.
;		Set INI$CPU_REV to okay just before CPU rev check; clear
;		if check fails prior to calling CLEANUP_PDT.
;		Set INI$PORT_REV when port is successfully init'ed assuming
;		its ucode is okay.  Clear in PACONFIG when we have
;		checked port ucode rev and determined it is bad.
;
;	V03-034	NPK3064		N. Kronenberg		21-Aug-1984
;		On cpu powerfail recovery (when port may still be
;		alive if it was an unswitched power failure), min
;		the port before dropping ipl to reinit.
;
;	V03-033	NPK3062		N. Kronenberg		10-Aug-1984
;		Fix yet another bug in leaving port offline, but
;		continuing to run the system.
;
;	V03-032	NPK3061		N. Kronenberg		 9-Aug-1984
;		Fix CLUB check in CLEANUP_PDT.
;
;	V03-031	NPK3060		N. Kronenberg		 1-Aug-1984
;		Init local port status to have loop back datagrams
;		enabled.
;
;	V03-030	NPK3059		N. Kronenberg		25-Jul-1984
;		Fix problems with deallocating PDT before deciding
;		to call BUGCHECK with a nonex PDT address.
;
;	V03-029	NPK3057		N. Kronenberg		23-Jul-1984
;		Eliminate override of max port reinit retry count
;		if system disk or clustering requires CI.
;		Now port unconditionally shutdown if retry count
;		exhausted.  Difference is that now, if clustering
;		or if system disk available via the failing port, 
;		system bugchecks unless there is another SCS speaking
;		port left.
;		Move the above check for system bugcheck to CLEANUP_PDT--
;		previously the analogous check was in TEST_SHUTDOWN
;		which was called only on each reinit.
;
;	V03-028	NPK3055		N. Kronenberg		14-Jul-1984
;		Add init of PDT$W_STDGUSED/DYN in INI$PORT.
;		Put 11/750 SID in R1 instead of R0 and pass to new
;		error logging routine, ELOG$CPU_REV.  
;		Leave port offline if 11/750 ucode not up to at least
;		97 (base 10.)
;		Make CLEANUP_PDT do maint init on port just in case.
;
;	v03-027	NPK3054		N. Kronenberg		24-Jun-1984
;		Log error if CPU is 11/750 and rev level is insufficient
;		to support ci port.  Ucode rev must be 97 (base 10)
;		or greater.
;
;	V03-026	NPK3048		N. Kronenberg		 5-Apr-1984
;		In TEST_SHUTDOWN, override retry max of 10 if this
;		system is part a cluster.  I.e., never leave the
; 		port offline, because it may prevent the cluster from
;		running and will certainly prevent this system from
;		doing anything useful.
;
;	V03-024	NPK3047		N. Kronenberg		15-Mar-1984
;		For VAX 8600, set system hardware type appropriately.
;		When building a PDT, add it to the list of SCS speaking
;		PDT's.  When removing a PDT, remove it from the list.
;		Init new PDT vector, PDT$L_STOP_VCS.
;		Near the end of port initialization call CNF$CALC_POLLSW
;		to compute the estimated time to do a full sweep of the
;		configuration poller.
;
;	V03-023	TMK0004		Todd M. Katz		07-Mar-1984
;		It is no longer necessary to broadcast messages to _OPA0 when 
;		it is discovered, during controller initialization, that 
;		SCSSYSTEMID has not been initialized to a non-zero value and
;		that the port is going to be left offline. This is because the 
;		error logging of this error condition has been modified to 
;		notice that the existance of this error should also be broadcast
;		to _OPA0, and does so.
;
;		I have modified the routine TEST_SHUTDOWN so that the port
;		re-initialization message that is broadcast to _OPA0 includes
;		the number of retries left.
;
;	V03-022	TMK0003		Todd M. Katz		21-Feb-1984
;		Change unit and port initialization so that they proceed at fork
;		IPL instead of at IPL$_POWER. This requires these changes:
;
;		1. Add a new routine INI$FORK. This routine is assumed to be
;		   called at elevated IPL with a routine address in R3 which is
;		   to be jumped to at fork IPL. INI$FORK will extract the fork
;		   block from the appropriate fork queue in an atomic fashion,
;		   if it has to, and create a fork process before returning
;		   to its caller. When the fork process resumes, it does so 
;		   within INI$FORK, which proceeds to jump to the routine
;		   address passed to it as input. Throughout this procedure
;		   proper use is made of the fork block interlock bit.
;		   
;		2. If the unit initialization routine has been called and the
;		   port has not yet been initialized then all miscellaneous
;		   errors within the configuration register are cleared, device
;		   interrupts are disabled by placing the port in the 
;		   un-initialized state, and the routine INI$FORK is called
;		   so that the remained of the unit initialization maybe done
;		   at fork IPL.
;
;		3. Because port initialization proceeds at fork IPL there is
;		   no longer any need to fork in order to print out messages
;		   to OPA0. 
;
;		4. Because port initialization proceeds at fork IPL, 
;		   EXE$ALONONPAGED maybe called to allocate whatever non-paged 
;		   pool needs to be allocated. This means that the routine
;		   HIPL_ALLPOOL (INI$HIPLALC) maybe deleted, and that the funny
;		   games that were being played with the IPL value in the pool
;		   header area, so that the allocation of free datagrams and 
;		   sequence messages could proceed at IPL$_POWER, can be 
;		   stopped.
;
;		5. Because port initialization used to proceed at IPL$_POWER, it
;		   never mattered when device interrupts were being enabled. 
;		   However, port initialization is now being done at fork IPL
;		   so it has become important not to enable device interrupts
;		   until after everything else has been done and just before 
;		   port initialization terminates.
;
;		6. It becomes an implicit assumption, that INI$PORT is only
;		   called at fork IPL with device interrupts disabled, and with
;		   no outstanding interrupts.
;
;	V03-021	TMK0002		Todd M. Katz		17-Feb-1984
;		Change the text of the message that is printed out on the
;		operator's console when it is discovered that SCSSYSTEMID
;		is unitialized, and has a value of 0.
;
;	V03-020	NPK3044		N. Kronenberg		 6-Feb-1984
;		Replace queuing of 3 gratituous datagrams to the port
;		free queue (to fill the cache) with queuing of an
;		additional SCS$GW_PAPPDDG datagrams.  The additional
;		datagrams are intended to handle error log datagrams
;		not associated with any particular connection.
;
;	V03-019	TMK0001		Todd M. Katz		27-Jan-1984
;		Before allocating the PDT, check for a SCSSYSTEMID of 0.
;		If such a SCSSYSTEMID is found, log the error condition,
;		notify the operator's console via an appropriate set of
;		messages, and keep the port off-line.
;
;	V03-018	NPK3039		N. Kronenberg		11-Jan-1984
;		Remove return of top unused portion of pool before PDT
;		back to pool.  No return can be done if PDT allocated
;		from LRP, so never return.
;
;	V03-017	NPK3037		N. Kronenberg		11-Nov-1983
;		Comment inputs to INI$PORT.
;		Add check to INI$PORT that command queues and response
;		queue are empty prior to starting port.  If queues
;		aren't empty, attempt recovery by setting them empty.
;
;	V03-016	NPK3035		N. Kronenberg		21-Oct-1983
;		Fix calculation of global page table length.
;
;	V03-015	TCM0002		Trudy C. Matthews	19-Aug-1983
;		Add SUPERSTAR-specific path to CPU-dependent code that sets
;		CPU type and port device type.
;
;	V03-014	NPK3029		N. Kronenberg		14-Jul-1983
;		Numerous enhancements for V4.0.
;		Add fork process call, SENDRGDG, to SCS offset table.
;		Set max block xfer byte count in PDT.
;		Allow sanity timer to be enabled.
;		Add routine TEST_SHUTDOWN to check if port can be
;		reinitialized or must be left offline and to print
;		operator warning if appropriate.
;		Add init of fork ipl for msg fork block in ucb.
;		Add $PAUCBDEF and $DDBDEF.
;
;	V03-013 NPK3024		N. Kronenberg		18-May-1983
;		Add comments explaining variable network header.
;
;	V03-012	KTA3046		Kerbey T. Altmann	03-Apr-1983
;		Redo for SCS/PPD split.
;
;	V03-011	TCM0001		Trudy C. Matthews	29-Feb-1983
;		Added an 11/790-specific path to CPUDISP macro which sets
;		CPU type and port device type.
;
;	V03-010	NPK3021		N. Kronenberg		28-Feb-1983
;		Fix setting of 'V750' cpu type.
;
;	V03-009	NPK3010		N. Kronenberg		 9-Nov-1982
;		Modify BUILD_PDT to set CI PDT type;  modify INI$PORT
;		to set local port number in PDT rather than maximum
;		port number on this CI.
;
;	V03-008	NPK3009		N. Kronenberg		 2-Nov-1982
;		Always fill in BDT info in newly created PDT in case
;		multiple ports per system.
;
;	V03-007	NPK3004		N. Kronenberg		30-Jul-1982
;		Add setting of CI750 device type in UCB.  Add ASCII
;		CPU type for start handshake.  Add check for 11/750 
;		status, NOCI, before initializing port.
;
;	V03-006	NPK3001		N. Kronenberg		25-Jun-1982
;		Fix to allow loading of ucode into rom/ram ports.
;		Enable read back of loaded ucode to check it.
;
;	V03-005	ROW0101		Ralph O. Weber		10-JUN-1982
;		Change ordering of port initialization operations to that 
;		proposed by Barry Odonoghue in his 9 June mail to Nancy.
;		The proposed order is as follows (the parenthetical letters 
;		indicate the order previously employed by this driver):
;		  1(a)	Set PIC
;		  2(b)	Wait for MIF
;		  3(c)	Check that only PIC is set in PSR
;		  4(g)	Release PSR to port (this should clear MIF)
;		  5(e)	Enable interrupts
;		  6(f)	Write PECR
;		The intent of the new ordering is to prevent unexpected 
;		interrupts which can occur if interrupts are enabled while MIF 
;		is set as the result of PIC (Port Initialization Complete).
;		This change will be in a new driver image shipped in V3.1.
;
;	V03-004	ROW0100		Ralph O. Weber		 9-JUN-1982
;		Add a high-IPL allocation jacket around the code which 
;		allocates and queues extra datagrams for start handshakes 
;		and extra message buffers to fill the port cache.  This jacket 
;		will allow the calls to EXE$ALONONPAGED, called within the 
;		SCS$ routines, to be made from IPL$_POWER in the same way that 
;		a similar call is made within HIPL_ALLPOOL.
;		This change will be in a new driver image shipped in V3.1.
;
;	V03-003	ROW0094		Ralph O. Weber		 7-JUN-1982
;		Add calls to error logging routines in BUILD_PDT, BUILD_TLB, 
;		BUILD_BDT, and INI$PORT.  Add necessary reference to $PAERDEF 
;		macro.  Correct branch destination out of range, caused by new 
;		code, in BUILD_BDT at BNEQ INIT_CRB.
;		This change will be in a new driver image shipped in V3.1.
;
;	V03-002	NPK2019		N. Kronenberg		6-Apr-1982
;		Fixed bug in setting of device type in UCB.
;		Remove unit init JSB to INI$BRK.
;
;	V03-001	NPK2016		N. Kronenberg		18-Mar-1982
;		Fixed .TITLE
;
;--

	.SBTTL	DEFINITIONS

;
; Set PSECT to driver code:
;

	.PSECT	$$$115_DRIVER,LONG

;
; System definitions (LIB.MLB):
;

	.nocross
	$CRBDEF				; Channel Request Block format
	$CXBDEF				; Complex Buffer format
	$DCDEF				; Device type codes
	$DDBDEF				; Device Data Block format
	$DYNDEF				; Structure type codes
	$IPLDEF				; Define interrupt priorities
	$MCHKDEF			; Protect from machine check definitions
	$PDTDEF				; Port Descriptor Table format
	$PRDEF				; Internal processor register definitions
	$SSDEF				; System service success codes
	$UCBDEF				; Unit Control Block definitions
	$VECDEF				; CRB vector dispatch block offsets

;
; PADRIVER definitions (PALIB.MLB):
;

	$PAERDEF			; Port driver error code values
	$PAPDTDEF			; Port -specific PDT extension
	$PAREGDEF			; CI port register definitions
	$PAUCBDEF			; PA specific extension to UCB
	$PPDDEF				; PPD message layer


	.SBTTL	TABLES OF INITIALIZATION DATA

;+
; The following table gives word offsets for fork process SCS calls.
; Offsets are relative to the address of the controller initialization
; routine, PA$CTLINIT.
;-

;
; Macro to generate the table and ASSUME statements about PDT format:
;

	.MACRO	SCS_OFFSET_TAB	ENTRY_LIST

	 $$$ENTRYNUM=0				; No entries in table yet
	 .IRP	ENTRY ENTRY_LIST		; For each entry in the list...
	 .WORD	<FPC$'ENTRY'-PA$CTLINIT>	;  insert offset from ctl init,
	 .IF	NE $$$ENTRYNUM			;  and for entries after the 1st
	 ASSUME	$$$PREV+4 EQ PDT$L_'ENTRY'	;  specify assumed PDT adjacency
	 .ENDC					;
	 $$$PREV=PDT$L_'ENTRY'			; Set previous entry as this entry
	 $$$ENTRYNUM=$$$ENTRYNUM+1		; Step entry count
	 .ENDR					;

	 ASSUME	$$$PREV+4 EQ PDT$C_SCSEND	; Final PDT assumption
	 .WORD	0				; Offset table terminator
	
	.ENDM	SCS_OFFSET_TAB			;

;
; Table itself:
;

PA$SCSOFFSET::

	SCS_OFFSET_TAB	<-			; Invoke macro to define offsets
		ACCEPT,-		
		ALLOCDG,-
		ALLOCMSG,-
		CONNECT,-
		DEALLOCDG,-
		DEALLOMSG,-
		DEALRGMSG,-
		DCONNECT,-
		MAP,-
		MAPBYPASS,-
		MAPIRP,-
		MAPIRPBYP,-
		QUEUEDG,-
		QUEUEMDGS,-
		RCHMSGBUF,-
		RCLMSGBUF,-
		REJECT,-
		REQDATA,-
		SENDDATA,-
		SENDDG,-
		SENDMSG,-
		SNDCNTMSG,-
		UNMAP,-
		READCOUNT,-
		RLSCOUNT,-
		MRESET,-
		MSTART,-
		MAINTFCN,-
		SENDRGDG,-
		STOP_VCS,-
		>

;+
; The following table is a list of word offsets from the CI configuration
; register of CI register addresses to be kept in the PDT for quick access.
;-

;
; Macro to generate table:
;

	.MACRO	REG_OFFSET_TAB	REG_LIST

	 $$$REGNUM=0				; # table entries =0
	 .IRP	REG REG_LIST			; For each register in list,
	 .WORD	<PA_'REG'-PA_CNF>		;  enter offset from config reg
	 .IF	NE $$$REGNUM			;  and for entries after first,
	 ASSUME	$$$PREV+4 EQ PDT$L_'REG'	;  verify PDT adjacency
	 .ENDC					;
	 
	 $$$PREV =PDT$L_'REG'			; Set this PDT entry to previous
	 $$$REGNUM=$$$REGNUM+1			; Step entry counter
	 .ENDR					;

	 ASSUME	$$$PREV+4 EQ PDT$C_PAREGEND	; Verify final PDT offset

	 .WORD	-1				; Table terminator
	
	.ENDM	REG_OFFSET_TAB

;
; Table itself:
;

PA$REGOFFSET::

	REG_OFFSET_TAB	<-			; Invoke macro to define offsets
		CNF,-				;  Configuration register
		PMC,-				;  Port maint control reg
		PS,-				;  Port status register  
		CQ0,-				;  Command queue 0 control
		CQ1,-				;  Command queue 1 control
		PSR,-				;  Port status release register
		DFQ,-				;  Datagram free queue control
		MFQ,-				;  Message free queue control
		MTC,-				;  Maint timer control
		PFAR,-				;  Fail address register
		PPR,-				;  Port parameter register
		>
	.cross
;
; Processor type in ASCII for start handshakes:
;

INI$T_HWTYPE::

	.ASCII	'V780'				; Assume 'V780' to start with

MIN_750_REV = 97				; Minimum 11/750 CPU ucode 
						;  rev level to support ci750

;
; Messages to send to _OPA0 on serious port errors:
;

CR	= 13					; ASCII for carriage return,
LF	= 10					;  linefeed,
BELL	= 7					;  and bell

INI$MSG_INIT::

	.ASCIC	<CR><LF><BELL>'%PAx0, CI Port is Reinitializing ( xxx Retries Left).  Check the Error Log.'<CR><LF>

INI$MSG_OFFL::

	.ASCIC	<CR><LF><BELL>'%PAx0, CI Port is going Offline.'<CR><LF>

RETRY_OFFSET	= 39				; Byte offset to retry count 
						; numerical field in port 
						; re-initialization message

CTRLR_NAME = 6					; Byte offset to device
						;  controller letter (x)
						;  in above msgs


;
; Polynomial table used to calculate CRC for loopback datagram:
;

CRC_TABLE:

	.LONG	0
	.LONG	^X1DB71064
	.LONG 	^X3B6E20C8
	.LONG	^X26D930AC
	.LONG	^X76DC4190
	.LONG	^X6B6B51F4
	.LONG	^X4DB26158
	.LONG	^X5005713C
	.LONG	^XEDB88320
	.LONG	^XF00F9344
	.LONG	^XD6D6A3E8
	.LONG	^XCB61B38C
	.LONG	^X9B64C2B0
	.LONG	^X86D3D2D4
	.LONG	^XA00AE278
	.LONG	^XBDBDF21C


	.SBTTL	UNIT_INIT

;+
; The device type is set in the UCB depending on what CPU we are running
; on.  If this is an 11/780, then the device type is CI780; if 11/750,
; then the device type is CI750.  If the CPU is other than an 11/780,
; alter the ASCII CPU type accordingly.  If this is some other CPU, we really
; shouldn't ever get here, so we just exit leaving the unit offline so
; it can't be used.
;
; Then the device is initialized by calling subroutine INIT_CTLR.
;
; Inputs:
;	
;	R3			-Address of PA configuration reg
;	R4			-Same as R3
;	R5			-Addr of UCB
;
; Outputs:
;
;	R0-R3			-Destroyed
;	Other registers		-Preserved
;
;	INI$T_HWTYPE		-Set to proper CPU type in ASCII
;-

ASSUME	DT$_CI750  EQ  DT$_CI780+1

	.ENABL	LSB

PA$UNITINIT::

	MOVB	#DT$_CI780,UCB$B_DEVTYPE(R5)  ; Set the device type to CI780

	CPUDISP	<<780,CI_780>, -	; * Dispatch on CPU type *
		 <750,CI_750>, -
		 <730,OTHER_CPU>, -
		 <790,CI_790>, -
		 <785,CI_785>>

CI_750:

	INCB	UCB$B_DEVTYPE(R5)	; Step device type to 750
	MOVB	#^A/5/,INI$T_HWTYPE+2	; Change CPU type to 'V750'
	BRB	CI_780			; Join common code

CI_785:

	MOVB	#^A/5/,INI$T_HWTYPE+3	; Change CPU type to 'V785'
	BRB	CI_780

CI_790:

	MOVL	#^A/8600/,INI$T_HWTYPE	; Change CPU type to '8600'
					; Device type = CI780

CI_780:					; * End of CPU dependent code *
	
	MOVB	#IPL$_SCS,-		; Set ipl for fork block to
		<UCB$L_MSGFKBLK+UCB$B_FIPL>(R5)
					;  start up msg to opa0
	TSTW	UCB$W_UNIT(R5)		; Is this unit 0?
	BNEQ	10$			; Branch if not
	BSBB	INIT_CTLR		; Else init controller too

OTHER_CPU:

10$:	RSB				; Done with unit init


	.DSABL	LSB

	.SBTTL	CONTROLLER INIT

;+
; The controller initialization entry as seen by the system, PA$CTLINIT,
; is a noop since initialization can't begin without the unit 0 UCB.
; Actual controller init is called from unit 0 unit initialization with
; the same inputs as unit init.
;
; Inputs:
;
;	R3			-Addr of PA configuration register
;	R4			-Same as R3
;	R5			-Addr of UCB for unit 0
;
; Outputs:
;
;	All registers	 	-Preserved
;-

PA$CTLINIT::				; Controller init called by system

	RSB				; Return

;
; Controller initialization called from unit 0 init.
;

	.ENABL	LSB
INIT_CTLR::
	TSTL	UCB$L_PDT(R5)		; Built structures yet?
	BEQL	BUILD_STRUCT		; Branch if not
	BICW	#UCB$M_ONLINE,-		; Set unit offline to show
		UCB$W_STS(R5)		;  port init being done
	MOVL	UCB$L_PDT(R5),R4	; Get PDT addr
	$PRTCTINI -			; Protect from non-ex port
		B^1$,#MCHK$M_NEXM	;
	MOVL	#PA_PMC_M_MIN,-		;  and maint init port
		@PDT$L_PMC(R4)		;
	$PRTCTEND 1$			; End of mcheck protection
	BLBC	R0,5$			; If mcheck, dont mark port
					;  powered up
	BISW	#PDT$M_PUP,-		; Set power up on this
		PDT$W_LPORT_STS(R4)	;  port 

5$:	BBSS	#PDT$V_PWF_CLNUP,-	; Branch if SYSAP notification
		PDT$W_LPORT_STS(R4),10$	;  underway; else set pwf recov
					;  in progress,
	MOVZWL	#SS$_POWERFAIL,R1	;  set aux status to give SYSAP's,
	BSBW	ERR$PWF_RECOV		;  call recovery startup

10$:	RSB				; Return

BUILD_STRUCT:				; Complete unit init at fork IPL
	MOVL	PA_CNF(R4),PA_CNF(R4)	; Clear all miscellaneous errors
	MOVL	#PA_PMC_M_MIN,PA_PMC(R4); Place port in un-initialized state
	MOVAB	CHECK_SYSTEMID,R3	; Address of where to resume at fork IPL
	BRW	INI$FORK		; Fork...

	.DSABL	LSB


;
; The SYSGEN parameter SCSSYSTEMID must be sent to a non-zero value. If it
; has not been so initialized, log this error condition and do not allow the 
; port to come on-line.
;

	.ENABL	LSB
CHECK_SYSTEMID:
	TSTL	G^SCS$GB_SYSTEMID	; Has SCSSYSTEMID been initialized?
	BNEQ	BUILD_PDT		; Branch if it has
	TSTW	G^SCS$GB_SYSTEMID+4	; Are we sure its been initialized?
	BNEQ	BUILD_PDT		; Branch if it has

	MOVZBL	#PAER$K_ES_SCSID,R0	; Log that SCSSYSTEMID is 0
	BRW	ELOG$INIT_SWERR
	.DSABL	LSB

	.SBTTL	BUILD PDT

;
; PDT adjacency assumptions:
;

ASSUME	PDT$L_FLINK	EQ 0
ASSUME	PDT$B_PDT_TYPE	EQ 7
ASSUME	PDT$W_SIZE	EQ 8
ASSUME 	PDT$W_SIZE+2	EQ PDT$B_TYPE
ASSUME	PDT$B_TYPE+1	EQ PDT$B_SUBTYP
ASSUME	PDT$B_SUBTYP+1	EQ PDT$C_SCSBASE

	.ENABL	LSB

BUILD_PDT:

	MOVZWL	#<PDT$C_PALENGTH+512>,R1  ; Enough for a PDT + 1 pg
	JSB	G^EXE$ALONONPAGED	; Allocate non-paged pool for PDT
	BLBS	R0,10$			; Branch if success
	ASSUME	PAER$K_ES_POOL EQ 0	; Else, log a pool allocation
	CLRL	R0			; error.
	BSBW	ELOG$INIT_SWERR
	RSB				; Return with unit offline

10$:	MOVL	R2,R0			; Save address
	MOVAL	PDT$C_PQB+512(R2),R2	; Round PQB offset up to 
	BICW	#511,R2			;  next page boundary
	SUBL	#PDT$C_PQB,R2		;  and compute corresponding PDT base
	MOVL	R2,UCB$L_PDT(R5)	; Save PDT addr
	MOVL	UCB$L_CRB(R5),R3	; Get CRB addr
	MOVL	R2,CRB$L_AUXSTRUC(R3)	;  and save PDT addr in CRB
	SUBW3	R0,R2,PDT$W_SIZE(R0)	; Fix up size of unused memory
	MOVW	#DYN$C_SCS,PDT$B_TYPE(R0) ;  and type
	CLRL	(R2)+			; Init PDT, unused longwd,
	MOVL	#PDT$C_PA@24,(R2)+	;  unused 3 bytes and port type
	SUBW3	PDT$W_SIZE(R0),R1,(R2)+	;  PDT size,
	MOVW	#<DYN$C_SCS_PDT@8 + DYN$C_SCS>,(R2)+  ;  structure subtype and type
	MOVL	CRB$L_INTD+VEC$L_INITIAL(R3),R3  ; Get addr of controller
						 ;  init routine
	MOVAW	PA$SCSOFFSET,R1		; Get addr of table of offsets
					;  to SCS entries in PADRIVER

20$:	CVTWL	(R1)+,R0		; Get offset to next SCS routine
	BEQL	30$			; Branch if no more
	ADDL3	R0,R3,(R2)+		; Add offset from controller init
					;  to addr of controller init
					;  and store in PDT
	BRB	20$			; Get next offset

30$:	MOVQ	R4,-(SP)		; Save R4, R5
	MOVC5	#0,#0,#0,-		; Zero PDT from here to
		#<PDT$L_DQELOGOUT - PDT$C_SCSEND>,-
		(R2)			;  to logout area
	MOVQ	(SP)+,R4		; Restore  R4, R5
	MOVL	UCB$L_PDT(R5),R2	; Get base of PDT again
	MOVAL	PDT$L_WAITQFL(R2),-	; Init the pool wait
		PDT$L_WAITQFL(R2)	;  queue
	MOVAL	PDT$L_WAITQFL(R2),-	;  to empty
		PDT$L_WAITQBL(R2)	;
	ADDL3	W^SCS$GL_SCSSIZE,-	; Set size of message header, 
		#PPD$C_LENGTH,-		;  PPD +
		PDT$L_MSGHDRSZ(R2)	;  SCS header
	ADDL3	W^SCS$GL_SCSSIZE,-	; Save size of datagram header,
		#PPD$C_LENGTH,-		;  PPD +
		PDT$L_DGHDRSZ(R2)	;  SCS portion only
	MOVL	#CXB$C_HEADER,-		; Set size of total dg header
		PDT$L_DGOVRHD(R2)	;  including PPD/SCS, and net
	SUBL3	PDT$L_DGHDRSZ(R2),-	; Calculate size of network header
		PDT$L_DGOVRHD(R2),-	;
		PDT$L_DGNETHD(R2)	;
	MNEGL	#1,PDT$L_MAXBCNT(R2)	; Set max bytes per block xfer =
					;  2**32-1
	MOVAL	PDT$C_PAREGBASE(R2),R2	; Step to addr of PA device
					;  registers accessed via PDT
	MOVAW	PA$REGOFFSET,R1		; Get addr of table of offsets 
					;  to device registers we want
	
40$:	CVTWL	(R1)+,R0		; Get next offset
	BLSS	50$			; Branch if end of offset table
	ADDL3	R0,R4,(R2)+		; Add offset to config reg addr,
					;  and store in PDT
	BRB	40$			; Get next offset

50$:	MOVL	UCB$L_PDT(R5),R2	; Get base of PDT again
	MOVL	R5,PDT$L_UCB0(R2)	; Save in PDT UCB 0 addr
	MOVAL	PDT$Q_FORMPB(R2),-	; Init formative
		PDT$Q_FORMPB(R2)	;  PB list
	MOVAL	PDT$Q_FORMPB(R2),-	;  to empty
		PDT$Q_FORMPB+4(R2)	;
	MOVB	#<PDT$M_CUR_LBS!PDT$M_PRV_LBS>,-  ; Set current/previous
		PDT$B_P0_LBSTS(R2)		  ;  loopback status to
	MOVB	#<PDT$M_CUR_LBS!PDT$M_PRV_LBS>,-  ;  good, 
		PDT$B_P1_LBSTS(R2)		  ;  both paths
	MOVAL	PDT$Q_DFREEQ(R2),-	; Set up addresses
		PDT$L_DFQHDR(R2)	;  of datagram and
	MOVAL	PDT$Q_MFREEQ(R2),-	;  message free queue
		PDT$L_MFQHDR(R2)	;  headers for port
	MOVL	PDT$L_DGOVRHD(R2),-	; Set up dg and msg queue
		PDT$W_DQELEN(R2)	;  entry sizes in PQB
	ADDW	G^SCS$GW_MAXDG,-	;  for port
		PDT$W_DQELEN(R2)	;
	MOVL	PDT$L_MSGHDRSZ(R2),-	; Queue entry size =
		PDT$W_MQELEN(R2)	;  PPD/SCS header
	ADDW	G^SCS$GW_MAXMSG,-	;  + SYSGEN param
		PDT$W_MQELEN(R2)	;
	MOVAL	PDT$C_PQB(R2),-		; Set VA of PQB within
		PDT$L_VPQB(R2)		;  PDT
	MFPR	#PR$_SBR,-		; Set PA of base of SPT
		PDT$L_SPTBASE(R2)	;  
	MFPR	#PR$_SLR,-		;  and SPT length
		PDT$L_SPTLEN(R2)	;
	MOVL	G^MMG$GL_GPTBASE,-	; Set VA of base of global
		PDT$L_GPTBASE(R2)	;  page table
	ADDL3	G^SGN$GL_MAXGPGCT,-	;  and GPT length which is
		PDT$L_SPTLEN(R2),-	;  the sum of the global page
		PDT$L_GPTLEN(R2)	;  count and spte count  (global
					;  page table base=spt base.)
	MOVAL	G^SCS$GL_PDT,R1		; Get base of SCS port list

60$:	MOVL	(R1),R0			; Get next port
	BEQL	70$			; Branch if none
	MOVL	R0,R1			; Else save next PDT as previous
	BRB	60$			; Continue down the list
	
70$:	MOVL	R2,(R1)			; Hook this PDT to end of list

	.DSABL	LSB

	.SBTTL	BUILD TEMPLATE LOOPBACK DG

;+
; Allocate and initialize the template loopback datagram except for local
; port number and CRC.  These are recalculated each time power is recovered.
;
; Note that the template loopback datagram need not have a network header,
; nor have PPD$W_SIZE be a negative offset.
;-

	.ENABL	LSB

BUILD_TLB:

	MOVZWL	#PPD$C_LB_LENGTH,R1	; Get total template size
	JSB	G^EXE$ALONONPAGED	; Allocate non-paged pool for template
	BLBS	R0,10$			; Branch if got it
	ASSUME	PAER$K_ES_POOL EQ 0	; Else, log a pool allocation
	CLRL	R0			; error.
	BSBW	ELOG$INIT_SWERR
	BRW	CLEANUP_PDT		; Go clean up allocated buffers

10$:	MOVW	R1,PPD$W_SIZE(R2)	; Save structure size and
	MOVW	#DYN$C_CIDG,-		;  type
		PPD$B_TYPE(R2)		;
	CLRB	PPD$B_STATUS(R2)	; Init template status = 0,
	MOVZBW	#PPD$C_SNDLB,-		;  opcode = SNDLB,
		PPD$B_OPC(R2)		;
	MOVW	#PPD$C_LBDAT_LEN,-	;  LB length to # of
		PPD$W_LENGTH(R2)	;  bytes of data
	CLRL	R1			; Generate LB data pattern

20$:	MOVB	R1,PPD$B_LBDATA(R2)[R1]	;  of bytes = 0,1,2,...
	AOBLEQ	#PPD$C_LBDAT_LEN,R1,20$	;  ... LBDAT_LEN-1
	MOVL	UCB$L_PDT(R5),R0	; Hook template to
	MOVL	R2,PDT$L_LBDG(R0)	;  PDT

	.SBTTL	SCS LAYER INITIIALIZATION

;+
; Now call into the SCS layer so it can do any needed initializations.
;-

	BSBW	SCS$INITIAL		; Do it
	MOVL	UCB$L_PDT(R5),R2	; Restore PDT address
	MOVZWL	G^SCS$GW_BDTCNT,-	; Set count of BD's
		PDT$W_BDTLEN(R2)	;  and address of
	MOVL	G^SCS$GL_BDT,-		;  BDT in case BDT
		PDT$L_VBDT(R2)		;  has already been created
	BLBS	R0,INIT_CRB		; Branch if success
	ASSUME	PAER$K_ES_POOL EQ 0	; Else, log a pool allocation
	CLRL	R0			; error.
	BSBW	ELOG$INIT_SWERR
	BRW	CLEANUP_PDT		; Go clean up allocated pool

	.SBTTL	INIT POLLER TIMER AND TRACE FUNCTION

;+
; Initialize timer to wake driver up and insert CRB on timer queue.
;-

	.ENABL	LSB

INIT_CRB:

	MOVL	UCB$L_CRB(R5),R3	; Get CRB addr
	BSBW	CNF$CALCINTDUE		; Set to wake up basic timer 
					;  interval from now and
	JSB	G^IOC$THREADCRB		; put CRB on timer queue

	.IF	DF PA$DEBUG		; Conditional init of debug facility
	BSBW	TRC$INIT		; Init trace buffer
	.ENDC				;

	.DSABL	LSB

	.SBTTL	INI$PORT, INITIALIZE PORT 

;+
; Load the port microcode, init port hardware, complete initialization
; of the template loopback datagram (in case port number changed while
; powered down.)  Allocate and queue free datagrams and messages to
; port for future receives.  If all this is successful, set unit 0 online,
; clear power fail in progress and set port powered up.
;
; Inputs:
;	
;	R4			-Addr of port configuration register
;	R5			-Addr of UCB of unit 0
;
;	IPL			-IPL$_SCS
;
; It is assumed that device interrupts are disabled, that there are no
; outstanding interrupts, and that the port is in the un-initialized state.
;-

ASSUME	PDT$W_STDGUSED	EQ  PDT$W_STDGDYN+2
ASSUME	PDT$Q_COMQH	EQ  PDT$Q_COMQBASE+8
ASSUME	PDT$Q_COMQ2	EQ  PDT$Q_COMQH+8
ASSUME	PDT$Q_COMQ3	EQ  PDT$Q_COMQ2+8
ASSUME	PDT$Q_RSPQ	EQ  PDT$Q_COMQ3+8

ASSUME	PPD$C_LBDAT_LEN+7  LE	255

	.ENABL	LSB

INI$PORT::

	MOVL	PA_CNF(R4),PA_CNF(R4)	; Clear any misc errors we can
	BITW	#PA_CNF_M_NOCI,-	; CI750 port inaccessible?
		PA_CNF(R4)		;
	BEQL	10$			; Branch if accessible
	BRW	PORT_NOTPRES		; Else go handle error

10$:	MOVL	#PA_PMC_M_MIN,PA_PMC(R4); Place port in un-initialized state
	MOVQ	R4,-(SP)		; Save registers destroyed by subr
	BSBW	TEST_SHUTDOWN		; Check if we are shutting down and
					;  if so, take operator action which
					;  may possibly include a bugcheck
					;  if we can't go on without the port
	MOVQ	(SP)+,R4		; Restore registers
	MOVL	UCB$L_PDT(R5),R2	; Get PDT address
	BNEQ	15$			; Branch if this port is still in business
	RSB				; Else return to caller without 
					;  reinitializing it

15$:	MOVB	#1,INI$CPU_REV		; Assume CPU rev will be okay
	CMPL	INI$T_HWTYPE,#^A/V750/	; Running 11/750?
	BNEQ	CPU_REV_OK		; Branch if not
	MFPR	#PR$_SID,R1		; Read SID (copy of SID in memory
					;  is not good enough because the
					;  ucode rev level may have been
					;  increased by the loading of patches
					;  by the PCS software load mechanism
					;  or decreased by failure to load patches
					;  following pwr fail recovery.)
	ASHL	#-8,R1,R0		; Get ucode rev level in low byte
	CMPB	R0,#MIN_750_REV		; Is CPU ucode sufficient to run port
	BGEQ	CPU_REV_OK		; Branch if so
	BRW	CPU_REV_ERROR		; Go handle if not sufficient

CPU_REV_OK:

	MOVL	G^SCS$GL_MCADR,R3	; Get base of microcode image
	BNEQ	CHECK_QUEUES		; Branch if got microcode image in pool
	MOVZBL	#PAER$K_ES_CODE, R0	; Else, log error indicating that
	BSBW	ELOG$INIT_SWERR		; microcode could not be found in pool.

20$:	BRW	CLEANUP_PDT		; Go clean up allocated pool

CHECK_QUEUES:

	SKPC	#0,#<PDT$Q_RSPQ - PDT$Q_COMQBASE>,-
		PDT$Q_COMQBASE(R2)	; Check for any nonzero port 
					;  command queues or response queue
	BEQL	LOAD_UCODE		; Branch if all zero (empty queues)
	$DEBUGCHECK #ERR$V_DEB_NEPQ	; Else do optional bugcheck
					;  since on reinit all queues should
					;  be empty
	CLRB	(R1)			; For recovery, try zeroing byte
	BRB	CHECK_QUEUES		;  and check again

LOAD_UCODE:

	MOVZWL	#^X400,R2		; Set initial MC addr assuming  ROM port
	CMPL	8(R3),#^X5F6A00A1	; Is this code from an all RAM
					;  port file?
	BNEQ	30$			; Branch if not -- assume ROM
	CLRL	R2			; Else set to load both PROM

30$:	MOVQ	R2,-(SP)		; Save initial addresses

40$:	MOVL	R2,PA_MADR(R4)		; Give CS addr to CI
	MOVL	(R3)+,PA_MDATR(R4)	; Write 4 bytes of ucode
	BISL3	#^X1000,R2,-		; Step CS addr of h.o. 
		PA_MADR(R4)		;  word of data
	MOVZWL	(R3)+,PA_MDATR(R4)	; Write h.o. 2 bytes
	AOBLSS	#^XC00,R2,40$		; Loop till entire image loaded
	MOVQ	(SP)+,R2		; Retreive initial addresses for
					;  read back of ucode
	TSTL	R2			; Is this a possible all RAM port?
	BEQL	START_UCODE		; Branch if so to skip check of
					;  possible ROM code that might
					;  not agree with our ucode image.
	
CHECK_UCODE:

	MOVL	R2,PA_MADR(R4)		; Set next control store addr
	MOVL	(R3)+,R0		; Get next 4 bytes wcs should have
	CMPL	PA_MDATR(R4),R0		; WCS ok?
	BNEQ	BAD_UCODE		; Branch if not
	BISL3	#^X1000,R2,PA_MADR(R4)	; Set to read h.o. 2 bytes of uword
	MOVZWL	(R3)+,R0		; Get next 2 bytes WCS should have
	CMPW	PA_MDATR(R4),R0		; Next 2 bytes ok?
	BEQL	60$			; Branch if so

BAD_UCODE:

	BRW	WCS_ERROR		; Go handle error

60$:	AOBLSS	#^XC00,R2,CHECK_UCODE	; Branch if more to check

	
START_UCODE:

	BISL	#PA_PMC_M_PSA,-		; Set programmable start addr
		PA_PMC(R4)		;  bit
	MOVL	#PA_C_UCODEST,-		; Set microcode start addr
		PA_MADR(R4)		;
	MOVL	#PA_PIC_M_PIC,-		; Set port initialize -- move
		PA_PIC(R4)		;  port state from uninit to disabled
	TIMEWAIT #<10000>,#PA_PMC_M_MIF,-  ; Wait for port init done 
		 PA_PMC(R4),L		  ;  or 100 msec
	BLBC	R0,70$			; Branch if failed
	CMPL	PA_PS(R4),-		; Check that port init is done
		#PA_PS_M_PIC		;  and no errors set
	BEQL	90$			; Branch if sucess
70$:	BRW	INIT_PORT_FAIL		; Else go to failure

90$:	MOVL	UCB$L_PDT(R5),R0	; Retreive PDT addr
	EXTZV	#9,#20,-		; Extract virtual page #
		PDT$L_VPQB(R0),R0	;  of PQB
	MOVL	G^MMG$GL_SPTBASE,R1	; Get base of SPT
	MOVL	(R1)[R0],R0		; Get PTE for PQB addr
	EXTZV	#0,#20,R0,R0		; Get PFN of PQB addr
	ASHL	#9,R0,PA_PQBBR(R4)	; Convert to phys addr and
					;  store in the PQB base reg
	BLBS	G^SCS$GB_PASANITY,95$	; Branch if sanity timer wanted
	BISL	#PA_PMC_M_MTD,-		; Else disable it
		PA_PMC(R4)		; 

95$:	MOVL	#PA_PSR_M_PSC,-		; Release the port
		PA_PSR(R4)		;  status register to port
	MOVL	#PA_PEC_M_PEC,-		; Finally,...
		PA_PEC(R4)		;  enable the port

INIT_LBDG_CRC:

	MOVL	UCB$L_PDT(R5),R4	; Get PDT address
	MOVL	PDT$L_LBDG(R4),R3	; Get addr of LB template
	MOVB	@PDT$L_PPR(R4),-	; Save local port number
		PPD$B_PORT(R3)		;  in LB dg template
	MOVZWL	#<PPD$C_LCB_DATA + PPD$C_LBDAT_LEN>,R1
	JSB	G^EXE$ALONONPAGED	; Allocate temporary buffer for 
					;  setting up data to calc CRC
	BLBS	R0,100$			; Branch if got it
97$:	BRW	INIT_LBDG_FAIL		; Else go handle error

100$:	BISL3	#DYN$C_SCS@16,R1,-	; Set structure type
		PPD$W_SIZE(R2)		;  and size in temporary buffer
					; Note that the size is not CRCed
					;  so it can be the straight size
					;  here, not a negative offset to
					;  a net header.
					; Set up data to CRC:
	CLRB	PPD$W_LCB_LEN7(R2)	;  H.o. lb data length + 7
	ADDB3	PPD$W_LENGTH(R3),#7,-	;  L.o. lb data length + 7
		PPD$W_LCB_LEN7+1(R2)	;  
	MOVB	PPD$B_PORT(R3),R0	;
	MOVB	R0,PPD$B_LCB_PORT(R2)	;  own port number,
	MCOMB	R0,PPD$B_LCB_NPORT(R2)	;  NOT(own port),
	MOVB	R0,PPD$B_LCB_LPORT(R2)	;  local port,
	MOVB	#PPD$C_SNDLB,-		;  SNDLB opcode,
		PPD$B_LCB_OPC(R2)	;
	CLRB	PPD$B_LCB_0(R2)		;  and 0 (packing fmt = 0)
	PUSHR	#^M<R2,R3,R4,R5>	; Save registers
	MOVC	#PPD$C_LBDAT_LEN,-	; Copy LB data from
		PPD$B_LBDATA(R3),-	;  template to temporary
		PPD$C_LCB_DATA(R2)	;  buffer
	MOVQ	(SP),R2			; Get R2 and R3 again
	MOVZBL	PPD$W_LCB_LEN7+1(R2),R0	; Get # bytes to crc
	CRC	CRC_TABLE,#-1,-		; Compute CRC from temporary
		R0,PPD$W_LCB_LEN7(R2)	;  buffer
	POPR	#^M<R2,R3,R4,R5>	; Retreive registers
	MCOML	R0,PPD$L_LBCRC(R3)	; Put CRC complement into template
	MOVL	R2,R0			; Copy temporary buffer addr
	JSB	G^COM$DRVDEALMEM	;  and return it to pool

INIT_DFREEQ:

	MOVL	UCB$L_PDT(R5),R4	; Get PDT address
	MOVZWL	G^SCS$GW_PAPPDDG,R0	; Get # dg's for start handshakes
	MOVL	R0,PDT$W_STDGDYN(R4)	; Set dynamic count of # dgs for
					;  IDREC's and 0 the number currently
					;  spoken for by known ports
	ADDL	R0,R0			; Double to handle error log dgs
	BSBW	SCS$ALL_FRDGS		; Allocate and put on free queue
	BLBC	R0,97$			; Branch if insufficient memory
	MOVZWL	#PA_C_MCACHESZ,R0	; Get # msgs to fill cache
	BSBW	SCS$ALL_FRMSGS		; Allocate and put on free queue
	BLBC	R0,97$			; Branch if insufficient memory
	MOVB	#15,PDT$B_MAX_PORT(R4)	; Assume small capacity cluster
	TSTL	@PDT$L_PPR(R4)		; Is it 16 ports max?
	BGEQ	120$			; Branch if so
	MOVB	#223,PDT$B_MAX_PORT(R4)	; Else up count to 224 ports

120$:	MOVB	@PDT$L_PPR(R4),-	; Save local port number in 
		PDT$B_PORT_NUM(R4)	;  PDT
	MOVB	#PPD$C_PSP0,-		; Set poller to scan all ports
		PDT$B_REQIDPS(R4)	;  on path A
	MOVL	UCB$L_CRB(R5),R3	; Retreive CRB address
	BSBW	CNF$CALCINTDUE		; Calculate due time for
					;  next driver wakeup
	BSBW	CNF$CALC_POLLSW		; Compute the time to do a
					;  full sweep by the poller
	PUSHR	#^M<R4,R5>		; Save registers
	MOVC5	#0,#0,#-1,-		; Init port logout area
		#<PDT$C_PALENGTH - PDT$L_DQELOGOUT>,-
		PDT$L_DQELOGOUT(R4)
	POPR	#^M<R4,R5>		; Restore registers
	MOVB	#1,INI$PORT_REV		; Assume port ucode rev is good
	BISW	#UCB$M_ONLINE,-		; Set unit online
		UCB$W_STS(R5)		;
	BICW	#PDT$M_PWF_CLNUP,-	; Clear power up init
		PDT$W_LPORT_STS(R4)	;  in progress
	BISW	#<PDT$M_PUP!PDT$M_LBDG>,-; Set power up and loopback
		PDT$W_LPORT_STS(R4)	;  dg enabled on port
	BISL2	#PA_PMC_M_MIE,-		; Enable interrupts
		@PDT$L_PMC(R4)		;
	RSB				; Return from port initialization
	.DSABL	LSB

	.SBTTL	TEST_SHUTDOWN,	CHECK IF PORT SHOULD
	.SBTTL	-		BE LEFT OFFLINE

;+
; This routine is called each time a port is initialized.  If the port
; is being initialized for the first time, or if it is already shut
; down, then return is taken.
;
; If this is not the first port init, then it must be a reinit following
; a serious port error.  If the system device is not on this CI port,
; and the number of reinitialization tries have been exhausted, then
; the message, '%PAx0, CI Port is going Offline.' is printed. 
; If there are retries left, then the message, 
; '%PAx0, CI Port is Reinitializing ( xxx Retries Left).  Check Error Log.'
; is printed. Both messages are directed to _OPA0, rather than OPCOM since 
; OPCOM needs a functioning system device to run and the system device may be 
; accessible only through the failing port.
;
; In the case of initialization failures that result in branching back
; to INI$PORT for another try (e. g., ucode readback compare error),
; these failures count against the maximum error retry count, and a message
; is printed for each failure.
;
; If the port should be taken offline due to exhausted retry count, but
; the system device is on this CI or this port is needed to cluster,
; then the port driver bugchecks (in routine CLEANUP_PDT.)
;
; Inputs:
;
;	R4			-Addr of port config register
;	R5			-Addr of UCB
;	IPL			-IPL$_SCS
;
; Outputs:
;
;	R0-R5			-Destroyed
;	Other registers		-Preserved
;-

	.ENABL	LSB

TEST_SHUTDOWN:

	TSTL	UCB$L_PDT(R5)		; Already shutdown?
	BEQL	10$			; Branch if so, no reason to proceed
	CMPB	UCB$B_ERTCNT(R5),-	; Is this the first init of port?
		UCB$B_ERTMAX(R5)	; 
	BNEQ	20$			; Branch if not
10$:	RSB				; Else return to continue init

20$:	MOVAL	INI$MSG_INIT,R2		; Get addr of appropriate msg
	TSTB	UCB$B_ERTCNT(R5)	; Retries all used up?
	BGEQ	30$			; Branch if not
	BSBW	CLEANUP_PDT		; Else cleanup PDT-- bugcheck
					;  if can't proceed without port
	MOVAL	INI$MSG_OFFL,R2		; We can proceed
	BRB	40$			; Go print port offline message

;
; The port reinitialization message is going to be broadcast to _OPA0. Format
; that portion of the message the contains the number of retries remaining.
;

30$:	PUSHL	R2			; Save message address
	ADDL2	#RETRY_OFFSET,R2	; Position to retry field in message
	MOVZBL	UCB$B_ERTCNT(R5),R0	; Retrieve number of retries left
	BSBW	ERR$CNV_HEX_DEC		; Format the retry field
	POPL	R2			; Restore message address

;
; Broadcast the message of choice to _OPA0 after completing the common
; formatting of the message.
;

40$:	MOVZBL	(R2)+,R1		; Get message size and address
	MOVL	UCB$L_DDB(R5),R0	; Get DDB addr in R0
	MOVB	DDB$T_NAME+3(R0),-	; Copy device controller letter from
		CTRLR_NAME(R2)		;  DDB to ASCII msg
	MOVAB	G^OPA$UCB0,R5		; Set _OPA0 to get msg
	JMP	G^IOC$BROADCAST		; Send msg to terminal driver

	.DSABL	LSB

	.SBTTL	PORT INITIALIZATION ERRORS

;+
; Come to PORT_NOTPRES if the NOCI bit is set in the configuration
; register.  The condition can only ever happen on a CI750.  It indicates
; that the port in its external cabinet is uncabled or unpowered.
;-

	.ENABL	LSB

PORT_NOTPRES:

	CVTWL	#<PAER$K_ES_HWER ! ^X8000>,R0	; Log as unspecified hardware
	BSBW	ELOG$HARDWARE			;  error
	BRW	CLEANUP_PDT			; Go clean up without bothering
						;  to do any retries.

;+
; Come to CPU_REV_ERROR if the CPU revision level is not sufficient to
; support CI port activity.
;
; Inputs:
;
;	R1			-Copy of current SID
;	R5			-UCB address
;-

CPU_REV_ERROR:

	CLRB	INI$CPU_REV		; Clear flag that says this
					;  is regular bugcheck reason --
					;  this is reason for UCODEREV bugchk
	BSBW	ELOG$CPU_REV		; Log bad CPU rev
	BRW	CLEANUP_PDT		; Go clean up pool because we
					;  can't continue

;+
; Come to WCS_ERROR if loaded microcode could not be read back
; correctly.
;
; Inputs:
;
;	PA_MADR(R4)		-micro addr that failed
;	PA_MDATR(R4)		-Bad WCS contents
;	R0			-Copy of good data from pool
;-

WCS_ERROR:

	BSBW	ELOG$UCODE_NORD		; Log microcode read-back error.
	BRW	RETRY_INIT		; Go clean up allocated pool

;+
; Port initialization (transition from uninitialized to disabled) did
; not complete correctly.
;-

INIT_PORT_FAIL:

	CVTWL	#<PAER$K_ES_INIT ! ^X8000>, R0	; Log failed to change from
	BSBW	ELOG$HARDWARE			; uninit. to disabled error.
	BRW	RETRY_INIT		; Go clean up allocated pool

;+
; Unable to allocate temporary buffer in which to calculate the
; loopback datagram CRC.
;-

INIT_LBDG_FAIL:

	ASSUME	PAER$K_ES_POOL EQ 0	; Log a pool allocation error.
	CLRL	R0
	BSBW	ELOG$INIT_SWERR
	MOVL	#PA_PMC_M_MIN,-		; Do maint init on port to
		@PDT$L_PMC(R4)		;  make sure it's quiet
	BRB	CLEANUP_PDT		; Go clean up allocated pool

	.DSABL	LSB

;+
; Deallocate template loopback datagram (if any) and PDT (if any).
; Return to caller with device offline, and power fail/power up
; unchanged.
;
; Inputs:
;
;	R5			-UCB 0 addr
;-

INI$CPU_REV::	

	.BYTE	1			; 1/0 means CPU rev is okay/not okay

INI$PORT_REV::

	.BYTE	1			; 1/0 means port ucode rev is okay/not okay
					; NOTE: use of this memory flag is not
					;  quite right in the case with multiple
					;  ports since there is a fork between
					;  the point where the flag is set
					;  in ERR$CRASHPORT and where it is
					;  set and here.  This means that we
					;  might take the UCODEREV bugcheck
					;  with the context for the wrong
					;  port in hand, not a very serious
					;  mishap.

ASSUME	PDT$L_FLINK	EQ 0

	.ENABL	LSB

CLEANUP_PDT:

	MOVL	UCB$L_PDT(R5),R2	; Get PDT addr
	BEQL	MAYBE_SYS_DEAD		; Branch if none allocated
	MOVAL	G^SCS$GL_PDT,R1		; Get base of SCS port list

10$:	MOVL	(R1),R0			; Get next PDT
	BEQL	30$			; Branch if none, ours wasn't linked
	CMPL	R0,R2			; Is this PDT ours?
	BEQL	20$			; Branch if it is
	MOVL	R0,R1			; Else, save next PDT as previous
	BRB	10$			; Continue searching down the list
	
20$:	MOVL	(R2),(R1)		; Remove out PDT from the list

30$:	MOVL	PDT$L_LBDG(R2),R0	; Get loopback dg addr
	BEQL	40$			; Branch if none allocated
	JSB	G^COM$DRVDEALMEM	; Else deallocate it

40$:	MOVL	PDT$L_CNF(R2),R1	; Get configuration register addr
	$PRTCTINI -			; Ignore non responding device registers
		B^50$,MCHK$M_NEXM	;  causing machine checks
	MOVL	#PA_PMC_M_MIN,-		;  while MINing the port once
		PA_PMC(R1)		;  more just to be sure it's quiet
	$PRTCTEND 50$			;
	MOVL	G^EXE$GL_SYSUCB,R0	; Get system device UCB
	CMPL	UCB$L_PDT(R0),-		; Is it via our PDT?
		UCB$L_PDT(R5)		; 
	BEQL	MAYBE_SYS_DEAD		; Branch if so
	TSTL	G^CLU$GL_CLUB		; No.  Are we clustering?
	BEQL	60$			; Branch if not because system can get
					;  by without port

MAYBE_SYS_DEAD:

	TSTL	G^SCS$GL_PDT		; Any SCS speaking PDTs left?
	BNEQ	60$			; Branch if so -- take a chance
					;  that the remaining port(s) will
					;  carry us
	MOVL	UCB$L_PDT(R5),R4	; Else set up R4 for BUGCHECK
	TSTB	INI$CPU_REV		; Is this a CPU ucode problem?
	BEQL	UCODE_BUGCHK		; Branch if so
	TSTB	INI$PORT_REV		; Is this a port ucode problem?
	BEQL	UCODE_BUGCHK		; Branch if so
	BUGCHECK CIPORT,FATAL		; Else shut the system down with
					;  normal CIPORT bugcheck

UCODE_BUGCHK:
	
	BUGCHECK UCODEREV,FATAL		; Shut system down with microcode
					;  revision problem bugcheck

60$:	MOVL	R2,R0			; Copy PDT addr to R0
	JSB	G^COM$DRVDEALMEM	; Deallocate PDT
	CLRL	UCB$L_PDT(R5)		; Show PDT as gone
	MOVL	UCB$L_CRB(R5),R0	; Get CRB addr
	CLRL	CRB$L_AUXSTRUC(R0)	;  and show no PDT here either

70$:	RSB				; Return


;+
; RETRY_INIT is branched to on WCS load error or port init
; error.  RETRY_INIT checks for retries left.  If none, it branches
; to CLEANUP_PDT.  If retries are left, it branches to INI$PORT
; after decrementing the retry count.
;
; Inputs:
;
;	R4			-Cofiguration register addr
;	R5			-UCB 0 addr
;-

RETRY_INIT:

	MOVL	#PA_PMC_M_MIN,-		; Do maint init on port
		PA_PMC(R4)		;  to make sure it's quiet
	DECB	UCB$B_ERTCNT(R5)	; Decr # retries left
	BGEQ	90$			; Branch if retries left
	BRW	CLEANUP_PDT		; Else cleanup PDT

90$:	BRW	INI$PORT		; Else do another init

	.DSABL	LSB

	.SBTTL	INI$FORK

;+
; This routine oversees and participates in the creation of a fork process,
; and the transfer of control at fork IPL to a user supplied address. This
; routine will use the UCB's fork block dequeuing it from the appropriate fork
; queue if necessary. The dequeuing of the fork block and creation of the fork
; process is handled as an atomic event by disabling all interrupts before
; testing whether the fork block needs to be dequeued, and then re-enabling 
; interrupts after creation of the fork process. After creation of the fork
; process this routine returns control to the caller.
;
; When the fork process commences execution it will do so within this routine.
; It immediately will transfer control to the user supplied address. The caller
; of this routine has available R4 in order to pass information across the 
; creation of the fork process to the user routine which will be jumped to at
; fork IPL.
;
; This routine participates in proper synchronization to the fork block by the 
; appropriate setting and clearing of the fork block interlock bit before the 
; fork process is creating, and within the context of the fork process.
;
; Inputs:
;
;	R3			-Address to JMP to at fork IPL
;	R5			-Address of UCB
;	IPL			-Device IPL or higher
;
;	
; Outputs:
;
;	After creation of fork process but before returning to caller:
;
;	R3-R4			-Destroyed
;	Other registers		-Preserved
;	IPL			-Preserved
;
;	Before exit from fork process:
;
;	R0-R2			-Unpredictable
;	R3			-User address jumped to at fork IPL
;	R4			-User supplied value
;	R5			-Address of UCB
;	IPL			-Fork IPL
;-

	.ENABL	LSB
INI$FORK::
	DSBINT				; Disable all interrupts
	BBCS	#UCB_V_FKLOCK,-		; Is the fork block in use? 
		UCB$W_DEVSTS(R5),10$	; Branch if not and set in use bit
	REMQUE	(R5),R5			; Remove fork block from its queue

10$:	PUSHAB	20$			; Return address for fork proc creation
	PUSHAB	30$			; Fork process PC
	JMP	G^EXE$FORK		; Create the fork process

20$:	ENBINT				; Re-enable interrupts 
	RSB				; Return to caller

;
; INI$FORK resumes execution at fork IPL within the context of the fork process
; whose creation it has initiated.
;

30$:	BICW2	#UCB_M_FKLOCK,-		; Clear fork block in use bit
		UCB$W_DEVSTS(R5)
	JMP	(R3)			; Transfer control to user supplied addr
	.DSABL	LSB

	.END
