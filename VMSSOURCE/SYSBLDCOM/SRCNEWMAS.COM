$ DBG_VERIFY=F$EDIT("''SOURCE_KIT_VERIFY'","TRIM,UPCASE")
$ IF DBG_VERIFY.NES."1".AND.DBG_VERIFY.NES."T" THEN $ DBG_VERIFY:="0"
$ V='F$VERIFY(DBG_VERIFY)'
$ !
$ ! This command procedure creates a copy of the specified master source pack
$ ! on the desired disk device.  It accepts the following parameters to control
$ ! the various operations:
$ !
$ !	P1 -	the device on which the source master pack resides
$ !		(required)
$ !
$ !	P2 -	the device on which the target master pack is to be built
$ !		(required)
$ !
$ !	P3 -	the label of the target master pack (default is VMSMASTER)
$ !
$ !	P4 -	the name of the file to control the structure of the target
$ !		master pack (the default is [SYSBLDCOM]VMSNEWBLD.DAT.
$ !
$ !	P5 -	the source of the update packets (ENH or BUG)
$ !		(required)
$ !
$ !	P6 -	misc. options to control various internal choices:
$ !			LOG - to log creates & copies
$ !			STATISTICS - show accounting stats
$ !			NOINITIALIZE - target master pack is not to be initialized
$ !			NOSETUP - don't do the setup phase (copying [SYSEXE], etc.)
$ !
$ ! In addition to the above parameters, this command procedure also looks for
$ ! the logical name STOP_MERGE in the group logical name table.  If this
$ ! logical name is defined (it is not null) then the merge is aborted cleanly.
$ !
$ ! Set up the error handling.
$ !
$ ON ERROR THEN $ GOTO CLEAN_UP
$ ON SEVERE_ERROR THEN $ GOTO CLEAN_UP
$ ON CONTROL_Y THEN $ GOTO CLEAN_UP
$ ON CONTROL_C THEN $ GOTO CLEAN_UP
$ !
$ ! Define some widely used shorthand synonyms.
$ !
$ OUTPUT="WRITE SYS$OUTPUT"
$ !
$ ! Set the initial state of the needed variables.
$ !
$ BATCH="FALSE"
$ IF F$MODE().EQS."BATCH" THEN BATCH="TRUE"
$ !
$ OLD_DEV=F$LOGICAL("SYS$DISK")
$ OLD_DIR=F$DIRECTORY()
$ OLD_UIC=F$USER()
$ FIRST_FACILITY=""
$ OPERATION=""
$ RESTART_FIL=""
$ RESTART_DIR=""
$ CLEANUP=0
$ !
$ BUILD_UIC="[11,177]"
$ !
$ SET UIC 'BUILD_UIC'
$ !
$ ! Get the source master pack device name if not given.
$ !
$GET_SRC:
$ IF P1.NES."" THEN $ GOTO GOT_SRC
$ IF BATCH THEN $ GOTO CLEAN_UP
$ INQUIRE P1 "What device has the source master pack [DISK$VMSMASTER:]"
$ IF P1.EQS."" THEN P1="DISK$VMSMASTER:"
$GOT_SRC:
$ IF F$LOCATE(":",P1).GE.F$LENGTH(P1) THEN $ P1=P1+":"
$ SRC_MASTER=P1
$ IF F$GETDVI(SRC_MASTER,"EXISTS") THEN $ GOTO GOT_DST
$ OUTPUT "''SRC_MASTER' does not exist."
$ IF BATCH THEN $ GOTO CLEAN_UP
$ GOTO GET_SRC
$ !
$ ! Get the target master pack device name if not given.
$ !
$GET_DST:
$ IF P2.NES."" THEN $ GOTO GOT_DST
$ IF BATCH THEN $ CLEAN_UP
$ INQUIRE P2 "What device is the target master pack on (ddcn:)"
$ GOTO GET_DST
$GOT_DST:
$ IF F$LOCATE(":",P2).GE.F$LENGTH(P2) THEN $ P2=P2+":"
$ DST_MASTER=P2
$ IF F$GETDVI(DST_MASTER,"EXISTS") THEN $ GOTO GOT_DST1
$ OUTPUT "''DST_MASTER' does not exist."
$ IF BATCH THEN $ GOTO CLEAN_UP
$ GOTO GET_DST
$GOT_DST1:
$ IF F$GETDVI(DST_MASTER,"MNT") THEN $ GOTO GET_LABEL
$ ON WARNING THEN $ GOTO GET_DST
$ ALLOCATE 'DST_MASTER'
$ ON WARNING THEN $ CONTINUE
$ !
$ ! Determine the label of the target master pack.
$ !
$GET_LABEL:
$ DST_LABEL=P3
$ IF P3.NES."" THEN $ GOTO GOT_LABEL
$ IF .NOT.BATCH THEN $ INQUIRE P3 "Target master pack label [VMSMASTER]"
$ DST_LABEL=P3
$ IF P3.EQS."" THEN $ DST_LABEL="VMSMASTER"
$GOT_LABEL:
$ !
$ ! Determine the build data file to use.
$ !
$GET_FILE:
$ BUILD_FILE=P4
$ IF P4.NES."" THEN $ GOTO CHECK_FILE
$ IF .NOT.BATCH THEN -
	$ INQUIRE P4 "Control data file [''SRC_MASTER'[SYSBLDCOM]VMSNEWBLD.DAT]"
$ BUILD_FILE=P4
$ IF P4.EQS."" THEN $ BUILD_FILE=SRC_MASTER+"[SYSBLDCOM]VMSNEWBLD.DAT"
$CHECK_FILE:
$ ON WARNING THEN $ GOTO BUILD_FILE_ERROR
$ IF F$SEARCH(BUILD_FILE).NES."" THEN $ GOTO GOT_FILE
$BUILD_FILE_ERROR:
$ OUTPUT "%SRCMRG-E-FNF, file not found '",BUILD_FILE,"'"
$ IF BATCH THEN $ GOTO CLEAN_UP
$ P4=""
$ GOTO GET_FILE
$GOT_FILE:
$ ON WARNING THEN $ CONTINUE
$ !
$ ! Determine the type of master pack copy to do.
$ !
$GET_TYPE:
$ IF P5.EQS."BUG".OR.P5.EQS."ENH" THEN $ GOTO GOT_TYPE
$ IF BATCH THEN $ CLEAN_UP
$ INQUIRE P5 "What type of copy operation (BUG or ENH) [ENH]"
$ IF P5.EQS."" THEN $ P5="ENH"
$ GOTO GET_TYPE
$GOT_TYPE:
$ IGNORE_TYPE="BUG"
$ IF P5.EQS."BUG" THEN $ IGNORE_TYPE="ENH"
$ !
$ ! Check for any options.
$ !
$ LOGGING=""
$ IF F$LOCATE("LOG",P6).LT.F$LENGTH(P6) THEN $ LOGGING="/LOG"
$ STATS="FALSE"
$ IF F$LOCATE("STATISTICS",P6).LT.F$LENGTH(P6) THEN $ STATS="TRUE"
$ NOINIT="FALSE"
$ IF F$LOCATE("NOINITIALIZE",P6).LT.F$LENGTH(P6) THEN $ NOINIT="TRUE"
$ NOSETUP="FALSE"
$ IF F$LOCATE("NOSETUP",P6).LT.F$LENGTH(P6) THEN $ NOSETUP="TRUE"
$ !
$ ! If the build file has not been copied, go do it.
$ !
$ IF F$SEARCH("SYS$LOGIN:VMSNEWBLD.DAT").EQS."" THEN $ GOTO COPY_BUILD_FILE
$ !
$ ! If this is a restart of a previously running batch job, use the existing
$ ! version of the build control file.
$ !
$ IF $RESTART THEN $ GOTO OPEN_BUILD_FILE
$ !
$ ! If the build file has been copied, then make sure it is (most likely) the
$ ! same file.  This is done by making sure that the creation date and the
$ ! file size are the same.  If any one of the three is different, it is
$ ! assumed that the file is not the same version, and a new copy is made.
$ !
$ IF F$FILE_ATTRIBUTES(BUILD_FILE,"CDT").NES. -
     F$FILE_ATTRIBUTES("SYS$LOGIN:VMSNEWBLD.DAT","CDT") THEN $ GOTO COPY_BUILD_FILE
$ IF F$FILE_ATTRIBUTES(BUILD_FILE,"EOF").EQS. -
     F$FILE_ATTRIBUTES("SYS$LOGIN:VMSNEWBLD.DAT","EOF") THEN $ GOTO OPEN_BUILD_FILE
$COPY_BUILD_FILE:
$ !
$ ! BACKUP is used to insure that the revision date and creation date remain
$ ! the same across the name change.
$ !
$ SUFFIX=""
$ IF F$LOCATE(";",BUILD_FILE).GE.F$LENGTH(BUILD_FILE) THEN $ SUFFIX=";"
$ BACKUP'LOGGING' 'BUILD_FILE''SUFFIX' SYS$LOGIN:VMSNEWBLD.DAT;
$ !
$ ! Open the build file for use in checkpointing the procedure and to
$ ! control the facilities copied.
$ !
$OPEN_BUILD_FILE:
$ OPEN/SHARE/READ BLDFIL SYS$LOGIN:VMSNEWBLD.DAT
$ CLEANUP=CLEANUP.OR.1
$ OPEN/SHARE/WRITE/READ CHKPNT SYS$LOGIN:VMSNEWBLD.DAT
$ CLEANUP=CLEANUP.OR.2
$ !
$ ! See if this is a restart of a copy.  If not, copy the build file and add a
$ ! record that contains information about the current state of the update.  If
$ ! it is, read the needed information from the build file and continue from
$ ! where the job was interrupted.
$ !
$ RESTART="FALSE"
$ READ/NOLOCK/INDEX=0/KEY="MERGE_MASTER"/ERROR=INIT_SOURCE_RECORD CHKPNT RECORD
$ RECORD=F$EXTRACT(16,999,RECORD)
$ OPERATION:='F$ELEMENT(0,"|",RECORD)
$ FIRST_FACILITY:='F$ELEMENT(1,"|",RECORD)
$ IF FIRST_FACILITY.EQS."|" THEN $ FIRST_FACILITY=""
$ RESTART_FIL:='F$ELEMENT(2,"|",RECORD)
$ IF RESTART_FIL.EQS."|" THEN $ RESTART_FIL=""
$ RESTART_DIR:='F$ELEMENT(3,"|",RECORD)
$ IF RESTART_DIR.EQS."|" THEN $ RESTART_DIR=""
$ CLEANUP:='F$ELEMENT(4,"|",RECORD)
$ IF CLEANUP.EQS."|" THEN $ CLEANUP=0
$ IF OPERATION.NES."" THEN $ RESTART="TRUE"
$ GOTO VERIFY_INPUT
$INIT_SOURCE_RECORD:
$ RECORD[0,80]:="MERGE_MASTER"
$ WRITE CHKPNT RECORD
$ !
$ ! Echo the selected input parameters so that the user knows what is
$ ! actually being used.
$ !
$VERIFY_INPUT:
$ OUTPUT "	Source master pack:		",SRC_MASTER
$ OUTPUT "	Destination master pack:	",DST_MASTER
$ OUTPUT "	Destination master pack label:	",DST_LABEL
$ OUTPUT "	Build control file:		",BUILD_FILE
$ IF P5.EQS."ENH" THEN $ OUTPUT "	This is an enhancement merge"
$ IF P5.EQS."BUG" THEN $ OUTPUT "	This is an bug packet merge"
$ IF LOGGING.NES."" THEN $ OUTPUT "	Create and copy logging being done"
$ IF STATS THEN $ OUTPUT "	Statistics will be given"
$ IF NOINIT THEN $ OUTPUT "	Not initializing ",DST_MASTER
$ IF NOSETUP THEN $ OUTPUT "	Initial setup not being done"
$ IF .NOT.RESTART THEN $ GOTO NO_RESTART
$ OUTPUT "	Resuming at label:		",OPERATION
$ IF FIRST_FACILITY.NES."" THEN -
	$ OUTPUT "	Restarting with the ''FIRST_FACILITY' facility"
$ IF RESTART_FIL.NES."" THEN -
	$ OUTPUT "	Restarting with the file:	",RESTART_FIL
$ IF RESTART_DIR.NES."" THEN -
	$ OUTPUT "	Restarting with the directory:	",RESTART_DIR
$NO_RESTART:
$ !
$ ! Initialize the target master pack.
$ !
$ IF FIRST_FACILITY.NES."" THEN $ GOTO JUST_MOUNT
$ IF NOINIT THEN $ GOTO JUST_MOUNT
$ IF BATCH THEN $ GOTO INIT_NOCHECK
$ OUTPUT "It is necessary to initialize the target disk ",DST_MASTER
$INIT_CHECK:
$ INQUIRE ANSWER "Continue (Y/N)"
$ IF ANSWER.EQS."" THEN $ GOTO INIT_CHECK
$ IF .NOT.ANSWER THEN $ GOTO CLEAN_UP
$INIT_NOCHECK:
$ IF F$GETDVI(DST_MASTER,"MNT") THEN $ DISMOUNT/NOUNLOAD 'DST_MASTER'
$ INITIALIZE/GROUP 'DST_MASTER' 'DST_LABEL'
$JUST_MOUNT:
$ IF F$GETDVI(DST_MASTER,"MNT") THEN $ GOTO DST_MOUNTED
$ MOUNT/GROUP 'DST_MASTER' 'DST_LABEL'
$DST_MOUNTED:
$ IF FIRST_FACILITY.NES."" THEN $ GOTO START_COPY
$ IF NOSETUP THEN $ GOTO SETUP_DONE
$ SET PROCESS/NAME=MERGE_SETUP
$ SET ACL/OBJECT=FILE/ACL=(DEFAULT_PROTECTION,SYSTEM:RW,OWNER:RW,GROUP:R,WORLD)/NEW -
	'DST_MASTER'[000000]000000.DIR 'LOGGING'
$ !
$ ! Create a few miscellaneous directories.
$ !
$ ! Because these directories are wired in.  It is essential that the following
$ ! directories created parallel those on the source master pack.
$ !
$ OPEN/WRITE CREFIL SYS$LOGIN:CREATCOPY.COM
$ CLEANUP=CLEANUP.OR.4.OR.8
$ WRITE CREFIL "$ VERIFY='F$VERIFY(0)'"
$ WRITE CREFIL "$ SET NOON"
$ WRITE CREFIL "$ SET DEFAULT ''DST_MASTER'"
$ WRITE CREFIL "$ SET DEFAULT 'P1'"
$ WRITE CREFIL "$ CREATE/DIRECTORY''LOGGING'/OWNER=''BUILD_UIC' ''DST_MASTER''P1'"
$ WRITE CREFIL "$ SET PROCESS/PRIVILEGE=BYPASS"
$ WRITE CREFIL "$ IF F$SEARCH(""''DST_MASTER'*.*"").NES."""" THEN -"
$ WRITE CREFIL "	$ DELETE''LOGGING' ''DST_MASTER'*.*;*"
$ WRITE CREFIL "$ SET PROCESS/PRIVILEGE=NOBYPASS"
$ WRITE CREFIL "$ COPY/EXCLUDE=*.DIR ",LOGGING," ",SRC_MASTER,"*.*; ",DST_MASTER,"*.*;1"
$ WRITE CREFIL "$ SET ON"
$ WRITE CREFIL "$ IF VERIFY THEN $ SET VERIFY"
$ CLOSE CREFIL
$ CLEANUP=CLEANUP.AND.(.NOT.8)
$ @SYS$LOGIN:CREATCOPY [CONSOLE.730]
$ IF F$LOGICAL("STOP_MERGE").NES."" THEN $ GOTO CLEAN_UP
$ @SYS$LOGIN:CREATCOPY [CONSOLE.750]
$ IF F$LOGICAL("STOP_MERGE").NES."" THEN $ GOTO CLEAN_UP
$ @SYS$LOGIN:CREATCOPY [CONSOLE.780]
$ IF F$LOGICAL("STOP_MERGE").NES."" THEN $ GOTO CLEAN_UP
$ @SYS$LOGIN:CREATCOPY [SYSBLDCOM]
$ IF F$LOGICAL("STOP_MERGE").NES."" THEN $ GOTO CLEAN_UP
$ @SYS$LOGIN:CREATCOPY [SYSERR]
$ IF F$LOGICAL("STOP_MERGE").NES."" THEN $ GOTO CLEAN_UP
$ @SYS$LOGIN:CREATCOPY [SYSEXE]
$ IF F$LOGICAL("STOP_MERGE").NES."" THEN $ GOTO CLEAN_UP
$ @SYS$LOGIN:CREATCOPY [SYSHLP]
$ IF F$LOGICAL("STOP_MERGE").NES."" THEN $ GOTO CLEAN_UP
$ @SYS$LOGIN:CREATCOPY [SYSHLP.EXAMPLES]
$ IF F$LOGICAL("STOP_MERGE").NES."" THEN $ GOTO CLEAN_UP
$ @SYS$LOGIN:CREATCOPY [SYSLIB]
$ SET FILE/ENTER='DST_MASTER'[0,0]001001.DIR'LOGGING' 'DST_MASTER'[0,0]SYSLIB.DIR
$ IF F$LOGICAL("STOP_MERGE").NES."" THEN $ GOTO CLEAN_UP
$ @SYS$LOGIN:CREATCOPY [SYSMGR]
$ IF F$LOGICAL("STOP_MERGE").NES."" THEN $ GOTO CLEAN_UP
$ @SYS$LOGIN:CREATCOPY [SYSMSG]
$ SET FILE/ENTER='DST_MASTER'[0,0]001002.DIR'LOGGING' 'DST_MASTER'[0,0]SYSMSG.DIR
$ IF F$LOGICAL("STOP_MERGE").NES."" THEN $ GOTO CLEAN_UP
$ @SYS$LOGIN:CREATCOPY [SYSOBJ]
$ @SYS$LOGIN:CREATCOPY [SYSUPD]
$ IF F$LOGICAL("STOP_MERGE").NES."" THEN $ GOTO CLEAN_UP
$ SET PROCESS/PRIVILEGE=BYPASS
$ DELETE SYS$LOGIN:CREATCOPY.COM;
$ SET PROCESS/PRIVILEGE=NOBYPASS
$ CLEANUP=CLEANUP.AND.(.NOT.4)
$ IF F$LOGICAL("STOP_MERGE").NES."" THEN $ GOTO CLEAN_UP
$ !
$ ! Copy the current versions of the language compilers necessary to do
$ ! the system build.
$ !
$ SET PROCESS/PRIVILEGE=BYPASS
$ IF F$SEARCH(DST_MASTER+"[SYSEXE]BLISS32.EXE").NES."" THEN -
	$ DELETE 'DST_MASTER'[SYSEXE]BLISS32.EXE;*'LOGGING'
$ COPY'LOGGING' SYS$SYSTEM:BLISS32.EXE 'DST_MASTER'[SYSEXE]BLISS32.EXE;1
$ IF F$SEARCH(DST_MASTER+"[SYSEXE]FORTRAN.EXE").NES."" THEN -
	$ DELETE 'DST_MASTER'[SYSEXE]FORTRAN.EXE;*'LOGGING'
$ COPY'LOGGING' SYS$SYSTEM:FORTRAN.EXE 'DST_MASTER'[SYSEXE]FORTRAN.EXE;1
$ IF F$SEARCH(DST_MASTER+"[SYSEXE]MARBLI.EXE").NES."" THEN -
	$ DELETE 'DST_MASTER'[SYSEXE]MARBLI.EXE;*'LOGGING'
$ COPY'LOGGING' SYS$SYSTEM:MARBLI.EXE 'DST_MASTER'[SYSEXE]MARBLI.EXE;1
$ IF F$SEARCH(DST_MASTER+"[SYSEXE]MDL.EXE").NES."" THEN -
	$ DELETE 'DST_MASTER'[SYSEXE]MDL.EXE;*'LOGGING'
$ COPY'LOGGING' SYS$SYSTEM:MDL.EXE 'DST_MASTER'[SYSEXE]MDL.EXE;1
$ IF F$SEARCH(DST_MASTER+"[SYSEXE]PASCAL.EXE").NES."" THEN -
	$ DELETE 'DST_MASTER'[SYSEXE]PASCAL.EXE;*'LOGGING'
$ COPY'LOGGING' SYS$SYSTEM:PASCAL.EXE 'DST_MASTER'[SYSEXE]PASCAL.EXE;1
$ IF F$SEARCH(DST_MASTER+"[SYSEXE]PLIG.EXE").NES."" THEN -
	$ DELETE 'DST_MASTER'[SYSEXE]PLIG.EXE;*'LOGGING'
$ COPY'LOGGING' SYS$SYSTEM:PLIG.EXE 'DST_MASTER'[SYSEXE]PLIG.EXE;1
$ IF F$SEARCH(DST_MASTER+"[SYSEXE]SDL.EXE").NES."" THEN -
	$ DELETE 'DST_MASTER'[SYSEXE]SDL.EXE;*'LOGGING'
$ COPY'LOGGING' SYS$SYSTEM:SDL.EXE 'DST_MASTER'[SYSEXE]SDL.EXE;1
$ IF F$SEARCH(DST_MASTER+"[SYSEXE]CVTMSG.EXE").NES."" THEN -
	$ DELETE 'DST_MASTER'[SYSEXE]CVTMSG.EXE;*'LOGGING'
$ COPY'LOGGING' SYS$SYSTEM:CVTMSG.EXE 'DST_MASTER'[SYSEXE]CVTMSG.EXE;1
$ IF F$SEARCH(DST_MASTER+"[SYSEXE]DCLDIET.EXE").NES."" THEN -
	$ DELETE 'DST_MASTER'[SYSEXE]DCLDIET.EXE;*'LOGGING'
$ COPY'LOGGING' SYS$SYSTEM:DCLDIET.EXE 'DST_MASTER'[SYSEXE]DCLDIET.EXE;1
$ IF F$SEARCH(DST_MASTER+"[SYSEXE]CVTMSG.COM").NES."" THEN -
	$ DELETE 'DST_MASTER'[SYSEXE]CVTMSG.COM;*'LOGGING'
$ COPY'LOGGING' SYS$SYSTEM:CVTMSG.COM 'DST_MASTER'[SYSEXE]CVTMSG.COM;1
$ IF F$SEARCH(DST_MASTER+"[SYSLIB]SDLBLISS.EXE").NES."" THEN -
	$ DELETE 'DST_MASTER'[SYSLIB]SDLBLISS.EXE;*'LOGGING'
$ COPY'LOGGING' SYS$LIBRARY:SDLBLISS.EXE 'DST_MASTER'[SYSLIB]SDLBLISS.EXE;1
$ IF F$SEARCH(DST_MASTER+"[SYSLIB]SDLBLISSF.EXE").NES."" THEN -
	$ DELETE 'DST_MASTER'[SYSLIB]SDLBLISSF.EXE;*'LOGGING'
$ COPY'LOGGING' SYS$LIBRARY:SDLBLISSF.EXE 'DST_MASTER'[SYSLIB]SDLBLISSF.EXE;1
$ IF F$SEARCH(DST_MASTER+"[SYSLIB]SDLFORTRA.EXE").NES."" THEN -
	$ DELETE 'DST_MASTER'[SYSLIB]SDLFORTRA.EXE;*'LOGGING'
$ COPY'LOGGING' SYS$LIBRARY:SDLFORTRA.EXE 'DST_MASTER'[SYSLIB]SDLFORTRA.EXE;1
$ IF F$SEARCH(DST_MASTER+"[SYSLIB]SDLFORTV3.EXE").NES."" THEN -
	$ DELETE 'DST_MASTER'[SYSLIB]SDLFORTV3.EXE;*'LOGGING'
$ COPY'LOGGING' SYS$LIBRARY:SDLFORTV3.EXE 'DST_MASTER'[SYSLIB]SDLFORTV3.EXE;1
$ IF F$SEARCH(DST_MASTER+"[SYSLIB]SDLMACRO.EXE").NES."" THEN -
	$ DELETE 'DST_MASTER'[SYSLIB]SDLMACRO.EXE;*'LOGGING'
$ COPY'LOGGING' SYS$LIBRARY:SDLMACRO.EXE 'DST_MASTER'[SYSLIB]SDLMACRO.EXE;1
$ IF F$SEARCH(DST_MASTER+"[SYSLIB]SDLPASCAL.EXE").NES."" THEN -
	$ DELETE 'DST_MASTER'[SYSLIB]SDLPASCAL.EXE;*'LOGGING'
$ COPY'LOGGING' SYS$LIBRARY:SDLPASCAL.EXE 'DST_MASTER'[SYSLIB]SDLPASCAL.EXE;1
$ IF F$SEARCH(DST_MASTER+"[SYSLIB]SDLPLI.EXE").NES."" THEN -
	$ DELETE 'DST_MASTER'[SYSLIB]SDLPLI.EXE;*'LOGGING'
$ COPY'LOGGING' SYS$LIBRARY:SDLPLI.EXE 'DST_MASTER'[SYSLIB]SDLPLI.EXE;1
$ SET PROCESS/PRIVILEGE=NOBYPASS
$SETUP_DONE:
$ !
$ ! Create the main directory and all needed sub-directories for all the
$ ! facilities specified in the control data file.
$ !
$START_COPY:
$ SET DEFAULT 'DST_MASTER'
$ KEY_QUAL:="/INDEX=1/KEY=""AAINFO """
$NEXT_RECORD:
$ IF F$LOGICAL("STOP_MERGE").NES."" THEN $ GOTO CLEAN_UP
$ READ 'KEY_QUAL' BLDFIL RECORD
$ KEY_QUAL:=""
$ IF F$EDIT(F$EXTRACT(16,16,RECORD),"TRIM").NES."AAINFO" THEN $ GOTO MERGE_DONE
$ FACILITY:='F$EDIT(F$EXTRACT(0,16,RECORD),"TRIM")'
$ IF FIRST_FACILITY.NES."".AND.FIRST_FACILITY.NES.FACILITY THEN $ GOTO NEXT_RECORD
$ FIRST_FACILITY:=""
$ SET DEFAULT ['FACILITY']
$ SET PROCESS/NAME=MERGE_'FACILITY'
$ IF STATS THEN $ SHOW PROCESS/ACCOUNTING
$ !
$ ! Set up the names of the directories of interest for this facility.
$ !
$ IF IGNORE_TYPE.EQS."BUG" THEN $ GOTO SETUP_ENH
$ UPDATE_DIR="["+FACILITY+".BUG]"
$ UPDATE_SRC="["+FACILITY+".BUGSRC]"
$ UPDATE_COM="["+FACILITY+".BUGCOM]"
$ ENTER_SRC="["+FACILITY+".SRC]"
$ ENTER_COM="["+FACILITY+".COM]"
$ GOTO SETUP_DONE
$SETUP_ENH:
$ UPDATE_DIR="["+FACILITY+".ENH]"
$ UPDATE_SRC="["+FACILITY+".SRC]"
$ UPDATE_COM="["+FACILITY+".COM]"
$ ENTER_SRC="["+FACILITY+".BUGSRC]"
$ ENTER_COM="["+FACILITY+".BUGCOM]"
$SETUP_DONE:
$ !
$ ! If this is a restart, continue from where the interruption occurred.
$ ! Otherwise, start from the beginning of the facility.
$ !
$ IF RESTART THEN $ GOTO 'OPERATION'
$CREATE_DIR:
$ RESTART:="FALSE"
$ READ/INDEX=0/KEY="MERGE_MASTER" CHKPNT RECORD
$ RECORD[16,80]:="CREATE_DIR | ''FACILITY' | | | ''CLEANUP'"
$ WRITE/UPDATE CHKPNT RECORD
$ @'SRC_MASTER'[SYSBLDCOM]CREATEDIR MASTER
$ !
$ ! At this point all the necessary directories and sub-directories have
$ ! have been created for a specific facility.  It is now necessary to copy
$ ! all the files for the facility from the original master pack to the new
$ ! master pack applying any update packets found in the desired packet
$ ! sub-directory.
$ !
$COPY_DIR:
$ DIR_FILE=F$SEARCH(SRC_MASTER+"[...]*.DIR",1)
$ IF DIR_FILE.EQS."" THEN $ GOTO ENTER_COM_FILES
$ READ/INDEX=0/KEY="MERGE_MASTER" CHKPNT RECORD
$ RECORD[16,80]:="COPY_DIR | ''FACILITY' | | | ''CLEANUP'"
$ WRITE/UPDATE CHKPNT RECORD
$ IF F$LOGICAL("STOP_MERGE").NES."" THEN $ GOTO CLEAN_UP
$ FILE_NAME=F$PARSE(DIR_FILE,,,"NAME")
$ !
$ ! Check to see if this directory should be ignored.
$ !
$ IF IGNORE_TYPE.NES."BUG" THEN $ GOTO CHECK_ENH
$ IF FILE_NAME.EQS."BUG".OR. -
     FILE_NAME.EQS."BUGCOM".OR. -
     FILE_NAME.EQS."BUGCLD".OR. -
     FILE_NAME.EQS."BUGSRC".OR. -
     FILE_NAME.EQS."ENH" THEN $ GOTO COPY_DIR
$ GOTO CHECK_DONE
$CHECK_ENH:
$ IF IGNORE_TYPE.NES."ENH" THEN $ GOTO CHECK_DONE
$ IF FILE_NAME.EQS."BUG".OR. -
     FILE_NAME.EQS."ENH".OR. -
     FILE_NAME.EQS."COM".OR. -
     FILE_NAME.EQS."SRC" THEN $ GOTO COPY_DIR
$CHECK_DONE:
$ DIR=F$PARSE(DIR_FILE,,,"DIRECTORY")-"]"+"."+FILE_NAME+"]"
$ IF RESTART.AND.RESTART_DIR.NES."".AND.DIR.NES.RESTART_DIR THEN $ GOTO COPY_DIR
$ READ/INDEX=0/KEY="MERGE_MASTER" CHKPNT RECORD
$ RECORD[16,80]:="COPY_DIR | ''FACILITY' | | ''DIR' | ''CLEANUP'"
$ WRITE/UPDATE CHKPNT RECORD
$ IF FILE_NAME.EQS."SRC".OR.FILE_NAME.EQS."BUGSRC" THEN $ GOTO SOURCE_UPDATE
$ RESTART:="FALSE"
$ SET PROCESS/PRIVILEGE=BYPASS
$ IF F$SEARCH(DIR+"*.*;*").NES."" THEN -
	$ DELETE 'LOGGING' 'DST_MASTER''DIR'*.*;*
$ SET PROCESS/PRIVILEGE=NOBYPASS
$ IF F$SEARCH(F$PARSE(DIR_FILE,,,"DIRECTORY")+ -
	      F$PARSE(DIR_FILE,,,"NAME")+".DIR",4).EQS."" THEN -
	$ CREATE/DIRECTORY 'LOGGING' 'DST_MASTER''DIR'
$ IF F$SEARCH(SRC_MASTER+DIR+"*.*;").NES."" THEN -
	$ COPY 'LOGGING' 'SRC_MASTER''DIR'*.*; 'DST_MASTER''DIR'*.*;1
$ GOTO COPY_DIR
$ !
$ ! Loop getting files from the facility source directory.  If a corresponding
$ ! update packet exists, update the source with the packet, directing the
$ ! updated output file to the output disk.  Otherwise, simply copy the file
$ ! from the source directory.
$ !
$SOURCE_UPDATE:
$ UPDATE_COUNT=0
$ COPY_COUNT=0
$ MULTIPLE_COUNT=0
$ IF RESTART THEN $ GOTO UPDATE_LOOP
$ SET PROCESS/PRIVILEGE=BYPASS
$ IF F$SEARCH(DIR+"*.*;*").NES."" THEN $ DELETE 'LOGGING' 'DST_MASTER''DIR'*.*;*
$ SET PROCESS/PRIVILEGE=NOBYPASS
$UPDATE_LOOP:
$ SOURCE_FILE=F$SEARCH(SRC_MASTER+DIR+"*.*;",2)'
$ IF SOURCE_FILE.EQS."" THEN $ GOTO COPY_DIR
$ IF .NOT.RESTART THEN $ GOTO DO_UPDATE
$ IF RESTART_FIL.NES."".AND.SOURCE_FILE.NES.RESTART_FIL THEN $ GOTO UPDATE_LOOP
$ SET PROCESS/PRIVILEGE=BYPASS
$ DELETE 'LOGGING' 'DST_MASTER''DIR''F$PARSE(RESTART_FIL,,,"NAME")''F$PARSE(RESTART_FIL,,,"TYPE")';
$ SET PROCESS/PRIVILEGE=NOBYPASS
$ RESTART="FALSE"
$DO_UPDATE:
$ READ/INDEX=0/KEY="MERGE_MASTER" CHKPNT RECORD
$ RECORD[16,80]:="COPY_DIR | ''FACILITY' | ''SOURCE_FILE' | ''DIR' | ''CLEANUP'"
$ WRITE/UPDATE CHKPNT RECORD
$ FILE_NAME=F$PARSE(SOURCE_FILE,,,"NAME")
$ UPDATE_FILE=F$SEARCH(SRC_MASTER+UPDATE_DIR+FILE_NAME+".UPD",3)'
$ IF UPDATE_FILE.EQS."" THEN $ GOTO DO_COPY
$ !
$ ! Check for more than one source file for the update packet.
$ !
$ COUNT=0
$COUNT_LOOP:
$ TFILE=F$SEARCH(SRC_MASTER+DIR+FILE_NAME+".*;",5)
$ IF TFILE.EQS."" THEN $ GOTO COUNT_DONE
$ COUNT=COUNT+1
$ GOTO COUNT_LOOP
$ !
$ ! If there is more than one source file, skip it and go to the next source
$ ! file.  Otherwise, update the source file with the update packet.
$ !
$COUNT_DONE:
$ IF COUNT.EQ.1 THEN $ GOTO COPY_OR_UPDATE
$ IF F$SEARCH(DST_MASTER+UPDATE_DIR+FILE_NAME+".UPD;",5).NES."" THEN $ GOTO UPDATE_LOOP
$ COPY 'LOGGING' 'UPDATE_FILE' 'DST_MASTER''UPDATE_DIR'*.*;1
$ COPY 'LOGGING' 'SRC_MASTER''DIR''FILE_NAME'.*; 'DST_MASTER''DIR'*.*;1
$ MULTIPLE_COUNT=MULTIPLE_COUNT+1
$ OUTPUT "%SRCMRG-E-MULTIPLESRC, multiple source files for ",UPDATE_FILE
$ OPEN_QUAL="/APPEND"
$ IF F$SEARCH("SYS$LOGIN:FIX_MULTIPLE.COM").EQS."" THEN $ OPEN_QUAL="/WRITE"
$ OPEN 'OPEN_QUAL' FIXUPS SYS$LOGIN:FIX_MULTIPLE.COM
$ CLEANUP=CLEANUP.OR.16
$MULTIPLE_LOOP:
$ TFILE=F$SEARCH(DST_MASTER+DIR+FILE_NAME+".*;",5)
$ IF TFILE.EQS."" THEN $ GOTO MULTIPLE_DONE
$ OUTPUT "-SRCMRG-I-MULTIPLEFIL, source file ",TFILE
$ WRITE FIXUPS "$ EDIT/SUM/OUTPUT=",DST_MASTER,DIR," ",TFILE,"/UPDATE=",UPDATE_FILE
$ GOTO MULTIPLE_LOOP
$MULTIPLE_DONE:
$ CLOSE FIXUPS
$ CLEANUP=CLEANUP.AND.(.NOT.16)
$ GOTO UPDATE_LOOP
$ !
$COPY_OR_UPDATE:
$ UPDATE_COUNT=UPDATE_COUNT+1
$ IF LOGGING.EQS."/LOG" THEN $ SET VERIFY
$ EDIT/SUM/OUTPUT='DST_MASTER''DIR' 'SOURCE_FILE'/UPDATE='UPDATE_FILE'
$ V='F$VERIFY(DBG_VERIFY)'
$ GOTO UPDATE_LOOP
$DO_COPY:
$ COPY_COUNT=COPY_COUNT+1
$ COPY 'LOGGING' 'SOURCE_FILE' 'DST_MASTER''DIR'*.*;1
$ GOTO UPDATE_LOOP
$ !
$ ! Now that the facility has been copied, enter the files in the [.COM] and
$ ! [.SRC] (or [.BUGCOM] and [.BUGSRC]) directories in the corresponding
$ ! [.BUGCOM] and [.BUGSRC] (or [.COM] and [.SRC]) direcories.
$ !
$ENTER_COM_FILES:
$ COM_FILE=F$SEARCH(DST_MASTER+UPDATE_COM+"*.*",6)
$ IF COM_FILE.EQS."" THEN $ GOTO ENTER_SRC_FILES
$ ENTER_FILE=ENTER_COM+F$PARSE(COM_FILE,,,"NAME")+F$PARSE(COM_FILE,,,"TYPE")
$ IF .NOT.RESTART THEN $ GOTO ENTER_COM
$ IF RESTART_FIL.NES.COM_FILE THEN $ GOTO ENTER_COM_FILES
$ SET FILE/REMOVE'LOGGING' 'ENTER_FILE'
$ RESTART="FALSE"
$ENTER_COM:
$ READ/INDEX=0/KEY="MERGE_MASTER" CHKPNT RECORD
$ RECORD[16,80]:="ENTER_COM_FILES | ''FACILITY' | ''COM_FILE' | | ''CLEANUP'"
$ WRITE/UPDATE CHKPNT RECORD
$ SET FILE/ENTER='ENTER_FILE''LOGGING' 'COM_FILE'
$ GOTO ENTER_COM_FILES
$ENTER_SRC_FILES:
$ SRC_FILE=F$SEARCH(DST_MASTER+UPDATE_SRC+"*.*",6)
$ IF SRC_FILE.EQS."" THEN $ GOTO COPY_STATS
$ ENTER_FILE=ENTER_SRC+F$PARSE(SRC_FILE,,,"NAME")+F$PARSE(SRC_FILE,,,"TYPE")
$ IF .NOT.RESTART THEN $ GOTO ENTER_SRC
$ IF RESTART_FIL.NES.SRC_FILE THEN $ GOTO ENTER_SRC_FILES
$ SET FILE/REMOVE'LOGGING' 'ENTER_FILE'
$ RESTART="FALSE"
$ENTER_SRC:
$ READ/INDEX=0/KEY="MERGE_MASTER" CHKPNT RECORD
$ RECORD[16,80]:="ENTER_SRC_FILES | ''FACILITY' | ''SRC_FILE' | | ''CLEANUP'"
$ WRITE/UPDATE CHKPNT RECORD
$ SET FILE/ENTER='ENTER_FILE''LOGGING' 'SRC_FILE'
$ GOTO ENTER_SRC_FILES
$ !
$ ! If statistics are being given, give the statistics for the facility just
$ ! copied.  Otherwise, go get the next record from the build file.
$ !
$COPY_STATS:
$ IF .NOT.STATS THEN $ GOTO NEXT_RECORD
$ OUTPUT F$FAO("	!UL file!%S copied with no update!%S",COPY_COUNT)
$ OUTPUT F$FAO("	!UL file!%S with update packet!%S",UPDATE_COUNT)
$ OUTPUT F$FAO("	!UL file!%S with multiple sources for the update",MULTIPLE_COUNT)
$ GOTO NEXT_RECORD
$ !
$ ! Either some fatal error has occurred or the master pack has been
$ ! successfully copied.  In either case some cleanup is required before
$ ! control may be returned to DCL.
$ !
$MERGE_DONE:
$ IF STATS THEN $ SHOW PROCESS/ACCOUNTING
$ READ/INDEX=0/KEY="MERGE_MASTER" CHKPNT RECORD
$ RECORD[16,80]:="CLEAN_UP | | | | ''CLEANUP'"
$ WRITE/UPDATE CHKPNT RECORD
$CLEAN_UP:
$ SET NOON
$ SET PROCESS/PRIVILEGE=BYPASS
$ IF (CLEANUP.AND.8).NE.0 THEN $ CLOSE CREFIL
$ IF (CLEANUP.AND.4).NE.0 THEN $ DELETE SYS$LOGIN:CREATCOPY.COM;
$ IF (CLEANUP.AND.2).NE.0 THEN $ CLOSE CHKPNT
$ IF (CLEANUP.AND.1).NE.0 THEN $ CLOSE BLDFIL
$ IF F$LOGICAL("STOP_MERGE").NES."" THEN $ DEASSIGN/GROUP STOP_MERGE
$ SET PROCESS/PRIVILEGE=NOBYPASS
$ SET DEFAULT 'OLD_DEV''OLD_DIR'
$ SET UIC 'OLD_UIC'
$ SET ON
$ IF V THEN $ SET VERIFY
