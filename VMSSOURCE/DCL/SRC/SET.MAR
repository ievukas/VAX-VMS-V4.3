	.TITLE	SET - SET PARAMETER DCLS COMMAND EXECUTION
	.IDENT	'V04-000'
 
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;
; SET PARAMETER DCLS COMMAND EXECUTION
;
;	SET DIRECTORY
;	SET PROTECTION
;	SET USER IDENTIFICATION CODE
;	SET VERIFY MODE
;	SET ON
;	SET CONTROL
;	SET PROMPT
;
; D. N. CUTLER 17-APR-77
;
; MODIFIED BY:
;
;	V03-015	HWS0095		Harold Schultz	25-Jul-1984
;		Add support for execute-only command procedures.
;
;	V03-014	HWS0011		Harold Schultz	13-Feb-1984
;		Use PRC_V_CARRCNTL to indicate presence/absence of
;		CR/LF in prompt string.
;		Fix broken branch.
;
;	V03-013	PCG0012		Peter George	12-Oct-1983
;		Fix bug in SET NOON, ON severity, SET ON sequence.
;
;	V03-012	PCG0011		Peter George	18-Aug-1983
;		Change the way that default protection is changed.
;
;	V03-011	KBT0577		Keith B. Thompson	8-Aug-1983
;		Fix a bug in kbt0572
;
;	V03-010	KBT0572		Keith B. Thompson	1-Aug-1983
;		Use $TRNLNM in SET DEFAULT
;
;	V03-009	PCG0010		Peter George	07-Jul-1983
;		Update SET UIC.
;
;	V03-008	PCG0009		Peter George	31-May-1983
;		Reference $RMEDEF.
;
;	V03-007	PCG0008		Peter George	27-May-1983
;		Add image verification.
;
;	V03-006	PCG0007		Peter George	30-Apr-1983
;		Change reference to CRLF.
;
;	V03-005	PCG0006		Peter George	17-Feb-1983
;		Remove reference to $CLIDEFQUALSET.
;		Convert to new table structure.
;
;	V03-004	PCG0005		Peter George	19-Nov-1982
;		Let SET PROMPT with no argument restore the default
;		prompt.
;
;	V03-003	PCG0004		Peter George	28-Oct-1982
;		Add SET PROMPT.
;
;	V03-002	PCG0003		Peter George	22-Oct-1982
;		Fix keyword parsing bug in SET PROTECTION.
;
;	V03-001	PCG0002		Peter George	01-Jul-1982
;		Modify SET CONTROL and SET PROTECTION to interact with 
;		DCL keyword parsing.
;
;---

;
; MACRO LIBRARY CALLS
;
 
	$$CLITABDEF			;TABLE STRUCTURE DEFINITIONS
	WRKDEF				;DEFINE COMMAND WORK AREA
	PRCDEF				;DEFINE PROCESS WORK AREA
	PTRDEF				;DEFINE RESULT PARSE DESCRIPTOR FORMAT
	IDFDEF				;DEFINE INDIRECT FILE DATA STRUCTURE
	$LNMDEF
	$LOGDEF				;LOGICAL NAME DEFINITIONS
	$RMEDEF				;DEFINE RME CONSTANTS
	$PCBDEF				;DEFINE PCB OFFSETS
	$PRVDEF				;PRIVILEGE BIT DEFINITIONS
	$CLIMSGDEF			;DEFINE CLI RELATED ERRORS
 
;
; LOCAL DATA
;
 
	.PSECT	DCL$ZCODE,BYTE,RD,NOWRT
ACCESS:					;ACCESS PROTECTION CODES
	.ASCII	/DEWR/			;
CLASS:					;PROTECTION CLASSES
	.ASCII	/WGOS/			;

TABNAM:	.ASCII	/LNM$FILE_DEV/		; Logical name table to search
	TABNAMSZ=.-TABNAM		;  for device names

DCL$T_DSKNAM::				; String for default device
	.ASCIC	/SYS$DISK/		;

CONTROL_CHARS:				;SET CONTROL CHARACTERS
	.ASCII	/ Y    T                   /

	.SBTTL	SET USER IDENTIFICATION CODE
;+
; DCL$SETUIC - SET USER IDENTIFICATION CODE
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO EXECUTE THE SET USER
; IDENTIFICATION CODE DCLS COMMAND.
;
; INPUTS:
;
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; OUTPUTS:
;
;	THE CURRENT USER IDENTIFICATION CODE IS ESTABLISHED,
;-
 
DCL$SETUIC::				;SET USER IDENTIFICATION CODE
	ADDL	#PTR_C_LENGTH,-		;SKIP OPTION DESCRIPTOR
		WRK_L_RSLNXT(R10)	;
	BSBW	DCL$GETDVAL		;GET THE VALUE OF THE TOKEN DESCRIPTOR

;
; TRANSLATE THE OVERALL STRING.
;
	MOVQ	R1,-(R9)		;PUSH DESCRIPTOR INTO SCRATCH STACK
	PUSHL	R2			;ADDRESS OF STRING IN BUFFER
	PUSHL 	#63			;MAXIMUM STRING TO RETURN
	MOVL	SP,R0			;GET ADDRESS OF OUTPUT DESCRIPTOR
	$TRNLOG_S (R9),(R0),(R0)	;TRANSLATE THE NAME
	MOVQ	(SP)+,R4		;RESET THE RESULTANT STRING DESCRIPTOR

;
; SKIP PAST NODE AND DEVICE NAMES.  FIND START OF DIRECTORY SPECIFICATION.
;
	CLRB	(R5)[R4]		;MARK THE END OF STRING
10$:	LOCC	#^A/:/,R4,(R5)		;LOOK FOR DEVICE NAME DELIMITER
	BEQL	20$			;BRANCH IF NO DEVICE HERE
	SUBL3	#1,R0,R4		;SKIP PAST DEVICE NAME
	MOVAB	1(R1),R5		;
	CMPB	(R1)+,(R1)		;IS THIS A NODE NAME?
	BNEQ	20$			;BR IF ONLY DEVICE
	DECL	R4			;SKIP PAST SECOND COLON
	INCL	R5			;
	BRB	10$			;LOOK FOR MORE NODES OR DEVICE

;
; CONVERT THE DIRECTORY STRING TO A UIC.
;
20$:	BSBB	DCL$CVTUIC		;GET THE UIC
	BLBC	R0,90$			;BRANCH IF ERROR
	MOVL	R1,-(R9)		;SAVE LONGWORD UIC
	$CMKRNL_S B^SETUIC,(R9)		;SET USER IDENTIFICATION CODE
90$:	RSB				;RETURN WITH STATUS

;
; SET USER IDENTIFICATION CODE
;
SETUIC:	.WORD	0			;ENTRY MASK
	MOVL	@#SCH$GL_CURPCB,R0	;GET CURRENT PROCESS PCB ADDRESS
	MOVL	(AP),PCB$L_UIC(R0)	;SET USER IDENTIFICATION CODE
	STATUS	NORMAL			;
	RET				;

	.SBTTL	CONVERT STRING TO LONGWORD UIC
;+
; DCL$CVTUIC - CONVERT STRING TO LONGWORD UIC.
;
; INPUTS:
;
;	R4/R5 = DESCRIPTOR OF UIC STRING
;
; OUTPUTS:
;
;	R0 = STATUS
;	R1 = LONGWORD UIC
;	R2-R5 ARE TRASHED
;-
DCL$CVTUIC::
	DECL	R4			;SKIP LEADING BRACKET
	INCL	R5			;
	MOVQ	R4,-(SP)		;SAVE DIRECTORY DESCRIPTOR
	CLRL	-(SP)			;ALLOCATE LONGWORD FOR UIC
	CMPB	#^A/[/,-1(R5)		;START WITH A BRACKET?
	BEQL	10$			;IF EQL YES
	CMPB	#^A/</,-1(R5)		;START WITH A BRACKET?
	BNEQ	90$			;IF NEQ NO
10$:	MOVL	SP,R3			;SAVE ADDRESS OF UIC LONGWORD
	BSBW	CVTUIC			;CONVERT GROUP NUMBER
	CMPB	#^A/,/,(R5)+		;END WITH A COMMA?
	BNEQ	50$			;IF NEQ NO
	MOVW	R0,2(R3)		;SAVE GROUP NUMBER
	BSBW	CVTUIC			;CONVERT MEMBER NUMBER
	CMPB	#^A/]/,(R5)		;END WITH A BRACKET?
	BEQL	20$			;IF EQL YES
	CMPB	#^A/>/,(R5)		;END WITH A BRACKET?
	BNEQ	50$			;IF NEQ NO
20$:	MOVW	R0,(R3)			;SAVE MEMBER NUMBER
30$:	POPL	R1			;GET UIC NUMBER
	ADDL	#8,SP			;POP UIC DESCRIPTOR
	STATUS	NORMAL			;RETURN SUCCESS
	RSB				;

;
; SIGNAL INVALID UIC SYNTAX
;
90$:	STATUS	INVUIC			;SET INVALID UIC SYNTAX
95$:	ADDL	#12,SP			;RESTORE THE STACK
	RSB				;
 
;
; TAKE UIC APART AND TRY TO CONVERT IT USING $ASCTOID.
;
50$:	MOVQ	4(R3),R4		;GET UIC DESCRPITOR
	LOCC	#^A/,/,R4,(R5)		;LOOK FOR A COMMA
	BEQL	60$			;BRANCH IF NONE
	SUBL	R0,4(R3)		;GET LENGTH OF GROUP NAME	
	DECL	R0			;CREATE DESCRIPTOR OF REST OF UIC
	INCL	R1			;
	MOVQ	R0,R4			;SAVE DESCRIPTOR OF REST OF UIC
	$ASCTOID_S  NAME=4(R3),-	;GET THE GROUP ID
		ID=(R3)			;
	BLBC	R0,95$			;BRANCH IF ERROR
	MOVQ	R4,4(R3)		;SAVE DESCRIPTOR OF REST OF UIC

60$:	LOCC	#^A/]/,R4,(R5)		;LOOK FOR A CLOSING BRACKET
	BNEQ	65$			;BRANCH IF FOUND
	LOCC	#^A/>/,R4,(R5)		;LOOK FOR A CLOSING BRACKET
	BEQL	90$			;BRANCH IF NONE
65$:	SUBL	R0,4(R3)		;GET LENGTH OF MEMBER NAME	
	$ASCTOID_S  NAME=4(R3),-	;GET THE UIC
		ID=(R3)			;
	BLBC	R0,95$			;BRANCH IF ERROR
	BRW	30$			;SET THE UIC

;
; CONVERT ASCII OCTAL UIC COMPONENT TO NUMERIC WORD
;
CVTUIC:	CLRQ	R0			;CLEAR ACCUMULATION AND CHARACTER
10$:	SUBB3	#^A/0/,(R5),R1		;GET NEXT CHARACTER
	BLSS	20$			;IF LSS NOT DIGIT
	CMPL	#8,R1			;OCTAL DIGIT?
	BLEQ	20$			;IF LEQ NO
	MOVAQ	(R1)[R0],R0		;ACCUMULATE RESULT
	INCL	R5			;POINT TO NEXT CHARACTER
	BRB	10$			;
20$:	RSB				;


	.SBTTL	SET DEFAULT DEVICE AND/OR DIRECTORY
;+
; DCL$SETDEFALT - SET DEFAULT DEVICE AND/OR DIRECTORY
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO EXECUTE THE SET DEFAULT
; DCLS COMMAND.
;
; INPUTS:
;
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; OUTPUTS:
;
;	R4,R5 = STRING DESCRIPTOR FOR DIRECTORY PORTION
;	SYS$DISK = DEFAULT DISK
;	THE CURRENT DEFAULT DIRECTORY IS ESTABLISHED.
;-

MAX_TRANS_LVLS = 10			; maximum translation levels allowed
 
;
; LNM service buffer offsets from R8
;

Q_LOGNAM	= 0			; Logical name descriptor
Q_TABLE		= 8			; Table name descriptor
L_ATTR		= 16			; Attributes longword
L_MAX_INDEX	= 20			; Max Index
W_STRING_LEN	= 24			; String length
T_STRING_BUF	= 28			; String buffer
S_XLT_BUF 	= 284			; Output buffer size


DCL$SETDEFALT::				; SET DEFAULT
	ADDL2	#PTR_C_LENGTH,-		; skip option descriptor
		WRK_L_RSLNXT(R10)	;
	BSBW	DCL$GETDVAL		; <R1,R2> = token

;
; Translate the overall string to get 1 level of translation
;

	MOVL	#MAX_TRANS_LVLS,AP	; set max translation counter
	SUBL2	#S_XLT_BUF,R9		; allocate buffer
	MOVL	R9,R8			; save addr of buffer

;
; Create item list for $TRNLNM
;

	CLRQ	-(R9)			; clear last longword and length addr
	MOVAL	L_ATTR(R8),-(R9)	; set up attributes item
	MOVL	#<LNM$_ATTRIBUTES@16>+4,-;
		-(R9)			;
	MOVAW	W_STRING_LEN(R8),-(R9)	; string size goes here
	MOVAB	T_STRING_BUF(R8),-(R9)	; string buffer	
	MOVL	#<LNM$_STRING@16>+255,-	;
		-(R9)			;
	CLRL	-(R9)			; no output size
	MOVAL	L_MAX_INDEX(R8),-(R9)	; max index here
	MOVL	#<LNM$_MAX_INDEX@16>+4,-;
		-(R9)			;
	MOVZBL	#TABNAMSZ,Q_TABLE(R8)	; create descriptor of logical name
	MOVAB	TABNAM,Q_TABLE+4(R8)	;  table to look in
	MOVQ	R1,Q_LOGNAM(R8)		; set up logical name
	$TRNLNM_S -			; translate the logical name
		TABNAM=Q_TABLE(R8),-	;
		LOGNAM=Q_LOGNAM(R8),-	;
		ITMLST=(R9)		;
	CMPW	R0,#SS$_NORMAL		; success?
	BEQL	10$			; yes
	CMPW	R0,#SS$_NOLOGNAM	; no translation?
	BEQL	15$			; yes
	RSB				; error

;
; Check if there was a really a translation, was it a search list
; and if it was a concealed device.
;

10$:	TSTL	L_MAX_INDEX(R8)		; was there a real non-search list name
	BGTR	20$			; branch if >0, search list
	BLSS	15$			; branch if <0, null translation
	BBS	#LNM$V_CONCEALED,-	; ignore if translation concealed
		L_ATTR(R8),20$		;
	MOVZWL	W_STRING_LEN(R8),-	; set result string length
		Q_LOGNAM(R8)		;
	MOVC3	W_STRING_LEN(R8),-	; copy translation into the buffer
		T_STRING_BUF(R8),-	;  where the original token use to be
		@Q_LOGNAM+4(R8)		;
15$:	MOVQ	Q_LOGNAM(R8),R4		; setup string descriptor
	BRB	40$			; parse string

;
; We could not use the translation because of concealed name or search list
; so use the original input string
;

20$:	MOVQ	Q_LOGNAM(R8),R4		; get source descriptor

;
; Make sure the last character is a ":" so it acts like a device name
;

	CMPB	-1(R5)[R4],#^A':'	; is last char a colon?
	BEQL	40$			; continue if so
	MOVB	#^A':',(R5)[R4]		; append a colon if not
	INCL	R4			; count it as well

;
; Locate the device portion of the string, include any node names found as well
;

40$:	CLRB	(R5)[R4]		; mark end of string
	LOCC	#^A/:/,R4,(R5)		; look for device name delimiter
	BEQL	70$			; branch if no device here
	CMPB	(R1)+,(R1)		; is this a node name?
	BNEQ	60$			; branch if only device
	MOVAB	1(R1),R3		; set address of end of node string
	SUBL	#2,R0			;  and length of remainder
	LOCC	#^A/:/,R0,(R3)		; see if device name is here
	BEQL	50$			; branch if none, just use node
	MOVAB	1(R1),R3		; set end of device name
50$:	MOVL	R3,R1			; set end of equivalence name for disk
60$:	MOVL	R5,R2			; save start of device string
	MOVL	R1,R5			; set start of directory string
	SUBL	R2,R1			; find length of device name
	SUBL	R1,R4			; adjust directory string length

;
; At this point: <R1,R2> = device (+node)
;		 <R4,R5> = rest of string
;
; Check if the device portion = 'SYS$DISK', if so ignore it
;

	MOVAB	DCL$T_DSKNAM,R7		; address of device name counted string
	MOVZBL	(R7)+,R6		; get length and address of first byte
	SUBL3	R6,R1,R0		; find difference in name string sizes
	DECL	R0			; check if 1 byte difference(the colon!)
	BNEQ	80$			; br if no-can't be the special name
	PUSHR	#^M<R1,R2>		; save registers to be used
	CMPC3	R6,(R2),(R7)		; check for reserved system name
	POPR	#^M<R1,R2>		; restore values
70$:	BNEQ	80$			; branch if no device name assignment
	BRW	130$			;  needed

;
; If the device portion has a translation and it contains a
; directory specification, then repeat using the translation
; if a directory was specified in addition, then report an error
; that 2 directory specifications appeared in the same string
;

80$:	DECL	R1			; do not send colon into trnlnm
	MOVQ	R1,Q_LOGNAM(R8)		; set up logical name
	$TRNLNM_S -			; translate the logical name
		TABNAM=Q_TABLE(R8),-	;
		LOGNAM=Q_LOGNAM(R8),-	;
		ITMLST=(R9)		;
	CMPW	R0,#SS$_NORMAL		; success?
	BEQL	90$			; yes
	CMPW	R0,#SS$_NOLOGNAM	; no translation?
	BEQL	120$			; yes
	RSB				; error

90$:	TSTL	L_MAX_INDEX(R8)		; branch if no translation or
	BNEQ	120$			;  search list
	BBS	#LNM$V_CONCEALED,-	;  or concealed
		L_ATTR(R8),120$
	LOCC	#^A/[/,W_STRING_LEN(R8),-; is there a directory in there?
		T_STRING_BUF(R8)	;
	BNEQ	95$			; ignore unless device/dir translation
	LOCC	#^A/</,W_STRING_LEN(R8),-; is there a directory in there?
		T_STRING_BUF(R8)	;
	BEQL	120$			; ignore unless device/dir translation
95$:	TSTL	R4			; any directory specified explicitly?
	BNEQ	100$			; if so, then error in specification

	MOVZWL	W_STRING_LEN(R8),-	; set result string length
		Q_LOGNAM(R8)		;
	MOVC3	W_STRING_LEN(R8),-	; copy translation into the buffer
		T_STRING_BUF(R8),-	;  where the original token use to be
		@Q_LOGNAM+4(R8)		;
	MOVQ	Q_LOGNAM(R8),R4		; setup string descriptor
	SOBGTR	AP,110$			; limit translation levels
100$:	STATUS	DIRECT			; error in directory specification
	RSB
110$:	BRW	40$			; continue translation device portion

120$:	MOVQ	Q_LOGNAM(R8),R1		; restore device portion descriptor
	INCL	R1			; restore colon to end of string

;
; Create/update the logical name sys$disk which holds the current
; default disk device.
;

	PUSHR	#^M<R1,R2,R6,R7>	; descriptors for logical and equivalence name
	PUSHL	#0			; access mode is defaulted
	PUSHAQ	4(SP)			; address of equivalence name desc
	PUSHAQ	16(SP)			; descriptor of name to relate with
	PUSHL	#LOG$C_PROCESS		; table number
	CALLS	#8,@#SYS$CRELOG		; clear descriptor on return
	BLBC	R0,150$			; branch if error creating name

;
; Change the default directory specification (if any);
;

130$:	TSTL	R4			; any directory field
	BEQL	140$			; branch if no
	PUSHR	#^M<R4,R5>		; descriptor for directory name
	CLRQ	-(SP)			; zeros as arguments 2 & 3
	PUSHAB	8(SP)			; address of directory string
	CALLS	#5,G^SYS$SETDDIR	; set the default directory
	BLBC	R0,150$			; branch if error from rms
140$:	STATUS	NORMAL			; assume all is aok
150$:	RSB


	.SBTTL	SET PROTECTION
;+
; DCL$SETPROT - SET PROTECTION
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO EXECUTE THE SET PROTECTION
; DCLS COMMAND.
;
; INPUTS:
;
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; OUTPUTS:
;
;	THE CURRENT DEFAULT PROTECTION IS ESTABLISHED.
;-
 
DCL$SETPROT::				;SET PROTECTION
	CLRL	-(SP)			;WHERE TO RETURN PROTECTION
	MOVL	SP,-(SP)		;NOTE WHERE PROTECTION IS TO BE PUT
	CLRL	-(SP)			;DON'T WANT TO SET PROTECTION
	CALLS	#2,@#SYS$SETDFPROT	;GET DEFAULT PROTECTION
	MOVL	(SP)+,R9		;COPY PROTECTION TO USEFUL REG
	ADDL	#2*PTR_C_LENGTH,-	;SKIP PAST OPTION DESCRIPTOR
		WRK_L_RSLNXT(R10)	; AND /DEFAULT QUALIFIER
10$:	BSBW	DCL$GETDVAL		;GET NEXT DESCRIPTOR VALUES
	CMPB	#PTR_K_PARAMETR,R5	;PARAMETER VALUE?
	BNEQ	40$			;IF NEQ NO
	LOCC	(R2),#4,CLASS		;LOCATE PROTECTION CLASS
	BEQL	60$			;IF EQL INVALID CLASS
	DECL	R0			;CALCULATE STARTING BIT NUMBER
	MULL3	#4,R0,R8		;
	INSV	#^XF,R8,#4,R9		;START WITH NO ACCESS
	CMPB	#PTR_K_COLON,R4		;PROTECTION VALUE SPECIFIED?
	BNEQ	10$			;IF NEQ NO
	BSBW	DCL$GETDVAL		;GET PROTECTION VALUE DESCRIPTOR
	MOVL	R1,R7			;SAVE LENGTH OF VALUE STRING
20$:	LOCC	(R2)+,#4,ACCESS		;LOCATE PROTECTION CODE
	BEQL	50$			;IF EQL INVALID PROTECTION CODE
	DECL	R0			;CALCULATE RELATIVE BIT NUMBER IN FIELD
	ADDL	R8,R0			;CALCULATE ACTUAL BIT NUMBER
	BBCC	R0,R9,30$		;ALLOW SPECIFIED ACCESS
30$:	SOBGTR	R7,20$			;ANY MORE TO SCAN?
	BRB	10$			;
40$:	PUSHL	R9			;SET NEW DEFAULT PROTECTION ARGUMENT
	CLRL	-(SP)			;ZERO ADDRESS OF RETURN DESCRIPTOR
	PUSHAL	4(SP)			;ADDRESS OF NEW PROTECTION
	CALLS	#3,@#SYS$SETDFPROT	;SET DEFAULT PROTECTION
	RSB				;
50$:	STATUS	IVPROT			;SET INVALID PROCTECTION CODE
	RSB				;
60$:	STATUS	IVKEYW			;SET INVALID KEYWORD
	RSB				;

	.SBTTL	SET VERIFY MODE
;+
; DCL$SETVERIFY - SET VERIFY MODE
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO EXECUTE THE SET VERIFY
; MODE DCLS COMMAND.
;
; INPUTS:
;
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; OUTPUTS:
;
;	THE VERIFY MODE IS ESTABLISHED.
;-
 
DCL$SETVERIFY::					;SET VERIFY MODE

;
; PARSE THE COMMAND.
;
	BSBW	DCL$GETDVAL			;GET OPTION DESCRIPTOR
	BLBC	R3,10$				;IF LBC VERIFICATION SPECIFIED
	CLRL	R6				;DISABLE ALL VERIFICATION
	BRB	40$				;IGNORE ANY KEYWORDS
10$:	MOVL	#3,R6				;ASSUME ALL VERIFICATION IS SPECIFIED
	BSBW	DCL$GETDVAL			;GET KEYWORD DESCRIPTOR
	CMPL	#PTR_K_ENDLINE,R5		;EOL?
	BEQL	40$				;YES, THEN SET SPECIFIED MODES
	MOVL	#15,R6				;ASSUME NO KEYWORDS ARE SPECIFIED
20$:	CMPB	#^A/P/,(R2)			;IS FIRST CHAR "P"?
	BEQL	25$				;YES, THEN PROCESS "PROCEDURE"
	CMPB	#^A/P/,2(R2)			;IS THIRD CHAR "P"?
	BNEQ	30$				;NO, THEN PROCESS "IMAGE"
25$:	BICL	#8,R6				;INDICATE "PROCEDURE" SEEN
	BISL	#2,R6				;ENABLE PROCEDURE VERIFICATION
	BLBC	R3,35$				;IF LBC PROCEDURE VERIFY SPECIFIED
	BICL	#2,R6				;DISABLE PROCEDURE VERIFICATION
	BRB	35$				;GET NEXT
30$:	BICL	#4,R6				;INDICATE "IMAGE" SEEN
	BISL	#1,R6				;ENABLE IMAGE VERIFICATION
	BLBC	R3,35$				;IF LBC IMAGE VERIFY SPECIFIED
	BICL	#1,R6				;DISABLE IMAGE VERIFICATION
35$:	BSBW	DCL$GETDVAL			;GET KEYWORD DESCRIPTOR
	CMPL	#PTR_K_ENDLINE,R5		;EOL?
	BEQL	40$				;YES, THEN SET SPECIFIED MODES
	BRB	20$				;GET NEXT

;
; UPDATE PROCEDURE VERIFICATION STATE.
;
40$:	BBS	#3,R6,50$			;BRANCH IF "PROC" NOT SPECIFIED
	BISW	#PRC_M_VERIFY,PRC_W_FLAGS(R11) 	;ASSUME VERIFICATION IS SPECIFIED
	BBS	#1,R6,50$			;BRANCH IF SO
	BICW	#PRC_M_VERIFY,PRC_W_FLAGS(R11) 	;DISABLE VERIFICATION
50$:	BBC	#2,R6,60$			;BRANCH IF "IMAGE" SPECIFIED
	STATUS	NORMAL				;SET STATUS
	RSB					;RETURN

	.SBTTL	SET IMAGE VERIFY MODE
;+
; DCL$SETVERIFY_IMAGE - SET IMAGE VERIFY MODE
;
; THIS ROUTINE IS CALLED TO SET IMAGE VERIFY MODE.
;
; INPUTS:
;
;	R6 = IMAGE VERIFY FLAGS, LBC MEANS CLEAR, LBS MEANS SET
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; OUTPUTS:
;
;	THE IMAGE VERIFY MODE IS ESTABLISHED.
;-

60$:
DCL$SETVERIFY_IMAGE::				;SET IMAGE VERIFY MODE
;
; GET INPUT STREAM INFORMATION.
;
	MOVL	PRC_L_INDFAB(R11),R1		;GET ADDRESS OF GENERIC FAB
	MOVL	PRC_L_IDFLNK(R11),R2		;GET ADDR OF CURRENT IND FRAME
	MOVW	IDF_W_INPIFI(R2),FAB$W_IFI(R1)	;GET INPUT IFI

;
; UPDATE IMAGE VERIFICATION STATE BOTH IN PRC AND FOR CURRENT INPUT STREAM.
;
	BLBC	R6,70$				;BRANCH IF /NOIMAGE
	BBS	#PRC_V_VERIMAGE,-		;IF IMAGE VERIFY ALREADY SET, 
		PRC_B_FLAGS2(R11),90$		;  THEN DONE
	BISW	#PRC_M_VERIMAGE,PRC_B_FLAGS2(R11);ENABLE IMAGE VERIFICATION
	BRB	80$				;EXECUTE $MODIFY

70$:	BBC	#PRC_V_VERIMAGE,-		;IF IMAGE VERIFY ALREADY CLEAR,
		PRC_B_FLAGS2(R11),90$		;  THEN DONE
	BICW	#PRC_M_VERIMAGE,PRC_B_FLAGS2(R11);DISABLE IMAGE VERIFICATION

80$:	BSBB	DCL$VERIFY_IMAGE		;ENABLE OR DISABLE VERIFICATION
	BLBC	R0,95$				;RETURN ERROR STATUS

90$:	STATUS	NORMAL				;RETURN SUCCESS
95$:	RSB					;

	.SBTTL	MODIFY INPUT STREAM CHARACTERISTICS
;++
; DCL$VERIFY_IMAGE - MODIFY THE INPUT STREAM CHARACTERISTICS.
;
; INPUTS:
;
;	R1 = INPUT FAB
;	R11 = ADDRESS OF PRC DATA STRUCTURE
;
; OUTPUTS:
;
;	R0 = STATUS
;--

DCL$VERIFY_IMAGE::
	TSTB	PRC_B_EXONLYL(R11)		;ARE WE IN EXE-ONLY MODE?
	BNEQ	90$				;YES, DON'T DO ANYTHING.

	BBS	#PRC_V_MODE,PRC_W_FLAGS(R11),10$;BRANCH IF NOT INTERACTIVE
	MOVL	#1,R0				;ASSUME SUCCESS
	TSTL	PRC_L_INDEPTH(R11)		;BRANCH IF LEVEL 0
	BEQL	90$				;
10$:	MOVW	#RME$C_PPFECHO,FAB$L_CTX(R1)	;SET TYPE CODE
	CLRW	FAB$L_CTX+2(R1)			;ZERO ISI VALUE
	BBC	#PRC_V_VERIMAGE,-		;IF IMAGE VERIFY SET,
		PRC_B_FLAGS2(R11),20$		;  THEN SET THE ISI
	MOVL	PRC_L_INDOUTRAB(R11),R0		;GET ADDR OF OUTPUT RAB
	MOVW	RAB$W_ISI(R0),-			;SET OUTPUT ISI
		FAB$L_CTX+2(R1)			;
20$:	PUSHL	R1				;SAVE R1
	BISL	#FAB$M_ESC,FAB$L_FOP(R1)	;SET ESC BIT IN FOP
	$MODIFY	FAB=(R1)			;MODIFY THE INPUT STREAM
	POPL	R1				;RESTORE R1
	BICL	#FAB$M_ESC,FAB$L_FOP(R1)	;CLEAR ESC BIT IN FOP
	CLRL	FAB$L_CTX(R1)			;
90$:	RSB					;RETURN STATUS

	.SBTTL	SET ON MODE
;+
; DCL$SETON - SET ON MODE
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO EXECUTE THE SET ON
; MODE DCLS COMMAND.
;
; INPUTS:
;
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; OUTPUTS:
;
;	THE ON MODE IS ESTABLISHED.
;-
 
DCL$SETON::				;SET ON MODE
	BSBW	DCL$GETDVAL		;GET THE DESCRIPTOR FOR "ON"
	STATUS	NORMAL			;SET NORMAL COMPLETION STATUS
	MOVAB	PRC_W_ONLEVEL(R11),R1	;GET ADDRESS OF ON LEVEL CODE
	CMPB	#8,(R1)			;CHECK "ON" LEVEL FOR RESERVED LEVEL
	BLBS	R3,20$			;BR IF OPTION WAS NEGATED (NOON)
	BGTR	10$			;BR IF "ON" ALREADY ACTIVE
	MOVB	1(R1),(R1)		;RESET TO SAVED VALUE
10$:	RSB				;
20$:	BEQL	30$			;BR IF "ON" ALREADY AT RESEVED LEVEL
	MOVB	(R1),1(R1)		;SAVE PREVIOUS "ON" LEVEL
	MOVB	#8,(R1)			;SET TO RESERVED LEVEL
30$:	RSB				;END OF NOON HANDLING

	.SBTTL	SET CONTROL ENABLE/DISABLE
;+
; DCL$SETCTLY - SET CONTROL MODE
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO EXECUTE THE SET CONTROL=KEY
; MODE DCLS COMMAND.
;
; INPUTS:
;
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; OUTPUTS:
;
;	CONTROL Y AND OUT-OF-BAND AST'S ARE ENABLED OR DISABLED FOR THIS 
;	PROCESS.
;-
DCL$SETCTLY::				;SET CONTROL MODE
	CLRL	-(SP)			;ALLOCATE CHAR MASK ON STACK
	BSBW	DCL$GETDVAL		;GET OPTION DESCRIPTOR
	ASSUME	PTR_V_NEGATE EQ 20
	MOVL	R3,R6			;SAVE [NO] STATUS FOR FUTURE USE

	BSBW	DCL$GETDVAL		;GET FIRST LETTER
	CMPB	R5,#PTR_K_ENDLINE	;END OF LINE?
	BNEQ	30$			;IF YES, THEN ASSUME Y
	BSBB	CTRLY			;OTHERWISE, SET CONTROL_Y BY DEFAULT
	BRB	80$			;ALL DONE

30$:	LOCC	(R2),#26,CONTROL_CHARS	;GET INDEX OF LETTER
	BBSS	R0,(SP),40$		;SET CHAR BIT IN MASK
40$:	BSBW	DCL$GETDVAL		;GET NEXT PARAMETER
	CMPB	R5,#PTR_K_ENDLINE	;END OF LINE?
	BNEQ	30$			;LOOP IF NOT
	
50$:	BISL3	(SP),PRC_L_OUTOFBAND(R11),R1	;GET CHARACTER MASK
	BLBC	R6,70$			;IF LBC, THEN ENABLE SPECIFIED
	BBC	#PRC_V_CTRLY,(SP),60$	;IF NOT CTRL/Y, THEN SKIP
	BSBB	CTRLY			;DO SPECIAL CTRL/Y PROCESSING
60$:	BICL3	(SP),PRC_L_OUTOFBAND(R11),R1      ;SET MASK FOR DISABLE
70$:	JSB	DCL$RESETOOB		;ENABLE/DISABLE APPROPRIATE AST ROUTINES
	
80$:	MOVL	(SP)+,R0		;RESTORE STACK
	STATUS	NORMAL			;SET NORMAL COMPLETION STATUS
	RSB				;

CTRLY:	BISL	#PRC_M_CTRLY,PRC_L_OUTOFBAND(R11)  ;ASSUME ENABLE SPECIFIED
	BLBC	R6,10$			;IF LBC, THEN ENABLE SPECIFED
	BICL	#PRC_M_CTRLY,PRC_L_OUTOFBAND(R11)  ;CLEAR CTRL/Y BIT IN MASK
	BSBW	W^DCL$ONCTLYRST		;RESET CONTROL Y COMMAND TEXT
10$:	RSB


	.SBTTL	SET PROMPT
;+
; DCL$SETPROMPT - SET PROMPT
;
; THIS ROUTINE IS CALLED AS AN INTERNAL COMMAND TO EXECUTE THE SET PROMPT
; DCLS COMMAND.
;
; INPUTS:
;
;	R8 = ADDRESS OF SCRATCH BUFFER DESCRIPTOR.
;	R9 = ADDRESS OF SCRATCH STACK.
;	R10 = BASE ADDRESS OF COMMAND WORK AREA.
;	R11 = BASE ADDRESS OF PROCESS WORK AREA.
;
; OUTPUTS:
;
;	THE DCL PROMPT STRING IS CHANGED.
;-
DCL$SETPROMPT::				;SET PROMPT
	MOVW	DCL$CRLF,PRC_W_PMPTCTRL(R11);ASSUME /CONTROL
	SETBIT	PRC_V_CARRCNTL,PRC_W_FLAGS(R11)  ;SET CR/LF FLAG
	BSBW	DCL$GETDVAL		;GET FIRST TOKEN
	CMPB	R5,#PTR_K_COMDQUAL	;/[NO]CONTROL QUALIFIER?
	BNEQ	20$			;NO, THEN BRANCH	
	ASSUME	PTR_V_NEGATE EQ 20	;
	BLBC	R3,10$			;BRANCH IF NOT NEGATED	
	CLRW	PRC_W_PMPTCTRL(R11)	;SET NOCONTROL
	CLRBIT	PRC_V_CARRCNTL,PRC_W_FLAGS(R11)  ;INDICATE NO CR/LF
10$:	BSBW	DCL$GETDVAL		;GET "PROMPT" TOKEN
20$:	BSBW	DCL$GETDVAL		;GET PROMPT STRING
	CMPB	R5,#PTR_K_ENDLINE	;IF PRESENT
	BNEQ	30$			;THEN RESET THE PROMPT
	MOVL	DCL$T_PROMPT,-		;ELSE RESTORE THE DEFAULT
		PRC_B_CONTINUE(R11)	;
	MOVB	#DCL$C_PROMPTLEN,-	;
		PRC_B_PROMPTLEN(R11)	;
	BRB	80$			;DONE
30$:	MOVL	#CLI$_STRTOOLNG,R0	;ASSUME STRING IS TOO LONG
	CMPL	R1,#ENT_K_MAX_PROMPT	;IS IT TOO LONG?
	BGTRU	90$			;YES, THEN ERROR
	ASSUME	ENT_K_MAX_PROMPT LT 256	;
	ADDB3	#3,R1,-			;SAVE LENGTH OF PROMPT
		PRC_B_PROMPTLEN(R11)	;
	MOVC3	R1,(R2),PRC_G_PROMPT(R11) ;SAVE PROMPT STRING
80$:	STATUS	NORMAL			;RETURN NORMAL STATUS
90$:	RSB

	.END
 
