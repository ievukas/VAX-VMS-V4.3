MODULE VMOUNT (
		LANGUAGE (BLISS32),
		ADDRESSING_MODE (NONEXTERNAL = LONG_RELATIVE),
		IDENT = 'V04-002'
		) =
BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************

!++
!
! FACILITY:  MOUNT Utility Structure Levels 1 & 2
!
! ABSTRACT:
!
! 	This is the main routine of the MOUNT utility. It provides the
!	general control flow of the MOUNT command and contains most of
!	the base data structures.
!
! ENVIRONMENT:
!
!	STARLET operating system, including privileged system services
!	and internal exec routines.
!
!--
!
!
! AUTHOR:  Andrew C. Goldstein,	 CREATION DATE:  5-Sep-1977  16:58
!
! MODIFIED BY:
!
!	V04-002	HH0056		Hai Huang		10-Sep-1984
!		Suppress outputting VOLINV error messages during
!		VOLINV retries.
!
!	V04-001	HH0055		Hai Huang		06-Sep-1984
!		Send mount/cluster requests with operator assist
!		disabled.
!
!	V03-035	CDS0005		Christian D. Saether	29-Aug-1984
!		Call STAND_ALONE_REBUILD routine which will
!		only do rebuild if necessary at that time.
!
!	V03-034	HH0043		Hai Huang		07-Aug-1984
!		Wait a while before retrying IOC$SEARCH.
!
!	V03-033	HH0042		Hai Huang		27-Jul-1984
!		Clear the global lock storage area during run time.
!
!	V03-032	HH0041		Hai Huang		24-Jul-1984
!		Remove REQUIRE 'LIBD$:[VMSLIB.OBJ]MOUNTMSG.B32'.
!
!	V03-031	HH0037		Hai Huang		12-Jul-1984
!		Make the label lock node-specific, i.e. make the CSID
!		part of the label lock.
!
!	V03-030	HH0036		Hai Huang		11-Jul-1984
!		Send the mount request cluster wide even if the volume
!		is already mounted on the local node.
!
!	V03-029	HH0034		Hai Huang		09-Jul-1984
!		Add yet another interlock to serialize shared mounts.
!
!	V03-028	HH0032		Hai Huang		05-Jul-1984
!		For private mounts, transfer device ownership to the top
!		level process in the process tree.
!
!	V03-027	HH0024		Hai Huang		18-Jun-1984
!		Do not call IOC$LOCK_DEV to test mode of the device lock,
!		as this routine could corrupt the lock value block.
!
!	V03-026	HH0021		Hai Huang		14-May-1984
!		Refine HH0019 to mark the device as allocated after 
!		IOC$SEARCH while holding the I/O database mutex. Also,
!		reject private mounts if IOC$SEARCH failed.
!
!	V03-025	HH0019		Hai Huang		07-May-1984
!		Properly interlock simultaneous mounts in a cluster-
!		environment.
!
!	V03-024	HH0016		Hai Huang		23-Apr-1984
!		Get the device name if IOC$SEARCH failed.
!
!	V03-023	HH0015		Hai Huang		20-Apr-1984
!		Get IOC$SEARCH to return the lock value block of the
!		device lock.
!
!	V03-022	HH0010		Hai Huang		30-Mar-1984
!		Fix generic mount.
!
!	V03-021	HH0004		Hai Huang		09-Mar-1984
!		Add cluster-wide mount support.
!
!	V03-020	HH0002		Hai Huang		02-Feb-1984
!		Add job-wide mount support.
!
!	V03-019	ACG0369		Andrew C. Goldstein,	8-Nov-1983  11:24
!		Don't issue IO$_AVAILABLE on mount failure of mounted disk
!
!	V03-018	CDS0004		Christian D. Saether	13-Sep-1983
!		Only clear VALID for tapes in the main error handler.
!		Move the CLEAR_VALID routine here from RDHOME as it
!		is only referenced here now.
!
!	V03-017	TCM0003		Trudy C. Matthews	07-Sep-1983
!		When converting the exclusive device lock to a shared lock,
!		make sure it is still system-owned.
!
!	V03-016	TCM0002		Trudy C. Matthews	01-Sep-1983
!		Make allocating a device followed by mounting a shared
!		volume on that device work correctly (i.e. deallocate
!		the device and convert the lock to CR mode).
!
!	V03-015	CDS0003		Christian D. Saether	 5-Aug-1983
!		Add cluster consistency checking routines.
!		Add status block to GETDVIW call so that wait
!		always works correctly.
!
!	V03-014	CDS0002		Christian D. Saether	 3-Aug-1983
!		Remove the device ref count check prior to assigning
!		the channel (from tcm0001) as it was racy.
!
!	V03-013	STJ3015		Steven T. Jeffreys	30-Jul-1983
!		Fix link-time truncation error.
!
!	V03-012	TCM0001		Trudy C. Matthews	28-Jul-1983
!		Re-write the MOUNT_VOLUME routine so that it uses a
!		mount interlock rather than temporarily allocating the
!		volume.  Also ensure that cluster-wide locks are taken
!		out in the appropriate mode (EX for private mounts and
!		CR for shared mounts).
!
!	V03-011	STJ3113		Steven T. Jeffreys,	26-Jul-1983
!		Moved ACTIVATE_JOURNAL and helper routines to their own
!		module, RUJMAN.
!
!	V03-010	STJ3111		Steven T. Jeffreys,	18-Jul-1983
!		When the privileges are amplified, take pains to include
!		those privileges that are in the second longword of the
!		privilege mask, notably PRMJNL privilege.
!
!	V03-009	DMW4045		DMWalp			 7-Jun-1983
!		Remove (S)LOG_Entry
!
!	V03-008	CDS0001		Christian D. Saether	28-May-1983
!		Tolerate allocation failure for F11B mounts.
!
!	V03-007	STJ3102		Steven T. Jeffreys,	25-May-1983
!		- Add call to $CREJNL.
!
!	V03-006	MMD0115		Meg Dumont,	29-Mar-1983  0:39
!		Add OPT_OVR_VOLO to override options set
!
!	V03-005	STJ3061		Steven T. Jeffreys,	08-Mar-1983
!		- Grant user PSWAPM privilege.  Needed to create ACP.
!
!	V03-004	STJ50311	Steven T. Jeffreys,	11-Feb-1983
!		- Make all uses of PHYS_NAME indexed by DEVICE_INDEX
!		- Ensure DEVICE_INDEX is not reset on retry
!		- Remove references to  FIRST_CHANNEL.
!		- Make CALLERS_ACMOD a global cell containing the
!		  caller's access mode.
!		- Changed device allocation/deallocation logic.
!		  Moved routine DEALLOCATE_DEVICE to ASSIST.
!
!	V03-003	STJ3037		Steven T. Jeffreys,	14-Oct-1982
!		If the mount attempt fails, free up the drive(s) via
!		an IO$_AVAILABLE $qio.
!
!	V03-002	KTA0103		Kerbey T. Altmann	29-Jun-1982
!		Change a register to NOPRESERVE in DEALLOCATE_DEVICE.
!
!	V03-001	STJ0252		Steven T. Jeffreys,	03-Apr-1982
!		- Allocate devices in the access mode of the caller.
!		- Check allocation return status and terminate the mount
!		  attempt if the specified device does not exist.
!		- Manually deallocate shared disk volumes after
!		  they are mounted.  This is necessitated by a
!		  change to $DALLOC such that mounted volumes may
!		  no longer be deallocated.
!
!	V02-020	STJ0229		Steven T. Jeffreys,	01-Mar-1982
!		- Set inhibit message bit in the exit status code
!		  if the message text was written via $PUTMSG.
!
!	V02-019	STJ0190		Steven T. Jeffreys,	02-Feb-1982
!		- Zero OWN and GLOBAL storage to guaranty restartablity.
!
!	V02-018	STJ0170		Steven T. Jeffreys,	13-Jan-1982
!		More work for $MOUNT support.
!
!	V02-017	RNG0001		Rod N. Gamache		05-Jan-1982
!		Declare MOUNT_OPTIONS to be external.
!
!	V02-016	STJ0161		Steven T. Jeffreys,	04-Jan-1982
!		Changed OPT_OVERLOCK to OPT_OVR_LOCK.  Do not print
!		messages if OPT_MESSAGE is not set.
!
!	V02-015	ACG0246		Andrew C. Goldstein,	4-Jan-1982  15:21
!		Add /OVER:LOCK
!
!	V02-014	STJ0149		Stevem T. Jeffreys	02-Jan-1981
!		Extensive rewrite to support the $MOUNT system service.
!
!	V02-013	STJ0089		Steven T. Jeffreys	09-Aug-1981
!		Reset mount options at the beginning of each attempt
!		to mount a volume.
!
!	V02-012 DMW0008		David Michael Walp	10-Jun-1981
!		Liberal re-write to facilitate operator assisted mount
!		work for tapes.
!
!	V0111	STJ0005		Steven T. Jeffreys,	9-Oct-1980
!		Liberal re-write to facilitate operator assisted mount.
!
!	V0110	ACG0125		Andrew C. Goldstein,	23-Jan-1980  14:57
!		Init USER_STATUS cell for correct header error reporting
!
!	V0109	ACG0123		Andrew C. Goldstein,	17-Jan-1980  20:33
!		Complete integration of disk rebuild
!
!	V0108	RIH0051		Richard I. Hustvedt,	13-Jan-1979 14:33
!		Add call to rebuild bitmaps and quota file on volume mount.
!
!	V0107	ACG0079		Andrew C. Goldstein,	5-Nov-1979  13:53
!		Structures for file ID and extent cacheing
!
!	V0106	ACG0072		Andrew C. Goldstein,	15-Oct-1979  16:12
!		Check primary and secondary device characteristics
!
!	V0105	ACG0069		Andrew C. Goldstein,	8-Oct-1979  18:32
!		Remove device data table
!
!	V0104	ACG0044		Andrew C. Goldstein,  18-Jun-1979  16:15
!	Add disk quota support
!
!	V0103	ACG21786	Andrew C. Goldstein,  2-Feb-1979  14:19
!	Fix home block scan loop limit conditional
!
!	V0102	ACG0013		Andrew C. Goldstein,  5-Jan-1979  13:52
!	Don't clear valid bit on failure on already mounted volume
!
!	V0101	ACG0003		Andrew C. Goldstein,  27-Nov-1978  17:48
!	Add multi-volume support for disk
!
!	V0100	ACG00001	Andrew C. Goldstein,  10-Oct-1978  19:56
!	Previous revision history moved to [MOUNT.SRC]MOUNT.REV
!**


LIBRARY 'SYS$LIBRARY:LIB.L32';
REQUIRE 'SRC$:MOUDEF.B32';
REQUIRE 'LIBD$:[VMSLIB.OBJ]INITMSG.REQ';


FORWARD ROUTINE
	SYS$VMOUNT,			! entry point (w/o operator assist)
	VMOUNT_ENVELOPE,		! base call frame for MOUNT_VOLUME
	REBUILD_ENVELOPE,		! base call frame for REBUILD
	INTERCEPT_SIGNAL,		! Intercept EXEC mode signal
	MOUNT_VOLUME,			! Mount a given volume
	MAIN_HANDLER,			! main condition handler
	FORCE_DISMOUNT,			! dismount a volume just mounted
	CLEAR_VALID,			! Clear VALID flag in UCB.
	DALLOC_SHR_DEV,			! deallocate device for shared mount
	XFER_DEV_OWNER,			! transfer device ownership
	MOUNT_CLUSTER,			! cluster-wide mount
	MOUNT_ENCIPHER,			! create a cluster-mount packet
	SEARCH_DEVICE,			! generic device search/allocate routine
	DEQ_MOUNT_LOCK	: NOVALUE,	! dequeue the mount lock
	WAIT_DELTA	: NOVALUE;	! wait before IOC$SEARCH retry


!+
!
! Own storage for general use in the MOUNT utility
! Note that DATA_BASE_READY and STORED_CONTEXT initialzed
! in the module ASSIST.
!
!-

GLOBAL
	VMOUNT_GBL_START: VECTOR [0],	! Mark start of global storage
	STORED_CONTEXT	: BITVECTOR [32],! store the context of some 1 time only
	DATA_BASE_READY	: LONG,		! Boolean
	DEV_ALLOCATED	: BITVECTOR [DEVMAX] VOLATILE,  !Indicates which physical devices are allocated
	DEV_ACQUIRED	: BITVECTOR [DEVMAX] VOLATILE,
					! Indicates which devices have been
					! interlocked.
	LOCK_STATUS	: VECTOR [2],	! Lock status block for $ENQ.
	CLEANUP_ALLOC	: BITVECTOR [DEVMAX] VOLATILE,	!Indicates which physical devices need to be deallocated
	CLEANUP_FLAGS	: BITVECTOR [32] VOLATILE, ! error cleanup status flags
	CHANNEL		: LONG VOLATILE,! channel number for I/O
	DEVICE_INDEX	: LONG VOLATILE,! Index into device list
	MAILBOX_CHANNEL,		! channel number of ACP termination mailbox
	CALLERS_ACMOD	: LONG,		! caller's access mode
	PHYS_COUNT,			! number of physical devices in use
	PHYS_NAME	: VECTOR [DEVMAX*2],	! descriptor of physical device name
	NAME_BUFFER	: VECTOR [NAMEBUF_LEN*DEVMAX, BYTE],
					! string buffer for physical device name
	LOG_BUFFER	: VECTOR [63, BYTE],
					! buffer to construct logical name
	HOME_BLOCK	: BBLOCK [512],	! buffer for volume header label or home block
	DEVICE_CHAR	: BBLOCK [DIB$K_LENGTH],
					! buffer for device characteristics
	DEVICE_CHAR2	: BBLOCK [DIB$K_LENGTH],
					! buffer for sec. device characteristics
	HOMEBLOCK_LBN,			! LBN of home block read
	HEADER_LBN,			! LBN of file header read
	CURRENT_RVN,			! RVN of disk being mounted
	USER_STATUS	: VECTOR [2],	! status return for various routines
	CURRENT_VCB	: REF BBLOCK,	! address of VCB used by CHECK_HEADER2
	REAL_MVL	: REF BBLOCK,	! address of MVL allocated for mag tape volume
	REAL_RVT	: REF BBLOCK,	! address of RVT allocated for mag tape volume
	REAL_VCB	: REF BBLOCK,	! address of VCB allocated for volume
	REAL_VCA	: REF BBLOCK,	! address of cache block allocated for vol.
	REAL_FCB	: REF BBLOCK,	! address of FCB allocated for volume
	REAL_WCB	: REF BBLOCK,	! address of window allocated for volume
	REAL_AQB	: REF BBLOCK,	! address of AQB allocated for volume
	MTL_ENTRY	: REF BBLOCK,	! address of mounted volume list entry
	SMTL_ENTRY	: REF BBLOCK,	! address of volume set MTL
	MOUNT_ITMLST,			! address of the mount item list
	LABLCK_STATUS	: VECTOR [2],	! label lock status
	VMOUNT_GBL_END	: VECTOR [0];	! Mark end of GLOBAL storage


GLOBAL BIND
	VOL1 		= HOME_BLOCK;	! BUFFER FOR VOL1 MAGNETIC TAPE LABEL

GLOBAL
	ALLDEVNAM_BUF	: VECTOR [NAMEBUF_LEN, BYTE]
			  INITIAL (BYTE ('MOU$',
					 REP NAMEBUF_LEN-4 OF (' '))),
					! string buffer for alloc class devnam
	ALLDEVNAM_DESC	: VECTOR [2] INITIAL (0, ALLDEVNAM_BUF),
					! descriptor for alloc class devnam
	DEVCHAR_DESC	: VECTOR [2] INITIAL (DIB$K_LENGTH, DEVICE_CHAR),
					! descriptor for device characteristics
	DEVCHAR_DESC2	: VECTOR [2] INITIAL (DIB$K_LENGTH, DEVICE_CHAR2),
					! descriptor for sec. device characteristics

	LABLCKNAM_BUF	: VECTOR [NAMEBUF_LEN+4, BYTE]
			  INITIAL (BYTE ('MOU$', 
					 REP NAMEBUF_LEN OF (' '))),
					! label lock name buffer
	LABLCKNAM_DESC	: VECTOR [2, LONG]
			  INITIAL (0, LABLCKNAM_BUF);
					! label lock descriptor


GLOBAL ROUTINE SYS$VMOUNT (ITEM_LIST) =
!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This is the main routine of the MOUNT utility.
!
! CALLING SEQUENCE:
!	$MOUNT (arglist)
!
! INPUT PARAMETERS:
!	ITEM_LIST	: Address of a $GETJPI-like item list
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	assorted status values
!
! SIDE EFFECTS:
!	volume(s) mounted, device data base updated
!
!--

BEGIN

BUILTIN
	MOVPSL,					! Get current PSL
	CALLG,					! Used to call CHECK_PARAMS
	AP;					! Used to pass params to CHECK_PARAMS

EXTERNAL ROUTINE
	ACTIVATE_JOURNAL: ADDRESSING_MODE (GENERAL),	! activate RUJ
	$DALLOC_DEVS$U	: ADDRESSING_MODE (GENERAL),
	CHECK_PARAMS;				! Process the user-supplied parameters

EXTERNAL
	DEVICE_COUNT	: ADDRESSING_MODE (GENERAL) 
			  LONG, 		! Number of devices specified
	LCK_GLOBAL_START: ADDRESSING_MODE (GENERAL),
						! Start of global lock area
	LCK_GLOBAL_END	: ADDRESSING_MODE (GENERAL);
						! End of global lock area

LOCAL
	!
	! Declare the privileges that are necessary for MOUNT to work.
	!
	CURRENT_PSL	: BBLOCK [4],		! holds current PSL 
	MOUNT_PRIVS	: BBLOCK [8],		! Amplified privilege mask
	USER_PRIVS	: BBLOCK [8],		! Temp storage for privilege mask
	STATUS;					! system service status


CHANNEL	      = 0;
USER_STATUS   = 1;

MOUNT_PRIVS   =  (1^$BITPOSITION (PRV$V_ACNT)	OR		! Amplified privilege mask
		  1^$BITPOSITION (PRV$V_ALTPRI)	OR
		  1^$BITPOSITION (PRV$V_BUGCHK)	OR
		  1^$BITPOSITION (PRV$V_BYPASS)	OR
		  1^$BITPOSITION (PRV$V_DETACH)	OR
		  1^$BITPOSITION (PRV$V_EXQUOTA)OR
		  1^$BITPOSITION (PRV$V_GROUP)	OR
		  1^$BITPOSITION (PRV$V_MOUNT)	OR
		  1^$BITPOSITION (PRV$V_PHY_IO)	OR
		  1^$BITPOSITION (PRV$V_PSWAPM)	OR
		  1^$BITPOSITION (PRV$V_TMPMBX)	OR
		  1^$BITPOSITION (PRV$V_SETPRV)	OR
		  1^$BITPOSITION (PRV$V_SYSLCK)	OR
		  1^$BITPOSITION (PRV$V_WORLD)
		 );
MOUNT_PRIVS[PRV$V_PRMJNL] = 1;			! PRMJNL is in the 2nd longword

! Process the user-supplied parameters, if
! we haven't already.  The conditional call
! is to save the overhead of having to do it
! for each attempt at a mount, and to make
! sure that it is done at least once.
!

IF NOT .DATA_BASE_READY
THEN
    BEGIN
    CH$FILL (0, VMOUNT_GBL_END-VMOUNT_GBL_START, VMOUNT_GBL_START);
    CH$FILL (0, LCK_GLOBAL_END-LCK_GLOBAL_START, LCK_GLOBAL_START);
    MOUNT_ITMLST  = .ITEM_LIST;
    DATA_BASE_READY = 1;
    IF NOT (STATUS = CALLG (.AP, CHECK_PARAMS))
    THEN
	RETURN (.STATUS);
    MOVPSL (CURRENT_PSL);
    CALLERS_ACMOD = .CURRENT_PSL [PSL$V_PRVMOD];
    END;

! Save the current privilege mask and grant the
! caller the necessary privileges.
!

$SETPRV (ENBFLG=1, PRVADR=MOUNT_PRIVS, PRVPRV=USER_PRIVS);

! Loop for all devices in the command line to mount multiple disks and tapes.
! However, it is necessary to reset DEVICE_INDEX for tape mounts because tape
! volumes are not mounted until every volume in the command line has been
! processed, and an error condition on the Nth volume will force all the work
! done on previous volumes to be undone.
!

IF (.DEVICE_INDEX GTR 0) AND .STORED_CONTEXT[TAPE_MOUNT]
THEN
    DEVICE_INDEX = 0;

INCR I FROM .DEVICE_INDEX TO .DEVICE_COUNT-1
DO
    BEGIN
    !
    ! Mount the volume.  If the attempt failed, abort the mount
    ! and return the error status.  Always dequeue the mount interlock(s),
    ! no matter if the mount attempt succeeded or failed.
    !
    STATUS = VMOUNT_ENVELOPE ();
    KERNEL_CALL ( DEQ_MOUNT_LOCK );
    IF .LABLCK_STATUS [1] NEQ 0			! Dequeue the label lock if it exists
    THEN 					!   
	$DEQ ( LKID = .LABLCK_STATUS [1] );

    IF NOT .STATUS
    THEN
	BEGIN 
	$SETPRV (ENBFLG=0, PRVADR=MOUNT_PRIVS);	! Clear granted privileges
	$SETPRV (ENBFLG=1, PRVADR=USER_PRIVS);	! Restore old privileges
	RETURN (.STATUS);
	END;
    DEVICE_INDEX = .DEVICE_INDEX+1;
    END;
    
!
! Deallocate all devices that are not mounted.
!
$DALLOC_DEVS$U (0);

!
! Rebuild volume if mounting files-11 ODS-2 disk
!

IF .CLEANUP_FLAGS[CLF_REBUILD]
THEN
    BEGIN
    STATUS = REBUILD_ENVELOPE ();
    $DASSGN (CHAN   = .CHANNEL);		! Deassign channel used by REBUILD
    END;

!
! If the rebuild was successful, attempt to activate the RUJ.
!
IF .STATUS
THEN
    STATUS = ACTIVATE_JOURNAL ();

!
! If the mount was successful, sent this mount request cluster-wide
! when appropriate.
!
IF .STATUS
THEN
    STATUS = MOUNT_CLUSTER (.ITEM_LIST);	! Mount cluster-wide

! Revoke any privileges that were granted.
!

$SETPRV (ENBFLG=0, PRVADR=MOUNT_PRIVS);		! Clear granted privileges
$SETPRV (ENBFLG=1, PRVADR=USER_PRIVS);		! Restore old privileges

RETURN (.STATUS)

END;						! end of routine MOUNT_COMMAND

ROUTINE VMOUNT_ENVELOPE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine serves as the base call frame for all the EXEC
!	mode code, and provides a convenient (and necessary) spot
!	from which to intercept all EXEC mode conditions.
!
! CALLING SEQUENCE:
!
!	This routine should be called in EXEC mode.
!
! INPUT:
!
!	None.
!
! OUTPUT:
!
!	None.
!
! IMPLICIT INPUTS:
!
!	Current mode is EXEC, DEVICE_INDEX contains an integer value.
!
! ROUTINE VALUE:
!
!	This routine returns the status returned by MOUNT_VOLUME.
!
!--

BEGIN

LOCAL
	STATUS;

!
! Establish the special EXEC mode condition handler.
!
ENABLE	INTERCEPT_SIGNAL;

!
! Attempt to mount the volume.
!
STATUS = MOUNT_VOLUME (.DEVICE_INDEX);

RETURN (.STATUS)

END;

ROUTINE REBUILD_ENVELOPE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine serves as the base call frame for all the EXEC
!	mode code, and provides a convenient (and necessary) spot
!	from which to intercept all EXEC mode conditions.
!
! CALLING SEQUENCE:
!
!	This routine should be called in EXEC mode.
!
! INPUT:
!
!	None.
!
! OUTPUT:
!
!	None.
!
! IMPLICIT INPUTS:
!
!	Current mode is EXEC, DEVICE_INDEX contains an integer value.
!
! ROUTINE VALUE:
!
!	This routine returns the status returned by MOUNT_VOLUME.
!
!--

BEGIN

EXTERNAL ROUTINE
	STAND_ALONE_REBUILD;		! Rebuild quota file and bitmaps (ODS2)

LOCAL
	STATUS;

!
! Establish the special EXEC mode condition handler.
!
ENABLE	INTERCEPT_SIGNAL;

    !
    ! Rebuild the volume.
    !
    ERR_MESSAGE (MOUN$_REBUILD);
    STATUS = $ASSIGN (DEVNAM = PHYS_NAME[0],
		      CHAN   = CHANNEL);
    IF NOT .STATUS THEN ERR_EXIT (.STATUS);
    STAND_ALONE_REBUILD (.CHANNEL);

RETURN 1

END;

ROUTINE INTERCEPT_SIGNAL (SIGNAL, MECHANISM) =

!++
! Functional Description:
!
!	This routine is a conditon handler whose sole
!	reason for existence is to force the primary
!	conditon code's facility-code to that of the
!	MOUNT facility.
!
! Input:
!
!	SIGNAL    = Address of the signal array
!	MECHANISM = Address of the mechanism array
!
! Output:
!
!	The condition facility code is equal to MOUN$_FACILITY
!--

BEGIN						! Start of INTERCEPT_SIGNAL

MAP

	SIGNAL		: REF BBLOCK,		! Signal array
	MECHANISM	: REF BBLOCK;		! Mechanism array

EXTERNAL

	MOUNT_OPTIONS	: ADDRESSING_MODE (GENERAL)
			  BITVECTOR VOLATILE,	! parser option flags
	USER_STATUS	: VECTOR,		! Status return of some routines
	VOLINV_COUNT	: ADDRESSING_MODE (GENERAL);
						! VOLINV retry counter

EXTERNAL LITERAL
	VOLINV_LIMIT;				! VOLINV retry limit


IF .SIGNAL[CHF$L_SIG_NAME] NEQ SS$_UNWIND
THEN
    BEGIN
    !
    ! Make the facility code MOUN$_FCILITY.
    !
    IF .BBLOCK [SIGNAL[CHF$L_SIG_NAME], STS$V_FAC_NO] EQL 0
    OR .BBLOCK [SIGNAL[CHF$L_SIG_NAME], STS$V_FAC_NO] EQL INIT$_FACILITY
    THEN
	BBLOCK [SIGNAL[CHF$L_SIG_NAME], STS$V_FAC_NO] = MOUN$_FACILITY;

    IF .BBLOCK [SIGNAL[CHF$L_SIG_NAME], STS$V_MSG_NO] EQL 0
    THEN
	BBLOCK [SIGNAL[CHF$L_SIG_NAME], STS$V_MSG_NO] = .USER_STATUS [0] ^ (-$BITPOSITION (STS$V_MSG_NO));

    !
    ! If the caller requested it, print the message text associated with the
    ! message.  Also make sure that the particular error is not covered by
    ! operator assisted mount.  If it is, do not print the message.
    !
    IF (.MOUNT_OPTIONS [OPT_MESSAGE] AND NOT (.MOUNT_OPTIONS [OPT_ASSIST]
    AND (SELECTONEU (.SIGNAL [CHF$L_SIG_NAME] AND STS$M_MSG_NO) OF
	     SET
	     [SS$_DEVALLOC	AND STS$M_MSG_NO] : 1;
	     [SS$_MEDOFL	AND STS$M_MSG_NO] : 1;
	     [SS$_VOLINV	AND STS$M_MSG_NO] : 1;
	     [SS$_NODEVAVL	AND STS$M_MSG_NO] : 1;
	     [SS$_NOSUCHDEV	AND STS$M_MSG_NO] : 1;
	     [SS$_INCVOLLABEL	AND STS$M_MSG_NO] : 1;
	     [OTHERWISE]			  : 0;
	     TES)))

    !
    ! If mounting with /NOASSIST and we are in VOLINV retry, supress outputting
    ! the VOLINV error message unless this is the last retry attempt. 
    !
    AND (.MOUNT_OPTIONS [OPT_MESSAGE] AND NOT (NOT .MOUNT_OPTIONS [OPT_ASSIST]
    AND (SELECTONEU (.SIGNAL [CHF$L_SIG_NAME] AND STS$M_MSG_NO) OF
	     SET
	     [SS$_VOLINV AND STS$M_MSG_NO] : IF .VOLINV_COUNT LSS VOLINV_LIMIT-1
					     THEN
						1
					     ELSE
						0;

	     [OTHERWISE]		   : 0;
	     TES)))
    THEN
	BEGIN
	SIGNAL [CHF$L_SIG_ARGS] = .SIGNAL [CHF$L_SIG_ARGS] - 2;
	$PUTMSG (MSGVEC = SIGNAL [CHF$L_SIG_ARGS], ACTRTN=0, FACNAM=0);
	SIGNAL [CHF$L_SIG_ARGS] = .SIGNAL [CHF$L_SIG_ARGS] + 2;
	BBLOCK [SIGNAL [CHF$L_SIG_NAME], STS$V_INHIB_MSG] = 1;
	END;

    !
    ! If the condition severity code is SEVERE or ERROR, then unwind the
    ! stack back to the caller of the frame that established this handler.
    ! Return the condition code in R0.
    !
    IF .BBLOCK [SIGNAL [CHF$L_SIG_NAME], STS$V_SEVERITY] EQL STS$K_SEVERE
    OR .BBLOCK [SIGNAL [CHF$L_SIG_NAME], STS$V_SEVERITY] EQL STS$K_ERROR
    THEN
	BEGIN
	MECHANISM [CHF$L_MCH_SAVR0] = .SIGNAL [CHF$L_SIG_NAME];
	$UNWIND ();
	END;
    END;

!
! Attempt to continue the operation.
!
RETURN (SS$_CONTINUE);

END;						! End of INTERCEPT_SIGNAL

ROUTINE MOUNT_VOLUME (J) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine will mount a single disk or tape volume.
!
! CALLING SEQUENCE:
!
!	mount_volume (.j)
!
! INPUT:
!
!	J : Index into device list.
!
! OUTPUT:
!
!	None.
!
! IMPLICIT INPUT:
!
!	Mount data base
!
! IMPLICIT OUTPUT:
!
!	None.
!
! ROUTINE VALUE:
!
!	Assorted status codes.
!
! SIDE EFFECTS:
!
!	Volume mounted, device data base updated.
!--

BEGIN

LOCAL
	DEVICE_ITMLST1	: BBLOCK [(1 * 12) + 4] INITIAL
			!
			! item: allocation class plus device name
			!
			(WORD (NAMEBUF_LEN-4),
			 WORD (DVI$_ALLDEVNAM),
			 LONG (ALLDEVNAM_BUF+4),
			 LONG (ALLDEVNAM_DESC),
			!
			! end of list
			!
			 LONG (0)),
	P,					! string scan pointer
	STATUS;					! system service status

EXTERNAL
	DEV_CTX		: BBLOCK FIELD (DC),	! device value block context fields
	MOUNT_FAILED	: ADDRESSING_MODE (GENERAL) LONG VOLATILE,	! State of the current mount
	MOUNT_OPTIONS	: ADDRESSING_MODE (GENERAL) BITVECTOR VOLATILE,	! parser option flags
	DEVICE_COUNT	: ADDRESSING_MODE (GENERAL), ! number of devices specified
	LABEL_COUNT	: ADDRESSING_MODE (GENERAL), ! number of volume labels specified
	DEVICE_STRING	: ADDRESSING_MODE (GENERAL) VECTOR VOLATILE,	! device name string descriptor
	LABEL_STRING	: ADDRESSING_MODE (GENERAL) VECTOR VOLATILE;	! volume label string descriptor

EXTERNAL ROUTINE

	SEARCH_VOL,			! search I/O database for volume
	TRAN_LOGNAME,			! translate logical name
	READ_VOLLABEL,			! read magtape volume header label
	READ_HOMEBLOCK,			! read disk home block
	MOUNT_TAPE,			! mount magtape
	MOUNT_DISK1,			! mount level 1 disk
	MOUNT_DISK2,			! mount level 1 disk
	GET_DEVICE_CONTEXT;		! get device lock value block context

BIND
	OPTIONS		= MOUNT_OPTIONS : VECTOR VOLATILE;


ENABLE MAIN_HANDLER;			! Enable the MOUNT condition handler

!
! Reset the mount options bit mask.
!

OPTIONS[0] = .OPTIONS[0] AND NOT RESET_OPTIONS1;
OPTIONS[1] = .OPTIONS[1] AND NOT RESET_OPTIONS2;
MOUNT_FAILED  = 1;

BEGIN
!
! rebind things to make life easier ( so we see them as their
! real logical units)
!
MAP
    DEVICE_STRING   : BBLOCKVECTOR [ DEVMAX, 8 ],
    NAME_BUFFER	    : BBLOCKVECTOR [ DEVMAX, NAMEBUF_LEN ],
    PHYS_NAME	    : BBLOCKVECTOR [ DEVMAX, 8 ];

!
! Start of buffer
!
MACRO   STADR   = 0,0,0,0%;

!
! Define descriptor vector displacements
!
MACRO   LEN	= 0,0,32,0%;
MACRO   ADDR    = 4,0,32,0%;
MACRO	ILEN	= 8,0,32,0%;	! Item list returned length position.


!
! If the device is being mounted /SHARE, /GROUP, or /SYSTEM, search the
! device database for a  matching volume label.  To properly  serialize
! simultaneous shared mounts, take out the label lock in EX mode.  This
! label lock will be released in routine  SYS$VMOUNT when everything is 
! done.
!
STATUS = 0;
IF NOT .MOUNT_OPTIONS [OPT_NOSHARE]
THEN 
    BEGIN

    !
    ! The label lock has the form  MOU$-csid-vollabel. The csid part makes
    ! the label lock node-specific, which is necessary to avoid potential
    ! deadlocks in a cluster.  If the node is not in a cluster, the csid
    ! field is set to zero.
    !
    LOCAL
	CSID		: LONG INITIAL (0),	! Initialize to zero 	
	SYI_ITMLST	: BLOCK  [(1*12)+4, BYTE] INITIAL
			( WORD (4),		! Return buffer length
		 	  WORD (SYI$_NODE_CSID),! CSID item code
			  LONG (CSID),		! Reuturn buffer address
			  LONG (0),
			  LONG (0));

    $GETSYIW ( EFN = MOUNT_EFN,			! Get CSID of the local node
	      ITMLST = SYI_ITMLST );

    !
    ! Set up the label lock resource name and descriptor
    !
    LABLCKNAM_DESC [0] = .LABEL_STRING [.J*2] + 8; ! 'MOU$' prefix +  CSID
    LABLCKNAM_BUF + 4  = .CSID;			! Merge in CSID
    CH$COPY  (	.LABEL_STRING [.J*2],		! Length of input string
		.LABEL_STRING [.J*2+1],		! Address of label string buffer
		0,				!
		.LABEL_STRING [.J*2],		! Length of output string
		LABLCKNAM_BUF + 8  );		! Address of output buffer

    $ENQW  (  LKMODE = LCK$K_EXMODE,		! Take out the label lock 
		LKSB = LABLCK_STATUS,		
	       FLAGS = LCK$M_SYSTEM,
	      RESNAM = LABLCKNAM_DESC,
		 EFN = MOUNT_EFN,
	      ACMODE = PSL$C_EXEC  );
    
    STATUS = KERNEL_CALL (SEARCH_VOL, LABEL_STRING[.J*2]);
    END;

!
! The SEARCH_VOL routine will only return success if this is a /SHARE
! mount and a matching volume label is found.  It will signal an error
! if this is a /SYSTEM or /GROUP mount and a duplicate volume label is
! already in use.
!
IF .STATUS
    !
    ! A successful /SHARE mount.  Just print the message here; we rejoin
    ! the "volume not found" path much later in the routine.
    !
    THEN ERR_MESSAGE (MOUN$_MOUNTED, 3, .LABEL_STRING[.J*2],
			.LABEL_STRING[.J*2+1], PHYS_NAME[.J, LEN])

    ELSE 
	IF .STATUS GTRU 7
	    THEN ERR_EXIT (.STATUS)
	    ELSE

!
! Volume not found: either not there or this is a /NOSHARE mount.
! We must go through the mechanics of mounting the device.
!
BEGIN

!
! The following block of code should not be re-executed if this routine
! is called a second time by operator-assisted mount code.
!
IF NOT .DEV_ACQUIRED[.J]
THEN 
    BEGIN

    LOCAL
	STSBLK	: VECTOR [2];

    !
    ! Call the SEARCH_DEVICE routine to search for a mountable device,
    ! allocate it, and set up the physical device name and descriptor
    ! in mount database.  Note that if the device is available cluster-
    ! wide, SEARCH_DEVICE will take out an EX mode lock for a private 
    ! mount, or a PW mode lock for a shared mount.
    !
    IF NOT .DEV_ALLOCATED [.J]
    THEN 
	BEGIN
	STATUS = KERNEL_CALL (SEARCH_DEVICE, .J);

	!
	! If the device does not exists, disable operator assist before 
	! exiting with the error status.
	!
	! Otherwise, indicate that this device has been allocated.
	! If the device was not previously allocated, indicate such.
	! If the mount fails, these devices must be deallocated.
	!
	IF NOT .STATUS
	THEN 
	    BEGIN
	    IF ((.STATUS AND STS$M_MSG_NO) EQL (SS$_NOSUCHDEV AND STS$M_MSG_NO))
	    OR ((.STATUS AND STS$M_MSG_NO) EQL (SS$_IVDEVNAM  AND STS$M_MSG_NO))
	    THEN 
		MOUNT_OPTIONS [OPT_ASSIST] = 0;
	    ERR_EXIT (.STATUS);
	    END;
	IF .STATUS NEQ SS$_DEVALRALLOC
	THEN 
	    BEGIN
	    CLEANUP_FLAGS [CLF_DEALLOCATE] = 1;
	    CLEANUP_ALLOC [.J] = 1;
	    END;
	DEV_ALLOCATED [.J] = 1;
	END;					! End device search/allocation block

    !
    ! Set the PHYS_NAME high-water mark.
    !
    PHYS_COUNT = .J + 1;

    END		! End of code that shouldn't be executed more than once
		! per device.

ELSE

    BEGIN

    ! Take out a lock on the allocation class device name.  This will
    ! interlock all mounts of this device.
    !
    STATUS = $ENQW (LKMODE = LCK$K_EXMODE,
  	       	      LKSB = LOCK_STATUS,
		     FLAGS = LCK$M_SYSTEM,
		    RESNAM = ALLDEVNAM_DESC,
		       EFN = MOUNT_EFN,
		    ACMODE = PSL$C_EXEC);
    IF NOT .STATUS THEN ERR_EXIT (.STATUS);

    END;

!
! The remainder of the code is executed each time this routine is called by
! ASSIST if an operator-assisted mount is required.
!
DEV_ACQUIRED[.J] = 1;

!
! Get a channel to it.  If this is a cluster accessible device,
! a device lock will be taken out by this node on the device.
!

STATUS = $ASSIGN (DEVNAM = PHYS_NAME[.J,LEN],
		    CHAN = CHANNEL);
IF NOT .STATUS THEN ERR_EXIT (.STATUS);

!
! Get the device characteristics and do device type validation: Make sure
! the device is mountable at all, and check that the mount qualifiers are
! consistent with the device type. A mismatch between primary and secondary
! device characteristics indicates a spooled device or something else strange.
! Reject such.
!

$GETCHN (CHAN = .CHANNEL, PRIBUF = DEVCHAR_DESC, SCDBUF = DEVCHAR_DESC2);

IF CH$NEQ (DIB$K_LENGTH, DEVICE_CHAR, DIB$K_LENGTH, DEVICE_CHAR2, 0)
    OR NOT .DEVICE_CHAR[DEV$V_FOD]
    THEN ERR_EXIT (SS$_NOTFILEDEV);

IF NOT .DEVICE_CHAR[DEV$V_AVL] THEN ERR_EXIT (SS$_DEVOFFLINE);

IF .DEVICE_CHAR[DEV$V_MNT] THEN ERR_EXIT (SS$_DEVMOUNT);

CLEANUP_FLAGS[CLF_CLEARVALID] = 1; ! device is now known not mounted

!
! Some things to be tested on the 1st only and then stored anyway
!
IF .J EQL 0 
    THEN
	BEGIN
	!
	! is it a tape or disk mount
	!
	STORED_CONTEXT [TAPE_MOUNT] = .DEVICE_CHAR [DEV$V_SQD];

	! we need only to test if we are going to overide something
	! once ( and then just save it )
	!
	IF (  .MOUNT_OPTIONS[OPT_FOREIGN] OR .MOUNT_OPTIONS[OPT_NOLABEL]
	   OR .MOUNT_OPTIONS[OPT_OVR_ACC] OR .MOUNT_OPTIONS[OPT_PROTECTION]
	   OR .MOUNT_OPTIONS[OPT_OVR_EXP] OR .MOUNT_OPTIONS[OPT_USER_UIC]
	   OR .MOUNT_OPTIONS[OPT_NOQUOTA] OR .MOUNT_OPTIONS[OPT_OWNER_UIC]
	   OR .MOUNT_OPTIONS[OPT_OVR_LOCK] OR .MOUNT_OPTIONS[OPT_OVR_VOLO])
		THEN STORED_CONTEXT [OVERIDE_SOMETHING] = 1
		ELSE STORED_CONTEXT [OVERIDE_SOMETHING] = 0;

	! device number must match label number for disk
	!
	IF (NOT .STORED_CONTEXT [TAPE_MOUNT]) AND
	   (.DEVICE_COUNT NEQ .LABEL_COUNT) AND (.LABEL_COUNT NEQ 0)
		THEN ERR_EXIT (MOUN$_DEVCOUNT);

	END;	! End of block to be executed for first device only.

!
! test legal options for device type
!
IF
    BEGIN
    IF .DEVICE_CHAR[DEV$V_SQD]
	THEN
	    ((.OPTIONS[0] AND NOT TAPE_OPTIONS1) NEQ 0
	    OR (.OPTIONS[1] AND NOT TAPE_OPTIONS2) NEQ 0)
	ELSE
	    ((.OPTIONS[0] AND NOT DISK_OPTIONS1) NEQ 0
	    OR (.OPTIONS[1] AND NOT DISK_OPTIONS2) NEQ 0)
    END
	THEN ERR_EXIT (MOUN$_ILLOPT);
	
! device types must be consistent
!   tapes with tapes or disks with disks
!
IF (NOT .DEVICE_CHAR [DEV$V_SQD] AND .STORED_CONTEXT [TAPE_MOUNT]) 
    OR
   (.DEVICE_CHAR [DEV$V_SQD] AND NOT .STORED_CONTEXT [TAPE_MOUNT])
	THEN ERR_EXIT (MOUN$_INCONSDEV);

!
! Now attempt to read the home block or volume header label, as appropriate
! for the device type.
!

IF .DEVICE_CHAR[DEV$V_SQD]
    THEN
	STATUS = READ_VOLLABEL (LABEL_STRING[.J*2])
    ELSE
	STATUS = READ_HOMEBLOCK (LABEL_STRING[.J*2], NOT .MOUNT_OPTIONS[OPT_FOREIGN]);

!
! Now check the status of the volume against the various mount options. Note,
! in particular, whether the user is attempting to override volume protection.
!

MOUNT_OPTIONS[OPT_IS_FILES11] = 1;	! assume volume is Files-11
IF NOT .STATUS
    THEN BEGIN
    IF .STATUS EQL SS$_NOHOMEBLK OR .STATUS EQL SS$_NOTLABELMT
					! if home block is not found
	THEN BEGIN
	MOUNT_OPTIONS[OPT_IS_FILES11] = 0;
	IF NOT  (  .MOUNT_OPTIONS[OPT_FOREIGN]
		OR .MOUNT_OPTIONS[OPT_NOLABEL])
	THEN
	    IF .DEVICE_CHAR[DEV$V_SQD]
	    THEN ERR_EXIT (.STATUS)
	    ELSE ERR_EXIT (.STATUS, 0, MOUN$_VOLIDENT, 6,
			    HM2$S_VOLNAME, HOME_BLOCK[HM2$T_VOLNAME],
			    HM2$S_OWNERNAME, HOME_BLOCK[HM2$T_OWNERNAME],
			    HM2$S_FORMAT, HOME_BLOCK[HM2$T_FORMAT]);
	END

	ELSE IF .STATUS EQL SS$_INCVOLLABEL ! if volume label mismatch
	    THEN
		BEGIN
		IF .MOUNT_OPTIONS[OPT_LABEL]
		AND NOT .MOUNT_OPTIONS[OPT_FOREIGN]
		AND NOT .MOUNT_OPTIONS[OPT_OVR_ID]
		THEN
		    IF .DEVICE_CHAR[DEV$V_SQD]
		    THEN ERR_EXIT (.STATUS)
		    ELSE ERR_EXIT (.STATUS, 0, MOUN$_VOLIDENT, 6,
				    HM2$S_VOLNAME, HOME_BLOCK[HM2$T_VOLNAME],
				    HM2$S_OWNERNAME, HOME_BLOCK[HM2$T_OWNERNAME],
				    HM2$S_FORMAT, HOME_BLOCK[HM2$T_FORMAT]);
		END

	    ELSE
		BEGIN
		MOUNT_OPTIONS[OPT_IS_FILES11] = 0; ! Clean up option flag.
		ERR_EXIT (.STATUS);
		END;
    END;

!
! are overiding something with a files-11 mount
!
IF .MOUNT_OPTIONS[OPT_IS_FILES11] AND .STORED_CONTEXT [OVERIDE_SOMETHING]
	THEN MOUNT_OPTIONS[OPT_OVR_PRO] = 1;

!
! Call the device specific routine that actually does the mount.
!

IF .DEVICE_CHAR[DEV$V_SQD]
	THEN
	    BEGIN
	    MOUNT_TAPE ();
	    KERNEL_CALL (XFER_DEV_OWNER, .CHANNEL);
	    END	    
	ELSE
	    BEGIN

! Get the device context, if it exists.  This is necessary to
! make sure that mounts of the same device from different nodes
! are consistent.
!

	    IF NOT (STATUS = KERNEL_CALL (GET_DEVICE_CONTEXT))
	    THEN
		ERR_EXIT (.STATUS);

	    IF .MOUNT_OPTIONS[OPT_IS_FILES11B]
	    THEN
		MOUNT_DISK2 ()
	    ELSE
		MOUNT_DISK1 ();
!
! If we are mounting a shared volume on an allocated device, deallocate the
! device now.  We delayed the deallocation until now so that if the mount
! failed, the device remained allocated.
!
	    IF NOT .MOUNT_OPTIONS [OPT_NOSHARE]
		THEN KERNEL_CALL (DALLOC_SHR_DEV, .CHANNEL)
		ELSE KERNEL_CALL (XFER_DEV_OWNER, .CHANNEL);

	    END;

!
! Deassign the channel.
!
$DASSGN (CHAN = .CHANNEL);
	
END;				! shared mount path rejoins us here
END;				! end of rebind block

!
! Clean out status values for the next time around the loop.
!

CLEANUP_FLAGS = .CLEANUP_FLAGS AND (1^CLF_REBUILD OR 1^CLF_REBUILDQUO);
CHANNEL = 0;
REAL_MVL = 0;
REAL_RVT = 0;
REAL_VCB = 0;
REAL_FCB = 0;
REAL_WCB = 0;
REAL_AQB = 0;
MTL_ENTRY = 0;
SMTL_ENTRY = 0;
OPTIONS[0] = .OPTIONS[0] AND NOT RESET_OPTIONS1;
OPTIONS[1] = .OPTIONS[1] AND NOT RESET_OPTIONS2;
MOUNT_FAILED = 0;		! Indicate that the mount worked.
RETURN (SS$_NORMAL)		! Return success status
END;				! end of MOUNT_VOLUME

ROUTINE MAIN_HANDLER (SIGNAL, MECHANISM) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine is the main level condition handler for the MOUNT
!	utility. It undoes anything that MOUNT has done so far and returns
!	the condition code as status to MOUNT's	caller (i.e., the CLI).
!
!
! CALLING SEQUENCE:
!	MAIN_HANDLER (ARG1, ARG2)
!
! INPUT PARAMETERS:
!	ARG1: address of signal array
!	ARG2: address of mechanism array
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	stack unwound, control passed to CLI
!
!--

BEGIN

MAP
	SIGNAL		: REF BBLOCK,	! signal array
	MECHANISM	: REF BBLOCK;	! mechanism array

EXTERNAL
	USER_STATUS	: VECTOR;	! status return of some routines


IF .SIGNAL[CHF$L_SIG_NAME] NEQ SS$_UNWIND
THEN
    BEGIN
    !
    ! Do cleanup as indicated by the status flags.
    !
    IF .BBLOCK [SIGNAL[CHF$L_SIG_NAME], STS$V_SEVERITY] EQL STS$K_SEVERE
    THEN
	BEGIN
	IF .CLEANUP_FLAGS[CLF_DISMOUNT]
	THEN
	    KERNEL_CALL (FORCE_DISMOUNT);

	IF .CHANNEL NEQ 0
	THEN
	    BEGIN
	    IF NOT .CLEANUP_FLAGS[CLF_DISMOUNT]
		AND .CLEANUP_FLAGS[CLF_CLEARVALID]
	    THEN
		BEGIN
		DO_IO (CHAN = .CHANNEL,
		       FUNC = (IO$_AVAILABLE OR IO$M_INHERLOG),
		       EFN  = MOUNT_EFN
		      );
		IF .STORED_CONTEXT [TAPE_MOUNT]
		THEN KERNEL_CALL (CLEAR_VALID);
		END;
	    $DASSGN (CHAN = .CHANNEL);
	    CHANNEL = 0;
	    END;

	!
	! Zero the various cleanup flags.
	!
	CLEANUP_FLAGS[CLF_DISMOUNT] = 0;
	CLEANUP_FLAGS[CLF_CLEARVALID] = 0;
	CLEANUP_FLAGS[CLF_DEASSTEMP] = 0;

	END;
    END;
!
! Resignal the condtion.  Does not affect UNWIND.
!
RETURN SS$_RESIGNAL;

END;					! end of routine MAIN_HANDLER

ROUTINE FORCE_DISMOUNT =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine initiates a dismount on the volume just mounted
!	(usually because an error occurred during the /BIND processing).
!	This routine must be called in kernel mode.
!
!
! CALLING SEQUENCE:
!	FORCE_DISMOUNT ()
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	MTL_ENTRY: address of mounted volume list entry just created
!	SMTL_ENTRY: as above, for volume set if non-zero
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	1
!
! SIDE EFFECTS:
!	volume dismounted
!
!--

BEGIN

BUILTIN
	REMQUE;

LINKAGE
	IOC_DISMOUNT	= JSB (REGISTER = 6, REGISTER = 3, REGISTER = 4) :
			NOPRESERVE (2);

EXTERNAL
	SCH$GL_CURPCB	: REF BBLOCK ADDRESSING_MODE (ABSOLUTE);
					! address of process PCB

EXTERNAL ROUTINE
	IOC$DISMOUNT	: IOC_DISMOUNT ADDRESSING_MODE (GENERAL);
					! system dismount routine

LOCAL
	MTL		: REF BBLOCK;	! address of mount list entry


REMQUE (.MTL_ENTRY, MTL);
IOC$DISMOUNT (.MTL, 1, .SCH$GL_CURPCB);

IF .SMTL_ENTRY NEQ 0
THEN
    BEGIN
    REMQUE (.SMTL_ENTRY, MTL);
    IOC$DISMOUNT (.MTL, 1, .SCH$GL_CURPCB);
    END;

RETURN 1;

END;					! end of routine FORCE_DISMOUNT


ROUTINE CLEAR_VALID =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine clears the volume valid bit in the UCB.
!
!
! CALLING SEQUENCE:
!	CLEAR_VALID ()
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!	CHANNEL: channel number assigned to device
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	1
!
! SIDE EFFECTS:
!	valid bit clear in UCB
!
!--

BEGIN

LOCAL
	UCB		: REF BBLOCK;	! pointer to UCB

EXTERNAL
	CHANNEL;			! channel assigned to device

EXTERNAL ROUTINE
	GET_CHANNELUCB;			! get UCB of channel


! Get the UCB address from the channel and clear the bit.
!

UCB = GET_CHANNELUCB (.CHANNEL);
UCB[UCB$V_VALID] = 0;

RETURN 1;

END;					! end of routine CLEAR_VALID

GLOBAL ROUTINE DALLOC_SHR_DEV (CHANNEL) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine locates the UCB associated with the channel passed to
!	it as an input argument.  It then deallocates the device (i.e. marks
!	the UCB as unallocated) on the local system.  If an
!	exclusive cluster-wide lock exists for this device, it will also
!	convert it into	a CR mode lock.
!
! CALLING SEQUENCE:
!
!	kernel_call (dalloc_shr_dev, .channel)
!
!	This routine must be called in kernel mode.
!
! INPUT:
!
!	CHANNEL = channel to the device which is being mounted
!
! OUTPUT:
!
!	None.
!
! IMPLICIT INPUT:
!
!	Mount data base.
!	Device is being mounted /SHARE, /GROUP, or /SYSTEM.
!
! IMPLICIT OUTPUT:
!
!	None.
!
! ROUTINE VALUE:
!
!	1 if control is returned to the caller.  Otherwise, the procedure
!	signals an error.
!
! SIDE EFFECTS:
!
!	Device is deallocated.  Device lock is converted to CR mode.
!--

BEGIN

EXTERNAL ROUTINE
	GET_CHANNELUCB: ADDRESSING_MODE (GENERAL);

LOCAL
	STATUS,				! Status of $ENQ call.
	LOCK_STATUS: VECTOR [2],	! Lock status block.
	UCB: REF BBLOCK;		! UCB of device.

UCB = GET_CHANNELUCB (.CHANNEL);	! Get the UCB address.
!
! We already know that this is a shared mount; check to see if the device
! was previously allocated.
!
IF .UCB [UCB$L_PID] NEQ 0
   THEN BEGIN
	!
	! Deallocate the local UCB.
	!
	UCB [UCB$L_PID] = 0;
	BBLOCK [UCB [UCB$L_DEVCHAR], DEV$V_ALL] = 0;
	UCB [UCB$W_REFC] = .UCB [UCB$W_REFC] - 1;
	!
	! If an exclusive lock exists, convert it to CR mode.
	!
	IF .UCB [UCB$L_LOCKID] NEQ 0
	    THEN BEGIN
		LOCK_STATUS [1] = .UCB [UCB$L_LOCKID];
		STATUS = $ENQW (ACMODE = PSL$C_KERNEL,
				EFN    = MOUNT_EFN,
				LKSB   = LOCK_STATUS,
				FLAGS  = (LCK$M_CONVERT OR LCK$M_CVTSYS),
				LKMODE = LCK$K_CRMODE);
		IF NOT .STATUS THEN ERR_EXIT (.STATUS);
	    END;
    END;

RETURN (1);

END;				! End of routine DALLOC_SHR_DEV.

GLOBAL ROUTINE XFER_DEV_OWNER (CHANNEL) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine locates the UCB associated with the channel passed to
!	it as an input argument.  If current process is a subprocess, then
!	the device ownership is transfered to the top level process in the
!	process tree. This is necessary to support job-wide mount.	
!
!	Note: we perform the transfer of ownership simply by setting the
!	master's PID into the UCB. This is sufficient because the lock on 
!	this device is not tied to this process, i.e. it is a system-owned 
!	lock.
!
! CALLING SEQUENCE:
!
!	KERNEL_CALL (XFER_DEV_OWNER, .CHANNEL)
!
!	This routine must be called in kernel mode.
!
! INPUT:
!
!	CHANNEL = channel to the device which is being mounted
!
! OUTPUT:
!
!	None.
!
! IMPLICIT INPUT:
!
!	Mount data base.
!	Device is being mounted /NOSHARE.
!
! IMPLICIT OUTPUT:
!
!	If the current process is a subprocess, then the device is
!		allocated to its master,
!	else
!		none.
!
! ROUTINE VALUE:
!
!	1.
!
! SIDE EFFECTS:
!
!	None.
!
!--

BEGIN

EXTERNAL
	SCH$GL_CURPCB	: REF BBLOCK ADDRESSING_MODE (GENERAL);
					! address of our PCB

EXTERNAL ROUTINE
	GET_CHANNELUCB	: ADDRESSING_MODE (GENERAL);

LOCAL
	JIB	: REF BBLOCK,		! JIB of current process	
	UCB	: REF BBLOCK;		! UCB of device.

UCB = GET_CHANNELUCB (.CHANNEL);	! Get the UCB address.
!
! We already know that this is a private mount; check to see if the device
! was previously allocated for sanity's sake.
!
IF .UCB [UCB$L_PID] NEQ 0
THEN 
    BEGIN
    ! 
    ! Check if the current process is a subprocess. If so, set the PID 
    ! of the top level process in the process tree in the UCB.
    !
    IF .SCH$GL_CURPCB [PCB$L_OWNER] NEQ 0  
    THEN
    	BEGIN
	JIB = .SCH$GL_CURPCB [PCB$L_JIB];
        UCB [UCB$L_PID] = .JIB [JIB$L_MPID];
	END;
    END;

RETURN 1;

END;				! End of routine XFER_DEV_OWNER.



GLOBAL ROUTINE MOUNT_CLUSTER (ITEM_LIST) =		

!+
!
! FUNCTIONAL DESCRIPTION:
!	
!	This routine performs the cluster-wide mount operation.
!	It calls another routine to create a cluster-mount packet
!	and then sends this mount request to other nodes in the
!	cluster.
!
! CALLING SEQUENCE:
!
!	MOUNT_CLUSTER (ARG1)
!
! INPUTS:
!
!	ARG1	: Address of the mount item list
! 
! OUTPUTS:
!
!	None.
! 
! IMPLICIT INPUTS:
!	
!	None.
!
! OUTPUT PARAMETERS:
!
!	None.
!
! IMPLICIT OUTPUTS:
!	
!	None.
!
! ROUTINE VALUE:
!
!	1	  : If success
!	Otherwise : Status from comm primitive.
!
! SIDE EFFECTS:
!
!	The mount request is sent to other nodes in the cluster.
! 
!-


BEGIN						! Start of MOUNT_CLUSTER

MAP
	ITEM_LIST	: REF BBLOCK;

EXTERNAL ROUTINE
	IN_CLUSTER	: ADDRESSING_MODE (GENERAL),
	SEND_CLUSTER	: ADDRESSING_MODE (GENERAL),
	GET_UIC		: ADDRESSING_MODE (GENERAL);

EXTERNAL
	MOUNT_OPTIONS	: BITVECTOR VOLATILE; ! Parser option flags

!
! Define constants to calculate the size of the cluster-mount buffer
!
LITERAL
	ITEM_SIZE	= 12,
	NO_OF_ITEMS	= 18,
	BUFFER_SIZE 	= 63,
	COMMENT_SIZE 	= 80,
	ITEM_LIST_SIZE  = ( (ITEM_SIZE*DEVMAX)*2 + (NO_OF_ITEMS*ITEM_SIZE) +4 );

LOCAL
	STATUS,
	LENGTH,
	UIC;

OWN
	BUFFER		: VECTOR [0],				! Buffer area for 
								! cluster-mount packet
	ITEM_BUF	: BBLOCK [ITEM_LIST_SIZE],		! Item descriptors

	LABEL_BUF	: BBLOCK [BUFFER_SIZE * DEVMAX],	! Volume labels
	LOGNAM_BUF	: BBLOCK [BUFFER_SIZE * DEVMAX],	! Logical names
	ACPNAM_BUF	: BBLOCK [BUFFER_SIZE],			! ACP name
	VOLSET_BUF	: BBLOCK [BUFFER_SIZE],			! Volume set name
	COMMENT_BUF	: BBLOCK [COMMENT_SIZE],		! Comments

	NAME_BUF	: VECTOR [NAMEBUF_LEN * DEVMAX, BYTE],	! Device names
	BUFFER_END	: VECTOR [0];

LITERAL
	BUFFER_LEN	= BUFFER_END - BUFFER;


IF ( NOT .MOUNT_OPTIONS [OPT_CLUSTER] )		! If not /cluster or not in a  
OR NOT ( STATUS = IN_CLUSTER() )		! cluster environment, return
THEN						! immediately
    RETURN 1;

CH$FILL (0, BUFFER_LEN, BUFFER); 		! Zero buffer area
STATUS = MOUNT_ENCIPHER (.ITEM_LIST, BUFFER_LEN, BUFFER, LENGTH); 
						! Encipher the mount request
IF NOT .STATUS 					! If error, return
THEN 
    RETURN .STATUS;				

UIC = KERNEL_CALL (GET_UIC);			! Get our UIC
STATUS = KERNEL_CALL (SEND_CLUSTER, BUFFER, .LENGTH, .UIC); ! Broadcast the request
						! Arg3 (UIC) non-zero means a cluster-mount
RETURN .STATUS;
	
END;						! End of MOUNT_CLUSTER




ROUTINE MOUNT_ENCIPHER (ITEM_LIST, LIMIT, BUFFER, LENGTH) =

!+
!
! FUNCTIONAL DESCRIPTION:
!
! 	This routine takes the parameters of the mount request
!	and enciphers the parameters into a cluster-mount packet.
!
! CALLING SEQUENCE:
!
!	MOUNT_ENCIPHER (ARG1,ARG2,ARG3,ARG4)
! 
! INPUTS:
!
!	ARG1	: Address of the item list
!	ARG2	: Output buffer limit
!
! OUTPUTS:
!
!	None.
!
! IMPLICIT INPUTS:
!
!	None.
!
! OUTPUT PARAMETERS:
!
!	ARG3	: Address of the output buffer to receive the
!		    cluster-mount packet
!	ARG4	: Address of a longword to receive the length of 
!		    the output buffer
!
! IMPLICIT OUTPUTS:
!
!	None.
!
! ROUTINE VALUES:
!
!	1	      : If successful
!	SS$_BUFFEROVF : Insufficient internal buffer space, 
!			i.e. length exceeds limit
!
! SIDE EFFECTS:
!
!	None.
!
!
! NOTES:
!
! This encipher routine takes the given mount item list and turns it
! into a cluster-mount packet of the form:
!
!			      Offset
!	+---------------+	
!	| code1 | len1	|  0  ITEM_LENG	item_desc_1
!	+---------------+	
!	|offset to str_1|  8  ITEM_ADDR
!	+---------------+	
!	|    unused	| 12  ITEM_NULL 
!	+---------------+	
!	| code2 | len2	|  0  ITEM_LENG	item_desc_2
!	+---------------+	
!	|offset to str_2|  8  ITEM_ADDR
!	+---------------+	
!	|    unused	| 12  ITEM_NULL
!	+---------------+	
!	.		.	
!	.		.	
!	.		.	
!	+---------------+	
!	|	0	|     End of item decsiptors
!	+---------------+	
!	|     str_1	|
!	+---------------+	
!	|     .....	|  
!	+---------------+	
!	|     str_2	|
!	+---------------+	
!	|     .....	|  
!	+---------------+	
!
! 	1. This cluster-mount packet is to be sent to other nodes in
!	   the cluster and processed by CSP (the Cluster Server Process).
!
!	2. The address in the item descriptor is "relocated" to be the 
!	   offset from the beginning of the packet (i.e. self-relative). 
!	   This is done so that when CSP gets the cluster-mount packet,
!	   it can simply add the packet address to the offset in the
!	   item desciptor to obtain the address of the string.
!
!-


BEGIN						! Start of MOUNT_ENCIPHER

MAP	
	ITEM_LIST	: REF BBLOCK,
	BUFFER		: REF BBLOCK;

LOCAL
	ITEM		: REF BBLOCK,		! Pointer to item descriptor
	PTR		: REF BBLOCK,		! Pointer to output item desc
	STR_PTR		: REF BBLOCK,		! Pointer to item string
	ITEM_COUNT,				! Number of items in item list
	DEVICE_COUNT,				! Device number index
	J;						

EXTERNAL
	MOUNT_OPTIONS	: BITVECTOR VOLATILE; ! Parser option flags

MACRO ITEM_LENG	 =  0,0,16,0%;			! Define buffer offsets
MACRO ITEM_CODE	 =  2,0,16,0%;
MACRO ITEM_ADDR	 =  4,0,32,0%;
MACRO ITEM_NULL	 =  8,0,32,0%;
LITERAL ITEM_SIZE = 12;

!
! Count of number of items in the item list
!
		
ITEM = .ITEM_LIST;				! Point to the beginning of list
ITEM_COUNT = 0;					! Initialize counter
WHILE ( .ITEM [ITEM_CODE] NEQ 0 ) DO
BEGIN
    ITEM_COUNT = .ITEM_COUNT + 1;		! Increment number of items
    ITEM = .ITEM + ITEM_SIZE;			! Bump item desciptor pointer
END;

!
! Calculate space needed for the item descriptors
!
STR_PTR = .BUFFER + (.ITEM_COUNT * ITEM_SIZE);	! Space needed for descriptors
STR_PTR [ITEM_CODE] = STR_PTR [ITEM_LENG] = 0;	! Mark end of descriptor area
STR_PTR = .STR_PTR + 4;				! Mark beginning of string area
PTR = .BUFFER;					! Mark beginning of desciptor area
ITEM = .ITEM_LIST;				! Point to the beginning of item list
DEVICE_COUNT = 0;				! Initialize device index
.LENGTH = 4;					! Initialize length (itmlst stopper)
 
! 
! For each item in the item list, copy the item descriptor and the
! item string to the output buffer
!
DECR J FROM .ITEM_COUNT TO 1 DO
BEGIN
    SELECT .ITEM [ITEM_CODE] OF
	SET

	[MNT$_DEVNAM]	:	
	 		    BEGIN
			    !
			    ! For DEVNAM:
			    !
			    !	a. Create item descriptor, relocate address
			    !   b. Compute length, return SS$_BUFFEROVF if appropriate
			    !   c. Copy device string from physical device descriptor
			    !
			    BIND
			    	DEV_DSC = PHYS_NAME [.DEVICE_COUNT * 2] : $BBLOCK;

			    PTR [ITEM_LENG] = .DEV_DSC [DSC$W_LENGTH];	
			    PTR [ITEM_CODE] = MNT$_DEVNAM;
			    PTR [ITEM_ADDR] = .STR_PTR - .BUFFER;
			    .LENGTH = ..LENGTH + ITEM_SIZE + .PTR [ITEM_LENG];
			    IF ..LENGTH GTRU .LIMIT
 			    THEN
			    	RETURN SS$_BUFFEROVF;
			    CH$COPY (.PTR [ITEM_LENG],
			    	     .DEV_DSC [DSC$A_POINTER],
			    	     0,
			    	     .PTR [ITEM_LENG],
			    	     .STR_PTR);
			    DEVICE_COUNT = .DEVICE_COUNT + 1;
			    END;

	[MNT$_FLAGS]	:	
	 		    BEGIN
			    !
			    ! For FLAGS:
			    !
			    !	a. Create item descriptor, relocate address
			    !   b. Compute length, return SS$_BUFFEROVF if appropriate
			    !   c. Copy flags, clear NMT$V_CLUSTER bit, and
			    !	   set MNT$V_NOASSIST (disables operator assist)
			    !
			    PTR [ITEM_LENG] = .ITEM [ITEM_LENG];	
			    PTR [ITEM_CODE] = MNT$_FLAGS;
			    PTR [ITEM_ADDR] = .STR_PTR - .BUFFER;
			    .LENGTH = ..LENGTH + ITEM_SIZE + .PTR [ITEM_LENG];
			    IF ..LENGTH GTRU .LIMIT
 			    THEN
				RETURN SS$_BUFFEROVF;
			    BEGIN
				BIND     
				    TEMP_PTR = .STR_PTR	: BBLOCK;
			    	TEMP_PTR = ..ITEM [ITEM_ADDR];
			        TEMP_PTR [MNT$V_CLUSTER] = 0;
				TEMP_PTR [MNT$V_NOASSIST] = 1;
				IF  NOT .MOUNT_OPTIONS [OPT_GROUP]
				THEN
				    TEMP_PTR [MNT$V_SYSTEM] = 1;
			    END;

			    END;

	[OTHERWISE]	:	
	 		    BEGIN
			    !
			    ! All others:
			    !
			    !	a. Create item descriptor, relocate address
			    !   b. Compute length, return SS$_BUFFEROVF if appropriate
			    !   c. Copy item to output buffer
			    !
			    PTR [ITEM_LENG] = .ITEM [ITEM_LENG];	
			    PTR [ITEM_CODE] = .ITEM [ITEM_CODE];
			    PTR [ITEM_ADDR] = .STR_PTR - .BUFFER;
			    .LENGTH = ..LENGTH + ITEM_SIZE + .PTR [ITEM_LENG];
			    IF ..LENGTH GTRU .LIMIT
 			    THEN
				RETURN SS$_BUFFEROVF;
			    CH$COPY (.ITEM [ITEM_LENG],
				     .ITEM [ITEM_ADDR],
				     0,
				     .ITEM [ITEM_LENG],
				     .STR_PTR);
			    END;

	TES;
	
    STR_PTR = .STR_PTR + .PTR [ITEM_LENG];	! Bump string buffer pointer
    ITEM = .ITEM + ITEM_SIZE;			! Bump item descriptor pointer
    PTR = .PTR + ITEM_SIZE;			! Bump output descriptor pointer

END;						! End of item list loop


RETURN 1;
END;						! End of MOUNT_ENCIPHER



ROUTINE SEARCH_DEVICE (J) =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine searches the I/O database for a mountable device
!	and allocates the device, if it is not already allocated. If
!	the mount operation is a private mount, an EX mode lock will
!	be taken out. If the mount operation is a shared mount, a PW
!	mode lock will be taken out.
!
!	Note: this routine must be called in kernel mode.
!
! CALLING SEQUENCE:
!
!	SEARCH_DEVICE (ARG1)
!
! INPUT:
!
!	ARG1	: Index into device list.
!
! OUTPUT:
!
!	None.
!
! IMPLICIT INPUT:
!
!	Mount database.
!
! IMPLICIT OUTPUT:
!
!	The physical device name of the device will be set up in
!	the mount data base, with the appropriate device descriptor
!	set up in PHYS_NAME.
!
! ROUTINE VALUE:
!
!	Assorted status codes.
!
! SIDE EFFECTS:
!
!	None.
!
! NOTES:
!
!	To properly interlock the device in a cluster environment,
!	we must carefully take out the MOU$ interlock and the device
!	lock to serialize the mounts in the cluster without deadlocks.
!	Following is the algorithm used:
!
!	Step 0:	Lock I/O database;
!		IOC$SEARCH (...);
!		If success 
!		    then S0
!		    else F0
!	
!	S0:	If device allocated
!		then
!		    set SS$_DEVALRALLOC
!		else
!		    mark UCB as allocated;
!
!	S1:	IOC$CVT_DEVNAM (...) to convert device name;
!
!	S2:	Unlock I/O database;
!
!	S3:	$GETDVIW to obtain allocation class name;
!
!	S4:	$ENQW MOU$ lock with LCK$M_NOQUEUE
!
!	S5:	If success
!		    then
!			Exit loop;
!
!	S6:	If SS$_DEVALRALLOC
!		    then
!			IOC$UNLOCK_DEV to dequeue device lock
!		    else
!			IOC$DALLOC_DEV to deallocate and release device lock;
!
!	S7:	Wait delta time;
!
!	S8:	$ENQW MOU$ lock;
!
!	S9:	$DEQ MOU$ lock;
!
!	S10:	Goto step 0;
!
!
!	F0:	If ( not SS$_DEVALLOC )
!		or ( private mount )
!		or ( device_allocated )
!		    then
!			Unlock I/O database;
!			Exit loop;
!
!	F1:	IOC$CVT_DEVNAM (...) to convert alloc class device name;
!
!	F2:	Unlock I/O database;
!
!	F3:	Wait delta time;
!
!	F4:	$ENQW MOU$ lock;
!	
!	F5:	Construct device lock;
!		$ENQW device in CR mode with NOQUEUE;
!
!	F6:	If failed 
!		    then
!			Exit loop;
!
!	F7:	$DEQ device lock;
!
!	F8:	$DEQ MOU$ lock;
!
!	F9:	Goto step 0;
!		
!
!	Note:   This algorithm does not handle simultaneous /shared mounts
!		from the same system. In this case, the first mounter will
!		mount the device, and the second mounter will fail with an
!		SS$_DEVALLOC error.  To  properly  serialize  simultaneous 
!		shared mounts,  another level of lock (the label lock) had 
!		to be added.
!
!--

BEGIN

LOCAL
	SEARCH_FLAGS	: BBLOCK [4],		! IOC$SEARCH routine flags
	UCB		: REF BBLOCK,		! Address of the UCB
	STATUS,					! Routine status
	SEARCH_STATUS,				! Final success status
	COUNTER,				! Count number of iterations
	DEVICE_ITMLST1	: BBLOCK [(1 * 12) + 4] INITIAL
			!
			! item: allocation class plus device name
			!
			(WORD (NAMEBUF_LEN-4),
			 WORD (DVI$_ALLDEVNAM),
			 LONG (ALLDEVNAM_BUF+4),
			 LONG (ALLDEVNAM_DESC),
			!
			! end of list
			!
			 LONG (0));

EXTERNAL
	DEV_CTX		: BBLOCK FIELD (DC), 	! device value block context fields
	MOUNT_OPTIONS	: BITVECTOR VOLATILE,	! Parser option flags
	DEVICE_STRING	: VECTOR VOLATILE,	! Device name string descriptor	
	SCH$GL_CURPCB	: REF BBLOCK ADDRESSING_MODE (GENERAL); ! PCB address of current process

LINKAGE
	IOC_SEARCH	= JSB (REGISTER = 1, REGISTER = 2, REGISTER = 3, 
			  REGISTER = 4; REGISTER = 1) : 
			  NOPRESERVE (2, 3, 5),

	IOC_CVT_DEVNAM	= JSB (REGISTER = 0, REGISTER = 1, REGISTER = 4,
			  REGISTER = 5; REGISTER = 1) :
			  PRESERVE (2,3,4,5,6,7),

	IOC_LOCK_DEV	= JSB (REGISTER = 0, REGISTER = 1, REGISTER = 4, 
			  REGISTER = 5) : NOPRESERVE (4, 5),

	IOC_UNLOCK_DEV	= JSB (REGISTER = 5),

	IOC_DALLOC_DEV	= JSB (REGISTER = 4, REGISTER = 5) :
			  NOPRESERVE (1,2,3,8),

	EXE_MAXACMODE	= JSB (REGISTER = 0) :
			  NOTUSED (2,3,4,5,6,7,8,9,10,11);	

EXTERNAL ROUTINE
	LOCK_IODB	: ADDRESSING_MODE (GENERAL),
						! Lock I/O database mutex
	UNLOCK_IODB	: ADDRESSING_MODE (GENERAL),
						! Unlock the above
	IOC$SEARCH	: IOC_SEARCH ADDRESSING_MODE (GENERAL),
						! Search I/O database for device
	IOC$CVT_DEVNAM	: IOC_CVT_DEVNAM ADDRESSING_MODE (GENERAL),
						! Get fully expanded device name
	IOC$LOCK_DEV	: IOC_LOCK_DEV ADDRESSING_MODE (GENERAL),
						! Take out the device lock
	IOC$UNLOCK_DEV	: IOC_UNLOCK_DEV ADDRESSING_MODE (GENERAL),
						! Release the device lock
	IOC$DALLOC_DEV	: IOC_DALLOC_DEV ADDRESSING_MODE (GENERAL),
						! Deallocate device and device lock
	EXE$MAXACMODE	: EXE_MAXACMODE ADDRESSING_MODE (GENERAL);
						! Maximize access mode

!
! Rebind things to make life easier ( so we see them as their
! real logical units).
!
MAP
	DEVICE_STRING   : BBLOCKVECTOR [ DEVMAX, 8 ],
	NAME_BUFFER	: BBLOCKVECTOR [ DEVMAX, NAMEBUF_LEN ],
	PHYS_NAME	: BBLOCKVECTOR [ DEVMAX, 8 ];

!
! Start of buffer
!
MACRO   STADR   = 0,0,0,0%;

!
! Define descriptor vector displacements
!
MACRO   LEN	= 0,0,32,0%;
MACRO   ADDR    = 4,0,32,0%;
MACRO	ILEN	= 8,0,32,0%;			! Item list returned length position.

LITERAL
	RETRY_LIMIT = 1000;			! Define retry limit

SEARCH_FLAGS [0,0,32,0] = 0;			! Initialize search flags
SEARCH_FLAGS [IOC$V_MOUNT] = 1;			! Set flag to indicate searching for a mountable device

!
! If this is a private mount, set flag to take out an exclusive lock on
! the device.
!
IF .MOUNT_OPTIONS [OPT_NOSHARE]
THEN
    SEARCH_FLAGS [IOC$V_ALLOC] = 1;	

COUNTER = 0;					! Initialize counter

WHILE  (1) DO					! Forever do block

BEGIN

LOCK_IODB ();					! Lock I/O database
STATUS = IOC$SEARCH ( DEVICE_STRING [.J, LEN],	! Search device with proper flags		
		      .SEARCH_FLAGS,
		      DEV_CTX,			! Return lock value block 
		      .SCH$GL_CURPCB;
		      UCB );			! Target device UCB

IF .STATUS 
THEN
	
    BEGIN					! IOC$SEARCH succeeded
    !
    ! If the device is not already allocated, allocate the device by 
    ! setting up the proper status in the I/O database.
    !
    IF  NOT .BBLOCK [UCB [UCB$L_DEVCHAR], DEV$V_ALL]
    THEN
	BEGIN
	UCB [UCB$B_AMOD] = EXE$MAXACMODE (.CALLERS_ACMOD); ! Set access mode
	BBLOCK [UCB [UCB$L_DEVCHAR], DEV$V_ALL] = 1;  ! Set the device as allocated
	UCB [UCB$W_REFC] = .UCB [UCB$W_REFC] + 1;     ! Bump reference count 
	UCB [UCB$L_PID] = .SCH$GL_CURPCB [PCB$L_PID]; ! Set device owner
	SEARCH_STATUS = SS$_NORMAL;		! Set normal return status
	END
    ELSE
	SEARCH_STATUS = SS$_DEVALRALLOC;	! Set proper return status

    !
    ! Set up physical device name in mount database (also set up the device
    ! descriptor).
    !
    IOC$CVT_DEVNAM ( NAMEBUF_LEN,		! Output buffer length	
		     NAME_BUFFER [.J, STADR],	! Output buffer address
		     -1,			! Format device name
		     .UCB;			! Address of UCB
		     PHYS_NAME [.J, LEN] );	! Returned length of device name

    PHYS_NAME [.J, ADDR] = NAME_BUFFER [.J, STADR]; ! Set up device descriptor

    UNLOCK_IODB ();				! Unlock I/O database

    $GETDVIW ( DEVNAM = PHYS_NAME [.J, LEN],	! Target device descriptor
	       ITMLST = DEVICE_ITMLST1,		! Item list
	       EFN    = MOUNT_EFN );		! 	
    ALLDEVNAM_DESC [0] = .ALLDEVNAM_DESC [0] + 4; ! Fix up length to include MOU$

    !
    ! Take out a lock on the allocation class device name.  This will
    ! interlock all mounts of this device.
    !
    STATUS = $ENQW (LKMODE = LCK$K_EXMODE,
  	       	      LKSB = LOCK_STATUS,
		     FLAGS = (LCK$M_SYSTEM OR LCK$M_NOQUEUE),
		    RESNAM = ALLDEVNAM_DESC,
		       EFN = MOUNT_EFN,
		    ACMODE = PSL$C_EXEC);
    IF .STATUS 
    THEN
	BEGIN					! MOU$ interlock granted
	STATUS = .SEARCH_STATUS;		! Return proper status code
	EXITLOOP;				! Get out of the loop
	END					! End of MOU$ success story
    ELSE
	BEGIN					! MOU$ interlock failed
	LOCK_IODB ();				! Lock I/O database
	IF .SEARCH_STATUS EQL SS$_DEVALRALLOC
	THEN
	    IOC$UNLOCK_DEV (.UCB)		! Release device lock
	ELSE
	    IOC$DALLOC_DEV (.SCH$GL_CURPCB, .UCB); ! Deallocate device and 
						   ! release device lock
	UNLOCK_IODB ();				! Unlock I/O database

	WAIT_DELTA (.COUNTER);			! Wait a while

	$ENQW (LKMODE = LCK$K_EXMODE,		! Enqueue MOU$ lock again
  		 LKSB = LOCK_STATUS,
		FLAGS = LCK$M_SYSTEM,
	       RESNAM = ALLDEVNAM_DESC,
		  EFN = MOUNT_EFN,
	       ACMODE = PSL$C_EXEC);
	$DEQ ( LKID = .LOCK_STATUS [1] );	! Dequeue MOU$ lock

	END					! End of MOU$ failure block
	    
    END						! End of IOC$SEACH success block

ELSE

    BEGIN					! IOC$SEARCH failure block

    IF ( .STATUS NEQ SS$_DEVALLOC )		! If not SS$_DEVALLOC 
    OR ( .MOUNT_OPTIONS [OPT_NOSHARE] )		! or this is a private mount
    OR ( .BBLOCK [ UCB [UCB$L_DEVCHAR], DEV$V_ALL ] ) ! or an allocated device
    THEN					! Get out
	BEGIN
	UNLOCK_IODB ();
	EXITLOOP;			
	END;

    !
    ! We have a valid UCB address, get the allocation device name to
    ! derive the MOU$ interlock.
    !
    IOC$CVT_DEVNAM ( NAMEBUF_LEN-4,		! Output buffer length	
		     ALLDEVNAM_BUF+4,		! Output buffer address
		     1,				! Format allocation class device name
		     .UCB;			! Address of UCB
		     ALLDEVNAM_DESC [0]);	! Returned length of device name
    ALLDEVNAM_DESC [0] = .ALLDEVNAM_DESC [0] + 4; ! Fix up length to include MOU$

    UNLOCK_IODB ();				! Unlock I/O database

    WAIT_DELTA (.COUNTER);			! Wait a while

    !
    ! Take out a lock on the allocation class device name. 
    !
    $ENQW (LKMODE = LCK$K_EXMODE,
  	     LKSB = LOCK_STATUS,
	    FLAGS = LCK$M_SYSTEM,
	   RESNAM = ALLDEVNAM_DESC,
	      EFN = MOUNT_EFN,
	   ACMODE = PSL$C_EXEC);

    !
    ! Construct the device lock name and take out the device lock
    ! in CR mode with NOQUEUE.
    !
    BEGIN					
	
    LOCAL
	DEVLCKNAM_BUF	: VECTOR [NAMEBUF_LEN, BYTE]
			  INITIAL (BYTE('SYS$', REP NAMEBUF_LEN-4 OF (' '))),
	DEVLCKNAM_DESC	: VECTOR [2, LONG]
			  INITIAL (0, DEVLCKNAM_BUF),
	DEVLCK_STS	: VECTOR [2, LONG];

    DEVLCKNAM_DESC [0] = .ALLDEVNAM_DESC [0];	! Set up device lock descriptor
  
    CH$COPY (  .ALLDEVNAM_DESC [0] - 4,		! Length of input string
 	       .ALLDEVNAM_DESC [1] + 4,		! Start of alloc name string
	       0,				! 
	       .ALLDEVNAM_DESC [0] - 4,		! Length of output string
	       .DEVLCKNAM_DESC [1] + 4 );	! Start of target string

    STATUS = $ENQW  (LKMODE = LCK$K_CRMODE,	! Enqueue device lock in CR mode
		       LKSB = DEVLCK_STS,	! Lock status block
		      FLAGS = (LCK$M_SYSTEM OR LCK$M_NOQUEUE), ! Return if not available 
   		     RESNAM = DEVLCKNAM_DESC,	! Device lock
		        EFN = MOUNT_EFN);

    IF .STATUS
    THEN
	!
	! Device lock in CR mode granted. This implies that the device
	! is not allocated. Release both locks and try again.
	!
	BEGIN
	$DEQ ( LKID = .DEVLCK_STS [1] );	! Release device lock
	$DEQ ( LKID = .LOCK_STATUS [1] );	! Release MOU$ lock
	END
    ELSE
	! 
	! Device lock in CR mode is not granted. This will happen if the
	! lock is already taken out in EX mode, i.e. the device is allocated.
	! Get out with an SS$_DEVALLOC status.
	!
	BEGIN
	STATUS = SS$_DEVALLOC;			! Set return code
	EXITLOOP;				! Get out
	END;

    END;					! End of block defining DEVLCK

    END;					! End of IOC$SEARCH failure block

    !
    ! Do a sanity check on how many times we have gone thru this loop. If
    ! too many times, give up with an error.
    ! 
    COUNTER = .COUNTER + 1;			! Update counter
    IF .COUNTER GEQ RETRY_LIMIT			! If loop thru too many times	
    THEN					! give up with an error
	BEGIN
	STATUS = SS$_DEVNOTMOUNT;
	EXITLOOP;
	END;

END;						! End of forever block


IF NOT .STATUS
THEN						! If SEARCH_DEVICE failed
    BEGIN
   
    LOCAL
	ITMLST2		: BBLOCK [(1 * 12) + 4] INITIAL
			!
			! item: device name
			!
			(WORD (NAMEBUF_LEN),	! Device name buffer length
			 WORD (DVI$_DEVNAM),	! Device name item code
			 LONG (0),		! Device name buffer address
			 LONG (0),		! Returned device name length
			!
			! end of list
			!
			 LONG (0)),
	LOC_STATUS;				! Local status work

    ! 
    ! The IOC$SEARCH routine failed, use input device string to get the
    ! device name. Also set up the device descriptor. This is necessary
    ! so Operator Assist can output the message with a device name. If
    ! the $GETDVI failed, we've got some real problems, return the status
    ! as the status of routine SEARCH_DEVICE.
    !
    ITMLST2 [ADDR] = NAME_BUFFER [.J, STADR];	! Set up device buffer address
    ITMLST2 [ILEN] = PHYS_NAME [.J, LEN];	! Set returned length 
    PHYS_NAME [.J, ADDR] = NAME_BUFFER [.J, STADR]; ! Set up descriptor

    LOC_STATUS = $GETDVIW (DEVNAM = DEVICE_STRING [.J, LEN], ! Target device descriptor
			   ITMLST = ITMLST2,		! Item list
			   EFN    = MOUNT_EFN );	! 	

    IF NOT .LOC_STATUS				! If we can't even get the device name
    THEN					! Return the status from $GETDVI
	STATUS = .LOC_STATUS

    END;					! End of SEARCH_DEVICE failure block

RETURN .STATUS;					! Return status
END;						! End of routine SEARCH_DEVICE



GLOBAL ROUTINE DEQ_MOUNT_LOCK : NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine dequeus the mount interlock, if it exists. 
!
! CALLING SEQUENCE:
!
!	KERNEL_CALL ( DEQ_MOUNT_LOCK );
!
!	This routine is called in kernel mode because the mount interlock
!	is taken out in kernel mode.
!
! INPUT:
!
!	None.
!
! OUTPUT:
!
!	None.
!
! IMPLICIT INPUT:
!
!	LOCK_STATUS	: Lock status block of the mount interlock
!
! IMPLICIT OUTPUT:
!
!	None.
!
! ROUTINE VALUE:
!
!	None.
!
! SIDE EFFECTS:
!
!	Mount interlock released.
!
!--

BEGIN						

IF .LOCK_STATUS[1] NEQ 0 			! If mount lock exists,
    THEN $DEQ (LKID = .LOCK_STATUS[1]);		! Release it


RETURN;						! Back to caller
END;						! End of routine DEQ_MOUNT_LOCK



ROUTINE WAIT_DELTA (N) : NOVALUE =

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine goes into the waitfor state for a small period of
!	time. This wait period is introduced to give simultaneous mounts
!	a chance to get both the device lock and the mount interlock.
!	The amount of time spent in waitfor state is node-dependent (e.g.
!	based on the scssystemid). The wait time also varies from one
!	call to the next (with a small positive or negative bias).
!
! CALLING SEQUENCE:
!
!	WAIT_DELTA (ARG1)
!
! INPUT:
!
!	ARG1 :	Number of times this routine has been called.
!
! OUTPUT:
!
!	None.
!
! IMPLICIT INPUT:
!
!	None.
!
! IMPLICIT OUTPUT:
!
!	None.
!
! ROUTINE VALUE:
!
!	None.
!
! SIDE EFFECTS:
!
!	None.
!
!--

BEGIN						

OWN
	SCSSYSID,
	XDELTA,
	BIAS,
	GETS_ITMLST	: BLOCK  [(1*12)+4, BYTE] INITIAL
			( WORD (4),	
		 	  WORD (SYI$_SCSSYSTEMID),
			  LONG (SCSSYSID),
			  LONG (0),
			  LONG (0));
LOCAL
	STATUS,
	DELTA		: VECTOR [2,LONG] INITIAL (-1,-1);

!
! Set up some initial values for the first call to this routine.
!
IF .N EQL 0
THEN
    BEGIN

    SCSSYSID = 0;

    STATUS = $GETSYIW ( EFN    = MOUNT_EFN,
		    	ITMLST = GETS_ITMLST );

    !
    ! If the $GETSYI failed or scssystemid is zero, use a default value.
    !

    IF NOT .STATUS 
    OR .SCSSYSID EQL 0
    THEN
	SCSSYSID = 64;

    !
    ! Comput the initial delta time.
    !
    XDELTA = .(SCSSYSID)<0,7>; 

    !
    ! Set up the bias. We set up a positive bias if the initial value
    ! is "sufficiently" small. Otherwise, we set up a positive bias.
    !
    IF .XDELTA GEQ 64
    THEN
        BIAS = -1
    ELSE
        BIAS = +1;

    END;

!
! The actual delta is the previous delta plus the bias, i.e.
!
! (previous_delta+bias) * 1 million * 100 nanosecond
!
! This gives the range of
!
!	scssystemid<0,7> = 1+bias	  .1 second + bias  
! 
!	scssystemid<0,7> = 128+bias	12.8 seconds + bias 
!
! The bias is + or - .1 second, depending on the previous delta time.
! If delta is large, we set up a negative bias for the next iteration.
! If delta is small, we set up a positive bias for the next iteration.
! 

IF .XDELTA GEQ 128				! Large xdelta, set negative bias
THEN
    BIAS = - 1;

IF .XDELTA LEQ 10				! Small xdelta, set positive bias
THEN
    BIAS = + 1;

XDELTA = .XDELTA + .BIAS;			! Compute new xdelta
		
DELTA [0] = .XDELTA * (-1 * 1000 * 1000);	! Compute delta in 100 nanoseconds

STATUS = $SETIMR ( EFN    = MOUNT_EFN,		! Set timer
		   DAYTIM = DELTA   );	

IF .STATUS 
THEN
    $WAITFR ( EFN = MOUNT_EFN );		! Wait 

RETURN;						! Back to caller
END;						! End of routine WAIT_DELTA

END
ELUDOM
