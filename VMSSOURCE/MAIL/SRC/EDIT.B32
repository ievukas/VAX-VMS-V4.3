MODULE MAIL$EDIT( %TITLE 'EDIT OR ENTER A MESSAGE'
		IDENT = 'V04-000' ) =
BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY:	VAX/VMS MAIL UTILITY
!
! ABSTRACT:	Edit or just enter a mail message.
!
! ENVIRONMENT:	NATIVE/USER MODE
!
! AUTHOR: LEN 	KAWELL, CREATION DATE: 25-NOV-1979
!
! MODIFIED BY:
!
!	V03-016	ROP0023		Robert Posniak		16-JUL-1984
!		Change references of XYZ to TPU.
!
!	V03-015	ROP0007		Robert Posniak		13-JUN-1984
!		Check validity of input file spec before
!		entering editor.  Check for illegal escape 
!		sequence when entering message.
!
!	V03-014	BL0280		Benn Schreiber		 4-MAR-1984
!		Handle terminator not seen and data overrun differently
!		since data may be returned.
!
!	V03-013	BLS0272		Benn Schreiber		25-FEB-1984
!		Use LIB$FIND_IMAGE_SYMBOL
!
!	V03-012	BLS0263		Benn Schreiber		 5-FEB-1984
!		If not using callable EDT, then copy message to temp file
!		before calling editor.
!
!	V03-011	BLS0255		Benn Schreiber		28-Dec-1983
!		Use global flags.  Fix error handling in MAIL$ENTER.  Make
!		/edit work with sequential mail files.
!
!	V03-010	BLS0250		Benn Schreiber		 8-Dec-1983
!		Correct condition handling to not signal error if EDTINI
!		not found.  Signal error if not callable editor for READ/EDIT
!		and EDIT commands.
!
!	V03-009	BLS0246		Benn Schreiber		28-Nov-1983
!		Add EDIT/EXTRACT, support for reading messages.
!
!	V03-008	BLS0226		Benn Schreiber		27-Jun-1983
!		Correct cli$ calls for edit command so that /noxxx qualifiers
!		work as advertised
!
!	V03-007	BLS0222		Benn Schreiber		16-May-1983
!		use SMG$READ_STRING rather than LIB$GET_INPUT
!
!	V03-006	BLS0220		Benn Schreiber		30-Apr-1983
!		Make /READ imply /NOJOURNAL
!
!	V03-005	BLS0211		Benn Schreiber		13-Mar-1983
!		Support EDIT command.  Load EDTSHR on the fly.  In
!		MAIL$ENTER, use MAIL's main CTRL/C handler.
!
!	V03-004	BLS0200		Benn Schreiber		22-Dec-1982
!		Remove need for MAIEDTINI by passing SET NOSUMMARY line
!		to EDT directly.
!
!	V03-003	BLS0199		Benn Schreiber		16-Dec-1982
!		Use SYS$SYSTEM:MAIEDTINI.EDT to suppress output file summary.
!		Check if file exists and return SENDABORT if not
!
!	V03-002	BLS0196		Benn Schreiber		22-Nov-1982
!		Turn on EDT journalling
!
!	V03-001	BLS0176		Benn Schreiber		18-Jun-1982
!		Add callable EDT interface
!
!--

!
! TABLE OF CONTENTS:
!

!
! INCLUDE FILES:
!
	LIBRARY 'SYS$LIBRARY:STARLET';
	REQUIRE 'SRC$:MAILREQ';
	LIBRARY	'LIB$:MAILDEF';
!
! MACROS:
!

!
! EQUATED SYMBOLS:
!

!
! OWN STORAGE:
!
OWN
    COMNOSUM: BYTE,				! Need to output SET NOSUM
    COMNOFILE: BYTE,				! User's EDTINI not found
    COMFILCNT: BYTE,				! Count fileio calls for init
    INPUT_DESC : DYN_DESC_DECL,
    COMMAND_DESC : DYN_DESC_DECL,
    JOURNAL_DESC : DYN_DESC_DECL,
    OUTPUT_DESC : DYN_DESC_DECL;

BIND
	DYN_DESC = JOURNAL_DESC : $BBLOCK,	!Used by MAIL$LOAD_EDT
	DYN_DESC_2 = COMMAND_DESC : $BBLOCK,	! ditto
	NL_DESC = $DESCRIPTOR('_NL:'),
	NO_FILE_DESC = $DESCRIPTOR(''),
	SYSIN_DESC = $DESCRIPTOR('SYS$INPUT'),
	JOU_FILE_DESC = $DESCRIPTOR('SYS$SCRATCH:MAIL.JOU');
!
! EXTERNAL REFERENCES:
!

EXTERNAL LITERAL
	CLI$_NEGATED,				! Explicitly negated qualifier
	CLI$_LOCNEG,				! Locally negated
	MAIL$C_TMP_PRO,				! Temporary file protection
	SMG$_EOF;				! SMG eof value

EXTERNAL
	MAIL$L_MYPID,				! Process pid
	MAIL$W_MSG_RSIZ : WORD,			! Seq. msg. size
	MAIL$L_MSG_RADR,			! Seq. msg address
	MAIL$L_MSG_STS,				! Seq. msg status
	MAIL$GL_FLAGS : $BBLOCK,		! Control flags
	MAIL$SPAWN_CMDS,			! SPAWN/ATTACH cld commands
	MAIL$L_SMG_KEYBOARD,			! SMG keyboard id
	MAIL$Q_INPTRAN:	BLOCK[,BYTE],		! SYS$INPUT translation
	MAIL$Q_EDITNAM_DESC: BLOCK[,BYTE],	! translation of MAIL$EDIT
	MAIL$Q_CALEDTNAM : $BBLOCK,		! Name of editor if callable
	MAIL$Q_USERNAME : $BBLOCK;		! User's name

EXTERNAL ROUTINE
	CLI$DCL_PARSE,				! Parse command line
	CLI$DISPATCH,				! and dispatch on it
	CLI$GET_VALUE,				! Get qualifier value
	CLI$PRESENT,				! Test qualifier present
	LIB$GET_INPUT,				! Read from SYS$INPUT
	LIB$PUT_OUTPUT,				! Write to SYS$OUTPUT
	LIB$SPAWN,				! Spawn a subprocess
	MAIL$DECR_NEWMAIL,			! Decrement new mail count
	MAIL$DISABLE_CTRLC,			! Disable CTRL/C handling
	MAIL$EXTRACT_MESSAGE,			! Copy message text to file
	MAIL$GET_MSG,				! Read seq. mail record
	MAIL$GET_I_MSG,				! Read isam mail record
	MAIL$GETMSG,				! Get error message text
	MAIL$LOAD_LBRSHR,			! Load LBRSHR
	MAIL$NEW_MSG,				! Test if new message
	MAIL$PUT_OUTPUT,
	MAIL$REWIND_I_MSG,			! Rewind isam mail msg
	SMG$READ_STRING,			! Read string
	STR$CONCAT,				! String concatenation
	STR$COPY_DX,				! String copy routine
	STR$FREE1_DX,				! Free dynamic string
	UTIL$REPORT_IO_ERROR,			! Report i/o error
	LIB$FIND_IMAGE_SYMBOL;			! Load image, find symbol val
!
! Define local names for shared messages
!
$SHR_MSGDEF(MAIL,126,LOCAL,
	(READERR,ERROR),
	(OPENIN,ERROR),
	(OPENOUT,ERROR),
	(CLOSEOUT,ERROR),
	(FILNOTDEL,WARNING),
	(WRITEERR,WARNING));
!
! Table of symbol names
!
OWN
    XYZ_HANDLER;

MACRO EDTSYM(EDTNAME) =
    PSECT OWN = $OWN$;

    OWN %NAME('EDT_',EDTNAME) : LONG;

    PSECT OWN = EDT_ADDRESSES (NOWRITE,EXECUTE);

    OWN %NAME(EDTNAME,'_ADDR'): INITIAL(%NAME('EDT_',EDTNAME));

    PSECT OWN = EDT_NAMES (NOWRITE,EXECUTE);

    OWN %NAME(EDTNAME) : VECTOR[2,LONG]
		INITIAL(%CHARCOUNT(%NAME('EDT$',EDTNAME)),
			UPLIT(%STRING('EDT$',%NAME(EDTNAME))));

    UNDECLARE %NAME(EDTNAME,'_ADDR'),%NAME(EDTNAME)%;

PSECT OWN = EDT_ADDRESSES(NOWRITE,EXECUTE);

OWN
   EDT_ADDR_HEAD : VECTOR[0,LONG];

PSECT OWN = EDT_NAMES(NOWRITE,EXECUTE);

OWN
    EDT_NAMES_HEAD : VECTOR[0,LONG];

EDTSYM(M_RECOVER);
EDTSYM(M_NOJOURNAL);
EDTSYM(M_NOOUTPUT);
EDTSYM(M_NOCOMMAND);
EDTSYM(M_NOCREATE);
EDTSYM(K_COMMAND_FILE);
EDTSYM(K_INPUT_FILE);
EDTSYM(K_OPEN_INPUT);
EDTSYM(K_GET);
EDTSYM(K_CLOSE);
EDTSYM(EDIT);
EDTSYM(FILEIO);

PSECT OWN = EDT_ADDRESSES;

OWN
    EDT_ADDR_END : LONG INITIAL(0);		!Mark end of table

PSECT OWN = $OWN$;

!
! Define names for qualifier name descriptors
!
SD (
    'EDTSHR',
    'COMMAND',
    'CREATE',
    'INPUT',
    'JOURNAL',
    'OUTPUT',
    'READ',
    'RECOVER');

GLOBAL ROUTINE MAIL$LOAD_EDT =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Load EDT if it has not been loaded
!
!--
BEGIN

LOCAL
    EDTINDEX;

IF NOT .MAIL$GL_FLAGS[MAIF_V_CALEDT]
    THEN RETURN SIGNAL(MAIL$_NOTCALEDT);

IF .EDT_EDIT NEQ 0
    THEN RETURN TRUE;

!
! Make sure LBRSHR is loaded first
!
IF_ERR(MAIL$LOAD_LBRSHR();,
	RETURN .STATUS);

IF .MAIL$GL_FLAGS[MAIF_V_EDTEDT]
THEN BEGIN
    EDTINDEX = 0;
    WHILE .EDT_ADDR_HEAD[.EDTINDEX] NEQ 0
    DO BEGIN
	IF_ERR(LIB$FIND_IMAGE_SYMBOL(SD_EDTSHR,EDT_NAMES_HEAD[.EDTINDEX*2],
				.EDT_ADDR_HEAD[.EDTINDEX]);,
		RETURN .STATUS);
	EDTINDEX = .EDTINDEX + 1;
	END;
    END
ELSE BEGIN
    STR$CONCAT(DYN_DESC,MAIL$Q_CALEDTNAM,$DESCRIPTOR('SHR'));
    STR$CONCAT(DYN_DESC_2,MAIL$Q_CALEDTNAM,$DESCRIPTOR('$EDIT'));
    IF_ERR(LIB$FIND_IMAGE_SYMBOL(DYN_DESC,DYN_DESC_2,EDT_EDIT);,
		RETURN .STATUS);
    IF .MAIL$GL_FLAGS[MAIF_V_EDTXYZ]
	THEN IF_ERR(LIB$FIND_IMAGE_SYMBOL(DYN_DESC,$DESCRIPTOR('TPU$HANDLER'),
							XYZ_HANDLER);,
		RETURN .STATUS);
    END;

RETURN TRUE
END;

ROUTINE CHECK_MESSAGE_FILE(OUT_DESC) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine determines whether the specified file was successfully
!	created and returns success if it was, and MAIL$_SENDABORT if not
!
! INPUTS:
!
!	OUT_DESC is a descriptor for the file to check
!--
BEGIN

MAP
    OUT_DESC : REF $BBLOCK;

LOCAL
    FAB : $FAB_DECL,
    NAM : $NAM_DECL,
    NAMESS : $BBLOCK[NAM$C_MAXRSS],
    STATUS;

$FAB_INIT(FAB=FAB,
	FNS=.OUT_DESC[DSC$W_LENGTH],
	FNA=.OUT_DESC[DSC$A_POINTER],
	NAM=NAM);

$NAM_INIT(NAM=NAM,
	ESS=NAM$C_MAXRSS,
	ESA=NAMESS,
	RSS=NAM$C_MAXRSS,
	RSA=NAMESS);
!
! If the PARSE or SEARCH fails, then return SENDABORT, otherwise return
! success
!
IF NOT $PARSE(FAB=FAB)
    OR NOT $SEARCH(FAB=FAB)
    THEN RETURN MAIL$_SENDABORT
    ELSE RETURN TRUE

END;

ROUTINE SEND_STRING (DESC) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Write string to SYS$OUTPUT
!
!--
BEGIN

LIB$PUT_OUTPUT(.DESC);
RETURN 0
END;

ROUTINE EDT_HANDLER (SIGARG, MECHARG) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Handler to handle EDT signalled errors.  Prevents EDT's fatal
!	errors from exiting MAIL
!--
BEGIN
MAP
    SIGARG : REF $BBLOCK,
    MECHARG : REF $BBLOCK;

BUILTIN
    CALLG,AP;

BIND
    SIGNAME = SIGARG[CHF$L_SIG_NAME] : $BBLOCK;

IF .SIGNAME EQL SS$_UNWIND
    THEN RETURN SS$_CONTINUE;

IF .MAIL$GL_FLAGS[MAIF_V_EDTXYZ]
    THEN RETURN CALLG(.AP,.XYZ_HANDLER);

IF NOT .SIGNAME
THEN BEGIN
    SIGARG[CHF$L_SIG_ARGS] = .SIGARG[CHF$L_SIG_ARGS] - 2;
    $PUTMSG(MSGVEC=SIGARG[CHF$L_SIG_ARGS],
		ACTRTN = SEND_STRING);
    SIGARG[CHF$L_SIG_ARGS] = .SIGARG[CHF$L_SIG_ARGS] + 2;
    SIGNAME[STS$V_SEVERITY] = STS$K_WARNING;
    END;

SETUNWIND();
RETURN 0
END;

ROUTINE EDT_HANDLER_2 (SIGARG, MECHARG) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Handler to handle EDT signalled errors.  Prevents EDT's fatal
!	errors from exiting MAIL.  This handler does not print the message.
!--
BEGIN
MAP
    SIGARG : REF $BBLOCK,
    MECHARG : REF $BBLOCK;

BIND
    SIGNAME = SIGARG[CHF$L_SIG_NAME] : $BBLOCK;

IF .SIGNAME EQL SS$_UNWIND
    THEN RETURN SS$_CONTINUE;

IF NOT .SIGNAME
    THEN SIGNAME[STS$V_SEVERITY] = STS$K_WARNING;

SETUNWIND();
RETURN 0
END;

ROUTINE CALL_EDT_FILEIO =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Calls EDT$FILEIO.  If attempting to open the user's EDTINI, enable
!	a condition handler so that the caller of this routine can get control
!	back.
!
BEGIN

BUILTIN
    CALLG,
    AP,
    FP;

!
! We only care about user's EDTINI not being found.  Let SIGNAL of FNF
! on system EDTINI go through to EDT.
!
IF .COMFILCNT EQL 1
    THEN .FP = EDT_HANDLER_2;

RETURN CALLG(.AP,.EDT_FILEIO)
END;

ROUTINE MAIL$EDT_FILEIO(FILE_CODE,FILE_STREAM,RECORD_DESC,RHB_DESC) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is called by EDT for all fileio.  It passes on most
!	calls, except for two special cases.  For the second call to open
!	the command 
!
!--
BEGIN

BUILTIN
    AP,
    CALLG;

MAP
    FILE_CODE : REF VECTOR[,BYTE],		!Assume codes are all bytes
    FILE_STREAM : REF VECTOR[,BYTE],		! and stream numbers
    RECORD_DESC : REF $BBLOCK,
    RHB_DESC : REF $BBLOCK;

LOCAL
    STATUS;

!
! If opening the main input file, set the default file type of .TXT
!
IF .FILE_STREAM[0] EQL .EDT_K_INPUT_FILE
    AND .FILE_CODE[0] EQL .EDT_K_OPEN_INPUT
THEN BEGIN
    STR$COPY_DX(.RHB_DESC,$DESCRIPTOR('.TXT'));
    RETURN CALLG(.AP,.EDT_FILEIO);
    END;
!
! Everything except command file i/o, call EDT$FILEIO
!
IF .FILE_STREAM[0] NEQ .EDT_K_COMMAND_FILE
THEN RETURN CALLG(.AP,.EDT_FILEIO)
ELSE BEGIN
    !
    ! If opening the command file, set flags and call special routine
    !
    IF .FILE_CODE[0] EQL .EDT_K_OPEN_INPUT
    THEN BEGIN
	COMNOSUM = 0;
	COMNOFILE = 0;
	COMFILCNT = .COMFILCNT + 1;	!Count the edtini
	!
	! This call will not return if there is a failure opening the
	! SYSTEM-wide EDTINI, but will return if there is a failure
	! opening the user's EDTINI
	!
	STATUS = CALLG(.AP,CALL_EDT_FILEIO);
	IF .COMFILCNT EQL 1		!If opening user's edtini
	THEN BEGIN
	    COMNOSUM = 1;		!Flag need to output SET NOSUMMARY
	    IF NOT .STATUS		!If file not there, pretend it was
		THEN COMNOFILE = STATUS = 1;!Return ok so EDT will do a GET
	    END;
	RETURN .STATUS
	END
    ELSE BEGIN
	!
	! a code of other than OPEN_INPUT...
	!
	IF .FILE_CODE[0] EQL .EDT_K_GET
	THEN BEGIN
	    !
	    ! If we need to send the SET NOSUMMARY line, do it, and clear flag
	    !
	    IF .COMNOSUM
	    THEN BEGIN
		STR$COPY_DX(.RECORD_DESC,$DESCRIPTOR('SET NOSUMMARY'));
		COMNOSUM = 0;
		RETURN 1;
		END;
	    IF .COMNOFILE		!If there was no file, return eof now
		THEN RETURN RMS$_EOF
		ELSE RETURN CALLG(.AP,.EDT_FILEIO); !Otherwise, just get record
	    END;
	IF .FILE_CODE[0] EQL .EDT_K_CLOSE
	    AND .COMNOFILE
	    THEN RETURN 1		!If closing non-ex file, pretend ok
	    ELSE RETURN CALLG(.AP,.EDT_FILEIO); !EDT will close real file
	END;
    END; 
END;

ROUTINE EDT_XLATE (C_DESC) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Process the XLATE command.  Specifically, SPAWN and ATTACH
!
!--
BEGIN
MAP
    C_DESC : REF $BBLOCK;

ENABLE EDT_HANDLER_2;

IF CLI$DCL_PARSE(.C_DESC,MAIL$SPAWN_CMDS,LIB$GET_INPUT)
    THEN CLI$DISPATCH();

STR$FREE1_DX(.C_DESC);

RETURN TRUE
END;

GLOBAL ROUTINE MAIL$EDIT(IN_NAME,OUT_NAME) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is called to enter and edit a mail message.
!
! INPUTS:
!
!	IN_NAME = Address of input file name descriptor.
!	OUT_NAME = Address of output file name descriptor.
!
! OUTPUTS:
!
!	Message copied to file OUT_NAME.
!
!--
BEGIN
MAP
	IN_NAME: REF BLOCK[,BYTE],			! Input file desc
	OUT_NAME: REF BLOCK[,BYTE];			! Output file desc

BUILTIN
    AP,
    CALLG;

LOCAL
	STATUS,						! Routine status
	FILEIO_BPV : VECTOR[2,LONG],
	XLATE_BPV : VECTOR[2,LONG],
	EDITCMD_BUF: 	BLOCK[255,BYTE],		! Edit command buffer
	EDITCMD_DESC: 	BLOCK[8,BYTE];			! Edit command desc

MAIL$DISABLE_CTRLC();
!
! If callable EDT requested then call EDT, otherwise create the
! editor subprocess.
!
IF .MAIL$GL_FLAGS[MAIF_V_CALEDT]
THEN BEGIN
	IF_ERR(MAIL$LOAD_EDT();,
		RETURN .STATUS);
	IF .MAIL$GL_FLAGS[MAIF_V_EDTEDT]
	THEN BEGIN
	    FILEIO_BPV[0] = MAIL$EDT_FILEIO;
	    FILEIO_BPV[1] = 0;
	    XLATE_BPV[0] = EDT_XLATE;
	    XLATE_BPV[1] = 0;
	    COMFILCNT = -1;
	    IF NOT (STATUS=(.EDT_EDIT)((IF .IN_NAME[DSC$W_LENGTH] EQL 0
				THEN NL_DESC
				ELSE .IN_NAME),
			.OUT_NAME,NO_FILE_DESC,JOU_FILE_DESC,
			%REF(0),FILEIO_BPV,0,XLATE_BPV))
		THEN RETURN .STATUS;
	    END
	ELSE IF NOT (STATUS = CALLG(.AP,.EDT_EDIT))
		THEN RETURN .STATUS;
	END
ELSE BEGIN
	!
	! Create and execute the command procedure execution command.
	!
	EDITCMD_DESC[0,0,32,0] = 255;
	EDITCMD_DESC[DSC$A_POINTER] = EDITCMD_BUF;
	$FAO(	DESCRIPTOR('$ @!AS "!AS" "!AS"'),
		EDITCMD_DESC[DSC$W_LENGTH],
		EDITCMD_DESC,
		(IF .MAIL$GL_FLAGS[MAIF_V_USEREDIT]
			THEN MAIL$Q_EDITNAM_DESC 
			ELSE DESCRIPTOR('SYS$SYSTEM:MAILEDIT.COM')),
		.IN_NAME,
		.OUT_NAME);
	IF_ERR(LIB$SPAWN(EDITCMD_DESC);,
		SIGNAL(MAIL$_EDITPROC,0,.STATUS));
	END;
RETURN CHECK_MESSAGE_FILE(.OUT_NAME)
END;

GLOBAL ROUTINE MAIL$ENTER(OUT_RAB) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is called to enter a mail message.
!
! INPUTS:
!
!	OUT_RAB = Address of a RAB connected to an open output file.
!
! OUTPUTS:
!
!	SYS$INPUT copied to file OUT_RAB.
!--
BEGIN
MAP
	OUT_RAB: REF BLOCK[,BYTE];			! Output file RAB
LOCAL
	DESC: BLOCK[8,BYTE],				! String desc
	STATUS;						! Routine status

IF .MAIL$GL_FLAGS[MAIF_V_ITERM]
    THEN MAIL$PUT_OUTPUT(MAIL$GETMSG(MAIL$_EDIT10));
!
! Read from input and copy to output file
!
DESC[DSC$W_LENGTH] = 0;
DESC[DSC$B_CLASS] = DSC$K_CLASS_D;
DESC[DSC$B_DTYPE] = 0;
DESC[DSC$A_POINTER] = 0;
STATUS = TRUE;

OUT_RAB[RAB$L_CTX] = MAIL$_WRITEERR;
WHILE 1
DO
	BEGIN
	DO
	    BEGIN
	    STATUS = SMG$READ_STRING(MAIL$L_SMG_KEYBOARD,DESC);
	    IF (.STATUS EQL SS$_BADESCAPE) THEN
				SIGNAL(RMS$_BES,0,MAIL$_REENTER);
	    END
	UNTIL (.STATUS NEQ SS$_BADESCAPE);
	IF (.STATUS EQL RMS$_TNS)
	    OR (.STATUS EQL SS$_DATAOVERUN)
	    THEN STATUS = SS$_NORMAL;
	IF NOT .STATUS
	THEN BEGIN
	    IF .STATUS EQL SMG$_EOF
		THEN EXITLOOP;
	    SIGNAL(MAIL$_READERR,1,SYSIN_DESC,.STATUS);
	    EXITLOOP;
	    END;
	IF .DESC[DSC$W_LENGTH] GTRU 255
	THEN BEGIN
	    SIGNAL(MAIL$_READERR,1,SYSIN_DESC,RMS$_RTB,.DESC[DSC$W_LENGTH]);
	    STATUS = RMS$_RTB;
	    EXITLOOP;
	    END;
	OUT_RAB[RAB$W_RSZ] = .DESC[DSC$W_LENGTH];
	OUT_RAB[RAB$L_RBF] = .DESC[DSC$A_POINTER];
	IF NOT (STATUS = $PUT(RAB = .OUT_RAB,ERR=UTIL$REPORT_IO_ERROR))
	    OR .MAIL$GL_FLAGS[MAIF_V_CTRLCFL] THEN EXITLOOP (STATUS = 0);
	END;

STR$FREE1_DX(DESC);

RETURN (IF .STATUS
	OR (.STATUS EQL SMG$_EOF)
	    THEN TRUE
	    ELSE MAIL$_SENDABORT)
END;

ROUTINE EDT_EXTRACT_IO(FILE_CODE,FILE_STREAM,RECORD_DESC,RHB_DESC) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is called by EDT when an EDT/EXTRACT is done.
!	This routine only handles input file i/o, and passes the rest
!	onto EDT's input routine
!
!--
BEGIN

LOCAL
    STATUS,
    MORE_FLAG,
    DESC : VECTOR[2,LONG];

BUILTIN
    AP,
    CALLG;

MAP
    FILE_CODE : REF VECTOR[,BYTE],
    FILE_STREAM : REF VECTOR[,BYTE],
    RECORD_DESC : REF $BBLOCK,
    RHB_DESC : REF $BBLOCK;
!
! If not input file i/o then pass it on to EDT
!
IF .FILE_STREAM[0] NEQ .EDT_K_INPUT_FILE
THEN RETURN CALLG(.AP,.EDT_FILEIO)
ELSE BEGIN
    IF .FILE_CODE[0] EQL .EDT_K_OPEN_INPUT
        OR .FILE_CODE[0] EQL .EDT_K_CLOSE
	THEN RETURN TRUE;
    IF .FILE_CODE[0] EQL .EDT_K_GET
    THEN BEGIN
	IF .MAIL$GL_FLAGS[MAIF_V_ISAM]
	THEN BEGIN
	    IF NOT MAIL$GET_I_MSG(DESC,MORE_FLAG)
		THEN RETURN RMS$_EOF;
	    STR$COPY_DX(.RECORD_DESC,DESC);
	    RETURN TRUE;
	    END
	ELSE BEGIN
	    IF NOT .MAIL$L_MSG_STS
		THEN RETURN RMS$_EOF;
	    DESC[0] = .MAIL$W_MSG_RSIZ;
	    DESC[1] = .MAIL$L_MSG_RADR;
	    STR$COPY_DX(.RECORD_DESC,DESC);
	    MAIL$GET_MSG();
	    RETURN TRUE;
	    END
	END
    ELSE SIGNAL(0);
    RETURN TRUE
    END;
END;

ROUTINE COPY_MSG(FAB,RAB,NAM) =
!++
! Copy the current message to a temporary file
!
!
!--
BEGIN
MAP
    FAB : REF $BBLOCK,
    RAB : REF $BBLOCK,
    NAM : REF $BBLOCK;

LOCAL
    SND_XABPRO : $XABPRO_DECL,
    STATUS,
    DESC : VECTOR[2,LONG];

DESC[0] = NAM$C_MAXRSS;
DESC[1] = .NAM[NAM$L_RSA];
$FAO((IF .MAIL$L_MYPID<16,16,0> NEQ 0
		THEN $DESCRIPTOR('SYS$SCRATCH:MAIL_!XL_EDIT.TMP')
		ELSE $DESCRIPTOR('SYS$SCRATCH:MAIL_!XW_EDIT.TMP')),
	DESC,DESC,.MAIL$L_MYPID);
$FAB_INIT(FAB=.FAB,
	FNS=.DESC[0],
	FNA=.DESC[1],
	FAC=(PUT,TRN),
	CTX=MAIL$_OPENOUT,
	NAM=.NAM,
	RAT=CR,
	RFM=VAR);

$XABPRO_INIT(XAB=SND_XABPRO,
	UIC=(0,0));

SND_XABPRO[XAB$W_PRO] = MAIL$C_TMP_PRO;

IF_ERR($CREATE(FAB=.FAB,ERR=UTIL$REPORT_IO_ERROR);,
	RETURN .STATUS);

FAB[FAB$L_XAB] = 0;
FAB[FAB$B_FNS] = .NAM[NAM$B_RSL];
DESC[0] = .NAM[NAM$B_RSL];
$RAB_INIT(RAB=.RAB,
	CTX=MAIL$_OPENOUT,
	FAB=.FAB);

IF_ERR($CONNECT(RAB=.RAB,ERR=UTIL$REPORT_IO_ERROR);,
	.FAB[FAB$V_DLT] = 1;
	$CLOSE(FAB=.FAB);
	RETURN .STATUS);

RAB[RAB$L_CTX] = MAIL$_WRITEERR;
STATUS = MAIL$EXTRACT_MESSAGE(1,.RAB);
FAB[FAB$L_CTX] = MAIL$_CLOSEOUT;
IF_ERR($CLOSE(FAB=.FAB,ERR=UTIL$REPORT_IO_ERROR);,
	RETURN .STATUS);

STR$COPY_DX(INPUT_DESC,DESC);
RETURN TRUE
END;

ROUTINE DELETE_TMP(FAB) =
!++
! Delete the file that FAB describes
!
!--
BEGIN
MAP
    FAB : REF $BBLOCK;

FAB[FAB$V_DLT] = TRUE;
FAB[FAB$L_CTX] = MAIL$_OPENIN;
IF_ERR($OPEN(FAB=.FAB,ERR=UTIL$REPORT_IO_ERROR);,
	RETURN .STATUS);
FAB[FAB$L_CTX] = MAIL$_FILNOTDEL;
IF_ERR($CLOSE(FAB=.FAB,ERR=UTIL$REPORT_IO_ERROR);,
	RETURN .STATUS);

RETURN TRUE
END;

ROUTINE CALL_EDT_EDIT (FLAGS,FILEIO_RTN) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Call EDT to edit the file.  Done this way so that if EDT signals
!	an error, the handler does a default unwind to the caller of this
!	routine
!--
BEGIN

LOCAL
    FAB : $FAB_DECL,
    NAM : $NAM_DECL,
    RAB : $RAB_DECL,
    STATUS,
    TMPFAB : $FAB_DECL,
    TMPNAM : $NAM_DECL,
    TMPESS : $BBLOCK[NAM$C_MAXRSS],
    TMPRSS : $BBLOCK[NAM$C_MAXRSS],
    NAMBUF : $BBLOCK[NAM$C_MAXRSS],
    XLATE_BPV : VECTOR[2,LONG],
    FILEIO_BPV : VECTOR[2,LONG];

ENABLE EDT_HANDLER;

!
! Initalize temporary file FAB
!
$FAB_INIT(fab=tmpfab,
	  fns=.input_desc[dsc$w_length],
	  fna=.input_desc[dsc$a_pointer],
	  nam=tmpnam);

$NAM_INIT(NAM=TMPNAM,
	ESS=NAM$C_MAXRSS,
	ESA=TMPESS,
	RSS=NAM$C_MAXRSS,
	RSA=TMPRSS);

IF NOT (status=$PARSE(fab=tmpfab)) THEN 
                 SIGNAL(MAIL$_OPENIN,1,input_desc,.status);

IF .MAIL$GL_FLAGS[MAIF_V_EDTEDT]
THEN BEGIN
    XLATE_BPV[0] = EDT_XLATE;
    XLATE_BPV[1] = 0;
    IF .FILEIO_RTN EQL 0
	THEN (.EDT_EDIT)(INPUT_DESC,OUTPUT_DESC,
			COMMAND_DESC,JOURNAL_DESC,FLAGS,0,0,XLATE_BPV)
    ELSE BEGIN
	FILEIO_BPV[0] = EDT_EXTRACT_IO;
	FILEIO_BPV[1] = 0;
	(.EDT_EDIT)(INPUT_DESC,OUTPUT_DESC,COMMAND_DESC,JOURNAL_DESC,
			FLAGS,FILEIO_BPV,0,XLATE_BPV);
	END;
    RETURN TRUE
    END;
!IF .MAIL$GL_FLAGS[MAIF_V_EDTXYZ]
!THEN BEGIN
!    RETURN TRUE
!    END;
!
! Not an editor we know about.  If reading a mail message, then copy
! it to a temporary file.
!
IF .FILEIO_RTN NEQ 0
THEN BEGIN
    $NAM_INIT(NAM=NAM,
	RSS=NAM$C_MAXRSS,
	RSA=NAMBUF);
    IF_ERR(COPY_MSG(FAB,RAB,NAM);,
	RETURN TRUE);
    END;
(.EDT_EDIT)(INPUT_DESC,OUTPUT_DESC);
IF .FILEIO_RTN NEQ 0
    THEN DELETE_TMP(FAB);
RETURN TRUE
END;

GLOBAL ROUTINE MAIL$EDIT_READ_MSG =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Invoke the editor to read the curent message
!
!--
BEGIN
LOCAL
    EDT_FLAGS;

STR$FREE1_DX(INPUT_DESC);
STR$FREE1_DX(OUTPUT_DESC);
STR$FREE1_DX(JOURNAL_DESC);
STR$FREE1_DX(COMMAND_DESC);

IF_ERR(MAIL$LOAD_EDT();,
	RETURN .STATUS);

IF MAIL$NEW_MSG()
    THEN MAIL$DECR_NEWMAIL(MAIL$Q_USERNAME);

EDT_FLAGS = .EDT_M_NOOUTPUT OR .EDT_M_NOCREATE OR .EDT_M_NOJOURNAL;
CALL_EDT_EDIT(.EDT_FLAGS,EDT_EXTRACT_IO);

RETURN TRUE
END;

GLOBAL ROUTINE MAIL$CMD_EDIT =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Process the EDIT command by invoking callable EDT to edit the file
!
!--
BEGIN
LOCAL
    STATUS,
    EDT_FLAGS;

STR$FREE1_DX(INPUT_DESC);
STR$FREE1_DX(OUTPUT_DESC);
STR$FREE1_DX(JOURNAL_DESC);
STR$FREE1_DX(COMMAND_DESC);

CLI$GET_VALUE(SD_INPUT,INPUT_DESC);

IF_ERR(MAIL$LOAD_EDT();,
	RETURN .STATUS);

EDT_FLAGS = 0;
STATUS = CLI$PRESENT(SD_COMMAND);
IF .STATUS
    THEN STATUS = CLI$GET_VALUE(SD_COMMAND,COMMAND_DESC)
    ELSE IF .STATUS EQL CLI$_NEGATED
	OR .STATUS EQL CLI$_LOCNEG
	THEN EDT_FLAGS = .EDT_FLAGS OR .EDT_M_NOCOMMAND;

STATUS = CLI$PRESENT(SD_JOURNAL);
IF .STATUS
    THEN STATUS = CLI$GET_VALUE(SD_JOURNAL,JOURNAL_DESC)
    ELSE IF .STATUS EQL CLI$_NEGATED
	OR .STATUS EQL CLI$_LOCNEG
	THEN EDT_FLAGS = .EDT_FLAGS OR .EDT_M_NOJOURNAL;

STATUS = CLI$PRESENT(SD_OUTPUT);
IF .STATUS
    THEN STATUS = CLI$GET_VALUE(SD_OUTPUT,OUTPUT_DESC)
    ELSE IF .STATUS EQL CLI$_NEGATED
	OR .STATUS EQL CLI$_LOCNEG
	THEN EDT_FLAGS = .EDT_FLAGS OR .EDT_M_NOOUTPUT;

STATUS = CLI$PRESENT(SD_CREATE);
IF .STATUS EQL CLI$_NEGATED
    OR .STATUS EQL CLI$_LOCNEG
    THEN EDT_FLAGS = .EDT_FLAGS OR .EDT_M_NOCREATE;

IF CLI$PRESENT(SD_READ)
    THEN EDT_FLAGS = .EDT_FLAGS OR .EDT_M_NOOUTPUT OR .EDT_M_NOCREATE
						OR .EDT_M_NOJOURNAL;

CALL_EDT_EDIT(.EDT_FLAGS,0);

RETURN TRUE
END;

END
ELUDOM
