MODULE RM3SIDXSP (LANGUAGE (BLISS32) ,
		IDENT = 'V04-000'
		) =
BEGIN
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************

!++
!
! FACILITY:	RMS32 INDEX SEQUENTIAL FILE ORGANIZATION
!
! ABSTRACT:
!                Split SIDR data level or any index level 50-50
!
!
! ENVIRONMENT:
!
!		VAX/VMS OPERATING SYSTEM
!
!--

!
! AUTHOR:        Christian Saether	     CREATION DATE:        	1-AUG-78  10:18
!
!
! MODIFIED BY:
!
!	V03-015 MCN0004		Maria del C. Nasr	04-Apr-1983
!		Change linkage of RM$COMPRESS_KEY.
!
!	V03-014	MCN0003		Maria del C. Nasr	22-Mar-1983
!		More changes in the linkages
!
!	V03-013 MCN0002		Maria del C. Nasr	28-Feb-1983
!		Reorganize linkages
!
!	V03-012	TMK0010		Todd M. Katz		05-Nov-1982
!		Document SIDR bucket splits, much as index bucket splits were
!		documented by TMK0005.
!
!	V03-011	TMK0009		Todd M. Katz		02-Oct-1982
!		I made a mistake when I re-wrote the routine RM$EXT_HIGH_KEY.
!		If the bucket whose key is to be extracted is a prologue 3 index
!		bucket with non-compressed keys, then there is no need to scan
!		the bucket to position to the high key of the bucket because all
!		the records are of a fixed size. I made an error in making this
!		check. What I ended up checking for was for a prologue 3 index
!		bucket with compressed keys rather than a prologue 3 bucket with
!		non-compressed keys.
!
!	V03-010	TMK0008		Todd M. Katz		14-Sep-1982
!		Add support for prologue 3 SIDRs. This involves modifications
!		to RM$SPLIT_EM, RM$COMP_SPL_PNT, and RM$MOVE_VBN, and the
!		re-write of RM$EXT_HIGH_KEY.
!
!	V03-009	KBT0233		Keith B. Thompson	23-Aug-1982
!		Reorganize psects
!
!	V03-008	TMK0007		Todd M. Katz		02-Jul-1982
!		Implement the RMS cluster solution for next record positioning.
!		This means that code must be added to reassign the ID's in
!		the new SIDR bucket following a SIDR bucket split instead of
!		calling the routine RM$ID_AND_NRP to do this (because that 
!		routine along with all the others in the module RM3NRP are 
!		disappearing.
!
!	V03-007	TMK0006		Todd M. Katz		16-Jun-1982
!		Make a change to the routine COMP_SPL_PNT which affects how the
!		split point of a prologue 3 index bucket with compressed keys
!		is calculated. In such a bucket, the keys are separate from 
!		the VBNs, and only the keys contribute to the end-of-bucket
!		calculation. However, both the keysize and the VBN size of the
!		new index record(s) to be added where influencing where the
!		split point should be instead of just the key size. This is
!		wrong, and lead to a nonoptimum calculation of the index
!		bucket split point. Change this such that only the key size of
!		the new record(s) influences where the index bucket split point
!		is computed to be.
!
!	V03-006	TMK0005		Todd M. Katz		15-Jun-1982
!		Add documentation at the fron of the routine for index bucket
!		update and split cases.
!
!	V03-005	TMK0004		Todd M. Katz		11-Jun-1982
!		When the code was added for the missing index bucket split 
!		cases in TMK0002, it accidently broke the two-pass multi-bucket
!		split cases where one of the two new index records goes in
!		each of the index buckets resulting from the split. The reason
!		for this is that I set the position of insertion of the new
!		records in the new (right) index bucket, IRB$W_POS_INS, to be
!		at the beginning of the bucket, before that parameter could
!		be used to diffrentiate between the two two-pass multibucket
!		index bucket split cases (both in one bucket vs. one in each).
!		The end result was that no matter what two-pass multi-bucket
!		split case had occurred, it was handled the same - as a both
!		in the same bucket two-pass multi-bucket split case. In the
!		case of the the other two-pass multi-bucket split case this
!		would result in failure to insert a new key-VBN pair into the
!		new (right) index bucket. The fix simply is to set 
!		IRB$W_POS_INS after the differentiation has been made as to the
!		type of two-pass multi-bucket index bucket split that had 
!		occurred.
!
!	V03-004	TMK0003		Todd M. Katz		26-May-1982
!		Performance Enhancement to the routine EXT_HIGH_KEY. This
!		routine extracts the high key of the old (left) bucket for
!		use in updating the index level above. This extraction must
!		include the key's re-expansion if index key compression is
!		enabled. The way this routine is currently written mandates
!		two complete passes down the index bucket - one to find the 
!		high key and the other to uncompress it. By setting the field
!		IRB$L_LST_NCMP, during the first scan, to the last 
!		noncompressed index key in the entire index bucket it is 
!		possible to cut down on the amount of the index bucket which 
!		is necessary to scan in order to re-expand the high key.
!
!	V03-003	TMK0002		Todd M. Katz		11-May-1982
!		Add support for the two two-pass index bucket split cases
!		which currently are not supported and return an alternate
!		success status of index not updated. These two-pass index
!		bucket split cases are: two-pass two-bucket with empty
!		bucket split and two-pass multi-bucket with empty bucket
!		split. In the case of the former split case, the routine
!		RM$INS_REC will only be called once since there is only a 
!		need to swing the level-one index downpointer of the new 
!		index bucket's low-order index record from the leftmost data 
!		bucket to the rightmost new bucket. In the case of a two-pass 
!		multi-bucket with empty bucket split case, the routine 
!		RM$INS_REC is called twice. First, the new key in keybuffer 2 
!		is inserted into the old (left) index bucket along with the 
!		VBN that corresponds to it (in IRB$L_VBN_MID). The second time
!		this routine is called the VBN downpointer of the new (right) 
!		index bucket's low-order index record is swung from the 
!		leftmost to the rightmost bucket.
!
!	V03-002	TMK0001		Todd M. Katz		21-Apr-1982
!		The routine COMP_SPL_PNT is responsible for computing the
!		index bucket split point. Under certain circumstances, it
!		will sometimes have to find the record size of the index 
!		record(s) which are to be inserted. This record size comes in
!		two parts - key and VBN, which must be added together. Because
!		the macros used to define the VBN offsets were wrong, this
!		mean't that when the total size of the new record(s) was 
!		computed, it was computed incorrectly. This could lead to the
!		split point being incorrectly calculated, and to a RMS 
!		signalled bugcheck in at least one case. To fix this problem,
!		I fixed the macro definitions, and but them in ONE place.
!
!	V03-001	MCN0001		Maria del C. Nasr	25-Mar-1982
!		Use macro to get key buffer address.
!
!	V02-019	KPL0001		Peter Lieberwirth	 2-Mar-1982
!		Define linkage omitted in v02-018
!
!	V02-018	TMK0004		Todd M. Katz	01-Mar-1982
!		Add support for rear-end truncation of keys in the index
!		of prologue 3 files with compressed keys. This involves changes
!		to RM$SPLIT_EM. When an index bucket split occurs, the new
!		(right) bucket is constructed without any thought as to where
!		the new index records will be inserted. If the prologue 3 file
!		contains compressed index keys, then the compression of the
!		first key in the new bucket must be redetermined. At the very
!		least, the key must be expanded so that it is zero front
!		compressed. As any change in front compression may affect 
!		rear-end truncation, the entire compression of the first key
!		must be redetermined.
!
!	V02-017	TMK0003		Todd M. Katz	12-Feb-1982
!		It is possible for the two-pass two-bucket split case to be
!		confused with the two-pass multibucket split case where both
!		keys are to go in the new bucket. This will occur when each
!		index bucket can only hold two keys, an index bucket containing
!		two keys (the second of which is nonzero front compressed) must
!		split to make room for an additional key, and the insertion 
!		point is computed to be at the beginning of the bucket. In this
!		case, both the insertion point and the split point are at the
!		beginning of the bucket. Since RMS doesn't always check for a
!		multibucket case when it wants to special case the special 
!		multibucket split case described above because it wrongly
!		assumes that the insertion point can only be at the beginning 
!		of a bucket in the speical two-pass multibucket split case,
!		the two-bucket case can be confused with the multibucket case.
!		Add checks for a multibucket split in all instances when it
!		isn't absolutly clear which of the two split cases is taking 
!		place.
!
!	V02-016	TMK0002		Todd M. Katz	25-Jan-1982
!		Made multiple changes affecting bucket splitting of
!		index buckets. These changes affect all prologs, and both
!		compressed and noncompressed prologue 3 keys.
!
!		1. When the new key is to be inserted as the very first record 
!		   in the new (right) index bucket following an index bucket 
!		   split, the offset to the point of insertion, 
!		   IRAB[IRB$W_POS_INS], in the new bucket was not being 
!		   correctly computed. This was because the amount of front 
!		   compression of the new low order key is saved before it is
!		   uncompressed, and then added to the offset. This is correct 
!		   except when the new key to be inserted will become the very 
!		   first key in the new bucket, and thus preceed it. What RMS 
!		   will now do is move the records into the new bucket 
!		   regardless of where the new record will be inserted, extract
!		   the amount of front compression of the new low order key and
!		   uncompress it, zero the amount of front compression if the
!		   new key is to be inserted as the very first key in the new
!		   bucket, and then proceed to insert the new key.
!
!		2. The series of checks made before incrementing the pointer,
!		   IRAB[IRB$L_LST_NCOMP], to the last noncompressed key seen
!		   was not stringent enough. What must be checked is that
!		   the current position in the bucket, REC_ADDR, is less than
!		   the point of insertion, INS_PNT. What was being checked
!		   was whether the bucket scan had past the insertion point.
!		   Since REC_ADDR is incremented to the next key position
!		   and the pointer to the last noncompressed key seen adjusted
!		   before the check is made as to whether the current bucket
!		   position is also the point of insertion, it was possible
!		   for the last noncompressed key pointer to be incremented
!		   to the key which will follow the new key when the latter 
!		   is eventually inserted. If the new key, and the key which
!		   follows it (and is pointed at by the last noncompressed
!		   key pointer) share some common front characters, the front
!		   compression of the new key will be incorrect, and the index
!		   will be corrupted.
!
!		3. There was no code handling the situation when a prologue 3
!		   index bucket splits, and the point of insertion of the new 
!		   key(s) is at the split point. In this instance, changes
!		   must be made to both the old, and the new index bucket.
!		   More specifically, if a multibucket split occurs, a new
!		   key is inserted in both the old (as the high key) and the 
!		   new (as the low key) index buckets, and a VBN pointer in the
!		   new index bucket bucket must be swung from 
!		   IRAB[IRB$L_VBN_LEFT] (its value before the split occurred) 
!		   to IRAB[IRB$L_VBN_RIGHT]. If a nonmultibucket split occurs,
!		   a new key is inserted as the high order key in the old
!		   index bucket, and the same VBN pointer swing, described
!		   above, occurs. These changes are made by forcing prologue 3
!		   files to go through the same top-level code sequence as
!		   prologue 1 and 2 files, affecting must of the changes in
!		   lower level routines.
!
!		4. In those cases when there is a key to go in the old index
!		   bucket, and the point of insertion is at the point at 
!		   which the bucket was split, and empty buckets are involved,
!		   do not update the index, and instead return an alternate
!		   success status of index not updated. Previously, the
!		   multibucket split empty bucket case was handled exactly
!		   like this, and for the two-bucket split empty bucket case,
!		   a situation which should almost never happen, the existing 
!		   code for nonprologue 3 files did not handle it correctly, and
!		   there was no code for prologue 3 files.
!
!		5. It is possible for both the point of insertion and the
!		   the split point to be at the very first record in an index
!		   bucket. This will occur when the key size is such that it
!		   is possible for two index records to be in the same bucket,
!		   and a multibucket split has occurred requiring updating of
!		   such a bucket. In this case, we want to put both new keys
!		   in the old bucket, but still swing the VBN pointer of what
!		   will become the low order key in the new index bucket.
!		   The key updating is accomplished by lower routines which
!		   will notice that not only is IRAB[IRB$V_BIG_SPLIT] and
!		   IRAB[IRB$V_SPL_IDX] set but that the point of insertion
!		   is at the very first key position of the old index bucket.
!		   That just the VBN swing should be performed for this
!		   multibucket split case will be signalled by clearing
!		   IRAB[IRB$L_VBN_MID] if the point of insertion is at the
!		   very first key position. This is contrary to what normally
!		   would occur when a multibucket split has occurred and the
!		   point of insertion is also the split point.
!
!		6. Made two changes in the computation of the split point
!		   of a prologue 3 index bucket with noncompressed keys. First,
!		   if the point of insertion of the new index record(s) is the
!		   same as that of the split point, the new index record (at
!		   least one of them) will be put in the old bucket. Second,
!		   if the new index record is to go in the old bucket and 
!		   there is insufficient room, an additional record is moved
!		   out to make room only if the point of insertion and the 
!		   split point are not the same. If they are the same, this
!		   inability to fit both records must be do to a multibucket 
!		   split since all records are the same size and at least one
!		   has been moved out. In such a case one new index record
!		   will go in the old bucket, and the second in the new index 
!		   bucket, and so no action need be taken.
!
!		7. Made a change in the computation of the split point
!		   of a prologue 2 index bucket, SIDR bucket or prologue 3
!		   index bucket with compressed keys. Only if the new record
!		   is to go in the old bucket, and there appears to be
!		   insufficient room for it, and the split point and
!		   insertion points are not the same do we make more room by 
!		   moving out additional records. This can only occur for
!		   SIDR buckets. For index buckets there will always be
!		   sufficent room unless a multibucket split has occurred
!		   requiring the insertion of two new keys. But in such
!		   instances the bucket will be split at the insertion point
!		   and one key will end up in the old and the other in the
!		   new index bucket.
!
!	V02-015	TMK0001		Todd M. Katz	09-Jan-1982
!		Made two changes affecting bucket splitting of 
!		index buckets with compressed keys. 
!
!		1. In some cases when the key to be inserted was to
!		   go in the new (right) bucket, the pointer to the
!		   last noncompressed key, IRB$L_LST_NCOMP, pointed to
!		   a key preceeding the insertion point in what will 
!		   become the old (left) bucket. This resulted in the 
!		   incorrect determination of the amount of front
!		   compression of the new key, and corruption of the file.
!		   Update this pointer to the first key in the new bucket
!		   if it does not point to a key in the new bucket
!		   preceeding the insertion point.
!
!		2. The routine RM$RECORD_SIZE returns the length of the new
!		   index record to be inserted in two parts. The first word
!		   is the key size, and the second word of the longword
!		   is the VBN size. However, the routine COMP_SPL_PNT
!		   thought that only a single value was returned. Thus, when
!		   the split point of a index bucket with compressed keys
!		   was being determined, and the routine encountered in its
!		   scan of the the bucket the point of insertion and had to 
!		   take into account the size of the new record, the resulting
!		   incorrect use of the record size returned prevented the 
!		   proper determination of the split point. In fact the 
!		   incorrect use of the record size returned resulted in the 
!		   inability to correctly split an index bucket whenever the
!		   new key was to go in the old (left) side.
!
!	V02-014	PSK0006		P S Knibbe	14-Dec-1981
!		Change RECORD_SIZE to take BKT_ADDR as an input
!
!	V02-013	PSK0005		P S Knibbe	13-Nov-1981
!		Change COMP_SPL_PNT to keep track of last record
!		with no front compression and the SPL_COUNT for
!		compressed keys
!
!	V02-012	PSK0004		P S Knibbe	26-Oct-1981
!		Add support for splitting compressed buckets
!
!	V02-011 PSK0003		P S Knibbe	25-Oct-1981
!		Set the AP flags correctly when calling RM$RECORD_KEY
!
!	V02-010	PSK0002		P S Knibbe	07-Oct-1981
!		Make sure the ptr_sz from one bucket is correctly
!		moved into the new bucket when a split occurs.
!
!	V02-009	PSK0001		P S Knibbe	07-Aug-1981
!		Add support for prologue three indexes.
!
!	V02-008	CDS0071		C D Saether	26-Feb-1981	20:00
!		Return error on spl_idx, non-empty, big_split case.
!
!	V02-007	REFORMAT	R A SCHAEFER	23-Jul-1980	14:15
!		Reformat the source.
!
!	V02-006	CDS0070		C D SAETHER	14-JAN-1980	14:35
!		Fix splitting alternate data level when no dupes count
!		field present in record.  Use rm$rec_ovhd routine.
!
! REVISION HISTORY:
!
!   Wendy Koenig, 	12-OCT-78  14:46
!   X0002 - CHANGE THE NRP STUFF
!
!   Wendy Koenig, 	24-OCT-78  14:03
!   X0003 - MAKE CHANGES CAUSED BY SHARING CONVENTIONS
!
!   Wendy Koenig, 	3-NOV-78  11:35
!   X0004 - GET RID OF ROUTINE RM$ID_AND_NRP
!
!   Christian Saether, 	26-JAN-79  9:45
!   X0005 - don't split insert of index entries on empty bucket cases
!
!*****

!
! 
! 		          Index Bucket Update Cases
! 
!     There are four and only four index bucket update cases: two-bucket, 
! two-bucket with empty bucket, multi-bucket, and multi-bucket with empty 
! bucket. I will discuss these cases from the point of view of updating the 
! index following a primary data bucket split.
! 
! 
! Two-bucket Index Bucket Update Case.
! 
!     When a primary data bucket splits roughly in half, the high key of the 
! bucket now becomes the high key of the new (right) bucket, and the old (left)
! bucket has a new key which is not yet represented in the index. If there is
! sufficient room in the level 1 index bucket for a new index record pointing
! to the old (left) bucket then a two-bucket index bucket update is performed.
! This index bucket update case has four steps to it.
! 
!      1. Position to the index record pointing to the bucket before the split.
! 	  This index record's key will be identical to the high key of the
! 	  new (right) bucket, but its VBN downpointer will be to the old (left)
! 	  bucket.
! 
!      2. Make sufficient room for the new index record. This step is very 
! 	  prologue dependent.
! 
!      3. Insert the new index record. The key of this new index record will 
! 	  be the new high key of the old (left) data bucket while the VBN 
! 	  downpointer will also be to old bucket.
! 
!      4. Position to the record following this new index record. Of course, 
! 	  the key of this index record was the high key of the data bucket 
! 	  before the split, and it is now the high key of the new (right) 
! 	  bucket. However, its VBN downpointer will still be pointing to the 
! 	  old bucket that has just split and not to the new (right) bucket. 
! 	  Change this index record's VBN downpointer from pointing to the old 
! 	  (left) bucket, to pointing to the new (right) bucket. 
! 
! 
! Two-bucket with Empty Bucket Index Bucket Update Case.
! 
!      If after performing a data bucket split one new bucket has been added, 
! and the left bucket is found to be empty, then index maintenance consists of 
! performing a two-bucket with empty bucket index bucket update. There are a 
! number of primary data bucket split cases that can result in this particular
! index maintenance case, but they all will be handled the same as far as the
! index update is concerned. Note that for this particular index bucket update
! case the new bucket is regarded as the "middle" bucket, and there is no 
! "right" bucket. Three steps are involved in the index update.
! 
!      1. Position to the index record pointing to the bucket before the split.
! 	  This index record's key will be identical to the high key of the
! 	  new (right) bucket.
! 
!      2. If the VBN downpointer of this index record does NOT point to the 
! 	  data bucket that has split (the old or left data bucket) then do NOT
! 	  data the index update. If this index update was performed, then RMS 
! 	  would be causing crossed downpointers to the primary data level below
! 	  and would no longer be able to retrieve certain records randomly by 
! 	  their primary key value.
! 
!      3. If the VBN downpointer of this index record does point to the data 
! 	  bucket that has split, then update its VBN downpointer so that it now
! 	  points to the new (middle) bucket (whose high key value is the same 
! 	  as the key of the index record, and was the same as the high key of 
!  	  the old data bucket before it split, and the old (left) bucket became
! 	  empty), instead of pointing to the old (left) bucket which is now 
! 	  empty. 
! 
! Note that this in effect removes the old (left) bucket from the index tree
! (there is no index record with a VBN downpointer pointing to it), but this is
! acceptable because the bucket is empty. The empty bucket remains linked into 
! the horizontal data bucket chain.
! 
! 
! Multi-bucket Index Bucket Update Case.
! 
!      If a multi-bucket split has occurred at the primary data level then the
! old (left) bucket and the new middle bucket contain new high keys, and the 
! new right bucket contains as its high key the high key of the splitting data 
! bucket before the split took place. In such a situation RMS will attempt a 
! multi-bucket index bucket update provided there is sufficient room in the 
! level one index bucket to contain the two new index records (one for each of 
! the new buckets) which must be added. This index bucket update case consists 
! of five steps.
! 
!      1. Position to the index record pointing to the bucket before the split.
! 	  This index record's key will be identical to the high key of the
! 	  new right bucket, but its VBN downpointer will be to the old (left)
! 	  bucket.
! 
!      2. Make sufficient room in the index bucket for the two new index 
! 	  record. This step is very prologue dependent.
! 
!      3. Insert the first of the two new index records. The key of this new 
! 	  index record will be the new high key of the old (left) data bucket 
! 	  while the VBN downpointer will also be to old bucket.
! 
!      4. Insert the second of the two new index records after the first. The 
! 	  key of this new index record will be the new high key of the new 
! 	  middle data bucket while the VBN downpointer will also be to the new 
! 	  middle bucket.
! 
!      5. Position to the record following the new index records. Of course, 
! 	  the key of this index record was the high key of the data bucket 
! 	  before the split, and it is now the high key of the new right bucket.
! 	  However, its VBN downpointer will still be pointing to the old bucket
! 	  that has just split and not to the new right bucket. Change this 
! 	  index record's VBN downpointer from pointing to the old (left) bucket
! 	  to pointing to the new right bucket. 
! 
! 
! Multi-bucket with Empty Bucket Index Bucket Update Case.
! 
!      If a multi-bucket split has occurred at the primary data level, and 
! following the split the bucket splitting (the old or left bucket) is empty
! then RMS will attempt a multi-bucket with empty bucket index bucket update
! provided there is sufficient room in the level one index bucket for the new
! index record that must be added. There is only a need to add one new index
! record in this particular index bucket update case, because although there
! will be be two new primary data buckets (the new middle bucket containing a 
! new high key and the new right bucket containing the high key of the old left
! bucket before the split took place) there is only one new high key. This 
! index bucket update consists of five steps.
! 
!      1. Position to the index record pointing to the bucket before the split.
! 	  This index record's key will be identical to the high key of the
! 	  new right bucket, but its VBN downpointer will be to the old (left)
! 	  bucket.
! 
!      2. Make sufficient room for the new index record. This step is very 
! 	  prologue dependent.
! 
!      3. Insert the new index record. The key of this new index record will 
! 	  be the new high key of the new middle data bucket while the VBN 
! 	  downpointer will also be to this bucket.
! 
!      4. Position to the record following this new index record. Of course, 
! 	  the key of this index record was the high key of the data bucket 
! 	  before the split, and it is now the high key of the new right bucket.
! 	  If the VBN downpointer of this index record does point to the bucket
! 	  that has just split (the old left bucket), then update the VBN 
! 	  downpointer so that it points to the new right bucket. Note that this
! 	  in effect removes the old (left) bucket from the index tree (there is
! 	  no index record with a VBN downpointer pointing to it), but this is 
! 	  acceptable because the bucket is empty. The empty bucket remains 
!  	  linked into the horizontal data bucket chain.
! 
!      5. If the VBN downpointer of the index record does not point to the 
! 	  bucket splitting (the old left) bucket then do NOT update the VBN 
! 	  downpointer so that it points to the new right data bucket. If this 
! 	  index update was performed, then RMS would be causing crossed 
! 	  downpointers to the primary data level below, and would no longer be
! 	  able to retrieve certain records randomly by their primary key value.
! 
! 
! 
! 			Index Bucket Split Cases
! 
!     There are four one-pass and five two-pass index bucket split cases. The 
! four one-pass index bucket split cases are: two-bucket, two-bucket with empty
! bucket, multi-bucket, and multi-bucket with empty bucket. The five two-pass
! index bucket split cases are: two-bucket, two-bucket with empty bucket,
! multi-bucket case I, multi-bucket case II, and multibucket with empty bucket.
! I will discuss these cases from the point of view of updating the index 
! following a primary data bucket split.
! 
! 
! One-pass Two-bucket Index Bucket Split Case.
! 
!      Index maintenance will consist of a one-pass two-bucket index bucket 
! split when RMS is unable to perform a two-bucket index bucket update because
! there is insufficient room in the index bucket for the new index record, and
! either the split point of the index bucket and the position of insertion of 
! the new index record do not coincide, or if they do, the new index record is
! to go into the new (right) bucket. This particular split case consists of 
! three steps.
! 
!      1. Split the index bucket. This step is very prologue dependent.
! 
!      2. Perform a two-bucket index bucket update on the index bucket (old or 
! 	  new) which after the index bucket split is to contain the new index
! 	  record which is to be added.
! 
!      3. As there has been a split of the level one index bucket, the level 
! 	  two index bucket containing the index record with the VBN downpointer
! 	  pointing to this level one index bucket must be updated. If the index
! 	  bucket splitting was the root bucket, a new root bucket is created, 
! 	  and then the index update is performed.
! 
! 
! One-pass Two-bucket with Empty Bucket Index Bucket Split Case.
! 
!      Index maintenance will consist of a one-pass two-bucket with empty 
! bucket index bucket split when RMS is unable to perform a two-bucket with 
! empty bucket index bucket update because the pointer size required to hold 
! the VBN of the new (right) bucket is greater than that required to hold the 
! VBN of the old (left) empty bucket, there is insufficient room in the index 
! bucket to accommidate the new size, and either the split point of the index 
! bucket and the position of the index record whose VBN downpointer is to be 
! updated do not coincide, or if they do, the index record will exist in the 
! new (right) bucket following the index bucket split. This is extremely 
! prologue dependent. It can be expected that this split case will occur much 
! more frequently in the case of prologue 3 files, where the VBN downpointer 
! size is fixed on an index bucket basis, then in the case of nonprologue 3 
! files where the VBN downpointer size is fixed on an index record basis. Three
! steps constitute this split case.
! 
!      1. Split the index bucket. This step is very prologue dependent.
! 
!      2. Perform a two-bucket with empty bucket index bucket update on the
! 	  index bucket (old or new) which after the index bucket split contains
! 	  the index record whose VBN downpointer needs to be updated.
! 
!      3. As there has been a split of the level one index bucket, the level 
! 	  two index bucket containing the index record with the VBN downpointer
! 	  pointing to this level one index bucket must be updated. If the index
! 	  bucket splitting was the root bucket, a new root bucket is created, 
! 	  and then the index update is performed.
! 
! 
! One-pass Multi-bucket Index Bucket Split Case.
! 
!      Index maintenance will consist of a one-pass multi-bucket index bucket 
! split when RMS is unable to perform a multi-bucket index bucket update 
! because there is insufficient room in the index bucket for the two new index 
! records, and either the split point of the index bucket and the position of 
! insertion of the two new index records do not coincide, or if they do, the 
! new index records are to go into the new (right) bucket. This particular 
! split case consists of three steps.
! 
!      1. Split the index bucket. This step is very prologue dependent.
! 
!      2. Perform a multi-bucket index bucket update on the index bucket (old 
! 	  or new) which after the index bucket split is to contain the two new 
! 	  index records which are to be added.
! 
!      3. As there has been a split of the level one index bucket, the level 
! 	  two index bucket containing the index record with the VBN downpointer
! 	  pointing to this level one index bucket must be updated. If the index
! 	  bucket splitting was the root bucket, a new root bucket is created, 
! 	  and then the index update is performed.
! 
! 
! One-pass Multi-bucket with Empty Bucket Index Bucket Split Case.
! 
!      Index maintenance will consist of a one-pass multi-bucket with empty 
! bucket index bucket split when RMS is unable to perform a multi-bucket with 
! empty bucket index bucket update because there is insufficient room in the 
! index bucket for the new index record, and either the split point of the 
! index bucket and the position of insertion of the new index record do not 
! coincide, or if they do, the new index record is to go into the new (right) 
! bucket. This particular split case consists of three steps.
! 
!      1. Split the index bucket. This step is very prologue dependent.
! 
!      2. Perform a multi-bucket with empty bucket index bucket update on the 
! 	  index bucket (old or new) which after the index bucket split is to 
! 	  contain the new index record which is to be added.
! 
!      3. As there has been a split of the level one index bucket, the level 
! 	  two index bucket containing the index record with the VBN downpointer
! 	  pointing to this level one index bucket must be updated. If the index
! 	  bucket splitting was the root bucket, a new root bucket is created, 
! 	  and then the index update is performed.
! 
! 
! Two-pass Two-bucket Index Bucket Split Case.
! 
!      Index maintenance will consist of a two-pass two-bucket index bucket 
! split when RMS is unable to perform a two-bucket index bucket update because
! there is insufficient room in the index bucket for the new index record, the
! split point of the index bucket and the position of insertion of the new 
! index record coincide, and the new index record is to go into the old (left)
! index bucket. This particular split case consists of four steps.
! 
!      1. Split the index bucket. This step is very prologue dependent.
! 
!      2. Insert the new index record as the rightmost index record of the old 
! 	  (left) index bucket. The key of this index record will be the new 
! 	  high key of the old (left) primary data bucket, and the VBN 
! 	  downpointer of this new index record will also point to this very 
!	  same bucket.
! 
!      3. Update the VBN downpointer of the first index record of the new 
! 	  (right) index bucket so that it points to the new (right) primary 
! 	  data bucket instead of to the old (left) data bucket. The key of 
! 	  this index record is identical to the key of the primary data bucket
! 	  which split (before the split took place), and of course, to the high
! 	  key of the new (right) primary data bucket.
! 
!      4. As there has been a split of the level one index bucket, the level 
! 	  two index bucket containing the index record with the VBN downpointer
! 	  pointing to this level one index bucket must be updated. If the index
! 	  bucket splitting was the root bucket, a new root bucket is created, 
! 	  and then the index update is performed.
! 
! 
! Two-pass Two-bucket with Empty Bucket Index Bucket Split Case.
! 
!      Index maintenance will consist of a two-pass two-bucket with empty 
! bucket index bucket split when RMS is unable to perform a two-bucket with 
! empty bucket index bucket update because the pointer size required to hold 
! the VBN of the new (right) bucket is greater than that required to hold the 
! VBN of the old (left) empty bucket, the split point of the index bucket and 
! the position of the index record whose VBN downpointer is to be updated 
! coincide, and the index record whose VBN downpointer is to be updated is 
! "marked" as to exist as the rightmost index record in the old (left) index 
! bucket following the index bucket split. This is extremely prologue dependent
! It can be expected that this split case will occur much more frequently in 
! the case of prologue 3 files, where the VBN downpointer size is fixed on an 
! index bucket basis, then in the case of nonprologue 3 files where the VBN 
! downpointer size is fixed on an index record basis. Four steps constitute 
! this split case.
! 
!      1. Split the index bucket. This step is very prologue dependent.
! 
!      2. Position to the first index record position in the new index bucket.
! 	  This index record will contain the high key of the splitting primary 
! 	  data bucket before it split, and thus, will be identical to the high
! 	  key of the new (middle) primary data bucket. If the VBN downpointer 
! 	  of this index record does NOT point to the data bucket that has split
! 	  (the old or left data bucket) then do NOT change its VBN downpointer.
! 	  If this VBN downpointer was changed, then RMS would be causing 
! 	  crossed downpointers to the primary data level below, and would no 
! 	  longer be able to retrieve certain records randomly by their primary
!	  key value.
! 
!      3. If the VBN downpointer of this index record does point to the data 
! 	  bucket that has split, then update its VBN downpointer so that it now
! 	  points to the new (middle) bucket (whose high key value is the same 
!  	  as the key of the index record, and was the same as the high key of 
! 	  the old data bucket before it split, and the old (left) bucket became
! 	  empty), instead of pointing to the old (left) bucket which is now 
! 	  empty. 
! 
!      4. As there has been a split of the level one index bucket, the level 
! 	  two index bucket containing the index record with the VBN downpointer
! 	  pointing to this level one index bucket must be updated. If the index
! 	  bucket splitting was the root bucket, a new root bucket is created, 
! 	  and then the index update is performed.
! 
! 
! Two-pass Multi-bucket Index Bucket Split Case I.
! 
!      Index maintenance will consist of a two-pass multi-bucket index bucket 
! split (case I) when RMS is unable to perform a multi-bucket index bucket 
! update because there is insufficient room in the index bucket for the two new
! index records, the split point of the index bucket and the position of 
! insertion of the two new index records coincide, the new index records are
! "marked" as to go into the old (left) index bucket following the index
! bucket split, and the point of insertion of the new index records and the 
! split point do NOT coincide with the position of the very first index record
! in the old (left) index bucket. This particular split case consists of five 
! steps.
! 
!      1. Split the index bucket. This step is very prologue dependent.
! 
!      2. Insert the first of the two new index records as the rightmost index 
! 	  record of the old (left) index bucket. The key of this index record 
! 	  will be the high key of the old (left) primary data bucket, and the 
! 	  VBN downpointer of this new index record will also point to this very
! 	  same data bucket.
! 
!      3. Position to the first index record position in the new (right) index 
! 	  bucket, make sufficient room for the second of the two new index
! 	  records (this is very prologue dependent), and insert the new record.
! 	  The key will be the new high key of the new middle primary data 
! 	  bucket, and the new index record's VBN downpointer will also point to
! 	  this data bucket.
! 
!      4. Update the VBN downpointer of the second index record of the new 
! 	  (right) index bucket so that it points to the new right primary data 
! 	  bucket instead of to the old (left) data bucket. The key of this 
! 	  index record is identical to the key of the primary data bucket which
! 	  split before the split occurred, and of course, to the high key of 
! 	  the new right primary data bucket.
! 
!      5. As there has been a split of the level one index bucket, the level 
! 	  two index bucket containing the index record with the VBN downpointer
! 	  pointing to this level one index bucket must be updated. If the index
! 	  bucket splitting was the root bucket, a new root bucket is created, 
! 	  and then the index update is performed.
! 
! 
! Two-pass Multi-bucket Index Bucket Split Case II.
! 
!      Index maintenance will consist of a two-pass multi-bucket index bucket 
! split (case II) when RMS is unable to perform a multi-bucket index bucket 
! update because there is insufficient room in the index bucket for the two new
! index records, the split point of the index bucket and the position of 
! insertion of the two new index records coincide, the new index records are
! "marked" as to go into the new (left) index bucket following the index
! bucket split, and the point of insertion of the new index records and the 
! split point coincide with the position of the very first index record in the
! old (left) index bucket. This particular split case is a very special split 
! case that can be required during the processing of only those files whose 
! bucket size/key size ratio allows for only two (or at the least two if index 
! compression is enabled) index records per index bucket, and when a 
! multi-bucket split occurs such the the keys of both new index records are 
! less than the key of the leftmost index record of the index bucket in which 
! both are to go. Five steps are required to process this particular split 
! case.
! 
!      1. Split the index bucket. This step is very prologue dependent. Because
! 	  the split point will be the same as the first index record position 
! 	  in the splitting index bucket and only two index records will be 
! 	  allowed in each index bucket this means that following the split, the
! 	  new (right) index bucket will contain both the records that were 
! 	  formerly in the splitting bucket, and the old (left) index bucket 
! 	  will temporarily be empty until the index update has been completed.
! 
!      2. Insert the first of the two new index records as the very first index
! 	  record in the old (left) index bucket. The key of this new index 
! 	  record will be the new high key of the old (left) data bucket while 
! 	  the VBN downpointer will also be to old bucket.
! 
!      3. Insert the second of the two new index records after the first. The 
! 	  key of this new index record will be the new high key of the new 
! 	  middle data bucket while the VBN downpointer will also be to the new 
! 	  middle bucket.
! 
!      4. Update the VBN downpointer of the first index record of the new 
! 	  (right) index bucket so that it points to the new right primary data 
! 	  bucket instead of to the old (left) data bucket. The key of this 
! 	  index record is identical to the key of the primary data bucket which
! 	  split (before the split took place), and of course, to the high key 
! 	  of the new right primary data bucket.
! 
!      5. As there has been a split of the level one index bucket, the level 
! 	  two index bucket containing the index record with the VBN downpointer
! 	  pointing to this level one index bucket must be updated. If the index
! 	  bucket splitting was the root bucket, a new root bucket is created, 
! 	  and then the index update is performed.
! 
! 
! Two-pass Multi-bucket with Empty Bucket Index Bucket Split Case.
! 
!      Index maintenance will consist of a two-pass multi-bucket with empty
! bucket index bucket split when RMS is unable to perform a multi-bucket with
! empty bucket index bucket update because there is insufficient room in the 
! index bucket for the new index record, the split point of the index bucket 
! and the position of insertion of the new index record coincide, and the new 
! index record is marked as to go into the old (left) index bucket following 
! the index bucket split. This particular split case consists of five steps.
! 
!      1. Split the index bucket. This step is very prologue dependent.
! 
!      2. Insert the new index record as the rightmost index record of the old 
! 	  (left) index bucket. The key of this index record will be the high 
! 	  key of the new middle primary data bucket, and the VBN downpointer of
! 	  this new index record will also point to this very same bucket.
! 
!      3. Position to the first index record position in the new index bucket.
! 	  This index record will contain the high key of the splitting primary 
! 	  data bucket before it split, and thus, will be identical to the high
! 	  key of the new right primary data bucket. If the VBN downpointer of 
! 	  this index record does NOT point to the data bucket that has split 
! 	  (the old or left data bucket) then do NOT change its VBN downpointer.
! 	  If this VBN downpointer was changed, then RMS would be causing 
! 	  crossed downpointers to the primary data level below, and would no 
! 	  longer be able to retrieve certain records randomly by their primary
!	  key value.
! 
!      4. If the VBN downpointer of this index record does point to the data 
! 	  bucket that has split, then update its VBN downpointer so that it now
! 	  points to the new right bucket (whose high key value is the same as 
! 	  the key of the index record, and was the same as the high key of the 
! 	  old data bucket before it split, and the old (left) bucket became 
! 	  empty), instead of pointing to the old (left) bucket which is now 
! 	  empty. 
! 
!      5. As there has been a split of the level one index bucket, the level 
! 	  two index bucket containing the index record with the VBN downpointer
! 	  pointing to this level one index bucket must be updated. If the index
! 	  bucket splitting was the root bucket, a new root bucket is created, 
! 	  and then the index update is performed.
! 
! 
! 
! 	    Index Maintenance Requirements for Index Bucket Splitting
! 
!     Whenever an index bucket splits it is necessary to update the index level
! immediately above, and if it is the root bucket that is splitting, a new root
! bucket is created before this updating takes place. If there is sufficient
! room in the index bucket that is to be updated because of the index bucket 
! split, then an index update takes place; however, if there is also 
! insufficient room in that bucket then it too must split, and the index level
! above it must be updated as well (or created if there is no level above).
! 
!     As there can be no empty index buckets, and no index bucket splits 
! involving more than one new index bucket this eliminates all empty bucket and
! multi-bucket update and split cases from occurring as the result of an index
! bucket split. In fact, only one update case (Two-bucket Index Bucket Update) 
! and two split cases (One-pass Two-bucket Index Bucket Split and Two-pass
! Two-bucket Index Bucket Split) can ever result from the splitting of an index
! bucket. These three cases are handled exactly the same as if the maintenance
! of the index was required because of the splitting of a primary data bucket.
! 
! 
! 	    Index Maintenance Requirements for SIDR Bucket Splitting
! 
!     A split involving a SIDR bucket can also never create an empty bucket or
! involve more than one new bucket; therefore, only the Two-bucket Index Bucket
! Update, the One-pass Two-bucket Index Bucket Split, and the Two-pass 
! Two-bucket Index Bucket Split cases can occur as the result of the splitting
! of a SIDR bucket. As was the case with the splitting of primary data and 
! index buckets, an index update is first attempted, and if there is 
! insufficient room in the index bucket to be update a split is done. 
! Furthermore, as was the case with the index updated resulting from the 
! splitting of index buckets, the various split and update cases resulting from
! the splitting of SIDR buckets are handled exactly the same as if the 
! maintenance was required because of the splitting of a primary data buckets.
! Where the maintenance requirements of SIDR bucket splits differs from that 
! of index buckets is when the bucket splitting is a continuation bucket. 
! Actually, as SIDR continuation buckets never split (new one are just created
! as they are needed), whenever a SIDR continuation bucket is created no index
! updating is required.
!
!
!		  The Goals of SIDR Bucket Splitting.
!
!     RMS will always try and split index buckets roughly in half. This is also
! the same basic goal for the computation of the split point in SIDR buckets. 
! Most of the time RMS would like to split SIDR buckets roughly in half. It is 
! not always successful because of odd numbers of SIDRs, and the differing 
! sizes of those SIDRs. The differing SIDR size maybe caused by SIDR key 
! compression, or by differing numbers of duplicates associated with each SIDR 
! that can cause some SIDRs to be very large, even take up an entire SIDR 
! bucket, or to be quite small. 
! 
!    To compute the SIDR bucket split point, RMS computes a target address 
! within the bucket, and proceeds to scan the bucket. The target address is 
! computed by looking at the amount of SIDR bucket in use, dividing it in half, 
! and adding it to the current address of the bucket in memory. The bucket scan
! terminates when a SIDR is encountered whose address equals or exceeds the
! target split address. That address becomes the split point of the bucket. 
! While performing this scan, RMS takes into acount the point of insertion of 
! the new SIDR. If it encounters this address during the scan without exceeding 
! the target address, RMS assumes that the new record is to go into the old or
! left bucket. A state bit is set to indicate this, and the size of the new 
! record is taken into account from this point on when determining whether or 
! not the target address has been exceeded. The most interesting SIDR bucket 
! split cases arise when the address of the calculated SIDR bucket split point, 
! and the point of insertion of the new record end up being one and the same. 
! 
!    There is one exception to how the bucket split point is calculated, and it
! points out a second SIDR bucket split goal. If the point of insertion of the 
! new record is at the end of the SIDR bucket, in certain cases RMS will split 
! the SIDR bucket at the end of the bucket (the point of insertion of the new 
! record), and the new record is put in the new (right) SIDR bucket as the sole 
! record. The reason for this is as follows. If the new record is a duplicate, 
! and the SIDR it would belong to occupies the entire bucket, then that bucket 
! is already being maximally used, and RMS will gain nothing by splitting the 
! bucket any other way except the waste of space in the old (left) bucket 
! (since SIDR array elements are aways added in FIFO ordering). RMS may benefit 
! more by splitting the bucket at its end, and creating a SIDR continuation 
! bucket with the new record as the first array element of the sole SIDR in the 
! new bucket. On the other hand, if the record is a brand new SIDR (not a 
! duplicate), then placing the new record in a bucket all by itself will be a 
! real space win if the records are being added to the file in ascending order 
! by this secondary key of reference. This is because each SIDR bucket will 
! have been completely packed, before packing of the next one is initiated. If 
! records are being added randomly then nothing is really lost by splitting the 
! bucket here.
! 
!    The third goal is more a matter of common sense. RMS can not split the SIDR
! bucket such that when RMS goes to insert the new record it finds that there is
! insufficient room in the SIDR bucket in which the new record is to go. Because
! RMS will never split a SIDR bucket in the middle of a SIDR, and because SIDRs
! can be very large so as to occupy almost the entire bucket it is possible for
! this situation to arise. For example, consider the case of a bucket consisting
! of one very small SIDR followed by one very large SIDR, and the new record 
! was to go between the two. During the bucket scan RMS positions to the very 
! large record, and even taking into account the new record, RMS still will not 
! have positioned past the target split point address. Thus, RMS would conclude 
! that the SIDR it is currently positioned to (the very large one) should go 
! with the others in the old bucket, and would position past it. Since this 
! positions RMS past the target split point address, RMS would stop scanning. 
! However, this also would position RMS to the end of the bucket, and this is 
! not a suitable split point since it would leave the old SIDR bucket intact 
! and RMS already knows that there was insufficient room in the bucket to 
! accomidate the new record or it would not be attempting a split in the first 
! place. What this third goal forces RMS to do in this situation is to back up 
! one SIDR and split the SIDR bucket between the very small and the very large 
! records with the new SIDR to be placed into the old (left) bucket. Even 
! though the SIDR bucket will be split into disapportionate halves, splitting 
! at this place guarentees that the new record will have sufficient room for 
! its insertion.
! 
!    The forth and final goal of SIDR bucket splitting is to make sure that if
! the new record is a duplicate (ie - there are other records in the file with 
! this secondary key value), it should always go into the SIDR bucket containing
! the SIDR it is a duplicate of. In fact, it should always end up as the last
! array element in this SIDR after its addition is completed. This goal never
! affects where the SIDR bucket split point is calculated to be; but rather, 
! once this split point has been calculated and it is seen to coincide with the 
! point of insertion of the new record, in which bucket the new record is 
! placed. Note that there is one exception to this rule which has already been 
! described. If the SIDR the new record is a duplicate of occupies the entire 
! SIDR bucket, then the new record is placed by itself in a SIDR continuation 
! bucket.
! 
!    Thus, there are four goals which are taken into account during SIDR bucket
! split point determination. Goal number 2 takes precedence in this 
! determination followed by goal number 1. Goal number 3 serves to modulate 
! goal number 1 such that a split point will always be calculated which will 
! allow sufficient room for the new record in whatever bucket it is to go. 
! Finally, goal number 4 can affect in which bucket the new record is placed 
! provided it is not superceeded by goal number 2.
! 
! 
!     The SIDR Bucket Split Point ~= The Point of Insertion of the New Record.
! 
!    There are six bucket split cases which fall into this catagory. They are
! all handled basically the same. After the split point has been determined, the
! SIDR bucket split takes place and then the new record is inserted into the
! appropriate bucket at the appropriate place.
! 
!    Case Number 1: The point of insertion of the new SIDR is at the front of
! 		    the SIDR bucket. 
! 
!    Case Number 2: The point of insertion of the new SIDR is to the left of the
!  		    SIDR bucket split point but not at the front of the bucket.
! 
!    Case Number 3: The point of insertion of the new duplicate is to the left 
! 		    of the SIDR bucket split point but not at the front of the 
! 		    SIDR bucket.
! 
!    Case Number 4: The point of insertion of the new SIDR is to the right of 
! 		    the SIDR bucket split point but not at the end of the 
! 		    bucket.
! 
!    Case Number 5: The point of insertion of the new duplicate is to the right
! 		    of the SIDR bucket split point but not at the end of the 
! 		    SIDR bucket.
! 
!    Case Number 6: The point of insertion of the new duplicate is at the end
! 		    of the bucket, but the SIDR it belongs does not occupy the
! 		    entire SIDR bucket.
! 
! Actually, case number 6 is handled somewhat differently from the other 5. The
! split point is initially determined to be at the end of the bucket (Goal 2).
! However, when it is determined that the SIDR the new duplicate belongs to does
! not occupy the entire bucket, RMS decides to split the SIDR bucket not at the 
! end, but at the beginning address of the last SIDR in the bucket. Thus, the 
! SIDR bucket split is performed such that the new (right) SIDR bucket contains 
! one SIDR - the SIDR that was formerly the last record in the old bucket, and 
! the new duplicate is inserted as the last member of its array.
! 
! 
!     The SIDR Bucket Split Point = The Point of Insertion of the New Record.
! 
!    There are seven bucket split cases which fall into this catagory. They are
! all handled basically the same. After the split point has been determined, the
! SIDR bucket split takes place and then the new record is inserted into the
! appropriate bucket at the appropriate place.
! 
!    Case Number 1: The point of insertion of the new SIDR is at the front of
! 		    the SIDR bucket. In this case the SIDR currently at the
! 		    front of the SIDR bucket must occupy the entire bucket.
! 		    It will be moved into the new (right) bucket and the new 
! 		    SIDR will occupy the old (left) bucket by itself.
! 
!    Case Number 2: The point of insertion of the new SIDR is to the left of
! 		    or at the hypothetical 50-50 split point of the SIDR bucket
! 		    but not at the front of the bucket. The new SIDR will be 
! 		    inserted as the last record in the old (left) SIDR bucket.
! 
!    Case Number 3: The point of insertion of the new duplicate is to the left 
! 		    of or at the hypothetical 50-50 split point of the SIDR 
! 		    bucket but not at the front of the bucket. The new duplicate
! 		    will be inserted as the last array element in what will 
! 		    become the last SIDR in the old (left) SIDR bucket.
! 
!    Case Number 4: The point of insertion of the new SIDR is to the right
! 		    of the hypothetical 50-50 split point of the SIDR bucket
! 		    but not at the end of the bucket. The new SIDR will become
! 		    the first record in the new (right) SIDR bucket.
! 
!    Case Number 5: The point of insertion of the new duplicate is to the right
! 		    of the hypothetical 50-50 split point of the SIDR bucket
! 		    but not at the end of the bucket. The new duplicate will be
! 		    inserted as the last array element in what will become the
! 		    last SIDR in the old (left) SIDR bucket.
! 
!    Case Number 6: The point of insertion of the new SIDR is at the end of the
! 		    SIDR bucket. The new SIDR will become the first and only
! 		    record in the new (right) SIDR bucket.
! 
!    Case Number 7: The point of insertion of the new duplicate is at the end of
! 		    the SIDR bucket. Because the SIDR occupies the entire old
! 		    (left) SIDR bucket, the new (right) bucket is created as a 
! 		    SIDR continuation bucket. A new SIDR is created to exist
! 		    within this new bucket. It is the sole SIDR within the new
! 		    bucket, and the new duplicate is inserted as the sole array 
! 		    element within this SIDR.
! 
!*****

LIBRARY 'RMSLIB:RMS';

REQUIRE 'RMSSRC:RMSIDXDEF';

! Define default PSECTS for code.
!
PSECT
    CODE = RM$RMS3(PSECT_ATTR),
    PLIT = RM$RMS3(PSECT_ATTR);

! Linkages
!
LINKAGE
    L_JSB01,
    L_PRESERVE1,
    L_RABREG_567,
    L_RABREG_67,
    L_REC_OVHD,

    ! Local Linkages
    !
    RL$COMP_SPL_PNT = JSB (REGISTER = 1) 
		    : GLOBAL (R_IDX_DFN, R_IRAB, R_REC_ADDR, R_BKT_ADDR,R_IFAB),
    RL$LINKAGE = JSB () 
		 : GLOBAL (R_IDX_DFN, R_IFAB, R_IRAB, R_REC_ADDR);


! External Routines
!
EXTERNAL ROUTINE
    RM$CNTRL_ADDR	: RL$RABREG_567,
    RM$COMPRESS_KEY	: RL$JSB01,
    RM$GETNEXT_REC	: RL$RABREG_67,
    RM$INS_REC		: RL$RABREG_67,
    RM$MOVE		: RL$PRESERVE1,
    RM$RECORD_KEY	: RL$PRESERVE1,
    RM$RECORD_SIZE	: RL$RABREG_567,
    RM$REC_OVHD		: RL$REC_OVHD;

! Key compression overhead macros.
!
MACRO 
    COMPR 	= 0,8,8,0 %,
    KEY_LEN	= 0,0,8,0 %;

%SBTTL 'RM$COMP_SPL_PNT'
ROUTINE RM$COMP_SPL_PNT (INS_PNT) : RL$COMP_SPL_PNT =

!+++
!
!  FUNCTIONAL DESCRIPTION:
!
!	This routine returns the address at which the bucket should
!	be split.
!
! CALLING SEQUENCE:
!
!	RM$COMP_SPL_PNT()
!
!  INPUT PARAMETERS:
!
!	Address to insert the new record
!
!  IMPLICIT INPUT:
!
!	IDX_DFN	
!	IRAB
!	BKT_ADDR
!
!  OUTPUT PARAMTERS:
!	NONE
!
!  IMPLICIT OUTPUT:
!
!	IRAB [IRB$L_SPL_CNT] - Number of first VBN which should be in new bucket
!	IRAB [IRB$V_REC_W_LO] - Set if new record should go in left bucket
!	IRAB [IRB$L_LST_NCMP] - Address of last record with a front compressoin
!				count of zero (before insertion point)
!
!  ROUTINE VALUE:
!
!	SPL_PNT - Address of first record which should be in new bucket
!
!  SIDE EFFECTS:
!	NONE
!
!---

    BEGIN

    EXTERNAL REGISTER
	R_BKT_ADDR_STR,
	R_IDX_DFN_STR,
	R_IFAB,
	R_IRAB_STR,
	R_REC_ADDR_STR;
	
    LOCAL
	EOB,
	SPL_PNT;

    MACRO
	KEY_SZ = 0,0,16,0 %,
	VBN_SZ = 0,16,16,0 %;

    REC_ADDR = .BKT_ADDR + BKT$C_OVERHDSZ;
    EOB = .BKT_ADDR + .BKT_ADDR[BKT$W_FREESPACE];

    ! Prologue 3 non-compressed index record.
    !
    IF  .BKT_ADDR[BKT$B_LEVEL] GTRU 0
	 AND
	.IDX_DFN [IDX$B_IDXBKTYP] EQLU IDX$C_NCMPIDX
    THEN

	BEGIN

	GLOBAL REGISTER
	    R_RAB,
	    R_IMPURE;

	LOCAL
	    VBN_ADDR,
	    TEMP: BLOCK[1];

	TEMP = RM$RECORD_SIZE();

	! Compute the address of first record past the midpoint.
	!
	SPL_PNT = .REC_ADDR + 
			(((.EOB - .REC_ADDR) / 2) / .IDX_DFN [IDX$B_KEYSZ])
						  * .IDX_DFN [IDX$B_KEYSZ];

	! Get the address of VBN split point.
	!
	BEGIN

	LOCAL
	    SAVE;

	IRAB [IRB$L_SPL_COUNT] = (.SPL_PNT - .REC_ADDR) / .IDX_DFN [IDX$B_KEYSZ];
	SAVE = .IRAB [IRB$L_REC_COUNT];
	IRAB [IRB$L_REC_COUNT] = .IRAB [IRB$L_SPL_COUNT];
	VBN_ADDR = RM$CNTRL_ADDR();
	IRAB [IRB$L_REC_COUNT] = .SAVE;
	END;

	! The new record will go into the left bucket.
	!
	IF .SPL_PNT GEQA .INS_PNT
	THEN
	    BEGIN

	    IRAB [IRB$V_REC_W_LO] = 1;

	    ! If there is insufficient room in the old bucket for the index
	    ! records which must be inserted, and we are not at the insertion
	    ! point then move out one more record to make room. If we are at
	    ! the insertion point then there is insufficient room because
	    ! we are attempting to insert two keys into an index bucket where
	    ! there is only room for one. In such a case one key will go in
	    ! the old bucket, and another will go in the new index bucket.
	    ! 
	    ! REMEMBER: keys are fixed in size!!!
	    !
	    IF (.VBN_ADDR - .SPL_PNT) LSSU (.TEMP [KEY_SZ] + .TEMP [VBN_SZ])
	       AND
	       (.INS_PNT NEQA .SPL_PNT)
	    THEN

		! The records we are moving out don't leave enough room
		! Move one more
		!
		BEGIN
		SPL_PNT = .SPL_PNT - .IDX_DFN [IDX$B_KEYSZ];
		IRAB [IRB$L_SPL_COUNT] = .IRAB [IRB$L_SPL_COUNT] - 1;
		END;

	    END;

	END
    ELSE
	
	! Prologue two index or SIDR bucket.
	! Prologue three compressed index or SIDR bucket.
	!
	BEGIN

	LOCAL
	    SAVE_COUNT;

	SAVE_COUNT = .IRAB [IRB$L_REC_COUNT];
	IRAB [IRB$L_LST_NCMP] = .REC_ADDR;

	IF .INS_PNT NEQ .EOB
	THEN
	    BEGIN					! of block scan

	    LOCAL
		BUCKET_LEVEL,
		LRA,
		NEW_REC_SZ;

	    ! Determine the level of the bucket once and only once.
	    !
	    IF (BUCKET_LEVEL = .BKT_ADDR[BKT$B_LEVEL]) EQLU 0
	    THEN
		BUCKET_LEVEL = -1;


	    ! Compute the hypothetical 50-50 split point based on the
	    ! current bucket freespace offset pointer.
	    !
	    NEW_REC_SZ = 0;
	    SPL_PNT = (.EOB - .REC_ADDR)/2 + .REC_ADDR;
	    IRAB [IRB$L_REC_COUNT] = 0;

	    ! Scan bucket until RMS gets to the record past the split point 
	    ! calculated (if the new record is going to end up in the new
	    ! (right) bucket, or until the current position plus the size of
	    ! the new record to be inserted exceeds the split point (if the
	    ! new record is going to end up in the old (left) bucket.
	    !
	    DO 
		BEGIN

		LRA = .REC_ADDR;

		! if RMS's current position in the bucket scan matches the
		! point of insertion, then the new record will go into
		! the old (left) bucket. at this time the size of the new 
		! record is computed so its value maybe taken into account
		! in the determination of the split point. if the insertion
		! of the new record would not cross the split point, the 
		! bucket scan continues with the next record.
		! 
		IF .REC_ADDR EQLA .INS_PNT
		THEN
		    BEGIN

		    GLOBAL REGISTER
			R_RAB,
			R_IMPURE;

		    IF .IRAB[IRB$V_REC_W_LO]
		    THEN
			RM$GETNEXT_REC()
		    ELSE
			BEGIN

			LOCAL
	    		    TEMP: BLOCK[1];

			! Obtain size of the new index record(s). This is a
			! single quantity in a non-prologue 3 file, but two
			! contigious words in a prologue 3 file. However, since
			! the entire prologue 1 index record but only the key
			! portion of the prologue 3 index record contributes
			! to the end-of-bucket computation, just use the low 
			! order word (key size in the case of a prologue 3
			! index record but entire index record size if 
			! nonprologue 3) as the new record size.
			!
			TEMP = RM$RECORD_SIZE();
			NEW_REC_SZ = .TEMP[KEY_SZ];
			IRAB[IRB$V_REC_W_LO] = 1;
			END
		    END
		ELSE
		    BEGIN

		    LOCAL
			REC_SIZE,
			RECORD_OVHD;

		    ! Position to the next record in the bucket.
		    !
		    RECORD_OVHD = RM$REC_OVHD(.BUCKET_LEVEL; REC_SIZE);
		    REC_ADDR = .REC_ADDR + .RECORD_OVHD + .REC_SIZE;

		    IRAB[IRB$L_REC_COUNT] = .IRAB[IRB$L_REC_COUNT] + 1;

		    ! if index or key compression is enabled, this is an
		    ! appropriate bucket, the front compression of the current
		    ! record is zero, and RMS has not reached the insertion 
		    ! point, then update the pointer to the last noncompressed 
		    ! record to facilitate computation of the front compression
		    ! of the new record to be inserted.
		    !
		    IF ((.BKT_ADDR[BKT$B_LEVEL] EQLU 0
					 AND
					.IDX_DFN[IDX$V_KEY_COMPR])
				 OR
				(.BKT_ADDR[BKT$B_LEVEL] GTRU 0
					 AND
					.IDX_DFN [IDX$V_IDX_COMPR]))
			 AND 
			.(.REC_ADDR + .RECORD_OVHD)<8,8> EQLU 0
			 AND 
			.REC_ADDR LSSA .INS_PNT
		    THEN
			IRAB [IRB$L_LST_NCMP] = .REC_ADDR;
		    END

		END
	    UNTIL .REC_ADDR + .NEW_REC_SZ GTRA .SPL_PNT;

	    ! if the new record goes in the old bucket, make sure we are at 
	    ! least moving out enough records to make room for it. SIDRs and
	    ! index records must be separately considered.
	    !
	    ! In the case of SIDRs, it is guaranteed that the new record will 
	    ! be as small as possible, and if even one record is moved out of 
	    ! the old bucket there will be room for it. However, if a very
	    ! small record is to be added, the possibility exists that by the
	    ! time the bucket scanning loop is exited, there will be 
	    ! insufficient room for the new record. This is because while the 
	    ! small record size at the insertion point did not cause the split 
	    ! point to be exceeded, the very large record which follows did 
	    ! and if the split was made following the large record there would 
	    ! not be enough room in the old bucket for the new record. in this
	    ! instance we still want to put the new record in the old (left)
	    ! bucket, but we want to split at the point of inserting forcing
	    ! the following big record to go in the new (right) bucket.
            !
	    ! in the case of index records, if we are not at the insertion
	    ! point then there must be room for the new records in the old
	    ! bucket, otherwise, we would have exited the above loop while
	    ! at the insertion point. if we are at the insertion point and 
	    ! there isn't room to insert new index records this can only be
	    ! because there has been a multibucket split requiring two new
	    ! keys to be inserted. in such a case, one will go in the old
	    ! bucket, and the other in the new index bucket, so nothing 
	    ! further need be done.
	    !
	    IF .IRAB[IRB$V_REC_W_LO]
		AND
		(.EOB - .REC_ADDR) LSSU .NEW_REC_SZ
		AND
		(.REC_ADDR NEQA .INS_PNT)
	    THEN
		BEGIN
		REC_ADDR = .LRA;
		IRAB [IRB$L_REC_COUNT] = .IRAB [IRB$L_REC_COUNT] - 1;
		END;

	    ! At this point, REC_ADDR is pointing to the place where RMS is
	    ! going to split the bucket.
	    !
	    SPL_PNT = .REC_ADDR;
	    END

	! If the point of insertion is at the end of the free-space of the
	! bucket, then this is also where RMS will split the bucket.
	!
	ELSE
	    SPL_PNT = .INS_PNT;

	IRAB [IRB$L_SPL_COUNT] = .IRAB [IRB$L_REC_COUNT];
	IRAB [IRB$L_REC_COUNT] = .SAVE_COUNT;

	END;

    RETURN .SPL_PNT;
    END;

%SBTTL 'RM$EXT_HIGH_KEY'
ROUTINE RM$EXT_HIGH_KEY : RL$LINKAGE NOVALUE =

!+++
!
!  FUNCTIONAL DESCRIPTION:
!
!	This routine extracts the high key from the bucket in IRB$L_CURBDB
!	and places it in keybuffer 2.
!
! CALLING SEQUENCE:
!
!	RM$EXT_HIGH_KEY()
!
!  INPUT PARAMETERS:
!	NONE
!
!  IMPLICIT INPUT:
!
!	BKT_ADDR		- address of the bucket
!	    BKT$W_FREESPACE	- offset to first free byte in the bucket
!	    BKT$B_LEVEL		- level of the bucket
!
!	IDX_DFN			- address of the index descriptor
!	    IDX$V_IDX_COMPR	- if set, index key compression is enabled
!	    IDX$V_KEY_COMPR	- if set, key compression is enabled
!	    IDX$B_KEYSZ		- size of the key
!
!	IFAB			- address of te IFAB
!	    IFB$B_PLG_VER	- prologue version of the file
!	    IFB$W_KBUFSZ	- size of a contigious keybuffer
!
!	IRAB			- address of the IRAB
!	    IRB$L_CURBDB	- address of BDB for current bucket
!	    IRB$L_KEYBUF	- address of contigious keybuffers
!
!  OUTPUT PARAMETERS:
!	NONE
!
!  IMPLICIT OUTPUT:
!
!	IRB$L_LST_NCMP		- address of last record in bucket with a zero 
!				  front compressed key
!
!	Keybuffer 2 has high key value of bucket.
!
!	REC_ADDR		- address of last record in the bucket
!
!  ROUTINE VALUE:
!	NONE
!	
!  SIDE EFFECTS:
!
!	AP is trashed.
!
!---
    BEGIN

    BUILTIN
	AP;

    EXTERNAL REGISTER
	R_IDX_DFN_STR,
	R_IFAB_STR,
	R_IRAB_STR;

    GLOBAL REGISTER
	R_BKT_ADDR_STR,
	R_REC_ADDR_STR;

    LOCAL
	EOB,
	RECORD_OVHD;

    ! Setup several variables inorder to be able to position to the last record
    ! with a key in the bucket.
    !
    BKT_ADDR = .BBLOCK[.IRAB[IRB$L_CURBDB], BDB$L_ADDR];
    EOB = .BKT_ADDR + .BKT_ADDR[BKT$W_FREESPACE];
    REC_ADDR = .BKT_ADDR + BKT$C_OVERHDSZ;

    ! The bucket is NOT a prologue 3 index bucket with non-compressed key
    ! index records. In every situation but this one, the size of the records
    ! in the bucket are variable, so in order to find the last record in the
    ! bucket, the entire bucket must be scanned record-by-record. If the keys
    ! of the records in the bucket are compressed, during this scan the address
    ! of the last record with a zero-front compressed key is saved to be used in
    ! expanding the key of the last record in the bucket.
    !
    IF  NOT (.IFAB[IFB$B_PLG_VER] GEQU PLG$C_VER_3
	      AND
	     .BKT_ADDR[BKT$B_LEVEL] NEQU 0
	      AND
	     NOT .IDX_DFN[IDX$V_IDX_COMPR])
    THEN
	BEGIN

	LOCAL
	    BUCKET_LEVEL;

	! Set BUCKET_LEVEL to the index level, if the bucket is an index bucket;
	! otherwise, set it to -1.
	!
	IF (BUCKET_LEVEL = .BKT_ADDR[BKT$B_LEVEL]) EQLU 0
	THEN
	    BUCKET_LEVEL = -1;

	! Scan the bucket until the end of the bucket is encountered.
	!
	WHILE 1 DO
	BEGIN

	    LOCAL
		REC_SIZE;

	    RECORD_OVHD = RM$REC_OVHD(.BUCKET_LEVEL; REC_SIZE);

	    ! If the keys in this bucket are compressed, and the current
	    ! record's key is zero front compressed, then save the address
	    ! of this record.
	    !
	    IF  .IFAB[IFB$B_PLG_VER] GEQU PLG$C_VER_3
		 AND
		NOT (.BKT_ADDR[BKT$B_LEVEL] EQLU 0
			 AND
			NOT .IDX_DFN[IDX$V_KEY_COMPR])
		 AND
	    	.(.REC_ADDR + .RECORD_OVHD)<8,8> EQLU 0
	    THEN
		IRAB[IRB$L_LST_NCMP] = .REC_ADDR;

	    ! If this is the last record in the bucket, exit the loop.
	    !
	    IF (.REC_ADDR + .RECORD_OVHD + .REC_SIZE) GEQU .EOB
	    THEN
		EXITLOOP

	    ! Else position to the next record and continue the scan.
	    !
	    ELSE
		REC_ADDR = .REC_ADDR + .RECORD_OVHD + .REC_SIZE;
	    END;
	END

    ! The bucket is a prologue 3 index bucket containing non-compressed key 
    ! index records. As the records are of fixed size, RMS is able to quickly
    ! position to the last record in the index bucket.
    !
    ELSE
	REC_ADDR = .EOB - .IDX_DFN[IDX$B_KEYSZ];

    ! Having positioned to the last record in the bucket, RMS can extract its
    ! key into keybuffer 2, expanding it as is necessary.
    !
    BEGIN

    GLOBAL REGISTER
	R_BDB,
	R_RAB,
	R_IMPURE;

    IF .IFAB[IFB$B_PLG_VER] LSSU PLG$C_VER_3
    THEN
	RM$MOVE (.IDX_DFN[IDX$B_KEYSZ], 
		 .REC_ADDR + .RECORD_OVHD, 
		 KEYBUF_ADDR(2))
    ELSE
	BEGIN
	AP = 0;
	RM$RECORD_KEY (KEYBUF_ADDR(2));
	END;
    END;

    RETURN;
    END;	

%SBTTL 'RM$MOVE_VBNS'
ROUTINE RM$MOVE_VBNS (NEW_BKT): RL$LINKAGE NOVALUE =

!+++
!
!  FUNCTIONAL DESCRIPTION:
!
!	This routine moves the VBNs starting with the one corresponding
!	to REC_COUNT into the new bucket.
!
! CALLING SEQUENCE:
!
!	RM$MOVE_VBNS()
!
!  INPUT PARAMETERS:
!
!	NEW_BKT - Address of new bucket
!
!  IMPLICIT INPUT:
!
!	IDX_DFN
!	IRAB
!	IFAB
!	REC_ADDR
!
!  OUTPUT PARAMETERS:
!	NONE
!
!  IMPLICIT OUTPUT:
!	NONE
!
!  ROUTINE VALUE:
!	NONE
!
!  SIDE EFFECTS:
!	NONE
!
!---

    BEGIN

    EXTERNAL REGISTER
	R_IDX_DFN_STR,
	R_IRAB_STR,
	R_IFAB,
	R_REC_ADDR;

    GLOBAL REGISTER
	R_BKT_ADDR_STR;

    MAP
	NEW_BKT : REF BBLOCK;

    LOCAL
	OLD_FREE  : REF BBLOCK,	! Address of old buckets VBN free pointer
	NEW_FREE  : REF BBLOCk,	! Address of new buckets VBN free pointer
	BKTSZ,			! Number of bytes in these buckets
	NEW_END,		! Address of new end of old bucket's VBN chain
	OLD_END,		! Address of old end of old bucket's VBN chain
	SIZE,			! Number of bytes to move
	DEST_ADDR;		! Starting address of VBN chain in new bucket

    ! First compute the number of bytes to move.
    !
    BKT_ADDR = .BBLOCK [.IRAB [IRB$L_CURBDB], BDB$L_ADDR];
    BKTSZ = .IDX_DFN [IDX$B_IDXBKTSZ];

    BKTSZ = .BKTSZ * 512;
    OLD_FREE = .BKT_ADDR + .BKTSZ - BKT$C_ENDOVHD;
    NEW_FREE = .NEW_BKT + .BKTSZ - BKT$C_ENDOVHD;

    ! Now get the start and end of the VBN chain to move.
    !
    BEGIN

    GLOBAL REGISTER
	R_RAB,
	R_IMPURE;

    LOCAL
	SAVE;

    SAVE = .IRAB [IRB$L_REC_COUNT];
    IRAB [IRB$L_REC_COUNT] = .IRAB [IRB$L_SPL_COUNT];
    NEW_END = RM$CNTRL_ADDR() + .BKT_ADDR [BKT$V_PTR_SZ] + 2;
    IRAB [IRB$L_REC_COUNT] = .SAVE;
    END;

    OLD_END = .BKT_ADDR + .OLD_FREE [0,0,16,0];
    SIZE = .NEW_END - .OLD_END;
    OLD_FREE [0,0,16,0] = .OLD_FREE [0,0,16,0] + .SIZE - 1;

    ! Finally get the destination address.
    !
    DEST_ADDR = .NEW_FREE - .SIZE;
 
    CH$MOVE (.SIZE, .OLD_END, .DEST_ADDR);

    NEW_FREE [0,0,16,0] = .DEST_ADDR - .NEW_BKT;

    ! Move the PTR_SZ from the old bucket to the new bucket.
    !
    NEW_BKT [BKT$V_PTR_SZ] = .BKT_ADDR [BKT$V_PTR_SZ];
    END;

%SBTTL 'RM$SPLIT_EM'
GLOBAL ROUTINE RM$SPLIT_EM : RL$RABREG_67 =

!++
!
! FUNCTIONAL DESCRIPTION:
!
! Split the bucket in CURBDB into NXTBDB for SIDR data level and
! any index level as close to 50-50 as possible.  Records are moved
! into the new bucket, and the new record is inserted where appropriate.
! Keybuffer 2 contains the high key value of the left hand bucket after
! splitting.  No buckets are actually written out in this routine, only
! the records are moved.
!
! CALLING SEQUENCE:
!
!	RM$SPLIT_EM()
!
! INPUT PARAMETERS:
!	NONE
!
! IMPLICIT INPUTS:
!
!	IDX_DFN - pointer to index descriptor for this key of reference
!	    IDX$B_KEYSZ - size of key
!
!	REC_ADDR - point in bucket where new record is to be inserted
!
!	IRAB - pointer to internal rab structure
!	    IRB$V_REC_W_LO - 0 on input
!	    IRB$V_DUPS_SEEN - set if positioned after existing record to add
!				sidr array entry
!	    IRB$L_LST_REC - address of beginning of record previous to one
!			rec_addr is positioned to (used in conjunction with
!			irb$v_dups_seen)
!	    IRB$B_STOPLEVEL - level at which insert is being done (non-zero
!			if this is primary key only)
!	    IRB$L_CURBDB - bdb describing bucket to split (left hand bucket)
!	    IRB$L_NXTBDB - bdb describing bucket to split into (right hand)
!
!	IFAB - pointer to internal fab structure
!	    IFB$W_KBUFSZ - size of keybuffers
!
!	Routines called by this routine will reference additional fields in
!	the above structures.
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	keybuffer 2 (irb$l_keybuff + ifb$w_kbufsz) contains high 
!	value of left hand bucket.
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!
!	All records in the original bucket described by IRB$L_CURBDB
!	and the new record are split between that bucket and the new
!	(empty) bucket described by IRB$L_NXTBDB.  Only when one record
!	occupies the entire bucket (curbdb) will a continuation record
!	be created, else the entire record will be moved to the new bucket.
!	ID's are reassigned in the new SIDR bucket as well.
!
!
!--

    BEGIN

    EXTERNAL REGISTER
	COMMON_RAB_STR,
	R_REC_ADDR_STR,
	R_IDX_DFN_STR;

    LOCAL
	EOB;

    BEGIN			! block to limit scope of following locals

    LOCAL
	INS_PNT;

    GLOBAL REGISTER
	R_BKT_ADDR_STR;

    BKT_ADDR = .BBLOCK[.IRAB[IRB$L_CURBDB], BDB$L_ADDR];
    EOB = .BKT_ADDR + .BKT_ADDR [BKT$W_FREESPACE];

    ! First compute the split point.
    !
    INS_PNT = .REC_ADDR;

    REC_ADDR = RM$COMP_SPL_PNT(.INS_PNT);

    ! If the split point ended up exactly where we wanted to insert the record
    ! anyway we must investigate a little further.
    !
    IF .REC_ADDR EQLA .INS_PNT
    THEN
	IF NOT .IRAB[IRB$V_REC_W_LO]
	THEN
	    IF  .BKT_ADDR[BKT$B_LEVEL] EQL 0
		 AND
		.IRAB[IRB$V_DUPS_SEEN]
	    THEN

		! This is a continuation record being added to the end of
		! an existing record so keep it with the low set.
		!
		IF .REC_ADDR NEQA .EOB
		THEN
		    IRAB[IRB$V_REC_W_LO] = 1

		! RMS is trying to insert a continuation record at the end
		! of the bucket.  Unless the existing record occupies the
		! entire bucket RMS will move the entire record into the new
		! bucket and add the continuation record there.
		!
		ELSE
		    BEGIN

		    ! RMS is going to back up the split point to the
		    ! beginning of this record so that it does not create a
		    ! continuation bucket, but force the whole thing
		    ! into the new bucket
	 	    !
		    IF .IRAB[IRB$L_LST_REC] NEQA .BKT_ADDR + BKT$C_OVERHDSZ
		    THEN
			REC_ADDR = .IRAB[IRB$L_LST_REC]

		    ! The existing record that RMS is positioned at the end
		    ! of occupies the entire bucket, therefore RMS is forced
		    ! to make the new record anew in the new bucket, causing a 
		    ! continuation bucket. This is the only time RMS will
		    ! ever create a continuation bucket at the SIDR data level 
		    ! and it is done with great reluctance. Clearing DUPS_SEEN 
		    ! will cause the record size to be correct when it is 
		    ! recalculated later.
		    !
		    ELSE
			BEGIN
			IRAB[IRB$L_LST_REC] = .INS_PNT;
			IRAB[IRB$V_DUPS_SEEN] = 0;
			IRAB[IRB$V_CONT_BKT] = 1;
			END;

		    END;

    ! Now set up things as offsets to simplify life later on.
    !
    IRAB[IRB$W_POS_INS] = .INS_PNT - .BKT_ADDR;
    IRAB[IRB$W_SPLIT] = .REC_ADDR - .BKT_ADDR;

    ! Adjust the freespace pointer for the old (left) bucket to reflect
    ! its new size.
    !
    BKT_ADDR[BKT$W_FREESPACE] = .IRAB[IRB$W_SPLIT];
    IRAB[IRB$L_LST_REC] = .IRAB[IRB$L_LST_REC] - .BKT_ADDR;
    END;				! of block defining INS_PNT, BKT_ADDR

    ! RMS moves everything beyond the split point into the new bucket
    ! without caring where the new record or records are going to go.
    !
    BEGIN

    LOCAL
	COMPRESSION,
	NEW_BKT	: REF BBLOCK;

    COMPRESSION = 0;

    NEW_BKT = .BBLOCK[.IRAB[IRB$L_NXTBDB], BDB$L_ADDR];

    ! If there is anything at all to move into the new bucket, RMS knows
    ! to move it without any regard as to where the new record or records will
    ! be inserted.
    !
    IF (NEW_BKT[BKT$W_FREESPACE] = .EOB - .REC_ADDR) NEQU 0
    THEN
	BEGIN

	LOCAL
	    REC_FROM	: REF BBLOCK,
	    REC_TO	: REF BBLOCK,
	    RECORD_OVHD,
	    LENGTH;

	REC_FROM   = .REC_ADDR;
	REC_TO = .NEW_BKT + BKT$C_OVERHDSZ;
	LENGTH = .NEW_BKT[BKT$W_FREESPACE];

	! Determine the number of bytes of record overhead for the current
	! record. This record will become the first record in the new bucket.
	!
	BEGIN

	LOCAL
	    REC_SIZE;

	IF (REC_SIZE = .NEW_BKT[BKT$B_LEVEL]) EQLU 0
	THEN
	    REC_SIZE = -1;

	RECORD_OVHD = RM$REC_OVHD(.REC_SIZE);
	END;
		
	! If this is a prologue 3 bucket with compressed keys, and if the key
	! of the record which is to be the first record in the new bucket is 
	! not zero front compressed, RMS constructs the contents of the new 
	! bucket in two steps. First, RMS moves in the new low order key front 
	! expanding and rear-end recompressing as required. Finally, the 
	! remainder of the contents of the new index/SIDR bucket is moved into 
	! the new bucket.
	!
	IF ((.NEW_BKT[BKT$B_LEVEL] EQLU 0
		 	 AND
			.IDX_DFN[IDX$V_KEY_COMPR])
		 OR
	   	(.NEW_BKT[BKT$B_LEVEL] NEQU 0
			 AND
			.IDX_DFN [IDX$V_IDX_COMPR]))
	    AND
	   (.(.REC_ADDR + .RECORD_OVHD)<8,8> GTRU 0)
	THEN
	    BEGIN

	    BUILTIN
		AP;

	    LOCAL
		SAVE_LST_NCMP,
		SAVE_REC_ADDR;

	    GLOBAL REGISTER
		R_BDB,
		R_BKT_ADDR;

	    ! If the record which is to be the first record in the new bucket
	    ! has any overhead associated with it, move the overhead into the
	    ! new bucket, and then position past it to the key of the record.
	    ! Also, position in the new bucket to the first byte past the
	    ! record overhead just moved into it.
	    ! 
	    IF .RECORD_OVHD GTRU 0
	    THEN
		BEGIN
		REC_TO = RM$MOVE (.RECORD_OVHD, .REC_ADDR, .REC_TO);
		REC_ADDR = .REC_ADDR + .RECORD_OVHD;
		END;
	    
	    ! Move the key which is to be the low-order key in the new bucket
	    ! from its current position in the old (left) bucket to its
	    ! position as the first key in the new bucket leaving room
	    ! for the record overhead bytes (in the case of SIDRs) and the key
	    ! compression overhead bytes.
	    !
	    AP = 1;
	    RM$RECORD_KEY (.REC_TO + 2);

	    ! Determine the compression of the low-order key of the new bucket.
	    ! This key must be and will be zero-front compressed, but it will
	    ! be rear-end truncated if possible.
	    !
	    SAVE_REC_ADDR = .REC_ADDR;
	    REC_ADDR = .REC_TO - .RECORD_OVHD;

	    SAVE_LST_NCMP = .IRAB[IRB$L_LST_NCMP];
	    IRAB[IRB$L_LST_NCMP] = .REC_ADDR;

	    BKT_ADDR = .NEW_BKT;

	    RM$COMPRESS_KEY (.REC_TO);

	    IRAB[IRB$L_LST_NCMP] = .SAVE_LST_NCMP;
	    REC_ADDR = .SAVE_REC_ADDR;

	    ! Adjust the freespace offset of the new bucket to reflect the
	    ! difference between the key size of the low-order key in its
	    ! new position (as low-order key of the new bucket), and the key
	    ! size of the low-order key in its old position (as a key somewhere
	    ! in the old bucket).
	    !
	    COMPRESSION = .REC_ADDR[KEY_LEN] - .REC_TO[KEY_LEN];

	    NEW_BKT[BKT$W_FREESPACE] = .NEW_BKT[BKT$W_FREESPACE] - .COMPRESSION;

	    ! If a SIDR bucket split occurred, adjust the record size field
	    ! of the SIDR that becomes the first SIDR in the new bucket, (the 
	    ! SIDR whose key was just front expanded), to reflect the difference
	    ! between the key size of the first SIDR in the new bucket, and the
	    ! key size of this SIDR in its old position in the old bucket 
	    ! (before the split took place). 
	    !
	    IF .NEW_BKT[BKT$B_LEVEL] EQLU 0
	    THEN
		(.REC_TO - IRC$C_DATSZFLD)<0,16> = 
			.(.REC_TO - IRC$C_DATSZFLD)<0,16> - .COMPRESSION;

	    ! If the new record is not to be inserted as the very first 
	    ! record in the new bucket, then the difference between the low 
	    ! order key in its old position in the old bucket and its new 
	    ! position as low order key of the new bucket must be saved (and 
	    ! already has as the value in COMPRESSION). It will be used in 
	    ! recomputing the point of insertion of the new record to be 
	    ! inserted if it is to go in the new bucket. If the new record is 
	    ! to be inserted as the very first record in the new bucket then 
	    ! this difference is not taken into account in the recomputation 
	    ! of the point of insertion, and so COMPRESSION is reset to 0.
	    !
	    IF  (.IRAB[IRB$W_POS_INS] EQLU .IRAB[IRB$W_SPLIT])
	    THEN 
		COMPRESSION = 0;

	    ! Having completed part 1 of the construction of the new bucket
	    ! (movement and recompression of the new bucket's low order key)
	    ! set up to remove the remainder of the old bucket which is to be 
	    ! moved into the new bucket. This will include the SIDR array of the
	    ! the new bucket's first record, if the split being processed is a
	    ! SIDR bucket split.
	    !
	    LENGTH = .LENGTH - .RECORD_OVHD -.REC_ADDR[KEY_LEN] - 2;
	    REC_FROM = .REC_ADDR + .REC_ADDR[KEY_LEN] + 2;
	    REC_TO = .REC_TO + .REC_TO[KEY_LEN] + 2;
	    END;

	! Move those records (and record parts if this is a SIDR bucket split)
	! remaining to be moved from the old to the new bucket. Note that this 
	! may include the first record of the new bucket (in those cases not 
	! requiring recomputation of the compression of the new low order key), 
	! and will include the VBNs for non-prologue 3 index and SIDR buckets, 
	! and prologue 3 SIDR buckets.
	!
	IF .LENGTH GTR 0
	THEN
	    CH$MOVE(.LENGTH,.REC_FROM,.REC_TO);
	END;

    NEW_BKT[BKT$W_FREESPACE] = .NEW_BKT[BKT$W_FREESPACE] + BKT$C_OVERHDSZ;

    ! The VBN chain will have to be separately moved if this is a prolgoue 3
    ! index bucket.
    !
    IF  .IFAB [IFB$B_PLG_VER] GEQU PLG$C_VER_3
	 AND
	.NEW_BKT[BKT$B_LEVEL] GTRU 0
    THEN
	RM$MOVE_VBNS(.NEW_BKT);

    ! If this is a level 0 bucket (SIDR data level) RMS must now reassign the 
    ! ID's of the records we moved out. This reassigning is only required for
    ! prologue 1 and 2 SIDR buckets, because prologue 3 SIDRs do not contain
    ! an ID.
    !
    IF  (.NEW_BKT[BKT$B_LEVEL] EQL 0)
	 AND
	(.IFAB[IFB$B_PLG_VER] LSSU PLG$C_VER_3)
    THEN
	BEGIN

	LOCAL
	    EOB,
	    ID;

	ID = 1;
	REC_ADDR = .NEW_BKT + BKT$C_OVERHDSZ;
	EOB = .NEW_BKT + .NEW_BKT[BKT$W_FREESPACE];

	! Reassign IDs to all the records in the prologue 2 SIDR bucket.
	!
	WHILE .REC_ADDR LSSA .EOB
	DO
	    BEGIN

	    ! Reassign the ID in the new bucket.
	    !
	    REC_ADDR[IRC$B_ID] = .ID;
	    ID = .ID + 1;
	    RM$GETNEXT_REC();
	    END;

	! Update the next ID field in bucket header.
	!
	NEW_BKT[BKT$B_NXTRECID] = .ID
	END;

    ! Now set up NEW_BKT and REC_ADDR to point to the buffer and position of
    ! insert for the new record.
    !
    IF .IRAB[IRB$V_REC_W_LO]
    THEN

	! Since IRAB[IRB$V_REC_W_LO] is set, the new record will be inserted
	! into the old bucket.
	!
	BEGIN
	NEW_BKT = .BBLOCK[.IRAB[IRB$L_CURBDB], BDB$L_ADDR];

	! If this is an index bucket split, and the point of insertion is
	! exactly the same as the split point, then two calls to RM$INS_REC
	! are required. The first pass will be to update the contents of the
	! (left) index bucket, as are required by the particular split case.
	! The second call will be to update the contents of the new (right)
	! index bucket as is required by the particular split case. 
	!
	IF  (.NEW_BKT[BKT$B_LEVEL] NEQ 0)
	    AND
	    (.IRAB[IRB$W_POS_INS] + .NEW_BKT EQLA .REC_ADDR)
	THEN
	    BEGIN
	    GLOBAL REGISTER
		R_BKT_ADDR;

	    IRAB[IRB$V_SPL_IDX] = 1;

	    ! First, the updating of the old (left) index bucket is done. This
	    ! will involve the insertion of a new key as the high key in the
	    ! bucket with its downpointer (pointing to the leftmost data 
	    ! bucket) left unchanged. However, if a two-pass two-bucket with
	    ! empty bucket split had taken place, then as there is no need to
	    ! update the old (left) index bucket, nothing is done.
	    !
	    ! There is one special case which is entirely handled by the
	    ! lower level routines. If only two keys fit in an index 
	    ! bucket, a multibucket split occurs, and both keys proceed
	    ! the lower order key, then both new keys must be put in
	    ! the old bucket instead of putting one in the old and the
	    ! other in the new index bucket. 
	    !
	    IF NOT (.IRAB[IRB$V_EMPTY_BKT]
		    AND
		   NOT .IRAB[IRB$V_BIG_SPLIT])
	    THEN
		BEGIN
		BKT_ADDR = .NEW_BKT;
		IF NOT RM$INS_REC(.NEW_BKT, RM$RECORD_SIZE())
		THEN
		    BUG_CHECK;
		END;

	    ! Finally, update the new (right) index bucket. This is done
	    ! by clearing IRAB[IRB$L_VBN_LEFT] and IRAB[IRB$V_SPL_IDX] 
	    ! as a signal that only a VBN should be swung, and in the
	    ! case of a multi-bucket non-empty bucket split, only a single 
	    ! key and VBN pair should be inserted into the new bucket.
	    !
	    ! If this is the two-pass two-bucket empty bucket split case then
	    ! this will be RMS's first and only call to RM$INS_REC. In such a
	    ! case we do not clear IRB$V_VBN_LEFT since we still have to
	    ! compare its contents to the downpointer of the first record
	    ! in the new (right) index bucket.
	    !
	    IF NOT (.IRAB[IRB$V_EMPTY_BKT]
		    AND
		   NOT .IRAB[IRB$V_BIG_SPLIT])
	    THEN
		IRAB[IRB$L_VBN_LEFT] = 0;

	    IRAB[IRB$V_SPL_IDX] = 0;
	    IRAB[IRB$L_REC_COUNT] = 0;
	    NEW_BKT = .BBLOCK[.IRAB[IRB$L_NXTBDB], BDB$L_ADDR];

	    ! If this is a multi-bucket split then we may have to insert a
	    ! new index record into the new (right) index bucket. This will
	    ! require adjustment of several IRAB cells for the second call
	    ! to RM$INS_REC.
	    !
	    IF .IRAB[IRB$V_BIG_SPLIT]
	    THEN

		! If this is the special multi-bucket split case which requires
		! both new keys to go in the old (left) bucket, or if this is
		! the two-pass multi-bucket with empty bucket split case, then
		! we just clear IRAB[IRB$L_VBN_MID] as a signal that just the 
		! VBN pointer need be swung.
		!
		IF ((.IRAB[IRB$W_POS_INS] EQLA BKT$C_OVERHDSZ)
		     OR
		    .IRAB[IRB$V_EMPTY_BKT])
		THEN 
		    IRAB[IRB$L_VBN_MID] = 0

		! If there is a new index record to be inserted into the new 
		! index bucket during the second call to RM$INS_REC, then
		! adjust the pointer to the last noncompressed key to be the
		! first record in the new (right) index bucket.
		!
		ELSE
		    IF .IDX_DFN[IDX$V_IDX_COMPR]
		    THEN 
		        IRAB[IRB$L_LST_NCMP] = .NEW_BKT + BKT$C_OVERHDSZ;

	    ! Make sure that the position of insertion of the new index records
	    ! (or position of replacement of the new VBNs if the VBN is just
	    ! to be swung) is at the first record of the new (right) index 
	    ! bucket.
	    !
	    IRAB[IRB$W_POS_INS] = BKT$C_OVERHDSZ;
	    END;				! Of BKT_ADDR definition

	END
    ELSE

	! If the record goes into the new bucket then adjust the offsets so
	! that things come out right later.
	!
	BEGIN

	! The only time it is not necessary to adjust the variable containing 
	! the address of the preceeding record by the number of bytes the first
	! record in the new bucket was front compressed is when the new record 
	! is a duplicate SIDR (ie the SIDR itself is the preceeding record), 
	! SIDR key compresion is enabled, and the SIDR occupies the first 
	! record position in the new bucket.
	!
	IF NOT (.IRAB[IRB$V_DUPS_SEEN]
			 AND
			.IDX_DFN[IDX$V_KEY_COMPR]
			 AND
			.IRAB[IRB$L_LST_REC] EQLA .IRAB[IRB$W_SPLIT])
	THEN
	    IRAB[IRB$L_LST_REC] = .IRAB[IRB$L_LST_REC] - .COMPRESSION;

	IRAB[IRB$W_POS_INS] = .IRAB[IRB$W_POS_INS] - .IRAB[IRB$W_SPLIT] 
						   + BKT$C_OVERHDSZ
						   - .COMPRESSION;

	IRAB[IRB$L_LST_REC] = .IRAB[IRB$L_LST_REC] - .IRAB[IRB$W_SPLIT] 
						   + BKT$C_OVERHDSZ;

	IF .IFAB [IFB$B_PLG_VER] GEQU PLG$C_VER_3
	THEN
	    BEGIN
	    IRAB [IRB$L_REC_COUNT] = .IRAB [IRB$L_REC_COUNT]
				      - .IRAB [IRB$L_SPL_COUNT];

	    ! If the record to be inserted is to go in the new bucket,
	    ! and the last noncompressed key remains in the old bucket,
	    ! or would follow the new record to be inserted, change this
	    ! pointer so that it points to the first record in the new bucket.
	    !
	    IF ((.NEW_BKT[BKT$B_LEVEL] EQLU 0
				 AND
				.IDX_DFN[IDX$V_KEY_COMPR])
			 OR
			(.NEW_BKT[BKT$B_LEVEL] NEQU 0
				 AND
				.IDX_DFN[IDX$V_IDX_COMPR]))
	       	AND	
	       NOT (.IRAB[IRB$L_LST_NCMP] GEQU .NEW_BKT 
			 AND
			.IRAB[IRB$L_LST_NCMP] LSSU .NEW_BKT + .IRAB[IRB$W_POS_INS])
	    THEN 
		IRAB[IRB$L_LST_NCMP] = .NEW_BKT + BKT$C_OVERHDSZ;
	    END;
		
	END;

    IRAB[IRB$L_LST_REC] = .IRAB[IRB$L_LST_REC] + .NEW_BKT;
    REC_ADDR = .IRAB[IRB$W_POS_INS] + .NEW_BKT;

    ! Call spread and insert appropriate record routine. The only possible error
    ! from this routine is a scarcity of ID's in the case of prologue 1 or 2
    ! and that is a bug here.
    !
    BEGIN

    GLOBAL REGISTER
	R_BKT_ADDR;

    BKT_ADDR = .NEW_BKT;

    IF NOT RM$INS_REC(.NEW_BKT, RM$RECORD_SIZE())
    THEN
	BUG_CHECK;

    END; ! Of bkt_addr definition

    END;

    ! Position to last record in left bucket and put key into keybuffer 2
    ! for index update.
    !
    RM$EXT_HIGH_KEY();
    RMSSUC (SUC)
    END;
	
END

ELUDOM
