MODULE INSMAIN (			! INSTALL Main Entry and Command processing
			IDENT = 'V04-000',
			ADDRESSING_MODE(EXTERNAL = GENERAL),
			MAIN = INSTALL_START
		 ) =
BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************

!++
! FACILITY:  Install
!
! ABSTRACT:
!
!	This module controls command parsing and processing.
!
! ENVIRONMENT:
!
!	VAX/VMS operating system.
!
! AUTHOR:  Bob Grosso, June 1981
!
! Modified by:
!
!	V03-015	MSH0061		Michael S. Harvey	5-Jul-1984
!		Add support for EXEONLY images. Also, don't carry old
!		PURGE context from a previous INSTALL action into a new
!		CREATE command.
!
!	V03-014	MSH0060		Michael S. Harvey	3-Jul-1984
!		Partially back off MSH0055 so that reasonable status
!		values don't cause the utility to exit.
!
!	V03-013	MSH0057		Michael S. Harvey	27-Jun-1984
!		Propagate /WRITEABLE attribute across REPLACE command
!		when appropriate.
!
!	V03-012	MSH0055		Michael S. Harvey	30-May-1984
!		Don't infinitely loop when an error occurs trying to
!		get a command line.
!
!	V03-011	MSH0052		Michael S. Harvey	22-May-1984
!		Prevent deleting wrong KFE by ensuring that the KFE
!		pointer contents is correct for all cases when opening
!		the image file.
!
!	V03-010	MSH0048		Michael S. Harvey	15-May-1984
!		Prevent some SPRs by adding some common sense to the
!		status reporting for the REPLACE command.
!
!	V03-009	MSH0031		Michael S. Harvey	12-Apr-1984
!		Ensure that a known file installed /OPEN is completely
!		mapped by the retrieval pointers.
!
!	V03-008	MSH0025		Michael S. Harvey	2-Apr-1984
!		Homogenize error reporting to prevent confusion (SPRs).
!
!	V03-007	MSH0022		Michael S. Harvey	15-Mar-1984
!		Fully resolve device specifications by unconcealing
!		the device. Eliminate middle directory brackets for
!		root directories.
!
!	V03-006	MSH0015		Michael S. Harvey	5-Mar-1984
!		Be a bit more intelligent when displaying other errors.
!
!	V03-005	MSH0009		Michael S. Harvey	16-Feb-1984
!		Don't report errors that DCLPARSE already reported.
!
!	V03-004	BLS0256		Benn Schreiber		27-Dec-1983
!		Allocate listing buffer once here. Use util$report_io_error
!		and util$getfilename.  Convert KFD directory specs
!		to all have angle brackets (square brackets not multinational).
!		Make DELETE work even if file has been deleted.
!
!	V03-003	BLS0245		Benn Schreiber		27-Oct-1983
!		Correct error severity for INS$_FAIL message to be
!		WARNING for /LIST and /DELETE.
!
!	V03-002	RPG0002		Bob Grosso		26-Aug-1983
!		Add a condition handler to record most severe error.
!		Comment code more thoroughly.
!
!	V03-001	RPG0001		Bob Grosso		24-Aug-1983
!		Check for Writeable qualifier before opening file
!		so that /WRITE works.
!		Re-activate header residency so that /HEAD works.
!
!-

%SBTTL  'Declarations';

!
! Include files
!

LIBRARY 'SYS$LIBRARY:LIB';		! VAX/VMS system definitions

EXTERNAL ROUTINE
    CLI$DCL_PARSE,			! Parse DCL command
    CLI$DISPATCH,			! Dispatch to verb routines
    CLI$PRESENT,			! Check if entity present
    CLI$GET_VALUE,			! Get value from command line
    LBR$OUTPUT_HELP,			! print interactive help
    LIB$GET_FOREIGN,			! get command line
    LIB$GET_INPUT,			! Get subcommands
    LIB$GET_VM,				! Allocate virtual memory
    LIB$PUT_OUTPUT,			! print help text
    PRV$SETPRIV,			! set privilege bits given ASCII string
    STR$COMPARE,			! compare two strings
    STR$CONCAT,				! concatenate strings
    STR$COPY_DX,			! Copy strings by descriptor
    STR$POSITION,    			! Find a substring on the command line
    STR$RIGHT,				! truncate part of command line
    STR$UPCASE,				! Raise case of command line
    UTIL$GETFILENAME,			! Get descriptor of file
    SYS$GETDVIW : ADDRESSING_MODE (GENERAL); ! Get Device Information

EXTERNAL LITERAL
    CLI$_NEGATED,			! Qualifier was explicitly negated
    CLI$_NOCOMD,			! Empty command line
    CLI$_NOQUAL,			! No qualifier permitted on command line
    PRV$_INVNAM,			! Invalid privilege name
    PRV$_NOTUNQ;			! Privilege name not unique

EXTERNAL LITERAL
    INS$C_FAOBUFLEN,			! Size of output buffer
    EXE$C_SYSEFN;			! System event flag, used when locking

EXTERNAL
    INS$FAOOUTBUF,			! Listing output buffer
    INS$FAOBUFDESC : $BBLOCK,		! Descriptor of output buffer
    CTL$GQ_PROCPRIV : $BBLOCK,		! privilege mask of user
    EXE$GQ_KFE_LCKNAM,			! Name of lock for Known file entries
    EXE$GL_SYSID_LOCK;			! System lock for KFE parent lock to
					!  avoid a trip down the CI on cluster systems

BIND
    INS$Q_LCKNAM = 	$DESCRIPTOR ('INSTALL$INSLOCK');



REQUIRE	'SRC$:INSPREFIX.REQ';
REQUIRE	'LIB$:INSDEF.R32';

EXTERNAL
    INSCMD;				! Tables describing the Install commands

EXTERNAL LITERAL
    INS$_DELETED,			! Previous Known File Entry deleted
    INS$_EXISTS,			! Known File Entry already exists
    INS$_FAIL,				! Unable to <OPERATION> <FILENAME>
    INS$_FAILED,			! Failed to process request for <FILENAME>
    INS$_FAILGETVM,			! Failed to get virtual memory
    INS$_HELP,				! Enter /HELP for INSTALL help
    INS$_INTRNLERR,			! Internal Error: error detail
    INS$_INVPRVNAM,			! Invalid privilege name
    INS$_NOKFEFND,			! Known File not found
    INS$_NOLOAD,			! Network and sequentially loaded files are not installable
    INS$_NOPREV,			! No KFE deleted during REPLACE operation
    INS$_PRVNOTUNQ,			! Privilege name not unique
    INS$_REMOVED;			! Entry for deleted file has been removed

!
! External routines
!

EXTERNAL ROUTINE

!   Routine		Defined in	Function    

    INS$PARSE_OLD_CMD,	! INSOLDCMD	Support the crusty old interface
    INS$CREATE,		! INSCREATE	perform CREATE command
    INS$DELETE,		! INSDELETE	perform DELETE command
    INS$PURGE,		! INSDELET	perform the PURGE command
    INS$GLOBAL,		! INSGLOBAL	list global sections
    INS$LIST;		! INSLIST	list known file entries

!
! Table of contents
!

FORWARD ROUTINE
    PARSE_NEW_CMD,			! Call the new Dispatch routines
    INS$HELP_VERB,			! Perform HELP function
    INS$EXECUTE_IN_EXEC_WITH_R_LOCK,	! Execute in exec mode to take out read lock and then execute routine 
    INS$EXECUTE_IN_KRNL_WITH_W_LOCK,	! Execute in kernel mode to take out write lock and then execute routine
    EXECUTE_WITH_R_LOCK,		! Take out read lock and then execute routine 
    EXECUTE_WITH_W_LOCK,		! Take out write lock and then execute routine
    INS$CNVRT_KF_LOCK,			! Convert the mode of the KF lock
    INS$CVT_DIR : NOVALUE,		! Convert and compress directory brackets
    INS$OPEN_FILE,			! handle file open processing
    INS$CLOSE_FILE,			! handle file close
    INS$CHECK_PRIV,			! enforce privilege check in case INSTALL is installed
    INS_HANDLER;			! Handler to pick up highest severity

GLOBAL
    SGN$GB_KFHSHSIZ,			! @@ Remove
    INS$L_INTRNLERR,			! Pass back address of internal error descriptor
    INS$G_KFENAM : $NAM_DECL,		! file name block declaration
    INS$GL_KFECHAN,			! channel on which known file is open
    INS$GL_CTLMSK : BLOCK [1],		! Control flags resulting from command parse
    INS$GL_REPLACE_MSK: BLOCK [1],	! Control flags saved for REPLACE
    INS$GQ_KFERNS : 			! buffer for resultant name 
	$BBLOCK [DSC$C_S_BLN],	
    INS$GL_KFEADR,			! Address of known file entry
    INS$GQ_KFEPRIVS : $BBLOCK [8],	! Quadword privilege mask resulting from command parse
    INS$GQ_FILDSC : DYN_DESC_DECL,	! descriptor to obtain filename 
					!  returned during command parse

    INS$G_OUTRAB : $RAB_DECL,		! Used for output by INS$LIST and 
    INS$G_OUTFAB : $FAB_DECL,		!   INS$GLOBAL
    INS$G_KFEFAB : $FAB_DECL,		! file access block declaration
    INS$G_KF_LKSB : $BBLOCK [8],	! Known file entries Lock status block 
    INS$G_INS_LKSB : $BBLOCK [8];	! INSTALL lock status block

OWN
    INS$EXIT_STATUS : $BBLOCK [4] 	! Store worst error status to exit with
	INITIAL (SS$_NORMAL),
    PARSE_CMD_DESC : DYN_DESC_DECL,	! descriptor of "INSTALL>" concatenated with input string
    INPUT_DESC : DYN_DESC_DECL,		! command string input
    VERB_DESC : DYN_DESC_DECL,		!
    HELP_DESC : DYN_DESC_DECL,		!
    PRIV_DSC : DYN_DESC_DECL,		! For parsing privileges on command line
    INTERACTIVE,			! boolean to record if this is a single execution of a 
					!  foreign command or an interactive session.
    COMMAND_MODE;			! Boolean to recall which CLD to use

LITERAL
    NEW = 1,				! use New command verb interface
    OLD = 0;				! use old command qualifier interface

!
! Define shared messages for local use
!
$SHR_MSGDEF(INS,123,LOCAL,
	(OPENIN,ERROR));

BIND
    ! Descriptors of command strings used during command parseing

    COMMAND_MODE_DSC = 	$DESCRIPTOR ('COMMAND_MODE'),
    SLASH_COMM_DSC =	$DESCRIPTOR ('/COMM'),

    HEL_DSC = 		$DESCRIPTOR ('HEL'),
    HELP_DSC = 		$DESCRIPTOR ('HELP'),

    FILE_SPEC_DSC = 	$DESCRIPTOR ('FILE_SPEC'),

    CREATE_DSC = 	$DESCRIPTOR ('CREATE'),
    REPLACE_DSC = 	$DESCRIPTOR ('REPLACE'),
    DELETE_DSC = 	$DESCRIPTOR ('DELETE'),
    REMOVE_DSC = 	$DESCRIPTOR ('REMOVE'),
    LIST_DSC = 		$DESCRIPTOR ('LIST'),
    LOG_DSC = 		$DESCRIPTOR ('LOG'),
    GLOBAL_DSC = 	$DESCRIPTOR ('GLOBAL'),

    PRIVILEGED_DSC = 	$DESCRIPTOR ('PRIVILEGED'),
    HDRRES_DSC =	$DESCRIPTOR ('HEADER_RESIDENT'),
    PROCESS_DSC = 	$DESCRIPTOR ('PROCESS'),
    SHARED_DSC = 	$DESCRIPTOR ('SHARED'),
    OPEN_DSC = 		$DESCRIPTOR ('OPEN'),
    PROTECT_DSC = 	$DESCRIPTOR ('PROTECTED'),
    WRITE_DSC = 	$DESCRIPTOR ('WRITEABLE'),
    PURGE_DSC = 	$DESCRIPTOR ('PURGE'),
    ACCOUNT_DSC = 	$DESCRIPTOR ('ACCOUNTING'),
    XONLY_DSC =		$DESCRIPTOR ('EXECUTE_ONLY');


%SBTTL  'INSTALL_START';

GLOBAL ROUTINE  INSTALL_START =
BEGIN
!+++
!
!  FUNCTIONAL DESCRIPTION:
!
!	Check if there is a foreign command.
!	If there is, see if it is preceded by /COMMAND_MODE which places INSTALL
!	into the new command verb mode.  Then if /COMMAND_MODE is followed by
!	a command, executed it as a single foreign command and terminate.
!	If /COMMAND_MODE specified alone, execute in command prompting mode
!	and parse for new command verbs.
!
!	If no /COMMAND_MODE present on foreign command line, then parse using 
!	the trashy old command qualifier interface.  Execute a foreign and quit
!	or drop into prompt mode if no foreign command.
!
!  IMPLICIT INPUT:
!
!	none
!
!  OUTPUT:
!
!	Print command line prompt and signal any errors.
!
!  IMPLICIT OUTPUT:
!
!	none
!
!  ROUTINE VALUE:
!
!	Low bit set for success.  All errors are signalled.
!
!---
LOCAL
    DDTSTR : BBLOCK [NAM$C_MAXRSS],
    STATUS;

BUILTIN
    FP;

.FP = INS_HANDLER;			!Set handler

!+++
!
!   Initialization
!
!---

INS$GQ_KFERNS [DSC$A_POINTER] = DDTSTR;		! Initialize DDT string pointer

COMMAND_MODE = OLD;


SGN$GB_KFHSHSIZ = 128;				! *** Replace with a literal ***

$FAB_INIT(					! Initialize the File Access Block
	FAB = INS$G_OUTFAB,
	FAC = PUT,
	RAT = CR,
	FNM = 'SYS$OUTPUT'
	);
$RAB_INIT(					! Initialize the Record Access Block
	RAB = INS$G_OUTRAB,
	FAB = INS$G_OUTFAB
	);
REPORT ($CREATE (FAB = INS$G_OUTFAB) );		! Create a channel to sys$output
REPORT ($CONNECT (RAB = INS$G_OUTRAB) );	! Connect to the channel

!
! Allocate fao output buffer
!
IF NOT (STATUS = LIB$GET_VM(%REF(INS$C_FAOBUFLEN), INS$FAOOUTBUF))
    THEN RETURN SIGNAL(INS$_FAILGETVM,1,INS$C_FAOBUFLEN,.STATUS);

!+++
!
!   See if there is a foreign command line.  If there is 
!   and it is not blank then flag non-interactive mode 
!   and execute only that command.
!
!---

INTERACTIVE = TRUE;				! Will loop for command input

REPORT (LIB$GET_FOREIGN( INPUT_DESC ) );
IF ( .INPUT_DESC [DSC$W_LENGTH] NEQ 0 ) AND	! If there is something on the line 
   NOT CH$FAIL( CH$FIND_NOT_CH			! and there is something besides blanks
	( .INPUT_DESC[DSC$W_LENGTH], 
	.INPUT_DESC[DSC$A_POINTER], %C' '))	
THEN
    BEGIN
    LOCAL
	CMD_PTR,
	CMD_LEN;
    MAP
	COMMAND_MODE_DSC : $BBLOCK;

    STR$UPCASE ( PARSE_CMD_DESC, INPUT_DESC );	! Upcase and copy to PARSE_CMD_DESC

    !+++
    !
    !   Check for /COMMAND_MODE
    !	If present by itself, then switch to new Command Language Definition
    !	and go interactive.
    !	If present, then switch to new Command Language Definition then execute
    !	the remainder of the command line as a single command and exit.
    !	
    !
    !---

    CMD_PTR = STR$POSITION ( PARSE_CMD_DESC, SLASH_COMM_DSC);	! Look for "/COMM" on COMMAND_MODE line
    IF .CMD_PTR NEQ 0						! If found
    THEN
	BEGIN
	LOCAL
	    PC_PTR : REF $BBLOCK,
	    SC_PTR : REF $BBLOCK;

	!
	!   Remove as much of "/COMMAND_MODE" as was present
	!
	PC_PTR = .PARSE_CMD_DESC [DSC$A_POINTER] + 5;
	SC_PTR = .COMMAND_MODE_DSC [DSC$A_POINTER] + 4;
	CMD_LEN = 5;

	WHILE .(.PC_PTR) <0, 8> EQL .(.SC_PTR) <0, 8> AND 
		.CMD_LEN LSS .PARSE_CMD_DESC [DSC$W_LENGTH] 
	DO
	    BEGIN
	    PC_PTR = .PC_PTR + 1;
	    SC_PTR = .SC_PTR + 1;
	    CMD_LEN = .CMD_LEN + 1;
	    END;

	!
	!   We've marched to the end of however much of "/COMMAND_MODE" had
	!   been entered.  Now drop that part and if anything is left
	!   treat it as a single command and then exit, otherwise, mark
	!   new CLD and proceed as though interactive, i.e. no foreign command.
	!
	STR$RIGHT ( PARSE_CMD_DESC, PARSE_CMD_DESC, %REF (.CMD_PTR+.CMD_LEN) );
	COMMAND_MODE = NEW;

	IF ( .PARSE_CMD_DESC [DSC$W_LENGTH] NEQ 0 ) AND	! If there is something on the line 
	   NOT CH$FAIL( CH$FIND_NOT_CH			! and there is something besides blanks
		( .PARSE_CMD_DESC [DSC$W_LENGTH], 
		.PARSE_CMD_DESC [DSC$A_POINTER], %C' '))
	THEN
	    INTERACTIVE = FALSE;			! There was something on line other than /COMMAND_MODE
							!  so execute the rest and then quit
	END						! /COMMAND_MODE was entered as foreign command
    ELSE
	INTERACTIVE = FALSE;				! Foreign command was present but did not include /COMMAND_MODE
    END;

INS$L_INTRNLERR = 0;					! clear internal error descriptor

IF .COMMAND_MODE EQL OLD 
THEN 
    INS$PARSE_OLD_CMD (PARSE_CMD_DESC, .INTERACTIVE)
ELSE
    PARSE_NEW_CMD ();

RETURN (STATUS = .INS$EXIT_STATUS OR STS$M_INHIB_MSG);	! Return worst status

END;		! Global routine install_start


%SBTTL  'parse_new_cmd';

ROUTINE  PARSE_NEW_CMD =
BEGIN
!+++
!
!
!---
LOCAL
    STATUS;

IF NOT .INTERACTIVE 
THEN
    BEGIN

    STATUS = CLI$DCL_PARSE( PARSE_CMD_DESC, INSCMD );	! parse the command line
    IF .STATUS 
    THEN 
	REPORT (CLI$DISPATCH () );
    END

ELSE					! INTERACTIVE
    BEGIN
    DO					! Keep looping while still interactive
	BEGIN

	DO STATUS = CLI$DCL_PARSE (0, INSCMD, LIB$GET_INPUT, 
			LIB$GET_INPUT, $DESCRIPTOR('INSTALL> ') )
	UNTIL .STATUS NEQ CLI$_NOCOMD;

	IF .STATUS 
	THEN 
	    BEGIN
	    INS$L_INTRNLERR = 0;	! clear internal error descriptor
	    REPORT (CLI$DISPATCH ());
	    END
	ELSE
	    BEGIN
	    IF .STATUS EQL RMS$_FNF THEN RETURN .STATUS;
	    IF .STATUS EQL RMS$_EOF THEN RETURN TRUE;
	    IF .STATUS EQL CLI$_NOQUAL
	    THEN
		BEGIN
		!
		!	If status is CLI$_NOQUAL then user may have typed
		!	HELP /QUALIFIER and we really should drop into HELP
		!	for him rather than barf out with a noqual message.
		!
		LOCAL
		    HELP_PTR;

		CLI$GET_VALUE (%ASCID '$LINE', VERB_DESC);

		HELP_PTR = STR$POSITION (VERB_DESC, HEL_DSC);
		IF .HELP_PTR NEQ 0
		THEN
		    INS$HELP_VERB ()
		ELSE
		    SIGNAL (.STATUS);
		END;
	    END;
	END				! end of DO-WHILE interactive
    WHILE .INTERACTIVE;
    END;				! Interactive

RETURN TRUE;
END;					! Routine parse_new_cmd


%SBTTL	'INS$HELP_VERB';
GLOBAL ROUTINE INS$HELP_VERB =
!+++
!
!   New command interface action routine for HELP
!   Request help be printed by lib$put_output to sys$output,
!   from library SYS$HELP:INSTALHLP.HLB.  Query for additional help
!   to sys$input using lib$get_input.
!
!---
BEGIN

CLI$GET_VALUE (%ASCID 'HELP_LINE', HELP_DESC);

REPORT ( LBR$OUTPUT_HELP (LIB$PUT_OUTPUT, 0, HELP_DESC,
		$DESCRIPTOR('INSTALHLP'), 0,LIB$GET_INPUT) );
RETURN TRUE;
END;					! routine INS$HELP_VERB


%SBTTL	'INS$EXIT_VERB';
GLOBAL ROUTINE INS$EXIT_VERB =
!+++
!
!   New command interface action routine for EXIT
!
!---
BEGIN
INTERACTIVE = FALSE;
RETURN TRUE;
END;					! Routine INS$EXIT_VERB


%SBTTL	'INS$CREATE_VERB';
GLOBAL ROUTINE INS$CREATE_VERB =
!+++
!
!   New command interface action routine for CREATE
!
!---
BEGIN
LOCAL
    PURGE,
    CMK_ARGLST : VECTOR [1],	! arguement list for change mode dispatcher
    OPEN_STATUS,
    STATUS;

INS$GL_CTLMSK [INS$V_PROCESS] = CLI$PRESENT( PROCESS_DSC );
IF NOT .INS$GL_CTLMSK [INS$V_PROCESS]
THEN
    BEGIN
    !
    !	Since INSTALL may be installed with CMKRNL privilege,
    !	check that user has CMKRNL privilege before allowing
    !	any operations other than /PROCESS operations.
    !
    CMK_ARGLST [0] = 0;
    STATUS = $CMKRNL (ROUTIN = INS$CHECK_PRIV, ARGLST = CMK_ARGLST);
    IF NOT .STATUS
    THEN
	BEGIN
	SIGNAL (SS$_NOCMKRNL);
	RETURN TRUE;
	END;

    INS$GL_CTLMSK [INS$V_PRIV] = CLI$PRESENT( PRIVILEGED_DSC );
    IF .INS$GL_CTLMSK [INS$V_PRIV]
    THEN
	BEGIN
	LOCAL
	    ALL_PRIVS;	! boolean

	ALL_PRIVS = TRUE;					! turn on all privs by default
	CH$FILL (0, 8, INS$GQ_KFEPRIVS);			! initialize privilege quadword to zeros
	WHILE CLI$GET_VALUE ( PRIVILEGED_DSC, PRIV_DSC ) DO
	    BEGIN
	    ALL_PRIVS = FALSE;					! turn off default
	    SELECT PRV$SETPRIV (PRIV_DSC, INS$GQ_KFEPRIVS) OF	! set the appropriate bit in the mask
		SET

		[PRV$_INVNAM]:
		    BEGIN
		    SIGNAL (INS$_INVPRVNAM, 1, PRIV_DSC);
		    RETURN TRUE;
		    END;

		[PRV$_NOTUNQ]:
		    BEGIN
		    SIGNAL (INS$_PRVNOTUNQ, 1, PRIV_DSC);
		    RETURN TRUE;
		    END;
		TES;
	    END;			! end while there are more privs
	IF .ALL_PRIVS					! No privs specified with /PRIV so
	THEN CH$FILL (-1, 8, INS$GQ_KFEPRIVS);		! use default of all privs set
	END;				! /PRIV

    END;				! Not /PROCESS

INS$GL_CTLMSK [INS$V_FILSPC] = CLI$PRESENT( FILE_SPEC_DSC );

    INS$GL_CTLMSK [INS$V_WRITABLE] = CLI$PRESENT( WRITE_DSC );	! Get WRITE before we open file

    !
    ! Get the file spec from the CLI
    !
    REPORT( CLI$GET_VALUE ( FILE_SPEC_DSC, INS$GQ_FILDSC) );
    OPEN_STATUS = INS$OPEN_FILE ();
    IF (NOT .OPEN_STATUS)
    THEN 
	BEGIN
	INS$CLOSE_FILE ();
	RETURN TRUE;
	END;

    IF .INS$GL_KFEADR EQL 0 
    THEN 
	BEGIN
	INS$GL_CTLMSK [INS$V_NOPURGE] = FALSE;
	PURGE = CLI$PRESENT( PURGE_DSC );
	IF .PURGE EQL CLI$_NEGATED THEN INS$GL_CTLMSK [INS$V_NOPURGE] = TRUE;
	
	INS$GL_CTLMSK [INS$V_PROTECT] = CLI$PRESENT( PROTECT_DSC );
	INS$GL_CTLMSK [INS$V_OPEN] = CLI$PRESENT( OPEN_DSC );
	INS$GL_CTLMSK [INS$V_HDRRES] = CLI$PRESENT( HDRRES_DSC );

	INS$GL_CTLMSK [INS$V_SHARED] = CLI$PRESENT( SHARED_DSC );
	INS$GL_CTLMSK [INS$V_ACCOUNT] = CLI$PRESENT( ACCOUNT_DSC );
	INS$GL_CTLMSK [INS$V_EXEONLY] = CLI$PRESENT( XONLY_DSC );

	STATUS = INS$CREATE ();		! Create it
	END
    ELSE
	STATUS = INS$_EXISTS;

    IF NOT .STATUS
    THEN
	BEGIN 
	IF .STATUS EQL INS$_INTRNLERR
	THEN
	    SIGNAL (INS$_FAIL,2,CREATE_DSC,INS$GQ_KFERNS,
			.STATUS,1,.INS$L_INTRNLERR)
	ELSE
	    SIGNAL (INS$_FAIL,2,CREATE_DSC,INS$GQ_KFERNS,.STATUS);
	END
    ELSE
	BEGIN
	!
	!   See if it should be logged
	!
	IF CLI$PRESENT( LOG_DSC )
	THEN
	    BEGIN
	    INS$GL_CTLMSK [INS$V_FULL] = TRUE;
	    INS$LIST (.INS$GL_KFEADR);	
	    INS$GLOBAL (.INS$GL_KFEADR);
	    END;
	END;

    INS$CLOSE_FILE ();

RETURN TRUE;
END;					! routine INS$CREATE_VERB


%SBTTL	'INS$REPLACE_VERB';
GLOBAL ROUTINE INS$REPLACE_VERB =
!+++
!
!   New command interface action routine for REPLACE
!
!---
BEGIN
LOCAL
    DELETED,
    QUAL_PRESENT,
    CMK_ARGLST : VECTOR [1],	! arguement list for change mode dispatcher
    OPEN_STATUS,
    STATUS;

INS$GL_CTLMSK [INS$V_PROCESS] = CLI$PRESENT( PROCESS_DSC );
IF NOT .INS$GL_CTLMSK [INS$V_PROCESS]
THEN
    BEGIN
    !
    !	Since INSTALL may be installed with CMKRNL privilege,
    !	check that user has CMKRNL privilege before allowing
    !	any operations other than /PROCESS operations.
    !
    CMK_ARGLST [0] = 0;
    STATUS = $CMKRNL (ROUTIN = INS$CHECK_PRIV, ARGLST = CMK_ARGLST);
    IF NOT .STATUS
    THEN
	BEGIN
	SIGNAL (SS$_NOCMKRNL);
	RETURN TRUE;
	END;
    END;

INS$GL_CTLMSK [INS$V_FILSPC] = CLI$PRESENT( FILE_SPEC_DSC );

    !
    ! Get the file spec from the CLI
    !
    REPORT( CLI$GET_VALUE ( FILE_SPEC_DSC, INS$GQ_FILDSC) );
    OPEN_STATUS = INS$OPEN_FILE ();
    IF (NOT .OPEN_STATUS)
    THEN 
	BEGIN
	INS$CLOSE_FILE ();
	RETURN TRUE;
	END;

    !
    !   Delete and recreate with new attributes
    !
    INS$GL_CTLMSK [INS$V_DELETE] = TRUE;	! set delete flag
    INS$GL_CTLMSK [INS$V_REPLACE] = TRUE;	! set replace flag so that attributes
						! will be returned in INS$GL_REPLACE_MSK
    INS$GL_REPLACE_MSK = 0;
    STATUS = INS$DELETE ();	 		! recreate it
    IF NOT .STATUS
    THEN
	BEGIN 
	DELETED = FALSE;			! Record status of delete step

	IF .STATUS EQL INS$_INTRNLERR
	THEN
	    SIGNAL (((INS$_FAIL AND NOT STS$M_SEVERITY) OR STS$K_WARNING),
			2,DELETE_DSC,INS$GQ_KFERNS,
			.STATUS,1,.INS$L_INTRNLERR);
	END
    ELSE
	DELETED = TRUE;				! Record status of delete step

    INS$GL_KFEADR = 0;				! Entry has gone away
    INS$CLOSE_FILE ();

    INS$GL_CTLMSK = .INS$GL_REPLACE_MSK;	! use replace mask
    INS$GL_CTLMSK [INS$V_CREATE] = TRUE;	! set create flag
    INS$GL_CTLMSK [INS$V_DELETE] = FALSE;	! clear delete flag

    !
    !	If any qualifiers were specified with REPLACE then
    !	check they override the current installed attributes.
    !	If they are negated they serve to remove the current attribute.
    !
    QUAL_PRESENT = CLI$PRESENT( PURGE_DSC );
    IF .QUAL_PRESENT THEN INS$GL_CTLMSK [INS$V_NOPURGE] = FALSE;
    IF .QUAL_PRESENT EQL CLI$_NEGATED THEN INS$GL_CTLMSK [INS$V_NOPURGE] = TRUE;

    QUAL_PRESENT = CLI$PRESENT( PROTECT_DSC );
    IF .QUAL_PRESENT THEN INS$GL_CTLMSK [INS$V_PROTECT] = TRUE;
    IF .QUAL_PRESENT EQL CLI$_NEGATED THEN INS$GL_CTLMSK [INS$V_PROTECT] = FALSE;

    QUAL_PRESENT = CLI$PRESENT( OPEN_DSC );
    IF .QUAL_PRESENT THEN INS$GL_CTLMSK [INS$V_OPEN] = TRUE;
    IF .QUAL_PRESENT EQL CLI$_NEGATED THEN INS$GL_CTLMSK [INS$V_OPEN] = FALSE;

    QUAL_PRESENT = CLI$PRESENT( HDRRES_DSC );
    IF .QUAL_PRESENT THEN INS$GL_CTLMSK [INS$V_HDRRES] = TRUE;
    IF .QUAL_PRESENT EQL CLI$_NEGATED THEN INS$GL_CTLMSK [INS$V_HDRRES] = FALSE;

    QUAL_PRESENT = CLI$PRESENT( PRIVILEGED_DSC );
    IF .QUAL_PRESENT 
    THEN 
	BEGIN
	LOCAL
	    ALL_PRIVS;	! boolean

	INS$GL_CTLMSK [INS$V_PRIV] = TRUE;
	ALL_PRIVS = TRUE;					! turn on all privs by default
	CH$FILL (0, 8, INS$GQ_KFEPRIVS);			! initialize privilege quadword to zeros
	WHILE CLI$GET_VALUE ( PRIVILEGED_DSC, PRIV_DSC ) DO
	    BEGIN
	    ALL_PRIVS = FALSE;					! turn off default
	    SELECT PRV$SETPRIV (PRIV_DSC, INS$GQ_KFEPRIVS) OF	! set the appropriate bit in the mask
		SET

		[PRV$_INVNAM]:
		    BEGIN
		    SIGNAL (INS$_INVPRVNAM, 1, PRIV_DSC);
		    RETURN TRUE;
		    END;

		[PRV$_NOTUNQ]:
		    BEGIN
		    SIGNAL (INS$_PRVNOTUNQ, 1, PRIV_DSC);
		    RETURN TRUE;
		    END;
		TES;
	    END;			! end while there are more privs
	IF .ALL_PRIVS					! No privs specified with /PRIV so
	THEN CH$FILL (-1, 8, INS$GQ_KFEPRIVS);		! use default of all privs set
	END;				! /PRIV
    IF .QUAL_PRESENT EQL CLI$_NEGATED THEN INS$GL_CTLMSK [INS$V_PRIV] = FALSE;

    QUAL_PRESENT = CLI$PRESENT( SHARED_DSC );
    IF .QUAL_PRESENT THEN INS$GL_CTLMSK [INS$V_SHARED] = TRUE;
    IF .QUAL_PRESENT EQL CLI$_NEGATED THEN INS$GL_CTLMSK [INS$V_SHARED] = FALSE;

    IF .INS$GL_CTLMSK [INS$V_SHARED]
    THEN
	BEGIN
	QUAL_PRESENT = CLI$PRESENT( WRITE_DSC );
	IF .QUAL_PRESENT THEN INS$GL_CTLMSK [INS$V_WRITABLE] = TRUE;
	IF .QUAL_PRESENT EQL CLI$_NEGATED THEN INS$GL_CTLMSK [INS$V_WRITABLE] = FALSE;
	END
    ELSE
	INS$GL_CTLMSK [INS$V_WRITABLE] = FALSE;

    QUAL_PRESENT = CLI$PRESENT( ACCOUNT_DSC );
    IF .QUAL_PRESENT THEN INS$GL_CTLMSK [INS$V_ACCOUNT] = TRUE;
    IF .QUAL_PRESENT EQL CLI$_NEGATED THEN INS$GL_CTLMSK [INS$V_ACCOUNT] = FALSE;

    QUAL_PRESENT = CLI$PRESENT( XONLY_DSC );
    IF .QUAL_PRESENT THEN INS$GL_CTLMSK [INS$V_EXEONLY] = TRUE;
    IF .QUAL_PRESENT EQL CLI$_NEGATED THEN INS$GL_CTLMSK [INS$V_EXEONLY] = FALSE;

    INS$OPEN_FILE ();

    IF .INS$GL_KFEADR EQL 0 
    THEN 
	STATUS = INS$CREATE () 		! recreate it
    ELSE
	STATUS = INS$_EXISTS;

    IF NOT .STATUS
    THEN
	BEGIN 
	IF .STATUS EQL INS$_INTRNLERR
	THEN
	    SIGNAL (INS$_FAIL,2,REPLACE_DSC,INS$GQ_KFERNS,
			.STATUS,1,.INS$L_INTRNLERR)
	ELSE
	    BEGIN
	    SIGNAL (INS$_FAIL,2,REPLACE_DSC,INS$GQ_KFERNS,.STATUS);
	    IF .DELETED
	    THEN
		SIGNAL (INS$_DELETED);
	    END;
	END
    ELSE
	BEGIN
	IF NOT .DELETED
	THEN
	    SIGNAL (INS$_NOPREV,1,INS$GQ_KFERNS); ! Report qualified success

	!
	!   See if it should be logged
	!
	IF CLI$PRESENT( LOG_DSC )
	THEN
	    BEGIN
	    INS$GL_CTLMSK [INS$V_FULL] = TRUE;
	    INS$LIST (.INS$GL_KFEADR);	
	    INS$GLOBAL (.INS$GL_KFEADR);
	    END;
	END;


RETURN TRUE;
END;					! routine INS$REPLACE_VERB

%SBTTL	'INS$REMOVE_VERB';
GLOBAL ROUTINE INS$REMOVE_VERB =
!+++
!
!   New command interface action routine for REMOVE
!
!---
BEGIN
LOCAL
    CMK_ARGLST : VECTOR [1],	! arguement list for change mode dispatcher
    OPEN_STATUS,
    STATUS;

!
! Make delete and remove synonomous actions
!
INS$GL_CTLMSK [INS$V_PROCESS] = CLI$PRESENT( PROCESS_DSC );
IF NOT .INS$GL_CTLMSK [INS$V_PROCESS]
THEN
    BEGIN
    !
    !	Since INSTALL may be installed with CMKRNL privilege,
    !	check that user has CMKRNL privilege before allowing
    !	any operations other than /PROCESS operations.
    !
    CMK_ARGLST [0] = 0;
    STATUS = $CMKRNL (ROUTIN = INS$CHECK_PRIV, ARGLST = CMK_ARGLST);
    IF NOT .STATUS
    THEN
	BEGIN
	SIGNAL (SS$_NOCMKRNL);
	RETURN TRUE;
	END;
    END;

INS$GL_CTLMSK [INS$V_FILSPC] = CLI$PRESENT( FILE_SPEC_DSC );
    !
    ! Get the file spec from the CLI
    !
    REPORT( CLI$GET_VALUE ( FILE_SPEC_DSC, INS$GQ_FILDSC) );
    OPEN_STATUS = INS$OPEN_FILE ();
    IF .OPEN_STATUS
    THEN 
	BEGIN
	IF .INS$GL_KFEADR NEQ 0 
	THEN 
	    STATUS = INS$DELETE () 		! delete it
	ELSE
	    STATUS = INS$_NOKFEFND;
	END

    ELSE				! Not opened, try to remove entry
	BEGIN
	INS$CLOSE_FILE ();
	STATUS = INS$DELETE ();		! INS$DELETE with INS$GL_KFEADR = 0 is a REMOVE
	IF .STATUS 
	THEN 
	    BEGIN
	    SIGNAL (.STATUS, 1, INS$GQ_KFERNS);
	    RETURN TRUE;
	    END;
	END;

    IF NOT .STATUS
    THEN
	BEGIN 
	IF .STATUS EQL INS$_INTRNLERR
	THEN
	    SIGNAL (((INS$_FAIL AND NOT STS$M_SEVERITY) OR STS$K_WARNING),
		2,REMOVE_DSC,INS$GQ_KFERNS,.STATUS,1,.INS$L_INTRNLERR)
	ELSE
	    SIGNAL (((INS$_FAIL AND NOT STS$M_SEVERITY) OR STS$K_WARNING),
		2,REMOVE_DSC,INS$GQ_KFERNS,.STATUS);
	END;

RETURN TRUE;
END;					! routine INS$REMOVE_VERB


%SBTTL	'INS$PURGE_VERB';
GLOBAL ROUTINE INS$PURGE_VERB =
!+++
!
!   New command interface action routine for PURGE
!
!---
BEGIN
LOCAL
    CMK_ARGLST : VECTOR [1],	! arguement list for change mode dispatcher
    STATUS;

INS$GL_CTLMSK [INS$V_PROCESS] = CLI$PRESENT( PROCESS_DSC );
IF NOT .INS$GL_CTLMSK [INS$V_PROCESS]
THEN
    BEGIN
    !
    !	Since INSTALL may be installed with CMKRNL privilege,
    !	check that user has CMKRNL privilege before allowing
    !	any operations other than /PROCESS operations.
    !
    CMK_ARGLST [0] = 0;
    STATUS = $CMKRNL (ROUTIN = INS$CHECK_PRIV, ARGLST = CMK_ARGLST);
    IF NOT .STATUS
    THEN
	BEGIN
	SIGNAL (SS$_NOCMKRNL);
	RETURN TRUE;
	END;
    END;

STATUS = INS$PURGE ();
IF NOT .STATUS 
THEN 
    SIGNAL (INS$_FAILED, 1, PURGE_DSC, .STATUS);

RETURN TRUE;
END;					! routine INS$PURGE_VERB


%SBTTL	'INS$LIST_VERB';
GLOBAL ROUTINE INS$LIST_VERB =
!+++
!
!   New command interface action routine for LIST
!
!---
BEGIN
LOCAL
    STATUS;

INS$GL_CTLMSK [INS$V_FILSPC] = CLI$PRESENT( FILE_SPEC_DSC );
INS$GL_CTLMSK [INS$V_FULL] = CLI$PRESENT( %ASCID 'FULL' );
INS$GL_CTLMSK [INS$V_STRUCTURE] = CLI$PRESENT( %ASCID 'STRUCTURE' );
INS$GL_CTLMSK [INS$V_GLOBAL] = CLI$PRESENT( GLOBAL_DSC );
INS$GL_CTLMSK [INS$V_PROCESS] = CLI$PRESENT( PROCESS_DSC );
INS$GL_CTLMSK [INS$V_PROCESS] = CLI$PRESENT( PROCESS_DSC );

IF NOT .INS$GL_CTLMSK [INS$V_FILSPC]
THEN
    BEGIN
    !
    !	If LIST /GLOBAL then only print global sections
    !
    IF .INS$GL_CTLMSK [INS$V_GLOBAL]
    THEN
	BEGIN
	STATUS = INS$GLOBAL ();
	IF NOT .STATUS 
	THEN 
	    SIGNAL (((INS$_FAILED AND NOT STS$M_SEVERITY) OR STS$K_WARNING),
				1, GLOBAL_DSC, .STATUS);
	END
    ELSE
	BEGIN
	STATUS = INS$LIST (0);
	IF NOT .STATUS 
	THEN 
	    SIGNAL (((INS$_FAILED AND NOT STS$M_SEVERITY) OR STS$K_WARNING),
				1, LIST_DSC, .STATUS);
	END;
    END
ELSE
    BEGIN
    LOCAL
	OPEN_STATUS,
	STATUS;

    !
    ! Get the file spec from the CLI
    !
    REPORT( CLI$GET_VALUE ( FILE_SPEC_DSC, INS$GQ_FILDSC) );
    OPEN_STATUS = INS$OPEN_FILE ();
    IF (NOT .OPEN_STATUS)
    THEN 
	BEGIN
	INS$CLOSE_FILE ();
	RETURN TRUE;
	END;

    IF .INS$GL_KFEADR EQL 0 
    THEN 
	BEGIN
	SIGNAL (((INS$_FAIL AND NOT STS$M_SEVERITY) OR STS$K_WARNING),
			2, LIST_DSC,INS$GQ_KFERNS,INS$_NOKFEFND);
	END
    ELSE
	BEGIN
	STATUS = INS$LIST (.INS$GL_KFEADR);
	IF NOT .STATUS 
	THEN 
	    SIGNAL (((INS$_FAILED AND NOT STS$M_SEVERITY) OR STS$K_WARNING),
				1, LIST_DSC, .STATUS);

	IF .INS$GL_CTLMSK [INS$V_GLOBAL]
	THEN
	    BEGIN
	    STATUS = INS$GLOBAL (.INS$GL_KFEADR);
	    IF NOT .STATUS 
	    THEN 
		SIGNAL (((INS$_FAILED AND NOT STS$M_SEVERITY)
				OR STS$K_WARNING), 1, GLOBAL_DSC, .STATUS);
	    END;
	END;

    INS$CLOSE_FILE ();
    END;

RETURN TRUE;
END;					! routine INS$LIST_VERB


%SBTTL	'INS$EXECUTE_IN_EXEC_WITH_R_LOCK';
GLOBAL ROUTINE INS$EXECUTE_IN_EXEC_WITH_R_LOCK (ROUTINE_NAM, PARAM) =
!+++
!
!   Execute the routine in exec mode
!
!---
BEGIN
LOCAL
    CME_ARGS : VECTOR [3, LONG],
    STATUS;

CME_ARGS [0] = 2;
CME_ARGS [1] = .ROUTINE_NAM;
CME_ARGS [2] = .PARAM;

STATUS = $CMEXEC (ROUTIN = EXECUTE_WITH_R_LOCK, ARGLST = CME_ARGS);

RETURN .STATUS;
END;		! Routine INS$EXECUTE_IN_EXEC_WITH_R_LOCK


%SBTTL	'INS$EXECUTE_IN_KRNL_WITH_W_LOCK';
GLOBAL ROUTINE INS$EXECUTE_IN_KRNL_WITH_W_LOCK (ROUTINE_NAM, PARAM) =
!+++
!
!   Execute the routine in kernel mode
!
!---
BEGIN
LOCAL
    CMK_ARGS : VECTOR [3, LONG],
    STATUS;

CMK_ARGS [0] = 2;
CMK_ARGS [1] = .ROUTINE_NAM;
CMK_ARGS [2] = .PARAM;

STATUS = $CMKRNL (ROUTIN = EXECUTE_WITH_W_LOCK, ARGLST = CMK_ARGS);

RETURN .STATUS;
END;		! Routine INS$EXECUTE_IN_KRNL_WITH_W_LOCK


%SBTTL	'execute_with_r_lock';
ROUTINE EXECUTE_WITH_R_LOCK (ROUTINE_NAM, PARAM) =
!+++
!
!   Execute the routine under the protection of a Known file list READ lock.
!
!---
BEGIN
LOCAL
    STATUS;

STATUS = $ENQW (
	EFN 	= EXE$C_SYSEFN,
	LKMODE 	= LCK$K_PRMODE,
	LKSB	= INS$G_KF_LKSB,
	FLAGS	= LCK$M_SYSTEM,
	RESNAM	= EXE$GQ_KFE_LCKNAM,
	PARID	= .EXE$GL_SYSID_LOCK,
	ACMODE	= PSL$C_EXEC
		);

IF .STATUS THEN STATUS = .INS$G_KF_LKSB [LK$W_STATUS];
IF NOT .STATUS THEN RETURN .STATUS;

STATUS = (.ROUTINE_NAM) (.PARAM);

$DEQ (LKID = .INS$G_KF_LKSB [LK$L_LOCKID]);

RETURN .STATUS;
END;		! Routine EXECUTE_WITH_R_LOCK


%SBTTL	'execute_with_w_lock';
ROUTINE EXECUTE_WITH_W_LOCK (ROUTINE_NAM, PARAM) =
!+++
!
!   Execute the routine under the protection of a Known file list READ lock,
!   and an Install WRITE lock.  During the execution of the routine, the
!   known file list lock must be converted to exclusive write.
!
!---
BEGIN
LOCAL
    STATUS;

!
!   Take out INSTALL lock.  This Entitles holder to convert the KFE Read lock
!   to a Write lock later.
!
STATUS = $ENQW (
	EFN 	= EXE$C_SYSEFN,
	LKMODE 	= LCK$K_PRMODE,
	LKSB	= INS$G_INS_LKSB,
	FLAGS	= LCK$M_SYSTEM,
	RESNAM	= INS$Q_LCKNAM,
	PARID	= .EXE$GL_SYSID_LOCK,
	ACMODE	= PSL$C_EXEC
		);

IF .STATUS THEN STATUS = .INS$G_INS_LKSB [LK$W_STATUS];
IF NOT .STATUS THEN RETURN .STATUS;

!
!   Take out KFE Read lock under protection of INSTALL lock.
!   This permits option to later convert lock to a Write lock.
!
STATUS = $ENQW (
	EFN 	= EXE$C_SYSEFN,
	LKMODE 	= LCK$K_PRMODE,
	LKSB	= INS$G_KF_LKSB,
	FLAGS	= LCK$M_SYSTEM,
	RESNAM	= EXE$GQ_KFE_LCKNAM,
	PARID	= .EXE$GL_SYSID_LOCK,
	ACMODE	= PSL$C_EXEC
		);

IF .STATUS THEN STATUS = .INS$G_KF_LKSB [LK$W_STATUS];
IF NOT .STATUS THEN RETURN .STATUS;

STATUS = (.ROUTINE_NAM) (.PARAM);

$DEQ (LKID = .INS$G_KF_LKSB [LK$L_LOCKID]);
$DEQ (LKID = .INS$G_INS_LKSB [LK$L_LOCKID]);

RETURN .STATUS;
END;		! Routine EXECUTE_WITH_W_LOCK


%SBTTL	'INS$CNVRT_KF_LOCK';
GLOBAL ROUTINE INS$CNVRT_KF_LOCK (MODE) =
!+++
!
!   Convert the currently held KF lock to a different mode.
!
!---
BEGIN
LOCAL
    STATUS;

!
!   
!
STATUS = $ENQW (
	EFN 	= EXE$C_SYSEFN,
	LKMODE 	= .MODE,
	LKSB	= INS$G_KF_LKSB,
	FLAGS	= LCK$M_CONVERT,
	RESNAM	= EXE$GQ_KFE_LCKNAM,
	PARID	= .EXE$GL_SYSID_LOCK,
	ACMODE	= PSL$C_EXEC
		);

IF .STATUS THEN STATUS = .INS$G_KF_LKSB [LK$W_STATUS];

RETURN .STATUS;

END;		! Routine INS$CNVRT_KF_LOCK


%SBTTL	'INS$CVT_DIR';
GLOBAL ROUTINE INS$CVT_DIR (DESC) : NOVALUE =
BEGIN
!++
! FUNCTIONAL DESCRIPTION:
!
!	Convert square brackets in file spec string to angle brackets. Also, eliminate
!	middle brackets if they exist because the directory was rooted.
!--
MAP
    DESC : REF $BBLOCK;

LOCAL
    PTR,
    PTR2;
!
! Convert "[" and "]" to "<" and ">" 
!
PTR = CH$FIND_CH(.DESC[DSC$W_LENGTH],.DESC[DSC$A_POINTER],'[');
IF NOT CH$FAIL(.PTR)
THEN
    BEGIN
    CH$WCHAR('<',.PTR);
    PTR = CH$FIND_CH(.DESC[DSC$W_LENGTH]-(.PTR-.DESC[DSC$A_POINTER]),.PTR,'[');
    IF NOT CH$FAIL(.PTR)
    THEN
	CH$WCHAR('<',.PTR);
    END;

PTR = CH$FIND_CH(.DESC[DSC$W_LENGTH],.DESC[DSC$A_POINTER],']');
IF NOT CH$FAIL(.PTR)
THEN
    BEGIN
    CH$WCHAR('>',.PTR);
    PTR = CH$FIND_CH(.DESC[DSC$W_LENGTH]-(.PTR-.DESC[DSC$A_POINTER]),.PTR,']');
    IF NOT CH$FAIL(.PTR)
    THEN
	CH$WCHAR('>',.PTR);
    END;

!
! If the device was rooted, there should be a middle set of brackets in
! the string. Compress them out of the string.
!

PTR = CH$FIND_CH(.DESC[DSC$W_LENGTH],.DESC[DSC$A_POINTER],'>');
IF NOT CH$FAIL(.PTR)
THEN
    BEGIN
    PTR2 = CH$FIND_CH(.DESC[DSC$W_LENGTH]-(.PTR+1-.DESC[DSC$A_POINTER]),.PTR+1,'<');
    IF NOT CH$FAIL(.PTR2)
    THEN
	BEGIN
	CH$MOVE(.DESC[DSC$W_LENGTH]-(.PTR2+1-.DESC[DSC$A_POINTER]),.PTR2+1,.PTR);
	DESC[DSC$W_LENGTH] = .DESC[DSC$W_LENGTH]-(.PTR2-.PTR+1);
	END;
    END;

RETURN;
END;

%SBTTL	'INS$OPEN_FILE';
GLOBAL ROUTINE INS$OPEN_FILE =
BEGIN

OWN
    INS$L_KFEESS : LONG,		! buffer for expanded name string
    INS$L_KFERSS : LONG;		! buffer for resultant name string

LOCAL
    VERSION_LENGTH,			! holds length of version string in RNS
    DEVNAM : BBLOCK [65],		! scratch device name buffer
    DEV_DSC : $BBLOCK [DSC$C_S_BLN],	! device name descriptor
    ITMLST : VECTOR [4,LONG]
	PRESET ( [0] = DVI$_LOGVOLNAM ^ 16 + 64,
		 [3] = 0),
    DESC : $BBLOCK [DSC$C_S_BLN],	! buffer for result name string desc.
    OPEN_STATUS,
    PTR,
    STATUS;

!
! Allocate RSS and ESS if not done so yet.
!
IF .INS$L_KFEESS EQL 0
THEN BEGIN
    STATUS = LIB$GET_VM(%REF(NAM$C_MAXRSS),INS$L_KFEESS);
    IF NOT .STATUS
	THEN (SIGNAL(.STATUS); RETURN .STATUS);
    END;
IF .INS$L_KFERSS EQL 0
THEN BEGIN
    STATUS = LIB$GET_VM(%REF(NAM$C_MAXRSS),INS$L_KFERSS);
    IF NOT .STATUS
	THEN (SIGNAL(.STATUS); RETURN .STATUS);
    END;
!+++
!
!   Prepare to OPEN the file
!
!---

$FAB_INIT (
	FAB = INS$G_KFEFAB,
	NAM = INS$G_KFENAM,
	SHR = <GET,PUT,UPI>,
	DNM = 'SYS$SYSTEM:.EXE',
	FNA = .INS$GQ_FILDSC [DSC$A_POINTER],
	FNS = .INS$GQ_FILDSC [DSC$W_LENGTH],
	FOP = <UFO, KFO>,
	RTV = -1
	);
INS$G_KFEFAB [FAB$L_CTX] = 0;	! Zero CTX longword in the FAB to 
				! determine if KFE address is returned by OPEN

$NAM_INIT (
	NAM = INS$G_KFENAM,
	ESA = .INS$L_KFEESS,
	ESS = NAM$C_MAXRSS,
	RSA = .INS$L_KFERSS,
	RSS = NAM$C_MAXRSS,
	NOP = <NOCONCEAL>
	);

IF .INS$GL_CTLMSK [INS$V_WRITABLE] 
    THEN INS$G_KFEFAB [FAB$B_FAC] = FAB$M_PUT;

!+++
!
!   Open the file
!
!---

OPEN_STATUS = $OPEN (FAB = INS$G_KFEFAB);
!
!   Disallow the installation of sequentially loaded files
!   such as network and magtape.
!
IF .OPEN_STATUS
THEN
    BEGIN
    BIND
	DEV = INS$G_KFEFAB [FAB$L_DEV] : $BBLOCK;

    IF .DEV [DEV$V_NET] OR .DEV [DEV$V_SQD] 
    THEN
	OPEN_STATUS = INS$_NOLOAD;
    END;

IF NOT .OPEN_STATUS	! open error
THEN
    BEGIN
    INS$G_KFEFAB[FAB$L_CTX] = INS$_OPENIN;
    IF .COMMAND_MODE EQL OLD
    THEN
	IF (STR$COMPARE (HEL_DSC, INS$GQ_FILDSC) EQL 0) OR
	   (STR$COMPARE (HELP_DSC, INS$GQ_FILDSC) EQL 0)
	THEN
	    BEGIN
	    SIGNAL (INS$_HELP);
	    END;
    END
ELSE
    INS$GL_KFECHAN = .INS$G_KFEFAB [FAB$L_STV];	! save the channel

!+++
!
!   Save the resultant name string. Extract the device name and convert
!   it into the volume logical name.
!
!---

CH$MOVE(DSC$C_S_BLN,UTIL$GETFILENAME(INS$G_KFEFAB),DESC);
IF .OPEN_STATUS
THEN
    VERSION_LENGTH = .DESC[DSC$W_LENGTH] - (
        .INS$G_KFENAM [NAM$B_DEV] +
        .INS$G_KFENAM [NAM$B_DIR] +
        .INS$G_KFENAM [NAM$B_NAME] +
        .INS$G_KFENAM [NAM$B_TYPE])
ELSE
    VERSION_LENGTH = 0;
!
! Extract device name from RNS
!
PTR = CH$FIND_CH(.DESC[DSC$W_LENGTH],.DESC[DSC$A_POINTER],':');
IF NOT CH$FAIL(.PTR)
THEN
    BEGIN
    DEV_DSC[DSC$A_POINTER] = DEVNAM;			! Setup devnam descriptor
    CH$WCHAR(%C'_',.DEV_DSC[DSC$A_POINTER]);		! Indicate device to GETDVI
    CH$MOVE(.PTR-.DESC[DSC$A_POINTER],.DESC[DSC$A_POINTER],
		.DEV_DSC[DSC$A_POINTER] + 1);		! Move in device name
    DEV_DSC[DSC$W_LENGTH] = .PTR - .DESC[DSC$A_POINTER] + 1; ! Count underscore

    ITMLST [1] = .INS$GQ_KFERNS[DSC$A_POINTER];		! Volume name buffer
    ITMLST [2] = INS$GQ_KFERNS[DSC$W_LENGTH];		! Place for string length
    SYS$GETDVIW(0,0,DEV_DSC,ITMLST,0,0,0,0);		! Get volume name string

    !
    ! Move remainder of RNS (except version string) behind volume name
    !
    PTR = CH$MOVE(.DESC[DSC$W_LENGTH]-(.PTR-.DESC[DSC$A_POINTER]),
		.PTR,.INS$GQ_KFERNS[DSC$A_POINTER]+
		.INS$GQ_KFERNS[DSC$W_LENGTH]);
    INS$GQ_KFERNS[DSC$W_LENGTH] = .PTR - .INS$GQ_KFERNS[DSC$A_POINTER] -
		.VERSION_LENGTH;
    END
!
! Use RNS string less version length
!
ELSE
    BEGIN
    CH$MOVE(.DESC[DSC$W_LENGTH],.DESC[DSC$A_POINTER],
		.INS$GQ_KFERNS[DSC$A_POINTER]);
    INS$GQ_KFERNS [DSC$W_LENGTH] = .DESC[DSC$W_LENGTH] - .VERSION_LENGTH;
    END;

!
! Convert brackets
!
INS$CVT_DIR(INS$GQ_KFERNS);

!
! If open had not succeeded, report the error and return open status.
!
IF NOT .OPEN_STATUS
THEN
    BEGIN
    IF .INS$G_KFEFAB [FAB$L_STS] NEQ RMS$_EOF
    THEN
	SIGNAL (.INS$G_KFEFAB [FAB$L_CTX], 1, INS$GQ_KFERNS,
		.INS$G_KFEFAB [FAB$L_STS], .INS$G_KFEFAB [FAB$L_STV]);

    INS$GL_KFEADR = 0;			! No KFE to point to in this case
    RETURN .OPEN_STATUS;
    END;
!
!	Store the KFE address returned by RMS OPEN.
!	After a replace or create operation, those routines will deposit the
!	new KFE address in ins$gl_kfeadr in case /LIST was requested
!
INS$GL_KFEADR = .INS$G_KFEFAB [FAB$L_CTX];

RETURN TRUE;
END;		! routine INS$OPEN_FILE


%SBTTL	'INS$CLOSE_FILE';
GLOBAL ROUTINE INS$CLOSE_FILE =
BEGIN
!
!	Be sure to clean up any opened file by deassigning the channel
!
IF .INS$GL_KFECHAN NEQ 0
THEN
    BEGIN
    REPORT ($DASSGN ( CHAN = .INS$GL_KFECHAN ));
    INS$GL_KFECHAN = 0;
    END;

RETURN TRUE;
END;		! Routine INS$CLOSE_FILE


%SBTTL  'INS$CHECK_PRIV';

GLOBAL ROUTINE INS$CHECK_PRIV =
!+++
!
!  FUNCTIONAL DESCRIPTION:
!	Check that user has CMKRNL privilege.
!
!  INPUT:
!	None
!
!  OUTPUT:
!	None
!
!  ROUTINE VALUE:
!	ss$_nocmkrnl	If user does not have CMKRNL privilege
!	low bit set	If user has CMKRNL privilege
!---
BEGIN
IF NOT .CTL$GQ_PROCPRIV [PRV$V_CMKRNL]
THEN
    RETURN SS$_NOCMKRNL
ELSE
    RETURN TRUE;
END;		! routine INS$CHECK_PRIV


%SBTTL  'INS_HANDLER';

ROUTINE INS_HANDLER (SIGARGS, MECHARGS) =
BEGIN
!
!	This routine is a condition handler called when ever a
!	SIGNAL is done by INSTALL.  It merely remembers the
!	most severe error for an exit status.
!
MAP
    SIGARGS : REF $BBLOCK,
    MECHARGS : REF $BBLOCK;

BIND
    SIGNAME = SIGARGS [CHF$L_SIG_NAME] : $BBLOCK;	!Name of signal

IF NOT .SIGNAME	AND					!If its an error signal
    ((.SIGNAME [STS$V_SEVERITY]	GEQU			! and severity is worse than it was
	.INS$EXIT_STATUS [STS$V_SEVERITY]) OR
	.INS$EXIT_STATUS [STS$V_SEVERITY])		! or we haven't had any errors
THEN 
    INS$EXIT_STATUS  = .SIGNAME;			! then remember it for exiting

RETURN SS$_RESIGNAL
END;					!Of ins_handler

END					! Module INSMAIN
ELUDOM
