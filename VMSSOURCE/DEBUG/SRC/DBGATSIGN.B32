MODULE DBGATSIGN (IDENT = 'V04-000') =

BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!
!
! MODULE FUNCTION
!
!	This module contains the parse and execution networks to support the 
!	commands having to do with command files (@, DECLARE, EXIT, EXITLOOP).
!	SPAWN and ATTACH are also in this module (for lack of a better
!	place to put them).	
!
! AUTHOR:	David Plummer, CREATION DATE: 3/28/80
!
! MODIFIED BY:
!
!	R. Title	- Added SPAWN, ATTACH, DECLARE, EXITLOOP, and merged
!			  all of this into this one module.
!

REQUIRE 'SRC$:DBGPROLOG.REQ';

LIBRARY 'LIB$:DBGGEN.L32';

FORWARD ROUTINE
    DBG$NPARSE_AT_SIGN,			! Parse indirect command file invocation
    DBG$NEXECUTE_AT_SIGN,		! Execute indirect command file invocation
    DBG$NPARSE_ATTACH,			! ATTACH command parse network
    DBG$NEXECUTE_ATTACH,		! ATTACH command execute network
    DBG$NPARSE_SPAWN,			! SPAWN command parse network
    DBG$NEXECUTE_SPAWN,			! SPAWN command execution network
    DBG$CONSTRUCT_PARAM_NAME,		! Builds name of form %Pi
    DBG$PARSE_SPAWN,			! Interface from old languages
    GET_PARAM,				! Parses a parameter
    DBG$NEXECUTE_EXIT,			! Execution network for EXIT command
    DBG$NEXECUTE_EXITLOOP,		! Execution network for EXITLOOP
    DBG$NPARSE_EXIT,			! ATN parse network for EXIT command
    DBG$NPARSE_EXITLOOP,		! ATN parse network for EXITLOOP
    DBG$NPARSE_DECLARE,			! DECLARE parse network
    DBG$NEXECUTE_DECLARE;		! DECLARE execution network

EXTERNAL ROUTINE
    DBG$DEF_PR_ENTRY,			! Procedure entry routine for @ procedures
    DBG$DEF_SYM_ADD,			! Adds a DEFINE symbol
    DBG$DEF_SYM_FIND,			! Locate a DEFINE symbol
    DBG$GET_MEMORY,			! Allocates permanent memory
    DBG$GET_TEMPMEM,			! Allocates and lists dynamic storage
    DBG$NCIS_ADD,			! Routine to add a node to the cis
    DBG$NCIS_OPENICF,			! Routine to connect an icf
    DBG$NCIS_REMOVE,			! Removes links from the command input stream
    DBG$NCOPY_DESC,			! Copy a descriptor
    DBG$NEWLINE: NOVALUE,		! Output routine
    DBG$NGET_SYMID,			! Obtain symid list
    DBG$NMAKE_ARG_VECT,			! Construct error message vector
    DBG$NMATCH,				! Match the next token
    DBG$NNEXT_WORD,			! Read next work of input
    DBG$NPARSE_ADDRESS,			! Parse an address expression
    DBG$NPARSE_EXPRESSION,		! Parse a language expression
    DBG$NREAD_NAME,			! Accept a DEFINE name
    DBG$NSAVE_BREAK_BUFFER,		! Parse a DEBUG command sequence
    DBG$NSAVE_DECIMAL_INTEGER,		! Parse an integer
    DBG$NSAVE_FILESP,			! Saves a file specification string
    DBG$NSAVE_STRING,			! Pick up string
    DBG$NSYNTAX_ERROR,			! Construct a syntax error message
    DBG$PRINT: NOVALUE,			! Output routine
    DBG$SCR_SCREEN_NORMAL: NOVALUE,	! Set screen to normal in screen mode
    DBG$STA_LOCK_SYMID: NOVALUE,	! Lock symid list
    LIB$ATTACH,				! Do the actual ATTACH to a process
    LIB$FREE_EF,			! Free up and event-flag
    LIB$GET_EF,				! Allocate an event-flag
    LIB$SPAWN,				! Do the actual SPAWN of a subprocess
    SMG$SET_KEYPAD_MODE;		! Set terminal to numeric/application mode

EXTERNAL
    DBG$GB_KEYPAD_INPUT: BYTE,		! Set if mode is KEYPAD
    DBG$GL_KEYBOARD_ID,			! Used by SMG$SET_KEYPAD_MODE
    DBG$GB_LANGUAGE: BYTE,		! The current language setting
    DBG$GB_RADIX    : VECTOR [3, BYTE],	! Radix settings
    DBG$GB_DEF_OUT  : VECTOR [,BYTE],	!    "    " output configuration structure
    DBG$GL_LOGFAB   : BLOCK [,BYTE],	!    "    " FAB for log file
    DBG$GL_CISHEAD  : REF CIS$LINK,	!    "    " head of command input stream
    DBG$GL_EXIT_STATUS,			! Last known user error status
    DBG$GV_CONTROL: DBG$CONTROL_FLAGS,	! DEBUG control bits
    DBG$GL_SMG_EXIT_HANDLER;		! Address of exit handler for SMG routines

LITERAL
    NOWAIT_FLAG = 0;			! Flag position for /NOWAIT

GLOBAL LITERAL
    DBG$K_MAX_PR_NESTING = 10;

GLOBAL
    DBG$GL_PR_NEST_LEVEL: INITIAL(0),	! Level of nesting of @ procedures
    DBG$GL_PARAM_COUNT:			! Parameter count for each procedure
    		VECTOR[1+DBG$K_MAX_PR_NESTING]
    		INITIAL(REP 1+DBG$K_MAX_PR_NESTING OF (0));


! The following macro is just an abbreviation for some error-reporting
! code that occurs repeatedly
!
MACRO report_error =
    BEGIN
    .message_vect = (
    	IF dbg$nmatch (.input_desc, dbg$cs_cr, 1)
    	THEN
    	    dbg$nmake_arg_vect (dbg$_needmore)
    	ELSE
    	    dbg$nsyntax_error (dbg$nnext_word (.input_desc)));
    RETURN sts$k_severe;
    END %;

GLOBAL ROUTINE DBG$NPARSE_AT_SIGN (INPUT_DESC, VERB_NODE, MESSAGE_VECT) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	Parses an @ filespec command. The @ has already been recognized in the routine
!	dbg$nparse_cmd network. This routine merely aquires the filespec string
!	and causes the noun node ( noun value ) field to point to the filespec which
!	is stored as a counted string in dynamically allocated storage.
!
!
! FORMAL PARAMETERS:
!
!	input_desc -			The present command line input descriptor
!
!	verb_node  -			The already existing command verb node
!
!	message_vect -			The address of a longword to contain the
!					address of a message argument vector
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	On success, the appropriate command execution tree is constructed.
!
!	On failure, a message argument vector is constructed
!
! ROUTINE VALUE:
!
!	An unsigned integer longword completion code
!
! COMPLETION CODES:
!
!	sts$k_severe (4) -		Error in parsing
!
!	sts$k_success (1) -		Successful parse
!
! SIDE EFFECTS:
!
!	None
!
!--

    BEGIN

    MAP
    	INPUT_DESC: REF dbg$stg_desc,
	VERB_NODE : REF dbg$verb_node;

    BIND
    	dbg$cs_comma		= UPLIT BYTE (1, dbg$k_comma),
    	dbg$cs_cr		= UPLIT BYTE (1, dbg$k_car_return),
    	dbg$cs_left_paren	= UPLIT BYTE (1, dbg$k_left_parenthesis),
    	dbg$cs_right_paren	= UPLIT BYTE (1, dbg$k_right_parenthesis);

    LOCAL
    	first_flag: BYTE,		! True first time around loop that
    					!    collect the parameters.
    	link,				! Used for building linked lists
	noun_node: REF dbg$noun_node,	! A noun node
    	paren_flag: BYTE;		! True if there is a parenthesized
    					!    parameter list.
    
    ! Create and link a noun node
    !
    noun_node = dbg$get_tempmem (dbg$k_noun_node_size);
    verb_node [dbg$l_verb_object_ptr] = .noun_node;

    ! Get the filespec
    !
    IF NOT dbg$nsave_filesp (.input_desc, noun_node [dbg$l_noun_value], .message_vect)
    THEN
	RETURN sts$k_severe;

    ! Check for end-of-line. In this case, there are no parameters so just
    ! return success.
    !
    IF dbg$nmatch (.input_desc, dbg$cs_cr, 1)	
    OR .input_desc [dsc$w_length] EQL 0
    THEN
    	RETURN sts$k_success;

    ! Now pick up the parameter list, if one is present.
    !
    IF dbg$nmatch (.input_desc, dbg$cs_left_paren, 1)
    THEN
    	paren_flag = TRUE
    ELSE
    	paren_flag = FALSE;

    ! Set a flag which is true only the first time around the loop.
    !
    first_flag = TRUE;

    ! Loop through the list of parameters.
    !
    WHILE TRUE DO
    	BEGIN
    	
    	! Allocate space for a new noun node.	
    	!
    	link = noun_node [dbg$l_noun_link];
    	noun_node = dbg$get_tempmem (dbg$k_noun_node_size);

    	! Attempt to read a parameter. 
    	!
    	IF NOT get_param (.input_desc, .paren_flag, 
    		noun_node [dbg$l_noun_value])
    	THEN
    	    BEGIN

    	    ! The only way this can legally fail is @FOO () 
    	    ! (no parameters). Check for this.
    	    !
    	    IF .first_flag
    	    THEN

    		! If there had been an opening paren, then make sure we
    		! collect the closing paren
    		!
    	        IF .paren_flag
    	        THEN
    		    IF NOT dbg$nmatch (.input_desc, dbg$cs_right_paren, 1)
    		    THEN
    		        BEGIN
    		        .message_vect = dbg$nmake_arg_vect (dbg$_unmtchparn);
    		        RETURN sts$k_severe;
    		        END
    		    ELSE
    		        EXITLOOP;

    	    ! If we get here, we have read a separating comma, but we have
    	    ! failed to read the next parameter (E.G., @FOO A,)
    	    ! This is therefore an error.
    	    !
    	    .message_vect = 
    		    (IF dbg$nmatch (.input_desc, dbg$cs_cr, 1)
    		     THEN
    			 dbg$nmake_arg_vect (dbg$_needmore)
    		     ELSE
    			 dbg$nsyntax_error (dbg$nnext_word (.input_desc)));
    	    RETURN sts$k_severe;
    	    END;

    	! Set first_flag to FALSE for next time around.
    	!
    	first_flag = FALSE;

    	! We must have succeeded in reading a parameter. Thus, link in
    	! the noun node.
    	!
    	.link = .noun_node;

    	! Attempt to read a comma, which separates parameters.
    	!
    	IF NOT dbg$nmatch (.input_desc, dbg$cs_comma, 1)
    	THEN

    	    ! If we fail, check for the closing paren, if an opening
    	    ! paren was present.	
    	    !
    	    IF .paren_flag
    	    THEN
    		IF NOT dbg$nmatch (.input_desc, dbg$cs_right_paren, 1)
    		THEN
    		    BEGIN
    		    .message_vect = dbg$nmake_arg_vect (dbg$_unmtchparn);
    		    RETURN sts$k_severe;
    		    END
    		ELSE
    		    EXITLOOP

    	    ! The lack of a separating comma indicates the end of the
    	    ! parameter list, so we just exit the loop.
    	    !
    	    ELSE 
    		EXITLOOP;
    	
    	END; ! of WHILE loop

    ! The command execution tree, containing a noun node with the filespec
    ! and a noun node for each parameter, has been constructed. Thus, we
    ! just return success.
    !
    RETURN sts$k_success;
	
    END;			! End of dbg$nparse_at_sign


GLOBAL ROUTINE DBG$NEXECUTE_AT_SIGN (VERB_NODE, MESSAGE_VECT) =
!
! FUNCTION
!	This routine begins execution of an @ filespec command.  That is, a FAB
!	and a RAB are allocated for the indirect command file, and calls are
!	made to add the file to the command input string and connect the file.
!
! INPUTS
!	VERB_NODE - The command verb node which is the start of the command
!		  execution tree.
!
!	MESSAGE_VECT - The address of a longword to contain the address of
!		  a message argument vector.  On failure of this routine,
!		  a message argument vector is returned to this parameter.
!
! OUTPUTS
!	An unsigned integer longword completion code is returned as the routine
!	value:
!
!	    STS$K_SUCCESS (1) -	Indicates the file was created and connected
!
!	    STS$K_SEVERE (4) -	Failure, file not created. Message argument vector returned
!

    BEGIN

    BIND
	DEFICF_NAME 	= UPLIT BYTE ('DEBUG.COM'),
	DEFICF_SIZE 	= %CHARCOUNT ('DEBUG.COM');

    MAP
	VERB_NODE: REF DBG$VERB_NODE;	! Pointer to input Verb Node

    LOCAL
	FAB_PTR: REF $FAB_DECL,		! Pointer to ICF FAB
	NOUN_NODE: REF DBG$NOUN_NODE,	! Pointer to command Noun Node
    	PARAM_COUNT,			! Count of number of parameters
    	PARAM_NAME: REF VECTOR[,BYTE],	! Pointer to ASCIC name of parameter
	RAB_PTR: REF $RAB_DECL,		! Pointer to ICF RAB
	REPLACED_FLAG,			! Returned symbol-replaced flag from
					!      DBG$DEF_SYM_ADD (value not used)
	VALARRAY: REF VECTOR[,LONG],	! Pointer to value field in the Value
					!      Descriptor for %PARCNT
	VALPTR: REF DBG$VALDESC;	! Pointer to Value Descriptor we build



    ! Obtain the Noun Node for the file name of the indirect command file.
    !
    NOUN_NODE = .VERB_NODE[DBG$L_VERB_OBJECT_PTR];


    ! Allocate a FAB and a RAB for the command file and initialize them.
    !
    FAB_PTR = DBG$GET_MEMORY ((FAB$C_BLN + 3) / %UPVAL);
    RAB_PTR = DBG$GET_MEMORY ((RAB$C_BLN + 3) / %UPVAL);
    $FAB_INIT (FAB=.FAB_PTR, FAC=GET, FNA=.NOUN_NODE[DBG$L_NOUN_VALUE] + 1,
	       FNS=.(.NOUN_NODE [DBG$L_NOUN_VALUE]) <0, 8, 0>,
               DNA=DEFICF_NAME, DNS=DEFICF_SIZE);
    $RAB_INIT (RAB=.RAB_PTR, FAB=.FAB_PTR);


    ! Place the ICF on the command input stream.
    !
    IF NOT DBG$NCIS_ADD(.RAB_PTR, 0, CIS_RAB, 0, 0, 0, .MESSAGE_VECT)
    THEN
	RETURN STS$K_SEVERE;


    ! Set up the local define list for the procedure.
    !
    IF NOT DBG$DEF_PR_ENTRY(.MESSAGE_VECT)
    THEN
    	RETURN STS$K_SEVERE;


    ! Add the parameters to the local define list.  To do this, we loop through
    ! the remaining Noun Nodes to get the parameter pointers.
    !
    PARAM_COUNT = 0;
    NOUN_NODE = .NOUN_NODE[DBG$L_NOUN_LINK];
    WHILE .NOUN_NODE NEQ 0 DO
    	BEGIN
    

	! Increment the parameter count to give the parameter number of the
	! present parameter.  Then obtain the name for this parameter and add
	! the parameter to the parameter list for the current command file.
	!
    	PARAM_COUNT = .PARAM_COUNT + 1;
    	IF NOT DBG$CONSTRUCT_PARAM_NAME(.PARAM_COUNT, PARAM_NAME, TRUE, 
			    					 .MESSAGE_VECT)
    	THEN
    	    RETURN STS$K_SEVERE;
    
    	IF NOT DBG$DEF_SYM_ADD(.PARAM_NAME, DEFINE_PARAMETER,
    		.NOUN_NODE[DBG$L_NOUN_VALUE], FALSE,
		REPLACED_FLAG, .MESSAGE_VECT)
    	THEN
    	    RETURN STS$K_SEVERE;

    	IF .REPLACED_FLAG THEN $DBG_ERROR('DBGATSIGN\DBG$NEXECUTE_AT_SIGN');


    	! Get the Noun Node for the next parameter and loop.
    	!
    	NOUN_NODE = .NOUN_NODE[DBG$L_NOUN_LINK];
    	END;


    ! Build a Value Descriptor to hold the integer value that gives the number
    ! of parameters to the indirect command file we are opening.  Then create
    ! a local DEFINEd symbol called %PARCNT in the scope of this indirect com-
    ! mand file.  This symbol gives the number of parameters to the indirect
    ! command file when referenced by the user within the command file.
    !
    VALPTR = DBG$GET_MEMORY(DBG$K_VALDESC_BASE_SIZE + 4);
    VALPTR[DBG$B_DHDR_TYPE] = DBG$K_VALUE_DESC;
    VALPTR[DBG$W_DHDR_LENGTH] = (DBG$K_VALDESC_BASE_SIZE + 4)*%UPVAL;
    VALPTR[DBG$B_DHDR_FCODE] = RST$K_TYPE_ATOMIC;
    VALPTR[DBG$B_DHDR_KIND] = RST$K_DATA;
    VALPTR[DBG$B_DHDR_LANG] = .DBG$GB_LANGUAGE;
    VALPTR[DBG$B_VALUE_CLASS] = DSC$K_CLASS_S;
    VALPTR[DBG$B_VALUE_DTYPE] = DSC$K_DTYPE_L;
    VALPTR[DBG$W_VALUE_LENGTH] = 4;
    VALPTR[DBG$L_VALUE_POINTER] = VALPTR[DBG$A_VALUE_ADDRESS];
    VALARRAY = VALPTR[DBG$A_VALUE_ADDRESS];
    VALARRAY[0] = .PARAM_COUNT;
    PARAM_NAME = DBG$GET_MEMORY(2);
    CH$MOVE(8, UPLIT BYTE(%ASCIC '%PARCNT'), PARAM_NAME[0]);
    IF NOT DBG$DEF_SYM_ADD(.PARAM_NAME, DEFINE_VALUE, .VALPTR,
					FALSE, REPLACED_FLAG, .MESSAGE_VECT)
    THEN
	RETURN STS$K_SEVERE;


    ! Open the specified indirect command file as the current input file.
    ! Then return.
    !
    IF NOT DBG$NCIS_OPENICF(.MESSAGE_VECT) THEN RETURN STS$K_SEVERE;
    RETURN STS$K_SUCCESS;

    END;

GLOBAL ROUTINE DBG$NPARSE_ATTACH (INPUT_DESC, VERB_NODE, MESSAGE_VECT) =
!
! FUNCTION
!	Parses the ATTACH command. The "ATTACH" has already been 
!	recognized by the top-level parse routine. This routine picks
!	up the integer argument and constructs a command execution tree.
!	The tree has the verb node for ATTACH, and a noun node with
!	the integer argument.
!
! INPUTS
!	INPUT_DESC 	- A string descriptor for the remaining command line
!
!	VERB_NODE	- The already existing verb node.
!
!	MESSAGE_VECT	- The address of a message argument vector.
!
! OUTPUTS
!	The return value is one of:
!		STS$K_SUCCESS	- Success. A command execution tree was
!				  constructed.
!		STS$K_SEVERE	- Failure. An error message vector is
!				  constructed.
!

    BEGIN

    MAP
    	INPUT_DESC: REF DBG$STG_DESC,
    	VERB_NODE: REF DBG$VERB_NODE;

    BIND
    	DBG$CS_CR 	= UPLIT BYTE (1, DBG$K_CAR_RETURN);



    ! Check for end-of-line. This is an error.
    !
    IF .INPUT_DESC [DSC$W_LENGTH] EQL 0
    THEN
    	BEGIN
    	.MESSAGE_VECT = DBG$NMAKE_ARG_VECT (DBG$_NEEDMORE);
    	RETURN STS$K_SEVERE;
    	END;

    IF DBG$NMATCH (.INPUT_DESC, DBG$CS_CR, 1)
    THEN
    	BEGIN
    	.MESSAGE_VECT = DBG$NMAKE_ARG_VECT (DBG$_NEEDMORE);
    	RETURN STS$K_SEVERE;
    	END;


    ! Pick up the string with the process name. Put a pointer to the
    ! string right in the verb node.
    !
    IF NOT DBG$NSAVE_STRING(.INPUT_DESC,
		VERB_NODE [DBG$L_VERB_ADVERB_PTR], .MESSAGE_VECT)
    THEN
    	RETURN STS$K_SEVERE;


    ! Return success.
    !
    RETURN STS$K_SUCCESS;
    END;	

GLOBAL ROUTINE DBG$NEXECUTE_ATTACH (VERB_NODE, MESSAGE_VECT) =
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine executes an ATTACH command. 
!
! FORMAL PARAMETERS:
!
!	verb_node -			The command verb node which is the start
!					of the command execution tree
!
!	message_vect -			The address of a longword to contain the
!					address of a message argument vector
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	On failure, a message argument vector is returned
!
! ROUTINE VALUE:	
!
!	An unsigned integer longword completion code
!
! COMPLETION CODES:
!
!	sts$k_success (1) -	Indicates the file was created and connected
!
!	sts$k_severe (4) -	Failure, file not created. Message argument vector returned
!
! SIDE EFFECTS:
!
!

    BEGIN

    MAP
	VERB_NODE: REF DBG$VERB_NODE;

    LOCAL
    	EVNT_FLAG,				! Event flag number
    	ITEM: BLOCK [3,LONG],			! Item list for $GETJPI
    	PID,					! Process id
    	PNAME: REF VECTOR[,BYTE],		! Pointer to counted string
    						!    with process name
    	STATUS,					! Return status from LIB$ATTACH
    	STG_DESC: BLOCK[8,BYTE],		! String descriptor with name
    	X;


    ! Obtain the process name of the process we are to attach to.
    !
    PID = 0;
    PNAME = .VERB_NODE [DBG$L_VERB_ADVERB_PTR];
    STG_DESC[DSC$B_CLASS] = DSC$K_CLASS_S;
    STG_DESC[DSC$B_DTYPE] = DSC$K_DTYPE_T;
    STG_DESC[DSC$W_LENGTH] = .PNAME[0];
    STG_DESC[DSC$A_POINTER] = PNAME[1];


    ! Obtain the process id of the process we are to attach to.
    !
    STATUS = LIB$GET_EF(EVNT_FLAG);
    IF NOT .STATUS THEN SIGNAL(.STATUS);
    CH$FILL(0, 12, ITEM);
    STATUS = $GETJPI(EFN=.EVNT_FLAG, PIDADR=PID, PRCNAM=STG_DESC, ITMLST=ITEM);
    IF NOT .STATUS
    THEN
	BEGIN
	LIB$FREE_EF(EVNT_FLAG);
	SIGNAL(DBG$_GETJPI, 0, .STATUS);
	END;

    $WAITFR(EFN = .EVNT_FLAG);
    LIB$FREE_EF(EVNT_FLAG);


    ! Reset the terminal screen to "normal" if we are in screen mode.  This
    ! makes sure that the whole terminal screen scrolls when we are in the
    ! other process and that the screen is refreshed when we reenter DEBUG.
    !
    DBG$SCR_SCREEN_NORMAL();


    ! Signal that we are about to do an attach.  Do the attach.  Signal an
    ! error if it fails.
    !
    SIGNAL(DBG$_ATTACHED, 1, .PNAME);
    STATUS = LIB$ATTACH(PID);
    IF NOT .STATUS THEN SIGNAL(DBG$_NOATTACH, 0, .STATUS);
    
    ! After returning from the attach, set the terminal back to
    ! the appropriate mode. Then return.
    !
    IF .DBG$GB_KEYPAD_INPUT THEN X = 1 ELSE X = 0;
    SMG$SET_KEYPAD_MODE (DBG$GL_KEYBOARD_ID, X);
    RETURN STS$K_SUCCESS;
    END;

GLOBAL ROUTINE DBG$NPARSE_SPAWN (INPUT_DESC, VERB_NODE, MESSAGE_VECT) =
!
! FUNCTION
!	Parses the spawn command. The "SPAWN" has already been recognized in the routine
!	dbg$nparse_cmd network. This routine merely aquires the argument string
!	and causes the noun node ( noun value ) field to point to the argument which
!	is stored as a counted string in dynamically allocated storage.
!
! FORMAL PARAMETERS:
!
!	INPUT_DESC - The present command line input descriptor.
!
!	VERB_NODE  - The already existing command Verb Node.
!
!	MESSAGE_VECT - The address of a longword to contain the address of a
!		  message argument vector.
!
!
! ROUTINE VALUE:
!	An unsigned integer longword completion code:
!
!		STS$K_SEVERE (4) - Error in parsing
!
!		STS$K_SUCCESS (1) - Successful parse
!

    BEGIN

    MAP
    	INPUT_DESC: REF DBG$STG_DESC,
	VERB_NODE: REF DBG$VERB_NODE;

    BIND
	DBG$CS_NOWAIT		= UPLIT BYTE (6, 'NOWAIT'),
	DBG$CS_CR		= UPLIT BYTE (1, DBG$K_CAR_RETURN),
	DBG$CS_DBLQUOTE		= UPLIT BYTE (1, DBG$K_DBLQUOTE),
	DBG$CS_SLASH		= UPLIT BYTE (1, DBG$K_SLASH);

    LOCAL
    	CHAR: BYTE,			   ! Holds a single character
    	COUNT,				   ! Count of number of chars in arg
    	COUNTED_STRING: REF VECTOR[,BYTE], ! Points to a counted string
    					   !     holding the argument.
    	FLAGS: BITVECTOR[32],		   ! Flags for /NOWAIT etc
	NOUN_NODE: REF DBG$NOUN_NODE,	   ! A pointer to a noun node
    	OUTPUT_PTR,			   ! Pointer into counted string
    	PREV_CHAR: BYTE,		   ! Holds a single character
    	QUOTE_FLAG: BYTE;		   ! TRUE if argument is quoted



    ! Initialize flags.
    !
    FLAGS = 0;


    ! Collect qualifiers.
    !
    WHILE DBG$NMATCH (.INPUT_DESC, DBG$CS_SLASH, 1) DO
      	BEGIN
    	SELECTONE TRUE OF
    	    SET

    	    ! /NOWAIT
    	    !
     	    [DBG$NMATCH (.INPUT_DESC, DBG$CS_NOWAIT, 3)]:
    		FLAGS[NOWAIT_FLAG] = TRUE;
    		
    	    [DBG$NMATCH (.INPUT_DESC, DBG$CS_CR, 1)]:
    		SIGNAL(DBG$_NEEDMORE);

    	    [OTHERWISE]:
    		SIGNAL(DBG$_ILLQUALIF);

    	    TES;
    	END;


    ! Put the flags in the adverb field.
    !
    VERB_NODE[DBG$L_VERB_ADVERB_PTR] = .FLAGS;


    ! Check for end-of-line. If so, there was no argument to SPAWN.
    ! We do not allocate a noun node in this case. Just return success.
    !
    IF .INPUT_DESC [DSC$W_LENGTH] EQL 0 THEN RETURN STS$K_SUCCESS;
    IF DBG$NMATCH (.INPUT_DESC, DBG$CS_CR, 1) THEN RETURN STS$K_SUCCESS;


    ! Create and link a Noun Node.
    !
    NOUN_NODE = DBG$GET_TEMPMEM(DBG$K_NOUN_NODE_SIZE);
    VERB_NODE[DBG$L_VERB_OBJECT_PTR] = .NOUN_NODE;


    ! Check whether the user has enclosed the argument in quotes.
    !
    IF DBG$NMATCH(.INPUT_DESC, DBG$CS_DBLQUOTE, 1)
    THEN    
    	QUOTE_FLAG = TRUE

    ELSE
    	QUOTE_FLAG = FALSE;


    ! Allocate space to store the argument string.
    !
    COUNTED_STRING = DBG$GET_TEMPMEM(1 + (1 + .INPUT_DESC[DSC$W_LENGTH])/4);


    ! Initialize some variables.
    !
    CHAR = 0;
    COUNT = 0;
    OUTPUT_PTR = COUNTED_STRING[1];


    ! Loop through the input, copying characters into the counted string.
    !
    WHILE .INPUT_DESC[DSC$W_LENGTH] GTR 0 DO
    	BEGIN


    	! Get the next character.
    	!
    	PREV_CHAR = .CHAR;
    	CHAR = CH$RCHAR_A (INPUT_DESC [DSC$A_POINTER]);
    	INPUT_DESC [DSC$W_LENGTH] = .INPUT_DESC [DSC$W_LENGTH] - 1;


    	! Check for carriage return.
    	!
    	IF .CHAR EQL DBG$K_CAR_RETURN THEN EXITLOOP;


    	! If argument was quoted, check for either doubled quotes or
    	! closing quote.
    	!
    	IF .QUOTE_FLAG
    	THEN
	    BEGIN
    	    IF .CHAR EQL DBG$K_DBLQUOTE
    	    THEN
		BEGIN


		! Undouble double quotes if that is what we have.  Otherwise,
		! we exit the quoted-string loop on the clonsing quote.
		!
    		IF .PREV_CHAR NEQ DBG$K_DBLQUOTE THEN EXITLOOP;
		CHAR = CH$RCHAR_A(.INPUT_DESC [DSC$A_POINTER]);
		INPUT_DESC[DSC$W_LENGTH] = .INPUT_DESC[DSC$W_LENGTH] - 1;
		END;

	    END;


    	! Write the character to the output buffer and increment count
    	! of number of chars in output buffer.
    	!
    	CH$WCHAR_A(.CHAR, OUTPUT_PTR);
    	COUNT = .COUNT + 1;
    	END;


    ! Fill in the count field.
    !
    COUNTED_STRING [0] = .COUNT;
    	

    ! Fill in the Noun Node.
    !
    NOUN_NODE [DBG$L_NOUN_VALUE] = .COUNTED_STRING;


    ! Return success.
    !
    RETURN STS$K_SUCCESS;
    
    END;

GLOBAL ROUTINE DBG$NEXECUTE_SPAWN (VERB_NODE, MESSAGE_VECT) =
!
! FUNCTION
!	This routine executes a SPAWN command. 
!
! FORMAL PARAMETERS:
!
!	VERB_NODE - The command verb node which is the start of the command
!		  execution tree.
!
!	MESSAGE_VECT - The address of a longword to contain the address of
!		  a message argument vector.
!
! ROUTINE VALUE:	
!	An unsigned integer longword completion code:
!
!		STS$K_SUCCESS (1) - Indicates the file was created and connected
!
!		STS$K_SEVERE (4) - Failure, file not created. Message argument
!				   vector returned.
!

    BEGIN

    MAP
	VERB_NODE: REF DBG$VERB_NODE;

    LOCAL
    	COUNTED_STRING:			! Contains arg to SPAWN
		REF VECTOR[,BYTE],	!
	EVNT_FLAG,			! Event flag for $GETJPI call
    	FLAGS: BITVECTOR[32],		! Flags for /NOWAIT etc.
    	ITEM: BLOCK[6, LONG],		! Item list for GETJPI
    	LEN: WORD,			! Length of process name
    	NAME_BUFFER: VECTOR[32,BYTE],	! Process name
	NOUN_NODE: REF DBG$NOUN_NODE,	! Command object noun
    	STATUS,				! Return status from LIB$SPANW
    	STG_DESC: DBG$STG_DESC,		! A string descriptor
    	X;


    ! Reset the terminal screen to "normal" if we are in screen mode.  This
    ! makes sure that the whole terminal screen scrolls when we are in the
    ! other process and that the screen is refreshed when we reenter DEBUG.
    !
    DBG$SCR_SCREEN_NORMAL();


    ! Obtain the qualifier flags and the noun node.
    ! The flags will tell us whether /NOWAIT was specified (this
    ! is currently the only qualifier we support).
    ! The noun node tells whether a DCL command was given as argument,
    ! or whether we saw a bare SPAWN.
    !
    FLAGS = .VERB_NODE [DBG$L_VERB_ADVERB_PTR];
    NOUN_NODE = .VERB_NODE [DBG$L_VERB_OBJECT_PTR];


    ! Note - in both cases below we would like to put out the
    ! "SPAWNED - process XXX spawned; terminal now attached to ..."
    ! as DCL does. But LIB$SPAWN does not put out this message, and
    ! there appears to be no way we can put it out at this level
    ! (we don't know if LIB$SPAWN will succeed, and even if it does,
    ! we don't know the name of the spawned subprocess).
    !
    ! If no command string is given, just call LIB$SPAWN with flags argument.
    !
    IF .NOUN_NODE EQL 0
    THEN
    	STATUS = LIB$SPAWN(0,0,0,FLAGS,0,0)


    ! If a command string was given, we pass it into LIB$SPAWN along with the
    ! flags argument.
    !
    ELSE
    	BEGIN
	COUNTED_STRING = .NOUN_NODE[DBG$L_NOUN_VALUE];
	STG_DESC[DSC$B_CLASS] = DSC$K_CLASS_S;
	STG_DESC[DSC$B_DTYPE] = DSC$K_DTYPE_T;
	STG_DESC[DSC$W_LENGTH] = .COUNTED_STRING[0];
	STG_DESC[DSC$A_POINTER] = COUNTED_STRING[1];
	STATUS = LIB$SPAWN(STG_DESC,0,0,FLAGS,0,0);
    	END;
    

    ! If a bad status was returned then signal a DEBUG error and include
    ! the return status as the secondary error.
    !
    IF NOT .STATUS
    THEN
    	SIGNAL(DBG$_NOSPAWN, 0, .STATUS)

    ELSE
	BEGIN
    	IF .FLAGS[NOWAIT_FLAG]
    	THEN

    	    ! We can put out an informational message if a SPAWN/NOWAIT
    	    ! subprocess was created.
    	    !
    	    SIGNAL(DBG$_SPAWNED)

    	ELSE
    	    BEGIN


    	    ! On a successful return just give an informational message that
    	    ! control is being returned to the parent process.
    	    !
    	    ! Note - if we return to the parent via an ATTACH, we will
    	    ! go through this code, which we don't really want to do.
    	    !
    	    ! We have to first go through some work just to determine the
    	    ! name of the parent process.
	    !
    	    ITEM[0,0,16,0] = 15;
    	    ITEM[0,16,16,0] = JPI$_PRCNAM;
    	    ITEM[1,0,32,0] = NAME_BUFFER;
    	    ITEM[2,0,32,0] = LEN;
	    CH$FILL(0, 12, ITEM[3, A_]);
	    STATUS = LIB$GET_EF(EVNT_FLAG);
	    IF NOT .STATUS THEN SIGNAL(.STATUS);
	    STATUS = $GETJPI(EFN=.EVNT_FLAG, ITMLST=ITEM);
	    LIB$FREE_EF(EVNT_FLAG);
    	    SIGNAL(DBG$_RETURNED, 2, .LEN, NAME_BUFFER);
    	    END;

	END;

    ! After returning from the spawn, set the terminal back to
    ! the appropriate mode. Then return.
    !
    IF .DBG$GB_KEYPAD_INPUT THEN X = 1 ELSE X = 0;
    SMG$SET_KEYPAD_MODE (DBG$GL_KEYBOARD_ID, X);
    RETURN STS$K_SUCCESS;
    END;

GLOBAL ROUTINE dbg$construct_param_name (param_count, param_name, 
    			perm_flag, message_vect) =
!++
! Routine Description
!
!	This routine constructs a name of the form "%Pi", given the
!	number i. The reason there is a global routine for this is
!	that this needs to be called from within DBG$NEXECUTE_DECLARE
!	as well as DBG$NEXECUTE_AT_SIGN.
!
! Inputs
!
!	param_count	-	The number "i" which is to be made into the
!				name "%Pi".
!	param_name	-	An address to receive the constructed name.
!	perm_flag	- 	If TRUE, construct param name out of permanent 
!    				memory
!	message_vect 	-	An error message vector.
!
! Outputs
!
!	A counted string is constructed and param_name is filled in with
!	its address.
!	A condition code is returned. This is one of:
!	STS$K_SUCCESS - success.
!	STS$K_SEVERE - error. An error message vector is constructed.
!
! Side Effects
!
!	Memory is allocated for the name.
!--
    BEGIN

    LOCAL
    	outlen: WORD,				! Receives length from SYS$FAO
    	param_len: WORD,			! Length of parameter name
    	stg_desc1	: dbg$stg_desc,		! Used in call to SYS$FAO
    	stg_desc2	: dbg$stg_desc,		! Used in call to SYS$FAO
    	temp_name: REF VECTOR [,BYTE];		! Holds name temporarily

    EXTERNAL ROUTINE
        sys$fao;

    ! Determine the length of the name.
    !
    IF .param_count GEQ 1 AND .param_count LEQ 9 
    THEN
        param_len = 3
    ELSE IF .param_count GEQ 10 AND .param_count LEQ 99
    THEN
        param_len = 4
    ELSE
    	$DBG_ERROR('DBGATSIGN\DBG$CONSTRUCT_PARAM_NAME');

    ! Allocate space for the name.
    !
    IF .perm_flag
    THEN
    	BEGIN
    	temp_name = dbg$get_memory (1+ (1+.param_len)/4);
    	END
    ELSE
    	BEGIN
    	temp_name = dbg$get_tempmem (1+ (1+.param_len)/4);
    	END;

    temp_name[0] = .param_len;
    ch$move (2, UPLIT BYTE(%ASCII '%P'), temp_name[1]);
    
    ! Fill in the string descriptor for use by SYS$FAO.
    !
    stg_desc1[dsc$w_length] = 3;
    stg_desc1[dsc$a_pointer] = UPLIT BYTE (%ASCII '!SL');
    stg_desc2[dsc$w_length] = .param_len-2;
    stg_desc2[dsc$a_pointer] = temp_name[3];

    ! Call SYS$FAO to convert the number into a string.
    !
    IF NOT sys$fao (stg_desc1, outlen, stg_desc2, .param_count)
    THEN
    	$DBG_ERROR('DBGATSIGN\DBG$CONSTRUCT_PARAM_NAME');

    ! Check that SYS$FAO filled in the expected number of characters.
    !
    IF .outlen NEQ .param_len-2 
    THEN
    	$DBG_ERROR('DBGATSIGN\DBG$CONSTRUCT_PARAM_NAME');

    ! Fill in output parameter.
    !
    .param_name = .temp_name;

    ! Return success.
    !
    RETURN sts$k_success;

    END; ! dbg$construct_param_name

GLOBAL ROUTINE dbg$parse_spawn (parse_stg_desc) =
!+
! Functional Description
!
!	This routine provides an interface from the old language parsers to
!	the new debugger parse network for SPAWN. It is passed a string 
!	descriptor for the remainder of the input line.
!	It calls DBG$NPARSE_SPAWN to construct
!	a command execution network, and returns a pointer to the verb node.
!
! Inputs
!
!	parse_stg_desc	-	A string descriptor for the remainder of the
!				input line.
!
! Outputs
!
!	A command execution network is constructed, 
!	consisting of a verb node for the SPAWN
!	verb, and possibly a noun node for the argument
!--
    BEGIN
    MAP
    	parse_stg_desc : REF BLOCK [,BYTE];

    LOCAL
    	char,
    	dummy_mess_vect: REF VECTOR,	! Address for message vector returned
    					!    from DBG$NPARSE_SPAWN
    	len,				! Length of command line
    	parse_stg_ptr,			! Pointer into command line
    	stg : REF VECTOR [,BYTE],	! Pointer to a new copy of the 
    					!    command line
    	verb_node;			! Pointer to the head of the command
    					!    execution tree for SPAWN

    ! Call the 'new style' parse network for the spawn
    ! command. This builds a command execution network.
    ! We return a pointer to the verb node.
    !
    ! First allocate space for the verb node.
    !
    verb_node = dbg$get_tempmem (dbg$k_verb_node_size);
    			
    ! Then stuff a carriage return character at the end
    ! of the input line since this is what the new style
    ! parser expects to see. Also, translate the line to
    ! upper case (the new debugger does this; the old does not)
    !
    len = .parse_stg_desc[dsc$w_length];
    stg = dbg$get_tempmem (1+(1+.len)/%UPVAL);
    parse_stg_ptr = ch$ptr(.parse_stg_desc[dsc$a_pointer]);
    INCR i FROM 0 TO .len-1 DO
        BEGIN
    	char = ch$rchar_a(parse_stg_ptr);
    	IF .char GEQ %C'a' AND .char LEQ %C'z' 
    	THEN 
    	    stg[.i] = .char - (%C'a'-%C'A')
    	ELSE
    	    stg[.i] = .char;
    	END;
    stg[.len] = dbg$k_car_return;
    parse_stg_desc[dsc$a_pointer] = .stg;
    parse_stg_desc[dsc$w_length] = 
        .parse_stg_desc[dsc$w_length] + 1;
    		
    ! Now call the parser on the remainder of the input line
    !
    IF NOT dbg$nparse_spawn (.parse_stg_desc,
    	.verb_node, dummy_mess_vect)
    THEN
    	! If the above routine does not return success, then we signal
    	! an error using the error message vector that we got back.
        !
    	BEGIN
    	EXTERNAL ROUTINE
    	    LIB$SIGNAL : ADDRESSING_MODE(GENERAL);
    	BUILTIN 
    	    CALLG;
    	CALLG (.dummy_mess_vect, lib$signal);
    	END;

    ! Restore pointer field of PARSE_STG_DESC since this can be wiped out 
    ! during new style parsing.
    !
    IF .parse_stg_desc[dsc$a_pointer] EQL 0
    THEN
        parse_stg_desc[dsc$a_pointer] = .stg+.len;
    
    ! Finally, return a pointer to the verb node.
    !
    RETURN .verb_node

    END; ! dbg$parse_spawn

ROUTINE get_param (input_desc, paren_flag: BYTE, result_addr) =
!++
! Routine Description
!
!	This routine collects a parameter from the input stream. It allocates
!	permanent memory and copies the parameter into that memory. A
!	parameter may be inside of double quotes ("), in which case this
!	routine reads to the closing quote. Or, if it is not inside of
!	quotes then comma (or possibly right paren) is the terminator.
!
! Inputs
!
!	input_desc -	A string descriptor for the remaining input.
!	paren_flag -	TRUE if the parameter list is parenthesized. This
!			affects the parsing of an individual parameter in
!			that a closing paren is treated as a terminator.
!	result_addr -	The address to leave a pointer to the result.
!
! Outputs
!
!	A counted string is constructed out of permanent memory and filled
!	in with the parameter that is read, and a pointer to this string
!	is left in result_addr.
!	The value TRUE is returned if a parameter is successfully read.
!	The value FALSE is returned if a parameter cannot be read.
!--
    BEGIN

    MAP
    	input_desc: REF dbg$stg_desc,
    	paren_flag: BYTE;

    LOCAL
    	char: BYTE,		   ! Holds a character from the stream
    	chars_read,		   ! Count of number of characters read
    	input_ptr,		   ! Pointer into current position in input stream
    	output_ptr,		   ! Pointer into result string
    	prev_char: BYTE,	   ! Holds previously-read character
    	prev_input_ptr,		   ! Pointer to previous position in input stream
    	quote_flag: BYTE,	   ! True if the parameter is quoted
    	result: REF VECTOR[,BYTE], ! Points to the result string
    	saved_input_ptr,	   ! Saved value of input pointer.
    	tot_chars_read;		   ! Count of total characters read

    ! The get_char macro is used when we want to read another character.
    !
    MACRO get_char =
    	prev_input_ptr = .input_ptr;
        char = ch$rchar_a (input_ptr);
        tot_chars_read = .tot_chars_read + 1%;

    ! Initialize some variables.
    !
    input_ptr = .input_desc [dsc$a_pointer];
    tot_chars_read = 0;
    chars_read = 0;
    prev_char = %C' ';
    char = %C' ';

    ! First skip leading blanks.
    !
    WHILE .char EQL dbg$k_blank    
      AND .tot_chars_read LSS .input_desc [dsc$w_length]
    	DO
    	BEGIN
    	get_char;
    	END;

    ! Check for leading quote.
    !
    IF .char EQL dbg$k_dblquote
    THEN
    	BEGIN
    	(.prev_input_ptr)<0,8,0> = 0;
    	quote_flag = TRUE;
    	get_char;
    	END
    ELSE
    	quote_flag = FALSE;

    saved_input_ptr = ch$plus (.input_ptr, -1);
    
    ! Loop through the string representing the parameter, 
    ! until a terminator is found.
    !
    WHILE .char NEQ dbg$k_car_return 
    	AND .tot_chars_read LSS .input_desc[dsc$w_length]
    	DO
    	BEGIN

    	! If we are inside of quotes, the only terminator is a quote (").
    	! Doubled quotes (""), however, must be undoubled.
    	!
    	IF .quote_flag
    	THEN
    	    BEGIN
    		
    	    ! Check for "
    	    !
    	    IF .char EQL dbg$k_dblquote
    	    THEN    	
    
    		! Check for doubled quotes
    		!
    		IF .prev_char EQL dbg$k_dblquote 
    		THEN
    	    	    BEGIN

    		    ! Mark the doubled quote with a 0.
    		    !
    	    	    (.prev_input_ptr)<0,8,0> = 0;
    		    chars_read = .chars_read - 1;
    	    	    END
    		ELSE
    		    ! Must be single quote. Since this terminates the
    		    ! string, exit the loop.
    		    !
    		    EXITLOOP;
    	    END
    	ELSE

    	    ! This else clause is reached when quote_flag is false.
    	    !
    	    BEGIN

    	    ! Comma is a terminator if not inside of quotes.
    	    !
    	    IF .char EQL dbg$k_comma
            THEN
    		BEGIN
    		! Decrement tot_chars_read to back up to before the comma.
    		tot_chars_read = .tot_chars_read - 1;
    		EXITLOOP;
    		END;

    	    ! Right paren is a terminator if not inside of quotes 
     	    ! and paren_flag is true.
    	    !
    	    IF .paren_flag AND .char EQL dbg$k_right_parenthesis 
    	    THEN
    		BEGIN
    		! Decrement tot_chars_read to back up to before the comma.
    		tot_chars_read = .tot_chars_read - 1;
    	        EXITLOOP;
    		END;
    	    END;

    	! Set up for next time around loop.
    	!
    	prev_char = .char;
    	get_char;
    	chars_read = .chars_read + 1;
    	END;

    ! If no characters were read, then we failed to parse a parameter.
    !
    IF .chars_read EQL 0
    THEN
    	RETURN FALSE;

    ! Allocate space for the result.
    !
    result = dbg$get_memory ((.chars_read+1+3)/%UPVAL);

    ! Copy the parameter into the allocated area.
    !
    result[0] = .chars_read;
    output_ptr = result[1];
    INCR i FROM 1 TO .chars_read DO         	
        BEGIN
    	char = ch$rchar_a (saved_input_ptr);
    	WHILE .char EQL 0 DO
    	    char = ch$rchar_a (saved_input_ptr);
    	ch$wchar_a (.char, output_ptr);
    	END;
    
    ! Fill in result_addr.
    !
    .result_addr = .result;

    ! Update input descriptor.
    !
    input_desc [dsc$w_length] = .input_desc [dsc$w_length] - .tot_chars_read;
    input_desc [dsc$a_pointer] = 
    	ch$plus (.input_desc[dsc$a_pointer], .tot_chars_read);

    RETURN TRUE;

    END; ! get_param

GLOBAL ROUTINE DBG$NPARSE_EXIT (INPUT_DESC, VERB_NODE, MESSAGE_VECT) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is the parse network for the EXIT command. Since the EXIT
!	verb has already been recognized in dbg$nparse_cmd, and nothing else may
!	follow that keyword, simply return success.
!
! FORMAL PARAMETERS:
!
! 	input_desc - 		string descriptor for remainder of input line
!
!	verb_node - 		command verb node - the head of the command execution
!				tree.
!
!	message_vect -		the address of a longword to contain the address
!				of a standard message argument vector
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE - 	  The command execution tree is unaffected by this network.
!
! ROUTINE VALUE:	unsigned integer lomgword completion code
!
! COMPLETION CODES:
!
!	sts$k_success (1) -	Always returned as the value of this routine
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    RETURN sts$k_success;

    END;			! End of dbg$nparse_exit


GLOBAL ROUTINE DBG$NEXECUTE_EXIT (VERB_NODE, MESSAGE_VECT) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is the execution network for the EXIT command. An EXIT issued
!	from an indirect command file or DO action buffer means to cease taking
!	commands from the present buffer. In this case, a buffer is removed from
!	the command input stream. An EXIT issued from the terminal means to exit
!	the debugger.
!
! FORMAL PARAMETERS:
!
!	verb_node - 	The head of the command excution tree which in the case 
!			of EXIT consists only of this one node. The value of the
!			verb node is used only to direct processing to this routine
!			and is not used by dbg$nexecute_exit itself.
!
!	message_vect -  The address of a longword to contain the address of a
!			message argument vector
!
! IMPLICIT INPUTS:
!
!
!	dbg$gb_def_out -		    "   "    "     output configuration structure
!
!	dbg$gl_cishead -		    "   "    "     head of command input stream
!
! IMPLICIT OUTPUTS:
!
!	The above data structures may be altered.
!
!	On failure, a message argument vector is returned.
!
! ROUTINE VALUE:
!
!	An unsigned integer longword completion code.
!
! COMPLETION CODES:
!
!	sts$k_severe (4) -	The command could not be executed.
!
!	sts$k_success (1) - 	The command was executed.
!
! SIDE EFFECTS:
!
!	This routine may force the exit of the program image. Nodes may be
!	removed from the command input stream.
!
!--

    BEGIN

    LOCAL
    	count,			! Temporary counter for number of levels to exit.
    	link: REF cis$link;! Pointer to a CIS link.

    !++
    ! When an EXIT is entered to the debugger we want to 'go up a level' to
    ! the next link in the command input stream. This is done for indirect command
    ! files by removing the links for the RAB as well as the associated buffer.
    !--

    ! First walk past any layers of IF, WHILE, or REPEAT that we may be in.
    !
    count = 0;
    link = .dbg$gl_cishead;
    WHILE  .link [cis$b_input_type] EQL dbg$k_cis_if
        OR .link [cis$b_input_type] EQL dbg$k_cis_while
        OR .link [cis$b_input_type] EQL dbg$k_cis_repeat
    	OR .link [cis$b_input_type] EQL dbg$k_cis_for
        DO BEGIN
    	count = .count + 1;
    	link = .link [cis$a_next_link]
    	END;
    	
    ! Now case on the type of buffer we are looking at.
    !
    CASE .link[cis$b_input_type] FROM dbg$k_cis_minimum TO dbg$k_cis_maximum OF
    	SET

        ! Ordinary input buffer.
    	!
        [dbg$k_cis_inpbuf] :
		BEGIN
		LOCAL
	    	    prev_link : REF cis$link;

    		! Look at the CIS above the input buffer CIS.
    		!
  		prev_link = .link [cis$a_next_link];
		CASE .prev_link [cis$b_input_type] FROM dbg$k_cis_minimum
    						   TO dbg$k_cis_maximum OF
    		    SET

    		    ! If it is cis_dbg$input then we are taking commands
    		    ! from DBG$INPUT. In this case we want to exit DEBUG.
    		    !
	    	    [dbg$k_cis_dbg$input] :
		    	BEGIN

		    	! We are accepting command from DBG$INPUT, so just
		    	! exit to the system CLI.
		    	!

		    	IF .dbg$gb_def_out [out_log]
		    	THEN
			    $CLOSE (FAB = dbg$gl_logfab);	! Close log file
		    	dbg$gb_def_out[out_log] = FALSE;
			dbg$gv_control[dbg$v_control_user] = True;
			dbg$gv_control[dbg$v_control_exit] = True;

    			! Call the SMG exit handler which restores the
    			! terminal back to application or numeric mode,
    			! depending on what it was at entry.
    			!
    			IF .dbg$gl_smg_exit_handler NEQ 0
    			THEN
    			    (.dbg$gl_smg_exit_handler)();

		    	$EXIT (code = .dbg$gl_exit_status OR sts$m_inhib_msg);
		    	END;
	    

    		    ! If it is a RAB, we are in an indirect command file.
    		    !
		    [dbg$k_cis_rab] :
	    	    	BEGIN

    			! Remove all CIS buffers we have walked past.
    			!
    			INCR i FROM 1 to .count+2 DO
	    	    	    IF NOT dbg$ncis_remove (TRUE, .message_vect)
	    	    	    THEN
			        RETURN sts$k_severe;
    			RETURN sts$k_success;
	    	        END;

    		    ! We can get inpbuf's nested inside of each other
    		    ! when executing DO command lists.
    		    !
      		    [INRANGE] :
    			BEGIN

    			! Remove all CIS buffers we have walked past.
    			!
    			INCR i FROM 1 to .count+1 DO
	    	    	    IF NOT dbg$ncis_remove (TRUE, .message_vect)
	    	    	    THEN
			        RETURN sts$k_severe;
    			RETURN sts$k_success;
	    	        END;
    			

    		    ! Anything else is a DEBUG error.
    		    !
    	  	    [OUTRANGE] :
    			BEGIN
    			$DBG_ERROR('DBGATSIGN\DBG$NEXECUTE_EXIT');
    			END;

	            TES;

    		END; ! cis_inpbuf case
    
	! If we are accepting commands from an action buffer
	! we go up a level by removing that buffer (and any 
    	! buffers that may be present for loops).
	!
	[dbg$k_cis_acbuf,
    	 dbg$k_cis_screen] :
	    	BEGIN
    		INCR i FROM 1 TO .count+1 DO
	    	    IF NOT dbg$ncis_remove (TRUE, .message_vect)
	    	    THEN
		        RETURN sts$k_severe;
	    	END;

	! Anything else is a DEBUG internal coding error.
	!
	[INRANGE,
	 OUTRANGE] :
	        BEGIN
    		$DBG_ERROR('DBGATSIGN\DBG$NEXECUTE_EXIT');
	    	END;

	TES;

    RETURN sts$k_success;

    END;			! End of dbg$nexecute_exit


GLOBAL ROUTINE DBG$NPARSE_EXITLOOP (INPUT_DESC, VERB_NODE, MESSAGE_VECT) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is the parse network for the EXITLOOP command. 
!	A single noun node is constructed containing the integer
!	argument, if there is one.
!
! FORMAL PARAMETERS:
!
!	input_desc -		string descriptor for the remaining input.
!
!	verb_node - 		command verb node - the head of the command execution
!				tree.
!
!	message_vect -		the address of a longword to contain the address
!				of a standard message argument vector
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	A command execution tree is contructed for use by DBG$NEXECUTE_EXITLOOP
!
! ROUTINE VALUE:	
!
!	An unsigned integer lomgword completion code
!
! COMPLETION CODES:
!
!	sts$k_success (1) -	success
!	sts$k_severe  (4) -	error in input
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    BEGIN

    MAP
    	verb_node : REF dbg$verb_node;

    LOCAL
    	noun_node : REF dbg$noun_node;

    BIND
    	dbg$cs_cr = UPLIT BYTE (1, dbg$k_car_return);

    noun_node = dbg$get_tempmem (dbg$k_noun_node_size);

    verb_node [dbg$l_verb_object_ptr] = .noun_node;

    IF dbg$nmatch (.input_desc, dbg$cs_cr, 1)
    THEN
    	noun_node [dbg$l_noun_value] = 1
    ELSE
    	IF NOT dbg$nsave_decimal_integer (.input_desc, 
    				noun_node [dbg$l_noun_value],
    				.message_vect)
    	THEN
    	    RETURN sts$k_severe;

    RETURN sts$k_success;

    END;			! End of dbg$nparse_exitloop

GLOBAL ROUTINE DBG$NEXECUTE_EXITLOOP (VERB_NODE, MESSAGE_VECT) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is the execution network for the EXITLOOP command. 
!	EXITLOOP N takes you out of N levels of loops. This is done
!	by removing the appropriate buffers from the linked list
!	of command buffers.
!
! FORMAL PARAMETERS:
!
!	verb_node     -  The head of the command excution tree which in the case 
!			 of EXITLOOP consists of this verb node, and a single
!			 noun node with the integer argument.
!
!	message_vect  -  The address of a longword to contain the address of a
!		         message argument vector
!
! IMPLICIT INPUTS:
!
!	dbg$gl_cishead - head of command input stream
!
! IMPLICIT OUTPUTS:
!
!	The CIS data structure may be altered.
!
!	On failure, a message argument vector is returned.
!
! ROUTINE VALUE:
!
!	An unsigned integer longword completion code.
!
! COMPLETION CODES:
!
!	sts$k_severe (4) -	The command could not be executed.
!
!	sts$k_success (1) - 	The command was executed.
!
! SIDE EFFECTS:
!
!	This routine may force the exit of WHILE or REPEAT loops. Nodes may be
!	removed from the command input stream.
!
!--

    BEGIN

    MAP
    	verb_node : REF dbg$verb_node;

    LOCAL
    	cis_ptr : REF cis$link,		! A pointer to a CIS buffer
    	count,				! Local counter of number of cislinks
    					!     to be removed.
    	init_num_levels,		! Number of levels of loop to exit
    	num_levels,			! (copy of) Number of levels of loop to exit
    	noun_node : REF dbg$noun_node;  ! Local pointer to the noun node


    ! Recover the argument to EXITLOOP.
    !
    noun_node = .verb_node [dbg$l_verb_object_ptr];
    num_levels = .noun_node [dbg$l_noun_value];
    init_num_levels = .num_levels;

    ! Initialize cis_ptr and count.
    !	
    cis_ptr = .dbg$gl_cishead;
    count = 0;

    ! Loop past NUM_LEVELS occurences of repeat or while loop buffers.
    !
    WHILE .num_levels GTR 0 DO
        BEGIN
    	
    	CASE .cis_ptr[cis$b_input_type] FROM dbg$k_cis_minimum TO 
    					     dbg$k_cis_maximum OF

    	    SET

    	    ! If the top level CIS indicates that we are not inside
    	    ! of a loop, then the EXITLOOP command is an error.
    	    !
    	    [cis_dbg$input,
    	     cis_rab,
    	     cis_inpbuf,
    	     cis_acbuf]:
    			BEGIN

    			! If the number of loops encountered so far  
    			! is zero, report that we
    			! are not in a loop.
    			!
    			IF .num_levels EQL .init_num_levels
    			THEN
    			    .message_vect = dbg$nmake_arg_vect (
    			    	dbg$_notinloop)

    			! If we have encountered loops, but we get here, 
    			! then we were
    			! in a loop but the argument to EXITLOOP
    			! was too large.
    			!
    			ELSE
        		    .message_vect = dbg$nmake_arg_vect (
    				dbg$_exitarg, 1, .init_num_levels);
    			RETURN sts$k_severe;
    			END;

    	    ! If we are in an if clause, then we want to peel off that
    	    ! CIS. We increment the count of the number of CIS buffers
    	    ! to remove.
    	    !
    	    [cis_if] :
    			BEGIN
    			count = .count + 1;
    			cis_ptr = .cis_ptr [cis$a_next_link];
    			END;

    	    ! If the top layer is a loop, increment the count of the
    	    ! the number of layets of buffers to remove. Decrement
    	    ! the count of the number of remaining loops.
    	    !
    	    [cis_repeat, 
    	     cis_while,
    	     cis_for] :
    			BEGIN
    			count = .count + 1;
    			num_levels = .num_levels - 1;
    			cis_ptr = .cis_ptr [cis$a_next_link];
    			END;

    	    ! Anything else is an error.
    	    !
    	    [INRANGE,
    	     OUTRANGE] :
    			BEGIN
    			$DBG_ERROR('DBGATSIGN\DBG$NEXECUTE_EXITLOOP');
    			END;

    	    TES;
    	    END; ! While loop

    ! Now, if we get to this point without an error, we strip off
    ! the CIS buffers.
    !
    INCR i FROM 1 TO .count DO
    	IF NOT dbg$ncis_remove (TRUE, .message_vect)
    	THEN
    	    RETURN sts$k_severe;

    RETURN sts$k_success;

    END;			! End of dbg$nexecute_exitloop

GLOBAL ROUTINE DBG$NPARSE_DECLARE (INPUT_DESC, VERB_NODE, MESSAGE_VECT) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Parses the DECLARE command. A command execution tree is constructed.
!	This tree contains a noun node for each name that is declared.
!
! FORMAL PARAMETERS:
!
!	input_desc -			The present command line input descriptor
!
!	verb_node  -			The already existing command verb node
!
!	message_vect -			The address of a longword to contain the
!					address of a message argument vector
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	On success, the appropriate command execution tree is constructed.
!
!	On failure, a message argument vector is constructed
!
! ROUTINE VALUE:
!
!	An unsigned integer longword completion code
!
! COMPLETION CODES:
!
!	sts$k_severe (4) -		Error in parsing
!
!	sts$k_success (1) -		Successful parse
!
! SIDE EFFECTS:
!
!	None
!
!--

    BEGIN

    MAP
    	INPUT_DESC: REF dbg$stg_desc,
	VERB_NODE : REF dbg$verb_node;

    BIND
    	dbg$cs_colon		= UPLIT BYTE (1, dbg$k_colon),
    	dbg$cs_comma		= UPLIT BYTE (1, dbg$k_comma),
    	dbg$cs_cr		= UPLIT BYTE (1, dbg$k_car_return),
    	dbg$cs_address		= UPLIT BYTE (7, 'ADDRESS'),
    	dbg$cs_command		= UPLIT BYTE (7, 'COMMAND'),
    	dbg$cs_procedure	= UPLIT BYTE (9, 'PROCEDURE'),
    	dbg$cs_string		= UPLIT BYTE (6, 'STRING'),
    	dbg$cs_value		= UPLIT BYTE (5, 'VALUE');

    LOCAL
    	first_time: BYTE,		! Flag which is true the first time
    					!    around a loop.
    	link,				! A link in the command execution tree.
    	noun_node: REF dbg$noun_node;	! Pointer to a noun node.

    ! Set the first_time flag to true for the first time around the loop.
    !
    first_time = TRUE;

    ! Loop through the list of declarations.
    !
    WHILE TRUE DO 
    	BEGIN

    	! Allocate a noun node and link it in.
    	!
    	IF .first_time    
    	THEN
    	    BEGIN
    	    link = verb_node [dbg$l_verb_object_ptr];
    	    first_time = FALSE;
    	    END
    	ELSE
    	    link = noun_node [dbg$l_noun_link];
    	noun_node = dbg$get_tempmem (dbg$k_noun_node_size);
    	.link = .noun_node;

    	! Read the name being declared.
    	!
    	IF NOT dbg$nread_name (.input_desc, noun_node [dbg$l_noun_value],
    				.message_vect)
    	THEN
    	    RETURN sts$k_severe;

    	! Look for a colon
    	!
    	IF dbg$nmatch (.input_desc, dbg$cs_colon, 1)
    	THEN
    	    
    	    ! Look for a keyword following the colon.
    	    !
    	    SELECTONE TRUE OF
    		SET

    		[dbg$nmatch (.input_desc, dbg$cs_address, 1)] :
    		    noun_node [dbg$l_noun_value2] = define_address;
    	
    		[dbg$nmatch (.input_desc, dbg$cs_command, 1)] :
    		    noun_node [dbg$l_noun_value2] = define_command;

    		! [dbg$nmatch (.input_desc, dbg$cs_procedure, 1)] :
    		!    noun_node [dbg$l_noun_value2] = define_procedure;

    		! [dbg$nmatch (.input_desc, dbg$cs_string, 1)] :
    		!    noun_node [dbg$l_noun_value2] = define_string;

    		[dbg$nmatch (.input_desc, dbg$cs_value, 1)] :
    		    noun_node [dbg$l_noun_value2] = define_value;

    		! Anything else following the colon is an error.
    		!
    		[OTHERWISE] :
    		    report_error;

    		TES

    	! The default type is address.
    	!
    	ELSE
    	    noun_node [dbg$l_noun_value2] = define_address;

    	! Look for the comma which separates declarations.
    	!
    	IF NOT dbg$nmatch (.input_desc, dbg$cs_comma, 1)
    	THEN

    	    ! If end-of-line, then just exit the loop.
    	    !
     	    IF dbg$nmatch (.input_desc, dbg$cs_cr, 1)
    	    THEN
    		EXITLOOP

    	    ! Anything other than end-of-line or comma is a syntax error.
    	    !
    	    ELSE
    	        report_error;

    	END; ! While loop

    ! If we get here, the parse was successful.
    !
    RETURN sts$k_success;

    END;

GLOBAL ROUTINE DBG$NEXECUTE_DECLARE (VERB_NODE, MESSAGE_VECT) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine executes the DECLARE command. This is done by
!	retrieving the strings that were passed in at @, and binding
!	them to the names being declared.
!
! FORMAL PARAMETERS:
!
!	verb_node -			The command verb node which is the start
!					of the command execution tree
!
!	message_vect -			The address of a longword to contain the
!					address of a message argument vector
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	The local DEFINE list for the current procedure is modified.
!	On failure, a message argument vector is returned
!
! ROUTINE VALUE:	
!
!	An unsigned integer longword completion code
!
! COMPLETION CODES:
!
!	sts$k_success (1) -	Indicates the file was created and connected
!
!	sts$k_severe (4) -	Failure, file not created. Message argument vector returned
!
! SIDE EFFECTS:
!
!	None.
!--

    BEGIN

    MAP
	VERB_NODE 	: REF dbg$verb_node;

    BIND
    	dbg$cs_cr		= UPLIT BYTE (1, dbg$k_car_return),
    	dbg$cs_left_paren 	= UPLIT BYTE (1, dbg$k_left_parenthesis);
    	
    LOCAL
    	global_flag,			! Flag that is returned from dbg$def_sym_find
    	input_desc: dbg$stg_desc,	! String descriptor for use with
    					!    AEI and EI.
    	len,				! Length of string
    	new_string: REF VECTOR[,BYTE],	! Pointer to char string
    	noun_node: REF dbg$noun_node,	! Points to a noun node
    	param_name,			! Points to a string with "%Pi"
    	replaced_flag,			! Flag returned from dbg$def_sym_add
    	returned_kind,			! Kind returned from dbg$def_sym_find
    	returned_value:REF VECTOR[,BYTE],! Value returned from dbg$def_sym_find
    	symid_list,			! Points to a symid list
    	value;				! Points to the "value" of the symbol

    ! Obtain the first noun node.
    !
    noun_node = .verb_node [dbg$l_verb_object_ptr];

    ! Loop through the list of declared names.
    !
    WHILE .noun_node NEQ 0 DO
    	BEGIN

    	! Increment the count of the number of names processed.
    	!
    	dbg$gl_param_count [.dbg$gl_pr_nest_level] = 
    	        1 + .dbg$gl_param_count [.dbg$gl_pr_nest_level];
    
    	! Obtain the name of the corresponding parameter.
    	!
    	IF NOT dbg$construct_param_name (
			.dbg$gl_param_count [.dbg$gl_pr_nest_level],
    			param_name, 
    			FALSE, 
    			.message_vect)
    	THEN
    	    RETURN sts$k_severe;

    	! Look up the corresponding value.
    	!
    	IF NOT dbg$def_sym_find (.param_name, returned_kind, returned_value,
    		global_flag, .message_vect)
    	THEN
    	    BEGIN
    	
    	    ! A parameter definition was not found. This most likely
    	    ! indicates more declarations than there were parameters.
    	    ! Report an error.
    	    !
    	    .message_vect = dbg$nmake_arg_vect (dbg$_declarerr, 1, 
    				.noun_node [dbg$l_noun_value]);
    	    RETURN sts$k_severe;
    	    END;


    	! Check that the definition that was found was of type parameter.
	! If not, report an internal DEBUG error.
    	!
    	IF .returned_kind NEQ define_parameter
    	THEN
	    $DBG_ERROR('DBGNDECL\NEXECUTE_DECLARE 10');


    	! Check that the definition was local and not global.  If it was global,
	! we report an internal error.
    	!
    	IF .global_flag
    	THEN
	    $DBG_ERROR('DBGNDECL\NEXECUTE_DECLARE 20');


    	! Convert the definition to the appropriate type.
    	! First turn the string into an input descriptor.
    	! Note - we need to append a carriage return to the end
    	! of the string first.
    	!
    	len = .returned_value[0];
    	new_string = dbg$get_tempmem (1+.len/4);
    	ch$move (.len,returned_value[1],.new_string);
    	new_string[.len] = dbg$k_car_return;
    	input_desc [dsc$w_length] = .len+1;
    	input_desc [dsc$a_pointer] = .new_string;


    	! Case on the kind of symbol.
    	!
     	CASE .noun_node[dbg$l_noun_value2] 
    	    FROM define_lowest TO define_highest OF
    	    SET

    	    [define_address] :
    		BEGIN
    		LOCAL
    		    primptr;

    		! Call the address expression interpreter.
    		!
    		IF NOT DBG$NPARSE_ADDRESS (INPUT_DESC, PRIMPTR,
    		 	.DBG$GB_RADIX[DBG$B_RADIX_INPUT],
    			TOKEN$K_TERM_NONE, .MESSAGE_VECT)
    		THEN
    		    RETURN sts$k_severe;

    		IF NOT dbg$nget_symid (.primptr, symid_list, .message_vect)
    		THEN
    		    RETURN sts$k_severe;
    		IF NOT dbg$ncopy_desc (.primptr, value, .message_vect)
    		THEN
    		    RETURN sts$k_severe;	    		    
    		dbg$sta_lock_symid (.symid_list);    		
    		END;

    	    [define_command, define_string] :
    		BEGIN

    		MAP
    		    value: REF VECTOR[,BYTE];

    		! In these cases we already have the definition in
    		! the appropriate form (a counted string). We need to
    		! allocate space for a copy and then copy the counted
    		! string.
    		!
    		value = dbg$get_memory (((.returned_value[0]+1)+3)/4);
    		value[0] = .returned_value[0];
    		ch$move (.returned_value[0], returned_value[1], value[1]);
    		END;

    	    [define_procedure] :
    		BEGIN

    		! For this case we want to pick up a sequence of DEBUG
    		! commands inside of parenthesis.
    		! First we eat the left paren.
    		!
    		IF NOT dbg$nmatch (input_desc, dbg$cs_left_paren, 1)
    		THEN
    		    report_error;

    		! Call the routine which picks up a sequence of 
    		! DEBUG commands.
    		!
    		IF NOT dbg$nsave_break_buffer (input_desc, 
    			value,
    			.message_vect)
    		THEN
    		    RETURN sts$k_severe;

    		END;

    	    [define_value] :
    		BEGIN
    		LOCAL
    		    temp_desc;	! Variable to hold a pointer to a value descriptor

    		! For this case we just call the expression interpreter
    		! to parse a language expression.
    		!
    		IF NOT DBG$NPARSE_EXPRESSION (INPUT_DESC, 
    			.DBG$GB_RADIX[DBG$B_RADIX_INPUT],
    			TEMP_DESC, TOKEN$K_TERM_NONE, .MESSAGE_VECT)
    		THEN
    		    RETURN sts$k_severe;

    		! Copy the descriptor into permanent memory.
    		!
    		IF NOT dbg$nget_symid (.temp_desc, symid_list, .message_vect)
    		THEN
    		    RETURN sts$k_severe;
    		IF NOT dbg$ncopy_desc (.temp_desc, 
    		    value, .message_vect)
    		THEN
    		    RETURN sts$k_severe;
    		dbg$sta_lock_symid (.symid_list);    		

    		END;


	    ! Anything else is an error.
	    !
    	    [INRANGE,OUTRANGE] :
		$DBG_ERROR('DBGNDECL\NEXECUTE_DECLARE 30');

    	    TES;


    	! Add the appropriate symbol definition.
    	!
    	IF NOT dbg$def_sym_add (.noun_node [dbg$l_noun_value],
    		.noun_node [dbg$l_noun_value2], .value,
    		FALSE, replaced_flag, .message_vect)
    	THEN
    	    RETURN sts$k_severe;

    	! Set up for the next time around the loop.
    	!
    	noun_node = .noun_node [dbg$l_noun_link];
    	END; ! while loop

    ! Return success.
    !
    RETURN sts$k_success;	

    END;	! End of dbg$nexecute_declare
END 
ELUDOM
