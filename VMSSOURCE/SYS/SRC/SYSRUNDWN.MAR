	.TITLE	SYSRUNDWN IMAGE RUNDOWN SYSTEM SERVICE
	.IDENT	'V04-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
; FACILITY: EXECUTIVE, SYSTEM SERVICES
;
; ABSTRACT:
;
; ENVIRONMENT:
;
;--
;
;	.PAGE
	.SBTTL	HISTORY			; DETAILED
;
; AUTHOR:	R. HUSTVEDT	 CREATION DATE: 10-OCT-76
;
; MODIFIED BY:
;
;	V03-018	WMC0002		Wayne Cardoza		28-Aug-1984
;		Don't try to delete logical names if no pointer to them.
;
;	V03-017	RAS0316		Ron Schaefer		25-Jun-1984
;		Change TMK0001 so that we delete ALL process-private
;		logical names, not just those in the process table.
;		Use new LNM internal routine LNM$DELETE_HASH, which
;		assumes that all protection/privileges have been checked.
;		This is ECO 4 in the FT2 update.
;
;	V03-016	LJK0272		Lawrence J. Kenah	10-Apr-1984
;		Reinitialize array of starting points for privileged vectors.
;
;	V03-015	TMK0001		Todd M. Katz		03-Apr-1984
;		Change the deletion of image logical names within the process
;		logical name table so that the $DELLNM system service is used
;		instead of the $DELLOG system service.
;
;	V03-014	SSA0018		Stan Amway		 9-Mar-1984
;		Rundown page fault monitoring activity.
;
;	V03-013	RSH0092		R. Scott Hanna		31-Jan-1984
;		Modify the security auditing process rundown support to
;		use the new IDT dedicated pages.
;
;	V03-012	CDS0001		Christian D. Saether	16-Dec-1983
;		Add comments reflecting new use by F11BXQP of the
;		CCB$B_AMOD field.
;
;	V03-011	RSH0067		R. Scott Hanna		22-Sep-1983
;		Move the RDI table deallocation to earlier in the rundown.
;
;	V03-010	RSH0022		R. Scott Hanna		23-May-1983
;		Add process rundown support to deallocate the Security
;		Auditing Impure Data Table (IDT) and deassign the the
;		Audit Journal.
;
;	V03-009	SRB0084		Steve Beckhardt		29-Apr-1983
;		Added LCK$M_INVVALBLK flag to $DEQ to invalidate value
;		blocks of locks being dequeued at high lock modes.
;
;	V03-008	JLV0231		Jake VanNoy		24-FEB-1983
;		Add checking of CCB$V_IMGTMP flag in running down channels.
;
;	V03-007 RSH0003		R. Scott Hanna		10-Feb-1983
;		Add rundown processing to deallocate the RDI table
;		and zero CTL$GL_RDIPTR.
;
;	V03-006	JWH0135		Jeffrey W. Horn		23-Nov-1982
;		Add rundown processing for CTL$GQ_P0ALLOC and
;		CTL$GL_PRCALLCNT.
;
;	V03-005	ACG0301		Andrew C. Goldstein,	21-Oct-1982  13:39
;		Restore FILCNTNONZ bugcheck
;
;	V03-004	WMC0001		Wayne Cardoza		26-Aug-1982
;		Make the privileged library vector reset a subroutine.
;
;	V03-003	LJK0164		Lawrence J. Kenah	20-Apr-1982
;		Clear byte following RSB in privileged vector rundown loop
;		so that next activation of privileged image succeeds.
;
;	V03-002	LJK0158		Lawrence J. Kenah	9-Apr-1982
;		Reset privileged vectors with process-specific array
;		to allow some vectors to survive image exit.
;
;	V03-001	ACG0278		Andrew C. Goldstein,	1-Apr-1982  10:30
;		Enable resource wait mode during rundown,
;		disable channel deassignment bug trap
;
;

	.SBTTL	DECLARATIONS

;
; INCLUDE FILES:
;

	$ACBDEF				; DEFINE AST CONTROL BLOCK
	$ACMDEF				; DEFINE ACCOUNTING MESSAGE OFFSETS
	$CCBDEF				; DEFINE CHANNEL CONTROL BLOCK
	$IPLDEF				; DEFINE INTERRUPT PRIORITIES
	$LCKDEF				; DEFINE $ENQ/$DEQ FLAGS
	$NSAIDTDEF			; DEFINE THE SECURITY AUDITING IDT OFFSETS
	$OPDEF				; DEFINE OPCODE SYMBOLIC CONSTANTS
	$PCBDEF				; DEFINE PCB OFFSETS
	$PHDDEF				; DEFINE PROCESS HEADER OFFSETS
	$PRDEF				; DEFINE PROCESSOR REGISTERS
	$RDIDEF				; DEFINE RIGHTS DATABASE IDENTIFIER BLOCK OFFSETS
	$SSDEF				; DEFINE STATUS CODES

;
; EQUATED SYMBOLS:
;
ACMODE=4				; DISPLACEMENT TO ACCESS MODE ARGUMENT

NXTKVEC=0			;OFFSET TO NEXT FREE KERNEL VECTOR
NXTEVEC=256			;OFFSET TO NEXT FREE EXEC VECTOR
NXTRVEC=512			;OFFSET TO NEXT FREE RUNDWN VECTOR
NXTMVEC=768			;OFFSET TO NEXT MESSAGE VECTOR

;
; STATIC DATA DEFINITIONS:
;
	.PSECT	YEXEPAGED

PROC_TABLE:				; PROCESS LOGICAL NAME TABLE NAME 
	.ASCID	/LNM$PROCESS/
	.PAGE

	.SBTTL	EXE$RUNDWN - IMAGE RUNDOWN SYSTEM SERVICE

;++
; FUNCTIONAL DESCRIPTION:
;	EXE$RUNDWN TERMINATES ALL PENDING ACTIVITY FOR THE SPECIFIED
;	AND ALL LESS PRIVILEGED ACCESS MODES.  ALL RESOURCES ASSOCIATED 
;	WITH THE PENDING ACTIVITY WILL BE RELEASED IF APPROPRIATE
;
; CALLING SEQUENCE:
;	CALLG	ARGLIST,EXE$RUNDWN
;
; INPUT PARAMETERS:
;	ACMODE(AP) - ACCESS MODE BOUNDARY FOR WHICH RUNDOWN IS TO BE PERFORMED
;			(MAXIMIZED WITH THE ACCESS MODE OF THE CALLER)
;
; IMPLICIT INPUTS:
;	R4 - POINTER TO CURRENT PCB
;
; OUTPUT PARAMETERS:
;	NONE
;
; IMPLICIT OUTPUTS:
;	ALL ACTIVITY INITIATED BUT NOT COMPLETED FOR ALL ACCESS MODES
;	HAVING THE SAME OR LESSER PRIVILEGE THAN THAT SPECIFIED WILL
;	BE TERMINATED.
;
; COMPLETION CODES:
;	SS$_NORMAL  -  SUCCESSFUL COMPLETION
;
; SIDE EFFECTS:
;	NONE
;
;--

	.ENTRY	EXE$RUNDWN,^M<R2,R3,R4,R5,R6,R7>
	EXTZV	#0,#2,ACMODE(AP),R0	; FETCH ACCESS MODE ARGUMENT
	BSBW	EXE$MAXACMODE		; MAXIMIZE WITH PREVIOUS
	MOVL	R0,R7			; SAVE IN R7 FOR REFERENCE
	BBCC	#PCB$V_PWRAST,PCB$L_STS(R4),10$	; SKIP IF NO POWER FAIL AST
	CLRL	@#CTL$GL_POWERAST	; ZAP AST ADDRESS
	INCW	PCB$W_ASTCNT(R4)	; AND RESTORE AST QUOTA
10$:					;
;-------------------------------------------------------------
;
;	Enable resource wait mode to ensure that rundown will succeed.
;
;-------------------------------------------------------------

	$SETRWM_S WATFLG=#0		; ENABLE WAIT MODE
	PUSHL	R0			; SAVE RETURN STATUS

;-------------------------------------------------------------
;
;	INVOKE THE USER RUNDOWN SERVICE(S)
;
;	The user service is invoked in KERNEL mode with a JSB and must
;	exit with a RSB.
;
;	R4 - Pointer to current PCB
;	R7 - Access mode parameter to SYSRUNDWN maximized with previous mode
;	ACMODE(AP) - Access mode parameter to SYSRUNDWN
;
;-------------------------------------------------------------

	MOVL	@#CTL$GL_USRUNDWN, R5	; GET PER-PROCESS USER RUNDOWN VECTOR
	BEQL	20$			; NOT PRESENT, SKIP ON
	JSB	(R5)			; CALL THRU THE VECTOR(S)
20$:	MOVL	G^EXE$GL_USRUNDWN, R5	; GET SYSTEM-WIDE USER RUNDOWN VECTOR
	BEQL	30$			; NOT PRESENT, SKIP ON
	JSB	(R5)			; CALL THRU THE VECTOR(S)
30$:					;
;-------------------------------------------------------------
;
;	WRITE IMAGE ACCOUNTING RECORD
;
;-------------------------------------------------------------
	BBC	#ACM$V_IMAGE,EXE$GL_ACMFLAGS,40$; IMAGE ACCOUNTING ENABLED ?
	CLRL	R5				; NOT A SPECIAL KERNEL AST
	BSBW	EXE$IMGDELMSG			; WRITE IMAGE DELETION MESSAGE
40$:
	CLRQ	@#CTL$GQ_ISTART			; IMAGE ACCOUNTING INACTIVE
;-------------------------------------------------------------
;
;	CLOCK THE IMAGE COUNTER
;
;-------------------------------------------------------------

	MOVL	@#CTL$GL_PHD,R5		; GET ADDRESS OF PROCESS HEADER
	INCL	PHD$L_IMGCNT(R5)	; PROVIDE A CHECKING MECHANISM TO
					; PREVENT DELIVERY OF AST'S TO THE
					; WRONG OR SUBSEQUENT IMAGES
;-------------------------------------------------------------
;
;	RESET THE DISPATCH VECTORS TO THEIR INITIAL VALUES. (NO VECTORS USED)
;
;-------------------------------------------------------------

	JSB	EXE$RESETVEC		; RESET DISPATCH VECTORS
	MOVL	G^MMG$GL_RMSBASE,G^CTL$GL_RMSBASE ;RESET TO DEFAULT RMS
 
;-------------------------------------------------------------
;
;	PAGE FAULT MONITORING RUNDOWN
;
;-------------------------------------------------------------

	$SETPFM_S PFMFLG=#0		; Terminate page fault monitoring
 
;-------------------------------------------------------------
;
;	SECURITY AUDITING PROCESS RUNDOWN
;
;-------------------------------------------------------------
 
	TSTL	R7			; IS THIS PROCESS RUNDOWN?
	BNEQU	DASSIGN1		; BR IF NOT
	MOVL	@#NSA$T_IDT+NSA$L_IDT_AUDIT_CHAN,R5 ; IS JOURNAL ASSIGNED?
	BEQLU	DASSIGN1		; BR IF NOT
	$DEASJNL_S R5			; DEASSIGN JOURNAL

;-------------------------------------------------------------
;
;	DEASSIGN CHANNELS WITHOUT OPEN FILES
;
;-------------------------------------------------------------
DASSIGN1:				; FIRST DEASSIGN PASS
	MOVZWL	@#CTL$GW_CHINDX,R5	; GET MAXIMUM INDEX
	BEQL	21$			; NO CHANNELS ASSIGNED, LEAVE
	MNEGL	R5,R5			; CONVERT TO NEGATIVE OFFSET
	ADDL3	#CCB$B_STS,-
		@#CTL$GL_CCBBASE,R3	; COMPUTE ADDRESS OF HIGHEST CHANNEL
	ASSUME	CCB$B_STS+1 EQ CCB$B_AMOD ; 
10$:	CMPB	1(R3)[R5],R7		; IS THIS CHANNEL DEASSIGNABLE?
	BGTR	15$			; YES, ASSIGNED BY HIGHER ACMODE

;
; NOTE THAT THE PRIVILEGE CHECK TO DETERMINE WHETHER THE CHANNEL SHOULD
; BE DEASSIGNED BY THIS MODE MUST BE A SIGNED COMPARISON.
; THE F11BXQP 'RESERVES' A CHANNEL FOR ITSELF (NEVER TO BE USED BY ANYTHING
; ELSE, OR DEASSIGNED) BY STORING A MINUS 1 (-1) IN THE CCB$B_AMOD FIELD.
; THIS CAUSES A SIGNED TEST AGAINST EVEN KERNEL MODE TO FAIL AS IF THE
; CHANNEL WERE ASSIGNED BY A HIGHER MODE.
; THE CHANNEL NEVER NEEDS TO BE DEASSIGNED BECAUSE THERE IS NO SPECIFIC
; DEVICE ASSOCIATED WITH IT - IT IS FABRICATED BY THE XQP INITIALIZATION
; CODE WHEN THE PROCESS IS CREATED.
;

	BBC	#CCB$V_IMGTMP,(R3)[R5],20$ ; BRANCH IF NOT IMAGE TEMPORARY
15$:	MNEGL	R5,-(SP)		; CONVERT TO REAL CHANNEL NUMBER
	CALLS	#1,G^SYS$DASSGN		; DE-ASSIGN CHANNEL
20$:	ADDL2	#CCB$C_LENGTH,R5	; POINT AT NEXT CHANNEL
	BLSS	10$			; NEXT CHANNEL

;-------------------------------------------------------------
;
;	Deallocate the RDI table and zero CTL$GL_RDIPTR
;
;-------------------------------------------------------------

21$:	MOVL	@#CTL$GL_RDIPTR,R0	; GET RDI POINTER
	BEQLU	22$			; BR IF NOT ALLOCATED
	MOVL	RDI$L_SIZE(R0),R1	; GET SIZE OF ALLOCATED BLOCK
	CLRL	@#CTL$GL_RDIPTR		; ZERO RDI POINTER
	JSB	G^EXE$DEAP1		; DEALLOCATE RDI BLOCK
22$:
 
;-------------------------------------------------------------
;
;	RELEASE MEMORY
;
;-------------------------------------------------------------

	BSBW	MMG$IMGRESET		; RELEASE IMAGE PAGES

;-------------------------------------------------------------
;
;	DEASSIGN CHANNELS - ALL
;
;-------------------------------------------------------------
 
	MOVZWL	@#CTL$GW_CHINDX,R5	; GET MAXIMUM INDEX
	BEQL	40$			; NO CHANNELS ASSIGNED, LEAVE
	MNEGL	R5,R5			; CONVERT TO NEGATIVE OFFSET
	ADDL3	#CCB$B_AMOD,-
		@#CTL$GL_CCBBASE,R3	; COMPUTE ADDRESS OF HIGHEST CHANNEL
25$:	CMPB	(R3)[R5],R7		; IS THIS CHANNEL DEASSIGNABLE?
	BLEQ	30$			; NO, ASSIGNED BY LOWER ACMODE

;
; NOTE THAT THE PRIVILEGE CHECK TO DETERMINE WHETHER THE CHANNEL SHOULD
; BE DEASSIGNED BY THIS MODE MUST BE A SIGNED COMPARISON.
; THE F11BXQP 'RESERVES' A CHANNEL FOR ITSELF (NEVER TO BE USED BY ANYTHING
; ELSE, OR DEASSIGNED) BY STORING A MINUS 1 (-1) IN THE CCB$B_AMOD FIELD.
; THIS CAUSES A SIGNED TEST AGAINST EVEN KERNEL MODE TO FAIL AS IF THE
; CHANNEL WERE ASSIGNED BY A HIGHER MODE.
; THE CHANNEL NEVER NEEDS TO BE DEASSIGNED BECAUSE THERE IS NO SPECIFIC
; DEVICE ASSOCIATED WITH IT - IT IS FABRICATED BY THE XQP INITIALIZATION
; CODE WHEN THE PROCESS IS CREATED.
;

	MNEGL	R5,-(SP)		; CONVERT TO REAL CHANNEL NUMBER
	CALLS	#1,G^SYS$DASSGN		; DE-ASSIGN CHANNEL
	BLBS	R0,30$			; BRANCH ON SUCCESS
	CMPL	R0,#SS$_IVCHNLSEC	; CHECK FOR SECTION ON CHANNEL
	BEQL	30$			; WHICH IS OK
	BUG_CHECK FILCNTNONZ,FATAL	; IT REALLY SHOULD HAVE WORKED

30$:	ADDL	#CCB$C_LENGTH,R5	; POINT AT NEXT CHANNEL
	BLSS	25$			; NEXT CHANNEL
 
;-------------------------------------------------------------
;
;	DEALLOCATE ALLOCATED DEVICES
;
;-------------------------------------------------------------
 
40$:	$DALLOC_S	ACMODE=R7	; DE-ALLOCATE AT ACCESS MODE

;-------------------------------------------------------------
;
;	CANCEL TIMER AND SCHEDULED WAKEUP REQUESTS
;
;-------------------------------------------------------------

	$CANTIM_S	ACMODE=R7	; CANCEL TIMER REQUESTS
	$CANWAK_S			; CANCEL WAKE UP REQUESTS

;-------------------------------------------------------------
;
;	DEQUEUE REMAINING LOCKS
;
;-------------------------------------------------------------

	$DEQ_S		ACMODE=R7,-		; DEQUEUE ALL LOCKS AT SPECIFIED
			FLAGS=#LCK$M_DEQALL!LCK$M_INVVALBLK	
						; ACCESS MODE AND INVALIDATE 
						; VALUE BLOCKS

;-------------------------------------------------------------
;
;	DISASSOCIATE COMMON EVENT BLOCKS
;
;-------------------------------------------------------------

	$DACEFC_S	EFN=#64		; DISASSOCIATE GROUP #2
	$DACEFC_S	EFN=#96		; DISASSOCIATE GROUP #3

;-------------------------------------------------------------
;
;	CLEAR THE IPAST VECTOR AND ADDRESS
;
;-------------------------------------------------------------

	MOVL	PCB$L_IPAST(R4),R1	; Pick up the vector
	BEQL	70$			; There are none
	MOVL	#7,R2			; Set up for 8 entries
50$:	ASHL	#2,R2,R0		; Each entry is 4 bits
	EXTZV	R0,#4,R1,R3		; Pick up the entry (mode+1)
	BEQL	60$			; None there
	CMPL	R3,R7			; At a more priv mode than ACMODE?
	BLEQ	60$			; Yes, do not clear
	INSV	#0,R0,#4,PCB$L_IPAST(R4); No, clear it out
	CLRL	@#CTL$AL_IPASTVEC[R2]	;  and its associated address
60$:	SOBGEQ	R2,50$			; Loop until all done
70$:

;-------------------------------------------------------------
;
;	PURGE PENDING UNDELIVERED AST CONTROL BLOCKS
;
;-------------------------------------------------------------

ASTRUNDWN:				; 
	MOVAL	PCB$L_ASTQFL(R4),R6	; COMPUTE ADDRESS OF HEADER
LOCK_BEGIN:
	SETIPL	W^LOCK_IPL		; BLOCK AST ARRIVAL & LOCK DOWN CODE
	CMPL	G^EXE$GQ_ERLMBX+4,PCB$L_PID(R4)	; CHECK FOR ERROR LOG MAILBOX
	BNEQ	10$			; BR IF NO
	CLRQ	G^EXE$GQ_ERLMBX		; YES, DEASSIGN IT
10$:	MOVL	PCB$L_ASTQBL(R4),R0	; GET TAIL OF AST QUEUE
	CMPL	R0,R6			; CHECK FOR EMPTY QUEUE
	BEQL	20$			; YES, DONE WITH ASTS
	CMPZV	#ACB$V_MODE,#ACB$S_MODE,ACB$B_RMOD(R0),R7 ; CHECK ACCESS MODE OF ACB
	BLSS	20$			; REACHED THE END OF DELETABLE ASTS
	REMQUE	(R0),R0			; REMOVE IT FROM AST QUEUE
	BVS	20$			; EXIT IF QUEUE EMPTY
	BBC	#ACB$V_QUOTA,ACB$B_RMOD(R0),15$	; SKIP IF NO QUOTA ACCOUNTING
	INCW	PCB$W_ASTCNT(R4)	; ALLOW ANOTHER AST
15$:	BITB	#<ACB$M_NODELETE!ACB$M_PKAST>,ACB$B_RMOD(R0)  ; SPECIAL ACTIONS?
	BNEQ	18$			; YES
	JSB	G^EXE$DEANONPAGED	; NO, DEALLOCATE IT
	BRB	10$			; CONTINUE

18$:	BBC	#ACB$V_PKAST,ACB$B_RMOD(R0),10$	; BR IF NO PIGGYBACK AST
	MOVL	R0,R5			; PUT ACB ADDRESS IN R5
;
; CALL PIGGY-BACK SPECIAL KERNEL AST ROUTINE.
; 	R5 - ACB ADDRESS (MUST BE PRESERVED)
; 	IPL = IPL$_ASTDEL (MUST NOT BE LOWERED)
;
	SETIPL	#IPL$_ASTDEL		; LOWER IPL TO IPL$_ASTDEL
	SUBL	#4,SP			; EXTRA LONGWORD FOR INTER-PROCESS ASTS
	JSB	@ACB$L_KAST(R5)		; CALL KAST ROUTINE
	ADDL	#4,SP			; REMOVE EXTRA LONGWORD
	BRB	LOCK_BEGIN		; NO DELETE FOR PKAST

;-------------------------------------------------------------
;
;	RESET AST ACTIVE AND AST ENABLE BITS
;
;-------------------------------------------------------------

20$:	MOVL	R7,R5			; INITIALIZE MODE INDEX
	BEQL	40$			; SKIP TERMINATION HANDLER FOR KERNEL
30$:	
	CMPL	#2,R5			; SUPERVISOR OR USER MODE?
	BGEQ	35$			; BRANCH IF NOT
	CLRL	@#CTL$GL_CMSUPR-8[R5]	; CLEAR CHANGE MODE HANDLER
35$:	CLRL	@#CTL$GL_THEXEC-4[R5]	; CLEAR TERMINATION HANDLER
40$:	CLRQ	@#CTL$AQ_EXCVEC[R5]	; CLEAR EXCEPTION HANDLER ENTRIES
	CLRL	@#CTL$AL_FINALEXC[R5]	; CLEAR LAST CHANCE EXCEPTION HANDLER
	BBSS	R5,PCB$B_ASTEN(R4),50$	; SET ENABLE BIT
50$:	BBCC	R5,PCB$B_ASTACT(R4),60$	; CLEAR AST ACTIVE
60$:	ADDL3	#PCB$V_SSFEXC,R5,R0	; COMPUTE SSFAIL ENABLE BIT NUMBER
	BBCC	R0,PCB$L_STS(R4),70$	; AND CLEAR IT
70$:	AOBLSS	#4,R5,30$		; DO ALL REQUESTED MODES
	CLRL	@#CTL$GL_CMHANDLR	; CLEAR COMPATIBILITY MODE HANDLER
	JSB	G^SCH$NEWLVL		; COMPUTE NEW ASTLVL
	BICL	#<1@PCB$V_FORCPEN>!<1@PCB$V_WAKEPEN>,- ; CLEAR FORCE EXIT AND
		PCB$L_STS(R4)		; WAKE PENDING
	SETIPL	#0			; ENABLE AGAIN
;-------------------------------------------------------------
;
;	DELETE IMAGE LOGICAL NAMES
;
;-------------------------------------------------------------

LOGNRUNDWN:				; LOGICAL NAME RUNDOWN
	MOVL	R7,R2			; ACCESS MODE ARG TO RIGHT REGISTER
	MOVL	@#CTL$GL_LNMHASH,R3	; ADDRESS OF PROCESS HASH TABLE
	BEQL	5$			; NEVER ALLOCATED SPACE
	JSB	G^LNM$DELETE_HASH	; DELETE ALL NAMES
5$:
;-------------------------------------------------------------
;
;	Reset P0 extention to Process Allocation Region
;
;-------------------------------------------------------------

	CLRQ	G^CTL$GQ_P0ALLOC	; RESET LIST HEAD TO NULL
	MOVZWL	G^SGN$GW_CTLIMGLIM,R0	; GET IMAGE LIMIT ON P0 REQUESTS
	ASHL	#9,R0,G^CTL$GL_PRCALLCNT;    AND RESET CELL CONTENTS.

;-------------------------------------------------------------
;
;	Restore previous setting of resource wait mode
;
;-------------------------------------------------------------

	CLRL	R0			; ASSUME ON
	CMPL	(SP)+,#SS$_WASSET	; CHECK IF IT WAS OFF
	BNEQ	10$			; BRANCH IF ON
	INCL	R0			; SET TO TURN OFF
10$:	$SETRWM_S WATFLG=R0

	MOVZWL	#SS$_NORMAL,R0		; SET NORMAL COMPLETION STATUS
	RET				; RETURN

LOCK_IPL:				; END OF LOCKED DOWN CODE
	.LONG	IPL$_SYNCH
LOCK_END:
	ASSUME	LOCK_END-LOCK_BEGIN LE 512	; MUST BE ON ADJOINING PAGES

	.SBTTL	EXE$RESETVEC - REST PROVILEGED LIBRARY VECTORS

;++
; FUNCTIONAL DESCRIPTION:
;	THIS ROUTINE RESETS THE KERNEL AND EXEC CHANGE MODE DISPATCH VECTORS
;	ALONG WITH THE RUNDOWN VECTORS.
;
; CALLING SEQUENCE:
;	JSB EXE$RESETVEC
;
;	R0, R1, R2, R3, AND R6 ARE DESTROYED
;
;
;--

EXE$RESETVEC::
	MOVAB	@#CTL$A_DISPVEC,R6	;GET ADR OF 1ST VECTOR PAGE
; VERIFY THAT EACH SET OF VECTORS USES ONE HALF PAGE

	ASSUME	<NXTEVEC-NXTKVEC> EQ 256
	ASSUME	<NXTRVEC-NXTEVEC> EQ 256
	ASSUME	<NXTMVEC-NXTRVEC> EQ 256

	MOVZBL	#4,R2			; THERE ARE FOUR VECTORS TO RESET
	MOVAW	@#IAC$AW_VECRESET,R1	; R1 LOCATES RESET CONTEXT
	MOVAW	@#IAC$AW_VECSET,R3	; R3 LOCATES THE STARTING POINT

50$:	MOVZWL	(R1),R0			; GET OFFSET INTO VECTOR
	MOVW	(R1)+,(R3)+		; RESET STARTING POINT
	MOVL	R0,(R6)			; STORE OFFSET INTO FIRST LONGWORD
	ADDL2	R6,R0			; LOCATE ADDRESS TO BE RESET
	MOVZBL	#OP$_RSB,(R0)		; STORE "RSB" AT APPROPRIATE OFFSET
	MOVAL	256(R6),R6		; ADVANCE R6 TO NEXT VECTOR
	SOBGTR	R2,50$			;  AND LOOP IF NOT YET DONE
	RSB

	.END
