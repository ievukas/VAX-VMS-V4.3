	.TITLE	ADPERR750 - I/O ADAPTER ERROR HANDLER
	.IDENT	'V04-000'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
; FACILITY:	EXECUTIVE, ERROR HANDLING
;
; ABSTRACT: 	HANDLE ERROR INTERRUPTS GENERATED BY I/O ADAPTERS ON 11/750.
;		TAKEN FROM ADAPTER ERROR HANDLER FOR 11/780.
;
; ENVIRONMENT:	ENTERED ON INTERRUPT STACK AT ADAPTER IPL.
;
; AUTHOR:       MARYANN HINDEN, Creation date: August 1982
;
; MODIFIED BY:
;
;	V03-001	KPL0100		Peter Lieberwirth	10-Feb-1984
;		Change to use CONFREG1.
;
;--

;
;	INCLUDED SYMBOL DEFINITIONS

	$ADPDEF				;DEFINE ADAPTER CONTROL BLOCK SYMBOLS
	$EMBDEF	<MC,SB,SE>		;DEFINE EMB OFFSETS
	$MCHKDEF			;DEFINE RECOVERY BLOCK MASK BITS
	$NDTDEF				;DEFINE NEXUS DEVICE TYPES
	$PRDEF				;DEFINE PROCESSOR REGISTER NUMBERS
	$UASDEF				;DEFINE DW750 IPEC REGISTERS
	$VADEF				;DEFINE PFN BITS


;	LOCAL DATA STORAGE
 
;	LOCAL MACROS

	.MACRO	VECGEN			; Macro to generate ISR entry point
$$$TEMP=.
	PUSHL	I^#0			; Replaced by ADP address for this NEXUS
	BRB	VECEND			; Join common code
$$$TEMP=.-$$$TEMP
	ASSUME	$$$TEMP EQ 8		; Each entry must be 8 bytes long
	.ENDM
 
	.PSECT	WIONONPAGED,QUAD,RD,WRT

	.SBTTL	EXE$UBAERR_INT - UBA ERROR INTERRUPT HANDLER
 
;++
; EXE$UBAERR_INT - UBA ADAPTOR ERROR INTERRUPT HANDLER
;
; INPUTS:
;	ON STACK -	PSL
;			PC
;			ADDRESS OF ADP + ADP$L_UBASCB+12
;
; OUTPUTS:
;	NONE
;
; FUNCTIONAL DESCRIPTION:
;
;	PROCESS ALL INTERRUPTS FROM DW750, SECOND (OPTIONAL)
;	11/750 UBA.  LOG AND TRY TO RECOVER.  
;	WE GET HERE VIA INTERRUPT DISPATCH CODE IN THE ADP
;	DATA STRUCTURE ITSELF.
;
;	THE FOLLOWING IS A DESCRIPTION OF USEAGE OF ADP DATA 
;	STRUCTURE ELEMENTS THAT ARE SPECIFIC TO 11/750 UBA
;	POWERFAIL HANDLING:
;
;	ADP$L_UBASCB 	- SAVED ADDRESS OF INTERRUPT SERVICE
;			  CODE IN THE ADP
;
;	ADP$L_UBASCB+4	- INTERRUPT SERVICE CODE:
;			  
;			  JSB	@#EXE$UBAERR_INT
;
;	ADP$L_UBASCB+10 - UNUSED (0)
;
;	ADP$L_UBASCB+12 - SVA OF IPEC REGISTER (CONTAINS POWERFAIL
;			  INTERRUPT ENABLE AND POWER STATUS BITS)
;
;	ADP$L_UBASPTE	- ADDRESS OF SPTE THAT MAPS ADAPTER
;
;	ADP$L_UBASPTE+4 - ADDRESS OF SPTE THAT MAPS I/O SPACE
;--
 
 
	.ENABL	LSB
 
EXE$UBAERR_INT::
 	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	; Save GPR's
	SUBL3	#<ADP$L_UBASCB+10-ADP$L_CSR>,-
		<6*4>(SP),R4		; Find top of ADP block
	DSBINT				; Lock out the world

RESTART_UBA:				; Enter here on power up
	MOVQ	<8*4>(SP),-(SP)		; Make second copy of PC,PSL for logger
	SUBL	#<2*4>,SP		; Make room for rest of log
	MOVL	ADP$L_UBASCB+12(R4),R3	; Get address of IPEC register

	$PRTCTINI B^10$,#MCHK$M_NEXM	; Protect against machine check

	MOVZWL	(R3),R3			; Get contents of register

	$PRTCTEND 10$

	MOVL	R3,(SP)			; Save register contents on stack
	BLBC	R0,UBA_POWER_DOWN	; No UBA there

; 
; AT THIS POINT IN TIME THE STACK LOOKS AS FOLLOWS
;
;	PSL
;	PC
;	POINTER INTO ADP or POINTER TO START OF ADP
;	R5
;	R4
;	R3
;	R2
;	R1
;	R0
;	IPL
;	PSL (COPY)
;	PC  (COPY)
;	EMPTY - WILL BE TR # OF THIS ADAPTER
; SP -->IPEC REGISTER

;
; MAKE SURE THE CORRECT SLOT IS INTERRUPTING AND CORRECT ADP TYPE
; IS IN CONFIG ARRAY
;
	MOVZWL	ADP$W_TR(R4),R0		; Fetch adapter TR number
	MOVL	R0,4(SP)		; Save on stack
	MOVL	G^EXE$GL_CONFREGL,R3	; Get address of CONFREG array
	MOVL	(R3)[R0],R3		; Get adapter type code
	CMPB	R3,#NDT$_UB1		; Is adapter UBA1?
	BNEQ	120$			; No, inconsistent
; 
; DISPATCH ON STATE OF POWER STATUS BIT IN IPEC REGISTER
;

	BITW	#UAS$M_IP_CR1_PDN,(SP)	; Test power status bit
	BEQL	UBA_POWER_UP		; If EQL, power is up

UBA_POWER_DOWN:
	BSBW	UNMAP_UNIBUS		; Unmap UNIBUS

RETURN:
	BSBW	LOG_ADAPTER		; Log UBA error
	.BYTE	EMB$K_UBA		; UBA errorlog type
	ADDL	#<4*4>,SP		; Clear log from stack
	ENBINT				; Enable interrupts
	POPR	#^M<R0,R1,R2,R3,R4,R5>	; Restore GPR's
	ADDL	#<1*4>,SP		; Clear ADP pointer off stack
	REI				; Done
 
UBA_POWER_UP:				; UNIBUS has regained its strength
	PUSHR	#^M<R1,R2,R3,R4,R5,R6,R7,R8,R9,R10,R11,AP,FP> ; Save regs destroyed by INIT_DEVICE
	$PRTCTINI B^100$,#MCHK$M_NEXM
	MOVZWL	ADP$W_TR(R4),AP		; Initialize for this adapter only
	PUSHL	R4			; Need ADP after INIT_DEVICE
	JSB	G^EXE$INIT_DEVICE	; Initialize devices on this TR level
	POPL	R2			; Restore register for next routine
	JSB	G^UBA$INITIAL		; Re-enable interrupts/init registers
	$PRTCTEND 100$
	POPR	#^M<R1,R2,R3,R4,R5,R6,R7,R8,R9,R10,R11,AP,FP>
	BLBS	R0,RETURN		; We made it
	BRB	UBA_POWER_DOWN		; No Unibus there
 
120$:	BUG_CHECK UNEXUBAINT,FATAL	; Crash; wrong/no adapter


	.SBTTL	ADAPTER_ISR - Adapter power-up interrupt service
;++
; FUNCTIONAL DESCRIPTION:
;
;	ISR Vector entry point for adapter interrupt service on adapter
;	power up after remapping adapter I/O space to black hole page and
;	replacing adapter SCB vector pointer.  The adapter type is checked;
;	Nexus 9 in the configuration array must contain the type for UB1.
;
; INPUTS:
;
;	(SP) - ADP address	
;
; OUTPUTS:
;
;	R0-R5 saved on stack
;	R4 <- ADP address
;	IPL Raised to 31
;--

	.ALIGN	LONG
ADP_BASE=.+2				; Base of ADP address save table
ISR_BASE=.				; Base of ISR entry point table
	VECGEN				; Generate a vector entry point

VECEND:
	PUSHR	#^M<R0,R1,R2,R3,R4,R5>	; Save GPRs
	MOVL	<6*4>(SP),R4		; R4 <- ADP address
	BEQL	120$			; If no ADP address, we're in trouble

	DSBINT				; To IPL 31
	BSBW	MAP_UNIBUS		; Remap the UNIBUS address space
	BRW	RESTART_UBA		; Restart UBA

	.DSABL	LSB


	.SBTTL	LOG_ADAPTER - ERROR LOG ADAPTER ERROR
;++
; LOG_ADAPTER - ERROR LOGGING FOR UBA ADAPTER ERROR INTERRUPTS
;
; FUNCTIONAL DESCRIPTION:
;
;	INTERFACE TO ERROR LOGGING ROUTINE IN MACHINE CHECK
;
; INPUTS:
;
;	(SP) - Points to error log type code
;	(SP)+1 - Return address
;	4 longwords are logged, defined as follows:
;		1 Adapter register (IPEC)
;		TR # of this adapter
;		PC
;		PSL
;
; OUTPUTS:
;
;	Entry made in error log
;	R0-R3 modified
;--

LOG_ADAPTER:

	PUSHR	#^M<R4,R5>		; Save R4, R5
	MOVAL	<3*4>(SP),R5		; Address of error log frame
	MOVL	#<4*4>,R4		; Length of error log frame
	MOVZBL	@<2*4>(SP),R3		; Error log type
	BSBW	MCHK$GL_LOG		; Call error loggin routine in MCHK750
	POPR	#^M<R4,R5>		; Restore R4, R5
	INCL	(SP)			; Bump Stack past type
	RSB

	.SBTTL	UNMAP ADAPTER ADDRESSES, REPLACE SCB VECTOR
;++
; UNMAP_UNIBUS - Remap UBA address space to black hole page
;
; INPUTS:
;
;	R4 - ADP address of the adapter
;	IPL 31
;
; OUTPUTS:
;
;	Adapter address space (and Unibus I/O space for UBA) mapped to
;	black hole page.
;	Adapter SCB vector replaced to point to this module
;	All general registers preserved.
;
; FUNCTIONAL DESCRIPTION:
;
;	On the 11/750, only the second UNIBUS adapter (DW750)may be 
;	powerfailed;  the powerfail interrupt is at 1E4 in the first
;	page of the SCB.  This routine modifies the SPTE's that map
;	the adapter to point to the black hole page instead.  The
;	SCB vector is modified to point to an entry point in this
;	module which will handle the powerup interrupt.  Remapping 
;	to the black hole page allows all code which touches the 
;	adapter I/O address space to continue without machine checks. 
;	Note that any such code (drivers, map register initialization,
;	etc.) will of course not do what it thought it was doing.  
;	The result should be device timeout for any I/O request.
;
;	The interrupt service routine entry point is located in this module.
;	When the adapter is unmapped, the SCB vector is redirected to the
;	interrupt service routine in this module.  Thus, this module
;	receives all interrupts from an unmapped adapter.
;
;	The interrupt service routine entry point is of the form:
;
;	PUSHL	I^#0
;	BRB	VECEND
;
;	When an adapter is unmapped, its ADP address is stored in the immediate
;	constant that is pushed on the stack.   This location is cleared when
;	the adapter is mapped and is used as a flag to prevent double mapping or
;	unmapping.
;
;	The interrupt service routine is exactly 8 bytes long (a quadword).
;	Thus the vector is long word aligned and some assumptions can be made 
;	for indexing into the array.  Indexing must be PIC.
;--

UNMAP_UNIBUS:
	PUSHR	#^M<R0,R1,R2,R3,R6>	; Save GPR's used
	MOVL	#24,R0			; Number of SPTE's to modify
	MOVAL	W^ADP_BASE,R6		; Get address of ISR 
	TSTL	(R6)			; Test saved ADP address cell
	BNEQ	100$			; If not zero, already unmapped
	MOVL	R4,(R6)			; Save ADP address for power up
	MOVL	G^EXE$GL_SCB,R1		; SCB base address
	DECL	R6			; Calculate ISR base +1 (vector) address
	MOVL	R6,^x1E4(R1)		; Change ISR address for vector in SCB
	MOVL	ADP$L_CSR(R4),R2	; Virtural address of adapter space
	JSB	G^MMG$SVAPTECHK		; Address of SPTE that maps adapter
	MOVL	G^EXE$GL_BLAKHOLE,R1	; PFN of black hole page
10$:	INSV	R1,#0,#VA$S_VPN,(R3)	; Insert new PFN in SPTE
	ADDL	#4,R3			; Point to next SPTE
	SOBGTR	R0,10$			; Do for all
	INVALID				; Invalidate TB
100$:	POPR	#^M<R0,R1,R2,R3,R6>	; Restore GPR's
	RSB

	.SBTTL	MAP ADAPTER ADDRESS, RESTORE SCB VECTORS
;++
; MAP_UNIBUS - Map UBA adapter addresses, restore UBA SCB vector
;
; FUNCTIONAL DESCRIPTION:
;
;	Restore SCB vector address from ADP for the adapter.  Restore
;	SPTE contents that map adapter and I/O address space.  These
;	routines essentially undo everything done by UNMAP_UNIBUS.
;
; INPUTS:
;
;	R4 - Adapter ADP address
;	IPL 31
;
; OUTPUTS:
;
;	PFN field of SPTE's that map adapter and adapter I/O space are
;	restored to point to the adapter.
;	SCB vector is pointed to the original system adapter ISR.
;--

MAP_UNIBUS:
	PUSHR	#^M<R0,R1,R2,R3>	; Save GPR's
	MOVAL	ADP$L_UBASCB(R4),R0	; Address of field containing ISR address
	BSBB	MAP			; Common re-map routine
	MOVL	ADP$L_UBASPTE(R4),R2	; Saved SPTE value that maps adapter
	MOVL	#24,R0			; UBA uses 24 SPTE's
10$:	MOVL	R2,(R3)+		; Replace each SPTE
	INCL	R2			; Point to next page
	CMPL	#17,R0			; Switch from adapter to I/O space
	BNEQ	20$			; For Unibus I/O page
	MOVL	ADP$L_UBASPTE+4(R4),R2	; SPTE value that maps I/O space
20$:	SOBGTR	R0,10$			; All SPTE's
	INVALID				; Invalidate TB
MAP_END:
	POPR	#^M<R0,R1,R2,R3>	; Restore GPR's
	RSB

;++
; MAP - Common adapter re-map routines
;
; INPUTS:
;
;	R0 - address of ADP field containing saved value for adapter SCB ISR
;	R4 - address of adapter ADP
;	return address plus R0,R1,R2,R3 saved on stack
;
; OUTPUTS:
;
;	R3 - address of first SPTE that maps adapter addresses
;	Adapter SCB vector restored to system ISR
;	R0,R1,R2 modified
;	If Adapter already mapped, stack is cleared and return to caller's
;	caller is made.
;
; Refer to comments at start of paragraph "UNMAP".
;--

MAP:
	MOVAL	W^ADP_BASE,R1		; Get address of vector
	TSTL	(R1)			; Adapter already mapped?
	BEQL	100$			; Yes, exit
	CLRL	(R1)			; Flag adapter already mapped
	MOVL	G^EXE$GL_SCB,R1 	; SCB base address
	MOVL	(R0),^X1E4(R1)		; Restore SCB vector
	MOVL	ADP$L_CSR(R4),R2	; Address of Adapter CSR
	JSB	G^MMG$SVAPTECHK		; Address of SPTE that maps adapter CSR
	RSB
100$:	ADDL	#4,SP			; Clear callers return address from stack
	BRB	MAP_END			; Restore GPR's and return to caller's caller

	.END
