	.TITLE	DLBTDRIVR - RL01/2 BOOT DRIVER
	.IDENT	'V03-001'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;

;++
; FACILITY:	BOOTS
;
; ABSTRACT:
;	This module contains the bootstrap device driver for
;	the RL01/2  disks.
;
; ENVIRONMENT:	IPL 31, kernel mode, code must be PIC
;
; AUTHOR:  Steve Beckhardt,	CREATION DATE:  31-Oct-1979
;  (Original author:  Charlie Franks)
;
; MODIFIED BY:
;
;	03-01	WHM0001		Bill Matthews		18-JUN-1984
;		Rewrite to support booting on MicroVAX I on a QBUS.
;
;	02-03	GRR2003		G. R. Robert		11-JUN-1981
;		Fixed get status code to test status bits properly
;
;	02-02	CAS0001		C.A. Samuelson		30-Apr-1980
;		Change interface to BOOTDRIVR for purge of UBA datapath
;
;--

	.SBTTL	DECLARATIONS
;
; INCLUDE FILES:
;

	$BTDDEF				; Boot device types
	$IODEF				; I/O function codes
	$PRDEF				; Define processor registers
	$PTEDEF				; Define page tabel entry fields
	$RPBDEF				; RPB offsets
	$SSDEF				; Status codes
	$UBADEF				; UBA definitions
	$UBIDEF				; 11/750 UBA definitions
	$VADEF				; Define virtual address fields

;
; MACROS:
;

;
; EQUATED SYMBOLS:
;
; 
; RL11/RL02 CONTROLLER REGISTER OFFSETS
; 

	$DEFINI	RL			;START OF REGISTER DEFINITIONS

$DEF	RL_CS		.BLKW	1	;CONTROL STATUS REGISTER (CSR)
	_VIELD	RL_CS,0,<-		;START OF CSR BIT DEFINITIONS
		<DRDY,,M>,-		; DRIVER READY
		<FCODE,3>,-		; FUNCTION CODE
		<XBA,2>,-		; BUS ADDRESS EXTENSION BITS
		<IE,,M>,-		; INTERRUPT ENABLE
		<CRDY,,M>,-		; CONTROLLER READY
		<DS,2>,-		; DRIVE SELECT
		<OPI,,M>,-		; OPERATION INCOMPLETE
		<CRC,,M>,-		; DATA CRC OR HEADER CRC
		<DLT,,M>,-		; DATA LATE OR HEADER NOT FOUND
		<NXM,,M>,-		; NON-EXISTENT MEMORY
		<DE,,M>,-		; DRIVE ERROR
		<CE,,M>-		; COMPOSITE ERROR
	>				;END CSR BIT DEFINITIONS

$DEF	RL_BA		.BLKW	1	;BUS ADDRESS REGISTER (BAR)

$DEF	RL_DA		.BLKW	1	;DISK ADDRESS REGISTER (DAR)
	_VIELD	RL_DA,0,<-		;START OF DAR BIT DEFINITIONS
		<MRK,,M>,-		; MARK (ALWAYS 1)
		<STS,,M>,-		; GET STATUS
		<,1>,-			; RESERVED BIT
		<RST,,M>,-		; RESET
		<,12>-			; RESERVED BITS
	>				;END OF DAR BIT DEFINITIONS

$DEF	RL_MP		.BLKW	1	;MULTIPURPOSE REGISTER (MPR)
	_VIELD	RL_MP,0,<-		;START OF MPR BIT DEFINITIONS
		<STA,3>,-		; DRIVE STATE
		<BH,,M>,-		; BRUSH HOME
		<HO,,M>,-		; HEADS OUT
		<CO,,M>,-		; COVER OPEN
		<HS,,M>,-		; HEAD SELECT
		<TYP,,M>,-		; DRIVE TYPE
		<DSE,,M>,-		; DRIVE SELECT ERROR
		<VC,,M>,-		; VOLUME CHECK
		<WGE,,M>,-		; WRITE GATE ERROR
		<SPE,,M>,-		; SPIN ERROR
		<SKTO,,M>,-		; SEEK TIME OUT
		<WL,,M>,-		; WRITE LOCK
		<CHE,,M>,-		; CURRENT HEAD ERROR
		<WDE,,M>-		; WRITE DATA ERROR
	>				;END OF MPR BIT DEFINITIONS

$DEF	RL_BAE		.BLKW	1	; BUS ADDRESS EXTENSION REGISTER

	$DEFEND	RL			;END RL11/RL02 REGISTER DEFINITIONS


;
; OWN STORAGE:
;

;
; Boot driver table entry
;

	$BOOT_DRIVER	DEVTYPE = BTD$K_DL,-	; Device type (DL)
			SIZE = DL_DRVSIZ,-	; Driver size
			ADDR = DL_DRIVER,-	; Driver address
			UNIT_INIT = DL_INIT,-	; Driver unit init routine
			DRIVRNAME = DLNAME	; Driver file name


	.SBTTL	RL01/2 Bootstrap driver code

;++
;
; Inputs:
;
;	R2	- physical address of the PTE for the user buffer virtual address
;	R3	- base address of adapter's register space
;	R5	- LBN FOR CURRENT PIECE OF TRANSFER
;	R6	- contains 0
;	R7	- address of device's CSR
;	R8	- SIZE OF TRANSFER IN BYTES
;	R9	- address of the RPB
;	R10	- starting address of transfer (user buffer address)
;
;	FUNC(AP)- I/O operation (IO$_READLBLK or IO$_WRITELBLK only)
;	BUF(AP) - Buffer address
;	SIZE(AP)- Size of transfer
;	MODE(AP)- 0 => Physical, 1 => Virtual
;
; Implicit inputs:
;
;	RPB$W_UNIT	- RPB field containing boot device unit number
;
; Outputs:
;
;	R0 - status code
;
;		SS$_NORMAL	- successful transfer
;		SS$_CTRLERR	- fatal controller error
;
;	R3 - must be preserved
;
;	This routine destroys R1, R2, R4, R5, R6. Within the
;	routine, register usage is as follows:

;--

BUF = 4
SIZE = 8
FUNC = 16
MODE = 20


DL_DRIVER:

;
; CALCULATE INTERNAL BUFFER ADDRESS
;
	
	MOVAB	DL_BUFFER,R4		; GET BUFFER AREA ADDRESS
	ADDL2	#511,R4			; GET TO A PAGE BOUNDARY
	BICL2	#511,R4			;
	MOVL	R4,DL_BUFFER_PA		; ASSUME PHYSICAL ADDRESS
	MOVL	R4,DL_BUFFER_VA		; ASSUME VIRTUAL ADDRESS
	MOVL	R2,DL_PHYS_PTE		; SAVE PHYSICAL ADDRESS OF PTE
	MFPR	#PR$_MAPEN,R0		; IS MAPPING ENABLED?
	BEQL	9$			; IF EQL NO
	MOVL	RPB$L_SVASPT(R9),R0	; ASSUME SYSTEM VIRTUAL ADDRESS
	BBS	#VA$V_SYSTEM,R4,8$	; BRANCH IF SYSTEM VIRTUAL ADDRESS
	MFPR	#PR$_P0BR,R0		; GET P0 PAGE TABLE ADDRESS
8$:	EXTZV	#VA$V_VPN,#VA$S_VPN,R4,R1;GET VIRTUAL PAGE NUMBER OF BUFFER
	MOVL	(R0)[R1],R0		;GET THE PTE CONTENTS
	BICL3	#^C<VA$M_BYTE>,R4,R1	;GET BUFFER OFFSET (BA00-BA08)
	ASSUME	PTE$S_PFN GE 13
	INSV	R0,#9,#13,R1		;COPY BA09-BA21
	MOVL	R1,DL_BUFFER_PA		;SAVE THE BUFFER'S PHYSICAL ADDRESS

;
; RESET DRIVE AND WAIT FOR IT TO SPIN UP.
;

9$:	CLRL	R0			; CLEAR R0
	INSV	RPB$W_UNIT(R9),#8,#2,R0	; GET UNIT NUMBER
	MOVW	#RL_DA_M_RST!-		; PUT RESET & GET STATUS IN DAR
		RL_DA_M_STS!-
		RL_DA_M_MRK,RL_DA(R7)
10$:	BISW3	#4,R0,RL_CS(R7)		; EXECUTE DRIVE RESET
	BSBW	READY			; WAIT FOR CONTROLLER READY
	MOVZWL	RL_MP(R7),R6		; FETCH STATUS WORD
	CMPZV	#0,#5,R6,-		; TEST STATUS BITS 04:00
		#RL_MP_M_HO!-		; HEADS,BRUSHES,STATE OK?
		RL_MP_M_BH!5		; ... (5 = SEEK LINEAR MODE STATE)
	BNEQ	10$			; BRANCH IF NOT: WAIT FOR DRIVE TO SPIN UP
	BITW	#RL_CS_M_DRDY,RL_CS(R7)	; IS DRIVE READY?
	BEQL	10$			; IF NOT, BRANCH TO WAIT FOR DRIVE READY

;
; FIND CURRENT DISK ADDRESS, CALCULATE CYLINDER DIFFERENCE, AND SEEK
; DESIRED CYLINDER
;

20$:	BISW3	#8,R0,RL_CS(R7)		; EXECUTE READ HEADER
	BSBW	READY			; WAIT FOR CONTROLLER READY
	BGEQ	30$			; BRANCH IF NO ERROR READING HEADER
	BRW	100$			; OTHERWISE, BRANCH TO ERROR HANDLING
30$:	BICW3	#^O77,RL_MP(R7),R1	; GET CURRENT CYL & SURFACE

;
; NOW CONVERT LOGICAL TO PHYSICAL
;

	MULL	#2,R5			; CONVERT LOGICAL BLOCKS TO SECTORS
	CLRL	R6			; CLEAR HIGH PART OF DIVIDEND
	EDIV	#80,R5,R6,R4		; R6 = DESIRED CYL = LBN/(SECTORS/CYL)
					; R4 = REMAINING SECTORS
	CLRL	R5			; CLEAR HIGH PART OF DIVIDEND
	EDIV	#40,R4,R5,R4		; R5 = DESIRED SURFACE = R5/(SECT/SUR)
					; R4 = DESIRED SECTOR
	ASHL	#7,R6,R6		; SHIFT DESIRED CYLINDER INTO R6<15:7>
	INSV	R5,#6,#1,R6		; INSERT DESIRED SURFACE BIT INTO R6<6>
	CMPW	R6,R1			; IS A SEEK NEEDED?
	BEQL	50$			; BRANCH IF NOT.

;
; NEED TO PERFORM A SEEK.
;

	BICW	#^O177,R1		; ISOLATE CURRENT CYLINDER IN R1
35$:	BICW3	#^O177,R6,R2		; ISOLATE DESIRED CYLINDER IN R2
	SUBW	R2,R1			; SUBTRACT DESIRED FROM ACTUAL
	BEQL	40$			; BRANCH IF CURRENT = DESIRED CYLINDER
	BCC	40$			; BRANCH IF CURRENT >= DESIRED CYLINDER
	MNEGW	R1,R1			; ACTUAL<DESIRED, MAKE POSITIVE DIFF
	BISW	#4,R1			; SET SIGN FOR MOVE TO CENTER OF DISK
40$:	INSV	R5,#4,#1,R1		; INSERT SURFACE BIT IN R1<4>
	BISW3	#RL_DA_M_MRK,R1,-	; SET MARKER AND LOAD DIFFERENCE
		RL_DA(R7)		; WORD.
	BISW3	#6,R0,RL_CS(R7)		; EXECUTE SEEK FUNCTION
	BSBW	READY			; WAIT FOR CONTROLLER READY OR ERROR
	BGEQ	50$			; BRANCH IF NO ERROR DURING SEEK
	BRW	100$			; OTHERWISE, BRANCH DUE TO ERROR

; 
; SEEK, IF ANY, IS COMPLETE. EXECUTE TRANSFER FUNCTION
; 

50$:	INSV	R4,#0,#6,R6		; MERGE SECTOR WITH CYLINDER AND SURFACE
					; CYL=R6<15:7> SUR=R6<6> SEC=R6<5:0>
	MOVW	R6,RL_DA(R7)		; SET DESIRED DISK ADDRESS
	MOVW	DL_BUFFER_PA,RL_BA(R7)	; SET BUFFER PHYSICAL ADDRESS
	MOVW	DL_BUFFER_PA+2,RL_BAE(R7);
	MOVW	R8,R2			; GET WORKING COPY OF BYTES LEFT TO XFER
					; AND ASSUME THIS IS LAST TRANSFER
	SUBW3	R4,#40,R1		; R1 = SECTORS LEFT ON SURFACE
	MULW	#256,R1			; CONVERT TO BYTES LEFT ON SURFACE
	CMPW	R2,R1			; ARE ADDITIONAL TRANSFERS REQUIRED?
	BLEQU	60$			; BRANCH IF ANSWER IS NO.
	MOVW	R1,R2			; SET BYTE COUNT FOR THIS TRANSFER
60$:	CMPW	R2,#DL_BUFSZ		; TRANSFER FIT IN BUFFER?
	BLEQU	61$			; IF LEQU YES
	MOVZWL	#DL_BUFSZ,R2		; TRANSFER ONE BUFFER'S WORTH OF DATA
61$:	DIVW3	#256,R2,R1		; GET TRANSFER SIZE IN SECTORS
	ADDW2	R1,R4			; UPDATE SECTOR ADDRESS
	CMPW	R4,#40			; TRANSFER COMPLETE THE TRACK?
	BNEQ	62$			; IF NEQ NO
	CLRW	R4			; INDICATE NO MORE SECTORS ON TRACK
62$:	DIVW	#2,R2			; CALCULATE TRANSFER WORD COUNT
	MNEGW	R2,RL_MP(R7)		; SET NEG TRANSFER WORD COUNT
	MOVW	#^XC,R1			; ASSUME READ FUNCTION
	CMPL	FUNC(AP),#IO$_WRITELBLK	; IS IT A WRITE FUNCTION?
	BNEQ	70$			; BRANCH IF NOT
	BSBW	MOVE_FROM_USER		; COPY USER BUFFER TO INTERNAL BUFFER
	MOVW	#^XA,R1			; SET WRITE FUNCTION CODE
70$:	BISW3	R0,R1,RL_CS(R7)		; MERGE UNIT # WITH FUNCTION AND EXECUTE
	BSBW	READY			; WAIT FOR CONTROLLER READY OR ERROR
	BLSS	100$			; BRANCH ON ERROR
80$:	MULW	#2,R2			; FIND BYTES TRANSFERRED THIS TIME
	CMPL	FUNC(AP),#IO$_READLBLK	; IS IT A READ FUNCTION?
	BNEQ	85$			; BRANCH IF NOT
	BSBW	MOVE_TO_USER		; COPY INTERNAL BUFFER TO USER BUFFER
85$:	SUBW	R2,R8			; UPDATE BYTES LEFT TO TRANSFER
	BEQL	90$			; BRANCH IF TRANSFER IS COMPLETE

; 
; UPDATE PARAMETERS FOR NEXT TRANSFER
; 

	TSTW	R4			; SECTORS LEFT ON THIS TRACK?
	BEQL	86$			; IF EQL NO
	BRW	50$			; LOOP FOR NEXT TRANSFER
86$:	BICW3	#^O177,RL_DA(R7),R1	; UPDATE CURRENT CYLINDER IN R1<15:7>
	BISW3	#^O77,RL_DA(R7),R6	; SET SECTOR BITS TO 1'S AND -
	INCW	R6			; UPDATE DESIRED DISK ADDRESS IN R6
	EXTZV	#6,#1,R6,R5		; UPDATE DESIRED SURFACE IN R5
	CLRL	R4			; UPDATE DESIRED SECTOR IN R4
	BRW	35$			; LOOP FOR NEXT TRANSFER

; 
; TRANSFER COMPLETE - RETURN
; 

90$:	MOVZWL	SIZE(AP),R1		; SET TOTAL BYTES TRANSFERRED
	BNEQ	95$			; BRANCH IF ORIGINAL SIZE WAS TRANSFERRED
	MOVL	#^X8000,R1		; ELSE SIZE WAS FORCED TO 64K
95$:	MOVZWL	#SS$_NORMAL,R0		; SET COMPLETION CODE
	RSB				; AND RETURN

; 
; RETRY ERROR
; 

100$:	MOVZWL	SIZE(AP),R8		; RESTORE BYTE SIZE OF TRANSFER IN R8
	BNEQ	110$			; BRANCH IF SIZE WAS LEGAL
	MOVL	#8000,R8		; ELSE FORCE TO 64K SIZE
110$:	EXTZV	#0,#9,BUF(AP),R10	; RESTORE BYTE OFFSET IN R10
	MOVZWL	#SS$_CTRLERR,R0		; SET FATAL CONTROLLER ERROR
	RSB				; AND ATTEMPT RETRY


;
; SUBROUTINE TO WAIT FOR CONTROLLER READY OR ERROR
;
 
READY:					;
	BITW	#^X8080,(R7)		;CONTROLLER READY OR ERROR?
	BEQL	READY			;IF EQL NO
	RSB				;

	.PAGE
	.SBTTL	MOVE BUFFER - MOVE BETWEEN PHYSICAL AND MAPPED MEMORY
;++
; Functional Description:
;	MOVE_FROM_USER/MOVE_TO_USER moves the specified number of bytes from the
;	given physical address from/to a specified system virtual address
;
;	DL_BUFFER_PA = physical address to move data from/to
;	R2 = number of bytes to move
;	R10 = virtual address to move them to/from
;	DL_PHYS_PTE = physical address of the PTE's
;
; Output Parameters:
;
;--
MOVE_FROM_USER:
	PUSHR	#^M<R0,R1,R2,R3,R4,R5,R6,R7,R8,R9>
	BLBC	MODE(AP),10$		; BRANCH IF PHYSICAL MODE
	MFPR	#PR$_MAPEN,R1		; MAPPING ENABLED?
	BEQL	20$			; BRANCH IF NOT
10$:	MOVC3	R2,(R10),@DL_BUFFER_VA	; COPY USER BUFFER TO INTERNAL BUFFER
	BRB	RET			; RETURN
20$:	MOVL	#1,R6			; SET MOVE FROM FLAG
	BRB	MOVEMAPPED		; MOVE BETWEEN PHYSICAL AND MAPPED MEMORY

MOVE_TO_USER:
	.ENABL	LSB
	PUSHR	#^M<R0,R1,R2,R3,R4,R5,R6,R7,R8,R9>
	BLBC	MODE(AP),10$		; BRANCH IF PHYSICAL MODE
	MFPR	#PR$_MAPEN,R1		; MAPPING ENABLED?
	BEQL	20$			; BRANCH IF NOT
10$:	MOVC3	R2,@DL_BUFFER_VA,(R10)	; COPY USER BUFFER TO INTERNAL BUFFER
RET:	POPR	#^M<R0,R1,R2,R3,R4,R5,R6,R7,R8,R9>
	ADDL2	R2,R10			; UPDATE BUFFER ADDRESS
	RSB				; RETURN
20$:	CLRL	R6			; SET MOVE TO FLAG
	.DSABL	LSB
MOVEMAPPED:
	MOVL	R2,R8			; PUT BYTE COUNT IN SAFE REGISTER
	MOVL	DL_BUFFER_PA,R1		; GET INTERNAL BUFFER ADDRESS
	EXTZV	#VA$V_BYTE,#VA$S_BYTE,R10,R2 ; STARTING BYTE OFFSET
	EXTZV	#VA$V_VPN,#VA$S_VPN,R10,R7 ; GET VIRTUAL PAGE NUMBER
	MOVAL	@DL_PHYS_PTE[R7],R7	; GET SPT ENTRY ADDRESS
	CLRL	R0			; BACKGROUND THIS FOR INSV IN LOOP
					; MOVC WILL ZERO IT EACH TIME
	BRB	20$
10$:	CLRL	R2			; NO BYTE OFFSET
20$:	INSV	(R7)+,#VA$V_VPN,#PTE$S_PFN,R0 ; DESTINATION PAGE ADDRESS
	SUBL3	R2,#512,R9		; NO. OF BYTES TO MOVE
	CMPL	R9,R8			; DON'T MOVE MORE THAN IS LEFT
	BLEQ	30$			; BRANCH IF MORE TO DO
	MOVL	R8,R9			; OTHERWISE USE WHAT IS LEFT
30$:	BLBC	R6,40$			; BRANCH IF MOVE TO USER BUFFER
	MOVC3	R9,(R0)[R2],(R1)	; MOVE THE NEXT PIECE
	MOVL	R3,R1			; UPDATE INTERNAL BUFFER ADDRESS
	BRB	45$			;
40$:	MOVC3	R9,(R1),(R0)[R2]	; MOVE THE NEXT PIECE
45$:	SUBL	R9,R8			; COUNT BYTES MOVED
	BGTR	10$			; BRANCH IF MORE TO MOVE
	BRB	RET			; GOTO COMMON RETURN

;
; UNIT INITIALIZATION ROUTINE
;
DL_INIT:.WORD	0			; UNIT INITIALIZATION ROUTINE
	CLRW	RPB$W_R0UBVEC(R11)	; NO SPECIAL INTERRUPT VECTOR
	MOVL	#1,R0			; INDICATE SUCCESS
	RET				; RETURN

DLNAME:	.ASCIC	/DLDRIVER.EXE/		; Driver file name

;
; INTERNAL BUFFER DEFINITION
;
DL_BUFFER_VA:	.LONG	0		; VIRTUAL ADDRESS OF DL_BUFFER
DL_BUFFER_PA:	.LONG	0		; PHYSICAL ADDRESS OF DL_BUFFER
DL_PHYS_PTE:	.LONG	0		; PHYSICAL ADDRESS OF THE PTE'S FOR
					; THE USER BUFFER VIRTUAL ADDRESS
DL_BUFFER:	.BLKB	1023
DL_BUFSZ = 512

DL_DRVSIZ=.-DL_DRIVER

	.END
