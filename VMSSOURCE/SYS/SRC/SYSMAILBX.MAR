        .TITLE	SYSMAILBX - SYSTEM SERVICES TO CREATE AND DELETE MAILBOXES
	.IDENT	'V04-000'
 
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; D. N. CUTLER 1-OCT-76
;
; MODIFIED BY:
;
;	V03-018	RAS0327		Ron Schaefer		24-Jul-1984
;		Change $TRNLNM item list to use the retlen parameter,
;		and only check a word-sized length value.
;
;	V03-017	LMP0271		L. Mark Pilant,		29-Jun-1984  13:06
;		Disallow ACLs on shared memory mailboxes.
;
;	V03-016	LJK0285		Lawrence J. Kenah	29-May-1984
;		Check status returned by invocation of LOCK macro. Exit
;		with error if attempt to gain interlock fails.
;
;	V03-015	RNH0001		Richard N. Holstein	08-May-1984
;		Fix typo in CREATE_SHMUCB which omitted a register.
;
;	V03-014	TMK0001		Todd M. Katz		28-Apr-1984
;		Modify EXE$CREMBX to increase the size of the logical name
;		associated with a mailbox so that it can be full sized 
;		( i.e. - 0 < LOGNAM size =< LNM$C_NAMLENGTH ). This is
;		accomplished through use of a KRP. When a logical name is
;		specified, it is translated by the internal executive routine
;		MMG$MBXTRNLOG. The KRP is utilized as the buffer to contain the
;		translated logical name, or the specified logical name if
;		MMG$MBXTRNLOG was unable to translate it.
;
;	V03-013	MSH0029		Michael S. Harvey	9-Apr-1984
;		Eliminate security holes in temporary mailbox creation where
;		one without appropriate privilege could create system or
;		group wide logical names. This undoes RAS0185 below.
;
;	V03-012	LMP0221		L. Mark Pilant,		30-Mar-1984  16:07
;		Change UCB$L_OWNUIC to ORB$L_OWNER and UCB$W_VPROT to
;		ORB$W_PROT.
;
;	V03-011	ROW0240		Ralph O. Weber		11-OCT-1983
;		Correct calling sequence to IOC$CVT_DEVNAM in CREATE_LOGNAM to 
;		supply a R4, name-type, argument.  Use R4=-1 which produces 
;		the same format device name as the previous R4 contents, a PCB 
;		address, produced.  Also increase MBXNAMSIZ to accomodate 
;		possible cluster format device names.
;
;	V03-010	RAS0185		Ron Schaefer		 5-Sep-1983
;		For compatibility reasons, mailbox creation implies
;		logical name table privileges:  TMPMBX -> GRPNAM
;		and PRMMBX -> SYSNAM for creating the logical names.
;		So we do a $SETPRV as necessary to set/clear xNAM.
;		Add page-locking code to CREATE_LOGNAM subroutine.
;
;	V03-009	RAS0175		Ron Schaefer		 1-Aug-1983
;		Turn the "_" in the mailbox name into the proper
;		LNM$M_TERMINAL attribute.
;
;	V03-008	DMW4058		DMWalp			22-Jun-1983
;		Change $xxLNM value parameters to be by reference
;
;	V03-007	DMW4052		DMWalp			20-Jun-1983
;		Added LNM$_LNMB_ADDR in place of ^XFFFF
;		Replaced HALT with BUGCHECK
;		Replaced ENQ call with mutex
;
;	V03-006	DMW4031		DMWalp			26-May-1983
;		1st pass at intergating new logical name structures.
;
;	V03-005	ROW0180		Ralph O. Weber		13-APR-1983
;		Test for possibly zero UCB pointer in DDB in routine 
;		GET_SHMTEMPLATE.
;
;	V03-004	ROW0168		Ralph O. Weber		 3-MAR-1983
;		Change resource locking routine calls to G^ references.
;
;	V03-003	SRB0067		Steve Beckhardt		21-Feb-1983
;		Fixed branch displacement to eliminate truncation error.
;
;	V03-002	DMW4011		DMWalp			19-Nov-1982
;		Recode Logical Name Block to UCB ( or MTL ) pointer
;
;	V03-001	ROW0127		Ralph O. Weber		19-SEP-1982
;		Make changes required to use new UCB creation routines in 
;		UCBCREDEL.  Modify CHECK_QUOTA to use IOC$_CHKMBXQUOTA.
;		Modify CREATE_SHMUCB and CREATE_LOCALUCB to use appropriate
;
;		UCB creation routines.  Fix CREATE_SHMUCB to use elevated IPL 
;		one page locking technique.  Modify COMP_CHARGES to use 
;		IOC$DEBIT_UCB.  Add R4 to inputs lists for CREATE_SHMUCB 
;		and CREATE_LOCALUCB.
;
; SYSTEM SERVICES TO CREATE AND DELETE MAILBOXES
;-

	.SBTTL	DATA DECLARATIONS

;
; MACRO LIBRARY CALLS
;
 
	$ADPDEF				;DEFINE ADAPTER CONTROL BLOCK OFFSETS
	$CCBDEF				;DEFINE CCB OFFSETS
	$CRBDEF				;DEFINE CRB OFFSETS
	$DDBDEF				;DEFINE DDB OFFSETS
	$DEVDEF				;DEFINE DEVICE CHARACTERISTIC BITS
	$DYNDEF				;DEFINE DATA STRUCTURE TYPE CODES
	$IDBDEF				;DEFINE INTERRUPT DISPATCH BLOCK
	$IPLDEF				;DEFINE INTERRUPT PRIORITY LEVELS
	$JIBDEF				;DEFINE JIB OFFSETS
	$LCKDEF				;DEFINE LOCK MANAGER OFFSETS
	$LNMDEF				;DEFINE LNM OFFSETS
	$LNMSTRDEF			;DEFINE LNM STRUCTURE OFFSETS
	$MBXDEF				;DEFINE SHARED MEMORY MAILBOX
	$ORBDEF				;DEFINE OBJECT"S RIGHTS BLOCK OFFSETS
	$PCBDEF				;DEFINE PCB OFFSETS
	$PRDEF				;DEFINE PROCESSOR REGISTERS
	$PRVDEF				;DEFINE PRIVILEGE BITS
	$PSLDEF				;DEFINE PSL OFFSETS
	$SHBDEF				;DEFINE SHARED MEMORY CONTROL BLOCK
	$SHDDEF				;DEFINE SHARED MEMORY DATAPAGE
	$SSDEF				;DEFINE SYSTEM STATUS CODES
	$UCBDEF				;DEFINE UCB OFFSETS
	$VECDEF				;DEFINE INTERRUPT VECTOR OFFSETS
 
;
; LOCAL SYMBOLS
;
MBXNAMSIZ = 17				;MAXIMUM MAILBOX DEVICE NAME SIZE
					;  _NODENM$MBxnnnnn:

;
; ARGUMENT LIST OFFSET DEFINITIONS FOR CREATE MAILBOX
;
 
	$OFFSET	4,POSITIVE,<-
		PRMFLG,-		;MAILBOX CREATION TYPE INDICATOR
		CRCHAN,-		;ADDRESS TO STORE ASSIGNED CHANNEL
		MAXMSG,-		;MAXIMUM MAILBOX MESSAGE SIZE
		BUFQUO,-		;MAXIMUM BYTES FOR MESSAGE BUFFERING
		PROMSK,-		;PROTECTION MASK FOR CREATED MAILBOX
		ACMODE,-		;ACCESS MODE FOR CHANNEL ASSIGNMENT
		LOGNAM,-		;ADDRESS OF LOGICAL NAME STRING DESCRIPTOR
		>
 
;
; ARGUMENT LIST OFFSET DEFINITIONS FOR DELETE MAILBOX
;
	$OFFSET	4,POSITIVE,<-
		DLCHAN,-		;CHANNELT NUMBER OF SPECIFIED MAILBOX
		>
;
; STACK LOCAL STORAGE SYMBOLS
;
	$OFFSET	0,NEGATIVE,<-
		LOCKID,-		;LOCK IDENT
		LOCKSTATUS,-		;LOCK BLOCK STATUS 
		CHANADDR,-		;ADDRESS TO STORE CHANNEL NUMBER
		CCBADDR,-		;CCB ADDRESS FOR THAT CHANNEL
		CHANNUM,-		;ASSIGNED CHANNEL NUMBER
		SHBADDR,-		;SHARED MEMORY CONTROL BLOCK ADDR
		UCB_ADDRESS,-		;UCB ADDRESS, ACCESSED VIA AN ITEMLIST
		CRELNM_END_LIST,-	;END OF ITEM LIST
		I6_RET_LEN,-		;ITEM 6 RETURN LENGTH ADDRESS	{NORMAL 
		I6_BUF_ADDR,-		;ITEM 6 BUFFER ADDRESS		{TRANSLATION 
		I6_CODE_LEN,-		;ITEM 6 ITEM CODE & BUFFER LEN	{STRING
		I5_RET_LEN,-		;ITEM 5 RETURN LENGTH ADDRESS	{TRANSLATION 
		I5_BUF_ADDR,-		;ITEM 5 BUFFER ADDRESS		{TERMINAL 
		I5_CODE_LEN,-		;ITEM 5 ITEM CODE & BUFFER LEN	{ATTRIBUTE
		I4_RET_LEN,-		;ITEM 4 RETURN LENGTH ADDRESS	{TRANSLATION 
		I4_BUF_ADDR,-		;ITEM 4 BUFFER ADDRESS		{INDEX 
		I4_CODE_LEN,-		;ITEM 4 ITEM CODE & BUFFER LEN	{ #0
		I3_RET_LEN,-		;ITEM 3 RETURN LENGTH ADDRESS	{BACKPTR 
		I3_BUF_ADDR,-		;ITEM 3 BUFFER ADDRESS		{TO UCB
		I3_CODE_LEN,-		;ITEM 3 ITEM CODE & BUFFER LEN	{
		I2_RET_LEN,-		;ITEM 2 RETURN LENGTH ADDRESS	{BACKPTR 
		I2_BUF_ADDR,-		;ITEM 2 BUFFER ADDRESS		{TO UCB 
		I2_CODE_LEN,-		;ITEM 2 ITEM CODE & BUFFER LEN	{INDEX
		I1_RET_LEN,-		;ITEM 1 RETURN LENGTH ADDRESS	{UCB TO 
		I1_BUF_ADDR,-		;ITEM 1 BUFFER ADDRESS		{LNMB 
		I1_CODE_LEN,-		;ITEM 1 ITEM CODE & BUFFER LEN	{PTR
		KRP,-			;ADDRESS OF ALLOCATED KRP
		LOCALSIZ,-		; SIZE OF LOCAL STORAGE
		>

;
; REDEFINE LOCAL STORAGE ITEM LIST FOR $TRNLNM AND $CRELNM
;
ZERO_INDEX	= CCBADDR
TRNLNM_END_LIST = I3_CODE_LEN
UCB_ADDR_SIZE	= I3_BUF_ADDR

;
; LOCAL DATA CONSTANTS
;

	.PSECT	Y$EXEPAGED

;
; BACK POINTER INDEX VALUE
;
BACKPTR_INDEX:
	.LONG	 LNMX$C_BACKPTR

;
; TERMINAL LOGICAL NAME ATTRIBUTE
;
LNM_TERM_ATTR:
	.LONG	LNM$M_TERMINAL

;
; Pointers to mailbox table names descriptors
;
MAILBOX_TABLES:
	.ADDRESS 10$
	.ADDRESS 20$
10$:	.ASCID	 "LNM$TEMPORARY_MAILBOX"
20$:	.ASCID	 "LNM$PERMANENT_MAILBOX"

	.PAGE
	.SBTTL	EXE$CREMBX - CREATE MAILBOX
;+
; EXE$CREMBX - CREATE MAILBOX
;
; THIS SERVICE PROVIDES THE CAPABILITY TO CREATE A VIRTUAL MAILBOX DEVICE
; AND ASSIGN AN I/O CHANNEL TO IT.
;
; INPUTS:
;
;	PRMFLG(AP) = MAILBOX CREATION TYPE INDICATOR.
;		LOW BIT CLEAR INDICATES TEMPORARY MAILBOX.
;		LOW BIT SET INDICATES PERMANENT MAILBOX.
;	CRCHAN(AP) = ADDRESS TO STORE ASSIGNED CHANNEL NUMBER.
;	MAXMSG(AP) = MAXIMUM MAILBOX MESSAGE SIZE.
;	BUFQUO(AP) = MAXIMUM BYTES FOR MESSAGE BUFFERING.
;	PROMSK(AP) = PROTECTION MASK FOR CREATED MAILBOX.
;	ACMODE(AP) = ACCESS MODE CHANNEL IS TO BE ASSIGNED TO.
;	LOGNAM(AP) = ADDRESS OF LOGICAL NAME STRING DESCRIPTOR.
;
;	R4 = CURRENT PROCESS PCB ADDRESS.
;
; OUTPUTS:
;
;	R0 LOW BIT CLEAR INDICATES FAILURE TO CREATE MAILBOX.
;
;		R0 = SS$_ACCVIO - LOGICAL NAME STRING OR LOGICAL NAME STRING
;			DESCRIPTOR CANNOT BE READ BY CALLING ACCESS MODE,
;			OR CHANNEL NUMBER CANNOT BE WRITTEN BY CALLING
;			ACCESS MODE.
;
;		R0 = SS$_BADPARAM - BUFQUO exceeds 65535 minus the size of a 
;			mailbox UCB (approximately 65355).
;
;		R0 = SS$_EXBYTLM - Process has insufficient buffer I/O byte 
;			count quota to allocate mailbox UCB or satisfy buffer 
;			requirements.
;
;		R0 = SS$_INSFMEM - SUFFICIENT SYSTEM DYNAMIC MEMORY DOES NOT
;			EXIST TO ALLOCATE MAILBOX UCB.
;
;		R0 = SS$_IVLOGNAM - GREATER THAN MAXIMUM LENGTH LOGICAL
;			NAME STRING SPECIFIED.
;
;		R0 = SS$_NOIOCHAN - NO I/O CHANNEL IS AVAILABLE FOR ASSIGNMENT.
;
;		R0 = SS$_NOPRIV - PROCESS DOES NOT HAVE PRIVILEGE TO CREATE
;			SPECIFIED TYPE OF MAILBOX.
;
;		R0 = SS$_INTERLOCK - UNABLE TO OBTAIN MAILBOX TABLE INTERLOCK.
;
;		R0 = SS$_EXPORTQUOTA - PORT'S MAILBOX CREATION QUOTA EXCEEDED.
;
;		R0 = SS$_NOSHMBLOCK - NO SHARED MEMORY MAILBOX TABLE BLOCKS
;			ARE AVAILABLE.
;
;		R0 = SS$_OPINCOMPL - Duplicate unit number encountered while 
;			linking shared memory mailbox UCB.  (This should never 
;			happen.  Submit an SPR if it does.)
;
;	R0 LOW BIT SET INDICATES SUCCESSFUL COMPLETION.
;
;		R0 = SS$_NORMAL - NORMAL COMPLETION., IF LOGICAL NAME SPECIFIED,
;			NEW ENTRY DID NOT SUPERSEDE PREVIOUS ENTRY.
;
;		R0 = SS$_SUPERSEDE - NORMAL COMPLETION, NEW ENTRY SUPERSEDED
;			PREVIOUS ENTRY IN SPECIFIED LOGIC
;-
 
BAD_LOGNAM:
	MOVZWL	#SS$_IVLOGNAM,R0	;INVALID LOGICAL NAME
EXIT:	MOVL	KRP(FP),R7		;RETRIEVE ADDRESS OF ALLOCATED KRP
	BEQL	10$			;IMMEDIATELY RETURN IF NO KRP ALLOCATED
	MOVAB	G^CTL$GL_KRPFL,R6	;ELSE RETRIEVE ADDRESS OF KRP LISTHEAD
	INSQUE	(R7),@4(R6)		;AND DEALLOCATE KRP TO LOOKASIDE LIST
10$:	RET				;EXIT SYSTEM SERVICE

	.ENTRY	EXE$CREMBX,^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	MOVAB	LOCALSIZ(SP),SP		;ALLOCATE LOCAL STORAGE
	CLRL	KRP(FP)			;NO KRP ALLOCATED
	MOVZWL	S^#SS$_ACCVIO,R0	;ASSUME ACCESS VIOLATION
	MOVL	CRCHAN(AP),R6		;GET ADDRESS TO STORE CHANNEL NUMBER
	IFNOWRT	#2,(R6),EXIT		;CAN CHANNEL NUMBER BE WRITTEN?
	MOVL	R6,CHANADDR(FP)		;SAVE ADDRESS TO STORE CHANNEL NUMBER
	CLRW	(R6)			;CLEAR CHANNEL NUMBER IN CASE OF ERROR
;
; GET AND TRANSLATE SPECIFIED LOGICAL NAME (IF ANY)
;
	MOVL	LOGNAM(AP),R11		;GET ADDRESS OF LOGICAL NAME STRING DESCRIPTOR
	BEQL	20$			;IF EQL NO LOGICAL NAME SPECIFIED
	IFNORD	#8,(R11),EXIT		;CAN LOGICAL NAME STRING DESCRIPTOR BE READ?
	MOVQ	(R11),-(SP)		;MOVE DESCRIPTOR TO KERNEL STACK
	MOVL	SP,R9			;GET ADDRESS OF DESCRIPTOR
	MOVL	4(R9),R10		;GET ADDRESS OF LOGICAL NAME STRING
	MOVZWL	(R9),R11		;GET LENGTH OF STRING IN BYTES
	BEQL	BAD_LOGNAM		;IF EQL STRING HAS ZERO LENGTH
	ASSUME  LNM$C_NAMLENGTH LE 512
	CMPW	R11,#LNM$C_NAMLENGTH	;LOGICAL NAME TOO LARGE?
	BGTRU	BAD_LOGNAM		;IF GTRU YES
	IFNORD	R11,(R10),EXIT		;CAN ENTIRE LOGICAL NAME STRING BE READ?

	MOVAB	-SHD$C_NAMLENGTH(SP),SP	;CREATE MEMORY NAME BUFFER
	PUSHL	SP			;CREATE BUFFER DESCRIPTOR
	PUSHL	#SHD$C_NAMLENGTH-1	;...
	MOVL	SP,R10			;GET ADDRESS OF DESCRIPTOR

	MOVAB	G^CTL$GL_KRPFL,R6	;RETRIEVE ADDRESS OF KRP QUEUE LISTHEAD
	REMQUE	@4(R6),R7		;RETRIEVE KRP FROM LOOKASIDE LIST
	BVC	10$			;CONTINUE IF GOT ONE
	BUG_CHECK	KRPEMPTY,FATAL	;OTHERWISE BUGCHECK

10$:	MOVL	R7,KRP(FP)		;SAVE ADDRESS OF KRP IN LOCAL STORAGE
	PUSHL	R7			;CREATE BUFFER DESCRIPTOR
	PUSHL	#LNM$C_NAMLENGTH	;...
	MOVL	SP,R11			;GET ADDRESS OF DESCRIPTOR
	BSBW	MMG$MBXTRNLOG		;TRANSLATE THE LOGICAL NAME
	BLBS	R0,20$			;IF LBC FAILURE
	BRW	EXIT

;
; GET A FREE CHANNEL AND CHECK PRIVILEGES
;

20$:	SETIPL	#IPL$_ASTDEL		;BLOCK AST DELIVERY
	BSBW	IOC$FFCHAN		;FIND A FREE CHANNEL
	BLBC	R0,TO_EXIT_LOWER_IPL	;IF LBC ERROR
	ASSUME	CHANNUM+4 EQ CCBADDR
	MOVQ	R1,CHANNUM(FP)		;SAVE CHANNEL NUMBER AND CCBADDR
	MOVL	PRMFLG(AP),R9		;GET FLAGS ARGUMENT
	MOVZWL	#SS$_IVSTSFLG,R0	;ASSUME BAD FLAGS SET
	BITL	#^C<1>,R9		;ANY BITS BUT DEFINED BITS SET?
	BNEQ	TO_EXIT_LOWER_IPL	;IF NEQ YES
	MOVZWL	#SS$_NOPRIV,R0		;ASSUME PROCESS DOES NOT HAVE PRIVILEGE
	IFPRIV	PRMMBX,DISPATCH		;CAN PROCESS CREATE PERMANENT MAILBOX?
	BLBS	R9,TO_EXIT_LOWER_IPL	;IF LBS NEEDS PRMMBX PRIVILEGE
	IFPRIV	TMPMBX,DISPATCH		;CAN PROCESS CREATE TEMPORARY MAILBOX?
TO_EXIT_LOWER_IPL:
	BRW	EXIT_LOWER_IPL

;
; DISPATCH TO APPROPRIATE TYPE MAILBOX CREATION ROUTINE
;
DISPATCH:
	JSB	G^SCH$IOLOCKW		;LOCK I/O DATABASE FOR WRITE
	TSTL	R11			;LOGICAL NAME SPECIFIED?
	BEQL	NONAME			;IF EQL NO - UNNAMED LOCAL MAILBOX
	TSTW	(R10)			;MEMORY NAME SPECIFIED?
	BNEQ	SHAREDMEM		;IF NEQ YES - SHARED MEMORY MAILBOX

;
; CREATE NAMED LOCAL MEMORY MAILBOX
;
NAMEDLOCAL:
	MOVAB	MB$UCB0,R5		;GET ADDRESS OF TEMPLATE UCB
	BSBW	SEARCH_MBXUCB		;CHECK IF MAILBOX EXISTS
	TSTL	R6			;MAILBOX FOUND?
	BNEQ	ASSIGN_IT		;IF NEQ YES
	BSBW	CHECK_QUOTA		;CHECK BYTE COUNT QUOTA
	BLBC	R0,EXIT_UNLOCKIODB	;IF LBC INSUFFICIENT QUOTA
	BSBW	CREATE_LOCALUCB		;CREATE LOCAL MEMORY UCB
	BLBC	R0,EXIT_UNLOCKIODB	;IF LBC FAILURE
	BSBW	ASSIGN			;ASSIGN CHANNEL
	BSBW	CREATE_LOGNAM		;CREATE LOGICAL NAME
	BLBC	R0,EXIT_DEASSIGN	;IF LBC DEASSIGN CHANNEL AND UCB
	MOVZWL	#SS$_NORMAL,R0		;SET FINAL STATUS
	BRB	EXIT_UNLOCKIODB		;RELEASE CREATE MAILBOX LOCK AND EXIT

;
; CREATE UNNAMED LOCAL MEMORY MAILBOX
;
NONAME:					;CREATE UNNAMED MAILBOX
	MOVAB	MB$UCB0,R5		;GET ADDRESS OF TEMPLATE UCB
	BSBW	CHECK_QUOTA		;CHECK BYTE COUNT QUOTA
	BLBC	R0,EXIT_UNLOCKIODB	;IF LBC INSUFFICIENT QUOTA
	BSBW	CREATE_LOCALUCB		;CREATE A LOCAL MAILBOX UCB
	BLBC	R0,EXIT_UNLOCKIODB	;IF LBC FAILURE
	CLRL	UCB$L_LOGADR(R6)	;SET NO NAME FOR MAILBOX
ASSIGN_IT:				;
	BSBW	ASSIGN			;ASSIGN CHANNEL AND EXIT
	MOVZWL	#SS$_NORMAL,R0		;SET FINAL STATUS
	BRB	EXIT_UNLOCKIODB		;RELEASE CREATE MAILBOX LOCK AND EXIT

;
; CREATE SHARED MEMORY MAILBOX
;
SHAREDMEM:
	MOVZWL	S^#SS$_NOPRIV,R0	;ASSUME NO PRIVILEGE
	IFNPRIV	SHMEM,EXIT_UNLOCKIODB	;PROCESS CREATE SHARED MEMORY OBJECTS?
	BSBW	GET_SHMTEMPLATE		;GET ADDRESS OF TEMPLATE UCB
	BLBC	R0,EXIT_UNLOCKIODB	;IF LBC FAILURE
	BSBW	SEARCH_MBXUCB		;CHECK IF MAILBOX EXISTS
	TSTL	R6			;MAILBOX FOUND?
	BNEQ	ASSIGN_IT		;IF NEQ YES
	BSBW	CHECK_QUOTA		;CHECK BYTE COUNT QUOTA
	BLBC	R0,EXIT_UNLOCKIODB	;IF LBC FAILURE
	BSBW	SEARCH_SHMMBX		;SEARCH SHARED MEMORY FOR MAILBOX
					; AND CREATE IT IF NOT FOUND
	BLBC	R0,EXIT_UNLOCKIODB	;IF LBC FAILURE
	BSBW	CREATE_SHMUCB		;CREATE SHARED MEMORY UCB
	BLBC	R0,EXIT_CLEAR_FLAGS	;IF LBC FAILURE
	BSBW	ASSIGN			;ASSIGN CHANNEL
	BSBW	CREATE_LOGNAM		;CREATE LOGICAL NAME
	BLBC	R0,EXIT_DEASSIGN	;IF LBC DEASSIGN CHANNEL AND UCB
	MOVZWL	#SS$_NORMAL,R0		;SET FINAL STATUS
	BRB	EXIT_UNLOCKIODB		;RELEASE CREATE MAILBOX LOCK AND EXIT

EXIT_CLEAR_FLAGS:
	CLRB	MBX$B_FLAGS(R7)		;CATASTROPHIC ERROR - CLEAR ALL FLAGS
EXIT_UNLOCKIODB:			;EXIT, UNLOCKING I/O DATABASE
	PUSHL	R0			;SAVE STATUS
	MOVL	G^CTL$GL_PCB,R4		;LOAD PCB INTO R4 FOR CALL
	JSB	G^SCH$IOUNLOCK		;UNLOCK IO DATA BASE
	POPL	R0			;RESTORE STATUS
EXIT_LOWER_IPL:				;EXIT, UNLOCKING WITH STATUS IN R0
	SETIPL	#0			;RESTORE IPL IF NEEDED
	BRB	RETURN			;GO EXIT SYSTEM SERVICE

EXIT_DEASSIGN:
	PUSHL	R0			;SAVE SYSTEM SERVICE STATUS
	MOVL	G^CTL$GL_PCB,R4		;LOAD PCB INTO R4 FOR CALL
	JSB	G^SCH$IOUNLOCK		;UNLOCK IO DATA BASE
	SETIPL	#0			;RESTORE IPL IF NEEDED
	BLBC	R9, 10$			;TEMP MAILBOX DO NOT DELETE
	$DELMBX_S -			;MARK PERMANENT MAILBOX FOR DELETE
		CHAN  = CHANNUM(FP)	;
	BLBC	R0,BUGCHECK		;SHOULD ALWAYS BE ABLE TO DELETE
10$:	$DASSGN_S -			;DELETE ASSIGNED CHANNEL, MAILBOX
		CHAN  = CHANNUM(FP)	; AND UCB
	BLBC	R0,BUGCHECK		;SHOULD ALWAYS BE ABLE TO DEASSIGN
	POPL	R0			;RESTORE STATUS

RETURN:	MOVL	KRP(FP),R7		;RETRIEVE ADDRESS OF ALLOCATED KRP
	BEQL	10$			;IMMEDIATELY RETURN IF NO KRP ALLOCATED
	MOVAB	G^CTL$GL_KRPFL,R6	;ELSE RETRIEVE ADDRESS OF KRP LISTHEAD
	INSQUE	(R7),@4(R6)		;AND DEALLOCATE KRP TO LOOKASIDE LIST
10$:	RET				;EXIT SYSTEM SERVICE

BUGCHECK:
	BUG_CHECK SSRVEXCEPT,FATAL

	.PAGE
	.SBTTL	CHECK_QUOTA - CHECK BUFFER I/O BYTE COUNT QUOTA
;++
; THIS ROUTINE IS CALLED TO CHECK IF PROCESS HAS ENOUGH BUFFER I/O
; BYTE COUNT QUOTA FOR TEMPORARY MAILBOX UCB AND MESSAGES.
;
; INPUTS:
;
;	BUFQUO(AP) = SPECIFIED MAILBOX BUFFER QUOTA FOR MESSAGES.
;	R4 = CURRENT PROCESS PCB ADDRESS
;	R9 = 0 IF TEMPORARY MAILBOX.
;	   = 1 IF PERMANENT MAILBOX.
;
; OUTPUTS:
;
;	R0 = SUCCESS OR FAILURE.
;	R8 = BYTE COUNT QUOTA FOR MESSAGES.
;--
CHECK_QUOTA:				;CHECK BUFFER QUOTA
	MOVZWL	S^#SS$_NORMAL,R0	;ASSUME SUCCESS
	MOVZWL	BUFQUO(AP),R8		;GET SPECIFIED BUFFER QUOTA
	BNEQ	10$			;IF NEQ BUFER QUOTA SPECIFIED
	MOVZWL	IOC$GW_MBXBFQUO,R8	;GET DEFAULT BUFFER QUOTA
10$:	BLBS	R9, 30$			; Branch if permanent mailbox.
	BSBW	IOC$CHKMBXQUOTA		; Check for enough BYTCNT quota.
30$:	RSB				; Return to caller.

	.PAGE
	.SBTTL	CREATE_LOCALUCB - CREATE LOCAL MEMORY MAILBOX UCB
;++
; THIS ROUTINE IS CALLED TO CREATE A UCB FOR A LOCAL MEMORY MAILBOX.
;
; INPUTS:
;
;	R4 = CURRENT PROCESS PCB ADDRESS
;	R5 = ADDRESS OF TEMPLATE MAILBOX UCB.
;	R8 = BYTE COUNT QUOTA FOR MESSAGES.
;
; OUTPUTS:
;
;	R0 = SUCCESS OR FAILURE.
;	R6 = ADDRESS OF CREATED UCB.
;--
	.ENABL	LSB
CREATE_LOCALUCB:			;CREATE LOCAL MEMORY MAILBOX UCB
	BSBW	IOC$CLONE_UCB		;CLONE MAILBOX UCB
	BLBC	R0,20$			;IF LBC ALLOCATION FAILURE
	MOVL	R2,R6			;SAVE ADDRESS OF ALLOCATED UCB
	MOVW	R8,UCB$W_BUFQUO(R6)	;SET BUFFER QUOTA
	CLRL	UCB$L_PID(R6)		;CLEAR OWNER PID
	MOVL	UCB$L_ORB(R6),R0	;GET ORB ADDRESS
	BISB2	#ORB$M_PROT_16,ORB$B_FLAGS(R0)	;USE SOGW PROTECTION WORD
	MOVW	PROMSK(AP),ORB$W_PROT(R0) ;SET PROTECTION MASK
	MOVL	PCB$L_UIC(R4), ORB$L_OWNER(R0) ;Establish owner UIC.
	MOVW	MAXMSG(AP),UCB$W_DEVBUFSIZ(R6) ;SET MAXIMUM MESSAGE SIZE
	BNEQ	COMP_CHARGES		;IF NEQ MESSAGE SIZE SPECIFIED
	MOVW	IOC$GW_MBXMXMSG,UCB$W_DEVBUFSIZ(R6) ;SET DEFAULT MAXIMUM SIZE
;
; COMPUTE BYTE COUNT CHARGES
;
COMP_CHARGES:
	CLRL	UCB$L_DEVDEPEND(R6)	;INIT USER VISABLE CURRENT MESSAGE COUNT
	ADDW3	R8, UCB$W_SIZE(R6), -	;Compute byte count charge for
		UCB$W_CHARGE(R6)	;this UCB.
	BLBC	R9, 10$			;Branch if temporary mailbox.
	BBCS	#UCB$V_PRMMBX, -	;Mark mailbox permanent and
		UCB$W_DEVSTS(R6), 19$	;skip temporary mailbox stuff.
10$:	BISW	#UCB$M_DELMBX, -	;Mark mailbox temporary (deletable).
		UCB$W_DEVSTS(R6) 
	BSBW	IOC$DEBIT_UCB		;Charge byte count quota for UCB, etc.
19$:	MOVZWL	#SS$_NORMAL, R0		;Set operation completed successfully.
20$:	RSB				;Return to caller.
	.DSABL	LSB

	.PAGE
	.SBTTL	ASSIGN - ASSIGN CHANNEL TO MAILBOX
;++
; THIS ROUTINE IS CALLED TO ASSIGN A CHANNEL TO THE MAILBOX
;
; INPUTS:
;
;	CHANADDR(FP) = ADDRESS TO STORE CHANNEL NUMBER.
;	CHANNUM(FP) = CHANNEL NUMBER.
;	CCBADDR(FP) = ADDRESS OF CCB FOR CHANNEL NUMBER.
;	R6 = ADDRESS OF UCB
;
; OUTPUTS:
;
;	CHANNEL NUMBER STORED AT CALLER'S ADDRESS.
;	I/O DATABASE UNLOCKED AND IPL SET TO 0
;--
ASSIGN:					;ASSIGN CHANNEL
	ASSUME	CHANNUM+4 EQ CCBADDR
	ASSUME	CCBADDR+4 EQ CHANADDR
	PUSHL	R11			;SAVE ADDRESS OF LOGNAME DESCRIPTOR
	MOVQ	CCBADDR(FP),R10		;RETRIEVE CCB AND CHANNEL ADDRESSES
	MOVW	CHANNUM(FP),(R11)	;STORE CHANNEL NUMBER
	MOVL	R6,CCB$L_UCB(R10)	;STORE UCB ADDRESS IN CCB
	EXTZV	#0,#2,ACMODE(AP),R0	;GET SPECIFIED ACCESS MODE
	BSBW	EXE$MAXACMODE		;MAXIMIZE ACCESS MODE
	ADDB3	#1,R0,CCB$B_AMOD(R10)	;STORE ASSIGN ACCESS MODE
	MOVL	G^CTL$GL_PCB,R4		;LOAD PCB INTO R4 FOR CALL
	POPL	R11			;RESTORE ADDRESS OF LOGNAME DESCRIPTOR
	RSB

	.PAGE
	.SBTTL	SEARCH_MBXUCB - SEARCH FOR SPECIFIED MAILBOX UCB
;++
; THIS ROUTINE IS CALLED TO SEARCH FOR THE SPECIFIED MAILBOX UCB.
; IF IT IS FOUND, THE MAILBOX ALREADY EXISTS AND THE UCB ADDRESS IS
; RETURNED.  IF IT IS NOT FOUND, THE MAILBOX MUST BE CREATED.
;
; INPUTS:
;
;	R9 = 0 IF MAILBOX IS TEMPORARY
;	     1 IF MAILBOX IS PERMANENT
;	R11 = ADDRESS OF MAILBOX NAME DESCRIPTOR
;
; OUTPUTS:
;
;	IF MAILBOX UCB FOUND.
;		R6 = ADDRESS OF MAILBOX UCB.
;
;	IF MAILBOX UCB NOT FOUND.
;		R6 = 0
;		
;--
SEARCH_MBXUCB:				;SEARCH FOR MAILBOX UCB

	; SET UP THE TRANSLATION INDEX TO BE THE BACK POINTER
	;
	MOVL	#LNM$_INDEX@16!4,I1_CODE_LEN(FP)
	MOVAL	BACKPTR_INDEX,I1_BUF_ADDR(FP)
	CLRL	I1_RET_LEN(FP)

	; GET THE TRANSLATION STRING AND SIZE ( OR HOPEFULLY THE UCB MAILBOX )
	;
	MOVL	#LNM$_STRING@16!4,I2_CODE_LEN(FP)
	MOVAL	UCB_ADDRESS(FP),I2_BUF_ADDR(FP)
	MOVAL	UCB_ADDR_SIZE(FP),I2_RET_LEN(FP)

	CLRL	TRNLNM_END_LIST(FP)	;END ITEM LIST

	EXTZV   #0,#2,ACMODE(AP),R0	;EXTRACT SPECIFIED MODE
	BSBW	EXE$MAXACMODE		;MAXIMIZE ACCESS MODE
	PUSHL	R0			;SAVE IT FOR REFERENCE
	MOVL	SP,R0			;SAVE POINTER TO ACCESS MODE
	MOVL	MAILBOX_TABLES[R9],R1	;CALCULATE TABLE

	$TRNLNM_S -				;SEE IF THE MAILBOX EXIST
		TABNAM = (R1),-			;USE THE CORRECT TABLE
		LOGNAM = (R11),-		;POINT TO DESCRIPTOR
		ACMODE = (R0),-			;PREVIOUS ACCESS MODES
		ITMLST = I1_CODE_LEN(FP)	;ITEM LIST

	ADDL2	#4,SP			;POP ACCESS MODE
	BLBC	R0,20$			;IF ERROR NO TRANSLATION
	CMPW	S^#4,UCB_ADDR_SIZE(FP)  ;TEST IF IT IS THE CORRECT SIZE
	BNEQ	20$			;CAN NOT BE POINTER, SHOULD NOT HAPPEN
	MOVL	UCB_ADDRESS(FP),R6	;LOAD THE ?UCB ADDRESS INTO R6
	MOVAL	-UCB$L_LOGADR(R6),R6	;POINT TO THE BEGINNING OF ?UCB
	CMPB	#DYN$C_UCB,UCB$B_TYPE(R6);CHECK TO SEE WHERE THE POINTER POINTS
	BNEQ	20$			;CHECK FAILED ( MUST BE MTL )
	INCW	UCB$W_REFC(R6)		;INCREMENT REFERENCE COUNT
	RSB				;RETURN
20$:	CLRL	R6			;NO UCB FOUND
	RSB				;RETURN

	.PAGE
	.SBTTL	CREATE_LOGNAM - CREATE LOGICAL NAME
;++
; THIS ROUTINE IS CALLED TO FILL-IN THE ALLOCATED LOGICAL NAME BLOCK
; AND INSERT IT INTO THE APPROPRIATE LOGICAL NAME TABLE.
;
; INPUTS:
;
;	R6 = ADDRESS OF MAILBOX UCB.
;	R9 = 0 IF TMPMBX, 1 IF PRMMBX.
;	R11 = ADDRESS OF LOGICAL NAME DESCRIPTOR.
;
; OUTPUTS:
;
;	R0 = INSERTION STATUS.
;
;	R1, R2, R4, and R5 are corrupted.
;
;--
CREATE_LOGNAM:				;CREATE LOGICAL NAME

	; STORE INFORMATION SO IT IS ACCESSABLE FROM ITEM LIST
	;
	MOVAL	UCB$L_LOGADR(R6),UCB_ADDRESS(FP)
					;MOVE ADDR OF UCB TO LOCAL STORAGE
	CLRL	ZERO_INDEX(FP)		;MOVE ZERO INDEX TO LOCAL STORAGE
	MOVAL	-MBXNAMSIZ(SP),SP	;STORAGE FOR EQUIVALENCE NAME
	MOVAL	(SP),I6_BUF_ADDR(FP)	;SAVE THE POINTER TO THE BUFFER
	MOVL	R6,R5			;MOVE UCB ADDRESS TO R5 FOR SUB-CALL
	DSBINT	100$			;LOCK THIS CODE FOR HIGH IPL EXECUTION.
	MOVL	I6_BUF_ADDR(FP),R1	;LOCATION OF OUTPUT BUFFER
	MOVL	#MBXNAMSIZ,R0		;SIZE OF OUTPUT BUFFER
	MNEGL	#1,R4			;SET FOR DISPLAY FORMAT DEVICE NAME
	BSBW	IOC$CVT_DEVNAM		;CONVERT UCB TO DEVICE NAME STRING
	MOVZBL  R1,I6_CODE_LEN(FP)	;SAVE SIZE OF OUTPUT BUFFER
	ENBINT				;RETURN OLD IPL

	; STUFF THE LOGICAL NAME BLOCK ADDRESS IN THE UCB
	;
	MOVL	#LNM$_LNMB_ADDR@16!4,I1_CODE_LEN(FP)
	MOVAL	UCB$L_LOGADR(R6),I1_BUF_ADDR(FP)
	CLRL	I1_RET_LEN(FP)

	; SET UP THE BACK POINTER TO THE UCB FROM THE LOGICAL NAME BLOCK
	;
	MOVL	#LNM$_INDEX@16!4,I2_CODE_LEN(FP)
	MOVAL	BACKPTR_INDEX,I2_BUF_ADDR(FP)
	CLRL	I2_RET_LEN(FP)
	MOVL	#LNM$_STRING@16!4,I3_CODE_LEN(FP)
	MOVAL	UCB_ADDRESS(FP),I3_BUF_ADDR(FP)
	CLRL	I3_RET_LEN(FP)

	; SET UP NORMAL EQUIVALENCE STRING
	;
	MOVL	#LNM$_INDEX@16!4,I4_CODE_LEN(FP)
	MOVAL	ZERO_INDEX(FP),I4_BUF_ADDR(FP)
	CLRL	I4_RET_LEN(FP)
	MOVL	#LNM$_ATTRIBUTES@16!4,I5_CODE_LEN(FP)
	MOVAL	LNM_TERM_ATTR,I5_BUF_ADDR(FP)
	CLRL	I5_RET_LEN(FP)
	DECW	I6_CODE_LEN(FP)		;REMOVE LEADING "_" FROM COUNT
	MOVW	#LNM$_STRING,I6_CODE_LEN+2(FP)
	INCL	I6_BUF_ADDR(FP)		;REMOVE LEADING "_" FROM STRING
	CLRL	I6_RET_LEN(FP)
	
	CLRL	CRELNM_END_LIST(FP)	;END ITEM LIST

	EXTZV   #0,#2,ACMODE(AP),R0	;EXTRACT SPECIFIED MODE
	BSBW	EXE$MAXACMODE		;MAXIMIZE ACCESS MODE
	PUSHL	R0			;SAVE IT FOR REFERENCE

	MOVAL	(SP),R0			;POINTER TO ACCESS MODE
	MOVL	MAILBOX_TABLES[R9],R1	;CALCULATE TABLE

	$CRELNM_S -
		TABNAM	= (R1),-
		LOGNAM	= (R11),-
		ACMODE  = (R0),-
		ITMLST  = I1_CODE_LEN(FP)

	MOVAL	MBXNAMSIZ+4(SP),SP	;RETURN STORAGE OF EQUIVALENCE NAME

	RSB
100$:					;IPL TO LOCK PREVIOUS CODE IN MEMORY
	.LONG	IPL$_SYNCH
	ASSUME	<.-CREATE_LOGNAM> LE 512 ;CAN ONLY LOCK 1 PAGE

	.PAGE
	.SBTTL	GET_SHMTEMPLATE - GET SHARED MEMORY MAILBOX TEMPLATE UCB
;++
;
; THIS ROUTINE IS CALLED TO GET THE ADDRESS OF THE "TEMPLATE" MAILBOX
; UCB FOR A SPECIFIED SHARED MEMORY.
;
; INPUTS:
;
;	R10 = ADDRESS OF SHARED MEMORY NAME DESCRIPTOR.
;
; OUTPUTS:
;
;	R0 = SUCCESS OR FAILURE.
;	R5 = ADDRESS OF TEMPLATE MAILBOX UCB.
;	SHBADDR(FP) = ADDRESS OF SHB.
;--
GET_SHMTEMPLATE:			;GET ADDRESS OF TEMPLATE UCB
	MOVAL	EXE$GL_SHBLIST,R6	;GET ADDRESS OF SHARED MEMORY LISTHEAD
10$:
	ASSUME	SHB$L_LINK EQ 0
	MOVL	SHB$L_LINK(R6),R6	;GET ADDRESS OF NEXT SHB
	BEQL	40$			;IF EQL NO SUCH MEMORY
	MOVL	SHB$L_DATAPAGE(R6),R5	;GET ADDRESS OF DATAPAGE
	CMPC5	(R10),@4(R10),#0,-	;NAMES MATCH?
		#SHD$C_NAMLENGTH-1,SHD$T_NAME+1(R5)
	BNEQ	10$			;IF NEQ NO
	BBC	#SHB$V_CONNECT,SHB$B_FLAGS(R6),40$ ;BR IF NOT CONNECTED
	MOVAL	IOC$GL_DEVLIST,R0	;GET ADDRESS OF DDB LISTHEAD
20$:
	ASSUME	DDB$L_LINK EQ 0
	MOVL	DDB$L_LINK(R0),R0	;GET ADDRESS OF NEXT DDB
	BEQL	40$			;IF EQL NOT FOUND
	MOVL	DDB$L_UCB(R0),R5	;GET ADDRESS OF UCB
	BEQL	20$			;BRANCH IF NO UCB ADDRESS HERE
	BBC	#DEV$V_MBX,UCB$L_DEVCHAR(R5),20$ ;IF CLR NOT MAILBOX
	BBC	#UCB$V_SHMMBX,UCB$W_DEVSTS(R5),20$ ;IF CLR NOT SHARED MEM MAILBOX
	MOVL	UCB$L_CRB(R5),R1	;GET CRB ADDRESS
	MOVL	CRB$L_INTD+VEC$L_ADP(R1),R1 ;GET ADAPTER CONTROL BLOCK ADDRESS
	CMPL	ADP$L_SHB(R1),R6	;SHARED MEMORY BLOCK ADDRESS MATCH?
	BNEQ	20$			;IF NEQ NO - WRONG MEMORY
	MOVL	R6,SHBADDR(FP)		;SAVE SHB ADDRESS
	MOVL	#1,R0			;SET SUCCESS
	RSB				;
40$:
	MOVZWL	#SS$_SHMNOTCNCT,R0	;SET MEMORY NOT CONNECTED
	RSB				;

	.PAGE
	.SBTTL	SEARCH_SHMMBX - SEARCH FOR SHARED MEMORY MAILBOX
;++
; THIS ROUTINE IS CALLED TO SEARCH THE SPECIFIED SHARED MEMORY MAILBOX
; TABLE TO SEE IF THE SPECIFIED MAILBOX ALREADY EXISTS.
;
; INPUTS:
;
;	R11 = ADDRESS OF MAILBOX NAME DESCRIPTOR.
;	SHBADDR(FP) = ADDRESS OF SHARED MEMORY CONTROL BLOCK.
;
; OUTPUTS:
;
;	R0 = SUCCESS IF FOUND
;
;		R7 = ADDRESS OF MAILBOX CONTROL BLOCK.
;
;		EXITS TO UNLOCK_SHMMBX.
;
;	ELSE, NOT FOUND AND
;
;		R7 = ADDRESS OF FIRST UNALLOCATED MAILBOX BLOCK.
;
;		EXITS TO CREATE_SHMMBX
;
;	R6 = ADDRESS OF SHARED MEMORY CONTROL BLOCK.
;
;	MAILBOX TABLE MUTEX OWNED, MAILBOX TABLE LOCK OWNED, IPL = 31.
;--
SEARCH_SHMMBX:				;SEARCH SHARED MEMORY MAILBOXES
	MOVAL	EXE$GL_SHMMBMTX,R0	;GET ADDRESS OF MAILBOX MUTEX
	JSB	G^SCH$LOCKW		;LOCK SHARED MEMORY MAILBOX MUTEX
	SETIPL	SHMMBX_CODE		;LOCK CODE IN MEMORY
	MOVL	SHBADDR(FP),R6		;GET ADDRESS OF SHB
	MOVL	SHB$L_DATAPAGE(R6),R1	;GET ADDRESS OF MEMORY DATAPAGE
	LOCK	#SHD$V_MBXLCK,SHD$B_FLAGS(R1) ;LOCK MAILBOX TABLE
	BLBS	R0,10$			;CONTINUE IF LOCK ATTEMPT SUCCEEDED
	MOVZWL	#SS$_INTERLOCK,R0	;STORE FINAL STATUS
	BRW	UNLOCK_SHMMBX_ERROR	; AND EXIT THROUGH COMMON CODE

10$:	ADDL3	SHD$L_MBXPTR(R1),R1,R7	;GET ADDRESS OF FIRST MAILBOX
	MOVZWL	SHD$W_MBXMAX(R1),-(SP)	;GET NUMBER OF MAILBOXES
	CLRL	-(SP)			;SET NO UNALLOCATED ENTRY YET
20$:
	BBC	#MBX$V_VALID,MBX$B_FLAGS(R7),30$ ;IF CLR MAILBOX NOT VALID
	MOVZBL	MBX$T_NAME(R7),R0	;GET MAILBOX NAME SIZE
	CMPC5	(R11),@4(R11),#0,-	;MAILBOX NAME MATCH ONE SPECIFIED?
		R0,MBX$T_NAME+1(R7)	;
	BNEQ	40$			;IF NEQ NO - TRY NEXT ONE
	ADDL	#8,SP			;REMOVE MAILBOX COUNT + POINTER
	MOVZBL	SHB$B_PORT(R6),R0	;GET PORT NUMBER
	BBSSI	R0,MBX$W_REF(R7),35$	;SET PORT'S REFERENCE FLAG
35$:					;
	MOVL	S^#SS$_NORMAL,R0	;SET SUCCESS
	BRW	UNLOCK_SHMMBX		;
30$:
	TSTL	(SP)			;FIND AN UNALLOCATED ENTRY YET?
	BNEQ	40$			;IF NEQ YES
	MOVL	R7,(SP)			;SAVE ADDRESS OF UNALLOCATED ENTRY
40$:
	ADDL	#MBX$C_LENGTH,R7	;INCREMENT MAILBOX POINTER
	SOBGTR	4(SP),20$		;DECREMENT MAILBOX COUNTER AND LOOP
	POPL	R7			;GET ADDRESS OF UNALLOCATED ENTRY
	ADDL	#4,SP			;REMOVE MAILBOX COUNT FROM STACK
					;CONTINUE IN CREATE_SHMMBX

	.PAGE
	.SBTTL	CREATE_SHMMBX - CREATE SHARED MEMORY MAILBOX BLOCK
;++
; THIS ROUTINE IS CALLED TO CREATE A SHARED MEMORY MAILBOX CONTROL BLOCK.
;
; INPUTS:
;
;	R6 = ADDRESS OF SHARED MEMORY CONTROL BLOCK.
;	R7 = ADDRESS OF FIRST UNALLOCATED ENTRY IN MAILBOX TABLE.
;	R8 = BYTE COUNT QUOTA OF MESSAGES.
;	00(SP) = SAVED PROCESSOR IPL.
;
;	MAILBOX TABLE MUTEX OWNED, MAILBOX TABLE LOCK OWNED, IPL = 31.
;
; OUTPUTS:
;
;	R0 = SUCCESS OR FAILURE.
;	R7 = ADDRESS OF CREATED MAILBOX CONTROL BLOCK.
;--
CREATE_SHMMBX:				;CREATE SHARED MEMORY MAILBOX
	MOVZWL	#SS$_NOSHMBLOCK,R0	;ASSUME NO SLOT AVAILABLE
	TSTL	R7			;WAS A SLOT AVAILABLE?
	BEQL	UNLOCK_SHMMBX		;IF EQL NO SLOT FOUND
	MOVZWL	#SS$_EXPORTQUOTA,R0	;ASSUME PORT'S MAILBOX LIMIT EXCEEDED
	MOVL	SHB$L_DATAPAGE(R6),R1	;GET DATAPAGE ADDRESS
	MOVZBL	SHB$B_PORT(R6),R2	;GET PORT NUMBER
	TSTW	SHD$W_MBXQUOTA(R1)[R2] 	;DOES PORT HAVE ANY MAILBOX QUOTA LEFT?
	BLEQ	UNLOCK_SHMMBX		;IF LEQ QUOTA EXHAUSTED
	DECW	SHD$W_MBXQUOTA(R1)[R2]	;DECREMENT PORT'S QUOTA
	MOVB	R2,MBX$B_CREATPORT(R7)	;SET CREATOR PORT NUMBER
	CLRQ	MBX$Q_MSG(R7)		;INITIALIZE MESSAGE QUEUE LISTHEAD
	ASSUME MBX$W_REF+2 EQ MBX$W_READER
	ASSUME MBX$W_READER+2 EQ MBX$W_READAST
	ASSUME MBX$W_READAST+2 EQ MBX$W_WRITAST
	CLRQ	MBX$W_REF(R7)		;INIT REF FLAGS, READER, READAST, AND WRITAST
	ASHL	R2,#1,MBX$W_REF(R7)	;SET THIS PORT'S REFERENCE FLAG
	CLRW	MBX$W_MSGCNT(R7)	;CLEAR MESSAGE COUNT
	MOVW	MAXMSG(AP),MBX$W_MAXMSG(R7) ;SET MAXIMUM MESSAGE SIZE
	BNEQ	10$			;IF NEQ MESSAGE SIZE SPECIFIED
	MOVW	IOC$GW_MBXMXMSG,MBX$W_MAXMSG(R7) ;SET DEFAULT MAXIMUM SIZE
10$:	MOVW	R8,MBX$W_BUFFQUO(R7)	;SET BUFFER QUOTA
	MOVW	PROMSK(AP),MBX$W_PROT(R7) ;SET PROTECTION MASK
	MOVL	PCB$L_UIC(R4),MBX$L_OWNUIC(R7) ;SET OWNER UIC
	PUSHR	#^M<R4,R5>		;SAVE MOVC REGISTERS
	MOVC5	(R11),@4(R11),#0,-	;SET MAILBOX NAME
		#15,MBX$T_NAME+1(R7)	;
	POPR	#^M<R4,R5>		;RESTORE MOVC REGISTERS
	MOVB	(R11),MBX$T_NAME(R7)	;SET MAILBOX NAME SIZE
	BISB	#MBX$M_VALID,MBX$B_FLAGS(R7) ;MARK MAILBOX VALID
	MOVL	S^#SS$_NORMAL,R0	;SET SUCCESS
UNLOCK_SHMMBX:				;UNLOCK SHARED MEMORY MAILBOXES
	MOVL	SHB$L_DATAPAGE(R6),R1	;GET ADDRESS OF MEMORY DATAPAGE
	UNLOCK	#SHD$V_MBXLCK,SHD$B_FLAGS(R1) ;UNLOCK MAILBOX TABLE
UNLOCK_SHMMBX_ERROR:			;ERROR EXIT PATH THAT RELEASES MUTEX
	PUSHL	R0			;SAVE EXIT STATUS
	MOVAL	EXE$GL_SHMMBMTX,R0	;GET ADDRESS OF MAILBOX MUTEX
	JSB	G^SCH$UNLOCK		;UNLOCK SHARED MEMORY MAILBOX MUTEX
	POPL	R0			;RESTORE EXIT STATUS
	SETIPL	#IPL$_ASTDEL		;RESTORE IPL
	RSB				;
SHMMBX_CODE:				;IPL TO LOCK PREVIOUS CODE IN MEMORY
	.LONG	IPL$_SYNCH
	ASSUME	<.-SEARCH_SHMMBX> LE 512 ;CAN ONLY LOCK 1 PAGE

	.PAGE
	.SBTTL	CREATE_SHMUCB - CREATE SHARED MEMORY MAILBOX UCB
;++
; THIS ROUTINE IS CALLED TO CREATE A UCB FOR A SHARED MEMORY MAILBOX.
;
; INPUTS:
;
;	R4 = CURRENT PROCESS PCB ADDRESS
;	R5 = ADDRESS OF TEMPLATE MAILBOX UCB.
;	R6 = ADDRESS OF SHARED MEMORY CONTROL BLOCK.
;	R7 = ADDRESS OF SHARED MEMORY MAILBOX CONTROL BLOCK.
;	R8 = BYTE COUNT QUOTA FOR MESSAGES.
;
; OUTPUTS:
;
;	R0 = SUCCESS OR FAILURE.
;	R6 = ADDRESS OF CREATED UCB.
;
;	EXECUTES AT DEVICE IPL, IPL$_MAILBOX.
;	I/O DATABASE LOCKED FOR WRITE.
;--
CREATE_SHMUCB:				;CREATE SHARED MEMORY MAILBOX UCB
	DSBINT	70$			;Lock out PRQ's until UCB complete and
					;lock this code for high IPL execution.
	BSBW	IOC$COPY_UCB		;Make a copy of template UCB.
	BLBC	R0, 20$			;Branch if copy operation failed.
	MOVW	MBX$W_UNIT(R7), -	;Establish the unit number of the
		UCB$W_UNIT(R2)		;new UCB.
	BSBW	IOC$LINK_UCB		;Link the new UCB.
	BLBC	R0, 20$			;Branch if link operation failed.
	MOVL	R6,UCB$L_MB_SHB(R2)	;SAVE ADDRESS OF SHB
	INCL	SHB$L_REFCNT(R6)	;INCREMENT MEMORY REFERENCE COUNT
	MOVZBL	SHB$B_PORT(R6),UCB$L_MB_PORT(R2) ;SET PORT NUMBER
	MOVL	R2,R6			;SAVE ADDRESS OF UCB
	MOVL	R7,UCB$L_MB_MBX(R6)	;SAVE ADDRESS OF MAILBOX
	MOVAL	UCB$L_MB_WIOQFL(R6),UCB$L_MB_WIOQFL(R6) ;INIT WRITE I/O REQUEST QUEUE
	MOVAL	UCB$L_MB_WIOQFL(R6),UCB$L_MB_WIOQBL(R6) ;
	MOVW	MBX$W_BUFFQUO(R7),UCB$W_BUFQUO(R6) ;SET BUFFER QUOTA
	MOVW	MBX$W_MAXMSG(R7),UCB$W_DEVBUFSIZ(R6) ;SET MAXIMUM MESSAGE SIZE
	MOVL	UCB$L_ORB(R6),R0	;GET ORB ADDRESS
	BISB2	#ORB$M_PROT_16 -	;USE SOGW PROTECTION WORD
		!ORB$M_NOACL,ORB$B_FLAGS(R0)		;NO ACLS PERMITTED
	BICB2	#ORB$M_ACL_QUEUE,ORB$B_FLAGS(R0)	;THEREFORE, NO QUEUE
	CLRL	ORB$L_ACL_MUTEX(R0)			; AND NO MUTEX
	ASSUME	ORB$L_ACL_DESC EQ ORB$L_ACL_COUNT+4
	CLRQ	ORB$L_ACL_COUNT(R0)			; AND NO ACL PRESENT
	MOVW	MBX$W_PROT(R7),ORB$W_PROT(R0) ;SET PROTECTION MASK
	MOVL	MBX$L_OWNUIC(R7),ORB$L_OWNER(R0) ;Establish owner UIC.
	BSBW	COMP_CHARGES		;COMPUTE QUOTA CHARGES
	MOVZWL	UCB$W_UNIT(R6),R2	;GET UNIT NUMBER
	MOVL	UCB$L_CRB(R6),R1	;GET CRB ADDRESS
	MOVL	CRB$L_INTD+VEC$L_IDB(R1),R1 ;GET IDB ADDRESS
	MOVL	R6,IDB$L_UCBLST(R1)[R2]	;SET UCB ADDRESS IN IDB LIST
20$:
	ENBINT				;ALLOW PRQ PROCESSING NOW
	RSB				;

70$:	.LONG	IPL$_MAILBOX			;Construct used to temporarily
	ASSUME	<. - CREATE_SHMUCB> LE 512	;lock less than one page at
						;elevated IPL.

	.PAGE
	.SBTTL	EXE$DELMBX - DELETE MAILBOX
;+
; EXE$DELMBX - DELETE MAILBOX
;
; THIS SERVICE PROVIDES THE CAPABILITY TO MARK A PERMANENT MAILBOX FOR
; DELETION. ACTUAL DELETION OF THE MAILBOX OCCURS WHEN ITS REFERENCE COUNT
; REACHES ZERO.
;
; INPUTS:
;
;	DLCHAN(AP) = CHANNEL NUMBER THAT THE MAILBOX TO BE DELETED IS ASSIGNED TO.
;
;	R4 = CURRENT PROCESS PCB ADDRESS.
;
; OUTPUTS:
;
;	R0 LOW BIT CLEAR INDICATES FAILURE TO MARK MAILBOX FOR DELETE.
;
;		R0 = SS$_DEVNOTMBX - SPECIFIED CHANNEL IS NOT ASSIGNED TO A
;			MAILBOX.
;
;		R0 = SS$_IVCHAN - INVALID CHANNEL NUMBER SPECIFIED.
;
;		R0 = SS$_NOPRIV - PROCESS DOES NOT HAVE PRIVILEGE TO DELETE A
;			PERMANENT MAILBOX, SPECIFIED CHANNEL IS NOT ASSIGNED
;			TO A DEVICE, OR THE CALLER DOES NOT HAVE SUFFICIENT
;			PRIVILEGE TO ACCESS THE CHANNEL.
;
;	R0 LOW BIT SET INDICATES SUCCESSFUL COMPLETION.
;
;		R0 = SS$_NORMAL - NORMAL COMPLETION.
;-
 
	.ENTRY	EXE$DELMBX,^M<R2,R3,R4,R5>
	MOVZWL	DLCHAN(AP),R0		;GET CHANNEL NUMBER OF MAILBOX
	BSBW	IOC$VERIFYCHAN		;VERIFY CHANNEL NUMBER
	BLBC	R0,20$			;IF LBC INVALID CHANNEL
	MOVL	CCB$L_UCB(R1),R5	;GET ASSIGNED DEVICE UCB ADDRESS
	MOVZWL	#SS$_DEVNOTMBX,R0	;SET DEVICE NOT MAILBOX STATUS
	BBC	#DEV$V_MBX,UCB$L_DEVCHAR(R5),20$ ;IF CLR, DEVICE NOT MAILBOX
	MOVZWL	#SS$_NOPRIV,R0		;ASSUME CALLER DOES NOT HAVE PRIVILEGE
	BBC	#UCB$V_PRMMBX,UCB$W_DEVSTS(R5),10$ ;IF CLR, NOT PERMANENT MAILBOX
	IFNPRIV	PRMMBX,20$		;CALLER HAVE PRIVILEGE TO DELETE?
	BISW	#UCB$M_DELMBX,UCB$W_DEVSTS(R5) ;MARK MAILBOX FOR DELETION
10$:	MOVZWL	#SS$_NORMAL,R0		;SET NORMAL COMPLETION
20$:	RET				;
 
	.END
