	.TITLE	CVDRIVER - VAX/VMS VAX 8600 CONSOLE DISK DRIVER
	.IDENT	'V04-001'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
; 
; FACILITY:
; 
; 	VAX/VMS VAX 8600 CONSOLE RL02 DRIVER
; 
; AUTHOR:
; 
;	BENN SCHREIBER, 15-MAR-1983
; 
; MODIFIED BY:
;
;	V04-001	BLS0345		Benn Schreiber		27-AUG-1984
;		Retry complete transfer rather than attempting restart
;		at last block.  This avoids forking per-block in the
;		non-error case.  Wait for ready before issuing sts/reset
;		on error path.  Increase timeout on read/write operations.
;		Check for errors on get status interrupts following read/write.
;
;	V03-005	BLS0342		Benn Schreiber		19-AUG-1984
;		Implement abort, reset with status.  Modify cvc_getsts
;		to use TIMEDWAIT macro.
;
;	V03-004	TCM0002		Trudy C. Matthews	09-Aug=1984
;		Increase timeout value in CVC_GETSTS from 30 to 100000.
;
;	V03-003	TCM0001		Trudy C. Matthews	08-Aug-1984
;		Several bug fixes.  Also a spec change - the LBN in STXCS
;		must always be valid for each word of the transfer (and not
;		just the first).
;
;**

; ABSTRACT:
; 
; 	THIS MODULE CONTAINS THE TABLES AND ROUTINES NECESSARY TO
; 	PERFORM ALL DEVICE-DEPENDENT PROCESSING OF AN I/O REQUEST
; 	FOR RL02 DISK TYPES ON A VAX/VMS VAX 8600 CONSOLE SUBSYSTEM.
; 
; 	THE DISKS HAVE THE FOLLOWING PHYSICAL GEOMETRY:
;
; 			TRACKS/	   SECTORS/	BYTES/	   MAXIMUM	
;	   # CYL	CYLINDER   TRACK	SECTOR	   BLOCKS
; 
; RL02	    512		   2	     40		  256	   20480
; 
; 	THE IO$X_INHSEEK FUNCTION MODIFIER IS TREATED AS A NO-OP BY
; 	THIS DRIVER, SINCE AN IMPLICIT SEEK IS ALWAYS DONE BY THE
;	CONSOLE SUBSYSTEM WHEN READING/WRITING.
; 
;--

	.SBTTL	EXTERNAL AND LOCAL DEFINITIONS

; 
; EXTERNAL SYMBOLS
; 

	$CRBDEF				;DEFINE CHANNEL REQUEST BLOCK
	$DCDEF				;DEFINE DEVICE CLASS
	$DDBDEF				;DEFINE DEVICE DATA BLOCK
	$DEVDEF				;DEFINE DEVICE CHARACTERISTICS
	$DPTDEF				;DEFINE DRIVER PROLOGUE TABLE
	$DYNDEF				;DEFINE DYNAMIC DATA STRUCTURE TYPES
	$EMBDEF				;DEFINE ERROR MESSAGE BUFFER
	$IDBDEF				;DEFINE INTERRUPT DATA BLOCK
	$IODEF				;DEFINE I/O FUNCTION CODES
	$IRPDEF				;DEFINE I/O REQUEST PACKET
	$PRDEF				;DEFINE PROCESSOR REGISTERS
	$SSDEF				;DEFINE SYSTEM STATUS CODES
	$UCBDEF				;DEFINE UNIT CONTROL BLOCK
	$VECDEF				;DEFINE INTERRUPT VECTOR BLOCK

; 	GENF
; 	GENERATE CASE TABLE INDEX SYMBOL

	.MACRO	GENF FCODE
		CD'FCODE=$$GENF_CODE
		$$GENF_CODE=$$GENF_CODE+1
	.ENDM
;
; LOCAL SYMBOLS
;
	CV_NUM_REGS	= 4		;NUMBER OF DEVICE REGISTERS (MIMIC RL02)
	CV_SLM		= 5		;STATE=SEEK LINEAR MODE (READY TO GO)
; 
; UCB OFFSETS WHICH FOLLOW THE STANDARD UCB FIELDS
; 
	$DEFINI	UCB			;START OF UCB DEFINITIONS

.=UCB$K_LCL_DISK_LENGTH			;BEGIN DEFINITIONS AT END OF UCB
$DEF	UCB$L_CV_CS	.BLKL	1	;CONTROL STATUS REGISTER
$DEF	UCB$L_CV_MP	.BLKL	1	;MULTIPURPOSE REGISTER
$DEF	UCB$Q_CV_CSMP	.BLKQ	1	;SAVE CS AND MP DURING RESET_STATUS
$DEF	UCB$B_CV_STATE	.BLKB	1	;CURRENT INTERRUPT STATE **ADJACENCY
$DEF	UCB$B_CV_STS	.BLKB	1	;STATUS FLAGS		 **ASSUMED
$DEF	UCB$W_CV_BBC	.BLKW	1	;BLOCK BYTE COUNT REMAINING
$DEF	UCB$L_CV_IBUF	.BLKL	1	;INTERNAL BUFFER FOR READING
$DEF	UCB$L_CV_MVRTN	.BLKL	1	;ADDRESS OF BUFFER MOVE ROUTINE
$DEF	UCB$L_CV_BUFWIN	.BLKL	1	;BUFFER WINDOW
$DEF	UCB$Q_CV_BDAT	.BLKQ	1	;SAVPTE AND TRANSFER PARAMS THIS BLOCK
$DEF	UCB$L_CV_LBN	.BLKL	1	;SAVE STARTING LBN OF TRANSFER
$DEF	UCB$L_CV_ABPC	.BLKL	1	;SAVE RETURN ADDRESS FROM ABORT CALL
$DEF	UCB$K_CV_LEN	.BLKW	0	;LENGTH OF UCB
	$DEFEND	UCB			;END OF UCB DEFINITONS
 
; 
; RL11/RL01 REGISTER OFFSETS FROM CSR ADDRESS
; 
	$DEFINI	CV			; START OF REGISTER DEFINITIONS

;
; UCB$B_CV_STS FLAGS
;
	_VIELD	CV,0,<-
		<RD,,M>,-		;SET IF READ OPERATION
		<STSONLY,,M>,-		;OPERATION IS GET STATUS ONLY
		<STSERROR,,M>,-		;ERROR FROM CONSOLE ON GETSTS INTERRUPT
		<ABORT,,M>>		;ABORT CURRENT OPERATION AND RETRY

$DEF	CV_CS		.BLKW	1	;CONTROL STATUS REGISTER (CSR)
	_VIELD	CV_CS,0,<-		;START OF CSR BIT DEFINITIONS
		<DRDY,,M>,-		; DRIVE READY
		<,3>,-			; FUNCTION CODE
		<,2>,-			; BUS ADDRESS EXTENSION BITS
		<,1>,-			; INTERRUPT ENABLE
		<,1>,-			; CONTROLLER READY
		<DS,2>,-		; DRIVE SELECT
		<OPI,,M>,-		; OPERATION INCOMPLETE
		<CRC,,M>,-		; DATA CRC OR HEADER CRC
		<CVT,,M>,-		; DATA LATE OR HEADER NOT FOUND
		<NXM,,M>,-		; NON-EXISTENT MEMORY
		<DE,,M>,-		; DRIVE ERROR
		<CE,,M>-		; COMPOSITE ERROR
	>				;END CSR BIT DEFINITIONS

$DEF	CV_MP		.BLKW	1	;MULTIPURPOSE REGISTER (MPR)
	_VIELD	CV_MP,0,<-		;START OF MPR BIT DEFINITIONS
		<STA,3>,-		; DRIVE STATE
		<BH,,M>,-		; BRUSH HOME
		<HO,,M>,-		; HEADS OUT
		<CO,,M>,-		; COVER OPEN
		<HS,,M>,-		; HEAD SELECT
		<,1>,-			; DRIVE TYPE
		<DSE,,M>,-		; DRIVE SELECT ERROR
		<VC,,M>,-		; VOLUME CHECK
		<WGE,,M>,-		; WRITE GATE ERROR
		<SPE,,M>,-		; SPIN ERROR
		<SKTO,,M>,-		; SEEK TIME OUT
		<WL,,M>,-		; WRITE LOCK
		<CHE,,M>,-		; CURRENT HEAD ERROR
		<WDE,,M>-		; WRITE DATA ERROR
	>				;END MPR BIT DEFINITIONS

;
; VAX 8600 STXCS FORMAT
;
	_VIELD	STXCS,0,<-
		<FUNC,4>,-		;DISK FUNCTION TO PERFORM
		<,2>,-			;MBZ
		<IE,,M>,-		;INTERRUPT ENABLE
		<RDY,,M>,-		;READY
		<ADDRS,16>,-		;DISK LOGICAL BLOCK NUMBER
		<STS,8>-		;STATUS OF TRANSFER
		>

	$DEFEND	CV			;END RL11/RL01 REGISTER DEFINITIONS

;
; VAX 8600 CONSOLE STXCS STATUS CODES
;
TRANS_COMPLETE = 1			;TRANSACTION COMPLETED
TRANS_CONTINUE = 2			;CONTINUE TRANSACTION
TRANS_ABORTED = 3			;TRANSACTION ABORTED
RETURNED_STATUS = 4			;STATUS RETURNED
HANDSHAKE_ERROR = ^X80			;HANDSHAKE ERROR DURING TRANSACTION
HW_ERROR = ^X81				;HARDWARE ERROR DURING TRANSACTION
;
; VAX 8600 CONSOLE STXCS FUNCTION CODES
;
NO_OP = 0				;NO OPERATION
STATUS_RESET = 2			;READ DEVICE STATUS WITH RST ASSERTED
ABORT_TRANSFER = 3			;ABORT CURRENT TRANSFER
READ_STATUS = 4				;READ DEVICE STATUS
WRITE_BLOCK = 5				;WRITE BLOCK OF DATA
READ_BLOCK = 6				;READ BLOCK OF DATA
;
; INTERRUPT TRANSITION CODES
;
ITC_DATA = 0				;READ OR WRITE DATA
ITC_STS1 = 1				;GET CONTROL/STATUS REGISTER
ITC_STS2 = 2				;GET RL11 MULTIPURPOSE REGISTER
ITC_ABORT = 3				;ABORT CURRENT TRANSFER
ITC_RESET1 = 4				;GET CONTROL/STATUS WITH RST ASSERTED
ITC_RESET2 = 5				;GET MP REG WITH RST ASSERTED
;
; DEFINE THE CASE OFFSETS AS CD'FUNCTION (I.E. CDF_NOP)
;
	$$GENF_CODE = 0			;INITIALIZE
	GENF	F_NOP			;NO-OP
	GENF	F_UNLOAD		;UNLOAD VOLUME (NOP)
	GENF	F_SEEK			;SEEK
	GENF	F_RECAL			;RECALIBRATE (NOP)
	GENF	F_DRVCLR		;DRIVE CLEAR (RESET & GET STATUS)
	GENF	F_RELEASE		;RELEASE PORT (NOP)
	GENF	F_OFFSET		;OFFSET HEADS (NOP)
	GENF	F_RETCENTER		;RETURN HEADS TO CENTERLINE (NOP)
	GENF	F_PACKACK		;PACK ACKNOWLEDGE (RESET & GET STATUS)
	GENF	F_SEARCH		;SEARCH (NOP)
	GENF	F_WRITECHECK		;WRITE CHECK
	GENF	F_WRITEDATA		;WRITE DATA
	GENF	F_READDATA		;READ DATA
	GENF	F_WRITEHEAD		;WRITE HEADERS (NOP)
	GENF	F_READHEAD		;READ HEADERS
	GENF	F_NOP			;place holder
	GENF	F_NOP			;place holder
	GENF	F_AVAILABLE		;AVAILABLE


	.SBTTL	STANDARD TABLES

; 
; DRIVER PROLOGUE TABLE
; 
; 	THE DPT DESCRIBES DRIVER PARAMETERS AND I/O DATABASE FIELDS
; 	THAT ARE TO BE INITIALIZED DURING DRIVER LOADING AND RELOADING
; 

	DPTAB	-			;DPT CREATION MACRO
		END=CV_END,-		;END OF DRIVER LABEL
		ADAPTER=UBA,-		;ADAPTER TYPE = UNIBUS
		FLAGS=DPT$M_SVP,-	;SYSTEM PAGE TABLE ENTRY REQUIRED
		UCBSIZE=UCB$K_CV_LEN,-	;LENGTH OF UCB
		NAME=CVDRIVER		;DRIVER NAME

	DPT_STORE INIT			;START CONTROL BLOCK INIT VALUES
	DPT_STORE DDB,DDB$L_ACPD,L,<^A\F11\>  ;DEFAULT ACP NAME
	DPT_STORE DDB,DDB$L_ACPD+3,B,DDB$K_CART	;ACP CLASS
	DPT_STORE UCB,UCB$B_FIPL,B,8	;FORK IPL
	DPT_STORE UCB,UCB$L_DEVCHAR,L,-	;DEVICE CHARACTERISTICS
		<DEV$M_FOD-		; FILES ORIENTED
		!DEV$M_DIR-		; DIRECTORY STRUCTURED
		!DEV$M_AVL-		; AVAILABLE
		!DEV$M_ELG-		; ERROR LOGGING
		!DEV$M_SHR-		; SHAREABLE
		!DEV$M_IDV-		; INPUT DEVICE
		!DEV$M_ODV-		; OUTPUT DEVICE
		!DEV$M_RND>		; RANDOM ACCESS
	DPT_STORE UCB,UCB$B_DEVCLASS,B,DC$_DISK  ;DEVICE CLASS
	DPT_STORE UCB,UCB$W_DEVBUFSIZ,W,512  ;DEFAULT BUFFER SIZE
	DPT_STORE UCB,UCB$B_SECTORS,B,40  ;NUMBER OF SECTORS PER TRACK
	DPT_STORE UCB,UCB$B_TRACKS,B,2	;NUMBER OF TRACKS PER CYLINDER
	DPT_STORE UCB,UCB$B_DIPL,B,21	;DEVICE IPL
	DPT_STORE UCB,UCB$B_ERTMAX,B,8	;MAX ERROR RETRY COUNT

	DPT_STORE REINIT		;START CONTROL BLOCK RE-INIT VALUES
	DPT_STORE CRB,CRB$L_INTD+4,D,CV_INT  ;INTERRUPT SERVICE ROUTINE ADDRESS
	DPT_STORE CRB,CRB$L_INTD+VEC$L_INITIAL,-  ;CONTROLLER INIT ADDRESS
		      D,CV_RL11_INIT		  ;...
	DPT_STORE CRB,CRB$L_INTD+VEC$L_UNITINIT,- ;UNIT INIT ADDRESS
		      D,CV_RL0X_INIT		  ;...
	DPT_STORE DDB,DDB$L_DDT,D,CV$DDT	  ;DDT ADDRESS

	DPT_STORE END			;END OF INITIALIZATION TABLE

; 
; DRIVER DISPATCH TABLE
; 
; 	THE DDT LISTS ENTRY POINTS FOR DRIVER SUBROUTINES WHICH ARE
; 	CALLED BY THE OPERATING SYSTEM.
; 

	DDTAB	-			;DDT CREATION MACRO
		DEVNAM=CV,-		;NAME OF DEVICE
		START=CV_STARTIO,-	;START I/O ROUTINE
		UNSOLIC=CV_UNSOLNT,-	;UNSOLICITED INTERRUPT
		FUNCTB=CV_FUNCTABLE,-	;FUNCTION DECISION TABLE
		CANCEL=0,-		;CANCEL=NO-OP FOR FILES DEVICE
		REGDMP=CV_REGDUMP,-	;REGISTER DUMP ROUTINE
		DIAGBF=<<CV_NUM_REGS+5+5+3+1>*4>,-  ;BYTES IN DIAG BUFFER
		ERLGBF=<<<CV_NUM_REGS+5+1>*4>+EMB$L_DV_REGSAV>  ;BYTES IN
							;ERROR LOG BUFFER

; DIAGNOSTIC BUFFER SIZE = <<4 RL02 REGISTER LONGWORDS + 5 UCB FIELD LONGWORDS 
;			   + 5 IOC$DIAGBUFILL LONGWORDS + 3 BUFFER ALLOCATION
;			   LONGWORDS + 1 LONGWORD FOR # REGISTERS IN CV_REGDUMP>
;			   * 4 BYTES/LONGWORD>
;
; ERROR LOG BUFFER SIZE  = <<<4 RL02 REGISTER LONGWORDS + 5 UCB FIELD LONGWORDS
; 			   + 1 LONGWORD FOR # REGISTERS IN CV_REGDUMP>
;			   * 4 BYTES/LONGWORD> + BYTES NEEDED FOR ERROR LOGGER
;			   TO SAVE SOFTWARE REGISTERS>



; 
; FUNCTION DECISION TABLE
; 
; 	THE FDT LISTS VALID FUNCTION CODES, SPECIFIES WHICH
; 	CODES ARE BUFFERED, AND DESIGNATES SUBROUTINES TO
; 	PERFORM PREPROCESSING FOR PARTICULAR FUNCTIONS.
; 

CV_FUNCTABLE:
	FUNCTAB	,-			;LIST LEGAL FUNCTIONS
		<NOP,-			; NO-OP
		UNLOAD,-		; UNLOAD
		SEEK,-			; SEEK
		DRVCLR,-		; DRIVE CLEAR
		PACKACK,-		; PACK ACKNOWLEDGE
		SENSECHAR,-		; SENSE CHARACTERISTICS
		SETCHAR,-		; SET CHARACTERISTICS
		SENSEMODE,-		; SENSE MODE
		SETMODE,-		; SET MODE
		READLBLK,-		; READ LOGICAL BLOCK
		WRITELBLK,-		; WRITE LOGICAL BLOCK
		READPBLK,-		; READ PHYSICAL BLOCK
		WRITEPBLK,-		; WRITE PHYSICAL BLOCK
		READVBLK,-		; READ VIRTUAL BLOCK
		WRITEVBLK,-		; WRITE VIRTUAL BLOCK
		AVAILABLE,-		; AVAILABLE
		ACCESS,-		; ACCESS FILE / FIND DIRECTORY ENTRY
		ACPCONTROL,-		; ACP CONTROL FUNCTION
		CREATE,-		; CREATE FILE AND/OR DIRECTORY ENTRY
		DEACCESS,-		; DEACCESS FILE
		DELETE,-		; DELETE FILE AND/OR DIRECTORY ENTRY
		MODIFY,-		; MODIFY FILE ATTRIBUTES
		MOUNT-			; MOUNT VOLUME
		>
	FUNCTAB	,-			;BUFFERED FUNCTIONS
		<NOP,-			; NO-OP
		UNLOAD,-		; UNLOAD
		SEEK,-			; SEEK
		DRVCLR,-		; DRIVE CLEAR
		PACKACK,-		; PACK ACKNOWLEDGE
		SENSECHAR,-		; SENSE CHARACTERISTICS
		SETCHAR,-		; SET CHARACTERISTICS
		SENSEMODE,-		; SENSE MODE
		SETMODE,-		; SET MODE
		AVAILABLE,-		; AVAILABLE
		ACCESS,-		; ACCESS FILE / FIND DIRECTORY ENTRY
		ACPCONTROL,-		; ACP CONTROL FUNCTION
		CREATE,-		; CREATE FILE AND/OR DIRECTORY ENTRY
		DEACCESS,-		; DEACCESS FILE
		DELETE,-		; DELETE FILE AND/OR DIRECTORY ENTRY
		MODIFY,-		; MODIFY FILE ATTRIBUTES
		MOUNT-			; MOUNT VOLUME
		>
	FUNCTAB	CV_ALIGN,-		;TEST ALIGNMENT FUNCTIONS
		<READLBLK,-		; READ LOGICAL BLOCK
		READPBLK,-		; READ PHYSICAL BLOCK
		READVBLK,-		; READ VIRTUAL BLOCK
		WRITELBLK,-		; WRITE LOGICAL BLOCK
		WRITEPBLK,-		; WRITE PHYSICAL BLOCK
		WRITEVBLK-		; WRITE VIRTUAL BLOCK
		>
	FUNCTAB	+ACP$READBLK,-		;READ FUNCTIONS
		<READLBLK,-		; READ LOGICAL BLOCK
		READPBLK,-		; READ PHYSICAL BLOCK
		READVBLK-		; READ VIRTUAL BLOCK
		>
	FUNCTAB	+ACP$WRITEBLK,-		;WRITE FUNCTIONS
		<WRITELBLK,-		; WRITE LOGICAL BLOCK
		WRITEPBLK,-		; WRITE PHYSICAL BLOCK
		WRITEVBLK-		; WRITE VIRTUAL BLOCK
		>
	FUNCTAB	+ACP$ACCESS,-		;ACCESS FUNCTIONS
		<ACCESS,-		; ACCEESS FILE / FIND DIRECTORY ENTRY
		CREATE-			; CREATE FILE AND/OR DIRECTORY ENTRY
		>
	FUNCTAB	+ACP$DEACCESS,-		;DEACCESS FUNCTION
		<DEACCESS-		; DEACCESS FILE
		>
	FUNCTAB	+ACP$MODIFY,-		;MODIFY FUNCTIONS
		<ACPCONTROL,-		; ACP CONTROL FUNCTION
		DELETE,-		; DELETE FILE AND/OR DIRECTORY ENTRY
		MODIFY-			; MODIFY FILE ATTRIBUTES
		>
	FUNCTAB	+ACP$MOUNT,-		;MOUNT FUNCTION
		<MOUNT-			; MOUNT VOLUME
		>
	FUNCTAB	+EXE$LCLDSKVALID,-
		<UNLOAD,-
		AVAILABLE,-
		PACKACK-
		>
	FUNCTAB	+EXE$ZEROPARM,-		;ZERO PARAMETER FUNCTIONS
		<NOP,-			; NO-OP
		UNLOAD,-		; UNLOAD
		DRVCLR,-		; DRIVE CLEAR
		PACKACK,-		; PACK ACKNOWLEDGE
		AVAILABLE,-		; AVAILABLE
		>
	FUNCTAB	+EXE$ONEPARM,-		;ONE PARAMETER FUNCTION
		<SEEK-			; SEEK
		>
	FUNCTAB	+EXE$SENSEMODE,-	;SENSE FUNCTIONS
		<SENSECHAR,-		; SENSE CHARACTERISTICS
		SENSEMODE-		; SENSE MODE
		>
	FUNCTAB	+EXE$SETCHAR,-		;SET FUNCTIONS
		<SETCHAR,-		; SET CHARACTERISTICS
		SETMODE-		; SET MODE
		>


	.SBTTL	CONTROLLER INITIALIZATION ROUTINE
;++
; 
; FUNCTIONAL DESCRIPTION:
; 
; 	THIS ROUTINE IS A NO-OP FOR THE RL11 BUT MUST BE INCLUDED
; 	SINCE IT IS CALLED WHEN THE RL02 IS BOOTED AS A SYSTEM DEVICE.
; 
; 	THE OPERATING SYSTEM CALLS THIS ROUTINE:
; 		- AT SYSTEM STARTUP
; 		- DURING DRIVER LOADING
; 		- DURING RECOVERY FROM POWER FAILURE
; 
; INPUTS:
; 
; 	R4	- CSR ADDRESS (DEVICE CONTROL STATUS REGISTER)
; 	R5	- IDB ADDRESS (INTERRUPT DATA BLOCK)
; 	ALL INTERRUPTS ARE LOCKED OUT
; 
; OUTPUTS:
; 
; 	CONTROL IS RETURNED TO THE CALLER.
; 
;--

CV_RL11_INIT:				;CONTROLLER INITIALIZATION
	RSB				;RETURN TO CALLER

	.SBTTL	UNIT INITIALIZATION ROUTINE

;++
; 
; CV_RL0X_INIT - UNIT INITIALIZATION ROUTINE
; 
; FUNCTIONAL DESCRIPTION:
; 
; 	THIS ROUTINE READIES THE RL02 UNIT FOR I/O OPERATIONS.
; 
; 	THE OPERATING SYSTEM CALLS THIS ROUTINE:
; 		- AT SYSTEM STARTUP
; 		- DURING DRIVER LOADING
; 		- DURING RECOVERY FROM POWER FAILURE
; 
; INPUTS:
; 
; 	R4	- CSR ADDRESS (CONTROLLER STATUS REGISTER)
; 	R5	- UCB ADDRESS (UNIT CONTROL BLOCK)
; 
; OUTPUTS:
; 
; 	THE DRIVE UNIT IS RESET, UCB FIELDS ARE INITIALIZED, AND THE
; 	ROUTINE WAITS FOR ONLINE UNITS TO SPIN UP.  ALL REGISTERS
; 	EXCEPT R0-R3 ARE PRESERVED.
; 
;--

CV_RL0X_INIT:				;RL01/RL02 UNIT INITIALIZATION
	BICW2	#<UCB$M_ONLINE!UCB$M_VALID>,-  ;ASSUME OFFLINE/INVALID
		UCB$W_STS(R5)		;...

	MOVL	#^X2324C002,-		;SET MEDIA IDENT "DL RL02"
		UCB$L_MEDIA_ID(R5)
	MOVB	S^#DT$_RL02,-		;SET RL02 DEVICE TYPE
			UCB$B_DEVTYPE(R5)
	MOVW	#512,UCB$W_CYLINDERS(R5);SET NUMBER OF RL02 CYLINDERS
	MOVZWL	#20480,UCB$L_MAXBLOCK(R5);SET MAX RL02 BLOCK NUMBER
	BSBB	CVC_GETSTS		;GET CONSOLE RL02 STATUS
	BBC	#CV_CS_V_DRDY,R0,40$	;BRANCH IF DRIVE NOT READY
	BISW2	#UCB$M_VALID,UCB$W_STS(R5) ;YES, SET VOLUME VALID
40$:	BISW2	#UCB$M_ONLINE,UCB$W_STS(R5);SET UNIT ONLINE
60$:	RSB

	.SBTTL	DRIVER SPECIFIC SUBROUTINES
;
; CVC_GETSTS - GET STATUS FOR VAX 8600 CONSOLE RL02 WITHOUT INTERRUPTS
;
; INPUTS:
;
;	NONE
;
; OUTPUTS:
;
;	R0 = 0 IF FAILED TO GET STATUS
;	   = RL02 CONTROL STATUS REGISTER
;
;	R1 = RL02 MULTIPURPOSE REGISTER (UNUSABLE IF R0=0)
;
CVC_GETSTS:
	PUSHL	R2			;SAVE R2
	BSBB	100$			;READ CONTROL STATUS REGISTER
	PUSHL	R0			;SAVE R0
	BSBB	100$			;READ MULTIPURPOSE REGISTER
	MOVL	R0,R1			;POSITION MULTIPURPOSE REGISTER
	POPL	R0			;RESTORE CSR
	POPR	#^M<R2>			;RESTORE R2
	RSB

100$:	MTPR	#STATUS_RESET,#PR$_STXCS ;REQUEST READ STATUS
	TIMEDWAIT TIME=#600*1000,-
		INS1=<MFPR	#PR$_STXCS,R2>,- ;READ STATUS
		INS2=<BBS	#STXCS_V_RDY,R2,140$> ;BRANCH IF READY
	RSB				;CONSOLE NEVER GOT READY (TIMEDWAIT
					;CLEARS R0 ON FALL-OUT)
140$:	ADDL2	#4,SP			;CLEAR TIMEDWAIT'S COUNTER FROM STACK
	MFPR	#PR$_STXDB,R0		;OBTAIN STATUS FROM CONSOLE
	RSB

	.SBTTL	FDT ROUTINE - TEST TRANSFER BYTE COUNT ALIGNMENT 

;++
; 
; DL_ALIGN - FDT ROUTINE TO TEST XFER BYTE COUNT
; 
; FUNCTIONAL DESCRIPTION:
; 
; 	THIS ROUTINE IS CALLED FROM THE FUNCTION DECISION TABLE DISPATCHER
; 	TO CHECK THE BYTE COUNT PARAMETER SPECIFIED BY THE USER PROCESS
; 	FOR AN EVEN NUMBER OF BYTES (WORD BOUNDARY).
; 
; INPUTS:
; 
; 	R3	- IRP ADDRESS (I/O REQUEST PACKET)
; 	R4	- PCB ADDRESS (PROCESS CONTROL BLOCK)
; 	R5	- UCB ADDRESS (UNIT CONTROL BLOCK)
; 	R6	- CCB ADDRESS (CHANNEL CONTROL BLOCK)
; 	R7	- BIT NUMBER OF THE I/O FUNCTION CODE
; 	R8	- ADDRESS OF FDT TABLE ENTRY FOR THIS ROUTINE
; 	4(AP)	- ADDRESS OF FIRST FUNCTION DEPENDENT QIO PARAMETER
; 
; OUTPUTS:
; 
; 	IF THE QIO BYTE COUNT PARAMETER IS ODD, THE I/O OPERATION IS
; 	TERMINATED WITH AN ERROR. IF IT IS EVEN, CONTROL IS RETURNED
; 	TO THE FDT DISPATCHER.
; 
;--

CV_ALIGN:				;CHECK BYTE COUNT AT P1(AP)
	BLBS	4(AP),10$		;IF LBS - ODD BYTE COUNT
	RSB				;EVEN - RETURN TO CALLER
10$:	MOVZWL	#SS$_IVBUFLEN,R0	;SET BUFFER ALIGNMENT STATUS
	JMP	G^EXE$ABORTIO		;ABORT I/O

	.SBTTL	START I/O ROUTINE

;++
; 
; CV_STARTIO - START I/O ROUTINE
; 
; FUNCTIONAL DESCRIPTION:
; 
; 	THIS FORK PROCESS IS ENTERED FROM THE EXECUTIVE AFTER AN I/O REQUEST
; 	PACKET HAS BEEN DEQUEUED, AND PERFORMS THE FOLLOWING:
; 
; 		- ACTIVATES THE CONSOLE AFTER SETTING UCB FIELDS, AND OBTAINING
; 		  CONTROLLER RESOURCES
; 
; 		- WAITS FOR AN INTERRUPT
; 
; 		- REGAINS CONTROL AFTER THE ISR SERVICES THE INTERRUPT, AND
; 			-  RE-ACTIVATES THE CONSOLE IF THE ORIGINAL FUNCTION
; 			   IS A RETRIABLE ERROR, OR
; 			-  COMPLETES THE I/O REQUEST BY RELEASING RESOURCES,
;			   SETTING STATUS CODES, AND RETURNING TO THE EXECUTIVE.
; 
; INPUTS:
; 
; 	R3		- IRP ADDRESS (I/O REQUEST PACKET)
; 	R5		- UCB ADDRESS (UNIT CONTROL BLOCK)
; 
; OUTPUTS:
; 
; 	R0	- FIRST I/O STATUS LONGWORD: STATUS CODE & BYTES XFERED
; 	R1	- SECOND I/O STATUS LONGWORD: 0 FOR DISKS
; 
; 	THE I/O FUNCTION IS EXECUTED.
; 
; 	ALL REGISTERS EXCEPT R0-R4 ARE PRESERVED.
; 
;--

CV_STARTIO:				;START I/O OPERATION
; 
; 	PREPROCESS UCB FIELDS
; 
PREPROCESS:
;
; Convert the physical media address in IRP$L_MEDIA to an LBN.
; This is necessary because the console RL02 controller expects an LBN,
; not a physical media address.  The LBN is given by the formula:
;
; LBN = (CYLINDER*(TRACKS/CYLINDER)+TRACK)*(SECTORS/TRACK))+SECTOR
;
	MOVL	IRP$L_MEDIA(R3),-	;Copy media address to UCB
		UCB$L_MEDIA(R5)		;
	MOVAL	UCB$L_MEDIA(R5),R3	;Get address of media address
	MOVZBL	(R3)+,R0		;Get SECTOR
	MOVZBL	(R3)+,R1		;Get TRACK
	MOVZWL	(R3)+,-(SP)		;Get CYLINDER
	MOVZBL	UCB$B_TRACKS(R5),R3	;Get TRACKS/CYLINDER
	MULL2	(SP)+,R3		;R3 = C*(T/C)
	ADDL2	R3,R1			;R1 = C*(T/C)+T
	MOVZBL	UCB$B_SECTORS(R5),R3	;Get SECTORS/TRACK
	MULL2	R3,R1			;R1 = (C*(T/C)+T)*(S/T)
	ADDL3	R1,R0,UCB$L_MEDIA(R5)	;CALULATE AND STORE LBN
	MOVL	UCB$L_MEDIA(R5),UCB$L_CV_LBN(R5) ;SAVE STARTING LBN FOR RETRIES
	MOVB	UCB$B_ERTMAX(R5),-	;INITIALIZE ERROR RETRY COUNT
		UCB$B_ERTCNT(R5)	;...
	MOVL	UCB$L_IRP(R5),R3	;GET IRP ADDRESS
	MOVW	IRP$W_FUNC(R3),UCB$W_FUNC(R5)  ;SAVE FUNCTION CODE
	EXTZV	#IRP$V_FCODE,-		;EXTRACT I/O FUNCTION CODE
		#IRP$S_FCODE,IRP$W_FUNC(R3),R1  ;...
	MOVB	R1,UCB$B_FEX(R5)	;STORE FUNCTION DISPATCH INDEX
	MOVQ	UCB$L_SVAPTE(R5),-	;SAVE TRANSFER PARAMETERS
		UCB$Q_CV_BDAT(R5)
	BICW2	#UCB$M_DIAGBUF,-
		UCB$W_DEVSTS(R5)	;CLR DIAGNOSTIC BUFFER PRESENT
	BBC	#IRP$V_DIAGBUF,-	;IF CLR - NO DIAG BUFFER
		IRP$W_STS(R3),FDISPATCH ;...
	BISW2	#UCB$M_DIAGBUF,UCB$W_DEVSTS(R5)  ;SET DIAG BUFFER PRESENT
; 
; 	CENTRAL FUNCTION DISPATCH
; 
FDISPATCH:				;FUNCTION DISPATCH
;
; RETRY LOGIC IS DONE BY RESTARTING THE ENTIRE TRANSFER, RATHER THAN
; AT THE BLOCK IN ERROR.  HENCE, WE RESTORE TRANSFER PARAMETERS HERE
;
	MNEGW	UCB$W_BCNT(R5),UCB$W_BCR(R5)  ;INIT NEG BYTES LEFT TO XFER
	MOVQ	UCB$Q_CV_BDAT(R5),-	;RESTORE TRANSFER PARAMETERS
		UCB$L_SVAPTE(R5)
	MOVL	UCB$L_CV_LBN(R5),UCB$L_MEDIA(R5) ;RESTORE STARTING LBN

	MOVL	UCB$L_IRP(R5),R3	;GET IRP ADDRESS
	BBS	#IRP$V_PHYSIO,-		;IF SET - PHYSICAL I/O FUNCTION
		IRP$W_STS(R3),10$	;...
	BBS	#UCB$V_VALID,-		;IF SET - VOLUME SOFTWARE VALID
		UCB$W_STS(R5),10$	;...
	MOVZWL	#SS$_VOLINV,R0		;SET VOLUME INVALID STATUS
	BRW	RESETXFR		;RESET BYTE COUNT AND EXIT
10$:	MOVZBL	UCB$B_FEX(R5),R3	;GET FUNCTION DISPATCH INDEX
	CLRW	UCB$B_CV_STATE(R5)	;CLEAR INTERRUPT STATE AND STATUS
	CLRL	UCB$L_CV_BUFWIN(R5)	;CLEAR BUFFER WINDOW
	CASE	R3,<-			;DISPATCH TO FUNCTION HANCVING ROUTINE
		NOP,-			; NOP
		UNLOAD,-		; UNLOAD
		SEEK,-			; SEEK
		NOP,-			; RECALIBRATE (unsupported)
		DRVCLR,-		; DRVCLR
		NOP,-			; RELEASE PORT (unsupported)
		NOP,-			; OFFSET HEADS (unsupported)
		NOP,-			; RETURN TO CENTER (unsupported)
		PACKACK,-		; PACK ACKNOWLEDGE
		NOP,-			; SEARCH (unsupported)
		WRITECHECK,-		; WRITE CHECK (unsupported)
		WRITEDATA,-		; WRITE DATA
		READDATA,-		; READ DATA
		NOP,-			; WRITE HEADER (unsupported)
		NOP,-			; READ HEADER
		NOP,-			; place holder
		NOP,-			; place holder
		AVAILABLE-		; AVAILABLE
		>

NOP:					;NO-OP
WRITECHECK:				;WRITE CHECK
SEEK:					;SEEK
DRVCLR:					;DRIVE CLEAR (GET STATUS & RESET)
DO_FUNCTION:
	CLRB	UCB$B_FEX(R5)		;SET FUNCTION
	BSBW	FEXL			;EXECUTE FUNCTION
	.BYTE	RETRYERR-.-1		;ERROR OFFSET
	BRB	NORMAL			;DONE

PACKACK:				;PACK ACKNOWLEDGE (GET STATUS & RESET)
	BISW2	#UCB$M_VALID, -		;Set software volume valid bit.
		UCB$W_STS(R5)
	BRB	DO_FUNCTION		;Then go do hardware function.

UNLOAD:					;UNLOAD
AVAILABLE:				;AVAILABLE
	BICW2	#UCB$M_VALID, -		;Clear software volume valid bit.
		UCB$W_STS(R5)		;and go complete operation without
	BRB	NORMAL			;any hardware interaction.

READDATA:				;READ DATA
	BISB	#CV_M_RD,UCB$B_CV_STS(R5) ;SET READ FLAG
WRITEDATA:				;WRITE DATA
	BSBW	FEXL			;EXECUTE FUNCTION
	.BYTE	RETRYERR-.-1		;ERROR OFFSET
; 
; 	OPERATON COMPLETION
; 

NORMAL:					;SUCCESSFUL OPERATION COMPLETE
	MOVZWL	#SS$_NORMAL,R0		;SET NORMAL COMPLETION STATUS
	BRB	FUNCXT			;FUNCTION EXIT

RETRYERR:				;RETRIABLE ERROR
	DECB	UCB$B_ERTCNT(R5)	;ANY RETRIES LEFT?
	BEQL	FATALERR		;IF EQL - NO
	BRW	FDISPATCH		;RETRY FUNCTION

FATALERR:				;UNRECOVERABLE ERROR
	MOVZWL	#SS$_VOLINV,R0		;ASSUME VOLUME INVALID STATUS
	MOVQ	UCB$L_CV_CS(R5),R1	;GET CS IN R1 AND MP IN R2
	BBS	#CV_MP_V_VC,R2,FUNCXT	;IF SET - VOLUME INVALID

	MOVZWL	#SS$_WRITLCK,R0		;ASSUME WRITE LOCK ERROR STATUS
	BBC	#CV_MP_V_WL,R2,10$	;IF CLR - VOLUME NOT WRITE LOCKED
	BBS	#CV_MP_V_WGE,R2,FUNCXT	;IF SET - WRITE GATE ERROR
					;IF WL & WGE SET - WRITE LOCK ERROR

10$:	MOVZWL	#SS$_PARITY,R0		;ASSUME PARITY ERROR STATUS
	BBS	#CV_CS_V_CRC,R1,FUNCXT	;IF SET - CRC ERROR
					;OR DATAPATH PURGE ERROR
	BBC	#CV_CS_V_OPI,R1,20$ 	;HEADER NOT FOUND ERROR?
	BBS	#CV_CS_V_CVT,R1,FUNCXT	;IF OPI AND CVT SET - YES

20$:	MOVZWL	#SS$_DRVERR,R0		;ASSUME DRIVE ERROR STATUS
	BBS	#CV_CS_V_DE,R1,FUNCXT	;IF SET - DRIVE ERROR

	MOVZWL	#SS$_CTRLERR,R0		;ASSUME CONTROLLER ERROR STATUS

FUNCXT:					;FUNCTION EXIT
	PUSHL	R0			;SAVE FINAL REQUEST STATUS
	JSB	G^IOC$DIAGBUFILL	;FILL DIAGNOSTIC BUFFER IF PRESENT
	CMPB	#CDF_WRITECHECK,UCB$B_FEX(R5)  ;DRIVE RELATED FUNCTION?
	BGTRU	10$			;IF GTRU - YES
	CMPB	#CDF_AVAILABLE,UCB$B_FEX(R5)   ;DRIVE RELATED FUNCTION?
	BEQL	10$			;IF EQL  - YES
	MOVL	UCB$L_IRP(R5),R3	;RETRIEVE ADDRESS OF IRP
	ADDW3	UCB$W_BCR(R5),-		;CALCULATE BYTES TRANSFERRED
		IRP$W_BCNT(R3),2(SP)	;...
10$:	RELCHAN				;RELEASE CHANNEL IF OWNED

	CLRL	R1			;CLEAR SECOND STATUS LONGWORD
	POPL	R0			;RETRIEVE FINAL REQUEST STATUS
	REQCOM				;COMPLETE REQUEST


; 
; FEXL - RL11 HARDWARE FUNCTION EXECUTION 
; 
; THIS ROUTINE IS CALLED VIA A BSB WITH A BYTE IMMEDIATELY FOLLOWING THAT
; SPECIFIES THE ADDRESS OF AN ERROR ROUTINE. ALL DATA IS ASSUMED TO HAVE BEEN
; SET UP IN THE UCB BEFORE THE CALL. THE APPROPRIATE PARAMETERS ARE LOADED
; INTO THE CONSOLE STXCS AND THE FUNCTION IS INITIATED. THE RETURN ADDRESS
; IS STORED IN THE UCB AND A WAITFOR INTERRUPT IS EXECUTED. WHEN THE
; INTERRUPT OCCURS, CONTROL IS RETURNED TO THE CALLER.
; 
; INPUTS:
; 
; 	R5 = DEVICE UNIT UCB ADDRESS
; 
; 	00(SP) = RETURN ADDRESS OF CALLER
; 	04(SP) = RETURN ADDRESS OF CALLER'S CALLER
; 
; 	IMMEDIATELY FOLLOWING INLINE AT THE CALL SITE IS A BYTE WHICH CONTAINS
; 	A BRANCH DESTINATION TO AN ERROR RETRY ROUTINE.
; 
; OUTPUTS:
; 
; 	THERE ARE FOUR EXITS FROM THIS ROUTINE:
; 
; 	1. SPECIAL CONDITION - THIS EXIT IS TAKEN IF A POWER FAILURE OCCURS
; 		OR THE OPERATION TIMES OUT. IT IS A JUMP TO THE APPROPRIATE
; 		ERROR ROUTINE.  IN THE CASE OF A POWER FAILURE, THE RETRY
;		COUNT IS RESET AND RETRIES INITIATED.  IN THE CASE OF A
;		TIMEOUT, THE RETRY COUNT IS DECREMENTED AND RETRIES INITIATED
;		IF RETRIES REMAIN.
; 
; 	2. FATAL ERROR - THIS EXIT IS TAKEN IF A FATAL CONTROLLER OR DRIVE
; 		ERROR OCCURS OR IF ANY ERROR OCCURS AND ERROR RETRY IS EITHER
; 		INHIBITED OR EXHAUSTED. IT IS A JUMP TO THE FATAL ERROR EXIT
; 		ROUTINE.
; 
; 	3. RETRIABLE ERROR - THIS EXIT IS TAKEN IF A RETRIABLE CONTROLLER
; 		OR DRIVE ERROR OCCURS AND ERROR RETRY IS NEITHER INHIBITED
; 		NOR EXHAUSTED. IT CONSISTS OF TAKING THE ERROR BRANCH EXIT
; 		SPECIFIED AT THE CALL SITE.  RETRIES ARE ACCOMPLISHED BY
;		RESTARTING THE ENTIRE I/O OPERATION, RATHER THAN AT THE
;		BLOCK IN ERROR.
; 
; 	4. SUCCESSFUL OPERATION - THIS EXIT IS TAKEN IF NO ERRORS OCCUR
; 		DURING THE OPERATION. IT CONSISTS OF A RETURN INLINE.
; 
; 	IN ALL CASES IF AN ERROR OCCURS, AN ATTEMPT IS MADE TO LOG THE ERROR.
; 
; 	IN ALL CASES FINAL DEVICE REGISTERS ARE RETURNED VIA THE UCB.
; 
; 	UCB$W_BCR(R5) = NEGATIVE BYTES REMAINING TO TRANSFER
;
FEXL:					;FUNCTION EXECUTOR 
	POPL	UCB$L_DPC(R5)		;SAVE DRIVER PC VALUE
	MOVL	UCB$L_CRB(R5),R0	;GET ADDRESS OF PRIMARY CRB
	MOVL	CRB$L_INTD+VEC$L_IDB(R0),R1  ;GET ADDRESS OF IDB
	CMPL	R5,IDB$L_OWNER(R1)	;DOES THIS PROCESS OWN CHANNEL?
	BNEQ	10$			;IF NEQ - NO
	MOVL	IDB$L_CSR(R1),R4	;SET ASSIGNED CHANNEL CSR ADDRESS
	BRB	20$			;
10$:	REQPCHAN			;REQUEST CHANNEL (RETURNS R4 = CSR ADR)

20$:	CMPB	R3,#CDF_SEARCH		;TRANSFER FUNCTION?
	BGTRU	XFER			;BRANCH IF YES
; 
; IMMEDIATE FUNCTION EXECUTION
; 
; 	FUNCTIONS INCLUDE:
; 
; 		NO OPERATION,
; 		DRIVE CLEAR, AND
; 		PACK ACKNOWLEDGE
; 
; INPUTS:
; 	R5	- UCB ADDRESS
; 
; FUNCTIONAL DESRIPTION:
; 
; INTERRUPTS ARE LOCKED OUT, THE APPROPRIATE FUNCTION IS INITIATED WITH
; INTERRUPT ENABLE, AND A WAITFOR INTERRUPT AND KEEP CHANNEL IS EXECUTED.
; 

IMMED:					;IMMEDIATE FUNCTION EXECUTION
	DSBINT				;DISABLE INTERRUPTS
	BBC	#UCB$V_POWER,UCB$W_STS(R5),20$ ;BRANCH IF NOT POWERFAIL
	ENBINT				;POWER FAIL
	BRW	RETREG			;PROCESS POWER FAILURE

20$:	BISB2	#CV_M_STSONLY,UCB$B_CV_STS(R5) ;REQUEST STATUS ONLY
	MOVB	#ITC_STS1,UCB$B_CV_STATE(R5)	;SET STATE TO GETSTS1
	MOVZBL	#<READ_STATUS!STXCS_M_IE>,R0 ;LOAD THE FUNCTION
	MTPR	R0,#PR$_STXCS		;REQUEST STATUS
	WFIKPCH	RETREG,#59		;*** for debugging... ;WAITFOR INTERRUPT
	IOFORK				;RETURN FROM ISR-
					;CREATE FORK PROCESS (&JSB BACK TO ISR)
	BRW	RETREG			;

; 
; TRANSFER FUNCTION EXECUTION
; 
; 	FUNCTIONS INCLUDE:
; 
; 		WRITE DATA
; 		READ DATA
; 
; INPUTS:
; 	R4	- DEVICE CSR ADDRESS
; 	R5	- UCB ADDRESS
; 
; FUNCTIONAL DESCRIPTION:
; 
; THE TRANSFER PARAMETERS ARE LOADED INTO THE CONSOLE REGISTER,
; INTERRUPTS ARE LOCKED OUT, THE FUNCTION IS INITIATED, AND
; A WAITFOR INTERRUPT AND KEEP CHANNEL IS EXECUTED.
; 
; UPON RETURN FROM THE INTERRUPT SERVICE ROUTINE, THE TRANSFER WILL
; EITHER BE COMPLETE OR AN ERROR WILL HAVE BEEN DETECTED.
; 

XFER:					;TRANSFER FUNCTION EXECUTION
; 
; EXECUTE THE TRANSFER FUNCTION
; 
	DSBINT
	BBC	#UCB$V_POWER,UCB$W_STS(R5),20$ ;BRANCH IF NOT POWERFAIL
	ENBINT
	BRW	RETREG
;
; SET UP CONTENTS OF STXCS, AND SET MOVE ROUTINE ADDRESS
; FOR USE IN INTERRUPT ROUTINE.
;
20$:	MOVZBL	#<READ_BLOCK!STXCS_M_IE>,R3 ;ASSUME READING
	MOVAB	G^IOC$MOVTOUSER,R0	;SET MOVE ROUTINE ADDRESS
	BBS	#CV_V_RD,UCB$B_CV_STS(R5),40$ ;BRANCH IF READING
	MOVZBL	#<WRITE_BLOCK!STXCS_M_IE>,R3 ;SET FOR WRITING
	MOVAB	G^IOC$MOVFRUSER,R0	;SET MOVE ROUTINE ADDRESS
40$:	MOVW	#256,UCB$W_CV_BBC(R5)	;SET WORD COUNT
	MOVL	R0,UCB$L_CV_MVRTN(R5)	;SAVE MOVE ROUTINE ADDRESS
;
; SET LBN INTO R3
;
	INSV	UCB$L_MEDIA(R5),#STXCS_V_ADDRS,#STXCS_S_ADDRS,R3 ;
	MOVZWL	UCB$W_BCNT(R5),R0	;GET BYTE COUNT OF TRANSFER
	DIVL2	#512,R0			;COMPUTE # BLOCKS
	ADDL2	#2,R0			;THROW IN 2 EXTRA FOR GOOD LUCK
	MTPR	R3,#PR$_STXCS		;READ/WRITE REQUEST
					;ISR WILL NOT RETURN UNTIL COMPLETE
					;TRANSFER DONE OR ERROR DETECTED.
	WFIKPCH	RETREG,R0		;WAITFOR INTERRUPT AND KEEP CHANNEL
					;RETURN HERE FROM ISR SAVING REGISTERS
	IOFORK				;CREATE FORK PROCESS (RETURN TO ISR)
					;RETURN HERE FROM ISR REI ROUTINE
; 
; GET STATUS AND RESET ERRORS
; 
RETREG:					;GET STATUS AND RESET ERRORS
; 
; DETERMINE EXIT - SPECIAL CONDITION, FATAL ERROR, RETRIABLE ERROR, OR SUCCESS
; 
	SETIPL	UCB$B_FIPL(R5)		;ENSURE AT FORK IPL
	BBSC	#CV_V_STSERROR,UCB$B_CV_STS(R5),260$ ;BRANCH IF GETSTS ERROR
	BBSC	#CV_V_ABORT,UCB$B_CV_STS(R5),240$ ;BRANCH IF ISR SAID TO ABORT
	CMPB	UCB$B_CV_STATE(R5),#ITC_STS2 ;DID WE GET STATUS?
	BNEQ	20$			;NO, MUST BE POWERFAIL OR TIMEOUT
	MOVQ	UCB$L_CV_CS(R5),R0	;GET CS AND MP REGISTERS IN R0/R1
	CMPZV	#0,#5,R1,-		;HEADS, BRUSHES, STATE OK?
		#<CV_MP_M_BH!CV_MP_M_HO!CV_SLM>  ;...
	BEQL	20$			;IF EQL - YES, ONLINE
	BICW2	#UCB$M_TIMOUT,UCB$W_STS(R5)  ;CLEAR DEVICE TIME OUT
	MOVZWL	#SS$_MEDOFL,R0		;SET MEDIUM OFFLINE STATUS
	BRW	FUNCXT			;RETURN
20$:	BITW	#UCB$M_POWER!-		;POWER FAIL OR DEVICE TIMEOUT?
		UCB$M_TIMOUT,UCB$W_STS(R5)  ;...
	BEQL	30$			;IF EQL NO
	BRW	SPECOND			;YES - SPECIAL CONDITION

30$:	BBS	#CV_MP_V_VC,R1,200$	;IF SET - VOLUME INVALID
	BBC	#CV_CS_V_CE,R0,100$	;IF CLEAR RL11 OK
40$:	JSB	G^ERL$DEVICERR		;ALLOCATE AND FILL ERROR MESSAGE BUFFER
	BBS	#IO$V_INHRETRY,UCB$W_FUNC(R5),200$  ;IF SET - RETRY INHIBITED
	MOVQ	UCB$L_CV_CS(R5),R0	;GET CS AND MP REGISTERS IN R0/R1
	BBS	#CV_CS_V_NXM,R0,200$	;IF SET - NONEXISTENT MEMORY
	BBC	#CV_CS_V_DE,R0,80$	;IF CLR - NO DRIVE ERRORS
	BBC	#CV_MP_V_WL,R1,60$	;IF CLR - NOT WRITE LOCKED 
	BBS	#CV_MP_V_WGE,R1,200$	;IF WL & WGE SET - WL ERROR
60$:	BITW	#<CV_MP_M_WDE!-		;WRITE DATA ERROR, OR
		CV_MP_M_CHE!-		;CURRENT HEAD ERROR, OR
		CV_MP_M_WGE!-		;WRITE GATE ERROR, OR
		CV_MP_M_DSE>,R1		;DRIVE SELECT ERROR?
	BNEQ	200$			;IF NEQ - YES
; 
; RETRIABLE ERROR EXIT
; 
80$:	CVTBL	@UCB$L_DPC(R5),-(SP)	;GET BRANCH DISPLACEMENT
	ADDL2	(SP)+,UCB$L_DPC(R5)	;CALCULATE RETURN ADDRESS - 1
; 
; SUCCESSFUL OPERATION EXIT
; 
100$:	INCL	UCB$L_DPC(R5)		;ADJUST TO CORRECT RETURN ADDRESS
	JMP	@UCB$L_DPC(R5)		;RETURN TO DRIVER
; 
; FATAL ERROR EXIT
; 
200$:
	BSBB	ABORT_RESET_STATUS	;DO AN ABORT AND RESET STATUS
	BRW	FATALERR		;FATAL ERROR EXIT
;
; ISR DETECTED ERROR.  TELL CONSOLE TO ABORT, AND TRY AGAIN IF WE CAN
;
240$:	BSBB	ABORT_RESET_STATUS	;ABORT AND RESET STATUS
	BRB	80$			;TRY AGAIN IF RETRIES LEFT
;
; CONSOLE REPORTED ERROR DURING GET STATUS INTERRUPT
;
260$:	BSBB	RESET_STATUS_ONLY	;RESET STATUS ONLY
	BRB	80$			;TRY AGAIN IF RETRIES LEFT
; 
; SPECIAL CONDITION EXIT (POWER FAILURE OR DEVICE TIMEOUT)
; 
SPECOND:
	BBS	#UCB$V_POWER,UCB$W_STS(R5),PWRFAIL  ;IF SET - POWER FAILURE
					;IF CLR - DEVICE TIMEOUT
	JSB	G^ERL$DEVICTMO		;LOG DEVICE TIMEOUT
	BICW2	#UCB$M_TIMOUT,UCB$W_STS(R5)  ;CLEAR TIMEOUT STATUS
	MOVZWL	#SS$_TIMEOUT,R0		;SET DEVICE TIMEOUT STATUS
	DECB	UCB$B_ERTCNT(R5)	;ANY ERROR RETRIES REMAINING?
	BEQL	RESETXFR		;IF EQL - NO
	BSBB	ABORT_RESET_STATUS	;ABORT AND RESET STATUS
	BRW	FDISPATCH		;RETRY FUNCTION AGAIN

RESETXFR:				;RESET TRANSFER BYTE COUNT
	BSBB	ABORT_RESET_STATUS	;ABORT TRANSFER AND RESET STATUS
	MOVL	UCB$L_IRP(R5),R3	;GET ADDRESS OF I/O PACKET
	MNEGW	IRP$W_BCNT(R3),UCB$W_BCR(R5)  ;RESET BYTE COUNT
	BRW	FUNCXT			;EXIT

PWRFAIL:				;POWER FAILURE
	BICW2	#UCB$M_POWER,UCB$W_STS(R5)  ;CLEAR POWER FAILURE BIT
	BSBB	ABORT_RESET_STATUS	;ABORT AND RESET STATUS
	RELCHAN				;RELEASE CHANNEL IF OWNED
	MOVL	UCB$L_IRP(R5),R3	;GET ADDRESS OF I/O PACKET
	MOVQ	IRP$L_SVAPTE(R3),-	;RESTORE TRANSFER PARAMETERS
		UCB$L_SVAPTE(R5)	;...
	BRW	PREPROCESS		;RETURN TO PREPROCESS UCB FIELDS
;
; ISSUE AN ABORT TO THE CONSOLE.  WHEN THE ABORT COMPLETES, READ
; THE RL11 STATUS REGISTERS, ASSERTING RST.
;
; THIS ROUTINE DESTROYS R0-R3
;
	.ENABLE	LOCAL_BLOCK

RESET_STATUS_ONLY:
	POPL	UCB$L_CV_ABPC(R5)	;POP RETURN ADDRESS FROM STACK
	BRB	30$			;GO EXECUTE

ABORT_RESET_STATUS:
	POPL	UCB$L_CV_ABPC(R5)	;POP RETURN ADDRESS FROM STACK
	MOVB	#ITC_ABORT,UCB$B_CV_STATE(R5) ;SET DISPATCH
	DSBINT				;DISABLE INTERRUPTS
	MOVZBL	#<ABORT_TRANSFER!STXCS_M_IE>,R0 ;SETUP FUNCTION
	MTPR	R0,#PR$_STXCS		;TELL THE CONSOLE TO ABORT
	WFIKPCH	20$,#6
20$:	IOFORK
30$:	MOVQ	UCB$L_CV_CS(R5),UCB$Q_CV_CSMP(R5) ;SAVE CS/MP REGISTERS
	TIMEDWAIT TIME=#600*1000,-	;WAIT FOR CONSOLE TO BE READY
		INS1=<MFPR	#PR$_STXCS,R2>,- ;READ STATUS REGISTER
		INS2=<BBS	#STXCS_V_RDY,R2,40$>,- ;BRANCH IF READY
		DONELBL=40$				;TO SAME PLACE AS DONE
;
; ** WHAT DO WE DO IF THE CONSOLE DOES NOT GO READY IN TIME?
;
	MOVB	#ITC_RESET1,UCB$B_CV_STATE(R5) ;SET DISPATCH
	DSBINT				;DISABLE INTERRUPTS
	MTPR	#<STATUS_RESET!STXCS_M_IE>,#PR$_STXCS ;REQUEST STATUS WITH RST ASSERTED
	WFIKPCH	60$,#6			;WAITFOR INTERRUPT
60$:	IOFORK
	MOVQ	UCB$Q_CV_CSMP(R5),UCB$L_CV_CS(R5) ;RESTORE CS/MP REGISTERS
	JMP	@UCB$L_CV_ABPC(R5)	;RETURN TO CALLER

	.DISABLE LOCAL_BLOCK

	.SBTTL	INTERRUPT SERVICE ROUTINE
;++
; CV$INT - VAX 8600 CONSOLE RL02 INTERRUPT SERVICE ROUTINE
; 
; FUNCTIONAL DESCRIPTION:
; 
; 	THIS ROUTINE IS ENTERED VIA A JSB INSTRUCTION WHEN AN INTERRUPT
; 	OCCURS ON THE VAX 8600 CONSOLE STXCS REGISTER. IF THE INTERRUPT
;	IS NOT EXPECTED, THE UNSOLICITED INTERRUPT ROUTINE DISMISSES
;	THE INTERRUPT. IF THE INTERRUPT IS EXPECTED, DEVICE REGISTERS
;	ARE SAVED AND THE DRIVER IS CALLED AT ITS INTERRUPT RETURN ADDRESS.
;	THE DRIVER FORKS, CAUSING A RETURN TO THIS ROUTINE,
;	WHICH RESTORES GENERAL REGISTERS AND DISMISSES THE INTERRUPT. 
; 
; INPUTS:
; 
; 	00(SP)	- POINTER TO ADDRESS OF THE IDB 
; 	04(SP)	- SAVED R0
; 	08(SP)	- SAVED R1
; 	12(SP)	- SAVED R2
; 	16(SP)	- SAVED R3
; 	20(SP)	- SAVED R4
; 	24(SP)	- SAVED R5
; 	28(SP)	- PC AT THE TIME OF THE INTERRUPT
; 	32(SP)	- PSL AT THE TIME OF THE INTERRUPT
; 
; OUTPUTS:
; 
; 	DEVICE REGISTERS ARE SAVED, IPL IS LOWERED TO FORK LEVEL, THE
; 	INTERRUPT IS DISMISSED, ALL REGISTERS EXCEPT R0-R5 ARE PRESERVED.
;
;--

CV_INT::				;INTERRUPT SERVICE ROUTINE
	MOVL	@(SP)+,R3		;REMOVE ADDRESS OF IDB FROM STACK
	MOVQ	(R3),R4			;GET ADDRESS OF CSR AND UCB
	TSTL	R5			;IS R5 A ZERO
	BEQL	CV_UNSOLNT		;IF EQL NO OWNER
	MFPR	#PR$_STXCS,R3		;**TEMP** READ CONSOLE STATUS
	BBC	#STXCS_V_RDY,R3,CV_UNSOLNT ;**TEMP** BRANCH IF NOT READY
	BBCC	#UCB$V_INT,-		;IF CLR - INTERRUPT NOT EXPECTED
		UCB$W_STS(R5),CV_UNSOLNT  ;...
CV_INT_DISP:
	MOVZBL	UCB$B_CV_STATE(R5),R3	;GET INTERRUPT STATE
	BEQL	CV_INT_XFR		;BRANCH IF TRANSFER INTERRUPT
	CASE	R3,<-			; AND DISPATCH
		CV_INT_XFR,-		;TRANSFER INTERRUPT
		CV_INT_STS1,-		;FIRST PART OF STATUS
		CV_INT_STS2,-		;SECOND PART OF STATUS
		CV_INT_ABORT,-		;ABORT REQUEST
		CV_INT_RSTS1,-		;GET STATUS WITH RST ASSERTED
		CV_INT_RSTS2>,-
		TYPE=B

CV_UNSOLNT:				;UNSOLICITED INTERRUPT
	POPR	#^M<R0,R1,R2,R3,R4,R5>	;RESTORE R0-R5
	REI				;RETURN FROM INTERRUPT
;
; GET STATUS WITH RESET INTERRUPT
;
CV_INT_RSTS1:
	MFPR	#PR$_STXDB,UCB$L_CV_CS(R5) ;READ CONTROL/STATUS REGISTER
	MOVB	#ITC_RESET2,UCB$B_CV_STATE(R5) ;SET NEXT STATE
	MTPR	#<STATUS_RESET!STXCS_M_IE>,#PR$_STXCS
	BISB2	#UCB$M_INT,UCB$W_STS(R5) ;FLAG INTERRUPT EXPTECTED
	BRB	CV_UNSOLNT
CV_INT_RSTS2:
	MFPR	#PR$_STXDB,UCB$L_CV_MP(R5) ;SAVE MULTIPURPOSE REGISTER
CV_INT_ABORT:
	JSB	@UCB$L_FPC(R5)		;CALL DRIVER AT INTERRUPT RETURN ADDR
	BRB	CV_UNSOLNT
;
; TRANSFER INTERRUPT
;
CV_INT_XFR:
	MFPR	#PR$_STXCS,R3		;GET STATUS REGISTER
	EXTZV	#STXCS_V_STS,#STXCS_S_STS,R3,R3 ;GET CONSOLE RL02 STATUS
	CMPL	#TRANS_CONTINUE,R3	;CONTINUE TRANSACTION?
	BEQL	10$			;YES, CONTINUE
	BRW	400$			;ELSE BRANCH TO ABORT
10$:	BBC	#CV_V_RD,UCB$B_CV_STS(R5),200$ ;BRANCH IF WRITING
;
; OPERATION IS A READ FROM DISK
;
	MFPR	#PR$_STXDB,-(SP)	;READ DATA ONTO STACK
	MOVZBL	#<READ_BLOCK!STXCS_M_IE>,R1 ;SET NEXT READ
	INSV	UCB$L_MEDIA(R5),#STXCS_V_ADDRS,#STXCS_S_ADDRS,R1 ;SET LBN
	MTPR	R1,#PR$_STXCS		;CONTINUE READING
	TSTW	UCB$W_BCR(R5)		;HAVE WE COMPLETED THE REQUEST?
	BEQL	20$			;IF EQL YES, DON'T WRITE TO BUFFER
	MOVL	SP,R1			;GET ADDRESS OF DATA
	MOVL	#2,R2			;WRITE 2 BYTES INTO USER BUFFER
	MOVL	UCB$L_CV_BUFWIN(R5),R0	;GET BUFFER ADDRESS
	JSB	@UCB$L_CV_MVRTN(R5)	;WRITE INTO USER BUFFER
	MOVL	R0,UCB$L_CV_BUFWIN(R5)	;SAVE WINDOW INTO USER BUFFER
	MOVAB	G^IOC$MOVTOUSER2,UCB$L_CV_MVRTN(R5) ;SET MOVE ROUTINE ADDRESS
	ADDW2	#2,UCB$W_BCR(R5)	;COUNT TWO MORE BYTES TRANSFERRED
20$:	ADDL2	#4,SP			;CLEAR DATA FROM STACK
	DECW	UCB$W_CV_BBC(R5)	;COUNT ANOTHER WORD TRANSFERRED
	BLSS	120$			;PROTOCOL ERROR
	MFPR	#PR$_STXCS,R4		;READ STXCS
	BBS	#STXCS_V_RDY,R4,CV_INT_XFR ;BRANCH IF DONE AGAIN
	BISB2	#UCB$M_INT,UCB$W_STS(R5);FLAG INTERRUPT EXPECTED
100$:	BRW	CV_UNSOLNT		;EXIT THIS INTERRUPT
120$:	BISB2	#CV_M_ABORT,UCB$B_CV_STS(R5) ;FLAG TO ABORT AND RETRY
	BRW	CV_INT_ABORT		;CALL DRIVER TO DO IT
;
; WRITING TO DISK
;
200$:	TSTW	UCB$W_BCR(R5)		;REQUEST COMPLETE?
	BEQL	220$			;IF EQL YES DON'T BOTHER FETCHING
	MOVAB	UCB$L_CV_IBUF(R5),R1	;GET ADDRESS OF INTERNAL BUFFER
	MOVL	#2,R2			;SET NUMBER OF BYTES
	MOVL	UCB$L_CV_BUFWIN(R5),R0	;GET BUFFER WINDOW
	JSB	@UCB$L_CV_MVRTN(R5)	;GET 2 BYTES FROM USERS BUFFER
	MOVL	R0,UCB$L_CV_BUFWIN(R5)	;SAVE WINDOW
	MOVAB	G^IOC$MOVFRUSER2,UCB$L_CV_MVRTN(R5) ;SET MOVE ROUTINE
	ADDW2	#2,UCB$W_BCR(R5)	;COUNT TWO MORE BYTES
220$:	MTPR	UCB$L_CV_IBUF(R5),#PR$_STXDB ;WRITE WORD TO CONSOLE
	TSTW	UCB$W_BCR(R5)		;REQUEST COMPLETE?
	BNEQ	240$			;IF NEQ NO
	CLRL	UCB$L_CV_IBUF(R5)	;YES, CLEAR BUFFER SO WE WRITE 0'S
240$:	DECW	UCB$W_CV_BBC(R5)	;COUNT ANOTHER WORD TRANSFERRED
250$:	BLSS	280$			;PROTOCOL ERROR
	MOVZBL	#<WRITE_BLOCK!STXCS_M_IE>,R1 ;REQUEST TO SEND AGAIN
	INSV	UCB$L_MEDIA(R5),#STXCS_V_ADDRS,#STXCS_S_ADDRS,R1 ;SET LBN
	MTPR	R1,#PR$_STXCS		;SEND COMMAND TO CONSOLE
260$:	BISB2	#UCB$M_INT,UCB$W_STS(R5);FLAG INTERRUPT EXPECTED
	BRW	CV_UNSOLNT		;DISMISS INTERRUPT
280$:	BISB2	#CV_M_ABORT,UCB$B_CV_STS(R5) ;FLAG TO ABORT AND RETRY
	BRW	CV_INT_ABORT		;CALL DRIVER TO DO IT
;
; TRANSACTION COMPLETE, OR ERROR DETECTED.  REQUEST STATUS
;
400$:	CMPB	#HANDSHAKE_ERROR,R3	;WAS THERE A HANDSHAKE ERROR?
	BEQL	440$			;BRANCH IF YES
	TSTW	UCB$W_CV_BBC(R5)	;ALL WORDS TRANSFERRED?
	BNEQ	460$			;IF NEQ NO
420$:	MOVB	#ITC_STS1,UCB$B_CV_STATE(R5) ;SET NEXT STATE
	MTPR	#<READ_STATUS!STXCS_M_IE>,#PR$_STXCS ;REQUEST STATUS
	BISB2	#UCB$M_INT,UCB$W_STS(R5);FLAG INTERRUPT EXPECTED
	BRW	CV_UNSOLNT		;DISMISS INTERRUPT
;
; HANDSHAKE ERROR.  TELL DRIVER TO ABORT AND RETRY
;
440$:	NOP				;**DEBUG
;
; NOT ALL WORDS TRANSFERRED.  TELL DRIVER TO ABORT AND RETRY
;
460$:	BISB2	#CV_M_ABORT,UCB$B_CV_STS(R5) ;FLAG TO ABORT AND RETRY
	BRW	CV_INT_ABORT		;CALL DRIVER TO DO IT
;
; ERROR ON GET STATUS OPERATION
;
CV_STSERROR:
	BISB2	#CV_M_STSERROR,UCB$B_CV_STS(R5) ;FLAG GET STATUS ERROR
	BRW	CV_INT_ABORT		;CALL DRIVER TO PROCESS ERROR
;
; GET STATUS PART 1 INTERRUPT
;
CV_INT_STS1:
	MFPR	#PR$_STXCS,R3		;READ STXCS REGISTER
	BBS	#31,R3,CV_STSERROR	;BRANCH IF ERROR GETTING STATUS
	MFPR	#PR$_STXDB,UCB$L_CV_CS(R5) ;GET THE CONTROL/STATUS REGISTER
	MOVB	#ITC_STS2,UCB$B_CV_STATE(R5)	;SET NEXT STATE
	MTPR	#<READ_STATUS!STXCS_M_IE>,#PR$_STXCS ;REQUEST IT
	BISB2	#UCB$M_INT,UCB$W_STS(R5);FLAG INTERRUPT EXPECTED
	BRW	CV_UNSOLNT		;DISMISS INTERRUPT
;
; GET STATUS PART 2 INTERRUPT
;
CV_INT_STS2:
	MFPR	#PR$_STXCS,R3		;READ STXCS REGISTER
	BBS	#31,R3,CV_STSERROR	;BRANCH IF ERROR GETTING STATUS
	MFPR	#PR$_STXDB,UCB$L_CV_MP(R5) ;GET MULTIPURPOSE REGISTER
	BBS	#CV_V_STSONLY,UCB$B_CV_STS(R5),20$ ;BRANCH IF STATUS ONLY
;
; TRANSFER OF A BLOCK IS COMPLETE.  SEE IF ERRORS, AND PROCESS IF SO.
; IF NO ERRORS, THEN SEE IF DONE WITH COMPLETE TRANSFER
;
	MOVQ	UCB$L_CV_CS(R5),R0	;GET CS AND MP REGISTERS
	CMPZV	#0,#5,R1,-		;HEADS AND BRUSHES OK?
			#<CV_MP_M_BH!CV_MP_M_HO!CV_SLM>
	BNEQ	20$			;IF NEQ NO
	BITW	#<CV_CS_M_CE!CV_CS_M_DE!CV_CS_M_NXM>,R0
	BNEQ	20$			;IF NEQ ERROR OF SOME SORT
	BITW	#<CV_MP_M_WDE!-
		CV_MP_M_CHE!-
		CV_MP_M_WGE!-
		CV_MP_M_DSE!-
		CV_MP_M_VC>,R1		;ANY ERRORS?
	BNEQ	20$			;IF NEQ YES
	INCL	UCB$L_MEDIA(R5)		;NEXT LBN
	TSTW	UCB$W_BCR(R5)		;ARE WE DONE YET?
	BNEQ	40$			;BRANCH IF NOT DONE YET
20$:	JSB	@UCB$L_FPC(R5)		;CALL DRIVER AT INTERRUPT RETURN ADDR
30$:	BRW	CV_UNSOLNT		;DISMISS
;
; MORE DATA TO TRANSFER STILL
;
40$:	MOVW	#256,UCB$W_CV_BBC(R5)	;RESET BYTE COUNT FOR BLOCK
	CLRB	UCB$B_CV_STATE(R5)	;RESET STATE TO READ MODE
	MOVZBL	#<READ_BLOCK!STXCS_M_IE>,R3 ;ASSUME READING
	BBS	#CV_V_RD,UCB$B_CV_STS(R5),60$ ;BRANCH IF READING
	MOVZBL	#<WRITE_BLOCK!STXCS_M_IE>,R3 ;SET FOR WRITING
60$:	INSV	UCB$L_MEDIA(R5),#STXCS_V_ADDRS,#STXCS_S_ADDRS,R3 ;SET LBN
	MTPR	R3,#PR$_STXCS		;SEND COMMAND TO CONSOLE
	BISB2	#UCB$M_INT,UCB$W_STS(R5);FLAG INTERRUPT EXPECTED
	BRW	CV_UNSOLNT		;EXIT INTERRUPT

CVPATCH::
	.BLKL	32

	.SBTTL	REGISTER DUMP ROUTINE
;++
; 
; CV_REGDUMP - REGISTER DUMP ROUTINE
; 
; FUNCTIONAL DESCRIPTION:
; 
; THIS ROUTINE IS CALLED TO SAVE THE DEVICE REGISTERS AND UBA RESOURCE
; REGISTERS IN A SPECIFIED BUFFER. IT IS CALLED FROM THE DEVICE ERROR
; LOGGING ROUTINE AND FROM THE DIAGNOSTIC BUFFER FILL ROUTINE.
; 
; INPUTS:
; 
; 	R0	- ADDRESS OF REGISTER SAVE BUFFER
; 	R4	- ADDRESS OF DEVICE CONTROL STATUS REGISTER (CSR)
; 	R5	- ADDRESS OF UNIT CONTROL BLOCK (UCB)
; 
; OUTPUTS:
; 
; 	THE DEVICE AND UBA REGISTERS ARE SAVED IN THE SPECIFIED BUFFER.
; 	R0 CONTAINS THE ADDRESS OF THE NEXT EMPTY LONGWORD IN THE BUFFER.
; 	ALL REGISTERS EXCEPT R1 AND R2 ARE PRESERVED.
; 
;--

CV_REGDUMP:				;REGISTER DUMP ROUTINE
	MOVL	#<CV_NUM_REGS+5>,(R0)+	;INSERT NUMBER OF REGISTERS
	MOVZWL	UCB$L_CV_CS(R5),(R0)+	;COPY CONTROL/STATUS REGISTER
	CLRQ	(R0)+			;NO BA/DA REGISTERS
	MOVZWL	UCB$L_CV_MP(R5),(R0)+	;COPY MULTIPURPOSE REGISTER
	CLRQ	(R0)+			;NO DATAPATH NUMBER/DATAPATH REGISTER
	CLRQ	(R0)+			;NO FINAL MAP REG/PREVIOUS MAP REG
	CLRL	(R0)+			;NO DATAPATH PURGE ERROR REGISTER
	RSB				;RETURN

CV_END:					;ADDRESS OF LAST LOCATION IN DRIVER
	.END
