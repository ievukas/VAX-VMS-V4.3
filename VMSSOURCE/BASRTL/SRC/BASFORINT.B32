%TITLE 'BAS$$FORMAT_INT - Basic format interpreter'
MODULE BAS$$FOR_INT (				! Basic format interpreter
		IDENT = '2-013'		! File: BASFORINT.B32 EDIT:MDL2013
		) =
BEGIN
!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY:
!
! Basic support library - not user callable
!
! ABSTRACT:
!
!	This is the format interpreter for Basic PRINT USING and FORMAT$.
!
! ENVIRONMENT:	User access mode, AST reentrant
!
! AUTHOR: Donald G. Petersen, CREATION DATE: 03-May-79
!
! MODIFIED BY:
!
! 	DGP,03-May-79 : VERSION 1
! 1-001	- original
! 1-002	- Get TPAMAC from SYS$LIBRARY.  JBS 22-MAY-1979
! 1-003 - Add PSECT declaration and make BAS$$FORMAT_INT global.  DGP 22-May-79
! 1-004 - Remove comment from switches statement.  DGP 22-May-79
! 1-005 - The TPARSE parameter block is passed by value using a CALLG.  Change
!	  the MAP of the formal in each action routine.  DGP  23-May-79
! 1-006 - The TPARSE argument list for the action routines is not quite right.
!	  AP is needed as a BUILTIN.  DGP 29-May-79
! 1-007 - Change error routine call to BAS$$STOP from BAS$$STOP_IO 'cuz
!	  the format interpreter knows nothing about I/O.  DGP 29-May-79
! 1-008 - Add BAS$$ prefix to PUKEYWDS and PRINT_USING.  DGP 30-May-79
! 1-009	- Change the names of the STR linkages.  JBS 04-JUN-1979
! 1-010 - Change length of K_INTER_STO_LEN to be 28.  Bug fix.  DGP 12-Jul-79
! 1-011	- Make PERCENT be a macro rather than a BIND.  JBS 14-JUL-1979
! 1-012	- Change calls to STR$COPY.  JBS 16-JUL-1979
! 1-013 - Make PERCENT a BIND rather than a macro.  DGP 16-Jul-79
! 1-014 - Work on numerics some.  DGP 16-Jul-79
! 1-015 - Add V_PERIOD.  DGP 20-Jul-79
! 1-016 - Bug fix in double precision floating.  DGP 30-Jul-79
! 1-017 - Yes, E format can have a (negative) number which won't fit.  DGP
!	  30-Jul-79
! 1-018 - Retro fit floating into integer.  DGP  01-Aug-79
! 1-019	- Use REQUIRE rather than LIBRARY to read TPAMAC, so we can try
!	   new BLISS compiler.  JBS 06-SEP-1979
! 1-020	- Go back to using LIBRARY, but use a logical name.  JBS 12-SEP-1979
! 1-021 - Initialize all null string desc. pointers to 0.  DGP 18-Sep-79
! 1-022 - Translate SYS$CURRENCY, SYS$RADIX_POINT, and SYS$DIGIT_SEP.  DGP
!	  30-Oct-79
! 1-023 - Return all temporary strings allocated from HEAP store.  DGP 08-Nov-79
! 1-024 - Receive the scale factor and pass it along to the conversion routines.
!	  DGP 25-Nov-79
! 2-001 - Add routines to use SPANC, SCANC, etc. instructions instead of
!	  LIB$TPARSE for performance optimizations.  Replace use of STR$CONCAT
!	  with STR$APPEND in OUTPUT_ARG where possible.  DJB 08-Jun-1981.
! 2-002 - Add support for byte, g floating, and h floating.  PLL 26-Aug-81
! 2-003 - Add f format for h floating.  PLL 8-Sep-81
! 2-004 - Add <CD>, <%>, <0>, and _ format characters. PLL 23-Nov-81
! 2-005 - Add support for packed decimal.  PLL 12-Jan-82
! 2-006 - Change calls to STR$APPEND to STR$CONCAT so that static string destinations
! 	  will work.  PLL 20-Apr-82
! 2-007 - allow both <CD> and <cd> format.  MDL 9-Aug-1982
! 2-008 - fix bug in processing underscores; shouldn't EXITLOOP in SPAN_CONSTANT
!	  after handling underscore as there may be more constant following it.
!	  MDL  10-Aug-1982
! 2-009 - Fix section in SPAN_CONSTANT on underscores.  
!	  A new class was added to CLASS_TABLE, mask_special, so that SCANC
!	  will pick up any format character and not just characters which
!	  begin a format sequence, for underscore.  PLL 28-Sep-1982
! 2-010 - SPAN_BRACKET should only look ahead 1 character when searching
!	  for the start of a valid <> sequence.  Other formatting characters
!	  may be bypassed in the case where <> is in an unexpected place.
!	  SPAN_CONSTANT must check for multi-char format sequences after an
!	  underscore.  For instance, '$$' must appear in multiples - a single
!	  '$' is not a valid format sequence.  So if '_$$' appears, include
!	  both '$$' in the constant.
!	  Yet another class was added to CLASS_TABLE, so that characters
!	  which follod '<' can be scanned.
!	  PLL 5-Oct-1982
! 2-011	- make <CD> at the beginning of a format sequence a constant in
!	  order to be consistent with BP2, rather than an error.
!	  MDL 9-Dec-1982
! 2-012 - fix case of $$<0>##.  BP2 treats this as 2 fields; the first being
!	  a dollar sign followed by a single digit, and the second a 3-digit
!	  field with leading zeroes.  Previously, we had treated this as a
!	  single field.  MDL 10-Dec-1982
! 2-013 - Fix case of a single underscore not followed by anything.  We
!	  should just ignore this.  Also fix case of <CD at the end of
!	  a format string; both these cases cause infinite loops.
!	  It is now apparent that whereas VAX-11 BASIC Run-Time code treats
!	  underscores not followed by format characters as literals, BP2
!	  treats these as something to be ignored.  MDL 18-Mar-1983 
!--

!<BLF/PAGE>

%SBTTL 'Declarations'
!
! SWITCHES:
!

SWITCHES ADDRESSING_MODE (EXTERNAL = GENERAL, NONEXTERNAL = WORD_RELATIVE);

!
! LINKAGES:
!

REQUIRE 'RTLIN:OTSLNK';			! macros for all linkages except STR$

REQUIRE 'RTLIN:STRLNK';			! macros for STR$ linkages

!
! TABLE OF CONTENTS:
!

FORWARD ROUTINE
    BAS$$FORMAT_INT : NOVALUE,		! the Basic format interpreter

!+
! A possible optimization in the future could be to make these internal
! routines JSB entry points.  This should be done after the full range
! of planned format characters is implemented (or allowed for).
!-

    DECODE_PROCESS_FORMAT,		! main driving routine
    SPAN_CONSTANT,			! find start of formatting sequence
    SPAN_SINGLE_QUOTE,			! process single quote format classes
    SPAN_TEXT,				! span various text format classes
    SPAN_BACKSLASH,			! process backslash format class
    SPAN_BRACKET,			! process < > format classes
    SPAN_NUMERIC,			! process numeric format class
    OUTPUT_ARG;				! do all of the formatting

!
! INCLUDE FILES:
!

REQUIRE 'RTLIN:RTLPSECT';		! Declare Psects macros

LIBRARY 'RTLSTARLE';			! STARLET library for macros and symbols

!
! MACROS:
!

MACRO
    RET_STR = 0, 0, 32, 0%,
    PU_MASK = 4, 0, 32, 0%,
    ELEM_TYPE = 8, 0, 32, 0%,
    ELEM = 12, 0, 32, 0%,
    FRACTION_DIGIT = 16, 0, 32, 1%,
    INTEGER_DIGITS = 20, 0, 32, 1%,
    CHARACTER = 24, 0, 32, 1%,
    SCALE_FACTOR = 28, 0, 32, 1%,
    NEXT_CHAR = 32, 0, 32, 0%;

!
! EQUATED SYMBOLS:
!

LITERAL

!+
! These literals define the bits in the PRINT USING mask (PU_MASK)
! NOTE: These are well ordered.  Action routines take advantage of the
! fact that:
! F format is < E_MASK
! E_MASK <= E format < R_JUSTIFY_MASK
! Text is >= R_JUSTIFY_MASK
! Be careful when adding new values
!-

    NUMERIC_MASK = 1,			! numeric format
    MINUS_MASK = 2,			! trailing minus required
    COMMA_MASK = 4,			! digit group separator required
    DOLLAR_MASK = 8,			! floating currency required
    STAR_MASK = 16,			! asterisk fill required

!+
! bit 5 (value = 32) should not be used unless we run out of bits
! The conversion routines use almost the same bits for the same things
! and bit 5 means strip_trailing_spaces.
!-

    PERIOD_MASK = 64,			! a period is in the format
    E_MASK = 128,			! number should be in E format
    R_JUSTIFY_MASK = 256,		! right justify the string
    C_JUSTIFY_MASK = 512,		! center justify the string
    EXTEND_MASK = 1024,			! extend the string as necessary
    L_JUSTIFY_MASK = 2048,		! left justify the string
    PERCENT_MASK = 4096,		! suppress zeroes mask
    ZERO_MASK = 8192,			! print leading zeroes mask
    CD_MASK = 16384,			! credit/debit mask
    K_CVT_FLAGS = 28767,		! turn off flags not interesting to
    					! conversion routine
    K_INTER_STO_LEN = 36,		! length of local interpreter store
    					! in bytes
    K_AST_FLAG = 1,			! 0 - do not disable ASTs
					! 1 - disable ASTs

!+
! ASCII character codes.
!-

    CHAR_SPACE = 32 : UNSIGNED (8),
    CHAR_EXCLAMATION = 33 : UNSIGNED (8),
    CHAR_POUND = 35 : UNSIGNED (8),
    CHAR_DOLLAR = 36 : UNSIGNED (8),
    CHAR_SINGLE_QUOTE = 39 : UNSIGNED (8),
    CHAR_STAR = 42 : UNSIGNED (8),
    CHAR_COMMA = 44 : UNSIGNED (8),
    CHAR_MINUS = 45 : UNSIGNED (8),
    CHAR_PERIOD = 46 : UNSIGNED (8),
    CHAR_BACKSLASH = 92 : UNSIGNED (8),
    CHAR_CARAT = 94 : UNSIGNED (8),
    CHAR_C = 67 : UNSIGNED (8),
    CHAR_E = 69 : UNSIGNED (8),
    CHAR_L = 76 : UNSIGNED (8),
    CHAR_R = 82 : UNSIGNED (8),
    CHAR_LOWER_C = 99 : UNSIGNED (8),
    CHAR_LOWER_E = 101 : UNSIGNED (8),
    CHAR_LOWER_L = 108 : UNSIGNED (8),
    CHAR_LOWER_R = 114 : UNSIGNED (8),
    CHAR_LF_ANGLE = 60 : UNSIGNED (8),
    CHAR_RT_ANGLE = 62 : UNSIGNED (8),
    CHAR_PERCENT = 37 : UNSIGNED (8),
    CHAR_ZERO = 48 : UNSIGNED (8),
    CHAR_UNDERSCORE = 95 : UNSIGNED (8),
    CHAR_D = 68 : UNSIGNED (8),

!+
! Functions for numeric format evaluation (see SPAN_NUMERIC routine).
!-

    K_SPAN_INTEGER = 1,
    K_SPAN_INTEGER_NO_E = 2,
    K_SPAN_FRACTION = 3,
    K_SPAN_FRACTION_NO_E = 4,

!+
! Classes for SPANC/SCANC table.
!-

    MASK_FORMAT_CHARS = 1 : UNSIGNED (8),
    MASK_L = 2 : UNSIGNED (8),
    MASK_C = 4 : UNSIGNED (8),
    MASK_R = 8 : UNSIGNED (8),
    MASK_E = 16 : UNSIGNED (8),
    MASK_SPECIAL = 32 : UNSIGNED (8),
    MASK_LF_ANGLE = 64 : UNSIGNED (8);

!
! PSECT DECLARATIONS:
!

DECLARE_PSECTS (BAS);

!
! OWN STORAGE:
!

OWN
    CURRENCY_DESC,			! descriptor for currency symbol
    CU_D,
    DIGIT_SEP_DESC,			! descriptor for digit group separator
    DI_D,
    RADIX_PT_DESC,			! descriptor for radix point
    RA_D;

BIND
    E_FORMAT = UPLIT BYTE (REP 4 OF (CHAR_CARAT)),
    PERCENT = UPLIT (BYTE ('%')),

!+
! Set up the class table for all groups of characters that will be involved
! in uses of the SCANC and SPANC instructions.  This class table is built
! into a PLIT.  An example of OWN storage initialition at run time is
! given below to help clarify the classes set up in the PLIT.
!
! INCR I FROM 0 TO 255 DO
!	SELECTONEU .I OF
!		SET
!		[CHAR_DOLLAR, CHAR_POUND, CHAR_PERIOD, CHAR_SINGLE_QUOTE,
!			CHAR_EXCLAMATION, CHAR_BACKSLASH, CHAR_STAR] :
!					 CLASS_TABLE [.I] = MASK_FORMAT_CHARS;
!		[CHAR_L, CHAR_LOWER_L] : CLASS_TABLE [.I] = MASK_L;
!		[CHAR_C, CHAR_LOWER_C] : CLASS_TABLE [.I] = MASK_C;
!		[CHAR_R, CHAR_LOWER_R] : CLASS_TABLE [.I] = MASK_R;
!		[CHAR_E, CHAR_LOWER_E] : CLASS_TABLE [.I] = MASK_E;
!		[OTHERWISE] :		 CLASS_TABLE [.I] = 0;
!		TES;
!
! Currently 5 formatting classes are used leaving 3 available.
! If more than 8 formatting classes are needed, a second CLASS_TABLE
! will have to be used unless various formatting classes can be grouped
! together (e.g. if MASK_C + MASK_R is passed to the SPANC instruction
! as the mask, all of the four characters CHAR_C, CHAR_LOWER_C, CHAR_R,
! CHAR_LOWER_R would be spanned.
!
! To add a new format character (or group of characters), the SPAN_CONSTANT
! routine should be modified to properly look for the beginning of the
! format sequence.  DECODE_PROCESS_FORMAT should then be modified to scan
! for the end of the formatting sequence setting any appropriate flags.
! Information to be communicated to the output conversion routine
! (OUTPUT_ARG) is passed via PARAM_BLK.  The paramter block could
! be expanded to allow for any new flags.
!-

    CLASS_TABLE = UPLIT BYTE
	(
	REP CHAR_EXCLAMATION  OF (0),
	(MASK_FORMAT_CHARS),		! CHAR_EXCLAMATION
	REP CHAR_POUND - CHAR_EXCLAMATION - 1 OF (0),
	(MASK_FORMAT_CHARS),		! CHAR_POUND
	REP CHAR_DOLLAR - CHAR_POUND - 1 OF (0),
	(MASK_FORMAT_CHARS),		! CHAR_DOLLAR
	REP CHAR_PERCENT - CHAR_DOLLAR - 1 OF (0),
	(MASK_LF_ANGLE),		! CHAR_PERCENT
	REP CHAR_SINGLE_QUOTE - CHAR_PERCENT - 1 OF (0),
	(MASK_FORMAT_CHARS),		! CHAR_SINGLE_QUOTE
	REP CHAR_STAR - CHAR_SINGLE_QUOTE - 1 OF (0),
	(MASK_FORMAT_CHARS),		! CHAR_STAR
	REP CHAR_COMMA - CHAR_STAR - 1 OF (0),
	(MASK_SPECIAL),			! CHAR_COMMA
	REP CHAR_MINUS - CHAR_COMMA - 1 OF (0),
	(MASK_SPECIAL),			! CHAR_MINUS
	REP CHAR_PERIOD - CHAR_MINUS - 1 OF (0),
	(MASK_FORMAT_CHARS),		! CHAR_PERIOD
	REP CHAR_ZERO - CHAR_PERIOD - 1 OF (0),
	(MASK_LF_ANGLE),		! CHAR_ZERO
	REP CHAR_LF_ANGLE - CHAR_ZERO - 1 OF (0),
	(MASK_FORMAT_CHARS),		! CHAR_LF_ANGLE
	REP CHAR_C - CHAR_LF_ANGLE - 1 OF (0),
	(MASK_C),			! CHAR_C
	REP CHAR_E - CHAR_C - 1 OF (0),
	(MASK_E), 			! CHAR_E
	REP CHAR_L - CHAR_E - 1 OF (0),
	(MASK_L),			! CHAR_L
	REP CHAR_R - CHAR_L - 1 OF (0),
	(MASK_R),			! CHAR_R
	REP CHAR_BACKSLASH - CHAR_R - 1 OF (0),
	(MASK_FORMAT_CHARS),		! CHAR_BACKSLASH
	REP CHAR_CARAT - CHAR_BACKSLASH - 1 OF (0),
	(MASK_SPECIAL),			! CHAR_CARAT
	REP CHAR_UNDERSCORE - CHAR_CARAT - 1 OF (0),
	(MASK_FORMAT_CHARS),		! CHAR_UNDERSCORE
	REP CHAR_LOWER_C - CHAR_UNDERSCORE - 1 OF (0),
	(MASK_C),			! CHAR_LOWER_C
	REP CHAR_LOWER_E - CHAR_LOWER_C - 1 OF (0),
	(MASK_E), 			! CHAR_LOWER_E
	REP CHAR_LOWER_L - CHAR_LOWER_E - 1 OF (0),
	(MASK_L),			! CHAR_LOWER_L
	REP CHAR_LOWER_R - CHAR_LOWER_L - 1 OF (0),
	(MASK_R),			! CHAR_LOWER_R
	REP 255 - CHAR_LOWER_R OF (0)
	) : VECTOR [256, BYTE, UNSIGNED];

!
! EXTERNAL REFERENCES:
!

EXTERNAL ROUTINE
    LIB$CURRENCY,			! currency symbol
    LIB$RADIX_POINT,			! radix point
    LIB$DIGIT_SEP,			! digit group separator
    BAS$RSET : NOVALUE,			! Basic RSET
    STR$GET1_DX,			! Allocate a string
    STR$FREE1_DX,			! Free a string
    STR$CONCAT,				! Concatenate strings
    STR$RIGHT,				! Extract right part of a string
    STR$LEN_EXTR,			! Extract a substring
    LIB$STOP,				! Signal internal RTL errors
    STR$COPY_DX_R8 : STR$JSB_COPY_DX,	! Copy to a string
    STR$COPY_R_R8 : STR$JSB_COPY_R,	! Copy to a dynamic string
    BAS$$STOP : NOVALUE,		! Signal errors and stop
    BAS$CVT_OUT_F_E,			! convert float to E format
    BAS$CVT_OUT_D_E,			! convert double to E format
    BAS$CVT_OUT_F_F,			! convert float to F format
    BAS$CVT_OUT_D_F,			! convert double to F format
    BAS$CVT_OUT_D_G,			! PRINT format conversion routine
    BAS$CVT_OUT_G_G,			! PRINT format conversion routine
    BAS$CVT_OUT_G_E,			! convert gfloat to E format
    BAS$CVT_OUT_G_F,			! convert gfloat to F format
    BAS$CVT_OUT_H_E,			! convert hfloat to E format
    BAS$CVT_OUT_H_G,			! PRINT format conversion routine
    BAS$CVT_OUT_H_F,			! convert hfloat to F format
    BAS$CVT_OUT_P_F,			! convert packed to F format
    BAS$CVT_OUT_P_E,			! convert packed to E format
    BAS$CVT_OUT_P_G;			! convert packed to general format

EXTERNAL LITERAL
    BAS$K_PRIUSIFOR,				! Print Using format error
    OTS$_FATINTERR;				! Fatal internal RTL error

BUILTIN

!+
! In version X3-669 of VAX-11 Bliss-32, output registers will be allowed
! for the SCANC and SPANC instructions (there is a bug in V2.1-667 that
! prevents the use of output registers with SCANC and SPANC or
! any BUILTIN for that matter).  These output
! registers could be used to return information from the instructions
! that currently requires a computation after the BUILTIN has been executed.
!
! In version V3 of VAX-11 Bliss-32, LOCC and SKPC will be allowed as BUILTINs
! so that the use of CH$FIND_NOT_CH could be replaced by the BUILTIN SKPC
! with output registers.
!-

    SCANC,
    SPANC,
    CVTLD;


%SBTTL 'BAS$$FORMAT_INT - external entry point'
GLOBAL ROUTINE BAS$$FORMAT_INT (		! Basic format interpreter

    ELEMENT,		! element to format
    FORMAT_STR,		! string containing the formatting information
    ELEMENT_TYPE,	! data type of the element
    RET_STRING,		! where to return the result
    RET_FORMAT_ADR,	! address of the next char in format string
    BAS_SCALE_FAC	! Scale factor (-6 <= x <= 0)
    ) : NOVALUE =

BEGIN

!++
! FUNCTIONAL DESCRIPTION:
!
!	This is the format interpreter for Basic Print Using and FORMAT$.
!	It will interpret the format string and call the appropriate output
!	conversion routine.
!
!	Note that this routine will be called for each item in the format
!	list.  Thus if there are 10 items in the format list and 1 formatting
!	sequence, this routine will be called once for each item (10 times).
!	If the PRINT USING is in a loop of 1,000 iterations, this routine
!	will be called once for each item-iteration or 10,000 times
!	in the above example.  Thus the format sequence will be decoded
!	10,000 times.  There is obvious room for improvement here by having
!	a separate routine to set up the PRINT USING paramater block with
!	the formatting information.  Note that the paramater block
!	currently used only handles one format sequence at a time.
!	Some higher level caller would have to save however many decoded
!	PRINT USING parameter blocks might be needed.
!
!	The routines in this module would benefit from RTL routines that
!	provide STR$APPEND with multiple source string descriptors and
!	STR$APPEND_R capabilities to append the source string by reference.
!
!	The PRINT USING support implemented here provides for upper
!	and lower case text formatting characters (L,C,R,E and l,c,r,e).
!	PDP-11 BASIC-PLUS-2 only allows upper case - lower case letters
!	(l,c,r,e) are treated as constants.  Thus the capabilities provided
!	here are not strictly a superset of the PDP-11 capabilities.
!
! FORMAL PARAMETERS:
!
!	ELEMENT.rx.r		element to format
!	FORMAT_STR.rt.dx	string containing the formatting information
!				Note that throughout this module, '.dx' is used
!				for FORMAT_STR where in fact it only supports
!				'.dd' and '.ds'.  We need a notation to specify
!				'.dd' and '.ds'.
!	ELEMENT_TYPE.rl.v	data type of the element
!	RET_STRING.wt.dd	where to return the result
!	RET_FORMAT_ADR.wl.r	address of next char in format string
!	BAS_SCALE_FAC.rb.v	Scale factor (-6 <= x <= 0)
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION CODES:
!
!	NONE
!
! SIDE EFFECTS:
!
!	Disables ASTs and re-enables them if they are enabled at entry
!	based on whether K_AST_FLAG is set.  This flag is provided
!	for performance testing of the options.
!
!--

!+
! Allocate the parameter block and some local working storage for the
! action routines.
!-

    LOCAL
	AST_STATUS,
	PARAM_BLK : BLOCK [K_INTER_STO_LEN, BYTE];

    MAP
	BAS_SCALE_FAC : VECTOR [1, BYTE, SIGNED],
	RET_FORMAT_ADR : REF VECTOR,
	FORMAT_STR : REF BLOCK [, BYTE];

!+
! Clear the return string as it may already have data in it.  By copying
! a null string to the return string, we can make it null, avoid using
! a first time flag in the action routines (to do a copy instead of a con-
! catenate to the return string the first time), and always use concatenates.
!-

    STR$COPY_R_R8 (.RET_STRING, 0, %REF (0));

!+
! Do the first time initialization of the currency, radix point, and digit
! separator symbols.  Default to '$', '.', and ',' respectively.
!-

    IF .RA_D EQL 0
    THEN
	BEGIN
	LOCAL
	    DIGIT_SEP_STR : BLOCK [8, BYTE],
	    RADIX_PT_STR : BLOCK [8, BYTE],
	    CURRENCY_STR : BLOCK [8, BYTE];
!+
! Initialize a dynamic string to a null string.  It will be expanded as necess-
! ary.
!-
	DIGIT_SEP_STR [DSC$W_LENGTH] = 0;
	DIGIT_SEP_STR [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	DIGIT_SEP_STR [DSC$B_CLASS] = DSC$K_CLASS_D;
	DIGIT_SEP_STR [DSC$A_POINTER] = 0;
	RADIX_PT_STR [DSC$W_LENGTH] = 0;
	RADIX_PT_STR [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	RADIX_PT_STR [DSC$B_CLASS] = DSC$K_CLASS_D;
	RADIX_PT_STR [DSC$A_POINTER] = 0;
	CURRENCY_STR [DSC$W_LENGTH] = 0;
	CURRENCY_STR [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	CURRENCY_STR [DSC$B_CLASS] = DSC$K_CLASS_D;
	CURRENCY_STR [DSC$A_POINTER] = 0;

	    BEGIN
	    MAP
		RADIX_PT_STR : VECTOR [2, LONG],
		DIGIT_SEP_STR : VECTOR [2, LONG],
		CURRENCY_STR : VECTOR [2, LONG];
	    LIB$CURRENCY(CURRENCY_STR);

!+
! Disable ASTs to guard against an AST right here which does a PRINT USING or
! a FORMAT$ which allocates another string resulting in its being lost forever.
!
! The disabling of ASTs will be controlled by K_AST_FLAG.
!-

	    IF K_AST_FLAG
	    THEN
		BEGIN
		AST_STATUS = $SETAST(ENBFLG = 0);
		CURRENCY_DESC = .CURRENCY_STR [0];
		CU_D = .CURRENCY_STR [1];

!+
! Re-enable ASTs if they were previously.
!-

		IF (.AST_STATUS EQL SS$_WASSET) THEN $SETAST(ENBFLG = 1);
		LIB$RADIX_POINT(RADIX_PT_STR);
		$SETAST(ENBFLG = 0);
		RADIX_PT_DESC = .RADIX_PT_STR [0];
		RA_D = .RADIX_PT_STR [1];
		IF (.AST_STATUS EQL SS$_WASSET) THEN $SETAST(ENBFLG = 1);
		LIB$DIGIT_SEP(DIGIT_SEP_STR);
		$SETAST(ENBFLG = 0);
		DIGIT_SEP_DESC = .DIGIT_SEP_STR [0];
		DI_D = .DIGIT_SEP_STR [1];
		IF (.AST_STATUS EQL SS$_WASSET) THEN $SETAST(ENBFLG = 1);
		END

	    ELSE
		BEGIN
		CURRENCY_DESC = .CURRENCY_STR [0];
		CU_D = .CURRENCY_STR [1];
		LIB$RADIX_POINT(RADIX_PT_STR);
		RADIX_PT_DESC = .RADIX_PT_STR [0];
		RA_D = .RADIX_PT_STR [1];
		LIB$DIGIT_SEP(DIGIT_SEP_STR);
		DIGIT_SEP_DESC = .DIGIT_SEP_STR [0];
		DI_D = .DIGIT_SEP_STR [1]
		END;

	    END;
	END;

!+
! Initialize the parameter block and the data base that Print Using
! will use.
!-

    PARAM_BLK [INTEGER_DIGITS] = PARAM_BLK [CHARACTER] = PARAM_BLK [FRACTION_DIGIT] =
    PARAM_BLK [PU_MASK] = 0;
    PARAM_BLK [RET_STR] = .RET_STRING;
    PARAM_BLK [ELEM] = .ELEMENT;
    PARAM_BLK [ELEM_TYPE] = .ELEMENT_TYPE;
    PARAM_BLK [SCALE_FACTOR] = .BAS_SCALE_FAC [0];

!+
! The format decoding routine takes over here and calls the output
! conversion routine after setting up PARAM_BLK.
!-

    IF NOT (DECODE_PROCESS_FORMAT (.FORMAT_STR, PARAM_BLK))
    THEN

!+
! Signal a fatal internal error in the RTL.  All errors should be caught
! in the routnes called by DECODE_PROCESS_FORMAT.
!-

	LIB$STOP (OTS$_FATINTERR);

    RET_FORMAT_ADR [0] = .PARAM_BLK [NEXT_CHAR];
    RETURN;
    END;				! End of routine BAS$$FORMAT_INT


%SBTTL 'DECODE_PROCESS_FORMAT - main driving routine'
ROUTINE DECODE_PROCESS_FORMAT (

	P_FORMAT_STR,	! format string
	P_PARAM_BLK) =	! print using parameter block

BEGIN

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	The plan of attack is to locate the start of the formatting sequence.
!	All characters up to the formatting sequence are concatenated onto
!	the return string.  A parameter block is then set up based on the
!	formatting information and OUTPUT_ARG is called to do the
!	actual formatting concatenating the result to the return string.
!	The beginning of the next formatting sequence is then searched for
!	and all characters up to this next formatting sequence are concatenated
!	onto the return string.
!
!	The SPAN_CONSTANT routine will position CHAR_CNT at the last character
!	before the formatting sequence.  CHAR_CNT = 0 implies that no leading
!	constant was found. The constant string up to the formatting sequence
!	is copied onto the return string. If no formatting sequence
!	is found, 0 is returned by SPAN_CONSTANT and a print using format error
!	is signalled; otherwise 1 is returned by SPAN_CONSTANT.
!
!	After the leading constant is located, the proper formatting sequence
!	is located and process.  Then the trailing constant is processed.
!
!	The calling structure of the routines is as follows:
!
!	BAS$$FORMAT_INT
!	  DECODE_PROCESS_FORMAT
!	    SPAN_CONSTANT
!	    SPAN_SINGLE_QUOTE
!	      SPAN_TEXT
!	    SPAN_BACKSLASH
!	    SPAN_NUMERIC
!	    OUTPUT_ARG
!	    SPAN_CONSTANT
!
! CALLING SEQUENCE:
!
!	STATUS.wlc.v = DECODE_PROCESS_FORMAT (P_FORMAT_STR.rt.dx,
!		P_PARAM_BLK.mr.r)
!
! FORMAL PARAMETERS:
!
!	P_FORMAT_STR	- address of string descriptor for format string
!	P_PARAM_BLK	- address of print using parameter block
!
! IMPLICIT INPUTS:
!
!	CURRENCY_DESC	- descriptor for currency symbol
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION CODES:
!
!	1		- routine completed successfully
!	0		- error
!
! SIDE EFFECTS:
!
!	NONE
!
!--

BIND
	PARAM_BLK = (.P_PARAM_BLK) : BLOCK [, BYTE],
	FORMAT_STR = (.P_FORMAT_STR) : BLOCK [, BYTE];

MAP
	CURRENCY_DESC : BLOCK [, BYTE];

LOCAL
	CHAR_CNT;	! keeps track of offset from beginning
			!  of format string

CHAR_CNT = .FORMAT_STR [DSC$W_LENGTH];
CHAR_CNT = 0;

!+
! SPAN_CONSTANT returns 0 if there is no format sequence or a null format
! string.
!-

IF NOT SPAN_CONSTANT (FORMAT_STR, .PARAM_BLK [RET_STR], CHAR_CNT)
THEN
    BEGIN
    BAS$$STOP (BAS$K_PRIUSIFOR);
    RETURN 1				! return if error
    END

ELSE
    BEGIN

!+
! Decode and process formatting sequence.
!-

    BIND CHAR = (.FORMAT_STR [DSC$A_POINTER] + .CHAR_CNT) : BYTE;

    SELECTONEU .CHAR OF
	SET

	[CHAR_SINGLE_QUOTE] :
		BEGIN
		CHAR_CNT = .CHAR_CNT + 1;
		SPAN_SINGLE_QUOTE (FORMAT_STR, PARAM_BLK, CHAR_CNT);
		OUTPUT_ARG (PARAM_BLK);
!+
! If there is an underscore in the text format string, the next character
! should be appended into a trailing constant.  Any other characters which
! should be part of the trailing constant will be handled in the next call
! to SPAN_CONSTANT.
!-
		SPAN_CONSTANT (FORMAT_STR, .PARAM_BLK [RET_STR], CHAR_CNT)
		END;

	[CHAR_POUND] :
		BEGIN
		CHAR_CNT = .CHAR_CNT + 1;
		PARAM_BLK [PU_MASK] = .PARAM_BLK [PU_MASK] OR NUMERIC_MASK;
		PARAM_BLK [INTEGER_DIGITS] = 1;
		SPAN_NUMERIC (K_SPAN_INTEGER, FORMAT_STR,
			CHAR_CNT, PARAM_BLK);
		OUTPUT_ARG (PARAM_BLK)
		END;

	[CHAR_DOLLAR] :			! floating currency

!+
! The SPAN_CONSTANT routine will have insured that the intial part of the
! formatting sequence is '$$'.
!-

		BEGIN
		CHAR_CNT = .CHAR_CNT + 2;
		PARAM_BLK [PU_MASK] = .PARAM_BLK [PU_MASK] OR DOLLAR_MASK
			OR NUMERIC_MASK;
		PARAM_BLK [INTEGER_DIGITS] = 1 + .CURRENCY_DESC [DSC$W_LENGTH];
!+
! A '<%>' or '<0>' could follow '$$'.  Check for this before scanning the rest
! of the format string.  Don't check for <0> anymore as of edit 2-012 to be
! compatible with BP2.
!-
		SPAN_BRACKET (CHAR_PERCENT, FORMAT_STR, PARAM_BLK, CHAR_CNT); 
!		SPAN_BRACKET (CHAR_ZERO, FORMAT_STR, PARAM_BLK, CHAR_CNT);
		SPAN_NUMERIC (K_SPAN_INTEGER_NO_E, FORMAT_STR,
			CHAR_CNT, PARAM_BLK);
		OUTPUT_ARG (PARAM_BLK)
		END;

	[CHAR_STAR] :			! asterisk fill

!+
! The SPAN_CONSTANT routine will have insured that the intial part of the
! formatting sequence is '**'.
!-

		BEGIN
		CHAR_CNT = .CHAR_CNT + 2;
		PARAM_BLK [PU_MASK] = .PARAM_BLK [PU_MASK] OR STAR_MASK
			OR NUMERIC_MASK;
		PARAM_BLK [INTEGER_DIGITS] = 2;
!+
! A '<%>' could follow '**'.  Check for this before scanning the rest of the
! format string.
!-
		SPAN_BRACKET (CHAR_PERCENT, FORMAT_STR, PARAM_BLK, CHAR_CNT);
		SPAN_NUMERIC (K_SPAN_INTEGER_NO_E, FORMAT_STR,
			CHAR_CNT, PARAM_BLK);
		OUTPUT_ARG (PARAM_BLK)
		END;

	[CHAR_PERIOD] :
		BEGIN

!+
! The SPAN_CONSTANT routine will have insured that the intial part of the
! formatting sequence is '.#'.
!-

		CHAR_CNT = .CHAR_CNT + 2;
		PARAM_BLK [PU_MASK] = .PARAM_BLK [PU_MASK] OR PERIOD_MASK
			OR NUMERIC_MASK;
		PARAM_BLK [FRACTION_DIGIT] = 1;
		SPAN_NUMERIC (K_SPAN_FRACTION, FORMAT_STR,
			CHAR_CNT, PARAM_BLK);
		OUTPUT_ARG (PARAM_BLK);
		END;

	[CHAR_BACKSLASH] :
		BEGIN
		CHAR_CNT = .CHAR_CNT + 1;
		IF NOT SPAN_BACKSLASH (FORMAT_STR, PARAM_BLK, CHAR_CNT)
		THEN
			BEGIN
			BAS$$STOP (BAS$K_PRIUSIFOR);
			RETURN 1;	! return if error
			END

		ELSE
			OUTPUT_ARG (PARAM_BLK)

		END;

	[CHAR_EXCLAMATION] :
		BEGIN
		CHAR_CNT = .CHAR_CNT + 1;
		PARAM_BLK [PU_MASK] = .PARAM_BLK [PU_MASK] OR L_JUSTIFY_MASK;
		PARAM_BLK [CHARACTER] = 1;
		OUTPUT_ARG (PARAM_BLK)
		END;

!+
! The SPAN_CONSTANT routine has insured that a valid '< >' sequence
! is present.
!-

	[CHAR_LF_ANGLE] :
	    	BEGIN
		BIND CHAR2 = (.FORMAT_STR [DSC$A_POINTER] + .CHAR_CNT + 1) : BYTE;

		SELECTONEU .CHAR2 OF
		SET
		[CHAR_PERCENT]:
		    BEGIN
		    CHAR_CNT = .CHAR_CNT + 3;
		    PARAM_BLK [PU_MASK] = .PARAM_BLK [PU_MASK] OR PERCENT_MASK
					    OR NUMERIC_MASK;
		    PARAM_BLK [INTEGER_DIGITS] = .PARAM_BLK [INTEGER_DIGITS] + 1;
		    SPAN_NUMERIC (K_SPAN_INTEGER, FORMAT_STR, CHAR_CNT,
				    PARAM_BLK);
		    OUTPUT_ARG (PARAM_BLK)
		    END;

		[CHAR_ZERO]:
		    BEGIN
		    CHAR_CNT = .CHAR_CNT + 3;
		    PARAM_BLK [PU_MASK] = .PARAM_BLK [PU_MASK] OR ZERO_MASK
					    OR NUMERIC_MASK;
		    PARAM_BLK [INTEGER_DIGITS] = .PARAM_BLK [INTEGER_DIGITS] + 1;
		    SPAN_NUMERIC (K_SPAN_INTEGER, FORMAT_STR, CHAR_CNT,
				    PARAM_BLK);
		    OUTPUT_ARG (PARAM_BLK)
		    END;

		TES;
		END;

	[OTHERWISE] :

!+
! This should never happen.
!-

		RETURN 0;		! return if error (this is a fatal
					!  internal error)

	TES
    END;

!+
! At this point, any trailing constant in the format string should be
! concatenated onto the return string.
!
! The return from SPAN_CONSTANT is ignored since we do not care at this
! point whether or not the constant string runs to the end of the format
! string.  In the initial call to SPAN_CONSTANT, we did care because
! a null formatting sequence must be signalled as an error.  If this
! code is executed, a legal formatting sequence has been found and processed.
! SPAN_CONSTANT is taking care to get CHAR_CNT to point just before the
! next formatting sequence (if one exists).
!-

SPAN_CONSTANT (FORMAT_STR, .PARAM_BLK [RET_STR], CHAR_CNT);

!+
! Now that the trailing constant has been handled; this routine
! has completed its work.
!-

PARAM_BLK [NEXT_CHAR] = .FORMAT_STR [DSC$A_POINTER] + .CHAR_CNT;

RETURN 1

END;					! End of routine DECODE_PROCESS_FORMAT

%SBTTL 'SPAN_CONSTANT - find start of format sequence'
ROUTINE SPAN_CONSTANT (

	P_FORMAT_STR,	! format string
	P_RETURN_STR,	! return string
	P_CHAR_CNT) =	! character position within format string

BEGIN

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine searches FORMAT_STR for the start of a valid
!	formatting sequence beginning at the CHAR_CNT + 1st character
!	position in FORMAT_STR.  CHAR_CNT is set to the character position
!	just before the formatting sequence.  Thus CHAR_CNT returned
!	unchanged indicates that no constant string was found, i.e.,
!	CHAR_CNT currently points to the character position just before
!	the start of a format sequence.  The constant string is copied
!	onto the return string. The routine returns 0 if no
!	formatting sequence is located and 1 otherwise.
!
!	This routine will be called initially to determine the end of
!	any leading constant in the format string.  This routine
!	will be called after any formatting has taken place to determine
!	the end of any trailing constant in the format string.
!
! CALLING SEQUENCE:
!
!	STATUS.wlc.v = SPAN_CONSTANT (P_FORMAT_STR.rt.dx, P_RETURN_STR.mt.dd,
!		P_CHAR_CNT.ml.r)
!
! FORMAL PARAMETERS:
!
!	P_FORMAT_STR	- address of string descriptor for format string
!	P_RETURN_STR	- address of string descriptor for return string
!	P_CHAR_CNT	- address of longword for character position within
!			   format string; this paramater is passed as the
!			   position 1 before the point at which the format
!			   sequence should start; this parameter is passed
!			   as the position 1 before the starting character
!			   position of the format sequence
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION CODES:
!
!	1		- routine completed successfully (format sequence
!			   located)
!	0		- no format sequence located
!
! SIDE EFFECTS:
!
!	NONE
!
! EXAMPLES:
!
!	FORMAT_STR	CHAR_CNT (in)	CHAR_CNT (out)	COMPLETION CODE
!	----------	-------------	--------------	---------------
!	abc$abc		0		0		0
!	abc$$abc	0		3		1
!	abc$abc**abc	0		7		1
!	abc'cccdef'cc	7		10		1
!	abc'cccdef*	7		7		0
!	abc'cccdef**	7		10		1
!	abc'ccc		7		7		0
!	
!--

BIND
	FORMAT_STR = (.P_FORMAT_STR) : BLOCK [, BYTE],
	RETURN_STR = (.P_RETURN_STR) : BLOCK [, BYTE],
	CHAR_CNT = (.P_CHAR_CNT);

LOCAL
	TMP_STR : BLOCK [8, BYTE],	! temporary string descriptor
	FORMAT_STR_LEN : UNSIGNED WORD,	! temporary for format length in SCANC
	SCAN_MASK : BYTE,		! temporary for mask in SCANC
	START_CNS_CNT,			! initial offset that could possibly
					!  begin a constant in the format
					!  string
	CHAR_PTR;			! pointer to possible start point
					!  for formatting sequence

!+
! START_CNS_CNT should be the initial offset that could possible
! begin a constant string.
!-

START_CNS_CNT = .CHAR_CNT + 1;

!+
! Use SCANC to find the beginning of a formatting sequence.
! SCANC will be used to find the first 'possible' formatting character.
! Since SCANC can only stop on single character sequences, and we only
! want to stop on multiple character sequences in some cases
! ('.#', '**' and '$$),
! SCANC may have to be used repeatedly to skip over false alarms such
! as '.R', '$2' or '*b'.
!-

WHILE 1 DO 				! This loop scans until the end
					!  of a leading or trailing constant
					!  is found
	BEGIN

	FORMAT_STR_LEN = .FORMAT_STR [DSC$W_LENGTH] - .CHAR_CNT;
	SCAN_MASK = MASK_FORMAT_CHARS;
	CHAR_PTR = SCANC (FORMAT_STR_LEN,
		.FORMAT_STR [DSC$A_POINTER] + .CHAR_CNT,
		CLASS_TABLE, SCAN_MASK);
	IF .CHAR_PTR EQLU 0
	THEN
		BEGIN

!+
! If CHAR_CNT is not 0, then we are trying to span a trailing constant.
! If no formatting sequence is found, we should treat everything from
! START_CNS_CNT to the end of the string as a trailing constant.
!-

		IF .CHAR_CNT NEQU 0
		THEN

			BEGIN
			IF .FORMAT_STR [DSC$W_LENGTH] - .START_CNS_CNT GEQ 0
			THEN
				BEGIN
				TMP_STR [DSC$W_LENGTH] = 0;
				TMP_STR [DSC$B_DTYPE] = DSC$K_DTYPE_T;
				TMP_STR [DSC$B_CLASS] = DSC$K_CLASS_D;
				TMP_STR [DSC$A_POINTER] = 0;
				STR$RIGHT (TMP_STR, FORMAT_STR, START_CNS_CNT);
				STR$CONCAT (RETURN_STR, RETURN_STR, TMP_STR);
				STR$FREE1_DX (TMP_STR);
				CHAR_CNT = .FORMAT_STR [DSC$W_LENGTH];
				END
			END;

		RETURN 0;		! return since end of format string
					!  was found
		END

	ELSE
		BEGIN
		BIND CHARS = (.CHAR_PTR) : VECTOR [, BYTE];
		CHAR_CNT = .CHAR_PTR - .FORMAT_STR [DSC$A_POINTER];

!+
! Check special cases ('.#', '$$', '**', '<CD>', '<%>', and '<0>').
!-

		IF .CHARS [0] EQLU CHAR_PERIOD
		THEN
			BEGIN
			IF .CHAR_CNT LSSU .FORMAT_STR [DSC$W_LENGTH] - 1
			THEN
				BEGIN
				IF .CHARS [1] EQLU CHAR_POUND
				THEN
					EXITLOOP

				ELSE

!+
! The format character was a false alarm so we should return to top of loop
! and get the possible format character into the constant.
!-
	
					CHAR_CNT = .CHAR_CNT + 1;
					! this gets the case "abc.+"
				END

			ELSE

!+
! The format character was a false alarm so we should return to top of loop
! and get the possible format character into the constant.
!-

				CHAR_CNT = .CHAR_CNT + 1;
					! this gets the case "abc."
			END

		ELSE IF .CHARS [0] EQLU CHAR_DOLLAR
		THEN
			BEGIN
			IF .CHAR_CNT LSSU .FORMAT_STR [DSC$W_LENGTH] - 1
			THEN
				BEGIN
				IF .CHARS [1] EQLU CHAR_DOLLAR
				THEN
					EXITLOOP

				ELSE

!+
! The format character was a false alarm so we should return to top of loop
! and get the possible format character into the constant.
!-

					CHAR_CNT = .CHAR_CNT + 1;
					! this gets the case "abc$+"
				END

			ELSE

!+
! The format character was a false alarm so we should return to top of loop
! and get the possible format character into the constant.
!-

				CHAR_CNT = .CHAR_CNT + 1;
					! this gets the case "abc$"
			END

		ELSE IF .CHARS [0] EQLU CHAR_STAR
		THEN
			BEGIN
			IF .CHAR_CNT LSSU .FORMAT_STR [DSC$W_LENGTH] - 1
			THEN
				BEGIN
				IF .CHARS [1] EQLU CHAR_STAR
				THEN
					EXITLOOP

				ELSE

!+
! The format character was a false alarm so we should return to top of loop
! and get the possible format character into the constant.
!-

					CHAR_CNT = .CHAR_CNT + 1;
					! this gets the case "abc*+"
				END

			ELSE

!+
! The format character was a false alarm so we should return to top of loop
! and get the possible format character into the constant.
!-

				CHAR_CNT = .CHAR_CNT + 1;
					! this gets the case "abc*"
			END

		ELSE IF .CHARS [0] EQLU CHAR_UNDERSCORE 
		THEN
			BEGIN
			IF .CHAR_CNT LSSU .FORMAT_STR [DSC$W_LENGTH] -1
			THEN
 			    BEGIN
			    LOCAL
			  	UNDER_MASK;
			    UNDER_MASK = (MASK_FORMAT_CHARS + 
					  MASK_L + MASK_C +
					  MASK_R + MASK_E +
					  MASK_SPECIAL); 
			    !+
			    ! Underscore must be the first character in the 
			    ! constant.  Any other
			    ! constant characters should be appended to the 
			    ! return string before
			    ! we try to process underscore.
			    !-
			    IF .CHAR_PTR - (.FORMAT_STR [DSC$A_POINTER] +
				.START_CNS_CNT) GEQ 0
			    THEN
			        BEGIN
				!+
				! Underscore is in the middle
				! of the constant.  Include
				! up to the _ in the return
				! string now, and set the
				! start ptr to the _ for next
				! time thru SPAN_CONSTANT.
				!-
				LOCAL
				    CNS_LENGTH;
				CNS_LENGTH = .CHAR_CNT - .START_CNS_CNT + 1;
				TMP_STR [DSC$W_LENGTH] = 0;
				TMP_STR [DSC$B_DTYPE] = DSC$K_DTYPE_T;
				TMP_STR [DSC$B_CLASS] = DSC$K_CLASS_D;
				TMP_STR [DSC$A_POINTER] = 0;
				STR$LEN_EXTR (TMP_STR, FORMAT_STR, START_CNS_CNT, CNS_LENGTH);
				STR$CONCAT (RETURN_STR, RETURN_STR, TMP_STR);
				STR$FREE1_DX (TMP_STR);
				START_CNS_CNT = .CHAR_CNT + 1;  ! constant starts past underscore
				END		! the case 'abc_###'
			    ELSE
			        BEGIN	! start of constant 
				!+
				! Search for the formatting character which 
				! should follow an underscore.
				! Underscore has no effect if no format 
				! character follows.
				! Note we don't EXITLOOP after processing the 
				! underscore and the char that
				! follows it, as there may be more constant 
				! expression after that.
				!-
			        FORMAT_STR_LEN = 1;
			        CHAR_PTR = SCANC (FORMAT_STR_LEN, 
					  .FORMAT_STR [DSC$A_POINTER] + .CHAR_CNT + 1,
					  CLASS_TABLE, UNDER_MASK);
			        IF .CHAR_PTR EQL 0
			        THEN
				!+
				! No format character follows the underscore, 
				! so the underscore should become
				! part of the constant.
				!-
				    CHAR_CNT = .CHAR_CNT + 1
						! this gets the case '_abc'					
			        ELSE
				!+
				! A valid text format character follows the 
				! underscore.  This character should
				! be included in the constant.  There may be 
				! more constant after this single
				! character - SCANC again, and if there is 
				! another format character we know
				! we are at the end of the constant.
				!-
				    BEGIN
			 	    IF .CHAR_CNT EQLU .FORMAT_STR [DSC$W_LENGTH] - 2
				    THEN
				    	BEGIN
				    	!+
				    	! Nothing follows the underscore and its
				    	! format character.  End of constant.
				    	!-
					IF .CHAR_CNT EQL 0
					THEN
			    		    RETURN 0;	! no format chars found
				    	CHAR_CNT = .CHAR_CNT + 2;
					IF .CHARS [1] NEQU CHAR_DOLLAR AND
					   .CHARS [1] NEQU CHAR_STAR AND
					   .CHARS [1] NEQU CHAR_LF_ANGLE
					THEN
				    	    START_CNS_CNT = .START_CNS_CNT + 1;
				    	EXITLOOP
				    	END	! case '_#' (end of string)
				    ELSE
					BEGIN
					!+
					! Characters which are part of a '<x>'
					! sequence may not normally be considered
					! format characters.  
					!-
					UNDER_MASK = .UNDER_MASK + MASK_LF_ANGLE;
				    	CHAR_PTR = SCANC (FORMAT_STR_LEN,
			 		    .FORMAT_STR [DSC$A_POINTER] + .CHAR_CNT + 2,
					    CLASS_TABLE, UNDER_MASK);
			     	    	IF .CHAR_PTR EQL 0
				    	THEN
				            BEGIN
				            !+ 
				            ! More constant follows the underscore and
				            ! its format character.  If multi-char
					    ! format, then the char after the
					    ! underscore is not a 'format' char
					    ! after all.
				            !-
					    IF .CHARS [1] NEQU CHAR_DOLLAR AND
					       .CHARS [1] NEQU CHAR_STAR AND
					       .CHARS [1] NEQU CHAR_LF_ANGLE
					    THEN
						BEGIN
						CHAR_CNT = .CHAR_CNT + 2;
				                START_CNS_CNT = .START_CNS_CNT + 1;
						END	! case '_#abc'
					    ELSE
						CHAR_CNT = .CHAR_CNT + 1;
							! case '_<abc'
				            END 
				    	ELSE
				            BEGIN
				            !+
				            ! More format characters follow the underscore
				            ! and its format character. 
					    ! Check for a multi-char format sequence,
					    ! such as '$$'.  Include all chars in
					    ! the constant if necessary.
					    !-
					    BIND
						FORMAT_CHAR = (.CHAR_PTR - 1) : VECTOR [,BYTE];
					    SELECTONEU .FORMAT_CHAR [0] OF
						SET
						[CHAR_DOLLAR] :
						    IF .FORMAT_CHAR [1] EQLU CHAR_DOLLAR
						    THEN
							BEGIN
							CHAR_CNT = .CHAR_CNT + 3;
							START_CNS_CNT = .START_CNS_CNT + 1;
							END	! case '_$$'
						    ELSE
							CHAR_CNT = .CHAR_CNT + 1;
								! case '_$#'
						[CHAR_STAR] :
						    IF .FORMAT_CHAR [1] EQLU CHAR_STAR
						    THEN
							BEGIN
							CHAR_CNT = .CHAR_CNT + 3;
							START_CNS_CNT = .START_CNS_CNT + 1;
							END ! case '_**'
						    ELSE
							CHAR_CNT = .CHAR_CNT + 1;
								! case '_*#'
						[CHAR_CARAT] :
						    IF .CHAR_CNT LEQU .FORMAT_STR [DSC$W_LENGTH] - 5
						    THEN
							BEGIN
							IF .FORMAT_CHAR [1] EQLU CHAR_CARAT  AND
							   .FORMAT_CHAR [2] EQLU CHAR_CARAT AND
							   .FORMAT_CHAR [3] EQLU CHAR_CARAT
							THEN
							    BEGIN
							    CHAR_CNT = .CHAR_CNT + 5;
							    START_CNS_CNT = .START_CNS_CNT + 1;
							    END; ! case '_^^^^'
							END
						    ELSE
							CHAR_CNT = .CHAR_CNT + 2;
							   	    ! case '_^#'
						[CHAR_LF_ANGLE] :
						    BEGIN
						    IF .CHAR_CNT LEQU .FORMAT_STR [DSC$W_LENGTH] - 4
						    THEN
							BEGIN
							LOCAL
							    TMP_CHAR_CNT,
							    TMP_PARAM_BLK : BLOCK [K_INTER_STO_LEN, BYTE];
							    ! don't alter real param_blk
							TMP_CHAR_CNT = .CHAR_CNT + 1;
							IF (SPAN_BRACKET (CHAR_PERCENT,
								FORMAT_STR, TMP_PARAM_BLK,
								TMP_CHAR_CNT)) OR
							   (SPAN_BRACKET (CHAR_ZERO,
								FORMAT_STR, TMP_PARAM_BLK,
								TMP_CHAR_CNT))
							THEN	! cases '_<%>', '_<0>'
							    BEGIN
							    CHAR_CNT = .CHAR_CNT + 4;
							    START_CNS_CNT = .START_CNS_CNT + 1;
							    END
							ELSE
							    IF (SPAN_BRACKET (CHAR_C,
							   	    FORMAT_STR, TMP_PARAM_BLK,
								    TMP_CHAR_CNT)) OR
							   	(SPAN_BRACKET (CHAR_LOWER_C,
								    FORMAT_STR, TMP_PARAM_BLK,
								    TMP_CHAR_CNT))
							    THEN	! cases '_<CD>', '_<cd>'
							        BEGIN
							        CHAR_CNT = .CHAR_CNT + 5;
							        START_CNS_CNT = .START_CNS_CNT + 1;
							        END
							    ELSE
							   	CHAR_CNT = .CHAR_CNT + 3; 
								! case '_<%abc'
							END
						    ELSE
							CHAR_CNT = .CHAR_CNT + 3; ! case '_<%'
						    END;  	! end of bracket formats

						[OTHERWISE] :
						    ! +
						    ! Underscore followed by a
						    ! singly valid format char.
						    ! Any format chars which 
						    ! follow the 1st format char
						    ! are immaterial.
						    !-
						    BEGIN
						    CHAR_CNT = .CHAR_CNT + 2;
						    START_CNS_CNT = .START_CNS_CNT + 1;
								! case '_##abc'
						    END;
						TES;

				            END; ! more format chars after
					         ! underscore & its format char
				    	END
				    END
				END
			    END
			!+
			! underscore followed by nothing.  treat as constant.
			!-	
			ELSE
			    BEGIN
			    !+
			    ! 
			    !-
			    CHAR_CNT = .CHAR_CNT + 1;
			    EXITLOOP;
			    END;
			END
				
		ELSE IF .CHARS [0] EQLU CHAR_LF_ANGLE
		THEN
			BEGIN
			IF .CHAR_CNT LSSU .FORMAT_STR [DSC$W_LENGTH] - 2
			THEN 
			    BEGIN
			    SELECTONEU .CHARS [1] OF
			    SET
			    [CHAR_PERCENT]:
				IF .CHARS [2] EQLU CHAR_RT_ANGLE
				THEN	! found a format character
				    EXITLOOP
				ELSE	! false alarm - include in constant
				    CHAR_CNT = .CHAR_CNT + 2; 
					! this gets the case '<%abc'
			    [CHAR_ZERO]:
				IF .CHARS [2] EQLU CHAR_RT_ANGLE
				THEN	! found a format character
				    EXITLOOP
				ELSE	! false alarm - include in constant
				    CHAR_CNT = .CHAR_CNT + 2;
					! this gets the case '<0abc'
			    [CHAR_C]:
				IF .CHARS [2] EQLU CHAR_D
				THEN
				    BEGIN
				    IF .CHAR_CNT LSSU .FORMAT_STR [DSC$W_LENGTH] - 3
				    THEN
					BEGIN
					IF .CHARS [3] EQLU CHAR_RT_ANGLE
					THEN 
					    BEGIN
!					    IF .CHAR_CNT GEQU .FORMAT_STR [DSC$W_LENGTH] - 4
					    IF CHARS NEQ .FORMAT_STR [DSC$A_POINTER]
					    THEN
						EXITLOOP	! found a format char (at end of string)
					    ELSE
						CHAR_CNT = .CHAR_CNT + 4
						! this gets the case where <CD> is in the beginning of
						! the format string and should be treated as a constant.
						! we treat it as a constant in order to be consistent w/ BP2.
					    END
					ELSE
					    CHAR_CNT = .CHAR_CNT + 3
					! this gets the case '<CDabc'
					END
				    ELSE
				        CHAR_CNT = .CHAR_CNT + 3
					! this gets the case '<CDabc' at end of string
				    END
				ELSE
				    CHAR_CNT = .CHAR_CNT + 2;
					! this gets the case '<Cabc'
			    [OTHERWISE]:
				CHAR_CNT = .CHAR_CNT + 1;
					! this gets the case '<abc'
			    TES;
   			    END
			ELSE
			    CHAR_CNT = .CHAR_CNT + 1;
					! this gets the case '<a'
			END
		ELSE					
			EXITLOOP
		END
	END;				! end of constant finding loop

!+
! If we get here we have moved CHAR_CNT to the character before
! the start of a format string.
!
! Concatentate constant string from FORMAT_STR onto RETURN_STR.
!
! Note that code similar to this is executed at the beginning of
! this module if a trailing constant is detected that extends to the
! end of the format string.
!-

IF .CHAR_CNT - .START_CNS_CNT GEQ 0
THEN
	BEGIN
	LOCAL CNS_LENGTH;
	CNS_LENGTH = .CHAR_CNT - .START_CNS_CNT + 1;
	TMP_STR [DSC$W_LENGTH] = 0;
	TMP_STR [DSC$B_DTYPE] = DSC$K_DTYPE_T;
	TMP_STR [DSC$B_CLASS] = DSC$K_CLASS_D;
	TMP_STR [DSC$A_POINTER] = 0;
	STR$LEN_EXTR (TMP_STR, FORMAT_STR, START_CNS_CNT, CNS_LENGTH);
	STR$CONCAT (RETURN_STR, RETURN_STR, TMP_STR);
	STR$FREE1_DX (TMP_STR)
	END;

RETURN 1

END;					! End of routine SPAN_CONSTANT

%SBTTL 'SPAN_SINGLE_QUOTE - process single quote formatting classes'
ROUTINE SPAN_SINGLE_QUOTE (

	P_FORMAT_STR,	! format string
	P_PARAM_BLK,	! print using parameter block
	P_CHAR_CNT) =	! character position within format string

BEGIN

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine searches FORMAT_STR for the start of something other
!	than one of the valid single quote format classes
!	(left-justify, center-justify, right-justify, extended)
!	beginning at the CHAR_CNT + 1st character
!	position in FORMAT_STR.  CHAR_CNT is then set to the last
!	character position in the formatting sequence.
!	Thus CHAR_CNT returned
!	unchanged indicates that no further formatting string was found.
!	The routine returns 0 if an illegal formatting character
!	formatting sequence is located and 1 otherwise.
!
!	This routine will be called initially to determine the end of
!	any leading constant in the format string.  This routine
!	will be called after any formatting has taken place to determine
!	the end of any trailing constant in the format string.
!
! CALLING SEQUENCE:
!
!	STATUS.wlc.v = SPAN_SINGLE_QUOTE (P_FORMAT_STR.rt.dx,
!		P_PARAM_BLK.mr.r, P_CHAR_CNT.ml.r)
!
! FORMAL PARAMETERS:
!
!	P_FORMAT_STR	- address of string descriptor for format string
!	P_PARAM_BLK	- address of print using parameter block
!	P_CHAR_CNT	- address of longword for character position within
!			   format string; this paramater is passed as the
!			   position 1 before the point at which the format
!			   sequence should start; this parameter is returned
!			   as the last position of the format sequence
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION CODES:
!
!	1		- routine completed successfully
!
! SIDE EFFECTS:
!
!	NONE
!
! EXAMPLES:
!
!	FORMAT_STR	CHAR_CNT (in)	CHAR_CNT (out)
!	----------	-------------	--------------
!	abc'cccdef'cc	4		7
!	abc'llldef'cc	4		7
!	abc'rrrdef'cc	4		7
!	abc'cccdef*	4		7
!	ab'lab		3		4
!	ab'		3		3
!	ab'z		3		3
!	
!--

BIND
	PARAM_BLK = (.P_PARAM_BLK) : BLOCK [, BYTE],
	FORMAT_STR = (.P_FORMAT_STR) : BLOCK [, BYTE],
	CHAR_CNT = (.P_CHAR_CNT),
	CHAR = (.FORMAT_STR [DSC$A_POINTER] + .CHAR_CNT) : BYTE;

LOCAL
	CHAR_PTR;			! pointer to possible start point
					!  for formatting sequence

IF .CHAR_CNT EQLU .FORMAT_STR [DSC$W_LENGTH]
THEN					! This is the case of a format string
					!  with just a single quote
	BEGIN
	PARAM_BLK [PU_MASK] = .PARAM_BLK [PU_MASK] OR L_JUSTIFY_MASK;
	PARAM_BLK [CHARACTER] = 1;
	RETURN 1
	END;

SELECTONEU .CHAR OF
	SET

	[CHAR_L, CHAR_LOWER_L] :
		BEGIN

!+
! Span L and l.
!-

		SPAN_TEXT (MASK_L, FORMAT_STR, CHAR_CNT,
			PARAM_BLK [CHARACTER]);
		PARAM_BLK [PU_MASK] = .PARAM_BLK [PU_MASK] OR L_JUSTIFY_MASK
		END;

	[CHAR_C, CHAR_LOWER_C] :
		BEGIN

!+
! Span C and c.
!-

		SPAN_TEXT (MASK_C, FORMAT_STR, CHAR_CNT,
			PARAM_BLK [CHARACTER]);
		PARAM_BLK [PU_MASK] = .PARAM_BLK [PU_MASK] OR C_JUSTIFY_MASK
		END;

	[CHAR_R, CHAR_LOWER_R] :
		BEGIN

!+
! Span R and r.
!-

		SPAN_TEXT (MASK_R, FORMAT_STR, CHAR_CNT,
			PARAM_BLK [CHARACTER]);
		PARAM_BLK [PU_MASK] = .PARAM_BLK [PU_MASK] OR R_JUSTIFY_MASK
		END;

	[CHAR_E, CHAR_LOWER_E] :
		BEGIN

!+
! Span E and e.
!-

		SPAN_TEXT (MASK_E, FORMAT_STR, CHAR_CNT,
			PARAM_BLK [CHARACTER]);
		PARAM_BLK [PU_MASK] = .PARAM_BLK [PU_MASK] OR EXTEND_MASK
		END;

	[CHAR_UNDERSCORE]:
!+
! Underscore causes the next format character to be ignored.  If not
! followed by a valid format character, it has no effect.  Underscore is
! handled in SPAN_CONSTANT so that the format character may be appended
! as a constant in the output string.
!-
		BEGIN
		PARAM_BLK [PU_MASK] = .PARAM_BLK [PU_MASK] OR L_JUSTIFY_MASK;
		PARAM_BLK [CHARACTER] = 1;
		RETURN 1
		END;
	
	[OTHERWISE] :
		BEGIN

!+
! Just a single quote followed by a constant string.
!-

		PARAM_BLK [PU_MASK] = .PARAM_BLK [PU_MASK] OR L_JUSTIFY_MASK;
		PARAM_BLK [CHARACTER] = 1
		END;

		TES;

RETURN 1				! return on success

END;					! End of routine SPAN_SINGLE_QUOTE

%SBTTL 'SPAN_TEXT - span various text formatting classes'
ROUTINE SPAN_TEXT (

	P_SPAN_MASK,		! mask for SPANC instruction
	P_FORMAT_STR,		! format string
	P_CHAR_CNT,		! position withing format string
	P_FORMAT_LENGTH) =	! length of format sequence

BEGIN

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine spans a particular class of text formatting characters
!	based on SPAN_MASK.
!
! CALLING SEQUENCE:
!
!	STATUS.wlc.v = SPAN_TEXT (P_SPAN_MASK, P_FORMAT_STR.rt.dx,
!		P_CHAR_CNT.ml.r, P_FORMAT_LENGTH.wl.r)
!
! FORMAL PARAMETERS:
!
!	P_SPAN_MASK	- address of a byte with the mask for the spanc
!			   instruction
!	P_FORMAT_STR	- address of string descriptor for format string
!	P_CHAR_CNT	- address of longword for character position within
!			   format string; this paramater is passed as the
!			   position 2 before the point at which the format
!			   sequence scanc should start;
!			   this parameter is returned
!			   as the last position of the format sequence
!	P_FORMAT_LENGTH	- address of longword for format length
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION CODES:
!
!	1		- routine completed successfully
!
! SIDE EFFECTS:
!
!	NONE
!
! EXAMPLES:
!
!	FORMAT_STR	CHAR_CNT (in)	CHAR_CNT (out)	FORMAT_LENGTH
!	----------	-------------	--------------	-------------
!	abc'cccdef'cc	4		7		4
!	abc'llldef'cc	4		7		4
!	abc'rrrdef'cc	4		7		4
!	abc'eeedef'cc	4		7		4
!	abc'cccdef*	4		7		4
!	ab'lab		3		4		2
!	abc'lll		4		7		4
!	abc'r		4		5		2
!	
!--

BIND
	SPAN_MASK = (P_SPAN_MASK) : BYTE,
	FORMAT_STR = (.P_FORMAT_STR) : BLOCK [, BYTE],
	CHAR_CNT = (.P_CHAR_CNT),
	FORMAT_LENGTH = (.P_FORMAT_LENGTH);

LOCAL
	FORMAT_STR_LEN : UNSIGNED WORD,	! temporary for format length in SCANC
	CHAR_PTR;			! pointer for SPANC routine return

FORMAT_STR_LEN = .FORMAT_STR [DSC$W_LENGTH] - .CHAR_CNT - 1;
CHAR_PTR = SPANC (FORMAT_STR_LEN, .FORMAT_STR [DSC$A_POINTER] + .CHAR_CNT + 1,
	CLASS_TABLE, SPAN_MASK);

IF .CHAR_PTR NEQU 0
THEN
	FORMAT_LENGTH = .CHAR_PTR - (.FORMAT_STR [DSC$A_POINTER]
		+ .CHAR_CNT - 1)	! this gets the case abc'cccdef*

ELSE IF .FORMAT_STR [DSC$W_LENGTH] - .CHAR_CNT + 1 GTRU 2
THEN
	FORMAT_LENGTH = .FORMAT_STR [DSC$W_LENGTH] - .CHAR_CNT + 1
					! this gets the case abc'lll

ELSE
	FORMAT_LENGTH = 2;		! this gets the case abc'r

CHAR_CNT = .CHAR_CNT + .FORMAT_LENGTH - 1;

RETURN 1				! return when done

END;					! End of routine SPAN_TEXT

%SBTTL 'SPAN_BACKSLASH - process backslash formatting class'
ROUTINE SPAN_BACKSLASH (

	P_FORMAT_STR,	! format string
	P_PARAM_BLK,	! print using parameter block
	P_CHAR_CNT) =	! character position within format string

BEGIN

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine finds the end of a backslash formatting sequence
!	which consists of a backslash followed by some number of blanks (>= 0)
!	followed by a backslash.  The initial backslash has been located
!	when this routine is called.  An error is returned if something
!	other than a proper backslash formatting sequence is located.
!
! CALLING SEQUENCE:
!
!	STATUS.wlc.v = SPAN_BACKSLASH (P_FORMAT_STR.rt.dx,
!		P_PARAM_BLK.mr.r, P_CHAR_CNT.ml.r)
!
! FORMAL PARAMETERS:
!
!	P_FORMAT_STR	- address of string descriptor for format string
!	P_PARAM_BLK	- address of print using parameter block
!	P_CHAR_CNT	- address of longword for character position within
!			   format string; this paramater is passed as the
!			   position 1 before the point at which the format
!			   sequence should start; this parameter is returned
!			   as the last position of the format sequence
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION CODES:
!
!	1		- routine completed successfully (format sequence
!			   for backslash located)
!	0		- no backslash format sequence located
!
! SIDE EFFECTS:
!
!	NONE
!
! EXAMPLES:
!
!	FORMAT_STR	CHAR_CNT (in)	CHAR_CNT (out)	return value
!	----------	-------------	--------------	------------
!	abc\\def	4		5		1
!	abc\   \def	4		8		1
!	abc\def		4		4		0
!	abc\   def	4		4		0
!	abc\   <eos>	4		4		0
!	
!--

BIND
	PARAM_BLK = (.P_PARAM_BLK) : BLOCK [, BYTE],
	FORMAT_STR = (.P_FORMAT_STR) : BLOCK [, BYTE],
	CHAR_CNT = (.P_CHAR_CNT);

LOCAL
	CHAR_PTR;			! pointer to possible start point
					!  for formatting sequence

PARAM_BLK [PU_MASK] = .PARAM_BLK [PU_MASK] OR L_JUSTIFY_MASK;

!+
! Span blanks; next character should then be another backslash.
!-

CHAR_PTR = CH$FIND_NOT_CH (.FORMAT_STR [DSC$W_LENGTH] - .CHAR_CNT,
	.FORMAT_STR [DSC$A_POINTER] + .CHAR_CNT, CHAR_SPACE);

!+
! CHAR_PTR should point to one past the last blank if a blank terminator
! was found; otherwise CHAR_PTR is the null pointer.
!
! In VAX-11 Bliss-32 V3, SKPC should be a BUILTIN allowing output registers
! which could make the computation of the number of charaters in the
! formatting sequence more efficient.
!-

IF CH$FAIL (.CHAR_PTR)
THEN
	RETURN 0			! this return gets the case
					!  abc\   <eos>
					!  which is a print using format error

ELSE
	BEGIN
	BIND CHARS = (.CHAR_PTR) : VECTOR [, BYTE];

!+
! Make sure that the first character past the blanks is a backslash.
!-

	IF .CHARS [0] EQLU CHAR_BACKSLASH
	THEN
		BEGIN
		PARAM_BLK [CHARACTER] = .CHAR_PTR -
			(.FORMAT_STR [DSC$A_POINTER] + .CHAR_CNT) + 2;
		CHAR_CNT = .CHAR_CNT + .PARAM_BLK [CHARACTER] - 1;
		RETURN 1;		! this return gets the case abc\   \def
					!  or the case abc\\def
		END

	ELSE
		RETURN 0;		! this return gets the case abc\   def

	END

END;					! End of routine SPAN_BACKSLASH

%SBTTL 'SPAN_BRACKET - process < > formatting classes'
ROUTINE SPAN_BRACKET (

	FORMAT_CHAR,	! format character within < >
	P_FORMAT_STR,	! format string
	P_PARAM_BLK,	! print using parameter block
	P_CHAR_CNT) =	! character position within format string

BEGIN

!++
!
! FUNCTIONAL DESCRIPTION:
!
! This routine looks for a valid '< >' sequence.  Since some diagraphs
! precede format characters and some follow, the calling program must
! specify what particular sequence is valid at that point, and only that
! sequence is searched for.
!
! If a '$$' or '**' has been found, then if '<%>' or '<0>' is 
! present, it must precede all other characters.  So this routine should be 
! called before SPAN_NUMERIC finishes processing the format string.
!
! SPAN_NUMERIC will also call this routine to check for '<CD>' at the end
! of a format string.
!
! CALLING SEQUENCE:
!
!	STATUS.wlc.v = SPAN_BRACKET (FORMAT_CHAR.rt.r, P_FORMAT_STR.rt.dx,
!		P_PARAM_BLK.mr.r, P_CHAR_CNT.ml.r)
!
! FORMAL PARAMETERS:
!
!	FORMAT_CHAR   - address of format character within < >
!	P_FORMAT_STR	- address of string descriptor for format string
!	P_PARAM_BLK	- address of print using parameter block
!	P_CHAR_CNT	- address of longword for character position within
!			   format string; this paramater is passed as the
!			   position 1 before the point at which the format
!			   sequence should start; this parameter is returned
!			   as the last position of the format sequence
!
! IMPLICIT INPUTS:
!
!	NONE
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION CODES:
!
!	1		- routine completed successfully (format sequence
!			  located)
!	0		- no format sequence located
!
! SIDE EFFECTS:
!
!	NONE
!
! EXAMPLES:
!
!	FORMAT_STR	CHAR_CNT (in)	CHAR_CNT (out)	return value
!	----------	-------------	--------------	------------
!	
!	$$<%>###.##		3		5		1
!	**##.##			3		3		0
!	$$<0>###,###.##-	3		5		1
!	$$###,###.##-		3		3		0
!--

BIND
	PARAM_BLK = (.P_PARAM_BLK) : BLOCK [, BYTE],
	FORMAT_STR = (.P_FORMAT_STR) : BLOCK [, BYTE],
	CHAR_CNT = (.P_CHAR_CNT);

LOCAL
	SUPPRESS_STR,
	LEADING_STR,
	FOUND_PTR,
	CD_STR;

!+
! Future formatting characters will be of the form '<x>'.  This
! routine is set up to allow new characters to be added easily.
!-

SELECTONEU .FORMAT_CHAR OF
	SET
	[CHAR_PERCENT]:
!+
! Suppress a zero value.
!-
	BEGIN
	SUPPRESS_STR = %ASCIZ'<%>';
	FOUND_PTR = CH$FIND_SUB (3,
			         .FORMAT_STR [DSC$A_POINTER] + .CHAR_CNT,
			         3, CH$PTR (SUPPRESS_STR));
	IF (NOT CH$FAIL (.FOUND_PTR))
	THEN
		BEGIN
		PARAM_BLK [PU_MASK] = .PARAM_BLK [PU_MASK] OR PERCENT_MASK;
		CHAR_CNT = .CHAR_CNT + 3;
		PARAM_BLK [INTEGER_DIGITS] = .PARAM_BLK [INTEGER_DIGITS] + 1;
		RETURN 1;			! '<%>' was found
		END;
	END;

	[CHAR_ZERO]:
!+
! Print leading zeroes.
!-
	BEGIN
	LEADING_STR = %ASCIZ'<0>';
	FOUND_PTR = CH$FIND_SUB (3,
				 .FORMAT_STR [DSC$A_POINTER] + .CHAR_CNT,
			  	 3, CH$PTR (LEADING_STR));
	IF (NOT CH$FAIL (.FOUND_PTR)) 
	THEN
		BEGIN
		PARAM_BLK [PU_MASK] = .PARAM_BLK [PU_MASK] OR ZERO_MASK;
		CHAR_CNT = .CHAR_CNT + 3;
		PARAM_BLK [INTEGER_DIGITS] = .PARAM_BLK [INTEGER_DIGITS] + 1;
		RETURN 1;			! '<0>' was found	
		END;
	END;

	[CHAR_C, CHAR_LOWER_C]:
	BEGIN
!+
! Credit/debit.
!-
	!+
	! First, check for <CD>.
	!-
	CD_STR = %ASCII'<CD>';
	FOUND_PTR = CH$FIND_SUB (4,
				 .FORMAT_STR [DSC$A_POINTER] + .CHAR_CNT,
				 4, CH$PTR (CD_STR));
	IF (NOT CH$FAIL (.FOUND_PTR))
	THEN
		BEGIN
		PARAM_BLK [PU_MASK] = .PARAM_BLK [PU_MASK] OR CD_MASK;
		CHAR_CNT = .CHAR_CNT + 4;
		PARAM_BLK [INTEGER_DIGITS] = .PARAM_BLK [INTEGER_DIGITS] + 1;
		RETURN 1;
		END;

	!+
	! Then check for <cd>.
	!-
	CD_STR = %ASCII'<cd>';
	FOUND_PTR = CH$FIND_SUB (4,
				 .FORMAT_STR [DSC$A_POINTER] + .CHAR_CNT,
				 4, CH$PTR (CD_STR));
	IF (NOT CH$FAIL (.FOUND_PTR))
	THEN
		BEGIN
		PARAM_BLK [PU_MASK] = .PARAM_BLK [PU_MASK] OR CD_MASK;
		CHAR_CNT = .CHAR_CNT + 4;
		PARAM_BLK [INTEGER_DIGITS] = .PARAM_BLK [INTEGER_DIGITS] + 1;
		RETURN 1;
		END;

	END;
	
	[OTHERWISE]:
!+
! Should never reach here.
!-
	RETURN 0;

	TES;

!+
! If we get here no '<x>' was found.
!-
	RETURN 0;

END;					! End of routine SPAN_BRACKET

%SBTTL 'SPAN_NUMERIC - processing numeric format class'
ROUTINE SPAN_NUMERIC (

	P_SPAN_MODE,	! numeric formatting mode
	P_FORMAT_STR,	! format string
	P_CHAR_CNT,	! position withing format string
	P_PARAM_BLK) =	! print using parameter block

BEGIN

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This routine handles various portions of a numeric formatting
!	sequence based on SPAN_MODE.  CHAR_CNT will be returned as the last
!	character of the particular portion of the numeric formatting
!	sequence under consideration.  This routine will call itself
!	recursively.  NUMERIC_MASK should be set in the main driving
!	routine before a call to this routine.
!
! CALLING SEQUENCE:
!
!	STATUS.wlc.v = SPAN_NUMERIC (P_SPAN_MODE.rl.r, P_FORMAT_STR.rt.dx,
!		P_CHAR_CNT.ml.r, P_PARAM_BLK.mr.r)
!
! FORMAL PARAMETERS:
!
!	P_SPAN_MODE	- address of longword for type of numeric span
!	P_FORMAT_STR	- address of string descriptor for format string
!	P_CHAR_CNT	- address of longword for character position within
!			   format string; this paramater is passed as the
!			   position 1 before the point at which the format
!			   sequence should start; this parameter is passed
!			   as the position 1 before the starting character
!			   position of the format sequence
!	P_PARAM_BLK	- address of print using parameter block
!
! IMPLICIT INPUTS:
!
!	DIGIT_SEP_DESC	- descriptor for digit group separator
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! COMPLETION CODES:
!
!	1		- routine completed successfully
!
! SIDE EFFECTS:
!
!	NONE
!	
!--

BIND
	SPAN_MODE = (P_SPAN_MODE),
	FORMAT_STR = (.P_FORMAT_STR) : BLOCK [, BYTE],
	PARAM_BLK = (.P_PARAM_BLK) : BLOCK [, BYTE],
	CHAR_CNT = (.P_CHAR_CNT);

MAP
	DIGIT_SEP_DESC : BLOCK [, BYTE];

LOCAL
	E_FLAG,		! 1 if E formatting is allowed; 0 otherwise
	PERIOD_MODE,	! fraction mode (either _E or _NO_E)
	INTEGER_MODE,	! 1 if integer mode; 0 otherwise (fraction mode)
	TMP_LEN,	! temporary length for format sequence
	CHAR_PTR;	! pointer to character in format string

CASE .SPAN_MODE FROM K_SPAN_INTEGER TO K_SPAN_FRACTION_NO_E OF
	SET

	[K_SPAN_INTEGER] :
		BEGIN
		E_FLAG = 1;
		PERIOD_MODE = K_SPAN_FRACTION;
		INTEGER_MODE = 1
		END;

	[K_SPAN_INTEGER_NO_E] :
		BEGIN
		E_FLAG = 0;
		PERIOD_MODE = K_SPAN_FRACTION_NO_E;
		INTEGER_MODE = 1
		END;

	[K_SPAN_FRACTION] :
		BEGIN
		E_FLAG = 1;
		INTEGER_MODE = 0
		END;

	[K_SPAN_FRACTION_NO_E] :
		BEGIN
		E_FLAG = 0;
		INTEGER_MODE = 0
		END;

	[OUTRANGE] :

!+
! This should never happen.
!-

		RETURN 0		! return here is an internal error

	TES;

!+
! Span pound signs.
!
! In VAX-11 Bliss-32 V3, SKPC should be a BUILTIN allowing output registers
! which could make the computation of the number of charaters in the
! formatting sequence more efficient.
!-

CHAR_PTR = CH$FIND_NOT_CH (.FORMAT_STR [DSC$W_LENGTH] - .CHAR_CNT,
	.FORMAT_STR [DSC$A_POINTER] + .CHAR_CNT, CHAR_POUND);

IF CH$FAIL (.CHAR_PTR)
THEN
	BEGIN
	IF .INTEGER_MODE
	THEN
		PARAM_BLK [INTEGER_DIGITS] = .PARAM_BLK [INTEGER_DIGITS]
			+ .FORMAT_STR [DSC$W_LENGTH] - .CHAR_CNT

	ELSE
		PARAM_BLK [FRACTION_DIGIT] = .PARAM_BLK [FRACTION_DIGIT]
			+ .FORMAT_STR [DSC$W_LENGTH] - .CHAR_CNT;
					! remember that there is already
					!  one fraction digit in the '.#' case

	CHAR_CNT = .FORMAT_STR [DSC$W_LENGTH];
	END

ELSE
	BEGIN
	BIND CHARS = (.CHAR_PTR) : VECTOR [, BYTE];
	TMP_LEN = .CHAR_PTR - (.FORMAT_STR [DSC$A_POINTER] + .CHAR_CNT);
	IF .INTEGER_MODE
	THEN
		PARAM_BLK [INTEGER_DIGITS] = .PARAM_BLK [INTEGER_DIGITS]
			+ .TMP_LEN

	ELSE
		PARAM_BLK [FRACTION_DIGIT] = .PARAM_BLK [FRACTION_DIGIT]
			+ .TMP_LEN;
					! remember that there is already
					!  one fraction digit in the '.#' case

	CHAR_CNT = .CHAR_CNT + .TMP_LEN;

	SELECTONEU .CHARS [0] OF
	    SET

	    [CHAR_COMMA] :

!+
! Commas should not occur in the fractional part.
!-

		IF .INTEGER_MODE
		THEN
			BEGIN

!+
! Each comma is picked up separately rather than doing a spanc instruction
! with pound signs and commas since the digit separator on output can
! have a length other than 1.
!-

			PARAM_BLK [PU_MASK] = .PARAM_BLK [PU_MASK]
				OR COMMA_MASK;
			PARAM_BLK [INTEGER_DIGITS] =
				.PARAM_BLK [INTEGER_DIGITS]
				+ .DIGIT_SEP_DESC [DSC$W_LENGTH];
			CHAR_CNT = .CHAR_CNT + 1;
			SPAN_NUMERIC (K_SPAN_INTEGER_NO_E,
				FORMAT_STR, CHAR_CNT, PARAM_BLK)
			END;

	    [CHAR_PERIOD] :

!+
! Periods should not occur in the fractional part.
!-

		IF .INTEGER_MODE
		THEN
			BEGIN
			PARAM_BLK [PU_MASK] = .PARAM_BLK [PU_MASK]
				OR PERIOD_MASK;
			CHAR_CNT = .CHAR_CNT + 1;
			SPAN_NUMERIC (.PERIOD_MODE, FORMAT_STR, CHAR_CNT,
				PARAM_BLK)
			END;

	    [CHAR_MINUS] :
		BEGIN
		CHAR_CNT = .CHAR_CNT + 1;
		PARAM_BLK [PU_MASK] = .PARAM_BLK [PU_MASK] OR MINUS_MASK
		END;

	    [CHAR_CARAT] :
		IF .E_FLAG
		THEN
			BEGIN

!+
! If the next three characters are carats, we should indicate that E format
! is desired and move CHAR_CNT to last carat.
!
! For efficiency, we make sure that we have four carats beginning with
! the character pointed to by CHAR_PTR which we know is a carat.
!-

			IF .FORMAT_STR [DSC$W_LENGTH] - .CHAR_CNT GTRU 3
				AND ..CHAR_PTR EQLU .E_FORMAT
					! Note that we want .. here since
					!  CHAR_PTR is an address
					!  and we want the actual value
					!  pointed to by that address
			THEN
				BEGIN
				PARAM_BLK [PU_MASK] = .PARAM_BLK [PU_MASK]
					OR E_MASK;
				CHAR_CNT = .CHAR_CNT + 4;
				END

			END;


	    [CHAR_LF_ANGLE]:
!+
! IF '<CD>' is present, it will be the last thing in the format string.
! Call SPAN_BRACKET to check for it.
!-
		SPAN_BRACKET (CHAR_C, FORMAT_STR, PARAM_BLK, CHAR_CNT);
	
	    TES

	END;

RETURN 1

END;					! End of routine SPAN_NUMERIC

%SBTTL 'OUTPUT_ARG - convert and format'
ROUTINE OUTPUT_ARG (			! convert and format the argument

	P_PARAM_BLK) =	! print using paramter block

BEGIN

!++
!
! FUNCTIONAL DESCRIPTION:
!
!	This action routine is the heart of the whole thing.
!	All of the formatting and most of the error checking will be done here.
!
! FORMAL PARAMETERS:
!
!	P_PARAM_BLK.mr.r	- parameter block
!
! IMPLICIT INPUTS:
!
!	CURRENCY_DESC		- descriptor for currency symbol
!	DIGIT_SEP_DESC		- descriptor for digit group separator
!	RADIX_PT_DESC		- descriptor for radix point
!
! IMPLICIT OUTPUTS:
!
!	NONE
!
! ROUTINE VALUE:
!
!	NONE
!
! SIDE EFFECTS:
!
!	NONE
!
!--

    LOCAL
	TEMP_MASK,				! temp for param_blk [pu_mask]
	DSC : BLOCK [8, BYTE],			! temp for converting and concatenating
	OUT_STR_LEN;				! length returned by conversion routine

    BIND
	PARAM_BLK = (.P_PARAM_BLK) : BLOCK [, BYTE];

    !+
    ! Do error checking for the format field.
    !-

    !+
    ! Set up a temp dynamic string descriptor to use for numeric and text conversions and
    ! string concatenates.
    !-

    DSC [DSC$W_LENGTH] = 0;
    DSC [DSC$B_CLASS] = DSC$K_CLASS_D;
    DSC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
    DSC [DSC$A_POINTER] = 0;

    !+
    ! Use a temporary print using mask in the following SELECT statements.
    ! This is because zero_mask and percent_mask fall outside the range
    ! 0 to e_mask, but they are f formats. 
    !-
    
    TEMP_MASK = .PARAM_BLK [PU_MASK];

    IF (.PARAM_BLK [PU_MASK] AND ZERO_MASK) NEQ 0 
    THEN TEMP_MASK = .TEMP_MASK XOR ZERO_MASK;

    IF (.PARAM_BLK [PU_MASK] AND PERCENT_MASK) NEQ 0
    THEN TEMP_MASK = .TEMP_MASK XOR PERCENT_MASK;

    IF (.PARAM_BLK [PU_MASK] AND CD_MASK) NEQ 0
    THEN TEMP_MASK = .TEMP_MASK XOR CD_MASK;
    !+
    ! This is where the action is.  A case is done on the data type to determine
    ! the proper syntaxing and the conversions which are necessary.  The conversion
    ! routines do most of the formatting.
    !-

    CASE .PARAM_BLK [ELEM_TYPE] FROM DSC$K_DTYPE_B TO DSC$K_DTYPE_H OF
	SET

	[DSC$K_DTYPE_B, DSC$K_DTYPE_W, DSC$K_DTYPE_L] :
	    BEGIN

	    !+
	    ! Integers.
	    ! Do the necessary syntax checking.
	    ! Convert the value to double precision and call the appropriate
	    ! conversion.
	    !-

	    LOCAL
		D_VALUE : VECTOR [2];		! hold double precision floating value

	    CVTLD (.PARAM_BLK [ELEM], D_VALUE [0]);

	    SELECTONEU .TEMP_MASK OF
		SET

		[0 TO E_MASK - 1] :

		    !+
		    ! F format
		    !-

		    IF NOT BAS$CVT_OUT_D_F (D_VALUE, .PARAM_BLK [INTEGER_DIGITS],
			    .PARAM_BLK [FRACTION_DIGIT],
			    (PARAM_BLK [PU_MASK] = .PARAM_BLK [PU_MASK] AND K_CVT_FLAGS;
			    .PARAM_BLK [PU_MASK]), 
			    OUT_STR_LEN, DSC, 0,	! Scale factor
			    CURRENCY_DESC, DIGIT_SEP_DESC, RADIX_PT_DESC)
		    THEN
			BEGIN

			!+
			! The number will not fit into the field width supplied.  So the
			! number is returned in Print format with a '% ' appended.
			!-

			LOCAL
			    PERCENT_DESC : BLOCK [8, BYTE];

			PERCENT_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
			PERCENT_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
			PERCENT_DESC [DSC$W_LENGTH] = 1;
			PERCENT_DESC [DSC$A_POINTER] = PERCENT;
			BAS$CVT_OUT_D_G (D_VALUE, 0, OUT_STR_LEN, DSC, 0);
			STR$CONCAT (.PARAM_BLK [RET_STR], .PARAM_BLK [RET_STR], PERCENT_DESC, DSC);
			END
		    ELSE
			STR$CONCAT (.PARAM_BLK [RET_STR], .PARAM_BLK [RET_STR], DSC);

		[E_MASK TO R_JUSTIFY_MASK - 1] :

		    !+
		    ! E format
		    !-

		    IF NOT BAS$CVT_OUT_D_E (D_VALUE, .PARAM_BLK [INTEGER_DIGITS],
			    .PARAM_BLK [FRACTION_DIGIT],
			    (PARAM_BLK [PU_MASK] = .PARAM_BLK [PU_MASK] AND K_CVT_FLAGS; .PARAM_BLK [PU_MASK]
			    ), OUT_STR_LEN, .PARAM_BLK [RET_STR], 0,	! Scale factor
			    CURRENCY_DESC, DIGIT_SEP_DESC, RADIX_PT_DESC)
		    THEN
			BEGIN

			!+
			! The number will not fit into the field width supplied.  So the
			! number is returned in Print format with a '% ' appended.
			!-

			LOCAL
			    PERCENT_DESC : BLOCK [8, BYTE];

			PERCENT_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
			PERCENT_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
			PERCENT_DESC [DSC$W_LENGTH] = 1;
			PERCENT_DESC [DSC$A_POINTER] = PERCENT;
			BAS$CVT_OUT_D_G (D_VALUE, 0, OUT_STR_LEN, DSC, 0);
			STR$CONCAT (.PARAM_BLK [RET_STR], .PARAM_BLK [RET_STR], PERCENT_DESC, DSC);
			END
		    ELSE
			STR$CONCAT (.PARAM_BLK [RET_STR], .PARAM_BLK [RET_STR], DSC);

		[OTHERWISE] :
!+
! Text formats
!-
		    BAS$$STOP (BAS$K_PRIUSIFOR);
		TES;

	    END;

	[DSC$K_DTYPE_F] :

	    !+
	    ! Floating - single precision
	    !-

	    BEGIN

	    SELECTONEU .TEMP_MASK OF
		SET

		[0 TO E_MASK - 1] :

		    !+
		    ! F format
		    !-

		    IF NOT BAS$CVT_OUT_F_F (.PARAM_BLK [ELEM], .PARAM_BLK [INTEGER_DIGITS],
			    .PARAM_BLK [FRACTION_DIGIT],
			    (PARAM_BLK [PU_MASK] = .PARAM_BLK [PU_MASK] AND K_CVT_FLAGS;
			    .PARAM_BLK [PU_MASK]),
			    OUT_STR_LEN, DSC,
			    CURRENCY_DESC, DIGIT_SEP_DESC, RADIX_PT_DESC)
		    THEN
			BEGIN

			!+
			! The number will not fit into the field width supplied.  So the
			! number is returned in Print format with a '% ' appended.
			!-

			LOCAL
			    PERCENT_DESC : BLOCK [8, BYTE];

			PERCENT_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
			PERCENT_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
			PERCENT_DESC [DSC$W_LENGTH] = 1;
			PERCENT_DESC [DSC$A_POINTER] = PERCENT;
			BAS$CVT_OUT_D_G (.PARAM_BLK [ELEM], 0, OUT_STR_LEN, DSC, 0);
			STR$CONCAT (.PARAM_BLK [RET_STR], .PARAM_BLK [RET_STR], PERCENT_DESC, DSC);
			END
		    ELSE
			STR$CONCAT (.PARAM_BLK [RET_STR], .PARAM_BLK [RET_STR], DSC);

		[E_MASK TO R_JUSTIFY_MASK - 1] :

		    !+
		    ! E format
		    !-

		    IF NOT BAS$CVT_OUT_F_E (.PARAM_BLK [ELEM], .PARAM_BLK [INTEGER_DIGITS],
			    .PARAM_BLK [FRACTION_DIGIT],
			    (PARAM_BLK [PU_MASK] = .PARAM_BLK [PU_MASK] AND K_CVT_FLAGS; .PARAM_BLK [PU_MASK]
			    ), OUT_STR_LEN, .PARAM_BLK [RET_STR],
			    CURRENCY_DESC, DIGIT_SEP_DESC, RADIX_PT_DESC)
		    THEN
!+
! E format will only not fit when a negative number is expected to fit in a
! field of width 1.
!-
			BEGIN

			!+
			! The number will not fit into the field width supplied.  So the
			! number is returned in Print format with a '% ' appended.
			!-

			LOCAL
			    PERCENT_DESC : BLOCK [8, BYTE];

			PERCENT_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
			PERCENT_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
			PERCENT_DESC [DSC$W_LENGTH] = 1;
			PERCENT_DESC [DSC$A_POINTER] = PERCENT;
			BAS$CVT_OUT_D_G (.PARAM_BLK [ELEM], 0, OUT_STR_LEN, DSC, 0);
			STR$CONCAT (.PARAM_BLK [RET_STR], .PARAM_BLK [RET_STR], PERCENT_DESC, DSC);
			END
		    ELSE
			STR$CONCAT (.PARAM_BLK [RET_STR], .PARAM_BLK [RET_STR], DSC);

		[OTHERWISE] :

		    !+
		    ! Text formats
		    !-

		    BAS$$STOP (BAS$K_PRIUSIFOR);
		TES;

	    END;

	[DSC$K_DTYPE_D] :

	    !+
	    ! Floating - double precision
	    !-

	    BEGIN

	    SELECTONEU .TEMP_MASK OF
		SET

		[0 TO E_MASK - 1] :

		    !+
		    ! F format
		    !-

		    IF NOT BAS$CVT_OUT_D_F (.PARAM_BLK [ELEM], .PARAM_BLK [INTEGER_DIGITS],
			    .PARAM_BLK [FRACTION_DIGIT],
			    (PARAM_BLK [PU_MASK] = .PARAM_BLK [PU_MASK] AND K_CVT_FLAGS;
			    .PARAM_BLK [PU_MASK]),
			    OUT_STR_LEN, DSC, .PARAM_BLK [SCALE_FACTOR],	! Scale factor
			    CURRENCY_DESC, DIGIT_SEP_DESC, RADIX_PT_DESC)
		    THEN
			BEGIN

			!+
			! The number will not fit into the field width supplied.  So the
			! number is returned in Print format with a '% ' appended.
			!-

			LOCAL
			    PERCENT_DESC : BLOCK [8, BYTE];

			PERCENT_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
			PERCENT_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
			PERCENT_DESC [DSC$W_LENGTH] = 1;
			PERCENT_DESC [DSC$A_POINTER] = PERCENT;
			BAS$CVT_OUT_D_G (.PARAM_BLK [ELEM], 0, OUT_STR_LEN, DSC, .PARAM_BLK [SCALE_FACTOR]);
			STR$CONCAT (.PARAM_BLK [RET_STR], .PARAM_BLK [RET_STR], PERCENT_DESC, DSC);
			END
		    ELSE
			STR$CONCAT (.PARAM_BLK [RET_STR], .PARAM_BLK [RET_STR], DSC);

		[E_MASK TO R_JUSTIFY_MASK - 1] :

		    !+
		    ! E format
		    !-

		    IF NOT BAS$CVT_OUT_D_E (.PARAM_BLK [ELEM], .PARAM_BLK [INTEGER_DIGITS],
			    .PARAM_BLK [FRACTION_DIGIT],
			    (PARAM_BLK [PU_MASK] = .PARAM_BLK [PU_MASK] AND K_CVT_FLAGS; .PARAM_BLK [PU_MASK]
			    ), OUT_STR_LEN, .PARAM_BLK [RET_STR], .PARAM_BLK [SCALE_FACTOR],	! Scale factor
			    CURRENCY_DESC, DIGIT_SEP_DESC, RADIX_PT_DESC)
		    THEN
			BEGIN

			!+
			! The number will not fit into the field width supplied.  So the
			! number is returned in Print format with a '% ' appended.
			!-

			LOCAL
			    PERCENT_DESC : BLOCK [8, BYTE];

			PERCENT_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
			PERCENT_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
			PERCENT_DESC [DSC$W_LENGTH] = 1;
			PERCENT_DESC [DSC$A_POINTER] = PERCENT;
			BAS$CVT_OUT_D_G (.PARAM_BLK [ELEM], 0, OUT_STR_LEN, DSC, .PARAM_BLK [SCALE_FACTOR]);
			STR$CONCAT (.PARAM_BLK [RET_STR], .PARAM_BLK [RET_STR], PERCENT_DESC, DSC);
			END
		    ELSE
			STR$CONCAT (.PARAM_BLK [RET_STR], .PARAM_BLK [RET_STR], DSC);

		[OTHERWISE] :

		    !+
		    ! Text formats
		    !-

		    BAS$$STOP (BAS$K_PRIUSIFOR);
		TES;

	    END;

	[DSC$K_DTYPE_P] :

	    !+
	    ! Packed decimal string
	    !-

	    BEGIN

	    SELECTONEU .TEMP_MASK OF
		SET

		[0 TO E_MASK - 1] :

		    !+
		    ! F format
		    !-

		    IF NOT BAS$CVT_OUT_P_F (.PARAM_BLK [ELEM], .PARAM_BLK [INTEGER_DIGITS],
			    .PARAM_BLK [FRACTION_DIGIT],
			    (PARAM_BLK [PU_MASK] = .PARAM_BLK [PU_MASK] AND K_CVT_FLAGS;
			    .PARAM_BLK [PU_MASK]),
			    OUT_STR_LEN, DSC,
			    CURRENCY_DESC, DIGIT_SEP_DESC, RADIX_PT_DESC)
		    THEN
			BEGIN

			!+
			! The number will not fit into the field width supplied.  So the
			! number is returned in Print format with a '% ' appended.
			!-

			LOCAL
			    PERCENT_DESC : BLOCK [8, BYTE];

			PERCENT_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
			PERCENT_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
			PERCENT_DESC [DSC$W_LENGTH] = 1;
			PERCENT_DESC [DSC$A_POINTER] = PERCENT;
			BAS$CVT_OUT_P_G (.PARAM_BLK [ELEM], 0, OUT_STR_LEN, DSC);
			STR$CONCAT (.PARAM_BLK [RET_STR], .PARAM_BLK [RET_STR], PERCENT_DESC, DSC);
			END
		    ELSE
			STR$CONCAT (.PARAM_BLK [RET_STR], .PARAM_BLK [RET_STR], DSC);

		[E_MASK TO R_JUSTIFY_MASK - 1] :

		    !+
		    ! E format
		    !-

		    IF NOT BAS$CVT_OUT_P_E (.PARAM_BLK [ELEM], .PARAM_BLK [INTEGER_DIGITS],
			    .PARAM_BLK [FRACTION_DIGIT],
			    (PARAM_BLK [PU_MASK] = .PARAM_BLK [PU_MASK] AND K_CVT_FLAGS; .PARAM_BLK [PU_MASK]
			    ), OUT_STR_LEN, .PARAM_BLK [RET_STR],
			    CURRENCY_DESC, DIGIT_SEP_DESC, RADIX_PT_DESC)
		    THEN
!+
! E format will only not fit when a negative number is expected to fit in a
! field of width 1.
!-
			BEGIN

			!+
			! The number will not fit into the field width supplied.  So the
			! number is returned in Print format with a '% ' appended.
			!-

			LOCAL
			    PERCENT_DESC : BLOCK [8, BYTE];

			PERCENT_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
			PERCENT_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
			PERCENT_DESC [DSC$W_LENGTH] = 1;
			PERCENT_DESC [DSC$A_POINTER] = PERCENT;
			BAS$CVT_OUT_P_G (.PARAM_BLK [ELEM], 0, OUT_STR_LEN, DSC);
			STR$CONCAT (.PARAM_BLK [RET_STR], .PARAM_BLK [RET_STR], PERCENT_DESC, DSC);
			END
		    ELSE
			STR$CONCAT (.PARAM_BLK [RET_STR], .PARAM_BLK [RET_STR], DSC);

		[OTHERWISE] :

		    !+
		    ! Text formats
		    !-

		    BAS$$STOP (BAS$K_PRIUSIFOR);
		TES;

	    END;

	[DSC$K_DTYPE_G] :

	    !+
	    ! G Floating 
	    !-

	    BEGIN

	    SELECTONEU .TEMP_MASK OF
		SET

		[0 TO E_MASK - 1] :

		    !+
		    ! F format
		    !-

		    IF NOT BAS$CVT_OUT_G_F (.PARAM_BLK [ELEM], .PARAM_BLK [INTEGER_DIGITS],
			    .PARAM_BLK [FRACTION_DIGIT],
			    (PARAM_BLK [PU_MASK] = .PARAM_BLK [PU_MASK] AND K_CVT_FLAGS;
			    .PARAM_BLK [PU_MASK]),
			    OUT_STR_LEN, DSC, 
			    CURRENCY_DESC, DIGIT_SEP_DESC, RADIX_PT_DESC)
		    THEN
			BEGIN

			!+
			! The number will not fit into the field width supplied.  So the
			! number is returned in Print format with a '% ' appended.
			!-

			LOCAL
			    PERCENT_DESC : BLOCK [8, BYTE];

			PERCENT_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
			PERCENT_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
			PERCENT_DESC [DSC$W_LENGTH] = 1;
			PERCENT_DESC [DSC$A_POINTER] = PERCENT;
			BAS$CVT_OUT_G_G (.PARAM_BLK [ELEM], 0, OUT_STR_LEN, DSC);
			STR$CONCAT (.PARAM_BLK [RET_STR], .PARAM_BLK [RET_STR], PERCENT_DESC, DSC);
			END
		    ELSE
			STR$CONCAT (.PARAM_BLK [RET_STR], .PARAM_BLK [RET_STR], DSC);

		[E_MASK TO R_JUSTIFY_MASK - 1] :

		    !+
		    ! E format
		    !-

		    IF NOT BAS$CVT_OUT_G_E (.PARAM_BLK [ELEM], .PARAM_BLK [INTEGER_DIGITS],
			    .PARAM_BLK [FRACTION_DIGIT],
			    (PARAM_BLK [PU_MASK] = .PARAM_BLK [PU_MASK] AND K_CVT_FLAGS; .PARAM_BLK [PU_MASK]
			    ), OUT_STR_LEN, .PARAM_BLK [RET_STR], 
			    CURRENCY_DESC, DIGIT_SEP_DESC, RADIX_PT_DESC)
		    THEN
			BEGIN

			!+
			! The number will not fit into the field width supplied.  So the
			! number is returned in Print format with a '% ' appended.
			!-

			LOCAL
			    PERCENT_DESC : BLOCK [8, BYTE];

			PERCENT_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
			PERCENT_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
			PERCENT_DESC [DSC$W_LENGTH] = 1;
			PERCENT_DESC [DSC$A_POINTER] = PERCENT;
			BAS$CVT_OUT_G_G (.PARAM_BLK [ELEM], 0, OUT_STR_LEN, DSC);
			STR$CONCAT (.PARAM_BLK [RET_STR], .PARAM_BLK [RET_STR], PERCENT_DESC, DSC);
			END
		    ELSE
			STR$CONCAT (.PARAM_BLK [RET_STR], .PARAM_BLK [RET_STR], DSC);

		[OTHERWISE] :

		    !+
		    ! Text formats
		    !-

		    BAS$$STOP (BAS$K_PRIUSIFOR);
		TES;

	    END;

	[DSC$K_DTYPE_H] :

	    !+
	    ! H Floating 
	    !-

	    BEGIN

	    SELECTONEU .TEMP_MASK OF
		SET

		[0 TO E_MASK - 1] :

		    !+
		    ! F format
		    !-

		    IF NOT BAS$CVT_OUT_H_F (.PARAM_BLK [ELEM], .PARAM_BLK [INTEGER_DIGITS],
			    .PARAM_BLK [FRACTION_DIGIT],
			    (PARAM_BLK [PU_MASK] = .PARAM_BLK [PU_MASK] AND K_CVT_FLAGS;
			    .PARAM_BLK [PU_MASK]),
			    OUT_STR_LEN, DSC, 
			    CURRENCY_DESC, DIGIT_SEP_DESC, RADIX_PT_DESC)
		    THEN
			BEGIN

			!+
			! The number will not fit into the field width supplied.  So the
			! number is returned in Print format with a '% ' appended.
			!-

			LOCAL
			    PERCENT_DESC : BLOCK [8, BYTE];

			PERCENT_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
			PERCENT_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
			PERCENT_DESC [DSC$W_LENGTH] = 1;
			PERCENT_DESC [DSC$A_POINTER] = PERCENT;
			BAS$CVT_OUT_H_G (.PARAM_BLK [ELEM], 0, OUT_STR_LEN, DSC);
			STR$CONCAT (.PARAM_BLK [RET_STR], .PARAM_BLK [RET_STR], PERCENT_DESC, DSC);
			END
		    ELSE
			STR$CONCAT (.PARAM_BLK [RET_STR], .PARAM_BLK [RET_STR], DSC);

		[E_MASK TO R_JUSTIFY_MASK - 1] :

		    !+
		    ! E format
		    !-

		    IF NOT BAS$CVT_OUT_H_E (.PARAM_BLK [ELEM], .PARAM_BLK [INTEGER_DIGITS],
			    .PARAM_BLK [FRACTION_DIGIT],
			    (PARAM_BLK [PU_MASK] = .PARAM_BLK [PU_MASK] AND K_CVT_FLAGS; .PARAM_BLK [PU_MASK]
			    ), OUT_STR_LEN, .PARAM_BLK [RET_STR], 
			    CURRENCY_DESC, DIGIT_SEP_DESC, RADIX_PT_DESC)
		    THEN
			BEGIN

			!+
			! The number will not fit into the field width supplied.  So the
			! number is returned in Print format with a '% ' appended.
			!-

			LOCAL
			    PERCENT_DESC : BLOCK [8, BYTE];

			PERCENT_DESC [DSC$B_CLASS] = DSC$K_CLASS_S;
			PERCENT_DESC [DSC$B_DTYPE] = DSC$K_DTYPE_T;
			PERCENT_DESC [DSC$W_LENGTH] = 1;
			PERCENT_DESC [DSC$A_POINTER] = PERCENT;
			BAS$CVT_OUT_H_G (.PARAM_BLK [ELEM], 0, OUT_STR_LEN, DSC);
			STR$CONCAT (.PARAM_BLK [RET_STR], .PARAM_BLK [RET_STR], PERCENT_DESC, DSC);
			END
		    ELSE
			STR$CONCAT (.PARAM_BLK [RET_STR], .PARAM_BLK [RET_STR], DSC);

		[OTHERWISE] :

		    !+
		    ! Text formats
		    !-

		    BAS$$STOP (BAS$K_PRIUSIFOR);
		TES;

	    END;

	[DSC$K_DTYPE_T] :

	    !+
	    ! Text
	    !-

	    BEGIN

	    !+
	    ! Allocate a temporary and make it a fixed length string so that
	    ! truncating and padding occur properly.
	    !-

	    STR$GET1_DX (PARAM_BLK [CHARACTER], DSC);
	    DSC [DSC$B_CLASS] = DSC$K_CLASS_S;

	    !+
	    ! Based on the bits in PU_MASK, go do the right type of justification
	    !-

	    SELECTONEU .PARAM_BLK [PU_MASK] OF
		SET

		[L_JUSTIFY_MASK] :
		    BEGIN

		    !+
		    ! Left justify the string in the return string
		    ! This should just amount in a copy.  Truncate on the right if necessary.
		    !-

		    STR$COPY_DX_R8 (DSC, .PARAM_BLK [ELEM]);
		    STR$CONCAT (.PARAM_BLK [RET_STR], .PARAM_BLK [RET_STR], DSC);
		    END;

		[R_JUSTIFY_MASK] :

		    !+
		    ! Right justify the string.
		    ! Use concatenate to prefix the right number of spaces to the
		    ! front.  If overflow occurs, then left justify the string
		    ! and truncate on the right.
		    !-

		    BEGIN

		    LOCAL
			LENGTH;			! Length of the element to format

		    LENGTH = .(.PARAM_BLK [ELEM])<0, 16>;

		    IF .LENGTH GEQ .PARAM_BLK [CHARACTER]
		    THEN
			BEGIN

			!+
			! String overflow
			!-

			STR$COPY_DX_R8 (DSC, .PARAM_BLK [ELEM]);
			STR$CONCAT (.PARAM_BLK [RET_STR], .PARAM_BLK [RET_STR], DSC);
			END
		    ELSE
			BEGIN

			!+
			! The string will fit; do an RSET.
			!-

			BAS$RSET (DSC, .PARAM_BLK [ELEM]);
			STR$CONCAT (.PARAM_BLK [RET_STR], .PARAM_BLK [RET_STR], DSC);
			END;

		    END;

		[C_JUSTIFY_MASK] :
		    BEGIN

		    !+
		    ! This is a combination of concatenating spaces on the front and
		    ! the end if necessary.
		    ! If overflow occurs, left justify the string and truncate on the
		    ! right.
		    !-

		    LOCAL
			LENGTH;			! Length of the element to format

		    LENGTH = .(.PARAM_BLK [ELEM])<0, 16>;

		    IF .LENGTH GEQ .PARAM_BLK [CHARACTER]
		    THEN
			BEGIN

			!+
			! String overflow
			!-

			STR$COPY_DX_R8 (DSC, .PARAM_BLK [ELEM]);
			STR$CONCAT (.PARAM_BLK [RET_STR], .PARAM_BLK [RET_STR], DSC);
			END
		    ELSE
			BEGIN

			!+
			! The string will fit; do an RSET into the left part followed by a copy
			! into the rest of the string
			!-

			LOCAL
			    T_LENGTH,		! Temp length for STR$GET1
			    T_DSC : BLOCK [8, BYTE];	! Temp descriptor

			T_LENGTH = .PARAM_BLK [CHARACTER] - ((.PARAM_BLK [CHARACTER] + 1) - .LENGTH)/2;
			T_DSC [DSC$W_LENGTH] = 0;
			T_DSC [DSC$B_CLASS] = DSC$K_CLASS_D;
			T_DSC [DSC$A_POINTER] = 0;
			STR$GET1_DX (T_LENGTH, T_DSC);
			T_DSC [DSC$B_CLASS] = DSC$K_CLASS_S;
			BAS$RSET (T_DSC, .PARAM_BLK [ELEM]);
			STR$COPY_DX_R8 (DSC, T_DSC);
			STR$CONCAT (.PARAM_BLK [RET_STR], .PARAM_BLK [RET_STR], DSC);
			T_DSC [DSC$B_CLASS] = DSC$K_CLASS_D;
			STR$FREE1_DX (T_DSC);
			END;

		    END;

		[EXTEND_MASK] :
		    BEGIN

		    !+
		    ! Extended string
		    ! Copy the text into the destination string and pad with spaces if
		    ! there is still room at the end.
		    !-

		    LOCAL
			LENGTH;			! Length of the element to format

		    LENGTH = .(.PARAM_BLK [ELEM])<0, 16>;

		    IF .LENGTH GEQ .PARAM_BLK [CHARACTER]
		    THEN

		    !+
		    ! String overflow
		    !-

			STR$CONCAT (.PARAM_BLK [RET_STR], .PARAM_BLK [RET_STR], .PARAM_BLK [ELEM])
		    ELSE
			BEGIN

			!+
			! The string will fit; do a copy.
			!-

			STR$COPY_DX_R8 (DSC, .PARAM_BLK [ELEM]);
			STR$CONCAT (.PARAM_BLK [RET_STR], .PARAM_BLK [RET_STR], DSC);
			END;

		    END;

		[OTHERWISE] :

		    !+
		    ! Error - format is for numeric element
		    !-

		    BAS$$STOP (BAS$K_PRIUSIFOR);
		TES;

	    DSC [DSC$B_CLASS] = DSC$K_CLASS_D;
	    END;

	[INRANGE, OUTRANGE] :

	    !+
	    ! Unsupported data types
	    !-

	    LIB$STOP (OTS$_FATINTERR);
	TES;

!+
! Return the temporary string allocated.
!-
    STR$FREE1_DX (DSC);
    RETURN 1;
    END;				! End of routine OUTPUT_ARG

%SBTTL 'End of module'
END					! End of module BASFORINT.B32
ELUDOM
