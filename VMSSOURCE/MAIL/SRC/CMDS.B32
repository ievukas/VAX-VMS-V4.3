MODULE MAIL$CMDS( %TITLE 'VAX/VMS PERSONAL MAIL UTILITY COMMANDS'
		IDENT = 'V04-000' ) =
BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY:	VAX/VMS MAIL UTILITY
!
! ABSTRACT:	Interactive command processing.
!
! ENVIRONMENT:	NATIVE/USER MODE
!
! AUTHOR: Benn Schreiber, CREATION DATE: 22-Dec-1982
!
! MODIFIED BY:
!
!
!	V03-015	ROP0028		Robert Posniak		23-JUL-1984
!		Make sure do not point past the end of the
!		current folder with the DELETE command.  Check
!		and report error status after deleting message.
!
!	V03-014	BLS0272		Benn Schreiber		18-FEB-1984
!		Disable ctrl/c handler around help. Use LIB$FIND_IMAGE_SYMBOL
!		rather than UTIL$ version.
!
!	V03-013	BLS0263		Benn Schreiber		22-Jan-1984
!		Don't allow SPAWN if captive user.  Implement COMPRESS
!		command to convert mail file.
!
!	V03-012	BLS0255		Benn Schreiber		28-Dec-1983
!		Convert byte flags to a flags longword.  /NEW implies
!		the default mail file.  Make /EDIT work on sequential
!		files.  Make first, last, search work on sequential
!		files.  Spawn and attach do a purgws.
!
!	V03-011	BLS0246		Benn Schreiber		28-Nov-1983
!		Add defaults of 'TODAY' to /BEFORE and /SINCE.  Add
!		/EDIT qualifier to BACK, CURRENT, FIRST, NEXT, LAST,
!		and READ commands.  Add /CONFIRM to MOVE, FILE, COPY.
!
!	V03-010	BLS0235		Benn Schreiber		23-Aug-1983
!		Fix defaulting of folder selection if file already open.
!		Clear garbage bits in return status passed as bit flag.
!
!	V03-009	BLS0227		Benn Schreiber		29-Jun-1983
!		Add routine to clear dir_flag and dir_mode.  Correct
!		method of deleting messages with MOVE,FILE commands.
!
!	V03-008	BLS0226		Benn Schreiber		27-Jun-1983
!		Make DIR/START=999 give a full screen listing
!
!	V03-007	BLS0225		Benn Schreiber		17-Jun-1983
!		Make SEARCH command open file and select if not already done.
!
!	V03-006	BLS0222		Benn Schreiber		15-May-1983
!		Disable CTRL/C ast around spawning/attaching to subprocess
!
!	V03-005	BLS0221		Benn Schreiber		 5-May-1983
!		Fix SPAWN/PROCESS=
!
!	V03-004	BLS0220		Benn Schreiber		30-Apr-1983
!		Interlock with PURGE, PURGE/RECLAIM to prevent extaneous
!		messages.
!
!	V03-003	BLS0217		Benn Schreiber		14-Apr-1983
!		Add SPAWN, ATTACH
!
!	V03-002	BLS0214		Benn Schreiber		27-Mar-1983
!		Add DELETE/ALL command.  Cause FIRST and LAST commands to
!		open mail file and read default messages if not done yet.
!
!--

!
! TABLE OF CONTENTS:
!
!
!
! INCLUDE FILES:
!
	LIBRARY 'SYS$LIBRARY:STARLET';
	REQUIRE 'SRC$:MAILREQ';
	LIBRARY	'LIB$:MAILDEF';

EXTERNAL ROUTINE
	CLI$GET_VALUE: ADDRESSING_MODE(GENERAL),! Get value for qualifier
	CLI$PRESENT: ADDRESSING_MODE(GENERAL),	! Test if qualifier present
	LIB$ATTACH,				! Attach to a subprocess
	LIB$CVT_DTB: ADDRESSING_MODE(GENERAL),	! Convert decimal to binary
	LIB$CVT_TIME: ADDRESSING_MODE(GENERAL),	! Convert date/time
	LIB$SPAWN,				! Spawn a subprocess
	MAIL$CLOSE_FILE,			! Close open msg file
	MAIL$CMD_ERASE,				! Erase the screen
	MAIL$CMD_SHOW_NEW,			! Show new message count
	MAIL$COMPRESS,				! Compress a mail file
	MAIL$COPY_MSGS,				! Copy messages to a file
	MAIL$DELETE_I_MSG,			! Delete current ISAM message
	MAIL$DELETE_MSG,			! Delete current message
	MAIL$DIRECTORY,				! Display summary of messages
	MAIL$DISABLE_CTRLC,			! Disable CTRL/C trap
	MAIL$ENABLE_CTRLC,			! Enable CTRL/C trap
	MAIL$EDIT,				! Edit a message
	MAIL$EDIT_READ_MSG,			! Edit/read a message
	MAIL$DIR_FOLDER,			! Display listing of folders
	MAIL$EMPTY_WASTEBASKET,			! Delete msgs from wastebasket
	MAIL$FILE_I_MSG,			! File current message
	MAIL$FIND_I_MSG,			! Find ISAM message
	MAIL$FIND_MSG,				! Find a message
	MAIL$GET_INPUT,				! Get from sys$input
	MAIL$GET_MSG,				! Get record of current message
	MAIL$GET_I_MSG,				! Get record from ISAM message
	MAIL$INFO_I_MSG,			! Get ISAM message info
	MAIL$INFO_MSG,				! Get message information
	MAIL$INFO_FOLDER,			! Get folder info
	MAIL$OPEN_FILE,				! Open a mail file
	MAIL$PRINT,				! Print a message
	MAIL$PUT_OUTPUT,			! Put to sys$output
	MAIL$READ,				! Display a message
	MAIL$RECLAIM,				! Convert/reclaim isam file
	MAIL$REMOVE_I_MSG,			! Remove message from current
	MAIL$REWIND_MSG,			! Rewind current message
	MAIL$REWIND_I_MSG,			! Rewind ISAM current message
	MAIL$SELECT_MSGS,			! Select ISAM messages
	MAIL$STRIP_QUOTES,			! Strip quote marks from string
	MAIL$TEST_SUBJ,				! Test if SUBJ: line present
	MAIL$UPCASE,				! Convert string to upper case
	MAIL$UPCASE_Q,				! Ditto, but not inside quotes
	OTS$SCOPY_DXDX:ADDRESSING_MODE(GENERAL),! String copy desc to desc
	STR$COPY_DX: ADDRESSING_MODE(GENERAL),	! String copy
	STR$FREE1_DX: ADDRESSING_MODE(GENERAL),	! Deallocate dynamic string
	LIB$FIND_IMAGE_SYMBOL;			! Load image, find symbol value

EXTERNAL
	MAIL$GL_FLAGS : $BBLOCK,		! Control flags
	MAIL$B_MSGTRAN : BYTE,			! ISAM getmsg transition
	MAIL$L_OUTLINES,			! Number of lines on page
	MAIL$L_SYSMAIBUF: REF $BBLOCK,		! Pointer to VMSMAIL.DAT buffer
	MAIL$L_MSG_NUM:	LONG,			! Current message number
	MAIL$L_MSG_RADR:LONG,			! Current message record addr
	MAIL$W_MSG_RSIZ:WORD,			! Current message record size
	MAIL$L_MSGBUFSIZ,			! Size of seq. file msg buf
	MAIL$L_MSG_STS:	LONG,			! Current message status
	MAIL$Q_CURFOLDER : $BBLOCK,		! Current folder name
	MAIL$Q_WASTEDESC : $BBLOCK,		! Wastebasket folder name
	MAIL$Q_MSGNAME:	$BBLOCK,		! message file name
	MAIL$Q_MSGTYPE: $BBLOCK,		! Default message file type
	MAIL$Q_RD_DESC : $BBLOCK,		! Descriptor of current file
	MAIL$L_NMSG,				! Number of ISAM messsages
	MAIL$L_CURMSG : REF $BBLOCK,		! Pointer to current msg block
	MAIL$L_MSGTBL : REF VECTOR[,LONG];	! Pointer to message table

GLOBAL
	MAIL$A_OUTPUT_HELP;			! Address of LBR$OUTPUT_HELP

OWN
	SEARCH_STRING_BUFF: $BBLOCK[128],	! Current search string buffer
	DIR_FLAG:	BYTE,			! DIRECTORY last command flag
						!  and there is more DIR to go
	DIRFULL_FLAG: BYTE,			! DIR/FULL last command
	DIR_MODE: BYTE,				! 1=DIRECTORY, 0=READ
	SELECT_DATA : VECTOR[5,LONG],		! Used to parse selection stuff
	SELECT_FROM : DYN_DESC_DECL,		!  ditto
	SELECT_NEW : LONG,			!  ditto
	SELECT_REPLIED : LONG,			!  ditto
	DYN_DESC : DYN_DESC_DECL,		! Dynamic descriptors
	DYN_DESC_2 : DYN_DESC_DECL,
	DYN_DESC_3 : DYN_DESC_DECL,
	COMMAND_DESC : DYN_DESC_DECL,
	SEARCH_STRING:	$BBLOCK[8]		! Current search string desc
			PRESET([DSC$A_POINTER] = SEARCH_STRING_BUFF);

BIND
    SELECT_FLAGS = SELECT_DATA[0] : $BBLOCK;	! Message selection flags

!
! Declare static strings for qualifier names
!
SD(
    'ALL',
    'BEFORE',
    'CONFIRM',
    'COPIES',
    'DELNUM',
    'HEADER',
    'INPUT',
    'FDL',
    'FILE',
    'FOLDER_NAME',
    'FOLDER',
    'FROM',
    'FULL',
    'LOG',
    'LOGICAL_NAMES',
    'NOTIFY',
    'OUTPUT',
    'P1',
    'PARENT',
    'PRINT',
    'PROCESS',
    'QUEUE',
    'RECLAIM',
    'STATISTICS',
    'SYMBOLS',
    'TODAY',
    'REPLF',
    'EDIT',
    'HELPKEYS',
    'NEW',
    'READ1',
    'READ2',
    'SEARCH1',
    'SEND1',
    'SINCE',
    'START',
    'SUBJECT',
    'NEXT',
    'SETF1',
    'SETN1',
    'WAIT',
    'TOLIST');

GLOBAL BIND
    MAIL$SD_SETF1 = SD_SETF1,		!For other modules
    MAIL$SD_SETN1 = SD_SETN1;
!
! Define shared messages as local
!
$SHR_MSGDEF(MAIL,126,LOCAL,
	(BADVALUE,ERROR),
	(CREATED,SUCCESS),
	(INVQUAVAL,ERROR));

GLOBAL ROUTINE MAIL$OPEN_IF =
!++
! FUNCTIONAL DESCRIPTION:
!
! Open the default mail file if no mail file is open
!
! INPUTS:
!
!	None
!
! IMPLICIT INPUTS:
!
!	MAIF_V_FILOPN = 0 if no file open, 1 if file open
!
!--
BEGIN

LOCAL
    DESC : VECTOR[2,LONG];

IF .MAIL$GL_FLAGS[MAIF_V_FILOPN]
    THEN RETURN TRUE;

DESC[0] = DESC[1] = 0;
RETURN MAIL$OPEN_FILE(DESC)
END;

ROUTINE INIT_SELECT_DATA : NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Initialize the message selection data vector
!
! INPUTS:
!
!	None
!
! OUTPUTS:
!
!	SELECT_DATA vector initialized for parsing
!--
BEGIN
SELECT_DATA[0] = 0;
SELECT_DATA[1] = -1;
SELECT_DATA[2] = -1;
SELECT_DATA[3] = 0;
SELECT_DATA[4] = 1;
RETURN
END;

ROUTINE PARSE_SELECTION_QUALS =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Parse the message selection qualifiers and fill in SELECT_DATA
!	vector.
!
! INPUTS:
!
!	SELECT_DATA vector initialized for parsing
!
! OUTPUTS:
!
!	SELECT_DATA vector filled in according to selection criteria in command
!--
BEGIN

BIND
    QUAL_FLAGS = SELECT_DATA[0] : $BBLOCK;
!
! Parse the /BEFORE qualifier
!
QUAL_FLAGS[QUAL_BEFORE] = CLI$PRESENT(SD_BEFORE);
IF .QUAL_FLAGS[QUAL_BEFORE]
THEN BEGIN
    CLI$GET_VALUE(SD_BEFORE,DYN_DESC);
    IF .DYN_DESC[DSC$W_LENGTH] EQL 0
	THEN STR$COPY_DX(DYN_DESC,SD_TODAY);
    IF_ERR(LIB$CVT_TIME(DYN_DESC,SELECT_DATA[1]);,
	    RETURN SIGNAL(MAIL$_INVQUAVAL,2,DYN_DESC,SD_BEFORE));
    IF .SELECT_DATA[2] EQL 0
	OR (.SELECT_DATA[2] AND %X'FFF80000') EQL 0
	THEN RETURN SIGNAL(MAIL$_INVQUAVAL,2,DYN_DESC,SD_BEFORE);
    END;
!
! Parse the /SINCE qualifier
!
QUAL_FLAGS[QUAL_SINCE] = CLI$PRESENT(SD_SINCE);
IF .QUAL_FLAGS[QUAL_SINCE]
THEN BEGIN
    CLI$GET_VALUE(SD_SINCE,DYN_DESC);
    IF .DYN_DESC[DSC$W_LENGTH] EQL 0
	THEN STR$COPY_DX(DYN_DESC,SD_TODAY);
    IF_ERR(LIB$CVT_TIME(DYN_DESC,SELECT_DATA[3]);,
	    RETURN SIGNAL(MAIL$_INVQUAVAL,2,DYN_DESC,SD_SINCE));
    IF .SELECT_DATA[4] EQL 0
	OR (.SELECT_DATA[4] AND %X'FFF80000') EQL 0
	THEN RETURN SIGNAL(MAIL$_INVQUAVAL,2,DYN_DESC,SD_SINCE);
    END;
!QUAL_FLAGS[QUAL_FROM] = CLI$GET_VALUE(SD_FROM,SELECT_FROM);
QUAL_FLAGS[QUAL_NEW] = CLI$PRESENT(SD_NEW);
!  QUAL_REPLIED

RETURN TRUE
END;

ROUTINE READ_MESSAGE (EDIT_FLAG) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Begin reading the next message
!
! INPUTS:
!
!	EDIT_FLAG = TRUE if to invoke editor, false if screen-at-a-time read
!	MAIL$REWIND_I_MSG or MAIL$REWIND_MSG has been called as appropriate
!
! OUTPUTS:
!
!	Calls MAIL$READ to read and display text of message
!--
BEGIN

IF .EDIT_FLAG
THEN BEGIN
    RETURN MAIL$EDIT_READ_MSG()
    END
ELSE BEGIN
    MAIL$B_MSGTRAN = MMB_C_FROMXDT;		!Don't put date/time on from line
    RETURN MAIL$READ()
    END;
END;

ROUTINE CHECK_FOLDER (FOLDER_DESC) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Check the folder name, signal any errors.
!
!--
BEGIN

MAP
    FOLDER_DESC : REF $BBLOCK;

IF .FOLDER_DESC[DSC$W_LENGTH] GTRU MFR_S_FILEKEY
    THEN RETURN SIGNAL(MAIL$_BADVALUE,1,.FOLDER_DESC)
    ELSE RETURN TRUE
END;

ROUTINE SELECT_DEFAULT =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Open the mail file (if not open) and select the default messages
!--
BEGIN

LOCAL
    FOLDER_DESC : VECTOR[2,LONG];

FOLDER_DESC[0] = FOLDER_DESC[1] = 0;
IF NOT .MAIL$GL_FLAGS[MAIF_V_FILOPN]
    OR .MAIL$Q_CURFOLDER[DSC$W_LENGTH] EQL 0
THEN BEGIN
    IF_ERR(MAIL$OPEN_IF();,
		RETURN .STATUS);
    IF NOT .MAIL$GL_FLAGS[MAIF_V_ISAM]	!All done if not isam file
	THEN RETURN TRUE;
    INIT_SELECT_DATA();
    IF_ERR(MAIL$SELECT_MSGS(FOLDER_DESC,SELECT_DATA);,
		RETURN .STATUS);
    END;

RETURN TRUE
END;

GLOBAL ROUTINE MAIL$CLR_DIR_FLAG : NOVALUE =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine clears the flags that determine whether a directory
!	command was in progress.
!
!--
BEGIN

DIR_FLAG = 0;
DIR_MODE = 0;
RETURN;
END;

GLOBAL ROUTINE MAIL$CMD_READ (PARSE_FLAG) = 
!++
! FUNCTIONAL DESCRIPTION:
!
!	This is the READ command action routine and is called to display
!	the rest of the current message text, or if there is no more,
!	the text of the next message, or if a specific message is specified,
!	the text of the specified message.
!
! INPUTS:
!
!	PARSE_FLAG	argument present if not called from CLI$DCL_PARSE
!
! OUTPUTS:
!
!	DIR_FLAG = Zero.
!
!	Specified message text is displayed on SYS$OUTPUT.
!--
BEGIN

BUILTIN
	ACTUALCOUNT;				! Number of actual args passed

LOCAL
	FOLDER_DESC : $BBLOCK[DSC$C_S_BLN],
	NEW_FILE,
	EDIT_FLAG,
	MSG_NUM;

MAIL$CLR_DIR_FLAG();
MSG_NUM = 0;
EDIT_FLAG = 0;
INIT_SDESC(FOLDER_DESC);
INIT_SELECT_DATA();
IF ACTUALCOUNT() EQL 0		!If called from CLIDISPATCH
THEN BEGIN
    IF CLI$GET_VALUE(SD_READ1,DYN_DESC_3)	!If first parameter present
    THEN BEGIN
	!
	! See if it's a number.  If not, it must be the foldername
	!
	IF NOT LIB$CVT_DTB(.DYN_DESC_3[DSC$W_LENGTH],
			.DYN_DESC_3[DSC$A_POINTER],MSG_NUM)
	THEN BEGIN
	    FOLDER_DESC[DSC$W_LENGTH] = .DYN_DESC_3[DSC$W_LENGTH];
	    FOLDER_DESC[DSC$A_POINTER] = .DYN_DESC_3[DSC$A_POINTER];
	    END;
	END;
    !
    ! If 2nd parameter present it MUST be the message number
    !
    IF CLI$GET_VALUE(SD_READ2,DYN_DESC_2)
    THEN BEGIN
	IF NOT LIB$CVT_DTB(.DYN_DESC_2[DSC$W_LENGTH],
				.DYN_DESC_2[DSC$A_POINTER],MSG_NUM)
	THEN RETURN SIGNAL(MAIL$_BADVALUE,1,DYN_DESC_2);
	END;
    !
    ! Parse message selection qualifiers
    !
    IF_ERR(CHECK_FOLDER(FOLDER_DESC);,
	RETURN .STATUS);
    IF_ERR(PARSE_SELECTION_QUALS();,
	RETURN .STATUS);
    EDIT_FLAG = CLI$PRESENT(SD_EDIT);
    IF .SELECT_FLAGS[QUAL_NEW]
	AND NOT .MAIL$GL_FLAGS[MAIF_V_DFMSG]
	THEN MAIL$CLOSE_FILE();
    END;

!
! If there are no more records in the current message or a specific message
! is desired, find the next or specific message, respectively.
!
IF (NEW_FILE = (NOT .MAIL$GL_FLAGS[MAIF_V_FILOPN]
	OR (.FOLDER_DESC[DSC$W_LENGTH] NEQ 0)
	OR (.SELECT_DATA[0] NEQ 0)))
THEN IF_ERR(MAIL$OPEN_IF();,
		RETURN .STATUS);
IF .MAIL$GL_FLAGS[MAIF_V_ISAM]
THEN BEGIN
    IF .NEW_FILE
	OR .MAIL$L_NMSG EQL 0
        THEN (IF_ERR(MAIL$SELECT_MSGS(FOLDER_DESC,SELECT_DATA);,
			RETURN .STATUS);
	    MAIL$GL_FLAGS[MAIF_V_RDHOLD] = 0);
    IF .MAIL$L_MSG_STS EQL 0
	OR .MAIL$L_MSG_STS EQL MAIL$_NOTREADIN
	OR .MSG_NUM NEQ 0
    THEN BEGIN
	IF MAIL$FIND_I_MSG(.MSG_NUM,(IF .MSG_NUM NEQ 0
					THEN 0
					ELSE 1))
	    AND MAIL$REWIND_I_MSG()
	THEN
		READ_MESSAGE(.EDIT_FLAG)
	ELSE
		SIGNAL(.MAIL$L_MSG_STS);

	RETURN TRUE
	END;
    !
    ! If there aren't any more messages in the message file, start over with
    ! the first message in the file.
    !
    IF .MAIL$L_MSG_STS EQL MAIL$_NOMOREMSG
    THEN BEGIN
	IF MAIL$FIND_I_MSG(1,1)
	    AND MAIL$REWIND_I_MSG()
	THEN
		READ_MESSAGE(.EDIT_FLAG);
	IF NOT .MAIL$L_MSG_STS
	    AND .MAIL$L_MSG_STS NEQ 0
	    THEN SIGNAL(.MAIL$L_MSG_STS);
	RETURN TRUE;
	END;
    END
ELSE BEGIN
    IF .SELECT_DATA[0] NEQ 0
	OR .FOLDER_DESC[DSC$W_LENGTH] NEQ 0
    THEN RETURN SIGNAL(MAIL$_NOTISAM);
    IF .MAIL$L_MSG_STS EQL 0
	OR .MAIL$L_MSG_STS EQL MAIL$_NOTREADIN
	OR .MSG_NUM NEQ 0
    THEN BEGIN
	IF MAIL$FIND_MSG(.MSG_NUM,.NEW_FILE)
	THEN
		READ_MESSAGE(.EDIT_FLAG)
	ELSE
		IF .MAIL$L_MSG_STS EQL MAIL$_NOMOREMSG
		THEN
			SIGNAL(MAIL$_NOMOREMSG);
	RETURN TRUE;
	END;
    !
    ! If there aren't any more messages in the message file, start over with
    ! the first message in the file.
    !
    IF .MAIL$L_MSG_STS EQL MAIL$_NOMOREMSG
    THEN BEGIN
	IF MAIL$FIND_MSG(1)
	THEN
		READ_MESSAGE(.EDIT_FLAG);
	RETURN TRUE;
	END;
    END;
!
! If there are more records in the current message, display them.  Otherwise
! there is an error.
!
IF .MAIL$L_MSG_STS
THEN
	MAIL$READ()
ELSE
	SIGNAL(.MAIL$L_MSG_STS);
RETURN TRUE
END;

GLOBAL ROUTINE MAIL$CMD_BACK =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This is the BACK command action routine and is called to display
!	the previous message.
!
! INPUTS:
!
!	Current message context.
!
! OUTPUTS:
!
!	The message before the current message is displayed on SYS$OUTPUT.
!--
BEGIN
LOCAL
    EDIT_FLAG,
    MSGNUM;

IF .DIR_MODE
    AND .MAIL$GL_FLAGS[MAIF_V_ISAM]
THEN BEGIN
    MSGNUM = MAX(.MAIL$L_MSG_NUM-2*(.MAIL$L_OUTLINES-7),1);
    IF MAIL$FIND_I_MSG(.MSGNUM,-1,1)
	THEN MAIL$DIRECTORY(.DIRFULL_FLAG);
    DIR_FLAG = 0;
    IF .MAIL$L_MSG_STS
	THEN DIR_FLAG = 1;
    RETURN TRUE;
    END;
!
! If positioned at the first message, then signal no more messages.
!
IF (.MAIL$L_MSG_NUM - 1) LEQ 0
THEN BEGIN
    IF .MAIL$GL_FLAGS[MAIF_V_ISAM]
    THEN BEGIN
	IF .MAIL$L_NMSG EQL 0
	    THEN MAIL$L_MSG_STS = MAIL$_NOMSGS
	    ELSE MAIL$L_MSG_STS = MAIL$_NOMOREMSG;
	SIGNAL(.MAIL$L_MSG_STS);
	END
	ELSE SIGNAL(MAIL$_NOMOREMSG);
	RETURN TRUE;
	END;
EDIT_FLAG = CLI$PRESENT(SD_EDIT);
!
! If positioned past the last message, then display the last message.
!
IF .MAIL$L_MSG_STS EQL MAIL$_NOMOREMSG
THEN	BEGIN
	IF .MAIL$GL_FLAGS[MAIF_V_ISAM]
	THEN BEGIN
	    MAIL$FIND_I_MSG(.MAIL$L_NMSG,-1);
	    IF NOT .MAIL$L_MSG_STS
		THEN (SIGNAL(.MAIL$L_MSG_STS); RETURN TRUE);
	    MAIL$REWIND_I_MSG();
	    END
	ELSE MAIL$FIND_MSG(.MAIL$L_MSG_NUM);
	READ_MESSAGE(.EDIT_FLAG);
	RETURN TRUE;
	END;
!
! Otherwise, just display the previous message.
!
IF .MAIL$GL_FLAGS[MAIF_V_ISAM]
THEN BEGIN
    IF MAIL$FIND_I_MSG(.MAIL$L_MSG_NUM - 1,-1)
	THEN MAIL$REWIND_I_MSG()
    ELSE IF NOT .MAIL$L_MSG_STS
	THEN RETURN SIGNAL(.MAIL$L_MSG_STS);
    END
ELSE MAIL$FIND_MSG(.MAIL$L_MSG_NUM-1);
READ_MESSAGE(.EDIT_FLAG);

RETURN TRUE

END;

GLOBAL ROUTINE MAIL$CMD_CONTINUE =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This is the <RETURN> command action routine and is called to continue
!	the last display type command.  If the last command was a READ command,
!	then the READ command action routine will be called.  If the last
!	command was a DIRECTORY command and there are more messages to be
!	displayed, then the DIRECTORY routine will be called.
!
! INPUTS:
!
!	DIR_FLAG = 1 if last command was a DIRECTORY command and there are
!		    more messages to be displayed.
!
! OUTPUTS:
!
!	Appropriate action routine selected.
!--
BEGIN
IF .DIR_FLAG						! If more to display
THEN	BEGIN
	MAIL$DIRECTORY(.DIRFULL_FLAG);
	IF NOT .MAIL$L_MSG_STS				! If no more messages
	THEN
		DIR_FLAG = 0;				! then clear flag
	END
ELSE
	MAIL$CMD_READ(1);
RETURN TRUE
END;


ROUTINE TELL_CREATED(DESC) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Signal that an ISAM file was created for the copy command
!
!--
SIGNAL(MAIL$_CREATED,1,.DESC);

GLOBAL ROUTINE MAIL$CMD_COPY =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This is the COPY command, which takes a copy of the current message
!	and copies it to the specified folder/file
!
!--
BEGIN
LOCAL
    COPY_FLAGS : $BBLOCK[4];

CLI$GET_VALUE(SD_FOLDER_NAME,DYN_DESC);
IF_ERR(CHECK_FOLDER(DYN_DESC);,
	RETURN .STATUS);

COPY_FLAGS = 0;
COPY_FLAGS[MCR_V_ALL] = CLI$PRESENT(SD_ALL) AND 1;

CLI$GET_VALUE(SD_FILE,DYN_DESC_2);

IF NOT .COPY_FLAGS[MCR_V_ALL]
    AND (IF .MAIL$GL_FLAGS[MAIF_V_ISAM]
	    THEN .MAIL$L_CURMSG EQL 0
	    ELSE NOT MAIL$REWIND_MSG())
    THEN RETURN SIGNAL(MAIL$_NOTREADIN);

IF CLI$PRESENT(SD_CONFIRM)
    THEN COPY_FLAGS[MCR_V_CONFNEW] = 1;

MAIL$COPY_MSGS(DYN_DESC_2,DYN_DESC,.COPY_FLAGS,TELL_CREATED);
RETURN TRUE
END;

GLOBAL ROUTINE MAIL$CMD_DELETE =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This is the DELETE command action routine and is called to delete
!	the current message.
!
! INPUTS:
!
!	Current message context.
!
! OUTPUTS:
!
!	The current message is deleted from the file it is in.
!--
BEGIN
LOCAL
	DELMSGNUM,
	SAVE_MSGNUM,
	ALL_FLAG,
	STATUS;					! Routine status

ALL_FLAG = CLI$PRESENT(SD_ALL);
IF .MAIL$GL_FLAGS[MAIF_V_ISAM]
THEN BEGIN
    IF CLI$GET_VALUE(SD_DELNUM,DYN_DESC)
    THEN BEGIN
	IF_ERR(LIB$CVT_DTB(.DYN_DESC[DSC$W_LENGTH],.DYN_DESC[DSC$A_POINTER],
				DELMSGNUM);,
		RETURN SIGNAL(MAIL$_BADVALUE,1,DYN_DESC));
	IF .DELMSGNUM GTRU .MAIL$L_NMSG
	    THEN RETURN SIGNAL(MAIL$_NOMSGS);
	IF .MAIL$L_MSGTBL[.DELMSGNUM-1] EQL 0
	    THEN RETURN SIGNAL(MAIL$_DELMSG);
!
!	Make sure we don't point past the end of the folder
!
	IF .MAIL$L_MSG_NUM GTRU .MAIL$L_NMSG THEN SAVE_MSGNUM = 0
	ELSE
	   SAVE_MSGNUM = .MAIL$L_MSG_NUM;
	MAIL$L_MSG_NUM = .DELMSGNUM;
	MAIL$L_CURMSG = .MAIL$L_MSGTBL[.DELMSGNUM-1];
	STATUS=MAIL$DELETE_I_MSG();
    	IF .STATUS EQL MAIL$_NOTREADIN
	    OR .STATUS EQL MAIL$_DELWASTE
	    THEN SIGNAL(.STATUS);
	MAIL$L_MSG_NUM = .SAVE_MSGNUM;
	IF .SAVE_MSGNUM NEQ 0
	 THEN MAIL$L_CURMSG = .MAIL$L_MSGTBL[.SAVE_MSGNUM-1];
	RETURN TRUE
	END;
    !
    ! Delete all the messages if /ALL
    !
    IF .ALL_FLAG
    THEN BEGIN
	IF CH$EQL(.MAIL$Q_CURFOLDER[DSC$W_LENGTH],
		.MAIL$Q_CURFOLDER[DSC$A_POINTER],
		.MAIL$Q_WASTEDESC[DSC$W_LENGTH],
		.MAIL$Q_WASTEDESC[DSC$A_POINTER],0)
	    THEN RETURN SIGNAL(MAIL$_DELWASTE);
	SAVE_MSGNUM = .MAIL$L_MSG_NUM;
	IF .MAIL$L_NMSG GTRU 0
	THEN INCRU I FROM 1 TO .MAIL$L_NMSG
	DO BEGIN
	    MAIL$L_CURMSG = .MAIL$L_MSGTBL[.I-1];
	    IF .MAIL$L_CURMSG NEQ 0
	    THEN BEGIN
		MAIL$L_MSG_NUM = .I;
		MAIL$DELETE_I_MSG();
		END;
	    END;
	MAIL$L_MSG_NUM = .SAVE_MSGNUM;
	IF .SAVE_MSGNUM NEQ 0
	    THEN MAIL$L_CURMSG = .MAIL$L_MSGTBL[.SAVE_MSGNUM-1];
	RETURN TRUE
	END;
    !
    ! Just delete a single message
    !
    STATUS = MAIL$DELETE_I_MSG();
    IF .STATUS EQL MAIL$_NOTREADIN
	OR .STATUS EQL MAIL$_DELWASTE
	THEN SIGNAL(.STATUS)
	ELSE IF .STATUS THEN MAIL$CMD_ERASE();
    END
ELSE BEGIN
    IF .ALL_FLAG
	THEN RETURN SIGNAL(MAIL$_NOTISAM);
    STATUS = MAIL$DELETE_MSG();			! Delete the message
    IF NOT .STATUS
    THEN
	SIGNAL(.STATUS)				! Signal the failure
    ELSE
	MAIL$CMD_ERASE();			! Erase the screen
    END;
RETURN TRUE
END;

GLOBAL ROUTINE MAIL$CMD_DIRECTORY =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This is the DIRECTORY command action routine and is called to
!	display a summary of all the messages in the current file or a
!	specified file.
!
! INPUTS:
!
! OUTPUTS:
!
!	DIR_FLAG = 1 if more messages to display.
!
!	A summary of each message is displayed on SYS$OUTPUT.
!--
BEGIN

LOCAL
    FOLDER_DESC : $BBLOCK[DSC$C_S_BLN],
    START_MSGNUM,
    START_FLAG,
    STATUS,
    NEW_FILE;

DIR_FLAG = 0;
DIRFULL_FLAG = 0;
INIT_SDESC(FOLDER_DESC);
IF CLI$GET_VALUE(SD_FOLDER_NAME,DYN_DESC_3)
THEN BEGIN
    FOLDER_DESC[DSC$W_LENGTH] = .DYN_DESC_3[DSC$W_LENGTH];
    FOLDER_DESC[DSC$A_POINTER] = .DYN_DESC_3[DSC$A_POINTER];
    IF_ERR(CHECK_FOLDER(FOLDER_DESC);,
		RETURN .STATUS);
    END;
INIT_SELECT_DATA();
IF_ERR(PARSE_SELECTION_QUALS();,
	RETURN .STATUS);

IF .SELECT_FLAGS[QUAL_NEW]
    AND NOT .MAIL$GL_FLAGS[MAIF_V_DFMSG]
    THEN MAIL$CLOSE_FILE();

START_FLAG = CLI$GET_VALUE(SD_START,DYN_DESC_2);
DIRFULL_FLAG = CLI$PRESENT(SD_FULL);
IF CLI$PRESENT(SD_FOLDER)
THEN BEGIN
    IF_ERR(MAIL$OPEN_IF();,
		RETURN .STATUS);
    IF NOT .MAIL$GL_FLAGS[MAIF_V_ISAM]
	THEN RETURN SIGNAL(MAIL$_NOTISAM)
	ELSE RETURN MAIL$DIR_FOLDER(DYN_DESC_2);
    END;

IF .START_FLAG
THEN BEGIN
    IF_ERR(LIB$CVT_DTB(.DYN_DESC_2[DSC$W_LENGTH],.DYN_DESC_2[DSC$A_POINTER],
			START_MSGNUM);,
		RETURN SIGNAL(MAIL$_BADVALUE,1,DYN_DESC_2));
    IF .START_MSGNUM EQL 0
	THEN START_MSGNUM = 1;
    END
ELSE START_MSGNUM = 0;

IF (NEW_FILE = NOT .MAIL$GL_FLAGS[MAIF_V_FILOPN]
		OR (.FOLDER_DESC[DSC$W_LENGTH] NEQ 0)
		OR (.SELECT_DATA[0] NEQ 0))
THEN IF_ERR(MAIL$OPEN_IF();,
		RETURN .STATUS);
IF .MAIL$GL_FLAGS[MAIF_V_ISAM]
THEN BEGIN
    IF .NEW_FILE
	OR .MAIL$L_NMSG EQL 0
	THEN IF_ERR(MAIL$SELECT_MSGS(FOLDER_DESC,SELECT_DATA);,
		RETURN .STATUS);
    IF .MAIL$L_NMSG EQL 0
	THEN RETURN SIGNAL(MAIL$_NOMSGS);
    IF .START_MSGNUM EQL 0
	THEN START_MSGNUM = (IF .NEW_FILE
			    OR (.MAIL$L_MSG_NUM LEQ 1)
			THEN 1
			ELSE MAX(1,MIN(.MAIL$L_MSG_NUM,
					.MAIL$L_NMSG-.MAIL$L_OUTLINES+7+1)))
	ELSE START_MSGNUM = MAX(1,MIN(.START_MSGNUM,
					.MAIL$L_NMSG-.MAIL$L_OUTLINES+7+1));

    IF MAIL$FIND_I_MSG(.START_MSGNUM,1,1)
	THEN MAIL$DIRECTORY(.DIRFULL_FLAG);
    END
ELSE BEGIN
    IF .SELECT_DATA[0] NEQ 0
	OR .FOLDER_DESC[DSC$W_LENGTH] NEQ 0
	OR .START_FLAG OR .DIRFULL_FLAG
	THEN RETURN SIGNAL(MAIL$_NOTISAM);
    IF MAIL$FIND_MSG(1,.NEW_FILE)
    THEN
	MAIL$DIRECTORY(0);			! Display directory
    END;

DIR_MODE = 1;
IF .MAIL$L_MSG_STS				! If more to display,
THEN
	DIR_FLAG = 1;				! then set flag
RETURN TRUE
END;


GLOBAL ROUTINE MAIL$CMD_SELECT =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Select new messages, tell how many were selected.
!
!--
BEGIN
LOCAL
    FOLDER_DESC : $BBLOCK[DSC$C_S_BLN],
    NEW_FILE;

INIT_SDESC(FOLDER_DESC);
IF CLI$GET_VALUE(SD_FOLDER_NAME,DYN_DESC_3)
THEN BEGIN
    FOLDER_DESC[DSC$W_LENGTH] = .DYN_DESC_3[DSC$W_LENGTH];
    FOLDER_DESC[DSC$A_POINTER] = .DYN_DESC_3[DSC$A_POINTER];
    IF_ERR(CHECK_FOLDER(FOLDER_DESC);,
		RETURN .STATUS);
    END;
INIT_SELECT_DATA();
IF_ERR(PARSE_SELECTION_QUALS();,
	RETURN .STATUS);

IF .SELECT_FLAGS[QUAL_NEW]
    AND NOT .MAIL$GL_FLAGS[MAIF_V_DFMSG]
    THEN MAIL$CLOSE_FILE();

IF (NEW_FILE = NOT .MAIL$GL_FLAGS[MAIF_V_FILOPN]
		OR (.FOLDER_DESC[DSC$W_LENGTH] NEQ 0)
		OR (.SELECT_DATA[0] NEQ 0))
    OR .MAIL$L_NMSG EQL 0
THEN IF_ERR(MAIL$OPEN_IF();,
		RETURN .STATUS);
IF .MAIL$GL_FLAGS[MAIF_V_ISAM]
THEN BEGIN
    IF_ERR(MAIL$SELECT_MSGS(FOLDER_DESC,SELECT_DATA);,
		RETURN .STATUS);
    SIGNAL(MAIL$_SELECTED,1,.MAIL$L_NMSG);
    END
ELSE SIGNAL(MAIL$_NOTISAM);

RETURN TRUE
END;

GLOBAL ROUTINE MAIL$CMD_MOVE =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This is the MOVE command action routine and is called to move
!	the current message from one isam folder to another in the same file.
!
! INPUTS:
!
!	Current message context.
!
! OUTPUTS:
!
!	Current message is filed in the specified folder
!--
BEGIN

LOCAL
    STATUS,
    SAVE_MSGNUM,
    CONFIRM_FLAG,
    COPY_FLAGS : $BBLOCK[4];

COPY_FLAGS = 0;
IF NOT .MAIL$GL_FLAGS[MAIF_V_FILOPN]
    THEN RETURN SIGNAL(MAIL$_NOTREADIN);

IF NOT .MAIL$GL_FLAGS[MAIF_V_ISAM]
    THEN RETURN SIGNAL(MAIL$_NOTISAM);

IF_ERR(CLI$GET_VALUE(SD_FOLDER_NAME,DYN_DESC);,
	RETURN .STATUS);

CONFIRM_FLAG = CLI$PRESENT(SD_CONFIRM) AND 1;

IF_ERR(CHECK_FOLDER(DYN_DESC);,
	RETURN .STATUS);

COPY_FLAGS[MCR_V_ALL] = CLI$PRESENT(SD_ALL) AND 1;
IF NOT .COPY_FLAGS[MCR_V_ALL]
    AND .MAIL$L_CURMSG EQL 0
    THEN RETURN SIGNAL(MAIL$_NOTREADIN);

IF .COPY_FLAGS[MCR_V_ALL]
    AND .MAIL$L_NMSG EQL 0
    THEN RETURN SIGNAL(MAIL$_NOMSGS);
CLI$GET_VALUE(SD_FILE,DYN_DESC_2);

IF .DYN_DESC_2[DSC$W_LENGTH] EQL 0
THEN BEGIN
    !
    ! Move to a folder in the same file
    !
    IF NOT .COPY_FLAGS[MCR_V_ALL]
	THEN MAIL$FILE_I_MSG(DYN_DESC,.CONFIRM_FLAG)
	ELSE BEGIN
	    SAVE_MSGNUM = .MAIL$L_MSG_NUM;
	    IF .MAIL$L_NMSG GTRU 0
	    THEN INCRU I FROM 1 TO .MAIL$L_NMSG
	    DO BEGIN
		MAIL$L_CURMSG = .MAIL$L_MSGTBL[.I-1];
		IF .MAIL$L_CURMSG NEQ 0
		THEN BEGIN
		    MAIL$L_MSG_NUM = .I;
		    STATUS = MAIL$FILE_I_MSG(DYN_DESC,.CONFIRM_FLAG);
		    IF .STATUS EQL RMS$_RNF
			THEN EXITLOOP;
		    END;
		END;
	    MAIL$L_MSG_NUM = .SAVE_MSGNUM;
	    IF .SAVE_MSGNUM NEQ 0
		THEN MAIL$L_CURMSG = .MAIL$L_MSGTBL[.SAVE_MSGNUM-1];
	    END;
    END
ELSE BEGIN
    !
    ! Move to a folder in another file.
    !
    IF .CONFIRM_FLAG
	THEN COPY_FLAGS[MCR_V_CONFNEW] = TRUE;
    COPY_FLAGS[MCR_V_DELMSG] = TRUE;
    MAIL$COPY_MSGS(DYN_DESC_2,DYN_DESC,.COPY_FLAGS,TELL_CREATED);
    END;

RETURN TRUE
END;

GLOBAL ROUTINE MAIL$LOAD_LBRSHR =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Load LBRSHR if it has not been loaded
!
!--
BEGIN

IF .MAIL$A_OUTPUT_HELP NEQ 0
    THEN RETURN TRUE;

RETURN LIB$FIND_IMAGE_SYMBOL($DESCRIPTOR('LBRSHR'),
			$DESCRIPTOR('LBR$OUTPUT_HELP'),
			MAIL$A_OUTPUT_HELP)
END;

ROUTINE HELP_HANDLER (SIGARG,MECHARG) =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Turn fatal signals from LBR$OUTPUT_HELP into errors
!
!--
BEGIN
MAP
    SIGARG : REF $BBLOCK;

BIND
    SIGNAME = SIGARG[CHF$L_SIG_NAME] : $BBLOCK;

IF .SIGNAME[STS$V_SEVERITY] EQL STS$K_SEVERE
    THEN SIGNAME[STS$V_SEVERITY] = STS$K_ERROR;

RETURN SS$_RESIGNAL
END;

GLOBAL ROUTINE MAIL$CMD_HELP =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This is the HELP command action routine and is called to display
!	help for specified commands and topics.
!
! INPUTS:
!
! OUTPUTS:
!
!	Help for specified topic is displayed on SYS$OUTPUT.
!--
BEGIN

BUILTIN
    FP;

CLI$GET_VALUE(SD_HELPKEYS,COMMAND_DESC);	!Get REST_OF_LINE
MAIL$CMD_ERASE();				!Erase the screen
IF_ERR(MAIL$LOAD_LBRSHR();,
	RETURN TRUE);

MAIL$DISABLE_CTRLC();
.FP = HELP_HANDLER;
(.MAIL$A_OUTPUT_HELP)(MAIL$PUT_OUTPUT,0,
			COMMAND_DESC,$DESCRIPTOR('MAILHELP'),
			%REF(HLP$M_PROMPT OR HLP$M_PROCESS OR
				HLP$M_GROUP OR HLP$M_SYSTEM OR
				HLP$M_HELP),
			MAIL$GET_INPUT);

MAIL$ENABLE_CTRLC();
RETURN TRUE
END;

GLOBAL ROUTINE MAIL$CMD_PRINT = 
!++
! FUNCTIONAL DESCRIPTION:
!
!	This is the PRINT command action routine and is called to queue
!	the current message for printing.
!
! INPUTS:
!
!	Current message context.
!
! OUTPUTS:
!
!	Current message is added to specified queue for printing.
!--
BEGIN

LOCAL
    N_COPIES,
    PRQ_FLAGS : $BBLOCK[4];

PRQ_FLAGS = 0;
PRQ_FLAGS[PRQ_V_NOTIFY] = CLI$PRESENT(SD_NOTIFY);
IF (PRQ_FLAGS[PRQ_V_FORCE] = CLI$PRESENT(SD_PRINT))
    THEN RETURN MAIL$PRINT(0,0,.PRQ_FLAGS);

IF NOT (PRQ_FLAGS[PRQ_V_ALL] = CLI$PRESENT(SD_ALL))
THEN BEGIN
    IF_ERR((IF .MAIL$GL_FLAGS[MAIF_V_ISAM]
		THEN MAIL$REWIND_I_MSG()
		ELSE MAIL$REWIND_MSG());,	! Rewind current message
	RETURN SIGNAL(.STATUS));
    END
ELSE BEGIN
    IF (IF .MAIL$GL_FLAGS[MAIF_V_ISAM]
	THEN .MAIL$L_NMSG EQL 0
	ELSE .MAIL$L_MSGBUFSIZ EQL 0)
	THEN RETURN SIGNAL(MAIL$_NOMSGS);
    END;

N_COPIES = 1;
IF CLI$GET_VALUE(SD_COPIES,COMMAND_DESC)
    THEN IF_ERR(LIB$CVT_DTB(.COMMAND_DESC[DSC$W_LENGTH],
		.COMMAND_DESC[DSC$A_POINTER],N_COPIES);,
	RETURN SIGNAL(MAIL$_BADVALUE,1,COMMAND_DESC));

IF .N_COPIES EQLU 0
    OR .N_COPIES GTRU 255
    THEN RETURN SIGNAL(MAIL$_BADVALUE,1,COMMAND_DESC);

CLI$GET_VALUE(SD_QUEUE,COMMAND_DESC);
MAIL$PRINT(COMMAND_DESC,.N_COPIES,.PRQ_FLAGS);	!Queue the message(s)

RETURN TRUE;
END;

GLOBAL ROUTINE MAIL$CMD_NEXT = 
!++
! FUNCTIONAL DESCRIPTION:
!
!	This is the NEXT command action routine and is called to display
!	the text of the next message.
!
! INPUTS:
!
!	Current message context.
!
! OUTPUTS:
!
!	Next message text is displayed on SYS$OUTPUT.
!--
BEGIN
LOCAL
    EDIT_FLAG;

MAIL$CLR_DIR_FLAG();
EDIT_FLAG = CLI$PRESENT(SD_EDIT);
IF .MAIL$GL_FLAGS[MAIF_V_ISAM]
THEN BEGIN
    IF MAIL$FIND_I_MSG(0)
	THEN (MAIL$REWIND_I_MSG(); READ_MESSAGE(.EDIT_FLAG))
	ELSE IF .MAIL$L_MSG_STS EQL MAIL$_NOMOREMSG
	    OR .MAIL$L_MSG_STS EQL MAIL$_NOMSGS
		THEN SIGNAL(.MAIL$L_MSG_STS);
    END
ELSE
IF MAIL$FIND_MSG(0)				! Find next message
THEN
	READ_MESSAGE(.EDIT_FLAG)		! Display it
ELSE
	IF .MAIL$L_MSG_STS EQL MAIL$_NOMOREMSG
	THEN
		SIGNAL(MAIL$_NOMOREMSG);
RETURN TRUE
END;

GLOBAL ROUTINE MAIL$CMD_PURGE =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Delete all messages in the wastebasket folder, or if PURGE/RECLAIM
!	is specified, reclaim deleted space in the ISAM file
!
!--
BEGIN

IF_ERR(MAIL$OPEN_IF();,
	RETURN .STATUS);

IF NOT .MAIL$GL_FLAGS[MAIF_V_ISAM]
    THEN RETURN SIGNAL(MAIL$_NOTISAM);

IF CLI$PRESENT(SD_RECLAIM)
THEN BEGIN
    MAIL$GL_FLAGS[MAIF_V_RECL] = 1;
    MAIL$EMPTY_WASTEBASKET();
    MAIL$GL_FLAGS[MAIF_V_RECL] = 0;
    MAIL$RECLAIM(CLI$PRESENT(SD_STATISTICS));
    END
ELSE SIGNAL(MAIL$_DELMSGS,1,MAIL$EMPTY_WASTEBASKET());

RETURN TRUE
END;

GLOBAL ROUTINE MAIL$CMD_COMPRESS =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Process the COMPRESS command.
!
!--
BEGIN
LOCAL
    FLAGS : BITVECTOR[32],
    DESC : VECTOR[2,LONG],
    STATUS;

DESC[0] = DESC[1] = 0;
!
! If a file was specified, use that.  Else, if a file is open,
! use that.  Else, open the default file.
!
IF CLI$PRESENT(SD_FILE)
THEN BEGIN
    MAIL$CLOSE_FILE();
    CLI$GET_VALUE(SD_FILE,DYN_DESC);
    IF_ERR(MAIL$OPEN_FILE(DYN_DESC);,
	RETURN .STATUS);
    END
ELSE IF NOT .MAIL$GL_FLAGS[MAIF_V_FILOPN]
    THEN IF_ERR(MAIL$OPEN_FILE(DESC);,
		RETURN .STATUS);
IF NOT .MAIL$GL_FLAGS[MAIF_V_ISAM]
    THEN RETURN SIGNAL(MAIL$_NOTISAM);

CLI$GET_VALUE(SD_OUTPUT,DYN_DESC_2);
!CLI$GET_VALUE(SD_FDL,DYN_DESC_3);
FLAGS = 0;
MAIL$COMPRESS(.FLAGS,DYN_DESC_2,DESC);
RETURN TRUE
END;

GLOBAL ROUTINE MAIL$CMD_SEARCH =
!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine is the SEARCH command action routine and is called to
!	search for a message containing the specified string.
!
! INPUTS:
!
! OUTPUTS:
!
!	A message containing the search string is displayed.
!--
BEGIN


LOCAL
	TEST_REC: BLOCK[8,BYTE],		! Test record descriptor
	TEST_REC_BUFF: BLOCK[MAIL$K_INBUFFSZ];	! Test record buffer

MAIL$CLR_DIR_FLAG();

IF_ERR(SELECT_DEFAULT();,		! Open file, select msgs if not
	RETURN .STATUS);

TEST_REC[DSC$A_POINTER] = TEST_REC_BUFF;	! Init descriptor
!
! If a string is specified, use it and reset search to first message.
!
IF CLI$GET_VALUE(SD_SEARCH1,COMMAND_DESC)
THEN BEGIN
    MAIL$STRIP_QUOTES(COMMAND_DESC,COMMAND_DESC);
    MAIL$UPCASE(COMMAND_DESC);		!Upcase in case quoted...DCL didn't
    SEARCH_STRING[DSC$W_LENGTH] = MIN(.COMMAND_DESC[DSC$W_LENGTH],
					  %ALLOCATION(SEARCH_STRING_BUFF));
    CH$MOVE(.SEARCH_STRING[DSC$W_LENGTH],.COMMAND_DESC[DSC$A_POINTER],
		SEARCH_STRING_BUFF);
    IF_ERR((IF .MAIL$GL_FLAGS[MAIF_V_ISAM]
		THEN MAIL$FIND_I_MSG(1,1)	! Start with first message
		ELSE MAIL$FIND_MSG(1));,
		IF .MAIL$GL_FLAGS[MAIF_V_ISAM]
		    THEN SIGNAL(.STATUS);
		RETURN TRUE);
    END
ELSE
	IF_ERR((IF .MAIL$GL_FLAGS[MAIF_V_ISAM]
		    THEN MAIL$FIND_I_MSG(0)	! Else, start with next message
		    ELSE MAIL$FIND_MSG(0));,
		IF .MAIL$GL_FLAGS[MAIF_V_ISAM]
		    THEN SIGNAL(.STATUS);
		RETURN TRUE);
!
! Search through the messages starting with the current.
!
IF .MAIL$GL_FLAGS[MAIF_V_ISAM]
THEN BEGIN
    LOCAL
	RECDESC : $BBLOCK[DSC$C_S_BLN],
	MOREFLAG;

    DO BEGIN
	MAIL$REWIND_I_MSG();
	WHILE MAIL$GET_I_MSG(RECDESC,MOREFLAG)
	DO BEGIN
	    TEST_REC[DSC$W_LENGTH] = MIN(.RECDESC[DSC$W_LENGTH],MAIL$K_INBUFFSZ);
	    CH$MOVE(.TEST_REC[DSC$W_LENGTH],.RECDESC[DSC$A_POINTER],
			TEST_REC_BUFF);
	    UPCASE(TEST_REC);
	    IF NOT CH$FAIL(CH$FIND_SUB(.TEST_REC[DSC$W_LENGTH],
					.TEST_REC[DSC$A_POINTER],
					.SEARCH_STRING[DSC$W_LENGTH],
					.SEARCH_STRING[DSC$A_POINTER]))
	    THEN BEGIN
		MAIL$REWIND_I_MSG();
		READ_MESSAGE(0);
		RETURN TRUE;
		END;
	    END;
	IF .MAIL$GL_FLAGS[MAIF_V_CTRLCFL] THEN EXITLOOP;
	END
	UNTIL NOT MAIL$FIND_I_MSG(0);
    END
ELSE BEGIN
DO 
    DO BEGIN
	IF .MAIL$GL_FLAGS[MAIF_V_CTRLCFL] THEN EXITLOOP;
	TEST_REC[DSC$W_LENGTH] = MIN(.MAIL$W_MSG_RSIZ,MAIL$K_INBUFFSZ);
	CH$MOVE(.TEST_REC[DSC$W_LENGTH],.MAIL$L_MSG_RADR,TEST_REC_BUFF);
	UPCASE(TEST_REC);
	IF NOT CH$FAIL(CH$FIND_SUB(.TEST_REC[DSC$W_LENGTH],
					   .TEST_REC[DSC$A_POINTER],
					   .SEARCH_STRING[DSC$W_LENGTH],
					   .SEARCH_STRING[DSC$A_POINTER]))
	THEN BEGIN
	    MAIL$REWIND_MSG();
	    MAIL$READ();
	    RETURN TRUE;
	    END;
    END
    UNTIL NOT MAIL$GET_MSG()
UNTIL NOT MAIL$FIND_MSG(0);
END;

SIGNAL(MAIL$_NOTFOUND,1,SEARCH_STRING);

RETURN TRUE;
END;

GLOBAL ROUTINE MAIL$CMD_CURRENT =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Redisplay the current message
!
!--
BEGIN
LOCAL
    EDIT_FLAG;

MAIL$CLR_DIR_FLAG();
EDIT_FLAG = CLI$PRESENT(SD_EDIT);
IF .MAIL$GL_FLAGS[MAIF_V_ISAM]
THEN BEGIN
    IF NOT .MAIL$GL_FLAGS[MAIF_V_FILOPN]
	OR .MAIL$L_MSG_NUM EQL 0
	THEN RETURN SIGNAL(MAIL$_NOTREADIN);
    MAIL$FIND_I_MSG(.MAIL$L_MSG_NUM);
    IF NOT .MAIL$L_MSG_STS
	THEN RETURN SIGNAL(.MAIL$L_MSG_STS);
    MAIL$REWIND_I_MSG();
    END
ELSE BEGIN
    IF NOT MAIL$REWIND_MSG()
	THEN RETURN SIGNAL(MAIL$_NOTREADIN);
    END;
READ_MESSAGE(.EDIT_FLAG);

RETURN TRUE
END;

GLOBAL ROUTINE MAIL$CMD_FIRST =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Retype the first message in the folder
!
!--
BEGIN
LOCAL
    EDIT_FLAG;

MAIL$CLR_DIR_FLAG();
IF_ERR(SELECT_DEFAULT();,
	RETURN .STATUS);

EDIT_FLAG = CLI$PRESENT(SD_EDIT);
IF .MAIL$GL_FLAGS[MAIF_V_ISAM]
THEN BEGIN
    MAIL$FIND_I_MSG(1);
    IF NOT .MAIL$L_MSG_STS
	THEN RETURN SIGNAL(.MAIL$L_MSG_STS);
    MAIL$REWIND_I_MSG();
    END
ELSE IF_ERR(MAIL$FIND_MSG(1);,
	RETURN TRUE);
READ_MESSAGE(.EDIT_FLAG);
RETURN TRUE
END;

GLOBAL ROUTINE MAIL$CMD_LAST =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Type the last message in the folder
!
!--
BEGIN
LOCAL
    EDIT_FLAG;

MAIL$CLR_DIR_FLAG();
IF_ERR(SELECT_DEFAULT();,
	RETURN .STATUS);

EDIT_FLAG = CLI$PRESENT(SD_EDIT);
IF .MAIL$GL_FLAGS[MAIF_V_ISAM]
THEN BEGIN
    IF .MAIL$L_NMSG EQL 0
	THEN RETURN SIGNAL(MAIL$_NOMSGS);
    MAIL$FIND_I_MSG(.MAIL$L_NMSG);
    IF NOT .MAIL$L_MSG_STS
	THEN RETURN SIGNAL(.MAIL$L_MSG_STS);
    MAIL$REWIND_I_MSG();
    END
ELSE IF_ERR(MAIL$FIND_MSG(%X'7FFFFFFF');,
		RETURN TRUE);
READ_MESSAGE(.EDIT_FLAG);
RETURN TRUE
END;

GLOBAL ROUTINE MAIL$CMD_SPAWN =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Spawn a subprocess
!
!--
BEGIN

OWN
    PROC_DESC : DYN_DESC_DECL,
    INP_DESC : DYN_DESC_DECL,
    OUT_DESC : DYN_DESC_DECL;

LOCAL
    SUBPROCPID,
    PURGE_VEC : VECTOR[2,LONG],
    SPAWN_FLAGS;

IF .MAIL$GL_FLAGS[MAIF_V_CAPTIVE]
    THEN RETURN SIGNAL(MAIL$_CAPTIVE);

SPAWN_FLAGS = 0;
CLI$GET_VALUE(SD_PROCESS,PROC_DESC);
CLI$GET_VALUE(SD_INPUT,INP_DESC);
CLI$GET_VALUE(SD_OUTPUT,OUT_DESC);
CLI$GET_VALUE(SD_P1,COMMAND_DESC);

IF NOT CLI$PRESENT(SD_WAIT)
    THEN SPAWN_FLAGS = .SPAWN_FLAGS OR 1;

IF NOT CLI$PRESENT(SD_SYMBOLS)
    THEN SPAWN_FLAGS = .SPAWN_FLAGS OR 2;

IF NOT CLI$PRESENT(SD_LOGICAL_NAMES)
    THEN SPAWN_FLAGS = .SPAWN_FLAGS OR 4;

MAIL$DISABLE_CTRLC();
IF (.SPAWN_FLAGS AND 1) EQL 0		!ONLY IF SPAWN/WAIT
THEN BEGIN
    PURGE_VEC[0] = 0;
    PURGE_VEC[1] = %X'7FFFFFFF';
    $PURGWS(INADR=PURGE_VEC);
    END;
IF_ERR(LIB$SPAWN(COMMAND_DESC,INP_DESC,OUT_DESC,
		SPAWN_FLAGS,PROC_DESC,SUBPROCPID);,
	(MAP STATUS : $BBLOCK;
	    STATUS[STS$V_SEVERITY] = STS$K_ERROR;
	    MAIL$ENABLE_CTRLC();
	    RETURN SIGNAL(.STATUS)));

MAIL$ENABLE_CTRLC();
IF (.SPAWN_FLAGS AND 1) EQL 0		!SPAWN /WAIT
    THEN MAIL$CMD_SHOW_NEW();

RETURN TRUE
END;

GLOBAL ROUTINE MAIL$CMD_ATTACH =
!++
! FUNCTIONAL DESCRIPTION:
!
!	Attach to a subprocess
!
!--
BEGIN

LOCAL
    STATUS,
    SUBPROCPID : VOLATILE,
    PURGE_VEC : VECTOR[2,LONG],
    PARENT_FLAG,
    ITMLST : $ITMLST_DECL(ITEMS=1);

CLI$GET_VALUE(SD_P1,COMMAND_DESC);

PARENT_FLAG = CLI$PRESENT(SD_PARENT);

IF .PARENT_FLAG
THEN BEGIN
    $ITMLST_INIT(ITMLST=ITMLST,
	(ITMCOD=JPI$_OWNER,BUFADR=SUBPROCPID));

    STATUS = $GETJPIW(ITMLST=ITMLST);
    IF NOT .STATUS
	OR (.SUBPROCPID EQL 0)
	THEN RETURN SIGNAL(MAIL$_NOPARENT);
    END
ELSE BEGIN
    $ITMLST_INIT(ITMLST=ITMLST,
	(ITMCOD=JPI$_PID,BUFADR=SUBPROCPID));

    IF_ERR($GETJPIW(PRCNAM=COMMAND_DESC,ITMLST=ITMLST);,
	RETURN SIGNAL(.STATUS));
    END;

IF .SUBPROCPID EQL 0
    THEN RETURN SIGNAL((SS$_NONEXPR AND NOT STS$M_SEVERITY) OR STS$K_WARNING);

MAIL$DISABLE_CTRLC();
PURGE_VEC[0] = 0;
PURGE_VEC[1] = %X'7FFFFFFF';
$PURGWS(INADR=PURGE_VEC);
IF_ERR(LIB$ATTACH(SUBPROCPID);,
	(MAP STATUS : $BBLOCK;
	    STATUS[STS$V_SEVERITY] = STS$K_ERROR;
	    MAIL$ENABLE_CTRLC();
	    RETURN SIGNAL(.STATUS)));

MAIL$ENABLE_CTRLC();
MAIL$CMD_SHOW_NEW();

RETURN TRUE
END;

END
ELUDOM
