MODULE JBCCMDPRS(%TITLE	'Job Controller Command Parsing Utilities'
		IDENT = 'V04-000'
		) =
BEGIN

!
!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************
!

!++
! FACILITY:
!	Queue manipulation commands.
!
! ABSTRACT:
!	This module contains common qualifier parsing routines for the queue
!	manipulation commands.
!
! ENVIRONMENT:
!	VAX/VMS user mode.
!--
!
! AUTHOR: M. Jack, CREATION DATE: 30-Apr-1982
!
! MODIFIED BY:
!
!	V03-101	JAK0220		J A Krycka	20-Jul-1984
!		Add support for new qualifiers.
!
!	V03-009	MLJ0118		Martin L. Jack,	23-Aug-1983
!		Change names to track $SJCDEF.
!
!	V03-007	LMP0140		L. Mark Pilant,		23-Aug-1983
!		Add support for alphanumeric UICs.
!
!	V03-007	MLJ0115		Martin L. Jack,	30-Jul-1983
!		Changes for job controller baselevel.
!
!	V03-006	KBT0569		Keith B. Thompson	29-Jul-1983
!		Remove lib$extract_conceal hack
!
!	V03-005	MLJ0114		Martin L. Jack,	23-Jun-1983
!		Changes for job controller baselevel.
!
!	V03-004	MLJ0113		Martin L. Jack,	26-May-1983
!		Changes for job controller baselevel.
!
!	V03-003	MLJ0112		Martin L. Jack,	29-Apr-1983
!		Changes for job controller baselevel.
!
!	V03-002	MLJ0109		Martin L. Jack,	13-Apr-1983
!		Add new qualifiers, relax length restrictions, disallow wildcard
!		in /LOG_FILE.
!
!	V03-001	MLJ0106		Martin L. Jack,	01-Mar-1983
!		Support START/QUEUE/MANAGER.
!
!**

LIBRARY 'SYS$LIBRARY:LIB';
LIBRARY 'SYS$LIBRARY:TPAMAC';
REQUIRE 'SRC$:JBCPRSDEF';


LITERAL
	TRUE=		1,
	FALSE=		0;


STRUCTURE
	BBLOCK[O,P,S,E;N]=
	    [N]
	    (BBLOCK + O)<P,S,E>;


PSECT
	CODE=		CODE,
	PLIT=		CODE,
	OWN=		DATA,
	GLOBAL=		DATA;


FORWARD ROUTINE
	CALL_TPARSE,
	PARSE_IF_TRUE:		PARSE_LINKAGE,
	PARSE_IF_FALSE:		PARSE_LINKAGE,
	PARSE_IF_TRUE_FALSE:	PARSE_LINKAGE,
	PARSE_LOCAL_TRUE_FALSE:	PARSE_LINKAGE,
	PARSE_AFTER:		PARSE_LINKAGE,
	PARSE_ALIGN:		PARSE_LINKAGE,
	PARSE_BACKWARD:		PARSE_LINKAGE,
	PARSE_BASE_PRIORITY:	PARSE_LINKAGE,
	PARSE_BUFFER_COUNT:	PARSE_LINKAGE,
	PARSE_CHARACTERISTICS:	PARSE_LINKAGE,
	PARSE_CHAR_NUMBER:	PARSE_LINKAGE,
	PARSE_COMMA_LIST:	PARSE_LINKAGE,
	PARSE_COPIES:		PARSE_LINKAGE,
	PARSE_CPUTIME:		PARSE_LINKAGE,
	PARSE_ENTRY:		PARSE_LINKAGE_VALUE,
	PARSE_EXTEND_QUANTITY:	PARSE_LINKAGE,
	PARSE_FILENAME:		PARSE_LINKAGE,
	PARSE_FORWARD:		PARSE_LINKAGE,
	PARSE_FORM:		PARSE_LINKAGE,
	PARSE_GENERIC:		PARSE_LINKAGE,
	PARSE_JOB_LIMIT:	PARSE_LINKAGE,
	PARSE_LOG_FILE:		PARSE_LINKAGE_VALUE,
	PARSE_LOWER_UPPER:	PARSE_LINKAGE,
	PARSE_NAME:		PARSE_LINKAGE,
	PARSE_NAME_AND_LOG_FILE:PARSE_LINKAGE,
	PARSE_NONZERO_NUMBER:	PARSE_LINKAGE,
	PARSE_NUMBER:		PARSE_LINKAGE,
	PARSE_OBJECT_NAME:	PARSE_LINKAGE,
	PARSE_ON:		PARSE_LINKAGE,
	PARSE_OWNER:		PARSE_LINKAGE,
	PARSE_PARAMETERS:	PARSE_LINKAGE,
	PARSE_PRINTER:		PARSE_LINKAGE,
	PARSE_PRIORITY:		PARSE_LINKAGE,
	PARSE_PROTECTION:	PARSE_LINKAGE,
	PARSE_QUEUE:		PARSE_LINKAGE,
	PARSE_SEARCH_STRING:	PARSE_LINKAGE,
	PARSE_STRING:		PARSE_LINKAGE,
	PARSE_STRING_255:	PARSE_LINKAGE,
	PARSE_WORKING_SET:	PARSE_LINKAGE;


EXTERNAL ROUTINE
	CLI$GET_VALUE:	ADDRESSING_MODE(GENERAL),
					! Get a parameter or qualifier value
	CLI$PRESENT:	ADDRESSING_MODE(GENERAL),
					! Determine if entity is present
	LIB$CVT_DTB:	ADDRESSING_MODE(GENERAL),
					! Convert decimal string to binary
	LIB$CVT_DTIME:	ADDRESSING_MODE(GENERAL),
					! Convert delta time to binary
	LIB$CVT_TIME:	ADDRESSING_MODE(GENERAL),
					! Convert absolute time to binary
	LIB$TPARSE:	ADDRESSING_MODE(GENERAL);
					! Table-driven parser


EXTERNAL LITERAL
	CLI$_COMMA,
	CLI$_NEGATED,
	CLI$_LOCNEG,
	CLI$_LOCPRES;


BIND
	LITERAL_MINUS_ONE=	UPLIT(-1),
	LITERAL_ZERO=		UPLIT(0),
	LITERAL_ONE=		UPLIT(+1);


FORWARD

	! TPARSE tables, which are defined at the end of this module.
	!
	NONE_STATES:	VECTOR[0],
	NONE_KEYS:	VECTOR[0],
	INFI_STATES:	VECTOR[0],
	INFI_KEYS:	VECTOR[0],
	SYMB_STATES:	VECTOR[0],
	SYMB_KEYS:	VECTOR[0],
	MASK_STATES:	VECTOR[0],
	MASK_KEYS:	VECTOR[0],
	OWNE_STATES:	VECTOR[0],
	OWNE_KEYS:	VECTOR[0],
	PROT_STATES:	VECTOR[0],
	PROT_KEYS:	VECTOR[0];


OWN
	TPA_1,
	CONVERTED_UIC;


BUILTIN
	EDIV,
	TESTBITCC;

ROUTINE CALL_TPARSE(SRC,STATES,KEYS)=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine executes a call to LIB$TPARSE.
!
! INPUT PARAMETERS:
!	SRC		- Address of a descriptor for the string to be parsed.
!	STATES		- State table parameter for TPARSE.
!	KEYS		- Keyword table parameter for TPARSE.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	As returned by LIB$TPARSE.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	SRC:		REF BBLOCK;		! Pointer to descriptor
LOCAL
	TPA_PARAM:	BBLOCK[TPA$K_LENGTH0];	! TPARSE parameter block


CH$FILL(0, TPA$K_LENGTH0, TPA_PARAM);
TPA_PARAM[TPA$L_COUNT] = TPA$K_COUNT0;
TPA_PARAM[TPA$L_OPTIONS] = TPA$M_ABBREV;
TPA_PARAM[TPA$L_STRINGCNT] = .SRC[DSC$W_LENGTH];
TPA_PARAM[TPA$L_STRINGPTR] = .SRC[DSC$A_POINTER];
LIB$TPARSE(TPA_PARAM, .STATES, .KEYS)
END;

GLOBAL ROUTINE PARSE_IF_TRUE(PARSE_PARAMETERS_): PARSE_LINKAGE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine parses a Boolean qualifier, making an entry in the job
!	controller parameter list if the qualifier is present.
!
! INPUT PARAMETERS:
!	Standard parser parameters.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
PARSE_EXTERNAL_REGISTERS;	! Declare external registers


IF CLI$PRESENT(.Q_DESC)
THEN
    BEGIN
    Q_ICURSOR[0,0,16,0] = 0;
    Q_ICURSOR[2,0,16,0] = .Q_P1;
    Q_ICURSOR[4,0,32,0] = 0;
    Q_ICURSOR[8,0,32,0] = 0;
    Q_ICURSOR = .Q_ICURSOR + 12;
    END;
END;

GLOBAL ROUTINE PARSE_IF_FALSE(PARSE_PARAMETERS_): PARSE_LINKAGE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine parses a Boolean qualifier, making an entry in the job
!	controller parameter list if the qualifier is explicitly negated.
!
! INPUT PARAMETERS:
!	Standard parser parameters.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
PARSE_EXTERNAL_REGISTERS;	! Declare external registers
LOCAL
	STATUS;
BUILTIN
	ACTUALCOUNT,
	ACTUALPARAMETER;


STATUS = CLI$PRESENT(.Q_DESC);
IF .STATUS EQL CLI$_NEGATED OR .STATUS EQL CLI$_LOCNEG
THEN
    BEGIN
    INCR I FROM 2 TO ACTUALCOUNT() DO
	BEGIN
	Q_ICURSOR[0,0,16,0] = 0;
	Q_ICURSOR[2,0,16,0] = ACTUALPARAMETER(.I);
	Q_ICURSOR[4,0,32,0] = 0;
	Q_ICURSOR[8,0,32,0] = 0;
	Q_ICURSOR = .Q_ICURSOR + 12;
	END;
    END;
END;

GLOBAL ROUTINE PARSE_IF_TRUE_FALSE(PARSE_PARAMETERS_): PARSE_LINKAGE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine parses a Boolean qualifier, making an entry in the job
!	controller parameter list according to the true or false status.
!
! INPUT PARAMETERS:
!	Standard parser parameters.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
PARSE_EXTERNAL_REGISTERS;	! Declare external registers
LOCAL
	STATUS;


STATUS = CLI$PRESENT(.Q_DESC);
IF .STATUS
THEN
    BEGIN
    Q_ICURSOR[0,0,16,0] = 0;
    Q_ICURSOR[2,0,16,0] = .Q_P1;
    Q_ICURSOR[4,0,32,0] = 0;
    Q_ICURSOR[8,0,32,0] = 0;
    Q_ICURSOR = .Q_ICURSOR + 12;
    END
ELSE IF .STATUS EQL CLI$_NEGATED OR .STATUS EQL CLI$_LOCNEG
THEN
    BEGIN
    Q_ICURSOR[0,0,16,0] = 0;
    Q_ICURSOR[2,0,16,0] = .Q_P2;
    Q_ICURSOR[4,0,32,0] = 0;
    Q_ICURSOR[8,0,32,0] = 0;
    Q_ICURSOR = .Q_ICURSOR + 12;
    END;
END;

GLOBAL ROUTINE PARSE_LOCAL_TRUE_FALSE(PARSE_PARAMETERS_): PARSE_LINKAGE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine parses a Boolean qualifier, making an entry in the job
!	controller parameter list according to the locally present or negated
!	status.
!
! INPUT PARAMETERS:
!	Standard parser parameters.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
PARSE_EXTERNAL_REGISTERS;	! Declare external registers
LOCAL
	STATUS;


STATUS = CLI$PRESENT(.Q_DESC);
IF .STATUS EQL CLI$_LOCPRES
THEN
    BEGIN
    Q_ICURSOR[0,0,16,0] = 0;
    Q_ICURSOR[2,0,16,0] = .Q_P1;
    Q_ICURSOR[4,0,32,0] = 0;
    Q_ICURSOR[8,0,32,0] = 0;
    Q_ICURSOR = .Q_ICURSOR + 12;
    END
ELSE IF .STATUS EQL CLI$_LOCNEG
THEN
    BEGIN
    Q_ICURSOR[0,0,16,0] = 0;
    Q_ICURSOR[2,0,16,0] = .Q_P2;
    Q_ICURSOR[4,0,32,0] = 0;
    Q_ICURSOR[8,0,32,0] = 0;
    Q_ICURSOR = .Q_ICURSOR + 12;
    END;
END;

GLOBAL ROUTINE PARSE_AFTER(PARSE_PARAMETERS_): PARSE_LINKAGE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine parses the /AFTER qualifier, making an entry in the job
!	controller parameter list.
!
! INPUT PARAMETERS:
!	Standard parser parameters.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
PARSE_EXTERNAL_REGISTERS;	! Declare external registers
LOCAL
	STATUS;


STATUS = CLI$PRESENT(.Q_DESC);
IF .STATUS
THEN
    BEGIN
    CLI$GET_VALUE(.Q_DESC, .Q_VALUE_DESC);
    IF NOT LIB$CVT_TIME(.Q_VALUE_DESC, .Q_DCURSOR)
    THEN
	SIGNAL_STOP(.Q_MESSAGE, 2, .Q_VALUE_DESC, .Q_DESC);


    Q_ICURSOR[0,0,16,0] = 8;
    Q_ICURSOR[2,0,16,0] = SJC$_AFTER_TIME;
    Q_ICURSOR[4,0,32,0] = .Q_DCURSOR;
    Q_ICURSOR[8,0,32,0] = 0;
    Q_ICURSOR = .Q_ICURSOR + 12;
    Q_DCURSOR = .Q_DCURSOR + 8;
    END;
IF .STATUS EQL CLI$_NEGATED OR .STATUS EQL CLI$_LOCNEG
THEN
    BEGIN
    Q_ICURSOR[0,0,16,0] = 0;
    Q_ICURSOR[2,0,16,0] = SJC$_NO_AFTER_TIME;
    Q_ICURSOR[4,0,32,0] = 0;
    Q_ICURSOR[8,0,32,0] = 0;
    Q_ICURSOR = .Q_ICURSOR + 12;
    END;
END;

GLOBAL ROUTINE PARSE_ALIGN(PARSE_PARAMETERS_): PARSE_LINKAGE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine parses the /ALIGN qualifier, making an entry in the job
!	controller parameter list.
!
! INPUT PARAMETERS:
!	Standard parser parameters.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
PARSE_EXTERNAL_REGISTERS;	! Declare external registers
LOCAL
	EXPLICIT_PAGES;


IF CLI$PRESENT(.Q_DESC)
THEN
    BEGIN
    EXPLICIT_PAGES = FALSE;


    WHILE CLI$GET_VALUE(.Q_DESC, .Q_VALUE_DESC) DO
	BEGIN
	IF LIB$CVT_DTB(
	    .Q_VALUE_DESC[DSC$W_LENGTH], .Q_VALUE_DESC[DSC$A_POINTER],
	    .Q_DCURSOR)
	THEN
	    BEGIN
	    IF .Q_DCURSOR[0,0,32,0] - 1 GTRU 20 - 1	! 1 <= N <= 20
	    THEN
		SIGNAL_STOP(.Q_MESSAGE, 2, .Q_VALUE_DESC, .Q_DESC);


	    EXPLICIT_PAGES = TRUE;
	    Q_ICURSOR[0,0,16,0] = 4;
	    Q_ICURSOR[2,0,16,0] = SJC$_ALIGNMENT_PAGES;
	    Q_ICURSOR[4,0,32,0] = .Q_DCURSOR;
	    Q_ICURSOR[8,0,32,0] = 0;
	    Q_ICURSOR = .Q_ICURSOR + 12;
	    Q_DCURSOR = .Q_DCURSOR + 4;
	    END


	ELSE IF CALL_TPARSE(.Q_VALUE_DESC, MASK_STATES, MASK_KEYS)
	THEN
	    BEGIN
	    Q_ICURSOR[0,0,16,0] = 0;
	    Q_ICURSOR[2,0,16,0] = SJC$_ALIGNMENT_MASK;
	    Q_ICURSOR[4,0,32,0] = 0;
	    Q_ICURSOR[8,0,32,0] = 0;
	    Q_ICURSOR = .Q_ICURSOR + 12;
	    END


	ELSE
	    SIGNAL_STOP(.Q_MESSAGE, 2, .Q_VALUE_DESC, .Q_DESC);
	END;


    IF NOT .EXPLICIT_PAGES
    THEN
	BEGIN
	Q_ICURSOR[0,0,16,0] = 4;
	Q_ICURSOR[2,0,16,0] = SJC$_ALIGNMENT_PAGES;
	Q_ICURSOR[4,0,32,0] = LITERAL_ONE;
	Q_ICURSOR[8,0,32,0] = 0;
	Q_ICURSOR = .Q_ICURSOR + 12;
	END;
    END;
END;

GLOBAL ROUTINE PARSE_BACKWARD(PARSE_PARAMETERS_): PARSE_LINKAGE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine parses the /BACKWARD qualifier, making an entry in the
!	job controller parameter list.
!
! INPUT PARAMETERS:
!	Standard parser parameters.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
PARSE_EXTERNAL_REGISTERS;	! Declare external registers


IF CLI$PRESENT(.Q_DESC)
THEN
    BEGIN
    IF CLI$GET_VALUE(.Q_DESC, .Q_VALUE_DESC)
    THEN
	BEGIN
	IF
	    BEGIN
	    IF NOT LIB$CVT_DTB(
		.Q_VALUE_DESC[DSC$W_LENGTH], .Q_VALUE_DESC[DSC$A_POINTER],
		.Q_DCURSOR)
	    THEN
		TRUE
	    ELSE
		.Q_DCURSOR[0,0,32,0] EQL 0
	    END
	THEN
	    SIGNAL_STOP(.Q_MESSAGE, 2, .Q_VALUE_DESC, .Q_DESC);


	Q_DCURSOR[0,0,32,0] = - .Q_DCURSOR[0,0,32,0];
	Q_ICURSOR[0,0,16,0] = 4;
	Q_ICURSOR[2,0,16,0] = SJC$_RELATIVE_PAGE;
	Q_ICURSOR[4,0,32,0] = .Q_DCURSOR;
	Q_ICURSOR[8,0,32,0] = 0;
	Q_ICURSOR = .Q_ICURSOR + 12;
	Q_DCURSOR = .Q_DCURSOR + 4;
	END
    ELSE
	BEGIN
	Q_ICURSOR[0,0,16,0] = 4;
	Q_ICURSOR[2,0,16,0] = SJC$_RELATIVE_PAGE;
	Q_ICURSOR[4,0,32,0] = LITERAL_MINUS_ONE;
	Q_ICURSOR[8,0,32,0] = 0;
	Q_ICURSOR = .Q_ICURSOR + 12;
	END;
    END;
END;

GLOBAL ROUTINE PARSE_BASE_PRIORITY(PARSE_PARAMETERS_): PARSE_LINKAGE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine parses the /BASE_PRIORITY qualifier, making an entry in the
!	job controller parameter list.
!
! INPUT PARAMETERS:
!	Standard parser parameters.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
PARSE_EXTERNAL_REGISTERS;	! Declare external registers


IF CLI$GET_VALUE(.Q_DESC, .Q_VALUE_DESC)
THEN
    BEGIN
    IF
	BEGIN
	IF NOT LIB$CVT_DTB(
	    .Q_VALUE_DESC[DSC$W_LENGTH], .Q_VALUE_DESC[DSC$A_POINTER],
	    .Q_DCURSOR)
	THEN
	    TRUE
	ELSE
	    .Q_DCURSOR[0,0,32,0] GTRU 15	! 0 <= N <= 15
	END
    THEN
	SIGNAL_STOP(.Q_MESSAGE, 2, .Q_VALUE_DESC, .Q_DESC);


    Q_ICURSOR[0,0,16,0] = 4;
    Q_ICURSOR[2,0,16,0] = SJC$_BASE_PRIORITY;
    Q_ICURSOR[4,0,32,0] = .Q_DCURSOR;
    Q_ICURSOR[8,0,32,0] = 0;
    Q_ICURSOR = .Q_ICURSOR + 12;
    Q_DCURSOR = .Q_DCURSOR + 4;
    END;
END;

GLOBAL ROUTINE PARSE_BUFFER_COUNT(PARSE_PARAMETERS_): PARSE_LINKAGE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine parses the /BUFFER_COUNT qualifier, making an entry in the
!	job controller parameter list.
!
! INPUT PARAMETERS:
!	Standard parser parameters.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
PARSE_EXTERNAL_REGISTERS;	! Declare external registers


IF CLI$GET_VALUE(.Q_DESC, .Q_VALUE_DESC)
THEN
    BEGIN
    IF
	BEGIN
	IF NOT LIB$CVT_DTB(
	    .Q_VALUE_DESC[DSC$W_LENGTH], .Q_VALUE_DESC[DSC$A_POINTER],
	    .Q_DCURSOR)
	THEN
	    TRUE
	ELSE
	    .Q_DCURSOR[0,0,32,0] GTRU 127	! 0 <= N <= 127
	END
    THEN
	SIGNAL_STOP(.Q_MESSAGE, 2, .Q_VALUE_DESC, .Q_DESC);


    Q_ICURSOR[0,0,16,0] = 4;
    Q_ICURSOR[2,0,16,0] = SJC$_BUFFER_COUNT;
    Q_ICURSOR[4,0,32,0] = .Q_DCURSOR;
    Q_ICURSOR[8,0,32,0] = 0;
    Q_ICURSOR = .Q_ICURSOR + 12;
    Q_DCURSOR = .Q_DCURSOR + 4;
    END;
END;

GLOBAL ROUTINE PARSE_CHARACTERISTICS(PARSE_PARAMETERS_): PARSE_LINKAGE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine parses the /CHARACTERISTICS qualifier, making an entry in
!	the job controller parameter list.
!
! INPUT PARAMETERS:
!	Standard parser parameters.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
PARSE_EXTERNAL_REGISTERS;	! Declare external registers
LOCAL
	STATUS;


STATUS = CLI$PRESENT(.Q_DESC);
IF .STATUS
THEN
    BEGIN
    WHILE CLI$GET_VALUE(.Q_DESC, .Q_VALUE_DESC) DO
	BEGIN
	IF LIB$CVT_DTB(
	    .Q_VALUE_DESC[DSC$W_LENGTH], .Q_VALUE_DESC[DSC$A_POINTER],
	    .Q_DCURSOR)
	THEN
	    BEGIN
	    IF .Q_DCURSOR[0,0,32,0] GTRU 127	! 0 <= N <= 127
	    THEN
		SIGNAL_STOP(.Q_MESSAGE, 2, .Q_VALUE_DESC, .Q_DESC);


	    Q_ICURSOR[0,0,16,0] = 4;
	    Q_ICURSOR[2,0,16,0] = SJC$_CHARACTERISTIC_NUMBER;
	    Q_ICURSOR[4,0,32,0] = .Q_DCURSOR;
	    Q_ICURSOR[8,0,32,0] = 0;
	    Q_ICURSOR = .Q_ICURSOR + 12;
	    Q_DCURSOR = .Q_DCURSOR + 4;
	    END


	ELSE IF CALL_TPARSE(.Q_VALUE_DESC, SYMB_STATES, SYMB_KEYS)
	THEN
	    BEGIN
	    Q_ICURSOR[0,0,16,0] = .Q_VALUE_DESC[DSC$W_LENGTH];
	    Q_ICURSOR[2,0,16,0] = SJC$_CHARACTERISTIC_NAME;
	    Q_ICURSOR[4,0,32,0] = .Q_DCURSOR;
	    Q_ICURSOR[8,0,32,0] = 0;
	    Q_ICURSOR = .Q_ICURSOR + 12;
	    Q_DCURSOR = CH$MOVE(
		.Q_VALUE_DESC[DSC$W_LENGTH],
		.Q_VALUE_DESC[DSC$A_POINTER],
		.Q_DCURSOR);
	    END


	ELSE
	    SIGNAL_STOP(.Q_MESSAGE, 2, .Q_VALUE_DESC, .Q_DESC);
	END;
    END;
IF .STATUS EQL CLI$_NEGATED OR .STATUS EQL CLI$_LOCNEG
THEN
    BEGIN
    Q_ICURSOR[0,0,16,0] = 0;
    Q_ICURSOR[2,0,16,0] = SJC$_NO_CHARACTERISTICS;
    Q_ICURSOR[4,0,32,0] = 0;
    Q_ICURSOR[8,0,32,0] = 0;
    Q_ICURSOR = .Q_ICURSOR + 12;
    END;
END;

GLOBAL ROUTINE PARSE_CHAR_NUMBER(PARSE_PARAMETERS_): PARSE_LINKAGE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine parses a characteristic number, making an entry in
!	the job controller parameter list.
!
! INPUT PARAMETERS:
!	Standard parser parameters.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
PARSE_EXTERNAL_REGISTERS;	! Declare external registers
LOCAL
	STATUS;


CLI$GET_VALUE(.Q_DESC, .Q_VALUE_DESC);
IF
    BEGIN
    IF NOT LIB$CVT_DTB(
	.Q_VALUE_DESC[DSC$W_LENGTH], .Q_VALUE_DESC[DSC$A_POINTER],
	.Q_DCURSOR)
    THEN
	TRUE
    ELSE
	.Q_DCURSOR[0,0,32,0] GTRU 127		! 0 <= N <= 127
    END
THEN
    SIGNAL_STOP(.Q_MESSAGE, 2, .Q_VALUE_DESC, .Q_DESC);


Q_ICURSOR[0,0,16,0] = 4;
Q_ICURSOR[2,0,16,0] = SJC$_CHARACTERISTIC_NUMBER;
Q_ICURSOR[4,0,32,0] = .Q_DCURSOR;
Q_ICURSOR[8,0,32,0] = 0;
Q_ICURSOR = .Q_ICURSOR + 12;
Q_DCURSOR = .Q_DCURSOR + 4;
END;

GLOBAL ROUTINE PARSE_COMMA_LIST(PARSE_PARAMETERS_): PARSE_LINKAGE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine parses a qualifier whose value is a comma-separated list of
!	arbitrary strings, making an entry in the job controller parameter list.
!
! INPUT PARAMETERS:
!	Standard parser parameters.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
PARSE_EXTERNAL_REGISTERS;	! Declare external registers
LOCAL
	FIRST,
	STATUS;


STATUS = CLI$PRESENT(.Q_DESC);
IF .STATUS
THEN
    BEGIN
    FIRST = TRUE;
    Q_ICURSOR[0,0,16,0] = 0;
    Q_ICURSOR[2,0,16,0] = .Q_P1;
    Q_ICURSOR[4,0,32,0] = .Q_DCURSOR;
    Q_ICURSOR[8,0,32,0] = 0;
    WHILE CLI$GET_VALUE(.Q_DESC, .Q_VALUE_DESC) DO
	BEGIN
	IF TESTBITCC(FIRST)
	THEN
	    BEGIN
	    (.Q_DCURSOR)<0,8> = %C',';
	    Q_DCURSOR = .Q_DCURSOR + 1;
	    Q_ICURSOR[0,0,16,0] = .Q_ICURSOR[0,0,16,0] + 1;
	    END;
	Q_ICURSOR[0,0,16,0] =
	    .Q_ICURSOR[0,0,16,0] + .Q_VALUE_DESC[DSC$W_LENGTH];
	Q_DCURSOR = CH$MOVE(
	    .Q_VALUE_DESC[DSC$W_LENGTH],
	    .Q_VALUE_DESC[DSC$A_POINTER],
	    .Q_DCURSOR);
	END;
    Q_ICURSOR = .Q_ICURSOR + 12;
    END;
IF .STATUS EQL CLI$_NEGATED OR .STATUS EQL CLI$_LOCNEG
THEN
    BEGIN
    Q_ICURSOR[0,0,16,0] = 0;
    Q_ICURSOR[2,0,16,0] = .Q_P2;
    Q_ICURSOR[4,0,32,0] = 0;
    Q_ICURSOR[8,0,32,0] = 0;
    Q_ICURSOR = .Q_ICURSOR + 12;
    END;
END;

GLOBAL ROUTINE PARSE_COPIES(PARSE_PARAMETERS_): PARSE_LINKAGE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine parses the /COPIES qualifier, making an entry in
!	the job controller parameter list.
!
! INPUT PARAMETERS:
!	Standard parser parameters.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
PARSE_EXTERNAL_REGISTERS;	! Declare external registers


IF CLI$GET_VALUE(.Q_DESC, .Q_VALUE_DESC)
THEN
    BEGIN
    IF
	BEGIN
	IF NOT LIB$CVT_DTB(
	    .Q_VALUE_DESC[DSC$W_LENGTH], .Q_VALUE_DESC[DSC$A_POINTER],
	    .Q_DCURSOR)
	THEN
	    TRUE
	ELSE
	    .Q_DCURSOR[0,0,32,0] - 1 GTRU 255 - 1	! 1 <= N <= 255
	END
    THEN
	SIGNAL_STOP(.Q_MESSAGE, 2, .Q_VALUE_DESC, .Q_DESC);


    Q_ICURSOR[0,0,16,0] = 4;
    Q_ICURSOR[2,0,16,0] = .Q_P1;
    Q_ICURSOR[4,0,32,0] = .Q_DCURSOR;
    Q_ICURSOR[8,0,32,0] = 0;
    Q_ICURSOR = .Q_ICURSOR + 12;
    Q_DCURSOR = .Q_DCURSOR + 4;
    END;
END;

GLOBAL ROUTINE PARSE_CPUTIME(PARSE_PARAMETERS_): PARSE_LINKAGE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine parses the /CPUTIME qualifier, making an entry in
!	the job controller parameter list.
!
! INPUT PARAMETERS:
!	Standard parser parameters.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
PARSE_EXTERNAL_REGISTERS;	! Declare external registers


IF CLI$GET_VALUE(.Q_DESC, .Q_VALUE_DESC)
THEN
    BEGIN
    LOCAL
	TIME_VALUE:	VECTOR[2],
	REMAINDER;


    IF CALL_TPARSE(.Q_VALUE_DESC, NONE_STATES, NONE_KEYS)
    THEN
	BEGIN
	Q_ICURSOR[0,0,16,0] = 0;
	Q_ICURSOR[2,0,16,0] = .Q_P2;
	Q_ICURSOR[4,0,32,0] = 0;
	Q_ICURSOR[8,0,32,0] = 0;
	Q_ICURSOR = .Q_ICURSOR + 12;
	END
    ELSE IF CALL_TPARSE(.Q_VALUE_DESC, INFI_STATES, INFI_KEYS)
    THEN
	BEGIN
	Q_ICURSOR[0,0,16,0] = 4;
	Q_ICURSOR[2,0,16,0] = .Q_P1;
	Q_ICURSOR[4,0,32,0] = LITERAL_ZERO;
	Q_ICURSOR[8,0,32,0] = 0;
	Q_ICURSOR = .Q_ICURSOR + 12;
	END
    ELSE
	BEGIN
	IF
	    BEGIN
	    IF NOT LIB$CVT_DTIME(.Q_VALUE_DESC, TIME_VALUE)
	    THEN
		TRUE
	    ELSE
		(EDIV(%REF(-200000), TIME_VALUE, .Q_DCURSOR, REMAINDER) AND PSL$M_V) NEQ 0
	    END
	THEN
	    SIGNAL_STOP(.Q_MESSAGE, 2, .Q_VALUE_DESC, .Q_DESC);


	Q_DCURSOR[0,0,32,0] = .Q_DCURSOR[0,0,32,0] ^ 1;
	IF .REMAINDER NEQ 0 THEN Q_DCURSOR[0,0,32,0] = .Q_DCURSOR[0,0,32,0] + 1;
	Q_ICURSOR[0,0,16,0] = 4;
	Q_ICURSOR[2,0,16,0] = .Q_P1;
	Q_ICURSOR[4,0,32,0] = .Q_DCURSOR;
	Q_ICURSOR[8,0,32,0] = 0;
	Q_ICURSOR = .Q_ICURSOR + 12;
	Q_DCURSOR = .Q_DCURSOR + 4;
	END;	
    END;
END;

GLOBAL ROUTINE PARSE_ENTRY(PARSE_PARAMETERS_): PARSE_LINKAGE_VALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine parses the /ENTRY qualifier, making an entry in
!	the job controller parameter list.
!
! INPUT PARAMETERS:
!	Standard parser parameters.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	As returned from CLI$GET_VALUE.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
PARSE_EXTERNAL_REGISTERS;	! Declare external registers
LOCAL
	STATUS;


STATUS = CLI$GET_VALUE(.Q_DESC, .Q_VALUE_DESC);
IF .STATUS
THEN
    BEGIN
    IF NOT LIB$CVT_DTB(
	.Q_VALUE_DESC[DSC$W_LENGTH], .Q_VALUE_DESC[DSC$A_POINTER],
	.Q_DCURSOR)
    THEN
	SIGNAL_STOP(.Q_MESSAGE, 2, .Q_VALUE_DESC, .Q_DESC);


    Q_ICURSOR[0,0,16,0] = 4;
    Q_ICURSOR[2,0,16,0] = SJC$_ENTRY_NUMBER;
    Q_ICURSOR[4,0,32,0] = .Q_DCURSOR;
    Q_ICURSOR[8,0,32,0] = 0;
    Q_ICURSOR = .Q_ICURSOR + 12;
    Q_DCURSOR = .Q_DCURSOR + 4;
    END;


.STATUS
END;

GLOBAL ROUTINE PARSE_EXTEND_QUANTITY(PARSE_PARAMETERS_): PARSE_LINKAGE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine parses the /EXTEND_QUANTITY qualifier, making an entry in
!	the job controller parameter list.
!
! INPUT PARAMETERS:
!	Standard parser parameters.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
PARSE_EXTERNAL_REGISTERS;	! Declare external registers


IF CLI$GET_VALUE(.Q_DESC, .Q_VALUE_DESC)
THEN
    BEGIN
    IF
	BEGIN
	IF NOT LIB$CVT_DTB(
	    .Q_VALUE_DESC[DSC$W_LENGTH], .Q_VALUE_DESC[DSC$A_POINTER],
	    .Q_DCURSOR)
	THEN
	    TRUE
	ELSE
	    .Q_DCURSOR[0,0,32,0] GTRU 65535	! 0 <= N <= 65535
	END
    THEN
	SIGNAL_STOP(.Q_MESSAGE, 2, .Q_VALUE_DESC, .Q_DESC);


    Q_ICURSOR[0,0,16,0] = 4;
    Q_ICURSOR[2,0,16,0] = SJC$_EXTEND_QUANTITY;
    Q_ICURSOR[4,0,32,0] = .Q_DCURSOR;
    Q_ICURSOR[8,0,32,0] = 0;
    Q_ICURSOR = .Q_ICURSOR + 12;
    Q_DCURSOR = .Q_DCURSOR + 4;
    END;
END;

GLOBAL ROUTINE PARSE_FILENAME(PARSE_PARAMETERS_): PARSE_LINKAGE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine parses a qualifier whose value is a file name, making an
!	entry in the job controller parameter list.
!
! INPUT PARAMETERS:
!	Standard parser parameters.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
PARSE_EXTERNAL_REGISTERS;	! Declare external registers
LOCAL
	STATUS;


STATUS = CLI$PRESENT(.Q_DESC);
IF .STATUS
THEN
    BEGIN
    CLI$GET_VALUE(.Q_DESC, .Q_VALUE_DESC);
    IF .Q_VALUE_DESC[DSC$W_LENGTH] - 1 GTRU 39 - 1		! 1 <= N <= 39
    THEN
	SIGNAL_STOP(.Q_MESSAGE, 2, .Q_VALUE_DESC, .Q_DESC);


    Q_ICURSOR[0,0,16,0] = .Q_VALUE_DESC[DSC$W_LENGTH];
    Q_ICURSOR[2,0,16,0] = .Q_P1;
    Q_ICURSOR[4,0,32,0] = .Q_DCURSOR;
    Q_ICURSOR[8,0,32,0] = 0;
    Q_ICURSOR = .Q_ICURSOR + 12;
    Q_DCURSOR = CH$MOVE(
	.Q_VALUE_DESC[DSC$W_LENGTH],
	.Q_VALUE_DESC[DSC$A_POINTER],
	.Q_DCURSOR);
    END;
IF .STATUS EQL CLI$_NEGATED OR .STATUS EQL CLI$_LOCNEG
THEN
    BEGIN
    Q_ICURSOR[0,0,16,0] = 0;
    Q_ICURSOR[2,0,16,0] = .Q_P2;
    Q_ICURSOR[4,0,32,0] = 0;
    Q_ICURSOR[8,0,32,0] = 0;
    Q_ICURSOR = .Q_ICURSOR + 12;
    END;
END;

GLOBAL ROUTINE PARSE_FORM(PARSE_PARAMETERS_): PARSE_LINKAGE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine parses the /FORM qualifier, making an entry in
!	the job controller parameter list.
!
! INPUT PARAMETERS:
!	Standard parser parameters.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
PARSE_EXTERNAL_REGISTERS;	! Declare external registers


IF CLI$GET_VALUE(.Q_DESC, .Q_VALUE_DESC)
THEN
    BEGIN
    IF LIB$CVT_DTB(
	.Q_VALUE_DESC[DSC$W_LENGTH], .Q_VALUE_DESC[DSC$A_POINTER],
	.Q_DCURSOR)
    THEN
	BEGIN
	Q_ICURSOR[0,0,16,0] = 4;
	Q_ICURSOR[2,0,16,0] = SJC$_FORM_NUMBER;
	Q_ICURSOR[4,0,32,0] = .Q_DCURSOR;
	Q_ICURSOR[8,0,32,0] = 0;
	Q_ICURSOR = .Q_ICURSOR + 12;
	Q_DCURSOR = .Q_DCURSOR + 4;
	END
    ELSE IF CALL_TPARSE(.Q_VALUE_DESC, SYMB_STATES, SYMB_KEYS)
    THEN
	BEGIN
	Q_ICURSOR[0,0,16,0] = .Q_VALUE_DESC[DSC$W_LENGTH];
	Q_ICURSOR[2,0,16,0] = SJC$_FORM_NAME;
	Q_ICURSOR[4,0,32,0] = .Q_DCURSOR;
	Q_ICURSOR[8,0,32,0] = 0;
	Q_ICURSOR = .Q_ICURSOR + 12;
	Q_DCURSOR = CH$MOVE(
	    .Q_VALUE_DESC[DSC$W_LENGTH],
	    .Q_VALUE_DESC[DSC$A_POINTER],
	    .Q_DCURSOR);
	END
    ELSE
	SIGNAL_STOP(.Q_MESSAGE, 2, .Q_VALUE_DESC, .Q_DESC);
    END;
END;

GLOBAL ROUTINE PARSE_FORWARD(PARSE_PARAMETERS_): PARSE_LINKAGE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine parses the /FORWARD qualifier, making an entry in the
!	job controller parameter list.
!
! INPUT PARAMETERS:
!	Standard parser parameters.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
PARSE_EXTERNAL_REGISTERS;	! Declare external registers


IF CLI$PRESENT(.Q_DESC)
THEN
    BEGIN
    IF CLI$GET_VALUE(.Q_DESC, .Q_VALUE_DESC)
    THEN
	BEGIN
	IF
	    BEGIN
	    IF NOT LIB$CVT_DTB(
		.Q_VALUE_DESC[DSC$W_LENGTH], .Q_VALUE_DESC[DSC$A_POINTER],
		.Q_DCURSOR)
	    THEN
		TRUE
	    ELSE
		.Q_DCURSOR[0,0,32,0] EQL 0
	    END
	THEN
	    SIGNAL_STOP(.Q_MESSAGE, 2, .Q_VALUE_DESC, .Q_DESC);


	Q_ICURSOR[0,0,16,0] = 4;
	Q_ICURSOR[2,0,16,0] = SJC$_RELATIVE_PAGE;
	Q_ICURSOR[4,0,32,0] = .Q_DCURSOR;
	Q_ICURSOR[8,0,32,0] = 0;
	Q_ICURSOR = .Q_ICURSOR + 12;
	Q_DCURSOR = .Q_DCURSOR + 4;
	END
    ELSE
	BEGIN
	Q_ICURSOR[0,0,16,0] = 4;
	Q_ICURSOR[2,0,16,0] = SJC$_RELATIVE_PAGE;
	Q_ICURSOR[4,0,32,0] = LITERAL_ONE;
	Q_ICURSOR[8,0,32,0] = 0;
	Q_ICURSOR = .Q_ICURSOR + 12;
	END;
    END;
END;

GLOBAL ROUTINE PARSE_GENERIC(PARSE_PARAMETERS_): PARSE_LINKAGE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine parses the /GENERIC qualifier, making an entry in
!	the job controller parameter list.
!
! INPUT PARAMETERS:
!	Standard parser parameters.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
PARSE_EXTERNAL_REGISTERS;	! Declare external registers
LOCAL
	STATUS;


STATUS = CLI$PRESENT(.Q_DESC);
IF .STATUS
THEN
    BEGIN
    Q_ICURSOR[0,0,16,0] = 0;
    Q_ICURSOR[2,0,16,0] = SJC$_GENERIC_QUEUE;
    Q_ICURSOR[4,0,32,0] = 0;
    Q_ICURSOR[8,0,32,0] = 0;
    Q_ICURSOR = .Q_ICURSOR + 12;


    WHILE CLI$GET_VALUE(.Q_DESC, .Q_VALUE_DESC) DO
	BEGIN
	Q_ICURSOR[0,0,16,0] = .Q_VALUE_DESC[DSC$W_LENGTH];
	Q_ICURSOR[2,0,16,0] = SJC$_GENERIC_TARGET;
	Q_ICURSOR[4,0,32,0] = .Q_DCURSOR;
	Q_ICURSOR[8,0,32,0] = 0;
	Q_ICURSOR = .Q_ICURSOR + 12;
	Q_DCURSOR = CH$MOVE(
	    .Q_VALUE_DESC[DSC$W_LENGTH],
	    .Q_VALUE_DESC[DSC$A_POINTER],
	    .Q_DCURSOR);
	END;
    END;


IF .STATUS EQL CLI$_NEGATED OR .STATUS EQL CLI$_LOCNEG
THEN
    BEGIN
    Q_ICURSOR[0,0,16,0] = 0;
    Q_ICURSOR[2,0,16,0] = SJC$_NO_GENERIC_QUEUE;
    Q_ICURSOR[4,0,32,0] = 0;
    Q_ICURSOR[8,0,32,0] = 0;
    Q_ICURSOR = .Q_ICURSOR + 12;
    END;
END;

GLOBAL ROUTINE PARSE_JOB_LIMIT(PARSE_PARAMETERS_): PARSE_LINKAGE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine parses the /JOB_LIMIT qualifier, making an entry in
!	the job controller parameter list.
!
! INPUT PARAMETERS:
!	Standard parser parameters.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
PARSE_EXTERNAL_REGISTERS;	! Declare external registers


IF CLI$GET_VALUE(.Q_DESC, .Q_VALUE_DESC)
THEN
    BEGIN
    IF
	BEGIN
	IF NOT LIB$CVT_DTB(
	    .Q_VALUE_DESC[DSC$W_LENGTH], .Q_VALUE_DESC[DSC$A_POINTER],
	    .Q_DCURSOR)
	THEN
	    TRUE
	ELSE
	    .Q_DCURSOR[0,0,32,0] - 1 GTRU 255 - 1	! 1 <= N <= 255
	END
    THEN
	SIGNAL_STOP(.Q_MESSAGE, 2, .Q_VALUE_DESC, .Q_DESC);


    Q_ICURSOR[0,0,16,0] = 4;
    Q_ICURSOR[2,0,16,0] = SJC$_JOB_LIMIT;
    Q_ICURSOR[4,0,32,0] = .Q_DCURSOR;
    Q_ICURSOR[8,0,32,0] = 0;
    Q_ICURSOR = .Q_ICURSOR + 12;
    Q_DCURSOR = .Q_DCURSOR + 4;
    END;
END;

GLOBAL ROUTINE PARSE_LOG_FILE(PARSE_PARAMETERS_): PARSE_LINKAGE_VALUE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine parses the /LOG_FILE qualifier, making an entry
!	in the job controller parameter list.
!
! INPUT PARAMETERS:
!	Standard parser parameters.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	True if /NOLOG specified.
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
PARSE_EXTERNAL_REGISTERS;	! Declare external registers
LOCAL
	STATUS;


STATUS = CLI$PRESENT(.Q_DESC);
IF .STATUS
THEN
    BEGIN
    CLI$GET_VALUE(.Q_DESC, .Q_VALUE_DESC);
    END;
IF .STATUS EQL CLI$_NEGATED OR .STATUS EQL CLI$_LOCNEG
THEN
    BEGIN
    Q_ICURSOR[0,0,16,0] = 0;
    Q_ICURSOR[2,0,16,0] = SJC$_NO_LOG_SPECIFICATION;
    Q_ICURSOR[4,0,32,0] = 0;
    Q_ICURSOR[8,0,32,0] = 0;
    Q_ICURSOR = .Q_ICURSOR + 12;
    RETURN TRUE;
    END;
FALSE
END;

GLOBAL ROUTINE PARSE_LOWER_UPPER(PARSE_PARAMETERS_): PARSE_LINKAGE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine parses a qualifier of the form:
!		/QUAL=upper
!		/QUAL=(lower,upper)
!		/QUAL=(lower,"")
!	making an entry in the job controller parameter list.
!
! INPUT PARAMETERS:
!	Standard parser parameters.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
PARSE_EXTERNAL_REGISTERS;	! Declare external registers
LOCAL
	STATUS,
	LOWER_LIMIT,
	UPPER_LIMIT;


IF CLI$PRESENT(.Q_DESC)
THEN
    BEGIN
    LOWER_LIMIT = 0;
    UPPER_LIMIT = 0;


    ! Get the first value.
    !
    STATUS = CLI$GET_VALUE(.Q_DESC, .Q_VALUE_DESC);
    IF .Q_VALUE_DESC[DSC$W_LENGTH] NEQ 0
    THEN
	BEGIN
	IF
	    BEGIN
	    IF NOT LIB$CVT_DTB(
		.Q_VALUE_DESC[DSC$W_LENGTH], .Q_VALUE_DESC[DSC$A_POINTER],
		UPPER_LIMIT)
	    THEN
		TRUE
	    ELSE
		.UPPER_LIMIT EQL 0
	    END
	THEN
	    SIGNAL_STOP(.Q_MESSAGE, 2, .Q_VALUE_DESC, .Q_DESC);
	END;


    ! Get the second value, if it exists.
    !
    IF .STATUS EQL CLI$_COMMA
    THEN
	BEGIN
	LOWER_LIMIT = .UPPER_LIMIT;
	UPPER_LIMIT = 0;
	CLI$GET_VALUE(.Q_DESC, .Q_VALUE_DESC);
	IF .Q_VALUE_DESC[DSC$W_LENGTH] NEQ 0
	THEN
	    BEGIN
	    IF
		BEGIN
		IF NOT LIB$CVT_DTB(
		    .Q_VALUE_DESC[DSC$W_LENGTH], .Q_VALUE_DESC[DSC$A_POINTER],
		    UPPER_LIMIT)
		THEN
		    TRUE
		ELSE
		    .UPPER_LIMIT EQL 0
		END
	    THEN
		SIGNAL_STOP(.Q_MESSAGE, 2, .Q_VALUE_DESC, .Q_DESC);
	    END;
	END;


    IF .LOWER_LIMIT NEQ 0
    THEN
	BEGIN
	Q_ICURSOR[0,0,16,0] = 4;
	Q_ICURSOR[2,0,16,0] = .Q_P1;
	Q_ICURSOR[4,0,32,0] = .Q_DCURSOR;
	Q_ICURSOR[8,0,32,0] = 0;
	Q_ICURSOR = .Q_ICURSOR + 12;
	.Q_DCURSOR = .LOWER_LIMIT;
	Q_DCURSOR = .Q_DCURSOR + 4;
	END
    ELSE
	BEGIN
	Q_ICURSOR[0,0,16,0] = 0;
	Q_ICURSOR[2,0,16,0] = .Q_P2;
	Q_ICURSOR[4,0,32,0] = 0;
	Q_ICURSOR[8,0,32,0] = 0;
	Q_ICURSOR = .Q_ICURSOR + 12;
	END;


    IF .UPPER_LIMIT NEQ 0
    THEN
	BEGIN
	Q_ICURSOR[0,0,16,0] = 4;
	Q_ICURSOR[2,0,16,0] = .Q_P3;
	Q_ICURSOR[4,0,32,0] = .Q_DCURSOR;
	Q_ICURSOR[8,0,32,0] = 0;
	Q_ICURSOR = .Q_ICURSOR + 12;
	.Q_DCURSOR = .UPPER_LIMIT;
	Q_DCURSOR = .Q_DCURSOR + 4;
	END
    ELSE
	BEGIN
	Q_ICURSOR[0,0,16,0] = 0;
	Q_ICURSOR[2,0,16,0] = .Q_P4;
	Q_ICURSOR[4,0,32,0] = 0;
	Q_ICURSOR[8,0,32,0] = 0;
	Q_ICURSOR = .Q_ICURSOR + 12;
	END;


    ! Try to get another value, to ensure there are not three.
    !
    IF CLI$GET_VALUE(.Q_DESC, .Q_VALUE_DESC)
    THEN
	SIGNAL_STOP(.Q_MESSAGE, 2, .Q_VALUE_DESC, .Q_DESC);
    END;
END;

GLOBAL ROUTINE PARSE_NAME(PARSE_PARAMETERS_): PARSE_LINKAGE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine parses the /NAME qualifier, making an entry in the job
!	controller parameter list.
!
! INPUT PARAMETERS:
!	Standard parser parameters.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
PARSE_EXTERNAL_REGISTERS;	! Declare external registers


IF CLI$GET_VALUE(.Q_DESC, .Q_VALUE_DESC)
THEN
    BEGIN
    IF .Q_VALUE_DESC[DSC$W_LENGTH] GTRU 39		! 0 <= N <= 39
    THEN
	SIGNAL_STOP(.Q_MESSAGE, 2, .Q_VALUE_DESC, .Q_DESC);


    Q_ICURSOR[0,0,16,0] = .Q_VALUE_DESC[DSC$W_LENGTH];
    Q_ICURSOR[2,0,16,0] = SJC$_JOB_NAME;
    Q_ICURSOR[4,0,32,0] = .Q_DCURSOR;
    Q_ICURSOR[8,0,32,0] = 0;
    Q_ICURSOR = .Q_ICURSOR + 12;
    Q_DCURSOR = CH$MOVE(
	.Q_VALUE_DESC[DSC$W_LENGTH],
	.Q_VALUE_DESC[DSC$A_POINTER],
	.Q_DCURSOR);
    END;
END;

GLOBAL ROUTINE PARSE_NAME_AND_LOG_FILE(NAME_DESC,LOG_FILE_DESC,DNA_DESC,MESSAGE): PARSE_LINKAGE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine finishes processing of the /NAME and /LOG_FILE qualifiers,
!	making entries in the job controller parameter list.
!
! INPUT PARAMETERS:
!	NAME_DESC	- Descriptor for the /NAME qualifier.
!	LOG_FILE_DESC	- Descriptor for the /LOG_FILE qualifier.
!	DNA_DESC	- Descriptor for the default filename string.
!	MESSAGE		- 'Invalid log file specification' message.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
MAP
	NAME_DESC:	REF BLOCK[,BYTE],
	LOG_FILE_DESC:	REF BLOCK[,BYTE],
	DNA_DESC:	REF BLOCK[,BYTE];

PARSE_EXTERNAL_REGISTERS;	! Declare external registers

LOCAL
	FAB:		$FAB_DECL,			! FAB for $PARSE
	NAM:		$NAM_DECL,			! NAM for $PARSE
	ESA:		VECTOR[NAM$C_MAXRSS,BYTE],	! Expanded string
	STATUS;


! Initialize RMS structures required to do a $PARSE.
!
$FAB_INIT(FAB=FAB,
    DNA=.DNA_DESC[DSC$A_POINTER],
    DNS=.DNA_DESC[DSC$W_LENGTH],
    NAM=NAM);
$NAM_INIT(NAM=NAM,
    ESA=ESA,
    ESS=NAM$C_MAXRSS);
NAM[NAM$V_NOCONCEAL] = TRUE;


! Establish the primary file name.  If the /LOG qualifier was used, it comes
! from that; otherwise, if the /NAME qualifier was used, it comes from that.
! If neither was used, do nothing, and let defaulting to the command file name
! happen.
!
IF .LOG_FILE_DESC[DSC$W_LENGTH] NEQ 0
THEN
    BEGIN
    FAB[FAB$B_FNS] = .LOG_FILE_DESC[DSC$W_LENGTH];
    FAB[FAB$L_FNA] = .LOG_FILE_DESC[DSC$A_POINTER];
    END

ELSE IF .NAME_DESC[DSC$W_LENGTH] NEQ 0
THEN
    BEGIN
    FAB[FAB$B_FNS] = .NAME_DESC[DSC$W_LENGTH];
    FAB[FAB$L_FNA] = .NAME_DESC[DSC$A_POINTER];
    END

ELSE
    RETURN;


! Execute a $PARSE.  Ensure that the device is a disk and that the filespec
! does not contain wildcards.
!
IF NOT $PARSE(FAB=FAB)
THEN
    SIGNAL_STOP(.MESSAGE, 0, .FAB[FAB$L_STS], .FAB[FAB$L_STV]);


IF NOT .BBLOCK[FAB[FAB$L_DEV], DEV$V_RND]
OR .BBLOCK[FAB[FAB$L_DEV], DEV$V_FOR]
THEN
    SIGNAL_STOP(.MESSAGE, 0, RMS$_DEV);


IF .NAM[NAM$V_WILDCARD]
THEN
    SIGNAL_STOP(.MESSAGE, 0, SHR$_NOWILD OR STS$K_ERROR);


! Return the unconcealed expanded string as the log file specification.
!
Q_ICURSOR[0,0,16,0] = .NAM[NAM$B_ESL];
Q_ICURSOR[2,0,16,0] = SJC$_LOG_SPECIFICATION;
Q_ICURSOR[4,0,32,0] = .Q_DCURSOR;
Q_ICURSOR[8,0,32,0] = 0;
Q_ICURSOR = .Q_ICURSOR + 12;
Q_DCURSOR = CH$MOVE(
    .NAM[NAM$B_ESL],
    .NAM[NAM$L_ESA],
    .Q_DCURSOR);
END;

GLOBAL ROUTINE PARSE_NONZERO_NUMBER(PARSE_PARAMETERS_): PARSE_LINKAGE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine parses a qualifier with an arbitrary nonzero numeric value,
!	making an entry in the job controller parameter list.
!
! INPUT PARAMETERS:
!	Standard parser parameters.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
PARSE_EXTERNAL_REGISTERS;	! Declare external registers


IF CLI$GET_VALUE(.Q_DESC, .Q_VALUE_DESC)
THEN
    BEGIN
    IF
	BEGIN
	IF NOT LIB$CVT_DTB(
	    .Q_VALUE_DESC[DSC$W_LENGTH], .Q_VALUE_DESC[DSC$A_POINTER],
	    .Q_DCURSOR)
	THEN
	    TRUE
	ELSE
	    .Q_DCURSOR[0,0,32,0] EQL 0
	END
    THEN
	SIGNAL_STOP(.Q_MESSAGE, 2, .Q_VALUE_DESC, .Q_DESC);


    Q_ICURSOR[0,0,16,0] = 4;
    Q_ICURSOR[2,0,16,0] = .Q_P1;
    Q_ICURSOR[4,0,32,0] = .Q_DCURSOR;
    Q_ICURSOR[8,0,32,0] = 0;
    Q_ICURSOR = .Q_ICURSOR + 12;
    Q_DCURSOR = .Q_DCURSOR + 4;
    END;
END;

GLOBAL ROUTINE PARSE_NUMBER(PARSE_PARAMETERS_): PARSE_LINKAGE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine parses a qualifier with an arbitrary numeric value,
!	making an entry in the job controller parameter list.
!
! INPUT PARAMETERS:
!	Standard parser parameters.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
PARSE_EXTERNAL_REGISTERS;	! Declare external registers


IF CLI$GET_VALUE(.Q_DESC, .Q_VALUE_DESC)
THEN
    BEGIN
    IF NOT LIB$CVT_DTB(
	.Q_VALUE_DESC[DSC$W_LENGTH], .Q_VALUE_DESC[DSC$A_POINTER],
	.Q_DCURSOR)
    THEN
	SIGNAL_STOP(.Q_MESSAGE, 2, .Q_VALUE_DESC, .Q_DESC);


    Q_ICURSOR[0,0,16,0] = 4;
    Q_ICURSOR[2,0,16,0] = .Q_P1;
    Q_ICURSOR[4,0,32,0] = .Q_DCURSOR;
    Q_ICURSOR[8,0,32,0] = 0;
    Q_ICURSOR = .Q_ICURSOR + 12;
    Q_DCURSOR = .Q_DCURSOR + 4;
    END;
END;

GLOBAL ROUTINE PARSE_OBJECT_NAME(PARSE_PARAMETERS_): PARSE_LINKAGE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine parses an object name, making an entry in
!	the job controller parameter list.
!
! INPUT PARAMETERS:
!	Standard parser parameters.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
PARSE_EXTERNAL_REGISTERS;	! Declare external registers


IF CLI$GET_VALUE(.Q_DESC, .Q_VALUE_DESC)
THEN
    BEGIN
    IF
	BEGIN
	IF NOT CALL_TPARSE(.Q_VALUE_DESC, SYMB_STATES, SYMB_KEYS)
	THEN
	    TRUE
	ELSE
	    .Q_VALUE_DESC[DSC$W_LENGTH] - 1 GTRU 31 - 1	! 1 <= N <= 31
	END
    THEN
	SIGNAL_STOP(.Q_MESSAGE, 2, .Q_VALUE_DESC, .Q_DESC);


    Q_ICURSOR[0,0,16,0] = .Q_VALUE_DESC[DSC$W_LENGTH];
    Q_ICURSOR[2,0,16,0] = .Q_P1;
    Q_ICURSOR[4,0,32,0] = .Q_DCURSOR;
    Q_ICURSOR[8,0,32,0] = 0;
    Q_ICURSOR = .Q_ICURSOR + 12;
    Q_DCURSOR = CH$MOVE(
	.Q_VALUE_DESC[DSC$W_LENGTH],
	.Q_VALUE_DESC[DSC$A_POINTER],
	.Q_DCURSOR);
    END;
END;

GLOBAL ROUTINE PARSE_ON(PARSE_PARAMETERS_): PARSE_LINKAGE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine parses the /ON qualifier, making an entry in the
!	job controller parameter list.
!
! INPUT PARAMETERS:
!	Standard parser parameters.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
PARSE_EXTERNAL_REGISTERS;	! Declare external registers


IF CLI$GET_VALUE(.Q_DESC, .Q_VALUE_DESC)
THEN
    BEGIN
    LOCAL
	LEN,
	ADDR:		REF VECTOR[,BYTE],
	P;
    BUILTIN
	MATCHC;


    LEN = .Q_VALUE_DESC[DSC$W_LENGTH];
    ADDR = .Q_VALUE_DESC[DSC$A_POINTER];
    IF MATCHC(%REF(2), UPLIT BYTE ('::'), LEN, .ADDR; ,,, P)
    THEN
	BEGIN
	LOCAL
	    NODE_LEN;

	NODE_LEN = .P - .ADDR - 2;
	IF .NODE_LEN GTRU 6
	THEN
	    SIGNAL_STOP(.Q_MESSAGE, 2, .Q_VALUE_DESC, .Q_DESC);


	Q_ICURSOR[0,0,16,0] = 6;
	Q_ICURSOR[2,0,16,0] = SJC$_SCSNODE_NAME;
	Q_ICURSOR[4,0,32,0] = .Q_DCURSOR;
	Q_ICURSOR[8,0,32,0] = 0;
	Q_ICURSOR = .Q_ICURSOR + 12;
	Q_DCURSOR = CH$COPY(.NODE_LEN, .ADDR, %C' ', 6, .Q_DCURSOR);


	LEN = .ADDR + .LEN - .P;
	ADDR = .P;
	END;


    IF .LEN NEQ 0
    THEN
	BEGIN
	IF .LEN GTRU 31
	THEN
	    SIGNAL_STOP(.Q_MESSAGE, 2, .Q_VALUE_DESC, .Q_DESC);


	Q_ICURSOR[0,0,16,0] = .LEN;
	Q_ICURSOR[2,0,16,0] = SJC$_DEVICE_NAME;
	Q_ICURSOR[4,0,32,0] = .Q_DCURSOR;
	Q_ICURSOR[8,0,32,0] = 0;
	Q_ICURSOR = .Q_ICURSOR + 12;
	Q_DCURSOR = CH$MOVE(
	    .LEN,
	    .ADDR,
	    .Q_DCURSOR);
	END;
    END;
END;

GLOBAL ROUTINE PARSE_OWNER(PARSE_PARAMETERS_): PARSE_LINKAGE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine parses the /OWNER qualifier, making an entry in
!	the job controller parameter list.
!
! INPUT PARAMETERS:
!	Standard parser parameters.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
PARSE_EXTERNAL_REGISTERS;	! Declare external registers


IF CLI$GET_VALUE(.Q_DESC, .Q_VALUE_DESC)
THEN
    BEGIN
    CONVERTED_UIC = 0;
    IF NOT CALL_TPARSE(.Q_VALUE_DESC, OWNE_STATES, OWNE_KEYS)
    THEN
	SIGNAL_STOP(.Q_MESSAGE, 2, .Q_VALUE_DESC, .Q_DESC);


    Q_ICURSOR[0,0,16,0] = 4;
    Q_ICURSOR[2,0,16,0] = SJC$_OWNER_UIC;
    Q_ICURSOR[4,0,32,0] = .Q_DCURSOR;
    Q_ICURSOR[8,0,32,0] = 0;
    Q_ICURSOR = .Q_ICURSOR + 12;
    Q_DCURSOR[0,0,32,0] = .CONVERTED_UIC;
    Q_DCURSOR = .Q_DCURSOR + 4;
    END;
END;

GLOBAL ROUTINE PARSE_PARAMETERS(PARSE_PARAMETERS_): PARSE_LINKAGE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine parses the /PARAMETERS qualifier, making an entry in the
!	job controller parameter list.
!
! INPUT PARAMETERS:
!	Standard parser parameters.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
PARSE_EXTERNAL_REGISTERS;	! Declare external registers
LOCAL
	STATUS;


STATUS = CLI$PRESENT(.Q_DESC);
IF .STATUS
THEN
    BEGIN
    LOCAL
	PARAM_COUNT;


    PARAM_COUNT = 0;
    WHILE CLI$GET_VALUE(.Q_DESC, .Q_VALUE_DESC) DO
	BEGIN
	IF .PARAM_COUNT GTRU 7
	OR .Q_VALUE_DESC[DSC$W_LENGTH] GTRU 255		! 0 <= N <= 255
	THEN
	    SIGNAL_STOP(.Q_MESSAGE, 2, .Q_VALUE_DESC, .Q_DESC);


	Q_ICURSOR[0,0,16,0] = .Q_VALUE_DESC[DSC$W_LENGTH];
	Q_ICURSOR[2,0,16,0] = SJC$_PARAMETER_1 + .PARAM_COUNT;
	Q_ICURSOR[4,0,32,0] = .Q_DCURSOR;
	Q_ICURSOR[8,0,32,0] = 0;
	Q_ICURSOR = .Q_ICURSOR + 12;
	Q_DCURSOR = CH$MOVE(
	    .Q_VALUE_DESC[DSC$W_LENGTH],
	    .Q_VALUE_DESC[DSC$A_POINTER],
	    .Q_DCURSOR);


	PARAM_COUNT = .PARAM_COUNT + 1;
	END;
    END;
IF .STATUS EQL CLI$_NEGATED OR .STATUS EQL CLI$_LOCNEG
THEN
    BEGIN
    Q_ICURSOR[0,0,16,0] = 0;
    Q_ICURSOR[2,0,16,0] = SJC$_NO_PARAMETERS;
    Q_ICURSOR[4,0,32,0] = 0;
    Q_ICURSOR[8,0,32,0] = 0;
    Q_ICURSOR = .Q_ICURSOR + 12;
    END;
END;

GLOBAL ROUTINE PARSE_PRINTER(PARSE_PARAMETERS_): PARSE_LINKAGE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine parses the /PRINTER qualifier, making an entry in the job
!	controller parameter list.
!
! INPUT PARAMETERS:
!	Standard parser parameters.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
PARSE_EXTERNAL_REGISTERS;	! Declare external registers
LOCAL
	STATUS;


STATUS = CLI$PRESENT(.Q_DESC);
IF .STATUS
THEN
    BEGIN
    CLI$GET_VALUE(.Q_DESC, .Q_VALUE_DESC);
    Q_ICURSOR[0,0,16,0] = .Q_VALUE_DESC[DSC$W_LENGTH];
    Q_ICURSOR[2,0,16,0] = SJC$_LOG_QUEUE;
    Q_ICURSOR[4,0,32,0] = .Q_DCURSOR;
    Q_ICURSOR[8,0,32,0] = 0;
    Q_ICURSOR = .Q_ICURSOR + 12;
    Q_DCURSOR = CH$MOVE(
	.Q_VALUE_DESC[DSC$W_LENGTH],
	.Q_VALUE_DESC[DSC$A_POINTER],
	.Q_DCURSOR);
    END;
IF .STATUS EQL CLI$_NEGATED OR .STATUS EQL CLI$_LOCNEG
THEN
    BEGIN
    Q_ICURSOR[0,0,16,0] = 0;
    Q_ICURSOR[2,0,16,0] = SJC$_NO_LOG_SPOOL;
    Q_ICURSOR[4,0,32,0] = 0;
    Q_ICURSOR[8,0,32,0] = 0;
    Q_ICURSOR = .Q_ICURSOR + 12;
    END;
END;

GLOBAL ROUTINE PARSE_PRIORITY(PARSE_PARAMETERS_): PARSE_LINKAGE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine parses the /PRIORITY qualifier, making an entry in the job
!	controller parameter list.
!
! INPUT PARAMETERS:
!	Standard parser parameters.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
PARSE_EXTERNAL_REGISTERS;	! Declare external registers


IF CLI$GET_VALUE(.Q_DESC, .Q_VALUE_DESC)
THEN
    BEGIN
    IF
	BEGIN
	IF NOT LIB$CVT_DTB(
	    .Q_VALUE_DESC[DSC$W_LENGTH], .Q_VALUE_DESC[DSC$A_POINTER],
	    .Q_DCURSOR)
	THEN
	    TRUE
	ELSE
	    .Q_DCURSOR[0,0,32,0] GTRU 255	! 0 <= N <= 255
	END
    THEN
	SIGNAL_STOP(.Q_MESSAGE, 2, .Q_VALUE_DESC, .Q_DESC);


    Q_ICURSOR[0,0,16,0] = 4;
    Q_ICURSOR[2,0,16,0] = SJC$_PRIORITY;
    Q_ICURSOR[4,0,32,0] = .Q_DCURSOR;
    Q_ICURSOR[8,0,32,0] = 0;
    Q_ICURSOR = .Q_ICURSOR + 12;
    Q_DCURSOR = .Q_DCURSOR + 4;
    END;
END;

GLOBAL ROUTINE PARSE_PROTECTION(PARSE_PARAMETERS_): PARSE_LINKAGE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine parses the /PROTECTION qualifier, making an entry in
!	the job controller parameter list.
!
! INPUT PARAMETERS:
!	Standard parser parameters.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
PARSE_EXTERNAL_REGISTERS;	! Declare external registers


IF CLI$PRESENT(.Q_DESC)
THEN
    BEGIN
    TPA_1 = 0;
    WHILE CLI$GET_VALUE(.Q_DESC, .Q_VALUE_DESC) DO
	BEGIN
	IF NOT CALL_TPARSE(.Q_VALUE_DESC, PROT_STATES, PROT_KEYS)
	THEN
	    SIGNAL_STOP(.Q_MESSAGE, 2, .Q_VALUE_DESC, .Q_DESC);
	END;


    Q_ICURSOR[0,0,16,0] = 4;
    Q_ICURSOR[2,0,16,0] = SJC$_PROTECTION;
    Q_ICURSOR[4,0,32,0] = .Q_DCURSOR;
    Q_ICURSOR[8,0,32,0] = 0;
    Q_ICURSOR = .Q_ICURSOR + 12;
    Q_DCURSOR[0,0,16,0] = NOT .TPA_1<0,16>;
    Q_DCURSOR[2,0,16,0] = .TPA_1<16,16>;
    Q_DCURSOR = .Q_DCURSOR + 4;
    END;
END;

GLOBAL ROUTINE PARSE_QUEUE(PARSE_PARAMETERS_): PARSE_LINKAGE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine parses a queue name qualifier, making an entry in the job
!	controller parameter list.
!
! INPUT PARAMETERS:
!	Standard parser parameters.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
PARSE_EXTERNAL_REGISTERS;	! Declare external registers
LOCAL
	DESC:		REF BBLOCK,
	STATUS;
BUILTIN
	ACTUALCOUNT;


DESC = .Q_VALUE_DESC;
IF NOT CLI$GET_VALUE(.Q_DESC, .Q_VALUE_DESC)
THEN
    IF ACTUALCOUNT() GEQU 3
    THEN
	DESC = .Q_P2
    ELSE
	RETURN;


Q_ICURSOR[0,0,16,0] = .DESC[DSC$W_LENGTH];
Q_ICURSOR[2,0,16,0] = .Q_P1;
Q_ICURSOR[4,0,32,0] = .Q_DCURSOR;
Q_ICURSOR[8,0,32,0] = 0;
Q_ICURSOR = .Q_ICURSOR + 12;
Q_DCURSOR = CH$MOVE(
    .DESC[DSC$W_LENGTH],
    .DESC[DSC$A_POINTER],
    .Q_DCURSOR);
END;

GLOBAL ROUTINE PARSE_SEARCH_STRING(PARSE_PARAMETERS_): PARSE_LINKAGE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine parses the value of the /SEARCH qualifier,
!	making an entry in the job controller parameter list.
!
! INPUT PARAMETERS:
!	Standard parser parameters.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
PARSE_EXTERNAL_REGISTERS;	! Declare external registers


IF CLI$GET_VALUE(.Q_DESC, .Q_VALUE_DESC)
THEN
    BEGIN
    IF .Q_VALUE_DESC[DSC$W_LENGTH] GTRU 63
    THEN
	SIGNAL_STOP(.Q_MESSAGE, 2, .Q_VALUE_DESC, .Q_DESC);


    Q_ICURSOR[0,0,16,0] = .Q_VALUE_DESC[DSC$W_LENGTH];
    Q_ICURSOR[2,0,16,0] = .Q_P1;
    Q_ICURSOR[4,0,32,0] = .Q_DCURSOR;
    Q_ICURSOR[8,0,32,0] = 0;
    Q_ICURSOR = .Q_ICURSOR + 12;
    Q_DCURSOR = CH$MOVE(
	.Q_VALUE_DESC[DSC$W_LENGTH],
	.Q_VALUE_DESC[DSC$A_POINTER],
	.Q_DCURSOR);
    END;
END;

GLOBAL ROUTINE PARSE_STRING(PARSE_PARAMETERS_): PARSE_LINKAGE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine parses a qualifier whose value is an arbitrary string,
!	making an entry in the job controller parameter list.
!
! INPUT PARAMETERS:
!	Standard parser parameters.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
PARSE_EXTERNAL_REGISTERS;	! Declare external registers
LOCAL
	STATUS;
BUILTIN
	ACTUALCOUNT;


STATUS = CLI$PRESENT(.Q_DESC);
IF .STATUS
THEN
    BEGIN
    CLI$GET_VALUE(.Q_DESC, .Q_VALUE_DESC);
    Q_ICURSOR[0,0,16,0] = .Q_VALUE_DESC[DSC$W_LENGTH];
    Q_ICURSOR[2,0,16,0] = .Q_P1;
    Q_ICURSOR[4,0,32,0] = .Q_DCURSOR;
    Q_ICURSOR[8,0,32,0] = 0;
    Q_ICURSOR = .Q_ICURSOR + 12;
    Q_DCURSOR = CH$MOVE(
	.Q_VALUE_DESC[DSC$W_LENGTH],
	.Q_VALUE_DESC[DSC$A_POINTER],
	.Q_DCURSOR);
    END;
IF (.STATUS EQL CLI$_NEGATED OR .STATUS EQL CLI$_LOCNEG)
AND ACTUALCOUNT() GEQU 3
THEN
    BEGIN
    Q_ICURSOR[0,0,16,0] = 0;
    Q_ICURSOR[2,0,16,0] = .Q_P2;
    Q_ICURSOR[4,0,32,0] = 0;
    Q_ICURSOR[8,0,32,0] = 0;
    Q_ICURSOR = .Q_ICURSOR + 12;
    END;
END;

GLOBAL ROUTINE PARSE_STRING_255(PARSE_PARAMETERS_): PARSE_LINKAGE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine parses a qualifier whose value is an arbitrary string
!	of up to 255 characters, making an entry in the job controller
!	parameter list.
!
! INPUT PARAMETERS:
!	Standard parser parameters.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
PARSE_EXTERNAL_REGISTERS;	! Declare external registers
LOCAL
	STATUS;
BUILTIN
	ACTUALCOUNT;


STATUS = CLI$PRESENT(.Q_DESC);
IF .STATUS
THEN
    BEGIN
    CLI$GET_VALUE(.Q_DESC, .Q_VALUE_DESC);


    IF .Q_VALUE_DESC[DSC$W_LENGTH] GTRU 255
    THEN
	SIGNAL_STOP(.Q_MESSAGE, 2, .Q_VALUE_DESC, .Q_DESC);


    Q_ICURSOR[0,0,16,0] = .Q_VALUE_DESC[DSC$W_LENGTH];
    Q_ICURSOR[2,0,16,0] = .Q_P1;
    Q_ICURSOR[4,0,32,0] = .Q_DCURSOR;
    Q_ICURSOR[8,0,32,0] = 0;
    Q_ICURSOR = .Q_ICURSOR + 12;
    Q_DCURSOR = CH$MOVE(
	.Q_VALUE_DESC[DSC$W_LENGTH],
	.Q_VALUE_DESC[DSC$A_POINTER],
	.Q_DCURSOR);
    END;
IF (.STATUS EQL CLI$_NEGATED OR .STATUS EQL CLI$_LOCNEG)
AND ACTUALCOUNT() GEQU 3
THEN
    BEGIN
    Q_ICURSOR[0,0,16,0] = 0;
    Q_ICURSOR[2,0,16,0] = .Q_P2;
    Q_ICURSOR[4,0,32,0] = 0;
    Q_ICURSOR[8,0,32,0] = 0;
    Q_ICURSOR = .Q_ICURSOR + 12;
    END;
END;

GLOBAL ROUTINE PARSE_USER(PARSE_PARAMETERS_): PARSE_LINKAGE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine parses the value of the /USER qualifier, making an entry
!	in the job controller parameter list.
!
! INPUT PARAMETERS:
!	Standard parser parameters.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
PARSE_EXTERNAL_REGISTERS;	! Declare external registers
EXTERNAL ROUTINE
	LGI$SEARCHUSER:		WEAK ADDRESSING_MODE(GENERAL);
LOCAL
	UAF_DESC:	VECTOR[2],		! Descriptor for UAF buffer
	UAF_BUFFER:	BBLOCK[UAF$C_LENGTH],	! UAF record for user
	STATUS;


IF CLI$GET_VALUE(.Q_DESC, .Q_VALUE_DESC)
THEN
    BEGIN
    IF .Q_VALUE_DESC[DSC$W_LENGTH] - 1 GTRU 12 - 1	! 1 <= N <= 12
    THEN
	SIGNAL_STOP(.Q_MESSAGE, 2, .Q_VALUE_DESC, .Q_DESC);


    UAF_DESC[0] = %ALLOCATION(UAF_BUFFER);
    UAF_DESC[1] = UAF_BUFFER;
    STATUS = LGI$SEARCHUSER(.Q_VALUE_DESC, 0, UAF_DESC);
    IF NOT .STATUS
    THEN
	IF .STATUS LSS 0
	THEN
	    SIGNAL_STOP(.Q_MESSAGE, 2, .Q_VALUE_DESC, .Q_DESC)
	ELSE
	    SIGNAL_STOP(.Q_MESSAGE, 2, .Q_VALUE_DESC, .Q_DESC, .STATUS);


    Q_ICURSOR[0,0,16,0] = 25;
    Q_ICURSOR[2,0,16,0] = SJC$_USER_IDENTIFICATION;
    Q_ICURSOR[4,0,32,0] = .Q_DCURSOR;
    Q_ICURSOR[8,0,32,0] = 0;
    Q_ICURSOR = .Q_ICURSOR + 12;
    Q_DCURSOR[0,0,32,0] = .UAF_BUFFER[UAF$L_UIC];
    Q_DCURSOR = .Q_DCURSOR + 4;
    Q_DCURSOR = CH$MOVE(
	UAF$S_USERNAME,
	UAF_BUFFER[UAF$T_USERNAME],
	.Q_DCURSOR);
    Q_DCURSOR = CH$MOVE(
	UAF$S_ACCOUNT,
	UAF_BUFFER[UAF$T_ACCOUNT],
	.Q_DCURSOR);
    Q_DCURSOR[0,0,8,0] = .UAF_BUFFER[UAF$B_PRI];
    Q_DCURSOR = .Q_DCURSOR + 1;
    END;
END;

GLOBAL ROUTINE PARSE_WORKING_SET(PARSE_PARAMETERS_): PARSE_LINKAGE=

!++
!
! FUNCTIONAL DESCRIPTION:
!	This routine parses the working set qualifiers, making an entry in the
!	job controller parameter list.
!
! INPUT PARAMETERS:
!	Standard parser parameters.
!
! IMPLICIT INPUTS:
!	NONE
!
! OUTPUT PARAMETERS:
!	NONE
!
! IMPLICIT OUTPUTS:
!	NONE
!
! ROUTINE VALUE:
!	NONE
!
! SIDE EFFECTS:
!	NONE
!
!--

BEGIN
PARSE_EXTERNAL_REGISTERS;	! Declare external registers


IF CLI$GET_VALUE(.Q_DESC, .Q_VALUE_DESC)
THEN
    BEGIN
    IF CALL_TPARSE(.Q_VALUE_DESC, NONE_STATES, NONE_KEYS)
    THEN
	BEGIN
	Q_ICURSOR[0,0,16,0] = 0;
	Q_ICURSOR[2,0,16,0] = .Q_P2;
	Q_ICURSOR[4,0,32,0] = 0;
	Q_ICURSOR[8,0,32,0] = 0;
	Q_ICURSOR = .Q_ICURSOR + 12;
	END
    ELSE
	BEGIN
	IF
	    BEGIN
	    IF NOT LIB$CVT_DTB(
		.Q_VALUE_DESC[DSC$W_LENGTH], .Q_VALUE_DESC[DSC$A_POINTER],
		.Q_DCURSOR)
	    THEN
		TRUE
	    ELSE
		.Q_DCURSOR[0,0,32,0] GTRU 65535		! 0 <= N <= 65535
	    END
	THEN
	    SIGNAL_STOP(.Q_MESSAGE, 2, .Q_VALUE_DESC, .Q_DESC);


	IF .Q_DCURSOR[0,0,32,0] EQL 0
	THEN
	    BEGIN
	    Q_ICURSOR[0,0,16,0] = 0;
	    Q_ICURSOR[2,0,16,0] = .Q_P2;
	    Q_ICURSOR[4,0,32,0] = 0;
	    Q_ICURSOR[8,0,32,0] = 0;
	    Q_ICURSOR = .Q_ICURSOR + 12;
	    END
	ELSE
	    BEGIN
	    Q_ICURSOR[0,0,16,0] = 4;
	    Q_ICURSOR[2,0,16,0] = .Q_P1;
	    Q_ICURSOR[4,0,32,0] = .Q_DCURSOR;
	    Q_ICURSOR[8,0,32,0] = 0;
	    Q_ICURSOR = .Q_ICURSOR + 12;
	    Q_DCURSOR = .Q_DCURSOR + 4;
	    END;
	END;	
    END;
END;

$INIT_STATE(NONE_STATES, NONE_KEYS);
$STATE( ,
    ('NONE'));
$STATE( ,
    (TPA$_EOS, TPA$_EXIT));


$INIT_STATE(INFI_STATES, INFI_KEYS);
$STATE( ,
    ('INFINITE'));
$STATE( ,
    (TPA$_EOS, TPA$_EXIT));


$INIT_STATE(SYMB_STATES, SYMB_KEYS);
$STATE( ,
    (TPA$_SYMBOL));
$STATE( ,
    (TPA$_EOS, TPA$_EXIT));


$INIT_STATE(MASK_STATES, MASK_KEYS);
$STATE( ,
    ('MASK'));
$STATE( ,
    (TPA$_EOS, TPA$_EXIT));


$INIT_STATE(OWNE_STATES, OWNE_KEYS);
$STATE( ,
    (TPA$_IDENT,,,,CONVERTED_UIC));
$STATE( ,
    (TPA$_EOS, TPA$_EXIT));


$INIT_STATE(PROT_STATES, PROT_KEYS);
$STATE(NEXTPRO,
    ('SYSTEM',SYPR,,%X'000F0000',TPA_1),
    ('OWNER', OWPR,,%X'00F00000',TPA_1),
    ('GROUP', GRPR,,%X'0F000000',TPA_1),
    ('WORLD', WOPR,,%X'F0000000',TPA_1));
$STATE(SYPR,
    (':'),
    ('='),
    (TPA$_LAMBDA,ENDPRO));
$STATE(SYPR0,
    ('R',SYPR0,,%X'0001',TPA_1),
    ('W',SYPR0,,%X'0002',TPA_1),
    ('E',SYPR0,,%X'0004',TPA_1),
    ('D',SYPR0,,%X'0008',TPA_1),
    (TPA$_LAMBDA,ENDPRO));
$STATE(OWPR,
    (':'),
    ('='),
    (TPA$_LAMBDA,ENDPRO));
$STATE(OWPR0,
    ('R',OWPR0,,%X'0010',TPA_1),
    ('W',OWPR0,,%X'0020',TPA_1),
    ('E',OWPR0,,%X'0040',TPA_1),
    ('D',OWPR0,,%X'0080',TPA_1),
    (TPA$_LAMBDA,ENDPRO));
$STATE(GRPR,
    (':'),
    ('='),
    (TPA$_LAMBDA,ENDPRO));
$STATE(GRPR0,
    ('R',GRPR0,,%X'0100',TPA_1),
    ('W',GRPR0,,%X'0200',TPA_1),
    ('E',GRPR0,,%X'0400',TPA_1),
    ('D',GRPR0,,%X'0800',TPA_1),
    (TPA$_LAMBDA,ENDPRO));
$STATE(WOPR,
    (':'),
    ('='),
    (TPA$_LAMBDA,ENDPRO));
$STATE(WOPR0,
    ('R',WOPR0,,%X'1000',TPA_1),
    ('W',WOPR0,,%X'2000',TPA_1),
    ('E',WOPR0,,%X'4000',TPA_1),
    ('D',WOPR0,,%X'8000',TPA_1),
    (TPA$_LAMBDA,ENDPRO));
$STATE(ENDPRO,
    (',',NEXTPRO),
    (TPA$_EOS,TPA$_EXIT));

END
ELUDOM
