%TITLE 'SYSIMGACT - Image Activator System Service'
MODULE SYS$IMGACT (
		IDENT = 'V04-001'		! File: SRC$:SYSIMGACT.B32
		) =
BEGIN

!****************************************************************************
!*									    *
!*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
!*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
!*  ALL RIGHTS RESERVED.						    *
!* 									    *
!*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
!*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
!*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
!*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
!*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
!*  TRANSFERRED.							    *
!* 									    *
!*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
!*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
!*  CORPORATION.							    *
!* 									    *
!*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
!*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
!* 									    *
!*									    *
!****************************************************************************

!++
! Facility:
!
!	Executive, System Service
!
! Abstract:
!
!	This module contains the code necessary to map a portion of process
!	address space to a particular image file.
!
! Environment:
!
!	The bulk of the code in this module executes in executive mode, in
!	a layer outside RMS. One routine executes a small amount of code in
!	kernel mode.
!
!	Note that the image activator is not reentrant.
!
! Author: 
!
!	Lawrence J. Kenah
!
!	The original version of the image activator was written by Peter Lipman.
!	During Version 2 of VMS, extensive enhancements were made by Kathy
!	Morse.
!
! Creation Date: 
!
!	15 April 1983
!
! Modified By:
!
!    V04-001	LJK0289		Lawrence J. Kenah	7-Sep-1984
!		Make SET_VECTORS loop into a zero-pass loop if there is no
!		work to do. 
!
!    V03B-021	MSH0056		Michael S. Harvey	2-Jul-1984
!		Rearrange new code for previous fix so the merged
!		activation path for a CLI doesn't get screwed up.
!
!    V03B-020	MSH0056		Michael S. Harvey	21-Jun-1984
!		When a secondary image must be substituted (such as
!		with an AME or CLI) for a primary image, make sure to
!		reinitialize the proper context variables, thus preventing
!		Executive mode bugchecks.
!
!    V03B-019	LJK0286		Lawrence J. Kenah	5-Jun-1984
!		Set flag bit in IMAGCTX that indicates to $IMGFIX that
!		shareable images contain initialization code.
!
!    V03B-018	LJK0283		Lawrence J. Kenah	11-May-1984
!		Set the DONE bit in all ICBs that result from a successful
!		activation so that they do not disappear in a later
!		activation that fails.
!
!    V03B-017	LJK0276		Lawrence J. Kenah	8-May-1984
!		Make sure that ICBs are not left dangling when an image
!		has already been activated or along error paths.
!
!    V03B-016	LJK0274		Lawrence J. Kenah	16-Apr-1984
!		Fix ERROR_CLEAN_UP routine.
!
!    V03B-015	LJK0269		Lawrence J. Kenah	31-Mar-1984
!		Miscellaneous small changes.
!		Add code that cleans up if an error is detected after
!		some pages have been successfully mapped.
!		Set internal status bit that indicates that the P0 half 
!		of a P1 merge operation is taking place.
!		Change the way that privileged vector context is stored.
!		Return correct context if image is already mapped.
!		Add state flags passed from $IMGACT to $IMGFIX.
!		Add error routine that performs a complete cleanup if
!		an error occurs after an image has been successfully mapped.
!		Defer addition of privileged vectors until fixups are done.
!
!    V03B-014	LJK0268		Lawrence J. Kenah	29-Mar-1984
!		Turn on code that records SHRCNT and USECNT in KFE.
!
!    V03B-013	LJK0267		Lawrence J. Kenah	28-Mar-1984
!		Use name stored in KFE as global section name. This allows
!		correct redirection of shareable images installed /SHARED.
!
!    V03B-013	LJK0266		Lawrence J. Kenah	27-Mar-1984
!		Add major and minor ID consistency checks on the
!		image header.
!
!    V03B-012	MSH0022		Michael S. Harvey	25-Mar-1984
!		Unconceal known file lookups.
!
!    V03B-011	WMC0003		Wayne Cardoza		24-Mar-1984
!		Call RM$SET to set up image I/O area.
!
!    V03B-010	WMC0002		Wayne Cardoza		23-Jan-1984
!		Misc small fixes.
!		Add sequential loading of images.
!
!    V03B-009	LJK0244		Lawrence J. Kenah	23-Aug-1983
!		Turn on image accounting. Set default stack size.
!
!    V03B-008	WMC0001		Wayne Cardoza		05-Aug-1983
!		Remove code for passing back FAB on failure.
!
!    V03B-007	LJK0242		Lawrence J. Kenah	2-Aug-1983
!		Add support for writable global sections.
!
!    V03B-006	LJK0235		Lawrence J. Kenah	26-Jul-1983
!		Add concept of image base address, different from starting
!		address. Continue fixing bugs and cleaning up loose ends.
!
!    V03B-005	LJK0232		Lawrence J. Kenah	21-Jul-1983
!		The starting address of the image I/O segment should
!		be page aligned.
!
!    V03B-004	LJK0230		Lawrence J. Kenah	18-Jul-1983
!		Add system version check. Add _001 suffix to main image name.
!
!    V03B-003	LJK0228		Lawrence J. Kenah	12-Jul-1983
!		Propogate setting of EXPREG flag into the ICB.
!
!    V03B-002	LJK0219		Lawrence J. Kenah	29-Jun-1983
!		Add support for compatibility mode and other alias images.
!		Fix the many bugs that were discovered during debugging.
!
!    V03B-001	LJK0200		Lawrence J. Kenah	15-Apr-1983
!		Being a complete rewrite of the original image activator
!		system service.
!--


%SBTTL 'Declarations'

SWITCHES ADDRESSING_MODE (EXTERNAL = GENERAL, NONEXTERNAL = WORD_RELATIVE);

PSECT
	CODE	= YF$$SYSIMGACT (WRITE),
	PLIT	= YF$$SYSIMGACT (WRITE, EXECUTE);

LIBRARY 'SYS$LIBRARY:LIB.L32';		! Define system data structures

REQUIRE 'LIB$:IMGMSGDEF.R32';		! Get status code definitions
REQUIRE 'LIB$:IMGACTCTX.R32';		! Define internal structures

! Machine dependent features

BUILTIN
    MOVC5,
    MOVPSL,
    MTPR,
    PROBER,
    PROBEW,
    INSQUE,
    REMQUE;

! Miscellaneous internal symbols

LITERAL
    TRUE = 1,
    FALSE = 0,
    BYTES_PER_PAGE = 512,
    RETURN_BUFFER_SIZE = 512,
    EXTRA_USER_STACK = 2,
    END_OF_P0_SPACE = %X'3FFFFFFF',
    EXEC_PROT = (PRT$C_UREW ^ 8) OR PSL$C_EXEC;

! Linkage declaration for procedures invoked with the $CMKRNL system service

LINKAGE
    SYS_CMKRNL = CALL : GLOBAL (PCB = 4);

! Internal references

FORWARD ROUTINE
    CHECK_PARAMS,
    INIT_WINDOW		: SYS_CMKRNL,
    CHECK_MATCH_CONTROL,
    GET_OTHER_IMAGE,
    END_PROCESSING,
    SET_CONTROL_REGION	: SYS_CMKRNL,
    GET_LOCK,
    RELEASE_LOCK,
    ERROR_CLEAN_UP	: NOVALUE,
    SET_VECTORS;

! Routines that will be referenced by the ISD mapping routines as well
! as internally

FORWARD ROUTINE
    IMG$GET_HEADER,
    IMG$OPEN_IMAGE,
    IMG$ALLOCATE_ICB,
    IMG$DEALLOCATE_ICB	: NOVALUE;

! Linkage declarations to JSB routines in exec

LINKAGE
    RM_RESET         = JSB : NOPRESERVE (0,1,2)
                       NOTUSED (3,4,5,6,7,8,9,10,11),
    RM_SET           = JSB (REGISTER = 0, REGISTER = 1) : 
                       NOPRESERVE (0,1,2)
                       NOTUSED (3,4,5,6,7,8,9,10,11),
    EXE_ALOP1PROC    = JSB (REGISTER = 1; REGISTER = 1,REGISTER = 2) :
                       NOPRESERVE (3)
                       NOTUSED (4,5,6,7,8,9,10,11),
    EXE_DEAP1        = JSB (REGISTER = 0, REGISTER = 1) :
                       NOPRESERVE (2,3)
                       NOTUSED (4,5,6,7,8,9,10,11),
    EXE_MAXACMODE    = JSB (REGISTER = 0; REGISTER = 0) :
                       NOPRESERVE (1)
                       NOTUSED (2,3,4,5,6,7,8,9,10,11),
    EXE_PROBE_DSC    = JSB (REGISTER = 1; REGISTER = 1, REGISTER = 2) :
                       NOPRESERVE (3)
                       NOTUSED (4,5,6,7,8,9,10,11),
    IMG_IS_IT_MAPPED = JSB (REGISTER = 0; REGISTER = 1) :
                       PRESERVE (2,3,4,5,6,7)
                       NOTUSED (8,9,10,11),
    IOC_VERIFYCHAN   = JSB (REGISTER = 0; REGISTER = 1, REGISTER = 2) :
                       NOPRESERVE (3)
                       NOTUSED (4,5,6,7,8,9,10,11),
    FIL_INIWCB       = JSB (REGISTER = 1, REGISTER = 2, REGISTER = 3;
                       REGISTER = 2) :
                       PRESERVE (3,4,5)
                       NOTUSED (6,7,8,9,10,11);

!  External references with explicit linkage mechanisms

EXTERNAL ROUTINE
    EXE$ALOP1PROC    : EXE_ALOP1PROC,
    EXE$DEAP1        : EXE_DEAP1,
    EXE$MAXACMODE    : EXE_MAXACMODE,
    EXE$PROBER_DSC   : EXE_PROBE_DSC,
    EXE$PROBEW_DSC   : EXE_PROBE_DSC,
    IMG$IS_IT_MAPPED : IMG_IS_IT_MAPPED,
    IOC$VERIFYCHAN   : IOC_VERIFYCHAN,
    FIL$INIWCB       : FIL_INIWCB,
    RM$RESET         : RM_RESET,
    RM$SET	     : RM_SET;

! External procedure references

EXTERNAL ROUTINE
    FIL$OPENFILE,
    IMG$DECODE_IHD,
    IMG$DO_WORK_LIST,
    MMG$CRETVA			: SYS_CMKRNL;

! External data cells in P1 space

EXTERNAL
    CTL$AG_CMEDATA,
    CTL$AL_STACK		: VECTOR [4],
    CTL$A_DISPVEC,
    CTL$GL_CTLBASVA,
    CTL$GL_FIXUPLNK,
    CTL$GL_IMGHDRBF,
    CTL$GL_PHD			: REF $BBLOCK,
    CTL$GL_RMSBASE,
    CTL$GL_VOLUMES,
    CTL$GQ_PROCPRIV		: VECTOR [2],
    IAC$AW_VECSET               : VECTOR [4, WORD],
    IAC$GL_ICBFL		: VECTOR [2],
    IAC$AL_IMGACTBUF,
    IAC$GL_FIRST_ICB,
    IAC$GL_IMAGCTX		: $BBLOCK,
    IAC$GL_MAIN_ICB,
    IAC$GL_WORK_LIST		: VECTOR [2],
    IAC$GL_IMAGE_LIST		: VECTOR [2],
    IAC$GL_STACK_SIZE,
    PIO$GW_IIOIMPA		: $BBLOCK;

! The following cells in P1 space are used exclusively for image accounting

EXTERNAL
    CTL$GL_ICPUTIM,
    CTL$GL_IFAULTS,
    CTL$GL_IFAULTIO,
    CTL$GL_IWSPEAK,
    CTL$GL_IPAGEFL,
    CTL$GL_IDIOCNT,
    CTL$GL_IBIOCNT,
    CTL$GL_IVOLUMES,
    CTL$GQ_ISTART		: VECTOR [2];

! External data cells in system space

EXTERNAL
    EXE$GL_ACMFLAGS		: $BBLOCK,
    EXE$GL_FLAGS		: $BBLOCK,
    EXE$GL_KNOWN_FILES,
    EXE$GL_SYSID_LOCK,
    EXE$GQ_KFE_LCKNAM,
    EXE$GQ_SYSTIME		: VECTOR [2],
    SGN$GW_IMGIOCNT		: WORD;

! Miscellaneous constants defined elsewhere

EXTERNAL LITERAL
    EXE$C_SYSEFN	: UNSIGNED (6),
    EXE$V_INIT		: UNSIGNED (6),
    SYS$K_VERSION	: UNSIGNED (31);

! Make the bit position of the INIT flag available to BLISS

MACRO EXE_V_INIT = 0, EXE$V_INIT, 1, 0 %;      

! Some miscellaneous address definitions

! The first part of the image activator scratch area is divided up into two
! large pieces, each of which is further subdivided into a FAB, a NAM block,
! a 512-byte block into which each succeeding block of the image header will
! be read, and a buffer that will receive the decoded image header. The
! decoded image header is assumed to be smaller than a page. The area that
! follows these buffers is used as OWN storage by the image activator.

LITERAL
    INPUT_BUFFER_SIZE = BYTES_PER_PAGE,
    IHD_BUFFER_SIZE   = BYTES_PER_PAGE;

BIND               
    INPUT_BUFFER = IAC$AL_IMGACTBUF,
    PRIMARY_IHD  = INPUT_BUFFER + 512,
    AUX_BUFFER   = PRIMARY_IHD  + 512,
    AUX_IHD      = AUX_BUFFER   + 512,
    PRIMARY_FAB  = AUX_IHD      + 512,
    PRIMARY_NAM  = PRIMARY_FAB  + FAB$K_BLN,
    AUX_FAB      = PRIMARY_NAM  + NAM$K_BLN,
    AUX_NAM      = AUX_FAB      + FAB$K_BLN,
    RESULT_NAME  = AUX_NAM      + NAM$K_BLN,
    OWN_STORAGE  = RESULT_NAME  + NAM$C_MAXRSS	: $BBLOCK;

! There are eight pages set aside in P1 space (in module SHELL) for
! the image activator scratch area. The following assumption guarantees
! that the scratch area that is defined here fits into eight pages.

    $ASSUME ( OWN_STORAGE_SIZE + (2 * (INPUT_BUFFER_SIZE +
                                       IHD_BUFFER_SIZE +
                                       FAB$K_BLN + 
                                       NAM$K_BLN) ),
              LEQU,
              8 * BYTES_PER_PAGE );

%SBTTL 'EXE$$IMGACT - Image Activator System Service Routine'

GLOBAL ROUTINE EXE$$IMGACT 
    (IMAGE_NAME_ADDR , DEFAULT_NAME_ADDR , BUFFER , CONTROL_FLAGS ,
    INADR , RETADR , IDENT , MODE ) =

!++
! FUNCTIONAL DESCRIPTION:
!
!	This routine receives control from the system service dispatcher
!	to perform the actual work of activating an image.
!
! CALLING SEQUENCE:
!
!    CALLx G^SYS$IMGACT
!
! FORMAL PARAMETERS:
!
!	TBS
!
! STATUS CODES:
!
!	TBS
!--

BEGIN

BUILTIN
    AP,
    CALLG;

BIND FLAGS = OWN_STORAGE [INPUT_FLAGS] : $BBLOCK;

LOCAL 
    ICB_ADR	: REF $BBLOCK,
    IHD_CTX	: $BBLOCK [CTX_K_LENGTH],
    STATUS;

! The portion of the impure area that is used as OWN storage is filled with
! zeros. This initializes system service parameters, copies of input
! parameters, and the like. 

CH$FILL (0, OWN_STORAGE_SIZE, OWN_STORAGE);
OWN_STORAGE [FINAL_STATUS] = SS$_NORMAL; 		! Assume successful completion
OWN_STORAGE [USER_STACK_SIZE] = EXTRA_USER_STACK;	! Assume a minimal user stack

! No access check is required for the activation flags, which are present in
! the argument list itself. A safe copy must be made, however, to insure that
! the flags are not destroyed by a mapping request issued by the image
! activator. To avoid this, the flags are stored away in a safe place. 

OWN_STORAGE [INPUT_FLAGS] = .CONTROL_FLAGS;

IF .FLAGS [IAC$V_SETVECTOR] 
THEN RETURN SET_VECTORS();

! Save the callers mode for use in various checks

MOVPSL (OWN_STORAGE [CALL_MODE] );

! Set up the starting points for the various privileged vectors

INCRU I FROM 0 TO 3 DO
    BEGIN

    BIND
        DISPVEC = CTL$A_DISPVEC + (.I * 256) : LONG;

    DISPVEC = .IAC$AW_VECSET [.I];

    END;

! The input parameter list is checked for accessibility and the parameters are
! stored in the impure area for later use.

STATUS = CALLG (.AP, CHECK_PARAMS);
IF NOT .STATUS THEN RETURN .STATUS;

! Several other miscellaneous areas need to be initialized if this is
! not a activation that merges an additional image into existing address
! space. Note that the fixup vector listhead is unconditionally cleared.

CTL$GL_FIXUPLNK = 0;			! Set the fixup vector list to empty
IF NOT .FLAGS [IAC$V_MERGE]
THEN
    BEGIN
    RM$RESET ();			! Clear the image I/O segment
    IAC$GL_IMAGCTX = 0;			! Start with a clean context slate
    OWN_STORAGE [MAIN_PROGRAM] = TRUE;	! Indicate that this is the activation
    END					!  of a main program
ELSE
    BEGIN

    BIND CONTEXT = IAC$GL_IMAGCTX : VECTOR [2,WORD];

    CONTEXT [1] = 0;			! Only clear flags passed to $IMGFIX
    END;

! Before we open the image file, we need to check whether the image is already
! mapped. If it is, we simply return successfully, passing back as much data
! as is available about the image.

STATUS = IMG$ALLOCATE_ICB (ICB_ADR);	! Allocate an ICB for the primary image

IF NOT .STATUS THEN RETURN .STATUS;

! The following check is only made for a merge activation

IF .FLAGS [IAC$V_MERGE]
THEN
    BEGIN

    BIND
        INPUT_NAME = OWN_STORAGE [IMAGE_NAME_DESC] : $BBLOCK,
        ICB_NAME = ICB_ADR [ICB$T_IMAGE_NAME] : VECTOR [,BYTE],
        RETADR = .OWN_STORAGE [RETURN_ARRAY_ADDRESS] : VECTOR [2],
        BUFFER = .OWN_STORAGE [BUFFER_ADDRESS] : VECTOR [128];

    LOCAL
        MAPPED_ICB : REF $BBLOCK;

    ICB_NAME [0] = .INPUT_NAME [DSC$W_LENGTH];
    MOVC5 (
        INPUT_NAME [DSC$W_LENGTH],
        .INPUT_NAME [DSC$A_POINTER],
        %REF(0),
        %REF(ICB$S_IMAGE_NAME-1),
        ICB_NAME [1]);
    STATUS = IMG$IS_IT_MAPPED (ICB_NAME; MAPPED_ICB);

    ! If the shareable image has already been mapped, we return successfully 
    ! after passing back to the caller whatever information is available.

    IF .STATUS EQL SS$_NORMAL
    THEN
        BEGIN

        IF RETADR NEQU 0
        THEN
            BEGIN
            RETADR [0] = .MAPPED_ICB [ICB$L_STARTING_ADDRESS];
            RETADR [1] = .MAPPED_ICB [ICB$L_END_ADDRESS];
            END;

        IF BUFFER NEQU 0
        THEN
            BEGIN

            BIND IFD = BUFFER [3] : $BBLOCK;

            BUFFER [0] = 0;
            BUFFER [1] = IFD;
            BUFFER [2] = 0;
            IFD [IFD$W_CHAN] = .MAPPED_ICB [ICB$W_CHAN];
            IFD [IFD$W_FLAGS] = .IAC$GL_IMAGCTX;

            END;

        IMG$DEALLOCATE_ICB (.ICB_ADR);

        RETURN SS$_NORMAL;

        END;

    END;

IAC$GL_FIRST_ICB = .ICB_ADR;		! Remember address of this ICB
IF .OWN_STORAGE [MAIN_PROGRAM]
THEN IAC$GL_MAIN_ICB = .ICB_ADR;	! Remember it here, too, if main program
ICB_ADR [ICB$L_CONTEXT] = IHD_CTX;	! Store address before opening image

STATUS = GET_LOCK();			! Lock the KFE data base for read access
IF NOT .STATUS THEN RETURN .STATUS;

STATUS = IMG$OPEN_IMAGE (		! Open the image file
    OWN_STORAGE [IMAGE_NAME_DESC],
    OWN_STORAGE [DFLT_NAME_DESC],
    PRIMARY_FAB,
    PRIMARY_NAM,
    RESULT_NAME,
    .ICB_ADR);
IF NOT .STATUS 
THEN 
    BEGIN
    IMG$DEALLOCATE_ICB (.ICB_ADR);
    RELEASE_LOCK ();
    RETURN .STATUS
    END;

! The IHD_CTX context block stores the image header data that does not need
! to exist once the image activator is done. Because this ICB represents the
! image whose name was passed directly to the image activator, the primary
! input buffer and IHD buffer are used. 

IHD_CTX [CTX_L_BUFFER] = INPUT_BUFFER;
IHD_CTX [CTX_L_IHDBUF] = PRIMARY_IHD;

STATUS = IMG$GET_HEADER (.ICB_ADR);	! Decode and store away the IHD contents
IF NOT .STATUS 
THEN 
    BEGIN
    $DASSGN (CHAN = .ICB_ADR [ICB$W_CHAN]);
    ERROR_CLEAN_UP ();
    IMG$DEALLOCATE_ICB (.ICB_ADR);
    RELEASE_LOCK ();
    RETURN .STATUS
    END;

! There are several alias images that cause a secondary image to be activated,
! leaving the primary image opened and its name stored in P1 space for later
! possible use by the secondary image, the one actually activated.

IF .IHD_CTX [CTX_W_ALIAS] NEQ IHD$C_NATIVE
THEN 
    BEGIN
    STATUS = GET_OTHER_IMAGE (.ICB_ADR);
    IF NOT .STATUS 
    THEN 
        BEGIN
        IMG$DEALLOCATE_ICB (.ICB_ADR);
        RELEASE_LOCK ();
        RETURN .STATUS
        END;
    END;

! Several other fields in the ICB must be loaded with information obtained
! from the input parameter list.

! Note that EXPREG is only valid when mapping into P0 space. Note further that
! the input map range is specified explicitly, rather than using the EXPREG
! flag in the ICB, which is only meaningful in ICBs for shareable images
! implicitly referenced during the activation of the primary image.

IF .FLAGS [IAC$V_EXPREG]
THEN 
    BEGIN

    BIND
        PHD = .CTL$GL_PHD	: $BBLOCK;

    ICB_ADR [ICB$L_STARTING_ADDRESS] = .PHD [PHD$L_FREP0VA];
    ICB_ADR [ICB$L_END_ADDRESS] = END_OF_P0_SPACE;
    END
ELSE
    BEGIN
    ICB_ADR [ICB$L_STARTING_ADDRESS] = .OWN_STORAGE [INPUT_START_ADDRESS];
    ICB_ADR [ICB$L_END_ADDRESS] = .OWN_STORAGE [INPUT_END_ADDRESS];
    END;

ICB_ADR [ICB$B_ACCESS_MODE] = .OWN_STORAGE [ACCESS_MODE];
ICB_ADR [ICB$B_ACT_CODE] = 
    (IF .FLAGS [IAC$V_MERGE]
     THEN ICB$K_MERGED_IMAGE
     ELSE ICB$K_MAIN_PROGRAM);
ICB_ADR [ICB$L_MATCH_CONTROL] = .OWN_STORAGE [MATCH_CONTROL];
ICB_ADR [ICB$L_VERSION] = .OWN_STORAGE [VERSION];

! The image control block is inserted into the work list where it can be
! retrieved by the routine that converts ISDs into mapping requests.

INSQUE (.ICB_ADR , .IAC$GL_WORK_LIST [1]);	! Insert at tail of work list
STATUS = IMG$DO_WORK_LIST();
IF NOT .STATUS THEN 
    BEGIN
    ERROR_CLEAN_UP ();
    RELEASE_LOCK ();
    RETURN .STATUS
    END;

STATUS = END_PROCESSING (.ICB_ADR);	! Set final state for image
IF NOT .STATUS THEN 
    BEGIN
    ERROR_CLEAN_UP ();
    RELEASE_LOCK ();
    RETURN .STATUS
    END;

RELEASE_LOCK();				! Allow exclusive access again
RETURN .OWN_STORAGE [FINAL_STATUS];	! ... and return 

END;    				! End of routine EXE$IMGACT main routine

%SBTTL 'CHECK_PARAMS - Check Accessibility and Store Parameters'

ROUTINE CHECK_PARAMS (NAME,DEFAULT,BUFFER,FLAGS,INADR,RETADR,IDENT,ACMODE) =

!+
! Functional Description:
!
!    This routine probes each input parameter for read access and stores
!    the value of the parameter in a safe place. Output parameters are probed
!    for write access and their addresses are stored for later use.
!
! Calling Sequence:
!
!    CHECK_PARAMS (NAME,DEFAULT,BUFFER,FLAGS,INADR,RETADR,IDENT,ACMODE)
!
!-

BEGIN

LOCAL 
    SAFE_PLACE,
    STATUS;

! Define some synonyms for the local storage called SAFE_PLACE

BIND
    LOCAL_NAME   = SAFE_PLACE : REF $BBLOCK,
    LOCAL_DFLT   = SAFE_PLACE : REF $BBLOCK,
    LOCAL_BUFFER = SAFE_PLACE,
    LOCAL_INADR  = INADR      : REF VECTOR,
    LOCAL_RETADR = RETADR     : REF VECTOR,
    LOCAL_IDENT  = SAFE_PLACE : REF VECTOR;

! Define some more synonyms for the two file name descriptors

BIND
    NAM_DSC  = OWN_STORAGE [IMAGE_NAME_DESC] : $BBLOCK,
    DFLT_DSC = OWN_STORAGE [DFLT_NAME_DESC]  : $BBLOCK;

! The image name is the only required parameter for the image activator. If an
! image name is not present, this routine returns with an IMG$_NONAME error.

LOCAL_NAME = .NAME;
IF .LOCAL_NAME EQL 0
THEN 
    RETURN IMG$_NONAME
ELSE 
    BEGIN
    IF NOT (STATUS = EXE$PROBER_DSC (
        .LOCAL_NAME;
        NAM_DSC [DSC$W_LENGTH],
        NAM_DSC [DSC$A_POINTER]))
    THEN
        RETURN .STATUS
    END;

! The default name descriptor is probed and stored in a similar fashion. No
! error occurs if the default name is missing.

LOCAL_DFLT = .DEFAULT;
IF .LOCAL_DFLT EQL 0
THEN 
    BEGIN
    DFLT_DSC [DSC$W_LENGTH]  = 0;
    DFLT_DSC [DSC$A_POINTER] = 0;
    END
ELSE 
    BEGIN
    IF NOT (STATUS = EXE$PROBER_DSC (
        .LOCAL_DFLT;
        DFLT_DSC [DSC$W_LENGTH],
        DFLT_DSC [DSC$A_POINTER]))
    THEN
        RETURN .STATUS
    END;

! The address of a 512-byte buffer is tucked away after the buffer is
! checked for write access.
!
! NOTE WELL
!
! Because the image activator issues calls to other memory management system
! services, the protection on this buffer may change. This buffer must be probed
! again by the completion code before anything is written to the buffer.

LOCAL_BUFFER = .BUFFER;
IF (.LOCAL_BUFFER NEQ 0) 
    AND 
    (NOT PROBEW (%REF(0), %REF(RETURN_BUFFER_SIZE), .LOCAL_BUFFER))
THEN RETURN SS$_ACCVIO
ELSE OWN_STORAGE [BUFFER_ADDRESS] = .LOCAL_BUFFER;

!!! NEED TO PROPOGATE SOME OF THE FLAGS INFORMATION INTO OTHER OWN_STORAGE
!!! CELLS. ALSO NEED TO DO CONSISTENCY CHECKS BETWEEN FLAGS AND OTHER
!!! INPUT PARAMETERS.

! The input address range array specifies the address range into which the
! image is to be mapped. It must be readable by the caller.

LOCAL_INADR = .INADR;
IF (.LOCAL_INADR NEQ 0) AND (NOT PROBER (%REF(0), %REF(8), .LOCAL_INADR))
THEN RETURN SS$_ACCVIO;
IF .LOCAL_INADR NEQ 0
THEN
    BEGIN

    BIND
        FLAG_BITS = OWN_STORAGE [INPUT_FLAGS] : $BBLOCK,
        ADDRESS_RANGE = OWN_STORAGE [INPUT_START_ADDRESS] : $BBLOCK;

    OWN_STORAGE [INPUT_START_ADDRESS] = .LOCAL_INADR [0];
    OWN_STORAGE [INPUT_END_ADDRESS] = .LOCAL_INADR [1];

    ! We need to remember that this is the P0 part of a P1 merge operation
    ! because certain steps taken in a "real" activation must not take place.

    IF (
        (.FLAG_BITS [IAC$V_P1MERGE])
        AND
        (NOT (.ADDRESS_RANGE [VA$V_P1]))
       )
    THEN
        OWN_STORAGE [P1_MERGE_P0] = TRUE;

    END;

! The caller can specify the address of an array that will receive the
! address range into which a collection of images was mapped. This array
! is probed for write access and set to contain FFFFFFFF in both elements,
! indicating that no mapping has yet occurred. Note that this array, like
! the output buffer must be probed again by the completion code before the
! actual return address arra is written to make sure that the accessibility
! of the array has not changed as a side effect of a system service call 
! issued by the image activator.

LOCAL_RETADR = .RETADR;
IF (.LOCAL_RETADR NEQ 0) AND (NOT PROBEW (%REF(0), %REF(8), .LOCAL_RETADR))
THEN RETURN SS$_ACCVIO;
OWN_STORAGE [RETURN_ARRAY_ADDRESS] = .LOCAL_RETADR;
OWN_STORAGE [RETURN_START_ADDRESS] = -1;
OWN_STORAGE [RETURN_END_ADDRESS] = -1;
IF .LOCAL_RETADR NEQ 0
THEN
    BEGIN
    LOCAL_RETADR [0] = -1;
    LOCAL_RETADR [1] = -1;
    END;

! The caller can specify explicit match control information that will be 
! compared to the version number contained in the image that is actually
! activated.

LOCAL_IDENT = .IDENT;
IF (.LOCAL_IDENT NEQ 0) AND (NOT PROBER (%REF(0), %REF(8), .LOCAL_IDENT))
THEN RETURN SS$_ACCVIO;
IF .LOCAL_IDENT NEQ 0
THEN
    BEGIN
    OWN_STORAGE [MATCH_CONTROL] = .LOCAL_IDENT [0];
    OWN_STORAGE [VERSION] = .LOCAL_IDENT [1];
    END;

! The final input parameter is the access mode that will be used for two
! purposes. The channel on which the image file is opened will have this
! access mode associated with it. The pages that are mapped will be owned
! by the mode specified by this parameter. 
!
! Because an access mode of kernel is meaningless, a missing ACCESS_MODE
! parameter is interpreted as USER mode. If a nonzero value is present in the
! argument list, it is first maximized with caller's mode and then stored in
! a safe place. 

IF .ACMODE EQL 0
THEN 
    OWN_STORAGE [ACCESS_MODE] = PSL$C_USER
ELSE
    EXE$MAXACMODE (.ACMODE; OWN_STORAGE [ACCESS_MODE]);

RETURN SS$_NORMAL

END;					! End of routine CHECK_PARAMS

%SBTTL 'IMG$OPEN_IMAGE - Open Next Image File'

GLOBAL ROUTINE IMG$OPEN_IMAGE (NAME_DESC , DFLT_DESC ,
                    FAB_ADDRESS , NAM_BLOCK_ADDRESS ,
                    NAME_STRING , ICB_POINTER) = 

!+
! Functional Description:
!
!    This routine opens an image file as a process permanent file for
!    subsequent use by one of the memory management system services. 
!
! Calling Sequence:
!
!    IMG$OPEN_IMAGE ()
!
! Input Parameters:
!
!    NAME_DESC - Address of string descriptor for image file name
!
!    DFLT_DESC - Address of default name descriptor
!-

BEGIN

MAP
    NAME_STRING	: REF VECTOR;

BIND
    FAB        = .FAB_ADDRESS		: $BBLOCK,
    NAME_BLOCK = .NAM_BLOCK_ADDRESS	: $BBLOCK,
    ICB        = .ICB_POINTER		: $BBLOCK,
    DEV_CHAR   = FAB [FAB$L_DEV]	: $BBLOCK,
    ICB_NAME   = ICB [ICB$T_IMAGE_NAME]	: VECTOR [, BYTE];

! Create synonyms for the CTX and STV fields in the FAB

BIND
    CHAN       = FAB [FAB$L_STV],
    KFE        = FAB [FAB$L_CTX]	: REF $BBLOCK;

MAP 
    NAME_DESC			: REF $BBLOCK,
    DFLT_DESC			: REF $BBLOCK;

LOCAL
    STATUS;

! Once the system is fully initialized, RMS and the file system can be used
! to open the various image files. Until that time, the bootstrap file
! routines must be used. At least two images, SYSINIT.EXE and F11BXQP.EXE,
! are activated along this alternate code path.

IF .EXE$GL_FLAGS [EXE_V_INIT]
THEN
    BEGIN

    $FAB_INIT (
        FAB = FAB,
        FNS = .NAME_DESC [DSC$W_LENGTH],
        FNA = .NAME_DESC [DSC$A_POINTER],
        DNS = .DFLT_DESC [DSC$W_LENGTH],
        DNA = .DFLT_DESC [DSC$A_POINTER],
        NAM = NAME_BLOCK,
        FOP = (
            KFO ,		! Use the known file data base
            PPF ,		! Process permanent file
            SQO ,		! Network optimization
            UFO ),		! User file open
        CTX = 0,		! KFE address will be returned here
        RTV = -1		! Insure that WCB completely maps file
        );

    FAB [FAB$V_CHAN_MODE] = .OWN_STORAGE [ACCESS_MODE];

    ! The image files associated with writable global sections are opened
    ! for write access. All other image files are opened for execute access.

    IF .ICB [ICB$V_OPEN_FOR_WRITE]
    THEN
        BEGIN
        FAB [FAB$B_FAC] = FAB$M_PUT;
        FAB [FAB$B_SHR] = FAB$M_SHRGET OR FAB$M_SHRPUT OR FAB$M_UPI;
        END
    ELSE
        BEGIN
        FAB [FAB$B_FAC] = FAB$M_EXE;
        FAB [FAB$B_SHR] = 0;
        END;

    ! If we are currently running an executable image installed with privilege,
    ! we must direct RMS to only use the logical name tables that cannot be
    ! redefined by user mode code.

    FAB [FAB$V_LNM_MODE] = 
        (IF .IAC$GL_IMAGCTX [IMAGCTX$V_PRIV]
        THEN PSL$C_EXEC
        ELSE PSL$C_USER);

    ! Load NAM block with descriptor for resultant (or merely expanded) name
    ! string. (If a known file entry is found, then RMS does not return an 
    ! resultant string but merely the expanded string.)

    $NAM_INIT
        (NAM = NAME_BLOCK,
        RSS = NAM$C_MAXRSS,
        RSA = .NAME_STRING,
        ESS = NAM$C_MAXRSS,
        ESA = .NAME_BLOCK [NAM$L_RSA],
	NOP = <NOCONCEAL>
        );

    STATUS = $OPEN (FAB = FAB);

    !!! THE FOLLOWING HACK ALLOWS INFORMATION IN THE FAB TO BE PASSED	!!!!!!
    !!! BACK TO THE CALLER IN THE EVENT THAT THE ACTIVATION FAILS	 !!!!!
    !!!									  !!!!
    if .own_storage [buffer_address] nequ 0				   !!!
    then								   !!!
        begin								   !!!
									   !!!
        bind								   !!!
            bufhdr = .own_storage [buffer_address]	: vector [3,long]; !!!
									   !!!
        if probew (%ref(0), %ref(4), bufhdr [2])			   !!!
        then								   !!!
            bufhdr [2] = fab;						   !!!
									   !!!
        end;								  !!!!
    !!!									 !!!!!
    !!! THIS IS THE END OF THE ERROR REPORTING HACK			!!!!!!

    IF NOT .STATUS THEN RETURN .STATUS;	! ??? WHAT ELSE ???
    END
ELSE
    BEGIN

    ! This is the code path that is used to open image files before the file
    ! system and RMS exist.

    LOCAL
        RTVRBUF  : VECTOR [512, BYTE],	! Retrieval pointer buffer
        IXFHDR   : VECTOR [512, BYTE],	! Index file header buffer
        FILHDR   : VECTOR [512, BYTE],	! File header buffer
        STATBLK  : VECTOR [2],		! Statistics block
        RTVRLEN,			! Returned length of retrieval buffer
        BUF_DESC : VECTOR [2]		! Retrieval pointer buffer descriptor 
                   INITIAL (512, RTVRBUF);

    LOCAL
        ARG_LIST : VECTOR [3]
                   INITIAL (2, 0, BUF_DESC);

    STATUS = FIL$OPENFILE (
        FAB [FAB$L_STV],		! Store channel here
        .NAME_DESC,			! Address of name descriptor
	IXFHDR,        			! Address of index file header buffer
	FILHDR,        			! Address of file header buffer
        STATBLK,			! Address of statistics array
        RTVRLEN,			! Returned buffer size
        BUF_DESC);			! Retrieval buffer descriptor
    IF NOT .STATUS 
    THEN RETURN .STATUS;		! Exit if error detected

    IF .RTVRLEN GTR .BUF_DESC [0]	! If the mapping pointers can't fit on
    THEN RETURN SS$_BADIMGHDR;		!  a single page, then return an error

    IF .RTVRLEN EQL 0			! If the file is empty,
    THEN RETURN SS$_BADIMGHDR		!  then return an error
    ELSE BUF_DESC [0] = .RTVRLEN;	! Otherwise, use correct buffer size

    ARG_LIST [1] = .CHAN;		! Store channel number in argument list
    STATUS = $CMKRNL (			! Allocate and initialize a window
        ROUTIN = INIT_WINDOW,		!  control block in kernel mode
        ARGLST = ARG_LIST);
    IF NOT .STATUS 
    THEN RETURN .STATUS;		! Exit if error detected

    ! The image file name string passed as input will be stored internally and
    ! passed back to the caller if so requested. The entire file specification
    ! (and not merely the file name portion) will also be stored in the ICB. 

    NAME_BLOCK [NAM$B_RSL] = .NAME_DESC [DSC$W_LENGTH];
    CH$MOVE (
        .NAME_BLOCK [NAM$B_RSL], 	! Store the input file specification
        .NAME_DESC [DSC$A_POINTER],	!  in the name string buffer
        .NAME_STRING);

    ! Rather than storing the name in the ICB, this code segment will merely
    ! set up the NAM block fields so that the code below that loads the image
    ! name into the ICB will work correctly. Note that ICB$S_IMAGE_NAME includes
    ! one byte of count and four bytes of _00n suffix. These must be subtracted
    ! before the minimization takes place.

    NAME_BLOCK [NAM$B_NAME] = MINU (	! Only use the beginning of the string
        .NAME_DESC [DSC$W_LENGTH],	!  if the input file specification is
        ICB$S_IMAGE_NAME - (1+4));	!  longer than 39 characters
    NAME_BLOCK [NAM$L_NAME] = .NAME_STRING;

    END;

ICB [ICB$W_CHAN] = .CHAN;		! Store channel number in ICB
ICB [ICB$L_KFE] = .FAB [FAB$L_CTX];	! Pick up address of KFE

! If ICB does not yet contain an image name, load the name contained in the
! NAM block. The name stored in the ICB will be the filename portion of the
! full file spec, the same name that the linker uses when constructing the
! names of global ISDs. 

IF .ICB_NAME [0] EQL 0
THEN
    BEGIN
    ICB_NAME [0] = .NAME_BLOCK [NAM$B_NAME];
    CH$MOVE ( 
        .ICB_NAME [0],
        .NAME_BLOCK [NAM$L_NAME],          
        ICB_NAME [1]);
    END;

! If activating an image across the network or from magtape, the file is
! not mapped. Rather, the address space is created and the contents of the
! image file are read directly into the newly created pages.

IF (.DEV_CHAR [DEV$V_NET] OR
    (.DEV_CHAR [DEV$V_SQD] AND (.FAB [FAB$W_BLS] EQL 512)))
THEN ICB [ICB$V_LOAD_IMAGE] = TRUE;

IF .ICB [ICB$L_KFE] EQL 0 
THEN
    BEGIN
    IF (.IAC$GL_IMAGCTX [IMAGCTX$V_PRIV]) THEN RETURN SS$_PRIVINSTALL
    END
ELSE
    BEGIN

    ! Make sure that the count byte immediately precedes the name string

    $ASSUME (($BYTEOFFSET (KFE$B_FILNAMLEN))
             EQLU 
             ($BYTEOFFSET (KFE$T_FILNAM) - 1));

    BIND 
        KFE_NAME = KFE [KFE$T_FILNAM] - 1 : VECTOR [,BYTE],	! Include count byte
        CTX = .ICB [ICB$L_CONTEXT]        : $BBLOCK,
        GSD_NAME = CTX [CTX_T_GSD_NAME]   : VECTOR [,BYTE];

    ! Several bits of housekeeping are in order if this was a successful
    ! $OPEN of a known file.

    IF .KFE [KFE$V_PROCPRIV] AND .OWN_STORAGE [MAIN_PROGRAM]
        THEN IAC$GL_IMAGCTX [IMAGCTX$V_PRIV] = TRUE;

    ! Images installed with the /ACCOUNT qualifier can cause image accounting
    ! records to be written each time they are run as main programs. The
    ! ACCOUNT flag is ignored for shareable images and images that are merged
    ! into an existing image's address space. 

    IF .KFE [KFE$V_ACCOUNT] AND .OWN_STORAGE [MAIN_PROGRAM]
        THEN OWN_STORAGE [IMAGE_ACCOUNT] = TRUE;

    ! RMS returned an expanded string. We will store the size of the image
    ! file in the RSL field in the NAM block. We will also strip off the 
    ! trailing semicolon (or dot) that would inhibit further known file
    ! lookups if the file name returned by the image activator were to be
    ! passed back into the image activator at a later time.

    IF .NAME_BLOCK [NAM$B_VER] EQL 1
    THEN NAME_BLOCK [NAM$B_RSL] = .NAME_BLOCK [NAM$B_ESL] - 1;

    IF .KFE [KFE$V_SHARED]
    THEN 
        BEGIN
        CH$MOVE ( 
            (.KFE [KFE$B_FILNAMLEN] + 1),
            KFE_NAME [0],
            GSD_NAME [0]);
        CH$MOVE ( 
            4,
            CH$PTR (UPLIT ('_000')),
            GSD_NAME [.KFE [KFE$B_FILNAMLEN] + 1]);
        ICB [ICB$V_SHAREABLE] = TRUE;
        END;

    !!! SOME MORE KFE FLAGS SHOULD BE COPIED INTO THE ICB

    !!! THE CURRENT CODE WORRIES ABOUT THIS "SHMIDENT" STUFF

    END;

RETURN SS$_NORMAL;

END;    				! End of routine IMG$OPEN_IMAGE


%SBTTL 'INIT_WINDOW - Interface Routine to FIL$INIWCB'

ROUTINE INIT_WINDOW (CHANNEL, BUFFER_DESC) : SYS_CMKRNL = 

!+
! Functional Description:
!
!    This routine acts as a jacket to the routine called FIL$INIWCB, which
!    allocates a window control block in the absence of a complete file 
!    system.
!
! Calling Sequence:
!
!    $CMKRNL (INIT_WINDOW, ARGUMENT_LIST)
!    
! Formal Parameters:
!
!    CHANNEL - Address of channel on which image file is opened
!
!    BUFFER_DESC - Address of descriptor of retrieval pointer buffer
!-

BEGIN

EXTERNAL REGISTER			! We enter this procedure with the PCB
    PCB = 4 : REF $BBLOCK;		!  address contained in R4

BIND
    JIB     = .PCB [PCB$L_JIB] : $BBLOCK,
    BUF_DSC = .BUFFER_DESC     : VECTOR [2];

LOCAL
    STATUS,
    CCB  : REF $BBLOCK,
    WCB;

STATUS = IOC$VERIFYCHAN (.CHANNEL; CCB);
IF NOT .STATUS THEN RETURN .STATUS;
STATUS = FIL$INIWCB (.BUF_DSC [0], .BUF_DSC [1], .CCB [CCB$L_UCB]; WCB);
IF NOT .STATUS THEN RETURN .STATUS;
CCB [CCB$L_WIND] = .WCB;
CCB [CCB$B_AMOD] = PSL$C_USER + 1;
JIB [JIB$W_FILCNT] = .JIB [JIB$W_FILCNT] -1;
RETURN SS$_NORMAL

END;

%SBTTL 'IMG$GET_HEADER - Get Parameters from Image Header'

GLOBAL ROUTINE IMG$GET_HEADER (ICB_ADDRESS) =

!+
! Functional Description:
!
!    This routine is a jacket routine that handler two kinds of image header.
!    If an image was installed header resident, then there is no need to decode
!    the header or verify its contents. Other images must have their headers 
!    read into memory before the decode and verification can occur.
!
! Calling Sequence:
!
!    IMG$GET_HEADER (ICB_ADDRESS)
!    
! Formal Parameter:
!
!    ICB_ADDRESS - Address of image control block that describes the image
!        that is currently being activated.
!-

BEGIN

BIND 
    ICB_ADR = .ICB_ADDRESS             : $BBLOCK,
    KFE     = .ICB_ADR [ICB$L_KFE]     : $BBLOCK,
    IHD_CTX = .ICB_ADR [ICB$L_CONTEXT] : $BBLOCK;

LOCAL
    STATUS;

IF
    BEGIN
    IF KFE EQL 0
    THEN TRUE
    ELSE NOT .KFE [KFE$V_HDRRES]
    END    
THEN
    BEGIN

    STATUS = IMG$DECODE_IHD (
        .ICB_ADR [ICB$W_CHAN],
        .IHD_CTX [CTX_L_BUFFER],
        .IHD_CTX [CTX_L_IHDBUF],
        IHD_CTX [CTX_L_VBN],
        IHD_CTX [CTX_W_ISD_OFFSET],
        IHD_CTX [CTX_W_GENERATION],
        IHD_CTX [CTX_W_ALIAS]);

    IF NOT .STATUS THEN RETURN .STATUS;

    ! Images that contain an alias of either IHD$C_RSX or IHD$C_BPA are not
    ! native images produced by the linker and, as a result, do not require
    ! a check against the system version field.

    IF 
        (.IHD_CTX [CTX_W_ALIAS] NEQ IHD$C_RSX)
        AND
        (.IHD_CTX [CTX_W_ALIAS] NEQ IHD$C_BPA)
        AND
        (.IHD_CTX [CTX_W_ALIAS] NEQ IHD$C_ALIAS)
    THEN
        BEGIN

        BIND 
            IHD = .IHD_CTX [CTX_L_IHDBUF]       : $BBLOCK,
            MINORID_DIGIT = IHD [IHD$W_MINORID] : VECTOR [2,BYTE],
            IHA  = IHD + .IHD [IHD$W_ACTIVOFF]  : VECTOR [5];

        ! MINORID_DIGIT [0] maps the tens digit.
        ! MINORID_DIGIT [1] maps the units digit.

        LITERAL
            MINOR_ID_TENS = IHD$K_MINORID AND %X'FF',
            MINOR_ID_ONES = IHD$K_MINORID ^ -8;

        ! The major ID in the image header must be identically equal to
        ! the constant IHD$K_MAJORID. The minor ID in the image header
        ! must be LEQU the constant IHD$K_MINORID. Both IDs are stored
        ! as ASCII strings.

        IF (.IHD [IHD$W_MAJORID] NEQU IHD$K_MAJORID)
        THEN RETURN SS$_BADIMGHDR;
            
        IF (
            (.MINORID_DIGIT [0] GTRU MINOR_ID_TENS)
            OR
            (
                (.MINORID_DIGIT [0] EQLU MINOR_ID_TENS)
                AND
                (.MINORID_DIGIT [1] GTRU MINOR_ID_ONES)
            )
           )
        THEN RETURN SS$_BADIMGHDR;

        ! Check match control data for shareable images that are being
        ! activated because of global ISD references.

        IF .ICB_ADR [ICB$B_ACT_CODE] EQLU ICB$K_GLOBAL_IMAGE_SECTION
        THEN
            BEGIN
            STATUS = CHECK_MATCH_CONTROL (ICB_ADR, IHD);
            IF NOT .STATUS THEN RETURN .STATUS;
            END;

        ! We must record whether we are activating a shareable image with an
        ! initialization section.

        IF .IHD [IHD$V_INISHR]
        THEN
            BEGIN
            ICB_ADR [ICB$L_INITIALIZE] = .IHA [4];
            ICB_ADR [ICB$V_INITIALIZE] = TRUE;
            IAC$GL_IMAGCTX [IMAGCTX$V_INITIALIZE] = TRUE;
            END;

        ! If the image was linked against a SYS.STB for other than the current 
        ! system, then CMEXEC and CMKRNL privilege will be removed.

        IF  (.IHD [IHD$L_SYSVER] NEQU 0)
        THEN
            BEGIN
            ICB_ADR [ICB$V_SYS_STB] = TRUE;
            IF  (.IHD [IHD$L_SYSVER] NEQU SYS$K_VERSION)
            THEN OWN_STORAGE [REMOVE_PRIVILEGE] = TRUE;
            END;

        END;
    END
ELSE		! Header is already resident
    BEGIN

    BIND 
        IHD  = .KFE [KFE$L_IMGHDR]         : $BBLOCK,
        KFRH = IHD - KFRH$K_LENGTH         : $BBLOCK,
        IHA  = IHD + .IHD [IHD$W_ACTIVOFF] : VECTOR [5];

    ICB_ADR [ICB$V_RES_HEADER] = TRUE;	! Indicate that header is already in memory
    ICB_ADR [ICB$L_IHD] = IHD;		! Remember the address of the resident IHD
    IHD_CTX [CTX_L_IHDBUF] = 0;		! Clear this so it won't get used by something else later
    IHD_CTX [CTX_W_ISD_OFFSET] = .IHD [IHD$W_SIZE];
    IHD_CTX [CTX_W_GENERATION] = .KFRH [KFRH$B_HDRVER];
    IHD_CTX [CTX_W_ALIAS] = .KFRH [KFRH$W_ALIAS];

    IF .ICB_ADR [ICB$B_ACT_CODE] EQLU ICB$K_GLOBAL_IMAGE_SECTION
    THEN
        BEGIN
        STATUS = CHECK_MATCH_CONTROL (ICB_ADR, IHD);
        IF NOT .STATUS THEN RETURN .STATUS;
        END;

    ! We must record whether we are activating a shareable image with an
    ! initialization section.

    IF .IHD [IHD$V_INISHR]
    THEN
        BEGIN
        ICB_ADR [ICB$L_INITIALIZE] = .IHA [4];
        ICB_ADR [ICB$V_INITIALIZE] = TRUE;
        END;

    ! If the image was linked against a SYS.STB for other than the current 
    ! system, then CMEXEC and CMKRNL privilege will be removed.

    IF  (.IHD [IHD$L_SYSVER] NEQU 0)
    THEN
        BEGIN
        ICB_ADR [ICB$V_SYS_STB] = TRUE;
        IF  (.IHD [IHD$L_SYSVER] NEQU SYS$K_VERSION)
        THEN OWN_STORAGE [REMOVE_PRIVILEGE] = TRUE;
        END;

    STATUS = SS$_NORMAL;
    END;
RETURN .STATUS;

END;

%SBTTL 'CHECK_MATCH_CONTROL - Check Match Control Identification'

ROUTINE CHECK_MATCH_CONTROL (ICB, IHD ) =

!+
! Functional Description:
!
!    This routine checks that the match control information in the image header 
!    is consistent with the match control information that is actually being 
!    requested. The check is made in three steps.
!
!    1.  The match control flag that is being requested must be at least as
!        restrictive as the match control flag in the image header. 
!
!    2.  If the resultant match control is MATCH ALWAYS, no further checks are
!        made. If the resultant check is MATCH NEVER, ?????. 
!
!    3.  If the match control is either MATCH EQUAL or MATCH LEQUAL, two
!        further checks are made. 
!
!        a.  The two major IDs (one in ICB and one in IHD) must be equal.
!
!        b.  The two minor IDs must be related according to the match control. 
!            In the case of MATCH EQUAL, they must be equal. In the case of 
!            MATCH LEQUAL, the requested minor ID (located in the ICB) must be 
!            LEQU the minor ID in the image header of the image being 
!            activated.
!
! Calling Sequence:
!
!    CHECK_MATCH_CONTROL (ICB, IHD )
!    
! Formal Parameter:
!
!    ICB - Address of image control block that describes the image
!        that is currently being activated.
!
!    IHD - Address of image header of image being activated.
!-

BEGIN

MACRO
    IHD_V_MINOR_ID = $BYTEOFFSET (IHD$L_IDENT), 0, 24, 0 %,
    IHD_V_MAJOR_ID = $BYTEOFFSET (IHD$L_IDENT), 24, 8, 0 %;

MAP
    ICB : REF $BBLOCK,
    IHD : REF $BBLOCK;

CASE .IHD [IHD$V_MATCHCTL]
FROM ISD$K_MATALL TO ISD$K_MATNEV OF
SET

[ISD$K_MATALL]:

    SS$_NORMAL;				! Do nothing

[ISD$K_MATEQU]:

    IF 
        (.ICB [ICB$V_MATCH_CONTROL] EQLU ISD$K_MATALL)
        OR
        (.ICB [ICB$V_MATCH_CONTROL] EQLU ISD$K_MATLEQ)
    THEN RETURN SS$_SHRIDMISMAT;

[ISD$K_MATLEQ]:

    IF .ICB [ICB$V_MATCH_CONTROL] EQLU ISD$K_MATALL
    THEN RETURN SS$_SHRIDMISMAT;

[ISD$K_MATNEV]:

    RETURN SS$_SHRIDMISMAT;

TES;

CASE .ICB [ICB$V_MATCH_CONTROL]
FROM ISD$K_MATALL TO ISD$K_MATNEV OF
SET

[ISD$K_MATALL]:

    RETURN SS$_NORMAL;

[ISD$K_MATEQU, ISD$K_MATNEV]:

    BEGIN

    IF .ICB [ICB$V_MAJOR_ID] NEQU .IHD [IHD_V_MAJOR_ID]
    THEN RETURN SS$_SHRIDMISMAT;

    IF .ICB [ICB$V_MINOR_ID] EQLU .IHD [IHD_V_MINOR_ID]
    THEN RETURN SS$_NORMAL
    ELSE RETURN SS$_SHRIDMISMAT;

    END;

[ISD$K_MATLEQ]:

    BEGIN

    IF .ICB [ICB$V_MAJOR_ID] NEQU .IHD [IHD_V_MAJOR_ID]
    THEN RETURN SS$_SHRIDMISMAT;

    IF .ICB [ICB$V_MINOR_ID] LEQU .IHD [IHD_V_MINOR_ID]
    THEN RETURN SS$_NORMAL
    ELSE RETURN SS$_SHRIDMISMAT;

    END;

TES;

END;

%SBTTL 'END_PROCESSING - Final Steps of Image Activation'

ROUTINE END_PROCESSING (ICB_ADDRESS) =

!+
! Functional Description:
!
!    This routine performs the steps involved in image activation after all 
!    of the ISDs have been processed. (Some of the details are actually
!    performed by the kernel mode routine SET_CONTROL_REGION.) The operations
!    that need to be completed include
!
!    o mapping the image I/O segment
!
!    o mapping the user stack and setting the initial value of USP
!
!    o setting up the process privilege mask
!
!    o optionally setting up image accounting information 
!
!    o bumping the use count in any KFEs referenced by this activation
!
!    o bumping the reference count in any shared WCBs referenced by this
!      activation
!
!    o returning image parameters to the caller
!
! Calling Sequence:
!
!    END_PROCESSING (ICB_ADDRESS)
!-

BEGIN

LOCAL
    IMAGE_IO_PAGE_COUNT,
    STACK_BASE,
    CRETVA_RANGE	: VECTOR [2],
    ARG_LIST		: VECTOR [4] INITIAL (
        3,				! Argument count
        CRETVA_RANGE,			! INADR
        0,				! Null retadr
        EXEC_PROT),			! Access mode and protection
    IMGIO_SEG_DESC	: VECTOR [2] INITIAL (0,0),
    STATUS;

BIND
    ICB = .ICB_ADDRESS		: $BBLOCK,
    KFE = .ICB [ICB$L_KFE]	: $BBLOCK,
    PHD = .CTL$GL_PHD		: $BBLOCK,
    STACK_ARRAY = CRETVA_RANGE	: VECTOR;

! The location of the image header depends on whether the image was installed
! with its header resident.

BIND
    IHD =
        (IF .ICB [ICB$L_IHD] EQL 0
	THEN
            BEGIN

            BIND
                CTX = .ICB [ICB$L_CONTEXT]	: $BBLOCK;

            .CTX [CTX_L_IHDBUF]		

            END
        ELSE
            .ICB [ICB$L_IHD])			: $BBLOCK;

! If this is the activation of a main program, then the image I/O segment and
! user stack must be mapped.

IF .OWN_STORAGE [MAIN_PROGRAM]
THEN
    BEGIN
    IMAGE_IO_PAGE_COUNT = (
        IF .IHD [IHD$W_IMGIOCNT] NEQ 0 
        THEN 
            .IHD [IHD$W_IMGIOCNT] 
        ELSE 
            .SGN$GW_IMGIOCNT);

    IF .IMAGE_IO_PAGE_COUNT GTR .SGN$GW_IMGIOCNT
    THEN
    BEGIN
	IF .IHD [IHD$V_P0IMAGE]
	THEN
            BEGIN
            CRETVA_RANGE [0] = .PHD [PHD$L_FREP0VA];
            CRETVA_RANGE [1] = 
        	.CRETVA_RANGE [0]
        	+ (.IMAGE_IO_PAGE_COUNT * BYTES_PER_PAGE)
        	- 1;
            END
	ELSE
            BEGIN
            CRETVA_RANGE [1] = .CTL$GL_CTLBASVA - 1;
            CRETVA_RANGE [0] = 
                .CRETVA_RANGE [1]
                - (.IMAGE_IO_PAGE_COUNT * BYTES_PER_PAGE) + 1;
            END;

	! Create the image I/O segment using the internal routine that allows
	! a mixed-mode protection mask to be specified.

	STATUS = $CMKRNL (
            ROUTIN = MMG$CRETVA, 
            ARGLST = ARG_LIST);
	IF NOT .STATUS 
	THEN RETURN .STATUS;

	IMGIO_SEG_DESC [0] = .IMAGE_IO_PAGE_COUNT * BYTES_PER_PAGE;
	IMGIO_SEG_DESC [1] = .CRETVA_RANGE [0];

    END;

    RM$SET (.IHD [IHD$L_LNKFLAGS], IMGIO_SEG_DESC);

    IF .IHD [IHD$V_P0IMAGE]
    THEN
        BEGIN
        STATUS = $EXPREG (
            PAGCNT = .OWN_STORAGE [USER_STACK_SIZE],
            RETADR = STACK_ARRAY,
            ACMODE = PSL$C_USER,
            REGION = 0);
        STACK_BASE = .STACK_ARRAY [1] + 1;
        END
    ELSE
        BEGIN
        STATUS = $EXPREG (
            PAGCNT = .OWN_STORAGE [USER_STACK_SIZE],
            RETADR = STACK_ARRAY,
            ACMODE = PSL$C_USER,
            REGION = 1);
        STACK_BASE = .STACK_ARRAY [0] + 1;
        END;

    IF NOT .STATUS 
    THEN RETURN .STATUS;
    END;				! End of test for main program

! If the caller so requested, information about the image just activated is
! returned in a 512-byte buffer whose address was passed as an input parameter.
!
! The two main pieces of information are 
!
!    the image header except for all of the ISDs
! 
!    an image file descriptor whose primary piece is a string and descriptor
!    for the image file just activated
!
! Note that the buffer must be probed again because one of the mapping requests
! issued by the image activator may have changed its protection.

IF .OWN_STORAGE [BUFFER_ADDRESS] NEQA 0
THEN
    BEGIN

    ! Because this buffer contains a variety of information, we need to look
    ! at it in several different ways.

    BIND
        BUFFER = .OWN_STORAGE [BUFFER_ADDRESS]	: VECTOR [RETURN_BUFFER_SIZE,BYTE],
        BUFHDR = .OWN_STORAGE [BUFFER_ADDRESS]	: VECTOR [3,LONG],
        NAM    = PRIMARY_NAM			: $BBLOCK;

    LOCAL
        IFD		: REF $BBLOCK,
        FILE_NAME	: REF VECTOR [,BYTE];

    ! Insure that buffer is still writable by caller

    IF NOT PROBEW (%REF(0), %REF(RETURN_BUFFER_SIZE), .OWN_STORAGE [BUFFER_ADDRESS])
    THEN RETURN SS$_ACCVIO;

    ! Insure that image header information will fit into a single page

    IF (    
        12 + 				! Three longword header
        .IHD [IHD$W_SIZE] 		! Image header less ISDs
        )
        LEQU RETURN_BUFFER_SIZE
    THEN
        BEGIN

        ! Fill in the three pointers

        BUFHDR [0] = BUFFER [12];		! Image header starts right after three longword pointers
        BUFHDR [1] = 0;				! 0 until we see if IFD fits
        BUFHDR [2] = 0;				! Third longword is unused on success path

        ! Copy the image header

	CH$MOVE (.IHD [IHD$W_SIZE], IHD, BUFFER [12]);

        ! Any transfer address array elements that are not located in the 
        ! permanent portion of P1 space or in system space must be relocated
        ! by an amount equal to the base address of the image just mapped.

        IF 
            (.OWN_STORAGE [TRANSFER_ARRAY_BIAS] NEQ 0)
            AND
            (NOT .IHD [IHD$V_LNKNOTFR])
        THEN
            BEGIN

            BIND
                IHA = .BUFHDR [0] + .IHD [IHD$W_ACTIVOFF]	: VECTOR [3];

            LOCAL
                I;

            INCR I FROM 0 TO 2 DO
                IF .IHA [.I] LSSU .CTL$GL_CTLBASVA
                THEN
                    IHA [.I] = .IHA [.I] + .OWN_STORAGE [TRANSFER_ARRAY_BIAS];
            END;

	! See if we can also fit in the IFD

	IF (    
            12 + 			! Three longword header
            .IHD [IHD$W_SIZE] +		! Image header less ISDs
            IFD$K_LENGTH +		! Fixed portion of IFD
	    .NAM [NAM$B_RSL] +		! Length of image file name
            1 )				! Count byte in ASCIC string
            LEQU RETURN_BUFFER_SIZE
	THEN
	    BEGIN
	    IFD = BUFFER [12 + .IHD [IHD$W_SIZE]];	! IFD follows the image header
            BUFHDR [1] = .IFD;				! Store its address

	    ! Fill in the fixed portion of the IFD

	    IFD [IFD$W_SIZE] = IFD$K_LENGTH + .NAM [NAM$B_RSL];
	    IFD [IFD$W_FILNAMOFF] = IFD$K_LENGTH;
	    IFD [IFD$W_CHAN] = .ICB [ICB$W_CHAN];

            IFD [IFD$W_CMCHAN] = .OWN_STORAGE [OTHER_CHANNEL];
            IFD [IFD$L_CMKFIADR] = .OWN_STORAGE [OTHER_KFE_ADDRESS];

            IFD [IFD$W_FLAGS] = .IAC$GL_IMAGCTX;
        
	    FILE_NAME = .IFD + IFD$K_LENGTH;

            BEGIN

            BIND
                FILE_NAME_DESC = IFD [IFD$Q_CURPROG]	: $BBLOCK;

            FILE_NAME_DESC [DSC$W_LENGTH] = .NAM [NAM$B_RSL];
            FILE_NAME_DESC [DSC$A_POINTER] = .FILE_NAME + 1;

            END;

	    FILE_NAME [0] = .NAM [NAM$B_RSL];
            CH$MOVE (
        	.NAM [NAM$B_RSL],
		RESULT_NAME,
		FILE_NAME [1]);

	    END

	ELSE

	    ! Fill the IFD portion with zeros

	    CH$FILL (0, RETURN_BUFFER_SIZE - 12 - .IHD [IHD$W_SIZE],
		     BUFFER [12 + .IHD [IHD$W_SIZE]] );
	END

    ELSE

        !!! FOR LACK OF ANYTHING BETTER TO DO IN THIS CASE, I WILL FILL
        !!! THE ENTIRE 512-BYTE BUFFER WITH ZEROS

        CH$FILL (0, RETURN_BUFFER_SIZE, .OWN_STORAGE [BUFFER_ADDRESS]);        

    END;

! If the caller so requested, the address range into which the image and all
! of its associated shareable images were mapped is returned. Like the previous
! buffer, this address range must be probed in case the protection on the
! pages changed since the argument was first validated.

IF .OWN_STORAGE [RETURN_ARRAY_ADDRESS] NEQA 0
THEN
    BEGIN

    BIND
        RETADR = .OWN_STORAGE [RETURN_ARRAY_ADDRESS]	: VECTOR;

    ! Insure that two longwords are still writable

    IF NOT PROBEW (%REF(0), %REF(8), .OWN_STORAGE [RETURN_ARRAY_ADDRESS])
    THEN RETURN SS$_ACCVIO;

    ! Return the start and end addresses    

    RETADR [0] = .OWN_STORAGE [RETURN_START_ADDRESS];
    RETADR [1] = .OWN_STORAGE [RETURN_END_ADDRESS];

    END;

! The following kernel mode routine executes unconditionally to perform those
! completion chores that must be executed in kernel mode.

ARG_LIST [1] = .STACK_BASE;
ARG_LIST [2] = IHD;
ARG_LIST [3] = KFE;

STATUS = $CMKRNL (
    ROUTIN = SET_CONTROL_REGION, 
    ARGLST = ARG_LIST);
IF NOT .STATUS 
THEN RETURN .STATUS;

RETURN SS$_NORMAL

END;

%SBTTL 'SET_CONTROL_REGION - Kernel Mode Completion Routine'

ROUTINE SET_CONTROL_REGION (
    USER_STACK_ADDRESS,
    IHD_POINTER,
    KFE_POINTER) : SYS_CMKRNL = 

!+
! Functional Description:
!
!    This routine performs the end processing that must be done in kernel
!    mode. This includes loading the user stack pointer processor register,
!    and setting up the process privilege mask. Note that these steps are
!    only taken during the activation of a main program.
!
! Calling Sequence:
!
!    $CMKRNL (SET_CONTROL_REGION, ARGUMENT_LIST)
!
! Formal Parameters:
!
!    USER_STACK_ADDRESS - Address of base (high address end) of user stack
!
!    IHD_POINTER - Pointer to image header for this image
!
!    KFE_POINTER - Pointer to known file entry for this image, if one exists
!-

BEGIN

MACRO

    MOVE_PRIV_MASK (SRC, DST) =

        BEGIN
        VECTOR [DST,0] = .VECTOR [SRC,0];
        VECTOR [DST,1] = .VECTOR [SRC,1];
        END% ,

    CLEAR_PRIV_MASK (DST) =

        BEGIN
        VECTOR [DST,0] = 0;
        VECTOR [DST,1] = 0;
        END% ,

    EXCLUDE_PRIV_MASK (MASK, DST) =

        BEGIN
        VECTOR [DST,0] = .VECTOR [MASK,0] AND .VECTOR [DST,0];
        VECTOR [DST,1] = .VECTOR [MASK,1] AND .VECTOR [DST,1];
        END% ,

    INCLUDE_PRIV_MASK (MASK, DST) =

        BEGIN
        VECTOR [DST,0] = .VECTOR [MASK,0] OR .VECTOR [DST,0];
        VECTOR [DST,1] = .VECTOR [MASK,1] OR .VECTOR [DST,1];
        END% ;

EXTERNAL REGISTER			! We enter this procedure with the PCB
    PCB = 4 : REF $BBLOCK;		!  address contained in R4

BIND
    IHD = .IHD_POINTER	: $BBLOCK,
    KFE = .KFE_POINTER	: $BBLOCK,
    PHD = .CTL$GL_PHD	: $BBLOCK;

LITERAL
    CMKRNL_OR_CMEXEC = (1 ^ $BITPOSITION (PRV$V_CMKRNL)) 
                       OR 
                       (1 ^ $BITPOSITION (PRV$V_CMEXEC));

LOCAL
    PRIVILEGES	: VECTOR [2],
    ICB         : REF $BBLOCK;

! Most of the operations in this routine are only performed when activating
! a main program. The only step that must be performed during a merged 
! activation is the USECNT adjustment for the KFEs.

IF .OWN_STORAGE [MAIN_PROGRAM]
THEN
    BEGIN

    ! The high address end of the user stack is loaded into the stack limit
    ! array. The user stack pointer is initialized with a value that is smaller
    ! than the input value by a value given by the EXTRA_USER_STACK compile 
    ! time constant. The size of the user stack is stored ina  cell that will
    ! be used by the automatic stack expansion logic in EXCEPTION. Note that
    ! this number can never be smaller than 2.

    CTL$AL_STACK [PSL$C_USER] = .USER_STACK_ADDRESS;
    MTPR (%REF (.USER_STACK_ADDRESS - (EXTRA_USER_STACK*BYTES_PER_PAGE))
        , PR$_USP);
    IAC$GL_STACK_SIZE = .OWN_STORAGE [USER_STACK_SIZE];

    ! The privilege mask that will be used while this image is executing must
    ! be fabricated. 

    MOVE_PRIV_MASK (CTL$GQ_PROCPRIV, PRIVILEGES);	! Start with process  privileges

    ! Eliminate those not present in the image header

    EXCLUDE_PRIV_MASK (IHD [IHD$Q_PRIVREQS], PRIVILEGES);

    ! If the image was installed with privilege and we were called from other than
    ! user mode, then add the privileges from the KFE

    IF .OWN_STORAGE [CALL_MODE] NEQ PSL$C_USER
	AND
        BEGIN
        IF .KFE_POINTER EQL 0 
        THEN FALSE
        ELSE .KFE [KFE$V_PROCPRIV]
        END
    THEN 
        BEGIN
        INCLUDE_PRIV_MASK (KFE [KFE$Q_PROCPRIV], PRIVILEGES);
        MOVE_PRIV_MASK (KFE [KFE$Q_PROCPRIV], PHD [PHD$Q_IMAGPRIV]);
        END
    ELSE
        CLEAR_PRIV_MASK (PHD [PHD$Q_IMAGPRIV]);

    ! Before the final privileges get stored, we need to check whether there
    ! is a system version mismatch in any of the images that was mapped. (This
    ! mismatch was detected by the image header decode routine and remembered
    ! in the REMOVE_PRIVILEGE flag.) If a mismatch was detected, and either
    ! CMEXEC or CMKRNL is set, then CMKRNL and CMEXEC privileges are turned
    ! off and an alternate status (SS$_SYSVERDIF) is returned. 

    IF  (.OWN_STORAGE [REMOVE_PRIVILEGE])
        AND
        ((.PRIVILEGES [0] AND CMKRNL_OR_CMEXEC) NEQU 0)
    THEN 
        BEGIN
        PRIVILEGES [0] = .PRIVILEGES [0] AND (NOT CMKRNL_OR_CMEXEC);
        OWN_STORAGE [FINAL_STATUS] = SS$_SYSVERDIF;
        END;

    ! Store the privileges in the process header and in the PCB

    MOVE_PRIV_MASK (PRIVILEGES, PCB [PCB$Q_PRIV]);
    MOVE_PRIV_MASK (PRIVILEGES, PHD [PHD$Q_PRIVMSK]);

    ! The address of the image header buffer must be stored in the pointer page

    CTL$GL_IMGHDRBF = .OWN_STORAGE [BUFFER_ADDRESS];

    ! Finally, if image accounting was requested for this image, then the various
    ! image accounting cells must be initialized.

    IF .OWN_STORAGE [IMAGE_ACCOUNT] OR .EXE$GL_ACMFLAGS [ACM$V_IMAGE]
    THEN
        BEGIN
        CTL$GL_ICPUTIM = .PHD [PHD$L_CPUTIM];
        CTL$GL_IFAULTS = .PHD [PHD$L_PAGEFLTS];
        CTL$GL_IFAULTIO = .PHD [PHD$L_PGFLTIO];
        CTL$GL_IWSPEAK = 0;
        CTL$GL_IPAGEFL = 0;
        CTL$GL_IDIOCNT = .PHD [PHD$L_DIOCNT];
        CTL$GL_IBIOCNT = .PHD [PHD$L_BIOCNT];
        CTL$GL_IVOLUMES = .CTL$GL_VOLUMES;
        CTL$GQ_ISTART [0] = .EXE$GQ_SYSTIME [0];
        CTL$GQ_ISTART [1] = .EXE$GQ_SYSTIME [1];
        END;

    END;				! End of test for main program

! The USECNT cell in each KFE must be incremented. In addition, any shared WCB
! must have its REFCNT incremented. If the adjusted REFCNT is larger than the
! current high water REFCNT in the KFE, the KFE cell is adjusted. Finally, the
! DONE bit in the ICB is turned ON, indicating that the activation for each of
! these ICBs is complete.

    ICB = .IAC$GL_IMAGE_LIST;
    DO
        BEGIN
     
        LOCAL
            KFE : REF $BBLOCK,
            WCB : REF $BBLOCK;
    
        IF NOT .ICB [ICB$V_DONE]
        THEN
            BEGIN
            ICB [ICB$V_DONE] = TRUE;
            KFE = .ICB [ICB$L_KFE];
            IF .KFE NEQU 0
            THEN
                BEGIN
                KFE [KFE$L_USECNT] = .KFE [KFE$L_USECNT] + 1;
                IF .KFE [KFE$V_OPEN]
                THEN
                    BEGIN
                    WCB = .KFE [KFE$L_WCB];
                    IF .WCB [WCB$W_REFCNT] GTRU .KFE [KFE$W_SHRCNT]
                    THEN KFE [KFE$W_SHRCNT] = .WCB [WCB$W_REFCNT];
                    END;
                END;
            END;
        ICB = .ICB [ICB$L_FLINK];
        END
    UNTIL .ICB EQLA IAC$GL_IMAGE_LIST;

IF .OWN_STORAGE [RMS_BASE] NEQU 0
THEN CTL$GL_RMSBASE = .OWN_STORAGE [RMS_BASE];

RETURN SS$_NORMAL

END;

%SBTTL 'GET_LOCK - Lock Known File Data Base for Read Access'

ROUTINE GET_LOCK =

!+
! Functional Description:
!
!    This routine locks the known file data base for read access. The image
!    activator maintains this lock for the entire time that it will be opening
!    files. Note that no lock is taken out during system initialization. until
!    INSTALL first executes and sets up the known file lists (and loads
!    EXE$GL_KNOWN_FILES with nonzero contents. 
!
! Calling Sequence:
!
!    GET_LOCK ()
!-

BEGIN

LOCAL STATUS;

IF .EXE$GL_KNOWN_FILES NEQ 0
THEN
    BEGIN

    STATUS = $ENQW (
        EFN = EXE$C_SYSEFN,
        LKMODE = LCK$K_PRMODE,
        LKSB = OWN_STORAGE [LOCK_STATUS_BLOCK],
        FLAGS = LCK$M_SYSTEM,
        RESNAM = EXE$GQ_KFE_LCKNAM,
        PARID = .EXE$GL_SYSID_LOCK,
        ACMODE = PSL$C_EXEC);		! End of routine GET_LOCK

    IF NOT .STATUS
    THEN RETURN .STATUS
    ELSE RETURN .OWN_STORAGE [LOCK_STATUS];
    
    END
ELSE	! No need to take out a lock yet
    RETURN SS$_NORMAL

END;

%SBTTL 'RELEASE_LOCK - Unlock Lock Known File Data Base'

ROUTINE RELEASE_LOCK =

!+
! Functional Description:
!
!    This routine unlocks the known file data base. This happens when
!    the image activator reaches the point where there are no more files
!    to open, or when an error occurs with the lock granted.
!
! Calling Sequence:
!
!    RELEASE_LOCK ()
!-

IF .OWN_STORAGE [LOCK_ID] NEQ 0
THEN
    $DEQ (LKID = .OWN_STORAGE [LOCK_ID])
ELSE
    SS$_NORMAL;				! End of routine RELEASE_LOCK

%SBTTL 'IMG$ALLOCATE_ICB - Lock Known File Data Base for Read Access'

GLOBAL ROUTINE IMG$ALLOCATE_ICB (ICB_POINTER) =

!+
! Functional Description:
!
!    This routine allocates an image control block for use by later stages
!    of the image activator. An allocation request is first made from a
!    pool of previously used ICBs. A trip into kernel mode is thus only
!    required if this lookaside list request fails. In either case, the
!    ICB is entirely filled with zeros.
!
!    Note that only the process allocation region is used to insure that
!    no ICBs are created in P0 space. This would be no problem on merged
!    activations but would mess up the simple execution of an image.
!
! Calling Sequence:
!
!    IMG$ALLOCATE_ICB (ICB_POINTER)
!
! Formal Parameter:
!
!    ICB_POINTER - Address of cell that will receive the address of a newly
!    allocated image control block.
!
! Status Return:
!
!    SS$_NORMAL  - ICB successfully allocated
!
!    SS$_INSFMEM - Unable to allocate ICB
!-

BEGIN

LOCAL
    SIZE,
    ICB : REF $BBLOCK;

IF REMQUE (.IAC$GL_ICBFL, ICB)
THEN IF NOT EXE$ALOP1PROC (ICB$K_LENGTH; SIZE, ICB)
     THEN RETURN SS$_INSFMEM;
CH$FILL (0, ICB$K_LENGTH, .ICB);
ICB [ICB$W_SIZE] = ICB$K_LENGTH;
ICB [ICB$B_TYPE] = ICB$K_ICB_TYPE_CODE;
ICB [ICB$L_STARTING_ADDRESS] = -1;
ICB [ICB$L_END_ADDRESS] = -1;
.ICB_POINTER = .ICB;
RETURN SS$_NORMAL;

END;

%SBTTL 'IMG$DEALLOCATE_ICB - Deallocate an Unused ICB'

GLOBAL ROUTINE IMG$DEALLOCATE_ICB (ICB) : NOVALUE =

!+
! Functional Description:
!
!    This routine deallocates an ICB that was not used. This can be due to
!    one of three reasons:
!
!        The current image is being rundown, thus releasing all of its
!        image control blocks back to pool.
!
!        An ICB was allocated during image activation for an image that
!        has already been activated.
!
!        An error occurred, requiring that all images activated during the
!        current call be eliminated.
!
!    If the ICB was allocated from P1 space, it is deallocated to a linked
!    list of free ICBs that will be used during later activations. ICBs
!    allocated from P0 space use the normal deallocation routine.
!
! Calling Sequence:
!
!    IMG$DEALLOCATE_ICB (ICB_ADDRESS)
!
! Formal Parameter:
!
!    ICB_ADDRESS - Address of ICB that is being deallocated
!-

BEGIN

MAP
    ICB : REF $BBLOCK;

BIND VA = ICB : $BBLOCK;

IF .VA [VA$V_P1]
THEN INSQUE (.ICB, .IAC$GL_ICBFL [1])	! Insert at tail of lookaside list
ELSE EXE$DEAP1 (.ICB, .ICB [ICB$W_SIZE]);

END;

%SBTTL 'SET_VECTORS - Prepare privileged vectors for execution'

ROUTINE SET_VECTORS =

!+
! Functional Description:
!
!    This routine takes the privileged vector entries that contain RSB 
!    instructions and replaces each with a JSB instruction.
!
! Calling Sequence:
!
!    SET_VECTORS ()
!
! Input Parameters:
!
!    none
!
! Implicit Input:
!
!    IAC$AW_VECSET - Array that locates the dividing point in each vector
!	list between those vectors that already existed and those that were
!	added as part of the latest activation. This is the starting point for
!	the search. 
!
!    CTL$A_DISPVEC - This address locates the start of the two-page area
!	containing the privileged vectors. The first longword of each area
!	contains the current end of the vector list. This is the end point for
!	the search. 
!-

BEGIN

LITERAL
    ABSOLUTE_MODE = %X'9F',    
    JSB_ABSOLUTE = (ABSOLUTE_MODE ^ 8) OR OP$_JSB : UNSIGNED (16),
    RSB_ABSOLUTE = (ABSOLUTE_MODE ^ 8) OR OP$_RSB : UNSIGNED (16);

LOCAL
    I, J;

INCRU I FROM 0 TO 3 DO
    BEGIN

    BIND 
        END_POINT = CTL$A_DISPVEC + (.I * 256) : LONG,
        DISPVEC = CTL$A_DISPVEC + (.I * 256) : VECTOR [256,BYTE];

    J = .IAC$AW_VECSET [.I];
    WHILE .J LSSU .END_POINT DO

        BEGIN    

        BIND OPCODE = DISPVEC [.J] : WORD;

        IF .OPCODE EQLU RSB_ABSOLUTE
        THEN OPCODE = JSB_ABSOLUTE;

        J = .J + 6;

        END;

    IAC$AW_VECSET [.I] = .END_POINT;

    END;

RETURN SS$_NORMAL;

END;

%SBTTL 'ERROR_CLEAN_UP - Clean Up after an Error is Detected'

ROUTINE ERROR_CLEAN_UP : NOVALUE =

!+
! Functional Description:
!
!    This routine cleans up when an error is detected after some successful 
!    work has been completed. 
!
!        All ICBs on the WORK list are simply deallocated. 
!
!        ICBs that exist on the IMAGE (so-called done) list with the DONE bit
!        clear indicate images that have been successfully activated as a part
!        of this activation before an error was detected. 
!
!            The address space associated with these images is deleted. 
!
!            The channel on which each image file was opened is closed. 
!
!            Each ICB is then deallocated. 
!
!        Note that an ICB with no addresses yet mapped will have an address
!        range of -1, -1. The error from $DELTVA in this case is ignored.
!
! Calling Sequence:
!
!    ERROR_CLEAN_UP ()
!
! Formal Parameters:
!
!    none
!
! Implicit Input:
!
!    IAC$GL_IMAGE_LIST - List of ICBs representing images that have been
!        successfully activated
!
!    IAC$GL_WORK_LIST - List of ICBs representing work left to be done.
!-

BEGIN

LOCAL 
    ICB      : REF $BBLOCK,
    NEXT_ICB : REF $BBLOCK;

! Simply deallocate the ICBs in the work list

WHILE NOT (REMQUE (.IAC$GL_WORK_LIST, ICB)) DO
    IMG$DEALLOCATE_ICB (.ICB);

! Traverse the done list, looking for ICBs with the done bit not yet set.

NEXT_ICB = .IAC$GL_IMAGE_LIST;

WHILE .NEXT_ICB NEQA IAC$GL_IMAGE_LIST DO
    IF .NEXT_ICB [ICB$V_DONE]
    THEN
        NEXT_ICB = .NEXT_ICB [ICB$L_FLINK]
    ELSE
        BEGIN
        REMQUE (.NEXT_ICB, ICB);
        $DELTVA (INADR = ICB [ICB$Q_ADDRESS_RANGE]);
        $DASSGN (CHAN = .ICB [ICB$W_CHAN]);
        NEXT_ICB = .ICB [ICB$L_FLINK];
        IMG$DEALLOCATE_ICB (.ICB);
        END;

IAC$GL_IMAGCTX [IMAGCTX$V_SETVECTOR] = FALSE;

END;

%SBTTL 'GET_OTHER_IMAGE - Open Primary Image File'

ROUTINE GET_OTHER_IMAGE (ICB) = 

!+
! Functional Description:
!
!    This routine is called when the image passed to the image activator is not
!    really the image that should be activated. This situation occurs in the
!    case of compatibility mode images and other specialized cases. The general
!    operation of this routine is as follows. 
!
!        Information about the original image is stored in various places so
!        that it is available to the image that eventually gets activated. 
!
!        A new image name is selected based on the alias code. 
!
!        This new image file is opened and its header decoded. 
!
!    Activation continues with the secondary image replacing the original image
!    as the target of activation.
!
! Calling Sequence:
!
!    GET_OTHER_IMAGE (ICB address)
!
! Input Parameter:
!
!    ICB - Address of image control block that describes the primary image
!
! Output Parameters:
!
!    none
!
! Implicit Output:
!
!    The image name of the primary image is stored in the compatibility mode
!    data page. The channel on which the primary image is opened (and its KFE
!    address if any) is stored for later return to the caller.
!
! Assumption:
!
!    This routine can only be called from the main loop in the image activator.
!    This means that the primary buffers (FAB, NAM, IHD, etc.) describe the
!    original image.
!-

BEGIN

MAP
    ICB						: REF $BBLOCK;

BIND
    IHD_CTX     = .ICB [ICB$L_CONTEXT]		: $BBLOCK,
    ICB_NAME    = ICB [ICB$T_IMAGE_NAME]	: VECTOR [, BYTE],
    FAB         = PRIMARY_FAB			: $BBLOCK,
    NAM         = PRIMARY_NAM			: $BBLOCK,
    STORED_NAME = CTL$AG_CMEDATA		: VECTOR [, BYTE];

! The image name for a type 2 image is stored in the last 126 bytes of the
! first block of the image header as a counted ASCII string.

MAP
    INPUT_BUFFER				: VECTOR [512, BYTE];

BIND
    TYPE_2_IMAGE_NAME = 
        INPUT_BUFFER [512 - 128]		: VECTOR [128 - 2, BYTE];

! Three of the four cases handled by this routine activate specific images
! whose names are listed here. (The fourth case extracts the image name from 
! the end of the first block of the image header.)

BIND
    RSX_NAME = $DESCRIPTOR ('RSX'),
    BPA_NAME = $DESCRIPTOR ('BPA'),
    LOGIN_NAME = $DESCRIPTOR ('LOGINOUT'),

    ! All four cases use SYS$SYSTEM as the default directory string

    SYSTEM_NAME = $DESCRIPTOR ('SYS$SYSTEM:.EXE');

LOCAL
    NEW_IMAGE_NAME,
    NEW_IMAGE_NAME_DESC			: $BBLOCK [DSC$K_S_BLN],
    STATUS;

OWN_STORAGE [OTHER_CHANNEL] = .ICB [ICB$W_CHAN];
OWN_STORAGE [OTHER_KFE_ADDRESS] = .FAB [FAB$L_CTX];

! Now perform the steps that are specific to the type of other image that is
! being selected. The name of the image to activate is the most important
! part of this step.

CASE .IHD_CTX [CTX_W_ALIAS] FROM IHD$C_RSX TO IHD$C_CLI OF

    SET

    [IHD$C_RSX]:

        ! This is an image produced by the RSX-11M task builder. Activate
        ! SYS$SYSTEM:RSX.EXE in its stead.

        NEW_IMAGE_NAME = RSX_NAME;

    [IHD$C_BPA]:

        ! There is no supported way that this type of image can be created. We
        ! will activate SYS$SYSTEM:BPA.EXE anyway and let the chips fall ...

        NEW_IMAGE_NAME = BPA_NAME;

    [IHD$C_ALIAS]:

        ! This is a special form of image that contains the name of a second
        ! image in the last 128 bytes of the first block of the image header.
        ! (The actual name is restricted to 125 bytes because the last word
        ! of the first block is reserved to contain the code word and the
        ! string contains a count byte.)

	BEGIN

        NEW_IMAGE_NAME_DESC [DSC$W_LENGTH] = .TYPE_2_IMAGE_NAME [0];
        NEW_IMAGE_NAME_DESC [DSC$A_POINTER] = TYPE_2_IMAGE_NAME [1];

        NEW_IMAGE_NAME = NEW_IMAGE_NAME_DESC;

	END;

    [IHD$C_CLI]:

        ! The image is a command language interpreter whose name was passed to
        ! the Create Process system service. If this is the activation of a main
        ! program (and not a merged activation, the usual way to put a CLI into
        ! P1 space), we will activate SYS$SYSTEM:LOGINOUT.EXE. In this case, we
        ! will close the CLI image file first (by deassigning the channel) because 
        ! LOGINOUT uses a more restrictive form of $OPEN than occurred above.

        IF .OWN_STORAGE [MAIN_PROGRAM]
        THEN
            BEGIN

            $DASSGN (CHAN = .ICB [ICB$W_CHAN]);
            NEW_IMAGE_NAME = LOGIN_NAME;

            END
        ELSE
            RETURN SS$_NORMAL;

    [OUTRANGE]:

        RETURN SS$_BADIMGHDR;

    TES;

! Any context established by the original image must be cleared before
! the activation continues. 

ICB [ICB$L_FLAGS] = 0;			! Clear previous activation flags
ICB [ICB$L_IHD] = 0;			! Clear pointer to resident header
IHD_CTX [CTX_L_IHDBUF] = PRIMARY_IHD;	! Reestablish IHD buffer

! If the primary image was a CLI (type 3), only the file name is stored. In
! all other cases, the entire resultant (or expanded) string is stored.

IF .IHD_CTX [CTX_W_ALIAS] EQL IHD$C_CLI
THEN
    BEGIN
    STORED_NAME [0] = .NAM [NAM$B_NAME];
    CH$MOVE (.STORED_NAME [0], .NAM [NAM$L_NAME], STORED_NAME [1]);
    END
ELSE
    BEGIN
    STORED_NAME [0] = .NAM [NAM$B_RSL];
    CH$MOVE (.STORED_NAME [0], .NAM [NAM$L_RSA], STORED_NAME [1]);
    END;

! Open the secondary image file, decode the image header, and resume processing
! in the main routine as if the secondary image were the one selected for
! activation.

ICB_NAME [0] = 0;			! Force a new name to be stored in ICB

STATUS = IMG$OPEN_IMAGE (		! Open the image file
    .NEW_IMAGE_NAME,
    SYSTEM_NAME,
    PRIMARY_FAB,
    PRIMARY_NAM,
    RESULT_NAME,
    .ICB);
IF NOT .STATUS 
THEN RETURN .STATUS;

STATUS = IMG$GET_HEADER (.ICB);		! Decode and store away the IHD contents
RETURN .STATUS;

END;


END					! End of module SYS$IMGACT

ELUDOM
