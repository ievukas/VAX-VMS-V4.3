	.TITLE	MONITOR	- VAX/VMS Performance Monitor Utility
	.IDENT	'V04-000'

;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************

;++
; FACILITY:  VAX/VMS MONITOR Utility
;
; ABSTRACT:
;
;	This module is a collection of routines which are called by
;	the MONMAIN, REQUEST, and COLLEVT PL/I routines to do
;	various tasks, including data collection, terminal I/O
;	(through the use of the Screen Package) and maintenance
;	of statistics for screen displays.
;
; ENVIRONMENT:
;
;	Unprivileged user mode,
;	except for certain collection routines which
;	run in EXEC or KERNEL mode to access system
;	data bases.
;
; AUTHOR: Thomas L. Cafarella, April, 1981
;
; MODIFIED BY:
;
;	V03-027	TLC1090		Thomas L. Cafarella	02-Aug-1984	15:00
;		Correct ACCVIOs in SYSTEM and PROCESSES classes.
;
;	V03-026	TLC1087		Thomas L. Cafarella	25-Jul-1984	15:00
;		Default to /ALL when summarizing.
;
;	V03-025	TLC1086		Thomas L. Cafarella	24-Jul-1984	14:00
;		Make top summary work for SYSTEM class.
;
;	V03-024	TLC1085		Thomas L. Cafarella	22-Jul-1984	14:00
;		Calculate scale values for Free and Modified List bar graphs.
;
;	V03-024	TLC1083		Thomas L. Cafarella	20-Jul-1984	11:00
;		If counter value decreases, use 0 for delta.
;
;	V03-023	TLC1081		Thomas L. Cafarella	18-Jul-1984	11:00
;		Correct use of R6 in PROCESSES /TOP display.
;
;	V03-022	TLC1078		Thomas L. Cafarella	11-Jul-1984	11:00
;		Use SCSNODE node name if present before using SYS$NODE.
;
;	V03-021	TLC1072		Thomas L. Cafarella	17-Apr-1984	11:00
;		Add volume name to DISK display.
;
;	V03-020	PRS1019		Paul R. Senn		11-Apr-1984	16:00
;		Fix /SUMMARY for SYSTEM class.
;
;	V03-020	PRS1018		Paul R. Senn		11-Apr-1984	9:00
;		Display CPU busy instead of CPU idle in SYSTEM class.
;
;	V03-020	TLC1066		Thomas L. Cafarella	01-Apr-1984	11:00
;		Add SYSTEM class.
;
;	V03-020	TLC1063		Thomas L. Cafarella	3-Apr-1984	13:00
;		Add check to ensure that a counter which is re-inited to
;		zero will not cause an **** to be displayed.
;
;	V03-020	PRS1015		Paul R. Senn		3-Apr-1984	15:00
;		add shared error message capability
;
;	V03-020	TLC1062		Thomas L. Cafarella	31-Mar-1984	23:00
;		Fix bug causing summary averages to be displayed as zeroes
;		for homogeneous classes.
;
;	V03-019	TLC1061		Thomas L. Cafarella	18-Mar-1984	11:00
;		Identify dual-path disks by allocation class.
;
;	V03-019	TLC1060		Thomas L. Cafarella	12-Mar-1984	11:00
;		Make multi-file summary work for homogeneous classes.
;
;	V03-018	PRS1008		Paul R. Senn		17-FEB-1984	14:00
;		Move GET_BUFFERS and associated subroutines into separate 
;		module.
;
;	V03-018	PRS1006		Paul R. Senn		17-FEB-1984	14:00
;		Add support for "computed" items 
;
;	V03-018	TLC1052		Thomas L. Cafarella	17-Feb-1984	11:00
;		Add multi-file summary capability.
;
;	V03-017	PRS1005		Paul R. Senn		13-JAN-1984	10:00
;		Allow flexible spacing between screen items
;
;	V03-016	TLC1051		Thomas L. Cafarella	11-Jan-1984	11:00
;		Add consecutive number to class header record.
;
;	V03-016	PRS1002		Paul R. Senn		29-Dec-1983	16:00
;		Add YES and NO global equated symbols, which are no longer 
;		defined	globally by MONMAIN,
;
;	V03-016	PRS1000		Paul R. Senn		15-Dec-1983	16:00
;		For cases where one display event may involve multiple
;		screens of data (such as PROCESSES and Homogeneous 
;		classes), make the wait between screens = VIEWING_TIME,
;		instead of a constant of 2 seconds.
;
;	V03-015	TLC1050		Thomas L. Cafarella	06-Dec-1983	11:00
;		Change directory information in DLOCK class.
;
;	V03-015	TLC1049		Thomas L. Cafarella	10-Oct-1983	15:00
;		Position TOP bar display properly.
;
;	V03-014	TLC1048		Thomas L. Cafarella	11-Sep-1983	12:00
;		Remove UIC from PROCESSES displays.
;
;	V03-013	TLC1047		Thomas L. Cafarella	09-Sep-1983	10:00
;		De-establish CTRL/W handler to get back AST quota.
;
;	V03-012	TLC1043		Thomas L. Cafarella	30-Jul-1983	13:00
;		Eliminate special characters from node name.
;
;	V03-012	SPC0004		Stephen P. Carney	24-Jun-1983	16:00
;		Add SCS display subroutine for new SCS Class.  Add FAO and
;		ASCII string for SCS class.
;
;	V03-011	TLC1042		Thomas L. Cafarella	19-Jun-1983	15:00
;		Add /ITEM qualifier for homogeneous classes.
;
;	V03-011	TLC1039		Thomas L. Cafarella	15-Jun-1983	15:00
;		Add DECnet node name to heading.
;
;	V03-011	TLC1036		Thomas L. Cafarella	10-Jun-1983	15:00
;		Properly recognize Revision Level 0.
;
;	V03-010	TLC1035		Thomas L. Cafarella	06-Jun-1983	15:00
;		Add homogeneous class type and DISK class.
;
;	V03-009	TLC1030		Thomas L. Cafarella	25-Apr-1983	10:00
;		Initialize MIN and MAX buffers.
;
;	V03-009	TLC1029		Thomas L. Cafarella	21-Apr-1983	10:00
;		Correctly calculate "Interrupt Stack" string.
;
;	V03-008	TLC1028		Thomas L. Cafarella	14-Apr-1983	16:00
;		Add interactive user interface.
;
;	V03-008	TLC1027		Thomas L. Cafarella	14-Apr-1983	16:00
;		Enhance file compatibility features.
;
;	V03-008	SPC0001		Stephen P. Carney	25-Mar-1983	15:00
;		Add RWxxx and MUTEX states in place of MWAIT state.
;
;	V03-007	TLC1024		Thomas L. Cafarella	1-Mar-1983	11:00
;		Convert an IPID to an EPID before placing it on the FAO
;		stack (for MONITOR PROCESSES display).
;
;	V03-006	TLC1021		Thomas L. Cafarella	07-Jul-1982	16:00
;		Change $SSDEF symbols to GLOBAL since they are no longer
;		accessible at link time.
;
;	V03-005	TLC1018		Thomas L. Cafarella	12-Apr-1982	16:00
;		Collect all data at KERNEL mode instead of EXEC.
;
;	V03-004	TLC1016		Thomas L. Cafarella	02-Apr-1982	16:00
;		Replace references to EXE$GQ_SYSTIME with $GETTIM calls.
;
;	V03-004	TLC1015		Thomas L. Cafarella	01-Apr-1982	16:00
;		Change .PSECT options in order to group image sections.
;
;	V03-004	TLC1014		Thomas L. Cafarella	01-Apr-1982	13:00
;		Correct attached processor time reporting for MODES class.
;
;	V03-004	TLC1012		Thomas L. Cafarella	30-Mar-1982	13:00
;		Display user's comment string on screen line 5.
;
;	V03-003	TLC1008		Thomas L. Cafarella	28-Mar-1981	21:00
;		Fix to display first and last PROCESSES records on playback.
;
;	V03-002	TLC1002		Thomas L. Cafarella	20-Mar-1981	13:00
;		Change PROCESSES display from scroll-style to page-style to
;			make it terminal-independent.
;
;		Widen working set field of PROCESSES display.
;
;		Reset DEC_CRT advanced video options at exit.
;
;	V03-001	TLC1001		Thomas L. Cafarella	16-Mar-1981	13:00
;		Add CTRL-W screen refresh support.
;
;--

	.SBTTL	DECLARATIONS
	.PSECT	MONDATA,QUAD,NOEXE
;
; INCLUDE FILES:
;

	$DCDEF				; define device class codes
	$DIBDEF				; define device information block
	$DSCDEF				; Descriptor Definitions
	$IODEF				; insert I/O function codes
	$IPLDEF				; define interrupt levels
	$JPIDEF				; define GETJPI items
	$PCBDEF				; process control block
	$PHDDEF				; process header definitions
	$PRDEF				; define processor registers
	$PSLDEF				; define PSL fields
	$RPBDEF				; define Restart Parameter Block
	$RSNDEF				; define resource wait codes
	$SCRDEF				; SCRPKG definitions
	$SSDEF	GLOBAL			; define status codes
	$STATEDEF			; define process state codes
	$STSDEF				; define status fields
	$SYIDEF				; define GETSYI item identifiers
	$SHRDEF				; define shared error codes
	$TTDEF				; define terinal functions

	$CDBDEF				; Define Class Descriptor Block
	$CDXDEF				; Define CDB Extension
	$CHDDEF				; Define CHange Descriptor
	$IDBDEF				; define item descriptor block offsets
	$MRBDEF				; Define Monitor Request Block
	$MBPDEF				; Define Monitor Buffer Pointers
	$MCADEF				; Define Monitor Communication Area
	$MONDEF				; Monitor Recording File Definitions
	$SCBDEF				; Define STATS Control Block
	$MFSDEF				; Define Multi-File Summary Block
	$TM4DEF				; Define temporary storage

;
; MACROS:
;

;
; Local Macro Definitions
;

;
; ALLOC Macro - Dynamically allocate space on the stack.
;

	.MACRO	ALLOC	LENGTH,RSLDESC,RSLBUF
	SUBL	#<LENGTH+3>&<^C3>,SP
	.IF	NB,RSLBUF
	MOVL	SP,RSLBUF
	.ENDC
	PUSHL	SP
	PUSHL	#LENGTH
	MOVL	SP,RSLDESC
	.ENDM	ALLOC


;
; EQUATED SYMBOLS:
;

					; Codes for MOVE_CLASS_QUALS routine:
YES == 1				; Yep
NO == 0					; Nope
DEF_TO_CUR == 0				; Move default values to current values
CUR_TO_ACT == 1				; Move current values to active values
ACT_TO_CUR == 2				; Move active values to current values
ALL_TO_ACT == 3				; Move ALL statistic value to active

COLL_BUFS == 2				; Number of collection  buffers
REG_BUFS == 4				; Number of "regular stats" buffers
PC_BUFS == 4				; Number of "percent stats" buffers

LARGE_NO == ^X7FFF7FFF			; Very large number (integer or float)

CR = 13					; carriage return
ESC = 27				; escape character
LF = 10					; line feed
SI = 15					; shift in (selects G0 char set on VT100)
BS_SECS = 2				; seconds between screens (of a mult scr)
MAXBARS == 40				; number of bar chars in horiz. graph
MAXBARS_SYS == 26			; same as above for SYSTEM display
DEF_BAR = ^A/*/				; default bar character (for hardcopy)
VID_BAR = ^A/a/				; video terminal bar character
MAX55HEIGHT = 200			; max height of vertical bars (VT55)
STARTPOS = 50				; stavt of bargraph position
START_XPOS = 34+4			; starting x position for VT55 bar
VTHEIGHT == 24				; number of rows on screen
VTWIDTH == 80				; number of columns on screen
FIRST_DATA_LINE == 8			; line no of 1st data line on screen
LAST_DATA_LINE == 22			; line no of last data line on screen
VTDATALINES == LAST_DATA_LINE - FIRST_DATA_LINE + 1
					; number of lines of actual data on screen
VT55CWIDTH == 74			; number of chars. on x axis
VT55HEIGHT = 236			; screen height in points
VT55WIDTH = 512				; screen width in points
NAME_COL_TAB == 5			; starting col no. for names -- tabular
NAME_COL_BAR == 2			; starting col no. for names -- bar graph
NAME_COL_MFSUM == 1			; starting col no. for names -- m.f. summ.
PROC_LINE = 75				; width of a PROCESSES display line
PUTS_REGSET = 0				; value for reg graphics set to PUT_SCREEN
PUTS_ALTSET = 0				; value for alt graphics set to PUT_SCREEN
MAXELTS == 200				; max no. of elements for a homog class
MAXELTS_MFS == MAXELTS*2		; max no. of homog elts in a m.f. summary
MAX_ELIDLEN == 27			; max length of an element ID for homog
MAX_HOM_ITEMS == 15			; max no. of items in a homog class
SCRDSC_SIZE = 512			; screen package buffer size
FAOSTK_SIZE = MAXELTS*8*4		; size of FAOL parameter stack for data displays
OUTDSC_SIZE = 1700			; size of FAO output buffer for displays
FAOCTR_SIZE == 1500			; size in bytes of FAO control string
PUTMSGSIZE = 26				; size in longwords of $PUTMSG message arg vector
MAX_REC_SIZE == 32000			; maximum record size for PLAYBACK and RECORD files
SYS_FAC_NO = 0				; system facility code
TAB_LWORDS = 8				; Define no. of FAOSTK longwords ...
					; ... for tabular display. Used by
					; ... FILL_HOMOG_SCREEN routine.

BAR_LWORDS = 3				; Define no. of FAOSTK longwords ...
					; ... for bar-graph display. Used by
					; ... FILL_HOMOG_SCREEN routine.

;
; SYS$OUTPUT Device types for Monitor
; Loaded into SYSOUT_TYPE
;
DEC_CRT   = 0				; includes VT100-compatible devices
VT5X      = 1				; VT5x series (VT52 and VT55)
HARDCOPY  = 2				; hardcopy terminal and disk file
OTHER_VID = 3				; other video types

;
; Monitor status codes which use shared error codes.
;

;
;   **** NOTE ****	The MONITOR facility number is defined here and in
;			MONMSG.MSG. Any change needs to be made in BOTH places.
;

FACNO = 206				; local symbol for monitor facility #

MNR$_OPENIN == <SHR$_OPENIN+STS$K_ERROR>!<FACNO@16>  ;open-input-file error

;
; OWN STORAGE:
;

NAME_COL::	.BLKB	1		; column number of name string
BARSIZE::	.LONG	25		; width of bar graph in points (VT55)
BARCHAR::	.BLKB	1		; bar graph character
BPU:		.BLKF	1		; no of bar chars per unit of output value
GMIN:		.BLKL	1		; min value which bar graph can represent
CURGRAPH::	.LONG	0		; currently enabled VT55 graph
CURXPOS:	.LONG	0		; current position for GRAPH6
PROCS_PER_REC:	.LONG	0		; number of processes which can fit into a ...
					; ... single PLAYBACK or RECORD file class record
PROC_WRI_BUFD:	.LONG	0,0		; PROCESSES write buffer descriptor
TOP_PROCS:	.BLKB	1		; number of top processes to display
TOP_TIME:	.BLKQ	1		; collection time of most recent TOP
					; ... display (in system time units)
TOP_TICKS:	.BLKL	1		; number of clock ticks (10ms units)
					; ... covered by most recent TOP display

S_TOP_TIME:	.BLKQ	1		; similar to above, but for SYSTEM
					; ... class
S_TOP_TICKS:	.BLKL	1		; ...
					; ...
SYS_TOP_VEC::	.BLKL	16		; vector of ptrs to SYSTEM TOP arrays
SYS_DATA_ADDR::	.LONG	0		; addr of the SYSTEM TOP arrays
SYS_DATA_LEN::	.LONG	0		; len of the SYSTEM TOP arrays

SYS_BOX_STR_LEN:: .BLKW	1		; len of SYSTEM box string
SYS_BOX_STR_ADDR:: .BLKL 1		; ... and its address
NEWXPOS:	.LONG	0		; next point to plot for GRAPH6
PTS_STAT:	.BLKL	1		; save area for SCRPKG return stati

CTRLW_MASK:	.LONG	0		; mask required by QIO for out-of-band char
		.LONG	^X00800000	; bit 23 representing CTRL-W

CTRLZ_MASK:	.LONG	0		; mask required by QIO for out-of-band char
		.LONG	^X04000000	; bit 26 representing CTRL-Z

CTRLCZ_CHAN::	.LONG	0		; channel no. for CTRL-C and -Z
CTRLW_CHAN::	.LONG	0		; channel no. for CTRL-W

BET_SCREENS:	.LONG	-10*1000*1000*BS_SECS ; delta time between
		.LONG	-1		; ... screens for single display event

SYSCMD_DESC:	.ASCID	\SYS$COMMAND\	; User command terminal
SYSNOD_NAM:	.ASCID	\SYS$NODE\	; DECnet node logical name

VT55XINCR::	.LONG	0		; incr to next bar of graph

CB_ADDRS::	.BLKQ	1		; holds coll buffer addrs in GET_BUFFERS
ITEM_TYPE:	.BLKW	1		; holds IDB item type code in FILL_DISP_BUFF
HOMOG_TYPE:	.BLKW	1		; holds same as above in COMPUTE_STATS

PREV_PD:	.BLKL	1		; no. of processes displayed in previous interval

PROMPT_STR::				; string and descriptor for
					; ... subcommand prompt string
		.LONG	20$-10$
		.LONG	10$
10$:		.BYTE	CR,LF
		.ASCII	\MONITOR> \
20$:

DYN_STRING::				; dynamic string descriptor for 
					; ... use in MONMAIN.PLI
		.WORD	0		; called routine will fill in length
		.BYTE	DSC$K_DTYPE_T	; string descriptor type
		.BYTE	DSC$K_CLASS_D	; dynamic class
		.LONG	0		; called routine will fill in address


;
; FAO-related buffers required for /DISPLAY
;

FAOSTK::	.BLKB	FAOSTK_SIZE	; DISPLAY buffer containing data for input to FAO

OUTDSC::				; FAO output buffer descriptor for data displays
		.LONG	OUTDSC_SIZE
		.LONG	10$
10$:		.BLKB	OUTDSC_SIZE

SCRDSC::				; Screen Package buffer descriptor
		.LONG	SCRDSC_SIZE
		.LONG	10$
10$:		.BLKB	SCRDSC_SIZE

;
; Control and name strings for screen output.
;
; These strings contain embedded escape sequences. Before the strings
; are sent to the Screen Package for output, the escape sequences are
; interpreted (in the PUT_TO_SCREEN routine) and translated to general-
; case screen package calls. The sequences embedded below are generally
; equivalent to VT52 escape sequences, with the following exceptions:
;
;	1) Cursor addresses for both row and column are in the
;	   form acceptable to the Screen Package -- i.e., the top
;	   row is 1 and the left-hand column is 1.
;
;	2) ESC B means BOLD all text until an UNDO sequence.
;
;	3) ESC L means UNDERLINE all text until an UNDO sequence.
;
;	4) ESC R means REVERSE VIDEO all text until an UNDO sequence.
;
;	5) ESC U means UNDO all DEC_CRT advanced video attributes selected
;				(i.e., BOLD, UNDERLINE, REVERSE, BLINK)
;

CLRVT55::
	.BYTE	10$-5$
5$:
	.BYTE	ESC,^A/1/		; enter graphics mode
	.BYTE	^A/A/,^X20		; turn off graphs
	.BYTE	^A/I/,^X30		; turn off lines, cursors, etc.
	.BYTE	ESC,^A/2/		; back to alphanumeric mode
10$:

NAMESTR::
	.BYTE	10$-5$
5$:	.BYTE	CR
	.ASCII	'!#*'
	.BYTE	LF
	.ASCII	'!AC'
10$:

;
; Finish sequence -- set regular character set,
; reset DEC_CRT (VT100) AVO characteristics, and 
; carriage return.
;

FIN_SEQ::
	.BYTE	10$-5$
5$:	.BYTE	ESC,^A/G/	; Set regular character set
	.BYTE	ESC,^A/B/,ESC,^A/L/,ESC,^A/R/
				; Set AVO char'cs so UNDO works
	.BYTE	CR		; Need to send a character to set attribs
	.BYTE	ESC,^A/U/	; Undo DEC_CRT AVO characteristics
	.BYTE	CR
10$:

;
; Sequence to place the cursor on the bottom line and clear it.
;

BOT_CURS::
	.BYTE	10$-5$
5$:	.BYTE	ESC,^A/Y/,24,1		; Position to bottom line on screen
	.BYTE	ESC,^A/K/		; Clear to end of line
10$:

;
; Announcement string, including home and clear screen, set regular
; char set, and identification (top line of the screen).
;

ANNCE_STR::
	.BYTE	10$-5$
5$:	.BYTE	ESC,^A/G/,ESC,^A/H/,ESC,^A/J/,ESC,^A/Y/,1,29
	.ASCII	\VAX/VMS Monitor Utility\
10$:

;
; Status string. This is bottom line (footing) of the screen.
; It contains indications for "PLAYBACK", "SUMMARIZING",
; and "RECORDING".
;

STATUS_STR::
	.BYTE	10$-5$
5$:	.BYTE	ESC,^A/Y/,24,1
	.ASCII	\!AC\
	.BYTE	ESC,^A/Y/,24,34
	.ASCII	\!AC\
	.BYTE	ESC,^A/Y/,24,70
	.ASCII	\!AC\
10$:

;
; Title string, including cursor positioning and title (with
; optional percent sign), centered and reversed.
;

TITLE_STR::
	.BYTE	10$-5$
5$:	.BYTE	ESC,^A/Y/,2,1		; Position cursor
	.ASCII	\!#* \			; Preceding blanks
	.BYTE	ESC,^A/R/		; Reverse-video
	.ASCII	\ !AC !#<(%) !>\	; Title text
	.BYTE	ESC,^A/U/		; Undo reverse-video
	.BYTE	ESC,^A/Y/,3,32		; Optional position cursor
	.ASCII	\  on node !AC\		; Optional nodename text
10$:

;
; User's comment string, including cursor positioning
; and comment string, centered and reversed.
;

COMM_STR::
	.BYTE	10$-5$
5$:	.BYTE	ESC,^A/Y/,5,1		; Position cursor
	.ASCII	\!#* \			; Preceding blanks
	.BYTE	ESC,^A/R/		; Reverse-video
	.ASCII	\ !AF \			; Title text
	.BYTE	ESC,^A/U/		; Undo reverse-video
10$:

;
; Date/time string, including cursor positioning.
;

TIME_STR::
	.BYTE	10$-5$
5$:	.BYTE	ESC,^A/Y/,4,31
	.ASCII	\!AD\
	.BYTE	ESC,^A/Y/,4,43
	.ASCII	\!AD\
10$:

;
; Date/time string for special SYSTEM screen
;

SYS_TIME_STR::
	.BYTE	10$-5$
5$:	.BYTE	ESC,^A/Y/,1,57
	.ASCII	\!AD\
	.BYTE	ESC,^A/Y/,1,69
	.ASCII	\!AD\
10$:

;
; Summary line string, including cursor
; positioning and from/to times.
;

SUMMLINE_STR::
	.BYTE	10$-5$
5$:	.BYTE	ESC,^A/Y/,3,55
	.ASCII	\From: !AD\
	.BYTE	ESC,^A/Y/,4,37
	.ASCII	\SUMMARY           To:   !AD\
10$:

;
; Special summary line string for SYSTEM class
;

SYS_SUMMLINE_STR::
	.BYTE	10$-5$
5$:	.BYTE	ESC,^A/Y/,1,55
	.ASCII	\From: !AD\
	.BYTE	ESC,^A/Y/,2,55
	.ASCII	\To:   !AD\
	.BYTE	ESC,^A/Y/,3,37
	.ASCII	\SUMMARY\
10$:

PLAY_STR:				; String for footing line
	.BYTE	10$-5$
5$:	.BYTE	ESC,^A/R/		; Reverse video
	.ASCII	\ PLAYBACK \
	.BYTE	ESC,^A/U/		; Undo the reverse
10$:

SUMM_STR:				; String for footing line
	.BYTE	10$-5$
5$:	.BYTE	ESC,^A/R/		; Reverse video
	.ASCII	\ SUMMARIZING \
	.BYTE	ESC,^A/U/		; Undo the reverse
10$:

REC_STR:				; String for footing line
	.BYTE	10$-5$
5$:	.BYTE	ESC,^A/R/		; Reverse video
	.ASCII	\ RECORDING \
	.BYTE	ESC,^A/U/		; Undo the reverse
10$:

BLANK_STR::	.ASCIC	\ \		; Blank string for footing and heading lines
STATUS_PARMS::				; Status parms -- next 3 longwords
FOOTP:		.BLKL	1		; Address of "playback" or blank string
FOOTS:		.BLKL	1		; Address of "summary" or blank string
FOOTR:		.BLKL	1		; Address of "record" or blank string

;
; PROCESSES screen heading string.
;

PROCHEAD_STR::
	.BYTE	10$-5$
5$:	.BYTE	ESC,^A/Y/,1,1		; Position cursor
	.ASCII	\Process Count:\
	.BYTE	ESC,^A/Y/,1,60		; Position cursor
	.ASCII	\Uptime:\
	.BYTE	ESC,^A/Y/,6,1		; Position cursor
	.BYTE	ESC,^A/L/		; Underline
	.ASCII	\        PID   STATE PRI   NAME         PAGES\
	.ASCII	\      DIOCNT  FAULTS  CPU TIME      \
	.BYTE	ESC,^A/U/		; Undo underlining
10$:

;
; Tabular screen heading string.
;

TABHEAD_STR::
	.BYTE	10$-5$
5$:	.BYTE	ESC,^A/L/		; Underline
	.ASCII	\CUR\
	.BYTE	ESC,^A/U/		; Undo underlining
	.ASCII	\!AC       \
	.BYTE	ESC,^A/L/		; Underline
	.ASCII	\AVE\
	.BYTE	ESC,^A/U/		; Undo underlining
	.ASCII	\!-!AC       \
	.BYTE	ESC,^A/L/		; Underline
	.ASCII	\MIN\
	.BYTE	ESC,^A/U/		; Undo underlining
	.ASCII	\!-!AC       \
	.BYTE	ESC,^A/L/		; Underline
	.ASCII	\MAX\
	.BYTE	ESC,^A/U/		; Undo underlining
	.ASCII	\!-!AC\
10$:

;
; Heading string for special SYSTEM class screen
;

SYS_HEAD_STR::
	.BYTE	10$-5$
5$:	.BYTE	ESC,^A/Y/,1,1
	.ASCII	\Node: !AC\
	.BYTE	ESC,^A/Y/,2,1
	.ASCII	\Statistic: \
	.ASCII	\!AD\
10$:

;
; Bar graph screen heading string.
;

BARHEAD_STR::
	.BYTE	10$-5$
5$:	.BYTE	ESC,^A/Y/,6,38
	.ASCII	\!10<!UL!AC!>!10<!UL!AC!>!10<!UL!AC!>!6<!UL!AC!>!#< !>!5UL!AC\
10$:

;
; Bar graph statistic heading string (in smaller box).
;

STATHEAD_STR::
	.BYTE	10$-5$
5$:	.BYTE	ESC,^A/Y/,2,13
	.ASCII	\+-----+\
	.BYTE	ESC,^A/Y/,3,13
	.ASCII	\| \
	.ASCII	\!AD\
	.ASCII	\ |\
	.BYTE	ESC,^A/Y/,4,13
	.ASCII	\+-----+\
10$:

;
; Other bar graph strings
;

CURSOR_STR::	.BYTE	ESC,^A\Y\	; Position cursor escape sequence

HORIZ_STR::	.ASCII	\+ - - - - + - - - - + - - - - + - - - - -+\
					; Top and bottom line of bar graph box
PCENT_STR::	.ASCIC	\%\		; Percent symbol string for heading line
K_STR::		.ASCIC	\K\		; K symbol string for heading on bar graph box
STAT_HEAD::	.ASCII	\CUR\		; Table of statistic headings for bar graph
		.ASCII	\AVE\
		.ASCII	\MIN\
		.ASCII	\MAX\
STAT_LONG::	.ASCII	\CURRENT\	; Long version for SYSTEM class screen
		.ASCII	\AVERAGE\
		.ASCII	\MINIMUM\
		.ASCII	\MAXIMUM\

;
; FAO control strings for name string displays for homogeneous classes.
;

DISK_FAO:	.ASCID	\!#<!AC!#*$!AC!ZW:!>!#* !AF\
					; Disk FAO string (no alloc class)
DISK_FAO_AC:	.ASCID	\!13<$!ZB$!AC!ZW: !>!#* !#<(!AC)!>!AF\
					; Disk class FAO string (with alloc cls)
SCS_FAO::	.ASCID	\!AC\ 		; SCS class FAO control string
UNKNOWN_NODE:	.ASCIC	/Unknown Node/	; Counted ASCII string for a 0 length
					;  node name in the system block.
;
; FAO control string for item name display for homogeneous classes
;

ITEM_NAM_STR:
	.BYTE	10$-5$
5$:	.BYTE	ESC,^A/Y/,0,1		; Cursor position
	.ASCII	\!#<    !>!26<!AC!>\
10$:
ILN_REG = 6				; Item line number for regular displays
ITMLNNO = ITEM_NAM_STR+3		; Label for item line number

SYSOUT_TYPE:	.BLKB	1		; SYS$OUTPUT device type
					; MONITOR SYSOUT types are:
					; DEC_CRT, VT5X, OTHER_VID, HARDCOPY
					; (Type codes defined above)

PROC_SETUP_STR:	.LONG	20$-10$		; Descriptor for PROCESSES screen setup ...
		.LONG	10$		; ... string (incl. cursor positioning)
10$:
		.BYTE	ESC,^A/Y/,1,16	; Cursor position to process count field
		.ASCII	\!5<!UL!>\           
		.BYTE	ESC,^A/Y/,1,68	; Cursor position to uptime field
		.ASCII	\!AS\
20$:

PROC_RES_STR:	.LONG	20$-10$		; Descriptor for PROCESSES FAO control ...
		.LONG	10$		; ... string (resident process)
10$:		.ASCII	\     !XL !5AC !2UL !4(+)!15AF !9<!UL/!UL!> !7UL !7UL !2(+)!%T\
20$:

PROC_NRES_STR:	.LONG	20$-10$		; Descriptor for PROCESSES FAO control ...
		.LONG	10$		; ... string (non-resident process)
10$:		.ASCII	\     !XL !5AC !2UL !4(+)!15AF !9<!UL/!UL!>!5(+)       SWAPPED OUT!9* \
20$:

;
; Top PROCESSES FAO control string for one process display line
;

TOPSTR:
	.BYTE	10$-5$
5$:	.BYTE	ESC,^A/Y/,0,2		; position to left margin
	.ASCII	\!XL  !4(+)!15AF   !7<!#UL!>  \
	.BYTE	ESC,^A/F/		; select alternate char set
	.ASCII	\!#**\			; repeating bar character
	.BYTE	ESC,^A/G/,ESC,^A/K/	; select reg set and erase to EOL
10$:
TOPLNNO = TOPSTR+3			; label for line number
TOPBAR  = TOPSTR+39			; label for bar character

;
; Top PROCESSES FAO control string to erase a line
;

ERLINE_STR:
	.BYTE	10$-5$
5$:	.BYTE	ESC,^A/Y/,0,1		; position to left margin
	.BYTE	ESC,^A/K/		; erase to end of line
10$:
ERLNNO = ERLINE_STR+3			; label for line number

VT100_REGSET:	.LONG	20$-10$		; descriptor for VT100 ...
		.LONG	10$		; ... "regular" char set esc seq
10$:		.BYTE	ESC,^A/(/,^A/B/,SI
20$:
VT100_ALTSET:	.LONG	20$-10$		; descriptor for VT100 ...
		.LONG	10$		; ... "alternate" graphics set esc seq
10$:		.BYTE	ESC,^A/(/,^A/0/
20$:
VT100_CURSET:	.BLKL	1		; addr of esc seq descr for curr char set
REG_SET:	.LONG	20$-10$		; VT52 esc seq to estab regular char set
		.LONG	10$
10$:		.BYTE	ESC,^A/G/
20$:

PUTSCRARG:				; arg list for PUT_SCREEN call
	.LONG	4			; argument count
	.LONG	TXT_DESC		; addr of buffer to display
	.LONG	0,0			; no cursor pos specification
ATTRIBMSK: .LONG 0			; start off with no special attributes

TXT_DESC:				; hold area for descriptor to be PUT'd
TXT_LENGTH:	.BLKL	1		; length
TXT_START:	.BLKL	1		; address

ESC_SEQ_TABLE:	.ASCII	\LBFGHJKRUY\	; table of valid escape modifiers
ES_TAB_LEN = .-ESC_SEQ_TABLE		; length of table

PUTMSGVEC:	.BLKL	PUTMSGSIZE	; Message argument vector for $PUTMSG

	.SBTTL	CALC_LEN - Calculate class record lengths
	.PSECT	$$MONCODE,NOWRT,EXE
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called to calculate the length of a block
;	(CDB$W_BLKLEN) for each STANDARD class. Non-standard
;	classes have this value entered at compile-time. Block
;	length for standard heterogeneous classes is defined as the
;	sum of the sizes of all data items which comprise the class, 
;	and which are recorded (calculated items which are displayed but
;	not recorded are not included in block length).
;	Block length for standard homogeneous classes is the sum of
;	all data items comprising the class (including the element ID)
;	for a SINGLE element (e.g., for a single disk).
;
;	In addition, some pre-processing for the MODES class is done,
;	and, for homogeneous classes, the CDX$W_CUMELCT, CDX$B_IDISCONSEC
;	CDX$W_IBITS and CDX$B_IDISCT fields are initialized.
;
; CALLING SEQUENCE:
;
;	CALLS #1,CALC_LEN
;
; INPUTS:
;
;	4(AP)	- address of MRB$O_CLASSBITS, the bit string
;		  representing classes to be monitored.
;
; IMPLICIT INPUTS:
;
;	PERFTABLE    - table of IDB's describing each data item,
;			 indexed by item number ( * entry size).
;
;	CDBHEAD      - table of CDB's, one for each class.
;
;	MAX_CLASS_NO - maximum class number (class numbers are zero-origin)
;
;	MODES_CLSNO  - MODES class number
;
;	MODES_ICOUNT  - MODES item count (for uniprocessor)
;
; OUTPUTS:
;
;	None
;
; IMPLICIT OUTPUTS:
;
;	CDB$W_BLKLEN (block length) field established for each CDB.
;
;	PROCS_PER_REC field established for the PROCESSES class.
;
;
; ROUTINE VALUE:
;
;	R0 = SS$_NORMAL, or MNR$_ITMNOTDEF
;
; SIDE EFFECTS:
;
;	None
;
;--


.ENTRY	CALC_LEN,	^M<R2,R3,R4,R6,R8,R9,R10,R11>

;
; First, re-establish item count for the MODES class (uniprocessor)
;

	BBC	#MODES_CLSNO,@4(AP),10$		; Skip if MODES not present
	MOVAL	CDBHEAD,R6			; Get address of first CDB
	ADDL	#<CDB$K_SIZE*MODES_CLSNO>,R6	; Calculate addr of MODES CDB
	MOVL	#MODES_ICOUNT,CDB$L_ICOUNT(R6)	; Get uniprocessor item count

;
; Now calculate CDB$W_BLKLEN for all requested classes.
;

10$:
	CLRL	R11			; Init starting bit position
20$:
	MOVL	#32,R9			; Init bit field size
					; NOTE -- must handle in 32-bit chunks
	MOVL	R11,R8			; Init start position of next chunk
30$:
	FFS	R8,R9,@4(AP),R10	; Search for next class number
					; R10 contains class no. if found
	BEQL	40$			; Branch if none found this chunk
	BSBB	CALC_CLASS		; Calc block length for this class
	BLBC	R0,50$			; Go return if error
	ADDL2	R8,R9			; Compute next starting
	ADDL3	#1,R10,R8		; ... position and field size
	SUBL2	R8,R9			; ... for this chunk
	BRB	30$			; Go search rest of chunk
40$:
	ACBW	#MAX_CLASS_NO,#32,R11,20$ ; Loop to process next chunk

;
; At this point, CDB$W_BLKLEN fields for all monitored classes
; have been established.
;

50$:
	RET				; Return with status in R0


CALC_CLASS:				; Calc block length for this class
					; NOTE -- R10 contains class number
					; Regs R8 thru R11 must not be changed

	MULL3	#CDB$K_SIZE,R10,R6	; Compute offset to desired CDB
	MOVAB	CDBHEAD[R6],R6		; Index to CDB address

;
; For all classes except homogeneous standard classes, set the
; element count (of elements displayed) equal to the item count
; (of items collected).
;

	BBS	#CDB$V_HOMOG,CDB$L_FLAGS(R6),10$ ; Br if homog
	MOVL	CDB$L_ICOUNT(R6),CDB$L_ECOUNT(R6) ; Item count = elt count
10$:
	BBS	#CDB$V_STD,CDB$L_FLAGS(R6),20$ ; Br if a standard class
	MOVL	#<MAX_REC_SIZE-MNR_CLS$K_HSIZE-MNR_PRO$K_PSIZE>,R2
					; Get max data size
	DIVW3	CDB$W_BLKLEN(R6),R2,W^PROCS_PER_REC
					; Compute processes per record for ...
					; ... PROCESSES non-STD class
	BRB	80$			; All done with this class
20$:
	MOVL	CDB$L_ICOUNT(R6),R0	; Get no of items to sum for this CDB
	MOVL	CDB$A_ITMSTR(R6),R1	; Address of item-number string
	CLRL	R2			; Clear block size reg
30$:
	MOVZBL	(R1)+,R4		; Get next item number
	MULL	#IDB$K_ILENGTH,R4	; Compute index into IDB table
	MOVAB	W^PERFTABLE[R4],R4	; Address of IDB for this item
	TSTB	IDB$B_FLAGS(R4)		; Is this a calculated item?
	BNEQ	70$			; Branch if so (don't add to size)
	CASE	IDB$W_ISIZE(R4),<40$,50$,60$>,W ; Select on proper size

40$:	INCL	R2			; Add 1 for byte
	BRB	70$
50$:	ADDL	#2,R2			; Add 2 for word
	BRB	70$
60$:	ADDL	#4,R2			; Add 4 for longword
70$:	SOBGTR	R0,30$			; Loop for each item in this class

	MOVW	R2,CDB$W_BLKLEN(R6)	; Store away size for this class

;
; Now add in size of element ID for homogeneous classes
;

	BBC	#CDB$V_HOMOG,CDB$L_FLAGS(R6),80$ ; All done if hetero
	MOVL	CDB$A_CDX(R6),R2	; Get CDX addr for homog class
	MOVZBL	CDX$B_ELIDLEN(R2),R0	; Get length of element ID
	ADDW2	R0,CDB$W_BLKLEN(R6)	; Add it in to get data block size
;
; Also, for homogeneous classes, initialize CDX$W_CUMELCT
; and CDX$B_IDISCONSEC, and calculate display item count.
;

	CLRW	CDX$W_CUMELCT(R2)	; Init cumulative element count
	CLRB	CDX$B_IDISCONSEC(R2)	; Init consecutive display number

	BSBB	CALC_DITEM		; Calculate display item count
	BRB	90$			; Go return with status in R0
80$:
	MOVL	#SS$_NORMAL,R0		; Success status

90$:	RSB				; Return with status in R0

CALC_DITEM:				; Calc display item cnt for homog class

	MOVL	CDB$L_ICOUNT(R6),R0	; Get count of all items for class
	BBS	#CDX$S_IBITS-1, -
		CDX$W_IBITS(R2),30$	; Br if ALL items requested for display

;
; Use FFS loop to calculate the number of display items requested.
; Store the number in CDX$B_IDISCT. Also, clear any bits higher
; than the number of items defined for this revision level.
;

	SUBB3	R0,#CDX$S_IBITS,R1	; Calc number of unused bits
	INSV	#0,R0,R1,CDX$W_IBITS(R2) ; ... and make sure they are clear
	CLRL	R4			; Init counter of requested items
	CLRL	R1			; Init starting bit number for FFS
10$:
	FFS	R1,R0,CDX$W_IBITS(R2),R3 ; Search for next item number

					; R3 contains item number if found
	BEQL	20$			; Branch if none found

	INCL	R4			; Count this item

	ADDL3	#1,R3,R1		; Compute next starting ...
	SUBL3	R1,#CDX$S_IBITS,R0	; ... position and field size
	BRB	10$			; Go search rest of bit string

20$:
	MOVB	R4,CDX$B_IDISCT(R2)	; Store number of display items
	BRB	40$			; ... and go return

;
; ALL items requested for display. Store number requested in
; CDX$B_IDISCT, and set all item bits in CDX$W_IBITS.
;

30$:
	CLRW	CDX$W_IBITS(R2)		; Start out with all item bits clear
	INSV	#-1,#0,R0,CDX$W_IBITS(R2) ; Set all bits defined for this rev.
	MOVB	R0,CDX$B_IDISCT(R2)	; ... and store its count
40$:

	MOVL	#SS$_NORMAL,R0		; Assume normal status
	TSTW	CDX$W_IBITS(R2)		; Check if no items requested
	BNEQU	50$			; Br if at least one requested

	PUSHL	#MNR$_ITMNOTDEF		; Stack MONITOR failing status code
	CALLS	#1,MON_ERR		; Log the error
	MOVL	#MNR$_ITMNOTDEF,R0	; Get status to caller
50$:
	RSB				; Return to caller

	.SBTTL	MOVE_CLASS_QUALS - Move Class Qualifier Values
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called to move a set of values from
;	one CDB or CDX field to another. In particular, the QFLAGS
;	(class qualifier flags), IBITS (item bits) and the ST
;	(display statistic) values are moved among three fields
;	defined for each, representing default value, current value
;	and active value. The types of moves are defined below under
;	INPUTS.
;
; CALLING SEQUENCE:
;
;	CALLS #1,MOVE_CLASS_QUALS
;
; INPUTS:
;
;	4(AP) - address of a byte containing a code indicating which
;		type of move to make, as follows:
;
;		If code =
;
;		DEF_TO_CUR(=0)  =>  Move default values to current values.
;
;		CUR_TO_ACT(=1)  =>  Move current values to active values.
;				    In addition, clear the CDB$V_EXPLIC bit.
;
;		ACT_TO_CUR(=2)  =>  Move active values to current values.
;
;		ALL_TO_ACT(=3)	=>  Move the ALL statistic value to active.
;
; IMPLICIT INPUTS:
;
;	CDBHEAD      - table of CDB's, one for each class.
;
;	MAX_CLASS_NO - maximum class number (class numbers are zero-origin)
;
;	CDB$B_ST, CDB$B_ST_DEF and CDB$B_ST_CUR fields for each CDB.
;
;	CDB$W_QFLAGS, CDB$W_QFLAGS_DEF and CDB$W_QFLAGS_CUR fields for each CDB.
;
;	CDX$W_IBITS, CDX$W_IBITS_DEF and CDX$W_IBITS_CUR fields for each homog class.
;
; OUTPUTS:
;
;	None
;
; IMPLICIT OUTPUTS:
;
;	Requested move is performed.
;
; ROUTINE VALUE:
;
;	R0 = SS$_NORMAL
;
; SIDE EFFECTS:
;
;	None
;
;--


.ENTRY	MOVE_CLASS_QUALS,	^M<R3,R6>

	MOVAL	CDBHEAD,R6		; Get address of first CDB
	MOVL	#MAX_CLASS_NO+1,R3	; Get number of CDB's
	CASE	@4(AP),<10$,20$,30$,40$>,B ; Select on type of move
	BRW	50$			; Do nothing if out of range

;
; DEFAULT TO CURRENT
;

10$:
	MOVB	CDB$B_ST_DEF(R6),CDB$B_ST_CUR(R6)	  ; Load default stat to current
	MOVW	CDB$W_QFLAGS_DEF(R6),CDB$W_QFLAGS_CUR(R6) ; Load default qual flags to current
	BBC	#CDB$V_HOMOG,CDB$L_FLAGS(R6),15$ 	  ; Br if heterogeneous class
	MOVL	CDB$A_CDX(R6),R0			  ; Get CDX address
	MOVW	CDX$W_IBITS_DEF(R0),CDX$W_IBITS_CUR(R0)	  ; Load def item bits to current
15$:
	ADDL	#CDB$K_SIZE,R6				  ; Point to CDB for next class
	SOBGTR	R3,10$					  ; Loop for each CDB
	BRW	50$					  ; Go to common exit

;
; CURRENT TO ACTIVE
;

20$:
	MOVB	CDB$B_ST_CUR(R6),CDB$B_ST(R6)		  ; Load current stat to active
	MOVW	CDB$W_QFLAGS_CUR(R6),CDB$W_QFLAGS(R6)	  ; Load current qual flags to active
	BBCC	#CDB$V_EXPLIC,CDB$L_FLAGS(R6),22$	  ; Indicate no explicit qualifier
22$:
	BBC	#CDB$V_HOMOG,CDB$L_FLAGS(R6),25$ 	  ; Br if heterogeneous class
	MOVL	CDB$A_CDX(R6),R0			  ; Get CDX address
	MOVW	CDX$W_IBITS_CUR(R0),CDX$W_IBITS(R0)	  ; Load curr item bits to active
25$:

	ADDL	#CDB$K_SIZE,R6		; Point to CDB for next class
	SOBGTR	R3,20$			; Loop for each CDB
	BRW	50$			; Go to common exit

;
; ACTIVE TO CURRENT
;

30$:
	MOVB	CDB$B_ST(R6),CDB$B_ST_CUR(R6)		  ; Load active stat back to current
	MOVW	CDB$W_QFLAGS(R6),CDB$W_QFLAGS_CUR(R6)	  ; Load active qual flags back to current
	BBC	#CDB$V_HOMOG,CDB$L_FLAGS(R6),35$ 	  ; Br if heterogeneous class
	MOVL	CDB$A_CDX(R6),R0			  ; Get CDX address
	MOVW	CDX$W_IBITS(R0),CDX$W_IBITS_CUR(R0)	  ; Load active item bits back to current
35$:

	ADDL	#CDB$K_SIZE,R6		; Point to CDB for next class
	SOBGTR	R3,30$			; Loop for each CDB
	BRB	50$			; Go to common exit

;
; /ALL TO ACTIVE
;

40$:
	BBC	#CDB$V_STD,CDB$L_FLAGS(R6),45$	  	  ; Br if non-standard class
	CMPB	CDB$B_ST_DEF(R6),CDB$B_ST_CUR(R6)	  ; Is default stat equal to current?
	BNEQ	45$					  ; Br if not
	BBS	#CDB$V_EXPLIC,CDB$L_FLAGS(R6),45$	  ; Br if explicit qualifier
	MOVB	#ALL_STAT,CDB$B_ST(R6)			  ; Force the ALL statistic
45$:
	ADDL	#CDB$K_SIZE,R6		; Point to CDB for next class
	SOBGTR	R3,40$			; Loop for each CDB

50$:
	MOVL	#SS$_NORMAL,R0		; Indicate success
	RET				; ... and return

	.SBTTL	FETCH - Collect Data into Buffer 

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called to collect the data for the next interval.
;	It scans a table describing which items to collect, and moves
;	each item to the proper slot in the collection buffer supplied
;	by the caller.
;
; CALLING SEQUENCE:
;
;	Entered via CALL from $CMKRNL system service.
;
; INPUTS:
;
;	 4(AP) - address of CDB (Class Descriptor Block)
;
;	 8(AP) - address of 1st byte of variable portion of collection buffer
;
; IMPLICIT INPUTS:
;
;	EXE$GQ_SYSTIME - current time in system time (quadword) units
;
;	PERFTABLE - table describing each data item, indexed by
;			item number ( * entry size)
;
; OUTPUTS:
;
;	None
;
; IMPLICIT OUTPUTS:
;
;	CURRENT collection buffer is filled with raw data.
;
; ROUTINE VALUE:
;
;	SS$_NORMAL
;
; SIDE EFFECTS:
;
;	None
;
;--


.ENTRY	FETCH,	^M<R3,R4,R5,R6>

	MOVL	4(AP),R6		; Load CDB pointer
	MOVL	8(AP),R5		; Load addr of 1st byte of actual data
	MOVQ	G^EXE$GQ_SYSTIME,<MNR_CLS$Q_STAMP-MNR_CLS$K_HSIZE>(R5)
					; Get current time into coll buffer
;
; If this class has a pre-collection routine, call it.
;
	TSTL	CDB$A_PRECOLL(R6)	; Is there a pre-collection rtn?
	BEQL	10$			; No -- continue
	PUSHL	R5			; Yes -- stack coll buffer addr
	CALLS	#1,@CDB$A_PRECOLL(R6)	; Call it
	BLBC	R0,70$			; If failed, get out
	BLBC	R1,65$			; If fetch is not required, skip it
10$:
	BBC	#CDB$V_STD,CDB$L_FLAGS(R6),65$ ; Skip fetch if non-STD class
	BBS	#CDB$V_HOMOG,CDB$L_FLAGS(R6),65$ ; Skip fetch if homog class
					; 
	MOVL	CDB$L_ICOUNT(R6),R0	; Get number of items to fetch
	MOVL	CDB$A_ITMSTR(R6),R1	; Address of item-number string
	CLRL	R3			; Clear loop counter
20$:
	MOVZBL	(R1)+,R4		; Get next item number
	MULL	#IDB$K_ILENGTH,R4	; Compute index into IDB table
	MOVAB	W^PERFTABLE[R4],R4	; Address of IDB for this item
	TSTB	IDB$B_FLAGS(R4)		; Is this a computed item?
	BEQL	25$			; no, go collect
	BRB	60$			; yes, skip this item and on to the next
25$:
	CASE	IDB$W_ISIZE(R4),<30$,40$,50$>,W ; Select on proper size

30$:	MOVB	@IDB$A_ADDR(R4),(R5)+	; Collect a byte
	BRB	60$
40$:	MOVW	@IDB$A_ADDR(R4),(R5)+	; Collect a word
	BRB	60$
50$:	MOVL	@IDB$A_ADDR(R4),(R5)+	; Collect a longword
60$:	AOBLSS	R0,R3,20$		; Loop until done

;
; If this class has a post-collection routine, call it.
;

65$:
	MOVL	#SS$_NORMAL,R0		; Assume good status at this point
	TSTL	CDB$A_POSTCOLL(R6)	; Is there a post-collection rtn?
	BEQL	70$			; No -- go return
	PUSHL	8(AP)			; Yes -- stack coll buffer addr
	CALLS	#1,@CDB$A_POSTCOLL(R6)	; Call it

70$:
	RET				; Return with status

	.SBTTL	CLASS_COLLECT - Collect & Transform Data

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called once per interval per class to collect
;	and record raw data and to do statistical transformations of
;	that data. The transformations include calculations of minimum
;	value, maximum value, total since request began, percent, etc.
;	On the first call to this routine per request, up to ten buffers
;	are obtained. These consist of two flip-flopped collection
;	buffers for raw data, and up to 8 statistics buffers. On subsequent
;	calls, the buffers are updated.
;
; CALLING SEQUENCE:
;
;	CALLS #1, CLASS_COLLECT
;
; INPUTS:
;
;	 4(AP) - address of byte containing class number
;
; IMPLICIT INPUTS:
;
;	CDBPTR - pointer to CDB (Class Descriptor Block)
;	MRBPTR - pointer to MRB (Monitor Request Block)
;	MCAPTR - pointer to MCA (Monitor Communication Area)
;	SPTR -   pointer to SYI (System Information Area)
;
; OUTPUTS:
;
;	None
;
; IMPLICIT OUTPUTS:
;
;	Collection buffer filled with raw data for this class
;	for this interval.
;
;	All required statistics buffers filled with transformed
;	data for this class for this interval.
;
;	COLLENDED bit set to YES if this collection 
;	has passed the requested ending time.
;
; ROUTINE VALUE:
;
;	R0 = NORMAL
;
; SIDE EFFECTS:
;
;	None
;
; REGISTER USAGE:
;
;	R6  = CDB pointer
;	R7  = MRB pointer
;	R8  = CURRENT collection buffer pointer
;	R9  = PREVIOUS collection buffer pointer
;	R10 = Buffer block pointer
;	R11 = MCA pointer
;
;	Others are volatile.
;
;--


.ENTRY	CLASS_COLLECT,	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>
	MOVL	CDBPTR,R6		; Load CDB pointer
	MOVL	MRBPTR,R7		; Load MRB pointer
	MOVL	MCAPTR,R11		; Load MCA pointer

	TSTL	MCA$L_COLLCNT(R11)	; First collection ?
	BNEQ	5$			; No -- keep going
	JSB	GET_BUFFERS		; Get collection & stat buffers
	BLBS	R0,5$			; Continue if OK
	BRW	CC_ERROR		; Else exit with error
5$:
	MOVL	CDB$A_BUFFERS(R6),R10	; Load address of buffer block
	BBC	#CDB$V_HOMOG,CDB$L_FLAGS(R6),10$ ; Br if not homog class
	MOVL	(R10),R10		; Get MBP ptr for homog class

;
; For standard classes:
;
; Load CURRENT buffer pointer (R8) and PREVIOUS buffer pointer (R9); at
; the same time, flip-flop the state of the CDB$V_SWAPBUF bit, so BUFFERA
; and BUFFERB will be swapped on next CLASS_COLLECT call for this class.
; When CDB$V_SWAPBUF is OFF, BUFFERA is CURRENT; otherwise, BUFFERB is
; CURRENT.
;
; For non-standard class (PROCESSES):
;
; CURRENT buffer pointer (R8) always points to BUFFERA. The CDB$V_SWAPBUF
; bit is always clear.
;

10$:
	BBS	#CDB$V_STD,CDB$L_FLAGS(R6),15$ ; Branch if STD class
	CMPL	MCA$L_COLLCNT(R11),#1	; Second collection coming up?
	BNEQ	20$			; No -- continue
	BBC	#MRB$V_SUMMARY,MRB$W_FLAGS(R7),20$ ; Continue if not summarizing
;
; Swap MBP$A_BUFFA and MBP$A_BUFF1ST pointers in order to retain data
; from the first collection buffer for use later during summary processing.
;

	MOVL	MBP$A_BUFFA(R10),R1	; Save current coll buff ptr
	MOVL	MBP$A_BUFF1ST(R10),MBP$A_BUFFA(R10) ; Point current to first
	MOVL	R1,MBP$A_BUFF1ST(R10)	; ... and first to current
	BRB	20$			; Go make BufferA CURRENT
;
; Standard classes
;

15$:
	BBSC	#CDB$V_SWAPBUF,CDB$L_FLAGS(R6),20$ ; Clear bit if set & branch
	INSV	#1,#CDB$V_SWAPBUF,#1,CDB$L_FLAGS(R6) ; Bit was clear -- set it
	MOVL	MBP$A_BUFFERB(R10),R8	; Make BufferB CURRENT
	MOVL	MBP$A_BUFFERA(R10),R9	; ... and BufferA PREVIOUS
	BRB	30$			; ... and continue
20$:
	MOVL	MBP$A_BUFFERA(R10),R8	; Make BufferA CURRENT
	MOVL	MBP$A_BUFFERB(R10),R9	; ... and BufferB PREVIOUS

;
; Collect data for this class into the CURRENT collection buffer.
;

30$:
	BSBW	COLLECTION		; Get data for this class
	BLBS	R0,40$			; Continue if OK
	BRW	CC_ERROR		; Else exit with error
;
; If a record request, perform recording.
;

40$:
	BBC	#MRB$V_RECORD,MRB$W_FLAGS(R7),70$ ; Continue if not recording
	BBC	#MRB$V_PLAYBACK,MRB$W_FLAGS(R7),50$ ; If live, go record
	BBC	#MCA$V_MULTFND,MCA$W_FLAGS(R11),70$ ; Skip rec if mult not found
50$:
	BBS	#CDB$V_STD,CDB$L_FLAGS(R6),60$ ; If STD class, go write a record
	MOVZWL	CDB$W_BLKLEN(R6),-(SP)	; Non-STD class -- push data block size
	PUSHL	R8			; ... and collection buffer ptr
	CALLS	#2,WRITE_PROC_RECORDS	; Write the required num of PROCESSES recs
	BLBS	R0,70$			; Continue if status OK
	BRW	CC_ERROR		; Else exit with error
60$:
	CLRQ	-(SP)			; Get descr on stack for CALL
	MOVW	CDB$W_BLKLEN(R6),(SP)	; Move in length of buffer
	BBC	#CDB$V_HOMOG,CDB$L_FLAGS(R6),65$ ; Br if a heterogeneous class
	MULL2	<MNR_CLS$K_HSIZE+MNR_HOM$L_ELTCT>(R8),(SP)
					; Times number of elts for homog class
	ADDL2	#MNR_HOM$K_PSIZE,(SP)	; ... plus the prefix
65$:
	ADDL2	#MNR_CLS$K_HSIZE,(SP)	; Add in class header size
	MOVL	R8,4(SP)		; Load address of buffer
	PUSHL	SP			; Stack descriptor address
	CALLS	#1,WRITE_RECORD		; ... and record the buffer

70$:
	CMPB	@4(AP),#MODES_CLSNO	; Is this the modes class?
	BNEQ	80$			; no, branch
;
; Combine MODES counters if required
;
	BBC	#CDB$V_CPU_COMB,CDB$L_FLAGS(R6),75$
					; Br if not special MODES case
	BSBW	COMBINE_MODES		; Combine modes for all cpu's

	
;
; Sum the first six counters to get sum of all CPU modes
;
75$:
	CLRL	CPU_BUSY		; Zero CPU_BUSY
	MOVL	#6,R0			; Get number of modes for display
	ADDL3	#MNR_CLS$K_HSIZE,R8,R1	; Compute start addr of 1st set of counters
77$:
	ADDL2	(R1)+,CPU_BUSY		; Sum of non-idle mode counters
	SOBGTR	R0,77$			; 


;
; Fill STATS buffer for homogeneous class
;

80$:
	BBC	#CDB$V_STD,CDB$L_FLAGS(R6),120$ ; If non-STD class, skip all transforms

	BBC	#CDB$V_HOMOG,CDB$L_FLAGS(R6),90$ ; Br if a heterogeneous class
	PUSHL	R9			; Stack addr of PREV coll buff
	PUSHL	R8			; Stack addr of CURR coll buff
	CALLS	#2,FILL_HOMOG_STATS	; Fill STATS buffers for homog class
	BLBS	R0,90$			; Continue if OK
	BRW	CC_ERROR		; Else exit with error
90$:

	TSTL	MCA$L_COLLCNT(R11)	; First collection?
	BEQL	120$			; Yes -- skip all transforms	

;
; Calculate MCA$L_INTTICKS (clock ticks during interval just finished)
;

	MOVQ	MNR_CLS$Q_STAMP(R8),R2	; Current system time to temp regs
	SUBL2	MNR_CLS$Q_STAMP(R9),R2	; Calc low-order in sys units
	SBWC	MNR_CLS$Q_STAMP+4(R9),R3 ; Calc high-order in sys units
	EDIV	#100000,R2,MCA$L_INTTICKS(R11),R2 ; Calc interval ticks (10ms units)
					     	 ; ... for use later

;
; Do Data Transformations for STANDARD (homogeneous) classes
;

	BBC	#CDB$V_HOMOG,CDB$L_FLAGS(R6),110$ ; Br if a heterogeneous class

	TSTL	CDB$L_ECOUNT(R6)	; Any elements in STATS?
	BEQL	120$			; No -- skip transformations

	MOVL	#CDX$S_IBITS,R1		; Init bit field size
	CLRL	R0			; Init start position
	CLRL	R4			; Init item index
100$:

	MOVL	CDB$A_CDX(R6),R2	; Get CDB extension for HOMOG class
	FFS	R0,R1,CDX$W_IBITS(R2),R3 ; Search for next item number
					; R3 contains item number if found
	BEQL	120$			; Branch if no more items

	MOVZBL	@CDB$A_ITMSTR(R6)[R3],R0 ; Load IDB item number
	MULL2	#IDB$K_ILENGTH,R0	; Compute index into IDB table
	MOVAB	W^PERFTABLE[R0],R0	; Address of IDB for this item
	MOVW	IDB$W_TYPE(R0),W^HOMOG_TYPE ; Save item type for COMPUTE_STATS

	MOVL	@CDB$A_BUFFERS(R6)[R4],R10 ; Load MBP ptr for this item
	PUSHR	#^M<R3,R4>		; Save regs
	BSBW	TRANSFORMS		; Fill trans'n buffers for this item
	POPR	#^M<R3,R4>		; Restore regs

	ADDL3	#1,R3,R0		; Compute next starting ...
	SUBL3	R0,#CDX$S_IBITS,R1	; ... position and field size
	INCL	R4			; Update item index
	BRB	100$			; Go search rest of bit string

;
; Fill STATS and do Data Transformations for STANDARD (heterogeneous) classes
;

110$:
	BSBW	FILL_HETERO_STATS	; Fill STATS from the 2 coll buffers
	BSBW	TRANSFORMS		; ... and fill all transformation buffs

;
; Call COLLECTION_END if end of collection has been reached. The end
; of collection is tested by comparing the system time (quadword)
; values of the current time and the requested end time.
;

120$:
	CMPB	@4(AP),MCA$B_LASTC(R11) 		; Last class?
	BNEQU	CC_NORMAL				; No -- just exit
	MOVQ	MNR_CLS$Q_STAMP(R8),MCA$Q_LASTCOLL(R11)	; Yes -- remember latest coll time
	BBS	#MRB$V_INDEFEND,MRB$W_FLAGS(R7),CC_NORMAL ; Skip end check if indef end
	CMPL	MNR_CLS$Q_STAMP+4(R8),MRB$Q_ENDING+4(R7) ; Has curr time passed
							; ... requested end (hi-order) ?
	BLSSU	CC_NORMAL				; No -- simply return
	BGTRU	130$					; Yes -- indicate so and return
	CMPL	MNR_CLS$Q_STAMP(R8),MRB$Q_ENDING(R7) 	; Check low order longword
	BLSSU	CC_NORMAL				; Not at end yet -- return
130$:
	CALLS	#0,COLLECTION_END			; Indicate collection has ended
							; COLLECTION_END sets COLLENDED bit

CC_NORMAL:
	MOVL	NORMAL,R0				; Indicate normal status
CC_ERROR:
	RET						; Return

	.SBTTL	TRANSFORMS - Perform Data Transformations

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine updates all transformation buffers (STATS, MIN,
;	MAX, SUM, PCSTATS, PCMIN, PCMAX, PCSUM) for STANDARD classes
;	(both homogeneous and heterogeneous).
;
; CALLING SEQUENCE:
;
;	BSBW	TRANSFORMS
;
; INPUTS:
;
;	R6  - CDB pointer
;	R7  - MRB pointer
;	R8  - CURRENT buffer pointer
;	R9  - PREVIOUS buffer pointer
;	R10 - Buffer block (MBP) pointer
;	R11 - MCA pointer
;
; IMPLICIT INPUTS:
;
;	All transformation buffers
;
; OUTPUTS:
;
;	None
;
; IMPLICIT OUTPUTS:
;
;	All transformation buffers updated with statistics 
;	from the current collection.
;
; ROUTINE VALUE:
;
;	None
;
; SIDE EFFECTS:
;
;	Registers R0,R1,R2,R3,R4,R5 destroyed.
;
;--

TRANSFORMS:				; Perform data transformations

;
; Update SUM buffer from STATS buffer
;

	MOVL	MBP$A_STATS(R10),R0	; Load STATS buffer pointer
	MOVL	MBP$A_SUM(R10),R1	; Load SUM buffer pointer
	MOVL	CDB$L_ECOUNT(R6),R2	; Load count of elements in STATS
10$:
	ADDL2	(R0)+,(R1)+		; Add this item to SUM buff
	SOBGTR	R2,10$			; Loop for each item in STATS buff

	BBC	#CDB$V_PERCENT,CDB$W_QFLAGS(R6),30$ ; If percent not requested, skip percent calcs

	BSBW	FILL_PCSTATS_BUFF	; Fill PCSTATS from STATS

;
; Update PCSUM buffer from PCSTATS buffer
;
	MOVL	MBP$A_PCSTATS(R10),R0	; Load PCSTATS buffer pointer
	MOVL	MBP$A_PCSUM(R10),R1	; Load PCSUM buffer pointer
	MOVL	CDB$L_ECOUNT(R6),R2	; Load count of elements in PCSTATS
20$:
	ADDL2	(R0)+,(R1)+		; Add this item to PCSUM buff
	SOBGTR	R2,20$			; Loop for each item in PCSTATS buff
;
; Update PCMIN and PCMAX buffers from PCSTATS buffer
;
	BSBW	UPD_PC_MIN_MAX		; Update PCMIN and PCMAX

;
; Convert counts to rates in STATS buffer and update MIN and MAX
;

30$:
	BSBW	COMPUTE_STATS		; Convert counts to rates in STATS
					; ... and update MIN and MAX

	RSB				; Return from TRANSFORMS subroutine

	.SBTTL	COMBINE_MODES - Combine Modes for all CPUs

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called by CLASS_COLLECT to combine the mode
;	tick counters for all CPU's on the system. The monitored
;	system is a multiprocessing system, but the user requested
;	that the display and/or summary show combined values for
;	the processor modes (/NOCPU).
;
; CALLING SEQUENCE:
;
;	BSBW	COMBINE_MODES
;
; INPUTS:
;
;	None
;
; IMPLICIT INPUTS:
;
;	R6 = Pointer to MODES CDB
;	R8 = Pointer to CURRENT collection buffer
;
; OUTPUTS:
;
;	None
;
; IMPLICIT OUTPUTS:
;
;	The first 7 longwords in the data portion of the collection buffer
;	will contain combined mode counter values for all CPU's on the system.
;
; ROUTINE VALUE:
;
;	None
;
; SIDE EFFECTS:
;
;	Registers R0, R1, R2 destroyed.
;
;--


COMBINE_MODES:

	MOVL	CDB$L_ECOUNT(R6),R0	; Get number of modes for display
	ADDL3	#MNR_CLS$K_HSIZE,R8,R1	; Compute start addr of 1st set of counters
	MOVAL	(R1)[R0],R2		; Compute start addr of 2nd set of counters
10$:
	ADDL2	(R2)+,(R1)+		; Combine 2nd set with 1st set
	SOBGTR	R0,10$			; ... for all counters

	RSB				; Return

	.SBTTL	QUAD_LT_QUAD - Compare Two Quadwords

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called by PL/I routines to compare two unsigned
;	quadword values (such as system time values). The routine answers
;	the question: Is the first value less than the second value?
;	The value YES or NO is placed in R0 upon exit.
;
; CALLING SEQUENCE:
;
;	CALLS #2,QUAD_LT_QUAD
;
; INPUTS:
;
;	4(AP) - address of first quadword value
;
;	8(AP) - address of second quadword value
;
; IMPLICIT INPUTS:
;
;	None
;
; OUTPUTS:
;
;	Routine value below.
;
; IMPLICIT OUTPUTS:
;
;	None
;
; ROUTINE VALUE:
;
;	R0 = YES if first quadword value is less than the second quadword value.
;	R0 = NO  otherwise
;
; SIDE EFFECTS:
;
;	None
;
;--


.ENTRY	QUAD_LT_QUAD,	^M<>

	MOVQ	4(AP),R0		; Pointers in R0 and R1
	CMPL	4(R0),4(R1)		; First < Second (hi-order) ?
	BLSSU	20$			; Yes -- answer is YES
	BGTRU	10$			; No -- answer is NO
	CMPL	(R0),(R1)		; Check low order longword
	BLSSU	20$			; Go answer YES
10$:
	MOVL	#NO,R0			; First not less than second
	BRB	QLQ_RET			; Go return
20$:
	MOVL	#YES,R0			; First less than second
QLQ_RET:
	RET				; Return with value in R0

	.SBTTL	QUAD_EQ_0 - Compare Quadword = 0

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called by PL/I routines to compare an unsigned
;	quadword values (such as a system time value) with the quadword
;	value 0. The routine answers the question: Is the quadword value
;	equal to 0?
;
;	The value YES or NO is placed in R0 upon exit.
;
; CALLING SEQUENCE:
;
;	CALLS #1,QUAD_EQ_0
;
; INPUTS:
;
;	4(AP) - address of quadword value
;
; IMPLICIT INPUTS:
;
;	None
;
; OUTPUTS:
;
;	Routine value below.
;
; IMPLICIT OUTPUTS:
;
;	None
;
; ROUTINE VALUE:
;
;	R0 = YES if quadword value is equal to 0.
;	R0 = NO  otherwise
;
; SIDE EFFECTS:
;
;	None
;
;--


.ENTRY	QUAD_EQ_0,	^M<>

	MOVQ	@4(AP),R0		; Quadword value in R0, R1
	TSTL	R0			; Right half = 0?
	BNEQU	10$			; No -- answer NO
	TSTL	R1			; Yes -- left half = 0?
	BNEQU	10$			; No -- answer NO
	MOVL	#YES,R0			; Answer YES
	BRB	QEZ_RET			; Go exit
10$:
	MOVL	#NO,R0			; Answer NO
QEZ_RET:
	RET				; Return with value in R0

	.SBTTL	MPCHECK - Check system for MP capability

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called by the EXECUTE_REQUEST PL/I routine
;	to determine whether or not the running system has MP
;	(multiprocessing) capability.
;
;	The value YES or NO is placed in R0 upon exit.
;
; CALLING SEQUENCE:
;
;	CALLS #0,QUAD_EQ_0
;
; INPUTS:
;
;	None
;
; IMPLICIT INPUTS:
;
;	EXE$GB_CPUTYPE -- CPU type. Assume type 1 = 780.
;
;	EXE$GL_RPB -- Address of Restart Parameter Block.
;
; OUTPUTS:
;
;	Routine value below.
;
; IMPLICIT OUTPUTS:
;
;	None
;
; ROUTINE VALUE:
;
;	R0 = YES if the system has MP capability
;	R0 = NO  otherwise
;
; SIDE EFFECTS:
;
;	None
;
;--


.ENTRY	MPCHECK,	^M<>

	CMPB	G^EXE$GB_CPUTYPE,#1	; 780 processor?
	BNEQ	10$			; No -- go answer NO
	MOVL	G^EXE$GL_RPB,R0		; Get Restart Parameter Block ptr
	BBC	#RPB$V_MPM,RPB$L_BOOTR5(R0),10$ ; Br if no multi-port mem
	MOVL	#YES,R0			; Answer YES
	BRB	20$			; Go exit
10$:
	MOVL	#NO,R0			; Answer NO
20$:
	RET				; Return with value in R0

	.SBTTL	WRITE_PROC_RECORDS - Write PROCESSES class records

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called to write out a group of class
;	records containing the data in a PROCESSES collection
;	buffer.
;
; CALLING SEQUENCE:
;
;	CALLS #2,WRITE_PROCS_RECORDS
;
; INPUTS:
;
;	4(AP) - address of collection buffer
;
;	8(AP) - longword size of a data block (for a single process)
;
; IMPLICIT INPUTS:
;
;	None
;
; OUTPUTS:
;
;	None
;
; IMPLICIT OUTPUTS:
;
;	As many class records as are required are written to the 
;	recording file for this PROCESSES collection buffer.
;
; ROUTINE VALUE:
;
;	R0 = NORMAL, or error status, if any
;
; SIDE EFFECTS:
;
;	None
;
;--


.ENTRY	WRITE_PROC_RECORDS,	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>

	MOVL	4(AP),R7		; Get pointer to collection buffer
	MOVL	<MNR_CLS$K_HSIZE+MNR_PRO$L_PCTINT>(R7),R8
					; Get num of processes in coll buffer
	CMPL	W^PROCS_PER_REC,R8	; Need more than 1 class record?
	BLSS	10$			; Yes -- go break it up
	ALLOC	8,R1,R2			; No -- alloc a descriptor on stack
	MULL3	R8,8(AP),(R2)		; Calculate size of data area
	ADDL2	#<MNR_CLS$K_HSIZE+MNR_PRO$K_PSIZE>,(R2)
					; Add in class hdr and PROCESSES prefix
	MOVL	R7,4(R2)		; Load addr of coll buff into descr
	PUSHL	R2			; Push descriptor address
	CALLS	#1,WRITE_RECORD		; ... and write the record
	BRW	WPR_RET			; Go return with status of WRITE_RECORD

;
; Break up collection buffer into a group of records and write
; each into the recording file. All except the last will have the 
; MNR_CLS$V_CONT flag set indicating that data for this interval
; continues in the next record.
;
;
; Register Usage:
;
;	R6 =  # of full records to write
;	R7 =  collection buffer index pointer
;	R8 =  # of processes in the collection buffer;
;		also, # of processes in the final record
;	R9 =  pointer to write buffer data area
;	R10 = size of data portion of write buffer
;	R11 = pointer to write buffer descriptor
;

10$:
	DIVL3	W^PROCS_PER_REC,R8,R6	; Get number of full records to write
	MULL3	W^PROCS_PER_REC,R6,R1	; Calculate # of procs in ...
	SUBL2	R1,R8			; ... final record
	MULL3	W^PROCS_PER_REC,8(AP),R10 ; Get size of data portion of write buff
	ADDL3	#<MNR_CLS$K_HSIZE+MNR_PRO$K_PSIZE>,R10,R1
					; Compute write buffer size
	ALLOC	8,R0,R11		; Get a write buffer descr on stack
	MOVL	R1,(R11)		; Move in write buff size
	PUSHAL	4(R11)			; Push addr of write buffer ptr
	PUSHAL	(R11)			; Push addr of write buffer size
	CALLS	#2,G^LIB$GET_VM		; Get the write buffer
	BLBS	R0,20$			; Continue if status OK
	BRW	WPR_RET			; Return with status if failed
20$:
	MOVQ	(R11),W^PROC_WRI_BUFD	; Save descriptor for later cleanup
	MOVL	4(R11),R9		; Get ptr to write buffer
	MOVC3	#<MNR_CLS$K_HSIZE+MNR_PRO$K_PSIZE>,(R7),(R9)
					; Move class hdr & prefix to write buff
	ADDL2	#<MNR_CLS$K_HSIZE+MNR_PRO$K_PSIZE>,R7 ; Update coll buff ptr
	BBSS	#MNR_CLS$V_CONT,MNR_CLS$W_FLAGS(R9),30$ ; Set "continued" bit
30$:	ADDL2	#MNR_CLS$K_HSIZE,R9	; Point to PROCESSES prefix
	MOVL	W^PROCS_PER_REC,MNR_PRO$L_PCTREC(R9) ; Load # of procs this rec
	ADDL2	#MNR_PRO$K_PSIZE,R9	; Point to data portion of write buffer

;
; Loop until all processes which fit into full records
; have been handled. On each time through the loop, move
; PROCS_PER_REC processes from the collection buffer to
; the write buffer and write it out. The class header
; portion and the PROCESSES prefix portion of the write
; buffer will be identical for all these records.
;

40$:
	MOVC3	R10,(R7),(R9)		; Move group of procs from coll to write
	ADDL2	R10,R7			; Update coll buff ptr
	PUSHL	R11			; Stack ptr to write buffer descr
	CALLS	#1,WRITE_RECORD		; Write this record
	BLBC	R0,WPR_RET		; Go exit with status if failed
	SOBGTR	R6,40$			; Loop back to do next group
;
; Build and write a final record for the "leftover"
; processes which didn't fit into one of the full records.
;

	MOVL	4(R11),R1		; Get pointer to write buff class hdr
	BBCC	#MNR_CLS$V_CONT,MNR_CLS$W_FLAGS(R1),50$ ; Clear "continued" bit
50$:	ADDL2	#MNR_CLS$K_HSIZE,R1	; Point to PROCESSES prefix
	MOVL	R8,MNR_PRO$L_PCTREC(R1)	; Load # of procs in this record
	MULL3	8(AP),R8,R10		; Compute size of data portion
	TSTL	R10			; Any "leftover" data to write?
	BEQL	60$			; No -- skip around the MOVC3
	MOVC3	R10,(R7),(R9)		; Move leftovers from coll to write buff
60$:
	ALLOC	8,R0,R1			; Allocate a descr for the write
	MOVL	4(R11),4(R1)		; Get write buff ptr from previous descr
	ADDL3	#<MNR_CLS$K_HSIZE+MNR_PRO$K_PSIZE>,R10,(R1)
					; Move write buff length into descr
	PUSHL	R1			; Stack descr ptr for write
	CALLS	#1,WRITE_RECORD		; Write the last record
	BLBC	R0,WPR_RET		; Leave with status if failed
;
; Free the virtual memory occupied by the write buffer
;

	PUSHAL	4(R11)			; Stack addr of write buffer ptr
	PUSHAL	(R11)			; Stack addr of write buffer len
	CALLS	#2,G^LIB$FREE_VM	; Free the write buffer memory
	BLBC	R0,WPR_RET		; Leave with status if failed
	MOVL	NORMAL,R0		; Indicate normal status
WPR_RET:
	RET				; Return with status

	.SBTTL	CVT_TO_DELTA - Convert Seconds to Delta

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called to convert a positive seconds quantity
;	supplied in a longword to a quadword delta time quantity.
;
; CALLING SEQUENCE:
;
;	CALLS #2,CVT_TO_DELTA
;
; INPUTS:
;
;	4(AP) - address of longword containing positive seconds quantity
;
;	8(AP) - address of quadword in which to store converted delta time.
;
; IMPLICIT INPUTS:
;
;	None
;
; OUTPUTS:
;
;	Quadword addressed by 8(AP) is loaded with converted delta time.
;
; IMPLICIT OUTPUTS:
;
;	None
;
; ROUTINE VALUE:
;
;	None
;
; SIDE EFFECTS:
;
;	None
;
;--


.ENTRY	CVT_TO_DELTA,	^M<>

	EMUL	#-10*1000*1000,@4(AP),#0,@8(AP) ; That's all, folks
	RET

	.SBTTL	COMPUTE_BOOTTIME - Compute System Time of Boot

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called to compute the quadword time value
;	representing the absolute time at which the monitored
;	(running) system was booted. This is done by converting
;	the EXE$GL_ABSTIM value (absolute number of seconds since
;	boot) to a negative quadword system time value and adding
;	it to the current time (obtained via $GETTIM).
;
; CALLING SEQUENCE:
;
;	CALLS #0,COMPUTE_BOOTTIME
;
; INPUTS:
;
;	None
;
; IMPLICIT INPUTS:
;
;	EXE$GL_ABSTIM - longword containing positive number of seconds
;			since boot.
;
;	SPTR - pointer to SYI (System Information Area).
;
; OUTPUTS:
;
;	None
;
; IMPLICIT OUTPUTS:
;
;	MNR_SYI$Q_BOOTTIME loaded with boot time in system time units.
;
; ROUTINE VALUE:
;
;	R0 = NORMAL, or failing system service status
;
; SIDE EFFECTS:
;
;	None
;
;--


.ENTRY	COMPUTE_BOOTTIME,	^M<R2>

	ALLOC	8,R0,R2			; Get quadword on stack
	$GETTIM_S TIMADR=(R2)		; Put current time into it
	BLBC	R0,10$			; Exit if error
	EMUL	#-10*1000*1000,EXE$GL_ABSTIM,#0,R0
					; Get delta quadword system time units
					; ... since boot
	ADDL2	(R2),R0			; Add low-order current time
	ADWC	4(R2),R1		; ... and high-order current time
	MOVL	SPTR,R2			; Get pointer to SYI
	MOVQ	R0,MNR_SYI$Q_BOOTTIME(R2) ; Move in boot time
	MOVL	NORMAL,R0		; Indicate success
10$:
	RET				; Return

	.SBTTL	CLUS_NET_INFO - Get Cluster & Net Info

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called to gather certain info about the
;	cluster and/or network and place it into the System
;	Information Area.
;
; CALLING SEQUENCE:
;
;	CALLS #0,CLUS_NET_INFO
;
; INPUTS:
;
;	None
;
; IMPLICIT INPUTS:
;
;	CLU$GL_CLUB - 	If non-zero, then this node is a cluster member;
;			otherwise, it is not.
;
;	SPTR - pointer to SYI (System Information Area).
;
;	SCSNODE system parameter -- SCS node name in ASCII
;	SYS$NODE logical name -- DECnet node name in ASCII
;
; OUTPUTS:
;
;	None
;
; IMPLICIT OUTPUTS:
;
;	SYI updated.
;
; ROUTINE VALUE:
;
;	R0 = NORMAL, or failing system service status
;
; SIDE EFFECTS:
;
;	None
;
;--


.ENTRY	CLUS_NET_INFO,	^M<R2,R3,R4,R5,R6>

	MOVL	SPTR,R6			; Get System Info Area pointer

;
; Set MNR_SYI$V_CLUSMEM if this node is a cluster member
;

	IFCLSTR	20$			; Br if a cluster member
	BBCC	#MNR_SYI$V_CLUSMEM, -	; Else indicate not member
		MNR_SYI$W_FLAGS(R6),10$
10$:	BRB	30$			; ... and go continue
20$:	BBSS	#MNR_SYI$V_CLUSMEM, -	; Indicate a cluster member
		MNR_SYI$W_FLAGS(R6),30$
30$:

;
; Call $GETSYI to get CPU type and node name (from SCSNODE parameter)
;

	ALLOC	56,R0,R2		; Allocate local temp storage

;
; Set up item descriptor for node name
;

	MOVW	#16,(R2)		; Move in length of buffer
	MOVW	#SYI$_NODENAME,2(R2)	; Move in item identifier
	MOVAL	28(R2),4(R2)		; Move in ptr to buffer
	MOVAL	44(R2),8(R2)		; Move in ptr to length word

;
; Set up item descriptor for CPU type
;

	MOVW	#4,12(R2)		; Move in length of buffer
	MOVW	#SYI$_CPU,14(R2)	; Move in item identifier
	MOVAL	48(R2),16(R2)		; Move in ptr to buffer
	MOVAL	52(R2),20(R2)		; Move in ptr to length word
	CLRL	24(R2)			; Indicate end of item list
	$GETSYIW_S ITMLST=(R2)		; Get the CPU type & SCSNODE node name
	BLBS	R0,40$			; Continue if status OK
	BRW	CNI_RET			; Go exit if error
40$:
	MOVL	48(R2),MNR_SYI$L_CPUTYPE(R6) ; Pick up CPU type
;
; Now process node name
;

	MOVL	4(R2),R3		; Set up ptr to 1st byte of string
	MOVL	8(R2),R4		; Set up ptr to length word
	TSTW	(R4)			; Check for null node name
	BNEQ	70$			; Br if not null

;
; $GETSYI returned a null node name, so try to get the
; DECnet node name by translating logical name SYS$NODE.
;

	ALLOC	15,R2,R3		; Get the result buffer on stack
	ALLOC	2,R0,R4			; ... and a word for actual length

	$TRNLOG_S LOGNAM=W^SYSNOD_NAM, RSLBUF=(R2), -
		  RSLLEN=(R4), DSBMSK=#^B110

					; Translate SYS$NODE in system table
	BLBC	R0,CNI_RET		; Exit if error

	CMPL	#SS$_NOTRAN,R0		; SYS$NODE logical name found?
	BNEQ	70$			; Br if yes
	CLRQ	MNR_SYI$T_NODENAME(R6)	; Otherwise, clear out node name
	CLRQ	MNR_SYI$T_NODENAME+8(R6) ; .......
	BRB	CNI_SUCC		; ... and go exit

;
; A node name has been found. Now eliminate leading underscore and
; trailing double colons if present.
;
; At this point, R3 = addr of first character of node name, and
;                R4 = addr of a non-zero word length field
;

70$:

	CMPB	#^A/_/,(R3)		; Is 1st character of string an _ ??
	BNEQU	80$			; No -- go check for trailing colons
	INCL	R3			; Yes -- redefine string address ...
	DECW	(R4)			; ... and length to eliminate _
80$:
	MOVZWL	(R4),R5			; Get current length of string
	MOVAB	-2(R3)[R5],R5		; Compute addr of end of string - 2
	CMPW	#^A/::/,(R5)		; Are last 2 characters colons?
	BNEQU	90$			; No -- go move string to SYI
	SUBW2	#2,(R4)			; Yes -- shorten string by 2 bytes
90$:
	MOVB	(R4),MNR_SYI$T_NODENAME(R6); Get length of node name
	MOVC5	(R4),(R3),#0,#15, -
		MNR_SYI$T_NODENAME+1(R6) ; ... and actual name string

CNI_SUCC:
	MOVL	NORMAL,R0		; Indicate success
CNI_RET:
	RET				; Return

	.SBTTL	ADV_HOM_ITEM - Advance to next display item for homog

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called by PL/I routines to advance the
;	current (homogeneous) class to the next item for display.
;
; CALLING SEQUENCE:
;
;	CALLS #1,ADV_HOM_ITEM
;
; INPUTS:
;
;	4(AP) - address of CDB pointer for current display class
;
; IMPLICIT INPUTS:
;
;	None
;
; OUTPUTS:
;
;	None
;
; IMPLICIT OUTPUTS:
;
;	CDX$B_IDISCONSEC and CDX$B_IDISINDEX fields updated to
;	indicate the next item to be displayed.
;
; ROUTINE VALUE:
;
;	SS$_NORMAL
;
; SIDE EFFECTS:
;
;	None
;
;--


.ENTRY	ADV_HOM_ITEM,	^M<R2,R3,R4>

;
; Bump CDX$B_IDISCONSEC so that next requested item is chosen for display.
;

	MOVL	@4(AP),R2		; Get CDB address
	MOVL	CDB$A_CDX(R2),R2	; Get CDX address
	INCB	CDX$B_IDISCONSEC(R2)	; Point to next consecutive item
	CMPB	CDX$B_IDISCONSEC(R2), -	; Past final item?
		CDX$B_IDISCT(R2)
	BLEQ	10$			; Br if not
	MOVB	#1,CDX$B_IDISCONSEC(R2)	; Restart consec no. at 1st item

;
; Now update CDX$B_IDISINDEX to be in sync with the new value
; of CDX$B_IDISCONSEC.
;

10$:
	MOVL	#CDX$S_IBITS,R1		; Init bit field size
	CLRL	R0			; Init start position

	MOVZBL	CDX$B_IDISCONSEC(R2),R4	; Get item display consec no.
40$:
	FFS	R0,R1,CDX$W_IBITS(R2),R3 ; Search for next item number
					; R3 contains item number if found
	ADDL3	#1,R3,R0		; Compute next starting ...
	SUBL3	R0,#CDX$S_IBITS,R1	; ... position and field size
	SOBGTR	R4,40$			; Loop until item number is found

	MOVB	R3,CDX$B_IDISINDEX(R2)	; ... and store it away

	MOVL	#SS$_NORMAL,R0		; Normal status
	RET				; Return

	.SBTTL	COLLECTION - Collect into CURRENT Buffer

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called to collect data for the current
;	class into the buffer pointed to by the CURRENT register
;	(R8). The data is obtained either from the running system
;	(live collection) or from an input recording file (playback).
;
; CALLING SEQUENCE:
;
;	BSBW	COLLECTION
;
; INPUTS:
;
;	None
;
; IMPLICIT INPUTS:
;
;	4(AP) - address of byte containing class number
;
;	Registers:
;
;		R6  = CDB pointer
;		R7  = MRB pointer
;		R8  = CURRENT collection buffer pointer
;		R11 = MCA pointer
;
;		If non-STD class, R8 has to have been set up before
;		entry to this routine.
;
; OUTPUTS:
;
;	None
;
; IMPLICIT OUTPUTS:
;
;	CURRENT buffer filled with data for this class.
;
;	On first collection event, MRB$Q_BEGINNING is loaded with
;	  the system time of the first collection.
;
; ROUTINE VALUE:
;
;	R0 = NORMAL, or error status, if any
;
; SIDE EFFECTS:
;
;	Registers R0,R1,R2,R3,R4,R5 destroyed.
;
;--

COLLECTION:

	BBC	#MRB$V_PLAYBACK,MRB$W_FLAGS(R7),30$ ; If not collecting from
					; ... a file, go do live collection

	BBS	#CDB$V_STD,CDB$L_FLAGS(R6),10$ ; Branch if standard class
;
; PLAYBACK -- Non-standard Class (PROCESSES)
;
	BSBW	COLL_NONSTD		; Fill coll buff from playback file
	BLBC	R0,COLL_RSB		; Premature EOF error possible here
	BRB	COLL_COMM		; Go join common collection code

;
; PLAYBACK -- Standard Class
;
; Pick up (with MOVC5) the collection buffer previously placed in a 
; fixed location by the PL/I read routine.
;

10$:
	PUSHR	#^M<R9,R10>		; Save regs 9 and 10
	MOVL	MCA$A_INPUT_PTR(R11),R9	; Get base of read buffer

;
; Compute size of collection buffer
;

	MOVZWL	CDB$W_BLKLEN(R6),R10	; Get length of a data block
	BBC	#CDB$V_HOMOG,CDB$L_FLAGS(R6),20$ ; Br if hetero
	MULL2	#MAXELTS,R10		; One data block for each element
	ADDL2	#MNR_HOM$K_PSIZE,R10	; Chip in with prefix size
20$:
	ADDL2	#MNR_CLS$K_HSIZE,R10	; Add in header size

	MOVC5	MCA$L_INPUT_LEN(R11),(R9),#0,R10,(R8) ; Move to CURRENT buffer
	POPR	#^M<R9,R10>		; Restore regs 9 and 10
	BRB	COLL_COMM		; Go join common collection code

;
; LIVE COLLECTION
;
; Create argument list (on stack) for $CMKRNL call to FETCH.
;

30$:
	ADDL3	#MNR_CLS$K_HSIZE,R8,-(SP) ; Stack addr of beg of variable
					; ... portion of collection buffer
	PUSHL	R6			; Stack CDB address
	PUSHL	#2			; Top off list with arg count
	MOVL	SP,R4			; Remember arg list addr for $CMKRNL
;
; Fill collection buffer header
;
	MOVB	@4(AP),MNR_CLS$B_TYPE(R8) ; Collect class number into buffer
	CLRW	MNR_CLS$W_FLAGS(R8)	; Zero out flags ...
	CLRW	MNR_CLS$W_RESERVED(R8)	; ... and reserved word
	$CMKRNL_S  FETCH,(R4)		; Call FETCH to fill in rest of buffer

	ADDL	#12,SP			; Restore stack
	BLBC	R0,COLL_RSB		; NOPRIV or other error possible here

COLL_COMM:				; Common code for playback or live collection
	MOVL	NORMAL,R0		; Indicate successful status
	MOVW	MCA$L_CONSEC_REC(R11),MNR_CLS$W_RESERVED(R8)
					; Store (low-order word of)
					; ... consec no in coll buff
	TSTL	MCA$L_COLLCNT(R11)	; First collection?
	BNEQ	COLL_RSB		; No -- just return
	CMPB	@4(AP),MCA$B_FIRSTC(R11) ; First class?
	BNEQU	COLL_RSB		; No -- just return
	MOVQ	MNR_CLS$Q_STAMP(R8),MRB$Q_BEGINNING(R7)
					; Yes -- save start time of collection
	BBC	#MRB$V_RECORD,MRB$W_FLAGS(R7),COLL_RSB ; Exit if not recording
	CALLS	#0,WRITE_HEADER		; Write recording file header

COLL_RSB:
	RSB				; Return

;
; Since the PROCESSES class can have class data which spans several 
; records, loop reading all PROCESSES records for this interval,
; concatenating the data portions of the records into the collection
; buffer.
;

COLL_NONSTD:

	PUSHR	#^M<R7,R8,R9,R10>	; Save registers
	MOVL	MCA$A_INPUT_PTR(R11),R9	; Get base of read buffer
	MOVC3	MCA$L_INPUT_LEN(R11),(R9),(R8) ; 1st class rec to CURRENT buffer
	BBC	#MNR_CLS$V_CONT,MNR_CLS$W_FLAGS(R9),30$ ; Done if only 1 class rec
	ADDL2	MCA$L_INPUT_LEN(R11),R8	; Point to end of coll buffer
	ADDL3	#<MNR_CLS$K_HSIZE+MNR_PRO$K_PSIZE>,R9,R10
					; Point to PROCESSES data in read buff
	CLRL	R7			; Ensure high-order word is clear ...
					; ... for later use
;
; Read the next PROCESSES class record for this interval
;

10$:
	MOVL	#SKIP_TO_CLASS,-(SP)	; Indicate next class rec is desired
	PUSHL	SP			; Stack indicator for call
	CALLS	#1,READ_INPUT		; Read next class record
	ADDL2	#4,SP			; Pop stack
	BBC	#MCA$V_EOF,MCA$W_FLAGS(R11),20$ ; Continue if not end-of-file
	MOVL	#MNR$_PREMEOF,R0	; Else indicate error ...
	BRB	40$			; ... and go return
20$:
	ADDL3	#MNR_CLS$K_HSIZE,R9,R0	; Point to PROCESSES prefix in read buff
	MULW3	MNR_PRO$L_PCTREC(R0),CDB$W_BLKLEN(R6),R7
					; Calc size of next move
	MOVC3	R7,(R10),(R8)		; Next class rec to CURRENT buffer
	ADDL2	R7,R8			; Point to end of coll buffer
	BBS	#MNR_CLS$V_CONT,MNR_CLS$W_FLAGS(R9),10$ ; If cont, go read next
30$:
	MOVL	NORMAL,R0		; Indicate normal status
40$:
	POPR	#^M<R7,R8,R9,R10>	; Restore registers
	RSB				; Return


	.SBTTL	FILL_HETERO_STATS  -  Fill the STATS Buffer

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called to fill in the STATS buffer
;	for the current (heterogeneous) class, given the current
;	and previous buffers. For COUNT-type data items, each
;	STATS item is computed as CURRENT minus PREVIOUS; for
;	LEVEL-type data items, each STATS item is merely copied
;	from CURRENT. This process may be viewed as "levelizing"
;	the counts.
;
; CALLING SEQUENCE:
;
;	BSBW FILL_HETERO_STATS
;
; INPUTS:
;
;	R6 =	address of CDB (Class Descriptor Block)
;
;	R8 =	address of CURRENT buffer
;
;	R9 =	address of PREVIOUS buffer
;
;	R10 =	address of buffer block
;
; IMPLICIT INPUTS:
;
;	PERFTABLE - table describing each data item, indexed by
;			item number ( * entry size)
;
; OUTPUTS:
;
;	None
;
; IMPLICIT OUTPUTS:
;
;	STATS buffer is filled.
;
; ROUTINE VALUE:
;
;	None
;
; SIDE EFFECTS:
;
;	Registers R0,R1,R2,R3,R4,R5 destroyed.
;
;--


FILL_HETERO_STATS:

	PUSHR	#^M<R11>		; Save reg 11
	MOVL	CDB$L_ECOUNT(R6),R0	; Get number of items to fetch
	MOVL	CDB$A_ITMSTR(R6),R1	; Address of item-number string
	ADDL3	#MNR_CLS$K_HSIZE,R9,R2	; Calc start of items for PREVIOUS
	ADDL3	#MNR_CLS$K_HSIZE,R8,R3	; Calc start of items for CURRENT
	MOVL	MBP$A_STATS(R10),R4	; Get pointer to STATS
	CLRL	R11			; Clear loop counter
10$:
	MOVZBL	(R1)+,R5		; Get next item number
	MULL	#IDB$K_ILENGTH,R5	; Compute index into IDB table
	MOVAB	W^PERFTABLE[R5],R5	; Address of IDB for this item
	CASE	IDB$W_ISIZE(R5),<20$,30$,40$>,W ; Select on proper size

20$:
	CMPW	IDB$W_TYPE(R5),#COUNT_TYPE ; Is this item a count?
	BNEQ	25$			; No -- assume level type
	SUBB3	(R2)+,(R3)+,(R4)	; Compute byte diff into STATS buff
	BGEQ	23$			; Br if difference OK
	CLRB	(R4)			; Counter has decreased; use 0 value
23$:
	MOVZBL	(R4),(R4)+		; Zero-extend to longword
	BRB	50$
25$:
	MOVZBL	(R3)+,(R4)+		; Move CURRENT byte level to STATS
	TSTB	(R2)+			; Auto-increment PREVIOUS buffer
	BRB	50$
30$:
	CMPW	IDB$W_TYPE(R5),#COUNT_TYPE ; Is this item a count?
	BNEQ	35$			; No -- assume level type
	SUBW3	(R2)+,(R3)+,(R4)	; Compute word diff into STATS buff
	BGEQ	33$			; Br if difference OK
	CLRW	(R4)			; Counter has decreased; use 0 value
33$:
	MOVZWL	(R4),(R4)+		; Zero-extend to longword
	BRB	50$
35$:
	MOVZWL	(R3)+,(R4)+		; Move CURRENT word level to STATS
	TSTW	(R2)+			; Auto-increment PREVIOUS buffer
	BRB	50$
40$:
	CMPW	IDB$W_TYPE(R5),#COUNT_TYPE ; Is this item a count?
	BNEQ	45$			; No -- assume level type
	SUBL3	(R2)+,(R3)+,(R4)+	; Compute long diff into STATS buff
	BGEQ	50$			; Br if difference OK
	CLRL	-4(R4)			; Counter has decreased; use 0 value
	BRB	50$
45$:
	TSTB	IDB$B_FLAGS(R5)		;Is this a computed item?
	BEQL	47$			;branch if not
	BSBW	GET_COMPUTED_ITEMS	;otherwise need to do some special calc.
	BRB	50$			;continue
47$:
	MOVL	(R3)+,(R4)+		; Move CURRENT longword level to STATS
	TSTL	(R2)+			; Auto-increment PREVIOUS buffer
50$:
	AOBLSS	R0,R11,10$		; Loop until done
	POPR	#^M<R11>		; Restore reg 11
	RSB				; ... and return




;++
; GET_COMPUTED_ITEMS
; 
;
;	Computed items are items which are not recorded, but are transformations
;	of other items.  This routine makes the appropriate transformations and
;	loads the STATS buffer for computed items.
;
;		R2 = address of current longword in PREVIOUS buffer
;		R3 = address of current longword in CURRENT buffer
;		R4 = address of current longword in STAT buffer
;

; Currently, the only type of computed item supported by Monitor is
; the percentage item.  Here are the steps involved in adding a new percentage
; item:
;		-  The item is flagged as a percentage by including
;		   FLAGS=IDB$M_PCNT in the BLDIDB for the item.  The item
;		   Type should be LEVEL.
;		-  The next two items following the percentage in the class
;		   will be used to calculate the percentage value.  The formula
;		   is 
;			Percentage value = (Item1 * 100)/Item2
;
;		   For example, in the case of XQPCACHE percentages,
;		   Item1 = Cache hits and item2 = (Cache hits + Cache misses)
;		   The items used to calculate the percentage must be longwords.
;
;		-  The percentage and item2 will be displayed; item1 will
;		   not be displayed.
;		
; Computed items currently may only be included in Standard Heterogeneous 
; classes.  

; To add a new type of computed item, define a new bitmask for IDB$B_FLAGS
; (for-instance IDB$M_RATIO) and add the necessary code to do the new 
; computation.  GET_COMPUTED_ITEMS will be called by FILL_HETERO_STATS anytime 
; the IDB$B_FLAGS field is nonzero, so this routine is one place you will want 
; to add new code.  Depending on the nature of the item, you may need to add 
; code elsewhere.  (for-instance, TEMPLATE, to prevent display of items used 
; in the calculation, and INTAVE to do special processing to obtain the 
; average for the item).

; Computed items are included in the item count for a class, but are not
; included in the CDB$W_BLKLEN value.  
;--

GET_COMPUTED_ITEMS:
;
; If this is a percent, compute the long dif for the following two items
; and do the calculation to end up with a level in the stats buff.
; Also, increment the stats buff pointer but not current or prev.
;
	PUSHR	#^M<R6,R7>		;save some registers so we can use them
	BBC	#IDB$V_PCNT, IDB$B_FLAGS(R5), 20$	;branch if not a percent
	CLRL	(R4)		; zero longword for this pcnt item in STAT buff 
	SUBL3	(R2),(R3),R6	; Current minus previous for item1 into R6
	SUBL3	4(R2),4(R3),R7	; Current minus previous for item2 into R7
	TSTL	R7		; Is the sum nonzero?
	BEQL	10$		; branch if it is zero to skip percent calc.
;
; now create a percentage value: (item1 * 100)/(item1 + item2)
;
	MULL2	#100,R6		;
	DIVL3	R7,R6,(R4)	;move the percentage result into the STAT buff.
10$:
	TSTL	(R4)+		;auto-increment the STAT buffer pointer.
20$:
	POPR	#^M<R6,R7>	;restore the registers
	RSB			;return


	.SBTTL	FILL_PCSTATS_BUFF - Fill PCSTATS Buffer from STATS Buffer

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	Fill the PCSTATS buffer with integer values representing
;	tenths of percent for each item in the STATS buffer.
;
; INPUTS:
;
;	R6  - CDB pointer
;	R10 - Buffer block pointer
;
; IMPLICIT INPUTS:
;
;	STATS buffer containing levels to be "percentized."
;
; OUTPUTS:
;
;	None
;
; IMPLICIT OUTPUTS:
;
;	PCSTATS buffer filled with integer values representing
;	tenths of percent.
;
; ROUTINE VALUE:
;
;	None
;
; SIDE EFFECTS:
;
;	Registers R0, R1, R3, R4 destroyed.
;--

FILL_PCSTATS_BUFF:

	MOVL	MBP$A_PCSTATS(R10),R3	; Load PCSTATS buffer pointer
	MOVL	MBP$A_STATS(R10),R4	; Load STATS buffer pointer
	MOVL	CDB$L_ECOUNT(R6),R0	; Get number of elements
	CLRL	R1			; Clear accumulator
10$:
	ADDL2	(R4)+,R1		; Add next item
	SOBGTR	R0,10$			; Continue until STATS summed
	MOVL	MBP$A_STATS(R10),R4	; Re-load STATS buffer pointer
	MOVL	CDB$L_ECOUNT(R6),R0	; ... and number of elements
	TSTL	R1			; Zero sum?
	BNEQ	30$			; No -- go calc percentages
20$:
	MOVL	(R4)+,(R3)+		; Yes -- simply move zeroes
	SOBGTR	R0,20$			; ... into PCSTATS buffer
	BRB	40$			; ... and go exit
30$:
	MULL3	#1000,(R4)+,(R3)	; Multiply value by 1000 ... and
	DIVL2	R1,(R3)+		; Divide by sum, leaving tenths of %
	SOBGTR	R0,30$			; Continue for all items
40$:
	RSB				; Return

	.SBTTL	COMPUTE_STATS - Statistical Computations on STATS

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	Replace each count item in the STATS buffer with a computed
;	(floating-point) rate per second. Also, replace each item in
;	the MIN and MAX buffers with the corresponding item from the
;	STATS buffer if it establishes a new minimum or maximum value.
;
; INPUTS:
;
;	R6  - CDB pointer
;	R7  - MRB pointer
;	R8  - CURRENT buffer pointer
;	R9  - PREVIOUS buffer pointer
;	R10 - Buffer block pointer
;	R11 - MCA pointer
;
; IMPLICIT INPUTS:
;
;	STATS buffer
;
;	HOMOG_TYPE - word containing item type code of current
;		     item for homogeneous class.
;
;	PERFTABLE - table describing each data item, indexed by
;			item number ( * entry size).
;
;	MCA$L_INTTICKS - clock ticks during interval just finished
;
; OUTPUTS:
;
;	None
;
; IMPLICIT OUTPUTS:
;
;	Each count element in STATS buffer converted to floating rate/second.
;
;	Elements in MIN and MAX buffers updated if new min and max
;	values were achieved in the interval just completed.
;
; ROUTINE VALUE:
;
;	None
;
; SIDE EFFECTS:
;
;	Registers R0,R1,R2,R3,R4,R5 destroyed.
;--

COMPUTE_STATS:

	PUSHR	#^M<R8,R9>		; Save regs
;
; Load registers for upcoming buffer manipulations
;

10$:
	MOVL	MBP$A_STATS(R10),R2	; Load addr of first STATS item
	MOVL	MBP$A_MIN(R10),R8	; Load addr of first MIN item
	MOVL	MBP$A_MAX(R10),R9	; Load addr of first MAX item
	MOVL	CDB$A_ITMSTR(R6),R0	; Load addr of item-number string
	MOVL	CDB$L_ECOUNT(R6),R3	; Load number of items in STATS
	CLRL	R1			; Clear loop counter
20$:
	BBC	#CDB$V_HOMOG,CDB$L_FLAGS(R6),25$  ; Br if heterogeneous
	CMPW	W^HOMOG_TYPE,#COUNT_TYPE ; Is this homog item a count?
	BNEQU	30$			; No -- assume level
	BRB	50$			; Yes -- go process count
25$:
	BBC	#CDB$V_CTPRES,CDB$L_FLAGS(R6),30$ ; Skip type check if no counts
	MOVZBL	(R0)+,R5		; Get next item number
	MULL	#IDB$K_ILENGTH,R5	; Compute index into IDB table
	MOVAB	W^PERFTABLE[R5],R5	; Address of IDB for this item
	CMPW	IDB$W_TYPE(R5),#COUNT_TYPE ; Is this item a count?
	BEQLU	50$			; Yes -- go compute rate
;
; Update MIN and MAX buffers for this item (level).
;

30$:
	CMPL	(R2)[R1],(R8)[R1]	; Check minimum
	BGEQ	40$			; Branch if not less
	MOVL	(R2)[R1],(R8)[R1]	; Else insert new minimum
40$:
	CMPL	(R2)[R1],(R9)[R1]	; Check maximum
	BLEQ	70$			; Branch if not more
	MOVL	(R2)[R1],(R9)[R1]	; Else insert new maximum
	BRB	70$			; ... and go loop
;
; Compute rate/second for this count item, replacing count in
; STATS buffer.
;

50$:
	CVTLF	(R2)[R1],R4		; Get floating value over interval
	CVTLF	MCA$L_INTTICKS(R11),R5	; Get floating ticks over interval
	DIVF2	#100,R5			; Get floating seconds over interval
	DIVF3	R5,R4,(R2)[R1]		; Floating rate/second into STATS
;
; Update MIN and MAX buffers for this item (count).
;

	CMPF	(R2)[R1],(R8)[R1]	; Check minimum
	BGEQ	60$			; Branch if not less
	MOVF	(R2)[R1],(R8)[R1]	; Else insert new minimum
60$:
	CMPF	(R2)[R1],(R9)[R1]	; Check maximum
	BLEQ	70$			; Branch if not more
	MOVF	(R2)[R1],(R9)[R1]	; Else insert new maximum
70$:
	AOBLSS	R3,R1,20$		; Loop for each item in STATS

	POPR	#^M<R8,R9>		; Restore regs
	RSB				; Return

	.SBTTL	UPD_PC_MIN_MAX - Update Percent Min/Max Buffers

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	Replace each item in the PCMIN and PCMAX buffers with the
;	corresponding item from the PCSTATS buffer if it establishes
;	a new minimum or maximum value.
;
; CALLING SEQUENCE:
;
;	BSBW UPD_PC_MIN_MAX
;
; INPUTS:
;
;	R6  - CDB pointer
;	R10 - Buffer block pointer
;	R11 - MCA pointer
;
; IMPLICIT INPUTS:
;
;	PCSTATS buffer containing percent values derived from
;	most recently collected levels.
;
; OUTPUTS:
;
;	None
;
; IMPLICIT OUTPUTS:
;
;	Items in PCMIN and PCMAX buffers updated accordingly.
;
; ROUTINE VALUE:
;
;	None
;
; SIDE EFFECTS:
;
;	Registers R0,R1,R2,R3,R4,R5 destroyed.
;--


UPD_PC_MIN_MAX:

	MOVL	MBP$A_PCSTATS(R10),R3	; Load PCSTATS ptr
	MOVL	MBP$A_PCMIN(R10),R4	; Load PCMIN ptr
	MOVL	MBP$A_PCMAX(R10),R5	; Load PCMAX ptr
	MOVL	CDB$L_ECOUNT(R6),R0	; Get element count
	CLRL	R2			; Clear loop counter

;
; Replace minimum and maximum (if necessary) for each item
;

10$:
	CMPL	(R3)[R2],(R4)[R2]	; Check minimum
	BGEQ	20$			; Branch if not less
	MOVL	(R3)[R2],(R4)[R2]	; Else insert new minimum
20$:
	CMPL	(R3)[R2],(R5)[R2]	; Check maximum
	BLEQ	30$			; Branch if not more
	MOVL	(R3)[R2],(R5)[R2]	; Else insert new maximum
30$:
	AOBLSS	R0,R2,10$		; Loop for each item in PCSTATS

	RSB				; Return

	.SBTTL	DISPLAY_INIT - Init for Display Output

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine performs initialization for DISPLAY output.
;
; CALLING SEQUENCE:
;
;	CALLS #0, DISPLAY_INIT
;
; INPUTS:
;
;	None.
;
; IMPLICIT INPUTS:
;
;	MRBPTR - pointer to MRB (Monitor Request Block)
;	MCAPTR - pointer to MCA (Monitor Communication Area)
;
; OUTPUTS:
;
;	BARCHAR loaded with appropriate bar character.
;
;	SYSOUT_TYPE loaded with display output device class.
;
;		The four classes are:
;
;			DEC_CRT
;			VT5X
;			OTHER_VID
;			HARDCOPY (including disk file)
;
;	MCA$V_VIDEO set if display device is a video terminal.
;
;	MCA$V_GRAPHICS set if display device is a VT55.
;
;	ATTRIBMSK (DEC_CRT video attribute mask) cleared.
;
; IMPLICIT OUTPUTS:
;
;	None.
;
; ROUTINE VALUE:
;
;	R0 = NORMAL or failing status from SCRPKG routine.
;
; SIDE EFFECTS:
;
;	None
;
; REGISTER USAGE:
;
;	R7   = MRB pointer
;	R11  = MCA pointer
;
;--


.ENTRY	DISPLAY_INIT,	^M<R2,R3,R7,R11>

	CLRL	W^ATTRIBMSK		; Turn off DEC_CRT attributes
	MOVL	MRBPTR,R7		; Load MRB pointer
	MOVL	MCAPTR,R11		; Load MCA pointer
	BBSS	#MRB$V_DIS_CL_REQ,MRB$W_FLAGS(R7),5$
5$:					; Indicate display cleanup required
	BSBW	COMMON_INIT		; Do initialization common with SUMMARY

;
; Establish SCRPKG output stream
;

	TSTL	MRB$A_DISPLAY(R7)	; Is there a display file-spec?
	BEQL	10$			; No -- continue
	PUSHL	MRB$A_DISPLAY(R7)	; Yes -- stack it for SET_OUTPUT
	PUSHL	#1			; ... along with a stream identifier
	CALLS	#2,G^SCR$SET_OUTPUT	; Establish output stream
	BLBS	R0,10$			; Continue if status OK
	BRW	110$			; Go exit if SCR$SET_OUTPUT failed

;
; Establish bar character, sysout device type.
;
; Set MCA$V_VIDEO bit if a video terminal.
;
; Set MVA$V_GRAPHICS if a VT55 terminal.
;

10$:
	MOVB	#DEF_BAR,W^BARCHAR	; Start out with default bar char
	MOVB	#OTHER_VID,W^SYSOUT_TYPE ; ... and assume "other video" sysout type
	ALLOC	9,R1,R2			; Allocate 9 bytes for screen info
	PUSHL	R2			; Stack addr of screen info buffer
	CALLS	#1,G^SCR$SCREEN_INFO	; Get screen info (dev type)
	BLBS	R0,20$			; Continue if status OK
	BRW	110$			; Go exit if SCR$SCREEN_INFO failed
20$:
	MOVB	SCR$B_DEVTYPE(R2),R3	; Save SYS$OUTPUT device type
	BBC	#SCR$V_SCREEN,SCR$L_FLAGS(R2),30$ ; If not video, keep going
	BBSS	#MCA$V_VIDEO,MCA$W_FLAGS(R11),40$ ; Otherwise, indicate video
	BRB	40$			; ... and continue
30$:
	MOVB	#HARDCOPY,W^SYSOUT_TYPE	; Set hardcopy type
	BRB	100$			; ... and go take def bar char
40$:
	CMPB	#DT$_VT55,R3		; Is it a VT55 ?
	BNEQU	60$			; No -- go check for other types
	BBSS	#MCA$V_GRAPHICS,MCA$W_FLAGS(R11),50$
					; Yes -- indicate VT55-style graphics
50$:
	MOVB	#VT5X,W^SYSOUT_TYPE	; Indicate VT5x series
	BRB	90$			; Go set special bar char
60$:	BBC	#SCR$V_DECCRT,SCR$L_FLAGS(R2),70$ ; If not DEC CRT, keep going
	MOVB	#DEC_CRT,W^SYSOUT_TYPE	; Set DEC CRT
	BRB	90$			; ... and go set special bar char
70$:	CMPB	#DT$_VT100,R3		; Is it a VT100 ?
	BNEQU	80$			; No -- more checking
	MOVB	#DEC_CRT,W^SYSOUT_TYPE	; Yes -- set DEC CRT
	BRB	90$			; ... and go set special bar char
80$:
	CMPB	#DT$_VT52,R3		; Is it a VT52 ?
	BNEQU	100$			; No -- take def bar char and type
	MOVB	#VT5X,W^SYSOUT_TYPE	; Yes -- indicate VT5x series
90$:	MOVB	#VID_BAR,W^BARCHAR	; Indicate special bar char

100$:
	BSBW	MOVE_BARS		; Move bar char into several places


;
; Kick off buffering mode for the Screen Package
;

	PUSHAQ	SCRDSC			; Push this routine's buffer addr
	CALLS	#1,G^LIB$SET_BUFFER	; Set buffering mode
110$:
	RET				; Return with R0 = status

	.SBTTL	SUMMARY_INIT - Init for Summary Output

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine performs initialization for SUMMARY output.
;
; CALLING SEQUENCE:
;
;	CALLS #0, SUMMARY_INIT
;
; INPUTS:
;
;	None.
;
; IMPLICIT INPUTS:
;
;	MRBPTR - pointer to MRB (Monitor Request Block)
;
; OUTPUTS:
;
;	BARCHAR loaded with appropriate bar character.
;
;	SYSOUT_TYPE loaded with display output device type.
;
;	ATTRIBMSK (DEC_CRT video attribute mask) cleared.
;
; IMPLICIT OUTPUTS:
;
;	None.
;
; ROUTINE VALUE:
;
;	R0 = NORMAL or failing status from SCRPKG routine.
;
; SIDE EFFECTS:
;
;	None
;
; REGISTER USAGE:
;
;	R7   = MRB pointer
;
;--


.ENTRY	SUMMARY_INIT,	^M<R7>

	CLRL	W^ATTRIBMSK		; Turn off DEC_CRT attributes
	MOVL	MRBPTR,R7		; Load MRB pointer
	BBSS	#MRB$V_SUM_CL_REQ,MRB$W_FLAGS(R7),5$
5$:					; Indicate summary cleanup required
	BBS	#MRB$V_DISPLAY,MRB$W_FLAGS(R7),10$ ; Skip init if already done
	BSBW	COMMON_INIT		; Do initialization common with DISPLAY

;
; Establish SCRPKG output stream
;

10$:
	PUSHL	MRB$A_SUMMARY(R7)	; Stack SUMMARY filespec for SET_OUTPUT
	PUSHL	#1			; ... along with a stream identifier
	CALLS	#2,G^SCR$SET_OUTPUT	; Establish output stream
	BLBS	R0,20$			; Continue if status OK
	BRW	40$			; Go exit if SCR$SET_OUTPUT failed

;
; Establish bar character, sysout device type.
;

20$:
	MOVB	#DEF_BAR,W^BARCHAR	; Use default bar character
	BSBB	MOVE_BARS		; Move bar char into several places
	MOVB	#HARDCOPY,SYSOUT_TYPE	; Treat SYS$OUTPUT dev type as hardcopy
	BBSS	#MRB$V_DISP_TO_FILE,MRB$W_FLAGS(R7),30$
					; Indicate output to file
30$:

;
; Kick off buffering mode for the Screen Package
;

	PUSHAQ	SCRDSC			; Push this routine's buffer addr
	CALLS	#1,G^LIB$SET_BUFFER	; Set buffering mode
40$:
	RET				; Return with R0 = status

COMMON_INIT:

;
; Do initialization for DISPLAY and SUMMARY options.
;

	MOVL	#SS$_NORMAL,W^PTS_STAT	; Start off request with clean status

;
; Set up footing display line with appropriate words
;

	MOVAL	W^BLANK_STR,W^FOOTP	; Indicate blank string for PLAYBACK
	BBC	#MRB$V_PLAYBACK,MRB$W_FLAGS(R7),10$ ; Continue if no PLAYBACK
	MOVAL	W^PLAY_STR,W^FOOTP	; Indicate PLAYBACK string in footing
10$:
	MOVAL	W^BLANK_STR,W^FOOTS	; Indicate blank string for SUMMARY
	BBC	#MRB$V_SUMMARY,MRB$W_FLAGS(R7),20$ ; Continue if no SUMMARY
	MOVAL	W^SUMM_STR,W^FOOTS	; Indicate SUMMARY string in footing
20$:
	MOVAL	W^BLANK_STR,W^FOOTR	; Indicate blank string for RECORD
	BBC	#MRB$V_RECORD,MRB$W_FLAGS(R7),30$ ; Continue if no RECORD
	MOVAL	W^REC_STR,W^FOOTR	; Indicate RECORD string in footing
30$:
	RSB				; Return


MOVE_BARS:				; Move bar char into several places
	MOVB	W^BARCHAR,W^TOPBAR	; Move bar char into TOP display line
	MOVB	W^BARCHAR,BAR1		; ... and into SYSTEM class FAO str
	MOVB	W^BARCHAR,BAR2		; .....
	MOVB	W^BARCHAR,BAR3		; .....
	MOVB	W^BARCHAR,BAR4		; .....
	MOVB	W^BARCHAR,BAR5		; .....
	MOVB	W^BARCHAR,BAR6		; .....
	MOVB	W^BARCHAR,BAR7		; .....
	MOVB	W^BARCHAR,BAR8		; .....
	MOVB	W^BARCHAR,BAR9		; .....
	MOVB	W^BARCHAR,BAR10		; .....
	MOVB	W^BARCHAR,BAR11		; .....

	MOVAL	SYS_BOX_STR_G,SYS_BOX_STR_ADDR ; Choose graphic box str (SYSTEM)
	MOVW	SYS_BOX_STR_LEN_G,SYS_BOX_STR_LEN ; ... and its length
	CMPB	BARCHAR,#DEF_BAR	; This terminal use the def bar char?
	BNEQ	10$			; No, all done
	MOVAL	SYS_BOX_STR_H,SYS_BOX_STR_ADDR ; Choose hardcopy box str
	MOVW	SYS_BOX_STR_LEN_H,SYS_BOX_STR_LEN ; ... and its length
10$:
	RSB

	.SBTTL	FILL_DISP_BUFF - Fill Display Buffer 

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called to fill the display buffer with values
;	to be presented to FAOL for display of the screen for the current
;	class. The address of the CDB for the current class is passed
;	as the first parameter to this routine. The second parameter is
;	the address of a quadword into which this routine will store the
;	time stamp from the most recent collection buffer.
;
; CALLING SEQUENCE:
;
;	CALLS #2,FILL_DISP_BUFF
;
; INPUTS:
;
;	 4(AP) - address of a pointer to the CDB (Class Descriptor Block)
;		 for the class to display.
;
;	 8(AP) - address of quadword in which to store the time
;		 stamp from the most recent collection buffer.
;
; IMPLICIT INPUTS:
;
;	MCAPTR - pointer to MCA (Monitor Communication Area)
;
;	MRBPTR - pointer to MRB (Monitor Request Block)
;
;	PERFTABLE - table describing each data item, indexed by
;			item number ( * entry size)
;
;	FAOSTK - buffer into which to store values for later FAOL call.
;
; OUTPUTS:
;
;	Quadword pointed to by 8(AP) is filled with time stamp from
;	most recent collection buffer.
;
; IMPLICIT OUTPUTS:
;
;	Display buffer (FAOSTK) buffer is filled.
;
;	For the non-standard class (PROCESSES),
;	MCA$L_PROC_DISP is filled with the count
;	of processes to display.
;
; ROUTINE VALUE:
;
;	R0 = SS$_NORMAL
;
; SIDE EFFECTS:
;
;	None
;
; REGISTER USAGE:
;
;	R5 = pointer to current longword in FAOSTK
;	R6 = address of CDB for class to display
;	R7 = scratch
;	R10 = address of buffer block
;	R11 = address of TM4, a temporary stack area
;
;	Other registers: see below
;
;--


.ENTRY	FILL_DISP_BUFF,	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>

	MOVL	@4(AP),R6		; Load CDB pointer
	ALLOC	TM4$K_SIZE,R0,R11	; Allocate local temp storage

	MOVL	CDB$A_BUFFERS(R6),R10	; Load address of buffer block (MBP)
	BBC	#CDB$V_HOMOG,CDB$L_FLAGS(R6),10$ ; Br if not homog class
	MOVL	CDB$A_CDX(R6),R0	; Get CDX address
	MOVZBL	CDX$B_IDISCONSEC(R0),R0	; Get no. of curr display item
	DECL	R0			; Decrement to use as index
	MOVL	(R10)[R0],R10		; Get MBP ptr for homog class

;
; Return time stamp from most recent collection buffer to caller.
;

10$:
	MOVL	MBP$A_BUFFERA(R10),R9	; Assume BufferA is current
	BBC	#CDB$V_SWAPBUF,CDB$L_FLAGS(R6),20$ ; Br if so
	MOVL	MBP$A_BUFFERB(R10),R9	; BufferB is current
20$:
	MOVQ	MNR_CLS$Q_STAMP(R9),@8(AP) ; Give current time stamp to caller

	MOVL	CDB$L_ECOUNT(R6), -	; Pick up element count
		TM4$L_ECOUNT(R11)
	MOVL	CDB$A_ITMSTR(R6), -	; ... and item string addr
		TM4$A_ITMSTR(R11)

;
; Note -- at this point, R10 contains MBP pointer; element count
; and item string address are in TM4$L_ECOUNT and TM4$A_ITMSTR.
;

	BBC	#CDB$V_STD,CDB$L_FLAGS(R6),50$ ; Branch if non-standard class

	BRW	FDB_STD			; Go process standard class

50$:					; Non-standard class (PROCESSES)
	CMPB	CDB$B_ST(R6),#REG_PROC	; Regular PROCESSES display?
	BEQL	FDB_REGPROC		; Yes -- go fill display buffer for it
					; No -- TOP PROCESSES display

;
; Calculate the two quantites BPU and GMIN for use later in computing
; the size of the bar graph:
;
;	BPU  - floating longword, no of bar chars per unit of output value
;	GMIN - integer longword, min value which graph can represent for this class
;

	BBS	#CDB$V_PERCENT,CDB$W_QFLAGS(R6),60$ ; Check for percent requested
	CVTLF	CDB$L_RANGE(R6),R7	; No percent -- get floating range for graph
	MOVL	CDB$L_MIN(R6),GMIN	; Get minimum value for graph
	BRB	70$			; Join common code
60$:
	CVTLF	#100,R7			; 100 is range of percent graph
	CLRL	GMIN			; 0 is min value of percent graph
70$:
	CVTBF	#MAXBARS,R8		; Get max bar chars per line
	DIVF3	R7,R8,BPU		; Calculate bar chars per unit of output

	PUSHL	R6			; Stack PROCESSES CDB pointer
	CALLS	#1,FILL_TOP		; Fill display buffer for TOP display
	BRW	FDB_RET			; ... and go return

;
; Fill display buffer for non-standard class (PROCESSES)
; (regular display).
;
; Register usage:
;
;	R0 = scratch
;	R1 = scratch
;	R2 = process index
;	R3 = process count
;	R5 = pointer to current longword in FAOSTK
;	R6 = address of CDB for class to display
;	R7 = scratch
;	R9 = CURRENT collection buffer
;	R10 = address of buffer block
;	R11 = address of TM4, a temporary stack area
;

FDB_REGPROC:

	ADDL2	#MNR_CLS$K_HSIZE,R9	; Point to PROCESSES prefix
	MOVL	MNR_PRO$L_PCTINT(R9),R3	; Get process count
	MOVL	MCAPTR,R0		; Get MCA pointer
	MOVL	R3,MCA$L_PROC_DISP(R0)	; Save count for the display rtn
	ADDL2	#MNR_PRO$K_PSIZE,R9	; Point to first data block
	MOVL	#1,R2			; Init loop counter
	MOVL	MBP$A_PR_FAOSTK(R10),R5	; Init FAO stack (display buffer) pointer

;
; Move individual items for this process from current data block
; in collection buffer to longwords in FAO stack.

10$:

	MOVL	MNR_PRO$L_IPID(R9),R0	; Pick up internal PID
	CMPW	#MNR_PRO$L_EPID,CDB$W_BLKLEN(R6) ; See if we have an EPID
	BGEQ	15$			; Br if we do not
	MOVL	MNR_PRO$L_EPID(R9),R0	; Take the EPID instead
15$:
	MOVL	R0,(R5)+		; PID to FAO stack

;
; Get STATE cstring pointer
;

	MOVZWL	MNR_PRO$W_STATE(R9),R0	; Get state number

	MOVL	STATELIST[R0],R0	; Get the STATE cstring.
	CMPW	#SCH$C_MWAIT,-		; Is the process in MWAIT?
		MNR_PRO$W_STATE(R9)	;
	BNEQU	20$			;  No, keep process' STATE cstring.
	CMPW	#MNR_PRO$L_EFWM,-	;  Yes, see if we have an EFWM
		CDB$W_BLKLEN(R6)
	BGEQ	20$			;  No, simply use MWAIT cstring
	MOVL	MWAITLIST,R0		;  Yes, get the generic MUTEX cstring.
	BBS	#31,-			; Is this is a MUTEX address?
		MNR_PRO$L_EFWM(R9),20$	;  Yes, keep the MUTEX cstring.
	MOVL	RWAITLIST,R0		;  No, get the generic RWUNK cstring.
	CMPW	#RSN$_MAX,-		; Is this resource wait code defined?
		MNR_PRO$L_EFWM(R9)	; 
	BLEQU	20$			;  No, keep the RWUNK cstring.
	MOVZWL	MNR_PRO$L_EFWM(R9),R0	;  Yes, get the resource wait number.
	MOVL	RWAITLIST[R0],R0	; Get the RWccc cstring.

20$:
	MOVL	R0,(R5)+		; ... and move it to FAO stack

;
; Get remainder of process items
;

	MOVZBL	MNR_PRO$B_PRI(R9),R7	; Get priority (31's complement)
	SUBL3	R7,#31,(R5)+		; Complement it and move to FAO stack
	MOVQ	MNR_PRO$O_LNAME(R9),(R5)+ ; Process name cstring to FAO stack
	MOVQ	MNR_PRO$O_LNAME+8(R9),(R5)+ ; .....
	MOVZBL	-16(R5),(R5)+		; Length of process name to FAO stack
	SUBL3	#19,R5,(R5)+		; Address of process name to FAO stack
	MOVZWL	MNR_PRO$W_GPGCNT(R9),(R5)+ ; Global page count to FAO stack
	ADDW3	MNR_PRO$W_GPGCNT(R9),MNR_PRO$W_PPGCNT(R9),R7
					; Get sum of global & process page cnts
	MOVZWL	R7,(R5)+		; ... and move to FAO stack
	BBS	#PCB$V_RES,MNR_PRO$L_STS(R9),30$ ; Br if process was resident
	ADDL2	#16,R5			; Process non-res; skip next 4 longwords
	CLRL	(R5)+			; Clear CPUTIM ptr to indicate non-res
	BRB	40$			; ... and continue
30$:					; Resident process
	MOVL	MNR_PRO$L_DIOCNT(R9),(R5)+   ; DIO count to FAO stack
	MOVL	MNR_PRO$L_PAGEFLTS(R9),(R5)+ ; Page fault count to FAO stack
	EMUL	#100000,MNR_PRO$L_CPUTIM(R9),#0,(R5)+
					; Xlate ticks to quad time val & move to FAO stack
	SUBL3	#8,R5,(R5)+		; ... and move ptr to it into FAO stack
40$:
	MOVZWL	CDB$W_BLKLEN(R6),R0	; Get length of a data block
	ADDL2	R0,R9			; Point to next (process) data block in coll buffer
	ACBL	R3,#1,R2,10$		; Loop to move next process to FAO stack
	BRW	FDB_RET			; All processes done ... go return

;
; Fill display buffer (FAOSTK) for standard classes.
;
; Register usage:
;
;	R0 = scratch, address of current item number
;	R1 = scratch
;	R2 = data item index
;	R3 = address of statistics buffer from buffer block
;	R4 = address of IDB for current data item
;	R5 = pointer to current longword in FAOSTK
;	R6 = address of CDB for class to display
;	R7 = scratch
;	R8 = statistic code (ALL =0, CUR=1, AVE=2, MIN=3, MAX=4)
;	R9 = scratch
;	R10 = address of buffer block
;	R11 = address of TM4, a temporary stack area
;

FDB_STD:

;
; For homogeneous class, store number of elements to display
; (for use in later display routines).
;

	BBC	#CDB$V_HOMOG,CDB$L_FLAGS(R6),10$ ; Br if a heterogeneous class

	MOVL	CDB$A_CDX(R6),R0	; Get CDB extension for HOMOG class
	MOVL	TM4$L_ECOUNT(R11), -	; Store number of elts to display
		CDX$L_DCOUNT(R0)
10$:
	TSTL	TM4$L_ECOUNT(R11)	; Any elements to display?
	BNEQ	20$			; Br if have some
	BRW	FDB_RET			; Else go exit if none
20$:

;
; If AVERAGE or ALL statistic requested, calculate floating elapsed
; seconds from start of monitor request to time of most recent collection
; event. Store it on the stack for later use.
;

	CMPB	CDB$B_ST(R6),#ALL_STAT	; ALL stats requested ?
	BEQL	30$			; Br if yes
	CMPB	CDB$B_ST(R6),#AVE_STAT	; Was AVERAGE stat requested ?
	BNEQ	40$			; No -- skip following calculation
30$:
	MOVL	MRBPTR,R7		; Get temp pointer to MRB
	MOVL	MNR_CLS$Q_STAMP+4(R9),R1 ; Get high order bits of time
	SUBL3	MRB$Q_BEGINNING(R7),MNR_CLS$Q_STAMP(R9),R0 ; Compute elapsed time since start
	SBWC	MRB$Q_BEGINNING+4(R7),R1 ; Get high order difference
	EDIV	#10000,R0,R0,R1		; Turn time into milliseconds
	CVTLF	R0,R0			; Floating milliseconds
	DIVF3	#1000,R0,TM4$L_FLTSECS(R11) ; Save floating seconds on stack
					; ... for later use

;
; Execute special routines if this is the SYSTEM class
;

40$:
	BBC	#CDB$V_SYSCLS,CDB$L_FLAGS(R6),55$ ; Br if not SYSTEM class
	CMPB	CDB$B_ST(R6),#ALL_STAT	; ALL stats requested ?
	BEQL	50$			; Br if yes
	ALLOC	<4*ECOUNT_SYS_SINGLE>,R0,R3 ; Single stat -- get dummy buffer
	BRW	FDB_SYS_SINGLE		; ... and branch to special rtn
50$:
	ALLOC	<MBP$K_SIZE+<4*4*ECOUNT_SYS_ALL>>,R0,R10
					; Alloc dummy MBP and stats buffers
					; ... pointed to by R10
	JSB	FDB_SYS_ALL		; Pre-process the SYSTEM class
55$:

	MOVAL	FAOSTK,R5		; Load addr of display buffer
	MOVZBL	CDB$B_ST(R6),R8		; Load requested statistic

;
; If single statistic (not ALL) requested, calculate and store two quantities
; for later use:
;
;	BPU  - floating longword, no of bar chars per unit of output value
;	GMIN - integer longword, min value which graph can represent for this class
;

	CMPL	R8,#ALL_STAT		; ALL requested?
	BEQL	80$			; Yes -- continue	
	BBS	#CDB$V_PERCENT,CDB$W_QFLAGS(R6),60$ ; No -- check for percent requested
	CVTLF	CDB$L_RANGE(R6),R0	; No percent -- get floating range for graph
	MOVL	CDB$L_MIN(R6),GMIN	; Get minimum value for graph
	BRB	70$			; Join common code
60$:
	CVTLF	#100,R0			; 100 is range of percent graph
	CLRL	GMIN			; 0 is min value of percent graph
70$:
	CVTBF	#MAXBARS,R1		; Get max bar chars per line
	DIVF3	R0,R1,BPU		; Calculate bar chars per unit of output

;
; For homogeneous class, determine item type for use below.
;

80$:
	BBC	#CDB$V_HOMOG,CDB$L_FLAGS(R6),90$ ; Br if a heterogeneous class

	MOVL	CDB$A_CDX(R6),R2	; Get CDB extension for HOMOG class

	MOVZBL	CDX$B_IDISINDEX(R2),R3	; Get item index for this disp event
	MOVZBL	@TM4$A_ITMSTR(R11)[R3],R4 ; Load IDB item number
	MULL2	#IDB$K_ILENGTH,R4	; Compute index into IDB table
	MOVAB	W^PERFTABLE[R4],R4	; Address of IDB for this item
	MOVW	IDB$W_TYPE(R4),W^ITEM_TYPE ; Save item type for use below

;
; Loop once for each element in this class. Pick up transformed value for
; desired statistic from appropriate buffer within collection buffer
; block. Do computation on transformed value if required, and place
; whole and fractional portions of result into display buffer (FAOSTK).
;

90$:
	DECL	TM4$L_ECOUNT(R11)	; Set up number of elements to
					; ... display as a loop limit
	MOVL	TM4$A_ITMSTR(R11),R0	; Address of item-number string
	CLRL	R2			; Clear element index register
FDB_BEG:
	BBS	#CDB$V_HOMOG,CDB$L_FLAGS(R6),10$ ; Br if a homogeneous class
	MOVZBL	(R0)+,R4		; Get next item number
	MULL2	#IDB$K_ILENGTH,R4	; Compute index into IDB table
	MOVAB	W^PERFTABLE[R4],R4	; Address of IDB for this item
	MOVW	IDB$W_TYPE(R4),W^ITEM_TYPE ; Save item type for use below
10$:
	CASE	R8,<F_ALL,F_CUR,F_AVE,F_MIN,F_MAX>,L ; Select on requested statistic

F_ALL:
F_CUR:
	BBS	#CDB$V_PERCENT,CDB$W_QFLAGS(R6),10$ ; Br if percent requested
	MOVL	MBP$A_STATS(R10),R3	; Load addr of STATS buffer
	BSBW	INTORFL			; Process an integer or floating value
	BRB	20$			; ... and continue
10$:
	MOVL	MBP$A_PCSTATS(R10),R3	; Load addr of PCSTATS buffer
	MOVL	(R3)[R2],R9		; Load tenths of % value
	BSB	PCTEN			; Process a tenths of % value
20$:
	TSTL	R8			; Was ALL statistic requested?
	BNEQ	COMMON			; No -- join common code
					; Yes -- continue to AVE
F_AVE:
	BBS	#CDB$V_PERCENT,CDB$W_QFLAGS(R6),10$ ; Br if percent requested
	MOVL	MBP$A_SUM(R10),R3	; Load addr of SUM buffer
	BSBW	INTAVE			; Process an integer average value
	BRB	20$			; ... and continue
10$:
	MOVL	MBP$A_PCSUM(R10),R3	; Load addr of PCSUM buffer
	MOVL	MCAPTR,R1		; Get MCA pointer
	SUBL3	#1,MCA$L_COLLCNT(R1),R7 ; Get no of colls, don't count 1st
	DIVL3	R7,(R3)[R2],R9		; Get average tenths % value
	BSB	PCTEN			; ... and process it
20$:
	TSTL	R8			; Was ALL statistic requested?
	BNEQ	COMMON			; No -- join common code
					; Yes -- continue to MIN
F_MIN:
	BBS	#CDB$V_PERCENT,CDB$W_QFLAGS(R6),10$ ; Br if percent requested
	MOVL	MBP$A_MIN(R10),R3	; Load addr of MIN buffer
	BSBW	INTORFL			; Process an integer or floating value
	BRB	20$			; ... and continue
10$:
	MOVL	MBP$A_PCMIN(R10),R3	; Load addr of PCMIN buffer
	MOVL	(R3)[R2],R9		; Load tenths of % value
	BSB	PCTEN			; Process a tenths of % value
20$:
	TSTL	R8			; Was ALL statistic requested?
	BNEQ	COMMON			; No -- join common code
					; Yes -- continue to MAX
F_MAX:
	BBS	#CDB$V_PERCENT,CDB$W_QFLAGS(R6),10$ ; Br if percent requested
	MOVL	MBP$A_MAX(R10),R3	; Load addr of MAX buffer
	BSBW	INTORFL			; Process an integer or floating value
	BRB	COMMON			; ... and continue
10$:
	MOVL	MBP$A_PCMAX(R10),R3	; Load addr of PCMAX buffer
	MOVL	(R3)[R2],R9		; Load tenths of % value
	BSB	PCTEN			; Process a tenths of % value

COMMON:					; Common return point from CASE
	BBC	#IDB$V_PCNT,IDB$B_FLAGS(R4),10$	;branch if it is not a pcnt
	INCL	R0			; increment index into item table
	INCL	R2			; increment index into data buffer
10$:
	ACBL	TM4$L_ECOUNT(R11),#1,R2,FDB_BEG	; Loop once for each element

FDB_RET:
	MOVL	#SS$_NORMAL,R0		; Indicate success
	RET				; ... and return

;
; PCTEN - Transform an integer tenths of percent value to a whole integer
;		percent value and an optional integer tenths "remainder"
;		value. Place result(s) in display buffer (FAOSTK).
;
;		R2 = data item index
;		R3 = address of source statistics buffer
;		R5 = address of current longword in display buffer
;		R7 = scratch
;		R8 = code for requested statistic
;		R9 = tenths of % value (input)
;

PCTEN:
	DIVL3	#10,R9,(R5)+		; Compute whole percent value
	TSTL	R8			; Requested ALL statistics?
	BEQL	10$			; Yes -- continue
	BSBW	CALC_BAR		; No -- go do bar graph calcs
	BRB	20$			; ... and get out
10$:
	MULL3	#10,-4(R5),R7		; Need fraction for tabular display
	SUBL3	R7,R9,(R5)+		; Into display buffer
20$:
	RSB

;
; INTAVE - Transform an integer sum of level values or counts into an
;		average size/collection or rate/second. Place whole
;		and optional fractional parts into display buffer (FAOSTK).
;
;		R1 = scratch
;		R2 = data item index
;		R3 = address of source statistics buffer
;		R4 = address of IDB for current item
;		R5 = address of current longword in display buffer
;		R7 = scratch
;		R8 = code for requested statistic
;		R9 = scratch
;		R11 = address of TM4
;	        TM4$L_FLTSECS = floating seconds from start of monitor request
;				to most recent collection event.
;

INTAVE:
	BBC	#IDB$V_PCNT,IDB$B_FLAGS(R4),7$	;branch if it is not a percent
;
;If it is percent,  compute the average based on the sums of item1 and item2
;
	CLRL	(R5)			;Zero the current longword in Fao buff
	MULL3	4(R3)[R2],#100,R7	;sum for item1*100 into R7
	CVTLF	R7,R7			;convert to float
	MOVL	8(R3)[R2],R9		;sum for (item1+item2) into R9
	TSTL	R9			;item1 + item2 = 0?
	BEQL	5$			;skip divide if so 
	CVTLF	R9,R9			;convert to float
	DIVF	R9,R7			;compute floating avg 
	CVTFL	R7,(R5)			;stack whole part for fao
5$:
	TSTL	(R5)+			;increment display buff pointer
	BRB	25$			;and move on

7$:
	CVTLF	(R3)[R2],R7		; Get floating sum
	CMPW	W^ITEM_TYPE,#COUNT_TYPE	; This item a count?
	BNEQ	10$			; No -- assume level type
	DIVF	TM4$L_FLTSECS(R11),R7	; Yes -- get floating avg rate/second
	BRB	20$			; ... and continue
10$:
	MOVL	MCAPTR,R1		; Get MCA pointer
	SUBL3	#1,MCA$L_COLLCNT(R1),R9 ; Get no of colls, don't count 1st
	CVTLF	R9,R9			; Get floating no of collections
	DIVF	R9,R7			; Compute floating avg size/collection
20$:
	CVTFL	R7,(R5)+		; Stack whole part for fao
25$:
	TSTL	R8			; Requested ALL statistics?
	BEQL	30$			; Yes -- continue
	BSBW	CALC_BAR		; No -- go do bar graph calcs
	BRB	40$			; ... and get out
30$:
	CVTLF	-4(R5),R9		; Get back truncated part
	SUBF	R9,R7			; Compute fraction to two ...
	MULF	#100,R7			; ... digits for tabular display
	CVTFL	R7,(R5)+		; Stack fraction for fao
40$:
	RSB


;
; INTORFL - Place whole and optional fractional parts of integer value
;		(level) or floating rate/second value (count) into
;		display buffer (FAOSTK). 
;
;		R2 = data item index
;		R3 = address of source statistics buffer
;		R4 = address of IDB for current item
;		R5 = address of current longword in display buffer
;		R7 = scratch
;		R8 = code for requested statistic
;		R9 = scratch
;

INTORFL:
	CMPW	W^ITEM_TYPE,#COUNT_TYPE	; Is this item a count?
	BEQL	20$			; Br if yes
	MOVL	(R3)[R2],(R5)+		; Move level value to disp buffer
	TSTL	R8			; ALL statistics requested?
	BEQL	10$			; Yes -- continue
	BSBW	CALC_BAR		; No -- go do bar graph calcs
	BRB	40$			; ... and get out
10$:
	CLRL	(R5)+			; Stack fractional part
	BRB	40$			; ... and exit
20$:
	CVTFL	(R3)[R2],(R5)+		; Stack whole part of rate (for count)
	TSTL	R8			; ALL statistics requested?
	BEQL	30$			; Yes -- continue
	BSBW	CALC_BAR		; No -- go do bar graph calcs
	BRB	40$			; ... and get out
30$:
	CVTLF	-4(R5),R7		; Get back rounded part
	SUBF3	R7,(R3)[R2],R9		; Compute fraction
	MULF	#100,R9			; ... to two digits
	CVTFL	R9,(R5)+		; Stack fractional part
40$:
	RSB				; Return to caller

;
; CALC_BAR - Replace integer longword value in display buffer with three
;		longwords representing the width of a field to display
;		the value (0 or 7), the value, and the number of bar
;		characters needed to represent the value in a bar graph.
;
;	     Note -- if SYSTEM class, merely annex bar count to count
;		     already in display buffer.
;
;	Register Inputs:
;
;		R1 = scratch
;		R5 = address of current longword in display buffer;
;		     will be updated to next available longword on output
;		R6 = addr of CDB
;		R7 = scratch
;		R9 = scratch
;
;	Implicit Inputs:
;
;		GMIN - Integer longword, min value for graph
;		BPU  - Floating longword, bar chars per unit of value
;


;
; This subroutine creates 3 longwords in the FAOSTK array for the current
; data item. The current item is represented by a longword integer value
; which will be displayed to the left of the bar in the bar graph for
; the current class. The current item has already been placed in the
; display buffer by the calling routine; R5 has already been advanced to
; the next available longword. This subroutine must replace the value
; longword in the display buffer (FAOSTK) with 3 longwords, leaving R5
; pointing to the next available longword. The three longwords are:
; width of value field (0 or 7), value, and number of bar characters
; needed to represent the value. The number of bargraph characters is
; computed in floating point and then truncated.                       
;                                                                               

CALC_BAR:
	BBS	#CDB$V_SYSCLS,CDB$L_FLAGS(R6),30$ ; Br if SYSTEM class
	CLRL	R7			; Assume value field width will be 0
	MOVL	-4(R5),(R5)		; Move value ahead in display buffer
	BEQL	10$			; If value zero, go move 0 field width 
	MOVZBL	#7,R7			; Value is non-zero; field width is 7
10$:                                                                            
	MOVL	R7,-4(R5)		; Move value field width into display buffer
;
; Now calculate number of bars to output
;
	CLRL	R7			; Assume no bars will be output
	SUBL3	GMIN,(R5)+,R9		; Calc units of value to output and ...
					; ... advance R5 to "no of bars" longword
	BLEQ	20$			; Output no bars if leq zero
	CVTLF	R9,R9			; Convert units to floating
	MULF2	BPU,R9			; Bars/unit * units => bars to output
	CVTFL	R9,R7			; Integer number to output
	CMPL	#MAXBARS,R7		; Check for upperbound
	BGEQ	20$			; Continue if within range
	MOVL	#MAXBARS,R7		; Else make it within range
20$:
	MOVL	R7,(R5)+		; Move number of bars to display buffer ...
					; ... and advance R5 to next longword
	BRB	50$			; Go return to caller

;
; Special processing for SYSTEM class
;

30$:
	MOVAL	FMT_SYS_SINGLE,R1	; Get vector of format codes
	CMPB	(R1)[R2],#NUMB_ONLY	; Number only desired?
	BEQL	50$			; Br if yes -- all done

;
; NUMB_BAR type ... number and bar desired. Number is already in stack.
; Now calculate number of bars to output.
;

	CLRL	R7			; Assume no bars will be output
	TSTL	-4(R5)			; Zero units of value to output?

	BLEQ	40$			; Output no bars if leq zero

	MOVAL	BU_SYS_SINGLE,R1	; Get addr of vector of bar ranges
	CVTLF	(R1)[R2],R9		; Get floating range for graph
	CVTBF	#MAXBARS_SYS,R1		; Get max bar chars per line
	DIVF2	R9,R1			; Calculate bar chars per unit of output

	CVTLF	-4(R5),R9		; Get floating units of value to output

	MULF2	R1,R9			; Bars/unit * units => bars to output
	CVTFL	R9,R7			; Integer number to output
	CMPL	#MAXBARS_SYS,R7		; Check for upperbound
	BGEQ	40$			; Continue if within range
	MOVL	#MAXBARS_SYS,R7		; Else make it within range
40$:
	MOVL	R7,(R5)+		; Move number of bars to display buffer ...
					; ... and advance R5 to next longword
50$:
	RSB				; Return to caller

;
; FDB_SYS_SINGLE
;
; Fill a dummy statistics buffer from similar buffers of the MODES
; STATES and SYSTEM classes. Then call INTORFL and INTAVE routines
; to transform the data in the buffer to items on the FAOSTK.
;
; This routine is entered with a direct branch, and branches to
; FDB_RET when done to return to original caller.
;
; Inputs:
;
;	R0 - R2 scratch
;	R3 - address of statistics buffer.
;	R4 - R5 scratch
;	R6  - address of SYSTEM CDB.
;	R7 - R10 scratch
;	R11 - address of TM4, a temporary stack area
;

FDB_SYS_SINGLE:

	MOVL	#<CDB$K_SIZE*MODES_CLSNO>,R0 ; Compute offset to MODES CDB
	MOVAB	CDBHEAD[R0],R0		; ... get its CDB address
	MOVL	CDB$A_BUFFERS(R0),R2	; ... and MBP ptr for later use

	MOVL	#<CDB$K_SIZE*STATES_CLSNO>,R0 ; Compute offset to STATES CDB
	MOVAB	CDBHEAD[R0],R0		; ... get its CDB address
	MOVL	CDB$A_BUFFERS(R0),R4	; ... and MBP ptr for later use

	MOVL	CDB$A_BUFFERS(R6),R5	; Get same for SYSTEM class

	MOVZBL	CDB$B_ST(R6),R8		; Get requested stat code
	CASE	R8,<FS_ALL,FS_CUR,FS_AVE,FS_MIN,FS_MAX>,L
					; Select on requested stat

FS_ALL:					; Should not occur
FS_CUR:
	MOVL	MBP$A_STATS(R2),R2	; Load addr of STATS buffer for MODES
	MOVL	MBP$A_STATS(R4),R4	; Load addr of STATS buffer for STATES
	MOVL	MBP$A_STATS(R5),R5	; Load addr of STATS buffer for SYSTEM
	BRB	FS_COMMON		; Join common code

FS_AVE:
	MOVL	MBP$A_SUM(R2),R2	; Load addr of SUM buffer for MODES
	MOVL	MBP$A_SUM(R4),R4	; Load addr of SUM buffer for STATES
	MOVL	MBP$A_SUM(R5),R5	; Load addr of SUM buffer for SYSTEM
	BRB	FS_COMMON		; Join common code

FS_MIN:
	MOVL	MBP$A_MIN(R2),R2	; Load addr of MIN buffer for MODES
	MOVL	MBP$A_MIN(R4),R4	; Load addr of MIN buffer for STATES
	MOVL	MBP$A_MIN(R5),R5	; Load addr of MIN buffer for SYSTEM
	BRB	FS_COMMON		; Join common code

FS_MAX:
	MOVL	MBP$A_MAX(R2),R2	; Load addr of MAX buffer for MODES
	MOVL	MBP$A_MAX(R4),R4	; Load addr of MAX buffer for STATES
	MOVL	MBP$A_MAX(R5),R5	; Load addr of MAX buffer for SYSTEM
	BRB	FS_COMMON		; Join common code

FS_COMMON:

;
; Move items of interest from the source buffers to a single
; destination buffer.
;
; *** NOTE ***  This section contains hard-wired offsets. It
;		assumes that the positions of items in the
;		MODES and STATES class do not change.
;		Not currently using the MODES class for the
;		single display, however.
;

;
; *** NOTE ***	R2 has the address of the MODES buffer, but it is
;		not being used currently.
;


	MOVL	R3,R7			; Set up variable ptr to dummy buffer

	MOVL	(R5)+,(R7)+		; Get "CPU busy" from SYSTEM
	MOVQ	16(R4),(R7)+		; Get 8 items from STATES
	MOVQ	24(R4),(R7)+
	MOVQ	44(R4),(R7)+
	MOVL	12(R4),(R7)+
	MOVL	4(R4),(R7)+

	MOVL	#<ECOUNT_SYS_SINGLE-9>,R0 ; No. of items to get from SYSTEM
10$:
	MOVL	(R5)+,(R7)+		; Move a SYSTEM item into dummy buffer
	SOBGTR	R0,10$			; Loop to get all of them



;
; At this point, 
;
;	R3 - points to the newly formed dummy statistics
;	R6 - CDB ptr
;	R8 - statistic code
;	R11 - TM4 ptr
;

	MOVAL	FAOSTK,R5		; Load address of display buffer

;
; Loop once for each element in this class. Pick up transformed value for
; desired statistic from appropriate buffer within collection buffer
; block. Do computation on transformed value if required, and place
; whole and fractional portions of result into display buffer (FAOSTK).
;

	MOVL	#<ECOUNT_SYS_SINGLE-1>, - ; Set up number of elements to
		TM4$L_ECOUNT(R11)	  ; ... display as a loop limit

	MOVAL	ITMSTR_SYS_SINGLE,R0	; Address of item-number string

	CLRL	R2			; Clear element index register
FSS_BEG:
	MOVZBL	(R0)+,R4		; Get next item number
	MULL2	#IDB$K_ILENGTH,R4	; Compute index into IDB table
	MOVAB	W^PERFTABLE[R4],R4	; Address of IDB for this item
	MOVW	IDB$W_TYPE(R4),W^ITEM_TYPE ; Save item type for use below

	CMPL	R8,#AVE_STAT		; AVERAGE statistic requested ?
	BEQL	10$			; Br if yes
	BSBW	INTORFL			; Process an integer or floating value
	BRB	20$			; ... and go loop for next element
10$:
	BSBW	INTAVE			; Process an integer average value
20$:
	ACBL	TM4$L_ECOUNT(R11),#1,R2,FSS_BEG	; Loop once for each element

	PUSHL	R6			; Pass CDB address
	PUSHL	R5			; Pass current FAOSTK address
	CALLS	#2,FDB_SYS_TOP		; Compute and stack the four tops

	BRW	FDB_RET			; Go return


	.SBTTL	FDB_SYS_TOP - Process TOPs for SYSTEM class

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	TBS
;
; INPUTS:
;
;
; OUTPUTS:
;
;
; IMPLICIT OUTPUTS:
;
;
; ROUTINE VALUE:
;
;	R0 = SS$_NORMAL
;
; SIDE EFFECTS:
;
;	none
;
;--

.ENTRY	FDB_SYS_TOP, ^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>


	MOVL	#<PROCS_CLSNO*CDB$K_SIZE>,R7 ; Compute offset to PROCESSES CDB
	MOVAB	CDBHEAD[R7],R0		; Index to CDB address
					; NOTE -- TOP_DIFFS needs R0 set up this way
	MOVL	CDB$A_BUFFERS(R0),R7	; Load buffer block ptr
	MOVL	MBP$A_BUFFERA(R7),R7	; Load collection buffer ptr

;
; If not first TOP display event, calculate S_TOP_TICKS (the
; number of clock ticks (10ms units) since previous entry
; to FDB_SYS_TOP.
;

	MOVL	MCAPTR,R2		; Get MCA pointer
	BBC	#MCA$V_S_TOP_DISP,MCA$W_FLAGS(R2),5$
					; Skip TOP_TICKS calc if 1st time thru
	MOVQ	MNR_CLS$Q_STAMP(R7),R2	; Current system time to temp regs
	SUBL2	W^S_TOP_TIME,R2		; Calc low-order in sys units
	SBWC	W^S_TOP_TIME+4,R3	; Calc high-order in sys units
	EDIV	#100000,R2,W^S_TOP_TICKS,R2 ; Calc interval ticks (10ms units)
					  ; ... for use below
5$:
	MOVQ	MNR_CLS$Q_STAMP(R7),W^S_TOP_TIME ; Save curr time for next disp event

;
; Set up registers to call TOP_DIFFS routine to get the DIFF array
; filled in, which contains the incremental differences in the
; requested resource since previous display event. R0 and R7
; already set up.
;

	MOVAL	SYS_TOP_VEC,R4		; Get ptr to vector of top buffers
	MOVL	(R4)+,R2		; Get DATA array ptr
	MOVL	(R4)+,R3		; Get DIFF array ptr
	MOVL	(R4)+,R5		; Get PID array ptr
	MOVL	(R4)+,R6		; Get ADDR array ptr
	MOVL	#MNR_PRO$L_CPUTIM,R11	; Get CPUTIM offset
	PUSHR	#^M<R0,R7>		; Save since changed by TOP_DIFFS
	BSBW	TOP_DIFFS		; Calc diffs over the last interval
	POPR	#^M<R0,R7>		; Restore

	MOVL	(R4)+,R2		; Get DATA array ptr
	MOVL	(R4)+,R3		; Get DIFF array ptr
	MOVL	(R4)+,R5		; Get PID array ptr
	MOVL	(R4)+,R6		; Get ADDR array ptr
	MOVL	#MNR_PRO$L_PAGEFLTS,R11	; Get PAGEFLTS offset
	PUSHR	#^M<R0,R7>		; Save since changed by TOP_DIFFS
	BSBW	TOP_DIFFS		; Calc diffs over the last interval
	POPR	#^M<R0,R7>		; Restore

	MOVL	(R4)+,R2		; Get DATA array ptr
	MOVL	(R4)+,R3		; Get DIFF array ptr
	MOVL	(R4)+,R5		; Get PID array ptr
	MOVL	(R4)+,R6		; Get ADDR array ptr
	MOVL	#MNR_PRO$L_DIOCNT,R11	; Get DIOCNT offset
	PUSHR	#^M<R0,R7>		; Save since changed by TOP_DIFFS
	BSBW	TOP_DIFFS		; Calc diffs over the last interval
	POPR	#^M<R0,R7>		; Restore

	MOVL	(R4)+,R2		; Get DATA array ptr
	MOVL	(R4)+,R3		; Get DIFF array ptr
	MOVL	(R4)+,R5		; Get PID array ptr
	MOVL	(R4)+,R6		; Get ADDR array ptr
	MOVL	#MNR_PRO$L_BIOCNT,R11	; Get BIOCNT offset
	PUSHR	#^M<R0,R7>		; Save since changed by TOP_DIFFS
	BSBW	TOP_DIFFS		; Calc diffs over the last interval
	POPR	#^M<R0,R7>		; Restore
;
; Now all DIFF arrays are established. Loop through each one to find
; the top user. Note: TOP_DIFFS places MAXPROCESSCNT in R11.
;


	MOVL	4(AP),R5		; Get current position in FAOSTK
	MOVL	8(AP),R6		; Get CDB address for later use
	MOVAL	SYS_TOP_VEC,R4		; Get addr of TOP arrays
	MOVL	MCAPTR,R1		; Get pointer to MCA
	BBSS	#MCA$V_S_TOP_DISP,MCA$W_FLAGS(R1),10$ ; Br if not first disp
						      ; ... and always set bit
	BSBB	CLEAR_STACK		; If first display event, simply
	BSBB	CLEAR_STACK		; ... stack zeroes
	BSBB	CLEAR_STACK		; ...
	BSBB	CLEAR_STACK		; ...

	BRB	20$			; ... and go return
10$:
	MOVL	4(R4),R1		; Get addr of CPUTIM DIFF array
	MOVL	12(R4),R3		; ... and ADDR array
	CLRL	R2			; ... and set up index for CALC_BAR
	BSBW	STACK_TOP		; Find the top and stack its info
	MOVL	20(R4),R1		; Get addr of PAGEFLTS DIFF array
	MOVL	28(R4),R3		; ... and ADDR array
	MOVL	#11,R2			; ... and set up index for CALC_BAR
	BSBW	STACK_TOP		; Find the top and stack its info
	MOVL	36(R4),R1		; Get addr of DIRIO DIFF array
	MOVL	44(R4),R3		; ... and ADDR array
	MOVL	#15,R2			; ... and set up index for CALC_BAR
	BSBW	STACK_TOP		; Find the top and stack its info
	MOVL	52(R4),R1		; Get addr of BUFIO DIFF array
	MOVL	60(R4),R3		; ... and ADDR array
	MOVL	#16,R2			; ... and set up index for CALC_BAR
	BSBW	STACK_TOP		; Find the top and stack its info
20$:
	RET				; Return

CLEAR_STACK:
	CLRQ	(R5)+			; Stack null process name
	CLRQ	(R5)+			; ....
	MOVZBL	-16(R5),(R5)+		; Length of process name to FAO stack
	SUBL3	#19,R5,(R5)+		; Address of process name to FAO stack
	CLRQ	(R5)+			; Stack dummy value and bar value
	RSB

FIND_TOP:
	CLRL	R0			; Init index
	MOVL	(R1)[R0],R10		; Get first value
	CLRL	R8			; ... and first index
10$:
	CMPL	R10,(R1)[R0]		; This item greater than current best?
	BGEQ	20$			; Br if no
	MOVL	(R1)[R0],R10		; Found a new best
	MOVL	R0,R8			; Save its index
20$:
	AOBLSS	R11,R0,10$		; Loop MAXPROCESSCNT times
	RSB				; Return

STACK_TOP:

	BSBB	FIND_TOP		; Find the top process

;
; At this point, R10 has the top value, and R8 has its index value.
;

	MOVL	8(R4),R0		; Get addr of CPUTIM PID array
	MOVL	(R0)[R8],R0		; Get PID for top process
	TSTW	R0			; Is it the NULL process?
	BNEQ	10$			; Br if no
	CLRL	(R1)[R8]		; NULL process -- zero its DIFF val
	BSBB	FIND_TOP		; ... and go find another top
10$:
	TSTL	R10			; Top value zero ?
	BNEQ	30$			; Br if no
	BSBB	CLEAR_STACK		; Yes, simply stack zeroes
	BRB	40$			; ... and go exit
30$:
	MOVL	(R3)[R8],R8		; Get addr of process data block
	MOVQ	MNR_PRO$O_LNAME(R8),(R5)+ ; Process name cstring to FAO stack
	MOVQ	MNR_PRO$O_LNAME+8(R8),(R5)+ ; .....
	MOVZBL	-16(R5),(R5)+		; Length of process name to FAO stack
	SUBL3	#19,R5,(R5)+		; Address of process name to FAO stack

;
; Transform the DIFF value (in R10) from a delta to a
; rate/second. Then place it into the FAOSTK and ship
; it off to the CALC_BAR subroutine to insert the
; bar character count into FAOSTK.
; 

	CVTLF	R10,R10			; Get floating value over interval
	CVTLF	W^S_TOP_TICKS,R0	; Get floating ticks over interval
	DIVF2	#100,R0			; Get floating seconds over interval
	DIVF2	R0,R10			; Get floating rate per second
	CVTFL	R10,(R5)+		; Move longword rate/sec to FAO stack
	BSBW	CALC_BAR		; Calculate and stack bar chars required
					; CALC_BAR destroys regs R7 and R9, and
					; ... updates R5 to point to the next
					; ... available longword in the FAO stack
40$:
	RSB				; Return


;
; FDB_SYS_ALL
;
; Fill a dummy MBP and 4 dummy statistics buffers (STATS, MIN, MAX, and SUM).
; The dummy statistics buffers will form a hybrid between the MODES class
; and the SYSTEM class.
;
; Inputs:
;
;	R0 - R5 scratch
;	R6  - address of SYSTEM CDB.
;	R10 - address of dummy MBP followed by the 4 statistics buffers.
;	R11 - address of TM4, a temporary stack area
;
; Implicit Outputs:
;
;	The dummy MBP and buffers are filled.
;	TM4$L_ECOUNT contains number of elements to display.
;	TM4$A_ITMSTR points to the display item string.
;

FDB_SYS_ALL:

	MOVL	#<CDB$K_SIZE*MODES_CLSNO>,R0 ; Compute offset to MODES CDB
	MOVAB	CDBHEAD[R0],R0		; ... get its CDB address
	MOVL	CDB$A_BUFFERS(R0),R1	; ... and MBP ptr for later use
	MOVL	CDB$A_BUFFERS(R6),R2	; Get same for SYSTEM class

	ADDL3	#MBP$K_SIZE,R10,R3	; Compute address of dummy STATS buffer

;
; Fill STATS buffer with ECOUNT_SYS_ALL longwords
; starting at address in R3.
;

	MOVL	R3,MBP$A_STATS(R10)	; Load addr of dummy STATS buffer
	MOVL	MBP$A_STATS(R1),R4	; Get MODES STATS buffer ptr
	MOVL	#7,R5			; ... and no. of items to pick up
	BSBB	MOVE_ITEMS		; Move the items into the dummy buffer

	ADDL3	#8,MBP$A_STATS(R2),R4	; Get SYSTEM STATS buff ptr (skips 2 items)
	MOVL	#<ECOUNT_SYS_ALL-7>,R5	; ... and no. of items to pick up
	BSBB	MOVE_ITEMS		; Move the items into the dummy buffer

;
; Fill MIN buffer with ECOUNT_SYS_ALL longwords
; starting at address in R3.
;

	MOVL	R3,MBP$A_MIN(R10)	; Load addr of dummy MIN buffer
	MOVL	MBP$A_MIN(R1),R4	; Get MODES MIN buffer ptr
	MOVL	#7,R5			; ... and no. of items to pick up
	BSBB	MOVE_ITEMS		; Move the items into the dummy buffer

	ADDL3	#8,MBP$A_MIN(R2),R4	; Get SYSTEM MIN buff ptr (skips 2 itemS)
	MOVL	#<ECOUNT_SYS_ALL-7>,R5	; ... and no. of items to pick up
	BSBB	MOVE_ITEMS		; Move the items into the dummy buffer

;
; Fill MAX buffer with ECOUNT_SYS_ALL longwords
; starting at address in R3.
;

	MOVL	R3,MBP$A_MAX(R10)	; Load addr of dummy MAX buffer
	MOVL	MBP$A_MAX(R1),R4	; Get MODES MAX buffer ptr
	MOVL	#7,R5			; ... and no. of items to pick up
	BSBB	MOVE_ITEMS		; Move the items into the dummy buffer

	ADDL3	#8,MBP$A_MAX(R2),R4	; Get SYSTEM MAX buff ptr (skips 2 itemS)
	MOVL	#<ECOUNT_SYS_ALL-7>,R5	; ... and no. of items to pick up
	BSBB	MOVE_ITEMS		; Move the items into the dummy buffer

;
; Fill SUM buffer with ECOUNT_SYS_ALL longwords
; starting at address in R3.
;

	MOVL	R3,MBP$A_SUM(R10)	; Load addr of dummy SUM buffer
	MOVL	MBP$A_SUM(R1),R4	; Get MODES SUM buffer ptr
	MOVL	#7,R5			; ... and no. of items to pick up
	BSBB	MOVE_ITEMS		; Move the items into the dummy buffer

	ADDL3	#8,MBP$A_SUM(R2),R4	; Get SYSTEM SUM buff ptr (skips 2 itemS)
	MOVL	#<ECOUNT_SYS_ALL-7>,R5	; ... and no. of items to pick up
	BSBB	MOVE_ITEMS		; Move the items into the dummy buffer


	MOVL	#ECOUNT_SYS_ALL, -	; Load number of elements to display
		TM4$L_ECOUNT(R11)
	MOVAL	ITMSTR_SYS_ALL, -
		TM4$A_ITMSTR(R11)	; ... and addr of display item string

	RSB				; Return to caller


;
; MOVE_ITEMS moves a consecutive number of longwords (number in R5)
; from location R4 to location R3. R4 and R3 are auto-incremented.
;

MOVE_ITEMS:
10$:
	MOVL	(R4)+,(R3)+		; Move an item into dummy buffer
	SOBGTR	R5,10$			; Loop to get all of them
	RSB


	.SBTTL	FILL_TOP - Fill Display Buffer for TOP PROCESSES

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	Calculates the TOP 8 PROCESSES since the last display
;	event, and fills the display buffer (FAOSTK) with data
;	for later display.
;
; INPUTS:
;
;	 4(AP) - CDB (Class Descriptor Block) pointer
;		 for the PROCESSES class.
;
; IMPLICIT INPUTS:
;
;	FAOSTK - FAO parameter list for a TOP screen
;	MCAPTR - Pointer to MCA (Monitor Communication Area)
;
; OUTPUTS:
;
;	None
;
; IMPLICIT OUTPUTS:
;
;	Entire display buffer (FAOSTK) filled with data for
;	eventual display.
;
;	TOP_PROCS byte filled with number of TOP processes
;	(with non-zero values) to display.
;
; ROUTINE VALUE:
;
;	R0 = SS$_NORMAL
;
; SIDE EFFECTS:
;
;	none
;
; REGISTER USAGE:
;
;	R0  = Scratch
;	R1  = Scratch, addr of MBP
;	R2  = Addr of DATA array
;	R3  = Addr of DIFF array
;	R4  = Addr of ORDER array
;	R5  = Addr of PID array
;	R6  = Addr of ADDR array
;	R7  = Pointer to collection buffer data block
;	R8  = Process index (PIX) for current data block
;	R9  = Current process index (from 0 to MNR_SYI$W_MAXPRCCT)
;	R10 = Number of data blocks (processes) in coll buff
;	R11 = Pointer to monitored data item in coll buff data block;
;	      Also, Max process count (from MNR_SYI$W_MAXPRCCT)
;--

.ENTRY	FILL_TOP, ^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>

	MOVL	4(AP),R1		; Load CDB pointer
	MOVZBL	CDB$B_ST(R1),R11	; Get PROCESSES display type code
	CASE	R11,<REG,TOPC,TOPD,TOPB,TOPF>,W ; Go set offset based on type
	BRB	TOPC			; If out of range, do a TOPCPU

REG:					; Regular PROCESSES display (should not get)
TOPC:					; TOPCPU display
	MOVL	#MNR_PRO$L_CPUTIM,R11	; Get offset into PROCESSES data block
	BRB	FT_CASE			; Join common code
TOPD:					; TOPDIO display
	MOVL	#MNR_PRO$L_DIOCNT,R11	; Get offset into PROCESSES data block
	BRB	FT_CASE			; Join common code
TOPB:					; TOPBIO display
	MOVL	#MNR_PRO$L_BIOCNT,R11	; Get offset into PROCESSES data block
	BRB	FT_CASE			; Join common code
TOPF:					; TOPFAULT display
	MOVL	#MNR_PRO$L_PAGEFLTS,R11	; Get offset into PROCESSES data block

FT_CASE:				; Common CASE return

	MOVL	CDB$A_BUFFERS(R1),R1	; Load buffer block ptr
	MOVL	MBP$A_BUFFERA(R1),R7	; Load collection buffer ptr

;
; If not first TOP display event, calculate TOP_TICKS (the
; number of clock ticks (10ms units) since previous entry
; to FILL_TOP.
;

	MOVL	MCAPTR,R2		; Get MCA pointer
	BBC	#MCA$V_TOP_DISP,MCA$W_FLAGS(R2),5$
					; Skip TOP_TICKS calc if 1st time thru
	MOVQ	MNR_CLS$Q_STAMP(R7),R2	; Current system time to temp regs
	SUBL2	W^TOP_TIME,R2		; Calc low-order in sys units
	SBWC	W^TOP_TIME+4,R3		; Calc high-order in sys units
	EDIV	#100000,R2,W^TOP_TICKS,R2 ; Calc interval ticks (10ms units)
					  ; ... for use in MOVE_TOP8 rtn below
5$:
	MOVQ	MNR_CLS$Q_STAMP(R7),W^TOP_TIME ; Save curr time for next disp event

;
; Set up array pointers in preparation for calculations of difference
; values for each process for the monitored item over the last interval.
;

	MOVL	MBP$A_DATA(R1),R2	; Load DATA array ptr
	MOVL	MBP$A_DIFF(R1),R3	; Load DIFF array ptr
	MOVL	MBP$A_ORDER(R1),R4	; Load ORDER array ptr
	MOVL	MBP$A_PID(R1),R5	; Load PID array ptr
	MOVL	MBP$A_ADDR(R1),R6	; Load ADDR array ptr
	MOVL	4(AP),R0		; Load CDB pointer

	BSBW	TOP_DIFFS		; Calculate the diffs over last int

	MOVL	MCAPTR,R1		; Get pointer to MCA
	BBCS	#MCA$V_TOP_DISP,MCA$W_FLAGS(R1),80$
					; If first top display event, don't
					; ... sort or move (and set bit for future)
	PUSHR	#^M<R11>		; Save max process count

	BSBB	SORT_PROCS		; Sort the top 8 processes

	POPR	#^M<R11>		; Restore max process count

	BSBB	MOVE_TOP8		; Insert data for TOP 8 into FAOSTK

	BRB	90$			; Go return
80$:
	CLRB	W^TOP_PROCS		; No procs to display on 1st time
90$:
	MOVL	NORMAL,R0		; Indicate normal status
	RET				; Return

;
; SORT_PROCS
;
; Set up the ORDER array to contain the processes indices.
;
; R11 contains max process count.
;
; This subroutine destroys registers R0,R1,R7,R8,R9,R10,R11.
;

SORT_PROCS:

	CLRL	R1			; Zero first process index
10$:	MOVL	R1,(R4)[R1]		; Load index into corresponding ORDER elem
	AOBLSS	R11,R1,10$		; Do all elements of ORDER array

;
; Go through the DIFF array and re-position elements in the
; ORDER array using a bubble sort. When the following two-level
; loop is complete, the highest-numbered 8 elements of the ORDER
; array will contain the process index numbers of the TOP 8
; consumers of the monitored resource.
;

	DECL	R11			; Get highest process index (PIX)
	SUBL3	#7,R11,R10		; Get 8th from the highest PIX
20$:
	MOVL	#1,R9			; Init loop index of inner loop
30$:
	SUBL3	#1,R9,R1		; R1 is always one less than R9
	MOVL	(R4)[R9],R7		; Get PIX from current ORDER element
	MOVL	(R4)[R1],R8		; Get PIX from previous ORDER element
	CMPL	(R3)[R7],(R3)[R8]	; Compare curr DIFF val with previous
	BGEQ	40$			; Curr is not less -- no switching
	MOVL	R8,(R4)[R9]		; Curr is less -- switch PIX in current
	MOVL	R7,(R4)[R1]		; ... ORDER elt with that in prev ORDER elt
40$:
	AOBLEQ	R11,R9,30$		; Loop through all elements of ORDER
					; ... array except the ones on the high
					; ... end which already have TOP values

	ACBL	R10,#-1,R11,20$		; Loop 8 times to "bubble down" PIX's
					; ... for the 8 largest consumers

	RSB				; Return


;
; MOVE_TOP8
;
; Move data for the top 8 (or fewer) processes
; into FAOSTK for later display.
;
; R11 contains max process count.
;
; This subroutine destroys registers R0,R1,R5,R7,R8,R9,R10,R11.
;

MOVE_TOP8:

	MOVAL	W^FAOSTK,R5		; Get pointer to display buffer
	MOVL	#1,R1			; Init count of procs that have
					; ... DIFF value > 0
10$:					; Beginning of TOP 8 loop
	DECL	R11			; Point to next lower ORDER element
	MOVL	(R4)[R11],R8		; Get PIX from ORDER array
	MOVL	(R3)[R8],R10		; Get DIFF value for this TOP process
	BEQL	40$			; Get out of loop if zero
	MOVL	(R6)[R8],R8		; Get ptr to process data block
					; ... from ADDR array
;
; NOTE -- at this point, R8 points to process data block
; ... and R10 has DIFF value.
;

;
; Move individual items for this process from current data block
; in collection buffer to longwords in FAO stack.
;

	MOVL	4(AP),R0		; Get PROCESSES CDB address

	CMPW	#MNR_PRO$L_EPID,CDB$W_BLKLEN(R0) ; See if we have an EPID
	BLSS	20$			; Br if we do
	MOVL	MNR_PRO$L_IPID(R8),(R5)+ ; Get the Internal PID
	BRB	30$			; Go get process name
20$:
	MOVL	MNR_PRO$L_EPID(R8),(R5)+ ; Get the Extended PID
30$:
	MOVQ	MNR_PRO$O_LNAME(R8),(R5)+ ; Process name cstring to FAO stack
	MOVQ	MNR_PRO$O_LNAME+8(R8),(R5)+ ; .....
	MOVZBL	-16(R5),(R5)+		; Length of process name to FAO stack
	SUBL3	#19,R5,(R5)+		; Address of process name to FAO stack

;
; Transform the DIFF value (in R10) from a delta to a
; rate/second. Then place it into the FAOSTK and ship
; it off to the CALC_BAR subroutine to insert the
; bar character count into FAOSTK.
; 

	CVTLF	R10,R10			; Get floating value over interval
	CVTLF	W^TOP_TICKS,R0		; Get floating ticks over interval
	DIVF2	#100,R0			; Get floating seconds over interval
	DIVF2	R0,R10			; Get floating rate per second
	CVTFL	R10,(R5)+		; Move longword rate/sec to FAO stack
	PUSHR	#^M<R6>			; Save ADDR array pointer
	MOVL	4(AP),R6		; ... and set up CDB ptr for CALC_BAR
	BSBW	CALC_BAR		; Calculate and stack bar chars required
					; CALC_BAR destroys regs R7 and R9, and
					; ... updates R5 to point to the next
					; ... available longword in the FAO stack
	POPR	#^M<R6>			; Restore ADDR array pointer

	AOBLEQ	#8,R1,10$		; Get info from TOP 8 processes
40$:
	SUBB3	#1,R1,W^TOP_PROCS	; Adjust count of processes for
					; ... DISPLAY_TOP routine

	RSB				; Return


TOP_DIFFS:

;
; Fill the DIFF array and ADDR array for the current collection buffer.
;
;
; REGISTER INPUTS:
;
;	R0  = PROCESSES CDB ptr
;	R1  = scratch
;	R2  = DATA array ptr
;	R3  = DIFF array ptr
;	R5  = PID array ptr
;	R6  = ADDR array ptr
;	R7  = pointer to PROCESSES collection buffer
;	R8-10 = scratch
;	R11 = offset into PROCESSES data block for requested resource
;

	ADDL2	#MNR_CLS$K_HSIZE,R7	; Point to PROCESSES class prefix
	MOVL	MNR_PRO$L_PCTINT(R7),R10 ; Get no. of procs in this coll buffer
	ADDL2	#MNR_PRO$K_PSIZE,R7	; Point to first data block
	ADDL2	R7,R11			; ... and to first monitored data item

	MOVL	#-1,R9			; Init process index

10$:
	MOVZWL	MNR_PRO$L_IPID(R7),R8	; Get process index from next process
					; ... in collection buffer
20$:
	INCL	R9			; Get next process index
	CMPL	R9,R8			; Any process slots not in coll buff?
	BGEQ	30$			; No -- go process this one
	CLRL	(R3)[R9]		; Yes -- clear DIFF array for this index
	BRB	20$			; Loop back to check next index
30$:
	CMPL	(R5)[R8],MNR_PRO$L_IPID(R7) ; Same process as last time?
	BNEQU	40$			; No -- go zero out DIFF
	TSTL	(R11)			; Zero data item => swapped out
	BEQL	40$			; Swapped out -- go zero out DIFF
	TSTL	(R2)[R8]		; Swapped out last time?
	BEQL	40$			; Yes -- go zero out DIFF
	SUBL3	(R2)[R8],(R11),(R3)[R8]	; Calculate DIFF
	MOVL	R7,(R6)[R8]		; Store proc data block ptr in ADDR array
	BRB	50$			; ... and continue
40$:
	CLRL	(R3)[R8]		; Clear DIFF, indicating not a TOP candidate
	MOVL	MNR_PRO$L_IPID(R7),(R5)[R8] ; Store PID
50$:
	MOVL	(R11),(R2)[R8]		; Store data item into DATA array
	MOVZWL	CDB$W_BLKLEN(R0),R1	; Get size of a data block
	ADDL2	R1,R7			; Point to next process in coll buffer
	ADDL2	R1,R11			; ... and to next data item
	SOBGTR	R10,10$			; Loop once for each proc in coll buffer

;
; A DIFF entry has been made for every index up through
; the last process in the collection buffer.
; The following loop clears the DIFF entry for each
; index between the last one already done and the
; last one in the DIFF array.
;

	INCL	R8			; Get next process index
	MOVL	SPTR,R11		; Get ptr to System Info Area
	MOVZWL	MNR_SYI$W_MAXPRCCT(R11),R11 ; Get max process count
	CMPL	R8,R11			; Any more process slots?
	BGEQ	70$			; No -- skip clear loop
60$:
	CLRL	(R3)[R8]		; Clear DIFF, indicating not a TOP candidate

	AOBLSS	R11,R8,60$		; Continue to end of DIFF array
70$:

	RSB				; Return to caller

	.SBTTL	SUMMARY_TOP - Set up Summary for TOP

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called to do setup for Summary processing of
;	the SYSTEM or PROCESSES class with the TOP display format. It is not
;	called when summarizing with the regular PROCESSES display format
;	or the tabular SYSTEM display format.
;
;	The basic job of this routine is to call FDB_SYS_TOP or FILL_DISP_BUFF
;	with the first PROCESSES collection buffer of the MONITOR request.
;	This is accomplished by loading the pointer to the current collection
;	buffer with the first collection buffer pointer, and then doing
;	a normal FDB_SYS_TOP or FILL_DISP_BUFF call. The current collection
;	buffer pointer is then restored to its original value before returning
;	to caller.
;
; CALLING SEQUENCE:
;
;	CALLS #1,SUMMARY_TOP
;
; INPUTS:
;
;	 4(AP) - address of a pointer to the CDB (Class Descriptor Block)
;		 for either the SYSTEM or the PROCESSES class.
;
; IMPLICIT INPUTS:
;
;	MCAPTR - pointer to MCA (Monitor Communication Area)
;
;	MRBPTR - pointer to MRB (Monitor Request Block)
;
;	SPTR - pointer to SYI (System Information Area)
;
;	PROCS_CLSNO - class number for the PROCESSES class
;
;	SYS_TOP_VEC - vector of pointers to SYSTEM class TOP arrays
;
; OUTPUTS:
;
;	None.
;
; IMPLICIT OUTPUTS:
;
;	The 5 TOP arrays (DATA, DIFF, ORDER, PID, ADDR)
;	are filled with information from the first collection
;	buffer.
;
; ROUTINE VALUE:
;
;	R0 = SS$_NORMAL
;
; SIDE EFFECTS:
;
;	None
;
;--

.ENTRY	SUMMARY_TOP,	^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>

	MOVL	MCAPTR,R1		; Load MCA pointer
	BBCC	#MCA$V_TOP_DISP,MCA$W_FLAGS(R1),10$ ; Indicate no TOP displays
10$:						    ; ... done yet for PROCESSES
	BBCC	#MCA$V_S_TOP_DISP,MCA$W_FLAGS(R1),20$ ; ... or SYSTEM class
20$:
	MOVL	@4(AP),R6		; Load CDB pointer
	MOVL	MRBPTR,R1		; Load MRB pointer
	BBC	#MRB$V_DISPLAY,MRB$W_FLAGS(R1),50$ ; No need to clear DATA array
					; ... if not already used for displaying
	MOVL	SPTR,R2			; Load SYI pointer
	MOVZWL	MNR_SYI$W_MAXPRCCT(R2),R2 ; Get max process count
	MULL3	#4,R2,R8		; Pass size of DATA array
	BBS	#CDB$V_SYSCLS,CDB$L_FLAGS(R6),30$ ; Br if SYSTEM class

;
; Call CLEAR_DATA to clear the DATA array for PROCESSES class
;

	MOVL	CDB$A_BUFFERS(R6),R9	; Pass address of DATA array
	MOVL	MBP$A_DATA(R9),R9	; ...
	JSB	CLEAR_DATA		; Clear DATA array in preparation for
					; ... call to FILL_DISP_BUFF
					; (CLEAR_DATA subrtn destroys R0-R5 and
					; ... R8,R9)
	BRB	50$			; Go continue.....

;
; Call CLEAR_DATA to clear all 4 DATA arrays for SYSTEM class
;

30$:
	MOVAL	SYS_TOP_VEC,R10		; Get addr of vector of ptrs
	MOVL	R8,R11			; Save array length
	MOVL	#4,R7			; Number of arrays to clear
40$:
	MOVL	(R10),R9		; R9 must contain array addr
	MOVL	R11,R8			; R8 gets array length
	JSB	CLEAR_DATA		; Clear DATA array in preparation for
					; ... call to FDB_SYS_TOP
					; (CLEAR_DATA subrtn destroys R0-R5 and
					; ... R8,R9)
	ADDL2	#16,R10			; Point to next array
	SOBGTR	R7,40$			; Loop back to process next one

;
; Load PROCESSES current collection buffer pointer (MBP$A_BUFFA)
; with first collection buffer pointer (MBP$A_BUFF1ST); then
; call FDB_SYS_TOP or FILL_DISP_BUFF to get the 5 TOP arrays
; loaded with data from the first collection buffer. Finally,
; restore original value of MBP$A_BUFFA for caller's use.
;

50$:
	MOVL	#<PROCS_CLSNO*CDB$K_SIZE>,R0 ; Compute offset to PROCESSES CDB
	MOVAB	CDBHEAD[R0],R0		; Index to CDB address
	MOVL	CDB$A_BUFFERS(R0),R2	; Load buffer block ptr
	MOVL	MBP$A_BUFFA(R2),R8	; Save current buffer pointer
	MOVL	MBP$A_BUFF1ST(R2),MBP$A_BUFFA(R2) ; Move first to current

	BBS	#CDB$V_SYSCLS,CDB$L_FLAGS(R6),60$ ; Br if SYSTEM class

	ALLOC	4,R0,R1			; Allocate 12 (4+descr) stack bytes
					; ... for FILL_DISP_BUFF call
	MOVL	R6,(R1)			; CDB pointer into allocated space
	PUSHL	R0			; Push pointer to time quadword
	PUSHL	R1			; Push address of CDB pointer
	CALLS	#2,FILL_DISP_BUFF	; Fill 5 TOP arrays
	BRB	70$			; Go continue.....
60$:
	PUSHL	R6			; Pass SYSTEM CDB address
	PUSHAL	FAOSTK			; Pass display buffer address
	CALLS	#2,FDB_SYS_TOP		; Fill 4 TOP arrays (doesn't use ORDER)
70$:
	MOVL	R8,MBP$A_BUFFA(R2)	; Restore current collection buffer ptr

	MOVL	#SS$_NORMAL,R0		; Indicate success
	RET				; ... and return

	.SBTTL	DISPLAY_PROCS - Put PROCESSES Display Output to Screen

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	Issues calls to various SCRPKG routines to display screen
;	output for the PROCESSES class (regular display).
;
; INPUTS:
;
;	 4(AP) - address of CDB (Class Descriptor Block) pointer
;		 for the PROCESSES class.
;
;	 8(AP) - address of quadword containing the system time
;		 value of the latest collection buffer.
;
; IMPLICIT INPUTS:
;
;	MCAPTR - pointer to MCA (Monitor Communication Area)
;	MRBPTR - pointer to MRB (Monitor Request Block)
;	SPTR   - pointer to SYI (System Information Area)
;
;	MCA$L_PROC_DISP - longword containing number of processes
;			  to display this interval.
;
;	PREV_PD         - longword containing number of processes
;			  displayed for the previous interval.
;
;
; OUTPUTS:
;
;	None
;
; IMPLICIT OUTPUTS:
;
;	Entire display buffer (FAOSTK) displayed to SYS$OUTPUT for
;	this display event.
;
;	PREV_PD -- longword set to the number of processes displayed
;		   this interval, for use next time through.
;
; ROUTINE VALUE:
;
;	R0 = SS$_NORMAL, or screen package error status.
;
; SIDE EFFECTS:
;
;	none
;
;--

.ENTRY	DISPLAY_PROCS, ^M<R2,R3,R4,R5,R6,R7,R8,R9,R10,R11>

	MOVL	@4(AP),R6		; Load CDB pointer
	MOVL	MCAPTR,R11		; Load MCA pointer
	MOVL	CDB$A_BUFFERS(R6),R10	; Load address of buffer block
	MOVL	MBP$A_PR_FAOSTK(R10),R5	; Get pointer to FAO stack
	MOVL	MCA$L_PROC_DISP(R11),R7	; Get number of procs to display
	BNEQ	10$			; Continue if we have some
	BRW	110$			; Get out quickly if none to display

;
; Compute number of lines to erase (difference in the number of
; processes from previous display to this one).
;
; Clear the display area if necessary.
;

10$:
	CLRL	R9			; Assume no lines to erase
	BBC	#MCA$V_ERA_SCRL,MCA$W_FLAGS(R11),30$
					; If bit clear, no need to erase
	CMPL	W^PREV_PD,#VTDATALINES	; Previous display a single screen?
	BLEQ	20$			; Yes -- skip the erase
	ALLOC	6,R1,R3			; Get 6 bytes for call to BLINK
	BSBW	BLINK			; Erase entire display area
	BLBS	R0,30$			; Continue if status OK
	BRW	DPROCS_RET		; Return with status if failed
					; (already logged)
20$:
	CMPL	R7,#VTDATALINES		; Current display a single screen?
	BGTR	30$			; No -- continue
	SUBL3	R7,W^PREV_PD,R9		; Yes -- calc lines to erase

;
; Compute and format ASCII uptime for setup display line.
;

30$:
	ALLOC	8,R1,R2			; Allocate 8 stack bytes for time calcs
	MOVL	SPTR,R4			; Get SYI pointer
	MOVQ	MNR_SYI$Q_BOOTTIME(R4),(R2) ; Boot time into calc area
	MOVQ	@8(AP),R0		; Get collection time
	SUBL2	R0,(R2)			; Subtract coll time from boot time
	SBWC	R1,4(R2)		; ....
	ALLOC	13,R4,R1		; Get ASCTIM output buffer
	$ASCTIM_S TIMBUF=(R4), TIMADR=(R2), CVTFLG=#0 ; Get ascii uptime
	BLBS	R0,40$			; Continue if status OK
	BRW	DPROCS_ERR		; Log error & ret with status if failed

;
; Put out process count and uptime.
;

40$:
	MOVL	R7,(R2)			; Re-use R2 as ptr to $FAOL parm list
	MOVL	R4,4(R2)		; Insert uptime descr ptr into parm list
	ALLOC	2,R1,R3			; Alloc 2 bytes for DISPLAY_PUT flags
	MOVW	#1,(R3)			; Set bit to force DISPLAY_PUT thru $FAOL
	PUSHL	R2			; Push ptr to $FAOL parameter list
	PUSHL	PROC_SETUP_STR+4	; Push address of setup string
	PUSHAL	PROC_SETUP_STR		; Push length of setup string
	PUSHL	R3			; Push DISPLAY_PUT request flags
	CALLS	#4,DISPLAY_PUT		; Put out screen setup string
	BLBS	R0,50$			; Continue if status OK
	BRW	DPROCS_RET		; Return with status if failed (already logged)

;
; Loop putting out a line for each process
;

50$:
	ALLOC	8,R1,R2			; Allocate a descriptor
	MOVL	#PROC_LINE,(R2)		; Move const len of FAO output buff
	MOVL	OUTDSC+4,4(R2)		; Load ptr to FAO output buffer
	MOVL	R7,R8			; Load no. of procs for this interval
60$:
	CMPL	R8,#VTDATALINES		; Will processes fit in display area?
	BLEQ	80$			; Yes -- go put them there

	BLBC	CTRLCZ_HIT,70$		; No -- go fill screen if collecting
					; Collection has ended
	MOVL	MRBPTR,R1		; Load MRB pointer
	BBS	#MRB$V_DISP_TO_FILE,MRB$W_FLAGS(R1),70$
					; Go fill screen if output to file
	BRB	130$			; Quit displaying
70$:
	MOVL	#VTDATALINES,R4		; Do a screenful
	BSBW	FILL_SCREEN		; .....
	BLBC	R0,DPROCS_ERR		; Exit if error

	BSBW	PRINT_SCREEN		; Force SCRPKG to display screen
	BLBC	R0,DPROCS_ERR		; Exit if error

	BSBW	HOLD_SCREEN		; Wait between screenfuls
	BLBC	R0,DPROCS_ERR		; Exit if error

	ALLOC	6,R1,R3			; Get 6 bytes for call to BLINK
	BSBW	BLINK			; Erase entire display area
	BLBC	R0,DPROCS_RET		; Return with status if failed
					; (already logged)
	SUBL2	#VTDATALINES,R8		; Calculate remaining processes
	BRB	60$			; ... and go get them displayed

80$:
	BLBC	CTRLCZ_HIT,90$		; Go fill screen unless CTRL-C or Z hit
					; Collection has ended
	MOVL	MRBPTR,R1		; Load MRB pointer
	BBS	#MRB$V_DISP_TO_FILE,MRB$W_FLAGS(R1),90$
					; Go fill screen if output to file
	BRB	130$			; Quit displaying
90$:
	MOVL	R8,R4			; Load no. of procs for final screenful
	BSBB	FILL_SCREEN		; ... and put them out
	BLBC	R0,DPROCS_ERR		; Exit if error

;
; At this point, all process lines have been sent to the SCRPKG.
;
; If necessary, erase individual screen lines left over from
; previous display event.
;

	MOVL	R9,R3			; Retrieve number of lines to erase
	BLEQ	110$			; Continue if none to erase
	ADDL3	#FIRST_DATA_LINE,R8,R4	; Compute 1st line to be erased
100$:
	PUSHL	#1			; Always erase from column 1
	PUSHL	R4			; ... at current row
	CALLS	#2,G^SCR$ERASE_LINE	; Erase current line
	BLBC	R0,DPROCS_ERR		; Quit if error
	INCL	R4			; Get next line number
	SOBGTR	R3,100$			; Go erase next line

;
; Save number of processes (this interval) for use in next interval.
;

110$:
	MOVL	R7,W^PREV_PD		; Remember number of procs for next interval
	BBSS	#MCA$V_ERA_SCRL,MCA$W_FLAGS(R11),120$
					; Indicate erase display area next int
120$:
	BSBB	PRINT_SCREEN		; Force SCRPKG to display the screen
	BLBC	R0,DPROCS_ERR		; Exit if error
130$:
	MOVL	#SS$_NORMAL,R0		; Successful status

DPROCS_RET:
	RET				; Return with status set	

DPROCS_ERR:
	BSBW	DISPERR			; Log display error
	RET				; Return with status


;
; PRINT_SCREEN subroutine.
;
; Forces SCRPKG to actually output entire screen.
;

PRINT_SCREEN:

	CALLS	#0,G^LIB$PUT_BUFFER	; Output SCRPKG buffer and stop buffering
	BLBC	R0,10$			; Exit if error
	PUSHAQ	SCRDSC			; Push MONITOR buffer addr
	CALLS	#1,G^LIB$SET_BUFFER	; Set buffering mode again
10$:
	RSB				; Return with R0 set


;
; The FILL_SCREEN subroutine fills the display area with
; the number of processes indicated in R4.
;
; REGISTER INPUTS:
;
;	R2 -- Pointer to an 8-byte stack area consisting of an FAO
;		output descriptor.
;		This register not modified by FILL_SCREEN.
;
;	R4 -- Number of processes to display (less than or equal
;		to display area size).
;		This register is destroyed by FILL_SCREEN.
;
;	R5 -- Pointer to current process in display buffer (FAO Stack).
;		On exit, R5 is updated to point to the first process
;		to be displayed on the next screen.
;
; SCRATCH REGISTERS:
;
;	R1
;
;	R3 --  Pointer to FAO control string
;
;	R10 -- Number of display lines to advance after PUT_LINE.
;
; RETURN REGISTER:
;
;	R0 -- On exit, contains status of most recent SCRPKG call.
;

FILL_SCREEN:

	PUSHL	#1			; Set cursor to
	PUSHL	#FIRST_DATA_LINE	; ... first PROCESSES
	CALLS	#2,G^SCR$SET_CURSOR	; ... display line
	BLBC	R0,40$			; Exit if error

	MOVL	#1,R10			; Load number of lines to advance
10$:
	CMPL	#1,R4			; Only one process left to display?
	BNEQ	20$			; No -- continue
	CLRL	R10			; Yes -- indicate no advance

;
; Choose an FAO control string based on process residency
;

20$:
	MOVAL	PROC_RES_STR,R3		; Assume this process is resident
	TSTL	MNR_PRO$K_FSIZE-4(R5)	; Is last longword for this process zero?
	BNEQ	30$			; No -- process is resident
	MOVAL	PROC_NRES_STR,R3	; Yes -- process is non-resident
;
; Issue FAOL
;

30$:
	$FAOL_S CTRSTR=(R3), OUTBUF=OUTDSC, PRMLST=(R5)
	BLBC	R0,40$			; Exit if error

;
; Send process output line to SCRPKG
;

	PUSHL	R10			; Push number of lines to advance
	PUSHL	R2			; Push addr of FAO output descriptor
	CALLS	#2,G^SCR$PUT_LINE	; Give one process line to SCRPKG
	BLBC	R0,40$			; Exit if error

	ADDL2	#MNR_PRO$K_FSIZE,R5	; Point to next process in FAO stack
	SOBGTR	R4,10$			; Loop back to do next process
40$:
	RSB				; Return

;
; BLINK Subroutine.
;
; Erases entire data display area.
; Also calls DISPLAY_PUT to replace the status
;	(footing) line if necessary.
;
; R3 = Address of 6-byte stack area for call to DISPLAY_PUT:
;
;	1) longword to hold length of status string;
;	2) pair of bytes used for request flags.
;
; Upon exit, R0 contains status from DISPLAY_PUT call.
;
; Register R1 is destroyed by this subroutine.
;

BLINK:
	PUSHL	#1			; Column 1
	PUSHL	#FIRST_DATA_LINE	; First line of data display area
	MOVL	MRBPTR,R1		; Get MRB pointer
	BBC	#MRB$V_MFSUM,MRB$W_FLAGS(R1),10$ ; Br if not m.f. summary
	ADDL2	#2,(SP)			; 1st data line lower for m.f. summary
10$:
	CALLS	#2,G^SCR$ERASE_PAGE	; Erase to end of screen

;
; Now replace the footing line that was erased if necessary
;

	MOVL	#SS$_NORMAL,R0		; Assume normal status
	MOVL	MRBPTR,R1		; Get MRB pointer
	BBS	#MRB$V_MFSUM,MRB$W_FLAGS(R1),20$
					; Don't refresh status if m.f. summary
	BITW	#<MRB$M_PLAYBACK+MRB$M_SUMMARY+MRB$M_RECORD>,MRB$W_FLAGS(R1)
					; Any status fields need refreshing?
	BEQL	20$			; No -- go exit
	PUSHAL	W^STATUS_PARMS		; Push addr of $FAOL parameter list
	PUSHAB	W^STATUS_STR+1		; Push address of status string
	MOVZBL	W^STATUS_STR,(R3)	; Load status string length
	PUSHL	R3			; Push its address
	MOVW	#1,4(R3)		; Set bit to force DISPLAY_PUT thru $FAOL
	PUSHAL	4(R3)			; Push ptr to DISPLAY_PUT request flags
	CALLS	#4,DISPLAY_PUT		; Put out status string on bottom line
20$:
	RSB				; Return with status in R0

;
; HOLD_SCREEN Subroutine.
;
;	Waits after a full screen has been displayed
;	in order to let the user see it before the
;	next screenful arrives.
;
; Upon exit, R0 contains status from $SETIMR or $WAITFR.
;
; Register R1 is destroyed by this subroutine.
;

HOLD_SCREEN:

	MOVL	#SS$_NORMAL,R0		; Assume normal status
	BLBS	CTRLCZ_HIT,10$		; If CTRL-C or Z hit, don't hold 
	MOVL	MRBPTR,R1		; Get MRB pointer
	BBS	#MRB$V_DISP_TO_FILE,MRB$W_FLAGS(R1),10$
					; Don't hold if output to file
	$SETIMR_S EFN=#BET_EV_FLAG, DAYTIM=VIEWING_DEL
					; Set time between screens
	BLBC	R0,10$			; Exit if error

	$WAITFR_S EFN=#BET_EV_FLAG	; Wait between screenfuls
10$:
	RSB				; Return with status

	.SBTTL	DISPLAY_TOP - Put PROCESSES/TOP Display Output to Screen

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	Constructs FAO control string for a PROCESSES/TOP screen
;	and calls DISPLAY_PUT to send the screen to the SCRPKG.
;
; INPUTS:
;
;	 4(AP) - address of CDB (Class Descriptor Block) pointer
;		 for the PROCESSES class.
;
; IMPLICIT INPUTS:
;
;	FAOSTK - FAO parameter list for a TOP screen
;
;	TOP_PROCS - byte containing count (up to 8) of
;		    TOP processes to display.
;
; OUTPUTS:
;
;	None
;
; IMPLICIT OUTPUTS:
;
;	Entire display buffer (FAOSTK) displayed to SYS$OUTPUT for
;	this display event.
;
; ROUTINE VALUE:
;
;	R0 = SS$_NORMAL, or screen package error status.
;
; SIDE EFFECTS:
;
;	none
;
;--

.ENTRY	DISPLAY_TOP, ^M<R2,R3,R4,R5,R6,R9,R10,R11>

	MOVL	@4(AP),R6		; Load CDB pointer
	MOVL	CDB$A_FAOCTR(R6),R11	; Load addr of FAO control string

;
; Loop which concatenates as many FAO control string segments
; as needed to build the portion of the control string for
; processes to be displayed. The portion for null lines is
; built later.
;

	MOVB	#FIRST_DATA_LINE,W^TOPLNNO ; Load first TOP display line no
	MOVZBL	W^TOPSTR,R9		; Load length of FAO ctr str for 1 line
	MOVZBL	W^TOP_PROCS,R10		; Load number of TOP procs to display
	BEQL	20$			; Branch if none
10$:
	MOVC3	R9,W^TOPSTR+1,(R11)	; Move ctr str segment to ctr string
	ADDL2	R9,R11			; Point to next available byte in ctr str
	ADDB2	#2,W^TOPLNNO		; Update cursor control to next disp line
	SOBGTR	R10,10$			; Move one segment for each process

;
; Now loop moving in control string segments for each
; null line to be displayed.
;

20$:
	SUBB3	W^TOP_PROCS,CDB$L_ECOUNT(R6),R10 ; Calc number of null lines
	BEQL	40$			; Branch if none
	MOVB	W^TOPLNNO,W^ERLNNO	; Line number of first null line
	MOVZBL	W^ERLINE_STR,R9		; Length of "erase line" control string
30$:
	MOVC3	R9,W^ERLINE_STR+1,(R11)	; Move ctr str segment to ctr string
	ADDL2	R9,R11			; Update control string pointer
	ADDB2	#2,W^ERLNNO		; Update cursor control to next disp line
	SOBGTR	R10,30$			; Move one segment for each null line

;
; Call DISPLAY_PUT to put the screen image to SYS$OUTPUT.
;

40$:
	ALLOC	6,R1,R9			; Alloc 2 bytes for DISPLAY_PUT flags
					; ... and a longword for ctr str size
	MOVB	#1,(R9)			; Set bit to force DISPLAY_PUT thru $FAOL
	MOVB	#1,1(R9)		; Force DISPLAY_PUT to output it now
	SUBL3	CDB$A_FAOCTR(R6),R11,2(R9) ; Calc size of FAO control string

	PUSHAL	W^FAOSTK		; Push ptr to $FAOL parameter list
	PUSHL	CDB$A_FAOCTR(R6)	; Push address of control string
	PUSHAL	2(R9)			; Push length of control string
	PUSHL	R9			; Push DISPLAY_PUT request flags
	CALLS	#4,DISPLAY_PUT		; Put out screen setup string
	BLBC	R0,DTOP_RET		; Return with status if failed (already logged)

	MOVL	#SS$_NORMAL,R0		; Indicate success

DTOP_RET:
	RET				; Return with status set	

	.SBTTL	DISPLAY_HOMOG - Put Homog Class Display Output to Screen

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	Issues calls to various SCRPKG routines to display screen
;	output for the current (homogeneous) class.
;
; INPUTS:
;
;	 4(AP) - address of CDB (Class Descriptor Block) pointer
;		 for the current class.
;
; IMPLICIT INPUTS:
;
;	MCAPTR - pointer to MCA (Monitor Communication Area)
;	MRBPTR - pointer to MRB (Monitor Request Block)
;
;	CDX$L_PREV_DCT - longword containing number of elements
;			 displayed for the previous interval.
;
;
; OUTPUTS:
;
;	None
;
; IMPLICIT OUTPUTS:
;
;	Entire list of elements for this homogeneous class
;	displayed to SYS$OUTPUT for this display event.
;
;	CDX$L_PREV_DCT -- longword set to the number of elements displayed
;		   this interval, for use next time through.
;
; ROUTINE VALUE:
;
;	R0 = SS$_NORMAL, or screen package error status.
;
; SIDE EFFECTS:
;
;	none
;
;--

.ENTRY	DISPLAY_HOMOG, ^M<R3,R5,R6,R7,R8,R11>

	MOVL	@4(AP),R6		; Load CDB pointer
	MOVL	CDB$A_CDX(R6),R7	; Load CDX pointer
	MOVL	MCAPTR,R11		; Load MCA pointer
	ALLOC	6,R1,R3			; Get 6 bytes for calls to BLINK
					; ... and DISPLAY_PUT

	TSTL	CDX$A_DISPNAM(R7)	; Check if we have a name display rtn
	BNEQ	10$			; Br if we do
	BRW	80$			; Else, go exit if not

10$:
	BBC	#MCA$V_ERA_SCRL,MCA$W_FLAGS(R11),20$
					; If bit clear, no need to erase
	CMPL	CDX$L_PREV_DCT(R7), -	; Previous display a single screen?
		#VTDATALINES
	BLEQ	20$			; Yes -- skip the erase
	BSBW	BLINK			; Erase entire display area
	BLBS	R0,20$			; Continue if status OK
	BRW	DHOMOG_RET		; Return with status if failed
					; (already logged)
;
; Display item name if necessary
;

20$:
	BBC	#MCA$V_ERA_SCRL,MCA$W_FLAGS(R11),30$
					; If bit clear, need to display
	CMPB	CDX$B_IDISCT(R7),#1	; More than one item?
	BLEQ	35$			; Br if no (no need to display)
30$:
	ALLOC	8,R0,R1			; Alloc 2 lwords for FAOL parm stack

	BSBW	DISP_HOM_ITMNAM		; Display item name string

	BLBS	R0,35$			; Continue if status OK
	BRW	DHOMOG_RET		; Return with status if failed
					; (already logged)

;
; Loop putting out a screenful each time
;

35$:
	MOVL	CDX$L_DCOUNT(R7),R8	; Load no. of elements this interval
	CLRL	R5			; Init element index
40$:
	CMPL	R8,#VTDATALINES		; Will elements fit on the screen?
	BLEQ	60$			; Yes -- go put them there

	BLBC	CTRLCZ_HIT,50$		; No -- go fill screen if collecting
					; Collection has ended
	MOVL	MRBPTR,R1		; Load MRB pointer
	BBS	#MRB$V_DISP_TO_FILE,MRB$W_FLAGS(R1),50$
					; Go fill screen if output to file
	BRB	90$			; Quit displaying
50$:
	PUSHL	R5			; Push starting element index
	PUSHL	#VTDATALINES		; ... no. of elts to display
	PUSHL	R6			; ... and CDB address

	CALLS	#3,FILL_HOMOG_SCREEN	; Display a screenful of elements
	BLBC	R0,DHOMOG_RET		; Exit if error (already logged)
	ADDL2	#VTDATALINES,R5		; Compute element index for next fill

	BSBW	HOLD_SCREEN		; Wait between screenfuls
	BLBC	R0,DHOMOG_ERR		; Exit if error

	BSBW	BLINK			; Erase entire display area
	BLBC	R0,DHOMOG_RET		; Return with status if failed
					; (already logged)
	SUBL2	#VTDATALINES,R8		; Calculate remaining elements
	BRB	40$			; ... and go get them displayed


;
; Fill a screen with remaining elements
;

60$:
	BLBC	CTRLCZ_HIT,70$		; Go fill screen unless CTRL-C or Z hit
					; Collection has ended
	MOVL	MRBPTR,R1		; Load MRB pointer
	BBS	#MRB$V_DISP_TO_FILE,MRB$W_FLAGS(R1),70$
					; Go fill screen if output to file
	BRB	90$			; Quit displaying
70$:
	PUSHL	R5			; Push starting element index
	PUSHL	R8			; ... no. of elts to display
	PUSHL	R6			; ... and CDB address

	CALLS	#3,FILL_HOMOG_SCREEN	; Display final screenful of elements
	BLBC	R0,DHOMOG_RET		; Exit if error (already logged)

;
; At this point, all elements have been sent to the SCRPKG.
;


;
; Save number of elements displayed this interval for use in next interval.
;

80$:
	MOVL	CDX$L_DCOUNT(R7), -
		CDX$L_PREV_DCT(R7)	; Remember no. of elts for next intv'l
	BBSS	#MCA$V_ERA_SCRL,MCA$W_FLAGS(R11),90$
					; Indicate erase display area next int
90$:
	MOVL	#SS$_NORMAL,R0		; Successful status

DHOMOG_RET:
	RET				; Return with status set	

DHOMOG_ERR:
	BSBW	DISPERR			; Log display error
	RET				; Return with status

;
; DISP_HOM_ITMNAM Subroutine.
;
; Calls DISPLAY_PUT to display the item name string
; in the heading for this homogeneous class. It is
; entered into the SCRPKG buffer, but not actually
; output to the terminal.
;
; Upon input,
;
; R1 = Address of 8-byte FAOL parm stack for call to DISPLAY_PUT
;
; R3 = Address of 6-byte stack area for call to DISPLAY_PUT:
;
;	1) longword to hold length of status string;
;	2) pair of bytes used for request flags.
;
; R6 = Address of CDB
; R7 = Address of CDX
;
; Upon exit, R0 contains status from DISPLAY_PUT call.
;
; Register R1 is destroyed by this subroutine.
;

DISP_HOM_ITMNAM:

	MOVB	#ILN_REG,W^ITMLNNO	; Set up row no. for reg. displays
	MOVL	MRBPTR,R0		; Get MRB pointer
	BBC	#MRB$V_MFSUM,MRB$W_FLAGS(R0),10$ ; Br if not m.f. summary
	SUBB2	#2,W^ITMLNNO		; Adjust row no. for m.f. summary
10$:
	MOVZBL	W^NAME_COL,(R1)		; Get col number for name string
	DECL	(R1)			; Express as additional spaces
	MOVZBL	CDX$B_IDISINDEX(R7),R0	; Get item index for this disp event

	MOVZBL	@CDB$A_ITMSTR(R6)[R0],R0 ; Load IDB item number
	MULL2	#IDB$K_ILENGTH,R0	; Compute index into IDB table
	MOVAB	W^PERFTABLE[R0],R0	; Address of IDB for this item
	MOVL	IDB$A_LNAME(R0),4(R1)	; Addr of item name str to FAOL stack

	PUSHL	R1			; Push addr of FAOL parameter list

	PUSHAB	W^ITEM_NAM_STR+1	; Push addr of item name FAOL ctrl str
	MOVZBL	W^ITEM_NAM_STR,(R3)	; Load its length
	PUSHL	R3			; Push address of length longword
	MOVW	#1,4(R3)		; Set bit to force DISPLAY_PUT thru $FAOL
	PUSHAL	4(R3)			; Push ptr to DISPLAY_PUT request flags
	CALLS	#4,DISPLAY_PUT		; Put out item name in heading

	RSB				; Return with status in R0

	.SBTTL	FILL_HOMOG_SCREEN - Fill a Screen with Homog Class Output
;++
;
; FUNCTIONAL DESCRIPTION:
;
;	Issues calls to DISPLAY_PUT to display a full screen
;	of output for this homogeneous class.
;
; INPUTS:
;
;	 4(AP) - address of CDB (Class Descriptor Block)
;		 for the current (homogeneous) class.
;
;	 8(AP) - number of element names (e.g., disk names) to be displayed.
;
;	12(AP) - Element ID Table index of 1st element to be displayed.
;
;
; IMPLICIT INPUTS:
;
;	MRBPTR - pointer to MRB (Monitor Request Block)
;
;	MFSPTR - pointer to MFS (Multi-File Summary Block)
;
; OUTPUTS:
;
;	None
;
; IMPLICIT OUTPUTS:
;
;	Entire screen full of homogeneous class data, names and
;	heading information output to the terminal.
;
; ROUTINE VALUE:
;
;	R0 = SS$_NORMAL, or screen package error status.
;
; SIDE EFFECTS:
;
;	none
;
;--

.ENTRY	FILL_HOMOG_SCREEN, ^M<R4,R5,R6,R7>

	MOVL	4(AP),R6		; Load CDB pointer
	MOVL	CDB$A_CDX(R6),R7	; Load CDX pointer
	MOVL	8(AP),R4		; Load no. of elts to display
	BNEQ	10$			; Br if have some
	BRW	70$			; Else simply go output screen
10$:
	MOVL	12(AP),R5		; Load element index of first one

;
; Set up call to names display routine.
;

	CLRL	R0			; Init count of names to skip displaying
	TSTL	R5			; First screenful this interval?
	BNEQ	20$			; Br if not
	CMPL	CDX$L_PREV_DCT(R7), -	; Previous display a single screen?
		#VTDATALINES
	BGTR	20$			; Br if not
	MOVL	CDX$L_PREV_DCT(R7),R0	; Skip display of all "previous" names
20$:
	CMPL	R0,R4			; Any additional names this interval?
	BEQL	40$			; Skip display if not
	ADDL3	R0,#FIRST_DATA_LINE,-(SP) ; Stack starting row number
	MOVL	MRBPTR,R1		; Get MRB pointer
	BBC	#MRB$V_MFSUM,MRB$W_FLAGS(R1),30$ ; Br if not m.f. summary
	ADDL2	#2,(SP)			; 1st data line lower for m.f. summary
30$:
	SUBL3	R0,R4,-(SP)		; Stack name count
	ADDL3	R0,R5,-(SP)		; Stack element index of first ...
					; ... name to display
	PUSHL	R6			; Stack CDB address

;
; Call name display routine
;

	CALLS	#4,DISP_HOM_NAMES	; Display the element names
	BLBS	R0,40$			; Br if OK status
	BRW	FHS_ERR			; Else go exit if error

;
; Now display the actual data
;

;
; First, compute the length of the FAO control string
;

40$:
	MOVZBL	CDB$B_FAOSEGLEN(R6),R1	; Get length of the FAO segment
	MULL2	R4,R1			; Compute length of FAO ctrl string
	MOVZBL	CDB$B_FAOPRELEN(R6),R0	; Get length of the FAO prefix
	ADDL3	R0,R1,CDB$L_FAOCTR(R6)	; ... and add it in

;
; Alloc some space for DISPLAY_PUT flags
;

	ALLOC	2,R0,R4			; Alloc 2 bytes for DISPLAY_PUT flags
	MOVB	#1,(R4)			; Set bit to force DISPLAY_PUT thru $FAOL
	CLRB	1(R4)			; ... but don't force to screen yet

;
; Calculate and stack beginning of FAOSTK segment for this screen
;

	MOVL	MRBPTR,R0		; Get MRB pointer
	BBC	#MRB$V_MFSUM,MRB$W_FLAGS(R0),50$ ; Br if not m.f. summary
	MOVL	MFSPTR,R0		; Get MFS pointer
	MULL3	#4,MFS$L_LWORDS(R0),R0	; Compute bytes in FAOSTK for one elt
	BRB	60$			; Go compute offset
50$:
	MOVL	#<4*TAB_LWORDS>,R0	; Assume tabular display
	CMPB	CDB$B_ST(R6),#ALL_STAT	; ALL statistic requested?
	BEQL	60$			; Br if so
	
	MOVL	#<4*BAR_LWORDS>,R0	; Bar graph display
60$:
	MULL2	R5,R0			; Compute offset to first data to display
	MOVAB	L^FAOSTK[R0],-(SP)	; ... and stack its address

	PUSHL	CDB$A_FAOCTR(R6)	; Stack address of FAO ctrl str
	PUSHAL	CDB$L_FAOCTR(R6)	; ... and its length
	PUSHL	R4			; Stack DISPLAY_PUT request flags

	CALLS	#4,DISPLAY_PUT		; Put screenful of homog class data

	BLBC	R0,FHS_RET		; Return with status if failed
					; ... (already logged)

;
; Send "REGSET" escape sequence to screen
; to get back to the regular character set,
; and force all accumulated output to screen.
;

70$:
	ALLOC	2,R0,R4			; Alloc 2 bytes for DISPLAY_PUT flags
	CLRB	(R4)			; Indicate no $FAOL filter needed
	MOVB	#1,1(R4)		; Force all accumulated output to screen

	ALLOC	2,R0,R1			; Get space for esc seq string & descr
	MOVW	#REGSET,(R1)		; Move in "reg set" escape sequence
	PUSHL	4(R0)			; Stack address of string
	PUSHAL	(R0)			; ... and its length
	PUSHL	R4			; Stack DISPLAY_PUT request flags

	CALLS	#3,DISPLAY_PUT		; Set reg set and display whole screen

	BLBC	R0,FHS_RET		; Return with status if failed
					; ... (already logged)

	MOVL	#SS$_NORMAL,R0		; Successful status

FHS_RET:
	RET				; Return with status set	

FHS_ERR:
	BSBW	DISPERR			; Log display error
	RET				; Return with status

;
; DISPERR Subroutine.
;
; Entered when an error has occurred in a system service or
; other routine while attempting to display to the terminal.
; Upon entry, R0 contains the failing status code. This
; routine makes a call to MON_ERR which records a MONITOR
; error code of MNR$_DISPERR and a subordinate error code of
; that in R0. Then, upon exit, the MNR$_DISPERR status is
; placed in R0.
;
; Upon entry,
;
; R0 = Error status code from a system service or other routine
;
; Upon exit,
;
; R0 = MNR$_DISPERR status code
;
; Register R1 is destroyed by this subroutine.
;

DISPERR:
	PUSHL	R0			; Bad status on stack
	PUSHAL	(SP)			; Stack pointer to bad status
	PUSHL	#MNR$_DISPERR		; Stack MONITOR failing status code
	CALLS	#2,MON_ERR		; Log the error
	ADDL2	#4,SP			; Pop original status
	MOVL	#MNR$_DISPERR,R0	; Get new status to caller
	RSB				; Return

	.SBTTL	DISP_HOM_NAMES - Display Names for Homog Class

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	Issues calls to SCRPKG routines to display names
;	of homogeneous elements for the current screen.
;	The names are entered into the SCRPKG buffer, but
;	are not actually output to the screen.
;
; INPUTS:
;
;	 4(AP) - address of CDB (Class Descriptor Block)
;		 for the current (homogeneous) class.
;
;	 8(AP) - Element ID Table index of 1st element to be displayed.
;
;	12(AP) - number of element names (e.g., disk names) to be displayed.
;
;	16(AP) - screen row number on which to display first element.
;
; IMPLICIT INPUTS:
;
; OUTPUTS:
;
;	None
;
; IMPLICIT OUTPUTS:
;
;	All names for the current screen full of elements are sent
;	to the SCRPKG.
;
; ROUTINE VALUE:
;
;	R0 = SS$_NORMAL, or screen package error status.
;
; SIDE EFFECTS:
;
;	none
;
;--

.ENTRY	DISP_HOM_NAMES, ^M<R2,R3,R4,R5,R6,R7,R8,R9,R10>

	MOVL	4(AP),R6		; Load CDB pointer
	MOVL	CDB$A_CDX(R6),R7	; Load CDX pointer
	MOVL	12(AP),R9		; Get number of elements to display
	ALLOC	40,R0,R3		; Get 10 longwords for an FAO stack
	ALLOC	10,R0,R2		; Allocate a descriptor & a word

;
; Get Element ID Table address of first element to be displayed
;

	MOVZBL	CDX$B_ELIDLEN(R7),R8	; Get length of an element ID
	MULL3	8(AP),R8,R10		; Compute offset to 1st display elt
	MOVL	CDX$A_ELIDTABLE(R7),R1	; Get addr of elt ID table
	MOVL	MRBPTR,R0		; Get MRB pointer
	BBC	#MRB$V_MFSUM,MRB$W_FLAGS(R0),10$ ; Br if not m.f. summary
	MOVL	CDX$A_SELIDTABLE(R7),R1	; Get addr of super elt ID table
10$:
	ADDL2	R1,R10			; Compute addr of 1st display elt

;
; Get row and column numbers for first element name
;

	MOVL	16(AP),R4		; Get first row number
	MOVZBL	W^NAME_COL,R5		; ... and column number

;
; Call class-specific routine to fill the FAO stack
; for the current element.
;
; NOTE -- this routine expects:
;
;	R0,R1 = scratch
;	R3  = address of 10-longword FAO stack
;	R6  = address of CDB
;	R7  = address of CDX
;	R10 = address of current element ID
;

20$:
	JSB	@CDX$A_DISPNAM(R7)	; Fill the FAO stack

;
; FAO stack is set up. Issue the $FAOL and SCR$PUT_SCREEN calls
;

	$FAOL_S CTRSTR=@CDX$A_DISPFAO(R7), OUTLEN=8(R2), -
		OUTBUF=W^OUTDSC, PRMLST=(R3) ; Format an element name

	BLBC	R0,DHN_RET		; Exit if error
	MOVZWL	8(R2),(R2)		; Move actual text len to descr
	MOVL	W^OUTDSC+4,4(R2)	; Move addr of text to descr

;
; Push SCR$PUT_SCREEN arguments on stack and call it to display one name
;

	PUSHL	#0			; No special screen attributes
	PUSHL	R5			; Column number
	PUSHL	R4			; Row number
	PUSHAL	(R2)			; Text descriptor
	CALLS	#4,G^SCR$PUT_SCREEN	; Put a name string to terminal

	BLBC	R0,DHN_RET		; Exit if error

	ADDL2	R8,R10			; Point to next element for display
	INCL	R4			; Point to next row number
	SOBGTR	R9,20$			; ... and go do it

	MOVL	#SS$_NORMAL,R0		; Successful status

DHN_RET:
	RET				; Return with status set	


	.SBTTL	DISPLAY_PUT - Put Display Output to Screen

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	Puts DISPLAY output to SYS$OUTPUT (or any file) using
;	the Screen Package. Depending on the setting of an input
;	flag, DISPLAY_PUT will either send the supplied buffer
;	directly on to the screen package, or run it through $FAOL
;	before sending it. A second input flag indicates whether or 
;	not to actually output the data sent to the screen package.
;
; INPUTS:
;
;	 4(AP) - address of 2 contiguous bytes, each containing a flag:
;
;		Byte 0:	If low bit set, use supplied buffer as input
;			to $FAOL, and send the resultant buffer
;			to the screen package. Otherwise, send
;			the buffer directly on to the screen 
;			package.
;
;		Byte 1:	If low bit set, issue screen package calls to
;			actually output the data. Otherwise,
;			no such calls are made and the screen
;			package merely buffers all received data.
;
;	 8(AP) - address of longword containing length of buffer to put.
;
;       12(AP) - address of buffer to put.
;
;	16(AP) - optional address of $FAOL parameter list.
;
; IMPLICIT INPUTS:
;
;	OUTDSC - quadword string descriptor for $FAOL output buffer.
;	SCRDSC - quadword string descriptor for buffer required by SCRPKG.
;
; OUTPUTS:
;
;	none
;
; IMPLICIT OUTPUTS:
;
;	Translated buffer sent to Screen Package.
;
; ROUTINE VALUE:
;
;	R0 = SS$_NORMAL, or screen package error status.
;
; SIDE EFFECTS:
;
;	none
;
;--

.ENTRY	DISPLAY_PUT,^M<R2>

	BBS	#0,@4(AP),10$		; Go do $FAOL call if requested
	PUSHL	12(AP)			; Otherwise, simply put buffer
	PUSHL	@8(AP)			; ....
	CALLS	#2,PUT_TO_SCREEN	; ....
	BRB	20$			; Join common code
10$:
	ALLOC	10,R1,R2		; Allocate a descriptor & a word
	MOVL	@8(AP),(R2)		; Move in length of buffer
	MOVL	12(AP),4(R2)		; ... and address of buffer
	$FAOL_S CTRSTR=(R2), OUTLEN=8(R2), OUTBUF=OUTDSC, PRMLST=@16(AP)
	BLBC	R0,DP_ERR		; Exit if error
	PUSHL	OUTDSC+4		; Push output buffer address
	MOVZWL	8(R2),-(SP)		; ... and its length
	CALLS	#2,PUT_TO_SCREEN	; Put buffer to screen	
20$:
	BLBC	R0,DP_ERR		; Exit if error
	MOVL	@4(AP),-(SP)		; Get parameter bytes on stack
	BBC	#0,1(SP),30$		; Go exit if no output requested
	CALLS	#0,G^LIB$PUT_BUFFER	; Output SCRPKG buffer and stop buffering
	BLBC	R0,DP_ERR		; Exit if error
	PUSHAQ	SCRDSC			; Push MONITOR buffer addr
	CALLS	#1,G^LIB$SET_BUFFER	; Set buffering mode again
	BLBC	R0,DP_ERR		; Exit if error
30$:
	MOVL	#SS$_NORMAL,R0		; No failing status hit
	RET				; Return with success	
DP_ERR:
	BSBW	DISPERR			; Log display error
	RET				; Return with status

	.SBTTL	PUT_TO_SCREEN - Translate escape seqs and issue PUT_SCREEN

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	Translate a buffer with imbedded escape sequences to Screen
;	Package (SCRPKG) calls. The escape sequences present on
;	input are defined above in the messages declaration section.
;	They are generally VT52-style sequences, with a few minor
;	changes. These are converted to general-case SCRPKG calls
;	to accommodate any terminal. Within the buffer, strings of
;	text between escape sequences are sent to SCRPKG with a
;	SCR$PUT_SCREEN call.
;
; INPUTS:
;
;	4(AP) - length of buffer to translate (longword).
;	8(AP) - address of buffer to translate.
;
; IMPLICIT INPUTS:
;
;	SYSOUT_TYPE - SYS$OUTPUT terminal type (byte).
;
; OUTPUTS:
;
;	none
;
; IMPLICIT OUTPUTS:
;
;	none
;
; ROUTINE VALUE:
;
;	R0 = Worst status received from SCRPKG.
;
; SIDE EFFECTS:
;
;	The entire buffer has been sent to the SCRPKG.
;
;--

.ENTRY	PUT_TO_SCREEN,^M<R2,R3>

	MOVQ	4(AP),R2		; get len & addr of buffer to translate
SCANBUF:
	MOVQ	R2,TXT_DESC		; save descriptor of remaining buffer
	LOCC	#ESC,R2,(R3)		; scan for escape character
	MOVQ	R0,R2			; use R2-R3 instead of R0-R1
	SUBW	R2,TXT_LENGTH		; compute length of text
	BEQL	10$			; br if no text between esc sequences
	CALLG	PUTSCRARG,G^SCR$PUT_SCREEN ; put text string into SCRPKG buffer
	BLBS	R0,10$			; continue if status OK
	MOVL	R0,PTS_STAT		; else, remember it for later
	.page
10$:
	SUBW	#2,R2			; update length of remaining buffer
	BGEQ	20$			; keep going if more chars in buffer
	BRW	PTS_RET			; all done if slid off end
20$:
	ADDL	#2,R3			; update ptr to remaining buffer
	LOCC	-1(R3),#ES_TAB_LEN,W^ESC_SEQ_TABLE ; get offset into tab for CASE
	BNEQ	30$			; go do CASE for known esc sequences
	BSBW	PUT_ESC_SEQ		; unknown esc seq ... just put out as text
	BRW	CHEKRET			; join common code
30$:
	CASE	R0,<CHEKBUF,PTS_ESCY,PTS_ESCU,PTS_ESCR,PTS_ESCK, -
		    PTS_ESCJ,PTS_ESCH,PTS_ESCG,PTS_ESCF,PTS_ESCB,PTS_ESCL>,W
	BRB	PTS_ESCH		; if out of range, do a cursor home

PTS_ESCB:				; set "bold" attribute
	BBSS	#SCR$V_BOLD,W^ATTRIBMSK,10$ ; turn on appropriate bit in attrib mask
10$:
	BRW	CHEKBUF			; join common code

PTS_ESCL:				; set "underline" attribute
	CMPB	#DEC_CRT,W^SYSOUT_TYPE	; is SYS$OUTPUT device VT100-compat ?
	BNEQU	10$			; no -- don't request underlining
	BBSS	#SCR$V_UNDERLINE,W^ATTRIBMSK,10$ ; turn on appropriate bit in attrib mask
10$:
	BRW	CHEKBUF			; join common code

PTS_ESCR:				; set "reverse video" attribute
	BBSS	#SCR$V_REVERSE,W^ATTRIBMSK,10$ ; turn on appropriate bit in attrib mask
10$:
	BRW	CHEKBUF			; join common code

PTS_ESCU:				; clear all VT100 attribute settings
	CLRL	W^ATTRIBMSK		; do it......
	BRW	CHEKBUF			; join common code

PTS_ESCY:				; position cursor
	SUBW	#2,R2			; update buffer length
	BGEQ	10$			; continue if more buffer left
	BRW	PTS_RET			; err if no coordinates -- just quit
10$:
	MOVZBL	1(R3),-(SP)		; stack column number
	MOVZBL	(R3),-(SP)		; stack row number
	ADDL	#2,R3			; update ptr to remaining buffer
	CALLS	#2,G^SCR$SET_CURSOR	; set the cursor position
	BRB	CHEKRET			; join common code

PTS_ESCK:				; erase to end of line
	CALLS	#0,G^LIB$ERASE_LINE	; do exactly that
	BRB	CHEKRET			; join common code

PTS_ESCJ:				; erase to end of page (screen)
	CALLS	#0,G^LIB$ERASE_PAGE	; do it
	BRB	CHEKRET			; join common code

PTS_ESCH:				; cursor to home
	PUSHL	#1			; stack column number
	PUSHL	#1			; stack row number
	CALLS	#2,G^SCR$SET_CURSOR	; position cursor to home
	BRB	CHEKRET			; join common code

PTS_ESCF:				; select "alternate" graphics set
	MOVAQ	VT100_ALTSET,VT100_CURSET ; make the alternate set current
	BRB	SELECT_SET		; ... and go output esc seq to select it

PTS_ESCG:				; select "regular" graphics set
	MOVAQ	VT100_REGSET,VT100_CURSET ; make the regular set current

SELECT_SET:
	CMPB	#DEC_CRT,W^SYSOUT_TYPE	; is SYS$OUTPUT device VT100-compat ?
	BNEQU	10$			; no --try another type
	PUSHL	VT100_CURSET		; yes -- push addr of esc seq
	CALLS	#1,G^SCR$PUT_SCREEN	; ... and write it
	BRB	CHEKRET			; join common return from CASE
10$:
	CMPB	#VT5X,SYSOUT_TYPE	; is it VT5x series ?
	BNEQU	CHEKBUF			; no -- no need to change char set

	BSBW	PUT_ESC_SEQ		; write out the esc seq just scanned

CHEKRET:
	BLBS	R0,CHEKBUF		; continue if status OK
	MOVL	R0,PTS_STAT		; else, remember it for later

CHEKBUF:				; common return point for CASE
	TSTW	R2			; whole buffer examined yet ?
	BEQL	PTS_RET			; yes -- get out
	BRW	SCANBUF			; no -- go look at more

PTS_RET:
	MOVL	PTS_STAT,R0		; return status value
	RET


PUT_ESC_SEQ:				; subroutine to put an imbedded esc
					; ... sequence directly to the screen

	MOVW	#2,TXT_LENGTH		; load length of esc sequence
	MOVAB	-2(R3),TXT_START	; load starting address
	PUSHAQ	TXT_DESC		; push descriptor addrress
	CALLS	#1,G^SCR$PUT_SCREEN	; ... and put out "as is"
	RSB

	.SBTTL	SELECT_REV_LEVS - Select Revision Levels

;++
;
; FUNCTIONAL DESCRIPTION:
;
;
;	This routine is called from the REQUEST_INIT routine in
;	REQUEST.PLI to select the appropriate Revision Level for
;	each class being monitored. Once the level is selected,
;	this routine stores the level number in REVLEVELS, a
;	128-byte vector which contains level numbers for all
;	classes being monitored. Then it moves the CHange
;	Descriptor (CHD) for each class into its Class Descriptor
;	Block (CDB/CDX). For playback, a class which has a revision
;	level unknown to this version of MONITOR is flagged in
;	the UNK_CLASSES vector.
;
; INPUTS:
;
;	 4(AP) - address of a 128-bit vector describing classes
;		 to monitor. If class n is to be monitored,
;		 bit n is a 1; otherwise it is 0.
;
;	 8(AP) - address of a 128-bit vector which will describe
;		 classes with revision levels unknown to this
;		 version of MONITOR (UNK_CLASSES). It is used only
;		 for playback requests. For live requests and playback
;		 of Version 3 files (all classes at Rev 0), 8(AP)
;		 contains 0. Upon entry, all bits are
;		 indeterminate. For each class n to be monitored,
;		 bit n is set to 0 if its revision level is known
;		 and 1 if its revision level is unknown.
;
;       12(AP) - address of HDR$T_REVLEVELS, a 128-byte vector
;		 indicating the revision level of each recorded
;		 (i.e., input) class (for playback requests only).
;		 For live requests and playback of Version 3 files
;		 (all classes at Rev 0), 12(AP) contains 0.
;
;	16(AP) - address of REVLEVELS, a 128-byte vector, into which
;		 will be stored a level number for each class being
;		 monitored. Upon input, all bytes contain 0.
;
; IMPLICIT INPUTS:
;
;	MAX_CLASS_NO -	maximum class number defined.
;	MRBPTR -	pointer to MRB (Monitor Request Block)
;	CDBHEAD -	table of contiguous CDBs.
;
; OUTPUTS:
;
;	For each class to be monitored, one of two things happens:
;
;		1) if its revision level is unknown, the appropriate
;			bit in UNK_CLASSES is set. (Can happen only
;			on playback); or,
;
;		2) the CHD (CHange Descriptor) is moved to the CDB/CDX.
;
;	Also, for each class to be monitored, the appropriate byte
;		in REVLEVELS is set to the selected revision level.
;
; IMPLICIT OUTPUTS:
;
;	None
;
; ROUTINE VALUE:
;
;	NORMAL
;
; SIDE EFFECTS:
;
;	None
;
;--

.ENTRY	SELECT_REV_LEVS, ^M<R2,R3,R4,R5,R6,R7,R8,R9>

	MOVL	MRBPTR,R7		; Get MRB pointer for later use
	TSTL	8(AP)			; Check if UNK_CLASSES is provided
	BEQL	10$			; If not, don't reference it
	MOVC5	#0,.,#0,#16,@8(AP)	; Assume all classes are NOT unknown

;
; Use FFS instruction to select classes to be monitored.
;

10$:
	CLRL	R5			; Init starting bit position
20$:
	MOVL	#32,R3			; Init bit field size
					; NOTE -- must handle in 32-bit chunks
	MOVL	R5,R2			; Init start position of next chunk
30$:
	FFS	R2,R3,@4(AP),R4		; Search class bits for next class no.
					; R4 contains class no. if found
	BEQL	40$			; Branch if none found this chunk
	BSBB	SELECT_REV		; Select Rev Level for this class
	ADDL2	R2,R3			; Compute next starting
	ADDL3	#1,R4,R2		; ... position and field size
	SUBL2	R2,R3			; ... for this chunk
	BRB	30$			; Go search rest of chunk
40$:
	ACBW	#MAX_CLASS_NO,#32,R5,20$ ; Loop to process next chunk

	MOVL	NORMAL,R0		; Set normal status
	RET				; Return


SELECT_REV:				; Select Rev Level for this class
					; NOTE -- R4 contains class number
					; Regs R2, R3, R4, R5 must not be changed

	MULL3	#CDB$K_SIZE,R4,R6	; Compute offset to desired CDB
	MOVAB	CDBHEAD[R6],R6		; Index to CDB address

	BBS	#MRB$V_PLAYBACK,MRB$W_FLAGS(R7),10$ ; If PLAYBACK, go do it
					; Else, stay here and do LIVE
	MOVL	CDB$A_CHDHDR(R6),R8	; Get ptr to CHD header
	MOVZBL	(R8)+,R9		; Get current rev level
	BSBB	MOVE_CHD		; ... and move CHD for it to CDB/CDX
	BRB	SR_RSB			; All done with this class

10$:					; Playback

	MOVL	CDB$A_CHDHDR(R6),R8	; Get ptr to CHD header
	MOVZBL	(R8)+,R0		; Get curr level from CHDHDR
20$:
	MOVL	12(AP),R9		; Get addr of recorded rev levels
	BEQL	60$			; Br if none (recorded lev is 0)
	MOVZBL	(R9)[R4],R9		; Get recorded rev level
	CMPL	R9,R0			; Recorded rev level greater than curr?
	BLEQU	60$			; Br if no (and use recorded level)
	BBSS	R4,@8(AP),30$		; Yes -- set bit for this class ...
30$:					; ... in UNK_CLASSES
	BBC	#SYSTEM_CLSNO,@4(AP),SR_RSB ; Skip checks if no SYSTEM
	CMPL	R4,#PROCS_CLSNO		; Is this the PROCESSES class?
	BEQL	40$			; Br if yes
	CMPL	R4,#STATES_CLSNO	; Is this the STATES class?
	BEQL	40$			; Br if yes
	CMPL	R4,#MODES_CLSNO		; Is this the MODES class?
	BNEQ	SR_RSB			; Br if no -- all done with this class
40$:
	BBSS	#SYSTEM_CLSNO,@8(AP),50$ ; Yes -- also set bit for SYSTEM class 
50$:					; ... in UNK_CLASSES
	BRB	SR_RSB			; All done with this class
60$:
	BSBB	MOVE_CHD		; Move CHD for this class to CDB

SR_RSB:
	RSB				; Return to caller


MOVE_CHD:				; Move CHD for selected rev level ...
					; ... to the CDB
;
; Upon input,
;
;	R4 = the current class number,
;	R6 = addr of CDB for this class.
;	R8 = addr of first CHD, 
;	R9 = the selected Rev Level,
;
; This routine alters R0 and R9.
;

	MOVB	R9,@16(AP)[R4]		; Set revision level
	MULL2	#CHD$K_SIZE,R9		; Compute offset to desired CHD
	MOVAB	(R8)[R9],R9		; R9 gets addr of desired CHD
	MOVL	CHD$L_ICOUNT(R9),CDB$L_ICOUNT(R6) ; Move in item count
	MOVL	CHD$A_ITMSTR(R9),CDB$A_ITMSTR(R6) ; ... and item string ptr
	MOVW	CHD$W_BLKLEN(R9),CDB$W_BLKLEN(R6) ; ... and block length
	MOVW	CHD$W_DISPCTL(R9),CDB$W_DISPCTL(R6) ;.. and display ctl string
	BBC	#CDB$V_HOMOG,CDB$L_FLAGS(R6),10$  ; Br if heterogeneous
	MOVL	CDB$A_CDX(R6),R0	; Homogeneous class -- get CDX
	MOVB	CHD$B_ELIDLEN(R9),CDX$B_ELIDLEN(R0) ; Move in elem ID length
10$:
	RSB				; Return

	.SBTTL	ESTAB_CTRLCZ - Establish CTRL-C,Z Handlers

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called to set up a CTRL-C handler and a
;	CTRL-Z handler for the SYS$COMMAND terminal device. A
;	channel is assigned to SYS$COMMAND and its device class 
;	is checked for TERMINAL. If not terminal class, the
;	handlers are not established.
;
;	Then $QIOW's are issued to the terminal driver to establish
;	both handlers. If any system service call fails,
;	the failing status is returned; otherwise, NORMAL status
;	is returned.
;
; INPUTS:
;
;	None
;
; IMPLICIT INPUTS:
;
;	CTRLC - address of CTRL-C handling routine.
;	CTRLZ - address of CTRL-Z handling routine.
;
; OUTPUTS:
;
;	None
;
; IMPLICIT OUTPUTS:
;
;	CTRL-C handler established for "CTRLC" routine.
;	CTRL-Z handler established for "CTRLZ" routine.
;	CTRLCZ_CHAN contains channel number.
;
; ROUTINE VALUE:
;
;	NORMAL, or failing system service status.
;
; SIDE EFFECTS:
;
;	none
;
;--

.ENTRY	ESTAB_CTRLCZ,	^M<R2,R3,R4>

	ALLOC	2,R1,R2			; Allocate word on stack for chan number
	$ASSIGN_S DEVNAM=W^SYSCMD_DESC, CHAN=(R2) ; Assign channel to SYS$COMMAND
	BLBS	R0,10$			; Continue if status OK
	BRW	EC_ERR			; Branch if error

10$:
	ALLOC	DIB$K_LENGTH,R3,R4	; Allocate DIB buffer on stack
	$GETCHN_S CHAN=(R2), PRIBUF=(R3) ; Get info on SYS$COMMAND device
	BLBC	R0,EC_ERR		; Branch if error

	CMPB	#DC$_TERM,DIB$B_DEVCLASS(R4) ; Is SYS$COMMAND device a terminal?
	BNEQU	EC_NOR			; No -- go return with normal status

	MOVZWL	(R2),L^CTRLCZ_CHAN	; Yes -- save channel no. for $CANCEL

	$QIOW_S	CHAN=(R2), -		; Set up CTRL-C handler
		FUNC=#<IO$_SETMODE!IO$M_CTRLCAST>, -
		P1=G^CTRLC

	BLBC	R0,EC_ERR		; Branch if error

	$QIOW_S	CHAN=(R2), -		; Now set up CTRL-Z handler
		FUNC=#<IO$_SETMODE!IO$M_OUTBAND>, -
		P1=G^CTRLZ, -
		P2=#CTRLZ_MASK

	BLBC	R0,EC_ERR		; Branch if error

EC_NOR:
	MOVL	NORMAL,R0		; Normal status
EC_ERR:
	RET				; Return with status

	.SBTTL	ESTAB_CTRLW - Establish CTRL-W Handler

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called to set up a CTRL-W handler for
;	refreshing the display terminal screen. A channel is
;	assigned to the display device and its device class is
;	checked for TERMINAL. If not terminal class, the handler
;	is not established.
;
;	Then a $QIOW is issued to the terminal driver to establish
;	the CTRL-W handler. If any system service call fails,
;	the failing status is returned; otherwise, NORMAL status
;	is returned.
;
; INPUTS:
;
;	None
;
; IMPLICIT INPUTS:
;
;	MRBPTR - pointer to MRB (Monitor Request Block)
;
;	CTRLW - address of CTRL-W handling routine.
;
; OUTPUTS:
;
;	None
;
; IMPLICIT OUTPUTS:
;
;	CTRL-W handler established for "CTRLW" routine.
;	CTRLW_CHAN contains channel number.
;
; ROUTINE VALUE:
;
;	NORMAL, or failing system service status.
;
; SIDE EFFECTS:
;
;	none
;
;--

.ENTRY	ESTAB_CTRLW,	^M<R2,R3,R4>

	ALLOC	2,R1,R2			; Allocate word on stack for chan number
	MOVL	MRBPTR,R3		; Get pointer to MRB
	$ASSIGN_S DEVNAM=@MRB$A_DISPLAY(R3), - ; Assign channel to display device
		  CHAN=(R2)
	BLBC	R0,EW_ERR		; Branch if error

	ALLOC	DIB$K_LENGTH,R3,R4	; Allocate DIB buffer on stack
	$GETCHN_S CHAN=(R2), PRIBUF=(R3) ; Get info on display device
	BLBC	R0,EW_ERR		; Branch if error

	CMPB	#DC$_TERM,DIB$B_DEVCLASS(R4) ; Is display device a terminal?
	BNEQU	EW_NOR			; No -- go return with normal status

	MOVZWL	(R2),L^CTRLW_CHAN	; Yes -- save channel no. for $CANCEL

	$QIOW_S	CHAN=(R2), -		; Set up CTRL-W handler
		FUNC=#<IO$_SETMODE!IO$M_OUTBAND>, -
		P1=G^CTRLW, -
		P2=#CTRLW_MASK

	BLBC	R0,EW_ERR		; Branch if error

EW_NOR:
	MOVL	NORMAL,R0		; Normal status
EW_ERR:
	RET				; Return with status

	.SBTTL	MON_ERR - Log MONITOR Error

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called to log an error whenever a MONITOR
;	synchronous error is discovered. Asynchronous (signaled)
;	errors are logged via the SIGNALED_ERR routine.
;	Logging consists of filling in the PUTMSGVEC array.
;	This array is the message argument vector for $PUTMSG which
;	will be called after all routines leading up to this
;	one have returned.
;
; INPUTS:
;
;	 4(AP) - MONITOR message code (required parameter)
;
;	 8(AP) - address of a secondary message code (0 if none).
;		 (optional parameter)
;
;       12(AP) - 1st FAO argument for MONITOR message (optional
;		 parameter). Up to 16 additional FAO arguments
;		 may be included in this parameter list, immediately
;		 following this parameter.
;
; IMPLICIT INPUTS:
;
;	PUTMSGVEC - 26-longword array, to contain the message argument
;		     vector for $PUTMSG.
;
; OUTPUTS:
;
;	none
;
; IMPLICIT OUTPUTS:
;
;	PUTMSGVEC contains message argument vector for later LIB$SIGNAL call.
;
; ROUTINE VALUE:
;
;	none
;
; SIDE EFFECTS:
;
;	none
;
;--

.ENTRY	MON_ERR,	^M<R2,R3>

	MOVAL	PUTMSGVEC+4,R1		; Get pointer to where MONITOR code goes
	MOVL	4(AP),(R1)+		; Move it in and point to next item in list
	MOVZWL	(AP),R2			; Get number of input args
	CMPL	#1,R2			; Just one arg?
	BLSS	10$			; No -- continue
	MOVL	#1,PUTMSGVEC		; Yes -- tack on argument vector size
	BRB	ME_RET			; ... and go return
10$:
	SUBL2	#2,R2			; Compute # of input FAO args
	BGTR	20$			; Continue if found some
	CLRL	(R1)+			; Indicate none in PUTMSGVEC
	CLRL	R2			; Remember for later
	BRB	50$			; ... and go check secondary code
20$:
	CMPL	#PUTMSGSIZE-4,R2	; # FAO args greater than max?
	BGEQ	30$			; No, OK as is
	MOVL	#PUTMSGSIZE-4,R2	; Yes, replace with max
30$:
	MOVL	R2,(R1)+		; Move # FAO args into list
	CLRL	R3			; Clear an index register
40$:
	MOVL	12(AP)[R3],(R1)+	; Move an FAO arg into list
	AOBLSS	R2,R3,40$		; Loop to move all FAO args

50$:
	ADDL3	#2,R2,PUTMSGVEC		; Compute # message args and store
	TSTL	8(AP)			; Secondary message code?
	BEQL	ME_RET			; No -- all done
	MOVL	@8(AP),(R1)		; Yes -- move in after FAO args
	INCL	PUTMSGVEC		; ... and count it
ME_RET:
	RET				; Return to caller	

	.SBTTL	SIGNALED_ERR - Log Signaled Error

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called to log an error whenever a MONITOR
;	asynchronous (signaled) error is discovered. Synchronous
;	errors (detected by MONITOR) are logged via the MON_ERR
;	routine. Logging consists of filling in the PUTMSGVEC array.
;	This array is the message argument vector for $PUTMSG which
;	will be called after all routines leading up to this
;	one have returned.
;
; INPUTS:
;
;	 4(AP) - MONITOR message code (required parameter)
;
;	 8(AP) - secondary message code (required parameter)
;
;       12(AP) - number of additional (FAO) arguments for secondary
;		 message.
;
;	16(AP) - address of first additional argument. Others
;		 follow contiguously.
;
; IMPLICIT INPUTS:
;
;	PUTMSGVEC - 26-longword array, to contain the message argument
;		     vector for $PUTMSG.
;
; OUTPUTS:
;
;	none
;
; IMPLICIT OUTPUTS:
;
;	PUTMSGVEC contains message argument vector for later LIB$SIGNAL call.
;
; ROUTINE VALUE:
;
;	none
;
; SIDE EFFECTS:
;
;	none
;
;--

.ENTRY	SIGNALED_ERR,	^M<R2,R3>

	MOVAL	PUTMSGVEC+4,R1		; Get pointer to where MONITOR code goes
	MOVL	4(AP),(R1)+		; Move it in and point to next item in list
	CLRL	(R1)+			; Zero MONITOR FAO args
	MOVL	8(AP),(R1)+		; Move in secondary code
	MOVL	#3,PUTMSGVEC		; Size of PUTMSGVEC so far
	CLRL	R2			; Start out with no PC/PSL args for 2ndary
	CMPZV	#STS$V_FAC_NO,#STS$S_FAC_NO,8(AP),#SYS_FAC_NO ; System fac code?
	BNEQ	10$			; No -- go add in additional args
	ADDL2	#2,R2			; Yes -- count the PC/PSL args (h'ware xcptn)
10$:
	ADDL2	12(AP),R2		; Add in caller's additional args for 2ndary
	BEQL	40$			; Go exit if none
	MOVL	16(AP),R3		; Set up pointer to first add'l arg
	CMPL	#PUTMSGSIZE-4,R2	; # FAO args greater than max?
	BGEQ	20$			; No, OK as is
	MOVL	#PUTMSGSIZE-4,R2	; Yes, replace with max
20$:
	ADDL2	R2,PUTMSGVEC		; Add the add'l args into PUTMSGVEC size
30$:
	MOVL	(R3)+,(R1)+		; Move from signal array to PUTMSGVEC
	SOBGTR	R2,30$			; Loop once for each add'l arg
40$:
	RET				; ... and return

	.SBTTL	SIGNAL_MON_ERR - Signal MONITOR Error

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine issues a CALLG to LIB$SIGNAL, passing a
;	signal argument list created by the MON_ERR or SIGNALED_ERR
;	routine. This routine is called from MONMAIN, a PL/I
;	routine; it is necessary because PL/I does not generate
;	G-form routine calls.
;
; INPUTS:
;
;	none
;
; IMPLICIT INPUTS:
;
;	PUTMSGVEC - 26-longword array, containing the signal argument
;		     list to be passed to LIB$SIGNAL.
;
; OUTPUTS:
;
;	none
;
; IMPLICIT OUTPUTS:
;
;	Condition is signaled. The VMS default condition handler will
;	display the error messages asssociated with the condition.
;
; ROUTINE VALUE:
;
;	none
;
; SIDE EFFECTS:
;
;	none
;
;--

.ENTRY	SIGNAL_MON_ERR,	^M<>

	CALLG	L^PUTMSGVEC,G^LIB$SIGNAL ; Signal the MONITOR error
	RET				; ... and return

	.SBTTL	LINK_MON_ERR - Link MONITOR Error

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine is called to link a MONITOR error message
;	into PUTMSGVEC ahead of the message already there.
;	It uses two input arguments: the MONITOR error message
;	code and the address of its (only) argument.
;
; INPUTS:
;
;	 4(AP) - MONITOR message code
;
;	 8(AP) - address of the only FAO argument for the MONITOR
;		 message (must be present).
;
; IMPLICIT INPUTS:
;
;	PUTMSGVEC - 26-longword array, to contain the message argument
;		     vector for $PUTMSG.
;
; OUTPUTS:
;
;	none
;
; IMPLICIT OUTPUTS:
;
;	PUTMSGVEC updated to include the input MONITOR message as its
;	primary error, followed by the original contents of PUTMSGVEC
;	as a linked error.
;
; ROUTINE VALUE:
;
;	None
;
; SIDE EFFECTS:
;
;	None
;
;--

.ENTRY	LINK_MON_ERR,	^M<R2,R3,R4,R5,R6>

	ALLOC	4*<PUTMSGSIZE-1>,R0,R6	; Get temp space on stack
	MULL3	#4,PUTMSGVEC,R0		; Compute size of source for move
	MOVC5	R0,PUTMSGVEC+4,#0, -	; Move current contents to temp area
		#4*<PUTMSGSIZE-1>,(R6)
	ADDL2	#3,PUTMSGVEC		; Increase size of vector
	MOVL	4(AP),PUTMSGVEC+4	; Move error code into vector
	MOVL	#1,PUTMSGVEC+8		; Move FAO arg count into vector
	MOVL	8(AP),PUTMSGVEC+12	; Move FAO arg addr into vector
	MOVC5	#4*<PUTMSGSIZE-1>,(R6),#0 - ; Move orig contents back in
		,#4*<PUTMSGSIZE-4>,PUTMSGVEC+16

	$PUTMSG_S MSGVEC=PUTMSGVEC	; Put out the linked message
	MOVL	#1,(R6)			; Use temp area for another msg
	MOVL	#MNR$_CONT,4(R6)	; ... which says "Continuing..."

	$PUTMSG_S MSGVEC=(R6)		; Put it out
	RET				; Return

	.SBTTL	FREE_MEM - Free Virtual Memory

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This routine issues calls to LIB$FREE_VM to free up virtual
;	memory acquired by classes for FAO control strings and
;	collection buffer blocks. Also, a special write buffer used
;	by the PROCESSES class is freed if present; also, the SYSTEM
;	class DATA arrays. No status code checking is done, since this
;	routine is in a cleanup path.
;
; INPUTS:
;
;	None
;
; IMPLICIT INPUTS:
;
;	The CDB$L_FAOCTR, CDB$A_FAOCTR, CDB$L_BUFFERS and CDB$A_BUFFERS
;	fields contain the length and address, respectively, of memory
;	blocks to be freed (for each class in this MONITOR request).
;
;	Additionally, PROC_WRI_BUFD is a quadword containing the length
;	and address of the special write buffer for the PROCESSES class.
;
;	Also, SYS_DATA_ADDR and SYS_DATA_LEN describe the address and length
;	of the SYSTEM class DATA arrays.
;
; OUTPUTS:
;
;	None
;
; IMPLICIT OUTPUTS:
;
;	Memory is freed. Pointers to freed memory are cleared to 0.
;
; ROUTINE VALUE:
;
;	NORMAL
;
; SIDE EFFECTS:
;
;	None
;
;--

.ENTRY	FREE_MEM, ^M<R2,R3,R4,R5,R6,R7>

;
; First free up memory left over from a special
; write buffer used for recording PROCESSES records.
;

	TSTL	L^PROC_WRI_BUFD+4	; Is there a buffer?
	BEQL	5$			; Br if not
	PUSHAL	L^PROC_WRI_BUFD+4	; Yes -- stack addr of buffer ptr
	PUSHAL	L^PROC_WRI_BUFD		; Stack addr of buffer length
	CALLS	#2,G^LIB$FREE_VM	; Free the buffer
	CLRL	L^PROC_WRI_BUFD+4	; Clear address

;
; Check for SYSTEM class DATA arrays, and free them if present
;

5$:
	TSTL	SYS_DATA_ADDR		; SYSTEM DATA arrays here ?
	BEQL	10$			; Branch if not
	PUSHAL	SYS_DATA_ADDR		; Stack addr of arrays ptr
	PUSHAL	SYS_DATA_LEN		; Stack addr of arrays length
	CALLS	#2,G^LIB$FREE_VM	; Free the space
	CLRL	SYS_DATA_ADDR		; Clear address

;
; Now look only at the requested classes for this MONITOR request.
; Free up the FAO control string and the collection buffer block for each.
;

10$:

	MOVL	MRBPTR,R7		; Load MRB pointer
	CLRL	R5			; Init starting bit position
20$:
	MOVL	#32,R3			; Init bit field size
					; NOTE -- must handle in 32-bit chunks
	MOVL	R5,R2			; Init start position of next chunk
30$:
	FFS	R2,R3,MRB$O_CLASSBITS(R7),R4 ; Search for next class number
					; R4 contains class no. if found
	BEQL	40$			; Branch if none found this chunk
	BSBB	FREE_CLASS		; Free memory for this class
	ADDL2	R2,R3			; Compute next starting
	ADDL3	#1,R4,R2		; ... position and field size
	SUBL2	R2,R3			; ... for this chunk
	BRB	30$			; Go search rest of chunk
40$:
	ACBW	#MAX_CLASS_NO,#32,R5,20$ ; Loop to process next chunk

	MOVL	NORMAL,R0		; Set normal status
	RET				; Return


FREE_CLASS:				; Free class memory
					; NOTE -- R4 contains class number

	MULL3	#CDB$K_SIZE,R4,R6	; Compute offset to desired CDB
	MOVAB	CDBHEAD[R6],R6		; Index to CDB address
	TSTL	CDB$A_FAOCTR(R6)	; Is there an FAO control string?
	BEQL	10$			; Branch if not
	MOVAL	SYS_FAO_STR,R0		; Get addr of special SYSTEM FAO str
	CMPL	CDB$A_FAOCTR(R6),R0	; Is this it?
	BEQL	5$			; Yes, don't try to free it
	PUSHAL	CDB$A_FAOCTR(R6)	; Stack addr of string ptr
	MOVL	#FAOCTR_SIZE,CDB$L_FAOCTR(R6) ; Ensure whole string is freed
	PUSHAL	CDB$L_FAOCTR(R6)	; Stack addr of string length
	CALLS	#2,G^LIB$FREE_VM	; Free it
5$:
	CLRL	CDB$A_FAOCTR(R6)	; Clear address
10$:
	TSTL	CDB$A_BUFFERS(R6)	; Is there a buffer block?
	BEQL	20$			; Branch if not
	PUSHAL	CDB$A_BUFFERS(R6)	; Stack addr of block ptr
	PUSHAL	CDB$L_BUFFERS(R6)	; Stack addr of block length
	CALLS	#2,G^LIB$FREE_VM	; Free it
	CLRL	CDB$A_BUFFERS(R6)	; Clear address
20$:
	RSB				; Return

	.SBTTL	DISK_DISPNAM - DISK Class display name subroutine

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This subroutine fills an FAO parameter stack with up to
;	10 longwords required to display a single element (disk)
;	name. The address of an element ID entry is passed to this
;	routine in a register; the address of the FAO stack is
;	also passed in a register.
;
; CALLING SEQUENCE:
;
;	JSB	DISK_DISPNAM
;
; INPUTS:
;
;	R3  = address of 10-longword FAO stack
;	R6  = address of CDB
;	R7  = address of CDX
;	R10 = address of current element ID
;
; IMPLICIT INPUTS:
;
;	None
;
; OUTPUTS:
;
;	None
;
; IMPLICIT OUTPUTS:
;
;	The FAO parameter stack is filled with as many longword
;	parameter values as necessary (up to 10) to display a
;	single element name. The number of parameters is defined
;	by the FAO control string defined for this homogeneous
;	class.
;
; ROUTINE VALUE:
;
;	None
;
; SIDE EFFECTS:
;
;	Alters R0.
;
;--

DISK_DISPNAM::

;
; First determine whether we have the special wider name
; area available with the tabular (/ALL) statistics display.
;

	MOVL	MRBPTR,R0		; Get MRB pointer
	BBS	#MRB$V_MFSUM,MRB$W_FLAGS(R0),10$ ; Br if m.f. summary
	CMPB	CDB$B_ST(R6),#ALL_STAT	; All statistics requested ?
	BNEQ	10$			; Br if no
	CLRL	R0			; Indicate wide display area
	BRB	20$			; ... and continue
10$:
	MOVL	#1,R0			; Indicate narrow display area
20$:
	BBC	#CDB$V_DISKAC, -	; Br if recorded without alloc class
		CDB$L_FLAGS(R6),50$	; .....
	TSTB	(R10)			; Allocation class 0?
	BEQL	50$			; Br if so

;
; Process a disk name with allocation class
;

	MOVAL	W^DISK_FAO_AC, -	; FAO string with alloc class
		CDX$A_DISPFAO(R7)
	MOVZBL	(R10),(R3)		; Move alloc class into FAO stack
	MOVAL	1(R10),4(R3)		; Move in device name pointer
	MOVZWL	5(R10),8(R3)		; ... and unit number

	CLRL	12(R3)			; Assume wide display
	BLBC	R0,30$			; Br if so
	MOVL	#1,12(R3)		; Else stack a different value
30$:
	CLRL	16(R3)			; Assume zero length node name field
	BLBS	R0,40$			; Br if narrow display area
	MOVL	#9,16(R3)		; Stack len of node name field for wide
40$:
	MOVAQ	7(R10),20(R3)		; Stack node name address
	BRB	DD_VOL			; ... and go stack volume name

;
; Process a disk name with the node$device format.
;

50$:
	MOVAL	W^DISK_FAO,CDX$A_DISPFAO(R7) ; FAO string without alloc class
	MOVL	#13,(R3)		; Assume narrow display area
	MOVL	#1,20(R3)		; .......
	BLBS	R0,60$			; Br if narrow
	MOVL	#22,(R3)		; Stack values for wide area
	CLRL	20(R3)			; .......
60$:
	BBC	#CDB$V_DISKAC, -	; Br if recorded without alloc class
		CDB$L_FLAGS(R6),80$	; ....

;
; Process a disk name with with zero allocation class
;

	MOVAQ	7(R10),4(R3)		; Move node name ptr into FAO stack
	CLRL	8(R3)			; Assume zero dollar-sign field length
	TSTB	7(R10)			; See if node name exists
	BEQL	70$			; Br if not
	MOVL	#1,8(R3)		; Adjust dollar-sign field length
70$:
	MOVAL	1(R10),12(R3)		; Move in device name pointer
	MOVZWL	5(R10),16(R3)		; ... and unit number
	BRB	DD_VOL			; Go stack volume name

;
; Process a disk name recorded without allocation class.
; This is the revision level 0 format for the element ID.
; It does not include an allocation class, and the fields
; are in positions different from those of later revision
; levels. This code is also suitable for processing journal
; device names.
;

80$:
	MOVAQ	(R10),4(R3)		; Move node name ptr into FAO stack
	CLRL	8(R3)			; Assume zero dollar-sign field length
	TSTB	(R10)			; See if node name exists
	BEQL	90$			; Br if not
	MOVL	#1,8(R3)		; Adjust dollar-sign field length
90$:
	MOVAL	8(R10),12(R3)		; Move in device name pointer
	MOVZWL	12(R10),16(R3)		; ... and unit number

DD_VOL:
	CLRL	24(R3)			; Assume no volume name
	MOVL	.,28(R3)		; .... (use any accessible address)
	BBC	#CDB$V_DISKVN, -	; Br if volume name not available
		CDB$L_FLAGS(R6),DD_RSB	; ....
	MOVL	#12,24(R3)		; Stack length of vol name
	MOVAB	15(R10),28(R3)		; ... and its address

DD_RSB:
	RSB				; Return to caller


	.SBTTL	SCS_DISPNAM - SCS Class display name subroutine

;++
;
; FUNCTIONAL DESCRIPTION:
;
;	This subroutine fills an FAO parameter stack with up to
;	10 longwords required to display a single element (SCS)
;	name. The address of an element ID entry is passed to this
;	routine in a register; the address of the FAO stack is
;	also passed in a register.
;
; CALLING SEQUENCE:
;
;	JSB	SCS_DISPNAM
;
; INPUTS:
;
;	R3  = address of 10-longword FAO stack
;	R10 = address of current element ID
;
; IMPLICIT INPUTS:
;
;	None
;
; OUTPUTS:
;
;	None
;
; IMPLICIT OUTPUTS:
;
;	The FAO parameter stack is filled with as many longword
;	parameter values as necessary (up to 10) to display a
;	single element name. The number of parameters is defined
;	by the FAO control string defined for this homogeneous
;	class.
;
; ROUTINE VALUE:
;
;	None
;
; SIDE EFFECTS:
;
;	None
;
;--

SCS_DISPNAM::

	MOVAQ	(R10),(R3)		; Move node name ptr into FAO stack
	TSTB	(R10)			; Is there a node name?
	BNEQ	10$			; Yes, return
	MOVAB	UNKNOWN_NODE,(R3)	; No, make it "Unknown Node"
10$:
	RSB				; Return to caller

.END

