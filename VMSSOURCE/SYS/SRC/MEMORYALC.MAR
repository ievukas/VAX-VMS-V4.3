	.TITLE	MEMORYALC - DYNAMIC MEMORY ALLOCATION
	.IDENT	'V04-000'
 
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
; D. N. CUTLER 3-AUG-76
;
; MODIFIED BY:
;
;	V03-031	WMC0011		Wayne Cardoza		27-Aug-1984
;		Return correct status after pool expansion fails.
;
;	V03-030	WMC0010		Wayne Cardoza		23-Aug-1984
;		Output message on pool expansion failure.
;
;	V03-029	DAS0002		David Solomon		30-Apr-1984
;		Fix broken branch destination.
;
;	V03-028	DAS0001		David Solomon		30-Apr-1984
;		Fix broken word reference to IOC$GL_xxx.
;
;	V03-027 CWH3027		CW Hobbs		29-Apr-1984
;		Fix broken branch.
;
;	V03-026 EMD0072		Ellen M. Dusseault	6-Apr-1984
;		Fix broken branches.
;
;	V03-025	KPL0003		Peter Lieberwirth	31-Mar-1984
;		Fix register useage bug in EXE$ALOPHYCNTG.  Fix some
;		broken branches.
;
;	V03-024	SRB0118		Steve Beckhart		26-Mar-1984
;		Fixed broken branches.
;
;	V03-024	KDM0095		Kathleen D. Morse	23-Mar-1984
;		Maximize size of slave CEB with regular CEB in EXE$ALLOCCEB.
;
;	V03-023	WMC0009		Wayne Cardoza		08-Mar-1984
;		Add entry point for non-paged variable length pool.
;
;	V03-022	WMC0008		Wayne Cardoza		25-Feb-1984
;		Optimize EXE$ALLOCBUF
;
;	V03-021	KPL0002		Peter Lieberwirth	22-Feb-1984
;		Fix bugs in V03-019, specifically: move routine to
;		non-paged PSECT, correct pointers that are zero-based.
;
;	V03-020 LY00B3		Larry Yetto		10-FEB-1984 10:10
;		Fix truncation errors
;
;	V03-019	KPL0001		Peter Lieberwirth	 5-Feb-1984
;		Add EXE$ALOPHYCNTG routine that allocates physically
;		contiguous memory and maps it in system virtual address
;		space.
;
;	V03-018	LJK0257		Lawrence J. Kenah	6-Jan-1984
;		Add EXE$ALOPAGWAIT routine that parallels a similar for
;		nonpaged pool. Remove EXE$ALLOCPQB entry point.
;
;	V03-017	DWT0157		David W. Thiel		29-Dec-1983
;		Fix broken branches.
;
;	V03-016	TMK0001		Todd M. Katz		13-Nov-1983
;		Fix a broken branch.
;
;	V03-015	CWH3015		CW Hobbs		29-Oct-1983
;		Fix broken branch.
;
;	V03-014	DWT0123		David W. Thiel		23-Aug-1983
;		Improve performance of main path through EXE$ALLOCATE by
;		deleting the calculation of the largest free block.
;		Improve performance of EXE$DEANONPGDSIZ by avoiding
;		call to SCH$RAVAIL on returning a block to a lookaside
;		list when the lookaside list was not previously empty.
;		Add EXE$DEAPGDSIZ entry point to deallocate an
;		arbirtrary quantity of paged dynamic memory.
;
;	V03-013	SRB0098		Steve Beckhardt		19-Jul-1983
;		Fixed bug in extending pool.  Changed EXE$ALONONPAGED
;		to return SS$_INSFMEM on error.
;
;	V03-012	SRB0076		Steve Beckhardt		8-Apr-1983
;		Modified EXE$ALONONPAGED to preserve R3.  Added entry point
;		EXE$ALONPAGWAITS which is similar to EXE$ALONPAGWAIT but
;		may be called at IPL$_SYNCH.
;	
;	V03-011	ROW0178		Ralph O. Weber		 5-APR-1983
;		Enhance the "cannot expand pool right now because IPL is 
;		wrong" test in EXE$EXTENDPOOL to allow pool expansion when the 
;		current IPL is at or below IPL$_SYNCH or the processor is not
;		running on the interrupt stack.
;
;	V03-010	RSH0006		R. Scott Hanna		28-Feb-1983
;		Temporary disable of size and address granularity check
;		in EXE$DEAP1. This check should be restored when all users
;		of the P1 allocation region call EXE$ALOP1PROC or
;		EXE$ALPO1IMAG to allocate space.
;
;	V03-009	JWH0183		Jeffrey W. Horn		10-Feb-1983
;		Modify P1 routines to round requests to proper allocation
;		boundries.
;
;	V03-008	STJ3052		Steven Jeffreys		20-Jan-1983
;		Changed W^ to L^ to fix link truncation error.
;
;	V03-007	WMC0007		Wayne Cardoza		10-Jan-1983
;		Fix MOVZBL of PCB length (grew past byte length).
;
;	V03-006	JWH0142		Jeffrey W. Horn		20-Nov-1982
;		Optimize routines added in JWH0119.  Also allow these
;		routines to be called from elevated IPL.
;
;	V03-005	JWH0119		Jeffrey W. Horn		 3-Nov-1982
;		Add  EXE$ALOP1IMAG, EXE$ALOP1PROC, and EXE$DEAP1
;		routines.
;
;	V03-004	CWH0001		CW Hobbs		19-Aug-1982
;		Add call to $PFNDEF macro
;
;	V03-003	WMC0001		Wayne Cardoza		31-Jul-1982
;		Fill in PFN data base when expanding non-paged pool.
;
;	V03-002	SRB0052		Steve Beckhardt		2-Jun-1982
;		Modified EXE$DEALLOCATE to detect overlapping deallocates
;		and bugcheck if this occurs.
;
; DYNAMIC MEMORY ALLOCATION
;
; MACRO LIBRARY CALLS
;
 
	$CEBDEF				;DEFINE COMMON EVENT BLOCKS
	$DYNDEF				;DEFINE DATA STRUCTURE TYPE CODES
	$IPLDEF				;DEFINE INTERRUPT PRIORITY LEVELS
	$IRPDEF				;DEFINE IRP OFFSETS
	$IMPDEF				;DEFINE RMS IMPURE AREA SYMBOLS
	$JIBDEF				;DEFINE JIB OFFSETS
	$PCBDEF				;DEFINE PCB OFFSETS
	$PFNDEF				;DEFINE PFN CONSTANTS & OFFSETS
	$PHDDEF				;DEFINE PHD OFFSETS
	$PQBDEF				;DEFINE PQB OFFSETS
	$PRDEF				;DEFINE PROCESSOR REGISTERS
	$PSLDEF				;DEFINE PSL FIELDS
	$PTEDEF				;DEFINE PTE FIELDS
	$RSNDEF				;DEFINE RESOURCE WAIT NUMBERS
	$SHBDEF				;DEFINE SHARED MEM CONTROL BLOCK
	$SHDDEF				;DEFINE SHARED MEM DATAPAGE
	$SSDEF				;DEFINE SYSTEM STATUS VALUES
	$TQEDEF				;DEFINE TQE OFFSETS
	$TTYDEF				;TWP
 	$VADEF				;DEFINE VIRTUAL ADDRESS FIELDS

;
; LOCAL SYMBOLS
;
; ALLOCATION GRANULARITY MASK
;
 
MASK=^XF				;16 BYTE ALLOCATION GRANULARITY
EXE$C_ALCGRNMSK==MASK			; ALLOCATION GRANULARITY MASK

	.PSECT	AEXENONPAGED		; NONPAGED EXEC
	.PAGE
	.SBTTL	ALLOCATE MEMORY AND CONDITIONALLY WAIT
;+
; EXE$ALLOCBUF - ALLOCATE BUFFERED I/O BUFFER AND CONDITIONALLY WAIT
;
; THIS ROUTINE IS CALLED TO ALLOCATE A BUFFERED I/O BUFFER. IF SUFFICIENT
; MEMORY IS NOT AVAILABLE, THEN A RESOURCE WAIT STATE IS CONDITIONALLY
; ENTERED DEPENDING ON THE CURRENT PROCESS' RESOURCE WAIT MODE.
;
; EXE$ALLOCCEB - ALLOCATE COMMON EVENT BLOCK AND CONDITIONALLY WAIT
;
; THIS ROUTINE IS CALLED TO ALLOCATE A COMMON EVENT BLOCK. IF SUFFICIENT
; MEMORY IS NOT AVAILABLE, THEN A RESOURCE WAIT STATE IS CONDITIONALLY
; ENTERED DEPENDING ON THE CURRENT PROCESS' RESOURCE WAIT MODE.
;
; EXE$ALLOCJIB - ALLOCATE JOB INFORMATION BLOCK AND CONDITIONALLY WAIT
;
; THIS ROUTINE IS CALLED TO ALLOCATE A JOB INFORMATION BLOCK. IF SUFFICIENT 
; MEMORY IS NOT AVAILABLE, THEN A RESOURCE WAIT STATE IS CONDITIONALLY ENTERED
; DEPENDING ON THE CURRENT PROCESS' RESOURCE WAIT MODE.
;
; EXE$ALLOCIRP - ALLOCATE I/O REQUEST PACKET AND CONDITIONALLY WAIT
;
; THIS ROUTINE IS CALLED TO ALLOCATE AN I/O PACKET. IF SUFFICIENT MEMORY
; IS NOT AVAILABLE, THEN A RESOURCE WAIT STATE IS CONDITIONALLY ENTERED
; DEPENDING ON THE CURRENT PROCESS' RESOURCE WAIT MODE.
;
; EXE$ALLOCPCB - ALLOCATE PROCESS CONTROL BLOCK AND CONDITIONALLY WAIT
;
; THIS ROUTINE IS CALLED TO ALLOCATE A PROCESS CONTROL BLOCK WHEN
; CREATING A NEW PROCESS.  IF SUFFICIENT MEMORY IS NOT AVAILABLE, THEN
; A RESOURCE WAIT STATE IS CONDITIONALLY ENTERED DEPENDING ON THE CURRENT
; PROCESS' RESOURCE WAIT MODE.
;
; EXE$ALLOCPQB - ALLOCATE PROCESS QUOTA BLOCK AND CONDITIONALLY WAIT
;
; THIS ROUTINE IS CALLED TO ALLOCATE A PROCESS QUOTA BLOCK WHEN CREATING
; A NEW PROCESS.  IF SUFFICIENT MEMORY IS NOT AVAILABLE, THEN A RESOURCE
; WAIT STATE IS ENTERED DEPENDING ON THE CURRENT PROCESS' RESOURCE WAIT
; MODE.
;
; EXE$ALLOCTQE - ALLOCATE TIME QUEUE ENTRY AND CONDITIONALLY WAIT
;
; THIS ROUTINE IS CALLED TO ALLOCATE A TIME QUEUE ENTRY. IF SUFFICIENT
; MEMORY IS NOT AVAILABLE, THEN A RESOURCE WAIT STATE IS CONDITIONALLY
; ENTERED DEPENDING ON THE CURRENT PROCESS' RESOURCE WAIT MODE.
;
; INPUTS:
;
;	R4 = NORMALLY CURRENT PROCESS PCB ADDRESS, BUT NOT REQUIRED.
;
; IF ENTRY AT EXE$ALLOCBUF, THEN
;
;	R1 = SIZE OF REQUESTED BUFFER IN BYTES.
;
; OUTPUTS:
;
;	R0 = LOW BIT CLEAR IF ALLOCATION FAILURE WITH CALLING IPL PRESERVED.
;
;		R0 = SS$_INSFMEM = INSUFFICIENT MEMORY AVAILABLE TO ALLOCATE
;			BUFFER.
;
;	R0 = LOW BIT SET IF SUCCESSFUL ALLOCATION WITH:
;
;		R1 = SIZE OF REQUESTED BUFFER IN BYTES.
;		R2 = ADDRESS OF ALLOCATED BUFFER WITH SIZE AND TYPE FIELDS
;			FILLED IN.
;
;		AND IPL SET TO AST DELIVERY LEVEL.
;
;	R4 = ORIGINAL R4 OR CURRENT PCB IF A WAIT OCCURRED.
;-
 
	.ENABL	LSB
EXE$ALLOCCEB::				;ALLOCATE COMMON EVENT BLOCK
	PUSHL	#DYN$C_CEB		;SET DATA STRUCTURE TYPE
	ASSUME	CEB$C_SLAVLNG GT CEB$C_LENGTH
	MOVZWL	#<CEB$C_SLAVLNG+MASK>&<^C<MASK>>,R1 ;AND LENGTH OF BLOCK
	BRB	20$			;
EXE$ALLOCJIB::				;ALLOCATE JOB INFORMATION BLOCK - COND WAIT
	PUSHL	#DYN$C_JIB		;SET STRUCTURE TYPE
	MOVZWL	#<JIB$C_LENGTH+MASK>&<^C<MASK>>,R1 ;AND LENGTH OF BLOCK
	BRB	20$			;MERGE WITH COMMON ALLOCATE CODE
EXE$ALLOCIRP::				;ALLOCATE I/O PACKET - CONDITIONAL WAIT
	PUSHL	#DYN$C_IRP		;SET DATA STRUCTURE TYPE
	MOVZBL	#<IRP$C_LENGTH+MASK>&<^C<MASK>>,R1 ;SET SIZE OF BUFFER REQUIRED
	BRB	20$			;
EXE$ALLOCPCB::				;ALLOCATE PROCESS CONTROL BLOCK
	PUSHL	#DYN$C_PCB		;SET DATA STRUCTURE TYPE
	MOVZWL	#<PCB$C_LENGTH+MASK>&<^C<MASK>>,R1 ;AND STRUCTURE SIZE
	BRB	20$			;
EXE$ALLOCTQE::				;ALLOCATE TIME QUEUE ENTRY
	PUSHL	#DYN$C_TQE		;SET DATA STRUCTURE TYPE
	MOVZBL	#<TQE$C_LENGTH+MASK>&<^C<MASK>>,R1 ;SET SIZE OF BUFFER REQUIRED
20$:	MOVPSL	-(SP)			;READ CURRENT PSL
	DSBINT	#IPL$_SYNCH		;SYNCHRONIZE ACCESS TO SYSTEM DATA BASE
	PUSHL	R1			;SAVE REQUEST SIZE
	BSBW	EXE$ALONONPAGED		;ATTEMPT TO ALLOCATE PACKET
	POPR	#^M<R1,R3>		;RETRIEVE REQUEST SIZE AND PREVIOUS IPL
	BLBC	R0,40$			;IF LBC NO PACKET ALLOCATED
	MOVW	R1,IRP$W_SIZE(R2)	;INSERT SIZE OF ALLOCATED BLOCK
	MOVZBW	4(SP),IRP$B_TYPE(R2)	;INSERT DATA STRUCTURE TYPE
					;AND CLEAR MISCELLANEOUS BYTE
	MOVZWL	#IPL$_ASTDEL,R3		;SET TO RAISE TO AST DELIVERY LEVEL
30$:	ENBINT	R3			;ALLOW INTERRUPTS
	ADDL	#8,SP			;REMOVE PSL AND STRUCTURE TYPE FROM STACK
	RSB				;
40$:	MOVL	L^SCH$GL_CURPCB,R4	;FORCE CURRENT PCB ADDRESS
	BBS	#PCB$V_SSRWAIT,PCB$L_STS(R4),30$ ;IF SET, NO WAIT
	MOVZWL	#RSN$_NPDYNMEM,R0	;SET NONPAGED DYNAMIC MEMORY RESOURCE NUMBER
	BSBW	SCH$RWAIT		;WAIT FOR NONPAGED MEMORY
	BRB	20$			;
;
;
; This routine is optimized due to heavy useage
;
EXE$ALLOCBUF::				;ALLOCATE BUFFERED I/O BUFFER
	MOVPSL	-(SP)			;READ CURRENT PSL
	MTPR	#IPL$_SYNCH,#PR$_IPL	;SYNCHRONIZE ACCESS TO SYSTEM DATA BASE
	MOVL	R1,R3			;SAVE REQUEST SIZE
	BSBW	EXE$ALONONPAGED		;ATTEMPT TO ALLOCATE PACKET
	MOVL	R3,R1			;RETRIEVE REQUEST SIZE 
	BLBC	R0,50$			;IF LBC NO PACKET ALLOCATED
	MOVW	R1,IRP$W_SIZE(R2)	;INSERT SIZE OF ALLOCATED BLOCK
	MOVW	#DYN$C_BUFIO,IRP$B_TYPE(R2) ;INSERT DATA STRUCTURE TYPE
					;AND CLEAR MISCELLANEOUS BYTE
	MTPR	#IPL$_ASTDEL,#PR$_IPL	;ALLOW INTERRUPTS
	ADDL	#4,SP			;REMOVE PSL FROM STACK
	RSB
;
50$:	MOVL	(SP)+,R3		;TEMPORARILY RETRIEVE PSL
	PUSHL	#DYN$C_BUFIO		;CONDITIONS FOR GENERAL ROUTINE
	PUSHL	R3			;PUT PSL BACK ON STACK
	ASHL	#-PSL$V_IPL,R3,R3	;IPL
	BRB	40$			;CONTINUE THE SLOW WAY

	.DSABL	LSB
	.PAGE
	.SBTTL	EXE$ALONPAGWAIT - ALLOCATE MEMORY AND WAIT IN CALLER'S MODE
;+
; EXE$ALONPAGWAIT - ALLOCATE NON-PAGED MEMORY AND OPTIONALLY WAIT IN CALLER'S
;		    ACCESS MODE.
;
; THIS ROUTINE IS CALLED TO ALLOCATE NON-PAGED MEMORY.  IF SUFFICIENT
; MEMORY IS NOT AVAILABLE, THEN THE PROCESS IS PLACED IN A RESOURCE
; WAIT STATE IF RESOURCE WAIT MODE IS ENABLED.  OTHERWISE, AN ERROR IS
; RETURNED.  THIS ROUTINE IS INTENDED TO BE CALLED BY SYSTEM SERVICES
; THAT NEED TO ALLOCATE NON-PAGED POOL.  IF IT IS NECESSARY TO WAIT, THE
; STACK IS TRIMMED BACK TO WAIT IN THE MODE OF THE (SYSTEM SERVICE) CALLER.
; WHEN THE PROCESS IS RESUMED, IT RESUMES AT THE BEGINNING OF THE SYSTEM
; SERVICE.  AS A RESULT OF THIS INTERFACE, IT IS NECESSARY TO PROVIDE A
; WAY FOR THE SYSTEM SERVICE TO PERFORM ANY NECESSARY CLEANUP BEFORE
; BEING PLACED IN THE WAIT STATE.  THIS IS PROVIDED BY ALLOWING THE 
; SYSTEM SERVICE TO SPECIFY AN OPTIONAL CLEANUP ROUTINE TO BE CALLED
; PRIOR TO PLACING THE PROCESS IN A WAIT STATE.
;
; INPUTS:
;
;	R0 = ADDRESS OF CLEANUP ROUTINE (0 INDICATES NO ROUTINE)
;	R1 = SIZE OF BUFFER REQUIRED (IN BYTES)
;
;	IPL MUST BE AT IPL$_ASTDEL OR LOWER (ENTRY POINT EXE$ALONPAGWAIT)
;	IPL MUST BE AT IPL$_SYNCH (ENTRY POINT EXE$ALONPAGWAITS)
;
; OUTPUTS:
;
;	R0 = SS$_INSFMEM IF ALLOCATION FAILURE AND RESOURCE WAIT MODE
;	     DISABLED.  IPL IS AT IPL$_ASTDEL (BOTH ENTRY POINTS).
;
;	   = LOW BIT SET IF SUCCESSFUL ALLOCATION.  
;	     IPL IS AT IPL$_ASTDEL (ENTRY POINT EXE$ALONPAGWAIT).
;	     IPL IS AT IPL$_SYNCH (ENTRY POINT EXE$ALONPAGWAITS).
;
;	R1 = SIZE OF ALLOCATED BUFFER
;
;	R2 = ADDRESS OF ALLOCATED BUFFER
;
;	R4 = ORIGINAL R4 IF ALLOCATION WAS SUCCESSFUL.
;
;	   = CURRENT PROCESS PCB ADDRESS IF ALLOCATION FAILURE AND RESOURCE
;	     WAIT MODE DISABLED.
;
; NOTES:
;
;	THE CLEANUP ROUTINE IS CALLED AT IPL$_SYNCH (THEREFORE IT
;	MUST BE NON-PAGEABLE).
;-

	.ENABL	LSB

EXE$ALONPAGWAITS::
	PUSHL	R0			; SAVE ADDRESS OF CLEANUP ROUTINE
	BSBB	EXE$ALONONPAGED		; TRY TO ALLOCATE THE MEMORY
	BLBS	R0,10$			; SKIP NEXT IF SUCCESSFUL
	BSBB	RWAIT_CHECK_NP		; CHECK FOR RESOURCE WAIT
10$:	ADDL	#4,SP			; REMOVE ADDRESS OF CLEANUP ROUTINE
	RSB				; RETURN

EXE$ALONPAGWAIT::
	PUSHL	R0			; SAVE ADDRESS OF CLEANUP ROUTINE
	SETIPL	#IPL$_SYNCH		; RAISE IPL TO SYNCH
	BSBB	EXE$ALONONPAGED		; TRY TO ALLOCATE THE MEMORY
	BLBS	R0,20$			; FAILED TO ALLOCATE IT
	BSBB	RWAIT_CHECK_NP		; CHECK FOR RESOURCE WAIT
20$:	SETIPL	#IPL$_ASTDEL		; LOWER IPL TO ASTDEL
	ADDL	#4,SP			; REMOVE ADDRESS OF CLEANUP ROUTINE
	RSB				; RETURN

EXE$ALOPAGWAIT::
	PUSHL	R0			; SAVE ADDRESS OF CLEANUP ROUTINE
	BSBW	EXE$ALOPAGED		; TRY TO ALLOCATE THE MEMORY
	BLBS	R0,30$			; FAILED TO ALLOCATE IT
	BSBB	RWAIT_CHECK_PAG		; CHECK FOR RESOURCE WAIT
30$:	ADDL	#4,SP			; REMOVE ADDRESS OF CLEANUP ROUTINE
	RSB				; RETURN

; ALLOCATION FAILED. IF RESOURCE WAIT MODE IS ENABLED THEN REMOVE CALL
; FRAME FROM STACK AND WAIT IN CALLER'S MODE. OTHERWISE, RETURN ERROR. 

RWAIT_CHECK_PAG:
	PUSHL	#RSN$_PGDYNMEM		; STORE RESOURCE NUMBER
	BRB	40$			; JOIN COMMON CODE

RWAIT_CHECK_NP:

	PUSHL	#RSN$_NPDYNMEM		; STORE RESOURCE NUMBER
40$:	MOVL	L^SCH$GL_CURPCB,R4	; GET CURRENT PROCESS PCB ADDRESS
	BBS	#PCB$V_SSRWAIT,PCB$L_STS(R4),30$  ; BRANCH IF NOT WAITING
	MOVL	8(SP),R0		; GET ADDRESS OF CLEANUP ROUTINE
	BEQL	50$			; NO CLEANUP ROUTINE
	JSB	(R0)			; CALL CLEANUP ROUTINE
50$:	POPL	R0			; GET RESOURCE NUMBER
	MOVL	FP,SP			; TRIM STACK BACK TO START OF FRAME
	MOVQ	8(SP),AP		; RESTORE PRE-CALL AP AND FP
	ADDL	S^#EXE$C_CMSTKSZ,SP	; CLEAN CALL FRAME OFF STACK
	SUBL	#4,(SP)			; BACK UP SAVED PC TO POINT TO CHMK
	BRW	SCH$RWAIT		; WAIT FOR RESOURCE

	.DSABL	LSB
	.PAGE
	.SBTTL	ALLOCATE NONPAGED DYNAMIC MEMORY
;+
; EXE$ALONONPAGED - ALLOCATE NONPAGED DYNAMIC MEMORY
;
; EXE$ALONPAGVAR  - ALLOCATE NONPAGED DYNAMIC MEMORY FROM VARIABLE AREA ONLY
;
; THIS ROUTINE IS CALLED TO ALLOCATE A BLOCK OF MEMORY FROM THE NONPAGED POOL.
; IF THE BLOCK IS THE SAME SIZE AS AN I/O PACKET, AN ATTEMPT IS MADE TO ALLO-
; CATE IT FROM THE LOOKASIDE LIST.
;
; INPUTS:
;
;	R1 = SIZE OF BLOCK REQUIRED IN BYTES.
;
; OUTPUTS:
;
;	R0 = SS$_INSFMEM IF MEMORY IS NOT AVAILABLE.
;
;	R0 = LOW BIT SET IF MEMORY ALLOCATED WITH:
;
;		R1 = SIZE OF ALLOCATED BLOCK.
;		R2 = ADDRESS OF ALLOCATED BLOCK.
;
;	OTHER REGISTERS PRESERVED
;-
 
	.ENABL	LSB
200$:	BRW	20$			;BAD ALLOCATION REQUEST
EXE$ALONONPAGED::			;ALLOCATE NONPAGED MEMORY
	CMPL	#<IRP$C_LENGTH+MASK>&<^C<MASK>>,R1 ;SIZE GREATER THAN IRP ?
	BLSSU	LRP			;IF LSSU, YES
	CMPL	R1, L^IOC$GL_IRPMIN	;IS THE BLOCK TOO SMALL?
	BLSSU	SRP			;YES, TRY SMALL PACKETS
	REMQUE	@L^IOC$GL_IRPFL,R2	;REMOVE FIRST PACKET FROM LOOK ASIDE LIST
	BVS	LISTCHK			;IF VS EMPTY LIST
	MOVL	#SS$_NORMAL,R0		;SET SUCCESSFUL COMPLETION
	RSB				;

LRP:	CMPL	L^IOC$GL_LRPMIN,R1	;SIZE LESS THAN LRP MINIMUM ?
	BGTRU	EXE$ALONPAGVAR		;IF GTRU, YES
	CMPL	L^IOC$GL_LRPSIZE,R1	;SIZE GREATER THAN LRP ?
	BLSSU	EXE$ALONPAGVAR		;IF LSSU, YES
	REMQUE	@L^IOC$GL_LRPFL,R2	;REMOVE FIRST PACEKT FROM LRP LIST
	BVS	LISTCHK			;IF VS, EMPTY LIS
	MOVL	#SS$_NORMAL,R0
	RSB
LISTCHK:
	BSBW	EXE$EXTENDPOOL		;ATTEMPT TO EXTEND POOL
	BLBS	R0,EXE$ALONONPAGED	;RETRY LISTS IF SOMETHING EXTENDED
EXE$ALONPAGVAR::
	ADDL	#MASK,R1		;ROUND SIZE UP TO NEXT BOUNDRY
	BICL	#MASK,R1		;TRUNCATE SIZE BACK TO MULTIPLE
	BEQL	200$			;IF EQL BAD ALLOCATION REQUEST
	PUSHL	R3			;SAVE R3
	MOVAB	W^EXE$GL_NONPAGED,R3	;GET ADDRESS OF NONPAGED MEMORY LISTHEAD
	DSBINT	(R3)+			;DISABLE INTERRUPTS
	BSBB	EXE$ALLOCATE		;ALLOCATE BLOCK
	ENBINT				;ENABLE INTERRUPTS
	POPL	R3			;RESTORE R3
	BLBC	R0,EXTENDCHK		;BR IF FAILURE
	RSB				;
EXTENDCHK:				;CHECK FOR POOL EXTENSION
	BISL	#1,W^MMG$GL_NPAGNEXT	;SET FLAG FOR EXTENSION
	BSBW	EXE$EXTENDPOOL		;ATTEMPT TO EXTEND POOL
	BLBS	R0,EXE$ALONONPAGED	;AND REPEAT ALLOCATION ATTEMPT
	MOVZWL	#SS$_INSFMEM,R0		;SET INSUFFICIENT MEMORY
	RSB				;

SRP:	CMPL	R1,L^IOC$GL_SRPSIZE	;CHECK FOR FIT IN SMALL PACKETS
	BGTRU	EXE$ALONPAGVAR		;MUST USE VARIABLE POOL
;	CMPL	R1,L^IOC$GL_SRPMIN	;CHECK FOR LOWER BOUND
;	BLSSU	EXE$ALONPAGVAR		;MUST USE VARIABLE POOL
	TSTL	R1
	BNEQ	10$			;VALID SIZE
	BRW	200$			;INVALID SIZE
10$:	REMQUE	@L^IOC$GL_SRPFL,R2	;REMOVE FIRST PACEKT FROM SRP LIST
	BVS	LISTCHK			;IF VS, EMPTY LIST
	MOVL	#SS$_NORMAL,R0		;
	RSB				;

	.PAGE
	.SBTTL	ALLOCATE PAGED DYNAMIC MEMORY
;+
; EXE$ALOPAGED - ALLOCATE PAGED DYNAMIC MEMORY
;
; THIS ROUTINE IS CALLED TO ALLOCATE A BLOCK OF MEMORY FROM THE PAGED POOL.
;
; INPUTS:
;
;	R1 = SIZE OF BLOCK REQUIRED IN BYTES.
;
; OUTPUTS:
;
;	R0 = LOW BIT CLEAR IF MEMORY IS NOT AVAILABLE.
;
;	R0 = LOW BIT SET IF MEMORY ALLOCATED WITH:
;
;		R1 = SIZE OF ALLOCATED BLOCK.
;		R2 = ADDRESS OF ALLOCATED BLOCK.
;-
 
EXE$ALOPAGED::				;ALLOCATE PAGED DYNAMIC MEMORY
	ADDL	#MASK,R1		;ROUND SIZE UP TO NEXT BOUNDRY
	BICL	#MASK,R1		;TRUNCATE SIZE BACK TO MULTIPLE
	BEQL	20$			;IF EQL BAD ALLOCATION REQUEST
	SAVIPL				;SAVE CURRENT IPL
	PUSHL	R4			;SAVE REGISTER
	MOVAB	W^EXE$GL_PGDYNMTX,R0	;GET ADDRESS OF PAGED MEMORY MUTEX
	MOVL	L^SCH$GL_CURPCB,R4	;GET CURRENT PROCESS PCB ADDRESS
	BSBW	SCH$LOCKW		;LOCK PAGED MEMORY DATA BASE FOR WRITE
	MOVAB	W^EXE$GL_PAGED,R3	;GET ADDRESS OF PAGED MEMORY LISTHEAD
	BSBB	EXE$ALLOCATE		;ALLOCATE BLOCK
	PUSHR	#^M<R0,R1,R2>		;SAVE REGISTERS
	MOVAB	W^EXE$GL_PGDYNMTX,R0	;GET ADDRESS OF PAGED MEMORY MUTEX
	BSBW	SCH$UNLOCK		;UNLOCK PAGED MEMORY DATA BASE
	POPR	#^M<R0,R1,R2,R4>	;RESTORE REGISTERS
	ENBINT				;ENABLE INTERRUPTS
	RSB				;
20$:	BUG_CHECK BADALORQSZ		;BAD ALLOCATION REQUEST SIZE
	CLRL	R0			;INDICATE NO BLOCK ALLOCATED
	RSB				;
	.DSABL	LSB
	.PAGE
	.SBTTL	GENERAL ALLOCATE MEMORY SUBROUTINE
;+
; EXE$ALLOCATE - ALLOCATE MEMORY SUBROUTINE
;
; THIS ROUTINE IS CALLED TO ALLOCATE A BLOCK OF MEMORY FROM A POOL WHOSE ENTRIES
; ARE MAINTAINED IN A MEMORY ORDER SORTED LIST.
;
; INPUTS:
;
;	R1 = SIZE OF BLOCK REQUIRED IN BYTES.
;	R3 = ADDRESS OF ALLOCATION REGION LISTHEAD.
;
; OUTPUTS:
;
;	R0 = LOW BIT CLEAR IF MEMORY IS NOT AVAILABLE.
;
;		R2 = 0 (USED TO BE THE SIZE OF LARGEST BLOCK FOUND)
;
;	R0 = LOW BIT SET IF MEMORY ALLOCATED WITH:
;
;		R1 = SIZE OF ALLOCATED BLOCK.
;		R2 = ADDRESS OF ALLOCATED BLOCK.
;-

EXE$ALLOCATE::				;ALLOCATE MEMORY
	MOVL	R3,R0			;COPY ADDRESS OF FIRST FREE BLOCK ADDRESS
10$:	MOVL	R0,R2			;SAVE ADDRESS OF PREVIOUS FREE BLOCK
	MOVL	(R2),R0			;GET ADDRESS OF NEXT FREE BLOCK
	BEQL	30$			;IF EQL NO MEMORY AVAILABLE
	CMPL	R1,4(R0)		;FREE BLOCK BIG ENOUGH?
	BGTRU	10$			;IF GTRU NO
	BEQL	20$			;IF EQL FREE BLOCK IS EXACT SIZE
	ADDL3	R0,R1,R3		;CALCULATE ADDRESS OF NEW FREE BLOCK
	MOVL	(R0)+,(R3)+		;COPY LINK TO NEXT FREE BLOCK
	SUBL3	R1,(R0),(R3)		;CALCULATE SIZE OF NEW FREE BLOCK
	MOVAL	-(R3),-(R0)		;SET LINK TO NEW FREE BLOCK
20$:	MOVL	(R0),(R2)		;COPY LINK TO NEW FREE BLOCK
	MOVAB	(R0)+,R2		;SET ADR OF ALLOCATED BLOCK, INDICATE SUCCESS
	RSB				;RETURN
;
; NO BLOCK OF THE REQUIRED SIZE COULD BE FOUND.  RETURN 0 IN R2 WHERE THE LENGTH OF
; THE LARGEST FREE BLOCK USED TO GO.
;
30$:	CLRL	R2			;INITIAL VALUE OF LARGEST FREE BLOCK SEEN
	RSB				;RETURN FAILURE
	.PAGE
	.SBTTL	DEALLOCATE NONPAGED DYNAMIC MEMORY
;+
; EXE$DEANONPAGED - DEALLOCATE NONPAGED DYNAMIC MEMORY
;
; THIS ROUTINE IS CALLED TO DEALLOCATE A BLOCK OF MEMORY TO A NONPAGED POOL.
; IF THE BLOCK IS A SHARED MEMORY BLOCK TYPE, THE BLOCK IS DEALLOCATED TO
; THE SHARED MEMORY POOL.  OTHERWISE, THE BLOCK'S ADDRESS IS CHECKED TO SEE
; IF IT WAS ALLOCATED FROM THE I/O PACKET LOOKASIDE LIST AND IF SO,
; IT IS RETURNED TO THAT LIST.  OTHERWISE IT IS MERGED INTO THE NORMAL
; NONPAGED POOL.
;
; INPUT:
;
;	IF ENTRY IS AT EXE$DEANONPAGED
;
;		R0 = ADDRESS OF BLOCK TO BE DEALLOCATED.
;		IRP$W_SIZE(R0) = SIZE OF BLOCK TO BE DEALLOCATED.
;		IRP$B_TYPE(R0) = TYPE OF BLOCK TO BE DEALLOCATED.
;
;	IF ENTRY IS AT EXE$DEANONPAGED_SIZE
;
;		R0 = ADDRESS OF BLOCK TO BE DEALLOCATED.
;		R1 = SIZE OF BLOCK TO BE DEALLOCATED (ASSUMED NONZERO)
;
; OUTPUTS:
;
;	THE SPECIFIED BLOCK IS RETURNED TO THE APPROPRIATE POOL.
;-
 
	.ENABL	LSB
EXE$DEANONPAGED::			;DEALLOCATE NONPAGED DYNAMIC MEMORY
	TSTB	IRP$B_TYPE(R0)		;IS BLOCK A SHARED MEMORY BLOCK?
	BGEQ	5$			;IF GEQ NO
	BRW	EXE$DEASHARED		;ELSE, DEALLOCATE IT

5$:	MOVZWL	IRP$W_SIZE(R0),R1	;GET SIZE OF BLOCK IN BYTES

EXE$DEANONPGDSIZ::			;DEALLOCATE NONPAGED DYNAMIC MEMORY
	BITL	#MASK,R0		;CHECK PACKET ALIGNMENT
	BNEQ	15$			;BRANCH ON ERROR -- LET STD. RTN HANDLE IT
	CMPL	R0,L^IOC$GL_SRPSPLIT	;SMALL REQUEST PACKET?
	BLSSU	8$			;BR IF NOT
	INSQUE	(R0),@L^IOC$GL_SRPBL	;INSERT NEW PACKET AT END OF LIST
	BEQL	20$			;BRANCH IF LIST WAS EMPTY, DECLARE RES. AVL.
	RSB				;RSB

8$:	CMPL	R0,W^EXE$GL_SPLITADR	;I/O REQUEST PACKET
	BLSSU	10$			;IF LSSU NO
	INSQUE	(R0),@L^IOC$GL_IRPBL	;INSERT NEW PACKET AT END OF LIST
	BEQL	20$			;BRANCH IF LIST WAS EMPTY, DECLARE RES. AVL.
	RSB				;RETURN

10$:	CMPL	R0,L^IOC$GL_LRPSPLIT	;LARGE REQUEST PACKET
	BLSSU	15$			;IF LSSU, NO
	INSQUE	(R0),@L^IOC$GL_LRPBL	;INSERT NEW PACKET AT END OF LIST
	BEQL	20$			;BRANCH IF LIST WAS EMPTY, DECLARE RES. AVL.
	RSB				;RETURN

15$:	BSBB	CHECKBLOCK		;CHECK DEALLOCATION PARAMETERS
	MOVAB	W^EXE$GL_NONPAGED,R3	;GET ADDRESS OF NONPAGED MEMORY LISTHEAD
	DSBINT	(R3)+			;DISABLE INTERRUPTS
	BSBB	EXE$DEALLOCATE		;DEALLOCATE BLOCK
	BRB	25$			;BRANCH TO DECLARE FREE RESOURCE

20$:	DSBINT	#IPL$_SYNCH		;NEED TO ENTER SCH$RAVAIL AT IPL$_SYNC
25$:	MOVZWL	#RSN$_NPDYNMEM,R0	;SET NONPAGED DYNAMIC MEMORY RESOURCE NUMBER
	BRB	30$			;
	.PAGE
	.SBTTL	DEALLOCATE PAGED DYNAMIC MEMORY
;+
; EXE$DEAPAGED - DEALLOCATE PAGED DYNAMIC MEMORY
;
; THIS ROUTINE IS CALLED TO DEALLOCATE A BLOCK OF MEMORY TO THE PAGED POOL.
;
; INPUTS:
;
;	IF ENTRY IS AT EXE$DEAPAGED
;
;		R0 = ADDRESS OF BLOCK TO BE DEALLOCATED.
;		IRP$W_SIZE(R0) = SIZE OF BLOCK TO BE DEALLOCATED.
;
;	IF ENTRY IS AT EXE$DEAPGDSIZ
;
;		R0 = ADDRESS OF BLOCK TO BE DEALLOCATED.
;		R1 = SIZE OF BLOCK TO BE DEALLOCATED (ASSUMED NONZERO).
;
; OUTPUTS:
;
;	THE SPECIFIED BLOCK OF MEMORY IS RETURNED TO THE PAGED POOL.
;-
 
EXE$DEAPAGED::				;DEALLOCATE PAGED DYNAMIC MEMORY
	MOVZWL	IRP$W_SIZE(R0),R1	;GET SIZE OF BLOCK IN BYTES

EXE$DEAPGDSIZ::
	BSBB	CHECKBLOCK		;CHECK DEALLOCATION PARAMETERS
	SAVIPL				;SAVE CURRENT IPL
	PUSHR	#^M<R0,R4>		;SAVE REGISTERS
	MOVAB	W^EXE$GL_PGDYNMTX,R0	;GET ADDRESS OF PAGED MEMORY MUTEX
	MOVL	L^SCH$GL_CURPCB,R4	;GET CURRENT PROCESS PCB ADDRESS
	BSBW	SCH$LOCKW		;LOCK PAGED MEMORY DATA BASE FOR WRITE
	POPL	R0			;RESTORE REGISTER
	MOVAB	W^EXE$GL_PAGED,R3	;GET ADDRESS OF PAGED MEMORY LISTHEAD
	BSBB	EXE$DEALLOCATE		;DEALLOCATE BLOCK
	MOVAB	W^EXE$GL_PGDYNMTX,R0	;GET ADDRESS OF PAGED MEMORY MUTEX
	BSBW	SCH$UNLOCK		;UNLOCK PAGED MEMORY DATA BASE
	POPL	R4			;RESTORE REGISTER
	MOVZWL	#RSN$_PGDYNMEM,R0	;SET PAGED DYNAMIC MEMORY RESOURCE NUMBER
30$:	BSBW	SCH$RAVAIL		;MARK RESOURCE AVAILABLE
	ENBINT				;ENABLE INTERRUPTS
	RSB				;
	.DSABL	LSB
	.PAGE
	.SBTTL	CHECK BLOCK PARAMETERS SUBROUTINE
;
; CHECKBLOCK - CHECK BLOCK PARAMETERS SUBROUTINE
;
; INPUT PARAMETERS:
;
;	R0 = ADDRESS OF BLOCK TO BE DEALLOCATED
;	R1 = SIZE OF BLOCK TO BE DEALLOCATED
;
; OUTPUT PARAMETER:
; 
;	R1 = MODIFIED SIZE OF BLOCK TO BE DEALLOCATED
;	     (SIZE IS ROUNDED UP TO NEXT MULTIPLE OF QUANTUM OF ALLOCATION)
;
 
CHECKBLOCK:				;CHECK BLOCK PARAMETERS
	BITL	#MASK,R0		;BLOCK ALIGNED ON BOUNDRY?
	BNEQ	10$			;IF NEQ NO - BAD DEALLOCATION
	ADDL	#MASK,R1		;ROUND SIZE UP TO NEXT BOUNDRY
	BICL	#MASK,R1		;TRUNCATE SIZE BACK TO MULTIPLE
	BNEQ	20$			;IF NEQ OKAY
10$:	BUG_CHECK BADDALRQSZ		;BAD DEALLOCATION REQUEST SIZE OR ADDRESS
	TSTL	(SP)+			;REMOVE RETURN FROM STACK
20$:	RSB				;
	.PAGE
	.SBTTL	GENERAL DEALLOCATION SUBROUTINE
;+
; EXE$DEALLOCATE - DEALLOCATION SUBROUTINE
;
; INPUTS:
;
;	R0 = ADDRESS OF BLOCK TO BE DEALLOCATED.
;	R1 = SIZE OF BLOCK IN BYTES
;	R3 = ADDRESS OF ALLOCATION REGION LISTHEAD.
;
; OUTPUTS:
;
;	NONE
;-

EXE$DEALLOCATE::			;DEALLOCATE BLOCK
	PUSHL	R4			;SAVE REGISTERS
	PUSHL	R3
10$:	MOVL	R3,R2			;SAVE ADDRESS OF PREVIOUS FREE BLOCK
	MOVL	(R2),R3			;GET ADDRESS OF NEXT FREE BLOCK
	BEQL	20$			;IF EQL END OF LIST
	CMPL	R0,R3			;BLOCK LOGICALLY GO HERE?
	BGTRU	10$			;IF GTRU NO
	BEQLU	50$			;IF EQLU DOUBLE DEALLOCATION
20$:	MOVL	R3,(R0)			;ASSUME NO AGGLOMERATION
	BEQL	30$			;END OF LIST - NO AGGLOMERATION
	ADDL3	R0,R1,R4		;CALCULATE ADDRESS OF END OF BLOCK
	CMPL	R3,R4			;END OF BLOCK EQUAL TO NEXT IN LIST?
	BGTRU	30$			;IF GTR DO NOT AGGLOMERATE
	BLSSU	50$			;IF LSS OVERLAPPING DEALLOCATE
	MOVL	(R3)+,(R0)		;MOVE LINK TO BLOCK BEING RELEASED
	ADDL	(R3),R1			;ACCUMULATE LENGTH OF NEW FREE BLOCK
30$:	MOVL	R2,R4			;CALCULATE ENDING ADDRESS OF PREVIOUS BLOCK
	MOVL	R0,(R2)+		;ASSUME NO AGGLOMERATION
	ADDL	(R2),R4			;ADD LENGTH TO BLOCK BASE ADDRESS
	CMPL	R0,R4			;END ADDRESS EQUAL TO BLOCK BEING RELEASED?
	BGTRU	40$			;IF GTR DO NOT AGGLOMERATE
	BLSSU	45$			;IF LSS MAY BE OVERLAPPING DEALLOCATE
	ADDL	(R2),R1			;ACCUMULATE SIZE OF NEW FREE BLOCK
	MOVL	(R0),-(R2)		;MOVE LINK TO PREVIOUS FREE BLOCK
	MOVL	R2,R0			;SET ADDRESS OF NEW FREE BLOCK
40$:	MOVL	R1,4(R0)		;SET SIZE OF FREE BLOCK
	MOVQ	(SP)+,R3		;RESTORE REGISTERS
	RSB

45$:	; IF WE COME HERE IT IS EITHER AN OVERLAPPING DEALLOCATE OR R2
	; (THE PREVIOUS BLOCK POINTER) IS POINTING TO THE LIST HEAD.

	SUBL	#4,R2			;BACK UP R2
	CMPL	R2,(SP)			;IS IT POINTING TO THE LIST HEAD?
	BEQL	40$			;YES, RESUME IN NORMAL PATH

50$:	BUG_CHECK DOUBLDEALO,FATAL	;DOUBLE DEALLOCATION OF MEMORY BLOCK

	.PAGE
	.SBTTL	ALLOCATE A BLOCK OF SHARED MEMORY POOL
;+
; EXE$ALOSHARED - ALLOCATE A BLOCK OF SHARED MEMORY POOL
;
; THIS ROUTINE IS CALLED TO ALLOCATE A BLOCK OF MEMORY FROM THE
; SHARED MEMORY POOL.
;
; INPUTS:
;
;	R2 = ADDRESS OF SHARED MEMORY CONTROL BLOCK (SHB).
;
; OUTPUTS:
;
;	R0 = LOW BIT CLEAR IF MEMORY IS NOT AVAILABLE.
;
;	R0 = LOW BIT SET IF MEMORY ALLOCATED WITH:
;
;		R1 = SIZE OF ALLOCATED BLOCK.
;		R2 = ADDRESS OF ALLOCATED BLOCK.
;-
 
EXE$ALOSHARED::				;ALLOCATE SHARED MEMORY POOL
	MOVL	SHB$L_DATAPAGE(R2),R0	;GET ADDRESS OF DATA PAGE
					;(PAGE ALIGNED SO LOW BIT CLEAR)
	CLRL	R1			;INIT RETRY COUNT

10$:	REMQHI	SHD$Q_POOL(R0),R2	;REMOVE A BLOCK FROM POOL
	BCS	30$			;BR IF QUEUE LOCKED - RETRY
	BVS	20$			;BR IF NO ENTRY - FAILURE
	MOVZWL	IRP$W_SIZE(R2),R1	;GET SIZE OF BLOCK
	INCL	R0			;SET SUCCESSFUL COMPLETION
20$:	RSB				;

30$:	AOBLEQ	W^EXE$GL_LOCKRTRY,R1,10$ ;INCREMENT RETRY COUNT AND TRY AGAIN
	RSB				;IF RETRIES EXHAUSTED, QUEUE HEADER BAD
	.PAGE
	.SBTTL	DEALLOCATE A BLOCK OF SHARED MEMORY POOL
;+
; EXE$DEASHARED - DEALLOCATE A BLOCK OF SHARED MEMORY POOL
;
; THIS ROUTINE IS CALLED TO DEALLOCATE A BLOCK OF MEMORY TO THE
; APPROPRIATE SHARED MEMORY POOL.
;
; INPUTS:
;
;	R0 = ADDRESS OF BLOCK TO BE DEALLOCATED.
;	IRP$W_SIZE(R0) = SIZE OF BLOCK TO BE DEALLOCATED.
;
; OUTPUTS:
;
;	THE SPECIFIED BLOCK IS RETURNED TO APPROPRIATE SHARED MEMORY POOL.
;
;	R0-R3 NOT PRESERVED.
;-
 
EXE$DEASHARED::				;DEALLOCATE SHARED MEMORY
	MOVZWL	IRP$W_SIZE(R0),R1	;GET SIZE OF BLOCK IN BYTES
	BSBW	CHECKBLOCK		;CHECK DEALLOCATION PARAMETERS
	MOVAL	W^EXE$GL_SHBLIST,R1	;GET ADDR OF SHARED MEMORY
					; CONTROL BLOCK LISTHEAD
	ASSUME	SHB$L_LINK EQ 0		;
10$:
	MOVL	SHB$L_LINK(R1),R1	;GET ADDR OF NEXT SHB
	BEQL	40$			;BR IF NONE - ERROR
	CMPL	R0,SHB$L_DATAPAGE(R1)	;CHECK IF BLOCK IS FROM MEMORY
	BLEQU	10$			;BR IF NOT
	CMPL	R0,SHB$L_POOLEND(R1)	;CHECK IF BLOCK IS FROM MEMORY
	BGTRU	10$			;BR IF NOT
	MOVL	SHB$L_DATAPAGE(R1),R3	;GET ADDR OF DATAPAGE
	CLRL	R2			;INIT RETRY COUNT
20$:
	INSQTI	(R0),SHD$Q_POOL(R3)	;DEALLOCATE BLOCK TO POOL
	BCC	30$			;BR IF QUEUE NOT LOCKED - SUCCESS
	AOBLEQ	W^EXE$GL_LOCKRTRY,R2,20$ ;INCREMENT RETRY COUNT AND TRY AGAIN
	BUG_CHECK BADQHDR		;IF RETRIES EXHAUSTED, QUEUE HEADER BAD
30$:	MOVZWL	#RSN$_NPDYNMEM,R0	;SET NONPAGED DYNAMIC MEMORY RESOURCE NUMBER
	BRW	MA$RAVAIL		;REPORT RESOURCE AVAILABLE AND RETURN

40$:	BUG_CHECK BADDALRQSZ		;BAD DEALLOCATION REQUEST ADDRESS
	RSB				;
	.PAGE
	.SBTTL	EXE$EXTENDPOOL - EXTEND NONPAGED POOL IF POSSIBLE
;+
; EXE$EXTENDPOOL - EXTEND NONPAGED POOL IF POSSIBLE
;
; THIS ROUTINE IS CALLED UPON A FAILURE TO ALLOCATE NON-PAGED POOL AND
; IT WILL ALLOCATE ADDITIONAL PAGES FOR ANY OF THE THREE SUBDIVISIONS
; OF NONPAGED POOL, THE IRP LIST, THE LRP LIST OR THE VARIABLE ALLOCATION
; AREA.
; 
; INPUTS:
;
;	NONE
;
; OUTPUTS:
;
;	R0 - COMPLETION STATUS 
; 
;		LOW BIT CLEAR IF NO EXTENSION PERFORMED
;-
EXE$EXTENDPOOL::
	CMPB	#31,G^EXE$GL_NONPAGED	; IS INIT RUNNING?
	BEQL	30$			; YES
	MOVPSL	R0			; GET CURRENT PSL
	CMPZV	#PSL$V_IPL, #PSL$S_IPL, - ; CHECK FOR IPL LESS THAN
		R0, #IPL$_SYNCH		  ; OR EQUAL TO IPL$_SYNCH
	BLEQU	30$			  ; CONTINUE IF IPL LOW ENOUGH
	BBC	#PSL$V_IS, R0, 30$	; ALSO CONT. IF NOT ON INTERRUPT STACK
	PUSHR	#^M<R1,R2,R3,R4,R5>	; SAVE REGISTERS DESTROYED BY FORK
	BBSS	#0,L^IOC$GL_PFKBINT,10$	; BR IF FORK BLOCK IN USE
	MOVAB	L^IOC$GL_POOLFKB,R5	; GET ADDRESS OF FORK BLOCK
	BSBB	20$			; PUSH ADDRESS OF CALLER'S CALLER
10$:	POPR	#^M<R1,R2,R3,R4,R5>	; RESTORE REGISTERS
	CLRL	R0			; INDICATE FAILURE
	RSB				; EXIT IF ON INTERRUPT STACK
20$:	BSBW	EXE$FORK		; FORK TO IPL$_QUEUEAST
;
; 	CONTINUATION IS AT IPL=IPL$_QUEUEAST (6) TO PERMIT SAFE ALLOCATION
;	OF PAGES FROM THE FREE PAGE LIST.
;
	BICL	#1,L^IOC$GL_PFKBINT	; INDICATE FORK BLOCK FREE
30$:	PUSHR	#^M<R1,R2,R3,R4,R5,R6,R7,R8,R9>	; SAVE REGISTERS
	DSBINT	L^EXE$GL_NONPAGED	; SYNCHRONIZE DATABASE
	CLRL	R5			; ASSUME FAILURE
CHECKIRP:				;
	MOVZWL	#<IRP$C_LENGTH+MASK>&<^C<MASK>>,R2 ; SIZE OF IRP
	MOVAB	W^MMG$GL_IRPNEXT,R3	; SET ADDRESS OF NEXT VA
	MOVAB	L^IOC$GL_IRPREM,R6	; ADDRESS OF PARTIAL PACKET
	MOVAB	L^IOC$GL_IRPCNT,R7	; ADDRESS OF PACKET COUNT
	MOVAB	L^IOC$GL_IRPFL,R8	; ADDRESS OF PACKET LIST
	MOVAB	W^SGN$GL_IRPCNTV,R9	; ADDRESS OF MAXIMUM COUNT
	BSBW	EXTENDLIST		; EXTEND LIST
	BISL	R0,R5			; LOGICAL OR COMPLETION STATUS
CHECKSRP:				;
	MOVL	L^IOC$GL_SRPSIZE,R2 	; SIZE OF SRP
	MOVAB	W^MMG$GL_SRPNEXT,R3	; SET ADDRESS OF NEXT VA
	MOVAB	L^IOC$GL_SRPREM,R6	; ADDRESS OF PARTIAL PACKET
	MOVAB	L^IOC$GL_SRPCNT,R7	; ADDRESS OF PACKET COUNT
	MOVAB	L^IOC$GL_SRPFL,R8	; ADDRESS OF PACKET LIST
	MOVAB	W^SGN$GL_SRPCNTV,R9	; ADDRESS OF MAXIMUM COUNT
	BSBB	EXTENDLIST		; EXTEND LIST
	BISL	R0,R5			; LOGICAL OR COMPLETION STATUS
CHECKLRP:				;
	MOVL	L^IOC$GL_LRPSIZE,R2 	; SIZE OF LRP
	MOVAB	W^MMG$GL_LRPNEXT,R3	; SET ADDRESS OF NEXT VA
	MOVAB	L^IOC$GL_LRPREM,R6	; ADDRESS OF PARTIAL PACKET
	MOVAB	L^IOC$GL_LRPCNT,R7	; ADDRESS OF PACKET COUNT
	MOVAB	L^IOC$GL_LRPFL,R8	; ADDRESS OF PACKET LIST
	MOVAB	W^SGN$GL_LRPCNTV,R9	; ADDRESS OF MAXIMUM COUNT
10$:	BSBB	EXTENDLIST		; EXTEND LIST
	BISL	R0,R5			; LOGICAL OR COMPLETION STATUS
	BLBS	R0,10$			; TRY AGAIN FOR MULTIPAGE PACKETS
CHECKVAR:				; 
;
; EXTEND VARIABLE AREA (R5 HAS LOW BIT SET IF ANY LIST WAS EXTENDED)
;
	MOVAB	W^MMG$GL_NPAGNEXT,R3	; GET ADDRESS OF NEXT VA CELL
	BLBC	(R3),90$		; BR IF VARIABLE EXTENSION NOT NEEDED
	ADDL3	W^SGN$GL_NPAGEVIR,W^MMG$GL_NPAGEDYN,R0 ; COMPUTE UPPER BOUND
	CMPL	R0,(R3)			; CHECK FOR AT LIMIT
	BLEQU	90$			; BR IF AT OR PAST LIMIT
	BSBW	EXTENDPAGE		; TRY TO ADD ANOTHER PAGE
	TSTL	R0			; CHECK STATUS
	BLSS	90$			; BR IF FAILURE
	BICL	#1,(R3)			; CLEAR FLAG
	SUBL3	#512,(R3),R0		; COMPUTE ADDRESS OF NEW SEGMENT
	MOVZWL	#512,IRP$W_SIZE(R0)	; SET SIZE
	MOVL	#1,R5			; RECORD SUCCESS STATUS
	BSBW	EXE$DEANONPAGED		; ADD NEW PAGE TO POOL
	BRB	100$			; AND EXIT
90$:	MOVZWL	#RSN$_NPDYNMEM,R0	; SET RESOURCE TYPE
	BLBC	R5,100$			; BR IF NOTHING AVAILABLE
	BSBW	SCH$RAVAIL		; REPORT RESOURCE AVAILABLE
100$:	MOVL	R5,R0			; SET COMPLETION STATUS
	ENBINT				; RESTORE CALLER'S IPL
	POPR	#^M<R1,R2,R3,R4,R5,R6,R7,R8,R9> ; RESTORE REGISTERS
	RSB

	.PAGE
	.SBTTL	EXTENDLIST - EXTEND SELECTED PACKET LIST
;+
; EXTENDLIST - EXTEND SELECTED PACKET LIST IF NEEDED
;
; THIS ROUTINE EXTENDS THE SELECTED LIST IF NECESSARY BY ADDING ONE
; PAGE AT A TIME
;
; INPUTS:
;
;	R2 = PACKET SIZE
;	R3 = ADDRESS OF MMG$GL_xRPNEXT, NEXT VA TO ALLOCATE
;	R6 = ADDRESS OF IOC$GL_xRPREM, ADDRESS OF PARTIAL PACKET
;	R7 = ADDRESS OF IOC$GL_xRPCNT, COUNT OF ALLOCATED PACKETS
;	R8 = ADDRESS OF IOC$GL_xRPFL, LIST HEADER
;	R9 = ADDRESS OF SGN$GL_xRPCNTV, MAXIMUM COUNT TO ALLOCATE
;
; OUTPUTS:
;
;	R0 = COMPLETION STATUS, LOW BIT CLEAR IF NO EXTENSION OR NOT NEEDED
;
;-
EXTENDLIST:				;
	CMPL	R8,(R8)			; IS LIST EMPTY?
	BNEQ	70$			; IF NOT, EXIT
	CMPL	(R9),(R7)		; CHECK FOR POSSIBLE EXTENSION
	BLEQ	70$			; NO, LIST IS AT MAXIMUM SIZE
	BSBB	EXTENDPAGE		; ATTEMPT TO ADD A PAGE
	TSTL	R0			; CHECK FOR SUCCESS
	BLSS	70$			; BR IF FAILED TO EXTEND
	MOVL	(R6),R0			; GET ADDRESS OF PARTIAL PACKET
	BNEQ	10$			; BR IF ONE PRESENT
	SUBL3	#512,(R3),R0		; COMPUTE ADDRESS OF NEW PAGE
	CLRL	(R0)			; INIT SIZE
10$:	MOVL	(R0),R1			; GET SIZE OF FRAGMENT
	MOVAB	512(R1),R1		; AND AUGMENT BY NEW PAGE
20$:	SUBL	R2,R1			; DIMINISH SIZE BY ONE PACKET
	BLSS	30$			; BRANCH IF INSUFFICIENT SPACE LEFT
	MOVW	R2,IRP$W_SIZE(R0)	; SET SIZE
	INCL	(R7)			; COUNT ANOTHER PACKET
	INSQUE	(R0),(R8)		; INSERT ON LIST
	ADDL	R2,R0			; ADVANCE ADDRESS
	BRB	20$			;
30$:	ADDL	R2,R1			; CORRECT SIZE OF FRAGMENT
	BEQL	40$			; BR IF NO FRAGMENT
	MOVL	R1,(R0)			; SAVE SIZE OF FRAGMENT
	BRB	50$			;
40$:	CLRL	R0			; ZAP FRAGMENT POINTER
50$:	MOVL	R0,(R6)			; SAVE NEW FRAGMENT POINTER
60$:	MOVL	#1,R0			; SET SUCCESS
	RSB
70$:	CLRL	R0			; SET FAILURE
	RSB				

	.PAGE
	.SBTTL	EXTENDPAGE - EXTEND SPECIFIED AREA BY ONE PAGE
;+
; EXTENDPAGE - EXTEND SPECIFIED AREA BY ONE PAGE
;
; THIS ROUTINE EXTENDS THE SPECIFIED AREA BY ONE PAGE PROVIDED THAT THE
; PAGE CAN BE ALLOCATED WITHOUT REDUCING THE FLUID PAGES BELOW THE NUMBER
; REQUIRED TO ACCOMODATE THE CURRENT MAXIMUM WORKING SET SIZE.  THE EXTENSION
; MAY ALSO BE PREVENTED IF NO PAGES ARE AVAILABLE OR THE SPECIFIED AREA IS
; FULL.
;
; INPUTS:
;
;	R3 = ADDRESS OF CELL CONTAINING VA TO BACK WITH PHYSICAL PAGE
;
; OUTPUTS:
;
;	R0 = COMPLETION STATUS, NEGATIVE MEANS FAILURE
;	@R3 = ADVANCED TO POINT TO THE NEXT PAGE IF SUCCESS
;
;	R1,R2,R3 PRESERVED
;-
EXTENDPAGE:
	MNEGL	#1,R0				; ASSUME FAILURE
	DSBINT	L^EXE$GL_NONPAGED		; SYNCHRONIZE
	PUSHR	#^M<R1,R2>			; SAVE REGISTERS
	EXTZV	#VA$V_VPN,#VA$S_VPN,(R3),R2	; GET VIRTUAL PAGE NUMBER
	MOVAL	@W^MMG$GL_SPTBASE[R2],R2	; COMPUTE SVAPTE
	TSTL	(R2)				; CHECK FOR EMPTY
	BNEQ	90$				; BR IF FILLED
	MOVZWL	W^MPW$GW_LOLIM,R1		; GET LOW LIMIT FOR MODIFY LIST
	ADDL	W^SGN$GL_FREELIM,R1		; ADD FREE LIST LIMIT
	SUBL3	R1,L^PFN$GL_PHYPGCNT,R1		; AND COMPUTE NET FLUID PAGE COUNT
	CMPL	R1,W^SGN$GL_MAXWSCNT		; COMPARE WITH MAX WORKING SET
	BLEQ	90$				; BR IF NO ROOM FOR GROWTH
	PUSHR	#^M<R1,R2,R3>			; SAVE VOLATILE REGISTERS
	BSBW	MMG$ALLOCPFN			; AND ATTEMPT TO ALLOCATE A PFN
	POPR	#^M<R1,R2,R3>			; RESTORE VOLATILE REGISTERS
	TSTL	R0				; CHECK STATUS
	BLSS	90$				; BR IF NO PAGE ALLOCATED
	BICB	#1,IOC$GL_POOLEXP_STS		; POOL SUCCESSFULLY EXPANDED
	INCW 	@W^PFN$AW_REFCNT[R0]		; REFERENCE COUNT
	MOVL 	R2,@W^PFN$AL_PTE[R0]		; PTE BACK-POINTER
	MOVB 	#PFN$C_ACTIVE,@W^PFN$AB_STATE[R0] ; STATE IS ACTIVE
	MOVB 	#1,@W^PFN$AB_TYPE[R0]		; TYPE IS SYSTEM PAGE
	BISL3	#<PTE$C_ERKW!PTE$M_VALID>,R0,(R2) ; SET PAGE INTO SPT
	DECL	L^PFN$GL_PHYPGCNT		; ONE LESS FLUID PAGE
	ADDL	#512,(R3)			; ADVANCE POINTER TO NEXT PAGE
80$:	POPR	#^M<R1,R2>			; RESTORE REGISTERS
	ENBINT					; RESTORE IPL
	RSB
;
; Pool expansion failure
;
90$:	BBSS	#0,IOC$GL_POOLEXP_STS,80$	; MESSAGE ALREADY OUTPUT
	BBCC	#0,IOC$GT_NOPOOL_TWP,80$	; TWP IN USE
	MOVAB	IOC$GT_NOPOOL_TWP+TTY$K_WB_LENGTH,R2 ; MESSAGE ADDRESS
	MOVZWL	IOC$GL_POOLEXP_STS+2,R1		; MESSAGE LENGTH
	JSB	IOC$CONBRDCST			; OUTPUT THE MESSAGE
	MNEGL	#1,R0				; INDICATE EXPANSION FAILURE
	BRB	80$
	
	.PAGE
	.SBTTL	ALLOCATE PHYSICALLY-CONTIGUOUS MEMORY
;++
; EXE$ALOPHYCNTG
;
; Allocate and map to system virtual address space N physically-contiguous
; pages.
;
; Inputs:
;	R1 = N = number of physically-contiguous pages
;
; Implicit Inputs:
;	IPL = SYNCH
;
; Outputs:
;	R0 = status: SUCCESS, INSFMEM, INSFSPTS
;	R1 = preserved
;	R2 = system virtual address of N pages of memory if success
;	all other registers preserved
;
; Implicit Outputs:
;	None.
;
; Side Effects:
;	MMG$ALLOCONTIG called
;	IOC$ALLOSPT called - so SPTs are allocated
;
;--
EXE$ALOPHYCNTG::
	PUSHR	#^M<R1,R3,R4,R5>	; save work registers
					;  r1 = input used as loop counter
					;  r3 = address of SPT
					;  r4 = index into PFN database
					;  r5 = temp storage
	JSB	MMG$ALLOCONTIG		; find N physically-contiguous pages
;
; MMG$ALLOCONTIG returns:
;	R0 = first PFN in range, or negative if cannot fulfill request
;
	MOVL	R0,R5			; success?
	BLSS	20$			; get out if none found
	BSBW	IOC$ALLOSPT		; allocate N SPTs to map VAs
	BLBC	R0,30$			; if LBC, no system page table slots
;
; IOC$ALLOSPT returns:
;	R1 = preserved, R2 = SVPN (index into SPT), R3 = address of SPT
;
; The main loop indexes backwards through the system page table entries
; and backwards through the PFN database.  It goes backwards so that the
; last system virtual address calculated can be returned to the caller.
;
;					;  r0 = index into SPT
	ADDL3	R1,R2,R0		; start at last SPT and go backwards
	ADDL3	R5,R1,R4		; start PFNs at end in loop
10$:					; set up system page-table entry
	DECL	R0			; back up SVPN index
	DECL	R4			; back up PFN index
	MOVL	R4,(R3)[R0]		; fill PFN in SPT
	BISL2	#<PTE$C_KW!PTE$M_VALID>,(R3)[R0] ; kernel mode access, valid
;
; Set up PFN database
;
	MOVW	#1,@L^PFN$AW_REFCNT[R4]		; reference count=1
	MOVB	#PFN$C_ACTIVE,@L^PFN$AB_STATE[R4] ; state=active
	MOVB	#PFN$C_SYSTEM,@L^PFN$AB_TYPE[R4]  ; type=system
	MOVAL	(R3)[R0],@L^PFN$AL_PTE[R4]	; PTE points to SPT
;
; Invalidate system virtual address
;
	ASHL	#9,R0,R2		; turn SVPN into VA
	BISL2	#<1@31>,R2		; make VA a system VA
	INVALID	R2			; and clear translation buffer
	SOBGTR	R1,10$			; loop N times

	MOVL	#SS$_NORMAL,R0		; indicates success (R2 has system VA)
15$:	POPR	#^M<R1,R3,R4,R5>	; restore work registers
	RSB				;
20$:	MOVZWL	#SS$_INSFMEM,R0		; no memory available
	BRB	15$			; return
30$:	MOVZWL	#SS$_INSFSPTS,R0	; no SPTs left
	BRB	15$			; return

	.PAGE
	.PSECT	Y$EXEPAGED
	.SBTTL	*** THE FOLLOWING ROUTINES ARE IN THE PAGED EXEC ***
	.SBTTL	EXE$ALOP1PROC - ALLOCATE MEMORY FROM PROCESS ALLOCATION REGION

;+
; EXE$ALOP1PROC - ALLOCATE MEMORY FROM PROCESS ALLOCATION REGION.
;
; This routine is called to allocate memory from the Process Allocation Region
; for those requests which need memory beyond the life of an image.
;
; INPUTS:
;
;	R1 = SIZE OF BLOCK REQUIRED IN BYTES.
;
; OUTPUTS:
;
;	R0 = LOW BIT CLEAR IF MEMORY IS NOT AVAILABLE.
;
;	R0 = LOW BIT SET IF MEMRY ALLOCATED WITH:
;
;		R1 = SIZE OF ALLOCATED BLOCK
;		R2 = ADDRESS OF ALLOCATED BLOCK
;
;	R3 Destroyed.
;
; ENVIRONMENT:
;
;	Called from EXEC or KERNEL modes, this routine will switch
;	into KERNEL mode and disable ASTs to perform the actual
;	allocation.
;
;	IPL =  0 or ASTDEL
;
;--

EXE$ALOP1PROC::
	ADDL	#MASK,R1			; round size to next boundry
	BICL	#MASK,R1			; truncate size back to multiple
	BSBW	P1SYNCH				; get to correct mode, AST level
	
;
; Now in Kernel Mode with ASTs disabled
;

	MOVAL	@#CTL$GQ_ALLOCREG,R3		; get list head address
	BSBW	EXE$ALLOCATE			; allocate block
	BLBC	R0,10$				; get out on error
	SUBL	R1,@#CTL$GL_PRCALLCNT		; keep track of space in use
10$:	RSB
	.PAGE
	.SBTTL	EXE$ALOP1IMAG - ALLOCATE MEMORY FROM PROCESS ALLOCATION REGION

;+
; EXE$ALOP1IMAG - ALLOCATE MEMORY FROM PROCESS ALLOCATION REGION.
;
; This routine is called to  allocate  memory  from  the  Process  Allocation
; Region  for those requests which need memory only for the life of an image.
; This routine will expand P0 space to extend the process  allocation  region
; when:
;
;	1.  There is not enough space left in the Process Allocation Region to
;	    satisfy the request, or
;
;	2.  The space left in the  Process  Allocation  Region  is  less  than
;	    SGN$GW_CTLPAGES - SGN$GW_CTLIMGLIM, and
;
;	3.  The linker option NOP0BUFS has not been selected.
;
;	4.  The routine is called at IPL 0.
;
; INPUTS:
;
;	R1 = SIZE OF BLOCK REQUIRED IN BYTES.
;
; OUTPUTS:
;
;	R0 = LOW BIT CLEAR IF MEMORY IS NOT AVAILABLE.
;
;	R0 = LOW BIT SET IF MEMRY ALLOCATED WITH:
;
;		R1 = SIZE OF ALLOCATED BLOCK
;		R2 = ADDRESS OF ALLOCATED BLOCK
;
;	R3 Destroyed.
;
; ENVIRONMENT:
;
;	Called from EXEC or KERNEL modes, this routine will switch
;	into KERNEL mode and disable ASTs to perform the actual
;	allocation.
;
;	IPL = 0 or ASTDEL
;
;--

EXE$ALOP1IMAG::
	ADDL	#MASK,R1			; round size to next boundry
	BICL	#MASK,R1			; truncate size back to multiple
	BSBW	P1SYNCH				; get to correct mode, AST level
	
;
; Now in Kernel Mode with ASTs disabled
;


	TSTL	@#CTL$GL_PRCALLCNT		; can we get any P1?
	BLEQ	P0SPACE				; branch if not.
	MOVAL	@#CTL$GQ_ALLOCREG,R3		; get list head address
	BSBW	EXE$ALLOCATE			; allocate block
	BLBC	R0,P0SPACE			; on error go try P0 space
	SUBL	R1,@#CTL$GL_PRCALLCNT		; keep track of space in use
	BLSS	10$				; get P0 space if not enough
	RSB

10$:	ADDL	R1,@#CTL$GL_PRCALLCNT		; backup count
	MOVL	R2,R0				; set up for DEALLOCATE
	BSBW	EXE$DEALLOCATE			; return space

P0SPACE:
	CLRL	R0				; assume failure
	BBS	#IMP$V_NOP0BUFS,@#PIO$GW_IIOIMPA,40$ ; branch if cant expand P0
	MOVAL	@#CTL$GQ_P0ALLOC,R3		; get P0 list head

10$:	BSBW	EXE$ALLOCATE			; try to get space
	BLBS	R0,40$				; branch if available
	
;
; SPACE NOT AVAILABLE ON P0 LISTHEAD, EXPAND REGION TO GET IT
;

	TSTL	4(SP)				; can we lower IPL?
	BNEQ	40$				; branch if not
	SETIPL	#0				; lower IPL
	PUSHL	R1				; save request size
	ASHL	#-9,R1,R1			; get size of request in pages
	INCL	R1				; one more page
	CMPL	R1,#16				; at least 16 pages?
	BGEQ	20$				; branch if so
	MOVL	#16,R1				; set 16 pages then
20$:	MOVAQ	-(SP),R2			; get space for RETADR
	$EXPREG_S -				; expand P0
		PAGCNT	=	R1, -
		RETADR	=	(R2), -
		ACMODE	=	#PSL$C_KERNEL, -
		REGION	=	#0
	BLBC	R0,30$				; get out on error
	$SETPRT_S -				; change page protection
		INADR	=	(R2), -
		ACMODE	=	#PSL$C_KERNEL, -
		PROT	=	#PRT$C_UREW
	BLBC	R0,30$				; get out on error
	MOVQ	(SP)+,R0			; get address range
	SUBL	R0,R1				; get size of area
	INCL	R1
	SETIPL	#IPL$_ASTDEL			; restore IPL
	BSBW	EXE$DEALLOCATE			; put new space on list
	MOVL	(SP)+,R1			; restore R1
	BRB	10$				; go back and try request

30$:	MOVAL	12(SP),SP			; pop temp space, saved R1
40$:	RSB					; and return

	.PAGE
	.SBTTL	EXE$DEAP1 - RETURN MEMORY TO PROCESS ALLOCATION REGION

;+
; EXE$DEAP1 - RETURN MEMORY TO PROCESS ALLOCATION REGION
;
; This routine is called to return memory allocated via the EXE$ALOP1IMAG
; or EXE$ALOP1PROC routines.
;
; INPUTS:
;
;	R0 = ADDRESS OF BLOCK TO BE DEALLOCATED.
;	R1 = SIZE OF BLOCK IN BYTES
;
; OUTPUTS:
;
;	R0-R3 Destroyed.
;
; ENVIRONMENT:
;
;	Called from EXEC or KERNEL modes, this routine will switch
;	into KERNEL mode and disable ASTs to perform the actual
;	de-allocation.
;
;	IPL = 0 or ASTDEL
;-

EXE$DEAP1::
	;BSBW	CHECKBLOCK				; check deall parameters
	BSBB	P1SYNCH					; get to correct mode, AST level

;
; Now in Kernel Mode with ASTs disabled
;

	BBC	#30,R0,10$				; branch if P0 address
	MOVAL	@#CTL$GQ_ALLOCREG,R3			; get list head address
	ADDL	R1,@#CTL$GL_PRCALLCNT			; keep track of space
	BRB	20$

10$:	MOVAL	@#CTL$GQ_P0ALLOC,R3			; get P0 list head
20$:	BSBW	EXE$DEALLOCATE				; return space
	RSB

	.PAGE
	.SBTTL	P1 SYNCH ROUTINE

;+
;
; This routine is called to switch into kernel mode if necessary.  It
; calls the subroutine P1KERN via a $CMKRNL service or a CALLG instruction
; depending on the current mode.  The P1KERN subroutine performs a JSB
; back to P1SYNCH's return address to perform the actual allocation
; routine after disabling ASTs.  Upon return from P1KERN, P1SYNCH
; pops it's return address and RSBs to it's caller's calller.
;
;-


P1SYNCH:
	MOVPSL	R2				; get PSL
	BBC	#PSL$V_CURMOD,R2,10$		; branch if not in EXEC mode
	PUSHR	#^M<R0,R1>			; push input args
	MOVL	SP,R3				; get argument list address
	$CMKRNL_S -				; go into kernel mode
		ROUTIN = 30$, -
		ARGLST = (R3)
	POPR	#^M<R1,R2,R3>			; get return R1,R2, pop return addr
	RSB					; return to caller's caller.

10$:	MOVL	(SP)+,R3			; get routine address

20$:	DSBINT	#IPL$_ASTDEL			; raise IPL
	JSB	(R3)				; go back to routine
	ENBINT					; lower IPL
	RSB

30$:	.WORD	^M<R2,R3>
	MOVQ	(AP),R0				; get input args
	MOVL	8(AP),R3			; get routine address
	BSBB	20$				; synch and call routine
	MOVQ	R1,(AP)				; return R1,R2 values
	RET

	.END
