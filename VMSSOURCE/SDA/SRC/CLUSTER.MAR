	.TITLE	CLUSTER		SHOW CLUSTER INFORMATION
	.SBTTL	COPYRIGHT NOTICE
	.IDENT	'V04-000'
;
;****************************************************************************
;*									    *
;*  COPYRIGHT (c) 1978, 1980, 1982, 1984 BY				    *
;*  DIGITAL EQUIPMENT CORPORATION, MAYNARD, MASSACHUSETTS.		    *
;*  ALL RIGHTS RESERVED.						    *
;* 									    *
;*  THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND COPIED   *
;*  ONLY IN  ACCORDANCE WITH  THE  TERMS  OF  SUCH  LICENSE  AND WITH THE   *
;*  INCLUSION OF THE ABOVE COPYRIGHT NOTICE. THIS SOFTWARE OR  ANY  OTHER   *
;*  COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE AVAILABLE TO ANY   *
;*  OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF  THE  SOFTWARE IS  HEREBY   *
;*  TRANSFERRED.							    *
;* 									    *
;*  THE INFORMATION IN THIS SOFTWARE IS  SUBJECT TO CHANGE WITHOUT NOTICE   *
;*  AND  SHOULD  NOT  BE  CONSTRUED AS  A COMMITMENT BY DIGITAL EQUIPMENT   *
;*  CORPORATION.							    *
;* 									    *
;*  DIGITAL ASSUMES NO RESPONSIBILITY FOR THE USE  OR  RELIABILITY OF ITS   *
;*  SOFTWARE ON EQUIPMENT WHICH IS NOT SUPPLIED BY DIGITAL.		    *
;* 									    *
;*									    *
;****************************************************************************
;
	.PAGE
	.SBTTL	PROGRAM DESCRIPTION
;++
;   FACILITY
;
;	SYSTEM DUMP ANALYZER
;
;   ABSTRACT
;
;	THIS MODULE CONTAINS THE ROUTINES NECESSARY TO DISPLAY THE
;	VAXCLUSTER DATA STRUCTURES.  IT PROVIDES SUPPORT FOR THE COMMANDS,
;	SHOW CLUSTER,SHOW RSPID, SHOW CONNECTIONS, AND SHOW PORTS.
;
;   ENVIRONMENT
;
;	NATIVE MODE, USER MODE
;
;   AUTHOR
;
;	ELLEN M. BATBOUTA, MAY 1984
;
;	V03-001  EMD0110  	Ellen M. Batbouta		16-JUL-1984
;		 Allocate storage dynamically for the cdl and the rdt since
;		 their sizes depend on sysgen parameters.  Display closed
;		 cdts only if the /address qualifier is specified on the
;		 command.  Also fix a few minor problems with the displays.
;

    .sbttl	declarations
;
;	symbol definitions
;
    	$cdldef			; Connection Descriptor List (CDL)
    	$cdtdef			; SCS Connection Descriptor Table (CDT)
    	$cdrpdef		; Class Driver Request Packet (CDRP)
    	$clubdef		; Cluster Block (CLUB)
    	$cludcbdef		; Cluster Quorum Disk Control Block (CLUDCB)
    	$csbdef			; Cluster System Block (CSB)
    	$ddbdef			; Device Data Block (DDB)
    	$dyndef			; Dynamic Storage Type Definitions 
    	$pbdef			; Path Block (PB)
    	$pdtdef			; Port Descriptor Table (PDT)
    	$rddef			; SCS Response Descriptor Format
    	$rdtdef			; SCS Response Descriptor Table
    	$sbdef			; System Block (SB)
    	$sdirdef		; SCS Directory Entry (SDIR)
    	$tpadef			; TPARSE definitions
    	$ucbdef			; Unit Control Block (UCB)

    .sbttl	storage definitions
;
;	storage definitions
;

    .psect	sdadata,noexe,wrt

cdl:   	.blkl	1			; to contain address of local cdl
    					; Connections Descriptor List (CDL)
cdl_size:
    	.blkl	1			; to contain size of cdl

cdt:	.blkb	cdt$c_length		; connection descriptor table (CDT)

club:	.blkb	club$c_length		; Cluster Block (CLUB)

csb:	.blkb	csb$c_length		; Cluster System Block (CSB)

cludcb:	.blkb	cludcb$c_length		; Cluster Quorum Disk Control Block

pdt:	.blkb	pdt$c_length		; Port Descriptor Table (PDT)

directory:  
    	.blkb	sdir$c_length		; SCS directory entry

rdt:	.blkl	1			; to contain address of local rdt

rdt_size:
    	.blkl	1			; to contain size of rdt    		
wait_cdrp:
    	.long	0			; cdrp in rdt wait queue

sblock:
    	.blkb	sb$c_length		; System Block (SB)

node:	.blkb	sb$s_nodename		; node name in system block (SB)

procname:   .blkb  16			; to hold local/remote process name

driver_name:	.blkb  20		; driver name

device_name:	.blkb	20		; device name

tim_buffer:
    	.blkl	2			; buffer to hold date/time stamp
csid::
    	.long	0			; cluster system id

cdt_spcfy::
    	.long	0			; flag to specify if /connection 
    					; qualifier was present in command


    .sbttl	read-only data definitions
;
;	read-only data definitions
;

    .psect 	cluster,exe,nowrt,long
    .default	displacement,long

club_summary:	
    	table	club$v_,<qf_dynvote,qf_vote,quorum,transition>

csb_summary:
    	table	csb$v_,<long_break,member,removed,qf_same,qf_active>

csb_states:
    	table	csb$k_,<open,status,reconnect,new,connect,accept,disconnect,-
    			reaccept,wait,dead,local>

csb_status:
    	table	csb$v_,<long_break,member,removed,qf_same,cluster,qf_active,-
    			shutdown,locked,selected,local,status_rcvd,send_status>

fcb_status:
    	table	clufcb$v_,<active,pending,sync_node,fkb_busy>

club_flags:
    	table	club$v_,<cluster,qf_active,shutdown,sts_pphase,sts_ph0,-
    			sts_ph1b,sts_ph1,sts_ph2,fkb_busy,unlock,no_form,-
    			init,backout,lost_cnx,qf_failed_node,qf_vote,-
    			qf_newvote,adj_quorum,quorum,transition,qf_dynvote>

cludcb_state:
    	table	cludcb$v_,<qs_not_ready,qs_ready,qs_active,qs_cluster,qs_vote>

cludcb_flags:
    	table	cludcb$v_,<qf_tim,qf_rip,qf_wip,qf_error,qf_cspack>

cdt_state:
    	table	cdt$c_,<closed,listen,open,disc_ack,disc_rec,disc_sent,-
    			disc_mtch,con_sent,con_ack,con_rec,accp_sent,rej_sent,-
    			vc_fail>

cdt_blkstate:
    	table	cdt$c_,<con_pend,accp_pend,rej_pend,disc_pend,cr_pend,dcr_pend>

pdt_type:
    	table	pdt$c_,<pa,pu,pe,ps>

port_char:
    	table	pdt$v_,<snglhost>


    .sbttl	show_cluster  --- display structures relevant to vaxclusters
;---
;
;	show_cluster
;
;	This is the main routine whose purpose is to provide information
;	on vaxclusters.  Several structures are displayed.  The order
;	is as follows:
;			list of cluster system blocks (CSBs)
;			the cluster block (CLUB)
;			the cluster failover control block (CLUFCB)
;			the cluster quorum disk control block (CLUDCB)
;			display a csb for each node in the cluster
;
;	Inputs:
;
;		AP = pointer to TPARSE block
;		CSID = cluster system id (CSID)
;
;	Outputs:
;
;		Vaxcluster data structures ( as listed above) are shown
;---
    .enable lsb
show_cluster::
    	.word 	^m<r2,r3,r4,r5,r6,r7,r8,r9,r10,r11>

    	subhd	<VAXcluster data structures>		; set heading

    	getmem	@clu$gl_club,r5			; get address of club
    	blbs	r0,5$				; branch if able to read it
    	brw	20$				; branch because of error
5$:
    	movab	club,r2				; will contain local copy of club
    	getmem	(r1),(r2),#club$c_length	; move club to local storage
    	blbc	r0,20$				; check for error
    	tstw	csid				; check to see if csid in command
    	bneq	locate_csb			; display csb of this csid and exit

    	pushl	r5				; address of club
    	pushl	r2				; pass address of local club
    	calls	#1,cluster_summary		; display list of csb's

    	pushl	r5				; address of club
    	pushl	r2				; pass address of local club
    	calls	#1,display_club			; display cluster block

    	pushab	club$b_clufcb(r2)		; address of fcb in local storage
    	pushab	club$b_clufcb(r5)		; failover control block
   	calls	#1,display_clufcb			; display it

    	tstl	club$l_cludcb(r2)		; cludcb exists?
    	beql	6$				; equal, does not exist
    	pushl	club$l_cludcb(r2)		; quorum disk control block
  	calls	#1,display_cludcb		; display it
6$:
    	moval	club$l_csbqfl(r5),r4		; address of csb queue
   	cmpl	r4,club$l_csbqfl(r2)		; check if queue empty
    	beql	20$				; equal, then empty, so exit
    	movl	club$l_csbqfl(r2),r3		; queue not empty 
10$:  	pushl	r3				; pass it to routine
    	calls	#1,display_csb			; display this csb
    	addl2	#csb$l_sysqfl,r3		; check for another csb
    	getmem	(r3),r3				; read field in queue
    	blbc	r0,20$				; are we able to read it?
    	cmpl	r4,r3				; check to see if at end of queue
    	bneq	10$				; not equal, another csb exists
20$:    movl	#1,r0				; finished! - return success
    	ret



locate_csb:
    	moval	club$l_csbqfl(r5),r4		; start of queue
    	cmpl	r4,club$l_csbqfl(r2)		; is queue empty
    	beql	20$				; equal, yes so exit
    	movl	club$l_csbqfl(r2),r3		; first entry in queue
40$:
    	addl3	#csb$l_csid,r3,r6		; point to csid in csb
    	getmem	(r6)				; read in csid value
    	blbc	r0,20$				; exit if can not read
    	cmpw	r1,csid				; right csb?
    	beql	50$				; equal, yes so display
    	addl2	#csb$l_sysqfl,r3		; point to next entry in queue
    	getmem	(r3),r3				; read it in
    	blbc	r0,20$				; exit if not possible
    	cmpl	r4,r3				; end of queue yet
    	beql	20$				; equal, yes so exit
    	brb	40$				; get next csb
50$:
    	skip	page				; next screen
    	pushl	r3				; actual address of csb
    	calls	#1,display_csb			; display
    	clrl	csid				; reinitialize
    	brw	20$				; and exit with success
    
    	.dsabl	lsb

    .sbttl	cluster_summary --- summary sheet for the club and csbs
;---
;
;	cluster_summary
;
;	This routine outputs a brief summary of the cluster block (CLUB)
;	and of each cluster system block (CSB).  There exists
;	one csb per node in the cluster and one club for the cluster.
;
;	Inputs:
;
;		4(ap) = address of club in local storage
;		8(ap) = actual address of club
;		
;	Outputs:
;		
;		
;---
cluster_summary:
    .word    ^m<r2,r3,r4,r5,r6,r7,r8,r9,r10,r11>

    movl    4(ap),r4			; club in local storage
;
; First display a few important fields in the cluster block (CLUB)
;
    skip    page
    print   0,<!_           --- VAXcluster Summary --->
    skip    1
    print   0,<!_ Quorum   Votes   Quorum Disk Votes   Status Summary>
    print   0,<!_ ------   -----   -----------------   -------------->		

    alloc	80,r2			; allocate output buffer
    movl	club$l_flags(r4),-(sp)	; bit mask to translate
    pushab	club_summary		; address of definition table
    calls	#2,translate_bits       ; translate bits to names

    pushl	sp			; address of string descriptor
    movzwl	club$w_qdvotes(r4),-(sp)	; quorum disk votes
    movzwl	club$w_votes(r4),-(sp)	; cluster votes
    movzwl	club$w_quorum(r4),-(sp)	; cluster quorum
    print	4,<!_    !4<!UW!>    !4<!UW!>         !4<!UW!>         !AS>
    addl2	#88,sp			; clean up stack
;
; Now to actually display a list of csb's and a little information about
; each one. (A little knowledge never hurt anyone, right?)
;
    skip    1
    print   0,<!_!_!_--- CSB list --->
    skip    1
    print   0,<Address   Node    CSID      Votes   State     Status>
    print   0,<-------   ----    ----      -----   -----     ------>
    skip    1
;
; Header information complete - now time to loop through the queue of csb's
; in the cluster block (club)
;
    assume	club$l_csbqfl eq 0
    cmpl	8(ap),club$l_csbqfl(r4)		; check for empty queue
    bneq	20$				; not equal, entry in queue
    brw		done				; otherwise, this display is done
20$:
    movl	club$l_csbqfl(r4),r6		; get address of csb
Loop:
    moval	csb,r7				; local storage for csb
    getmem	(r6),(r7),#csb$c_length		; read entire csb
    blbc	r0,done				; if not able to read, exit

    alloc	80				; alloc buffer for translation
    movl	csb$l_status(r7),-(sp)		; bit mask to translate
    pushab	csb_summary			; bit definition table
    calls	#2,translate_bits		; translate bits to names
    pushl	sp				; names for status bits

    movzbl	csb$b_state(r7),r2		; bit mask to translate
    movab	csb_states,r3			; state translation table
    jsb		g^translate_address		; translate value to names
    beql	10$				; branch if translation failed
    pushl	r0				; names for states
10$:
    movzwl	csb$w_votes(r7),-(sp)		; votes held by node
    pushl	csb$l_csid(r7)			; Cluster System Id

    movab	node,r2
    addl3	#sb$t_nodename, csb$l_sb(r7),r3  ; point to nodename
    getmem	(r3),(r2),#sb$s_nodename	; read in nodename	
    pushl	r2				; node
    pushl	r6				; address of csb
    print	6,<!XL  !6<!AC!>  !XL    !3<!UW!>!10<   !AC!> !AS>
    addl2	#88,sp				; clean up stack    

    cmpl	csb$l_sysqfl(r7),8(ap)		; check for end of csbs
    beql	done				; equal, at end
    movl	csb$l_sysqfl(r7),r6		; address of next csb
    brw		loop				; loop to display

done:
    movl	#1,r0
    ret

    .sbttl	display_club --- display cluster block (CLUB)
;---
;
;	display_club
;
;	This routine displays the cluster block.  There exists
;	one club per cluster.
;
;	Inputs:
;
;		4(ap) = address of club in local storage
;		8(ap) = actual address of club
;		
;	Outputs:
;		The CLUB is displayed.
;		
;---
display_club:
    .word	^m<r2,r3,r4,r5,r6,r7,r8,r9,r10,r11>

    ensure	20			; make sure at least 20 lines on screen
    movl	4(ap),r4		; club in local storage
    pushl	8(ap)			; actual address of club
    print	1,<!_!_ --- Cluster Block (CLUB) !XL --->
    skip 	1
    alloc	80,r5				; 80 byte output buffer
    pushl	club$l_flags(r4)		; flags in club
    pushab	club_flags			; bit definition table
    calls	#2,translate_bits		; translate bits to names
    pushl	r5				; names defining flags
    pushl	club$l_flags(r4)		; flags in club
    print	2,<Flags: !XL !AS>		; display translated flags
    skip	1
    addl2	#88,sp				; clean up stack
    print_columns -
    		(r4),8(ap),-
    		club_col_1,club_col_2	        ; display the club
    status	success
    ret

    .sbttl	cluster block data block tables & action routines
;
;   PRINT_COLUMNS table for CLUB displays
;

club_fao_6bytes:
    	string	<!#* !XW!XL>

club_2words:
    	string  <!10UW/!UW>

club_col_1:
    	column_list	-
    		club$, 21, 12, 4, <-
    		<<Quorum/Votes>,quor_vote,0>,-
    		<<Quorum Disk Votes>,w_qdvotes,uw>,-
    		<<Nodes>,w_nodes,uw>,-
    		<<Quorum Disk>,t_qdname,ac,15,18>,-
    		<<Found Node SYSID>,club_6bytes,club$b_fsysid>,-
 		<<Founding Time>,date_routine,club$q_ftime>,-
    		<<>,time_routine,club$q_ftime>,-
    		<<Index of next CSID>,w_next_csid,xw>,-
       		<<Quorum Disk Cntrl Block>,l_cludcb,xl,25,8>,-
    		<<Timer Entry Address>,l_tqe,xl>,-
    		<<CSP Queue>,l_cspfl,q2>,-
    		<<Transaction code>,trans_byte,club$b_cur_code>,-
    		<<Transaction Phase>,trans_byte,club$b_cur_phase>,-
    		<<Message Count>,trans_word,club$w_msgcnt>,-
    		>


club_col_2:
    	column_list	-
    		club$, 21, 12, 0, < -
    		<<Last transaction code>,b_lst_code,xb>,-
    		<<Last trans. number>,l_lst_xtn,ul>,-
    		<<Last coordinator CSID>,l_lst_coord,xl>,-
    		<<Last time stamp>,date_routine,club$q_lst_time>,-
    		<<>,time_routine,club$q_lst_time>,-
    		<<Largest trans. id>,l_max_xtn,xl>,-
    		<<Resource Alloc. retry>,l_retrycnt,ul>,-
       		<<Figure of Merit>,l_fmerit,xl>,-
    		<<Member State Seq. Num.>,w_memseq,xw>,-
   		<<Foreign Cluster>,l_foreign_cluster,xl>,-
    		<<Curr. coord. CSID>,trans_long,club$l_cur_coord>,-
    		<<Current trans. number>,trans_long,club$l_cur_xtn>,-
    		<<Curr. time-stamp>,curr_date,club$q_cur_time>,-
    		<<>,curr_time,club$q_cur_time>,-
    		>
    		
;
;   The following are all PRINT_COLUMNS action routines for the show 
;   cluster block displays.
;
;   Action Routine Inputs:
;
;	R2	value from the COLUMN_LIST entry
;	R5	size of value section for this item
;	R7	address of a descriptor for a scratch string in
;		which the FAO converted value is to be returned
;	R11	base address of the local CLUB copy
;
;   Action Routine Outputs:
;
;	R0	status
;		lbs ==> use this entry
;		lbc ==> skip this entry
;	R1-R5   scratch
;		all other registers must be preserved
;
;*******
quor_vote:
    movzwl	club$w_quorum(r11),r2		; display quorum value with
    movzwl	club$w_votes(r11),r3		; the value for votes
    $fao_s	-
    		ctrstr = club_2words,-		; two values as requested
    		outbuf=(r7),-
    		outlen=(r7),-
    		p1=r2,-
    		p2=r3
    rsb

;*******
club_6bytes:
    addl3	r2,r11,r3	; locate storage of interest
    subl	#12,r5		; get size of filler field
    $fao_s	-
    		ctrstr=club_fao_6bytes,-
    		outbuf=(r7),-
    		outlen=(r7),-
    		p1=r5,-
    		p2=4(r3),-
    		p3=(r3)
    rsb

;*******
date_routine:
    addl3	r2,r11,r3	; locate area of interest
    
    movq	(r3),tim_buffer	; move into buffer
    alloc	11,r4		; allocate space for date 
    $asctim_s	timadr=tim_buffer,-
    		timbuf=(r4)	; convert value to ascii 
    movl	r4,r2		; pass address of descriptor in r2
    do_column_entry	as	; display date
    addl	#20,sp		; clean up the stack
    rsb

;*******
time_routine:
    addl3	r2,r11,r3	; locate area of interest
    movq	(r3),tim_buffer ; move into buffer
    alloc	24,r4		; allocate space for date/time
    $asctim_s	timadr=tim_buffer,-
    		timbuf=(r4)	; convert to ascii
    movw	#9,(r4)		; only display time - adjust length accordingly
    addl2	#11,4(r4)	; adjust address to point to time
    movl	r4,r2		;
    do_column_entry	as	; display time
    addl2	#32,sp		; clean up the stack
    rsb

;*******
curr_date:
    bbc	    	#club$v_transition,club$l_flags(r11),10$
    				; if transition in progress, this field is of
    				; interest to us, so display.
    jmp		date_routine
10$:
    rsb

;*******
curr_time:
    bbc		#club$v_transition,club$l_flags(r11),10$
    				; if transition in progress, this field is of
       				; interest to us, so display
    jmp		time_routine
10$:
    rsb

;********
trans_long:
    bbc		#club$v_transition,club$l_flags(r11),10$
    				; if transition in progress, this field is of
    				; interest to us, so display.
    addl	r11,r2		; locate cell to return
    do_column_entry	xl,jmp
10$:
    rsb

;********
trans_word:
    bbc		#club$v_transition,club$l_flags(r11),10$
    				; if transition in progress, this field is of
    				; interest to us, so display.
    addl	r11,r2		; locate cell to return
    do_column_entry	uw,jmp
10$:
    rsb

;********
trans_byte:
    bbc		#club$v_transition,club$l_flags(r11),10$
    				; if transition in progress, this field is of
    				; interest to us, so display.
    addl	r11,r2		; locate cell to return
    do_column_entry	ub,jmp
10$:
    rsb

    .sbttl     display_clufcb --- display cluster failover control block(CLUFCB)
;---
;
;	display_clufcb
;
;	This routine displays the cluster failover control block which is
;	a subblock of the club that is used to sequence failover actions 
;	in a cluster
;
;	Inputs:
;
;		4(ap) = actual address of cluster failover control block
;		8(ap) = address of cluster fcb in local storage
;		
;	Outputs:
;		The Cluster failover control block is displayed.
;		
;---
display_clufcb:
    .word	^m<r2,r3,r4,r5,r6,r7,r8,r9,r10,r11>

    ensure	20			; make sure at least 20 lines on screen
    movl	8(ap),r4		; cluster fcb in local storage
    pushl	4(ap)			; actual address of cluster fcb
    print	1,<!_ --- Cluster Failover Control Block (CLUFCB) !XL --->
    skip 	1
    alloc	80,r5				; 80 byte output buffer
    pushl	clufcb$l_status(r4)		; status
    pushab	fcb_status			; bit definition table
    calls	#2,translate_bits		; translate bits to names
    pushl	r5				; names defining status bits
    pushl	clufcb$l_status(r4)		; status field
    print	2,<Flags: !XL !AS>		; display translated status
    skip	1
    addl2	#88,sp				; clean up stack
    print_columns -
    		(r4),4(ap),-
    		fcb_col_1,fcb_col_2	        ; display the cluster fcb
    status	success
    ret

    .sbttl     display_cludcb --- display cluster quorum disk control block
;---
;
;	display_cludcb
;
;
;	Inputs:
;
;		4(ap) = actual address of cluster quorum disk control block
;		
;	Outputs:
;		The Cluster quorum disk control block is displayed.
;		
;---
display_cludcb:
    .word	^m<r2,r3,r4,r5,r6,r7,r8,r9,r10,r11>

    skip	3
    movl	4(ap),r5		; actual address of cluster dcb 
    pushl	r5			
    print	1,<!_ --- Cluster Quorum Disk Control Block (CLUDCB) !XL --->
    skip 	1
    movab	cludcb,r4
    getmem	(r5),(r4),#cludcb$c_length	; read into local storage
    blbs	r0,20$				; branch if able to read
    rsb						; else, exit
20$:
    alloc	80,r6				; 80 byte output buffer
    movzwl	cludcb$w_state(r4),-(sp)	; status
    pushab	cludcb_state			; bit definition table
    calls	#2,translate_bits		; translate bits to names
    pushl	r6				; names defining state bits
    movzwl	cludcb$w_state(r4),-(sp)	; state field
    print	2,<State: !XW !AS>		; display translated state
    movzbl	#80,(r6)			; reinitialize buffer
    movzwl	cludcb$w_flags(r4),-(sp)	; translate flags now
    pushab	cludcb_flags			; bit definition table
    calls	#2,translate_bits		; translate to names
    pushl	r6				; names defining flags
    movzwl	cludcb$w_flags(r4),-(sp)	; flags field
    print	2,<Flags: !XW !AS>		; display translated flags
    skip	1
    addl2	#88,sp				; clean up stack
    print_columns -
    		(r4),r5,-
    		dcb_col_1,dcb_col_2	        ; display the cluster fcb

    status	success
    ret

    .sbttl	cluster failover control block tables & action routines
;
;   PRINT_COLUMNS table for CLUFCB displays
;
fcb_col_1:
    	column_list	-
    		clufcb$, 21, 12, 4, < -
    		<<Failover Step Index>,l_step,xl>,-
    		<<Failover Instance ID>,l_id,xl>,-
    		>

fcb_col_2:
    	column_list	-
    		clufcb$, 21, 12, 4, < -
    		<<CSB of Synchr. System>,l_sync_csb,xl>,-
    		>

    .sbttl	cluster quorum disk control block tables & action routines
;
;   PRINT_COLUMNS table for CLUDCB displays
;
dcb_col_1:
    	column_list	-
    		cludcb$, 21, 12, 4, < -
    		<<Iteration Counter>,b_counter,ub>,-
    		<<Activity Counter>,l_act_count,ul>,-
    		<<Quorum file LBN>,l_qflbn,xl>,-
    		>

dcb_col_2:
    	column_list	-
    		cludcb$, 21, 12, 0, < -
    		<<          UCB address>,l_ucb,xl>,-
    		<<          TQE address>,l_tqe,xl>,-
    		<<          IRP address>,l_irp,xl>,-
    		>

    .sbttl     display_csb --- display cluster system block (CSB)
;---
;
;	display_csb
;
;
;	Inputs:
;
;		4(ap) = actual address of cluster system block
;		
;	Outputs:
;		The Cluster system block is displayed.
;		All registers are preserved.
;		
;---
display_csb:
    .word	^m<r2,r3,r4,r5,r6,r7,r8,r9,r10,r11>

    ensure	20
    pushl	4(ap)			; actual address of csb			
    skip	1
    movab	csb,r4			; buffer to hold contents of csb locally
    getmem	@4(ap),(r4),#csb$c_length	; read into local storage
    blbs	r0,10$				; branch if able to read
    rsb						; else, exit
10$:
    addl3	#sb$t_nodename,csb$l_sb(r4),r7	; address of system block
    getmem	(r7),node,#sb$s_nodename	; read node name
    pushal	node				; address of ASCIC string
    print	1,<!_ --- !AC Cluster System Block (CSB) !XL --->
    skip 	1

make_csb_symbols:
    make_symbol	CSB, 4(ap)
    make_symbol	CDT, csb$l_cdt(r4)		
    make_symbol	PDT, csb$l_pdt(r4)
    make_symbol	SB, csb$l_sb(r4)    		

    movzbl	csb$b_state(r4),r2		; state field
    movab	csb_states,r3			; bit definition table
    jsb		g^translate_address		; translate bits to names
    beql	notrans				; equal, unable to translate
    pushl	r0				; names defining state bits
    movzbl	csb$b_state(r4),-(sp)		; state field
    print	2,<State: !XB !AC>		; display translated state
notrans:
    alloc	80,r6				; allocate buffer
    pushl	csb$l_status(r4)		; translate status now
    pushab	csb_status			; bit definition table
    calls	#2,translate_bits		; translate to names
    pushl	r6				; names defining status
    pushl	csb$l_status(r4)		; status field
    print	2,<Flags: !XL !AS>		; display translated status
    skip	1
    addl2	#88,sp				; clean up stack
    print_columns -
    		(r4),4(ap),-
    		csb_col_1,csb_col_2,-
    		csb_col_3		        ; display the csb

    status	success
    ret


    .sbttl	cluster system block tables & action routines
;
;   PRINT_COLUMNS table for CSB displays
;

csb_2words:
    string 	<!6UW/!UW>

csb_2bytes:
    string	<!5UB/!UB>

csb_col_1:
    	column_list	-
    		csb$, 14, 8, 4, < -
    		<<Quorum/Votes>,csbquor_votes,0>,-
    		<<Quor. Disk Vote>,w_qdvotes,uw,15,7>,-
    		<<CSID>,l_csid,xl>,-
    		<<Eco/Version>,eco_vers,0>,-
    		<<Reconn. time>,l_timeout,xl>,-
    		<<Ref. count>,b_ref_cnt,ub>,-
    		<<Ref. time>,date_routine,csb$q_reftime,11,11>,-
    		<<>,time_routine,csb$q_reftime,11,11>,-
    		>

csb_col_2:
    	column_list	-
    		csb$, 16, 8, 4, < -
    		<<Next seq. number>,w_sendseqnm,xw>,-
    		<<Last seq num rcvd>,w_rcvdseqnm,xw,17,7>,-
    		<<Last ack. seq num>,w_ackrseqnm,xw,17,7>,-
    		<<Unacked messages>,b_unackedmsgs,ub>,-
    		<<Ack limit>,b_remacklim,ub,18,6>,-
    		<<Incarnation>,date_routine,csb$q_swincarn,13,11>,-
    		<<>,time_routine,csb$q_swincarn,13,11>,-
    		<<Lock mgr dir wgt>,w_lckdirwt,uw>,-
    		>

csb_col_3:
    	column_list	-
    		csb$, 16, 8, 0, < -
    		<<Send queue>,l_sentqfl,xl>,-
    		<<Resend queue>,l_resendqfl,xl>,-
    		<<Block xfer Q.>,l_partnerqfl,q2>,-
    		<<CDT address>,l_cdt,xl>,-
    		<<PDT address>,l_pdt,xl>,-
    		<<TQE address>,l_tqe,xl>,-
    		<<SB address>, l_sb,xl>,-
    		<<Current CDRP>,l_currcdrp,xl>,-
    		>    		
;
;   The following are all PRINT_COLUMNS action routines for the show 
;   cluster block displays.
;
;   Action Routine Inputs:
;
;	R2	value from the COLUMN_LIST entry
;	R5	size of value section for this item
;	R7	address of a descriptor for a scratch string in
;		which the FAO converted value is to be returned
;	R11	base address of the local CLUB copy
;
;   Action Routine Outputs:
;
;	R0	status
;		lbs ==> use this entry
;		lbc ==> skip this entry
;	R1-R5   scratch
;		all other registers must be preserved
;

;*******
csbquor_votes:
    movzwl	csb$w_quorum(r11),r2		; display quorum value with
    movzwl	csb$w_votes(r11),r3		; the value for votes
    $fao_s	-
    		ctrstr = csb_2words,-		; two values as requested
    		outbuf=(r7),-
    		outlen=(r7),-
    		p1=r2,-
    		p2=r3
    rsb
;*******
eco_vers:
    movzbl	csb$b_ecolvl(r11),r2		; display eco level with
    movzbl	csb$b_vernum(r11),r3		; the version number
    $fao_s	-
    		ctrstr = csb_2bytes,-	; two values as requested
    		outbuf=(r7),-
    		outlen=(r7),-
    		p1=r2,-
    		p2=r3
    rsb


    .sbttl	show_scs --- display system communications(SCS) data structures
;---
;
;	show_scs
;
;	This is the main routine whose purpose is to provide information
;	on vaxclusters which are related to system communications (SCS).  
;	Several structures are displayed.  The order
;	is as follows:
;			summary page
;			each system block and all of its path blocks
;
;	Inputs:
;
;		AP = pointer to TPARSE block
;
;	Outputs:
;
;		SCS data structures ( as mentioned above) are shown
;		All registers are preserved.
;
;---
    .enable lsb
show_scs::
    	.word 	^m<r2,r3,r4,r5,r6,r7,r8,r9,r10,r11>

    	subhd	<VAXcluster data structures>		; set heading
    	skip	page
    	calls	#0,scs_summary				; summary page

    	skip page
    	calls	#0,display_sb_pbs		; system and path blocks

    	movl	#1,r0					; return success
    	ret
    	.dsabl	lsb

    .sbttl	scs_summary --- display system communications(SCS) summary
;---
;
;	show_scs
;
;	This is a coroutine whose purpose is display a summary page.
;	The summary page is divided into 2 parts.  The first half
;	displays a list of the local processes that are known to SCS.
;	The second half displays a brief description of the systems 
;	in the cluster and the number of paths each has.
;
;	Inputs:
;
;		none
;
;	Outputs:
;
;		SCS data structures (as mentioned above) are shown
;		All registers are preserved.
;
;---
    	.enabl  lsb
scs_summary:
    	.word 	^m<r2,r3,r4,r5,r6,r7,r8,r9,r10,r11>

    	skip	1
    	print	0,<!_ 	--- SCS Listening Process Directory --->
    	skip	1
    	print	0,<Entry Address     Connection ID     Process Name	   Information>
    	print	0,<-------------     -------------     ------------	   ----------->
    	skip	1
    	
    	getmem	@scs$gq_direct,r6			; get address of 1st entry
    	retiferr					; check for error
    	movab	directory,r4				; local storage for entry
    	getmem	(r6),(r4),#sdir$c_length		; read into local storage
    	retiferr					; check for error
5$:
   	pushal	sdir$b_procinf(r4)			; process information
    	tstb	sdir$b_procinf(r4)			; check for ascii info
    	beql	7$					; equal, don't display
    	pushl	#16
    	brb	8$					; branch around
7$:    	pushl	#0					; don't display info
8$:    	pushal	sdir$b_procnam(r4)			; process name
    	pushl	#16
    	pushl	sdir$l_conid(r4)			; connection id
    	pushl	r6					; address of the dir entry
    	print	4,<  !XL          !XL	    !AD       !AD>
	cmpl	sdir$l_flink(r4),scs$gq_direct		; any more entries
    	beql	10$					; equal, no
    	movl	sdir$l_flink(r4),r6			; get next entry address
    	getmem	(r6),(r4),#sdir$c_length		; read into local storage
    	blbs	r0,5$					; branch if read o.k.
;
; This is the second half of the summary page, a brief description of the system
; blocks and the number of paths each system has.
;
10$:
    	skip	page
    	skip	1
    	print 	0,<!_!_   --- SCS Systems Summary --->
    	skip	1
    	print	0,<  SB Address     Node      Type       System ID         Paths>
    	print	0,<  ----------     ----      ----       ---------         ----->
    	skip	1

    	getmem	@scs$gq_config,r7			; system block address
    	retiferr
    	movab	sblock,r8				; local storage for sb
15$:
    	getmem	(r7),(r8),#sb$c_length			; read into local storage
    	retiferr

    	bsb	count_paths				; determine number of pb
	pushl	r4					; move count onto stack
    	pushl	sb$b_systemid(r8)			; system id
    	movzwl	sb$b_systemid+4(r8),-(sp)		; high order 2 bytes
    	pushal	sb$t_swtype(r8)				; type of node
    	tstb	sb$t_swtype(r8)				; check for missing type
    	beql	25$					; equal, missing type
    	pushl	#4					;
16$:   	pushab	sb$t_nodename(r8)			; node name
    	pushl	r7					; address of sb
    	print   6,<  !XL      !6<!AC!> 	   !4<!AD!>      !XL!XW	  !UL>

    	movl	sb$l_flink(r8),r7			; move to next sb
    	cmpl	r7,scs$gq_config			; end of list of sb's
    	bneq	15$					; branch if no
;
; We are done so let's get out of here.
;
20$:
    	movl	#1,r0					; return success
    	ret

25$:	pushl	#0			; put zero length on stack for type
    	brb	16$			; continue
    	.dsabl	lsb

Count_paths:
    	clrl	r4			; counter for number of paths
    	addl3	#sb$l_pbfl,r7,r5	; start of list of pb's
    	cmpl	sb$l_pbfl(r8),r5	; any path blocks?
    	beql	35$			; equal, zero pb's
    	movl	sb$l_pbfl(r8),r6	; get next path block
25$:
    	incb	r4			; increment count
    	assume pb$l_flink eq 0
    	getmem  (r6)			; read in link to next pb
    	cmpl	r1,r5	 		; end of list? (assume statement for r1)
    	beql	35$			; equal, yes, so return to caller
    	movl	r1,r6			; follow the link (assume statement for r1)
    	brb	25$			; still in loop of pb's

35$:   	rsb				; return to main line code

    .sbttl	display_sb_pbs --- display all system and path blocks
;---
;
;	display_sb_pbs
;
;	This is a coroutine whose purpose is display each system
;	block and its associated path blocks.
;
;	Inputs:
;
;		none
;
;	Outputs:
;
;		SCS data structures ( as mentioned above) are shown
;		All registers are preserved.
;
;---
display_sb_pbs:
    	.word 	^m<r2,r3,r4,r5,r6,r7,r8,r9,r10,r11>

    	getmem	@scs$gq_config,r3		; system block address
    	retiferr				; return if error
10$:
    	pushl	r3				; pass sb address
    	calls	#1,show_system_block		; easy way out!
    	assume	sb$l_flink eq 0
    	getmem	(r3),r3				; get next address
    	cmpl	r3,scs$gq_config		; are we at the end?
    	bneq	10$				; not equal, still more    

    	movl	#1,r0				; return success
    	ret

    .sbttl	show_connections --- display all connection descriptor tables (CDT)
;---
;
;	show_connections
;
;	This is the main routine whose purpose is to display the contents
;	of each connection descriptor table(CDT). A CDT is used to store
;	information about a virtual circuit between two processes.  The
;	first page is a brief summary of each cdt.
;
;	Inputs:
;
;		AP = pointer to TPARSE block
;
;	Outputs:
;
;		SCS data structures ( as mentioned above) are shown
;		All registers are preserved.
;
;---
        .enabl lsb
null_string:
    	.byte	0
    	.ascii //

show_connections::
    	.word 	^m<r2,r3,r4,r5,r6,r7,r8,r9,r10,r11>
;
;  Header information
;
    	subhd	<VAXcluster data structures>		; set heading
    	skip	page
    	skip	1
    	print	0,<!_!_  --- CDT Summary Page --->
    	skip	1
    	print	0,<CDT Address   Local Process     Connection ID     State       Remote Node>
    	print	0,<-----------   -------------     -------------     -----       ----------->
    	skip	1
;
;  Now set up the data structures.  Read the cdl ( specifically the location
;  containing the first free cdt and the list of cdts).  Then read into local
;  storage the first cdt to display.  Check to see if this cdt is on the free
;  list, if it is then it will not be displayed.  Also if the state of the cdt
;  is closed, it will not be displayed.  Otherwise it will be displayed.
;
    	getmem	@scs$gl_cdl,r6		; address of cdl
    	clrl	cdl_size		; initialize field
    	getmem	cdl$w_size(r6),cdl_size,#2 ; size of cdl to read into virtual memory
    	retiferr			; return on error
    	pushab	cdl			; will contain virtual address for cdl
    	pushab	cdl_size		; size of cdl
    	calls	#2,g^lib$get_vm		; get memory for cdl
    	retiferr			; return on error
    	getmem	-16(r6),@cdl,cdl_size	; read cdl into storage
    	retiferr			; return on error
    	addl3	cdl_size,cdl,r6		; r6 => end address of cdl
    	addl3	#16,cdl,r5		; base of cdl
    	movl	cdl$w_maxconidx(r5),r10	; max number of cdts in table
    	blss	20$			; no cdts in table
    	movl	r5,r7			; save address of cdl

    	clrl	r11			; counter of the number of free cdt's
5$:	cmpl	r7,r6			; safety check for end of list
    	beql	20$			; yes, exit loop
    	bsbw	free_cdt_list		; check to see if on free cdt list
    	blbs	r0,10$			; set, not on free list so display
    	sobgeq	r10,5$			; on free list so don't display
    	brb	20$			; hit end of cdts
10$:	movab	cdt,r9			; local storage for cdt
	getmem	@(r7)+,(r9),#cdt$c_length ; read into local storage
    	pushl	r10			; save r10
    	jsb	display_sumline		; display one line of the summary page
    	movl	(sp)+,r10		; restore r10
    	sobgeq	r10,5$			; get next cdt 
;
;  At this stage the summary page is almost complete.  The last thing to display
;  is the number of free cdt's.  R11 contains this number.
;
20$:	skip	1
    	pushl	r11
    	print	1,<Number of free CDT's:  !UL>
;
;  The summary page is done.  Now we will again loop through all the
;  cdts in use and call upon a routine to display the full contents
;  of each and every one of them.
;
    	movl	cdl$l_freecdt(r5),r4	; first free cdt
    	movl	cdl$w_maxconidx(r5),r10	; max number of cdts in table
30$: 	cmpl	r5,r6			; test for end of list
    	beql	40$			; equal, end of list   	
    	cmpl	(r5),r4		        ; beginning of free cdt's
    	beql	35$			; equal, update r6 to next free cdt
    	skip	page			; new page for each cdt
;
;  First check the state to see if this cdt is marked as closed.  If it is
;  don't bother to display.
;
    	addl3	#cdt$w_state,(r5),r7	; point to cdt state
    	getmem	(r7),r7			; read in state
    	retiferr			; return on error
    	cmpw	r7,#cdt$c_closed	; closed cdt?
    	beql	38$			; equal, disregard closed cdt	

    	movl	(r5)+,-(sp)		; address of cdt
    	calls	#1,display_cdt		; display
    	sobgeq	r10,30$			; get next one
35$:	getmem	@(r5)+,r4		; get next free cdt in r6
    	sobgeq	r10,30$			; loop for next cdt
    	brb	40$			; end of list

38$:	tstl	(r5)+			; increment r5
    	sobgeq	r10,30$			; loop for next valid cdt

40$:
    	pushab	cdl			; address of virtual memory to deall.
    	pushab	cdl_size
    	calls	#2,g^lib$free_vm	; deallocate virtual memory
    	movl	#1,r0			; success
    	ret				; finished!!!
    	.dsabl	lsb


free_cdt_list:
    	movl	#1,r0			; assume not on the cdt free list
    	movl	cdl$l_freecdt(r5),r4	; head of list
5$:	cmpl	(r7),r4			; on the free list
    	beql	10$			; equal, on free list
    	getmem	(r4),r4			; chain down the list
    	retiferr			; return on error
    	tstl	r4			; end of list
    	beql	15$			; yes end of list and no match
    	brb	5$			; loop and compare
10$:	tstl	(r7)+			; point to next cdt in list
	incl	r11			; increment the counter of free cdts
    	clrl	r0			; r0 clr indicates free list
15$:	rsb				; return to caller
    		

    .sbttl	display_sumline --- display a line of the cdt summary page
;---
;
;	display_sumline
;
;	This is the subroutine whose purpose is to display a line of the
;	summary page for the given cdt.
;
;	Inputs:
;
;		R9 = address of cdt in local storage
;
;	Outputs:
;
;		A line of the cdt summary page is displayed.
;
;---
    	.enabl	lsb
display_sumline:
    	cmpw	cdt$w_state(r9),#cdt$c_closed   ; if closed, ignore this cdt
    	bneq	1$			; if not equal, cdt is of interest
    	brw	40$			; neq, not closed so continue to process
;
;  Now obtain the remote node name.  This requires going through a few
;  channels.  The CDT contains the path block address.  The path block
;  will lead us to the system block which yields the remote node name.
;  Follow me.  However if the cdt is a listen cdt,  the remote node name
;  will not be present.  So test first for this condition.
;
1$:    	cmpw    cdt$w_state(r9),#cdt$c_listen		; listen cdt?
    	bneq	5$			; no equal, not a listen cdt
    	pushab  null_string		; listen cdt - no remote node name
    	brb	10$			; 
5$:
    	pushl	r9			; address of cdt in local storage
    	calls	#1,remote_node		; find remote node name
    	pushl	r10			; address of counted ascii string
;
; Cdt's are not the easiest data structure to display.  The key to 
; displaying them correctly is the state and blkstate fields.  The
; strategy is to translate the blkstate field first.  If this succeeds,
; then displaying the cdt follows the normal path.  If this translation
; fails,  then the state field is translated.  The blkst_flag will be
; clear if the translation of it succeeded.  Setting of the flag indicates
; failure.
;
10$:	jsb	state_translate		; translate state value
    	pushl	r0			; address of counted ascii string    	
    	pushl	cdt$l_lconid(r9)	; connection id
;
;  Now to display the local process name.  This also is not as straight forward
;  as it seems.  If the cdt is NOT a listen CDT, then the process name in the
;  cdt is valid.  However if the cdt is a listen cdt, the local process name
;  field will most likely be zero. (Bummer!)  There is hope however for re-
;  trieving the name.  The cdt will have a valid connection id.  Therefore,
;  if search the scs directory looking for a match on connection id,  the
;  entry which matches based on the id will contain the local process name.
;
    	pushl	r9			; address of cdt in local storage
    	calls	#1,find_procname	; find the local process name
    	pushl	r2			; address of process name
	pushl	r3			; maximum length of name
	pushl	-4(r7)			; address of cdt
    	print	6,< !XL     !AD    !XL        !9<!AC!>    !AC>
40$:	rsb				; return to main routine
    	.dsabl	lsb

    .sbttl	state_translate --- translate cdt state values to names
;---
;
;	state_translate
;
;	This is the subroutine whose purpose is to translate the state fields
;	in the given cdt to their corresponding ascii names for display.
;
;	Inputs:
;
;		R9 = address of cdt in local storage
;
;	Outputs:
;
;		State fields in the cdt are translated to meaningful
;		ascii names.
;
;---
state_translate:
;
;  Translate the SCS blocked send state location to their equivalent
;  ascii names.
;
    	movzwl	cdt$w_blkstate(r9),r2	; scs send blocked state
    	movab	cdt_blkstate,r3		; definition table
    	jsb	g^translate_address	; translate constants to names
    	bneq	10$			; not equal, match found
;
;  The translation has failed.  Translate the state value and set the flag
;  to indicate that the blkstate translation has failed.
;
    	movzwl	cdt$w_state(r9),r2	; state value
    	movab	cdt_state,r3		; corresponding definition table
    	jsb	g^translate_address	; translate
10$:	
    	rsb    

    .sbttl	find_procname --- Find the local process name.
;---
;
;	find_procname
;
;	This is the coroutine whose purpose is to find the local process 
; 	name.  If the cdt is a listen cdt, then the local process name in
;	the cdt will not be valid.  We will have to use the scs directory
;	to determine the name.  The connection id of the cdt is used to find
;       the scs directory entry with the local process name for this cdt.
;	If the state of the cdt is other than listen,  then the field in
;	the cdt should be valid.
;
;	Inputs:
;
;		4(AP) = address of cdt in local storage
;
;	Outputs:
;
;		R2 = address of the local process name.
;		R3 = length of the name.
;		All other registers are preserved.
;
;---
find_procname::
    	.word 	^m<r4,r5>

    	movl	4(ap),r5		; get the address of the cdt
    	cmpw	cdt$w_state(r5),#cdt$c_listen	; is this a listen cdt
    	beql	15$				; equal, yes
    	tstl	cdt$l_lprocnam(r5)		; test for zero address
    	beql	10$				; no local process name
    	movab	procname,r2			; address of local process
    	getmem  @cdt$l_lprocnam(r5),(r2),#16    ; read into local storage
    	movl	#16,r3	
    	brw	50$
10$:	movab	null_string,r2			; no local process name
    	movl	#0,r3				; zero length
    	brw	50$
;
;  Search the scs directory for the entry with the same connection id.
;
15$:	movab	directory,r4		; local storage for directory entry
	getmem	@scs$gq_direct,(r4),#sdir$c_length
    	retiferr			; return if error
20$:	cmpl	cdt$l_lconid(r5),sdir$l_conid(r4)
    	beql	30$			; match
    	movl	sdir$l_flink(r4),r3	; next entry
    	getmem	(r3),(r4),#sdir$c_length   ; read into local storage
    	retiferr			; return on error
    	brb	20$
;
30$:	tstb	sdir$b_procnam(r4)	; check if name exists
    	bneq	40$			; not equal, exists
    	movl	#0,r3			; zero length
    	brb	45$			; branch around	
40$:	movl	#16,r3			; length
45$:	movab	sdir$b_procnam(r4),r2	; address of local process name
50$:	ret

    .sbttl	remote_node --- find the remote node name
;---
;
;	remote_node
;
;		This routine is to determine the name of the remote node
;		given the contents of a cdt.  The cdt will give us the path
;		block address which in turn will yield the system block
;		address.  The system block contains the remote node name
;		that is desired.
;
;	Inputs:
;
;		4(ap) = address of cdt in local storage
;
;	Outputs:
;
;		R10 = address of counted ascii string of remote node name.
;		All other registers are preserved.
;
;---
remote_node:    
    	.word 	^m<r2,r3,r4,r5,r8,r9>
    	movl	4(ap),r9		; address of cdt in local storage
    	movl	cdt$l_pb(r9),r8		; path block address
    	addl2	#pb$l_sblink,r8		; point to system block address
    	getmem	(r8),r8			; yields system block address
    	retiferr			; return if error
    	movab	node,r10		; local storage for node name
    	addl2	#sb$t_nodename,r8	; point at node name
    	getmem	(r8),(r10),#sb$s_nodename ; read it into local storage
    	movl	#1,r0			; success
    	ret				; return with address of node name in r10


    .sbttl	display_cdt --- display a connection descriptor table
;---
;
;	display_cdt
;
;	This is a coroutine whose purpose is display each connection
;	descriptor table (CDT). A CDT is used to store information
;	about a virtual circuit between two processes.
;
;	Inputs:
;
;		4(ap) = actual address of cdt
;
;	Outputs:
;
;		CDT is displayed.
;		All registers are preserved.
;
;---
    	.enabl	lsb
display_cdt::
    	.word 	^m<r2,r3,r4,r5,r6,r7,r8,r9,r10,r11>

    	movab	cdt,r9				; local storage for cdt
    	getmem	@4(ap),(r9),#cdt$c_length	; read into local storage
    	retiferr
	skip	1
    	pushl	4(ap)		; actual address of cdt
    	print	0,<!_  --- Connection Descriptor Table (CDT) !XL --->
    	skip	1
;
;  Determine local process name
;
    	cmpw	cdt$w_state(r9),#cdt$c_closed	; if closed, no local process name
    	bneq	1$				; not equal, continue to look
    	pushab	procname			; null process name
    	pushl	#0				; zero length
    	brb	3$				; no local process name available 
1$:	tstl	cdt$l_lprocnam(r9)		; check to see if valid address
    	bneq	2$				; yes there is a process name
    	brw	40$				; go and search for it

2$:	movab	procname,r2			; put into local storage
	getmem	@cdt$l_lprocnam(r9),(r2),#16	; local process name
    	pushl	r2			; push address of process name
    	pushl	#16				; length of name
; 
;  Translate state value to ascii string
;
3$:    	movzwl	cdt$w_state(r9),r2	; state value
    	movab	cdt_state,r3		; corresponding definition table
    	jsb	g^translate_address	; translate
    	bneq	4$			; match found
    	brw	35$			; no match
4$:    	pushl	r0			; translated to names
5$:   	movzwl	cdt$w_state(r9),-(sp)	; state value
    	print	3,<State:  !XW !AC		  Local Process:        !AD>
    					; display
;
;  Determine remote process name if it exists.
;
    	cmpw	cdt$w_state(r9),#cdt$c_closed	; check for closed cdt
    	bneq	10$			; not equal, continue to look for
    	pushab	procname		; null process name
    	pushl	#0			; zero length
    	brb	15$			; no remote node and process available
10$:	tstl	cdt$l_rprocnam(r9)	; check for non-zero address
    	beql	15$			; equal, remote process name not available
    	movab	procname,r2		; local storage for remote process name
    	getmem	@cdt$l_rprocnam(r9),(r2),#16   ; read into local storage
    	pushl	r2			; address of remote process name
    	pushl	#16			; length of name
;
;  Obtain the remote node name.
;
    	pushl	r9			; address of cdt in local storage
    	calls	#1,remote_node		; find remote node
    	pushl	r10			; counted ascii string
;
;  Translate scs blocked send state to ascii string
;
15$:	movzwl	cdt$w_blkstate(r9),r2	; scs send blocked state
    	movab	cdt_blkstate,r3		; definition table
    	jsb	g^translate_address	; translate constants to names
    	bneq	19$			; translate failed if equal
    	brw	30$
19$:	pushl	r0			; address of counted ascii string
20$:   	movzwl	cdt$w_blkstate(r9),-(sp)	; scs send blocked state
;
;  Display
; 
   	cmpw	cdt$w_state(r9),#cdt$c_listen	; check for listen cdt
    	beql	22$				; equal, listen so no remote
    	cmpw	cdt$w_state(r9),#cdt$c_closed	; check for closed cdt
    	beql	22$				; no remote for closed
    	print	5,<Blocked State:  !XW !AC             Remote Node::Process: !AC::!AD>
	brb	23$
22$:	print	2,<Blocked State:  !XW !AC>

23$:    make_symbol	PB, cdt$l_pb(r9)
    	make_symbol	PDT, cdt$l_pdt(r9)  
	skip 	1

    	print_columns -
    		(r9),4(ap),-
    		cdt_col_1,cdt_col_2,cdt_col_3		; display cdt
25$:	movl	#1,r0				; return with success
    	ret					; done

30$:	pushab	null_string
    	brw	20$

35$:	pushab	null_string		; translation failed
    	brw	5$		    	; return to main line code

40$:	pushl	r9			; local address of cdt
    	calls	#1,find_procname	; maybe in the directory entry
    	pushl	r2			; address of local process name
    	pushl	r3			; length of name
    	brw	3$			; return to main line code

   	.dsabl	lsb

    .sbttl	cdt_byaddr --- display the cdt requested by the user
;---
;
;	cdt_byaddr
;
;	This is a routine whose purpose is display a connection
;	descriptor table (CDT) which the user has requested by using
;	the /ADDR qualifier and a valid address of a cdt. A CDT is 
;	used to store information about a virtual circuit between 
;	two processes.
;
;	Inputs:
;
;		AP = TPARSE block (TPA$L_NUMBER contains the address)
;
;	Outputs:
;
;		The requested CDT is displayed if a valid address is specified.
;		Otherwise an informational message is sent to say invalid cdt
;		address.
;		All registers are preserved.
;
;---
    	.enabl	lsb
cdt_byaddr::
    	.word 	^m<r2,r3,r4,r5,r6,r7,r8,r9,r10,r11>
    	movl	tpa$l_number(ap),r7		; get address of cdt
    	jsb	verify_cdt			; is this a cdt
    	blbc	r0,10$				; clear, not a cdt
;
;  Now that we are through the validation phase the rest is trivial.
;
    	skip	page
    	pushl	r7				; pass the actual address
    	calls	#1, display_cdt			; display it
10$:
    	movl	#1,r0
    	ret

verify_cdt:
    	tstl	r7				; check for 80000000 address
    	bgeq	900$				; not valid
    	addl3	#cdt$b_type,r7,r8		; point at the type field
    	getmem	(r8),r8				; attempt to read
    	retiferr				; return on error
    	cmpb	r8,#dyn$c_scs			; check for the right type
    	bneq	900$				; not equal, error
    	ashl	#-8,r8,r8			; point at subtype
    	cmpb	r8,#dyn$c_scs_cdt		; check for correct subtype
    	bneq	900$				; not equal, invalid address
    	movl	#1,r0				; valid cdt
    	rsb

900$:	pushl	r7				; invalid cdt address		
    	type	1,<!XL is not the address of a CDT>
    	movl	#0,r0				; invalid cdt
    	rsb

    	.dsabl	lsb

    .sbttl	connection descriptor tables & action routines
;
;   PRINT_COLUMNS table for CDT displays
;


cdt_col_1:
    	column_list	-
    		cdt$, 16, 8, 4, < -
    		<<Local Con. ID>,l_lconid,xl>,-
    		<<Remote Con. ID>,l_rconid,xl>,-
    		<<Receive Credit>,w_rec,uw>,-
    		<<Send Credit>,w_send,uw>,-
    		<<Min. Rec. Credit>,w_minrec,uw>,-
    		<<Pend Rec. Credit>,w_pendrec,uw>,-
    		<<Initial Rec. Credit>,w_initlrec,uw,20,4>,-
    		<<Rem. Sta.>,cdt_6bytes,cdt$b_rstation,12,12>, -
    		<<Rej/Disconn Reason>,w_reason,uw,20,4>,-
    		<<Queued for BDT>,w_qbdt_cnt,uw>,-
    		<<Queued Send Credit>,w_qcr_cnt,uw,20,4>,-
    		>

cdt_col_2:
    	column_list	-
    		cdt$, 16, 8, 4, < -
    		<<Datagrams sent>,l_dgsent,ul>,-
    		<<Datagrams rcvd>,l_dgrcvd,ul>,-
    		<<Datagram discard>,l_dgdiscard,ul>,-
    		<<Messages Sent>,l_msgsent,ul>,-
    		<<Messages Rcvd.>,l_msgrcvd,ul>,-
    		<<Send Data Init.>,l_snddats,ul>,-
    		<<Req Data Init.>,l_reqdats,ul>,-
    		<<Bytes Sent>,l_bytsent,ul>,-
    		<<Bytes rcvd>,l_bytreqd,ul>,-
    		<<Total bytes map>,l_bytmapd,ul>,-
    		>

cdt_col_3:
    	column_list	-
    		cdt$, 16, 8, 0, < -
    		<<Message queue>,l_waitqfl,q2>,-
    		<<Send Credit Q.>,l_crwaitqfl,q2>,-
    		<<PB address>,l_pb,xl>,-
    		<<PDT address>,l_pdt,xl>,-
    		<<Error Notify>,l_erraddr,xl>,-
    		<<Receive Buffer>,l_scsmsg,xl>,-
    		<<Connect Data>, l_condat,xl>,-
    		<<Aux. Structure>,l_auxstruc,xl>,-
    		>    		
;
;   The following are all PRINT_COLUMNS action routines for the show 
;   connection descriptor table displays.
;
;   Action Routine Inputs:
;
;	R2	value from the COLUMN_LIST entry
;	R5	size of value section for this item
;	R7	address of a descriptor for a scratch string in
;		which the FAO converted value is to be returned
;	R11	base address of the local CDT copy
;
;   Action Routine Outputs:
;
;	R0	status
;		lbs ==> use this entry
;		lbc ==> skip this entry
;	R1-R5   scratch
;		all other registers must be preserved
;
cdt_fao_6bytes:
    	string	<!XW!XL>

;*********
cdt_6bytes:
    	addl3	r2,r11,r3		; locate storage of interest
    	subl	#12,r5			; get size of filler field
    	$fao_s	-
    		ctrstr = cdt_fao_6bytes,-
    		outbuf = (r7),-
    		outlen = (r7),-
    		p1 = r5,-
    		p2 = (r3),-
    		p3 = 4(r3)
    	rsb

    .sbttl	show_rspid --- display RDT entries
;---
;
;	show_rspid
;
;	This is the main routine whose purpose is to display the contents
;	of the response descriptor table(RDT).  If an address of a connection
;	descriptor table is specified, then only those entries with the same
;	cdt will be displayed.
;	
;
;	Inputs:
;
;		AP = pointer to TPARSE block
;		CDT_SPCFY = 1 means /CONNECTION qualifier was present
;			    0 means the qualifier was absent
;
;	Outputs:
;
;		All RDT entries are displayed unless they are on the free list
;		or are permanently allocated in which cases they are of no
;		interest to us.
;		All registers are preserved.
;
;---
        .enabl lsb

show_rspid::
    	.word 	^m<r2,r3,r4,r5,r6,r7,r8,r9,r10,r11>

    	clrl	r7				; initialize cdt address
    	tstl	cdt_spcfy			; cdt address specified?
    	beql	5$				; equal, no address
    	movl	tpa$l_number(ap),r7		; cdt address
    	clrl	cdt_spcfy			; clear for next round
    	jsb	verify_cdt			; check validity of cdt
    	blbs	r0,5$				; valid cdt 
    	brw	40$				; not a cdt
;
;  Header information
;
5$:    	subhd	<VAXcluster data structures>		; set heading
    	skip	page
    	skip	1
    	getmem	@scs$gl_rdt,r6		; address of rdt
    	retiferr
    	pushl	r6			
    	print	1,<!_--- Summary of Response Descriptor Table(RDT) !XL --->
    	skip	1
    	print	0,<RSPID      CDRP Address     CDT Address     Local Process Name      Remote Node>
    	print	0,<-----      ------------     -----------     ------------------      ----------->
    	skip	1
;
;  Now set up the data structures.  Read the rdt ( specifically the location
;  containing the first free rd and the list of rds).  Then read into local
;  storage the first rd to display.  Check to see if this rd is on the free
;  list, if it is then it will not be displayed.  Also if rd is permanently
;  allocated, it will not be displayed.  Otherwise it will be displayed.
;
    	clrl	rdt_size		; initialize field
    	getmem	rdt$w_size(r6),rdt_size,#2 ; size of rdt to read into virtual memory
    	retiferr			; return on error
    	pushab	rdt			; will contain virtual address for rdt
    	pushab	rdt_size		; size of rdt
    	calls	#2,g^lib$get_vm		; get memory for rdt
    	retiferr			; return on error
    	assume  rdt$c_length  eq  24
    	getmem	-24(r6),@rdt,rdt_size	; read rdt into storage
    	retiferr			; return on error
    	addl3	rdt_size,rdt,r9		; r9 => end address of rdt
    	addl3	#rdt$c_length,rdt,r5	; base of rdt
    	movl	rdt$l_maxrdidx(r5),r10	; max index of rdt
    	movl	rdt$l_freerd(r5),r8	; address of first free rdt entry
    	movl	r5,r3			; save base of rdt in r3    	

    	clrl	r4			; initialize index counter to 0
10$:	cmpl	r5,r9			; check for end of rd list
    	beql	40$			; equal, end of list
    	cmpl	(r5),r8			; check to see if rd is free
    	beql	20$			; equal, hit a free rd
    	bbc	#rd$v_busy,4(r5),30$    ; not interested in perm. allocated rd's
    	tstl	r7			; cdt address specified
    	bneq	50$			; yes, so check for a match on cdt
15$:	pushl	r4			; index counter
    	pushl	r5			; address of rd entry
    	calls	#1,display_rd_entry	; display one line of the summary page
    	incl	r4			; increment index counter
    	addl2	#8,r5			; advance to the next entry
    	sobgeq	r10,10$			; get next rd
    	brb	40$			; end of list
20$:	movl	(r5),r8			; next free rd
30$:	incl	r4			; increment index counter
    	addl2	#8,r5			; advance to the next entry
    	sobgeq	r10,10$			; get next free rd
;
;  Now that all the busy rdt entries have been displayed, let's walk through
;  the wait queue and display its contents.  These entries will not have a 
;  rspid since that is the reason they are in the wait queue.
;
40$:	addl3	#rdt$l_waitfl,r6,r6		; start of wait queue
    	movab	wait_cdrp,r5			; address to hold cdrp
    	movl	rdt$l_waitfl(r3),(r5)		; first entry in wait queue
41$:	cmpl	r6,(r5)				; end of queue?
    	beql	45$				; yes, so exit    		
    	pushl	#-1				; not available rspid
    	pushl	r5				; address of cdrp address
    	calls	#2,display_rd_entry		; display
    	getmem	@(r5),(r5),#4			; get next entry
    	retiferr				; return on error
    	brb	41$				; loop
45$:
    	pushab	rdt				; 
    	pushab	rdt_size			; size to deallocate
    	calls	#2,g^lib$free_vm		; deallocate virtual memory
    	movl	#1,r0				; success status
    	ret

50$:
    	movl	(r5),r8			; cdrp address
    	addl3	#cdrp$l_cdt,r8,r8	; point to cdt address
    	getmem	(r8),r8			; cdt address
    	cmpl	r8,r7			; match?
    	bneq	30$			; not equal, don't display
    	brw	15$			; do display


    .sbttl	display_rd_entry --- display an entry in the response descriptor table
;---
;
;	display_rd_entry
;
;	This is a coroutine whose purpose is display each entry in the 
;	response descriptor table (RDT). A RDT is used to provide a
;	match between a rspid and its CDRP.
;
;	Inputs:
;
;		4(ap) = rd entry in local storage
;		8(ap) = index portion of rspid
;
;	Outputs:
;
;		A rd entry is displayed.
;		All registers are preserved.
;
;---
    	.enabl	lsb
no_rspid:
    	.ascic /waiting/
display_rd_entry::
    	.word 	^m<r2,r3,r4,r5,r6,r7,r8,r9,r10,r11>

    	movl	4(ap),r4		; address of rd in local storage
    	movl	(r4),r5			; cdrp address
    	addl3	#cdrp$l_cdt,r5,r6	; cdt address
    	getmem	(r6),r6			; get pointer to cdt from cdrp
    	tstl	r6			; test for valid cdt
    	bgeq	10$			; cdt is not valid
    	movab	cdt,r7			; address of local storage for cdt
    	getmem	(r6),(r7),#cdt$c_length ; read into local storage
    	retiferr			; return on error
    	pushl	r7			; address of cdt in local storage
    	calls	#1,remote_node		; find the remote node
    	pushl	r10			; counted ascii string
    	pushl	r7			; address of cdt in local storage
    	calls	#1,find_procname	; find the local process name
    	pushl	r2			; address of local process name
    	pushl	r3			; length of name	
    	pushl	r6			; cdt address
5$:    	pushl	r5			; cdrp address
    	tstl	8(ap)			; rspid available
    	blss	20$			; branch if not available		
    	movw	#0,4(r4)		; zero the state field
    	bisl3	4(r4),8(ap),r7		; yields the rspid
    	pushl	r7			; rspid
    	print	6,<!XL     !XL        !XL       !AD        !AC>
7$:    	movl	#1,r0
    	ret

10$:	pushab	null_string		; empty string for node name
	pushl	#0			; length of remote node name
	pushl	#0			; cdt address
	brb	5$

20$:	pushab	no_rspid
    	print	5,<  !AC       !XL           !XL       !AD>
    	brb	7$

    .dsabl	lsb

    .sbttl	show_ports --- display all port descriptor tables (PDT)
;---
;
;	show_ports
;
;	This is the main routine whose purpose is to display the contents
;	of each port descriptor table (PDT). A PDT is used to store
;	scs entry addresses and port independent bookkeeping.  The first
;	page is a summary.
;
;	Inputs:
;
;		AP = pointer to TPARSE block
;
;	Outputs:
;
;		SCS data structures ( as mentioned above) are shown
;		All registers are preserved.
;
;---
        .enabl lsb
show_ports::
    	.word 	^m<r2,r3,r4,r5,r6,r7,r8,r9,r10,r11>
;
;  Header information
;
    	subhd	<VAXcluster data structures>		; set heading
    	skip	page
    	skip	1
    	print	0,<!_!_  --- PDT Summary Page --->
    	skip	1
    	print	0,< PDT Address	      Type    	   Device          Driver Name>
    	print	0,< -----------          ----         -------         ----------->
    	skip	1
;
;  Read the contents of the pdt into local storage
;
    	movab	pdt,r4				; local storage for pdt
    	getmem	@scs$gl_pdt,r5			; get address of 1st pdt
    	retiferr				; return on error
    	movl	r5,r11				; save the pdt address
10$:	getmem	(r5),(r4),#pdt$c_length		; read pdt into local storage
    	retiferr				; return on error

;
;  Get the driver name from the device data block (DDB).
;
    	movl	pdt$l_ucb0(r4),r2		; ucb address
    	addl3	#ucb$l_ddb,r2,r3		; point to the ddb
    	getmem	(r3),r6				; ddb address
    	addl3	#ddb$b_drvnam_len,r6,r8		; driver name length
    	getmem	(r8),r9				; read it in
    	retiferr				; return on error
    	movzbl	r9,r9				; zero the other fields
    	movab	driver_name,r7			; local storage for driver name
    	addl3	#ddb$t_drvname,r6,r8		; point to driver name
    	getmem	1(r8),(r7),r9			; read into local storage
    	retiferr				; return on error
    	pushl	r7				; address of driver name
    	pushl	r9				; length of driver name
;
;  Put together the device name by pulling the unit number from the ucb and
;  the device name from the device data block (DDB).
;
    	addl3	#ucb$w_unit,r2,r2		; point to the unit field
    	getmem	(r2),r2				; unit number
    	movzwl	r2,-(sp)			; put on the stack
    	addl3	#ddb$b_name_len,r6,r8		; point to length field
    	getmem	(r8),r7				; read the field
    	retiferr				; return on error
    	movzbl	r7,r7				; zero the other fields
    	addl3	#ddb$t_name,r6,r8		; point to name field
    	movab	device_name,r6			; local storage for name
    	getmem	1(r8),(r6),r7			; read the name
    	retiferr				; return on error
    	pushl	r6				; address of name
    	pushl	r7				; push length on stack
;
;  Get the type of port (PA, PU, PE, PS).
;
    	movzbl	pdt$b_pdt_type(r4),r2		; port type
    	movab	pdt_type,r3			; translation table
    	jsb	g^translate_address		; translate constant to name
    	pushl	r0				; address of ascii name  	
    	pushl	r5				; pdt address
    	print	6,<  !XL             !AC	   !AD!UW            !AD>

    	tstl	pdt$l_flink(r4)			; is there another pdt
    	beql	20$				; equal, no
    	movl	pdt$l_flink(r4),r5		; next pdt to display
    	brw	10$				; loop for another pdt
;
;  Now that the summary page is complete, let's go on to display each pdt
;  in full.
;
    	assume pdt$l_flink eq 0
20$:	pushl	r11				; actual address of pdt
    	calls	#2,display_pdt			; display this pdt
    	getmem	(r11),r11			; read link field
    	retiferr				; return on error
    	tstl	r11				; another pdt
    	bneq	20$				; not equal, display next pdt
	
    	movl	#1,r0				; return with success
    	ret


    .sbttl	display_pdt --- display a port descriptor table
;---
;
;	display_pdt
;
;	This is a coroutine whose purpose is display each port
;	descriptor table (PDT). 
;
;	Inputs:
;
;		4(ap) = actual address of pdt 
;
;	Outputs:
;
;		PDT is displayed.
;		All registers are preserved.
;
;---
    	.enabl	lsb
display_pdt::
    	.word 	^m<r2,r3,r4,r5,r6,r7,r8,r9,r10,r11>

    	skip	page
    	skip	1
    	pushl	4(ap)
    	print	0,<!_!_  --- Port Descriptor Table (PDT) !XL --->
    	skip	1

    	moval	pdt,r5				; local storage for pdt
    	getmem	@4(ap),(r5),#pdt$c_length	; read it in
    	retiferr				; return on error
;
;  Translate port type
;
    	movzbl	pdt$b_pdt_type(r5),r2
    	movab	pdt_type,r3
    	jsb	g^translate_address		; get the ascii name for the
    						; port type
    	pushl	r0				; counted ascii string
    	movzbl	pdt$b_pdt_type(r5),-(sp)	; port type
    	print	2,<Type: !XB !AC>
;
;  Translate port characteristics
;
    	alloc	80				; output buffer
    	movzwl	pdt$w_portchar(r5),-(sp)	; port characteristics
    	pushab	port_char			; bit definition table
    	calls	#2,translate_bits		; translate bits to names
    	pushl	sp				; address of string descriptor
    	movzwl	pdt$w_portchar(r5),-(sp)	; port characteristics
    	print	2,<Characteristics: !XW !AS>
    	addl2	#80,sp				; clean up the stack
    	skip 	1
;
;  Display the rest of the pdt
;
    	make_symbol	UCB, pdt$l_ucb0(r5)
    	make_symbol	ADP, pdt$l_adp(r5)

    	print_columns	-
    		(r5),4(ap),-
    		pdt_col_1,pdt_col_2,pdt_col_3	; display
    	movl	#1,r0				; return with success
    	ret
    	.dsabl	lsb

    .sbttl	pdt_byaddr --- display the pdt requested by the user
;---
;
;	pdt_byaddr
;
;	This is a routine whose purpose is display a port
;	descriptor table (PDT) which the user has requested by using
;	the /ADDR qualifier and a valid address of a pdt. 
;
;	Inputs:
;
;		AP = TPARSE block (TPA$L_NUMBER contains the address)
;
;	Outputs:
;
;		The requested PDT is displayed if a valid address is specified.
;		Otherwise an informational message is sent to say invalid pdt
;		address.
;		All registers are preserved.
;
;---
    	.enabl	lsb
pdt_byaddr::
    	.word 	^m<r2,r3,r4,r5,r6,r7,r8,r9,r10,r11>
    	movl	tpa$l_number(ap),r7		; get address of pdt
    	jsb	verify_pdt			; is this a pdt
    	blbc	r0,10$				; clear, not a pdt
;
;  Now that we are through the validation phase the rest is trivial.
;
    	subhd	<VAXcluster data structures>		; set heading
    	skip	page
    	pushl	r7				; pass the actual address
    	calls	#1, display_pdt			; display it
10$:
    	movl	#1,r0
    	ret

verify_pdt:
    	tstl	r7				; check for 80000000 address
    	bgeq	900$				; not valid
    	addl3	#pdt$b_type,r7,r8		; point at the type field
    	getmem	(r8),r8				; attempt to read
    	retiferr				; return on error
    	cmpb	r8,#dyn$c_scs			; check for the right type
    	bneq	900$				; not equal, error
    	ashl	#-8,r8,r8			; point at subtype
    	cmpb	r8,#dyn$c_scs_pdt		; check for correct subtype
    	bneq	900$				; not equal, invalid address
    	movl	#1,r0				; valid pdt
    	rsb

900$:	pushl	r7				; invalid pdt address		
    	type	1,<!XL is not the address of a PDT>
    	movl	#0,r0				; invalid pdt
    	rsb
    	.dsabl	lsb

    .sbttl	port descriptor tables & action routines
;
;   PRINT_COLUMNS table for PDT displays
;


pdt_col_1:
    	column_list	-
    		pdt$, 20, 8, 2, < -
    		<<Msg Header Size>,l_msghdrsz,ul>,-
    		<<Max Xfer Bcnt>,l_maxbcnt,xl>,-
    		<<DG Header Size>,l_dgovrhd,ul>,-
    		<<Poller Sweep>,l_pollsweep,ul>,-
    		<<Fork Block W.Q.>,l_waitqfl,q2>,-
    		<<UCB Address>,l_ucb0,xl>,-
    		<<ADP Address>,l_adp,xl>,-
    		<<Accept>,l_accept,xl>,-
    		<<Alloc_Dg_Buf>,l_allocdg,xl>,-
    		<<Alloc_Msg_Buf>,l_allocmsg,xl>,-
    		<<Dealloc_Msg_Buf>,l_deallomsg,xl>,-
    		<<Dealloc_Msg_Buf_Reg>,l_dealrgmsg,xl>,-
    		>
pdt_col_2:
    	column_list	-
    		pdt$, 15, 8, 2, < -
    		<<Connect>,l_connect,xl>,-
    		<<Dealloc_Dg_Buf>,l_deallocdg,xl>,-
    		<<Disconnect>,l_dconnect,xl>,-
    		<<Unmap>,l_unmap,xl>,-
    		<<Map>,l_map,xl>,-
    		<<Map_Bypass>,l_mapbypass,xl>,-
    		<<Map_Irp>,l_mapirp,xl>,-
    		<<Map_Irp_Bypass>,l_mapirpbyp,xl>,-
    		<<Queue_Dg_Buf>,l_queuedg,xl>,-
    		<<Queue_Mult_Dgs>,l_queuemdgs,xl>,-
    		<<Recycl_Msg_Buf>,l_rclmsgbuf,xl>,-
    		<<Reject>,l_reject,xl>,-
    		>
pdt_col_3:
    	column_list	-
    		pdt$, 17, 8, 0, < -
    		<<Recyclh_Msg_Buf>,l_rchmsgbuf,xl>,-
    		<<Request_Data>,l_reqdata,xl>,-
    		<<Send_Data>,l_senddata,xl>,-
    		<<Send_Dg_Buf>,l_senddg,xl>,-
    		<<Send_Msg_Buf>,l_sendmsg,xl>,-
    		<<Send_Cnt_Msg_Buf>,l_sndcntmsg,xl>,-
    		<<Read_Count>,l_readcount,xl>,-
    		<<Rls_Read_Count>,l_rlscount,xl>,-
    		<<Mreset>,l_mreset,xl>,-
    		<<Mstart>,l_mstart,xl>,-
    		<<Stop_Vcs>,l_stop_vcs,xl>,-
    		<<Send_Dg_Reg>,l_sendrgdg,xl>,-
    		>
    .end

